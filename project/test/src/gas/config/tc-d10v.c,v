head	1.46;
access;
symbols
	binutils-2_24-branch:1.46.0.2
	binutils-2_24-branchpoint:1.46
	binutils-2_21_1:1.45
	binutils-2_23_2:1.45
	binutils-2_23_1:1.45
	binutils-2_23:1.45
	binutils-2_23-branch:1.45.0.8
	binutils-2_23-branchpoint:1.45
	binutils-2_22_branch:1.45.0.6
	binutils-2_22:1.45
	binutils-2_22-branch:1.45.0.4
	binutils-2_22-branchpoint:1.45
	binutils-2_21:1.45
	binutils-2_21-branch:1.45.0.2
	binutils-2_21-branchpoint:1.45
	binutils-2_20_1:1.42.8.1
	binutils-2_20:1.42.8.1
	binutils-arc-20081103-branch:1.42.0.10
	binutils-arc-20081103-branchpoint:1.42
	binutils-2_20-branch:1.42.0.8
	binutils-2_20-branchpoint:1.42
	dje-cgen-play1-branch:1.42.0.6
	dje-cgen-play1-branchpoint:1.42
	arc-20081103-branch:1.42.0.4
	arc-20081103-branchpoint:1.42
	binutils-2_19_1:1.42
	binutils-2_19:1.42
	binutils-2_19-branch:1.42.0.2
	binutils-2_19-branchpoint:1.42
	binutils-2_18:1.41
	binutils-2_18-branch:1.41.0.2
	binutils-2_18-branchpoint:1.41
	binutils-csl-coldfire-4_1-32:1.38
	binutils-csl-sourcerygxx-4_1-32:1.38
	binutils-csl-innovasic-fido-3_4_4-33:1.38
	binutils-csl-sourcerygxx-3_4_4-32:1.34
	binutils-csl-coldfire-4_1-30:1.38
	binutils-csl-sourcerygxx-4_1-30:1.38
	binutils-csl-coldfire-4_1-28:1.38
	binutils-csl-sourcerygxx-4_1-29:1.38
	binutils-csl-sourcerygxx-4_1-28:1.38
	binutils-csl-arm-2006q3-27:1.38
	binutils-csl-sourcerygxx-4_1-27:1.38
	binutils-csl-arm-2006q3-26:1.38
	binutils-csl-sourcerygxx-4_1-26:1.38
	binutils-csl-sourcerygxx-4_1-25:1.38
	binutils-csl-sourcerygxx-4_1-24:1.38
	binutils-csl-sourcerygxx-4_1-23:1.38
	binutils-csl-sourcerygxx-4_1-21:1.38
	binutils-csl-arm-2006q3-21:1.38
	binutils-csl-sourcerygxx-4_1-22:1.38
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.38
	binutils-csl-sourcerygxx-4_1-20:1.38
	binutils-csl-arm-2006q3-19:1.38
	binutils-csl-sourcerygxx-4_1-19:1.38
	binutils-csl-sourcerygxx-4_1-18:1.38
	binutils-csl-renesas-4_1-9:1.38
	binutils-csl-sourcerygxx-3_4_4-25:1.34
	binutils-csl-renesas-4_1-8:1.38
	binutils-csl-renesas-4_1-7:1.38
	binutils-csl-renesas-4_1-6:1.38
	binutils-csl-sourcerygxx-4_1-17:1.38
	binutils-csl-sourcerygxx-4_1-14:1.38
	binutils-csl-sourcerygxx-4_1-15:1.38
	binutils-csl-sourcerygxx-4_1-13:1.38
	binutils-2_17:1.38
	binutils-csl-sourcerygxx-4_1-12:1.38
	binutils-csl-sourcerygxx-3_4_4-21:1.38
	binutils-csl-wrs-linux-3_4_4-24:1.34
	binutils-csl-wrs-linux-3_4_4-23:1.34
	binutils-csl-sourcerygxx-4_1-9:1.38
	binutils-csl-sourcerygxx-4_1-8:1.38
	binutils-csl-sourcerygxx-4_1-7:1.38
	binutils-csl-arm-2006q1-6:1.38
	binutils-csl-sourcerygxx-4_1-6:1.38
	binutils-csl-wrs-linux-3_4_4-22:1.34
	binutils-csl-coldfire-4_1-11:1.38
	binutils-csl-sourcerygxx-3_4_4-19:1.38
	binutils-csl-coldfire-4_1-10:1.38
	binutils-csl-sourcerygxx-4_1-5:1.38
	binutils-csl-sourcerygxx-4_1-4:1.38
	binutils-csl-wrs-linux-3_4_4-21:1.34
	binutils-csl-morpho-4_1-4:1.38
	binutils-csl-sourcerygxx-3_4_4-17:1.38
	binutils-csl-wrs-linux-3_4_4-20:1.34
	binutils-2_17-branch:1.38.0.4
	binutils-2_17-branchpoint:1.38
	binutils-csl-2_17-branch:1.38.0.2
	binutils-csl-2_17-branchpoint:1.38
	binutils-csl-gxxpro-3_4-branch:1.34.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.34
	binutils-2_16_1:1.34
	binutils-csl-arm-2005q1b:1.34
	binutils-2_16:1.34
	binutils-csl-arm-2005q1a:1.34
	binutils-csl-arm-2005q1-branch:1.34.0.4
	binutils-csl-arm-2005q1-branchpoint:1.34
	binutils-2_16-branch:1.34.0.2
	binutils-2_16-branchpoint:1.34
	csl-arm-2004-q3d:1.33
	csl-arm-2004-q3:1.33
	binutils-2_15:1.33
	binutils-2_15-branchpoint:1.33
	csl-arm-2004-q1a:1.33
	csl-arm-2004-q1:1.33
	binutils-2_15-branch:1.33.0.6
	cagney_bfdfile-20040213-branch:1.33.0.4
	cagney_bfdfile-20040213-branchpoint:1.33
	cagney_bigcore-20040122-branch:1.33.0.2
	cagney_bigcore-20040122-branchpoint:1.33
	csl-arm-2003-q4:1.33
	binutils-2_14:1.32
	binutils-2_14-branch:1.32.0.2
	binutils-2_14-branchpoint:1.32
	binutils-2_13_2_1:1.28
	binutils-2_13_2:1.28
	binutils-2_13_1:1.28
	binutils-2_13:1.28
	binutils-2_13-branchpoint:1.28
	binutils-2_13-branch:1.28.0.2
	binutils-2_12_1:1.24
	binutils-2_12:1.24
	binutils-2_12-branch:1.24.0.2
	binutils-2_12-branchpoint:1.24
	cygnus_cvs_20020108_pre:1.24
	binutils-2_11_2:1.16.2.1
	binutils-2_11_1:1.16.2.1
	binutils-2_11:1.16
	x86_64versiong3:1.16
	binutils-2_11-branch:1.16.0.2
	binutils-2_10_1:1.8
	binutils-2_10:1.8
	binutils-2_10-branch:1.8.0.2
	binutils-2_10-branchpoint:1.8
	binutils_latest_snapshot:1.46
	repo-unification-2000-02-06:1.7
	binu_ss_19990721:1.5
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.46
date	2012.11.09.08.29.32;	author hjl;	state Exp;
branches;
next	1.45;

1.45
date	2010.08.25.11.51.07;	author amodra;	state Exp;
branches;
next	1.44;

1.44
date	2009.12.11.13.42.10;	author nickc;	state Exp;
branches;
next	1.43;

1.43
date	2009.09.10.14.31.22;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2007.10.17.16.45.55;	author nickc;	state Exp;
branches
	1.42.8.1;
next	1.41;

1.41
date	2007.07.03.11.01.04;	author nickc;	state Exp;
branches;
next	1.40;

1.40
date	2007.02.28.18.38.51;	author nickc;	state Exp;
branches;
next	1.39;

1.39
date	2006.06.07.11.27.57;	author amodra;	state Exp;
branches;
next	1.38;

1.38
date	2005.06.07.17.54.16;	author zack;	state Exp;
branches;
next	1.37;

1.37
date	2005.05.05.09.12.54;	author nickc;	state Exp;
branches;
next	1.36;

1.36
date	2005.04.20.17.40.01;	author hjl;	state Exp;
branches;
next	1.35;

1.35
date	2005.03.24.20.40.25;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	2005.02.23.12.28.04;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2003.11.21.00.24.40;	author kazu;	state Exp;
branches;
next	1.32;

1.32
date	2003.01.23.12.51.04;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2002.12.17.01.13.55;	author kazu;	state Exp;
branches;
next	1.30;

1.30
date	2002.11.30.08.39.43;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2002.09.05.00.01.17;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2002.05.30.16.16.30;	author trix;	state Exp;
branches;
next	1.27;

1.27
date	2002.05.09.13.12.57;	author kazu;	state Exp;
branches;
next	1.26;

1.26
date	2002.04.16.02.58.11;	author trix;	state Exp;
branches;
next	1.25;

1.25
date	2002.04.03.19.44.05;	author trix;	state Exp;
branches;
next	1.24;

1.24
date	2001.12.12.07.32.47;	author aoliva;	state Exp;
branches;
next	1.23;

1.23
date	2001.12.04.17.30.43;	author aoliva;	state Exp;
branches;
next	1.22;

1.22
date	2001.12.04.10.07.03;	author aoliva;	state Exp;
branches;
next	1.21;

1.21
date	2001.11.29.18.23.11;	author aoliva;	state Exp;
branches;
next	1.20;

1.20
date	2001.11.29.18.04.12;	author aoliva;	state Exp;
branches;
next	1.19;

1.19
date	2001.11.15.21.28.55;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2001.09.19.05.33.22;	author hjl;	state Exp;
branches;
next	1.17;

1.17
date	2001.03.08.23.24.23;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2001.01.14.18.54.06;	author kazu;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2000.12.22.22.06.32;	author dj;	state Exp;
branches;
next	1.14;

1.14
date	2000.12.05.00.56.04;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2000.08.04.01.01.32;	author kazu;	state Exp;
branches;
next	1.12;

1.12
date	2000.07.27.04.05.05;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2000.05.25.22.35.05;	author dlindsay;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.12.18.03.58;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.12.17.59.32;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2000.02.18.18.45.28;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	99.10.21.13.49.38;	author dnovillo;	state Exp;
branches;
next	1.6;

1.6
date	99.10.07.06.17.03;	author dnovillo;	state Exp;
branches;
next	1.5;

1.5
date	99.06.22.14.35.17;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	99.06.22.14.07.32;	author ian;	state Exp;
branches;
next	1.3;

1.3
date	99.06.17.02.13.18;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	99.06.03.00.29.24;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.42;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.42.8.1
date	2009.09.10.14.33.15;	author amodra;	state Exp;
branches;
next	;

1.16.2.1
date	2001.06.07.03.15.28;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.42;	author rth;	state Exp;
branches;
next	;


desc
@@


1.46
log
@Remove trailing redundant `;'

bfd/

	* aout-tic30.c (MY_final_link_callback): Remove trailing
	redundant `;'.
	* coff-h8500.c (extra_case): Likewise.
	(bfd_coff_reloc16_get_value): Likewise.
	* dwarf2.c (_bfd_dwarf2_cleanup_debug_info): Likewise.
	* elf.c (_bfd_elf_slurp_version_tables): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_perform_relocation): Likewise.
	* opncls.c (bfd_calc_gnu_debuglink_crc32): Likewise.
	* plugin.c (add_symbols): Likewise.
	* reloc.c (bfd_check_overflow): Likewise.
	* vms-lib.c (_bfd_vms_lib_archive_p): Likewise.

binutils/

	* coffgrok.c (coff_grok): Remove trailing redundant `;'.
	* resrc.c (open_input_stream): Likewise.

gas/

	* config/atof-ieee.c (gen_to_words): Remove trailing redundant
	`;'.
	* config/atof-vax.c (flonum_gen2vax): Likewise.
	* config/tc-d10v.c (write_2_short): Likewise.
	* config/tc-i386-intel.c (i386_intel_simplify): Likewise.
	* config/tc-s390.c (tc_s390_force_relocation): Likewise.
	* config/tc-v850.c (md_parse_option): Likewise.
	* config/tc-xtensa.c (find_address_of_next_align_frag): Likewise.
	* dwarf2dbg.c (out_header): Likewise.
	* symbols.c (dollar_label_name): Likewise.
	(fb_label_name): Likewise.

ld/

	* testplug.c (record_add_file): Remove trailing redundant `;'.

opcodes/

	* aarch64-opc.h (gen_mask): Remove trailing redundant `;'.
	* ia64-gen.c (fetch_insn_class): Likewise.
@
text
@/* tc-d10v.c -- Assembler code for the Mitsubishi D10V
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2006,
   2007, 2009, 2010
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 51 Franklin Street - Fifth Floor,
   Boston, MA 02110-1301, USA.  */

#include "as.h"
#include "safe-ctype.h"
#include "subsegs.h"
#include "opcode/d10v.h"
#include "elf/ppc.h"
#include "dwarf2dbg.h"

const char comment_chars[]        = ";";
const char line_comment_chars[]   = "#";
const char line_separator_chars[] = "";
const char *md_shortopts          = "O";
const char EXP_CHARS[]            = "eE";
const char FLT_CHARS[]            = "dD";

int Optimizing = 0;

#define AT_WORD_P(X) ((X)->X_op == O_right_shift \
		      && (X)->X_op_symbol != NULL \
		      && symbol_constant_p ((X)->X_op_symbol) \
		      && S_GET_VALUE ((X)->X_op_symbol) == AT_WORD_RIGHT_SHIFT)
#define AT_WORD_RIGHT_SHIFT 2

/* Fixups.  */
#define MAX_INSN_FIXUPS  5

struct d10v_fixup
{
  expressionS exp;
  int operand;
  int pcrel;
  int size;
  bfd_reloc_code_real_type reloc;
};

typedef struct _fixups
{
  int fc;
  struct d10v_fixup fix[MAX_INSN_FIXUPS];
  struct _fixups *next;
} Fixups;

static Fixups FixUps[2];
static Fixups *fixups;

static int do_not_ignore_hash = 0;

typedef int packing_type;
#define PACK_UNSPEC 	(0)	/* Packing order not specified.  */
#define PACK_PARALLEL	(1)	/* "||"  */
#define PACK_LEFT_RIGHT (2)	/* "->"  */
#define PACK_RIGHT_LEFT (3)	/* "<-"  */
static packing_type etype = PACK_UNSPEC; /* Used by d10v_cleanup.  */

/* TRUE if instruction swapping warnings should be inhibited.
   --nowarnswap.  */
static bfd_boolean flag_warn_suppress_instructionswap;

/* TRUE if instruction packing should be performed when --gstabs is specified.
   --gstabs-packing, --no-gstabs-packing.  */
static bfd_boolean flag_allow_gstabs_packing = 1;

/* Local functions.  */

enum options
{
  OPTION_NOWARNSWAP = OPTION_MD_BASE,
  OPTION_GSTABSPACKING,
  OPTION_NOGSTABSPACKING
};

struct option md_longopts[] =
{
  {"nowarnswap", no_argument, NULL, OPTION_NOWARNSWAP},
  {"gstabspacking",  no_argument, NULL, OPTION_GSTABSPACKING},
  {"gstabs-packing", no_argument, NULL, OPTION_GSTABSPACKING},
  {"nogstabspacking",   no_argument, NULL, OPTION_NOGSTABSPACKING},
  {"no-gstabs-packing", no_argument, NULL, OPTION_NOGSTABSPACKING},
  {NULL, no_argument, NULL, 0}
};

size_t md_longopts_size = sizeof (md_longopts);

/* Opcode hash table.  */
static struct hash_control *d10v_hash;

/* Do a binary search of the d10v_predefined_registers array to see if
   NAME is a valid regiter name.  Return the register number from the
   array on success, or -1 on failure.  */

static int
reg_name_search (char *name)
{
  int middle, low, high;
  int cmp;

  low = 0;
  high = d10v_reg_name_cnt () - 1;

  do
    {
      middle = (low + high) / 2;
      cmp = strcasecmp (name, d10v_predefined_registers[middle].name);
      if (cmp < 0)
	high = middle - 1;
      else if (cmp > 0)
	low = middle + 1;
      else
	return d10v_predefined_registers[middle].value;
    }
  while (low <= high);
  return -1;
}

/* Check the string at input_line_pointer
   to see if it is a valid register name.  */

static int
register_name (expressionS *expressionP)
{
  int reg_number;
  char c, *p = input_line_pointer;

  while (*p
	 && *p != '\n' && *p != '\r' && *p != ',' && *p != ' ' && *p != ')')
    p++;

  c = *p;
  if (c)
    *p++ = 0;

  /* Look to see if it's in the register table.  */
  reg_number = reg_name_search (input_line_pointer);
  if (reg_number >= 0)
    {
      expressionP->X_op = O_register;
      /* Temporarily store a pointer to the string here.  */
      expressionP->X_op_symbol = (symbolS *) input_line_pointer;
      expressionP->X_add_number = reg_number;
      input_line_pointer = p;
      return 1;
    }
  if (c)
    *(p - 1) = c;
  return 0;
}

static int
check_range (unsigned long num, int bits, int flags)
{
  long min, max;
  int retval = 0;

  /* Don't bother checking 16-bit values.  */
  if (bits == 16)
    return 0;

  if (flags & OPERAND_SHIFT)
    {
      /* All special shift operands are unsigned and <= 16.
	 We allow 0 for now.  */
      if (num > 16)
	return 1;
      else
	return 0;
    }

  if (flags & OPERAND_SIGNED)
    {
      /* Signed 3-bit integers are restricted to the (-2, 3) range.  */
      if (flags & RESTRICTED_NUM3)
	{
	  if ((long) num < -2 || (long) num > 3)
	    retval = 1;
	}
      else
	{
	  max = (1 << (bits - 1)) - 1;
	  min = - (1 << (bits - 1));
	  if (((long) num > max) || ((long) num < min))
	    retval = 1;
	}
    }
  else
    {
      max = (1 << bits) - 1;
      min = 0;
      if (((long) num > max) || ((long) num < min))
	retval = 1;
    }
  return retval;
}

void
md_show_usage (FILE *stream)
{
  fprintf (stream, _("D10V options:\n\
-O                      Optimize.  Will do some operations in parallel.\n\
--gstabs-packing        Pack adjacent short instructions together even\n\
                        when --gstabs is specified.  On by default.\n\
--no-gstabs-packing     If --gstabs is specified, do not pack adjacent\n\
                        instructions together.\n"));
}

int
md_parse_option (int c, char *arg ATTRIBUTE_UNUSED)
{
  switch (c)
    {
    case 'O':
      /* Optimize. Will attempt to parallelize operations.  */
      Optimizing = 1;
      break;
    case OPTION_NOWARNSWAP:
      flag_warn_suppress_instructionswap = 1;
      break;
    case OPTION_GSTABSPACKING:
      flag_allow_gstabs_packing = 1;
      break;
    case OPTION_NOGSTABSPACKING:
      flag_allow_gstabs_packing = 0;
      break;
    default:
      return 0;
    }
  return 1;
}

symbolS *
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
{
  return 0;
}

char *
md_atof (int type, char *litP, int *sizeP)
{
  return ieee_md_atof (type, litP, sizeP, TRUE);
}

void
md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED,
		 asection *sec ATTRIBUTE_UNUSED,
		 fragS *fragP ATTRIBUTE_UNUSED)
{
  abort ();
}

valueT
md_section_align (asection *seg, valueT addr)
{
  int align = bfd_get_section_alignment (stdoutput, seg);
  return ((addr + (1 << align) - 1) & (-1 << align));
}

void
md_begin (void)
{
  char *prev_name = "";
  struct d10v_opcode *opcode;
  d10v_hash = hash_new ();

  /* Insert unique names into hash table.  The D10v instruction set
     has many identical opcode names that have different opcodes based
     on the operands.  This hash table then provides a quick index to
     the first opcode with a particular name in the opcode table.  */

  for (opcode = (struct d10v_opcode *) d10v_opcodes; opcode->name; opcode++)
    {
      if (strcmp (prev_name, opcode->name))
	{
	  prev_name = (char *) opcode->name;
	  hash_insert (d10v_hash, opcode->name, (char *) opcode);
	}
    }

  fixups = &FixUps[0];
  FixUps[0].next = &FixUps[1];
  FixUps[1].next = &FixUps[0];
}

/* Remove the postincrement or postdecrement operator ( '+' or '-' )
   from an expression.  */

static int
postfix (char *p)
{
  while (*p != '-' && *p != '+')
    {
      if (*p == 0 || *p == '\n' || *p == '\r')
	break;
      p++;
    }

  if (*p == '-')
    {
      *p = ' ';
      return -1;
    }
  if (*p == '+')
    {
      *p = ' ';
      return 1;
    }

  return 0;
}

static bfd_reloc_code_real_type
get_reloc (struct d10v_operand *op)
{
  int bits = op->bits;

  if (bits <= 4)
    return 0;

  if (op->flags & OPERAND_ADDR)
    {
      if (bits == 8)
	return BFD_RELOC_D10V_10_PCREL_R;
      else
	return BFD_RELOC_D10V_18_PCREL;
    }

  return BFD_RELOC_16;
}

/* Parse a string of operands.  Return an array of expressions.  */

static int
get_operands (expressionS exp[])
{
  char *p = input_line_pointer;
  int numops = 0;
  int post = 0;
  int uses_at = 0;

  while (*p)
    {
      while (*p == ' ' || *p == '\t' || *p == ',')
	p++;
      if (*p == 0 || *p == '\n' || *p == '\r')
	break;

      if (*p == '@@')
	{
	  uses_at = 1;

	  p++;
	  exp[numops].X_op = O_absent;
	  if (*p == '(')
	    {
	      p++;
	      exp[numops].X_add_number = OPERAND_ATPAR;
	    }
	  else if (*p == '-')
	    {
	      p++;
	      exp[numops].X_add_number = OPERAND_ATMINUS;
	    }
	  else
	    {
	      exp[numops].X_add_number = OPERAND_ATSIGN;
	      if (*p == '+')
		{
		  numops++;
		  exp[numops].X_op = O_absent;
		  exp[numops].X_add_number = OPERAND_PLUS;
		  p++;
		}
	      post = postfix (p);
	    }
	  numops++;
	  continue;
	}

      if (*p == ')')
	{
	  /* Just skip the trailing paren.  */
	  p++;
	  continue;
	}

      input_line_pointer = p;

      /* Check to see if it might be a register name.  */
      if (!register_name (&exp[numops]))
	{
	  /* Parse as an expression.  */
	  if (uses_at)
	    {
	      /* Any expression that involves the indirect addressing
		 cannot also involve immediate addressing.  Therefore
		 the use of the hash character is illegal.  */
	      int save = do_not_ignore_hash;
	      do_not_ignore_hash = 1;

	      expression (&exp[numops]);

	      do_not_ignore_hash = save;
	    }
	  else
	    expression (&exp[numops]);
	}

      if (strncasecmp (input_line_pointer, "@@word", 5) == 0)
	{
	  input_line_pointer += 5;
	  if (exp[numops].X_op == O_register)
	    {
	      /* If it looked like a register name but was followed by
                 "@@word" then it was really a symbol, so change it to
                 one.  */
	      exp[numops].X_op = O_symbol;
	      exp[numops].X_add_symbol =
		symbol_find_or_make ((char *) exp[numops].X_op_symbol);
	    }

	  /* Check for identifier@@word+constant.  */
	  if (*input_line_pointer == '-' || *input_line_pointer == '+')
	    {
	      expressionS new_exp;
	      expression (&new_exp);
	      exp[numops].X_add_number = new_exp.X_add_number;
	    }

	  /* Convert expr into a right shift by AT_WORD_RIGHT_SHIFT.  */
	  {
	    expressionS new_exp;
	    memset (&new_exp, 0, sizeof new_exp);
	    new_exp.X_add_number = AT_WORD_RIGHT_SHIFT;
	    new_exp.X_op = O_constant;
	    new_exp.X_unsigned = 1;
	    exp[numops].X_op_symbol = make_expr_symbol (&new_exp);
	    exp[numops].X_op = O_right_shift;
	  }

	  know (AT_WORD_P (&exp[numops]));
	}

      if (exp[numops].X_op == O_illegal)
	as_bad (_("illegal operand"));
      else if (exp[numops].X_op == O_absent)
	as_bad (_("missing operand"));

      numops++;
      p = input_line_pointer;
    }

  switch (post)
    {
    case -1:	/* Postdecrement mode.  */
      exp[numops].X_op = O_absent;
      exp[numops++].X_add_number = OPERAND_MINUS;
      break;
    case 1:	/* Postincrement mode.  */
      exp[numops].X_op = O_absent;
      exp[numops++].X_add_number = OPERAND_PLUS;
      break;
    }

  exp[numops].X_op = 0;
  return numops;
}

static unsigned long
d10v_insert_operand (unsigned long insn,
		     int op_type,
		     offsetT value,
		     int left,
		     fixS *fix)
{
  int shift, bits;

  shift = d10v_operands[op_type].shift;
  if (left)
    shift += 15;

  bits = d10v_operands[op_type].bits;

  /* Truncate to the proper number of bits.  */
  if (check_range (value, bits, d10v_operands[op_type].flags))
    as_bad_where (fix->fx_file, fix->fx_line,
		  _("operand out of range: %ld"), (long) value);

  value &= 0x7FFFFFFF >> (31 - bits);
  insn |= (value << shift);

  return insn;
}

/* Take a pointer to the opcode entry in the opcode table and the
   array of operand expressions.  Return the instruction.  */

static unsigned long
build_insn (struct d10v_opcode *opcode,
	    expressionS *opers,
	    unsigned long insn)
{
  int i, bits, shift, flags, format;
  unsigned long number;

  /* The insn argument is only used for the DIVS kludge.  */
  if (insn)
    format = LONG_R;
  else
    {
      insn = opcode->opcode;
      format = opcode->format;
    }

  for (i = 0; opcode->operands[i]; i++)
    {
      flags = d10v_operands[opcode->operands[i]].flags;
      bits = d10v_operands[opcode->operands[i]].bits;
      shift = d10v_operands[opcode->operands[i]].shift;
      number = opers[i].X_add_number;

      if (flags & OPERAND_REG)
	{
	  number &= REGISTER_MASK;
	  if (format == LONG_L)
	    shift += 15;
	}

      if (opers[i].X_op != O_register && opers[i].X_op != O_constant)
	{
	  /* Now create a fixup.  */

	  if (fixups->fc >= MAX_INSN_FIXUPS)
	    as_fatal (_("too many fixups"));

	  if (AT_WORD_P (&opers[i]))
	    {
	      /* Recognize XXX>>1+N aka XXX@@word+N as special (AT_WORD).  */
	      fixups->fix[fixups->fc].reloc = BFD_RELOC_D10V_18;
	      opers[i].X_op = O_symbol;
	      opers[i].X_op_symbol = NULL; /* Should free it.  */
	      /* number is left shifted by AT_WORD_RIGHT_SHIFT so
                 that, it is aligned with the symbol's value.  Later,
                 BFD_RELOC_D10V_18 will right shift (symbol_value +
                 X_add_number).  */
	      number <<= AT_WORD_RIGHT_SHIFT;
	      opers[i].X_add_number = number;
	    }
	  else
	    {
	      fixups->fix[fixups->fc].reloc =
		get_reloc ((struct d10v_operand *) &d10v_operands[opcode->operands[i]]);

	      /* Check that an immediate was passed to ops that expect one.  */
	      if ((flags & OPERAND_NUM)
		  && (fixups->fix[fixups->fc].reloc == 0))
		as_bad (_("operand is not an immediate"));
	    }

	  if (fixups->fix[fixups->fc].reloc == BFD_RELOC_16 ||
	      fixups->fix[fixups->fc].reloc == BFD_RELOC_D10V_18)
	    fixups->fix[fixups->fc].size = 2;
	  else
	    fixups->fix[fixups->fc].size = 4;

	  fixups->fix[fixups->fc].exp = opers[i];
	  fixups->fix[fixups->fc].operand = opcode->operands[i];
	  fixups->fix[fixups->fc].pcrel =
	    (flags & OPERAND_ADDR) ? TRUE : FALSE;
	  (fixups->fc)++;
	}

      /* Truncate to the proper number of bits.  */
      if ((opers[i].X_op == O_constant) && check_range (number, bits, flags))
	as_bad (_("operand out of range: %lu"), number);
      number &= 0x7FFFFFFF >> (31 - bits);
      insn = insn | (number << shift);
    }

  /* kludge: for DIVS, we need to put the operands in twice on the second
     pass, format is changed to LONG_R to force the second set of operands
     to not be shifted over 15.  */
  if ((opcode->opcode == OPCODE_DIVS) && (format == LONG_L))
    insn = build_insn (opcode, opers, insn);

  return insn;
}

/* Write out a long form instruction.  */

static void
write_long (unsigned long insn, Fixups *fx)
{
  int i, where;
  char *f = frag_more (4);

  dwarf2_emit_insn (4);
  insn |= FM11;
  number_to_chars_bigendian (f, insn, 4);

  for (i = 0; i < fx->fc; i++)
    {
      if (fx->fix[i].reloc)
	{
	  where = f - frag_now->fr_literal;
	  if (fx->fix[i].size == 2)
	    where += 2;

	  if (fx->fix[i].reloc == BFD_RELOC_D10V_18)
	    fx->fix[i].operand |= 4096;

	  fix_new_exp (frag_now,
		       where,
		       fx->fix[i].size,
		       &(fx->fix[i].exp),
		       fx->fix[i].pcrel,
		       fx->fix[i].operand|2048);
	}
    }
  fx->fc = 0;
}

/* Write out a short form instruction by itself.  */

static void
write_1_short (struct d10v_opcode *opcode,
	       unsigned long insn,
	       Fixups *fx)
{
  char *f = frag_more (4);
  int i, where;

  dwarf2_emit_insn (4);
  if (opcode->exec_type & PARONLY)
    as_fatal (_("Instruction must be executed in parallel with another instruction."));

  /* The other container needs to be NOP.
     According to 4.3.1: for FM=00, sub-instructions performed only by IU
     cannot be encoded in L-container.  */
  if (opcode->unit == IU)
    insn |= FM00 | (NOP << 15);		/* Right container.  */
  else
    insn = FM00 | (insn << 15) | NOP;	/* Left container.  */

  number_to_chars_bigendian (f, insn, 4);
  for (i = 0; i < fx->fc; i++)
    {
      if (fx->fix[i].reloc)
	{
	  where = f - frag_now->fr_literal;
	  if (fx->fix[i].size == 2)
	    where += 2;

	  if (fx->fix[i].reloc == BFD_RELOC_D10V_18)
	    fx->fix[i].operand |= 4096;

	  /* If it's an R reloc, we may have to switch it to L.  */
	  if ((fx->fix[i].reloc == BFD_RELOC_D10V_10_PCREL_R)
	      && (opcode->unit != IU))
	    fx->fix[i].operand |= 1024;

	  fix_new_exp (frag_now,
		       where,
		       fx->fix[i].size,
		       &(fx->fix[i].exp),
		       fx->fix[i].pcrel,
		       fx->fix[i].operand|2048);
	}
    }
  fx->fc = 0;
}

/* Determine if there are any resource conflicts among two manually
   parallelized instructions.  Some of this was lifted from parallel_ok.  */

static void
check_resource_conflict (struct d10v_opcode *op1,
			 unsigned long insn1,
			 struct d10v_opcode *op2,
			 unsigned long insn2)
{
  int i, j, flags, mask, shift, regno;
  unsigned long ins, mod[2];
  struct d10v_opcode *op;

  if ((op1->exec_type & SEQ)
      || ! ((op1->exec_type & PAR) || (op1->exec_type & PARONLY)))
    {
      as_warn (_("packing conflict: %s must dispatch sequentially"),
	      op1->name);
      return;
    }

  if ((op2->exec_type & SEQ)
      || ! ((op2->exec_type & PAR) || (op2->exec_type & PARONLY)))
    {
      as_warn (_("packing conflict: %s must dispatch sequentially"),
	      op2->name);
      return;
    }

   /* See if both instructions write to the same resource.

      The idea here is to create two sets of bitmasks (mod and used) which
      indicate which registers are modified or used by each instruction.
      The operation can only be done in parallel if neither instruction
      modifies the same register. Accesses to control registers and memory
      are treated as accesses to a single register. So if both instructions
      write memory or if the first instruction writes memory and the second
      reads, then they cannot be done in parallel. We treat reads to the PSW
      (which includes C, F0, and F1) in isolation. So simultaneously writing
      C and F0 in two different sub-instructions is permitted.  */

  /* The bitmasks (mod and used) look like this (bit 31 = MSB).
     r0-r15	  0-15
     a0-a1	  16-17
     cr (not psw) 18
     psw(other)   19
     mem	  20
     psw(C flag)  21
     psw(F0 flag) 22  */

  for (j = 0; j < 2; j++)
    {
      if (j == 0)
	{
	  op = op1;
	  ins = insn1;
	}
      else
	{
	  op = op2;
	  ins = insn2;
	}
      mod[j] = 0;
      if (op->exec_type & BRANCH_LINK)
	mod[j] |= 1 << 13;

      for (i = 0; op->operands[i]; i++)
	{
	  flags = d10v_operands[op->operands[i]].flags;
	  shift = d10v_operands[op->operands[i]].shift;
	  mask = 0x7FFFFFFF >> (31 - d10v_operands[op->operands[i]].bits);
	  if (flags & OPERAND_REG)
	    {
	      regno = (ins >> shift) & mask;
	      if (flags & (OPERAND_ACC0 | OPERAND_ACC1))
		regno += 16;
	      else if (flags & OPERAND_CONTROL)	/* mvtc or mvfc */
		{
		  if (regno == 0)
		    regno = 19;
		  else
		    regno = 18;
		}
	      else if (flags & OPERAND_FFLAG)
		regno = 22;
	      else if (flags & OPERAND_CFLAG)
		regno = 21;

	      if (flags & OPERAND_DEST
		  /* Auto inc/dec also modifies the register.  */
		  || (op->operands[i + 1] != 0
		      && (d10v_operands[op->operands[i + 1]].flags
			  & (OPERAND_PLUS | OPERAND_MINUS)) != 0))
		{
		  mod[j] |= 1 << regno;
		  if (flags & OPERAND_EVEN)
		    mod[j] |= 1 << (regno + 1);
		}
	    }
	  else if (flags & OPERAND_ATMINUS)
	    {
	      /* SP implicitly used/modified.  */
	      mod[j] |= 1 << 15;
	    }
	}

      if (op->exec_type & WMEM)
	mod[j] |= 1 << 20;
      else if (op->exec_type & WF0)
	mod[j] |= 1 << 22;
      else if (op->exec_type & WCAR)
	mod[j] |= 1 << 21;
    }

  if ((mod[0] & mod[1]) == 0)
    return;
  else
    {
      unsigned long x;
      x = mod[0] & mod[1];

      for (j = 0; j <= 15; j++)
	if (x & (1 << j))
	  as_warn (_("resource conflict (R%d)"), j);
      for (j = 16; j <= 17; j++)
	if (x & (1 << j))
	  as_warn (_("resource conflict (A%d)"), j - 16);
      if (x & (1 << 19))
	as_warn (_("resource conflict (PSW)"));
      if (x & (1 << 21))
	as_warn (_("resource conflict (C flag)"));
      if (x & (1 << 22))
	as_warn (_("resource conflict (F flag)"));
    }
}

/* Check 2 instructions and determine if they can be safely
   executed in parallel.  Return 1 if they can be.  */

static int
parallel_ok (struct d10v_opcode *op1,
	     unsigned long insn1,
	     struct d10v_opcode *op2,
	     unsigned long insn2,
	     packing_type exec_type)
{
  int i, j, flags, mask, shift, regno;
  unsigned long ins, mod[2], used[2];
  struct d10v_opcode *op;

  if ((op1->exec_type & SEQ) != 0 || (op2->exec_type & SEQ) != 0
      || (op1->exec_type & PAR) == 0 || (op2->exec_type & PAR) == 0
      || (op1->unit == BOTH) || (op2->unit == BOTH)
      || (op1->unit == IU && op2->unit == IU)
      || (op1->unit == MU && op2->unit == MU))
    return 0;

  /* If this is auto parallelization, and the first instruction is a
     branch or should not be packed, then don't parallelize.  */
  if (exec_type == PACK_UNSPEC
      && (op1->exec_type & (ALONE | BRANCH)))
    return 0;

  /* The idea here is to create two sets of bitmasks (mod and used)
     which indicate which registers are modified or used by each
     instruction.  The operation can only be done in parallel if
     instruction 1 and instruction 2 modify different registers, and
     the first instruction does not modify registers that the second
     is using (The second instruction can modify registers that the
     first is using as they are only written back after the first
     instruction has completed).  Accesses to control registers, PSW,
     and memory are treated as accesses to a single register.  So if
     both instructions write memory or if the first instruction writes
     memory and the second reads, then they cannot be done in
     parallel.  Likewise, if the first instruction mucks with the psw
     and the second reads the PSW (which includes C, F0, and F1), then
     they cannot operate safely in parallel.  */

  /* The bitmasks (mod and used) look like this (bit 31 = MSB).
     r0-r15	  0-15
     a0-a1	  16-17
     cr (not psw) 18
     psw	  19
     mem	  20  */

  for (j = 0; j < 2; j++)
    {
      if (j == 0)
	{
	  op = op1;
	  ins = insn1;
	}
      else
	{
	  op = op2;
	  ins = insn2;
	}
      mod[j] = used[j] = 0;
      if (op->exec_type & BRANCH_LINK)
	mod[j] |= 1 << 13;

      for (i = 0; op->operands[i]; i++)
	{
	  flags = d10v_operands[op->operands[i]].flags;
	  shift = d10v_operands[op->operands[i]].shift;
	  mask = 0x7FFFFFFF >> (31 - d10v_operands[op->operands[i]].bits);
	  if (flags & OPERAND_REG)
	    {
	      regno = (ins >> shift) & mask;
	      if (flags & (OPERAND_ACC0 | OPERAND_ACC1))
		regno += 16;
	      else if (flags & OPERAND_CONTROL)	/* mvtc or mvfc.  */
		{
		  if (regno == 0)
		    regno = 19;
		  else
		    regno = 18;
		}
	      else if (flags & (OPERAND_FFLAG | OPERAND_CFLAG))
		regno = 19;

	      if (flags & OPERAND_DEST)
		{
		  mod[j] |= 1 << regno;
		  if (flags & OPERAND_EVEN)
		    mod[j] |= 1 << (regno + 1);
		}
	      else
		{
		  used[j] |= 1 << regno;
		  if (flags & OPERAND_EVEN)
		    used[j] |= 1 << (regno + 1);

		  /* Auto inc/dec also modifies the register.  */
		  if (op->operands[i + 1] != 0
		      && (d10v_operands[op->operands[i + 1]].flags
			  & (OPERAND_PLUS | OPERAND_MINUS)) != 0)
		    mod[j] |= 1 << regno;
		}
	    }
	  else if (flags & OPERAND_ATMINUS)
	    {
	      /* SP implicitly used/modified.  */
	      mod[j] |= 1 << 15;
	      used[j] |= 1 << 15;
	    }
	}
      if (op->exec_type & RMEM)
	used[j] |= 1 << 20;
      else if (op->exec_type & WMEM)
	mod[j] |= 1 << 20;
      else if (op->exec_type & RF0)
	used[j] |= 1 << 19;
      else if (op->exec_type & WF0)
	mod[j] |= 1 << 19;
      else if (op->exec_type & WCAR)
	mod[j] |= 1 << 19;
    }
  if ((mod[0] & mod[1]) == 0 && (mod[0] & used[1]) == 0)
    return 1;
  return 0;
}

/* Expects two short instructions.
   If possible, writes out both as a single packed instruction.
   Otherwise, writes out the first one, packed with a NOP.
   Returns number of instructions not written out.  */

static int
write_2_short (struct d10v_opcode *opcode1,
	       unsigned long insn1,
	       struct d10v_opcode *opcode2,
	       unsigned long insn2,
	       packing_type exec_type,
	       Fixups *fx)
{
  unsigned long insn;
  char *f;
  int i, j, where;

  if ((exec_type != PACK_PARALLEL)
      && ((opcode1->exec_type & PARONLY) || (opcode2->exec_type & PARONLY)))
    as_fatal (_("Instruction must be executed in parallel"));

  if ((opcode1->format & LONG_OPCODE) || (opcode2->format & LONG_OPCODE))
    as_fatal (_("Long instructions may not be combined."));

  switch (exec_type)
    {
    case PACK_UNSPEC:	/* Order not specified.  */
      if (opcode1->exec_type & ALONE)
	{
	  /* Case of a short branch on a separate GAS line.  Pack with NOP.  */
	  write_1_short (opcode1, insn1, fx->next);
	  return 1;
	}
      if (Optimizing
	  && parallel_ok (opcode1, insn1, opcode2, insn2, exec_type))
	{
	  /* Parallel.  */
	  if (opcode1->unit == IU)
	    insn = FM00 | (insn2 << 15) | insn1;
	  else if (opcode2->unit == MU)
	    insn = FM00 | (insn2 << 15) | insn1;
	  else
	    insn = FM00 | (insn1 << 15) | insn2;
	}
      else if (opcode1->unit == IU)
	/* Reverse sequential with IU opcode1 on right and done first.  */
	insn = FM10 | (insn2 << 15) | insn1;
      else
	/* Sequential with non-IU opcode1 on left and done first.  */
	insn = FM01 | (insn1 << 15) | insn2;
      break;

    case PACK_PARALLEL:
      if (opcode1->exec_type & SEQ || opcode2->exec_type & SEQ)
	as_fatal
	  (_("One of these instructions may not be executed in parallel."));
      if (opcode1->unit == IU)
	{
	  if (opcode2->unit == IU)
	    as_fatal (_("Two IU instructions may not be executed in parallel"));
	  if (!flag_warn_suppress_instructionswap)
	    as_warn (_("Swapping instruction order"));
	  insn = FM00 | (insn2 << 15) | insn1;
	}
      else if (opcode2->unit == MU)
	{
	  if (opcode1->unit == MU)
	    as_fatal (_("Two MU instructions may not be executed in parallel"));
	  if (!flag_warn_suppress_instructionswap)
	    as_warn (_("Swapping instruction order"));
	  insn = FM00 | (insn2 << 15) | insn1;
	}
      else
	insn = FM00 | (insn1 << 15) | insn2;
      check_resource_conflict (opcode1, insn1, opcode2, insn2);
      break;

    case PACK_LEFT_RIGHT:
      if (opcode1->unit != IU)
	insn = FM01 | (insn1 << 15) | insn2;
      else if (opcode2->unit == MU || opcode2->unit == EITHER)
	{
	  if (!flag_warn_suppress_instructionswap)
	    as_warn (_("Swapping instruction order"));
	  insn = FM10 | (insn2 << 15) | insn1;
	}
      else
	as_fatal (_("IU instruction may not be in the left container"));
      if (opcode1->exec_type & ALONE)
	as_warn (_("Instruction in R container is squashed by flow control instruction in L container."));
      break;

    case PACK_RIGHT_LEFT:
      if (opcode2->unit != MU)
	insn = FM10 | (insn1 << 15) | insn2;
      else if (opcode1->unit == IU || opcode1->unit == EITHER)
	{
	  if (!flag_warn_suppress_instructionswap)
	    as_warn (_("Swapping instruction order"));
	  insn = FM01 | (insn2 << 15) | insn1;
	}
      else
	as_fatal (_("MU instruction may not be in the right container"));
      if (opcode2->exec_type & ALONE)
	as_warn (_("Instruction in R container is squashed by flow control instruction in L container."));
      break;

    default:
      as_fatal (_("unknown execution type passed to write_2_short()"));
    }

  f = frag_more (4);
  dwarf2_emit_insn (4);
  number_to_chars_bigendian (f, insn, 4);

  /* Process fixup chains.  fx refers to insn2 when j == 0, and to
     insn1 when j == 1.  Yes, it's reversed.  */

  for (j = 0; j < 2; j++)
    {
      for (i = 0; i < fx->fc; i++)
	{
	  if (fx->fix[i].reloc)
	    {
	      where = f - frag_now->fr_literal;
	      if (fx->fix[i].size == 2)
		where += 2;

	      if (fx->fix[i].reloc == BFD_RELOC_D10V_10_PCREL_R
		  /* A BFD_RELOC_D10V_10_PCREL_R relocation applied to
		     the instruction in the L container has to be
		     adjusted to BDF_RELOC_D10V_10_PCREL_L.  When
		     j==0, we're processing insn2's operands, so we
		     want to mark the operand if insn2 is *not* in the
		     R container.  When j==1, we're processing insn1's
		     operands, so we want to mark the operand if insn2
		     *is* in the R container.  Note that, if two
		     instructions are identical, we're never going to
		     swap them, so the test is safe.  */
		  && j == ((insn & 0x7fff) == insn2))
		fx->fix[i].operand |= 1024;

	      if (fx->fix[i].reloc == BFD_RELOC_D10V_18)
		fx->fix[i].operand |= 4096;

	      fix_new_exp (frag_now,
			   where,
			   fx->fix[i].size,
			   &(fx->fix[i].exp),
			   fx->fix[i].pcrel,
			   fx->fix[i].operand|2048);
	    }
	}
      fx->fc = 0;
      fx = fx->next;
    }
  return 0;
}

/* This is the main entry point for the machine-dependent assembler.
   str points to a machine-dependent instruction.  This function is
   supposed to emit the frags/bytes it assembles to.  For the D10V, it
   mostly handles the special VLIW parsing and packing and leaves the
   difficult stuff to do_assemble().  */

static unsigned long prev_insn;
static struct d10v_opcode *prev_opcode = 0;
static subsegT prev_subseg;
static segT prev_seg = 0;

/* Find the symbol which has the same name as the register in exp.  */

static symbolS *
find_symbol_matching_register (expressionS *exp)
{
  int i;

  if (exp->X_op != O_register)
    return NULL;

  /* Find the name of the register.  */
  for (i = d10v_reg_name_cnt (); i--;)
    if (d10v_predefined_registers[i].value == exp->X_add_number)
      break;

  if (i < 0)
    abort ();

  /* Now see if a symbol has been defined with the same name.  */
  return symbol_find (d10v_predefined_registers[i].name);
}

/* Get a pointer to an entry in the opcode table.
   The function must look at all opcodes with the same name and use
   the operands to choose the correct opcode.  */

static struct d10v_opcode *
find_opcode (struct d10v_opcode *opcode, expressionS myops[])
{
  int i, match;
  struct d10v_opcode *next_opcode;

  /* Get all the operands and save them as expressions.  */
  get_operands (myops);

  /* Now see if the operand is a fake.  If so, find the correct size
     instruction, if possible.  */
  if (opcode->format == OPCODE_FAKE)
    {
      int opnum = opcode->operands[0];
      int flags;

      if (myops[opnum].X_op == O_register)
	{
	  myops[opnum].X_op = O_symbol;
	  myops[opnum].X_add_symbol =
	    symbol_find_or_make ((char *) myops[opnum].X_op_symbol);
	  myops[opnum].X_add_number = 0;
	  myops[opnum].X_op_symbol = NULL;
	}

      next_opcode = opcode + 1;

      /* If the first operand is supposed to be a register, make sure
	 we got a valid one.  */
      flags = d10v_operands[next_opcode->operands[0]].flags;
      if (flags & OPERAND_REG)
	{
	  int X_op = myops[0].X_op;
	  int num = myops[0].X_add_number;

	  if (X_op != O_register
	      || (num & ~flags
		  & (OPERAND_GPR | OPERAND_ACC0 | OPERAND_ACC1
		     | OPERAND_FFLAG | OPERAND_CFLAG | OPERAND_CONTROL))
	      || ((flags & OPERAND_SP) && ! (num & OPERAND_SP)))
	    {
	      as_bad (_("bad opcode or operands"));
	      return 0;
	    }
	}

      if (myops[opnum].X_op == O_constant
	  || (myops[opnum].X_op == O_symbol
	      && S_IS_DEFINED (myops[opnum].X_add_symbol)
	      && (S_GET_SEGMENT (myops[opnum].X_add_symbol) == now_seg)))
	{
	  for (i = 0; opcode->operands[i + 1]; i++)
	    {
	      int bits = d10v_operands[next_opcode->operands[opnum]].bits;

	      flags = d10v_operands[next_opcode->operands[opnum]].flags;

	      if (flags & OPERAND_ADDR)
		bits += 2;

	      if (myops[opnum].X_op == O_constant)
		{
		  if (!check_range (myops[opnum].X_add_number, bits, flags))
		    break;
		}
	      else
		{
		  fragS *sym_frag;
		  fragS *f;
		  unsigned long current_position;
		  unsigned long symbol_position;
		  unsigned long value;
		  bfd_boolean found_symbol;

		  /* Calculate the address of the current instruction
		     and the address of the symbol.  Do this by summing
		     the offsets of previous frags until we reach the
		     frag containing the symbol, and the current frag.  */
		  sym_frag = symbol_get_frag (myops[opnum].X_add_symbol);
		  found_symbol = FALSE;

		  current_position =
		    obstack_next_free (&frchain_now->frch_obstack)
		    - frag_now->fr_literal;
		  symbol_position = S_GET_VALUE (myops[opnum].X_add_symbol);

		  for (f = frchain_now->frch_root; f; f = f->fr_next)
		    {
		      current_position += f->fr_fix + f->fr_offset;

		      if (f == sym_frag)
			found_symbol = TRUE;

		      if (! found_symbol)
			symbol_position += f->fr_fix + f->fr_offset;
		    }

		  value = symbol_position;

		  if (flags & OPERAND_ADDR)
		    value -= current_position;

		  if (AT_WORD_P (&myops[opnum]))
		    {
		      if (bits > 4)
			{
			  bits += 2;
			  if (!check_range (value, bits, flags))
			    break;
			}
		    }
		  else if (!check_range (value, bits, flags))
		    break;
		}
	      next_opcode++;
	    }

	  if (opcode->operands [i + 1] == 0)
	    as_fatal (_("value out of range"));
	  else
	    opcode = next_opcode;
	}
      else
	/* Not a constant, so use a long instruction.  */
	opcode += 2;
    }

  match = 0;

  /* Now search the opcode table table for one with operands
     that matches what we've got.  */
  while (!match)
    {
      match = 1;
      for (i = 0; opcode->operands[i]; i++)
	{
	  int flags = d10v_operands[opcode->operands[i]].flags;
	  int X_op = myops[i].X_op;
	  int num = myops[i].X_add_number;

	  if (X_op == 0)
	    {
	      match = 0;
	      break;
	    }

	  if (flags & OPERAND_REG)
	    {
	      if ((X_op != O_register)
		  || (num & ~flags
		      & (OPERAND_GPR | OPERAND_ACC0 | OPERAND_ACC1
			 | OPERAND_FFLAG | OPERAND_CFLAG
			 | OPERAND_CONTROL))
		  || ((flags & OPERAND_SP) && ! (num & OPERAND_SP)))
		{
		  match = 0;
		  break;
		}
	    }

	  if (((flags & OPERAND_MINUS)   && ((X_op != O_absent) || (num != OPERAND_MINUS))) ||
	      ((flags & OPERAND_PLUS)    && ((X_op != O_absent) || (num != OPERAND_PLUS))) ||
	      ((flags & OPERAND_ATMINUS) && ((X_op != O_absent) || (num != OPERAND_ATMINUS))) ||
	      ((flags & OPERAND_ATPAR)   && ((X_op != O_absent) || (num != OPERAND_ATPAR))) ||
	      ((flags & OPERAND_ATSIGN)  && ((X_op != O_absent) || ((num != OPERAND_ATSIGN) && (num != OPERAND_ATPAR)))))
	    {
	      match = 0;
	      break;
	    }

	  /* Unfortunately, for the indirect operand in instructions such
	     as ``ldb r1, @@(c,r14)'' this function can be passed
	     X_op == O_register (because 'c' is a valid register name).
	     However we cannot just ignore the case when X_op == O_register
	     but flags & OPERAND_REG is null, so we check to see if a symbol
	     of the same name as the register exists.  If the symbol does
	     exist, then the parser was unable to distinguish the two cases
	     and we fix things here. (Ref: PR14826)  */

	  if (!(flags & OPERAND_REG) && (X_op == O_register))
	    {
	      symbolS * sym;

	      sym = find_symbol_matching_register (& myops[i]);

	      if (sym != NULL)
		{
		  myops[i].X_op = X_op = O_symbol;
		  myops[i].X_add_symbol = sym;
		}
	      else
		as_bad
		  (_("illegal operand - register name found where none expected"));
	    }
	}

      /* We're only done if the operands matched so far AND there
	     are no more to check.  */
      if (match && myops[i].X_op == 0)
	break;
      else
	match = 0;

      next_opcode = opcode + 1;

      if (next_opcode->opcode == 0)
	break;

      if (strcmp (next_opcode->name, opcode->name))
	break;

      opcode = next_opcode;
    }

  if (!match)
    {
      as_bad (_("bad opcode or operands"));
      return 0;
    }

  /* Check that all registers that are required to be even are.
     Also, if any operands were marked as registers, but were really symbols,
     fix that here.  */
  for (i = 0; opcode->operands[i]; i++)
    {
      if ((d10v_operands[opcode->operands[i]].flags & OPERAND_EVEN) &&
	  (myops[i].X_add_number & 1))
	as_fatal (_("Register number must be EVEN"));
      if ((d10v_operands[opcode->operands[i]].flags & OPERAND_NOSP)
	  && (myops[i].X_add_number & OPERAND_SP))
	as_bad (_("Unsupported use of sp"));
      if (myops[i].X_op == O_register)
	{
	  if (!(d10v_operands[opcode->operands[i]].flags & OPERAND_REG))
	    {
	      myops[i].X_op = O_symbol;
	      myops[i].X_add_symbol =
		symbol_find_or_make ((char *) myops[i].X_op_symbol);
	      myops[i].X_add_number = 0;
	      myops[i].X_op_symbol = NULL;
	    }
	}
      if ((d10v_operands[opcode->operands[i]].flags & OPERAND_CONTROL)
	  && (myops[i].X_add_number == OPERAND_CONTROL + 4
	      || myops[i].X_add_number == OPERAND_CONTROL + 5
	      || myops[i].X_add_number == OPERAND_CONTROL + 6
	      || myops[i].X_add_number == OPERAND_CONTROL + 12
	      || myops[i].X_add_number == OPERAND_CONTROL + 13
	      || myops[i].X_add_number == OPERAND_CONTROL + 15))
	as_warn (_("cr%ld is a reserved control register"),
		 myops[i].X_add_number - OPERAND_CONTROL);
    }
  return opcode;
}

/* Assemble a single instruction.
   Return an opcode, or -1 (an invalid opcode) on error.  */

static unsigned long
do_assemble (char *str, struct d10v_opcode **opcode)
{
  unsigned char *op_start, *op_end;
  char *save;
  char name[20];
  int nlen = 0;
  expressionS myops[6];

  /* Drop leading whitespace.  */
  while (*str == ' ')
    str++;

  /* Find the opcode end.  */
  for (op_start = op_end = (unsigned char *) str;
       *op_end && !is_end_of_line[*op_end] && *op_end != ' ';
       op_end++)
    {
      name[nlen] = TOLOWER (op_start[nlen]);
      nlen++;
      if (nlen == sizeof (name) - 1)
	break;
    }
  name[nlen] = 0;

  if (nlen == 0)
    return -1;

  /* Find the first opcode with the proper name.  */
  *opcode = (struct d10v_opcode *) hash_find (d10v_hash, name);
  if (*opcode == NULL)
    return -1;

  save = input_line_pointer;
  input_line_pointer = (char *) op_end;
  *opcode = find_opcode (*opcode, myops);
  if (*opcode == 0)
    return -1;
  input_line_pointer = save;

  return build_insn ((*opcode), myops, 0);
}

/* If while processing a fixup, a reloc really needs to be created.
   Then it is done here.  */

arelent *
tc_gen_reloc (asection *seg ATTRIBUTE_UNUSED, fixS *fixp)
{
  arelent *reloc;
  reloc = xmalloc (sizeof (arelent));
  reloc->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
  if (reloc->howto == (reloc_howto_type *) NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("reloc %d not supported by object file format"),
		    (int) fixp->fx_r_type);
      return NULL;
    }

  if (fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    reloc->address = fixp->fx_offset;

  reloc->addend = 0;

  return reloc;
}

int
md_estimate_size_before_relax (fragS *fragp ATTRIBUTE_UNUSED,
			       asection *seg ATTRIBUTE_UNUSED)
{
  abort ();
  return 0;
}

long
md_pcrel_from_section (fixS *fixp, segT sec)
{
  if (fixp->fx_addsy != (symbolS *) NULL
      && (!S_IS_DEFINED (fixp->fx_addsy)
	  || (S_GET_SEGMENT (fixp->fx_addsy) != sec)))
    return 0;
  return fixp->fx_frag->fr_address + fixp->fx_where;
}

void
md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
{
  char *where;
  unsigned long insn;
  long value = *valP;
  int op_type;
  int left = 0;

  if (fixP->fx_addsy == (symbolS *) NULL)
    fixP->fx_done = 1;

  /* We don't actually support subtracting a symbol.  */
  if (fixP->fx_subsy != (symbolS *) NULL)
    as_bad_where (fixP->fx_file, fixP->fx_line, _("expression too complex"));

  op_type = fixP->fx_r_type;
  if (op_type & 2048)
    {
      op_type -= 2048;
      if (op_type & 1024)
	{
	  op_type -= 1024;
	  fixP->fx_r_type = BFD_RELOC_D10V_10_PCREL_L;
	  left = 1;
	}
      else if (op_type & 4096)
	{
	  op_type -= 4096;
	  fixP->fx_r_type = BFD_RELOC_D10V_18;
	}
      else
	fixP->fx_r_type =
	  get_reloc ((struct d10v_operand *) &d10v_operands[op_type]);
    }

  /* Fetch the instruction, insert the fully resolved operand
     value, and stuff the instruction back again.  */
  where = fixP->fx_frag->fr_literal + fixP->fx_where;
  insn = bfd_getb32 ((unsigned char *) where);

  switch (fixP->fx_r_type)
    {
    case BFD_RELOC_D10V_10_PCREL_L:
    case BFD_RELOC_D10V_10_PCREL_R:
    case BFD_RELOC_D10V_18_PCREL:
      /* If the fix is relative to a global symbol, not a section
	 symbol, then ignore the offset.
         XXX - Do we have to worry about branches to a symbol + offset ?  */
      if (fixP->fx_addsy != NULL
	  && S_IS_EXTERNAL (fixP->fx_addsy) )
        {
          segT fseg = S_GET_SEGMENT (fixP->fx_addsy);
          segment_info_type *segf = seg_info(fseg);

	  if ( segf && segf->sym != fixP->fx_addsy)
	    value = 0;
        }
      /* Drop through.  */
    case BFD_RELOC_D10V_18:
      /* Instruction addresses are always right-shifted by 2.  */
      value >>= AT_WORD_RIGHT_SHIFT;
      if (fixP->fx_size == 2)
	bfd_putb16 ((bfd_vma) value, (unsigned char *) where);
      else
	{
	  struct d10v_opcode *rep, *repi;

	  rep = (struct d10v_opcode *) hash_find (d10v_hash, "rep");
	  repi = (struct d10v_opcode *) hash_find (d10v_hash, "repi");
	  if ((insn & FM11) == FM11
	      && ((repi != NULL
		   && (insn & repi->mask) == (unsigned) repi->opcode)
		  || (rep != NULL
		      && (insn & rep->mask) == (unsigned) rep->opcode))
	      && value < 4)
	    as_fatal
	      (_("line %d: rep or repi must include at least 4 instructions"),
	       fixP->fx_line);
	  insn =
	    d10v_insert_operand (insn, op_type, (offsetT) value, left, fixP);
	  bfd_putb32 ((bfd_vma) insn, (unsigned char *) where);
	}
      break;
    case BFD_RELOC_32:
      bfd_putb32 ((bfd_vma) value, (unsigned char *) where);
      break;
    case BFD_RELOC_16:
      bfd_putb16 ((bfd_vma) value, (unsigned char *) where);
      break;

    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
      fixP->fx_done = 0;
      return;

    default:
      as_fatal (_("line %d: unknown relocation type: 0x%x"),
		fixP->fx_line, fixP->fx_r_type);
    }
}

/* d10v_cleanup() is called after the assembler has finished parsing
   the input file, when a label is read from the input file, or when a
   stab directive is output.  Because the D10V assembler sometimes
   saves short instructions to see if it can package them with the
   next instruction, there may be a short instruction that still needs
   to be written.

   NOTE: accesses a global, etype.
   NOTE: invoked by various macros such as md_cleanup: see.  */

int
d10v_cleanup (void)
{
  segT seg;
  subsegT subseg;

  /* If cleanup was invoked because the assembler encountered, e.g., a
     user label, we write out the pending instruction, if any.  If it
     was invoked because the assembler is outputting a piece of line
     debugging information, though, we write out the pending
     instruction only if the --no-gstabs-packing command line switch
     has been specified.  */
  if (prev_opcode
      && etype == PACK_UNSPEC
      && (! outputting_stabs_line_debug || ! flag_allow_gstabs_packing))
    {
      seg = now_seg;
      subseg = now_subseg;

      if (prev_seg)
	subseg_set (prev_seg, prev_subseg);

      write_1_short (prev_opcode, prev_insn, fixups->next);
      subseg_set (seg, subseg);
      prev_opcode = NULL;
    }
  return 1;
}

void
d10v_frob_label (symbolS *lab)
{
  d10v_cleanup ();
  symbol_set_frag (lab, frag_now);
  S_SET_VALUE (lab, (valueT) frag_now_fix ());
  dwarf2_emit_label (lab);
}

/* Like normal .word, except support @@word.
   Clobbers input_line_pointer, checks end-of-line.  */

static void
d10v_dot_word (int dummy ATTRIBUTE_UNUSED)
{
  expressionS exp;
  char *p;

  if (is_it_end_of_statement ())
    {
      demand_empty_rest_of_line ();
      return;
    }

  do
    {
      expression (&exp);
      if (!strncasecmp (input_line_pointer, "@@word", 5))
	{
	  exp.X_add_number = 0;
	  input_line_pointer += 5;

	  p = frag_more (2);
	  fix_new_exp (frag_now, p - frag_now->fr_literal, 2,
		       &exp, 0, BFD_RELOC_D10V_18);
	}
      else
	emit_expr (&exp, 2);
    }
  while (*input_line_pointer++ == ',');

  input_line_pointer--;		/* Put terminator back into stream.  */
  demand_empty_rest_of_line ();
}

/* Mitsubishi asked that we support some old syntax that apparently
   had immediate operands starting with '#'.  This is in some of their
   sample code but is not documented (although it appears in some
   examples in their assembler manual). For now, we'll solve this
   compatibility problem by simply ignoring any '#' at the beginning
   of an operand.  */

/* Operands that begin with '#' should fall through to here.
   From expr.c.  */

void
md_operand (expressionS *expressionP)
{
  if (*input_line_pointer == '#' && ! do_not_ignore_hash)
    {
      input_line_pointer++;
      expression (expressionP);
    }
}

bfd_boolean
d10v_fix_adjustable (fixS *fixP)
{
  /* We need the symbol name for the VTABLE entries.  */
  if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 0;

  return 1;
}

/* The target specific pseudo-ops which we support.  */
const pseudo_typeS md_pseudo_table[] =
{
  { "word",	d10v_dot_word,	2 },
  { NULL,       NULL,           0 }
};

void
md_assemble (char *str)
{
  /* etype is saved extype.  For multi-line instructions.  */
  packing_type extype = PACK_UNSPEC;		/* Parallel, etc.  */
  struct d10v_opcode *opcode;
  unsigned long insn;
  char *str2;

  if (etype == PACK_UNSPEC)
    {
      /* Look for the special multiple instruction separators.  */
      str2 = strstr (str, "||");
      if (str2)
	extype = PACK_PARALLEL;
      else
	{
	  str2 = strstr (str, "->");
	  if (str2)
	    extype = PACK_LEFT_RIGHT;
	  else
	    {
	      str2 = strstr (str, "<-");
	      if (str2)
		extype = PACK_RIGHT_LEFT;
	    }
	}

      /* str2 points to the separator, if there is one.  */
      if (str2)
	{
	  *str2 = 0;

	  /* If two instructions are present and we already have one saved,
	     then first write out the saved one.  */
	  d10v_cleanup ();

	  /* Assemble first instruction and save it.  */
	  prev_insn = do_assemble (str, &prev_opcode);
	  prev_seg = now_seg;
	  prev_subseg = now_subseg;
	  if (prev_insn == (unsigned long) -1)
	    as_fatal (_("can't find previous opcode "));
	  fixups = fixups->next;
	  str = str2 + 2;
	}
    }

  insn = do_assemble (str, &opcode);
  if (insn == (unsigned long) -1)
    {
      if (extype != PACK_UNSPEC)
	etype = extype;
      else
	as_bad (_("could not assemble: %s"), str);
      return;
    }

  if (etype != PACK_UNSPEC)
    {
      extype = etype;
      etype = PACK_UNSPEC;
    }

  /* If this is a long instruction, write it and any previous short
     instruction.  */
  if (opcode->format & LONG_OPCODE)
    {
      if (extype != PACK_UNSPEC)
	as_fatal (_("Unable to mix instructions as specified"));
      d10v_cleanup ();
      write_long (insn, fixups);
      prev_opcode = NULL;
      return;
    }

  if (prev_opcode
      && prev_seg
      && ((prev_seg != now_seg) || (prev_subseg != now_subseg)))
    d10v_cleanup ();

  if (prev_opcode
      && (0 == write_2_short (prev_opcode, prev_insn, opcode, insn, extype,
			      fixups)))
    {
      /* No instructions saved.  */
      prev_opcode = NULL;
    }
  else
    {
      if (extype != PACK_UNSPEC)
	as_fatal (_("Unable to mix instructions as specified"));
      /* Save last instruction so it may be packed on next pass.  */
      prev_opcode = opcode;
      prev_insn = insn;
      prev_seg = now_seg;
      prev_subseg = now_subseg;
      fixups = fixups->next;
    }
}

@


1.45
log
@	* config/tc-d10v.c (do_assemble): Correctly detect overflow of
	"name" buffer.
	* config/tc-m68hc11.c (md_assemble): Likewise.
	* config/tc-microblaze.c (md_assemble): Likewise.  Correct cast
	of is_end_of_line index.
@
text
@d1122 1
a1122 1
static segT prev_seg = 0;;
@


1.44
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d3 1
a3 1
   2007, 2009
d1423 1
a1423 1
       *op_end && nlen < 20 && !is_end_of_line[*op_end] && *op_end != ' ';
d1428 2
@


1.43
log
@gas/
	* config/tc-d10v.c: Include dwarf2dbg.h.
	(write_long, write_1_short, write_2_short): Call dwarf2_emit_insn.
	(d10v_frob_label): New function.
	* config/tc-d10v.h (d10v_frob_label): Declare.
	(tc_frob_label): Define as d10v_frob_label.
gas/testsuite/
	* gas/lns/lns-common-1.s: Use two nops between each .loc.
	* gas/lns/lns.exp: Don't exclude d10v.
@
text
@d1204 3
a1206 1
	      int flags = d10v_operands[next_opcode->operands[opnum]].flags;
@


1.42
log
@Remove duplicate definitions of the md_atof() function
@
text
@d2 2
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2006, 2007
d28 1
d615 1
d651 1
d1066 1
d1634 9
@


1.42.8.1
log
@gas/
	* config/tc-d10v.c: Include dwarf2dbg.h.
	(write_long, write_1_short, write_2_short): Call dwarf2_emit_insn.
	(d10v_frob_label): New function.
	* config/tc-d10v.h (d10v_frob_label): Declare.
	(tc_frob_label): Define as d10v_frob_label.
gas/testsuite/
	* gas/lns/lns-common-1.s: Use two nops between each .loc.
	* gas/lns/lns.exp: Don't exclude d10v.
@
text
@d2 1
a2 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2006,
   2007, 2009
a26 1
#include "dwarf2dbg.h"
a612 1
  dwarf2_emit_insn (4);
a647 1
  dwarf2_emit_insn (4);
a1061 1
  dwarf2_emit_insn (4);
a1628 9
void
d10v_frob_label (symbolS *lab)
{
  d10v_cleanup ();
  symbol_set_frag (lab, frag_now);
  S_SET_VALUE (lab, (valueT) frag_now_fix ());
  dwarf2_emit_label (lab);
}

@


1.41
log
@Switch to GPLv3
@
text
@a253 5
/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */

d257 1
a257 30
  int prec;
  LITTLENUM_TYPE words[4];
  char *t;
  int i;

  switch (type)
    {
    case 'f':
      prec = 2;
      break;
    case 'd':
      prec = 4;
      break;
    default:
      *sizeP = 0;
      return _("bad call to md_atof");
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizeP = prec * 2;

  for (i = 0; i < prec; i++)
    {
      md_number_to_chars (litP, (valueT) words[i], 2);
      litP += 2;
    }
  return NULL;
@


1.40
log
@PR gas/3797
* config/tc-d10v.c (do_assemble): Do not generate error messages, just return -1 whenever a problem is encoun$
 (md_assemble): If do_assemble returns -1 generate a non-fatal error message and return.
* gas/lns/lns.exp: Do not run the lns-common test for the d10v port.
* gas/d10v/address-002.l: Update expected assembler output.
* gas/d10v/address-003.l, gas/d10v/address-004.l,
  gas/d10v/address-005.l, gas/d10v/address-006.l,
  gas/d10v/address-007.l, gas/d10v/address-008.l,
  gas/d10v/address-009.l, gas/d10v/address-010.l,
  gas/d10v/address-011.l, gas/d10v/address-012.l,
  gas/d10v/address-013.l, gas/d10v/address-014.l,
  gas/d10v/address-015.l, gas/d10v/address-016.l,
  gas/d10v/address-017.l, gas/d10v/address-018.l,
  gas/d10v/address-019.l, gas/d10v/address-020.l,
  gas/d10v/address-021.l, gas/d10v/address-022.l,
  gas/d10v/address-023.l, gas/d10v/address-024.l,
  gas/d10v/address-025.l, gas/d10v/address-026.l,
  gas/d10v/address-027.l, gas/d10v/address-030.l,
  gas/d10v/address-031.l, gas/d10v/address-032.l,
  gas/d10v/address-033.l, gas/d10v/address-034.l,
  gas/d10v/address-035.l, gas/d10v/address-036.l,
  gas/d10v/address-037.l, gas/d10v/address-038.l,
  gas/d10v/address-039.l, gas/d10v/address-040.l,
  gas/d10v/address-041.l: Likewise.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.39
log
@remove some duplicate #include's.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2006
a1442 1
  unsigned long insn;
d1464 1
a1464 1
    as_fatal (_("unknown opcode: %s"), name);
d1473 1
a1473 2
  insn = build_insn ((*opcode), myops, 0);
  return insn;
d1779 1
a1779 1
	    as_fatal (_("can't find opcode "));
d1789 4
a1792 5
	{
	  etype = extype;
	  return;
	}
      as_fatal (_("can't find opcode "));
@


1.38
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005
a21 1
#include <stdio.h>
@


1.37
log
@Update the address and phone number of the FSF
@
text
@d1526 1
a1526 1
md_apply_fix3 (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
@


1.36
log
@2005-04-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-aout.h (S_IS_EXTERN): Removed.
	* config/obj-bout.h (S_IS_EXTERN): Likewise.
	* config/obj-coff.h (S_IS_EXTERN): Likewise.
	* symbols.c (S_IS_EXTERN): Likewise.
	* symbols.h (S_IS_EXTERN): Likewise.

	* config/tc-alpha.c (tc_gen_reloc): Replace S_IS_EXTERN with
	S_IS_EXTERNAL.
	* config/tc-d10v.c (md_apply_fix3): Likewise.
	* config/tc-ia64.c (ia64_fix_adjustable): Likewise.
	* config/tc-iq2000.c (iq2000_fix_adjustable): Likewise.
	* config/tc-m32r.c (m32r_fix_adjustable): Likewise.
	* config/tc-mmix.c (mmix_adjust_symtab): Likewise.
	* config/tc-sh64.c (shmedia_frob_file_before_adjust): Likewise.
	(shmedia_md_convert_frag): Likewise.
	* symbols.c (print_symbol_value_1): Likewise.
	* write.c (write_object_file): Likewise.
@
text
@d19 2
a20 2
   the Free Software Foundation, 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.35
log
@Convert unmaintained files over to ISO-C90 and fix formatting.
@
text
@d1575 1
a1575 1
	  && S_IS_EXTERN (fixP->fx_addsy) )
@


1.34
log
@	* cgen.c: Warning fixes.
	* config/tc-arc.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-frv.c: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ip2k.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-xstormy16.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d29 2
a30 2
const char comment_chars[] = ";";
const char line_comment_chars[] = "#";
d32 3
a34 3
const char *md_shortopts = "O";
const char EXP_CHARS[] = "eE";
const char FLT_CHARS[] = "dD";
d45 2
a46 1
#define MAX_INSN_FIXUPS (5)
a83 23
static int reg_name_search PARAMS ((char *name));
static int register_name PARAMS ((expressionS *expressionP));
static int check_range PARAMS ((unsigned long num, int bits, int flags));
static int postfix PARAMS ((char *p));
static bfd_reloc_code_real_type get_reloc PARAMS ((struct d10v_operand *op));
static int get_operands PARAMS ((expressionS exp[]));
static struct d10v_opcode *find_opcode PARAMS ((struct d10v_opcode *opcode, expressionS ops[]));
static unsigned long build_insn PARAMS ((struct d10v_opcode *opcode, expressionS *opers, unsigned long insn));
static void write_long PARAMS ((unsigned long insn, Fixups *fx));
static void write_1_short PARAMS ((struct d10v_opcode *opcode, unsigned long insn, Fixups *fx));
static int write_2_short PARAMS ((struct d10v_opcode *opcode1, unsigned long insn1,
				  struct d10v_opcode *opcode2, unsigned long insn2, packing_type exec_type, Fixups *fx));
static unsigned long do_assemble PARAMS ((char *str, struct d10v_opcode **opcode));
static unsigned long d10v_insert_operand PARAMS (( unsigned long insn, int op_type,
						   offsetT value, int left, fixS *fix));
static int parallel_ok PARAMS ((struct d10v_opcode *opcode1, unsigned long insn1,
				struct d10v_opcode *opcode2, unsigned long insn2,
				packing_type exec_type));

static void check_resource_conflict PARAMS ((struct d10v_opcode *opcode1,
					     unsigned long insn1,
					     struct d10v_opcode *opcode2,
					     unsigned long insn2));
d85 6
a90 1
static symbolS * find_symbol_matching_register PARAMS ((expressionS *));
a93 1
#define OPTION_NOWARNSWAP (OPTION_MD_BASE)
a94 1
#define OPTION_GSTABSPACKING (OPTION_MD_BASE + 1)
a96 1
#define OPTION_NOGSTABSPACKING (OPTION_MD_BASE + 2)
a103 9
static void d10v_dot_word PARAMS ((int));

/* The target specific pseudo-ops which we support.  */
const pseudo_typeS md_pseudo_table[] =
{
  { "word",	d10v_dot_word,	2 },
  { NULL,       NULL,           0 }
};

d112 1
a112 2
reg_name_search (name)
     char *name;
d139 1
a139 2
register_name (expressionP)
     expressionS *expressionP;
d169 1
a169 4
check_range (num, bits, flags)
     unsigned long num;
     int bits;
     int flags;
d215 1
a215 2
md_show_usage (stream)
     FILE *stream;
d226 1
a226 3
md_parse_option (c, arg)
     int c;
     char *arg ATTRIBUTE_UNUSED;
d250 1
a250 2
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
d261 1
a261 4
md_atof (type, litP, sizeP)
     int type;
     char *litP;
     int *sizeP;
d296 3
a298 4
md_convert_frag (abfd, sec, fragP)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     fragS *fragP ATTRIBUTE_UNUSED;
d304 1
a304 3
md_section_align (seg, addr)
     asection *seg;
     valueT addr;
d311 1
a311 1
md_begin ()
d340 1
a340 2
postfix (p)
     char *p;
d352 1
a352 1
      return (-1);
d357 1
a357 1
      return (1);
d360 1
a360 1
  return (0);
d364 1
a364 2
get_reloc (op)
     struct d10v_operand *op;
d369 1
a369 1
    return (0);
d374 1
a374 1
	return (BFD_RELOC_D10V_10_PCREL_R);
d376 1
a376 1
	return (BFD_RELOC_D10V_18_PCREL);
d379 1
a379 1
  return (BFD_RELOC_16);
d385 1
a385 2
get_operands (exp)
     expressionS exp[];
d517 1
a517 1
  return (numops);
d521 5
a525 6
d10v_insert_operand (insn, op_type, value, left, fix)
     unsigned long insn;
     int op_type;
     offsetT value;
     int left;
     fixS *fix;
d550 3
a552 4
build_insn (opcode, opers, insn)
     struct d10v_opcode *opcode;
     expressionS *opers;
     unsigned long insn;
d643 1
a643 3
write_long (insn, fx)
     unsigned long insn;
     Fixups *fx;
d676 3
a678 4
write_1_short (opcode, insn, fx)
     struct d10v_opcode *opcode;
     unsigned long insn;
     Fixups *fx;
d722 2
a723 4
/* Expects two short instructions.
   If possible, writes out both as a single packed instruction.
   Otherwise, writes out the first one, packed with a NOP.
   Returns number of instructions not written out.  */
d725 5
a729 6
static int
write_2_short (opcode1, insn1, opcode2, insn2, exec_type, fx)
     struct d10v_opcode *opcode1, *opcode2;
     unsigned long insn1, insn2;
     packing_type exec_type;
     Fixups *fx;
d731 21
a751 3
  unsigned long insn;
  char *f;
  int i, j, where;
d753 9
a761 3
  if ((exec_type != PACK_PARALLEL)
      && ((opcode1->exec_type & PARONLY) || (opcode2->exec_type & PARONLY)))
    as_fatal (_("Instruction must be executed in parallel"));
d763 8
a770 2
  if ((opcode1->format & LONG_OPCODE) || (opcode2->format & LONG_OPCODE))
    as_fatal (_("Long instructions may not be combined."));
d772 1
a772 1
  switch (exec_type)
d774 1
a774 2
    case PACK_UNSPEC:	/* Order not specified.  */
      if (opcode1->exec_type & ALONE)
d776 2
a777 14
	  /* Case of a short branch on a separate GAS line.  Pack with NOP.  */
	  write_1_short (opcode1, insn1, fx->next);
	  return 1;
	}
      if (Optimizing
	  && parallel_ok (opcode1, insn1, opcode2, insn2, exec_type))
	{
	  /* Parallel.  */
	  if (opcode1->unit == IU)
	    insn = FM00 | (insn2 << 15) | insn1;
	  else if (opcode2->unit == MU)
	    insn = FM00 | (insn2 << 15) | insn1;
	  else
	    insn = FM00 | (insn1 << 15) | insn2;
a778 3
      else if (opcode1->unit == IU)
	/* Reverse sequential with IU opcode1 on right and done first.  */
	insn = FM10 | (insn2 << 15) | insn1;
a779 9
	/* Sequential with non-IU opcode1 on left and done first.  */
	insn = FM01 | (insn1 << 15) | insn2;
      break;

    case PACK_PARALLEL:
      if (opcode1->exec_type & SEQ || opcode2->exec_type & SEQ)
	as_fatal
	  (_("One of these instructions may not be executed in parallel."));
      if (opcode1->unit == IU)
d781 2
a782 5
	  if (opcode2->unit == IU)
	    as_fatal (_("Two IU instructions may not be executed in parallel"));
	  if (!flag_warn_suppress_instructionswap)
	    as_warn (_("Swapping instruction order"));
	  insn = FM00 | (insn2 << 15) | insn1;
d784 3
a786 12
      else if (opcode2->unit == MU)
	{
	  if (opcode1->unit == MU)
	    as_fatal (_("Two MU instructions may not be executed in parallel"));
	  if (!flag_warn_suppress_instructionswap)
	    as_warn (_("Swapping instruction order"));
	  insn = FM00 | (insn2 << 15) | insn1;
	}
      else
	insn = FM00 | (insn1 << 15) | insn2;
      check_resource_conflict (opcode1, insn1, opcode2, insn2);
      break;
d788 1
a788 4
    case PACK_LEFT_RIGHT:
      if (opcode1->unit != IU)
	insn = FM01 | (insn1 << 15) | insn2;
      else if (opcode2->unit == MU || opcode2->unit == EITHER)
d790 19
a808 9
	  if (!flag_warn_suppress_instructionswap)
	    as_warn (_("Swapping instruction order"));
	  insn = FM10 | (insn2 << 15) | insn1;
	}
      else
	as_fatal (_("IU instruction may not be in the left container"));
      if (opcode1->exec_type & ALONE)
	as_warn (_("Instruction in R container is squashed by flow control instruction in L container."));
      break;
d810 16
a825 8
    case PACK_RIGHT_LEFT:
      if (opcode2->unit != MU)
	insn = FM10 | (insn1 << 15) | insn2;
      else if (opcode1->unit == IU || opcode1->unit == EITHER)
	{
	  if (!flag_warn_suppress_instructionswap)
	    as_warn (_("Swapping instruction order"));
	  insn = FM01 | (insn2 << 15) | insn1;
a826 5
      else
	as_fatal (_("MU instruction may not be in the right container"));
      if (opcode2->exec_type & ALONE)
	as_warn (_("Instruction in R container is squashed by flow control instruction in L container."));
      break;
d828 6
a833 2
    default:
      as_fatal (_("unknown execution type passed to write_2_short()"));
d836 3
a838 7
  f = frag_more (4);
  number_to_chars_bigendian (f, insn, 4);

  /* Process fixup chains.  fx refers to insn2 when j == 0, and to
     insn1 when j == 1.  Yes, it's reversed.  */

  for (j = 0; j < 2; j++)
d840 2
a841 7
      for (i = 0; i < fx->fc; i++)
	{
	  if (fx->fix[i].reloc)
	    {
	      where = f - frag_now->fr_literal;
	      if (fx->fix[i].size == 2)
		where += 2;
d843 12
a854 27
	      if (fx->fix[i].reloc == BFD_RELOC_D10V_10_PCREL_R
		  /* A BFD_RELOC_D10V_10_PCREL_R relocation applied to
		     the instruction in the L container has to be
		     adjusted to BDF_RELOC_D10V_10_PCREL_L.  When
		     j==0, we're processing insn2's operands, so we
		     want to mark the operand if insn2 is *not* in the
		     R container.  When j==1, we're processing insn1's
		     operands, so we want to mark the operand if insn2
		     *is* in the R container.  Note that, if two
		     instructions are identical, we're never going to
		     swap them, so the test is safe.  */
		  && j == ((insn & 0x7fff) == insn2))
		fx->fix[i].operand |= 1024;

	      if (fx->fix[i].reloc == BFD_RELOC_D10V_18)
		fx->fix[i].operand |= 4096;

	      fix_new_exp (frag_now,
			   where,
			   fx->fix[i].size,
			   &(fx->fix[i].exp),
			   fx->fix[i].pcrel,
			   fx->fix[i].operand|2048);
	    }
	}
      fx->fc = 0;
      fx = fx->next;
a855 1
  return (0);
d862 5
a866 4
parallel_ok (op1, insn1, op2, insn2, exec_type)
     struct d10v_opcode *op1, *op2;
     unsigned long insn1, insn2;
     packing_type exec_type;
d985 12
a996 7
/* Determine if there are any resource conflicts among two manually
   parallelized instructions.  Some of this was lifted from parallel_ok.  */

static void
check_resource_conflict (op1, insn1, op2, insn2)
     struct d10v_opcode *op1, *op2;
     unsigned long insn1, insn2;
d998 3
a1000 3
  int i, j, flags, mask, shift, regno;
  unsigned long ins, mod[2];
  struct d10v_opcode *op;
d1002 3
a1004 7
  if ((op1->exec_type & SEQ)
      || ! ((op1->exec_type & PAR) || (op1->exec_type & PARONLY)))
    {
      as_warn (_("packing conflict: %s must dispatch sequentially"),
	      op1->name);
      return;
    }
d1006 2
a1007 7
  if ((op2->exec_type & SEQ)
      || ! ((op2->exec_type & PAR) || (op2->exec_type & PARONLY)))
    {
      as_warn (_("packing conflict: %s must dispatch sequentially"),
	      op2->name);
      return;
    }
d1009 1
a1009 22
   /* See if both instructions write to the same resource.

      The idea here is to create two sets of bitmasks (mod and used) which
      indicate which registers are modified or used by each instruction.
      The operation can only be done in parallel if neither instruction
      modifies the same register. Accesses to control registers and memory
      are treated as accesses to a single register. So if both instructions
      write memory or if the first instruction writes memory and the second
      reads, then they cannot be done in parallel. We treat reads to the PSW
      (which includes C, F0, and F1) in isolation. So simultaneously writing
      C and F0 in two different sub-instructions is permitted.  */

  /* The bitmasks (mod and used) look like this (bit 31 = MSB).
     r0-r15	  0-15
     a0-a1	  16-17
     cr (not psw) 18
     psw(other)   19
     mem	  20
     psw(C flag)  21
     psw(F0 flag) 22  */

  for (j = 0; j < 2; j++)
d1011 2
a1012 1
      if (j == 0)
d1014 3
a1016 2
	  op = op1;
	  ins = insn1;
d1018 2
a1019 1
      else
d1021 7
a1027 2
	  op = op2;
	  ins = insn2;
d1029 7
a1035 3
      mod[j] = 0;
      if (op->exec_type & BRANCH_LINK)
	mod[j] |= 1 << 13;
d1037 5
a1041 1
      for (i = 0; op->operands[i]; i++)
d1043 5
a1047 36
	  flags = d10v_operands[op->operands[i]].flags;
	  shift = d10v_operands[op->operands[i]].shift;
	  mask = 0x7FFFFFFF >> (31 - d10v_operands[op->operands[i]].bits);
	  if (flags & OPERAND_REG)
	    {
	      regno = (ins >> shift) & mask;
	      if (flags & (OPERAND_ACC0 | OPERAND_ACC1))
		regno += 16;
	      else if (flags & OPERAND_CONTROL)	/* mvtc or mvfc */
		{
		  if (regno == 0)
		    regno = 19;
		  else
		    regno = 18;
		}
	      else if (flags & OPERAND_FFLAG)
		regno = 22;
	      else if (flags & OPERAND_CFLAG)
		regno = 21;

	      if (flags & OPERAND_DEST
		  /* Auto inc/dec also modifies the register.  */
		  || (op->operands[i + 1] != 0
		      && (d10v_operands[op->operands[i + 1]].flags
			  & (OPERAND_PLUS | OPERAND_MINUS)) != 0))
		{
		  mod[j] |= 1 << regno;
		  if (flags & OPERAND_EVEN)
		    mod[j] |= 1 << (regno + 1);
		}
	    }
	  else if (flags & OPERAND_ATMINUS)
	    {
	      /* SP implicitly used/modified.  */
	      mod[j] |= 1 << 15;
	    }
d1049 1
a1049 61

      if (op->exec_type & WMEM)
	mod[j] |= 1 << 20;
      else if (op->exec_type & WF0)
	mod[j] |= 1 << 22;
      else if (op->exec_type & WCAR)
	mod[j] |= 1 << 21;
    }

  if ((mod[0] & mod[1]) == 0)
    return;
  else
    {
      unsigned long x;
      x = mod[0] & mod[1];

      for (j = 0; j <= 15; j++)
	if (x & (1 << j))
	  as_warn (_("resource conflict (R%d)"), j);
      for (j = 16; j <= 17; j++)
	if (x & (1 << j))
	  as_warn (_("resource conflict (A%d)"), j - 16);
      if (x & (1 << 19))
	as_warn (_("resource conflict (PSW)"));
      if (x & (1 << 21))
	as_warn (_("resource conflict (C flag)"));
      if (x & (1 << 22))
	as_warn (_("resource conflict (F flag)"));
    }
}

/* This is the main entry point for the machine-dependent assembler.
   str points to a machine-dependent instruction.  This function is
   supposed to emit the frags/bytes it assembles to.  For the D10V, it
   mostly handles the special VLIW parsing and packing and leaves the
   difficult stuff to do_assemble().  */

static unsigned long prev_insn;
static struct d10v_opcode *prev_opcode = 0;
static subsegT prev_subseg;
static segT prev_seg = 0;;

void
md_assemble (str)
     char *str;
{
  /* etype is saved extype.  For multi-line instructions.  */

  packing_type extype = PACK_UNSPEC;		/* Parallel, etc.  */

  struct d10v_opcode *opcode;
  unsigned long insn;
  char *str2;

  if (etype == PACK_UNSPEC)
    {
      /* Look for the special multiple instruction separators.  */
      str2 = strstr (str, "||");
      if (str2)
	extype = PACK_PARALLEL;
      else
d1051 5
a1055 9
	  str2 = strstr (str, "->");
	  if (str2)
	    extype = PACK_LEFT_RIGHT;
	  else
	    {
	      str2 = strstr (str, "<-");
	      if (str2)
		extype = PACK_RIGHT_LEFT;
	    }
d1057 4
d1062 4
a1065 2
      /* str2 points to the separator, if there is one.  */
      if (str2)
d1067 3
a1069 14
	  *str2 = 0;

	  /* If two instructions are present and we already have one saved,
	     then first write out the saved one.  */
	  d10v_cleanup ();

	  /* Assemble first instruction and save it.  */
	  prev_insn = do_assemble (str, &prev_opcode);
	  prev_seg = now_seg;
	  prev_subseg = now_subseg;
	  if (prev_insn == (unsigned long) -1)
	    as_fatal (_("can't find opcode "));
	  fixups = fixups->next;
	  str = str2 + 2;
d1071 5
a1075 1
    }
d1077 4
a1080 4
  insn = do_assemble (str, &opcode);
  if (insn == (unsigned long) -1)
    {
      if (extype != PACK_UNSPEC)
d1082 3
a1084 2
	  etype = extype;
	  return;
d1086 5
a1090 2
      as_fatal (_("can't find opcode "));
    }
d1092 2
a1093 40
  if (etype != PACK_UNSPEC)
    {
      extype = etype;
      etype = PACK_UNSPEC;
    }

  /* If this is a long instruction, write it and any previous short
     instruction.  */
  if (opcode->format & LONG_OPCODE)
    {
      if (extype != PACK_UNSPEC)
	as_fatal (_("Unable to mix instructions as specified"));
      d10v_cleanup ();
      write_long (insn, fixups);
      prev_opcode = NULL;
      return;
    }

  if (prev_opcode
      && prev_seg
      && ((prev_seg != now_seg) || (prev_subseg != now_subseg)))
    d10v_cleanup ();

  if (prev_opcode
      && (0 == write_2_short (prev_opcode, prev_insn, opcode, insn, extype,
			      fixups)))
    {
      /* No instructions saved.  */
      prev_opcode = NULL;
    }
  else
    {
      if (extype != PACK_UNSPEC)
	as_fatal (_("Unable to mix instructions as specified"));
      /* Save last instruction so it may be packed on next pass.  */
      prev_opcode = opcode;
      prev_insn = insn;
      prev_seg = now_seg;
      prev_subseg = now_subseg;
      fixups = fixups->next;
a1094 1
}
d1096 2
a1097 2
/* Assemble a single instruction.
   Return an opcode, or -1 (an invalid opcode) on error.  */
d1099 2
a1100 11
static unsigned long
do_assemble (str, opcode)
     char *str;
     struct d10v_opcode **opcode;
{
  unsigned char *op_start, *op_end;
  char *save;
  char name[20];
  int nlen = 0;
  expressionS myops[6];
  unsigned long insn;
d1102 9
a1110 3
  /* Drop leading whitespace.  */
  while (*str == ' ')
    str++;
d1112 13
a1124 9
  /* Find the opcode end.  */
  for (op_start = op_end = (unsigned char *) str;
       *op_end && nlen < 20 && !is_end_of_line[*op_end] && *op_end != ' ';
       op_end++)
    {
      name[nlen] = TOLOWER (op_start[nlen]);
      nlen++;
    }
  name[nlen] = 0;
d1126 2
a1127 2
  if (nlen == 0)
    return -1;
d1129 13
a1141 4
  /* Find the first opcode with the proper name.  */
  *opcode = (struct d10v_opcode *) hash_find (d10v_hash, name);
  if (*opcode == NULL)
    as_fatal (_("unknown opcode: %s"), name);
d1143 5
a1147 6
  save = input_line_pointer;
  input_line_pointer = (char *) op_end;
  *opcode = find_opcode (*opcode, myops);
  if (*opcode == 0)
    return -1;
  input_line_pointer = save;
d1149 4
a1152 3
  insn = build_insn ((*opcode), myops, 0);
  return (insn);
}
d1157 1
a1157 2
find_symbol_matching_register (exp)
     expressionS *exp;
d1181 1
a1181 3
find_opcode (opcode, myops)
     struct d10v_opcode *opcode;
     expressionS myops[];
d1301 2
a1302 4
	{
	  /* Not a constant, so use a long instruction.  */
	  opcode += 2;
	}
d1395 1
a1395 1
      return (0);
d1433 46
d1483 1
a1483 3
tc_gen_reloc (seg, fixp)
     asection *seg ATTRIBUTE_UNUSED;
     fixS *fixp;
d1486 2
a1487 2
  reloc = (arelent *) xmalloc (sizeof (arelent));
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
d1508 2
a1509 3
md_estimate_size_before_relax (fragp, seg)
     fragS *fragp ATTRIBUTE_UNUSED;
     asection *seg ATTRIBUTE_UNUSED;
d1516 1
a1516 3
md_pcrel_from_section (fixp, sec)
     fixS *fixp;
     segT sec;
d1526 1
a1526 4
md_apply_fix3 (fixP, valP, seg)
     fixS *fixP;
     valueT *valP;
     segT seg ATTRIBUTE_UNUSED;
d1638 1
a1638 1
d10v_cleanup ()
d1670 1
a1670 2
d10v_dot_word (dummy)
     int dummy ATTRIBUTE_UNUSED;
d1713 1
a1713 2
md_operand (expressionP)
     expressionS *expressionP;
d1723 1
a1723 2
d10v_fix_adjustable (fixP)
     fixS *fixP;
d1732 110
@


1.33
log
@	* config/tc-a29k.h: Fix comment typos.
	* config/tc-alpha.c: Likewise.
	* config/tc-alpha.h: Likewise.
	* config/tc-arc.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-cris.c: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-dlx.c: Likewise.
	* config/tc-dlx.h: Likewise.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d1316 2
a1317 2
  unsigned char *op_start, *save;
  unsigned char *op_end;
d1328 2
a1329 4
  for (op_start = op_end = (unsigned char *) (str);
       *op_end
       && nlen < 20
       && !is_end_of_line[*op_end] && *op_end != ' ';
d1346 1
a1346 1
  input_line_pointer = op_end;
@


1.32
log
@	* symbols.c (S_FORCE_RELOC): Add "strict" param.
	* symbols.h (S_FORCE_RELOC): Likewise.
	* config/obj-aout.h (S_FORCE_RELOC): Likewise.
	* config/obj-bout.h (S_FORCE_RELOC): Likewise.
	* config/obj-coff.h (S_FORCE_RELOC): Likewise.
	* config/obj-ieee.h (S_FORCE_RELOC): Likewise.
	* config/obj-vms.h (S_FORCE_RELOC): Likewise.
	* write.c (generic_force_reloc): New function.
	(TC_FORCE_RELOCATION): Use it here instead of S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	(adjust_reloc_syms): Adjust S_FORCE_RELOC call.
	* as.h (generic_force_reloc): Declare.
	* doc/internals.texi (S_FORCE_RELOC): Update.
	(TC_FORCE_RELOCATION_SUB_SAME): Update.

	* config/tc-alpha.c (alpha_force_relocation): Adjust to use
	generic_force_reloc.
	(alpha_fix_adjustable): Likewise.
	* config/tc-arm.c (arm_force_relocation): Likewise.
	* config/tc-cris.c (md_cris_force_relocation): Likewise.
	* config/tc-frv.c (frv_force_relocation): Likewise.
	* config/tc-i386.c (md_apply_fix3): Likewise.
	* config/tc-ia64.c (ia64_force_relocation): Likewise.
	* config/tc-ip2k.c (ip2k_force_relocation): Likewise.
	* config/tc-m32r.c (m32r_force_relocation): Likewise.
	* config/tc-m68hc11.c (tc_m68hc11_force_relocation): Likewise.
	* config/tc-mcore.c (mcore_force_relocation): Likewise.
	* config/tc-mips.c (mips_force_relocation): Likewise.
	* config/tc-mmix.c (mmix_force_relocation): Likewise.
	* config/tc-ppc.c (ppc_force_relocation): Likewise.
	* config/tc-s390.c (tc_s390_force_relocation): Likewise.
	* config/tc-sh.c (sh_force_relocation): Likewise.
	(md_pcrel_from_section): Likewise.
	* config/tc-sparc.c (tc_gen_reloc): Likewise.
	* config/tc-v850.c (v850_force_relocation): Likewise.
	* config/tc-xstormy16.c (xstormy16_force_relocation): Likewise.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-mcore.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-sparc.h (tc_fix_adjustable): Likewise.

	* config/tc-d10v.c (d10v_force_relocation): Delete.
	* config/tc-d10v.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-dlx.c (md_dlx_force_relocation): Delete.
	* config/tc-dlx.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-fr30.c (fr30_force_relocation): Delete.
	* config/tc-fr30.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-mn10300.c (mn10300_force_relocation): Delete.
	* config/tc-mn10300.h (TC_FORCE_RELOCATION): Don't define.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-i960.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
	* config/tc-hppa.c (hppa_force_relocation): Adjust S_FORCE_RELOC call.
	* config/tc-mips.c (RELAX_BRANCH_TOOFAR): Warning fix.
	* config/tc-mips.h (TC_FORCE_RELOCATION_SUB_SAME): Don't define.
	* config/tc-openrisc.c (openrisc_force_relocation): Delete.
	* config/tc-openrisc.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sparc.c (elf32_sparc_force_relocation): Delete.
	* config/tc-sparc.h (TC_FORCE_RELOCATION): Don't define for ELF.
	* config/tc-i386.c (i386_force_relocation): Delete.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Don't define for
	BFD_ASSEMBLER.
	(EXTERN_FORCE_RELOC): Fix TE_PE and STRICT_PE_FORMAT nesting.
	* config/tc-m68k.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-pj.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sh.h (TC_FORCE_RELOCATION_SUB_ABS): Don't call
	S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-sh64.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
@
text
@d638 1
a638 1
	      /* Reconize XXX>>1+N aka XXX@@word+N as special (AT_WORD).  */
d1557 1
a1557 1
	  /* Unfortunatly, for the indirect operand in instructions such
@


1.31
log
@	* ChangeLog-9295: Fix a typo.
	* README: Likewise.
	* config/tc-d10v.c: Fix a comment typo.
	* config/tc-dlx.c: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-h8500.h: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-tic80.h: Likewise.
	* config/tc-w65.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-z8k.h: Likewise.
	* testsuite/gas/h8300/cmpsi2.s: Likewise.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002
a1904 11
}

int
d10v_force_relocation (fixp)
     fixS *fixp;
{
  if (fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 1;

  return S_FORCE_RELOC (fixp->fx_addsy);
@


1.30
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d654 1
a654 1
	      /* Check that a immediate was passed to ops that expect one. */
@


1.29
log
@gas reloc rewrite.
@
text
@d74 1
a74 1
/* True if instruction swapping warnings should be inhibited.
d76 1
a76 1
static boolean flag_warn_suppress_instructionswap;
d78 1
a78 1
/* True if instruction packing should be performed when --gstabs is specified.
d80 1
a80 1
static boolean flag_allow_gstabs_packing = 1;
d102 3
a104 3
static void check_resource_conflict PARAMS ((struct d10v_opcode *opcode1, 
					     unsigned long insn1, 
					     struct d10v_opcode *opcode2, 
d655 1
a655 1
	      if ((flags & OPERAND_NUM) 
d669 1
a669 1
	    (flags & OPERAND_ADDR) ? true : false;
d672 1
a672 1
  
d680 2
a681 2
  /* kludge: for DIVS, we need to put the operands in twice on the second 
     pass, format is changed to LONG_R to force the second set of operands 
d738 2
a739 2
  /* The other container needs to be NOP.  
     According to 4.3.1: for FM=00, sub-instructions performed only by IU 
d972 2
a973 2
  /* The bitmasks (mod and used) look like this (bit 31 = MSB). 
     r0-r15	  0-15   
d1060 1
a1060 1
static void 
d1133 1
a1133 1
		{ 
d1137 1
a1137 1
		    regno = 18; 
d1143 1
a1143 1
	      
d1289 1
a1289 1
      && (0 == write_2_short (prev_opcode, prev_insn, opcode, insn, extype, 
d1457 1
a1457 1
		  boolean found_symbol;
d1464 1
a1464 1
		  found_symbol = false;
d1476 1
a1476 1
			found_symbol = true;
d1515 1
a1515 1
  
d1557 7
a1563 7
	  /* Unfortunatly, for the indirect operand in instructions such 
	     as ``ldb r1, @@(c,r14)'' this function can be passed 
	     X_op == O_register (because 'c' is a valid register name).  
	     However we cannot just ignore the case when X_op == O_register 
	     but flags & OPERAND_REG is null, so we check to see if a symbol 
	     of the same name as the register exists.  If the symbol does 
	     exist, then the parser was unable to distinguish the two cases 
d1569 1
a1569 1
		  
d1767 1
a1767 1
	      && ((repi != NULL 
d1769 1
a1769 1
		  || (rep != NULL 
d1895 1
a1895 1
boolean
@


1.28
log
@d10v fixes.
@
text
@d1664 1
a1664 2
  if (fixp->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixp->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
d1667 1
a1667 1
  reloc->addend = fixp->fx_addnumber;
d1696 1
a1696 1
     valueT * valP;
d1701 1
a1701 1
  long value = * (long *) valP;
d1708 3
a1710 19
  else if (fixP->fx_pcrel)
    ;

  else
    {
      value = fixP->fx_offset;

      if (fixP->fx_subsy != (symbolS *) NULL)
	{
	  if (S_GET_SEGMENT (fixP->fx_subsy) == absolute_section)
	    value -= S_GET_VALUE (fixP->fx_subsy);
	  else
	    {
	      /* We don't actually support subtracting a symbol.  */
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("expression too complex"));
	    }
	}
    }
a1898 10
  if (fixP->fx_addsy == NULL)
    return 1;

  /* Prevent all adjustments to global and weak symbols or symbols in
     merge sections.  */
  if ((S_IS_EXTERN (fixP->fx_addsy)
       || (S_IS_WEAK (fixP->fx_addsy))
       || (S_GET_SEGMENT (fixP->fx_addsy)->flags & SEC_MERGE) != 0))
    return 0;

d1915 1
a1915 1
  return 0;
@


1.27
log
@	* config/obj-coff.c: Fix formatting.
	* config/obj-elf.c: Likewise.
	* config/tc-alpha.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-hppa.c: Likewise.
@
text
@d102 3
a104 3
static void check_resource_conflict PARAMS ((struct d10v_opcode *opcode1,
					     unsigned long insn1,
					     struct d10v_opcode *opcode2,
d650 9
a658 2
	    fixups->fix[fixups->fc].reloc =
	      get_reloc ((struct d10v_operand *) &d10v_operands[opcode->operands[i]]);
d672 1
a672 1

d680 2
a681 2
  /* kludge: for DIVS, we need to put the operands in twice on the second
     pass, format is changed to LONG_R to force the second set of operands
d738 2
a739 2
  /* The other container needs to be NOP.
     According to 4.3.1: for FM=00, sub-instructions performed only by IU
d951 2
a952 2
  /* If this is auto parallization, and either instruction is a branch,
     don't parallel.  */
d954 1
a954 2
      && (op1->exec_type & (ALONE | BRANCH)
	  || op2->exec_type & (ALONE | BRANCH)))
d972 2
a973 2
  /* The bitmasks (mod and used) look like this (bit 31 = MSB).
     r0-r15	  0-15
d1060 1
a1060 1
static void
d1066 1
a1066 1
  unsigned long ins, mod[2], used[2];
d1085 11
a1095 14
  /* The idea here is to create two sets of bitmasks (mod and used)
     which indicate which registers are modified or used by each
     instruction.  The operation can only be done in parallel if
     instruction 1 and instruction 2 modify different registers, and
     the first instruction does not modify registers that the second
     is using (The second instruction can modify registers that the
     first is using as they are only written back after the first
     instruction has completed).  Accesses to control registers
     and memory are treated as accesses to a single register.  So if
     both instructions write memory or if the first instruction writes
     memory and the second reads, then they cannot be done in
     parallel. We treat reads to the PSW (which includes C, F0, and F1)
     in isolation. So simultaneously writing C and F0 in two different
     sub-instructions is permitted.  */
d1118 1
a1118 1
      mod[j] = used[j] = 0;
d1133 1
a1133 1
		{
d1137 1
a1137 1
		    regno = 18;
d1143 6
a1148 2

	      if ( flags & OPERAND_DEST )
a1153 12
	      else
		{
		  used[j] |= 1 << regno ;
		  if (flags & OPERAND_EVEN)
		    used[j] |= 1 << (regno + 1);

		  /* Auto inc/dec also modifies the register.  */
		  if (op->operands[i+1] != 0
		      && (d10v_operands[op->operands[i+1]].flags
			  & (OPERAND_PLUS | OPERAND_MINUS)) != 0)
		    mod[j] |= 1 << regno;
		}
a1158 1
	      used[j] |= 1 << 15;
d1161 2
a1162 3
      if (op->exec_type & RMEM)
	used[j] |= 1 << 20;
      else if (op->exec_type & WMEM)
a1163 2
      else if (op->exec_type & RF0)
	used[j] |= 1 << 22;
d1169 1
d1193 1
a1193 1
   STR points to a machine-dependent instruction.  This function is
d1289 1
a1289 1
      && (0 == write_2_short (prev_opcode, prev_insn, opcode, insn, extype,
d1515 1
a1515 1

d1557 7
a1563 7
	  /* Unfortunatly, for the indirect operand in instructions such
	     as ``ldb r1, @@(c,r14)'' this function can be passed
	     X_op == O_register (because 'c' is a valid register name).
	     However we cannot just ignore the case when X_op == O_register
	     but flags & OPERAND_REG is null, so we check to see if a symbol
	     of the same name as the register exists.  If the symbol does
	     exist, then the parser was unable to distinguish the two cases
d1569 1
a1569 1

d1764 3
a1766 3
	{
	  segT fseg = S_GET_SEGMENT (fixP->fx_addsy);
	  segment_info_type *segf = seg_info(fseg);
d1770 1
a1770 1
	}
d1784 1
a1784 1
	      && ((repi != NULL
d1786 1
a1786 1
		  || (rep != NULL
@


1.26
log
@Prevent adjustments to symbols in merge sections.
@
text
@d102 3
a104 3
static void check_resource_conflict PARAMS ((struct d10v_opcode *opcode1, 
					     unsigned long insn1, 
					     struct d10v_opcode *opcode2, 
d673 2
a674 2
  /* kludge: for DIVS, we need to put the operands in twice on the second 
     pass, format is changed to LONG_R to force the second set of operands 
d731 2
a732 2
  /* The other container needs to be NOP.  
     According to 4.3.1: for FM=00, sub-instructions performed only by IU 
d947 1
a947 1
      && (op1->exec_type & (ALONE | BRANCH) 
d966 2
a967 2
  /* The bitmasks (mod and used) look like this (bit 31 = MSB). 
     r0-r15	  0-15   
d1054 1
a1054 1
static void 
d1130 1
a1130 1
		{ 
d1134 1
a1134 1
		    regno = 18; 
d1140 2
a1141 2
	      
            if ( flags & OPERAND_DEST )
d1147 12
a1158 12
            else
              {
                used[j] |= 1 << regno ;
                if (flags & OPERAND_EVEN)
                  used[j] |= 1 << (regno + 1);

                /* Auto inc/dec also modifies the register.  */
                if (op->operands[i+1] != 0
                    && (d10v_operands[op->operands[i+1]].flags
                        & (OPERAND_PLUS | OPERAND_MINUS)) != 0)
                  mod[j] |= 1 << regno;
              }
d1297 1
a1297 1
      && (0 == write_2_short (prev_opcode, prev_insn, opcode, insn, extype, 
d1523 1
a1523 1
  
d1565 7
a1571 7
	  /* Unfortunatly, for the indirect operand in instructions such 
	     as ``ldb r1, @@(c,r14)'' this function can be passed 
	     X_op == O_register (because 'c' is a valid register name).  
	     However we cannot just ignore the case when X_op == O_register 
	     but flags & OPERAND_REG is null, so we check to see if a symbol 
	     of the same name as the register exists.  If the symbol does 
	     exist, then the parser was unable to distinguish the two cases 
d1577 1
a1577 1
		  
d1675 1
a1675 1
  
d1677 1
a1677 1
  
d1772 3
a1774 3
        {
          segT fseg = S_GET_SEGMENT (fixP->fx_addsy);
          segment_info_type *segf = seg_info(fseg);
d1778 1
a1778 1
        }
d1792 1
a1792 1
	      && ((repi != NULL 
d1794 1
a1794 1
		  || (rep != NULL 
@


1.25
log
@Various fixes and improvements for d10v.
@
text
@d1927 5
a1931 4
  /* Prevent all adjustments to global symbols.  */
  if (S_IS_EXTERN (fixP->fx_addsy))
    return 0;
  if (S_IS_WEAK (fixP->fx_addsy))
@


1.24
log
@* config/tc-d10v.c (get_operands): Mark OPERAND_PLUS after
OPERAND_ATSIGN as O_absent.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
a27 1
//#include "read.h"
d101 6
d586 1
a586 1
		  _("operand out of range: %d"), value);
d668 1
a668 1
	as_bad (_("operand out of range: %d"), number);
d673 3
a675 3
  /* kludge: for DIVS, we need to put the operands in twice  */
  /* on the second pass, format is changed to LONG_R to force
     the second set of operands to not be shifted over 15.  */
d731 3
a733 3
  /* The other container needs to be NOP.  */
  /* According to 4.3.1: for FM=00, sub-instructions performed only
     by IU cannot be encoded in L-container.  */
d795 1
a795 2
	  /* Case of a short branch on a separate GAS line.
	     Pack with NOP.  */
d840 1
d947 2
a948 1
      && (op1->exec_type & ALONE || op2->exec_type & ALONE))
d966 6
a971 6
  /* The bitmasks (mod and used) look like this (bit 31 = MSB).  */
  /* r0-r15	  0-15   */
  /* a0-a1	  16-17  */
  /* cr (not psw) 18     */
  /* psw	  19     */
  /* mem	  20     */
d1051 149
d1241 2
a1242 1
      /* STR2 points to the separator, if there is one.  */
d1297 2
a1298 1
      && (write_2_short (prev_opcode, prev_insn, opcode, insn, extype, fixups) == 0))
d1366 1
a1366 1
/* Find the symbol which has the same name as the register in EXP.  */
d1456 1
a1456 1
		    return next_opcode;
d1501 1
a1501 1
			    return next_opcode;
d1505 1
a1505 1
		    return next_opcode;
d1509 5
a1513 1
	  as_fatal (_("value out of range"));
d1518 1
a1518 1
	  return opcode + 2;
d1521 6
a1526 1
  else
d1528 12
a1539 11
      match = 0;
      /* Now search the opcode table table for one with operands
	 that matches what we've got.  */
      while (!match)
	{
	  match = 1;
	  for (i = 0; opcode->operands[i]; i++)
	    {
	      int flags = d10v_operands[opcode->operands[i]].flags;
	      int X_op = myops[i].X_op;
	      int num = myops[i].X_add_number;
d1541 8
a1548 1
	      if (X_op == 0)
d1553 1
d1555 9
a1563 13
	      if (flags & OPERAND_REG)
		{
		  if ((X_op != O_register)
		      || (num & ~flags
			  & (OPERAND_GPR | OPERAND_ACC0 | OPERAND_ACC1
			     | OPERAND_FFLAG | OPERAND_CFLAG
			     | OPERAND_CONTROL))
		      || ((flags & OPERAND_SP) && ! (num & OPERAND_SP)))
		    {
		      match = 0;
		      break;
		    }
		}
d1565 8
a1572 9
	      if (((flags & OPERAND_MINUS)   && ((X_op != O_absent) || (num != OPERAND_MINUS))) ||
		  ((flags & OPERAND_PLUS)    && ((X_op != O_absent) || (num != OPERAND_PLUS))) ||
		  ((flags & OPERAND_ATMINUS) && ((X_op != O_absent) || (num != OPERAND_ATMINUS))) ||
		  ((flags & OPERAND_ATPAR)   && ((X_op != O_absent) || (num != OPERAND_ATPAR))) ||
		  ((flags & OPERAND_ATSIGN)  && ((X_op != O_absent) || ((num != OPERAND_ATSIGN) && (num != OPERAND_ATPAR)))))
		{
		  match = 0;
		  break;
		}
d1574 5
a1578 10
	      /* Unfortunatly, for the indirect operand in
		 instructions such as ``ldb r1, @@(c,r14)'' this
		 function can be passed X_op == O_register (because
		 'c' is a valid register name).  However we cannot
		 just ignore the case when X_op == O_register but
		 flags & OPERAND_REG is null, so we check to see if a
		 symbol of the same name as the register exists.  If
		 the symbol does exist, then the parser was unable to
		 distinguish the two cases and we fix things here.
		 (Ref: PR14826)  */
d1580 1
a1580 1
	      if (!(flags & OPERAND_REG) && (X_op == O_register))
d1582 2
a1583 10
		  symbolS *sym = find_symbol_matching_register (&myops[i]);

		  if (sym != NULL)
		    {
		      myops[i].X_op = X_op = O_symbol;
		      myops[i].X_add_symbol = sym;
		    }
		  else
		    as_bad
		      (_("illegal operand - register name found where none expected"));
d1585 3
d1589 1
d1591 1
a1591 1
	  /* We're only done if the operands matched so far AND there
d1593 4
a1596 4
	  if (match && myops[i].X_op == 0)
	    break;
	  else
	    match = 0;
d1598 1
a1598 1
	  next_opcode = opcode + 1;
d1600 2
a1601 2
	  if (next_opcode->opcode == 0)
	    break;
d1603 2
a1604 2
	  if (strcmp (next_opcode->name, opcode->name))
	    break;
d1606 1
a1606 2
	  opcode = next_opcode;
	}
d1637 9
d1675 1
a1675 1

d1677 1
a1677 1

d1767 13
d1792 4
a1795 2
	      && (  (repi != NULL && (insn & repi->mask) == (unsigned) repi->opcode)
		  || (rep != NULL && (insn & rep->mask) == (unsigned) rep->opcode))
a1855 1

d1862 2
a1863 2
/* Like normal .word, except support @@word.  */
/* Clobbers input_line_pointer, checks end-of-line.  */
d1906 2
a1907 2
/* Operands that begin with '#' should fall through to here.  */
/* From expr.c.  */
@


1.23
log
@* config/tc-d10v.c (write_2_short): Don't skip dummy fixups, so
that we can tell which operand refers to the insn put in the L
container and mark it as such, so that the relocation type can be
adjusted.
@
text
@d462 4
a465 2
		  exp[++numops].X_add_number = OPERAND_PLUS;
		  ++p;
@


1.22
log
@* config/tc-d10v.c (find_opcode): Reject SP operand if
OPERAND_NOSP flag is present.
@
text
@d802 1
a802 5
	    {
	      insn = FM00 | (insn1 << 15) | insn2;
	      /* Advance over dummy fixup since packed insn1 in L.  */
	      fx = fx->next;
	    }
d808 2
a809 6
	{
	  /* Sequential with non-IU opcode1 on left and done first.  */
	  insn = FM01 | (insn1 << 15) | insn2;
	  /* Advance over dummy fixup since packed insn1 in L.  */
	  fx = fx->next;
	}
d833 1
a833 5
	{
	  insn = FM00 | (insn1 << 15) | insn2;
	  /* Advance over dummy fixup since packed insn1 in L.  */
	  fx = fx->next;
	}
a848 2
      /* Advance over dummy fixup.  */
      fx = fx->next;
a863 2
      /* Advance over dummy fixup.  */
      fx = fx->next;
d873 2
a874 7
  /* Process fixup chains.
     Note that the packing code above advanced fx conditionally.
     dlindsay@@cygnus.com:  There's something subtle going on here involving
	_dummy_first_bfd_reloc_code_real.  This is related to the
	difference between BFD_RELOC_D10V_10_PCREL_R and _L, ie whether
	a fixup is done in the L or R container.  A bug in this code
	can pass Plum Hall fine, yet still affect hand-written assembler.  */
d886 12
a897 1
	      if ((fx->fix[i].reloc == BFD_RELOC_D10V_10_PCREL_R) && (j == 0))
@


1.21
log
@* config/tc-d10v.c (get_operands): Emit OPERAND_PLUS for
prefix `+'.
@
text
@d1471 3
@


1.20
log
@* config/tc-d10v.c (find_opcode): Reject non-SP operand if
flags requires SP.
@
text
@d460 5
@


1.19
log
@Update all uses of md_apply_fix to use md_apply_fix3.  Make it a void function.
@
text
@d1279 2
a1280 1
		     | OPERAND_FFLAG | OPERAND_CFLAG | OPERAND_CONTROL)))
d1389 2
a1390 1
			     | OPERAND_CONTROL)))
@


1.18
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d1531 4
a1534 4
int
md_apply_fix3 (fixp, valuep, seg)
     fixS *fixp;
     valueT *valuep;
d1539 1
a1539 1
  long value;
d1543 6
a1548 7
  if (fixp->fx_addsy == (symbolS *) NULL)
    {
      value = *valuep;
      fixp->fx_done = 1;
    }
  else if (fixp->fx_pcrel)
    value = *valuep;
d1551 3
a1553 2
      value = fixp->fx_offset;
      if (fixp->fx_subsy != (symbolS *) NULL)
d1555 2
a1556 2
	  if (S_GET_SEGMENT (fixp->fx_subsy) == absolute_section)
	    value -= S_GET_VALUE (fixp->fx_subsy);
d1560 1
a1560 1
	      as_bad_where (fixp->fx_file, fixp->fx_line,
d1566 1
a1566 1
  op_type = fixp->fx_r_type;
d1573 1
a1573 1
	  fixp->fx_r_type = BFD_RELOC_D10V_10_PCREL_L;
d1579 1
a1579 1
	  fixp->fx_r_type = BFD_RELOC_D10V_18;
d1582 1
a1582 1
	fixp->fx_r_type =
d1588 1
a1588 1
  where = fixp->fx_frag->fr_literal + fixp->fx_where;
d1591 1
a1591 1
  switch (fixp->fx_r_type)
d1599 1
a1599 1
      if (fixp->fx_size == 2)
d1613 1
a1613 1
	       fixp->fx_line);
d1615 1
a1615 1
	    d10v_insert_operand (insn, op_type, (offsetT) value, left, fixp);
d1628 2
a1629 2
      fixp->fx_done = 0;
      return 1;
d1633 1
a1633 1
		fixp->fx_line, fixp->fx_r_type);
a1634 1
  return 0;
@


1.17
log
@Fix copyright notices
@
text
@a22 1
#include <ctype.h>
d24 1
d1188 1
a1188 1
      name[nlen] = tolower (op_start[nlen]);
@


1.16
log
@2001-01-14  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-alpha.c: Fix formatting.
	* config/tc-arc.c: Likewise.
	* config/tc-arc.h: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-vax.c: Likewise.
@
text
@d2 2
a3 1
   Copyright (C) 1996, 97, 98, 99, 2000 Free Software Foundation.
@


1.16.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
@


1.15
log
@* config/tc-d10v.c (md_assemble): set prev_seg and prev_subseg
when we assemble the first half of a pair.
@
text
@d75 1
a75 1
   --nowarnswap.  */   
@


1.14
log
@Add outputting_stabs_line_debug varaible and D10v code to use it
@
text
@d1099 2
@


1.13
log
@2000-08-04  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-cris.c: Rearrange code for readability.
	* config/tc-d10v.c: Fix formatting.
	* config/tc-m32r.c: Likewise.
	* config/tc-sparc.c: Likewise.
@
text
@d27 1
d74 7
a80 2
/* True if instruction swapping warnings should be inhibited.  */
static unsigned char flag_warn_suppress_instructionswap; /* --nowarnswap  */
d91 1
a91 1
static void write_long PARAMS ((struct d10v_opcode *opcode, unsigned long insn, Fixups *fx));
d107 6
d199 1
a199 1
  long min, max, bit1;
d236 1
a236 1
      if ((num > max) || (num < min))
d247 5
a251 1
-O                      optimize.  Will do some operations in parallel.\n"));
d257 1
a257 1
     char *arg;
d268 6
d282 1
a282 1
     char *name;
d332 3
a334 3
     bfd *abfd;
     asection *sec;
     fragS *fragP;
a509 1
	      char *orig_line = input_line_pointer;
d672 1
a672 2
write_long (opcode, insn, fx)
     struct d10v_opcode *opcode;
d1099 1
a1099 1
	  if (prev_insn == -1)
d1107 1
a1107 1
  if (insn == -1)
d1130 1
a1130 1
      write_long (opcode, insn, fixups);
d1241 1
a1241 1
  int i, match, done;
d1481 1
a1481 1
     asection *seg;
d1509 2
a1510 2
     fragS *fragp;
     asection *seg;
d1532 1
a1532 1
     segT seg;
d1605 2
a1606 2
	      && ((repi != NULL && (insn & repi->mask) == repi->opcode)
		  || (rep != NULL && (insn & rep->mask) == rep->opcode))
d1635 3
a1637 2
/* Called after the assembler has finished parsing the input file or
   after a label is defined.  Because the D10V assembler sometimes
d1651 9
a1659 1
  if (prev_opcode && etype == PACK_UNSPEC)
d1663 1
d1666 1
d1668 1
d1679 2
a1680 2
d10v_dot_word (nbytes)
     register int nbytes;	/* 1=.byte, 2=.word, 4=.long  */
a1682 1
  bfd_reloc_code_real_type reloc;
a1683 1
  int offset;
@


1.12
log
@Kazu Hirata's formatting fixes.
@
text
@d103 2
a104 1
size_t md_longopts_size = sizeof(md_longopts);
d551 2
a552 1
    as_bad_where (fix->fx_file, fix->fx_line, _("operand out of range: %d"), value);
@


1.11
log
@New short-conditional-branch packing rules for D10V.
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation.
d24 1
a24 1
#include "subsegs.h"     
d43 1
a43 2

/* fixups */
d67 5
a71 5
#define PACK_UNSPEC 	(0)	/* packing order not specified */
#define PACK_PARALLEL	(1)	/* "||" */
#define PACK_LEFT_RIGHT (2)	/* "->" */
#define PACK_RIGHT_LEFT (3)	/* "<-" */
static packing_type etype = PACK_UNSPEC; /* used by d10v_cleanup */
d74 1
a74 1
static unsigned char flag_warn_suppress_instructionswap; /* --nowarnswap */
d76 1
a76 1
/* local functions */
d87 1
a87 1
static int write_2_short PARAMS ((struct d10v_opcode *opcode1, unsigned long insn1, 
d92 1
a92 1
static int parallel_ok PARAMS ((struct d10v_opcode *opcode1, unsigned long insn1, 
d103 1
a103 1
size_t md_longopts_size = sizeof(md_longopts);       
d117 3
a119 3
/* reg_name_search does a binary search of the d10v_predefined_registers
   array to see if "name" is a valid regiter name.  Returns the register
   number from the array on success, or -1 on failure. */
d129 1
a129 1
  high = d10v_reg_name_cnt() - 1;
d139 2
a140 2
      else 
	  return d10v_predefined_registers[middle].value;
d146 2
a147 2
/* register_name() checks the string at input_line_pointer
   to see if it is a valid register name */
d155 3
a157 2
  
  while (*p && *p!='\n' && *p!='\r' && *p !=',' && *p!=' ' && *p!=')')
d164 1
a164 1
  /* look to see if it's in the register table */
d166 1
a166 1
  if (reg_number >= 0) 
d169 2
a170 2
      /* temporarily store a pointer to the string here */
      expressionP->X_op_symbol = (symbolS *)input_line_pointer;
d176 1
a176 1
    *(p-1) = c;
a179 1

d187 1
a187 1
  int retval=0;
d189 1
a189 1
  /* don't bother checking 16-bit values */
d195 3
a197 3
      /* all special shift operands are unsigned */
      /* and <= 16.  We allow 0 for now. */
      if (num>16)
d205 1
a205 1
      /* Signed 3-bit integers are restricted to the (-2, 3) range */
d213 2
a214 2
	  max = (1 << (bits - 1)) - 1; 
	  min = - (1 << (bits - 1));  
a228 1

d231 1
a231 1
  FILE *stream;
d233 1
a233 1
  fprintf(stream, _("D10V options:\n\
d235 1
a235 1
} 
d245 1
a245 1
      /* Optimize. Will attempt to parallelize operations */
d259 1
a259 1
  char *name;
d264 5
a268 4
/* Turn a string in input_line_pointer into a floating point constant of type
   type, and store the appropriate bytes in *litP.  The number of LITTLENUMS
   emitted is stored in *sizeP .  An error message is returned, or NULL on OK.
 */
d279 1
a279 1
  
d296 1
a296 1
  
d298 1
a298 1
  
d302 1
a302 1
	  litP += 2;
d309 3
a311 3
  bfd *abfd;
  asection *sec;
  fragS *fragP;
a324 1

d330 1
a330 1
  d10v_hash = hash_new();
d337 1
a337 1
  for (opcode = (struct d10v_opcode *)d10v_opcodes; opcode->name; opcode++)
d341 1
a341 1
	  prev_name = (char *)opcode->name;
d351 2
d354 2
a355 4
/* this function removes the postincrement or postdecrement
   operator ( '+' or '-' ) from an expression */

static int postfix (p) 
d358 1
a358 1
  while (*p != '-' && *p != '+') 
d360 1
a360 1
      if (*p==0 || *p=='\n' || *p=='\r') 
d365 1
a365 1
  if (*p == '-') 
d370 1
a370 1
  if (*p == '+') 
d379 2
a380 3

static bfd_reloc_code_real_type 
get_reloc (op) 
d385 1
a385 1
  if (bits <= 4) 
d387 2
a388 2
      
  if (op->flags & OPERAND_ADDR) 
d399 1
a399 3

/* get_operands parses a string of operands and returns
   an array of expressions */
d402 1
a402 1
get_operands (exp) 
d409 2
a410 2
  
  while (*p)  
d412 1
a412 1
      while (*p == ' ' || *p == '\t' || *p == ',') 
d414 1
a414 1
      if (*p==0 || *p=='\n' || *p=='\r') 
d416 2
a417 2
      
      if (*p == '@@') 
d420 1
a420 1
	  
d423 1
a423 1
	  if (*p == '(') 
d428 1
a428 1
	  else if (*p == '-') 
d442 1
a442 1
      if (*p == ')') 
d444 1
a444 1
	  /* just skip the trailing paren */
d451 1
a451 1
      /* check to see if it might be a register name */
d454 1
a454 1
	  /* parse as an expression */
d462 1
a462 1
	      
d464 1
a464 1
	      
d476 1
a476 1
	      /* if it looked like a register name but was followed by
d478 1
a478 1
                 one */
d480 2
a481 1
	      exp[numops].X_add_symbol = symbol_find_or_make ((char *)exp[numops].X_op_symbol);
d484 1
a484 1
	  /* check for identifier@@word+constant */
d486 6
a491 6
	  {
	    char *orig_line = input_line_pointer;
	    expressionS new_exp;
	    expression (&new_exp);
	    exp[numops].X_add_number = new_exp.X_add_number;
	  }
d493 1
a493 1
	  /* convert expr into a right shift by AT_WORD_RIGHT_SHIFT */
d506 2
a507 2
      
      if (exp[numops].X_op == O_illegal) 
d509 1
a509 1
      else if (exp[numops].X_op == O_absent) 
d516 1
a516 1
  switch (post) 
d518 1
a518 1
    case -1:	/* postdecrement mode */
d522 1
a522 1
    case 1:	/* postincrement mode */
d533 1
a533 1
d10v_insert_operand (insn, op_type, value, left, fix) 
d548 1
a548 1
  /* truncate to the proper number of bits */
d558 2
a559 3

/* build_insn takes a pointer to the opcode entry in the opcode table
   and the array of operand expressions and returns the instruction */
d562 1
a562 1
build_insn (opcode, opers, insn) 
d569 2
a570 2
  
  /* the insn argument is only used for the DIVS kludge */
d578 2
a579 2
  
  for (i=0;opcode->operands[i];i++) 
d586 1
a586 1
      if (flags & OPERAND_REG) 
d593 1
a593 1
      if (opers[i].X_op != O_register && opers[i].X_op != O_constant) 
d595 1
a595 1
	  /* now create a fixup */
d602 1
a602 1
	      /* Reconize XXX>>1+N aka XXX@@word+N as special (AT_WORD) */
d605 1
a605 1
	      opers[i].X_op_symbol = NULL; /* Should free it */
d609 1
a609 1
                 X_add_number). */
d614 2
a615 2
	    fixups->fix[fixups->fc].reloc = 
	      get_reloc((struct d10v_operand *)&d10v_operands[opcode->operands[i]]);
d617 1
a617 1
	  if (fixups->fix[fixups->fc].reloc == BFD_RELOC_16 || 
d619 1
a619 1
	    fixups->fix[fixups->fc].size = 2; 	    
d622 1
a622 1
 	    
d625 2
a626 1
	  fixups->fix[fixups->fc].pcrel = (flags & OPERAND_ADDR) ? true : false;
d630 1
a630 1
      /* truncate to the proper number of bits */
d632 1
a632 1
	as_bad (_("operand out of range: %d"),number);
d637 4
a640 4
  /* kludge: for DIVS, we need to put the operands in twice */
  /* on the second pass, format is changed to LONG_R to force */
  /* the second set of operands to not be shifted over 15 */
  if ((opcode->opcode == OPCODE_DIVS) && (format==LONG_L))
d642 1
a642 1
      
d646 2
a647 1
/* write out a long form instruction */
d649 1
a649 1
write_long (opcode, insn, fx) 
d655 1
a655 1
  char *f = frag_more(4);
d660 1
a660 1
  for (i=0; i < fx->fc; i++) 
d663 2
a664 2
	{ 
	  where = f - frag_now->fr_literal; 
d669 1
a669 1
	    fx->fix[i].operand |= 4096;	  
d682 1
a683 1
/* write out a short form instruction by itself */
d685 1
a685 1
write_1_short (opcode, insn, fx) 
d690 1
a690 1
  char *f = frag_more(4);
d696 3
a698 3
  /* the other container needs to be NOP */
  /* according to 4.3.1: for FM=00, sub-instructions performed only
     by IU cannot be encoded in L-container. */
d700 1
a700 1
    insn |= FM00 | (NOP << 15);		/* right container */
d702 1
a702 1
    insn = FM00 | (insn << 15) | NOP;	/* left container */
d705 1
a705 1
  for (i=0; i < fx->fc; i++) 
d708 2
a709 2
	{ 
	  where = f - frag_now->fr_literal; 
d714 1
a714 1
	    fx->fix[i].operand |= 4096;	  
d716 3
a718 2
	  /* if it's an R reloc, we may have to switch it to L */
	  if ( (fx->fix[i].reloc == BFD_RELOC_D10V_10_PCREL_R) && (opcode->unit != IU) )
d722 1
a722 1
		       where, 
d735 1
a735 1
   Returns number of instructions not written out. */
d738 1
a738 1
write_2_short (opcode1, insn1, opcode2, insn2, exec_type, fx) 
d746 1
a746 1
  int i,j, where;
d748 2
a749 2
  if ( (exec_type != PACK_PARALLEL) && ((opcode1->exec_type & PARONLY)
	                || (opcode2->exec_type & PARONLY)))
d751 2
a752 2
  
  if ( (opcode1->format & LONG_OPCODE) || (opcode2->format & LONG_OPCODE))
d755 1
a755 2

  switch (exec_type) 
d757 1
a757 1
    case PACK_UNSPEC:	/* order not specified */
d760 2
a761 1
	  /* Case of a short branch on a separate GAS line.  Pack with NOP. */
d765 2
a766 1
      if (Optimizing && parallel_ok (opcode1, insn1, opcode2, insn2, exec_type))
d768 1
a768 1
	  /* parallel */
d775 2
a776 2
	      insn = FM00 | (insn1 << 15) | insn2;  
	      /* Advance over dummy fixup since packed insn1 in L */
d780 2
a781 2
      else if (opcode1->unit == IU) 
	/* reverse sequential with IU opcode1 on right and done first */
d785 1
a785 1
	  /* sequential with non-IU opcode1 on left and done first */
d787 1
a787 1
	 /* Advance over dummy fixup since packed insn1 in L */
a791 1

d794 2
a795 2
	as_fatal 
	    (_("One of these instructions may not be executed in parallel."));
d800 1
a800 1
          if (!flag_warn_suppress_instructionswap)
d802 1
a802 1
 	  insn = FM00 | (insn2 << 15) | insn1;
d808 1
a808 1
          if (!flag_warn_suppress_instructionswap)
d814 2
a815 2
	  insn = FM00 | (insn1 << 15) | insn2;  
	  /* Advance over dummy fixup since packed insn1 in L */
a819 1

d822 1
a822 1
	insn = FM01 | (insn1 << 15) | insn2;  
d825 1
a825 1
          if (!flag_warn_suppress_instructionswap)
d833 1
a833 1
      /* Advance over dummy fixup */
a836 1

d842 1
a842 1
          if (!flag_warn_suppress_instructionswap)
d844 1
a844 1
	  insn = FM01 | (insn2 << 15) | insn1;  
d850 1
a850 1
      /* Advance over dummy fixup */
a853 1

d858 1
a858 2

  f = frag_more(4);
d861 1
a861 1
  /* Process fixup chains.  
d867 1
a867 1
	can pass Plum Hall fine, yet still affect hand-written assembler. */
d869 1
a869 1
  for (j=0; j<2; j++) 
d871 1
a871 1
      for (i=0; i < fx->fc; i++) 
d875 1
a875 1
	      where = f - frag_now->fr_literal; 
d878 2
a879 2
	      
	      if ( (fx->fix[i].reloc == BFD_RELOC_D10V_10_PCREL_R) && (j == 0) )
d881 1
a881 1
	      
d883 1
a883 1
		fx->fix[i].operand |= 4096;	  
d886 1
a886 1
			   where, 
d899 2
a901 2
/* Check 2 instructions and determine if they can be safely */
/* executed in parallel.  Returns 1 if they can be.         */
d920 1
a920 1
     don't parallel. */
d938 1
a938 1
     they cannot operate safely in parallel. */
d940 6
a945 6
  /* the bitmasks (mod and used) look like this (bit 31 = MSB) */
  /* r0-r15	  0-15  */
  /* a0-a1	  16-17 */
  /* cr (not psw) 18    */
  /* psw	  19    */
  /* mem	  20    */
d947 1
a947 1
  for (j=0;j<2;j++)
d971 1
a971 1
	      if (flags & (OPERAND_ACC0|OPERAND_ACC1))
d973 2
a974 2
	      else if (flags & OPERAND_CONTROL)	/* mvtc or mvfc */
		{ 
d978 1
a978 1
		    regno = 18; 
d980 1
a980 1
	      else if (flags & (OPERAND_FFLAG|OPERAND_CFLAG))
d982 2
a983 2
	      
	      if ( flags & OPERAND_DEST )
d991 1
a991 1
		  used[j] |= 1 << regno ;
d996 2
a997 2
		  if (op->operands[i+1] != 0
		      && (d10v_operands[op->operands[i+1]].flags
d1004 1
a1004 1
	      /* SP implicitly used/modified */
d1025 5
a1029 6

/* This is the main entry point for the machine-dependent assembler.  str points to a
   machine-dependent instruction.  This function is supposed to emit the frags/bytes 
   it assembles to.  For the D10V, it mostly handles the special VLIW parsing and packing
   and leaves the difficult stuff to do_assemble().
 */
d1040 1
a1040 1
  /* etype is saved extype. for multiline instructions */
d1042 1
a1042 1
  packing_type extype = PACK_UNSPEC;		/* parallel, etc */
d1044 1
a1044 1
  struct d10v_opcode * opcode;
d1046 1
a1046 1
  char * str2;
d1050 1
a1050 1
      /* look for the special multiple instruction separators */
d1052 1
a1052 1
      if (str2) 
d1057 1
a1057 1
	  if (str2) 
d1062 1
a1062 1
	      if (str2) 
d1066 2
a1067 2
      /* str2 points to the separator, if one */
      if (str2) 
d1070 3
a1072 3
	  
	  /* if two instructions are present and we already have one saved
	     then first write out the save one */
d1074 2
a1075 2
	  
	  /* assemble first instruction and save it */
d1101 3
a1103 2
  /* if this is a long instruction, write it and any previous short instruction */
  if (opcode->format & LONG_OPCODE) 
d1105 1
a1105 1
      if (extype != PACK_UNSPEC) 
d1112 4
a1115 2
  
  if (prev_opcode && prev_seg && ((prev_seg != now_seg) || (prev_subseg != now_subseg)))
d1117 3
a1119 2
  
  if (prev_opcode && (write_2_short (prev_opcode, prev_insn, opcode, insn, extype, fixups) == 0)) 
d1121 1
a1121 1
      /* no instructions saved */
d1126 1
a1126 1
      if (extype != PACK_UNSPEC) 
d1128 1
a1128 1
      /* save off last instruction so it may be packed on next pass */
d1137 2
a1138 3

/* do_assemble assembles a single instruction and returns an opcode */
/* it returns -1 (an invalid opcode) on error */
d1141 1
a1141 1
do_assemble (str, opcode) 
d1170 1
a1170 1
  
d1172 1
a1172 1
  *opcode = (struct d10v_opcode *)hash_find (d10v_hash, name);
d1174 1
a1174 1
      as_fatal (_("unknown opcode: %s"),name);
d1183 1
a1183 1
  insn = build_insn ((*opcode), myops, 0); 
d1187 2
a1188 1
/* Find the symbol which has the same name as the register in the given expression.  */
d1191 1
a1191 1
     expressionS * exp;
d1194 1
a1194 1
  
d1197 1
a1197 1
  
d1200 1
a1200 1
    if (d10v_predefined_registers [i].value == exp->X_add_number)
d1207 1
a1207 1
  return symbol_find (d10v_predefined_registers [i].name);
d1210 3
a1212 4

/* find_opcode() gets a pointer to an entry in the opcode table.       */
/* It must look at all opcodes with the same name and use the operands */
/* to choose the correct opcode. */
d1222 1
a1222 1
  /* get all the operands and save them as expressions */
d1225 2
a1226 2
  /* now see if the operand is a fake.  If so, find the correct size */
  /* instruction, if possible */
d1231 1
a1231 1
			 
d1235 2
a1236 1
	  myops[opnum].X_add_symbol = symbol_find_or_make ((char *)myops[opnum].X_op_symbol);
d1241 1
a1241 1
      next_opcode=opcode+1;
d1261 4
a1264 3
      if (myops[opnum].X_op == O_constant || (myops[opnum].X_op == O_symbol &&
	  S_IS_DEFINED(myops[opnum].X_add_symbol) &&
	  (S_GET_SEGMENT(myops[opnum].X_add_symbol) == now_seg)))
d1266 1
a1266 1
	  for (i=0; opcode->operands[i+1]; i++)
d1272 1
a1272 1
	      
d1280 2
a1281 2
		  fragS * sym_frag;
		  fragS * f;
d1286 1
a1286 1
		  
d1294 3
a1296 1
		  current_position = obstack_next_free (&frchain_now->frch_obstack) - frag_now->fr_literal;
d1298 1
a1298 1
		  
d1302 1
a1302 1
		      
d1305 1
a1305 1
		      
d1311 1
a1311 1
		  
d1314 1
a1314 1
		  
d1333 2
a1334 2
	  /* not a constant, so use a long instruction */    
	  return opcode+2;
d1340 2
a1341 2
      /* now search the opcode table table for one with operands */
      /* that matches what we've got */
d1345 1
a1345 1
	  for (i = 0; opcode->operands[i]; i++) 
d1356 1
a1356 1
	      
d1369 1
a1369 1
	      
d1379 12
a1390 9
	      
	      /* Unfortunatly, for the indirect operand in instructions such as
		 ``ldb r1, @@(c,r14)'' this function can be passed X_op == O_register
		 (because 'c' is a valid register name).  However we cannot just
		 ignore the case when X_op == O_register but flags & OPERAND_REG is
		 null, so we check to see if a symbol of the same name as the register
		 exists.  If the symbol does exist, then the parser was unable to
		 distinguish the two cases and we fix things here.  (Ref: PR14826) */
	      
d1393 2
a1394 4
		  symbolS * sym;
		  
		  sym = find_symbol_matching_register (& myops[i]);
		  
d1397 2
a1398 2
		      myops [i].X_op == X_op == O_symbol;
		      myops [i].X_add_symbol = sym;
d1405 1
a1405 1
	  
d1408 1
a1408 1
	  if (match && myops[i].X_op == 0) 
d1414 2
a1415 2
	  
	  if (next_opcode->opcode == 0) 
d1417 1
a1417 1
	  
d1420 1
a1420 1
	  
d1425 1
a1425 1
  if (!match)  
d1431 4
a1434 4
  /* Check that all registers that are required to be even are. */
  /* Also, if any operands were marked as registers, but were really symbols */
  /* fix that here. */
  for (i=0; opcode->operands[i]; i++) 
d1437 1
a1437 1
	  (myops[i].X_add_number & 1)) 
d1441 1
a1441 1
	  if (!(d10v_operands[opcode->operands[i]].flags & OPERAND_REG)) 
d1444 2
a1445 1
	      myops[i].X_add_symbol = symbol_find_or_make ((char *)myops[i].X_op_symbol);
d1454 3
a1456 3
/* if while processing a fixup, a reloc really needs to be created */
/* then it is done here */
                 
d1471 2
a1472 1
                    _("reloc %d not supported by object file format"), (int)fixp->fx_r_type);
d1492 1
a1492 1
} 
d1499 3
a1501 2
  if (fixp->fx_addsy != (symbolS *)NULL && (!S_IS_DEFINED (fixp->fx_addsy) ||
      (S_GET_SEGMENT (fixp->fx_addsy) != sec)))
d1516 1
a1516 1
  int left=0;
d1535 1
a1535 1
 	      as_bad_where (fixp->fx_file, fixp->fx_line,
d1557 2
a1558 1
	fixp->fx_r_type = get_reloc((struct d10v_operand *)&d10v_operands[op_type]); 
d1572 1
a1572 1
      /* instruction addresses are always right-shifted by 2 */
d1589 3
a1591 2
	  insn = d10v_insert_operand (insn, op_type, (offsetT)value, left, fixp);
	  bfd_putb32 ((bfd_vma) insn, (unsigned char *) where);  
d1607 2
a1608 1
      as_fatal (_("line %d: unknown relocation type: 0x%x"),fixp->fx_line,fixp->fx_r_type);
d1613 6
a1618 4
/* d10v_cleanup() is called after the assembler has finished parsing the input 
   file or after a label is defined.  Because the D10V assembler sometimes saves short 
   instructions to see if it can package them with the next instruction, there may
   be a short instruction that still needs written.
d1621 1
d1641 3
a1643 2
/* Like normal .word, except support @@word */
/* clobbers input_line_pointer, checks end-of-line. */
d1646 1
a1646 1
     register int nbytes;	/* 1=.byte, 2=.word, 4=.long */
d1666 1
a1666 1
	
d1668 1
a1668 1
	  fix_new_exp (frag_now, p - frag_now->fr_literal, 2, 
d1676 1
a1676 1
  input_line_pointer--;		/* Put terminator back into stream. */
d1680 6
d1687 2
a1688 6
/* Mitsubishi asked that we support some old syntax that apparently */
/* had immediate operands starting with '#'.  This is in some of their */
/* sample code but is not documented (although it appears in some  */
/* examples in their assembler manual). For now, we'll solve this */
/* compatibility problem by simply ignoring any '#' at the beginning */
/* of an operand. */
d1690 1
a1690 4
/* operands that begin with '#' should fall through to here */
/* from expr.c */

void 
d1703 1
a1703 1
   fixS *fixP;
a1704 1

d1707 2
a1708 2
  
  /* Prevent all adjustments to global symbols. */
d1714 1
a1714 1
  /* We need the symbol name for the VTABLE entries */
d1724 1
a1724 1
      fixS *fixp;
@


1.10
log
@Apply patch to fix compuation of frag offsets for symbols
@
text
@d67 7
d89 1
a89 1
				  struct d10v_opcode *opcode2, unsigned long insn2, int exec_type, Fixups *fx));
d95 1
a95 1
				int exec_type));
d734 5
a738 2
/* write out a short form instruction if possible */
/* return number of instructions not written out */
d743 1
a743 1
     int exec_type;
d750 1
a750 1
  if ( (exec_type != 1) && ((opcode1->exec_type & PARONLY)
a756 7
  if(opcode1->exec_type & BRANCH_LINK && exec_type == 0)
    {
      /* Instructions paired with a subroutine call are executed before the
	 subroutine, so don't do these pairings unless explicitly requested.  */
      write_1_short (opcode1, insn1, fx->next);
      return (1);
    }
d760 8
a767 2
    case 0:	/* order not specified */
      if ( Optimizing && parallel_ok (opcode1, insn1, opcode2, insn2, exec_type))
d777 1
d782 2
a783 4
	{
	  /* reverse sequential */
	  insn = FM10 | (insn2 << 15) | insn1;
	}
d786 1
a786 1
	  /* sequential */
d788 2
a789 1
	  fx = fx->next;  
d792 3
a794 1
    case 1:	/* parallel */
d796 2
a797 2
	as_fatal (_("One of these instructions may not be executed in parallel."));

d817 1
d821 3
a823 1
    case 2:	/* sequential */
d830 1
a830 1
	  insn = FM10 | (insn2 << 15) | insn1;  
d834 3
d839 3
a841 1
    case 3:	/* reverse sequential */
d852 3
d857 2
d863 1
d867 8
d912 1
a912 1
     int exec_type;
d925 4
a928 3
  /* If the first instruction is a branch and this is auto parallazation,
     don't combine with any second instruction.  */
  if (exec_type == 0 && (op1->exec_type & BRANCH) != 0)
a1041 1
static int etype = 0;		/* saved extype.  used for multiline instructions */
d1047 4
a1052 1
  int extype = 0;		/* execution type; parallel, etc */
d1055 1
a1055 1
  if (etype == 0)
d1060 1
a1060 1
	extype = 1;
d1065 1
a1065 1
	    extype = 2;
d1070 1
a1070 1
		extype = 3;
d1079 1
a1079 1
	     then first write it out */
d1094 1
a1094 1
      if (extype)
d1102 1
a1102 1
  if (etype)
d1105 1
a1105 1
      etype = 0;
d1111 1
a1111 1
      if (extype) 
d1120 1
a1120 1
    d10v_cleanup();
d1129 1
a1129 1
      if (extype) 
d1609 3
a1611 1
   be a short instruction that still needs written.  */
d1618 1
a1618 1
  if (prev_opcode && etype == 0)
@


1.9
log
@Apply Andrew Cagney's patch to fix use of 'struct fix'.
@
text
@d1238 1
d1246 27
a1272 6
		  fragS *f;
		  long value;
		  /* calculate the current address by running through the previous frags */
		  /* and adding our current offset */
		  for (value = 0, f = frchain_now->frch_root; f; f = f->fr_next)
		    value += f->fr_fix + f->fr_offset;
d1274 2
d1277 2
a1278 5
		    value = S_GET_VALUE(myops[opnum].X_add_symbol) - value -
		      (obstack_next_free(&frchain_now->frch_obstack) - frag_now->fr_literal);
		  else
		    value += S_GET_VALUE(myops[opnum].X_add_symbol);

d1677 1
a1677 1
      struct fix *fixp;
@


1.8
log
@Add a symbol's value to	the computed frag offset, rather than overwriting it.
@
text
@d1521 2
a1522 2
	      && (repi != NULL && (insn & repi->mask) == repi->opcode
		  || rep != NULL && (insn & rep->mask) == rep->opcode)
@


1.7
log
@	* tc_d10v.c (find_opcode): Allow ATSIGN to match expressions of the
	form @@abs16, @@(abs16) and @@(abs16 + imm).
@
text
@d1256 1
a1256 1
		    value = S_GET_VALUE(myops[opnum].X_add_symbol);
@


1.6
log
@
Added seven new instructions ld, ld2w, sac, sachi, slae, st and
st2w for d10v. Created new testsuite for d10v to verify new
instructions.
@
text
@d1317 1
a1317 1
		  ((flags & OPERAND_ATSIGN)  && ((X_op != O_absent) || (num != OPERAND_ATSIGN))))
@


1.5
log
@	* config/tc-arc.c (get_arc_exp_reloc_type): Change uses of
	sy_value with appropriate accessor functions.
	* config/tc-arm.c (md_apply_fix3): Likewise.
	* config/tc-d10v.c (AT_WORD_P): Likewise.
	* config/tc-v850.c (reg_name_search): Likewise.
@
text
@d199 13
a211 4
      max = (1 << (bits - 1))-1; 
      min = - (1 << (bits - 1));  
      if (((long)num > max) || ((long)num < min))
	retval = 1;
@


1.4
log
@1999-06-22  Jonathan Larmour  <jlarmour@@cygnus.co.uk>
	* config/tc-arc.c (tc_gen_reloc): Use symbol_get_bfdsym to get at
	the symbol, rather than accessing the bsym member.
	* config/tc-d10v.c (tc_gen_reloc): Likewise.
	* config/tc-d30v.c (tc_gen_reloc): Likewise.
	* config/tc-mcore.c (tc_gen_reloc): Likewise.
	* config/tc-mn10200.c (tc_gen_reloc): Likewise.
	* config/tc-mn10300.c (tc_gen_reloc): Likewise.
	* config/tc-ns32k.c (tc_gen_reloc): Likewise.
	* config/tc-tic30.c (tc_gen_reloc): Likewise.
	* config/tc-v850.c (tc_gen_reloc): Likewise.
@
text
@d39 2
a40 2
		      && (X)->X_op_symbol->sy_value.X_op == O_constant \
		      && (X)->X_op_symbol->sy_value.X_add_number == AT_WORD_RIGHT_SHIFT)
@


1.3
log
@Detect illegal use of hash symbols in assembler mnemonics.
@
text
@a1 1

d1396 2
a1397 1
  reloc->sym_ptr_ptr = &fixp->fx_addsy->bsym;
@


1.2
log
@	Add support for storing local symbols in a small structure to save
	memory when assembling large files.
	* as.h: Don't include struc-symbol.h.
	(symbolS): Add typedef.
	* symbols.c: Include struc-symbol.h.
	(local_hash): New static variable.
	(save_symbol_name): New static function, from symbol_create.
	(symbol_create): Call save_symbol_name.
	(local_symbol_count): New static variable.
	(local_symbol_conversion_count): Likewise.
	(LOCAL_SYMBOL_CHECK): Define.
	(local_symbol_make): New static function.
	(local_symbol_convert): New static function.
	(colon): Handle local symbols.  Create local symbol for local
	label name.
	(symbol_table_insert): Handle local symbols.
	(symbol_find_or_make): Create local symbol for local label name.
	(symbol_find_base): Check for local symbol.
	(symbol_append, symbol_insert): Check for local symbols.
	(symbol_clear_list_pointers, symbol_remove): Likewise.
	(verify_symbol_chain): Likewise.
	(copy_symbol_attributes): Likewise.
	(resolve_symbol_value): Handle local symbols.
	(resolve_local_symbol): New static function.
	(resolve_local_symbol_values): New function.
	(S_GET_VALUE, S_SET_VALUE): Handle local symbols.
	(S_IS_FUNCTION, S_IS_EXTERNAL, S_IS_WEAK, S_IS_COMMON): Likewise.
	(S_IS_DEFINED, S_IS_DEBUG, S_IS_LOCAL, S_GET_NAME): Likewise.
	(S_GET_SEGMENT, S_SET_SEGMENT, S_SET_EXTERNAL): Likewise.
	(S_CLEAR_EXTERNAL, S_SET_WEAK, S_SET_NAME): Likewise.
	(symbol_previous, symbol_next): New functions.
	(symbol_get_value_expression): Likewise.
	(symbol_set_value_expression): Likewise.
	(symbol_set_frag, symbol_get_frag): Likewise.
	(symbol_mark_used, symbol_clear_used, symbol_used_p): Likewise.
	(symbol_mark_used_in_reloc): Likewise.
	(symbol_clear_used_in_reloc, symbol_used_in_reloc_p): Likewise.
	(symbol_mark_mri_common, symbol_clear_mri_common): Likewise.
	(symbol_mri_common_p): Likewise.
	(symbol_mark_written, symbol_clear_written): Likewise.
	(symbol_written_p): Likewise.
	(symbol_mark_resolved, symbol_resolved_p): Likewise.
	(symbol_section_p, symbol_equated_p): Likewise.
	(symbol_constant_p): Likewise.
	(symbol_get_bfdsym, symbol_set_bfdsym): Likewise.
	(symbol_get_obj, symbol_set_obj): Likewise.
	(symbol_get_tc, symbol_set_tc): Likewise.
	(symbol_begin): Initialize local_hash.
	(print_symbol_value_1): Handle local symbols.
	(symbol_print_statistics): Print local symbol statistics.
	* symbols.h: Include "struc-symbol.h" if not BFD_ASSEMBLER.
	Declare new symbols.c functions.  Move many declarations here from
	struc-symbol.h.
	(SYMBOLS_NEED_BACKPOINTERS): Define if needed.
	* struc-symbol.h (SYMBOLS_NEED_BACKPOINTERS): Don't set.
	(struct symbol): Move bsym to make it clearly the first field.
	Remove TARGET_SYMBOL_FIELDS.
	(symbolS): Don't typedef.
	(struct broken_word): Remove.
	(N_TYPE_seg, seg_N_TYPE): Move to symbol.h.
	(SEGMENT_TO_SYMBOL_TYPE, N_REGISTER): Likewise.
	(symbol_clear_list_pointers): Likewise.
	(symbol_insert, symbol_remove): Likewise.
	(symbol_previous, symbol_append): Likewise.
	(verify_symbol_chain, verify_symbol_chain_2): Likewise.
	(struct local_symbol): Define.
	(local_symbol_converted_p, local_symbol_mark_converted): Define.
	(local_symbol_resolved_p, local_symbol_mark_resolved): Define.
	(local_symbol_get_frag, local_symbol_set_frag): Define.
	(local_symbol_get_real_symbol): Define.
	(local_symbol_set_real_symbol): Define.
	Define.
	* write.c (write_object_file): Call resolve_local_symbol_values.
	* config/obj-ecoff.h (OBJ_SYMFIELD_TYPE): Define.
	(TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-elf.h (OBJ_SYMFIELD_TYPE): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-multi.h (struct elf_obj_sy): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	(ECOFF_DEBUG_TARGET_SYMBOL_FIELDS): Don't define.
	* config/tc-mcore.h: Don't include struc-symbol.h.
	(TARGET_SYMBOL_FIELDS): Don't define.
	(struct mcore_tc_sy): Define.
	(TC_SYMFIELD_TYPE): Define.
	* Many files: Use symbolS instead of struct symbol.  Use new
	accessor functions rather than referring to symbolS fields
	directly.
	* read.c (s_mri_common): Don't add in value of line_label.
	* config/tc-mips.c (md_apply_fix): Correct parenthesization when
	checking for SEC_LINK_ONCE.
	* config/tc-sh.h (sh_fix_adjustable): Declare.
@
text
@d66 2
d398 2
a399 1

d409 2
d445 14
a458 1
	  expression (&exp[numops]);
d1616 1
a1616 1
  if (*input_line_pointer == '#')
@


1.1
log
@Initial revision
@
text
@d3 1
a3 1
   Copyright (C) 1996, 1997, 1998 Free Software Foundation.
d162 1
a162 1
      expressionP->X_op_symbol = (struct symbol *)input_line_pointer;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

