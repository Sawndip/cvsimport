head	1.34;
access;
symbols
	binutils-2_24-branch:1.34.0.4
	binutils-2_24-branchpoint:1.34
	binutils-2_21_1:1.33
	binutils-2_23_2:1.34
	binutils-2_23_1:1.34
	binutils-2_23:1.34
	binutils-2_23-branch:1.34.0.2
	binutils-2_23-branchpoint:1.34
	binutils-2_22_branch:1.33.0.6
	binutils-2_22:1.33
	binutils-2_22-branch:1.33.0.4
	binutils-2_22-branchpoint:1.33
	binutils-2_21:1.33
	binutils-2_21-branch:1.33.0.2
	binutils-2_21-branchpoint:1.33
	binutils-2_20_1:1.32
	binutils-2_20:1.32
	binutils-arc-20081103-branch:1.30.0.4
	binutils-arc-20081103-branchpoint:1.30
	binutils-2_20-branch:1.32.0.2
	binutils-2_20-branchpoint:1.32
	dje-cgen-play1-branch:1.31.0.2
	dje-cgen-play1-branchpoint:1.31
	arc-20081103-branch:1.30.0.2
	arc-20081103-branchpoint:1.30
	binutils-2_19_1:1.29
	binutils-2_19:1.29
	binutils-2_19-branch:1.29.0.2
	binutils-2_19-branchpoint:1.29
	binutils-2_18:1.28
	binutils-2_18-branch:1.28.0.2
	binutils-2_18-branchpoint:1.28
	binutils-csl-coldfire-4_1-32:1.25
	binutils-csl-sourcerygxx-4_1-32:1.25
	binutils-csl-innovasic-fido-3_4_4-33:1.25
	binutils-csl-sourcerygxx-3_4_4-32:1.21
	binutils-csl-coldfire-4_1-30:1.25
	binutils-csl-sourcerygxx-4_1-30:1.25
	binutils-csl-coldfire-4_1-28:1.25
	binutils-csl-sourcerygxx-4_1-29:1.25
	binutils-csl-sourcerygxx-4_1-28:1.25
	binutils-csl-arm-2006q3-27:1.25
	binutils-csl-sourcerygxx-4_1-27:1.25
	binutils-csl-arm-2006q3-26:1.25
	binutils-csl-sourcerygxx-4_1-26:1.25
	binutils-csl-sourcerygxx-4_1-25:1.25
	binutils-csl-sourcerygxx-4_1-24:1.25
	binutils-csl-sourcerygxx-4_1-23:1.25
	binutils-csl-sourcerygxx-4_1-21:1.25
	binutils-csl-arm-2006q3-21:1.25
	binutils-csl-sourcerygxx-4_1-22:1.25
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.25
	binutils-csl-sourcerygxx-4_1-20:1.25
	binutils-csl-arm-2006q3-19:1.25
	binutils-csl-sourcerygxx-4_1-19:1.25
	binutils-csl-sourcerygxx-4_1-18:1.25
	binutils-csl-renesas-4_1-9:1.25
	binutils-csl-sourcerygxx-3_4_4-25:1.21
	binutils-csl-renesas-4_1-8:1.25
	binutils-csl-renesas-4_1-7:1.25
	binutils-csl-renesas-4_1-6:1.25
	binutils-csl-sourcerygxx-4_1-17:1.25
	binutils-csl-sourcerygxx-4_1-14:1.25
	binutils-csl-sourcerygxx-4_1-15:1.25
	binutils-csl-sourcerygxx-4_1-13:1.25
	binutils-2_17:1.25
	binutils-csl-sourcerygxx-4_1-12:1.25
	binutils-csl-sourcerygxx-3_4_4-21:1.25
	binutils-csl-wrs-linux-3_4_4-24:1.21
	binutils-csl-wrs-linux-3_4_4-23:1.21
	binutils-csl-sourcerygxx-4_1-9:1.25
	binutils-csl-sourcerygxx-4_1-8:1.25
	binutils-csl-sourcerygxx-4_1-7:1.25
	binutils-csl-arm-2006q1-6:1.25
	binutils-csl-sourcerygxx-4_1-6:1.25
	binutils-csl-wrs-linux-3_4_4-22:1.21
	binutils-csl-coldfire-4_1-11:1.25
	binutils-csl-sourcerygxx-3_4_4-19:1.25
	binutils-csl-coldfire-4_1-10:1.25
	binutils-csl-sourcerygxx-4_1-5:1.25
	binutils-csl-sourcerygxx-4_1-4:1.25
	binutils-csl-wrs-linux-3_4_4-21:1.21
	binutils-csl-morpho-4_1-4:1.25
	binutils-csl-sourcerygxx-3_4_4-17:1.25
	binutils-csl-wrs-linux-3_4_4-20:1.21
	binutils-2_17-branch:1.25.0.4
	binutils-2_17-branchpoint:1.25
	binutils-csl-2_17-branch:1.25.0.2
	binutils-csl-2_17-branchpoint:1.25
	binutils-csl-gxxpro-3_4-branch:1.21.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.21
	binutils-2_16_1:1.21
	binutils-csl-arm-2005q1b:1.21
	binutils-2_16:1.21
	binutils-csl-arm-2005q1a:1.21
	binutils-csl-arm-2005q1-branch:1.21.0.4
	binutils-csl-arm-2005q1-branchpoint:1.21
	binutils-2_16-branch:1.21.0.2
	binutils-2_16-branchpoint:1.21
	csl-arm-2004-q3d:1.19
	csl-arm-2004-q3:1.19
	binutils-2_15:1.19
	binutils-2_15-branchpoint:1.19
	csl-arm-2004-q1a:1.19
	csl-arm-2004-q1:1.19
	binutils-2_15-branch:1.19.0.6
	cagney_bfdfile-20040213-branch:1.19.0.4
	cagney_bfdfile-20040213-branchpoint:1.19
	cagney_bigcore-20040122-branch:1.19.0.2
	cagney_bigcore-20040122-branchpoint:1.19
	csl-arm-2003-q4:1.19
	binutils-2_14:1.17
	binutils-2_14-branch:1.17.0.2
	binutils-2_14-branchpoint:1.17
	binutils-2_13_2_1:1.15
	binutils-2_13_2:1.15
	binutils-2_13_1:1.15
	binutils-2_13:1.15
	binutils-2_13-branchpoint:1.15
	binutils-2_13-branch:1.15.0.2
	binutils-2_12_1:1.14
	binutils-2_12:1.14
	binutils-2_12-branch:1.14.0.2
	binutils-2_12-branchpoint:1.14
	cygnus_cvs_20020108_pre:1.14
	binutils-2_11_2:1.7.2.2
	binutils-2_11_1:1.7.2.2
	binutils-2_11:1.7
	x86_64versiong3:1.7
	binutils-2_11-branch:1.7.0.2
	binutils-2_10_1:1.3
	binutils-2_10:1.3
	binutils-2_10-branch:1.3.0.2
	binutils-2_10-branchpoint:1.3
	binutils_latest_snapshot:1.34
	repo-unification-2000-02-06:1.3
	binu_ss_19990721:1.3
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.34
date	2011.10.25.13.35.00;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	2009.12.11.13.42.11;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2009.09.02.07.24.20;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2009.06.22.17.56.02;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	2008.10.21.00.26.17;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2007.10.17.16.45.55;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2007.07.03.11.01.04;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	2006.08.29.01.31.56;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2006.06.07.11.27.58;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2005.08.11.01.25.28;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2005.06.07.17.54.17;	author zack;	state Exp;
branches;
next	1.23;

1.23
date	2005.05.05.09.13.02;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2005.03.24.20.40.27;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2005.03.03.11.47.54;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2005.01.31.23.18.33;	author bje;	state Exp;
branches;
next	1.19;

1.19
date	2003.11.22.02.35.30;	author kazu;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.23.00.41.47;	author thorpej;	state Exp;
branches;
next	1.17;

1.17
date	2002.12.16.09.54.39;	author amodra;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2002.07.31.16.23.29;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.08.07.37.15;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.15.21.28.58;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2001.09.19.05.33.28;	author hjl;	state Exp;
branches;
next	1.12;

1.12
date	2001.07.23.14.02.12;	author kazu;	state Exp;
branches;
next	1.11;

1.11
date	2001.07.23.13.03.40;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2001.05.10.11.32.52;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.30.00.06.10;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.08.23.24.24;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2000.09.21.20.26.34;	author kazu;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2000.07.28.00.42.18;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.07.16.58.24;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.09.00.00.03;	author amodra;	state Exp;
branches;
next	1.3;

1.3
date	99.06.22.14.52.58;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.06.22.14.07.38;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.43;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.17.2.1
date	2003.06.23.00.53.00;	author thorpej;	state Exp;
branches;
next	;

1.7.2.1
date	2001.06.07.03.15.32;	author amodra;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2001.06.11.10.04.50;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.43;	author rth;	state Exp;
branches;
next	;


desc
@@


1.34
log
@* config/tc-ns32k.c (md_begin): Rename local variable 'stat' to	'status'.
@
text
@/* ns32k.c  -- Assemble on the National Semiconductor 32k series
   Copyright 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001, 2002, 2003, 2005, 2006, 2007, 2008, 2009
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/*#define SHOW_NUM 1*//* Uncomment for debugging.  */

#include "as.h"
#include "opcode/ns32k.h"

#include "obstack.h"

/* Macros.  */
#define IIF_ENTRIES 13		/* Number of entries in iif.  */
#define PRIVATE_SIZE 256	/* Size of my garbage memory.  */
#define MAX_ARGS 4
#define DEFAULT	-1		/* addr_mode returns this value when
                                   plain constant or label is
                                   encountered.  */

#define IIF(ptr,a1,c1,e1,g1,i1,k1,m1,o1,q1,s1,u1)	\
    iif.iifP[ptr].type = a1;				\
    iif.iifP[ptr].size = c1;				\
    iif.iifP[ptr].object = e1;				\
    iif.iifP[ptr].object_adjust = g1;			\
    iif.iifP[ptr].pcrel = i1;				\
    iif.iifP[ptr].pcrel_adjust = k1;			\
    iif.iifP[ptr].im_disp = m1;				\
    iif.iifP[ptr].relax_substate = o1;			\
    iif.iifP[ptr].bit_fixP = q1;			\
    iif.iifP[ptr].addr_mode = s1;			\
    iif.iifP[ptr].bsr = u1;

#ifdef SEQUENT_COMPATABILITY
#define LINE_COMMENT_CHARS "|"
#define ABSOLUTE_PREFIX '@@'
#define IMMEDIATE_PREFIX '#'
#endif

#ifndef LINE_COMMENT_CHARS
#define LINE_COMMENT_CHARS "#"
#endif

const char comment_chars[] = "#";
const char line_comment_chars[] = LINE_COMMENT_CHARS;
const char line_separator_chars[] = ";";
static int default_disp_size = 4; /* Displacement size for external refs.  */

#if !defined(ABSOLUTE_PREFIX) && !defined(IMMEDIATE_PREFIX)
#define ABSOLUTE_PREFIX '@@'	/* One or the other MUST be defined.  */
#endif

struct addr_mode
{
  signed char mode;		/* Addressing mode of operand (0-31).  */
  signed char scaled_mode;	/* Mode combined with scaled mode.  */
  char scaled_reg;		/* Register used in scaled+1 (1-8).  */
  char float_flag;		/* Set if R0..R7 was F0..F7 ie a
				   floating-point-register.  */
  char am_size;			/* Estimated max size of general addr-mode
				   parts.  */
  char im_disp;			/* If im_disp==1 we have a displacement.  */
  char pcrel;			/* 1 if pcrel, this is really redundant info.  */
  char disp_suffix[2];		/* Length of displacement(s), 0=undefined.  */
  char *disp[2];		/* Pointer(s) at displacement(s)
				   or immediates(s)     (ascii).  */
  char index_byte;		/* Index byte.  */
};
typedef struct addr_mode addr_modeS;

char *freeptr, *freeptr_static;	/* Points at some number of free bytes.  */
struct hash_control *inst_hash_handle;

struct ns32k_opcode *desc;	/* Pointer at description of instruction.  */
addr_modeS addr_modeP;
const char EXP_CHARS[] = "eE";
const char FLT_CHARS[] = "fd";	/* We don't want to support lowercase,
                                   do we?  */

/* UPPERCASE denotes live names when an instruction is built, IIF is
   used as an intermediate form to store the actual parts of the
   instruction. A ns32k machine instruction can be divided into a
   couple of sub PARTs. When an instruction is assembled the
   appropriate PART get an assignment. When an IIF has been completed
   it is converted to a FRAGment as specified in AS.H.  */

/* Internal structs.  */
struct ns32k_option
{
  char *pattern;
  unsigned long or;
  unsigned long and;
};

typedef struct
{
  int type;			/* How to interpret object.  */
  int size;			/* Estimated max size of object.  */
  unsigned long object;		/* Binary data.  */
  int object_adjust;		/* Number added to object.  */
  int pcrel;			/* True if object is pcrel.  */
  int pcrel_adjust;		/* Length in bytes from the instruction
				   start to the	displacement.  */
  int im_disp;			/* True if the object is a displacement.  */
  relax_substateT relax_substate;/*Initial relaxsubstate.  */
  bit_fixS *bit_fixP;		/* Pointer at bit_fix struct.  */
  int addr_mode;		/* What addrmode do we associate with this
				   iif-entry.  */
  char bsr;			/* Sequent hack.  */
} iif_entryT;			/* Internal Instruction Format.  */

struct int_ins_form
{
  int instr_size;		/* Max size of instruction in bytes.  */
  iif_entryT iifP[IIF_ENTRIES + 1];
};

struct int_ins_form iif;
expressionS exprP;
char *input_line_pointer;

/* Description of the PARTs in IIF
  object[n]:
   0	total length in bytes of entries in iif
   1	opcode
   2	index_byte_a
   3	index_byte_b
   4	disp_a_1
   5	disp_a_2
   6	disp_b_1
   7	disp_b_2
   8	imm_a
   9	imm_b
   10	implied1
   11	implied2

   For every entry there is a datalength in bytes. This is stored in size[n].
  	 0,	the objectlength is not explicitly given by the instruction
  		and the operand is undefined. This is a case for relaxation.
  		Reserve 4 bytes for the final object.

  	 1,	the entry contains one byte
  	 2,	the entry contains two bytes
  	 3,	the entry contains three bytes
  	 4,	the entry contains four bytes
  	etc

   Furthermore, every entry has a data type identifier in type[n].

   	 0,	the entry is void, ignore it.
   	 1,	the entry is a binary number.
  	 2,	the entry is a pointer at an expression.
  		Where expression may be as simple as a single '1',
  		and as complicated as  foo-bar+12,
   		foo and bar may be undefined but suffixed by :{b|w|d} to
  		control the length of the object.

  	 3,	the entry is a pointer at a bignum struct

   The low-order-byte corresponds to low physical memory.
   Obviously a FRAGment must be created for each valid disp in PART whose
   datalength is undefined (to bad) .
   The case where just the expression is undefined is less severe and is
   handled by fix. Here the number of bytes in the objectfile is known.
   With this representation we simplify the assembly and separates the
   machine dependent/independent parts in a more clean way (said OE).  */

struct ns32k_option opt1[] =		/* restore, exit.  */
{
  {"r0", 0x80, 0xff},
  {"r1", 0x40, 0xff},
  {"r2", 0x20, 0xff},
  {"r3", 0x10, 0xff},
  {"r4", 0x08, 0xff},
  {"r5", 0x04, 0xff},
  {"r6", 0x02, 0xff},
  {"r7", 0x01, 0xff},
  {0, 0x00, 0xff}
};
struct ns32k_option opt2[] =		/* save, enter.  */
{
  {"r0", 0x01, 0xff},
  {"r1", 0x02, 0xff},
  {"r2", 0x04, 0xff},
  {"r3", 0x08, 0xff},
  {"r4", 0x10, 0xff},
  {"r5", 0x20, 0xff},
  {"r6", 0x40, 0xff},
  {"r7", 0x80, 0xff},
  {0, 0x00, 0xff}
};
struct ns32k_option opt3[] =		/* setcfg.  */
{
  {"c", 0x8, 0xff},
  {"m", 0x4, 0xff},
  {"f", 0x2, 0xff},
  {"i", 0x1, 0xff},
  {0, 0x0, 0xff}
};
struct ns32k_option opt4[] =		/* cinv.  */
{
  {"a", 0x4, 0xff},
  {"i", 0x2, 0xff},
  {"d", 0x1, 0xff},
  {0, 0x0, 0xff}
};
struct ns32k_option opt5[] =		/* String inst.  */
{
  {"b", 0x2, 0xff},
  {"u", 0xc, 0xff},
  {"w", 0x4, 0xff},
  {0, 0x0, 0xff}
};
struct ns32k_option opt6[] =		/* Plain reg ext,cvtp etc.  */
{
  {"r0", 0x00, 0xff},
  {"r1", 0x01, 0xff},
  {"r2", 0x02, 0xff},
  {"r3", 0x03, 0xff},
  {"r4", 0x04, 0xff},
  {"r5", 0x05, 0xff},
  {"r6", 0x06, 0xff},
  {"r7", 0x07, 0xff},
  {0, 0x00, 0xff}
};

#if !defined(NS32032) && !defined(NS32532)
#define NS32532
#endif

struct ns32k_option cpureg_532[] =	/* lpr spr.  */
{
  {"us", 0x0, 0xff},
  {"dcr", 0x1, 0xff},
  {"bpc", 0x2, 0xff},
  {"dsr", 0x3, 0xff},
  {"car", 0x4, 0xff},
  {"fp", 0x8, 0xff},
  {"sp", 0x9, 0xff},
  {"sb", 0xa, 0xff},
  {"usp", 0xb, 0xff},
  {"cfg", 0xc, 0xff},
  {"psr", 0xd, 0xff},
  {"intbase", 0xe, 0xff},
  {"mod", 0xf, 0xff},
  {0, 0x00, 0xff}
};
struct ns32k_option mmureg_532[] =	/* lmr smr.  */
{
  {"mcr", 0x9, 0xff},
  {"msr", 0xa, 0xff},
  {"tear", 0xb, 0xff},
  {"ptb0", 0xc, 0xff},
  {"ptb1", 0xd, 0xff},
  {"ivar0", 0xe, 0xff},
  {"ivar1", 0xf, 0xff},
  {0, 0x0, 0xff}
};

struct ns32k_option cpureg_032[] =	/* lpr spr.  */
{
  {"upsr", 0x0, 0xff},
  {"fp", 0x8, 0xff},
  {"sp", 0x9, 0xff},
  {"sb", 0xa, 0xff},
  {"psr", 0xd, 0xff},
  {"intbase", 0xe, 0xff},
  {"mod", 0xf, 0xff},
  {0, 0x0, 0xff}
};
struct ns32k_option mmureg_032[] =	/* lmr smr.  */
{
  {"bpr0", 0x0, 0xff},
  {"bpr1", 0x1, 0xff},
  {"pf0", 0x4, 0xff},
  {"pf1", 0x5, 0xff},
  {"sc", 0x8, 0xff},
  {"msr", 0xa, 0xff},
  {"bcnt", 0xb, 0xff},
  {"ptb0", 0xc, 0xff},
  {"ptb1", 0xd, 0xff},
  {"eia", 0xf, 0xff},
  {0, 0x0, 0xff}
};

#if defined(NS32532)
struct ns32k_option *cpureg = cpureg_532;
struct ns32k_option *mmureg = mmureg_532;
#else
struct ns32k_option *cpureg = cpureg_032;
struct ns32k_option *mmureg = mmureg_032;
#endif


const pseudo_typeS md_pseudo_table[] =
{					/* So far empty.  */
  {0, 0, 0}
};

#define IND(x,y)	(((x)<<2)+(y))

/* Those are index's to relax groups in md_relax_table ie it must be
   multiplied by 4 to point at a group start. Viz IND(x,y) Se function
   relax_segment in write.c for more info.  */

#define BRANCH		1
#define PCREL		2

/* Those are index's to entries in a relax group.  */

#define BYTE		0
#define WORD		1
#define DOUBLE		2
#define UNDEF           3
/* Those limits are calculated from the displacement start in memory.
   The ns32k uses the beginning of the instruction as displacement
   base.  This type of displacements could be handled here by moving
   the limit window up or down. I choose to use an internal
   displacement base-adjust as there are other routines that must
   consider this. Also, as we have two various offset-adjusts in the
   ns32k (acb versus br/brs/jsr/bcond), two set of limits would have
   had to be used.  Now we dont have to think about that.  */

const relax_typeS md_relax_table[] =
{
  {1, 1, 0, 0},
  {1, 1, 0, 0},
  {1, 1, 0, 0},
  {1, 1, 0, 0},

  {(63), (-64), 1, IND (BRANCH, WORD)},
  {(8192), (-8192), 2, IND (BRANCH, DOUBLE)},
  {0, 0, 4, 0},
  {1, 1, 0, 0}
};

/* Array used to test if mode contains displacements.
   Value is true if mode contains displacement.  */

char disp_test[] =
{0, 0, 0, 0, 0, 0, 0, 0,
 1, 1, 1, 1, 1, 1, 1, 1,
 1, 1, 1, 0, 0, 1, 1, 0,
 1, 1, 1, 1, 1, 1, 1, 1};

/* Array used to calculate max size of displacements.  */

char disp_size[] =
{4, 1, 2, 0, 4};

/* Parse a general operand into an addressingmode struct

   In:  pointer at operand in ascii form
        pointer at addr_mode struct for result
        the level of recursion. (always 0 or 1)

   Out: data in addr_mode struct.  */

static int
addr_mode (char *operand,
	   addr_modeS *addrmodeP,
	   int recursive_level)
{
  char *str;
  int i;
  int strl;
  int mode;
  int j;

  mode = DEFAULT;		/* Default.  */
  addrmodeP->scaled_mode = 0;	/* Why not.  */
  addrmodeP->scaled_reg = 0;	/* If 0, not scaled index.  */
  addrmodeP->float_flag = 0;
  addrmodeP->am_size = 0;
  addrmodeP->im_disp = 0;
  addrmodeP->pcrel = 0;	/* Not set in this function.  */
  addrmodeP->disp_suffix[0] = 0;
  addrmodeP->disp_suffix[1] = 0;
  addrmodeP->disp[0] = NULL;
  addrmodeP->disp[1] = NULL;
  str = operand;

  if (str[0] == 0)
    return 0;

  strl = strlen (str);

  switch (str[0])
    {
      /* The following three case statements controls the mode-chars
	 this is the place to ed if you want to change them.  */
#ifdef ABSOLUTE_PREFIX
    case ABSOLUTE_PREFIX:
      if (str[strl - 1] == ']')
	break;
      addrmodeP->mode = 21;	/* absolute */
      addrmodeP->disp[0] = str + 1;
      return -1;
#endif
#ifdef IMMEDIATE_PREFIX
    case IMMEDIATE_PREFIX:
      if (str[strl - 1] == ']')
	break;
      addrmodeP->mode = 20;	/* immediate */
      addrmodeP->disp[0] = str + 1;
      return -1;
#endif
    case '.':
      if (str[strl - 1] != ']')
	{
	  switch (str[1])
	    {
	    case '-':
	    case '+':
	      if (str[2] != '\000')
		{
		  addrmodeP->mode = 27;	/* pc-relative */
		  addrmodeP->disp[0] = str + 2;
		  return -1;
		}
	    default:
	      as_bad (_("Invalid syntax in PC-relative addressing mode"));
	      return 0;
	    }
	}
      break;
    case 'e':
      if (str[strl - 1] != ']')
	{
	  if ((!strncmp (str, "ext(", 4)) && strl > 7)
	    {				/* external */
	      addrmodeP->disp[0] = str + 4;
	      i = 0;
	      j = 2;
	      do
		{			/* disp[0]'s termination point.  */
		  j += 1;
		  if (str[j] == '(')
		    i++;
		  if (str[j] == ')')
		    i--;
		}
	      while (j < strl && i != 0);
	      if (i != 0 || !(str[j + 1] == '-' || str[j + 1] == '+'))
		{
		  as_bad (_("Invalid syntax in External addressing mode"));
		  return (0);
		}
	      str[j] = '\000';		/* null terminate disp[0] */
	      addrmodeP->disp[1] = str + j + 2;
	      addrmodeP->mode = 22;
	      return -1;
	    }
	}
      break;

    default:
      ;
    }

  strl = strlen (str);

  switch (strl)
    {
    case 2:
      switch (str[0])
	{
	case 'f':
	  addrmodeP->float_flag = 1;
	  /* Drop through.  */
	case 'r':
	  if (str[1] >= '0' && str[1] < '8')
	    {
	      addrmodeP->mode = str[1] - '0';
	      return -1;
	    }
	  break;
	default:
	  break;
	}
      /* Drop through.  */

    case 3:
      if (!strncmp (str, "tos", 3))
	{
	  addrmodeP->mode = 23;	/* TopOfStack */
	  return -1;
	}
      break;

    default:
      break;
    }

  if (strl > 4)
    {
      if (str[strl - 1] == ')')
	{
	  if (str[strl - 2] == ')')
	    {
	      if (!strncmp (&str[strl - 5], "(fp", 3))
		mode = 16;		/* Memory Relative.  */
	      else if (!strncmp (&str[strl - 5], "(sp", 3))
		mode = 17;
	      else if (!strncmp (&str[strl - 5], "(sb", 3))
		mode = 18;

	      if (mode != DEFAULT)
		{
		  /* Memory relative.  */
		  addrmodeP->mode = mode;
		  j = strl - 5;		/* Temp for end of disp[0].  */
		  i = 0;

		  do
		    {
		      strl -= 1;
		      if (str[strl] == ')')
			i++;
		      if (str[strl] == '(')
			i--;
		    }
		  while (strl > -1 && i != 0);

		  if (i != 0)
		    {
		      as_bad (_("Invalid syntax in Memory Relative addressing mode"));
		      return (0);
		    }

		  addrmodeP->disp[1] = str;
		  addrmodeP->disp[0] = str + strl + 1;
		  str[j] = '\000';	/* Null terminate disp[0] .  */
		  str[strl] = '\000';	/* Null terminate disp[1].  */

		  return -1;
		}
	    }

	  switch (str[strl - 3])
	    {
	    case 'r':
	    case 'R':
	      if (str[strl - 2] >= '0'
		  && str[strl - 2] < '8'
		  && str[strl - 4] == '(')
		{
		  addrmodeP->mode = str[strl - 2] - '0' + 8;
		  addrmodeP->disp[0] = str;
		  str[strl - 4] = 0;
		  return -1;		/* reg rel */
		}
	      /* Drop through.  */

	    default:
	      if (!strncmp (&str[strl - 4], "(fp", 3))
		mode = 24;
	      else if (!strncmp (&str[strl - 4], "(sp", 3))
		mode = 25;
	      else if (!strncmp (&str[strl - 4], "(sb", 3))
		mode = 26;
	      else if (!strncmp (&str[strl - 4], "(pc", 3))
		mode = 27;

	      if (mode != DEFAULT)
		{
		  addrmodeP->mode = mode;
		  addrmodeP->disp[0] = str;
		  str[strl - 4] = '\0';

		  return -1;		/* Memory space.  */
		}
	    }
	}

      /* No trailing ')' do we have a ']' ?  */
      if (str[strl - 1] == ']')
	{
	  switch (str[strl - 2])
	    {
	    case 'b':
	      mode = 28;
	      break;
	    case 'w':
	      mode = 29;
	      break;
	    case 'd':
	      mode = 30;
	      break;
	    case 'q':
	      mode = 31;
	      break;
	    default:
	      as_bad (_("Invalid scaled-indexed mode, use (b,w,d,q)"));

	      if (str[strl - 3] != ':' || str[strl - 6] != '['
		  || str[strl - 5] == 'r' || str[strl - 4] < '0'
		  || str[strl - 4] > '7')
		as_bad (_("Syntax in scaled-indexed mode, use [Rn:m] where n=[0..7] m={b,w,d,q}"));
	    } /* Scaled index.  */

	  if (recursive_level > 0)
	    {
	      as_bad (_("Scaled-indexed addressing mode combined with scaled-index"));
	      return 0;
	    }

	  addrmodeP->am_size += 1;	/* scaled index byte.  */
	  j = str[strl - 4] - '0';	/* store temporary.  */
	  str[strl - 6] = '\000';	/* nullterminate for recursive call.  */
	  i = addr_mode (str, addrmodeP, 1);

	  if (!i || addrmodeP->mode == 20)
	    {
	      as_bad (_("Invalid or illegal addressing mode combined with scaled-index"));
	      return 0;
	    }

	  addrmodeP->scaled_mode = addrmodeP->mode;	/* Store the inferior mode.  */
	  addrmodeP->mode = mode;
	  addrmodeP->scaled_reg = j + 1;

	  return -1;
	}
    }

  addrmodeP->mode = DEFAULT;	/* Default to whatever.  */
  addrmodeP->disp[0] = str;

  return -1;
}

static void
evaluate_expr (expressionS *resultP, char *ptr)
{
  char *tmp_line;

  tmp_line = input_line_pointer;
  input_line_pointer = ptr;
  expression (resultP);
  input_line_pointer = tmp_line;
}

/* ptr points at string addr_modeP points at struct with result This
   routine calls addr_mode to determine the general addr.mode of the
   operand. When this is ready it parses the displacements for size
   specifying suffixes and determines size of immediate mode via
   ns32k-opcode.  Also builds index bytes if needed.  */

static int
get_addr_mode (char *ptr, addr_modeS *addrmodeP)
{
  int tmp;

  addr_mode (ptr, addrmodeP, 0);

  if (addrmodeP->mode == DEFAULT || addrmodeP->scaled_mode == -1)
    {
      /* Resolve ambiguous operands, this shouldn't be necessary if
	 one uses standard NSC operand syntax. But the sequent
	 compiler doesn't!!!  This finds a proper addressing mode
	 if it is implicitly stated. See ns32k-opcode.h.  */
      (void) evaluate_expr (&exprP, ptr); /* This call takes time Sigh!  */

      if (addrmodeP->mode == DEFAULT)
	{
	  if (exprP.X_add_symbol || exprP.X_op_symbol)
	    addrmodeP->mode = desc->default_model; /* We have a label.  */
	  else
	    addrmodeP->mode = desc->default_modec; /* We have a constant.  */
	}
      else
	{
	  if (exprP.X_add_symbol || exprP.X_op_symbol)
	    addrmodeP->scaled_mode = desc->default_model;
	  else
	    addrmodeP->scaled_mode = desc->default_modec;
	}

      /* Must put this mess down in addr_mode to handle the scaled
         case better.  */
    }

  /* It appears as the sequent compiler wants an absolute when we have
     a label without @@. Constants becomes immediates besides the addr
     case.  Think it does so with local labels too, not optimum, pcrel
     is better.  When I have time I will make gas check this and
     select pcrel when possible Actually that is trivial.  */
  if ((tmp = addrmodeP->scaled_reg))
    {				/* Build indexbyte.  */
      tmp--;			/* Remember regnumber comes incremented for
				   flagpurpose.  */
      tmp |= addrmodeP->scaled_mode << 3;
      addrmodeP->index_byte = (char) tmp;
      addrmodeP->am_size += 1;
    }

  gas_assert (addrmodeP->mode >= 0); 
  if (disp_test[(unsigned int) addrmodeP->mode])
    {
      char c;
      char suffix;
      char suffix_sub;
      int i;
      char *toP;
      char *fromP;

      /* There was a displacement, probe for length  specifying suffix.  */
      addrmodeP->pcrel = 0;

      gas_assert (addrmodeP->mode >= 0);
      if (disp_test[(unsigned int) addrmodeP->mode])
	{
	  /* There is a displacement.  */
	  if (addrmodeP->mode == 27 || addrmodeP->scaled_mode == 27)
	    /* Do we have pcrel. mode.  */
	    addrmodeP->pcrel = 1;

	  addrmodeP->im_disp = 1;

	  for (i = 0; i < 2; i++)
	    {
	      suffix_sub = suffix = 0;

	      if ((toP = addrmodeP->disp[i]))
		{
		  /* Suffix of expression, the largest size rules.  */
		  fromP = toP;

		  while ((c = *fromP++))
		    {
		      *toP++ = c;
		      if (c == ':')
			{
			  switch (*fromP)
			    {
			    case '\0':
			      as_warn (_("Premature end of suffix -- Defaulting to d"));
			      suffix = 4;
			      continue;
			    case 'b':
			      suffix_sub = 1;
			      break;
			    case 'w':
			      suffix_sub = 2;
			      break;
			    case 'd':
			      suffix_sub = 4;
			      break;
			    default:
			      as_warn (_("Bad suffix after ':' use {b|w|d} Defaulting to d"));
			      suffix = 4;
			    }

			  fromP ++;
			  toP --;	/* So we write over the ':' */

			  if (suffix < suffix_sub)
			    suffix = suffix_sub;
			}
		    }

		  *toP = '\0'; /* Terminate properly.  */
		  addrmodeP->disp_suffix[i] = suffix;
		  addrmodeP->am_size += suffix ? suffix : 4;
		}
	    }
	}
    }
  else
    {
      if (addrmodeP->mode == 20)
	{
	  /* Look in ns32k_opcode for size.  */
	  addrmodeP->disp_suffix[0] = addrmodeP->am_size = desc->im_size;
	  addrmodeP->im_disp = 0;
	}
    }

  return addrmodeP->mode;
}

/* Read an optionlist.  */

static void
optlist (char *str,			/* The string to extract options from.  */
	 struct ns32k_option *optionP,	/* How to search the string.  */
	 unsigned long *default_map)	/* Default pattern and output.  */
{
  int i, j, k, strlen1, strlen2;
  char *patternP, *strP;

  strlen1 = strlen (str);

  if (strlen1 < 1)
    as_fatal (_("Very short instr to option, ie you can't do it on a NULLstr"));

  for (i = 0; optionP[i].pattern != 0; i++)
    {
      strlen2 = strlen (optionP[i].pattern);

      for (j = 0; j < strlen1; j++)
	{
	  patternP = optionP[i].pattern;
	  strP = &str[j];

	  for (k = 0; k < strlen2; k++)
	    {
	      if (*(strP++) != *(patternP++))
		break;
	    }

	  if (k == strlen2)
	    {			/* match */
	      *default_map |= optionP[i].or;
	      *default_map &= optionP[i].and;
	    }
	}
    }
}

/* Search struct for symbols.
   This function is used to get the short integer form of reg names in
   the instructions lmr, smr, lpr, spr return true if str is found in
   list.  */

static int
list_search (char *str,				/* The string to match.  */
	     struct ns32k_option *optionP,	/* List to search.  */
	     unsigned long *default_map)	/* Default pattern and output.  */
{
  int i;

  for (i = 0; optionP[i].pattern != 0; i++)
    {
      if (!strncmp (optionP[i].pattern, str, 20))
	{
	  /* Use strncmp to be safe.  */
	  *default_map |= optionP[i].or;
	  *default_map &= optionP[i].and;

	  return -1;
	}
    }

  as_bad (_("No such entry in list. (cpu/mmu register)"));
  return 0;
}

/* Create a bit_fixS in obstack 'notes'.
   This struct is used to profile the normal fix. If the bit_fixP is a
   valid pointer (not NULL) the bit_fix data will be used to format
   the fix.  */

static bit_fixS *
bit_fix_new (int size,		/* Length of bitfield.  */
	     int offset,	/* Bit offset to bitfield.  */
	     long min,		/* Signextended min for bitfield.  */
	     long max,		/* Signextended max for bitfield.  */
	     long add,		/* Add mask, used for huffman prefix.  */
	     long base_type,	/* 0 or 1, if 1 it's exploded to opcode ptr.  */
	     long base_adj)
{
  bit_fixS *bit_fixP;

  bit_fixP = obstack_alloc (&notes, sizeof (bit_fixS));

  bit_fixP->fx_bit_size = size;
  bit_fixP->fx_bit_offset = offset;
  bit_fixP->fx_bit_base = base_type;
  bit_fixP->fx_bit_base_adj = base_adj;
  bit_fixP->fx_bit_max = max;
  bit_fixP->fx_bit_min = min;
  bit_fixP->fx_bit_add = add;

  return bit_fixP;
}

/* Convert operands to iif-format and adds bitfields to the opcode.
   Operands are parsed in such an order that the opcode is updated from
   its most significant bit, that is when the operand need to alter the
   opcode.
   Be careful not to put to objects in the same iif-slot.  */

static void
encode_operand (int argc,
		char **argv,
		const char *operandsP,
		const char *suffixP,
		char im_size ATTRIBUTE_UNUSED,
		char opcode_bit_ptr)
{
  int i, j;
  char d;
  int pcrel, b, loop, pcrel_adjust;
  unsigned long tmp;

  for (loop = 0; loop < argc; loop++)
    {
      /* What operand are we supposed to work on.  */
      i = operandsP[loop << 1] - '1';
      if (i > 3)
	as_fatal (_("Internal consistency error.  check ns32k-opcode.h"));

      pcrel = 0;
      pcrel_adjust = 0;
      tmp = 0;

      switch ((d = operandsP[(loop << 1) + 1]))
	{
	case 'f':		/* Operand of sfsr turns out to be a nasty
				   specialcase.  */
	  opcode_bit_ptr -= 5;
	case 'Z':		/* Float not immediate.  */
	case 'F':		/* 32 bit float	general form.  */
	case 'L':		/* 64 bit float.  */
	case 'I':		/* Integer not immediate.  */
	case 'B':		/* Byte	 */
	case 'W':		/* Word	 */
	case 'D':		/* Double-word.  */
	case 'A':		/* Double-word	gen-address-form ie no regs
				   allowed.  */
	  get_addr_mode (argv[i], &addr_modeP);

	  if ((addr_modeP.mode == 20) &&
	     (d == 'I' || d == 'Z' || d == 'A'))
	    as_fatal (d == 'A'? _("Address of immediate operand"):
			_("Invalid immediate write operand."));

	  if (opcode_bit_ptr == desc->opcode_size)
	    b = 4;
	  else
	    b = 6;

	  for (j = b; j < (b + 2); j++)
	    {
	      if (addr_modeP.disp[j - b])
		{
		  IIF (j,
		       2,
		       addr_modeP.disp_suffix[j - b],
		       (unsigned long) addr_modeP.disp[j - b],
		       0,
		       addr_modeP.pcrel,
		       iif.instr_size,
		       addr_modeP.im_disp,
		       IND (BRANCH, BYTE),
		       NULL,
		       (addr_modeP.scaled_reg ? addr_modeP.scaled_mode
			: addr_modeP.mode),
		       0);
		}
	    }

	  opcode_bit_ptr -= 5;
	  iif.iifP[1].object |= ((long) addr_modeP.mode) << opcode_bit_ptr;

	  if (addr_modeP.scaled_reg)
	    {
	      j = b / 2;
	      IIF (j, 1, 1, (unsigned long) addr_modeP.index_byte,
		   0, 0, 0, 0, 0, NULL, -1, 0);
	    }
	  break;

	case 'b':		/* Multiple instruction disp.  */
	  freeptr++;		/* OVE:this is an useful hack.  */
	  sprintf (freeptr, "((%s-1)*%d)", argv[i], desc->im_size);
	  argv[i] = freeptr;
	  pcrel -= 1;		/* Make pcrel 0 in spite of what case 'p':
				   wants.  */
	  /* fall thru */
	case 'p':		/* Displacement - pc relative addressing.  */
	  pcrel += 1;
	  /* fall thru */
	case 'd':		/* Displacement.  */
	  iif.instr_size += suffixP[i] ? suffixP[i] : 4;
	  IIF (12, 2, suffixP[i], (unsigned long) argv[i], 0,
	       pcrel, pcrel_adjust, 1, IND (BRANCH, BYTE), NULL, -1, 0);
	  break;
	case 'H':		/* Sequent-hack: the linker wants a bit set
				   when bsr.  */
	  pcrel = 1;
	  iif.instr_size += suffixP[i] ? suffixP[i] : 4;
	  IIF (12, 2, suffixP[i], (unsigned long) argv[i], 0,
	       pcrel, pcrel_adjust, 1, IND (BRANCH, BYTE), NULL, -1, 1);
	  break;
	case 'q':		/* quick */
	  opcode_bit_ptr -= 4;
	  IIF (11, 2, 42, (unsigned long) argv[i], 0, 0, 0, 0, 0,
	       bit_fix_new (4, opcode_bit_ptr, -8, 7, 0, 1, 0), -1, 0);
	  break;
	case 'r':		/* Register number (3 bits).  */
	  list_search (argv[i], opt6, &tmp);
	  opcode_bit_ptr -= 3;
	  iif.iifP[1].object |= tmp << opcode_bit_ptr;
	  break;
	case 'O':		/* Setcfg instruction optionslist.  */
	  optlist (argv[i], opt3, &tmp);
	  opcode_bit_ptr -= 4;
	  iif.iifP[1].object |= tmp << 15;
	  break;
	case 'C':		/* Cinv instruction optionslist.  */
	  optlist (argv[i], opt4, &tmp);
	  opcode_bit_ptr -= 4;
	  iif.iifP[1].object |= tmp << 15; /* Insert the regtype in opcode.  */
	  break;
	case 'S':		/* String instruction options list.  */
	  optlist (argv[i], opt5, &tmp);
	  opcode_bit_ptr -= 4;
	  iif.iifP[1].object |= tmp << 15;
	  break;
	case 'u':
	case 'U':		/* Register list.  */
	  IIF (10, 1, 1, 0, 0, 0, 0, 0, 0, NULL, -1, 0);
	  switch (operandsP[(i << 1) + 1])
	    {
	    case 'u':		/* Restore, exit.  */
	      optlist (argv[i], opt1, &iif.iifP[10].object);
	      break;
	    case 'U':		/* Save, enter.  */
	      optlist (argv[i], opt2, &iif.iifP[10].object);
	      break;
	    }
	  iif.instr_size += 1;
	  break;
	case 'M':		/* MMU register.  */
	  list_search (argv[i], mmureg, &tmp);
	  opcode_bit_ptr -= 4;
	  iif.iifP[1].object |= tmp << opcode_bit_ptr;
	  break;
	case 'P':		/* CPU register.  */
	  list_search (argv[i], cpureg, &tmp);
	  opcode_bit_ptr -= 4;
	  iif.iifP[1].object |= tmp << opcode_bit_ptr;
	  break;
	case 'g':		/* Inss exts.  */
	  iif.instr_size += 1;	/* 1 byte is allocated after the opcode.  */
	  IIF (10, 2, 1,
	       (unsigned long) argv[i],	/* i always 2 here.  */
	       0, 0, 0, 0, 0,
	       bit_fix_new (3, 5, 0, 7, 0, 0, 0), /* A bit_fix is targeted to
						     the byte.  */
	       -1, 0);
	  break;
	case 'G':
	  IIF (11, 2, 42,
	       (unsigned long) argv[i],	/* i always 3 here.  */
	       0, 0, 0, 0, 0,
	       bit_fix_new (5, 0, 1, 32, -1, 0, -1), -1, 0);
	  break;
	case 'i':
	  iif.instr_size += 1;
	  b = 2 + i;		/* Put the extension byte after opcode.  */
	  IIF (b, 2, 1, 0, 0, 0, 0, 0, 0, 0, -1, 0);
	  break;
	default:
	  as_fatal (_("Bad opcode-table-option, check in file ns32k-opcode.h"));
	}
    }
}

/* in:  instruction line
   out: internal structure of instruction
   that has been prepared for direct conversion to fragment(s) and
   fixes in a systematical fashion
   Return-value = recursive_level.  */
/* Build iif of one assembly text line.  */

static int
parse (const char *line, int recursive_level)
{
  const char *lineptr;
  char c, suffix_separator;
  int i;
  unsigned int argc;
  int arg_type;
  char sqr, sep;
  char suffix[MAX_ARGS], *argv[MAX_ARGS];	/* No more than 4 operands.  */

  if (recursive_level <= 0)
    {
      /* Called from md_assemble.  */
      for (lineptr = line; (*lineptr) != '\0' && (*lineptr) != ' '; lineptr++)
	continue;

      c = *lineptr;
      *(char *) lineptr = '\0';

      if (!(desc = (struct ns32k_opcode *) hash_find (inst_hash_handle, line)))
	as_fatal (_("No such opcode"));

      *(char *) lineptr = c;
    }
  else
    lineptr = line;

  argc = 0;

  if (*desc->operands)
    {
      if (*lineptr++ != '\0')
	{
	  sqr = '[';
	  sep = ',';

	  while (*lineptr != '\0')
	    {
	      if (desc->operands[argc << 1])
		{
		  suffix[argc] = 0;
		  arg_type = desc->operands[(argc << 1) + 1];

		  switch (arg_type)
		    {
		    case 'd':
		    case 'b':
		    case 'p':
		    case 'H':
		      /* The operand is supposed to be a displacement.  */
		      /* Hackwarning: do not forget to update the 4
                         cases above when editing ns32k-opcode.h.  */
		      suffix_separator = ':';
		      break;
		    default:
		      /* If this char occurs we loose.  */
		      suffix_separator = '\255';
		      break;
		    }

		  suffix[argc] = 0; /* 0 when no ':' is encountered.  */
		  argv[argc] = freeptr;
		  *freeptr = '\0';

		  while ((c = *lineptr) != '\0' && c != sep)
		    {
		      if (c == sqr)
			{
			  if (sqr == '[')
			    {
			      sqr = ']';
			      sep = '\0';
			    }
			  else
			    {
			      sqr = '[';
			      sep = ',';
			    }
			}

		      if (c == suffix_separator)
			{
			  /* ':' - label/suffix separator.  */
			  switch (lineptr[1])
			    {
			    case 'b':
			      suffix[argc] = 1;
			      break;
			    case 'w':
			      suffix[argc] = 2;
			      break;
			    case 'd':
			      suffix[argc] = 4;
			      break;
			    default:
			      as_warn (_("Bad suffix, defaulting to d"));
			      suffix[argc] = 4;
			      if (lineptr[1] == '\0' || lineptr[1] == sep)
				{
				  lineptr += 1;
				  continue;
				}
			      break;
			    }

			  lineptr += 2;
			  continue;
			}

		      *freeptr++ = c;
		      lineptr++;
		    }

		  *freeptr++ = '\0';
		  argc += 1;

		  if (*lineptr == '\0')
		    continue;

		  lineptr += 1;
		}
	      else
		as_fatal (_("Too many operands passed to instruction"));
	    }
	}
    }

  if (argc != strlen (desc->operands) / 2)
    {
      if (strlen (desc->default_args))
	{
	  /* We can apply default, don't goof.  */
	  if (parse (desc->default_args, 1) != 1)
	    /* Check error in default.  */
	    as_fatal (_("Wrong numbers of operands in default, check ns32k-opcodes.h"));
	}
      else
	as_fatal (_("Wrong number of operands"));
    }

  for (i = 0; i < IIF_ENTRIES; i++)
    /* Mark all entries as void.  */
    iif.iifP[i].type = 0;

  /* Build opcode iif-entry.  */
  iif.instr_size = desc->opcode_size / 8;
  IIF (1, 1, iif.instr_size, desc->opcode_seed, 0, 0, 0, 0, 0, 0, -1, 0);

  /* This call encodes operands to iif format.  */
  if (argc)
    encode_operand (argc, argv, &desc->operands[0],
		    &suffix[0], desc->im_size, desc->opcode_size);

  return recursive_level;
}

/* This functionality should really be in the bfd library.  */

static bfd_reloc_code_real_type
reloc (int size, int pcrel, int type)
{
  int length, rel_index;
  bfd_reloc_code_real_type relocs[] =
  {
    BFD_RELOC_NS32K_IMM_8,
    BFD_RELOC_NS32K_IMM_16,
    BFD_RELOC_NS32K_IMM_32,
    BFD_RELOC_NS32K_IMM_8_PCREL,
    BFD_RELOC_NS32K_IMM_16_PCREL,
    BFD_RELOC_NS32K_IMM_32_PCREL,

    /* ns32k displacements.  */
    BFD_RELOC_NS32K_DISP_8,
    BFD_RELOC_NS32K_DISP_16,
    BFD_RELOC_NS32K_DISP_32,
    BFD_RELOC_NS32K_DISP_8_PCREL,
    BFD_RELOC_NS32K_DISP_16_PCREL,
    BFD_RELOC_NS32K_DISP_32_PCREL,

    /* Normal 2's complement.  */
    BFD_RELOC_8,
    BFD_RELOC_16,
    BFD_RELOC_32,
    BFD_RELOC_8_PCREL,
    BFD_RELOC_16_PCREL,
    BFD_RELOC_32_PCREL
  };

  switch (size)
    {
    case 1:
      length = 0;
      break;
    case 2:
      length = 1;
      break;
    case 4:
      length = 2;
      break;
    default:
      length = -1;
      break;
    }

  rel_index = length + 3 * pcrel + 6 * type;

  if (rel_index >= 0 && (unsigned int) rel_index < sizeof (relocs) / sizeof (relocs[0]))
    return relocs[rel_index];

  if (pcrel)
    as_bad (_("Can not do %d byte pc-relative relocation for storage type %d"),
	    size, type);
  else
    as_bad (_("Can not do %d byte relocation for storage type %d"),
	    size, type);

  return BFD_RELOC_NONE;

}

static void
fix_new_ns32k (fragS *frag,		/* Which frag? */
	       int where,		/* Where in that frag? */
	       int size,		/* 1, 2  or 4 usually.  */
	       symbolS *add_symbol,	/* X_add_symbol.  */
	       long offset,		/* X_add_number.  */
	       int pcrel,		/* True if PC-relative relocation.  */
	       char im_disp,		/* True if the value to write is a
					   displacement.  */
	       bit_fixS *bit_fixP,	/* Pointer at struct of bit_fix's, ignored if
					   NULL.  */
	       char bsr,		/* Sequent-linker-hack: 1 when relocobject is
					   a bsr.  */
	       fragS *opcode_frag,
	       unsigned int opcode_offset)
{
  fixS *fixP = fix_new (frag, where, size, add_symbol,
			offset, pcrel,
			bit_fixP ? NO_RELOC : reloc (size, pcrel, im_disp)
			);

  fix_opcode_frag (fixP) = opcode_frag;
  fix_opcode_offset (fixP) = opcode_offset;
  fix_im_disp (fixP) = im_disp;
  fix_bsr (fixP) = bsr;
  fix_bit_fixP (fixP) = bit_fixP;
  /* We have a MD overflow check for displacements.  */
  fixP->fx_no_overflow = (im_disp != 0);
}

static void
fix_new_ns32k_exp (fragS *frag,		/* Which frag? */
		   int where,		/* Where in that frag? */
		   int size,		/* 1, 2  or 4 usually.  */
		   expressionS *exp,	/* Expression.  */
		   int pcrel,		/* True if PC-relative relocation.  */
		   char im_disp,	/* True if the value to write is a
					   displacement.  */
		   bit_fixS *bit_fixP,	/* Pointer at struct of bit_fix's, ignored if
					   NULL.  */
		   char bsr,		/* Sequent-linker-hack: 1 when relocobject is
					   a bsr.  */
		   fragS *opcode_frag,
		   unsigned int opcode_offset)
{
  fixS *fixP = fix_new_exp (frag, where, size, exp, pcrel,
			    bit_fixP ? NO_RELOC : reloc (size, pcrel, im_disp)
			    );

  fix_opcode_frag (fixP) = opcode_frag;
  fix_opcode_offset (fixP) = opcode_offset;
  fix_im_disp (fixP) = im_disp;
  fix_bsr (fixP) = bsr;
  fix_bit_fixP (fixP) = bit_fixP;
  /* We have a MD overflow check for displacements.  */
  fixP->fx_no_overflow = (im_disp != 0);
}

/* Convert number to chars in correct order.  */

void
md_number_to_chars (char *buf, valueT value, int nbytes)
{
  number_to_chars_littleendian (buf, value, nbytes);
}

/* This is a variant of md_numbers_to_chars. The reason for its'
   existence is the fact that ns32k uses Huffman coded
   displacements. This implies that the bit order is reversed in
   displacements and that they are prefixed with a size-tag.

   binary: msb -> lsb
   0xxxxxxx				byte
   10xxxxxx xxxxxxxx			word
   11xxxxxx xxxxxxxx xxxxxxxx xxxxxxxx	double word

   This must be taken care of and we do it here!  */

static void
md_number_to_disp (char *buf, long val, int n)
{
  switch (n)
    {
    case 1:
      if (val < -64 || val > 63)
	as_bad (_("value of %ld out of byte displacement range."), val);
      val &= 0x7f;
#ifdef SHOW_NUM
      printf ("%x ", val & 0xff);
#endif
      *buf++ = val;
      break;

    case 2:
      if (val < -8192 || val > 8191)
	as_bad (_("value of %ld out of word displacement range."), val);
      val &= 0x3fff;
      val |= 0x8000;
#ifdef SHOW_NUM
      printf ("%x ", val >> 8 & 0xff);
#endif
      *buf++ = (val >> 8);
#ifdef SHOW_NUM
      printf ("%x ", val & 0xff);
#endif
      *buf++ = val;
      break;

    case 4:
      if (val < -0x20000000 || val >= 0x20000000)
	as_bad (_("value of %ld out of double word displacement range."), val);
      val |= 0xc0000000;
#ifdef SHOW_NUM
      printf ("%x ", val >> 24 & 0xff);
#endif
      *buf++ = (val >> 24);
#ifdef SHOW_NUM
      printf ("%x ", val >> 16 & 0xff);
#endif
      *buf++ = (val >> 16);
#ifdef SHOW_NUM
      printf ("%x ", val >> 8 & 0xff);
#endif
      *buf++ = (val >> 8);
#ifdef SHOW_NUM
      printf ("%x ", val & 0xff);
#endif
      *buf++ = val;
      break;

    default:
      as_fatal (_("Internal logic error.  line %d, file \"%s\""),
		__LINE__, __FILE__);
    }
}

static void
md_number_to_imm (char *buf, long val, int n)
{
  switch (n)
    {
    case 1:
#ifdef SHOW_NUM
      printf ("%x ", val & 0xff);
#endif
      *buf++ = val;
      break;

    case 2:
#ifdef SHOW_NUM
      printf ("%x ", val >> 8 & 0xff);
#endif
      *buf++ = (val >> 8);
#ifdef SHOW_NUM
      printf ("%x ", val & 0xff);
#endif
      *buf++ = val;
      break;

    case 4:
#ifdef SHOW_NUM
      printf ("%x ", val >> 24 & 0xff);
#endif
      *buf++ = (val >> 24);
#ifdef SHOW_NUM
      printf ("%x ", val >> 16 & 0xff);
#endif
      *buf++ = (val >> 16);
#ifdef SHOW_NUM
      printf ("%x ", val >> 8 & 0xff);
#endif
      *buf++ = (val >> 8);
#ifdef SHOW_NUM
      printf ("%x ", val & 0xff);
#endif
      *buf++ = val;
      break;

    default:
      as_fatal (_("Internal logic error. line %d, file \"%s\""),
		__LINE__, __FILE__);
    }
}

/* Fast bitfiddling support.  */
/* Mask used to zero bitfield before oring in the true field.  */

static unsigned long l_mask[] =
{
  0xffffffff, 0xfffffffe, 0xfffffffc, 0xfffffff8,
  0xfffffff0, 0xffffffe0, 0xffffffc0, 0xffffff80,
  0xffffff00, 0xfffffe00, 0xfffffc00, 0xfffff800,
  0xfffff000, 0xffffe000, 0xffffc000, 0xffff8000,
  0xffff0000, 0xfffe0000, 0xfffc0000, 0xfff80000,
  0xfff00000, 0xffe00000, 0xffc00000, 0xff800000,
  0xff000000, 0xfe000000, 0xfc000000, 0xf8000000,
  0xf0000000, 0xe0000000, 0xc0000000, 0x80000000,
};
static unsigned long r_mask[] =
{
  0x00000000, 0x00000001, 0x00000003, 0x00000007,
  0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f,
  0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff,
  0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff,
  0x0000ffff, 0x0001ffff, 0x0003ffff, 0x0007ffff,
  0x000fffff, 0x001fffff, 0x003fffff, 0x007fffff,
  0x00ffffff, 0x01ffffff, 0x03ffffff, 0x07ffffff,
  0x0fffffff, 0x1fffffff, 0x3fffffff, 0x7fffffff,
};
#define MASK_BITS 31
/* Insert bitfield described by field_ptr and val at buf
   This routine is written for modification of the first 4 bytes pointed
   to by buf, to yield speed.
   The ifdef stuff is for selection between a ns32k-dependent routine
   and a general version. (My advice: use the general version!).  */

static void
md_number_to_field (char *buf, long val, bit_fixS *field_ptr)
{
  unsigned long object;
  unsigned long mask;
  /* Define ENDIAN on a ns32k machine.  */
#ifdef ENDIAN
  unsigned long *mem_ptr;
#else
  char *mem_ptr;
#endif

  if (field_ptr->fx_bit_min <= val && val <= field_ptr->fx_bit_max)
    {
#ifdef ENDIAN
      if (field_ptr->fx_bit_base)
	/* Override buf.  */
	mem_ptr = (unsigned long *) field_ptr->fx_bit_base;
      else
	mem_ptr = (unsigned long *) buf;

      mem_ptr = ((unsigned long *)
		 ((char *) mem_ptr + field_ptr->fx_bit_base_adj));
#else
      if (field_ptr->fx_bit_base)
	mem_ptr = (char *) field_ptr->fx_bit_base;
      else
	mem_ptr = buf;

      mem_ptr += field_ptr->fx_bit_base_adj;
#endif
#ifdef ENDIAN
      /* We have a nice ns32k machine with lowbyte at low-physical mem.  */
      object = *mem_ptr;	/* get some bytes */
#else /* OVE Goof! the machine is a m68k or dito.  */
      /* That takes more byte fiddling.  */
      object = 0;
      object |= mem_ptr[3] & 0xff;
      object <<= 8;
      object |= mem_ptr[2] & 0xff;
      object <<= 8;
      object |= mem_ptr[1] & 0xff;
      object <<= 8;
      object |= mem_ptr[0] & 0xff;
#endif
      mask = 0;
      mask |= (r_mask[field_ptr->fx_bit_offset]);
      mask |= (l_mask[field_ptr->fx_bit_offset + field_ptr->fx_bit_size]);
      object &= mask;
      val += field_ptr->fx_bit_add;
      object |= ((val << field_ptr->fx_bit_offset) & (mask ^ 0xffffffff));
#ifdef ENDIAN
      *mem_ptr = object;
#else
      mem_ptr[0] = (char) object;
      object >>= 8;
      mem_ptr[1] = (char) object;
      object >>= 8;
      mem_ptr[2] = (char) object;
      object >>= 8;
      mem_ptr[3] = (char) object;
#endif
    }
  else
    as_bad (_("Bit field out of range"));
}

/* Convert iif to fragments.  From this point we start to dribble with
   functions in other files than this one.(Except hash.c) So, if it's
   possible to make an iif for an other CPU, you don't need to know
   what frags, relax, obstacks, etc is in order to port this
   assembler. You only need to know if it's possible to reduce your
   cpu-instruction to iif-format (takes some work) and adopt the other
   md_? parts according to given instructions Note that iif was
   invented for the clean ns32k`s architecture.  */

/* GAS for the ns32k has a problem. PC relative displacements are
   relative to the address of the opcode, not the address of the
   operand. We used to keep track of the offset between the operand
   and the opcode in pcrel_adjust for each frag and each fix. However,
   we get into trouble where there are two or more pc-relative
   operands and the size of the first one can't be determined. Then in
   the relax phase, the size of the first operand will change and
   pcrel_adjust will no longer be correct.  The current solution is
   keep a pointer to the frag with the opcode in it and the offset in
   that frag for each frag and each fix. Then, when needed, we can
   always figure out how far it is between the opcode and the pcrel
   object.  See also md_pcrel_adjust and md_fix_pcrel_adjust.  For
   objects not part of an instruction, the pointer to the opcode frag
   is always zero.  */

static void
convert_iif (void)
{
  int i;
  bit_fixS *j;
  fragS *inst_frag;
  unsigned int inst_offset;
  char *inst_opcode;
  char *memP;
  int l;
  int k;
  char type;
  char size = 0;

  frag_grow (iif.instr_size);	/* This is important.  */
  memP = frag_more (0);
  inst_opcode = memP;
  inst_offset = (memP - frag_now->fr_literal);
  inst_frag = frag_now;

  for (i = 0; i < IIF_ENTRIES; i++)
    {
      if ((type = iif.iifP[i].type))
	{
	  /* The object exist, so handle it.  */
	  switch (size = iif.iifP[i].size)
	    {
	    case 42:
	      size = 0;
	      /* It's a bitfix that operates on an existing object.  */
	      if (iif.iifP[i].bit_fixP->fx_bit_base)
		/* Expand fx_bit_base to point at opcode.  */
		iif.iifP[i].bit_fixP->fx_bit_base = (long) inst_opcode;
	      /* Fall through.  */

	    case 8:		/* bignum or doublefloat.  */
	    case 1:
	    case 2:
	    case 3:
	    case 4:
	      /* The final size in objectmemory is known.  */
	      memP = frag_more (size);
	      j = iif.iifP[i].bit_fixP;

	      switch (type)
		{
		case 1:	/* The object is pure binary.  */
		  if (j)
		    md_number_to_field (memP, exprP.X_add_number, j);

		  else if (iif.iifP[i].pcrel)
		    fix_new_ns32k (frag_now,
				   (long) (memP - frag_now->fr_literal),
				   size,
				   0,
				   iif.iifP[i].object,
				   iif.iifP[i].pcrel,
				   iif.iifP[i].im_disp,
				   0,
				   iif.iifP[i].bsr,	/* Sequent hack.  */
				   inst_frag, inst_offset);
		  else
		    {
		      /* Good, just put them bytes out.  */
		      switch (iif.iifP[i].im_disp)
			{
			case 0:
			  md_number_to_chars (memP, iif.iifP[i].object, size);
			  break;
			case 1:
			  md_number_to_disp (memP, iif.iifP[i].object, size);
			  break;
			default:
			  as_fatal (_("iif convert internal pcrel/binary"));
			}
		    }
		  break;

		case 2:
		  /* The object is a pointer at an expression, so
                     unpack it, note that bignums may result from the
                     expression.  */
		  evaluate_expr (&exprP, (char *) iif.iifP[i].object);
		  if (exprP.X_op == O_big || size == 8)
		    {
		      if ((k = exprP.X_add_number) > 0)
			{
			  /* We have a bignum ie a quad. This can only
                             happens in a long suffixed instruction.  */
			  if (k * 2 > size)
			    as_bad (_("Bignum too big for long"));

			  if (k == 3)
			    memP += 2;

			  for (l = 0; k > 0; k--, l += 2)
			    md_number_to_chars (memP + l,
						generic_bignum[l >> 1],
						sizeof (LITTLENUM_TYPE));
			}
		      else
			{
			  /* flonum.  */
			  LITTLENUM_TYPE words[4];

			  switch (size)
			    {
			    case 4:
			      gen_to_words (words, 2, 8);
			      md_number_to_imm (memP, (long) words[0],
						sizeof (LITTLENUM_TYPE));
			      md_number_to_imm (memP + sizeof (LITTLENUM_TYPE),
						(long) words[1],
						sizeof (LITTLENUM_TYPE));
			      break;
			    case 8:
			      gen_to_words (words, 4, 11);
			      md_number_to_imm (memP, (long) words[0],
						sizeof (LITTLENUM_TYPE));
			      md_number_to_imm (memP + sizeof (LITTLENUM_TYPE),
						(long) words[1],
						sizeof (LITTLENUM_TYPE));
			      md_number_to_imm ((memP + 2
						 * sizeof (LITTLENUM_TYPE)),
						(long) words[2],
						sizeof (LITTLENUM_TYPE));
			      md_number_to_imm ((memP + 3
						 * sizeof (LITTLENUM_TYPE)),
						(long) words[3],
						sizeof (LITTLENUM_TYPE));
			      break;
			    }
			}
		      break;
		    }
		  if (exprP.X_add_symbol ||
		      exprP.X_op_symbol ||
		      iif.iifP[i].pcrel)
		    {
		      /* The expression was undefined due to an
                         undefined label. Create a fix so we can fix
                         the object later.  */
		      exprP.X_add_number += iif.iifP[i].object_adjust;
		      fix_new_ns32k_exp (frag_now,
					 (long) (memP - frag_now->fr_literal),
					 size,
					 &exprP,
					 iif.iifP[i].pcrel,
					 iif.iifP[i].im_disp,
					 j,
					 iif.iifP[i].bsr,
					 inst_frag, inst_offset);
		    }
		  else if (j)
		    md_number_to_field (memP, exprP.X_add_number, j);
		  else
		    {
		      /* Good, just put them bytes out.  */
		      switch (iif.iifP[i].im_disp)
			{
			case 0:
			  md_number_to_imm (memP, exprP.X_add_number, size);
			  break;
			case 1:
			  md_number_to_disp (memP, exprP.X_add_number, size);
			  break;
			default:
			  as_fatal (_("iif convert internal pcrel/pointer"));
			}
		    }
		  break;
		default:
		  as_fatal (_("Internal logic error in iif.iifP[n].type"));
		}
	      break;

	    case 0:
	      /* Too bad, the object may be undefined as far as its
		 final nsize in object memory is concerned.  The size
		 of the object in objectmemory is not explicitly
		 given.  If the object is defined its length can be
		 determined and a fix can replace the frag.  */
	      {
		evaluate_expr (&exprP, (char *) iif.iifP[i].object);

		if ((exprP.X_add_symbol || exprP.X_op_symbol) &&
		    !iif.iifP[i].pcrel)
		  {
		    /* Size is unknown until link time so have to default.  */
		    size = default_disp_size; /* Normally 4 bytes.  */
		    memP = frag_more (size);
		    fix_new_ns32k_exp (frag_now,
				       (long) (memP - frag_now->fr_literal),
				       size,
				       &exprP,
				       0, /* never iif.iifP[i].pcrel, */
				       1, /* always iif.iifP[i].im_disp */
				       (bit_fixS *) 0, 0,
				       inst_frag,
				       inst_offset);
		    break;		/* Exit this absolute hack.  */
		  }

		if (exprP.X_add_symbol || exprP.X_op_symbol)
		  {
		    /* Frag it.  */
		    if (exprP.X_op_symbol)
		      /* We cant relax this case.  */
		      as_fatal (_("Can't relax difference"));
		    else
		      {
			/* Size is not important.  This gets fixed by
			   relax, but we assume 0 in what follows.  */
			memP = frag_more (4); /* Max size.  */
			size = 0;

			{
			  fragS *old_frag = frag_now;
			  frag_variant (rs_machine_dependent,
					4, /* Max size.  */
					0, /* Size.  */
					IND (BRANCH, UNDEF), /* Expecting
                                                                the worst.  */
					exprP.X_add_symbol,
					exprP.X_add_number,
					inst_opcode);
			  frag_opcode_frag (old_frag) = inst_frag;
			  frag_opcode_offset (old_frag) = inst_offset;
			  frag_bsr (old_frag) = iif.iifP[i].bsr;
			}
		      }
		  }
		else
		  {
		    /* This duplicates code in md_number_to_disp.  */
		    if (-64 <= exprP.X_add_number && exprP.X_add_number <= 63)
		      size = 1;
		    else
		      {
			if (-8192 <= exprP.X_add_number
			    && exprP.X_add_number <= 8191)
			  size = 2;
			else
			  {
			    if (-0x20000000 <= exprP.X_add_number
				&& exprP.X_add_number<=0x1fffffff)
			      size = 4;
			    else
			      {
				as_bad (_("Displacement too large for :d"));
				size = 4;
			      }
			  }
		      }

		    memP = frag_more (size);
		    md_number_to_disp (memP, exprP.X_add_number, size);
		  }
	      }
	      break;

	    default:
	      as_fatal (_("Internal logic error in iif.iifP[].type"));
	    }
	}
    }
}

void
md_assemble (char *line)
{
  freeptr = freeptr_static;
  parse (line, 0);		/* Explode line to more fix form in iif.  */
  convert_iif ();		/* Convert iif to frags, fix's etc.  */
#ifdef SHOW_NUM
  printf (" \t\t\t%s\n", line);
#endif
}

void
md_begin (void)
{
  /* Build a hashtable of the instructions.  */
  const struct ns32k_opcode *ptr;
  const char *status;
  const struct ns32k_opcode *endop;

  inst_hash_handle = hash_new ();

  endop = ns32k_opcodes + sizeof (ns32k_opcodes) / sizeof (ns32k_opcodes[0]);
  for (ptr = ns32k_opcodes; ptr < endop; ptr++)
    {
      if ((status = hash_insert (inst_hash_handle, ptr->name, (char *) ptr)))
	/* Fatal.  */
	as_fatal (_("Can't hash %s: %s"), ptr->name, status);
    }

  /* Some private space please!  */
  freeptr_static = (char *) malloc (PRIVATE_SIZE);
}

/* Turn the string pointed to by litP into a floating point constant
   of type TYPE, and emit the appropriate bytes.  The number of
   LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */

char *
md_atof (int type, char *litP, int *sizeP)
{
  return ieee_md_atof (type, litP, sizeP, FALSE);
}

int
md_pcrel_adjust (fragS *fragP)
{
  fragS *opcode_frag;
  addressT opcode_address;
  unsigned int offset;

  opcode_frag = frag_opcode_frag (fragP);
  if (opcode_frag == 0)
    return 0;

  offset = frag_opcode_offset (fragP);
  opcode_address = offset + opcode_frag->fr_address;

  return fragP->fr_address + fragP->fr_fix - opcode_address;
}

static int
md_fix_pcrel_adjust (fixS *fixP)
{
  fragS *opcode_frag;
  addressT opcode_address;
  unsigned int offset;

  opcode_frag = fix_opcode_frag (fixP);
  if (opcode_frag == 0)
    return 0;

  offset = fix_opcode_offset (fixP);
  opcode_address = offset + opcode_frag->fr_address;

  return fixP->fx_where + fixP->fx_frag->fr_address - opcode_address;
}

/* Apply a fixS (fixup of an instruction or data that we didn't have
   enough info to complete immediately) to the data in a frag.

   On the ns32k, everything is in a different format, so we have broken
   out separate functions for each kind of thing we could be fixing.
   They all get called from here.  */

void
md_apply_fix (fixS *fixP, valueT * valP, segT seg ATTRIBUTE_UNUSED)
{
  long val = * (long *) valP;
  char *buf = fixP->fx_where + fixP->fx_frag->fr_literal;

  if (fix_bit_fixP (fixP))
    /* Bitfields to fix, sigh.  */
    md_number_to_field (buf, val, fix_bit_fixP (fixP));
  else switch (fix_im_disp (fixP))
    {
    case 0:
      /* Immediate field.  */
      md_number_to_imm (buf, val, fixP->fx_size);
      break;

    case 1:
      /* Displacement field.  */
      /* Calculate offset.  */
      md_number_to_disp (buf,
			 (fixP->fx_pcrel ? val + md_fix_pcrel_adjust (fixP)
			  : val), fixP->fx_size);
      break;

    case 2:
      /* Pointer in a data object.  */
      md_number_to_chars (buf, val, fixP->fx_size);
      break;
    }

  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;
}

/* Convert a relaxed displacement to ditto in final output.  */

void
md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED,
		 segT sec ATTRIBUTE_UNUSED,
		 fragS *fragP)
{
  long disp;
  long ext = 0;
  /* Address in gas core of the place to store the displacement.  */
  char *buffer_address = fragP->fr_fix + fragP->fr_literal;
  /* Address in object code of the displacement.  */
  int object_address;

  switch (fragP->fr_subtype)
    {
    case IND (BRANCH, BYTE):
      ext = 1;
      break;
    case IND (BRANCH, WORD):
      ext = 2;
      break;
    case IND (BRANCH, DOUBLE):
      ext = 4;
      break;
    }

  if (ext == 0)
    return;

  know (fragP->fr_symbol);

  object_address = fragP->fr_fix + fragP->fr_address;

  /* The displacement of the address, from current location.  */
  disp = (S_GET_VALUE (fragP->fr_symbol) + fragP->fr_offset) - object_address;
  disp += md_pcrel_adjust (fragP);

  md_number_to_disp (buffer_address, (long) disp, (int) ext);
  fragP->fr_fix += ext;
}

/* This function returns the estimated size a variable object will occupy,
   one can say that we tries to guess the size of the objects before we
   actually know it.  */

int
md_estimate_size_before_relax (fragS *fragP, segT segment)
{
  if (fragP->fr_subtype == IND (BRANCH, UNDEF))
    {
      if (S_GET_SEGMENT (fragP->fr_symbol) != segment)
	{
	  /* We don't relax symbols defined in another segment.  The
	     thing to do is to assume the object will occupy 4 bytes.  */
	  fix_new_ns32k (fragP,
			 (int) (fragP->fr_fix),
			 4,
			 fragP->fr_symbol,
			 fragP->fr_offset,
			 1,
			 1,
			 0,
			 frag_bsr(fragP), /* Sequent hack.  */
			 frag_opcode_frag (fragP),
			 frag_opcode_offset (fragP));
	  fragP->fr_fix += 4;
	  frag_wane (fragP);
	  return 4;
	}

      /* Relaxable case.  Set up the initial guess for the variable
	 part of the frag.  */
      fragP->fr_subtype = IND (BRANCH, BYTE);
    }

  if (fragP->fr_subtype >= sizeof (md_relax_table) / sizeof (md_relax_table[0]))
    abort ();

  /* Return the size of the variable part of the frag.  */
  return md_relax_table[fragP->fr_subtype].rlx_length;
}

int md_short_jump_size = 3;
int md_long_jump_size = 5;

void
md_create_short_jump (char *ptr,
		      addressT from_addr,
		      addressT to_addr,
		      fragS *frag ATTRIBUTE_UNUSED,
		      symbolS *to_symbol ATTRIBUTE_UNUSED)
{
  valueT offset;

  offset = to_addr - from_addr;
  md_number_to_chars (ptr, (valueT) 0xEA, 1);
  md_number_to_disp (ptr + 1, (valueT) offset, 2);
}

void
md_create_long_jump (char *ptr,
		     addressT from_addr,
		     addressT to_addr,
		     fragS *frag ATTRIBUTE_UNUSED,
		     symbolS *to_symbol ATTRIBUTE_UNUSED)
{
  valueT offset;

  offset = to_addr - from_addr;
  md_number_to_chars (ptr, (valueT) 0xEA, 1);
  md_number_to_disp (ptr + 1, (valueT) offset, 4);
}

const char *md_shortopts = "m:";

struct option md_longopts[] =
{
#define OPTION_DISP_SIZE (OPTION_MD_BASE)
  {"disp-size-default", required_argument , NULL, OPTION_DISP_SIZE},
  {NULL, no_argument, NULL, 0}
};

size_t md_longopts_size = sizeof (md_longopts);

int
md_parse_option (int c, char *arg)
{
  switch (c)
    {
    case 'm':
      if (!strcmp (arg, "32032"))
	{
	  cpureg = cpureg_032;
	  mmureg = mmureg_032;
	}
      else if (!strcmp (arg, "32532"))
	{
	  cpureg = cpureg_532;
	  mmureg = mmureg_532;
	}
      else
	{
	  as_warn (_("invalid architecture option -m%s, ignored"), arg);
	  return 0;
	}
      break;
    case OPTION_DISP_SIZE:
      {
	int size = atoi(arg);
	switch (size)
	  {
	  case 1: case 2: case 4:
	    default_disp_size = size;
	    break;
	  default:
	    as_warn (_("invalid default displacement size \"%s\". Defaulting to %d."),
		     arg, default_disp_size);
	  }
	break;
      }

    default:
      return 0;
    }

  return 1;
}

void
md_show_usage (FILE *stream)
{
  fprintf (stream, _("\
NS32K options:\n\
-m32032 | -m32532	select variant of NS32K architecture\n\
--disp-size-default=<1|2|4>\n"));
}

/* This is TC_CONS_FIX_NEW, called by emit_expr in read.c.  */

void
cons_fix_new_ns32k (fragS *frag,	/* Which frag? */
		    int where,		/* Where in that frag? */
		    int size,		/* 1, 2  or 4 usually.  */
		    expressionS *exp)	/* Expression.  */
{
  fix_new_ns32k_exp (frag, where, size, exp,
		     0, 2, 0, 0, 0, 0);
}

/* We have no need to default values of symbols.  */

symbolS *
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
{
  return 0;
}

/* Round up a section size to the appropriate boundary.  */

valueT
md_section_align (segT segment ATTRIBUTE_UNUSED, valueT size)
{
  return size;			/* Byte alignment is fine.  */
}

/* Exactly what point is a PC-relative offset relative TO?  On the
   ns32k, they're relative to the start of the instruction.  */

long
md_pcrel_from (fixS *fixP)
{
  long res;

  res = fixP->fx_where + fixP->fx_frag->fr_address;
#ifdef SEQUENT_COMPATABILITY
  if (frag_bsr (fixP->fx_frag))
    res += 0x12			/* FOO Kludge alert!  */
#endif
      return res;
}

arelent *
tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS *fixp)
{
  arelent *rel;
  bfd_reloc_code_real_type code;

  code = reloc (fixp->fx_size, fixp->fx_pcrel, fix_im_disp (fixp));

  rel = xmalloc (sizeof (arelent));
  rel->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
  *rel->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  rel->address = fixp->fx_frag->fr_address + fixp->fx_where;
  if (fixp->fx_pcrel)
    rel->addend = fixp->fx_addnumber;
  else
    rel->addend = 0;

  rel->howto = bfd_reloc_type_lookup (stdoutput, code);
  if (!rel->howto)
    {
      const char *name;

      name = S_GET_NAME (fixp->fx_addsy);
      if (name == NULL)
	name = _("<unknown>");
      as_fatal (_("Cannot find relocation type for symbol %s, code %d"),
		name, (int) code);
    }

  return rel;
}
@


1.33
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d1899 1
a1899 1
  const char *stat;
d1907 1
a1907 1
      if ((stat = hash_insert (inst_hash_handle, ptr->name, (char *) ptr)))
d1909 1
a1909 1
	as_fatal (_("Can't hash %s: %s"), ptr->name, stat);
@


1.32
log
@update copyright dates
@
text
@d378 1
a378 1
	   addr_modeS *addr_modeP,
d388 10
a397 10
  addr_modeP->scaled_mode = 0;	/* Why not.  */
  addr_modeP->scaled_reg = 0;	/* If 0, not scaled index.  */
  addr_modeP->float_flag = 0;
  addr_modeP->am_size = 0;
  addr_modeP->im_disp = 0;
  addr_modeP->pcrel = 0;	/* Not set in this function.  */
  addr_modeP->disp_suffix[0] = 0;
  addr_modeP->disp_suffix[1] = 0;
  addr_modeP->disp[0] = NULL;
  addr_modeP->disp[1] = NULL;
d413 2
a414 2
      addr_modeP->mode = 21;	/* absolute */
      addr_modeP->disp[0] = str + 1;
d421 2
a422 2
      addr_modeP->mode = 20;	/* immediate */
      addr_modeP->disp[0] = str + 1;
d434 2
a435 2
		  addr_modeP->mode = 27;	/* pc-relative */
		  addr_modeP->disp[0] = str + 2;
d449 1
a449 1
	      addr_modeP->disp[0] = str + 4;
d467 2
a468 2
	      addr_modeP->disp[1] = str + j + 2;
	      addr_modeP->mode = 22;
d486 1
a486 1
	  addr_modeP->float_flag = 1;
d491 1
a491 1
	      addr_modeP->mode = str[1] - '0';
d503 1
a503 1
	  addr_modeP->mode = 23;	/* TopOfStack */
d528 1
a528 1
		  addr_modeP->mode = mode;
d548 2
a549 2
		  addr_modeP->disp[1] = str;
		  addr_modeP->disp[0] = str + strl + 1;
d565 2
a566 2
		  addr_modeP->mode = str[strl - 2] - '0' + 8;
		  addr_modeP->disp[0] = str;
d584 2
a585 2
		  addr_modeP->mode = mode;
		  addr_modeP->disp[0] = str;
d625 1
a625 1
	  addr_modeP->am_size += 1;	/* scaled index byte.  */
d628 1
a628 1
	  i = addr_mode (str, addr_modeP, 1);
d630 1
a630 1
	  if (!i || addr_modeP->mode == 20)
d636 3
a638 3
	  addr_modeP->scaled_mode = addr_modeP->mode;	/* Store the inferior mode.  */
	  addr_modeP->mode = mode;
	  addr_modeP->scaled_reg = j + 1;
d644 2
a645 2
  addr_modeP->mode = DEFAULT;	/* Default to whatever.  */
  addr_modeP->disp[0] = str;
d668 1
a668 1
get_addr_mode (char *ptr, addr_modeS *addr_modeP)
d672 1
a672 1
  addr_mode (ptr, addr_modeP, 0);
d674 1
a674 1
  if (addr_modeP->mode == DEFAULT || addr_modeP->scaled_mode == -1)
d682 1
a682 1
      if (addr_modeP->mode == DEFAULT)
d685 1
a685 1
	    addr_modeP->mode = desc->default_model; /* We have a label.  */
d687 1
a687 1
	    addr_modeP->mode = desc->default_modec; /* We have a constant.  */
d692 1
a692 1
	    addr_modeP->scaled_mode = desc->default_model;
d694 1
a694 1
	    addr_modeP->scaled_mode = desc->default_modec;
d706 1
a706 1
  if ((tmp = addr_modeP->scaled_reg))
d710 3
a712 3
      tmp |= addr_modeP->scaled_mode << 3;
      addr_modeP->index_byte = (char) tmp;
      addr_modeP->am_size += 1;
d715 2
a716 2
  gas_assert (addr_modeP->mode >= 0); 
  if (disp_test[(unsigned int) addr_modeP->mode])
d726 1
a726 1
      addr_modeP->pcrel = 0;
d728 2
a729 2
      gas_assert (addr_modeP->mode >= 0);
      if (disp_test[(unsigned int) addr_modeP->mode])
d732 1
a732 1
	  if (addr_modeP->mode == 27 || addr_modeP->scaled_mode == 27)
d734 1
a734 1
	    addr_modeP->pcrel = 1;
d736 1
a736 1
	  addr_modeP->im_disp = 1;
d742 1
a742 1
	      if ((toP = addr_modeP->disp[i]))
d781 2
a782 2
		  addr_modeP->disp_suffix[i] = suffix;
		  addr_modeP->am_size += suffix ? suffix : 4;
d789 1
a789 1
      if (addr_modeP->mode == 20)
d792 2
a793 2
	  addr_modeP->disp_suffix[0] = addr_modeP->am_size = desc->im_size;
	  addr_modeP->im_disp = 0;
d797 1
a797 1
  return addr_modeP->mode;
d1249 1
a1249 1
  int length, index;
d1292 1
a1292 1
  index = length + 3 * pcrel + 6 * type;
d1294 2
a1295 2
  if (index >= 0 && (unsigned int) index < sizeof (relocs) / sizeof (relocs[0]))
    return relocs[index];
@


1.31
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2005, 2006, 2007
@


1.30
log
@Remove unnecessary casts on obstack_alloc invocations.
@
text
@d715 1
a715 1
  assert (addr_modeP->mode >= 0); 
d728 1
a728 1
      assert(addr_modeP->mode >= 0);
@


1.29
log
@Remove duplicate definitions of the md_atof() function
@
text
@d883 1
a883 1
  bit_fixP = (bit_fixS *) obstack_alloc (&notes, sizeof (bit_fixS));
@


1.28
log
@Switch to GPLv3
@
text
@a1915 3
/* Must be equal to MAX_PRECISON in atof-ieee.c.  */
#define MAX_LITTLENUMS 6

d1924 1
a1924 32
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  char *t;

  switch (type)
    {
    case 'f':
      prec = 2;
      break;

    case 'd':
      prec = 4;
      break;
    default:
      *sizeP = 0;
      return _("Bad call to MD_ATOF()");
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizeP = prec * sizeof (LITTLENUM_TYPE);

  for (wordP = words + prec; prec--;)
    {
      md_number_to_chars (litP, (long) (*--wordP), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }

  return 0;
@


1.27
log
@	* ecoff.c (ecoff_directive_val): Fix message typo.
	* config/tc-ns32k.c (convert_iif): Likewise.
	* config/tc-sh64.c (shmedia_check_limits): Likewise.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2005, 2006
d10 1
a10 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.26
log
@remove some duplicate #include's.
@
text
@d1864 1
a1864 1
				as_bad (_("Displacement to large for :d"));
@


1.25
log
@	* README-vms: Delete.
	* config-gas.com: Delete.
	* makefile.vms: Delete.
	* vmsconf.sh: Delete.
	* config/atof-tahoe.c: Delete.
	* config/m88k-opcode.h: Delete.
	* config/obj-bout.c: Delete.
	* config/obj-bout.h: Delete.
	* config/obj-hp300.c: Delete.
	* config/obj-hp300.h: Delete.
	* config/tc-a29k.c: Delete.
	* config/tc-a29k.h: Delete.
	* config/tc-h8500.c: Delete.
	* config/tc-h8500.h: Delete.
	* config/tc-m88k.c: Delete.
	* config/tc-m88k.h: Delete.
	* config/tc-tahoe.c: Delete.
	* config/tc-tahoe.h: Delete.
	* config/tc-tic80.c: Delete.
	* config/tc-tic80.h: Delete.
	* config/tc-w65.c: Delete.
	* config/tc-w65.h: Delete.
	* config/te-aux.h: Delete.
	* config/te-delt88.h: Delete.
	* config/te-delta.h: Delete.
	* config/te-dpx2.h: Delete.
	* config/te-hp300.h: Delete.
	* config/te-ic960.h: Delete.
	* config/vms-a-conf.h: Delete.
	* doc/c-a29k.texi: Delete.
	* doc/c-h8500.texi: Delete.
	* doc/c-m88k.texi: Delete.
	* README: Remove obsolete examples, and list of supported targets.
	* Makefile.am: Remove a29k, h8500, m88k, tahoe, tic80, w65,
	bout and hp300 support.
	(DEP_FLAGS): Don't define BFD_ASSEMBLER.
	* configure.in: Remove --enable-bfd-assembler, need_bfd,
	primary_bfd_gas.
	* configure.tgt: Remove a29k, h8300-coff, h8500-*, i960 non-elf,
	m68k non bfd, m88k, or32-coff, tic80-*, vax non-bfd, w65k-*, *-nindy.
	* as.c: Remove all non-BFD_ASSEMBLER code, support for above targets.
	* as.h: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
	* input-file.c: Likewise.
	* listing.c: Likewise.
	* literal.c: Likewise.
	* messages.c: Likewise.
	* obj.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* stabs.c: Likewise.
	* struc-symbol.h: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* symbols.c: Likewise.
	* symbols.h: Likewise.
	* tc.h: Likewise.
	* write.c: Likewise.
	* write.h: Likewise.
	* config/aout_gnu.h: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-aout.h: Likewise.
	* config/obj-coff.c: Likewise.
	* config/obj-coff.h: Likewise.
	* config/obj-evax.h: Likewise.
	* config/obj-ieee.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-crx.h: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-d30v.h: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-fr30.h: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-hppa.h: Likewise.
	* config/tc-i370.h: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i860.h: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ip2k.h: Likewise.
	* config/tc-iq2000.h: Likewise.
	* config/tc-m32c.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m68k.h: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-maxq.h: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mn10200.h: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-mn10300.h: Likewise.
	* config/tc-ms1.h: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-msp430.h: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-ns32k.h: Likewise.
	* config/tc-openrisc.h: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.h: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic4x.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-vax.h: Likewise.
	* config/tc-xstormy16.h: Likewise.
	* config/tc-xtensa.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-z8k.h: Likewise.
	* config/vms-a-conf.h
	* doc/Makefile.am: Likewise.
	* doc/all.texi: Likewise.
	* doc/as.texinfo: Likewise.
	* doc/Makefile.in: Regenerate.
	* Makefile.in: Regenerate.
	* configure: Regenerate.
	* config.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2005
a24 2
#include <stdio.h>

@


1.24
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@a1245 1
#ifdef BFD_ASSEMBLER
a1308 1
#endif
a1327 1
#ifdef BFD_ASSEMBLER
a1328 3
#else
			NO_RELOC
#endif
a1355 1
#ifdef BFD_ASSEMBLER
a1356 3
#else
			    NO_RELOC
#endif
a2039 6
#ifndef BFD_ASSEMBLER
void
md_convert_frag (object_headers *headers,
		 segT sec,
		 fragS *fragP)
#else
a2043 1
#endif
a2122 1
const int md_reloc_size = 8;	/* Size of relocation record.  */
a2259 2
#ifdef BFD_ASSEMBLER

a2290 36
#else /* BFD_ASSEMBLER */

#ifdef OBJ_AOUT
void
cons_fix_new_ns32k (char *where,
		    struct fix *fixP,
		    relax_addressT segment_address_in_file)
{
  /* In:  Length of relocation (or of address) in chars: 1, 2 or 4.
     Out: GNU LD relocation length code: 0, 1, or 2.  */

  static unsigned char nbytes_r_length[] = { 42, 0, 1, 42, 2 };
  long r_symbolnum;

  know (fixP->fx_addsy != NULL);

  md_number_to_chars (where,
       fixP->fx_frag->fr_address + fixP->fx_where - segment_address_in_file,
		      4);

  r_symbolnum = (S_IS_DEFINED (fixP->fx_addsy)
		 ? S_GET_TYPE (fixP->fx_addsy)
		 : fixP->fx_addsy->sy_number);

  md_number_to_chars (where + 4,
		      ((long) (r_symbolnum)
		       | (long) (fixP->fx_pcrel << 24)
		       | (long) (nbytes_r_length[fixP->fx_size] << 25)
		       | (long) ((!S_IS_DEFINED (fixP->fx_addsy)) << 27)
		       | (long) (fix_bsr (fixP) << 28)
		       | (long) (fix_im_disp (fixP) << 29)),
		      4);
}

#endif /* OBJ_AOUT */
#endif /* BFD_ASSEMBLER */
@


1.23
log
@Update the address and phone number of the FSF
@
text
@d2015 1
a2015 1
md_apply_fix3 (fixS *fixP, valueT * valP, segT seg ATTRIBUTE_UNUSED)
@


1.22
log
@Convert unmaintained files over to ISO-C90 and fix formatting.
@
text
@d20 2
a21 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.21
log
@update copyright dates
@
text
@d41 11
a51 11
    iif.iifP[ptr].type= a1;				\
    iif.iifP[ptr].size= c1;				\
    iif.iifP[ptr].object= e1;				\
    iif.iifP[ptr].object_adjust= g1;			\
    iif.iifP[ptr].pcrel= i1;				\
    iif.iifP[ptr].pcrel_adjust= k1;			\
    iif.iifP[ptr].im_disp= m1;				\
    iif.iifP[ptr].relax_substate= o1;			\
    iif.iifP[ptr].bit_fixP= q1;				\
    iif.iifP[ptr].addr_mode= s1;			\
    iif.iifP[ptr].bsr= u1;
d73 5
a77 5
  {
    signed char mode;		/* Addressing mode of operand (0-31).  */
    signed char scaled_mode;	/* Mode combined with scaled mode.  */
    char scaled_reg;		/* Register used in scaled+1 (1-8).  */
    char float_flag;		/* Set if R0..R7 was F0..F7 ie a
d79 1
a79 1
    char am_size;		/* Estimated max size of general addr-mode
d81 4
a84 4
    char im_disp;		/* If im_disp==1 we have a displacement.  */
    char pcrel;			/* 1 if pcrel, this is really redundant info.  */
    char disp_suffix[2];	/* Length of displacement(s), 0=undefined.  */
    char *disp[2];		/* Pointer(s) at displacement(s)
d86 2
a87 2
    char index_byte;		/* Index byte.  */
  };
d115 7
a121 7
  {
    int type;			/* How to interpret object.  */
    int size;			/* Estimated max size of object.  */
    unsigned long object;	/* Binary data.  */
    int object_adjust;		/* Number added to object.  */
    int pcrel;			/* True if object is pcrel.  */
    int pcrel_adjust;		/* Length in bytes from the instruction
d123 4
a126 4
    int im_disp;		/* True if the object is a displacement.  */
    relax_substateT relax_substate;	/* Initial relaxsubstate.  */
    bit_fixS *bit_fixP;		/* Pointer at bit_fix struct.  */
    int addr_mode;		/* What addrmode do we associate with this
d128 2
a129 2
    char bsr;			/* Sequent hack.  */
  } iif_entryT;			/* Internal Instruction Format.  */
d132 4
a135 4
  {
    int instr_size;		/* Max size of instruction in bytes.  */
    iif_entryT iifP[IIF_ENTRIES + 1];
  };
a369 5
static void evaluate_expr PARAMS ((expressionS * resultP, char *));
static void md_number_to_disp PARAMS ((char *, long, int));
static void md_number_to_imm PARAMS ((char *, long, int));
static void md_number_to_field PARAMS ((char *, long, bit_fixS *));

a377 2
static int addr_mode PARAMS ((char *, addr_modeS *, int));

d379 3
a381 4
addr_mode (operand, addr_modeP, recursive_level)
     char *operand;
     addr_modeS *addr_modeP;
     int recursive_level;
d652 11
a668 1
static int get_addr_mode PARAMS ((char *, addr_modeS *));
d670 1
a670 3
get_addr_mode (ptr, addr_modeP)
     char *ptr;
     addr_modeS *addr_modeP;
a803 1
static void optlist PARAMS ((char *, struct ns32k_option *, unsigned long *));
d805 3
a807 4
optlist (str, optionP, default_map)
     char *str;			/* The string to extract options from.  */
     struct ns32k_option *optionP;	/* How to search the string.  */
     unsigned long *default_map;	/* Default pattern and output.  */
a845 2
static int list_search PARAMS ((char *, struct ns32k_option *, unsigned long *));

d847 3
a849 4
list_search (str, optionP, default_map)
     char *str;				/* The string to match.  */
     struct ns32k_option *optionP;	/* List to search.  */
     unsigned long *default_map;	/* Default pattern and output.  */
d868 5
d874 8
a881 4
static void
evaluate_expr (resultP, ptr)
     expressionS *resultP;
     char *ptr;
d883 11
a893 1
  char *tmp_line;
d895 1
a895 4
  tmp_line = input_line_pointer;
  input_line_pointer = ptr;
  expression (resultP);
  input_line_pointer = tmp_line;
d897 1
a897 1

a903 3
static void encode_operand
  PARAMS ((int, char **, const char *, const char *, char, char));

d905 6
a910 7
encode_operand (argc, argv, operandsP, suffixP, im_size, opcode_bit_ptr)
     int argc;
     char **argv;
     const char *operandsP;
     const char *suffixP;
     char im_size ATTRIBUTE_UNUSED;
     char opcode_bit_ptr;
a1088 2
static int parse PARAMS ((const char *, int));

d1090 1
a1090 3
parse (line, recursive_level)
     const char *line;
     int recursive_level;
d1115 1
a1115 3
    {
      lineptr = line;
    }
d1212 1
a1212 3
		{
		  as_fatal (_("Too many operands passed to instruction"));
		}
d1227 1
a1227 3
	{
	  as_fatal (_("Wrong number of operands"));
	}
d1240 3
a1242 8
    {
      encode_operand (argc,
		      argv,
		      &desc->operands[0],
		      &suffix[0],
		      desc->im_size,
		      desc->opcode_size);
    }
d1246 2
a1247 8
/* Convert iif to fragments.  From this point we start to dribble with
   functions in other files than this one.(Except hash.c) So, if it's
   possible to make an iif for an other CPU, you don't need to know
   what frags, relax, obstacks, etc is in order to port this
   assembler. You only need to know if it's possible to reduce your
   cpu-instruction to iif-format (takes some work) and adopt the other
   md_? parts according to given instructions Note that iif was
   invented for the clean ns32k`s architecture.  */
d1249 12
a1260 14
/* GAS for the ns32k has a problem. PC relative displacements are
   relative to the address of the opcode, not the address of the
   operand. We used to keep track of the offset between the operand
   and the opcode in pcrel_adjust for each frag and each fix. However,
   we get into trouble where there are two or more pc-relative
   operands and the size of the first one can't be determined. Then in
   the relax phase, the size of the first operand will change and
   pcrel_adjust will no longer be correct.  The current solution is
   keep a pointer to the frag with the opcode in it and the offset in
   that frag for each frag and each fix. Then, when needed, we can
   always figure out how far it is between the opcode and the pcrel
   object.  See also md_pcrel_adjust and md_fix_pcrel_adjust.  For
   objects not part of an instruction, the pointer to the opcode frag
   is always zero.  */
d1262 7
a1268 14
static void convert_iif PARAMS ((void));
static void
convert_iif ()
{
  int i;
  bit_fixS *j;
  fragS *inst_frag;
  unsigned int inst_offset;
  char *inst_opcode;
  char *memP;
  int l;
  int k;
  char type;
  char size = 0;
d1270 8
a1277 5
  frag_grow (iif.instr_size);	/* This is important.  */
  memP = frag_more (0);
  inst_opcode = memP;
  inst_offset = (memP - frag_now->fr_literal);
  inst_frag = frag_now;
d1279 1
a1279 1
  for (i = 0; i < IIF_ENTRIES; i++)
d1281 25
a1305 12
      if ((type = iif.iifP[i].type))
	{
	  /* The object exist, so handle it.  */
	  switch (size = iif.iifP[i].size)
	    {
	    case 42:
	      size = 0;
	      /* It's a bitfix that operates on an existing object.  */
	      if (iif.iifP[i].bit_fixP->fx_bit_base)
		/* Expand fx_bit_base to point at opcode.  */
		iif.iifP[i].bit_fixP->fx_bit_base = (long) inst_opcode;
	      /* Fall through.  */
d1307 1
a1307 8
	    case 8:		/* bignum or doublefloat.  */
	    case 1:
	    case 2:
	    case 3:
	    case 4:
	      /* The final size in objectmemory is known.  */
	      memP = frag_more (size);
	      j = iif.iifP[i].bit_fixP;
d1309 2
a1310 36
	      switch (type)
		{
		case 1:	/* The object is pure binary.  */
		  if (j)
		    {
		      md_number_to_field(memP, exprP.X_add_number, j);
		    }
		  else if (iif.iifP[i].pcrel)
		    {
		      fix_new_ns32k (frag_now,
				     (long) (memP - frag_now->fr_literal),
				     size,
				     0,
				     iif.iifP[i].object,
				     iif.iifP[i].pcrel,
				     iif.iifP[i].im_disp,
				     0,
				     iif.iifP[i].bsr,	/* Sequent hack.  */
				     inst_frag, inst_offset);
		    }
		  else
		    {
		      /* Good, just put them bytes out.  */
		      switch (iif.iifP[i].im_disp)
			{
			case 0:
			  md_number_to_chars (memP, iif.iifP[i].object, size);
			  break;
			case 1:
			  md_number_to_disp (memP, iif.iifP[i].object, size);
			  break;
			default:
			  as_fatal (_("iif convert internal pcrel/binary"));
			}
		    }
		  break;
d1312 24
a1335 13
		case 2:
		  /* The object is a pointer at an expression, so
                     unpack it, note that bignums may result from the
                     expression.  */
		  evaluate_expr (&exprP, (char *) iif.iifP[i].object);
		  if (exprP.X_op == O_big || size == 8)
		    {
		      if ((k = exprP.X_add_number) > 0)
			{
			  /* We have a bignum ie a quad. This can only
                             happens in a long suffixed instruction.  */
			  if (k * 2 > size)
			    as_bad (_("Bignum too big for long"));
d1337 8
a1344 2
			  if (k == 3)
			    memP += 2;
d1346 385
a1730 9
			  for (l = 0; k > 0; k--, l += 2)
			    md_number_to_chars (memP + l,
						generic_bignum[l >> 1],
						sizeof (LITTLENUM_TYPE));
			}
		      else
			{
			  /* flonum.  */
			  LITTLENUM_TYPE words[4];
d1781 1
a1781 3
		    {
		      md_number_to_field(memP, exprP.X_add_number, j);
		    }
d1834 2
a1835 4
		      {
			/* We cant relax this case.  */
			as_fatal (_("Can't relax difference"));
		      }
d1863 1
a1863 3
		      {
			size = 1;
		      }
d1868 1
a1868 3
			  {
			    size = 2;
			  }
d1873 1
a1873 3
			      {
				size = 4;
			      }
a1894 65
#ifdef BFD_ASSEMBLER
/* This functionality should really be in the bfd library.  */
static bfd_reloc_code_real_type
reloc (int size, int pcrel, int type)
{
  int length, index;
  bfd_reloc_code_real_type relocs[] =
  {
    BFD_RELOC_NS32K_IMM_8,
    BFD_RELOC_NS32K_IMM_16,
    BFD_RELOC_NS32K_IMM_32,
    BFD_RELOC_NS32K_IMM_8_PCREL,
    BFD_RELOC_NS32K_IMM_16_PCREL,
    BFD_RELOC_NS32K_IMM_32_PCREL,

    /* ns32k displacements.  */
    BFD_RELOC_NS32K_DISP_8,
    BFD_RELOC_NS32K_DISP_16,
    BFD_RELOC_NS32K_DISP_32,
    BFD_RELOC_NS32K_DISP_8_PCREL,
    BFD_RELOC_NS32K_DISP_16_PCREL,
    BFD_RELOC_NS32K_DISP_32_PCREL,

    /* Normal 2's complement.  */
    BFD_RELOC_8,
    BFD_RELOC_16,
    BFD_RELOC_32,
    BFD_RELOC_8_PCREL,
    BFD_RELOC_16_PCREL,
    BFD_RELOC_32_PCREL
  };

  switch (size)
    {
    case 1:
      length = 0;
      break;
    case 2:
      length = 1;
      break;
    case 4:
      length = 2;
      break;
    default:
      length = -1;
      break;
    }

  index = length + 3 * pcrel + 6 * type;

  if (index >= 0 && (unsigned int) index < sizeof (relocs) / sizeof (relocs[0]))
    return relocs[index];

  if (pcrel)
    as_bad (_("Can not do %d byte pc-relative relocation for storage type %d"),
	    size, type);
  else
    as_bad (_("Can not do %d byte relocation for storage type %d"),
	    size, type);

  return BFD_RELOC_NONE;

}
#endif

d1896 1
a1896 2
md_assemble (line)
     char *line;
d1902 1
a1902 146
  printf (" \t\t\t%s\n", line);
#endif
}

void
md_begin ()
{
  /* Build a hashtable of the instructions.  */
  const struct ns32k_opcode *ptr;
  const char *stat;
  const struct ns32k_opcode *endop;

  inst_hash_handle = hash_new ();

  endop = ns32k_opcodes + sizeof (ns32k_opcodes) / sizeof (ns32k_opcodes[0]);
  for (ptr = ns32k_opcodes; ptr < endop; ptr++)
    {
      if ((stat = hash_insert (inst_hash_handle, ptr->name, (char *) ptr)))
	/* Fatal.  */
	as_fatal (_("Can't hash %s: %s"), ptr->name, stat);
    }

  /* Some private space please!  */
  freeptr_static = (char *) malloc (PRIVATE_SIZE);
}

/* Must be equal to MAX_PRECISON in atof-ieee.c.  */
#define MAX_LITTLENUMS 6

/* Turn the string pointed to by litP into a floating point constant
   of type TYPE, and emit the appropriate bytes.  The number of
   LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */

char *
md_atof (type, litP, sizeP)
     char type;
     char *litP;
     int *sizeP;
{
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *wordP;
  char *t;

  switch (type)
    {
    case 'f':
      prec = 2;
      break;

    case 'd':
      prec = 4;
      break;
    default:
      *sizeP = 0;
      return _("Bad call to MD_ATOF()");
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizeP = prec * sizeof (LITTLENUM_TYPE);

  for (wordP = words + prec; prec--;)
    {
      md_number_to_chars (litP, (long) (*--wordP), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }

  return 0;
}

/* Convert number to chars in correct order.  */

void
md_number_to_chars (buf, value, nbytes)
     char *buf;
     valueT value;
     int nbytes;
{
  number_to_chars_littleendian (buf, value, nbytes);
}

/* This is a variant of md_numbers_to_chars. The reason for its'
   existence is the fact that ns32k uses Huffman coded
   displacements. This implies that the bit order is reversed in
   displacements and that they are prefixed with a size-tag.

   binary: msb -> lsb
   0xxxxxxx				byte
   10xxxxxx xxxxxxxx			word
   11xxxxxx xxxxxxxx xxxxxxxx xxxxxxxx	double word

   This must be taken care of and we do it here!  */

static void
md_number_to_disp (buf, val, n)
     char *buf;
     long val;
     char n;
{
  switch (n)
    {
    case 1:
      if (val < -64 || val > 63)
	as_bad (_("value of %ld out of byte displacement range."), val);
      val &= 0x7f;
#ifdef SHOW_NUM
      printf ("%x ", val & 0xff);
#endif
      *buf++ = val;
      break;
    case 2:
      if (val < -8192 || val > 8191)
	as_bad (_("value of %ld out of word displacement range."), val);
      val &= 0x3fff;
      val |= 0x8000;
#ifdef SHOW_NUM
      printf ("%x ", val >> 8 & 0xff);
#endif
      *buf++ = (val >> 8);
#ifdef SHOW_NUM
      printf ("%x ", val & 0xff);
#endif
      *buf++ = val;
      break;
    case 4:
      if (val < -0x20000000 || val >= 0x20000000)
	as_bad (_("value of %ld out of double word displacement range."), val);
      val |= 0xc0000000;
#ifdef SHOW_NUM
      printf ("%x ", val >> 24 & 0xff);
#endif
      *buf++ = (val >> 24);
#ifdef SHOW_NUM
      printf ("%x ", val >> 16 & 0xff);
#endif
      *buf++ = (val >> 16);
#ifdef SHOW_NUM
      printf ("%x ", val >> 8 & 0xff);
#endif
      *buf++ = (val >> 8);
#ifdef SHOW_NUM
      printf ("%x ", val & 0xff);
a1903 6
      *buf++ = val;
      break;
    default:
      as_fatal (_("Internal logic error.  line %d, file \"%s\""),
		__LINE__, __FILE__);
    }
d1906 2
a1907 5
static void
md_number_to_imm (buf, val, n)
     char *buf;
     long val;
     char n;
d1909 9
a1917 1
  switch (n)
d1919 3
a1921 37
    case 1:
#ifdef SHOW_NUM
      printf ("%x ", val & 0xff);
#endif
      *buf++ = val;
      break;
    case 2:
#ifdef SHOW_NUM
      printf ("%x ", val >> 8 & 0xff);
#endif
      *buf++ = (val >> 8);
#ifdef SHOW_NUM
      printf ("%x ", val & 0xff);
#endif
      *buf++ = val;
      break;
    case 4:
#ifdef SHOW_NUM
      printf ("%x ", val >> 24 & 0xff);
#endif
      *buf++ = (val >> 24);
#ifdef SHOW_NUM
      printf ("%x ", val >> 16 & 0xff);
#endif
      *buf++ = (val >> 16);
#ifdef SHOW_NUM
      printf ("%x ", val >> 8 & 0xff);
#endif
      *buf++ = (val >> 8);
#ifdef SHOW_NUM
      printf ("%x ", val & 0xff);
#endif
      *buf++ = val;
      break;
    default:
      as_fatal (_("Internal logic error. line %d, file \"%s\""),
		__LINE__, __FILE__);
d1923 3
d1928 2
a1929 2
/* Fast bitfiddling support.  */
/* Mask used to zero bitfield before oring in the true field.  */
d1931 4
a1934 28
static unsigned long l_mask[] =
{
  0xffffffff, 0xfffffffe, 0xfffffffc, 0xfffffff8,
  0xfffffff0, 0xffffffe0, 0xffffffc0, 0xffffff80,
  0xffffff00, 0xfffffe00, 0xfffffc00, 0xfffff800,
  0xfffff000, 0xffffe000, 0xffffc000, 0xffff8000,
  0xffff0000, 0xfffe0000, 0xfffc0000, 0xfff80000,
  0xfff00000, 0xffe00000, 0xffc00000, 0xff800000,
  0xff000000, 0xfe000000, 0xfc000000, 0xf8000000,
  0xf0000000, 0xe0000000, 0xc0000000, 0x80000000,
};
static unsigned long r_mask[] =
{
  0x00000000, 0x00000001, 0x00000003, 0x00000007,
  0x0000000f, 0x0000001f, 0x0000003f, 0x0000007f,
  0x000000ff, 0x000001ff, 0x000003ff, 0x000007ff,
  0x00000fff, 0x00001fff, 0x00003fff, 0x00007fff,
  0x0000ffff, 0x0001ffff, 0x0003ffff, 0x0007ffff,
  0x000fffff, 0x001fffff, 0x003fffff, 0x007fffff,
  0x00ffffff, 0x01ffffff, 0x03ffffff, 0x07ffffff,
  0x0fffffff, 0x1fffffff, 0x3fffffff, 0x7fffffff,
};
#define MASK_BITS 31
/* Insert bitfield described by field_ptr and val at buf
   This routine is written for modification of the first 4 bytes pointed
   to by buf, to yield speed.
   The ifdef stuff is for selection between a ns32k-dependent routine
   and a general version. (My advice: use the general version!).  */
d1936 2
a1937 5
static void
md_number_to_field (buf, val, field_ptr)
     char *buf;
     long val;
     bit_fixS *field_ptr;
d1939 4
a1942 8
  unsigned long object;
  unsigned long mask;
  /* Define ENDIAN on a ns32k machine.  */
#ifdef ENDIAN
  unsigned long *mem_ptr;
#else
  char *mem_ptr;
#endif
d1944 1
a1944 1
  if (field_ptr->fx_bit_min <= val && val <= field_ptr->fx_bit_max)
d1946 15
a1960 6
#ifdef ENDIAN
      if (field_ptr->fx_bit_base)
	/* Override buf.  */
	mem_ptr = (unsigned long *) field_ptr->fx_bit_base;
      else
	mem_ptr = (unsigned long *) buf;
d1962 1
a1962 7
      mem_ptr = ((unsigned long *)
		 ((char *) mem_ptr + field_ptr->fx_bit_base_adj));
#else
      if (field_ptr->fx_bit_base)
	mem_ptr = (char *) field_ptr->fx_bit_base;
      else
	mem_ptr = buf;
d1964 1
a1964 35
      mem_ptr += field_ptr->fx_bit_base_adj;
#endif
#ifdef ENDIAN
      /* We have a nice ns32k machine with lowbyte at low-physical mem.  */
      object = *mem_ptr;	/* get some bytes */
#else /* OVE Goof! the machine is a m68k or dito.  */
      /* That takes more byte fiddling.  */
      object = 0;
      object |= mem_ptr[3] & 0xff;
      object <<= 8;
      object |= mem_ptr[2] & 0xff;
      object <<= 8;
      object |= mem_ptr[1] & 0xff;
      object <<= 8;
      object |= mem_ptr[0] & 0xff;
#endif
      mask = 0;
      mask |= (r_mask[field_ptr->fx_bit_offset]);
      mask |= (l_mask[field_ptr->fx_bit_offset + field_ptr->fx_bit_size]);
      object &= mask;
      val += field_ptr->fx_bit_add;
      object |= ((val << field_ptr->fx_bit_offset) & (mask ^ 0xffffffff));
#ifdef ENDIAN
      *mem_ptr = object;
#else
      mem_ptr[0] = (char) object;
      object >>= 8;
      mem_ptr[1] = (char) object;
      object >>= 8;
      mem_ptr[2] = (char) object;
      object >>= 8;
      mem_ptr[3] = (char) object;
#endif
    }
  else
d1966 2
a1967 1
      as_bad (_("Bit field out of range"));
d1969 2
d1972 1
a1972 1

d1974 1
a1974 2
md_pcrel_adjust (fragP)
     fragS *fragP;
a1989 1
static int md_fix_pcrel_adjust PARAMS ((fixS *fixP));
d1991 1
a1991 2
md_fix_pcrel_adjust (fixP)
     fixS *fixP;
d2015 1
a2015 4
md_apply_fix3 (fixP, valP, seg)
     fixS *fixP;
     valueT * valP;
     segT seg ATTRIBUTE_UNUSED;
d2021 2
a2022 4
    {
      /* Bitfields to fix, sigh.  */
      md_number_to_field (buf, val, fix_bit_fixP (fixP));
    }
d2052 3
a2054 4
md_convert_frag (headers, sec, fragP)
     object_headers *headers;
     segT sec;
     fragS *fragP;
d2057 3
a2059 4
md_convert_frag (abfd, sec, fragP)
     bfd *abfd ATTRIBUTE_UNUSED;
     segT sec ATTRIBUTE_UNUSED;
     fragS *fragP;
d2102 1
a2102 3
md_estimate_size_before_relax (fragP, segment)
     fragS *fragP;
     segT segment;
d2143 5
a2147 5
md_create_short_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr;
     addressT from_addr, to_addr;
     fragS *frag ATTRIBUTE_UNUSED;
     symbolS *to_symbol ATTRIBUTE_UNUSED;
d2157 5
a2161 5
md_create_long_jump (ptr, from_addr, to_addr, frag, to_symbol)
     char *ptr;
     addressT from_addr, to_addr;
     fragS *frag ATTRIBUTE_UNUSED;
     symbolS *to_symbol ATTRIBUTE_UNUSED;
d2182 1
a2182 3
md_parse_option (c, arg)
     int c;
     char *arg;
d2226 1
a2226 2
md_show_usage (stream)
     FILE *stream;
a2233 100
/* Create a bit_fixS in obstack 'notes'.
   This struct is used to profile the normal fix. If the bit_fixP is a
   valid pointer (not NULL) the bit_fix data will be used to format
   the fix.  */

bit_fixS *
bit_fix_new (size, offset, min, max, add, base_type, base_adj)
     char size;			/* Length of bitfield.  */
     char offset;		/* Bit offset to bitfield.  */
     long min;			/* Signextended min for bitfield.  */
     long max;			/* Signextended max for bitfield.  */
     long add;			/* Add mask, used for huffman prefix.  */
     long base_type;		/* 0 or 1, if 1 it's exploded to opcode ptr.  */
     long base_adj;
{
  bit_fixS *bit_fixP;

  bit_fixP = (bit_fixS *) obstack_alloc (&notes, sizeof (bit_fixS));

  bit_fixP->fx_bit_size = size;
  bit_fixP->fx_bit_offset = offset;
  bit_fixP->fx_bit_base = base_type;
  bit_fixP->fx_bit_base_adj = base_adj;
  bit_fixP->fx_bit_max = max;
  bit_fixP->fx_bit_min = min;
  bit_fixP->fx_bit_add = add;

  return bit_fixP;
}

void
fix_new_ns32k (frag, where, size, add_symbol, offset, pcrel,
	       im_disp, bit_fixP, bsr, opcode_frag, opcode_offset)
     fragS *frag;		/* Which frag? */
     int where;			/* Where in that frag? */
     int size;			/* 1, 2  or 4 usually.  */
     symbolS *add_symbol;	/* X_add_symbol.  */
     long offset;		/* X_add_number.  */
     int pcrel;			/* True if PC-relative relocation.  */
     char im_disp;		/* True if the value to write is a
				   displacement.  */
     bit_fixS *bit_fixP;	/* Pointer at struct of bit_fix's, ignored if
				   NULL.  */
     char bsr;			/* Sequent-linker-hack: 1 when relocobject is
				   a bsr.  */
     fragS *opcode_frag;
     unsigned int opcode_offset;
{
  fixS *fixP = fix_new (frag, where, size, add_symbol,
			offset, pcrel,
#ifdef BFD_ASSEMBLER
			bit_fixP ? NO_RELOC : reloc (size, pcrel, im_disp)
#else
			NO_RELOC
#endif
			);

  fix_opcode_frag (fixP) = opcode_frag;
  fix_opcode_offset (fixP) = opcode_offset;
  fix_im_disp (fixP) = im_disp;
  fix_bsr (fixP) = bsr;
  fix_bit_fixP (fixP) = bit_fixP;
  /* We have a MD overflow check for displacements.  */
  fixP->fx_no_overflow = (im_disp != 0);
}

void
fix_new_ns32k_exp (frag, where, size, exp, pcrel,
		   im_disp, bit_fixP, bsr, opcode_frag, opcode_offset)
     fragS *frag;		/* Which frag? */
     int where;			/* Where in that frag? */
     int size;			/* 1, 2  or 4 usually.  */
     expressionS *exp;		/* Expression.  */
     int pcrel;			/* True if PC-relative relocation.  */
     char im_disp;		/* True if the value to write is a
				   displacement.  */
     bit_fixS *bit_fixP;	/* Pointer at struct of bit_fix's, ignored if
				   NULL.  */
     char bsr;			/* Sequent-linker-hack: 1 when relocobject is
				   a bsr.  */
     fragS *opcode_frag;
     unsigned int opcode_offset;
{
  fixS *fixP = fix_new_exp (frag, where, size, exp, pcrel,
#ifdef BFD_ASSEMBLER
			    bit_fixP ? NO_RELOC : reloc (size, pcrel, im_disp)
#else
			    NO_RELOC
#endif
			    );

  fix_opcode_frag (fixP) = opcode_frag;
  fix_opcode_offset (fixP) = opcode_offset;
  fix_im_disp (fixP) = im_disp;
  fix_bsr (fixP) = bsr;
  fix_bit_fixP (fixP) = bit_fixP;
  /* We have a MD overflow check for displacements.  */
  fixP->fx_no_overflow = (im_disp != 0);
}

d2237 4
a2240 5
cons_fix_new_ns32k (frag, where, size, exp)
     fragS *frag;		/* Which frag? */
     int where;			/* Where in that frag? */
     int size;			/* 1, 2  or 4 usually.  */
     expressionS *exp;		/* Expression.  */
d2249 1
a2249 2
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
d2257 1
a2257 3
md_section_align (segment, size)
     segT segment ATTRIBUTE_UNUSED;
     valueT size;
d2266 1
a2266 2
md_pcrel_from (fixP)
     fixS *fixP;
d2281 1
a2281 3
tc_gen_reloc (section, fixp)
     asection *section ATTRIBUTE_UNUSED;
     fixS *fixp;
d2288 2
a2289 2
  rel = (arelent *) xmalloc (sizeof (arelent));
  rel->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
d2315 3
a2317 4
cons_fix_new_ns32k (where, fixP, segment_address_in_file)
     char *where;
     struct fix *fixP;
     relax_addressT segment_address_in_file;
@


1.20
log
@	* config/atof-ieee.c, config/obj-coff.c, config/obj-elf.c,
	config/obj-ieee.c, config/obj-som.c, config/obj-vms.c,
	config/tc-a29k.c, config/tc-alpha.c, config/tc-arc.c,
	config/tc-arm.c, config/tc-d30v.c, config/tc-dlx.c,
	config/tc-fr30.c, config/tc-h8300.c, config/tc-h8500.c,
	config/tc-i370.c, config/tc-i386.c, config/tc-i960.c,
	config/tc-ia64.c, config/tc-m32r.c, config/tc-m32r.h,
	config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-mips.c,
	config/tc-mn10200.c, config/tc-msp430.c, config/tc-ns32k.c,
	config/tc-openrisc.c, config/tc-or32.c, config/tc-pdp11.c,
	config/tc-pj.c, config/tc-sparc.h, config/tc-tic54x.c,
	config/tc-tic80.c, config/tc-v850.c, config/tc-w65.c,
	config/tc-xtensa.c, config/tc-z8k.c, config/xtensa-relax.c: Remove
	#if 0'd code throughout.
@
text
@d3 1
a3 1
   2001, 2002
@


1.19
log
@	* config/tc-a29k.h: Fix comment typos.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-m32r.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
@
text
@a2100 3
#if 0
	  fragP->fr_opcode[1] = 0xff;
#endif
@


1.18
log
@* config/tc-ns32k.c (md_begin): Initialize inst_hash_table after
all locals have been declared.
@
text
@d179 1
a179 1
   The low-order-byte coresponds to low physical memory.
d335 1
a335 1
   The ns32k uses the begining of the instruction as displacement
d444 1
a444 1
		  addr_modeP->mode = 27;	/* pc-relativ */
d678 1
a678 1
      /* Resolve ambigious operands, this shouldn't be necessary if
d680 1
a680 1
	 compiler doesn't!!!  This finds a proper addressinging mode
d891 1
a891 1
   Be carefull not to put to objects in the same iif-slot.  */
d982 1
a982 1
	  pcrel -= 1;		/* Make pcrel 0 inspite of what case 'p':
d1261 1
a1261 1
   invented for the clean ns32k`s architecure.  */
d2439 1
a2439 1
#endif /* BFD_ASSMEBLER */
@


1.17
log
@	* config/tc-ns32k.c (encode_operand): Constify operandsP and suffixP.
	(parse): Constify line and lineptr.
	(md_begin): Calculate endop here.
@
text
@d1643 2
a1645 1
  const struct ns32k_opcode *endop;
@


1.17.2.1
log
@* config/tc-ns32k.c (md_begin): Initialize inst_hash_table after
all locals have been declared.
@
text
@d1643 1
a1644 2

  inst_hash_handle = hash_new ();
@


1.16
log
@Fix bugs and remove compile time warnings for N"32K port.
@
text
@d893 3
a895 1
static void encode_operand PARAMS ((int argc, char **argv, char *operandsP, char *, char, char));
d900 2
a901 2
     char *operandsP;
     char *suffixP;
d1082 2
a1083 1
static int parse PARAMS ((char *, int));
d1086 1
a1086 1
     char *line;
d1089 2
a1090 1
  char *lineptr, c, suffix_separator;
d1104 1
a1104 1
      *lineptr = '\0';
d1109 1
a1109 1
      *lineptr = c;
d1644 1
d1646 1
@


1.15
log
@	* as.c: Replace CONST with const.
	* write.c: Likewise.
	* config/obj-coff.c: Likewise.
	* config/tc-a29k.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.c: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i860.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d66 1
d69 1
a69 1
#define ABSOLUTE_PREFIX '@@'	/* One or the other MUST be defined */
d74 13
a86 13
    char mode;			/* addressing mode of operand (0-31) */
    char scaled_mode;		/* mode combined with scaled mode */
    char scaled_reg;		/* register used in scaled+1 (1-8) */
    char float_flag;		/* set if R0..R7 was F0..F7 ie a
				   floating-point-register */
    char am_size;		/* estimated max size of general addr-mode
				   parts */
    char im_disp;		/* if im_disp==1 we have a displacement */
    char pcrel;			/* 1 if pcrel, this is really redundant info */
    char disp_suffix[2];	/* length of displacement(s), 0=undefined */
    char *disp[2];		/* pointer(s) at displacement(s)
				   or immediates(s)     (ascii) */
    char index_byte;		/* index byte */
d100 5
a104 5
 * used as an intermediate form to store the actual parts of the
 * instruction. A ns32k machine instruction can be divided into a
 * couple of sub PARTs. When an instruction is assembled the
 * appropriate PART get an assignment. When an IIF has been completed
 * it is converted to a FRAGment as specified in AS.H.  */
d116 10
a125 11
    int type;			/* how to interpret object */
    int size;			/* Estimated max size of object */
    unsigned long object;	/* binary data */
    int object_adjust;		/* number added to object */
    int pcrel;			/* True if object is pcrel */
    int pcrel_adjust;		/* length in bytes from the
					   instruction start to the
					   displacement */
    int im_disp;		/* True if the object is a displacement */
    relax_substateT relax_substate;	/* Initial relaxsubstate */
    bit_fixS *bit_fixP;		/* Pointer at bit_fix struct */
d127 3
a129 3
				   iif-entry */
    char bsr;			/* Sequent hack */
  } iif_entryT;			/* Internal Instruction Format */
d187 1
a187 1
struct ns32k_option opt1[] =		/* restore, exit */
d199 1
a199 1
struct ns32k_option opt2[] =		/* save, enter */
d211 1
a211 1
struct ns32k_option opt3[] =		/* setcfg */
d219 1
a219 1
struct ns32k_option opt4[] =		/* cinv */
d226 1
a226 1
struct ns32k_option opt5[] =		/* string inst */
d233 1
a233 1
struct ns32k_option opt6[] =		/* plain reg ext,cvtp etc */
d250 1
a250 1
struct ns32k_option cpureg_532[] =	/* lpr spr */
d267 1
a267 1
struct ns32k_option mmureg_532[] =	/* lmr smr */
d279 1
a279 1
struct ns32k_option cpureg_032[] =	/* lpr spr */
d290 1
a290 1
struct ns32k_option mmureg_032[] =	/* lmr smr */
d370 4
a373 3
static void evaluate_expr PARAMS ((expressionS * resultP, char *ptr));
static void md_number_to_disp PARAMS ((char *buf, long val, int n));
static void md_number_to_imm PARAMS ((char *buf, long val, int n));
d383 3
a385 1
int
d388 1
a388 1
     register addr_modeS *addr_modeP;
d391 4
a394 4
  register char *str;
  register int i;
  register int strl;
  register int mode;
d397 3
a399 3
  mode = DEFAULT;		/* default */
  addr_modeP->scaled_mode = 0;	/* why not */
  addr_modeP->scaled_reg = 0;	/* if 0, not scaled index */
d403 1
a403 1
  addr_modeP->pcrel = 0;	/* not set in this function */
d449 1
a449 1
	      as_warn (_("Invalid syntax in PC-relative addressing mode"));
d463 1
a463 1
		{			/* disp[0]'s termination point */
d473 1
a473 1
		  as_warn (_("Invalid syntax in External addressing mode"));
d536 2
a537 1
		{			/* Memory relative.  */
d554 1
a554 1
		      as_warn (_("Invalid syntax in Memory Relative addressing mode"));
d621 1
a621 1
	      as_warn (_("Invalid scaled-indexed mode, use (b,w,d,q)"));
d626 1
a626 1
		as_warn (_("Syntax in scaled-indexed mode, use [Rn:m] where n=[0..7] m={b,w,d,q}"));
d631 1
a631 1
	      as_warn (_("Scaled-indexed addressing mode combined with scaled-index"));
d635 3
a637 3
	  addr_modeP->am_size += 1;	/* scaled index byte */
	  j = str[strl - 4] - '0';	/* store temporary */
	  str[strl - 6] = '\000';	/* nullterminate for recursive call */
d642 1
a642 1
	      as_warn (_("Invalid or illegal addressing mode combined with scaled-index"));
d666 2
a667 1
int
d708 1
a708 1
  if (tmp = addr_modeP->scaled_reg)
d717 2
a718 1
  if (disp_test[addr_modeP->mode])
d720 6
a725 6
      register char c;
      register char suffix;
      register char suffix_sub;
      register int i;
      register char *toP;
      register char *fromP;
d730 2
a731 1
      if (disp_test[addr_modeP->mode])
d744 1
a744 1
	      if (toP = addr_modeP->disp[i])
d749 1
a749 1
		  while (c = *fromP++)
d804 2
a805 1
void
d811 2
a812 2
  register int i, j, k, strlen1, strlen2;
  register char *patternP, *strP;
d848 3
a850 1
int
d856 1
a856 1
  register int i;
d870 1
a870 1
  as_warn (_("No such entry in list. (cpu/mmu register)"));
d879 1
a879 1
  register char *tmp_line;
d883 1
a883 1
  expression (&exprP);
d893 2
a894 1
void
d900 1
a900 1
     char im_size;
d903 1
a903 1
  register int i, j;
d905 2
a906 1
  int pcrel, tmp, b, loop, pcrel_adjust;
d921 2
a922 2
	case 'f':		/* operand of sfsr turns out to be a nasty
				   specialcase */
d924 9
a932 9
	case 'Z':		/* float not immediate */
	case 'F':		/* 32 bit float	general form */
	case 'L':		/* 64 bit float	*/
	case 'I':		/* integer not immediate */
	case 'B':		/* byte	 */
	case 'W':		/* word	 */
	case 'D':		/* double-word	*/
	case 'A':		/* double-word	gen-address-form ie no regs
				   allowed */
d976 3
a978 3
	case 'b':		/* multiple instruction disp */
	  freeptr++;		/* OVE:this is an useful hack */
	  sprintf (freeptr, "((%s-1)*%d)\000", argv[i], desc->im_size);
d980 2
a981 2
	  pcrel -= 1;		/* make pcrel 0 inspite of what case 'p':
				   wants */
d983 1
a983 1
	case 'p':		/* displacement - pc relative addressing */
d986 1
a986 1
	case 'd':		/* displacement */
d991 2
a992 2
	case 'H':		/* sequent-hack: the linker wants a bit set
				   when bsr */
d1003 1
a1003 1
	case 'r':		/* register number (3 bits) */
d1008 1
a1008 1
	case 'O':		/* setcfg instruction optionslist */
d1013 1
a1013 1
	case 'C':		/* cinv instruction optionslist */
d1016 1
a1016 1
	  iif.iifP[1].object |= tmp << 15; /* insert the regtype in opcode */
d1018 1
a1018 1
	case 'S':		/* stringinstruction optionslist */
d1024 1
a1024 1
	case 'U':		/* registerlist */
d1028 1
a1028 1
	    case 'u':		/* restore, exit */
d1031 1
a1031 1
	    case 'U':		/* save,enter */
d1037 1
a1037 1
	case 'M':		/* mmu register */
d1042 1
a1042 1
	case 'P':		/* cpu register  */
d1047 2
a1048 2
	case 'g':		/* inss exts */
	  iif.instr_size += 1;	/* 1 byte is allocated after the opcode */
d1050 1
a1050 1
	       (unsigned long) argv[i],	/* i always 2 here */
d1052 2
a1053 2
	       bit_fix_new (3, 5, 0, 7, 0, 0, 0), /* a bit_fix is targeted to
						     the byte */
d1058 1
a1058 1
	       (unsigned long) argv[i],	/* i always 3 here */
d1064 1
a1064 1
	  b = 2 + i;		/* put the extension byte after opcode */
d1077 1
a1077 1
   Return-value = recursive_level.    */
d1080 2
a1081 1
int
d1086 4
a1089 3
  register char *lineptr, c, suffix_separator;
  register int i;
  int argc, arg_type;
d1145 1
a1145 1
		  suffix[argc] = 0; /* 0 when no ':' is encountered */
d1274 2
a1275 1
void
a1287 1
  int size_so_far;
d1289 1
d1297 1
a1297 1
      if (type = iif.iifP[i].type)
d1310 1
a1310 1
	    case 8:		/* bignum or doublefloat */
d1322 5
a1326 1
		  if (j || iif.iifP[i].pcrel)
d1335 2
a1336 2
				     j,
				     iif.iifP[i].bsr,	/* sequent hack */
d1368 1
a1368 1
			    as_warn (_("Bignum too big for long"));
d1374 3
a1376 5
			    {
			      md_number_to_chars (memP + l,
						  generic_bignum[l >> 1],
						  sizeof (LITTLENUM_TYPE));
			    }
d1413 1
a1413 2
		  if (j ||
		      exprP.X_add_symbol ||
d1431 4
d1468 2
a1469 3
		    /* Size is unknown until link time so have to
                       allow 4 bytes.  */
		    size = 4;
d1480 1
a1480 1
		    break;		/* exit this absolute hack */
d1537 1
a1537 1
				as_warn (_("Displacement to large for :d"));
d1606 1
a1606 1
  if (index >= 0 && index < sizeof (relocs) / sizeof (relocs[0]))
d1733 1
a1733 1
	as_warn (_("Byte displacement out of range.  line number not valid"));
d1742 1
a1742 1
	as_warn (_("Word displacement out of range.  line number not valid"));
d1756 1
a1756 1
	as_warn (_("Double word displacement out of range"));
d1776 1
a1776 1
      as_fatal (_("Internal logic error.  line %s, file \"%s\""),
d1824 1
a1824 1
      as_fatal (_("Internal logic error. line %s, file \"%s\""),
d1863 7
a1869 7
     register char *buf;
     register long val;
     register bit_fixS *field_ptr;
{
  register unsigned long object;
  register unsigned long mask;
  /* define ENDIAN on a ns32k machine */
d1871 1
a1871 1
  register unsigned long *mem_ptr;
d1873 1
a1873 1
  register char *mem_ptr;
d1875 1
d1898 1
a1898 1
#else /* OVE Goof! the machine is a m68k or dito */
d1929 1
a1929 1
      as_warn (_("Bit field out of range"));
d1951 2
a1952 1
int
a1955 1
  fragS *fragP = fixP->fx_frag;
a1983 1
  fragS *fragP = fixP->fx_frag;
d1987 4
a1990 3
    /* Bitfields to fix, sigh.  */
    md_number_to_field (buf, val, fix_bit_fixP (fixP));

d2000 1
a2000 1
      /* Calculate offset */
d2016 1
a2016 1
/* Convert a relaxed displacement to ditto in final output */
d2023 1
a2023 1
     register fragS *fragP;
d2027 3
a2029 3
     bfd *abfd;
     segT sec;
     register fragS *fragP;
a2033 1

d2035 1
a2035 1
  register char *buffer_address = fragP->fr_fix + fragP->fr_literal;
a2038 2
  fragS *opcode_frag;

d2073 1
a2073 1
     register fragS *fragP;
d2090 1
a2090 1
			 frag_bsr(fragP), /*sequent hack */
d2121 2
a2122 2
     fragS *frag;
     symbolS *to_symbol;
d2135 2
a2136 2
     fragS *frag;
     symbolS *to_symbol;
d2149 2
d2176 1
a2176 1
	  as_bad (_("invalid architecture option -m%s"), arg);
d2180 14
d2208 2
a2209 1
-m32032 | -m32532	select variant of NS32K architecture\n"));
d2219 6
a2224 6
     char size;			/* Length of bitfield		*/
     char offset;		/* Bit offset to bitfield	*/
     long min;			/* Signextended min for bitfield */
     long max;			/* Signextended max for bitfield */
     long add;			/* Add mask, used for huffman prefix */
     long base_type;		/* 0 or 1, if 1 it's exploded to opcode ptr */
d2227 1
a2227 1
  register bit_fixS *bit_fixP;
d2239 1
a2239 1
  return (bit_fixP);
d2250 7
a2256 7
     int pcrel;			/* TRUE if PC-relative relocation.  */
     char im_disp;		/* true if the value to write is a
				   displacement */
     bit_fixS *bit_fixP;	/* pointer at struct of bit_fix's, ignored if
				   NULL */
     char bsr;			/* sequent-linker-hack: 1 when relocobject is
				   a bsr */
d2274 2
d2285 7
a2291 7
     int pcrel;			/* TRUE if PC-relative relocation.  */
     char im_disp;		/* true if the value to write is a
				   displacement */
     bit_fixS *bit_fixP;	/* pointer at struct of bit_fix's, ignored if
				   NULL */
     char bsr;			/* sequent-linker-hack: 1 when relocobject is
				   a bsr */
d2308 2
d2329 1
a2329 1
     char *name;
d2338 1
a2338 1
     segT segment;
d2352 1
d2365 1
a2365 1
     asection *section;
@


1.14
log
@Update all uses of md_apply_fix to use md_apply_fix3.  Make it a void function.
@
text
@d3 1
a3 1
   2001
d2128 1
a2128 1
CONST char *md_shortopts = "m:";
@


1.13
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@a1956 6
#ifdef BFD_ASSEMBLER
int
md_apply_fix (fixP, valp)
     fixS *fixP;
     valueT *valp;
#else
d1958 1
a1958 1
md_apply_fix (fixP, val)
d1960 2
a1961 2
     long val;
#endif
d1963 1
a1963 3
#ifdef BFD_ASSEMBLER
  long val = *valp;
#endif
a1964 1

d1968 22
a1989 2
    {				/* Bitfields to fix, sigh.  */
      md_number_to_field (buf, val, fix_bit_fixP (fixP));
a1990 15
  else
    switch (fix_im_disp (fixP))
      {
      case 0:			/* Immediate field.  */
	md_number_to_imm (buf, val, fixP->fx_size);
	break;

      case 1:			/* Displacement field.  */
	/* Calculate offset */
	{
	  md_number_to_disp (buf,
			     (fixP->fx_pcrel ? val + md_fix_pcrel_adjust (fixP)
			      : val), fixP->fx_size);
	}
	break;
d1992 2
a1993 7
      case 2:			/* Pointer in a data object.  */
	md_number_to_chars (buf, val, fixP->fx_size);
	break;
      }
#ifdef BSD_ASSEMBLER
  return 1;
#endif
@


1.12
log
@	* config/tc-alpha.h: Fix formatting.
	* config/tc-arc.c: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ia64.h: Likewise.
	* config/tc-m32r.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-pj.h: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-sparc.h: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-w65.h: Likewise.
@
text
@a25 1
#include <ctype.h>
@


1.11
log
@	* symbols.c (S_GET_VALUE): Don't treat O_constant and local
	symbols specially.  Always resolve, adding fr_address to value.
	* write.c (write_object_file): Don't add fr_address to sym values.
	(relax_frag): Likewise.
	(relax_segment): Likewise.
	* config/obj-ieee.c (do_symbols): Likewise.
	* config/tc-cris.c (md_convert_frag): Likewise.
	* config/tc-fr30.c (md_convert_frag): Likewise.
	* config/tc-i386.c (md_convert_frag): Likewise.
	* config/tc-m32r.c (md_convert_frag): Likewise.
	* config/tc-m68hc11.c (md_convert_frag): Likewise.
	* config/tc-mcore.c (md_convert_frag): Likewise.
	* config/tc-mips.c (mips16_extended_frag): Likewise.
	* config/tc-ns32k.c (md_convert_frag): Likewise.
	* config/tc-m68k.c (md_convert_frag_1): Likewise.
	(BRANCHBWL, BRABSJUNC, BRABSJCOND, BRANCHBW, FBRANCH, DBCCLBR,
	DBCCABSJ, PCREL1632, PCINDEX, ABSTOPCREL): Decrement.
	(md_relax_table): Remove first four entries.  Format.
	(md_estimate_size_before_relax): Remove old_fix.  Don't bother
	setting fr_var.  Simplify byte branch checks.
@
text
@d1302 1
a1302 1
	      memP = frag_more(size);
d1452 1
a1452 1
		    memP = frag_more(size);
d1477 1
a1477 1
			memP = frag_more(4); /* Max size.  */
@


1.10
log
@Fix more fallout from multi-pass relaxation patch.
@
text
@a2053 3
#ifdef BFD_ASSEMBLER
  disp += symbol_get_frag (fragP->fr_symbol)->fr_address;
#endif
@


1.9
log
@Prepare for multi-pass relaxation.
@
text
@d2072 1
a2072 5
  int old_fix;

  old_fix = fragP->fr_fix;

  switch (fragP->fr_subtype)
d2074 1
a2074 7
    case IND (BRANCH, UNDEF):
      if (S_GET_SEGMENT (fragP->fr_symbol) == segment)
	{
	  /* The symbol has been assigned a value.  */
	  fragP->fr_subtype = IND (BRANCH, BYTE);
	}
      else
d2076 1
a2076 1
	  /* We don't relax symbols defined in an other segment the
d2094 1
a2094 1
	  break;
a2095 1
      /* Fall thru */
d2097 4
a2100 5
    case IND (BRANCH, BYTE):
    case IND (BRANCH, WORD):
    case IND (BRANCH, DOUBLE):
      fragP->fr_var = md_relax_table[fragP->fr_subtype].rlx_length;
      break;
d2102 2
a2103 3
    default:
      break;
    }
d2105 2
a2106 1
  return fragP->fr_var + fragP->fr_fix - old_fix;
@


1.8
log
@Fix copyright notices
@
text
@d2 2
a3 1
   Copyright 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
d2106 2
d2109 3
a2111 1
      fragP->fr_var += 1;
d2113 1
@


1.7
log
@2000-09-21  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-ns32k.c: Fix formatting.
	* config/tc-ns32k.h: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1987, 92, 93, 94, 95, 96, 97, 98, 1999, 2000
@


1.7.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1987, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001
@


1.7.2.2
log
@Merge from mainline.
@
text
@d2072 5
a2076 1
  if (fragP->fr_subtype == IND (BRANCH, UNDEF))
d2078 7
a2084 1
      if (S_GET_SEGMENT (fragP->fr_symbol) != segment)
d2086 1
a2086 1
	  /* We don't relax symbols defined in another segment.  The
d2104 1
a2104 1
	  return 4;
d2106 5
a2110 4

      /* Relaxable case.  Set up the initial guess for the variable
	 part of the frag.  */
      fragP->fr_subtype = IND (BRANCH, BYTE);
d2113 1
a2113 5
  if (fragP->fr_subtype >= sizeof (md_relax_table) / sizeof (md_relax_table[0]))
    abort ();

  /* Return the size of the variable part of the frag.  */
  return md_relax_table[fragP->fr_subtype].rlx_length;
@


1.6
log
@Fix formatting
@
text
@d133 1
a133 1
    int instr_size;		/* Max size of instruction in bytes. */
d155 1
a155 1
  
d160 1
a160 1
  
d166 1
a166 1
  
d168 1
a168 1
  
d176 1
a176 1
  
d178 1
a178 2
  
  
d393 1
a393 1
  
d406 1
a406 1
  
d411 1
a411 1
  
d480 1
a480 1
      
d484 1
a484 1
  
d486 1
a486 1
  
d506 1
a506 1
      
d514 1
a514 1
      
d518 1
a518 1
  
d537 1
a537 1
		  
d547 1
a547 1
		  
d553 1
a553 1
		  
d556 1
a556 1
		  str[j] = '\000';	/* Null terminate disp[0] . */
d558 1
a558 1
		  
d562 1
a562 1
	  
d577 1
a577 1
	      
d587 1
a587 1
	      
d593 1
a593 1
		  
d598 1
a598 1
      
d618 1
a618 1
	      
d630 1
a630 1
	  
d635 1
a635 1
	  
d641 1
a641 1
	  
d645 1
a645 1
	  
d649 1
a649 1
  
d652 1
a652 1
  
d668 1
a668 1
  
d670 1
a670 1
  
d678 1
a678 1
      
d693 1
a693 1
      
d697 1
a697 1
  
d711 1
a711 1
  
d723 1
a723 1
	
d730 1
a730 1
	    
d732 1
a732 1
	    
d736 1
a736 1
		
d741 1
a741 1
		    
d766 1
a766 1
			  
d769 1
a769 1
			  
d774 1
a774 1
		  
d791 1
a791 1
  
d805 1
a805 1
  
d807 1
a807 1
  
d810 1
a810 1
  
d814 1
a814 1
      
d819 1
a819 1
	  
d825 1
a825 1
	  
d847 1
a847 1
  
d855 1
a855 1
	  
d859 1
a859 1
  
d895 1
a895 1
  
d902 1
a902 1
      
d906 1
a906 1
      
d922 1
a922 1
	  
d932 1
a932 1
	  
d952 1
a952 1
	  
d955 1
a955 1
	  
d963 1
a963 1
	  
d1078 1
a1078 1
  
d1084 1
a1084 1
      
d1087 1
a1087 1
      
d1097 1
a1097 1
  
d1099 1
a1099 1
  
d1106 1
a1106 1
	  
d1113 1
a1113 1
		  
d1130 1
a1130 1
		  
d1134 1
a1134 1
		  
d1150 1
a1150 1
		      
d1175 1
a1175 1
			  
d1179 1
a1179 1
		      
d1183 1
a1183 1
		  
d1186 1
a1186 1
		  
d1189 1
a1189 1
		  
d1199 1
a1199 1
  
d1214 1
a1214 1
  
d1294 1
a1294 1
	      
d1303 1
a1303 1
	      
d1336 1
a1336 1
		  
d1350 1
a1350 1
			  
d1353 1
a1353 1
			  
d1435 1
a1435 1
	      
d1444 1
a1444 1
		
d1523 1
a1523 1
		    
d1529 1
a1529 1
	      
d1568 1
a1568 1
  
d1584 1
a1584 1
  
d1586 1
a1586 1
  
d1589 1
a1589 1
  
d1596 1
a1596 1
  
d1665 1
a1665 1
  
d1671 1
a1671 1
  
d1677 1
a1677 1
  
d1864 1
a1864 1
      
d1920 1
a1920 1
  
d1924 1
a1924 1
  
d1927 1
a1927 1
  
d1939 1
a1939 1
  
d1943 1
a1943 1
  
d1946 1
a1946 1
  
d2050 1
a2050 1
  
d2072 1
a2072 1
  
d2074 1
a2074 1
  
d2111 1
a2111 1
  
d2232 4
a2235 4
     int size;			/* 1, 2  or 4 usually. */
     symbolS *add_symbol;	/* X_add_symbol. */
     long offset;		/* X_add_number. */
     int pcrel;			/* TRUE if PC-relative relocation. */
d2266 3
a2268 3
     int size;			/* 1, 2  or 4 usually. */
     expressionS *exp;		/* Expression. */
     int pcrel;			/* TRUE if PC-relative relocation. */
d2299 2
a2300 2
     int size;			/* 1, 2  or 4 usually. */
     expressionS *exp;		/* Expression. */
@


1.5
log
@Fix comments.
@
text
@d2 1
a2 1
   Copyright (C) 1987, 92, 93, 94, 95, 96, 97, 98, 1999
d22 1
a22 1
/*#define SHOW_NUM 1*//* uncomment for debugging */
d32 3
a34 3
/* Macros */
#define IIF_ENTRIES 13		/* number of entries in iif */
#define PRIVATE_SIZE 256	/* size of my garbage memory */
d38 1
a38 1
                                   encountered */
d66 1
d89 1
a89 2

char *freeptr, *freeptr_static;	/* points at some number of free bytes */
d92 1
a92 1
struct ns32k_opcode *desc;	/* pointer at description of instruction */
d95 2
a96 1
const char FLT_CHARS[] = "fd";	/* we don't want to support lowercase, do we */
d103 1
a103 1
 * it is converted to a FRAGment as specified in AS.H */
d105 1
a105 1
/* internal structs */
d107 5
a111 5
  {
    char *pattern;
    unsigned long or;
    unsigned long and;
  };
d136 1
d140 47
a186 47
/* description of the PARTs in IIF
 *object[n]:
 * 0	total length in bytes of entries in iif
 * 1	opcode
 * 2	index_byte_a
 * 3	index_byte_b
 * 4	disp_a_1
 * 5	disp_a_2
 * 6	disp_b_1
 * 7	disp_b_2
 * 8	imm_a
 * 9	imm_b
 * 10	implied1
 * 11	implied2
 *
 * For every entry there is a datalength in bytes. This is stored in size[n].
 *	 0,	the objectlength is not explicitly given by the instruction
 *		and the operand is undefined. This is a case for relaxation.
 *		Reserve 4 bytes for the final object.
 *
 *	 1,	the entry contains one byte
 *	 2,	the entry contains two bytes
 *	 3,	the entry contains three bytes
 *	 4,	the entry contains four bytes
 *	etc
 *
 * Furthermore, every entry has a data type identifier in type[n].
 *
 * 	 0,	the entry is void, ignore it.
 * 	 1,	the entry is a binary number.
 *	 2,	the entry is a pointer at an expression.
 *		Where expression may be as simple as a single '1',
 *		and as complicated as  foo-bar+12,
 * 		foo and bar may be undefined but suffixed by :{b|w|d} to
 *		control the length of the object.
 *
 *	 3,	the entry is a pointer at a bignum struct
 *
 *
 * The low-order-byte coresponds to low physical memory.
 * Obviously a FRAGment must be created for each valid disp in PART whose
 * datalength is undefined (to bad) .
 * The case where just the expression is undefined is less severe and is
 * handled by fix. Here the number of bytes in the objectfile is known.
 * With this representation we simplify the assembly and separates the
 * machine dependent/independent parts in a more clean way (said OE)
 */
d316 1
a316 1
{					/* so far empty */
d322 1
a322 1
/* those are index's to relax groups in md_relax_table ie it must be
d324 1
a324 1
   relax_segment in write.c for more info */
d329 1
a329 1
/* those are index's to entries in a relax group */
d342 1
a342 2
   had to be used.  Now we dont have to think about that. */

d358 1
a358 1
   Value is true if mode contains displacement. */
d366 1
a366 1
/* Array used to calculate max size of displacements */
d375 5
a379 1
/* Parses a general operand into an addressingmode struct
d381 1
a381 3
   in:  pointer at operand in ascii form
   pointer at addr_mode struct for result
   the level of recursion. (always 0 or 1)
a382 2
   out: data in addr_mode struct
   */
d394 1
d407 1
d409 2
a410 3
    {
      return (0);
    }				/* we don't want this */
d412 1
d415 2
a416 2
      /* the following three case statements controls the mode-chars
	 this is the place to ed if you want to change them */
d423 1
a423 1
      return (-1);
d431 1
a431 1
      return (-1);
d444 1
a444 1
		  return (-1);
d448 1
a448 1
	      return (0);
d477 1
a477 1
	      return (-1);
d481 3
a483 1
    default:;
d485 1
d487 1
d495 1
d500 1
a500 1
	      return (-1);
d502 3
d506 2
d512 1
a512 1
	  return (-1);
d514 4
a517 1
    default:;
d519 1
d527 6
a532 11
		{
		  mode = 16;		/* Memory Relative */
		}
	      if (!strncmp (&str[strl - 5], "(sp", 3))
		{
		  mode = 17;
		}
	      if (!strncmp (&str[strl - 5], "(sb", 3))
		{
		  mode = 18;
		}
d534 1
a534 1
		{			/* memory relative */
d536 1
a536 1
		  j = strl - 5;		/* temp for end of disp[0] */
d538 1
d548 1
d554 1
d557 4
a560 3
		  str[j] = '\000';	/* null terminate disp[0] */
		  str[strl] = '\000';	/* null terminate disp[1] */
		  return (-1);
d563 1
d575 1
a575 1
		  return (-1);		/* reg rel */
d577 2
d581 8
a588 15
		{
		  mode = 24;
		}
	      if (!strncmp (&str[strl - 4], "(sp", 3))
		{
		  mode = 25;
		}
	      if (!strncmp (&str[strl - 4], "(sb", 3))
		{
		  mode = 26;
		}
	      if (!strncmp (&str[strl - 4], "(pc", 3))
		{
		  mode = 27;
		}
d594 2
a595 1
		  return (-1);		/* memory space */
d599 2
a600 1
      /* no trailing ')' do we have a ']' ? */
d617 1
a617 1
	    default:;
d619 1
d623 25
a647 25
		{
		  as_warn (_("Syntax in scaled-indexed mode, use [Rn:m] where n=[0..7] m={b,w,d,q}"));
		}
	    } /* scaled index */
	  {
	    if (recursive_level > 0)
	      {
		as_warn (_("Scaled-indexed addressing mode combined with scaled-index"));
		return (0);
	      }
	    addr_modeP->am_size += 1;	/* scaled index byte */
	    j = str[strl - 4] - '0';	/* store temporary */
	    str[strl - 6] = '\000';	/* nullterminate for recursive call */
	    i = addr_mode (str, addr_modeP, 1);
	    if (!i || addr_modeP->mode == 20)
	      {
		as_warn (_("Invalid or illegal addressing mode combined with scaled-index"));
		return (0);
	      }
	    addr_modeP->scaled_mode = addr_modeP->mode;	/* store the inferior
							   mode */
	    addr_modeP->mode = mode;
	    addr_modeP->scaled_reg = j + 1;
	    return (-1);
	  }
d650 2
a651 1
  addr_modeP->mode = DEFAULT;	/* default to whatever */
d653 2
a654 1
  return (-1);
d662 1
d669 1
d671 1
d674 1
a674 1
      /* resolve ambigious operands, this shouldn't be necessary if
d677 3
a679 2
	 if it is implicitly stated. See ns32k-opcode.h */
      (void) evaluate_expr (&exprP, ptr); /* this call takes time Sigh! */
d683 1
a683 3
	    {
	      addr_modeP->mode = desc->default_model; /* we have a label */
	    }
d685 1
a685 3
	    {
	      addr_modeP->mode = desc->default_modec; /* we have a constant */
	    }
d690 1
a690 3
	    {
	      addr_modeP->scaled_mode = desc->default_model;
	    }
d692 1
a692 3
	    {
	      addr_modeP->scaled_mode = desc->default_modec;
	    }
d694 3
a696 2
      /* must put this mess down in addr_mode to handle the scaled
         case better */
d698 1
d705 3
a707 3
    {				/* build indexbyte */
      tmp--;			/* remember regnumber comes incremented for
				   flagpurpose */
d712 1
d714 68
a781 62
    {				/* there was a displacement, probe for length
				   specifying suffix */
      {
	register char c;
	register char suffix;
	register char suffix_sub;
	register int i;
	register char *toP;
	register char *fromP;

	addr_modeP->pcrel = 0;
	if (disp_test[addr_modeP->mode])
	  {			/* there is a displacement */
	    if (addr_modeP->mode == 27 || addr_modeP->scaled_mode == 27)
	      {			/* do we have pcrel. mode */
		addr_modeP->pcrel = 1;
	      }
	    addr_modeP->im_disp = 1;
	    for (i = 0; i < 2; i++)
	      {
		suffix_sub = suffix = 0;
		if (toP = addr_modeP->disp[i])
		  {		/* suffix of expression, the largest size
				   rules */
		    fromP = toP;
		    while (c = *fromP++)
		      {
			*toP++ = c;
			if (c == ':')
			  {
			    switch (*fromP)
			      {
			      case '\0':
				as_warn (_("Premature end of suffix -- Defaulting to d"));
				suffix = 4;
				continue;
			      case 'b':
				suffix_sub = 1;
				break;
			      case 'w':
				suffix_sub = 2;
				break;
			      case 'd':
				suffix_sub = 4;
				break;
			      default:
				as_warn (_("Bad suffix after ':' use {b|w|d} Defaulting to d"));
				suffix = 4;
			      }
			    fromP++;
			    toP--;	/* So we write over the ':' */
			    if (suffix < suffix_sub)
			      suffix = suffix_sub;
			  }
		      }
		    *toP = '\0';/* terminate properly */
		    addr_modeP->disp_suffix[i] = suffix;
		    addr_modeP->am_size += suffix ? suffix : 4;
		  }
	      }
	  }
      }
d786 2
a787 1
	{			/* look in ns32k_opcode for size */
d792 1
d796 1
a797 1
/* read an optionlist */
d800 3
a802 3
     char *str;			/* the string to extract options from */
     struct ns32k_option *optionP;	/* how to search the string */
     unsigned long *default_map;	/* default pattern and output */
d806 1
d808 1
d810 2
a811 3
    {
      as_fatal (_("Very short instr to option, ie you can't do it on a NULLstr"));
    }
d815 1
d820 1
d826 1
d836 1
a836 1
/* search struct for symbols
d839 1
a839 1
   list */
d843 3
a845 3
     char *str;				/* the string to match */
     struct ns32k_option *optionP;	/* list to search */
     unsigned long *default_map;	/* default pattern and output */
d848 1
d852 2
a853 1
	{				/* use strncmp to be safe */
d856 1
d860 1
d882 1
a882 2
   Be carefull not to put to objects in the same iif-slot.
   */
d896 1
d899 2
a900 2
      i = operandsP[loop << 1] - '1';	/* what operand are we supposed
					   to work on */
d903 1
d907 1
d923 5
a927 5
	  if((addr_modeP.mode == 20) &&
	     (d == 'I' || d == 'Z' || d == 'A')) {
	    as_fatal(d == 'A'? _("Address of immediate operand"):
		     _("Invalid immediate write operand."));
	  }
d933 1
d953 1
d956 1
d964 1
d1066 3
a1068 3
   Return-value = recursive_level
   */
/* build iif of one assembly text line */
d1078 2
a1079 1
  char suffix[MAX_ARGS], *argv[MAX_ARGS];	/* no more than 4 operands */
d1081 5
a1085 2
    {				/* called from md_assemble */
      for (lineptr = line; (*lineptr) != '\0' && (*lineptr) != ' '; lineptr++);
d1088 1
d1090 2
a1091 3
	{
	  as_fatal (_("No such opcode"));
	}
d1098 1
d1100 1
d1107 1
d1114 1
d1120 2
a1121 2
		    case 'H':	/* the operand is supposed to be a
				   displacement */
d1123 1
a1123 1
                         cases above when editing ns32k-opcode.h */
d1127 3
a1129 2
		      suffix_separator = '\255'; /* if this char occurs we
						    loose */
d1131 1
d1135 1
d1151 1
d1153 2
a1154 1
			{	/* ':' - label/suffix separator */
d1174 1
d1176 1
d1180 1
d1184 1
d1187 1
d1190 1
d1200 1
d1204 2
a1205 1
	{			/* we can apply default, dont goof */
d1207 2
a1208 3
	    {			/* check error in default */
	      as_fatal (_("Wrong numbers of operands in default, check ns32k-opcodes.h"));
	    }
a1213 1

d1215 1
d1217 2
a1218 3
    {
      iif.iifP[i].type = 0;	/* mark all entries as void*/
    }
d1220 1
a1220 1
  /* build opcode iif-entry */
d1224 1
a1224 1
  /* this call encodes operands to iif format */
a1236 1

d1238 7
a1244 8
 * functions in other files than this one.(Except hash.c) So, if it's
 * possible to make an iif for an other CPU, you don't need to know
 * what frags, relax, obstacks, etc is in order to port this
 * assembler. You only need to know if it's possible to reduce your
 * cpu-instruction to iif-format (takes some work) and adopt the other
 * md_? parts according to given instructions Note that iif was
 * invented for the clean ns32k`s architecure.
 */
d1247 13
a1259 13
 * relative to the address of the opcode, not the address of the
 * operand. We used to keep track of the offset between the operand
 * and the opcode in pcrel_adjust for each frag and each fix. However,
 * we get into trouble where there are two or more pc-relative
 * operands and the size of the first one can't be determined. Then in
 * the relax phase, the size of the first operand will change and
 * pcrel_adjust will no longer be correct.  The current solution is
 * keep a pointer to the frag with the opcode in it and the offset in
 * that frag for each frag and each fix. Then, when needed, we can
 * always figure out how far it is between the opcode and the pcrel
 * object.  See also md_pcrel_adjust and md_fix_pcrel_adjust.  For
 * objects not part of an instruction, the pointer to the opcode frag
 * is always zero.  */
d1284 2
a1285 1
	{			/* the object exist, so handle it */
d1289 2
a1290 2
	      size = 0;		/* it's a bitfix that operates on an existing
				   object*/
d1292 4
a1295 3
		{		/* expand fx_bit_base to point at opcode */
		  iif.iifP[i].bit_fixP->fx_bit_base = (long) inst_opcode;
		}
d1300 2
a1301 1
	    case 4:		/* the final size in objectmemory is known */
d1304 1
d1307 1
a1307 1
		case 1:	/* the object is pure binary */
d1322 2
a1323 1
		    {		/* good, just put them bytes out */
d1337 1
d1339 1
a1339 1
		  /* the object is a pointer at an expression, so
d1341 1
a1341 1
                     expression */
d1347 2
a1348 2
			  /* we have a bignum ie a quad. This can only
                             happens in a long suffixed instruction */
d1351 1
d1354 1
d1363 2
a1364 1
			{	/* flonum */
d1404 1
a1404 1
                         the object later. */
d1418 1
a1418 1
		      /* good, just put them bytes out */
d1436 1
d1438 1
a1438 1
	      /* To bad, the object may be undefined as far as its
d1442 1
a1442 1
		 determined and a fix can replace the frag. */
d1445 1
d1450 1
a1450 1
                       allow 4 bytes. */
d1466 2
a1467 1
		  {			/* frag it */
d1469 2
a1470 1
		      {			/* We cant relax this case */
d1475 3
a1477 5

			/* Size is not important. This gets fixed by relax,
			 * but we assume 0 in what follows
			 */
			memP = frag_more(4); /* Max size */
d1483 4
a1486 3
					4, /* Max size */
					0, /* size */
					IND (BRANCH, UNDEF), /* expecting the worst */
d1490 3
a1492 3
			  frag_opcode_frag(old_frag) = inst_frag;
			  frag_opcode_offset(old_frag) = inst_offset;
			  frag_bsr(old_frag) = iif.iifP[i].bsr;
d1498 1
a1498 1
		    /* This duplicates code in md_number_to_disp */
d1512 2
a1513 2
			    if (-0x20000000<=exprP.X_add_number &&
				exprP.X_add_number<=0x1fffffff)
d1524 2
a1525 1
		    memP = frag_more(size);
d1530 1
d1539 1
a1539 1
/* This functionality should really be in the bfd library */
d1544 2
a1545 1
  bfd_reloc_code_real_type relocs[] = {
d1553 1
a1553 1
    /* ns32k displacements */
d1561 1
a1561 1
    /* Normal 2's complement */
d1568 2
a1569 1
    };
d1585 1
d1587 2
a1588 1
  if (index >= 0 && index < sizeof(relocs)/sizeof(relocs[0]))
d1590 1
d1597 1
a1600 1

d1608 2
a1609 2
  parse (line, 0);		/* explode line to more fix form in iif */
  convert_iif ();		/* convert iif to frags, fix's etc */
a1614 1

d1618 1
a1618 1
  /* build a hashtable of the instructions */
d1622 1
d1626 2
a1627 3
	{
	  as_fatal (_("Can't hash %s: %s"), ptr->name, stat);	/*fatal*/
	}
d1629 3
a1631 2
  freeptr_static = (char *) malloc (PRIVATE_SIZE); /* some private space
						      please! */
d1634 1
a1634 1
/* Must be equal to MAX_PRECISON in atof-ieee.c */
d1666 1
d1672 1
d1678 1
d1682 1
a1682 1
/* Convert number to chars in correct order */
a1692 1

d1704 1
d1811 2
a1812 3

/* fast bitfiddling support */
/* mask used to zero bitfield before oring in the true field */
d1841 1
a1841 2
   and a general version. (My advice: use the general version!)
   */
d1861 2
a1862 3
	{			/* override buf */
	  mem_ptr = (unsigned long *) field_ptr->fx_bit_base;
	}
d1864 2
a1865 3
	{
	  mem_ptr = (unsigned long *) buf;
	}
d1870 1
a1870 3
	{			/* override buf */
	  mem_ptr = (char *) field_ptr->fx_bit_base;
	}
d1872 2
a1873 3
	{
	  mem_ptr = buf;
	}
d1876 2
a1877 2
#ifdef ENDIAN			/* we have a nice ns32k machine with lowbyte
				   at low-physical mem */
d1880 1
a1880 1
      /* That takes more byte fiddling */
d1914 3
a1916 1
int md_pcrel_adjust (fragS *fragP)
d1921 2
a1922 1
  opcode_frag = frag_opcode_frag(fragP);
d1925 2
a1926 1
  offset = frag_opcode_offset(fragP);
d1928 1
d1932 3
a1934 1
int md_fix_pcrel_adjust (fixS *fixP)
d1940 2
a1941 1
  opcode_frag = fix_opcode_frag(fixP);
d1944 2
a1945 1
  offset = fix_opcode_offset(fixP);
d1947 1
d1977 3
a1979 3
  if (fix_bit_fixP(fixP))
    {				/* Bitfields to fix, sigh */
      md_number_to_field (buf, val, fix_bit_fixP(fixP));
d1982 1
a1982 1
    switch (fix_im_disp(fixP))
d1984 1
a1984 2

      case 0:			/* Immediate field */
d1988 1
a1988 1
      case 1:			/* Displacement field */
d1991 3
a1993 3
	md_number_to_disp (buf,
			   (fixP->fx_pcrel ? val + md_fix_pcrel_adjust(fixP)
			    : val), fixP->fx_size);
d1997 1
a1997 1
      case 2:			/* Pointer in a data object */
d2045 1
a2045 1
  if(ext == 0)
d2051 1
d2057 1
a2057 1
  disp += md_pcrel_adjust(fragP);
d2065 1
a2065 1
   actually know it */
d2073 1
d2075 1
d2081 1
a2081 1
	  /* the symbol has been assigned a value */
d2086 2
a2087 2
	  /* we don't relax symbols defined in an other segment the
	     thing to do is to assume the object will occupy 4 bytes */
d2097 2
a2098 2
			 frag_opcode_frag(fragP),
			 frag_opcode_offset(fragP));
d2100 3
a2102 1
	  /* fragP->fr_opcode[1]=0xff; */
d2112 1
d2118 1
a2118 1
const int md_reloc_size = 8;	/* Size of relocation record */
d2149 3
a2151 1
struct option md_longopts[] = {
d2154 2
a2155 1
size_t md_longopts_size = sizeof(md_longopts);
d2193 1
a2193 1
  fprintf(stream, _("\
d2197 5
a2202 8

/*
 *			bit_fix_new()
 *
 * Create a bit_fixS in obstack 'notes'.
 * This struct is used to profile the normal fix. If the bit_fixP is a
 * valid pointer (not NULL) the bit_fix data will be used to format the fix.
 */
a2244 1

d2249 1
a2249 1
			bit_fixP? NO_RELOC: reloc(size, pcrel, im_disp)
d2255 6
a2260 6
  fix_opcode_frag(fixP) = opcode_frag;
  fix_opcode_offset(fixP) = opcode_offset;
  fix_im_disp(fixP) = im_disp;
  fix_bsr(fixP) = bsr;
  fix_bit_fixP(fixP) = bit_fixP;
}				/* fix_new_ns32k() */
d2281 1
a2281 1
			    bit_fixP? NO_RELOC: reloc(size, pcrel, im_disp)
d2287 6
a2292 6
  fix_opcode_frag(fixP) = opcode_frag;
  fix_opcode_offset(fixP) = opcode_offset;
  fix_im_disp(fixP) = im_disp;
  fix_bsr(fixP) = bsr;
  fix_bit_fixP(fixP) = bit_fixP;
}				/* fix_new_ns32k() */
d2317 1
d2323 1
a2323 1
  return size;			/* Byte alignment is fine */
d2327 2
a2328 1
   ns32k, they're relative to the start of the instruction. */
d2336 2
a2337 2
  if (frag_bsr(fixP->fx_frag))
    res += 0x12			/* FOO Kludge alert! */
d2352 1
a2352 1
  code = reloc(fixp->fx_size, fixp->fx_pcrel, fix_im_disp(fixp));
d2386 2
a2387 4
  /*
   * In: length of relocation (or of address) in chars: 1, 2 or 4.
   * Out: GNU LD relocation length code: 0, 1, or 2.
   */
d2389 1
a2389 1
  static unsigned char nbytes_r_length[] = {42, 0, 1, 42, 2};
d2407 2
a2408 2
		       | (long) (fix_bsr(fixP) << 28)
		       | (long) (fix_im_disp(fixP) << 29)),
a2413 2

/* end of tc-ns32k.c */
@


1.4
log
@Don't treat `;' as a line separator by default.
Explicitly mention `;' in line_separator_chars in each backend.
@
text
@d1564 2
a1565 2
   of type type, and emit the appropriate bytes.  The number of
   LITTLENUMS emitted is stored in *sizeP .  An error message is
d1567 1
@


1.3
log
@	* config/tc-alpha.c: More use of symbol accessor functions.
	* config/tc-arc.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-fr30.c: Likewise.
	* config/tc-i860.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-v850.c: Likewise.
@
text
@d65 1
a65 1
const char line_separator_chars[] = "";
@


1.2
log
@1999-06-22  Jonathan Larmour  <jlarmour@@cygnus.co.uk>
	* config/tc-arc.c (tc_gen_reloc): Use symbol_get_bfdsym to get at
	the symbol, rather than accessing the bsym member.
	* config/tc-d10v.c (tc_gen_reloc): Likewise.
	* config/tc-d30v.c (tc_gen_reloc): Likewise.
	* config/tc-mcore.c (tc_gen_reloc): Likewise.
	* config/tc-mn10200.c (tc_gen_reloc): Likewise.
	* config/tc-mn10300.c (tc_gen_reloc): Likewise.
	* config/tc-ns32k.c (tc_gen_reloc): Likewise.
	* config/tc-tic30.c (tc_gen_reloc): Likewise.
	* config/tc-v850.c (tc_gen_reloc): Likewise.
@
text
@d1974 1
a1974 1
  disp += fragP->fr_symbol->sy_frag->fr_address;
@


1.1
log
@Initial revision
@
text
@d2 2
a3 1
   Copyright (C) 1987, 92, 93, 94, 95, 96, 1997, 1998 Free Software Foundation, Inc.
d2268 2
a2269 1
  rel->sym_ptr_ptr = &fixp->fx_addsy->bsym;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

