head	1.27;
access;
symbols
	binutils-2_24-branch:1.26.0.4
	binutils-2_24-branchpoint:1.26
	binutils-2_21_1:1.25
	binutils-2_23_2:1.26
	binutils-2_23_1:1.26
	binutils-2_23:1.26
	binutils-2_23-branch:1.26.0.2
	binutils-2_23-branchpoint:1.26
	binutils-2_22_branch:1.25.0.6
	binutils-2_22:1.25
	binutils-2_22-branch:1.25.0.4
	binutils-2_22-branchpoint:1.25
	binutils-2_21:1.25
	binutils-2_21-branch:1.25.0.2
	binutils-2_21-branchpoint:1.25
	binutils-2_20_1:1.23.8.1
	binutils-2_20:1.23.8.1
	binutils-arc-20081103-branch:1.23.0.10
	binutils-arc-20081103-branchpoint:1.23
	binutils-2_20-branch:1.23.0.8
	binutils-2_20-branchpoint:1.23
	dje-cgen-play1-branch:1.23.0.6
	dje-cgen-play1-branchpoint:1.23
	arc-20081103-branch:1.23.0.4
	arc-20081103-branchpoint:1.23
	binutils-2_19_1:1.23
	binutils-2_19:1.23
	binutils-2_19-branch:1.23.0.2
	binutils-2_19-branchpoint:1.23
	binutils-2_18:1.22
	binutils-2_18-branch:1.22.0.2
	binutils-2_18-branchpoint:1.22
	binutils-csl-coldfire-4_1-32:1.20
	binutils-csl-sourcerygxx-4_1-32:1.20
	binutils-csl-innovasic-fido-3_4_4-33:1.20
	binutils-csl-sourcerygxx-3_4_4-32:1.16
	binutils-csl-coldfire-4_1-30:1.20
	binutils-csl-sourcerygxx-4_1-30:1.20
	binutils-csl-coldfire-4_1-28:1.20
	binutils-csl-sourcerygxx-4_1-29:1.20
	binutils-csl-sourcerygxx-4_1-28:1.20
	binutils-csl-arm-2006q3-27:1.20
	binutils-csl-sourcerygxx-4_1-27:1.20
	binutils-csl-arm-2006q3-26:1.20
	binutils-csl-sourcerygxx-4_1-26:1.20
	binutils-csl-sourcerygxx-4_1-25:1.20
	binutils-csl-sourcerygxx-4_1-24:1.20
	binutils-csl-sourcerygxx-4_1-23:1.20
	binutils-csl-sourcerygxx-4_1-21:1.20
	binutils-csl-arm-2006q3-21:1.20
	binutils-csl-sourcerygxx-4_1-22:1.20
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.20
	binutils-csl-sourcerygxx-4_1-20:1.20
	binutils-csl-arm-2006q3-19:1.20
	binutils-csl-sourcerygxx-4_1-19:1.20
	binutils-csl-sourcerygxx-4_1-18:1.20
	binutils-csl-renesas-4_1-9:1.20
	binutils-csl-sourcerygxx-3_4_4-25:1.16
	binutils-csl-renesas-4_1-8:1.20
	binutils-csl-renesas-4_1-7:1.20
	binutils-csl-renesas-4_1-6:1.20
	binutils-csl-sourcerygxx-4_1-17:1.20
	binutils-csl-sourcerygxx-4_1-14:1.20
	binutils-csl-sourcerygxx-4_1-15:1.20
	binutils-csl-sourcerygxx-4_1-13:1.20
	binutils-2_17:1.20
	binutils-csl-sourcerygxx-4_1-12:1.20
	binutils-csl-sourcerygxx-3_4_4-21:1.20
	binutils-csl-wrs-linux-3_4_4-24:1.16
	binutils-csl-wrs-linux-3_4_4-23:1.16
	binutils-csl-sourcerygxx-4_1-9:1.20
	binutils-csl-sourcerygxx-4_1-8:1.20
	binutils-csl-sourcerygxx-4_1-7:1.20
	binutils-csl-arm-2006q1-6:1.20
	binutils-csl-sourcerygxx-4_1-6:1.20
	binutils-csl-wrs-linux-3_4_4-22:1.16
	binutils-csl-coldfire-4_1-11:1.20
	binutils-csl-sourcerygxx-3_4_4-19:1.20
	binutils-csl-coldfire-4_1-10:1.20
	binutils-csl-sourcerygxx-4_1-5:1.20
	binutils-csl-sourcerygxx-4_1-4:1.20
	binutils-csl-wrs-linux-3_4_4-21:1.16
	binutils-csl-morpho-4_1-4:1.20
	binutils-csl-sourcerygxx-3_4_4-17:1.20
	binutils-csl-wrs-linux-3_4_4-20:1.16
	binutils-2_17-branch:1.20.0.4
	binutils-2_17-branchpoint:1.20
	binutils-csl-2_17-branch:1.20.0.2
	binutils-csl-2_17-branchpoint:1.20
	binutils-csl-gxxpro-3_4-branch:1.16.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.16
	binutils-2_16_1:1.16
	binutils-csl-arm-2005q1b:1.16
	binutils-2_16:1.16
	binutils-csl-arm-2005q1a:1.16
	binutils-csl-arm-2005q1-branch:1.16.0.4
	binutils-csl-arm-2005q1-branchpoint:1.16
	binutils-2_16-branch:1.16.0.2
	binutils-2_16-branchpoint:1.16
	csl-arm-2004-q3d:1.13
	csl-arm-2004-q3:1.13
	binutils-2_15:1.12
	binutils-2_15-branchpoint:1.12
	csl-arm-2004-q1a:1.12
	csl-arm-2004-q1:1.12
	binutils-2_15-branch:1.12.0.6
	cagney_bfdfile-20040213-branch:1.12.0.4
	cagney_bfdfile-20040213-branchpoint:1.12
	cagney_bigcore-20040122-branch:1.12.0.2
	cagney_bigcore-20040122-branchpoint:1.12
	csl-arm-2003-q4:1.12
	binutils-2_14:1.11
	binutils-2_14-branch:1.11.0.2
	binutils-2_14-branchpoint:1.11
	binutils-2_13_2_1:1.9
	binutils-2_13_2:1.9
	binutils-2_13_1:1.9
	binutils-2_13:1.9
	binutils-2_13-branchpoint:1.9
	binutils-2_13-branch:1.9.0.4
	binutils-2_12_1:1.9
	binutils-2_12:1.9
	binutils-2_12-branch:1.9.0.2
	binutils-2_12-branchpoint:1.9
	cygnus_cvs_20020108_pre:1.9
	binutils-2_11_2:1.3.2.2
	binutils-2_11_1:1.3.2.2
	binutils-2_11:1.3
	x86_64versiong3:1.3
	binutils-2_11-branch:1.3.0.2
	binutils-2_10_1:1.2
	binutils-2_10:1.2
	binutils-2_10-branch:1.2.0.2
	binutils-2_10-branchpoint:1.2
	binutils_latest_snapshot:1.27
	repo-unification-2000-02-06:1.2
	binu_ss_19990721:1.2
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2013.10.09.15.52.32;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	2011.10.24.02.49.24;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2009.12.11.13.42.11;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2009.09.08.10.36.39;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2007.10.17.16.45.55;	author nickc;	state Exp;
branches
	1.23.8.1;
next	1.22;

1.22
date	2007.07.03.11.01.04;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2006.06.07.11.27.58;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2006.01.11.17.39.49;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2005.06.07.17.54.17;	author zack;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.05.09.13.01;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2005.03.24.20.40.27;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2005.03.03.13.50.02;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2005.03.03.11.47.54;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2005.01.31.23.18.32;	author bje;	state Exp;
branches;
next	1.13;

1.13
date	2004.05.06.11.01.48;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.11.06.11.45;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2002.12.12.22.09.12;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2002.11.30.08.39.43;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.15.21.28.57;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2001.10.11.23.56.33;	author kazu;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.19.05.33.28;	author hjl;	state Exp;
branches;
next	1.6;

1.6
date	2001.07.30.06.15.49;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.30.00.06.10;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.08.23.24.24;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.17.21.06.14;	author nickc;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	99.06.22.14.07.36;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.43;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.23.8.1
date	2009.09.08.10.53.21;	author amodra;	state Exp;
branches;
next	;

1.3.2.1
date	2001.06.07.03.15.32;	author amodra;	state Exp;
branches;
next	1.3.2.2;

1.3.2.2
date	2001.06.11.10.04.49;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.43;	author rth;	state Exp;
branches;
next	;


desc
@@


1.27
log
@	PR gas/16026
	* config/tc-mn10200.c (md_convert_frag): Add missing break
	statement.
@
text
@/* tc-mn10200.c -- Assembler code for the Matsushita 10200
   Copyright 1996-2013 Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 51 Franklin Street - Fifth Floor,
   Boston, MA 02110-1301, USA.  */

#include "as.h"
#include "safe-ctype.h"
#include "subsegs.h"
#include "opcode/mn10200.h"

/* Structure to hold information about predefined registers.  */
struct reg_name
{
  const char *name;
  int value;
};

/* Generic assembler global variables which must be defined by all
   targets.  */

/* Characters which always start a comment.  */
const char comment_chars[] = "#";

/* Characters which start a comment at the beginning of a line.  */
const char line_comment_chars[] = ";#";

/* Characters which may be used to separate multiple commands on a
   single line.  */
const char line_separator_chars[] = ";";

/* Characters which are used to indicate an exponent in a floating
   point number.  */
const char EXP_CHARS[] = "eE";

/* Characters which mean that a number is a floating point constant,
   as in 0d1.0.  */
const char FLT_CHARS[] = "dD";

const relax_typeS md_relax_table[] =
 {
  /* bCC relaxing  */
  {0x81, -0x7e, 2, 1},
  {0x8004, -0x7ffb, 5, 2},
  {0x800006, -0x7ffff9, 7, 0},
  /* bCCx relaxing  */
  {0x81, -0x7e, 3, 4},
  {0x8004, -0x7ffb, 6, 5},
  {0x800006, -0x7ffff9, 8, 0},
  /* jsr relaxing  */
  {0x8004, -0x7ffb, 3, 7},
  {0x800006, -0x7ffff9, 5, 0},
  /* jmp relaxing  */
  {0x81, -0x7e, 2, 9},
  {0x8004, -0x7ffb, 3, 10},
  {0x800006, -0x7ffff9, 5, 0},

};


/* Fixups.  */
#define MAX_INSN_FIXUPS 5

struct mn10200_fixup
{
  expressionS exp;
  int opindex;
  bfd_reloc_code_real_type reloc;
};

struct mn10200_fixup fixups[MAX_INSN_FIXUPS];
static int fc;

const char *md_shortopts = "";

struct option md_longopts[] =
{
  {NULL, no_argument, NULL, 0}
};

size_t md_longopts_size = sizeof (md_longopts);

/* The target specific pseudo-ops which we support.  */
const pseudo_typeS md_pseudo_table[] =
{
  { NULL,       NULL,           0 }
};

/* Opcode hash table.  */
static struct hash_control *mn10200_hash;

/* This table is sorted. Suitable for searching by a binary search.  */
static const struct reg_name data_registers[] =
{
  { "d0", 0 },
  { "d1", 1 },
  { "d2", 2 },
  { "d3", 3 },
};
#define DATA_REG_NAME_CNT				\
  (sizeof (data_registers) / sizeof (struct reg_name))

static const struct reg_name address_registers[] =
{
  { "a0", 0 },
  { "a1", 1 },
  { "a2", 2 },
  { "a3", 3 },
};
#define ADDRESS_REG_NAME_CNT					\
  (sizeof (address_registers) / sizeof (struct reg_name))

static const struct reg_name other_registers[] =
{
  { "mdr", 0 },
  { "psw", 0 },
};
#define OTHER_REG_NAME_CNT				\
  (sizeof (other_registers) / sizeof (struct reg_name))

/* reg_name_search does a binary search of the given register table
   to see if "name" is a valid regiter name.  Returns the register
   number from the array on success, or -1 on failure.  */

static int
reg_name_search (const struct reg_name *regs,
		 int regcount,
		 const char *name)
{
  int middle, low, high;
  int cmp;

  low = 0;
  high = regcount - 1;

  do
    {
      middle = (low + high) / 2;
      cmp = strcasecmp (name, regs[middle].name);
      if (cmp < 0)
	high = middle - 1;
      else if (cmp > 0)
	low = middle + 1;
      else
	return regs[middle].value;
    }
  while (low <= high);
  return -1;
}

/* Summary of register_name().

   in: Input_line_pointer points to 1st char of operand.

   out: An expressionS.
  	The operand may have been a register: in this case, X_op == O_register,
  	X_add_number is set to the register number, and truth is returned.
  	Input_line_pointer->(next non-blank) char after operand, or is in
  	its original state.  */

static bfd_boolean
data_register_name (expressionS *expressionP)
{
  int reg_number;
  char *name;
  char *start;
  char c;

  /* Find the spelling of the operand.  */
  start = name = input_line_pointer;

  c = get_symbol_end ();
  reg_number = reg_name_search (data_registers, DATA_REG_NAME_CNT, name);

  /* Put back the delimiting char.  */
  *input_line_pointer = c;

  /* Look to see if it's in the register table.  */
  if (reg_number >= 0)
    {
      expressionP->X_op = O_register;
      expressionP->X_add_number = reg_number;

      /* Make the rest nice.  */
      expressionP->X_add_symbol = NULL;
      expressionP->X_op_symbol = NULL;

      return TRUE;
    }

  /* Reset the line as if we had not done anything.  */
  input_line_pointer = start;
  return FALSE;
}

/* Summary of register_name().

   in: Input_line_pointer points to 1st char of operand.

   out: An expressionS.
  	The operand may have been a register: in this case, X_op == O_register,
  	X_add_number is set to the register number, and truth is returned.
  	Input_line_pointer->(next non-blank) char after operand, or is in
  	its original state.  */

static bfd_boolean
address_register_name (expressionS *expressionP)
{
  int reg_number;
  char *name;
  char *start;
  char c;

  /* Find the spelling of the operand.  */
  start = name = input_line_pointer;

  c = get_symbol_end ();
  reg_number = reg_name_search (address_registers, ADDRESS_REG_NAME_CNT, name);

  /* Put back the delimiting char.  */
  *input_line_pointer = c;

  /* Look to see if it's in the register table.  */
  if (reg_number >= 0)
    {
      expressionP->X_op = O_register;
      expressionP->X_add_number = reg_number;

      /* Make the rest nice.  */
      expressionP->X_add_symbol = NULL;
      expressionP->X_op_symbol = NULL;

      return TRUE;
    }

  /* Reset the line as if we had not done anything.  */
  input_line_pointer = start;
  return FALSE;
}

/* Summary of register_name().

   in: Input_line_pointer points to 1st char of operand.

   out: An expressionS.
  	The operand may have been a register: in this case, X_op == O_register,
  	X_add_number is set to the register number, and truth is returned.
  	Input_line_pointer->(next non-blank) char after operand, or is in
  	its original state.  */

static bfd_boolean
other_register_name (expressionS *expressionP)
{
  int reg_number;
  char *name;
  char *start;
  char c;

  /* Find the spelling of the operand.  */
  start = name = input_line_pointer;

  c = get_symbol_end ();
  reg_number = reg_name_search (other_registers, OTHER_REG_NAME_CNT, name);

  /* Put back the delimiting char.  */
  *input_line_pointer = c;

  /* Look to see if it's in the register table.  */
  if (reg_number >= 0)
    {
      expressionP->X_op = O_register;
      expressionP->X_add_number = reg_number;

      /* Make the rest nice.  */
      expressionP->X_add_symbol = NULL;
      expressionP->X_op_symbol = NULL;

      return TRUE;
    }

  /* Reset the line as if we had not done anything.  */
  input_line_pointer = start;
  return FALSE;
}

void
md_show_usage (FILE *stream)
{
  fprintf (stream, _("MN10200 options:\n\
none yet\n"));
}

int
md_parse_option (int c ATTRIBUTE_UNUSED,
		 char *arg ATTRIBUTE_UNUSED)
{
  return 0;
}

symbolS *
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
{
  return 0;
}

char *
md_atof (int type, char *litp, int *sizep)
{
  return ieee_md_atof (type, litp, sizep, FALSE);
}

void
md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED,
		 asection *sec,
		 fragS *fragP)
{
  static unsigned long label_count = 0;
  char buf[40];

  subseg_change (sec, 0);
  if (fragP->fr_subtype == 0)
    {
      fix_new (fragP, fragP->fr_fix + 1, 1, fragP->fr_symbol,
	       fragP->fr_offset, 1, BFD_RELOC_8_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 2;
    }
  else if (fragP->fr_subtype == 1)
    {
      /* Reverse the condition of the first branch.  */
      int offset = fragP->fr_fix;
      int opcode = fragP->fr_literal[offset] & 0xff;

      switch (opcode)
	{
	case 0xe8:
	  opcode = 0xe9;
	  break;
	case 0xe9:
	  opcode = 0xe8;
	  break;
	case 0xe0:
	  opcode = 0xe2;
	  break;
	case 0xe2:
	  opcode = 0xe0;
	  break;
	case 0xe3:
	  opcode = 0xe1;
	  break;
	case 0xe1:
	  opcode = 0xe3;
	  break;
	case 0xe4:
	  opcode = 0xe6;
	  break;
	case 0xe6:
	  opcode = 0xe4;
	  break;
	case 0xe7:
	  opcode = 0xe5;
	  break;
	case 0xe5:
	  opcode = 0xe7;
	  break;
	default:
	  abort ();
	}
      fragP->fr_literal[offset] = opcode;

      /* Create a fixup for the reversed conditional branch.  */
      sprintf (buf, ".%s_%ld", FAKE_LABEL_NAME, label_count++);
      fix_new (fragP, fragP->fr_fix + 1, 1,
	       symbol_new (buf, sec, 0, fragP->fr_next),
	       fragP->fr_offset, 1, BFD_RELOC_8_PCREL);

      /* Now create the unconditional branch + fixup to the
	 final target.  */
      fragP->fr_literal[offset + 2] = 0xfc;
      fix_new (fragP, fragP->fr_fix + 3, 2, fragP->fr_symbol,
	       fragP->fr_offset, 1, BFD_RELOC_16_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 5;
    }
  else if (fragP->fr_subtype == 2)
    {
      /* Reverse the condition of the first branch.  */
      int offset = fragP->fr_fix;
      int opcode = fragP->fr_literal[offset] & 0xff;

      switch (opcode)
	{
	case 0xe8:
	  opcode = 0xe9;
	  break;
	case 0xe9:
	  opcode = 0xe8;
	  break;
	case 0xe0:
	  opcode = 0xe2;
	  break;
	case 0xe2:
	  opcode = 0xe0;
	  break;
	case 0xe3:
	  opcode = 0xe1;
	  break;
	case 0xe1:
	  opcode = 0xe3;
	  break;
	case 0xe4:
	  opcode = 0xe6;
	  break;
	case 0xe6:
	  opcode = 0xe4;
	  break;
	case 0xe7:
	  opcode = 0xe5;
	  break;
	case 0xe5:
	  opcode = 0xe7;
	  break;
	default:
	  abort ();
	}
      fragP->fr_literal[offset] = opcode;

      /* Create a fixup for the reversed conditional branch.  */
      sprintf (buf, ".%s_%ld", FAKE_LABEL_NAME, label_count++);
      fix_new (fragP, fragP->fr_fix + 1, 1,
	       symbol_new (buf, sec, 0, fragP->fr_next),
	       fragP->fr_offset, 1, BFD_RELOC_8_PCREL);

      /* Now create the unconditional branch + fixup to the
	 final target.  */
      fragP->fr_literal[offset + 2] = 0xf4;
      fragP->fr_literal[offset + 3] = 0xe0;
      fix_new (fragP, fragP->fr_fix + 4, 4, fragP->fr_symbol,
	       fragP->fr_offset, 1, BFD_RELOC_24_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 7;
    }
  else if (fragP->fr_subtype == 3)
    {
      fix_new (fragP, fragP->fr_fix + 2, 1, fragP->fr_symbol,
	       fragP->fr_offset, 1, BFD_RELOC_8_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 3;
    }
  else if (fragP->fr_subtype == 4)
    {
      /* Reverse the condition of the first branch.  */
      int offset = fragP->fr_fix;
      int opcode = fragP->fr_literal[offset + 1] & 0xff;

      switch (opcode)
	{
	case 0xfc:
	  opcode = 0xfd;
	  break;
	case 0xfd:
	  opcode = 0xfc;
	  break;
	case 0xfe:
	  opcode = 0xff;
	  break;
	case 0xff:
	  opcode = 0xfe;
	  break;
	case 0xe8:
	  opcode = 0xe9;
	  break;
	case 0xe9:
	  opcode = 0xe8;
	  break;
	case 0xe0:
	  opcode = 0xe2;
	  break;
	case 0xe2:
	  opcode = 0xe0;
	  break;
	case 0xe3:
	  opcode = 0xe1;
	  break;
	case 0xe1:
	  opcode = 0xe3;
	  break;
	case 0xe4:
	  opcode = 0xe6;
	  break;
	case 0xe6:
	  opcode = 0xe4;
	  break;
	case 0xe7:
	  opcode = 0xe5;
	  break;
	case 0xe5:
	  opcode = 0xe7;
	  break;
	case 0xec:
	  opcode = 0xed;
	  break;
	case 0xed:
	  opcode = 0xec;
	  break;
	case 0xee:
	  opcode = 0xef;
	  break;
	case 0xef:
	  opcode = 0xee;
	  break;
	default:
	  abort ();
	}
      fragP->fr_literal[offset + 1] = opcode;

      /* Create a fixup for the reversed conditional branch.  */
      sprintf (buf, ".%s_%ld", FAKE_LABEL_NAME, label_count++);
      fix_new (fragP, fragP->fr_fix + 2, 1,
	       symbol_new (buf, sec, 0, fragP->fr_next),
	       fragP->fr_offset, 1, BFD_RELOC_8_PCREL);

      /* Now create the unconditional branch + fixup to the
	 final target.  */
      fragP->fr_literal[offset + 3] = 0xfc;
      fix_new (fragP, fragP->fr_fix + 4, 2, fragP->fr_symbol,
	       fragP->fr_offset, 1, BFD_RELOC_16_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 6;
    }
  else if (fragP->fr_subtype == 5)
    {
      /* Reverse the condition of the first branch.  */
      int offset = fragP->fr_fix;
      int opcode = fragP->fr_literal[offset + 1] & 0xff;

      switch (opcode)
	{
	case 0xfc:
	  opcode = 0xfd;
	  break;
	case 0xfd:
	  opcode = 0xfc;
	  break;
	case 0xfe:
	  opcode = 0xff;
	  break;
	case 0xff:
	  opcode = 0xfe;
	  break;
	case 0xe8:
	  opcode = 0xe9;
	  break;
	case 0xe9:
	  opcode = 0xe8;
	  break;
	case 0xe0:
	  opcode = 0xe2;
	  break;
	case 0xe2:
	  opcode = 0xe0;
	  break;
	case 0xe3:
	  opcode = 0xe1;
	  break;
	case 0xe1:
	  opcode = 0xe3;
	  break;
	case 0xe4:
	  opcode = 0xe6;
	  break;
	case 0xe6:
	  opcode = 0xe4;
	  break;
	case 0xe7:
	  opcode = 0xe5;
	  break;
	case 0xe5:
	  opcode = 0xe7;
	  break;
	case 0xec:
	  opcode = 0xed;
	  break;
	case 0xed:
	  opcode = 0xec;
	  break;
	case 0xee:
	  opcode = 0xef;
	  break;
	case 0xef:
	  opcode = 0xee;
	  break;
	default:
	  abort ();
	}
      fragP->fr_literal[offset + 1] = opcode;

      /* Create a fixup for the reversed conditional branch.  */
      sprintf (buf, ".%s_%ld", FAKE_LABEL_NAME, label_count++);
      fix_new (fragP, fragP->fr_fix + 2, 1,
	       symbol_new (buf, sec, 0, fragP->fr_next),
	       fragP->fr_offset, 1, BFD_RELOC_8_PCREL);

      /* Now create the unconditional branch + fixup to the
	 final target.  */
      fragP->fr_literal[offset + 3] = 0xf4;
      fragP->fr_literal[offset + 4] = 0xe0;
      fix_new (fragP, fragP->fr_fix + 5, 4, fragP->fr_symbol,
	       fragP->fr_offset, 1, BFD_RELOC_24_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 8;
    }
  else if (fragP->fr_subtype == 6)
    {
      fix_new (fragP, fragP->fr_fix + 1, 2, fragP->fr_symbol,
	       fragP->fr_offset, 1, BFD_RELOC_16_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 3;
    }
  else if (fragP->fr_subtype == 7)
    {
      int offset = fragP->fr_fix;
      fragP->fr_literal[offset] = 0xf4;
      fragP->fr_literal[offset + 1] = 0xe1;

      fix_new (fragP, fragP->fr_fix + 2, 4, fragP->fr_symbol,
	       fragP->fr_offset, 1, BFD_RELOC_24_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 5;
    }
  else if (fragP->fr_subtype == 8)
    {
      fragP->fr_literal[fragP->fr_fix] = 0xea;
      fix_new (fragP, fragP->fr_fix + 1, 1, fragP->fr_symbol,
	       fragP->fr_offset, 1, BFD_RELOC_8_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 2;
    }
  else if (fragP->fr_subtype == 9)
    {
      int offset = fragP->fr_fix;
      fragP->fr_literal[offset] = 0xfc;

      fix_new (fragP, fragP->fr_fix + 1, 4, fragP->fr_symbol,
	       fragP->fr_offset, 1, BFD_RELOC_16_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 3;
    }
  else if (fragP->fr_subtype == 10)
    {
      int offset = fragP->fr_fix;
      fragP->fr_literal[offset] = 0xf4;
      fragP->fr_literal[offset + 1] = 0xe0;

      fix_new (fragP, fragP->fr_fix + 2, 4, fragP->fr_symbol,
	       fragP->fr_offset, 1, BFD_RELOC_24_PCREL);
      fragP->fr_var = 0;
      fragP->fr_fix += 5;
    }
  else
    abort ();
}

valueT
md_section_align (asection *seg, valueT addr)
{
  int align = bfd_get_section_alignment (stdoutput, seg);
  return ((addr + (1 << align) - 1) & (-1 << align));
}

void
md_begin (void)
{
  char *prev_name = "";
  register const struct mn10200_opcode *op;

  mn10200_hash = hash_new ();

  /* Insert unique names into hash table.  The MN10200 instruction set
     has many identical opcode names that have different opcodes based
     on the operands.  This hash table then provides a quick index to
     the first opcode with a particular name in the opcode table.  */

  op = mn10200_opcodes;
  while (op->name)
    {
      if (strcmp (prev_name, op->name))
	{
	  prev_name = (char *) op->name;
	  hash_insert (mn10200_hash, op->name, (char *) op);
	}
      op++;
    }

  /* This is both a simplification (we don't have to write md_apply_fix)
     and support for future optimizations (branch shortening and similar
     stuff in the linker.  */
  linkrelax = 1;
}

static unsigned long
check_operand (unsigned long insn ATTRIBUTE_UNUSED,
	       const struct mn10200_operand *operand,
	       offsetT val)
{
  /* No need to check 24bit or 32bit operands for a bit.  */
  if (operand->bits < 24
      && (operand->flags & MN10200_OPERAND_NOCHECK) == 0)
    {
      long min, max;
      offsetT test;

      if ((operand->flags & MN10200_OPERAND_SIGNED) != 0)
	{
	  max = (1 << (operand->bits - 1)) - 1;
	  min = - (1 << (operand->bits - 1));
	}
      else
	{
	  max = (1 << operand->bits) - 1;
	  min = 0;
	}

      test = val;

      if (test < (offsetT) min || test > (offsetT) max)
	return 0;
      else
	return 1;
    }
  return 1;
}
/* If while processing a fixup, a reloc really needs to be created
   Then it is done here.  */

arelent *
tc_gen_reloc (asection *seg ATTRIBUTE_UNUSED, fixS *fixp)
{
  arelent *reloc;
  reloc = xmalloc (sizeof (arelent));

  if (fixp->fx_subsy != NULL)
    {
      if (S_GET_SEGMENT (fixp->fx_addsy) == S_GET_SEGMENT (fixp->fx_subsy)
	  && S_IS_DEFINED (fixp->fx_subsy))
	{
	  fixp->fx_offset -= S_GET_VALUE (fixp->fx_subsy);
	  fixp->fx_subsy = NULL;
	}
      else
	/* FIXME: We should try more ways to resolve difference expressions
	   here.  At least this is better than silently ignoring the
	   subtrahend.  */
	as_bad_where (fixp->fx_file, fixp->fx_line,
		      _("can't resolve `%s' {%s section} - `%s' {%s section}"),
		      fixp->fx_addsy ? S_GET_NAME (fixp->fx_addsy) : "0",
		      segment_name (fixp->fx_addsy
				    ? S_GET_SEGMENT (fixp->fx_addsy)
				    : absolute_section),
		      S_GET_NAME (fixp->fx_subsy),
		      segment_name (S_GET_SEGMENT (fixp->fx_addsy)));
    }

  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
  if (reloc->howto == NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("reloc %d not supported by object file format"),
		    (int) fixp->fx_r_type);
      return NULL;
    }
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
  reloc->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->addend = fixp->fx_offset;
  return reloc;
}

int
md_estimate_size_before_relax (fragS *fragp, asection *seg)
{
  if (fragp->fr_subtype == 6
      && (!S_IS_DEFINED (fragp->fr_symbol)
	  || seg != S_GET_SEGMENT (fragp->fr_symbol)))
    fragp->fr_subtype = 7;
  else if (fragp->fr_subtype == 8
	   && (!S_IS_DEFINED (fragp->fr_symbol)
	       || seg != S_GET_SEGMENT (fragp->fr_symbol)))
    fragp->fr_subtype = 10;

  if (fragp->fr_subtype >= sizeof (md_relax_table) / sizeof (md_relax_table[0]))
    abort ();

  return md_relax_table[fragp->fr_subtype].rlx_length;
}

long
md_pcrel_from (fixS *fixp)
{
  return fixp->fx_frag->fr_address;
}

void
md_apply_fix (fixS * fixP, valueT * valP ATTRIBUTE_UNUSED, segT seg ATTRIBUTE_UNUSED)
{
  /* We shouldn't ever get here because linkrelax is nonzero.  */
  abort ();
  fixP->fx_done = 1;
}

/* Insert an operand value into an instruction.  */

static void
mn10200_insert_operand (unsigned long *insnp,
			unsigned long *extensionp,
			const struct mn10200_operand *operand,
			offsetT val,
			char *file,
			unsigned int line,
			unsigned int shift)
{
  /* No need to check 24 or 32bit operands for a bit.  */
  if (operand->bits < 24
      && (operand->flags & MN10200_OPERAND_NOCHECK) == 0)
    {
      long min, max;
      offsetT test;

      if ((operand->flags & MN10200_OPERAND_SIGNED) != 0)
	{
	  max = (1 << (operand->bits - 1)) - 1;
	  min = - (1 << (operand->bits - 1));
	}
      else
	{
	  max = (1 << operand->bits) - 1;
	  min = 0;
	}

      test = val;

      if (test < (offsetT) min || test > (offsetT) max)
	as_warn_value_out_of_range (_("operand"), test, (offsetT) min, (offsetT) max, file, line);
    }

  if ((operand->flags & MN10200_OPERAND_EXTENDED) == 0)
    {
      *insnp |= (((long) val & ((1 << operand->bits) - 1))
		 << (operand->shift + shift));

      if ((operand->flags & MN10200_OPERAND_REPEATED) != 0)
	*insnp |= (((long) val & ((1 << operand->bits) - 1))
		   << (operand->shift + shift + 2));
    }
  else
    {
      *extensionp |= (val >> 16) & 0xff;
      *insnp |= val & 0xffff;
    }
}

void
md_assemble (char *str)
{
  char *s;
  struct mn10200_opcode *opcode;
  struct mn10200_opcode *next_opcode;
  const unsigned char *opindex_ptr;
  int next_opindex, relaxable;
  unsigned long insn, extension, size = 0;
  char *f;
  int i;
  int match;

  /* Get the opcode.  */
  for (s = str; *s != '\0' && !ISSPACE (*s); s++)
    ;
  if (*s != '\0')
    *s++ = '\0';

  /* Find the first opcode with the proper name.  */
  opcode = (struct mn10200_opcode *) hash_find (mn10200_hash, str);
  if (opcode == NULL)
    {
      as_bad (_("Unrecognized opcode: `%s'"), str);
      return;
    }

  str = s;
  while (ISSPACE (*str))
    ++str;

  input_line_pointer = str;

  for (;;)
    {
      const char *errmsg = NULL;
      int op_idx;
      char *hold;
      int extra_shift = 0;

      relaxable = 0;
      fc = 0;
      match = 0;
      next_opindex = 0;
      insn = opcode->opcode;
      extension = 0;
      for (op_idx = 1, opindex_ptr = opcode->operands;
	   *opindex_ptr != 0;
	   opindex_ptr++, op_idx++)
	{
	  const struct mn10200_operand *operand;
	  expressionS ex;

	  if (next_opindex == 0)
	    {
	      operand = &mn10200_operands[*opindex_ptr];
	    }
	  else
	    {
	      operand = &mn10200_operands[next_opindex];
	      next_opindex = 0;
	    }

	  errmsg = NULL;

	  while (*str == ' ' || *str == ',')
	    ++str;

	  if (operand->flags & MN10200_OPERAND_RELAX)
	    relaxable = 1;

	  /* Gather the operand.  */
	  hold = input_line_pointer;
	  input_line_pointer = str;

	  if (operand->flags & MN10200_OPERAND_PAREN)
	    {
	      if (*input_line_pointer != ')' && *input_line_pointer != '(')
		{
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}
	      input_line_pointer++;
	      goto keep_going;
	    }
	  /* See if we can match the operands.  */
	  else if (operand->flags & MN10200_OPERAND_DREG)
	    {
	      if (!data_register_name (&ex))
		{
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}
	    }
	  else if (operand->flags & MN10200_OPERAND_AREG)
	    {
	      if (!address_register_name (&ex))
		{
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}
	    }
	  else if (operand->flags & MN10200_OPERAND_PSW)
	    {
	      char *start = input_line_pointer;
	      char c = get_symbol_end ();

	      if (strcmp (start, "psw") != 0)
		{
		  *input_line_pointer = c;
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}
	      *input_line_pointer = c;
	      goto keep_going;
	    }
	  else if (operand->flags & MN10200_OPERAND_MDR)
	    {
	      char *start = input_line_pointer;
	      char c = get_symbol_end ();

	      if (strcmp (start, "mdr") != 0)
		{
		  *input_line_pointer = c;
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}
	      *input_line_pointer = c;
	      goto keep_going;
	    }
	  else if (data_register_name (&ex))
	    {
	      input_line_pointer = hold;
	      str = hold;
	      goto error;
	    }
	  else if (address_register_name (&ex))
	    {
	      input_line_pointer = hold;
	      str = hold;
	      goto error;
	    }
	  else if (other_register_name (&ex))
	    {
	      input_line_pointer = hold;
	      str = hold;
	      goto error;
	    }
	  else if (*str == ')' || *str == '(')
	    {
	      input_line_pointer = hold;
	      str = hold;
	      goto error;
	    }
	  else
	    {
	      expression (&ex);
	    }

	  switch (ex.X_op)
	    {
	    case O_illegal:
	      errmsg = _("illegal operand");
	      goto error;
	    case O_absent:
	      errmsg = _("missing operand");
	      goto error;
	    case O_register:
	      if ((operand->flags
		   & (MN10200_OPERAND_DREG | MN10200_OPERAND_AREG)) == 0)
		{
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}

	      if (opcode->format == FMT_2 || opcode->format == FMT_5)
		extra_shift = 8;
	      else if (opcode->format == FMT_3 || opcode->format == FMT_6
		       || opcode->format == FMT_7)
		extra_shift = 16;
	      else
		extra_shift = 0;

	      mn10200_insert_operand (&insn, &extension, operand,
				      ex.X_add_number, NULL,
				      0, extra_shift);

	      break;

	    case O_constant:
	      /* If this operand can be promoted, and it doesn't
		 fit into the allocated bitfield for this insn,
		 then promote it (ie this opcode does not match).  */
	      if (operand->flags
		  & (MN10200_OPERAND_PROMOTE | MN10200_OPERAND_RELAX)
		  && !check_operand (insn, operand, ex.X_add_number))
		{
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}

	      mn10200_insert_operand (&insn, &extension, operand,
				      ex.X_add_number, NULL,
				      0, 0);
	      break;

	    default:
	      /* If this operand can be promoted, then this opcode didn't
		 match since we can't know if it needed promotion!  */
	      if (operand->flags & MN10200_OPERAND_PROMOTE)
		{
		  input_line_pointer = hold;
		  str = hold;
		  goto error;
		}

	      /* We need to generate a fixup for this expression.  */
	      if (fc >= MAX_INSN_FIXUPS)
		as_fatal (_("too many fixups"));
	      fixups[fc].exp = ex;
	      fixups[fc].opindex = *opindex_ptr;
	      fixups[fc].reloc = BFD_RELOC_UNUSED;
	      ++fc;
	      break;
	    }

keep_going:
	  str = input_line_pointer;
	  input_line_pointer = hold;

	  while (*str == ' ' || *str == ',')
	    ++str;

	}

      /* Make sure we used all the operands!  */
      if (*str != ',')
	match = 1;

    error:
      if (match == 0)
	{
	  next_opcode = opcode + 1;
	  if (!strcmp (next_opcode->name, opcode->name))
	    {
	      opcode = next_opcode;
	      continue;
	    }

	  as_bad ("%s", errmsg);
	  return;
	}
      break;
    }

  while (ISSPACE (*str))
    ++str;

  if (*str != '\0')
    as_bad (_("junk at end of line: `%s'"), str);

  input_line_pointer = str;

  if (opcode->format == FMT_1)
    size = 1;
  else if (opcode->format == FMT_2 || opcode->format == FMT_4)
    size = 2;
  else if (opcode->format == FMT_3 || opcode->format == FMT_5)
    size = 3;
  else if (opcode->format == FMT_6)
    size = 4;
  else if (opcode->format == FMT_7)
    size = 5;
  else
    abort ();

  /* Write out the instruction.  */
  dwarf2_emit_insn (0);
  if (relaxable && fc > 0)
    {
      /* On a 64-bit host the size of an 'int' is not the same
	 as the size of a pointer, so we need a union to convert
	 the opindex field of the fr_cgen structure into a char *
	 so that it can be stored in the frag.  We do not have
	 to worry about loosing accuracy as we are not going to
	 be even close to the 32bit limit of the int.  */
      union
      {
	int opindex;
	char * ptr;
      }
      opindex_converter;
      int type;

      /* bCC  */
      if (size == 2 && opcode->opcode != 0xfc0000)
	{
	  /* Handle bra specially.  Basically treat it like jmp so
	     that we automatically handle 8, 16 and 32 bit offsets
	     correctly as well as jumps to an undefined address.

	     It is also important to not treat it like other bCC
	     instructions since the long forms of bra is different
	     from other bCC instructions.  */
	  if (opcode->opcode == 0xea00)
	    type = 8;
	  else
	    type = 0;
	}
      /* jsr  */
      else if (size == 3 && opcode->opcode == 0xfd0000)
	type = 6;
      /* jmp  */
      else if (size == 3 && opcode->opcode == 0xfc0000)
	type = 8;
      /* bCCx  */
      else
	type = 3;

      opindex_converter.opindex = fixups[0].opindex;
      f = frag_var (rs_machine_dependent, 8, 8 - size, type,
		    fixups[0].exp.X_add_symbol,
		    fixups[0].exp.X_add_number,
		    opindex_converter.ptr);
      number_to_chars_bigendian (f, insn, size);
      if (8 - size > 4)
	{
	  number_to_chars_bigendian (f + size, 0, 4);
	  number_to_chars_bigendian (f + size + 4, 0, 8 - size - 4);
	}
      else
	number_to_chars_bigendian (f + size, 0, 8 - size);
    }
  else
    {
      f = frag_more (size);

      /* Oh, what a mess.  The instruction is in big endian format, but
	 16 and 24bit immediates are little endian!  */
      if (opcode->format == FMT_3)
	{
	  number_to_chars_bigendian (f, (insn >> 16) & 0xff, 1);
	  number_to_chars_littleendian (f + 1, insn & 0xffff, 2);
	}
      else if (opcode->format == FMT_6)
	{
	  number_to_chars_bigendian (f, (insn >> 16) & 0xffff, 2);
	  number_to_chars_littleendian (f + 2, insn & 0xffff, 2);
	}
      else if (opcode->format == FMT_7)
	{
	  number_to_chars_bigendian (f, (insn >> 16) & 0xffff, 2);
	  number_to_chars_littleendian (f + 2, insn & 0xffff, 2);
	  number_to_chars_littleendian (f + 4, extension & 0xff, 1);
	}
      else
	number_to_chars_bigendian (f, insn, size > 4 ? 4 : size);

      /* Create any fixups.  */
      for (i = 0; i < fc; i++)
	{
	  const struct mn10200_operand *operand;
	  int reloc_size;

	  operand = &mn10200_operands[fixups[i].opindex];
	  if (fixups[i].reloc != BFD_RELOC_UNUSED)
	    {
	      reloc_howto_type *reloc_howto;
	      int offset;
	      fixS *fixP;

	      reloc_howto = bfd_reloc_type_lookup (stdoutput,
						   fixups[i].reloc);

	      if (!reloc_howto)
		abort ();

	      reloc_size = bfd_get_reloc_size (reloc_howto);

	      if (reloc_size < 1 || reloc_size > 4)
		abort ();

	      offset = 4 - reloc_size;
	      fixP = fix_new_exp (frag_now, f - frag_now->fr_literal + offset,
				  reloc_size,
				  &fixups[i].exp,
				  reloc_howto->pc_relative,
				  fixups[i].reloc);

	      /* PC-relative offsets are from the first byte of the
		 next instruction, not from the start of the current
		 instruction.  */
	      if (reloc_howto->pc_relative)
		fixP->fx_offset += reloc_size;
	    }
	  else
	    {
	      int reloc, pcrel, offset;
	      fixS *fixP;

	      reloc = BFD_RELOC_NONE;
	      /* How big is the reloc?  Remember SPLIT relocs are
		 implicitly 32bits.  */
	      reloc_size = operand->bits;

	      offset = size - reloc_size / 8;

	      /* Is the reloc pc-relative?  */
	      pcrel = (operand->flags & MN10200_OPERAND_PCREL) != 0;

	      /* Choose a proper BFD relocation type.  */
	      if (pcrel)
		{
		  if (reloc_size == 8)
		    reloc = BFD_RELOC_8_PCREL;
		  else if (reloc_size == 24)
		    reloc = BFD_RELOC_24_PCREL;
		  else
		    abort ();
		}
	      else
		{
		  if (reloc_size == 32)
		    reloc = BFD_RELOC_32;
		  else if (reloc_size == 16)
		    reloc = BFD_RELOC_16;
		  else if (reloc_size == 8)
		    reloc = BFD_RELOC_8;
		  else if (reloc_size == 24)
		    reloc = BFD_RELOC_24;
		  else
		    abort ();
		}

	      /* Convert the size of the reloc into what fix_new_exp
                 wants.  */
	      reloc_size = reloc_size / 8;
	      if (reloc_size == 8)
		reloc_size = 0;
	      else if (reloc_size == 16)
		reloc_size = 1;
	      else if (reloc_size == 32 || reloc_size == 24)
		reloc_size = 2;

	      fixP = fix_new_exp (frag_now, f - frag_now->fr_literal + offset,
				  reloc_size, &fixups[i].exp, pcrel,
				  ((bfd_reloc_code_real_type) reloc));

	      /* PC-relative offsets are from the first byte of the
		 next instruction, not from the start of the current
		 instruction.  */
	      if (pcrel)
		fixP->fx_offset += size;
	    }
	}
    }
}

@


1.26
log
@	* config/tc-mn10200.c (md_convert_frag): Add missing break.
@
text
@d2 1
a2 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
   2005, 2006, 2007, 2009  Free Software Foundation, Inc.
d564 1
@


1.25
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d484 1
@


1.24
log
@	* read.c (emit_expr_fix): Handle size 3.
	* config/tc-avr.c (md_assemble): Call dwarf2_emit_insn.
	* config/tc-d30v.c (write_long, write_1_short,
	write_2_short, md_assemble): Likewise.
	* config/tc-dlx.c (md_assemble): Likewise.
	* config/tc-i860.c (md_assemble): Likewise.
	* config/tc-mn10200.c (md_assemble): Likewise.
	* config/tc-pj.c (md_assemble): Likewise.
	* config/tc-vax.c (md_assemble): Likewise.
@
text
@d1244 1
a1249 1
	      int size;
d1259 1
a1259 1
	      size = bfd_get_reloc_size (reloc_howto);
d1261 1
a1261 1
	      if (size < 1 || size > 4)
d1264 1
a1264 1
	      offset = 4 - size;
d1266 1
a1266 1
				  size,
d1275 1
a1275 1
		fixP->fx_offset += size;
d1279 1
a1279 1
	      int reloc, pcrel, reloc_size, offset;
@


1.23
log
@Remove duplicate definitions of the md_atof() function
@
text
@d3 1
a3 1
   2005, 2006, 2007  Free Software Foundation, Inc.
d1159 1
@


1.23.8.1
log
@gas/
	* read.c (emit_expr_fix): Handle size 3.
	* config/tc-avr.c (md_assemble): Call dwarf2_emit_insn.
	* config/tc-d30v.c (write_long, write_1_short,
	write_2_short, md_assemble): Likewise.
	* config/tc-dlx.c (md_assemble): Likewise.
	* config/tc-i860.c (md_assemble): Likewise.
	* config/tc-mn10200.c (md_assemble): Likewise.
	* config/tc-pj.c (md_assemble): Likewise.
	* config/tc-vax.c (md_assemble): Likewise.
gas/testsuite/
	* gas/d30v/serial2.l: Adjust position of page break.
	* gas/lns/lns-common-1-alt.d: Match 2009-04-24 change.
	* gas/mt/ms1-16-003.d: Correct reloc name.
	* gas/mt/relocs.d: Elide incorrect file format strings.
@
text
@d3 1
a3 1
   2005, 2006, 2007, 2009  Free Software Foundation, Inc.
a1158 1
  dwarf2_emit_insn (0);
@


1.22
log
@Switch to GPLv3
@
text
@d324 1
a324 33
  int prec;
  LITTLENUM_TYPE words[4];
  char *t;
  int i;

  switch (type)
    {
    case 'f':
      prec = 2;
      break;

    case 'd':
      prec = 4;
      break;

    default:
      *sizep = 0;
      return _("bad call to md_atof");
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizep = prec * 2;

  for (i = prec - 1; i >= 0; i--)
    {
      md_number_to_chars (litp, (valueT) words[i], 2);
      litp += 2;
    }

  return NULL;
@


1.21
log
@remove some duplicate #include's.
@
text
@d3 1
a3 1
   2005, 2006  Free Software Foundation, Inc.
d9 1
a9 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.20
log
@Fixes for building on 64-bit hosts:
        * config/tc-avr.c (mod_index): New union to allow conversion
        between pointers and integers.
        (md_begin, avr_ldi_expression): Use it.
        * config/tc-i370.c (md_assemble): Add cast for argument to print
        statement.
        * config/tc-tic54x.c (subsym_substitute): Likewise.
        * config/tc-mn10200.c (md_assemble): Use a union to convert the
        opindex field of fr_cgen structure into a pointer so that it can
        be stored in a frag.
        * config/tc-mn10300.c (md_assemble): Likewise.
        * config/tc-frv.c (frv_debug_tomcat): Use %p to print pointer
        types.
        * config/tc-v850.c: Replace uses of (int) casts with correct
        types.
        * gas/tic54x/address.d: Work with 64bit hosts.
        * gas/tic54x/addrfar.d: Likewise.
        * gas/tic54x/align.d: Likewise.
        * gas/tic54x/all-opcodes.d: Likewise.
        * gas/tic54x/asg.d: Likewise.
        * gas/tic54x/cons.d: Likewise.
        * gas/tic54x/consfar.d: Likewise.
        * gas/tic54x/extaddr.d: Likewise.
        * gas/tic54x/field.d: Likewise.
        * gas/tic54x/labels.d: Likewise.
        * gas/tic54x/loop.d: Likewise.
        * gas/tic54x/lp.d: Likewise.
        * gas/tic54x/macro.d: Likewise.
        * gas/tic54x/math.d: Likewise.
        * gas/tic54x/opcodes.d: Likewise.
        * gas/tic54x/sections.d: Likewise.
       * gas/tic54x/set.d: Likewise.
       * gas/tic54x/struct.d: Likewise.
       * gas/tic54x/subsym.d: Likewise.
@
text
@a21 1
#include <stdio.h>
@


1.19
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@d3 1
a3 1
   2005  Free Software Foundation, Inc.
d1194 12
d1233 1
d1237 1
a1237 1
		    (char *)fixups[0].opindex);
@


1.18
log
@Update the address and phone number of the FSF
@
text
@d741 1
a741 1
  /* This is both a simplification (we don't have to write md_apply_fix3)
d850 1
a850 1
md_apply_fix3 (fixS * fixP, valueT * valP ATTRIBUTE_UNUSED, segT seg ATTRIBUTE_UNUSED)
@


1.17
log
@Convert unmaintained files over to ISO-C90 and fix formatting.
@
text
@d19 2
a20 2
   the Free Software Foundation, 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.16
log
@(tc_gen_reloc): Handle the case where the reloc is the difference of two
symbols defined in the same section.
@
text
@d2 2
a3 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
d56 2
a57 1
const relax_typeS md_relax_table[] = {
a75 12
/* Local functions.  */
static void mn10200_insert_operand PARAMS ((unsigned long *, unsigned long *,
					    const struct mn10200_operand *,
					    offsetT, char *, unsigned,
					    unsigned));
static unsigned long check_operand PARAMS ((unsigned long,
					    const struct mn10200_operand *,
					    offsetT));
static int reg_name_search PARAMS ((const struct reg_name *, int, const char *));
static bfd_boolean data_register_name PARAMS ((expressionS *expressionP));
static bfd_boolean address_register_name PARAMS ((expressionS *expressionP));
static bfd_boolean other_register_name PARAMS ((expressionS *expressionP));
d78 2
a79 1
#define MAX_INSN_FIXUPS (5)
d86 1
d91 3
a93 1
struct option md_longopts[] = {
d96 1
d142 3
a144 4
reg_name_search (regs, regcount, name)
     const struct reg_name *regs;
     int regcount;
     const char *name;
d168 8
a175 9
 *
 * in: Input_line_pointer points to 1st char of operand.
 *
 * out: An expressionS.
 *	The operand may have been a register: in this case, X_op == O_register,
 *	X_add_number is set to the register number, and truth is returned.
 *	Input_line_pointer->(next non-blank) char after operand, or is in
 *	its original state.
 */
d178 1
a178 2
data_register_name (expressionP)
     expressionS *expressionP;
d213 8
a220 9
 *
 * in: Input_line_pointer points to 1st char of operand.
 *
 * out: An expressionS.
 *	The operand may have been a register: in this case, X_op == O_register,
 *	X_add_number is set to the register number, and truth is returned.
 *	Input_line_pointer->(next non-blank) char after operand, or is in
 *	its original state.
 */
d223 1
a223 2
address_register_name (expressionP)
     expressionS *expressionP;
d258 8
a265 9
 *
 * in: Input_line_pointer points to 1st char of operand.
 *
 * out: An expressionS.
 *	The operand may have been a register: in this case, X_op == O_register,
 *	X_add_number is set to the register number, and truth is returned.
 *	Input_line_pointer->(next non-blank) char after operand, or is in
 *	its original state.
 */
d268 1
a268 2
other_register_name (expressionP)
     expressionS *expressionP;
d303 1
a303 2
md_show_usage (stream)
     FILE *stream;
d310 2
a311 3
md_parse_option (c, arg)
     int c ATTRIBUTE_UNUSED;
     char *arg ATTRIBUTE_UNUSED;
d317 1
a317 2
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
d323 1
a323 4
md_atof (type, litp, sizep)
     int type;
     char *litp;
     int *sizep;
d361 3
a363 4
md_convert_frag (abfd, sec, fragP)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     fragS *fragP;
d711 1
a711 3
md_section_align (seg, addr)
     asection *seg;
     valueT addr;
d718 1
a718 1
md_begin ()
d747 102
d850 60
a909 2
md_assemble (str)
     char *str;
d1098 1
a1098 1
				      ex.X_add_number, (char *) NULL,
d1117 1
a1117 1
				      ex.X_add_number, (char *) NULL,
a1191 1

a1233 1

d1257 1
a1257 3
	{
	  number_to_chars_bigendian (f, insn, size > 4 ? 4 : size);
	}
a1358 171
/* If while processing a fixup, a reloc really needs to be created
   Then it is done here.  */

arelent *
tc_gen_reloc (seg, fixp)
     asection *seg ATTRIBUTE_UNUSED;
     fixS *fixp;
{
  arelent *reloc;
  reloc = (arelent *) xmalloc (sizeof (arelent));

  if (fixp->fx_subsy != NULL)
    {
      if (S_GET_SEGMENT (fixp->fx_addsy) == S_GET_SEGMENT (fixp->fx_subsy)
	  && S_IS_DEFINED (fixp->fx_subsy))
	{
	  fixp->fx_offset -= S_GET_VALUE (fixp->fx_subsy);
	  fixp->fx_subsy = NULL;
	}
      else
	/* FIXME: We should try more ways to resolve difference expressions
	   here.  At least this is better than silently ignoring the
	   subtrahend.  */
	as_bad_where (fixp->fx_file, fixp->fx_line,
		      _("can't resolve `%s' {%s section} - `%s' {%s section}"),
		      fixp->fx_addsy ? S_GET_NAME (fixp->fx_addsy) : "0",
		      segment_name (fixp->fx_addsy
				    ? S_GET_SEGMENT (fixp->fx_addsy)
				    : absolute_section),
		      S_GET_NAME (fixp->fx_subsy),
		      segment_name (S_GET_SEGMENT (fixp->fx_addsy)));
    }

  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
  if (reloc->howto == (reloc_howto_type *) NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("reloc %d not supported by object file format"),
		    (int) fixp->fx_r_type);
      return NULL;
    }
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->addend = fixp->fx_offset;
  return reloc;
}

int
md_estimate_size_before_relax (fragp, seg)
     fragS *fragp;
     asection *seg;
{
  if (fragp->fr_subtype == 6
      && (!S_IS_DEFINED (fragp->fr_symbol)
	  || seg != S_GET_SEGMENT (fragp->fr_symbol)))
    fragp->fr_subtype = 7;
  else if (fragp->fr_subtype == 8
	   && (!S_IS_DEFINED (fragp->fr_symbol)
	       || seg != S_GET_SEGMENT (fragp->fr_symbol)))
    fragp->fr_subtype = 10;

  if (fragp->fr_subtype >= sizeof (md_relax_table) / sizeof (md_relax_table[0]))
    abort ();

  return md_relax_table[fragp->fr_subtype].rlx_length;
}

long
md_pcrel_from (fixp)
     fixS *fixp;
{
  return fixp->fx_frag->fr_address;
}

void
md_apply_fix3 (fixP, valP, seg)
     fixS * fixP;
     valueT * valP ATTRIBUTE_UNUSED;
     segT seg ATTRIBUTE_UNUSED;
{
  /* We shouldn't ever get here because linkrelax is nonzero.  */
  abort ();
  fixP->fx_done = 1;
}

/* Insert an operand value into an instruction.  */

static void
mn10200_insert_operand (insnp, extensionp, operand, val, file, line, shift)
     unsigned long *insnp;
     unsigned long *extensionp;
     const struct mn10200_operand *operand;
     offsetT val;
     char *file;
     unsigned int line;
     unsigned int shift;
{
  /* No need to check 24 or 32bit operands for a bit.  */
  if (operand->bits < 24
      && (operand->flags & MN10200_OPERAND_NOCHECK) == 0)
    {
      long min, max;
      offsetT test;

      if ((operand->flags & MN10200_OPERAND_SIGNED) != 0)
	{
	  max = (1 << (operand->bits - 1)) - 1;
	  min = - (1 << (operand->bits - 1));
	}
      else
	{
	  max = (1 << operand->bits) - 1;
	  min = 0;
	}

      test = val;

      if (test < (offsetT) min || test > (offsetT) max)
	as_warn_value_out_of_range (_("operand"), test, (offsetT) min, (offsetT) max, file, line);
    }

  if ((operand->flags & MN10200_OPERAND_EXTENDED) == 0)
    {
      *insnp |= (((long) val & ((1 << operand->bits) - 1))
		 << (operand->shift + shift));

      if ((operand->flags & MN10200_OPERAND_REPEATED) != 0)
	*insnp |= (((long) val & ((1 << operand->bits) - 1))
		   << (operand->shift + shift + 2));
    }
  else
    {
      *extensionp |= (val >> 16) & 0xff;
      *insnp |= val & 0xffff;
    }
}

static unsigned long
check_operand (insn, operand, val)
     unsigned long insn ATTRIBUTE_UNUSED;
     const struct mn10200_operand *operand;
     offsetT val;
{
  /* No need to check 24bit or 32bit operands for a bit.  */
  if (operand->bits < 24
      && (operand->flags & MN10200_OPERAND_NOCHECK) == 0)
    {
      long min, max;
      offsetT test;

      if ((operand->flags & MN10200_OPERAND_SIGNED) != 0)
	{
	  max = (1 << (operand->bits - 1)) - 1;
	  min = - (1 << (operand->bits - 1));
	}
      else
	{
	  max = (1 << operand->bits) - 1;
	  min = 0;
	}

      test = val;

      if (test < (offsetT) min || test > (offsetT) max)
	return 0;
      else
	return 1;
    }
  return 1;
}
@


1.15
log
@update copyright dates
@
text
@d1238 18
a1255 11
      /* FIXME: We should resolve difference expressions if possible
	 here.  At least this is better than silently ignoring the
	 subtrahend.  */
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("can't resolve `%s' {%s section} - `%s' {%s section}"),
		    fixp->fx_addsy ? S_GET_NAME (fixp->fx_addsy) : "0",
		    segment_name (fixp->fx_addsy
				  ? S_GET_SEGMENT (fixp->fx_addsy)
				  : absolute_section),
		    S_GET_NAME (fixp->fx_subsy),
		    segment_name (S_GET_SEGMENT (fixp->fx_addsy)));
@


1.14
log
@	* config/atof-ieee.c, config/obj-coff.c, config/obj-elf.c,
	config/obj-ieee.c, config/obj-som.c, config/obj-vms.c,
	config/tc-a29k.c, config/tc-alpha.c, config/tc-arc.c,
	config/tc-arm.c, config/tc-d30v.c, config/tc-dlx.c,
	config/tc-fr30.c, config/tc-h8300.c, config/tc-h8500.c,
	config/tc-i370.c, config/tc-i386.c, config/tc-i960.c,
	config/tc-ia64.c, config/tc-m32r.c, config/tc-m32r.h,
	config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-mips.c,
	config/tc-mn10200.c, config/tc-msp430.c, config/tc-ns32k.c,
	config/tc-openrisc.c, config/tc-or32.c, config/tc-pdp11.c,
	config/tc-pj.c, config/tc-sparc.h, config/tc-tic54x.c,
	config/tc-tic80.c, config/tc-v850.c, config/tc-w65.c,
	config/tc-xtensa.c, config/tc-z8k.c, config/xtensa-relax.c: Remove
	#if 0'd code throughout.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
@


1.13
log
@Remove duplicate code and provide a function for generating internally consistent 'value out of range' messages
@
text
@a1290 8
#if 0
  if (fixp->fx_addsy != (symbolS *) NULL && !S_IS_DEFINED (fixp->fx_addsy))
    {
      /* The symbol is undefined.  Let the linker figure it out.  */
      return 0;
    }
  return fixp->fx_frag->fr_address + fixp->fx_where;
#endif
@


1.12
log
@	* config/tc-i960.c (line_comment_chars): Add '#'.
	* config/tc-mn10200.c (tc_gen_reloc): Don't ignore fx_subsy.
@
text
@d1345 1
a1345 11
        {
          const char *err =
            _("operand out of range (%s not between %ld and %ld)");
          char buf[100];

          sprint_value (buf, test);
          if (file == (char *) NULL)
            as_warn (err, buf, min, max);
          else
            as_warn_where (file, line, err, buf, min, max);
        }
@


1.11
log
@	* config/tc-mn10200.c (md_parse_option <c, arg>): Add ATTRIBUTE_UNUSED.
	(md_undefined_symbol <name>): Likewise.
	(md_convert_frag <abfd>): Likewise.
	(tc_gen_reloc <seg>): Likewise.
	(check_operand <insn>): Likewise.
	(md_convert_frag): Fix format strings.
	(tc_gen_reloc): Delete fx_addsy - fx_subsy code.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002
d1235 15
@


1.10
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d325 2
a326 2
     int c;
     char *arg;
d333 1
a333 1
     char *name;
d381 1
a381 1
     bfd *abfd;
d440 1
a440 1
      sprintf (buf, ".%s_%d", FAKE_LABEL_NAME, label_count++);
d497 1
a497 1
      sprintf (buf, ".%s_%d", FAKE_LABEL_NAME, label_count++);
d585 1
a585 1
      sprintf (buf, ".%s_%d", FAKE_LABEL_NAME, label_count++);
d665 1
a665 1
      sprintf (buf, ".%s_%d", FAKE_LABEL_NAME, label_count++);
d1230 1
a1230 1
     asection *seg;
d1245 3
a1247 20

  if (fixp->fx_addsy && fixp->fx_subsy)
    {
      if ((S_GET_SEGMENT (fixp->fx_addsy) != S_GET_SEGMENT (fixp->fx_subsy))
	  || S_GET_SEGMENT (fixp->fx_addsy) == undefined_section)
	{
	  as_bad_where (fixp->fx_file, fixp->fx_line,
			"Difference of symbols in different sections is not supported");
	  return NULL;
	}
      reloc->sym_ptr_ptr = &bfd_abs_symbol;
      reloc->addend = (S_GET_VALUE (fixp->fx_addsy)
		       - S_GET_VALUE (fixp->fx_subsy) + fixp->fx_offset);
    }
  else
    {
      reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
      *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
      reloc->addend = fixp->fx_offset;
    }
d1361 1
a1361 1
     unsigned long insn;
@


1.9
log
@Update all uses of md_apply_fix to use md_apply_fix3.  Make it a void function.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
d84 3
a86 3
static boolean data_register_name PARAMS ((expressionS *expressionP));
static boolean address_register_name PARAMS ((expressionS *expressionP));
static boolean other_register_name PARAMS ((expressionS *expressionP));
d185 1
a185 1
static boolean
d213 1
a213 1
      return true;
d218 1
a218 1
  return false;
d232 1
a232 1
static boolean
d260 1
a260 1
      return true;
d265 1
a265 1
  return false;
d279 1
a279 1
static boolean
d307 1
a307 1
      return true;
d312 1
a312 1
  return false;
@


1.8
log
@	* config/tc-alpha.c: Fix comment typos.
	* config/tc-cris.c: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-mn10200.c: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-v850.c: Likewise.
@
text
@d763 1
a763 1
  /* This is both a simplification (we don't have to write md_apply_fix)
d1303 5
a1307 5
int
md_apply_fix3 (fixp, valuep, seg)
     fixS *fixp;
     valueT *valuep;
     segT seg;
d1311 1
a1311 2
  fixp->fx_done = 1;
  return 0;
@


1.7
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d178 1
a178 1
 * out: A expressionS.
d225 1
a225 1
 * out: A expressionS.
d272 1
a272 1
 * out: A expressionS.
@


1.6
log
@	* config/obj-elf.c (obj_elf_symver): Temporarily modify lex_type
	to include '@@' in symbol names when parsing versioned symbols
	rather than calling get_symbol_end multiple times.
	* config/tc-i370.c (register_name): Format fixes.  Don't call
	get_symbol_end after parsing number.
	* config/tc-mn10200.c (data_register_name): Format fixes.  Hoist
	code out of conditional.
	(address_register_name): Likewise.
	(other_register_name): Likewise.
	* config/tc-mn10300.c (r_register_name): Likewise.
	(xr_register_name): Likewise.
	(data_register_name): Likewise.
	(address_register_name): Likewise.
	(other_register_name): Likewise.
	* config/tc-ppc.c (register_name): Likewise.
	* config/tc-s390.c (register_name): Likewise.
@
text
@a22 1
#include <ctype.h>
d24 1
d784 1
a784 1
  for (s = str; *s != '\0' && !isspace (*s); s++)
d798 1
a798 1
  while (isspace (*str))
d1032 1
a1032 1
  while (isspace (*str))
@


1.5
log
@Prepare for multi-pass relaxation.
@
text
@d200 3
a212 2
      /* Put back the delimiting char.  */
      *input_line_pointer = c;
d215 4
a218 10
  else
    {
      /* Reset the line as if we had not done anything.  */
      /* Put back the delimiting char.  */
      *input_line_pointer = c;

      /* Reset input_line pointer.  */
      input_line_pointer = start;
      return false;
    }
d247 3
a259 2
      /* Put back the delimiting char.  */
      *input_line_pointer = c;
d262 4
a265 10
  else
    {
      /* Reset the line as if we had not done anything.  */
      /* Put back the delimiting char.  */
      *input_line_pointer = c;

      /* Reset input_line pointer.  */
      input_line_pointer = start;
      return false;
    }
d294 3
a306 2
      /* Put back the delimiting char.  */
      *input_line_pointer = c;
d309 4
a312 10
  else
    {
      /* Reset the line as if we had not done anything.  */
      /* Put back the delimiting char.  */
      *input_line_pointer = c;

      /* Reset input_line pointer.  */
      input_line_pointer = start;
      return false;
    }
@


1.4
log
@Fix copyright notices
@
text
@d2 2
a3 1
   Copyright 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
d1288 13
a1300 23
  if (fragp->fr_subtype == 0)
    return 2;
  if (fragp->fr_subtype == 3)
    return 3;
  if (fragp->fr_subtype == 6)
    {
      if (!S_IS_DEFINED (fragp->fr_symbol)
	  || seg != S_GET_SEGMENT (fragp->fr_symbol))
	{
	  fragp->fr_subtype = 7;
	  return 5;
	}
      return 3;
    }
  if (fragp->fr_subtype == 8)
    {
      if (!S_IS_DEFINED (fragp->fr_symbol))
	{
	  fragp->fr_subtype = 10;
	  return 5;
	}
      return 2;
    }
@


1.3
log
@Fix formatting.
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation.
@


1.3.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
@


1.3.2.2
log
@Merge from mainline.
@
text
@d1288 23
a1310 13
  if (fragp->fr_subtype == 6
      && (!S_IS_DEFINED (fragp->fr_symbol)
	  || seg != S_GET_SEGMENT (fragp->fr_symbol)))
    fragp->fr_subtype = 7;
  else if (fragp->fr_subtype == 8
	   && (!S_IS_DEFINED (fragp->fr_symbol)
	       || seg != S_GET_SEGMENT (fragp->fr_symbol)))
    fragp->fr_subtype = 10;

  if (fragp->fr_subtype >= sizeof (md_relax_table) / sizeof (md_relax_table[0]))
    abort ();

  return md_relax_table[fragp->fr_subtype].rlx_length;
@


1.2
log
@1999-06-22  Jonathan Larmour  <jlarmour@@cygnus.co.uk>
	* config/tc-arc.c (tc_gen_reloc): Use symbol_get_bfdsym to get at
	the symbol, rather than accessing the bsym member.
	* config/tc-d10v.c (tc_gen_reloc): Likewise.
	* config/tc-d30v.c (tc_gen_reloc): Likewise.
	* config/tc-mcore.c (tc_gen_reloc): Likewise.
	* config/tc-mn10200.c (tc_gen_reloc): Likewise.
	* config/tc-mn10300.c (tc_gen_reloc): Likewise.
	* config/tc-ns32k.c (tc_gen_reloc): Likewise.
	* config/tc-tic30.c (tc_gen_reloc): Likewise.
	* config/tc-v850.c (tc_gen_reloc): Likewise.
@
text
@d24 1
a24 1
#include "subsegs.h"     
d34 2
a35 1
/* Generic assembler global variables which must be defined by all targets. */
d37 1
a37 1
/* Characters which always start a comment. */
d43 1
a43 1
/* Characters which may be used to separate multiple commands on a 
d47 1
a47 1
/* Characters which are used to indicate an exponent in a floating 
d51 1
a51 1
/* Characters which mean that a number is a floating point constant, 
a54 1

d56 1
a56 1
  /* bCC relaxing */
d60 1
a60 1
  /* bCCx relaxing */
d64 1
a64 1
  /* jsr relaxing */
d67 1
a67 1
  /* jmp relaxing */
d73 2
a74 1
/* local functions */
d87 1
a87 2

/* fixups */
d102 1
a102 1
size_t md_longopts_size = sizeof(md_longopts); 
d113 1
a113 1
/* This table is sorted. Suitable for searching by a binary search. */
d121 2
a122 1
#define DATA_REG_NAME_CNT	(sizeof(data_registers) / sizeof(struct reg_name))
d131 2
a132 1
#define ADDRESS_REG_NAME_CNT	(sizeof(address_registers) / sizeof(struct reg_name))
d139 2
a140 1
#define OTHER_REG_NAME_CNT	(sizeof(other_registers) / sizeof(struct reg_name))
d144 1
a144 1
   number from the array on success, or -1 on failure. */
d166 2
a167 2
      else 
	  return regs[middle].value;
a172 1

d183 1
d193 1
a193 1
  /* Find the spelling of the operand */
d199 2
a200 2
  /* look to see if it's in the register table */
  if (reg_number >= 0) 
d205 1
a205 1
      /* make the rest nice */
d208 3
a210 1
      *input_line_pointer = c;	/* put back the delimiting char */
d215 6
a220 3
      /* reset the line as if we had not done anything */
      *input_line_pointer = c;   /* put back the delimiting char */
      input_line_pointer = start; /* reset input_line pointer */
d235 1
d245 1
a245 1
  /* Find the spelling of the operand */
d251 2
a252 2
  /* look to see if it's in the register table */
  if (reg_number >= 0) 
d257 1
a257 1
      /* make the rest nice */
d260 3
a262 1
      *input_line_pointer = c;	/* put back the delimiting char */
d267 6
a272 3
      /* reset the line as if we had not done anything */
      *input_line_pointer = c;   /* put back the delimiting char */
      input_line_pointer = start; /* reset input_line pointer */
d287 1
d297 1
a297 1
  /* Find the spelling of the operand */
d303 2
a304 2
  /* look to see if it's in the register table */
  if (reg_number >= 0) 
d309 1
a309 1
      /* make the rest nice */
d312 3
a314 1
      *input_line_pointer = c;	/* put back the delimiting char */
d319 6
a324 3
      /* reset the line as if we had not done anything */
      *input_line_pointer = c;   /* put back the delimiting char */
      input_line_pointer = start; /* reset input_line pointer */
d331 1
a331 1
  FILE *stream;
d333 1
a333 1
  fprintf(stream, _("MN10200 options:\n\
d335 1
a335 1
} 
d347 1
a347 1
  char *name;
d354 3
a356 3
  int type;
  char *litp;
  int *sizep;
d377 1
a377 1
  
a392 1

d395 3
a397 3
  bfd *abfd;
  asection *sec;
  fragS *fragP;
d759 1
a759 1
  mn10200_hash = hash_new();
d769 1
a769 1
      if (strcmp (prev_name, op->name)) 
d784 1
a784 1
md_assemble (str) 
d798 1
a798 1
  for (s = str; *s != '\0' && ! isspace (*s); s++)
d803 2
a804 2
  /* find the first opcode with the proper name */
  opcode = (struct mn10200_opcode *)hash_find (mn10200_hash, str);
d817 1
a817 1
  for(;;)
d855 1
a855 1
	  /* Gather the operand. */
d948 1
a948 1
	  switch (ex.X_op) 
d958 1
a958 1
                   & (MN10200_OPERAND_DREG | MN10200_OPERAND_AREG)) == 0)
d964 1
a964 1
		
d972 1
a972 1
	      
d985 1
a985 1
		  && ! check_operand (insn, operand, ex.X_add_number))
d1032 1
a1032 1
        {
d1034 1
a1034 1
	  if (!strcmp(next_opcode->name, opcode->name))
d1039 1
a1039 1
	  
d1042 1
a1042 1
        }
d1045 1
a1045 1
      
d1066 1
a1066 1
         
d1073 1
a1073 1
      /* bCC */
d1083 2
a1084 2
          if (opcode->opcode == 0xea00)
            type = 8;
d1088 1
a1088 1
      /* jsr */
d1091 1
a1091 1
      /* jmp */
d1094 1
a1094 1
      /* bCCx */
d1152 2
a1153 1
	      reloc_howto = bfd_reloc_type_lookup (stdoutput, fixups[i].reloc);
d1156 2
a1157 2
		abort();
	  
d1161 1
a1161 1
		abort();
d1166 1
a1166 1
				  &fixups[i].exp, 
d1170 3
a1172 2
	      /* PC-relative offsets are from the first byte of the next
		 instruction, not from the start of the current instruction.  */
a1190 1

d1215 2
a1216 1
	      /* Convert the size of the reloc into what fix_new_exp wants.  */
d1229 3
a1231 2
	      /* PC-relative offsets are from the first byte of the next
		 instruction, not from the start of the current instruction.  */
d1239 2
a1241 3
/* if while processing a fixup, a reloc really needs to be created */
/* then it is done here */
                 
d1254 2
a1255 2
                    _("reloc %d not supported by object file format"),
		    (int)fixp->fx_r_type);
d1273 1
a1273 1
  else 
d1310 1
a1310 1
} 
d1318 1
a1318 1
  if (fixp->fx_addsy != (symbolS *) NULL && ! S_IS_DEFINED (fixp->fx_addsy))
d1364 4
a1367 4
        {
          max = (1 << operand->bits) - 1;
          min = 0;
        }
a1370 1

d1420 4
a1423 4
        {
          max = (1 << operand->bits) - 1;
          min = 0;
        }
a1425 1

@


1.1
log
@Initial revision
@
text
@d2 1
a2 2

   Copyright (C) 1996, 1997, 1998 Free Software Foundation.
d1254 2
a1255 1
      reloc->sym_ptr_ptr = &fixp->fx_addsy->bsym;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

