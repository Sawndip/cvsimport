head	1.21;
access;
symbols
	binutils-2_24-branch:1.21.0.12
	binutils-2_24-branchpoint:1.21
	binutils-2_21_1:1.21
	binutils-2_23_2:1.21
	binutils-2_23_1:1.21
	binutils-2_23:1.21
	binutils-2_23-branch:1.21.0.10
	binutils-2_23-branchpoint:1.21
	binutils-2_22_branch:1.21.0.8
	binutils-2_22:1.21
	binutils-2_22-branch:1.21.0.6
	binutils-2_22-branchpoint:1.21
	binutils-2_21:1.21
	binutils-2_21-branch:1.21.0.4
	binutils-2_21-branchpoint:1.21
	binutils-2_20_1:1.21
	binutils-2_20:1.21
	binutils-arc-20081103-branch:1.17.0.6
	binutils-arc-20081103-branchpoint:1.17
	binutils-2_20-branch:1.21.0.2
	binutils-2_20-branchpoint:1.21
	dje-cgen-play1-branch:1.20.0.2
	dje-cgen-play1-branchpoint:1.20
	arc-20081103-branch:1.17.0.4
	arc-20081103-branchpoint:1.17
	binutils-2_19_1:1.17
	binutils-2_19:1.17
	binutils-2_19-branch:1.17.0.2
	binutils-2_19-branchpoint:1.17
	binutils-2_18:1.16
	binutils-2_18-branch:1.16.0.2
	binutils-2_18-branchpoint:1.16
	binutils-csl-coldfire-4_1-32:1.10.2.1
	binutils-csl-sourcerygxx-4_1-32:1.10.2.1
	binutils-csl-innovasic-fido-3_4_4-33:1.10.2.1
	binutils-csl-sourcerygxx-3_4_4-32:1.7
	binutils-csl-coldfire-4_1-30:1.10.2.1
	binutils-csl-sourcerygxx-4_1-30:1.10.2.1
	binutils-csl-coldfire-4_1-28:1.10.2.1
	binutils-csl-sourcerygxx-4_1-29:1.10.2.1
	binutils-csl-sourcerygxx-4_1-28:1.10.2.1
	binutils-csl-arm-2006q3-27:1.10.2.1
	binutils-csl-sourcerygxx-4_1-27:1.10.2.1
	binutils-csl-arm-2006q3-26:1.10.2.1
	binutils-csl-sourcerygxx-4_1-26:1.10.2.1
	binutils-csl-sourcerygxx-4_1-25:1.10.2.1
	binutils-csl-sourcerygxx-4_1-24:1.10.2.1
	binutils-csl-sourcerygxx-4_1-23:1.10.2.1
	binutils-csl-sourcerygxx-4_1-21:1.10.2.1
	binutils-csl-arm-2006q3-21:1.10.2.1
	binutils-csl-sourcerygxx-4_1-22:1.10.2.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.10.2.1
	binutils-csl-sourcerygxx-4_1-20:1.10.2.1
	binutils-csl-arm-2006q3-19:1.10.2.1
	binutils-csl-sourcerygxx-4_1-19:1.10.2.1
	binutils-csl-sourcerygxx-4_1-18:1.10.2.1
	binutils-csl-renesas-4_1-9:1.10.2.1
	binutils-csl-sourcerygxx-3_4_4-25:1.7
	binutils-csl-renesas-4_1-8:1.10
	binutils-csl-renesas-4_1-7:1.10
	binutils-csl-renesas-4_1-6:1.10
	binutils-csl-sourcerygxx-4_1-17:1.10
	binutils-csl-sourcerygxx-4_1-14:1.10
	binutils-csl-sourcerygxx-4_1-15:1.10
	binutils-csl-sourcerygxx-4_1-13:1.10
	binutils-2_17:1.10.4.2
	binutils-csl-sourcerygxx-4_1-12:1.10
	binutils-csl-sourcerygxx-3_4_4-21:1.10
	binutils-csl-wrs-linux-3_4_4-24:1.7
	binutils-csl-wrs-linux-3_4_4-23:1.7
	binutils-csl-sourcerygxx-4_1-9:1.10
	binutils-csl-sourcerygxx-4_1-8:1.10
	binutils-csl-sourcerygxx-4_1-7:1.10
	binutils-csl-arm-2006q1-6:1.10
	binutils-csl-sourcerygxx-4_1-6:1.10
	binutils-csl-wrs-linux-3_4_4-22:1.7
	binutils-csl-coldfire-4_1-11:1.10
	binutils-csl-sourcerygxx-3_4_4-19:1.10
	binutils-csl-coldfire-4_1-10:1.10
	binutils-csl-sourcerygxx-4_1-5:1.10
	binutils-csl-sourcerygxx-4_1-4:1.10
	binutils-csl-wrs-linux-3_4_4-21:1.7
	binutils-csl-morpho-4_1-4:1.10
	binutils-csl-sourcerygxx-3_4_4-17:1.10
	binutils-csl-wrs-linux-3_4_4-20:1.7
	binutils-2_17-branch:1.10.0.4
	binutils-2_17-branchpoint:1.10
	binutils-csl-2_17-branch:1.10.0.2
	binutils-csl-2_17-branchpoint:1.10
	binutils-csl-gxxpro-3_4-branch:1.7.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.7
	binutils-2_16_1:1.7
	binutils-csl-arm-2005q1b:1.7
	binutils-2_16:1.7
	binutils-csl-arm-2005q1a:1.7
	binutils-csl-arm-2005q1-branch:1.7.0.4
	binutils-csl-arm-2005q1-branchpoint:1.7
	binutils-2_16-branch:1.7.0.2
	binutils-2_16-branchpoint:1.7
	csl-arm-2004-q3d:1.5
	csl-arm-2004-q3:1.3
	binutils-2_15:1.3
	binutils-2_15-branchpoint:1.3
	csl-arm-2004-q1a:1.3
	csl-arm-2004-q1:1.3
	binutils-2_15-branch:1.3.0.6
	cagney_bfdfile-20040213-branch:1.3.0.4
	cagney_bfdfile-20040213-branchpoint:1.3
	cagney_bigcore-20040122-branch:1.3.0.2
	cagney_bigcore-20040122-branchpoint:1.3
	csl-arm-2003-q4:1.3
	binutils-2_14:1.1
	binutils-2_14-branch:1.1.0.2
	binutils-2_14-branchpoint:1.1
	binutils_latest_snapshot:1.21;
locks; strict;
comment	@ * @;


1.21
date	2009.09.02.07.24.21;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2009.06.22.17.56.02;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2009.01.07.17.41.09;	author sterling;	state Exp;
branches;
next	1.18;

1.18
date	2008.11.04.23.11.02;	author bwilson;	state Exp;
branches;
next	1.17;

1.17
date	2008.08.20.23.28.58;	author bwilson;	state Exp;
branches;
next	1.16;

1.16
date	2007.07.03.11.01.05;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2007.06.22.18.44.50;	author bwilson;	state Exp;
branches;
next	1.14;

1.14
date	2007.02.02.23.09.50;	author bwilson;	state Exp;
branches;
next	1.13;

1.13
date	2007.02.02.22.08.36;	author bwilson;	state Exp;
branches;
next	1.12;

1.12
date	2006.04.25.17.11.10;	author bwilson;	state Exp;
branches;
next	1.11;

1.11
date	2006.04.25.15.41.16;	author bwilson;	state Exp;
branches;
next	1.10;

1.10
date	2005.12.30.23.34.00;	author bwilson;	state Exp;
branches
	1.10.2.1
	1.10.4.1;
next	1.9;

1.9
date	2005.05.06.21.27.47;	author bwilson;	state Exp;
branches;
next	1.8;

1.8
date	2005.05.05.09.13.06;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2005.03.03.11.47.57;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2005.01.31.23.18.35;	author bje;	state Exp;
branches;
next	1.5;

1.5
date	2004.10.12.18.33.15;	author bwilson;	state Exp;
branches;
next	1.4;

1.4
date	2004.10.08.00.22.11;	author bwilson;	state Exp;
branches;
next	1.3;

1.3
date	2003.12.10.06.41.08;	author bje;	state Exp;
branches;
next	1.2;

1.2
date	2003.11.22.15.32.28;	author kazu;	state Exp;
branches;
next	1.1;

1.1
date	2003.04.01.15.50.29;	author nickc;	state Exp;
branches;
next	;

1.10.2.1
date	2006.08.22.15.08.36;	author jsm28;	state Exp;
branches;
next	;

1.10.4.1
date	2006.04.25.15.43.26;	author bwilson;	state Exp;
branches;
next	1.10.4.2;

1.10.4.2
date	2006.04.25.17.14.03;	author bwilson;	state Exp;
branches;
next	;


desc
@@


1.21
log
@update copyright dates
@
text
@/* Table of relaxations for Xtensa assembly.
   Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2009
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

/* This file contains the code for generating runtime data structures
   for relaxation pattern matching from statically specified strings.
   Each action contains an instruction pattern to match and
   preconditions for the match as well as an expansion if the pattern
   matches.  The preconditions can specify that two operands are the
   same or an operand is a specific constant or register.  The expansion
   uses the bound variables from the pattern to specify that specific
   operands from the pattern should be used in the result.

   The code determines whether the condition applies to a constant or
   a register depending on the type of the operand.  You may get
   unexpected results if you don't match the rule against the operand
   type correctly.

   The patterns match a language like:

   INSN_PATTERN ::= INSN_TEMPL ( '|' PRECOND )* ( '?' OPTIONPRED )*
   INSN_TEMPL   ::= OPCODE ' ' [ OPERAND (',' OPERAND)* ]
   OPCODE       ::=  id
   OPERAND      ::= CONSTANT | VARIABLE | SPECIALFN '(' VARIABLE ')'
   SPECIALFN    ::= 'HI24S' | 'F32MINUS' | 'LOW8'
                    | 'HI16' | 'LOW16'
   VARIABLE     ::= '%' id
   PRECOND      ::= OPERAND CMPOP OPERAND
   CMPOP        ::= '==' | '!='
   OPTIONPRED   ::= OPTIONNAME ('+' OPTIONNAME)
   OPTIONNAME   ::= '"' id '"'

   The replacement language
   INSN_REPL      ::= INSN_LABEL_LIT ( ';' INSN_LABEL_LIT )*
   INSN_LABEL_LIT ::= INSN_TEMPL
                      | 'LABEL'
                      | 'LITERAL' VARIABLE

   The operands in a PRECOND must be constants or variables bound by
   the INSN_PATTERN.

   The configuration options define a predicate on the availability of
   options which must be TRUE for this rule to be valid.  Examples are
   requiring "density" for replacements with density instructions,
   requiring "const16" for replacements that require const16
   instructions, etc.  The names are interpreted by the assembler to a
   truth value for a particular frag.

   The operands in the INSN_REPL must be constants, variables bound in
   the associated INSN_PATTERN, special variables that are bound in
   the INSN_REPL by LABEL or LITERAL definitions, or special value
   manipulation functions.

   A simple example of a replacement pattern:
   {"movi.n %as,%imm", "movi %as,%imm"} would convert the narrow
   movi.n instruction to the wide movi instruction.

   A more complex example of a branch around:
   {"beqz %as,%label", "bnez %as,%LABEL;j %label;LABEL"}
   would convert a branch to a negated branch to the following instruction
   with a jump to the original label.

   An Xtensa-specific example that generates a literal:
   {"movi %at,%imm", "LITERAL %imm; l32r %at,%LITERAL"}
   will convert a movi instruction to an l32r of a literal
   literal defined in the literal pool.

   Even more complex is a conversion of a load with immediate offset
   to a load of a freshly generated literal, an explicit add and
   a load with 0 offset.  This transformation is only valid, though
   when the first and second operands are not the same as specified
   by the "| %at!=%as" precondition clause.
   {"l32i %at,%as,%imm | %at!=%as",
   "LITERAL %imm; l32r %at,%LITERAL; add %at,%at,%as; l32i %at,%at,0"}

   There is special case for loop instructions here, but because we do
   not currently have the ability to represent the difference of two
   symbols, the conversion requires special code in the assembler to
   write the operands of the addi/addmi pair representing the
   difference of the old and new loop end label.  */

#include "as.h"
#include "xtensa-isa.h"
#include "xtensa-relax.h"
#include <stddef.h>
#include "xtensa-config.h"

#ifndef XCHAL_HAVE_WIDE_BRANCHES
#define XCHAL_HAVE_WIDE_BRANCHES 0
#endif

/* Imported from bfd.  */
extern xtensa_isa xtensa_default_isa;

/* The opname_list is a small list of names that we use for opcode and
   operand variable names to simplify ownership of these commonly used
   strings.  Strings entered in the table can be compared by pointer
   equality.  */

typedef struct opname_list_struct opname_list;
typedef opname_list opname_e;

struct opname_list_struct
{
  char *opname;
  opname_list *next;
};

static opname_list *local_opnames = NULL;


/* The "opname_map" and its element structure "opname_map_e" are used
   for binding an operand number to a name or a constant.  */

typedef struct opname_map_e_struct opname_map_e;
typedef struct opname_map_struct opname_map;

struct opname_map_e_struct
{
  const char *operand_name;	/* If null, then use constant_value.  */
  int operand_num;
  unsigned constant_value;
  opname_map_e *next;
};

struct opname_map_struct
{
  opname_map_e *head;
  opname_map_e **tail;
};

/* The "precond_list" and its element structure "precond_e" represents
   explicit preconditions comparing operand variables and constants.
   In the "precond_e" structure, a variable is identified by the name
   in the "opname" field.   If that field is NULL, then the operand
   is the constant in field "opval".  */

typedef struct precond_e_struct precond_e;
typedef struct precond_list_struct precond_list;

struct precond_e_struct
{
  const char *opname1;
  unsigned opval1;
  CmpOp cmpop;
  const char *opname2;
  unsigned opval2;
  precond_e *next;
};

struct precond_list_struct
{
  precond_e *head;
  precond_e **tail;
};


/* The insn_templ represents the INSN_TEMPL instruction template.  It
   is an opcode name with a list of operands.  These are used for
   instruction patterns and replacement patterns.  */

typedef struct insn_templ_struct insn_templ;
struct insn_templ_struct
{
  const char *opcode_name;
  opname_map operand_map;
};


/* The insn_pattern represents an INSN_PATTERN instruction pattern.
   It is an instruction template with preconditions that specify when
   it actually matches a given instruction.  */

typedef struct insn_pattern_struct insn_pattern;
struct insn_pattern_struct
{
  insn_templ t;
  precond_list preconds;
  ReqOptionList *options;
};


/* The "insn_repl" and associated element structure "insn_repl_e"
   instruction replacement list is a list of
   instructions/LITERALS/LABELS with constant operands or operands
   with names bound to the operand names in the associated pattern.  */

typedef struct insn_repl_e_struct insn_repl_e;
struct insn_repl_e_struct
{
  insn_templ t;
  insn_repl_e *next;
};

typedef struct insn_repl_struct insn_repl;
struct insn_repl_struct
{
  insn_repl_e *head;
  insn_repl_e **tail;
};


/* The split_rec is a vector of allocated char * pointers.  */

typedef struct split_rec_struct split_rec;
struct split_rec_struct
{
  char **vec;
  int count;
};

/* The "string_pattern_pair" is a set of pairs containing instruction
   patterns and replacement strings.  */

typedef struct string_pattern_pair_struct string_pattern_pair;
struct string_pattern_pair_struct
{
  const char *pattern;
  const char *replacement;
};


/* The widen_spec_list is a list of valid substitutions that generate
   wider representations.  These are generally used to specify
   replacements for instructions whose immediates do not fit their
   encodings.  A valid transition may require multiple steps of
   one-to-one instruction replacements with a final multiple
   instruction replacement.  As an example, here are the transitions
   required to replace an 'addi.n' with an 'addi', 'addmi'.

     addi.n a4, 0x1010
     => addi a4, 0x1010
     => addmi a4, 0x1010
     => addmi a4, 0x1000, addi a4, 0x10.  

   See the comments in xg_assembly_relax for some important details
   regarding how these chains must be built.  */

static string_pattern_pair widen_spec_list[] =
{
  {"add.n %ar,%as,%at ? IsaUseDensityInstruction", "add %ar,%as,%at"},
  {"addi.n %ar,%as,%imm ? IsaUseDensityInstruction", "addi %ar,%as,%imm"},
  {"beqz.n %as,%label ? IsaUseDensityInstruction", "beqz %as,%label"},
  {"bnez.n %as,%label ? IsaUseDensityInstruction", "bnez %as,%label"},
  {"l32i.n %at,%as,%imm ? IsaUseDensityInstruction", "l32i %at,%as,%imm"},
  {"mov.n %at,%as ? IsaUseDensityInstruction", "or %at,%as,%as"},
  {"movi.n %as,%imm ? IsaUseDensityInstruction", "movi %as,%imm"},
  {"nop.n ? IsaUseDensityInstruction ? realnop", "nop"},
  {"nop.n ? IsaUseDensityInstruction ? no-realnop", "or 1,1,1"},
  {"ret.n %as ? IsaUseDensityInstruction", "ret %as"},
  {"retw.n %as ? IsaUseDensityInstruction", "retw %as"},
  {"s32i.n %at,%as,%imm ? IsaUseDensityInstruction", "s32i %at,%as,%imm"},
  {"srli %at,%as,%imm", "extui %at,%as,%imm,F32MINUS(%imm)"},
  {"slli %ar,%as,0", "or %ar,%as,%as"},

  /* Widening with literals or const16.  */
  {"movi %at,%imm ? IsaUseL32R ",
   "LITERAL %imm; l32r %at,%LITERAL"},
  {"movi %at,%imm ? IsaUseConst16",
   "const16 %at,HI16U(%imm); const16 %at,LOW16U(%imm)"},

  {"addi %ar,%as,%imm", "addmi %ar,%as,%imm"},
  /* LOW8 is the low 8 bits of the Immed
     MID8S is the middle 8 bits of the Immed */
  {"addmi %ar,%as,%imm", "addmi %ar,%as,HI24S(%imm); addi %ar,%ar,LOW8(%imm)"},

  /* In the end convert to either an l32r or const16.  */
  {"addmi %ar,%as,%imm | %ar!=%as ? IsaUseL32R",
   "LITERAL %imm; l32r %ar,%LITERAL; add %ar,%as,%ar"},
  {"addmi %ar,%as,%imm | %ar!=%as ? IsaUseConst16",
   "const16 %ar,HI16U(%imm); const16 %ar,LOW16U(%imm); add %ar,%as,%ar"},

  /* Widening the load instructions with too-large immediates */
  {"l8ui %at,%as,%imm | %at!=%as ? IsaUseL32R",
   "LITERAL %imm; l32r %at,%LITERAL; add %at,%at,%as; l8ui %at,%at,0"},
  {"l16si %at,%as,%imm | %at!=%as ? IsaUseL32R",
   "LITERAL %imm; l32r %at,%LITERAL; add %at,%at,%as; l16si %at,%at,0"},
  {"l16ui %at,%as,%imm | %at!=%as ? IsaUseL32R",
   "LITERAL %imm; l32r %at,%LITERAL; add %at,%at,%as; l16ui %at,%at,0"},
  {"l32i %at,%as,%imm | %at!=%as ? IsaUseL32R",
   "LITERAL %imm; l32r %at,%LITERAL; add %at,%at,%as; l32i %at,%at,0"},

  /* Widening load instructions with const16s.  */
  {"l8ui %at,%as,%imm | %at!=%as ? IsaUseConst16",
   "const16 %at,HI16U(%imm); const16 %at,LOW16U(%imm); add %at,%at,%as; l8ui %at,%at,0"},
  {"l16si %at,%as,%imm | %at!=%as ? IsaUseConst16",
   "const16 %at,HI16U(%imm); const16 %at,LOW16U(%imm); add %at,%at,%as; l16si %at,%at,0"},
  {"l16ui %at,%as,%imm | %at!=%as ? IsaUseConst16",
   "const16 %at,HI16U(%imm); const16 %at,LOW16U(%imm); add %at,%at,%as; l16ui %at,%at,0"},
  {"l32i %at,%as,%imm | %at!=%as ? IsaUseConst16",
   "const16 %at,HI16U(%imm); const16 %at,LOW16U(%imm); add %at,%at,%as; l32i %at,%at,0"},

  /* This is only PART of the loop instruction.  In addition,
     hardcoded into its use is a modification of the final operand in
     the instruction in bytes 9 and 12.  */
  {"loop %as,%label | %as!=1 ? IsaUseLoops",
   "loop %as,%LABEL;"
   "rsr.lend    %as;"		/* LEND */
   "wsr.lbeg    %as;"		/* LBEG */
   "addi    %as, %as, 0;"	/* lo8(%label-%LABEL1) */
   "addmi   %as, %as, 0;"	/* mid8(%label-%LABEL1) */
   "wsr.lend    %as;"
   "isync;"
   "rsr.lcount    %as;"		/* LCOUNT */
   "addi    %as, %as, 1;"	/* density -> addi.n %as, %as, 1 */
   "LABEL"},
  {"loopgtz %as,%label | %as!=1 ? IsaUseLoops",
   "beqz    %as,%label;"
   "bltz    %as,%label;"
   "loopgtz %as,%LABEL;"
   "rsr.lend    %as;"		/* LEND */
   "wsr.lbeg    %as;"		/* LBEG */
   "addi    %as, %as, 0;"	/* lo8(%label-%LABEL1) */
   "addmi   %as, %as, 0;"	/* mid8(%label-%LABEL1) */
   "wsr.lend    %as;"
   "isync;"
   "rsr.lcount    %as;"		/* LCOUNT */
   "addi    %as, %as, 1;"	/* density -> addi.n %as, %as, 1 */
   "LABEL"},
  {"loopnez %as,%label | %as!=1 ? IsaUseLoops",
   "beqz     %as,%label;"
   "loopnez %as,%LABEL;"
   "rsr.lend    %as;"		/* LEND */
   "wsr.lbeg    %as;"		/* LBEG */
   "addi    %as, %as, 0;"	/* lo8(%label-%LABEL1) */
   "addmi   %as, %as, 0;"	/* mid8(%label-%LABEL1) */
   "wsr.lend    %as;"
   "isync;"
   "rsr.lcount    %as;"		/* LCOUNT */
   "addi    %as, %as, 1;"	/* density -> addi.n %as, %as, 1 */
   "LABEL"},

  /* Relaxing to wide branches.  Order is important here.  With wide
     branches, there is more than one correct relaxation for an
     out-of-range branch.  Put the wide branch relaxations first in the
     table since they are more efficient than the branch-around
     relaxations.  */
  
  {"beqz %as,%label ? IsaUseWideBranches", "WIDE.beqz %as,%label"},
  {"bnez %as,%label ? IsaUseWideBranches", "WIDE.bnez %as,%label"},
  {"bgez %as,%label ? IsaUseWideBranches", "WIDE.bgez %as,%label"},
  {"bltz %as,%label ? IsaUseWideBranches", "WIDE.bltz %as,%label"},
  {"beqi %as,%imm,%label ? IsaUseWideBranches", "WIDE.beqi %as,%imm,%label"},
  {"bnei %as,%imm,%label ? IsaUseWideBranches", "WIDE.bnei %as,%imm,%label"},
  {"bgei %as,%imm,%label ? IsaUseWideBranches", "WIDE.bgei %as,%imm,%label"},
  {"blti %as,%imm,%label ? IsaUseWideBranches", "WIDE.blti %as,%imm,%label"},
  {"bgeui %as,%imm,%label ? IsaUseWideBranches", "WIDE.bgeui %as,%imm,%label"},
  {"bltui %as,%imm,%label ? IsaUseWideBranches", "WIDE.bltui %as,%imm,%label"},
  {"bbci %as,%imm,%label ? IsaUseWideBranches", "WIDE.bbci %as,%imm,%label"},
  {"bbsi %as,%imm,%label ? IsaUseWideBranches", "WIDE.bbsi %as,%imm,%label"},
  {"beq %as,%at,%label ? IsaUseWideBranches", "WIDE.beq %as,%at,%label"},
  {"bne %as,%at,%label ? IsaUseWideBranches", "WIDE.bne %as,%at,%label"},
  {"bge %as,%at,%label ? IsaUseWideBranches", "WIDE.bge %as,%at,%label"},
  {"blt %as,%at,%label ? IsaUseWideBranches", "WIDE.blt %as,%at,%label"},
  {"bgeu %as,%at,%label ? IsaUseWideBranches", "WIDE.bgeu %as,%at,%label"},
  {"bltu %as,%at,%label ? IsaUseWideBranches", "WIDE.bltu %as,%at,%label"},
  {"bany %as,%at,%label ? IsaUseWideBranches", "WIDE.bany %as,%at,%label"},
  {"bnone %as,%at,%label ? IsaUseWideBranches", "WIDE.bnone %as,%at,%label"},
  {"ball %as,%at,%label ? IsaUseWideBranches", "WIDE.ball %as,%at,%label"},
  {"bnall %as,%at,%label ? IsaUseWideBranches", "WIDE.bnall %as,%at,%label"},
  {"bbc %as,%at,%label ? IsaUseWideBranches", "WIDE.bbc %as,%at,%label"},
  {"bbs %as,%at,%label ? IsaUseWideBranches", "WIDE.bbs %as,%at,%label"},
  
  /* Widening branch comparisons eq/ne to zero.  Prefer relaxing to narrow
     branches if the density option is available.  */
  {"beqz %as,%label ? IsaUseDensityInstruction", "bnez.n %as,%LABEL;j %label;LABEL"},
  {"bnez %as,%label ? IsaUseDensityInstruction", "beqz.n %as,%LABEL;j %label;LABEL"},
  {"beqz %as,%label", "bnez %as,%LABEL;j %label;LABEL"},
  {"bnez %as,%label", "beqz %as,%LABEL;j %label;LABEL"},
  {"WIDE.beqz %as,%label ? IsaUseDensityInstruction", "bnez.n %as,%LABEL;j %label;LABEL"},
  {"WIDE.bnez %as,%label ? IsaUseDensityInstruction", "beqz.n %as,%LABEL;j %label;LABEL"},
  {"WIDE.beqz %as,%label", "bnez %as,%LABEL;j %label;LABEL"},
  {"WIDE.bnez %as,%label", "beqz %as,%LABEL;j %label;LABEL"},

  /* Widening expect-taken branches.  */
  {"beqzt %as,%label ? IsaUsePredictedBranches", "bnez %as,%LABEL;j %label;LABEL"},
  {"bnezt %as,%label ? IsaUsePredictedBranches", "beqz %as,%LABEL;j %label;LABEL"},
  {"beqt %as,%at,%label ? IsaUsePredictedBranches", "bne %as,%at,%LABEL;j %label;LABEL"},
  {"bnet %as,%at,%label ? IsaUsePredictedBranches", "beq %as,%at,%LABEL;j %label;LABEL"},

  /* Widening branches from the Xtensa boolean option.  */
  {"bt %bs,%label ? IsaUseBooleans", "bf %bs,%LABEL;j %label;LABEL"},
  {"bf %bs,%label ? IsaUseBooleans", "bt %bs,%LABEL;j %label;LABEL"},

  /* Other branch-around-jump widenings.  */
  {"bgez %as,%label", "bltz %as,%LABEL;j %label;LABEL"},
  {"bltz %as,%label", "bgez %as,%LABEL;j %label;LABEL"},
  {"beqi %as,%imm,%label", "bnei %as,%imm,%LABEL;j %label;LABEL"},
  {"bnei %as,%imm,%label", "beqi %as,%imm,%LABEL;j %label;LABEL"},
  {"bgei %as,%imm,%label", "blti %as,%imm,%LABEL;j %label;LABEL"},
  {"blti %as,%imm,%label", "bgei %as,%imm,%LABEL;j %label;LABEL"},
  {"bgeui %as,%imm,%label", "bltui %as,%imm,%LABEL;j %label;LABEL"},
  {"bltui %as,%imm,%label", "bgeui %as,%imm,%LABEL;j %label;LABEL"},
  {"bbci %as,%imm,%label", "bbsi %as,%imm,%LABEL;j %label;LABEL"},
  {"bbsi %as,%imm,%label", "bbci %as,%imm,%LABEL;j %label;LABEL"},
  {"beq %as,%at,%label", "bne %as,%at,%LABEL;j %label;LABEL"},
  {"bne %as,%at,%label", "beq %as,%at,%LABEL;j %label;LABEL"},
  {"bge %as,%at,%label", "blt %as,%at,%LABEL;j %label;LABEL"},
  {"blt %as,%at,%label", "bge %as,%at,%LABEL;j %label;LABEL"},
  {"bgeu %as,%at,%label", "bltu %as,%at,%LABEL;j %label;LABEL"},
  {"bltu %as,%at,%label", "bgeu %as,%at,%LABEL;j %label;LABEL"},
  {"bany %as,%at,%label", "bnone %as,%at,%LABEL;j %label;LABEL"},
  {"bnone %as,%at,%label", "bany %as,%at,%LABEL;j %label;LABEL"},
  {"ball %as,%at,%label", "bnall %as,%at,%LABEL;j %label;LABEL"},
  {"bnall %as,%at,%label", "ball %as,%at,%LABEL;j %label;LABEL"},
  {"bbc %as,%at,%label", "bbs %as,%at,%LABEL;j %label;LABEL"},
  {"bbs %as,%at,%label", "bbc %as,%at,%LABEL;j %label;LABEL"},

  {"WIDE.bgez %as,%label", "bltz %as,%LABEL;j %label;LABEL"},
  {"WIDE.bltz %as,%label", "bgez %as,%LABEL;j %label;LABEL"},
  {"WIDE.beqi %as,%imm,%label", "bnei %as,%imm,%LABEL;j %label;LABEL"},
  {"WIDE.bnei %as,%imm,%label", "beqi %as,%imm,%LABEL;j %label;LABEL"},
  {"WIDE.bgei %as,%imm,%label", "blti %as,%imm,%LABEL;j %label;LABEL"},
  {"WIDE.blti %as,%imm,%label", "bgei %as,%imm,%LABEL;j %label;LABEL"},
  {"WIDE.bgeui %as,%imm,%label", "bltui %as,%imm,%LABEL;j %label;LABEL"},
  {"WIDE.bltui %as,%imm,%label", "bgeui %as,%imm,%LABEL;j %label;LABEL"},
  {"WIDE.bbci %as,%imm,%label", "bbsi %as,%imm,%LABEL;j %label;LABEL"},
  {"WIDE.bbsi %as,%imm,%label", "bbci %as,%imm,%LABEL;j %label;LABEL"},
  {"WIDE.beq %as,%at,%label", "bne %as,%at,%LABEL;j %label;LABEL"},
  {"WIDE.bne %as,%at,%label", "beq %as,%at,%LABEL;j %label;LABEL"},
  {"WIDE.bge %as,%at,%label", "blt %as,%at,%LABEL;j %label;LABEL"},
  {"WIDE.blt %as,%at,%label", "bge %as,%at,%LABEL;j %label;LABEL"},
  {"WIDE.bgeu %as,%at,%label", "bltu %as,%at,%LABEL;j %label;LABEL"},
  {"WIDE.bltu %as,%at,%label", "bgeu %as,%at,%LABEL;j %label;LABEL"},
  {"WIDE.bany %as,%at,%label", "bnone %as,%at,%LABEL;j %label;LABEL"},
  {"WIDE.bnone %as,%at,%label", "bany %as,%at,%LABEL;j %label;LABEL"},
  {"WIDE.ball %as,%at,%label", "bnall %as,%at,%LABEL;j %label;LABEL"},
  {"WIDE.bnall %as,%at,%label", "ball %as,%at,%LABEL;j %label;LABEL"},
  {"WIDE.bbc %as,%at,%label", "bbs %as,%at,%LABEL;j %label;LABEL"},
  {"WIDE.bbs %as,%at,%label", "bbc %as,%at,%LABEL;j %label;LABEL"},

  /* Expanding calls with literals.  */
  {"call0 %label,%ar0 ? IsaUseL32R",
   "LITERAL %label; l32r a0,%LITERAL; callx0 a0,%ar0"},
  {"call4 %label,%ar4 ? IsaUseL32R",
   "LITERAL %label; l32r a4,%LITERAL; callx4 a4,%ar4"},
  {"call8 %label,%ar8 ? IsaUseL32R",
   "LITERAL %label; l32r a8,%LITERAL; callx8 a8,%ar8"},
  {"call12 %label,%ar12 ? IsaUseL32R",
   "LITERAL %label; l32r a12,%LITERAL; callx12 a12,%ar12"},

  /* Expanding calls with const16.  */
  {"call0 %label,%ar0 ? IsaUseConst16",
   "const16 a0,HI16U(%label); const16 a0,LOW16U(%label); callx0 a0,%ar0"},
  {"call4 %label,%ar4 ? IsaUseConst16",
   "const16 a4,HI16U(%label); const16 a4,LOW16U(%label); callx4 a4,%ar4"},
  {"call8 %label,%ar8 ? IsaUseConst16",
   "const16 a8,HI16U(%label); const16 a8,LOW16U(%label); callx8 a8,%ar8"},
  {"call12 %label,%ar12 ? IsaUseConst16",
   "const16 a12,HI16U(%label); const16 a12,LOW16U(%label); callx12 a12,%ar12"},

  /* Expanding j.l with literals.  */
  {"j %label ? FREEREG ? IsaUseL32R",
   "LITERAL %label; l32r FREEREG,%LITERAL; jx FREEREG"},
  /* Expanding j.l with const16.  */
  {"j %label ? FREEREG ? IsaUseConst16",
   "const16 FREEREG,HI16U(%label); const16 FREEREG,LOW16U(%label); jx FREEREG"},
};

#define WIDEN_COUNT (sizeof (widen_spec_list) / sizeof (string_pattern_pair))


/* The simplify_spec_list specifies simplifying transformations that
   will reduce the instruction width or otherwise simplify an
   instruction.  These are usually applied before relaxation in the
   assembler.  It is always legal to simplify.  Even for "addi as, 0",
   the "addi.n as, 0" will eventually be widened back to an "addi 0"
   after the widening table is applied.  Note: The usage of this table
   has changed somewhat so that it is entirely specific to "narrowing"
   instructions to use the density option.  This table is not used at
   all when the density option is not available.  */

string_pattern_pair simplify_spec_list[] =
{
  {"add %ar,%as,%at ? IsaUseDensityInstruction", "add.n %ar,%as,%at"},
  {"addi.n %ar,%as,0 ? IsaUseDensityInstruction", "mov.n %ar,%as"},
  {"addi %ar,%as,0 ? IsaUseDensityInstruction", "mov.n %ar,%as"},
  {"addi %ar,%as,%imm ? IsaUseDensityInstruction", "addi.n %ar,%as,%imm"},
  {"addmi %ar,%as,%imm ? IsaUseDensityInstruction", "addi.n %ar,%as,%imm"},
  {"beqz %as,%label ? IsaUseDensityInstruction", "beqz.n %as,%label"},
  {"bnez %as,%label ? IsaUseDensityInstruction", "bnez.n %as,%label"},
  {"l32i %at,%as,%imm ? IsaUseDensityInstruction", "l32i.n %at,%as,%imm"},
  {"movi %as,%imm ? IsaUseDensityInstruction", "movi.n %as,%imm"},
  {"nop ? realnop ? IsaUseDensityInstruction", "nop.n"},
  {"or %ar,%as,%at | %ar==%as | %as==%at ? IsaUseDensityInstruction", "nop.n"},
  {"or %ar,%as,%at | %ar!=%as | %as==%at ? IsaUseDensityInstruction", "mov.n %ar,%as"},
  {"ret %as ? IsaUseDensityInstruction", "ret.n %as"},
  {"retw %as ? IsaUseDensityInstruction", "retw.n %as"},
  {"s32i %at,%as,%imm ? IsaUseDensityInstruction", "s32i.n %at,%as,%imm"},
  {"slli %ar,%as,0 ? IsaUseDensityInstruction", "mov.n %ar,%as"}
};

#define SIMPLIFY_COUNT \
  (sizeof (simplify_spec_list) / sizeof (string_pattern_pair))


/* Externally visible functions.  */

extern bfd_boolean xg_has_userdef_op_fn (OpType);
extern long xg_apply_userdef_op_fn (OpType, long);


static void
append_transition (TransitionTable *tt,
		   xtensa_opcode opcode,
		   TransitionRule *t,
		   transition_cmp_fn cmp)
{
  TransitionList *tl = (TransitionList *) xmalloc (sizeof (TransitionList));
  TransitionList *prev;
  TransitionList **t_p;
  gas_assert (tt != NULL);
  gas_assert (opcode < tt->num_opcodes);

  prev = tt->table[opcode];
  tl->rule = t;
  tl->next = NULL;
  if (prev == NULL)
    {
      tt->table[opcode] = tl;
      return;
    }

  for (t_p = &tt->table[opcode]; (*t_p) != NULL; t_p = &(*t_p)->next)
    {
      if (cmp && cmp (t, (*t_p)->rule) < 0)
	{
	  /* Insert it here.  */
	  tl->next = *t_p;
	  *t_p = tl;
	  return;
	}
    }
  (*t_p) = tl;
}


static void
append_condition (TransitionRule *tr, Precondition *cond)
{
  PreconditionList *pl =
    (PreconditionList *) xmalloc (sizeof (PreconditionList));
  PreconditionList *prev = tr->conditions;
  PreconditionList *nxt;

  pl->precond = cond;
  pl->next = NULL;
  if (prev == NULL)
    {
      tr->conditions = pl;
      return;
    }
  nxt = prev->next;
  while (nxt != NULL)
    {
      prev = nxt;
      nxt = nxt->next;
    }
  prev->next = pl;
}


static void
append_value_condition (TransitionRule *tr,
			CmpOp cmp,
			unsigned op1,
			unsigned op2)
{
  Precondition *cond = (Precondition *) xmalloc (sizeof (Precondition));

  cond->cmp = cmp;
  cond->op_num = op1;
  cond->typ = OP_OPERAND;
  cond->op_data = op2;
  append_condition (tr, cond);
}


static void
append_constant_value_condition (TransitionRule *tr,
				 CmpOp cmp,
				 unsigned op1,
				 unsigned cnst)
{
  Precondition *cond = (Precondition *) xmalloc (sizeof (Precondition));

  cond->cmp = cmp;
  cond->op_num = op1;
  cond->typ = OP_CONSTANT;
  cond->op_data = cnst;
  append_condition (tr, cond);
}


static void
append_build_insn (TransitionRule *tr, BuildInstr *bi)
{
  BuildInstr *prev = tr->to_instr;
  BuildInstr *nxt;

  bi->next = NULL;
  if (prev == NULL)
    {
      tr->to_instr = bi;
      return;
    }
  nxt = prev->next;
  while (nxt != 0)
    {
      prev = nxt;
      nxt = prev->next;
    }
  prev->next = bi;
}


static void
append_op (BuildInstr *bi, BuildOp *b_op)
{
  BuildOp *prev = bi->ops;
  BuildOp *nxt;

  if (prev == NULL)
    {
      bi->ops = b_op;
      return;
    }
  nxt = prev->next;
  while (nxt != NULL)
    {
      prev = nxt;
      nxt = nxt->next;
    }
  prev->next = b_op;
}


static void
append_literal_op (BuildInstr *bi, unsigned op1, unsigned src_op)
{
  BuildOp *b_op = (BuildOp *) xmalloc (sizeof (BuildOp));

  b_op->op_num = op1;
  b_op->typ = OP_LITERAL;
  b_op->op_data = src_op;
  b_op->next = NULL;
  append_op (bi, b_op);
}


static void
append_label_op (BuildInstr *bi, unsigned op1)
{
  BuildOp *b_op = (BuildOp *) xmalloc (sizeof (BuildOp));

  b_op->op_num = op1;
  b_op->typ = OP_LABEL;
  b_op->op_data = 0;
  b_op->next = NULL;
  append_op (bi, b_op);
}


static void
append_constant_op (BuildInstr *bi, unsigned op1, unsigned cnst)
{
  BuildOp *b_op = (BuildOp *) xmalloc (sizeof (BuildOp));

  b_op->op_num = op1;
  b_op->typ = OP_CONSTANT;
  b_op->op_data = cnst;
  b_op->next = NULL;
  append_op (bi, b_op);
}


static void
append_field_op (BuildInstr *bi, unsigned op1, unsigned src_op)
{
  BuildOp *b_op = (BuildOp *) xmalloc (sizeof (BuildOp));

  b_op->op_num = op1;
  b_op->typ = OP_OPERAND;
  b_op->op_data = src_op;
  b_op->next = NULL;
  append_op (bi, b_op);
}


/* These could be generated but are not currently.  */

static void
append_user_fn_field_op (BuildInstr *bi,
			 unsigned op1,
			 OpType typ,
			 unsigned src_op)
{
  BuildOp *b_op = (BuildOp *) xmalloc (sizeof (BuildOp));

  b_op->op_num = op1;
  b_op->typ = typ;
  b_op->op_data = src_op;
  b_op->next = NULL;
  append_op (bi, b_op);
}


/* These operand functions are the semantics of user-defined
   operand functions.  */

static long
operand_function_HI24S (long a)
{
  if (a & 0x80)
    return (a & (~0xff)) + 0x100;
  else
    return (a & (~0xff));
}


static long
operand_function_F32MINUS (long a)
{
  return (32 - a);
}


static long
operand_function_LOW8 (long a)
{
  if (a & 0x80)
    return (a & 0xff) | ~0xff;
  else
    return (a & 0xff);
}


static long
operand_function_LOW16U (long a)
{
  return (a & 0xffff);
}


static long
operand_function_HI16U (long a)
{
  unsigned long b = a & 0xffff0000;
  return (long) (b >> 16);
}


bfd_boolean
xg_has_userdef_op_fn (OpType op)
{
  switch (op)
    {
    case OP_OPERAND_F32MINUS:
    case OP_OPERAND_LOW8:
    case OP_OPERAND_HI24S:
    case OP_OPERAND_LOW16U:
    case OP_OPERAND_HI16U:
      return TRUE;
    default:
      break;
    }
  return FALSE;
}


long
xg_apply_userdef_op_fn (OpType op, long a)
{
  switch (op)
    {
    case OP_OPERAND_F32MINUS:
      return operand_function_F32MINUS (a);
    case OP_OPERAND_LOW8:
      return operand_function_LOW8 (a);
    case OP_OPERAND_HI24S:
      return operand_function_HI24S (a);
    case OP_OPERAND_LOW16U:
      return operand_function_LOW16U (a);
    case OP_OPERAND_HI16U:
      return operand_function_HI16U (a);
    default:
      break;
    }
  return FALSE;
}


/* Generate a transition table.  */

static const char *
enter_opname_n (const char *name, int len)
{
  opname_e *op;

  for (op = local_opnames; op != NULL; op = op->next)
    {
      if (strlen (op->opname) == (unsigned) len
	  && strncmp (op->opname, name, len) == 0)
	return op->opname;
    }
  op = (opname_e *) xmalloc (sizeof (opname_e));
  op->opname = (char *) xmalloc (len + 1);
  strncpy (op->opname, name, len);
  op->opname[len] = '\0';
  return op->opname;
}


static const char *
enter_opname (const char *name)
{
  opname_e *op;

  for (op = local_opnames; op != NULL; op = op->next)
    {
      if (strcmp (op->opname, name) == 0)
	return op->opname;
    }
  op = (opname_e *) xmalloc (sizeof (opname_e));
  op->opname = xstrdup (name);
  return op->opname;
}


static void
init_opname_map (opname_map *m)
{
  m->head = NULL;
  m->tail = &m->head;
}


static void
clear_opname_map (opname_map *m)
{
  opname_map_e *e;

  while (m->head != NULL)
    {
      e = m->head;
      m->head = e->next;
      free (e);
    }
  m->tail = &m->head;
}


static bfd_boolean
same_operand_name (const opname_map_e *m1, const opname_map_e *m2)
{
  if (m1->operand_name == NULL || m1->operand_name == NULL)
    return FALSE;
  return (m1->operand_name == m2->operand_name);
}


static opname_map_e *
get_opmatch (opname_map *map, const char *operand_name)
{
  opname_map_e *m;

  for (m = map->head; m != NULL; m = m->next)
    {
      if (strcmp (m->operand_name, operand_name) == 0)
	return m;
    }
  return NULL;
}


static bfd_boolean
op_is_constant (const opname_map_e *m1)
{
  return (m1->operand_name == NULL);
}


static unsigned
op_get_constant (const opname_map_e *m1)
{
  gas_assert (m1->operand_name == NULL);
  return m1->constant_value;
}


static void
init_precond_list (precond_list *l)
{
  l->head = NULL;
  l->tail = &l->head;
}


static void
clear_precond_list (precond_list *l)
{
  precond_e *e;

  while (l->head != NULL)
    {
      e = l->head;
      l->head = e->next;
      free (e);
    }
  l->tail = &l->head;
}


static void
init_insn_templ (insn_templ *t)
{
  t->opcode_name = NULL;
  init_opname_map (&t->operand_map);
}


static void
clear_insn_templ (insn_templ *t)
{
  clear_opname_map (&t->operand_map);
}


static void
init_insn_pattern (insn_pattern *p)
{
  init_insn_templ (&p->t);
  init_precond_list (&p->preconds);
  p->options = NULL;
}


static void
clear_insn_pattern (insn_pattern *p)
{
  clear_insn_templ (&p->t);
  clear_precond_list (&p->preconds);
}


static void
init_insn_repl (insn_repl *r)
{
  r->head = NULL;
  r->tail = &r->head;
}


static void
clear_insn_repl (insn_repl *r)
{
  insn_repl_e *e;

  while (r->head != NULL)
    {
      e = r->head;
      r->head = e->next;
      clear_insn_templ (&e->t);
    }
  r->tail = &r->head;
}


static int
insn_templ_operand_count (const insn_templ *t)
{
  int i = 0;
  const opname_map_e *op;

  for (op = t->operand_map.head; op != NULL; op = op->next, i++)
    ;
  return i;
}


/* Convert a string to a number.  E.G.: parse_constant("10", &num) */

static bfd_boolean
parse_constant (const char *in, unsigned *val_p)
{
  unsigned val = 0;
  const char *p;

  if (in == NULL)
    return FALSE;
  p = in;

  while (*p != '\0')
    {
      if (*p >= '0' && *p <= '9')
	val = val * 10 + (*p - '0');
      else
	return FALSE;
      ++p;
    }
  *val_p = val;
  return TRUE;
}


static bfd_boolean
parse_special_fn (const char *name,
		  const char **fn_name_p,
		  const char **arg_name_p)
{
  char *p_start;
  const char *p_end;

  p_start = strchr (name, '(');
  if (p_start == NULL)
    return FALSE;

  p_end = strchr (p_start, ')');

  if (p_end == NULL)
    return FALSE;

  if (p_end[1] != '\0')
    return FALSE;

  *fn_name_p = enter_opname_n (name, p_start - name);
  *arg_name_p = enter_opname_n (p_start + 1, p_end - p_start - 1);
  return TRUE;
}


static const char *
skip_white (const char *p)
{
  if (p == NULL)
    return p;
  while (*p == ' ')
    ++p;
  return p;
}


static void
trim_whitespace (char *in)
{
  char *last_white = NULL;
  char *p = in;

  while (p && *p != '\0')
    {
      while (*p == ' ')
	{
	  if (last_white == NULL)
	    last_white = p;
	  p++;
	}
      if (*p != '\0')
	{
	  last_white = NULL;
	  p++;
	}
    }
  if (last_white)
    *last_white = '\0';
}


/* Split a string into component strings where "c" is the
   delimiter.  Place the result in the split_rec.  */

static void
split_string (split_rec *rec,
	      const char *in,
	      char c,
	      bfd_boolean elide_whitespace)
{
  int cnt = 0;
  int i;
  const char *p = in;

  while (p != NULL && *p != '\0')
    {
      cnt++;
      p = strchr (p, c);
      if (p)
	p++;
    }
  rec->count = cnt;
  rec->vec = NULL;

  if (rec->count == 0)
    return;

  rec->vec = (char **) xmalloc (sizeof (char *) * cnt);
  for (i = 0; i < cnt; i++)
    rec->vec[i] = 0;

  p = in;
  for (i = 0; i < cnt; i++)
    {
      const char *q;
      int len;

      q = p;
      if (elide_whitespace)
	q = skip_white (q);

      p = strchr (q, c);
      if (p == NULL)
	rec->vec[i] = xstrdup (q);
      else
	{
	  len = p - q;
	  rec->vec[i] = (char *) xmalloc (sizeof (char) * (len + 1));
	  strncpy (rec->vec[i], q, len);
	  rec->vec[i][len] = '\0';
	  p++;
	}

      if (elide_whitespace)
	trim_whitespace (rec->vec[i]);
    }
}


static void
clear_split_rec (split_rec *rec)
{
  int i;

  for (i = 0; i < rec->count; i++)
    free (rec->vec[i]);

  if (rec->count > 0)
    free (rec->vec);
}


/* Initialize a split record.  The split record must be initialized
   before split_string is called.  */

static void
init_split_rec (split_rec *rec)
{
  rec->vec = NULL;
  rec->count = 0;
}


/* Parse an instruction template like "insn op1, op2, op3".  */

static bfd_boolean
parse_insn_templ (const char *s, insn_templ *t)
{
  const char *p = s;
  int insn_name_len;
  split_rec oprec;
  int i;

  /* First find the first whitespace.  */

  init_split_rec (&oprec);

  p = skip_white (p);
  insn_name_len = strcspn (s, " ");
  if (insn_name_len == 0)
    return FALSE;

  init_insn_templ (t);
  t->opcode_name = enter_opname_n (p, insn_name_len);

  p = p + insn_name_len;

  /* Split by ',' and skip beginning and trailing whitespace.  */
  split_string (&oprec, p, ',', TRUE);

  for (i = 0; i < oprec.count; i++)
    {
      const char *opname = oprec.vec[i];
      opname_map_e *e = (opname_map_e *) xmalloc (sizeof (opname_map_e));
      e->next = NULL;
      e->operand_name = NULL;
      e->constant_value = 0;
      e->operand_num = i;

      /* If it begins with a number, assume that it is a number.  */
      if (opname && opname[0] >= '0' && opname[0] <= '9')
	{
	  unsigned val;

	  if (parse_constant (opname, &val))
	    e->constant_value = val;
	  else
	    {
	      free (e);
	      clear_split_rec (&oprec);
	      clear_insn_templ (t);
	      return FALSE;
	    }
	}
      else
	e->operand_name = enter_opname (oprec.vec[i]);

      *t->operand_map.tail = e;
      t->operand_map.tail = &e->next;
    }
  clear_split_rec (&oprec);
  return TRUE;
}


static bfd_boolean
parse_precond (const char *s, precond_e *precond)
{
  /* All preconditions are currently of the form:
     a == b or a != b or a == k (where k is a constant).
     Later we may use some special functions like DENSITY == 1
     to identify when density is available.  */

  const char *p = s;
  int len;
  precond->opname1 = NULL;
  precond->opval1 = 0;
  precond->cmpop = OP_EQUAL;
  precond->opname2 = NULL;
  precond->opval2 = 0;
  precond->next = NULL;

  p = skip_white (p);

  len = strcspn (p, " !=");

  if (len == 0)
    return FALSE;

  precond->opname1 = enter_opname_n (p, len);
  p = p + len;
  p = skip_white (p);

  /* Check for "==" and "!=".  */
  if (strncmp (p, "==", 2) == 0)
    precond->cmpop = OP_EQUAL;
  else if (strncmp (p, "!=", 2) == 0)
    precond->cmpop = OP_NOTEQUAL;
  else
    return FALSE;

  p = p + 2;
  p = skip_white (p);

  /* No trailing whitespace from earlier parsing.  */
  if (p[0] >= '0' && p[0] <= '9')
    {
      unsigned val;
      if (parse_constant (p, &val))
	precond->opval2 = val;
      else
	return FALSE;
    }
  else
    precond->opname2 = enter_opname (p);
  return TRUE;
}


static void
clear_req_or_option_list (ReqOrOption **r_p)
{
  if (*r_p == NULL)
    return;

  free ((*r_p)->option_name);
  clear_req_or_option_list (&(*r_p)->next);
  *r_p = NULL;
}


static void
clear_req_option_list (ReqOption **r_p)
{
  if (*r_p == NULL)
    return;

  clear_req_or_option_list (&(*r_p)->or_option_terms);
  clear_req_option_list (&(*r_p)->next);
  *r_p = NULL;
}


static ReqOrOption *
clone_req_or_option_list (ReqOrOption *req_or_option)
{
  ReqOrOption *new_req_or_option;

  if (req_or_option == NULL)
    return NULL;

  new_req_or_option = (ReqOrOption *) xmalloc (sizeof (ReqOrOption));
  new_req_or_option->option_name = xstrdup (req_or_option->option_name);
  new_req_or_option->is_true = req_or_option->is_true;
  new_req_or_option->next = NULL;
  new_req_or_option->next = clone_req_or_option_list (req_or_option->next);
  return new_req_or_option;
}


static ReqOption *
clone_req_option_list (ReqOption *req_option)
{
  ReqOption *new_req_option;

  if (req_option == NULL)
    return NULL;

  new_req_option = (ReqOption *) xmalloc (sizeof (ReqOption));
  new_req_option->or_option_terms = NULL;
  new_req_option->next = NULL;
  new_req_option->or_option_terms =
    clone_req_or_option_list (req_option->or_option_terms);
  new_req_option->next = clone_req_option_list (req_option->next);
  return new_req_option;
}


static bfd_boolean
parse_option_cond (const char *s, ReqOption *option)
{
  int i;
  split_rec option_term_rec;

  /* All option or conditions are of the form:
     optionA + no-optionB + ...
     "Ands" are divided by "?".  */

  init_split_rec (&option_term_rec);
  split_string (&option_term_rec, s, '+', TRUE);

  if (option_term_rec.count == 0)
    {
      clear_split_rec (&option_term_rec);
      return FALSE;
    }

  for (i = 0; i < option_term_rec.count; i++)
    {
      char *option_name = option_term_rec.vec[i];
      bfd_boolean is_true = TRUE;
      ReqOrOption *req;
      ReqOrOption **r_p;

      if (strncmp (option_name, "no-", 3) == 0)
	{
	  option_name = xstrdup (&option_name[3]);
	  is_true = FALSE;
	}
      else
	option_name = xstrdup (option_name);

      req = (ReqOrOption *) xmalloc (sizeof (ReqOrOption));
      req->option_name = option_name;
      req->is_true = is_true;
      req->next = NULL;

      /* Append to list.  */
      for (r_p = &option->or_option_terms; (*r_p) != NULL;
	   r_p = &(*r_p)->next)
	;
      (*r_p) = req;
    }
  return TRUE;
}


/* Parse a string like:
   "insn op1, op2, op3, op4 | op1 != op2 | op2 == op3 | op4 == 1".
   I.E., instruction "insn" with 4 operands where operand 1 and 2 are not
   the same and operand 2 and 3 are the same and operand 4 is 1.

   or:

   "insn op1 | op1 == 1 / density + boolean / no-useroption".
   i.e. instruction "insn" with 1 operands where operand 1 is 1
   when "density" or "boolean" options are available and
   "useroption" is not available.

   Because the current implementation of this parsing scheme uses
   split_string, it requires that '|' and '?' are only used as
   delimiters for predicates and required options.  */

static bfd_boolean
parse_insn_pattern (const char *in, insn_pattern *insn)
{
  split_rec rec;
  split_rec optionrec;
  int i;

  init_insn_pattern (insn);

  init_split_rec (&optionrec);
  split_string (&optionrec, in, '?', TRUE);
  if (optionrec.count == 0)
    {
      clear_split_rec (&optionrec);
      return FALSE;
    }

  init_split_rec (&rec);

  split_string (&rec, optionrec.vec[0], '|', TRUE);

  if (rec.count == 0)
    {
      clear_split_rec (&rec);
      clear_split_rec (&optionrec);
      return FALSE;
    }

  if (!parse_insn_templ (rec.vec[0], &insn->t))
    {
      clear_split_rec (&rec);
      clear_split_rec (&optionrec);
      return FALSE;
    }

  for (i = 1; i < rec.count; i++)
    {
      precond_e *cond = (precond_e *) xmalloc (sizeof (precond_e));

      if (!parse_precond (rec.vec[i], cond))
	{
	  clear_split_rec (&rec);
	  clear_split_rec (&optionrec);
	  clear_insn_pattern (insn);
	  return FALSE;
	}

      /* Append the condition.  */
      *insn->preconds.tail = cond;
      insn->preconds.tail = &cond->next;
    }

  for (i = 1; i < optionrec.count; i++)
    {
      /* Handle the option conditions.  */
      ReqOption **r_p;
      ReqOption *req_option = (ReqOption *) xmalloc (sizeof (ReqOption));
      req_option->or_option_terms = NULL;
      req_option->next = NULL;

      if (!parse_option_cond (optionrec.vec[i], req_option))
	{
	  clear_split_rec (&rec);
	  clear_split_rec (&optionrec);
	  clear_insn_pattern (insn);
	  clear_req_option_list (&req_option);
	  return FALSE;
	}

      /* Append the condition.  */
      for (r_p = &insn->options; (*r_p) != NULL; r_p = &(*r_p)->next)
	;

      (*r_p) = req_option;
    }

  clear_split_rec (&rec);
  clear_split_rec (&optionrec);
  return TRUE;
}


static bfd_boolean
parse_insn_repl (const char *in, insn_repl *r_p)
{
  /* This is a list of instruction templates separated by ';'.  */
  split_rec rec;
  int i;

  split_string (&rec, in, ';', TRUE);

  for (i = 0; i < rec.count; i++)
    {
      insn_repl_e *e = (insn_repl_e *) xmalloc (sizeof (insn_repl_e));

      e->next = NULL;

      if (!parse_insn_templ (rec.vec[i], &e->t))
	{
	  free (e);
	  clear_insn_repl (r_p);
	  return FALSE;
	}
      *r_p->tail = e;
      r_p->tail = &e->next;
    }
  return TRUE;
}


static bfd_boolean
transition_applies (insn_pattern *initial_insn,
		    const char *from_string ATTRIBUTE_UNUSED,
		    const char *to_string ATTRIBUTE_UNUSED)
{
  ReqOption *req_option;

  for (req_option = initial_insn->options;
       req_option != NULL;
       req_option = req_option->next)
    {
      ReqOrOption *req_or_option = req_option->or_option_terms;

      if (req_or_option == NULL
	  || req_or_option->next != NULL)
	continue;

      if (strncmp (req_or_option->option_name, "IsaUse", 6) == 0)
	{
	  bfd_boolean option_available = FALSE;
	  char *option_name = req_or_option->option_name + 6;
	  if (!strcmp (option_name, "DensityInstruction"))
	    option_available = (XCHAL_HAVE_DENSITY == 1);
	  else if (!strcmp (option_name, "L32R"))
	    option_available = (XCHAL_HAVE_L32R == 1);
	  else if (!strcmp (option_name, "Const16"))
	    option_available = (XCHAL_HAVE_CONST16 == 1);
	  else if (!strcmp (option_name, "Loops"))
	    option_available = (XCHAL_HAVE_LOOPS == 1);
	  else if (!strcmp (option_name, "WideBranches"))
	    option_available 
	      = (XCHAL_HAVE_WIDE_BRANCHES == 1 && produce_flix == FLIX_ALL);
	  else if (!strcmp (option_name, "PredictedBranches"))
	    option_available
	      = (XCHAL_HAVE_PREDICTED_BRANCHES == 1
		 && produce_flix == FLIX_ALL);
	  else if (!strcmp (option_name, "Booleans"))
	    option_available = (XCHAL_HAVE_BOOLEANS == 1);
	  else
	    as_warn (_("invalid configuration option '%s' in transition rule '%s'"),
		     req_or_option->option_name, from_string);
	  if ((option_available ^ req_or_option->is_true) != 0)
	    return FALSE;
	}
      else if (strcmp (req_or_option->option_name, "realnop") == 0)
	{
	  bfd_boolean nop_available =
	    (xtensa_opcode_lookup (xtensa_default_isa, "nop")
	     != XTENSA_UNDEFINED);
	  if ((nop_available ^ req_or_option->is_true) != 0)
	    return FALSE;
	}
    }
  return TRUE;
}


static bfd_boolean
wide_branch_opcode (const char *opcode_name,
		    char *suffix,
		    xtensa_opcode *popcode)
{
  xtensa_isa isa = xtensa_default_isa;
  xtensa_opcode opcode;
  static char wbr_name_buf[20];

  if (strncmp (opcode_name, "WIDE.", 5) != 0)
    return FALSE;

  strcpy (wbr_name_buf, opcode_name + 5);
  strcat (wbr_name_buf, suffix);
  opcode = xtensa_opcode_lookup (isa, wbr_name_buf);
  if (opcode != XTENSA_UNDEFINED)
    {
      *popcode = opcode;
      return TRUE;
    }

  return FALSE;
}


static TransitionRule *
build_transition (insn_pattern *initial_insn,
		  insn_repl *replace_insns,
		  const char *from_string,
		  const char *to_string)
{
  TransitionRule *tr = NULL;
  xtensa_opcode opcode;
  xtensa_isa isa = xtensa_default_isa;
  BuildInstr *literal_bi;

  opname_map_e *op1;
  opname_map_e *op2;

  precond_e *precond;
  insn_repl_e *r;

  if (!wide_branch_opcode (initial_insn->t.opcode_name, ".w18", &opcode) 
      && !wide_branch_opcode (initial_insn->t.opcode_name, ".w15", &opcode))
    opcode = xtensa_opcode_lookup (isa, initial_insn->t.opcode_name);

  if (opcode == XTENSA_UNDEFINED)
    {
      /* It is OK to not be able to translate some of these opcodes.  */
      return NULL;
    }


  if (xtensa_opcode_num_operands (isa, opcode)
      != insn_templ_operand_count (&initial_insn->t))
    {
      /* This is also OK because there are opcodes that
	 have different numbers of operands on different
	 architecture variations.  */
      return NULL;
    }

  tr = (TransitionRule *) xmalloc (sizeof (TransitionRule));
  tr->opcode = opcode;
  tr->conditions = NULL;
  tr->to_instr = NULL;

  /* Build the conditions. First, equivalent operand condition....  */
  for (op1 = initial_insn->t.operand_map.head; op1 != NULL; op1 = op1->next)
    {
      for (op2 = op1->next; op2 != NULL; op2 = op2->next)
	{
	  if (same_operand_name (op1, op2))
	    {
	      append_value_condition (tr, OP_EQUAL,
				      op1->operand_num, op2->operand_num);
	    }
	}
    }

  /* Now the condition that an operand value must be a constant....  */
  for (op1 = initial_insn->t.operand_map.head; op1 != NULL; op1 = op1->next)
    {
      if (op_is_constant (op1))
	{
	  append_constant_value_condition (tr,
					   OP_EQUAL,
					   op1->operand_num,
					   op_get_constant (op1));
	}
    }


  /* Now add the explicit preconditions listed after the "|" in the spec.
     These are currently very limited, so we do a special case
     parse for them.  We expect spaces, opname != opname.  */
  for (precond = initial_insn->preconds.head;
       precond != NULL;
       precond = precond->next)
    {
      op1 = NULL;
      op2 = NULL;

      if (precond->opname1)
	{
	  op1 = get_opmatch (&initial_insn->t.operand_map, precond->opname1);
	  if (op1 == NULL)
	    as_fatal (_("opcode '%s': no bound opname '%s' "
			"for precondition in '%s'"),
		      xtensa_opcode_name (isa, opcode),
		      precond->opname1, from_string);
	}

      if (precond->opname2)
	{
	  op2 = get_opmatch (&initial_insn->t.operand_map, precond->opname2);
	  if (op2 == NULL)
	    as_fatal (_("opcode '%s': no bound opname '%s' "
			"for precondition in %s"),
		      xtensa_opcode_name (isa, opcode),
		      precond->opname2, from_string);
	}

      if (op1 == NULL && op2 == NULL)
	as_fatal (_("opcode '%s': precondition only contains "
		    "constants in '%s'"),
		  xtensa_opcode_name (isa, opcode), from_string);
      else if (op1 != NULL && op2 != NULL)
	append_value_condition (tr, precond->cmpop,
				op1->operand_num, op2->operand_num);
      else if (op2 == NULL)
	append_constant_value_condition (tr, precond->cmpop,
					 op1->operand_num, precond->opval2);
      else
	append_constant_value_condition (tr, precond->cmpop,
					 op2->operand_num, precond->opval1);
    }

  tr->options = clone_req_option_list (initial_insn->options);

  /* Generate the replacement instructions.  Some of these
     "instructions" are actually labels and literals.  There can be at
     most one literal and at most one label.  A literal must be defined
     (e.g., "LITERAL %imm") before use (e.g., "%LITERAL").  The labels
     can be used before they are defined.  Also there are a number of
     special operands (e.g., HI24S).  */

  literal_bi = NULL;
  for (r = replace_insns->head; r != NULL; r = r->next)
    {
      BuildInstr *bi;
      const char *opcode_name;
      int operand_count;
      opname_map_e *op;
      const char *fn_name;
      const char *operand_arg_name;

      bi = (BuildInstr *) xmalloc (sizeof (BuildInstr));
      append_build_insn (tr, bi);

      bi->opcode = XTENSA_UNDEFINED;
      bi->ops = NULL;
      bi->next = NULL;

      opcode_name = r->t.opcode_name;
      operand_count = insn_templ_operand_count (&r->t);

      if (strcmp (opcode_name, "LITERAL") == 0)
	{
	  bi->typ = INSTR_LITERAL_DEF;
	  if (operand_count != 1)
	    as_fatal (_("expected one operand for generated literal"));
	  literal_bi = bi;
	}
      else if (strcmp (opcode_name, "LABEL") == 0)
	{
	  bi->typ = INSTR_LABEL_DEF;
	  if (operand_count != 0)
	    as_fatal (_("expected 0 operands for generated label"));
	}
      else
	{
	  bi->typ = INSTR_INSTR;
	  if (wide_branch_opcode (opcode_name, ".w18", &bi->opcode)
	      || wide_branch_opcode (opcode_name, ".w15", &bi->opcode))
	    opcode_name = xtensa_opcode_name (isa, bi->opcode);
	  else
	    bi->opcode = xtensa_opcode_lookup (isa, opcode_name);

	  if (bi->opcode == XTENSA_UNDEFINED)
	    {
	      as_warn (_("invalid opcode '%s' in transition rule '%s'"),
		       opcode_name, to_string);
	      return NULL;
	    }

	  /* Check for the right number of ops.  */
	  if (xtensa_opcode_num_operands (isa, bi->opcode)
	      != (int) operand_count)
	    as_fatal (_("opcode '%s': replacement does not have %d ops"),
		      opcode_name,
		      xtensa_opcode_num_operands (isa, bi->opcode));
	}

      for (op = r->t.operand_map.head; op != NULL; op = op->next)
	{
	  unsigned idnum;

	  if (op_is_constant (op))
	    append_constant_op (bi, op->operand_num, op_get_constant (op));
	  else if (strcmp (op->operand_name, "%LITERAL") == 0)
	    {
	      if (! literal_bi || ! literal_bi->ops || literal_bi->ops->next)
		as_fatal (_("opcode '%s': cannot find literal definition"),
			  opcode_name);
	      append_literal_op (bi, op->operand_num,
				 literal_bi->ops->op_data);
	    }
	  else if (strcmp (op->operand_name, "%LABEL") == 0)
	    append_label_op (bi, op->operand_num);
	  else if (op->operand_name[0] == 'a'
		   && parse_constant (op->operand_name + 1, &idnum))
	    append_constant_op (bi, op->operand_num, idnum);
	  else if (op->operand_name[0] == '%')
	    {
	      opname_map_e *orig_op;
	      orig_op = get_opmatch (&initial_insn->t.operand_map,
				     op->operand_name);
	      if (orig_op == NULL)
		as_fatal (_("opcode %s: unidentified operand '%s' in '%s'"),
			  opcode_name, op->operand_name, to_string);
	      append_field_op (bi, op->operand_num, orig_op->operand_num);
	    }
	  else if (strcmp (op->operand_name, "FREEREG") == 0)
	    {
	      append_user_fn_field_op (bi, op->operand_num, OP_FREEREG, 0);
	    }
	  else if (parse_special_fn (op->operand_name,
				     &fn_name, &operand_arg_name))
	    {
	      opname_map_e *orig_op;
	      OpType typ = OP_CONSTANT;

	      if (strcmp (fn_name, "LOW8") == 0)
		typ = OP_OPERAND_LOW8;
	      else if (strcmp (fn_name, "HI24S") == 0)
		typ = OP_OPERAND_HI24S;
	      else if (strcmp (fn_name, "F32MINUS") == 0)
		typ = OP_OPERAND_F32MINUS;
	      else if (strcmp (fn_name, "LOW16U") == 0)
		typ = OP_OPERAND_LOW16U;
	      else if (strcmp (fn_name, "HI16U") == 0)
		typ = OP_OPERAND_HI16U;
	      else
		as_fatal (_("unknown user-defined function %s"), fn_name);

	      orig_op = get_opmatch (&initial_insn->t.operand_map,
				     operand_arg_name);
	      if (orig_op == NULL)
		as_fatal (_("opcode %s: unidentified operand '%s' in '%s'"),
			  opcode_name, op->operand_name, to_string);
	      append_user_fn_field_op (bi, op->operand_num,
				       typ, orig_op->operand_num);
	    }
	  else
	    as_fatal (_("opcode %s: could not parse operand '%s' in '%s'"),
		      opcode_name, op->operand_name, to_string);
	}
    }

  return tr;
}


static TransitionTable *
build_transition_table (const string_pattern_pair *transitions,
			int transition_count,
			transition_cmp_fn cmp)
{
  TransitionTable *table = NULL;
  int num_opcodes = xtensa_isa_num_opcodes (xtensa_default_isa);
  int i, tnum;

  if (table != NULL)
    return table;

  /* Otherwise, build it now.  */
  table = (TransitionTable *) xmalloc (sizeof (TransitionTable));
  table->num_opcodes = num_opcodes;
  table->table =
    (TransitionList **) xmalloc (sizeof (TransitionTable *) * num_opcodes);

  for (i = 0; i < num_opcodes; i++)
    table->table[i] = NULL;

  for (tnum = 0; tnum < transition_count; tnum++)
    {
      const char *from_string = transitions[tnum].pattern;
      const char *to_string = transitions[tnum].replacement;

      insn_pattern initial_insn;
      insn_repl replace_insns;
      TransitionRule *tr;

      init_insn_pattern (&initial_insn);
      if (!parse_insn_pattern (from_string, &initial_insn))
	as_fatal (_("could not parse INSN_PATTERN '%s'"), from_string);

      init_insn_repl (&replace_insns);
      if (!parse_insn_repl (to_string, &replace_insns))
	as_fatal (_("could not parse INSN_REPL '%s'"), to_string);

      if (transition_applies (&initial_insn, from_string, to_string))
	{
	  tr = build_transition (&initial_insn, &replace_insns,
				 from_string, to_string);
	  if (tr)
	    append_transition (table, tr->opcode, tr, cmp);
	  else
	    {
#if TENSILICA_DEBUG
	      as_warn (_("could not build transition for %s => %s"),
		       from_string, to_string);
#endif
	    }
	}

      clear_insn_repl (&replace_insns);
      clear_insn_pattern (&initial_insn);
    }
  return table;
}


extern TransitionTable *
xg_build_widen_table (transition_cmp_fn cmp)
{
  static TransitionTable *table = NULL;
  if (table == NULL)
    table = build_transition_table (widen_spec_list, WIDEN_COUNT, cmp);
  return table;
}


extern TransitionTable *
xg_build_simplify_table (transition_cmp_fn cmp)
{
  static TransitionTable *table = NULL;
  if (table == NULL)
    table = build_transition_table (simplify_spec_list, SIMPLIFY_COUNT, cmp);
  return table;
}
@


1.20
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d2 2
a3 1
   Copyright 2003, 2004, 2005, 2007, 2008 Free Software Foundation, Inc.
@


1.19
log
@2009-01-07  Sterling Augustine  <sterling@@tensilica.com>

	* config/tc-xtensa.c (produce_flix): New.
	(option_flix, optoin_no_generate_flix, option_no_flix) Define.
	(md_longopts): Add support for them.
	(md_parse_option): Likewise.
	(md_show_usage): Add help message.
	(finish_vinsn): Don't allow multi-slot flix when produce_flix
	option is set to FLIX_NONE.
	* config/xtensa-relax.c (transition_applies): Only relax to
	flix branches when produce_flix equals FLIX_ALL.
	* config/xtensa-relax.h (flix_level, FLIX_ALL, FLIX_NO_GENERATE
	FLIX_NONE): New.
	(produce_flix): Declare.
@
text
@d528 2
a529 2
  assert (tt != NULL);
  assert (opcode < tt->num_opcodes);
d902 1
a902 1
  assert (m1->operand_name == NULL);
@


1.18
log
@2008-11-04  Sterling Augustine  <sterling@@tensilica.com>
	* config/tc-xtensa.c (xtensa_j_opcode): New.
	(xg_instruction_matches_option_term): Handle "FREEREG" option.
	(xg_build_to_insn): Likewise.  Update renamed tls_reloc reference.
	(md_begin): Initialize xtensa_j_opcode.
	(md_assemble): Update renamed tls_reloc reference.  Handle "j.l".
	(xg_assemble_vliw_tokens): Save free_reg info in the frag.
	(tinsn_immed_from_frag): Get free_reg info back out of the frag.
	(vinsn_to_insnbuf): Update renamed tls_reloc references.
	Distinguish extra argument for "FREEREG" from extra TLS argument.
	* config/tc-xtensa.h (struct xtensa_frag_type): Add free_reg field.
	* config/xtensa-istack.h (struct tinsn_struct): Rename tls_reloc
	field to extra_arg.
	* config/xtensa-relax.c (widen_spec_list): Add rules to relax "j.l".
	(build_transition): Handle "FREEREG" operand.
	* config/xtensa-relax.h (enum op_type): Add OP_FREEREG.
2008-11-04  Bob Wilson  <bob.wilson@@acm.org>
	* gas/xtensa/all.exp: Run jlong test.
	* gas/xtensa/jlong.d: New.
	* gas/xtensa/jlong.s: New.
@
text
@d1546 2
a1547 1
	    option_available = (XCHAL_HAVE_WIDE_BRANCHES == 1);
d1549 3
a1551 1
	    option_available = (XCHAL_HAVE_PREDICTED_BRANCHES == 1);
@


1.17
log
@2008-08-20  Bob Wilson  <bob.wilson@@acm.org>
bfd/
        * elf-bfd.h (elf_object_id): Add XTENSA_ELF_TDATA.
        * elf32-xtensa.c (elf_howto_table): Add TLS relocations.
        (elf_xtensa_reloc_type_lookup): Likewise.
        (TCB_SIZE): Define.
        (elf_xtensa_link_hash_entry): New.
        (GOT_UNKNOWN, GOT_NORMAL, GOT_TLS_GD, GOT_TLS_IE, GOT_TLS_ANY): Define.
        (elf_xtensa_hash_entry): Define.
        (elf_xtensa_obj_tdata): New.
        (elf_xtensa_tdata): Define.
        (elf_xtensa_local_got_tls_type): Define.
        (elf_xtensa_local_tlsfunc_refcounts): Define.
        (is_xtensa_elf): Define.
        (elf_xtensa_mkobject): New.
        (elf_xtensa_link_hash_table): Add tlsbase field.
        (elf_xtensa_link_hash_newfunc): New.
        (elf_xtensa_link_hash_table_create): Use elf_xtensa_link_hash_newfunc.
        Create an entry for "_TLS_MODULE_BASE_" and save it in tlsbase field.
        (elf_xtensa_copy_indirect_symbol): New.
        (elf_xtensa_check_relocs): Rewrite to handle TLS relocations.
        (elf_xtensa_gc_sweep_hook): Likewise.
        (elf_xtensa_allocate_dynrelocs): Optimize away GOT entries for
        TLSDESC_FN relocations when an IE reference is seen.
        (elf_xtensa_allocate_local_got_size): Likewise.
        (elf_xtensa_always_size_sections): New.
        (dtpoff_base, tpoff): New.
        (elf_xtensa_do_reloc): Handle TLS relocations.
        (replace_tls_insn): New.
        (IS_XTENSA_TLS_RELOC): Define.
        (elf_xtensa_relocate_section): Handle TLS relocations.
        (get_indirect_call_dest_reg): New.
        (bfd_elf32_mkobject): Define.
        (elf_backend_always_size_sections): New.
        (elf_backend_copy_indirect_symbol): New.
        * reloc.c (BFD_RELOC_XTENSA_TLSDESC_FN, BFD_RELOC_XTENSA_TLSDESC_ARG)
        (BFD_RELOC_XTENSA_TLS_DTPOFF, BFD_RELOC_XTENSA_TLS_TPOFF)
        (BFD_RELOC_XTENSA_TLS_FUNC, BFD_RELOC_XTENSA_TLS_ARG)
        (BFD_RELOC_XTENSA_TLS_CALL): New.
        * bfd-in2.h: Regenerate.
        * libbfd.h: Regenerate.
gas/
        * config/tc-xtensa.c (O_tlsfunc, O_tlsarg, O_tlscall): Define.
        (O_tpoff, O_dtpoff): Define.
        (suffix_relocs): Add entries for TLS suffixes.
        (xtensa_elf_cons): Check for invalid use of TLS relocations.
        (map_operator_to_reloc): Add is_literal parameter and use it to
        control translating TLS instruction relocations to the corresponding
        literal relocations.
        (xg_valid_literal_expression): Allow TLS operators.
        (xg_build_to_insn): Copy TLS operators from pseudo-instruction
        operands to generated literals.
        (xg_assemble_literal): Handle TLS operators.  Update call to
        map_operator_to_reloc.
        (md_assemble): Handle CALLXn.TLS pseudo-instruction.
        (md_apply_fix): Handle TLS relocations.
        (emit_single_op): Handle TLS operators.
        (convert_frag_immed): Update call to map_operator_to_reloc.
        (vinsn_to_insnbuf): Emit relocations for TLS-related instructions.
        * config/xtensa-istack.h (tinsn_struct): Add tls_reloc field.
        * config/xtensa-relax.c (append_literal_op): Add src_op parameter
        to initialize the op_data field of the BuildOp.
        (build_transition): Use it here to record the source operand
        corresponding to a generated literal.
        * config/xtensa-relax.h (build_op): Comment op_data use for literals.
include/elf/
        * xtensa.h (R_XTENSA_TLSDESC_FN, R_XTENSA_TLSDESC_ARG)
        (R_XTENSA_TLS_DTPOFF, R_XTENSA_TLS_TPOFF, R_XTENSA_TLS_FUNC)
        (R_XTENSA_TLS_ARG, R_XTENSA_TLS_CALL): New.
ld/testsuite/
        * ld-xtensa/tlsbin.dd, ld-xtensa/tlsbin.rd, ld-xtensa/tlsbin.s,
        ld-xtensa/tlsbin.sd, ld-xtensa/tlsbin.td, ld-xtensa/tlslib.s,
        ld-xtensa/tlspic.dd, ld-xtensa/tlspic.rd, ld-xtensa/tlspic.sd,
        ld-xtensa/tlspic.td, ld-xtensa/tlspic1.s, ld-xtensa/tlspic2.s: New.
        * ld-xtensa/xtensa.exp: Run them.
@
text
@d466 8
a473 1
   "const16 a12,HI16U(%label); const16 a12,LOW16U(%label); callx12 a12,%ar12"}
d1803 4
@


1.16
log
@Switch to GPLv3
@
text
@d2 1
a2 1
   Copyright 2003, 2004, 2005, 2007 Free Software Foundation, Inc.
d648 1
a648 1
append_literal_op (BuildInstr *bi, unsigned op1)
d654 1
a654 1
  b_op->op_data = 0;
d1597 1
d1710 1
d1735 1
d1774 7
a1780 1
	    append_literal_op (bi, op->operand_num);
@


1.15
log
@	* config/tc-xtensa.c (xg_assembly_relax): Comment termination rules.
	(frag_format_size): Handle RELAX_IMMED_STEP3.
	(xtensa_relax_frag, md_convert_frag): Likewise.
	* config/tc-xtensa.h (xtensa_relax_statesE): Add RELAX_IMMED_STEP3.
	(RELAX_IMMED_MAXSTEPS): Adjust.
	* config/xtensa-relax.c (widen_spec_list): Add transitions from
	wide branches to branch-over-jumps.
	(build_transition): Handle wide branches in transition patterns.
@
text
@d8 1
a8 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.14
log
@	* config/xtensa-relax.h (struct build_instr): Delete id field.
	* config/xtensa-relax.c (widen_spec_list): Remove zeros from LITERAL
	and LABEL tokens.
	(append_literal_op, append_label_op): Remove litnum/labnum arguments;
	set op_data fields to zero.
	(parse_id_constant): Delete.
	(build_transition): Remove code to handle numbered literals and labels.
@
text
@d250 4
a253 1
     => addmi a4, 0x1000, addi a4, 0x10.  */
d386 4
d425 23
d1604 4
a1607 1
  opcode = xtensa_opcode_lookup (isa, initial_insn->t.opcode_name);
@


1.13
log
@	* config/xtensa-relax.c (build_transition): Remove code after as_fatal.
	(build_transition_table): Likewise.
@
text
@d52 2
a53 2
                      | 'LABEL' num
                      | 'LITERAL' num ' ' VARIABLE
d75 1
a75 1
   {"beqz %as,%label", "bnez %as,%LABEL0;j %label;LABEL0"}
d80 1
a80 1
   {"movi %at,%imm", "LITERAL0 %imm; l32r %at,%LITERAL0"}
d90 1
a90 1
   "LITERAL0 %imm; l32r %at,%LITERAL0; add %at,%at,%as; l32i %at,%at,0"}
d271 1
a271 1
   "LITERAL0 %imm; l32r %at,%LITERAL0"},
d282 1
a282 1
   "LITERAL0 %imm; l32r %ar,%LITERAL0; add %ar,%as,%ar"},
d288 1
a288 1
   "LITERAL0 %imm; l32r %at,%LITERAL0; add %at,%at,%as; l8ui %at,%at,0"},
d290 1
a290 1
   "LITERAL0 %imm; l32r %at,%LITERAL0; add %at,%at,%as; l16si %at,%at,0"},
d292 1
a292 1
   "LITERAL0 %imm; l32r %at,%LITERAL0; add %at,%at,%as; l16ui %at,%at,0"},
d294 1
a294 1
   "LITERAL0 %imm; l32r %at,%LITERAL0; add %at,%at,%as; l32i %at,%at,0"},
d310 1
a310 1
   "loop %as,%LABEL0;"
d319 1
a319 1
   "LABEL0"},
d323 1
a323 1
   "loopgtz %as,%LABEL0;"
d332 1
a332 1
   "LABEL0"},
d335 1
a335 1
   "loopnez %as,%LABEL0;"
d344 1
a344 1
   "LABEL0"},
d379 4
a382 4
  {"beqz %as,%label ? IsaUseDensityInstruction", "bnez.n %as,%LABEL0;j %label;LABEL0"},
  {"bnez %as,%label ? IsaUseDensityInstruction", "beqz.n %as,%LABEL0;j %label;LABEL0"},
  {"beqz %as,%label", "bnez %as,%LABEL0;j %label;LABEL0"},
  {"bnez %as,%label", "beqz %as,%LABEL0;j %label;LABEL0"},
d385 4
a388 4
  {"beqzt %as,%label ? IsaUsePredictedBranches", "bnez %as,%LABEL0;j %label;LABEL0"},
  {"bnezt %as,%label ? IsaUsePredictedBranches", "beqz %as,%LABEL0;j %label;LABEL0"},
  {"beqt %as,%at,%label ? IsaUsePredictedBranches", "bne %as,%at,%LABEL0;j %label;LABEL0"},
  {"bnet %as,%at,%label ? IsaUsePredictedBranches", "beq %as,%at,%LABEL0;j %label;LABEL0"},
d391 2
a392 2
  {"bt %bs,%label ? IsaUseBooleans", "bf %bs,%LABEL0;j %label;LABEL0"},
  {"bf %bs,%label ? IsaUseBooleans", "bt %bs,%LABEL0;j %label;LABEL0"},
d395 22
a416 22
  {"bgez %as,%label", "bltz %as,%LABEL0;j %label;LABEL0"},
  {"bltz %as,%label", "bgez %as,%LABEL0;j %label;LABEL0"},
  {"beqi %as,%imm,%label", "bnei %as,%imm,%LABEL0;j %label;LABEL0"},
  {"bnei %as,%imm,%label", "beqi %as,%imm,%LABEL0;j %label;LABEL0"},
  {"bgei %as,%imm,%label", "blti %as,%imm,%LABEL0;j %label;LABEL0"},
  {"blti %as,%imm,%label", "bgei %as,%imm,%LABEL0;j %label;LABEL0"},
  {"bgeui %as,%imm,%label", "bltui %as,%imm,%LABEL0;j %label;LABEL0"},
  {"bltui %as,%imm,%label", "bgeui %as,%imm,%LABEL0;j %label;LABEL0"},
  {"bbci %as,%imm,%label", "bbsi %as,%imm,%LABEL0;j %label;LABEL0"},
  {"bbsi %as,%imm,%label", "bbci %as,%imm,%LABEL0;j %label;LABEL0"},
  {"beq %as,%at,%label", "bne %as,%at,%LABEL0;j %label;LABEL0"},
  {"bne %as,%at,%label", "beq %as,%at,%LABEL0;j %label;LABEL0"},
  {"bge %as,%at,%label", "blt %as,%at,%LABEL0;j %label;LABEL0"},
  {"blt %as,%at,%label", "bge %as,%at,%LABEL0;j %label;LABEL0"},
  {"bgeu %as,%at,%label", "bltu %as,%at,%LABEL0;j %label;LABEL0"},
  {"bltu %as,%at,%label", "bgeu %as,%at,%LABEL0;j %label;LABEL0"},
  {"bany %as,%at,%label", "bnone %as,%at,%LABEL0;j %label;LABEL0"},
  {"bnone %as,%at,%label", "bany %as,%at,%LABEL0;j %label;LABEL0"},
  {"ball %as,%at,%label", "bnall %as,%at,%LABEL0;j %label;LABEL0"},
  {"bnall %as,%at,%label", "ball %as,%at,%LABEL0;j %label;LABEL0"},
  {"bbc %as,%at,%label", "bbs %as,%at,%LABEL0;j %label;LABEL0"},
  {"bbs %as,%at,%label", "bbc %as,%at,%LABEL0;j %label;LABEL0"},
d420 1
a420 1
   "LITERAL0 %label; l32r a0,%LITERAL0; callx0 a0,%ar0"},
d422 1
a422 1
   "LITERAL0 %label; l32r a4,%LITERAL0; callx4 a4,%ar4"},
d424 1
a424 1
   "LITERAL0 %label; l32r a8,%LITERAL0; callx8 a8,%ar8"},
d426 1
a426 1
   "LITERAL0 %label; l32r a12,%LITERAL0; callx12 a12,%ar12"},
d618 1
a618 1
append_literal_op (BuildInstr *bi, unsigned op1, unsigned litnum)
d624 1
a624 1
  b_op->op_data = litnum;
d631 1
a631 1
append_label_op (BuildInstr *bi, unsigned op1, unsigned labnum)
d637 1
a637 1
  b_op->op_data = labnum;
a984 24
/* Match a pattern like "foo1" with
   parse_id_constant("foo1", "foo", &num).
   This may also be used to just match a number.  */

static bfd_boolean
parse_id_constant (const char *in, const char *name, unsigned *val_p)
{
  unsigned namelen = 0;
  const char *p;

  if (in == NULL)
    return FALSE;

  if (name != NULL)
    namelen = strlen (name);

  if (name != NULL && strncmp (in, name, namelen) != 0)
    return FALSE;

  p = &in[namelen];
  return parse_constant (p, val_p);
}


a1572 4
  unsigned label_count = 0;
  unsigned max_label_count = 0;
  bfd_boolean has_label = FALSE;
  unsigned literal_count = 0;
d1670 5
a1674 6
     "instructions" are actually labels and literals.  The literals
     must be defined in order 0..n and a literal must be defined
     (e.g., "LITERAL0 %imm") before use (e.g., "%LITERAL0").  The
     labels must be defined in order, but they can be used before they
     are defined.  Also there are a number of special operands (e.g.,
     HI24S).  */
a1681 1
      unsigned idnum = 0;
a1687 1
      bi->id = 0;
d1695 1
a1695 1
      if (parse_id_constant (opcode_name, "LITERAL", &idnum))
a1697 4
	  bi->id = idnum;
	  if (idnum != literal_count)
	    as_fatal (_("generated literals must be numbered consecutively"));
	  ++literal_count;
a1699 1

d1701 1
a1701 1
      else if (parse_id_constant (opcode_name, "LABEL", &idnum))
a1703 4
	  bi->id = idnum;
	  if (idnum != label_count)
	    as_fatal (_("generated labels must be numbered consecutively"));
	  ++label_count;
d1737 6
a1742 16
	  else if (parse_id_constant (op->operand_name, "%LITERAL", &idnum))
	    {
	      if (idnum >= literal_count)
		as_fatal (_("opcode %s: replacement "
			    "literal %d >= literal_count(%d)"),
			  opcode_name, idnum, literal_count);
	      append_literal_op (bi, op->operand_num, idnum);
	    }
	  else if (parse_id_constant (op->operand_name, "%LABEL", &idnum))
	    {
	      has_label = TRUE;
	      if (idnum > max_label_count)
		max_label_count = idnum;
	      append_label_op (bi, op->operand_num, idnum);
	    }
	  else if (parse_id_constant (op->operand_name, "a", &idnum))
a1785 4
  if (has_label && max_label_count >= label_count)
    as_fatal (_("opcode %s: replacement label %d >= label_count(%d)"),
	      xtensa_opcode_name (isa, opcode),
	      max_label_count, label_count);
@


1.12
log
@	* config/xtensa-relax.c (widen_spec_list): Use new "WIDE.<opcode>"
	syntax instead of hardcoded opcodes with ".w18" suffixes.
	(wide_branch_opcode): New.
	(build_transition): Use it to check for wide branch opcodes with
	either ".w18" or ".w15" suffixes.
@
text
@d2 1
a2 1
   Copyright 2003, 2004, 2005 Free Software Foundation, Inc.
d1664 4
a1667 7
	    {
	      as_fatal (_("opcode '%s': no bound opname '%s' "
			  "for precondition in '%s'"),
			xtensa_opcode_name (isa, opcode),
			precond->opname1, from_string);
	      return NULL;
	    }
d1674 4
a1677 7
	    {
	      as_fatal (_("opcode '%s': no bound opname '%s' "
			  "for precondition in %s"),
		       xtensa_opcode_name (isa, opcode),
		       precond->opname2, from_string);
	      return NULL;
	    }
d1681 3
a1683 6
	{
	  as_fatal (_("opcode '%s': precondition only contains "
		      "constants in '%s'"),
		    xtensa_opcode_name (isa, opcode), from_string);
	  return NULL;
	}
d1800 3
a1802 8
		{
		  as_fatal (_("opcode %s: unidentified operand '%s' in '%s'"),
			    opcode_name, op->operand_name, to_string);

		  append_constant_op (bi, op->operand_num, 0);
		}
	      else
		append_field_op (bi, op->operand_num, orig_op->operand_num);
d1826 4
a1829 8
		{
		  as_fatal (_("opcode %s: unidentified operand '%s' in '%s'"),
			    opcode_name, op->operand_name, to_string);
		  append_constant_op (bi, op->operand_num, 0);
		}
	      else
		append_user_fn_field_op (bi, op->operand_num,
					 typ, orig_op->operand_num);
d1832 2
a1833 5
	    {
	      as_fatal (_("opcode %s: could not parse operand '%s' in '%s'"),
			opcode_name, op->operand_name, to_string);
	      append_constant_op (bi, op->operand_num, 0);
	    }
d1837 3
a1839 6
    {
      as_fatal (_("opcode %s: replacement label %d >= label_count(%d)"),
		xtensa_opcode_name (isa, opcode),
		max_label_count, label_count);
      return NULL;
    }
d1877 1
a1877 5
	{
	  as_fatal (_("could not parse INSN_PATTERN '%s'"), from_string);
	  clear_insn_pattern (&initial_insn);
	  continue;
	}
d1881 1
a1881 6
	{
	  as_fatal (_("could not parse INSN_REPL '%s'"), to_string);
	  clear_insn_pattern (&initial_insn);
	  clear_insn_repl (&replace_insns);
	  continue;
	}
@


1.11
log
@	* config/xtensa-relax.c (XCHAL_HAVE_WIDE_BRANCHES): Provide default.
@
text
@d352 24
a375 24
  {"beqz %as,%label ? IsaUseWideBranches", "beqz.w18 %as,%label"},
  {"bnez %as,%label ? IsaUseWideBranches", "bnez.w18 %as,%label"},
  {"bgez %as,%label ? IsaUseWideBranches", "bgez.w18 %as,%label"},
  {"bltz %as,%label ? IsaUseWideBranches", "bltz.w18 %as,%label"},
  {"beqi %as,%imm,%label ? IsaUseWideBranches", "beqi.w18 %as,%imm,%label"},
  {"bnei %as,%imm,%label ? IsaUseWideBranches", "bnei.w18 %as,%imm,%label"},
  {"bgei %as,%imm,%label ? IsaUseWideBranches", "bgei.w18 %as,%imm,%label"},
  {"blti %as,%imm,%label ? IsaUseWideBranches", "blti.w18 %as,%imm,%label"},
  {"bgeui %as,%imm,%label ? IsaUseWideBranches", "bgeui.w18 %as,%imm,%label"},
  {"bltui %as,%imm,%label ? IsaUseWideBranches", "bltui.w18 %as,%imm,%label"},
  {"bbci %as,%imm,%label ? IsaUseWideBranches", "bbci.w18 %as,%imm,%label"},
  {"bbsi %as,%imm,%label ? IsaUseWideBranches", "bbsi.w18 %as,%imm,%label"},
  {"beq %as,%at,%label ? IsaUseWideBranches", "beq.w18 %as,%at,%label"},
  {"bne %as,%at,%label ? IsaUseWideBranches", "bne.w18 %as,%at,%label"},
  {"bge %as,%at,%label ? IsaUseWideBranches", "bge.w18 %as,%at,%label"},
  {"blt %as,%at,%label ? IsaUseWideBranches", "blt.w18 %as,%at,%label"},
  {"bgeu %as,%at,%label ? IsaUseWideBranches", "bgeu.w18 %as,%at,%label"},
  {"bltu %as,%at,%label ? IsaUseWideBranches", "bltu.w18 %as,%at,%label"},
  {"bany %as,%at,%label ? IsaUseWideBranches", "bany.w18 %as,%at,%label"},
  {"bnone %as,%at,%label ? IsaUseWideBranches", "bnone.w18 %as,%at,%label"},
  {"ball %as,%at,%label ? IsaUseWideBranches", "ball.w18 %as,%at,%label"},
  {"bnall %as,%at,%label ? IsaUseWideBranches", "bnall.w18 %as,%at,%label"},
  {"bbc %as,%at,%label ? IsaUseWideBranches", "bbc.w18 %as,%at,%label"},
  {"bbs %as,%at,%label ? IsaUseWideBranches", "bbs.w18 %as,%at,%label"},
d1557 25
d1759 6
a1764 1
	  bi->opcode = xtensa_opcode_lookup (isa, r->t.opcode_name);
d1768 1
a1768 1
		       r->t.opcode_name, to_string);
d1771 1
@


1.10
log
@include:
	* xtensa-config.h (XCHAL_HAVE_WIDE_BRANCHES): New.
gas:
	* config/tc-xtensa.c (op_placement_info_struct): Delete single,
	single_size, widest, and widest_size fields.  Add narrowest_slot.
	(xg_emit_insn_to_buf): Remove fmt parameter and compute it here.
	Use xg_get_single_slot to find the slot.
	(finish_vinsn): Use emit_single_op instead of bundle_single_op.
	(bundle_single_op): Rename this to....
	(bundle_tinsn): ...this function, which builds a vliw_insn but does
	not call finish_vinsn.
	(emit_single_op): Use bundle_tinsn instead of bundle_single_op.
	(relax_frag_immed): Get num_slots from cur_vinsn.
	(convert_frag_narrow): Update call to xg_emit_insn_to_buf.
	(convert_frag_immed): Likewise.  Also, get num_slots from cur_vinsn.
	(init_op_placement_info_table): Set narrowest_slot field.  Remove
	code for deleted fields.
	(xg_get_single_size): Return narrowest_size field, not single_size.
	(xg_get_single_format): Return narrowest field, not single.
	(xg_get_single_slot): New.
	(tinsn_to_insnbuf): Rewrite to use tinsn_to_slotbuf.
	* config/xtensa-relax.c (widen_spec_list): Add wide branch relaxations.
	(transition_applies): Check wide branch option availability.
@
text
@d104 4
@


1.10.2.1
log
@Merge changes between binutils-csl-2_17-branchpoint and
binutils-2_17, except for the addition of generated files to CVS.
@
text
@a103 4
#ifndef XCHAL_HAVE_WIDE_BRANCHES
#define XCHAL_HAVE_WIDE_BRANCHES 0
#endif

d348 24
a371 24
  {"beqz %as,%label ? IsaUseWideBranches", "WIDE.beqz %as,%label"},
  {"bnez %as,%label ? IsaUseWideBranches", "WIDE.bnez %as,%label"},
  {"bgez %as,%label ? IsaUseWideBranches", "WIDE.bgez %as,%label"},
  {"bltz %as,%label ? IsaUseWideBranches", "WIDE.bltz %as,%label"},
  {"beqi %as,%imm,%label ? IsaUseWideBranches", "WIDE.beqi %as,%imm,%label"},
  {"bnei %as,%imm,%label ? IsaUseWideBranches", "WIDE.bnei %as,%imm,%label"},
  {"bgei %as,%imm,%label ? IsaUseWideBranches", "WIDE.bgei %as,%imm,%label"},
  {"blti %as,%imm,%label ? IsaUseWideBranches", "WIDE.blti %as,%imm,%label"},
  {"bgeui %as,%imm,%label ? IsaUseWideBranches", "WIDE.bgeui %as,%imm,%label"},
  {"bltui %as,%imm,%label ? IsaUseWideBranches", "WIDE.bltui %as,%imm,%label"},
  {"bbci %as,%imm,%label ? IsaUseWideBranches", "WIDE.bbci %as,%imm,%label"},
  {"bbsi %as,%imm,%label ? IsaUseWideBranches", "WIDE.bbsi %as,%imm,%label"},
  {"beq %as,%at,%label ? IsaUseWideBranches", "WIDE.beq %as,%at,%label"},
  {"bne %as,%at,%label ? IsaUseWideBranches", "WIDE.bne %as,%at,%label"},
  {"bge %as,%at,%label ? IsaUseWideBranches", "WIDE.bge %as,%at,%label"},
  {"blt %as,%at,%label ? IsaUseWideBranches", "WIDE.blt %as,%at,%label"},
  {"bgeu %as,%at,%label ? IsaUseWideBranches", "WIDE.bgeu %as,%at,%label"},
  {"bltu %as,%at,%label ? IsaUseWideBranches", "WIDE.bltu %as,%at,%label"},
  {"bany %as,%at,%label ? IsaUseWideBranches", "WIDE.bany %as,%at,%label"},
  {"bnone %as,%at,%label ? IsaUseWideBranches", "WIDE.bnone %as,%at,%label"},
  {"ball %as,%at,%label ? IsaUseWideBranches", "WIDE.ball %as,%at,%label"},
  {"bnall %as,%at,%label ? IsaUseWideBranches", "WIDE.bnall %as,%at,%label"},
  {"bbc %as,%at,%label ? IsaUseWideBranches", "WIDE.bbc %as,%at,%label"},
  {"bbs %as,%at,%label ? IsaUseWideBranches", "WIDE.bbs %as,%at,%label"},
a1552 25
static bfd_boolean
wide_branch_opcode (const char *opcode_name,
		    char *suffix,
		    xtensa_opcode *popcode)
{
  xtensa_isa isa = xtensa_default_isa;
  xtensa_opcode opcode;
  static char wbr_name_buf[20];

  if (strncmp (opcode_name, "WIDE.", 5) != 0)
    return FALSE;

  strcpy (wbr_name_buf, opcode_name + 5);
  strcat (wbr_name_buf, suffix);
  opcode = xtensa_opcode_lookup (isa, wbr_name_buf);
  if (opcode != XTENSA_UNDEFINED)
    {
      *popcode = opcode;
      return TRUE;
    }

  return FALSE;
}


d1730 1
a1730 6
	  if (wide_branch_opcode (opcode_name, ".w18", &bi->opcode)
	      || wide_branch_opcode (opcode_name, ".w15", &bi->opcode))
	    opcode_name = xtensa_opcode_name (isa, bi->opcode);
	  else
	    bi->opcode = xtensa_opcode_lookup (isa, opcode_name);

d1734 1
a1734 1
		       opcode_name, to_string);
a1736 1

@


1.10.4.1
log
@	* config/xtensa-relax.c (XCHAL_HAVE_WIDE_BRANCHES): Provide default.
@
text
@a103 4
#ifndef XCHAL_HAVE_WIDE_BRANCHES
#define XCHAL_HAVE_WIDE_BRANCHES 0
#endif

@


1.10.4.2
log
@	* config/xtensa-relax.c (widen_spec_list): Use new "WIDE.<opcode>"
	syntax instead of hardcoded opcodes with ".w18" suffixes.
	(wide_branch_opcode): New.
	(build_transition): Use it to check for wide branch opcodes with
	either ".w18" or ".w15" suffixes.
@
text
@d352 24
a375 24
  {"beqz %as,%label ? IsaUseWideBranches", "WIDE.beqz %as,%label"},
  {"bnez %as,%label ? IsaUseWideBranches", "WIDE.bnez %as,%label"},
  {"bgez %as,%label ? IsaUseWideBranches", "WIDE.bgez %as,%label"},
  {"bltz %as,%label ? IsaUseWideBranches", "WIDE.bltz %as,%label"},
  {"beqi %as,%imm,%label ? IsaUseWideBranches", "WIDE.beqi %as,%imm,%label"},
  {"bnei %as,%imm,%label ? IsaUseWideBranches", "WIDE.bnei %as,%imm,%label"},
  {"bgei %as,%imm,%label ? IsaUseWideBranches", "WIDE.bgei %as,%imm,%label"},
  {"blti %as,%imm,%label ? IsaUseWideBranches", "WIDE.blti %as,%imm,%label"},
  {"bgeui %as,%imm,%label ? IsaUseWideBranches", "WIDE.bgeui %as,%imm,%label"},
  {"bltui %as,%imm,%label ? IsaUseWideBranches", "WIDE.bltui %as,%imm,%label"},
  {"bbci %as,%imm,%label ? IsaUseWideBranches", "WIDE.bbci %as,%imm,%label"},
  {"bbsi %as,%imm,%label ? IsaUseWideBranches", "WIDE.bbsi %as,%imm,%label"},
  {"beq %as,%at,%label ? IsaUseWideBranches", "WIDE.beq %as,%at,%label"},
  {"bne %as,%at,%label ? IsaUseWideBranches", "WIDE.bne %as,%at,%label"},
  {"bge %as,%at,%label ? IsaUseWideBranches", "WIDE.bge %as,%at,%label"},
  {"blt %as,%at,%label ? IsaUseWideBranches", "WIDE.blt %as,%at,%label"},
  {"bgeu %as,%at,%label ? IsaUseWideBranches", "WIDE.bgeu %as,%at,%label"},
  {"bltu %as,%at,%label ? IsaUseWideBranches", "WIDE.bltu %as,%at,%label"},
  {"bany %as,%at,%label ? IsaUseWideBranches", "WIDE.bany %as,%at,%label"},
  {"bnone %as,%at,%label ? IsaUseWideBranches", "WIDE.bnone %as,%at,%label"},
  {"ball %as,%at,%label ? IsaUseWideBranches", "WIDE.ball %as,%at,%label"},
  {"bnall %as,%at,%label ? IsaUseWideBranches", "WIDE.bnall %as,%at,%label"},
  {"bbc %as,%at,%label ? IsaUseWideBranches", "WIDE.bbc %as,%at,%label"},
  {"bbs %as,%at,%label ? IsaUseWideBranches", "WIDE.bbs %as,%at,%label"},
a1556 25
static bfd_boolean
wide_branch_opcode (const char *opcode_name,
		    char *suffix,
		    xtensa_opcode *popcode)
{
  xtensa_isa isa = xtensa_default_isa;
  xtensa_opcode opcode;
  static char wbr_name_buf[20];

  if (strncmp (opcode_name, "WIDE.", 5) != 0)
    return FALSE;

  strcpy (wbr_name_buf, opcode_name + 5);
  strcat (wbr_name_buf, suffix);
  opcode = xtensa_opcode_lookup (isa, wbr_name_buf);
  if (opcode != XTENSA_UNDEFINED)
    {
      *popcode = opcode;
      return TRUE;
    }

  return FALSE;
}


d1734 1
a1734 6
	  if (wide_branch_opcode (opcode_name, ".w18", &bi->opcode)
	      || wide_branch_opcode (opcode_name, ".w15", &bi->opcode))
	    opcode_name = xtensa_opcode_name (isa, bi->opcode);
	  else
	    bi->opcode = xtensa_opcode_lookup (isa, opcode_name);

d1738 1
a1738 1
		       opcode_name, to_string);
a1740 1

@


1.9
log
@	* config/tc-xtensa.c: Remove excess whitespace.
	* config/tc-xtensa.h: Likewise.
	* config/xtensa-istack.h: Likewise.
	* config/xtensa-relax.c: Likewise.
	* config/xtensa-relax.h: Likewise.
@
text
@d342 33
d379 2
d383 6
d390 1
a402 2
  {"beqt %as,%at,%label ? IsaUsePredictedBranches", "bne %as,%at,%LABEL0;j %label;LABEL0"},
  {"bnet %as,%at,%label ? IsaUsePredictedBranches", "beq %as,%at,%LABEL0;j %label;LABEL0"},
a407 4

  {"bt %bs,%label ? IsaUseBooleans", "bf %bs,%LABEL0;j %label;LABEL0"},
  {"bf %bs,%label ? IsaUseBooleans", "bt %bs,%LABEL0;j %label;LABEL0"},

d1528 2
@


1.8
log
@Update the address and phone number of the FSF
@
text
@d18 1
a18 1
   the Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston, 
d28 1
a28 1
   operands from the pattern should be used in the result.  
d49 1
a49 1
   The replacement language 
d51 2
a52 2
   INSN_LABEL_LIT ::= INSN_TEMPL 
                      | 'LABEL' num 
d78 1
a78 1
   
d266 1
a266 1
  {"movi %at,%imm ? IsaUseL32R ", 
d268 1
a268 1
  {"movi %at,%imm ? IsaUseConst16", 
d1281 1
a1281 1
  new_req_option->or_option_terms = 
d1328 1
a1328 1
      for (r_p = &option->or_option_terms; (*r_p) != NULL; 
d1369 1
a1369 1
  
d1412 1
a1412 1
      
d1480 1
a1480 1
      if (strncmp (req_or_option->option_name, "IsaUse", 6) == 0) 
d1504 1
a1504 1
	  bfd_boolean nop_available = 
d1700 1
a1700 1
	  if (xtensa_opcode_num_operands (isa, bi->opcode) 
@


1.7
log
@update copyright dates
@
text
@d18 2
a19 2
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston, 
   MA 02111-1307, USA.  */
@


1.6
log
@	* config/atof-ieee.c, config/obj-coff.c, config/obj-elf.c,
	config/obj-ieee.c, config/obj-som.c, config/obj-vms.c,
	config/tc-a29k.c, config/tc-alpha.c, config/tc-arc.c,
	config/tc-arm.c, config/tc-d30v.c, config/tc-dlx.c,
	config/tc-fr30.c, config/tc-h8300.c, config/tc-h8500.c,
	config/tc-i370.c, config/tc-i386.c, config/tc-i960.c,
	config/tc-ia64.c, config/tc-m32r.c, config/tc-m32r.h,
	config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-mips.c,
	config/tc-mn10200.c, config/tc-msp430.c, config/tc-ns32k.c,
	config/tc-openrisc.c, config/tc-or32.c, config/tc-pdp11.c,
	config/tc-pj.c, config/tc-sparc.h, config/tc-tic54x.c,
	config/tc-tic80.c, config/tc-v850.c, config/tc-w65.c,
	config/tc-xtensa.c, config/tc-z8k.c, config/xtensa-relax.c: Remove
	#if 0'd code throughout.
@
text
@d2 1
a2 1
   Copyright 2003, 2004 Free Software Foundation, Inc.
@


1.5
log
@bfd ChangeLog

	* elf32-xtensa.c: Use ISO C90 formatting.

gas ChangeLog

	* config/tc-xtensa.c: Use ISO C90 formatting.
	* config/tc-xtensa.h: Likewise.
	* config/xtensa-istack.h: Likewise.
	* config/xtensa-relax.c: Likewise.
	* config/xtensa-relax.h: Likewise.

ld ChangeLog

	* emultempl/xtensaelf.em: Use ISO C90 formatting.

opcodes ChangeLog

	* xtensa-dis.c: Use ISO C90 formatting.
@
text
@a301 9
#if 0 /* Xtensa Synchronization Option not yet available */
  {"l32ai %at,%as,%imm ? IsaUseL32R",
   "LITERAL0 %imm; l32r %at,%LITERAL0; add.n %at,%at,%as; l32ai %at,%at,0"},
#endif
#if 0 /* Xtensa Speculation Option not yet available */
  {"l32is %at,%as,%imm ? IsaUseL32R",
   "LITERAL0 %imm; l32r %at,%LITERAL0; add.n %at,%at,%as; l32is %at,%at,0"},
#endif

a1538 4
#if 0
      as_warn (_("invalid opcode '%s' in transition rule '%s'"),
	       initial_insn->t.opcode_name, from_string);
#endif
a1548 6
#if 0
      as_fatal (_("opcode %s mismatched operand count %d != expected %d"),
		xtensa_opcode_name (isa, opcode),
		xtensa_num_operands (isa, opcode),
		insn_templ_operand_count (&initial_insn->t));
#endif
@


1.4
log
@bfd ChangeLog

	* elf32-xtensa.c (elf32xtensa_size_opt): New global variable.
	(xtensa_default_isa): Global variable moved here from xtensa-isa.c.
	(elf32xtensa_no_literal_movement): New global variable.
	(elf_howto_table): Add entries for new relocations.
	(elf_xtensa_reloc_type_lookup): Handle new relocations.
	(property_table_compare): When addresses are equal, compare sizes and
	various property flags.
	(property_table_matches): New.
	(xtensa_read_table_entries): Extend to read new property tables.  Add
	output_addr parameter to indicate that output addresses should be used.
	Use bfd_get_section_limit.
	(elf_xtensa_find_property_entry): New.
	(elf_xtensa_in_literal_pool): Use elf_xtensa_find_property_entry.
	(elf_xtensa_check_relocs): Handle new relocations.
	(elf_xtensa_do_reloc): Use bfd_get_section_limit.  Handle new
	relocations.  Use new xtensa-isa.h functions.
	(build_encoding_error_message): Remove encode_result parameter.  Add
	new target_address parameter used to detect alignment errors.
	(elf_xtensa_relocate_section): Use bfd_get_section_limit.  Clean up
	error handling.  Use new is_operand_relocation function.
	(elf_xtensa_combine_prop_entries, elf_xtensa_merge_private_bfd_data):
	Use underbar macro for error messages.  Formatting.
	(get_const16_opcode): New.
	(get_l32r_opcode): Add a separate flag for initialization.
	(get_relocation_opnd): Operand number is no longer explicit in the
	relocation.  Change to decode the opcode and analyze its operands.
	(get_relocation_slot): New.
	(get_relocation_opcode): Add bfd parameter.  Use bfd_get_section_limit.
	Use new xtensa-isa.h functions to handle multislot instructions.
	(is_l32r_relocation): Add bfd parameter.  Use is_operand_relocation.
	(get_asm_simplify_size, is_alt_relocation, is_operand_relocation,
	insn_decode_len, insn_decode_opcode, check_branch_target_aligned,
	check_loop_aligned, check_branch_target_aligned_address, narrowable,
	widenable, narrow_instruction, widen_instruction, op_single_fmt_table,
	get_single_format, init_op_single_format_table): New.
	(elf_xtensa_do_asm_simplify): Add error_message parameter and use it
	instead of calling _bfd_error_handler.  Use new xtensa-isa.h functions.
	(contract_asm_expansion): Add error_message parameter and pass it to
	elf_xtensa_do_asm_simplify.  Replace use of R_XTENSA_OP0 relocation
	with R_XTENSA_SLOT0_OP.
	(get_expanded_call_opcode): Extend to handle either L32R or CONST16
	instructions.  Use new xtensa-isa.h functions.
	(r_reloc struct): Add new virtual_offset field.
	(r_reloc_init): Add contents and content_length parameters.  Set
	virtual_offset field to zero.  Add contents to target_offset field for
	partial_inplace relocations.
	(r_reloc_is_defined): Check for null.
	(print_r_reloc): New debug function.
	(source_reloc struct): Replace xtensa_operand field with pair of the
	opcode and the operand position.  Add is_abs_literal field.
	(init_source_reloc): Specify operand by opcode/position pair.  Set
	is_abs_literal field.
	(source_reloc_compare): When target_offsets are equal, compare other
	fields to make sorting predictable.
	(literal_value struct): Add is_abs_literal field.
	(value_map_hash_table struct): Add has_last_loc and last_loc fields.
	(init_literal_value): New.
	(is_same_value): Replace with ...
	(literal_value_equal): ... this function.  Add comparisons of
	virtual_offset and is_abs_literal fields.
	(value_map_hash_table_init): Use bfd_zmalloc.  Check for allocation
	failure.  Initialize has_last_loc field.
	(value_map_hash_table_delete): New.
	(hash_literal_value): Rename to ...
	(literal_value_hash): ... this.  Include is_abs_literal flag and
	virtual_offset field in the hash value.
	(get_cached_value): Rename to ...
	(value_map_get_cached_value): ... this.  Update calls to
	literal_value_hash and literal_value_equal.
	(add_value_map): Check for allocation failure.  Update calls to
	value_map_get_cached_value and literal_value_hash.
	(text_action, text_action_list, text_action_t): New types.
	(find_fill_action, compute_removed_action_diff, adjust_fill_action,
	text_action_add, text_action_add_literal, offset_with_removed_text,
	offset_with_removed_text_before_fill, find_insn_action,
	print_action_list, print_removed_literals): New.
	(offset_with_removed_literals): Delete.
	(xtensa_relax_info struct): Add is_relaxable_asm_section, action_list,
	fix_array, fix_array_count, allocated_relocs, relocs_count, and
	allocated_relocs_count fields.
	(init_xtensa_relax_info): Initialize new fields.
	(reloc_bfd_fix struct): Add new translated field.
	(reloc_bfd_fix_init): Add translated parameter and use it to set the
	translated field.
	(fix_compare, cache_fix_array): New.
	(get_bfd_fix): Remove fix_list parameter and get all relax_info for the
	section via get_xtensa_relax_info.  Use cache_fix_array to set up
	sorted fix_array and use bsearch instead of linear search.
	(section_cache_t): New struct.
	(init_section_cache, section_cache_section, clear_section_cache): New.
	(ebb_t, ebb_target_enum, proposed_action, ebb_constraint): New types.
	(init_ebb_constraint, free_ebb_constraint, init_ebb, extend_ebb_bounds,
	extend_ebb_bounds_forward, extend_ebb_bounds_backward,
	insn_block_decodable_len, ebb_propose_action, ebb_add_proposed_action):
	New.
	(retrieve_contents): Use bfd_get_section_limit.
	(elf_xtensa_relax_section): Add relocations_analyzed flag.  Update call
	to compute_removed_literals.  Free value_map_hash_table when no longer
	needed.
	(analyze_relocations): Check is_relaxable_asm_section flag.  Call
	compute_text_actions for all sections.
	(find_relaxable_sections): Mark sections as relaxable if they contain
	ASM_EXPAND relocations that can be optimized.  Adjust r_reloc_init
	call.  Increment relax_info src_count field only for appropriate
	relocation types.  Remove is_literal_section check.
	(collect_source_relocs): Use bfd_get_section_limit.  Adjust calls to
	r_reloc_init and find_associated_l32r_irel.  Check
	is_relaxable_asm_section flag.  Handle L32R instructions with absolute
	literals.  Pass is_abs_literal flag to init_source_reloc.
	(is_resolvable_asm_expansion): Use bfd_get_section_limit.  Check for
	CONST16 instructions.  Adjust calls to r_reloc_init and
	pcrel_reloc_fits.  Handle weak symbols conservatively.
	(find_associated_l32r_irel): Add bfd parameter and pass it to
	is_l32r_relocation.
	(compute_text_actions, compute_ebb_proposed_actions,
	compute_ebb_actions, check_section_ebb_pcrels_fit,
	check_section_ebb_reduces, text_action_add_proposed,
	compute_fill_extra_space): New.
	(remove_literals): Replace with ...
	(compute_removed_literals): ... this function.  Call
	init_section_cache.  Use bfd_get_section_limit.  Sort internal_relocs.
	Call xtensa_read_table_entries to get the property table.  Skip
	relocations other than R_XTENSA_32 and R_XTENSA_PLT.  Use new
	is_removable_literal, remove_dead_literal, and
	identify_literal_placement functions.
	(get_irel_at_offset): Rewrite to use bsearch on sorted relocations
	instead of linear search.
	(is_removable_literal, remove_dead_literal,
	identify_literal_placement): New.
	(relocations_reach): Update check for literal not referenced by any
	PC-relative relocations.  Adjust call to pcrel_reloc_fits.
	(coalesce_shared_literal, move_shared_literal): New.
	(relax_section): Use bfd_get_section_limit.  Call
	translate_section_fixes.  Update calls to r_reloc_init and
	offset_with_removed_text.  Check new is_relaxable_asm_section flag.
	Add call to pin_internal_relocs.  Add special handling for
	R_XTENSA_ASM_SIMPLIFY and R_XTENSA_DIFF* relocs.  Use virtual_offset
	info to calculate new addend_displacement variable.  Replace code for
	deleting literals with more general code to perform the actions
	determined by the action_list for the section.
	(translate_section_fixes, translate_reloc_bfd_fix): New.
	(translate_reloc): Check new is_relaxable_asm_section flag.  Call
	find_removed_literal only if is_operand_relocation.  Update call to
	offset_with_removed_text.  Use new target_offset and removed_bytes
	variables.
	(move_literal): New.
	(relax_property_section):  Use bfd_get_section_limit.  Set new
	is_full_prop_section flag and handle new property tables.  Update calls
	to r_reloc_init and offset_with_removed_text.  Check
	is_relaxable_asm_section flag.  Handle expansion of zero-sized
	unreachable entries, with use of offset_with_removed_text_before_fill.
	For relocatable links, combine entries only for literal tables.
	(relax_section_symbols): Check is_relaxable_asm_section flag.  Update
	calls to offset_with_removed_text.  Translate st_size field for
	function symbols.
	(do_fix_for_relocatable_link): Change to return bfd_boolean to indicate
	failure.  Add contents parameter.  Update call to get_bfd_fix.  Update
	call to r_reloc_init.  Call _bfd_error_handler and return FALSE for
	R_XTENSA_ASM_EXPAND relocs.
	(do_fix_for_final_link): Add input_bfd and contents parameters.  Update
	call to get_bfd_fix.  Include offset from contents for partial_inplace
	relocations.
	(is_reloc_sym_weak): New.
	(pcrel_reloc_fits): Use new xtensa-isa.h functions.
	(prop_sec_len): New.
	(xtensa_is_property_section): Handle new property sections.
	(is_literal_section): Delete.
	(internal_reloc_compare): When r_offset matches, compare r_info and
	r_addend to make sorting predictable.
	(internal_reloc_matches): New.
	(xtensa_get_property_section_name): Handle new property sections.
	(xtensa_get_property_predef_flags): New.
	(xtensa_callback_required_dependence): Use bfd_get_section_limit.
	Update calls to xtensa_isa_init, is_l32r_relocation, and r_reloc_init.
	* xtensa-isa.c (xtensa_default_isa): Moved to elf32-xtensa.c.
	(xtisa_errno, xtisa_error_msg): New variables.
	(xtensa_isa_errno, xtensa_isa_error_msg): New.
	(xtensa_insnbuf_alloc): Add error handling.
	(xtensa_insnbuf_to_chars): Add num_chars parameter.  Update to
	use xtensa_format_decode.  Add error handling.
	(xtensa_insnbuf_from_chars): Add num_chars parameter.  Decode the
	instruction length to find the number of bytes to copy.
	(xtensa_isa_init): Add error handling.  Replace calls to
	xtensa_load_isa and xtensa_extend_isa with code to initialize lookup
	tables in the xtensa_modules structure.
	(xtensa_check_isa_config, xtensa_add_isa, xtensa_load_isa,
	xtensa_extend_isa): Delete.
	(xtensa_isa_free): Change to only free lookup tables.
	(opname_lookup_compare): Replace with ...
	(xtensa_isa_name_compare): ... this function.  Use strcasecmp.
	(xtensa_insn_maxlength): Rename to ...
	(xtensa_isa_maxlength): ... this.
	(xtensa_insn_length): Delete.
	(xtensa_insn_length_from_first_byte): Replace with ...
	(xtensa_isa_length_from_chars): ... this function.
	(xtensa_num_opcodes): Rename to ...
	(xtensa_isa_num_opcodes): ... this.
	(xtensa_isa_num_pipe_stages, xtensa_isa_num_formats,
	xtensa_isa_num_regfiles, xtensa_isa_num_stages,
	xtensa_isa_num_sysregs, xtensa_isa_num_interfaces,
	xtensa_isa_num_funcUnits, xtensa_format_name, xtensa_format_lookup,
	xtensa_format_decode, xtensa_format_encode, xtensa_format_length,
	xtensa_format_num_slots, xtensa_format_slot_nop_opcode,
	xtensa_format_get_slot, xtensa_format_set_slot): New functions.
	(xtensa_opcode_lookup): Add error handling.
	(xtensa_decode_insn): Replace with ...
	(xtensa_opcode_decode): ... this function, with new format and
	slot parameters.  Add error handling.
	(xtensa_encode_insn): Replace with ...
	(xtensa_opcode_encode): ... this function, which does the encoding via
	one of the entries in the "encode_fns" array.  Add error handling.
	(xtensa_opcode_name): Add error handling.
	(xtensa_opcode_is_branch, xtensa_opcode_is_jump, xtensa_opcode_is_loop,
	xtensa_opcode_is_call): New.
	(xtensa_num_operands): Replace with ...
	(xtensa_opcode_num_operands): ... this function.  Add error handling.
	(xtensa_opcode_num_stateOperands,
	xtensa_opcode_num_interfaceOperands, xtensa_opcode_num_funcUnit_uses,
	xtensa_opcode_funcUnit_use, xtensa_operand_name,
	xtensa_operand_is_visible): New.
	(xtensa_get_operand, xtensa_operand_kind): Delete.
	(xtensa_operand_inout): Add error handling and special-case for
	"sout" operands.
	(xtensa_operand_get_field, xtensa_operand_set_field): Rewritten to
	operate on one slot of an instruction.  Added error handling.
	(xtensa_operand_encode): Handle default operands with no encoding
	functions.  Check for success by comparing against decoded value.
	Add error handling.
	(xtensa_operand_decode): Handle default operands.  Return decoded value
	through argument pointer.  Add error handling.
	(xtensa_operand_is_register, xtensa_operand_regfile,
	xtensa_operand_num_regs, xtensa_operand_is_known_reg): New.
	(xtensa_operand_isPCRelative): Rename to ...
	(xtensa_operand_is_PCrelative): ... this.  Add error handling.
	(xtensa_operand_do_reloc, xtensa_operand_undo_reloc): Return value
	through argument pointer.  Add error handling.
	(xtensa_stateOperand_state, xtensa_stateOperand_inout,
	xtensa_interfaceOperand_interface, xtensa_regfile_lookup,
	xtensa_regfile_lookup_shortname, xtensa_regfile_name,
	xtensa_regfile_shortname, xtensa_regfile_view_parent,
	xtensa_regfile_num_bits, xtensa_regfile_num_entries,
	xtensa_state_lookup, xtensa_state_name, xtensa_state_num_bits,
	xtensa_state_is_exported, xtensa_sysreg_lookup,
	xtensa_sysreg_lookup_name, xtensa_sysreg_name, xtensa_sysreg_number,
	xtensa_sysreg_is_user, xtensa_interface_lookup, xtensa_interface_name,
	xtensa_interface_num_bits, xtensa_interface_inout,
	xtensa_interface_has_side_effect, xtensa_funcUnit_lookup,
	xtensa_funcUnit_name, xtensa_funcUnit_num_copies): New.
	* xtensa-modules.c: Rewrite to use new data structures.
	* reloc.c (BFD_RELOC_XTENSA_DIFF8, BFD_RELOC_XTENSA_DIFF16,
	BFD_RELOC_XTENSA_DIFF32, BFD_RELOC_XTENSA_SLOT0_OP,
	BFD_RELOC_XTENSA_SLOT1_OP, BFD_RELOC_XTENSA_SLOT2_OP,
	BFD_RELOC_XTENSA_SLOT3_OP, BFD_RELOC_XTENSA_SLOT4_OP,
	BFD_RELOC_XTENSA_SLOT5_OP, BFD_RELOC_XTENSA_SLOT6_OP,
	BFD_RELOC_XTENSA_SLOT7_OP, BFD_RELOC_XTENSA_SLOT8_OP,
	BFD_RELOC_XTENSA_SLOT9_OP, BFD_RELOC_XTENSA_SLOT10_OP,
	BFD_RELOC_XTENSA_SLOT11_OP, BFD_RELOC_XTENSA_SLOT12_OP,
	BFD_RELOC_XTENSA_SLOT13_OP, BFD_RELOC_XTENSA_SLOT14_OP,
	BFD_RELOC_XTENSA_SLOT0_ALT, BFD_RELOC_XTENSA_SLOT1_ALT,
	BFD_RELOC_XTENSA_SLOT2_ALT, BFD_RELOC_XTENSA_SLOT3_ALT,
	BFD_RELOC_XTENSA_SLOT4_ALT, BFD_RELOC_XTENSA_SLOT5_ALT,
	BFD_RELOC_XTENSA_SLOT6_ALT, BFD_RELOC_XTENSA_SLOT7_ALT,
	BFD_RELOC_XTENSA_SLOT8_ALT, BFD_RELOC_XTENSA_SLOT9_ALT,
	BFD_RELOC_XTENSA_SLOT10_ALT, BFD_RELOC_XTENSA_SLOT11_ALT,
	BFD_RELOC_XTENSA_SLOT12_ALT, BFD_RELOC_XTENSA_SLOT13_ALT,
	BFD_RELOC_XTENSA_SLOT14_ALT): Add new relocations.
	* Makefile.am (xtensa-isa.lo, xtensa-modules.lo): Update dependencies.
	* Makefile.in: Regenerate.
	* bfd-in2.h: Likewise.
	* libbfd.h: Likewise.

gas ChangeLog

	* config/tc-xtensa.c (absolute_literals_supported): New global flag.
	(UNREACHABLE_MAX_WIDTH): Define.
	(XTENSA_FETCH_WIDTH): Delete.
	(cur_vinsn, xtensa_fetch_width, xt_saved_debug_type, past_xtensa_end,
	prefer_const16, prefer_l32r): New global variables.
	(LIT4_SECTION_NAME): Define.
	(lit4_state struct): Add lit4_seg_name and lit4_seg fields.
	(XTENSA_PROP_*, GET_XTENSA_PROP_*, SET_XTENSA_PROP_*): Define.
	(frag_flags struct): New.
	(xtensa_block_info struct): Move from tc-xtensa.h.  Add flags field.
	(subseg_map struct): Add cur_total_freq and cur_target_freq fields.
	(bitfield, bit_is_set, set_bit, clear_bit): Define.
	(MAX_FORMATS): Define.
	(op_placement_info struct, op_placement_table): New.
	(O_pltrel, O_hi16, O_lo16): Define.
	(directiveE enum): Rename directive_generics to directive_transform.
	Delete directive_relax.  Add directive_schedule,
	directive_absolute_literals, and directive_last_directive.
	(directive_info): Rename "generics" to "transform".  Delete "relax".
	Add "schedule" and "absolute-literals".
	(directive_state): Adjust entries to match changes in directive_info.
	(xtensa_relax_statesE, RELAX_IMMED_MAXSTEPS): Move to tc-xtensa.h.
	(xtensa_const16_opcode, xtensa_movi_opcode, xtensa_movi_n_opcode,
	xtensa_l32r_opcode, xtensa_nop_opcode, xtensa_rsr_lcount_opcode): New.
	(xtensa_j_opcode, xtensa_rsr_opcode): Delete.
	(align_only_targets, software_a0_b_retw_interlock,
	software_avoid_b_j_loop_end, maybe_has_b_j_loop_end,
	software_avoid_short_loop, software_avoid_close_loop_end,
	software_avoid_all_short_loops, specific_opcode): Delete.
	(warn_unaligned_branch_targets): New.
	(workaround_a0_b_retw, workaround_b_j_loop_end, workaround_short_loop,
	workaround_close_loop_end, workaround_all_short_loops): Default FALSE.
	(option_[no_]link_relax, option_[no_]transform,
	option_[no_]absolute_literals, option_warn_unaligned_targets,
	option_prefer_l32r, option_prefer_const16, option_target_hardware):
	New enum values.
	(option_[no_]align_only_targets, option_literal_section_name,
	option_text_section_name, option_data_section_name,
	option_bss_section_name, option_eb, option_el): Delete.
	(md_longopts): Add entries for: [no-]transform, [no-]absolute-literals,
	warn-unaligned-targets, prefer-l32r, prefer-const16, [no-]link-relax,
	and target-hardware.  Delete entries for [no-]target-align-only,
	literal-section-name, text-section-name, data-section-name, and
	bss-section-name.
	(md_parse_option): Handle new options and remove old ones.  Accept but
	ignore [no-]density options.  Warn for [no-]generics and [no-]relax
	and treat them as [no-]transform.
	(md_show_usage): Add new options and remove old ones.
	(xtensa_setup_hw_workarounds): New.
	(md_pseudo_table): Change "word" entry to use xtensa_elf_cons.  Add
	"long", "short", "loc" and "frequency" entries.
	(use_generics): Rename to ...
	(use_transform): ... this function.  Add past_xtensa_end check.
	(use_longcalls): Add past_xtensa_end check.
	(code_density_available, can_relax): Delete.
	(do_align_targets): New.
	(get_directive): Accept dashes in directive names.  Warn about
	[no-]generics and [no-]relax directives and treat them as
	[no-]transform.
	(xtensa_begin_directive): Call md_flush_pending_output only for some
	directives.  Check for directives inside instruction bundles.  Warn
	about deprecated ".begin literal" usage.  Warn and ignore [no-]density
	directives.  Handle new directives.  Check generating_literals flag
	for literal_prefix.
	(xtensa_end_directive): Check for directives inside instruction
	bundles.  Warn and ignore [no-]density directives.  Handle new
	directives.  Call xtensa_set_frag_assembly_state.
	(xtensa_loc_directive_seen, xtensa_dwarf2_directive_loc,
	xtensa_dwarf2_emit_insn): New.
	(xtensa_literal_position): Call md_flush_pending_output.  Do not check
	use_literal_section flag.
	(xtensa_literal_pseudo): Call md_flush_pending_output.  Handle absolute
	literals.  Use xtensa_elf_cons to parse the expression.
	(xtensa_literal_prefix): Do not check use_literal_section.  Support
	".lit4" sections for absolute literals.  Change prefix convention to
	replace ".text" (or ".t" in a linkonce section).  No need to call
	subseg_set.
	(xtensa_frequency_pseudo, xtensa_elf_cons, xtensa_elf_suffix): New.
	(expression_end): Handle closing braces and colons.
	(PLT_SUFFIX, plt_suffix): Delete.
	(expression_maybe_register): Use new xtensa-isa.h functions.  Use
	xtensa_elf_suffix instead of checking for plt suffix, and handle O_lo16
	and O_hi16 expressions as well.
	(tokenize_arguments): Handle closing braces and colons.
	(parse_arguments): Use new xtensa-isa.h functions.  Handle "invisible"
	operands and paired register syntax.
	(get_invisible_operands): New.
	(xg_translate_sysreg_op): Handle new Xtensa LX RSR/WSR/XSR syntax.  Use
	new xtensa-isa.h functions.
	(xtensa_translate_old_userreg_ops, xtensa_translate_zero_immed): New.
	(xg_translate_idioms): Check if inside bundle.  Use use_transform.
	Handle new Xtensa LX RSR/WSR/XSR syntax.  Remove code to widen density
	instructions.  Use xtensa_translate_zero_immed.
	(operand_is_immed, operand_is_pcrel_label): Delete.
	(get_relaxable_immed): Use new xtensa-isa.h functions.
	(get_opcode_from_buf): Add slot parameter.  Use new xtensa-isa.h
	functions.
	(xtensa_print_insn_table, print_vliw_insn): New.
	(is_direct_call_opcode): Use new xtensa-isa.h functions.
	(is_call_opcode, is_loop_opcode, is_conditional_branch_opcode,
	is_branch_or_jump_opcode): Delete.
	(is_movi_opcode, decode_reloc, encode_reloc, encode_alt_reloc): New.
	(opnum_to_reloc, reloc_to_opnum): Delete.
	(xtensa_insnbuf_set_operand, xtensa_insnbuf_get_operand): Use new
	xtensa-isa.h functions.  Operate on one slot of an instruction.
	(xtensa_insnbuf_set_immediate_field, is_negatable_branch,
	xg_get_insn_size): Delete.
	(xg_get_build_instr_size): Use xg_get_single_size.
	(xg_is_narrow_insn, xg_is_single_relaxable_insn): Update calls to
	xg_build_widen_table.  Use xg_get_single_size.
	(xg_get_max_narrow_insn_size): Delete.
	(xg_get_max_insn_widen_size, xg_get_max_insn_widen_literal_size,
	xg_is_relaxable_insn): Update calls to xg_build_widen_table.  Use
	xg_get_single_size.
	(xg_build_to_insn): Record the loc field.  Handle OP_OPERAND_HI16U and
	OP_OPERAND_LOW16U.  Check xg_valid_literal_expression.
	(xg_expand_to_stack, xg_expand_narrow): Update calls to
	xg_build_widen_table.  Use xg_get_single_size.
	(xg_immeds_fit): Use new xtensa-isa.h functions.  Update call to
	xg_check_operand.
	(xg_symbolic_immeds_fit): Likewise.  Also handle O_lo16 and O_hi16, and
	treat weak symbols conservatively.
	(xg_check_operand): Use new xtensa-isa.h functions.
	(is_dnrange): Delete.
	(xg_assembly_relax): Inline previous calls to tinsn_copy.
	(xg_finish_frag): Specify separate relax states for the frag and slot0.
	(is_branch_jmp_to_next, xg_add_branch_and_loop_targets): Use new
	xtensa-isa.h functions.
	(xg_instruction_matches_option_term, xg_instruction_matches_or_options,
	xg_instruction_matches_options): New.
	(xg_instruction_matches_rule): Handle O_register expressions.  Call
	xg_instruction_matches_options.
	(transition_rule_cmp): New.
	(xg_instruction_match): Update call to xg_build_simplify_table.
	(xg_build_token_insn): Record loc fields.
	(xg_simplify_insn): Check is_specific_opcode field and
	density_supported flag.
	(xg_expand_assembly_insn): Skip checking code_density_available.  Use
	new xtensa-isa.h functions.  Call use_transform instead of can_relax.
	(xg_assemble_literal): Add error handling for O_big.  Call
	record_alignment.  Handle O_pltrel.
	(xg_valid_literal_expression): New.
	(xg_assemble_literal_space): Add slot parameter.  Remove call to
	set_expr_symbol_offset.  Add call to record_alignment.  Update call to
	xg_finish_frag.
	(xg_emit_insn): Delete.
	(xg_emit_insn_to_buf): Add format parameter.  Update calls to
	xg_add_opcode_fix and xtensa_insnbuf_to_chars.
	(xg_add_opcode_fix): Change opcode parameter to tinsn and add format
	and slot parameters.  Handle new "alternate" relocations for absolute
	literals and CONST16 instructions.  Check for bad uses of O_lo16 and
	O_hi16.  Use new xtensa-isa.h functions.
	(xg_assemble_tokens): Delete.
	(is_register_writer): Use new xtensa-isa.h functions.
	(is_bad_loopend_opcode): Check for xtensa_rsr_lcount_opcode instead of
	old-style RSR from LCOUNT.
	(next_frag_opcode): Delete.
	(next_frag_opcode_is_loop, next_frag_format_size, frag_format_size,
	update_next_frag_state): New.
	(update_next_frag_nop_state): Delete.
	(next_frag_pre_opcode_bytes): Use next_frag_opcode_is_loop.
	(xtensa_mark_literal_pool_location): Check use_literal_section flag and
	the state of the absolute-literals directive.  Add calls to
	record_alignment and xtensa_set_frag_assembly_state.  Call
	xtensa_switch_to_non_abs_literal_fragment instead of
	xtensa_switch_to_literal_fragment.
	(build_nop): New.
	(assemble_nop): Use build_nop.  Update call to xtensa_insnbuf_to_chars.
	(get_expanded_loop_offset): Change check for undefined opcode to an
	assertion.
	(xtensa_set_frag_assembly_state, relaxable_section,
	xtensa_find_unmarked_state_frags, xtensa_find_unaligned_branch_targets,
	xtensa_find_unaligned_loops, xg_apply_tentative_value): New.
	(md_begin): Update call to xtensa_isa_init.  Initialize linkrelax to 1.
	Set lit4_seg_name.  Call xg_init_vinsn.  Initialize new global opcodes.
	Call init_op_placement_info_table and xtensa_set_frag_assembly_state.
	(xtensa_init_fix_data): New.
	(xtensa_frob_label): Reset label symbol to the current frag.  Check
	do_align_targets and generating_literals flag.  Propagate frequency
	info to new alignment frag.  Call xtensa_set_frag_assembly_state.
	(xtensa_unrecognized_line): New.
	(xtensa_flush_pending_output): Check if inside a bundle.  Add a call
	to xtensa_set_frag_assembly_state.
	(error_reset_cur_vinsn): New.
	(md_assemble): Remove check for literal frag.  Remove call to
	istack_init.  Call use_transform instead of use_generics.  Parse
	explicit instruction format specifiers.  Move code for
	a0_b_retw_interlock workaround to xg_assemble_vliw_tokens.  Call
	error_reset_cur_vinsn on errors.  Add call to get_invisible_operands.
	Add dwarf2_where call.  Remote automatic alignment for ENTRY
	instructions.  Move call to xtensa_clear_insn_labels to the end.
	Rearrange to handle bundles.
	(xtensa_cons_fix_new): Delete.
	(xtensa_handle_align): New.
	(xtensa_frag_init): Call xtensa_set_frag_assembly_state.  Remove
	assignment to is_no_density field.
	(md_pcrel_from): Use new xtensa-isa.h functions.  Use decode_reloc
	instead of reloc_to_opnum.  Handle "alternate" relocations.
	(xtensa_force_relocation, xtensa_check_inside_bundle,
	xtensa_elf_section_change_hook): New.
	(xtensa_symbol_new_hook): Delete.
	(xtensa_fix_adjustable): Check for difference of symbols with an
	offset.  Check for external and weak symbols.
	(md_apply_fix3): Remove cases for XTENSA_OP{0,1,2} relocs.
	(md_estimate_size_before_relax): Return expansion for the first slot.
	(tc_gen_reloc): Handle difference of symbols by producing
	XTENSA_DIFF{8,16,32} relocs and by writing the value of the difference
	into the output.  Handle new XTENSA_SLOT*_OP relocs by storing the
	tentative values into the output when linkrelax is set.
	(XTENSA_PROP_SEC_NAME): Define.
	(xtensa_post_relax_hook): Call xtensa_find_unmarked_state_frags.
	Create literal tables only if using literal sections.  Create new
	property tables instead of old instruction tables.  Check for unaligned
	branch targets and loops.
	(finish_vinsn, find_vinsn_conflicts, check_t1_t2_reads_and_writes,
	new_resource_table, clear_resource_table, resize_resource_table,
	resources_available, reserve_resources, release_resources,
	opcode_funcUnit_use_unit, opcode_funcUnit_use_stage,
	resources_conflict, xg_find_narrowest_format, relaxation_requirements,
	bundle_single_op, emit_single_op, xg_assemble_vliw_tokens): New.
	(xtensa_end): Call xtensa_flush_pending_output.  Set past_xtensa_end
	flag.  Update checks for workaround options.  Call
	xtensa_mark_narrow_branches and xtensa_mark_zcl_first_insns.
	(xtensa_cleanup_align_frags): Add special case for branch targets.
	Check for and mark unreachable frags.
	(xtensa_fix_target_frags): Remove use of align_only_targets flag.
	Use RELAX_LOOP_END_BYTES in special case for negatable branch at the
	end of a zero-overhead loop body.
	(frag_can_negate_branch): Handle instructions with multiple slots.
	Use new xtensa-isa.h functions
	(xtensa_mark_narrow_branches, is_narrow_branch_guaranteed_in_range,
	xtensa_mark_zcl_first_insns): New.
	(xtensa_fix_a0_b_retw_frags, xtensa_fix_b_j_loop_end_frags): Error if
	transformations are disabled.
	(next_instrs_are_b_retw): Use new xtensa-isa.h functions.  Handle
	multislot instructions.
	(xtensa_fix_close_loop_end_frags, xtensa_fix_short_loop_frags):
	Likewise.  Also error if transformations are disabled.
	(unrelaxed_frag_max_size): New.
	(unrelaxed_frag_min_insn_count, unrelax_frag_has_b_j): Use new
	xtensa-isa.h functions.
	(xtensa_sanity_check, is_empty_loop, is_local_forward_loop): Use
	xtensa_opcode_is_loop instead of is_loop_opcode.
	(get_text_align_power): Replace as_fatal with assertion.
	(get_text_align_fill_size): Iterate instead of using modulus when
	use_nops is false.
	(get_noop_aligned_address): Assert that this is for a machine-dependent
	RELAX_ALIGN_NEXT_OPCODE frag.  Use next_frag_opcode_is_loop,
	xg_get_single_size, and frag_format_size.
	(get_widen_aligned_address): Rename to ...
	(get_aligned_diff): ... this function.  Add max_diff parameter.
	Remove handling of rs_align/rs_align_code frags.  Use
	next_frag_format_size, get_text_align_power, get_text_align_fill_size,
	next_frag_opcode_is_loop, and xg_get_single_size.  Compute max_diff
	and pass it back to caller.
	(xtensa_relax_frag): Use relax_frag_loop_align.  Add code for new
	RELAX_SLOTS, RELAX_MAYBE_UNREACHABLE, RELAX_MAYBE_DESIRE_ALIGN,
	RELAX_FILL_NOP, and RELAX_UNREACHABLE frag types.  Check relax_seen.
	(relax_frag_text_align): Rename to ...
	(relax_frag_loop_align): ... this function.  Assume loops can only be
	in the first slot of an instruction.
	(relax_frag_add_nop): Use assemble_nop instead of constructing an OR
	instruction.  Remove call to frag_wane.
	(relax_frag_narrow): Rename to ...
	(relax_frag_for_align): ... this function.  Extend to handle
	RELAX_FILL_NOP and RELAX_UNREACHABLE, as well as RELAX_SLOTS with
	RELAX_NARROW for the first slot.
	(find_address_of_next_align_frag, bytes_to_stretch): New.
	(future_alignment_required): Use find_address_of_next_align_frag and
	bytes_to_stretch.  Look ahead to subsequent frags to make smarter
	alignment decisions.
	(relax_frag_immed): Add format, slot, and estimate_only parameters.
	Check if transformations are enabled for b_j_loop_end workaround.
	Use new xtensa-isa.h functions and handle multislot instructions.
	Update call to xg_assembly_relax.
	(md_convert_frag): Handle new RELAX_SLOTS, RELAX_UNREACHABLE,
	RELAX_MAYBE_UNREACHABLE, RELAX_MAYBE_DESIRE_ALIGN, and RELAX_FILL_NOP
	frag types.
	(convert_frag_narrow): Add segP, format and slot parameters.  Call
	convert_frag_immed for branch instructions.  Adjust calls to
	tinsn_from_chars, tinsn_immed_from_frag, and xg_emit_insn_to_buf.  Use
	xg_get_single_size and xg_get_single_format.
	(convert_frag_fill_nop): New.
	(convert_frag_immed): Add format and slot parameters.  Handle multislot
	instructions and use new xtensa-isa.h functions.  Update calls to
	tinsn_immed_from_frag and xg_assembly_relax.  Check if transformations
	enabled for b_j_loop_end workaround.  Use build_nop instead of
	assemble_nop.  Check is_specific_opcode flag.  Check for unreachable
	frags.  Use xg_get_single_size.  Handle O_pltrel.
	(fix_new_exp_in_seg): Remove check for old plt flag.
	(convert_frag_immed_finish_loop): Update calls to tinsn_from_chars and
	xtensa_insnbuf_to_chars.  Call tinsn_immed_from_frag.  Change check
	for loop opcode to an assertion.  Mark all frags up to the end of the
	loop as not transformable.
	(get_last_insn_flags, set_last_insn_flags): Use get_subseg_info.
	(get_subseg_info): New.
	(xtensa_move_literals): Call xtensa_set_frag_assembly_state.  Add null
	check for dest_seg.
	(xtensa_switch_to_literal_fragment): Rewrite to handle absolute
	literals and use xtensa_switch_to_non_abs_literal_fragment otherwise.
	(xtensa_switch_to_non_abs_literal_fragment): New.
	(cache_literal_section): Add is_code parameter and pass it through to
	retrieve_literal_seg.
	(retrieve_literal_seg): Add is_code parameter and use it to set the
	flags on the literal section.  Handle case where head parameter is 0.
	(get_frag_is_no_transform, set_frag_is_specific_opcode,
	set_frag_is_no_transform): New.
	(xtensa_create_property_segments): Add end_property_function parameter
	and pass it through to add_xt_block_frags.  Call bfd_get_section_flags
	and skip SEC_DEBUGGING and !SEC_ALLOC sections.
	(xtensa_create_xproperty_segments, section_has_xproperty): New.
	(add_xt_block_frags): Add end_property_function parameter and call it
	if it is non-zero.  Call xtensa_frag_flags_init.
	(xtensa_frag_flags_is_empty, xtensa_frag_flags_init,
	get_frag_property_flags, frag_flags_to_number,
	xtensa_frag_flags_combinable, xt_block_aligned_size,
	xtensa_xt_block_combine, add_xt_prop_frags,
	init_op_placement_info_table, opcode_fits_format_slot,
	xg_get_single_size, xg_get_single_format): New.
	(istack_push): Inline call to tinsn_copy.
	(tinsn_copy): Delete.
	(tinsn_has_invalid_symbolic_operands): Handle O_hi16 and O_lo16 and
	CONST16 opcodes.  Handle O_big, O_illegal, and O_absent.
	(tinsn_has_complex_operands): Handle O_hi16 and O_lo16.
	(tinsn_to_insnbuf): Use xg_get_single_format and new xtensa-isa.h
	functions.  Handle invisible operands.
	(tinsn_to_slotbuf): New.
	(tinsn_check_arguments): Use new xtensa-isa.h functions.
	(tinsn_from_chars): Add slot parameter.  Rewrite using xg_init_vinsn,
	vinsn_from_chars, and xg_free_vinsn.
	(tinsn_from_insnbuf): New.
	(tinsn_immed_from_frag): Add slot parameter and handle multislot
	instructions.  Handle symbol differences.
	(get_num_stack_text_bytes): Use xg_get_single_size.
	(xg_init_vinsn, xg_clear_vinsn, vinsn_has_specific_opcodes,
	xg_free_vinsn, vinsn_to_insnbuf, vinsn_from_chars, expr_is_register,
	get_expr_register, set_expr_symbol_offset_diff): New.
	* config/tc-xtensa.h (MAX_SLOTS): Define.
	(xtensa_relax_statesE): Move from tc-xtensa.c. Add
	RELAX_CHECK_ALIGN_NEXT_OPCODE, RELAX_MAYBE_DESIRE_ALIGN, RELAX_SLOTS,
	RELAX_FILL_NOP, RELAX_UNREACHABLE, RELAX_MAYBE_UNREACHABLE, and
	RELAX_NONE types.
	(RELAX_IMMED_MAXSTEPS): Move from tc-xtensa.c.
	(xtensa_frag_type struct): Add is_assembly_state_set,
	use_absolute_literals, relax_seen, is_unreachable, is_specific_opcode,
	is_align, is_text_align, alignment, and is_first_loop_insn fields.
	Replace is_generics and is_relax fields by is_no_transform field.
	Delete is_text and is_longcalls fields.  Change text_expansion and
	literal_expansion to arrays of MAX_SLOTS entries.  Add arrays of
	per-slot information: literal_frags, slot_subtypes, slot_symbols,
	slot_sub_symbols, and slot_offsets.  Add fr_prev field.
	(xtensa_fix_data struct): New.
	(xtensa_symfield_type struct): Delete plt field.
	(xtensa_block_info struct): Move definition to tc-xtensa.h.  Add
	forward declaration here.
	(xt_section_type enum): Delete xt_insn_sec.  Add xt_prop_sec.
	(XTENSA_SECTION_RENAME): Undefine.
	(TC_FIX_TYPE, TC_INIT_FIX_DATA, TC_FORCE_RELOCATION, NO_PSEUDO_DOT,
	tc_unrecognized_line, md_do_align, md_elf_section_change_hook,
	HANDLE_ALIGN, TC_LINKRELAX_FIXUP, SUB_SEGMENT_ALIGN): Define.
	(TC_CONS_FIX_NEW, tc_symbol_new_hook): Delete.
	(unit_num_copies_func, opcode_num_units_func,
	opcode_funcUnit_use_unit_func, opcode_funcUnit_use_stage_func): New.
	(resource_table struct): New.
	* config/xtensa-istack.h (MAX_INSN_ARGS): Increase from 6 to 10.
	(TInsn struct): Add keep_wide, loc, fixup, record_fix, subtype,
	literal_space, symbol, sub_symbol, offset, and literal_frag fields.
	(tinsn_copy): Delete prototype.
	(vliw_insn struct): New.
	* config/xtensa-relax.c (insn_pattern_struct): Add options field.
	(widen_spec_list): Add option conditions for density and boolean
	instructions.  Add expansions using CONST16 and conditions for using
	CONST16 vs. L32R.  Use new Xtensa LX RSR/WSR syntax.  Add entries for
	predicted branches.
	(simplify_spec_list): Add option conditions for density instructions.
	Add entry for NOP instruction.
	(append_transition): Add cmp function pointer parameter and use it to
	insert the new entry in order.
	(operand_function_LOW16U, operand_function_HI16U): New.
	(xg_has_userdef_op_fn, xg_apply_userdef_op_fn): Handle
	OP_OPERAND_LOW16U and OP_OPERAND_HI16U.
	(enter_opname, split_string): Use xstrdup instead of strdup.
	(init_insn_pattern): Initialize new options field.
	(clear_req_or_option_list, clear_req_option_list,
	clone_req_or_option_list, clone_req_option_list, parse_option_cond):
	New.
	(parse_insn_pattern): Parse option conditions.
	(transition_applies): New.
	(build_transition): Use new xtensa-isa.h functions.  Fix incorrectly
	swapped last arguments in calls to append_constant_value_condition.
	Call clone_req_option_list.  Add warning about invalid opcode.
	Handle LOW16U and HI16U function names.
	(build_transition_table): Add cmp parameter and use it in calls to
	append_transition.  Use new xtensa-isa.h functions.  Check
	transition_applies before adding entries.
	(xg_build_widen_table, xg_build_simplify_table): Add cmp parameter and
	pass it through to build_transition_table.
	* config/xtensa-relax.h (ReqOrOptionList, ReqOrOption, ReqOptionList,
	ReqOption, transition_cmp_fn): New types.
	(OpType enum): Add OP_OPERAND_LOW16U and OP_OPERAND_HI16U.
	(transition_rule struct): Add options field.
	* doc/as.texinfo (Overview): Update Xtensa options.
	* doc/c-xtensa.texi (Xtensa Options): Delete --[no-]density,
	--[no-]relax, and --[no-]generics options.  Update descriptions of
	--text-section-literals and --[no-]longcalls.  Add
	--[no-]absolute-literals and --[no-]transform.
	(Xtensa Syntax): Add description of syntax for FLIX instructions.
	Remove use of "generic" and "specific" terminology for opcodes.
	(Xtensa Registers): Generalize the syntax description to include
	user-defined register files.
	(Xtensa Automatic Alignment): Update.
	(Xtensa Branch Relaxation): Mention limitation of unconditional jumps.
	(Xtensa Call Relaxation): Linker can now remove most of the overhead.
	(Xtensa Directives): Remove confusing rules about precedence.
	(Density Directive, Relax Directive): Delete.
	(Schedule Directive): New.
	(Generics Directive): Rename to ...
	(Transform Directive): ... this node.
	(Literal Directive): Update for absolute literals.  Missing
	literal_position directive is now an error.
	(Literal Position Directive): Update for absolute literals.
	(Freeregs Directive): Delete.
	(Absolute Literals Directive): New.
	(Frame Directive): Minor editing.
	* Makefile.am (DEPTC_xtensa_elf, DEPOBJ_xtensa_elf, DEP_xtensa_elf):
	Update dependencies.
	* Makefile.in: Regenerate.

gas/testsuite ChangeLog

	* gas/xtensa/all.exp: Adjust expected error message for j_too_far.
	Change entry_align test to expect an error.
	* gas/xtensa/entry_misalign2.s: Use no-transform instead of
	no-generics directives.

include ChangeLog

	* xtensa-config.h (XSHAL_USE_ABSOLUTE_LITERALS,
	XCHAL_HAVE_PREDICTED_BRANCHES, XCHAL_INST_FETCH_WIDTH): New.
	(XCHAL_EXTRA_SA_SIZE, XCHAL_EXTRA_SA_ALIGN): Delete.
	* xtensa-isa-internal.h (ISA_INTERFACE_VERSION): Delete.
	(config_sturct struct): Delete.
	(XTENSA_OPERAND_IS_REGISTER, XTENSA_OPERAND_IS_PCRELATIVE,
	XTENSA_OPERAND_IS_INVISIBLE, XTENSA_OPERAND_IS_UNKNOWN,
	XTENSA_OPCODE_IS_BRANCH, XTENSA_OPCODE_IS_JUMP,
	XTENSA_OPCODE_IS_LOOP, XTENSA_OPCODE_IS_CALL,
	XTENSA_STATE_IS_EXPORTED, XTENSA_INTERFACE_HAS_SIDE_EFFECT): Define.
	(xtensa_format_encode_fn, xtensa_get_slot_fn, xtensa_set_slot_fn): New.
	(xtensa_insn_decode_fn): Rename to ...
	(xtensa_opcode_decode_fn): ... this.
	(xtensa_immed_decode_fn, xtensa_immed_encode_fn, xtensa_do_reloc_fn,
	xtensa_undo_reloc_fn): Update.
	(xtensa_encoding_template_fn): Delete.
	(xtensa_opcode_encode_fn, xtensa_format_decode_fn,
	xtensa_length_decode_fn): New.
	(xtensa_format_internal, xtensa_slot_internal): New types.
	(xtensa_operand_internal): Delete operand_kind, inout, isPCRelative,
	get_field, and set_field fields.  Add name, field_id, regfile,
	num_regs, and flags fields.
	(xtensa_arg_internal): New type.
	(xtensa_iclass_internal): Change operands field to array of
	xtensa_arg_internal.  Add num_stateOperands, stateOperands,
	num_interfaceOperands, and interfaceOperands fields.
	(xtensa_opcode_internal): Delete length, template, and iclass fields.
	Add iclass_id, flags, encode_fns, num_funcUnit_uses, and funcUnit_uses.
	(opname_lookup_entry): Delete.
	(xtensa_regfile_internal, xtensa_interface_internal,
	xtensa_funcUnit_internal, xtensa_state_internal,
	xtensa_sysreg_internal, xtensa_lookup_entry): New.
	(xtensa_isa_internal): Replace opcode_table field with opcodes field.
	Change type of opname_lookup_table.  Delete num_modules,
	module_opcode_base, module_decode_fn, config, and has_density fields.
	Add num_formats, formats, format_decode_fn, length_decode_fn,
	num_slots, slots, num_fields, num_operands, operands, num_iclasses,
	iclasses, num_regfiles, regfiles, num_states, states,
	state_lookup_table, num_sysregs, sysregs, sysreg_lookup_table,
	max_sysreg_num, sysreg_table, num_interfaces, interfaces,
	interface_lookup_table, num_funcUnits, funcUnits and
	funcUnit_lookup_table fields.
	(xtensa_isa_module, xtensa_isa_modules): Delete.
	(xtensa_isa_name_compare): New prototype.
	(xtisa_errno, xtisa_error_msg): New.
	* xtensa-isa.h (XTENSA_ISA_VERSION): Define.
	(xtensa_isa): Change type.
	(xtensa_operand): Delete.
	(xtensa_format, xtensa_regfile, xtensa_state, xtensa_sysreg,
	xtensa_interface, xtensa_funcUnit, xtensa_isa_status,
	xtensa_funcUnit_use): New types.
	(libisa_module_specifier): Delete.
	(xtensa_isa_errno, xtensa_isa_error_msg): New prototypes.
	(xtensa_insnbuf_free, xtensa_insnbuf_to_chars,
	xtensa_insnbuf_from_chars): Update prototypes.
	(xtensa_load_isa, xtensa_extend_isa, xtensa_default_isa,
	xtensa_insn_maxlength, xtensa_num_opcodes, xtensa_decode_insn,
	xtensa_encode_insn, xtensa_insn_length,
	xtensa_insn_length_from_first_byte, xtensa_num_operands,
	xtensa_operand_kind, xtensa_encode_result,
	xtensa_operand_isPCRelative): Delete.
	(xtensa_isa_init, xtensa_operand_inout, xtensa_operand_get_field,
	xtensa_operand_set_field, xtensa_operand_encode,
	xtensa_operand_decode, xtensa_operand_do_reloc,
	xtensa_operand_undo_reloc): Update prototypes.
	(xtensa_isa_maxlength, xtensa_isa_length_from_chars,
	xtensa_isa_num_pipe_stages, xtensa_isa_num_formats,
	xtensa_isa_num_opcodes, xtensa_isa_num_regfiles, xtensa_isa_num_states,
	xtensa_isa_num_sysregs, xtensa_isa_num_interfaces,
	xtensa_isa_num_funcUnits, xtensa_format_name, xtensa_format_lookup,
	xtensa_format_decode, xtensa_format_encode, xtensa_format_length,
	xtensa_format_num_slots, xtensa_format_slot_nop_opcode,
	xtensa_format_get_slot, xtensa_format_set_slot, xtensa_opcode_decode,
	xtensa_opcode_encode, xtensa_opcode_is_branch, xtensa_opcode_is_jump,
	xtensa_opcode_is_loop, xtensa_opcode_is_call,
	xtensa_opcode_num_operands, xtensa_opcode_num_stateOperands,
	xtensa_opcode_num_interfaceOperands, xtensa_opcode_num_funcUnit_uses,
	xtensa_opcode_funcUnit_use, xtensa_operand_name,
	xtensa_operand_is_visible, xtensa_operand_is_register,
	xtensa_operand_regfile, xtensa_operand_num_regs,
	xtensa_operand_is_known_reg, xtensa_operand_is_PCrelative,
	xtensa_stateOperand_state, xtensa_stateOperand_inout,
	xtensa_interfaceOperand_interface, xtensa_regfile_lookup,
	xtensa_regfile_lookup_shortname, xtensa_regfile_name,
	xtensa_regfile_shortname, xtensa_regfile_view_parent,
	xtensa_regfile_num_bits, xtensa_regfile_num_entries,
	xtensa_state_lookup, xtensa_state_name, xtensa_state_num_bits,
	xtensa_state_is_exported, xtensa_sysreg_lookup,
	xtensa_sysreg_lookup_name, xtensa_sysreg_name, xtensa_sysreg_number,
	xtensa_sysreg_is_user, xtensa_interface_lookup, xtensa_interface_name,
	xtensa_interface_num_bits, xtensa_interface_inout,
	xtensa_interface_has_side_effect, xtensa_funcUnit_lookup,
	xtensa_funcUnit_name, xtensa_funcUnit_num_copies): New prototypes.
	* elf/xtensa.h (R_XTENSA_DIFF8, R_XTENSA_DIFF16, R_XTENSA_DIFF32,
	R_XTENSA_SLOT*_OP, R_XTENSA_SLOT*_ALT): New relocations.
	(XTENSA_PROP_SEC_NAME): Define.
	(property_table_entry): Add flags field.
	(XTENSA_PROP_*, GET_XTENSA_PROP_*, SET_XTENSA_PROP_*): Define.

ld ChangeLog

	* ld.texinfo (Xtensa): Describe new linker relaxation to optimize
	assembler-generated longcall sequences.  Describe new --size-opt
	option.
	* emulparams/elf32xtensa.sh (OTHER_SECTIONS): Add .xt.prop section.
	* emultempl/xtensaelf.em (remove_section,
	replace_insn_sec_with_prop_sec, replace_instruction_table_sections,
	elf_xtensa_after_open): New.
	(OPTION_OPT_SIZEOPT, OPTION_LITERAL_MOVEMENT,
	OPTION_NO_LITERAL_MOVEMENT): Define.
	(elf32xtensa_size_opt, elf32xtensa_no_literal_movement): New globals.
	(PARSE_AND_LIST_LONGOPTS): Add size-opt and [no-]literal-movement.
	(PARSE_AND_LIST_OPTIONS): Add --size-opt.
	(PARSE_AND_LIST_ARGS_CASES): Handle OPTION_OPT_SIZEOPT,
	OPTION_LITERAL_MOVEMENT, and OPTION_NO_LITERAL_MOVEMENT.
	(LDEMUL_AFTER_OPEN): Set to elf_xtensa_after_open.
	* scripttempl/elfxtensa.sc: Update with changes from elf.sc.
	* Makefile.am (eelf32xtensa.c): Update dependencies.
	* Makefile.in: Regenerate.

ld/testsuite ChangeLog

	* ld-xtensa/lcall1.s: Use .literal directive.
	* ld-xtensa/lcall2.s: Align function entry.
	* ld-xtensa/coalesce2.s: Likewise.

opcodes ChangeLog

	* xtensa-dis.c (state_names): Delete.
	(fetch_data): Use xtensa_isa_maxlength.
	(print_xtensa_operand): Replace operand parameter with opcode/operand
	pair.  Remove print_sr_name parameter.  Use new xtensa-isa.h functions.
	(print_insn_xtensa): Use new xtensa-isa.h functions.  Handle multislot
	instruction bundles.  Use xmalloc instead of malloc.
@
text
@d445 1
a445 35
/* Transition generation helpers.  */

static void append_transition 
  PARAMS ((TransitionTable *, xtensa_opcode, TransitionRule *,
	   transition_cmp_fn));
static void append_condition 
  PARAMS ((TransitionRule *, Precondition *));
static void append_value_condition 
  PARAMS ((TransitionRule *, CmpOp, unsigned, unsigned));
static void append_constant_value_condition 
  PARAMS ((TransitionRule *, CmpOp, unsigned, unsigned));
static void append_build_insn
  PARAMS ((TransitionRule *, BuildInstr *));
static void append_op
  PARAMS ((BuildInstr *, BuildOp *));
static void append_literal_op 
  PARAMS ((BuildInstr *, unsigned, unsigned));
static void append_label_op 
  PARAMS ((BuildInstr *, unsigned, unsigned));
static void append_constant_op 
  PARAMS ((BuildInstr *, unsigned, unsigned));
static void append_field_op 
  PARAMS ((BuildInstr *, unsigned, unsigned));
static void append_user_fn_field_op 
  PARAMS ((BuildInstr *, unsigned, OpType, unsigned));
static long operand_function_HI24S
  PARAMS ((long));
static long operand_function_F32MINUS
  PARAMS ((long));
static long operand_function_LOW8
  PARAMS ((long));
static long operand_function_LOW16U
  PARAMS ((long));
static long operand_function_HI16U
  PARAMS ((long));
d447 2
a448 1
/* Externally visible functions.  */
a449 96
extern bfd_boolean xg_has_userdef_op_fn
  PARAMS ((OpType));
extern long xg_apply_userdef_op_fn
  PARAMS ((OpType, long));

/* Parsing helpers.  */

static const char *enter_opname_n
  PARAMS ((const char *, int));
static const char *enter_opname
  PARAMS ((const char *));

/* Construction and destruction.  */

static void init_opname_map
  PARAMS ((opname_map *));
static void clear_opname_map
  PARAMS ((opname_map *));
static void init_precond_list
  PARAMS ((precond_list *));
static void clear_precond_list
  PARAMS ((precond_list *));
static void init_insn_templ
  PARAMS ((insn_templ *));
static void clear_insn_templ
  PARAMS ((insn_templ *));
static void init_insn_pattern
  PARAMS ((insn_pattern *));
static void clear_insn_pattern
  PARAMS ((insn_pattern *));
static void init_insn_repl
  PARAMS ((insn_repl *));
static void clear_insn_repl
  PARAMS ((insn_repl *));
static void init_split_rec
  PARAMS ((split_rec *));
static void clear_split_rec
  PARAMS ((split_rec *));
static void clear_req_or_option_list
  PARAMS ((ReqOrOption **));
static void clear_req_option_list
  PARAMS ((ReqOption **));
static ReqOrOption *clone_req_or_option_list
  PARAMS ((ReqOrOption *));
static ReqOption *clone_req_option_list
  PARAMS ((ReqOption *));

/* Operand and insn_templ helpers.  */

static bfd_boolean same_operand_name
  PARAMS ((const opname_map_e *, const opname_map_e *));
static opname_map_e *get_opmatch
  PARAMS ((opname_map *, const char *));
static bfd_boolean op_is_constant
  PARAMS ((const opname_map_e *));
static unsigned op_get_constant
  PARAMS ((const opname_map_e *));
static int insn_templ_operand_count
  PARAMS ((const insn_templ *));

/* Parsing helpers.  */

static const char *skip_white
  PARAMS ((const char *));
static void trim_whitespace
  PARAMS ((char *));
static void split_string 
  PARAMS ((split_rec *, const char *, char,  bfd_boolean));

/* Language parsing.  */

static bfd_boolean parse_insn_pattern 
  PARAMS ((const char *, insn_pattern *));
static bfd_boolean parse_insn_repl 
  PARAMS ((const char *, insn_repl *));
static bfd_boolean parse_insn_templ 
  PARAMS ((const char *, insn_templ *));
static bfd_boolean parse_special_fn 
  PARAMS ((const char *, const char **, const char **));
static bfd_boolean parse_precond
  PARAMS ((const char *, precond_e *));
static bfd_boolean parse_constant
  PARAMS ((const char *, unsigned *));
static bfd_boolean parse_id_constant 
  PARAMS ((const char *, const char *, unsigned *));
static bfd_boolean parse_option_cond
  PARAMS ((const char *, ReqOption *));

/* Transition table building code.  */

static bfd_boolean transition_applies 
  PARAMS ((insn_pattern *, const char *, const char *));
static TransitionRule *build_transition 
  PARAMS ((insn_pattern *, insn_repl *, const char *, const char *));
static TransitionTable *build_transition_table 
  PARAMS ((const string_pattern_pair *, int, transition_cmp_fn));
d451 5
a455 7

void
append_transition (tt, opcode, t, cmp)
     TransitionTable *tt;
     xtensa_opcode opcode;
     TransitionRule *t;
     transition_cmp_fn cmp;
d486 2
a487 4
void
append_condition (tr, cond)
     TransitionRule *tr;
     Precondition *cond;
d511 5
a515 6
void
append_value_condition (tr, cmp, op1, op2)
     TransitionRule *tr;
     CmpOp cmp;
     unsigned op1;
     unsigned op2;
d527 5
a531 6
void
append_constant_value_condition (tr, cmp, op1, cnst)
     TransitionRule *tr;
     CmpOp cmp;
     unsigned op1;
     unsigned cnst;
d543 2
a544 4
void
append_build_insn (tr, bi)
     TransitionRule *tr;
     BuildInstr *bi;
d565 2
a566 4
void
append_op (bi, b_op)
     BuildInstr *bi;
     BuildOp *b_op;
d586 2
a587 5
void
append_literal_op (bi, op1, litnum)
     BuildInstr *bi;
     unsigned op1;
     unsigned litnum;
d599 2
a600 5
void
append_label_op (bi, op1, labnum)
     BuildInstr *bi;
     unsigned op1;
     unsigned labnum;
d612 2
a613 5
void
append_constant_op (bi, op1, cnst)
     BuildInstr *bi;
     unsigned op1;
     unsigned cnst;
d625 2
a626 5
void
append_field_op (bi, op1, src_op)
     BuildInstr *bi;
     unsigned op1;
     unsigned src_op;
d640 5
a644 6
void
append_user_fn_field_op (bi, op1, typ, src_op)
     BuildInstr *bi;
     unsigned op1;
     OpType typ;
     unsigned src_op;
d659 2
a660 3
long
operand_function_HI24S (a)
     long a;
d669 2
a670 3
long
operand_function_F32MINUS (a)
     long a;
d676 2
a677 3
long
operand_function_LOW8 (a)
     long a;
d686 2
a687 3
long
operand_function_LOW16U (a)
     long a;
d693 2
a694 3
long
operand_function_HI16U (a)
     long a;
d702 1
a702 2
xg_has_userdef_op_fn (op)
     OpType op;
d720 1
a720 3
xg_apply_userdef_op_fn (op, a)
     OpType op;
     long a;
d743 2
a744 4
const char *
enter_opname_n (name, len)
     const char *name;
     int len;
d763 1
a763 2
enter_opname (name)
     const char *name;
d778 2
a779 3
void
init_opname_map (m)
     opname_map *m;
d786 2
a787 3
void
clear_opname_map (m)
     opname_map *m;
d802 1
a802 3
same_operand_name (m1, m2)
     const opname_map_e *m1;
     const opname_map_e *m2;
d810 2
a811 4
opname_map_e *
get_opmatch (map, operand_name)
     opname_map *map;
     const char *operand_name;
d824 2
a825 3
bfd_boolean
op_is_constant (m1)
     const opname_map_e *m1;
d832 1
a832 2
op_get_constant (m1)
     const opname_map_e *m1;
d839 2
a840 3
void
init_precond_list (l)
     precond_list *l;
d847 2
a848 3
void
clear_precond_list (l)
     precond_list *l;
d862 2
a863 3
void
init_insn_templ (t)
     insn_templ *t;
d870 2
a871 3
void
clear_insn_templ (t)
     insn_templ *t;
d877 2
a878 3
void
init_insn_pattern (p)
     insn_pattern *p;
d886 2
a887 3
void
clear_insn_pattern (p)
     insn_pattern *p;
d894 2
a895 3
void
init_insn_repl (r)
     insn_repl *r;
d902 2
a903 3
void
clear_insn_repl (r)
     insn_repl *r;
d918 1
a918 2
insn_templ_operand_count (t)
     const insn_templ *t;
d931 2
a932 4
bfd_boolean
parse_constant (in, val_p)
     const char *in;
     unsigned *val_p;
d958 2
a959 5
bfd_boolean
parse_id_constant (in, name, val_p)
     const char *in;
     const char *name;
     unsigned *val_p;
d979 3
a981 4
parse_special_fn (name, fn_name_p, arg_name_p)
     const char *name;
     const char **fn_name_p;
     const char **arg_name_p;
d1004 2
a1005 3
const char *
skip_white (p)
     const char *p;
d1015 2
a1016 3
void
trim_whitespace (in)
     char *in;
d1043 5
a1047 6
void
split_string (rec, in, c, elide_whitespace)
     split_rec *rec;
     const char *in;
     char c;
     bfd_boolean elide_whitespace;
d1098 2
a1099 3
void
clear_split_rec (rec)
     split_rec *rec;
d1114 2
a1115 3
void
init_split_rec (rec)
     split_rec *rec;
d1124 2
a1125 4
bfd_boolean
parse_insn_templ (s, t)
     const char *s;
     insn_templ *t;
d1184 2
a1185 4
bfd_boolean
parse_precond (s, precond)
     const char *s;
     precond_e *precond;
d1238 2
a1239 3
void
clear_req_or_option_list (r_p)
     ReqOrOption **r_p;
d1250 2
a1251 3
void
clear_req_option_list (r_p)
     ReqOption **r_p;
d1262 2
a1263 3
ReqOrOption *
clone_req_or_option_list (req_or_option)
     ReqOrOption *req_or_option;
d1279 2
a1280 3
ReqOption *
clone_req_option_list (req_option)
     ReqOption *req_option;
d1297 2
a1298 4
bfd_boolean
parse_option_cond (s, option)
     const char *s;
     ReqOption *option;
d1362 2
a1363 4
bfd_boolean
parse_insn_pattern (in, insn)
     const char *in;
     insn_pattern *insn;
d1444 2
a1445 4
bfd_boolean
parse_insn_repl (in, r_p)
     const char *in;
     insn_repl *r_p;
d1472 4
a1475 5
bfd_boolean
transition_applies (initial_insn, from_string, to_string)
     insn_pattern *initial_insn;
     const char *from_string ATTRIBUTE_UNUSED; 
     const char *to_string ATTRIBUTE_UNUSED; 
d1524 5
a1528 6
TransitionRule *
build_transition (initial_insn, replace_insns, from_string, to_string)
     insn_pattern *initial_insn;
     insn_repl *replace_insns;
     const char *from_string;
     const char *to_string;
d1815 4
a1818 5
TransitionTable *
build_transition_table (transitions, transition_count, cmp)
     const string_pattern_pair *transitions;
     int transition_count;
     transition_cmp_fn cmp;
d1885 1
a1885 2
xg_build_widen_table (cmp)
     transition_cmp_fn cmp;
d1895 1
a1895 2
xg_build_simplify_table (cmp)
     transition_cmp_fn cmp;
@


1.3
log
@Remove redundant returns in void functions.
@
text
@d2 1
a2 1
   Copyright 2003 Free Software Foundation, Inc.
d26 8
a33 3
   same or an operand is a specific constant.  The expansion uses the
   bound variables from the pattern to specify that specific operands
   from the pattern should be used in the result.  
d37 1
a37 1
   INSN_PATTERN ::= INSN_TEMPL ( '|' PRECOND )*
d42 1
d46 2
d58 7
d102 1
a106 1

d133 1
a133 1
  size_t operand_num;
d191 1
d221 1
a221 1
  size_t count;
d250 12
a261 11
  {"add.n %ar,%as,%at", "add %ar,%as,%at"},
  {"addi.n %ar,%as,%imm", "addi %ar,%as,%imm"},
  {"beqz.n %as,%label", "beqz %as,%label"},
  {"bnez.n %as,%label", "bnez %as,%label"},
  {"l32i.n %at,%as,%imm", "l32i %at,%as,%imm"},
  {"mov.n %at,%as", "or %at,%as,%as"},
  {"movi.n %as,%imm", "movi %as,%imm"},
  {"nop.n", "or 1,1,1"},
  {"ret.n", "ret"},
  {"retw.n", "retw"},
  {"s32i.n %at,%as,%imm", "s32i %at,%as,%imm"},
d264 7
a270 2
  /* Widening with literals */
  {"movi %at,%imm", "LITERAL0 %imm; l32r %at,%LITERAL0"},
d275 3
a277 1
  {"addmi %ar,%as,%imm | %ar!=%as",
d279 2
d283 1
a283 1
  {"l8ui %at,%as,%imm | %at!=%as",
d285 1
a285 1
  {"l16si %at,%as,%imm | %at!=%as",
d287 1
a287 1
  {"l16ui %at,%as,%imm | %at!=%as",
d289 13
d303 1
a303 1
  {"l32ai %at,%as,%imm",
d307 1
a307 1
  {"l32is %at,%as,%imm",
a309 2
  {"l32i %at,%as,%imm | %at!=%as",
   "LITERAL0 %imm; l32r %at,%LITERAL0; add %at,%at,%as; l32i %at,%at,0"},
d311 4
a314 4
  /* This is only PART of the loop instruction.  In addition, hard
     coded into it's use is a modification of the final operand in the
     instruction in bytes 9 and 12.  */
  {"loop %as,%label",
d316 2
a317 2
   "rsr     %as, 1;"		/* LEND */
   "wsr     %as, 0;"		/* LBEG */
d320 1
a320 1
   "wsr     %as, 1;"
d322 1
a322 1
   "rsr     %as, 2;"		/* LCOUNT */
d325 3
a327 3
  {"loopgtz %as,%label",
   "beqz     %as,%label;"
   "bltz     %as,%label;"
d329 2
a330 2
   "rsr     %as, 1;"		/* LEND */
   "wsr     %as, 0;"		/* LBEG */
d333 1
a333 1
   "wsr     %as, 1;"
d335 1
a335 1
   "rsr     %as, 2;"		/* LCOUNT */
d338 1
a338 1
  {"loopnez %as,%label",
d341 2
a342 2
   "rsr     %as, 1;"		/* LEND */
   "wsr     %as, 0;"		/* LBEG */
d345 1
a345 1
   "wsr     %as, 1;"
d347 1
a347 1
   "rsr     %as, 2;"		/* LCOUNT */
d351 2
a352 4
#if 0 /* no mechanism here to determine if Density Option is available */
  {"beqz %as,%label", "bnez.n %as,%LABEL0;j %label;LABEL0"},
  {"bnez %as,%label", "beqz.n %as,%LABEL0;j %label;LABEL0"},
#else
d355 2
a356 1
#endif
d370 2
d377 4
a380 4
#if 1 /* provide relaxations for Boolean Option */
  {"bt %bs,%label", "bf %bs,%LABEL0;j %label;LABEL0"},
  {"bf %bs,%label", "bt %bs,%LABEL0;j %label;LABEL0"},
#endif
d386 20
a405 4
  {"call0 %label", "LITERAL0 %label; l32r a0,%LITERAL0; callx0 a0"},
  {"call4 %label", "LITERAL0 %label; l32r a4,%LITERAL0; callx4 a4"},
  {"call8 %label", "LITERAL0 %label; l32r a8,%LITERAL0; callx8 a8"},
  {"call12 %label", "LITERAL0 %label; l32r a12,%LITERAL0; callx12 a12"}
d423 16
a438 14
  {"add %ar,%as,%at", "add.n %ar,%as,%at"},
  {"addi.n %ar,%as,0", "mov.n %ar,%as"},
  {"addi %ar,%as,0", "mov.n %ar,%as"},
  {"addi %ar,%as,%imm", "addi.n %ar,%as,%imm"},
  {"addmi %ar,%as,%imm", "addi.n %ar,%as,%imm"},
  {"beqz %as,%label", "beqz.n %as,%label"},
  {"bnez %as,%label", "bnez.n %as,%label"},
  {"l32i %at,%as,%imm", "l32i.n %at,%as,%imm"},
  {"movi %as,%imm", "movi.n %as,%imm"},
  {"or %ar,%as,%at | %as==%at", "mov.n %ar,%as"},
  {"ret", "ret.n"},
  {"retw", "retw.n"},
  {"s32i %at,%as,%imm", "s32i.n %at,%as,%imm"},
  {"slli %ar,%as,0", "mov.n %ar,%as"}
d448 2
a449 1
  PARAMS ((TransitionTable *, xtensa_opcode, TransitionRule *));
d476 4
d491 1
a491 1
  PARAMS ((const char *, size_t));
d521 8
d540 1
a540 1
static size_t insn_templ_operand_count
d543 1
a543 1
/* parsing helpers.  */
d568 2
d573 2
d578 1
a578 1
  PARAMS ((const string_pattern_pair *, size_t));
d582 1
a582 1
append_transition (tt, opcode, t)
d586 1
d590 1
a590 1
  TransitionList *nxt;
d602 2
a603 2
  nxt = prev->next;
  while (nxt != NULL)
d605 7
a611 2
      prev = nxt;
      nxt = nxt->next;
d613 1
a613 1
  prev->next = tl;
d841 17
d867 2
d890 4
d906 1
a906 1
     size_t len;
d912 2
a913 1
      if (strlen (op->opname) == len && strncmp (op->opname, name, len) == 0)
d936 1
a936 1
  op->opname = strdup (name);
d1058 1
d1096 1
a1096 1
static size_t
d1100 1
a1100 1
  size_t i = 0;
d1103 1
a1103 1
  for (op = t->operand_map.head; op != NULL; op = op->next, ++i)
d1238 2
a1239 2
  size_t cnt = 0;
  size_t i;
d1263 1
a1263 1
      size_t len;
d1271 1
a1271 1
	rec->vec[i] = strdup (q);
d1291 1
a1291 1
  size_t i;
d1293 1
a1293 1
  for (i = 0; i < rec->count; ++i)
d1301 3
d1321 4
a1325 3
  size_t insn_name_len;
  split_rec oprec;
  size_t i;
d1388 1
a1388 1
  size_t len;
d1433 114
d1550 12
a1561 1
   the same and operand 2 and 3 are the same and operand 4 is 1.  */
d1568 3
d1572 1
a1572 2
  split_rec rec;
  size_t i;
d1574 8
a1582 1
  init_insn_pattern (insn);
d1584 1
a1584 1
  split_string (&rec, in, '|', TRUE);
d1589 1
d1596 1
d1607 1
d1617 24
d1642 1
d1654 1
a1654 1
  size_t i;
d1677 53
d1756 2
a1757 2
      as_warn (_("Invalid opcode '%s' in transition rule '%s'\n"),
	       initial_insn->t.opcode_name, to_string);
d1763 2
a1764 2
  if (xtensa_num_operands (isa, opcode)
      != (int) insn_templ_operand_count (&initial_insn->t))
d1857 1
a1857 1
					 op1->operand_num, precond->opval1);
d1860 1
a1860 1
					 op2->operand_num, precond->opval2);
d1863 2
d1877 1
a1877 1
      size_t operand_count;
d1920 5
a1924 1
	    return NULL;
d1926 1
a1926 1
	  if (xtensa_num_operands (isa, bi->opcode) 
d1929 2
a1930 1
		      opcode_name, xtensa_num_operands (isa, bi->opcode));
d1983 4
d1988 1
a1988 1
		as_fatal (_("unknown user defined function %s"), fn_name);
d2023 1
a2023 1
build_transition_table (transitions, transition_count)
d2025 2
a2026 1
     size_t transition_count;
d2029 2
a2030 3
  int num_opcodes = xtensa_num_opcodes (xtensa_default_isa);
  int i;
  size_t tnum;
d2070 14
a2083 4
      tr = build_transition (&initial_insn, &replace_insns,
			     from_string, to_string);
      if (tr)
	append_transition (table, tr->opcode, tr);
d2093 2
a2094 1
xg_build_widen_table ()
d2098 1
a2098 1
    table = build_transition_table (widen_spec_list, WIDEN_COUNT);
d2104 2
a2105 1
xg_build_simplify_table ()
d2109 1
a2109 1
    table = build_transition_table (simplify_spec_list, SIMPLIFY_COUNT);
@


1.2
log
@	* config/atof-tahoe.c: Fix comment typos.
	* config/m68k-parse.y: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-bout.c: Likewise.
	* config/obj-vms.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/te-delt88.h: Likewise.
	* config/te-delta.h: Likewise.
	* config/te-generic.h: Likewise.
	* config/te-macos.h: Likewise.
	* config/te-ppcnw.h: Likewise.
	* config/te-psos.h: Likewise.
	* config/te-sun3.h: Likewise.
	* config/te-tmips.h: Likewise.
	* config/xtensa-relax.c: Likewise.
@
text
@a534 1
  return;
@


1.1
log
@Add Xtensa port
@
text
@d222 1
a222 1
   encodings.  A valid transition may require mutiple steps of
@

