head	1.57;
access;
symbols
	binutils-2_24-branch:1.57.0.4
	binutils-2_24-branchpoint:1.57
	binutils-2_21_1:1.55
	binutils-2_23_2:1.57
	binutils-2_23_1:1.57
	binutils-2_23:1.57
	binutils-2_23-branch:1.57.0.2
	binutils-2_23-branchpoint:1.57
	binutils-2_22_branch:1.56.0.4
	binutils-2_22:1.56
	binutils-2_22-branch:1.56.0.2
	binutils-2_22-branchpoint:1.56
	binutils-2_21:1.55
	binutils-2_21-branch:1.55.0.2
	binutils-2_21-branchpoint:1.55
	binutils-2_20_1:1.54
	binutils-2_20:1.54
	binutils-arc-20081103-branch:1.52.0.6
	binutils-arc-20081103-branchpoint:1.52
	binutils-2_20-branch:1.54.0.2
	binutils-2_20-branchpoint:1.54
	dje-cgen-play1-branch:1.53.0.2
	dje-cgen-play1-branchpoint:1.53
	arc-20081103-branch:1.52.0.4
	arc-20081103-branchpoint:1.52
	binutils-2_19_1:1.52
	binutils-2_19:1.52
	binutils-2_19-branch:1.52.0.2
	binutils-2_19-branchpoint:1.52
	binutils-2_18:1.50
	binutils-2_18-branch:1.50.0.2
	binutils-2_18-branchpoint:1.50
	binutils-csl-coldfire-4_1-32:1.48
	binutils-csl-sourcerygxx-4_1-32:1.48
	binutils-csl-innovasic-fido-3_4_4-33:1.48
	binutils-csl-sourcerygxx-3_4_4-32:1.40.2.1
	binutils-csl-coldfire-4_1-30:1.48
	binutils-csl-sourcerygxx-4_1-30:1.48
	binutils-csl-coldfire-4_1-28:1.48
	binutils-csl-sourcerygxx-4_1-29:1.48
	binutils-csl-sourcerygxx-4_1-28:1.48
	binutils-csl-arm-2006q3-27:1.48
	binutils-csl-sourcerygxx-4_1-27:1.48
	binutils-csl-arm-2006q3-26:1.48
	binutils-csl-sourcerygxx-4_1-26:1.48
	binutils-csl-sourcerygxx-4_1-25:1.48
	binutils-csl-sourcerygxx-4_1-24:1.48
	binutils-csl-sourcerygxx-4_1-23:1.48
	binutils-csl-sourcerygxx-4_1-21:1.48
	binutils-csl-arm-2006q3-21:1.48
	binutils-csl-sourcerygxx-4_1-22:1.48
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.48
	binutils-csl-sourcerygxx-4_1-20:1.48
	binutils-csl-arm-2006q3-19:1.48
	binutils-csl-sourcerygxx-4_1-19:1.48
	binutils-csl-sourcerygxx-4_1-18:1.48
	binutils-csl-renesas-4_1-9:1.48
	binutils-csl-sourcerygxx-3_4_4-25:1.40.2.1
	binutils-csl-renesas-4_1-8:1.48
	binutils-csl-renesas-4_1-7:1.48
	binutils-csl-renesas-4_1-6:1.48
	binutils-csl-sourcerygxx-4_1-17:1.48
	binutils-csl-sourcerygxx-4_1-14:1.48
	binutils-csl-sourcerygxx-4_1-15:1.48
	binutils-csl-sourcerygxx-4_1-13:1.48
	binutils-2_17:1.48
	binutils-csl-sourcerygxx-4_1-12:1.48
	binutils-csl-sourcerygxx-3_4_4-21:1.48
	binutils-csl-wrs-linux-3_4_4-24:1.40
	binutils-csl-wrs-linux-3_4_4-23:1.40
	binutils-csl-sourcerygxx-4_1-9:1.48
	binutils-csl-sourcerygxx-4_1-8:1.48
	binutils-csl-sourcerygxx-4_1-7:1.48
	binutils-csl-arm-2006q1-6:1.48
	binutils-csl-sourcerygxx-4_1-6:1.48
	binutils-csl-wrs-linux-3_4_4-22:1.40
	binutils-csl-coldfire-4_1-11:1.48
	binutils-csl-sourcerygxx-3_4_4-19:1.48
	binutils-csl-coldfire-4_1-10:1.48
	binutils-csl-sourcerygxx-4_1-5:1.48
	binutils-csl-sourcerygxx-4_1-4:1.48
	binutils-csl-wrs-linux-3_4_4-21:1.40
	binutils-csl-morpho-4_1-4:1.48
	binutils-csl-sourcerygxx-3_4_4-17:1.48
	binutils-csl-wrs-linux-3_4_4-20:1.40
	binutils-2_17-branch:1.48.0.4
	binutils-2_17-branchpoint:1.48
	binutils-csl-2_17-branch:1.48.0.2
	binutils-csl-2_17-branchpoint:1.48
	binutils-csl-gxxpro-3_4-branch:1.40.2.1.0.2
	binutils-csl-gxxpro-3_4-branchpoint:1.40.2.1
	binutils-2_16_1:1.40.2.1
	binutils-csl-arm-2005q1b:1.40
	binutils-2_16:1.40
	binutils-csl-arm-2005q1a:1.40
	binutils-csl-arm-2005q1-branch:1.40.0.4
	binutils-csl-arm-2005q1-branchpoint:1.40
	binutils-2_16-branch:1.40.0.2
	binutils-2_16-branchpoint:1.40
	csl-arm-2004-q3d:1.37
	csl-arm-2004-q3:1.37
	binutils-2_15:1.34
	binutils-2_15-branchpoint:1.34
	csl-arm-2004-q1a:1.36
	csl-arm-2004-q1:1.35
	binutils-2_15-branch:1.34.0.6
	cagney_bfdfile-20040213-branch:1.34.0.4
	cagney_bfdfile-20040213-branchpoint:1.34
	cagney_bigcore-20040122-branch:1.34.0.2
	cagney_bigcore-20040122-branchpoint:1.34
	csl-arm-2003-q4:1.34
	binutils-2_14:1.28.2.1
	binutils-2_14-branch:1.28.0.2
	binutils-2_14-branchpoint:1.28
	binutils-2_13_2_1:1.24
	binutils-2_13_2:1.24
	binutils-2_13_1:1.24
	binutils-2_13:1.24
	binutils-2_13-branchpoint:1.24
	binutils-2_13-branch:1.24.0.4
	binutils-2_12_1:1.24
	binutils-2_12:1.24
	binutils-2_12-branch:1.24.0.2
	binutils-2_12-branchpoint:1.24
	cygnus_cvs_20020108_pre:1.24
	binutils-2_11_2:1.15.2.3
	binutils-2_11_1:1.15.2.3
	binutils-2_11:1.15.2.1
	x86_64versiong3:1.16
	binutils-2_11-branch:1.15.0.2
	binutils-2_10_1:1.10
	binutils-2_10:1.10
	binutils-2_10-branch:1.10.0.2
	binutils-2_10-branchpoint:1.10
	binutils_latest_snapshot:1.57
	repo-unification-2000-02-06:1.7
	binu_ss_19990721:1.4
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.57
date	2012.05.05.03.05.27;	author amodra;	state Exp;
branches;
next	1.56;

1.56
date	2011.05.17.16.15.59;	author nickc;	state Exp;
branches;
next	1.55;

1.55
date	2009.12.11.13.42.11;	author nickc;	state Exp;
branches;
next	1.54;

1.54
date	2009.07.24.11.45.00;	author nickc;	state Exp;
branches;
next	1.53;

1.53
date	2009.06.22.17.56.01;	author nickc;	state Exp;
branches;
next	1.52;

1.52
date	2007.12.10.23.33.46;	author amodra;	state Exp;
branches;
next	1.51;

1.51
date	2007.10.17.16.45.55;	author nickc;	state Exp;
branches;
next	1.50;

1.50
date	2007.07.03.11.01.04;	author nickc;	state Exp;
branches;
next	1.49;

1.49
date	2006.06.07.11.27.57;	author amodra;	state Exp;
branches;
next	1.48;

1.48
date	2005.10.11.11.16.16;	author nickc;	state Exp;
branches;
next	1.47;

1.47
date	2005.07.29.13.52.00;	author nickc;	state Exp;
branches;
next	1.46;

1.46
date	2005.07.20.11.35.00;	author nickc;	state Exp;
branches;
next	1.45;

1.45
date	2005.06.08.14.39.54;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	2005.06.07.17.54.17;	author zack;	state Exp;
branches;
next	1.43;

1.43
date	2005.05.05.09.12.58;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	2005.04.20.17.40.01;	author hjl;	state Exp;
branches;
next	1.41;

1.41
date	2005.03.24.20.40.27;	author nickc;	state Exp;
branches;
next	1.40;

1.40
date	2005.03.03.11.47.52;	author amodra;	state Exp;
branches
	1.40.2.1;
next	1.39;

1.39
date	2005.01.31.23.18.30;	author bje;	state Exp;
branches;
next	1.38;

1.38
date	2004.11.29.15.09.27;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	2004.06.25.16.11.09;	author nickc;	state Exp;
branches;
next	1.36;

1.36
date	2004.04.13.16.47.57;	author nickc;	state Exp;
branches;
next	1.35;

1.35
date	2004.02.27.14.13.18;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	2003.12.19.11.43.36;	author nickc;	state Exp;
branches
	1.34.6.1;
next	1.33;

1.33
date	2003.12.17.09.41.06;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2003.12.03.17.38.45;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	2003.11.22.02.35.30;	author kazu;	state Exp;
branches;
next	1.30;

1.30
date	2003.06.10.22.08.45;	author devans;	state Exp;
branches;
next	1.29;

1.29
date	2003.05.29.17.37.03;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2003.01.23.12.51.05;	author amodra;	state Exp;
branches
	1.28.2.1;
next	1.27;

1.27
date	2002.12.12.22.18.10;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2002.11.30.08.39.43;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2002.09.05.00.01.18;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2001.11.15.21.28.56;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2001.09.19.05.33.25;	author hjl;	state Exp;
branches;
next	1.22;

1.22
date	2001.07.23.14.02.12;	author kazu;	state Exp;
branches;
next	1.21;

1.21
date	2001.07.23.13.03.39;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2001.07.06.19.09.23;	author jhealy;	state Exp;
branches;
next	1.19;

1.19
date	2001.05.10.11.32.51;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2001.03.08.23.24.24;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2001.03.02.22.49.57;	author brolley;	state Exp;
branches;
next	1.16;

1.16
date	2001.02.13.21.27.52;	author ian;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.23.13.31.10;	author amodra;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2000.12.28.10.07.55;	author rth;	state Exp;
branches;
next	1.13;

1.13
date	2000.09.20.22.05.08;	author kazu;	state Exp;
branches;
next	1.12;

1.12
date	2000.08.04.01.01.32;	author kazu;	state Exp;
branches;
next	1.11;

1.11
date	2000.06.19.01.22.40;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2000.03.09.22.07.28;	author clm;	state Exp;
branches;
next	1.9;

1.9
date	2000.03.07.00.06.52;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.06.23.37.57;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	99.10.05.00.37.17;	author devans;	state Exp;
branches;
next	1.6;

1.6
date	99.09.06.10.24.19;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	99.08.29.20.45.22;	author devans;	state Exp;
branches;
next	1.4;

1.4
date	99.06.17.04.51.25;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	99.06.12.16.49.49;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.06.03.12.46.26;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.41;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.40.2.1
date	2005.06.08.15.34.15;	author nickc;	state Exp;
branches;
next	;

1.34.6.1
date	2005.06.08.15.34.48;	author nickc;	state Exp;
branches;
next	;

1.28.2.1
date	2003.06.02.18.21.15;	author drow;	state Exp;
branches;
next	;

1.15.2.1
date	2001.03.18.08.41.26;	author ciceron;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2001.05.23.03.41.10;	author amodra;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2001.06.11.10.04.48;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.41;	author rth;	state Exp;
branches;
next	;


desc
@@


1.57
log
@Replace all uses of bfd_abs_section, bfd_com_section, bfd_und_section
and bfd_ind_section with their _ptr variants, or use corresponding
bfd_is_* macros.
@
text
@/* tc-m32r.c -- Assembler for the Renesas M32R.
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
   2006, 2007, 2009, 2011, 2012 Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 51 Franklin Street - Fifth Floor,
   Boston, MA 02110-1301, USA.  */

#include "as.h"
#include "safe-ctype.h"
#include "subsegs.h"
#include "symcat.h"
#include "opcodes/m32r-desc.h"
#include "opcodes/m32r-opc.h"
#include "cgen.h"
#include "elf/m32r.h"

/* Linked list of symbols that are debugging symbols to be defined as the
   beginning of the current instruction.  */
typedef struct sym_link
{
  struct sym_link *next;
  symbolS *symbol;
} sym_linkS;

static sym_linkS *debug_sym_link = (sym_linkS *) 0;

/* Structure to hold all of the different components describing
   an individual instruction.  */
typedef struct
{
  const CGEN_INSN *insn;
  const CGEN_INSN *orig_insn;
  CGEN_FIELDS fields;
#if CGEN_INT_INSN_P
  CGEN_INSN_INT buffer[1];
#define INSN_VALUE(buf) (*(buf))
#else
  unsigned char buffer[CGEN_MAX_INSN_SIZE];
#define INSN_VALUE(buf) (buf)
#endif
  char *addr;
  fragS *frag;
  int num_fixups;
  fixS *fixups[GAS_CGEN_MAX_FIXUPS];
  int indices[MAX_OPERAND_INSTANCES];
  sym_linkS *debug_sym_link;
}
m32r_insn;

/* prev_insn.insn is non-null if last insn was a 16 bit insn on a 32 bit
   boundary (i.e. was the first of two 16 bit insns).  */
static m32r_insn prev_insn;

/* Non-zero if we've seen a relaxable insn since the last 32 bit
   alignment request.  */
static int seen_relaxable_p = 0;

/* Non-zero if we are generating PIC code.  */
int pic_code;

/* Non-zero if -relax specified, in which case sufficient relocs are output
   for the linker to do relaxing.
   We do simple forms of relaxing internally, but they are always done.
   This flag does not apply to them.  */
static int m32r_relax;

/* Non-zero if warn when a high/shigh reloc has no matching low reloc.
   Each high/shigh reloc must be paired with it's low cousin in order to
   properly calculate the addend in a relocatable link (since there is a
   potential carry from the low to the high/shigh).
   This option is off by default though for user-written assembler code it
   might make sense to make the default be on (i.e. have gcc pass a flag
   to turn it off).  This warning must not be on for GCC created code as
   optimization may delete the low but not the high/shigh (at least we
   shouldn't assume or require it to).  */
static int warn_unmatched_high = 0;

/* 1 if -m32rx has been specified, in which case support for
     the extended M32RX instruction set should be enabled.
   2 if -m32r2 has been specified, in which case support for
     the extended M32R2 instruction set should be enabled.  */
static int enable_m32rx = 0; /* Default to M32R.  */

/* Non-zero if -m32rx -hidden has been specified, in which case support for
   the special M32RX instruction set should be enabled.  */
static int enable_special = 0;

/* Non-zero if -bitinst has been specified, in which case support
   for extended M32R bit-field instruction set should be enabled.  */
static int enable_special_m32r = 1;

/* Non-zero if -float has been specified, in which case support for
   extended M32R floating point instruction set should be enabled.  */
static int enable_special_float = 0;

/* Non-zero if the programmer should be warned when an explicit parallel
   instruction might have constraint violations.  */
static int warn_explicit_parallel_conflicts = 1;

/* Non-zero if the programmer should not receive any messages about
   parallel instruction with potential or real constraint violations.
   The ability to suppress these messages is intended only for hardware
   vendors testing the chip.  It superceedes
   warn_explicit_parallel_conflicts.  */
static int ignore_parallel_conflicts = 0;

/* Non-zero if insns can be made parallel.  */
static int use_parallel = 0;

/* Non-zero if optimizations should be performed.  */
static int optimize;

/* m32r er_flags.  */
static int m32r_flags = 0;

/* Stuff for .scomm symbols.  */
static segT     sbss_section;
static asection scom_section;
static asymbol  scom_symbol;

const char comment_chars[]        = ";";
const char line_comment_chars[]   = "#";
const char line_separator_chars[] = "!";
const char EXP_CHARS[]            = "eE";
const char FLT_CHARS[]            = "dD";

/* Relocations against symbols are done in two
   parts, with a HI relocation and a LO relocation.  Each relocation
   has only 16 bits of space to store an addend.  This means that in
   order for the linker to handle carries correctly, it must be able
   to locate both the HI and the LO relocation.  This means that the
   relocations must appear in order in the relocation table.

   In order to implement this, we keep track of each unmatched HI
   relocation.  We then sort them so that they immediately precede the
   corresponding LO relocation.  */

struct m32r_hi_fixup
{
  /* Next HI fixup.  */
  struct m32r_hi_fixup *next;

  /* This fixup.  */
  fixS *fixp;

  /* The section this fixup is in.  */
  segT seg;
};

/* The list of unmatched HI relocs.  */

static struct m32r_hi_fixup *m32r_hi_fixup_list;

struct
{
  enum bfd_architecture bfd_mach;
  int mach_flags;
} mach_table[] =
{
  { bfd_mach_m32r,  (1<<MACH_M32R) },
  { bfd_mach_m32rx, (1<<MACH_M32RX) },
  { bfd_mach_m32r2, (1<<MACH_M32R2) }
};

static void
allow_m32rx (int on)
{
  enable_m32rx = on;

  if (stdoutput != NULL)
    bfd_set_arch_mach (stdoutput, TARGET_ARCH, mach_table[on].bfd_mach);

  if (gas_cgen_cpu_desc != NULL)
    gas_cgen_cpu_desc->machs = mach_table[on].mach_flags;
}

#define M32R_SHORTOPTS "O::K:"

const char *md_shortopts = M32R_SHORTOPTS;

enum md_option_enums
{
  OPTION_M32R = OPTION_MD_BASE,
  OPTION_M32RX,
  OPTION_M32R2,
  OPTION_BIG,
  OPTION_LITTLE,
  OPTION_PARALLEL,
  OPTION_NO_PARALLEL,
  OPTION_WARN_PARALLEL,
  OPTION_NO_WARN_PARALLEL,
  OPTION_IGNORE_PARALLEL,
  OPTION_NO_IGNORE_PARALLEL,
  OPTION_SPECIAL,
  OPTION_SPECIAL_M32R,
  OPTION_NO_SPECIAL_M32R,
  OPTION_SPECIAL_FLOAT,
  OPTION_WARN_UNMATCHED,
  OPTION_NO_WARN_UNMATCHED
};

struct option md_longopts[] =
{
  {"m32r",  no_argument, NULL, OPTION_M32R},
  {"m32rx", no_argument, NULL, OPTION_M32RX},
  {"m32r2", no_argument, NULL, OPTION_M32R2},
  {"big", no_argument, NULL, OPTION_BIG},
  {"little", no_argument, NULL, OPTION_LITTLE},
  {"EB", no_argument, NULL, OPTION_BIG},
  {"EL", no_argument, NULL, OPTION_LITTLE},
  {"parallel", no_argument, NULL, OPTION_PARALLEL},
  {"no-parallel", no_argument, NULL, OPTION_NO_PARALLEL},
  {"warn-explicit-parallel-conflicts", no_argument, NULL, OPTION_WARN_PARALLEL},
  {"Wp", no_argument, NULL, OPTION_WARN_PARALLEL},
  {"no-warn-explicit-parallel-conflicts", no_argument, NULL, OPTION_NO_WARN_PARALLEL},
  {"Wnp", no_argument, NULL, OPTION_NO_WARN_PARALLEL},
  {"ignore-parallel-conflicts", no_argument, NULL, OPTION_IGNORE_PARALLEL},
  {"Ip", no_argument, NULL, OPTION_IGNORE_PARALLEL},
  {"no-ignore-parallel-conflicts", no_argument, NULL, OPTION_NO_IGNORE_PARALLEL},
  {"nIp", no_argument, NULL, OPTION_NO_IGNORE_PARALLEL},
  {"hidden", no_argument, NULL, OPTION_SPECIAL},
  {"bitinst", no_argument, NULL, OPTION_SPECIAL_M32R},
  {"no-bitinst", no_argument, NULL, OPTION_NO_SPECIAL_M32R},
  {"float", no_argument, NULL, OPTION_SPECIAL_FLOAT},
  /* Sigh.  I guess all warnings must now have both variants.  */
  {"warn-unmatched-high", no_argument, NULL, OPTION_WARN_UNMATCHED},
  {"Wuh", no_argument, NULL, OPTION_WARN_UNMATCHED},
  {"no-warn-unmatched-high", no_argument, NULL, OPTION_NO_WARN_UNMATCHED},
  {"Wnuh", no_argument, NULL, OPTION_NO_WARN_UNMATCHED},
  {NULL, no_argument, NULL, 0}
};

size_t md_longopts_size = sizeof (md_longopts);

static void
little (int on)
{
  target_big_endian = ! on;
}

/* Use parallel execution.  */

static int
parallel (void)
{
  if (! enable_m32rx)
    return 0;

  if (use_parallel == 1)
    return 1;

  return 0;
}

int
md_parse_option (int c, char *arg ATTRIBUTE_UNUSED)
{
  switch (c)
    {
    case 'O':
      optimize = 1;
      use_parallel = 1;
      break;

    case OPTION_M32R:
      allow_m32rx (0);
      break;

    case OPTION_M32RX:
      allow_m32rx (1);
      break;

    case OPTION_M32R2:
      allow_m32rx (2);
      enable_special = 1;
      enable_special_m32r = 1;
      break;

    case OPTION_BIG:
      target_big_endian = 1;
      break;

    case OPTION_LITTLE:
      target_big_endian = 0;
      break;

    case OPTION_PARALLEL:
      use_parallel = 1;
      break;

    case OPTION_NO_PARALLEL:
      use_parallel = 0;
      break;

    case OPTION_WARN_PARALLEL:
      warn_explicit_parallel_conflicts = 1;
      break;

    case OPTION_NO_WARN_PARALLEL:
      warn_explicit_parallel_conflicts = 0;
      break;

    case OPTION_IGNORE_PARALLEL:
      ignore_parallel_conflicts = 1;
      break;

    case OPTION_NO_IGNORE_PARALLEL:
      ignore_parallel_conflicts = 0;
      break;

    case OPTION_SPECIAL:
      if (enable_m32rx)
	enable_special = 1;
      else
	{
	  /* Pretend that we do not recognise this option.  */
	  as_bad (_("Unrecognised option: -hidden"));
	  return 0;
	}
      break;

    case OPTION_SPECIAL_M32R:
      enable_special_m32r = 1;
      break;

    case OPTION_NO_SPECIAL_M32R:
      enable_special_m32r = 0;
      break;

    case OPTION_SPECIAL_FLOAT:
      enable_special_float = 1;
      break;

    case OPTION_WARN_UNMATCHED:
      warn_unmatched_high = 1;
      break;

    case OPTION_NO_WARN_UNMATCHED:
      warn_unmatched_high = 0;
      break;

    case 'K':
      if (strcmp (arg, "PIC") != 0)
        as_warn (_("Unrecognized option following -K"));
      else
        pic_code = 1;
      break;

    default:
      return 0;
    }

  return 1;
}

void
md_show_usage (FILE *stream)
{
  fprintf (stream, _(" M32R specific command line options:\n"));

  fprintf (stream, _("\
  -m32r                   disable support for the m32rx instruction set\n"));
  fprintf (stream, _("\
  -m32rx                  support the extended m32rx instruction set\n"));
  fprintf (stream, _("\
  -m32r2                  support the extended m32r2 instruction set\n"));
  fprintf (stream, _("\
  -EL,-little             produce little endian code and data\n"));
  fprintf (stream, _("\
  -EB,-big                produce big endian code and data\n"));
  fprintf (stream, _("\
  -parallel               try to combine instructions in parallel\n"));
  fprintf (stream, _("\
  -no-parallel            disable -parallel\n"));
  fprintf (stream, _("\
  -no-bitinst             disallow the M32R2's extended bit-field instructions\n"));
  fprintf (stream, _("\
  -O                      try to optimize code.  Implies -parallel\n"));

  fprintf (stream, _("\
  -warn-explicit-parallel-conflicts     warn when parallel instructions\n"));
  fprintf (stream, _("\
                                         might violate contraints\n"));
  fprintf (stream, _("\
  -no-warn-explicit-parallel-conflicts  do not warn when parallel\n"));
  fprintf (stream, _("\
                                         instructions might violate contraints\n"));
  fprintf (stream, _("\
  -Wp                     synonym for -warn-explicit-parallel-conflicts\n"));
  fprintf (stream, _("\
  -Wnp                    synonym for -no-warn-explicit-parallel-conflicts\n"));
  fprintf (stream, _("\
  -ignore-parallel-conflicts            do not check parallel instructions\n"));
  fprintf (stream, _("\
                                         for constraint violations\n"));
  fprintf (stream, _("\
  -no-ignore-parallel-conflicts         check parallel instructions for\n"));
  fprintf (stream, _("\
                                         constraint violations\n"));
  fprintf (stream, _("\
  -Ip                     synonym for -ignore-parallel-conflicts\n"));
  fprintf (stream, _("\
  -nIp                    synonym for -no-ignore-parallel-conflicts\n"));

  fprintf (stream, _("\
  -warn-unmatched-high    warn when an (s)high reloc has no matching low reloc\n"));
  fprintf (stream, _("\
  -no-warn-unmatched-high do not warn about missing low relocs\n"));
  fprintf (stream, _("\
  -Wuh                    synonym for -warn-unmatched-high\n"));
  fprintf (stream, _("\
  -Wnuh                   synonym for -no-warn-unmatched-high\n"));

  fprintf (stream, _("\
  -KPIC                   generate PIC\n"));
}

/* Set by md_assemble for use by m32r_fill_insn.  */
static subsegT prev_subseg;
static segT prev_seg;

#define GOT_NAME "_GLOBAL_OFFSET_TABLE_"
symbolS * GOT_symbol;

static inline int
m32r_PIC_related_p (symbolS *sym)
{
  expressionS *exp;

  if (! sym)
    return 0;

  if (sym == GOT_symbol)
    return 1;

  exp = symbol_get_value_expression (sym);

  return (exp->X_op == O_PIC_reloc
          || exp->X_md == BFD_RELOC_M32R_26_PLTREL
          || m32r_PIC_related_p (exp->X_add_symbol)
          || m32r_PIC_related_p (exp->X_op_symbol));
}

static inline int
m32r_check_fixup (expressionS *main_exp, bfd_reloc_code_real_type *r_type_p)
{
  expressionS *exp = main_exp;

  if (exp->X_op == O_add && m32r_PIC_related_p (exp->X_op_symbol))
    return 1;

  if (exp->X_op == O_symbol && exp->X_add_symbol)
    {
      if (exp->X_add_symbol == GOT_symbol)
        {
          *r_type_p = BFD_RELOC_M32R_GOTPC24;
          return 0;
        }
    }
  else if (exp->X_op == O_add)
    {
      exp = symbol_get_value_expression (exp->X_add_symbol);
      if (! exp)
        return 0;
    }

  if (exp->X_op == O_PIC_reloc)
    {
      *r_type_p = exp->X_md;
      if (exp == main_exp)
        exp->X_op = O_symbol;
      else
       {
          main_exp->X_add_symbol = exp->X_add_symbol;
          main_exp->X_add_number += exp->X_add_number;
       }
    }
  else
    return (m32r_PIC_related_p (exp->X_add_symbol)
            || m32r_PIC_related_p (exp->X_op_symbol));

  return 0;
}

/* FIXME: Should be machine generated.  */
#define NOP_INSN     0x7000
#define PAR_NOP_INSN 0xf000 /* Can only be used in 2nd slot.  */

/* This is called from HANDLE_ALIGN in write.c.  Fill in the contents
   of an rs_align_code fragment.  */

void
m32r_handle_align (fragS *fragp)
{
  static const unsigned char nop_pattern[] = { 0xf0, 0x00 };
  static const unsigned char multi_nop_pattern[] = { 0x70, 0x00, 0xf0, 0x00 };

  int bytes, fix;
  char *p;

  if (fragp->fr_type != rs_align_code)
    return;

  bytes = fragp->fr_next->fr_address - fragp->fr_address - fragp->fr_fix;
  p = fragp->fr_literal + fragp->fr_fix;
  fix = 0;

  if (bytes & 1)
    {
      fix = 1;
      *p++ = 0;
      bytes--;
    }

  if (bytes & 2)
    {
      memcpy (p, nop_pattern, 2);
      p += 2;
      bytes -= 2;
      fix += 2;
    }

  memcpy (p, multi_nop_pattern, 4);

  fragp->fr_fix += fix;
  fragp->fr_var = 4;
}

/* If the last instruction was the first of 2 16 bit insns,
   output a nop to move the PC to a 32 bit boundary.

   This is done via an alignment specification since branch relaxing
   may make it unnecessary.

   Internally, we need to output one of these each time a 32 bit insn is
   seen after an insn that is relaxable.  */

static void
fill_insn (int ignore ATTRIBUTE_UNUSED)
{
  frag_align_code (2, 0);
  prev_insn.insn = NULL;
  seen_relaxable_p = 0;
}

/* Record the symbol so that when we output the insn, we can create
   a symbol that is at the start of the instruction.  This is used
   to emit the label for the start of a breakpoint without causing
   the assembler to emit a NOP if the previous instruction was a
   16 bit instruction.  */

static void
debug_sym (int ignore ATTRIBUTE_UNUSED)
{
  char *name;
  char delim;
  char *end_name;
  symbolS *symbolP;
  sym_linkS *lnk;

  name = input_line_pointer;
  delim = get_symbol_end ();
  end_name = input_line_pointer;

  if ((symbolP = symbol_find (name)) == NULL
      && (symbolP = md_undefined_symbol (name)) == NULL)
    symbolP = symbol_new (name, undefined_section, 0, &zero_address_frag);

  symbol_table_insert (symbolP);
  if (S_IS_DEFINED (symbolP) && (S_GET_SEGMENT (symbolP) != reg_section
                                 || S_IS_EXTERNAL (symbolP)
                                 || S_IS_WEAK (symbolP)))
    /* xgettext:c-format */
    as_bad (_("symbol `%s' already defined"), S_GET_NAME (symbolP));

  else
    {
      lnk = (sym_linkS *) xmalloc (sizeof (sym_linkS));
      lnk->symbol = symbolP;
      lnk->next = debug_sym_link;
      debug_sym_link = lnk;
      symbol_get_obj (symbolP)->local = 1;
    }

  *end_name = delim;
  demand_empty_rest_of_line ();
}

/* Second pass to expanding the debug symbols, go through linked
   list of symbols and reassign the address.  */

static void
expand_debug_syms (sym_linkS *syms, int align)
{
  char *save_input_line = input_line_pointer;
  sym_linkS *next_syms;

  if (!syms)
    return;

  (void) frag_align_code (align, 0);
  for (; syms != (sym_linkS *) 0; syms = next_syms)
    {
      symbolS *symbolP = syms->symbol;
      next_syms = syms->next;
      input_line_pointer = ".\n";
      pseudo_set (symbolP);
      free ((char *) syms);
    }

  input_line_pointer = save_input_line;
}

void
m32r_flush_pending_output (void)
{
  if (debug_sym_link)
    {
      expand_debug_syms (debug_sym_link, 1);
      debug_sym_link = (sym_linkS *) 0;
    }
}

/* Cover function to fill_insn called after a label and at end of assembly.
   The result is always 1: we're called in a conditional to see if the
   current line is a label.  */

int
m32r_fill_insn (int done)
{
  if (prev_seg != NULL)
    {
      segT seg = now_seg;
      subsegT subseg = now_subseg;

      subseg_set (prev_seg, prev_subseg);

      fill_insn (0);

      subseg_set (seg, subseg);
    }

  if (done && debug_sym_link)
    {
      expand_debug_syms (debug_sym_link, 1);
      debug_sym_link = (sym_linkS *) 0;
    }

  return 1;
}

/* The default target format to use.  */

const char *
m32r_target_format (void)
{
#ifdef TE_LINUX
  if (target_big_endian)
    return "elf32-m32r-linux";
  else
    return "elf32-m32rle-linux";
#else
  if (target_big_endian)
    return "elf32-m32r";
  else
    return "elf32-m32rle";
#endif
}

void
md_begin (void)
{
  flagword applicable;
  segT seg;
  subsegT subseg;

  /* Initialize the `cgen' interface.  */

  /* Set the machine number and endian.  */
  gas_cgen_cpu_desc = m32r_cgen_cpu_open (CGEN_CPU_OPEN_MACHS, 0,
					  CGEN_CPU_OPEN_ENDIAN,
					  (target_big_endian ?
					   CGEN_ENDIAN_BIG : CGEN_ENDIAN_LITTLE),
					  CGEN_CPU_OPEN_END);
  m32r_cgen_init_asm (gas_cgen_cpu_desc);

  /* The operand instance table is used during optimization to determine
     which insns can be executed in parallel.  It is also used to give
     warnings regarding operand interference in parallel insns.  */
  m32r_cgen_init_opinst_table (gas_cgen_cpu_desc);

  /* This is a callback from cgen to gas to parse operands.  */
  cgen_set_parse_operand_fn (gas_cgen_cpu_desc, gas_cgen_parse_operand);

  /* Save the current subseg so we can restore it [it's the default one and
     we don't want the initial section to be .sbss].  */
  seg    = now_seg;
  subseg = now_subseg;

  /* The sbss section is for local .scomm symbols.  */
  sbss_section = subseg_new (".sbss", 0);
  seg_info (sbss_section)->bss = 1;

  /* This is copied from perform_an_assembly_pass.  */
  applicable = bfd_applicable_section_flags (stdoutput);
  bfd_set_section_flags (stdoutput, sbss_section, applicable & SEC_ALLOC);

  subseg_set (seg, subseg);

  /* We must construct a fake section similar to bfd_com_section
     but with the name .scommon.  */
  scom_section                = *bfd_com_section_ptr;
  scom_section.name           = ".scommon";
  scom_section.output_section = & scom_section;
  scom_section.symbol         = & scom_symbol;
  scom_section.symbol_ptr_ptr = & scom_section.symbol;
  scom_symbol                 = * bfd_com_section_ptr->symbol;
  scom_symbol.name            = ".scommon";
  scom_symbol.section         = & scom_section;

  allow_m32rx (enable_m32rx);

  gas_cgen_initialize_saved_fixups_array ();
}

#define OPERAND_IS_COND_BIT(operand, indices, index) \
  ((operand)->hw_type == HW_H_COND			\
   || ((operand)->hw_type == HW_H_PSW)			\
   || ((operand)->hw_type == HW_H_CR			\
       && (indices [index] == 0 || indices [index] == 1)))

/* Returns true if an output of instruction 'a' is referenced by an operand
   of instruction 'b'.  If 'check_outputs' is true then b's outputs are
   checked, otherwise its inputs are examined.  */

static int
first_writes_to_seconds_operands (m32r_insn *a,
				  m32r_insn *b,
				  const int check_outputs)
{
  const CGEN_OPINST *a_operands = CGEN_INSN_OPERANDS (a->insn);
  const CGEN_OPINST *b_ops = CGEN_INSN_OPERANDS (b->insn);
  int a_index;

  if (ignore_parallel_conflicts)
    return 0;

  /* If at least one of the instructions takes no operands, then there is
     nothing to check.  There really are instructions without operands,
     eg 'nop'.  */
  if (a_operands == NULL || b_ops == NULL)
    return 0;

  /* Scan the operand list of 'a' looking for an output operand.  */
  for (a_index = 0;
       a_operands->type != CGEN_OPINST_END;
       a_index ++, a_operands ++)
    {
      if (a_operands->type == CGEN_OPINST_OUTPUT)
	{
	  int b_index;
	  const CGEN_OPINST *b_operands = b_ops;

	  /* Special Case:
	     The Condition bit 'C' is a shadow of the CBR register (control
	     register 1) and also a shadow of bit 31 of the program status
	     word (control register 0).  For now this is handled here, rather
	     than by cgen....  */

	  if (OPERAND_IS_COND_BIT (a_operands, a->indices, a_index))
	    {
	      /* Scan operand list of 'b' looking for another reference to the
		 condition bit, which goes in the right direction.  */
	      for (b_index = 0;
		   b_operands->type != CGEN_OPINST_END;
		   b_index++, b_operands++)
		{
		  if ((b_operands->type
		       == (check_outputs
			   ? CGEN_OPINST_OUTPUT
			   : CGEN_OPINST_INPUT))
		      && OPERAND_IS_COND_BIT (b_operands, b->indices, b_index))
		    return 1;
		}
	    }
	  else
	    {
	      /* Scan operand list of 'b' looking for an operand that
		 references the same hardware element, and which goes in the
		 right direction.  */
	      for (b_index = 0;
		   b_operands->type != CGEN_OPINST_END;
		   b_index++, b_operands++)
		{
		  if ((b_operands->type
		       == (check_outputs
			   ? CGEN_OPINST_OUTPUT
			   : CGEN_OPINST_INPUT))
		      && (b_operands->hw_type == a_operands->hw_type)
		      && (a->indices[a_index] == b->indices[b_index]))
		    return 1;
		}
	    }
	}
    }

  return 0;
}

/* Returns true if the insn can (potentially) alter the program counter.  */

static int
writes_to_pc (m32r_insn *a)
{
  if (CGEN_INSN_ATTR_VALUE (a->insn, CGEN_INSN_UNCOND_CTI)
      || CGEN_INSN_ATTR_VALUE (a->insn, CGEN_INSN_COND_CTI))
    return 1;
  return 0;
}

/* Return NULL if the two 16 bit insns can be executed in parallel.
   Otherwise return a pointer to an error message explaining why not.  */

static const char *
can_make_parallel (m32r_insn *a, m32r_insn *b)
{
  PIPE_ATTR a_pipe;
  PIPE_ATTR b_pipe;

  /* Make sure the instructions are the right length.  */
  if (CGEN_FIELDS_BITSIZE (&a->fields) != 16
      || CGEN_FIELDS_BITSIZE (&b->fields) != 16)
    abort ();

  if (first_writes_to_seconds_operands (a, b, TRUE))
    return _("instructions write to the same destination register.");

  a_pipe = CGEN_INSN_ATTR_VALUE (a->insn, CGEN_INSN_PIPE);
  b_pipe = CGEN_INSN_ATTR_VALUE (b->insn, CGEN_INSN_PIPE);

  /* Make sure that the instructions use the correct execution pipelines.  */
  if (a_pipe == PIPE_NONE
      || b_pipe == PIPE_NONE)
    return _("Instructions do not use parallel execution pipelines.");

  /* Leave this test for last, since it is the only test that can
     go away if the instructions are swapped, and we want to make
     sure that any other errors are detected before this happens.  */
  if (a_pipe == PIPE_S
      || b_pipe == PIPE_O
      || (b_pipe == PIPE_O_OS && (enable_m32rx != 2)))
    return _("Instructions share the same execution pipeline");

  return NULL;
}

/* Force the top bit of the second 16-bit insn to be set.  */

static void
make_parallel (CGEN_INSN_BYTES_PTR buffer)
{
#if CGEN_INT_INSN_P
  *buffer |= 0x8000;
#else
  buffer[CGEN_CPU_ENDIAN (gas_cgen_cpu_desc) == CGEN_ENDIAN_BIG ? 0 : 1]
    |= 0x80;
#endif
}

/* Same as make_parallel except buffer contains the bytes in target order.  */

static void
target_make_parallel (char *buffer)
{
  buffer[CGEN_CPU_ENDIAN (gas_cgen_cpu_desc) == CGEN_ENDIAN_BIG ? 0 : 1]
    |= 0x80;
}

/* Assemble two instructions with an explicit parallel operation (||) or
   sequential operation (->).  */

static void
assemble_two_insns (char *str1, char *str2, int parallel_p)
{
  char *str3;
  m32r_insn first;
  m32r_insn second;
  char *errmsg;
  char save_str2 = *str2;

  /* Separate the two instructions.  */
  *str2 = 0;

  /* Make sure the two insns begin on a 32 bit boundary.
     This is also done for the serial case (foo -> bar), relaxing doesn't
     affect insns written like this.
     Note that we must always do this as we can't assume anything about
     whether we're currently on a 32 bit boundary or not.  Relaxing may
     change this.  */
  fill_insn (0);

  first.debug_sym_link = debug_sym_link;
  debug_sym_link = (sym_linkS *) 0;

  /* Parse the first instruction.  */
  if (! (first.insn = m32r_cgen_assemble_insn
	 (gas_cgen_cpu_desc, str1, & first.fields, first.buffer, & errmsg)))
    {
      as_bad ("%s", errmsg);
      return;
    }

  /* Check it.  */
  if (CGEN_FIELDS_BITSIZE (&first.fields) != 16)
    {
      /* xgettext:c-format  */
      as_bad (_("not a 16 bit instruction '%s'"), str1);
      return;
    }
#ifdef E_M32R2_ARCH
  else if ((enable_m32rx == 1)
           /* FIXME: Need standard macro to perform this test.  */
           && ((CGEN_INSN_ATTR_VALUE (first.insn, CGEN_INSN_MACH)
                & (1 << MACH_M32R2))
               && !((CGEN_INSN_ATTR_VALUE (first.insn, CGEN_INSN_MACH)
                    & (1 << MACH_M32RX)))))
    {
      /* xgettext:c-format  */
      as_bad (_("instruction '%s' is for the M32R2 only"), str1);
      return;
    }
  else if ((! enable_special
            && CGEN_INSN_ATTR_VALUE (first.insn, CGEN_INSN_SPECIAL))
           || (! enable_special_m32r
               && CGEN_INSN_ATTR_VALUE (first.insn, CGEN_INSN_SPECIAL_M32R)))
#else
  else if (! enable_special
      && CGEN_INSN_ATTR_VALUE (first.insn, CGEN_INSN_SPECIAL))
#endif
    {
      /* xgettext:c-format  */
      as_bad (_("unknown instruction '%s'"), str1);
      return;
    }
  else if (! enable_m32rx
	   /* FIXME: Need standard macro to perform this test.  */
	   && (CGEN_INSN_ATTR_VALUE (first.insn, CGEN_INSN_MACH)
	       == (1 << MACH_M32RX)))
    {
      /* xgettext:c-format  */
      as_bad (_("instruction '%s' is for the M32RX only"), str1);
      return;
    }

  /* Check to see if this is an allowable parallel insn.  */
  if (parallel_p
      && CGEN_INSN_ATTR_VALUE (first.insn, CGEN_INSN_PIPE) == PIPE_NONE)
    {
      /* xgettext:c-format  */
      as_bad (_("instruction '%s' cannot be executed in parallel."), str1);
      return;
    }

  /* Restore the original assembly text, just in case it is needed.  */
  *str2 = save_str2;

  /* Save the original string pointer.  */
  str3 = str1;

  /* Advanced past the parsed string.  */
  str1 = str2 + 2;

  /* Remember the entire string in case it is needed for error
     messages.  */
  str2 = str3;

  /* Convert the opcode to lower case.  */
  {
    char *s2 = str1;

    while (ISSPACE (*s2++))
      continue;

    --s2;

    while (ISALNUM (*s2))
      {
	*s2 = TOLOWER (*s2);
	s2++;
      }
  }

  /* Preserve any fixups that have been generated and reset the list
     to empty.  */
  gas_cgen_save_fixups (0);

  /* Get the indices of the operands of the instruction.  */
  /* FIXME: CGEN_FIELDS is already recorded, but relying on that fact
     doesn't seem right.  Perhaps allow passing fields like we do insn.  */
  /* FIXME: ALIAS insns do not have operands, so we use this function
     to find the equivalent insn and overwrite the value stored in our
     structure.  We still need the original insn, however, since this
     may have certain attributes that are not present in the unaliased
     version (eg relaxability).  When aliases behave differently this
     may have to change.  */
  first.orig_insn = first.insn;
  {
    CGEN_FIELDS tmp_fields;
    first.insn = cgen_lookup_get_insn_operands
      (gas_cgen_cpu_desc, NULL, INSN_VALUE (first.buffer), NULL, 16,
       first.indices, &tmp_fields);
  }

  if (first.insn == NULL)
    as_fatal (_("internal error: lookup/get operands failed"));

  second.debug_sym_link = NULL;

  /* Parse the second instruction.  */
  if (! (second.insn = m32r_cgen_assemble_insn
	 (gas_cgen_cpu_desc, str1, & second.fields, second.buffer, & errmsg)))
    {
      as_bad ("%s", errmsg);
      return;
    }

  /* Check it.  */
  if (CGEN_FIELDS_BITSIZE (&second.fields) != 16)
    {
      /* xgettext:c-format  */
      as_bad (_("not a 16 bit instruction '%s'"), str1);
      return;
    }
#ifdef E_M32R2_ARCH
  else if ((enable_m32rx == 1)
           /* FIXME: Need standard macro to perform this test.  */
           && ((CGEN_INSN_ATTR_VALUE (first.insn, CGEN_INSN_MACH)
                & (1 << MACH_M32R2))
               && !((CGEN_INSN_ATTR_VALUE (first.insn, CGEN_INSN_MACH)
                    & (1 << MACH_M32RX)))))
    {
      /* xgettext:c-format  */
      as_bad (_("instruction '%s' is for the M32R2 only"), str1);
      return;
    }
  else if ((! enable_special
            && CGEN_INSN_ATTR_VALUE (second.insn, CGEN_INSN_SPECIAL))
           || (! enable_special_m32r
               && CGEN_INSN_ATTR_VALUE (second.insn, CGEN_INSN_SPECIAL_M32R)))
#else
  else if (! enable_special
      && CGEN_INSN_ATTR_VALUE (second.insn, CGEN_INSN_SPECIAL))
#endif
    {
      /* xgettext:c-format  */
      as_bad (_("unknown instruction '%s'"), str1);
      return;
    }
  else if (! enable_m32rx
      && CGEN_INSN_ATTR_VALUE (second.insn, CGEN_INSN_MACH) == (1 << MACH_M32RX))
    {
      /* xgettext:c-format  */
      as_bad (_("instruction '%s' is for the M32RX only"), str1);
      return;
    }

  /* Check to see if this is an allowable parallel insn.  */
  if (parallel_p
      && CGEN_INSN_ATTR_VALUE (second.insn, CGEN_INSN_PIPE) == PIPE_NONE)
    {
      /* xgettext:c-format  */
      as_bad (_("instruction '%s' cannot be executed in parallel."), str1);
      return;
    }

  if (parallel_p && ! enable_m32rx)
    {
      if (CGEN_INSN_NUM (first.insn) != M32R_INSN_NOP
	  && CGEN_INSN_NUM (second.insn) != M32R_INSN_NOP)
	{
	  /* xgettext:c-format  */
	  as_bad (_("'%s': only the NOP instruction can be issued in parallel on the m32r"), str2);
	  return;
	}
    }

  /* Get the indices of the operands of the instruction.  */
  second.orig_insn = second.insn;
  {
    CGEN_FIELDS tmp_fields;
    second.insn = cgen_lookup_get_insn_operands
      (gas_cgen_cpu_desc, NULL, INSN_VALUE (second.buffer), NULL, 16,
       second.indices, &tmp_fields);
  }

  if (second.insn == NULL)
    as_fatal (_("internal error: lookup/get operands failed"));

  /* We assume that if the first instruction writes to a register that is
     read by the second instruction it is because the programmer intended
     this to happen, (after all they have explicitly requested that these
     two instructions be executed in parallel).  Although if the global
     variable warn_explicit_parallel_conflicts is true then we do generate
     a warning message.  Similarly we assume that parallel branch and jump
     instructions are deliberate and should not produce errors.  */

  if (parallel_p && warn_explicit_parallel_conflicts)
    {
      if (first_writes_to_seconds_operands (&first, &second, FALSE))
	/* xgettext:c-format  */
	as_warn (_("%s: output of 1st instruction is the same as an input to 2nd instruction - is this intentional ?"), str2);

      if (first_writes_to_seconds_operands (&second, &first, FALSE))
	/* xgettext:c-format  */
	as_warn (_("%s: output of 2nd instruction is the same as an input to 1st instruction - is this intentional ?"), str2);
    }

  if (!parallel_p
      || (errmsg = (char *) can_make_parallel (&first, &second)) == NULL)
    {
      /* Get the fixups for the first instruction.  */
      gas_cgen_swap_fixups (0);

      /* Write it out.  */
      expand_debug_syms (first.debug_sym_link, 1);
      gas_cgen_finish_insn (first.orig_insn, first.buffer,
			    CGEN_FIELDS_BITSIZE (&first.fields), 0, NULL);

      /* Force the top bit of the second insn to be set.  */
      if (parallel_p)
	make_parallel (second.buffer);

      /* Get its fixups.  */
      gas_cgen_restore_fixups (0);

      /* Write it out.  */
      expand_debug_syms (second.debug_sym_link, 1);
      gas_cgen_finish_insn (second.orig_insn, second.buffer,
			    CGEN_FIELDS_BITSIZE (&second.fields), 0, NULL);
    }
  /* Try swapping the instructions to see if they work that way.  */
  else if (can_make_parallel (&second, &first) == NULL)
    {
      /* Write out the second instruction first.  */
      expand_debug_syms (second.debug_sym_link, 1);
      gas_cgen_finish_insn (second.orig_insn, second.buffer,
			    CGEN_FIELDS_BITSIZE (&second.fields), 0, NULL);

      /* Force the top bit of the first instruction to be set.  */
      make_parallel (first.buffer);

      /* Get the fixups for the first instruction.  */
      gas_cgen_restore_fixups (0);

      /* Write out the first instruction.  */
      expand_debug_syms (first.debug_sym_link, 1);
      gas_cgen_finish_insn (first.orig_insn, first.buffer,
			    CGEN_FIELDS_BITSIZE (&first.fields), 0, NULL);
    }
  else
    {
      as_bad ("'%s': %s", str2, errmsg);
      return;
    }

  if (CGEN_INSN_ATTR_VALUE (first.insn, CGEN_INSN_SPECIAL)
      || CGEN_INSN_ATTR_VALUE (second.insn, CGEN_INSN_SPECIAL))
    m32r_flags |= E_M32R_HAS_HIDDEN_INST;
  if (CGEN_INSN_ATTR_VALUE (first.insn, CGEN_INSN_SPECIAL_M32R)
      || CGEN_INSN_ATTR_VALUE (second.insn, CGEN_INSN_SPECIAL_M32R))
    m32r_flags |= E_M32R_HAS_BIT_INST;
  if (CGEN_INSN_ATTR_VALUE (first.insn, CGEN_INSN_SPECIAL_FLOAT)
      || CGEN_INSN_ATTR_VALUE (second.insn, CGEN_INSN_SPECIAL_FLOAT))
    m32r_flags |= E_M32R_HAS_FLOAT_INST;

  /* Set these so m32r_fill_insn can use them.  */
  prev_seg    = now_seg;
  prev_subseg = now_subseg;
}

void
md_assemble (char *str)
{
  m32r_insn insn;
  char *errmsg;
  char *str2 = NULL;

  /* Initialize GAS's cgen interface for a new instruction.  */
  gas_cgen_init_parse ();

  /* Look for a parallel instruction separator.  */
  if ((str2 = strstr (str, "||")) != NULL)
    {
      assemble_two_insns (str, str2, 1);
      m32r_flags |= E_M32R_HAS_PARALLEL;
      return;
    }

  /* Also look for a sequential instruction separator.  */
  if ((str2 = strstr (str, "->")) != NULL)
    {
      assemble_two_insns (str, str2, 0);
      return;
    }

  insn.debug_sym_link = debug_sym_link;
  debug_sym_link = (sym_linkS *) 0;

  insn.insn = m32r_cgen_assemble_insn
    (gas_cgen_cpu_desc, str, &insn.fields, insn.buffer, & errmsg);

  if (!insn.insn)
    {
      as_bad ("%s", errmsg);
      return;
    }

#ifdef E_M32R2_ARCH
  if ((enable_m32rx == 1)
       /* FIXME: Need standard macro to perform this test.  */
      && ((CGEN_INSN_ATTR_VALUE (insn.insn, CGEN_INSN_MACH)
           & (1 << MACH_M32R2))
          && !((CGEN_INSN_ATTR_VALUE (insn.insn, CGEN_INSN_MACH)
               & (1 << MACH_M32RX)))))
    {
      /* xgettext:c-format  */
      as_bad (_("instruction '%s' is for the M32R2 only"), str);
      return;
    }
  else if ((! enable_special
       && CGEN_INSN_ATTR_VALUE (insn.insn, CGEN_INSN_SPECIAL))
      || (! enable_special_m32r
          && CGEN_INSN_ATTR_VALUE (insn.insn, CGEN_INSN_SPECIAL_M32R)))
#else
  if (! enable_special
      && CGEN_INSN_ATTR_VALUE (insn.insn, CGEN_INSN_SPECIAL))
#endif
    {
      /* xgettext:c-format  */
      as_bad (_("unknown instruction '%s'"), str);
      return;
    }
  else if (! enable_m32rx
	   && CGEN_INSN_ATTR_VALUE (insn.insn, CGEN_INSN_MACH) == (1 << MACH_M32RX))
    {
      /* xgettext:c-format  */
      as_bad (_("instruction '%s' is for the M32RX only"), str);
      return;
    }

  if (CGEN_INSN_ATTR_VALUE (insn.insn, CGEN_INSN_SPECIAL))
    m32r_flags |= E_M32R_HAS_HIDDEN_INST;
  if (CGEN_INSN_ATTR_VALUE (insn.insn, CGEN_INSN_SPECIAL_M32R))
    m32r_flags |= E_M32R_HAS_BIT_INST;
  if (CGEN_INSN_ATTR_VALUE (insn.insn, CGEN_INSN_SPECIAL_FLOAT))
    m32r_flags |= E_M32R_HAS_FLOAT_INST;

  if (CGEN_INSN_BITSIZE (insn.insn) == 32)
    {
      /* 32 bit insns must live on 32 bit boundaries.  */
      if (prev_insn.insn || seen_relaxable_p)
	{
	  /* ??? If calling fill_insn too many times turns us into a memory
	     pig, can we call a fn to assemble a nop instead of
	     !seen_relaxable_p?  */
	  fill_insn (0);
	}

      expand_debug_syms (insn.debug_sym_link, 2);

      /* Doesn't really matter what we pass for RELAX_P here.  */
      gas_cgen_finish_insn (insn.insn, insn.buffer,
			    CGEN_FIELDS_BITSIZE (&insn.fields), 1, NULL);
    }
  else
    {
      int on_32bit_boundary_p;
      int swap = FALSE;

      if (CGEN_INSN_BITSIZE (insn.insn) != 16)
	abort ();

      insn.orig_insn = insn.insn;

      /* If the previous insn was relaxable, then it may be expanded
	 to fill the current 16 bit slot.  Emit a NOP here to occupy
	 this slot, so that we can start at optimizing at a 32 bit
	 boundary.  */
      if (prev_insn.insn && seen_relaxable_p && optimize)
	fill_insn (0);

      if (enable_m32rx)
	{
	  /* Get the indices of the operands of the instruction.
	     FIXME: See assemble_parallel for notes on orig_insn.  */
	  {
	    CGEN_FIELDS tmp_fields;
	    insn.insn = cgen_lookup_get_insn_operands
	      (gas_cgen_cpu_desc, NULL, INSN_VALUE (insn.buffer), NULL,
	       16, insn.indices, &tmp_fields);
	  }

	  if (insn.insn == NULL)
	    as_fatal (_("internal error: lookup/get operands failed"));
	}

      /* Compute whether we're on a 32 bit boundary or not.
	 prev_insn.insn is NULL when we're on a 32 bit boundary.  */
      on_32bit_boundary_p = prev_insn.insn == NULL;

      /* Change a frag to, if each insn to swap is in a different frag.
         It must keep only one instruction in a frag.  */
      if (parallel() && on_32bit_boundary_p)
        {
          frag_wane (frag_now);
          frag_new (0);
        }

      /* Look to see if this instruction can be combined with the
	 previous instruction to make one, parallel, 32 bit instruction.
	 If the previous instruction (potentially) changed the flow of
	 program control, then it cannot be combined with the current
	 instruction.  If the current instruction is relaxable, then it
	 might be replaced with a longer version, so we cannot combine it.
	 Also if the output of the previous instruction is used as an
	 input to the current instruction then it cannot be combined.
	 Otherwise call can_make_parallel() with both orderings of the
	 instructions to see if they can be combined.  */
      if (! on_32bit_boundary_p
	  && parallel ()
	  && CGEN_INSN_ATTR_VALUE (insn.orig_insn, CGEN_INSN_RELAXABLE) == 0
	  && ! writes_to_pc (&prev_insn)
	  && ! first_writes_to_seconds_operands (&prev_insn, &insn, FALSE))
	{
	  if (can_make_parallel (&prev_insn, &insn) == NULL)
	    make_parallel (insn.buffer);
	  else if (can_make_parallel (&insn, &prev_insn) == NULL)
	    swap = TRUE;
	}

      expand_debug_syms (insn.debug_sym_link, 1);

      {
	int i;
	finished_insnS fi;

	/* Ensure each pair of 16 bit insns is in the same frag.  */
	frag_grow (4);

	gas_cgen_finish_insn (insn.orig_insn, insn.buffer,
			      CGEN_FIELDS_BITSIZE (&insn.fields),
			      1 /* relax_p  */, &fi);
	insn.addr = fi.addr;
	insn.frag = fi.frag;
	insn.num_fixups = fi.num_fixups;
	for (i = 0; i < fi.num_fixups; ++i)
	  insn.fixups[i] = fi.fixups[i];
      }

      if (swap)
	{
	  int i, tmp;

#define SWAP_BYTES(a,b) tmp = a; a = b; b = tmp

	  /* Swap the two insns */
	  SWAP_BYTES (prev_insn.addr[0], insn.addr[0]);
	  SWAP_BYTES (prev_insn.addr[1], insn.addr[1]);

	  target_make_parallel (insn.addr);

	  /* Swap any relaxable frags recorded for the two insns.  */
	  /* FIXME: Clarify.  relaxation precludes parallel insns */
	  if (prev_insn.frag->fr_opcode == prev_insn.addr)
	    prev_insn.frag->fr_opcode = insn.addr;
	  else if (insn.frag->fr_opcode == insn.addr)
	    insn.frag->fr_opcode = prev_insn.addr;

          /* Change a frag to, if each insn is in a different frag.
	     It must keep only one instruction in a frag.  */
          if (prev_insn.frag != insn.frag)
            {
              for (i = 0; i < prev_insn.num_fixups; ++i)
                prev_insn.fixups[i]->fx_frag = insn.frag;
              for (i = 0; i < insn.num_fixups; ++i)
                insn.fixups[i]->fx_frag = prev_insn.frag;
            }
          else
	    {
	      /* Update the addresses in any fixups.
		 Note that we don't have to handle the case where each insn is in
		 a different frag as we ensure they're in the same frag above.  */
	      for (i = 0; i < prev_insn.num_fixups; ++i)
		prev_insn.fixups[i]->fx_where += 2;
	      for (i = 0; i < insn.num_fixups; ++i)
		insn.fixups[i]->fx_where -= 2;
	    }
	}

      /* Keep track of whether we've seen a pair of 16 bit insns.
	 prev_insn.insn is NULL when we're on a 32 bit boundary.  */
      if (on_32bit_boundary_p)
	prev_insn = insn;
      else
	prev_insn.insn = NULL;

      /* If the insn needs the following one to be on a 32 bit boundary
	 (e.g. subroutine calls), fill this insn's slot.  */
      if (on_32bit_boundary_p
	  && CGEN_INSN_ATTR_VALUE (insn.orig_insn, CGEN_INSN_FILL_SLOT) != 0)
	fill_insn (0);

      /* If this is a relaxable insn (can be replaced with a larger version)
	 mark the fact so that we can emit an alignment directive for a
	 following 32 bit insn if we see one.   */
      if (CGEN_INSN_ATTR_VALUE (insn.orig_insn, CGEN_INSN_RELAXABLE) != 0)
	seen_relaxable_p = 1;
    }

  /* Set these so m32r_fill_insn can use them.  */
  prev_seg    = now_seg;
  prev_subseg = now_subseg;
}

/* The syntax in the manual says constants begin with '#'.
   We just ignore it.  */

void
md_operand (expressionS *expressionP)
{
  if (*input_line_pointer == '#')
    {
      input_line_pointer++;
      expression (expressionP);
    }
}

valueT
md_section_align (segT segment, valueT size)
{
  int align = bfd_get_section_alignment (stdoutput, segment);

  return ((size + (1 << align) - 1) & (-1 << align));
}

symbolS *
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
{
  return 0;
}

/* .scomm pseudo-op handler.

   This is a new pseudo-op to handle putting objects in .scommon.
   By doing this the linker won't need to do any work,
   and more importantly it removes the implicit -G arg necessary to
   correctly link the object file.  */

static void
m32r_scomm (int ignore ATTRIBUTE_UNUSED)
{
  char *name;
  char c;
  char *p;
  offsetT size;
  symbolS *symbolP;
  offsetT align;
  int align2;

  name = input_line_pointer;
  c = get_symbol_end ();

  /* Just after name is now '\0'.  */
  p = input_line_pointer;
  *p = c;
  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
      as_bad (_("Expected comma after symbol-name: rest of line ignored."));
      ignore_rest_of_line ();
      return;
    }

  /* Skip ','.  */
  input_line_pointer++;
  if ((size = get_absolute_expression ()) < 0)
    {
      /* xgettext:c-format  */
      as_warn (_(".SCOMMon length (%ld.) <0! Ignored."), (long) size);
      ignore_rest_of_line ();
      return;
    }

  /* The third argument to .scomm is the alignment.  */
  if (*input_line_pointer != ',')
    align = 8;
  else
    {
      ++input_line_pointer;
      align = get_absolute_expression ();
      if (align <= 0)
	{
	  as_warn (_("ignoring bad alignment"));
	  align = 8;
	}
    }

  /* Convert to a power of 2 alignment.  */
  if (align)
    {
      for (align2 = 0; (align & 1) == 0; align >>= 1, ++align2)
	continue;
      if (align != 1)
	{
	  as_bad (_("Common alignment not a power of 2"));
	  ignore_rest_of_line ();
	  return;
	}
    }
  else
    align2 = 0;

  *p = 0;
  symbolP = symbol_find_or_make (name);
  *p = c;

  if (S_IS_DEFINED (symbolP))
    {
      /* xgettext:c-format  */
      as_bad (_("Ignoring attempt to re-define symbol `%s'."),
	      S_GET_NAME (symbolP));
      ignore_rest_of_line ();
      return;
    }

  if (S_GET_VALUE (symbolP) && S_GET_VALUE (symbolP) != (valueT) size)
    {
      /* xgettext:c-format  */
      as_bad (_("Length of .scomm \"%s\" is already %ld. Not changed to %ld."),
	      S_GET_NAME (symbolP),
	      (long) S_GET_VALUE (symbolP),
	      (long) size);

      ignore_rest_of_line ();
      return;
    }

  if (symbol_get_obj (symbolP)->local)
    {
      segT old_sec = now_seg;
      int old_subsec = now_subseg;
      char *pfrag;

      record_alignment (sbss_section, align2);
      subseg_set (sbss_section, 0);

      if (align2)
	frag_align (align2, 0, 0);

      if (S_GET_SEGMENT (symbolP) == sbss_section)
	symbol_get_frag (symbolP)->fr_symbol = 0;

      symbol_set_frag (symbolP, frag_now);

      pfrag = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP, size,
			(char *) 0);
      *pfrag = 0;
      S_SET_SIZE (symbolP, size);
      S_SET_SEGMENT (symbolP, sbss_section);
      S_CLEAR_EXTERNAL (symbolP);
      subseg_set (old_sec, old_subsec);
    }
  else
    {
      S_SET_VALUE (symbolP, (valueT) size);
      S_SET_ALIGN (symbolP, align2);
      S_SET_EXTERNAL (symbolP);
      S_SET_SEGMENT (symbolP, &scom_section);
    }

  demand_empty_rest_of_line ();
}

/* The target specific pseudo-ops which we support.  */
const pseudo_typeS md_pseudo_table[] =
{
  { "word",	cons,		4 },
  { "fillinsn", fill_insn,	0 },
  { "scomm",	m32r_scomm,	0 },
  { "debugsym",	debug_sym,	0 },
  { "m32r",	allow_m32rx,	0 },
  { "m32rx",	allow_m32rx,	1 },
  { "m32r2",	allow_m32rx,	2 },
  { "little",   little,         1 },
  { "big",      little,         0 },
  { NULL, NULL, 0 }
};

/* Interface to relax_segment.  */

/* FIXME: Build table by hand, get it working, then machine generate.  */

const relax_typeS md_relax_table[] =
{
/* The fields are:
   1) most positive reach of this state,
   2) most negative reach of this state,
   3) how many bytes this mode will add to the size of the current frag
   4) which index into the table to try if we can't fit into this one.  */

  /* The first entry must be unused because an `rlx_more' value of zero ends
     each list.  */
  {1, 1, 0, 0},

  /* The displacement used by GAS is from the end of the 2 byte insn,
     so we subtract 2 from the following.  */
  /* 16 bit insn, 8 bit disp -> 10 bit range.
     This doesn't handle a branch in the right slot at the border:
     the "& -4" isn't taken into account.  It's not important enough to
     complicate things over it, so we subtract an extra 2 (or + 2 in -ve
     case).  */
  {511 - 2 - 2, -512 - 2 + 2, 0, 2 },
  /* 32 bit insn, 24 bit disp -> 26 bit range.  */
  {0x2000000 - 1 - 2, -0x2000000 - 2, 2, 0 },
  /* Same thing, but with leading nop for alignment.  */
  {0x2000000 - 1 - 2, -0x2000000 - 2, 4, 0 }
};

long
m32r_relax_frag (segT segment, fragS *fragP, long stretch)
{
  /* Address of branch insn.  */
  long address = fragP->fr_address + fragP->fr_fix - 2;
  long growth = 0;

  /* Keep 32 bit insns aligned on 32 bit boundaries.  */
  if (fragP->fr_subtype == 2)
    {
      if ((address & 3) != 0)
	{
	  fragP->fr_subtype = 3;
	  growth = 2;
	}
    }
  else if (fragP->fr_subtype == 3)
    {
      if ((address & 3) == 0)
	{
	  fragP->fr_subtype = 2;
	  growth = -2;
	}
    }
  else
    {
      growth = relax_frag (segment, fragP, stretch);

      /* Long jump on odd halfword boundary?  */
      if (fragP->fr_subtype == 2 && (address & 3) != 0)
	{
	  fragP->fr_subtype = 3;
	  growth += 2;
	}
    }

  return growth;
}

/* Return an initial guess of the length by which a fragment must grow to
   hold a branch to reach its destination.
   Also updates fr_type/fr_subtype as necessary.

   Called just before doing relaxation.
   Any symbol that is now undefined will not become defined.
   The guess for fr_var is ACTUALLY the growth beyond fr_fix.
   Whatever we do to grow fr_fix or fr_var contributes to our returned value.
   Although it may not be explicit in the frag, pretend fr_var starts
   with a 0 value.  */

int
md_estimate_size_before_relax (fragS *fragP, segT segment)
{
  /* The only thing we have to handle here are symbols outside of the
     current segment.  They may be undefined or in a different segment in
     which case linker scripts may place them anywhere.
     However, we can't finish the fragment here and emit the reloc as insn
     alignment requirements may move the insn about.  */
  if (S_GET_SEGMENT (fragP->fr_symbol) != segment
      || S_IS_EXTERNAL (fragP->fr_symbol)
      || S_IS_WEAK (fragP->fr_symbol))
    {
      /* The symbol is undefined in this segment.
	 Change the relaxation subtype to the max allowable and leave
	 all further handling to md_convert_frag.  */
      fragP->fr_subtype = 2;

      {
	const CGEN_INSN *insn;
	int i;

	/* Update the recorded insn.
	   Fortunately we don't have to look very far.
	   FIXME: Change this to record in the instruction the next higher
	   relaxable insn to use.  */
	for (i = 0, insn = fragP->fr_cgen.insn; i < 4; i++, insn++)
	  {
	    if ((strcmp (CGEN_INSN_MNEMONIC (insn),
			 CGEN_INSN_MNEMONIC (fragP->fr_cgen.insn))
		 == 0)
		&& CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_RELAXED))
	      break;
	  }
	if (i == 4)
	  abort ();

	fragP->fr_cgen.insn = insn;
	return 2;
      }
    }

  return md_relax_table[fragP->fr_subtype].rlx_length;
}

/* *FRAGP has been relaxed to its final size, and now needs to have
   the bytes inside it modified to conform to the new size.

   Called after relaxation is finished.
   fragP->fr_type == rs_machine_dependent.
   fragP->fr_subtype is the subtype of what the address relaxed to.  */

void
md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED,
		 segT sec,
		 fragS *fragP)
{
  char *opcode;
  char *displacement;
  int target_address;
  int opcode_address;
  int extension;
  int addend;

  opcode = fragP->fr_opcode;

  /* Address opcode resides at in file space.  */
  opcode_address = fragP->fr_address + fragP->fr_fix - 2;

  switch (fragP->fr_subtype)
    {
    case 1:
      extension = 0;
      displacement = &opcode[1];
      break;
    case 2:
      opcode[0] |= 0x80;
      extension = 2;
      displacement = &opcode[1];
      break;
    case 3:
      opcode[2] = opcode[0] | 0x80;
      md_number_to_chars (opcode, PAR_NOP_INSN, 2);
      opcode_address += 2;
      extension = 4;
      displacement = &opcode[3];
      break;
    default:
      abort ();
    }

  if (S_GET_SEGMENT (fragP->fr_symbol) != sec
      || S_IS_EXTERNAL (fragP->fr_symbol)
      || S_IS_WEAK (fragP->fr_symbol))
    {
      /* Symbol must be resolved by linker.  */
      if (fragP->fr_offset & 3)
	as_warn (_("Addend to unresolved symbol not on word boundary."));
#ifdef USE_M32R_OLD_RELOC
      addend = fragP->fr_offset >> 2; /* Old M32R used USE_REL. */
#else
      addend = 0;
#endif
    }
  else
    {
      /* Address we want to reach in file space.  */
      target_address = S_GET_VALUE (fragP->fr_symbol) + fragP->fr_offset;
      addend = (target_address - (opcode_address & -4)) >> 2;
    }

  /* Create a relocation for symbols that must be resolved by the linker.
     Otherwise output the completed insn.  */

  if (S_GET_SEGMENT (fragP->fr_symbol) != sec
      || S_IS_EXTERNAL (fragP->fr_symbol)
      || S_IS_WEAK (fragP->fr_symbol))
    {
      fixS *fixP;

      gas_assert (fragP->fr_subtype != 1);
      gas_assert (fragP->fr_cgen.insn != 0);

      fixP = gas_cgen_record_fixup (fragP,
				    /* Offset of branch insn in frag.  */
				    fragP->fr_fix + extension - 4,
				    fragP->fr_cgen.insn,
				    4 /* Length.  */,
				    /* FIXME: quick hack.  */
				    cgen_operand_lookup_by_num (gas_cgen_cpu_desc,
								M32R_OPERAND_DISP24),
				    fragP->fr_cgen.opinfo,
				    fragP->fr_symbol, fragP->fr_offset);
      if (fragP->fr_cgen.opinfo)
        fixP->fx_r_type = fragP->fr_cgen.opinfo;
    }

#define SIZE_FROM_RELAX_STATE(n) ((n) == 1 ? 1 : 3)

  md_number_to_chars (displacement, (valueT) addend,
		      SIZE_FROM_RELAX_STATE (fragP->fr_subtype));

  fragP->fr_fix += extension;
}

/* Functions concerning relocs.  */

/* The location from which a PC relative jump should be calculated,
   given a PC relative reloc.  */

long
md_pcrel_from_section (fixS *fixP, segT sec)
{
  if (fixP->fx_addsy != (symbolS *) NULL
      && (! S_IS_DEFINED (fixP->fx_addsy)
	  || S_GET_SEGMENT (fixP->fx_addsy) != sec
          || S_IS_EXTERNAL (fixP->fx_addsy)
          || S_IS_WEAK (fixP->fx_addsy)))
    {
      if (S_GET_SEGMENT (fixP->fx_addsy) != sec
          && S_IS_DEFINED (fixP->fx_addsy)
          && ! S_IS_EXTERNAL (fixP->fx_addsy)
          && ! S_IS_WEAK (fixP->fx_addsy))
        return fixP->fx_offset;

      /* The symbol is undefined (or is defined but not in this section).
	 Let the linker figure it out.  */
      return 0;
    }

  return (fixP->fx_frag->fr_address + fixP->fx_where) & -4L;
}

/* Return the bfd reloc type for OPERAND of INSN at fixup FIXP.
   Returns BFD_RELOC_NONE if no reloc type can be found.
   *FIXP may be modified if desired.  */

bfd_reloc_code_real_type
md_cgen_lookup_reloc (const CGEN_INSN *insn ATTRIBUTE_UNUSED,
		      const CGEN_OPERAND *operand,
		      fixS *fixP)
{
  switch (operand->type)
    {
    case M32R_OPERAND_DISP8:  return BFD_RELOC_M32R_10_PCREL;
    case M32R_OPERAND_DISP16: return BFD_RELOC_M32R_18_PCREL;
    case M32R_OPERAND_DISP24: return BFD_RELOC_M32R_26_PCREL;
    case M32R_OPERAND_UIMM24: return BFD_RELOC_M32R_24;
    case M32R_OPERAND_HI16:
    case M32R_OPERAND_SLO16:
    case M32R_OPERAND_ULO16:
      /* If low/high/shigh/sda was used, it is recorded in `opinfo'.  */
      if (fixP->fx_cgen.opinfo != 0)
	return fixP->fx_cgen.opinfo;
      break;
    default:
      /* Avoid -Wall warning.  */
      break;
    }
  return BFD_RELOC_NONE;
}

/* Record a HI16 reloc for later matching with its LO16 cousin.  */

static void
m32r_record_hi16 (int reloc_type,
		  fixS *fixP,
		  segT seg ATTRIBUTE_UNUSED)
{
  struct m32r_hi_fixup *hi_fixup;

  gas_assert (reloc_type == BFD_RELOC_M32R_HI16_SLO
	  || reloc_type == BFD_RELOC_M32R_HI16_ULO);

  hi_fixup = xmalloc (sizeof (* hi_fixup));
  hi_fixup->fixp = fixP;
  hi_fixup->seg  = now_seg;
  hi_fixup->next = m32r_hi_fixup_list;

  m32r_hi_fixup_list = hi_fixup;
}

/* Called while parsing an instruction to create a fixup.
   We need to check for HI16 relocs and queue them up for later sorting.  */

fixS *
m32r_cgen_record_fixup_exp (fragS *frag,
			    int where,
			    const CGEN_INSN *insn,
			    int length,
			    const CGEN_OPERAND *operand,
			    int opinfo,
			    expressionS *exp)
{
  fixS *fixP;
  bfd_reloc_code_real_type r_type = BFD_RELOC_UNUSED;

  if (m32r_check_fixup (exp, &r_type))
    as_bad (_("Invalid PIC expression."));

  fixP = gas_cgen_record_fixup_exp (frag, where, insn, length,
				    operand, opinfo, exp);

  switch (operand->type)
    {
    case M32R_OPERAND_HI16:
      /* If low/high/shigh/sda was used, it is recorded in `opinfo'.  */
      if (fixP->fx_cgen.opinfo == BFD_RELOC_M32R_HI16_SLO
	  || fixP->fx_cgen.opinfo == BFD_RELOC_M32R_HI16_ULO)
	m32r_record_hi16 (fixP->fx_cgen.opinfo, fixP, now_seg);
      break;

    default:
      /* Avoid -Wall warning.  */
      break;
    }

  switch (r_type)
    {
    case BFD_RELOC_UNUSED:
    default:
      return fixP;

    case BFD_RELOC_M32R_GOTPC24:
      if (fixP->fx_cgen.opinfo == BFD_RELOC_M32R_HI16_SLO)
        r_type = BFD_RELOC_M32R_GOTPC_HI_SLO;
      else if (fixP->fx_cgen.opinfo == BFD_RELOC_M32R_HI16_ULO)
        r_type = BFD_RELOC_M32R_GOTPC_HI_ULO;
      else if (fixP->fx_cgen.opinfo == BFD_RELOC_M32R_LO16)
        r_type = BFD_RELOC_M32R_GOTPC_LO;
      break;

    case BFD_RELOC_M32R_GOT24:
      if (fixP->fx_cgen.opinfo == BFD_RELOC_M32R_HI16_SLO)
        r_type = BFD_RELOC_M32R_GOT16_HI_SLO;
      else if (fixP->fx_cgen.opinfo == BFD_RELOC_M32R_HI16_ULO)
        r_type = BFD_RELOC_M32R_GOT16_HI_ULO;
      else if (fixP->fx_cgen.opinfo == BFD_RELOC_M32R_LO16)
        r_type = BFD_RELOC_M32R_GOT16_LO;
      break;

    case BFD_RELOC_M32R_GOTOFF:
      if (fixP->fx_cgen.opinfo == BFD_RELOC_M32R_HI16_SLO)
        r_type = BFD_RELOC_M32R_GOTOFF_HI_SLO;
      else if (fixP->fx_cgen.opinfo == BFD_RELOC_M32R_HI16_ULO)
        r_type = BFD_RELOC_M32R_GOTOFF_HI_ULO;
      else if (fixP->fx_cgen.opinfo == BFD_RELOC_M32R_LO16)
        r_type = BFD_RELOC_M32R_GOTOFF_LO;
      break;

    case BFD_RELOC_M32R_26_PLTREL:
      as_bad (_("Invalid PIC expression."));
      break;
    }

  fixP->fx_r_type = r_type;

  return fixP;
}

/* Return BFD reloc type from opinfo field in a fixS.
   It's tricky using fx_r_type in m32r_frob_file because the values
   are BFD_RELOC_UNUSED + operand number.  */
#define FX_OPINFO_R_TYPE(f) ((f)->fx_cgen.opinfo)

/* Sort any unmatched HI16 relocs so that they immediately precede
   the corresponding LO16 reloc.  This is called before md_apply_fix and
   tc_gen_reloc.  */

void
m32r_frob_file (void)
{
  struct m32r_hi_fixup *l;

  for (l = m32r_hi_fixup_list; l != NULL; l = l->next)
    {
      segment_info_type *seginfo;
      int pass;

      gas_assert (FX_OPINFO_R_TYPE (l->fixp) == BFD_RELOC_M32R_HI16_SLO
	      || FX_OPINFO_R_TYPE (l->fixp) == BFD_RELOC_M32R_HI16_ULO);

      /* Check quickly whether the next fixup happens to be a matching low.  */
      if (l->fixp->fx_next != NULL
	  && FX_OPINFO_R_TYPE (l->fixp->fx_next) == BFD_RELOC_M32R_LO16
	  && l->fixp->fx_addsy == l->fixp->fx_next->fx_addsy
	  && l->fixp->fx_offset == l->fixp->fx_next->fx_offset)
	continue;

      /* Look through the fixups for this segment for a matching `low'.
         When we find one, move the high/shigh just in front of it.  We do
         this in two passes.  In the first pass, we try to find a
         unique `low'.  In the second pass, we permit multiple high's
         relocs for a single `low'.  */
      seginfo = seg_info (l->seg);
      for (pass = 0; pass < 2; pass++)
	{
	  fixS *f;
	  fixS *prev;

	  prev = NULL;
	  for (f = seginfo->fix_root; f != NULL; f = f->fx_next)
	    {
	      /* Check whether this is a `low' fixup which matches l->fixp.  */
	      if (FX_OPINFO_R_TYPE (f) == BFD_RELOC_M32R_LO16
		  && f->fx_addsy == l->fixp->fx_addsy
		  && f->fx_offset == l->fixp->fx_offset
		  && (pass == 1
		      || prev == NULL
		      || (FX_OPINFO_R_TYPE (prev) != BFD_RELOC_M32R_HI16_SLO
			  && FX_OPINFO_R_TYPE (prev) != BFD_RELOC_M32R_HI16_ULO)
		      || prev->fx_addsy != f->fx_addsy
		      || prev->fx_offset != f->fx_offset))
		{
		  fixS **pf;

		  /* Move l->fixp before f.  */
		  for (pf = &seginfo->fix_root;
		       *pf != l->fixp;
		       pf = & (*pf)->fx_next)
		    gas_assert (*pf != NULL);

		  *pf = l->fixp->fx_next;

		  l->fixp->fx_next = f;
		  if (prev == NULL)
		    seginfo->fix_root = l->fixp;
		  else
		    prev->fx_next = l->fixp;

		  break;
		}

	      prev = f;
	    }

	  if (f != NULL)
	    break;

	  if (pass == 1
	      && warn_unmatched_high)
	    as_warn_where (l->fixp->fx_file, l->fixp->fx_line,
			   _("Unmatched high/shigh reloc"));
	}
    }
}

/* See whether we need to force a relocation into the output file.
   This is used to force out switch and PC relative relocations when
   relaxing.  */

int
m32r_force_relocation (fixS *fix)
{
  if (generic_force_reloc (fix))
    return 1;

  if (! m32r_relax)
    return 0;

  return fix->fx_pcrel;
}

/* Write a value out to the object file, using the appropriate endianness.  */

void
md_number_to_chars (char *buf, valueT val, int n)
{
  if (target_big_endian)
    number_to_chars_bigendian (buf, val, n);
  else
    number_to_chars_littleendian (buf, val, n);
}

/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */

/* Equal to MAX_PRECISION in atof-ieee.c.  */
#define MAX_LITTLENUMS 6

char *
md_atof (int type, char *litP, int *sizeP)
{
  return ieee_md_atof (type, litP, sizeP, target_big_endian);
}

void
m32r_elf_section_change_hook (void)
{
  /* If we have reached the end of a section and we have just emitted a
     16 bit insn, then emit a nop to make sure that the section ends on
     a 32 bit boundary.  */

  if (prev_insn.insn || seen_relaxable_p)
    (void) m32r_fill_insn (0);
}

/* Return true if can adjust the reloc to be relative to its section
   (such as .data) instead of relative to some symbol.  */

bfd_boolean
m32r_fix_adjustable (fixS *fixP)
{
  bfd_reloc_code_real_type reloc_type;

  if ((int) fixP->fx_r_type >= (int) BFD_RELOC_UNUSED)
    {
      const CGEN_INSN *insn = NULL;
      int opindex = (int) fixP->fx_r_type - (int) BFD_RELOC_UNUSED;
      const CGEN_OPERAND *operand =
	cgen_operand_lookup_by_num(gas_cgen_cpu_desc, opindex);

      reloc_type = md_cgen_lookup_reloc (insn, operand, fixP);
    }
  else
    reloc_type = fixP->fx_r_type;

  if (fixP->fx_addsy == NULL)
    return 1;

  /* Prevent all adjustments to global symbols.  */
  if (S_IS_EXTERNAL (fixP->fx_addsy))
    return 0;
  if (S_IS_WEAK (fixP->fx_addsy))
    return 0;

  if (pic_code
      && (reloc_type == BFD_RELOC_M32R_24
          || reloc_type == BFD_RELOC_M32R_26_PCREL
          || reloc_type == BFD_RELOC_M32R_HI16_SLO
          || reloc_type == BFD_RELOC_M32R_HI16_ULO
          || reloc_type == BFD_RELOC_M32R_LO16))
    return 0;

  if (reloc_type == BFD_RELOC_M32R_GOT24
      || reloc_type == BFD_RELOC_M32R_26_PLTREL
      || reloc_type == BFD_RELOC_M32R_GOTPC_HI_SLO
      || reloc_type == BFD_RELOC_M32R_GOTPC_HI_ULO
      || reloc_type == BFD_RELOC_M32R_GOTPC_LO
      || reloc_type == BFD_RELOC_M32R_GOT16_HI_SLO
      || reloc_type == BFD_RELOC_M32R_GOT16_HI_ULO
      || reloc_type == BFD_RELOC_M32R_GOT16_LO)
    return 0;

  /* We need the symbol name for the VTABLE entries.  */
  if (reloc_type == BFD_RELOC_VTABLE_INHERIT
      || reloc_type == BFD_RELOC_VTABLE_ENTRY)
    return 0;

  return 1;
}

void
m32r_elf_final_processing (void)
{
  if (use_parallel)
    m32r_flags |= E_M32R_HAS_PARALLEL;
  elf_elfheader (stdoutput)->e_flags |= m32r_flags;
}

/* Translate internal representation of relocation info to BFD target
   format. */

arelent *
tc_gen_reloc (asection * section, fixS * fixP)
{
  arelent * reloc;
  bfd_reloc_code_real_type code;
 
  reloc = xmalloc (sizeof (* reloc));
 
  reloc->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixP->fx_addsy);
  reloc->address = fixP->fx_frag->fr_address + fixP->fx_where;

  if (fixP->fx_pcrel)
    {
      if (fixP->fx_r_type == BFD_RELOC_32)
        fixP->fx_r_type = BFD_RELOC_32_PCREL;
      else if (fixP->fx_r_type == BFD_RELOC_16)
	{
          fixP->fx_r_type = BFD_RELOC_16_PCREL;
          bfd_set_error (bfd_error_bad_value);
	}
    }
 
  code = fixP->fx_r_type;
  if (pic_code)
    {
#ifdef DEBUG_PIC
printf("%s",bfd_get_reloc_code_name(code));
#endif
      switch (code)
        {
        case BFD_RELOC_M32R_26_PCREL:
            code = BFD_RELOC_M32R_26_PLTREL;
          break;

        case BFD_RELOC_M32R_24:
          if (fixP->fx_addsy != NULL
              && strcmp (S_GET_NAME (fixP->fx_addsy), GOT_NAME) == 0)
            code = BFD_RELOC_M32R_GOTPC24;
          else
            code = BFD_RELOC_M32R_GOT24;
          break;

        case BFD_RELOC_M32R_HI16_ULO:
          if (fixP->fx_addsy != NULL
              && strcmp (S_GET_NAME (fixP->fx_addsy), GOT_NAME) == 0)
            code = BFD_RELOC_M32R_GOTPC_HI_ULO;
          else
            code = BFD_RELOC_M32R_GOT16_HI_ULO;
          break;

        case BFD_RELOC_M32R_HI16_SLO:
          if (fixP->fx_addsy != NULL
              && strcmp (S_GET_NAME (fixP->fx_addsy), GOT_NAME) == 0)
            code = BFD_RELOC_M32R_GOTPC_HI_SLO;
          else
            code = BFD_RELOC_M32R_GOT16_HI_SLO;
          break;

        case BFD_RELOC_M32R_LO16:
          if (fixP->fx_addsy != NULL
              && strcmp (S_GET_NAME (fixP->fx_addsy), GOT_NAME) == 0)
            code = BFD_RELOC_M32R_GOTPC_LO;
          else
            code = BFD_RELOC_M32R_GOT16_LO;
          break;

        default:
          break;
        }
#ifdef DEBUG_PIC
printf(" => %s",bfd_get_reloc_code_name(code));
#endif
    }
 
  reloc->howto = bfd_reloc_type_lookup (stdoutput, code);

#ifdef DEBUG_PIC
printf(" => %s\n",reloc->howto->name);
#endif

 if (reloc->howto == (reloc_howto_type *) NULL)
    {
      as_bad_where (fixP->fx_file, fixP->fx_line,
            _("internal error: can't export reloc type %d (`%s')"),
            fixP->fx_r_type, bfd_get_reloc_code_name (code));
      return NULL;
    }
 
  /* Use fx_offset for these cases.  */
  if (   fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY
      || fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixP->fx_r_type == BFD_RELOC_32_PCREL)
    reloc->addend  = fixP->fx_offset;
  else if ((!pic_code
            && code != BFD_RELOC_M32R_26_PLTREL)
           && fixP->fx_pcrel
           && fixP->fx_addsy != NULL
           && (S_GET_SEGMENT(fixP->fx_addsy) != section)
           && S_IS_DEFINED (fixP->fx_addsy)
           && ! S_IS_EXTERNAL(fixP->fx_addsy)
           && ! S_IS_WEAK(fixP->fx_addsy))
    /* Already used fx_offset in the opcode field itseld.  */
    reloc->addend  = fixP->fx_offset;
  else
    reloc->addend  = fixP->fx_addnumber;
 
  return reloc;
}

inline static char *
m32r_end_of_match (char *cont, char *what)
{
  int len = strlen (what);

  if (strncasecmp (cont, what, strlen (what)) == 0
      && ! is_part_of_name (cont[len]))
    return cont + len;

  return NULL;
}

int
m32r_parse_name (char const *name,
		 expressionS *exprP,
		 enum expr_mode mode,
		 char *nextcharP)
{
  char *next = input_line_pointer;
  char *next_end;
  int reloc_type;
  operatorT op_type;
  segT segment;

  exprP->X_op_symbol = NULL;
  exprP->X_md = BFD_RELOC_UNUSED;

  if (strcmp (name, GOT_NAME) == 0)
    {
      if (! GOT_symbol)
	GOT_symbol = symbol_find_or_make (name);

      exprP->X_add_symbol = GOT_symbol;
    no_suffix:
      /* If we have an absolute symbol or a
	 reg, then we know its value now.  */
      segment = S_GET_SEGMENT (exprP->X_add_symbol);
      if (mode != expr_defer && segment == absolute_section)
	{
	  exprP->X_op = O_constant;
	  exprP->X_add_number = S_GET_VALUE (exprP->X_add_symbol);
	  exprP->X_add_symbol = NULL;
	}
      else if (mode != expr_defer && segment == reg_section)
	{
	  exprP->X_op = O_register;
	  exprP->X_add_number = S_GET_VALUE (exprP->X_add_symbol);
	  exprP->X_add_symbol = NULL;
	}
      else
	{
	  exprP->X_op = O_symbol;
	  exprP->X_add_number = 0;
	}

      return 1;
    }

  exprP->X_add_symbol = symbol_find_or_make (name);

  if (*nextcharP != '@@')
    goto no_suffix;
  else if ((next_end = m32r_end_of_match (next + 1, "GOTOFF")))
    {
      reloc_type = BFD_RELOC_M32R_GOTOFF;
      op_type = O_PIC_reloc;
    }
  else if ((next_end = m32r_end_of_match (next + 1, "GOT")))
    {
      reloc_type = BFD_RELOC_M32R_GOT24;
      op_type = O_PIC_reloc;
    }
  else if ((next_end = m32r_end_of_match (next + 1, "PLT")))
    {
      reloc_type = BFD_RELOC_M32R_26_PLTREL;
      op_type = O_PIC_reloc;
    }
  else
    goto no_suffix;

  *input_line_pointer = *nextcharP;
  input_line_pointer = next_end;
  *nextcharP = *input_line_pointer;
  *input_line_pointer = '\0';

  exprP->X_op = op_type;
  exprP->X_add_number = 0;
  exprP->X_md = reloc_type;

  return 1;
}

int
m32r_cgen_parse_fix_exp(int opinfo, expressionS *exp)
{
  if (exp->X_op == O_PIC_reloc
      && exp->X_md == BFD_RELOC_M32R_26_PLTREL)
    {
      exp->X_op = O_symbol;
      opinfo = exp->X_md;
    }

  return opinfo;
}
@


1.56
log
@	* config/tc-m32r.c (md_show_usage): Fix typos in descriptions.
	* config/tc-mt.c (md_assemble): Fix typos in warning messages.
	* cond.c (s_else): Fix typos in error messages.
	* config/tc-pj.c (md_assemble): Fix typo in error message.
@
text
@d3 1
a3 1
   2006, 2007, 2009 Free Software Foundation, Inc.
d726 1
a726 1
  scom_section                = bfd_com_section;
d731 1
a731 1
  scom_symbol                 = * bfd_com_section.symbol;
@


1.55
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d409 1
a409 1
                                         fo contraint violations\n"));
d413 1
a413 1
                                         contraint violations\n"));
@


1.54
log
@        PR 10437
        * config/tc-alpha.c: Fix up uses of gas printf like functions so
        that the format string is a constant string.  Add translation
        support to message strings.
        * config/tc-arc.c: Likewise.
        * config/tc-arm.c: Likewise.
        * config/tc-cris.c: Likewise.
        * config/tc-fr30.c: Likewise.
        * config/tc-frv.c: Likewise.
        * config/tc-h8300.c: Likewise.
        * config/tc-hppa.c: Likewise.
        * config/tc-i370.c: Likewise.
        * config/tc-i960.c: Likewise.
        * config/tc-ia64.c: Likewise.
        * config/tc-m32r.c: Likewise.
        * config/tc-mep.c: Likewise.
        * config/tc-mips.c: Likewise.
        * config/tc-moxie.c: Likewise.
        * config/tc-msp430.c: Likewise.
        * config/tc-openrisc.c: Likewise.
        * config/tc-pdp11.c: Likewise.
        * config/tc-pj.c: Likewise.
        * config/tc-s390.c: Likewise.
        * config/tc-sh.c: Likewise.
        * config/tc-sh64.c: Likewise.
        * config/tc-sparc.c: Likewise.
        * config/tc-spu.c: Likewise.
        * config/tc-tic30.c: Likewise.
        * config/tc-tic4x.c: Likewise.
        * config/tc-tic54x.c: Likewise.
        * config/tc-v850.c: Likewise.
        * config/tc-xc16x.c: Likewise.
        * config/tc-xstormy16.c: Likewise.
        * config/tc-z80.c: Likewise.
        * config/tc-z8k.c: Likewise.
        * config/atof-ieee.c: Add translation support to as_warn
        messages.
        * config/obj-coff.c: Likewise.
@
text
@d573 1
a573 1
  sym_linkS *link;
d592 4
a595 4
      link = (sym_linkS *) xmalloc (sizeof (sym_linkS));
      link->symbol = symbolP;
      link->next = debug_sym_link;
      debug_sym_link = link;
@


1.53
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d3 1
a3 1
   2006, 2007 Free Software Foundation, Inc.
d923 1
a923 1
      as_bad (errmsg);
d1037 1
a1037 1
      as_bad (errmsg);
d1228 1
a1228 1
      as_bad (errmsg);
@


1.52
log
@	* config/tc-m32r.c (md_begin): Mark .sbss as being bss style section.
@
text
@d1812 2
a1813 2
      assert (fragP->fr_subtype != 1);
      assert (fragP->fr_cgen.insn != 0);
d1903 1
a1903 1
  assert (reloc_type == BFD_RELOC_M32R_HI16_SLO
d2011 1
a2011 1
      assert (FX_OPINFO_R_TYPE (l->fixp) == BFD_RELOC_M32R_HI16_SLO
d2052 1
a2052 1
		    assert (*pf != NULL);
@


1.51
log
@Remove duplicate definitions of the md_atof() function
@
text
@d716 1
@


1.50
log
@Switch to GPLv3
@
text
@d2116 1
a2116 54
  int i;
  int prec;
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  char *t;

  switch (type)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;

      /* FIXME: Some targets allow other format chars for bigger sizes
         here.  */

    default:
      *sizeP = 0;
      return _("Bad call to md_atof()");
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;
  *sizeP = prec * sizeof (LITTLENUM_TYPE);

  if (target_big_endian)
    {
      for (i = 0; i < prec; i++)
	{
	  md_number_to_chars (litP, (valueT) words[i],
			      sizeof (LITTLENUM_TYPE));
	  litP += sizeof (LITTLENUM_TYPE);
	}
    }
  else
    {
      for (i = prec - 1; i >= 0; i--)
	{
	  md_number_to_chars (litP, (valueT) words[i],
			      sizeof (LITTLENUM_TYPE));
	  litP += sizeof (LITTLENUM_TYPE);
	}
    }

  return 0;
@


1.49
log
@remove some duplicate #include's.
@
text
@d3 1
a3 1
   2006 Free Software Foundation, Inc.
d9 1
a9 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.48
log
@This adjusts equate handling by
- allowing true forward references (which will always assume the referenced
  symbols have at the point of use) through the new .eqv pseudo-op and the
  new == operator
- disallowing changing .equiv-generated equates (so that the protection this
  provides is both forward and backward)
- snapshotting equates when their value gets changed so that previous uses
  don't get affected by the new value.
- allowing expressions in places where absolute expressions (or register
  names) are needed which were not completely resolvable at the point of
  their definition but which are fully resolvable at the point of use

In addition it fixes PR/288.
@
text
@d2 2
a3 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
   Free Software Foundation, Inc.
a21 1
#include <stdio.h>
@


1.47
log
@(m32r_check_fixup): Fixed X_op check.
@
text
@d2373 4
a2376 1
m32r_parse_name (char const *name, expressionS *exprP, char *nextcharP)
d2397 1
a2397 1
      if (segment == absolute_section)
d2403 1
a2403 1
      else if (segment == reg_section)
@


1.46
log
@Add support for a 32bit PC relative reloc
@
text
@d482 1
a482 1
  if (exp->X_op == O_PIC_reloc || exp->X_md != BFD_RELOC_UNUSED)
@


1.45
log
@(use_parallel): Change default value from 1 to 0.
@
text
@d2261 11
d2341 2
a2342 1
      || fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT)
@


1.44
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@d123 1
a123 1
static int use_parallel = 1;
@


1.43
log
@Update the address and phone number of the FSF
@
text
@d1998 1
a1998 1
   the corresponding LO16 reloc.  This is called before md_apply_fix3 and
@


1.42
log
@2005-04-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-aout.h (S_IS_EXTERN): Removed.
	* config/obj-bout.h (S_IS_EXTERN): Likewise.
	* config/obj-coff.h (S_IS_EXTERN): Likewise.
	* symbols.c (S_IS_EXTERN): Likewise.
	* symbols.h (S_IS_EXTERN): Likewise.

	* config/tc-alpha.c (tc_gen_reloc): Replace S_IS_EXTERN with
	S_IS_EXTERNAL.
	* config/tc-d10v.c (md_apply_fix3): Likewise.
	* config/tc-ia64.c (ia64_fix_adjustable): Likewise.
	* config/tc-iq2000.c (iq2000_fix_adjustable): Likewise.
	* config/tc-m32r.c (m32r_fix_adjustable): Likewise.
	* config/tc-mmix.c (mmix_adjust_symtab): Likewise.
	* config/tc-sh64.c (shmedia_frob_file_before_adjust): Likewise.
	(shmedia_md_convert_frag): Likewise.
	* symbols.c (print_symbol_value_1): Likewise.
	* write.c (write_object_file): Likewise.
@
text
@d19 2
a20 2
   the Free Software Foundation, 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.41
log
@Convert unmaintained files over to ISO-C90 and fix formatting.
@
text
@d2208 1
a2208 1
  if (S_IS_EXTERN (fixP->fx_addsy))
@


1.40
log
@update copyright dates
@
text
@d169 2
a170 1
struct {
a179 2
static void allow_m32rx (int);

d196 21
a218 17
#define OPTION_M32R		  (OPTION_MD_BASE)
#define OPTION_M32RX		  (OPTION_M32R + 1)
#define OPTION_M32R2		  (OPTION_M32RX + 1)
#define OPTION_BIG                (OPTION_M32R2 + 1)
#define OPTION_LITTLE             (OPTION_BIG + 1)
#define OPTION_PARALLEL           (OPTION_LITTLE + 1)
#define OPTION_NO_PARALLEL        (OPTION_PARALLEL + 1)
#define OPTION_WARN_PARALLEL	  (OPTION_NO_PARALLEL + 1)
#define OPTION_NO_WARN_PARALLEL	  (OPTION_WARN_PARALLEL + 1)
#define OPTION_IGNORE_PARALLEL    (OPTION_NO_WARN_PARALLEL + 1)
#define OPTION_NO_IGNORE_PARALLEL (OPTION_IGNORE_PARALLEL + 1)
#define OPTION_SPECIAL		  (OPTION_NO_IGNORE_PARALLEL + 1)
#define OPTION_SPECIAL_M32R       (OPTION_SPECIAL + 1)
#define OPTION_NO_SPECIAL_M32R    (OPTION_SPECIAL_M32R + 1)
#define OPTION_SPECIAL_FLOAT      (OPTION_NO_SPECIAL_M32R + 1)
#define OPTION_WARN_UNMATCHED 	  (OPTION_SPECIAL_FLOAT + 1)
#define OPTION_NO_WARN_UNMATCHED  (OPTION_WARN_UNMATCHED + 1)
a249 3
static void little (int);
static int parallel (void);

d271 1
a271 3
md_parse_option (c, arg)
     int c;
     char *arg ATTRIBUTE_UNUSED;
d372 1
a372 2
md_show_usage (stream)
     FILE *stream;
a432 5
static void fill_insn PARAMS ((int));
static void m32r_scomm PARAMS ((int));
static void debug_sym PARAMS ((int));
static void expand_debug_syms PARAMS ((sym_linkS *, int));

a436 15
/* The target specific pseudo-ops which we support.  */
const pseudo_typeS md_pseudo_table[] =
{
  { "word",	cons,		4 },
  { "fillinsn", fill_insn,	0 },
  { "scomm",	m32r_scomm,	0 },
  { "debugsym",	debug_sym,	0 },
  { "m32r",	allow_m32rx,	0 },
  { "m32rx",	allow_m32rx,	1 },
  { "m32r2",	allow_m32rx,	2 },
  { "little",   little,         1 },
  { "big",      little,         0 },
  { NULL, NULL, 0 }
};

d508 1
a508 2
m32r_handle_align (fragp)
     fragS *fragp;
d554 1
a554 2
fill_insn (ignore)
     int ignore ATTRIBUTE_UNUSED;
d568 1
a568 2
debug_sym (ignore)
     int ignore ATTRIBUTE_UNUSED;
d570 5
a574 5
  register char *name;
  register char delim;
  register char *end_name;
  register symbolS *symbolP;
  register sym_linkS *link;
d582 1
a582 3
    {
      symbolP = symbol_new (name, undefined_section, 0, &zero_address_frag);
    }
d608 1
a608 3
expand_debug_syms (syms, align)
     sym_linkS *syms;
     int align;
d630 1
a630 1
m32r_flush_pending_output()
d644 1
a644 2
m32r_fill_insn (done)
     int done;
d670 1
a670 1
m32r_target_format ()
d686 1
a686 1
md_begin ()
d728 4
a731 4
  scom_section.output_section = &scom_section;
  scom_section.symbol         = &scom_symbol;
  scom_section.symbol_ptr_ptr = &scom_section.symbol;
  scom_symbol                 = *bfd_com_section.symbol;
d733 1
a733 1
  scom_symbol.section         = &scom_section;
a749 3
static int first_writes_to_seconds_operands
  PARAMS ((m32r_insn *, m32r_insn *, const int));

d751 3
a753 4
first_writes_to_seconds_operands (a, b, check_outputs)
     m32r_insn *a;
     m32r_insn *b;
     const int check_outputs;
a825 2
static int writes_to_pc PARAMS ((m32r_insn *));

d827 1
a827 2
writes_to_pc (a)
     m32r_insn *a;
a837 2
static const char *can_make_parallel PARAMS ((m32r_insn *, m32r_insn *));

d839 1
a839 3
can_make_parallel (a, b)
     m32r_insn *a;
     m32r_insn *b;
a872 2
static void make_parallel PARAMS ((CGEN_INSN_BYTES_PTR));

d874 1
a874 2
make_parallel (buffer)
     CGEN_INSN_BYTES_PTR buffer;
a885 2
static void target_make_parallel PARAMS ((char *));

d887 1
a887 2
target_make_parallel (buffer)
     char *buffer;
a895 2
static void assemble_two_insns PARAMS ((char *, char *, int));

d897 1
a897 4
assemble_two_insns (str, str2, parallel_p)
     char *str;
     char *str2;
     int parallel_p;
d921 1
a921 1
	 (gas_cgen_cpu_desc, str, & first.fields, first.buffer, & errmsg)))
d931 1
a931 1
      as_bad (_("not a 16 bit instruction '%s'"), str);
d943 1
a943 1
      as_bad (_("instruction '%s' is for the M32R2 only"), str);
d956 1
a956 1
      as_bad (_("unknown instruction '%s'"), str);
d965 1
a965 1
      as_bad (_("instruction '%s' is for the M32RX only"), str);
d974 1
a974 1
      as_bad (_("instruction '%s' cannot be executed in parallel."), str);
d982 1
a982 1
  str3 = str;
d985 1
a985 1
  str = str2 + 2;
d993 1
a993 1
    char *s2 = str;
d1035 1
a1035 1
	 (gas_cgen_cpu_desc, str, & second.fields, second.buffer, & errmsg)))
d1045 1
a1045 1
      as_bad (_("not a 16 bit instruction '%s'"), str);
d1057 1
a1057 1
      as_bad (_("instruction '%s' is for the M32R2 only"), str);
d1070 1
a1070 1
      as_bad (_("unknown instruction '%s'"), str);
d1077 1
a1077 1
      as_bad (_("instruction '%s' is for the M32RX only"), str);
d1086 1
a1086 1
      as_bad (_("instruction '%s' cannot be executed in parallel."), str);
d1196 1
a1196 2
md_assemble (str)
     char *str;
d1443 1
a1443 2
md_operand (expressionP)
     expressionS *expressionP;
d1453 1
a1453 3
md_section_align (segment, size)
     segT segment;
     valueT size;
d1456 1
d1461 1
a1461 2
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
d1474 1
a1474 2
m32r_scomm (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1476 3
a1478 3
  register char *name;
  register char c;
  register char *p;
d1480 1
a1480 1
  register symbolS *symbolP;
d1597 15
d1644 1
a1644 4
m32r_relax_frag (segment, fragP, stretch)
     segT segment;
     fragS *fragP;
     long stretch;
d1694 1
a1694 3
md_estimate_size_before_relax (fragP, segment)
     fragS *fragP;
     segT segment;
a1700 1

d1745 3
a1747 4
md_convert_frag (abfd, sec, fragP)
     bfd *abfd ATTRIBUTE_UNUSED;
     segT sec;
     fragS *fragP;
d1843 1
a1843 3
md_pcrel_from_section (fixP, sec)
     fixS *fixP;
     segT sec;
d1870 3
a1872 4
md_cgen_lookup_reloc (insn, operand, fixP)
     const CGEN_INSN *insn ATTRIBUTE_UNUSED;
     const CGEN_OPERAND *operand;
     fixS *fixP;
a1895 2
static void m32r_record_hi16 PARAMS ((int, fixS *, segT));

d1897 3
a1899 4
m32r_record_hi16 (reloc_type, fixP, seg)
     int reloc_type;
     fixS *fixP;
     segT seg ATTRIBUTE_UNUSED;
d1906 1
a1906 2
  hi_fixup = ((struct m32r_hi_fixup *)
	      xmalloc (sizeof (struct m32r_hi_fixup)));
d1918 7
a1924 8
m32r_cgen_record_fixup_exp (frag, where, insn, length, operand, opinfo, exp)
     fragS *frag;
     int where;
     const CGEN_INSN *insn;
     int length;
     const CGEN_OPERAND *operand;
     int opinfo;
     expressionS *exp;
d1963 1
d1972 1
d1981 1
d2002 1
a2002 1
m32r_frob_file ()
d2084 1
a2084 2
m32r_force_relocation (fix)
     fixS *fix;
d2098 1
a2098 4
md_number_to_chars (buf, val, n)
     char *buf;
     valueT val;
     int n;
d2115 1
a2115 4
md_atof (type, litP, sizeP)
     char type;
     char *litP;
     int *sizeP;
d2174 1
a2174 1
m32r_elf_section_change_hook ()
d2188 1
a2188 2
m32r_fix_adjustable (fixP)
   fixS *fixP;
d2198 1
d2251 1
a2251 3
tc_gen_reloc (section, fixP)
     asection * section;
     fixS *     fixP;
d2256 1
a2256 1
  reloc = (arelent *) xmalloc (sizeof (arelent));
d2258 1
a2258 1
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
d2273 1
d2281 1
d2289 1
d2297 1
d2305 1
d2315 1
d2319 2
a2320 1
  if (reloc->howto == (reloc_howto_type *) NULL)
@


1.40.2.1
log
@(use_parallel): Change default value from 1 to 0.
@
text
@d123 1
a123 1
static int use_parallel = 0;
@


1.39
log
@	* config/atof-ieee.c, config/obj-coff.c, config/obj-elf.c,
	config/obj-ieee.c, config/obj-som.c, config/obj-vms.c,
	config/tc-a29k.c, config/tc-alpha.c, config/tc-arc.c,
	config/tc-arm.c, config/tc-d30v.c, config/tc-dlx.c,
	config/tc-fr30.c, config/tc-h8300.c, config/tc-h8500.c,
	config/tc-i370.c, config/tc-i386.c, config/tc-i960.c,
	config/tc-ia64.c, config/tc-m32r.c, config/tc-m32r.h,
	config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-mips.c,
	config/tc-mn10200.c, config/tc-msp430.c, config/tc-ns32k.c,
	config/tc-openrisc.c, config/tc-or32.c, config/tc-pdp11.c,
	config/tc-pj.c, config/tc-sparc.h, config/tc-tic54x.c,
	config/tc-tic80.c, config/tc-v850.c, config/tc-w65.c,
	config/tc-xtensa.c, config/tc-z8k.c, config/xtensa-relax.c: Remove
	#if 0'd code throughout.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
@


1.38
log
@Fixed a pcrel relocte miss between different section in the same module.
@
text
@a81 7
#if 0
/* Not supported yet.  */
/* If non-NULL, pointer to cpu description file to read.
   This allows runtime additions to the assembler.  */
static const char *m32r_cpu_desc;
#endif

a241 8

#if 0
  /* Not supported yet.  */
#define OPTION_RELAX		(OPTION_NO_WARN_UNMATCHED + 1)
#define OPTION_CPU_DESC		(OPTION_RELAX + 1)
  {"relax", no_argument, NULL, OPTION_RELAX},
  {"cpu-desc", required_argument, NULL, OPTION_CPU_DESC},
#endif
a365 10
#if 0
    /* Not supported yet.  */
    case OPTION_RELAX:
      m32r_relax = 1;
      break;
    case OPTION_CPU_DESC:
      m32r_cpu_desc = arg;
      break;
#endif

a433 7

#if 0
  fprintf (stream, _("\
  -relax                 create linker relaxable code\n"));
  fprintf (stream, _("\
  -cpu-desc              provide runtime cpu description file\n"));
#endif
a740 13
#if 0
  /* Not supported yet.  */
  /* If a runtime cpu description file was provided, parse it.  */
  if (m32r_cpu_desc != NULL)
    {
      const char *errmsg;

      errmsg = cgen_read_cpu_file (gas_cgen_cpu_desc, m32r_cpu_desc);
      if (errmsg != NULL)
	as_bad ("%s: %s", m32r_cpu_desc, errmsg);
    }
#endif

a752 5
#if 0
  /* What does this do? [see perform_an_assembly_pass]  */
  seg_info (bss_section)->bss = 1;
#endif

a866 18
#if 0
  /* Once PC operands are working....  */
  const CGEN_OPINST *a_operands == CGEN_INSN_OPERANDS (gas_cgen_cpu_desc,
						       a->insn);

  if (a_operands == NULL)
    return 0;

  while (a_operands->type != CGEN_OPINST_END)
    {
      if (a_operands->operand != NULL
	  && CGEN_OPERAND_INDEX (gas_cgen_cpu_desc,
				 a_operands->operand) == M32R_OPERAND_PC)
	return 1;

      a_operands++;
    }
#else
a869 1
#endif
a1753 4
#if 0
      int old_fr_fix = fragP->fr_fix;
#endif

a1758 20
#if 0
      /* Can't use this, but leave in for illustration.  */
      /* Change 16 bit insn to 32 bit insn.  */
      fragP->fr_opcode[0] |= 0x80;

      /* Increase known (fixed) size of fragment.  */
      fragP->fr_fix += 2;

      /* Create a relocation for it.  */
      fix_new (fragP, old_fr_fix, 4,
	       fragP->fr_symbol,
	       fragP->fr_offset, 1 /* pcrel  */,
	       /* FIXME: Can't use a real BFD reloc here.
		  gas_cgen_md_apply_fix3 can't handle it.  */
	       BFD_RELOC_M32R_26_PCREL);

      /* Mark this fragment as finished.  */
      frag_wane (fragP);
      return fragP->fr_fix - old_fr_fix;
#else
a1780 1
#endif
a1870 4
#if 0
				    cgen_operand_lookup_by_num (gas_cgen_cpu_desc,
								fragP->fr_cgen.opindex),
#else
a1872 1
#endif
@


1.37
log
@Add support for M32R GOT relocs
@
text
@d2002 6
d2497 1
a2497 1
    reloc->addend  = 0;
@


1.36
log
@Fix inifnite loop problem with M32R port
@
text
@d492 63
d1954 2
d1958 7
a1964 6
      gas_cgen_record_fixup (fragP,
			     /* Offset of branch insn in frag.  */
			     fragP->fr_fix + extension - 4,
			     fragP->fr_cgen.insn,
			     4 /* Length.  */,
			     /* FIXME: quick hack.  */
d1966 2
a1967 2
			     cgen_operand_lookup_by_num (gas_cgen_cpu_desc,
							 fragP->fr_cgen.opindex),
d1969 2
a1970 2
			     cgen_operand_lookup_by_num (gas_cgen_cpu_desc,
							 M32R_OPERAND_DISP24),
d1972 4
a1975 2
			     fragP->fr_cgen.opinfo,
			     fragP->fr_symbol, fragP->fr_offset);
d2077 8
a2084 2
  fixS *fixP = gas_cgen_record_fixup_exp (frag, where, insn, length,
					  operand, opinfo, exp);
d2094 1
d2096 36
a2131 1
      /* Avoid -Wall warning */
d2135 2
d2376 10
d2395 1
a2395 1
m32r_elf_final_processing ()
a2401 2
#define GOT_NAME "_GLOBAL_OFFSET_TABLE_"
 
d2404 1
d2478 1
a2478 1
  /* Use fx_offset for these cases */
d2482 2
a2483 1
  else if (!pic_code
d2490 1
a2490 1
    /* already used fx_offset in the opcode field itseld. */
d2497 102
@


1.35
log
@Add -no-bitinst switch for M32R2
@
text
@d1385 8
d1453 19
a1471 7
	  /* Update the addresses in any fixups.
	     Note that we don't have to handle the case where each insn is in
	     a different frag as we ensure they're in the same frag above.  */
	  for (i = 0; i < prev_insn.num_fixups; ++i)
	    prev_insn.fixups[i]->fx_where += 2;
	  for (i = 0; i < insn.num_fixups; ++i)
	    insn.fixups[i]->fx_where -= 2;
@


1.34
log
@Add support for m32r-linux target, including a RELA ABI and PIC.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d112 1
a112 1
static int enable_special_m32r = 0;
d219 2
a220 1
#define OPTION_SPECIAL_FLOAT      (OPTION_SPECIAL_M32R + 1)
d242 1
d358 4
d418 2
@


1.34.6.1
log
@(use_parallel): Change default value from 1 to 0.
@
text
@d130 1
a130 1
static int use_parallel = 0;
@


1.33
log
@Replace --error-explicit-parallel-conflicts with --ignore-parallel-conflitcs.
Add test of parallel constraint checking.
@
text
@d73 3
d200 1
a200 1
#define M32R_SHORTOPTS "O"
d368 7
d449 3
d574 3
a576 1
  if (S_IS_DEFINED (symbolP) && S_GET_SEGMENT (symbolP) != reg_section)
d1728 3
a1730 1
  if (S_GET_SEGMENT (fragP->fr_symbol) != segment)
d1836 3
a1838 1
  if (S_GET_SEGMENT (fragP->fr_symbol) != sec)
d1843 5
a1847 1
      addend = fragP->fr_offset >> 2;
d1859 3
a1861 1
  if (S_GET_SEGMENT (fragP->fr_symbol) != sec)
d1902 3
a1904 1
	  || S_GET_SEGMENT (fixP->fx_addsy) != sec))
d2219 17
d2250 96
@


1.32
log
@Add support for the M32R2 processor.
@
text
@d119 6
a124 3
/* Non-zero if the programmer should receive an error message when an
   explicit parallel instruction might have constraint violations.  */
static int error_explicit_parallel_conflicts = 1;
d203 16
a218 16
#define OPTION_M32R		 (OPTION_MD_BASE)
#define OPTION_M32RX		 (OPTION_M32R + 1)
#define OPTION_M32R2		 (OPTION_M32RX + 1)
#define OPTION_BIG               (OPTION_M32R2 + 1)
#define OPTION_LITTLE            (OPTION_BIG + 1)
#define OPTION_PARALLEL          (OPTION_LITTLE + 1)
#define OPTION_NO_PARALLEL       (OPTION_PARALLEL + 1)
#define OPTION_WARN_PARALLEL	 (OPTION_NO_PARALLEL + 1)
#define OPTION_NO_WARN_PARALLEL	 (OPTION_WARN_PARALLEL + 1)
#define OPTION_ERROR_PARALLEL    (OPTION_NO_WARN_PARALLEL + 1)
#define OPTION_NO_ERROR_PARALLEL (OPTION_ERROR_PARALLEL + 1)
#define OPTION_SPECIAL		 (OPTION_NO_ERROR_PARALLEL + 1)
#define OPTION_SPECIAL_M32R      (OPTION_SPECIAL + 1)
#define OPTION_SPECIAL_FLOAT     (OPTION_SPECIAL_M32R + 1)
#define OPTION_WARN_UNMATCHED 	 (OPTION_SPECIAL_FLOAT + 1)
#define OPTION_NO_WARN_UNMATCHED (OPTION_WARN_UNMATCHED + 1)
d232 4
a235 4
  {"error-explicit-parallel-conflicts", no_argument, NULL, OPTION_ERROR_PARALLEL},
  {"Ep", no_argument, NULL, OPTION_ERROR_PARALLEL},
  {"no-error-explicit-parallel-conflicts", no_argument, NULL, OPTION_NO_ERROR_PARALLEL},
  {"Enp", no_argument, NULL, OPTION_NO_ERROR_PARALLEL},
a323 1
      error_explicit_parallel_conflicts = 0;
a327 1
      error_explicit_parallel_conflicts = 0;
d330 2
a331 3
    case OPTION_ERROR_PARALLEL:
      warn_explicit_parallel_conflicts = 1;
      error_explicit_parallel_conflicts = 1;
d334 2
a335 3
    case OPTION_NO_ERROR_PARALLEL:
      error_explicit_parallel_conflicts = 0;
      warn_explicit_parallel_conflicts = 0;
d408 1
a408 1
                                         violate contraints\n"));
d412 1
a412 1
                                         instructions violate contraints\n"));
d418 1
a418 1
  -error-explicit-parallel-conflicts     error when parallel instructions\n"));
d420 1
a420 1
                                         violate contraints\n"));
d422 1
a422 1
  -no-error-explicit-parallel-conflicts  do not error when parallel\n"));
d424 1
a424 1
                                         instructions violate contraints\n"));
d426 1
a426 1
  -Ep                     synonym for -error-explicit-parallel-conflicts\n"));
d428 1
a428 1
  -Enp                    synonym for -no-error-explicit-parallel-conflicts\n"));
d758 3
d875 1
a875 1
    return _("Instructions write to the same destination register.");
a1158 4
      void (* func)(const char *, ...);

      func = error_explicit_parallel_conflicts ? as_bad : as_warn;

d1161 1
a1161 1
	func (_("%s: output of 1st instruction is the same as an input to 2nd instruction - is this intentional ?"), str2);
d1165 1
a1165 1
	func (_("%s: output of 2nd instruction is the same as an input to 1st instruction - is this intentional ?"), str2);
@


1.31
log
@	* config/tc-a29k.h: Fix comment typos.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-m32r.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
@
text
@d30 1
d97 5
a101 3
/* Non-zero if -m32rx has been specified, in which case support for the
   extended M32RX instruction set should be enabled.  */
static int enable_m32rx = 0;
d107 8
d119 4
d124 3
d129 3
d139 1
a139 1
const char line_separator_chars[] = "";
d170 11
a180 1
static void allow_m32rx PARAMS ((int));
d183 1
a183 2
allow_m32rx (on)
     int on;
d188 4
a191 2
    bfd_set_arch_mach (stdoutput, TARGET_ARCH,
		       enable_m32rx ? bfd_mach_m32rx : bfd_mach_m32r);
d200 15
a214 6
#define OPTION_M32R		(OPTION_MD_BASE)
#define OPTION_M32RX		(OPTION_M32R + 1)
#define OPTION_WARN_PARALLEL	(OPTION_M32RX + 1)
#define OPTION_NO_WARN_PARALLEL	(OPTION_WARN_PARALLEL + 1)
#define OPTION_SPECIAL		(OPTION_NO_WARN_PARALLEL + 1)
#define OPTION_WARN_UNMATCHED 	(OPTION_SPECIAL + 1)
d218 7
d229 4
d234 2
d254 23
d286 1
d297 22
d321 1
d326 11
d350 8
d394 11
a404 1
  -O                      try to combine instructions in parallel\n"));
d418 12
a463 1
  /* Not documented as so far there is no need for them....  */
d466 3
d473 1
a473 1
#define NOP_INSN 0x7000
d606 10
d645 18
d675 2
a676 1
					  CGEN_ENDIAN_BIG,
d887 2
a888 1
      || b_pipe == PIPE_O)
d968 17
d987 1
d1082 17
d1101 1
d1157 4
d1163 1
a1163 1
	as_warn (_("%s: output of 1st instruction is the same as an input to 2nd instruction - is this intentional ?"), str2);
d1167 1
a1167 1
	as_warn (_("%s: output of 2nd instruction is the same as an input to 1st instruction - is this intentional ?"), str2);
d1218 10
d1248 1
d1271 17
d1290 1
d1304 7
d1375 1
a1375 2
	  && enable_m32rx
	  && optimize
d2200 8
@


1.30
log
@opcodes:
	* cgen-asm.in (@@arch@@_cgen_assemble_insn): CGEN_INSN_RELAX renamed to
	CGEN_INSN_RELAXED.
	* fr30-asm.c,fr30-desc.c,fr30-desc.h: Regenerate.
	* frv-asm.c,frv-desc.c,frv-desc.h: Regenerate.
	* ip2k-asm.c,ip2k-desc.c,ip2k-desc.h: Regenerate.
	* iq2000-asm.c,iq2000-desc.c,iq2000-desc.h: Regenerate.
	* m32r-asm.c,m32r-desc.c,m32r-desc.h,m32r-opc.c: Regenerate.
	* openrisc-asm.c,openrisc-desc.c,openrisc-desc.h: Regenerate.
	* xstormy16-asm.c,xstormy16-desc.c,xstormy16-desc.h: Regenerate.
gas:
	* cgen.c (gas_cgen_finish_insn): CGEN_INSN_RELAX renamed to
	CGEN_INSN_RELAXED.
	* config/tc-fr30.c (md_estimate_size_before_relax): Ditto.
	* config/tc-m32r.c (md_estimate_size_before_relax): Ditto.
	* config/tc-openrisc.c (md_estimate_size_before_relax): Ditto.
@
text
@d765 1
a765 1
  /* Seperate the two instructions.  */
d1020 1
a1020 1
  /* Look for a parallel instruction seperator.  */
d1027 1
a1027 1
  /* Also look for a sequential instruction seperator.  */
@


1.29
log
@Change Mitsubishi to Renesas
@
text
@d1510 1
a1510 1
		&& CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_RELAX))
@


1.28
log
@	* symbols.c (S_FORCE_RELOC): Add "strict" param.
	* symbols.h (S_FORCE_RELOC): Likewise.
	* config/obj-aout.h (S_FORCE_RELOC): Likewise.
	* config/obj-bout.h (S_FORCE_RELOC): Likewise.
	* config/obj-coff.h (S_FORCE_RELOC): Likewise.
	* config/obj-ieee.h (S_FORCE_RELOC): Likewise.
	* config/obj-vms.h (S_FORCE_RELOC): Likewise.
	* write.c (generic_force_reloc): New function.
	(TC_FORCE_RELOCATION): Use it here instead of S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	(adjust_reloc_syms): Adjust S_FORCE_RELOC call.
	* as.h (generic_force_reloc): Declare.
	* doc/internals.texi (S_FORCE_RELOC): Update.
	(TC_FORCE_RELOCATION_SUB_SAME): Update.

	* config/tc-alpha.c (alpha_force_relocation): Adjust to use
	generic_force_reloc.
	(alpha_fix_adjustable): Likewise.
	* config/tc-arm.c (arm_force_relocation): Likewise.
	* config/tc-cris.c (md_cris_force_relocation): Likewise.
	* config/tc-frv.c (frv_force_relocation): Likewise.
	* config/tc-i386.c (md_apply_fix3): Likewise.
	* config/tc-ia64.c (ia64_force_relocation): Likewise.
	* config/tc-ip2k.c (ip2k_force_relocation): Likewise.
	* config/tc-m32r.c (m32r_force_relocation): Likewise.
	* config/tc-m68hc11.c (tc_m68hc11_force_relocation): Likewise.
	* config/tc-mcore.c (mcore_force_relocation): Likewise.
	* config/tc-mips.c (mips_force_relocation): Likewise.
	* config/tc-mmix.c (mmix_force_relocation): Likewise.
	* config/tc-ppc.c (ppc_force_relocation): Likewise.
	* config/tc-s390.c (tc_s390_force_relocation): Likewise.
	* config/tc-sh.c (sh_force_relocation): Likewise.
	(md_pcrel_from_section): Likewise.
	* config/tc-sparc.c (tc_gen_reloc): Likewise.
	* config/tc-v850.c (v850_force_relocation): Likewise.
	* config/tc-xstormy16.c (xstormy16_force_relocation): Likewise.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-mcore.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-sparc.h (tc_fix_adjustable): Likewise.

	* config/tc-d10v.c (d10v_force_relocation): Delete.
	* config/tc-d10v.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-dlx.c (md_dlx_force_relocation): Delete.
	* config/tc-dlx.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-fr30.c (fr30_force_relocation): Delete.
	* config/tc-fr30.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-mn10300.c (mn10300_force_relocation): Delete.
	* config/tc-mn10300.h (TC_FORCE_RELOCATION): Don't define.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-i960.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
	* config/tc-hppa.c (hppa_force_relocation): Adjust S_FORCE_RELOC call.
	* config/tc-mips.c (RELAX_BRANCH_TOOFAR): Warning fix.
	* config/tc-mips.h (TC_FORCE_RELOCATION_SUB_SAME): Don't define.
	* config/tc-openrisc.c (openrisc_force_relocation): Delete.
	* config/tc-openrisc.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sparc.c (elf32_sparc_force_relocation): Delete.
	* config/tc-sparc.h (TC_FORCE_RELOCATION): Don't define for ELF.
	* config/tc-i386.c (i386_force_relocation): Delete.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Don't define for
	BFD_ASSEMBLER.
	(EXTERN_FORCE_RELOC): Fix TE_PE and STRICT_PE_FORMAT nesting.
	* config/tc-m68k.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-pj.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sh.h (TC_FORCE_RELOCATION_SUB_ABS): Don't call
	S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-sh64.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
@
text
@d1 1
a1 1
/* tc-m32r.c -- Assembler for the Mitsubishi M32R.
@


1.28.2.1
log
@	* config/tc-m32r.c: Amend comment to refer to Renesas
@
text
@d1 1
a1 1
/* tc-m32r.c -- Assembler for the Renesas M32R.
@


1.27
log
@	* config/tc-m32r.c (md_parse_option <arg>): Add ATTRIBUTE_UNUSED.
	(fill_insn <ignore>): Likewise.
	(debug_sym <ignore>): Likewise.
	(md_undefined_symbol <name>): Likewise.
	(m32r_scomm <ignore>): Likewise.
	(md_convert_frag <abfd>): Likewise.
	(md_cgen_lookup_reloc <insn>): Likewise.
	(m32r_record_hi16 <seg>): Likewise.
	(md_estimate_size_before_relax): #if 0 old_fr_fix.
	(allow_m32rx): Prototype.
	(first_writes_to_seconds_operands): Prototype.
	(writes_to_pc): Prototype.
	(can_make_parallel): Prototype.
	(make_parallel): Prototype.
	(target_make_parallel): Prototype.
	(assemble_two_insns): Prototype.
	(m32r_record_hi16): Prototype.
	(md_atof): Remove declaration of atof_ieee.
	* config/tc-m32r.h (m32r_fix_adjustable): Declare.
	(m32r_force_relocation): Prototype.
	(m32r_elf_section_change_hook): Prototype.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002
d1821 1
a1821 3
  if (fix->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fix->fx_r_type == BFD_RELOC_VTABLE_ENTRY
      || S_FORCE_RELOC (fix->fx_addsy))
@


1.26
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d149 2
d203 1
a203 1
     char *arg;
d384 1
a384 1
     int ignore;
d399 1
a399 1
     int ignore;
d573 3
d650 2
d684 2
d722 2
d738 2
d751 2
d1234 1
a1234 1
     char *name;
d1248 1
a1248 1
     int ignore;
d1468 1
d1470 1
d1534 1
a1534 1
     bfd *abfd;
d1646 1
a1646 1
     const CGEN_INSN *insn;
d1672 2
d1678 1
a1678 1
     segT seg;
a1863 1
  char *atof_ieee ();
@


1.25
log
@gas reloc rewrite.
@
text
@d690 1
a690 1
  if (first_writes_to_seconds_operands (a, b, true))
d932 1
a932 1
      if (first_writes_to_seconds_operands (&first, &second, false))
d936 1
a936 1
      if (first_writes_to_seconds_operands (&second, &first, false))
d1066 1
a1066 1
      int swap = false;
d1114 1
a1114 1
	  && ! first_writes_to_seconds_operands (&prev_insn, &insn, false))
d1119 1
a1119 1
	    swap = true;
d1912 1
a1912 1
boolean
@


1.24
log
@Update all uses of md_apply_fix to use md_apply_fix3.  Make it a void function.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
d1803 2
a1804 1
      || fix->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
a1915 1

a1927 9

  if (fixP->fx_addsy == NULL)
    return 1;

  /* Prevent all adjustments to global symbols.  */
  if (S_IS_EXTERN (fixP->fx_addsy))
    return 0;
  if (S_IS_WEAK (fixP->fx_addsy))
    return 0;
@


1.23
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d1713 1
a1713 1
   the corresponding LO16 reloc.  This is called before md_apply_fix and
@


1.22
log
@	* config/tc-alpha.h: Fix formatting.
	* config/tc-arc.c: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ia64.h: Likewise.
	* config/tc-m32r.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-pj.h: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-sparc.h: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-w65.h: Likewise.
@
text
@a22 1
#include <ctype.h>
d24 1
d822 1
a822 1
    while (isspace (*s2++))
d827 1
a827 1
    while (isalnum (*s2))
d829 1
a829 2
	if (isupper ((unsigned char) *s2))
	  *s2 = tolower (*s2);
@


1.21
log
@	* symbols.c (S_GET_VALUE): Don't treat O_constant and local
	symbols specially.  Always resolve, adding fr_address to value.
	* write.c (write_object_file): Don't add fr_address to sym values.
	(relax_frag): Likewise.
	(relax_segment): Likewise.
	* config/obj-ieee.c (do_symbols): Likewise.
	* config/tc-cris.c (md_convert_frag): Likewise.
	* config/tc-fr30.c (md_convert_frag): Likewise.
	* config/tc-i386.c (md_convert_frag): Likewise.
	* config/tc-m32r.c (md_convert_frag): Likewise.
	* config/tc-m68hc11.c (md_convert_frag): Likewise.
	* config/tc-mcore.c (md_convert_frag): Likewise.
	* config/tc-mips.c (mips16_extended_frag): Likewise.
	* config/tc-ns32k.c (md_convert_frag): Likewise.
	* config/tc-m68k.c (md_convert_frag_1): Likewise.
	(BRANCHBWL, BRABSJUNC, BRABSJCOND, BRANCHBW, FBRANCH, DBCCLBR,
	DBCCABSJ, PCREL1632, PCINDEX, ABSTOPCREL): Decrement.
	(md_relax_table): Remove first four entries.  Format.
	(md_estimate_size_before_relax): Remove old_fix.  Don't bother
	setting fr_var.  Simplify byte branch checks.
@
text
@d558 1
a558 1
  gas_cgen_initialize_saved_fixups_array();
@


1.20
log
@2001-07-06  John Healy  <jhealy@@redhat.com>

        * cgen.c (gas_cgen_save_fixups): Modified to allow more than one
        set of fixups to be stored.
        (gas_cgen_restore_fixups): Modified to allow the fixup chain to be
        restored to be chosen from any that are saved.
        (gas_cgen_swap_fixups): Modified to allow the current set of
        fixups to be swapped with any other set that has been saved.
        (gas_cgen_initialize_saved_fixups_array): New routine.
        * cgen.h: Modifed prototypes for gas_cgen_save_fixups,
        gas_cgen_restore_fixups, and gas_cgen_swap_fixups.  Added definitions
        or MAX_SAVED_FIXUP_CHAINS.
        * config/tc-m32r.c (assemble_two_insns): Changed calls to fixup
        store, swap and restore fuctions to reflect the new interface.
@
text
@a1566 1
      target_address += symbol_get_frag (fragP->fr_symbol)->fr_address;
@


1.19
log
@Fix more fallout from multi-pass relaxation patch.
@
text
@d557 2
d837 1
a837 1
  gas_cgen_save_fixups ();
d946 1
a946 1
      gas_cgen_swap_fixups ();
d958 1
a958 1
      gas_cgen_restore_fixups ();
d977 1
a977 1
      gas_cgen_restore_fixups ();
@


1.18
log
@Fix copyright notices
@
text
@a1443 2
  int old_fr_fix = fragP->fr_fix;

d1452 2
d1477 1
d1504 1
a1504 1
  return (fragP->fr_var + fragP->fr_fix - old_fr_fix);
@


1.17
log
@2001-03-02  Dave Brolley  <brolley@@redhat.com>

	* config/tc-m32r.c (expand_debug_syms): Call frag_align_code rather than
	m32r_do_align.
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 1998, 1999, 2000
@


1.16
log
@	* write.c (is_dnrange): Stop as soon as the address becomes
	larger.
	(relax_frag): Add segment parameter.  Only call symbol_get_frag
	once.  Only call is_dnrange if the symbol is in the same segment,
	and the symbol address is larger.
	(relax_segment): Pass segment to md_relax_frag and relax_frag.
	* write.h (relax_frag): Update declaration.
	* config/tc-fr30.c (fr30_relax_frag): Add segment parameter.  Pass
	it to relax_frag.
	* config/tc-m32r.c (m32r_relax_frag): Likewise.
	* config/tc-m32r.h (md_relax_frag): Add segment parameter.
	(m32r_relax_frag): Update declaration.
	* config/tc-mips.h (md_relax_frag): Add segment parameter.
	* config/tc-tic54x.h (md_relax_frag): Likewise.
	* doc/internals.texi (CPU backend): Update documentation for
	md_relax_frag.
@
text
@d447 1
a447 1
  (void) m32r_do_align (align, NULL, 0, 0);
@


1.15
log
@(m32r_handle_align): Declare type of fragp.
@
text
@d1387 2
a1388 1
m32r_relax_frag (fragP, stretch)
d1415 1
a1415 1
      growth = relax_frag (fragP, stretch);
@


1.15.2.1
log
@Fix by Dave Brolley  <brolley@@redhat.com> from the mainline:
	* config/tc-m32r.c (expand_debug_syms): Call frag_align_code rather
	than m32r_do_align.
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001
d447 1
a447 1
  (void) frag_align_code (align, 0);
@


1.15.2.2
log
@Merge from mainline.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
d1387 1
a1387 2
m32r_relax_frag (segment, fragP, stretch)
     segT segment;
d1414 1
a1414 1
      growth = relax_frag (segment, fragP, stretch);
@


1.15.2.3
log
@Merge from mainline.
@
text
@d1444 2
a1453 2
      int old_fr_fix = fragP->fr_fix;

a1476 1
      return fragP->fr_fix - old_fr_fix;
d1503 1
a1503 1
  return md_relax_table[fragP->fr_subtype].rlx_length;
@


1.14
log
@	* as.h (rs_align_test): New.
	* frags.c (NOP_OPCODE): Move default from read.c.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New default.
	(frag_align_code): New.
	* frags.h (frag_align_code): Declare.
	* read.c (NOP_OPCODE): Remove.
	(do_align): Use frag_align_code.
	* write.c (NOP_OPCODE): Remove.
	(get_recorded_alignment): New.
	(cvt_frag_to_fill): Handle rs_align_test.
	(relax_segment): Likewise.
	(subsegs_finish): Align last subseg in section to the
	section alignment.  Use frag_align_code.
	* write.h (get_recorded_alignment): Declare.
	* config/obj-coff.c (size_section): Handle rs_align_test.
	(fill_section, fixup_mdeps): Likewise.
	(write_object_file): Use frag_align_code.

	* config/tc-alpha.c (alpha_align): Use frag_align_code.
	(alpha_handle_align): New.
	* config/tc-alpha.h (HANDLE_ALIGN): New.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-i386.h (md_do_align): Use frag_align_code.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-ia64.c (ia64_md_do_align): Don't do code alignment.
	(ia64_handle_align): New.
	* config/tc-ia64.h (HANDLE_ALIGN): New.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-m32r.c (m32r_do_align): Remove.
	(m32r_handle_align): New.
	(fill_insn): Use frag_align_code.
	* config/tc-m32r.h (md_do_align): Remove.
	(HANDLE_ALIGN, MAX_MEM_FOR_RS_ALIGN_CODE): New.
	* config/tc-m88k.c, config/tc-m88k.h: Similarly.
	* config/tc-mips.c, config/tc-mips.h: Similarly.

	* config/tc-sh.c (sh_cons_align): Use rs_align_test.
	(sh_handle_align): Likewise.  Handle rs_align_code.
	(sh_do_align): Remove.
	* config/tc-sh.h (md_do_align): Remove.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-sparc.c (sparc_cons_align): Use rs_align_test.
	(sparc_handle_align): Likewise.  Handle rs_align_code.
	* config/tc-sparc.h (md_do_align): Remove.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.
@
text
@d335 1
@


1.13
log
@2000-09-20  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-m32r.c: Fix formatting.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68851.h: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-mips.h: Likewise.
	* config/tc-mn10200.h: Likewise.
	* config/tc-mn10300.h: Likewise.
@
text
@d330 5
a334 11
/* When we align the .text section, insert the correct NOP pattern.
   N is the power of 2 alignment.  LEN is the length of pattern FILL.
   MAX is the maximum number of characters to skip when doing the alignment,
   or 0 if there is no maximum.  */

int
m32r_do_align (n, fill, len, max)
     int n;
     const char *fill;
     int len;
     int max;
d336 14
a349 9
  /* Only do this if the fill pattern wasn't specified.  */
  if (fill == NULL
      && subseg_text_p (now_seg)
      /* Only do this special handling if aligning to at least a
	 4 byte boundary.  */
      && n > 1
     /* Only do this special handling if we're allowed to emit at
	 least two bytes.  */
      && (max == 0 || max > 1))
d351 4
a354 1
      static const unsigned char nop_pattern[] = { 0xf0, 0x00 };
d356 7
a362 18
#if 0
      /* First align to a 2 byte boundary, in case there is an odd .byte.  */
      /* FIXME: How much memory will cause gas to use when assembling a big
	 program?  Perhaps we can avoid the frag_align call?  */
      frag_align (1, 0, 0);
#endif
      /* Next align to a 4 byte boundary (we know n >= 2) using a parallel
	 nop.  */
      frag_align_pattern (2, nop_pattern, sizeof nop_pattern, 0);
      /* If doing larger alignments use a repeating sequence of appropriate
	 nops.  */
      if (n > 2)
	{
	  static const unsigned char multi_nop_pattern[] =
	  { 0x70, 0x00, 0xf0, 0x00 };
	  frag_align_pattern (n, multi_nop_pattern, sizeof multi_nop_pattern,
			      max ? max - 2 : 0);
	}
d364 1
a364 3
      prev_insn.insn = NULL;
      return 1;
    }
d366 2
a367 1
  return 0;
d383 1
a383 1
  (void) m32r_do_align (2, NULL, 0, 0);
@


1.12
log
@2000-08-04  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-cris.c: Rearrange code for readability.
	* config/tc-d10v.c: Fix formatting.
	* config/tc-m32r.c: Likewise.
	* config/tc-sparc.c: Likewise.
@
text
@d131 1
a131 1
   corresponding LO relocation. */
@


1.11
log
@Applied Stephane Carrez <Stephane.Carrez@@worldnet.fr> patches to add support
for m68hc11 and m68hc12 processors.
@
text
@d2 2
a3 1
   Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation.
d25 1
a25 1
#include "subsegs.h"     
d36 1
a36 1
  symbolS	  *symbol;
d39 2
a40 2
static sym_linkS *debug_sym_link = (sym_linkS *)0;
  
d45 3
a47 3
  const CGEN_INSN *	insn;
  const CGEN_INSN *	orig_insn;
  CGEN_FIELDS		fields;
d49 1
a49 1
  CGEN_INSN_INT         buffer [1];
d52 1
a52 1
  unsigned char         buffer [CGEN_MAX_INSN_SIZE];
d55 6
a60 6
  char *		addr;
  fragS *		frag;
  int                   num_fixups;
  fixS *                fixups [GAS_CGEN_MAX_FIXUPS];
  int                   indices [MAX_OPERAND_INSTANCES];
  sym_linkS		*debug_sym_link;
d66 1
a66 1
static m32r_insn	prev_insn;
d78 2
a79 1
#if 0 /* not supported yet */
d82 1
a82 1
static const char * m32r_cpu_desc;
d111 1
a111 1
/* stuff for .scomm symbols.  */
d135 5
a139 3
  struct m32r_hi_fixup * next;  /* Next HI fixup.  */
  fixS *                 fixp;  /* This fixup.  */
  segT                   seg;   /* The section this fixup is in.  */
d141 2
d147 1
a147 2
static struct m32r_hi_fixup * m32r_hi_fixup_list;

d161 2
a162 1
const char * md_shortopts = M32R_SHORTOPTS;
d186 2
a187 1
#if 0 /* not supported yet */
d195 1
d200 2
a201 2
     int    c;
     char * arg;
d212 1
a212 1
      
d216 1
a216 1
      
d220 1
a220 1
      
d243 3
a245 2
      
#if 0 /* not supported yet */
d257 1
a257 1
  
d263 1
a263 1
  FILE * stream;
d302 1
a302 1
} 
d320 1
a320 1
  /* Not documented as so far there is no need for them.... */  
d328 1
a328 1
#define PAR_NOP_INSN 0xf000 /* can only be used in 2nd slot */
d337 4
a340 4
     int          n;
     const char * fill;
     int          len;
     int          max;
d372 1
a372 1
      
d417 1
a417 1
 
d457 1
a457 1
  for (; syms != (sym_linkS *)0; syms = next_syms)
d463 1
a463 1
      free ((char *)syms);
d479 1
a479 1
      segT    seg    = now_seg;
d483 1
a483 1
      
d492 1
a492 1
      debug_sym_link = (sym_linkS *)0;
d502 2
a503 2
  segT     seg;
  subsegT  subseg;
d506 1
a506 1
  
d522 2
a523 1
#if 0 /* not supported yet */
d527 1
a527 1
      const char * errmsg;
d542 1
a542 1
  
d546 3
a548 2
  
#if 0 /* What does this do? [see perform_an_assembly_pass]  */
d558 4
a561 4
  scom_section.output_section = & scom_section;
  scom_section.symbol         = & scom_symbol;
  scom_section.symbol_ptr_ptr = & scom_section.symbol;
  scom_symbol                 = * bfd_com_section.symbol;
d563 1
a563 1
  scom_symbol.section         = & scom_section;
d580 3
a582 3
     m32r_insn * a;
     m32r_insn * b;
     const int   check_outputs;
d584 2
a585 2
  const CGEN_OPINST * a_operands = CGEN_INSN_OPERANDS (a->insn);
  const CGEN_OPINST * b_ops = CGEN_INSN_OPERANDS (b->insn);
d593 1
a593 1
      
d602 1
a602 1
	  const CGEN_OPINST * b_operands = b_ops;
d608 2
a609 2
	     than by cgen.... */
	  
d616 1
a616 1
		   b_index ++, b_operands ++)
d633 1
a633 1
		   b_index ++, b_operands ++)
d640 1
a640 1
		      && (a->indices [a_index] == b->indices [b_index]))
d654 1
a654 1
     m32r_insn * a;
d656 4
a659 3
#if 0  /* Once PC operands are working.... */
  const CGEN_OPINST * a_operands == CGEN_INSN_OPERANDS (gas_cgen_cpu_desc,
							a->insn);
d667 2
a668 1
	  && CGEN_OPERAND_INDEX (gas_cgen_cpu_desc, a_operands->operand) == M32R_OPERAND_PC)
d670 2
a671 2
      
      a_operands ++;
d681 2
a682 2
/* Returns NULL if the two 16 bit insns can be executed in parallel,
   otherwise it returns a pointer to an error message explaining why not.  */
d686 2
a687 2
     m32r_insn * a;
     m32r_insn * b;
d691 1
a691 1
  
d693 3
a695 3
  if (   CGEN_FIELDS_BITSIZE (& a->fields) != 16
      || CGEN_FIELDS_BITSIZE (& b->fields) != 16)
    abort();
d699 1
a699 1
  
d704 1
a704 1
  if (   a_pipe == PIPE_NONE
d711 1
a711 1
  if (   a_pipe == PIPE_S
d714 1
a714 1
  
d727 1
a727 1
  buffer [CGEN_CPU_ENDIAN (gas_cgen_cpu_desc) == CGEN_ENDIAN_BIG ? 0 : 1]
d738 1
a738 1
  buffer [CGEN_CPU_ENDIAN (gas_cgen_cpu_desc) == CGEN_ENDIAN_BIG ? 0 : 1]
d747 3
a749 3
     char * str;
     char * str2;
     int    parallel_p;
d751 1
a751 1
  char *    str3;
d754 2
a755 2
  char *    errmsg;
  char      save_str2 = *str2;
d757 2
a758 1
  * str2 = 0; /* Seperate the two instructions.  */
d769 1
a769 1
  debug_sym_link = (sym_linkS *)0;
d782 1
a782 1
      /* xgettext:c-format */
d789 1
a789 1
      /* xgettext:c-format */
d794 3
a796 2
      /* FIXME: Need standard macro to perform this test.  */
      && CGEN_INSN_ATTR_VALUE (first.insn, CGEN_INSN_MACH) == (1 << MACH_M32RX))
d798 1
a798 1
      /* xgettext:c-format */
d802 1
a802 1
    
d804 2
a805 1
  if (parallel_p && CGEN_INSN_ATTR_VALUE (first.insn, CGEN_INSN_PIPE) == PIPE_NONE)
d807 1
a807 1
      /* xgettext:c-format */
d811 13
a823 5
  
  *str2 = save_str2; /* Restore the original assembly text, just in case it is needed.  */
  str3  = str;       /* Save the original string pointer.  */
  str   = str2 + 2;  /* Advanced past the parsed string.  */
  str2  = str3;      /* Remember the entire string in case it is needed for error messages.  */
d828 2
a829 2
    
    while (isspace (*s2 ++))
d838 1
a838 1
	s2 ++;
d841 3
a843 2
  
  /* Preserve any fixups that have been generated and reset the list to empty.  */
d862 1
a862 1
  
d879 1
a879 1
      /* xgettext:c-format */
d886 1
a886 1
      /* xgettext:c-format */
d893 1
a893 1
      /* xgettext:c-format */
d899 2
a900 1
  if (parallel_p && CGEN_INSN_ATTR_VALUE (second.insn, CGEN_INSN_PIPE) == PIPE_NONE)
d902 1
a902 1
      /* xgettext:c-format */
d906 1
a906 1
  
d912 1
a912 1
	  /* xgettext:c-format */
d926 1
a926 1
  
d937 1
a937 1
  
d940 2
a941 2
      if (first_writes_to_seconds_operands (& first, & second, false))
	/* xgettext:c-format */
d943 3
a945 3
      
      if (first_writes_to_seconds_operands (& second, & first, false))
	/* xgettext:c-format */
d948 1
a948 1
      
d950 1
a950 1
      || (errmsg = (char *) can_make_parallel (& first, & second)) == NULL)
d958 2
a959 2
			    CGEN_FIELDS_BITSIZE (& first.fields), 0, NULL);
      
d970 1
a970 1
			    CGEN_FIELDS_BITSIZE (& second.fields), 0, NULL);
d973 1
a973 1
  else if (can_make_parallel (& second, & first) == NULL)
d978 2
a979 2
			    CGEN_FIELDS_BITSIZE (& second.fields), 0, NULL);
      
d989 1
a989 1
			    CGEN_FIELDS_BITSIZE (& first.fields), 0, NULL);
d996 1
a996 1
      
d1004 1
a1004 1
     char * str;
d1007 2
a1008 2
  char *    errmsg;
  char *    str2 = NULL;
d1026 1
a1026 1
  
d1028 1
a1028 1
  debug_sym_link = (sym_linkS *)0;
d1031 2
a1032 2
    (gas_cgen_cpu_desc, str, & insn.fields, insn.buffer, & errmsg);
  
d1042 1
a1042 1
      /* xgettext:c-format */
d1049 1
a1049 1
      /* xgettext:c-format */
d1053 1
a1053 1
  
d1069 1
a1069 1
			    CGEN_FIELDS_BITSIZE (& insn.fields), 1, NULL);
d1077 1
a1077 1
	abort();
d1087 1
a1087 1
      
d1098 1
a1098 1
	  
d1117 6
a1122 7
      if (     ! on_32bit_boundary_p
	  &&   enable_m32rx
	  &&   optimize
	  &&   CGEN_INSN_ATTR_VALUE (insn.orig_insn, CGEN_INSN_RELAXABLE) == 0
	  && ! writes_to_pc (& prev_insn)
	  && ! first_writes_to_seconds_operands (& prev_insn, &insn, false)
	  )
d1124 1
a1124 1
	  if (can_make_parallel (& prev_insn, & insn) == NULL)
d1126 1
a1126 1
	  else if (can_make_parallel (& insn, & prev_insn) == NULL)
d1140 2
a1141 2
			      CGEN_FIELDS_BITSIZE (& insn.fields),
			      1 /*relax_p*/, &fi);
d1151 1
a1151 1
	  int i,tmp;
d1156 2
a1157 2
	  SWAP_BYTES (prev_insn.addr [0], insn.addr [0]);
	  SWAP_BYTES (prev_insn.addr [1], insn.addr [1]);
d1183 1
a1183 1
      
d1205 1
a1205 1
void 
d1207 1
a1207 1
     expressionS * expressionP;
d1209 1
a1209 1
  if (* input_line_pointer == '#')
d1211 1
a1211 1
      input_line_pointer ++;
d1218 1
a1218 1
     segT   segment;
d1227 1
a1227 1
  char * name;
d1235 3
a1237 3
   By doing this the linker won't need to do any work and more importantly
   it removes the implicit -G arg necessary to correctly link the object file.
*/
d1243 7
a1249 7
  register char *    name;
  register char      c;
  register char *    p;
  offsetT            size;
  register symbolS * symbolP;
  offsetT            align;
  int                align2;
d1254 1
a1254 1
  /* just after name is now '\0' */
d1256 1
a1256 1
  * p = c;
d1258 1
a1258 1
  if (* input_line_pointer != ',')
d1265 2
a1266 1
  input_line_pointer ++;		/* skip ',' */
d1269 1
a1269 1
      /* xgettext:c-format */
d1276 1
a1276 1
  if (* input_line_pointer != ',')
d1280 1
a1280 1
      ++ input_line_pointer;
d1288 1
d1292 1
a1292 1
      for (align2 = 0; (align & 1) == 0; align >>= 1, ++ align2)
d1304 1
a1304 1
  * p = 0;
d1306 1
a1306 1
  * p = c;
d1310 1
a1310 1
      /* xgettext:c-format */
d1319 1
a1319 1
      /* xgettext:c-format */
d1331 3
a1333 3
      segT   old_sec    = now_seg;
      int    old_subsec = now_subseg;
      char * pfrag;
d1337 1
a1337 1
      
d1340 1
a1340 1
      
d1343 1
a1343 1
      
d1345 1
a1345 1
      
d1348 1
a1348 1
      * pfrag = 0;
d1359 1
a1359 1
      S_SET_SEGMENT (symbolP, & scom_section);
d1397 2
a1398 2
     fragS * fragP;
     long    stretch;
d1444 2
a1445 2
   Although it may not be explicit in the frag, pretend fr_var starts with a
   0 value.  */
d1449 2
a1450 2
     fragS * fragP;
     segT    segment;
d1452 1
a1452 1
  int    old_fr_fix = fragP->fr_fix;
d1467 2
a1468 1
#if 0 /* Can't use this, but leave in for illustration.  */     
d1478 1
a1478 1
	       fragP->fr_offset, 1 /* pcrel */,
d1487 2
a1488 2
	const CGEN_INSN * insn;
	int               i;
d1512 1
a1512 1
} 
d1514 1
a1514 1
/* *fragP has been relaxed to its final size, and now needs to have
d1523 10
a1532 10
  bfd *   abfd;
  segT    sec;
  fragS * fragP;
{
  char * opcode;
  char * displacement;
  int    target_address;
  int    opcode_address;
  int    extension;
  int    addend;
d1541 1
a1541 1
    case 1 :
d1543 1
a1543 1
      displacement = & opcode[1];
d1545 1
a1545 1
    case 2 :
d1548 1
a1548 1
      displacement = & opcode[1];
d1550 1
a1550 1
    case 3 :
d1555 1
a1555 1
      displacement = & opcode[3];
d1557 1
a1557 1
    default :
d1563 1
a1563 1
      /* symbol must be resolved by linker */
d1587 2
a1588 2
			     4 /*length*/,
			     /* FIXME: quick hack */
d1615 2
a1616 2
     fixS * fixP;
     segT   sec;
d1636 3
a1638 3
     const CGEN_INSN *    insn;
     const CGEN_OPERAND * operand;
     fixS *               fixP;
d1642 7
a1648 7
    case M32R_OPERAND_DISP8 : return  BFD_RELOC_M32R_10_PCREL;
    case M32R_OPERAND_DISP16 : return BFD_RELOC_M32R_18_PCREL;
    case M32R_OPERAND_DISP24 : return BFD_RELOC_M32R_26_PCREL;
    case M32R_OPERAND_UIMM24 : return BFD_RELOC_M32R_24;
    case M32R_OPERAND_HI16 :
    case M32R_OPERAND_SLO16 :
    case M32R_OPERAND_ULO16 :
d1653 2
a1654 1
    default : /* avoid -Wall warning */
d1664 3
a1666 3
     int    reloc_type;
     fixS * fixP;
     segT   seg;
d1668 1
a1668 1
  struct m32r_hi_fixup * hi_fixup;
d1678 1
a1678 1
  
d1687 7
a1693 7
     fragS *              frag;
     int                  where;
     const CGEN_INSN *    insn;
     int                  length;
     const CGEN_OPERAND * operand;
     int                  opinfo;
     expressionS *        exp;
d1695 2
a1696 2
  fixS * fixP = gas_cgen_record_fixup_exp (frag, where, insn, length,
					   operand, opinfo, exp);
d1700 1
a1700 1
    case M32R_OPERAND_HI16 :
d1706 2
a1707 1
    default : /* avoid -Wall warning */
d1726 1
a1726 1
  struct m32r_hi_fixup * l;
d1730 2
a1731 2
      segment_info_type * seginfo;
      int                 pass;
d1751 2
a1752 2
	  fixS * f;
	  fixS * prev;
d1766 1
a1766 1
		      || prev->fx_offset !=  f->fx_offset))
d1768 1
a1768 1
		  fixS ** pf;
d1772 3
a1774 3
		       * pf != l->fixp;
		       pf = & (* pf)->fx_next)
		    assert (* pf != NULL);
d1776 1
a1776 1
		  * pf = l->fixp->fx_next;
d1807 1
a1807 1
     fixS * fix;
d1816 1
a1816 2
  return (fix->fx_pcrel
	  || 0 /* ??? */);
d1823 1
a1823 1
     char * buf;
d1825 1
a1825 1
     int    n;
d1833 4
a1836 4
/* Turn a string in input_line_pointer into a floating point constant of type
   type, and store the appropriate bytes in *litP.  The number of LITTLENUMS
   emitted is stored in *sizeP .  An error message is returned, or NULL on OK.
*/
d1838 1
a1838 1
/* Equal to MAX_PRECISION in atof-ieee.c */
d1847 5
a1851 5
  int              i;
  int              prec;
  LITTLENUM_TYPE   words [MAX_LITTLENUMS];
  char *           t;
  char *           atof_ieee ();
d1869 2
a1870 1
   /* FIXME: Some targets allow other format chars for bigger sizes here.  */
d1873 1
a1873 1
      * sizeP = 0;
d1880 1
a1880 1
  * sizeP = prec * sizeof (LITTLENUM_TYPE);
d1900 1
a1900 1
     
d1910 1
a1910 1
  
d1916 1
a1916 1
   (such as .data) instead of relative to some symbol. */
d1924 1
a1924 1
 
d1929 2
a1930 1
      const CGEN_OPERAND *operand = cgen_operand_lookup_by_num(gas_cgen_cpu_desc, opindex);
d1939 1
a1939 1
  /* Prevent all adjustments to global symbols. */
d1945 1
a1945 1
  /* We need the symbol name for the VTABLE entries */
@


1.10
log
@        * config/tc-m32r.c (m32r_fix_adjustable):  Look up the
        relocation type based on the entry in the fixup structure.
@
text
@d1885 3
d1907 1
a1907 1
  
d1913 1
a1913 1
  
@


1.9
log
@Document new -m32r command line switch
@
text
@d1890 12
d1912 2
a1913 2
  if (fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
@


1.8
log
@treat -m32r as a seperate, specific command line switch.
@
text
@d259 2
@


1.7
log
@	Add support for m32rx.
	* config/tc-m32r.c (enable_m32rx): New static global.
	(enable_special,warn_explicit_parallel_conflicts,optimize): Ditto.
	(allow_m32rx): New function.
	(M32R_SHORTOPTS): Add `O'.
	(md_longopts): Add --m32rx plus several warning options.
	(md_parse_option): Handle new options.
	(md_show_usage): Print them.
	(md_begin): Enable m32rx.
	(OPERAND_IS_COND_BIT): New macro.
	(first_writes_to_seconds_operands): New function.
	(writes_to_pc,can_make_parallel,make_parallel): New functions.
	(target_make_parallel,assemble_two_insns): New functions.
	(md_assemble): Recognize "insn1 -> insn2" and "insn1 || insn2".
	If optimizing and m32rx, try to make consecutive insns parallel.
@
text
@d160 8
a167 1
#define OPTION_M32RX	(OPTION_MD_BASE)
a168 1
#define OPTION_WARN_PARALLEL	(OPTION_MD_BASE + 1)
a170 1
#define OPTION_NO_WARN_PARALLEL	(OPTION_MD_BASE + 2)
a172 1
#define OPTION_SPECIAL	(OPTION_MD_BASE + 3)
a173 1

a174 1
#define OPTION_WARN_UNMATCHED (OPTION_MD_BASE + 4)
a176 1
#define OPTION_NO_WARN_UNMATCHED (OPTION_MD_BASE + 5)
d181 2
a182 1
#define OPTION_RELAX  (OPTION_MD_BASE + 6)
a183 1
#define OPTION_CPU_DESC (OPTION_MD_BASE + 7)
d201 4
@


1.6
log
@Fix value for -Wnuh command line option
@
text
@d94 14
d144 10
d155 1
a155 1
#define M32R_SHORTOPTS ""
d160 10
d196 26
d253 17
d304 3
d547 149
d698 254
d953 15
d980 13
d1006 14
d1041 1
d1048 22
d1074 23
d1117 27
@


1.5
log
@	* config/tc-m32r.c (md_parse_option): Delete unrecognized option
	error message (done elsewhere).
@
text
@d142 2
a143 2
  {"no-warn-unmatched-high", no_argument, NULL, OPTION_WARN_UNMATCHED},
  {"Wnuh", no_argument, NULL, OPTION_WARN_UNMATCHED},
a150 1

d183 1
@


1.4
log
@Fix -Wuh and -Wnhu options so that they work.
@
text
@a181 4
      if (arg)
	fprintf (stderr, _("%s: unrecognised command line option: -%c\n"), myname, c);
      else
	fprintf (stderr, _("%s: unrecognised command line option: -%c%s\n"), myname, c, arg);
@


1.3
log
@	* subsegs.c (subseg_text_p): New function.
	* as.h (subseg_text_p): Declare.
	* read.c (do_align): Use subseg_text_p to set the default fill.
	* write.c (subsegs_finish): Likewise.
	* config/obj-coff.c (write_object_file): Likewise.
	* config/tc-i386.h (md_maybe_text): Don't define.
	(md_do_align): Use subseg_text_p to set the default fill.
	* config/tc-m32r.c (m32r_do_align): Likewise.
	* config/tc-sh.c (sh_do_align): Likewise.
	* config/tc-sparc.h (md_do_align): Likewise.
@
text
@d139 2
a140 2
  {"warn-unmatched-high", OPTION_WARN_UNMATCHED},
  {"Wuh", OPTION_WARN_UNMATCHED},
d142 2
a143 2
  {"no-warn-unmatched-high", OPTION_WARN_UNMATCHED},
  {"Wnuh", OPTION_WARN_UNMATCHED},
d182 4
@


1.2
log
@	* config/tc-m32r.c: Update for symbol handling changes.
@
text
@d248 1
a248 1
      && (now_seg->flags & SEC_CODE) != 0
@


1.1
log
@Initial revision
@
text
@d339 1
a339 1
      symbolP->local = 1;
d697 1
a697 1
  if (symbolP->local)
d710 1
a710 1
	symbolP->sy_frag->fr_symbol = 0;
d712 1
a712 1
      symbolP->sy_frag = frag_now;
d939 1
a939 1
      target_address += fragP->fr_symbol->sy_frag->fr_address;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

