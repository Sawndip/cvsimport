head	1.36;
access;
symbols
	binutils-2_24-branch:1.36.0.4
	binutils-2_24-branchpoint:1.36
	binutils-2_21_1:1.35
	binutils-2_23_2:1.36
	binutils-2_23_1:1.36
	binutils-2_23:1.36
	binutils-2_23-branch:1.36.0.2
	binutils-2_23-branchpoint:1.36
	binutils-2_22_branch:1.35.0.6
	binutils-2_22:1.35
	binutils-2_22-branch:1.35.0.4
	binutils-2_22-branchpoint:1.35
	binutils-2_21:1.35
	binutils-2_21-branch:1.35.0.2
	binutils-2_21-branchpoint:1.35
	binutils-2_20_1:1.33
	binutils-2_20:1.33
	binutils-arc-20081103-branch:1.31.0.8
	binutils-arc-20081103-branchpoint:1.31
	binutils-2_20-branch:1.33.0.2
	binutils-2_20-branchpoint:1.33
	dje-cgen-play1-branch:1.31.0.6
	dje-cgen-play1-branchpoint:1.31
	arc-20081103-branch:1.31.0.4
	arc-20081103-branchpoint:1.31
	binutils-2_19_1:1.31
	binutils-2_19:1.31
	binutils-2_19-branch:1.31.0.2
	binutils-2_19-branchpoint:1.31
	binutils-2_18:1.28
	binutils-2_18-branch:1.28.0.2
	binutils-2_18-branchpoint:1.28
	binutils-csl-coldfire-4_1-32:1.25
	binutils-csl-sourcerygxx-4_1-32:1.25
	binutils-csl-innovasic-fido-3_4_4-33:1.25
	binutils-csl-sourcerygxx-3_4_4-32:1.20
	binutils-csl-coldfire-4_1-30:1.25
	binutils-csl-sourcerygxx-4_1-30:1.25
	binutils-csl-coldfire-4_1-28:1.25
	binutils-csl-sourcerygxx-4_1-29:1.25
	binutils-csl-sourcerygxx-4_1-28:1.25
	binutils-csl-arm-2006q3-27:1.25
	binutils-csl-sourcerygxx-4_1-27:1.25
	binutils-csl-arm-2006q3-26:1.25
	binutils-csl-sourcerygxx-4_1-26:1.25
	binutils-csl-sourcerygxx-4_1-25:1.25
	binutils-csl-sourcerygxx-4_1-24:1.25
	binutils-csl-sourcerygxx-4_1-23:1.25
	binutils-csl-sourcerygxx-4_1-21:1.25
	binutils-csl-arm-2006q3-21:1.25
	binutils-csl-sourcerygxx-4_1-22:1.25
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.25
	binutils-csl-sourcerygxx-4_1-20:1.25
	binutils-csl-arm-2006q3-19:1.25
	binutils-csl-sourcerygxx-4_1-19:1.25
	binutils-csl-sourcerygxx-4_1-18:1.25
	binutils-csl-renesas-4_1-9:1.25
	binutils-csl-sourcerygxx-3_4_4-25:1.20
	binutils-csl-renesas-4_1-8:1.25
	binutils-csl-renesas-4_1-7:1.25
	binutils-csl-renesas-4_1-6:1.25
	binutils-csl-sourcerygxx-4_1-17:1.25
	binutils-csl-sourcerygxx-4_1-14:1.25
	binutils-csl-sourcerygxx-4_1-15:1.25
	binutils-csl-sourcerygxx-4_1-13:1.25
	binutils-2_17:1.25
	binutils-csl-sourcerygxx-4_1-12:1.25
	binutils-csl-sourcerygxx-3_4_4-21:1.25
	binutils-csl-wrs-linux-3_4_4-24:1.20
	binutils-csl-wrs-linux-3_4_4-23:1.20
	binutils-csl-sourcerygxx-4_1-9:1.25
	binutils-csl-sourcerygxx-4_1-8:1.25
	binutils-csl-sourcerygxx-4_1-7:1.25
	binutils-csl-arm-2006q1-6:1.25
	binutils-csl-sourcerygxx-4_1-6:1.25
	binutils-csl-wrs-linux-3_4_4-22:1.20
	binutils-csl-coldfire-4_1-11:1.25
	binutils-csl-sourcerygxx-3_4_4-19:1.25
	binutils-csl-coldfire-4_1-10:1.25
	binutils-csl-sourcerygxx-4_1-5:1.25
	binutils-csl-sourcerygxx-4_1-4:1.25
	binutils-csl-wrs-linux-3_4_4-21:1.20
	binutils-csl-morpho-4_1-4:1.25
	binutils-csl-sourcerygxx-3_4_4-17:1.25
	binutils-csl-wrs-linux-3_4_4-20:1.20
	binutils-2_17-branch:1.25.0.4
	binutils-2_17-branchpoint:1.25
	binutils-csl-2_17-branch:1.25.0.2
	binutils-csl-2_17-branchpoint:1.25
	binutils-csl-gxxpro-3_4-branch:1.20.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.20
	binutils-2_16_1:1.20
	binutils-csl-arm-2005q1b:1.20
	binutils-2_16:1.20
	binutils-csl-arm-2005q1a:1.20
	binutils-csl-arm-2005q1-branch:1.20.0.4
	binutils-csl-arm-2005q1-branchpoint:1.20
	binutils-2_16-branch:1.20.0.2
	binutils-2_16-branchpoint:1.20
	csl-arm-2004-q3d:1.16
	csl-arm-2004-q3:1.16
	binutils-2_15:1.16
	binutils-2_15-branchpoint:1.16
	csl-arm-2004-q1a:1.16
	csl-arm-2004-q1:1.16
	binutils-2_15-branch:1.16.0.6
	cagney_bfdfile-20040213-branch:1.16.0.4
	cagney_bfdfile-20040213-branchpoint:1.16
	cagney_bigcore-20040122-branch:1.16.0.2
	cagney_bigcore-20040122-branchpoint:1.16
	csl-arm-2003-q4:1.16
	binutils-2_14:1.15
	binutils-2_14-branch:1.15.0.2
	binutils-2_14-branchpoint:1.15
	binutils-2_13_2_1:1.13.2.1
	binutils-2_13_2:1.13.2.1
	binutils-2_13_1:1.13
	binutils-2_13:1.13
	binutils-2_13-branchpoint:1.13
	binutils-2_13-branch:1.13.0.2
	binutils-2_12_1:1.11
	binutils-2_12:1.11
	binutils-2_12-branch:1.11.0.2
	binutils-2_12-branchpoint:1.11
	cygnus_cvs_20020108_pre:1.10
	binutils-2_11_2:1.5.2.1
	binutils-2_11_1:1.5.2.1
	binutils-2_11:1.5
	x86_64versiong3:1.5
	binutils-2_11-branch:1.5.0.2
	binutils_latest_snapshot:1.36;
locks; strict;
comment	@ * @;


1.36
date	2012.05.17.15.13.16;	author nickc;	state Exp;
branches;
next	1.35;

1.35
date	2010.06.28.14.06.57;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2009.12.11.13.42.11;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	2009.08.29.22.10.59;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2009.07.24.11.45.01;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	2008.08.12.23.39.31;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2008.08.11.07.40.22;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2007.10.17.16.45.55;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2007.07.03.11.01.05;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	2006.09.22.11.35.13;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2006.06.07.11.27.58;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2006.01.11.17.39.49;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2005.08.11.01.25.28;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2005.06.07.17.54.18;	author zack;	state Exp;
branches;
next	1.22;

1.22
date	2005.05.05.09.13.03;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2005.03.10.09.32.20;	author jbeulich;	state Exp;
branches;
next	1.20;

1.20
date	2005.03.03.11.47.55;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2005.02.22.00.50.05;	author hjl;	state Exp;
branches;
next	1.18;

1.18
date	2005.01.31.23.18.33;	author bje;	state Exp;
branches;
next	1.17;

1.17
date	2004.11.22.10.02.27;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2003.11.22.15.32.28;	author kazu;	state Exp;
branches;
next	1.15;

1.15
date	2002.12.19.05.47.45;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2002.11.30.08.39.44;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.11.09.53.51;	author kazu;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2002.02.22.10.49.38;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2002.01.17.17.41.23;	author twall;	state Exp;
branches;
next	1.10;

1.10
date	2001.11.15.21.28.59;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2001.11.13.14.22.41;	author twall;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.19.05.33.29;	author hjl;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.18.10.08.15;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.08.23.24.25;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2000.09.15.01.06.52;	author kazu;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2000.07.11.18.48.17;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2000.07.10.19.09.51;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.08.18.56.38;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	2000.06.20.13.52.29;	author twall;	state Exp;
branches;
next	;

1.13.2.1
date	2002.12.19.05.49.19;	author amodra;	state Exp;
branches;
next	;

1.5.2.1
date	2001.06.07.03.15.33;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.36
log
@	PR 14072
	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.
	* alpha-opc.c: Include sysdep.h before any other header file.
	* alpha-dis.c: Likewise.
	* avr-dis.c: Likewise.
	* cgen-opc.c: Likewise.
	* cr16-dis.c: Likewise.
	* cris-dis.c: Likewise.
	* crx-dis.c: Likewise.
	* d10v-dis.c: Likewise.
	* d10v-opc.c: Likewise.
	* d30v-dis.c: Likewise.
	* d30v-opc.c: Likewise.
	* h8500-dis.c: Likewise.
	* i370-dis.c: Likewise.
	* i370-opc.c: Likewise.
	* m10200-dis.c: Likewise.
	* m10300-dis.c: Likewise.
	* micromips-opc.c: Likewise.
	* mips-opc.c: Likewise.
	* mips61-opc.c: Likewise.
	* moxie-dis.c: Likewise.
	* or32-opc.c: Likewise.
	* pj-dis.c: Likewise.
	* ppc-dis.c: Likewise.
	* ppc-opc.c: Likewise.
	* s390-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* sh64-dis.c: Likewise.
	* sparc-dis.c: Likewise.
	* sparc-opc.c: Likewise.
	* spu-dis.c: Likewise.
	* tic30-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
	* tic80-dis.c: Likewise.
	* tic80-opc.c: Likewise.
	* tilegx-dis.c: Likewise.
	* tilepro-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* v850-opc.c: Likewise.
	* vax-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* xgate-dis.c: Likewise.
	* xtensa-dis.c: Likewise.
	* rl78-decode.opc: Likewise.
	* rl78-decode.c: Regenerate.
	* rx-decode.opc: Likewise.
	* rx-decode.c: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* bfd-in.h: Generate an error if included before config.h.
	* sysdep.h: Likewise.
	* bfd-in2.h: Regenerate.
	* compress.c: Remove #include "config.h".
	* plugin.c: Likewise.
	* elf32-m68hc1x.c: Include sysdep.h before alloca-conf.h.
	* elf64-hppa.c: Likewise.
	* som.c: Likewise.
	* xsymc.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* Makefile.am: Use wrappers around C files generated by flex.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* itbl-lex-wrapper.c: New file.
	* config/bfin-lex-wrapper.c: New file.
	* cgen.c: Include as.h before setjmp.h.
	* config/tc-dlx.c: Include as.h before any other header.
	* config/tc-h8300.c: Likewise.
	* config/tc-lm32.c: Likewise.
	* config/tc-mep.c: Likewise.
	* config/tc-microblaze.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-xtensa.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* unwind-ia64.h: Include config.h.
@
text
@/* tc-tic54x.c -- Assembly code for the Texas Instruments TMS320C54X
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
   2009, 2010, 2012  Free Software Foundation, Inc.
   Contributed by Timothy Wall (twall@@cygnus.com)

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Texas Instruments TMS320C54X machine specific gas.
   Written by Timothy Wall (twall@@alum.mit.edu).

   Valuable things to do:
   Pipeline conflict warnings
   We encode/decode "ld #_label, dp" differently in relocatable files
     This means we're not compatible with TI output containing those
     expressions.  We store the upper nine bits; TI stores the lower nine
     bits.  How they recover the original upper nine bits is beyond me.

   Tests to add to expect testsuite:
     '=' and '==' with .if, .elseif, and .break

   Incompatibilities (mostly trivial):
   We don't allow '''
   We fill text section with zeroes instead of "nop"s
   We don't convert '' or "" to a single instance
   We don't convert '' to '\0'
   We don't allow strings with .byte/.half/.short/.long
   Probably details of the subsym stuff are different
   TI sets labels to be data type 4 (T_INT); GAS uses T_NULL.

   COFF1 limits section names to 8 characters.
   Some of the default behavior changed from COFF1 to COFF2.  */

#include "as.h"
#include <limits.h>
#include "safe-ctype.h"
#include "sb.h"
#include "macro.h"
#include "subsegs.h"
#include "struc-symbol.h"
#include "opcode/tic54x.h"
#include "obj-coff.h"
#include <math.h>


static struct stag
{
  symbolS *sym;		        /* Symbol for this stag; value is offset.  */
  const char *name;		/* Shortcut to symbol name.  */
  bfd_vma size;		        /* Size of struct/union.  */
  int current_bitfield_offset;  /* Temporary for tracking fields.  */
  int is_union;
  struct stag_field		/* List of fields.  */
  {
    const char *name;
    bfd_vma offset;		/* Of start of this field.  */
    int bitfield_offset;	/* Of start of this field.  */
    struct stag *stag;	        /* If field is struct/union.  */
    struct stag_field *next;
  } *field;
  /* For nesting; used only in stag construction.  */
  struct stag *inner;	        /* Enclosed .struct.  */
  struct stag *outer;	        /* Enclosing .struct.  */
} *current_stag = NULL;

#define MAX_LINE 256 /* Lines longer than this are truncated by TI's asm.  */

typedef struct _tic54x_insn
{
  const insn_template *tm;	/* Opcode template.  */

  char mnemonic[MAX_LINE];	/* Opcode name/mnemonic.  */
  char parmnemonic[MAX_LINE];   /* 2nd mnemonic of parallel insn.  */

  int opcount;
  struct opstruct
  {
    char buf[MAX_LINE];
    enum optype type;
    expressionS exp;
  } operands[MAX_OPERANDS];

  int paropcount;
  struct opstruct paroperands[MAX_OPERANDS];

  int is_lkaddr;
  int lkoperand;
  int words;			/* Size of insn in 16-bit words.  */
  int using_default_dst;	/* Do we need to explicitly set an
				   omitted OP_DST operand?  */
  struct
  {
    unsigned short word;	     /* Final encoded opcode data.  */
    int unresolved;
    int r_nchars;		     /* Relocation size.  */
    bfd_reloc_code_real_type r_type; /* Relocation type.  */
    expressionS addr_expr;	     /* Storage for unresolved expressions.  */
  } opcode[3];
} tic54x_insn;

enum cpu_version
{
  VNONE = 0, V541 = 1, V542 = 2, V543 = 3, V545 = 5, V548 = 8, V549 = 9,
  V545LP = 15, V546LP = 16
};

enum address_mode
{
  c_mode,   /* 16-bit addresses.  */
  far_mode  /* >16-bit addresses.  */
};

static segT stag_saved_seg;
static subsegT stag_saved_subseg;

const char comment_chars[] = ";";
const char line_comment_chars[] = ";*#"; /* At column zero only.  */
const char line_separator_chars[] = ""; /* Not permitted.  */

int emitting_long = 0;

/* Characters which indicate that this is a floating point constant.  */
const char FLT_CHARS[] = "fF";

/* Characters that can be used to separate mantissa from exp in FP
   nums.  */
const char EXP_CHARS[] = "eE";

const char *md_shortopts = "";

#define OPTION_ADDRESS_MODE     (OPTION_MD_BASE)
#define OPTION_CPU_VERSION      (OPTION_ADDRESS_MODE + 1)
#define OPTION_COFF_VERSION     (OPTION_CPU_VERSION + 1)
#define OPTION_STDERR_TO_FILE   (OPTION_COFF_VERSION + 1)

struct option md_longopts[] =
{
  { "mfar-mode",       no_argument,	    NULL, OPTION_ADDRESS_MODE },
  { "mf",	       no_argument,	    NULL, OPTION_ADDRESS_MODE },
  { "mcpu",	       required_argument,   NULL, OPTION_CPU_VERSION },
  { "merrors-to-file", required_argument,   NULL, OPTION_STDERR_TO_FILE },
  { "me",	       required_argument,   NULL, OPTION_STDERR_TO_FILE },
  { NULL,              no_argument,         NULL, 0},
};

size_t md_longopts_size = sizeof (md_longopts);

static int assembly_begun = 0;
/* Addressing mode is not entirely implemented; the latest rev of the Other
   assembler doesn't seem to make any distinction whatsoever; all relocations
   are stored as extended relocatiosn.  Older versions used REL16 vs RELEXT16,
   but now it seems all relocations are RELEXT16.  We use all RELEXT16.

   The cpu version is kind of a waste of time as well.  There is one
   instruction (RND) for LP devices only, and several for devices with
   extended addressing only.  We include it for compatibility.  */
static enum address_mode amode = c_mode;
static enum cpu_version cpu = VNONE;

/* Include string substitutions in listing?  */
static int listing_sslist = 0;

/* Did we do subsym substitutions on the line?  */
static int substitution_line = 0;

/* Last label seen.  */
static symbolS *last_label_seen = NULL;

/* This ensures that all new labels are unique.  */
static int local_label_id;

static struct hash_control *subsym_recurse_hash; /* Prevent infinite recurse.  */
static struct hash_control *math_hash; /* Built-in math functions.  */
/* Allow maximum levels of macro nesting; level 0 is the main substitution
   symbol table.  The other assembler only does 32 levels, so there!  */
static struct hash_control *subsym_hash[100];

/* Keep track of local labels so we can substitute them before GAS sees them
   since macros use their own 'namespace' for local labels, use a separate hash

   We do our own local label handling 'cuz it's subtly different from the
   stock GAS handling.

   We use our own macro nesting counter, since GAS overloads it when expanding
   other things (like conditionals and repeat loops).  */
static int macro_level = 0;
static struct hash_control *local_label_hash[100];
/* Keep track of struct/union tags.  */
static struct hash_control *stag_hash;
static struct hash_control *op_hash;
static struct hash_control *parop_hash;
static struct hash_control *reg_hash;
static struct hash_control *mmreg_hash;
static struct hash_control *cc_hash;
static struct hash_control *cc2_hash;
static struct hash_control *cc3_hash;
static struct hash_control *sbit_hash;
static struct hash_control *misc_symbol_hash;

/* Only word (et al.), align, or conditionals are allowed within
   .struct/.union.  */
#define ILLEGAL_WITHIN_STRUCT()					\
  do								\
    if (current_stag != NULL)					\
      { 							\
	as_bad (_("pseudo-op illegal within .struct/.union"));	\
	return;							\
      }								\
  while (0)


static void subsym_create_or_replace (char *, char *);
static char *subsym_lookup (char *, int);
static char *subsym_substitute (char *, int);


void
md_show_usage (FILE *stream)
{
  fprintf (stream, _("C54x-specific command line  options:\n"));
  fprintf (stream, _("-mfar-mode | -mf          Use extended addressing\n"));
  fprintf (stream, _("-mcpu=<CPU version>       Specify the CPU version\n"));
  fprintf (stream, _("-merrors-to-file <filename>\n"));
  fprintf (stream, _("-me <filename>            Redirect errors to a file\n"));
}

/* Output a single character (upper octect is zero).  */

static void
tic54x_emit_char (char c)
{
  expressionS expn;

  expn.X_op = O_constant;
  expn.X_add_number = c;
  emit_expr (&expn, 2);
}

/* Walk backwards in the frag chain.  */

static fragS *
frag_prev (fragS *frag, segT seg)
{
  segment_info_type *seginfo = seg_info (seg);
  fragS *fragp;

  for (fragp = seginfo->frchainP->frch_root; fragp; fragp = fragp->fr_next)
    if (fragp->fr_next == frag)
      return fragp;

  return NULL;
}

static fragS *
bit_offset_frag (fragS *frag, segT seg)
{
  while (frag != NULL)
    {
      if (frag->fr_fix == 0
	  && frag->fr_opcode == NULL
	  && frag->tc_frag_data == 0)
	frag = frag_prev (frag, seg);
      else
	return frag;
    }
  return NULL;
}

/* Return the number of bits allocated in the most recent word, or zero if
   none. .field/.space/.bes may leave words partially allocated.  */

static int
frag_bit_offset (fragS *frag, segT seg)
{
  frag = bit_offset_frag (frag, seg);

  if (frag)
    return frag->fr_opcode != NULL ? -1 : frag->tc_frag_data;

  return 0;
}

/* Read an expression from a C string; returns a pointer past the end of the
   expression.  */

static char *
parse_expression (char *str, expressionS *expn)
{
  char *s;
  char *tmp;

  tmp = input_line_pointer;	/* Save line pointer.  */
  input_line_pointer = str;
  expression (expn);
  s = input_line_pointer;
  input_line_pointer = tmp;	/* Restore line pointer.  */
  return s;			/* Return pointer to where parsing stopped.  */
}

/* .asg "character-string"|character-string, symbol

   .eval is the only pseudo-op allowed to perform arithmetic on substitution
   symbols.  all other use of symbols defined with .asg are currently
   unsupported.  */

static void
tic54x_asg (int x ATTRIBUTE_UNUSED)
{
  int c;
  char *name;
  char *str;
  char *tmp;
  int quoted = *input_line_pointer == '"';

  ILLEGAL_WITHIN_STRUCT ();

  if (quoted)
    {
      int len;
      str = demand_copy_C_string (&len);
      c = *input_line_pointer;
    }
  else
    {
      str = input_line_pointer;
      while ((c = *input_line_pointer) != ',')
	{
	  if (is_end_of_line[(int) *input_line_pointer])
	    break;
	  ++input_line_pointer;
	}
      *input_line_pointer = 0;
    }
  if (c != ',')
    {
      as_bad (_("Comma and symbol expected for '.asg STRING, SYMBOL'"));
      ignore_rest_of_line ();
      return;
    }

  name = ++input_line_pointer;
  c = get_symbol_end ();	/* Get terminator.  */
  if (!ISALPHA (*name))
    {
      as_bad (_("symbols assigned with .asg must begin with a letter"));
      ignore_rest_of_line ();
      return;
    }

  tmp = xmalloc (strlen (str) + 1);
  strcpy (tmp, str);
  str = tmp;
  tmp = xmalloc (strlen (name) + 1);
  strcpy (tmp, name);
  name = tmp;
  subsym_create_or_replace (name, str);
  *input_line_pointer = c;
  demand_empty_rest_of_line ();
}

/* .eval expression, symbol
   There's something screwy about this.  The other assembler sometimes does and
   sometimes doesn't substitute symbols defined with .eval.
   We'll put the symbols into the subsym table as well as the normal symbol
   table, since that's what works best.  */

static void
tic54x_eval (int x ATTRIBUTE_UNUSED)
{
  char c;
  int value;
  char *name;
  symbolS *symbolP;
  char valuestr[32], *tmp;
  int quoted;

  ILLEGAL_WITHIN_STRUCT ();

  SKIP_WHITESPACE ();

  quoted = *input_line_pointer == '"';
  if (quoted)
    ++input_line_pointer;
  value = get_absolute_expression ();
  if (quoted)
    {
      if (*input_line_pointer != '"')
	{
	  as_bad (_("Unterminated string after absolute expression"));
	  ignore_rest_of_line ();
	  return;
	}
      ++input_line_pointer;
    }
  if (*input_line_pointer++ != ',')
    {
      as_bad (_("Comma and symbol expected for '.eval EXPR, SYMBOL'"));
      ignore_rest_of_line ();
      return;
    }
  name = input_line_pointer;
  c = get_symbol_end ();	/* Get terminator.  */
  tmp = xmalloc (strlen (name) + 1);
  name = strcpy (tmp, name);
  *input_line_pointer = c;

  if (!ISALPHA (*name))
    {
      as_bad (_("symbols assigned with .eval must begin with a letter"));
      ignore_rest_of_line ();
      return;
    }
  symbolP = symbol_new (name, absolute_section,
			(valueT) value, &zero_address_frag);
  SF_SET_LOCAL (symbolP);
  symbol_table_insert (symbolP);

  /* The "other" assembler sometimes doesn't put .eval's in the subsym table
     But since there's not written rule as to when, don't even bother trying
     to match their behavior.  */
  sprintf (valuestr, "%d", value);
  tmp = xmalloc (strlen (valuestr) + 1);
  strcpy (tmp, valuestr);
  subsym_create_or_replace (name, tmp);

  demand_empty_rest_of_line ();
}

/* .bss symbol, size [, [blocking flag] [, alignment flag]

   alignment is to a longword boundary; blocking is to 128-word boundary.

   1) if there is a hole in memory, this directive should attempt to fill it
      (not yet implemented).

   2) if the blocking flag is not set, allocate at the current SPC
      otherwise, check to see if the current SPC plus the space to be
      allocated crosses the page boundary (128 words).
      if there's not enough space, create a hole and align with the next page
      boundary.
      (not yet implemented).  */

static void
tic54x_bss (int x ATTRIBUTE_UNUSED)
{
  char c;
  char *name;
  char *p;
  int words;
  segT current_seg;
  subsegT current_subseg;
  symbolS *symbolP;
  int block = 0;
  int align = 0;

  ILLEGAL_WITHIN_STRUCT ();

  current_seg = now_seg;	/* Save current seg.  */
  current_subseg = now_subseg;	/* Save current subseg.  */

  name = input_line_pointer;
  c = get_symbol_end ();	/* Get terminator.  */
  if (c != ',')
    {
      as_bad (_(".bss size argument missing\n"));
      ignore_rest_of_line ();
      return;
    }

  ++input_line_pointer;
  words = get_absolute_expression ();
  if (words < 0)
    {
      as_bad (_(".bss size %d < 0!"), words);
      ignore_rest_of_line ();
      return;
    }

  if (*input_line_pointer == ',')
    {
      /* The blocking flag may be missing.  */
      ++input_line_pointer;
      if (*input_line_pointer != ',')
	block = get_absolute_expression ();
      else
	block = 0;

      if (*input_line_pointer == ',')
	{
	  ++input_line_pointer;
	  align = get_absolute_expression ();
	}
      else
	align = 0;
    }
  else
    block = align = 0;

  subseg_set (bss_section, 0);
  symbolP = symbol_find_or_make (name);

  if (S_GET_SEGMENT (symbolP) == bss_section)
    symbolP->sy_frag->fr_symbol = (symbolS *) NULL;

  symbol_set_frag (symbolP, frag_now);
  p = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP,
		(offsetT) (words * OCTETS_PER_BYTE), (char *) 0);
  *p = 0;			/* Fill char.  */

  S_SET_SEGMENT (symbolP, bss_section);

  /* The symbol may already have been created with a preceding
     ".globl" directive -- be careful not to step on storage class
     in that case.  Otherwise, set it to static.  */
  if (S_GET_STORAGE_CLASS (symbolP) != C_EXT)
    S_SET_STORAGE_CLASS (symbolP, C_STAT);

  if (align)
    {
      /* s_align eats end of line; restore it */
      s_align_bytes (4);
      --input_line_pointer;
    }

  if (block)
    bss_section->flags |= SEC_TIC54X_BLOCK;

  subseg_set (current_seg, current_subseg);	/* Restore current seg.  */
  demand_empty_rest_of_line ();
}

static void
stag_add_field_symbols (struct stag *stag,
			const char *path,
			bfd_vma base_offset,
			symbolS *rootsym,
			const char *root_stag_name)
{
  char prefix[strlen (path) + 2];
  struct stag_field *field = stag->field;

  /* Construct a symbol for every field contained within this structure
     including fields within structure fields.  */
  strcpy (prefix, path);
  if (*path)
    strcat (prefix, ".");

  while (field != NULL)
    {
      int len = strlen (prefix) + strlen (field->name) + 2;
      char *name = xmalloc (len);
      strcpy (name, prefix);
      strcat (name, field->name);

      if (rootsym == NULL)
	{
	  symbolS *sym;
	  sym = symbol_new (name, absolute_section,
			    (field->stag ? field->offset :
			     (valueT) (base_offset + field->offset)),
			    &zero_address_frag);
	  SF_SET_LOCAL (sym);
	  symbol_table_insert (sym);
	}
      else
	{
	  char *replacement = xmalloc (strlen (name)
				       + strlen (stag->name) + 2);
	  strcpy (replacement, S_GET_NAME (rootsym));
	  strcat (replacement, "+");
	  strcat (replacement, root_stag_name);
	  strcat (replacement, name + strlen (S_GET_NAME (rootsym)));
	  hash_insert (subsym_hash[0], name, replacement);
	}

      /* Recurse if the field is a structure.
	 Note the field offset is relative to the outermost struct.  */
      if (field->stag != NULL)
	stag_add_field_symbols (field->stag, name,
				field->offset,
				rootsym, root_stag_name);
      field = field->next;
    }
}

/* Keep track of stag fields so that when structures are nested we can add the
   complete dereferencing symbols to the symbol table.  */

static void
stag_add_field (struct stag *parent,
		const char *name,
		bfd_vma offset,
		struct stag *stag)
{
  struct stag_field *sfield = xmalloc (sizeof (struct stag_field));

  memset (sfield, 0, sizeof (*sfield));
  sfield->name = strcpy (xmalloc (strlen (name) + 1), name);
  sfield->offset = offset;
  sfield->bitfield_offset = parent->current_bitfield_offset;
  sfield->stag = stag;
  if (parent->field == NULL)
    parent->field = sfield;
  else
    {
      struct stag_field *sf = parent->field;
      while (sf->next != NULL)
	sf = sf->next;
      sf->next = sfield;
    }
  /* Only create a symbol for this field if the parent has no name.  */
  if (!strncmp (".fake", parent->name, 5))
    {
      symbolS *sym = symbol_new (name, absolute_section,
				 (valueT) offset, &zero_address_frag);
      SF_SET_LOCAL (sym);
      symbol_table_insert (sym);
    }
}

/* [STAG] .struct       [OFFSET]
   Start defining structure offsets (symbols in absolute section).  */

static void
tic54x_struct (int arg)
{
  int start_offset = 0;
  int is_union = arg;

  if (!current_stag)
    {
      /* Starting a new struct, switch to absolute section.  */
      stag_saved_seg = now_seg;
      stag_saved_subseg = now_subseg;
      subseg_set (absolute_section, 0);
    }
  /* Align the current pointer.  */
  else if (current_stag->current_bitfield_offset != 0)
    {
      ++abs_section_offset;
      current_stag->current_bitfield_offset = 0;
    }

  /* Offset expression is only meaningful for global .structs.  */
  if (!is_union)
    {
      /* Offset is ignored in inner structs.  */
      SKIP_WHITESPACE ();
      if (!is_end_of_line[(int) *input_line_pointer])
	start_offset = get_absolute_expression ();
      else
	start_offset = 0;
    }

  if (current_stag)
    {
      /* Nesting, link to outer one.  */
      current_stag->inner = (struct stag *) xmalloc (sizeof (struct stag));
      memset (current_stag->inner, 0, sizeof (struct stag));
      current_stag->inner->outer = current_stag;
      current_stag = current_stag->inner;
      if (start_offset)
	as_warn (_("Offset on nested structures is ignored"));
      start_offset = abs_section_offset;
    }
  else
    {
      current_stag = (struct stag *) xmalloc (sizeof (struct stag));
      memset (current_stag, 0, sizeof (struct stag));
      abs_section_offset = start_offset;
    }
  current_stag->is_union = is_union;

  if (line_label == NULL)
    {
      static int struct_count = 0;
      char fake[] = ".fake_stagNNNNNNN";
      sprintf (fake, ".fake_stag%d", struct_count++);
      current_stag->sym = symbol_new (fake, absolute_section,
				      (valueT) abs_section_offset,
				      &zero_address_frag);
    }
  else
    {
      char label[strlen (S_GET_NAME (line_label)) + 1];
      strcpy (label, S_GET_NAME (line_label));
      current_stag->sym = symbol_new (label, absolute_section,
				      (valueT) abs_section_offset,
				      &zero_address_frag);
    }
  current_stag->name = S_GET_NAME (current_stag->sym);
  SF_SET_LOCAL (current_stag->sym);
  /* Nested .structs don't go into the symbol table.  */
  if (current_stag->outer == NULL)
    symbol_table_insert (current_stag->sym);

  line_label = NULL;
}

/* [LABEL] .endstruct
   finish defining structure offsets; optional LABEL's value will be the size
   of the structure.  */

static void
tic54x_endstruct (int is_union)
{
  int size;
  const char *path =
    !strncmp (current_stag->name, ".fake", 5) ? "" : current_stag->name;

  if (!current_stag || current_stag->is_union != is_union)
    {
      as_bad (_(".end%s without preceding .%s"),
	      is_union ? "union" : "struct",
	      is_union ? "union" : "struct");
      ignore_rest_of_line ();
      return;
    }

  /* Align end of structures.  */
  if (current_stag->current_bitfield_offset)
    {
      ++abs_section_offset;
      current_stag->current_bitfield_offset = 0;
    }

  if (current_stag->is_union)
    size = current_stag->size;
  else
    size = abs_section_offset - S_GET_VALUE (current_stag->sym);
  if (line_label != NULL)
    {
      S_SET_VALUE (line_label, size);
      symbol_table_insert (line_label);
      line_label = NULL;
    }

  /* Union size has already been calculated.  */
  if (!current_stag->is_union)
    current_stag->size = size;
  /* Nested .structs don't get put in the stag table.  */
  if (current_stag->outer == NULL)
    {
      hash_insert (stag_hash, current_stag->name, current_stag);
      stag_add_field_symbols (current_stag, path,
			      S_GET_VALUE (current_stag->sym),
			      NULL, NULL);
    }
  current_stag = current_stag->outer;

  /* If this is a nested .struct/.union, add it as a field to the enclosing
     one.  otherwise, restore the section we were in.  */
  if (current_stag != NULL)
    {
      stag_add_field (current_stag, current_stag->inner->name,
		      S_GET_VALUE (current_stag->inner->sym),
		      current_stag->inner);
    }
  else
    subseg_set (stag_saved_seg, stag_saved_subseg);
}

/* [LABEL]      .tag    STAG
   Reference a structure within a structure, as a sized field with an optional
   label.
   If used outside of a .struct/.endstruct, overlays the given structure
   format on the existing allocated space.  */

static void
tic54x_tag (int ignore ATTRIBUTE_UNUSED)
{
  char *name = input_line_pointer;
  int c = get_symbol_end ();
  struct stag *stag = (struct stag *) hash_find (stag_hash, name);

  if (!stag)
    {
      if (*name)
	as_bad (_("Unrecognized struct/union tag '%s'"), name);
      else
	as_bad (_(".tag requires a structure tag"));
      ignore_rest_of_line ();
      return;
    }
  if (line_label == NULL)
    {
      as_bad (_("Label required for .tag"));
      ignore_rest_of_line ();
      return;
    }
  else
    {
      char label[strlen (S_GET_NAME (line_label)) + 1];

      strcpy (label, S_GET_NAME (line_label));
      if (current_stag != NULL)
	stag_add_field (current_stag, label,
			abs_section_offset - S_GET_VALUE (current_stag->sym),
			stag);
      else
	{
	  symbolS *sym = symbol_find (label);

	  if (!sym)
	    {
	      as_bad (_(".tag target '%s' undefined"), label);
	      ignore_rest_of_line ();
	      return;
	    }
	  stag_add_field_symbols (stag, S_GET_NAME (sym),
				  S_GET_VALUE (stag->sym), sym, stag->name);
	}
    }

  /* Bump by the struct size, but only if we're within a .struct section.  */
  if (current_stag != NULL && !current_stag->is_union)
    abs_section_offset += stag->size;

  *input_line_pointer = c;
  demand_empty_rest_of_line ();
  line_label = NULL;
}

/* Handle all .byte, .char, .double, .field, .float, .half, .int, .long,
   .short, .string, .ubyte, .uchar, .uhalf, .uint, .ulong, .ushort, .uword,
   and .word.  */

static void
tic54x_struct_field (int type)
{
  int size;
  int count = 1;
  int new_bitfield_offset = 0;
  int field_align = current_stag->current_bitfield_offset != 0;
  int longword_align = 0;

  SKIP_WHITESPACE ();
  if (!is_end_of_line[(int) *input_line_pointer])
    count = get_absolute_expression ();

  switch (type)
    {
    case 'b':
    case 'B':
    case 'c':
    case 'C':
    case 'h':
    case 'H':
    case 'i':
    case 'I':
    case 's':
    case 'S':
    case 'w':
    case 'W':
    case '*': /* String.  */
      size = 1;
      break;
    case 'f':
    case 'l':
    case 'L':
      longword_align = 1;
      size = 2;
      break;
    case '.': /* Bitfield.  */
      size = 0;
      if (count < 1 || count > 32)
	{
	  as_bad (_(".field count '%d' out of range (1 <= X <= 32)"), count);
	  ignore_rest_of_line ();
	  return;
	}
      if (current_stag->current_bitfield_offset + count > 16)
	{
	  /* Set the appropriate size and new field offset.  */
	  if (count == 32)
	    {
	      size = 2;
	      count = 1;
	    }
	  else if (count > 16)
	    {
	      size = 1;
	      count = 1;
	      new_bitfield_offset = count - 16;
	    }
	  else
	    new_bitfield_offset = count;
	}
      else
	{
	  field_align = 0;
	  new_bitfield_offset = current_stag->current_bitfield_offset + count;
	}
      break;
    default:
      as_bad (_("Unrecognized field type '%c'"), type);
      ignore_rest_of_line ();
      return;
    }

  if (field_align)
    {
      /* Align to the actual starting position of the field.  */
      current_stag->current_bitfield_offset = 0;
      ++abs_section_offset;
    }
  /* Align to longword boundary.  */
  if (longword_align && (abs_section_offset & 0x1))
    ++abs_section_offset;

  if (line_label == NULL)
    {
      static int fieldno = 0;
      char fake[] = ".fake_fieldNNNNN";

      sprintf (fake, ".fake_field%d", fieldno++);
      stag_add_field (current_stag, fake,
		      abs_section_offset - S_GET_VALUE (current_stag->sym),
		      NULL);
    }
  else
    {
      char label[strlen (S_GET_NAME (line_label) + 1)];

      strcpy (label, S_GET_NAME (line_label));
      stag_add_field (current_stag, label,
		      abs_section_offset - S_GET_VALUE (current_stag->sym),
		      NULL);
    }

  if (current_stag->is_union)
    {
      /* Note we treat the element as if it were an array of COUNT.  */
      if (current_stag->size < (unsigned) size * count)
	current_stag->size = size * count;
    }
  else
    {
      abs_section_offset += (unsigned) size * count;
      current_stag->current_bitfield_offset = new_bitfield_offset;
    }
  line_label = NULL;
}

/* Handle .byte, .word. .int, .long and all variants.  */

static void
tic54x_cons (int type)
{
  unsigned int c;
  int octets;

  /* If we're within a .struct construct, don't actually allocate space.  */
  if (current_stag != NULL)
    {
      tic54x_struct_field (type);
      return;
    }

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  generate_lineno_debug ();

  /* Align long words to long word boundaries (4 octets).  */
  if (type == 'l' || type == 'L')
    {
      frag_align (2, 0, 2);
      /* If there's a label, assign it to the first allocated word.  */
      if (line_label != NULL)
	{
	  symbol_set_frag (line_label, frag_now);
	  S_SET_VALUE (line_label, frag_now_fix ());
	}
    }

  switch (type)
    {
    case 'l':
    case 'L':
    case 'x':
      octets = 4;
      break;
    case 'b':
    case 'B':
    case 'c':
    case 'C':
      octets = 1;
      break;
    default:
      octets = 2;
      break;
    }

  do
    {
      if (*input_line_pointer == '"')
	{
	  input_line_pointer++;
	  while (is_a_char (c = next_char_of_string ()))
	    tic54x_emit_char (c);
	  know (input_line_pointer[-1] == '\"');
	}
      else
	{
	  expressionS expn;

	  input_line_pointer = parse_expression (input_line_pointer, &expn);
	  if (expn.X_op == O_constant)
	    {
	      offsetT value = expn.X_add_number;
	      /* Truncate overflows.  */
	      switch (octets)
		{
		case 1:
		  if ((value > 0 && value > 0xFF)
		      || (value < 0 && value < - 0x100))
		    as_warn (_("Overflow in expression, truncated to 8 bits"));
		  break;
		case 2:
		  if ((value > 0 && value > 0xFFFF)
		      || (value < 0 && value < - 0x10000))
		    as_warn (_("Overflow in expression, truncated to 16 bits"));
		  break;
		}
	    }
	  if (expn.X_op != O_constant && octets < 2)
	    {
	      /* Disallow .byte with a non constant expression that will
		 require relocation.  */
	      as_bad (_("Relocatable values require at least WORD storage"));
	      ignore_rest_of_line ();
	      return;
	    }

	  if (expn.X_op != O_constant
	      && amode == c_mode
	      && octets == 4)
	    {
	      /* FIXME -- at one point TI tools used to output REL16
		 relocations, but I don't think the latest tools do at all
		 The current tools output extended relocations regardless of
		 the addressing mode (I actually think that ".c_mode" is
		 totally ignored in the latest tools).  */
	      amode = far_mode;
	      emitting_long = 1;
	      emit_expr (&expn, 4);
	      emitting_long = 0;
	      amode = c_mode;
	    }
	  else
	    {
	      emitting_long = octets == 4;
	      emit_expr (&expn, (octets == 1) ? 2 : octets);
	      emitting_long = 0;
	    }
	}
    }
  while (*input_line_pointer++ == ',');

  input_line_pointer--;		/* Put terminator back into stream.  */
  demand_empty_rest_of_line ();
}

/* .global <symbol>[,...,<symbolN>]
   .def    <symbol>[,...,<symbolN>]
   .ref    <symbol>[,...,<symbolN>]

   These all identify global symbols.

   .def means the symbol is defined in the current module and can be accessed
   by other files.  The symbol should be placed in the symbol table.

   .ref means the symbol is used in the current module but defined in another
   module.  The linker is to resolve this symbol's definition at link time.

   .global should act as a .ref or .def, as needed.

   global, def and ref all have symbol storage classes of C_EXT.

   I can't identify any difference in how the "other" c54x assembler treats
   these, so we ignore the type here.  */

void
tic54x_global (int type)
{
  char *name;
  int c;
  symbolS *symbolP;

  if (type == 'r')
    as_warn (_("Use of .def/.ref is deprecated.  Use .global instead"));

  ILLEGAL_WITHIN_STRUCT ();

  do
    {
      name = input_line_pointer;
      c = get_symbol_end ();
      symbolP = symbol_find_or_make (name);

      *input_line_pointer = c;
      S_SET_STORAGE_CLASS (symbolP, C_EXT);
      if (c == ',')
	{
	  input_line_pointer++;
	  if (is_end_of_line[(int) *input_line_pointer])
	    c = *input_line_pointer;
	}
    }
  while (c == ',');

  demand_empty_rest_of_line ();
}

/* Remove the symbol from the local label hash lookup.  */

static void
tic54x_remove_local_label (const char *key, void *value ATTRIBUTE_UNUSED)
{
  void *elem = hash_delete (local_label_hash[macro_level], key, FALSE);
  free (elem);
}

/* Reset all local labels.  */

static void
tic54x_clear_local_labels (int ignored ATTRIBUTE_UNUSED)
{
  hash_traverse (local_label_hash[macro_level], tic54x_remove_local_label);
}

/* .text
   .data
   .sect "section name"

   Initialized section
   make sure local labels get cleared when changing sections

   ARG is 't' for text, 'd' for data, or '*' for a named section

   For compatibility, '*' sections are SEC_CODE if instructions are
   encountered, or SEC_DATA if not.
*/

static void
tic54x_sect (int arg)
{
  ILLEGAL_WITHIN_STRUCT ();

  /* Local labels are cleared when changing sections.  */
  tic54x_clear_local_labels (0);

  if (arg == 't')
    s_text (0);
  else if (arg == 'd')
    s_data (0);
  else
    {
      char *name = NULL;
      int len;

      /* If there are quotes, remove them.  */
      if (*input_line_pointer == '"')
	{
	  name = demand_copy_C_string (&len);
	  demand_empty_rest_of_line ();
	  name = strcpy (xmalloc (len + 10), name);
	}
      else
	{
	  int c;
	  name = input_line_pointer;
	  c = get_symbol_end ();
          len = strlen(name);
	  name = strcpy (xmalloc (len + 10), name);
	  *input_line_pointer = c;
	  demand_empty_rest_of_line ();
	}
      /* Make sure all named initialized sections flagged properly.  If we
         encounter instructions, we'll flag it with SEC_CODE as well.  */
      strcat (name, ",\"w\"\n");
      input_scrub_insert_line (name);
      obj_coff_section (0);

      /* If there was a line label, make sure that it gets assigned the proper
	 section.  This is for compatibility, even though the actual behavior
	 is not explicitly defined.  For consistency, we make .sect behave
	 like .usect, since that is probably what people expect.  */
      if (line_label != NULL)
	{
	  S_SET_SEGMENT (line_label, now_seg);
	  symbol_set_frag (line_label, frag_now);
	  S_SET_VALUE (line_label, frag_now_fix ());
	  if (S_GET_STORAGE_CLASS (line_label) != C_EXT)
	    S_SET_STORAGE_CLASS (line_label, C_LABEL);
	}
    }
}

/* [symbol] .space space_in_bits
   [symbol] .bes space_in_bits
   BES puts the symbol at the *last* word allocated

   cribbed from s_space.  */

static void
tic54x_space (int arg)
{
  expressionS expn;
  char *p = 0;
  int octets = 0;
  long words;
  int bits_per_byte = (OCTETS_PER_BYTE * 8);
  int bit_offset = 0;
  symbolS *label = line_label;
  int bes = arg;

  ILLEGAL_WITHIN_STRUCT ();

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  /* Read the bit count.  */
  expression (&expn);

  /* Some expressions are unresolvable until later in the assembly pass;
     postpone until relaxation/fixup.  we also have to postpone if a previous
     partial allocation has not been completed yet.  */
  if (expn.X_op != O_constant || frag_bit_offset (frag_now, now_seg) == -1)
    {
      struct bit_info *bi = xmalloc (sizeof (struct bit_info));

      bi->seg = now_seg;
      bi->type = bes;
      bi->sym = label;
      p = frag_var (rs_machine_dependent,
		    65536 * 2, 1, (relax_substateT) 0,
		    make_expr_symbol (&expn), (offsetT) 0,
		    (char *) bi);
      if (p)
	*p = 0;

      return;
    }

  /* Reduce the required size by any bit offsets currently left over
     from a previous .space/.bes/.field directive.  */
  bit_offset = frag_now->tc_frag_data;
  if (bit_offset != 0 && bit_offset < 16)
    {
      int spare_bits = bits_per_byte - bit_offset;

      if (spare_bits >= expn.X_add_number)
	{
	  /* Don't have to do anything; sufficient bits have already been
	     allocated; just point the label to the right place.  */
	  if (label != NULL)
	    {
	      symbol_set_frag (label, frag_now);
	      S_SET_VALUE (label, frag_now_fix () - 1);
	      label = NULL;
	    }
	  frag_now->tc_frag_data += expn.X_add_number;
	  goto getout;
	}
      expn.X_add_number -= spare_bits;
      /* Set the label to point to the first word allocated, which in this
	 case is the previous word, which was only partially filled.  */
      if (!bes && label != NULL)
	{
	  symbol_set_frag (label, frag_now);
	  S_SET_VALUE (label, frag_now_fix () - 1);
	  label = NULL;
	}
    }
  /* Convert bits to bytes/words and octets, rounding up.  */
  words = ((expn.X_add_number + bits_per_byte - 1) / bits_per_byte);
  /* How many do we have left over?  */
  bit_offset = expn.X_add_number % bits_per_byte;
  octets = words * OCTETS_PER_BYTE;
  if (octets < 0)
    {
      as_warn (_(".space/.bes repeat count is negative, ignored"));
      goto getout;
    }
  else if (octets == 0)
    {
      as_warn (_(".space/.bes repeat count is zero, ignored"));
      goto getout;
    }

  /* If we are in the absolute section, just bump the offset.  */
  if (now_seg == absolute_section)
    {
      abs_section_offset += words;
      if (bes && label != NULL)
	S_SET_VALUE (label, abs_section_offset - 1);
      frag_now->tc_frag_data = bit_offset;
      goto getout;
    }

  if (!need_pass_2)
    p = frag_var (rs_fill, 1, 1,
		  (relax_substateT) 0, (symbolS *) 0,
		  (offsetT) octets, (char *) 0);

  /* Make note of how many bits of this word we've allocated so far.  */
  frag_now->tc_frag_data = bit_offset;

  /* .bes puts label at *last* word allocated.  */
  if (bes && label != NULL)
    {
      symbol_set_frag (label, frag_now);
      S_SET_VALUE (label, frag_now_fix () - 1);
    }

  if (p)
    *p = 0;

 getout:

  demand_empty_rest_of_line ();
}

/* [symbol] .usect "section-name", size-in-words
		   [, [blocking-flag] [, alignment-flag]]

   Uninitialized section.
   Non-zero blocking means that if the section would cross a page (128-word)
   boundary, it will be page-aligned.
   Non-zero alignment aligns on a longword boundary.

   Has no effect on the current section.  */

static void
tic54x_usect (int x ATTRIBUTE_UNUSED)
{
  char c;
  char *name;
  char *section_name;
  char *p;
  segT seg;
  int size, blocking_flag, alignment_flag;
  segT current_seg;
  subsegT current_subseg;
  flagword flags;

  ILLEGAL_WITHIN_STRUCT ();

  current_seg = now_seg;	/* Save current seg.  */
  current_subseg = now_subseg;	/* Save current subseg.  */

  if (*input_line_pointer == '"')
    input_line_pointer++;
  section_name = input_line_pointer;
  c = get_symbol_end ();	/* Get terminator.  */
  input_line_pointer++;		/* Skip null symbol terminator.  */
  name = xmalloc (input_line_pointer - section_name + 1);
  strcpy (name, section_name);

  if (*input_line_pointer == ',')
    ++input_line_pointer;
  else if (c != ',')
    {
      as_bad (_("Missing size argument"));
      ignore_rest_of_line ();
      return;
    }

  size = get_absolute_expression ();

  /* Read a possibly present third argument (blocking flag).  */
  if (*input_line_pointer == ',')
    {
      ++input_line_pointer;
      if (*input_line_pointer != ',')
	blocking_flag = get_absolute_expression ();
      else
	blocking_flag = 0;

      /* Read a possibly present fourth argument (alignment flag).  */
      if (*input_line_pointer == ',')
	{
	  ++input_line_pointer;
	  alignment_flag = get_absolute_expression ();
	}
      else
	alignment_flag = 0;
    }
  else
    blocking_flag = alignment_flag = 0;

  seg = subseg_new (name, 0);
  flags = bfd_get_section_flags (stdoutput, seg) | SEC_ALLOC;

  if (alignment_flag)
    {
      /* s_align eats end of line; restore it.  */
      s_align_bytes (4);
      --input_line_pointer;
    }

  if (line_label != NULL)
    {
      S_SET_SEGMENT (line_label, seg);
      symbol_set_frag (line_label, frag_now);
      S_SET_VALUE (line_label, frag_now_fix ());
      /* Set scl to label, since that's what TI does.  */
      if (S_GET_STORAGE_CLASS (line_label) != C_EXT)
	S_SET_STORAGE_CLASS (line_label, C_LABEL);
    }

  seg_info (seg)->bss = 1;	/* Uninitialized data.  */

  p = frag_var (rs_fill, 1, 1,
		(relax_substateT) 0, (symbolS *) line_label,
		size * OCTETS_PER_BYTE, (char *) 0);
  *p = 0;

  if (blocking_flag)
    flags |= SEC_TIC54X_BLOCK;

  if (!bfd_set_section_flags (stdoutput, seg, flags))
    as_warn (_("Error setting flags for \"%s\": %s"), name,
	     bfd_errmsg (bfd_get_error ()));

  subseg_set (current_seg, current_subseg);	/* Restore current seg.  */
  demand_empty_rest_of_line ();
}

static enum cpu_version
lookup_version (const char *ver)
{
  enum cpu_version version = VNONE;

  if (ver[0] == '5' && ver[1] == '4')
    {
      if (strlen (ver) == 3
	  && (ver[2] == '1' || ver[2] == '2' || ver[2] == '3'
	      || ver[2] == '5' || ver[2] == '8' || ver[2] == '9'))
	version = ver[2] - '0';
      else if (strlen (ver) == 5
	       && TOUPPER (ver[3]) == 'L'
	       && TOUPPER (ver[4]) == 'P'
	       && (ver[2] == '5' || ver[2] == '6'))
	version = ver[2] - '0' + 10;
    }

  return version;
}

static void
set_cpu (enum cpu_version version)
{
  cpu = version;
  if (version == V545LP || version == V546LP)
    {
      symbolS *symbolP = symbol_new ("__allow_lp", absolute_section,
				     (valueT) 1, &zero_address_frag);
      SF_SET_LOCAL (symbolP);
      symbol_table_insert (symbolP);
    }
}

/* .version cpu-version
   cpu-version may be one of the following:
   541
   542
   543
   545
   545LP
   546LP
   548
   549

   This is for compatibility only.  It currently has no affect on assembly.  */
static int cpu_needs_set = 1;

static void
tic54x_version (int x ATTRIBUTE_UNUSED)
{
  enum cpu_version version = VNONE;
  enum cpu_version old_version = cpu;
  int c;
  char *ver;

  ILLEGAL_WITHIN_STRUCT ();

  SKIP_WHITESPACE ();
  ver = input_line_pointer;
  while (!is_end_of_line[(int) *input_line_pointer])
    ++input_line_pointer;
  c = *input_line_pointer;
  *input_line_pointer = 0;

  version = lookup_version (ver);

  if (cpu != VNONE && cpu != version)
    as_warn (_("CPU version has already been set"));

  if (version == VNONE)
    {
      as_bad (_("Unrecognized version '%s'"), ver);
      ignore_rest_of_line ();
      return;
    }
  else if (assembly_begun && version != old_version)
    {
      as_bad (_("Changing of CPU version on the fly not supported"));
      ignore_rest_of_line ();
      return;
    }

  set_cpu (version);

  *input_line_pointer = c;
  demand_empty_rest_of_line ();
}

/* 'f' = float, 'x' = xfloat, 'd' = double, 'l' = ldouble.  */

static void
tic54x_float_cons (int type)
{
  if (current_stag != 0)
    tic54x_struct_field ('f');

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  /* Align to long word boundary (4 octets) unless it's ".xfloat".  */
  if (type != 'x')
    {
      frag_align (2, 0, 2);
      /* If there's a label, assign it to the first allocated word.  */
      if (line_label != NULL)
	{
	  symbol_set_frag (line_label, frag_now);
	  S_SET_VALUE (line_label, frag_now_fix ());
	}
    }

  float_cons ('f');
}

/* The argument is capitalized if it should be zero-terminated
   's' is normal string with upper 8-bits zero-filled, 'p' is packed.
   Code copied from stringer, and slightly modified so that strings are packed
   and encoded into the correct octets.  */

static void
tic54x_stringer (int type)
{
  unsigned int c;
  int append_zero = type == 'S' || type == 'P';
  int packed = type == 'p' || type == 'P';
  int last_char = -1; /* Packed strings need two bytes at a time to encode.  */

  if (current_stag != NULL)
    {
      tic54x_struct_field ('*');
      return;
    }

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  c = ',';			/* Do loop.  */
  while (c == ',')
    {
      SKIP_WHITESPACE ();
      switch (*input_line_pointer)
	{
	default:
	  {
	    unsigned short value = get_absolute_expression ();
	    FRAG_APPEND_1_CHAR ( value       & 0xFF);
	    FRAG_APPEND_1_CHAR ((value >> 8) & 0xFF);
	    break;
	  }
	case '\"':
	  ++input_line_pointer;	/* -> 1st char of string.  */
	  while (is_a_char (c = next_char_of_string ()))
	    {
	      if (!packed)
		{
		  FRAG_APPEND_1_CHAR (c);
		  FRAG_APPEND_1_CHAR (0);
		}
	      else
		{
		  /* Packed strings are filled MS octet first.  */
		  if (last_char == -1)
		    last_char = c;
		  else
		    {
		      FRAG_APPEND_1_CHAR (c);
		      FRAG_APPEND_1_CHAR (last_char);
		      last_char = -1;
		    }
		}
	    }
	  if (append_zero)
	    {
	      if (packed && last_char != -1)
		{
		  FRAG_APPEND_1_CHAR (0);
		  FRAG_APPEND_1_CHAR (last_char);
		  last_char = -1;
		}
	      else
		{
		  FRAG_APPEND_1_CHAR (0);
		  FRAG_APPEND_1_CHAR (0);
		}
	    }
	  know (input_line_pointer[-1] == '\"');
	  break;
	}
      SKIP_WHITESPACE ();
      c = *input_line_pointer;
      if (!is_end_of_line[c])
	++input_line_pointer;
    }

  /* Finish up any leftover packed string.  */
  if (packed && last_char != -1)
    {
      FRAG_APPEND_1_CHAR (0);
      FRAG_APPEND_1_CHAR (last_char);
    }
  demand_empty_rest_of_line ();
}

static void
tic54x_p2align (int arg ATTRIBUTE_UNUSED)
{
  as_bad (_("p2align not supported on this target"));
}

static void
tic54x_align_words (int arg)
{
  /* Only ".align" with no argument is allowed within .struct/.union.  */
  int count = arg;

  if (!is_end_of_line[(int) *input_line_pointer])
    {
      if (arg == 2)
	as_warn (_("Argument to .even ignored"));
      else
	count = get_absolute_expression ();
    }

  if (current_stag != NULL && arg == 128)
    {
      if (current_stag->current_bitfield_offset != 0)
	{
	  current_stag->current_bitfield_offset = 0;
	  ++abs_section_offset;
	}
      demand_empty_rest_of_line ();
      return;
    }

  ILLEGAL_WITHIN_STRUCT ();

  s_align_bytes (count << 1);
}

/* Initialize multiple-bit fields withing a single word of memory.  */

static void
tic54x_field (int ignore ATTRIBUTE_UNUSED)
{
  expressionS expn;
  int size = 16;
  char *p;
  valueT value;
  symbolS *label = line_label;

  if (current_stag != NULL)
    {
      tic54x_struct_field ('.');
      return;
    }

  input_line_pointer = parse_expression (input_line_pointer, &expn);

  if (*input_line_pointer == ',')
    {
      ++input_line_pointer;
      size = get_absolute_expression ();
      if (size < 1 || size > 32)
	{
	  as_bad (_("Invalid field size, must be from 1 to 32"));
	  ignore_rest_of_line ();
	  return;
	}
    }

  /* Truncate values to the field width.  */
  if (expn.X_op != O_constant)
    {
      /* If the expression value is relocatable, the field size *must*
         be 16.  */
      if (size != 16)
	{
	  as_bad (_("field size must be 16 when value is relocatable"));
	  ignore_rest_of_line ();
	  return;
	}

      frag_now->tc_frag_data = 0;
      emit_expr (&expn, 2);
    }
  else
    {
      unsigned long fmask = (size == 32) ? 0xFFFFFFFF : (1ul << size) - 1;

      value = expn.X_add_number;
      expn.X_add_number &= fmask;
      if (value != (valueT) expn.X_add_number)
	as_warn (_("field value truncated"));
      value = expn.X_add_number;
      /* Bits are stored MS first.  */
      while (size >= 16)
	{
	  frag_now->tc_frag_data = 0;
	  p = frag_more (2);
	  md_number_to_chars (p, (value >> (size - 16)) & 0xFFFF, 2);
	  size -= 16;
	}
      if (size > 0)
	{
	  int bit_offset = frag_bit_offset (frag_now, now_seg);

	  fragS *alloc_frag = bit_offset_frag (frag_now, now_seg);
	  if (bit_offset == -1)
	    {
	      struct bit_info *bi = xmalloc (sizeof (struct bit_info));
	      /* We don't know the previous offset at this time, so store the
		 info we need and figure it out later.  */
	      expressionS size_exp;

	      size_exp.X_op = O_constant;
	      size_exp.X_add_number = size;
	      bi->seg = now_seg;
	      bi->type = TYPE_FIELD;
	      bi->value = value;
	      p = frag_var (rs_machine_dependent,
			    4, 1, (relax_substateT) 0,
			    make_expr_symbol (&size_exp), (offsetT) 0,
			    (char *) bi);
	      goto getout;
	    }
	  else if (bit_offset == 0 || bit_offset + size > 16)
	    {
	      /* Align a new field.  */
	      p = frag_more (2);
	      frag_now->tc_frag_data = 0;
	      alloc_frag = frag_now;
	    }
	  else
	    {
	      /* Put the new value entirely within the existing one.  */
	      p = alloc_frag == frag_now ?
		frag_now->fr_literal + frag_now_fix_octets () - 2 :
		alloc_frag->fr_literal;
	      if (label != NULL)
		{
		  symbol_set_frag (label, alloc_frag);
		  if (alloc_frag == frag_now)
		    S_SET_VALUE (label, frag_now_fix () - 1);
		  label = NULL;
		}
	    }
	  value <<= 16 - alloc_frag->tc_frag_data - size;

	  /* OR in existing value.  */
	  if (alloc_frag->tc_frag_data)
	    value |= ((unsigned short) p[1] << 8) | p[0];
	  md_number_to_chars (p, value, 2);
	  alloc_frag->tc_frag_data += size;
	  if (alloc_frag->tc_frag_data == 16)
	    alloc_frag->tc_frag_data = 0;
	}
    }
 getout:
  demand_empty_rest_of_line ();
}

/* Ideally, we want to check SEC_LOAD and SEC_HAS_CONTENTS, but those aren't
   available yet.  seg_info ()->bss is the next best thing.  */

static int
tic54x_initialized_section (segT seg)
{
  return !seg_info (seg)->bss;
}

/* .clink ["section name"]

   Marks the section as conditionally linked (link only if contents are
   referenced elsewhere.
   Without a name, refers to the current initialized section.
   Name is required for uninitialized sections.  */

static void
tic54x_clink (int ignored ATTRIBUTE_UNUSED)
{
  segT seg = now_seg;

  ILLEGAL_WITHIN_STRUCT ();

  if (*input_line_pointer == '\"')
    {
      char *section_name = ++input_line_pointer;
      char *name;

      while (is_a_char (next_char_of_string ()))
	;
      know (input_line_pointer[-1] == '\"');
      input_line_pointer[-1] = 0;
      name = xmalloc (input_line_pointer - section_name + 1);
      strcpy (name, section_name);

      seg = bfd_get_section_by_name (stdoutput, name);
      if (seg == NULL)
	{
	  as_bad (_("Unrecognized section '%s'"), section_name);
	  ignore_rest_of_line ();
	  return;
	}
    }
  else
    {
      if (!tic54x_initialized_section (seg))
	{
	  as_bad (_("Current section is unitialized, "
		    "section name required for .clink"));
	  ignore_rest_of_line ();
	  return;
	}
    }

  seg->flags |= SEC_TIC54X_CLINK;

  demand_empty_rest_of_line ();
}

/* Change the default include directory to be the current source file's
   directory, instead of the current working directory.  If DOT is non-zero,
   set to "." instead.  */

static void
tic54x_set_default_include (int dot)
{
  char *dir = ".";
  char *tmp = NULL;

  if (!dot)
    {
      char *curfile;
      unsigned lineno;

      as_where (&curfile, &lineno);
      dir = strcpy (xmalloc (strlen (curfile) + 1), curfile);
      tmp = strrchr (dir, '/');
    }
  if (tmp != NULL)
    {
      int len;

      *tmp = '\0';
      len = strlen (dir);
      if (include_dir_count == 0)
	{
	  include_dirs = (char **) xmalloc (sizeof (*include_dirs));
	  include_dir_count = 1;
	}
      include_dirs[0] = dir;
      if (len > include_dir_maxlen)
	include_dir_maxlen = len;
    }
  else if (include_dirs != NULL)
    include_dirs[0] = ".";
}

/* .include "filename" | filename
   .copy    "filename" | filename

   FIXME 'include' file should be omitted from any output listing,
     'copy' should be included in any output listing
   FIXME -- prevent any included files from changing listing (compat only)
   FIXME -- need to include source file directory in search path; what's a
      good way to do this?

   Entering/exiting included/copied file clears all local labels.  */

static void
tic54x_include (int ignored ATTRIBUTE_UNUSED)
{
  char newblock[] = " .newblock\n";
  char *filename;
  char *input;
  int len, c = -1;

  ILLEGAL_WITHIN_STRUCT ();

  SKIP_WHITESPACE ();

  if (*input_line_pointer == '"')
    {
      filename = demand_copy_C_string (&len);
      demand_empty_rest_of_line ();
    }
  else
    {
      filename = input_line_pointer;
      while (!is_end_of_line[(int) *input_line_pointer])
	++input_line_pointer;
      c = *input_line_pointer;
      *input_line_pointer = '\0';
      filename = strcpy (xmalloc (strlen (filename) + 1), filename);
      *input_line_pointer = c;
      demand_empty_rest_of_line ();
    }
  /* Insert a partial line with the filename (for the sake of s_include)
     and a .newblock.
     The included file will be inserted before the newblock, so that the
     newblock is executed after the included file is processed.  */
  input = xmalloc (sizeof (newblock) + strlen (filename) + 4);
  sprintf (input, "\"%s\"\n%s", filename, newblock);
  input_scrub_insert_line (input);

  tic54x_clear_local_labels (0);

  tic54x_set_default_include (0);

  s_include (0);
}

static void
tic54x_message (int type)
{
  char *msg;
  char c;
  int len;

  ILLEGAL_WITHIN_STRUCT ();

  if (*input_line_pointer == '"')
    msg = demand_copy_C_string (&len);
  else
    {
      msg = input_line_pointer;
      while (!is_end_of_line[(int) *input_line_pointer])
	++input_line_pointer;
      c = *input_line_pointer;
      *input_line_pointer = 0;
      msg = strcpy (xmalloc (strlen (msg) + 1), msg);
      *input_line_pointer = c;
    }

  switch (type)
    {
    case 'm':
      as_tsktsk ("%s", msg);
      break;
    case 'w':
      as_warn ("%s", msg);
      break;
    case 'e':
      as_bad ("%s", msg);
      break;
    }

  demand_empty_rest_of_line ();
}

/* .label <symbol>
   Define a special symbol that refers to the loadtime address rather than the
   runtime address within the current section.

   This symbol gets a special storage class so that when it is resolved, it is
   resolved relative to the load address (lma) of the section rather than the
   run address (vma).  */

static void
tic54x_label (int ignored ATTRIBUTE_UNUSED)
{
  char *name = input_line_pointer;
  symbolS *symbolP;
  int c;

  ILLEGAL_WITHIN_STRUCT ();

  c = get_symbol_end ();
  symbolP = colon (name);
  S_SET_STORAGE_CLASS (symbolP, C_STATLAB);

  *input_line_pointer = c;
  demand_empty_rest_of_line ();
}

/* .mmregs
   Install all memory-mapped register names into the symbol table as
   absolute local symbols.  */

static void
tic54x_mmregs (int ignored ATTRIBUTE_UNUSED)
{
  symbol *sym;

  ILLEGAL_WITHIN_STRUCT ();

  for (sym = (symbol *) mmregs; sym->name; sym++)
    {
      symbolS *symbolP = symbol_new (sym->name, absolute_section,
				     (valueT) sym->value, &zero_address_frag);
      SF_SET_LOCAL (symbolP);
      symbol_table_insert (symbolP);
    }
}

/* .loop [count]
   Count defaults to 1024.  */

static void
tic54x_loop (int count)
{
  ILLEGAL_WITHIN_STRUCT ();

  SKIP_WHITESPACE ();
  if (!is_end_of_line[(int) *input_line_pointer])
    count = get_absolute_expression ();

  do_repeat (count, "LOOP", "ENDLOOP");
}

/* Normally, endloop gets eaten by the preceding loop.  */

static void
tic54x_endloop (int ignore ATTRIBUTE_UNUSED)
{
  as_bad (_("ENDLOOP without corresponding LOOP"));
  ignore_rest_of_line ();
}

/* .break [condition].  */

static void
tic54x_break (int ignore ATTRIBUTE_UNUSED)
{
  int cond = 1;

  ILLEGAL_WITHIN_STRUCT ();

  SKIP_WHITESPACE ();
  if (!is_end_of_line[(int) *input_line_pointer])
    cond = get_absolute_expression ();

  if (cond)
    end_repeat (substitution_line ? 1 : 0);
}

static void
set_address_mode (int mode)
{
  amode = mode;
  if (mode == far_mode)
    {
      symbolS *symbolP = symbol_new ("__allow_far", absolute_section,
				     (valueT) 1, &zero_address_frag);
      SF_SET_LOCAL (symbolP);
      symbol_table_insert (symbolP);
    }
}

static int address_mode_needs_set = 1;

static void
tic54x_address_mode (int mode)
{
  if (assembly_begun && amode != (unsigned) mode)
    {
      as_bad (_("Mixing of normal and extended addressing not supported"));
      ignore_rest_of_line ();
      return;
    }
  if (mode == far_mode && cpu != VNONE && cpu != V548 && cpu != V549)
    {
      as_bad (_("Extended addressing not supported on the specified CPU"));
      ignore_rest_of_line ();
      return;
    }

  set_address_mode (mode);
  demand_empty_rest_of_line ();
}

/* .sblock "section"|section [,...,"section"|section]
   Designate initialized sections for blocking.  */

static void
tic54x_sblock (int ignore ATTRIBUTE_UNUSED)
{
  int c = ',';

  ILLEGAL_WITHIN_STRUCT ();

  while (c == ',')
    {
      segT seg;
      char *name;

      if (*input_line_pointer == '"')
	{
	  int len;

	  name = demand_copy_C_string (&len);
	}
      else
	{
	  char *section_name = input_line_pointer;

	  c = get_symbol_end ();
	  name = xmalloc (strlen (section_name) + 1);
	  strcpy (name, section_name);
	  *input_line_pointer = c;
	}

      seg = bfd_get_section_by_name (stdoutput, name);
      if (seg == NULL)
	{
	  as_bad (_("Unrecognized section '%s'"), name);
	  ignore_rest_of_line ();
	  return;
	}
      else if (!tic54x_initialized_section (seg))
	{
	  as_bad (_(".sblock may be used for initialized sections only"));
	  ignore_rest_of_line ();
	  return;
	}
      seg->flags |= SEC_TIC54X_BLOCK;

      c = *input_line_pointer;
      if (!is_end_of_line[(int) c])
	++input_line_pointer;
    }

  demand_empty_rest_of_line ();
}

/* symbol .set value
   symbol .equ value

   value must be defined externals; no forward-referencing allowed
   symbols assigned with .set/.equ may not be redefined.  */

static void
tic54x_set (int ignore ATTRIBUTE_UNUSED)
{
  symbolS *symbolP;
  char *name;

  ILLEGAL_WITHIN_STRUCT ();

  if (!line_label)
    {
      as_bad (_("Symbol missing for .set/.equ"));
      ignore_rest_of_line ();
      return;
    }
  name = xstrdup (S_GET_NAME (line_label));
  line_label = NULL;
  if ((symbolP = symbol_find (name)) == NULL
      && (symbolP = md_undefined_symbol (name)) == NULL)
    {
      symbolP = symbol_new (name, absolute_section, 0, &zero_address_frag);
      S_SET_STORAGE_CLASS (symbolP, C_STAT);
    }
  free (name);
  S_SET_DATA_TYPE (symbolP, T_INT);
  S_SET_SEGMENT (symbolP, absolute_section);
  symbol_table_insert (symbolP);
  pseudo_set (symbolP);
  demand_empty_rest_of_line ();
}

/* .fclist
   .fcnolist
   List false conditional blocks.  */

static void
tic54x_fclist (int show)
{
  if (show)
    listing &= ~LISTING_NOCOND;
  else
    listing |= LISTING_NOCOND;
  demand_empty_rest_of_line ();
}

static void
tic54x_sslist (int show)
{
  ILLEGAL_WITHIN_STRUCT ();

  listing_sslist = show;
}

/* .var SYM[,...,SYMN]
   Define a substitution string to be local to a macro.  */

static void
tic54x_var (int ignore ATTRIBUTE_UNUSED)
{
  static char empty[] = "";
  char *name;
  int c;

  ILLEGAL_WITHIN_STRUCT ();

  if (macro_level == 0)
    {
      as_bad (_(".var may only be used within a macro definition"));
      ignore_rest_of_line ();
      return;
    }
  do
    {
      if (!ISALPHA (*input_line_pointer))
	{
	  as_bad (_("Substitution symbols must begin with a letter"));
	  ignore_rest_of_line ();
	  return;
	}
      name = input_line_pointer;
      c = get_symbol_end ();
      /* .var symbols start out with a null string.  */
      name = strcpy (xmalloc (strlen (name) + 1), name);
      hash_insert (subsym_hash[macro_level], name, empty);
      *input_line_pointer = c;
      if (c == ',')
	{
	  ++input_line_pointer;
	  if (is_end_of_line[(int) *input_line_pointer])
	    c = *input_line_pointer;
	}
    }
  while (c == ',');

  demand_empty_rest_of_line ();
}

/* .mlib <macro library filename>

   Macro libraries are archived (standard AR-format) text macro definitions
   Expand the file and include it.

   FIXME need to try the source file directory as well.  */

static void
tic54x_mlib (int ignore ATTRIBUTE_UNUSED)
{
  char *filename;
  char *path;
  int len, i;
  bfd *abfd, *mbfd;

  ILLEGAL_WITHIN_STRUCT ();

  /* Parse the filename.  */
  if (*input_line_pointer == '"')
    {
      if ((filename = demand_copy_C_string (&len)) == NULL)
	return;
    }
  else
    {
      SKIP_WHITESPACE ();
      len = 0;
      while (!is_end_of_line[(int) *input_line_pointer]
	     && !ISSPACE (*input_line_pointer))
	{
	  obstack_1grow (&notes, *input_line_pointer);
	  ++input_line_pointer;
	  ++len;
	}
      obstack_1grow (&notes, '\0');
      filename = obstack_finish (&notes);
    }
  demand_empty_rest_of_line ();

  tic54x_set_default_include (0);
  path = xmalloc ((unsigned long) len + include_dir_maxlen + 5);

  for (i = 0; i < include_dir_count; i++)
    {
      FILE *try;

      strcpy (path, include_dirs[i]);
      strcat (path, "/");
      strcat (path, filename);
      if ((try = fopen (path, "r")) != NULL)
	{
	  fclose (try);
	  break;
	}
    }

  if (i >= include_dir_count)
    {
      free (path);
      path = filename;
    }

  /* FIXME: if path is found, malloc'd storage is not freed.  Of course, this
     happens all over the place, and since the assembler doesn't usually keep
     running for a very long time, it really doesn't matter.  */
  register_dependency (path);

  /* Expand all archive entries to temporary files and include them.  */
  abfd = bfd_openr (path, NULL);
  if (!abfd)
    {
      as_bad (_("can't open macro library file '%s' for reading: %s"),
	      path, bfd_errmsg (bfd_get_error ()));
      ignore_rest_of_line ();
      return;
    }
  if (!bfd_check_format (abfd, bfd_archive))
    {
      as_bad (_("File '%s' not in macro archive format"), path);
      ignore_rest_of_line ();
      return;
    }

  /* Open each BFD as binary (it should be straight ASCII text).  */
  for (mbfd = bfd_openr_next_archived_file (abfd, NULL);
       mbfd != NULL; mbfd = bfd_openr_next_archived_file (abfd, mbfd))
    {
      /* Get a size at least as big as the archive member.  */
      bfd_size_type size = bfd_get_size (mbfd);
      char *buf = xmalloc (size);
      char *fname = tmpnam (NULL);
      FILE *ftmp;

      /* We're not sure how big it is, but it will be smaller than "size".  */
      bfd_bread (buf, size, mbfd);

      /* Write to a temporary file, then use s_include to include it
	 a bit of a hack.  */
      ftmp = fopen (fname, "w+b");
      fwrite ((void *) buf, size, 1, ftmp);
      if (buf[size - 1] != '\n')
	fwrite ("\n", 1, 1, ftmp);
      fclose (ftmp);
      free (buf);
      input_scrub_insert_file (fname);
      unlink (fname);
    }
}

const pseudo_typeS md_pseudo_table[] =
{
  { "algebraic", s_ignore                 ,          0 },
  { "align"    , tic54x_align_words       ,        128 },
  { "ascii"    , tic54x_stringer          ,        'p' },
  { "asciz"    , tic54x_stringer          ,        'P' },
  { "even"     , tic54x_align_words       ,          2 },
  { "asg"      , tic54x_asg               ,          0 },
  { "eval"     , tic54x_eval              ,          0 },
  { "bss"      , tic54x_bss               ,          0 },
  { "byte"     , tic54x_cons              ,        'b' },
  { "ubyte"    , tic54x_cons              ,        'B' },
  { "char"     , tic54x_cons              ,        'c' },
  { "uchar"    , tic54x_cons              ,        'C' },
  { "clink"    , tic54x_clink             ,          0 },
  { "c_mode"   , tic54x_address_mode      ,     c_mode },
  { "copy"     , tic54x_include           ,        'c' },
  { "include"  , tic54x_include           ,        'i' },
  { "data"     , tic54x_sect              ,        'd' },
  { "double"   , tic54x_float_cons        ,        'd' },
  { "ldouble"  , tic54x_float_cons        ,        'l' },
  { "drlist"   , s_ignore                 ,          0 },
  { "drnolist" , s_ignore                 ,          0 },
  { "emsg"     , tic54x_message           ,        'e' },
  { "mmsg"     , tic54x_message           ,        'm' },
  { "wmsg"     , tic54x_message           ,        'w' },
  { "far_mode" , tic54x_address_mode      ,   far_mode },
  { "fclist"   , tic54x_fclist            ,          1 },
  { "fcnolist" , tic54x_fclist            ,          0 },
  { "field"    , tic54x_field             ,         -1 },
  { "float"    , tic54x_float_cons        ,        'f' },
  { "xfloat"   , tic54x_float_cons        ,        'x' },
  { "global"   , tic54x_global            ,        'g' },
  { "def"      , tic54x_global            ,        'd' },
  { "ref"      , tic54x_global            ,        'r' },
  { "half"     , tic54x_cons              ,        'h' },
  { "uhalf"    , tic54x_cons              ,        'H' },
  { "short"    , tic54x_cons              ,        's' },
  { "ushort"   , tic54x_cons              ,        'S' },
  { "if"       , s_if                     , (int) O_ne },
  { "elseif"   , s_elseif                 , (int) O_ne },
  { "else"     , s_else                   ,          0 },
  { "endif"    , s_endif                  ,          0 },
  { "int"      , tic54x_cons              ,        'i' },
  { "uint"     , tic54x_cons              ,        'I' },
  { "word"     , tic54x_cons              ,        'w' },
  { "uword"    , tic54x_cons              ,        'W' },
  { "label"    , tic54x_label             ,          0 }, /* Loadtime
                                                             address.  */
  { "length"   , s_ignore                 ,          0 },
  { "width"    , s_ignore                 ,          0 },
  { "long"     , tic54x_cons              ,        'l' },
  { "ulong"    , tic54x_cons              ,        'L' },
  { "xlong"    , tic54x_cons              ,        'x' },
  { "loop"     , tic54x_loop              ,       1024 },
  { "break"    , tic54x_break             ,          0 },
  { "endloop"  , tic54x_endloop           ,          0 },
  { "mlib"     , tic54x_mlib              ,          0 },
  { "mlist"    , s_ignore                 ,          0 },
  { "mnolist"  , s_ignore                 ,          0 },
  { "mmregs"   , tic54x_mmregs            ,          0 },
  { "newblock" , tic54x_clear_local_labels,          0 },
  { "option"   , s_ignore                 ,          0 },
  { "p2align"  , tic54x_p2align           ,          0 },
  { "sblock"   , tic54x_sblock            ,          0 },
  { "sect"     , tic54x_sect              ,        '*' },
  { "set"      , tic54x_set               ,          0 },
  { "equ"      , tic54x_set               ,          0 },
  { "space"    , tic54x_space             ,          0 },
  { "bes"      , tic54x_space             ,          1 },
  { "sslist"   , tic54x_sslist            ,          1 },
  { "ssnolist" , tic54x_sslist            ,          0 },
  { "string"   , tic54x_stringer          ,        's' },
  { "pstring"  , tic54x_stringer          ,        'p' },
  { "struct"   , tic54x_struct            ,          0 },
  { "tag"      , tic54x_tag               ,          0 },
  { "endstruct", tic54x_endstruct         ,          0 },
  { "tab"      , s_ignore                 ,          0 },
  { "text"     , tic54x_sect              ,        't' },
  { "union"    , tic54x_struct            ,          1 },
  { "endunion" , tic54x_endstruct         ,          1 },
  { "usect"    , tic54x_usect             ,          0 },
  { "var"      , tic54x_var               ,          0 },
  { "version"  , tic54x_version           ,          0 },
  {0           , 0                        ,          0 }
};

int
md_parse_option (int c, char *arg)
{
  switch (c)
    {
    default:
      return 0;
    case OPTION_COFF_VERSION:
      {
	int version = atoi (arg);

	if (version != 0 && version != 1 && version != 2)
	  as_fatal (_("Bad COFF version '%s'"), arg);
	/* FIXME -- not yet implemented.  */
	break;
      }
    case OPTION_CPU_VERSION:
      {
	cpu = lookup_version (arg);
	cpu_needs_set = 1;
	if (cpu == VNONE)
	  as_fatal (_("Bad CPU version '%s'"), arg);
	break;
      }
    case OPTION_ADDRESS_MODE:
      amode = far_mode;
      address_mode_needs_set = 1;
      break;
    case OPTION_STDERR_TO_FILE:
      {
	char *filename = arg;
	FILE *fp = fopen (filename, "w+");

	if (fp == NULL)
	  as_fatal (_("Can't redirect stderr to the file '%s'"), filename);
	fclose (fp);
	if ((fp = freopen (filename, "w+", stderr)) == NULL)
	  as_fatal (_("Can't redirect stderr to the file '%s'"), filename);
	break;
      }
    }

  return 1;
}

/* Create a "local" substitution string hash table for a new macro level
   Some docs imply that macros have to use .newblock in order to be able
   to re-use a local label.  We effectively do an automatic .newblock by
   deleting the local label hash between macro invocations.  */

void
tic54x_macro_start (void)
{
  ++macro_level;
  subsym_hash[macro_level] = hash_new ();
  local_label_hash[macro_level] = hash_new ();
}

void
tic54x_macro_info (const macro_entry *macro)
{
  const formal_entry *entry;

  /* Put the formal args into the substitution symbol table.  */
  for (entry = macro->formals; entry; entry = entry->next)
    {
      char *name = strncpy (xmalloc (entry->name.len + 1),
			    entry->name.ptr, entry->name.len);
      char *value = strncpy (xmalloc (entry->actual.len + 1),
			     entry->actual.ptr, entry->actual.len);

      name[entry->name.len] = '\0';
      value[entry->actual.len] = '\0';
      hash_insert (subsym_hash[macro_level], name, value);
    }
}

/* Get rid of this macro's .var's, arguments, and local labels.  */

void
tic54x_macro_end (void)
{
  hash_die (subsym_hash[macro_level]);
  subsym_hash[macro_level] = NULL;
  hash_die (local_label_hash[macro_level]);
  local_label_hash[macro_level] = NULL;
  --macro_level;
}

static int
subsym_symlen (char *a, char *ignore ATTRIBUTE_UNUSED)
{
  return strlen (a);
}

/* Compare symbol A to string B.  */

static int
subsym_symcmp (char *a, char *b)
{
  return strcmp (a, b);
}

/* Return the index of the first occurrence of B in A, or zero if none
   assumes b is an integer char value as a string.  Index is one-based.  */

static int
subsym_firstch (char *a, char *b)
{
  int val = atoi (b);
  char *tmp = strchr (a, val);

  return tmp ? tmp - a + 1 : 0;
}

/* Similar to firstch, but returns index of last occurrence of B in A.  */

static int
subsym_lastch (char *a, char *b)
{
  int val = atoi (b);
  char *tmp = strrchr (a, val);

  return tmp ? tmp - a + 1 : 0;
}

/* Returns 1 if string A is defined in the symbol table (NOT the substitution
   symbol table).  */

static int
subsym_isdefed (char *a, char *ignore ATTRIBUTE_UNUSED)
{
  symbolS *symbolP = symbol_find (a);

  return symbolP != NULL;
}

/* Assign first member of comma-separated list B (e.g. "1,2,3") to the symbol
   A, or zero if B is a null string.  Both arguments *must* be substitution
   symbols, unsubstituted.  */

static int
subsym_ismember (char *sym, char *list)
{
  char *elem, *ptr, *listv;

  if (!list)
    return 0;

  listv = subsym_lookup (list, macro_level);
  if (!listv)
    {
      as_bad (_("Undefined substitution symbol '%s'"), list);
      ignore_rest_of_line ();
      return 0;
    }

  ptr = elem = xmalloc (strlen (listv) + 1);
  strcpy (elem, listv);
  while (*ptr && *ptr != ',')
    ++ptr;
  *ptr++ = 0;

  subsym_create_or_replace (sym, elem);

  /* Reassign the list.  */
  subsym_create_or_replace (list, ptr);

  /* Assume this value, docs aren't clear.  */
  return *list != 0;
}

/* Return zero if not a constant; otherwise:
   1 if binary
   2 if octal
   3 if hexadecimal
   4 if character
   5 if decimal.  */

static int
subsym_iscons (char *a, char *ignore ATTRIBUTE_UNUSED)
{
  expressionS expn;

  parse_expression (a, &expn);

  if (expn.X_op == O_constant)
    {
      int len = strlen (a);

      switch (TOUPPER (a[len - 1]))
	{
	case 'B':
	  return 1;
	case 'Q':
	  return 2;
	case 'H':
	  return 3;
	case '\'':
	  return 4;
	default:
	  break;
	}
      /* No suffix; either octal, hex, or decimal.  */
      if (*a == '0' && len > 1)
	{
	  if (TOUPPER (a[1]) == 'X')
	    return 3;
	  return 2;
	}
      return 5;
    }

  return 0;
}

/* Return 1 if A is a valid symbol name.  Expects string input.   */

static int
subsym_isname (char *a, char *ignore ATTRIBUTE_UNUSED)
{
  if (!is_name_beginner (*a))
    return 0;
  while (*a)
    {
      if (!is_part_of_name (*a))
	return 0;
      ++a;
    }
  return 1;
}

/* Return whether the string is a register; accepts ar0-7, unless .mmregs has
   been seen; if so, recognize any memory-mapped register.
   Note this does not recognize "A" or "B" accumulators.  */

static int
subsym_isreg (char *a, char *ignore ATTRIBUTE_UNUSED)
{
  if (hash_find (reg_hash, a))
    return 1;
  if (hash_find (mmreg_hash, a))
    return 1;
  return 0;
}

/* Return the structure size, given the stag.  */

static int
subsym_structsz (char *name, char *ignore ATTRIBUTE_UNUSED)
{
  struct stag *stag = (struct stag *) hash_find (stag_hash, name);

  if (stag)
    return stag->size;

  return 0;
}

/* If anybody actually uses this, they can fix it :)
   FIXME I'm not sure what the "reference point" of a structure is.  It might
   be either the initial offset given .struct, or it may be the offset of the
   structure within another structure, or it might be something else
   altogether.  since the TI assembler doesn't seem to ever do anything but
   return zero, we punt and return zero.  */

static int
subsym_structacc (char *stag_name ATTRIBUTE_UNUSED,
		  char *ignore ATTRIBUTE_UNUSED)
{
  return 0;
}

static float
math_ceil (float arg1, float ignore ATTRIBUTE_UNUSED)
{
  return (float) ceil (arg1);
}

static float
math_cvi (float arg1, float ignore ATTRIBUTE_UNUSED)
{
  return (int) arg1;
}

static float
math_floor (float arg1, float ignore ATTRIBUTE_UNUSED)
{
  return (float) floor (arg1);
}

static float
math_fmod (float arg1, float arg2)
{
  return (int) arg1 % (int) arg2;
}

static float
math_int (float arg1, float ignore ATTRIBUTE_UNUSED)
{
  return ((float) ((int) arg1)) == arg1;
}

static float
math_round (float arg1, float ignore ATTRIBUTE_UNUSED)
{
  return arg1 > 0 ? (int) (arg1 + 0.5) : (int) (arg1 - 0.5);
}

static float
math_sgn (float arg1, float ignore ATTRIBUTE_UNUSED)
{
  return (arg1 < 0) ? -1 : (arg1 ? 1 : 0);
}

static float
math_trunc (float arg1, float ignore ATTRIBUTE_UNUSED)
{
  return (int) arg1;
}

static float
math_acos (float arg1, float ignore ATTRIBUTE_UNUSED)
{
  return (float) acos (arg1);
}

static float
math_asin (float arg1, float ignore ATTRIBUTE_UNUSED)
{
  return (float) asin (arg1);
}

static float
math_atan (float arg1, float ignore ATTRIBUTE_UNUSED)
{
  return (float) atan (arg1);
}

static float
math_atan2 (float arg1, float arg2)
{
  return (float) atan2 (arg1, arg2);
}

static float
math_cosh (float arg1, float ignore ATTRIBUTE_UNUSED)
{
  return (float) cosh (arg1);
}

static float
math_cos (float arg1, float ignore ATTRIBUTE_UNUSED)
{
  return (float) cos (arg1);
}

static float
math_cvf (float arg1, float ignore ATTRIBUTE_UNUSED)
{
  return (float) arg1;
}

static float
math_exp (float arg1, float ignore ATTRIBUTE_UNUSED)
{
  return (float) exp (arg1);
}

static float
math_fabs (float arg1, float ignore ATTRIBUTE_UNUSED)
{
  return (float) fabs (arg1);
}

/* expr1 * 2^expr2.  */

static float
math_ldexp (float arg1, float arg2)
{
  return arg1 * (float) pow (2.0, arg2);
}

static float
math_log10 (float arg1, float ignore ATTRIBUTE_UNUSED)
{
  return (float) log10 (arg1);
}

static float
math_log (float arg1, float ignore ATTRIBUTE_UNUSED)
{
  return (float) log (arg1);
}

static float
math_max (float arg1, float arg2)
{
  return (arg1 > arg2) ? arg1 : arg2;
}

static float
math_min (float arg1, float arg2)
{
  return (arg1 < arg2) ? arg1 : arg2;
}

static float
math_pow (float arg1, float arg2)
{
  return (float) pow (arg1, arg2);
}

static float
math_sin (float arg1, float ignore ATTRIBUTE_UNUSED)
{
  return (float) sin (arg1);
}

static float
math_sinh (float arg1, float ignore ATTRIBUTE_UNUSED)
{
  return (float) sinh (arg1);
}

static float
math_sqrt (float arg1, float ignore ATTRIBUTE_UNUSED)
{
  return (float) sqrt (arg1);
}

static float
math_tan (float arg1, float ignore ATTRIBUTE_UNUSED)
{
  return (float) tan (arg1);
}

static float
math_tanh (float arg1, float ignore ATTRIBUTE_UNUSED)
{
  return (float) tanh (arg1);
}

/* Built-in substitution symbol functions and math functions.  */
typedef struct
{
  char *name;
  int (*proc) (char *, char *);
  int nargs;
} subsym_proc_entry;

static const subsym_proc_entry subsym_procs[] =
{
  /* Assembler built-in string substitution functions.  */
  { "$symlen", subsym_symlen, 1,  },
  { "$symcmp", subsym_symcmp, 2,  },
  { "$firstch", subsym_firstch, 2,  },
  { "$lastch", subsym_lastch, 2,  },
  { "$isdefed", subsym_isdefed, 1,  },
  { "$ismember", subsym_ismember, 2,  },
  { "$iscons", subsym_iscons, 1,  },
  { "$isname", subsym_isname, 1,  },
  { "$isreg", subsym_isreg, 1,  },
  { "$structsz", subsym_structsz, 1,  },
  { "$structacc", subsym_structacc, 1,  },
  { NULL, NULL, 0 },
};

typedef struct
{
  char *name;
  float (*proc) (float, float);
  int nargs;
  int int_return;
} math_proc_entry;

static const math_proc_entry math_procs[] =
{
  /* Integer-returning built-in math functions.  */
  { "$cvi", math_cvi, 1, 1 },
  { "$int", math_int, 1, 1 },
  { "$sgn", math_sgn, 1, 1 },

  /* Float-returning built-in math functions.  */
  { "$acos", math_acos, 1, 0 },
  { "$asin", math_asin, 1, 0 },
  { "$atan", math_atan, 1, 0 },
  { "$atan2", math_atan2, 2, 0 },
  { "$ceil", math_ceil, 1, 0 },
  { "$cosh", math_cosh, 1, 0 },
  { "$cos", math_cos, 1, 0 },
  { "$cvf", math_cvf, 1, 0 },
  { "$exp", math_exp, 1, 0 },
  { "$fabs", math_fabs, 1, 0 },
  { "$floor", math_floor, 1, 0 },
  { "$fmod", math_fmod, 2, 0 },
  { "$ldexp", math_ldexp, 2, 0 },
  { "$log10", math_log10, 1, 0 },
  { "$log", math_log, 1, 0 },
  { "$max", math_max, 2, 0 },
  { "$min", math_min, 2, 0 },
  { "$pow", math_pow, 2, 0 },
  { "$round", math_round, 1, 0 },
  { "$sin", math_sin, 1, 0 },
  { "$sinh", math_sinh, 1, 0 },
  { "$sqrt", math_sqrt, 1, 0 },
  { "$tan", math_tan, 1, 0 },
  { "$tanh", math_tanh, 1, 0 },
  { "$trunc", math_trunc, 1, 0 },
  { NULL, NULL, 0, 0 },
};

void
md_begin (void)
{
  insn_template *tm;
  symbol *sym;
  const subsym_proc_entry *subsym_proc;
  const math_proc_entry *math_proc;
  const char *hash_err;
  char **symname;
  char *TIC54X_DIR = getenv ("TIC54X_DIR");
  char *A_DIR = TIC54X_DIR ? TIC54X_DIR : getenv ("A_DIR");

  local_label_id = 0;

  /* Look for A_DIR and add it to the include list.  */
  if (A_DIR != NULL)
    {
      char *tmp = xstrdup (A_DIR);

      do
	{
	  char *next = strchr (tmp, ';');

	  if (next)
	    *next++ = '\0';
	  add_include_dir (tmp);
	  tmp = next;
	}
      while (tmp != NULL);
    }

  op_hash = hash_new ();
  for (tm = (insn_template *) tic54x_optab; tm->name; tm++)
    {
      if (hash_find (op_hash, tm->name))
	continue;
      hash_err = hash_insert (op_hash, tm->name, (char *) tm);
      if (hash_err)
	as_fatal ("Internal Error: Can't hash %s: %s",
		  tm->name, hash_err);
    }
  parop_hash = hash_new ();
  for (tm = (insn_template *) tic54x_paroptab; tm->name; tm++)
    {
      if (hash_find (parop_hash, tm->name))
	continue;
      hash_err = hash_insert (parop_hash, tm->name, (char *) tm);
      if (hash_err)
	as_fatal ("Internal Error: Can't hash %s: %s",
		  tm->name, hash_err);
    }
  reg_hash = hash_new ();
  for (sym = (symbol *) regs; sym->name; sym++)
    {
      /* Add basic registers to the symbol table.  */
      symbolS *symbolP = symbol_new (sym->name, absolute_section,
				     (valueT) sym->value, &zero_address_frag);
      SF_SET_LOCAL (symbolP);
      symbol_table_insert (symbolP);
      hash_err = hash_insert (reg_hash, sym->name, (char *) sym);
    }
  for (sym = (symbol *) mmregs; sym->name; sym++)
    hash_err = hash_insert (reg_hash, sym->name, (char *) sym);
  mmreg_hash = hash_new ();
  for (sym = (symbol *) mmregs; sym->name; sym++)
    hash_err = hash_insert (mmreg_hash, sym->name, (char *) sym);

  cc_hash = hash_new ();
  for (sym = (symbol *) condition_codes; sym->name; sym++)
    hash_err = hash_insert (cc_hash, sym->name, (char *) sym);

  cc2_hash = hash_new ();
  for (sym = (symbol *) cc2_codes; sym->name; sym++)
    hash_err = hash_insert (cc2_hash, sym->name, (char *) sym);

  cc3_hash = hash_new ();
  for (sym = (symbol *) cc3_codes; sym->name; sym++)
    hash_err = hash_insert (cc3_hash, sym->name, (char *) sym);

  sbit_hash = hash_new ();
  for (sym = (symbol *) status_bits; sym->name; sym++)
    hash_err = hash_insert (sbit_hash, sym->name, (char *) sym);

  misc_symbol_hash = hash_new ();
  for (symname = (char **) misc_symbols; *symname; symname++)
    hash_err = hash_insert (misc_symbol_hash, *symname, *symname);

  /* Only the base substitution table and local label table are initialized;
     the others (for local macro substitution) get instantiated as needed.  */
  local_label_hash[0] = hash_new ();
  subsym_hash[0] = hash_new ();
  for (subsym_proc = subsym_procs; subsym_proc->name; subsym_proc++)
    hash_err = hash_insert (subsym_hash[0], subsym_proc->name,
			    (char *) subsym_proc);

  math_hash = hash_new ();
  for (math_proc = math_procs; math_proc->name; math_proc++)
    {
      /* Insert into the main subsym hash for recognition; insert into
	 the math hash to actually store information.  */
      hash_err = hash_insert (subsym_hash[0], math_proc->name,
			      (char *) math_proc);
      hash_err = hash_insert (math_hash, math_proc->name,
			      (char *) math_proc);
    }
  subsym_recurse_hash = hash_new ();
  stag_hash = hash_new ();
}

static int
is_accumulator (struct opstruct *operand)
{
  return strcasecmp (operand->buf, "a") == 0
    || strcasecmp (operand->buf, "b") == 0;
}

/* Return the number of operands found, or -1 on error, copying the
   operands into the given array and the accompanying expressions into
   the next array.  */

static int
get_operands (struct opstruct operands[], char *line)
{
  char *lptr = line;
  int numexp = 0;
  int expecting_operand = 0;
  int i;

  while (numexp < MAX_OPERANDS && !is_end_of_line[(int) *lptr])
    {
      int paren_not_balanced = 0;
      char *op_start, *op_end;

      while (*lptr && ISSPACE (*lptr))
	++lptr;
      op_start = lptr;
      while (paren_not_balanced || *lptr != ',')
	{
	  if (*lptr == '\0')
	    {
	      if (paren_not_balanced)
		{
		  as_bad (_("Unbalanced parenthesis in operand %d"), numexp);
		  return -1;
		}
	      else
		break;
	    }
	  if (*lptr == '(')
	    ++paren_not_balanced;
	  else if (*lptr == ')')
	    --paren_not_balanced;
	  ++lptr;
	}
      op_end = lptr;
      if (op_end != op_start)
	{
	  int len = op_end - op_start;

	  strncpy (operands[numexp].buf, op_start, len);
	  operands[numexp].buf[len] = 0;
	  /* Trim trailing spaces; while the preprocessor gets rid of most,
	     there are weird usage patterns that can introduce them
	     (i.e. using strings for macro args).  */
	  while (len > 0 && ISSPACE (operands[numexp].buf[len - 1]))
	    operands[numexp].buf[--len] = 0;
	  lptr = op_end;
	  ++numexp;
	}
      else
	{
	  if (expecting_operand || *lptr == ',')
	    {
	      as_bad (_("Expecting operand after ','"));
	      return -1;
	    }
	}
      if (*lptr == ',')
	{
	  if (*++lptr == '\0')
	    {
	      as_bad (_("Expecting operand after ','"));
	      return -1;
	    }
	  expecting_operand = 1;
	}
    }

  while (*lptr && ISSPACE (*lptr++))
    ;
  if (!is_end_of_line[(int) *lptr])
    {
      as_bad (_("Extra junk on line"));
      return -1;
    }

  /* OK, now parse them into expressions.  */
  for (i = 0; i < numexp; i++)
    {
      memset (&operands[i].exp, 0, sizeof (operands[i].exp));
      if (operands[i].buf[0] == '#')
	{
	  /* Immediate.  */
	  parse_expression (operands[i].buf + 1, &operands[i].exp);
	}
      else if (operands[i].buf[0] == '@@')
	{
	  /* Direct notation.  */
	  parse_expression (operands[i].buf + 1, &operands[i].exp);
	}
      else if (operands[i].buf[0] == '*')
	{
	  /* Indirect.  */
	  char *paren = strchr (operands[i].buf, '(');

	  /* Allow immediate syntax in the inner expression.  */
	  if (paren && paren[1] == '#')
	    *++paren = '(';

	  /* Pull out the lk expression or SP offset, if present.  */
	  if (paren != NULL)
	    {
	      int len = strlen (paren);
	      char *end = paren + len;
	      int c;

	      while (end[-1] != ')')
		if (--end <= paren)
		  {
		    as_bad (_("Badly formed address expression"));
		    return -1;
		  }
	      c = *end;
	      *end = '\0';
	      parse_expression (paren, &operands[i].exp);
	      *end = c;
	    }
	  else
	    operands[i].exp.X_op = O_absent;
	}
      else
	parse_expression (operands[i].buf, &operands[i].exp);
    }

  return numexp;
}

/* Predicates for different operand types.  */

static int
is_immediate (struct opstruct *operand)
{
  return *operand->buf == '#';
}

/* This is distinguished from immediate because some numbers must be constants
   and must *not* have the '#' prefix.  */

static int
is_absolute (struct opstruct *operand)
{
  return operand->exp.X_op == O_constant && !is_immediate (operand);
}

/* Is this an indirect operand?  */

static int
is_indirect (struct opstruct *operand)
{
  return operand->buf[0] == '*';
}

/* Is this a valid dual-memory operand?  */

static int
is_dual (struct opstruct *operand)
{
  if (is_indirect (operand) && strncasecmp (operand->buf, "*ar", 3) == 0)
    {
      char *tmp = operand->buf + 3;
      int arf;
      int valid_mod;

      arf = *tmp++ - '0';
      /* Only allow *ARx, *ARx-, *ARx+, or *ARx+0%.  */
      valid_mod = *tmp == '\0' ||
	strcasecmp (tmp, "-") == 0 ||
	strcasecmp (tmp, "+") == 0 ||
	strcasecmp (tmp, "+0%") == 0;
      return arf >= 2 && arf <= 5 && valid_mod;
    }
  return 0;
}

static int
is_mmreg (struct opstruct *operand)
{
  return (is_absolute (operand)
	  || is_immediate (operand)
	  || hash_find (mmreg_hash, operand->buf) != 0);
}

static int
is_type (struct opstruct *operand, enum optype type)
{
  switch (type)
    {
    case OP_None:
      return operand->buf[0] == 0;
    case OP_Xmem:
    case OP_Ymem:
      return is_dual (operand);
    case OP_Sind:
      return is_indirect (operand);
    case OP_xpmad_ms7:
      /* This one *must* be immediate.  */
      return is_immediate (operand);
    case OP_xpmad:
    case OP_pmad:
    case OP_PA:
    case OP_dmad:
    case OP_Lmem:
    case OP_MMR:
      return 1;
    case OP_Smem:
      /* Address may be a numeric, indirect, or an expression.  */
      return !is_immediate (operand);
    case OP_MMRY:
    case OP_MMRX:
      return is_mmreg (operand);
    case OP_SRC:
    case OP_SRC1:
    case OP_RND:
    case OP_DST:
      return is_accumulator (operand);
    case OP_B:
      return is_accumulator (operand) && TOUPPER (operand->buf[0]) == 'B';
    case OP_A:
      return is_accumulator (operand) && TOUPPER (operand->buf[0]) == 'A';
    case OP_ARX:
      return strncasecmp ("ar", operand->buf, 2) == 0
	&& ISDIGIT (operand->buf[2]);
    case OP_SBIT:
      return hash_find (sbit_hash, operand->buf) != 0 || is_absolute (operand);
    case OP_CC:
      return hash_find (cc_hash, operand->buf) != 0;
    case OP_CC2:
      return hash_find (cc2_hash, operand->buf) != 0;
    case OP_CC3:
      return hash_find (cc3_hash, operand->buf) != 0
	|| is_immediate (operand) || is_absolute (operand);
    case OP_16:
      return (is_immediate (operand) || is_absolute (operand))
	&& operand->exp.X_add_number == 16;
    case OP_N:
      /* Allow st0 or st1 instead of a numeric.  */
      return is_absolute (operand) || is_immediate (operand) ||
	strcasecmp ("st0", operand->buf) == 0 ||
	strcasecmp ("st1", operand->buf) == 0;
    case OP_12:
    case OP_123:
      return is_absolute (operand) || is_immediate (operand);
    case OP_SHFT:
      return (is_immediate (operand) || is_absolute (operand))
	&& operand->exp.X_add_number >= 0 && operand->exp.X_add_number < 16;
    case OP_SHIFT:
      /* Let this one catch out-of-range values.  */
      return (is_immediate (operand) || is_absolute (operand))
	&& operand->exp.X_add_number != 16;
    case OP_BITC:
    case OP_031:
    case OP_k8:
      return is_absolute (operand) || is_immediate (operand);
    case OP_k8u:
      return is_immediate (operand)
	&& operand->exp.X_op == O_constant
	&& operand->exp.X_add_number >= 0
	&& operand->exp.X_add_number < 256;
    case OP_lk:
    case OP_lku:
      /* Allow anything; assumes opcodes are ordered with Smem operands
	 versions first.  */
      return 1;
    case OP_k5:
    case OP_k3:
    case OP_k9:
      /* Just make sure it's an integer; check range later.  */
      return is_immediate (operand);
    case OP_T:
      return strcasecmp ("t", operand->buf) == 0 ||
	strcasecmp ("treg", operand->buf) == 0;
    case OP_TS:
      return strcasecmp ("ts", operand->buf) == 0;
    case OP_ASM:
      return strcasecmp ("asm", operand->buf) == 0;
    case OP_TRN:
      return strcasecmp ("trn", operand->buf) == 0;
    case OP_DP:
      return strcasecmp ("dp", operand->buf) == 0;
    case OP_ARP:
      return strcasecmp ("arp", operand->buf) == 0;
    default:
      return 0;
    }
}

static int
operands_match (tic54x_insn *insn,
		struct opstruct *operands,
		int opcount,
		const enum optype *refoptype,
		int minops,
		int maxops)
{
  int op = 0, refop = 0;

  if (opcount == 0 && minops == 0)
    return 1;

  while (op <= maxops && refop <= maxops)
    {
      while (!is_type (&operands[op], OPTYPE (refoptype[refop])))
	{
	  /* Skip an optional template operand if it doesn't agree
	     with the current operand.  */
	  if (refoptype[refop] & OPT)
	    {
	      ++refop;
	      --maxops;
	      if (refop > maxops)
		return 0;
	    }
	  else
	    return 0;
	}

      /* Save the actual operand type for later use.  */
      operands[op].type = OPTYPE (refoptype[refop]);
      ++refop;
      ++op;
      /* Have we matched them all yet?  */
      if (op == opcount)
	{
	  while (op < maxops)
	    {
	      /* If a later operand is *not* optional, no match.  */
	      if ((refoptype[refop] & OPT) == 0)
		return 0;
	      /* Flag any implicit default OP_DST operands so we know to add
		 them explicitly when encoding the operand later.  */
	      if (OPTYPE (refoptype[refop]) == OP_DST)
		insn->using_default_dst = 1;
	      ++refop;
	      ++op;
	    }

	  return 1;
	}
    }

  return 0;
}

/* 16-bit direct memory address
   Explicit dmad operands are always in last word of insn (usually second
   word, but bumped to third if lk addressing is used)

   We allow *(dmad) notation because the TI assembler allows it.

   XPC_CODE:
   0 for 16-bit addresses
   1 for full 23-bit addresses
   2 for the upper 7 bits of a 23-bit address (LDX).  */

static int
encode_dmad (tic54x_insn *insn, struct opstruct *operand, int xpc_code)
{
  int op = 1 + insn->is_lkaddr;

  /* Only allow *(dmad) expressions; all others are invalid.  */
  if (is_indirect (operand) && operand->buf[strlen (operand->buf) - 1] != ')')
    {
      as_bad (_("Invalid dmad syntax '%s'"), operand->buf);
      return 0;
    }

  insn->opcode[op].addr_expr = operand->exp;

  if (insn->opcode[op].addr_expr.X_op == O_constant)
    {
      valueT value = insn->opcode[op].addr_expr.X_add_number;

      if (xpc_code == 1)
	{
	  insn->opcode[0].word &= 0xFF80;
	  insn->opcode[0].word |= (value >> 16) & 0x7F;
	  insn->opcode[1].word = value & 0xFFFF;
	}
      else if (xpc_code == 2)
	insn->opcode[op].word = (value >> 16) & 0xFFFF;
      else
	insn->opcode[op].word = value;
    }
  else
    {
      /* Do the fixup later; just store the expression.  */
      insn->opcode[op].word = 0;
      insn->opcode[op].r_nchars = 2;

      if (amode == c_mode)
	insn->opcode[op].r_type = BFD_RELOC_TIC54X_16_OF_23;
      else if (xpc_code == 1)
	{
	  /* This relocation spans two words, so adjust accordingly.  */
	  insn->opcode[0].addr_expr = operand->exp;
	  insn->opcode[0].r_type = BFD_RELOC_TIC54X_23;
	  insn->opcode[0].r_nchars = 4;
	  insn->opcode[0].unresolved = 1;
	  /* It's really 2 words, but we want to stop encoding after the
	     first, since we must encode both words at once.  */
	  insn->words = 1;
	}
      else if (xpc_code == 2)
	insn->opcode[op].r_type = BFD_RELOC_TIC54X_MS7_OF_23;
      else
	insn->opcode[op].r_type = BFD_RELOC_TIC54X_16_OF_23;

      insn->opcode[op].unresolved = 1;
    }

  return 1;
}

/* 7-bit direct address encoding.  */

static int
encode_address (tic54x_insn *insn, struct opstruct *operand)
{
  /* Assumes that dma addresses are *always* in word 0 of the opcode.  */
  insn->opcode[0].addr_expr = operand->exp;

  if (operand->exp.X_op == O_constant)
    insn->opcode[0].word |= (operand->exp.X_add_number & 0x7F);
  else
    {
      if (operand->exp.X_op == O_register)
        as_bad (_("Use the .mmregs directive to use memory-mapped register names such as '%s'"), operand->buf);
      /* Do the fixup later; just store the expression.  */
      insn->opcode[0].r_nchars = 1;
      insn->opcode[0].r_type = BFD_RELOC_TIC54X_PARTLS7;
      insn->opcode[0].unresolved = 1;
    }

  return 1;
}

static int
encode_indirect (tic54x_insn *insn, struct opstruct *operand)
{
  int arf;
  int mod;

  if (insn->is_lkaddr)
    {
      /* lk addresses always go in the second insn word.  */
      mod = ((TOUPPER (operand->buf[1]) == 'A') ? 12 :
	     (operand->buf[1] == '(') ? 15 :
	     (strchr (operand->buf, '%') != NULL) ? 14 : 13);
      arf = ((mod == 12) ? operand->buf[3] - '0' :
	     (mod == 15) ? 0 : operand->buf[4] - '0');

      insn->opcode[1].addr_expr = operand->exp;

      if (operand->exp.X_op == O_constant)
	insn->opcode[1].word = operand->exp.X_add_number;
      else
	{
	  insn->opcode[1].word = 0;
	  insn->opcode[1].r_nchars = 2;
	  insn->opcode[1].r_type = BFD_RELOC_TIC54X_16_OF_23;
	  insn->opcode[1].unresolved = 1;
	}
    }
  else if (strncasecmp (operand->buf, "*sp (", 4) == 0)
    {
      /* Stack offsets look the same as 7-bit direct addressing.  */
      return encode_address (insn, operand);
    }
  else
    {
      arf = (TOUPPER (operand->buf[1]) == 'A' ?
	     operand->buf[3] : operand->buf[4]) - '0';

      if (operand->buf[1] == '+')
	{
	  mod = 3;		    /* *+ARx  */
	  if (insn->tm->flags & FL_SMR)
	    as_warn (_("Address mode *+ARx is write-only. "
		       "Results of reading are undefined."));
	}
      else if (operand->buf[4] == '\0')
	mod = 0;		    /* *ARx  */
      else if (operand->buf[5] == '\0')
	mod = (operand->buf[4] == '-' ? 1 : 2); /* *ARx+ / *ARx-  */
      else if (operand->buf[6] == '\0')
	{
	  if (operand->buf[5] == '0')
	    mod = (operand->buf[4] == '-' ? 5 : 6); /* *ARx+0 / *ARx-0  */
	  else
	    mod = (operand->buf[4] == '-' ? 8 : 10);/* *ARx+% / *ARx-%  */
	}
      else if (TOUPPER (operand->buf[6]) == 'B')
	mod = (operand->buf[4] == '-' ? 4 : 7); /* ARx+0B / *ARx-0B  */
      else if (TOUPPER (operand->buf[6]) == '%')
	mod = (operand->buf[4] == '-' ? 9 : 11); /* ARx+0% / *ARx - 0%  */
      else
	{
	  as_bad (_("Unrecognized indirect address format \"%s\""),
		  operand->buf);
	  return 0;
	}
    }

  insn->opcode[0].word |= 0x80 | (mod << 3) | arf;

  return 1;
}

static int
encode_integer (tic54x_insn *insn,
		struct opstruct *operand,
		int which,
		int min,
		int max,
		unsigned short mask)
{
  long parse, integer;

  insn->opcode[which].addr_expr = operand->exp;

  if (operand->exp.X_op == O_constant)
    {
      parse = operand->exp.X_add_number;
      /* Hack -- fixup for 16-bit hex quantities that get converted positive
	 instead of negative.  */
      if ((parse & 0x8000) && min == -32768 && max == 32767)
	integer = (short) parse;
      else
	integer = parse;

      if (integer >= min && integer <= max)
	{
	  insn->opcode[which].word |= (integer & mask);
	  return 1;
	}
      as_bad (_("Operand '%s' out of range (%d <= x <= %d)"),
	      operand->buf, min, max);
    }
  else
    {
      if (insn->opcode[which].addr_expr.X_op == O_constant)
	{
	  insn->opcode[which].word |=
	    insn->opcode[which].addr_expr.X_add_number & mask;
	}
      else
	{
	  /* Do the fixup later; just store the expression.  */
	  bfd_reloc_code_real_type rtype =
	    (mask == 0x1FF ? BFD_RELOC_TIC54X_PARTMS9 :
	     mask == 0xFFFF ? BFD_RELOC_TIC54X_16_OF_23 :
	     mask == 0x7F ? BFD_RELOC_TIC54X_PARTLS7 : BFD_RELOC_8);
	  int size = (mask == 0x1FF || mask == 0xFFFF) ? 2 : 1;

	  if (rtype == BFD_RELOC_8)
	    as_bad (_("Error in relocation handling"));

	  insn->opcode[which].r_nchars = size;
	  insn->opcode[which].r_type = rtype;
	  insn->opcode[which].unresolved = 1;
	}

      return 1;
    }

  return 0;
}

static int
encode_condition (tic54x_insn *insn, struct opstruct *operand)
{
  symbol *cc = (symbol *) hash_find (cc_hash, operand->buf);
  if (!cc)
    {
      as_bad (_("Unrecognized condition code \"%s\""), operand->buf);
      return 0;
    }
#define CC_GROUP 0x40
#define CC_ACC   0x08
#define CATG_A1  0x07
#define CATG_B1  0x30
#define CATG_A2  0x30
#define CATG_B2  0x0C
#define CATG_C2  0x03
  /* Disallow group 1 conditions mixed with group 2 conditions
     if group 1, allow only one category A and one category B
     if group 2, allow only one each of category A, B, and C.  */
  if (((insn->opcode[0].word & 0xFF) != 0))
    {
      if ((insn->opcode[0].word & CC_GROUP) != (cc->value & CC_GROUP))
	{
	  as_bad (_("Condition \"%s\" does not match preceding group"),
		  operand->buf);
	  return 0;
	}
      if (insn->opcode[0].word & CC_GROUP)
	{
	  if ((insn->opcode[0].word & CC_ACC) != (cc->value & CC_ACC))
	    {
	      as_bad (_("Condition \"%s\" uses a different accumulator from "
			"a preceding condition"),
		      operand->buf);
	      return 0;
	    }
	  if ((insn->opcode[0].word & CATG_A1) && (cc->value & CATG_A1))
	    {
	      as_bad (_("Only one comparison conditional allowed"));
	      return 0;
	    }
	  if ((insn->opcode[0].word & CATG_B1) && (cc->value & CATG_B1))
	    {
	      as_bad (_("Only one overflow conditional allowed"));
	      return 0;
	    }
	}
      else if (   ((insn->opcode[0].word & CATG_A2) && (cc->value & CATG_A2))
	       || ((insn->opcode[0].word & CATG_B2) && (cc->value & CATG_B2))
	       || ((insn->opcode[0].word & CATG_C2) && (cc->value & CATG_C2)))
	{
	  as_bad (_("Duplicate %s conditional"), operand->buf);
	  return 0;
	}
    }

  insn->opcode[0].word |= cc->value;
  return 1;
}

static int
encode_cc3 (tic54x_insn *insn, struct opstruct *operand)
{
  symbol *cc3 = (symbol *) hash_find (cc3_hash, operand->buf);
  int value = cc3 ? cc3->value : operand->exp.X_add_number << 8;

  if ((value & 0x0300) != value)
    {
      as_bad (_("Unrecognized condition code \"%s\""), operand->buf);
      return 0;
    }
  insn->opcode[0].word |= value;
  return 1;
}

static int
encode_arx (tic54x_insn *insn, struct opstruct *operand)
{
  int arf = strlen (operand->buf) >= 3 ? operand->buf[2] - '0' : -1;

  if (strncasecmp ("ar", operand->buf, 2) || arf < 0 || arf > 7)
    {
      as_bad (_("Invalid auxiliary register (use AR0-AR7)"));
      return 0;
    }
  insn->opcode[0].word |= arf;
  return 1;
}

static int
encode_cc2 (tic54x_insn *insn, struct opstruct *operand)
{
  symbol *cc2 = (symbol *) hash_find (cc2_hash, operand->buf);

  if (!cc2)
    {
      as_bad (_("Unrecognized condition code \"%s\""), operand->buf);
      return 0;
    }
  insn->opcode[0].word |= cc2->value;
  return 1;
}

static int
encode_operand (tic54x_insn *insn, enum optype type, struct opstruct *operand)
{
  int ext = (insn->tm->flags & FL_EXT) != 0;

  if (type == OP_MMR && operand->exp.X_op != O_constant)
    {
      /* Disallow long-constant addressing for memory-mapped addressing.  */
      if (insn->is_lkaddr)
	{
	  as_bad (_("lk addressing modes are invalid for memory-mapped "
		    "register addressing"));
	  return 0;
	}
      type = OP_Smem;
      /* Warn about *+ARx when used with MMR operands.  */
      if (strncasecmp (operand->buf, "*+ar", 4) == 0)
	{
	  as_warn (_("Address mode *+ARx is not allowed in memory-mapped "
		     "register addressing.  Resulting behavior is "
		     "undefined."));
	}
    }

  switch (type)
    {
    case OP_None:
      return 1;
    case OP_dmad:
      /* 16-bit immediate value.  */
      return encode_dmad (insn, operand, 0);
    case OP_SRC:
      if (TOUPPER (*operand->buf) == 'B')
	{
	  insn->opcode[ext ? (1 + insn->is_lkaddr) : 0].word |= (1 << 9);
	  if (insn->using_default_dst)
	    insn->opcode[ext ? (1 + insn->is_lkaddr) : 0].word |= (1 << 8);
	}
      return 1;
    case OP_RND:
      /* Make sure this agrees with the OP_DST operand.  */
      if (!((TOUPPER (operand->buf[0]) == 'B') ^
	    ((insn->opcode[0].word & (1 << 8)) != 0)))
	{
	  as_bad (_("Destination accumulator for each part of this parallel "
		    "instruction must be different"));
	  return 0;
	}
      return 1;
    case OP_SRC1:
    case OP_DST:
      if (TOUPPER (operand->buf[0]) == 'B')
	insn->opcode[ext ? (1 + insn->is_lkaddr) : 0].word |= (1 << 8);
      return 1;
    case OP_Xmem:
    case OP_Ymem:
      {
	int mod = (operand->buf[4] == '\0' ? 0 : /* *arx  */
		   operand->buf[4] == '-' ? 1 : /* *arx-  */
		   operand->buf[5] == '\0' ? 2 : 3); /* *arx+, *arx+0%  */
	int arf = operand->buf[3] - '0' - 2;
	int code = (mod << 2) | arf;
	insn->opcode[0].word |= (code << (type == OP_Xmem ? 4 : 0));
	return 1;
      }
    case OP_Lmem:
    case OP_Smem:
      if (!is_indirect (operand))
	return encode_address (insn, operand);
      /* Fall through.  */
    case OP_Sind:
      return encode_indirect (insn, operand);
    case OP_xpmad_ms7:
      return encode_dmad (insn, operand, 2);
    case OP_xpmad:
      return encode_dmad (insn, operand, 1);
    case OP_PA:
    case OP_pmad:
      return encode_dmad (insn, operand, 0);
    case OP_ARX:
      return encode_arx (insn, operand);
    case OP_MMRX:
    case OP_MMRY:
    case OP_MMR:
      {
	int value = operand->exp.X_add_number;

	if (type == OP_MMR)
	  insn->opcode[0].word |= value;
	else
	  {
	    if (value < 16 || value > 24)
	      {
		as_bad (_("Memory mapped register \"%s\" out of range"),
			operand->buf);
		return 0;
	      }
	    if (type == OP_MMRX)
	      insn->opcode[0].word |= (value - 16) << 4;
	    else
	      insn->opcode[0].word |= (value - 16);
	  }
	return 1;
      }
    case OP_B:
    case OP_A:
      return 1;
    case OP_SHFT:
      return encode_integer (insn, operand, ext + insn->is_lkaddr,
			     0, 15, 0xF);
    case OP_SHIFT:
      return encode_integer (insn, operand, ext + insn->is_lkaddr,
			     -16, 15, 0x1F);
    case OP_lk:
      return encode_integer (insn, operand, 1 + insn->is_lkaddr,
			     -32768, 32767, 0xFFFF);
    case OP_CC:
      return encode_condition (insn, operand);
    case OP_CC2:
      return encode_cc2 (insn, operand);
    case OP_CC3:
      return encode_cc3 (insn, operand);
    case OP_BITC:
      return encode_integer (insn, operand, 0, 0, 15, 0xF);
    case OP_k8:
      return encode_integer (insn, operand, 0, -128, 127, 0xFF);
    case OP_123:
      {
	int value = operand->exp.X_add_number;
	int code;
	if (value < 1 || value > 3)
	  {
	    as_bad (_("Invalid operand (use 1, 2, or 3)"));
	    return 0;
	  }
	code = value == 1 ? 0 : value == 2 ? 0x2 : 0x1;
	insn->opcode[0].word |= (code << 8);
	return 1;
      }
    case OP_031:
      return encode_integer (insn, operand, 0, 0, 31, 0x1F);
    case OP_k8u:
      return encode_integer (insn, operand, 0, 0, 255, 0xFF);
    case OP_lku:
      return encode_integer (insn, operand, 1 + insn->is_lkaddr,
			     0, 65535, 0xFFFF);
    case OP_SBIT:
      {
	symbol *sbit = (symbol *) hash_find (sbit_hash, operand->buf);
	int value = is_absolute (operand) ?
	  operand->exp.X_add_number : (sbit ? sbit->value : -1);
	int reg = 0;

	if (insn->opcount == 1)
	  {
	    if (!sbit)
	      {
		as_bad (_("A status register or status bit name is required"));
		return 0;
	      }
	    /* Guess the register based on the status bit; "ovb" is the last
	       status bit defined for st0.  */
	    if (sbit > (symbol *) hash_find (sbit_hash, "ovb"))
	      reg = 1;
	  }
	if (value == -1)
	  {
	    as_bad (_("Unrecognized status bit \"%s\""), operand->buf);
	    return 0;
	  }
	insn->opcode[0].word |= value;
	insn->opcode[0].word |= (reg << 9);
	return 1;
      }
    case OP_N:
      if (strcasecmp (operand->buf, "st0") == 0
	  || strcasecmp (operand->buf, "st1") == 0)
	{
	  insn->opcode[0].word |=
	    ((unsigned short) (operand->buf[2] - '0')) << 9;
	  return 1;
	}
      else if (operand->exp.X_op == O_constant
	       && (operand->exp.X_add_number == 0
		   || operand->exp.X_add_number == 1))
	{
	  insn->opcode[0].word |=
	    ((unsigned short) (operand->exp.X_add_number)) << 9;
	  return 1;
	}
      as_bad (_("Invalid status register \"%s\""), operand->buf);
      return 0;
    case OP_k5:
      return encode_integer (insn, operand, 0, -16, 15, 0x1F);
    case OP_k3:
      return encode_integer (insn, operand, 0, 0, 7, 0x7);
    case OP_k9:
      return encode_integer (insn, operand, 0, 0, 0x1FF, 0x1FF);
    case OP_12:
      if (operand->exp.X_add_number != 1
	  && operand->exp.X_add_number != 2)
	{
	  as_bad (_("Operand \"%s\" out of range (use 1 or 2)"), operand->buf);
	  return 0;
	}
      insn->opcode[0].word |= (operand->exp.X_add_number - 1) << 9;
      return 1;
    case OP_16:
    case OP_T:
    case OP_TS:
    case OP_ASM:
    case OP_TRN:
    case OP_DP:
    case OP_ARP:
      /* No encoding necessary.  */
      return 1;
    default:
      return 0;
    }

  return 1;
}

static void
emit_insn (tic54x_insn *insn)
{
  int i;
  flagword oldflags = bfd_get_section_flags (stdoutput, now_seg);
  flagword flags = oldflags | SEC_CODE;

  if (! bfd_set_section_flags (stdoutput, now_seg, flags))
        as_warn (_("error setting flags for \"%s\": %s"),
                 bfd_section_name (stdoutput, now_seg),
                 bfd_errmsg (bfd_get_error ()));

  for (i = 0; i < insn->words; i++)
    {
      int size = (insn->opcode[i].unresolved
		  && insn->opcode[i].r_type == BFD_RELOC_TIC54X_23) ? 4 : 2;
      char *p = frag_more (size);

      if (size == 2)
	md_number_to_chars (p, (valueT) insn->opcode[i].word, 2);
      else
	md_number_to_chars (p, (valueT) insn->opcode[i].word << 16, 4);

      if (insn->opcode[i].unresolved)
	fix_new_exp (frag_now, p - frag_now->fr_literal,
		     insn->opcode[i].r_nchars, &insn->opcode[i].addr_expr,
		     FALSE, insn->opcode[i].r_type);
    }
}

/* Convert the operand strings into appropriate opcode values
   return the total number of words used by the instruction.  */

static int
build_insn (tic54x_insn *insn)
{
  int i;

  /* Only non-parallel instructions support lk addressing.  */
  if (!(insn->tm->flags & FL_PAR))
    {
      for (i = 0; i < insn->opcount; i++)
	{
	  if ((OPTYPE (insn->operands[i].type) == OP_Smem
	       || OPTYPE (insn->operands[i].type) == OP_Lmem
	       || OPTYPE (insn->operands[i].type) == OP_Sind)
	      && strchr (insn->operands[i].buf, '(')
	      /* Don't mistake stack-relative addressing for lk addressing.  */
	      && strncasecmp (insn->operands[i].buf, "*sp (", 4) != 0)
	    {
	      insn->is_lkaddr = 1;
	      insn->lkoperand = i;
	      break;
	    }
	}
    }
  insn->words = insn->tm->words + insn->is_lkaddr;

  insn->opcode[0].word = insn->tm->opcode;
  if (insn->tm->flags & FL_EXT)
    insn->opcode[1 + insn->is_lkaddr].word = insn->tm->opcode2;

  for (i = 0; i < insn->opcount; i++)
    {
      enum optype type = insn->operands[i].type;

      if (!encode_operand (insn, type, &insn->operands[i]))
	return 0;
    }
  if (insn->tm->flags & FL_PAR)
    for (i = 0; i < insn->paropcount; i++)
      {
	enum optype partype = insn->paroperands[i].type;

	if (!encode_operand (insn, partype, &insn->paroperands[i]))
	  return 0;
      }

  emit_insn (insn);

  return insn->words;
}

static int
optimize_insn (tic54x_insn *insn)
{
  /* Optimize some instructions, helping out the brain-dead programmer.  */
#define is_zero(op) ((op).exp.X_op == O_constant && (op).exp.X_add_number == 0)
  if (strcasecmp (insn->tm->name, "add") == 0)
    {
      if (insn->opcount > 1
	  && is_accumulator (&insn->operands[insn->opcount - 2])
	  && is_accumulator (&insn->operands[insn->opcount - 1])
	  && strcasecmp (insn->operands[insn->opcount - 2].buf,
			 insn->operands[insn->opcount - 1].buf) == 0)
	{
	  --insn->opcount;
	  insn->using_default_dst = 1;
	  return 1;
	}

      /* Try to collapse if Xmem and shift count is zero.  */
      if ((OPTYPE (insn->tm->operand_types[0]) == OP_Xmem
	   && OPTYPE (insn->tm->operand_types[1]) == OP_SHFT
	   && is_zero (insn->operands[1]))
	  /* Or if Smem, shift is zero or absent, and SRC == DST.  */
	  || (OPTYPE (insn->tm->operand_types[0]) == OP_Smem
	      && OPTYPE (insn->tm->operand_types[1]) == OP_SHIFT
	      && is_type (&insn->operands[1], OP_SHIFT)
	      && is_zero (insn->operands[1]) && insn->opcount == 3))
	{
	  insn->operands[1] = insn->operands[2];
	  insn->opcount = 2;
	  return 1;
	}
    }
  else if (strcasecmp (insn->tm->name, "ld") == 0)
    {
      if (insn->opcount == 3 && insn->operands[0].type != OP_SRC)
	{
	  if ((OPTYPE (insn->tm->operand_types[1]) == OP_SHIFT
	       || OPTYPE (insn->tm->operand_types[1]) == OP_SHFT)
	      && is_zero (insn->operands[1])
	      && (OPTYPE (insn->tm->operand_types[0]) != OP_lk
		  || (insn->operands[0].exp.X_op == O_constant
		      && insn->operands[0].exp.X_add_number <= 255
		      && insn->operands[0].exp.X_add_number >= 0)))
	    {
	      insn->operands[1] = insn->operands[2];
	      insn->opcount = 2;
	      return 1;
	    }
	}
    }
  else if (strcasecmp (insn->tm->name, "sth") == 0
	   || strcasecmp (insn->tm->name, "stl") == 0)
    {
      if ((OPTYPE (insn->tm->operand_types[1]) == OP_SHIFT
	   || OPTYPE (insn->tm->operand_types[1]) == OP_SHFT)
	  && is_zero (insn->operands[1]))
	{
	  insn->operands[1] = insn->operands[2];
	  insn->opcount = 2;
	  return 1;
	}
    }
  else if (strcasecmp (insn->tm->name, "sub") == 0)
    {
      if (insn->opcount > 1
	  && is_accumulator (&insn->operands[insn->opcount - 2])
	  && is_accumulator (&insn->operands[insn->opcount - 1])
	  && strcasecmp (insn->operands[insn->opcount - 2].buf,
			 insn->operands[insn->opcount - 1].buf) == 0)
	{
	  --insn->opcount;
	  insn->using_default_dst = 1;
	  return 1;
	}

      if (   ((OPTYPE (insn->tm->operand_types[0]) == OP_Smem
	    && OPTYPE (insn->tm->operand_types[1]) == OP_SHIFT)
	   || (OPTYPE (insn->tm->operand_types[0]) == OP_Xmem
	    && OPTYPE (insn->tm->operand_types[1]) == OP_SHFT))
	  && is_zero (insn->operands[1])
	  && insn->opcount == 3)
	{
	  insn->operands[1] = insn->operands[2];
	  insn->opcount = 2;
	  return 1;
	}
    }
  return 0;
}

/* Find a matching template if possible, and get the operand strings.  */

static int
tic54x_parse_insn (tic54x_insn *insn, char *line)
{
  insn->tm = (insn_template *) hash_find (op_hash, insn->mnemonic);
  if (!insn->tm)
    {
      as_bad (_("Unrecognized instruction \"%s\""), insn->mnemonic);
      return 0;
    }

  insn->opcount = get_operands (insn->operands, line);
  if (insn->opcount < 0)
    return 0;

  /* Check each variation of operands for this mnemonic.  */
  while (insn->tm->name && strcasecmp (insn->tm->name, insn->mnemonic) == 0)
    {
      if (insn->opcount >= insn->tm->minops
	  && insn->opcount <= insn->tm->maxops
	  && operands_match (insn, &insn->operands[0], insn->opcount,
			     insn->tm->operand_types,
			     insn->tm->minops, insn->tm->maxops))
	{
	  /* SUCCESS! now try some optimizations.  */
	  if (optimize_insn (insn))
	    {
	      insn->tm = (insn_template *) hash_find (op_hash,
                                                      insn->mnemonic);
	      continue;
	    }

	  return 1;
	}
      ++(insn->tm);
    }
  as_bad (_("Unrecognized operand list '%s' for instruction '%s'"),
	  line, insn->mnemonic);
  return 0;
}

/* We set this in start_line_hook, 'cause if we do a line replacement, we
   won't be able to see the next line.  */
static int parallel_on_next_line_hint = 0;

/* See if this is part of a parallel instruction
   Look for a subsequent line starting with "||".  */

static int
next_line_shows_parallel (char *next_line)
{
  /* Look for the second half.  */
  while (ISSPACE (*next_line))
    ++next_line;

  return (next_line[0] == PARALLEL_SEPARATOR
	  && next_line[1] == PARALLEL_SEPARATOR);
}

static int
tic54x_parse_parallel_insn_firstline (tic54x_insn *insn, char *line)
{
  insn->tm = (insn_template *) hash_find (parop_hash, insn->mnemonic);
  if (!insn->tm)
    {
      as_bad (_("Unrecognized parallel instruction \"%s\""),
	      insn->mnemonic);
      return 0;
    }

  while (insn->tm->name && strcasecmp (insn->tm->name,
                                       insn->mnemonic) == 0)
    {
      insn->opcount = get_operands (insn->operands, line);
      if (insn->opcount < 0)
	return 0;
      if (insn->opcount == 2
	  && operands_match (insn, &insn->operands[0], insn->opcount,
			     insn->tm->operand_types, 2, 2))
	{
	  return 1;
	}
      ++(insn->tm);
    }
  /* Didn't find a matching parallel; try for a normal insn.  */
  return 0;
}

/* Parse the second line of a two-line parallel instruction.  */

static int
tic54x_parse_parallel_insn_lastline (tic54x_insn *insn, char *line)
{
  int valid_mnemonic = 0;

  insn->paropcount = get_operands (insn->paroperands, line);
  while (insn->tm->name && strcasecmp (insn->tm->name,
				       insn->mnemonic) == 0)
    {
      if (strcasecmp (insn->tm->parname, insn->parmnemonic) == 0)
	{
	  valid_mnemonic = 1;

	  if (insn->paropcount >= insn->tm->minops
	      && insn->paropcount <= insn->tm->maxops
	      && operands_match (insn, insn->paroperands,
				 insn->paropcount,
				 insn->tm->paroperand_types,
				 insn->tm->minops, insn->tm->maxops))
	    return 1;
	}
      ++(insn->tm);
    }
  if (valid_mnemonic)
    as_bad (_("Invalid operand (s) for parallel instruction \"%s\""),
	    insn->parmnemonic);
  else
    as_bad (_("Unrecognized parallel instruction combination \"%s || %s\""),
	    insn->mnemonic, insn->parmnemonic);

  return 0;
}

/* If quotes found, return copy of line up to closing quote;
   otherwise up until terminator.
   If it's a string, pass as-is; otherwise attempt substitution symbol
   replacement on the value.  */

static char *
subsym_get_arg (char *line, char *terminators, char **str, int nosub)
{
  char *ptr = line;
  char *endp;
  int is_string = *line == '"';
  int is_char = ISDIGIT (*line);

  if (is_char)
    {
      while (ISDIGIT (*ptr))
	++ptr;
      endp = ptr;
      *str = xmalloc (ptr - line + 1);
      strncpy (*str, line, ptr - line);
      (*str)[ptr - line] = 0;
    }
  else if (is_string)
    {
      char *savedp = input_line_pointer;
      int len;

      input_line_pointer = ptr;
      *str = demand_copy_C_string (&len);
      endp = input_line_pointer;
      input_line_pointer = savedp;

      /* Do forced substitutions if requested.  */
      if (!nosub && **str == ':')
	*str = subsym_substitute (*str, 1);
    }
  else
    {
      char *term = terminators;
      char *value = NULL;

      while (*ptr && *ptr != *term)
	{
	  if (!*term)
	    {
	      term = terminators;
	      ++ptr;
	    }
	  else
	    ++term;
	}
      endp = ptr;
      *str = xmalloc (ptr - line + 1);
      strncpy (*str, line, ptr - line);
      (*str)[ptr - line] = 0;
      /* Do simple substitution, if available.  */
      if (!nosub && (value = subsym_lookup (*str, macro_level)) != NULL)
	*str = value;
    }

  return endp;
}

/* Replace the given substitution string.
   We start at the innermost macro level, so that existing locals remain local
   Note: we're treating macro args identically to .var's; I don't know if
   that's compatible w/TI's assembler.  */

static void
subsym_create_or_replace (char *name, char *value)
{
  int i;

  for (i = macro_level; i > 0; i--)
    {
      if (hash_find (subsym_hash[i], name))
	{
	  hash_replace (subsym_hash[i], name, value);
	  return;
	}
    }
  if (hash_find (subsym_hash[0], name))
    hash_replace (subsym_hash[0], name, value);
  else
    hash_insert (subsym_hash[0], name, value);
}

/* Look up the substitution string replacement for the given symbol.
   Start with the innermost macro substitution table given and work
   outwards.  */

static char *
subsym_lookup (char *name, int nest_level)
{
  char *value = hash_find (subsym_hash[nest_level], name);

  if (value || nest_level == 0)
    return value;

  return subsym_lookup (name, nest_level - 1);
}

/* Do substitution-symbol replacement on the given line (recursively).
   return the argument if no substitution was done

   Also look for built-in functions ($func (arg)) and local labels.

   If FORCED is set, look for forced substitutions of the form ':SYMBOL:'.  */

static char *
subsym_substitute (char *line, int forced)
{
  /* For each apparent symbol, see if it's a substitution symbol, and if so,
     replace it in the input.  */
  char *replacement; /* current replacement for LINE.  */
  char *head; /* Start of line.  */
  char *ptr; /* Current examination point.  */
  int changed = 0; /* Did we make a substitution?  */
  int eval_line = 0; /* Is this line a .eval/.asg statement?  */
  int eval_symbol = 0; /* Are we in the middle of the symbol for
                          .eval/.asg?  */
  char *eval_end = NULL;
  int recurse = 1;
  int line_conditional = 0;
  char *tmp;

  /* Work with a copy of the input line.  */
  replacement = xmalloc (strlen (line) + 1);
  strcpy (replacement, line);

  ptr = head = replacement;

  /* Flag lines where we might need to replace a single '=' with two;
     GAS uses single '=' to assign macro args values, and possibly other
     places, so limit what we replace.  */
  if (strstr (line, ".if")
      || strstr (line, ".elseif")
      || strstr (line, ".break"))
    line_conditional = 1;

  /* Watch out for .eval, so that we avoid doing substitution on the
     symbol being assigned a value.  */
  if (strstr (line, ".eval") || strstr (line, ".asg"))
    eval_line = 1;

  /* If it's a macro definition, don't do substitution on the argument
     names.  */
  if (strstr (line, ".macro"))
    return line;

  while (!is_end_of_line[(int) *ptr])
    {
      int current_char = *ptr;

      /* Need to update this since LINE may have been modified.  */
      if (eval_line)
	eval_end = strrchr (ptr, ',');

      /* Replace triple double quotes with bounding quote/escapes.  */
      if (current_char == '"' && ptr[1] == '"' && ptr[2] == '"')
	{
	  ptr[1] = '\\';
	  tmp = strstr (ptr + 2, "\"\"\"");
	  if (tmp)
	    tmp[0] = '\\';
	  changed = 1;
	}

      /* Replace a single '=' with a '==';
	 for compatibility with older code only.  */
      if (line_conditional && current_char == '=')
	{
	  if (ptr[1] == '=')
	    {
	      ptr += 2;
	      continue;
	    }
	  *ptr++ = '\0';
	  tmp = xmalloc (strlen (head) + 2 + strlen (ptr) + 1);
	  sprintf (tmp, "%s==%s", head, ptr);
	  /* Continue examining after the '=='.  */
	  ptr = tmp + strlen (head) + 2;
	  free (replacement);
	  head = replacement = tmp;
	  changed = 1;
	}

      /* Flag when we've reached the symbol part of .eval/.asg.  */
      if (eval_line && ptr >= eval_end)
	eval_symbol = 1;

      /* For each apparent symbol, see if it's a substitution symbol, and if
	 so, replace it in the input.  */
      if ((forced && current_char == ':')
	  || (!forced && is_name_beginner (current_char)))
	{
	  char *name; /* Symbol to be replaced.  */
	  char *savedp = input_line_pointer;
	  int c;
	  char *value = NULL;
	  char *tail; /* Rest of line after symbol.  */

	  /* Skip the colon.  */
	  if (forced)
	    ++ptr;

	  name = input_line_pointer = ptr;
	  c = get_symbol_end ();
	  /* '?' is not normally part of a symbol, but it IS part of a local
	     label.  */
	  if (c == '?')
	    {
	      *input_line_pointer++ = c;
	      c = *input_line_pointer;
	      *input_line_pointer = '\0';
	    }
	  /* Avoid infinite recursion; if a symbol shows up a second time for
	     substitution, leave it as is.  */
	  if (hash_find (subsym_recurse_hash, name) == NULL)
	    value = subsym_lookup (name, macro_level);
	  else
	    as_warn (_("%s symbol recursion stopped at "
		       "second appearance of '%s'"),
		     forced ? "Forced substitution" : "Substitution", name);
	  ptr = tail = input_line_pointer;
	  input_line_pointer = savedp;

	  /* Check for local labels; replace them with the appropriate
	     substitution.  */
	  if ((*name == '$' && ISDIGIT (name[1]) && name[2] == '\0')
	      || name[strlen (name) - 1] == '?')
	    {
	      /* Use an existing identifier for that label if, available, or
		 create a new, unique identifier.  */
	      value = hash_find (local_label_hash[macro_level], name);
	      if (value == NULL)
		{
		  char digit[11];
		  char *namecopy = strcpy (xmalloc (strlen (name) + 1), name);

		  value = strcpy (xmalloc (strlen (name) + sizeof (digit) + 1),
				  name);
		  if (*value != '$')
		    value[strlen (value) - 1] = '\0';
		  sprintf (digit, ".%d", local_label_id++);
		  strcat (value, digit);
		  hash_insert (local_label_hash[macro_level], namecopy, value);
		}
	      /* Indicate where to continue looking for substitutions.  */
	      ptr = tail;
	    }
	  /* Check for built-in subsym and math functions.  */
	  else if (value != NULL && *name == '$')
	    {
	      subsym_proc_entry *entry = (subsym_proc_entry *) value;
	      math_proc_entry *math_entry = hash_find (math_hash, name);
	      char *arg1, *arg2 = NULL;

	      *ptr = c;
	      if (entry == NULL)
		{
		  as_bad (_("Unrecognized substitution symbol function"));
		  break;
		}
	      else if (*ptr != '(')
		{
		  as_bad (_("Missing '(' after substitution symbol function"));
		  break;
		}
	      ++ptr;
	      if (math_entry != NULL)
		{
		  float farg1, farg2 = 0;
		  volatile float fresult;

		  farg1 = (float) strtod (ptr, &ptr);
		  if (math_entry->nargs == 2)
		    {
		      if (*ptr++ != ',')
			{
			  as_bad (_("Expecting second argument"));
			  break;
			}
		      farg2 = (float) strtod (ptr, &ptr);
		    }
		  fresult = (*math_entry->proc) (farg1, farg2);
		  value = xmalloc (128);
		  if (math_entry->int_return)
		    sprintf (value, "%d", (int) fresult);
		  else
		    sprintf (value, "%f", fresult);
		  if (*ptr++ != ')')
		    {
		      as_bad (_("Extra junk in function call, expecting ')'"));
		      break;
		    }
		  /* Don't bother recursing; the replacement isn't a
                     symbol.  */
		  recurse = 0;
		}
	      else
		{
		  int val;
		  int arg_type[2] = { *ptr == '"' , 0 };
		  int ismember = !strcmp (entry->name, "$ismember");

		  /* Parse one or two args, which must be a substitution
		     symbol, string or a character-string constant.  */
		  /* For all functions, a string or substitution symbol may be
		     used, with the following exceptions:
		     firstch/lastch: 2nd arg must be character constant
		     ismember: both args must be substitution symbols.  */
		  ptr = subsym_get_arg (ptr, ",)", &arg1, ismember);
		  if (!arg1)
		    break;
		  if (entry->nargs == 2)
		    {
		      if (*ptr++ != ',')
			{
			  as_bad (_("Function expects two arguments"));
			  break;
			}
		      /* Character constants are converted to numerics
			 by the preprocessor.  */
		      arg_type[1] = (ISDIGIT (*ptr)) ? 2 : (*ptr == '"');
		      ptr = subsym_get_arg (ptr, ")", &arg2, ismember);
		    }
		  /* Args checking.  */
		  if ((!strcmp (entry->name, "$firstch")
		       || !strcmp (entry->name, "$lastch"))
		      && arg_type[1] != 2)
		    {
		      as_bad (_("Expecting character constant argument"));
		      break;
		    }
		  if (ismember
		      && (arg_type[0] != 0 || arg_type[1] != 0))
		    {
		      as_bad (_("Both arguments must be substitution symbols"));
		      break;
		    }
		  if (*ptr++ != ')')
		    {
		      as_bad (_("Extra junk in function call, expecting ')'"));
		      break;
		    }
		  val = (*entry->proc) (arg1, arg2);
		  value = xmalloc (64);
		  sprintf (value, "%d", val);
		}
	      /* Fix things up to replace the entire expression, not just the
		 function name.  */
	      tail = ptr;
	      c = *tail;
	    }

	  if (value != NULL && !eval_symbol)
	    {
	      /* Replace the symbol with its string replacement and
		 continue.  Recursively replace VALUE until either no
		 substitutions are performed, or a substitution that has been
		 previously made is encountered again.

		 put the symbol into the recursion hash table so we only
		 try to replace a symbol once.  */
	      if (recurse)
		{
		  hash_insert (subsym_recurse_hash, name, name);
		  value = subsym_substitute (value, macro_level > 0);
		  hash_delete (subsym_recurse_hash, name, FALSE);
		}

	      /* Temporarily zero-terminate where the symbol started.  */
	      *name = 0;
	      if (forced)
		{
		  if (c == '(')
		    {
		      /* Subscripted substitution symbol -- use just the
			 indicated portion of the string; the description
			 kinda indicates that forced substitution is not
			 supposed to be recursive, but I'm not sure.  */
		      unsigned beg, len = 1; /* default to a single char */
		      char *newval = strcpy (xmalloc (strlen (value) + 1),
					     value);

		      savedp = input_line_pointer;
		      input_line_pointer = tail + 1;
		      beg = get_absolute_expression ();
		      if (beg < 1)
			{
			  as_bad (_("Invalid subscript (use 1 to %d)"),
				  (int) strlen (value));
			  break;
			}
		      if (*input_line_pointer == ',')
			{
			  ++input_line_pointer;
			  len = get_absolute_expression ();
			  if (beg + len > strlen (value))
			    {
			      as_bad (_("Invalid length (use 0 to %d"),
				      (int) strlen (value) - beg);
			      break;
			    }
			}
		      newval += beg - 1;
		      newval[len] = 0;
		      tail = input_line_pointer;
		      if (*tail++ != ')')
			{
			  as_bad (_("Missing ')' in subscripted substitution "
				    "symbol expression"));
			  break;
			}
		      c = *tail;
		      input_line_pointer = savedp;

		      value = newval;
		    }
		  name[-1] = 0;
		}
	      tmp = xmalloc (strlen (head) + strlen (value) +
			     strlen (tail + 1) + 2);
	      strcpy (tmp, head);
	      strcat (tmp, value);
	      /* Make sure forced substitutions are properly terminated.  */
	      if (forced)
		{
		  if (c != ':')
		    {
		      as_bad (_("Missing forced substitution terminator ':'"));
		      break;
		    }
		  ++tail;
		}
	      else
		/* Restore the character after the symbol end.  */
		*tail = c;
	      strcat (tmp, tail);
	      /* Continue examining after the replacement value.  */
	      ptr = tmp + strlen (head) + strlen (value);
	      free (replacement);
	      head = replacement = tmp;
	      changed = 1;
	    }
	  else
	    *ptr = c;
	}
      else
	{
	  ++ptr;
	}
    }

  if (changed)
    return replacement;
  else
    return line;
}

/* We use this to handle substitution symbols
   hijack input_line_pointer, replacing it with our substituted string.

   .sslist should enable listing the line after replacements are made...

   returns the new buffer limit.  */

void
tic54x_start_line_hook (void)
{
  char *line, *endp;
  char *replacement = NULL;

  /* Work with a copy of the input line, including EOL char.  */
  endp = input_line_pointer;
  while (!is_end_of_line[(int) *endp++])
    ;
  line = xmalloc (endp - input_line_pointer + 1);
  strncpy (line, input_line_pointer, endp - input_line_pointer + 1);
  line[endp - input_line_pointer] = 0;

  /* Scan ahead for parallel insns.  */
  parallel_on_next_line_hint = next_line_shows_parallel (endp + 1);

  /* If within a macro, first process forced replacements.  */
  if (macro_level > 0)
    replacement = subsym_substitute (line, 1);
  else
    replacement = line;
  replacement = subsym_substitute (replacement, 0);

  if (replacement != line)
    {
      char *tmp = replacement;
      char *comment = strchr (replacement, ';');
      char endc = replacement[strlen (replacement) - 1];

      /* Clean up the replacement; we'd prefer to have this done by the
	 standard preprocessing equipment (maybe do_scrub_chars?)
	 but for now, do a quick-and-dirty.  */
      if (comment != NULL)
	{
	  comment[0] = endc;
	  comment[1] = 0;
	  --comment;
	}
      else
	comment = replacement + strlen (replacement) - 1;

      /* Trim trailing whitespace.  */
      while (ISSPACE (*comment))
	{
	  comment[0] = endc;
	  comment[1] = 0;
	  --comment;
	}

      /* Compact leading whitespace.  */
      while (ISSPACE (tmp[0]) && ISSPACE (tmp[1]))
	++tmp;

      input_line_pointer = endp;
      input_scrub_insert_line (tmp);
      free (replacement);
      free (line);
      /* Keep track of whether we've done a substitution.  */
      substitution_line = 1;
    }
  else
    {
      /* No change.  */
      free (line);
      substitution_line = 0;
    }
}

/* This is the guts of the machine-dependent assembler.  STR points to a
   machine dependent instruction.  This function is supposed to emit
   the frags/bytes it assembles to.  */
void
md_assemble (char *line)
{
  static int repeat_slot = 0;
  static int delay_slots = 0; /* How many delay slots left to fill?  */
  static int is_parallel = 0;
  static tic54x_insn insn;
  char *lptr;
  char *savedp = input_line_pointer;
  int c;

  input_line_pointer = line;
  c = get_symbol_end ();

  if (cpu == VNONE)
    cpu = V542;
  if (address_mode_needs_set)
    {
      set_address_mode (amode);
      address_mode_needs_set = 0;
    }
  if (cpu_needs_set)
    {
      set_cpu (cpu);
      cpu_needs_set = 0;
    }
  assembly_begun = 1;

  if (is_parallel)
    {
      is_parallel = 0;

      strcpy (insn.parmnemonic, line);
      lptr = input_line_pointer;
      *lptr = c;
      input_line_pointer = savedp;

      if (tic54x_parse_parallel_insn_lastline (&insn, lptr))
	{
	  int words = build_insn (&insn);

	  if (delay_slots != 0)
	    {
	      if (words > delay_slots)
		{
		  as_bad (_("Instruction does not fit in available delay "
			    "slots (%d-word insn, %d slots left)"),
			  words, delay_slots);
		  delay_slots = 0;
		  return;
		}
	      delay_slots -= words;
	    }
	}
      return;
    }

  memset (&insn, 0, sizeof (insn));
  strcpy (insn.mnemonic, line);
  lptr = input_line_pointer;
  *lptr = c;
  input_line_pointer = savedp;

  /* See if this line is part of a parallel instruction; if so, either this
     line or the next line will have the "||" specifier preceding the
     mnemonic, and we look for it in the parallel insn hash table.  */
  if (strstr (line, "||") != NULL || parallel_on_next_line_hint)
    {
      char *tmp = strstr (line, "||");
      if (tmp != NULL)
	*tmp = '\0';

      if (tic54x_parse_parallel_insn_firstline (&insn, lptr))
	{
	  is_parallel = 1;
	  /* If the parallel part is on the same line, process it now,
	     otherwise let the assembler pick up the next line for us.  */
	  if (tmp != NULL)
	    {
	      while (ISSPACE (tmp[2]))
		++tmp;
	      md_assemble (tmp + 2);
	    }
	}
      else
	{
	  as_bad (_("Unrecognized parallel instruction '%s'"), line);
	}
      return;
    }

  if (tic54x_parse_insn (&insn, lptr))
    {
      int words;

      if ((insn.tm->flags & FL_LP)
	  && cpu != V545LP && cpu != V546LP)
	{
	  as_bad (_("Instruction '%s' requires an LP cpu version"),
		  insn.tm->name);
	  return;
	}
      if ((insn.tm->flags & FL_FAR)
	  && amode != far_mode)
	{
	  as_bad (_("Instruction '%s' requires far mode addressing"),
		  insn.tm->name);
	  return;
	}

      words = build_insn (&insn);

      /* Is this instruction in a delay slot?  */
      if (delay_slots)
	{
	  if (words > delay_slots)
	    {
	      as_warn (_("Instruction does not fit in available delay "
			 "slots (%d-word insn, %d slots left). "
			 "Resulting behavior is undefined."),
		       words, delay_slots);
	      delay_slots = 0;
	      return;
	    }
	  /* Branches in delay slots are not allowed.  */
	  if (insn.tm->flags & FL_BMASK)
	    {
	      as_warn (_("Instructions which cause PC discontinuity are not "
			 "allowed in a delay slot. "
			 "Resulting behavior is undefined."));
	    }
	  delay_slots -= words;
	}

      /* Is this instruction the target of a repeat?  */
      if (repeat_slot)
	{
	  if (insn.tm->flags & FL_NR)
	    as_warn (_("'%s' is not repeatable. "
		       "Resulting behavior is undefined."),
		     insn.tm->name);
	  else if (insn.is_lkaddr)
	    as_warn (_("Instructions using long offset modifiers or absolute "
		       "addresses are not repeatable. "
		       "Resulting behavior is undefined."));
	  repeat_slot = 0;
	}

      /* Make sure we check the target of a repeat instruction.  */
      if (insn.tm->flags & B_REPEAT)
	{
	  repeat_slot = 1;
	  /* FIXME -- warn if repeat_slot == 1 at EOF.  */
	}
      /* Make sure we check our delay slots for validity.  */
      if (insn.tm->flags & FL_DELAY)
	{
	  delay_slots = 2;
	  /* FIXME -- warn if delay_slots != 0 at EOF.  */
	}
    }
}

/* Do a final adjustment on the symbol table; in this case, make sure we have
   a ".file" symbol.  */

void
tic54x_adjust_symtab (void)
{
  if (symbol_rootP == NULL
      || S_GET_STORAGE_CLASS (symbol_rootP) != C_FILE)
    {
      char *filename;
      unsigned lineno;
      as_where (&filename, &lineno);
      c_dot_file_symbol (filename, 0);
    }
}

/* In order to get gas to ignore any | chars at the start of a line,
   this function returns true if a | is found in a line.
   This lets us process parallel instructions, which span two lines.  */

int
tic54x_unrecognized_line (int c)
{
  return c == PARALLEL_SEPARATOR;
}

/* Watch for local labels of the form $[0-9] and [_a-zA-Z][_a-zA-Z0-9]*?
   Encode their names so that only we see them and can map them to the
   appropriate places.
   FIXME -- obviously this isn't done yet.  These locals still show up in the
   symbol table.  */
void
tic54x_define_label (symbolS *sym)
{
  /* Just in case we need this later; note that this is not necessarily the
     same thing as line_label...
     When aligning or assigning labels to fields, sometimes the label is
     assigned other than the address at which the label appears.
     FIXME -- is this really needed? I think all the proper label assignment
     is done in tic54x_cons.  */
  last_label_seen = sym;
}

/* Try to parse something that normal parsing failed at.  */

symbolS *
tic54x_undefined_symbol (char *name)
{
  symbol *sym;

  /* Not sure how to handle predefined symbols.  */
  if ((sym = (symbol *) hash_find (cc_hash, name)) != NULL ||
      (sym = (symbol *) hash_find (cc2_hash, name)) != NULL ||
      (sym = (symbol *) hash_find (cc3_hash, name)) != NULL ||
      (sym = (symbol *) hash_find (misc_symbol_hash, name)) != NULL ||
      (sym = (symbol *) hash_find (sbit_hash, name)) != NULL)
    {
      return symbol_new (name, reg_section,
			 (valueT) sym->value,
			 &zero_address_frag);
    }

  if ((sym = (symbol *) hash_find (reg_hash, name)) != NULL ||
      (sym = (symbol *) hash_find (mmreg_hash, name)) != NULL ||
      !strcasecmp (name, "a") || !strcasecmp (name, "b"))
    {
      return symbol_new (name, reg_section,
			 (valueT) sym ? sym->value : 0,
			 &zero_address_frag);
    }

  return NULL;
}

/* Parse a name in an expression before the expression parser takes a stab at
   it.  */

int
tic54x_parse_name (char *name ATTRIBUTE_UNUSED,
		   expressionS *expn ATTRIBUTE_UNUSED)
{
  return 0;
}

char *
md_atof (int type, char *literalP, int *sizeP)
{
  /* Target data is little-endian, but floats are stored
     big-"word"ian.  ugh.  */
  return ieee_md_atof (type, literalP, sizeP, TRUE);
}

arelent *
tc_gen_reloc (asection *section, fixS *fixP)
{
  arelent *rel;
  bfd_reloc_code_real_type code = fixP->fx_r_type;
  asymbol *sym = symbol_get_bfdsym (fixP->fx_addsy);

  rel = (arelent *) xmalloc (sizeof (arelent));
  rel->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *rel->sym_ptr_ptr = sym;
  /* We assume that all rel->address are host byte offsets.  */
  rel->address = fixP->fx_frag->fr_address + fixP->fx_where;
  rel->address /= OCTETS_PER_BYTE;
  rel->howto = bfd_reloc_type_lookup (stdoutput, code);
  if (!strcmp (sym->name, section->name))
    rel->howto += HOWTO_BANK;

  if (!rel->howto)
    {
      const char *name = S_GET_NAME (fixP->fx_addsy);
      if (name == NULL)
	name = "<unknown>";
      as_fatal ("Cannot generate relocation type for symbol %s, code %s",
		name, bfd_get_reloc_code_name (code));
      return NULL;
    }
  return rel;
}

/* Handle cons expressions.  */

void
tic54x_cons_fix_new (fragS *frag, int where, int octets, expressionS *expn)
{
  bfd_reloc_code_real_type r;

  switch (octets)
    {
    default:
      as_bad (_("Unsupported relocation size %d"), octets);
      r = BFD_RELOC_TIC54X_16_OF_23;
      break;
    case 2:
      r = BFD_RELOC_TIC54X_16_OF_23;
      break;
    case 4:
      /* TI assembler always uses this, regardless of addressing mode.  */
      if (emitting_long)
	r = BFD_RELOC_TIC54X_23;
      else
	/* We never want to directly generate this; this is provided for
	   stabs support only.  */
	r = BFD_RELOC_32;
      break;
    }
  fix_new_exp (frag, where, octets, expn, 0, r);
}

/* Attempt to simplify or even eliminate a fixup.
   To indicate that a fixup has been eliminated, set fixP->fx_done.

   If fixp->fx_addsy is non-NULL, we'll have to generate a reloc entry.   */

void
md_apply_fix (fixS *fixP, valueT *valP, segT seg ATTRIBUTE_UNUSED)
{
  char *buf = fixP->fx_where + fixP->fx_frag->fr_literal;
  valueT val = * valP;

  switch (fixP->fx_r_type)
    {
    default:
      as_fatal ("Bad relocation type: 0x%02x", fixP->fx_r_type);
      return;
    case BFD_RELOC_TIC54X_MS7_OF_23:
      val = (val >> 16) & 0x7F;
      /* Fall through.  */
    case BFD_RELOC_TIC54X_16_OF_23:
    case BFD_RELOC_16:
      bfd_put_16 (stdoutput, val, buf);
      /* Indicate what we're actually writing, so that we don't get warnings
	 about exceeding available space.  */
      *valP = val & 0xFFFF;
      break;
    case BFD_RELOC_TIC54X_PARTLS7:
      bfd_put_16 (stdoutput,
		  (bfd_get_16 (stdoutput, buf) & 0xFF80) | (val & 0x7F),
		  buf);
      /* Indicate what we're actually writing, so that we don't get warnings
	 about exceeding available space.  */
      *valP = val & 0x7F;
      break;
    case BFD_RELOC_TIC54X_PARTMS9:
      /* TI assembler doesn't shift its encoding for relocatable files, and is
	 thus incompatible with this implementation's relocatable files.  */
      bfd_put_16 (stdoutput,
		  (bfd_get_16 (stdoutput, buf) & 0xFE00) | (val >> 7),
		  buf);
      break;
    case BFD_RELOC_32:
    case BFD_RELOC_TIC54X_23:
      bfd_put_32 (stdoutput,
		  (bfd_get_32 (stdoutput, buf) & 0xFF800000) | val,
		  buf);
      break;
    }

  if (fixP->fx_addsy == NULL && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;
}

/* This is our chance to record section alignment
   don't need to do anything here, since BFD does the proper encoding.  */

valueT
md_section_align (segT segment ATTRIBUTE_UNUSED, valueT section_size)
{
  return section_size;
}

long
md_pcrel_from (fixS *fixP ATTRIBUTE_UNUSED)
{
  return 0;
}

/* Mostly little-endian, but longwords (4 octets) get MS word stored
   first.  */

void
tic54x_number_to_chars (char *buf, valueT val, int n)
{
  if (n != 4)
    number_to_chars_littleendian (buf, val, n);
  else
    {
      number_to_chars_littleendian (buf    , val >> 16   , 2);
      number_to_chars_littleendian (buf + 2, val & 0xFFFF, 2);
    }
}

int
tic54x_estimate_size_before_relax (fragS *frag ATTRIBUTE_UNUSED,
				   segT seg ATTRIBUTE_UNUSED)
{
  return 0;
}

/* We use this to handle bit allocations which we couldn't handle before due
   to symbols being in different frags.  return number of octets added.  */

int
tic54x_relax_frag (fragS *frag, long stretch ATTRIBUTE_UNUSED)
{
  symbolS *sym = frag->fr_symbol;
  int growth = 0;
  int i;

  if (sym != NULL)
    {
      struct bit_info *bi = (struct bit_info *) frag->fr_opcode;
      int bit_offset = frag_bit_offset (frag_prev (frag, bi->seg), bi->seg);
      int size = S_GET_VALUE (sym);
      fragS *prev_frag = bit_offset_frag (frag_prev (frag, bi->seg), bi->seg);
      int available = 16 - bit_offset;

      if (symbol_get_frag (sym) != &zero_address_frag
	  || S_IS_COMMON (sym)
	  || !S_IS_DEFINED (sym))
	as_bad_where (frag->fr_file, frag->fr_line,
		      _("non-absolute value used with .space/.bes"));

      if (size < 0)
	{
	  as_warn (_("negative value ignored in %s"),
		   bi->type == TYPE_SPACE ? ".space" :
		   bi->type == TYPE_BES ? ".bes" : ".field");
	  growth = 0;
	  frag->tc_frag_data = frag->fr_fix = 0;
	  return 0;
	}

      if (bi->type == TYPE_FIELD)
	{
	  /* Bit fields of 16 or larger will have already been handled.  */
	  if (bit_offset != 0 && available >= size)
	    {
	      char *p = prev_frag->fr_literal;

	      valueT value = bi->value;
	      value <<= available - size;
	      value |= ((unsigned short) p[1] << 8) | p[0];
	      md_number_to_chars (p, value, 2);
	      if ((prev_frag->tc_frag_data += size) == 16)
		prev_frag->tc_frag_data = 0;
	      if (bi->sym)
		symbol_set_frag (bi->sym, prev_frag);
	      /* This frag is no longer used.  */
	      growth = -frag->fr_fix;
	      frag->fr_fix = 0;
	      frag->tc_frag_data = 0;
	    }
	  else
	    {
	      char *p = frag->fr_literal;

	      valueT value = bi->value << (16 - size);
	      md_number_to_chars (p, value, 2);
	      if ((frag->tc_frag_data = size) == 16)
		frag->tc_frag_data = 0;
	      growth = 0;
	    }
	}
      else
	{
	  if (bit_offset != 0 && bit_offset < 16)
	    {
	      if (available >= size)
		{
		  if ((prev_frag->tc_frag_data += size) == 16)
		    prev_frag->tc_frag_data = 0;
		  if (bi->sym)
		    symbol_set_frag (bi->sym, prev_frag);
		  /* This frag is no longer used.  */
		  growth = -frag->fr_fix;
		  frag->fr_fix = 0;
		  frag->tc_frag_data = 0;
		  goto getout;
		}
	      if (bi->type == TYPE_SPACE && bi->sym)
		symbol_set_frag (bi->sym, prev_frag);
	      size -= available;
	    }
	  growth = (size + 15) / 16 * OCTETS_PER_BYTE - frag->fr_fix;
	  for (i = 0; i < growth; i++)
	    frag->fr_literal[i] = 0;
	  frag->fr_fix = growth;
	  frag->tc_frag_data = size % 16;
	  /* Make sure any BES label points to the LAST word allocated.  */
	  if (bi->type == TYPE_BES && bi->sym)
	    S_SET_VALUE (bi->sym, frag->fr_fix / OCTETS_PER_BYTE - 1);
	}
    getout:
      frag->fr_symbol = 0;
      frag->fr_opcode = 0;
      free ((void *) bi);
    }
  return growth;
}

void
tic54x_convert_frag (bfd *abfd ATTRIBUTE_UNUSED,
		     segT seg ATTRIBUTE_UNUSED,
		     fragS *frag)
{
  /* Offset is in bytes.  */
  frag->fr_offset = (frag->fr_next->fr_address
		     - frag->fr_address
		     - frag->fr_fix) / frag->fr_var;
  if (frag->fr_offset < 0)
    {
      as_bad_where (frag->fr_file, frag->fr_line,
		    _("attempt to .space/.bes backwards? (%ld)"),
		    (long) frag->fr_offset);
    }
  frag->fr_type = rs_space;
}

/* We need to avoid having labels defined for certain directives/pseudo-ops
   since once the label is defined, it's in the symbol table for good.  TI
   syntax puts the symbol *before* the pseudo (which is kinda like MRI syntax,
   I guess, except I've never seen a definition of MRI syntax).

   C is the character that used to be at *REST, which points to the end of the
   label.

   Don't allow labels to start with '.'  */

int
tic54x_start_label (int c, char *rest)
{
  /* If within .struct/.union, no auto line labels, please.  */
  if (current_stag != NULL)
    return 0;

  /* Disallow labels starting with "."  */
  if (c != ':')
    {
      char *label = rest;

      while (!is_end_of_line[(int) label[-1]])
	--label;
      if (*label == '.')
	{
	  as_bad (_("Invalid label '%s'"), label);
	  return 0;
	}
    }

  if (is_end_of_line[(int) c])
    return 1;

  if (ISSPACE (c))
    while (ISSPACE (c = *++rest))
      ;
  if (c == '.')
    {
      /* Don't let colon () define a label for any of these...  */
      return (strncasecmp (rest, ".tag", 4) != 0 || !ISSPACE (rest[4]))
	&& (strncasecmp (rest, ".struct", 7) != 0 || !ISSPACE (rest[7]))
	&& (strncasecmp (rest, ".union", 6) != 0 || !ISSPACE (rest[6]))
	&& (strncasecmp (rest, ".macro", 6) != 0 || !ISSPACE (rest[6]))
	&& (strncasecmp (rest, ".set", 4) != 0 || !ISSPACE (rest[4]))
	&& (strncasecmp (rest, ".equ", 4) != 0 || !ISSPACE (rest[4]));
    }

  return 1;
}
@


1.35
log
@	* config/obj-evax.h (S_SET_OTHER, S_SET_TYPE, S_SET_DESC): Don't define.
	* config/tc-crx.c (gettrap): Constify arg.
	(handle_LoadStor, get_cinv_parameters): Likewise.
	(getreg_image): Fix enum warning
	(md_assemble): Restore input line char.
	* config/tc-hppa.c (tc_gen_reloc): Fix enum warning.
	* config/tc-i960.c (mem_fmt): Rename var to fix shadow warning.
	* config/tc-sh.c (sh_fdpic): Only define when OBJ_ELF.
	(build_Mytes): Fix build failure for non-elf targets.
	* config/tc-tic4x.c (tic4x_eval): Restore terminator char.
	* config/tc-xtensa.c (xtensa_end_directive): Fix switch enum warning.

	* cgen.c (gas_cgen_md_apply_fix): Avoid set but unused warning.
	* ecoff.c (add_ecoff_symbol): Likewise.
	* itbl-ops.c (append_insns_as_macros): Likewise.
	* listing.c (debugging_pseudo): Likewise.
	* read.c (s_mri_common, stringer): Likewise.
	* config/obj-coff.c (coff_frob_section): Likewise.
	* config/tc-alpha.c (emit_ldgp, s_alpha_proc): Likewise.
	* config/tc-arm.c (my_get_expression): Likewise.
	* config/tc-hppa.c (process_exit, pa_type_args): Likewise.
	* config/tc-m32c.c (md_assemble): Likewise.
	* config/tc-microblaze.c (md_convert_frag): Likewise.
	* config/tc-mips.c (s_change_section): Likewise.
	* config/tc-mt.c (mt_fix_adjustable): Likewise.
	* config/tc-xtensa.c (xtensa_literal_pseudo): Likewise.

	* config/obj-aout.c (obj_aout_frob_symbol): Delete set but otherwise
	unused vars.
	* config/tc-alpha.c (load_expression): Likewise.
	(s_alpha_rdata, s_alpha_section, s_alpha_prologue): Likewise.
	* config/tc-arm.c (parse_neon_el_struct_list): Likewise.
	* config/tc-avr.c (extract_word): Likewise.
	* config/tc-cris.c (cris_get_expression): Likewise.
	* config/tc-d30v.c (build_insn, find_format): Likewise.
	* config/tc-dlx.c (machine_ip): Likewise.
	* config/tc-hppa.c (pa_get_absolute_expression): Likewise.
	* config/tc-i370.c (md_assemble): Likewise.
	* config/tc-i960.c (brtab_emit): Likewise.
	* config/tc-iq2000.c (s_iq2000_ent): Likewise.
	* config/tc-m32c.c (md_convert_frag): Likewise.
	* config/tc-m68hc11.c (fixup24, build_jump_insn): Likewise.
	(md_estimate_size_before_relax, md_apply_fix): Likewise.
	* config/tc-m68k.c (md_show_usage): Likewise.
	* config/tc-microblaze.c (microblaze_s_lcomm): Likewise.
	* config/tc-mips.c (s_mips_end): Likewise.
	* config/tc-mmix.c (mmix_byte, mmix_cons): Likewise.
	* config/tc-mn10300.c (md_assemble): Likewise.
	* config/tc-msp430.c (extract_word): Likewise.
	* config/tc-mt.c (md_assemble): Likewise.
	* config/tc-or32.c (machine_ip): Likewise.
	* config/tc-pj.c (md_apply_fix): Likewise.
	* config/tc-s390.c (md_gather_operands): Likewise.
	* config/tc-sh.c (sh_cons_align): Likewise.
	* config/tc-sparc.c (sparc_cons_align): Likewise.
	* config/tc-tic4x.c (tic4x_sect): Likewise.
	* config/tc-tic54x.c (tic54x_stringer): Likewise.
	* config/tc-vax.c (vip_op): Likewise.
	* config/tc-xstormy16.c (xstormy16_cons_fix_new): Likewise.
	* config/tc-xtensa.c (md_assemble): Likewise.
	(xtensa_fix_short_loop_frags, convert_frag_immed): Likewise.
	(xtensa_move_literals): Likewise.
@
text
@d3 1
a3 1
   2009, 2010  Free Software Foundation, Inc.
d48 1
a49 1
#include "as.h"
@


1.34
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d3 1
a3 1
   2009  Free Software Foundation, Inc.
a1572 1
  char *start;
a1601 1
	  start = input_line_pointer;
@


1.33
log
@        Updated sources to avoid using the identifier name "new", which is a
        keyword in c++.

        * bfd/aoutx.h (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol.
        * bfd/coffgen.c (coff_make_empty_symbol)
        (coff_bfd_make_debug_symbol): Rename variable new to new_symbol.
        * bfd/cpu-ia64-opc.c (ext_reg, ins_imms_scaled): Rename variable
        new to new_insn.
        * bfd/doc/chew.c (newentry, add_intrinsic): Rename variable new to
        new_d.
        * bfd/ecoff.c (_bfd_ecoff_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/elf32-m68k.c (elf_m68k_get_got_entry_type): Rename argument
        new to new_reloc.
        * bfd/hash.c (bfd_hash_lookup): Rename variable new to new_string.
        * bfd/ieee.c (ieee_make_empty_symbol): Rename variable new to
        new_symbol.
        * bfd/linker.c (bfd_new_link_order): Rename variable new to
        new_lo.
        * bfd/mach-o.c (bfd_mach_o_sizeof_headers): Rename variable new to
        symbol.
        * bfd/oasys.c (oasys_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/pdp11.c (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol_type.
        * bfd/plugin.c (bfd_plugin_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/rs6000-core.c (CoreHdr, VmInfo): Rename union member new to
        new_dump.
        (read_hdr, rs6000coff_core_p)
        (rs6000coff_core_file_matches_executable_p)
        (rs6000coff_core_file_failing_command)
        (rs6000coff_core_file_failing_signal): Updated function to use new
        union member name.
        * bfd/som.c (som_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/syms.c (_bfd_generic_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/tekhex.c (first_phase, tekhex_make_empty_symbol): Rename
        variable new to new_symbol.
        * binutils/nlmconv.c (main): Rename variable new to new_name.
        * gas/config/tc-arm.c (insert_reg_alias): Rename variable new to
        new_reg.
        * gas/config/tc-dlx.c (parse_operand): Rename variable new to
        new_pos.
        * gas/config/tc-ia64.c (ia64_gen_real_reloc_type): Rename variable
        new to newr.
        * gas/config/tc-mcore.c (parse_exp, parse_imm): Rename variable
        new to new_pointer.
        * gas/config/tc-microblaze.c (parse_exp, parse_imm, check_got):
        Change name from new to new_pointer.
        * gas/config/tc-or32.c (parse_operand): Rename variable new to
        new_pointer.
        * gas/config/tc-pdp11.c (md_assemble): Rename variable new to
        new_pointer.
        * gas/config/tc-pj.c (alias): Change argument new to new_name.
        * gas/config/tc-score.c (s3_build_score_ops_hsh): Rename variable
        new to new_opcode. (s3_build_dependency_insn_hsh) Rename variable
        new to new_i2n. (s3_convert): Rename variables old and new to
        r_old and r_new.
        * gas/config/tc-score7.c (s7_build_score_ops_hsh): Rename variable
        new to new_opcode. (s7_build_dependency_insn_hsh): Rename variable
        new to new_i2d. (s7_b32_relax_to_b16, s7_convert_frag): Rename
        variables old and new to r_old and r_new.
        * gas/config/tc-sh.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-sh64.c (shmedia_parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-tic4x.c (tic4x_operand_parse): Rename variable new
        to new_pointer.
        * gas/config/tc-z8k.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/listing.c (listing_newline): Rename variable new to new_i.
        * ld/ldexp.c (exp_intop, exp_bigintop, exp_relop, exp_binop)
        (exp_trinop, exp_unop, exp_nameop, exp_assop): Rename variable new
        to new_e.
        * ld/ldfile.c (ldfile_add_library_path): Rename variable new to
        new_dirs. (ldfile_add_arch): Rename variable new to new_arch.
        * ld/ldlang.c (new_statement, lang_final, lang_add_wild)
        (lang_target, lang_add_fill, lang_add_data, lang_add_assignment)
        (lang_add_insert): Rename variable new to new_stmt. (new_afile):
        Added missing cast. (lang_memory_region_lookup): Rename variable
        new to new_region. (init_os): Rename variable new to
        new_userdata. (lang_add_section): Rename variable new to
        new_section. (ldlang_add_undef): Rename variable new to
        new_undef. (realsymbol): Rename variable new to new_name.
        * opcodes/z8kgen.c (internal, gas): Rename variable new to new_op.

        Updated sources to avoid using the identifier name "template",
        which is a keyword in c++.

        * bfd/elf32-arm.c (struct stub_def): Rename member template to
        template_sequence. (arm_build_one_stub,
        find_stub_size_and_template, arm_size_one_stub, arm_map_one_stub):
        Rename variable template to template_sequence.
        * bfd/elfxx-ia64.c (elfNN_ia64_relax_br, elfNN_ia64_relax_brl):
        Rename variable template to template_val.
        * gas/config/tc-arm.c (struct asm_cond, struct asm_psr, struct
        asm_barrier_opt): Change member template to
        template_name. (md_begin): Update code to reflect new member
        names.
        * gas/config/tc-i386.c (struct templates, struct _i386_insn)
        (match_template, cpu_flags_match, match_reg_size, match_mem_size)
        (operand_size_match, md_begin, i386_print_statistics, pi)
        (build_vex_prefix, md_assemble, parse_insn, optimize_imm)
        (optimize_disp): Updated code to use new names. (parse_insn):
        Added casts.
        * gas/config/tc-ia64.c (dot_template, emit_one_bundle): Updated
        code to use new names.
        * gas/config/tc-score.c (struct s3_asm_opcode): Renamed member
        template to template_name. (s3_parse_16_32_inst, s3_parse_48_inst,
        s3_do_macro_ldst_label, s3_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-score7.c (struct s7_asm_opcode): Renamed member
        template to template_name. (s7_parse_16_32_inst,
        s7_do_macro_ldst_label, s7_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-tic30.c (md_begin, struct tic30_insn)
        (md_assemble): Update code to use new names.
        * gas/config/tc-tic54x.c (struct _tic54x_insn, md_begin)
        (optimize_insn, tic54x_parse_insn, next_line_shows_parallel):
        Update code to use new names.
        * include/opcode/tic30.h (template): Rename type template to
        insn_template. Updated code to use new name.
        * include/opcode/tic54x.h (template): Rename type template to
        insn_template.
        * opcodes/cris-dis.c (bytes_to_skip): Update code to use new name.
        * opcodes/i386-dis.c (putop): Update code to use new name.
        * opcodes/i386-gen.c (process_i386_opcodes): Update code to use
        new name.
        * opcodes/i386-opc.h (struct template): Rename struct template to
        insn_template. Update code accordingly.
        * opcodes/i386-tbl.h (i386_optab): Update type to use new name.
        * opcodes/ia64-dis.c (print_insn_ia64): Rename variable template
        to template_val.
        * opcodes/tic30-dis.c (struct instruction, get_tic30_instruction):
        Update code to use new name.
        * opcodes/tic54x-dis.c (has_lkaddr, get_insn_size)
        (print_parallel_instruction, print_insn_tic54x, tic54x_get_insn):
        Update code to use new name.
        * opcodes/tic54x-opc.c (tic54x_unknown_opcode, tic54x_optab):
        Update type to new name.
@
text
@d246 1
a246 1
  expressionS exp;
d248 3
a250 3
  exp.X_op = O_constant;
  exp.X_add_number = c;
  emit_expr (&exp, 2);
d301 1
a301 1
parse_expression (char *str, expressionS *exp)
d308 1
a308 1
  expression (exp);
d1021 1
a1021 1
	  expressionS exp;
d1023 2
a1024 2
	  input_line_pointer = parse_expression (input_line_pointer, &exp);
	  if (exp.X_op == O_constant)
d1026 1
a1026 1
	      offsetT value = exp.X_add_number;
d1042 1
a1042 1
	  if (exp.X_op != O_constant && octets < 2)
d1051 1
a1051 1
	  if (exp.X_op != O_constant
d1062 1
a1062 1
	      emit_expr (&exp, 4);
d1069 1
a1069 1
	      emit_expr (&exp, (octets == 1) ? 2 : octets);
d1225 1
a1225 1
  expressionS exp;
d1241 1
a1241 1
  expression (&exp);
d1246 1
a1246 1
  if (exp.X_op != O_constant || frag_bit_offset (frag_now, now_seg) == -1)
a1248 1
      char *p;
d1255 1
a1255 1
		    make_expr_symbol (&exp), (offsetT) 0,
d1270 1
a1270 1
      if (spare_bits >= exp.X_add_number)
d1280 1
a1280 1
	  frag_now->tc_frag_data += exp.X_add_number;
d1283 1
a1283 1
      exp.X_add_number -= spare_bits;
d1294 1
a1294 1
  words = ((exp.X_add_number + bits_per_byte - 1) / bits_per_byte);
d1296 1
a1296 1
  bit_offset = exp.X_add_number % bits_per_byte;
d1697 1
a1697 1
  expressionS exp;
d1709 1
a1709 1
  input_line_pointer = parse_expression (input_line_pointer, &exp);
d1724 1
a1724 1
  if (exp.X_op != O_constant)
d1736 1
a1736 1
      emit_expr (&exp, 2);
d1742 3
a1744 3
      value = exp.X_add_number;
      exp.X_add_number &= fmask;
      if (value != (valueT) exp.X_add_number)
d1746 1
a1746 1
      value = exp.X_add_number;
d2658 1
a2658 1
  expressionS exp;
d2660 1
a2660 1
  parse_expression (a, &exp);
d2662 1
a2662 1
  if (exp.X_op == O_constant)
d4572 1
a4572 1
		  float arg1, arg2 = 0;
d4575 1
a4575 1
		  arg1 = (float) strtod (ptr, &ptr);
d4583 1
a4583 1
		      arg2 = (float) strtod (ptr, &ptr);
d4585 1
a4585 1
		  fresult = (*math_entry->proc) (arg1, arg2);
d5082 1
a5082 1
		   expressionS *exp ATTRIBUTE_UNUSED)
d5127 1
a5127 1
tic54x_cons_fix_new (fragS *frag, int where, int octets, expressionS *exp)
d5150 1
a5150 1
  fix_new_exp (frag, where, octets, exp, 0, r);
@


1.32
log
@        PR 10437
        * config/tc-alpha.c: Fix up uses of gas printf like functions so
        that the format string is a constant string.  Add translation
        support to message strings.
        * config/tc-arc.c: Likewise.
        * config/tc-arm.c: Likewise.
        * config/tc-cris.c: Likewise.
        * config/tc-fr30.c: Likewise.
        * config/tc-frv.c: Likewise.
        * config/tc-h8300.c: Likewise.
        * config/tc-hppa.c: Likewise.
        * config/tc-i370.c: Likewise.
        * config/tc-i960.c: Likewise.
        * config/tc-ia64.c: Likewise.
        * config/tc-m32r.c: Likewise.
        * config/tc-mep.c: Likewise.
        * config/tc-mips.c: Likewise.
        * config/tc-moxie.c: Likewise.
        * config/tc-msp430.c: Likewise.
        * config/tc-openrisc.c: Likewise.
        * config/tc-pdp11.c: Likewise.
        * config/tc-pj.c: Likewise.
        * config/tc-s390.c: Likewise.
        * config/tc-sh.c: Likewise.
        * config/tc-sh64.c: Likewise.
        * config/tc-sparc.c: Likewise.
        * config/tc-spu.c: Likewise.
        * config/tc-tic30.c: Likewise.
        * config/tc-tic4x.c: Likewise.
        * config/tc-tic54x.c: Likewise.
        * config/tc-v850.c: Likewise.
        * config/tc-xc16x.c: Likewise.
        * config/tc-xstormy16.c: Likewise.
        * config/tc-z80.c: Likewise.
        * config/tc-z8k.c: Likewise.
        * config/atof-ieee.c: Add translation support to as_warn
        messages.
        * config/obj-coff.c: Likewise.
@
text
@d84 1
a84 1
  const template *tm;		/* Opcode template.  */
d2992 1
a2992 1
  template *tm;
d3021 1
a3021 1
  for (tm = (template *) tic54x_optab; tm->name; tm++)
d3031 1
a3031 1
  for (tm = (template *) tic54x_paroptab; tm->name; tm++)
d4182 1
a4182 1
  insn->tm = (template *) hash_find (op_hash, insn->mnemonic);
d4205 2
a4206 2
	      insn->tm = (template *) hash_find (op_hash,
						 insn->mnemonic);
d4240 1
a4240 1
  insn->tm = (template *) hash_find (parop_hash, insn->mnemonic);
@


1.31
log
@Banish PARAMS and PTR.  Convert to ISO C.
Delete unnecessary forward declarations.
@
text
@d2 2
a3 2
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
   Free Software Foundation, Inc.
d359 1
a359 1
      as_bad ("symbols assigned with .asg must begin with a letter");
d479 1
a479 1
      as_bad (".bss size argument missing\n");
d488 1
a488 1
      as_bad (".bss size %d < 0!", words);
d1033 1
a1033 1
		    as_warn ("Overflow in expression, truncated to 8 bits");
d1038 1
a1038 1
		    as_warn ("Overflow in expression, truncated to 16 bits");
d1442 1
a1442 1
    as_warn ("Error setting flags for \"%s\": %s", name,
d3131 1
a3131 1
		  as_bad ("Unbalanced parenthesis in operand %d", numexp);
d3162 1
a3162 1
	      as_bad ("Expecting operand after ','");
d3170 1
a3170 1
	      as_bad ("Expecting operand after ','");
d3181 1
a3181 1
      as_bad ("Extra junk on line");
@


1.30
log
@	PR 6575
	* hash.c: Expand PTR to void *.
	(hash_delete): Add "freeme" parameter.  Call obstack_free.
	* hash.h: Expand PTR to void *.
	(hash_delete): Update prototype.
	* macro.c (macro_expand_body): hash_delete LOCALs from formal_hash.
	* config/tc-tic54x.c (tic54x_remove_local_label): Update hash_delete
	call.
	(subsym_substitute): Likewise.
	* doc/internals.texi (hash_delete): Update.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
d225 4
a228 114
static void	tic54x_emit_char 	PARAMS ((char));
static fragS *	frag_prev 		PARAMS ((fragS *, segT));
static fragS *	bit_offset_frag 	PARAMS ((fragS *, segT));
static int	frag_bit_offset 	PARAMS ((fragS *, segT));
static char *	parse_expression 	PARAMS ((char *, expressionS *));
static void	tic54x_asg 		PARAMS ((int));
static void	tic54x_eval 		PARAMS ((int));
static void	tic54x_bss 		PARAMS ((int));
static void	stag_add_field_symbols	PARAMS ((struct stag *, const char *, bfd_vma, symbolS *, const char *));
static void	stag_add_field 		PARAMS ((struct stag *, const char *, bfd_vma, struct stag *));
static void	tic54x_struct 		PARAMS ((int));
static void	tic54x_endstruct 	PARAMS ((int));
static void	tic54x_tag 		PARAMS ((int));
static void	tic54x_struct_field 	PARAMS ((int));
static void	tic54x_cons 		PARAMS ((int));
static void	tic54x_remove_local_label PARAMS ((const char *, PTR));
static void	tic54x_clear_local_labels PARAMS ((int));
static void	tic54x_sect 		PARAMS ((int));
static void	tic54x_space 		PARAMS ((int));
static void	tic54x_usect 		PARAMS ((int));
static enum cpu_version lookup_version	PARAMS ((const char *));
static void	set_cpu 		PARAMS ((enum cpu_version));
static void	tic54x_version 		PARAMS ((int));
static void	tic54x_float_cons 	PARAMS ((int));
static void	tic54x_stringer 	PARAMS ((int));
static void	tic54x_p2align 		PARAMS ((int));
static void	tic54x_align_words 	PARAMS ((int));
static void	tic54x_field 		PARAMS ((int));
static int	tic54x_initialized_section PARAMS ((segT));
static void	tic54x_clink 		PARAMS ((int));
static void	tic54x_set_default_include PARAMS ((int));
static void	tic54x_include 		PARAMS ((int));
static void	tic54x_message 		PARAMS ((int));
static void	tic54x_label 		PARAMS ((int));
static void	tic54x_mmregs 		PARAMS ((int));
static void	tic54x_loop 		PARAMS ((int));
static void	tic54x_endloop 		PARAMS ((int));
static void	tic54x_break 		PARAMS ((int));
static void	set_address_mode 	PARAMS ((int));
static void	tic54x_address_mode 	PARAMS ((int));
static void	tic54x_sblock 		PARAMS ((int));
static void	tic54x_set 		PARAMS ((int));
static void	tic54x_fclist 		PARAMS ((int));
static void	tic54x_sslist 		PARAMS ((int));
static void	tic54x_var 		PARAMS ((int));
static void	tic54x_mlib 		PARAMS ((int));
static int 	subsym_symlen 		PARAMS ((char *, char *));
static int 	subsym_symcmp 		PARAMS ((char *, char *));
static int 	subsym_firstch 		PARAMS ((char *, char *));
static int 	subsym_lastch 		PARAMS ((char *, char *));
static int 	subsym_isdefed 		PARAMS ((char *, char *));
static int 	subsym_ismember 	PARAMS ((char *, char *));
static int 	subsym_iscons 		PARAMS ((char *, char *));
static int 	subsym_isname 		PARAMS ((char *, char *));
static int 	subsym_isreg 		PARAMS ((char *, char *));
static int 	subsym_structsz 	PARAMS ((char *, char *));
static int 	subsym_structacc 	PARAMS ((char *, char *));
static float 	math_ceil 		PARAMS ((float, float));
static float 	math_cvi 		PARAMS ((float, float));
static float 	math_floor 		PARAMS ((float, float));
static float 	math_fmod 		PARAMS ((float, float));
static float 	math_int 		PARAMS ((float, float));
static float 	math_round 		PARAMS ((float, float));
static float 	math_sgn 		PARAMS ((float, float));
static float 	math_trunc 		PARAMS ((float, float));
static float 	math_acos 		PARAMS ((float, float));
static float 	math_asin 		PARAMS ((float, float));
static float 	math_atan 		PARAMS ((float, float));
static float 	math_atan2 		PARAMS ((float, float));
static float 	math_cosh 		PARAMS ((float, float));
static float 	math_cos 		PARAMS ((float, float));
static float 	math_cvf 		PARAMS ((float, float));
static float 	math_exp 		PARAMS ((float, float));
static float 	math_fabs 		PARAMS ((float, float));
static float 	math_ldexp 		PARAMS ((float, float));
static float 	math_log10 		PARAMS ((float, float));
static float 	math_log 		PARAMS ((float, float));
static float 	math_max 		PARAMS ((float, float));
static float 	math_min 		PARAMS ((float, float));
static float 	math_pow 		PARAMS ((float, float));
static float 	math_sin 		PARAMS ((float, float));
static float 	math_sinh 		PARAMS ((float, float));
static float 	math_sqrt 		PARAMS ((float, float));
static float 	math_tan 		PARAMS ((float, float));
static float 	math_tanh 		PARAMS ((float, float));
static int 	is_accumulator 		PARAMS ((struct opstruct *));
static int 	get_operands 		PARAMS ((struct opstruct operands[], char *));
static int 	is_immediate 		PARAMS ((struct opstruct *));
static int 	is_absolute 		PARAMS ((struct opstruct *));
static int 	is_indirect 		PARAMS ((struct opstruct *));
static int 	is_dual 		PARAMS ((struct opstruct *));
static int 	is_mmreg 		PARAMS ((struct opstruct *));
static int 	is_type 		PARAMS ((struct opstruct *, enum optype));
static int 	operands_match 		PARAMS ((tic54x_insn *, struct opstruct *, int, const enum optype *, int, int));
static int 	encode_dmad 		PARAMS ((tic54x_insn *, struct opstruct *, int));
static int 	encode_address 		PARAMS ((tic54x_insn *, struct opstruct *));
static int 	encode_indirect 	PARAMS ((tic54x_insn *, struct opstruct *));
static int 	encode_integer 		PARAMS ((tic54x_insn *, struct opstruct *, int, int, int, unsigned short));
static int 	encode_condition 	PARAMS ((tic54x_insn *, struct opstruct *));
static int 	encode_cc3 		PARAMS ((tic54x_insn *, struct opstruct *));
static int 	encode_arx 		PARAMS ((tic54x_insn *, struct opstruct *));
static int 	encode_cc2 		PARAMS ((tic54x_insn *, struct opstruct *));
static int 	encode_operand 		PARAMS ((tic54x_insn *, enum optype, struct opstruct *));
static void 	emit_insn 		PARAMS ((tic54x_insn *));
static int 	build_insn 		PARAMS ((tic54x_insn *));
static int 	optimize_insn 		PARAMS ((tic54x_insn *));
static int 	tic54x_parse_insn 	PARAMS ((tic54x_insn *, char *));
static int 	next_line_shows_parallel PARAMS ((char *));
static int 	tic54x_parse_parallel_insn_firstline PARAMS ((tic54x_insn *, char *));
static int 	tic54x_parse_parallel_insn_lastline PARAMS ((tic54x_insn *, char *));
static char *	subsym_get_arg 		PARAMS ((char *, char *, char **, int));
static void	subsym_create_or_replace PARAMS ((char *, char *));
static char *	subsym_lookup 		PARAMS ((char *, int));
static char *	subsym_substitute 	PARAMS ((char *, int));
d232 1
a232 2
md_show_usage (stream)
     FILE *stream;
d244 1
a244 2
tic54x_emit_char (c)
     char c;
d256 1
a256 3
frag_prev (frag, seg)
     fragS *frag;
     segT seg;
d269 1
a269 3
bit_offset_frag (frag, seg)
     fragS *frag;
     segT seg;
d287 1
a287 3
frag_bit_offset (frag, seg)
     fragS *frag;
     segT seg;
d301 1
a301 3
parse_expression (str, exp)
     char *str;
     expressionS * exp;
d321 1
a321 2
tic54x_asg (x)
     int x ATTRIBUTE_UNUSED;
d382 1
a382 2
tic54x_eval (x)
     int x ATTRIBUTE_UNUSED;
d458 1
a458 2
tic54x_bss (x)
     int x ATTRIBUTE_UNUSED;
d547 5
a551 6
stag_add_field_symbols (stag, path, base_offset, rootsym, root_stag_name)
     struct stag *stag;
     const char *path;
     bfd_vma base_offset;
     symbolS *rootsym;
     const char *root_stag_name;
d604 4
a607 5
stag_add_field (parent, name, offset, stag)
     struct stag *parent;
     const char *name;
     bfd_vma offset;
     struct stag *stag;
d639 1
a639 2
tic54x_struct (arg)
     int arg;
d719 1
a719 2
tic54x_endstruct (is_union)
     int is_union;
d784 1
a784 2
tic54x_tag (ignore)
     int ignore ATTRIBUTE_UNUSED;
d843 1
a843 2
tic54x_struct_field (type)
     int type;
d962 1
a962 2
tic54x_cons (type)
     int type;
d1100 1
a1100 2
tic54x_global (type)
     int type;
d1134 1
a1134 3
tic54x_remove_local_label (key, value)
     const char *key;
     PTR value ATTRIBUTE_UNUSED;
d1136 1
a1136 1
  PTR *elem = hash_delete (local_label_hash[macro_level], key, FALSE);
d1143 1
a1143 2
tic54x_clear_local_labels (ignored)
     int ignored ATTRIBUTE_UNUSED;
d1162 1
a1162 2
tic54x_sect (arg)
     int arg;
d1223 1
a1223 2
tic54x_space (arg)
     int arg;
d1354 1
a1354 2
tic54x_usect (x)
     int x ATTRIBUTE_UNUSED;
d1450 1
a1450 2
lookup_version (ver)
     const char *ver;
d1471 1
a1471 2
set_cpu (version)
     enum cpu_version version;
d1498 1
a1498 2
tic54x_version (x)
     int x ATTRIBUTE_UNUSED;
d1541 1
a1541 2
tic54x_float_cons (type)
     int type;
d1571 1
a1571 2
tic54x_stringer (type)
     int type;
d1658 1
a1658 2
tic54x_p2align (arg)
     int arg ATTRIBUTE_UNUSED;
d1664 1
a1664 2
tic54x_align_words (arg)
     int arg;
d1696 1
a1696 2
tic54x_field (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1819 1
a1819 2
tic54x_initialized_section (seg)
     segT seg;
d1832 1
a1832 2
tic54x_clink (ignored)
     int ignored ATTRIBUTE_UNUSED;
d1879 1
a1879 2
tic54x_set_default_include (dot)
     int dot;
d1924 1
a1924 2
tic54x_include (ignored)
     int ignored ATTRIBUTE_UNUSED;
d1967 1
a1967 2
tic54x_message (type)
     int type;
d2013 1
a2013 2
tic54x_label (ignored)
     int ignored ATTRIBUTE_UNUSED;
d2034 1
a2034 2
tic54x_mmregs (ignored)
     int ignored ATTRIBUTE_UNUSED;
d2053 1
a2053 2
tic54x_loop (count)
     int count;
d2067 1
a2067 2
tic54x_endloop (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2076 1
a2076 2
tic54x_break (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2091 1
a2091 2
set_address_mode (mode)
     int mode;
d2106 1
a2106 2
tic54x_address_mode (mode)
     int mode;
d2129 1
a2129 2
tic54x_sblock (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2186 1
a2186 2
tic54x_set (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2220 1
a2220 2
tic54x_fclist (show)
     int show;
d2230 1
a2230 2
tic54x_sslist (show)
     int show;
d2241 1
a2241 2
tic54x_var (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2289 1
a2289 2
tic54x_mlib (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2478 1
a2478 3
md_parse_option (c, arg)
     int c;
     char *arg;
d2528 1
a2528 1
tic54x_macro_start ()
d2536 1
a2536 2
tic54x_macro_info (macro)
     const macro_entry *macro;
d2557 1
a2557 1
tic54x_macro_end ()
d2567 1
a2567 3
subsym_symlen (a, ignore)
     char *a;
     char *ignore ATTRIBUTE_UNUSED;
d2575 1
a2575 3
subsym_symcmp (a, b)
     char *a;
     char *b;
d2584 1
a2584 3
subsym_firstch (a, b)
     char *a;
     char *b;
d2595 1
a2595 3
subsym_lastch (a, b)
     char *a;
     char *b;
d2607 1
a2607 3
subsym_isdefed (a, ignore)
     char *a;
     char *ignore ATTRIBUTE_UNUSED;
d2619 1
a2619 3
subsym_ismember (sym, list)
     char *sym;
     char *list;
d2657 1
a2657 3
subsym_iscons (a, ignore)
     char *a;
     char *ignore ATTRIBUTE_UNUSED;
d2696 1
a2696 3
subsym_isname (a, ignore)
     char *a;
     char *ignore ATTRIBUTE_UNUSED;
d2714 1
a2714 3
subsym_isreg (a, ignore)
     char *a;
     char *ignore ATTRIBUTE_UNUSED;
d2726 1
a2726 3
subsym_structsz (name, ignore)
     char *name;
     char *ignore ATTRIBUTE_UNUSED;
d2744 2
a2745 3
subsym_structacc (stag_name, ignore)
     char *stag_name ATTRIBUTE_UNUSED;
     char *ignore ATTRIBUTE_UNUSED;
d2751 1
a2751 3
math_ceil (arg1, ignore)
     float arg1;
     float ignore ATTRIBUTE_UNUSED;
d2757 1
a2757 3
math_cvi (arg1, ignore)
     float arg1;
     float ignore ATTRIBUTE_UNUSED;
d2763 1
a2763 3
math_floor (arg1, ignore)
     float arg1;
     float ignore ATTRIBUTE_UNUSED;
d2769 1
a2769 3
math_fmod (arg1, arg2)
     float arg1;
     float arg2;
d2775 1
a2775 3
math_int (arg1, ignore)
     float arg1;
     float ignore ATTRIBUTE_UNUSED;
d2781 1
a2781 3
math_round (arg1, ignore)
     float arg1;
     float ignore ATTRIBUTE_UNUSED;
d2787 1
a2787 3
math_sgn (arg1, ignore)
     float arg1;
     float ignore ATTRIBUTE_UNUSED;
d2793 1
a2793 3
math_trunc (arg1, ignore)
     float arg1;
     float ignore ATTRIBUTE_UNUSED;
d2799 1
a2799 3
math_acos (arg1, ignore)
     float arg1;
     float ignore ATTRIBUTE_UNUSED;
d2805 1
a2805 3
math_asin (arg1, ignore)
     float arg1;
     float ignore ATTRIBUTE_UNUSED;
d2811 1
a2811 3
math_atan (arg1, ignore)
     float arg1;
     float ignore ATTRIBUTE_UNUSED;
d2817 1
a2817 3
math_atan2 (arg1, arg2)
     float arg1;
     float arg2;
d2823 1
a2823 3
math_cosh (arg1, ignore)
     float arg1;
     float ignore ATTRIBUTE_UNUSED;
d2829 1
a2829 3
math_cos (arg1, ignore)
     float arg1;
     float ignore ATTRIBUTE_UNUSED;
d2835 1
a2835 3
math_cvf (arg1, ignore)
     float arg1;
     float ignore ATTRIBUTE_UNUSED;
d2841 1
a2841 3
math_exp (arg1, ignore)
     float arg1;
     float ignore ATTRIBUTE_UNUSED;
d2847 1
a2847 3
math_fabs (arg1, ignore)
     float arg1;
     float ignore ATTRIBUTE_UNUSED;
d2855 1
a2855 3
math_ldexp (arg1, arg2)
     float arg1;
     float arg2;
d2861 1
a2861 3
math_log10 (arg1, ignore)
     float arg1;
     float ignore ATTRIBUTE_UNUSED;
d2867 1
a2867 3
math_log (arg1, ignore)
     float arg1;
     float ignore ATTRIBUTE_UNUSED;
d2873 1
a2873 3
math_max (arg1, arg2)
     float arg1;
     float arg2;
d2879 1
a2879 3
math_min (arg1, arg2)
     float arg1;
     float arg2;
d2885 1
a2885 3
math_pow (arg1, arg2)
     float arg1;
     float arg2;
d2891 1
a2891 3
math_sin (arg1, ignore)
     float arg1;
     float ignore ATTRIBUTE_UNUSED;
d2897 1
a2897 3
math_sinh (arg1, ignore)
     float arg1;
     float ignore ATTRIBUTE_UNUSED;
d2903 1
a2903 3
math_sqrt (arg1, ignore)
     float arg1;
     float ignore ATTRIBUTE_UNUSED;
d2909 1
a2909 3
math_tan (arg1, ignore)
     float arg1;
     float ignore ATTRIBUTE_UNUSED;
d2915 1
a2915 3
math_tanh (arg1, ignore)
     float arg1;
     float ignore ATTRIBUTE_UNUSED;
d2924 1
a2924 1
  int (*proc) PARAMS ((char *, char *));
d2948 1
a2948 1
  float (*proc) PARAMS ((float, float));
d2990 1
a2990 1
md_begin ()
d3099 1
a3099 2
is_accumulator (operand)
     struct opstruct *operand;
d3110 1
a3110 3
get_operands (operands, line)
     struct opstruct operands[];
     char *line;
d3239 1
a3239 2
is_immediate (operand)
     struct opstruct *operand;
d3248 1
a3248 2
is_absolute (operand)
     struct opstruct *operand;
d3256 1
a3256 2
is_indirect (operand)
     struct opstruct *operand;
d3264 1
a3264 2
is_dual (operand)
     struct opstruct *operand;
d3284 1
a3284 2
is_mmreg (operand)
     struct opstruct *operand;
d3292 1
a3292 3
is_type (operand, type)
     struct opstruct *operand;
     enum optype type;
d3396 6
a3401 7
operands_match (insn, operands, opcount, refoptype, minops, maxops)
     tic54x_insn *insn;
     struct opstruct *operands;
     int opcount;
     const enum optype *refoptype;
     int minops;
     int maxops;
d3464 1
a3464 4
encode_dmad (insn, operand, xpc_code)
     tic54x_insn *insn;
     struct opstruct *operand;
     int xpc_code;
d3525 1
a3525 3
encode_address (insn, operand)
     tic54x_insn *insn;
     struct opstruct *operand;
d3546 1
a3546 3
encode_indirect (insn, operand)
     tic54x_insn *insn;
     struct opstruct *operand;
d3618 6
a3623 7
encode_integer (insn, operand, which, min, max, mask)
     tic54x_insn *insn;
     struct opstruct *operand;
     int which;
     int min;
     int max;
     unsigned short mask;
d3678 1
a3678 3
encode_condition (insn, operand)
     tic54x_insn *insn;
     struct opstruct *operand;
d3738 1
a3738 3
encode_cc3 (insn, operand)
     tic54x_insn *insn;
     struct opstruct *operand;
d3753 1
a3753 3
encode_arx (insn, operand)
     tic54x_insn *insn;
     struct opstruct *operand;
d3767 1
a3767 3
encode_cc2 (insn, operand)
     tic54x_insn *insn;
     struct opstruct *operand;
d3781 1
a3781 4
encode_operand (insn, type, operand)
     tic54x_insn *insn;
     enum optype type;
     struct opstruct *operand;
d4004 1
a4004 2
emit_insn (insn)
     tic54x_insn *insn;
d4037 1
a4037 2
build_insn (insn)
     tic54x_insn *insn;
d4087 1
a4087 2
optimize_insn (insn)
     tic54x_insn *insn;
d4180 1
a4180 3
tic54x_parse_insn (insn, line)
     tic54x_insn *insn;
     char *line;
d4227 1
a4227 2
next_line_shows_parallel (next_line)
     char *next_line;
d4238 1
a4238 3
tic54x_parse_parallel_insn_firstline (insn, line)
     tic54x_insn *insn;
     char *line;
d4269 1
a4269 3
tic54x_parse_parallel_insn_lastline (insn, line)
     tic54x_insn *insn;
     char *line;
d4307 1
a4307 5
subsym_get_arg (line, terminators, str, nosub)
     char *line;
     char *terminators;
     char **str;
     int nosub;
d4370 1
a4370 3
subsym_create_or_replace (name, value)
     char *name;
     char *value;
d4393 1
a4393 3
subsym_lookup (name, nest_level)
     char *name;
     int nest_level;
d4411 1
a4411 3
subsym_substitute (line, forced)
     char * line;
     int forced;
d4770 1
a4770 1
tic54x_start_line_hook ()
d4842 1
a4842 2
md_assemble (line)
     char *line;
d5008 1
a5008 1
tic54x_adjust_symtab ()
d5036 1
a5036 2
tic54x_define_label (sym)
     symbolS *sym;
d5050 1
a5050 2
tic54x_undefined_symbol (name)
     char *name;
d5082 2
a5083 3
tic54x_parse_name (name, exp)
     char *name ATTRIBUTE_UNUSED;
     expressionS *exp ATTRIBUTE_UNUSED;
d5097 1
a5097 3
tc_gen_reloc (section, fixP)
     asection *section;
     fixS *fixP;
d5128 1
a5128 5
tic54x_cons_fix_new (frag, where, octets, exp)
     fragS *frag;
     int where;
     int octets;
     expressionS *exp;
d5160 1
a5160 4
md_apply_fix (fixP, valP, seg)
     fixS *fixP;
     valueT * valP;
     segT seg ATTRIBUTE_UNUSED;
d5211 1
a5211 3
md_section_align (segment, section_size)
     segT segment ATTRIBUTE_UNUSED;
     valueT section_size;
d5217 1
a5217 2
md_pcrel_from (fixP)
     fixS *fixP ATTRIBUTE_UNUSED;
d5226 1
a5226 4
tic54x_number_to_chars (buf, val, n)
     char *buf;
     valueT val;
     int n;
d5238 2
a5239 3
tic54x_estimate_size_before_relax (frag, seg)
     fragS *frag ATTRIBUTE_UNUSED;
     segT seg ATTRIBUTE_UNUSED;
d5248 1
a5248 3
tic54x_relax_frag (frag, stretch)
     fragS *frag;
     long stretch ATTRIBUTE_UNUSED;
d5347 3
a5349 4
tic54x_convert_frag (abfd, seg, frag)
     bfd *abfd ATTRIBUTE_UNUSED;
     segT seg ATTRIBUTE_UNUSED;
     fragS *frag;
d5375 1
a5375 3
tic54x_start_label (c, rest)
     int c;
     char *rest;
@


1.29
log
@Remove duplicate definitions of the md_atof() function
@
text
@d1269 1
a1269 1
  PTR *elem = hash_delete (local_label_hash[macro_level], key);
d4963 1
a4963 1
		  hash_delete (subsym_recurse_hash, name);
@


1.28
log
@Switch to GPLv3
@
text
@d5386 2
a5387 15
md_atof (type, literalP, sizeP)
     int type;
     char *literalP;
     int *sizeP;
{
#define MAX_LITTLENUMS 2
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  LITTLENUM_TYPE *word;
  /* Only one precision on the c54x.  */
  int prec = 2;
  char *t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;
  *sizeP = 4;

d5390 1
a5390 7
  for (word = words; prec--;)
    {
      md_number_to_chars (literalP, (long) (*word++), sizeof (LITTLENUM_TYPE));
      literalP += sizeof (LITTLENUM_TYPE);
    }

  return 0;
@


1.27
log
@	* as.h (as_perror): Delete declaration.
	* gdbinit.in (as_perror): Delete breakpoint.
	* messages.c (as_perror): Delete function.
	* doc/internals.texi: Remove as_perror description.
	* listing.c (listing_print: Don't use as_perror.
	* output-file.c (output_file_create, output_file_close): Likewise.
	* symbols.c (symbol_create, symbol_clone): Likewise.
	* write.c (write_contents): Likewise.
	* config/obj-som.c (obj_som_version, obj_som_copyright): Likewise.
	* config/tc-tic54x.c (tic54x_mlib): Likewise.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
d10 1
a10 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.26
log
@remove some duplicate #include's.
@
text
@d2515 2
a2516 2
      as_bad (_("Can't open macro library file '%s' for reading."), path);
      as_perror ("%s", path);
@


1.25
log
@Fixes for building on 64-bit hosts:
        * config/tc-avr.c (mod_index): New union to allow conversion
        between pointers and integers.
        (md_begin, avr_ldi_expression): Use it.
        * config/tc-i370.c (md_assemble): Add cast for argument to print
        statement.
        * config/tc-tic54x.c (subsym_substitute): Likewise.
        * config/tc-mn10200.c (md_assemble): Use a union to convert the
        opindex field of fr_cgen structure into a pointer so that it can
        be stored in a frag.
        * config/tc-mn10300.c (md_assemble): Likewise.
        * config/tc-frv.c (frv_debug_tomcat): Use %p to print pointer
        types.
        * config/tc-v850.c: Replace uses of (int) casts with correct
        types.
        * gas/tic54x/address.d: Work with 64bit hosts.
        * gas/tic54x/addrfar.d: Likewise.
        * gas/tic54x/align.d: Likewise.
        * gas/tic54x/all-opcodes.d: Likewise.
        * gas/tic54x/asg.d: Likewise.
        * gas/tic54x/cons.d: Likewise.
        * gas/tic54x/consfar.d: Likewise.
        * gas/tic54x/extaddr.d: Likewise.
        * gas/tic54x/field.d: Likewise.
        * gas/tic54x/labels.d: Likewise.
        * gas/tic54x/loop.d: Likewise.
        * gas/tic54x/lp.d: Likewise.
        * gas/tic54x/macro.d: Likewise.
        * gas/tic54x/math.d: Likewise.
        * gas/tic54x/opcodes.d: Likewise.
        * gas/tic54x/sections.d: Likewise.
       * gas/tic54x/set.d: Likewise.
       * gas/tic54x/struct.d: Likewise.
       * gas/tic54x/subsym.d: Likewise.
@
text
@a47 1
#include <stdlib.h>
a48 1
#include <errno.h>
@


1.24
log
@	* README-vms: Delete.
	* config-gas.com: Delete.
	* makefile.vms: Delete.
	* vmsconf.sh: Delete.
	* config/atof-tahoe.c: Delete.
	* config/m88k-opcode.h: Delete.
	* config/obj-bout.c: Delete.
	* config/obj-bout.h: Delete.
	* config/obj-hp300.c: Delete.
	* config/obj-hp300.h: Delete.
	* config/tc-a29k.c: Delete.
	* config/tc-a29k.h: Delete.
	* config/tc-h8500.c: Delete.
	* config/tc-h8500.h: Delete.
	* config/tc-m88k.c: Delete.
	* config/tc-m88k.h: Delete.
	* config/tc-tahoe.c: Delete.
	* config/tc-tahoe.h: Delete.
	* config/tc-tic80.c: Delete.
	* config/tc-tic80.h: Delete.
	* config/tc-w65.c: Delete.
	* config/tc-w65.h: Delete.
	* config/te-aux.h: Delete.
	* config/te-delt88.h: Delete.
	* config/te-delta.h: Delete.
	* config/te-dpx2.h: Delete.
	* config/te-hp300.h: Delete.
	* config/te-ic960.h: Delete.
	* config/vms-a-conf.h: Delete.
	* doc/c-a29k.texi: Delete.
	* doc/c-h8500.texi: Delete.
	* doc/c-m88k.texi: Delete.
	* README: Remove obsolete examples, and list of supported targets.
	* Makefile.am: Remove a29k, h8500, m88k, tahoe, tic80, w65,
	bout and hp300 support.
	(DEP_FLAGS): Don't define BFD_ASSEMBLER.
	* configure.in: Remove --enable-bfd-assembler, need_bfd,
	primary_bfd_gas.
	* configure.tgt: Remove a29k, h8300-coff, h8500-*, i960 non-elf,
	m68k non bfd, m88k, or32-coff, tic80-*, vax non-bfd, w65k-*, *-nindy.
	* as.c: Remove all non-BFD_ASSEMBLER code, support for above targets.
	* as.h: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
	* input-file.c: Likewise.
	* listing.c: Likewise.
	* literal.c: Likewise.
	* messages.c: Likewise.
	* obj.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* stabs.c: Likewise.
	* struc-symbol.h: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* symbols.c: Likewise.
	* symbols.h: Likewise.
	* tc.h: Likewise.
	* write.c: Likewise.
	* write.h: Likewise.
	* config/aout_gnu.h: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-aout.h: Likewise.
	* config/obj-coff.c: Likewise.
	* config/obj-coff.h: Likewise.
	* config/obj-evax.h: Likewise.
	* config/obj-ieee.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-crx.h: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-d30v.h: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-fr30.h: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-hppa.h: Likewise.
	* config/tc-i370.h: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i860.h: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ip2k.h: Likewise.
	* config/tc-iq2000.h: Likewise.
	* config/tc-m32c.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m68k.h: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-maxq.h: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mn10200.h: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-mn10300.h: Likewise.
	* config/tc-ms1.h: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-msp430.h: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-ns32k.h: Likewise.
	* config/tc-openrisc.h: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.h: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic4x.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-vax.h: Likewise.
	* config/tc-xstormy16.h: Likewise.
	* config/tc-xtensa.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-z8k.h: Likewise.
	* config/vms-a-conf.h
	* doc/Makefile.am: Likewise.
	* doc/all.texi: Likewise.
	* doc/as.texinfo: Likewise.
	* doc/Makefile.in: Regenerate.
	* Makefile.in: Regenerate.
	* configure: Regenerate.
	* config.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005
d4988 1
a4988 1
				  strlen (value));
d4998 1
a4998 1
				      strlen (value) - beg);
@


1.23
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@a5551 11
#if defined OBJ_COFF

short
tc_coff_fix2rtype (fixP)
     fixS *fixP;
{
  return (fixP->fx_r_type);
}

#endif /* OBJ_COFF */

@


1.22
log
@Update the address and phone number of the FSF
@
text
@d5484 1
a5484 1
md_apply_fix3 (fixP, valP, seg)
@


1.21
log
@gas/
2005-03-10  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-tic54x.h (tic54x_macro_info): Change parameter type.
	* config/tc-tic54x.c (tic54x_macro_info): Likewise. Replace hand-
	crafted structure declarations with the types from macro.h.
@
text
@d20 2
a21 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.20
log
@update copyright dates
@
text
@d2703 2
a2704 2
tic54x_macro_info (info)
     void *info;
d2706 1
a2706 20
  struct formal_struct
  {
    struct formal_struct *next;	/* Next formal in list  */
    sb name;			/* Name of the formal  */
    sb def;			/* The default value  */
    sb actual;			/* The actual argument (changed on
                                   each expansion) */
    int index;			/* The index of the formal
                                   0 .. formal_count - 1 */
  } *entry;
  struct macro_struct
  {
    sb sub;			/* Substitution text.  */
    int formal_count;		/* Number of formal args.  */
    struct formal_struct *formals;	/* Pointer to list of
                                           formal_structs.  */
    struct hash_control *formal_hash; /* Hash table of formals.  */
  } *macro;

  macro = (struct macro_struct *) info;
@


1.19
log
@bfd/

2005-02-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* coffcode.h (sec_to_styp_flags): Replaced SEC_CLINK with
	SEC_TIC54X_CLINK. Replace SEC_BLOCK with SEC_TIC54X_BLOCK.
	Replace SEC_SHARED with SEC_COFF_SHARED.
	(styp_to_sec_flags): Likewise.

	* elfxx-target.h (TARGET_BIG_SYM): Remove SEC_ARCH_BIT_0.
	(TARGET_LITTLE_SYM): Likewise.

	* section.c (SEC_ARCH_BIT_0): Removed.
	(SEC_LINK_DUPLICATES_SAME_CONTENTS): Defined with
	SEC_LINK_DUPLICATES_ONE_ONLY and SEC_LINK_DUPLICATES_SAME_SIZE.
	(SEC_SHARED): Renamed to ...
	(SEC_COFF_SHARED): This.
	(SEC_BLOCK): Renamed to ...
	(SEC_TIC54X_BLOCK): This.
	(SEC_CLINK): Renamed to ...
	(SEC_TIC54X_CLINK): This.
	(SEC_XXX): Rearranged. Move SEC_COFF_SHARED_LIBRARY,
	SEC_COFF_SHARED, SEC_TIC54X_BLOCK and SEC_TIC54X_CLINK to the
	end.
	* bfd-in2.h: Regenerated.

binutils/

2005-02-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* objcopy.c (parse_flags): Replace SEC_SHARED with
	SEC_COFF_SHARED.

	* objdump.c (dump_section_header): Dump SEC_TIC54X_BLOCK and
	SEC_TIC54X_CLINK for TI c54x only. Remove SEC_ARCH_BIT_0. Dump
	SEC_COFF_SHARED for COFF only.

gas/

2005-02-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-coff.c (obj_coff_section): Replace SEC_SHARED with
	SEC_COFF_SHARED.

	* config/tc-tic54x.c (tic54x_bss): Replace SEC_BLOCK with
	SEC_TIC54X_BLOCK.
	(demand_empty_rest_of_line): Likewise.
	(tic54x_sblock): Likewise.
	(tic54x_clink): Replace with SEC_CLINK with SEC_TIC54X_CLINK.

ld/

2005-02-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldlang.c (lang_add_section): Check SEC_TIC54X_BLOCK for TI
	tic54x input only.
	(lang_size_sections_1): Check SEC_COFF_SHARED_LIBRARY for COFF
	and ECOFF output only.
@
text
@d2 2
a3 1
   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
@


1.18
log
@	* config/atof-ieee.c, config/obj-coff.c, config/obj-elf.c,
	config/obj-ieee.c, config/obj-som.c, config/obj-vms.c,
	config/tc-a29k.c, config/tc-alpha.c, config/tc-arc.c,
	config/tc-arm.c, config/tc-d30v.c, config/tc-dlx.c,
	config/tc-fr30.c, config/tc-h8300.c, config/tc-h8500.c,
	config/tc-i370.c, config/tc-i386.c, config/tc-i960.c,
	config/tc-ia64.c, config/tc-m32r.c, config/tc-m32r.h,
	config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-mips.c,
	config/tc-mn10200.c, config/tc-msp430.c, config/tc-ns32k.c,
	config/tc-openrisc.c, config/tc-or32.c, config/tc-pdp11.c,
	config/tc-pj.c, config/tc-sparc.h, config/tc-tic54x.c,
	config/tc-tic80.c, config/tc-v850.c, config/tc-w65.c,
	config/tc-xtensa.c, config/tc-z8k.c, config/xtensa-relax.c: Remove
	#if 0'd code throughout.
@
text
@d664 1
a664 1
    bss_section->flags |= SEC_BLOCK;
d1577 1
a1577 1
    flags |= SEC_BLOCK;
d2017 1
a2017 1
  seg->flags |= SEC_CLINK;
d2328 1
a2328 1
      seg->flags |= SEC_BLOCK;
@


1.17
log
@(tic54x_adjust_symtab): Adjust call to c_dot_file_symbol.
@
text
@a155 3
#if 0
  { "mcoff-version",   required_argument,   NULL, OPTION_COFF_VERSION },
#endif
a348 3
#if 0
  fprintf (stream, _("-mcoff-version={0|1|2}    Select COFF version\n"));
#endif
a2579 3
#if 0
  { "end"      , s_end                    ,          0 },
#endif
a2604 4
#if 0
  { "list"     , listing_list             ,          1 },
  { "nolist"   , listing_list             ,          0 },
#endif
a2617 3
#if 0
  { "page"     , listing_eject            ,          0 },
#endif
a2632 3
#if 0
  { "title"    , listing_title            ,          0 },
#endif
a2640 15
#if 0
/* For debugging, strings for each operand type.  */
static const char *optypes[] =
{
  "none", "Xmem", "Ymem", "pmad", "dmad", "Smem", "Lmem", "MMR", "PA",
  "Sind", "xpmad", "xpmad+", "MMRX", "MMRY",
  "SRC1", "SRC", "RND", "DST",
  "ARX",
  "SHIFT", "SHFT",
  "B", "A", "lk", "TS", "k8", "16", "BITC", "CC", "CC2", "CC3", "123", "031",
  "k5", "k8u", "ASM", "T", "DP", "ARP", "k3", "lku", "N", "SBIT", "12",
  "k9", "TRN",
};
#endif

a5048 18
#if 0
		  /* Try to replace required whitespace
		     eliminated by the preprocessor; technically, a forced
		     substitution could come anywhere, even mid-symbol,
		     e.g. if x is "0", 'sym:x:end' should result in 'sym0end',
		     but 'sym:x: end' should result in 'sym0 end'.
		     FIXME -- this should really be fixed in the preprocessor,
		     but would require several new states;
		     KEEP_WHITE_AROUND_COLON does part of the job, but isn't
		     complete.  */
		  if ((is_part_of_name (tail[1])
		       && tail[1] != '.'
		       && tail[1] != '$')
		      || tail[1] == '\0' || tail[1] == ',' || tail[1] == '"')
		    ++tail;
		  else
		    *tail = ' ';
#endif
a5352 5
#if 0
  static int local_label_count = 0;
  const char *name = S_GET_NAME (sym);
#endif

a5401 11
#if 0
  symbol *sym = (symbol *) hash_find (mmreg_hash, name);

  /* If it's a MMREG, replace it with its constant value.  */
  if (sym)
    {
      exp->X_op = O_constant;
      exp->X_add_number = sym->value;
      return 1;
    }
#endif
@


1.16
log
@	* config/atof-tahoe.c: Fix comment typos.
	* config/m68k-parse.y: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-bout.c: Likewise.
	* config/obj-vms.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/te-delt88.h: Likewise.
	* config/te-delta.h: Likewise.
	* config/te-generic.h: Likewise.
	* config/te-macos.h: Likewise.
	* config/te-ppcnw.h: Likewise.
	* config/te-psos.h: Likewise.
	* config/te-sun3.h: Likewise.
	* config/te-tmips.h: Likewise.
	* config/xtensa-relax.c: Likewise.
@
text
@d5382 1
a5382 1
      c_dot_file_symbol (filename);
@


1.15
log
@	* doc/as.texinfo (Invoking): Typo fix.
	* config/tc-tic54x.c (encode_operand): Comment typo fix.
@
text
@d1195 1
a1195 1
		 the addresing mode (I actually think that ".c_mode" is
d1489 1
a1489 1
   Unitialized section.
d2804 1
a2804 1
/* Return the index of the first occurence of B in A, or zero if none
d2961 1
a2961 1
/* Return the structrure size, given the stag.  */
d4732 1
a4732 1
   Start with the innermost macro substituion table given and work
d5028 1
a5028 1
			 kinda indicates that forced substituion is not
@


1.14
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d4147 1
a4147 1
      /* Make sure this agrees with with the OP_DST operand.  */
@


1.13
log
@	* config/obj-coff.h: Fix formatting.
	* config/tc-mcore.c: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-openrisc.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-xstormy16.c: Likewise.
	* config/tc-xstormy16.h: Likewise.
@
text
@d4357 1
a4357 1
		     false, insn->opcode[i].r_type);
@


1.13.2.1
log
@	* doc/as.texinfo (Invoking): Typo fix.
	* config/tc-tic54x.c (encode_operand): Comment typo fix.
@
text
@d4147 1
a4147 1
      /* Make sure this agrees with the OP_DST operand.  */
@


1.12
log
@Add missing protoypes.
Remove ANSI style function declarations
@
text
@d1715 1
a1715 1
   Code copied from stringer, and slightly modified so that strings are packed 
d3328 1
a3328 1
  for (tm = (template *) tic54x_paroptab; tm->name; tm++) 
@


1.11
log
@Add a more instructive error message on bad syntax
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001 Free Software Foundation, Inc.
d45 1
a45 2
   Some of the default behavior changed from COFF1 to COFF2.
*/
d60 21
d83 3
a85 3
const char comment_chars[] = ";";
const char line_comment_chars[] = ";*#"; /* At column zero only.  */
const char line_separator_chars[] = ""; /* Not permitted.  */
d87 2
a88 2
/* Characters which indicate that this is a floating point constant.  */
const char FLT_CHARS[] = "fF";
d90 7
a96 3
/* Characters that can be used to separate mantissa from exp in FP
   nums.  */
const char EXP_CHARS[] = "eE";
d98 2
a99 10
/* Only word (et al.), align, or conditionals are allowed within
   .struct/.union.  */
#define ILLEGAL_WITHIN_STRUCT()					\
  do								\
    if (current_stag != NULL)					\
      { 							\
	as_bad (_("pseudo-op illegal within .struct/.union"));	\
	return;							\
      }								\
  while (0)
d101 14
a114 15
void
md_show_usage (stream)
     FILE *stream;
{
  fprintf (stream, _("C54x-specific command line  options:\n"));
  fprintf (stream, _("-mfar-mode | -mf          Use extended addressing\n"));
  fprintf (stream, _("-mcpu=<CPU version>       Specify the CPU version\n"));
#if 0
  fprintf (stream, _("-mcoff-version={0|1|2}    Select COFF version\n"));
#endif
  fprintf (stream, _("-merrors-to-file <filename>\n"));
  fprintf (stream, _("-me <filename>            Redirect errors to a file\n"));
}

const char *md_shortopts = "";
d128 18
d153 3
a155 3
  { "mfar-mode",       no_argument,	 NULL, OPTION_ADDRESS_MODE },
  { "mf",	      no_argument,	 NULL, OPTION_ADDRESS_MODE },
  { "mcpu",	    required_argument,   NULL, OPTION_CPU_VERSION },
d160 2
a161 2
  { "me",	      required_argument,   NULL, OPTION_STDERR_TO_FILE },
  { NULL, no_argument, NULL, 0},
d218 125
a342 30
static char *subsym_substitute PARAMS ((char *line, int forced));
static char *subsym_lookup PARAMS ((char *name, int nest_level));
static void subsym_create_or_replace PARAMS ((char *name, char *value));
static float math_ceil PARAMS ((float, float));
static float math_cvi PARAMS ((float, float));
static float math_floor PARAMS ((float, float));
static float math_fmod PARAMS ((float, float));
static float math_int PARAMS ((float, float));
static float math_round PARAMS ((float, float));
static float math_sgn PARAMS ((float, float));
static float math_trunc PARAMS ((float, float));
static float math_acos PARAMS ((float, float));
static float math_asin PARAMS ((float, float));
static float math_atan PARAMS ((float, float));
static float math_atan2 PARAMS ((float, float));
static float math_cosh PARAMS ((float, float));
static float math_cos PARAMS ((float, float));
static float math_cvf PARAMS ((float, float));
static float math_exp PARAMS ((float, float));
static float math_fabs PARAMS ((float, float));
static float math_ldexp PARAMS ((float, float));
static float math_log10 PARAMS ((float, float));
static float math_log PARAMS ((float, float));
static float math_max PARAMS ((float, float));
static float math_pow PARAMS ((float, float));
static float math_sin PARAMS ((float, float));
static float math_sinh PARAMS ((float, float));
static float math_sqrt PARAMS ((float, float));
static float math_tan PARAMS ((float, float));
static float math_tanh PARAMS ((float, float));
d344 4
a347 1
static struct stag
d349 9
a357 20
  symbolS *sym;		     /* Symbol for this stag; value is offset.  */
  const char *name;		 /* Shortcut to symbol name.  */
  bfd_vma size;		     /* Size of struct/union.  */
  int current_bitfield_offset;      /* Temporary for tracking fields.  */
  int is_union;
  struct stag_field		 /* List of fields.  */
  {
    const char *name;
    bfd_vma offset;		 /* Of start of this field.  */
    int bitfield_offset;	    /* Of start of this field.  */
    struct stag *stag;	      /* If field is struct/union.  */
    struct stag_field *next;
  } *field;
  /* For nesting; used only in stag construction.  */
  struct stag *inner;	       /* Enclosed .struct.  */
  struct stag *outer;	       /* Enclosing .struct.  */
} *current_stag = NULL;

static segT stag_saved_seg;
static subsegT stag_saved_subseg;
d362 2
a363 1
tic54x_emit_char (char c)
d375 3
a377 1
frag_prev (fragS *frag, segT seg)
d390 3
a392 1
bit_offset_frag (fragS *frag, segT seg)
d410 3
a412 1
frag_bit_offset (fragS *frag, segT seg)
d426 3
a428 1
parse_expression (char *str, expressionS * exp)
d448 2
a449 1
tic54x_asg (int x ATTRIBUTE_UNUSED)
d510 2
a511 1
tic54x_eval (int x ATTRIBUTE_UNUSED)
d587 2
a588 1
tic54x_bss (int x ATTRIBUTE_UNUSED)
d677 6
a682 5
stag_add_field_symbols (struct stag *stag, 
                        const char *path, 
                        bfd_vma base_offset, 
                        symbolS *rootsym, 
                        const char *root_stag_name)
d735 5
a739 4
stag_add_field (struct stag *parent, 
                const char *name, 
                bfd_vma offset, 
                struct stag *stag)
d771 2
a772 1
tic54x_struct (int arg)
d852 2
a853 1
tic54x_endstruct (int is_union)
d918 2
a919 1
tic54x_tag (int ignore ATTRIBUTE_UNUSED)
d952 1
d978 2
a979 1
tic54x_struct_field (int type)
d1037 1
a1037 3
	    {
	      new_bitfield_offset = count;
	    }
d1065 1
d1074 1
a1096 1
int emitting_long = 0;
d1098 2
a1099 1
tic54x_cons (int type)
d1101 1
a1101 1
  register unsigned int c;
d1237 2
a1238 1
tic54x_global (int type)
d1272 3
a1274 2
tic54x_remove_local_label (const char *key, 
                           PTR value ATTRIBUTE_UNUSED)
d1283 2
a1284 1
tic54x_clear_local_labels (int ignored ATTRIBUTE_UNUSED)
d1303 2
a1304 1
tic54x_sect (int arg)
d1319 1
d1338 1
a1338 1
         encounter instructions, we'll flag it with SEC_CODE as well. */
d1365 2
a1366 1
tic54x_space (int arg)
d1413 1
d1497 2
a1498 1
tic54x_usect (int x ATTRIBUTE_UNUSED)
d1594 2
a1595 1
lookup_version (const char *ver)
d1616 2
a1617 1
set_cpu (enum cpu_version version)
d1644 2
a1645 1
tic54x_version (int x ATTRIBUTE_UNUSED)
d1688 2
a1689 1
tic54x_float_cons (int type)
d1719 2
a1720 1
tic54x_stringer (int type)
d1722 1
a1722 1
  register unsigned int c;
d1807 2
a1808 1
tic54x_p2align (int arg ATTRIBUTE_UNUSED)
d1814 2
a1815 1
tic54x_align_words (int arg)
d1847 2
a1848 1
tic54x_field (int ignore ATTRIBUTE_UNUSED)
d1894 1
d1911 1
d1919 1
d1971 2
a1972 1
tic54x_initialized_section (segT seg)
d1985 2
a1986 1
tic54x_clink (int ignored ATTRIBUTE_UNUSED)
d1996 1
d2033 2
a2034 1
tic54x_set_default_include (int dot)
d2051 1
d2079 2
a2080 1
tic54x_include (int ignored ATTRIBUTE_UNUSED)
d2123 2
a2124 1
tic54x_message (int type)
d2170 2
a2171 1
tic54x_label (int ignored ATTRIBUTE_UNUSED)
d2192 2
a2193 1
tic54x_mmregs (int ignored ATTRIBUTE_UNUSED)
d2212 2
a2213 1
tic54x_loop (int count)
d2227 2
a2228 1
tic54x_endloop (int ignore ATTRIBUTE_UNUSED)
d2237 2
a2238 1
tic54x_break (int ignore ATTRIBUTE_UNUSED)
d2253 2
a2254 1
set_address_mode (int mode)
d2267 1
d2269 2
a2270 1
tic54x_address_mode (int mode)
d2293 2
a2294 1
tic54x_sblock (int ignore ATTRIBUTE_UNUSED)
d2308 1
d2314 1
d2351 2
a2352 1
tic54x_set (int ignore ATTRIBUTE_UNUSED)
d2386 2
a2387 1
tic54x_fclist (int show)
d2397 2
a2398 1
tic54x_sslist (int show)
d2409 2
a2410 1
tic54x_var (int ignore ATTRIBUTE_UNUSED)
d2458 2
a2459 1
tic54x_mlib (int ignore ATTRIBUTE_UNUSED)
d2492 1
d2496 1
d2506 1
d2687 1
d2709 1
d2767 1
d2787 3
a2789 1
subsym_symlen (char *a, char *ignore ATTRIBUTE_UNUSED)
d2797 3
a2799 1
subsym_symcmp (char *a, char *b)
d2808 3
a2810 1
subsym_firstch (char *a, char *b)
d2821 3
a2823 1
subsym_lastch (char *a, char *b)
d2835 3
a2837 1
subsym_isdefed (char *a, char *ignore ATTRIBUTE_UNUSED)
d2849 3
a2851 1
subsym_ismember (char *sym, char *list)
d2889 3
a2891 1
subsym_iscons (char *a, char *ignore ATTRIBUTE_UNUSED)
d2930 3
a2932 1
subsym_isname (char *a, char *ignore ATTRIBUTE_UNUSED)
d2950 3
a2952 1
subsym_isreg (char *a, char *ignore ATTRIBUTE_UNUSED)
d2964 3
a2966 1
subsym_structsz (char *name, char *ignore ATTRIBUTE_UNUSED)
d2969 1
d2984 3
a2986 2
subsym_structacc (char *stag_name ATTRIBUTE_UNUSED, 
                  char *ignore ATTRIBUTE_UNUSED)
d3016 3
a3018 1
math_fmod (float arg1, float arg2)
d3080 3
a3082 1
math_atan2 (float arg1, float arg2)
d3130 3
a3132 1
math_ldexp (float arg1, float arg2)
d3154 3
a3156 1
math_max (float arg1, float arg2)
d3162 3
a3164 1
math_min (float arg1, float arg2)
d3170 3
a3172 1
math_pow (float arg1, float arg2)
d3221 1
a3221 1
  int (*proc) (char *, char *);
d3245 1
a3245 1
  float (*proc) (float, float);
d3300 1
a3300 1
  /* Look for A_DIR and add it to the include list. a  */
d3304 1
d3308 1
d3351 2
a3352 3
    {
      hash_err = hash_insert (mmreg_hash, sym->name, (char *) sym);
    }
d3355 2
a3356 3
    {
      hash_err = hash_insert (cc_hash, sym->name, (char *) sym);
    }
d3359 2
a3360 3
    {
      hash_err = hash_insert (cc2_hash, sym->name, (char *) sym);
    }
d3363 2
a3364 3
    {
      hash_err = hash_insert (cc3_hash, sym->name, (char *) sym);
    }
d3367 2
a3368 3
    {
      hash_err = hash_insert (sbit_hash, sym->name, (char *) sym);
    }
d3371 2
a3372 3
    {
      hash_err = hash_insert (misc_symbol_hash, *symname, *symname);
    }
d3378 3
a3380 4
    {
      hash_err = hash_insert (subsym_hash[0], subsym_proc->name,
			      (char *) subsym_proc);
    }
a3394 40
typedef struct _tic54x_insn
{
  const template *tm;	       /* Opcode template.  */

  char mnemonic[MAX_LINE];	  /* Opcode name/mnemonic.  */
  char parmnemonic[MAX_LINE];       /* 2nd mnemonic of parallel insn.  */

  int opcount;
  struct opstruct
  {
    char buf[MAX_LINE];
    enum optype type;
    expressionS exp;
  } operands[MAX_OPERANDS];

  int paropcount;
  struct opstruct paroperands[MAX_OPERANDS];

  int is_lkaddr;
  int lkoperand;
  int words;			/* Size of insn in 16-bit words.  */
  int using_default_dst;	    /* Do we need to explicitly set an
				       omitted OP_DST operand?  */
  struct
  {
    unsigned short word;	    /* Final encoded opcode data.  */
    int unresolved;
    int r_nchars;		     /* Relocation size.  */
    bfd_reloc_code_real_type r_type; /* Relocation type.  */
    expressionS addr_expr;	  /* Storage for unresolved expressions.  */
  } opcode[3];
} tic54x_insn;

static int encode_operand (tic54x_insn *, enum optype, struct opstruct *);
static int encode_dmad (tic54x_insn *, struct opstruct *, int);
static int operands_match (tic54x_insn *, struct opstruct *, int,
			   const enum optype *, int, int);
static int encode_address (tic54x_insn *, struct opstruct *);
static int is_accumulator (struct opstruct *);

d3396 2
a3397 1
is_accumulator (struct opstruct *operand)
d3408 3
a3410 1
get_operands (struct opstruct operands[], char *line)
d3421 1
d3447 1
d3503 1
d3514 1
d3539 2
a3540 1
is_immediate (struct opstruct *operand)
d3549 2
a3550 1
is_absolute (struct opstruct *operand)
d3558 2
a3559 1
is_indirect (struct opstruct *operand)
d3567 2
a3568 1
is_dual (struct opstruct *operand)
d3588 2
a3589 1
is_mmreg (struct opstruct *operand)
d3597 3
a3599 1
is_type (struct opstruct *operand, enum optype type)
d3708 2
a3709 1
     int minops, maxops;
d3714 1
a3714 3
    {
      return 1;
    }
d3791 1
d3847 2
a3848 3
      if (operand->exp.X_op == O_register) {
        as_bad(_("Use the .mmregs directive to use memory-mapped register names such as '%s'"), operand->buf);
      }
d3859 3
a3861 1
encode_indirect (tic54x_insn *insn, struct opstruct *operand)
d3933 7
a3939 3
encode_integer (tic54x_insn *insn, 
                struct opstruct *operand, 
                int which, int min, int max, unsigned short mask)
d3994 3
a3996 1
encode_condition (tic54x_insn *insn, struct opstruct *operand)
d4042 3
a4044 3
      else if (((insn->opcode[0].word & CATG_A2) && (cc->value & CATG_A2)) ||
	       ((insn->opcode[0].word & CATG_B2) && (cc->value & CATG_B2)) ||
	       ((insn->opcode[0].word & CATG_C2) && (cc->value & CATG_C2)))
d4056 3
a4058 1
encode_cc3 (tic54x_insn *insn, struct opstruct *operand)
d4073 3
a4075 1
encode_arx (tic54x_insn *insn, struct opstruct *operand)
d4078 1
d4089 3
a4091 1
encode_cc2 (tic54x_insn *insn, struct opstruct *operand)
d4094 1
d4331 2
a4332 1
emit_insn (tic54x_insn *insn)
d4365 2
a4366 1
build_insn (tic54x_insn *insn)
d4397 1
d4405 1
d4416 2
a4417 1
optimize_insn (tic54x_insn *insn)
d4492 1
a4492 1
      if (((OPTYPE (insn->tm->operand_types[0]) == OP_Smem
d4495 1
a4495 1
	       && OPTYPE (insn->tm->operand_types[1]) == OP_SHFT))
d4510 3
a4512 1
tic54x_parse_insn (tic54x_insn *insn, char *line)
d4559 2
a4560 1
next_line_shows_parallel (char *next_line)
d4571 3
a4573 1
tic54x_parse_parallel_insn_firstline (tic54x_insn *insn, char *line)
d4604 3
a4606 1
tic54x_parse_parallel_insn_lastline (tic54x_insn *insn, char *line)
d4617 1
d4624 1
a4624 3
	    {
	      return 1;
	    }
d4644 5
a4648 1
subsym_get_arg (char *line, char *terminators, char **str, int nosub)
d4668 1
d4756 3
a4758 1
subsym_substitute (char *line, int forced)
d4786 1
a4786 3
    {
      line_conditional = 1;
    }
d4887 1
d4953 1
d5534 5
a5538 1
tic54x_cons_fix_new (fragS *frag, int where, int octets, expressionS *exp)
d5541 1
d5717 1
d5734 1
d5821 1
@


1.10
log
@Update all uses of md_apply_fix to use md_apply_fix3.  Make it a void function.
@
text
@d3657 3
@


1.9
log
@Fix tic54x testsuite failures and Lmem disassembly bugs.
@
text
@d5338 2
a5339 2
int
md_apply_fix (fixP, valP)
d5341 2
a5342 1
     valueT *valP;
d5345 1
a5345 1
  valueT val = *valP;
d5351 1
a5351 1
      return 0;
d5385 2
a5386 1
  return 0; /* Return value is ignored.  */
@


1.8
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d42 5
a46 1
   TI sets labels to be data type 4 (T_INT); GAS uses T_NULL.  */
d242 1
a242 2
tic54x_emit_char (c)
     char c;
d254 1
a254 3
frag_prev (frag, seg)
     fragS *frag;
     segT seg;
d267 1
a267 3
bit_offset_frag (frag, seg)
     fragS *frag;
     segT seg;
d285 1
a285 3
frag_bit_offset (frag, seg)
     fragS *frag;
     segT seg;
d319 1
a319 2
tic54x_asg (x)
     int x ATTRIBUTE_UNUSED;
d380 1
a380 2
tic54x_eval (x)
     int x ATTRIBUTE_UNUSED;
d456 1
a456 2
tic54x_bss (x)
     int x ATTRIBUTE_UNUSED;
d519 1
a519 1
		(offsetT) (words << 1), (char *) 0);
d545 5
a549 6
stag_add_field_symbols (stag, path, base_offset, rootsym, root_stag_name)
     struct stag *stag;
     const char *path;
     bfd_vma base_offset;
     symbolS *rootsym;
     const char *root_stag_name;
d602 4
a605 5
stag_add_field (parent, name, offset, stag)
     struct stag *parent;
     const char *name;
     bfd_vma offset;
     struct stag *stag;
d782 1
a782 2
tic54x_tag (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1098 1
a1098 2
tic54x_global (type)
     int type;
d1132 2
a1133 3
tic54x_remove_local_label (key, value)
     const char *key;
     PTR value ATTRIBUTE_UNUSED;
d1142 1
a1142 2
tic54x_clear_local_labels (ignored)
     int ignored ATTRIBUTE_UNUSED;
d1156 3
a1158 1
   For compatibility, '*' sections have SEC_DATA set instead of SEC_CODE.  */
d1188 1
d1193 2
a1194 1
      /* Make sure all named initialized sections are SEC_DATA.  */
d1351 1
a1351 2
tic54x_usect (x)
     int x ATTRIBUTE_UNUSED;
d1447 1
a1447 2
lookup_version (ver)
     const char *ver;
d1468 1
a1468 2
set_cpu (version)
     enum cpu_version version;
d1495 1
a1495 2
tic54x_version (x)
     int x ATTRIBUTE_UNUSED;
d1564 1
a1564 1
   Code copied from read.c, and slightly modified so that strings are packed
d1568 1
a1568 2
tic54x_stringer (type)
     int type;
d1655 1
a1655 2
tic54x_p2align (arg)
     int arg ATTRIBUTE_UNUSED;
d1661 1
a1661 2
tic54x_align_words (arg)
     int arg;
d1693 1
a1693 2
tic54x_field (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1813 1
a1813 2
tic54x_initialized_section (seg)
     segT seg;
d1826 1
a1826 2
tic54x_clink (ignored)
     int ignored ATTRIBUTE_UNUSED;
d1872 1
a1872 2
tic54x_set_default_include (dot)
     int dot;
d1916 1
a1916 2
tic54x_include (ignored)
     int ignored ATTRIBUTE_UNUSED;
d1959 1
a1959 2
tic54x_message (type)
     int type;
d2005 1
a2005 2
tic54x_label (ignored)
     int ignored ATTRIBUTE_UNUSED;
d2026 1
a2026 2
tic54x_mmregs (ignored)
     int ignored ATTRIBUTE_UNUSED;
d2059 1
a2059 2
tic54x_endloop (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2068 1
a2068 2
tic54x_break (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2083 1
a2083 2
set_address_mode (mode)
     int mode;
d2097 1
a2097 2
tic54x_address_mode (mode)
     int mode;
d2120 1
a2120 2
tic54x_sblock (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2175 1
a2175 2
tic54x_set (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2230 1
a2230 2
tic54x_var (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2278 1
a2278 2
tic54x_mlib (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2380 2
d2600 1
a2600 3
subsym_symlen (a, ignore)
     char *a;
     char *ignore ATTRIBUTE_UNUSED;
d2608 1
a2608 3
subsym_symcmp (a, b)
     char *a;
     char *b;
d2617 1
a2617 3
subsym_firstch (a, b)
     char *a;
     char *b;
d2628 1
a2628 3
subsym_lastch (a, b)
     char *a;
     char *b;
d2640 1
a2640 3
subsym_isdefed (a, ignore)
     char *a;
     char *ignore ATTRIBUTE_UNUSED;
d2652 1
a2652 3
subsym_ismember (sym, list)
     char *sym;
     char *list;
d2690 1
a2690 3
subsym_iscons (a, ignore)
     char *a;
     char *ignore ATTRIBUTE_UNUSED;
d2729 1
a2729 3
subsym_isname (a, ignore)
     char *a;
     char *ignore ATTRIBUTE_UNUSED;
d2747 1
a2747 3
subsym_isreg (a, ignore)
     char *a;
     char *ignore ATTRIBUTE_UNUSED;
d2759 1
a2759 3
subsym_structsz (name, ignore)
     char *name;
     char *ignore ATTRIBUTE_UNUSED;
d2776 2
a2777 3
subsym_structacc (stag_name, ignore)
     char *stag_name ATTRIBUTE_UNUSED;
     char *ignore ATTRIBUTE_UNUSED;
d3068 1
a3068 2
  template *opcode;
  partemplate *paropcode;
d3095 1
a3095 1
  for (opcode = (template *) tic54x_optab; opcode->name; opcode++)
d3097 1
a3097 1
      if (hash_find (op_hash, opcode->name))
d3099 1
a3099 1
      hash_err = hash_insert (op_hash, opcode->name, (char *) opcode);
d3102 1
a3102 1
		  opcode->name, hash_err);
d3105 1
a3105 3
  for (paropcode = (partemplate *) tic54x_paroptab;
       paropcode->name;
       paropcode++)
d3107 1
a3107 1
      if (hash_find (parop_hash, paropcode->name))
d3109 1
a3109 1
      hash_err = hash_insert (parop_hash, paropcode->name, (char *) paropcode);
d3112 1
a3112 1
		  paropcode->name, hash_err);
a3181 1
  const partemplate *ptm;	   /* Parallel opcode template.  */
d3217 1
d3220 1
a3220 2
is_accumulator (operand)
     struct opstruct *operand;
d3231 1
a3231 3
get_operands (operands, line)
     struct opstruct operands[];
     char *line;
d3356 1
a3356 2
is_immediate (operand)
     struct opstruct *operand;
d3365 1
a3365 2
is_absolute (operand)
     struct opstruct *operand;
d3373 1
a3373 2
is_indirect (operand)
     struct opstruct *operand;
d3381 1
a3381 2
is_dual (operand)
     struct opstruct *operand;
d3401 1
a3401 2
is_mmreg (operand)
     struct opstruct *operand;
d3409 1
a3409 3
is_type (operand, type)
     struct opstruct *operand;
     enum optype type;
d3667 1
a3667 3
encode_indirect (insn, operand)
     tic54x_insn *insn;
     struct opstruct *operand;
d3739 3
a3741 5
encode_integer (insn, operand, which, min, max, mask)
     tic54x_insn *insn;
     struct opstruct *operand;
     int which, min, max;
     unsigned short mask;
d3796 1
a3796 3
encode_condition (insn, operand)
     tic54x_insn *insn;
     struct opstruct *operand;
d3856 1
a3856 3
encode_cc3 (insn, operand)
     tic54x_insn *insn;
     struct opstruct *operand;
d3871 1
a3871 3
encode_arx (insn, operand)
     tic54x_insn *insn;
     struct opstruct *operand;
d3884 1
a3884 3
encode_cc2 (insn, operand)
     tic54x_insn *insn;
     struct opstruct *operand;
d3902 1
a3902 1
  int ext = insn->tm && ((insn->tm->flags & FL_EXT) != 0);
d4123 1
a4123 2
emit_insn (insn)
     tic54x_insn *insn;
d4126 7
d4156 1
a4156 2
build_insn (insn)
     tic54x_insn *insn;
d4161 1
a4161 1
  if (insn->tm)
d4178 1
a4178 2
  insn->words =
    (insn->tm ? insn->tm->words : insn->ptm->words) + insn->is_lkaddr;
d4180 2
a4181 2
  insn->opcode[0].word = insn->tm ? insn->tm->opcode : insn->ptm->opcode;
  if (insn->tm && (insn->tm->flags & FL_EXT))
d4190 1
a4190 1
  if (insn->ptm)
d4204 1
a4204 2
optimize_insn (insn)
     tic54x_insn *insn;
d4297 1
a4297 3
tic54x_parse_insn (insn, line)
     tic54x_insn *insn;
     char *line;
d4344 1
a4344 2
next_line_shows_parallel (next_line)
     char *next_line;
d4355 1
a4355 3
tic54x_parse_parallel_insn_firstline (insn, line)
     tic54x_insn *insn;
     char *line;
d4357 2
a4358 2
  insn->ptm = (partemplate *) hash_find (parop_hash, insn->mnemonic);
  if (!insn->ptm)
d4365 2
a4366 2
  while (insn->ptm->name && strcasecmp (insn->ptm->name,
					insn->mnemonic) == 0)
d4373 1
a4373 1
			     insn->ptm->operand_types, 2, 2))
d4377 1
a4377 1
      ++(insn->ptm);
d4386 1
a4386 3
tic54x_parse_parallel_insn_lastline (insn, line)
     tic54x_insn *insn;
     char *line;
d4391 1
a4391 1
  while (insn->ptm->name && strcasecmp (insn->ptm->name,
d4394 1
a4394 1
      if (strcasecmp (insn->ptm->parname, insn->parmnemonic) == 0)
d4397 2
a4398 2
	  if (insn->paropcount >= insn->ptm->minops
	      && insn->paropcount <= insn->ptm->maxops
d4401 2
a4402 2
				 insn->ptm->paroperand_types,
				 insn->ptm->minops, insn->ptm->maxops))
d4407 1
a4407 1
      ++(insn->ptm);
@


1.7
log
@	* dwarf2dbg.c (dwarf2_directive_file): Avoid signed/unsigned warning.

	* write.c (set_symtab): Update bfd_alloc declaration.  Use a temp
	var to ensure bfd_alloc arg is the right type.
	(write_object_file): Cast args of bfd_seek.  Replace bfd_write with
	bfd_bwrite.

	* config/obj-coff.c: Replace calls to bfd_write with calls to
	bfd_bwrite.  Cast args of bfd_seek.

	* config/obj-elf.c (obj_elf_change_section): Avoid signed/unsigned
	warning.

	* config/tc-mn10300.c (set_arch_mach): Make param unsigned.

	* config/tc-tic54x.c (tic54x_mlib): Replace bfd_read call with
	call to bfd_bread.
@
text
@d48 1
d359 1
a359 1
  if (!isalpha (*name))
d424 1
a424 1
  if (!isalpha (*name))
d1468 2
a1469 2
	       && toupper (ver[3]) == 'L'
	       && toupper (ver[4]) == 'P'
d2276 1
a2276 1
      if (!isalpha (*input_line_pointer))
d2329 1
a2329 1
	     && !isspace (*input_line_pointer))
d2743 1
a2743 1
      switch (toupper (a[len - 1]))
d2759 1
a2759 1
	  if (toupper (a[1]) == 'X')
d3298 1
a3298 1
      while (*lptr && isspace (*lptr))
d3328 1
a3328 1
	  while (len > 0 && isspace (operands[numexp].buf[len - 1]))
d3352 1
a3352 1
  while (*lptr && isspace (*lptr++))
d3505 1
a3505 1
      return is_accumulator (operand) && toupper (operand->buf[0]) == 'B';
d3507 1
a3507 1
      return is_accumulator (operand) && toupper (operand->buf[0]) == 'A';
d3510 1
a3510 1
	&& isdigit (operand->buf[2]);
d3740 1
a3740 1
      mod = ((toupper (operand->buf[1]) == 'A') ? 12 :
d3765 1
a3765 1
      arf = (toupper (operand->buf[1]) == 'A' ?
d3786 1
a3786 1
      else if (toupper (operand->buf[6]) == 'B')
d3788 1
a3788 1
      else if (toupper (operand->buf[6]) == '%')
d4006 1
a4006 1
      if (toupper (*operand->buf) == 'B')
d4015 1
a4015 1
      if (!((toupper (operand->buf[0]) == 'B') ^
d4025 1
a4025 1
      if (toupper (operand->buf[0]) == 'B')
d4422 1
a4422 1
  while (isspace (*next_line))
d4509 1
a4509 1
  int is_char = isdigit (*line);
d4513 1
a4513 1
      while (isdigit (*ptr))
d4732 1
a4732 1
	  if ((*name == '$' && isdigit (name[1]) && name[2] == '\0')
d4825 1
a4825 1
		      arg_type[1] = (isdigit (*ptr)) ? 2 : (*ptr == '"');
d5030 1
a5030 1
      while (isspace (*comment))
d5038 1
a5038 1
      while (isspace (tmp[0]) && isspace (tmp[1]))
d5139 1
a5139 1
	      while (isspace (tmp[2]))
d5677 2
a5678 2
  if (isspace (c))
    while (isspace (c = *++rest))
d5683 6
a5688 6
      return (strncasecmp (rest, ".tag", 4) != 0 || !isspace (rest[4]))
	&& (strncasecmp (rest, ".struct", 7) != 0 || !isspace (rest[7]))
	&& (strncasecmp (rest, ".union", 6) != 0 || !isspace (rest[6]))
	&& (strncasecmp (rest, ".macro", 6) != 0 || !isspace (rest[6]))
	&& (strncasecmp (rest, ".set", 4) != 0 || !isspace (rest[4]))
	&& (strncasecmp (rest, ".equ", 4) != 0 || !isspace (rest[4]));
@


1.6
log
@Fix copyright notices
@
text
@d2 1
a2 1
   Copyright 1999, 2000 Free Software Foundation, Inc.
d2391 1
a2391 1
      bfd_read (buf, size, 1, mbfd);
@


1.5
log
@2000-09-14  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-a29k.c: Fix formatting.
	* config/tc-alpha.c: Likewise.
	* config/tc-arc.c: Likewise.
	* config/tc-arc.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-tic80.h: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000 Free Software Foundation.
@


1.5.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1999, 2000 Free Software Foundation, Inc.
@


1.4
log
@Fix formatting.
@
text
@d152 1
a152 1
static struct hash_control *subsym_recurse_hash; /* Prevent infinite recurse. */
d1598 1
a1598 1
  c = ',';			/* Do loop. */
@


1.3
log
@Fix formatting
@
text
@d59 2
a60 2
const char line_comment_chars[] = ";*#"; /* at column zero only */
const char line_separator_chars[] = ""; /* not permitted */
d64 1
d104 2
a105 2
  c_mode,   /* 16-bit addresses */
  far_mode  /* >16-bit addresses */
d115 3
a117 3
  { "mfar-mode",       no_argument,         NULL, OPTION_ADDRESS_MODE },
  { "mf",              no_argument,         NULL, OPTION_ADDRESS_MODE },
  { "mcpu",            required_argument,   NULL, OPTION_CPU_VERSION },
d122 1
a122 1
  { "me",              required_argument,   NULL, OPTION_STDERR_TO_FILE },
d142 1
d145 1
d148 1
d152 2
a153 2
static struct hash_control *subsym_recurse_hash; /* prevent infinite recurse */
static struct hash_control *math_hash; /* built-in math functions */
d157 1
d213 4
a216 4
  symbolS *sym;                     /* symbol for this stag; value is offset */
  const char *name;                 /* shortcut to symbol name */
  bfd_vma size;                     /* size of struct/union */
  int current_bitfield_offset;      /* temporary for tracking fields */
d218 1
a218 1
  struct stag_field                 /* list of fields */
d221 3
a223 3
    bfd_vma offset;                 /* of start of this field */
    int bitfield_offset;            /* of start of this field */
    struct stag *stag;              /* if field is struct/union */
d226 3
a228 3
  /* for nesting; used only in stag construction */
  struct stag *inner;               /* enclosed .struct */
  struct stag *outer;               /* enclosing .struct */
d235 1
d248 1
d283 1
d299 1
d319 1
d381 1
d458 1
d498 1
a498 1
      /* the blocking flag may be missing */
d525 1
a525 1
  *p = 0;			/* fill char.  */
d545 1
a545 1
  subseg_set (current_seg, current_subseg);	/* restore current seg.  */
d574 9
a582 9
        {
          symbolS *sym;
          sym = symbol_new (name, absolute_section,
                            (field->stag ? field->offset :
                             (valueT) (base_offset + field->offset)),
                            &zero_address_frag);
          SF_SET_LOCAL (sym);
          symbol_table_insert (sym);
        }
d584 2
a585 2
        {
          char *replacement = xmalloc (strlen (name)
d587 6
a592 6
          strcpy (replacement, S_GET_NAME (rootsym));
          strcat (replacement, "+");
          strcat (replacement, root_stag_name);
          strcat (replacement, name + strlen (S_GET_NAME (rootsym)));
          hash_insert (subsym_hash[0], name, replacement);
        }
d595 1
a595 1
         Note the field offset is relative to the outermost struct.  */
d597 3
a599 3
        stag_add_field_symbols (field->stag, name,
                                field->offset,
                                rootsym, root_stag_name);
d606 1
d634 1
a634 1
                                 (valueT) offset, &zero_address_frag);
d641 2
a642 1
   start defining structure offsets (symbols in absolute section).  */
d669 1
a669 1
        start_offset = get_absolute_expression ();
d671 1
a671 1
        start_offset = 0;
d682 1
a682 1
        as_warn (_("Offset on nested structures is ignored"));
d699 2
a700 2
                                      (valueT) abs_section_offset,
                                      &zero_address_frag);
d707 2
a708 2
                                      (valueT) abs_section_offset,
                                      &zero_address_frag);
d722 1
d733 2
a734 2
              is_union ? "union" : "struct",
              is_union ? "union" : "struct");
d765 2
a766 2
                              S_GET_VALUE (current_stag->sym),
                              NULL, NULL);
d775 2
a776 2
                      S_GET_VALUE (current_stag->inner->sym),
                      current_stag->inner);
d787 1
d799 1
a799 1
        as_bad (_("Unrecognized struct/union tag '%s'"), name);
d801 1
a801 1
        as_bad (_(".tag requires a structure tag"));
d817 3
a819 3
        stag_add_field (current_stag, label,
                        abs_section_offset - S_GET_VALUE (current_stag->sym),
                        stag);
d821 11
a831 11
        {
          symbolS *sym = symbol_find (label);
          if (!sym)
            {
              as_bad (_(".tag target '%s' undefined"), label);
              ignore_rest_of_line ();
              return;
            }
          stag_add_field_symbols (stag, S_GET_NAME (sym),
                                  S_GET_VALUE (stag->sym), sym, stag->name);
        }
d846 1
d874 1
a874 1
    case '*': /* string */
d883 1
a883 1
    case '.': /* bitfield */
d886 5
a890 5
        {
          as_bad (_(".field count '%d' out of range (1 <= X <= 32)"), count);
          ignore_rest_of_line ();
          return;
        }
d892 5
a896 5
        {
          /* Set the appropriate size and new field offset.  */
          if (count == 32)
            {
              size = 2;
d898 4
a901 4
            }
          else if (count > 16)
            {
              size = 1;
d903 7
a909 7
              new_bitfield_offset = count - 16;
            }
          else
            {
              new_bitfield_offset = count;
            }
        }
d911 4
a914 4
        {
          field_align = 0;
          new_bitfield_offset = current_stag->current_bitfield_offset + count;
        }
d938 2
a939 2
                      abs_section_offset - S_GET_VALUE (current_stag->sym),
                      NULL);
d946 2
a947 2
                      abs_section_offset - S_GET_VALUE (current_stag->sym),
                      NULL);
d954 1
a954 1
        current_stag->size = size * count;
d965 1
d992 4
a995 4
        {
          symbol_set_frag (line_label, frag_now);
          S_SET_VALUE (line_label, frag_now_fix ());
        }
d1032 2
a1033 2
              offsetT value = exp.X_add_number;
              /* Truncate overflows.  */
d1037 3
a1039 3
                  if ((value > 0 && value > 0xFF)
                      || (value < 0 && value < - 0x100))
                    as_warn ("Overflow in expression, truncated to 8 bits");
d1042 3
a1044 3
                  if ((value > 0 && value > 0xFFFF)
                      || (value < 0 && value < - 0x10000))
                    as_warn ("Overflow in expression, truncated to 16 bits");
d1048 30
a1077 30
          if (exp.X_op != O_constant && octets < 2)
            {
              /* Disallow .byte with a non constant expression that will
                 require relocation.  */
              as_bad (_("Relocatable values require at least WORD storage"));
              ignore_rest_of_line ();
              return;
            }

          if (exp.X_op != O_constant
              && amode == c_mode
              && octets == 4)
            {
              /* FIXME -- at one point TI tools used to output REL16
                 relocations, but I don't think the latest tools do at all
                 The current tools output extended relocations regardless of
                 the addresing mode (I actually think that ".c_mode" is
                 totally ignored in the latest tools).  */
              amode = far_mode;
              emitting_long = 1;
              emit_expr (&exp, 4);
              emitting_long = 0;
              amode = c_mode;
            }
          else
            {
              emitting_long = octets == 4;
              emit_expr (&exp, (octets == 1) ? 2 : octets);
              emitting_long = 0;
            }
d1104 1
d1114 1
a1114 1
      as_warn (_("Use of .def/.ref is deprecated.  Use .global instead"));
d1139 1
d1150 1
d1168 1
d1187 5
a1191 5
        {
          name = demand_copy_C_string (&len);
          demand_empty_rest_of_line ();
          name = strcpy (xmalloc (len + 10), name);
        }
d1193 8
a1200 8
        {
          int c;
          name = input_line_pointer;
          c = get_symbol_end ();
          name = strcpy (xmalloc (len + 10), name);
          *input_line_pointer = c;
          demand_empty_rest_of_line ();
        }
d1207 3
a1209 3
         section.  This is for compatibility, even though the actual behavior
         is not explicitly defined.  For consistency, we make .sect behave
         like .usect, since that is probably what people expect.  */
d1211 7
a1217 7
        {
          S_SET_SEGMENT (line_label, now_seg);
          symbol_set_frag (line_label, frag_now);
          S_SET_VALUE (line_label, frag_now_fix ());
          if (S_GET_STORAGE_CLASS (line_label) != C_EXT)
              S_SET_STORAGE_CLASS (line_label, C_LABEL);
        }
d1226 1
d1260 3
a1262 3
                    65536*2, 1, (relax_substateT) 0,
                    make_expr_symbol (&exp), (offsetT) 0,
                    (char *) bi);
d1264 1
a1264 1
        *p = 0;
d1276 12
a1287 12
        {
          /* Don't have to do anything; sufficient bits have already been
             allocated; just point the label to the right place.  */
          if (label != NULL)
            {
              symbol_set_frag (label, frag_now);
              S_SET_VALUE (label, frag_now_fix () - 1);
              label = NULL;
            }
          frag_now->tc_frag_data += exp.X_add_number;
          goto getout;
        }
d1290 1
a1290 1
         case is the previous word, which was only partially filled.  */
d1292 5
a1296 5
        {
          symbol_set_frag (label, frag_now);
          S_SET_VALUE (label, frag_now_fix () - 1);
          label = NULL;
        }
d1319 1
a1319 1
        S_SET_VALUE (label, abs_section_offset - 1);
d1326 2
a1327 2
                  (relax_substateT) 0, (symbolS *) 0,
                  (offsetT) octets, (char *) 0);
d1348 1
a1348 1
                   [, [blocking-flag] [, alignment-flag]]
d1356 1
d1373 2
a1374 2
  current_seg = now_seg;	/* save current seg.  */
  current_subseg = now_subseg;	/* save current subseg.  */
d1400 1
a1400 1
        blocking_flag = get_absolute_expression ();
d1402 1
a1402 1
        blocking_flag = 0;
d1406 4
a1409 4
        {
          ++input_line_pointer;
          alignment_flag = get_absolute_expression ();
        }
d1411 1
a1411 1
        alignment_flag = 0;
d1431 1
a1431 1
      /* set scl to label, since that's what TI does */
d1433 1
a1433 1
        S_SET_STORAGE_CLASS (line_label, C_LABEL);
d1439 2
a1440 2
                (relax_substateT) 0, (symbolS *) line_label,
                size * OCTETS_PER_BYTE, (char *) 0);
d1462 9
a1470 9
      if (strlen (ver) == 3 &&
          (ver[2] == '1' || ver[2] == '2' || ver[2] == '3' ||
           ver[2] == '5' || ver[2] == '8' || ver[2] == '9'))
        version = ver[2] - '0';
      else if (strlen (ver) == 5 &&
               toupper (ver[3]) == 'L' &&
               toupper (ver[4]) == 'P' &&
               (ver[2] == '5' || ver[2] == '6'))
        version = ver[2] - '0' + 10;
d1484 1
a1484 1
                                    (valueT) 1, &zero_address_frag);
d1547 1
d1564 4
a1567 4
        {
          symbol_set_frag (line_label, frag_now);
          S_SET_VALUE (line_label, frag_now_fix ());
        }
d1577 1
d1604 7
a1610 7
        default:
          {
            unsigned short value = get_absolute_expression ();
            FRAG_APPEND_1_CHAR ( value       & 0xFF);
            FRAG_APPEND_1_CHAR ((value >> 8) & 0xFF);
            break;
          }
d1612 1
a1612 1
	  ++input_line_pointer;	/*->1st char of string. */
d1616 17
a1632 17
              if (!packed)
                {
                  FRAG_APPEND_1_CHAR (c);
                  FRAG_APPEND_1_CHAR (0);
                }
              else
                {
                  /* Packed strings are filled MS octet first.  */
                  if (last_char == -1)
                    last_char = c;
                  else
                    {
                      FRAG_APPEND_1_CHAR (c);
                      FRAG_APPEND_1_CHAR (last_char);
                      last_char = -1;
                    }
                }
d1635 13
a1647 13
            {
              if (packed && last_char != -1)
                {
                  FRAG_APPEND_1_CHAR (0);
                  FRAG_APPEND_1_CHAR (last_char);
                  last_char = -1;
                }
              else
                {
                  FRAG_APPEND_1_CHAR (0);
                  FRAG_APPEND_1_CHAR (0);
                }
            }
d1654 1
a1654 1
        ++input_line_pointer;
d1683 1
a1683 1
        as_warn (_("Argument to .even ignored"));
d1685 1
a1685 1
        count = get_absolute_expression ();
d1691 4
a1694 4
        {
          current_stag->current_bitfield_offset = 0;
          ++abs_section_offset;
        }
d1705 1
d1729 5
a1733 5
        {
          as_bad (_("Invalid field size, must be from 1 to 32"));
          ignore_rest_of_line ();
          return;
        }
d1739 2
a1740 1
      /* If the expression value is relocatable, the field size *must* be 16.  */
d1742 5
a1746 5
        {
          as_bad (_("field size must be 16 when value is relocatable"));
          ignore_rest_of_line ();
          return;
        }
d1757 1
a1757 1
        as_warn (_("field value truncated"));
d1761 6
a1766 6
        {
          frag_now->tc_frag_data = 0;
          p = frag_more (2);
          md_number_to_chars (p, (value >> (size - 16)) & 0xFFFF, 2);
          size -= 16;
        }
d1768 51
a1818 51
        {
          int bit_offset = frag_bit_offset (frag_now, now_seg);
          fragS *alloc_frag = bit_offset_frag (frag_now, now_seg);
          if (bit_offset == -1)
            {
              struct bit_info *bi = xmalloc (sizeof (struct bit_info));
              /* We don't know the previous offset at this time, so store the
                 info we need and figure it out later.  */
              expressionS size_exp;
              size_exp.X_op = O_constant;
              size_exp.X_add_number = size;
              bi->seg = now_seg;
              bi->type = TYPE_FIELD;
              bi->value = value;
              p = frag_var (rs_machine_dependent,
                            4, 1, (relax_substateT) 0,
                            make_expr_symbol (&size_exp), (offsetT) 0,
                            (char *) bi);
              goto getout;
            }
          else if (bit_offset == 0 || bit_offset + size > 16)
            {
              /* Align a new field.  */
              p = frag_more (2);
              frag_now->tc_frag_data = 0;
              alloc_frag = frag_now;
            }
          else
            {
              /* Put the new value entirely within the existing one.  */
              p = alloc_frag == frag_now ?
                frag_now->fr_literal + frag_now_fix_octets () - 2 :
                alloc_frag->fr_literal;
              if (label != NULL)
                {
                  symbol_set_frag (label, alloc_frag);
                  if (alloc_frag == frag_now)
                    S_SET_VALUE (label, frag_now_fix () - 1);
                  label = NULL;
                }
            }
          value <<= 16 - alloc_frag->tc_frag_data - size;

          /* OR in existing value.  */
          if (alloc_frag->tc_frag_data)
            value |= ((unsigned short) p[1] << 8) | p[0];
          md_number_to_chars (p, value, 2);
          alloc_frag->tc_frag_data += size;
          if (alloc_frag->tc_frag_data == 16)
            alloc_frag->tc_frag_data = 0;
        }
d1826 1
d1840 1
d1854 1
a1854 1
        ;
d1862 5
a1866 5
        {
          as_bad (_("Unrecognized section '%s'"), section_name);
          ignore_rest_of_line ();
          return;
        }
d1871 6
a1876 6
        {
          as_bad (_("Current section is unitialized, "
                    "section name required for .clink"));
          ignore_rest_of_line ();
          return;
        }
d1887 1
d1910 4
a1913 4
        {
          include_dirs = (char **) xmalloc (sizeof (*include_dirs));
          include_dir_count = 1;
        }
d1916 1
a1916 1
        include_dir_maxlen = len;
d1932 1
d1955 1
a1955 1
        ++input_line_pointer;
d1993 1
a1993 1
        ++input_line_pointer;
d2017 1
a2017 1
   define a special symbol that refers to the loadtime address rather than the
d2023 1
d2043 3
a2045 2
   install all memory-mapped register names into the symbol table as absolute
   local symbols.  */
d2057 1
a2057 1
                                     (valueT) sym->value, &zero_address_frag);
d2064 2
a2065 1
   count defaults to 1024.  */
d2073 1
a2073 1
      count = get_absolute_expression ();
d2079 1
d2089 1
d2100 2
a2101 3
    {
      cond = get_absolute_expression ();
    }
d2103 1
a2103 3
    {
      end_repeat (substitution_line ? 1 : 0);
    }
d2114 1
a2114 1
                                    (valueT) 1, &zero_address_frag);
d2143 2
a2144 1
   designate initialized sections for blocking.  */
d2159 4
a2162 4
        {
          int len;
          name = demand_copy_C_string (&len);
        }
d2164 7
a2170 7
        {
          char *section_name = input_line_pointer;
          c = get_symbol_end ();
          name = xmalloc (strlen (section_name) + 1);
          strcpy (name, section_name);
          *input_line_pointer = c;
        }
d2174 5
a2178 5
        {
          as_bad (_("Unrecognized section '%s'"), name);
          ignore_rest_of_line ();
          return;
        }
d2180 5
a2184 5
        {
          as_bad (_(".sblock may be used for initialized sections only"));
          ignore_rest_of_line ();
          return;
        }
d2189 1
a2189 1
        ++input_line_pointer;
d2200 1
d2234 2
a2235 1
   list false conditional blocks.  */
d2255 2
a2256 1
   define a substitution string to be local to a macro.  */
d2276 5
a2280 5
        {
          as_bad (_("Substitution symbols must begin with a letter"));
          ignore_rest_of_line ();
          return;
        }
d2283 1
a2283 1
      /* .var symbols start out with a null string */
d2288 5
a2292 5
        {
          ++input_line_pointer;
          if (is_end_of_line[(int) *input_line_pointer])
            c = *input_line_pointer;
        }
d2305 1
d2317 1
a2317 1
  /* parse the filename */
d2321 1
a2321 1
        return;
d2328 6
a2333 6
             && !isspace (*input_line_pointer))
        {
          obstack_1grow (&notes, *input_line_pointer);
          ++input_line_pointer;
          ++len;
        }
d2348 4
a2351 4
        {
          fclose (try);
          break;
        }
d2361 1
a2361 1
     running for a very long time, it really doesn't matter...  */
d2394 1
a2394 1
         a bit of a hack...  */
d2398 1
a2398 1
        fwrite ("\n", 1, 1, ftmp);
d2408 22
a2429 22
  { "algebraic", s_ignore, 0 },
  { "align", tic54x_align_words, 128 },
  { "even", tic54x_align_words, 2 },
  { "asg", tic54x_asg, 0 },
  { "eval", tic54x_eval, 0 },
  { "bss", tic54x_bss, 0 },
  { "byte", tic54x_cons, 'b' },
  { "ubyte", tic54x_cons, 'B' },
  { "char", tic54x_cons, 'c' },
  { "uchar", tic54x_cons, 'C' },
  { "clink", tic54x_clink, 0 },
  { "c_mode", tic54x_address_mode, c_mode },
  { "copy", tic54x_include, 'c' },
  { "include", tic54x_include, 'i' },
  { "data", tic54x_sect, 'd' },
  { "double", tic54x_float_cons, 'd' },
  { "ldouble", tic54x_float_cons, 'l' },
  { "drlist", s_ignore, 0 },
  { "drnolist", s_ignore, 0 },
  { "emsg", tic54x_message, 'e' },
  { "mmsg", tic54x_message, 'm' },
  { "wmsg", tic54x_message, 'w' },
d2431 1
a2431 1
  { "end",     s_end,                   0 },
d2433 25
a2457 24
  { "far_mode", tic54x_address_mode, far_mode },
  { "fclist",   tic54x_fclist, 1 },
  { "fcnolist", tic54x_fclist, 0 },
  { "field", tic54x_field, -1 },
  { "float", tic54x_float_cons, 'f' },
  { "xfloat",  tic54x_float_cons, 'x' },
  { "global", tic54x_global, 'g' },
  { "def", tic54x_global, 'd' },
  { "ref", tic54x_global, 'r' },
  { "half", tic54x_cons, 'h' },
  { "uhalf", tic54x_cons, 'H' },
  { "short", tic54x_cons, 's' },
  { "ushort", tic54x_cons, 'S' },
  { "if", s_if, (int) O_ne },
  { "elseif", s_elseif, (int) O_ne },
  { "else", s_else, 0 },
  { "endif", s_endif, 0 },
  { "int", tic54x_cons, 'i' },
  { "uint", tic54x_cons, 'I' },
  { "word", tic54x_cons, 'w' },
  { "uword", tic54x_cons, 'W' },
  { "label", tic54x_label, 0 }, /* loadtime address */
  { "length",   s_ignore, 0 },
  { "width",    s_ignore, 0 },
d2459 2
a2460 2
  { "list",     listing_list,      1 },
  { "nolist",   listing_list,      0 },
d2462 13
a2474 13
  { "long", tic54x_cons, 'l' },
  { "ulong", tic54x_cons, 'L' },
  { "xlong", tic54x_cons, 'x' },
  { "loop", tic54x_loop, 1024 },
  { "break", tic54x_break, 0 },
  { "endloop", tic54x_endloop, 0 },
  { "mlib", tic54x_mlib, 0 },
  { "mlist",     s_ignore, 0 },
  { "mnolist",     s_ignore, 0 },
  { "mmregs", tic54x_mmregs, 0 },
  { "newblock", tic54x_clear_local_labels, 0 },
  { "option",     s_ignore, 0 },
  { "p2align", tic54x_p2align, 0 },
d2476 1
a2476 1
  { "page",     listing_eject,      0 },
d2478 15
a2492 15
  { "sblock", tic54x_sblock, 0 },
  { "sect", tic54x_sect, '*' },
  { "set", tic54x_set, 0 },
  { "equ", tic54x_set, 0 },
  { "space", tic54x_space, 0 },
  { "bes", tic54x_space, 1 },
  { "sslist", tic54x_sslist, 1 },
  { "ssnolist", tic54x_sslist, 0 },
  { "string", tic54x_stringer, 's' },
  { "pstring", tic54x_stringer, 'p' },
  { "struct", tic54x_struct, 0 },
  { "tag", tic54x_tag, 0 },
  { "endstruct", tic54x_endstruct, 0 },
  { "tab",     s_ignore, 0 },
  { "text", tic54x_sect, 't' },
d2494 1
a2494 1
  { "title",     listing_title,      0 },
d2496 6
a2501 6
  { "union", tic54x_struct, 1 },
  { "endunion", tic54x_endstruct, 1 },
  { "usect", tic54x_usect, 0 },
  { "var", tic54x_var, 0 },
  { "version", tic54x_version, 0 },
  {0, 0, 0}
d2530 5
a2534 5
        int version = atoi (arg);
        if (version != 0 && version != 1 && version != 2)
          as_fatal (_("Bad COFF version '%s'"), arg);
        /* FIXME -- not yet implemented */
        break;
d2538 5
a2542 5
        cpu = lookup_version (arg);
        cpu_needs_set = 1;
        if (cpu == VNONE)
          as_fatal (_("Bad CPU version '%s'"), arg);
        break;
d2550 8
a2557 8
        char *filename = arg;
        FILE *fp = fopen (filename, "w+");
        if (fp == NULL)
          as_fatal (_("Can't redirect stderr to the file '%s'"), filename);
        fclose (fp);
        if ((fp = freopen (filename, "w+", stderr)) == NULL)
          as_fatal (_("Can't redirect stderr to the file '%s'"), filename);
        break;
d2568 1
d2583 7
a2589 5
    struct formal_struct *next;	/* next formal in list */
    sb name;			/* name of the formal */
    sb def;			/* the default value */
    sb actual;			/* the actual argument (changed on each expansion) */
    int index;			/* the index of the formal 0..formal_count-1 */
d2593 5
a2597 4
    sb sub;			/* substitution text. */
    int formal_count;		/* number of formal args. */
    struct formal_struct *formals;	/* pointer to list of formal_structs */
    struct hash_control *formal_hash; /* hash table of formals. */
d2606 1
a2606 1
                            entry->name.ptr, entry->name.len);
d2608 1
a2608 1
                             entry->actual.ptr, entry->actual.len);
d2616 1
d2629 2
a2630 2
  char *a;
  char *ignore ATTRIBUTE_UNUSED;
d2636 1
d2647 1
d2660 1
d2663 2
a2664 2
  char *a;
  char *b;
d2673 2
a2674 1
   symbol table). */
d2677 2
a2678 2
  char *a;
  char *ignore ATTRIBUTE_UNUSED;
d2688 1
d2728 1
d2743 12
a2754 12
        {
        case 'B':
          return 1;
        case 'Q':
          return 2;
        case 'H':
          return 3;
        case '\'':
          return 4;
        default:
          break;
        }
d2757 5
a2761 5
        {
          if (toupper (a[1]) == 'X')
            return 3;
          return 2;
        }
d2769 1
d2780 1
a2780 1
        return 0;
d2789 1
d2803 1
d2822 1
d2964 1
d3129 1
a3129 1
  /* Look for A_DIR and add it to the include list. a */
d3148 1
a3148 1
        continue;
d3151 2
a3152 2
        as_fatal ("Internal Error: Can't hash %s: %s",
                  opcode->name, hash_err);
d3160 1
a3160 1
        continue;
d3163 2
a3164 2
        as_fatal ("Internal Error: Can't hash %s: %s",
                  paropcode->name, hash_err);
d3171 1
a3171 1
                                     (valueT) sym->value, &zero_address_frag);
d3215 1
a3215 1
                              (char *) subsym_proc);
d3221 1
a3221 1
         the math hash to actually store information.  */
d3223 1
a3223 1
                              (char *) math_proc);
d3225 1
a3225 1
                              (char *) math_proc);
d3233 2
a3234 2
  const template *tm;               /* opcode template */
  const partemplate *ptm;           /* parallel opcode template */
d3236 2
a3237 2
  char mnemonic[MAX_LINE];          /* opcode name/mnemonic */
  char parmnemonic[MAX_LINE];       /* 2nd mnemonic of parallel insn */
d3252 3
a3254 3
  int words;                        /* size of insn in 16-bit words */
  int using_default_dst;            /* do we need to explicitly set an
                                       omitted OP_DST operand? */
d3257 1
a3257 1
    unsigned short word;            /* final encoded opcode data */
d3259 3
a3261 3
    int r_nchars;                     /* relocation size */
    bfd_reloc_code_real_type r_type; /* relocation type */
    expressionS addr_expr;          /* storage for unresolved expressions */
d3268 1
a3268 1
                           const enum optype *, int, int);
d3279 4
a3282 2
/* Return the number of operands found, or -1 on error, copying the operands
   into the given array and the accompanying expressions into the next array.  */
d3285 2
a3286 2
  struct opstruct operands[];
  char *line;
d3298 1
a3298 1
        ++lptr;
d3301 17
a3317 17
        {
          if (*lptr == '\0')
            {
              if (paren_not_balanced)
                {
                  as_bad ("Unbalanced parenthesis in operand %d", numexp);
                  return -1;
                }
              else
                break;
            }
          if (*lptr == '(')
            ++paren_not_balanced;
          else if (*lptr == ')')
            --paren_not_balanced;
          ++lptr;
        }
d3320 12
a3331 12
        {
          int len = op_end - op_start;
          strncpy (operands[numexp].buf, op_start, len);
          operands[numexp].buf[len] = 0;
          /* Trim trailing spaces; while the preprocessor gets rid of most,
             there are weird usage patterns that can introduce them
             (i.e. using strings for macro args).  */
          while (len > 0 && isspace (operands[numexp].buf[len - 1]))
            operands[numexp].buf[--len] = 0;
          lptr = op_end;
          ++numexp;
        }
d3333 7
a3339 7
        {
          if (expecting_operand || *lptr == ',')
            {
              as_bad ("Expecting operand after ','");
              return -1;
            }
        }
d3341 8
a3348 8
        {
          if (*++lptr == '\0')
            {
              as_bad ("Expecting operand after ','");
              return -1;
            }
          expecting_operand = 1;
        }
d3364 4
a3367 4
        {
          /* immediate */
          parse_expression (operands[i].buf + 1, &operands[i].exp);
        }
d3369 4
a3372 4
        {
          /* direct notation */
          parse_expression (operands[i].buf + 1, &operands[i].exp);
        }
d3374 27
a3400 27
        {
          /* indirect */
          char *paren = strchr (operands[i].buf, '(');
          /* Allow immediate syntax in the inner expression.  */
          if (paren && paren[1] == '#')
              *++paren = '(';

          /* Pull out the lk expression or SP offset, if present.  */
          if (paren != NULL)
            {
              int len = strlen (paren);
              char *end = paren + len;
              int c;
              while (end[-1] != ')')
                if (--end <= paren)
                  {
                    as_bad (_("Badly formed address expression"));
                    return -1;
                  }
              c = *end;
              *end = '\0';
              parse_expression (paren, &operands[i].exp);
              *end = c;
            }
          else
            operands[i].exp.X_op = O_absent;
        }
d3402 1
a3402 3
        {
          parse_expression (operands[i].buf, &operands[i].exp);
        }
d3409 1
d3419 1
d3428 1
d3437 1
d3451 3
a3453 3
        strcasecmp (tmp, "-") == 0 ||
        strcasecmp (tmp, "+") == 0 ||
        strcasecmp (tmp, "+0%") == 0;
d3463 3
a3465 2
  return is_absolute (operand) || is_immediate (operand)
    || hash_find (mmreg_hash, operand->buf) != 0;
d3509 1
a3509 1
        && isdigit (operand->buf[2]);
d3518 1
a3518 1
        || is_immediate (operand) || is_absolute (operand);
d3521 1
a3521 1
        && operand->exp.X_add_number == 16;
d3525 2
a3526 2
        strcasecmp ("st0", operand->buf) == 0 ||
        strcasecmp ("st1", operand->buf) == 0;
d3532 1
a3532 1
        && operand->exp.X_add_number >= 0 && operand->exp.X_add_number < 16;
d3536 1
a3536 1
        && operand->exp.X_add_number != 16;
d3543 3
a3545 3
        && operand->exp.X_op == O_constant
        && operand->exp.X_add_number >= 0
        && operand->exp.X_add_number < 256;
d3549 1
a3549 1
         versions first.  */
d3558 1
a3558 1
        strcasecmp ("treg", operand->buf) == 0;
d3592 13
a3604 13
        {
          /* Skip an optional template operand if it doesn't agree
             with the current operand.  */
          if (refoptype[refop] & OPT)
            {
              ++refop;
              --maxops;
              if (refop > maxops)
                return 0;
            }
          else
            return 0;
        }
d3612 13
a3624 13
        {
          while (op < maxops)
            {
              /* If a later operand is *not* optional, no match.  */
              if ((refoptype[refop] & OPT) == 0)
                return 0;
              /* Flag any implicit default OP_DST operands so we know to add
                 them explicitly when encoding the operand later.  */
              if (OPTYPE (refoptype[refop]) == OP_DST)
                insn->using_default_dst = 1;
              ++refop;
              ++op;
            }
d3626 2
a3627 2
          return 1;
        }
d3643 1
d3665 5
a3669 5
        {
          insn->opcode[0].word &= 0xFF80;
          insn->opcode[0].word |= (value >> 16) & 0x7F;
          insn->opcode[1].word = value & 0xFFFF;
        }
d3671 1
a3671 1
        insn->opcode[op].word = (value >> 16) & 0xFFFF;
d3673 1
a3673 1
        insn->opcode[op].word = value;
d3682 1
a3682 1
        insn->opcode[op].r_type = BFD_RELOC_TIC54X_16_OF_23;
d3684 10
a3693 10
        {
          /* This relocation spans two words, so adjust accordingly.  */
          insn->opcode[0].addr_expr = operand->exp;
          insn->opcode[0].r_type = BFD_RELOC_TIC54X_23;
          insn->opcode[0].r_nchars = 4;
          insn->opcode[0].unresolved = 1;
          /* It's really 2 words, but we want to stop encoding after the
             first, since we must encode both words at once.  */
          insn->words = 1;
        }
d3695 1
a3695 1
        insn->opcode[op].r_type = BFD_RELOC_TIC54X_MS7_OF_23;
d3697 1
a3697 1
        insn->opcode[op].r_type = BFD_RELOC_TIC54X_16_OF_23;
d3705 1
a3706 1
/* 7-bit direct address encoding.  */
d3740 2
a3741 2
             (operand->buf[1] == '(') ? 15 :
             (strchr (operand->buf, '%') != NULL) ? 14 : 13);
d3743 1
a3743 1
             (mod == 15) ? 0 : operand->buf[4] - '0');
d3748 1
a3748 1
        insn->opcode[1].word = operand->exp.X_add_number;
d3750 6
a3755 6
        {
          insn->opcode[1].word = 0;
          insn->opcode[1].r_nchars = 2;
          insn->opcode[1].r_type = BFD_RELOC_TIC54X_16_OF_23;
          insn->opcode[1].unresolved = 1;
        }
d3765 1
a3765 1
             operand->buf[3] : operand->buf[4]) - '0';
d3768 6
a3773 6
        {
          mod = 3;                    /* *+ARx */
          if (insn->tm->flags & FL_SMR)
            as_warn (_("Address mode *+ARx is write-only. "
                       "Results of reading are undefined."));
        }
d3775 1
a3775 1
        mod = 0;                    /* *ARx */
d3777 1
a3777 1
        mod = (operand->buf[4] == '-' ? 1 : 2); /* *ARx+ / *ARx- */
d3779 6
a3784 6
        {
          if (operand->buf[5] == '0')
            mod = (operand->buf[4] == '-' ? 5 : 6); /* *ARx+0 / *ARx-0 */
          else
            mod = (operand->buf[4] == '-' ? 8 : 10);/* *ARx+% / *ARx-% */
        }
d3786 1
a3786 1
        mod = (operand->buf[4] == '-' ? 4 : 7); /* ARx+0B / *ARx-0B */
d3788 1
a3788 1
        mod = (operand->buf[4] == '-' ? 9 : 11); /* ARx+0% / *ARx - 0% */
d3790 5
a3794 5
        {
          as_bad (_("Unrecognized indirect address format \"%s\""),
                  operand->buf);
          return 0;
        }
d3817 1
a3817 1
         instead of negative.  */
d3819 1
a3819 1
        integer = (short) parse;
d3821 1
a3821 1
        integer = parse;
d3824 4
a3827 4
        {
          insn->opcode[which].word |= (integer & mask);
          return 1;
        }
d3829 1
a3829 1
              operand->buf, min, max);
d3834 4
a3837 4
        {
          insn->opcode[which].word |=
            insn->opcode[which].addr_expr.X_add_number & mask;
        }
d3839 15
a3853 15
        {
          /* Do the fixup later; just store the expression.  */
          bfd_reloc_code_real_type rtype =
            (mask == 0x1FF ? BFD_RELOC_TIC54X_PARTMS9 :
             mask == 0xFFFF ? BFD_RELOC_TIC54X_16_OF_23 :
             mask == 0x7F ? BFD_RELOC_TIC54X_PARTLS7 : BFD_RELOC_8);
          int size = (mask == 0x1FF || mask == 0xFFFF) ? 2 : 1;

          if (rtype == BFD_RELOC_8)
            as_bad (_("Error in relocation handling"));

          insn->opcode[which].r_nchars = size;
          insn->opcode[which].r_type = rtype;
          insn->opcode[which].unresolved = 1;
        }
d3885 5
a3889 5
        {
          as_bad (_("Condition \"%s\" does not match preceding group"),
                  operand->buf);
          return 0;
        }
d3891 19
a3909 19
        {
          if ((insn->opcode[0].word & CC_ACC) != (cc->value & CC_ACC))
            {
              as_bad (_("Condition \"%s\" uses a different accumulator from "
                        "a preceding condition"),
                      operand->buf);
              return 0;
            }
          if ((insn->opcode[0].word & CATG_A1) && (cc->value & CATG_A1))
            {
              as_bad (_("Only one comparison conditional allowed"));
              return 0;
            }
          if ((insn->opcode[0].word & CATG_B1) && (cc->value & CATG_B1))
            {
              as_bad (_("Only one overflow conditional allowed"));
              return 0;
            }
        }
d3911 6
a3916 6
               ((insn->opcode[0].word & CATG_B2) && (cc->value & CATG_B2)) ||
               ((insn->opcode[0].word & CATG_C2) && (cc->value & CATG_C2)))
        {
          as_bad (_("Duplicate %s conditional"), operand->buf);
          return 0;
        }
d3982 5
a3986 5
        {
          as_bad (_("lk addressing modes are invalid for memory-mapped "
                    "register addressing"));
          return 0;
        }
d3990 5
a3994 5
        {
          as_warn (_("Address mode *+ARx is not allowed in memory-mapped "
                     "register addressing.  Resulting behavior is "
                     "undefined."));
        }
d4006 5
a4010 5
        {
          insn->opcode[ext ?  (1 + insn->is_lkaddr) : 0].word |= (1<<9);
          if (insn->using_default_dst)
            insn->opcode[ext ? (1 + insn->is_lkaddr) : 0].word |= (1<<8);
        }
d4015 6
a4020 6
            ((insn->opcode[0].word & (1<<8)) != 0)))
        {
          as_bad (_("Destination accumulator for each part of this parallel "
                    "instruction must be different"));
          return 0;
        }
d4025 1
a4025 1
        insn->opcode[ext ? (1 + insn->is_lkaddr) : 0].word |= (1<<8);
d4030 3
a4032 3
	int mod = (operand->buf[4] == '\0' ? 0 : /* *arx */
		   operand->buf[4] == '-' ? 1 : /* *arx- */
		   operand->buf[5] == '\0' ? 2 : 3); /* *arx+, *arx+0% */
d4041 2
a4042 2
        return encode_address (insn, operand);
      /* fall through */
d4082 1
a4082 1
                             0, 15, 0xF);
d4085 1
a4085 1
                             -16, 15, 0x1F);
d4088 1
a4088 1
                             -32768, 32767, 0xFFFF);
d4118 1
a4118 1
                             0, 65535, 0xFFFF);
d4149 6
a4154 5
          || strcasecmp (operand->buf, "st1") == 0)
        {
          insn->opcode[0].word |= ((unsigned short) (operand->buf[2] - '0'))<<9;
          return 1;
        }
d4156 7
a4162 7
               && (operand->exp.X_add_number == 0
                   || operand->exp.X_add_number == 1))
        {
          insn->opcode[0].word |= ((unsigned short)
                                   (operand->exp.X_add_number))<<9;
          return 1;
        }
d4173 5
a4177 5
          && operand->exp.X_add_number != 2)
        {
          as_bad (_("Operand \"%s\" out of range (use 1 or 2)"), operand->buf);
          return 0;
        }
d4205 1
a4205 1
                  && insn->opcode[i].r_type == BFD_RELOC_TIC54X_23) ? 4 : 2;
d4209 1
a4209 1
        md_number_to_chars (p, (valueT) insn->opcode[i].word, 2);
d4211 1
a4211 1
        md_number_to_chars (p, (valueT) insn->opcode[i].word << 16, 4);
d4214 3
a4216 3
        fix_new_exp (frag_now, p - frag_now->fr_literal,
                     insn->opcode[i].r_nchars, &insn->opcode[i].addr_expr,
                     false, insn->opcode[i].r_type);
d4222 1
d4233 13
a4245 13
        {
          if ((OPTYPE (insn->operands[i].type) == OP_Smem ||
               OPTYPE (insn->operands[i].type) == OP_Lmem ||
               OPTYPE (insn->operands[i].type) == OP_Sind) &&
              strchr (insn->operands[i].buf, '(') &&
              /* Don't mistake stack-relative addressing for lk addressing.  */
              strncasecmp (insn->operands[i].buf, "*sp (", 4) != 0)
            {
              insn->is_lkaddr = 1;
              insn->lkoperand = i;
              break;
            }
        }
d4254 1
a4254 1
  for (i=0; i < insn->opcount; i++)
d4258 1
a4258 7
        return 0;
    }
  if (insn->ptm) for (i=0; i < insn->paropcount; i++)
    {
      enum optype partype = insn->paroperands[i].type;
      if (!encode_operand (insn, partype, &insn->paroperands[i]))
        return 0;
d4260 7
d4281 10
a4290 10
      if (insn->opcount > 1 &&
          is_accumulator (&insn->operands[insn->opcount-2]) &&
          is_accumulator (&insn->operands[insn->opcount-1]) &&
          strcasecmp (insn->operands[insn->opcount-2].buf,
		      insn->operands[insn->opcount-1].buf) == 0)
        {
          --insn->opcount;
          insn->using_default_dst = 1;
          return 1;
        }
d4293 13
a4305 13
      if ((OPTYPE (insn->tm->operand_types[0]) == OP_Xmem &&
           OPTYPE (insn->tm->operand_types[1]) == OP_SHFT &&
           is_zero (insn->operands[1])) ||
          /* Or if Smem, shift is zero or absent, and SRC == DST.  */
          (OPTYPE (insn->tm->operand_types[0]) == OP_Smem &&
           OPTYPE (insn->tm->operand_types[1]) == OP_SHIFT &&
           is_type (&insn->operands[1], OP_SHIFT) &&
           is_zero (insn->operands[1]) && insn->opcount == 3))
        {
          insn->operands[1] = insn->operands[2];
          insn->opcount = 2;
          return 1;
        }
d4310 26
a4335 26
        {
          if ((OPTYPE (insn->tm->operand_types[1]) == OP_SHIFT ||
               OPTYPE (insn->tm->operand_types[1]) == OP_SHFT) &&
              is_zero (insn->operands[1]) &&
              (OPTYPE (insn->tm->operand_types[0]) != OP_lk ||
               (insn->operands[0].exp.X_op == O_constant &&
                insn->operands[0].exp.X_add_number <= 255 &&
                insn->operands[0].exp.X_add_number >= 0)))
            {
              insn->operands[1] = insn->operands[2];
              insn->opcount = 2;
              return 1;
            }
        }
    }
  else if (strcasecmp (insn->tm->name, "sth") == 0 ||
           strcasecmp (insn->tm->name, "stl") == 0)
    {
      if ((OPTYPE (insn->tm->operand_types[1]) == OP_SHIFT ||
           OPTYPE (insn->tm->operand_types[1]) == OP_SHFT) &&
          is_zero (insn->operands[1]))
        {
          insn->operands[1] = insn->operands[2];
          insn->opcount = 2;
          return 1;
        }
d4339 22
a4360 22
      if (insn->opcount > 1 &&
          is_accumulator (&insn->operands[insn->opcount-2]) &&
          is_accumulator (&insn->operands[insn->opcount-1]) &&
          strcasecmp (insn->operands[insn->opcount-2].buf,
		      insn->operands[insn->opcount-1].buf) == 0)
        {
          --insn->opcount;
          insn->using_default_dst = 1;
          return 1;
        }

      if (((OPTYPE (insn->tm->operand_types[0]) == OP_Smem &&
            OPTYPE (insn->tm->operand_types[1]) == OP_SHIFT) ||
           (OPTYPE (insn->tm->operand_types[0]) == OP_Xmem &&
            OPTYPE (insn->tm->operand_types[1]) == OP_SHFT)) &&
          is_zero (insn->operands[1]) &&
          insn->opcount == 3)
        {
          insn->operands[1] = insn->operands[2];
          insn->opcount = 2;
          return 1;
        }
d4366 1
d4386 10
a4395 10
      if (insn->opcount >= insn->tm->minops &&
          insn->opcount <= insn->tm->maxops &&
          operands_match (insn, &insn->operands[0], insn->opcount,
                          insn->tm->operand_types,
                          insn->tm->minops, insn->tm->maxops))
        {
          /* SUCCESS! now try some optimizations.  */
          if (optimize_insn (insn))
            {
              insn->tm = (template *) hash_find (op_hash,
d4397 2
a4398 2
              continue;
            }
d4400 2
a4401 2
          return 1;
        }
d4412 1
d4415 1
d4420 1
a4420 1
  /* look for the second half */
d4424 2
a4425 2
  return (next_line[0] == PARALLEL_SEPARATOR &&
          next_line[1] == PARALLEL_SEPARATOR);
d4437 1
a4437 1
              insn->mnemonic);
d4446 7
a4452 7
        return 0;
      if (insn->opcount == 2 &&
          operands_match (insn, &insn->operands[0], insn->opcount,
                          insn->ptm->operand_types, 2, 2))
        {
          return 1;
        }
d4460 1
d4463 2
a4464 2
  tic54x_insn *insn;
  char *line;
d4470 1
a4470 1
                                       insn->mnemonic) == 0)
d4473 12
a4484 12
        {
          valid_mnemonic = 1;
          if (insn->paropcount >= insn->ptm->minops &&
              insn->paropcount <= insn->ptm->maxops &&
              operands_match (insn, insn->paroperands,
                              insn->paropcount,
                              insn->ptm->paroperand_types,
                              insn->ptm->minops, insn->ptm->maxops))
            {
              return 1;
            }
        }
d4489 1
a4489 1
            insn->parmnemonic);
d4492 1
a4492 1
            insn->mnemonic, insn->parmnemonic);
d4498 2
a4499 2
   otherwise up until terminator
   if it's a string, pass as-is; otherwise attempt substitution symbol
d4501 1
d4513 1
a4513 1
        ++ptr;
d4530 1
a4530 1
        *str = subsym_substitute (*str, 1);
d4538 9
a4546 9
        {
          if (!*term)
            {
              term = terminators;
              ++ptr;
            }
          else
            ++term;
        }
d4563 1
d4574 4
a4577 4
        {
          hash_replace (subsym_hash[i], name, value);
          return;
        }
d4585 4
a4588 2
/* Look up the substitution string replacement for the given symbol
   start with the innermost macro substituion table given and work outwards.  */
d4608 1
d4614 7
a4620 6
  char *replacement; /* current replacement for LINE */
  char *head; /* start of line */
  char *ptr; /* current examination point */
  int changed = 0; /* did we make a substitution? */
  int eval_line = 0; /* is this line a .eval/.asg statement? */
  int eval_symbol = 0; /* are we in the middle of the symbol for .eval/.asg? */
d4647 2
a4648 1
  /* If it's a macro definition, don't do substitution on the argument names.  */
d4662 7
a4668 7
        {
          ptr[1] = '\\';
          tmp = strstr (ptr + 2, "\"\"\"");
          if (tmp)
            tmp[0] = '\\';
          changed = 1;
        }
d4671 1
a4671 1
         for compatibility with older code only.  */
d4673 15
a4687 15
        {
          if (ptr[1] == '=')
            {
              ptr += 2;
              continue;
            }
          *ptr++ = '\0';
          tmp = xmalloc (strlen (head) + 2 + strlen (ptr) + 1);
          sprintf (tmp, "%s==%s", head, ptr);
          /* Continue examining after the '=='.  */
          ptr = tmp + strlen (head) + 2;
          free (replacement);
          head = replacement = tmp;
          changed = 1;
        }
d4691 1
a4691 1
        eval_symbol = 1;
d4694 1
a4694 1
         so, replace it in the input.  */
d4696 206
a4901 204
          || (!forced && is_name_beginner (current_char)))
        {
          char *name; /* symbol to be replaced */
          char *savedp = input_line_pointer;
          int c;
          char *value = NULL;
          char *tail; /* rest of line after symbol */

          /* Skip the colon.  */
          if (forced)
            ++ptr;

          name = input_line_pointer = ptr;
          c = get_symbol_end ();
          /* '?' is not normally part of a symbol, but it IS part of a local
             label.  */
          if (c == '?')
            {
              *input_line_pointer++ = c;
              c = *input_line_pointer;
              *input_line_pointer = '\0';
            }
          /* Avoid infinite recursion; if a symbol shows up a second time for
             substitution, leave it as is.  */
          if (hash_find (subsym_recurse_hash, name) == NULL)
            value = subsym_lookup (name, macro_level);
          else
            as_warn (_("%s symbol recursion stopped at "
                       "second appearance of '%s'"),
                     forced ? "Forced substitution": "Substitution", name);
          ptr = tail = input_line_pointer;
          input_line_pointer = savedp;

          /* Check for local labels; replace them with the appropriate
             substitution.  */
          if ((*name == '$' && isdigit (name[1]) && name[2] == '\0')
              || name[strlen (name) - 1] == '?')
            {
              /* Use an existing identifier for that label if, available, or
                 create a new, unique identifier.  */
              value = hash_find (local_label_hash[macro_level], name);
              if (value == NULL)
                {
                  char digit[11];
                  char *namecopy = strcpy (xmalloc (strlen (name) + 1), name);
                  value = strcpy (xmalloc (strlen (name) + sizeof (digit) + 1),
                                  name);
                  if (*value != '$')
                    value[strlen (value) - 1] = '\0';
                  sprintf (digit, ".%d", local_label_id++);
                  strcat (value, digit);
                  hash_insert (local_label_hash[macro_level], namecopy, value);
                }
              /* Indicate where to continue looking for substitutions.  */
              ptr = tail;
            }
          /* Check for built-in subsym and math functions.  */
          else if (value != NULL && *name == '$')
            {
              subsym_proc_entry *entry = (subsym_proc_entry *)value;
              math_proc_entry *math_entry = hash_find (math_hash, name);
              char *arg1, *arg2 = NULL;

              *ptr = c;
              if (entry == NULL)
                {
                  as_bad (_("Unrecognized substitution symbol function"));
                  break;
                }
              else if (*ptr != '(')
                {
                  as_bad (_("Missing '(' after substitution symbol function"));
                  break;
                }
              ++ptr;
              if (math_entry != NULL)
                {
                  float arg1, arg2 = 0;
                  volatile float fresult;

                  arg1 = (float) strtod (ptr, &ptr);
                  if (math_entry->nargs == 2)
                    {
                      if (*ptr++ != ',')
                        {
                          as_bad (_("Expecting second argument"));
                          break;
                        }
                      arg2 = (float) strtod (ptr, &ptr);
                    }
                  fresult = (*math_entry->proc) (arg1, arg2);
                  value = xmalloc (128);
                  if (math_entry->int_return)
                    sprintf (value, "%d", (int) fresult);
                  else
                    sprintf (value, "%f", fresult);
                  if (*ptr++ != ')')
                    {
                      as_bad (_("Extra junk in function call, expecting ')'"));
                      break;
                    }
                  /* Don't bother recursing; the replacement isn't a symbol.  */
                  recurse = 0;
                }
              else
                {
                  int val;
                  int arg_type[2] = {*ptr == '"',0};
                  int ismember = !strcmp (entry->name, "$ismember");
                  /* Parse one or two args, which must be a substitution
                     symbol, string or a character-string constant.  */
                  /* For all functions, a string or substitution symbol may be
                     used, with the following exceptions:
                     firstch/lastch: 2nd arg must be character constant
                     ismember: both args must be substitution symbols.  */
                  ptr = subsym_get_arg (ptr, ",)", &arg1, ismember);
                  if (!arg1)
                    break;
                  if (entry->nargs == 2)
                    {
                      if (*ptr++ != ',')
                        {
                          as_bad (_("Function expects two arguments"));
                          break;
                        }
                      /* Character constants are converted to numerics
                         by the preprocessor.  */
                      arg_type[1] = (isdigit (*ptr)) ? 2 : (*ptr == '"');
                      ptr = subsym_get_arg (ptr, ")", &arg2, ismember);
                    }
                  /* Args checking.  */
                  if ((!strcmp (entry->name, "$firstch")
                       || !strcmp (entry->name, "$lastch"))
                      && arg_type[1] != 2)
                    {
                      as_bad (_("Expecting character constant argument"));
                      break;
                    }
                  if (ismember
                      && (arg_type[0] != 0 || arg_type[1] != 0))
                    {
                      as_bad (_("Both arguments must be substitution symbols"));
                      break;
                    }
                  if (*ptr++ != ')')
                    {
                      as_bad (_("Extra junk in function call, expecting ')'"));
                      break;
                    }
                  val = (*entry->proc) (arg1, arg2);
                  value = xmalloc (64);
                  sprintf (value, "%d", val);
                }
              /* Fix things up to replace the entire expression, not just the
                 function name.  */
              tail = ptr;
              c = *tail;
            }

          if (value != NULL && !eval_symbol)
            {
              /* Replace the symbol with its string replacement and
                 continue.  Recursively replace VALUE until either no
                 substitutions are performed, or a substitution that has been
                 previously made is encountered again.

                 put the symbol into the recursion hash table so we only
                 try to replace a symbol once.  */
              if (recurse)
                {
                  hash_insert (subsym_recurse_hash, name, name);
                  value = subsym_substitute (value, macro_level > 0);
                  hash_delete (subsym_recurse_hash, name);
                }

              /* Temporarily zero-terminate where the symbol started.  */
              *name = 0;
              if (forced)
                {
                  if (c == '(')
                    {
                      /* Subscripted substitution symbol -- use just the
                         indicated portion of the string; the description
                         kinda indicates that forced substituion is not
                         supposed to be recursive, but I'm not sure.  */
                      unsigned beg, len = 1; /* default to a single char */
                      char *newval = strcpy (xmalloc (strlen (value) + 1), value);

                      savedp = input_line_pointer;
                      input_line_pointer = tail + 1;
                      beg = get_absolute_expression ();
                      if (beg < 1)
                        {
                          as_bad (_("Invalid subscript (use 1 to %d)"),
                                  strlen (value));
                          break;
                        }
                      if (*input_line_pointer == ',')
                        {
                          ++input_line_pointer;
                          len = get_absolute_expression ();
                          if (beg + len > strlen (value))
                            {
                              as_bad (_("Invalid length (use 0 to %d"),
d4903 32
a4934 32
                              break;
                            }
                        }
                      newval += beg - 1;
                      newval[len] = 0;
                      tail = input_line_pointer;
                      if (*tail++ != ')')
                        {
                          as_bad (_("Missing ')' in subscripted substitution "
                                    "symbol expression"));
                          break;
                        }
                      c = *tail;
                      input_line_pointer = savedp;

                      value = newval;
                    }
                  name[-1] = 0;
                }
              tmp = xmalloc (strlen (head) + strlen (value) +
                             strlen (tail + 1) + 2);
              strcpy (tmp, head);
              strcat (tmp, value);
              /* Make sure forced substitutions are properly terminated.  */
              if (forced)
                {
                  if (c != ':')
                    {
                      as_bad (_("Missing forced substitution terminator ':'"));
                      break;
                    }
                  ++tail;
d4936 16
a4951 16
                  /* Try to replace required whitespace
                     eliminated by the preprocessor; technically, a forced
                     substitution could come anywhere, even mid-symbol,
                     e.g. if x is "0", 'sym:x:end' should result in 'sym0end',
                     but 'sym:x: end' should result in 'sym0 end'.
                     FIXME -- this should really be fixed in the preprocessor,
                     but would require several new states;
                     KEEP_WHITE_AROUND_COLON does part of the job, but isn't
                     complete.  */
                  if ((is_part_of_name (tail[1])
                       && tail[1] != '.'
                       && tail[1] != '$')
                      || tail[1] == '\0' || tail[1] == ',' || tail[1] == '"')
                    ++tail;
                  else
                    *tail = ' ';
d4953 14
a4966 14
                }
              else
                /* Restore the character after the symbol end.  */
                *tail = c;
              strcat (tmp, tail);
              /* Continue examining after the replacement value.  */
              ptr = tmp + strlen (head) + strlen (value);
              free (replacement);
              head = replacement = tmp;
              changed = 1;
            }
          else
            *ptr = c;
        }
d4968 3
a4970 3
        {
          ++ptr;
        }
d4985 1
d5013 1
a5013 1
      char *comment = strchr (replacement,';');
d5017 2
a5018 2
         standard preprocessing equipment (maybe do_scrub_chars?)
         but for now, do a quick-and-dirty.  */
d5020 5
a5024 5
        {
          comment[0] = endc;
          comment[1] = 0;
          --comment;
        }
d5026 1
a5026 1
        comment = replacement + strlen (replacement) - 1;
d5030 5
a5034 5
        {
          comment[0] = endc;
          comment[1] = 0;
          --comment;
        }
d5038 1
a5038 1
        ++tmp;
d5063 1
a5063 1
  static int delay_slots = 0; /* how many delay slots left to fill? */
d5097 2
a5098 2
        {
          int words = build_insn (&insn);
d5100 6
a5105 6
          if (delay_slots != 0)
            {
              if (words > delay_slots)
                {
                  as_bad (_("Instruction does not fit in available delay "
                            "slots (%d-word insn, %d slots left)"),
d5107 6
a5112 6
                  delay_slots = 0;
                  return;
                }
              delay_slots -= words;
            }
        }
d5129 1
a5129 1
        *tmp = '\0';
d5132 11
a5142 11
        {
          is_parallel = 1;
          /* If the parallel part is on the same line, process it now,
             otherwise let the assembler pick up the next line for us.  */
          if (tmp != NULL)
            {
              while (isspace (tmp[2]))
                ++tmp;
              md_assemble (tmp + 2);
            }
        }
d5144 3
a5146 3
        {
          as_bad (_("Unrecognized parallel instruction '%s'"), line);
        }
d5155 6
a5160 6
          && cpu != V545LP && cpu != V546LP)
        {
          as_bad (_("Instruction '%s' requires an LP cpu version"),
                  insn.tm->name);
          return;
        }
d5162 6
a5167 6
          && amode != far_mode)
        {
          as_bad (_("Instruction '%s' requires far mode addressing"),
                  insn.tm->name);
          return;
        }
d5173 19
a5191 19
        {
          if (words > delay_slots)
            {
              as_warn (_("Instruction does not fit in available delay "
                         "slots (%d-word insn, %d slots left). "
                         "Resulting behavior is undefined."),
                       words, delay_slots);
              delay_slots = 0;
              return;
            }
          /* Branches in delay slots are not allowed.  */
          if (insn.tm->flags & FL_BMASK)
            {
              as_warn (_("Instructions which cause PC discontinuity are not "
                         "allowed in a delay slot. "
                         "Resulting behavior is undefined."));
            }
          delay_slots -= words;
        }
d5193 1
a5193 1
      /* Is this instruction the target of a repeat? */
d5195 11
a5205 11
        {
          if (insn.tm->flags & FL_NR)
            as_warn (_("'%s' is not repeatable. "
                       "Resulting behavior is undefined."),
                     insn.tm->name);
          else if (insn.is_lkaddr)
            as_warn (_("Instructions using long offset modifiers or absolute "
                       "addresses are not repeatable. "
                       "Resulting behavior is undefined."));
          repeat_slot = 0;
        }
d5209 4
a5212 4
        {
          repeat_slot = 1;
          /* FIXME -- warn if repeat_slot == 1 at EOF.  */
        }
d5215 4
a5218 4
        {
          delay_slots = 2;
          /* FIXME -- warn if delay_slots != 0 at EOF.  */
        }
d5224 1
d5240 2
a5241 1
   This lets us process parallel instructions, which span two lines. */
d5272 1
d5287 2
a5288 2
                         (valueT) sym->value,
                         &zero_address_frag);
d5296 2
a5297 2
                         (valueT) sym ? sym->value : 0,
                         &zero_address_frag);
d5305 1
d5334 1
a5334 1
  /* only one precision on the c54x */
d5364 1
a5364 1
  /* We assume that all rel->address are host byte offsets */
d5377 1
a5377 1
                name, bfd_get_reloc_code_name (code));
d5384 1
d5401 1
a5401 1
        r = BFD_RELOC_TIC54X_23;
d5403 3
a5405 3
        /* We never want to directly generate this; this is provided for
           stabs support only.  */
        r = BFD_RELOC_32;
d5415 1
d5436 1
a5436 1
         about exceeding available space.  */
d5441 2
a5442 2
                  (bfd_get_16 (stdoutput, buf) & 0xFF80) | (val & 0x7F),
                  buf);
d5444 1
a5444 1
         about exceeding available space.  */
d5449 1
a5449 1
         thus incompatible with this implementation's relocatable files.  */
d5451 2
a5452 2
                  (bfd_get_16 (stdoutput, buf) & 0xFE00) | (val >> 7),
                  buf);
d5457 2
a5458 2
                  (bfd_get_32 (stdoutput, buf) & 0xFF800000) | val,
                  buf);
d5467 1
d5492 4
a5495 1
#endif	/* OBJ_COFF */
a5496 1
/* Mostly little-endian, but longwords (4 octets) get MS word stored first.  */
d5499 3
a5501 3
  char *buf;
  valueT val;
  int n;
d5504 1
a5504 1
      number_to_chars_littleendian (buf, val, n);
d5514 2
a5515 2
  fragS *frag ATTRIBUTE_UNUSED;
  segT seg ATTRIBUTE_UNUSED;
d5522 1
d5541 4
a5544 4
          || S_IS_COMMON (sym)
          || !S_IS_DEFINED (sym))
        as_bad_where (frag->fr_file, frag->fr_line,
                      _("non-absolute value used with .space/.bes"));
d5547 8
a5554 8
        {
          as_warn (_("negative value ignored in %s"),
                   bi->type == TYPE_SPACE ? ".space" :
                   bi->type == TYPE_BES ? ".bes" : ".field");
          growth = 0;
          frag->tc_frag_data = frag->fr_fix = 0;
          return 0;
        }
d5557 28
a5584 28
        {
          /* Bit fields of 16 or larger will have already been handled.  */
          if (bit_offset != 0 && available >= size)
            {
              char *p = prev_frag->fr_literal;
              valueT value = bi->value;
              value <<= available - size;
              value |= ((unsigned short) p[1]<<8) | p[0];
              md_number_to_chars (p, value, 2);
              if ((prev_frag->tc_frag_data += size) == 16)
                prev_frag->tc_frag_data = 0;
              if (bi->sym)
                symbol_set_frag (bi->sym, prev_frag);
              /* This frag is no longer used.  */
              growth = -frag->fr_fix;
              frag->fr_fix = 0;
              frag->tc_frag_data = 0;
            }
          else
            {
              char *p = frag->fr_literal;
              valueT value = bi->value << (16 - size);
              md_number_to_chars (p, value, 2);
              if ((frag->tc_frag_data = size) == 16)
                frag->tc_frag_data = 0;
              growth = 0;
            }
        }
d5586 28
a5613 28
        {
          if (bit_offset != 0 && bit_offset < 16)
            {
              if (available >= size)
                {
                  if ((prev_frag->tc_frag_data += size) == 16)
                    prev_frag->tc_frag_data = 0;
                  if (bi->sym)
                    symbol_set_frag (bi->sym, prev_frag);
                  /* this frag is no longer used */
                  growth = -frag->fr_fix;
                  frag->fr_fix = 0;
                  frag->tc_frag_data = 0;
                  goto getout;
                }
              if (bi->type == TYPE_SPACE && bi->sym)
                symbol_set_frag (bi->sym, prev_frag);
              size -= available;
            }
          growth = (size + 15) / 16 * OCTETS_PER_BYTE - frag->fr_fix;
          for (i=0;i < growth;i++)
            frag->fr_literal[i] = 0;
          frag->fr_fix = growth;
          frag->tc_frag_data = size % 16;
          /* Make sure any BES label points to the LAST word allocated.  */
          if (bi->type == TYPE_BES && bi->sym)
            S_SET_VALUE (bi->sym, frag->fr_fix / OCTETS_PER_BYTE - 1);
        }
d5630 2
a5631 2
                     - frag->fr_address
                     - frag->fr_fix) / frag->fr_var;
d5635 2
a5636 2
                    _("attempt to .space/.bes backwards? (%ld)"),
                    (long) frag->fr_offset);
d5650 1
d5665 1
a5665 1
        --label;
d5667 4
a5670 4
        {
          as_bad (_("Invalid label '%s'"), label);
          return 0;
        }
d5683 5
a5687 5
        && (strncasecmp (rest, ".struct", 7) != 0 || !isspace (rest[7]))
        && (strncasecmp (rest, ".union", 6) != 0 || !isspace (rest[6]))
        && (strncasecmp (rest, ".macro", 6) != 0 || !isspace (rest[6]))
        && (strncasecmp (rest, ".set", 4) != 0 || !isspace (rest[4]))
        && (strncasecmp (rest, ".equ", 4) != 0 || !isspace (rest[4]));
@


1.2
log
@Fix formating
@
text
@d70 8
a77 3
#define ILLEGAL_WITHIN_STRUCT() \
do if (current_stag != NULL){ \
as_bad (_("pseudo-op illegal within .struct/.union"));return; } while (0)
d108 3
a110 3
#define OPTION_CPU_VERSION      (OPTION_ADDRESS_MODE+1)
#define OPTION_COFF_VERSION     (OPTION_CPU_VERSION+1)
#define OPTION_STDERR_TO_FILE   (OPTION_COFF_VERSION+1)
d112 1
a112 1
struct option md_longopts[] = 
d117 3
a119 1
  /*  { "mcoff-version",   required_argument,   NULL, OPTION_COFF_VERSION },*/
d153 1
a153 1
/* Keep track of local labels so we can substitute them before GAS sees them 
d253 1
a253 1
  
d282 1
a282 1
  
d305 2
a306 2
/* .asg "character-string"|character-string, symbol 
   
d366 1
a366 1
/* .eval expression, symbol 
d368 1
a368 1
   sometimes doesn't substitute symbols defined with .eval.  
d434 1
a434 1
/* .bss symbol, size [, [blocking flag] [, alignment flag] 
d445 1
a445 1
      boundary. 
d531 1
a531 1
      bss_section->flags |= SEC_BLOCK;
d547 2
a548 2
  
  /* Construct a symbol for every field contained within this structure 
d564 1
a564 1
          sym = symbol_new (name, absolute_section, 
d566 1
a566 1
                             (valueT)(base_offset + field->offset)), 
d573 2
a574 1
          char *replacement = xmalloc (strlen (name) + strlen (stag->name) + 2);
d585 2
a586 2
        stag_add_field_symbols (field->stag, name, 
                                field->offset, 
d604 1
a604 1
  sfield->name = strcpy (xmalloc (strlen (name)+1), name);
d610 7
a616 6
  else {
    struct stag_field *sf = parent->field;
    while (sf->next != NULL)
      sf = sf->next;
    sf->next = sfield;
  }
d620 2
a621 2
      symbolS *sym = symbol_new (name, absolute_section, 
                                 (valueT)offset, &zero_address_frag);
d654 1
a654 1
      if (!is_end_of_line[(int)*input_line_pointer])
d663 1
a663 1
      current_stag->inner = (struct stag *)xmalloc (sizeof (struct stag));
d671 1
a671 1
  else 
d673 1
a673 1
      current_stag = (struct stag *)xmalloc (sizeof (struct stag));
d685 1
a685 1
                                      (valueT)abs_section_offset,
d693 1
a693 1
                                      (valueT)abs_section_offset,
d705 1
a705 1
/* [LABEL] .endstruct 
d712 1
a712 1
  const char *path = 
d714 1
a714 1
  
d717 1
a717 1
      as_bad (_(".end%s without preceding .%s"), 
d749 1
a749 1
      stag_add_field_symbols (current_stag, path, 
d760 1
a760 1
                      S_GET_VALUE (current_stag->inner->sym), 
d769 1
a769 1
   label. 
d774 1
a774 1
  int ignore ATTRIBUTE_UNUSED;
d778 1
a778 1
  struct stag *stag = (struct stag *)hash_find (stag_hash, name);
d797 3
a799 2
      char label[strlen (S_GET_NAME (line_label))+1];
      strcpy (label,  S_GET_NAME (line_label));
d801 2
a802 2
        stag_add_field (current_stag, label, 
                        abs_section_offset - S_GET_VALUE (current_stag->sym), 
d813 1
a813 1
          stag_add_field_symbols (stag, S_GET_NAME (sym), 
d817 1
a817 1
    
d840 1
a840 1
  if (!is_end_of_line[(int)*input_line_pointer])
d879 2
a880 1
              size = 2; count = 1;
d884 2
a885 1
              size = 1; count = 1;
d920 2
a921 2
      stag_add_field (current_stag, fake, 
                      abs_section_offset - S_GET_VALUE (current_stag->sym), 
d928 2
a929 2
      stag_add_field (current_stag, label, 
                      abs_section_offset - S_GET_VALUE (current_stag->sym), 
d936 1
a936 1
      if (current_stag->size < (unsigned)size * count)
d941 1
a941 1
      abs_section_offset += (unsigned)size * count;
d949 1
a949 1
static void 
d1033 1
a1033 1
                 require relocation.  */ 
d1039 1
a1039 1
          if (exp.X_op != O_constant 
d1044 1
a1044 1
                 relocations, but I don't think the latest tools do at all 
d1072 1
a1072 1
   These all identify global symbols. 
d1082 1
a1082 1
   global, def and ref all have symbol storage classes of C_EXT.  
d1110 1
a1110 1
	  if (is_end_of_line[(int)*input_line_pointer])
d1122 2
a1123 2
  const char *key;
  PTR value ATTRIBUTE_UNUSED;
d1130 1
a1130 1
static void 
d1132 1
a1132 1
  int ignored ATTRIBUTE_UNUSED;
d1142 1
a1142 1
   make sure local labels get cleared when changing sections 
d1168 1
a1168 1
          name = strcpy (xmalloc (len+10), name);
d1170 1
a1170 1
      else 
d1175 1
a1175 1
          name = strcpy (xmalloc (len+10), name);
d1199 1
a1199 1
/* [symbol] .space space_in_bits 
d1201 1
a1201 1
   BES puts the symbol at the *last* word allocated 
d1236 1
a1236 1
      p = frag_var (rs_machine_dependent, 
d1238 1
a1238 1
                    make_expr_symbol (&exp), (offsetT) 0, 
d1255 1
a1255 1
             allocated; just point the label to the right place.  */ 
d1290 1
a1290 1
  
d1300 1
a1300 1
  
d1302 2
a1303 2
    p = frag_var (rs_fill, 1, 1, 
                  (relax_substateT) 0, (symbolS *) 0, 
d1313 1
a1313 1
      S_SET_VALUE (label, frag_now_fix ()-1);
d1315 1
a1315 1
  
d1324 2
a1325 2
/* [symbol] .usect "section-name", size-in-words 
                   [, [blocking-flag] [, alignment-flag]] 
d1333 1
a1333 1
static void 
d1335 1
a1335 1
  int x ATTRIBUTE_UNUSED;
d1414 1
a1414 1
  p = frag_var (rs_fill, 1, 1, 
d1428 1
a1428 1
} 
d1435 1
a1435 1
  
d1460 1
a1460 1
                                    (valueT)1, &zero_address_frag);
d1466 1
a1466 1
/* .version cpu-version 
d1480 1
a1480 1
static void 
d1482 1
a1482 1
  int x ATTRIBUTE_UNUSED;
d1493 1
a1493 1
  while (!is_end_of_line[(int)*input_line_pointer])
d1497 1
a1497 1
  
d1532 1
a1532 1
  
d1548 1
a1548 1
/* The argument is capitalized if it should be zero-terminated 
d1581 2
a1582 2
            FRAG_APPEND_1_CHAR (value&0xFF);
            FRAG_APPEND_1_CHAR ((value>>8)&0xFF);
d1642 1
a1642 1
  int arg ATTRIBUTE_UNUSED;
d1654 1
a1654 1
  if (!is_end_of_line[(int)*input_line_pointer])
d1681 1
a1681 1
  int ignore ATTRIBUTE_UNUSED;
d1728 1
a1728 1
      if (value != (valueT)exp.X_add_number)
d1770 1
a1770 1
              p = alloc_frag == frag_now ? 
d1785 1
a1785 1
            value |= ((unsigned short)p[1]<<8) | p[0];
d1800 1
a1800 1
  segT seg;
d1805 1
a1805 1
/* .clink ["section name"] 
d1813 1
a1813 1
  int ignored ATTRIBUTE_UNUSED;
d1859 1
a1859 1
  int dot;
d1863 1
a1863 1
  
d1868 1
a1868 1
      
d1870 1
a1870 1
      dir = strcpy (xmalloc (strlen (curfile)+1), curfile);
d1891 1
a1891 1
/* .include "filename" | filename 
d1894 1
a1894 1
   FIXME 'include' file should be omitted from any output listing, 
d1903 1
a1903 1
  int ignored ATTRIBUTE_UNUSED;
d1911 1
a1911 1
  
d1922 1
a1922 1
      while (!is_end_of_line[(int)*input_line_pointer])
d1926 1
a1926 1
      filename = strcpy (xmalloc (strlen (filename)+1), filename);
d1960 1
a1960 1
      while (! is_end_of_line[(int)*input_line_pointer])
d1984 1
a1984 1
/* .label <symbol> 
d1993 1
a1993 1
  int ignored ATTRIBUTE_UNUSED;
d2014 1
a2014 1
  int ignored ATTRIBUTE_UNUSED;
d2020 1
a2020 1
  for (sym = (symbol *)mmregs; sym->name; sym++)
d2037 1
a2037 1
  if (!is_end_of_line[(int)*input_line_pointer])
d2046 1
a2046 1
  int ignore ATTRIBUTE_UNUSED;
d2055 1
a2055 1
  int ignore ATTRIBUTE_UNUSED;
d2062 1
a2062 1
  if (!is_end_of_line[(int)*input_line_pointer])
d2074 1
a2074 1
  int mode;
d2079 2
a2080 2
      symbolS *symbolP = symbol_new ("__allow_far", absolute_section, 
                                    (valueT)1, &zero_address_frag);
d2089 1
a2089 1
  int mode;
d2091 1
a2091 1
  if (assembly_begun && amode != (unsigned)mode)
d2112 1
a2112 1
  int ignore ATTRIBUTE_UNUSED;
d2122 1
a2122 1
      
d2132 1
a2132 1
          name = xmalloc (strlen (section_name)+1);
d2153 1
a2153 1
      if (!is_end_of_line[(int)c])
d2161 1
a2161 1
   symbol .equ value 
d2167 1
a2167 1
  int ignore ATTRIBUTE_UNUSED;
d2217 1
a2217 1
/* .var SYM[,...,SYMN] 
d2221 1
a2221 1
  int ignore ATTRIBUTE_UNUSED;
d2235 1
a2235 1
  do 
d2246 1
a2246 1
      name = strcpy (xmalloc (strlen (name)+1), name);
d2252 1
a2252 1
          if (is_end_of_line[(int)*input_line_pointer])
d2261 1
a2261 1
/* .mlib <macro library filename> 
d2269 1
a2269 1
  int ignore ATTRIBUTE_UNUSED;
d2288 1
a2288 1
      while (! is_end_of_line[(int)*input_line_pointer]
d2302 1
a2302 1
  for (i=0;i < include_dir_count; i++)
d2313 1
a2313 1
  }
d2322 1
a2322 1
     running for a very long time, it really doesn't matter...  */ 
d2354 1
a2354 1
      /* Write to a temporary file, then use s_include to include it 
d2357 2
a2358 2
      fwrite ((void *)buf, size, 1, ftmp);
      if (buf[size-1] != '\n')
d2367 1
a2367 1
const pseudo_typeS md_pseudo_table[] = 
d2370 2
a2371 2
  { "align", tic54x_align_words, 128 }, 
  { "even", tic54x_align_words, 2 }, 
d2391 4
a2394 2
  /*{ "end",     s_end,                   0 }, */
  { "far_mode", tic54x_address_mode, far_mode }, 
d2407 2
a2408 2
  { "if", s_if, (int)O_ne },
  { "elseif", s_elseif, (int)O_ne },
d2416 18
a2433 16
  { "length",   s_ignore, 0 }, 
  { "width",    s_ignore, 0 }, 
  /*{ "list",     listing_list,      1 }, */
  /*{ "nolist",   listing_list,      0 }, */
  { "long", tic54x_cons, 'l' }, 
  { "ulong", tic54x_cons, 'L' }, 
  { "xlong", tic54x_cons, 'x' }, 
  { "loop", tic54x_loop, 1024 }, 
  { "break", tic54x_break, 0 }, 
  { "endloop", tic54x_endloop, 0 }, 
  { "mlib", tic54x_mlib, 0 }, 
  { "mlist",     s_ignore, 0 }, 
  { "mnolist",     s_ignore, 0 }, 
  { "mmregs", tic54x_mmregs, 0 }, 
  { "newblock", tic54x_clear_local_labels, 0 }, 
  { "option",     s_ignore, 0 }, 
d2435 11
a2445 9
  /*{ "page",     listing_eject,      0 }, */
  { "sblock", tic54x_sblock, 0 }, 
  { "sect", tic54x_sect, '*' }, 
  { "set", tic54x_set, 0 }, 
  { "equ", tic54x_set, 0 }, 
  { "space", tic54x_space, 0 }, 
  { "bes", tic54x_space, 1 }, 
  { "sslist", tic54x_sslist, 1 }, 
  { "ssnolist", tic54x_sslist, 0 }, 
d2448 13
a2460 11
  { "struct", tic54x_struct, 0 }, 
  { "tag", tic54x_tag, 0 }, 
  { "endstruct", tic54x_endstruct, 0 }, 
  { "tab",     s_ignore, 0 }, 
  { "text", tic54x_sect, 't' }, 
  /*{ "title",     listing_title,      0 }, */
  { "union", tic54x_struct, 1 }, 
  { "endunion", tic54x_endstruct, 1 }, 
  { "usect", tic54x_usect, 0 }, 
  { "var", tic54x_var, 0 }, 
  { "version", tic54x_version, 0 }, 
d2466 1
a2466 1
static const char *optypes[] = 
d2469 3
a2471 3
  "Sind", "xpmad", "xpmad+", "MMRX", "MMRY", 
  "SRC1", "SRC", "RND", "DST", 
  "ARX", 
d2473 1
a2473 1
  "B", "A", "lk", "TS", "k8", "16", "BITC", "CC", "CC2", "CC3", "123", "031", 
d2481 2
a2482 2
  int c;
  char *arg;
d2524 1
a2524 1
/* Create a "local" substitution string hash table for a new macro level 
d2528 1
a2528 1
void 
d2556 1
a2556 1
  macro = (struct macro_struct *)info;
d2599 1
a2599 1
/* Return the index of the first occurence of B in A, or zero if none 
d2608 1
a2608 1
  
d2657 1
a2657 1
  ptr = elem = xmalloc (strlen (listv)+1);
d2667 1
a2667 1
  
d2680 2
a2681 2
  char *a;
  char *ignore ATTRIBUTE_UNUSED;
d2691 1
a2691 1
      switch (toupper (a[len-1]))
d2720 2
a2721 2
  char *a;
  char *ignore ATTRIBUTE_UNUSED;
d2739 2
a2740 2
  char *a;
  char *ignore ATTRIBUTE_UNUSED;
d2752 2
a2753 2
  char *name;
  char *ignore ATTRIBUTE_UNUSED;
d2755 1
a2755 1
  struct stag *stag = (struct stag *)hash_find (stag_hash, name);
d2770 2
a2771 2
  char *stag_name ATTRIBUTE_UNUSED;
  char *ignore ATTRIBUTE_UNUSED;
d2778 2
a2779 2
  float arg1;
  float ignore ATTRIBUTE_UNUSED;
d2781 1
a2781 1
  return (float)ceil (arg1);
d2786 2
a2787 2
  float arg1;
  float ignore ATTRIBUTE_UNUSED;
d2789 1
a2789 1
  return (int)arg1;
d2794 2
a2795 2
  float arg1;
  float ignore ATTRIBUTE_UNUSED;
d2797 1
a2797 1
  return (float)floor (arg1);
d2803 1
a2803 1
  return (int)arg1 % (int)arg2;
d2808 2
a2809 2
  float arg1;
  float ignore ATTRIBUTE_UNUSED;
d2811 1
a2811 1
  return ((float)((int)arg1)) == arg1;
d2816 2
a2817 2
  float arg1;
  float ignore ATTRIBUTE_UNUSED;
d2819 1
a2819 1
  return arg1 > 0 ? (int)(arg1 + 0.5) : (int)(arg1 - 0.5);
d2824 2
a2825 2
  float arg1;
  float ignore ATTRIBUTE_UNUSED;
d2832 2
a2833 2
  float arg1;
  float ignore ATTRIBUTE_UNUSED;
d2835 1
a2835 1
  return (int)arg1;
d2840 2
a2841 2
  float arg1;
  float ignore ATTRIBUTE_UNUSED;
d2843 1
a2843 1
  return (float)acos (arg1);
d2848 2
a2849 2
  float arg1;
  float ignore ATTRIBUTE_UNUSED;
d2851 1
a2851 1
  return (float)asin (arg1);
d2856 2
a2857 2
  float arg1;
  float ignore ATTRIBUTE_UNUSED;
d2859 1
a2859 1
  return (float)atan (arg1);
d2863 1
a2863 1
math_atan2(float arg1, float arg2)
d2865 1
a2865 1
  return (float)atan2 (arg1, arg2);
d2870 2
a2871 2
  float arg1;
  float ignore ATTRIBUTE_UNUSED;
d2873 1
a2873 1
  return (float)cosh (arg1);
d2878 2
a2879 2
  float arg1;
  float ignore ATTRIBUTE_UNUSED;
d2881 1
a2881 1
  return (float)cos (arg1);
d2886 2
a2887 2
  float arg1;
  float ignore ATTRIBUTE_UNUSED;
d2889 1
a2889 1
  return (float)arg1;
d2894 2
a2895 2
  float arg1;
  float ignore ATTRIBUTE_UNUSED;
d2897 1
a2897 1
  return (float)exp (arg1);
d2902 2
a2903 2
  float arg1;
  float ignore ATTRIBUTE_UNUSED;
d2905 1
a2905 1
  return (float)fabs (arg1);
d2912 1
a2912 1
  return arg1 * (float)pow (2.0, arg2);
d2917 2
a2918 2
  float arg1;
  float ignore ATTRIBUTE_UNUSED;
d2920 1
a2920 1
  return (float)log10 (arg1);
d2925 2
a2926 2
  float arg1;
  float ignore ATTRIBUTE_UNUSED;
d2928 1
a2928 1
  return (float)log (arg1);
d2946 1
a2946 1
  return (float)pow (arg1, arg2);
d2951 2
a2952 2
  float arg1;
  float ignore ATTRIBUTE_UNUSED;
d2954 1
a2954 1
  return (float)sin (arg1);
d2959 2
a2960 2
  float arg1;
  float ignore ATTRIBUTE_UNUSED;
d2962 1
a2962 1
  return (float)sinh (arg1);
d2967 2
a2968 2
  float arg1;
  float ignore ATTRIBUTE_UNUSED;
d2970 1
a2970 1
  return (float)sqrt (arg1);
d2975 2
a2976 2
  float arg1;
  float ignore ATTRIBUTE_UNUSED;
d2978 1
a2978 1
  return (float)tan (arg1);
d2983 2
a2984 2
  float arg1;
  float ignore ATTRIBUTE_UNUSED;
d2986 1
a2986 1
  return (float)tanh (arg1);
d2990 1
a2990 1
typedef struct 
d2993 1
a2993 1
  int (*proc)(char *, char *);
d3017 1
a3017 1
  float (*proc)(float, float);
d3033 1
a3033 1
  { "$atan2", math_atan2, 2, 0 }, 
d3077 9
a3085 7
      do {
        char *next = strchr (tmp, ';');
        if (next)
          *next++ = '\0';
        add_include_dir (tmp);
        tmp = next;
      } while (tmp != NULL);
d3089 1
a3089 1
  for (opcode=(template *)tic54x_optab; opcode->name; opcode++)
d3093 1
a3093 1
      hash_err = hash_insert (op_hash, opcode->name, (char *)opcode);
d3095 1
a3095 1
        as_fatal ("Internal Error: Can't hash %s: %s", 
d3099 3
a3101 1
  for (paropcode=(partemplate *)tic54x_paroptab; paropcode->name; paropcode++)
d3105 1
a3105 1
      hash_err = hash_insert (parop_hash, paropcode->name, (char *)paropcode);
d3107 1
a3107 1
        as_fatal ("Internal Error: Can't hash %s: %s", 
d3111 1
a3111 1
  for (sym = (symbol *)regs; sym->name; sym++)
d3115 1
a3115 1
                                     (valueT)sym->value, &zero_address_frag);
d3118 1
a3118 1
      hash_err = hash_insert (reg_hash, sym->name, (char *)sym);
d3120 2
a3121 2
  for (sym = (symbol *)mmregs; sym->name; sym++)
    hash_err = hash_insert (reg_hash, sym->name, (char *)sym);
d3123 1
a3123 1
  for (sym = (symbol *)mmregs; sym->name; sym++)
d3125 1
a3125 1
      hash_err = hash_insert (mmreg_hash, sym->name, (char *)sym);
d3128 1
a3128 1
  for (sym = (symbol *)condition_codes; sym->name; sym++)
d3130 1
a3130 1
      hash_err = hash_insert (cc_hash, sym->name, (char *)sym);
d3133 1
a3133 1
  for (sym = (symbol *)cc2_codes; sym->name; sym++)
d3135 1
a3135 1
      hash_err = hash_insert (cc2_hash, sym->name, (char *)sym);
d3138 1
a3138 1
  for (sym = (symbol *)cc3_codes; sym->name; sym++)
d3140 1
a3140 1
      hash_err = hash_insert (cc3_hash, sym->name, (char *)sym);
d3143 1
a3143 1
  for (sym = (symbol *)status_bits; sym->name; sym++)
d3145 1
a3145 1
      hash_err = hash_insert (sbit_hash, sym->name, (char *)sym);
d3148 1
a3148 1
  for (symname = (char **)misc_symbols; *symname; symname++)
d3158 2
a3159 2
      hash_err = hash_insert (subsym_hash[0], subsym_proc->name, 
                              (char *)subsym_proc);
d3167 1
a3167 1
                              (char *)math_proc);
d3169 1
a3169 1
                              (char *)math_proc);
d3197 1
a3197 1
  int using_default_dst;            /* do we need to explicitly set an 
d3211 1
a3211 1
static int operands_match (tic54x_insn *, struct opstruct *, int, 
d3219 1
a3219 1
  return strcasecmp (operand->buf, "a") == 0 
d3235 1
a3235 1
  while (numexp < MAX_OPERANDS && !is_end_of_line[(int)*lptr])
d3269 1
a3269 1
          while (len > 0 && isspace (operands[numexp].buf[len-1]))
d3274 1
a3274 1
      else 
d3295 1
a3295 1
  if (!is_end_of_line[(int)*lptr])
d3302 1
a3302 1
  for (i=0;i < numexp;i++)
d3357 1
a3357 1
  return  *operand->buf == '#';
d3387 1
a3387 1
      
d3392 1
a3392 1
        strcasecmp (tmp, "+") == 0 || 
d3409 2
a3410 2
  struct opstruct *operand;
  enum optype type;
d3447 1
a3447 1
      return strncasecmp ("ar", operand->buf, 2) == 0 
d3456 1
a3456 1
      return hash_find (cc3_hash, operand->buf) != 0 
d3481 2
a3482 2
      return is_immediate (operand) 
        && operand->exp.X_op == O_constant 
d3487 1
a3487 1
      /* Allow anything; assumes opcodes are ordered with Smem operands 
d3496 1
a3496 1
      return strcasecmp ("t", operand->buf) == 0 || 
d3515 5
a3519 5
  tic54x_insn *insn;
  struct opstruct *operands;
  int opcount;
  const enum optype *refoptype;
  int minops, maxops;
d3572 1
a3572 1
/* 16-bit direct memory address 
d3578 1
a3578 1
   XPC_CODE: 
d3584 3
a3586 3
  tic54x_insn *insn;
  struct opstruct *operand;
  int xpc_code;
d3591 1
a3591 1
  if (is_indirect (operand) && operand->buf[strlen (operand->buf)-1] != ')')
d3647 2
a3648 2
  tic54x_insn *insn;
  struct opstruct *operand;
d3668 2
a3669 2
  tic54x_insn *insn;
  struct opstruct *operand;
d3682 1
a3682 1
      
d3702 1
a3702 1
      arf = (toupper (operand->buf[1]) == 'A' ? 
d3704 2
a3705 2
      
      if (operand->buf[1] == '+') 
d3712 1
a3712 1
      else if (operand->buf[4] == '\0') 
d3729 1
a3729 1
          as_bad (_("Unrecognized indirect address format \"%s\""), 
d3733 1
a3733 1
    }      
d3735 1
a3735 1
  insn->opcode[0].word |= 0x80 | (mod<<3) | arf;
d3742 4
a3745 4
  tic54x_insn *insn;
  struct opstruct *operand;
  int which, min, max;
  unsigned short mask;
d3757 1
a3757 1
        integer = (short)parse;
d3766 1
a3766 1
      as_bad (_("Operand '%s' out of range (%d <= x <= %d)"), 
d3773 1
a3773 1
          insn->opcode[which].word |= 
d3779 2
a3780 2
          bfd_reloc_code_real_type rtype = 
            (mask == 0x1FF ? BFD_RELOC_TIC54X_PARTMS9 : 
d3801 2
a3802 2
  tic54x_insn *insn;
  struct opstruct *operand;
d3804 1
a3804 1
  symbol *cc = (symbol *)hash_find (cc_hash, operand->buf);
d3824 1
a3824 1
          as_bad (_("Condition \"%s\" does not match preceding group"), 
d3833 1
a3833 1
                        "a preceding condition"), 
d3863 2
a3864 2
  tic54x_insn *insn;
  struct opstruct *operand;
d3866 1
a3866 1
  symbol *cc3 = (symbol *)hash_find (cc3_hash, operand->buf);
d3880 2
a3881 2
  tic54x_insn *insn;
  struct opstruct *operand;
d3895 2
a3896 2
  tic54x_insn *insn;
  struct opstruct *operand;
d3898 1
a3898 1
  symbol *cc2 = (symbol *)hash_find (cc2_hash, operand->buf);
d3910 3
a3912 3
  tic54x_insn *insn;
  enum optype type;
  struct opstruct *operand;
d3967 9
a3975 9
    {
      int mod = (operand->buf[4] == '\0' ? 0 : /* *arx */
                 operand->buf[4] == '-' ? 1 : /* *arx- */
                 operand->buf[5] == '\0' ? 2 : 3); /* *arx+, *arx+0% */
      int arf = operand->buf[3] - '0' - 2;
      int code = (mod << 2)|arf;
      insn->opcode[0].word |= (code << (type == OP_Xmem ? 4 : 0));
      return 1;
    }
d3995 19
a4013 15
    {
      int value = operand->exp.X_add_number;
      if (type == OP_MMR)
        insn->opcode[0].word |= value;
      else {
        if (value < 16 || value > 24)
          {
            as_bad (_("Memory mapped register \"%s\" out of range"), 
                    operand->buf);
            return 0;
          }
        if (type == OP_MMRX)
          insn->opcode[0].word |= (value - 16) << 4;
        else
          insn->opcode[0].word |= (value - 16);
a4014 2
      return 1;
    }
d4019 1
a4019 1
      return encode_integer (insn, operand, ext + insn->is_lkaddr, 
d4022 1
a4022 1
      return encode_integer (insn, operand, ext + insn->is_lkaddr, 
d4038 12
a4049 12
    {
      int value = operand->exp.X_add_number;
      int code;
      if (value < 1 || value > 3)
        {
          as_bad (_("Invalid operand (use 1, 2, or 3)"));
          return 0;
        }
      code = value == 1 ? 0 : value == 2 ? 0x2 : 0x1;
      insn->opcode[0].word |= (code << 8);
      return 1;
    }
d4055 1
a4055 1
      return encode_integer (insn, operand, 1 + insn->is_lkaddr, 
d4058 27
a4084 27
    {
      symbol *sbit = (symbol *)hash_find (sbit_hash, operand->buf);
      int value = is_absolute (operand) ? 
        operand->exp.X_add_number : (sbit ? sbit->value : -1);
      int reg = 0;
      
      if (insn->opcount == 1)
        {
          if (!sbit)
            {
              as_bad (_("A status register or status bit name is required"));
              return 0;
            }
          /* Guess the register based on the status bit; "ovb" is the last
             status bit defined for st0.  */
          if (sbit > (symbol *)hash_find (sbit_hash, "ovb"))
            reg = 1;
        }
      if (value == -1)
        {
          as_bad (_("Unrecognized status bit \"%s\""), operand->buf);
          return 0;
        }
      insn->opcode[0].word |= value;
      insn->opcode[0].word |= (reg << 9);
      return 1;
    }
d4089 1
a4089 1
          insn->opcode[0].word |= ((unsigned short)(operand->buf[2] - '0'))<<9;
d4093 1
a4093 1
               && (operand->exp.X_add_number == 0 
d4109 1
a4109 1
      if (operand->exp.X_add_number != 1 
d4135 1
a4135 1
  tic54x_insn *insn;
d4138 2
a4139 1
  for (i=0;i < insn->words;i++)
d4141 1
a4141 1
      int size = (insn->opcode[i].unresolved 
d4146 1
a4146 1
        md_number_to_chars (p, (valueT)insn->opcode[i].word, 2);
d4148 2
a4149 2
        md_number_to_chars (p, (valueT)insn->opcode[i].word << 16, 4);
        
d4157 1
a4157 1
/* Convert the operand strings into appropriate opcode values 
d4161 1
a4161 1
  tic54x_insn *insn;
d4168 1
a4168 1
      for (i=0; i < insn->opcount; i++)
d4183 1
a4183 1
  insn->words = 
d4188 1
a4188 1
      insn->opcode[1 + insn->is_lkaddr].word = insn->tm->opcode2;
d4210 1
a4210 1
  tic54x_insn *insn;
d4212 1
a4212 1
  /* Optimize some instructions, helping out the brain-dead programmer.  */ 
d4220 1
a4220 1
                     insn->operands[insn->opcount-1].buf) == 0)
d4226 1
a4226 1
      
d4234 1
a4234 1
           is_type (&insn->operands[1], OP_SHIFT) && 
d4278 1
a4278 1
                     insn->operands[insn->opcount-1].buf) == 0)
d4284 1
a4284 1
      
d4303 2
a4304 2
  tic54x_insn *insn;
  char *line;
d4306 1
a4306 1
  insn->tm = (template *)hash_find (op_hash, insn->mnemonic);
d4315 1
a4315 1
      return 0;
d4323 1
a4323 1
                          insn->tm->operand_types, 
d4329 2
a4330 2
              insn->tm = (template *)hash_find (op_hash, 
                                                insn->mnemonic);
d4338 2
a4339 2
  as_bad (_("Unrecognized operand list '%s' for instruction '%s'"), 
            line, insn->mnemonic);
d4350 1
a4350 1
  char *next_line;
d4362 2
a4363 2
  tic54x_insn *insn;
  char *line;
d4365 1
a4365 1
  insn->ptm = (partemplate *)hash_find (parop_hash, insn->mnemonic);
d4368 1
a4368 1
      as_bad (_("Unrecognized parallel instruction \"%s\""), 
d4374 1
a4374 1
                                       insn->mnemonic) == 0)
d4379 1
a4379 1
      if (insn->opcount == 2 && 
d4398 1
a4398 1
  
d4408 1
a4408 1
              operands_match (insn, insn->paroperands, 
d4429 1
a4429 1
   otherwise up until terminator 
d4483 1
a4483 1
          *str = value;
d4500 1
a4500 1
  for (i=macro_level;i > 0;i--)
d4514 1
a4514 1
/* Look up the substitution string replacement for the given symbol 
d4526 1
a4526 1
  return subsym_lookup (name, nest_level-1);
d4530 1
a4530 1
   return the argument if no substitution was done 
d4560 2
a4561 2
  if (strstr (line, ".if") 
      || strstr (line, ".elseif") 
d4570 1
a4570 1
      eval_line = 1;
d4576 1
a4576 1
  while (!is_end_of_line[(int)*ptr])
d4582 1
a4582 1
          eval_end = strrchr (ptr, ',');
d4588 1
a4588 1
          tmp = strstr (ptr+2, "\"\"\"");
d4596 1
a4596 1
      if (line_conditional && current_char == '=') 
d4600 1
a4600 1
              ptr += 2; 
d4627 1
a4627 1
          
d4635 1
a4635 1
             label.  */ 
d4648 1
a4648 1
                       "second appearance of '%s'"), 
d4655 2
a4656 2
          if ((*name == '$' && isdigit (name[1]) && name[2] == '\0') 
              || name[strlen (name)-1] == '?')
d4668 1
a4668 1
                    value[strlen (value)-1] = '\0';
d4700 1
a4700 1
                  arg1 = (float)strtod (ptr, &ptr);
d4708 1
a4708 1
                      arg2 = (float)strtod (ptr, &ptr);
d4710 1
a4710 1
                  fresult = (*math_entry->proc)(arg1, arg2);
d4713 1
a4713 1
                    sprintf (value, "%d", (int)fresult);
d4752 1
a4752 1
                       || !strcmp (entry->name, "$lastch")) 
d4769 1
a4769 1
                  val = (*entry->proc)(arg1, arg2);
d4796 1
a4796 1
              *name = 0; 
d4806 1
a4806 1
                      char *newval = strcpy (xmalloc (strlen (value)+1), value);
d4813 1
a4813 1
                          as_bad (_("Invalid subscript (use 1 to %d)"), 
d4824 1
a4824 1
                                     strlen (value) - beg);
d4844 2
a4845 2
              tmp = xmalloc (strlen (head) + strlen (value) + 
                             strlen (tail+1) + 2);
d4858 1
a4858 1
                  /* Try to replace required whitespace 
d4869 1
a4869 1
                       && tail[1] != '$') 
d4901 1
a4901 1
/* We use this to handle substitution symbols 
d4915 1
a4915 1
  while (!is_end_of_line[(int)*endp++])
d4935 1
a4935 1
      char endc = replacement[strlen (replacement)-1];
d4946 1
a4946 1
      else 
d4981 1
a4981 1
  char *line;
d5026 2
a5027 2
                            "slots (%d-word insn, %d slots left)"), 
                            words, delay_slots);
d5042 1
a5042 1
  
d5061 1
a5061 1
              md_assemble (tmp+2);
d5075 1
a5075 1
      if ((insn.tm->flags & FL_LP) 
d5082 1
a5082 1
      if ((insn.tm->flags & FL_FAR) 
d5099 1
a5099 1
                         "Resulting behavior is undefined."), 
d5113 1
a5113 1
      
d5119 1
a5119 1
                       "Resulting behavior is undefined."), 
d5127 1
a5127 1
      
d5159 1
a5159 1
   this function returns true if a | is found in a line. 
d5176 4
a5179 2
  /*static int local_label_count = 0;*/
  /*const char *name = S_GET_NAME (sym);*/
d5182 1
a5182 1
     same thing as line_label... 
d5198 5
a5202 5
  if ((sym = (symbol *)hash_find (cc_hash, name)) != NULL ||
      (sym = (symbol *)hash_find (cc2_hash, name)) != NULL ||
      (sym = (symbol *)hash_find (cc3_hash, name)) != NULL ||
      (sym = (symbol *)hash_find (misc_symbol_hash, name)) != NULL ||
      (sym = (symbol *)hash_find (sbit_hash, name)) != NULL)
d5204 1
a5204 1
      return symbol_new (name, reg_section, 
d5209 2
a5210 2
  if ((sym = (symbol *)hash_find (reg_hash, name)) != NULL ||
      (sym = (symbol *)hash_find (mmreg_hash, name)) != NULL ||
d5213 1
a5213 1
      return symbol_new (name, reg_section, 
d5229 2
a5230 1
  symbol *sym = (symbol *)hash_find (mmreg_hash, name);
d5258 2
a5259 1
  /* Target data is little-endian, but floats are stored big-"word"ian.  ugh.  */
d5262 1
a5262 1
      md_number_to_chars (literalP, (long)(*word++), sizeof (LITTLENUM_TYPE));
d5279 1
a5279 1
  rel->sym_ptr_ptr = (asymbol **)xmalloc (sizeof (asymbol *));
d5293 1
a5293 1
      as_fatal ("Cannot generate relocation type for symbol %s, code %s", 
d5319 1
a5319 1
        /* We never want to directly generate this; this is provided for 
d5327 1
a5327 1
/* Attempt to simplify or even eliminate a fixup.  
d5364 3
a5366 3
         thus incompatible with this implementation's relocatable files.  */ 
      bfd_put_16 (stdoutput, 
                  (bfd_get_16 (stdoutput, buf) & 0xFE00) | (val >> 7), 
d5380 1
a5380 1
/* This is our chance to record section alignment 
d5419 2
a5420 2
      number_to_chars_littleendian (buf, val>>16, 2);
      number_to_chars_littleendian (buf+2, val&0xFFFF, 2);
d5424 1
a5424 1
int 
d5434 1
a5434 1
int 
d5436 2
a5437 2
  fragS *frag;
  long stretch ATTRIBUTE_UNUSED;
d5445 1
a5445 1
      struct bit_info *bi = (struct bit_info *)frag->fr_opcode;
d5475 1
a5475 1
              value |= ((unsigned short)p[1]<<8) | p[0];
d5528 1
a5528 1
      free ((void *)bi);
d5535 3
a5537 3
  bfd *abfd ATTRIBUTE_UNUSED;
  segT seg ATTRIBUTE_UNUSED;
  fragS *frag;
d5540 1
a5540 1
  frag->fr_offset = (frag->fr_next->fr_address 
d5558 1
a5558 1
   label. 
d5563 2
a5564 2
  int c;
  char *rest;
d5574 1
a5574 1
      while (!is_end_of_line[(int)label[-1]])
d5583 1
a5583 1
  if (is_end_of_line[(int)c])
@


1.1
log
@TI C54x target.
@
text
@d22 1
a22 2
/*
   Texas Instruments TMS320C54X machine specific gas.
d42 1
a42 2
   TI sets labels to be data type 4 (T_INT); GAS uses T_NULL
 */
d56 1
a56 1
#define MAX_LINE 256 /* lines longer than this are truncated by TI's asm */
d60 1
a60 1
const char line_separator_chars[] = "";/* not permitted */
d62 4
a65 3
/* characters which indicate that this is a floating point constant */
const char FLT_CHARS[] = "fF"; 
/* Characters that can be used to separate mantissa from exp in FP nums */
d68 2
a69 2
/* only word (et al.), align, or conditionals are allowed within
   .struct/.union */
d76 1
a76 1
  FILE *stream;
d81 3
a83 1
  /*  fprintf (stream, _("-mcoff-version={0|1|2}    Select COFF version\n"));*/
d89 3
a91 1
enum cpu_version { 
d96 3
a98 2
enum address_mode {
  c_mode,   /* 16-bit addresses */                         
d120 1
a120 1
static int assembly_begun = 0; 
d128 1
a128 2
   extended addressing only.  We include it for compatibility.
 */
d130 1
a130 1
static enum cpu_version cpu  = VNONE;
d132 1
a132 1
/* include string substitutions in listing? */
d134 1
a134 1
/* did we do subsym substitutions on the line? */
d136 1
a136 1
/* last label seen */
d138 1
a138 1
/* this ensures that all new labels are unique */
d143 2
a144 2
/* allow maximum levels of macro nesting; level 0 is the main substitution
   symbol table.  The other assembler only does 32 levels, so there! */
d146 1
a146 1
/* keep track of local labels so we can substitute them before GAS sees them 
d153 1
a153 2
   other things (like conditionals and repeat loops).
 */
d156 1
a156 1
/* keep track of struct/union tags */
d199 2
a200 1
static struct stag {
d206 2
a207 1
  struct stag_field {               /* list of fields */
d222 4
a225 3
/* output a single character (upper octect is zero) */
static void 
tic54x_emit_char (char c)
d234 1
a234 1
/* walk backwards in the frag chain */
d237 2
a238 2
  fragS *frag;
  segT seg;
d243 1
a243 1
  for (fragp = seginfo->frchainP->frch_root;fragp;fragp = fragp->fr_next)
d246 1
d252 2
a253 2
  fragS *frag;
  segT seg;
d257 4
a260 4
      if (frag->fr_fix == 0 
          && frag->fr_opcode == NULL 
          && frag->tc_frag_data == 0)
        frag = frag_prev (frag, seg);
d262 1
a262 1
        return frag;
d267 2
a268 2
/* return the number of bits allocated in the most recent word, or zero if
   none. .field/.space/.bes may leave words partially allocated */
d271 2
a272 2
  fragS *frag;
  segT seg;
d275 1
d277 2
a278 3
    {
      return frag->fr_opcode != NULL ? -1 : frag->tc_frag_data;
    }
d282 2
a283 2
/* read an expression from a C string; returns a pointer past the end of the
   expression  */
d302 2
a303 3
   unsupported. 
*/
static void 
d305 1
a305 1
  int x ATTRIBUTE_UNUSED;
d325 5
a329 5
        {
          if (is_end_of_line[(int)*input_line_pointer])
            break;
          ++input_line_pointer;
        }
d363 2
a364 3
   table, since that's what works best.
*/
static void 
d366 1
a366 1
  int x ATTRIBUTE_UNUSED;
d386 5
a390 5
        {
          as_bad (_("Unterminated string after absolute expression"));
          ignore_rest_of_line ();
          return;
        }
d401 1
a401 1
  tmp = xmalloc (strlen (name)+1);
d418 1
a418 1
     to match their behavior */
d439 2
a440 4
      (not yet implemented)

 */
static void 
d442 1
a442 1
  int x ATTRIBUTE_UNUSED;
d456 2
a457 2
  current_seg = now_seg;	/* save current seg.  */
  current_subseg = now_subseg;	/* save current subseg.  */
d482 1
a482 1
          block = get_absolute_expression ();
d484 1
a484 1
          block = 0;
d487 4
a490 4
        {
          ++input_line_pointer;
          align = get_absolute_expression ();
        }
d492 1
a492 1
        align = 0;
d505 1
a505 1
		(offsetT)(words << 1), (char *) 0);
d531 6
a536 5
stag_add_field_symbols (struct stag *stag,
                        const char *path, 
                        bfd_vma base_offset, 
                        symbolS *rootsym,
                        const char *root_stag_name)
d541 2
a542 3
  /* construct a symbol for every field contained within this structure 
     including fields within structure fields
   */
d574 2
a575 3
      /* recurse if the field is a structure 
         note the field offset is relative to the outermost struct
       */
d584 2
a585 2
/* keep track of stag fields so that when structures are nested we can add the
   complete dereferencing symbols to the symbol table */
d587 5
a591 2
stag_add_field (struct stag *parent, const char *name, bfd_vma offset, 
                struct stag *stag)
d608 1
a608 1
  /* only create a symbol for this field if the parent has no name */
d619 1
a619 3
   start defining structure offsets (symbols in absolute section)

 */
d628 1
a628 1
      /* starting a new struct, switch to absolute section */
d633 1
a633 1
  /* align the current pointer */
d640 1
a640 1
  /* offset expression is only meaningful for global .structs */
d643 1
a643 1
      /* offset is ignored in inner structs */
d653 1
a653 1
      /* nesting, link to outer one */
d689 1
a689 1
  /* nested .structs don't go into the symbol table */
d698 1
a698 2
   of the structure
 */
d705 1
d715 1
a715 1
  /* align end of structures */
d733 1
a733 1
  /* union size has already been calculated */
d736 1
a736 1
  /* nested .structs don't get put in the stag table */
d746 2
a747 2
  /* if this is a nested .struct/.union, add it as a field to the enclosing
     one.  otherwise, restore the section we were in   */
d762 1
a762 2
   format on the existing allocated space.
 */
d808 1
a808 1
  /* bump by the struct size, but only if we're within a .struct section */
d817 1
a817 1
/* handle all .byte, .char, .double, .field, .float, .half, .int, .long,
d819 1
a819 2
   and .word 
*/
d866 1
a866 1
          /* set the appropriate size and new field offset */
d895 1
a895 1
      /* align to the actual starting position of the field */
d899 1
a899 1
  /* align to longword boundary */
d923 1
a923 1
      /* Note we treat the element as if it were an array of COUNT */
d935 1
a935 1
/* Handle .byte, .word. .int, .long and all variants */
d943 1
a943 1
  /* if we're within a .struct construct, don't actually allocate space */
d956 1
a956 1
  /* align long words to long word boundaries (4 octets) */
d960 1
a960 1
      /* if there's a label, assign it to the first allocated word */
d1003 1
a1003 1
              /* truncate overflows */
d1035 1
a1035 1
                 totally ignored in the latest tools) */
d1073 1
a1073 2
   these, so we ignore the type here.
*/
d1107 1
a1107 1
/* remove the symbol from the local label hash lookup */
d1117 1
a1117 1
/* Reset all local labels */
d1125 1
a1125 2
/* 
   .text
d1134 1
a1134 2
   For compatibility, '*' sections have SEC_DATA set instead of SEC_CODE
*/
d1140 1
a1140 1
  /* local labels are cleared when changing sections */
d1151 1
a1151 1
      /* if there are quotes, remove them */
d1167 1
a1167 1
      /* make sure all named initialized sections are SEC_DATA */
d1172 1
a1172 1
      /* if there was a line label, make sure that it gets assigned the proper
d1175 1
a1175 1
         like .usect, since that is probably what people expect */
d1191 1
a1191 2
   cribbed from s_space
*/
d1210 1
a1210 1
  /* read the bit count */
d1213 1
a1213 1
  /* some expressions are unresolvable until later in the assembly pass;
d1215 1
a1215 2
     partial allocation has not been completed yet.
  */
d1234 2
a1235 2
  /* reduce the required size by any bit offsets currently left over
     from a previous .space/.bes/.field directive */
d1242 2
a1243 2
          /* don't have to do anything; sufficient bits have already been
             allocated; just point the label to the right place */ 
d1254 2
a1255 2
      /* set the label to point to the first word allocated, which in this
         case is the previous word, which was only partially filled */
d1263 1
a1263 1
  /* convert bits to bytes/words and octets, rounding up */
d1265 1
a1265 1
  /* how many do we have left over? */
d1294 1
a1294 1
  /* make note of how many bits of this word we've allocated so far */
d1297 1
a1297 1
  /* .bes puts label at *last* word allocated */
d1320 1
a1320 2
   Has no effect on the current section.
*/
d1359 1
a1359 1
  /* read a possibly present third argument (blocking flag) */
d1368 1
a1368 1
      /* read a possibly present fourth argument (alignment flag) */
d1385 1
a1385 1
      /* s_align eats end of line; restore it */
d1419 2
a1420 1
lookup_version (const char *ver)
d1423 1
d1441 2
a1442 1
set_cpu (enum cpu_version version)
d1465 2
a1466 1
   This is for compatibility only.  It currently has no affect on assembly.
a1467 2
 */
static int cpu_needs_set = 1;
d1510 1
a1510 1
/* 'f' = float, 'x' = xfloat, 'd' = double, 'l' = ldouble */
d1515 1
a1515 3
    {
      tic54x_struct_field ('f');
    }
d1520 2
a1521 1
  /* align to long word boundary (4 octets) unless it's ".xfloat" */
d1525 1
a1525 1
      /* if there's a label, assign it to the first allocated word */
d1539 1
a1539 2
   and encoded into the correct octets.
*/
d1541 2
a1542 1
tic54x_stringer (int type)
d1548 1
a1548 1
  int last_char = -1; /* packed strings need two bytes at a time to encode */
d1585 1
a1585 1
                  /* packed strings are filled MS octet first */
d1619 1
a1619 1
  /* finish up any leftover packed string */
d1636 2
a1637 1
tic54x_align_words (int arg)
d1639 1
a1639 1
  /* only ".align" with no argument is allowed within .struct/.union */
d1666 1
a1666 2
/* initialize multiple-bit fields withing a single word of memory 
 */
d1697 1
a1697 1
  /* truncate values to the field width */
d1700 1
a1700 1
      /* if the expression value is relocatable, the field size *must* be 16 */
d1719 1
a1719 1
      /* bits are stored MS first */
d1734 2
a1735 2
              /* we don't know the previous offset at this time, so store the
                 info we need and figure it out later */
d1750 1
a1750 1
              /* align a new field */
d1757 1
a1757 1
              /* put the new value entirely within the existing one */
d1771 1
a1771 1
          /* OR in existing value */
d1785 1
a1785 1
   available yet.  seg_info ()->bss is the next best thing */
d1798 1
a1798 3
   Name is required for uninitialized sections.

 */
d1842 1
a1842 1
/* change the default include directory to be the current source file's
d1844 1
a1844 1
   set to "." instead  */
d1879 1
a1879 2
/* 
   .include "filename" | filename 
d1888 1
a1888 2
   Entering/exiting included/copied file clears all local labels
*/
d1921 1
a1921 1
     newblock is executed after the included file is processed */
d1934 2
a1935 1
tic54x_message (int type)
d1978 1
a1978 2
   run address (vma)
 */
d1997 3
a1999 5
/*
  .mmregs
  install all memory-mapped register names into the symbol table as absolute
  local symbols.
 */
d2017 2
a2018 4
/*
  .loop [count]
  count defaults to 1024
 */
d2031 1
a2031 1
/* normally, endloop gets eaten by the preceding loop */
d2040 1
a2040 3
/*
  .break [condition]
*/
d2097 1
a2097 2
   designate initialized sections for blocking
 */
d2152 1
a2152 2
   symbols assigned with .set/.equ may not be redefined
*/
d2186 1
a2186 2
   list false conditional blocks
*/
d2206 1
a2206 2
   define a substitution string to be local to a macro
*/
d2254 1
a2254 2
   FIXME need to try the source file directory as well
 */
d2310 1
a2310 1
     running for a very long time, it really doesn't matter... */ 
d2313 1
a2313 1
  /* expand all archive entries to temporary files and include them */
d2329 1
a2329 1
  /* open each BFD as binary (it should be straight ASCII text) */
d2333 1
a2333 1
      /* get a size at least as big as the archive member */
d2339 1
a2339 1
      /* we're not sure how big it is, but it will be smaller than "size" */
d2342 2
a2343 3
      /* write to a temporary file, then use s_include to include it 
         a bit of a hack...
       */
a2443 1
/* for debugging, strings for each operand type */
d2445 1
d2504 1
a2504 1
/* create a "local" substitution string hash table for a new macro level 
d2507 1
a2507 2
   deleting the local label hash between macro invocations.
 */
d2517 2
a2518 1
tic54x_macro_info (void *info)
d2538 1
a2538 1
  /* put the formal args into the substitution symbol table */
d2551 1
a2551 1
/* get rid of this macro's .var's, arguments, and local labels */
d2570 1
a2570 1
/* compare symbol A to string B */
d2572 3
a2574 1
subsym_symcmp (char *a, char *b)
d2579 2
a2580 2
/* return the index of the first occurence of B in A, or zero if none 
   assumes b is an integer char value as a string.  index is one-based */
d2582 3
a2584 1
subsym_firstch (char *a, char *b)
d2592 1
a2592 1
/* similar to firstch, but returns index of last occurrence of B in A */
d2604 2
a2605 2
/* returns 1 if string A is defined in the symbol table (NOT the substitution
   symbol table) */
d2616 1
a2616 1
/* assign first member of comma-separated list B (e.g. "1,2,3") to the symbol
d2618 1
a2618 1
   symbols, unsubstituted  */
d2620 3
a2622 1
subsym_ismember (char *symbol, char *list)
d2643 1
a2643 1
  subsym_create_or_replace (symbol, elem);
d2645 1
a2645 1
  /* reassign the list */
d2648 1
a2648 1
  /* assume this value, docs aren't clear */
d2652 1
a2652 1
/* return zero if not a constant; otherwise:
d2657 1
a2657 2
   5 if decimal
*/
d2684 1
a2684 1
      /* no suffix; either octal, hex, or decimal */
d2697 1
a2697 1
/* return 1 if A is a valid symbol name.  Expects string input   */
d2714 1
a2714 1
/* return whether the string is a register; accepts ar0-7, unless .mmregs has
d2716 1
a2716 1
   Note this does not recognize "A" or "B" accumulators */
d2729 1
a2729 1
/* Return the structrure size, given the stag */
d2747 1
a2747 2
   return zero, we punt and return zero.
 */
d2763 1
d2771 1
d2779 1
d2785 1
d2793 1
d2801 1
d2809 1
d2825 1
d2833 1
d2841 1
d2847 1
d2855 1
d2863 1
d2871 1
d2879 1
d2887 2
a2888 1
/* expr1 * 2^expr2 */
d2894 1
d2902 1
d2910 1
d2916 1
d2922 1
d2928 1
d2936 1
d2944 1
d2952 1
d2960 1
d2969 1
a2969 1
/* built-in substitution symbol functions and math functions */
d2977 3
a2979 2
static const subsym_proc_entry subsym_procs[] = {
  /* assembler built-in string substitution functions */
d3002 3
a3004 2
static const math_proc_entry math_procs[] = {
  /* integer-returning built-in math functions */
d3009 1
a3009 1
  /* float-returning built-in math functions */
d3053 1
a3053 1
  /* look for A_DIR and add it to the include list */
d3089 1
a3089 1
      /* add basic registers to the symbol table */
d3128 2
a3129 2
  /* only the base substitution table and local label table are initialized;
     the others (for local macro substitution) get instantiated as needed */
d3140 2
a3141 2
      /* insert into the main subsym hash for recognition; insert into
         the math hash to actually store information */
d3151 2
a3152 1
typedef struct _tic54x_insn {
d3160 2
a3161 1
  struct opstruct {
d3175 2
a3176 1
  struct {
d3192 2
a3193 1
is_accumulator (struct opstruct *operand)
d3199 2
a3200 2
/* return the number of operands found, or -1 on error, copying the operands
   into the given array and the accompanying expressions into the next array */
d3242 1
a3242 1
          /* trim trailing spaces; while the preprocessor gets rid of most,
d3244 1
a3244 1
             (i.e. using strings for macro args) */
d3277 1
a3277 1
  /* ok, now parse them into expressions */
d3295 1
a3295 1
          /* allow immediate syntax in the inner expression */
d3299 1
a3299 1
          /* pull out the lk expression or SP offset, if present */
d3328 1
a3328 3
/*
 * Predicates for different operand types
 */
d3330 2
a3331 1
is_immediate (struct opstruct *operand)
d3337 1
a3337 1
   and must *not* have the '#' prefix */
d3339 2
a3340 1
is_absolute (struct opstruct *operand)
d3345 1
a3345 1
/* is this an indirect operand? */
d3347 2
a3348 1
is_indirect (struct opstruct *operand)
d3353 1
a3353 1
/* is this a valid dual-memory operand? */
d3355 2
a3356 1
is_dual (struct opstruct *operand)
d3363 1
d3365 1
a3365 1
      /* only allow *ARx, *ARx-, *ARx+, or *ARx+0% */
d3376 2
a3377 1
is_mmreg (struct opstruct *operand)
d3398 1
a3398 1
      /* this one *must* be immediate */
d3408 1
a3408 1
      /* address may be a numeric, indirect, or an expression */
d3438 1
a3438 1
      /* allow st0 or st1 instead of a numeric */
d3449 1
a3449 1
      /* let this one catch out-of-range values */
d3463 2
a3464 2
      /* allow anything; assumes opcodes are ordered with Smem operands 
         versions first */
d3469 1
a3469 1
      /* just make sure it's an integer; check range later */
d3508 2
a3509 3
          /* skip an optional template operand if it doesn't agree
             with the current operand
           */
d3521 1
a3521 1
      /* save the actual operand type for later use */
d3525 1
a3525 1
      /* have we matched them all yet? */
d3530 1
a3530 1
              /* if a later operand is *not* optional, no match */
d3533 2
a3534 2
              /* flag any implicit default OP_DST operands so we know to add
                 them explicitly when encoding the operand later */
d3557 1
a3557 2
   2 for the upper 7 bits of a 23-bit address (LDX)
*/
d3566 1
a3566 1
  /* only allow *(dmad) expressions; all others are invalid */
d3591 1
a3591 1
      /* do the fixup later; just store the expression */
d3599 1
a3599 1
          /* this relocation spans two words, so adjust accordingly */
d3604 2
a3605 2
          /* it's really 2 words, but we want to stop encoding after the
             first, since we must encode both words at once */
d3620 1
a3620 1
/* 7-bit direct address encoding */
d3626 1
a3626 1
  /* Assumes that dma addresses are *always* in word 0 of the opcode */
d3633 1
a3633 1
      /* do the fixup later; just store the expression */
d3652 1
a3652 1
      /* lk addresses always go in the second insn word */
d3673 1
a3673 1
      /* stack offsets look the same as 7-bit direct addressing */
d3730 2
a3731 2
      /* hack -- fixup for 16-bit hex quantities that get converted positive
         instead of negative */
d3754 1
a3754 1
          /* do the fixup later; just store the expression */
d3793 1
a3793 1
  /* disallow group 1 conditions mixed with group 2 conditions
d3795 1
a3795 2
     if group 2, allow only one each of category A, B, and C
   */
d3894 1
a3894 1
      /* disallow long-constant addressing for memory-mapped addressing */
d3902 1
a3902 1
      /* warn about *+ARx when used with MMR operands */
d3916 1
a3916 1
      /* 16-bit immediate value */
d3927 1
a3927 1
      /* make sure this agrees with with the OP_DST operand */
d4045 2
a4046 2
          /* guess the register based on the status bit; "ovb" is the last
             status bit defined for st0 */
d4098 1
a4098 1
      /* no encoding necessary */
d4130 2
a4131 3
/* convert the operand strings into appropriate opcode values 
   return the total number of words used by the instruction
 */
d4138 1
a4138 1
  /* only non-parallel instructions support lk addressing */
d4147 1
a4147 1
              /* don't mistake stack-relative addressing for lk addressing */
d4185 1
a4185 2
  /* optimize some instructions, helping out the brain-dead programmer
   */ 
d4200 1
a4200 1
      /* try to collapse if Xmem and shift count is zero */
d4204 1
a4204 1
          /* Or if Smem, shift is zero or absent, and SRC == DST */
d4273 1
a4273 1
/* Find a matching template if possible, and get the operand strings */
d4290 1
a4290 1
  /* check each variation of operands for this mnemonic */
d4299 1
a4299 1
          /* SUCCESS! now try some optimizations */
d4316 2
a4317 2
/* we set this in start_line_hook, 'cause if we do a line replacement, we
   won't be able to see the next line */
d4320 1
a4320 2
   Look for a subsequent line starting with "||"
*/
d4360 1
a4360 1
  /* didn't find a matching parallel; try for a normal insn */
d4364 1
a4364 1
/* parse the second line of a two-line parallel instruction */
d4401 1
a4401 1
/* if quotes found, return copy of line up to closing quote;
d4404 1
a4404 2
   replacement on the value
*/
d4431 1
a4431 1
      /* do forced substitutions if requested */
d4454 1
a4454 1
      /* do simple substitution, if available */
d4462 1
a4462 1
/* replace the given substitution string.
d4465 1
a4465 2
   that's compatible w/TI's assembler.
*/
d4467 3
a4469 1
subsym_create_or_replace (char *name, char *value)
d4487 2
a4488 2
/* look up the substitution string replacement for the given symbol 
   start with the innermost macro substituion table given and work outwards */
d4490 3
a4492 1
subsym_lookup (char *name, int nest_level)
d4502 1
a4502 1
/* do substitution-symbol replacement on the given line (recursively).
d4507 1
a4507 2
   if FORCED is set, look for forced substitutions of the form ':SYMBOL:'.
*/
d4511 2
a4512 2
  /* for each apparent symbol, see if it's a substitution symbol, and if so,
     replace it in the input */
d4524 1
a4524 1
  /* work with a copy of the input line */
d4530 1
a4530 1
  /* flag lines where we might need to replace a single '=' with two;
d4532 1
a4532 1
     places, so limit what we replace */
d4540 2
a4541 2
  /* watch out for .eval, so that we avoid doing substitution on the
     symbol being assigned a value */
d4545 1
a4545 1
  /* if it's a macro definition, don't do substitution on the argument names */
d4553 1
a4553 1
      /* need to update this since LINE may have been modified */
d4557 1
a4557 1
      /* replace triple double quotes with bounding quote/escapes */
d4567 2
a4568 2
      /* replace a single '=' with a '==';
         for compatibility with older code only */
d4579 1
a4579 1
          /* continue examining after the '==' */
d4586 1
a4586 1
      /* flag when we've reached the symbol part of .eval/.asg */
d4590 2
a4591 3
      /* for each apparent symbol, see if it's a substitution symbol, and if
         so, replace it in the input 
      */
d4601 1
a4601 1
          /* skip the colon */
d4608 1
a4608 2
             label 
           */ 
d4615 2
a4616 2
          /* avoid infinite recursion; if a symbol shows up a second time for
             substitution, leave it as is */
d4626 2
a4627 2
          /* check for local labels; replace them with the appropriate
             substitution */
d4631 2
a4632 2
              /* use an existing identifier for that label if, available, or
                 create a new, unique identifier */
d4646 1
a4646 1
              /* indicate where to continue looking for substitutions */
d4649 1
a4649 1
          /* check for built-in subsym and math functions */
d4694 1
a4694 1
                  /* don't bother recursing; the replacement isn't a symbol */
d4702 3
a4704 3
                  /* parse one or two args, which must be a substitution
                     symbol, string or a character-string constant */
                  /* for all functions, a string or substitution symbol may be
d4707 1
a4707 2
                     ismember: both args must be substitution symbols
                  */
d4718 2
a4719 2
                      /* character constants are converted to numerics
                         by the preprocessor */
d4723 1
a4723 1
                  /* args checking */
d4746 2
a4747 2
              /* fix things up to replace the entire expression, not just the
                 function name  */
d4760 1
a4760 2
                 try to replace a symbol once
              */
d4768 1
a4768 1
              /* temporarily zero-terminate where the symbol started */
d4774 1
a4774 1
                      /* subscripted substitution symbol -- use just the
d4777 1
a4777 2
                         supposed to be recursive, but I'm not sure. 
                      */
d4821 1
a4821 1
              /* Make sure forced substitutions are properly terminated */
d4839 1
a4839 2
                     complete 
                  */
d4850 1
a4850 1
                /* restore the character after the symbol end */
d4853 1
a4853 1
              /* continue examining after the replacement value */
d4874 1
a4874 1
/* we use this to handle substitution symbols 
d4879 1
a4879 2
   returns the new buffer limit
*/
d4886 1
a4886 1
  /* work with a copy of the input line, including EOL char */
d4894 1
a4894 1
  /* scan ahead for parallel insns */
d4897 1
a4897 1
  /* if within a macro, first process forced replacements */
d4910 1
a4910 1
      /* clean up the replacement; we'd prefer to have this done by the
d4912 1
a4912 2
         but for now, do a quick-and-dirty
      */
d4922 1
a4922 1
      /* trim trailing whitespace */
d4930 1
a4930 1
      /* compact leading whitespace */
d4938 1
a4938 1
      /* keep track of whether we've done a substitution */
d4943 1
a4943 1
      /* no change */
d4951 1
a4951 2
   the frags/bytes it assembles to.
 */
d5018 1
a5018 1
     mnemonic, and we look for it in the parallel insn hash table */
d5028 2
a5029 2
          /* if the parallel part is on the same line, process it now,
             otherwise let the assembler pick up the next line for us */
d5065 1
a5065 1
      /* Is this instruction in a delay slot? */
d5077 1
a5077 1
          /* branches in delay slots are not allowed */
d5086 1
d5101 1
a5101 1
      /* make sure we check the target of a repeat instruction */
d5105 1
a5105 1
          /* FIXME -- warn if repeat_slot == 1 at EOF */
d5107 1
a5107 1
      /* make sure we check our delay slots for validity */
d5111 1
a5111 1
          /* FIXME -- warn if delay_slots != 0 at EOF */
d5117 1
a5117 1
   a ".file" symbol */
d5133 1
a5133 2
   This lets us process parallel instructions, which span two lines
*/
d5144 1
a5144 2
   symbol table.
 */
d5146 2
a5147 1
tic54x_define_label (symbolS *sym)
d5152 1
a5152 1
  /* just in case we need this later; note that this is not necessarily the
d5157 1
a5157 2
     is done in tic54x_cons.
  */
d5161 1
a5161 1
/* Try to parse something that normal parsing failed at. */
d5168 1
a5168 1
  /* not sure how to handle predefined symbols */
d5192 2
a5193 2
/* parse a name in an expression before the expression parser takes a stab at
   it */
d5201 1
a5201 1
  /* if it's a MMREG, replace it with its constant value */
d5228 1
a5228 1
  /* target data is little-endian, but floats are stored big-"word"ian.  ugh */
d5269 1
a5269 1
/* handle cons expressions */
d5284 1
a5284 1
      /* TI assembler always uses this, regardless of addressing mode */
d5288 2
a5289 2
        /* we never want to directly generate this; this is provided for 
           stabs support only */
d5299 1
a5299 2
   If fixp->fx_addsy is non-NULL, we'll have to generate a reloc entry.
   */
d5315 1
a5315 1
      /* fall through */
d5319 2
a5320 2
      /* indicate what we're actually writing, so that we don't get warnings
         about exceeding available space */
d5327 2
a5328 2
      /* indicate what we're actually writing, so that we don't get warnings
         about exceeding available space */
d5333 1
a5333 1
         thus incompatible with this implementation's relocatable files */ 
d5346 1
a5346 1
  return 0; /* return value is ignored */
d5349 2
a5350 3
/* this is our chance to record section alignment 
   don't need to do anything here, since BFD does the proper encoding
 */
d5377 1
a5377 1
/* mostly little-endian, but longwords (4 octets) get MS word stored first */
d5401 2
a5402 2
/* we use this to handle bit allocations which we couldn't handle before due
   to symbols being in different frags.  return number of octets added. */
d5438 1
a5438 1
          /* bit fields of 16 or larger will have already been handled */
d5450 1
a5450 1
              /* this frag is no longer used */
d5490 1
a5490 1
          /* make sure any BES label points to the LAST word allocated */
d5508 1
a5508 1
  /* offset is in bytes */
d5521 1
a5521 1
/* we need to avoid having labels defined for certain directives/pseudo-ops
d5529 1
a5529 2
   Don't allow labels to start with '.'
*/
d5535 1
a5535 1
  /* if within .struct/.union, no auto line labels, please */
d5539 1
a5539 1
  /* disallow labels starting with "." */
d5560 1
a5560 1
      /* don't let colon () define a label for any of these... */
@

