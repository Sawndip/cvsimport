head	1.222;
access;
symbols
	binutils-2_24-branch:1.222.0.2
	binutils-2_24-branchpoint:1.222
	binutils-2_21_1:1.214
	binutils-2_23_2:1.219.2.1
	binutils-2_23_1:1.219.2.1
	binutils-2_23:1.219.2.1
	binutils-2_23-branch:1.219.0.2
	binutils-2_23-branchpoint:1.219
	binutils-2_22_branch:1.217.0.4
	binutils-2_22:1.217
	binutils-2_22-branch:1.217.0.2
	binutils-2_22-branchpoint:1.217
	binutils-2_21:1.214
	binutils-2_21-branch:1.214.0.2
	binutils-2_21-branchpoint:1.214
	binutils-2_20_1:1.209.2.1
	binutils-2_20:1.209.2.1
	binutils-arc-20081103-branch:1.203.0.6
	binutils-arc-20081103-branchpoint:1.203
	binutils-2_20-branch:1.209.0.2
	binutils-2_20-branchpoint:1.209
	dje-cgen-play1-branch:1.206.0.2
	dje-cgen-play1-branchpoint:1.206
	arc-20081103-branch:1.203.0.4
	arc-20081103-branchpoint:1.203
	binutils-2_19_1:1.203
	binutils-2_19:1.203
	binutils-2_19-branch:1.203.0.2
	binutils-2_19-branchpoint:1.203
	binutils-2_18:1.192
	binutils-2_18-branch:1.192.0.2
	binutils-2_18-branchpoint:1.192
	binutils-csl-coldfire-4_1-32:1.187
	binutils-csl-sourcerygxx-4_1-32:1.187
	binutils-csl-innovasic-fido-3_4_4-33:1.187
	binutils-csl-sourcerygxx-3_4_4-32:1.149.2.2
	binutils-csl-coldfire-4_1-30:1.187
	binutils-csl-sourcerygxx-4_1-30:1.187
	binutils-csl-coldfire-4_1-28:1.187
	binutils-csl-sourcerygxx-4_1-29:1.187
	binutils-csl-sourcerygxx-4_1-28:1.187
	binutils-csl-arm-2006q3-27:1.187
	binutils-csl-sourcerygxx-4_1-27:1.187
	binutils-csl-arm-2006q3-26:1.187
	binutils-csl-sourcerygxx-4_1-26:1.187
	binutils-csl-sourcerygxx-4_1-25:1.187
	binutils-csl-sourcerygxx-4_1-24:1.187
	binutils-csl-sourcerygxx-4_1-23:1.187
	binutils-csl-sourcerygxx-4_1-21:1.187
	binutils-csl-arm-2006q3-21:1.187
	binutils-csl-sourcerygxx-4_1-22:1.187
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.187
	binutils-csl-sourcerygxx-4_1-20:1.187
	binutils-csl-arm-2006q3-19:1.187
	binutils-csl-sourcerygxx-4_1-19:1.187
	binutils-csl-sourcerygxx-4_1-18:1.187
	binutils-csl-renesas-4_1-9:1.187
	binutils-csl-sourcerygxx-3_4_4-25:1.149.2.2
	binutils-csl-renesas-4_1-8:1.187
	binutils-csl-renesas-4_1-7:1.187
	binutils-csl-renesas-4_1-6:1.187
	binutils-csl-sourcerygxx-4_1-17:1.187
	binutils-csl-sourcerygxx-4_1-14:1.187
	binutils-csl-sourcerygxx-4_1-15:1.187
	binutils-csl-sourcerygxx-4_1-13:1.187
	binutils-2_17:1.187
	binutils-csl-sourcerygxx-4_1-12:1.187
	binutils-csl-sourcerygxx-3_4_4-21:1.187
	binutils-csl-wrs-linux-3_4_4-24:1.149
	binutils-csl-wrs-linux-3_4_4-23:1.149
	binutils-csl-sourcerygxx-4_1-9:1.187
	binutils-csl-sourcerygxx-4_1-8:1.187
	binutils-csl-sourcerygxx-4_1-7:1.187
	binutils-csl-arm-2006q1-6:1.187
	binutils-csl-sourcerygxx-4_1-6:1.187
	binutils-csl-wrs-linux-3_4_4-22:1.149
	binutils-csl-coldfire-4_1-11:1.187
	binutils-csl-sourcerygxx-3_4_4-19:1.187
	binutils-csl-coldfire-4_1-10:1.187
	binutils-csl-sourcerygxx-4_1-5:1.187
	binutils-csl-sourcerygxx-4_1-4:1.187
	binutils-csl-wrs-linux-3_4_4-21:1.149
	binutils-csl-morpho-4_1-4:1.187
	binutils-csl-sourcerygxx-3_4_4-17:1.187
	binutils-csl-wrs-linux-3_4_4-20:1.149
	binutils-2_17-branch:1.187.0.4
	binutils-2_17-branchpoint:1.187
	binutils-csl-2_17-branch:1.187.0.2
	binutils-csl-2_17-branchpoint:1.187
	binutils-csl-gxxpro-3_4-branch:1.149.2.2.0.2
	binutils-csl-gxxpro-3_4-branchpoint:1.149.2.2
	binutils-2_16_1:1.149.2.2
	binutils-csl-arm-2005q1b:1.149
	binutils-2_16:1.149.2.1
	binutils-csl-arm-2005q1a:1.149
	binutils-csl-arm-2005q1-branch:1.149.0.4
	binutils-csl-arm-2005q1-branchpoint:1.149
	binutils-2_16-branch:1.149.0.2
	binutils-2_16-branchpoint:1.149
	csl-arm-2004-q3d:1.119
	csl-arm-2004-q3:1.117
	binutils-2_15:1.101.4.1
	binutils-2_15-branchpoint:1.101
	csl-arm-2004-q1a:1.107
	csl-arm-2004-q1:1.107
	binutils-2_15-branch:1.101.0.4
	cagney_bfdfile-20040213-branch:1.101.0.2
	cagney_bfdfile-20040213-branchpoint:1.101
	cagney_bigcore-20040122-branch:1.96.0.2
	cagney_bigcore-20040122-branchpoint:1.96
	csl-arm-2003-q4:1.95
	binutils-2_14:1.82
	binutils-2_14-branch:1.82.0.2
	binutils-2_14-branchpoint:1.82
	binutils-2_13_2_1:1.69.2.1
	binutils-2_13_2:1.69.2.1
	binutils-2_13_1:1.69.2.1
	binutils-2_13:1.69
	binutils-2_13-branchpoint:1.69
	binutils-2_13-branch:1.69.0.2
	binutils-2_12_1:1.64.2.3
	binutils-2_12:1.64.2.1
	binutils-2_12-branch:1.64.0.2
	binutils-2_12-branchpoint:1.64
	cygnus_cvs_20020108_pre:1.63
	binutils-2_11_2:1.38.2.10
	binutils-2_11_1:1.38.2.10
	binutils-2_11:1.38.2.6
	x86_64versiong3:1.45
	binutils-2_11-branch:1.38.0.2
	binutils_latest_snapshot:1.222;
locks; strict;
comment	@ * @;


1.222
date	2013.08.23.07.54.18;	author nickc;	state Exp;
branches;
next	1.221;

1.221
date	2013.03.26.09.13.17;	author gingold;	state Exp;
branches;
next	1.220;

1.220
date	2012.09.04.13.52.06;	author hjl;	state Exp;
branches;
next	1.219;

1.219
date	2012.05.05.03.05.27;	author amodra;	state Exp;
branches
	1.219.2.1;
next	1.218;

1.218
date	2012.04.20.10.21.33;	author gingold;	state Exp;
branches;
next	1.217;

1.217
date	2011.07.03.13.37.08;	author tschwinge;	state Exp;
branches;
next	1.216;

1.216
date	2011.05.18.09.41.15;	author nickc;	state Exp;
branches;
next	1.215;

1.215
date	2011.04.01.08.56.21;	author gingold;	state Exp;
branches;
next	1.214;

1.214
date	2010.09.16.23.55.10;	author amodra;	state Exp;
branches;
next	1.213;

1.213
date	2010.02.12.14.34.45;	author gingold;	state Exp;
branches;
next	1.212;

1.212
date	2010.01.19.09.14.54;	author gingold;	state Exp;
branches;
next	1.211;

1.211
date	2009.12.11.13.42.10;	author nickc;	state Exp;
branches;
next	1.210;

1.210
date	2009.10.07.05.13.53;	author amodra;	state Exp;
branches;
next	1.209;

1.209
date	2009.09.03.13.20.31;	author gingold;	state Exp;
branches
	1.209.2.1;
next	1.208;

1.208
date	2009.08.29.22.10.59;	author nickc;	state Exp;
branches;
next	1.207;

1.207
date	2009.07.24.11.45.00;	author nickc;	state Exp;
branches;
next	1.206;

1.206
date	2009.06.22.17.56.01;	author nickc;	state Exp;
branches;
next	1.205;

1.205
date	2009.03.02.14.47.38;	author nickc;	state Exp;
branches;
next	1.204;

1.204
date	2009.01.15.12.42.52;	author nickc;	state Exp;
branches;
next	1.203;

1.203
date	2008.08.28.14.07.49;	author hjl;	state Exp;
branches;
next	1.202;

1.202
date	2008.08.12.23.39.30;	author amodra;	state Exp;
branches;
next	1.201;

1.201
date	2008.08.12.09.58.34;	author amodra;	state Exp;
branches;
next	1.200;

1.200
date	2008.01.09.22.36.06;	author aoliva;	state Exp;
branches;
next	1.199;

1.199
date	2007.11.19.18.15.53;	author bwilson;	state Exp;
branches;
next	1.198;

1.198
date	2007.11.14.22.31.54;	author hjl;	state Exp;
branches;
next	1.197;

1.197
date	2007.10.17.16.45.55;	author nickc;	state Exp;
branches;
next	1.196;

1.196
date	2007.10.11.15.18.40;	author nickc;	state Exp;
branches;
next	1.195;

1.195
date	2007.10.04.17.05.37;	author nickc;	state Exp;
branches;
next	1.194;

1.194
date	2007.09.26.06.58.01;	author jbeulich;	state Exp;
branches;
next	1.193;

1.193
date	2007.08.14.10.44.12;	author schwab;	state Exp;
branches;
next	1.192;

1.192
date	2007.07.03.11.01.04;	author nickc;	state Exp;
branches;
next	1.191;

1.191
date	2007.04.21.12.25.13;	author nickc;	state Exp;
branches;
next	1.190;

1.190
date	2007.02.01.14.12.18;	author amodra;	state Exp;
branches;
next	1.189;

1.189
date	2006.05.02.13.34.25;	author hjl;	state Exp;
branches;
next	1.188;

1.188
date	2006.04.23.22.12.43;	author kazu;	state Exp;
branches;
next	1.187;

1.187
date	2006.03.03.01.10.42;	author wilson;	state Exp;
branches;
next	1.186;

1.186
date	2006.02.23.21.36.17;	author hjl;	state Exp;
branches;
next	1.185;

1.185
date	2006.02.23.14.49.32;	author hjl;	state Exp;
branches;
next	1.184;

1.184
date	2006.02.23.00.17.23;	author hjl;	state Exp;
branches;
next	1.183;

1.183
date	2005.11.23.04.34.13;	author wilson;	state Exp;
branches;
next	1.182;

1.182
date	2005.11.23.01.40.55;	author wilson;	state Exp;
branches;
next	1.181;

1.181
date	2005.11.14.08.38.37;	author jbeulich;	state Exp;
branches;
next	1.180;

1.180
date	2005.11.14.08.37.12;	author jbeulich;	state Exp;
branches;
next	1.179;

1.179
date	2005.10.24.07.42.49;	author jbeulich;	state Exp;
branches;
next	1.178;

1.178
date	2005.10.24.07.36.40;	author jbeulich;	state Exp;
branches;
next	1.177;

1.177
date	2005.10.12.07.51.07;	author jbeulich;	state Exp;
branches;
next	1.176;

1.176
date	2005.09.29.07.00.52;	author jbeulich;	state Exp;
branches;
next	1.175;

1.175
date	2005.09.20.18.24.47;	author rth;	state Exp;
branches;
next	1.174;

1.174
date	2005.07.27.06.32.45;	author jbeulich;	state Exp;
branches;
next	1.173;

1.173
date	2005.07.06.08.31.50;	author jbeulich;	state Exp;
branches;
next	1.172;

1.172
date	2005.07.01.06.51.37;	author jbeulich;	state Exp;
branches;
next	1.171;

1.171
date	2005.06.08.19.47.59;	author wilson;	state Exp;
branches;
next	1.170;

1.170
date	2005.06.08.15.47.45;	author nickc;	state Exp;
branches;
next	1.169;

1.169
date	2005.06.07.17.54.16;	author zack;	state Exp;
branches;
next	1.168;

1.168
date	2005.05.27.06.28.03;	author jbeulich;	state Exp;
branches;
next	1.167;

1.167
date	2005.05.27.06.25.22;	author jbeulich;	state Exp;
branches;
next	1.166;

1.166
date	2005.05.26.18.46.12;	author wilson;	state Exp;
branches;
next	1.165;

1.165
date	2005.05.25.07.17.08;	author jbeulich;	state Exp;
branches;
next	1.164;

1.164
date	2005.05.25.07.13.19;	author jbeulich;	state Exp;
branches;
next	1.163;

1.163
date	2005.05.25.07.08.51;	author jbeulich;	state Exp;
branches;
next	1.162;

1.162
date	2005.05.25.06.59.33;	author jbeulich;	state Exp;
branches;
next	1.161;

1.161
date	2005.05.25.06.55.41;	author jbeulich;	state Exp;
branches;
next	1.160;

1.160
date	2005.05.19.06.32.00;	author jbeulich;	state Exp;
branches;
next	1.159;

1.159
date	2005.05.07.22.19.36;	author hjl;	state Exp;
branches;
next	1.158;

1.158
date	2005.05.05.17.57.31;	author wilson;	state Exp;
branches;
next	1.157;

1.157
date	2005.05.05.09.12.57;	author nickc;	state Exp;
branches;
next	1.156;

1.156
date	2005.04.20.17.40.01;	author hjl;	state Exp;
branches;
next	1.155;

1.155
date	2005.04.20.13.29.45;	author schwab;	state Exp;
branches;
next	1.154;

1.154
date	2005.04.19.14.44.12;	author schwab;	state Exp;
branches;
next	1.153;

1.153
date	2005.04.19.06.46.49;	author jbeulich;	state Exp;
branches;
next	1.152;

1.152
date	2005.04.05.04.01.12;	author hjl;	state Exp;
branches;
next	1.151;

1.151
date	2005.04.02.00.43.48;	author wilson;	state Exp;
branches;
next	1.150;

1.150
date	2005.03.28.22.34.16;	author hjl;	state Exp;
branches;
next	1.149;

1.149
date	2005.03.08.08.27.01;	author jbeulich;	state Exp;
branches
	1.149.2.1;
next	1.148;

1.148
date	2005.03.08.08.23.30;	author jbeulich;	state Exp;
branches;
next	1.147;

1.147
date	2005.02.23.12.28.04;	author amodra;	state Exp;
branches;
next	1.146;

1.146
date	2005.02.18.01.59.08;	author wilson;	state Exp;
branches;
next	1.145;

1.145
date	2005.02.17.23.22.03;	author hjl;	state Exp;
branches;
next	1.144;

1.144
date	2005.02.17.07.43.11;	author jbeulich;	state Exp;
branches;
next	1.143;

1.143
date	2005.02.15.08.11.12;	author jbeulich;	state Exp;
branches;
next	1.142;

1.142
date	2005.02.15.07.54.03;	author jbeulich;	state Exp;
branches;
next	1.141;

1.141
date	2005.02.15.07.50.22;	author jbeulich;	state Exp;
branches;
next	1.140;

1.140
date	2005.02.15.07.37.11;	author jbeulich;	state Exp;
branches;
next	1.139;

1.139
date	2005.02.15.07.32.14;	author jbeulich;	state Exp;
branches;
next	1.138;

1.138
date	2005.02.15.07.30.07;	author jbeulich;	state Exp;
branches;
next	1.137;

1.137
date	2005.02.14.08.02.48;	author jbeulich;	state Exp;
branches;
next	1.136;

1.136
date	2005.02.14.07.47.51;	author jbeulich;	state Exp;
branches;
next	1.135;

1.135
date	2005.02.12.00.13.33;	author hjl;	state Exp;
branches;
next	1.134;

1.134
date	2005.02.11.21.03.33;	author hjl;	state Exp;
branches;
next	1.133;

1.133
date	2005.02.11.21.01.18;	author hjl;	state Exp;
branches;
next	1.132;

1.132
date	2005.02.11.10.13.07;	author jbeulich;	state Exp;
branches;
next	1.131;

1.131
date	2005.02.11.07.54.52;	author jbeulich;	state Exp;
branches;
next	1.130;

1.130
date	2005.02.11.07.45.20;	author jbeulich;	state Exp;
branches;
next	1.129;

1.129
date	2005.02.02.07.37.33;	author jbeulich;	state Exp;
branches;
next	1.128;

1.128
date	2005.01.31.23.18.29;	author bje;	state Exp;
branches;
next	1.127;

1.127
date	2005.01.31.10.01.00;	author jbeulich;	state Exp;
branches;
next	1.126;

1.126
date	2005.01.31.09.46.10;	author jbeulich;	state Exp;
branches;
next	1.125;

1.125
date	2005.01.31.09.17.09;	author jbeulich;	state Exp;
branches;
next	1.124;

1.124
date	2005.01.31.08.48.19;	author jbeulich;	state Exp;
branches;
next	1.123;

1.123
date	2005.01.28.08.21.11;	author jbeulich;	state Exp;
branches;
next	1.122;

1.122
date	2005.01.27.09.12.48;	author jbeulich;	state Exp;
branches;
next	1.121;

1.121
date	2005.01.27.08.41.23;	author jbeulich;	state Exp;
branches;
next	1.120;

1.120
date	2005.01.04.05.42.42;	author wilson;	state Exp;
branches;
next	1.119;

1.119
date	2004.10.25.15.47.52;	author hjl;	state Exp;
branches;
next	1.118;

1.118
date	2004.10.25.15.32.18;	author hjl;	state Exp;
branches;
next	1.117;

1.117
date	2004.09.21.21.39.27;	author wilson;	state Exp;
branches;
next	1.116;

1.116
date	2004.09.08.20.52.48;	author pbrook;	state Exp;
branches;
next	1.115;

1.115
date	2004.08.18.09.51.29;	author jakub;	state Exp;
branches;
next	1.114;

1.114
date	2004.07.26.21.01.14;	author hjl;	state Exp;
branches;
next	1.113;

1.113
date	2004.07.09.23.21.54;	author wilson;	state Exp;
branches;
next	1.112;

1.112
date	2004.07.04.00.29.21;	author wilson;	state Exp;
branches;
next	1.111;

1.111
date	2004.05.28.19.26.31;	author hjl;	state Exp;
branches;
next	1.110;

1.110
date	2004.05.28.05.02.18;	author hjl;	state Exp;
branches;
next	1.109;

1.109
date	2004.05.06.22.32.44;	author wilson;	state Exp;
branches;
next	1.108;

1.108
date	2004.05.04.14.58.11;	author hjl;	state Exp;
branches;
next	1.107;

1.107
date	2004.03.18.13.31.04;	author nathan;	state Exp;
branches;
next	1.106;

1.106
date	2004.03.05.17.07.12;	author hjl;	state Exp;
branches;
next	1.105;

1.105
date	2004.03.03.19.26.26;	author hjl;	state Exp;
branches;
next	1.104;

1.104
date	2004.03.03.04.37.38;	author hjl;	state Exp;
branches;
next	1.103;

1.103
date	2004.02.21.00.24.15;	author wilson;	state Exp;
branches;
next	1.102;

1.102
date	2004.02.19.01.24.29;	author wilson;	state Exp;
branches;
next	1.101;

1.101
date	2004.02.11.01.35.14;	author wilson;	state Exp;
branches
	1.101.4.1;
next	1.100;

1.100
date	2004.02.07.02.41.20;	author wilson;	state Exp;
branches;
next	1.99;

1.99
date	2004.02.05.23.50.21;	author wilson;	state Exp;
branches;
next	1.98;

1.98
date	2004.02.04.04.40.24;	author wilson;	state Exp;
branches;
next	1.97;

1.97
date	2004.01.28.23.00.02;	author hjl;	state Exp;
branches;
next	1.96;

1.96
date	2004.01.07.19.19.35;	author hjl;	state Exp;
branches;
next	1.95;

1.95
date	2003.12.10.06.41.08;	author bje;	state Exp;
branches;
next	1.94;

1.94
date	2003.11.21.14.38.06;	author kazu;	state Exp;
branches;
next	1.93;

1.93
date	2003.11.10.03.07.52;	author amodra;	state Exp;
branches;
next	1.92;

1.92
date	2003.10.23.06.12.17;	author hjl;	state Exp;
branches;
next	1.91;

1.91
date	2003.06.30.04.10.48;	author amodra;	state Exp;
branches;
next	1.90;

1.90
date	2003.06.23.19.35.52;	author wilson;	state Exp;
branches;
next	1.89;

1.89
date	2003.05.21.12.07.55;	author nickc;	state Exp;
branches;
next	1.88;

1.88
date	2003.05.07.19.31.10;	author hjl;	state Exp;
branches;
next	1.87;

1.87
date	2003.05.03.16.04.11;	author hjl;	state Exp;
branches;
next	1.86;

1.86
date	2003.05.02.02.41.45;	author hjl;	state Exp;
branches;
next	1.85;

1.85
date	2003.05.01.01.00.30;	author hjl;	state Exp;
branches;
next	1.84;

1.84
date	2003.05.01.00.53.38;	author hjl;	state Exp;
branches;
next	1.83;

1.83
date	2003.04.30.21.38.55;	author hjl;	state Exp;
branches;
next	1.82;

1.82
date	2003.03.21.14.02.09;	author schwab;	state Exp;
branches;
next	1.81;

1.81
date	2003.03.11.22.00.33;	author rth;	state Exp;
branches;
next	1.80;

1.80
date	2003.01.28.03.24.12;	author wilson;	state Exp;
branches;
next	1.79;

1.79
date	2003.01.23.12.51.05;	author amodra;	state Exp;
branches;
next	1.78;

1.78
date	2003.01.16.21.31.17;	author jakub;	state Exp;
branches;
next	1.77;

1.77
date	2002.12.08.21.25.38;	author hjl;	state Exp;
branches;
next	1.76;

1.76
date	2002.12.05.23.20.39;	author rth;	state Exp;
branches;
next	1.75;

1.75
date	2002.12.05.02.08.01;	author wilson;	state Exp;
branches;
next	1.74;

1.74
date	2002.12.03.18.15.44;	author rth;	state Exp;
branches;
next	1.73;

1.73
date	2002.11.28.23.32.59;	author jakub;	state Exp;
branches;
next	1.72;

1.72
date	2002.11.28.14.15.51;	author jakub;	state Exp;
branches;
next	1.71;

1.71
date	2002.09.05.00.01.17;	author amodra;	state Exp;
branches;
next	1.70;

1.70
date	2002.08.20.23.49.27;	author amodra;	state Exp;
branches;
next	1.69;

1.69
date	2002.05.23.13.12.47;	author jakub;	state Exp;
branches
	1.69.2.1;
next	1.68;

1.68
date	2002.05.06.11.43.02;	author kazu;	state Exp;
branches;
next	1.67;

1.67
date	2002.04.02.00.32.41;	author rth;	state Exp;
branches;
next	1.66;

1.66
date	2002.03.12.09.30.42;	author schwab;	state Exp;
branches;
next	1.65;

1.65
date	2002.02.22.11.56.21;	author nickc;	state Exp;
branches;
next	1.64;

1.64
date	2002.01.11.09.27.38;	author nickc;	state Exp;
branches
	1.64.2.1;
next	1.63;

1.63
date	2002.01.01.01.18.17;	author rth;	state Exp;
branches;
next	1.62;

1.62
date	2002.01.01.01.16.44;	author rth;	state Exp;
branches;
next	1.61;

1.61
date	2001.11.28.17.00.44;	author schwab;	state Exp;
branches;
next	1.60;

1.60
date	2001.11.15.21.28.56;	author nickc;	state Exp;
branches;
next	1.59;

1.59
date	2001.09.19.05.33.24;	author hjl;	state Exp;
branches;
next	1.58;

1.58
date	2001.09.11.18.26.04;	author rth;	state Exp;
branches;
next	1.57;

1.57
date	2001.09.05.20.20.37;	author rth;	state Exp;
branches;
next	1.56;

1.56
date	2001.08.23.20.43.01;	author jakub;	state Exp;
branches;
next	1.55;

1.55
date	2001.07.23.14.02.12;	author kazu;	state Exp;
branches;
next	1.54;

1.54
date	2001.07.06.07.32.42;	author wilson;	state Exp;
branches;
next	1.53;

1.53
date	2001.07.05.03.34.42;	author wilson;	state Exp;
branches;
next	1.52;

1.52
date	2001.07.05.02.30.21;	author wilson;	state Exp;
branches;
next	1.51;

1.51
date	2001.05.11.12.36.46;	author jakub;	state Exp;
branches;
next	1.50;

1.50
date	2001.05.10.00.18.19;	author rth;	state Exp;
branches;
next	1.49;

1.49
date	2001.04.27.20.42.55;	author hjl;	state Exp;
branches;
next	1.48;

1.48
date	2001.04.14.03.51.40;	author wilson;	state Exp;
branches;
next	1.47;

1.47
date	2001.03.16.04.56.31;	author wilson;	state Exp;
branches;
next	1.46;

1.46
date	2001.03.08.23.24.24;	author nickc;	state Exp;
branches;
next	1.45;

1.45
date	2001.02.22.17.16.38;	author twall;	state Exp;
branches;
next	1.44;

1.44
date	2001.02.22.03.16.20;	author wilson;	state Exp;
branches;
next	1.43;

1.43
date	2001.02.21.22.39.59;	author wilson;	state Exp;
branches;
next	1.42;

1.42
date	2001.02.14.01.46.10;	author wilson;	state Exp;
branches;
next	1.41;

1.41
date	2001.02.10.01.42.04;	author rth;	state Exp;
branches;
next	1.40;

1.40
date	2001.02.06.19.09.01;	author hjl;	state Exp;
branches;
next	1.39;

1.39
date	2001.02.06.03.49.29;	author wilson;	state Exp;
branches;
next	1.38;

1.38
date	2001.01.15.23.30.38;	author wilson;	state Exp;
branches
	1.38.2.1;
next	1.37;

1.37
date	2000.12.28.10.07.55;	author rth;	state Exp;
branches;
next	1.36;

1.36
date	2000.12.03.06.49.22;	author kazu;	state Exp;
branches;
next	1.35;

1.35
date	2000.11.22.23.08.47;	author wilson;	state Exp;
branches;
next	1.34;

1.34
date	2000.11.22.02.10.34;	author wilson;	state Exp;
branches;
next	1.33;

1.33
date	2000.11.22.01.12.05;	author wilson;	state Exp;
branches;
next	1.32;

1.32
date	2000.11.17.08.47.51;	author rth;	state Exp;
branches;
next	1.31;

1.31
date	2000.11.16.23.52.01;	author wilson;	state Exp;
branches;
next	1.30;

1.30
date	2000.11.15.17.34.00;	author bernds;	state Exp;
branches;
next	1.29;

1.29
date	2000.11.14.23.56.38;	author wilson;	state Exp;
branches;
next	1.28;

1.28
date	2000.11.14.20.57.30;	author kazu;	state Exp;
branches;
next	1.27;

1.27
date	2000.11.08.20.55.21;	author wilson;	state Exp;
branches;
next	1.26;

1.26
date	2000.11.07.01.21.10;	author wilson;	state Exp;
branches;
next	1.25;

1.25
date	2000.11.01.00.00.34;	author wilson;	state Exp;
branches;
next	1.24;

1.24
date	2000.10.31.10.30.11;	author bernds;	state Exp;
branches;
next	1.23;

1.23
date	2000.10.05.21.55.24;	author wilson;	state Exp;
branches;
next	1.22;

1.22
date	2000.10.04.00.28.45;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2000.09.22.19.43.47;	author wilson;	state Exp;
branches;
next	1.20;

1.20
date	2000.09.16.00.56.47;	author kazu;	state Exp;
branches;
next	1.19;

1.19
date	2000.09.14.21.37.02;	author twall;	state Exp;
branches;
next	1.18;

1.18
date	2000.09.06.02.36.20;	author kazu;	state Exp;
branches;
next	1.17;

1.17
date	2000.09.03.09.36.57;	author rth;	state Exp;
branches;
next	1.16;

1.16
date	2000.09.03.00.04.40;	author kazu;	state Exp;
branches;
next	1.15;

1.15
date	2000.09.02.01.02.41;	author rth;	state Exp;
branches;
next	1.14;

1.14
date	2000.08.23.20.36.38;	author wilson;	state Exp;
branches;
next	1.13;

1.13
date	2000.08.16.23.20.14;	author wilson;	state Exp;
branches;
next	1.12;

1.12
date	2000.08.14.20.13.39;	author wilson;	state Exp;
branches;
next	1.11;

1.11
date	2000.08.07.21.50.08;	author rth;	state Exp;
branches;
next	1.10;

1.10
date	2000.08.02.21.24.54;	author wilson;	state Exp;
branches;
next	1.9;

1.9
date	2000.07.07.16.58.24;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.23.03.31.06;	author twall;	state Exp;
branches;
next	1.7;

1.7
date	2000.06.08.17.07.48;	author wilson;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.07.23.14.22;	author wilson;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.25.02.00.14;	author wilson;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.23.01.48.04;	author rth;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.09.01.54.37;	author wilson;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.23.02.53.35;	author twall;	state Exp;
branches;
next	1.1;

1.1
date	2000.04.21.20.22.22;	author wilson;	state Exp;
branches;
next	;

1.219.2.1
date	2012.09.04.13.57.44;	author gingold;	state Exp;
branches;
next	;

1.209.2.1
date	2009.10.13.11.52.35;	author gingold;	state Exp;
branches;
next	;

1.149.2.1
date	2005.04.20.07.30.24;	author jbeulich;	state Exp;
branches;
next	1.149.2.2;

1.149.2.2
date	2005.05.19.15.43.04;	author jbeulich;	state Exp;
branches;
next	;

1.101.4.1
date	2004.04.09.18.28.11;	author drow;	state Exp;
branches;
next	;

1.69.2.1
date	2002.10.31.09.32.05;	author obrien;	state Exp;
branches;
next	;

1.64.2.1
date	2002.02.22.11.57.38;	author nickc;	state Exp;
branches;
next	1.64.2.2;

1.64.2.2
date	2002.03.28.06.25.03;	author amodra;	state Exp;
branches;
next	1.64.2.3;

1.64.2.3
date	2002.04.02.00.39.01;	author rth;	state Exp;
branches;
next	;

1.38.2.1
date	2001.02.06.03.52.46;	author wilson;	state Exp;
branches;
next	1.38.2.2;

1.38.2.2
date	2001.02.10.01.49.50;	author rth;	state Exp;
branches;
next	1.38.2.3;

1.38.2.3
date	2001.02.14.09.57.29;	author pb;	state Exp;
branches;
next	1.38.2.4;

1.38.2.4
date	2001.02.21.22.42.47;	author wilson;	state Exp;
branches;
next	1.38.2.5;

1.38.2.5
date	2001.02.22.03.27.12;	author wilson;	state Exp;
branches;
next	1.38.2.6;

1.38.2.6
date	2001.03.16.04.58.10;	author wilson;	state Exp;
branches;
next	1.38.2.7;

1.38.2.7
date	2001.04.15.08.01.04;	author wilson;	state Exp;
branches;
next	1.38.2.8;

1.38.2.8
date	2001.04.27.21.44.21;	author wilson;	state Exp;
branches;
next	1.38.2.9;

1.38.2.9
date	2001.05.10.00.20.41;	author rth;	state Exp;
branches;
next	1.38.2.10;

1.38.2.10
date	2001.06.07.03.15.29;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.222
log
@	PR binutils/15834
	Fix typos:
---
 bfd/bfdio.c                                  |  2 +-
 bfd/elf32-spu.c                              |  2 +-
 bfd/elfnn-aarch64.c                          |  2 +-
 binutils/od-xcoff.c                          |  2 +-
 config/tcl.m4                                |  2 +-
 gas/config/tc-ia64.c                         |  2 +-
 gas/config/tc-sparc.c                        |  2 +-
 gas/config/tc-z80.c                          | 12 ++++++------
 gas/doc/c-i386.texi                          |  6 +++---
 gas/doc/c-m32r.texi                          |  2 +-
 gas/testsuite/gas/d10v/instruction_packing.d |  2 +-
 gas/testsuite/gas/z80/atend.d                |  2 +-
 gold/object.h                                |  2 +-
 include/gdb/remote-sim.h                     |  2 +-
 include/opcode/ChangeLog                     |  2 +-
 include/opcode/i960.h                        |  2 +-
 ld/testsuite/ld-mips-elf/mips16-pic-1.inc    |  2 +-
 opcodes/aarch64-asm.c                        |  2 +-
 opcodes/aarch64-dis.c                        |  2 +-
 opcodes/msp430-dis.c                         |  2 +-
@
text
@/* tc-ia64.c -- Assembler for the HP/Intel IA-64 architecture.
   Copyright 1998-2013 Free Software Foundation, Inc.
   Contributed by David Mosberger-Tang <davidm@@hpl.hp.com>

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 51 Franklin Street - Fifth Floor,
   Boston, MA 02110-1301, USA.  */

/*
  TODO:

  - optional operands
  - directives:
	.eb
	.estate
	.lb
	.popsection
	.previous
	.psr
	.pushsection
  - labels are wrong if automatic alignment is introduced
    (e.g., checkout the second real10 definition in test-data.s)
  - DV-related stuff:
	<reg>.safe_across_calls and any other DV-related directives I don't
	  have documentation for.
	verify mod-sched-brs reads/writes are checked/marked (and other
	notes)

 */

#include "as.h"
#include "safe-ctype.h"
#include "dwarf2dbg.h"
#include "subsegs.h"

#include "opcode/ia64.h"

#include "elf/ia64.h"
#include "bfdver.h"
#include <time.h>

#ifdef HAVE_LIMITS_H
#include <limits.h>
#endif

#define NELEMS(a)	((int) (sizeof (a)/sizeof ((a)[0])))

/* Some systems define MIN in, e.g., param.h.  */
#undef MIN
#define MIN(a,b)	((a) < (b) ? (a) : (b))

#define NUM_SLOTS	4
#define PREV_SLOT	md.slot[(md.curr_slot + NUM_SLOTS - 1) % NUM_SLOTS]
#define CURR_SLOT	md.slot[md.curr_slot]

#define O_pseudo_fixup (O_max + 1)

enum special_section
  {
    /* IA-64 ABI section pseudo-ops.  */
    SPECIAL_SECTION_BSS = 0,
    SPECIAL_SECTION_SBSS,
    SPECIAL_SECTION_SDATA,
    SPECIAL_SECTION_RODATA,
    SPECIAL_SECTION_COMMENT,
    SPECIAL_SECTION_UNWIND,
    SPECIAL_SECTION_UNWIND_INFO,
    /* HPUX specific section pseudo-ops.  */
    SPECIAL_SECTION_INIT_ARRAY,
    SPECIAL_SECTION_FINI_ARRAY,
  };

enum reloc_func
  {
    FUNC_DTP_MODULE,
    FUNC_DTP_RELATIVE,
    FUNC_FPTR_RELATIVE,
    FUNC_GP_RELATIVE,
    FUNC_LT_RELATIVE,
    FUNC_LT_RELATIVE_X,
    FUNC_PC_RELATIVE,
    FUNC_PLT_RELATIVE,
    FUNC_SEC_RELATIVE,
    FUNC_SEG_RELATIVE,
    FUNC_TP_RELATIVE,
    FUNC_LTV_RELATIVE,
    FUNC_LT_FPTR_RELATIVE,
    FUNC_LT_DTP_MODULE,
    FUNC_LT_DTP_RELATIVE,
    FUNC_LT_TP_RELATIVE,
    FUNC_IPLT_RELOC,
#ifdef TE_VMS
    FUNC_SLOTCOUNT_RELOC,
#endif
  };

enum reg_symbol
  {
    REG_GR	= 0,
    REG_FR	= (REG_GR + 128),
    REG_AR	= (REG_FR + 128),
    REG_CR	= (REG_AR + 128),
    REG_DAHR	= (REG_CR + 128),
    REG_P	= (REG_DAHR + 8),
    REG_BR	= (REG_P  + 64),
    REG_IP	= (REG_BR + 8),
    REG_CFM,
    REG_PR,
    REG_PR_ROT,
    REG_PSR,
    REG_PSR_L,
    REG_PSR_UM,
    /* The following are pseudo-registers for use by gas only.  */
    IND_CPUID,
    IND_DBR,
    IND_DTR,
    IND_ITR,
    IND_IBR,
    IND_MSR,
    IND_PKR,
    IND_PMC,
    IND_PMD,
    IND_DAHR,
    IND_RR,
    /* The following pseudo-registers are used for unwind directives only:  */
    REG_PSP,
    REG_PRIUNAT,
    REG_NUM
  };

enum dynreg_type
  {
    DYNREG_GR = 0,	/* dynamic general purpose register */
    DYNREG_FR,		/* dynamic floating point register */
    DYNREG_PR,		/* dynamic predicate register */
    DYNREG_NUM_TYPES
  };

enum operand_match_result
  {
    OPERAND_MATCH,
    OPERAND_OUT_OF_RANGE,
    OPERAND_MISMATCH
  };

/* On the ia64, we can't know the address of a text label until the
   instructions are packed into a bundle.  To handle this, we keep
   track of the list of labels that appear in front of each
   instruction.  */
struct label_fix
{
  struct label_fix *next;
  struct symbol *sym;
  bfd_boolean dw2_mark_labels;
};

#ifdef TE_VMS
/* An internally used relocation.  */
#define DUMMY_RELOC_IA64_SLOTCOUNT	(BFD_RELOC_UNUSED + 1)
#endif

/* This is the endianness of the current section.  */
extern int target_big_endian;

/* This is the default endianness.  */
static int default_big_endian = TARGET_BYTES_BIG_ENDIAN;

void (*ia64_number_to_chars) (char *, valueT, int);

static void ia64_float_to_chars_bigendian (char *, LITTLENUM_TYPE *, int);
static void ia64_float_to_chars_littleendian (char *, LITTLENUM_TYPE *, int);

static void (*ia64_float_to_chars) (char *, LITTLENUM_TYPE *, int);

static struct hash_control *alias_hash;
static struct hash_control *alias_name_hash;
static struct hash_control *secalias_hash;
static struct hash_control *secalias_name_hash;

/* List of chars besides those in app.c:symbol_chars that can start an
   operand.  Used to prevent the scrubber eating vital white-space.  */
const char ia64_symbol_chars[] = "@@?";

/* Characters which always start a comment.  */
const char comment_chars[] = "";

/* Characters which start a comment at the beginning of a line.  */
const char line_comment_chars[] = "#";

/* Characters which may be used to separate multiple commands on a
   single line.  */
const char line_separator_chars[] = ";{}";

/* Characters which are used to indicate an exponent in a floating
   point number.  */
const char EXP_CHARS[] = "eE";

/* Characters which mean that a number is a floating point constant,
   as in 0d1.0.  */
const char FLT_CHARS[] = "rRsSfFdDxXpP";

/* ia64-specific option processing:  */

const char *md_shortopts = "m:N:x::";

struct option md_longopts[] =
  {
#define OPTION_MCONSTANT_GP (OPTION_MD_BASE + 1)
    {"mconstant-gp", no_argument, NULL, OPTION_MCONSTANT_GP},
#define OPTION_MAUTO_PIC (OPTION_MD_BASE + 2)
    {"mauto-pic", no_argument, NULL, OPTION_MAUTO_PIC}
  };

size_t md_longopts_size = sizeof (md_longopts);

static struct
  {
    struct hash_control *pseudo_hash;	/* pseudo opcode hash table */
    struct hash_control *reg_hash;	/* register name hash table */
    struct hash_control *dynreg_hash;	/* dynamic register hash table */
    struct hash_control *const_hash;	/* constant hash table */
    struct hash_control *entry_hash;    /* code entry hint hash table */

    /* If X_op is != O_absent, the registername for the instruction's
       qualifying predicate.  If NULL, p0 is assumed for instructions
       that are predictable.  */
    expressionS qp;

    /* Optimize for which CPU.  */
    enum
      {
	itanium1,
	itanium2
      } tune;

    /* What to do when hint.b is used.  */
    enum
      {
	hint_b_error,
	hint_b_warning,
	hint_b_ok
      } hint_b;

    unsigned int
      manual_bundling : 1,
      debug_dv: 1,
      detect_dv: 1,
      explicit_mode : 1,            /* which mode we're in */
      default_explicit_mode : 1,    /* which mode is the default */
      mode_explicitly_set : 1,      /* was the current mode explicitly set? */
      auto_align : 1,
      keep_pending_output : 1;

    /* What to do when something is wrong with unwind directives.  */
    enum
      {
	unwind_check_warning,
	unwind_check_error
      } unwind_check;

    /* Each bundle consists of up to three instructions.  We keep
       track of four most recent instructions so we can correctly set
       the end_of_insn_group for the last instruction in a bundle.  */
    int curr_slot;
    int num_slots_in_use;
    struct slot
      {
	unsigned int
	  end_of_insn_group : 1,
	  manual_bundling_on : 1,
	  manual_bundling_off : 1,
	  loc_directive_seen : 1;
	signed char user_template;	/* user-selected template, if any */
	unsigned char qp_regno;		/* qualifying predicate */
	/* This duplicates a good fraction of "struct fix" but we
	   can't use a "struct fix" instead since we can't call
	   fix_new_exp() until we know the address of the instruction.  */
	int num_fixups;
	struct insn_fix
	  {
	    bfd_reloc_code_real_type code;
	    enum ia64_opnd opnd;	/* type of operand in need of fix */
	    unsigned int is_pcrel : 1;	/* is operand pc-relative? */
	    expressionS expr;		/* the value to be inserted */
	  }
	fixup[2];			/* at most two fixups per insn */
	struct ia64_opcode *idesc;
	struct label_fix *label_fixups;
	struct label_fix *tag_fixups;
	struct unw_rec_list *unwind_record;	/* Unwind directive.  */
	expressionS opnd[6];
	char *src_file;
	unsigned int src_line;
	struct dwarf2_line_info debug_line;
      }
    slot[NUM_SLOTS];

    segT last_text_seg;

    struct dynreg
      {
	struct dynreg *next;		/* next dynamic register */
	const char *name;
	unsigned short base;		/* the base register number */
	unsigned short num_regs;	/* # of registers in this set */
      }
    *dynreg[DYNREG_NUM_TYPES], in, loc, out, rot;

    flagword flags;			/* ELF-header flags */

    struct mem_offset {
      unsigned hint:1;              /* is this hint currently valid? */
      bfd_vma offset;               /* mem.offset offset */
      bfd_vma base;                 /* mem.offset base */
    } mem_offset;

    int path;                       /* number of alt. entry points seen */
    const char **entry_labels;      /* labels of all alternate paths in
				       the current DV-checking block.  */
    int maxpaths;                   /* size currently allocated for
				       entry_labels */

    int pointer_size;       /* size in bytes of a pointer */
    int pointer_size_shift; /* shift size of a pointer for alignment */

    symbolS *indregsym[IND_RR - IND_CPUID + 1];
  }
md;

/* These are not const, because they are modified to MMI for non-itanium1
   targets below.  */
/* MFI bundle of nops.  */
static unsigned char le_nop[16] =
{
  0x0c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00
};
/* MFI bundle of nops with stop-bit.  */
static unsigned char le_nop_stop[16] =
{
  0x0d, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
  0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00
};

/* application registers:  */

#define AR_K0		0
#define AR_K7		7
#define AR_RSC		16
#define AR_BSP		17
#define AR_BSPSTORE	18
#define AR_RNAT		19
#define AR_FCR		21
#define AR_EFLAG	24
#define AR_CSD		25
#define AR_SSD		26
#define AR_CFLG		27
#define AR_FSR		28
#define AR_FIR		29
#define AR_FDR		30
#define AR_CCV		32
#define AR_UNAT		36
#define AR_FPSR		40
#define AR_ITC		44
#define AR_RUC		45
#define AR_PFS		64
#define AR_LC		65
#define AR_EC		66

static const struct
  {
    const char *name;
    unsigned int regnum;
  }
ar[] =
  {
    {"ar.k0",		AR_K0},		{"ar.k1",	AR_K0 + 1},
    {"ar.k2",		AR_K0 + 2},	{"ar.k3",	AR_K0 + 3},
    {"ar.k4",		AR_K0 + 4},	{"ar.k5",	AR_K0 + 5},
    {"ar.k6",		AR_K0 + 6},	{"ar.k7",	AR_K7},
    {"ar.rsc",		AR_RSC},	{"ar.bsp",	AR_BSP},
    {"ar.bspstore",	AR_BSPSTORE},	{"ar.rnat",	AR_RNAT},
    {"ar.fcr",		AR_FCR},	{"ar.eflag",	AR_EFLAG},
    {"ar.csd",		AR_CSD},	{"ar.ssd",	AR_SSD},
    {"ar.cflg",		AR_CFLG},	{"ar.fsr",	AR_FSR},
    {"ar.fir",		AR_FIR},	{"ar.fdr",	AR_FDR},
    {"ar.ccv",		AR_CCV},	{"ar.unat",	AR_UNAT},
    {"ar.fpsr",		AR_FPSR},	{"ar.itc",	AR_ITC},
    {"ar.ruc",		AR_RUC},	{"ar.pfs",	AR_PFS},
    {"ar.lc",		AR_LC},		{"ar.ec",	AR_EC},
  };

/* control registers:  */

#define CR_DCR           0
#define CR_ITM           1
#define CR_IVA           2
#define CR_PTA           8
#define CR_GPTA          9
#define CR_IPSR         16
#define CR_ISR          17
#define CR_IIP          19
#define CR_IFA          20
#define CR_ITIR         21
#define CR_IIPA         22
#define CR_IFS          23
#define CR_IIM          24
#define CR_IHA          25
#define CR_IIB0         26
#define CR_IIB1         27
#define CR_LID          64
#define CR_IVR          65
#define CR_TPR          66
#define CR_EOI          67
#define CR_IRR0         68
#define CR_IRR3         71
#define CR_ITV          72
#define CR_PMV          73
#define CR_CMCV         74
#define CR_LRR0         80
#define CR_LRR1         81

static const struct
  {
    const char *name;
    unsigned int regnum;
  }
cr[] =
  {
    {"cr.dcr",	CR_DCR},
    {"cr.itm",	CR_ITM},
    {"cr.iva",	CR_IVA},
    {"cr.pta",	CR_PTA},
    {"cr.gpta",	CR_GPTA},
    {"cr.ipsr",	CR_IPSR},
    {"cr.isr",	CR_ISR},
    {"cr.iip",	CR_IIP},
    {"cr.ifa",	CR_IFA},
    {"cr.itir",	CR_ITIR},
    {"cr.iipa",	CR_IIPA},
    {"cr.ifs",	CR_IFS},
    {"cr.iim",	CR_IIM},
    {"cr.iha",	CR_IHA},
    {"cr.iib0",	CR_IIB0},
    {"cr.iib1",	CR_IIB1},
    {"cr.lid",	CR_LID},
    {"cr.ivr",	CR_IVR},
    {"cr.tpr",	CR_TPR},
    {"cr.eoi",	CR_EOI},
    {"cr.irr0",	CR_IRR0},
    {"cr.irr1",	CR_IRR0 + 1},
    {"cr.irr2",	CR_IRR0 + 2},
    {"cr.irr3",	CR_IRR3},
    {"cr.itv",	CR_ITV},
    {"cr.pmv",	CR_PMV},
    {"cr.cmcv",	CR_CMCV},
    {"cr.lrr0",	CR_LRR0},
    {"cr.lrr1",	CR_LRR1}
  };

#define PSR_MFL         4
#define PSR_IC          13
#define PSR_DFL         18
#define PSR_CPL         32

static const struct const_desc
  {
    const char *name;
    valueT value;
  }
const_bits[] =
  {
    /* PSR constant masks:  */

    /* 0: reserved */
    {"psr.be",	((valueT) 1) << 1},
    {"psr.up",	((valueT) 1) << 2},
    {"psr.ac",	((valueT) 1) << 3},
    {"psr.mfl",	((valueT) 1) << 4},
    {"psr.mfh",	((valueT) 1) << 5},
    /* 6-12: reserved */
    {"psr.ic",	((valueT) 1) << 13},
    {"psr.i",	((valueT) 1) << 14},
    {"psr.pk",	((valueT) 1) << 15},
    /* 16: reserved */
    {"psr.dt",	((valueT) 1) << 17},
    {"psr.dfl",	((valueT) 1) << 18},
    {"psr.dfh",	((valueT) 1) << 19},
    {"psr.sp",	((valueT) 1) << 20},
    {"psr.pp",	((valueT) 1) << 21},
    {"psr.di",	((valueT) 1) << 22},
    {"psr.si",	((valueT) 1) << 23},
    {"psr.db",	((valueT) 1) << 24},
    {"psr.lp",	((valueT) 1) << 25},
    {"psr.tb",	((valueT) 1) << 26},
    {"psr.rt",	((valueT) 1) << 27},
    /* 28-31: reserved */
    /* 32-33: cpl (current privilege level) */
    {"psr.is",	((valueT) 1) << 34},
    {"psr.mc",	((valueT) 1) << 35},
    {"psr.it",	((valueT) 1) << 36},
    {"psr.id",	((valueT) 1) << 37},
    {"psr.da",	((valueT) 1) << 38},
    {"psr.dd",	((valueT) 1) << 39},
    {"psr.ss",	((valueT) 1) << 40},
    /* 41-42: ri (restart instruction) */
    {"psr.ed",	((valueT) 1) << 43},
    {"psr.bn",	((valueT) 1) << 44},
  };

/* indirect register-sets/memory:  */

static const struct
  {
    const char *name;
    unsigned int regnum;
  }
indirect_reg[] =
  {
    { "CPUID",	IND_CPUID },
    { "cpuid",	IND_CPUID },
    { "dbr",	IND_DBR },
    { "dtr",	IND_DTR },
    { "itr",	IND_ITR },
    { "ibr",	IND_IBR },
    { "msr",	IND_MSR },
    { "pkr",	IND_PKR },
    { "pmc",	IND_PMC },
    { "pmd",	IND_PMD },
    { "dahr",	IND_DAHR },
    { "rr",	IND_RR },
  };

/* Pseudo functions used to indicate relocation types (these functions
   start with an at sign (@@).  */
static struct
  {
    const char *name;
    enum pseudo_type
      {
	PSEUDO_FUNC_NONE,
	PSEUDO_FUNC_RELOC,
	PSEUDO_FUNC_CONST,
	PSEUDO_FUNC_REG,
	PSEUDO_FUNC_FLOAT
      }
    type;
    union
      {
	unsigned long ival;
	symbolS *sym;
      }
    u;
  }
pseudo_func[] =
  {
    /* reloc pseudo functions (these must come first!):  */
    { "dtpmod",	PSEUDO_FUNC_RELOC, { 0 } },
    { "dtprel",	PSEUDO_FUNC_RELOC, { 0 } },
    { "fptr",	PSEUDO_FUNC_RELOC, { 0 } },
    { "gprel",	PSEUDO_FUNC_RELOC, { 0 } },
    { "ltoff",	PSEUDO_FUNC_RELOC, { 0 } },
    { "ltoffx",	PSEUDO_FUNC_RELOC, { 0 } },
    { "pcrel",	PSEUDO_FUNC_RELOC, { 0 } },
    { "pltoff",	PSEUDO_FUNC_RELOC, { 0 } },
    { "secrel",	PSEUDO_FUNC_RELOC, { 0 } },
    { "segrel",	PSEUDO_FUNC_RELOC, { 0 } },
    { "tprel",	PSEUDO_FUNC_RELOC, { 0 } },
    { "ltv",	PSEUDO_FUNC_RELOC, { 0 } },
    { NULL, 0, { 0 } },	/* placeholder for FUNC_LT_FPTR_RELATIVE */
    { NULL, 0, { 0 } },	/* placeholder for FUNC_LT_DTP_MODULE */
    { NULL, 0, { 0 } },	/* placeholder for FUNC_LT_DTP_RELATIVE */
    { NULL, 0, { 0 } },	/* placeholder for FUNC_LT_TP_RELATIVE */
    { "iplt",	PSEUDO_FUNC_RELOC, { 0 } },
#ifdef TE_VMS
    { "slotcount", PSEUDO_FUNC_RELOC, { 0 } },
#endif

    /* mbtype4 constants:  */
    { "alt",	PSEUDO_FUNC_CONST, { 0xa } },
    { "brcst",	PSEUDO_FUNC_CONST, { 0x0 } },
    { "mix",	PSEUDO_FUNC_CONST, { 0x8 } },
    { "rev",	PSEUDO_FUNC_CONST, { 0xb } },
    { "shuf",	PSEUDO_FUNC_CONST, { 0x9 } },

    /* fclass constants:  */
    { "nat",	PSEUDO_FUNC_CONST, { 0x100 } },
    { "qnan",	PSEUDO_FUNC_CONST, { 0x080 } },
    { "snan",	PSEUDO_FUNC_CONST, { 0x040 } },
    { "pos",	PSEUDO_FUNC_CONST, { 0x001 } },
    { "neg",	PSEUDO_FUNC_CONST, { 0x002 } },
    { "zero",	PSEUDO_FUNC_CONST, { 0x004 } },
    { "unorm",	PSEUDO_FUNC_CONST, { 0x008 } },
    { "norm",	PSEUDO_FUNC_CONST, { 0x010 } },
    { "inf",	PSEUDO_FUNC_CONST, { 0x020 } },

    { "natval",	PSEUDO_FUNC_CONST, { 0x100 } }, /* old usage */

    /* hint constants: */
    { "pause",	PSEUDO_FUNC_CONST, { 0x0 } },
    { "priority", PSEUDO_FUNC_CONST, { 0x1 } },

    /* tf constants: */
    { "clz",	PSEUDO_FUNC_CONST, {  32 } },
    { "mpy",	PSEUDO_FUNC_CONST, {  33 } },
    { "datahints",	PSEUDO_FUNC_CONST, {  34 } },

    /* unwind-related constants:  */
    { "svr4",	PSEUDO_FUNC_CONST,	{ ELFOSABI_NONE } },
    { "hpux",	PSEUDO_FUNC_CONST,	{ ELFOSABI_HPUX } },
    { "nt",	PSEUDO_FUNC_CONST,	{ 2 } },		/* conflicts w/ELFOSABI_NETBSD */
    { "linux",	PSEUDO_FUNC_CONST,	{ ELFOSABI_GNU } },
    { "freebsd", PSEUDO_FUNC_CONST,	{ ELFOSABI_FREEBSD } },
    { "openvms", PSEUDO_FUNC_CONST,	{ ELFOSABI_OPENVMS } },
    { "nsk",	PSEUDO_FUNC_CONST,	{ ELFOSABI_NSK } },

    /* unwind-related registers:  */
    { "priunat",PSEUDO_FUNC_REG, { REG_PRIUNAT } }
  };

/* 41-bit nop opcodes (one per unit):  */
static const bfd_vma nop[IA64_NUM_UNITS] =
  {
    0x0000000000LL,	/* NIL => break 0 */
    0x0008000000LL,	/* I-unit nop */
    0x0008000000LL,	/* M-unit nop */
    0x4000000000LL,	/* B-unit nop */
    0x0008000000LL,	/* F-unit nop */
    0x0000000000LL,	/* L-"unit" nop immediate */
    0x0008000000LL,	/* X-unit nop */
  };

/* Can't be `const' as it's passed to input routines (which have the
   habit of setting temporary sentinels.  */
static char special_section_name[][20] =
  {
    {".bss"}, {".sbss"}, {".sdata"}, {".rodata"}, {".comment"},
    {".IA_64.unwind"}, {".IA_64.unwind_info"},
    {".init_array"}, {".fini_array"}
  };

/* The best template for a particular sequence of up to three
   instructions:  */
#define N	IA64_NUM_TYPES
static unsigned char best_template[N][N][N];
#undef N

/* Resource dependencies currently in effect */
static struct rsrc {
  int depind;                       /* dependency index */
  const struct ia64_dependency *dependency; /* actual dependency */
  unsigned specific:1,              /* is this a specific bit/regno? */
    link_to_qp_branch:1;           /* will a branch on the same QP clear it?*/
  int index;                        /* specific regno/bit within dependency */
  int note;                         /* optional qualifying note (0 if none) */
#define STATE_NONE 0
#define STATE_STOP 1
#define STATE_SRLZ 2
  int insn_srlz;                    /* current insn serialization state */
  int data_srlz;                    /* current data serialization state */
  int qp_regno;                     /* qualifying predicate for this usage */
  char *file;                       /* what file marked this dependency */
  unsigned int line;                /* what line marked this dependency */
  struct mem_offset mem_offset;     /* optional memory offset hint */
  enum { CMP_NONE, CMP_OR, CMP_AND } cmp_type; /* OR or AND compare? */
  int path;                         /* corresponding code entry index */
} *regdeps = NULL;
static int regdepslen = 0;
static int regdepstotlen = 0;
static const char *dv_mode[] = { "RAW", "WAW", "WAR" };
static const char *dv_sem[] = { "none", "implied", "impliedf",
				"data", "instr", "specific", "stop", "other" };
static const char *dv_cmp_type[] = { "none", "OR", "AND" };

/* Current state of PR mutexation */
static struct qpmutex {
  valueT prmask;
  int path;
} *qp_mutexes = NULL;          /* QP mutex bitmasks */
static int qp_mutexeslen = 0;
static int qp_mutexestotlen = 0;
static valueT qp_safe_across_calls = 0;

/* Current state of PR implications */
static struct qp_imply {
  unsigned p1:6;
  unsigned p2:6;
  unsigned p2_branched:1;
  int path;
} *qp_implies = NULL;
static int qp_implieslen = 0;
static int qp_impliestotlen = 0;

/* Keep track of static GR values so that indirect register usage can
   sometimes be tracked.  */
static struct gr {
  unsigned known:1;
  int path;
  valueT value;
} gr_values[128] = {
  {
    1,
#ifdef INT_MAX
    INT_MAX,
#else
    (((1 << (8 * sizeof(gr_values->path) - 2)) - 1) << 1) + 1,
#endif
    0
  }
};

/* Remember the alignment frag.  */
static fragS *align_frag;

/* These are the routines required to output the various types of
   unwind records.  */

/* A slot_number is a frag address plus the slot index (0-2).  We use the
   frag address here so that if there is a section switch in the middle of
   a function, then instructions emitted to a different section are not
   counted.  Since there may be more than one frag for a function, this
   means we also need to keep track of which frag this address belongs to
   so we can compute inter-frag distances.  This also nicely solves the
   problem with nops emitted for align directives, which can't easily be
   counted, but can easily be derived from frag sizes.  */

typedef struct unw_rec_list {
  unwind_record r;
  unsigned long slot_number;
  fragS *slot_frag;
  struct unw_rec_list *next;
} unw_rec_list;

#define SLOT_NUM_NOT_SET        (unsigned)-1

/* Linked list of saved prologue counts.  A very poor
   implementation of a map from label numbers to prologue counts.  */
typedef struct label_prologue_count
{
  struct label_prologue_count *next;
  unsigned long label_number;
  unsigned int prologue_count;
} label_prologue_count;

typedef struct proc_pending
{
  symbolS *sym;
  struct proc_pending *next;
} proc_pending;

static struct
{
  /* Maintain a list of unwind entries for the current function.  */
  unw_rec_list *list;
  unw_rec_list *tail;

  /* Any unwind entries that should be attached to the current slot
     that an insn is being constructed for.  */
  unw_rec_list *current_entry;

  /* These are used to create the unwind table entry for this function.  */
  proc_pending proc_pending;
  symbolS *info;		/* pointer to unwind info */
  symbolS *personality_routine;
  segT saved_text_seg;
  subsegT saved_text_subseg;
  unsigned int force_unwind_entry : 1;	/* force generation of unwind entry? */

  /* TRUE if processing unwind directives in a prologue region.  */
  unsigned int prologue : 1;
  unsigned int prologue_mask : 4;
  unsigned int prologue_gr : 7;
  unsigned int body : 1;
  unsigned int insn : 1;
  unsigned int prologue_count;	/* number of .prologues seen so far */
  /* Prologue counts at previous .label_state directives.  */
  struct label_prologue_count * saved_prologue_counts;

  /* List of split up .save-s.  */
  unw_p_record *pending_saves;
} unwind;

/* The input value is a negated offset from psp, and specifies an address
   psp - offset.  The encoded value is psp + 16 - (4 * offset).  Thus we
   must add 16 and divide by 4 to get the encoded value.  */

#define ENCODED_PSP_OFFSET(OFFSET) (((OFFSET) + 16) / 4)

typedef void (*vbyte_func) (int, char *, char *);

/* Forward declarations:  */
static void dot_alias (int);
static int parse_operand_and_eval (expressionS *, int);
static void emit_one_bundle (void);
static bfd_reloc_code_real_type ia64_gen_real_reloc_type (struct symbol *,
							  bfd_reloc_code_real_type);
static void insn_group_break (int, int, int);
static void add_qp_mutex (valueT);
static void add_qp_imply (int, int);
static void clear_qp_mutex (valueT);
static void clear_qp_implies (valueT, valueT);
static void print_dependency (const char *, int);
static void instruction_serialization (void);
static void data_serialization (void);
static void output_R3_format (vbyte_func, unw_record_type, unsigned long);
static void output_B3_format (vbyte_func, unsigned long, unsigned long);
static void output_B4_format (vbyte_func, unw_record_type, unsigned long);
static void free_saved_prologue_counts (void);

/* Determine if application register REGNUM resides only in the integer
   unit (as opposed to the memory unit).  */
static int
ar_is_only_in_integer_unit (int reg)
{
  reg -= REG_AR;
  return reg >= 64 && reg <= 111;
}

/* Determine if application register REGNUM resides only in the memory 
   unit (as opposed to the integer unit).  */
static int
ar_is_only_in_memory_unit (int reg)
{
  reg -= REG_AR;
  return reg >= 0 && reg <= 47;
}

/* Switch to section NAME and create section if necessary.  It's
   rather ugly that we have to manipulate input_line_pointer but I
   don't see any other way to accomplish the same thing without
   changing obj-elf.c (which may be the Right Thing, in the end).  */
static void
set_section (char *name)
{
  char *saved_input_line_pointer;

  saved_input_line_pointer = input_line_pointer;
  input_line_pointer = name;
  obj_elf_section (0);
  input_line_pointer = saved_input_line_pointer;
}

/* Map 's' to SHF_IA_64_SHORT.  */

bfd_vma
ia64_elf_section_letter (int letter, char **ptr_msg)
{
  if (letter == 's')
    return SHF_IA_64_SHORT;
  else if (letter == 'o')
    return SHF_LINK_ORDER;
#ifdef TE_VMS
  else if (letter == 'O')
    return SHF_IA_64_VMS_OVERLAID;
  else if (letter == 'g')
    return SHF_IA_64_VMS_GLOBAL;
#endif

  *ptr_msg = _("bad .section directive: want a,o,s,w,x,M,S,G,T in string");
  return -1;
}

/* Map SHF_IA_64_SHORT to SEC_SMALL_DATA.  */

flagword
ia64_elf_section_flags (flagword flags,
			bfd_vma attr,
			int type ATTRIBUTE_UNUSED)
{
  if (attr & SHF_IA_64_SHORT)
    flags |= SEC_SMALL_DATA;
  return flags;
}

int
ia64_elf_section_type (const char *str, size_t len)
{
#define STREQ(s) ((len == sizeof (s) - 1) && (strncmp (str, s, sizeof (s) - 1) == 0))

  if (STREQ (ELF_STRING_ia64_unwind_info))
    return SHT_PROGBITS;

  if (STREQ (ELF_STRING_ia64_unwind_info_once))
    return SHT_PROGBITS;

  if (STREQ (ELF_STRING_ia64_unwind))
    return SHT_IA_64_UNWIND;

  if (STREQ (ELF_STRING_ia64_unwind_once))
    return SHT_IA_64_UNWIND;

  if (STREQ ("unwind"))
    return SHT_IA_64_UNWIND;

  return -1;
#undef STREQ
}

static unsigned int
set_regstack (unsigned int ins,
	      unsigned int locs,
	      unsigned int outs,
	      unsigned int rots)
{
  /* Size of frame.  */
  unsigned int sof;

  sof = ins + locs + outs;
  if (sof > 96)
    {
      as_bad (_("Size of frame exceeds maximum of 96 registers"));
      return 0;
    }
  if (rots > sof)
    {
      as_warn (_("Size of rotating registers exceeds frame size"));
      return 0;
    }
  md.in.base = REG_GR + 32;
  md.loc.base = md.in.base + ins;
  md.out.base = md.loc.base + locs;

  md.in.num_regs  = ins;
  md.loc.num_regs = locs;
  md.out.num_regs = outs;
  md.rot.num_regs = rots;
  return sof;
}

void
ia64_flush_insns (void)
{
  struct label_fix *lfix;
  segT saved_seg;
  subsegT saved_subseg;
  unw_rec_list *ptr;
  bfd_boolean mark;

  if (!md.last_text_seg)
    return;

  saved_seg = now_seg;
  saved_subseg = now_subseg;

  subseg_set (md.last_text_seg, 0);

  while (md.num_slots_in_use > 0)
    emit_one_bundle ();		/* force out queued instructions */

  /* In case there are labels following the last instruction, resolve
     those now.  */
  mark = FALSE;
  for (lfix = CURR_SLOT.label_fixups; lfix; lfix = lfix->next)
    {
      symbol_set_value_now (lfix->sym);
      mark |= lfix->dw2_mark_labels;
    }
  if (mark)
    {
      dwarf2_where (&CURR_SLOT.debug_line);
      CURR_SLOT.debug_line.flags |= DWARF2_FLAG_BASIC_BLOCK;
      dwarf2_gen_line_info (frag_now_fix (), &CURR_SLOT.debug_line);
      dwarf2_consume_line_info ();
    }
  CURR_SLOT.label_fixups = 0;

  for (lfix = CURR_SLOT.tag_fixups; lfix; lfix = lfix->next)
    symbol_set_value_now (lfix->sym);
  CURR_SLOT.tag_fixups = 0;

  /* In case there are unwind directives following the last instruction,
     resolve those now.  We only handle prologue, body, and endp directives
     here.  Give an error for others.  */
  for (ptr = unwind.current_entry; ptr; ptr = ptr->next)
    {
      switch (ptr->r.type)
	{
	case prologue:
	case prologue_gr:
	case body:
	case endp:
	  ptr->slot_number = (unsigned long) frag_more (0);
	  ptr->slot_frag = frag_now;
	  break;

	  /* Allow any record which doesn't have a "t" field (i.e.,
	     doesn't relate to a particular instruction).  */
	case unwabi:
	case br_gr:
	case copy_state:
	case fr_mem:
	case frgr_mem:
	case gr_gr:
	case gr_mem:
	case label_state:
	case rp_br:
	case spill_base:
	case spill_mask:
	  /* nothing */
	  break;

	default:
	  as_bad (_("Unwind directive not followed by an instruction."));
	  break;
	}
    }
  unwind.current_entry = NULL;

  subseg_set (saved_seg, saved_subseg);

  if (md.qp.X_op == O_register)
    as_bad (_("qualifying predicate not followed by instruction"));
}

static void
ia64_do_align (int nbytes)
{
  char *saved_input_line_pointer = input_line_pointer;

  input_line_pointer = "";
  s_align_bytes (nbytes);
  input_line_pointer = saved_input_line_pointer;
}

void
ia64_cons_align (int nbytes)
{
  if (md.auto_align)
    {
      char *saved_input_line_pointer = input_line_pointer;
      input_line_pointer = "";
      s_align_bytes (nbytes);
      input_line_pointer = saved_input_line_pointer;
    }
}

#ifdef TE_VMS

/* .vms_common section, symbol, size, alignment  */

static void
obj_elf_vms_common (int ignore ATTRIBUTE_UNUSED)
{
  char *sec_name;
  char *sym_name;
  char c;
  offsetT size;
  offsetT cur_size;
  offsetT temp;
  symbolS *symbolP;
  segT current_seg = now_seg;
  subsegT current_subseg = now_subseg;
  offsetT log_align;

  /* Section name.  */
  sec_name = obj_elf_section_name ();
  if (sec_name == NULL)
    return;

  /* Symbol name.  */
  SKIP_WHITESPACE ();
  if (*input_line_pointer == ',')
    {
      input_line_pointer++;
      SKIP_WHITESPACE ();
    }
  else
    {
      as_bad (_("expected ',' after section name"));
      ignore_rest_of_line ();
      return;
    }

  sym_name = input_line_pointer;
  c = get_symbol_end ();

  if (input_line_pointer == sym_name)
    {
      *input_line_pointer = c;
      as_bad (_("expected symbol name"));
      ignore_rest_of_line ();
      return;
    }

  symbolP = symbol_find_or_make (sym_name);
  *input_line_pointer = c;

  if ((S_IS_DEFINED (symbolP) || symbol_equated_p (symbolP))
      && !S_IS_COMMON (symbolP))
    {
      as_bad (_("Ignoring attempt to re-define symbol"));
      ignore_rest_of_line ();
      return;
    }

  /* Symbol size.  */
  SKIP_WHITESPACE ();
  if (*input_line_pointer == ',')
    {
      input_line_pointer++;
      SKIP_WHITESPACE ();
    }
  else
    {
      as_bad (_("expected ',' after symbol name"));
      ignore_rest_of_line ();
      return;
    }

  temp = get_absolute_expression ();
  size = temp;
  size &= ((offsetT) 2 << (stdoutput->arch_info->bits_per_address - 1)) - 1;
  if (temp != size)
    {
      as_warn (_("size (%ld) out of range, ignored"), (long) temp);
      ignore_rest_of_line ();
      return;
    }

  /* Alignment.  */
  SKIP_WHITESPACE ();
  if (*input_line_pointer == ',')
    {
      input_line_pointer++;
      SKIP_WHITESPACE ();
    }
  else
    {
      as_bad (_("expected ',' after symbol size"));
      ignore_rest_of_line ();
      return;
    }

  log_align = get_absolute_expression ();

  demand_empty_rest_of_line ();

  obj_elf_change_section
    (sec_name, SHT_NOBITS,
     SHF_ALLOC | SHF_WRITE | SHF_IA_64_VMS_OVERLAID | SHF_IA_64_VMS_GLOBAL,
     0, NULL, 1, 0);

  S_SET_VALUE (symbolP, 0);
  S_SET_SIZE (symbolP, size);
  S_SET_EXTERNAL (symbolP);
  S_SET_SEGMENT (symbolP, now_seg);

  symbol_get_bfdsym (symbolP)->flags |= BSF_OBJECT;

  record_alignment (now_seg, log_align);

  cur_size = bfd_section_size (stdoutput, now_seg);
  if ((int) size > cur_size)
    {
      char *pfrag
        = frag_var (rs_fill, 1, 1, (relax_substateT)0, NULL,
                    (valueT)size - (valueT)cur_size, NULL);
      *pfrag = 0;
      bfd_section_size (stdoutput, now_seg) = size;
    }

  /* Switch back to current segment.  */
  subseg_set (current_seg, current_subseg);

#ifdef md_elf_section_change_hook
  md_elf_section_change_hook ();
#endif
}

#endif /* TE_VMS */

/* Output COUNT bytes to a memory location.  */
static char *vbyte_mem_ptr = NULL;

static void
output_vbyte_mem (int count, char *ptr, char *comment ATTRIBUTE_UNUSED)
{
  int x;
  if (vbyte_mem_ptr == NULL)
    abort ();

  if (count == 0)
    return;
  for (x = 0; x < count; x++)
    *(vbyte_mem_ptr++) = ptr[x];
}

/* Count the number of bytes required for records.  */
static int vbyte_count = 0;
static void
count_output (int count,
	      char *ptr ATTRIBUTE_UNUSED,
	      char *comment ATTRIBUTE_UNUSED)
{
  vbyte_count += count;
}

static void
output_R1_format (vbyte_func f, unw_record_type rtype, int rlen)
{
  int r = 0;
  char byte;
  if (rlen > 0x1f)
    {
      output_R3_format (f, rtype, rlen);
      return;
    }

  if (rtype == body)
    r = 1;
  else if (rtype != prologue)
    as_bad (_("record type is not valid"));

  byte = UNW_R1 | (r << 5) | (rlen & 0x1f);
  (*f) (1, &byte, NULL);
}

static void
output_R2_format (vbyte_func f, int mask, int grsave, unsigned long rlen)
{
  char bytes[20];
  int count = 2;
  mask = (mask & 0x0f);
  grsave = (grsave & 0x7f);

  bytes[0] = (UNW_R2 | (mask >> 1));
  bytes[1] = (((mask & 0x01) << 7) | grsave);
  count += output_leb128 (bytes + 2, rlen, 0);
  (*f) (count, bytes, NULL);
}

static void
output_R3_format (vbyte_func f, unw_record_type rtype, unsigned long rlen)
{
  int r = 0, count;
  char bytes[20];
  if (rlen <= 0x1f)
    {
      output_R1_format (f, rtype, rlen);
      return;
    }

  if (rtype == body)
    r = 1;
  else if (rtype != prologue)
    as_bad (_("record type is not valid"));
  bytes[0] = (UNW_R3 | r);
  count = output_leb128 (bytes + 1, rlen, 0);
  (*f) (count + 1, bytes, NULL);
}

static void
output_P1_format (vbyte_func f, int brmask)
{
  char byte;
  byte = UNW_P1 | (brmask & 0x1f);
  (*f) (1, &byte, NULL);
}

static void
output_P2_format (vbyte_func f, int brmask, int gr)
{
  char bytes[2];
  brmask = (brmask & 0x1f);
  bytes[0] = UNW_P2 | (brmask >> 1);
  bytes[1] = (((brmask & 1) << 7) | gr);
  (*f) (2, bytes, NULL);
}

static void
output_P3_format (vbyte_func f, unw_record_type rtype, int reg)
{
  char bytes[2];
  int r = 0;
  reg = (reg & 0x7f);
  switch (rtype)
    {
    case psp_gr:
      r = 0;
      break;
    case rp_gr:
      r = 1;
      break;
    case pfs_gr:
      r = 2;
      break;
    case preds_gr:
      r = 3;
      break;
    case unat_gr:
      r = 4;
      break;
    case lc_gr:
      r = 5;
      break;
    case rp_br:
      r = 6;
      break;
    case rnat_gr:
      r = 7;
      break;
    case bsp_gr:
      r = 8;
      break;
    case bspstore_gr:
      r = 9;
      break;
    case fpsr_gr:
      r = 10;
      break;
    case priunat_gr:
      r = 11;
      break;
    default:
      as_bad (_("Invalid record type for P3 format."));
    }
  bytes[0] = (UNW_P3 | (r >> 1));
  bytes[1] = (((r & 1) << 7) | reg);
  (*f) (2, bytes, NULL);
}

static void
output_P4_format (vbyte_func f, unsigned char *imask, unsigned long imask_size)
{
  imask[0] = UNW_P4;
  (*f) (imask_size, (char *) imask, NULL);
}

static void
output_P5_format (vbyte_func f, int grmask, unsigned long frmask)
{
  char bytes[4];
  grmask = (grmask & 0x0f);

  bytes[0] = UNW_P5;
  bytes[1] = ((grmask << 4) | ((frmask & 0x000f0000) >> 16));
  bytes[2] = ((frmask & 0x0000ff00) >> 8);
  bytes[3] = (frmask & 0x000000ff);
  (*f) (4, bytes, NULL);
}

static void
output_P6_format (vbyte_func f, unw_record_type rtype, int rmask)
{
  char byte;
  int r = 0;

  if (rtype == gr_mem)
    r = 1;
  else if (rtype != fr_mem)
    as_bad (_("Invalid record type for format P6"));
  byte = (UNW_P6 | (r << 4) | (rmask & 0x0f));
  (*f) (1, &byte, NULL);
}

static void
output_P7_format (vbyte_func f,
		  unw_record_type rtype,
		  unsigned long w1,
		  unsigned long w2)
{
  char bytes[20];
  int count = 1;
  int r = 0;
  count += output_leb128 (bytes + 1, w1, 0);
  switch (rtype)
    {
    case mem_stack_f:
      r = 0;
      count += output_leb128 (bytes + count, w2 >> 4, 0);
      break;
    case mem_stack_v:
      r = 1;
      break;
    case spill_base:
      r = 2;
      break;
    case psp_sprel:
      r = 3;
      break;
    case rp_when:
      r = 4;
      break;
    case rp_psprel:
      r = 5;
      break;
    case pfs_when:
      r = 6;
      break;
    case pfs_psprel:
      r = 7;
      break;
    case preds_when:
      r = 8;
      break;
    case preds_psprel:
      r = 9;
      break;
    case lc_when:
      r = 10;
      break;
    case lc_psprel:
      r = 11;
      break;
    case unat_when:
      r = 12;
      break;
    case unat_psprel:
      r = 13;
      break;
    case fpsr_when:
      r = 14;
      break;
    case fpsr_psprel:
      r = 15;
      break;
    default:
      break;
    }
  bytes[0] = (UNW_P7 | r);
  (*f) (count, bytes, NULL);
}

static void
output_P8_format (vbyte_func f, unw_record_type rtype, unsigned long t)
{
  char bytes[20];
  int r = 0;
  int count = 2;
  bytes[0] = UNW_P8;
  switch (rtype)
    {
    case rp_sprel:
      r = 1;
      break;
    case pfs_sprel:
      r = 2;
      break;
    case preds_sprel:
      r = 3;
      break;
    case lc_sprel:
      r = 4;
      break;
    case unat_sprel:
      r = 5;
      break;
    case fpsr_sprel:
      r = 6;
      break;
    case bsp_when:
      r = 7;
      break;
    case bsp_psprel:
      r = 8;
      break;
    case bsp_sprel:
      r = 9;
      break;
    case bspstore_when:
      r = 10;
      break;
    case bspstore_psprel:
      r = 11;
      break;
    case bspstore_sprel:
      r = 12;
      break;
    case rnat_when:
      r = 13;
      break;
    case rnat_psprel:
      r = 14;
      break;
    case rnat_sprel:
      r = 15;
      break;
    case priunat_when_gr:
      r = 16;
      break;
    case priunat_psprel:
      r = 17;
      break;
    case priunat_sprel:
      r = 18;
      break;
    case priunat_when_mem:
      r = 19;
      break;
    default:
      break;
    }
  bytes[1] = r;
  count += output_leb128 (bytes + 2, t, 0);
  (*f) (count, bytes, NULL);
}

static void
output_P9_format (vbyte_func f, int grmask, int gr)
{
  char bytes[3];
  bytes[0] = UNW_P9;
  bytes[1] = (grmask & 0x0f);
  bytes[2] = (gr & 0x7f);
  (*f) (3, bytes, NULL);
}

static void
output_P10_format (vbyte_func f, int abi, int context)
{
  char bytes[3];
  bytes[0] = UNW_P10;
  bytes[1] = (abi & 0xff);
  bytes[2] = (context & 0xff);
  (*f) (3, bytes, NULL);
}

static void
output_B1_format (vbyte_func f, unw_record_type rtype, unsigned long label)
{
  char byte;
  int r = 0;
  if (label > 0x1f)
    {
      output_B4_format (f, rtype, label);
      return;
    }
  if (rtype == copy_state)
    r = 1;
  else if (rtype != label_state)
    as_bad (_("Invalid record type for format B1"));

  byte = (UNW_B1 | (r << 5) | (label & 0x1f));
  (*f) (1, &byte, NULL);
}

static void
output_B2_format (vbyte_func f, unsigned long ecount, unsigned long t)
{
  char bytes[20];
  int count = 1;
  if (ecount > 0x1f)
    {
      output_B3_format (f, ecount, t);
      return;
    }
  bytes[0] = (UNW_B2 | (ecount & 0x1f));
  count += output_leb128 (bytes + 1, t, 0);
  (*f) (count, bytes, NULL);
}

static void
output_B3_format (vbyte_func f, unsigned long ecount, unsigned long t)
{
  char bytes[20];
  int count = 1;
  if (ecount <= 0x1f)
    {
      output_B2_format (f, ecount, t);
      return;
    }
  bytes[0] = UNW_B3;
  count += output_leb128 (bytes + 1, t, 0);
  count += output_leb128 (bytes + count, ecount, 0);
  (*f) (count, bytes, NULL);
}

static void
output_B4_format (vbyte_func f, unw_record_type rtype, unsigned long label)
{
  char bytes[20];
  int r = 0;
  int count = 1;
  if (label <= 0x1f)
    {
      output_B1_format (f, rtype, label);
      return;
    }

  if (rtype == copy_state)
    r = 1;
  else if (rtype != label_state)
    as_bad (_("Invalid record type for format B1"));

  bytes[0] = (UNW_B4 | (r << 3));
  count += output_leb128 (bytes + 1, label, 0);
  (*f) (count, bytes, NULL);
}

static char
format_ab_reg (int ab, int reg)
{
  int ret;
  ab = (ab & 3);
  reg = (reg & 0x1f);
  ret = (ab << 5) | reg;
  return ret;
}

static void
output_X1_format (vbyte_func f,
		  unw_record_type rtype,
		  int ab,
		  int reg,
		  unsigned long t,
		  unsigned long w1)
{
  char bytes[20];
  int r = 0;
  int count = 2;
  bytes[0] = UNW_X1;

  if (rtype == spill_sprel)
    r = 1;
  else if (rtype != spill_psprel)
    as_bad (_("Invalid record type for format X1"));
  bytes[1] = ((r << 7) | format_ab_reg (ab, reg));
  count += output_leb128 (bytes + 2, t, 0);
  count += output_leb128 (bytes + count, w1, 0);
  (*f) (count, bytes, NULL);
}

static void
output_X2_format (vbyte_func f,
		  int ab,
		  int reg,
		  int x,
		  int y,
		  int treg,
		  unsigned long t)
{
  char bytes[20];
  int count = 3;
  bytes[0] = UNW_X2;
  bytes[1] = (((x & 1) << 7) | format_ab_reg (ab, reg));
  bytes[2] = (((y & 1) << 7) | (treg & 0x7f));
  count += output_leb128 (bytes + 3, t, 0);
  (*f) (count, bytes, NULL);
}

static void
output_X3_format (vbyte_func f,
		  unw_record_type rtype,
		  int qp,
		  int ab,
		  int reg,
		  unsigned long t,
		  unsigned long w1)
{
  char bytes[20];
  int r = 0;
  int count = 3;
  bytes[0] = UNW_X3;

  if (rtype == spill_sprel_p)
    r = 1;
  else if (rtype != spill_psprel_p)
    as_bad (_("Invalid record type for format X3"));
  bytes[1] = ((r << 7) | (qp & 0x3f));
  bytes[2] = format_ab_reg (ab, reg);
  count += output_leb128 (bytes + 3, t, 0);
  count += output_leb128 (bytes + count, w1, 0);
  (*f) (count, bytes, NULL);
}

static void
output_X4_format (vbyte_func f,
		  int qp,
		  int ab,
		  int reg,
		  int x,
		  int y,
		  int treg,
		  unsigned long t)
{
  char bytes[20];
  int count = 4;
  bytes[0] = UNW_X4;
  bytes[1] = (qp & 0x3f);
  bytes[2] = (((x & 1) << 7) | format_ab_reg (ab, reg));
  bytes[3] = (((y & 1) << 7) | (treg & 0x7f));
  count += output_leb128 (bytes + 4, t, 0);
  (*f) (count, bytes, NULL);
}

/* This function checks whether there are any outstanding .save-s and
   discards them if so.  */

static void
check_pending_save (void)
{
  if (unwind.pending_saves)
    {
      unw_rec_list *cur, *prev;

      as_warn (_("Previous .save incomplete"));
      for (cur = unwind.list, prev = NULL; cur; )
	if (&cur->r.record.p == unwind.pending_saves)
	  {
	    if (prev)
	      prev->next = cur->next;
	    else
	      unwind.list = cur->next;
	    if (cur == unwind.tail)
	      unwind.tail = prev;
	    if (cur == unwind.current_entry)
	      unwind.current_entry = cur->next;
	    /* Don't free the first discarded record, it's being used as
	       terminator for (currently) br_gr and gr_gr processing, and
	       also prevents leaving a dangling pointer to it in its
	       predecessor.  */
	    cur->r.record.p.grmask = 0;
	    cur->r.record.p.brmask = 0;
	    cur->r.record.p.frmask = 0;
	    prev = cur->r.record.p.next;
	    cur->r.record.p.next = NULL;
	    cur = prev;
	    break;
	  }
	else
	  {
	    prev = cur;
	    cur = cur->next;
	  }
      while (cur)
	{
	  prev = cur;
	  cur = cur->r.record.p.next;
	  free (prev);
	}
      unwind.pending_saves = NULL;
    }
}

/* This function allocates a record list structure, and initializes fields.  */

static unw_rec_list *
alloc_record (unw_record_type t)
{
  unw_rec_list *ptr;
  ptr = xmalloc (sizeof (*ptr));
  memset (ptr, 0, sizeof (*ptr));
  ptr->slot_number = SLOT_NUM_NOT_SET;
  ptr->r.type = t;
  return ptr;
}

/* Dummy unwind record used for calculating the length of the last prologue or
   body region.  */

static unw_rec_list *
output_endp (void)
{
  unw_rec_list *ptr = alloc_record (endp);
  return ptr;
}

static unw_rec_list *
output_prologue (void)
{
  unw_rec_list *ptr = alloc_record (prologue);
  memset (&ptr->r.record.r.mask, 0, sizeof (ptr->r.record.r.mask));
  return ptr;
}

static unw_rec_list *
output_prologue_gr (unsigned int saved_mask, unsigned int reg)
{
  unw_rec_list *ptr = alloc_record (prologue_gr);
  memset (&ptr->r.record.r.mask, 0, sizeof (ptr->r.record.r.mask));
  ptr->r.record.r.grmask = saved_mask;
  ptr->r.record.r.grsave = reg;
  return ptr;
}

static unw_rec_list *
output_body (void)
{
  unw_rec_list *ptr = alloc_record (body);
  return ptr;
}

static unw_rec_list *
output_mem_stack_f (unsigned int size)
{
  unw_rec_list *ptr = alloc_record (mem_stack_f);
  ptr->r.record.p.size = size;
  return ptr;
}

static unw_rec_list *
output_mem_stack_v (void)
{
  unw_rec_list *ptr = alloc_record (mem_stack_v);
  return ptr;
}

static unw_rec_list *
output_psp_gr (unsigned int gr)
{
  unw_rec_list *ptr = alloc_record (psp_gr);
  ptr->r.record.p.r.gr = gr;
  return ptr;
}

static unw_rec_list *
output_psp_sprel (unsigned int offset)
{
  unw_rec_list *ptr = alloc_record (psp_sprel);
  ptr->r.record.p.off.sp = offset / 4;
  return ptr;
}

static unw_rec_list *
output_rp_when (void)
{
  unw_rec_list *ptr = alloc_record (rp_when);
  return ptr;
}

static unw_rec_list *
output_rp_gr (unsigned int gr)
{
  unw_rec_list *ptr = alloc_record (rp_gr);
  ptr->r.record.p.r.gr = gr;
  return ptr;
}

static unw_rec_list *
output_rp_br (unsigned int br)
{
  unw_rec_list *ptr = alloc_record (rp_br);
  ptr->r.record.p.r.br = br;
  return ptr;
}

static unw_rec_list *
output_rp_psprel (unsigned int offset)
{
  unw_rec_list *ptr = alloc_record (rp_psprel);
  ptr->r.record.p.off.psp = ENCODED_PSP_OFFSET (offset);
  return ptr;
}

static unw_rec_list *
output_rp_sprel (unsigned int offset)
{
  unw_rec_list *ptr = alloc_record (rp_sprel);
  ptr->r.record.p.off.sp = offset / 4;
  return ptr;
}

static unw_rec_list *
output_pfs_when (void)
{
  unw_rec_list *ptr = alloc_record (pfs_when);
  return ptr;
}

static unw_rec_list *
output_pfs_gr (unsigned int gr)
{
  unw_rec_list *ptr = alloc_record (pfs_gr);
  ptr->r.record.p.r.gr = gr;
  return ptr;
}

static unw_rec_list *
output_pfs_psprel (unsigned int offset)
{
  unw_rec_list *ptr = alloc_record (pfs_psprel);
  ptr->r.record.p.off.psp = ENCODED_PSP_OFFSET (offset);
  return ptr;
}

static unw_rec_list *
output_pfs_sprel (unsigned int offset)
{
  unw_rec_list *ptr = alloc_record (pfs_sprel);
  ptr->r.record.p.off.sp = offset / 4;
  return ptr;
}

static unw_rec_list *
output_preds_when (void)
{
  unw_rec_list *ptr = alloc_record (preds_when);
  return ptr;
}

static unw_rec_list *
output_preds_gr (unsigned int gr)
{
  unw_rec_list *ptr = alloc_record (preds_gr);
  ptr->r.record.p.r.gr = gr;
  return ptr;
}

static unw_rec_list *
output_preds_psprel (unsigned int offset)
{
  unw_rec_list *ptr = alloc_record (preds_psprel);
  ptr->r.record.p.off.psp = ENCODED_PSP_OFFSET (offset);
  return ptr;
}

static unw_rec_list *
output_preds_sprel (unsigned int offset)
{
  unw_rec_list *ptr = alloc_record (preds_sprel);
  ptr->r.record.p.off.sp = offset / 4;
  return ptr;
}

static unw_rec_list *
output_fr_mem (unsigned int mask)
{
  unw_rec_list *ptr = alloc_record (fr_mem);
  unw_rec_list *cur = ptr;

  ptr->r.record.p.frmask = mask;
  unwind.pending_saves = &ptr->r.record.p;
  for (;;)
    {
      unw_rec_list *prev = cur;

      /* Clear least significant set bit.  */
      mask &= ~(mask & (~mask + 1));
      if (!mask)
	return ptr;
      cur = alloc_record (fr_mem);
      cur->r.record.p.frmask = mask;
      /* Retain only least significant bit.  */
      prev->r.record.p.frmask ^= mask;
      prev->r.record.p.next = cur;
    }
}

static unw_rec_list *
output_frgr_mem (unsigned int gr_mask, unsigned int fr_mask)
{
  unw_rec_list *ptr = alloc_record (frgr_mem);
  unw_rec_list *cur = ptr;

  unwind.pending_saves = &cur->r.record.p;
  cur->r.record.p.frmask = fr_mask;
  while (fr_mask)
    {
      unw_rec_list *prev = cur;

      /* Clear least significant set bit.  */
      fr_mask &= ~(fr_mask & (~fr_mask + 1));
      if (!gr_mask && !fr_mask)
	return ptr;
      cur = alloc_record (frgr_mem);
      cur->r.record.p.frmask = fr_mask;
      /* Retain only least significant bit.  */
      prev->r.record.p.frmask ^= fr_mask;
      prev->r.record.p.next = cur;
    }
  cur->r.record.p.grmask = gr_mask;
  for (;;)
    {
      unw_rec_list *prev = cur;

      /* Clear least significant set bit.  */
      gr_mask &= ~(gr_mask & (~gr_mask + 1));
      if (!gr_mask)
	return ptr;
      cur = alloc_record (frgr_mem);
      cur->r.record.p.grmask = gr_mask;
      /* Retain only least significant bit.  */
      prev->r.record.p.grmask ^= gr_mask;
      prev->r.record.p.next = cur;
    }
}

static unw_rec_list *
output_gr_gr (unsigned int mask, unsigned int reg)
{
  unw_rec_list *ptr = alloc_record (gr_gr);
  unw_rec_list *cur = ptr;

  ptr->r.record.p.grmask = mask;
  ptr->r.record.p.r.gr = reg;
  unwind.pending_saves = &ptr->r.record.p;
  for (;;)
    {
      unw_rec_list *prev = cur;

      /* Clear least significant set bit.  */
      mask &= ~(mask & (~mask + 1));
      if (!mask)
	return ptr;
      cur = alloc_record (gr_gr);
      cur->r.record.p.grmask = mask;
      /* Indicate this record shouldn't be output.  */
      cur->r.record.p.r.gr = REG_NUM;
      /* Retain only least significant bit.  */
      prev->r.record.p.grmask ^= mask;
      prev->r.record.p.next = cur;
    }
}

static unw_rec_list *
output_gr_mem (unsigned int mask)
{
  unw_rec_list *ptr = alloc_record (gr_mem);
  unw_rec_list *cur = ptr;

  ptr->r.record.p.grmask = mask;
  unwind.pending_saves = &ptr->r.record.p;
  for (;;)
    {
      unw_rec_list *prev = cur;

      /* Clear least significant set bit.  */
      mask &= ~(mask & (~mask + 1));
      if (!mask)
	return ptr;
      cur = alloc_record (gr_mem);
      cur->r.record.p.grmask = mask;
      /* Retain only least significant bit.  */
      prev->r.record.p.grmask ^= mask;
      prev->r.record.p.next = cur;
    }
}

static unw_rec_list *
output_br_mem (unsigned int mask)
{
  unw_rec_list *ptr = alloc_record (br_mem);
  unw_rec_list *cur = ptr;

  ptr->r.record.p.brmask = mask;
  unwind.pending_saves = &ptr->r.record.p;
  for (;;)
    {
      unw_rec_list *prev = cur;

      /* Clear least significant set bit.  */
      mask &= ~(mask & (~mask + 1));
      if (!mask)
	return ptr;
      cur = alloc_record (br_mem);
      cur->r.record.p.brmask = mask;
      /* Retain only least significant bit.  */
      prev->r.record.p.brmask ^= mask;
      prev->r.record.p.next = cur;
    }
}

static unw_rec_list *
output_br_gr (unsigned int mask, unsigned int reg)
{
  unw_rec_list *ptr = alloc_record (br_gr);
  unw_rec_list *cur = ptr;

  ptr->r.record.p.brmask = mask;
  ptr->r.record.p.r.gr = reg;
  unwind.pending_saves = &ptr->r.record.p;
  for (;;)
    {
      unw_rec_list *prev = cur;

      /* Clear least significant set bit.  */
      mask &= ~(mask & (~mask + 1));
      if (!mask)
	return ptr;
      cur = alloc_record (br_gr);
      cur->r.record.p.brmask = mask;
      /* Indicate this record shouldn't be output.  */
      cur->r.record.p.r.gr = REG_NUM;
      /* Retain only least significant bit.  */
      prev->r.record.p.brmask ^= mask;
      prev->r.record.p.next = cur;
    }
}

static unw_rec_list *
output_spill_base (unsigned int offset)
{
  unw_rec_list *ptr = alloc_record (spill_base);
  ptr->r.record.p.off.psp = ENCODED_PSP_OFFSET (offset);
  return ptr;
}

static unw_rec_list *
output_unat_when (void)
{
  unw_rec_list *ptr = alloc_record (unat_when);
  return ptr;
}

static unw_rec_list *
output_unat_gr (unsigned int gr)
{
  unw_rec_list *ptr = alloc_record (unat_gr);
  ptr->r.record.p.r.gr = gr;
  return ptr;
}

static unw_rec_list *
output_unat_psprel (unsigned int offset)
{
  unw_rec_list *ptr = alloc_record (unat_psprel);
  ptr->r.record.p.off.psp = ENCODED_PSP_OFFSET (offset);
  return ptr;
}

static unw_rec_list *
output_unat_sprel (unsigned int offset)
{
  unw_rec_list *ptr = alloc_record (unat_sprel);
  ptr->r.record.p.off.sp = offset / 4;
  return ptr;
}

static unw_rec_list *
output_lc_when (void)
{
  unw_rec_list *ptr = alloc_record (lc_when);
  return ptr;
}

static unw_rec_list *
output_lc_gr (unsigned int gr)
{
  unw_rec_list *ptr = alloc_record (lc_gr);
  ptr->r.record.p.r.gr = gr;
  return ptr;
}

static unw_rec_list *
output_lc_psprel (unsigned int offset)
{
  unw_rec_list *ptr = alloc_record (lc_psprel);
  ptr->r.record.p.off.psp = ENCODED_PSP_OFFSET (offset);
  return ptr;
}

static unw_rec_list *
output_lc_sprel (unsigned int offset)
{
  unw_rec_list *ptr = alloc_record (lc_sprel);
  ptr->r.record.p.off.sp = offset / 4;
  return ptr;
}

static unw_rec_list *
output_fpsr_when (void)
{
  unw_rec_list *ptr = alloc_record (fpsr_when);
  return ptr;
}

static unw_rec_list *
output_fpsr_gr (unsigned int gr)
{
  unw_rec_list *ptr = alloc_record (fpsr_gr);
  ptr->r.record.p.r.gr = gr;
  return ptr;
}

static unw_rec_list *
output_fpsr_psprel (unsigned int offset)
{
  unw_rec_list *ptr = alloc_record (fpsr_psprel);
  ptr->r.record.p.off.psp = ENCODED_PSP_OFFSET (offset);
  return ptr;
}

static unw_rec_list *
output_fpsr_sprel (unsigned int offset)
{
  unw_rec_list *ptr = alloc_record (fpsr_sprel);
  ptr->r.record.p.off.sp = offset / 4;
  return ptr;
}

static unw_rec_list *
output_priunat_when_gr (void)
{
  unw_rec_list *ptr = alloc_record (priunat_when_gr);
  return ptr;
}

static unw_rec_list *
output_priunat_when_mem (void)
{
  unw_rec_list *ptr = alloc_record (priunat_when_mem);
  return ptr;
}

static unw_rec_list *
output_priunat_gr (unsigned int gr)
{
  unw_rec_list *ptr = alloc_record (priunat_gr);
  ptr->r.record.p.r.gr = gr;
  return ptr;
}

static unw_rec_list *
output_priunat_psprel (unsigned int offset)
{
  unw_rec_list *ptr = alloc_record (priunat_psprel);
  ptr->r.record.p.off.psp = ENCODED_PSP_OFFSET (offset);
  return ptr;
}

static unw_rec_list *
output_priunat_sprel (unsigned int offset)
{
  unw_rec_list *ptr = alloc_record (priunat_sprel);
  ptr->r.record.p.off.sp = offset / 4;
  return ptr;
}

static unw_rec_list *
output_bsp_when (void)
{
  unw_rec_list *ptr = alloc_record (bsp_when);
  return ptr;
}

static unw_rec_list *
output_bsp_gr (unsigned int gr)
{
  unw_rec_list *ptr = alloc_record (bsp_gr);
  ptr->r.record.p.r.gr = gr;
  return ptr;
}

static unw_rec_list *
output_bsp_psprel (unsigned int offset)
{
  unw_rec_list *ptr = alloc_record (bsp_psprel);
  ptr->r.record.p.off.psp = ENCODED_PSP_OFFSET (offset);
  return ptr;
}

static unw_rec_list *
output_bsp_sprel (unsigned int offset)
{
  unw_rec_list *ptr = alloc_record (bsp_sprel);
  ptr->r.record.p.off.sp = offset / 4;
  return ptr;
}

static unw_rec_list *
output_bspstore_when (void)
{
  unw_rec_list *ptr = alloc_record (bspstore_when);
  return ptr;
}

static unw_rec_list *
output_bspstore_gr (unsigned int gr)
{
  unw_rec_list *ptr = alloc_record (bspstore_gr);
  ptr->r.record.p.r.gr = gr;
  return ptr;
}

static unw_rec_list *
output_bspstore_psprel (unsigned int offset)
{
  unw_rec_list *ptr = alloc_record (bspstore_psprel);
  ptr->r.record.p.off.psp = ENCODED_PSP_OFFSET (offset);
  return ptr;
}

static unw_rec_list *
output_bspstore_sprel (unsigned int offset)
{
  unw_rec_list *ptr = alloc_record (bspstore_sprel);
  ptr->r.record.p.off.sp = offset / 4;
  return ptr;
}

static unw_rec_list *
output_rnat_when (void)
{
  unw_rec_list *ptr = alloc_record (rnat_when);
  return ptr;
}

static unw_rec_list *
output_rnat_gr (unsigned int gr)
{
  unw_rec_list *ptr = alloc_record (rnat_gr);
  ptr->r.record.p.r.gr = gr;
  return ptr;
}

static unw_rec_list *
output_rnat_psprel (unsigned int offset)
{
  unw_rec_list *ptr = alloc_record (rnat_psprel);
  ptr->r.record.p.off.psp = ENCODED_PSP_OFFSET (offset);
  return ptr;
}

static unw_rec_list *
output_rnat_sprel (unsigned int offset)
{
  unw_rec_list *ptr = alloc_record (rnat_sprel);
  ptr->r.record.p.off.sp = offset / 4;
  return ptr;
}

static unw_rec_list *
output_unwabi (unsigned long abi, unsigned long context)
{
  unw_rec_list *ptr = alloc_record (unwabi);
  ptr->r.record.p.abi = abi;
  ptr->r.record.p.context = context;
  return ptr;
}

static unw_rec_list *
output_epilogue (unsigned long ecount)
{
  unw_rec_list *ptr = alloc_record (epilogue);
  ptr->r.record.b.ecount = ecount;
  return ptr;
}

static unw_rec_list *
output_label_state (unsigned long label)
{
  unw_rec_list *ptr = alloc_record (label_state);
  ptr->r.record.b.label = label;
  return ptr;
}

static unw_rec_list *
output_copy_state (unsigned long label)
{
  unw_rec_list *ptr = alloc_record (copy_state);
  ptr->r.record.b.label = label;
  return ptr;
}

static unw_rec_list *
output_spill_psprel (unsigned int ab,
		     unsigned int reg,
		     unsigned int offset,
		     unsigned int predicate)
{
  unw_rec_list *ptr = alloc_record (predicate ? spill_psprel_p : spill_psprel);
  ptr->r.record.x.ab = ab;
  ptr->r.record.x.reg = reg;
  ptr->r.record.x.where.pspoff = ENCODED_PSP_OFFSET (offset);
  ptr->r.record.x.qp = predicate;
  return ptr;
}

static unw_rec_list *
output_spill_sprel (unsigned int ab,
		    unsigned int reg,
		    unsigned int offset,
		    unsigned int predicate)
{
  unw_rec_list *ptr = alloc_record (predicate ? spill_sprel_p : spill_sprel);
  ptr->r.record.x.ab = ab;
  ptr->r.record.x.reg = reg;
  ptr->r.record.x.where.spoff = offset / 4;
  ptr->r.record.x.qp = predicate;
  return ptr;
}

static unw_rec_list *
output_spill_reg (unsigned int ab,
		  unsigned int reg,
		  unsigned int targ_reg,
		  unsigned int xy,
		  unsigned int predicate)
{
  unw_rec_list *ptr = alloc_record (predicate ? spill_reg_p : spill_reg);
  ptr->r.record.x.ab = ab;
  ptr->r.record.x.reg = reg;
  ptr->r.record.x.where.reg = targ_reg;
  ptr->r.record.x.xy = xy;
  ptr->r.record.x.qp = predicate;
  return ptr;
}

/* Given a unw_rec_list process the correct format with the
   specified function.  */

static void
process_one_record (unw_rec_list *ptr, vbyte_func f)
{
  unsigned int fr_mask, gr_mask;

  switch (ptr->r.type)
    {
      /* This is a dummy record that takes up no space in the output.  */
    case endp:
      break;

    case gr_mem:
    case fr_mem:
    case br_mem:
    case frgr_mem:
      /* These are taken care of by prologue/prologue_gr.  */
      break;

    case prologue_gr:
    case prologue:
      if (ptr->r.type == prologue_gr)
	output_R2_format (f, ptr->r.record.r.grmask,
			  ptr->r.record.r.grsave, ptr->r.record.r.rlen);
      else
	output_R1_format (f, ptr->r.type, ptr->r.record.r.rlen);

      /* Output descriptor(s) for union of register spills (if any).  */
      gr_mask = ptr->r.record.r.mask.gr_mem;
      fr_mask = ptr->r.record.r.mask.fr_mem;
      if (fr_mask)
	{
	  if ((fr_mask & ~0xfUL) == 0)
	    output_P6_format (f, fr_mem, fr_mask);
	  else
	    {
	      output_P5_format (f, gr_mask, fr_mask);
	      gr_mask = 0;
	    }
	}
      if (gr_mask)
	output_P6_format (f, gr_mem, gr_mask);
      if (ptr->r.record.r.mask.br_mem)
	output_P1_format (f, ptr->r.record.r.mask.br_mem);

      /* output imask descriptor if necessary:  */
      if (ptr->r.record.r.mask.i)
	output_P4_format (f, ptr->r.record.r.mask.i,
			  ptr->r.record.r.imask_size);
      break;

    case body:
      output_R1_format (f, ptr->r.type, ptr->r.record.r.rlen);
      break;
    case mem_stack_f:
    case mem_stack_v:
      output_P7_format (f, ptr->r.type, ptr->r.record.p.t,
			ptr->r.record.p.size);
      break;
    case psp_gr:
    case rp_gr:
    case pfs_gr:
    case preds_gr:
    case unat_gr:
    case lc_gr:
    case fpsr_gr:
    case priunat_gr:
    case bsp_gr:
    case bspstore_gr:
    case rnat_gr:
      output_P3_format (f, ptr->r.type, ptr->r.record.p.r.gr);
      break;
    case rp_br:
      output_P3_format (f, rp_br, ptr->r.record.p.r.br);
      break;
    case psp_sprel:
      output_P7_format (f, psp_sprel, ptr->r.record.p.off.sp, 0);
      break;
    case rp_when:
    case pfs_when:
    case preds_when:
    case unat_when:
    case lc_when:
    case fpsr_when:
      output_P7_format (f, ptr->r.type, ptr->r.record.p.t, 0);
      break;
    case rp_psprel:
    case pfs_psprel:
    case preds_psprel:
    case unat_psprel:
    case lc_psprel:
    case fpsr_psprel:
    case spill_base:
      output_P7_format (f, ptr->r.type, ptr->r.record.p.off.psp, 0);
      break;
    case rp_sprel:
    case pfs_sprel:
    case preds_sprel:
    case unat_sprel:
    case lc_sprel:
    case fpsr_sprel:
    case priunat_sprel:
    case bsp_sprel:
    case bspstore_sprel:
    case rnat_sprel:
      output_P8_format (f, ptr->r.type, ptr->r.record.p.off.sp);
      break;
    case gr_gr:
      if (ptr->r.record.p.r.gr < REG_NUM)
	{
	  const unw_rec_list *cur = ptr;

	  gr_mask = cur->r.record.p.grmask;
	  while ((cur = cur->r.record.p.next) != NULL)
	    gr_mask |= cur->r.record.p.grmask;
	  output_P9_format (f, gr_mask, ptr->r.record.p.r.gr);
	}
      break;
    case br_gr:
      if (ptr->r.record.p.r.gr < REG_NUM)
	{
	  const unw_rec_list *cur = ptr;

	  gr_mask = cur->r.record.p.brmask;
	  while ((cur = cur->r.record.p.next) != NULL)
	    gr_mask |= cur->r.record.p.brmask;
	  output_P2_format (f, gr_mask, ptr->r.record.p.r.gr);
	}
      break;
    case spill_mask:
      as_bad (_("spill_mask record unimplemented."));
      break;
    case priunat_when_gr:
    case priunat_when_mem:
    case bsp_when:
    case bspstore_when:
    case rnat_when:
      output_P8_format (f, ptr->r.type, ptr->r.record.p.t);
      break;
    case priunat_psprel:
    case bsp_psprel:
    case bspstore_psprel:
    case rnat_psprel:
      output_P8_format (f, ptr->r.type, ptr->r.record.p.off.psp);
      break;
    case unwabi:
      output_P10_format (f, ptr->r.record.p.abi, ptr->r.record.p.context);
      break;
    case epilogue:
      output_B3_format (f, ptr->r.record.b.ecount, ptr->r.record.b.t);
      break;
    case label_state:
    case copy_state:
      output_B4_format (f, ptr->r.type, ptr->r.record.b.label);
      break;
    case spill_psprel:
      output_X1_format (f, ptr->r.type, ptr->r.record.x.ab,
			ptr->r.record.x.reg, ptr->r.record.x.t,
			ptr->r.record.x.where.pspoff);
      break;
    case spill_sprel:
      output_X1_format (f, ptr->r.type, ptr->r.record.x.ab,
			ptr->r.record.x.reg, ptr->r.record.x.t,
			ptr->r.record.x.where.spoff);
      break;
    case spill_reg:
      output_X2_format (f, ptr->r.record.x.ab, ptr->r.record.x.reg,
			ptr->r.record.x.xy >> 1, ptr->r.record.x.xy,
			ptr->r.record.x.where.reg, ptr->r.record.x.t);
      break;
    case spill_psprel_p:
      output_X3_format (f, ptr->r.type, ptr->r.record.x.qp,
			ptr->r.record.x.ab, ptr->r.record.x.reg,
			ptr->r.record.x.t, ptr->r.record.x.where.pspoff);
      break;
    case spill_sprel_p:
      output_X3_format (f, ptr->r.type, ptr->r.record.x.qp,
			ptr->r.record.x.ab, ptr->r.record.x.reg,
			ptr->r.record.x.t, ptr->r.record.x.where.spoff);
      break;
    case spill_reg_p:
      output_X4_format (f, ptr->r.record.x.qp, ptr->r.record.x.ab,
			ptr->r.record.x.reg, ptr->r.record.x.xy >> 1,
			ptr->r.record.x.xy, ptr->r.record.x.where.reg,
			ptr->r.record.x.t);
      break;
    default:
      as_bad (_("record_type_not_valid"));
      break;
    }
}

/* Given a unw_rec_list list, process all the records with
   the specified function.  */
static void
process_unw_records (unw_rec_list *list, vbyte_func f)
{
  unw_rec_list *ptr;
  for (ptr = list; ptr; ptr = ptr->next)
    process_one_record (ptr, f);
}

/* Determine the size of a record list in bytes.  */
static int
calc_record_size (unw_rec_list *list)
{
  vbyte_count = 0;
  process_unw_records (list, count_output);
  return vbyte_count;
}

/* Return the number of bits set in the input value.
   Perhaps this has a better place...  */
#if __GNUC__ > 3 || (__GNUC__ == 3 && __GNUC_MINOR__ >= 4)
# define popcount __builtin_popcount
#else
static int
popcount (unsigned x)
{
  static const unsigned char popcnt[16] =
    {
      0, 1, 1, 2,
      1, 2, 2, 3,
      1, 2, 2, 3,
      2, 3, 3, 4
    };

  if (x < NELEMS (popcnt))
    return popcnt[x];
  return popcnt[x % NELEMS (popcnt)] + popcount (x / NELEMS (popcnt));
}
#endif

/* Update IMASK bitmask to reflect the fact that one or more registers
   of type TYPE are saved starting at instruction with index T.  If N
   bits are set in REGMASK, it is assumed that instructions T through
   T+N-1 save these registers.

   TYPE values:
	0: no save
	1: instruction saves next fp reg
	2: instruction saves next general reg
	3: instruction saves next branch reg */
static void
set_imask (unw_rec_list *region,
	   unsigned long regmask,
	   unsigned long t,
	   unsigned int type)
{
  unsigned char *imask;
  unsigned long imask_size;
  unsigned int i;
  int pos;

  imask = region->r.record.r.mask.i;
  imask_size = region->r.record.r.imask_size;
  if (!imask)
    {
      imask_size = (region->r.record.r.rlen * 2 + 7) / 8 + 1;
      imask = xmalloc (imask_size);
      memset (imask, 0, imask_size);

      region->r.record.r.imask_size = imask_size;
      region->r.record.r.mask.i = imask;
    }

  i = (t / 4) + 1;
  pos = 2 * (3 - t % 4);
  while (regmask)
    {
      if (i >= imask_size)
	{
	  as_bad (_("Ignoring attempt to spill beyond end of region"));
	  return;
	}

      imask[i] |= (type & 0x3) << pos;

      regmask &= (regmask - 1);
      pos -= 2;
      if (pos < 0)
	{
	  pos = 0;
	  ++i;
	}
    }
}

/* Return the number of instruction slots from FIRST_ADDR to SLOT_ADDR.
   SLOT_FRAG is the frag containing SLOT_ADDR, and FIRST_FRAG is the frag
   containing FIRST_ADDR.  If BEFORE_RELAX, then we use worst-case estimates
   for frag sizes.  */

static unsigned long
slot_index (unsigned long slot_addr,
	    fragS *slot_frag,
	    unsigned long first_addr,
	    fragS *first_frag,
	    int before_relax)
{
  unsigned long s_index = 0;

  /* First time we are called, the initial address and frag are invalid.  */
  if (first_addr == 0)
    return 0;

  /* If the two addresses are in different frags, then we need to add in
     the remaining size of this frag, and then the entire size of intermediate
     frags.  */
  while (slot_frag != first_frag)
    {
      unsigned long start_addr = (unsigned long) &first_frag->fr_literal;

      if (! before_relax)
	{
	  /* We can get the final addresses only during and after
	     relaxation.  */
	  if (first_frag->fr_next && first_frag->fr_next->fr_address)
	    s_index += 3 * ((first_frag->fr_next->fr_address
			   - first_frag->fr_address
			     - first_frag->fr_fix) >> 4);
	}
      else
	/* We don't know what the final addresses will be. We try our
	   best to estimate.  */
	switch (first_frag->fr_type)
	  {
	  default:
	    break;

	  case rs_space:
	    as_fatal (_("Only constant space allocation is supported"));
	    break;

	  case rs_align:
	  case rs_align_code:
	  case rs_align_test:
	    /* Take alignment into account.  Assume the worst case
	       before relaxation.  */
	    s_index += 3 * ((1 << first_frag->fr_offset) >> 4);
	    break;

	  case rs_org:
	    if (first_frag->fr_symbol)
	      {
		as_fatal (_("Only constant offsets are supported"));
		break;
	      }
	  case rs_fill:
	    s_index += 3 * (first_frag->fr_offset >> 4);
	    break;
	  }

      /* Add in the full size of the frag converted to instruction slots.  */
      s_index += 3 * (first_frag->fr_fix >> 4);
      /* Subtract away the initial part before first_addr.  */
      s_index -= (3 * ((first_addr >> 4) - (start_addr >> 4))
		+ ((first_addr & 0x3) - (start_addr & 0x3)));

      /* Move to the beginning of the next frag.  */
      first_frag = first_frag->fr_next;
      first_addr = (unsigned long) &first_frag->fr_literal;

      /* This can happen if there is section switching in the middle of a
	 function, causing the frag chain for the function to be broken.
	 It is too difficult to recover safely from this problem, so we just
	 exit with an error.  */
      if (first_frag == NULL)
	as_fatal (_("Section switching in code is not supported."));
    }

  /* Add in the used part of the last frag.  */
  s_index += (3 * ((slot_addr >> 4) - (first_addr >> 4))
	    + ((slot_addr & 0x3) - (first_addr & 0x3)));
  return s_index;
}

/* Optimize unwind record directives.  */

static unw_rec_list *
optimize_unw_records (unw_rec_list *list)
{
  if (!list)
    return NULL;

  /* If the only unwind record is ".prologue" or ".prologue" followed
     by ".body", then we can optimize the unwind directives away.  */
  if (list->r.type == prologue
      && (list->next->r.type == endp
	  || (list->next->r.type == body && list->next->next->r.type == endp)))
    return NULL;

  return list;
}

/* Given a complete record list, process any records which have
   unresolved fields, (ie length counts for a prologue).  After
   this has been run, all necessary information should be available
   within each record to generate an image.  */

static void
fixup_unw_records (unw_rec_list *list, int before_relax)
{
  unw_rec_list *ptr, *region = 0;
  unsigned long first_addr = 0, rlen = 0, t;
  fragS *first_frag = 0;

  for (ptr = list; ptr; ptr = ptr->next)
    {
      if (ptr->slot_number == SLOT_NUM_NOT_SET)
	as_bad (_(" Insn slot not set in unwind record."));
      t = slot_index (ptr->slot_number, ptr->slot_frag,
		      first_addr, first_frag, before_relax);
      switch (ptr->r.type)
	{
	case prologue:
	case prologue_gr:
	case body:
	  {
	    unw_rec_list *last;
	    int size;
	    unsigned long last_addr = 0;
	    fragS *last_frag = NULL;

	    first_addr = ptr->slot_number;
	    first_frag = ptr->slot_frag;
	    /* Find either the next body/prologue start, or the end of
	       the function, and determine the size of the region.  */
	    for (last = ptr->next; last != NULL; last = last->next)
	      if (last->r.type == prologue || last->r.type == prologue_gr
		  || last->r.type == body || last->r.type == endp)
		{
		  last_addr = last->slot_number;
		  last_frag = last->slot_frag;
		  break;
		}
	    size = slot_index (last_addr, last_frag, first_addr, first_frag,
			       before_relax);
	    rlen = ptr->r.record.r.rlen = size;
	    if (ptr->r.type == body)
	      /* End of region.  */
	      region = 0;
	    else
	      region = ptr;
	    break;
	  }
	case epilogue:
	  if (t < rlen)
	    ptr->r.record.b.t = rlen - 1 - t;
	  else
	    /* This happens when a memory-stack-less procedure uses a
	       ".restore sp" directive at the end of a region to pop
	       the frame state.  */
	    ptr->r.record.b.t = 0;
	  break;

	case mem_stack_f:
	case mem_stack_v:
	case rp_when:
	case pfs_when:
	case preds_when:
	case unat_when:
	case lc_when:
	case fpsr_when:
	case priunat_when_gr:
	case priunat_when_mem:
	case bsp_when:
	case bspstore_when:
	case rnat_when:
	  ptr->r.record.p.t = t;
	  break;

	case spill_reg:
	case spill_sprel:
	case spill_psprel:
	case spill_reg_p:
	case spill_sprel_p:
	case spill_psprel_p:
	  ptr->r.record.x.t = t;
	  break;

	case frgr_mem:
	  if (!region)
	    {
	      as_bad (_("frgr_mem record before region record!"));
	      return;
	    }
	  region->r.record.r.mask.fr_mem |= ptr->r.record.p.frmask;
	  region->r.record.r.mask.gr_mem |= ptr->r.record.p.grmask;
	  set_imask (region, ptr->r.record.p.frmask, t, 1);
	  set_imask (region, ptr->r.record.p.grmask, t, 2);
	  break;
	case fr_mem:
	  if (!region)
	    {
	      as_bad (_("fr_mem record before region record!"));
	      return;
	    }
	  region->r.record.r.mask.fr_mem |= ptr->r.record.p.frmask;
	  set_imask (region, ptr->r.record.p.frmask, t, 1);
	  break;
	case gr_mem:
	  if (!region)
	    {
	      as_bad (_("gr_mem record before region record!"));
	      return;
	    }
	  region->r.record.r.mask.gr_mem |= ptr->r.record.p.grmask;
	  set_imask (region, ptr->r.record.p.grmask, t, 2);
	  break;
	case br_mem:
	  if (!region)
	    {
	      as_bad (_("br_mem record before region record!"));
	      return;
	    }
	  region->r.record.r.mask.br_mem |= ptr->r.record.p.brmask;
	  set_imask (region, ptr->r.record.p.brmask, t, 3);
	  break;

	case gr_gr:
	  if (!region)
	    {
	      as_bad (_("gr_gr record before region record!"));
	      return;
	    }
	  set_imask (region, ptr->r.record.p.grmask, t, 2);
	  break;
	case br_gr:
	  if (!region)
	    {
	      as_bad (_("br_gr record before region record!"));
	      return;
	    }
	  set_imask (region, ptr->r.record.p.brmask, t, 3);
	  break;

	default:
	  break;
	}
    }
}

/* Estimate the size of a frag before relaxing.  We only have one type of frag
   to handle here, which is the unwind info frag.  */

int
ia64_estimate_size_before_relax (fragS *frag,
				 asection *segtype ATTRIBUTE_UNUSED)
{
  unw_rec_list *list;
  int len, size, pad;

  /* ??? This code is identical to the first part of ia64_convert_frag.  */
  list = (unw_rec_list *) frag->fr_opcode;
  fixup_unw_records (list, 0);

  len = calc_record_size (list);
  /* pad to pointer-size boundary.  */
  pad = len % md.pointer_size;
  if (pad != 0)
    len += md.pointer_size - pad;
  /* Add 8 for the header.  */
  size = len + 8;
  /* Add a pointer for the personality offset.  */
  if (frag->fr_offset)
    size += md.pointer_size;

  /* fr_var carries the max_chars that we created the fragment with.
     We must, of course, have allocated enough memory earlier.  */
  gas_assert (frag->fr_var >= size);

  return frag->fr_fix + size;
}

/* This function converts a rs_machine_dependent variant frag into a
  normal fill frag with the unwind image from the record list.  */
void
ia64_convert_frag (fragS *frag)
{
  unw_rec_list *list;
  int len, size, pad;
  valueT flag_value;

  /* ??? This code is identical to ia64_estimate_size_before_relax.  */
  list = (unw_rec_list *) frag->fr_opcode;
  fixup_unw_records (list, 0);

  len = calc_record_size (list);
  /* pad to pointer-size boundary.  */
  pad = len % md.pointer_size;
  if (pad != 0)
    len += md.pointer_size - pad;
  /* Add 8 for the header.  */
  size = len + 8;
  /* Add a pointer for the personality offset.  */
  if (frag->fr_offset)
    size += md.pointer_size;

  /* fr_var carries the max_chars that we created the fragment with.
     We must, of course, have allocated enough memory earlier.  */
  gas_assert (frag->fr_var >= size);

  /* Initialize the header area. fr_offset is initialized with
     unwind.personality_routine.  */
  if (frag->fr_offset)
    {
      if (md.flags & EF_IA_64_ABI64)
	flag_value = (bfd_vma) 3 << 32;
      else
	/* 32-bit unwind info block.  */
	flag_value = (bfd_vma) 0x1003 << 32;
    }
  else
    flag_value = 0;

 md_number_to_chars (frag->fr_literal,
		     (((bfd_vma) 1 << 48) /* Version.  */
		      | flag_value        /* U & E handler flags.  */
		      | (len / md.pointer_size)), /* Length.  */
		     8);

  /* Skip the header.  */
  vbyte_mem_ptr = frag->fr_literal + 8;
  process_unw_records (list, output_vbyte_mem);

  /* Fill the padding bytes with zeros.  */
  if (pad != 0)
    md_number_to_chars (frag->fr_literal + len + 8 - md.pointer_size + pad, 0,
			md.pointer_size - pad);
  /* Fill the unwind personality with zeros.  */
  if (frag->fr_offset)
    md_number_to_chars (frag->fr_literal + size - md.pointer_size, 0,
			md.pointer_size);

  frag->fr_fix += size;
  frag->fr_type = rs_fill;
  frag->fr_var = 0;
  frag->fr_offset = 0;
}

static int
parse_predicate_and_operand (expressionS *e, unsigned *qp, const char *po)
{
  int sep = parse_operand_and_eval (e, ',');

  *qp = e->X_add_number - REG_P;
  if (e->X_op != O_register || *qp > 63)
    {
      as_bad (_("First operand to .%s must be a predicate"), po);
      *qp = 0;
    }
  else if (*qp == 0)
    as_warn (_("Pointless use of p0 as first operand to .%s"), po);
  if (sep == ',')
    sep = parse_operand_and_eval (e, ',');
  else
    e->X_op = O_absent;
  return sep;
}

static void
convert_expr_to_ab_reg (const expressionS *e,
			unsigned int *ab,
			unsigned int *regp,
			const char *po,
			int n)
{
  unsigned int reg = e->X_add_number;

  *ab = *regp = 0; /* Anything valid is good here.  */

  if (e->X_op != O_register)
    reg = REG_GR; /* Anything invalid is good here.  */

  if (reg >= (REG_GR + 4) && reg <= (REG_GR + 7))
    {
      *ab = 0;
      *regp = reg - REG_GR;
    }
  else if ((reg >= (REG_FR + 2) && reg <= (REG_FR + 5))
	   || (reg >= (REG_FR + 16) && reg <= (REG_FR + 31)))
    {
      *ab = 1;
      *regp = reg - REG_FR;
    }
  else if (reg >= (REG_BR + 1) && reg <= (REG_BR + 5))
    {
      *ab = 2;
      *regp = reg - REG_BR;
    }
  else
    {
      *ab = 3;
      switch (reg)
	{
	case REG_PR:		*regp =  0; break;
	case REG_PSP:		*regp =  1; break;
	case REG_PRIUNAT:	*regp =  2; break;
	case REG_BR + 0:	*regp =  3; break;
	case REG_AR + AR_BSP:	*regp =  4; break;
	case REG_AR + AR_BSPSTORE: *regp = 5; break;
	case REG_AR + AR_RNAT:	*regp =  6; break;
	case REG_AR + AR_UNAT:	*regp =  7; break;
	case REG_AR + AR_FPSR:	*regp =  8; break;
	case REG_AR + AR_PFS:	*regp =  9; break;
	case REG_AR + AR_LC:	*regp = 10; break;

	default:
	  as_bad (_("Operand %d to .%s must be a preserved register"), n, po);
	  break;
	}
    }
}

static void
convert_expr_to_xy_reg (const expressionS *e,
			unsigned int *xy,
			unsigned int *regp,
			const char *po,
			int n)
{
  unsigned int reg = e->X_add_number;

  *xy = *regp = 0; /* Anything valid is good here.  */

  if (e->X_op != O_register)
    reg = REG_GR; /* Anything invalid is good here.  */

  if (reg >= (REG_GR + 1) && reg <= (REG_GR + 127))
    {
      *xy = 0;
      *regp = reg - REG_GR;
    }
  else if (reg >= (REG_FR + 2) && reg <= (REG_FR + 127))
    {
      *xy = 1;
      *regp = reg - REG_FR;
    }
  else if (reg >= REG_BR && reg <= (REG_BR + 7))
    {
      *xy = 2;
      *regp = reg - REG_BR;
    }
  else
    as_bad (_("Operand %d to .%s must be a writable register"), n, po);
}

static void
dot_align (int arg)
{
  /* The current frag is an alignment frag.  */
  align_frag = frag_now;
  s_align_bytes (arg);
}

static void
dot_radix (int dummy ATTRIBUTE_UNUSED)
{
  char *radix;
  int ch;

  SKIP_WHITESPACE ();

  if (is_it_end_of_statement ())
    return;
  radix = input_line_pointer;
  ch = get_symbol_end ();
  ia64_canonicalize_symbol_name (radix);
  if (strcasecmp (radix, "C"))
    as_bad (_("Radix `%s' unsupported or invalid"), radix);
  *input_line_pointer = ch;
  demand_empty_rest_of_line ();
}

/* Helper function for .loc directives.  If the assembler is not generating
   line number info, then we need to remember which instructions have a .loc
   directive, and only call dwarf2_gen_line_info for those instructions.  */

static void
dot_loc (int x)
{
  CURR_SLOT.loc_directive_seen = 1;
  dwarf2_directive_loc (x);
}

/* .sbss, .bss etc. are macros that expand into ".section SECNAME".  */
static void
dot_special_section (int which)
{
  set_section ((char *) special_section_name[which]);
}

/* Return -1 for warning and 0 for error.  */

static int
unwind_diagnostic (const char * region, const char *directive)
{
  if (md.unwind_check == unwind_check_warning)
    {
      as_warn (_(".%s outside of %s"), directive, region);
      return -1;
    }
  else
    {
      as_bad (_(".%s outside of %s"), directive, region);
      ignore_rest_of_line ();
      return 0;
    }
}

/* Return 1 if a directive is in a procedure, -1 if a directive isn't in
   a procedure but the unwind directive check is set to warning, 0 if
   a directive isn't in a procedure and the unwind directive check is set
   to error.  */

static int
in_procedure (const char *directive)
{
  if (unwind.proc_pending.sym
      && (!unwind.saved_text_seg || strcmp (directive, "endp") == 0))
    return 1;
  return unwind_diagnostic ("procedure", directive);
}

/* Return 1 if a directive is in a prologue, -1 if a directive isn't in
   a prologue but the unwind directive check is set to warning, 0 if
   a directive isn't in a prologue and the unwind directive check is set
   to error.  */

static int
in_prologue (const char *directive)
{
  int in = in_procedure (directive);

  if (in > 0 && !unwind.prologue)
    in = unwind_diagnostic ("prologue", directive);
  check_pending_save ();
  return in;
}

/* Return 1 if a directive is in a body, -1 if a directive isn't in
   a body but the unwind directive check is set to warning, 0 if
   a directive isn't in a body and the unwind directive check is set
   to error.  */

static int
in_body (const char *directive)
{
  int in = in_procedure (directive);

  if (in > 0 && !unwind.body)
    in = unwind_diagnostic ("body region", directive);
  return in;
}

static void
add_unwind_entry (unw_rec_list *ptr, int sep)
{
  if (ptr)
    {
      if (unwind.tail)
	unwind.tail->next = ptr;
      else
	unwind.list = ptr;
      unwind.tail = ptr;

      /* The current entry can in fact be a chain of unwind entries.  */
      if (unwind.current_entry == NULL)
	unwind.current_entry = ptr;
    }

  /* The current entry can in fact be a chain of unwind entries.  */
  if (unwind.current_entry == NULL)
    unwind.current_entry = ptr;

  if (sep == ',')
    {
      /* Parse a tag permitted for the current directive.  */
      int ch;

      SKIP_WHITESPACE ();
      ch = get_symbol_end ();
      /* FIXME: For now, just issue a warning that this isn't implemented.  */
      {
	static int warned;

	if (!warned)
	  {
	    warned = 1;
	    as_warn (_("Tags on unwind pseudo-ops aren't supported, yet"));
	  }
      }
      *input_line_pointer = ch;
    }
  if (sep != NOT_A_CHAR)
    demand_empty_rest_of_line ();
}

static void
dot_fframe (int dummy ATTRIBUTE_UNUSED)
{
  expressionS e;
  int sep;

  if (!in_prologue ("fframe"))
    return;

  sep = parse_operand_and_eval (&e, ',');

  if (e.X_op != O_constant)
    {
      as_bad (_("First operand to .fframe must be a constant"));
      e.X_add_number = 0;
    }
  add_unwind_entry (output_mem_stack_f (e.X_add_number), sep);
}

static void
dot_vframe (int dummy ATTRIBUTE_UNUSED)
{
  expressionS e;
  unsigned reg;
  int sep;

  if (!in_prologue ("vframe"))
    return;

  sep = parse_operand_and_eval (&e, ',');
  reg = e.X_add_number - REG_GR;
  if (e.X_op != O_register || reg > 127)
    {
      as_bad (_("First operand to .vframe must be a general register"));
      reg = 0;
    }
  add_unwind_entry (output_mem_stack_v (), sep);
  if (! (unwind.prologue_mask & 2))
    add_unwind_entry (output_psp_gr (reg), NOT_A_CHAR);
  else if (reg != unwind.prologue_gr
		  + (unsigned) popcount (unwind.prologue_mask & (-2 << 1)))
    as_warn (_("Operand of .vframe contradicts .prologue"));
}

static void
dot_vframesp (int psp)
{
  expressionS e;
  int sep;

  if (psp)
    as_warn (_(".vframepsp is meaningless, assuming .vframesp was meant"));

  if (!in_prologue ("vframesp"))
    return;

  sep = parse_operand_and_eval (&e, ',');
  if (e.X_op != O_constant)
    {
      as_bad (_("Operand to .vframesp must be a constant (sp-relative offset)"));
      e.X_add_number = 0;
    }
  add_unwind_entry (output_mem_stack_v (), sep);
  add_unwind_entry (output_psp_sprel (e.X_add_number), NOT_A_CHAR);
}

static void
dot_save (int dummy ATTRIBUTE_UNUSED)
{
  expressionS e1, e2;
  unsigned reg1, reg2;
  int sep;

  if (!in_prologue ("save"))
    return;

  sep = parse_operand_and_eval (&e1, ',');
  if (sep == ',')
    sep = parse_operand_and_eval (&e2, ',');
  else
    e2.X_op = O_absent;

  reg1 = e1.X_add_number;
  /* Make sure its a valid ar.xxx reg, OR its br0, aka 'rp'.  */
  if (e1.X_op != O_register)
    {
      as_bad (_("First operand to .save not a register"));
      reg1 = REG_PR; /* Anything valid is good here.  */
    }
  reg2 = e2.X_add_number - REG_GR;
  if (e2.X_op != O_register || reg2 > 127)
    {
      as_bad (_("Second operand to .save not a valid register"));
      reg2 = 0;
    }
  switch (reg1)
    {
    case REG_AR + AR_BSP:
      add_unwind_entry (output_bsp_when (), sep);
      add_unwind_entry (output_bsp_gr (reg2), NOT_A_CHAR);
      break;
    case REG_AR + AR_BSPSTORE:
      add_unwind_entry (output_bspstore_when (), sep);
      add_unwind_entry (output_bspstore_gr (reg2), NOT_A_CHAR);
      break;
    case REG_AR + AR_RNAT:
      add_unwind_entry (output_rnat_when (), sep);
      add_unwind_entry (output_rnat_gr (reg2), NOT_A_CHAR);
      break;
    case REG_AR + AR_UNAT:
      add_unwind_entry (output_unat_when (), sep);
      add_unwind_entry (output_unat_gr (reg2), NOT_A_CHAR);
      break;
    case REG_AR + AR_FPSR:
      add_unwind_entry (output_fpsr_when (), sep);
      add_unwind_entry (output_fpsr_gr (reg2), NOT_A_CHAR);
      break;
    case REG_AR + AR_PFS:
      add_unwind_entry (output_pfs_when (), sep);
      if (! (unwind.prologue_mask & 4))
	add_unwind_entry (output_pfs_gr (reg2), NOT_A_CHAR);
      else if (reg2 != unwind.prologue_gr
		       + (unsigned) popcount (unwind.prologue_mask & (-4 << 1)))
	as_warn (_("Second operand of .save contradicts .prologue"));
      break;
    case REG_AR + AR_LC:
      add_unwind_entry (output_lc_when (), sep);
      add_unwind_entry (output_lc_gr (reg2), NOT_A_CHAR);
      break;
    case REG_BR:
      add_unwind_entry (output_rp_when (), sep);
      if (! (unwind.prologue_mask & 8))
	add_unwind_entry (output_rp_gr (reg2), NOT_A_CHAR);
      else if (reg2 != unwind.prologue_gr)
	as_warn (_("Second operand of .save contradicts .prologue"));
      break;
    case REG_PR:
      add_unwind_entry (output_preds_when (), sep);
      if (! (unwind.prologue_mask & 1))
	add_unwind_entry (output_preds_gr (reg2), NOT_A_CHAR);
      else if (reg2 != unwind.prologue_gr
		       + (unsigned) popcount (unwind.prologue_mask & (-1 << 1)))
	as_warn (_("Second operand of .save contradicts .prologue"));
      break;
    case REG_PRIUNAT:
      add_unwind_entry (output_priunat_when_gr (), sep);
      add_unwind_entry (output_priunat_gr (reg2), NOT_A_CHAR);
      break;
    default:
      as_bad (_("First operand to .save not a valid register"));
      add_unwind_entry (NULL, sep);
      break;
    }
}

static void
dot_restore (int dummy ATTRIBUTE_UNUSED)
{
  expressionS e1;
  unsigned long ecount;	/* # of _additional_ regions to pop */
  int sep;

  if (!in_body ("restore"))
    return;

  sep = parse_operand_and_eval (&e1, ',');
  if (e1.X_op != O_register || e1.X_add_number != REG_GR + 12)
    as_bad (_("First operand to .restore must be stack pointer (sp)"));

  if (sep == ',')
    {
      expressionS e2;

      sep = parse_operand_and_eval (&e2, ',');
      if (e2.X_op != O_constant || e2.X_add_number < 0)
	{
	  as_bad (_("Second operand to .restore must be a constant >= 0"));
	  e2.X_add_number = 0;
	}
      ecount = e2.X_add_number;
    }
  else
    ecount = unwind.prologue_count - 1;

  if (ecount >= unwind.prologue_count)
    {
      as_bad (_("Epilogue count of %lu exceeds number of nested prologues (%u)"),
	      ecount + 1, unwind.prologue_count);
      ecount = 0;
    }

  add_unwind_entry (output_epilogue (ecount), sep);

  if (ecount < unwind.prologue_count)
    unwind.prologue_count -= ecount + 1;
  else
    unwind.prologue_count = 0;
}

static void
dot_restorereg (int pred)
{
  unsigned int qp, ab, reg;
  expressionS e;
  int sep;
  const char * const po = pred ? "restorereg.p" : "restorereg";

  if (!in_procedure (po))
    return;

  if (pred)
    sep = parse_predicate_and_operand (&e, &qp, po);
  else
    {
      sep = parse_operand_and_eval (&e, ',');
      qp = 0;
    }
  convert_expr_to_ab_reg (&e, &ab, &reg, po, 1 + pred);

  add_unwind_entry (output_spill_reg (ab, reg, 0, 0, qp), sep);
}

static char *special_linkonce_name[] =
  {
    ".gnu.linkonce.ia64unw.", ".gnu.linkonce.ia64unwi."
  };

static void
start_unwind_section (const segT text_seg, int sec_index)
{
  /*
    Use a slightly ugly scheme to derive the unwind section names from
    the text section name:

    text sect.  unwind table sect.
    name:       name:                      comments:
    ----------  -----------------          --------------------------------
    .text       .IA_64.unwind
    .text.foo   .IA_64.unwind.text.foo
    .foo        .IA_64.unwind.foo
    .gnu.linkonce.t.foo
		.gnu.linkonce.ia64unw.foo
    _info       .IA_64.unwind_info         gas issues error message (ditto)
    _infoFOO    .IA_64.unwind_infoFOO      gas issues error message (ditto)

    This mapping is done so that:

	(a) An object file with unwind info only in .text will use
	    unwind section names .IA_64.unwind and .IA_64.unwind_info.
	    This follows the letter of the ABI and also ensures backwards
	    compatibility with older toolchains.

	(b) An object file with unwind info in multiple text sections
	    will use separate unwind sections for each text section.
	    This allows us to properly set the "sh_info" and "sh_link"
	    fields in SHT_IA_64_UNWIND as required by the ABI and also
	    lets GNU ld support programs with multiple segments
	    containing unwind info (as might be the case for certain
	    embedded applications).

	(c) An error is issued if there would be a name clash.
  */

  const char *text_name, *sec_text_name;
  char *sec_name;
  const char *prefix = special_section_name [sec_index];
  const char *suffix;
  size_t prefix_len, suffix_len, sec_name_len;

  sec_text_name = segment_name (text_seg);
  text_name = sec_text_name;
  if (strncmp (text_name, "_info", 5) == 0)
    {
      as_bad (_("Illegal section name `%s' (causes unwind section name clash)"),
	      text_name);
      ignore_rest_of_line ();
      return;
    }
  if (strcmp (text_name, ".text") == 0)
    text_name = "";

  /* Build the unwind section name by appending the (possibly stripped)
     text section name to the unwind prefix.  */
  suffix = text_name;
  if (strncmp (text_name, ".gnu.linkonce.t.",
	       sizeof (".gnu.linkonce.t.") - 1) == 0)
    {
      prefix = special_linkonce_name [sec_index - SPECIAL_SECTION_UNWIND];
      suffix += sizeof (".gnu.linkonce.t.") - 1;
    }

  prefix_len = strlen (prefix);
  suffix_len = strlen (suffix);
  sec_name_len = prefix_len + suffix_len;
  sec_name = alloca (sec_name_len + 1);
  memcpy (sec_name, prefix, prefix_len);
  memcpy (sec_name + prefix_len, suffix, suffix_len);
  sec_name [sec_name_len] = '\0';

  /* Handle COMDAT group.  */
  if ((text_seg->flags & SEC_LINK_ONCE) != 0
      && (elf_section_flags (text_seg) & SHF_GROUP) != 0)
    {
      char *section;
      size_t len, group_name_len;
      const char *group_name = elf_group_name (text_seg);

      if (group_name == NULL)
	{
	  as_bad (_("Group section `%s' has no group signature"),
		  sec_text_name);
	  ignore_rest_of_line ();
	  return;
	}
      /* We have to construct a fake section directive. */
      group_name_len = strlen (group_name);
      len = (sec_name_len
	     + 16			/* ,"aG",@@progbits,  */
	     + group_name_len		/* ,group_name  */
	     + 7);			/* ,comdat  */

      section = alloca (len + 1);
      memcpy (section, sec_name, sec_name_len);
      memcpy (section + sec_name_len, ",\"aG\",@@progbits,", 16);
      memcpy (section + sec_name_len + 16, group_name, group_name_len);
      memcpy (section + len - 7, ",comdat", 7);
      section [len] = '\0';
      set_section (section);
    }
  else
    {
      set_section (sec_name);
      bfd_set_section_flags (stdoutput, now_seg,
			     SEC_LOAD | SEC_ALLOC | SEC_READONLY);
    }

  elf_linked_to_section (now_seg) = text_seg;
}

static void
generate_unwind_image (const segT text_seg)
{
  int size, pad;
  unw_rec_list *list;

  /* Mark the end of the unwind info, so that we can compute the size of the
     last unwind region.  */
  add_unwind_entry (output_endp (), NOT_A_CHAR);

  /* Force out pending instructions, to make sure all unwind records have
     a valid slot_number field.  */
  ia64_flush_insns ();

  /* Generate the unwind record.  */
  list = optimize_unw_records (unwind.list);
  fixup_unw_records (list, 1);
  size = calc_record_size (list);

  if (size > 0 || unwind.force_unwind_entry)
    {
      unwind.force_unwind_entry = 0;
      /* pad to pointer-size boundary.  */
      pad = size % md.pointer_size;
      if (pad != 0)
	size += md.pointer_size - pad;
      /* Add 8 for the header.  */
      size += 8;
      /* Add a pointer for the personality offset.  */
      if (unwind.personality_routine)
	size += md.pointer_size;
    }

  /* If there are unwind records, switch sections, and output the info.  */
  if (size != 0)
    {
      expressionS exp;
      bfd_reloc_code_real_type reloc;

      start_unwind_section (text_seg, SPECIAL_SECTION_UNWIND_INFO);

      /* Make sure the section has 4 byte alignment for ILP32 and
	 8 byte alignment for LP64.  */
      frag_align (md.pointer_size_shift, 0, 0);
      record_alignment (now_seg, md.pointer_size_shift);

      /* Set expression which points to start of unwind descriptor area.  */
      unwind.info = expr_build_dot ();
      
      frag_var (rs_machine_dependent, size, size, 0, 0,
		(offsetT) (long) unwind.personality_routine,
		(char *) list);

      /* Add the personality address to the image.  */
      if (unwind.personality_routine != 0)
	{
	  exp.X_op = O_symbol;
	  exp.X_add_symbol = unwind.personality_routine;
	  exp.X_add_number = 0;

	  if (md.flags & EF_IA_64_BE)
	    {
	      if (md.flags & EF_IA_64_ABI64)
		reloc = BFD_RELOC_IA64_LTOFF_FPTR64MSB;
	      else
		reloc = BFD_RELOC_IA64_LTOFF_FPTR32MSB;
	    }
	  else
	    {
	      if (md.flags & EF_IA_64_ABI64)
		reloc = BFD_RELOC_IA64_LTOFF_FPTR64LSB;
	      else
		reloc = BFD_RELOC_IA64_LTOFF_FPTR32LSB;
	    }

	  fix_new_exp (frag_now, frag_now_fix () - md.pointer_size,
		       md.pointer_size, &exp, 0, reloc);
	  unwind.personality_routine = 0;
	}
    }

  free_saved_prologue_counts ();
  unwind.list = unwind.tail = unwind.current_entry = NULL;
}

static void
dot_handlerdata (int dummy ATTRIBUTE_UNUSED)
{
  if (!in_procedure ("handlerdata"))
    return;
  unwind.force_unwind_entry = 1;

  /* Remember which segment we're in so we can switch back after .endp */
  unwind.saved_text_seg = now_seg;
  unwind.saved_text_subseg = now_subseg;

  /* Generate unwind info into unwind-info section and then leave that
     section as the currently active one so dataXX directives go into
     the language specific data area of the unwind info block.  */
  generate_unwind_image (now_seg);
  demand_empty_rest_of_line ();
}

static void
dot_unwentry (int dummy ATTRIBUTE_UNUSED)
{
  if (!in_procedure ("unwentry"))
    return;
  unwind.force_unwind_entry = 1;
  demand_empty_rest_of_line ();
}

static void
dot_altrp (int dummy ATTRIBUTE_UNUSED)
{
  expressionS e;
  unsigned reg;

  if (!in_prologue ("altrp"))
    return;

  parse_operand_and_eval (&e, 0);
  reg = e.X_add_number - REG_BR;
  if (e.X_op != O_register || reg > 7)
    {
      as_bad (_("First operand to .altrp not a valid branch register"));
      reg = 0;
    }
  add_unwind_entry (output_rp_br (reg), 0);
}

static void
dot_savemem (int psprel)
{
  expressionS e1, e2;
  int sep;
  int reg1, val;
  const char * const po = psprel ? "savepsp" : "savesp";

  if (!in_prologue (po))
    return;

  sep = parse_operand_and_eval (&e1, ',');
  if (sep == ',')
    sep = parse_operand_and_eval (&e2, ',');
  else
    e2.X_op = O_absent;

  reg1 = e1.X_add_number;
  val = e2.X_add_number;

  /* Make sure its a valid ar.xxx reg, OR its br0, aka 'rp'.  */
  if (e1.X_op != O_register)
    {
      as_bad (_("First operand to .%s not a register"), po);
      reg1 = REG_PR; /* Anything valid is good here.  */
    }
  if (e2.X_op != O_constant)
    {
      as_bad (_("Second operand to .%s not a constant"), po);
      val = 0;
    }

  switch (reg1)
    {
    case REG_AR + AR_BSP:
      add_unwind_entry (output_bsp_when (), sep);
      add_unwind_entry ((psprel
			 ? output_bsp_psprel
			 : output_bsp_sprel) (val), NOT_A_CHAR);
      break;
    case REG_AR + AR_BSPSTORE:
      add_unwind_entry (output_bspstore_when (), sep);
      add_unwind_entry ((psprel
			 ? output_bspstore_psprel
			 : output_bspstore_sprel) (val), NOT_A_CHAR);
      break;
    case REG_AR + AR_RNAT:
      add_unwind_entry (output_rnat_when (), sep);
      add_unwind_entry ((psprel
			 ? output_rnat_psprel
			 : output_rnat_sprel) (val), NOT_A_CHAR);
      break;
    case REG_AR + AR_UNAT:
      add_unwind_entry (output_unat_when (), sep);
      add_unwind_entry ((psprel
			 ? output_unat_psprel
			 : output_unat_sprel) (val), NOT_A_CHAR);
      break;
    case REG_AR + AR_FPSR:
      add_unwind_entry (output_fpsr_when (), sep);
      add_unwind_entry ((psprel
			 ? output_fpsr_psprel
			 : output_fpsr_sprel) (val), NOT_A_CHAR);
      break;
    case REG_AR + AR_PFS:
      add_unwind_entry (output_pfs_when (), sep);
      add_unwind_entry ((psprel
			 ? output_pfs_psprel
			 : output_pfs_sprel) (val), NOT_A_CHAR);
      break;
    case REG_AR + AR_LC:
      add_unwind_entry (output_lc_when (), sep);
      add_unwind_entry ((psprel
			 ? output_lc_psprel
			 : output_lc_sprel) (val), NOT_A_CHAR);
      break;
    case REG_BR:
      add_unwind_entry (output_rp_when (), sep);
      add_unwind_entry ((psprel
			 ? output_rp_psprel
			 : output_rp_sprel) (val), NOT_A_CHAR);
      break;
    case REG_PR:
      add_unwind_entry (output_preds_when (), sep);
      add_unwind_entry ((psprel
			 ? output_preds_psprel
			 : output_preds_sprel) (val), NOT_A_CHAR);
      break;
    case REG_PRIUNAT:
      add_unwind_entry (output_priunat_when_mem (), sep);
      add_unwind_entry ((psprel
			 ? output_priunat_psprel
			 : output_priunat_sprel) (val), NOT_A_CHAR);
      break;
    default:
      as_bad (_("First operand to .%s not a valid register"), po);
      add_unwind_entry (NULL, sep);
      break;
    }
}

static void
dot_saveg (int dummy ATTRIBUTE_UNUSED)
{
  expressionS e;
  unsigned grmask;
  int sep;

  if (!in_prologue ("save.g"))
    return;

  sep = parse_operand_and_eval (&e, ',');

  grmask = e.X_add_number;
  if (e.X_op != O_constant
      || e.X_add_number <= 0
      || e.X_add_number > 0xf)
    {
      as_bad (_("First operand to .save.g must be a positive 4-bit constant"));
      grmask = 0;
    }

  if (sep == ',')
    {
      unsigned reg;
      int n = popcount (grmask);

      parse_operand_and_eval (&e, 0);
      reg = e.X_add_number - REG_GR;
      if (e.X_op != O_register || reg > 127)
	{
	  as_bad (_("Second operand to .save.g must be a general register"));
	  reg = 0;
	}
      else if (reg > 128U - n)
	{
	  as_bad (_("Second operand to .save.g must be the first of %d general registers"), n);
	  reg = 0;
	}
      add_unwind_entry (output_gr_gr (grmask, reg), 0);
    }
  else
    add_unwind_entry (output_gr_mem (grmask), 0);
}

static void
dot_savef (int dummy ATTRIBUTE_UNUSED)
{
  expressionS e;

  if (!in_prologue ("save.f"))
    return;

  parse_operand_and_eval (&e, 0);

  if (e.X_op != O_constant
      || e.X_add_number <= 0
      || e.X_add_number > 0xfffff)
    {
      as_bad (_("Operand to .save.f must be a positive 20-bit constant"));
      e.X_add_number = 0;
    }
  add_unwind_entry (output_fr_mem (e.X_add_number), 0);
}

static void
dot_saveb (int dummy ATTRIBUTE_UNUSED)
{
  expressionS e;
  unsigned brmask;
  int sep;

  if (!in_prologue ("save.b"))
    return;

  sep = parse_operand_and_eval (&e, ',');

  brmask = e.X_add_number;
  if (e.X_op != O_constant
      || e.X_add_number <= 0
      || e.X_add_number > 0x1f)
    {
      as_bad (_("First operand to .save.b must be a positive 5-bit constant"));
      brmask = 0;
    }

  if (sep == ',')
    {
      unsigned reg;
      int n = popcount (brmask);

      parse_operand_and_eval (&e, 0);
      reg = e.X_add_number - REG_GR;
      if (e.X_op != O_register || reg > 127)
	{
	  as_bad (_("Second operand to .save.b must be a general register"));
	  reg = 0;
	}
      else if (reg > 128U - n)
	{
	  as_bad (_("Second operand to .save.b must be the first of %d general registers"), n);
	  reg = 0;
	}
      add_unwind_entry (output_br_gr (brmask, reg), 0);
    }
  else
    add_unwind_entry (output_br_mem (brmask), 0);
}

static void
dot_savegf (int dummy ATTRIBUTE_UNUSED)
{
  expressionS e1, e2;

  if (!in_prologue ("save.gf"))
    return;

  if (parse_operand_and_eval (&e1, ',') == ',')
    parse_operand_and_eval (&e2, 0);
  else
    e2.X_op = O_absent;

  if (e1.X_op != O_constant
      || e1.X_add_number < 0
      || e1.X_add_number > 0xf)
    {
      as_bad (_("First operand to .save.gf must be a non-negative 4-bit constant"));
      e1.X_op = O_absent;
      e1.X_add_number = 0;
    }
  if (e2.X_op != O_constant
      || e2.X_add_number < 0
      || e2.X_add_number > 0xfffff)
    {
      as_bad (_("Second operand to .save.gf must be a non-negative 20-bit constant"));
      e2.X_op = O_absent;
      e2.X_add_number = 0;
    }
  if (e1.X_op == O_constant
      && e2.X_op == O_constant
      && e1.X_add_number == 0
      && e2.X_add_number == 0)
    as_bad (_("Operands to .save.gf may not be both zero"));

  add_unwind_entry (output_frgr_mem (e1.X_add_number, e2.X_add_number), 0);
}

static void
dot_spill (int dummy ATTRIBUTE_UNUSED)
{
  expressionS e;

  if (!in_prologue ("spill"))
    return;

  parse_operand_and_eval (&e, 0);

  if (e.X_op != O_constant)
    {
      as_bad (_("Operand to .spill must be a constant"));
      e.X_add_number = 0;
    }
  add_unwind_entry (output_spill_base (e.X_add_number), 0);
}

static void
dot_spillreg (int pred)
{
  int sep;
  unsigned int qp, ab, xy, reg, treg;
  expressionS e;
  const char * const po = pred ? "spillreg.p" : "spillreg";

  if (!in_procedure (po))
    return;

  if (pred)
    sep = parse_predicate_and_operand (&e, &qp, po);
  else
    {
      sep = parse_operand_and_eval (&e, ',');
      qp = 0;
    }
  convert_expr_to_ab_reg (&e, &ab, &reg, po, 1 + pred);

  if (sep == ',')
    sep = parse_operand_and_eval (&e, ',');
  else
    e.X_op = O_absent;
  convert_expr_to_xy_reg (&e, &xy, &treg, po, 2 + pred);

  add_unwind_entry (output_spill_reg (ab, reg, treg, xy, qp), sep);
}

static void
dot_spillmem (int psprel)
{
  expressionS e;
  int pred = (psprel < 0), sep;
  unsigned int qp, ab, reg;
  const char * po;

  if (pred)
    {
      psprel = ~psprel;
      po = psprel ? "spillpsp.p" : "spillsp.p";
    }
  else
    po = psprel ? "spillpsp" : "spillsp";

  if (!in_procedure (po))
    return;

  if (pred)
    sep = parse_predicate_and_operand (&e, &qp, po);
  else
    {
      sep = parse_operand_and_eval (&e, ',');
      qp = 0;
    }
  convert_expr_to_ab_reg (&e, &ab, &reg, po, 1 + pred);

  if (sep == ',')
    sep = parse_operand_and_eval (&e, ',');
  else
    e.X_op = O_absent;
  if (e.X_op != O_constant)
    {
      as_bad (_("Operand %d to .%s must be a constant"), 2 + pred, po);
      e.X_add_number = 0;
    }

  if (psprel)
    add_unwind_entry (output_spill_psprel (ab, reg, e.X_add_number, qp), sep);
  else
    add_unwind_entry (output_spill_sprel (ab, reg, e.X_add_number, qp), sep);
}

static unsigned int
get_saved_prologue_count (unsigned long lbl)
{
  label_prologue_count *lpc = unwind.saved_prologue_counts;

  while (lpc != NULL && lpc->label_number != lbl)
    lpc = lpc->next;

  if (lpc != NULL)
    return lpc->prologue_count;

  as_bad (_("Missing .label_state %ld"), lbl);
  return 1;
}

static void
save_prologue_count (unsigned long lbl, unsigned int count)
{
  label_prologue_count *lpc = unwind.saved_prologue_counts;

  while (lpc != NULL && lpc->label_number != lbl)
    lpc = lpc->next;

  if (lpc != NULL)
    lpc->prologue_count = count;
  else
    {
      label_prologue_count *new_lpc = xmalloc (sizeof (* new_lpc));

      new_lpc->next = unwind.saved_prologue_counts;
      new_lpc->label_number = lbl;
      new_lpc->prologue_count = count;
      unwind.saved_prologue_counts = new_lpc;
    }
}

static void
free_saved_prologue_counts ()
{
  label_prologue_count *lpc = unwind.saved_prologue_counts;
  label_prologue_count *next;

  while (lpc != NULL)
    {
      next = lpc->next;
      free (lpc);
      lpc = next;
    }

  unwind.saved_prologue_counts = NULL;
}

static void
dot_label_state (int dummy ATTRIBUTE_UNUSED)
{
  expressionS e;

  if (!in_body ("label_state"))
    return;

  parse_operand_and_eval (&e, 0);
  if (e.X_op == O_constant)
    save_prologue_count (e.X_add_number, unwind.prologue_count);
  else
    {
      as_bad (_("Operand to .label_state must be a constant"));
      e.X_add_number = 0;
    }
  add_unwind_entry (output_label_state (e.X_add_number), 0);
}

static void
dot_copy_state (int dummy ATTRIBUTE_UNUSED)
{
  expressionS e;

  if (!in_body ("copy_state"))
    return;

  parse_operand_and_eval (&e, 0);
  if (e.X_op == O_constant)
    unwind.prologue_count = get_saved_prologue_count (e.X_add_number);
  else
    {
      as_bad (_("Operand to .copy_state must be a constant"));
      e.X_add_number = 0;
    }
  add_unwind_entry (output_copy_state (e.X_add_number), 0);
}

static void
dot_unwabi (int dummy ATTRIBUTE_UNUSED)
{
  expressionS e1, e2;
  unsigned char sep;

  if (!in_prologue ("unwabi"))
    return;

  sep = parse_operand_and_eval (&e1, ',');
  if (sep == ',')
    parse_operand_and_eval (&e2, 0);
  else
    e2.X_op = O_absent;

  if (e1.X_op != O_constant)
    {
      as_bad (_("First operand to .unwabi must be a constant"));
      e1.X_add_number = 0;
    }

  if (e2.X_op != O_constant)
    {
      as_bad (_("Second operand to .unwabi must be a constant"));
      e2.X_add_number = 0;
    }

  add_unwind_entry (output_unwabi (e1.X_add_number, e2.X_add_number), 0);
}

static void
dot_personality (int dummy ATTRIBUTE_UNUSED)
{
  char *name, *p, c;
  if (!in_procedure ("personality"))
    return;
  SKIP_WHITESPACE ();
  name = input_line_pointer;
  c = get_symbol_end ();
  p = input_line_pointer;
  unwind.personality_routine = symbol_find_or_make (name);
  unwind.force_unwind_entry = 1;
  *p = c;
  SKIP_WHITESPACE ();
  demand_empty_rest_of_line ();
}

static void
dot_proc (int dummy ATTRIBUTE_UNUSED)
{
  char *name, *p, c;
  symbolS *sym;
  proc_pending *pending, *last_pending;

  if (unwind.proc_pending.sym)
    {
      (md.unwind_check == unwind_check_warning
       ? as_warn
       : as_bad) (_("Missing .endp after previous .proc"));
      while (unwind.proc_pending.next)
	{
	  pending = unwind.proc_pending.next;
	  unwind.proc_pending.next = pending->next;
	  free (pending);
	}
    }
  last_pending = NULL;

  /* Parse names of main and alternate entry points and mark them as
     function symbols:  */
  while (1)
    {
      SKIP_WHITESPACE ();
      name = input_line_pointer;
      c = get_symbol_end ();
      p = input_line_pointer;
      if (!*name)
	as_bad (_("Empty argument of .proc"));
      else
	{
	  sym = symbol_find_or_make (name);
	  if (S_IS_DEFINED (sym))
	    as_bad (_("`%s' was already defined"), name);
	  else if (!last_pending)
	    {
	      unwind.proc_pending.sym = sym;
	      last_pending = &unwind.proc_pending;
	    }
	  else
	    {
	      pending = xmalloc (sizeof (*pending));
	      pending->sym = sym;
	      last_pending = last_pending->next = pending;
	    }
	  symbol_get_bfdsym (sym)->flags |= BSF_FUNCTION;
	}
      *p = c;
      SKIP_WHITESPACE ();
      if (*input_line_pointer != ',')
	break;
      ++input_line_pointer;
    }
  if (!last_pending)
    {
      unwind.proc_pending.sym = expr_build_dot ();
      last_pending = &unwind.proc_pending;
    }
  last_pending->next = NULL;
  demand_empty_rest_of_line ();
  ia64_do_align (16);

  unwind.prologue = 0;
  unwind.prologue_count = 0;
  unwind.body = 0;
  unwind.insn = 0;
  unwind.list = unwind.tail = unwind.current_entry = NULL;
  unwind.personality_routine = 0;
}

static void
dot_body (int dummy ATTRIBUTE_UNUSED)
{
  if (!in_procedure ("body"))
    return;
  if (!unwind.prologue && !unwind.body && unwind.insn)
    as_warn (_("Initial .body should precede any instructions"));
  check_pending_save ();

  unwind.prologue = 0;
  unwind.prologue_mask = 0;
  unwind.body = 1;

  add_unwind_entry (output_body (), 0);
}

static void
dot_prologue (int dummy ATTRIBUTE_UNUSED)
{
  unsigned mask = 0, grsave = 0;

  if (!in_procedure ("prologue"))
    return;
  if (unwind.prologue)
    {
      as_bad (_(".prologue within prologue"));
      ignore_rest_of_line ();
      return;
    }
  if (!unwind.body && unwind.insn)
    as_warn (_("Initial .prologue should precede any instructions"));

  if (!is_it_end_of_statement ())
    {
      expressionS e;
      int n, sep = parse_operand_and_eval (&e, ',');

      if (e.X_op != O_constant
	  || e.X_add_number < 0
	  || e.X_add_number > 0xf)
	as_bad (_("First operand to .prologue must be a positive 4-bit constant"));
      else if (e.X_add_number == 0)
	as_warn (_("Pointless use of zero first operand to .prologue"));
      else
	mask = e.X_add_number;
	n = popcount (mask);

      if (sep == ',')
	parse_operand_and_eval (&e, 0);
      else
	e.X_op = O_absent;
      if (e.X_op == O_constant
	  && e.X_add_number >= 0
	  && e.X_add_number < 128)
	{
	  if (md.unwind_check == unwind_check_error)
	    as_warn (_("Using a constant as second operand to .prologue is deprecated"));
	  grsave = e.X_add_number;
	}
      else if (e.X_op != O_register
	       || (grsave = e.X_add_number - REG_GR) > 127)
	{
	  as_bad (_("Second operand to .prologue must be a general register"));
	  grsave = 0;
	}
      else if (grsave > 128U - n)
	{
	  as_bad (_("Second operand to .prologue must be the first of %d general registers"), n);
	  grsave = 0;
	}

    }

  if (mask)
    add_unwind_entry (output_prologue_gr (mask, grsave), 0);
  else
    add_unwind_entry (output_prologue (), 0);

  unwind.prologue = 1;
  unwind.prologue_mask = mask;
  unwind.prologue_gr = grsave;
  unwind.body = 0;
  ++unwind.prologue_count;
}

static void
dot_endp (int dummy ATTRIBUTE_UNUSED)
{
  expressionS e;
  int bytes_per_address;
  long where;
  segT saved_seg;
  subsegT saved_subseg;
  proc_pending *pending;
  int unwind_check = md.unwind_check;

  md.unwind_check = unwind_check_error;
  if (!in_procedure ("endp"))
    return;
  md.unwind_check = unwind_check;

  if (unwind.saved_text_seg)
    {
      saved_seg = unwind.saved_text_seg;
      saved_subseg = unwind.saved_text_subseg;
      unwind.saved_text_seg = NULL;
    }
  else
    {
      saved_seg = now_seg;
      saved_subseg = now_subseg;
    }

  insn_group_break (1, 0, 0);

  /* If there wasn't a .handlerdata, we haven't generated an image yet.  */
  if (!unwind.info)
    generate_unwind_image (saved_seg);

  if (unwind.info || unwind.force_unwind_entry)
    {
      symbolS *proc_end;

      subseg_set (md.last_text_seg, 0);
      proc_end = expr_build_dot ();

      start_unwind_section (saved_seg, SPECIAL_SECTION_UNWIND);

      /* Make sure that section has 4 byte alignment for ILP32 and
         8 byte alignment for LP64.  */
      record_alignment (now_seg, md.pointer_size_shift);

      /* Need space for 3 pointers for procedure start, procedure end,
	 and unwind info.  */
      memset (frag_more (3 * md.pointer_size), 0, 3 * md.pointer_size);
      where = frag_now_fix () - (3 * md.pointer_size);
      bytes_per_address = bfd_arch_bits_per_address (stdoutput) / 8;

      /* Issue the values of  a) Proc Begin, b) Proc End, c) Unwind Record.  */
      e.X_op = O_pseudo_fixup;
      e.X_op_symbol = pseudo_func[FUNC_SEG_RELATIVE].u.sym;
      e.X_add_number = 0;
      if (!S_IS_LOCAL (unwind.proc_pending.sym)
	  && S_IS_DEFINED (unwind.proc_pending.sym))
	e.X_add_symbol = symbol_temp_new (S_GET_SEGMENT (unwind.proc_pending.sym),
					  S_GET_VALUE (unwind.proc_pending.sym),
					  symbol_get_frag (unwind.proc_pending.sym));
      else
	e.X_add_symbol = unwind.proc_pending.sym;
      ia64_cons_fix_new (frag_now, where, bytes_per_address, &e);

      e.X_op = O_pseudo_fixup;
      e.X_op_symbol = pseudo_func[FUNC_SEG_RELATIVE].u.sym;
      e.X_add_number = 0;
      e.X_add_symbol = proc_end;
      ia64_cons_fix_new (frag_now, where + bytes_per_address,
			 bytes_per_address, &e);

      if (unwind.info)
	{
	  e.X_op = O_pseudo_fixup;
	  e.X_op_symbol = pseudo_func[FUNC_SEG_RELATIVE].u.sym;
	  e.X_add_number = 0;
	  e.X_add_symbol = unwind.info;
	  ia64_cons_fix_new (frag_now, where + (bytes_per_address * 2),
			     bytes_per_address, &e);
	}
    }
  subseg_set (saved_seg, saved_subseg);

  /* Set symbol sizes.  */
  pending = &unwind.proc_pending;
  if (S_GET_NAME (pending->sym))
    {
      do
	{
	  symbolS *sym = pending->sym;

	  if (!S_IS_DEFINED (sym))
	    as_bad (_("`%s' was not defined within procedure"), S_GET_NAME (sym));
	  else if (S_GET_SIZE (sym) == 0
		   && symbol_get_obj (sym)->size == NULL)
	    {
	      fragS *frag = symbol_get_frag (sym);

	      if (frag)
		{
		  if (frag == frag_now && SEG_NORMAL (now_seg))
		    S_SET_SIZE (sym, frag_now_fix () - S_GET_VALUE (sym));
		  else
		    {
		      symbol_get_obj (sym)->size =
			(expressionS *) xmalloc (sizeof (expressionS));
		      symbol_get_obj (sym)->size->X_op = O_subtract;
		      symbol_get_obj (sym)->size->X_add_symbol
			= symbol_new (FAKE_LABEL_NAME, now_seg,
				      frag_now_fix (), frag_now);
		      symbol_get_obj (sym)->size->X_op_symbol = sym;
		      symbol_get_obj (sym)->size->X_add_number = 0;
		    }
		}
	    }
	} while ((pending = pending->next) != NULL);
    }

  /* Parse names of main and alternate entry points.  */
  while (1)
    {
      char *name, *p, c;

      SKIP_WHITESPACE ();
      name = input_line_pointer;
      c = get_symbol_end ();
      p = input_line_pointer;
      if (!*name)
	(md.unwind_check == unwind_check_warning
	 ? as_warn
	 : as_bad) (_("Empty argument of .endp"));
      else
	{
	  symbolS *sym = symbol_find (name);

	  for (pending = &unwind.proc_pending; pending; pending = pending->next)
	    {
	      if (sym == pending->sym)
		{
		  pending->sym = NULL;
		  break;
		}
	    }
	  if (!sym || !pending)
	    as_warn (_("`%s' was not specified with previous .proc"), name);
	}
      *p = c;
      SKIP_WHITESPACE ();
      if (*input_line_pointer != ',')
	break;
      ++input_line_pointer;
    }
  demand_empty_rest_of_line ();

  /* Deliberately only checking for the main entry point here; the
     language spec even says all arguments to .endp are ignored.  */
  if (unwind.proc_pending.sym
      && S_GET_NAME (unwind.proc_pending.sym)
      && strcmp (S_GET_NAME (unwind.proc_pending.sym), FAKE_LABEL_NAME))
    as_warn (_("`%s' should be an operand to this .endp"),
	     S_GET_NAME (unwind.proc_pending.sym));
  while (unwind.proc_pending.next)
    {
      pending = unwind.proc_pending.next;
      unwind.proc_pending.next = pending->next;
      free (pending);
    }
  unwind.proc_pending.sym = unwind.info = NULL;
}

static void
dot_template (int template_val)
{
  CURR_SLOT.user_template = template_val;
}

static void
dot_regstk (int dummy ATTRIBUTE_UNUSED)
{
  int ins, locs, outs, rots;

  if (is_it_end_of_statement ())
    ins = locs = outs = rots = 0;
  else
    {
      ins = get_absolute_expression ();
      if (*input_line_pointer++ != ',')
	goto err;
      locs = get_absolute_expression ();
      if (*input_line_pointer++ != ',')
	goto err;
      outs = get_absolute_expression ();
      if (*input_line_pointer++ != ',')
	goto err;
      rots = get_absolute_expression ();
    }
  set_regstack (ins, locs, outs, rots);
  return;

 err:
  as_bad (_("Comma expected"));
  ignore_rest_of_line ();
}

static void
dot_rot (int type)
{
  offsetT num_regs;
  valueT num_alloced = 0;
  struct dynreg **drpp, *dr;
  int ch, base_reg = 0;
  char *name, *start;
  size_t len;

  switch (type)
    {
    case DYNREG_GR: base_reg = REG_GR + 32; break;
    case DYNREG_FR: base_reg = REG_FR + 32; break;
    case DYNREG_PR: base_reg = REG_P + 16; break;
    default: break;
    }

  /* First, remove existing names from hash table.  */
  for (dr = md.dynreg[type]; dr && dr->num_regs; dr = dr->next)
    {
      hash_delete (md.dynreg_hash, dr->name, FALSE);
      /* FIXME: Free dr->name.  */
      dr->num_regs = 0;
    }

  drpp = &md.dynreg[type];
  while (1)
    {
      start = input_line_pointer;
      ch = get_symbol_end ();
      len = strlen (ia64_canonicalize_symbol_name (start));
      *input_line_pointer = ch;

      SKIP_WHITESPACE ();
      if (*input_line_pointer != '[')
	{
	  as_bad (_("Expected '['"));
	  goto err;
	}
      ++input_line_pointer;	/* skip '[' */

      num_regs = get_absolute_expression ();

      if (*input_line_pointer++ != ']')
	{
	  as_bad (_("Expected ']'"));
	  goto err;
	}
      if (num_regs <= 0)
	{
	  as_bad (_("Number of elements must be positive"));
	  goto err;
	}
      SKIP_WHITESPACE ();

      num_alloced += num_regs;
      switch (type)
	{
	case DYNREG_GR:
	  if (num_alloced > md.rot.num_regs)
	    {
	      as_bad (_("Used more than the declared %d rotating registers"),
		      md.rot.num_regs);
	      goto err;
	    }
	  break;
	case DYNREG_FR:
	  if (num_alloced > 96)
	    {
	      as_bad (_("Used more than the available 96 rotating registers"));
	      goto err;
	    }
	  break;
	case DYNREG_PR:
	  if (num_alloced > 48)
	    {
	      as_bad (_("Used more than the available 48 rotating registers"));
	      goto err;
	    }
	  break;

	default:
	  break;
	}

      if (!*drpp)
	{
	  *drpp = obstack_alloc (&notes, sizeof (*dr));
	  memset (*drpp, 0, sizeof (*dr));
	}

      name = obstack_alloc (&notes, len + 1);
      memcpy (name, start, len);
      name[len] = '\0';

      dr = *drpp;
      dr->name = name;
      dr->num_regs = num_regs;
      dr->base = base_reg;
      drpp = &dr->next;
      base_reg += num_regs;

      if (hash_insert (md.dynreg_hash, name, dr))
	{
	  as_bad (_("Attempt to redefine register set `%s'"), name);
	  obstack_free (&notes, name);
	  goto err;
	}

      if (*input_line_pointer != ',')
	break;
      ++input_line_pointer;	/* skip comma */
      SKIP_WHITESPACE ();
    }
  demand_empty_rest_of_line ();
  return;

 err:
  ignore_rest_of_line ();
}

static void
dot_byteorder (int byteorder)
{
  segment_info_type *seginfo = seg_info (now_seg);

  if (byteorder == -1)
    {
      if (seginfo->tc_segment_info_data.endian == 0)
	seginfo->tc_segment_info_data.endian = default_big_endian ? 1 : 2;
      byteorder = seginfo->tc_segment_info_data.endian == 1;
    }
  else
    seginfo->tc_segment_info_data.endian = byteorder ? 1 : 2;

  if (target_big_endian != byteorder)
    {
      target_big_endian = byteorder;
      if (target_big_endian)
	{
	  ia64_number_to_chars = number_to_chars_bigendian;
	  ia64_float_to_chars = ia64_float_to_chars_bigendian;
	}
      else
	{
	  ia64_number_to_chars = number_to_chars_littleendian;
	  ia64_float_to_chars = ia64_float_to_chars_littleendian;
	}
    }
}

static void
dot_psr (int dummy ATTRIBUTE_UNUSED)
{
  char *option;
  int ch;

  while (1)
    {
      option = input_line_pointer;
      ch = get_symbol_end ();
      if (strcmp (option, "lsb") == 0)
	md.flags &= ~EF_IA_64_BE;
      else if (strcmp (option, "msb") == 0)
	md.flags |= EF_IA_64_BE;
      else if (strcmp (option, "abi32") == 0)
	md.flags &= ~EF_IA_64_ABI64;
      else if (strcmp (option, "abi64") == 0)
	md.flags |= EF_IA_64_ABI64;
      else
	as_bad (_("Unknown psr option `%s'"), option);
      *input_line_pointer = ch;

      SKIP_WHITESPACE ();
      if (*input_line_pointer != ',')
	break;

      ++input_line_pointer;
      SKIP_WHITESPACE ();
    }
  demand_empty_rest_of_line ();
}

static void
dot_ln (int dummy ATTRIBUTE_UNUSED)
{
  new_logical_line (0, get_absolute_expression ());
  demand_empty_rest_of_line ();
}

static void
cross_section (int ref, void (*builder) (int), int ua)
{
  char *start, *end;
  int saved_auto_align;
  unsigned int section_count;

  SKIP_WHITESPACE ();
  start = input_line_pointer;
  if (*start == '"')
    {
      int len;
      char *name;

      name = demand_copy_C_string (&len);
      obstack_free(&notes, name);
      if (!name)
	{
	  ignore_rest_of_line ();
	  return;
	}
    }
  else
    {
      char c = get_symbol_end ();

      if (input_line_pointer == start)
	{
	  as_bad (_("Missing section name"));
	  ignore_rest_of_line ();
	  return;
	}
      *input_line_pointer = c;
    }
  end = input_line_pointer;
  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
      as_bad (_("Comma expected after section name"));
      ignore_rest_of_line ();
      return;
    }
  *end = '\0';
  end = input_line_pointer + 1;		/* skip comma */
  input_line_pointer = start;
  md.keep_pending_output = 1;
  section_count = bfd_count_sections (stdoutput);
  obj_elf_section (0);
  if (section_count != bfd_count_sections (stdoutput))
    as_warn (_("Creating sections with .xdataN/.xrealN/.xstringZ is deprecated."));
  input_line_pointer = end;
  saved_auto_align = md.auto_align;
  if (ua)
    md.auto_align = 0;
  (*builder) (ref);
  if (ua)
    md.auto_align = saved_auto_align;
  obj_elf_previous (0);
  md.keep_pending_output = 0;
}

static void
dot_xdata (int size)
{
  cross_section (size, cons, 0);
}

/* Why doesn't float_cons() call md_cons_align() the way cons() does?  */

static void
stmt_float_cons (int kind)
{
  size_t alignment;

  switch (kind)
    {
    case 'd':
      alignment = 8;
      break;

    case 'x':
    case 'X':
      alignment = 16;
      break;

    case 'f':
    default:
      alignment = 4;
      break;
    }
  ia64_do_align (alignment);
  float_cons (kind);
}

static void
stmt_cons_ua (int size)
{
  int saved_auto_align = md.auto_align;

  md.auto_align = 0;
  cons (size);
  md.auto_align = saved_auto_align;
}

static void
dot_xfloat_cons (int kind)
{
  cross_section (kind, stmt_float_cons, 0);
}

static void
dot_xstringer (int zero)
{
  cross_section (zero, stringer, 0);
}

static void
dot_xdata_ua (int size)
{
  cross_section (size, cons, 1);
}

static void
dot_xfloat_cons_ua (int kind)
{
  cross_section (kind, float_cons, 1);
}

/* .reg.val <regname>,value */

static void
dot_reg_val (int dummy ATTRIBUTE_UNUSED)
{
  expressionS reg;

  expression_and_evaluate (&reg);
  if (reg.X_op != O_register)
    {
      as_bad (_("Register name expected"));
      ignore_rest_of_line ();
    }
  else if (*input_line_pointer++ != ',')
    {
      as_bad (_("Comma expected"));
      ignore_rest_of_line ();
    }
  else
    {
      valueT value = get_absolute_expression ();
      int regno = reg.X_add_number;
      if (regno <= REG_GR || regno > REG_GR + 127)
	as_warn (_("Register value annotation ignored"));
      else
	{
	  gr_values[regno - REG_GR].known = 1;
	  gr_values[regno - REG_GR].value = value;
	  gr_values[regno - REG_GR].path = md.path;
	}
    }
  demand_empty_rest_of_line ();
}

/*
  .serialize.data
  .serialize.instruction
 */
static void
dot_serialize (int type)
{
  insn_group_break (0, 0, 0);
  if (type)
    instruction_serialization ();
  else
    data_serialization ();
  insn_group_break (0, 0, 0);
  demand_empty_rest_of_line ();
}

/* select dv checking mode
   .auto
   .explicit
   .default

   A stop is inserted when changing modes
 */

static void
dot_dv_mode (int type)
{
  if (md.manual_bundling)
    as_warn (_("Directive invalid within a bundle"));

  if (type == 'E' || type == 'A')
    md.mode_explicitly_set = 0;
  else
    md.mode_explicitly_set = 1;

  md.detect_dv = 1;
  switch (type)
    {
    case 'A':
    case 'a':
      if (md.explicit_mode)
	insn_group_break (1, 0, 0);
      md.explicit_mode = 0;
      break;
    case 'E':
    case 'e':
      if (!md.explicit_mode)
	insn_group_break (1, 0, 0);
      md.explicit_mode = 1;
      break;
    default:
    case 'd':
      if (md.explicit_mode != md.default_explicit_mode)
	insn_group_break (1, 0, 0);
      md.explicit_mode = md.default_explicit_mode;
      md.mode_explicitly_set = 0;
      break;
    }
}

static void
print_prmask (valueT mask)
{
  int regno;
  char *comma = "";
  for (regno = 0; regno < 64; regno++)
    {
      if (mask & ((valueT) 1 << regno))
	{
	  fprintf (stderr, "%s p%d", comma, regno);
	  comma = ",";
	}
    }
}

/*
  .pred.rel.clear [p1 [,p2 [,...]]]     (also .pred.rel "clear" or @@clear)
  .pred.rel.imply p1, p2                (also .pred.rel "imply" or @@imply)
  .pred.rel.mutex p1, p2 [,...]         (also .pred.rel "mutex" or @@mutex)
  .pred.safe_across_calls p1 [, p2 [,...]]
 */

static void
dot_pred_rel (int type)
{
  valueT mask = 0;
  int count = 0;
  int p1 = -1, p2 = -1;

  if (type == 0)
    {
      if (*input_line_pointer == '"')
	{
	  int len;
	  char *form = demand_copy_C_string (&len);

	  if (strcmp (form, "mutex") == 0)
	    type = 'm';
	  else if (strcmp (form, "clear") == 0)
	    type = 'c';
	  else if (strcmp (form, "imply") == 0)
	    type = 'i';
	  obstack_free (&notes, form);
	}
      else if (*input_line_pointer == '@@')
	{
	  char *form = ++input_line_pointer;
	  char c = get_symbol_end();

	  if (strcmp (form, "mutex") == 0)
	    type = 'm';
	  else if (strcmp (form, "clear") == 0)
	    type = 'c';
	  else if (strcmp (form, "imply") == 0)
	    type = 'i';
	  *input_line_pointer = c;
	}
      else
	{
	  as_bad (_("Missing predicate relation type"));
	  ignore_rest_of_line ();
	  return;
	}
      if (type == 0)
	{
	  as_bad (_("Unrecognized predicate relation type"));
	  ignore_rest_of_line ();
	  return;
	}
      if (*input_line_pointer == ',')
	++input_line_pointer;
      SKIP_WHITESPACE ();
    }

  while (1)
    {
      valueT bits = 1;
      int sep, regno;
      expressionS pr, *pr1, *pr2;

      sep = parse_operand_and_eval (&pr, ',');
      if (pr.X_op == O_register
	  && pr.X_add_number >= REG_P
	  && pr.X_add_number <= REG_P + 63)
	{
	  regno = pr.X_add_number - REG_P;
	  bits <<= regno;
	  count++;
	  if (p1 == -1)
	    p1 = regno;
	  else if (p2 == -1)
	    p2 = regno;
	}
      else if (type != 'i'
	  && pr.X_op == O_subtract
	  && (pr1 = symbol_get_value_expression (pr.X_add_symbol))
	  && pr1->X_op == O_register
	  && pr1->X_add_number >= REG_P
	  && pr1->X_add_number <= REG_P + 63
	  && (pr2 = symbol_get_value_expression (pr.X_op_symbol))
	  && pr2->X_op == O_register
	  && pr2->X_add_number >= REG_P
	  && pr2->X_add_number <= REG_P + 63)
	{
	  /* It's a range.  */
	  int stop;

	  regno = pr1->X_add_number - REG_P;
	  stop = pr2->X_add_number - REG_P;
	  if (regno >= stop)
	    {
	      as_bad (_("Bad register range"));
	      ignore_rest_of_line ();
	      return;
	    }
	  bits = ((bits << stop) << 1) - (bits << regno);
	  count += stop - regno + 1;
	}
      else
	{
	  as_bad (_("Predicate register expected"));
	  ignore_rest_of_line ();
	  return;
	}
      if (mask & bits)
	as_warn (_("Duplicate predicate register ignored"));
      mask |= bits;
      if (sep != ',')
	break;
    }

  switch (type)
    {
    case 'c':
      if (count == 0)
	mask = ~(valueT) 0;
      clear_qp_mutex (mask);
      clear_qp_implies (mask, (valueT) 0);
      break;
    case 'i':
      if (count != 2 || p1 == -1 || p2 == -1)
	as_bad (_("Predicate source and target required"));
      else if (p1 == 0 || p2 == 0)
	as_bad (_("Use of p0 is not valid in this context"));
      else
	add_qp_imply (p1, p2);
      break;
    case 'm':
      if (count < 2)
	{
	  as_bad (_("At least two PR arguments expected"));
	  break;
	}
      else if (mask & 1)
	{
	  as_bad (_("Use of p0 is not valid in this context"));
	  break;
	}
      add_qp_mutex (mask);
      break;
    case 's':
      /* note that we don't override any existing relations */
      if (count == 0)
	{
	  as_bad (_("At least one PR argument expected"));
	  break;
	}
      if (md.debug_dv)
	{
	  fprintf (stderr, "Safe across calls: ");
	  print_prmask (mask);
	  fprintf (stderr, "\n");
	}
      qp_safe_across_calls = mask;
      break;
    }
  demand_empty_rest_of_line ();
}

/* .entry label [, label [, ...]]
   Hint to DV code that the given labels are to be considered entry points.
   Otherwise, only global labels are considered entry points.  */

static void
dot_entry (int dummy ATTRIBUTE_UNUSED)
{
  const char *err;
  char *name;
  int c;
  symbolS *symbolP;

  do
    {
      name = input_line_pointer;
      c = get_symbol_end ();
      symbolP = symbol_find_or_make (name);

      err = hash_insert (md.entry_hash, S_GET_NAME (symbolP), (void *) symbolP);
      if (err)
	as_fatal (_("Inserting \"%s\" into entry hint table failed: %s"),
		  name, err);

      *input_line_pointer = c;
      SKIP_WHITESPACE ();
      c = *input_line_pointer;
      if (c == ',')
	{
	  input_line_pointer++;
	  SKIP_WHITESPACE ();
	  if (*input_line_pointer == '\n')
	    c = '\n';
	}
    }
  while (c == ',');

  demand_empty_rest_of_line ();
}

/* .mem.offset offset, base
   "base" is used to distinguish between offsets from a different base.  */

static void
dot_mem_offset (int dummy ATTRIBUTE_UNUSED)
{
  md.mem_offset.hint = 1;
  md.mem_offset.offset = get_absolute_expression ();
  if (*input_line_pointer != ',')
    {
      as_bad (_("Comma expected"));
      ignore_rest_of_line ();
      return;
    }
  ++input_line_pointer;
  md.mem_offset.base = get_absolute_expression ();
  demand_empty_rest_of_line ();
}

/* ia64-specific pseudo-ops:  */
const pseudo_typeS md_pseudo_table[] =
  {
    { "radix", dot_radix, 0 },
    { "lcomm", s_lcomm_bytes, 1 },
    { "loc", dot_loc, 0 },
    { "bss", dot_special_section, SPECIAL_SECTION_BSS },
    { "sbss", dot_special_section, SPECIAL_SECTION_SBSS },
    { "sdata", dot_special_section, SPECIAL_SECTION_SDATA },
    { "rodata", dot_special_section, SPECIAL_SECTION_RODATA },
    { "comment", dot_special_section, SPECIAL_SECTION_COMMENT },
    { "ia_64.unwind", dot_special_section, SPECIAL_SECTION_UNWIND },
    { "ia_64.unwind_info", dot_special_section, SPECIAL_SECTION_UNWIND_INFO },
    { "init_array", dot_special_section, SPECIAL_SECTION_INIT_ARRAY },
    { "fini_array", dot_special_section, SPECIAL_SECTION_FINI_ARRAY },
    { "proc", dot_proc, 0 },
    { "body", dot_body, 0 },
    { "prologue", dot_prologue, 0 },
    { "endp", dot_endp, 0 },

    { "fframe", dot_fframe, 0 },
    { "vframe", dot_vframe, 0 },
    { "vframesp", dot_vframesp, 0 },
    { "vframepsp", dot_vframesp, 1 },
    { "save", dot_save, 0 },
    { "restore", dot_restore, 0 },
    { "restorereg", dot_restorereg, 0 },
    { "restorereg.p", dot_restorereg, 1 },
    { "handlerdata", dot_handlerdata, 0 },
    { "unwentry", dot_unwentry, 0 },
    { "altrp", dot_altrp, 0 },
    { "savesp", dot_savemem, 0 },
    { "savepsp", dot_savemem, 1 },
    { "save.g", dot_saveg, 0 },
    { "save.f", dot_savef, 0 },
    { "save.b", dot_saveb, 0 },
    { "save.gf", dot_savegf, 0 },
    { "spill", dot_spill, 0 },
    { "spillreg", dot_spillreg, 0 },
    { "spillsp", dot_spillmem, 0 },
    { "spillpsp", dot_spillmem, 1 },
    { "spillreg.p", dot_spillreg, 1 },
    { "spillsp.p", dot_spillmem, ~0 },
    { "spillpsp.p", dot_spillmem, ~1 },
    { "label_state", dot_label_state, 0 },
    { "copy_state", dot_copy_state, 0 },
    { "unwabi", dot_unwabi, 0 },
    { "personality", dot_personality, 0 },
    { "mii", dot_template, 0x0 },
    { "mli", dot_template, 0x2 }, /* old format, for compatibility */
    { "mlx", dot_template, 0x2 },
    { "mmi", dot_template, 0x4 },
    { "mfi", dot_template, 0x6 },
    { "mmf", dot_template, 0x7 },
    { "mib", dot_template, 0x8 },
    { "mbb", dot_template, 0x9 },
    { "bbb", dot_template, 0xb },
    { "mmb", dot_template, 0xc },
    { "mfb", dot_template, 0xe },
    { "align", dot_align, 0 },
    { "regstk", dot_regstk, 0 },
    { "rotr", dot_rot, DYNREG_GR },
    { "rotf", dot_rot, DYNREG_FR },
    { "rotp", dot_rot, DYNREG_PR },
    { "lsb", dot_byteorder, 0 },
    { "msb", dot_byteorder, 1 },
    { "psr", dot_psr, 0 },
    { "alias", dot_alias, 0 },
    { "secalias", dot_alias, 1 },
    { "ln", dot_ln, 0 },		/* source line info (for debugging) */

    { "xdata1", dot_xdata, 1 },
    { "xdata2", dot_xdata, 2 },
    { "xdata4", dot_xdata, 4 },
    { "xdata8", dot_xdata, 8 },
    { "xdata16", dot_xdata, 16 },
    { "xreal4", dot_xfloat_cons, 'f' },
    { "xreal8", dot_xfloat_cons, 'd' },
    { "xreal10", dot_xfloat_cons, 'x' },
    { "xreal16", dot_xfloat_cons, 'X' },
    { "xstring", dot_xstringer, 8 + 0 },
    { "xstringz", dot_xstringer, 8 + 1 },

    /* unaligned versions:  */
    { "xdata2.ua", dot_xdata_ua, 2 },
    { "xdata4.ua", dot_xdata_ua, 4 },
    { "xdata8.ua", dot_xdata_ua, 8 },
    { "xdata16.ua", dot_xdata_ua, 16 },
    { "xreal4.ua", dot_xfloat_cons_ua, 'f' },
    { "xreal8.ua", dot_xfloat_cons_ua, 'd' },
    { "xreal10.ua", dot_xfloat_cons_ua, 'x' },
    { "xreal16.ua", dot_xfloat_cons_ua, 'X' },

    /* annotations/DV checking support */
    { "entry", dot_entry, 0 },
    { "mem.offset", dot_mem_offset, 0 },
    { "pred.rel", dot_pred_rel, 0 },
    { "pred.rel.clear", dot_pred_rel, 'c' },
    { "pred.rel.imply", dot_pred_rel, 'i' },
    { "pred.rel.mutex", dot_pred_rel, 'm' },
    { "pred.safe_across_calls", dot_pred_rel, 's' },
    { "reg.val", dot_reg_val, 0 },
    { "serialize.data", dot_serialize, 0 },
    { "serialize.instruction", dot_serialize, 1 },
    { "auto", dot_dv_mode, 'a' },
    { "explicit", dot_dv_mode, 'e' },
    { "default", dot_dv_mode, 'd' },

    /* ??? These are needed to make gas/testsuite/gas/elf/ehopt.s work.
       IA-64 aligns data allocation pseudo-ops by default, so we have to
       tell it that these ones are supposed to be unaligned.  Long term,
       should rewrite so that only IA-64 specific data allocation pseudo-ops
       are aligned by default.  */
    {"2byte", stmt_cons_ua, 2},
    {"4byte", stmt_cons_ua, 4},
    {"8byte", stmt_cons_ua, 8},

#ifdef TE_VMS
    {"vms_common", obj_elf_vms_common, 0},
#endif

    { NULL, 0, 0 }
  };

static const struct pseudo_opcode
  {
    const char *name;
    void (*handler) (int);
    int arg;
  }
pseudo_opcode[] =
  {
    /* these are more like pseudo-ops, but don't start with a dot */
    { "data1", cons, 1 },
    { "data2", cons, 2 },
    { "data4", cons, 4 },
    { "data8", cons, 8 },
    { "data16", cons, 16 },
    { "real4", stmt_float_cons, 'f' },
    { "real8", stmt_float_cons, 'd' },
    { "real10", stmt_float_cons, 'x' },
    { "real16", stmt_float_cons, 'X' },
    { "string", stringer, 8 + 0 },
    { "stringz", stringer, 8 + 1 },

    /* unaligned versions:  */
    { "data2.ua", stmt_cons_ua, 2 },
    { "data4.ua", stmt_cons_ua, 4 },
    { "data8.ua", stmt_cons_ua, 8 },
    { "data16.ua", stmt_cons_ua, 16 },
    { "real4.ua", float_cons, 'f' },
    { "real8.ua", float_cons, 'd' },
    { "real10.ua", float_cons, 'x' },
    { "real16.ua", float_cons, 'X' },
  };

/* Declare a register by creating a symbol for it and entering it in
   the symbol table.  */

static symbolS *
declare_register (const char *name, unsigned int regnum)
{
  const char *err;
  symbolS *sym;

  sym = symbol_create (name, reg_section, regnum, &zero_address_frag);

  err = hash_insert (md.reg_hash, S_GET_NAME (sym), (void *) sym);
  if (err)
    as_fatal ("Inserting \"%s\" into register table failed: %s",
	      name, err);

  return sym;
}

static void
declare_register_set (const char *prefix,
		      unsigned int num_regs,
		      unsigned int base_regnum)
{
  char name[8];
  unsigned int i;

  for (i = 0; i < num_regs; ++i)
    {
      snprintf (name, sizeof (name), "%s%u", prefix, i);
      declare_register (name, base_regnum + i);
    }
}

static unsigned int
operand_width (enum ia64_opnd opnd)
{
  const struct ia64_operand *odesc = &elf64_ia64_operands[opnd];
  unsigned int bits = 0;
  int i;

  bits = 0;
  for (i = 0; i < NELEMS (odesc->field) && odesc->field[i].bits; ++i)
    bits += odesc->field[i].bits;

  return bits;
}

static enum operand_match_result
operand_match (const struct ia64_opcode *idesc, int res_index, expressionS *e)
{
  enum ia64_opnd opnd = idesc->operands[res_index];
  int bits, relocatable = 0;
  struct insn_fix *fix;
  bfd_signed_vma val;

  switch (opnd)
    {
      /* constants:  */

    case IA64_OPND_AR_CCV:
      if (e->X_op == O_register && e->X_add_number == REG_AR + 32)
	return OPERAND_MATCH;
      break;

    case IA64_OPND_AR_CSD:
      if (e->X_op == O_register && e->X_add_number == REG_AR + 25)
	return OPERAND_MATCH;
      break;

    case IA64_OPND_AR_PFS:
      if (e->X_op == O_register && e->X_add_number == REG_AR + 64)
	return OPERAND_MATCH;
      break;

    case IA64_OPND_GR0:
      if (e->X_op == O_register && e->X_add_number == REG_GR + 0)
	return OPERAND_MATCH;
      break;

    case IA64_OPND_IP:
      if (e->X_op == O_register && e->X_add_number == REG_IP)
	return OPERAND_MATCH;
      break;

    case IA64_OPND_PR:
      if (e->X_op == O_register && e->X_add_number == REG_PR)
	return OPERAND_MATCH;
      break;

    case IA64_OPND_PR_ROT:
      if (e->X_op == O_register && e->X_add_number == REG_PR_ROT)
	return OPERAND_MATCH;
      break;

    case IA64_OPND_PSR:
      if (e->X_op == O_register && e->X_add_number == REG_PSR)
	return OPERAND_MATCH;
      break;

    case IA64_OPND_PSR_L:
      if (e->X_op == O_register && e->X_add_number == REG_PSR_L)
	return OPERAND_MATCH;
      break;

    case IA64_OPND_PSR_UM:
      if (e->X_op == O_register && e->X_add_number == REG_PSR_UM)
	return OPERAND_MATCH;
      break;

    case IA64_OPND_C1:
      if (e->X_op == O_constant)
	{
	  if (e->X_add_number == 1)
	    return OPERAND_MATCH;
	  else
	    return OPERAND_OUT_OF_RANGE;
	}
      break;

    case IA64_OPND_C8:
      if (e->X_op == O_constant)
	{
	  if (e->X_add_number == 8)
	    return OPERAND_MATCH;
	  else
	    return OPERAND_OUT_OF_RANGE;
	}
      break;

    case IA64_OPND_C16:
      if (e->X_op == O_constant)
	{
	  if (e->X_add_number == 16)
	    return OPERAND_MATCH;
	  else
	    return OPERAND_OUT_OF_RANGE;
	}
      break;

      /* register operands:  */

    case IA64_OPND_AR3:
      if (e->X_op == O_register && e->X_add_number >= REG_AR
	  && e->X_add_number < REG_AR + 128)
	return OPERAND_MATCH;
      break;

    case IA64_OPND_B1:
    case IA64_OPND_B2:
      if (e->X_op == O_register && e->X_add_number >= REG_BR
	  && e->X_add_number < REG_BR + 8)
	return OPERAND_MATCH;
      break;

    case IA64_OPND_CR3:
      if (e->X_op == O_register && e->X_add_number >= REG_CR
	  && e->X_add_number < REG_CR + 128)
	return OPERAND_MATCH;
      break;

    case IA64_OPND_DAHR3:
      if (e->X_op == O_register && e->X_add_number >= REG_DAHR
	  && e->X_add_number < REG_DAHR + 8)
	return OPERAND_MATCH;
      break;

    case IA64_OPND_F1:
    case IA64_OPND_F2:
    case IA64_OPND_F3:
    case IA64_OPND_F4:
      if (e->X_op == O_register && e->X_add_number >= REG_FR
	  && e->X_add_number < REG_FR + 128)
	return OPERAND_MATCH;
      break;

    case IA64_OPND_P1:
    case IA64_OPND_P2:
      if (e->X_op == O_register && e->X_add_number >= REG_P
	  && e->X_add_number < REG_P + 64)
	return OPERAND_MATCH;
      break;

    case IA64_OPND_R1:
    case IA64_OPND_R2:
    case IA64_OPND_R3:
      if (e->X_op == O_register && e->X_add_number >= REG_GR
	  && e->X_add_number < REG_GR + 128)
	return OPERAND_MATCH;
      break;

    case IA64_OPND_R3_2:
      if (e->X_op == O_register && e->X_add_number >= REG_GR)
	{
	  if (e->X_add_number < REG_GR + 4)
	    return OPERAND_MATCH;
	  else if (e->X_add_number < REG_GR + 128)
	    return OPERAND_OUT_OF_RANGE;
	}
      break;

      /* indirect operands:  */
    case IA64_OPND_CPUID_R3:
    case IA64_OPND_DBR_R3:
    case IA64_OPND_DTR_R3:
    case IA64_OPND_ITR_R3:
    case IA64_OPND_IBR_R3:
    case IA64_OPND_MSR_R3:
    case IA64_OPND_PKR_R3:
    case IA64_OPND_PMC_R3:
    case IA64_OPND_PMD_R3:
    case IA64_OPND_DAHR_R3:
    case IA64_OPND_RR_R3:
      if (e->X_op == O_index && e->X_op_symbol
	  && (S_GET_VALUE (e->X_op_symbol) - IND_CPUID
	      == opnd - IA64_OPND_CPUID_R3))
	return OPERAND_MATCH;
      break;

    case IA64_OPND_MR3:
      if (e->X_op == O_index && !e->X_op_symbol)
	return OPERAND_MATCH;
      break;

      /* immediate operands:  */
    case IA64_OPND_CNT2a:
    case IA64_OPND_LEN4:
    case IA64_OPND_LEN6:
      bits = operand_width (idesc->operands[res_index]);
      if (e->X_op == O_constant)
	{
	  if ((bfd_vma) (e->X_add_number - 1) < ((bfd_vma) 1 << bits))
	    return OPERAND_MATCH;
	  else
	    return OPERAND_OUT_OF_RANGE;
	}
      break;

    case IA64_OPND_CNT2b:
      if (e->X_op == O_constant)
	{
	  if ((bfd_vma) (e->X_add_number - 1) < 3)
	    return OPERAND_MATCH;
	  else
	    return OPERAND_OUT_OF_RANGE;
	}
      break;

    case IA64_OPND_CNT2c:
      val = e->X_add_number;
      if (e->X_op == O_constant)
	{
	  if ((val == 0 || val == 7 || val == 15 || val == 16))
	    return OPERAND_MATCH;
	  else
	    return OPERAND_OUT_OF_RANGE;
	}
      break;

    case IA64_OPND_SOR:
      /* SOR must be an integer multiple of 8 */
      if (e->X_op == O_constant && e->X_add_number & 0x7)
	return OPERAND_OUT_OF_RANGE;
    case IA64_OPND_SOF:
    case IA64_OPND_SOL:
      if (e->X_op == O_constant)
	{
	  if ((bfd_vma) e->X_add_number <= 96)
	    return OPERAND_MATCH;
	  else
	    return OPERAND_OUT_OF_RANGE;
	}
      break;

    case IA64_OPND_IMMU62:
      if (e->X_op == O_constant)
	{
	  if ((bfd_vma) e->X_add_number < ((bfd_vma) 1 << 62))
	    return OPERAND_MATCH;
	  else
	    return OPERAND_OUT_OF_RANGE;
	}
      else
	{
	  /* FIXME -- need 62-bit relocation type */
	  as_bad (_("62-bit relocation not yet implemented"));
	}
      break;

    case IA64_OPND_IMMU64:
      if (e->X_op == O_symbol || e->X_op == O_pseudo_fixup
	  || e->X_op == O_subtract)
	{
	  fix = CURR_SLOT.fixup + CURR_SLOT.num_fixups;
	  fix->code = BFD_RELOC_IA64_IMM64;
	  if (e->X_op != O_subtract)
	    {
	      fix->code = ia64_gen_real_reloc_type (e->X_op_symbol, fix->code);
	      if (e->X_op == O_pseudo_fixup)
		e->X_op = O_symbol;
	    }

	  fix->opnd = idesc->operands[res_index];
	  fix->expr = *e;
	  fix->is_pcrel = 0;
	  ++CURR_SLOT.num_fixups;
	  return OPERAND_MATCH;
	}
      else if (e->X_op == O_constant)
	return OPERAND_MATCH;
      break;

    case IA64_OPND_IMMU5b:
      if (e->X_op == O_constant)
	{
	  val = e->X_add_number;
	  if (val >= 32 && val <= 63)
	    return OPERAND_MATCH;
	  else
	    return OPERAND_OUT_OF_RANGE;
	}
      break;

    case IA64_OPND_CCNT5:
    case IA64_OPND_CNT5:
    case IA64_OPND_CNT6:
    case IA64_OPND_CPOS6a:
    case IA64_OPND_CPOS6b:
    case IA64_OPND_CPOS6c:
    case IA64_OPND_IMMU2:
    case IA64_OPND_IMMU7a:
    case IA64_OPND_IMMU7b:
    case IA64_OPND_IMMU16:
    case IA64_OPND_IMMU19:
    case IA64_OPND_IMMU21:
    case IA64_OPND_IMMU24:
    case IA64_OPND_MBTYPE4:
    case IA64_OPND_MHTYPE8:
    case IA64_OPND_POS6:
      bits = operand_width (idesc->operands[res_index]);
      if (e->X_op == O_constant)
	{
	  if ((bfd_vma) e->X_add_number < ((bfd_vma) 1 << bits))
	    return OPERAND_MATCH;
	  else
	    return OPERAND_OUT_OF_RANGE;
	}
      break;

    case IA64_OPND_IMMU9:
      bits = operand_width (idesc->operands[res_index]);
      if (e->X_op == O_constant)
	{
	  if ((bfd_vma) e->X_add_number < ((bfd_vma) 1 << bits))
	    {
	      int lobits = e->X_add_number & 0x3;
	      if (((bfd_vma) e->X_add_number & 0x3C) != 0 && lobits == 0)
		e->X_add_number |= (bfd_vma) 0x3;
	      return OPERAND_MATCH;
	    }
	  else
	    return OPERAND_OUT_OF_RANGE;
	}
      break;

    case IA64_OPND_IMM44:
      /* least 16 bits must be zero */
      if ((e->X_add_number & 0xffff) != 0)
	/* XXX technically, this is wrong: we should not be issuing warning
	   messages until we're sure this instruction pattern is going to
	   be used! */
	as_warn (_("lower 16 bits of mask ignored"));

      if (e->X_op == O_constant)
	{
	  if (((e->X_add_number >= 0
		&& (bfd_vma) e->X_add_number < ((bfd_vma) 1 << 44))
	       || (e->X_add_number < 0
		   && (bfd_vma) -e->X_add_number <= ((bfd_vma) 1 << 44))))
	    {
	      /* sign-extend */
	      if (e->X_add_number >= 0
		  && (e->X_add_number & ((bfd_vma) 1 << 43)) != 0)
		{
		  e->X_add_number |= ~(((bfd_vma) 1 << 44) - 1);
		}
	      return OPERAND_MATCH;
	    }
	  else
	    return OPERAND_OUT_OF_RANGE;
	}
      break;

    case IA64_OPND_IMM17:
      /* bit 0 is a don't care (pr0 is hardwired to 1) */
      if (e->X_op == O_constant)
	{
	  if (((e->X_add_number >= 0
		&& (bfd_vma) e->X_add_number < ((bfd_vma) 1 << 17))
	       || (e->X_add_number < 0
		   && (bfd_vma) -e->X_add_number <= ((bfd_vma) 1 << 17))))
	    {
	      /* sign-extend */
	      if (e->X_add_number >= 0
		  && (e->X_add_number & ((bfd_vma) 1 << 16)) != 0)
		{
		  e->X_add_number |= ~(((bfd_vma) 1 << 17) - 1);
		}
	      return OPERAND_MATCH;
	    }
	  else
	    return OPERAND_OUT_OF_RANGE;
	}
      break;

    case IA64_OPND_IMM14:
    case IA64_OPND_IMM22:
      relocatable = 1;
    case IA64_OPND_IMM1:
    case IA64_OPND_IMM8:
    case IA64_OPND_IMM8U4:
    case IA64_OPND_IMM8M1:
    case IA64_OPND_IMM8M1U4:
    case IA64_OPND_IMM8M1U8:
    case IA64_OPND_IMM9a:
    case IA64_OPND_IMM9b:
      bits = operand_width (idesc->operands[res_index]);
      if (relocatable && (e->X_op == O_symbol
			  || e->X_op == O_subtract
			  || e->X_op == O_pseudo_fixup))
	{
	  fix = CURR_SLOT.fixup + CURR_SLOT.num_fixups;

	  if (idesc->operands[res_index] == IA64_OPND_IMM14)
	    fix->code = BFD_RELOC_IA64_IMM14;
	  else
	    fix->code = BFD_RELOC_IA64_IMM22;

	  if (e->X_op != O_subtract)
	    {
	      fix->code = ia64_gen_real_reloc_type (e->X_op_symbol, fix->code);
	      if (e->X_op == O_pseudo_fixup)
		e->X_op = O_symbol;
	    }

	  fix->opnd = idesc->operands[res_index];
	  fix->expr = *e;
	  fix->is_pcrel = 0;
	  ++CURR_SLOT.num_fixups;
	  return OPERAND_MATCH;
	}
      else if (e->X_op != O_constant
	       && ! (e->X_op == O_big && opnd == IA64_OPND_IMM8M1U8))
	return OPERAND_MISMATCH;

      if (opnd == IA64_OPND_IMM8M1U4)
	{
	  /* Zero is not valid for unsigned compares that take an adjusted
	     constant immediate range.  */
	  if (e->X_add_number == 0)
	    return OPERAND_OUT_OF_RANGE;

	  /* Sign-extend 32-bit unsigned numbers, so that the following range
	     checks will work.  */
	  val = e->X_add_number;
	  if (((val & (~(bfd_vma) 0 << 32)) == 0)
	      && ((val & ((bfd_vma) 1 << 31)) != 0))
	    val = ((val << 32) >> 32);

	  /* Check for 0x100000000.  This is valid because
	     0x100000000-1 is the same as ((uint32_t) -1).  */
	  if (val == ((bfd_signed_vma) 1 << 32))
	    return OPERAND_MATCH;

	  val = val - 1;
	}
      else if (opnd == IA64_OPND_IMM8M1U8)
	{
	  /* Zero is not valid for unsigned compares that take an adjusted
	     constant immediate range.  */
	  if (e->X_add_number == 0)
	    return OPERAND_OUT_OF_RANGE;

	  /* Check for 0x10000000000000000.  */
	  if (e->X_op == O_big)
	    {
	      if (generic_bignum[0] == 0
		  && generic_bignum[1] == 0
		  && generic_bignum[2] == 0
		  && generic_bignum[3] == 0
		  && generic_bignum[4] == 1)
		return OPERAND_MATCH;
	      else
		return OPERAND_OUT_OF_RANGE;
	    }
	  else
	    val = e->X_add_number - 1;
	}
      else if (opnd == IA64_OPND_IMM8M1)
	val = e->X_add_number - 1;
      else if (opnd == IA64_OPND_IMM8U4)
	{
	  /* Sign-extend 32-bit unsigned numbers, so that the following range
	     checks will work.  */
	  val = e->X_add_number;
	  if (((val & (~(bfd_vma) 0 << 32)) == 0)
	      && ((val & ((bfd_vma) 1 << 31)) != 0))
	    val = ((val << 32) >> 32);
	}
      else
	val = e->X_add_number;

      if ((val >= 0 && (bfd_vma) val < ((bfd_vma) 1 << (bits - 1)))
	  || (val < 0 && (bfd_vma) -val <= ((bfd_vma) 1 << (bits - 1))))
	return OPERAND_MATCH;
      else
	return OPERAND_OUT_OF_RANGE;

    case IA64_OPND_INC3:
      /* +/- 1, 4, 8, 16 */
      val = e->X_add_number;
      if (val < 0)
	val = -val;
      if (e->X_op == O_constant)
	{
	  if ((val == 1 || val == 4 || val == 8 || val == 16))
	    return OPERAND_MATCH;
	  else
	    return OPERAND_OUT_OF_RANGE;
	}
      break;

    case IA64_OPND_TGT25:
    case IA64_OPND_TGT25b:
    case IA64_OPND_TGT25c:
    case IA64_OPND_TGT64:
      if (e->X_op == O_symbol)
	{
	  fix = CURR_SLOT.fixup + CURR_SLOT.num_fixups;
	  if (opnd == IA64_OPND_TGT25)
	    fix->code = BFD_RELOC_IA64_PCREL21F;
	  else if (opnd == IA64_OPND_TGT25b)
	    fix->code = BFD_RELOC_IA64_PCREL21M;
	  else if (opnd == IA64_OPND_TGT25c)
	    fix->code = BFD_RELOC_IA64_PCREL21B;
	  else if (opnd == IA64_OPND_TGT64)
	    fix->code = BFD_RELOC_IA64_PCREL60B;
	  else
	    abort ();

	  fix->code = ia64_gen_real_reloc_type (e->X_op_symbol, fix->code);
	  fix->opnd = idesc->operands[res_index];
	  fix->expr = *e;
	  fix->is_pcrel = 1;
	  ++CURR_SLOT.num_fixups;
	  return OPERAND_MATCH;
	}
    case IA64_OPND_TAG13:
    case IA64_OPND_TAG13b:
      switch (e->X_op)
	{
	case O_constant:
	  return OPERAND_MATCH;

	case O_symbol:
	  fix = CURR_SLOT.fixup + CURR_SLOT.num_fixups;
	  /* There are no external relocs for TAG13/TAG13b fields, so we
	     create a dummy reloc.  This will not live past md_apply_fix.  */
	  fix->code = BFD_RELOC_UNUSED;
	  fix->code = ia64_gen_real_reloc_type (e->X_op_symbol, fix->code);
	  fix->opnd = idesc->operands[res_index];
	  fix->expr = *e;
	  fix->is_pcrel = 1;
	  ++CURR_SLOT.num_fixups;
	  return OPERAND_MATCH;

	default:
	  break;
	}
      break;

    case IA64_OPND_LDXMOV:
      fix = CURR_SLOT.fixup + CURR_SLOT.num_fixups;
      fix->code = BFD_RELOC_IA64_LDXMOV;
      fix->opnd = idesc->operands[res_index];
      fix->expr = *e;
      fix->is_pcrel = 0;
      ++CURR_SLOT.num_fixups;
      return OPERAND_MATCH;

    case IA64_OPND_STRD5b:
      if (e->X_op == O_constant)
	{
	  /* 5-bit signed scaled by 64 */
	  if ((e->X_add_number <=  	( 0xf  << 6 )) 
	       && (e->X_add_number >=  -( 0x10 << 6 )))
	    {
	      
	      /* Must be a multiple of 64 */
	      if ((e->X_add_number & 0x3f) != 0)
	        as_warn (_("stride must be a multiple of 64; lower 6 bits ignored"));

	      e->X_add_number &= ~ 0x3f;
	      return OPERAND_MATCH;
	    }
	  else
	    return OPERAND_OUT_OF_RANGE;
	}
      break;
    case IA64_OPND_CNT6a:
      if (e->X_op == O_constant)
	{
	  /* 6-bit unsigned biased by 1 -- count 0 is meaningless */
	  if ((e->X_add_number     <=   64) 
	       && (e->X_add_number > 0) )
	    {
	      return OPERAND_MATCH;
	    }
	  else
	    return OPERAND_OUT_OF_RANGE;
	}
      break;

    default:
      break;
    }
  return OPERAND_MISMATCH;
}

static int
parse_operand (expressionS *e, int more)
{
  int sep = '\0';

  memset (e, 0, sizeof (*e));
  e->X_op = O_absent;
  SKIP_WHITESPACE ();
  expression (e);
  sep = *input_line_pointer;
  if (more && (sep == ',' || sep == more))
    ++input_line_pointer;
  return sep;
}

static int
parse_operand_and_eval (expressionS *e, int more)
{
  int sep = parse_operand (e, more);
  resolve_expression (e);
  return sep;
}

static int
parse_operand_maybe_eval (expressionS *e, int more, enum ia64_opnd op)
{
  int sep = parse_operand (e, more);
  switch (op)
    {
    case IA64_OPND_IMM14:
    case IA64_OPND_IMM22:
    case IA64_OPND_IMMU64:
    case IA64_OPND_TGT25:
    case IA64_OPND_TGT25b:
    case IA64_OPND_TGT25c:
    case IA64_OPND_TGT64:
    case IA64_OPND_TAG13:
    case IA64_OPND_TAG13b:
    case IA64_OPND_LDXMOV:
      break;
    default:
      resolve_expression (e);
      break;
    }
  return sep;
}

/* Returns the next entry in the opcode table that matches the one in
   IDESC, and frees the entry in IDESC.  If no matching entry is
   found, NULL is returned instead.  */

static struct ia64_opcode *
get_next_opcode (struct ia64_opcode *idesc)
{
  struct ia64_opcode *next = ia64_find_next_opcode (idesc);
  ia64_free_opcode (idesc);
  return next;
}

/* Parse the operands for the opcode and find the opcode variant that
   matches the specified operands, or NULL if no match is possible.  */

static struct ia64_opcode *
parse_operands (struct ia64_opcode *idesc)
{
  int i = 0, highest_unmatched_operand, num_operands = 0, num_outputs = 0;
  int error_pos, out_of_range_pos, curr_out_of_range_pos, sep = 0;
  int reg1, reg2;
  char reg_class;
  enum ia64_opnd expected_operand = IA64_OPND_NIL;
  enum operand_match_result result;
  char mnemonic[129];
  char *first_arg = 0, *end, *saved_input_pointer;
  unsigned int sof;

  gas_assert (strlen (idesc->name) <= 128);

  strcpy (mnemonic, idesc->name);
  if (idesc->operands[2] == IA64_OPND_SOF
      || idesc->operands[1] == IA64_OPND_SOF)
    {
      /* To make the common idiom "alloc loc?=ar.pfs,0,1,0,0" work, we
	 can't parse the first operand until we have parsed the
	 remaining operands of the "alloc" instruction.  */
      SKIP_WHITESPACE ();
      first_arg = input_line_pointer;
      end = strchr (input_line_pointer, '=');
      if (!end)
	{
	  as_bad (_("Expected separator `='"));
	  return 0;
	}
      input_line_pointer = end + 1;
      ++i;
      ++num_outputs;
    }

  for (; ; ++i)
    {
      if (i < NELEMS (CURR_SLOT.opnd)) 
	{
	  sep = parse_operand_maybe_eval (CURR_SLOT.opnd + i, '=',
					  idesc->operands[i]);
	  if (CURR_SLOT.opnd[i].X_op == O_absent)
	    break;
	}
      else
	{
	  expressionS dummy;

	  sep = parse_operand (&dummy, '=');
	  if (dummy.X_op == O_absent)
	    break;
	}

      ++num_operands;

      if (sep != '=' && sep != ',')
	break;

      if (sep == '=')
	{
	  if (num_outputs > 0)
	    as_bad (_("Duplicate equal sign (=) in instruction"));
	  else
	    num_outputs = i + 1;
	}
    }
  if (sep != '\0')
    {
      as_bad (_("Illegal operand separator `%c'"), sep);
      return 0;
    }

  if (idesc->operands[2] == IA64_OPND_SOF
      || idesc->operands[1] == IA64_OPND_SOF)
    {
      /* Map alloc r1=ar.pfs,i,l,o,r to alloc r1=ar.pfs,(i+l+o),(i+l),r.
	 Note, however, that due to that mapping operand numbers in error
	 messages for any of the constant operands will not be correct.  */
      know (strcmp (idesc->name, "alloc") == 0);
      /* The first operand hasn't been parsed/initialized, yet (but
	 num_operands intentionally doesn't account for that).  */
      i = num_operands > 4 ? 2 : 1;
#define FORCE_CONST(n) (CURR_SLOT.opnd[n].X_op == O_constant \
			? CURR_SLOT.opnd[n].X_add_number \
			: 0)
      sof = set_regstack (FORCE_CONST(i),
			  FORCE_CONST(i + 1),
			  FORCE_CONST(i + 2),
			  FORCE_CONST(i + 3));
#undef FORCE_CONST

      /* now we can parse the first arg:  */
      saved_input_pointer = input_line_pointer;
      input_line_pointer = first_arg;
      sep = parse_operand_maybe_eval (CURR_SLOT.opnd + 0, '=',
				      idesc->operands[0]);
      if (sep != '=')
	--num_outputs;	/* force error */
      input_line_pointer = saved_input_pointer;

      CURR_SLOT.opnd[i].X_add_number = sof;
      if (CURR_SLOT.opnd[i + 1].X_op == O_constant
	  && CURR_SLOT.opnd[i + 2].X_op == O_constant)
	CURR_SLOT.opnd[i + 1].X_add_number
	  = sof - CURR_SLOT.opnd[i + 2].X_add_number;
      else
	CURR_SLOT.opnd[i + 1].X_op = O_illegal;
      CURR_SLOT.opnd[i + 2] = CURR_SLOT.opnd[i + 3];
    }

  highest_unmatched_operand = -4;
  curr_out_of_range_pos = -1;
  error_pos = 0;
  for (; idesc; idesc = get_next_opcode (idesc))
    {
      if (num_outputs != idesc->num_outputs)
	continue;		/* mismatch in # of outputs */
      if (highest_unmatched_operand < 0)
	highest_unmatched_operand |= 1;
      if (num_operands > NELEMS (idesc->operands)
	  || (num_operands < NELEMS (idesc->operands)
	   && idesc->operands[num_operands])
	  || (num_operands > 0 && !idesc->operands[num_operands - 1]))
	continue;		/* mismatch in number of arguments */
      if (highest_unmatched_operand < 0)
	highest_unmatched_operand |= 2;

      CURR_SLOT.num_fixups = 0;

      /* Try to match all operands.  If we see an out-of-range operand,
	 then continue trying to match the rest of the operands, since if
	 the rest match, then this idesc will give the best error message.  */

      out_of_range_pos = -1;
      for (i = 0; i < num_operands && idesc->operands[i]; ++i)
	{
	  result = operand_match (idesc, i, CURR_SLOT.opnd + i);
	  if (result != OPERAND_MATCH)
	    {
	      if (result != OPERAND_OUT_OF_RANGE)
		break;
	      if (out_of_range_pos < 0)
		/* remember position of the first out-of-range operand: */
		out_of_range_pos = i;
	    }
	}

      /* If we did not match all operands, or if at least one operand was
	 out-of-range, then this idesc does not match.  Keep track of which
	 idesc matched the most operands before failing.  If we have two
	 idescs that failed at the same position, and one had an out-of-range
	 operand, then prefer the out-of-range operand.  Thus if we have
	 "add r0=0x1000000,r1" we get an error saying the constant is out
	 of range instead of an error saying that the constant should have been
	 a register.  */

      if (i != num_operands || out_of_range_pos >= 0)
	{
	  if (i > highest_unmatched_operand
	      || (i == highest_unmatched_operand
		  && out_of_range_pos > curr_out_of_range_pos))
	    {
	      highest_unmatched_operand = i;
	      if (out_of_range_pos >= 0)
		{
		  expected_operand = idesc->operands[out_of_range_pos];
		  error_pos = out_of_range_pos;
		}
	      else
		{
		  expected_operand = idesc->operands[i];
		  error_pos = i;
		}
	      curr_out_of_range_pos = out_of_range_pos;
	    }
	  continue;
	}

      break;
    }
  if (!idesc)
    {
      if (expected_operand)
	as_bad (_("Operand %u of `%s' should be %s"),
		error_pos + 1, mnemonic,
		elf64_ia64_operands[expected_operand].desc);
      else if (highest_unmatched_operand < 0 && !(highest_unmatched_operand & 1))
	as_bad (_("Wrong number of output operands"));
      else if (highest_unmatched_operand < 0 && !(highest_unmatched_operand & 2))
	as_bad (_("Wrong number of input operands"));
      else
	as_bad (_("Operand mismatch"));
      return 0;
    }

  /* Check that the instruction doesn't use
     - r0, f0, or f1 as output operands
     - the same predicate twice as output operands
     - r0 as address of a base update load or store
     - the same GR as output and address of a base update load
     - two even- or two odd-numbered FRs as output operands of a floating
       point parallel load.
     At most two (conflicting) output (or output-like) operands can exist,
     (floating point parallel loads have three outputs, but the base register,
     if updated, cannot conflict with the actual outputs).  */
  reg2 = reg1 = -1;
  for (i = 0; i < num_operands; ++i)
    {
      int regno = 0;

      reg_class = 0;
      switch (idesc->operands[i])
	{
	case IA64_OPND_R1:
	case IA64_OPND_R2:
	case IA64_OPND_R3:
	  if (i < num_outputs)
	    {
	      if (CURR_SLOT.opnd[i].X_add_number == REG_GR)
		reg_class = 'r';
	      else if (reg1 < 0)
		reg1 = CURR_SLOT.opnd[i].X_add_number;
	      else if (reg2 < 0)
		reg2 = CURR_SLOT.opnd[i].X_add_number;
	    }
	  break;
	case IA64_OPND_P1:
	case IA64_OPND_P2:
	  if (i < num_outputs)
	    {
	      if (reg1 < 0)
		reg1 = CURR_SLOT.opnd[i].X_add_number;
	      else if (reg2 < 0)
		reg2 = CURR_SLOT.opnd[i].X_add_number;
	    }
	  break;
	case IA64_OPND_F1:
	case IA64_OPND_F2:
	case IA64_OPND_F3:
	case IA64_OPND_F4:
	  if (i < num_outputs)
	    {
	      if (CURR_SLOT.opnd[i].X_add_number >= REG_FR
		  && CURR_SLOT.opnd[i].X_add_number <= REG_FR + 1)
		{
		  reg_class = 'f';
		  regno = CURR_SLOT.opnd[i].X_add_number - REG_FR;
		}
	      else if (reg1 < 0)
		reg1 = CURR_SLOT.opnd[i].X_add_number;
	      else if (reg2 < 0)
		reg2 = CURR_SLOT.opnd[i].X_add_number;
	    }
	  break;
	case IA64_OPND_MR3:
	  if (idesc->flags & IA64_OPCODE_POSTINC)
	    {
	      if (CURR_SLOT.opnd[i].X_add_number == REG_GR)
		reg_class = 'm';
	      else if (reg1 < 0)
		reg1 = CURR_SLOT.opnd[i].X_add_number;
	      else if (reg2 < 0)
		reg2 = CURR_SLOT.opnd[i].X_add_number;
	    }
	  break;
	default:
	  break;
	}
      switch (reg_class)
	{
	case 0:
	  break;
	default:
	  as_warn (_("Invalid use of `%c%d' as output operand"), reg_class, regno);
	  break;
	case 'm':
	  as_warn (_("Invalid use of `r%d' as base update address operand"), regno);
	  break;
	}
    }
  if (reg1 == reg2)
    {
      if (reg1 >= REG_GR && reg1 <= REG_GR + 127)
	{
	  reg1 -= REG_GR;
	  reg_class = 'r';
	}
      else if (reg1 >= REG_P && reg1 <= REG_P + 63)
	{
	  reg1 -= REG_P;
	  reg_class = 'p';
	}
      else if (reg1 >= REG_FR && reg1 <= REG_FR + 127)
	{
	  reg1 -= REG_FR;
	  reg_class = 'f';
	}
      else
	reg_class = 0;
      if (reg_class)
	as_warn (_("Invalid duplicate use of `%c%d'"), reg_class, reg1);
    }
  else if (((reg1 >= REG_FR && reg1 <= REG_FR + 31
	     && reg2 >= REG_FR && reg2 <= REG_FR + 31)
	    || (reg1 >= REG_FR + 32 && reg1 <= REG_FR + 127
	     && reg2 >= REG_FR + 32 && reg2 <= REG_FR + 127))
	   && ! ((reg1 ^ reg2) & 1))
    as_warn (_("Invalid simultaneous use of `f%d' and `f%d'"),
	     reg1 - REG_FR, reg2 - REG_FR);
  else if ((reg1 >= REG_FR && reg1 <= REG_FR + 31
	    && reg2 >= REG_FR + 32 && reg2 <= REG_FR + 127)
	   || (reg1 >= REG_FR + 32 && reg1 <= REG_FR + 127
	    && reg2 >= REG_FR && reg2 <= REG_FR + 31))
    as_warn (_("Dangerous simultaneous use of `f%d' and `f%d'"),
	     reg1 - REG_FR, reg2 - REG_FR);
  return idesc;
}

static void
build_insn (struct slot *slot, bfd_vma *insnp)
{
  const struct ia64_operand *odesc, *o2desc;
  struct ia64_opcode *idesc = slot->idesc;
  bfd_vma insn;
  bfd_signed_vma val;
  const char *err;
  int i;

  insn = idesc->opcode | slot->qp_regno;

  for (i = 0; i < NELEMS (idesc->operands) && idesc->operands[i]; ++i)
    {
      if (slot->opnd[i].X_op == O_register
	  || slot->opnd[i].X_op == O_constant
	  || slot->opnd[i].X_op == O_index)
	val = slot->opnd[i].X_add_number;
      else if (slot->opnd[i].X_op == O_big)
	{
	  /* This must be the value 0x10000000000000000.  */
	  gas_assert (idesc->operands[i] == IA64_OPND_IMM8M1U8);
	  val = 0;
	}
      else
	val = 0;

      switch (idesc->operands[i])
	{
	case IA64_OPND_IMMU64:
	  *insnp++ = (val >> 22) & 0x1ffffffffffLL;
	  insn |= (((val & 0x7f) << 13) | (((val >> 7) & 0x1ff) << 27)
		   | (((val >> 16) & 0x1f) << 22) | (((val >> 21) & 0x1) << 21)
		   | (((val >> 63) & 0x1) << 36));
	  continue;

	case IA64_OPND_IMMU62:
	  val &= 0x3fffffffffffffffULL;
	  if (val != slot->opnd[i].X_add_number)
	    as_warn (_("Value truncated to 62 bits"));
	  *insnp++ = (val >> 21) & 0x1ffffffffffLL;
	  insn |= (((val & 0xfffff) << 6) | (((val >> 20) & 0x1) << 36));
	  continue;

	case IA64_OPND_TGT64:
	  val >>= 4;
	  *insnp++ = ((val >> 20) & 0x7fffffffffLL) << 2;
	  insn |= ((((val >> 59) & 0x1) << 36)
		   | (((val >> 0) & 0xfffff) << 13));
	  continue;

	case IA64_OPND_AR3:
	  val -= REG_AR;
	  break;

	case IA64_OPND_B1:
	case IA64_OPND_B2:
	  val -= REG_BR;
	  break;

	case IA64_OPND_CR3:
	  val -= REG_CR;
	  break;

	case IA64_OPND_DAHR3:
	  val -= REG_DAHR;
	  break;

	case IA64_OPND_F1:
	case IA64_OPND_F2:
	case IA64_OPND_F3:
	case IA64_OPND_F4:
	  val -= REG_FR;
	  break;

	case IA64_OPND_P1:
	case IA64_OPND_P2:
	  val -= REG_P;
	  break;

	case IA64_OPND_R1:
	case IA64_OPND_R2:
	case IA64_OPND_R3:
	case IA64_OPND_R3_2:
	case IA64_OPND_CPUID_R3:
	case IA64_OPND_DBR_R3:
	case IA64_OPND_DTR_R3:
	case IA64_OPND_ITR_R3:
	case IA64_OPND_IBR_R3:
	case IA64_OPND_MR3:
	case IA64_OPND_MSR_R3:
	case IA64_OPND_PKR_R3:
	case IA64_OPND_PMC_R3:
	case IA64_OPND_PMD_R3:
	case IA64_OPND_DAHR_R3:
	case IA64_OPND_RR_R3:
	  val -= REG_GR;
	  break;

	default:
	  break;
	}

      odesc = elf64_ia64_operands + idesc->operands[i];
      err = (*odesc->insert) (odesc, val, &insn);
      if (err)
	as_bad_where (slot->src_file, slot->src_line,
		      _("Bad operand value: %s"), err);
      if (idesc->flags & IA64_OPCODE_PSEUDO)
	{
	  if ((idesc->flags & IA64_OPCODE_F2_EQ_F3)
	      && odesc == elf64_ia64_operands + IA64_OPND_F3)
	    {
	      o2desc = elf64_ia64_operands + IA64_OPND_F2;
	      (*o2desc->insert) (o2desc, val, &insn);
	    }
	  if ((idesc->flags & IA64_OPCODE_LEN_EQ_64MCNT)
	      && (odesc == elf64_ia64_operands + IA64_OPND_CPOS6a
		  || odesc == elf64_ia64_operands + IA64_OPND_POS6))
	    {
	      o2desc = elf64_ia64_operands + IA64_OPND_LEN6;
	      (*o2desc->insert) (o2desc, 64 - val, &insn);
	    }
	}
    }
  *insnp = insn;
}

static void
emit_one_bundle (void)
{
  int manual_bundling_off = 0, manual_bundling = 0;
  enum ia64_unit required_unit, insn_unit = 0;
  enum ia64_insn_type type[3], insn_type;
  unsigned int template_val, orig_template;
  bfd_vma insn[3] = { -1, -1, -1 };
  struct ia64_opcode *idesc;
  int end_of_insn_group = 0, user_template = -1;
  int n, i, j, first, curr, last_slot;
  bfd_vma t0 = 0, t1 = 0;
  struct label_fix *lfix;
  bfd_boolean mark_label;
  struct insn_fix *ifix;
  char mnemonic[16];
  fixS *fix;
  char *f;
  int addr_mod;

  first = (md.curr_slot + NUM_SLOTS - md.num_slots_in_use) % NUM_SLOTS;
  know (first >= 0 && first < NUM_SLOTS);
  n = MIN (3, md.num_slots_in_use);

  /* Determine template: user user_template if specified, best match
     otherwise:  */

  if (md.slot[first].user_template >= 0)
    user_template = template_val = md.slot[first].user_template;
  else
    {
      /* Auto select appropriate template.  */
      memset (type, 0, sizeof (type));
      curr = first;
      for (i = 0; i < n; ++i)
	{
	  if (md.slot[curr].label_fixups && i != 0)
	    break;
	  type[i] = md.slot[curr].idesc->type;
	  curr = (curr + 1) % NUM_SLOTS;
	}
      template_val = best_template[type[0]][type[1]][type[2]];
    }

  /* initialize instructions with appropriate nops:  */
  for (i = 0; i < 3; ++i)
    insn[i] = nop[ia64_templ_desc[template_val].exec_unit[i]];

  f = frag_more (16);

  /* Check to see if this bundle is at an offset that is a multiple of 16-bytes
     from the start of the frag.  */
  addr_mod = frag_now_fix () & 15;
  if (frag_now->has_code && frag_now->insn_addr != addr_mod)
    as_bad (_("instruction address is not a multiple of 16"));
  frag_now->insn_addr = addr_mod;
  frag_now->has_code = 1;

  /* now fill in slots with as many insns as possible:  */
  curr = first;
  idesc = md.slot[curr].idesc;
  end_of_insn_group = 0;
  last_slot = -1;
  for (i = 0; i < 3 && md.num_slots_in_use > 0; ++i)
    {
      /* If we have unwind records, we may need to update some now.  */
      unw_rec_list *ptr = md.slot[curr].unwind_record;
      unw_rec_list *end_ptr = NULL;

      if (ptr)
	{
	  /* Find the last prologue/body record in the list for the current
	     insn, and set the slot number for all records up to that point.
	     This needs to be done now, because prologue/body records refer to
	     the current point, not the point after the instruction has been
	     issued.  This matters because there may have been nops emitted
	     meanwhile.  Any non-prologue non-body record followed by a
	     prologue/body record must also refer to the current point.  */
	  unw_rec_list *last_ptr;

	  for (j = 1; end_ptr == NULL && j < md.num_slots_in_use; ++j)
	    end_ptr = md.slot[(curr + j) % NUM_SLOTS].unwind_record;
	  for (last_ptr = NULL; ptr != end_ptr; ptr = ptr->next)
	    if (ptr->r.type == prologue || ptr->r.type == prologue_gr
		|| ptr->r.type == body)
	      last_ptr = ptr;
	  if (last_ptr)
	    {
	      /* Make last_ptr point one after the last prologue/body
		 record.  */
	      last_ptr = last_ptr->next;
	      for (ptr = md.slot[curr].unwind_record; ptr != last_ptr;
		   ptr = ptr->next)
		{
		  ptr->slot_number = (unsigned long) f + i;
		  ptr->slot_frag = frag_now;
		}
	      /* Remove the initialized records, so that we won't accidentally
		 update them again if we insert a nop and continue.  */
	      md.slot[curr].unwind_record = last_ptr;
	    }
	}

      manual_bundling_off = md.slot[curr].manual_bundling_off;
      if (md.slot[curr].manual_bundling_on)
	{
	  if (curr == first)
	    manual_bundling = 1;
	  else
	  break; /* Need to start a new bundle.  */
	}

      /* If this instruction specifies a template, then it must be the first
	 instruction of a bundle.  */
      if (curr != first && md.slot[curr].user_template >= 0)
	break;

      if (idesc->flags & IA64_OPCODE_SLOT2)
	{
	  if (manual_bundling && !manual_bundling_off)
	    {
	      as_bad_where (md.slot[curr].src_file, md.slot[curr].src_line,
			    _("`%s' must be last in bundle"), idesc->name);
	      if (i < 2)
		manual_bundling = -1; /* Suppress meaningless post-loop errors.  */
	    }
	  i = 2;
	}
      if (idesc->flags & IA64_OPCODE_LAST)
	{
	  int required_slot;
	  unsigned int required_template;

	  /* If we need a stop bit after an M slot, our only choice is
	     template 5 (M;;MI).  If we need a stop bit after a B
	     slot, our only choice is to place it at the end of the
	     bundle, because the only available templates are MIB,
	     MBB, BBB, MMB, and MFB.  We don't handle anything other
	     than M and B slots because these are the only kind of
	     instructions that can have the IA64_OPCODE_LAST bit set.  */
	  required_template = template_val;
	  switch (idesc->type)
	    {
	    case IA64_TYPE_M:
	      required_slot = 0;
	      required_template = 5;
	      break;

	    case IA64_TYPE_B:
	      required_slot = 2;
	      break;

	    default:
	      as_bad_where (md.slot[curr].src_file, md.slot[curr].src_line,
			    _("Internal error: don't know how to force %s to end of instruction group"),
			    idesc->name);
	      required_slot = i;
	      break;
	    }
	  if (manual_bundling
	      && (i > required_slot
		  || (required_slot == 2 && !manual_bundling_off)
		  || (user_template >= 0
		      /* Changing from MMI to M;MI is OK.  */
		      && (template_val ^ required_template) > 1)))
	    {
	      as_bad_where (md.slot[curr].src_file, md.slot[curr].src_line,
			    _("`%s' must be last in instruction group"),
			    idesc->name);
	      if (i < 2 && required_slot == 2 && !manual_bundling_off)
		manual_bundling = -1; /* Suppress meaningless post-loop errors.  */
	    }
	  if (required_slot < i)
	    /* Can't fit this instruction.  */
	    break;

	  i = required_slot;
	  if (required_template != template_val)
	    {
	      /* If we switch the template, we need to reset the NOPs
	         after slot i.  The slot-types of the instructions ahead
	         of i never change, so we don't need to worry about
	         changing NOPs in front of this slot.  */
	      for (j = i; j < 3; ++j)
	        insn[j] = nop[ia64_templ_desc[required_template].exec_unit[j]];

	      /* We just picked a template that includes the stop bit in the
		 middle, so we don't need another one emitted later.  */
	      md.slot[curr].end_of_insn_group = 0;
	    }
	  template_val = required_template;
	}
      if (curr != first && md.slot[curr].label_fixups)
	{
	  if (manual_bundling)
	    {
	      as_bad_where (md.slot[curr].src_file, md.slot[curr].src_line,
			    _("Label must be first in a bundle"));
	      manual_bundling = -1; /* Suppress meaningless post-loop errors.  */
	    }
	  /* This insn must go into the first slot of a bundle.  */
	  break;
	}

      if (end_of_insn_group && md.num_slots_in_use >= 1)
	{
	  /* We need an instruction group boundary in the middle of a
	     bundle.  See if we can switch to an other template with
	     an appropriate boundary.  */

	  orig_template = template_val;
	  if (i == 1 && (user_template == 4
			 || (user_template < 0
			     && (ia64_templ_desc[template_val].exec_unit[0]
				 == IA64_UNIT_M))))
	    {
	      template_val = 5;
	      end_of_insn_group = 0;
	    }
	  else if (i == 2 && (user_template == 0
			      || (user_template < 0
				  && (ia64_templ_desc[template_val].exec_unit[1]
				      == IA64_UNIT_I)))
		   /* This test makes sure we don't switch the template if
		      the next instruction is one that needs to be first in
		      an instruction group.  Since all those instructions are
		      in the M group, there is no way such an instruction can
		      fit in this bundle even if we switch the template.  The
		      reason we have to check for this is that otherwise we
		      may end up generating "MI;;I M.." which has the deadly
		      effect that the second M instruction is no longer the
		      first in the group! --davidm 99/12/16  */
		   && (idesc->flags & IA64_OPCODE_FIRST) == 0)
	    {
	      template_val = 1;
	      end_of_insn_group = 0;
	    }
	  else if (i == 1
		   && user_template == 0
		   && !(idesc->flags & IA64_OPCODE_FIRST))
	    /* Use the next slot.  */
	    continue;
	  else if (curr != first)
	    /* can't fit this insn */
	    break;

	  if (template_val != orig_template)
	    /* if we switch the template, we need to reset the NOPs
	       after slot i.  The slot-types of the instructions ahead
	       of i never change, so we don't need to worry about
	       changing NOPs in front of this slot.  */
	    for (j = i; j < 3; ++j)
	      insn[j] = nop[ia64_templ_desc[template_val].exec_unit[j]];
	}
      required_unit = ia64_templ_desc[template_val].exec_unit[i];

      /* resolve dynamic opcodes such as "break", "hint", and "nop":  */
      if (idesc->type == IA64_TYPE_DYN)
	{
	  enum ia64_opnd opnd1, opnd2;

	  if ((strcmp (idesc->name, "nop") == 0)
	      || (strcmp (idesc->name, "break") == 0))
	    insn_unit = required_unit;
	  else if (strcmp (idesc->name, "hint") == 0)
	    {
	      insn_unit = required_unit;
	      if (required_unit == IA64_UNIT_B)
		{
		  switch (md.hint_b)
		    {
		    case hint_b_ok:
		      break;
		    case hint_b_warning:
		      as_warn (_("hint in B unit may be treated as nop"));
		      break;
		    case hint_b_error:
		      /* When manual bundling is off and there is no
			 user template, we choose a different unit so
			 that hint won't go into the current slot. We
			 will fill the current bundle with nops and
			 try to put hint into the next bundle.  */
		      if (!manual_bundling && user_template < 0)
			insn_unit = IA64_UNIT_I;
		      else
			as_bad (_("hint in B unit can't be used"));
		      break;
		    }
		}
	    }
	  else if (strcmp (idesc->name, "chk.s") == 0
	      || strcmp (idesc->name, "mov") == 0)
	    {
	      insn_unit = IA64_UNIT_M;
	      if (required_unit == IA64_UNIT_I
		  || (required_unit == IA64_UNIT_F && template_val == 6))
		insn_unit = IA64_UNIT_I;
	    }
	  else
	    as_fatal (_("emit_one_bundle: unexpected dynamic op"));

	  snprintf (mnemonic, sizeof (mnemonic), "%s.%c",
		    idesc->name, "?imbfxx"[insn_unit]);
	  opnd1 = idesc->operands[0];
	  opnd2 = idesc->operands[1];
	  ia64_free_opcode (idesc);
	  idesc = ia64_find_opcode (mnemonic);
	  /* moves to/from ARs have collisions */
	  if (opnd1 == IA64_OPND_AR3 || opnd2 == IA64_OPND_AR3)
	    {
	      while (idesc != NULL
		     && (idesc->operands[0] != opnd1
			 || idesc->operands[1] != opnd2))
		idesc = get_next_opcode (idesc);
	    }
	  md.slot[curr].idesc = idesc;
	}
      else
	{
	  insn_type = idesc->type;
	  insn_unit = IA64_UNIT_NIL;
	  switch (insn_type)
	    {
	    case IA64_TYPE_A:
	      if (required_unit == IA64_UNIT_I || required_unit == IA64_UNIT_M)
		insn_unit = required_unit;
	      break;
	    case IA64_TYPE_X: insn_unit = IA64_UNIT_L; break;
	    case IA64_TYPE_I: insn_unit = IA64_UNIT_I; break;
	    case IA64_TYPE_M: insn_unit = IA64_UNIT_M; break;
	    case IA64_TYPE_B: insn_unit = IA64_UNIT_B; break;
	    case IA64_TYPE_F: insn_unit = IA64_UNIT_F; break;
	    default:				       break;
	    }
	}

      if (insn_unit != required_unit)
	continue;		/* Try next slot.  */

      /* Now is a good time to fix up the labels for this insn.  */
      mark_label = FALSE;
      for (lfix = md.slot[curr].label_fixups; lfix; lfix = lfix->next)
	{
	  S_SET_VALUE (lfix->sym, frag_now_fix () - 16);
	  symbol_set_frag (lfix->sym, frag_now);
	  mark_label |= lfix->dw2_mark_labels;
	}
      for (lfix = md.slot[curr].tag_fixups; lfix; lfix = lfix->next)
	{
	  S_SET_VALUE (lfix->sym, frag_now_fix () - 16 + i);
	  symbol_set_frag (lfix->sym, frag_now);
	}

      if (debug_type == DEBUG_DWARF2
	  || md.slot[curr].loc_directive_seen
	  || mark_label)
	{
	  bfd_vma addr = frag_now->fr_address + frag_now_fix () - 16 + i;

	  md.slot[curr].loc_directive_seen = 0;
	  if (mark_label)
	    md.slot[curr].debug_line.flags |= DWARF2_FLAG_BASIC_BLOCK;

	  dwarf2_gen_line_info (addr, &md.slot[curr].debug_line);
	}

      build_insn (md.slot + curr, insn + i);

      ptr = md.slot[curr].unwind_record;
      if (ptr)
	{
	  /* Set slot numbers for all remaining unwind records belonging to the
	     current insn.  There can not be any prologue/body unwind records
	     here.  */
	  for (; ptr != end_ptr; ptr = ptr->next)
	    {
	      ptr->slot_number = (unsigned long) f + i;
	      ptr->slot_frag = frag_now;
	    }
	  md.slot[curr].unwind_record = NULL;
	}

      for (j = 0; j < md.slot[curr].num_fixups; ++j)
	{
	  ifix = md.slot[curr].fixup + j;
	  fix = fix_new_exp (frag_now, frag_now_fix () - 16 + i, 8,
			     &ifix->expr, ifix->is_pcrel, ifix->code);
	  fix->tc_fix_data.opnd = ifix->opnd;
	  fix->fx_file = md.slot[curr].src_file;
	  fix->fx_line = md.slot[curr].src_line;
	}

      end_of_insn_group = md.slot[curr].end_of_insn_group;

      /* This adjustment to "i" must occur after the fix, otherwise the fix
	 is assigned to the wrong slot, and the VMS linker complains.  */
      if (required_unit == IA64_UNIT_L)
	{
	  know (i == 1);
	  /* skip one slot for long/X-unit instructions */
	  ++i;
	}
      --md.num_slots_in_use;
      last_slot = i;

      /* clear slot:  */
      ia64_free_opcode (md.slot[curr].idesc);
      memset (md.slot + curr, 0, sizeof (md.slot[curr]));
      md.slot[curr].user_template = -1;

      if (manual_bundling_off)
	{
	  manual_bundling = 0;
	  break;
	}
      curr = (curr + 1) % NUM_SLOTS;
      idesc = md.slot[curr].idesc;
    }

  /* A user template was specified, but the first following instruction did
     not fit.  This can happen with or without manual bundling.  */
  if (md.num_slots_in_use > 0 && last_slot < 0)
    {
      as_bad_where (md.slot[curr].src_file, md.slot[curr].src_line,
		    _("`%s' does not fit into %s template"),
		    idesc->name, ia64_templ_desc[template_val].name);
      /* Drop first insn so we don't livelock.  */
      --md.num_slots_in_use;
      know (curr == first);
      ia64_free_opcode (md.slot[curr].idesc);
      memset (md.slot + curr, 0, sizeof (md.slot[curr]));
      md.slot[curr].user_template = -1;
    }
  else if (manual_bundling > 0)
    {
      if (md.num_slots_in_use > 0)
	{
	  if (last_slot >= 2)
	    as_bad_where (md.slot[curr].src_file, md.slot[curr].src_line,
			  _("`%s' does not fit into bundle"), idesc->name);
	  else
	    {
	      const char *where;

	      if (template_val == 2)
		where = "X slot";
	      else if (last_slot == 0)
		where = "slots 2 or 3";
	      else
		where = "slot 3";
	      as_bad_where (md.slot[curr].src_file, md.slot[curr].src_line,
			    _("`%s' can't go in %s of %s template"),
			    idesc->name, where, ia64_templ_desc[template_val].name);
	    }
	}
      else
	as_bad_where (md.slot[curr].src_file, md.slot[curr].src_line,
		      _("Missing '}' at end of file"));
    }
	
  know (md.num_slots_in_use < NUM_SLOTS);

  t0 = end_of_insn_group | (template_val << 1) | (insn[0] << 5) | (insn[1] << 46);
  t1 = ((insn[1] >> 18) & 0x7fffff) | (insn[2] << 23);

  number_to_chars_littleendian (f + 0, t0, 8);
  number_to_chars_littleendian (f + 8, t1, 8);
}

int
md_parse_option (int c, char *arg)
{

  switch (c)
    {
    /* Switches from the Intel assembler.  */
    case 'm':
      if (strcmp (arg, "ilp64") == 0
	  || strcmp (arg, "lp64") == 0
	  || strcmp (arg, "p64") == 0)
	{
	  md.flags |= EF_IA_64_ABI64;
	}
      else if (strcmp (arg, "ilp32") == 0)
	{
	  md.flags &= ~EF_IA_64_ABI64;
	}
      else if (strcmp (arg, "le") == 0)
	{
	  md.flags &= ~EF_IA_64_BE;
	  default_big_endian = 0;
	}
      else if (strcmp (arg, "be") == 0)
	{
	  md.flags |= EF_IA_64_BE;
	  default_big_endian = 1;
	}
      else if (strncmp (arg, "unwind-check=", 13) == 0)
	{
	  arg += 13;
	  if (strcmp (arg, "warning") == 0)
	    md.unwind_check = unwind_check_warning;
	  else if (strcmp (arg, "error") == 0)
	    md.unwind_check = unwind_check_error;
	  else
	    return 0;
	}
      else if (strncmp (arg, "hint.b=", 7) == 0)
	{
	  arg += 7;
	  if (strcmp (arg, "ok") == 0)
	    md.hint_b = hint_b_ok;
	  else if (strcmp (arg, "warning") == 0)
	    md.hint_b = hint_b_warning;
	  else if (strcmp (arg, "error") == 0)
	    md.hint_b = hint_b_error;
	  else
	    return 0;
	}
      else if (strncmp (arg, "tune=", 5) == 0)
	{
	  arg += 5;
	  if (strcmp (arg, "itanium1") == 0)
	    md.tune = itanium1;
	  else if (strcmp (arg, "itanium2") == 0)
	    md.tune = itanium2;
	  else
	    return 0;
	}
      else
	return 0;
      break;

    case 'N':
      if (strcmp (arg, "so") == 0)
	{
	  /* Suppress signon message.  */
	}
      else if (strcmp (arg, "pi") == 0)
	{
	  /* Reject privileged instructions.  FIXME */
	}
      else if (strcmp (arg, "us") == 0)
	{
	  /* Allow union of signed and unsigned range.  FIXME */
	}
      else if (strcmp (arg, "close_fcalls") == 0)
	{
	  /* Do not resolve global function calls.  */
	}
      else
	return 0;
      break;

    case 'C':
      /* temp[="prefix"]  Insert temporary labels into the object file
			  symbol table prefixed by "prefix".
			  Default prefix is ":temp:".
       */
      break;

    case 'a':
      /* indirect=<tgt>	Assume unannotated indirect branches behavior
			according to <tgt> --
			exit:	branch out from the current context (default)
			labels:	all labels in context may be branch targets
       */
      if (strncmp (arg, "indirect=", 9) != 0)
        return 0;
      break;

    case 'x':
      /* -X conflicts with an ignored option, use -x instead */
      md.detect_dv = 1;
      if (!arg || strcmp (arg, "explicit") == 0)
	{
	  /* set default mode to explicit */
	  md.default_explicit_mode = 1;
	  break;
	}
      else if (strcmp (arg, "auto") == 0)
	{
	  md.default_explicit_mode = 0;
	}
      else if (strcmp (arg, "none") == 0)
	{
	  md.detect_dv = 0;
	}
      else if (strcmp (arg, "debug") == 0)
	{
	  md.debug_dv = 1;
	}
      else if (strcmp (arg, "debugx") == 0)
	{
	  md.default_explicit_mode = 1;
	  md.debug_dv = 1;
	}
      else if (strcmp (arg, "debugn") == 0)
	{
	  md.debug_dv = 1;
	  md.detect_dv = 0;
	}
      else
	{
	  as_bad (_("Unrecognized option '-x%s'"), arg);
	}
      break;

    case 'S':
      /* nops		Print nops statistics.  */
      break;

    /* GNU specific switches for gcc.  */
    case OPTION_MCONSTANT_GP:
      md.flags |= EF_IA_64_CONS_GP;
      break;

    case OPTION_MAUTO_PIC:
      md.flags |= EF_IA_64_NOFUNCDESC_CONS_GP;
      break;

    default:
      return 0;
    }

  return 1;
}

void
md_show_usage (FILE *stream)
{
  fputs (_("\
IA-64 options:\n\
  --mconstant-gp	  mark output file as using the constant-GP model\n\
			  (sets ELF header flag EF_IA_64_CONS_GP)\n\
  --mauto-pic		  mark output file as using the constant-GP model\n\
			  without function descriptors (sets ELF header flag\n\
			  EF_IA_64_NOFUNCDESC_CONS_GP)\n\
  -milp32|-milp64|-mlp64|-mp64	select data model (default -mlp64)\n\
  -mle | -mbe		  select little- or big-endian byte order (default -mle)\n\
  -mtune=[itanium1|itanium2]\n\
			  tune for a specific CPU (default -mtune=itanium2)\n\
  -munwind-check=[warning|error]\n\
			  unwind directive check (default -munwind-check=warning)\n\
  -mhint.b=[ok|warning|error]\n\
			  hint.b check (default -mhint.b=error)\n\
  -x | -xexplicit	  turn on dependency violation checking\n"), stream);
  /* Note for translators: "automagically" can be translated as "automatically" here.  */
  fputs (_("\
  -xauto		  automagically remove dependency violations (default)\n\
  -xnone		  turn off dependency violation checking\n\
  -xdebug		  debug dependency violation checker\n\
  -xdebugn		  debug dependency violation checker but turn off\n\
			  dependency violation checking\n\
  -xdebugx		  debug dependency violation checker and turn on\n\
			  dependency violation checking\n"),
	stream);
}

void
ia64_after_parse_args (void)
{
  if (debug_type == DEBUG_STABS)
    as_fatal (_("--gstabs is not supported for ia64"));
}

/* Return true if TYPE fits in TEMPL at SLOT.  */

static int
match (int templ, int type, int slot)
{
  enum ia64_unit unit;
  int result;

  unit = ia64_templ_desc[templ].exec_unit[slot];
  switch (type)
    {
    case IA64_TYPE_DYN: result = 1; break; /* for nop and break */
    case IA64_TYPE_A:
      result = (unit == IA64_UNIT_I || unit == IA64_UNIT_M);
      break;
    case IA64_TYPE_X:	result = (unit == IA64_UNIT_L); break;
    case IA64_TYPE_I:	result = (unit == IA64_UNIT_I); break;
    case IA64_TYPE_M:	result = (unit == IA64_UNIT_M); break;
    case IA64_TYPE_B:	result = (unit == IA64_UNIT_B); break;
    case IA64_TYPE_F:	result = (unit == IA64_UNIT_F); break;
    default:		result = 0; break;
    }
  return result;
}

/* For Itanium 1, add a bit of extra goodness if a nop of type F or B would fit
   in TEMPL at SLOT.  For Itanium 2, add a bit of extra goodness if a nop of
   type M or I would fit in TEMPL at SLOT.  */

static inline int
extra_goodness (int templ, int slot)
{
  switch (md.tune)
    {
    case itanium1:
      if (slot == 1 && match (templ, IA64_TYPE_F, slot))
	return 2;
      else if (slot == 2 && match (templ, IA64_TYPE_B, slot))
	return 1;
      else
	return 0;
      break;
    case itanium2:
      if (match (templ, IA64_TYPE_M, slot)
	  || match (templ, IA64_TYPE_I, slot))
	/* Favor M- and I-unit NOPs.  We definitely want to avoid
	   F-unit and B-unit may cause split-issue or less-than-optimal
	   branch-prediction.  */
	return 2;
      else
	return 0;
      break;
    default:
      abort ();
      return 0;
    }
}

/* This function is called once, at assembler startup time.  It sets
   up all the tables, etc. that the MD part of the assembler will need
   that can be determined before arguments are parsed.  */
void
md_begin (void)
{
  int i, j, k, t, goodness, best, ok;
  const char *err;
  char name[8];

  md.auto_align = 1;
  md.explicit_mode = md.default_explicit_mode;

  bfd_set_section_alignment (stdoutput, text_section, 4);

  /* Make sure function pointers get initialized.  */
  target_big_endian = -1;
  dot_byteorder (default_big_endian);

  alias_hash = hash_new ();
  alias_name_hash = hash_new ();
  secalias_hash = hash_new ();
  secalias_name_hash = hash_new ();

  pseudo_func[FUNC_DTP_MODULE].u.sym =
    symbol_new (".<dtpmod>", undefined_section, FUNC_DTP_MODULE,
		&zero_address_frag);

  pseudo_func[FUNC_DTP_RELATIVE].u.sym =
    symbol_new (".<dtprel>", undefined_section, FUNC_DTP_RELATIVE,
		&zero_address_frag);

  pseudo_func[FUNC_FPTR_RELATIVE].u.sym =
    symbol_new (".<fptr>", undefined_section, FUNC_FPTR_RELATIVE,
		&zero_address_frag);

  pseudo_func[FUNC_GP_RELATIVE].u.sym =
    symbol_new (".<gprel>", undefined_section, FUNC_GP_RELATIVE,
		&zero_address_frag);

  pseudo_func[FUNC_LT_RELATIVE].u.sym =
    symbol_new (".<ltoff>", undefined_section, FUNC_LT_RELATIVE,
		&zero_address_frag);

  pseudo_func[FUNC_LT_RELATIVE_X].u.sym =
    symbol_new (".<ltoffx>", undefined_section, FUNC_LT_RELATIVE_X,
		&zero_address_frag);

  pseudo_func[FUNC_PC_RELATIVE].u.sym =
    symbol_new (".<pcrel>", undefined_section, FUNC_PC_RELATIVE,
		&zero_address_frag);

  pseudo_func[FUNC_PLT_RELATIVE].u.sym =
    symbol_new (".<pltoff>", undefined_section, FUNC_PLT_RELATIVE,
		&zero_address_frag);

  pseudo_func[FUNC_SEC_RELATIVE].u.sym =
    symbol_new (".<secrel>", undefined_section, FUNC_SEC_RELATIVE,
		&zero_address_frag);

  pseudo_func[FUNC_SEG_RELATIVE].u.sym =
    symbol_new (".<segrel>", undefined_section, FUNC_SEG_RELATIVE,
		&zero_address_frag);

  pseudo_func[FUNC_TP_RELATIVE].u.sym =
    symbol_new (".<tprel>", undefined_section, FUNC_TP_RELATIVE,
		&zero_address_frag);

  pseudo_func[FUNC_LTV_RELATIVE].u.sym =
    symbol_new (".<ltv>", undefined_section, FUNC_LTV_RELATIVE,
		&zero_address_frag);

  pseudo_func[FUNC_LT_FPTR_RELATIVE].u.sym =
    symbol_new (".<ltoff.fptr>", undefined_section, FUNC_LT_FPTR_RELATIVE,
		&zero_address_frag);

  pseudo_func[FUNC_LT_DTP_MODULE].u.sym =
    symbol_new (".<ltoff.dtpmod>", undefined_section, FUNC_LT_DTP_MODULE,
		&zero_address_frag);

  pseudo_func[FUNC_LT_DTP_RELATIVE].u.sym =
    symbol_new (".<ltoff.dptrel>", undefined_section, FUNC_LT_DTP_RELATIVE,
		&zero_address_frag);

  pseudo_func[FUNC_LT_TP_RELATIVE].u.sym =
    symbol_new (".<ltoff.tprel>", undefined_section, FUNC_LT_TP_RELATIVE,
		&zero_address_frag);

  pseudo_func[FUNC_IPLT_RELOC].u.sym =
    symbol_new (".<iplt>", undefined_section, FUNC_IPLT_RELOC,
		&zero_address_frag);

#ifdef TE_VMS
  pseudo_func[FUNC_SLOTCOUNT_RELOC].u.sym =
    symbol_new (".<slotcount>", undefined_section, FUNC_SLOTCOUNT_RELOC,
		&zero_address_frag);
#endif

 if (md.tune != itanium1)
   {
     /* Convert MFI NOPs bundles into MMI NOPs bundles.  */
     le_nop[0] = 0x8;
     le_nop_stop[0] = 0x9;
   }

  /* Compute the table of best templates.  We compute goodness as a
     base 4 value, in which each match counts for 3.  Match-failures
     result in NOPs and we use extra_goodness() to pick the execution
     units that are best suited for issuing the NOP.  */
  for (i = 0; i < IA64_NUM_TYPES; ++i)
    for (j = 0; j < IA64_NUM_TYPES; ++j)
      for (k = 0; k < IA64_NUM_TYPES; ++k)
	{
	  best = 0;
	  for (t = 0; t < NELEMS (ia64_templ_desc); ++t)
	    {
	      goodness = 0;
	      if (match (t, i, 0))
		{
		  if (match (t, j, 1))
		    {
		      if ((t == 2 && j == IA64_TYPE_X) || match (t, k, 2))
			goodness = 3 + 3 + 3;
		      else
			goodness = 3 + 3 + extra_goodness (t, 2);
		    }
		  else if (match (t, j, 2))
		    goodness = 3 + 3 + extra_goodness (t, 1);
		  else
		    {
		      goodness = 3;
		      goodness += extra_goodness (t, 1);
		      goodness += extra_goodness (t, 2);
		    }
		}
	      else if (match (t, i, 1))
		{
		  if ((t == 2 && i == IA64_TYPE_X) || match (t, j, 2))
		    goodness = 3 + 3;
		  else
		    goodness = 3 + extra_goodness (t, 2);
		}
	      else if (match (t, i, 2))
		goodness = 3 + extra_goodness (t, 1);

	      if (goodness > best)
		{
		  best = goodness;
		  best_template[i][j][k] = t;
		}
	    }
	}

#ifdef DEBUG_TEMPLATES
  /* For debugging changes to the best_template calculations.  We don't care
     about combinations with invalid instructions, so start the loops at 1.  */
  for (i = 0; i < IA64_NUM_TYPES; ++i)
    for (j = 0; j < IA64_NUM_TYPES; ++j)
      for (k = 0; k < IA64_NUM_TYPES; ++k)
	{
	  char type_letter[IA64_NUM_TYPES] = { 'n', 'a', 'i', 'm', 'b', 'f',
					       'x', 'd' };
	  fprintf (stderr, "%c%c%c %s\n", type_letter[i], type_letter[j],
		   type_letter[k],
		   ia64_templ_desc[best_template[i][j][k]].name);
	}
#endif

  for (i = 0; i < NUM_SLOTS; ++i)
    md.slot[i].user_template = -1;

  md.pseudo_hash = hash_new ();
  for (i = 0; i < NELEMS (pseudo_opcode); ++i)
    {
      err = hash_insert (md.pseudo_hash, pseudo_opcode[i].name,
			 (void *) (pseudo_opcode + i));
      if (err)
	as_fatal (_("ia64.md_begin: can't hash `%s': %s"),
		  pseudo_opcode[i].name, err);
    }

  md.reg_hash = hash_new ();
  md.dynreg_hash = hash_new ();
  md.const_hash = hash_new ();
  md.entry_hash = hash_new ();

  /* general registers:  */
  declare_register_set ("r", 128, REG_GR);
  declare_register ("gp", REG_GR +  1);
  declare_register ("sp", REG_GR + 12);
  declare_register ("tp", REG_GR + 13);
  declare_register_set ("ret", 4, REG_GR + 8);

  /* floating point registers:  */
  declare_register_set ("f", 128, REG_FR);
  declare_register_set ("farg", 8, REG_FR + 8);
  declare_register_set ("fret", 8, REG_FR + 8);

  /* branch registers:  */
  declare_register_set ("b", 8, REG_BR);
  declare_register ("rp", REG_BR + 0);

  /* predicate registers:  */
  declare_register_set ("p", 64, REG_P);
  declare_register ("pr", REG_PR);
  declare_register ("pr.rot", REG_PR_ROT);

  /* application registers:  */
  declare_register_set ("ar", 128, REG_AR);
  for (i = 0; i < NELEMS (ar); ++i)
    declare_register (ar[i].name, REG_AR + ar[i].regnum);

  /* control registers:  */
  declare_register_set ("cr", 128, REG_CR);
  for (i = 0; i < NELEMS (cr); ++i)
    declare_register (cr[i].name, REG_CR + cr[i].regnum);

  /* dahr registers:  */
  declare_register_set ("dahr", 8, REG_DAHR);

  declare_register ("ip", REG_IP);
  declare_register ("cfm", REG_CFM);
  declare_register ("psr", REG_PSR);
  declare_register ("psr.l", REG_PSR_L);
  declare_register ("psr.um", REG_PSR_UM);

  for (i = 0; i < NELEMS (indirect_reg); ++i)
    {
      unsigned int regnum = indirect_reg[i].regnum;

      md.indregsym[regnum - IND_CPUID] = declare_register (indirect_reg[i].name, regnum);
    }

  /* pseudo-registers used to specify unwind info:  */
  declare_register ("psp", REG_PSP);

  for (i = 0; i < NELEMS (const_bits); ++i)
    {
      err = hash_insert (md.const_hash, const_bits[i].name,
			 (void *) (const_bits + i));
      if (err)
	as_fatal (_("Inserting \"%s\" into constant hash table failed: %s"),
		  name, err);
    }

  /* Set the architecture and machine depending on defaults and command line
     options.  */
  if (md.flags & EF_IA_64_ABI64)
    ok = bfd_set_arch_mach (stdoutput, bfd_arch_ia64, bfd_mach_ia64_elf64);
  else
    ok = bfd_set_arch_mach (stdoutput, bfd_arch_ia64, bfd_mach_ia64_elf32);

  if (! ok)
     as_warn (_("Could not set architecture and machine"));

  /* Set the pointer size and pointer shift size depending on md.flags */

  if (md.flags & EF_IA_64_ABI64)
    {
      md.pointer_size = 8;         /* pointers are 8 bytes */
      md.pointer_size_shift = 3;   /* alignment is 8 bytes = 2^2 */
    }
  else
    {
      md.pointer_size = 4;         /* pointers are 4 bytes */
      md.pointer_size_shift = 2;   /* alignment is 4 bytes = 2^2 */
    }

  md.mem_offset.hint = 0;
  md.path = 0;
  md.maxpaths = 0;
  md.entry_labels = NULL;
}

/* Set the default options in md.  Cannot do this in md_begin because
   that is called after md_parse_option which is where we set the
   options in md based on command line options.  */

void
ia64_init (int argc ATTRIBUTE_UNUSED, char **argv ATTRIBUTE_UNUSED)
{
  md.flags = MD_FLAGS_DEFAULT;
#ifndef TE_VMS
  /* Don't turn on dependency checking for VMS, doesn't work.  */
  md.detect_dv = 1;
#endif
  /* FIXME: We should change it to unwind_check_error someday.  */
  md.unwind_check = unwind_check_warning;
  md.hint_b = hint_b_error;
  md.tune = itanium2;
}

/* Return a string for the target object file format.  */

const char *
ia64_target_format (void)
{
  if (OUTPUT_FLAVOR == bfd_target_elf_flavour)
    {
      if (md.flags & EF_IA_64_BE)
	{
	  if (md.flags & EF_IA_64_ABI64)
#if defined(TE_AIX50)
	    return "elf64-ia64-aix-big";
#elif defined(TE_HPUX)
	    return "elf64-ia64-hpux-big";
#else
	    return "elf64-ia64-big";
#endif
	  else
#if defined(TE_AIX50)
	    return "elf32-ia64-aix-big";
#elif defined(TE_HPUX)
	    return "elf32-ia64-hpux-big";
#else
	    return "elf32-ia64-big";
#endif
	}
      else
	{
	  if (md.flags & EF_IA_64_ABI64)
#if defined (TE_AIX50)
	    return "elf64-ia64-aix-little";
#elif defined (TE_VMS)
	  {
	    md.flags |= EF_IA_64_ARCHVER_1;
	    return "elf64-ia64-vms";
	  }
#else
	    return "elf64-ia64-little";
#endif
	  else
#ifdef TE_AIX50
	    return "elf32-ia64-aix-little";
#else
	    return "elf32-ia64-little";
#endif
	}
    }
  else
    return "unknown-format";
}

void
ia64_end_of_source (void)
{
  /* terminate insn group upon reaching end of file:  */
  insn_group_break (1, 0, 0);

  /* emits slots we haven't written yet:  */
  ia64_flush_insns ();

  bfd_set_private_flags (stdoutput, md.flags);

  md.mem_offset.hint = 0;
}

void
ia64_start_line (void)
{
  static int first;

  if (!first) {
    /* Make sure we don't reference input_line_pointer[-1] when that's
       not valid.  */
    first = 1;
    return;
  }

  if (md.qp.X_op == O_register)
    as_bad (_("qualifying predicate not followed by instruction"));
  md.qp.X_op = O_absent;

  if (ignore_input ())
    return;

  if (input_line_pointer[0] == ';' && input_line_pointer[-1] == ';')
    {
      if (md.detect_dv && !md.explicit_mode)
	{
	  static int warned;

	  if (!warned)
	    {
	      warned = 1;
	      as_warn (_("Explicit stops are ignored in auto mode"));
	    }
	}
      else
	insn_group_break (1, 0, 0);
    }
  else if (input_line_pointer[-1] == '{')
    {
      if (md.manual_bundling)
	as_warn (_("Found '{' when manual bundling is already turned on"));
      else
	CURR_SLOT.manual_bundling_on = 1;
      md.manual_bundling = 1;

      /* Bundling is only acceptable in explicit mode
	 or when in default automatic mode.  */
      if (md.detect_dv && !md.explicit_mode)
	{
	  if (!md.mode_explicitly_set
	      && !md.default_explicit_mode)
	    dot_dv_mode ('E');
	  else
	    as_warn (_("Found '{' after explicit switch to automatic mode"));
	}
    }
  else if (input_line_pointer[-1] == '}')
    {
      if (!md.manual_bundling)
	as_warn (_("Found '}' when manual bundling is off"));
      else
	PREV_SLOT.manual_bundling_off = 1;
      md.manual_bundling = 0;

      /* switch back to automatic mode, if applicable */
      if (md.detect_dv
	  && md.explicit_mode
	  && !md.mode_explicitly_set
	  && !md.default_explicit_mode)
	dot_dv_mode ('A');
    }
}

/* This is a hook for ia64_frob_label, so that it can distinguish tags from
   labels.  */
static int defining_tag = 0;

int
ia64_unrecognized_line (int ch)
{
  switch (ch)
    {
    case '(':
      expression_and_evaluate (&md.qp);
      if (*input_line_pointer++ != ')')
	{
	  as_bad (_("Expected ')'"));
	  return 0;
	}
      if (md.qp.X_op != O_register)
	{
	  as_bad (_("Qualifying predicate expected"));
	  return 0;
	}
      if (md.qp.X_add_number < REG_P || md.qp.X_add_number >= REG_P + 64)
	{
	  as_bad (_("Predicate register expected"));
	  return 0;
	}
      return 1;

    case '[':
      {
	char *s;
	char c;
	symbolS *tag;
	int temp;

	if (md.qp.X_op == O_register)
	  {
	    as_bad (_("Tag must come before qualifying predicate."));
	    return 0;
	  }

	/* This implements just enough of read_a_source_file in read.c to
	   recognize labels.  */
	if (is_name_beginner (*input_line_pointer))
	  {
	    s = input_line_pointer;
	    c = get_symbol_end ();
	  }
	else if (LOCAL_LABELS_FB
		 && ISDIGIT (*input_line_pointer))
	  {
	    temp = 0;
	    while (ISDIGIT (*input_line_pointer))
	      temp = (temp * 10) + *input_line_pointer++ - '0';
	    fb_label_instance_inc (temp);
	    s = fb_label_name (temp, 0);
	    c = *input_line_pointer;
	  }
	else
	  {
	    s = NULL;
	    c = '\0';
	  }
	if (c != ':')
	  {
	    /* Put ':' back for error messages' sake.  */
	    *input_line_pointer++ = ':';
	    as_bad (_("Expected ':'"));
	    return 0;
	  }

	defining_tag = 1;
	tag = colon (s);
	defining_tag = 0;
	/* Put ':' back for error messages' sake.  */
	*input_line_pointer++ = ':';
	if (*input_line_pointer++ != ']')
	  {
	    as_bad (_("Expected ']'"));
	    return 0;
	  }
	if (! tag)
	  {
	    as_bad (_("Tag name expected"));
	    return 0;
	  }
	return 1;
      }

    default:
      break;
    }

  /* Not a valid line.  */
  return 0;
}

void
ia64_frob_label (struct symbol *sym)
{
  struct label_fix *fix;

  /* Tags need special handling since they are not bundle breaks like
     labels.  */
  if (defining_tag)
    {
      fix = obstack_alloc (&notes, sizeof (*fix));
      fix->sym = sym;
      fix->next = CURR_SLOT.tag_fixups;
      fix->dw2_mark_labels = FALSE;
      CURR_SLOT.tag_fixups = fix;

      return;
    }

  if (bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE)
    {
      md.last_text_seg = now_seg;
      fix = obstack_alloc (&notes, sizeof (*fix));
      fix->sym = sym;
      fix->next = CURR_SLOT.label_fixups;
      fix->dw2_mark_labels = dwarf2_loc_mark_labels;
      CURR_SLOT.label_fixups = fix;

      /* Keep track of how many code entry points we've seen.  */
      if (md.path == md.maxpaths)
	{
	  md.maxpaths += 20;
	  md.entry_labels = (const char **)
	    xrealloc ((void *) md.entry_labels,
		      md.maxpaths * sizeof (char *));
	}
      md.entry_labels[md.path++] = S_GET_NAME (sym);
    }
}

#ifdef TE_HPUX
/* The HP-UX linker will give unresolved symbol errors for symbols
   that are declared but unused.  This routine removes declared,
   unused symbols from an object.  */
int
ia64_frob_symbol (struct symbol *sym)
{
  if ((S_GET_SEGMENT (sym) == bfd_und_section_ptr && ! symbol_used_p (sym) &&
       ELF_ST_VISIBILITY (S_GET_OTHER (sym)) == STV_DEFAULT)
      || (S_GET_SEGMENT (sym) == bfd_abs_section_ptr
	  && ! S_IS_EXTERNAL (sym)))
    return 1;
  return 0;
}
#endif

void
ia64_flush_pending_output (void)
{
  if (!md.keep_pending_output
      && bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE)
    {
      /* ??? This causes many unnecessary stop bits to be emitted.
	 Unfortunately, it isn't clear if it is safe to remove this.  */
      insn_group_break (1, 0, 0);
      ia64_flush_insns ();
    }
}

/* Do ia64-specific expression optimization.  All that's done here is
   to transform index expressions that are either due to the indexing
   of rotating registers or due to the indexing of indirect register
   sets.  */
int
ia64_optimize_expr (expressionS *l, operatorT op, expressionS *r)
{
  if (op != O_index)
    return 0;
  resolve_expression (l);
  if (l->X_op == O_register)
    {
      unsigned num_regs = l->X_add_number >> 16;

      resolve_expression (r);
      if (num_regs)
	{
	  /* Left side is a .rotX-allocated register.  */
	  if (r->X_op != O_constant)
	    {
	      as_bad (_("Rotating register index must be a non-negative constant"));
	      r->X_add_number = 0;
	    }
	  else if ((valueT) r->X_add_number >= num_regs)
	    {
	      as_bad (_("Index out of range 0..%u"), num_regs - 1);
	      r->X_add_number = 0;
	    }
	  l->X_add_number = (l->X_add_number & 0xffff) + r->X_add_number;
	  return 1;
	}
      else if (l->X_add_number >= IND_CPUID && l->X_add_number <= IND_RR)
	{
	  if (r->X_op != O_register
	      || r->X_add_number < REG_GR
	      || r->X_add_number > REG_GR + 127)
	    {
	      as_bad (_("Indirect register index must be a general register"));
	      r->X_add_number = REG_GR;
	    }
	  l->X_op = O_index;
	  l->X_op_symbol = md.indregsym[l->X_add_number - IND_CPUID];
	  l->X_add_number = r->X_add_number;
	  return 1;
	}
    }
  as_bad (_("Index can only be applied to rotating or indirect registers"));
  /* Fall back to some register use of which has as little as possible
     side effects, to minimize subsequent error messages.  */
  l->X_op = O_register;
  l->X_add_number = REG_GR + 3;
  return 1;
}

int
ia64_parse_name (char *name, expressionS *e, char *nextcharP)
{
  struct const_desc *cdesc;
  struct dynreg *dr = 0;
  unsigned int idx;
  struct symbol *sym;
  char *end;

  if (*name == '@@')
    {
      enum pseudo_type pseudo_type = PSEUDO_FUNC_NONE;

      /* Find what relocation pseudo-function we're dealing with.  */
      for (idx = 0; idx < NELEMS (pseudo_func); ++idx)
	if (pseudo_func[idx].name
	    && pseudo_func[idx].name[0] == name[1]
	    && strcmp (pseudo_func[idx].name + 1, name + 2) == 0)
	  {
	    pseudo_type = pseudo_func[idx].type;
	    break;
	  }
      switch (pseudo_type)
	{
	case PSEUDO_FUNC_RELOC:
	  end = input_line_pointer;
	  if (*nextcharP != '(')
	    {
	      as_bad (_("Expected '('"));
	      break;
	    }
	  /* Skip '('.  */
	  ++input_line_pointer;
	  expression (e);
	  if (*input_line_pointer != ')')
	    {
	      as_bad (_("Missing ')'"));
	      goto done;
	    }
	  /* Skip ')'.  */
	  ++input_line_pointer;
#ifdef TE_VMS
          if (idx == FUNC_SLOTCOUNT_RELOC)
            {
              /* @@slotcount can accept any expression.  Canonicalize.  */
              e->X_add_symbol = make_expr_symbol (e);
              e->X_op = O_symbol;
              e->X_add_number = 0;
            }
#endif
	  if (e->X_op != O_symbol)
	    {
	      if (e->X_op != O_pseudo_fixup)
		{
		  as_bad (_("Not a symbolic expression"));
		  goto done;
		}
	      if (idx != FUNC_LT_RELATIVE)
		{
		  as_bad (_("Illegal combination of relocation functions"));
		  goto done;
		}
	      switch (S_GET_VALUE (e->X_op_symbol))
		{
		case FUNC_FPTR_RELATIVE:
		  idx = FUNC_LT_FPTR_RELATIVE; break;
		case FUNC_DTP_MODULE:
		  idx = FUNC_LT_DTP_MODULE; break;
		case FUNC_DTP_RELATIVE:
		  idx = FUNC_LT_DTP_RELATIVE; break;
		case FUNC_TP_RELATIVE:
		  idx = FUNC_LT_TP_RELATIVE; break;
		default:
		  as_bad (_("Illegal combination of relocation functions"));
		  goto done;
		}
	    }
	  /* Make sure gas doesn't get rid of local symbols that are used
	     in relocs.  */
	  e->X_op = O_pseudo_fixup;
	  e->X_op_symbol = pseudo_func[idx].u.sym;
	done:
	  *nextcharP = *input_line_pointer;
	  break;

	case PSEUDO_FUNC_CONST:
	  e->X_op = O_constant;
	  e->X_add_number = pseudo_func[idx].u.ival;
	  break;

	case PSEUDO_FUNC_REG:
	  e->X_op = O_register;
	  e->X_add_number = pseudo_func[idx].u.ival;
	  break;

	default:
	  return 0;
	}
      return 1;
    }

  /* first see if NAME is a known register name:  */
  sym = hash_find (md.reg_hash, name);
  if (sym)
    {
      e->X_op = O_register;
      e->X_add_number = S_GET_VALUE (sym);
      return 1;
    }

  cdesc = hash_find (md.const_hash, name);
  if (cdesc)
    {
      e->X_op = O_constant;
      e->X_add_number = cdesc->value;
      return 1;
    }

  /* check for inN, locN, or outN:  */
  idx = 0;
  switch (name[0])
    {
    case 'i':
      if (name[1] == 'n' && ISDIGIT (name[2]))
	{
	  dr = &md.in;
	  idx = 2;
	}
      break;

    case 'l':
      if (name[1] == 'o' && name[2] == 'c' && ISDIGIT (name[3]))
	{
	  dr = &md.loc;
	  idx = 3;
	}
      break;

    case 'o':
      if (name[1] == 'u' && name[2] == 't' && ISDIGIT (name[3]))
	{
	  dr = &md.out;
	  idx = 3;
	}
      break;

    default:
      break;
    }

  /* Ignore register numbers with leading zeroes, except zero itself.  */
  if (dr && (name[idx] != '0' || name[idx + 1] == '\0'))
    {
      unsigned long regnum;

      /* The name is inN, locN, or outN; parse the register number.  */
      regnum = strtoul (name + idx, &end, 10);
      if (end > name + idx && *end == '\0' && regnum < 96)
	{
	  if (regnum >= dr->num_regs)
	    {
	      if (!dr->num_regs)
		as_bad (_("No current frame"));
	      else
		as_bad (_("Register number out of range 0..%u"),
			dr->num_regs - 1);
	      regnum = 0;
	    }
	  e->X_op = O_register;
	  e->X_add_number = dr->base + regnum;
	  return 1;
	}
    }

  end = alloca (strlen (name) + 1);
  strcpy (end, name);
  name = ia64_canonicalize_symbol_name (end);
  if ((dr = hash_find (md.dynreg_hash, name)))
    {
      /* We've got ourselves the name of a rotating register set.
	 Store the base register number in the low 16 bits of
	 X_add_number and the size of the register set in the top 16
	 bits.  */
      e->X_op = O_register;
      e->X_add_number = dr->base | (dr->num_regs << 16);
      return 1;
    }
  return 0;
}

/* Remove the '#' suffix that indicates a symbol as opposed to a register.  */

char *
ia64_canonicalize_symbol_name (char *name)
{
  size_t len = strlen (name), full = len;

  while (len > 0 && name[len - 1] == '#')
    --len;
  if (len <= 0)
    {
      if (full > 0)
	as_bad (_("Standalone `#' is illegal"));
    }
  else if (len < full - 1)
    as_warn (_("Redundant `#' suffix operators"));
  name[len] = '\0';
  return name;
}

/* Return true if idesc is a conditional branch instruction.  This excludes
   the modulo scheduled branches, and br.ia.  Mod-sched branches are excluded
   because they always read/write resources regardless of the value of the
   qualifying predicate.  br.ia must always use p0, and hence is always
   taken.  Thus this function returns true for branches which can fall
   through, and which use no resources if they do fall through.  */

static int
is_conditional_branch (struct ia64_opcode *idesc)
{
  /* br is a conditional branch.  Everything that starts with br. except
     br.ia, br.c{loop,top,exit}, and br.w{top,exit} is a conditional branch.
     Everything that starts with brl is a conditional branch.  */
  return (idesc->name[0] == 'b' && idesc->name[1] == 'r'
	  && (idesc->name[2] == '\0'
	      || (idesc->name[2] == '.' && idesc->name[3] != 'i'
		  && idesc->name[3] != 'c' && idesc->name[3] != 'w')
	      || idesc->name[2] == 'l'
	      /* br.cond, br.call, br.clr  */
	      || (idesc->name[2] == '.' && idesc->name[3] == 'c'
		  && (idesc->name[4] == 'a' || idesc->name[4] == 'o'
		      || (idesc->name[4] == 'l' && idesc->name[5] == 'r')))));
}

/* Return whether the given opcode is a taken branch.  If there's any doubt,
   returns zero.  */

static int
is_taken_branch (struct ia64_opcode *idesc)
{
  return ((is_conditional_branch (idesc) && CURR_SLOT.qp_regno == 0)
	  || strncmp (idesc->name, "br.ia", 5) == 0);
}

/* Return whether the given opcode is an interruption or rfi.  If there's any
   doubt, returns zero.  */

static int
is_interruption_or_rfi (struct ia64_opcode *idesc)
{
  if (strcmp (idesc->name, "rfi") == 0)
    return 1;
  return 0;
}

/* Returns the index of the given dependency in the opcode's list of chks, or
   -1 if there is no dependency.  */

static int
depends_on (int depind, struct ia64_opcode *idesc)
{
  int i;
  const struct ia64_opcode_dependency *dep = idesc->dependencies;
  for (i = 0; i < dep->nchks; i++)
    {
      if (depind == DEP (dep->chks[i]))
	return i;
    }
  return -1;
}

/* Determine a set of specific resources used for a particular resource
   class.  Returns the number of specific resources identified  For those
   cases which are not determinable statically, the resource returned is
   marked nonspecific.

   Meanings of value in 'NOTE':
   1) only read/write when the register number is explicitly encoded in the
   insn.
   2) only read CFM when accessing a rotating GR, FR, or PR.  mov pr only
   accesses CFM when qualifying predicate is in the rotating region.
   3) general register value is used to specify an indirect register; not
   determinable statically.
   4) only read the given resource when bits 7:0 of the indirect index
   register value does not match the register number of the resource; not
   determinable statically.
   5) all rules are implementation specific.
   6) only when both the index specified by the reader and the index specified
   by the writer have the same value in bits 63:61; not determinable
   statically.
   7) only access the specified resource when the corresponding mask bit is
   set
   8) PSR.dfh is only read when these insns reference FR32-127.  PSR.dfl is
   only read when these insns reference FR2-31
   9) PSR.mfl is only written when these insns write FR2-31.  PSR.mfh is only
   written when these insns write FR32-127
   10) The PSR.bn bit is only accessed when one of GR16-31 is specified in the
   instruction
   11) The target predicates are written independently of PR[qp], but source
   registers are only read if PR[qp] is true.  Since the state of PR[qp]
   cannot statically be determined, all source registers are marked used.
   12) This insn only reads the specified predicate register when that
   register is the PR[qp].
   13) This reference to ld-c only applies to the GR whose value is loaded
   with data returned from memory, not the post-incremented address register.
   14) The RSE resource includes the implementation-specific RSE internal
   state resources.  At least one (and possibly more) of these resources are
   read by each instruction listed in IC:rse-readers.  At least one (and
   possibly more) of these resources are written by each insn listed in
   IC:rse-writers.
   15+16) Represents reserved instructions, which the assembler does not
   generate.
   17) CR[TPR] has a RAW dependency only between mov-to-CR-TPR and
   mov-to-PSR-l or ssm instructions that set PSR.i, PSR.pp or PSR.up.

   Memory resources (i.e. locations in memory) are *not* marked or tracked by
   this code; there are no dependency violations based on memory access.
*/

#define MAX_SPECS 256
#define DV_CHK 1
#define DV_REG 0

static int
specify_resource (const struct ia64_dependency *dep,
		  struct ia64_opcode *idesc,
		  /* is this a DV chk or a DV reg? */
		  int type,
		  /* returned specific resources */
		  struct rsrc specs[MAX_SPECS],
		  /* resource note for this insn's usage */
		  int note,
		  /* which execution path to examine */
		  int path)
{
  int count = 0;
  int i;
  int rsrc_write = 0;
  struct rsrc tmpl;

  if (dep->mode == IA64_DV_WAW
      || (dep->mode == IA64_DV_RAW && type == DV_REG)
      || (dep->mode == IA64_DV_WAR && type == DV_CHK))
    rsrc_write = 1;

  /* template for any resources we identify */
  tmpl.dependency = dep;
  tmpl.note = note;
  tmpl.insn_srlz = tmpl.data_srlz = 0;
  tmpl.qp_regno = CURR_SLOT.qp_regno;
  tmpl.link_to_qp_branch = 1;
  tmpl.mem_offset.hint = 0;
  tmpl.mem_offset.offset = 0;
  tmpl.mem_offset.base = 0;
  tmpl.specific = 1;
  tmpl.index = -1;
  tmpl.cmp_type = CMP_NONE;
  tmpl.depind = 0;
  tmpl.file = NULL;
  tmpl.line = 0;
  tmpl.path = 0;

#define UNHANDLED \
as_warn (_("Unhandled dependency %s for %s (%s), note %d"), \
dep->name, idesc->name, (rsrc_write?"write":"read"), note)
#define KNOWN(REG) (gr_values[REG].known && gr_values[REG].path >= path)

  /* we don't need to track these */
  if (dep->semantics == IA64_DVS_NONE)
    return 0;

  switch (dep->specifier)
    {
    case IA64_RS_AR_K:
      if (note == 1)
	{
	  if (idesc->operands[!rsrc_write] == IA64_OPND_AR3)
	    {
	      int regno = CURR_SLOT.opnd[!rsrc_write].X_add_number - REG_AR;
	      if (regno >= 0 && regno <= 7)
		{
		  specs[count] = tmpl;
		  specs[count++].index = regno;
		}
	    }
	}
      else if (note == 0)
	{
	  for (i = 0; i < 8; i++)
	    {
	      specs[count] = tmpl;
	      specs[count++].index = i;
	    }
	}
      else
	{
	  UNHANDLED;
	}
      break;

    case IA64_RS_AR_UNAT:
      /* This is a mov =AR or mov AR= instruction.  */
      if (idesc->operands[!rsrc_write] == IA64_OPND_AR3)
	{
	  int regno = CURR_SLOT.opnd[!rsrc_write].X_add_number - REG_AR;
	  if (regno == AR_UNAT)
	    {
	      specs[count++] = tmpl;
	    }
	}
      else
	{
	  /* This is a spill/fill, or other instruction that modifies the
	     unat register.  */

	  /* Unless we can determine the specific bits used, mark the whole
	     thing; bits 8:3 of the memory address indicate the bit used in
	     UNAT.  The .mem.offset hint may be used to eliminate a small
	     subset of conflicts.  */
	  specs[count] = tmpl;
	  if (md.mem_offset.hint)
	    {
	      if (md.debug_dv)
		fprintf (stderr, "  Using hint for spill/fill\n");
	      /* The index isn't actually used, just set it to something
		 approximating the bit index.  */
	      specs[count].index = (md.mem_offset.offset >> 3) & 0x3F;
	      specs[count].mem_offset.hint = 1;
	      specs[count].mem_offset.offset = md.mem_offset.offset;
	      specs[count++].mem_offset.base = md.mem_offset.base;
	    }
	  else
	    {
	      specs[count++].specific = 0;
	    }
	}
      break;

    case IA64_RS_AR:
      if (note == 1)
	{
	  if (idesc->operands[!rsrc_write] == IA64_OPND_AR3)
	    {
	      int regno = CURR_SLOT.opnd[!rsrc_write].X_add_number - REG_AR;
	      if ((regno >= 8 && regno <= 15)
		  || (regno >= 20 && regno <= 23)
		  || (regno >= 31 && regno <= 39)
		  || (regno >= 41 && regno <= 47)
		  || (regno >= 67 && regno <= 111))
		{
		  specs[count] = tmpl;
		  specs[count++].index = regno;
		}
	    }
	}
      else
	{
	  UNHANDLED;
	}
      break;

    case IA64_RS_ARb:
      if (note == 1)
	{
	  if (idesc->operands[!rsrc_write] == IA64_OPND_AR3)
	    {
	      int regno = CURR_SLOT.opnd[!rsrc_write].X_add_number - REG_AR;
	      if ((regno >= 48 && regno <= 63)
		  || (regno >= 112 && regno <= 127))
		{
		  specs[count] = tmpl;
		  specs[count++].index = regno;
		}
	    }
	}
      else if (note == 0)
	{
	  for (i = 48; i < 64; i++)
	    {
	      specs[count] = tmpl;
	      specs[count++].index = i;
	    }
	  for (i = 112; i < 128; i++)
	    {
	      specs[count] = tmpl;
	      specs[count++].index = i;
	    }
	}
      else
	{
	  UNHANDLED;
	}
      break;

    case IA64_RS_BR:
      if (note != 1)
	{
	  UNHANDLED;
	}
      else
	{
	  if (rsrc_write)
	    {
	      for (i = 0; i < idesc->num_outputs; i++)
		if (idesc->operands[i] == IA64_OPND_B1
		    || idesc->operands[i] == IA64_OPND_B2)
		  {
		    specs[count] = tmpl;
		    specs[count++].index =
		      CURR_SLOT.opnd[i].X_add_number - REG_BR;
		  }
	    }
	  else
	    {
	      for (i = idesc->num_outputs; i < NELEMS (idesc->operands); i++)
		if (idesc->operands[i] == IA64_OPND_B1
		    || idesc->operands[i] == IA64_OPND_B2)
		  {
		    specs[count] = tmpl;
		    specs[count++].index =
		      CURR_SLOT.opnd[i].X_add_number - REG_BR;
		  }
	    }
	}
      break;

    case IA64_RS_CPUID: /* four or more registers */
      if (note == 3)
	{
	  if (idesc->operands[!rsrc_write] == IA64_OPND_CPUID_R3)
	    {
	      int regno = CURR_SLOT.opnd[!rsrc_write].X_add_number - REG_GR;
	      if (regno >= 0 && regno < NELEMS (gr_values)
		  && KNOWN (regno))
		{
		  specs[count] = tmpl;
		  specs[count++].index = gr_values[regno].value & 0xFF;
		}
	      else
		{
		  specs[count] = tmpl;
		  specs[count++].specific = 0;
		}
	    }
	}
      else
	{
	  UNHANDLED;
	}
      break;

    case IA64_RS_DBR: /* four or more registers */
      if (note == 3)
	{
	  if (idesc->operands[!rsrc_write] == IA64_OPND_DBR_R3)
	    {
	      int regno = CURR_SLOT.opnd[!rsrc_write].X_add_number - REG_GR;
	      if (regno >= 0 && regno < NELEMS (gr_values)
		  && KNOWN (regno))
		{
		  specs[count] = tmpl;
		  specs[count++].index = gr_values[regno].value & 0xFF;
		}
	      else
		{
		  specs[count] = tmpl;
		  specs[count++].specific = 0;
		}
	    }
	}
      else if (note == 0 && !rsrc_write)
	{
	  specs[count] = tmpl;
	  specs[count++].specific = 0;
	}
      else
	{
	  UNHANDLED;
	}
      break;

    case IA64_RS_IBR: /* four or more registers */
      if (note == 3)
	{
	  if (idesc->operands[!rsrc_write] == IA64_OPND_IBR_R3)
	    {
	      int regno = CURR_SLOT.opnd[!rsrc_write].X_add_number - REG_GR;
	      if (regno >= 0 && regno < NELEMS (gr_values)
		  && KNOWN (regno))
		{
		  specs[count] = tmpl;
		  specs[count++].index = gr_values[regno].value & 0xFF;
		}
	      else
		{
		  specs[count] = tmpl;
		  specs[count++].specific = 0;
		}
	    }
	}
      else
	{
	  UNHANDLED;
	}
      break;

    case IA64_RS_MSR:
      if (note == 5)
	{
	  /* These are implementation specific.  Force all references to
	     conflict with all other references.  */
	  specs[count] = tmpl;
	  specs[count++].specific = 0;
	}
      else
	{
	  UNHANDLED;
	}
      break;

    case IA64_RS_PKR: /* 16 or more registers */
      if (note == 3 || note == 4)
	{
	  if (idesc->operands[!rsrc_write] == IA64_OPND_PKR_R3)
	    {
	      int regno = CURR_SLOT.opnd[!rsrc_write].X_add_number - REG_GR;
	      if (regno >= 0 && regno < NELEMS (gr_values)
		  && KNOWN (regno))
		{
		  if (note == 3)
		    {
		      specs[count] = tmpl;
		      specs[count++].index = gr_values[regno].value & 0xFF;
		    }
		  else
		    for (i = 0; i < NELEMS (gr_values); i++)
		      {
			/* Uses all registers *except* the one in R3.  */
			if ((unsigned)i != (gr_values[regno].value & 0xFF))
			  {
			    specs[count] = tmpl;
			    specs[count++].index = i;
			  }
		      }
		}
	      else
		{
		  specs[count] = tmpl;
		  specs[count++].specific = 0;
		}
	    }
	}
      else if (note == 0)
	{
	  /* probe et al.  */
	  specs[count] = tmpl;
	  specs[count++].specific = 0;
	}
      break;

    case IA64_RS_PMC: /* four or more registers */
      if (note == 3)
	{
	  if (idesc->operands[!rsrc_write] == IA64_OPND_PMC_R3
	      || (!rsrc_write && idesc->operands[1] == IA64_OPND_PMD_R3))

	    {
	      int reg_index = ((idesc->operands[1] == IA64_OPND_R3 && !rsrc_write)
			       ? 1 : !rsrc_write);
	      int regno = CURR_SLOT.opnd[reg_index].X_add_number - REG_GR;
	      if (regno >= 0 && regno < NELEMS (gr_values)
		  && KNOWN (regno))
		{
		  specs[count] = tmpl;
		  specs[count++].index = gr_values[regno].value & 0xFF;
		}
	      else
		{
		  specs[count] = tmpl;
		  specs[count++].specific = 0;
		}
	    }
	}
      else
	{
	  UNHANDLED;
	}
      break;

    case IA64_RS_PMD: /* four or more registers */
      if (note == 3)
	{
	  if (idesc->operands[!rsrc_write] == IA64_OPND_PMD_R3)
	    {
	      int regno = CURR_SLOT.opnd[!rsrc_write].X_add_number - REG_GR;
	      if (regno >= 0 && regno < NELEMS (gr_values)
		  && KNOWN (regno))
		{
		  specs[count] = tmpl;
		  specs[count++].index = gr_values[regno].value & 0xFF;
		}
	      else
		{
		  specs[count] = tmpl;
		  specs[count++].specific = 0;
		}
	    }
	}
      else
	{
	  UNHANDLED;
	}
      break;

    case IA64_RS_RR: /* eight registers */
      if (note == 6)
	{
	  if (idesc->operands[!rsrc_write] == IA64_OPND_RR_R3)
	    {
	      int regno = CURR_SLOT.opnd[!rsrc_write].X_add_number - REG_GR;
	      if (regno >= 0 && regno < NELEMS (gr_values)
		  && KNOWN (regno))
		{
		  specs[count] = tmpl;
		  specs[count++].index = (gr_values[regno].value >> 61) & 0x7;
		}
	      else
		{
		  specs[count] = tmpl;
		  specs[count++].specific = 0;
		}
	    }
	}
      else if (note == 0 && !rsrc_write)
	{
	  specs[count] = tmpl;
	  specs[count++].specific = 0;
	}
      else
	{
	  UNHANDLED;
	}
      break;

    case IA64_RS_CR_IRR:
      if (note == 0)
	{
	  /* handle mov-from-CR-IVR; it's a read that writes CR[IRR] */
	  int regno = CURR_SLOT.opnd[1].X_add_number - REG_CR;
	  if (rsrc_write
	      && idesc->operands[1] == IA64_OPND_CR3
	      && regno == CR_IVR)
	    {
	      for (i = 0; i < 4; i++)
		{
		  specs[count] = tmpl;
		  specs[count++].index = CR_IRR0 + i;
		}
	    }
	}
      else if (note == 1)
	{
	  int regno = CURR_SLOT.opnd[!rsrc_write].X_add_number - REG_CR;
	  if (idesc->operands[!rsrc_write] == IA64_OPND_CR3
	      && regno >= CR_IRR0
	      && regno <= CR_IRR3)
	    {
	      specs[count] = tmpl;
	      specs[count++].index = regno;
	    }
	}
      else
	{
	  UNHANDLED;
	}
      break;

    case IA64_RS_CR_IIB:
      if (note != 0)
	{
	  UNHANDLED;
	}
      else
	{
	  int regno = CURR_SLOT.opnd[!rsrc_write].X_add_number - REG_CR;
	  if (idesc->operands[!rsrc_write] == IA64_OPND_CR3
	      && (regno == CR_IIB0 || regno == CR_IIB1))
	    {
	      specs[count] = tmpl;
	      specs[count++].index = regno;
	    }
	}
      break;

    case IA64_RS_CR_LRR:
      if (note != 1)
	{
	  UNHANDLED;
	}
      else
	{
	  int regno = CURR_SLOT.opnd[!rsrc_write].X_add_number - REG_CR;
	  if (idesc->operands[!rsrc_write] == IA64_OPND_CR3
	      && (regno == CR_LRR0 || regno == CR_LRR1))
	    {
	      specs[count] = tmpl;
	      specs[count++].index = regno;
	    }
	}
      break;

    case IA64_RS_CR:
      if (note == 1)
	{
	  if (idesc->operands[!rsrc_write] == IA64_OPND_CR3)
	    {
	      specs[count] = tmpl;
	      specs[count++].index =
		CURR_SLOT.opnd[!rsrc_write].X_add_number - REG_CR;
	    }
	}
      else
	{
	  UNHANDLED;
	}
      break;

    case IA64_RS_DAHR:
      if (note == 0)
	{
	  if (idesc->operands[!rsrc_write] == IA64_OPND_DAHR3)
	    {
	      specs[count] = tmpl;
	      specs[count++].index =
		CURR_SLOT.opnd[!rsrc_write].X_add_number - REG_DAHR;
	    }
	}
      else
	{
	  UNHANDLED;
	}
      break;

    case IA64_RS_FR:
    case IA64_RS_FRb:
      if (note != 1)
	{
	  UNHANDLED;
	}
      else if (rsrc_write)
	{
	  if (dep->specifier == IA64_RS_FRb
	      && idesc->operands[0] == IA64_OPND_F1)
	    {
	      specs[count] = tmpl;
	      specs[count++].index = CURR_SLOT.opnd[0].X_add_number - REG_FR;
	    }
	}
      else
	{
	  for (i = idesc->num_outputs; i < NELEMS (idesc->operands); i++)
	    {
	      if (idesc->operands[i] == IA64_OPND_F2
		  || idesc->operands[i] == IA64_OPND_F3
		  || idesc->operands[i] == IA64_OPND_F4)
		{
		  specs[count] = tmpl;
		  specs[count++].index =
		    CURR_SLOT.opnd[i].X_add_number - REG_FR;
		}
	    }
	}
      break;

    case IA64_RS_GR:
      if (note == 13)
	{
	  /* This reference applies only to the GR whose value is loaded with
	     data returned from memory.  */
	  specs[count] = tmpl;
	  specs[count++].index = CURR_SLOT.opnd[0].X_add_number - REG_GR;
	}
      else if (note == 1)
	{
	  if (rsrc_write)
	    {
	      for (i = 0; i < idesc->num_outputs; i++)
		if (idesc->operands[i] == IA64_OPND_R1
		    || idesc->operands[i] == IA64_OPND_R2
		    || idesc->operands[i] == IA64_OPND_R3)
		  {
		    specs[count] = tmpl;
		    specs[count++].index =
		      CURR_SLOT.opnd[i].X_add_number - REG_GR;
		  }
	      if (idesc->flags & IA64_OPCODE_POSTINC)
		for (i = 0; i < NELEMS (idesc->operands); i++)
		  if (idesc->operands[i] == IA64_OPND_MR3)
		    {
		      specs[count] = tmpl;
		      specs[count++].index =
			CURR_SLOT.opnd[i].X_add_number - REG_GR;
		    }
	    }
	  else
	    {
	      /* Look for anything that reads a GR.  */
	      for (i = 0; i < NELEMS (idesc->operands); i++)
		{
		  if (idesc->operands[i] == IA64_OPND_MR3
		      || idesc->operands[i] == IA64_OPND_CPUID_R3
		      || idesc->operands[i] == IA64_OPND_DBR_R3
		      || idesc->operands[i] == IA64_OPND_IBR_R3
		      || idesc->operands[i] == IA64_OPND_MSR_R3
		      || idesc->operands[i] == IA64_OPND_PKR_R3
		      || idesc->operands[i] == IA64_OPND_PMC_R3
		      || idesc->operands[i] == IA64_OPND_PMD_R3
		      || idesc->operands[i] == IA64_OPND_DAHR_R3
		      || idesc->operands[i] == IA64_OPND_RR_R3
		      || ((i >= idesc->num_outputs)
			  && (idesc->operands[i] == IA64_OPND_R1
			      || idesc->operands[i] == IA64_OPND_R2
			      || idesc->operands[i] == IA64_OPND_R3
			      /* addl source register.  */
			      || idesc->operands[i] == IA64_OPND_R3_2)))
		    {
		      specs[count] = tmpl;
		      specs[count++].index =
			CURR_SLOT.opnd[i].X_add_number - REG_GR;
		    }
		}
	    }
	}
      else
	{
	  UNHANDLED;
	}
      break;

      /* This is the same as IA64_RS_PRr, except that the register range is
	 from 1 - 15, and there are no rotating register reads/writes here.  */
    case IA64_RS_PR:
      if (note == 0)
	{
	  for (i = 1; i < 16; i++)
	    {
	      specs[count] = tmpl;
	      specs[count++].index = i;
	    }
	}
      else if (note == 7)
	{
	  valueT mask = 0;
	  /* Mark only those registers indicated by the mask.  */
	  if (rsrc_write)
	    {
	      mask = CURR_SLOT.opnd[2].X_add_number;
	      for (i = 1; i < 16; i++)
		if (mask & ((valueT) 1 << i))
		  {
		    specs[count] = tmpl;
		    specs[count++].index = i;
		  }
	    }
	  else
	    {
	      UNHANDLED;
	    }
	}
      else if (note == 11) /* note 11 implies note 1 as well */
	{
	  if (rsrc_write)
	    {
	      for (i = 0; i < idesc->num_outputs; i++)
		{
		  if (idesc->operands[i] == IA64_OPND_P1
		      || idesc->operands[i] == IA64_OPND_P2)
		    {
		      int regno = CURR_SLOT.opnd[i].X_add_number - REG_P;
		      if (regno >= 1 && regno < 16)
			{
			  specs[count] = tmpl;
			  specs[count++].index = regno;
			}
		    }
		}
	    }
	  else
	    {
	      UNHANDLED;
	    }
	}
      else if (note == 12)
	{
	  if (CURR_SLOT.qp_regno >= 1 && CURR_SLOT.qp_regno < 16)
	    {
	      specs[count] = tmpl;
	      specs[count++].index = CURR_SLOT.qp_regno;
	    }
	}
      else if (note == 1)
	{
	  if (rsrc_write)
	    {
	      int p1 = CURR_SLOT.opnd[0].X_add_number - REG_P;
	      int p2 = CURR_SLOT.opnd[1].X_add_number - REG_P;
	      int or_andcm = strstr (idesc->name, "or.andcm") != NULL;
	      int and_orcm = strstr (idesc->name, "and.orcm") != NULL;

	      if ((idesc->operands[0] == IA64_OPND_P1
		   || idesc->operands[0] == IA64_OPND_P2)
		  && p1 >= 1 && p1 < 16)
		{
		  specs[count] = tmpl;
		  specs[count].cmp_type =
		    (or_andcm ? CMP_OR : (and_orcm ? CMP_AND : CMP_NONE));
		  specs[count++].index = p1;
		}
	      if ((idesc->operands[1] == IA64_OPND_P1
		   || idesc->operands[1] == IA64_OPND_P2)
		  && p2 >= 1 && p2 < 16)
		{
		  specs[count] = tmpl;
		  specs[count].cmp_type =
		    (or_andcm ? CMP_AND : (and_orcm ? CMP_OR : CMP_NONE));
		  specs[count++].index = p2;
		}
	    }
	  else
	    {
	      if (CURR_SLOT.qp_regno >= 1 && CURR_SLOT.qp_regno < 16)
		{
		  specs[count] = tmpl;
		  specs[count++].index = CURR_SLOT.qp_regno;
		}
	      if (idesc->operands[1] == IA64_OPND_PR)
		{
		  for (i = 1; i < 16; i++)
		    {
		      specs[count] = tmpl;
		      specs[count++].index = i;
		    }
		}
	    }
	}
      else
	{
	  UNHANDLED;
	}
      break;

      /* This is the general case for PRs.  IA64_RS_PR and IA64_RS_PR63 are
	 simplified cases of this.  */
    case IA64_RS_PRr:
      if (note == 0)
	{
	  for (i = 16; i < 63; i++)
	    {
	      specs[count] = tmpl;
	      specs[count++].index = i;
	    }
	}
      else if (note == 7)
	{
	  valueT mask = 0;
	  /* Mark only those registers indicated by the mask.  */
	  if (rsrc_write
	      && idesc->operands[0] == IA64_OPND_PR)
	    {
	      mask = CURR_SLOT.opnd[2].X_add_number;
	      if (mask & ((valueT) 1 << 16))
		for (i = 16; i < 63; i++)
		  {
		    specs[count] = tmpl;
		    specs[count++].index = i;
		  }
	    }
	  else if (rsrc_write
		   && idesc->operands[0] == IA64_OPND_PR_ROT)
	    {
	      for (i = 16; i < 63; i++)
		{
		  specs[count] = tmpl;
		  specs[count++].index = i;
		}
	    }
	  else
	    {
	      UNHANDLED;
	    }
	}
      else if (note == 11) /* note 11 implies note 1 as well */
	{
	  if (rsrc_write)
	    {
	      for (i = 0; i < idesc->num_outputs; i++)
		{
		  if (idesc->operands[i] == IA64_OPND_P1
		      || idesc->operands[i] == IA64_OPND_P2)
		    {
		      int regno = CURR_SLOT.opnd[i].X_add_number - REG_P;
		      if (regno >= 16 && regno < 63)
			{
			  specs[count] = tmpl;
			  specs[count++].index = regno;
			}
		    }
		}
	    }
	  else
	    {
	      UNHANDLED;
	    }
	}
      else if (note == 12)
	{
	  if (CURR_SLOT.qp_regno >= 16 && CURR_SLOT.qp_regno < 63)
	    {
	      specs[count] = tmpl;
	      specs[count++].index = CURR_SLOT.qp_regno;
	    }
	}
      else if (note == 1)
	{
	  if (rsrc_write)
	    {
	      int p1 = CURR_SLOT.opnd[0].X_add_number - REG_P;
	      int p2 = CURR_SLOT.opnd[1].X_add_number - REG_P;
	      int or_andcm = strstr (idesc->name, "or.andcm") != NULL;
	      int and_orcm = strstr (idesc->name, "and.orcm") != NULL;

	      if ((idesc->operands[0] == IA64_OPND_P1
		   || idesc->operands[0] == IA64_OPND_P2)
		  && p1 >= 16 && p1 < 63)
		{
		  specs[count] = tmpl;
		  specs[count].cmp_type =
		    (or_andcm ? CMP_OR : (and_orcm ? CMP_AND : CMP_NONE));
		  specs[count++].index = p1;
		}
	      if ((idesc->operands[1] == IA64_OPND_P1
		   || idesc->operands[1] == IA64_OPND_P2)
		  && p2 >= 16 && p2 < 63)
		{
		  specs[count] = tmpl;
		  specs[count].cmp_type =
		    (or_andcm ? CMP_AND : (and_orcm ? CMP_OR : CMP_NONE));
		  specs[count++].index = p2;
		}
	    }
	  else
	    {
	      if (CURR_SLOT.qp_regno >= 16 && CURR_SLOT.qp_regno < 63)
		{
		  specs[count] = tmpl;
		  specs[count++].index = CURR_SLOT.qp_regno;
		}
	      if (idesc->operands[1] == IA64_OPND_PR)
		{
		  for (i = 16; i < 63; i++)
		    {
		      specs[count] = tmpl;
		      specs[count++].index = i;
		    }
		}
	    }
	}
      else
	{
	  UNHANDLED;
	}
      break;

    case IA64_RS_PSR:
      /* Verify that the instruction is using the PSR bit indicated in
	 dep->regindex.  */
      if (note == 0)
	{
	  if (idesc->operands[!rsrc_write] == IA64_OPND_PSR_UM)
	    {
	      if (dep->regindex < 6)
		{
		  specs[count++] = tmpl;
		}
	    }
	  else if (idesc->operands[!rsrc_write] == IA64_OPND_PSR)
	    {
	      if (dep->regindex < 32
		  || dep->regindex == 35
		  || dep->regindex == 36
		  || (!rsrc_write && dep->regindex == PSR_CPL))
		{
		  specs[count++] = tmpl;
		}
	    }
	  else if (idesc->operands[!rsrc_write] == IA64_OPND_PSR_L)
	    {
	      if (dep->regindex < 32
		  || dep->regindex == 35
		  || dep->regindex == 36
		  || (rsrc_write && dep->regindex == PSR_CPL))
		{
		  specs[count++] = tmpl;
		}
	    }
	  else
	    {
	      /* Several PSR bits have very specific dependencies.  */
	      switch (dep->regindex)
		{
		default:
		  specs[count++] = tmpl;
		  break;
		case PSR_IC:
		  if (rsrc_write)
		    {
		      specs[count++] = tmpl;
		    }
		  else
		    {
		      /* Only certain CR accesses use PSR.ic */
		      if (idesc->operands[0] == IA64_OPND_CR3
			  || idesc->operands[1] == IA64_OPND_CR3)
			{
			  int reg_index =
			    ((idesc->operands[0] == IA64_OPND_CR3)
			     ? 0 : 1);
			  int regno =
			    CURR_SLOT.opnd[reg_index].X_add_number - REG_CR;

			  switch (regno)
			    {
			    default:
			      break;
			    case CR_ITIR:
			    case CR_IFS:
			    case CR_IIM:
			    case CR_IIP:
			    case CR_IPSR:
			    case CR_ISR:
			    case CR_IFA:
			    case CR_IHA:
			    case CR_IIB0:
			    case CR_IIB1:
			    case CR_IIPA:
			      specs[count++] = tmpl;
			      break;
			    }
			}
		    }
		  break;
		case PSR_CPL:
		  if (rsrc_write)
		    {
		      specs[count++] = tmpl;
		    }
		  else
		    {
		      /* Only some AR accesses use cpl */
		      if (idesc->operands[0] == IA64_OPND_AR3
			  || idesc->operands[1] == IA64_OPND_AR3)
			{
			  int reg_index =
			    ((idesc->operands[0] == IA64_OPND_AR3)
			     ? 0 : 1);
			  int regno =
			    CURR_SLOT.opnd[reg_index].X_add_number - REG_AR;

			  if (regno == AR_ITC
			      || regno == AR_RUC
			      || (reg_index == 0
				  && (regno == AR_RSC
				      || (regno >= AR_K0
					  && regno <= AR_K7))))
			    {
			      specs[count++] = tmpl;
			    }
			}
		      else
			{
			  specs[count++] = tmpl;
			}
		      break;
		    }
		}
	    }
	}
      else if (note == 7)
	{
	  valueT mask = 0;
	  if (idesc->operands[0] == IA64_OPND_IMMU24)
	    {
	      mask = CURR_SLOT.opnd[0].X_add_number;
	    }
	  else
	    {
	      UNHANDLED;
	    }
	  if (mask & ((valueT) 1 << dep->regindex))
	    {
	      specs[count++] = tmpl;
	    }
	}
      else if (note == 8)
	{
	  int min = dep->regindex == PSR_DFL ? 2 : 32;
	  int max = dep->regindex == PSR_DFL ? 31 : 127;
	  /* dfh is read on FR32-127; dfl is read on FR2-31 */
	  for (i = 0; i < NELEMS (idesc->operands); i++)
	    {
	      if (idesc->operands[i] == IA64_OPND_F1
		  || idesc->operands[i] == IA64_OPND_F2
		  || idesc->operands[i] == IA64_OPND_F3
		  || idesc->operands[i] == IA64_OPND_F4)
		{
		  int reg = CURR_SLOT.opnd[i].X_add_number - REG_FR;
		  if (reg >= min && reg <= max)
		    {
		      specs[count++] = tmpl;
		    }
		}
	    }
	}
      else if (note == 9)
	{
	  int min = dep->regindex == PSR_MFL ? 2 : 32;
	  int max = dep->regindex == PSR_MFL ? 31 : 127;
	  /* mfh is read on writes to FR32-127; mfl is read on writes to
	     FR2-31 */
	  for (i = 0; i < idesc->num_outputs; i++)
	    {
	      if (idesc->operands[i] == IA64_OPND_F1)
		{
		  int reg = CURR_SLOT.opnd[i].X_add_number - REG_FR;
		  if (reg >= min && reg <= max)
		    {
		      specs[count++] = tmpl;
		    }
		}
	    }
	}
      else if (note == 10)
	{
	  for (i = 0; i < NELEMS (idesc->operands); i++)
	    {
	      if (idesc->operands[i] == IA64_OPND_R1
		  || idesc->operands[i] == IA64_OPND_R2
		  || idesc->operands[i] == IA64_OPND_R3)
		{
		  int regno = CURR_SLOT.opnd[i].X_add_number - REG_GR;
		  if (regno >= 16 && regno <= 31)
		    {
		      specs[count++] = tmpl;
		    }
		}
	    }
	}
      else
	{
	  UNHANDLED;
	}
      break;

    case IA64_RS_AR_FPSR:
      if (idesc->operands[!rsrc_write] == IA64_OPND_AR3)
	{
	  int regno = CURR_SLOT.opnd[!rsrc_write].X_add_number - REG_AR;
	  if (regno == AR_FPSR)
	    {
	      specs[count++] = tmpl;
	    }
	}
      else
	{
	  specs[count++] = tmpl;
	}
      break;

    case IA64_RS_ARX:
      /* Handle all AR[REG] resources */
      if (note == 0 || note == 1)
	{
	  int regno = CURR_SLOT.opnd[!rsrc_write].X_add_number - REG_AR;
	  if (idesc->operands[!rsrc_write] == IA64_OPND_AR3
	      && regno == dep->regindex)
	    {
	      specs[count++] = tmpl;
	    }
	  /* other AR[REG] resources may be affected by AR accesses */
	  else if (idesc->operands[0] == IA64_OPND_AR3)
	    {
	      /* AR[] writes */
	      regno = CURR_SLOT.opnd[0].X_add_number - REG_AR;
	      switch (dep->regindex)
		{
		default:
		  break;
		case AR_BSP:
		case AR_RNAT:
		  if (regno == AR_BSPSTORE)
		    {
		      specs[count++] = tmpl;
		    }
		case AR_RSC:
		  if (!rsrc_write &&
		      (regno == AR_BSPSTORE
		       || regno == AR_RNAT))
		    {
		      specs[count++] = tmpl;
		    }
		  break;
		}
	    }
	  else if (idesc->operands[1] == IA64_OPND_AR3)
	    {
	      /* AR[] reads */
	      regno = CURR_SLOT.opnd[1].X_add_number - REG_AR;
	      switch (dep->regindex)
		{
		default:
		  break;
		case AR_RSC:
		  if (regno == AR_BSPSTORE || regno == AR_RNAT)
		    {
		      specs[count++] = tmpl;
		    }
		  break;
		}
	    }
	  else
	    {
	      specs[count++] = tmpl;
	    }
	}
      else
	{
	  UNHANDLED;
	}
      break;

    case IA64_RS_CRX:
      /* Handle all CR[REG] resources.
	 ??? FIXME: The rule 17 isn't really handled correctly.   */
      if (note == 0 || note == 1 || note == 17)
	{
	  if (idesc->operands[!rsrc_write] == IA64_OPND_CR3)
	    {
	      int regno = CURR_SLOT.opnd[!rsrc_write].X_add_number - REG_CR;
	      if (regno == dep->regindex)
		{
		  specs[count++] = tmpl;
		}
	      else if (!rsrc_write)
		{
		  /* Reads from CR[IVR] affect other resources.  */
		  if (regno == CR_IVR)
		    {
		      if ((dep->regindex >= CR_IRR0
			   && dep->regindex <= CR_IRR3)
			  || dep->regindex == CR_TPR)
			{
			  specs[count++] = tmpl;
			}
		    }
		}
	    }
	  else
	    {
	      specs[count++] = tmpl;
	    }
	}
      else
	{
	  UNHANDLED;
	}
      break;

    case IA64_RS_INSERVICE:
      /* look for write of EOI (67) or read of IVR (65) */
      if ((idesc->operands[0] == IA64_OPND_CR3
	   && CURR_SLOT.opnd[0].X_add_number - REG_CR == CR_EOI)
	  || (idesc->operands[1] == IA64_OPND_CR3
	      && CURR_SLOT.opnd[1].X_add_number - REG_CR == CR_IVR))
	{
	  specs[count++] = tmpl;
	}
      break;

    case IA64_RS_GR0:
      if (note == 1)
	{
	  specs[count++] = tmpl;
	}
      else
	{
	  UNHANDLED;
	}
      break;

    case IA64_RS_CFM:
      if (note != 2)
	{
	  specs[count++] = tmpl;
	}
      else
	{
	  /* Check if any of the registers accessed are in the rotating region.
	     mov to/from pr accesses CFM only when qp_regno is in the rotating
	     region */
	  for (i = 0; i < NELEMS (idesc->operands); i++)
	    {
	      if (idesc->operands[i] == IA64_OPND_R1
		  || idesc->operands[i] == IA64_OPND_R2
		  || idesc->operands[i] == IA64_OPND_R3)
		{
		  int num = CURR_SLOT.opnd[i].X_add_number - REG_GR;
		  /* Assumes that md.rot.num_regs is always valid */
		  if (md.rot.num_regs > 0
		      && num > 31
		      && num < 31 + md.rot.num_regs)
		    {
		      specs[count] = tmpl;
		      specs[count++].specific = 0;
		    }
		}
	      else if (idesc->operands[i] == IA64_OPND_F1
		       || idesc->operands[i] == IA64_OPND_F2
		       || idesc->operands[i] == IA64_OPND_F3
		       || idesc->operands[i] == IA64_OPND_F4)
		{
		  int num = CURR_SLOT.opnd[i].X_add_number - REG_FR;
		  if (num > 31)
		    {
		      specs[count] = tmpl;
		      specs[count++].specific = 0;
		    }
		}
	      else if (idesc->operands[i] == IA64_OPND_P1
		       || idesc->operands[i] == IA64_OPND_P2)
		{
		  int num = CURR_SLOT.opnd[i].X_add_number - REG_P;
		  if (num > 15)
		    {
		      specs[count] = tmpl;
		      specs[count++].specific = 0;
		    }
		}
	    }
	  if (CURR_SLOT.qp_regno > 15)
	    {
	      specs[count] = tmpl;
	      specs[count++].specific = 0;
	    }
	}
      break;

      /* This is the same as IA64_RS_PRr, except simplified to account for
	 the fact that there is only one register.  */
    case IA64_RS_PR63:
      if (note == 0)
	{
	  specs[count++] = tmpl;
	}
      else if (note == 7)
	{
	  valueT mask = 0;
	  if (idesc->operands[2] == IA64_OPND_IMM17)
	    mask = CURR_SLOT.opnd[2].X_add_number;
	  if (mask & ((valueT) 1 << 63))
	    specs[count++] = tmpl;
	}
      else if (note == 11)
	{
	  if ((idesc->operands[0] == IA64_OPND_P1
	       && CURR_SLOT.opnd[0].X_add_number - REG_P == 63)
	      || (idesc->operands[1] == IA64_OPND_P2
		  && CURR_SLOT.opnd[1].X_add_number - REG_P == 63))
	    {
	      specs[count++] = tmpl;
	    }
	}
      else if (note == 12)
	{
	  if (CURR_SLOT.qp_regno == 63)
	    {
	      specs[count++] = tmpl;
	    }
	}
      else if (note == 1)
	{
	  if (rsrc_write)
	    {
	      int p1 = CURR_SLOT.opnd[0].X_add_number - REG_P;
	      int p2 = CURR_SLOT.opnd[1].X_add_number - REG_P;
	      int or_andcm = strstr (idesc->name, "or.andcm") != NULL;
	      int and_orcm = strstr (idesc->name, "and.orcm") != NULL;

	      if (p1 == 63
		  && (idesc->operands[0] == IA64_OPND_P1
		      || idesc->operands[0] == IA64_OPND_P2))
		{
		  specs[count] = tmpl;
		  specs[count++].cmp_type =
		    (or_andcm ? CMP_OR : (and_orcm ? CMP_AND : CMP_NONE));
		}
	      if (p2 == 63
		  && (idesc->operands[1] == IA64_OPND_P1
		      || idesc->operands[1] == IA64_OPND_P2))
		{
		  specs[count] = tmpl;
		  specs[count++].cmp_type =
		    (or_andcm ? CMP_AND : (and_orcm ? CMP_OR : CMP_NONE));
		}
	    }
	  else
	    {
	      if (CURR_SLOT.qp_regno == 63)
		{
		  specs[count++] = tmpl;
		}
	    }
	}
      else
	{
	  UNHANDLED;
	}
      break;

    case IA64_RS_RSE:
      /* FIXME we can identify some individual RSE written resources, but RSE
	 read resources have not yet been completely identified, so for now
	 treat RSE as a single resource */
      if (strncmp (idesc->name, "mov", 3) == 0)
	{
	  if (rsrc_write)
	    {
	      if (idesc->operands[0] == IA64_OPND_AR3
		  && CURR_SLOT.opnd[0].X_add_number - REG_AR == AR_BSPSTORE)
		{
		  specs[count++] = tmpl;
		}
	    }
	  else
	    {
	      if (idesc->operands[0] == IA64_OPND_AR3)
		{
		  if (CURR_SLOT.opnd[0].X_add_number - REG_AR == AR_BSPSTORE
		      || CURR_SLOT.opnd[0].X_add_number - REG_AR == AR_RNAT)
		    {
		      specs[count++] = tmpl;
		    }
		}
	      else if (idesc->operands[1] == IA64_OPND_AR3)
		{
		  if (CURR_SLOT.opnd[1].X_add_number - REG_AR == AR_BSP
		      || CURR_SLOT.opnd[1].X_add_number - REG_AR == AR_BSPSTORE
		      || CURR_SLOT.opnd[1].X_add_number - REG_AR == AR_RNAT)
		    {
		      specs[count++] = tmpl;
		    }
		}
	    }
	}
      else
	{
	  specs[count++] = tmpl;
	}
      break;

    case IA64_RS_ANY:
      /* FIXME -- do any of these need to be non-specific? */
      specs[count++] = tmpl;
      break;

    default:
      as_bad (_("Unrecognized dependency specifier %d\n"), dep->specifier);
      break;
    }

  return count;
}

/* Clear branch flags on marked resources.  This breaks the link between the
   QP of the marking instruction and a subsequent branch on the same QP.  */

static void
clear_qp_branch_flag (valueT mask)
{
  int i;
  for (i = 0; i < regdepslen; i++)
    {
      valueT bit = ((valueT) 1 << regdeps[i].qp_regno);
      if ((bit & mask) != 0)
	{
	  regdeps[i].link_to_qp_branch = 0;
	}
    }
}

/* MASK contains 2 and only 2 PRs which are mutually exclusive.  Remove
   any mutexes which contain one of the PRs and create new ones when
   needed.  */

static int
update_qp_mutex (valueT mask)
{
  int i;
  int add = 0;

  i = 0;
  while (i < qp_mutexeslen)
    {
      if ((qp_mutexes[i].prmask & mask) != 0)
	{
	  /* If it destroys and creates the same mutex, do nothing.  */
	  if (qp_mutexes[i].prmask == mask
	      && qp_mutexes[i].path == md.path)
	    {
	      i++;
	      add = -1;
	    }
	  else
	    {
	      int keep = 0;

	      if (md.debug_dv)
		{
		  fprintf (stderr, "  Clearing mutex relation");
		  print_prmask (qp_mutexes[i].prmask);
		  fprintf (stderr, "\n");
		}
	      
	      /* Deal with the old mutex with more than 3+ PRs only if
		 the new mutex on the same execution path with it.

		 FIXME: The 3+ mutex support is incomplete.
		 dot_pred_rel () may be a better place to fix it.  */
	      if (qp_mutexes[i].path == md.path)
		{
		  /* If it is a proper subset of the mutex, create a
		     new mutex.  */
		  if (add == 0
		      && (qp_mutexes[i].prmask & mask) == mask)
		    add = 1;
		  
		  qp_mutexes[i].prmask &= ~mask;
		  if (qp_mutexes[i].prmask & (qp_mutexes[i].prmask - 1))
		    {
		      /* Modify the mutex if there are more than one
			 PR left.  */
		      keep = 1;
		      i++;
		    }
		}
	      
	      if (keep == 0)
		/* Remove the mutex.  */
		qp_mutexes[i] = qp_mutexes[--qp_mutexeslen];
	    }
	}
      else
	++i;
    }

  if (add == 1)
    add_qp_mutex (mask);

  return add;
}

/* Remove any mutexes which contain any of the PRs indicated in the mask.

   Any changes to a PR clears the mutex relations which include that PR.  */

static void
clear_qp_mutex (valueT mask)
{
  int i;

  i = 0;
  while (i < qp_mutexeslen)
    {
      if ((qp_mutexes[i].prmask & mask) != 0)
	{
	  if (md.debug_dv)
	    {
	      fprintf (stderr, "  Clearing mutex relation");
	      print_prmask (qp_mutexes[i].prmask);
	      fprintf (stderr, "\n");
	    }
	  qp_mutexes[i] = qp_mutexes[--qp_mutexeslen];
	}
      else
	++i;
    }
}

/* Clear implies relations which contain PRs in the given masks.
   P1_MASK indicates the source of the implies relation, while P2_MASK
   indicates the implied PR.  */

static void
clear_qp_implies (valueT p1_mask, valueT p2_mask)
{
  int i;

  i = 0;
  while (i < qp_implieslen)
    {
      if ((((valueT) 1 << qp_implies[i].p1) & p1_mask) != 0
	  || (((valueT) 1 << qp_implies[i].p2) & p2_mask) != 0)
	{
	  if (md.debug_dv)
	    fprintf (stderr, "Clearing implied relation PR%d->PR%d\n",
		     qp_implies[i].p1, qp_implies[i].p2);
	  qp_implies[i] = qp_implies[--qp_implieslen];
	}
      else
	++i;
    }
}

/* Add the PRs specified to the list of implied relations.  */

static void
add_qp_imply (int p1, int p2)
{
  valueT mask;
  valueT bit;
  int i;

  /* p0 is not meaningful here.  */
  if (p1 == 0 || p2 == 0)
    abort ();

  if (p1 == p2)
    return;

  /* If it exists already, ignore it.  */
  for (i = 0; i < qp_implieslen; i++)
    {
      if (qp_implies[i].p1 == p1
	  && qp_implies[i].p2 == p2
	  && qp_implies[i].path == md.path
	  && !qp_implies[i].p2_branched)
	return;
    }

  if (qp_implieslen == qp_impliestotlen)
    {
      qp_impliestotlen += 20;
      qp_implies = (struct qp_imply *)
	xrealloc ((void *) qp_implies,
		  qp_impliestotlen * sizeof (struct qp_imply));
    }
  if (md.debug_dv)
    fprintf (stderr, "  Registering PR%d implies PR%d\n", p1, p2);
  qp_implies[qp_implieslen].p1 = p1;
  qp_implies[qp_implieslen].p2 = p2;
  qp_implies[qp_implieslen].path = md.path;
  qp_implies[qp_implieslen++].p2_branched = 0;

  /* Add in the implied transitive relations; for everything that p2 implies,
     make p1 imply that, too; for everything that implies p1, make it imply p2
     as well.  */
  for (i = 0; i < qp_implieslen; i++)
    {
      if (qp_implies[i].p1 == p2)
	add_qp_imply (p1, qp_implies[i].p2);
      if (qp_implies[i].p2 == p1)
	add_qp_imply (qp_implies[i].p1, p2);
    }
  /* Add in mutex relations implied by this implies relation; for each mutex
     relation containing p2, duplicate it and replace p2 with p1.  */
  bit = (valueT) 1 << p1;
  mask = (valueT) 1 << p2;
  for (i = 0; i < qp_mutexeslen; i++)
    {
      if (qp_mutexes[i].prmask & mask)
	add_qp_mutex ((qp_mutexes[i].prmask & ~mask) | bit);
    }
}

/* Add the PRs specified in the mask to the mutex list; this means that only
   one of the PRs can be true at any time.  PR0 should never be included in
   the mask.  */

static void
add_qp_mutex (valueT mask)
{
  if (mask & 0x1)
    abort ();

  if (qp_mutexeslen == qp_mutexestotlen)
    {
      qp_mutexestotlen += 20;
      qp_mutexes = (struct qpmutex *)
	xrealloc ((void *) qp_mutexes,
		  qp_mutexestotlen * sizeof (struct qpmutex));
    }
  if (md.debug_dv)
    {
      fprintf (stderr, "  Registering mutex on");
      print_prmask (mask);
      fprintf (stderr, "\n");
    }
  qp_mutexes[qp_mutexeslen].path = md.path;
  qp_mutexes[qp_mutexeslen++].prmask = mask;
}

static int
has_suffix_p (const char *name, const char *suffix)
{
  size_t namelen = strlen (name);
  size_t sufflen = strlen (suffix);

  if (namelen <= sufflen)
    return 0;
  return strcmp (name + namelen - sufflen, suffix) == 0;
}

static void
clear_register_values (void)
{
  int i;
  if (md.debug_dv)
    fprintf (stderr, "  Clearing register values\n");
  for (i = 1; i < NELEMS (gr_values); i++)
    gr_values[i].known = 0;
}

/* Keep track of register values/changes which affect DV tracking.

   optimization note: should add a flag to classes of insns where otherwise we
   have to examine a group of strings to identify them.  */

static void
note_register_values (struct ia64_opcode *idesc)
{
  valueT qp_changemask = 0;
  int i;

  /* Invalidate values for registers being written to.  */
  for (i = 0; i < idesc->num_outputs; i++)
    {
      if (idesc->operands[i] == IA64_OPND_R1
	  || idesc->operands[i] == IA64_OPND_R2
	  || idesc->operands[i] == IA64_OPND_R3)
	{
	  int regno = CURR_SLOT.opnd[i].X_add_number - REG_GR;
	  if (regno > 0 && regno < NELEMS (gr_values))
	    gr_values[regno].known = 0;
	}
      else if (idesc->operands[i] == IA64_OPND_R3_2)
	{
	  int regno = CURR_SLOT.opnd[i].X_add_number - REG_GR;
	  if (regno > 0 && regno < 4)
	    gr_values[regno].known = 0;
	}
      else if (idesc->operands[i] == IA64_OPND_P1
	       || idesc->operands[i] == IA64_OPND_P2)
	{
	  int regno = CURR_SLOT.opnd[i].X_add_number - REG_P;
	  qp_changemask |= (valueT) 1 << regno;
	}
      else if (idesc->operands[i] == IA64_OPND_PR)
	{
	  if (idesc->operands[2] & (valueT) 0x10000)
	    qp_changemask = ~(valueT) 0x1FFFF | idesc->operands[2];
	  else
	    qp_changemask = idesc->operands[2];
	  break;
	}
      else if (idesc->operands[i] == IA64_OPND_PR_ROT)
	{
	  if (idesc->operands[1] & ((valueT) 1 << 43))
	    qp_changemask = -((valueT) 1 << 44) | idesc->operands[1];
	  else
	    qp_changemask = idesc->operands[1];
	  qp_changemask &= ~(valueT) 0xFFFF;
	  break;
	}
    }

  /* Always clear qp branch flags on any PR change.  */
  /* FIXME there may be exceptions for certain compares.  */
  clear_qp_branch_flag (qp_changemask);

  /* Invalidate rotating registers on insns which affect RRBs in CFM.  */
  if (idesc->flags & IA64_OPCODE_MOD_RRBS)
    {
      qp_changemask |= ~(valueT) 0xFFFF;
      if (strcmp (idesc->name, "clrrrb.pr") != 0)
	{
	  for (i = 32; i < 32 + md.rot.num_regs; i++)
	    gr_values[i].known = 0;
	}
      clear_qp_mutex (qp_changemask);
      clear_qp_implies (qp_changemask, qp_changemask);
    }
  /* After a call, all register values are undefined, except those marked
     as "safe".  */
  else if (strncmp (idesc->name, "br.call", 6) == 0
	   || strncmp (idesc->name, "brl.call", 7) == 0)
    {
      /* FIXME keep GR values which are marked as "safe_across_calls"  */
      clear_register_values ();
      clear_qp_mutex (~qp_safe_across_calls);
      clear_qp_implies (~qp_safe_across_calls, ~qp_safe_across_calls);
      clear_qp_branch_flag (~qp_safe_across_calls);
    }
  else if (is_interruption_or_rfi (idesc)
	   || is_taken_branch (idesc))
    {
      clear_register_values ();
      clear_qp_mutex (~(valueT) 0);
      clear_qp_implies (~(valueT) 0, ~(valueT) 0);
    }
  /* Look for mutex and implies relations.  */
  else if ((idesc->operands[0] == IA64_OPND_P1
	    || idesc->operands[0] == IA64_OPND_P2)
	   && (idesc->operands[1] == IA64_OPND_P1
	       || idesc->operands[1] == IA64_OPND_P2))
    {
      int p1 = CURR_SLOT.opnd[0].X_add_number - REG_P;
      int p2 = CURR_SLOT.opnd[1].X_add_number - REG_P;
      valueT p1mask = (p1 != 0) ? (valueT) 1 << p1 : 0;
      valueT p2mask = (p2 != 0) ? (valueT) 1 << p2 : 0;

      /* If both PRs are PR0, we can't really do anything.  */
      if (p1 == 0 && p2 == 0)
	{
	  if (md.debug_dv)
	    fprintf (stderr, "  Ignoring PRs due to inclusion of p0\n");
	}
      /* In general, clear mutexes and implies which include P1 or P2,
	 with the following exceptions.  */
      else if (has_suffix_p (idesc->name, ".or.andcm")
	       || has_suffix_p (idesc->name, ".and.orcm"))
	{
	  clear_qp_implies (p2mask, p1mask);
	}
      else if (has_suffix_p (idesc->name, ".andcm")
	       || has_suffix_p (idesc->name, ".and"))
	{
	  clear_qp_implies (0, p1mask | p2mask);
	}
      else if (has_suffix_p (idesc->name, ".orcm")
	       || has_suffix_p (idesc->name, ".or"))
	{
	  clear_qp_mutex (p1mask | p2mask);
	  clear_qp_implies (p1mask | p2mask, 0);
	}
      else
	{
	  int added = 0;

	  clear_qp_implies (p1mask | p2mask, p1mask | p2mask);

	  /* If one of the PRs is PR0, we call clear_qp_mutex.  */
	  if (p1 == 0 || p2 == 0)
	    clear_qp_mutex (p1mask | p2mask);
	  else
	    added = update_qp_mutex (p1mask | p2mask);

	  if (CURR_SLOT.qp_regno == 0
	      || has_suffix_p (idesc->name, ".unc"))
	    {
	      if (added == 0 && p1 && p2)
		add_qp_mutex (p1mask | p2mask);
	      if (CURR_SLOT.qp_regno != 0)
		{
		  if (p1)
		    add_qp_imply (p1, CURR_SLOT.qp_regno);
		  if (p2)
		    add_qp_imply (p2, CURR_SLOT.qp_regno);
		}
	    }
	}
    }
  /* Look for mov imm insns into GRs.  */
  else if (idesc->operands[0] == IA64_OPND_R1
	   && (idesc->operands[1] == IA64_OPND_IMM22
	       || idesc->operands[1] == IA64_OPND_IMMU64)
	   && CURR_SLOT.opnd[1].X_op == O_constant
	   && (strcmp (idesc->name, "mov") == 0
	       || strcmp (idesc->name, "movl") == 0))
    {
      int regno = CURR_SLOT.opnd[0].X_add_number - REG_GR;
      if (regno > 0 && regno < NELEMS (gr_values))
	{
	  gr_values[regno].known = 1;
	  gr_values[regno].value = CURR_SLOT.opnd[1].X_add_number;
	  gr_values[regno].path = md.path;
	  if (md.debug_dv)
	    {
	      fprintf (stderr, "  Know gr%d = ", regno);
	      fprintf_vma (stderr, gr_values[regno].value);
	      fputs ("\n", stderr);
	    }
	}
    }
  /* Look for dep.z imm insns.  */
  else if (idesc->operands[0] == IA64_OPND_R1
	   && idesc->operands[1] == IA64_OPND_IMM8
	   && strcmp (idesc->name, "dep.z") == 0)
    {
      int regno = CURR_SLOT.opnd[0].X_add_number - REG_GR;
      if (regno > 0 && regno < NELEMS (gr_values))
	{
	  valueT value = CURR_SLOT.opnd[1].X_add_number;

	  if (CURR_SLOT.opnd[3].X_add_number < 64)
	    value &= ((valueT)1 << CURR_SLOT.opnd[3].X_add_number) - 1;
	  value <<= CURR_SLOT.opnd[2].X_add_number;
	  gr_values[regno].known = 1;
	  gr_values[regno].value = value;
	  gr_values[regno].path = md.path;
	  if (md.debug_dv)
	    {
	      fprintf (stderr, "  Know gr%d = ", regno);
	      fprintf_vma (stderr, gr_values[regno].value);
	      fputs ("\n", stderr);
	    }
	}
    }
  else
    {
      clear_qp_mutex (qp_changemask);
      clear_qp_implies (qp_changemask, qp_changemask);
    }
}

/* Return whether the given predicate registers are currently mutex.  */

static int
qp_mutex (int p1, int p2, int path)
{
  int i;
  valueT mask;

  if (p1 != p2)
    {
      mask = ((valueT) 1 << p1) | (valueT) 1 << p2;
      for (i = 0; i < qp_mutexeslen; i++)
	{
	  if (qp_mutexes[i].path >= path
	      && (qp_mutexes[i].prmask & mask) == mask)
	    return 1;
	}
    }
  return 0;
}

/* Return whether the given resource is in the given insn's list of chks
   Return 1 if the conflict is absolutely determined, 2 if it's a potential
   conflict.  */

static int
resources_match (struct rsrc *rs,
		 struct ia64_opcode *idesc,
		 int note,
		 int qp_regno,
		 int path)
{
  struct rsrc specs[MAX_SPECS];
  int count;

  /* If the marked resource's qp_regno and the given qp_regno are mutex,
     we don't need to check.  One exception is note 11, which indicates that
     target predicates are written regardless of PR[qp].  */
  if (qp_mutex (rs->qp_regno, qp_regno, path)
      && note != 11)
    return 0;

  count = specify_resource (rs->dependency, idesc, DV_CHK, specs, note, path);
  while (count-- > 0)
    {
      /* UNAT checking is a bit more specific than other resources */
      if (rs->dependency->specifier == IA64_RS_AR_UNAT
	  && specs[count].mem_offset.hint
	  && rs->mem_offset.hint)
	{
	  if (rs->mem_offset.base == specs[count].mem_offset.base)
	    {
	      if (((rs->mem_offset.offset >> 3) & 0x3F) ==
		  ((specs[count].mem_offset.offset >> 3) & 0x3F))
		return 1;
	      else
		continue;
	    }
	}

      /* Skip apparent PR write conflicts where both writes are an AND or both
	 writes are an OR.  */
      if (rs->dependency->specifier == IA64_RS_PR
	  || rs->dependency->specifier == IA64_RS_PRr
	  || rs->dependency->specifier == IA64_RS_PR63)
	{
	  if (specs[count].cmp_type != CMP_NONE
	      && specs[count].cmp_type == rs->cmp_type)
	    {
	      if (md.debug_dv)
		fprintf (stderr, "  %s on parallel compare allowed (PR%d)\n",
			 dv_mode[rs->dependency->mode],
			 rs->dependency->specifier != IA64_RS_PR63 ?
			 specs[count].index : 63);
	      continue;
	    }
	  if (md.debug_dv)
	    fprintf (stderr,
		     "  %s on parallel compare conflict %s vs %s on PR%d\n",
		     dv_mode[rs->dependency->mode],
		     dv_cmp_type[rs->cmp_type],
		     dv_cmp_type[specs[count].cmp_type],
		     rs->dependency->specifier != IA64_RS_PR63 ?
		     specs[count].index : 63);

	}

      /* If either resource is not specific, conservatively assume a conflict
       */
      if (!specs[count].specific || !rs->specific)
	return 2;
      else if (specs[count].index == rs->index)
	return 1;
    }

  return 0;
}

/* Indicate an instruction group break; if INSERT_STOP is non-zero, then
   insert a stop to create the break.  Update all resource dependencies
   appropriately.  If QP_REGNO is non-zero, only apply the break to resources
   which use the same QP_REGNO and have the link_to_qp_branch flag set.
   If SAVE_CURRENT is non-zero, don't affect resources marked by the current
   instruction.  */

static void
insn_group_break (int insert_stop, int qp_regno, int save_current)
{
  int i;

  if (insert_stop && md.num_slots_in_use > 0)
    PREV_SLOT.end_of_insn_group = 1;

  if (md.debug_dv)
    {
      fprintf (stderr, "  Insn group break%s",
	       (insert_stop ? " (w/stop)" : ""));
      if (qp_regno != 0)
	fprintf (stderr, " effective for QP=%d", qp_regno);
      fprintf (stderr, "\n");
    }

  i = 0;
  while (i < regdepslen)
    {
      const struct ia64_dependency *dep = regdeps[i].dependency;

      if (qp_regno != 0
	  && regdeps[i].qp_regno != qp_regno)
	{
	  ++i;
	  continue;
	}

      if (save_current
	  && CURR_SLOT.src_file == regdeps[i].file
	  && CURR_SLOT.src_line == regdeps[i].line)
	{
	  ++i;
	  continue;
	}

      /* clear dependencies which are automatically cleared by a stop, or
	 those that have reached the appropriate state of insn serialization */
      if (dep->semantics == IA64_DVS_IMPLIED
	  || dep->semantics == IA64_DVS_IMPLIEDF
	  || regdeps[i].insn_srlz == STATE_SRLZ)
	{
	  print_dependency ("Removing", i);
	  regdeps[i] = regdeps[--regdepslen];
	}
      else
	{
	  if (dep->semantics == IA64_DVS_DATA
	      || dep->semantics == IA64_DVS_INSTR
	      || dep->semantics == IA64_DVS_SPECIFIC)
	    {
	      if (regdeps[i].insn_srlz == STATE_NONE)
		regdeps[i].insn_srlz = STATE_STOP;
	      if (regdeps[i].data_srlz == STATE_NONE)
		regdeps[i].data_srlz = STATE_STOP;
	    }
	  ++i;
	}
    }
}

/* Add the given resource usage spec to the list of active dependencies.  */

static void
mark_resource (struct ia64_opcode *idesc ATTRIBUTE_UNUSED,
	       const struct ia64_dependency *dep ATTRIBUTE_UNUSED,
	       struct rsrc *spec,
	       int depind,
	       int path)
{
  if (regdepslen == regdepstotlen)
    {
      regdepstotlen += 20;
      regdeps = (struct rsrc *)
	xrealloc ((void *) regdeps,
		  regdepstotlen * sizeof (struct rsrc));
    }

  regdeps[regdepslen] = *spec;
  regdeps[regdepslen].depind = depind;
  regdeps[regdepslen].path = path;
  regdeps[regdepslen].file = CURR_SLOT.src_file;
  regdeps[regdepslen].line = CURR_SLOT.src_line;

  print_dependency ("Adding", regdepslen);

  ++regdepslen;
}

static void
print_dependency (const char *action, int depind)
{
  if (md.debug_dv)
    {
      fprintf (stderr, "  %s %s '%s'",
	       action, dv_mode[(regdeps[depind].dependency)->mode],
	       (regdeps[depind].dependency)->name);
      if (regdeps[depind].specific && regdeps[depind].index >= 0)
	fprintf (stderr, " (%d)", regdeps[depind].index);
      if (regdeps[depind].mem_offset.hint)
	{
	  fputs (" ", stderr);
	  fprintf_vma (stderr, regdeps[depind].mem_offset.base);
	  fputs ("+", stderr);
	  fprintf_vma (stderr, regdeps[depind].mem_offset.offset);
	}
      fprintf (stderr, "\n");
    }
}

static void
instruction_serialization (void)
{
  int i;
  if (md.debug_dv)
    fprintf (stderr, "  Instruction serialization\n");
  for (i = 0; i < regdepslen; i++)
    if (regdeps[i].insn_srlz == STATE_STOP)
      regdeps[i].insn_srlz = STATE_SRLZ;
}

static void
data_serialization (void)
{
  int i = 0;
  if (md.debug_dv)
    fprintf (stderr, "  Data serialization\n");
  while (i < regdepslen)
    {
      if (regdeps[i].data_srlz == STATE_STOP
	  /* Note: as of 991210, all "other" dependencies are cleared by a
	     data serialization.  This might change with new tables */
	  || (regdeps[i].dependency)->semantics == IA64_DVS_OTHER)
	{
	  print_dependency ("Removing", i);
	  regdeps[i] = regdeps[--regdepslen];
	}
      else
	++i;
    }
}

/* Insert stops and serializations as needed to avoid DVs.  */

static void
remove_marked_resource (struct rsrc *rs)
{
  switch (rs->dependency->semantics)
    {
    case IA64_DVS_SPECIFIC:
      if (md.debug_dv)
	fprintf (stderr, "Implementation-specific, assume worst case...\n");
      /* ...fall through...  */
    case IA64_DVS_INSTR:
      if (md.debug_dv)
	fprintf (stderr, "Inserting instr serialization\n");
      if (rs->insn_srlz < STATE_STOP)
	insn_group_break (1, 0, 0);
      if (rs->insn_srlz < STATE_SRLZ)
	{
	  struct slot oldslot = CURR_SLOT;
	  /* Manually jam a srlz.i insn into the stream */
	  memset (&CURR_SLOT, 0, sizeof (CURR_SLOT));
	  CURR_SLOT.user_template = -1;
	  CURR_SLOT.idesc = ia64_find_opcode ("srlz.i");
	  instruction_serialization ();
	  md.curr_slot = (md.curr_slot + 1) % NUM_SLOTS;
	  if (++md.num_slots_in_use >= NUM_SLOTS)
	    emit_one_bundle ();
	  CURR_SLOT = oldslot;
	}
      insn_group_break (1, 0, 0);
      break;
    case IA64_DVS_OTHER: /* as of rev2 (991220) of the DV tables, all
			    "other" types of DV are eliminated
			    by a data serialization */
    case IA64_DVS_DATA:
      if (md.debug_dv)
	fprintf (stderr, "Inserting data serialization\n");
      if (rs->data_srlz < STATE_STOP)
	insn_group_break (1, 0, 0);
      {
	struct slot oldslot = CURR_SLOT;
	/* Manually jam a srlz.d insn into the stream */
	memset (&CURR_SLOT, 0, sizeof (CURR_SLOT));
	CURR_SLOT.user_template = -1;
	CURR_SLOT.idesc = ia64_find_opcode ("srlz.d");
	data_serialization ();
	md.curr_slot = (md.curr_slot + 1) % NUM_SLOTS;
	if (++md.num_slots_in_use >= NUM_SLOTS)
	  emit_one_bundle ();
	CURR_SLOT = oldslot;
      }
      break;
    case IA64_DVS_IMPLIED:
    case IA64_DVS_IMPLIEDF:
      if (md.debug_dv)
	fprintf (stderr, "Inserting stop\n");
      insn_group_break (1, 0, 0);
      break;
    default:
      break;
    }
}

/* Check the resources used by the given opcode against the current dependency
   list.

   The check is run once for each execution path encountered.  In this case,
   a unique execution path is the sequence of instructions following a code
   entry point, e.g. the following has three execution paths, one starting
   at L0, one at L1, and one at L2.

   L0:     nop
   L1:     add
   L2:     add
   br.ret
*/

static void
check_dependencies (struct ia64_opcode *idesc)
{
  const struct ia64_opcode_dependency *opdeps = idesc->dependencies;
  int path;
  int i;

  /* Note that the number of marked resources may change within the
     loop if in auto mode.  */
  i = 0;
  while (i < regdepslen)
    {
      struct rsrc *rs = &regdeps[i];
      const struct ia64_dependency *dep = rs->dependency;
      int chkind;
      int note;
      int start_over = 0;

      if (dep->semantics == IA64_DVS_NONE
	  || (chkind = depends_on (rs->depind, idesc)) == -1)
	{
	  ++i;
	  continue;
	}

      note = NOTE (opdeps->chks[chkind]);

      /* Check this resource against each execution path seen thus far.  */
      for (path = 0; path <= md.path; path++)
	{
	  int matchtype;

	  /* If the dependency wasn't on the path being checked, ignore it.  */
	  if (rs->path < path)
	    continue;

	  /* If the QP for this insn implies a QP which has branched, don't
	     bother checking.  Ed. NOTE: I don't think this check is terribly
	     useful; what's the point of generating code which will only be
	     reached if its QP is zero?
	     This code was specifically inserted to handle the following code,
	     based on notes from Intel's DV checking code, where p1 implies p2.

		  mov r4 = 2
	     (p2) br.cond L
	     (p1) mov r4 = 7
	  */
	  if (CURR_SLOT.qp_regno != 0)
	    {
	      int skip = 0;
	      int implies;
	      for (implies = 0; implies < qp_implieslen; implies++)
		{
		  if (qp_implies[implies].path >= path
		      && qp_implies[implies].p1 == CURR_SLOT.qp_regno
		      && qp_implies[implies].p2_branched)
		    {
		      skip = 1;
		      break;
		    }
		}
	      if (skip)
		continue;
	    }

	  if ((matchtype = resources_match (rs, idesc, note,
					    CURR_SLOT.qp_regno, path)) != 0)
	    {
	      char msg[1024];
	      char pathmsg[256] = "";
	      char indexmsg[256] = "";
	      int certain = (matchtype == 1 && CURR_SLOT.qp_regno == 0);

	      if (path != 0)
		snprintf (pathmsg, sizeof (pathmsg),
			  " when entry is at label '%s'",
			 md.entry_labels[path - 1]);
	      if (matchtype == 1 && rs->index >= 0)
		snprintf (indexmsg, sizeof (indexmsg),
			  ", specific resource number is %d",
			 rs->index);
	      snprintf (msg, sizeof (msg),
			"Use of '%s' %s %s dependency '%s' (%s)%s%s",
		       idesc->name,
		       (certain ? "violates" : "may violate"),
		       dv_mode[dep->mode], dep->name,
		       dv_sem[dep->semantics],
		       pathmsg, indexmsg);

	      if (md.explicit_mode)
		{
		  as_warn ("%s", msg);
		  if (path < md.path)
		    as_warn (_("Only the first path encountering the conflict is reported"));
		  as_warn_where (rs->file, rs->line,
				 _("This is the location of the conflicting usage"));
		  /* Don't bother checking other paths, to avoid duplicating
		     the same warning */
		  break;
		}
	      else
		{
		  if (md.debug_dv)
		    fprintf (stderr, "%s @@ %s:%d\n", msg, rs->file, rs->line);

		  remove_marked_resource (rs);

		  /* since the set of dependencies has changed, start over */
		  /* FIXME -- since we're removing dvs as we go, we
		     probably don't really need to start over...  */
		  start_over = 1;
		  break;
		}
	    }
	}
      if (start_over)
	i = 0;
      else
	++i;
    }
}

/* Register new dependencies based on the given opcode.  */

static void
mark_resources (struct ia64_opcode *idesc)
{
  int i;
  const struct ia64_opcode_dependency *opdeps = idesc->dependencies;
  int add_only_qp_reads = 0;

  /* A conditional branch only uses its resources if it is taken; if it is
     taken, we stop following that path.  The other branch types effectively
     *always* write their resources.  If it's not taken, register only QP
     reads.  */
  if (is_conditional_branch (idesc) || is_interruption_or_rfi (idesc))
    {
      add_only_qp_reads = 1;
    }

  if (md.debug_dv)
    fprintf (stderr, "Registering '%s' resource usage\n", idesc->name);

  for (i = 0; i < opdeps->nregs; i++)
    {
      const struct ia64_dependency *dep;
      struct rsrc specs[MAX_SPECS];
      int note;
      int path;
      int count;

      dep = ia64_find_dependency (opdeps->regs[i]);
      note = NOTE (opdeps->regs[i]);

      if (add_only_qp_reads
	  && !(dep->mode == IA64_DV_WAR
	       && (dep->specifier == IA64_RS_PR
		   || dep->specifier == IA64_RS_PRr
		   || dep->specifier == IA64_RS_PR63)))
	continue;

      count = specify_resource (dep, idesc, DV_REG, specs, note, md.path);

      while (count-- > 0)
	{
	  mark_resource (idesc, dep, &specs[count],
			 DEP (opdeps->regs[i]), md.path);
	}

      /* The execution path may affect register values, which may in turn
	 affect which indirect-access resources are accessed.  */
      switch (dep->specifier)
	{
	default:
	  break;
	case IA64_RS_CPUID:
	case IA64_RS_DBR:
	case IA64_RS_IBR:
	case IA64_RS_MSR:
	case IA64_RS_PKR:
	case IA64_RS_PMC:
	case IA64_RS_PMD:
	case IA64_RS_RR:
	  for (path = 0; path < md.path; path++)
	    {
	      count = specify_resource (dep, idesc, DV_REG, specs, note, path);
	      while (count-- > 0)
		mark_resource (idesc, dep, &specs[count],
			       DEP (opdeps->regs[i]), path);
	    }
	  break;
	}
    }
}

/* Remove dependencies when they no longer apply.  */

static void
update_dependencies (struct ia64_opcode *idesc)
{
  int i;

  if (strcmp (idesc->name, "srlz.i") == 0)
    {
      instruction_serialization ();
    }
  else if (strcmp (idesc->name, "srlz.d") == 0)
    {
      data_serialization ();
    }
  else if (is_interruption_or_rfi (idesc)
	   || is_taken_branch (idesc))
    {
      /* Although technically the taken branch doesn't clear dependencies
	 which require a srlz.[id], we don't follow the branch; the next
	 instruction is assumed to start with a clean slate.  */
      regdepslen = 0;
      md.path = 0;
    }
  else if (is_conditional_branch (idesc)
	   && CURR_SLOT.qp_regno != 0)
    {
      int is_call = strstr (idesc->name, ".call") != NULL;

      for (i = 0; i < qp_implieslen; i++)
	{
	  /* If the conditional branch's predicate is implied by the predicate
	     in an existing dependency, remove that dependency.  */
	  if (qp_implies[i].p2 == CURR_SLOT.qp_regno)
	    {
	      int depind = 0;
	      /* Note that this implied predicate takes a branch so that if
		 a later insn generates a DV but its predicate implies this
		 one, we can avoid the false DV warning.  */
	      qp_implies[i].p2_branched = 1;
	      while (depind < regdepslen)
		{
		  if (regdeps[depind].qp_regno == qp_implies[i].p1)
		    {
		      print_dependency ("Removing", depind);
		      regdeps[depind] = regdeps[--regdepslen];
		    }
		  else
		    ++depind;
		}
	    }
	}
      /* Any marked resources which have this same predicate should be
	 cleared, provided that the QP hasn't been modified between the
	 marking instruction and the branch.  */
      if (is_call)
	{
	  insn_group_break (0, CURR_SLOT.qp_regno, 1);
	}
      else
	{
	  i = 0;
	  while (i < regdepslen)
	    {
	      if (regdeps[i].qp_regno == CURR_SLOT.qp_regno
		  && regdeps[i].link_to_qp_branch
		  && (regdeps[i].file != CURR_SLOT.src_file
		      || regdeps[i].line != CURR_SLOT.src_line))
		{
		  /* Treat like a taken branch */
		  print_dependency ("Removing", i);
		  regdeps[i] = regdeps[--regdepslen];
		}
	      else
		++i;
	    }
	}
    }
}

/* Examine the current instruction for dependency violations.  */

static int
check_dv (struct ia64_opcode *idesc)
{
  if (md.debug_dv)
    {
      fprintf (stderr, "Checking %s for violations (line %d, %d/%d)\n",
	       idesc->name, CURR_SLOT.src_line,
	       idesc->dependencies->nchks,
	       idesc->dependencies->nregs);
    }

  /* Look through the list of currently marked resources; if the current
     instruction has the dependency in its chks list which uses that resource,
     check against the specific resources used.  */
  check_dependencies (idesc);

  /* Look up the instruction's regdeps (RAW writes, WAW writes, and WAR reads),
     then add them to the list of marked resources.  */
  mark_resources (idesc);

  /* There are several types of dependency semantics, and each has its own
     requirements for being cleared

     Instruction serialization (insns separated by interruption, rfi, or
     writer + srlz.i + reader, all in separate groups) clears DVS_INSTR.

     Data serialization (instruction serialization, or writer + srlz.d +
     reader, where writer and srlz.d are in separate groups) clears
     DVS_DATA. (This also clears DVS_OTHER, but that is not guaranteed to
     always be the case).

     Instruction group break (groups separated by stop, taken branch,
     interruption or rfi) clears DVS_IMPLIED and DVS_IMPLIEDF.
   */
  update_dependencies (idesc);

  /* Sometimes, knowing a register value allows us to avoid giving a false DV
     warning.  Keep track of as many as possible that are useful.  */
  note_register_values (idesc);

  /* We don't need or want this anymore.  */
  md.mem_offset.hint = 0;

  return 0;
}

/* Translate one line of assembly.  Pseudo ops and labels do not show
   here.  */
void
md_assemble (char *str)
{
  char *saved_input_line_pointer, *mnemonic;
  const struct pseudo_opcode *pdesc;
  struct ia64_opcode *idesc;
  unsigned char qp_regno;
  unsigned int flags;
  int ch;

  saved_input_line_pointer = input_line_pointer;
  input_line_pointer = str;

  /* extract the opcode (mnemonic):  */

  mnemonic = input_line_pointer;
  ch = get_symbol_end ();
  pdesc = (struct pseudo_opcode *) hash_find (md.pseudo_hash, mnemonic);
  if (pdesc)
    {
      *input_line_pointer = ch;
      (*pdesc->handler) (pdesc->arg);
      goto done;
    }

  /* Find the instruction descriptor matching the arguments.  */

  idesc = ia64_find_opcode (mnemonic);
  *input_line_pointer = ch;
  if (!idesc)
    {
      as_bad (_("Unknown opcode `%s'"), mnemonic);
      goto done;
    }

  idesc = parse_operands (idesc);
  if (!idesc)
    goto done;

  /* Handle the dynamic ops we can handle now:  */
  if (idesc->type == IA64_TYPE_DYN)
    {
      if (strcmp (idesc->name, "add") == 0)
	{
	  if (CURR_SLOT.opnd[2].X_op == O_register
	      && CURR_SLOT.opnd[2].X_add_number < 4)
	    mnemonic = "addl";
	  else
	    mnemonic = "adds";
	  ia64_free_opcode (idesc);
	  idesc = ia64_find_opcode (mnemonic);
	}
      else if (strcmp (idesc->name, "mov") == 0)
	{
	  enum ia64_opnd opnd1, opnd2;
	  int rop;

	  opnd1 = idesc->operands[0];
	  opnd2 = idesc->operands[1];
	  if (opnd1 == IA64_OPND_AR3)
	    rop = 0;
	  else if (opnd2 == IA64_OPND_AR3)
	    rop = 1;
	  else
	    abort ();
	  if (CURR_SLOT.opnd[rop].X_op == O_register)
	    {
	      if (ar_is_only_in_integer_unit (CURR_SLOT.opnd[rop].X_add_number))
		mnemonic = "mov.i";
	      else if (ar_is_only_in_memory_unit (CURR_SLOT.opnd[rop].X_add_number))
		mnemonic = "mov.m";
	      else
		rop = -1;
	    }
	  else
	    abort ();
	  if (rop >= 0)
	    {
	      ia64_free_opcode (idesc);
	      idesc = ia64_find_opcode (mnemonic);
	      while (idesc != NULL
		     && (idesc->operands[0] != opnd1
			 || idesc->operands[1] != opnd2))
		idesc = get_next_opcode (idesc);
	    }
	}
    }
  else if (strcmp (idesc->name, "mov.i") == 0
	   || strcmp (idesc->name, "mov.m") == 0)
    {
      enum ia64_opnd opnd1, opnd2;
      int rop;
      
      opnd1 = idesc->operands[0];
      opnd2 = idesc->operands[1];
      if (opnd1 == IA64_OPND_AR3)
	rop = 0;
      else if (opnd2 == IA64_OPND_AR3)
	rop = 1;
      else
	abort ();
      if (CURR_SLOT.opnd[rop].X_op == O_register)
	{
	  char unit = 'a';
	  if (ar_is_only_in_integer_unit (CURR_SLOT.opnd[rop].X_add_number))
	    unit = 'i';
	  else if (ar_is_only_in_memory_unit (CURR_SLOT.opnd[rop].X_add_number))
	    unit = 'm';
	  if (unit != 'a' && unit != idesc->name [4])
	    as_bad (_("AR %d can only be accessed by %c-unit"),
		    (int) (CURR_SLOT.opnd[rop].X_add_number - REG_AR),
		    TOUPPER (unit));
	}
    }
  else if (strcmp (idesc->name, "hint.b") == 0)
    {
      switch (md.hint_b)
	{
	case hint_b_ok:
	  break;
	case hint_b_warning:
	  as_warn (_("hint.b may be treated as nop"));
	  break;
	case hint_b_error:
	  as_bad (_("hint.b shouldn't be used"));
	  break;
	}
    }

  qp_regno = 0;
  if (md.qp.X_op == O_register)
    {
      qp_regno = md.qp.X_add_number - REG_P;
      md.qp.X_op = O_absent;
    }

  flags = idesc->flags;

  if ((flags & IA64_OPCODE_FIRST) != 0)
    {
      /* The alignment frag has to end with a stop bit only if the
	 next instruction after the alignment directive has to be
	 the first instruction in an instruction group.  */
      if (align_frag)
	{
	  while (align_frag->fr_type != rs_align_code)
	    {
	      align_frag = align_frag->fr_next;
	      if (!align_frag)
		break;
	    }
	  /* align_frag can be NULL if there are directives in
	     between.  */
	  if (align_frag && align_frag->fr_next == frag_now)
	    align_frag->tc_frag_data = 1;
	}

      insn_group_break (1, 0, 0);
    }
  align_frag = NULL;

  if ((flags & IA64_OPCODE_NO_PRED) != 0 && qp_regno != 0)
    {
      as_bad (_("`%s' cannot be predicated"), idesc->name);
      goto done;
    }

  /* Build the instruction.  */
  CURR_SLOT.qp_regno = qp_regno;
  CURR_SLOT.idesc = idesc;
  as_where (&CURR_SLOT.src_file, &CURR_SLOT.src_line);
  dwarf2_where (&CURR_SLOT.debug_line);
  dwarf2_consume_line_info ();

  /* Add unwind entries, if there are any.  */
  if (unwind.current_entry)
    {
      CURR_SLOT.unwind_record = unwind.current_entry;
      unwind.current_entry = NULL;
    }
  if (unwind.pending_saves)
    {
      if (unwind.pending_saves->next)
	{
	  /* Attach the next pending save to the next slot so that its
	     slot number will get set correctly.  */
	  add_unwind_entry (unwind.pending_saves->next, NOT_A_CHAR);
	  unwind.pending_saves = &unwind.pending_saves->next->r.record.p;
	}
      else
	unwind.pending_saves = NULL;
    }
  if (unwind.proc_pending.sym && S_IS_DEFINED (unwind.proc_pending.sym))
    unwind.insn = 1;

  /* Check for dependency violations.  */
  if (md.detect_dv)
    check_dv (idesc);

  md.curr_slot = (md.curr_slot + 1) % NUM_SLOTS;
  if (++md.num_slots_in_use >= NUM_SLOTS)
    emit_one_bundle ();

  if ((flags & IA64_OPCODE_LAST) != 0)
    insn_group_break (1, 0, 0);

  md.last_text_seg = now_seg;

 done:
  input_line_pointer = saved_input_line_pointer;
}

/* Called when symbol NAME cannot be found in the symbol table.
   Should be used for dynamic valued symbols only.  */

symbolS *
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
{
  return 0;
}

/* Called for any expression that can not be recognized.  When the
   function is called, `input_line_pointer' will point to the start of
   the expression.  */

void
md_operand (expressionS *e)
{
  switch (*input_line_pointer)
    {
    case '[':
      ++input_line_pointer;
      expression_and_evaluate (e);
      if (*input_line_pointer != ']')
	{
	  as_bad (_("Closing bracket missing"));
	  goto err;
	}
      else
	{
	  if (e->X_op != O_register
	      || e->X_add_number < REG_GR
	      || e->X_add_number > REG_GR + 127)
	    {
	      as_bad (_("Index must be a general register"));
	      e->X_add_number = REG_GR;
	    }

	  ++input_line_pointer;
	  e->X_op = O_index;
	}
      break;

    default:
      break;
    }
  return;

 err:
  ignore_rest_of_line ();
}

/* Return 1 if it's OK to adjust a reloc by replacing the symbol with
   a section symbol plus some offset.  For relocs involving @@fptr(),
   directives we don't want such adjustments since we need to have the
   original symbol's name in the reloc.  */
int
ia64_fix_adjustable (fixS *fix)
{
  /* Prevent all adjustments to global symbols */
  if (S_IS_EXTERNAL (fix->fx_addsy) || S_IS_WEAK (fix->fx_addsy))
    return 0;

  switch (fix->fx_r_type)
    {
    case BFD_RELOC_IA64_FPTR64I:
    case BFD_RELOC_IA64_FPTR32MSB:
    case BFD_RELOC_IA64_FPTR32LSB:
    case BFD_RELOC_IA64_FPTR64MSB:
    case BFD_RELOC_IA64_FPTR64LSB:
    case BFD_RELOC_IA64_LTOFF_FPTR22:
    case BFD_RELOC_IA64_LTOFF_FPTR64I:
      return 0;
    default:
      break;
    }

  return 1;
}

int
ia64_force_relocation (fixS *fix)
{
  switch (fix->fx_r_type)
    {
    case BFD_RELOC_IA64_FPTR64I:
    case BFD_RELOC_IA64_FPTR32MSB:
    case BFD_RELOC_IA64_FPTR32LSB:
    case BFD_RELOC_IA64_FPTR64MSB:
    case BFD_RELOC_IA64_FPTR64LSB:

    case BFD_RELOC_IA64_LTOFF22:
    case BFD_RELOC_IA64_LTOFF64I:
    case BFD_RELOC_IA64_LTOFF_FPTR22:
    case BFD_RELOC_IA64_LTOFF_FPTR64I:
    case BFD_RELOC_IA64_PLTOFF22:
    case BFD_RELOC_IA64_PLTOFF64I:
    case BFD_RELOC_IA64_PLTOFF64MSB:
    case BFD_RELOC_IA64_PLTOFF64LSB:

    case BFD_RELOC_IA64_LTOFF22X:
    case BFD_RELOC_IA64_LDXMOV:
      return 1;

    default:
      break;
    }

  return generic_force_reloc (fix);
}

/* Decide from what point a pc-relative relocation is relative to,
   relative to the pc-relative fixup.  Er, relatively speaking.  */
long
ia64_pcrel_from_section (fixS *fix, segT sec)
{
  unsigned long off = fix->fx_frag->fr_address + fix->fx_where;

  if (bfd_get_section_flags (stdoutput, sec) & SEC_CODE)
    off &= ~0xfUL;

  return off;
}


/* Used to emit section-relative relocs for the dwarf2 debug data.  */
void
ia64_dwarf2_emit_offset (symbolS *symbol, unsigned int size)
{
  expressionS exp;

  exp.X_op = O_pseudo_fixup;
  exp.X_op_symbol = pseudo_func[FUNC_SEC_RELATIVE].u.sym;
  exp.X_add_number = 0;
  exp.X_add_symbol = symbol;
  emit_expr (&exp, size);
}

/* This is called whenever some data item (not an instruction) needs a
   fixup.  We pick the right reloc code depending on the byteorder
   currently in effect.  */
void
ia64_cons_fix_new (fragS *f, int where, int nbytes, expressionS *exp)
{
  bfd_reloc_code_real_type code;
  fixS *fix;

  switch (nbytes)
    {
      /* There are no reloc for 8 and 16 bit quantities, but we allow
	 them here since they will work fine as long as the expression
	 is fully defined at the end of the pass over the source file.  */
    case 1: code = BFD_RELOC_8; break;
    case 2: code = BFD_RELOC_16; break;
    case 4:
      if (target_big_endian)
	code = BFD_RELOC_IA64_DIR32MSB;
      else
	code = BFD_RELOC_IA64_DIR32LSB;
      break;

    case 8:
      /* In 32-bit mode, data8 could mean function descriptors too.  */
      if (exp->X_op == O_pseudo_fixup
	  && exp->X_op_symbol
	  && S_GET_VALUE (exp->X_op_symbol) == FUNC_IPLT_RELOC
	  && !(md.flags & EF_IA_64_ABI64))
	{
	  if (target_big_endian)
	    code = BFD_RELOC_IA64_IPLTMSB;
	  else
	    code = BFD_RELOC_IA64_IPLTLSB;
	  exp->X_op = O_symbol;
	  break;
	}
      else
	{
	  if (target_big_endian)
	    code = BFD_RELOC_IA64_DIR64MSB;
	  else
	    code = BFD_RELOC_IA64_DIR64LSB;
	  break;
	}

    case 16:
      if (exp->X_op == O_pseudo_fixup
	  && exp->X_op_symbol
	  && S_GET_VALUE (exp->X_op_symbol) == FUNC_IPLT_RELOC)
	{
	  if (target_big_endian)
	    code = BFD_RELOC_IA64_IPLTMSB;
	  else
	    code = BFD_RELOC_IA64_IPLTLSB;
	  exp->X_op = O_symbol;
	  break;
	}
      /* FALLTHRU */

    default:
      as_bad (_("Unsupported fixup size %d"), nbytes);
      ignore_rest_of_line ();
      return;
    }

  if (exp->X_op == O_pseudo_fixup)
    {
      exp->X_op = O_symbol;
      code = ia64_gen_real_reloc_type (exp->X_op_symbol, code);
      /* ??? If code unchanged, unsupported.  */
    }

  fix = fix_new_exp (f, where, nbytes, exp, 0, code);
  /* We need to store the byte order in effect in case we're going
     to fix an 8 or 16 bit relocation (for which there no real
     relocs available).  See md_apply_fix().  */
  fix->tc_fix_data.bigendian = target_big_endian;
}

/* Return the actual relocation we wish to associate with the pseudo
   reloc described by SYM and R_TYPE.  SYM should be one of the
   symbols in the pseudo_func array, or NULL.  */

static bfd_reloc_code_real_type
ia64_gen_real_reloc_type (struct symbol *sym, bfd_reloc_code_real_type r_type)
{
  bfd_reloc_code_real_type newr = 0;
  const char *type = NULL, *suffix = "";

  if (sym == NULL)
    {
      return r_type;
    }

  switch (S_GET_VALUE (sym))
    {
    case FUNC_FPTR_RELATIVE:
      switch (r_type)
	{
	case BFD_RELOC_IA64_IMM64:	newr = BFD_RELOC_IA64_FPTR64I; break;
	case BFD_RELOC_IA64_DIR32MSB:	newr = BFD_RELOC_IA64_FPTR32MSB; break;
	case BFD_RELOC_IA64_DIR32LSB:	newr = BFD_RELOC_IA64_FPTR32LSB; break;
	case BFD_RELOC_IA64_DIR64MSB:	newr = BFD_RELOC_IA64_FPTR64MSB; break;
	case BFD_RELOC_IA64_DIR64LSB:	newr = BFD_RELOC_IA64_FPTR64LSB; break;
	default:			type = "FPTR"; break;
	}
      break;

    case FUNC_GP_RELATIVE:
      switch (r_type)
	{
	case BFD_RELOC_IA64_IMM22:	newr = BFD_RELOC_IA64_GPREL22; break;
	case BFD_RELOC_IA64_IMM64:	newr = BFD_RELOC_IA64_GPREL64I; break;
	case BFD_RELOC_IA64_DIR32MSB:	newr = BFD_RELOC_IA64_GPREL32MSB; break;
	case BFD_RELOC_IA64_DIR32LSB:	newr = BFD_RELOC_IA64_GPREL32LSB; break;
	case BFD_RELOC_IA64_DIR64MSB:	newr = BFD_RELOC_IA64_GPREL64MSB; break;
	case BFD_RELOC_IA64_DIR64LSB:	newr = BFD_RELOC_IA64_GPREL64LSB; break;
	default:			type = "GPREL"; break;
	}
      break;

    case FUNC_LT_RELATIVE:
      switch (r_type)
	{
	case BFD_RELOC_IA64_IMM22:	newr = BFD_RELOC_IA64_LTOFF22; break;
	case BFD_RELOC_IA64_IMM64:	newr = BFD_RELOC_IA64_LTOFF64I; break;
	default:			type = "LTOFF"; break;
	}
      break;

    case FUNC_LT_RELATIVE_X:
      switch (r_type)
	{
	case BFD_RELOC_IA64_IMM22:	newr = BFD_RELOC_IA64_LTOFF22X; break;
	default:			type = "LTOFF"; suffix = "X"; break;
	}
      break;

    case FUNC_PC_RELATIVE:
      switch (r_type)
	{
	case BFD_RELOC_IA64_IMM22:	newr = BFD_RELOC_IA64_PCREL22; break;
	case BFD_RELOC_IA64_IMM64:	newr = BFD_RELOC_IA64_PCREL64I; break;
	case BFD_RELOC_IA64_DIR32MSB:	newr = BFD_RELOC_IA64_PCREL32MSB; break;
	case BFD_RELOC_IA64_DIR32LSB:	newr = BFD_RELOC_IA64_PCREL32LSB; break;
	case BFD_RELOC_IA64_DIR64MSB:	newr = BFD_RELOC_IA64_PCREL64MSB; break;
	case BFD_RELOC_IA64_DIR64LSB:	newr = BFD_RELOC_IA64_PCREL64LSB; break;
	default:			type = "PCREL"; break;
	}
      break;

    case FUNC_PLT_RELATIVE:
      switch (r_type)
	{
	case BFD_RELOC_IA64_IMM22:	newr = BFD_RELOC_IA64_PLTOFF22; break;
	case BFD_RELOC_IA64_IMM64:	newr = BFD_RELOC_IA64_PLTOFF64I; break;
	case BFD_RELOC_IA64_DIR64MSB:	newr = BFD_RELOC_IA64_PLTOFF64MSB;break;
	case BFD_RELOC_IA64_DIR64LSB:	newr = BFD_RELOC_IA64_PLTOFF64LSB;break;
	default:			type = "PLTOFF"; break;
	}
      break;

    case FUNC_SEC_RELATIVE:
      switch (r_type)
	{
	case BFD_RELOC_IA64_DIR32MSB:	newr = BFD_RELOC_IA64_SECREL32MSB;break;
	case BFD_RELOC_IA64_DIR32LSB:	newr = BFD_RELOC_IA64_SECREL32LSB;break;
	case BFD_RELOC_IA64_DIR64MSB:	newr = BFD_RELOC_IA64_SECREL64MSB;break;
	case BFD_RELOC_IA64_DIR64LSB:	newr = BFD_RELOC_IA64_SECREL64LSB;break;
	default:			type = "SECREL"; break;
	}
      break;

    case FUNC_SEG_RELATIVE:
      switch (r_type)
	{
	case BFD_RELOC_IA64_DIR32MSB:	newr = BFD_RELOC_IA64_SEGREL32MSB;break;
	case BFD_RELOC_IA64_DIR32LSB:	newr = BFD_RELOC_IA64_SEGREL32LSB;break;
	case BFD_RELOC_IA64_DIR64MSB:	newr = BFD_RELOC_IA64_SEGREL64MSB;break;
	case BFD_RELOC_IA64_DIR64LSB:	newr = BFD_RELOC_IA64_SEGREL64LSB;break;
	default:			type = "SEGREL"; break;
	}
      break;

    case FUNC_LTV_RELATIVE:
      switch (r_type)
	{
	case BFD_RELOC_IA64_DIR32MSB:	newr = BFD_RELOC_IA64_LTV32MSB; break;
	case BFD_RELOC_IA64_DIR32LSB:	newr = BFD_RELOC_IA64_LTV32LSB; break;
	case BFD_RELOC_IA64_DIR64MSB:	newr = BFD_RELOC_IA64_LTV64MSB; break;
	case BFD_RELOC_IA64_DIR64LSB:	newr = BFD_RELOC_IA64_LTV64LSB; break;
	default:			type = "LTV"; break;
	}
      break;

    case FUNC_LT_FPTR_RELATIVE:
      switch (r_type)
	{
	case BFD_RELOC_IA64_IMM22:
	  newr = BFD_RELOC_IA64_LTOFF_FPTR22; break;
	case BFD_RELOC_IA64_IMM64:
	  newr = BFD_RELOC_IA64_LTOFF_FPTR64I; break;
	case BFD_RELOC_IA64_DIR32MSB:
	  newr = BFD_RELOC_IA64_LTOFF_FPTR32MSB; break;
	case BFD_RELOC_IA64_DIR32LSB:
	  newr = BFD_RELOC_IA64_LTOFF_FPTR32LSB; break;
	case BFD_RELOC_IA64_DIR64MSB:
	  newr = BFD_RELOC_IA64_LTOFF_FPTR64MSB; break;
	case BFD_RELOC_IA64_DIR64LSB:
	  newr = BFD_RELOC_IA64_LTOFF_FPTR64LSB; break;
	default:
	  type = "LTOFF_FPTR"; break;
	}
      break;

    case FUNC_TP_RELATIVE:
      switch (r_type)
	{
	case BFD_RELOC_IA64_IMM14:      newr = BFD_RELOC_IA64_TPREL14; break;
	case BFD_RELOC_IA64_IMM22:      newr = BFD_RELOC_IA64_TPREL22; break;
	case BFD_RELOC_IA64_IMM64:      newr = BFD_RELOC_IA64_TPREL64I; break;
	case BFD_RELOC_IA64_DIR64MSB:   newr = BFD_RELOC_IA64_TPREL64MSB; break;
	case BFD_RELOC_IA64_DIR64LSB:   newr = BFD_RELOC_IA64_TPREL64LSB; break;
	default:                        type = "TPREL"; break;
	}
      break;

    case FUNC_LT_TP_RELATIVE:
      switch (r_type)
	{
	case BFD_RELOC_IA64_IMM22:
	  newr = BFD_RELOC_IA64_LTOFF_TPREL22; break;
	default:
	  type = "LTOFF_TPREL"; break;
	}
      break;

    case FUNC_DTP_MODULE:
      switch (r_type)
	{
	case BFD_RELOC_IA64_DIR64MSB:
	  newr = BFD_RELOC_IA64_DTPMOD64MSB; break;
	case BFD_RELOC_IA64_DIR64LSB:
	  newr = BFD_RELOC_IA64_DTPMOD64LSB; break;
	default:
	  type = "DTPMOD"; break;
	}
      break;

    case FUNC_LT_DTP_MODULE:
      switch (r_type)
	{
	case BFD_RELOC_IA64_IMM22:
	  newr = BFD_RELOC_IA64_LTOFF_DTPMOD22; break;
	default:
	  type = "LTOFF_DTPMOD"; break;
	}
      break;

    case FUNC_DTP_RELATIVE:
      switch (r_type)
	{
	case BFD_RELOC_IA64_DIR32MSB:
	  newr = BFD_RELOC_IA64_DTPREL32MSB; break;
	case BFD_RELOC_IA64_DIR32LSB:
	  newr = BFD_RELOC_IA64_DTPREL32LSB; break;
	case BFD_RELOC_IA64_DIR64MSB:
	  newr = BFD_RELOC_IA64_DTPREL64MSB; break;
	case BFD_RELOC_IA64_DIR64LSB:
	  newr = BFD_RELOC_IA64_DTPREL64LSB; break;
	case BFD_RELOC_IA64_IMM14:
	  newr = BFD_RELOC_IA64_DTPREL14; break;
	case BFD_RELOC_IA64_IMM22:
	  newr = BFD_RELOC_IA64_DTPREL22; break;
	case BFD_RELOC_IA64_IMM64:
	  newr = BFD_RELOC_IA64_DTPREL64I; break;
	default:
	  type = "DTPREL"; break;
	}
      break;

    case FUNC_LT_DTP_RELATIVE:
      switch (r_type)
	{
	case BFD_RELOC_IA64_IMM22:
	  newr = BFD_RELOC_IA64_LTOFF_DTPREL22; break;
	default:
	  type = "LTOFF_DTPREL"; break;
	}
      break;

    case FUNC_IPLT_RELOC:
      switch (r_type)
	{
	case BFD_RELOC_IA64_IPLTMSB:    return r_type;
	case BFD_RELOC_IA64_IPLTLSB:    return r_type;
	default:                        type = "IPLT"; break;
	}
      break;

#ifdef TE_VMS
    case FUNC_SLOTCOUNT_RELOC:
      return DUMMY_RELOC_IA64_SLOTCOUNT;
#endif

    default:
      abort ();
    }

  if (newr)
    return newr;
  else
    {
      int width;

      if (!type)
	abort ();
      switch (r_type)
	{
	case BFD_RELOC_IA64_DIR32MSB: width = 32; suffix = "MSB"; break;
	case BFD_RELOC_IA64_DIR32LSB: width = 32; suffix = "LSB"; break;
	case BFD_RELOC_IA64_DIR64MSB: width = 64; suffix = "MSB"; break;
	case BFD_RELOC_IA64_DIR64LSB: width = 64; suffix = "LSB"; break;
	case BFD_RELOC_UNUSED:        width = 13; break;
	case BFD_RELOC_IA64_IMM14:    width = 14; break;
	case BFD_RELOC_IA64_IMM22:    width = 22; break;
	case BFD_RELOC_IA64_IMM64:    width = 64; suffix = "I"; break;
	default:                      abort ();
	}

      /* This should be an error, but since previously there wasn't any
	 diagnostic here, don't make it fail because of this for now.  */
      as_warn (_("Cannot express %s%d%s relocation"), type, width, suffix);
      return r_type;
    }
}

/* Here is where generate the appropriate reloc for pseudo relocation
   functions.  */
void
ia64_validate_fix (fixS *fix)
{
  switch (fix->fx_r_type)
    {
    case BFD_RELOC_IA64_FPTR64I:
    case BFD_RELOC_IA64_FPTR32MSB:
    case BFD_RELOC_IA64_FPTR64LSB:
    case BFD_RELOC_IA64_LTOFF_FPTR22:
    case BFD_RELOC_IA64_LTOFF_FPTR64I:
      if (fix->fx_offset != 0)
	as_bad_where (fix->fx_file, fix->fx_line,
		      _("No addend allowed in @@fptr() relocation"));
      break;
    default:
      break;
    }
}

static void
fix_insn (fixS *fix, const struct ia64_operand *odesc, valueT value)
{
  bfd_vma insn[3], t0, t1, control_bits;
  const char *err;
  char *fixpos;
  long slot;

  slot = fix->fx_where & 0x3;
  fixpos = fix->fx_frag->fr_literal + (fix->fx_where - slot);

  /* Bundles are always in little-endian byte order */
  t0 = bfd_getl64 (fixpos);
  t1 = bfd_getl64 (fixpos + 8);
  control_bits = t0 & 0x1f;
  insn[0] = (t0 >>  5) & 0x1ffffffffffLL;
  insn[1] = ((t0 >> 46) & 0x3ffff) | ((t1 & 0x7fffff) << 18);
  insn[2] = (t1 >> 23) & 0x1ffffffffffLL;

  err = NULL;
  if (odesc - elf64_ia64_operands == IA64_OPND_IMMU64)
    {
      insn[1] = (value >> 22) & 0x1ffffffffffLL;
      insn[2] |= (((value & 0x7f) << 13)
		  | (((value >> 7) & 0x1ff) << 27)
		  | (((value >> 16) & 0x1f) << 22)
		  | (((value >> 21) & 0x1) << 21)
		  | (((value >> 63) & 0x1) << 36));
    }
  else if (odesc - elf64_ia64_operands == IA64_OPND_IMMU62)
    {
      if (value & ~0x3fffffffffffffffULL)
	err = _("integer operand out of range");
      insn[1] = (value >> 21) & 0x1ffffffffffLL;
      insn[2] |= (((value & 0xfffff) << 6) | (((value >> 20) & 0x1) << 36));
    }
  else if (odesc - elf64_ia64_operands == IA64_OPND_TGT64)
    {
      value >>= 4;
      insn[1] = ((value >> 20) & 0x7fffffffffLL) << 2;
      insn[2] |= ((((value >> 59) & 0x1) << 36)
		  | (((value >> 0) & 0xfffff) << 13));
    }
  else
    err = (*odesc->insert) (odesc, value, insn + slot);

  if (err)
    as_bad_where (fix->fx_file, fix->fx_line, "%s", err);

  t0 = control_bits | (insn[0] << 5) | (insn[1] << 46);
  t1 = ((insn[1] >> 18) & 0x7fffff) | (insn[2] << 23);
  number_to_chars_littleendian (fixpos + 0, t0, 8);
  number_to_chars_littleendian (fixpos + 8, t1, 8);
}

/* Attempt to simplify or even eliminate a fixup.  The return value is
   ignored; perhaps it was once meaningful, but now it is historical.
   To indicate that a fixup has been eliminated, set FIXP->FX_DONE.

   If fixp->fx_addsy is non-NULL, we'll have to generate a reloc entry
   (if possible).  */

void
md_apply_fix (fixS *fix, valueT *valP, segT seg ATTRIBUTE_UNUSED)
{
  char *fixpos;
  valueT value = *valP;

  fixpos = fix->fx_frag->fr_literal + fix->fx_where;

  if (fix->fx_pcrel)
    {
    switch (fix->fx_r_type)
      {
      case BFD_RELOC_IA64_PCREL21B: break;
      case BFD_RELOC_IA64_PCREL21BI: break;
      case BFD_RELOC_IA64_PCREL21F: break;
      case BFD_RELOC_IA64_PCREL21M: break;
      case BFD_RELOC_IA64_PCREL60B: break;
      case BFD_RELOC_IA64_PCREL22: break;
      case BFD_RELOC_IA64_PCREL64I: break;
      case BFD_RELOC_IA64_PCREL32MSB: break;
      case BFD_RELOC_IA64_PCREL32LSB: break;
      case BFD_RELOC_IA64_PCREL64MSB: break;
      case BFD_RELOC_IA64_PCREL64LSB: break;
      default:
	fix->fx_r_type = ia64_gen_real_reloc_type (pseudo_func[FUNC_PC_RELATIVE].u.sym,
					       fix->fx_r_type);
	break;
      }
    }
  if (fix->fx_addsy)
    {
      switch ((unsigned) fix->fx_r_type)
	{
	case BFD_RELOC_UNUSED:
	  /* This must be a TAG13 or TAG13b operand.  There are no external
	     relocs defined for them, so we must give an error.  */
	  as_bad_where (fix->fx_file, fix->fx_line,
			_("%s must have a constant value"),
			elf64_ia64_operands[fix->tc_fix_data.opnd].desc);
	  fix->fx_done = 1;
	  return;

	case BFD_RELOC_IA64_TPREL14:
	case BFD_RELOC_IA64_TPREL22:
	case BFD_RELOC_IA64_TPREL64I:
	case BFD_RELOC_IA64_LTOFF_TPREL22:
	case BFD_RELOC_IA64_LTOFF_DTPMOD22:
	case BFD_RELOC_IA64_DTPREL14:
	case BFD_RELOC_IA64_DTPREL22:
	case BFD_RELOC_IA64_DTPREL64I:
	case BFD_RELOC_IA64_LTOFF_DTPREL22:
	  S_SET_THREAD_LOCAL (fix->fx_addsy);
	  break;

#ifdef TE_VMS
        case DUMMY_RELOC_IA64_SLOTCOUNT:
	  as_bad_where (fix->fx_file, fix->fx_line,
			_("cannot resolve @@slotcount parameter"));
	  fix->fx_done = 1;
	  return;
#endif

	default:
	  break;
	}
    }
  else if (fix->tc_fix_data.opnd == IA64_OPND_NIL)
    {
#ifdef TE_VMS
      if (fix->fx_r_type == DUMMY_RELOC_IA64_SLOTCOUNT)
        {
          /* For @@slotcount, convert an addresses difference to a slots
             difference.  */
          valueT v;

          v = (value >> 4) * 3;
          switch (value & 0x0f)
            {
            case 0:
            case 1:
            case 2:
              v += value & 0x0f;
              break;
            case 0x0f:
              v += 2;
              break;
            case 0x0e:
              v += 1;
              break;
            default:
              as_bad (_("invalid @@slotcount value"));
            }
          value = v;
        }
#endif

      if (fix->tc_fix_data.bigendian)
	number_to_chars_bigendian (fixpos, value, fix->fx_size);
      else
	number_to_chars_littleendian (fixpos, value, fix->fx_size);
      fix->fx_done = 1;
    }
  else
    {
      fix_insn (fix, elf64_ia64_operands + fix->tc_fix_data.opnd, value);
      fix->fx_done = 1;
    }
}

/* Generate the BFD reloc to be stuck in the object file from the
   fixup used internally in the assembler.  */

arelent *
tc_gen_reloc (asection *sec ATTRIBUTE_UNUSED, fixS *fixp)
{
  arelent *reloc;

  reloc = xmalloc (sizeof (*reloc));
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
  reloc->addend = fixp->fx_offset;
  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);

  if (!reloc->howto)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    _("Cannot represent %s relocation in object file"),
		    bfd_get_reloc_code_name (fixp->fx_r_type));
      free (reloc);
      return NULL;
    }
  return reloc;
}

/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LIT.  The number
   of LITTLENUMS emitted is stored in *SIZE.  An error message is
   returned, or NULL on OK.  */

#define MAX_LITTLENUMS 5

char *
md_atof (int type, char *lit, int *size)
{
  LITTLENUM_TYPE words[MAX_LITTLENUMS];
  char *t;
  int prec;

  switch (type)
    {
      /* IEEE floats */
    case 'f':
    case 'F':
    case 's':
    case 'S':
      prec = 2;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      prec = 4;
      break;

    case 'x':
    case 'X':
    case 'p':
    case 'P':
      prec = 5;
      break;

    default:
      *size = 0;
      return _("Unrecognized or unsupported floating point constant");
    }
  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  (*ia64_float_to_chars) (lit, words, prec);

  if (type == 'X')
    {
      /* It is 10 byte floating point with 6 byte padding.  */
      memset (&lit [10], 0, 6);
      *size = 8 * sizeof (LITTLENUM_TYPE);
    }
  else
    *size = prec * sizeof (LITTLENUM_TYPE);

  return NULL;
}

/* Handle ia64 specific semantics of the align directive.  */

void
ia64_md_do_align (int n ATTRIBUTE_UNUSED,
		  const char *fill ATTRIBUTE_UNUSED,
		  int len ATTRIBUTE_UNUSED,
		  int max ATTRIBUTE_UNUSED)
{
  if (subseg_text_p (now_seg))
    ia64_flush_insns ();
}

/* This is called from HANDLE_ALIGN in write.c.  Fill in the contents
   of an rs_align_code fragment.  */

void
ia64_handle_align (fragS *fragp)
{
  int bytes;
  char *p;
  const unsigned char *nop_type;

  if (fragp->fr_type != rs_align_code)
    return;

  /* Check if this frag has to end with a stop bit.  */
  nop_type = fragp->tc_frag_data ? le_nop_stop : le_nop;

  bytes = fragp->fr_next->fr_address - fragp->fr_address - fragp->fr_fix;
  p = fragp->fr_literal + fragp->fr_fix;

  /* If no paddings are needed, we check if we need a stop bit.  */ 
  if (!bytes && fragp->tc_frag_data)
    {
      if (fragp->fr_fix < 16)
#if 1
	/* FIXME: It won't work with
	   .align 16
	   alloc r32=ar.pfs,1,2,4,0
	 */
	;
#else
	as_bad_where (fragp->fr_file, fragp->fr_line,
		      _("Can't add stop bit to mark end of instruction group"));
#endif
      else
	/* Bundles are always in little-endian byte order. Make sure
	   the previous bundle has the stop bit.  */
	*(p - 16) |= 1;
    }

  /* Make sure we are on a 16-byte boundary, in case someone has been
     putting data into a text section.  */
  if (bytes & 15)
    {
      int fix = bytes & 15;
      memset (p, 0, fix);
      p += fix;
      bytes -= fix;
      fragp->fr_fix += fix;
    }

  /* Instruction bundles are always little-endian.  */
  memcpy (p, nop_type, 16);
  fragp->fr_var = 16;
}

static void
ia64_float_to_chars_bigendian (char *lit, LITTLENUM_TYPE *words,
			       int prec)
{
  while (prec--)
    {
      number_to_chars_bigendian (lit, (long) (*words++),
				 sizeof (LITTLENUM_TYPE));
      lit += sizeof (LITTLENUM_TYPE);
    }
}

static void
ia64_float_to_chars_littleendian (char *lit, LITTLENUM_TYPE *words,
				  int prec)
{
  while (prec--)
    {
      number_to_chars_littleendian (lit, (long) (words[prec]),
				    sizeof (LITTLENUM_TYPE));
      lit += sizeof (LITTLENUM_TYPE);
    }
}

void
ia64_elf_section_change_hook (void)
{
  if (elf_section_type (now_seg) == SHT_IA_64_UNWIND
      && elf_linked_to_section (now_seg) == NULL)
    elf_linked_to_section (now_seg) = text_section;
  dot_byteorder (-1);
}

/* Check if a label should be made global.  */
void
ia64_check_label (symbolS *label)
{
  if (*input_line_pointer == ':')
    {
      S_SET_EXTERNAL (label);
      input_line_pointer++;
    }
}

/* Used to remember where .alias and .secalias directives are seen. We
   will rename symbol and section names when we are about to output
   the relocatable file.  */
struct alias
{
  char *file;		/* The file where the directive is seen.  */
  unsigned int line;	/* The line number the directive is at.  */
  const char *name;	/* The original name of the symbol.  */
};

/* Called for .alias and .secalias directives. If SECTION is 1, it is
   .secalias. Otherwise, it is .alias.  */
static void
dot_alias (int section)
{
  char *name, *alias;
  char delim;
  char *end_name;
  int len;
  const char *error_string;
  struct alias *h;
  const char *a;
  struct hash_control *ahash, *nhash;
  const char *kind;

  name = input_line_pointer;
  delim = get_symbol_end ();
  end_name = input_line_pointer;
  *end_name = delim;

  if (name == end_name)
    {
      as_bad (_("expected symbol name"));
      ignore_rest_of_line ();
      return;
    }

  SKIP_WHITESPACE ();

  if (*input_line_pointer != ',')
    {
      *end_name = 0;
      as_bad (_("expected comma after \"%s\""), name);
      *end_name = delim;
      ignore_rest_of_line ();
      return;
    }

  input_line_pointer++;
  *end_name = 0;
  ia64_canonicalize_symbol_name (name);

  /* We call demand_copy_C_string to check if alias string is valid.
     There should be a closing `"' and no `\0' in the string.  */
  alias = demand_copy_C_string (&len);
  if (alias == NULL)
    {
      ignore_rest_of_line ();
      return;
    }

  /* Make a copy of name string.  */
  len = strlen (name) + 1;
  obstack_grow (&notes, name, len);
  name = obstack_finish (&notes);

  if (section)
    {
      kind = "section";
      ahash = secalias_hash;
      nhash = secalias_name_hash;
    }
  else
    {
      kind = "symbol";
      ahash = alias_hash;
      nhash = alias_name_hash;
    }

  /* Check if alias has been used before.  */
  h = (struct alias *) hash_find (ahash, alias);
  if (h)
    {
      if (strcmp (h->name, name))
	as_bad (_("`%s' is already the alias of %s `%s'"),
		alias, kind, h->name);
      goto out;
    }

  /* Check if name already has an alias.  */
  a = (const char *) hash_find (nhash, name);
  if (a)
    {
      if (strcmp (a, alias))
	as_bad (_("%s `%s' already has an alias `%s'"), kind, name, a);
      goto out;
    }

  h = (struct alias *) xmalloc (sizeof (struct alias));
  as_where (&h->file, &h->line);
  h->name = name;
  
  error_string = hash_jam (ahash, alias, (void *) h);
  if (error_string)
    {
      as_fatal (_("inserting \"%s\" into %s alias hash table failed: %s"),
		alias, kind, error_string);
      goto out;
    }

  error_string = hash_jam (nhash, name, (void *) alias);
  if (error_string)
    {
      as_fatal (_("inserting \"%s\" into %s name hash table failed: %s"),
		alias, kind, error_string);
out:
      obstack_free (&notes, name);
      obstack_free (&notes, alias);
    }

  demand_empty_rest_of_line ();
}

/* It renames the original symbol name to its alias.  */
static void
do_alias (const char *alias, void *value)
{
  struct alias *h = (struct alias *) value;
  symbolS *sym = symbol_find (h->name);

  if (sym == NULL)
    {
#ifdef TE_VMS
      /* Uses .alias extensively to alias CRTL functions to same with
	 decc$ prefix. Sometimes function gets optimized away and a
	 warning results, which should be suppressed.  */
      if (strncmp (alias, "decc$", 5) != 0)
#endif
	as_warn_where (h->file, h->line,
		       _("symbol `%s' aliased to `%s' is not used"),
		       h->name, alias);
    }
    else
      S_SET_NAME (sym, (char *) alias);
}

/* Called from write_object_file.  */
void
ia64_adjust_symtab (void)
{
  hash_traverse (alias_hash, do_alias);
}

/* It renames the original section name to its alias.  */
static void
do_secalias (const char *alias, void *value)
{
  struct alias *h = (struct alias *) value;
  segT sec = bfd_get_section_by_name (stdoutput, h->name);

  if (sec == NULL)
    as_warn_where (h->file, h->line,
		   _("section `%s' aliased to `%s' is not used"),
		   h->name, alias);
  else
    sec->name = alias;
}

/* Called from write_object_file.  */
void
ia64_frob_file (void)
{
  hash_traverse (secalias_hash, do_secalias);
}

#ifdef TE_VMS
#define NT_VMS_MHD 1
#define NT_VMS_LNM 2

/* Integrity VMS 8.x identifies it's ELF modules with a standard ELF
   .note section.  */

/* Manufacture a VMS-like time string.  */
static void
get_vms_time (char *Now)
{
  char *pnt;
  time_t timeb;

  time (&timeb);
  pnt = ctime (&timeb);
  pnt[3] = 0;
  pnt[7] = 0;
  pnt[10] = 0;
  pnt[16] = 0;
  pnt[24] = 0;
  sprintf (Now, "%2s-%3s-%s %s", pnt + 8, pnt + 4, pnt + 20, pnt + 11);
}

void
ia64_vms_note (void)
{
  char *p;
  asection *seg = now_seg;
  subsegT subseg = now_subseg;
  asection *secp = NULL;
  char *bname;
  char buf [256];
  symbolS *sym;

  /* Create the .note section.  */

  secp = subseg_new (".note", 0);
  bfd_set_section_flags (stdoutput,
			 secp,
			 SEC_HAS_CONTENTS | SEC_READONLY);

  /* Module header note (MHD).  */
  bname = xstrdup (lbasename (out_file_name));
  if ((p = strrchr (bname, '.')))
    *p = '\0';
  
  /* VMS note header is 24 bytes long.  */
  p = frag_more (8 + 8 + 8);
  number_to_chars_littleendian (p + 0, 8, 8);
  number_to_chars_littleendian (p + 8, 40 + strlen (bname), 8);
  number_to_chars_littleendian (p + 16, NT_VMS_MHD, 8);

  p = frag_more (8);
  strcpy (p, "IPF/VMS");

  p = frag_more (17 + 17 + strlen (bname) + 1 + 5);
  get_vms_time (p);
  strcpy (p + 17, "24-FEB-2005 15:00");
  p += 17 + 17;
  strcpy (p, bname);
  p += strlen (bname) + 1;
  free (bname);
  strcpy (p, "V1.0");

  frag_align (3, 0, 0);

  /* Language processor name note.  */
  sprintf (buf, "GNU assembler version %s (%s) using BFD version %s",
	   VERSION, TARGET_ALIAS, BFD_VERSION_STRING);

  p = frag_more (8 + 8 + 8);
  number_to_chars_littleendian (p + 0, 8, 8);
  number_to_chars_littleendian (p + 8, strlen (buf) + 1, 8);
  number_to_chars_littleendian (p + 16, NT_VMS_LNM, 8);

  p = frag_more (8);
  strcpy (p, "IPF/VMS");

  p = frag_more (strlen (buf) + 1);
  strcpy (p, buf);

  frag_align (3, 0, 0);

  secp = subseg_new (".vms_display_name_info", 0);
  bfd_set_section_flags (stdoutput,
			 secp,
			 SEC_HAS_CONTENTS | SEC_READONLY);

  /* This symbol should be passed on the command line and be variable
     according to language.  */
  sym = symbol_new ("__gnat_vms_display_name@@gnat_demangler_rtl",
		    absolute_section, 0, &zero_address_frag);
  symbol_table_insert (sym);
  symbol_get_bfdsym (sym)->flags |= BSF_DEBUGGING | BSF_DYNAMIC;

  p = frag_more (4);
  /* Format 3 of VMS demangler Spec.  */
  number_to_chars_littleendian (p, 3, 4);

  p = frag_more (4);
  /* Place holder for symbol table index of above symbol.  */
  number_to_chars_littleendian (p, -1, 4);

  frag_align (3, 0, 0);

  /* We probably can't restore the current segment, for there likely
     isn't one yet...  */
  if (seg && subseg)
    subseg_set (seg, subseg);
}

#endif /* TE_VMS */
@


1.221
log
@gas/
2013-03-26  Douglas B Rupp  <rupp@@gnat.com>

	* config/tc-ia64.c (emit_one_bundle): Move last_slot adjustment
	after fixup.

gas/testsuite/
2013-03-26  Douglas B Rupp  <rupp@@adacore.com

	* gas/ia64/ia64.exp: Add new test reloc-mlx
	* gas/ia64/reloc-mlx.[sd]: New test for X-unit reloc.
	* gas/ia64/pcrel.d: Fix output for X-unit reloc.
@
text
@d2 1
a2 2
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
   2008, 2009, 2011, 2012, 2013 Free Software Foundation, Inc.
d2980 1
a2980 1
  normal fill frag with the unwind image from the the record list.  */
@


1.220
log
@Add Intel Itanium Series 9500 support

bfd/

2012-09-04  Sergey A. Guriev <sergey.a.guriev@@intel.com>

	* cpu-ia64-opc.c (ins_cnt6a): New function.
	(ext_cnt6a): Ditto.
	(ins_strd5b): Ditto.
	(ext_strd5b): Ditto.
	(elf64_ia64_operands): Add new operand types.

gas/

2012-09-04  Sergey A. Guriev  <sergey.a.guriev@@intel.com>

	* config/tc-ia64.c (reg_symbol): Add a new register.
	(indirect_reg): Ditto.
	(pseudo_func): Add new symbolic constants.
	(operand_match): Add new operand types recognition.
	(operand_insn): Add new register recognition.
	(md_begin): Add new register definition.
	(specify_resource): Add new register recognition.

gas/testsuite/

2012-09-04  Sergey A. Guriev  <sergey.a.guriev@@intel.com>

	* gas/testsuite/gas/ia64/psn.d: New file.
	* gas/testsuite/gas/ia64/psn.s: New file.
	* gas/testsuite/gas/ia64/ia64.exp: Add new testcase.
	* gas/testsuite/gas/ia64/opc-i.d: Fixed failing tests.
	* gas/testsuite/gas/ia64/opc-m.d: Ditto.

include/opcode/

2012-09-04  Sergey A. Guriev <sergey.a.guriev@@intel.com>

	* ia64.h (ia64_opnd): Add new operand types.

opcodes/

2012-09-04  Sergey A. Guriev <sergey.a.guriev@@intel.com>

	* ia64-asmtab.h (completer_index): Extend bitfield to full uint.
	* ia64-gen.c: Promote completer index type to longlong.
	(irf_operand): Add new register recognition.
	(in_iclass_mov_x): Add an entry for the new mov_* instruction type.
	(lookup_specifier): Add new resource recognition.
	(insert_bit_table_ent): Relax abort condition according to the
	changed completer index type.
	(print_dis_table): Fix printf format for completer index.
	* ia64-ic.tbl: Add a new instruction class.
	* ia64-opc-i.c (ia64_opcodes_i): Define new I-instructions.
	* ia64-opc-m.c (ia64_opcodes_m): Define new M-instructions.
	* ia64-opc.h: Define short names for new operand types.
	* ia64-raw.tbl: Add new RAW resource for DAHR register.
	* ia64-waw.tbl: Add new WAW resource for DAHR register.
	* ia64-asmtab.c: Regenerate.
@
text
@d3 1
a3 1
   2008, 2009, 2011, 2012 Free Software Foundation, Inc.
a6936 9
      if (required_unit == IA64_UNIT_L)
	{
	  know (i == 1);
	  /* skip one slot for long/X-unit instructions */
	  ++i;
	}
      --md.num_slots_in_use;
      last_slot = i;

d6949 11
@


1.219
log
@Replace all uses of bfd_abs_section, bfd_com_section, bfd_und_section
and bfd_ind_section with their _ptr variants, or use corresponding
bfd_is_* macros.
@
text
@d117 2
a118 1
    REG_P	= (REG_CR + 128),
d137 1
d544 1
d615 6
d5579 6
d5629 1
d5750 2
d6008 33
d6491 4
d6521 1
d7494 3
d8750 16
d8840 1
@


1.219.2.1
log
@bfd/
2012-09-04  Sergey A. Guriev <sergey.a.guriev@@intel.com>

	* cpu-ia64-opc.c (ins_cnt6a): New function.
	(ext_cnt6a): Ditto.
	(ins_strd5b): Ditto.
	(ext_strd5b): Ditto.
	(elf64_ia64_operands): Add new operand types.

gas/
2012-09-04  Sergey A. Guriev  <sergey.a.guriev@@intel.com>

	* config/tc-ia64.c (reg_symbol): Add a new register.
	(indirect_reg): Ditto.
	(pseudo_func): Add new symbolic constants.
	(operand_match): Add new operand types recognition.
	(operand_insn): Add new register recognition.
	(md_begin): Add new register definition.
	(specify_resource): Add new register recognition.

gas/
2012-09-04  Sergey A. Guriev  <sergey.a.guriev@@intel.com>

	* gas/testsuite/gas/ia64/psn.d: New file.
	* gas/testsuite/gas/ia64/psn.s: New file.
	* gas/testsuite/gas/ia64/ia64.exp: Add new testcase.
	* gas/testsuite/gas/ia64/opc-i.d: Fixed failing tests.
	* gas/testsuite/gas/ia64/opc-m.d: Ditto.

include/
2012-09-04  Sergey A. Guriev <sergey.a.guriev@@intel.com>

	* ia64.h (ia64_opnd): Add new operand types.

opcodes/
2012-09-04  Sergey A. Guriev <sergey.a.guriev@@intel.com>

	* ia64-asmtab.h (completer_index): Extend bitfield to full uint.
	* ia64-gen.c: Promote completer index type to longlong.
	(irf_operand): Add new register recognition.
	(in_iclass_mov_x): Add an entry for the new mov_* instruction type.
	(lookup_specifier): Add new resource recognition.
	(insert_bit_table_ent): Relax abort condition according to the
	changed completer index type.
	(print_dis_table): Fix printf format for completer index.
	* ia64-ic.tbl: Add a new instruction class.
	* ia64-opc-i.c (ia64_opcodes_i): Define new I-instructions.
	* ia64-opc-m.c (ia64_opcodes_m): Define new M-instructions.
	* ia64-opc.h: Define short names for new operand types.
	* ia64-raw.tbl: Add new RAW resource for DAHR register.
	* ia64-waw.tbl: Add new WAW resource for DAHR register.
	* ia64-asmtab.c: Regenerate.
@
text
@d117 1
a117 2
    REG_DAHR	= (REG_CR + 128),
    REG_P	= (REG_DAHR + 8),
a135 1
    IND_DAHR,
a541 1
    { "dahr",	IND_DAHR },
a611 6
    { "priority", PSEUDO_FUNC_CONST, { 0x1 } },

    /* tf constants: */
    { "clz",	PSEUDO_FUNC_CONST, {  32 } },
    { "mpy",	PSEUDO_FUNC_CONST, {  33 } },
    { "datahints",	PSEUDO_FUNC_CONST, {  34 } },
a5569 6
    case IA64_OPND_DAHR3:
      if (e->X_op == O_register && e->X_add_number >= REG_DAHR
	  && e->X_add_number < REG_DAHR + 8)
	return OPERAND_MATCH;
      break;

a5613 1
    case IA64_OPND_DAHR_R3:
a5733 2
    case IA64_OPND_IMMU16:
    case IA64_OPND_IMMU19:
a5989 33
    case IA64_OPND_STRD5b:
      if (e->X_op == O_constant)
	{
	  /* 5-bit signed scaled by 64 */
	  if ((e->X_add_number <=  	( 0xf  << 6 )) 
	       && (e->X_add_number >=  -( 0x10 << 6 )))
	    {
	      
	      /* Must be a multiple of 64 */
	      if ((e->X_add_number & 0x3f) != 0)
	        as_warn (_("stride must be a multiple of 64; lower 6 bits ignored"));

	      e->X_add_number &= ~ 0x3f;
	      return OPERAND_MATCH;
	    }
	  else
	    return OPERAND_OUT_OF_RANGE;
	}
      break;
    case IA64_OPND_CNT6a:
      if (e->X_op == O_constant)
	{
	  /* 6-bit unsigned biased by 1 -- count 0 is meaningless */
	  if ((e->X_add_number     <=   64) 
	       && (e->X_add_number > 0) )
	    {
	      return OPERAND_MATCH;
	    }
	  else
	    return OPERAND_OUT_OF_RANGE;
	}
      break;

a6439 4
	case IA64_OPND_DAHR3:
	  val -= REG_DAHR;
	  break;

a6465 1
	case IA64_OPND_DAHR_R3:
a7437 3
  /* dahr registers:  */
  declare_register_set ("dahr", 8, REG_DAHR);

a8690 16
    case IA64_RS_DAHR:
      if (note == 0)
	{
	  if (idesc->operands[!rsrc_write] == IA64_OPND_DAHR3)
	    {
	      specs[count] = tmpl;
	      specs[count++].index =
		CURR_SLOT.opnd[!rsrc_write].X_add_number - REG_DAHR;
	    }
	}
      else
	{
	  UNHANDLED;
	}
      break;

a8764 1
		      || idesc->operands[i] == IA64_OPND_DAHR_R3
@


1.218
log
@2012-04-20  Tristan Gingold  <gingold@@adacore.com>

	* config/tc-ia64.c (obj_elf_vms_common): New function.
	(md_pseudo_table): Add .vms_common pseudo.
	* config/obj-elf.h (obj_elf_section_name): Add a prototype.
	* config/obj-elf.c (obj_elf_section_name): Make it public.
@
text
@d3 1
a3 1
   2008, 2009, 2011   Free Software Foundation, Inc.
d7788 1
a7788 1
  if ((S_GET_SEGMENT (sym) == &bfd_und_section && ! symbol_used_p (sym) &&
d7790 1
a7790 1
      || (S_GET_SEGMENT (sym) == &bfd_abs_section
@


1.217
log
@ELFOSABI_GNU

	bfd/
	* elf.c (_bfd_elf_set_osabi): Use ELFOSABI_GNU name instead of
	ELFOSABI_LINUX alias.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf64-hppa.c: Likewise.

	binutils/
	* elfedit.c (osabis): Use ELFOSABI_GNU name instead of ELFOSABI_LINUX
	alias and ELFOSABI_HURD.  Add GNU alias.
	* readelf.c (get_osabi_name, get_symbol_binding, get_symbol_type):
	Likewise.
	* doc/binutils.texi <elfedit>: Update accordingly.

	elfcpp/
	* elfcpp.h (ELFOSABI): Add ELFOSABI_GNU with value of ELFOSABI_LINUX,
	keep ELFOSABI_LINUX as an alias.  Remove ELFOSABI_HURD.

	gas/
	* config/obj-elf.c (obj_elf_type): Use ELFOSABI_GNU name instead of
	ELFOSABI_LINUX alias.
	* config/tc-ia64.c: Likewise.

	include/elf/
	* common.h (ELFOSABI_GNU): Define, replaces...
	(ELFOSABI_LINUX): ... this, kept as an alias.
	(ELFOSABI_HURD): Remove.

	ld/testsuite/
	* ld-ifunc/ifunc.exp: Update for changed output.
	* ld-unique/unique.exp: Likewise.
@
text
@d1042 135
d5370 4
@


1.216
log
@	* config/tc-arm.c (s_unreq): Reword warning message to make it
	easier to translate.
	* config/tc-ia64.c (md_show_usage): Add note for translators.
	* configure.in (ALL_LINGUAS): Add "fi".
	* configure: Regenerate.
@
text
@d617 1
a617 1
    { "linux",	PSEUDO_FUNC_CONST,	{ ELFOSABI_LINUX } },
@


1.215
log
@2011-04-01  Tristan Gingold  <gingold@@adacore.com>

	* config/tc-ia64.c (md_apply_fix): Add a cast to avoid a warning.
@
text
@d3 1
a3 1
   2008, 2009   Free Software Foundation, Inc.
d7004 3
a7006 1
  -x | -xexplicit	  turn on dependency violation checking\n\
@


1.214
log
@	PR gas/12011
	* config/obj-elf.c (obj_elf_parse_section_letters): Correct test
	for error return from md_elf_section_letter.
	* config/tc-alpha.c (alpha_elf_section_letter): Correct error message.
	* config/tc-i386.c (x86_64_section_letter): Likewise.
	* config/tc-ia64.c (ia64_elf_section_letter): Likewise.
	* config/tc-mep.c (mep_elf_section_letter): Likewise.
	* gas/elf/bad-section-flag.d, * gas/elf/bad-section-flag.err,
	* gas/elf/bad-section-flag.s: New test.
	* gas/elf/elf.exp: Run it.
@
text
@d11289 1
a11289 1
      switch (fix->fx_r_type)
@


1.213
log
@gas/
2010-02-12  Tristan Gingold  <gingold@@adacore.com>
	    Douglas B Rupp  <rupp@@gnat.com>

	* config/tc-ia64.c (enum reloc_func): Add FUNC_SLOTCOUNT_RELOC.
	(DUMMY_RELOC_IA64_SLOTCOUNT): Added.
	(pseudo_func): Add an entry for slotcount.
	(md_begin): Initialize slotcount pseudo symbol.
	(ia64_parse_name): Handle @@slotcount parameter.
	(ia64_gen_real_reloc_type): Handle slotcount.
	(md_apply_fix): Ditto.
	* doc/c-ia64.texi (IA-64-Relocs): Document @@slotcount.

gas/testsuite/
2010-02-12  Tristan Gingold  <gingold@@adacore.com>

	* gas/ia64/slotcount.s, gas/ia64/slotcount.s: New test.
	* gas/ia64/ia64.exp: Add slotcount test (vms only).
@
text
@d864 1
a864 1
  *ptr_msg = _("Bad .section directive: want a,o,s,w,x,M,S,G,T in string");
@


1.212
log
@2010-01-18  Tristan Gingold  <gingold@@adacore.com>

	* config/tc-ia64.c (ia64_vms_note): Generate 24 bytes note headers.
@
text
@d106 3
d169 5
d586 3
d7172 6
d7764 9
d11138 5
d11312 8
d11326 28
@


1.211
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@a11701 1
  Elf_Internal_Note i_note;
d11714 1
a11714 1
  /* Module header note.  */
d11718 6
a11723 13

  i_note.namesz = 8;
  i_note.descsz = 40 + strlen (bname);
  i_note.type = NT_VMS_MHD;

  p = frag_more (sizeof (i_note.namesz));
  number_to_chars_littleendian (p, i_note.namesz, 8);

  p = frag_more (sizeof (i_note.descsz));
  number_to_chars_littleendian (p, i_note.descsz, 8);

  p = frag_more (sizeof (i_note.type));
  number_to_chars_littleendian (p, i_note.type, 8);
d11728 4
a11731 8
  get_vms_time (buf);
  p = frag_more (17);
  strcpy (p, buf);

  p = frag_more (17);
  strcpy (p, "24-FEB-2005 15:00");

  p = frag_more (strlen (bname) + 1);
d11733 1
a11734 2

  p = frag_more (5);
d11743 4
a11746 12
  i_note.namesz = 8;
  i_note.descsz = 1 + strlen (buf);
  i_note.type = NT_VMS_LNM;

  p = frag_more (sizeof (i_note.namesz));
  number_to_chars_littleendian (p, i_note.namesz, 8);

  p = frag_more (sizeof (i_note.descsz));
  number_to_chars_littleendian (p, i_note.descsz, 8);

  p = frag_more (sizeof (i_note.type));
  number_to_chars_littleendian (p, i_note.type, 8);
@


1.210
log
@	PR gas/2117
	* config/tc-ia64.c (parse_operand): Use expression rather than
	expression_and_evalute.
	(parse_operand_and_eval): New function.  Replace all uses of
	parse_operand outside of parse_operands with this function.
	(parse_operans_maybe_eval): New function.  Replace uses of
	parse_operand in parse_operands, except for the dummy, with
	this function.
@
text
@d2550 1
a2550 1
  unsigned long index = 0;
d2568 1
a2568 1
	    index += 3 * ((first_frag->fr_next->fr_address
d2589 1
a2589 1
	    index += 3 * ((1 << first_frag->fr_offset) >> 4);
d2599 1
a2599 1
	    index += 3 * (first_frag->fr_offset >> 4);
d2604 1
a2604 1
      index += 3 * (first_frag->fr_fix >> 4);
d2606 1
a2606 1
      index -= (3 * ((first_addr >> 4) - (start_addr >> 4))
d2622 1
a2622 1
  index += (3 * ((slot_addr >> 4) - (first_addr >> 4))
d2624 1
a2624 1
  return index;
d4649 1
a4649 1
cross_section (int ref, void (*cons) (int), int ua)
d4694 1
a4694 1
  section_count = bfd_count_sections(stdoutput);
d4696 1
a4696 1
  if (section_count != bfd_count_sections(stdoutput))
d4702 1
a4702 1
  (*cons) (ref);
d5308 1
a5308 1
operand_match (const struct ia64_opcode *idesc, int index, expressionS *e)
d5310 1
a5310 1
  enum ia64_opnd opnd = idesc->operands[index];
d5480 1
a5480 1
      bits = operand_width (idesc->operands[index]);
d5554 1
a5554 1
	  fix->opnd = idesc->operands[index];
d5589 1
a5589 1
      bits = operand_width (idesc->operands[index]);
d5600 1
a5600 1
      bits = operand_width (idesc->operands[index]);
d5676 1
a5676 1
      bits = operand_width (idesc->operands[index]);
d5683 1
a5683 1
	  if (idesc->operands[index] == IA64_OPND_IMM14)
d5695 1
a5695 1
	  fix->opnd = idesc->operands[index];
d5801 1
a5801 1
	  fix->opnd = idesc->operands[index];
d5820 1
a5820 1
	  fix->opnd = idesc->operands[index];
d5834 1
a5834 1
      fix->opnd = idesc->operands[index];
d8364 3
a8366 3
	      int index = ((idesc->operands[1] == IA64_OPND_R3 && !rsrc_write)
			   ? 1 : !rsrc_write);
	      int regno = CURR_SLOT.opnd[index].X_add_number - REG_GR;
d8904 1
a8904 1
			  int index =
d8908 1
a8908 1
			    CURR_SLOT.opnd[index].X_add_number - REG_CR;
d8942 1
a8942 1
			  int index =
d8946 1
a8946 1
			    CURR_SLOT.opnd[index].X_add_number - REG_AR;
d8950 1
a8950 1
			      || (index == 0
d10802 1
a10802 1
  expressionS expr;
d10804 5
a10808 5
  expr.X_op = O_pseudo_fixup;
  expr.X_op_symbol = pseudo_func[FUNC_SEC_RELATIVE].u.sym;
  expr.X_add_number = 0;
  expr.X_add_symbol = symbol;
  emit_expr (&expr, size);
d11406 1
a11406 1
  const unsigned char *nop;
d11412 1
a11412 1
  nop = fragp->tc_frag_data ? le_nop_stop : le_nop;
d11449 1
a11449 1
  memcpy (p, nop, 16);
@


1.209
log
@2009-09-03  Tristan Gingold  <gingold@@adacore.com>

	* config/tc-ia64.c (ia64_vms_note): Use lbasename instead of basename.
	Call xstrdup on the result and free the buffer after use.
@
text
@d787 1
a787 1
static int parse_operand (expressionS *, int);
d2894 1
a2894 1
  int sep = parse_operand (e, ',');
d2905 1
a2905 1
    sep = parse_operand (e, ',');
d3158 1
a3158 1
  sep = parse_operand (&e, ',');
d3178 1
a3178 1
  sep = parse_operand (&e, ',');
d3205 1
a3205 1
  sep = parse_operand (&e, ',');
d3225 1
a3225 1
  sep = parse_operand (&e1, ',');
d3227 1
a3227 1
    sep = parse_operand (&e2, ',');
d3314 1
a3314 1
  sep = parse_operand (&e1, ',');
d3322 1
a3322 1
      sep = parse_operand (&e2, ',');
d3363 1
a3363 1
      sep = parse_operand (&e, ',');
d3609 1
a3609 1
  parse_operand (&e, 0);
d3630 1
a3630 1
  sep = parse_operand (&e1, ',');
d3632 1
a3632 1
    sep = parse_operand (&e2, ',');
d3730 1
a3730 1
  sep = parse_operand (&e, ',');
d3746 1
a3746 1
      parse_operand (&e, 0);
d3772 1
a3772 1
  parse_operand (&e, 0);
d3794 1
a3794 1
  sep = parse_operand (&e, ',');
d3810 1
a3810 1
      parse_operand (&e, 0);
d3836 2
a3837 2
  if (parse_operand (&e1, ',') == ',')
    parse_operand (&e2, 0);
d3874 1
a3874 1
  parse_operand (&e, 0);
d3899 1
a3899 1
      sep = parse_operand (&e, ',');
d3905 1
a3905 1
    sep = parse_operand (&e, ',');
d3936 1
a3936 1
      sep = parse_operand (&e, ',');
d3942 1
a3942 1
    sep = parse_operand (&e, ',');
d4017 1
a4017 1
  parse_operand (&e, 0);
d4036 1
a4036 1
  parse_operand (&e, 0);
d4056 1
a4056 1
  sep = parse_operand (&e1, ',');
d4058 1
a4058 1
    parse_operand (&e2, 0);
d4201 1
a4201 1
      int n, sep = parse_operand (&e, ',');
d4214 1
a4214 1
	parse_operand (&e, 0);
d4950 1
a4950 1
      sep = parse_operand (&pr, ',');
d5854 1
a5854 1
  expression_and_evaluate (e);
d5861 32
d5947 2
a5948 1
	  sep = parse_operand (CURR_SLOT.opnd + i, '=');
d6002 2
a6003 1
      sep = parse_operand (CURR_SLOT.opnd + 0, '=');
@


1.209.2.1
log
@2009-10-13  Alan Modra  <amodra@@bigpond.net.au>
	    H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/2117
	* config/tc-ia64.c (parse_operand): Use expression rather than
	expression_and_evalute.
	(parse_operand_and_eval): New function.  Replace all uses of
	parse_operand outside of parse_operands with this function.
	(parse_operans_maybe_eval): New function.  Replace uses of
	parse_operand in parse_operands, except for the dummy, with
	this function.
@
text
@d787 1
a787 1
static int parse_operand_and_eval (expressionS *, int);
d2894 1
a2894 1
  int sep = parse_operand_and_eval (e, ',');
d2905 1
a2905 1
    sep = parse_operand_and_eval (e, ',');
d3158 1
a3158 1
  sep = parse_operand_and_eval (&e, ',');
d3178 1
a3178 1
  sep = parse_operand_and_eval (&e, ',');
d3205 1
a3205 1
  sep = parse_operand_and_eval (&e, ',');
d3225 1
a3225 1
  sep = parse_operand_and_eval (&e1, ',');
d3227 1
a3227 1
    sep = parse_operand_and_eval (&e2, ',');
d3314 1
a3314 1
  sep = parse_operand_and_eval (&e1, ',');
d3322 1
a3322 1
      sep = parse_operand_and_eval (&e2, ',');
d3363 1
a3363 1
      sep = parse_operand_and_eval (&e, ',');
d3609 1
a3609 1
  parse_operand_and_eval (&e, 0);
d3630 1
a3630 1
  sep = parse_operand_and_eval (&e1, ',');
d3632 1
a3632 1
    sep = parse_operand_and_eval (&e2, ',');
d3730 1
a3730 1
  sep = parse_operand_and_eval (&e, ',');
d3746 1
a3746 1
      parse_operand_and_eval (&e, 0);
d3772 1
a3772 1
  parse_operand_and_eval (&e, 0);
d3794 1
a3794 1
  sep = parse_operand_and_eval (&e, ',');
d3810 1
a3810 1
      parse_operand_and_eval (&e, 0);
d3836 2
a3837 2
  if (parse_operand_and_eval (&e1, ',') == ',')
    parse_operand_and_eval (&e2, 0);
d3874 1
a3874 1
  parse_operand_and_eval (&e, 0);
d3899 1
a3899 1
      sep = parse_operand_and_eval (&e, ',');
d3905 1
a3905 1
    sep = parse_operand_and_eval (&e, ',');
d3936 1
a3936 1
      sep = parse_operand_and_eval (&e, ',');
d3942 1
a3942 1
    sep = parse_operand_and_eval (&e, ',');
d4017 1
a4017 1
  parse_operand_and_eval (&e, 0);
d4036 1
a4036 1
  parse_operand_and_eval (&e, 0);
d4056 1
a4056 1
  sep = parse_operand_and_eval (&e1, ',');
d4058 1
a4058 1
    parse_operand_and_eval (&e2, 0);
d4201 1
a4201 1
      int n, sep = parse_operand_and_eval (&e, ',');
d4214 1
a4214 1
	parse_operand_and_eval (&e, 0);
d4950 1
a4950 1
      sep = parse_operand_and_eval (&pr, ',');
d5854 1
a5854 1
  expression (e);
a5860 32
static int
parse_operand_and_eval (expressionS *e, int more)
{
  int sep = parse_operand (e, more);
  resolve_expression (e);
  return sep;
}

static int
parse_operand_maybe_eval (expressionS *e, int more, enum ia64_opnd op)
{
  int sep = parse_operand (e, more);
  switch (op)
    {
    case IA64_OPND_IMM14:
    case IA64_OPND_IMM22:
    case IA64_OPND_IMMU64:
    case IA64_OPND_TGT25:
    case IA64_OPND_TGT25b:
    case IA64_OPND_TGT25c:
    case IA64_OPND_TGT64:
    case IA64_OPND_TAG13:
    case IA64_OPND_TAG13b:
    case IA64_OPND_LDXMOV:
      break;
    default:
      resolve_expression (e);
      break;
    }
  return sep;
}

d5915 1
a5915 2
	  sep = parse_operand_maybe_eval (CURR_SLOT.opnd + i, '=',
					  idesc->operands[i]);
d5969 1
a5969 2
      sep = parse_operand_maybe_eval (CURR_SLOT.opnd + 0, '=',
				      idesc->operands[0]);
@


1.208
log
@        Updated sources to avoid using the identifier name "new", which is a
        keyword in c++.

        * bfd/aoutx.h (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol.
        * bfd/coffgen.c (coff_make_empty_symbol)
        (coff_bfd_make_debug_symbol): Rename variable new to new_symbol.
        * bfd/cpu-ia64-opc.c (ext_reg, ins_imms_scaled): Rename variable
        new to new_insn.
        * bfd/doc/chew.c (newentry, add_intrinsic): Rename variable new to
        new_d.
        * bfd/ecoff.c (_bfd_ecoff_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/elf32-m68k.c (elf_m68k_get_got_entry_type): Rename argument
        new to new_reloc.
        * bfd/hash.c (bfd_hash_lookup): Rename variable new to new_string.
        * bfd/ieee.c (ieee_make_empty_symbol): Rename variable new to
        new_symbol.
        * bfd/linker.c (bfd_new_link_order): Rename variable new to
        new_lo.
        * bfd/mach-o.c (bfd_mach_o_sizeof_headers): Rename variable new to
        symbol.
        * bfd/oasys.c (oasys_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/pdp11.c (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol_type.
        * bfd/plugin.c (bfd_plugin_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/rs6000-core.c (CoreHdr, VmInfo): Rename union member new to
        new_dump.
        (read_hdr, rs6000coff_core_p)
        (rs6000coff_core_file_matches_executable_p)
        (rs6000coff_core_file_failing_command)
        (rs6000coff_core_file_failing_signal): Updated function to use new
        union member name.
        * bfd/som.c (som_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/syms.c (_bfd_generic_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/tekhex.c (first_phase, tekhex_make_empty_symbol): Rename
        variable new to new_symbol.
        * binutils/nlmconv.c (main): Rename variable new to new_name.
        * gas/config/tc-arm.c (insert_reg_alias): Rename variable new to
        new_reg.
        * gas/config/tc-dlx.c (parse_operand): Rename variable new to
        new_pos.
        * gas/config/tc-ia64.c (ia64_gen_real_reloc_type): Rename variable
        new to newr.
        * gas/config/tc-mcore.c (parse_exp, parse_imm): Rename variable
        new to new_pointer.
        * gas/config/tc-microblaze.c (parse_exp, parse_imm, check_got):
        Change name from new to new_pointer.
        * gas/config/tc-or32.c (parse_operand): Rename variable new to
        new_pointer.
        * gas/config/tc-pdp11.c (md_assemble): Rename variable new to
        new_pointer.
        * gas/config/tc-pj.c (alias): Change argument new to new_name.
        * gas/config/tc-score.c (s3_build_score_ops_hsh): Rename variable
        new to new_opcode. (s3_build_dependency_insn_hsh) Rename variable
        new to new_i2n. (s3_convert): Rename variables old and new to
        r_old and r_new.
        * gas/config/tc-score7.c (s7_build_score_ops_hsh): Rename variable
        new to new_opcode. (s7_build_dependency_insn_hsh): Rename variable
        new to new_i2d. (s7_b32_relax_to_b16, s7_convert_frag): Rename
        variables old and new to r_old and r_new.
        * gas/config/tc-sh.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-sh64.c (shmedia_parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-tic4x.c (tic4x_operand_parse): Rename variable new
        to new_pointer.
        * gas/config/tc-z8k.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/listing.c (listing_newline): Rename variable new to new_i.
        * ld/ldexp.c (exp_intop, exp_bigintop, exp_relop, exp_binop)
        (exp_trinop, exp_unop, exp_nameop, exp_assop): Rename variable new
        to new_e.
        * ld/ldfile.c (ldfile_add_library_path): Rename variable new to
        new_dirs. (ldfile_add_arch): Rename variable new to new_arch.
        * ld/ldlang.c (new_statement, lang_final, lang_add_wild)
        (lang_target, lang_add_fill, lang_add_data, lang_add_assignment)
        (lang_add_insert): Rename variable new to new_stmt. (new_afile):
        Added missing cast. (lang_memory_region_lookup): Rename variable
        new to new_region. (init_os): Rename variable new to
        new_userdata. (lang_add_section): Rename variable new to
        new_section. (ldlang_add_undef): Rename variable new to
        new_undef. (realsymbol): Rename variable new to new_name.
        * opcodes/z8kgen.c (internal, gas): Rename variable new to new_op.

        Updated sources to avoid using the identifier name "template",
        which is a keyword in c++.

        * bfd/elf32-arm.c (struct stub_def): Rename member template to
        template_sequence. (arm_build_one_stub,
        find_stub_size_and_template, arm_size_one_stub, arm_map_one_stub):
        Rename variable template to template_sequence.
        * bfd/elfxx-ia64.c (elfNN_ia64_relax_br, elfNN_ia64_relax_brl):
        Rename variable template to template_val.
        * gas/config/tc-arm.c (struct asm_cond, struct asm_psr, struct
        asm_barrier_opt): Change member template to
        template_name. (md_begin): Update code to reflect new member
        names.
        * gas/config/tc-i386.c (struct templates, struct _i386_insn)
        (match_template, cpu_flags_match, match_reg_size, match_mem_size)
        (operand_size_match, md_begin, i386_print_statistics, pi)
        (build_vex_prefix, md_assemble, parse_insn, optimize_imm)
        (optimize_disp): Updated code to use new names. (parse_insn):
        Added casts.
        * gas/config/tc-ia64.c (dot_template, emit_one_bundle): Updated
        code to use new names.
        * gas/config/tc-score.c (struct s3_asm_opcode): Renamed member
        template to template_name. (s3_parse_16_32_inst, s3_parse_48_inst,
        s3_do_macro_ldst_label, s3_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-score7.c (struct s7_asm_opcode): Renamed member
        template to template_name. (s7_parse_16_32_inst,
        s7_do_macro_ldst_label, s7_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-tic30.c (md_begin, struct tic30_insn)
        (md_assemble): Update code to use new names.
        * gas/config/tc-tic54x.c (struct _tic54x_insn, md_begin)
        (optimize_insn, tic54x_parse_insn, next_line_shows_parallel):
        Update code to use new names.
        * include/opcode/tic30.h (template): Rename type template to
        insn_template. Updated code to use new name.
        * include/opcode/tic54x.h (template): Rename type template to
        insn_template.
        * opcodes/cris-dis.c (bytes_to_skip): Update code to use new name.
        * opcodes/i386-dis.c (putop): Update code to use new name.
        * opcodes/i386-gen.c (process_i386_opcodes): Update code to use
        new name.
        * opcodes/i386-opc.h (struct template): Rename struct template to
        insn_template. Update code accordingly.
        * opcodes/i386-tbl.h (i386_optab): Update type to use new name.
        * opcodes/ia64-dis.c (print_insn_ia64): Rename variable template
        to template_val.
        * opcodes/tic30-dis.c (struct instruction, get_tic30_instruction):
        Update code to use new name.
        * opcodes/tic54x-dis.c (has_lkaddr, get_insn_size)
        (print_parallel_instruction, print_insn_tic54x, tic54x_get_insn):
        Update code to use new name.
        * opcodes/tic54x-opc.c (tic54x_unknown_opcode, tic54x_optab):
        Update type to new name.
@
text
@d11670 1
a11670 1
  char *basec, *bname;
d11682 1
a11682 2
  basec = xstrdup (out_file_name);
  bname = basename (basec);
d11711 1
@


1.207
log
@        PR 10437
        * config/tc-alpha.c: Fix up uses of gas printf like functions so
        that the format string is a constant string.  Add translation
        support to message strings.
        * config/tc-arc.c: Likewise.
        * config/tc-arm.c: Likewise.
        * config/tc-cris.c: Likewise.
        * config/tc-fr30.c: Likewise.
        * config/tc-frv.c: Likewise.
        * config/tc-h8300.c: Likewise.
        * config/tc-hppa.c: Likewise.
        * config/tc-i370.c: Likewise.
        * config/tc-i960.c: Likewise.
        * config/tc-ia64.c: Likewise.
        * config/tc-m32r.c: Likewise.
        * config/tc-mep.c: Likewise.
        * config/tc-mips.c: Likewise.
        * config/tc-moxie.c: Likewise.
        * config/tc-msp430.c: Likewise.
        * config/tc-openrisc.c: Likewise.
        * config/tc-pdp11.c: Likewise.
        * config/tc-pj.c: Likewise.
        * config/tc-s390.c: Likewise.
        * config/tc-sh.c: Likewise.
        * config/tc-sh64.c: Likewise.
        * config/tc-sparc.c: Likewise.
        * config/tc-spu.c: Likewise.
        * config/tc-tic30.c: Likewise.
        * config/tc-tic4x.c: Likewise.
        * config/tc-tic54x.c: Likewise.
        * config/tc-v850.c: Likewise.
        * config/tc-xc16x.c: Likewise.
        * config/tc-xstormy16.c: Likewise.
        * config/tc-z80.c: Likewise.
        * config/tc-z8k.c: Likewise.
        * config/atof-ieee.c: Add translation support to as_warn
        messages.
        * config/obj-coff.c: Likewise.
@
text
@d4424 1
a4424 1
dot_template (int template)
d4426 1
a4426 1
  CURR_SLOT.user_template = template;
d6321 1
a6321 1
  unsigned int template, orig_template;
d6343 1
a6343 1
    user_template = template = md.slot[first].user_template;
d6356 1
a6356 1
      template = best_template[type[0]][type[1]][type[2]];
d6361 1
a6361 1
    insn[i] = nop[ia64_templ_desc[template].exec_unit[i]];
d6455 1
a6455 1
	  required_template = template;
d6479 1
a6479 1
		      && (template ^ required_template) > 1)))
d6492 1
a6492 1
	  if (required_template != template)
d6505 1
a6505 1
	  template = required_template;
d6525 1
a6525 1
	  orig_template = template;
d6528 1
a6528 1
			     && (ia64_templ_desc[template].exec_unit[0]
d6531 1
a6531 1
	      template = 5;
d6536 1
a6536 1
				  && (ia64_templ_desc[template].exec_unit[1]
d6549 1
a6549 1
	      template = 1;
d6561 1
a6561 1
	  if (template != orig_template)
d6567 1
a6567 1
	      insn[j] = nop[ia64_templ_desc[template].exec_unit[j]];
d6569 1
a6569 1
      required_unit = ia64_templ_desc[template].exec_unit[i];
d6610 1
a6610 1
		  || (required_unit == IA64_UNIT_F && template == 6))
d6738 1
a6738 1
		    idesc->name, ia64_templ_desc[template].name);
d6757 1
a6757 1
	      if (template == 2)
d6765 1
a6765 1
			    idesc->name, where, ia64_templ_desc[template].name);
d6775 1
a6775 1
  t0 = end_of_insn_group | (template << 1) | (insn[0] << 5) | (insn[1] << 46);
d10864 1
a10864 1
  bfd_reloc_code_real_type new = 0;
d10877 5
a10881 5
	case BFD_RELOC_IA64_IMM64:	new = BFD_RELOC_IA64_FPTR64I; break;
	case BFD_RELOC_IA64_DIR32MSB:	new = BFD_RELOC_IA64_FPTR32MSB; break;
	case BFD_RELOC_IA64_DIR32LSB:	new = BFD_RELOC_IA64_FPTR32LSB; break;
	case BFD_RELOC_IA64_DIR64MSB:	new = BFD_RELOC_IA64_FPTR64MSB; break;
	case BFD_RELOC_IA64_DIR64LSB:	new = BFD_RELOC_IA64_FPTR64LSB; break;
d10889 6
a10894 6
	case BFD_RELOC_IA64_IMM22:	new = BFD_RELOC_IA64_GPREL22; break;
	case BFD_RELOC_IA64_IMM64:	new = BFD_RELOC_IA64_GPREL64I; break;
	case BFD_RELOC_IA64_DIR32MSB:	new = BFD_RELOC_IA64_GPREL32MSB; break;
	case BFD_RELOC_IA64_DIR32LSB:	new = BFD_RELOC_IA64_GPREL32LSB; break;
	case BFD_RELOC_IA64_DIR64MSB:	new = BFD_RELOC_IA64_GPREL64MSB; break;
	case BFD_RELOC_IA64_DIR64LSB:	new = BFD_RELOC_IA64_GPREL64LSB; break;
d10902 2
a10903 2
	case BFD_RELOC_IA64_IMM22:	new = BFD_RELOC_IA64_LTOFF22; break;
	case BFD_RELOC_IA64_IMM64:	new = BFD_RELOC_IA64_LTOFF64I; break;
d10911 1
a10911 1
	case BFD_RELOC_IA64_IMM22:	new = BFD_RELOC_IA64_LTOFF22X; break;
d10919 6
a10924 6
	case BFD_RELOC_IA64_IMM22:	new = BFD_RELOC_IA64_PCREL22; break;
	case BFD_RELOC_IA64_IMM64:	new = BFD_RELOC_IA64_PCREL64I; break;
	case BFD_RELOC_IA64_DIR32MSB:	new = BFD_RELOC_IA64_PCREL32MSB; break;
	case BFD_RELOC_IA64_DIR32LSB:	new = BFD_RELOC_IA64_PCREL32LSB; break;
	case BFD_RELOC_IA64_DIR64MSB:	new = BFD_RELOC_IA64_PCREL64MSB; break;
	case BFD_RELOC_IA64_DIR64LSB:	new = BFD_RELOC_IA64_PCREL64LSB; break;
d10932 4
a10935 4
	case BFD_RELOC_IA64_IMM22:	new = BFD_RELOC_IA64_PLTOFF22; break;
	case BFD_RELOC_IA64_IMM64:	new = BFD_RELOC_IA64_PLTOFF64I; break;
	case BFD_RELOC_IA64_DIR64MSB:	new = BFD_RELOC_IA64_PLTOFF64MSB;break;
	case BFD_RELOC_IA64_DIR64LSB:	new = BFD_RELOC_IA64_PLTOFF64LSB;break;
d10943 4
a10946 4
	case BFD_RELOC_IA64_DIR32MSB:	new = BFD_RELOC_IA64_SECREL32MSB;break;
	case BFD_RELOC_IA64_DIR32LSB:	new = BFD_RELOC_IA64_SECREL32LSB;break;
	case BFD_RELOC_IA64_DIR64MSB:	new = BFD_RELOC_IA64_SECREL64MSB;break;
	case BFD_RELOC_IA64_DIR64LSB:	new = BFD_RELOC_IA64_SECREL64LSB;break;
d10954 4
a10957 4
	case BFD_RELOC_IA64_DIR32MSB:	new = BFD_RELOC_IA64_SEGREL32MSB;break;
	case BFD_RELOC_IA64_DIR32LSB:	new = BFD_RELOC_IA64_SEGREL32LSB;break;
	case BFD_RELOC_IA64_DIR64MSB:	new = BFD_RELOC_IA64_SEGREL64MSB;break;
	case BFD_RELOC_IA64_DIR64LSB:	new = BFD_RELOC_IA64_SEGREL64LSB;break;
d10965 4
a10968 4
	case BFD_RELOC_IA64_DIR32MSB:	new = BFD_RELOC_IA64_LTV32MSB; break;
	case BFD_RELOC_IA64_DIR32LSB:	new = BFD_RELOC_IA64_LTV32LSB; break;
	case BFD_RELOC_IA64_DIR64MSB:	new = BFD_RELOC_IA64_LTV64MSB; break;
	case BFD_RELOC_IA64_DIR64LSB:	new = BFD_RELOC_IA64_LTV64LSB; break;
d10977 1
a10977 1
	  new = BFD_RELOC_IA64_LTOFF_FPTR22; break;
d10979 1
a10979 1
	  new = BFD_RELOC_IA64_LTOFF_FPTR64I; break;
d10981 1
a10981 1
	  new = BFD_RELOC_IA64_LTOFF_FPTR32MSB; break;
d10983 1
a10983 1
	  new = BFD_RELOC_IA64_LTOFF_FPTR32LSB; break;
d10985 1
a10985 1
	  new = BFD_RELOC_IA64_LTOFF_FPTR64MSB; break;
d10987 1
a10987 1
	  new = BFD_RELOC_IA64_LTOFF_FPTR64LSB; break;
d10996 5
a11000 5
	case BFD_RELOC_IA64_IMM14:      new = BFD_RELOC_IA64_TPREL14; break;
	case BFD_RELOC_IA64_IMM22:      new = BFD_RELOC_IA64_TPREL22; break;
	case BFD_RELOC_IA64_IMM64:      new = BFD_RELOC_IA64_TPREL64I; break;
	case BFD_RELOC_IA64_DIR64MSB:   new = BFD_RELOC_IA64_TPREL64MSB; break;
	case BFD_RELOC_IA64_DIR64LSB:   new = BFD_RELOC_IA64_TPREL64LSB; break;
d11009 1
a11009 1
	  new = BFD_RELOC_IA64_LTOFF_TPREL22; break;
d11019 1
a11019 1
	  new = BFD_RELOC_IA64_DTPMOD64MSB; break;
d11021 1
a11021 1
	  new = BFD_RELOC_IA64_DTPMOD64LSB; break;
d11031 1
a11031 1
	  new = BFD_RELOC_IA64_LTOFF_DTPMOD22; break;
d11041 1
a11041 1
	  new = BFD_RELOC_IA64_DTPREL32MSB; break;
d11043 1
a11043 1
	  new = BFD_RELOC_IA64_DTPREL32LSB; break;
d11045 1
a11045 1
	  new = BFD_RELOC_IA64_DTPREL64MSB; break;
d11047 1
a11047 1
	  new = BFD_RELOC_IA64_DTPREL64LSB; break;
d11049 1
a11049 1
	  new = BFD_RELOC_IA64_DTPREL14; break;
d11051 1
a11051 1
	  new = BFD_RELOC_IA64_DTPREL22; break;
d11053 1
a11053 1
	  new = BFD_RELOC_IA64_DTPREL64I; break;
d11063 1
a11063 1
	  new = BFD_RELOC_IA64_LTOFF_DTPREL22; break;
d11082 2
a11083 2
  if (new)
    return new;
@


1.206
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d11163 1
a11163 1
	err = "integer operand out of range";
@


1.205
log
@        PR 9874
        * config/tc-ia64.c (fix_insn): Fix warning reported by
        -Wformat-security.
@
text
@d2820 1
a2820 1
  assert (frag->fr_var >= size);
d2851 1
a2851 1
  assert (frag->fr_var >= size);
d5889 1
a5889 1
  assert (strlen (idesc->name) <= 128);
d6213 1
a6213 1
	  assert (idesc->operands[i] == IA64_OPND_IMM8M1U8);
@


1.204
log
@        * include/elf/ia64.h (SHT_IA_64_VMS_DISPLAY_NAME_INFO,
        EF_IA_64_ARCHVER_1): New macros. Minor reformatting.

        * bfd/Makefile.am (BFD32_BACKENDS): Add new object vmsutil.lo
        (BFD32_BACKENDS_CFILES): Add new file vmsutil.c
        (vmsutil.lo): Add dependency rule
        * bfd/Makefile.in: Regenerate
        * bfd/config.bfd (ia64*-*-*vms*): Add case.
        * bfd/configure.in (bfd_elf64_ia64_vms_vec): Add case.
        * bfd/configure: Regenerate
        * bfd/vmsutil.[ch]: New files
        * bfd/elf-bfd.h (struct bfd_elf_special_section): Change type of
        attr to bfd_vma.
        * bfd/elfxx-ia64.c (elfNN_vms_post_process_headers,
        elfNN_vms_section_processing, elfNN_vms_final_write_processing,
        elfNN_vms_close_and_cleanup, elfNN_vms_section_from_shdr,
        elfNN_vms_object_p): New functions
        * bfd/targets.c (bfd_elf64_ia64_vms_vec): New target.

        * gas/configure.tgt(ia64-*-*vms*): New target.
        * gas/dwarf2dbg.h (dwarf2_loc_mark_labels): Make extern.
        * gas/tc.h (md_number_to_chars): Declare iff undefined.
        * gas/config/obj-elf.c (obj_elf_change_section): Change type of
        arg attr to bfd_vma.
        (obj_elf_parse_section_letters): Return a bfd_vma. Change type of
        variables attr, md_attr to bfd_vma.
        (obj_elf_section_word): Likewise.
        (obj_elf_section): Change type of variable attr to bfd_vma
        * gas/config/obj-elf.h (obj_elf_change_section): Change type of
        arg attr to bfd_vma
        * gas/config/tc-ia64.c (bfdver.h,time.h): Include.
        (ia64_elf_section_letter): Now returns a bfd_vma.
        Handle VMS specific attributes.
        (ia64_elf_section_flags): Arg attr now a bfd_vma.
        (ia64_init): Don't turn on dependency checking for VMS.
        (ia64_target_format): Check for VMS flag bit.
        (do_alias): Hande decc$ functions.
        (get_vms_time): New function.
        (ia64_vms_note): New function.
        * gas/config/tc-ia64.h (ia64_elf_section_letter): Now returns a bfd_vma.
        (ia64_elf_section_flags): Arg attr now a bfd_vma.
        (tc_init_after_args): Define for VMS.
        * gas/config/tc-alpha.c (alpha_elf_section_letter): Return a bfd_vma.
        (alpha_elf_section_flags): Change type of arg attr to bfd_vma.
        * gas/config/tc-alpha.h: Likewise.
        * gas/config/tc-i386.c (x86_64_section_letter): Return a bfd_vma.
        (x86_64_section_word): Return a bfd_vma.
        * gas/config/tc-i386.h: Likewise.
        * gas/config/tc-ip2k.c (ip2k_elf_section_flags): Change type of arg
        attr to bfd_vma.
        * gas/config/tc-ip2k.h: Likewise.
        * gas/config/tc-mep.c (mep_elf_section_letter): Return a bfd_vma.
        (mep_elf_section_flags): Change type of arg attr to bfd_vma.
        * gas/config/tc-mep.h: Likewise.
        * gas/config/tc-ppc.c  (ppc_section_letter): Return a bfd_vma.
        (ppc_section_word): Return a bfd_vma.
        (ppc_section_flags): Change type of arg attr to bfd_vma.
        * gas/config/tc-ppc.h: Likewise.
        * gas/config/te-vms.h (DWARF2_DIR_SHOULD_END_WITH_SEPARATOR,
        DWAR2_FILE_TIME_NAME, DWARF2_FILE_SIZE_NAME, DWARF2_FILEN_NAME):
        New file with new macros
        * gas/dwarf2dbg.c (get_filenum, out_file_list): Default and call new
        macros.
@
text
@d11178 1
a11178 1
    as_bad_where (fix->fx_file, fix->fx_line, err);
@


1.203
log
@gas/

2008-08-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-ia64.c (CR_IIB0): New.
	(CR_IIB1): Likewise.
	(cr): Add cr.iib0 and cr.iib1.
	(specify_resource): Handle IA64_RS_CR_IIB and CR_IIB0/CR_IIB1.

gas/testsuite/

2008-08-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/ia64/dv-raw-err.s: Add tests for cr.iib0 and cr.iib1.
	* gas/ia64/dv-waw-err.s: Likewise.
	* gas/ia64/regs.s: Likewise.

	* gas/ia64/dv-raw-err.l: Updated.
	* gas/ia64/dv-waw-err.l: Likewise.
	* gas/ia64/regs.d: Likewise.

include/opcode/

2008-08-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* ia64.h (ia64_resource_specifier): Add IA64_RS_CR_IIB.  Update
	IA64_RS_CR.

opcodes/

2008-08-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* ia64-dis.c (print_insn_ia64): Handle cr.iib0 and cr.iib1.
	* ia64-gen.c (lookup_specifier): Likewise.

	* ia64-ic.tbl: Add support for cr.iib0 and cr.iib1.
	* ia64-raw.tbl: Likewise.
	* ia64-waw.tbl: Likewise.
	* ia64-asmtab.c: Regenerated.
@
text
@d2 2
a3 2
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
   Free Software Foundation, Inc.
d53 2
d839 1
a839 1
int
d846 6
d861 1
a861 1
			int attr,
d7308 2
d7311 1
d7347 1
a7347 1
#ifdef TE_AIX50
d7349 5
d11594 11
a11604 3
    as_warn_where (h->file, h->line,
		   _("symbol `%s' aliased to `%s' is not used"),
		   h->name, alias);
d11637 135
@


1.202
log
@Banish PARAMS and PTR.  Convert to ISO C.
Delete unnecessary forward declarations.
@
text
@d411 2
d446 2
d8424 17
d8872 2
@


1.201
log
@	* config/tc-arm.c (s_unreq): Adjust hash_delete call.
	* config/tc-ia64.c (dot_rot): Likewise.
@
text
@d170 1
a170 1
void (*ia64_number_to_chars) PARAMS ((char *, valueT, int));
d172 4
a175 6
static void ia64_float_to_chars_bigendian
  PARAMS ((char *, LITTLENUM_TYPE *, int));
static void ia64_float_to_chars_littleendian
  PARAMS ((char *, LITTLENUM_TYPE *, int));
static void (*ia64_float_to_chars)
  PARAMS ((char *, LITTLENUM_TYPE *, int));
d777 1
a777 1
typedef void (*vbyte_func) PARAMS ((int, char *, char *));
d780 17
a796 202
static void set_section PARAMS ((char *name));
static unsigned int set_regstack PARAMS ((unsigned int, unsigned int,
					  unsigned int, unsigned int));
static void dot_align (int);
static void dot_radix PARAMS ((int));
static void dot_special_section PARAMS ((int));
static void dot_proc PARAMS ((int));
static void dot_fframe PARAMS ((int));
static void dot_vframe PARAMS ((int));
static void dot_vframesp PARAMS ((int));
static void dot_save PARAMS ((int));
static void dot_restore PARAMS ((int));
static void dot_restorereg PARAMS ((int));
static void dot_handlerdata  PARAMS ((int));
static void dot_unwentry PARAMS ((int));
static void dot_altrp PARAMS ((int));
static void dot_savemem PARAMS ((int));
static void dot_saveg PARAMS ((int));
static void dot_savef PARAMS ((int));
static void dot_saveb PARAMS ((int));
static void dot_savegf PARAMS ((int));
static void dot_spill PARAMS ((int));
static void dot_spillreg PARAMS ((int));
static void dot_spillmem PARAMS ((int));
static void dot_label_state PARAMS ((int));
static void dot_copy_state PARAMS ((int));
static void dot_unwabi PARAMS ((int));
static void dot_personality PARAMS ((int));
static void dot_body PARAMS ((int));
static void dot_prologue PARAMS ((int));
static void dot_endp PARAMS ((int));
static void dot_template PARAMS ((int));
static void dot_regstk PARAMS ((int));
static void dot_rot PARAMS ((int));
static void dot_byteorder PARAMS ((int));
static void dot_psr PARAMS ((int));
static void dot_alias PARAMS ((int));
static void dot_ln PARAMS ((int));
static void cross_section PARAMS ((int ref, void (*cons) PARAMS((int)), int ua));
static void dot_xdata PARAMS ((int));
static void stmt_float_cons PARAMS ((int));
static void stmt_cons_ua PARAMS ((int));
static void dot_xfloat_cons PARAMS ((int));
static void dot_xstringer PARAMS ((int));
static void dot_xdata_ua PARAMS ((int));
static void dot_xfloat_cons_ua PARAMS ((int));
static void print_prmask PARAMS ((valueT mask));
static void dot_pred_rel PARAMS ((int));
static void dot_reg_val PARAMS ((int));
static void dot_serialize PARAMS ((int));
static void dot_dv_mode PARAMS ((int));
static void dot_entry PARAMS ((int));
static void dot_mem_offset PARAMS ((int));
static void add_unwind_entry PARAMS((unw_rec_list *, int));
static symbolS *declare_register PARAMS ((const char *name, unsigned int regnum));
static void declare_register_set PARAMS ((const char *, unsigned int, unsigned int));
static unsigned int operand_width PARAMS ((enum ia64_opnd));
static enum operand_match_result operand_match PARAMS ((const struct ia64_opcode *idesc,
							int index,
							expressionS *e));
static int parse_operand PARAMS ((expressionS *, int));
static struct ia64_opcode * parse_operands PARAMS ((struct ia64_opcode *));
static void build_insn PARAMS ((struct slot *, bfd_vma *));
static void emit_one_bundle PARAMS ((void));
static void fix_insn PARAMS ((fixS *, const struct ia64_operand *, valueT));
static bfd_reloc_code_real_type ia64_gen_real_reloc_type PARAMS ((struct symbol *sym,
								  bfd_reloc_code_real_type r_type));
static void insn_group_break PARAMS ((int, int, int));
static void mark_resource PARAMS ((struct ia64_opcode *, const struct ia64_dependency *,
				   struct rsrc *, int depind, int path));
static void add_qp_mutex PARAMS((valueT mask));
static void add_qp_imply PARAMS((int p1, int p2));
static void clear_qp_branch_flag PARAMS((valueT mask));
static void clear_qp_mutex PARAMS((valueT mask));
static void clear_qp_implies PARAMS((valueT p1_mask, valueT p2_mask));
static int has_suffix_p PARAMS((const char *, const char *));
static void clear_register_values PARAMS ((void));
static void print_dependency PARAMS ((const char *action, int depind));
static void instruction_serialization PARAMS ((void));
static void data_serialization PARAMS ((void));
static void remove_marked_resource PARAMS ((struct rsrc *));
static int is_conditional_branch PARAMS ((struct ia64_opcode *));
static int is_taken_branch PARAMS ((struct ia64_opcode *));
static int is_interruption_or_rfi PARAMS ((struct ia64_opcode *));
static int depends_on PARAMS ((int, struct ia64_opcode *));
static int specify_resource PARAMS ((const struct ia64_dependency *,
				     struct ia64_opcode *, int, struct rsrc [], int, int));
static int check_dv PARAMS((struct ia64_opcode *idesc));
static void check_dependencies PARAMS((struct ia64_opcode *));
static void mark_resources PARAMS((struct ia64_opcode *));
static void update_dependencies PARAMS((struct ia64_opcode *));
static void note_register_values PARAMS((struct ia64_opcode *));
static int qp_mutex PARAMS ((int, int, int));
static int resources_match PARAMS ((struct rsrc *, struct ia64_opcode *, int, int, int));
static void output_vbyte_mem PARAMS ((int, char *, char *));
static void count_output PARAMS ((int, char *, char *));
static void output_R1_format PARAMS ((vbyte_func, unw_record_type, int));
static void output_R2_format PARAMS ((vbyte_func, int, int, unsigned long));
static void output_R3_format PARAMS ((vbyte_func, unw_record_type, unsigned long));
static void output_P1_format PARAMS ((vbyte_func, int));
static void output_P2_format PARAMS ((vbyte_func, int, int));
static void output_P3_format PARAMS ((vbyte_func, unw_record_type, int));
static void output_P4_format PARAMS ((vbyte_func, unsigned char *, unsigned long));
static void output_P5_format PARAMS ((vbyte_func, int, unsigned long));
static void output_P6_format PARAMS ((vbyte_func, unw_record_type, int));
static void output_P7_format PARAMS ((vbyte_func, unw_record_type, unsigned long, unsigned long));
static void output_P8_format PARAMS ((vbyte_func, unw_record_type, unsigned long));
static void output_P9_format PARAMS ((vbyte_func, int, int));
static void output_P10_format PARAMS ((vbyte_func, int, int));
static void output_B1_format PARAMS ((vbyte_func, unw_record_type, unsigned long));
static void output_B2_format PARAMS ((vbyte_func, unsigned long, unsigned long));
static void output_B3_format PARAMS ((vbyte_func, unsigned long, unsigned long));
static void output_B4_format PARAMS ((vbyte_func, unw_record_type, unsigned long));
static char format_ab_reg PARAMS ((int, int));
static void output_X1_format PARAMS ((vbyte_func, unw_record_type, int, int, unsigned long,
				      unsigned long));
static void output_X2_format PARAMS ((vbyte_func, int, int, int, int, int, unsigned long));
static void output_X3_format PARAMS ((vbyte_func, unw_record_type, int, int, int, unsigned long,
				      unsigned long));
static void output_X4_format PARAMS ((vbyte_func, int, int, int, int, int, int, unsigned long));
static unw_rec_list *output_endp PARAMS ((void));
static unw_rec_list *output_prologue PARAMS ((void));
static unw_rec_list *output_prologue_gr PARAMS ((unsigned int, unsigned int));
static unw_rec_list *output_body PARAMS ((void));
static unw_rec_list *output_mem_stack_f PARAMS ((unsigned int));
static unw_rec_list *output_mem_stack_v PARAMS ((void));
static unw_rec_list *output_psp_gr PARAMS ((unsigned int));
static unw_rec_list *output_psp_sprel PARAMS ((unsigned int));
static unw_rec_list *output_rp_when PARAMS ((void));
static unw_rec_list *output_rp_gr PARAMS ((unsigned int));
static unw_rec_list *output_rp_br PARAMS ((unsigned int));
static unw_rec_list *output_rp_psprel PARAMS ((unsigned int));
static unw_rec_list *output_rp_sprel PARAMS ((unsigned int));
static unw_rec_list *output_pfs_when PARAMS ((void));
static unw_rec_list *output_pfs_gr PARAMS ((unsigned int));
static unw_rec_list *output_pfs_psprel PARAMS ((unsigned int));
static unw_rec_list *output_pfs_sprel PARAMS ((unsigned int));
static unw_rec_list *output_preds_when PARAMS ((void));
static unw_rec_list *output_preds_gr PARAMS ((unsigned int));
static unw_rec_list *output_preds_psprel PARAMS ((unsigned int));
static unw_rec_list *output_preds_sprel PARAMS ((unsigned int));
static unw_rec_list *output_fr_mem PARAMS ((unsigned int));
static unw_rec_list *output_frgr_mem PARAMS ((unsigned int, unsigned int));
static unw_rec_list *output_gr_gr PARAMS ((unsigned int, unsigned int));
static unw_rec_list *output_gr_mem PARAMS ((unsigned int));
static unw_rec_list *output_br_mem PARAMS ((unsigned int));
static unw_rec_list *output_br_gr PARAMS ((unsigned int, unsigned int));
static unw_rec_list *output_spill_base PARAMS ((unsigned int));
static unw_rec_list *output_unat_when PARAMS ((void));
static unw_rec_list *output_unat_gr PARAMS ((unsigned int));
static unw_rec_list *output_unat_psprel PARAMS ((unsigned int));
static unw_rec_list *output_unat_sprel PARAMS ((unsigned int));
static unw_rec_list *output_lc_when PARAMS ((void));
static unw_rec_list *output_lc_gr PARAMS ((unsigned int));
static unw_rec_list *output_lc_psprel PARAMS ((unsigned int));
static unw_rec_list *output_lc_sprel PARAMS ((unsigned int));
static unw_rec_list *output_fpsr_when PARAMS ((void));
static unw_rec_list *output_fpsr_gr PARAMS ((unsigned int));
static unw_rec_list *output_fpsr_psprel PARAMS ((unsigned int));
static unw_rec_list *output_fpsr_sprel PARAMS ((unsigned int));
static unw_rec_list *output_priunat_when_gr PARAMS ((void));
static unw_rec_list *output_priunat_when_mem PARAMS ((void));
static unw_rec_list *output_priunat_gr PARAMS ((unsigned int));
static unw_rec_list *output_priunat_psprel PARAMS ((unsigned int));
static unw_rec_list *output_priunat_sprel PARAMS ((unsigned int));
static unw_rec_list *output_bsp_when PARAMS ((void));
static unw_rec_list *output_bsp_gr PARAMS ((unsigned int));
static unw_rec_list *output_bsp_psprel PARAMS ((unsigned int));
static unw_rec_list *output_bsp_sprel PARAMS ((unsigned int));
static unw_rec_list *output_bspstore_when PARAMS ((void));
static unw_rec_list *output_bspstore_gr PARAMS ((unsigned int));
static unw_rec_list *output_bspstore_psprel PARAMS ((unsigned int));
static unw_rec_list *output_bspstore_sprel PARAMS ((unsigned int));
static unw_rec_list *output_rnat_when PARAMS ((void));
static unw_rec_list *output_rnat_gr PARAMS ((unsigned int));
static unw_rec_list *output_rnat_psprel PARAMS ((unsigned int));
static unw_rec_list *output_rnat_sprel PARAMS ((unsigned int));
static unw_rec_list *output_unwabi PARAMS ((unsigned long, unsigned long));
static unw_rec_list *output_epilogue PARAMS ((unsigned long));
static unw_rec_list *output_label_state PARAMS ((unsigned long));
static unw_rec_list *output_copy_state PARAMS ((unsigned long));
static unw_rec_list *output_spill_psprel PARAMS ((unsigned int, unsigned int, unsigned int,
						    unsigned int));
static unw_rec_list *output_spill_sprel PARAMS ((unsigned int, unsigned int, unsigned int,
						   unsigned int));
static unw_rec_list *output_spill_reg PARAMS ((unsigned int, unsigned int, unsigned int,
						 unsigned int, unsigned int));
static void process_one_record PARAMS ((unw_rec_list *, vbyte_func));
static void process_unw_records PARAMS ((unw_rec_list *, vbyte_func));
static int calc_record_size PARAMS ((unw_rec_list *));
static void set_imask PARAMS ((unw_rec_list *, unsigned long, unsigned long, unsigned int));
static unsigned long slot_index PARAMS ((unsigned long, fragS *,
					 unsigned long, fragS *,
					 int));
static unw_rec_list *optimize_unw_records PARAMS ((unw_rec_list *));
static void fixup_unw_records PARAMS ((unw_rec_list *, int));
static int parse_predicate_and_operand PARAMS ((expressionS *, unsigned *, const char *));
static void convert_expr_to_ab_reg PARAMS ((const expressionS *, unsigned int *, unsigned int *, const char *, int));
static void convert_expr_to_xy_reg PARAMS ((const expressionS *, unsigned int *, unsigned int *, const char *, int));
static unsigned int get_saved_prologue_count PARAMS ((unsigned long));
static void save_prologue_count PARAMS ((unsigned long, unsigned int));
static void free_saved_prologue_counts PARAMS ((void));
d821 1
a821 2
set_section (name)
     char *name;
d834 1
a834 3
ia64_elf_section_letter (letter, ptr_msg)
     int letter;
     char **ptr_msg;
d848 3
a850 3
ia64_elf_section_flags (flags, attr, type)
     flagword flags;
     int attr, type ATTRIBUTE_UNUSED;
d858 1
a858 3
ia64_elf_section_type (str, len)
     const char *str;
     size_t len;
d882 4
a885 2
set_regstack (ins, locs, outs, rots)
     unsigned int ins, locs, outs, rots;
d913 1
a913 1
ia64_flush_insns ()
d1008 1
a1008 2
ia64_cons_align (nbytes)
     int nbytes;
d1022 2
a1023 5
void
output_vbyte_mem (count, ptr, comment)
     int count;
     char *ptr;
     char *comment ATTRIBUTE_UNUSED;
d1037 4
a1040 5
void
count_output (count, ptr, comment)
     int count;
     char *ptr ATTRIBUTE_UNUSED;
     char *comment ATTRIBUTE_UNUSED;
d1046 1
a1046 4
output_R1_format (f, rtype, rlen)
     vbyte_func f;
     unw_record_type rtype;
     int rlen;
d1066 1
a1066 4
output_R2_format (f, mask, grsave, rlen)
     vbyte_func f;
     int mask, grsave;
     unsigned long rlen;
d1080 1
a1080 4
output_R3_format (f, rtype, rlen)
     vbyte_func f;
     unw_record_type rtype;
     unsigned long rlen;
d1100 1
a1100 3
output_P1_format (f, brmask)
     vbyte_func f;
     int brmask;
d1108 1
a1108 4
output_P2_format (f, brmask, gr)
     vbyte_func f;
     int brmask;
     int gr;
d1118 1
a1118 4
output_P3_format (f, rtype, reg)
     vbyte_func f;
     unw_record_type rtype;
     int reg;
d1170 1
a1170 4
output_P4_format (f, imask, imask_size)
     vbyte_func f;
     unsigned char *imask;
     unsigned long imask_size;
d1177 1
a1177 4
output_P5_format (f, grmask, frmask)
     vbyte_func f;
     int grmask;
     unsigned long frmask;
d1190 1
a1190 4
output_P6_format (f, rtype, rmask)
     vbyte_func f;
     unw_record_type rtype;
     int rmask;
d1204 4
a1207 5
output_P7_format (f, rtype, w1, w2)
     vbyte_func f;
     unw_record_type rtype;
     unsigned long w1;
     unsigned long w2;
d1272 1
a1272 4
output_P8_format (f, rtype, t)
     vbyte_func f;
     unw_record_type rtype;
     unsigned long t;
d1346 1
a1346 4
output_P9_format (f, grmask, gr)
     vbyte_func f;
     int grmask;
     int gr;
d1356 1
a1356 4
output_P10_format (f, abi, context)
     vbyte_func f;
     int abi;
     int context;
d1366 1
a1366 4
output_B1_format (f, rtype, label)
     vbyte_func f;
     unw_record_type rtype;
     unsigned long label;
d1385 1
a1385 4
output_B2_format (f, ecount, t)
     vbyte_func f;
     unsigned long ecount;
     unsigned long t;
d1400 1
a1400 4
output_B3_format (f, ecount, t)
     vbyte_func f;
     unsigned long ecount;
     unsigned long t;
d1416 1
a1416 4
output_B4_format (f, rtype, label)
     vbyte_func f;
     unw_record_type rtype;
     unsigned long label;
d1438 1
a1438 3
format_ab_reg (ab, reg)
     int ab;
     int reg;
d1448 6
a1453 6
output_X1_format (f, rtype, ab, reg, t, w1)
     vbyte_func f;
     unw_record_type rtype;
     int ab, reg;
     unsigned long t;
     unsigned long w1;
d1471 7
a1477 5
output_X2_format (f, ab, reg, x, y, treg, t)
     vbyte_func f;
     int ab, reg;
     int x, y, treg;
     unsigned long t;
d1489 7
a1495 7
output_X3_format (f, rtype, qp, ab, reg, t, w1)
     vbyte_func f;
     unw_record_type rtype;
     int qp;
     int ab, reg;
     unsigned long t;
     unsigned long w1;
d1514 8
a1521 6
output_X4_format (f, qp, ab, reg, x, y, treg, t)
     vbyte_func f;
     int qp;
     int ab, reg;
     int x, y, treg;
     unsigned long t;
d1599 1
a1599 1
output_endp ()
d1606 1
a1606 1
output_prologue ()
d1614 1
a1614 3
output_prologue_gr (saved_mask, reg)
     unsigned int saved_mask;
     unsigned int reg;
d1624 1
a1624 1
output_body ()
d1631 1
a1631 2
output_mem_stack_f (size)
     unsigned int size;
d1639 1
a1639 1
output_mem_stack_v ()
d1646 1
a1646 2
output_psp_gr (gr)
     unsigned int gr;
d1654 1
a1654 2
output_psp_sprel (offset)
     unsigned int offset;
d1662 1
a1662 1
output_rp_when ()
d1669 1
a1669 2
output_rp_gr (gr)
     unsigned int gr;
d1677 1
a1677 2
output_rp_br (br)
     unsigned int br;
d1685 1
a1685 2
output_rp_psprel (offset)
     unsigned int offset;
d1693 1
a1693 2
output_rp_sprel (offset)
     unsigned int offset;
d1701 1
a1701 1
output_pfs_when ()
d1708 1
a1708 2
output_pfs_gr (gr)
     unsigned int gr;
d1716 1
a1716 2
output_pfs_psprel (offset)
     unsigned int offset;
d1724 1
a1724 2
output_pfs_sprel (offset)
     unsigned int offset;
d1732 1
a1732 1
output_preds_when ()
d1739 1
a1739 2
output_preds_gr (gr)
     unsigned int gr;
d1747 1
a1747 2
output_preds_psprel (offset)
     unsigned int offset;
d1755 1
a1755 2
output_preds_sprel (offset)
     unsigned int offset;
d1763 1
a1763 2
output_fr_mem (mask)
     unsigned int mask;
d1787 1
a1787 3
output_frgr_mem (gr_mask, fr_mask)
     unsigned int gr_mask;
     unsigned int fr_mask;
d1826 1
a1826 3
output_gr_gr (mask, reg)
     unsigned int mask;
     unsigned int reg;
d1853 1
a1853 2
output_gr_mem (mask)
     unsigned int mask;
d1901 1
a1901 3
output_br_gr (mask, reg)
     unsigned int mask;
     unsigned int reg;
d1928 1
a1928 2
output_spill_base (offset)
     unsigned int offset;
d1936 1
a1936 1
output_unat_when ()
d1943 1
a1943 2
output_unat_gr (gr)
     unsigned int gr;
d1951 1
a1951 2
output_unat_psprel (offset)
     unsigned int offset;
d1959 1
a1959 2
output_unat_sprel (offset)
     unsigned int offset;
d1967 1
a1967 1
output_lc_when ()
d1974 1
a1974 2
output_lc_gr (gr)
     unsigned int gr;
d1982 1
a1982 2
output_lc_psprel (offset)
     unsigned int offset;
d1990 1
a1990 2
output_lc_sprel (offset)
     unsigned int offset;
d1998 1
a1998 1
output_fpsr_when ()
d2005 1
a2005 2
output_fpsr_gr (gr)
     unsigned int gr;
d2013 1
a2013 2
output_fpsr_psprel (offset)
     unsigned int offset;
d2021 1
a2021 2
output_fpsr_sprel (offset)
     unsigned int offset;
d2029 1
a2029 1
output_priunat_when_gr ()
d2036 1
a2036 1
output_priunat_when_mem ()
d2043 1
a2043 2
output_priunat_gr (gr)
     unsigned int gr;
d2051 1
a2051 2
output_priunat_psprel (offset)
     unsigned int offset;
d2059 1
a2059 2
output_priunat_sprel (offset)
     unsigned int offset;
d2067 1
a2067 1
output_bsp_when ()
d2074 1
a2074 2
output_bsp_gr (gr)
     unsigned int gr;
d2082 1
a2082 2
output_bsp_psprel (offset)
     unsigned int offset;
d2090 1
a2090 2
output_bsp_sprel (offset)
     unsigned int offset;
d2098 1
a2098 1
output_bspstore_when ()
d2105 1
a2105 2
output_bspstore_gr (gr)
     unsigned int gr;
d2113 1
a2113 2
output_bspstore_psprel (offset)
     unsigned int offset;
d2121 1
a2121 2
output_bspstore_sprel (offset)
     unsigned int offset;
d2129 1
a2129 1
output_rnat_when ()
d2136 1
a2136 2
output_rnat_gr (gr)
     unsigned int gr;
d2144 1
a2144 2
output_rnat_psprel (offset)
     unsigned int offset;
d2152 1
a2152 2
output_rnat_sprel (offset)
     unsigned int offset;
d2160 1
a2160 3
output_unwabi (abi, context)
     unsigned long abi;
     unsigned long context;
d2193 4
a2196 5
output_spill_psprel (ab, reg, offset, predicate)
     unsigned int ab;
     unsigned int reg;
     unsigned int offset;
     unsigned int predicate;
d2207 4
a2210 5
output_spill_sprel (ab, reg, offset, predicate)
     unsigned int ab;
     unsigned int reg;
     unsigned int offset;
     unsigned int predicate;
d2221 5
a2225 6
output_spill_reg (ab, reg, targ_reg, xy, predicate)
     unsigned int ab;
     unsigned int reg;
     unsigned int targ_reg;
     unsigned int xy;
     unsigned int predicate;
d2240 1
a2240 3
process_one_record (ptr, f)
     unw_rec_list *ptr;
     vbyte_func f;
d2433 1
a2433 3
process_unw_records (list, f)
     unw_rec_list *list;
     vbyte_func f;
d2442 1
a2442 2
calc_record_size (list)
     unw_rec_list *list;
d2482 4
a2485 5
set_imask (region, regmask, t, type)
     unw_rec_list *region;
     unsigned long regmask;
     unsigned long t;
     unsigned int type;
d2531 6
a2536 7
unsigned long
slot_index (slot_addr, slot_frag, first_addr, first_frag, before_relax)
     unsigned long slot_addr;
     fragS *slot_frag;
     unsigned long first_addr;
     fragS *first_frag;
     int before_relax;
d2618 1
a2618 2
optimize_unw_records (list)
     unw_rec_list *list;
d2639 1
a2639 3
fixup_unw_records (list, before_relax)
     unw_rec_list *list;
     int before_relax;
d2880 1
a2880 4
parse_predicate_and_operand (e, qp, po)
     expressionS * e;
     unsigned * qp;
     const char * po;
d2900 5
a2904 6
convert_expr_to_ab_reg (e, ab, regp, po, n)
     const expressionS *e;
     unsigned int *ab;
     unsigned int *regp;
     const char * po;
     int n;
d2954 5
a2958 6
convert_expr_to_xy_reg (e, xy, regp, po, n)
     const expressionS *e;
     unsigned int *xy;
     unsigned int *regp;
     const char * po;
     int n;
d2995 1
a2995 2
dot_radix (dummy)
     int dummy ATTRIBUTE_UNUSED;
d3026 1
a3026 2
dot_special_section (which)
     int which;
d3095 1
a3095 3
add_unwind_entry (ptr, sep)
     unw_rec_list *ptr;
     int sep;
d3138 1
a3138 2
dot_fframe (dummy)
     int dummy ATTRIBUTE_UNUSED;
d3157 1
a3157 2
dot_vframe (dummy)
     int dummy ATTRIBUTE_UNUSED;
d3182 1
a3182 2
dot_vframesp (psp)
     int psp;
d3204 1
a3204 2
dot_save (dummy)
     int dummy ATTRIBUTE_UNUSED;
d3293 1
a3293 2
dot_restore (dummy)
     int dummy ATTRIBUTE_UNUSED;
d3337 1
a3337 2
dot_restorereg (pred)
     int pred;
d3562 1
a3562 2
dot_handlerdata (dummy)
     int dummy ATTRIBUTE_UNUSED;
d3580 1
a3580 2
dot_unwentry (dummy)
     int dummy ATTRIBUTE_UNUSED;
d3589 1
a3589 2
dot_altrp (dummy)
     int dummy ATTRIBUTE_UNUSED;
d3608 1
a3608 2
dot_savemem (psprel)
     int psprel;
d3709 1
a3709 2
dot_saveg (dummy)
     int dummy ATTRIBUTE_UNUSED;
d3753 1
a3753 2
dot_savef (dummy)
     int dummy ATTRIBUTE_UNUSED;
d3773 1
a3773 2
dot_saveb (dummy)
     int dummy ATTRIBUTE_UNUSED;
d3817 1
a3817 2
dot_savegf (dummy)
     int dummy ATTRIBUTE_UNUSED;
d3855 1
a3855 2
dot_spill (dummy)
     int dummy ATTRIBUTE_UNUSED;
d3873 1
a3873 2
dot_spillreg (pred)
     int pred;
d3902 1
a3902 2
dot_spillmem (psprel)
     int psprel;
d3946 1
a3946 2
get_saved_prologue_count (lbl)
     unsigned long lbl;
d3961 1
a3961 3
save_prologue_count (lbl, count)
     unsigned long lbl;
     unsigned int count;
d3998 1
a3998 2
dot_label_state (dummy)
     int dummy ATTRIBUTE_UNUSED;
d4017 1
a4017 2
dot_copy_state (dummy)
     int dummy ATTRIBUTE_UNUSED;
d4036 1
a4036 2
dot_unwabi (dummy)
     int dummy ATTRIBUTE_UNUSED;
d4066 1
a4066 2
dot_personality (dummy)
     int dummy ATTRIBUTE_UNUSED;
d4083 1
a4083 2
dot_proc (dummy)
     int dummy ATTRIBUTE_UNUSED;
d4155 1
a4155 2
dot_body (dummy)
     int dummy ATTRIBUTE_UNUSED;
d4171 1
a4171 2
dot_prologue (dummy)
     int dummy ATTRIBUTE_UNUSED;
d4240 1
a4240 2
dot_endp (dummy)
     int dummy ATTRIBUTE_UNUSED;
d4412 1
a4412 2
dot_template (template)
     int template;
d4418 1
a4418 2
dot_regstk (dummy)
     int dummy ATTRIBUTE_UNUSED;
d4446 1
a4446 2
dot_rot (type)
     int type;
d4568 1
a4568 2
dot_byteorder (byteorder)
     int byteorder;
d4598 1
a4598 2
dot_psr (dummy)
     int dummy ATTRIBUTE_UNUSED;
d4630 1
a4630 2
dot_ln (dummy)
     int dummy ATTRIBUTE_UNUSED;
d4637 1
a4637 4
cross_section (ref, cons, ua)
     int ref;
     void (*cons) PARAMS((int));
     int ua;
d4698 1
a4698 2
dot_xdata (size)
     int size;
d4706 1
a4706 2
stmt_float_cons (kind)
     int kind;
d4731 1
a4731 2
stmt_cons_ua (size)
     int size;
d4741 1
a4741 2
dot_xfloat_cons (kind)
     int kind;
d4753 1
a4753 2
dot_xdata_ua (size)
     int size;
d4759 1
a4759 2
dot_xfloat_cons_ua (kind)
     int kind;
d4767 1
a4767 2
dot_reg_val (dummy)
     int dummy ATTRIBUTE_UNUSED;
d4803 1
a4803 2
dot_serialize (type)
     int type;
d4823 1
a4823 2
dot_dv_mode (type)
     int type;
d4859 1
a4859 2
print_prmask (mask)
     valueT mask;
d4881 1
a4881 2
dot_pred_rel (type)
     int type;
d5042 1
a5042 2
dot_entry (dummy)
     int dummy ATTRIBUTE_UNUSED;
d5055 1
a5055 1
      err = hash_insert (md.entry_hash, S_GET_NAME (symbolP), (PTR) symbolP);
d5080 1
a5080 2
dot_mem_offset (dummy)
  int dummy ATTRIBUTE_UNUSED;
d5251 1
a5251 3
declare_register (name, regnum)
     const char *name;
     unsigned int regnum;
d5258 1
a5258 1
  err = hash_insert (md.reg_hash, S_GET_NAME (sym), (PTR) sym);
d5267 3
a5269 4
declare_register_set (prefix, num_regs, base_regnum)
     const char *prefix;
     unsigned int num_regs;
     unsigned int base_regnum;
d5282 1
a5282 2
operand_width (opnd)
     enum ia64_opnd opnd;
d5296 1
a5296 4
operand_match (idesc, index, e)
     const struct ia64_opcode *idesc;
     int index;
     expressionS *e;
d5835 1
a5835 3
parse_operand (e, more)
     expressionS *e;
     int more;
d5865 1
a5865 2
parse_operands (idesc)
     struct ia64_opcode *idesc;
d6181 1
a6181 3
build_insn (slot, insnp)
     struct slot *slot;
     bfd_vma *insnp;
d6304 1
a6304 1
emit_one_bundle ()
d6771 1
a6771 3
md_parse_option (c, arg)
     int c;
     char *arg;
d6930 1
a6930 2
md_show_usage (stream)
     FILE *stream;
d6959 1
a6959 1
ia64_after_parse_args ()
d7027 1
a7027 1
md_begin ()
d7253 1
a7253 1
			 (PTR) (const_bits + i));
d7293 1
a7293 3
ia64_init (argc, argv)
     int argc ATTRIBUTE_UNUSED;
     char **argv ATTRIBUTE_UNUSED;
d7306 1
a7306 1
ia64_target_format ()
d7350 1
a7350 1
ia64_end_of_source ()
d7364 1
a7364 1
ia64_start_line ()
d7438 1
a7438 2
ia64_unrecognized_line (ch)
     int ch;
d7531 1
a7531 2
ia64_frob_label (sym)
     struct symbol *sym;
d7574 1
a7574 2
ia64_frob_symbol (sym)
     struct symbol *sym;
d7586 1
a7586 1
ia64_flush_pending_output ()
d7603 1
a7603 4
ia64_optimize_expr (l, op, r)
     expressionS *l;
     operatorT op;
     expressionS *r;
d7653 1
a7653 4
ia64_parse_name (name, e, nextcharP)
     char *name;
     expressionS *e;
     char *nextcharP;
d7836 1
a7836 2
ia64_canonicalize_symbol_name (name)
     char *name;
d7861 1
a7861 2
is_conditional_branch (idesc)
     struct ia64_opcode *idesc;
d7881 1
a7881 2
is_taken_branch (idesc)
     struct ia64_opcode *idesc;
d7891 1
a7891 2
is_interruption_or_rfi (idesc)
     struct ia64_opcode *idesc;
d7902 1
a7902 3
depends_on (depind, idesc)
     int depind;
     struct ia64_opcode *idesc;
d7967 10
a7976 7
specify_resource (dep, idesc, type, specs, note, path)
     const struct ia64_dependency *dep;
     struct ia64_opcode *idesc;
     int type;                         /* is this a DV chk or a DV reg? */
     struct rsrc specs[MAX_SPECS];     /* returned specific resources */
     int note;                         /* resource note for this insn's usage */
     int path;                         /* which execution path to examine */
d9293 1
a9293 2
clear_qp_branch_flag (mask)
     valueT mask;
d9382 1
a9382 2
clear_qp_mutex (mask)
     valueT mask;
d9409 1
a9409 3
clear_qp_implies (p1_mask, p2_mask)
     valueT p1_mask;
     valueT p2_mask;
d9432 1
a9432 2
add_qp_imply (p1, p2)
     int p1, p2;
d9495 1
a9495 2
add_qp_mutex (mask)
     valueT mask;
d9518 1
a9518 3
has_suffix_p (name, suffix)
     const char *name;
     const char *suffix;
d9529 1
a9529 1
clear_register_values ()
d9544 1
a9544 2
note_register_values (idesc)
     struct ia64_opcode *idesc;
d9743 1
a9743 4
qp_mutex (p1, p2, path)
     int p1;
     int p2;
     int path;
d9766 5
a9770 6
resources_match (rs, idesc, note, qp_regno, path)
     struct rsrc *rs;
     struct ia64_opcode *idesc;
     int note;
     int qp_regno;
     int path;
d9846 1
a9846 4
insn_group_break (insert_stop, qp_regno, save_current)
     int insert_stop;
     int qp_regno;
     int save_current;
d9910 5
a9914 6
mark_resource (idesc, dep, spec, depind, path)
     struct ia64_opcode *idesc ATTRIBUTE_UNUSED;
     const struct ia64_dependency *dep ATTRIBUTE_UNUSED;
     struct rsrc *spec;
     int depind;
     int path;
d9936 1
a9936 3
print_dependency (action, depind)
     const char *action;
     int depind;
d9957 1
a9957 1
instruction_serialization ()
d9968 1
a9968 1
data_serialization ()
d9991 1
a9991 2
remove_marked_resource (rs)
     struct rsrc *rs;
d10066 1
a10066 2
check_dependencies (idesc)
     struct ia64_opcode *idesc;
d10190 1
a10190 2
mark_resources (idesc)
     struct ia64_opcode *idesc;
d10263 1
a10263 2
update_dependencies (idesc)
     struct ia64_opcode *idesc;
d10343 1
a10343 2
check_dv (idesc)
     struct ia64_opcode *idesc;
d10391 1
a10391 2
md_assemble (str)
     char *str;
d10606 1
a10606 2
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
d10616 1
a10616 2
md_operand (e)
     expressionS *e;
d10657 1
a10657 2
ia64_fix_adjustable (fix)
     fixS *fix;
d10681 1
a10681 2
ia64_force_relocation (fix)
     fixS *fix;
d10714 1
a10714 3
ia64_pcrel_from_section (fix, sec)
     fixS *fix;
     segT sec;
d10742 1
a10742 5
ia64_cons_fix_new (f, where, nbytes, exp)
     fragS *f;
     int where;
     int nbytes;
     expressionS *exp;
d10823 1
a10823 3
ia64_gen_real_reloc_type (sym, r_type)
     struct symbol *sym;
     bfd_reloc_code_real_type r_type;
d11074 1
a11074 2
ia64_validate_fix (fix)
     fixS *fix;
d11093 1
a11093 4
fix_insn (fix, odesc, value)
     fixS *fix;
     const struct ia64_operand *odesc;
     valueT value;
d11155 1
a11155 4
md_apply_fix (fix, valP, seg)
     fixS *fix;
     valueT *valP;
     segT seg ATTRIBUTE_UNUSED;
d11231 1
a11231 3
tc_gen_reloc (sec, fixp)
     asection *sec ATTRIBUTE_UNUSED;
     fixS *fixp;
d11316 4
a11319 5
ia64_md_do_align (n, fill, len, max)
     int n ATTRIBUTE_UNUSED;
     const char *fill ATTRIBUTE_UNUSED;
     int len ATTRIBUTE_UNUSED;
     int max ATTRIBUTE_UNUSED;
d11329 1
a11329 2
ia64_handle_align (fragp)
     fragS *fragp;
d11405 1
a11405 1
ia64_elf_section_change_hook  (void)
d11526 1
a11526 1
  error_string = hash_jam (ahash, alias, (PTR) h);
d11534 1
a11534 1
  error_string = hash_jam (nhash, name, (PTR) alias);
d11549 1
a11549 1
do_alias (const char *alias, PTR value)
d11571 1
a11571 1
do_secalias (const char *alias, PTR value)
@


1.200
log
@* config/tc-ia64.c (ia64_convert_frag): Zero-initialize room for
unwind personality function address.
@
text
@d4807 1
a4807 1
      hash_delete (md.dynreg_hash, dr->name);
@


1.199
log
@	* dwarf2dbg.c (dwarf2_consume_line_info): New.
	(dwarf2_emit_insn): Use it here.
	(dwarf2_directive_loc): Fix check for consecutive .loc directives
	when debug_type is DEBUG_DWARF2.
	* dwarf2dbg.h (dwarf2_consume_line_info): New prototype.
	* config/tc-ia64.c (ia64_flush_insns): Call dwarf2_consume_line_info.
	(md_assemble): Likewise.
testsuite/
	* gas/lns/lns.exp: Run lns-common-1 with alternate source for ia64.
	* gas/lns/lns-common-1-ia64.s: New file.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
d3169 4
@


1.198
log
@gas/

2007-11-14  Tristan Gingold  <gingold@@adacore.com>

	* config/tc-ia64.c (AR_RUC): Defined.
	(ar): Add "ar.ruc".
	(specify_resource): Handle AR_RUC like AR_ITC.

gas/testsuite/

2007-11-14  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/ia64/dv-raw-err.s: Add tests for ar.ruc.
	* gas/ia64/dv-waw-err.s: Likewise.
	* gas/ia64/invalid-ar.s: Likewise.

	* gas/ia64/regs.s: Add tests for ar.ruc and ar44.

	* gas/ia64/dv-raw-err.l: Updated.
	* gas/ia64/dv-waw-err.l: Likewise.
	* gas/ia64/invalid-ar.l: Likewise.
	* gas/ia64/regs.d: Likewise.

opcodes/

2007-11-14  H.J. Lu  <hongjiu.lu@@intel.com>

	* ia64-ic.tbl: Updated for Itanium 9100 series.
	* ia64-raw.tbl: Likewise.
	* ia64-waw.tbl: Likewise.
	* ia64-asmtab.c: Regenerated.

2007-11-14  Tristan Gingold  <gingold@@adacore.com>

	* ia64-dis.c (print_insn_ia64): Handle ar.ruc.
	* ia64-gen.c (lookup_regindex): Likewise.
@
text
@d1135 1
d10972 1
@


1.197
log
@Remove duplicate definitions of the md_atof() function
@
text
@d369 1
d393 2
a394 2
    {"ar.pfs",		AR_PFS},	{"ar.lc",	AR_LC},
    {"ar.ec",		AR_EC},
d9260 1
d9262 1
a9262 2
				  && (regno == AR_ITC
				      || regno == AR_RSC
@


1.196
log
@PR gas/5161
* config/tc-ia64.c: Allow for translations of error and warning messages.
* po/gas.pot: Regenerate.
@
text
@d11689 1
a11689 4
md_atof (type, lit, size)
     int type;
     char *lit;
     int *size;
d11721 1
a11721 1
      return "Bad call to MD_ATOF()";
d11738 1
a11738 1
  return 0;
@


1.195
log
@* read.c (potable): Add string8, string16, string32 and string64. Add bit size for stringer function.
 (stringer_append_char): New.
 (stringer): Use stringer_append_char().
* config/obj-coff.c (obj_coff_ident): Add bit size for stringer function.
* config/obj-elf.c (obj_elf_ident): Likewise.
* config/tc-alpha.c (s_alpha_stringer): Likewise.
* config/tc-dlx.c (dlx_pseudo_table): Likewise.
* config/tc-hppa.c (pa_stringer): Likewise.
* config/tc-ia64.c (md_pseudo_table, pseudo_opcode): Likewise.
* config/tc-m68hc11.c (md_pseudo_table): Likewise.
* config/tc-mcore.c (md_pseudo_table): Likewise.
* config/tc-mips.c (mips_pseudo_table): Likewise.
* config/tc-spu.c (md_pseudo_table): Likewise.
* config/tc-s390.c (md_pseudo_table): Likewise. Replace '2' by '1'.
* doc/as.texinfo (ABORT): Fix identing.
  (String): Document new string8, string16, string32, string64 functions.
* NEWS: Mention the new feature.

* testsuite/gas/all/gas.exp: Include new test "strings".
* testsuite/gas/all/string.s: New
* testsuite/gas/all/string.d: New.
@
text
@d230 1
a230 1
       that are predicatable.  */
d746 1
a746 1
  /* Any unwind entires that should be attached to the current slot
d1082 1
a1082 1
      as_bad ("Size of frame exceeds maximum of 96 registers");
d1087 1
a1087 1
      as_warn ("Size of rotating registers exceeds frame size");
d1182 1
a1182 1
    as_bad ("qualifying predicate not followed by instruction");
d1255 1
a1255 1
    as_bad ("record type is not valid");
d1295 1
a1295 1
    as_bad ("record type is not valid");
d1372 1
a1372 1
      as_bad ("Invalid record type for P3 format.");
d1417 1
a1417 1
    as_bad ("Invalid record type for format P6");
d1610 1
a1610 1
    as_bad ("Invalid record type for format B1");
d1671 1
a1671 1
    as_bad ("Invalid record type for format B1");
d1706 1
a1706 1
    as_bad ("Invalid record type for format X1");
d1746 1
a1746 1
    as_bad ("Invalid record type for format X3");
d1782 1
a1782 1
      as_warn ("Previous .save incomplete");
d2659 1
a2659 1
      as_bad ("spill_mask record unimplemented.");
d2716 1
a2716 1
      as_bad ("record_type_not_valid");
d2805 1
a2805 1
	  as_bad ("Ignoring attempt to spill beyond end of region");
d2865 1
a2865 1
	    as_fatal ("only constant space allocation is supported");
d2879 1
a2879 1
		as_fatal ("only constant offsets are supported");
d2902 1
a2902 1
	as_fatal ("Section switching in code is not supported.");
d2947 1
a2947 1
	as_bad (" Insn slot not set in unwind record.");
d3021 1
a3021 1
	      as_bad ("frgr_mem record before region record!");
d3032 1
a3032 1
	      as_bad ("fr_mem record before region record!");
d3041 1
a3041 1
	      as_bad ("gr_mem record before region record!");
d3050 1
a3050 1
	      as_bad ("br_mem record before region record!");
d3060 1
a3060 1
	      as_bad ("gr_gr record before region record!");
d3068 1
a3068 1
	      as_bad ("br_gr record before region record!");
d3185 1
a3185 1
      as_bad ("First operand to .%s must be a predicate", po);
d3189 1
a3189 1
    as_warn ("Pointless use of p0 as first operand to .%s", po);
d3246 1
a3246 1
	  as_bad ("Operand %d to .%s must be a preserved register", n, po);
d3283 1
a3283 1
    as_bad ("Operand %d to .%s must be a writable register", n, po);
d3309 1
a3309 1
    as_bad ("Radix `%s' unsupported or invalid", radix);
d3340 1
a3340 1
      as_warn (".%s outside of %s", directive, region);
d3345 1
a3345 1
      as_bad (".%s outside of %s", directive, region);
d3432 1
a3432 1
	    as_warn ("Tags on unwind pseudo-ops aren't supported, yet");
d3455 1
a3455 1
      as_bad ("First operand to .fframe must be a constant");
d3476 1
a3476 1
      as_bad ("First operand to .vframe must be a general register");
d3484 1
a3484 1
    as_warn ("Operand of .vframe contradicts .prologue");
d3495 1
a3495 1
    as_warn (".vframepsp is meaningless, assuming .vframesp was meant");
d3503 1
a3503 1
      as_bad ("Operand to .vframesp must be a constant (sp-relative offset)");
d3531 1
a3531 1
      as_bad ("First operand to .save not a register");
d3537 1
a3537 1
      as_bad ("Second operand to .save not a valid register");
d3568 1
a3568 1
	as_warn ("Second operand of .save contradicts .prologue");
d3579 1
a3579 1
	as_warn ("Second operand of .save contradicts .prologue");
d3587 1
a3587 1
	as_warn ("Second operand of .save contradicts .prologue");
d3594 1
a3594 1
      as_bad ("First operand to .save not a valid register");
d3613 1
a3613 1
    as_bad ("First operand to .restore must be stack pointer (sp)");
d3622 1
a3622 1
	  as_bad ("Second operand to .restore must be a constant >= 0");
d3632 1
a3632 1
      as_bad ("Epilogue count of %lu exceeds number of nested prologues (%u)",
d3720 1
a3720 1
      as_bad ("Illegal section name `%s' (causes unwind section name clash)",
d3756 1
a3756 1
	  as_bad ("Group section `%s' has no group signature",
d3914 1
a3914 1
      as_bad ("First operand to .altrp not a valid branch register");
d3944 1
a3944 1
      as_bad ("First operand to .%s not a register", po);
d3949 1
a3949 1
      as_bad ("Second operand to .%s not a constant", po);
d4016 1
a4016 1
      as_bad ("First operand to .%s not a valid register", po);
d4040 1
a4040 1
      as_bad ("First operand to .save.g must be a positive 4-bit constant");
d4053 1
a4053 1
	  as_bad ("Second operand to .save.g must be a general register");
d4058 1
a4058 1
	  as_bad ("Second operand to .save.g must be the first of %d general registers", n);
d4082 1
a4082 1
      as_bad ("Operand to .save.f must be a positive 20-bit constant");
d4106 1
a4106 1
      as_bad ("First operand to .save.b must be a positive 5-bit constant");
d4119 1
a4119 1
	  as_bad ("Second operand to .save.b must be a general register");
d4124 1
a4124 1
	  as_bad ("Second operand to .save.b must be the first of %d general registers", n);
d4151 1
a4151 1
      as_bad ("First operand to .save.gf must be a non-negative 4-bit constant");
d4159 1
a4159 1
      as_bad ("Second operand to .save.gf must be a non-negative 20-bit constant");
d4167 1
a4167 1
    as_bad ("Operands to .save.gf may not be both zero");
d4185 1
a4185 1
      as_bad ("Operand to .spill must be a constant");
d4256 1
a4256 1
      as_bad ("Operand %d to .%s must be a constant", 2 + pred, po);
d4278 1
a4278 1
  as_bad ("Missing .label_state %ld", lbl);
d4335 1
a4335 1
      as_bad ("Operand to .label_state must be a constant");
d4355 1
a4355 1
      as_bad ("Operand to .copy_state must be a constant");
d4379 1
a4379 1
      as_bad ("First operand to .unwabi must be a constant");
d4385 1
a4385 1
      as_bad ("Second operand to .unwabi must be a constant");
d4422 1
a4422 1
       : as_bad) ("Missing .endp after previous .proc");
d4441 1
a4441 1
	as_bad ("Empty argument of .proc");
d4446 1
a4446 1
	    as_bad ("`%s' was already defined", name);
d4490 1
a4490 1
    as_warn ("Initial .body should precede any instructions");
d4510 1
a4510 1
      as_bad (".prologue within prologue");
d4515 1
a4515 1
    as_warn ("Initial .prologue should precede any instructions");
d4525 1
a4525 1
	as_bad ("First operand to .prologue must be a positive 4-bit constant");
d4527 1
a4527 1
	as_warn ("Pointless use of zero first operand to .prologue");
d4541 1
a4541 1
	    as_warn ("Using a constant as second operand to .prologue is deprecated");
d4547 1
a4547 1
	  as_bad ("Second operand to .prologue must be a general register");
d4552 1
a4552 1
	  as_bad ("Second operand to .prologue must be the first of %d general registers", n);
d4665 1
a4665 1
	    as_bad ("`%s' was not defined within procedure", S_GET_NAME (sym));
d4703 1
a4703 1
	 : as_bad) ("Empty argument of .endp");
d4717 1
a4717 1
	    as_warn ("`%s' was not specified with previous .proc", name);
d4732 1
a4732 1
    as_warn ("`%s' should be an operand to this .endp",
d4775 1
a4775 1
  as_bad ("Comma expected");
d4817 1
a4817 1
	  as_bad ("Expected '['");
d4826 1
a4826 1
	  as_bad ("Expected ']'");
d4831 1
a4831 1
	  as_bad ("Number of elements must be positive");
d4842 1
a4842 1
	      as_bad ("Used more than the declared %d rotating registers",
d4850 1
a4850 1
	      as_bad ("Used more than the available 96 rotating registers");
d4857 1
a4857 1
	      as_bad ("Used more than the available 48 rotating registers");
d4885 1
a4885 1
	  as_bad ("Attempt to redefine register set `%s'", name);
d4953 1
a4953 1
	as_bad ("Unknown psr option `%s'", option);
d5005 1
a5005 1
	  as_bad ("Missing section name");
d5015 1
a5015 1
      as_bad ("Comma expected after section name");
d5026 1
a5026 1
    as_warn ("Creating sections with .xdataN/.xrealN/.xstringZ is deprecated.");
d6255 1
a6255 1
	  as_bad ("Expected separator `='");
d6288 1
a6288 1
	    as_bad ("Duplicate equal sign (=) in instruction");
d6295 1
a6295 1
      as_bad ("Illegal operand separator `%c'", sep);
d6409 1
a6409 1
	as_bad ("Operand %u of `%s' should be %s",
d6413 1
a6413 1
	as_bad ("Wrong number of output operands");
d6415 1
a6415 1
	as_bad ("Wrong number of input operands");
d6417 1
a6417 1
	as_bad ("Operand mismatch");
d6499 1
a6499 1
	  as_warn ("Invalid use of `%c%d' as output operand", reg_class, regno);
d6502 1
a6502 1
	  as_warn ("Invalid use of `r%d' as base update address operand", regno);
d6526 1
a6526 1
	as_warn ("Invalid duplicate use of `%c%d'", reg_class, reg1);
d6533 1
a6533 1
    as_warn ("Invalid simultaneous use of `f%d' and `f%d'",
d6539 1
a6539 1
    as_warn ("Dangerous simultaneous use of `f%d' and `f%d'",
d6648 1
a6648 1
		      "Bad operand value: %s", err);
d6791 1
a6791 1
			    "`%s' must be last in bundle", idesc->name);
d6823 2
a6824 2
			    "Internal error: don't know how to force %s to end"
			    "of instruction group", idesc->name);
d6836 1
a6836 1
			    "`%s' must be last in instruction group",
d6866 1
a6866 1
			  "Label must be first in a bundle");
d6943 1
a6943 1
		      as_warn ("hint in B unit may be treated as nop");
d6954 1
a6954 1
			as_bad ("hint in B unit can't be used");
d6968 1
a6968 1
	    as_fatal ("emit_one_bundle: unexpected dynamic op");
d7091 1
a7091 1
		    "`%s' does not fit into %s template",
d7106 1
a7106 1
			  "`%s' does not fit into bundle", idesc->name);
d7118 1
a7118 1
			    "`%s' can't go in %s of %s template",
d7124 1
a7124 1
		      "Missing '}' at end of file");
d7563 1
a7563 1
	as_fatal ("ia64.md_begin: can't hash `%s': %s",
d7624 1
a7624 1
	as_fatal ("Inserting \"%s\" into constant hash table failed: %s",
d7747 1
a7747 1
    as_bad ("qualifying predicate not followed by instruction");
d7771 1
a7771 1
	as_warn ("Found '{' when manual bundling is already turned on");
d7790 1
a7790 1
	as_warn ("Found '}' when manual bundling is off");
d7818 1
a7818 1
	  as_bad ("Expected ')'");
d7823 1
a7823 1
	  as_bad ("Qualifying predicate expected");
d7828 1
a7828 1
	  as_bad ("Predicate register expected");
d7842 1
a7842 1
	    as_bad ("Tag must come before qualifying predicate.");
d7872 1
a7872 1
	    as_bad ("Expected ':'");
d7883 1
a7883 1
	    as_bad ("Expected ']'");
d7888 1
a7888 1
	    as_bad ("Tag name expected");
d7995 1
a7995 1
	      as_bad ("Rotating register index must be a non-negative constant");
d8000 1
a8000 1
	      as_bad ("Index out of range 0..%u", num_regs - 1);
d8012 1
a8012 1
	      as_bad ("Indirect register index must be a general register");
d8021 1
a8021 1
  as_bad ("Index can only be applied to rotating or indirect registers");
d8060 1
a8060 1
	      as_bad ("Expected '('");
d8068 1
a8068 1
	      as_bad ("Missing ')'");
d8077 1
a8077 1
		  as_bad ("Not a symbolic expression");
d8082 1
a8082 1
		  as_bad ("Illegal combination of relocation functions");
d8096 1
a8096 1
		  as_bad ("Illegal combination of relocation functions");
d8185 1
a8185 1
		as_bad ("No current frame");
d8187 1
a8187 1
		as_bad ("Register number out of range 0..%u",
d8226 1
a8226 1
	as_bad ("Standalone `#' is illegal");
d8229 1
a8229 1
    as_warn ("Redundant `#' suffix operators");
d8332 1
a8332 1
   13) This reference to ld-c only applies to teh GR whose value is loaded
d10562 1
a10562 2
		    as_warn (_("Only the first path encountering the conflict "
			       "is reported"));
d10564 1
a10564 2
				 _("This is the location of the "
				   "conflicting usage"));
d10829 1
a10829 1
      as_bad ("Unknown opcode `%s'", mnemonic);
d10907 1
a10907 1
	    as_bad ("AR %d can only be accessed by %c-unit",
d10919 1
a10919 1
	  as_warn ("hint.b may be treated as nop");
d10922 1
a10922 1
	  as_bad ("hint.b shouldn't be used");
d10961 1
a10961 1
      as_bad ("`%s' cannot be predicated", idesc->name);
d11034 1
a11034 1
	  as_bad ("Closing bracket missing");
d11043 1
a11043 1
	      as_bad ("Index must be a general register");
d11216 1
a11216 1
      as_bad ("Unsupported fixup size %d", nbytes);
d11484 2
a11485 2
	 diagnostic here, dont't make it fail because of this for now.  */
      as_warn ("Cannot express %s%d%s relocation", type, width, suffix);
d11505 1
a11505 1
		      "No addend allowed in @@fptr() relocation");
d11617 1
a11617 1
			"%s must have a constant value",
d11673 1
a11673 1
		    "Cannot represent %s relocation in object file",
@


1.194
log
@gas/
2007-09-26  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (dot_pred_rel): Replace specialized handling
	with simple call to parse_operand.
@
text
@d5092 1
a5092 2
dot_xstringer (zero)
     int zero;
d5529 2
a5530 2
    { "xstring", dot_xstringer, 0 },
    { "xstringz", dot_xstringer, 1 },
d5587 2
a5588 2
    { "string", stringer, 0 },
    { "stringz", stringer, 1 },
@


1.193
log
@	* config/tc-ia64.c (tc_gen_reloc): Return NULL if relocation is
	unrepresentable.
@
text
@a5284 1
  SKIP_WHITESPACE ();
d5288 1
a5288 1
      int regno;
d5291 1
a5291 1
      expression_and_evaluate (&pr);
d5338 1
a5338 1
      if (*input_line_pointer != ',')
a5339 2
      ++input_line_pointer;
      SKIP_WHITESPACE ();
@


1.192
log
@Switch to GPLv3
@
text
@d11681 2
@


1.191
log
@Fix typo.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.190
log
@	* write.h (struct fix <fx_pcrel_adjust, fx_size>): Move.
	(struct fix <fx_plt>): Rename to tcbit2.
	* write.c (fix_new_internal): Adjust.
	(TC_FORCE_RELOCATION_LOCAL): Don't test fx_plt.
	* config/tc-arm.h (TC_FORCE_RELOCATION_LOCAL): Likewise.
	* config/tc-cris.h (TC_FORCE_RELOCATION_LOCAL): Likewise.
	* config/tc-i386.h (TC_FORCE_RELOCATION_LOCAL): Likewise.
	* config/tc-i960.h (TC_FORCE_RELOCATION_LOCAL): Likewise.
	* config/tc-sh.h (TC_FORCE_RELOCATION_LOCAL): Likewise.
	* config/tc-sh64.h (TC_FORCE_RELOCATION_LOCAL): Likewise.
	* config/tc-sparc.h (TC_FORCE_RELOCATION_LOCAL): Likewise.
	* config/tc-msp430.c (msp430_force_relocation_local): Likewise.
	* config/tc-ia64.c (emit_one_bundle): Don't set fx_plt.
	* config/tc-ia64.h (TC_FORCE_RELOCATION_LOCAL): Don't test fx_plt.
	Instead, compare fx_r_type.
	* config/tc-xtensa.c (xg_add_opcode_fix, md_apply_fix): Use
	fx_tcbit in place of fx_plt.
	* config/tc-xtensa.h (TC_FORCE_RELOCATION_LOCAL): Define.
	* doc/internals.texi (TC_FORCE_RELOCATION_LOCAL): Remove reference
	to fx_plt.
@
text
@d6694 1
a6694 1
  know (first >= 0 & first < NUM_SLOTS);
@


1.189
log
@2006-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (output_invalid_buf): Change size to 16.
	* config/tc-tic30.c (output_invalid_buf): Likewise.

	* config/tc-i386.c (output_invalid): Use snprintf instead of
	sprintf.
	* config/tc-ia64.c (declare_register_set): Likewise.
	(emit_one_bundle): Likewise.
	(check_dependencies): Likewise.
	* config/tc-tic30.c (output_invalid): Likewise.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
a7069 1
	  fix->fx_plt = (fix->fx_r_type == BFD_RELOC_IA64_PLTOFF22);
@


1.188
log
@	* config/obj-coff.c, config/tc-arm.c, config/tc-bfin.c,
	config/tc-cris.c, config/tc-crx.c, config/tc-i386.c,
	config/tc-ia64.c, config/tc-maxq.c, config/tc-maxq.h,
	config/tc-mips.c, config/tc-msp430.c, config/tc-sh.c,
	config/tc-tic4x.c, config/tc-xtensa.c: Fix comment typos.
@
text
@d5637 1
a5637 1
      sprintf (name, "%s%u", prefix, i);
d6974 2
a6975 1
	  sprintf (mnemonic, "%s.%c", idesc->name, "?imbfxx"[insn_unit]);
d10548 2
a10549 1
		sprintf (pathmsg, " when entry is at label '%s'",
d10552 2
a10553 1
		sprintf (indexmsg, ", specific resource number is %d",
d10555 2
a10556 1
	      sprintf (msg, "Use of '%s' %s %s dependency '%s' (%s)%s%s",
@


1.187
log
@Fix problem with double-stop-bit after itc.i instruction.
* config/tc-ia64.c (emit_one_bundle): For IA64_OPCODE_LAST, if we
change the template, then clear md.slot[curr].end_of_insn_group.
@
text
@d11865 1
a11865 1
  const char *name;	/* The orignale name of the symbol.  */
@


1.186
log
@bfd/

2006-02-23  H.J. Lu  <hongjiu.lu@@intel.com>

	* cpu-ia64-opc.c (ins_immu5b): New.
	(ext_immu5b): Likewise.
	(elf64_ia64_operands): Add IMMU5b.

gas/

2006-02-23  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-ia64.c (operand_match): Handle IA64_OPND_IMMU5b.

gas/testsuite/

2006-02-23  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/ia64/opc-i.s: Add tests for tf.
	* gas/ia64/pseudo.s: Likewise.
	* gas/ia64/opc-i.d: Updated.
	* gas/ia64/pseudo.d: Likewise.

include/opcode/

2006-02-23  H.J. Lu  <hongjiu.lu@@intel.com>

	* ia64.h (ia64_opnd): Add IA64_OPND_IMMU5b.

opcodes/

2006-02-23  H.J. Lu  <hongjiu.lu@@intel.com>

	* ia64-opc-i.c (bXc): New.
	(mXc): Likewise.
	(OpX2TaTbYaXcC): Likewise.
	(TF). Likewise.
	(TFCM). Likewise.
	(ia64_opcodes_i): Add instructions for tf.

	* ia64-opc.h (IMMU5b): New.

	* ia64-asmtab.c: Regenerated.
@
text
@d6858 4
@


1.185
log
@Update copyright years.
@
text
@d5917 11
@


1.184
log
@gas/

2006-02-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-ia64.c (specify_resource): Add the rule 17 from
	SDM 2.2.

gas/testsuite/

2006-02-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/ia64/dv-raw-err.s: Add check for vmsw.0.
	* gas/ia64/dv-raw-err.l: Updated.

	* gas/ia64/opc-b.s: Add vmsw.0 and vmsw.1.
	* gas/ia64/opc-b.d: Updated.

opcodes/

2006-02-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* ia64-gen.c (lookup_regindex): Handle ".vm".
	(print_dependency_table): Handle '\"'.

	* ia64-ic.tbl: Updated from SDM 2.2.
	* ia64-raw.tbl: Likewise.
	* ia64-waw.tbl: Likewise.
	* ia64-asmtab.c: Regenerated.

	* ia64-opc-b.c (ia64_opcodes_b): Add vmsw.0 and vmsw.1.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
@


1.183
log
@Fix PR 994, core dump with section switching.
* config/tc-ia64.c (slot_index): Emit an error instead of a warning
when the frag chain is broken by section switching.
@
text
@d8330 2
d9420 3
a9422 2
      /* Handle all CR[REG] resources */
      if (note == 0 || note == 1)
@


1.182
log
@Fix PR 1889, infinite loop compiling code with bad user template.
* config/tc-ia64.c (emit_one_bundle): Perform last_slot < 0 check
even when manual_bundling isn't set.
@
text
@d2898 3
a2900 1
	 function, causing the frag chain for the function to be broken.  */
d2902 1
a2902 16
	{
	  /* We get six warnings for one problem, because of the loop in
	     fixup_unw_records, and because fixup_unw_records is called 3
	     times: once before creating the variant frag, once to estimate
	     its size, and once to relax it.  This is unreasonable, so we use
	     a static var to make sure we only emit the warning once.  */
	  static int warned = 0;

	  if (!warned)
	    {
	      as_warn ("Corrupted unwind info due to unsupported section switching");
	      warned = 1;
	    }

	  return index;
	}
@


1.181
log
@gas/
2005-11-14  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (AR_FCR, AR_EFLAG, AR_CSD, AR_SSD, AR_CFLG,
	AR_FSR, AR_FIR, AR_FDR, AR_CCV, AR_EC): Define.
	(ar): Use AR_* instead of literals.
	(CR_DCR, CR_ITM, CR_IVA, CR_PTA, CR_GPTA, CR_LID, CR_ITV,
	CR_PMV, CR_CMCV): Define.
	(cr): Use CR_* instead of literals.
@
text
@d7087 16
a7102 1
  if (manual_bundling > 0)
a7108 12
	  else if (last_slot < 0)
	    {
	      as_bad_where (md.slot[curr].src_file, md.slot[curr].src_line,
			    "`%s' does not fit into %s template",
			    idesc->name, ia64_templ_desc[template].name);
	      /* Drop first insn so we don't livelock.  */
	      --md.num_slots_in_use;
	      know (curr == first);
	      ia64_free_opcode (md.slot[curr].idesc);
	      memset (md.slot + curr, 0, sizeof (md.slot[curr]));
	      md.slot[curr].user_template = -1;
	    }
d7128 1
@


1.180
log
@gas/
2005-11-14  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (md): Rename regsym to indregsym and move
	it to the end of the structure.
	(ar): Field regnum is unsigned.
	(cr): Likewise:
	(indirect_reg): Likewise.
	(declare_register_set): Parameter regnum is unsigned.
	(declare_register): Parameter numregs and base_regnum are
	unsigned. So is the local loop variable.
	(md_begin): Restrict scope of local variable regnum, which
	also is unsigned. Replace loops with function calls where
	possible. Re-order things so that register groups are kept
	together. Remove all uses of regsym except for indirect
	registers. Replace use of regsym by indregsym for indirect
	registers.
	(ia64_optimize_expr): Replace use of regsym by indregsym for
	indirect registers, with appropriate bias.
@
text
@d357 9
d371 1
d380 14
a393 12
    {"ar.k0", 0}, {"ar.k1", 1}, {"ar.k2", 2}, {"ar.k3", 3},
    {"ar.k4", 4}, {"ar.k5", 5}, {"ar.k6", 6}, {"ar.k7", 7},
    {"ar.rsc",		16}, {"ar.bsp",		17},
    {"ar.bspstore",	18}, {"ar.rnat",	19},
    {"ar.fcr",		21}, {"ar.eflag",	24},
    {"ar.csd",		25}, {"ar.ssd",		26},
    {"ar.cflg",		27}, {"ar.fsr",		28},
    {"ar.fir",		29}, {"ar.fdr",		30},
    {"ar.ccv",		32}, {"ar.unat",	36},
    {"ar.fpsr",		40}, {"ar.itc",		44},
    {"ar.pfs",		64}, {"ar.lc",		65},
    {"ar.ec",		66},
d396 7
d412 1
d418 3
a423 1
/* control registers:  */
d431 27
a457 27
    {"cr.dcr",	 0},
    {"cr.itm",	 1},
    {"cr.iva",	 2},
    {"cr.pta",	 8},
    {"cr.gpta",	 9},
    {"cr.ipsr",	16},
    {"cr.isr",	17},
    {"cr.iip",	19},
    {"cr.ifa",	20},
    {"cr.itir",	21},
    {"cr.iipa",	22},
    {"cr.ifs",	23},
    {"cr.iim",	24},
    {"cr.iha",	25},
    {"cr.lid",	64},
    {"cr.ivr",	65},
    {"cr.tpr",	66},
    {"cr.eoi",	67},
    {"cr.irr0",	68},
    {"cr.irr1",	69},
    {"cr.irr2",	70},
    {"cr.irr3",	71},
    {"cr.itv",	72},
    {"cr.pmv",	73},
    {"cr.cmcv",	74},
    {"cr.lrr0",	80},
    {"cr.lrr1",	81}
@


1.179
log
@include/opcode/
2005-10-24  Jan Beulich  <jbeulich@@novell.com>

	* ia64.h (enum ia64_opnd): Move memory operand out of set of
	indirect operands.

bfd/
2005-10-24  Jan Beulich  <jbeulich@@novell.com>

	* cpu-ia64-opc.c (elf64_ia64_operands): Move memory operand out of
	set of indirect operands.

gas/
2005-10-24  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (enum reg_symbol): Delete IND_MEM.
	(dot_rot): Change type of num_* variables. Check for positive count.
	(ia64_optimize_expr): Re-structure.
	(md_operand): Check for general register.

gas/testsuite/
2005-10-24  Jan Beulich  <jbeulich@@novell.com>

	* gas/ia64/index.[sl]: New.
	* gas/ia64/rotX.[sl]: New.
	* gas/ia64/ia64.exp: Run new tests.

opcodes/
2005-10-24  Jan Beulich  <jbeulich@@novell.com>

	* ia64-asmtab.c: Regenerate.
@
text
@a227 2
    symbolS *regsym[REG_NUM];

d329 2
d366 1
a366 1
    int regnum;
d405 1
a405 1
    int regnum;
d493 1
a493 1
    int regnum;
d813 2
a814 2
static symbolS *declare_register PARAMS ((const char *name, int regnum));
static void declare_register_set PARAMS ((const char *, int, int));
d5602 1
a5602 1
     int regnum;
d5620 2
a5621 2
     int num_regs;
     int base_regnum;
d5624 1
a5624 1
  int i;
d7374 1
a7374 1
  int i, j, k, t, goodness, best, regnum, ok;
d7549 5
a7553 5
  for (i = REG_GR; i < REG_GR + 128; ++i)
    {
      sprintf (name, "r%d", i - REG_GR);
      md.regsym[i] = declare_register (name, i);
    }
d7556 3
a7558 5
  for (i = REG_FR; i < REG_FR + 128; ++i)
    {
      sprintf (name, "f%d", i - REG_FR);
      md.regsym[i] = declare_register (name, i);
    }
d7560 3
a7562 13
  /* application registers:  */
  for (i = REG_AR; i < REG_AR + 128; ++i)
    {
      sprintf (name, "ar%d", i - REG_AR);
      md.regsym[i] = declare_register (name, i);
    }

  /* control registers:  */
  for (i = REG_CR; i < REG_CR + 128; ++i)
    {
      sprintf (name, "cr%d", i - REG_CR);
      md.regsym[i] = declare_register (name, i);
    }
d7565 3
a7567 5
  for (i = REG_P; i < REG_P + 64; ++i)
    {
      sprintf (name, "p%d", i - REG_P);
      md.regsym[i] = declare_register (name, i);
    }
d7569 2
a7570 22
  /* branch registers:  */
  for (i = REG_BR; i < REG_BR + 8; ++i)
    {
      sprintf (name, "b%d", i - REG_BR);
      md.regsym[i] = declare_register (name, i);
    }

  md.regsym[REG_IP] = declare_register ("ip", REG_IP);
  md.regsym[REG_CFM] = declare_register ("cfm", REG_CFM);
  md.regsym[REG_PR] = declare_register ("pr", REG_PR);
  md.regsym[REG_PR_ROT] = declare_register ("pr.rot", REG_PR_ROT);
  md.regsym[REG_PSR] = declare_register ("psr", REG_PSR);
  md.regsym[REG_PSR_L] = declare_register ("psr.l", REG_PSR_L);
  md.regsym[REG_PSR_UM] = declare_register ("psr.um", REG_PSR_UM);

  for (i = 0; i < NELEMS (indirect_reg); ++i)
    {
      regnum = indirect_reg[i].regnum;
      md.regsym[regnum] = declare_register (indirect_reg[i].name, regnum);
    }

  /* define synonyms for application registers:  */
d7574 2
a7575 1
  /* define synonyms for control registers:  */
d7579 12
a7590 4
  declare_register ("gp", REG_GR +  1);
  declare_register ("sp", REG_GR + 12);
  declare_register ("tp", REG_GR + 13);
  declare_register ("rp", REG_BR +  0);
a7594 4
  declare_register_set ("ret", 4, REG_GR + 8);
  declare_register_set ("farg", 8, REG_FR + 8);
  declare_register_set ("fret", 8, REG_FR + 8);

d7992 1
a7992 1
	  l->X_op_symbol = md.regsym[l->X_add_number];
@


1.178
log
@gas/
2005-10-24  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (declare_register): Call symbol_create.
	(md_begin): Remove local variables total, ar_base, and cr_base.
	Start loops for registers at their respective first one. Don't
	update md.regsym for alias names. Generate alias name tp for r13.

gas/testsuite/
2005-10-24  Jan Beulich  <jbeulich@@novell.com>

	* gas/ia64/regs.pl: Also check tp alias of r13.
	* gas/ia64/regs.s: Regenerate.
	* gas/ia64/regs.d: Adjust.
@
text
@a126 1
    IND_MEM,
d4774 2
a4775 1
  unsigned num_regs, num_alloced = 0;
d4820 5
d7987 6
a7992 1
  unsigned num_regs;
d7994 2
a7995 3
  if (op == O_index)
    {
      if (l->X_op == O_register && r->X_op == O_constant)
d7997 2
a7998 2
	  num_regs = (l->X_add_number >> 16);
	  if ((unsigned) r->X_add_number >= num_regs)
d8000 6
a8005 4
	      if (!num_regs)
		as_bad ("No current frame");
	      else
		as_bad ("Index out of range 0..%u", num_regs - 1);
d8011 1
a8011 1
      else if (l->X_op == O_register && r->X_op == O_register)
d8013 3
a8015 2
	  if (l->X_add_number < IND_CPUID || l->X_add_number > IND_RR
	      || l->X_add_number == IND_MEM)
d8017 2
a8018 2
	      as_bad ("Indirect register set name expected");
	      l->X_add_number = IND_CPUID;
d8026 6
a8031 1
  return 0;
d11040 7
a11046 2
	  if (e->X_op != O_register)
	    as_bad ("Register expected as index");
@


1.177
log
@gas/
2005-10-12  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (dot_reg_val): Use expression_and_evaluate.
	(dot_pred_rel): Likewise.
	(parse_operand): Likewise.
	(ia64_unrecognized_line): Likewise.
	(md_operand): Likewise.

gas/testsuite/
2005-10-12  Jan Beulich  <jbeulich@@novell.com>

	* gas/ia64/forward.[sd]: New.
	* gas/ia64/ia64.exp: Run new test.
@
text
@d5602 1
a5602 1
  sym = symbol_new (name, reg_section, regnum, &zero_address_frag);
d7369 1
a7369 1
  int i, j, k, t, total, ar_base, cr_base, goodness, best, regnum, ok;
d7544 1
a7544 3

  total = 128;
  for (i = 0; i < total; ++i)
d7551 1
a7551 2
  total += 128;
  for (; i < total; ++i)
d7558 1
a7558 3
  total += 128;
  ar_base = i;
  for (; i < total; ++i)
d7565 1
a7565 3
  total += 128;
  cr_base = i;
  for (; i < total; ++i)
d7572 1
a7572 2
  total += 64;
  for (; i < total; ++i)
d7579 1
a7579 2
  total += 8;
  for (; i < total; ++i)
d7600 2
a7601 3
  for (i = REG_AR; i < REG_AR + NELEMS (ar); ++i)
    md.regsym[i] = declare_register (ar[i - REG_AR].name,
				     REG_AR + ar[i - REG_AR].regnum);
d7604 2
a7605 3
  for (i = REG_CR; i < REG_CR + NELEMS (cr); ++i)
    md.regsym[i] = declare_register (cr[i - REG_CR].name,
				     REG_CR + cr[i - REG_CR].regnum);
d7609 1
@


1.176
log
@gas/
2005-09-29  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (parse_operands): Always parse first operand of
	alloc.

gas/testsuite/
2005-09-29  Jan Beulich  <jbeulich@@novell.com>

	* gas/ia64/alloc.[sl]: New.
	* gas/ia64/ia64.exp: Run new test.
@
text
@d5106 1
a5106 1
  expression (&reg);
d5278 1
a5278 1
      expression (&pr);
d6184 1
a6184 1
  expression (e);
d7825 1
a7825 1
      expression (&md.qp);
d11025 1
a11025 1
      expression (e);
@


1.175
log
@        * dwarf2dbg.c (struct line_entry): Replace frag and frag_ofs
        with label.
        (dwarf2_loc_mark_labels): New.
        (dwarf2_gen_line_info_1): Split out of ...
        (dwarf2_gen_line_info): ... here.  Create the temp symbol here.
        (dwarf2_emit_label): New.
        (dwarf2_directive_loc_mark_labels): New.
        (out_set_addr): Take a symbol instead of frag+ofs.
        (relax_inc_line_addr): Likewise.
        (emit_inc_line_addr): Assert delta non-negative.
        (process_entries): Remove dead code.  Update to work with temp
        symbols instead of frag+ofs.
        * dwarf2dbg.h (dwarf2_directive_loc_mark_labels): Declare.
        (dwarf2_emit_label, dwarf2_loc_mark_labels): Declare.
        * config/obj-elf.c (elf_pseudo_tab): Add loc_mark_labels.
        * config/obj-elf.h (obj_frob_label): New.
        * config/tc-alpha.c (alpha_define_label): Call dwarf2_emit_label.
        * config/tc-arm.c, config/tc-hppa.c, config/tc-m68k.c,
        config/tc-mips.c, config/tc-ppc.c, config/tc-sh.c, config/tc-xtensa.c:
        Similarly in the respective tc_frob_label implementation functions.
        * config/tc-i386.c (md_pseudo_table): Move file and loc to
        non-elf section; add loc_mark_labels.
        * config/tc-ia64.c (struct label_fix): Add dw2_mark_labels.
        (ia64_flush_insns): Check for marked labels; emit line entry if so.
        (emit_one_bundle): Similarly.
        (ia64_frob_label): Record marked labels.
        * config/tc-m68hc11.h (tc_frob_label): Remove.
        * config/tc-ms1.c (md_pseudo_table): Remove file and loc.
        * config/tc-sh.h (tc_frob_label): Pass sym to sh_frob_label.
        * config/tc-sh64.h (tc_frob_label): Likewise.
        * doc/as.texinfo (LNS directives): Docuement .loc_mark_blocks.
@
text
@d6281 3
a6283 1
      /* map alloc r1=ar.pfs,i,l,o,r to alloc r1=ar.pfs,(i+l+o),(i+l),r */
d6285 28
a6312 26
      i = (CURR_SLOT.opnd[1].X_op == O_register
          && CURR_SLOT.opnd[1].X_add_number == REG_AR + AR_PFS) ? 2 : 1;
      if (num_operands == i + 3 /* first_arg not included in this count! */
	  && CURR_SLOT.opnd[i].X_op == O_constant
	  && CURR_SLOT.opnd[i + 1].X_op == O_constant
	  && CURR_SLOT.opnd[i + 2].X_op == O_constant
	  && CURR_SLOT.opnd[i + 3].X_op == O_constant)
	{
	  sof = set_regstack (CURR_SLOT.opnd[i].X_add_number,
			      CURR_SLOT.opnd[i + 1].X_add_number,
			      CURR_SLOT.opnd[i + 2].X_add_number,
			      CURR_SLOT.opnd[i + 3].X_add_number);

	  /* now we can parse the first arg:  */
	  saved_input_pointer = input_line_pointer;
	  input_line_pointer = first_arg;
	  sep = parse_operand (CURR_SLOT.opnd + 0, '=');
	  if (sep != '=')
	    --num_outputs;	/* force error */
	  input_line_pointer = saved_input_pointer;

	  CURR_SLOT.opnd[i].X_add_number = sof;
	  CURR_SLOT.opnd[i + 1].X_add_number
	    = sof - CURR_SLOT.opnd[i + 2].X_add_number;
	  CURR_SLOT.opnd[i + 2] = CURR_SLOT.opnd[i + 3];
	}
@


1.174
log
@gas/
2005-07-27  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.h (unw_r_record): Change type of fr_mem to unsigned
	int.
	(unw_p_record): Remove unused/redundant fields imask and rmask.
	Combine spoff and pspoff into a union. Combine gr and br into a
	union. Change type of grmask and brmask to unsigned char. Change type
	of frmask to unsigned int.
	(unw_x_record): Combine spoff, pspoff, and treg into a union.
	* config/tc-ia64.c (unwind): New field 'pending_saves'.
	(check_pending_save): New.
	(alloc_record): Clear out entire record.
	(output_psp_gr): Use renamed structure fields.
	(output_psp_sprel): Likewise.
	(output_rp_gr): Likewise.
	(output_rp_br): Likewise.
	(output_rp_psprel): Likewise.
	(output_rp_sprel): Likewise.
	(output_pfs_gr): Likewise.
	(output_pfs_psprel): Likewise.
	(output_pfs_sprel): Likewise.
	(output_preds_gr): Likewise.
	(output_preds_psprel): Likewise.
	(output_preds_sprel): Likewise.
	(output_spill_base): Likewise.
	(output_unat_gr): Likewise.
	(output_unat_psprel): Likewise.
	(output_unat_sprel): Likewise.
	(output_lc_gr): Likewise.
	(output_lc_psprel): Likewise.
	(output_lc_sprel): Likewise.
	(output_fpsr_gr): Likewise.
	(output_fpsr_psprel): Likewise.
	(output_fpsr_sprel): Likewise.
	(output_priunat_gr): Likewise.
	(output_priunat_psprel): Likewise.
	(output_priunat_sprel): Likewise.
	(output_bsp_gr): Likewise.
	(output_bsp_psprel): Likewise.
	(output_bsp_sprel): Likewise.
	(output_bspstore_gr): Likewise.
	(output_bspstore_psprel): Likewise.
	(output_bspstore_sprel): Likewise.
	(output_rnat_gr): Likewise.
	(output_rnat_psprel): Likewise.
	(output_rnat_sprel): Likewise.
	(output_spill_psprel): Likewise.
	(output_spill_sprel): Likewise.
	(output_spill_reg): Likewise.
	(output_fr_mem): Likewise. Allocate one unwind record per set mask
	bit.
	(output_frgr_mem): Likewise.
	(output_gr_mem): Likewise.
	(output_br_mem): Likewise.
	(output_gr_gr): Likewise.
	(output_br_gr): Likewise.
	(fixup_unw_records): Likewise.
	(process_one_record): Use renamed structure fields. For gr_gr and
	br_gr, collect mask from chain of records before output.
	(in_prologue): Simplify and eliminate early returns. Call
	check_pending_save.
	(in_body): Simplify and eliminate early returns.
	(dot_body): Call check_pending_save.
	(md_assemble): Update comment. Deal with pending saves.

gas/testsuite/
2005-07-27  Jan Beulich  <jbeulich@@novell.com>

	* gas/ia64/unwind-bad.l: Uncomment patterns matching new warnings.
	* gas/ia64/unwind-ok.d: Correct expectations.
@
text
@d162 1
d1087 1
d1101 2
a1102 1
     those now:  */
d1105 8
a1112 2
      S_SET_VALUE (lfix->sym, frag_now_fix ());
      symbol_set_frag (lfix->sym, frag_now);
d1115 1
d1117 1
a1117 4
    {
      S_SET_VALUE (lfix->sym, frag_now_fix ());
      symbol_set_frag (lfix->sym, frag_now);
    }
d6657 1
d6978 17
a6994 1
      if (debug_type == DEBUG_DWARF2 || md.slot[curr].loc_directive_seen)
d6999 3
a7029 13
      /* now is a good time to fix up the labels for this insn:  */
      for (lfix = md.slot[curr].label_fixups; lfix; lfix = lfix->next)
	{
	  S_SET_VALUE (lfix->sym, frag_now_fix () - 16);
	  symbol_set_frag (lfix->sym, frag_now);
	}
      /* and fix up the tags also.  */
      for (lfix = md.slot[curr].tag_fixups; lfix; lfix = lfix->next)
	{
	  S_SET_VALUE (lfix->sym, frag_now_fix () - 16 + i);
	  symbol_set_frag (lfix->sym, frag_now);
	}

d7921 1
d7933 1
@


1.173
log
@gas/
2005-07-06  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (nop): Use zero for L-unit pseudo-nop.
@
text
@d745 3
d1744 49
d1800 1
a1800 1
  ptr->next = NULL;
d1864 1
a1864 1
  ptr->r.record.p.gr = gr;
d1873 1
a1873 1
  ptr->r.record.p.spoff = offset / 4;
d1889 1
a1889 1
  ptr->r.record.p.gr = gr;
d1898 1
a1898 1
  ptr->r.record.p.br = br;
d1907 1
a1907 1
  ptr->r.record.p.pspoff = ENCODED_PSP_OFFSET (offset);
d1916 1
a1916 1
  ptr->r.record.p.spoff = offset / 4;
d1932 1
a1932 1
  ptr->r.record.p.gr = gr;
d1941 1
a1941 1
  ptr->r.record.p.pspoff = ENCODED_PSP_OFFSET (offset);
d1950 1
a1950 1
  ptr->r.record.p.spoff = offset / 4;
d1966 1
a1966 1
  ptr->r.record.p.gr = gr;
d1975 1
a1975 1
  ptr->r.record.p.pspoff = ENCODED_PSP_OFFSET (offset);
d1984 1
a1984 1
  ptr->r.record.p.spoff = offset / 4;
d1993 18
a2010 2
  ptr->r.record.p.rmask = mask;
  return ptr;
d2019 33
a2051 3
  ptr->r.record.p.grmask = gr_mask;
  ptr->r.record.p.frmask = fr_mask;
  return ptr;
d2060 2
d2063 18
a2080 2
  ptr->r.record.p.gr = reg;
  return ptr;
d2088 18
a2105 2
  ptr->r.record.p.rmask = mask;
  return ptr;
d2112 2
d2115 15
a2129 1
  return ptr;
d2133 2
a2134 2
output_br_gr (save_mask, reg)
     unsigned int save_mask;
d2138 21
a2158 3
  ptr->r.record.p.brmask = save_mask;
  ptr->r.record.p.gr = reg;
  return ptr;
d2166 1
a2166 1
  ptr->r.record.p.pspoff = ENCODED_PSP_OFFSET (offset);
d2182 1
a2182 1
  ptr->r.record.p.gr = gr;
d2191 1
a2191 1
  ptr->r.record.p.pspoff = ENCODED_PSP_OFFSET (offset);
d2200 1
a2200 1
  ptr->r.record.p.spoff = offset / 4;
d2216 1
a2216 1
  ptr->r.record.p.gr = gr;
d2225 1
a2225 1
  ptr->r.record.p.pspoff = ENCODED_PSP_OFFSET (offset);
d2234 1
a2234 1
  ptr->r.record.p.spoff = offset / 4;
d2250 1
a2250 1
  ptr->r.record.p.gr = gr;
d2259 1
a2259 1
  ptr->r.record.p.pspoff = ENCODED_PSP_OFFSET (offset);
d2268 1
a2268 1
  ptr->r.record.p.spoff = offset / 4;
d2291 1
a2291 1
  ptr->r.record.p.gr = gr;
d2300 1
a2300 1
  ptr->r.record.p.pspoff = ENCODED_PSP_OFFSET (offset);
d2309 1
a2309 1
  ptr->r.record.p.spoff = offset / 4;
d2325 1
a2325 1
  ptr->r.record.p.gr = gr;
d2334 1
a2334 1
  ptr->r.record.p.pspoff = ENCODED_PSP_OFFSET (offset);
d2343 1
a2343 1
  ptr->r.record.p.spoff = offset / 4;
d2359 1
a2359 1
  ptr->r.record.p.gr = gr;
d2368 1
a2368 1
  ptr->r.record.p.pspoff = ENCODED_PSP_OFFSET (offset);
d2377 1
a2377 1
  ptr->r.record.p.spoff = offset / 4;
d2393 1
a2393 1
  ptr->r.record.p.gr = gr;
d2402 1
a2402 1
  ptr->r.record.p.pspoff = ENCODED_PSP_OFFSET (offset);
d2411 1
a2411 1
  ptr->r.record.p.spoff = offset / 4;
d2460 1
a2460 1
  ptr->r.record.x.pspoff = ENCODED_PSP_OFFSET (offset);
d2475 1
a2475 1
  ptr->r.record.x.spoff = offset / 4;
d2491 1
a2491 1
  ptr->r.record.x.treg = targ_reg;
d2505 1
a2505 1
  unsigned long fr_mask, gr_mask;
d2571 1
a2571 1
      output_P3_format (f, ptr->r.type, ptr->r.record.p.gr);
d2574 1
a2574 1
      output_P3_format (f, rp_br, ptr->r.record.p.br);
d2577 1
a2577 1
      output_P7_format (f, psp_sprel, ptr->r.record.p.spoff, 0);
d2594 1
a2594 1
      output_P7_format (f, ptr->r.type, ptr->r.record.p.pspoff, 0);
d2606 1
a2606 1
      output_P8_format (f, ptr->r.type, ptr->r.record.p.spoff);
d2609 9
a2617 1
      output_P9_format (f, ptr->r.record.p.grmask, ptr->r.record.p.gr);
d2620 9
a2628 1
      output_P2_format (f, ptr->r.record.p.brmask, ptr->r.record.p.gr);
d2644 1
a2644 1
      output_P8_format (f, ptr->r.type, ptr->r.record.p.pspoff);
d2659 1
a2659 1
			ptr->r.record.x.pspoff);
d2664 1
a2664 1
			ptr->r.record.x.spoff);
d2669 1
a2669 1
			ptr->r.record.x.treg, ptr->r.record.x.t);
d2674 1
a2674 1
			ptr->r.record.x.t, ptr->r.record.x.pspoff);
d2679 1
a2679 1
			ptr->r.record.x.t, ptr->r.record.x.spoff);
d2684 1
a2684 1
			ptr->r.record.x.xy, ptr->r.record.x.treg,
d3020 2
a3021 2
	  region->r.record.r.mask.fr_mem |= ptr->r.record.p.rmask;
	  set_imask (region, ptr->r.record.p.rmask, t, 1);
d3029 2
a3030 2
	  region->r.record.r.mask.gr_mem |= ptr->r.record.p.rmask;
	  set_imask (region, ptr->r.record.p.rmask, t, 2);
d3359 5
a3363 12
  if (in)
    {
      /* We are in a procedure. Check if we are in a prologue.  */
      if (unwind.prologue)
	return 1;
      /* We only want to issue one message.  */
      if (in == 1)
	return unwind_diagnostic ("prologue", directive);
      else
	return -1;
    }
  return 0;
d3375 4
a3378 12
  if (in)
    {
      /* We are in a procedure. Check if we are in a body.  */
      if (unwind.body)
	return 1;
      /* We only want to issue one message.  */
      if (in == 1)
	return unwind_diagnostic ("body region", directive);
      else
	return -1;
    }
  return 0;
d4476 1
d10945 1
a10945 1
  /* Add unwind entry, if there is one.  */
d10951 12
@


1.172
log
@gas/
2005-07-01  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (line_separator_chars): Add '{' and '}'.
	(output_spill_psprel, output_spill_psprel_p): Combine.
	(output_spill_sprel, output_spill_sprel_p): Combine.
	(output_spill_reg, output_spill_regp_p): Combine.
	(process_one_record): Handle psp_psprel.
	(parse_predicate_and_operand): New.
	(convert_expr_to_ab_reg): Two new parameters. Return void. Always
	initialize output values. Emit diagnostic case here.
	(convert_expr_to_xy_reg): Likewise. Don't allow r0, f0, and f1.
	(add_unwind_entry): New second parameter. Allow first parameter to
	be NULL. Parse optional tag, emit warning about further support for
	it otherwise being missing. Check end-of-line when requested.
	(dot_fframe): Clear operand when wrong. Allow tag.
	(dot_vframe): Likewise.
	(dot_vframesp): Likewise. Rename parameter, issue warning when psp
	relative.
	(dot_vframepsp): Remove.
	(dot_altrp): Clear operand when wrong. Allow tag.
	(dot_save): Likewise. Let default case also go through
	add_unwind_entry.
	(dot_savemem): Likewise.
	(dot_restore): Don't return when wrong operand. Allow tag.
	(dot_spillreg, dot_spillreg_p): Combine. Simplify by using
	parse_predicate_and_operand and the new arguments to
	convert_expr_to_ab_reg and convert_expr_to_xy_reg. Don't return
	when wrong operand. Allow tag.
	(dot_restorereg, dot_restorereg_p): Likewise.
	(dot_spillmem, dot_spillmem_p): Likewise.
	(dot_saveg): Clear operand when wrong. Perform tighter operand
	checks. Allow tag.
	(dot_savef): Likewise.
	(dot_saveb): Likewise.
	(dot_savegf): Likewise.
	(dot_spill): Remove end-of-line check. 	Combine. Simplify by using
	parse_predicate_and_operand and the new arguments to
	convert_expr_to_ab_reg and convert_expr_to_xy_reg. Don't return
	when wrong operand. Allow tag.
	(popcount): New.
	(dot_label_state): Don't return when wrong operand.
	(dot_copy_state): Likewise.
	(dot_unwabi): Likewise. Check if in prologue.
	(dot_body): Don't call demand_empty_rest_of_line.
	(dot_prologue): Type of mask and grsave is unsigned. Perform tighter
	operand checks.
	(md_pseudo_table): Also use dot_restorereg for .restorereg.p. Also
	use dot_spillreg for .spillreg.p. Also use dot_spillmem for
	.spillpsp.p and .spillsp.p. Also use dot_vframesp for .vframepsp.
	(parse_operand): New second parameter. Don't deal with '}' here
	anymore. Don't advance past end-of-line.
	(parse_operands): Pass second argument to parse_operand.
	(ia64_start_line): Prevent out-of-bounds access through
	input_line_pointer. Deal with '}' here.
	(ia64_unrecognized_line): Don't deal with '}' here.
	(dot_alias): Use ignore_rest_of_line not its deprecated alias
	discard_rest_of_line.

gas/testsuite/
2005-07-01  Jan Beulich  <jbeulich@@novell.com>

	* gas/ia64/group-2.s: Use register as second operand of .prologue.
	* gas/ia64/unwind-err.s: Add check for .vframesp.
	* gas/ia64/unwind-err.l: Adjust.
	* gas/ia64/strange.[sd]: New.
	* gas/ia64/unwind-bad.[sl]: New.
	* gas/ia64/unwind-ok.[sd]: New.
	* gas/ia64/ia64.exp: Run new tests.
@
text
@d596 1
a596 1
    0x0008000000LL,	/* L-"unit" nop */
@


1.171
log
@Warning and partial fix for gcc -freorder-blocks-and-partition related problem.
PR 994
* config/tc-ia64.c (slot_index): Revert last change.  If first_frag
is NULL, then emit a warning, and return the current index.
@
text
@d196 1
a196 1
const char line_separator_chars[] = ";";
d739 1
a765 1
static void dot_vframepsp PARAMS ((int));
a768 1
static void dot_restorereg_p PARAMS ((int));
a779 2
static void dot_spillreg_p PARAMS ((int));
static void dot_spillmem_p PARAMS ((int));
d809 1
a809 1
static void add_unwind_entry PARAMS((unw_rec_list *ptr));
d816 1
a816 1
static int parse_operand PARAMS ((expressionS *e));
d937 1
a937 3
static unw_rec_list *output_spill_psprel PARAMS ((unsigned int, unsigned int, unsigned int));
static unw_rec_list *output_spill_sprel PARAMS ((unsigned int, unsigned int, unsigned int));
static unw_rec_list *output_spill_psprel_p PARAMS ((unsigned int, unsigned int, unsigned int,
d939 1
a939 1
static unw_rec_list *output_spill_sprel_p PARAMS ((unsigned int, unsigned int, unsigned int,
a941 2
					       unsigned int));
static unw_rec_list *output_spill_reg_p PARAMS ((unsigned int, unsigned int, unsigned int,
d952 3
a954 2
static int convert_expr_to_ab_reg PARAMS ((expressionS *, unsigned int *, unsigned int *));
static int convert_expr_to_xy_reg PARAMS ((expressionS *, unsigned int *, unsigned int *));
d2285 1
a2285 27
output_spill_psprel (ab, reg, offset)
     unsigned int ab;
     unsigned int reg;
     unsigned int offset;
{
  unw_rec_list *ptr = alloc_record (spill_psprel);
  ptr->r.record.x.ab = ab;
  ptr->r.record.x.reg = reg;
  ptr->r.record.x.pspoff = ENCODED_PSP_OFFSET (offset);
  return ptr;
}

static unw_rec_list *
output_spill_sprel (ab, reg, offset)
     unsigned int ab;
     unsigned int reg;
     unsigned int offset;
{
  unw_rec_list *ptr = alloc_record (spill_sprel);
  ptr->r.record.x.ab = ab;
  ptr->r.record.x.reg = reg;
  ptr->r.record.x.spoff = offset / 4;
  return ptr;
}

static unw_rec_list *
output_spill_psprel_p (ab, reg, offset, predicate)
d2291 1
a2291 1
  unw_rec_list *ptr = alloc_record (spill_psprel_p);
d2300 1
a2300 1
output_spill_sprel_p (ab, reg, offset, predicate)
d2306 1
a2306 1
  unw_rec_list *ptr = alloc_record (spill_sprel_p);
d2315 1
a2315 16
output_spill_reg (ab, reg, targ_reg, xy)
     unsigned int ab;
     unsigned int reg;
     unsigned int targ_reg;
     unsigned int xy;
{
  unw_rec_list *ptr = alloc_record (spill_reg);
  ptr->r.record.x.ab = ab;
  ptr->r.record.x.reg = reg;
  ptr->r.record.x.treg = targ_reg;
  ptr->r.record.x.xy = xy;
  return ptr;
}

static unw_rec_list *
output_spill_reg_p (ab, reg, targ_reg, xy, predicate)
d2322 1
a2322 1
  unw_rec_list *ptr = alloc_record (spill_reg_p);
d2533 22
d2978 25
a3002 2
convert_expr_to_ab_reg (e, ab, regp)
     expressionS *e;
d3005 2
d3008 3
a3010 1
  unsigned int reg;
d3013 1
a3013 1
    return 0;
a3014 1
  reg = e->X_add_number;
d3049 2
a3050 1
	  return 0;
a3052 1
  return 1;
d3055 3
a3057 3
static int
convert_expr_to_xy_reg (e, xy, regp)
     expressionS *e;
d3060 2
d3063 3
a3065 1
  unsigned int reg;
d3068 1
a3068 1
    return 0;
d3070 1
a3070 3
  reg = e->X_add_number;

  if (/* reg >= REG_GR && */ reg <= (REG_GR + 127))
d3075 1
a3075 1
  else if (reg >= REG_FR && reg <= (REG_FR + 127))
d3086 1
a3086 2
    return -1;
  return 1;
d3215 1
a3215 1
add_unwind_entry (ptr)
d3217 1
d3219 12
a3230 5
  if (unwind.tail)
    unwind.tail->next = ptr;
  else
    unwind.list = ptr;
  unwind.tail = ptr;
d3235 22
d3264 1
d3269 1
a3269 1
  parse_operand (&e);
d3272 5
a3276 3
    as_bad ("Operand to .fframe must be a constant");
  else
    add_unwind_entry (output_mem_stack_f (e.X_add_number));
d3285 1
d3290 1
a3290 1
  parse_operand (&e);
d3292 1
a3292 1
  if (e.X_op == O_register && reg < 128)
d3294 2
a3295 3
      add_unwind_entry (output_mem_stack_v ());
      if (! (unwind.prologue_mask & 2))
	add_unwind_entry (output_psp_gr (reg));
d3297 6
a3302 2
  else
    as_bad ("First operand to .vframe must be a general register");
d3306 2
a3307 2
dot_vframesp (dummy)
     int dummy ATTRIBUTE_UNUSED;
d3310 4
d3318 2
a3319 2
  parse_operand (&e);
  if (e.X_op == O_constant)
d3321 2
a3322 21
      add_unwind_entry (output_mem_stack_v ());
      add_unwind_entry (output_psp_sprel (e.X_add_number));
    }
  else
    as_bad ("Operand to .vframesp must be a constant (sp-relative offset)");
}

static void
dot_vframepsp (dummy)
     int dummy ATTRIBUTE_UNUSED;
{
  expressionS e;

  if (!in_prologue ("vframepsp"))
    return;

  parse_operand (&e);
  if (e.X_op == O_constant)
    {
      add_unwind_entry (output_mem_stack_v ());
      add_unwind_entry (output_psp_sprel (e.X_add_number));
d3324 2
a3325 2
  else
    as_bad ("Operand to .vframepsp must be a constant (psp-relative offset)");
d3333 1
a3334 1
  int reg1, reg2;
d3339 5
a3343 4
  sep = parse_operand (&e1);
  if (sep != ',')
    as_bad ("No second operand to .save");
  sep = parse_operand (&e2);
d3346 6
d3353 6
a3358 3

  /* Make sure its a valid ar.xxx reg, OR its br0, aka 'rp'.  */
  if (e1.X_op == O_register)
d3360 55
a3414 53
      if (e2.X_op == O_register && reg2 >= 0 && reg2 < 128)
	{
	  switch (reg1)
	    {
	    case REG_AR + AR_BSP:
	      add_unwind_entry (output_bsp_when ());
	      add_unwind_entry (output_bsp_gr (reg2));
	      break;
	    case REG_AR + AR_BSPSTORE:
	      add_unwind_entry (output_bspstore_when ());
	      add_unwind_entry (output_bspstore_gr (reg2));
	      break;
	    case REG_AR + AR_RNAT:
	      add_unwind_entry (output_rnat_when ());
	      add_unwind_entry (output_rnat_gr (reg2));
	      break;
	    case REG_AR + AR_UNAT:
	      add_unwind_entry (output_unat_when ());
	      add_unwind_entry (output_unat_gr (reg2));
	      break;
	    case REG_AR + AR_FPSR:
	      add_unwind_entry (output_fpsr_when ());
	      add_unwind_entry (output_fpsr_gr (reg2));
	      break;
	    case REG_AR + AR_PFS:
	      add_unwind_entry (output_pfs_when ());
	      if (! (unwind.prologue_mask & 4))
		add_unwind_entry (output_pfs_gr (reg2));
	      break;
	    case REG_AR + AR_LC:
	      add_unwind_entry (output_lc_when ());
	      add_unwind_entry (output_lc_gr (reg2));
	      break;
	    case REG_BR:
	      add_unwind_entry (output_rp_when ());
	      if (! (unwind.prologue_mask & 8))
		add_unwind_entry (output_rp_gr (reg2));
	      break;
	    case REG_PR:
	      add_unwind_entry (output_preds_when ());
	      if (! (unwind.prologue_mask & 1))
		add_unwind_entry (output_preds_gr (reg2));
	      break;
	    case REG_PRIUNAT:
	      add_unwind_entry (output_priunat_when_gr ());
	      add_unwind_entry (output_priunat_gr (reg2));
	      break;
	    default:
	      as_bad ("First operand not a valid register");
	    }
	}
      else
	as_bad (" Second operand not a valid register");
a3415 2
  else
    as_bad ("First operand not a register");
d3422 1
a3422 1
  expressionS e1, e2;
d3429 1
a3429 1
  sep = parse_operand (&e1);
d3431 1
a3431 4
    {
      as_bad ("First operand to .restore must be stack pointer (sp)");
      return;
    }
d3435 3
a3437 1
      parse_operand (&e2);
d3441 1
a3441 1
	  return;
d3452 1
a3452 1
      return;
d3455 1
a3455 1
  add_unwind_entry (output_epilogue (ecount));
d3464 2
a3465 2
dot_restorereg (dummy)
     int dummy ATTRIBUTE_UNUSED;
d3467 1
a3467 1
  unsigned int ab, reg;
a3468 20

  if (!in_procedure ("restorereg"))
    return;

  parse_operand (&e);

  if (!convert_expr_to_ab_reg (&e, &ab, &reg))
    {
      as_bad ("First operand to .restorereg must be a preserved register");
      return;
    }
  add_unwind_entry (output_spill_reg (ab, reg, 0, 0));
}

static void
dot_restorereg_p (dummy)
     int dummy ATTRIBUTE_UNUSED;
{
  unsigned int qp, ab, reg;
  expressionS e1, e2;
d3470 1
d3472 1
a3472 1
  if (!in_procedure ("restorereg.p"))
d3475 3
a3477 11
  sep = parse_operand (&e1);
  if (sep != ',')
    {
      as_bad ("No second operand to .restorereg.p");
      return;
    }

  parse_operand (&e2);

  qp = e1.X_add_number - REG_P;
  if (e1.X_op != O_register || qp > 63)
d3479 2
a3480 2
      as_bad ("First operand to .restorereg.p must be a predicate");
      return;
d3482 1
d3484 1
a3484 6
  if (!convert_expr_to_ab_reg (&e2, &ab, &reg))
    {
      as_bad ("Second operand to .restorereg.p must be a preserved register");
      return;
    }
  add_unwind_entry (output_spill_reg_p (ab, reg, 0, 0, qp));
d3612 1
a3612 1
  add_unwind_entry (output_endp ());
d3728 1
a3728 1
  parse_operand (&e);
d3730 6
a3735 4
  if (e.X_op == O_register && reg < 8)
    add_unwind_entry (output_rp_br (reg));
  else
    as_bad ("First operand not a valid branch register");
d3745 1
d3747 1
a3747 1
  if (!in_prologue (psprel ? "savepsp" : "savesp"))
d3750 5
a3754 4
  sep = parse_operand (&e1);
  if (sep != ',')
    as_bad ("No second operand to .save%ssp", psprel ? "p" : "");
  sep = parse_operand (&e2);
d3760 12
a3771 1
  if (e1.X_op == O_register)
d3773 64
a3836 70
      if (e2.X_op == O_constant)
	{
	  switch (reg1)
	    {
	    case REG_AR + AR_BSP:
	      add_unwind_entry (output_bsp_when ());
	      add_unwind_entry ((psprel
				 ? output_bsp_psprel
				 : output_bsp_sprel) (val));
	      break;
	    case REG_AR + AR_BSPSTORE:
	      add_unwind_entry (output_bspstore_when ());
	      add_unwind_entry ((psprel
				 ? output_bspstore_psprel
				 : output_bspstore_sprel) (val));
	      break;
	    case REG_AR + AR_RNAT:
	      add_unwind_entry (output_rnat_when ());
	      add_unwind_entry ((psprel
				 ? output_rnat_psprel
				 : output_rnat_sprel) (val));
	      break;
	    case REG_AR + AR_UNAT:
	      add_unwind_entry (output_unat_when ());
	      add_unwind_entry ((psprel
				 ? output_unat_psprel
				 : output_unat_sprel) (val));
	      break;
	    case REG_AR + AR_FPSR:
	      add_unwind_entry (output_fpsr_when ());
	      add_unwind_entry ((psprel
				 ? output_fpsr_psprel
				 : output_fpsr_sprel) (val));
	      break;
	    case REG_AR + AR_PFS:
	      add_unwind_entry (output_pfs_when ());
	      add_unwind_entry ((psprel
				 ? output_pfs_psprel
				 : output_pfs_sprel) (val));
	      break;
	    case REG_AR + AR_LC:
	      add_unwind_entry (output_lc_when ());
	      add_unwind_entry ((psprel
				 ? output_lc_psprel
				 : output_lc_sprel) (val));
	      break;
	    case REG_BR:
	      add_unwind_entry (output_rp_when ());
	      add_unwind_entry ((psprel
				 ? output_rp_psprel
				 : output_rp_sprel) (val));
	      break;
	    case REG_PR:
	      add_unwind_entry (output_preds_when ());
	      add_unwind_entry ((psprel
				 ? output_preds_psprel
				 : output_preds_sprel) (val));
	      break;
	    case REG_PRIUNAT:
	      add_unwind_entry (output_priunat_when_mem ());
	      add_unwind_entry ((psprel
				 ? output_priunat_psprel
				 : output_priunat_sprel) (val));
	      break;
	    default:
	      as_bad ("First operand not a valid register");
	    }
	}
      else
	as_bad (" Second operand not a valid constant");
a3837 2
  else
    as_bad ("First operand not a register");
d3844 2
a3845 1
  expressionS e1, e2;
d3851 11
a3861 1
  sep = parse_operand (&e1);
d3863 3
a3865 1
    parse_operand (&e2);
d3867 8
a3874 8
  if (e1.X_op != O_constant)
    as_bad ("First operand to .save.g must be a constant.");
  else
    {
      int grmask = e1.X_add_number;
      if (sep != ',')
	add_unwind_entry (output_gr_mem (grmask));
      else
d3876 2
a3877 5
	  int reg = e2.X_add_number - REG_GR;
	  if (e2.X_op == O_register && reg >= 0 && reg < 128)
	    add_unwind_entry (output_gr_gr (grmask, reg));
	  else
	    as_bad ("Second operand is an invalid register.");
d3879 1
d3881 2
d3889 1
a3889 2
  expressionS e1;
  int sep;
d3894 1
a3894 1
  sep = parse_operand (&e1);
d3896 8
a3903 4
  if (e1.X_op != O_constant)
    as_bad ("Operand to .save.f must be a constant.");
  else
    add_unwind_entry (output_fr_mem (e1.X_add_number));
d3910 3
a3912 4
  expressionS e1, e2;
  unsigned int reg;
  unsigned char sep;
  int brmask;
d3917 6
a3922 2
  sep = parse_operand (&e1);
  if (e1.X_op != O_constant)
d3924 2
a3925 2
      as_bad ("First operand to .save.b must be a constant.");
      return;
a3926 1
  brmask = e1.X_add_number;
d3930 11
a3940 3
      sep = parse_operand (&e2);
      reg = e2.X_add_number - REG_GR;
      if (e2.X_op != O_register || reg > 127)
d3942 2
a3943 2
	  as_bad ("Second operand to .save.b must be a general register.");
	  return;
d3945 1
a3945 1
      add_unwind_entry (output_br_gr (brmask, e2.X_add_number));
d3948 1
a3948 4
    add_unwind_entry (output_br_mem (brmask));

  if (!is_end_of_line[sep] && !is_it_end_of_statement ())
    demand_empty_rest_of_line ();
a3955 1
  int sep;
d3960 26
a3985 3
  sep = parse_operand (&e1);
  if (sep == ',')
    parse_operand (&e2);
d3987 1
a3987 8
  if (e1.X_op != O_constant || sep != ',' || e2.X_op != O_constant)
    as_bad ("Both operands of .save.gf must be constants.");
  else
    {
      int grmask = e1.X_add_number;
      int frmask = e2.X_add_number;
      add_unwind_entry (output_frgr_mem (grmask, frmask));
    }
a3994 1
  unsigned char sep;
d3999 1
a3999 3
  sep = parse_operand (&e);
  if (!is_end_of_line[sep] && !is_it_end_of_statement ())
    demand_empty_rest_of_line ();
d4002 5
a4006 3
    as_bad ("Operand to .spill must be a constant");
  else
    add_unwind_entry (output_spill_base (e.X_add_number));
d4010 2
a4011 2
dot_spillreg (dummy)
     int dummy ATTRIBUTE_UNUSED;
d4014 3
a4016 2
  unsigned int ab, xy, reg, treg;
  expressionS e1, e2;
d4018 1
a4018 1
  if (!in_procedure ("spillreg"))
d4021 3
a4023 2
  sep = parse_operand (&e1);
  if (sep != ',')
d4025 2
a4026 2
      as_bad ("No second operand to .spillreg");
      return;
d4028 1
d4030 5
a4034 7
  parse_operand (&e2);

  if (!convert_expr_to_ab_reg (&e1, &ab, &reg))
    {
      as_bad ("First operand to .spillreg must be a preserved register");
      return;
    }
d4036 1
a4036 7
  if (!convert_expr_to_xy_reg (&e2, &xy, &treg))
    {
      as_bad ("Second operand to .spillreg must be a register");
      return;
    }

  add_unwind_entry (output_spill_reg (ab, reg, treg, xy));
d4043 4
a4046 22
  expressionS e1, e2;
  int sep;
  unsigned int ab, reg;

  if (!in_procedure ("spillmem"))
    return;

  sep = parse_operand (&e1);
  if (sep != ',')
    {
      as_bad ("Second operand missing");
      return;
    }

  parse_operand (&e2);

  if (!convert_expr_to_ab_reg (&e1, &ab, &reg))
    {
      as_bad ("First operand to .spill%s must be a preserved register",
	      psprel ? "psp" : "sp");
      return;
    }
d4048 1
a4048 1
  if (e2.X_op != O_constant)
d4050 2
a4051 3
      as_bad ("Second operand to .spill%s must be a constant",
	      psprel ? "psp" : "sp");
      return;
a4052 3

  if (psprel)
    add_unwind_entry (output_spill_psprel (ab, reg, e2.X_add_number));
d4054 1
a4054 2
    add_unwind_entry (output_spill_sprel (ab, reg, e2.X_add_number));
}
d4056 1
a4056 10
static void
dot_spillreg_p (dummy)
     int dummy ATTRIBUTE_UNUSED;
{
  int sep;
  unsigned int ab, xy, reg, treg;
  expressionS e1, e2, e3;
  unsigned int qp;

  if (!in_procedure ("spillreg.p"))
d4059 3
a4061 2
  sep = parse_operand (&e1);
  if (sep != ',')
d4063 2
a4064 2
      as_bad ("No second and third operand to .spillreg.p");
      return;
d4066 1
d4068 5
a4072 2
  sep = parse_operand (&e2);
  if (sep != ',')
d4074 2
a4075 77
      as_bad ("No third operand to .spillreg.p");
      return;
    }

  parse_operand (&e3);

  qp = e1.X_add_number - REG_P;

  if (e1.X_op != O_register || qp > 63)
    {
      as_bad ("First operand to .spillreg.p must be a predicate");
      return;
    }

  if (!convert_expr_to_ab_reg (&e2, &ab, &reg))
    {
      as_bad ("Second operand to .spillreg.p must be a preserved register");
      return;
    }

  if (!convert_expr_to_xy_reg (&e3, &xy, &treg))
    {
      as_bad ("Third operand to .spillreg.p must be a register");
      return;
    }

  add_unwind_entry (output_spill_reg_p (ab, reg, treg, xy, qp));
}

static void
dot_spillmem_p (psprel)
     int psprel;
{
  expressionS e1, e2, e3;
  int sep;
  unsigned int ab, reg;
  unsigned int qp;

  if (!in_procedure ("spillmem.p"))
    return;

  sep = parse_operand (&e1);
  if (sep != ',')
    {
      as_bad ("Second operand missing");
      return;
    }

  parse_operand (&e2);
  if (sep != ',')
    {
      as_bad ("Second operand missing");
      return;
    }

  parse_operand (&e3);

  qp = e1.X_add_number - REG_P;
  if (e1.X_op != O_register || qp > 63)
    {
      as_bad ("First operand to .spill%s_p must be a predicate",
	      psprel ? "psp" : "sp");
      return;
    }

  if (!convert_expr_to_ab_reg (&e2, &ab, &reg))
    {
      as_bad ("Second operand to .spill%s_p must be a preserved register",
	      psprel ? "psp" : "sp");
      return;
    }

  if (e3.X_op != O_constant)
    {
      as_bad ("Third operand to .spill%s_p must be a constant",
	      psprel ? "psp" : "sp");
      return;
d4079 1
a4079 1
    add_unwind_entry (output_spill_psprel_p (ab, reg, e3.X_add_number, qp));
d4081 1
a4081 1
    add_unwind_entry (output_spill_sprel_p (ab, reg, e3.X_add_number, qp));
d4148 4
a4151 2
  parse_operand (&e);
  if (e.X_op != O_constant)
d4154 1
a4154 1
      return;
d4156 1
a4156 2
  add_unwind_entry (output_label_state (e.X_add_number));
  save_prologue_count (e.X_add_number, unwind.prologue_count);
d4168 4
a4171 2
  parse_operand (&e);
  if (e.X_op != O_constant)
d4174 1
a4174 1
      return;
d4176 1
a4176 2
  add_unwind_entry (output_copy_state (e.X_add_number));
  unwind.prologue_count = get_saved_prologue_count (e.X_add_number);
d4186 1
a4186 1
  if (!in_procedure ("unwabi"))
d4189 5
a4193 9
  sep = parse_operand (&e1);
  if (sep != ',')
    {
      as_bad ("Second operand to .unwabi missing");
      return;
    }
  sep = parse_operand (&e2);
  if (!is_end_of_line[sep] && !is_it_end_of_statement ())
    demand_empty_rest_of_line ();
d4198 1
a4198 1
      return;
d4204 1
a4204 1
      return;
d4207 1
a4207 1
  add_unwind_entry (output_unwabi (e1.X_add_number, e2.X_add_number));
d4314 1
a4314 2
  add_unwind_entry (output_body ());
  demand_empty_rest_of_line ();
d4321 1
a4321 2
  unsigned char sep;
  int mask = 0, grsave = 0;
d4336 12
a4347 7
      expressionS e1, e2;
      sep = parse_operand (&e1);
      if (sep != ',')
	as_bad ("No second operand to .prologue");
      sep = parse_operand (&e2);
      if (!is_end_of_line[sep] && !is_it_end_of_statement ())
	demand_empty_rest_of_line ();
d4349 14
a4362 1
      if (e1.X_op == O_constant)
d4364 8
a4371 1
	  mask = e1.X_add_number;
d4373 1
a4373 7
	  if (e2.X_op == O_constant)
	    grsave = e2.X_add_number;
	  else if (e2.X_op == O_register
		   && (grsave = e2.X_add_number - REG_GR) < 128)
	    ;
	  else
	    as_bad ("Second operand not a constant or general register");
d4375 2
a4376 5
	  add_unwind_entry (output_prologue_gr (mask, grsave));
	}
      else
	as_bad ("First operand not a constant");
    }
d4378 1
a4378 1
    add_unwind_entry (output_prologue ());
d4382 1
d5287 1
a5287 1
    { "vframepsp", dot_vframepsp, 0 },
d5291 1
a5291 1
    { "restorereg.p", dot_restorereg_p, 0 },
d5305 3
a5307 3
    { "spillreg.p", dot_spillreg_p, 0 },
    { "spillsp.p", dot_spillmem_p, 0 },
    { "spillpsp.p", dot_spillmem_p, 1 },
d6000 1
a6000 1
parse_operand (e)
d6002 1
d6009 4
a6012 13
  if (*input_line_pointer != '}')
    expression (e);
  sep = *input_line_pointer++;

  if (sep == '}')
    {
      if (!md.manual_bundling)
	as_warn ("Found '}' when manual bundling is off");
      else
	CURR_SLOT.manual_bundling_off = 1;
      md.manual_bundling = 0;
      sep = '\0';
    }
d6071 1
a6071 1
	  sep = parse_operand (CURR_SLOT.opnd + i);
d6079 1
a6079 1
	  sep = parse_operand (&dummy);
d6124 1
a6124 1
	  sep = parse_operand (CURR_SLOT.opnd + 0);
d7561 9
d7592 1
a7592 11
}

/* This is a hook for ia64_frob_label, so that it can distinguish tags from
   labels.  */
static int defining_tag = 0;

int
ia64_unrecognized_line (ch)
     int ch;
{
  switch (ch)
a7593 20
    case '(':
      expression (&md.qp);
      if (*input_line_pointer++ != ')')
	{
	  as_bad ("Expected ')'");
	  return 0;
	}
      if (md.qp.X_op != O_register)
	{
	  as_bad ("Qualifying predicate expected");
	  return 0;
	}
      if (md.qp.X_add_number < REG_P || md.qp.X_add_number >= REG_P + 64)
	{
	  as_bad ("Predicate register expected");
	  return 0;
	}
      return 1;

    case '{':
d7610 3
a7612 3
      return 1;

    case '}':
d7625 6
d7632 19
a7650 4
      /* Allow '{' to follow on the same line.  We also allow ";;", but that
	 happens automatically because ';' is an end of line marker.  */
      SKIP_WHITESPACE ();
      if (input_line_pointer[0] == '{')
d7652 2
a7653 2
	  input_line_pointer++;
	  return ia64_unrecognized_line ('{');
a7654 2

      demand_empty_rest_of_line ();
d11677 1
a11677 1
      discard_rest_of_line ();
@


1.170
log
@PR 994
* config/tc-ia64.c (slot_index): Check for a NULL first_frag.
@
text
@d2658 1
a2658 1
  while (first_frag != NULL && slot_frag != first_frag)
d2711 20
@


1.169
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@d2658 1
a2658 1
  while (slot_frag != first_frag)
@


1.168
log
@gas/
2005-05-27  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (struct proc_pending): New.
	(unwind): Replace proc_start with proc_pending.
	(unwind_diagnostic): Check unwind.proc_pending.sym.
	(dot_proc): Replace unwind.proc_start with unwind.proc_pending.sym.
	Check if previous proc not closed. Record all entry points.
	(dot_endp): Replace unwind.proc_start with unwind.proc_pending.sym.
	Set symbol sizes for entry points recorded in dot_proc. Check
	arguments for consistency with respective .proc's.
	(md_assemble): Replace unwind.proc_start with
	unwind.proc_pending.sym.

gas/testsuite/
2005-05-27  Jan Beulich  <jbeulich@@novell.com>

	* gas/ia64/proc.l: Adjust.
@
text
@d5998 1
a5998 1
	     create a dummy reloc.  This will not live past md_apply_fix3.  */
d11058 1
a11058 1
     relocs available).  See md_apply_fix3().  */
d11405 1
a11405 1
md_apply_fix3 (fix, valP, seg)
@


1.167
log
@gas/
2005-05-27  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (emit_one_bundle): Restrict scope of ptr, end_ptr,
	and last_ptr. Check all in-use slots for first one with non-NULL
	unwind_record. Don't reload end_ptr before second update round.
@
text
@d712 6
d729 1
a729 1
  symbolS *proc_start;
d3140 1
a3140 1
  if (unwind.proc_start
d4277 15
a4292 1
  unwind.proc_start = 0;
d4308 6
a4313 1
	  else if (unwind.proc_start == 0)
d4315 3
a4317 1
	      unwind.proc_start = sym;
d4327 6
a4332 2
  if (unwind.proc_start == 0)
    unwind.proc_start = expr_build_dot ();
d4424 1
a4424 2
  char *name, *default_name, *p, c;
  symbolS *sym;
d4473 5
a4477 5
      if (!S_IS_LOCAL (unwind.proc_start)
	  && S_IS_DEFINED (unwind.proc_start))
	e.X_add_symbol = symbol_temp_new (S_GET_SEGMENT (unwind.proc_start),
					  S_GET_VALUE (unwind.proc_start),
					  symbol_get_frag (unwind.proc_start));
d4479 1
a4479 1
	e.X_add_symbol = unwind.proc_start;
d4501 12
a4512 47
  if (unwind.proc_start)
    default_name = (char *) S_GET_NAME (unwind.proc_start);
  else
    default_name = NULL;

  /* Parse names of main and alternate entry points and set symbol sizes.  */
  while (1)
    {
      SKIP_WHITESPACE ();
      name = input_line_pointer;
      c = get_symbol_end ();
      p = input_line_pointer;
      if (!*name)
	{
	  if (md.unwind_check == unwind_check_warning)
	    {
	      if (default_name)
		{
		  as_warn ("Empty argument of .endp. Use the default name `%s'",
			   default_name);
		  name = default_name;
		}
	      else
		as_warn ("Empty argument of .endp");
	    }
	  else
	    as_bad ("Empty argument of .endp");
	}
      if (*name)
	{
	  sym = symbol_find (name);
	  if (!sym
	      && md.unwind_check == unwind_check_warning
	      && default_name
	      && default_name != name)
	    {
	      /* We have a bad name. Try the default one if needed.  */
	      as_warn ("`%s' was not defined within procedure. Use the default name `%s'",
		       name, default_name);
	      name = default_name;
	      sym = symbol_find (name);
	    }
	  if (!sym || !S_IS_DEFINED (sym))
	    as_bad ("`%s' was not defined within procedure", name);
	  else if (unwind.proc_start
	      && (symbol_get_bfdsym (sym)->flags & BSF_FUNCTION)
	      && S_GET_SIZE (sym) == 0 && symbol_get_obj (sym)->size == NULL)
a4513 1
	      fragS *fr = symbol_get_frag (unwind.proc_start);
d4516 1
a4516 5
	      /* Check whether the function label is at or beyond last
		 .proc directive.  */
	      while (fr && fr != frag)
		fr = fr->fr_next;
	      if (fr)
d4533 30
d4571 15
a4585 1
  unwind.proc_start = unwind.info = 0;
d10821 1
a10821 1
  if (unwind.proc_start && S_IS_DEFINED (unwind.proc_start))
@


1.166
log
@Fix issues noticed while reviewing Jan Beulich's MLX template bug fix.
* config/tc-ia64.c (extra_goodness): Update comment.
(md_begin): Add debugging code to print best_template table.
@
text
@a6481 1
  unw_rec_list *ptr, *last_ptr, *end_ptr;
d6536 3
a6538 1
      ptr = md.slot[curr].unwind_record;
d6548 5
a6552 3
	  last_ptr = NULL;
	  end_ptr = md.slot[(curr + 1) % NUM_SLOTS].unwind_record;
	  for (; ptr != end_ptr; ptr = ptr->next)
a6819 1
	  end_ptr = md.slot[(curr + 1) % NUM_SLOTS].unwind_record;
@


1.165
log
@gas/
2005-05-25  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (md_begin): Don't try to match slot 2 of an MLX
	template.
@
text
@d7144 3
a7146 2
/* Add a bit of extra goodness if a nop of type F or B would fit
   in TEMPL at SLOT.  */
d7324 15
@


1.164
log
@gas/
2005-05-25  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (ia64_gen_real_reloc_type): Also handle
	BFD_RELOC_UNUSED when determining the width of the reloc.
@
text
@d7291 1
a7291 1
		      if (match (t, k, 2))
d7307 1
a7307 1
		  if (match (t, j, 2))
@


1.163
log
@gas/
2005-05-25  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (dot_endp): Clear out all three pointers in unwind
	section entry.
@
text
@d11251 1
@


1.162
log
@gas/
2005-05-25  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (dot_radix): Rewrite.

gas/testsuite/
2005-05-25  Jan Beulich  <jbeulich@@novell.com>

	* gas/ia64/radix.s: New.
	* gas/ia64/radix.l: New.
	* gas/ia64/ia64.exp: Run new test.
@
text
@a4388 1
  char *ptr;
d4435 1
a4435 1
      ptr = frag_more (3 * md.pointer_size);
a4467 4
      else
	md_number_to_chars (ptr + (bytes_per_address * 2), 0,
			    bytes_per_address);

@


1.161
log
@gas/
2005-05-25  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (struct unw_rec_list): Remove next_slot_number
	and next_slot_frag.
	(alloc_record): Remove references to next_slot_number and
	next_slot_frag.
	(emit_one_bundle): Likewise.
@
text
@d3073 2
a3074 1
  int radix;
a3076 1
  radix = *input_line_pointer++;
d3078 9
a3086 6
  if (radix != 'C' && !is_end_of_line[(unsigned char) radix])
    {
      as_bad ("Radix `%c' unsupported", *input_line_pointer);
      ignore_rest_of_line ();
      return;
    }
@


1.160
log
@gas/
2005-05-19  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (dot_endp): Don't use global symbol for unwind
	relocations in unwind section.

gas/testsuite/
2005-05-19  Jan Beulich  <jbeulich@@novell.com>

	* gas/ia64/reloc-uw.s: New.
	* gas/ia64/reloc-uw.d: New.
	* gas/ia64/reloc-uw-ilp32.d: New.
	* gas/ia64/ia64.exp: Run new test.
@
text
@a697 2
  unsigned long next_slot_number;
  fragS *next_slot_frag;
a1750 2
  ptr->next_slot_number = 0;
  ptr->next_slot_frag = 0;
a6920 6

  if (unwind.list)
    {
      unwind.list->next_slot_number = (unsigned long) f + 16;
      unwind.list->next_slot_frag = frag_now;
    }
@


1.159
log
@gas/

2005-05-07  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 940
	* config/tc-ia64.c (start_unwind_section): Properly check
	comdat group with SHF_GROUP.

gas/testsuite/

2005-05-07  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 940
	* gas/ia64/group-2.d: New.
	* gas/ia64/group-2.s: New.

	* gas/ia64/ia64.exp: Add "group-2".
@
text
@d4445 7
a4451 1
      e.X_add_symbol = unwind.proc_start;
@


1.158
log
@Fix ia64-hpux build failure, patch from Steve Ellcey.
* config/tc-ia64.c (MIN): Undef.
@
text
@d3538 2
a3539 1
  if (suffix == text_name && (text_seg->flags & SEC_LINK_ONCE) != 0)
@


1.157
log
@Update the address and phone number of the FSF
@
text
@d59 3
@


1.156
log
@2005-04-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-aout.h (S_IS_EXTERN): Removed.
	* config/obj-bout.h (S_IS_EXTERN): Likewise.
	* config/obj-coff.h (S_IS_EXTERN): Likewise.
	* symbols.c (S_IS_EXTERN): Likewise.
	* symbols.h (S_IS_EXTERN): Likewise.

	* config/tc-alpha.c (tc_gen_reloc): Replace S_IS_EXTERN with
	S_IS_EXTERNAL.
	* config/tc-d10v.c (md_apply_fix3): Likewise.
	* config/tc-ia64.c (ia64_fix_adjustable): Likewise.
	* config/tc-iq2000.c (iq2000_fix_adjustable): Likewise.
	* config/tc-m32r.c (m32r_fix_adjustable): Likewise.
	* config/tc-mmix.c (mmix_adjust_symtab): Likewise.
	* config/tc-sh64.c (shmedia_frob_file_before_adjust): Likewise.
	(shmedia_md_convert_frag): Likewise.
	* symbols.c (print_symbol_value_1): Likewise.
	* write.c (write_object_file): Likewise.
@
text
@d20 2
a21 2
   the Free Software Foundation, 59 Temple Place - Suite 330,
   Boston, MA 02111-1307, USA.  */
@


1.155
log
@	* config/tc-ia64.c (specify_resource): Initialize all of tmpl.
@
text
@d10847 1
a10847 1
  if (S_IS_EXTERN (fix->fx_addsy) || S_IS_WEAK (fix->fx_addsy))
@


1.154
log
@	* config/tc-ia64.c (md_assemble): Fix error message for wrong
	access to application registers.

testsuite/:
	* gas/ia64/invalid-ar.l: Adapt to changed error message.
@
text
@d8174 2
d8179 4
@


1.153
log
@gas/
2005-04-19  Jan Beulich  <jbeulich@@novell.com>

	PR/847
	* config/tc-ia64.c (ia64_canonicalize_symbol_name): Re-allow zero-
	length symbols.
@
text
@d10695 1
a10695 1
	    as_bad ("AR %d cannot be accessed by %c-unit",
@


1.152
log
@bfd/

2005-04-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf.c (bfd_elf_set_group_contents): Ignore linker created
	group section.
	(assign_section_numbers): Accept link_info. Check SHT_GROUP
	sections for relocatable files only. Remove the linker created
	group sections.
	(_bfd_elf_compute_section_file_positions): Pass link_info to
	assign_section_numbers.

	* elfxx-ia64.c (elfNN_ia64_object_p): New.
	(elf_backend_object_p): Defined.

gas/

2005-04-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-ia64.c (start_unwind_section): Undo the change
	of 2004-08-18.
	(generate_unwind_image, dot_endp): Likewise.
@
text
@a8024 2
      else
	as_bad ("Zero-length symbol is illegal");
@


1.151
log
@Patch from David Mosberger, to avoid nop.f on Itanium2.
* config/tc-ia64.c (ia64_handle_align): Move le_nop and
le_nop_stop arrays and initializers to file scope.
(md_begin): When generating code for anything other than
Itanium 1, use MMI instead of MFI NOP bundles as a filler.
@
text
@d3463 1
a3463 1
start_unwind_section (const segT text_seg, int sec_index, int linkonce_empty)
a3524 2
  else if (linkonce_empty)
    return;
d3612 1
a3612 1
      start_unwind_section (text_seg, SPECIAL_SECTION_UNWIND_INFO, 0);
a3652 2
  else
    start_unwind_section (text_seg, SPECIAL_SECTION_UNWIND_INFO, 1);
d4425 1
a4425 1
      start_unwind_section (saved_seg, SPECIAL_SECTION_UNWIND, 0);
a4464 3
  else
    start_unwind_section (saved_seg, SPECIAL_SECTION_UNWIND, 1);

@


1.150
log
@gas/

2005-03-28  David Mosberger  <davidm@@hpl.hp.com>
	    H.J. Lu  <hongjiu.lu@@intel.com>

	PR 803
	NEWS: Mention "-mtune=[itanium1|itanium2]".

	* config/tc-ia64.c (md): Add tune.
	(md_parse_option): Accepted "-mtune=[itanium1|itanium2]".
	(md_show_usage): Add "-mtune=[itanium1|itanium2]".
	(extra_goodness): Prefer M- and I-unit NOPs for itanium2. F and
	B unit NOPs are discouraged for McKinley-derived cores.
	(md_begin): Don't hardcode the "extra_goodness()" function in
	the comment...
	(ia64_init): Set md.tune to itanium2.

	* doc/as.texinfo: Add -mtune=[itanium1|itanium2]".
	* doc/c-ia64.texi: Likewise.

gas/testsuite/

2005-03-28  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 803
	* gas/ia64/dv-imply.d: Pass -mtune=itanium1 to as.
	* gas/ia64/dv-mutex.d : Likewise.
	* gas/ia64/dv-safe.d: Likewise.
	* gas/ia64/dv-srlz.d.nop: Likewise.
	* gas/ia64/ldxmov-1.d: Likewise.
	* gas/ia64/opc-b.d: Likewise.
	* gas/ia64/opc-f.d: Likewise.
	* gas/ia64/opc-i.d: Likewise.
	* gas/ia64/opc-m.d: Likewise.
	* gas/ia64/operand-or.d: Likewise.
	* gas/ia64/pcrel.d: Likewise.
	* gas/ia64/pseudo.d: Likewise.
	* gas/ia64/tls.d: Likewise.

ld/testsuite/

2005-03-28  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 803
	* ld-ia64/ia64.exp: Pass -mtune=itanium1 to as.
@
text
@d331 15
d7277 7
a11540 8
  /* Use mfi bundle of nops with no stop bits.  */
  static const unsigned char le_nop[]
    = { 0x0c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00};
  static const unsigned char le_nop_stop[]
    = { 0x0d, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00};

@


1.149
log
@gas/
2005-03-08  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (emit_one_bundle): Track last slot user insn was
	emitted to. Add more precise diagnostics for non-fitting insns based
	on that. Eliminate now superfluous special casing of MLX. Clear out
	slot information when dropping an insn.

gas/testsuite/
2005-03-08  Jan Beulich  <jbeulich@@novell.com>

	* gas/ia64/no-fit.[ls]: New.
	* gas/ia64/ia64.exp: Run new test.
@
text
@d232 7
d6967 10
d7089 2
d7144 24
a7167 5
  if (slot == 1 && match (templ, IA64_TYPE_F, slot))
    return 2;
  if (slot == 2 && match (templ, IA64_TYPE_B, slot))
    return 1;
  return 0;
d7263 3
a7265 4
     base 4 value, in which each match counts for 3, each F counts
     for 2, each B counts for 1.  This should maximize the number of
     F and B nops in the chosen bundles, which is good because these
     pipelines are least likely to be overcommitted.  */
d7466 1
@


1.149.2.1
log
@gas/
2005-04-20  Jan Beulich  <jbeulich@@novell.com>

	PR/847
	* config/tc-ia64.c (ia64_canonicalize_symbol_name): Re-allow zero-
	length symbols.
@
text
@d7972 2
@


1.149.2.2
log
@gas/
2005-05-18  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (dot_endp): Don't use global symbol for unwind
	relocations in unwind section.

gas/testsuite/
2005-05-18  Jan Beulich  <jbeulich@@novell.com>

	* gas/ia64/reloc-uw.s: New.
	* gas/ia64/reloc-uw.d: New.
	* gas/ia64/reloc-uw-ilp32.d: New.
	* gas/ia64/ia64.exp: Run new test.
@
text
@d4423 1
a4423 7
      if (!S_IS_LOCAL (unwind.proc_start)
	  && S_IS_DEFINED (unwind.proc_start))
	e.X_add_symbol = symbol_temp_new (S_GET_SEGMENT (unwind.proc_start),
					  S_GET_VALUE (unwind.proc_start),
					  symbol_get_frag (unwind.proc_start));
      else
	e.X_add_symbol = unwind.proc_start;
@


1.148
log
@gas/
2005-03-08  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (parse_section_name): Rename to...
	(cross_section): In addition to separating the name from the rest of
	the arguments, also carry out the operation.
	(dot_xdata): Use cross_section.
	(dot_float_cons): Likewise.
	(dot_xstringer): Likewise.
	(dot_xdata_ua): Likewise.
	(dot_float_cons_ua): Likewise. Pass float_cons, not stmt_float_cons.

gas/testsuite/
2005-03-08  Jan Beulich  <jbeulich@@novell.com>

	* gas/ia64/xdata.[sd], gas/ia64/xdata-ilp32.d: New.
	* gas/ia64/ia64.exp: Run new tests.
@
text
@d6462 1
a6462 1
  int n, i, j, first, curr;
d6514 1
d6780 1
a6780 21
	{
	  if (required_unit == IA64_UNIT_L
	      && insn_unit == IA64_UNIT_I
	      && !(idesc->flags & IA64_OPCODE_X_IN_MLX))
	    {
	      /* we got ourselves an MLX template but the current
		 instruction isn't an X-unit, or an I-unit instruction
		 that can go into the X slot of an MLX template.  Duh.  */
	      if (md.num_slots_in_use >= NUM_SLOTS)
		{
		  as_bad_where (md.slot[curr].src_file,
				md.slot[curr].src_line,
				"`%s' can't go in X slot of "
				"MLX template", idesc->name);
		  /* drop this insn so we don't livelock:  */
		  --md.num_slots_in_use;
		}
	      break;
	    }
	  continue;		/* try next slot */
	}
d6814 1
d6859 29
a6887 4
	  as_bad_where (md.slot[curr].src_file, md.slot[curr].src_line,
			"`%s' does not fit into %s template",
			idesc->name, ia64_templ_desc[template].name);
	  --md.num_slots_in_use;
@


1.147
log
@	* cgen.c: Warning fixes.
	* config/tc-arc.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-frv.c: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ip2k.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-xstormy16.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d768 1
a768 1
static char *parse_section_name PARAMS ((void));
d4760 9
a4768 5
static char *
parse_section_name ()
{
  char *name;
  int len;
d4771 6
a4776 1
  if (*input_line_pointer == '"')
d4778 7
a4786 1
      char *start = input_line_pointer;
d4793 1
a4793 1
	  return 0;
a4794 1
      name = obstack_copy (&notes, start, input_line_pointer - start + 1);
d4797 1
a4797 5
  if (!name)
    {
      ignore_rest_of_line ();
      return 0;
    }
d4803 1
a4803 1
      return 0;
d4805 17
a4821 2
  ++input_line_pointer;		/* skip comma */
  return name;
d4828 1
a4828 9
  char *name = parse_section_name ();
  if (!name)
    return;

  md.keep_pending_output = 1;
  set_section (name);
  cons (size);
  obj_elf_previous (0);
  md.keep_pending_output = 0;
d4874 1
a4874 9
  char *name = parse_section_name ();
  if (!name)
    return;

  md.keep_pending_output = 1;
  set_section (name);
  stmt_float_cons (kind);
  obj_elf_previous (0);
  md.keep_pending_output = 0;
d4881 1
a4881 9
  char *name = parse_section_name ();
  if (!name)
    return;

  md.keep_pending_output = 1;
  set_section (name);
  stringer (zero);
  obj_elf_previous (0);
  md.keep_pending_output = 0;
d4888 1
a4888 12
  int saved_auto_align = md.auto_align;
  char *name = parse_section_name ();
  if (!name)
    return;

  md.keep_pending_output = 1;
  set_section (name);
  md.auto_align = 0;
  cons (size);
  md.auto_align = saved_auto_align;
  obj_elf_previous (0);
  md.keep_pending_output = 0;
d4895 1
a4895 12
  int saved_auto_align = md.auto_align;
  char *name = parse_section_name ();
  if (!name)
    return;

  md.keep_pending_output = 1;
  set_section (name);
  md.auto_align = 0;
  stmt_float_cons (kind);
  md.auto_align = saved_auto_align;
  obj_elf_previous (0);
  md.keep_pending_output = 0;
@


1.146
log
@Respect bundle directives.
* config/tc-ia64.c (emit_one_bundle): Stop filling a bundle if we
see an instruction that specifies a template.
@
text
@d1155 1
a1155 1
static unsigned char *vbyte_mem_ptr = NULL;
d1332 1
a1332 1
  (*f) (imask_size, imask, NULL);
d3920 2
a3921 1
  int sep, ab, xy, reg, treg;
d3956 2
a3957 1
  int sep, ab, reg;
d3995 2
a3996 1
  int sep, ab, xy, reg, treg;
d4047 2
a4048 1
  int sep, ab, reg;
d4368 1
a4368 1
  unsigned char *ptr;
d6355 2
a6356 1
  bfd_signed_vma insn, val;
@


1.145
log
@gas/

2005-02-17  H.J. Lu  <hongjiu.lu@@intel.com>

	* NEWS: Mention "-mhint.b=[ok|warning|error]".

	* config/tc-ia64.c (md): Add hint_b.
	(emit_one_bundle): Handle md.hint_b for "hint".
	(md_parse_option): Accepted "-mhint.b=[ok|warning|error]".
	(md_show_usage): Add "-mhint.b=[ok|warning|error]".
	(ia64_init): Set md.hint_b to error.
	(md_assemble): Handle md.hint_b for "hint.b".

	* doc/as.texinfo: Add "-mhint.b=[ok|warning|error]".
	* doc/c-ia64.texi: Likewise.

gas/testsuite/

2005-02-17  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/ia64/hint.b-err.l: New file.
	* gas/ia64/hint.b-err.s: Likewise.
	* gas/ia64/hint.b-warn.l: Likewise.
	* gas/ia64/hint.b-warn.s: Likewise.

	* gas/ia64/ia64.exp: Run hint.b-err and hint.b-warn.

	* gas/ia64/opc-b.d: Pass -mhint.b=ok to as.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004
d6575 5
d10159 1
d10181 1
@


1.144
log
@gas/
2005-02-17  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (ia64_parse_name): Don't advance 'name' when
	parsing inN, locN, outN. Set 'idx' to offset register number starts
	at. Don't handle numbers with leading zeroes or beyond 95. Remove
	pointless cast.

gas/testsuite/
2005-02-17  Jan Beulich  <jbeulich@@novell.com>

	* gas/ia64/nostkreg.[ds]: New.
	* gas/ia64/ia64.exp: Run new test.
@
text
@d232 8
a6715 1
	      || (strcmp (idesc->name, "hint") == 0)
d6718 26
d6952 12
d7078 2
d7432 1
d10651 14
@


1.143
log
@gas/
2005-02-15  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (md_apply_fix3): Call ia64_gen_real_reloc_type
	instead of explicitly dealing with the translation; exclude
	relocations that are already pcrel, however.

gas/testsuite/
2005-02-15  Jan Beulich  <jbeulich@@novell.com>

	* gas/ia64/pcrel.[ds]: New.
	* gas/ia64/ia64.exp: Run new test.
@
text
@a7737 1
  unsigned int regnum;
d7843 1
d7850 1
a7850 1
	  name += 2;
d7858 1
a7858 1
	  name += 3;
d7866 1
a7866 1
	  name += 3;
d7874 2
a7875 1
  if (dr)
d7877 2
d7880 2
a7881 2
      regnum = strtoul (name, &end, 10);
      if (end > name && *end == '\0')
d7883 1
a7883 1
	  if ((unsigned) regnum >= dr->num_regs)
@


1.142
log
@gas/
2005-02-15  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c: Include limits.h (if available).
	(gr_values[0]): Set path to INT_MAX.
	(dot_reg_val): Don't allow changing value of r0. Limit range of
	general registers at r127.
	(specify_resource): Default resource index is -1. Don't set resource
	index (in case IA64_RS_RSE) without setting the specific flag.
	(note_register_values): Check operand is O_constant before tracking
	input value of moves. Add tracking for dep.z with constant inputs.
	(print_dependency): Resource index of specific resource may be zero.
	(check_dependencies): Likewise.

gas/testsuite/
2005-02-15  Jan Beulich  <jbeulich@@novell.com>

	* gas/ia64/dv-raw-err.l: Expect specific resource for RAW violation on b0.
	* gas/ia64/regval.[ls]: New.
	* gas/ia64/ia64.exp: Run new test.
@
text
@d11246 18
a11263 21
      switch (fix->fx_r_type)
	{
	case BFD_RELOC_IA64_DIR32MSB:
	  fix->fx_r_type = BFD_RELOC_IA64_PCREL32MSB;
	  break;

	case BFD_RELOC_IA64_DIR32LSB:
	  fix->fx_r_type = BFD_RELOC_IA64_PCREL32LSB;
	  break;

	case BFD_RELOC_IA64_DIR64MSB:
	  fix->fx_r_type = BFD_RELOC_IA64_PCREL64MSB;
	  break;

	case BFD_RELOC_IA64_DIR64LSB:
	  fix->fx_r_type = BFD_RELOC_IA64_PCREL64LSB;
	  break;

	default:
	  break;
	}
@


1.141
log
@gas/
2005-02-15  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (parse_operands): New local variables reg1, reg2,
	reg_class. Check operands and emit diagnostics for illegal use of
	registers.

gas/testsuite/
2005-02-15  Jan Beulich  <jbeulich@@novell.com>

	* gas/ia64/dv-raw-err.s: Don't use r0 or f0 as output operand.
	* gas/ia64/dv-waw-err.s: Likewise.
	* gas/ia64/reg-err.[ls]: New.
	* gas/ia64/ia64.exp: Run new test.
@
text
@d54 4
d634 11
a644 1
} gr_values[128] = {{ 1, 0, 0 }};
d4930 1
a4930 1
      if (regno < REG_GR || regno > REG_GR + 128)
d8077 1
a8077 1
  tmpl.index = 0;
d9320 1
a9320 2
		  specs[count] = tmpl;
		  specs[count++].index = 0; /* IA64_RSE_BSPLOAD/RNATBITINDEX */
d9774 1
d9792 24
d10036 1
a10036 1
      if (regdeps[depind].specific && regdeps[depind].index != 0)
d10234 1
a10234 1
	      if (rs->specific && rs->index != 0)
@


1.140
log
@bfd/
2005-02-15  Jan Beulich  <jbeulich@@novell.com>

	* elfxx-ia64.c (ia64_howto_table): Correct strings for
	R_IA64_DTPMOD64[LM]SB.

gas/
2005-02-15  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (ia64_gen_real_reloc_type): Define and initialize
	new variables type, suffix, and width. Handle
	BFD_RELOC_IA64_DIR(32|64)[LM]SB in FUNC_LT_FPTR_RELATIVE case.
	Handle BFD_RELOC_IA64_DIR64[LM]SB in FUNC_TP_RELATIVE case. Add
	FUNC_DTP_MODULE case. Handle BFD_RELOC_IA64_DIR32[LM]SB in
	FUNC_DTP_RELATIVE case. Return incoming relocation type if
	BFD_RELOC_IA64_IPLT[LM]SB in FUNC_IPLT_RELOC case. Generate warning
	if unable to translate relocation type, using the new variables.

gas/testsuite/
2005-02-15  Jan Beulich  <jbeulich@@novell.com>

	* gas/ia64/reloc.[ds]: New.
	* gas/ia64/reloc-bad.[ls]: New.
	* gas/ia64/ia64.exp: Run new tests.
@
text
@d6015 2
d6198 121
@


1.139
log
@gas/
2005-02-15  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.h (ia64_symbol_chars): Declare.
	(ty_symbol_chars): Define.
	* config/tc-ia64.c (ia64_symbol_chars): Define.
@
text
@d10741 1
d10758 1
a10758 1
	default:			break;
d10771 1
a10771 1
	default:			break;
d10780 1
a10780 1
	default:			break;
d10788 1
a10788 1
	default:			break;
d10801 1
a10801 1
	default:			break;
d10812 1
a10812 1
	default:			break;
d10823 1
a10823 1
	default:			break;
d10834 1
a10834 1
	default:			break;
d10845 1
a10845 1
	default:			break;
d10856 8
d10865 1
a10865 1
	  break;
d10872 6
a10877 8
	case BFD_RELOC_IA64_IMM14:
	  new = BFD_RELOC_IA64_TPREL14; break;
	case BFD_RELOC_IA64_IMM22:
	  new = BFD_RELOC_IA64_TPREL22; break;
	case BFD_RELOC_IA64_IMM64:
	  new = BFD_RELOC_IA64_TPREL64I; break;
	default:
	  break;
d10887 13
a10899 1
	  break;
d10909 1
a10909 1
	  break;
d10916 4
d10931 1
a10931 1
	  break;
d10941 1
a10941 1
	  break;
d10946 6
a10957 1
  /* Hmmmm.  Should this ever occur?  */
d10961 22
a10982 1
    return r_type;
@


1.138
log
@gas/
2005-02-15  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (ia64_parse_name): Only update next character if
	input_line_pointer was advanced.

gas/testsuite/
2005-02-15  Jan Beulich  <jbeulich@@novell.com>

	* gas/ia64/operand-or.d: Pass -xnone to assembler.
@
text
@d177 4
@


1.137
log
@gas/
2005-02-13  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (md_parse_option): Handle -xnone and -xdebugn.
	(md_show_usage): Add -xnone, -xdebugn, and -xdebugx. Relocate default
	indicator.
	(ia64_init): Set md.detect_dv.
	(ia64_start_line): New static variable warned. Warn only once when
	encountering explicit stops in automatic mode.
	* doc/c-ia64.texi: Describe -xnone, -xdebugn, and -xdebugx.
	* NEWS: Mention new default mode.

gas/testsuite/
2005-02-13  Jan Beulich  <jbeulich@@novell.com>

	* gas/ia64/label.l: Adjust line numbers.
	* gas/ia64/label.s: Add .explicit.
	* gas/ia64/nop_x.s: Likewise.
	* gas/ia64/opc-a.d: Add assembler option -xnone.
	* gas/ia64/opc-b.d: Likewise.
	* gas/ia64/opc-f.d: Likewise.
	* gas/ia64/opc-i.d: Likewise.
	* gas/ia64/opc-m.d: Likewise.
	* gas/ia64/opc-x.d: Likewise.
	* gas/ia64/pseudo.d: Likewise.
	* gas/ia64/regs.d: Likewise.
	* gas/ia64/tls.d: Likewise.
	* gas/ia64/unwind-err.l: Adjust line numbers.
	* gas/ia64/unwind-err.s: Remove explicit stops.

ld/testsuite/
2005-02-13  Jan Beulich  <jbeulich@@novell.com>

	* ld-elfvers/vers.exp (as_options): New. Set to -x for ia64.
	(build_binary): Pass as_options to ld_assemble.
	(test_ldfail): Likewise.
	(build_exec): Likewise.
	Pass as_options to run_ld_link_tests.
	* ld-ia64/tlsbin.s: Add .explicit.
	* ld-ia64/tlsbinpic.s: Likewise.
	* ld-ia64/tlspic1.s: Likewise.
@
text
@d7622 1
a7622 1
	      goto done;
d7665 2
a7681 2
    done:
      *nextcharP = *input_line_pointer;
@


1.136
log
@gas/
2005-02-13  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (dot_rot): Add comment that name strings should
	be freed when wiping out previous state. Canonicalize names before
	use. Free name string when detecting redefinition.
	(dot_pred_rel): Call generic expression parser to process arguments.
	Handle O_register case for individual predicates and O_subtract for
	ranges.
	(ia64_parse_name): Canonicalize name before looking it up in dynamic
	register hash.
	(ia64_canonicalize_symbol_name): Strip off all trailing # characters.
	Warn if multiple found, issue error if resulting symbol name has zero
	length.
	(dot_alias): Canonicalize name before use.

gas/testsuite/
2005-02-13  Jan Beulich  <jbeulich@@novell.com>

	* gas/ia64/pound.[ls]: New.
	* gas/ia64/ia64.exp: Run new test.
@
text
@d6833 4
d6846 5
d6892 8
a6899 3
  -x | -xexplicit	  turn on dependency violation checking (default)\n\
  -xauto		  automagically remove dependency violations\n\
  -xdebug		  debug dependency violation checker\n"),
d7241 1
d7319 9
a7327 1
	as_warn (_("Explicit stops are ignored in auto mode"));
@


1.135
log
@2005-02-11  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-ia64.c (unwind_diagnostic): Return -1 for warning
	and 0 for error.
	(in_procedure): Return -1 for warning.
	(in_prologue): Likewise.
	(in_body): Likewise.
@
text
@d4563 1
d4572 1
a4573 1
      len = (input_line_pointer - start);
a4621 4
      name = obstack_alloc (&notes, len + 1);
      memcpy (name, start, len);
      name[len] = '\0';

d4628 4
d4642 1
d5065 1
a5065 1
      valueT bit = 1;
d5067 1
d5069 39
a5107 3
      if (TOUPPER (*input_line_pointer) != 'P'
	  || (regno = atoi (++input_line_pointer)) < 0
	  || regno > 63)
d5113 1
a5113 8
      while (ISDIGIT (*input_line_pointer))
	++input_line_pointer;
      if (p1 == -1)
	p1 = regno;
      else if (p2 == -1)
	p2 = regno;
      bit <<= regno;
      if (mask & bit)
d5115 1
a5115 33
      mask |= bit;
      count++;
      /* See if it's a range.  */
      if (*input_line_pointer == '-')
	{
	  valueT stop = 1;
	  ++input_line_pointer;

	  if (TOUPPER (*input_line_pointer) != 'P'
	      || (regno = atoi (++input_line_pointer)) < 0
	      || regno > 63)
	    {
	      as_bad (_("Predicate register expected"));
	      ignore_rest_of_line ();
	      return;
	    }
	  while (ISDIGIT (*input_line_pointer))
	    ++input_line_pointer;
	  stop <<= regno;
	  if (bit >= stop)
	    {
	      as_bad (_("Bad register range"));
	      ignore_rest_of_line ();
	      return;
	    }
	  while (bit < stop)
	    {
	      bit <<= 1;
	      mask |= bit;
	      count++;
	    }
	  SKIP_WHITESPACE ();
	}
d7731 3
d7753 14
a7766 3
  size_t len = strlen (name);
  if (len > 1 && name[len - 1] == '#')
    name[len - 1] = '\0';
d11335 1
@


1.134
log
@2005-02-11  H.J. Lu  <hongjiu.lu@@intel.com>

	(dot_xdata): Undo the last change. Section name is used by
	set_section.
	(dot_float_cons): Likewise.
	(dot_xstringer): Likewise.
	(dot_xdata_ua): Likewise.
	(dot_float_cons_ua): Likewise.
@
text
@d3058 3
a3060 1
static void
d3064 4
a3067 1
    as_warn (".%s outside of %s", directive, region);
d3072 1
d3076 5
d3087 1
a3087 2
  unwind_diagnostic ("procedure", directive);
  return 0;
d3090 5
d3098 2
a3099 1
  if (in_procedure (directive))
d3104 5
a3108 1
      unwind_diagnostic ("prologue", directive);
d3113 5
d3121 2
a3122 1
  if (in_procedure (directive))
d3127 5
a3131 1
      unwind_diagnostic ("body region", directive);
@


1.133
log
@gas/

2005-02-11  H.J. Lu  <hongjiu.lu@@intel.com>

	* NEWS: Mention "-munwind-check=[warning|error]".

	* config/tc-ia64.c (md): Add unwind_check.
	(unwind_diagnostic): New.
	(in_procedure): Call unwind_diagnostic when a directive isn't
	in procedure.
	(in_prologue): Call unwind_diagnostic when a directive isn't in
	prologue.
	(in_body): Call unwind_diagnostic when a directive isn't in
	body region.
	(dot_endp): Set md.unwind_check to error before calling
	in_procedure and restore it after. When the name is missing or
	couldn't be found, use the one from the last .proc if
	md.unwind_check isn't error. Warn if md.unwind_check is
	warning.
	(md_parse_option): Handle "-munwind-check=[warning|error]".
	(md_show_usage): Add "-munwind-check=[warning|error]".
	(ia64_init): Set md.unwind_check to warning.

	* doc/as.texinfo: Add "-munwind-check=[none|warning|error]".
	* doc/c-ia64.texi: Likewise.

gas/testcase

2005-02-11  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/ia64/ia64.exp: Pass -munwind-check=error for unwind-err
	and proc.
@
text
@a4746 1
  obstack_free (&notes, name);
a4800 1
  obstack_free (&notes, name);
a4815 1
  obstack_free (&notes, name);
a4831 1
  obstack_free (&notes, name);
a4849 1
  obstack_free (&notes, name);
@


1.132
log
@gas/
2005-02-11  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.h (LEX_AT): Include LEX_BEGIN_NAME.
	(LEX_QM): Likewise.
	(ia64_parse_name): New third parameter.
	(md_parse_name): Pass third argument.
	* config/tc-ia64.c (pseudo_func): Placeholders use NULL as name.
	(md_operand): Handling of '@@'-prefixed symbols moved from here...
	(ia64_parse_name): ...to here.
@
text
@d234 7
d3058 12
d3076 1
a3076 2
  as_bad (".%s outside of procedure", directive);
  ignore_rest_of_line ();
d3085 1
d3088 1
a3088 2
      as_bad (".%s outside of prologue", directive);
      ignore_rest_of_line ();
d3098 1
d3101 1
a3101 2
      as_bad (".%s outside of body region", directive);
      ignore_rest_of_line ();
d4313 1
a4313 1
  char *name, *p, c;
d4315 1
d4317 1
d4320 1
d4392 5
d4405 16
a4420 2
	as_bad ("Empty argument of .endp");
      else
d4423 11
d6743 10
d6856 2
d7192 3
a7194 4
/* Set the elf type to 64 bit ABI by default.  Cannot do this in md_begin
   because that is called after md_parse_option which is where we do the
   dynamic changing of md.flags based on -mlp64 or -milp32.  Also, set the
   default endianness.  */
d7202 2
@


1.131
log
@gas/
2005-02-11  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (md): Remove last_groups and group_idx.
	(errata_nop_necessary_p): Remove declaraction and definition.
	(emit_one_bundle): Don't call errata_nop_necessary_p. Don't
	update md.group_idx. Don't reset md.last_groups.
@
text
@d498 4
a501 4
    { "", 0, { 0 } },	/* placeholder for FUNC_LT_FPTR_RELATIVE */
    { "", 0, { 0 } },	/* placeholder for FUNC_LT_DTP_MODULE */
    { "", 0, { 0 } },	/* placeholder for FUNC_LT_DTP_RELATIVE */
    { "", 0, { 0 } },	/* placeholder for FUNC_LT_TP_RELATIVE */
d7478 1
a7478 1
ia64_parse_name (name, e)
d7481 1
d7486 1
d7490 83
a10397 5
  enum pseudo_type pseudo_type;
  const char *name;
  size_t len;
  int ch, i;

a10399 85
    case '@@':
      /* Find what relocation pseudo-function we're dealing with.  */
      pseudo_type = 0;
      ch = *++input_line_pointer;
      for (i = 0; i < NELEMS (pseudo_func); ++i)
	if (pseudo_func[i].name && pseudo_func[i].name[0] == ch)
	  {
	    len = strlen (pseudo_func[i].name);
	    if (strncmp (pseudo_func[i].name + 1,
			 input_line_pointer + 1, len - 1) == 0
		&& !is_part_of_name (input_line_pointer[len]))
	      {
		input_line_pointer += len;
		pseudo_type = pseudo_func[i].type;
		break;
	      }
	  }
      switch (pseudo_type)
	{
	case PSEUDO_FUNC_RELOC:
	  SKIP_WHITESPACE ();
	  if (*input_line_pointer != '(')
	    {
	      as_bad ("Expected '('");
	      goto err;
	    }
	  /* Skip '('.  */
	  ++input_line_pointer;
	  expression (e);
	  if (*input_line_pointer++ != ')')
	    {
	      as_bad ("Missing ')'");
	      goto err;
	    }
	  if (e->X_op != O_symbol)
	    {
	      if (e->X_op != O_pseudo_fixup)
		{
		  as_bad ("Not a symbolic expression");
		  goto err;
		}
	      if (i != FUNC_LT_RELATIVE)
		{
		  as_bad ("Illegal combination of relocation functions");
		  goto err;
		}
	      switch (S_GET_VALUE (e->X_op_symbol))
		{
		case FUNC_FPTR_RELATIVE:
		  i = FUNC_LT_FPTR_RELATIVE; break;
		case FUNC_DTP_MODULE:
		  i = FUNC_LT_DTP_MODULE; break;
		case FUNC_DTP_RELATIVE:
		  i = FUNC_LT_DTP_RELATIVE; break;
		case FUNC_TP_RELATIVE:
		  i = FUNC_LT_TP_RELATIVE; break;
		default:
		  as_bad ("Illegal combination of relocation functions");
		  goto err;
		}
	    }
	  /* Make sure gas doesn't get rid of local symbols that are used
	     in relocs.  */
	  e->X_op = O_pseudo_fixup;
	  e->X_op_symbol = pseudo_func[i].u.sym;
	  break;

	case PSEUDO_FUNC_CONST:
	  e->X_op = O_constant;
	  e->X_add_number = pseudo_func[i].u.ival;
	  break;

	case PSEUDO_FUNC_REG:
	  e->X_op = O_register;
	  e->X_add_number = pseudo_func[i].u.ival;
	  break;

	default:
	  name = input_line_pointer - 1;
	  get_symbol_end ();
	  as_bad ("Unknown pseudo function `%s'", name);
	  goto err;
	}
      break;

d10405 1
a10405 1
	  as_bad ("Closing bracket misssing");
@


1.130
log
@gas/
2005-02-11  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (parse_section_name): Handle non-quoted first
	argument.
	(dot_xdata): Free section name after use.
	(dot_float_cons): Likewise.
	(dot_xstringer): Likewise.
	(dot_xdata_ua): Likewise.
	(dot_float_cons_ua): Likewise.
	(md_pseudo_table): Add xdata16 and xdata16.ua.
@
text
@a294 19
    /* Support for hardware errata workarounds.  */

    /* Record data about the last three insn groups.  */
    struct group
    {
      /* B-step workaround.
	 For each predicate register, this is set if the corresponding insn
	 group conditionally sets this register with one of the affected
	 instructions.  */
      int p_reg_set[64];
      /* B-step workaround.
	 For each general register, this is set if the corresponding insn
	 a) is conditional one one of the predicate registers for which
	    P_REG_SET is 1 in the corresponding entry of the previous group,
	 b) sets this general register with one of the affected
	    instructions.  */
      int g_reg_set_conditionally[128];
    } last_groups[3];
    int group_idx;
a758 1
static int errata_nop_necessary_p PARAMS ((struct slot *, enum ia64_unit));
a6118 92
/* Keep track of state necessary to determine whether a NOP is necessary
   to avoid an erratum in A and B step Itanium chips, and return 1 if we
   detect a case where additional NOPs may be necessary.  */
static int
errata_nop_necessary_p (slot, insn_unit)
     struct slot *slot;
     enum ia64_unit insn_unit;
{
  int i;
  struct group *this_group = md.last_groups + md.group_idx;
  struct group *prev_group = md.last_groups + (md.group_idx + 2) % 3;
  struct ia64_opcode *idesc = slot->idesc;

  /* Test whether this could be the first insn in a problematic sequence.  */
  if (insn_unit == IA64_UNIT_F)
    {
      for (i = 0; i < idesc->num_outputs; i++)
	if (idesc->operands[i] == IA64_OPND_P1
	    || idesc->operands[i] == IA64_OPND_P2)
	  {
	    int regno = slot->opnd[i].X_add_number - REG_P;
	    /* Ignore invalid operands; they generate errors elsewhere.  */
	    if (regno >= 64)
	      return 0;
	    this_group->p_reg_set[regno] = 1;
	  }
    }

  /* Test whether this could be the second insn in a problematic sequence.  */
  if (insn_unit == IA64_UNIT_M && slot->qp_regno > 0
      && prev_group->p_reg_set[slot->qp_regno])
    {
      for (i = 0; i < idesc->num_outputs; i++)
	if (idesc->operands[i] == IA64_OPND_R1
	    || idesc->operands[i] == IA64_OPND_R2
	    || idesc->operands[i] == IA64_OPND_R3)
	  {
	    int regno = slot->opnd[i].X_add_number - REG_GR;
	    /* Ignore invalid operands; they generate errors elsewhere.  */
	    if (regno >= 128)
	      return 0;
	    if (strncmp (idesc->name, "add", 3) != 0
		&& strncmp (idesc->name, "sub", 3) != 0
		&& strncmp (idesc->name, "shladd", 6) != 0
		&& (idesc->flags & IA64_OPCODE_POSTINC) == 0)
	      this_group->g_reg_set_conditionally[regno] = 1;
	  }
    }

  /* Test whether this could be the third insn in a problematic sequence.  */
  for (i = 0; i < NELEMS (idesc->operands) && idesc->operands[i]; i++)
    {
      if (/* For fc, ptc, ptr, tak, thash, tpa, ttag, probe, ptr, ptc.  */
	  idesc->operands[i] == IA64_OPND_R3
	  /* For mov indirect.  */
	  || idesc->operands[i] == IA64_OPND_RR_R3
	  || idesc->operands[i] == IA64_OPND_DBR_R3
	  || idesc->operands[i] == IA64_OPND_IBR_R3
	  || idesc->operands[i] == IA64_OPND_PKR_R3
	  || idesc->operands[i] == IA64_OPND_PMC_R3
	  || idesc->operands[i] == IA64_OPND_PMD_R3
	  || idesc->operands[i] == IA64_OPND_MSR_R3
	  || idesc->operands[i] == IA64_OPND_CPUID_R3
	  /* For itr.  */
	  || idesc->operands[i] == IA64_OPND_ITR_R3
	  || idesc->operands[i] == IA64_OPND_DTR_R3
	  /* Normal memory addresses (load, store, xchg, cmpxchg, etc.).  */
	  || idesc->operands[i] == IA64_OPND_MR3)
	{
	  int regno = slot->opnd[i].X_add_number - REG_GR;
	  /* Ignore invalid operands; they generate errors elsewhere.  */
	  if (regno >= 128)
	    return 0;
	  if (idesc->operands[i] == IA64_OPND_R3)
	    {
	      if (strcmp (idesc->name, "fc") != 0
		  && strcmp (idesc->name, "tak") != 0
		  && strcmp (idesc->name, "thash") != 0
		  && strcmp (idesc->name, "tpa") != 0
		  && strcmp (idesc->name, "ttag") != 0
		  && strncmp (idesc->name, "ptr", 3) != 0
		  && strncmp (idesc->name, "ptc", 3) != 0
		  && strncmp (idesc->name, "probe", 5) != 0)
		return 0;
	    }
	  if (prev_group->g_reg_set_conditionally[regno])
	    return 1;
	}
    }
  return 0;
}

a6569 3
      if (errata_nop_necessary_p (md.slot + curr, insn_unit))
	as_warn (_("Additional NOP may be necessary to workaround Itanium processor A/B step errata"));

a6620 6
      if (end_of_insn_group)
	{
	  md.group_idx = (md.group_idx + 1) % 3;
	  memset (md.last_groups + md.group_idx, 0, sizeof md.last_groups[0]);
	}

@


1.129
log
@gas/
2005-02-02  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (dot_pred_rel): Update comment. Handle @@-prefixed
	designators along with quoted ones. Free copy of quoted designator
	when done.

gas/testsuite/
2005-02-02  Jan Beulich  <jbeulich@@novell.com>

	* gas/ia64/pred-rel.s: New.
	* gas/ia64/ia64.exp: Run new test.
@
text
@d4674 3
a4676 1
  if (*input_line_pointer != '"')
d4678 11
a4688 3
      as_bad ("Missing section name");
      ignore_rest_of_line ();
      return 0;
a4689 1
  name = demand_copy_C_string (&len);
d4716 1
d4771 1
d4787 1
d4804 1
d4823 1
d5249 1
d5261 1
@


1.128
log
@	* config/atof-ieee.c, config/obj-coff.c, config/obj-elf.c,
	config/obj-ieee.c, config/obj-som.c, config/obj-vms.c,
	config/tc-a29k.c, config/tc-alpha.c, config/tc-arc.c,
	config/tc-arm.c, config/tc-d30v.c, config/tc-dlx.c,
	config/tc-fr30.c, config/tc-h8300.c, config/tc-h8500.c,
	config/tc-i370.c, config/tc-i386.c, config/tc-i960.c,
	config/tc-ia64.c, config/tc-m32r.c, config/tc-m32r.h,
	config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-mips.c,
	config/tc-mn10200.c, config/tc-msp430.c, config/tc-ns32k.c,
	config/tc-openrisc.c, config/tc-or32.c, config/tc-pdp11.c,
	config/tc-pj.c, config/tc-sparc.h, config/tc-tic54x.c,
	config/tc-tic80.c, config/tc-v850.c, config/tc-w65.c,
	config/tc-xtensa.c, config/tc-z8k.c, config/xtensa-relax.c: Remove
	#if 0'd code throughout.
@
text
@d4931 3
a4933 3
  .pred.rel.clear [p1 [,p2 [,...]]]     (also .pred.rel "clear")
  .pred.rel.imply p1, p2                (also .pred.rel "imply")
  .pred.rel.mutex p1, p2 [,...]         (also .pred.rel "mutex")
d4947 1
a4947 1
      if (*input_line_pointer != '"')
d4949 10
a4958 3
	  as_bad (_("Missing predicate relation type"));
	  ignore_rest_of_line ();
	  return;
d4960 1
a4960 1
      else
d4962 3
a4964 2
	  int len;
	  char *form = demand_copy_C_string (&len);
d4971 13
a4983 6
	  else
	    {
	      as_bad (_("Unrecognized predicate relation type"));
	      ignore_rest_of_line ();
	      return;
	    }
@


1.127
log
@gas/
2005-01-31  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (parse_operands): Parse all specified operands,
	immediately discarding (but counting) those exceeding the maximum
	possible amount. Track whether output and input operand counts ever
	matched, and use this to better indicate which of the operands/
	operand types was wrong; specifically don't default to pointing to
	the first operand.

gas/testsuite/
2005-01-31  Jan Beulich  <jbeulich@@novell.com>

	* gas/ia64/operands.[ls]: New.
	* gas/ia64/ia64.exp: Run new test.
@
text
@a5192 3
#if 0
    { "estate", dot_estate, 0 },
#endif
a5203 4
#if 0
    { "lb", dot_scope, 0 },
    { "le", dot_scope, 1 },
#endif
a6598 5
#if 0
	  else
	    /* no other resolved dynamic ops have collisions */
	    know (!get_next_opcode (idesc));
#endif
a9634 4
#if 0
  if (md.debug_dv)
    fprintf (stderr, "  No %s conflicts\n", rs->dependency->name);
#endif
a10034 6
#if 0
      if (md.debug_dv && !count)
	fprintf (stderr, "  No %s %s usage found (path %d)\n",
		 dv_mode[dep->mode], dep->name, md.path);
#endif

a10250 3
#if 0
	  know (!idesc->next);
#endif
@


1.126
log
@gas/
2005-01-31  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (unwind): Remove proc_end (now an automatic
	variable in dot_endp). Add body and insn. Make prologue,
	prologue_mask, body, and insn bitfields.
	(fixup_unw_records): Remove spurious new-lines from end of diagnostic
	messages.
	(in_procedure, in_prologue, in_body): New.
	(dot_fframe, dot_vframe, dot_vframesp, dot_vframepsp, dot_save,
	dot_restore, dot_restorereg, dot_restorereg_p, dot_handlerdata,
	dot_unwentry, dot_altrp, dot_savemem, dot_saveg, dot_savef, dot_saveb,
	dot_savegf, dot_spill, dot_spillreg, dot_spillmem, dot_spillreg_p,
	dot_spillmem_p, dot_label_state, dot_copy_state, dot_unwabi,
	dot_personality): Use the appropriate one of the above.
	(dot_proc): Clear unwind.proc_start; set to current location only if
	none of the entry points were valid. Check for non-zero-length entry
	point names. Check that entry points aren't defined, yet. Clear
	unwind.prologue, unwind.body, and unwind.insn.
	(dot_body): Call in_procedure. Check that first directive in procedure
	had no insns emitted before. Set unwind.body.
	(dot_prologue): Call in_procedure. Check that not already in prologue.
	Check that first directive in procedure had no insns emitted before.
	Clear unwind.body.
	(dot_endp): Call in_procedure. Declare proc_end. Check for non-zero-
	length entry point names. Check that entry points became defined.
	(md_assemble): Set unwind.insn once unwind.proc_start is defined.

gas/testsuite/
2005-01-31  Jan Beulich  <jbeulich@@novell.com>

	* gas/ia64/proc.[ls]: New.
	* gas/ia64/unwind-err.[ls]: New.
	* gas/ia64/ia64.exp: Run new tests.
@
text
@d5959 1
a5959 1
  for (; i < NELEMS (CURR_SLOT.opnd); ++i)
d5961 14
a5974 3
      sep = parse_operand (CURR_SLOT.opnd + i);
      if (CURR_SLOT.opnd[i].X_op == O_absent)
	break;
d6028 1
a6028 1
  highest_unmatched_operand = 0;
a6030 1
  expected_operand = idesc->operands[0];
d6035 9
a6095 4
      if (num_operands < NELEMS (idesc->operands)
	  && idesc->operands[num_operands])
	continue;		/* mismatch in number of arguments */

d6104 4
@


1.125
log
@gas/
2005-01-31  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (emit_one_bundle): Snapshot manual bundling state
	before actually using it. Don't generate an error in manual bundling
	mode when looking at an insn requiring slot 2 but not yet at slot 2.
	Don't generate an error in manual bundling mode when looking at an
	insn required to be last in its group but the required slot hasn't
	been reached, yet. Allow conversion from MII to MI;I for bundle
	consisting of only 2 insns with the stop between them. Suppress
	various meaningless errors resulting from detecting earlier ones.

gas/testsuite/
2005-01-31  Jan Beulich  <jbeulich@@novell.com>

	* gas/ia64/bundling.[ds]: New.
	* gas/ia64/label.[ls]: New.
	* gas/ia64/last.[ls]: New.
	* gas/ia64/slot2.[ls]: New.
	* gas/ia64/ia64.exp: Run new tests.
@
text
@a686 1
  symbolS *proc_end;
d694 4
a697 2
  int prologue;
  int prologue_mask;
d2789 1
a2789 1
	      as_bad ("frgr_mem record before region record!\n");
d2800 1
a2800 1
	      as_bad ("fr_mem record before region record!\n");
d2809 1
a2809 1
	      as_bad ("gr_mem record before region record!\n");
d2818 1
a2818 1
	      as_bad ("br_mem record before region record!\n");
d2828 1
a2828 1
	      as_bad ("gr_gr record before region record!\n");
d2836 1
a2836 1
	      as_bad ("br_gr record before region record!\n");
d3071 37
d3129 3
d3147 3
d3168 3
d3187 3
d3208 3
d3288 3
d3333 3
d3354 3
d3590 2
d3609 2
d3622 3
d3641 3
d3736 4
d3768 4
d3789 3
d3824 4
d3849 3
d3869 3
d3903 3
d3943 3
d3993 3
d4101 3
d4120 3
d4140 3
d4173 2
d4193 1
a4193 1
  unwind.proc_start = expr_build_dot ();
d4202 3
a4204 2
      sym = symbol_find_or_make (name);
      if (unwind.proc_start == 0)
d4206 8
a4213 1
	  unwind.proc_start = sym;
a4214 1
      symbol_get_bfdsym (sym)->flags |= BSF_FUNCTION;
d4221 2
d4226 1
d4228 2
d4238 5
d4245 1
d4258 11
d4301 1
d4318 3
d4341 2
d4344 1
a4344 1
      unwind.proc_end = expr_build_dot ();
d4368 1
a4368 1
      e.X_add_symbol = unwind.proc_end;
d4398 19
a4416 17
      sym = symbol_find (name);
      if (sym && unwind.proc_start
	  && (symbol_get_bfdsym (sym)->flags & BSF_FUNCTION)
	  && S_GET_SIZE (sym) == 0 && symbol_get_obj (sym)->size == NULL)
	{
	  fragS *fr = symbol_get_frag (unwind.proc_start);
	  fragS *frag = symbol_get_frag (sym);

	  /* Check whether the function label is at or beyond last
	     .proc directive.  */
	  while (fr && fr != frag)
	    fr = fr->fr_next;
	  if (fr)
	    {
	      if (frag == frag_now && SEG_NORMAL (now_seg))
		S_SET_SIZE (sym, frag_now_fix () - S_GET_VALUE (sym));
	      else
d4418 13
a4430 8
		  symbol_get_obj (sym)->size =
		    (expressionS *) xmalloc (sizeof (expressionS));
		  symbol_get_obj (sym)->size->X_op = O_subtract;
		  symbol_get_obj (sym)->size->X_add_symbol
		    = symbol_new (FAKE_LABEL_NAME, now_seg,
				  frag_now_fix (), frag_now);
		  symbol_get_obj (sym)->size->X_op_symbol = sym;
		  symbol_get_obj (sym)->size->X_add_number = 0;
d4441 1
a4441 1
  unwind.proc_start = unwind.proc_end = unwind.info = 0;
d10371 2
@


1.124
log
@gas/
2005-01-31  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (parse_operands): Also handle alloc without first
	input being ar.pfs.

gas/testsuite/
2005-01-31  Jan Beulich  <jbeulich@@novell.com>

	* gas/ia64/pseudo.[ds]: New.
	* gas/ia64/ia64.exp: Run new test.

opcodes/
2005-01-31  Jan Beulich  <jbeulich@@novell.com>

	* ia64-gen.c (NELEMS): Define.
	(shrink): Generate alias with missing second predicate register when
	opcode has two outputs and these are both predicates.
	* ia64-opc-i.c (FULL17): Define.
	(ia64_opcodes_i): Add mov-to-pr alias without second input. Use FULL17
	here to generate output template.
	(TBITCM, TNATCM): Undefine after use.
	* ia64-opc-m.c (ia64_opcodes_i): Add alloc alias without ar.pfs as
	first input. Add ld16 aliases without ar.csd as second output. Add
	st16 aliases without ar.csd as second input. Add cmpxchg aliases
	without ar.ccv as third input. Add cmp8xchg16 aliases without ar.csd/
	ar.ccv as third/fourth inputs. Consolidate through...
	(CMPXCHG_acq, CMPXCHG_rel, CMPXCHG_1, CMPXCHG_2, CMPXCHG_4, CMPXCHG_8,
	CMPXCHGn, CMP8XCHG16, CMPXCHG_ALL): Define.
	* ia64-asmtab.c: Regenerate.
@
text
@d6160 1
a6160 2
  unsigned int manual_bundling_on = 0, manual_bundling_off = 0;
  unsigned int manual_bundling = 0;
d6255 9
d6266 8
a6273 5
	  if (manual_bundling && i != 2)
	    as_bad_where (md.slot[curr].src_file, md.slot[curr].src_line,
			  "`%s' must be last in bundle", idesc->name);
	  else
	    i = 2;
d6306 13
a6318 4
	  if (manual_bundling && i != required_slot)
	    as_bad_where (md.slot[curr].src_file, md.slot[curr].src_line,
			  "`%s' must be last in instruction group",
			  idesc->name);
d6337 3
a6339 2
	  if (manual_bundling_on)
	    as_bad_where (md.slot[curr].src_file, md.slot[curr].src_line,
d6341 2
a6346 11
      manual_bundling_on = md.slot[curr].manual_bundling_on;
      manual_bundling_off = md.slot[curr].manual_bundling_off;

      if (manual_bundling_on)
	{
	  if (curr == first)
	    manual_bundling = 1;
	  else
	    break;			/* need to start a new bundle */
	}

d6374 1
a6374 1
		      first in the bundle! --davidm 99/12/16  */
d6380 5
d6562 1
a6562 1
  if (manual_bundling)
@


1.123
log
@gas/
2005-01-28  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (ia64_estimate_size_before_relax): Allocate space
	for personality routine pointer only if there is one.
	(ia64_convert_frag): Likewise.
	(generate_unwind_image): Likewise.

ld/testsuite/
2005-01-28  Jan Beulich  <jbeulich@@novell.com>

	* ld/ia64/tlsbin.[rt]d: Widen expected offset/size ranges.
	* ld/ia64/tlspic.[rt]d: Likewise.
@
text
@d5785 2
a5786 1
  if (idesc->operands[2] == IA64_OPND_SOF)
d5829 2
a5830 1
  if (idesc->operands[2] == IA64_OPND_SOF)
d5834 12
a5845 10
      if (num_operands == 5 /* first_arg not included in this count! */
	  && CURR_SLOT.opnd[2].X_op == O_constant
	  && CURR_SLOT.opnd[3].X_op == O_constant
	  && CURR_SLOT.opnd[4].X_op == O_constant
	  && CURR_SLOT.opnd[5].X_op == O_constant)
	{
	  sof = set_regstack (CURR_SLOT.opnd[2].X_add_number,
			      CURR_SLOT.opnd[3].X_add_number,
			      CURR_SLOT.opnd[4].X_add_number,
			      CURR_SLOT.opnd[5].X_add_number);
d5855 4
a5858 4
	  CURR_SLOT.opnd[2].X_add_number = sof;
	  CURR_SLOT.opnd[3].X_add_number
	    = sof - CURR_SLOT.opnd[4].X_add_number;
	  CURR_SLOT.opnd[4] = CURR_SLOT.opnd[5];
@


1.122
log
@gas/
2005-01-27  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (emit_one_bundle): Change "?imbf??" to "?ibmfxx".

gas/testsuite/
2005-01-27  Jan Beulich  <jbeulich@@novell.com>

	* gas/ia64/nop_x.[ds]: New.
	* gas/ia64/ia64.exp: Run new test.
@
text
@d2866 5
a2870 2
  /* Add 8 for the header + a pointer for the personality offset.  */
  size = len + 8 + md.pointer_size;
d2897 5
a2901 2
  /* Add 8 for the header + a pointer for the personality offset.  */
  size = len + 8 + md.pointer_size;
d3463 5
a3467 3
      /* Add 8 for the header + a pointer for the personality
	 offset.  */
      size += 8 + md.pointer_size;
@


1.121
log
@gas/
2005-01-25  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-ia64.c (emit_one_bundle): Add late resolution of move
	to/from application registers dynamic insns.
	(md_assemble): Defer resolution of move to/from application registers
	dynamic insns when they can be issued on either the I- or M-units.

gas/testsuite/
2005-01-25  Jan Beulich  <jbeulich@@novell.com>

	* gas/ia64/dv-waw-err.l: Don't expect ar112 move warning to refer to
	M-unit.
	* gas/ia64/mov-ar.[ds]: New.
	* gas/ia64/ia64.exp: Run new test.
@
text
@d6390 1
a6390 1
	  sprintf (mnemonic, "%s.%c", idesc->name, "?imbf??"[insn_unit]);
@


1.120
log
@Line number bug fix patch from David Mosberger.
* config/tc-ia64.c (md): Add member "loc_directive_seen".
(dot_loc): New function.
(md_pseudo_table): Add entry to map .loc to dot_loc().
(emit_one_bundle): Only call dwarf2_gen_line_info() if we have
seen a .loc directive or we're generating DWARF2 debug info for
assembly source.
@
text
@d6373 2
d6379 2
a6380 1
	  else if (strcmp (idesc->name, "chk.s") == 0)
d6383 2
a6384 1
	      if (required_unit == IA64_UNIT_I)
d6391 2
d6394 9
a6402 1
	  md.slot[curr].idesc = idesc = ia64_find_opcode (mnemonic);
d6404 3
a6406 1
	  know (!idesc->next);	/* no resolved dynamic ops have collisions */
d6408 1
d10091 2
d10094 1
a10094 1
		mnemonic = "mov.m";
d10098 9
a10106 6
	  ia64_free_opcode (idesc);
	  idesc = ia64_find_opcode (mnemonic);
	  while (idesc != NULL
		 && (idesc->operands[0] != opnd1
		     || idesc->operands[1] != opnd2))
	    idesc = get_next_opcode (idesc);
@


1.119
log
@2004-10-25  David Mosberger-Tang  <davidm@@hpl.hp.com>

	* config/tc-ia64.c (fixup_unw_records): Don't let the "t" value
	in an epilogue directive go negative.
@
text
@d244 2
a245 1
	  manual_bundling_off : 1;
d3045 11
d4987 1
d6435 3
a6437 2
      {
	bfd_vma addr;
d6439 3
a6441 3
	addr = frag_now->fr_address + frag_now_fix () - 16 + i;
	dwarf2_gen_line_info (addr, &md.slot[curr].debug_line);
      }
@


1.118
log
@2004-10-25  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 474
	* config/tc-ia64.c (emit_one_bundle): Decrement md.num_slots_in_use
	after reporting template error during manual bundling. Reported
	by Michael Dupont, michaelx.dupont@@intel.com.
@
text
@d2750 7
a2756 1
	  ptr->r.record.b.t = rlen - 1 - t;
@


1.117
log
@Fix error in unwind info for psp relative offsets.
* config/tc-ia64.c (ENCODED_PSP_OFFSET): New.
(output_rp_psprel, output_pfs_psprel, output_preds_psprel,
output_spill_base, output_unat_psprel, output_lc_psprel,
output_fpsr_psprel, output_priunat_psprel, output_bsp_psprel,
output_bsprestore_psprel, output_rnat_psprel, output_spill_psprel,
output_spill_psprel_p): Use it.
@
text
@d6499 6
a6504 3
	as_bad_where (md.slot[curr].src_file, md.slot[curr].src_line,
		      "`%s' does not fit into %s template",
		      idesc->name, ia64_templ_desc[template].name);
@


1.116
log
@	* config/obj-elf.c (obj_elf_section_type): Handle init_array,
	fini_array and preinit_array section types.
	* config/tc-ia64.c (ia64_elf_section_type): Remove init_array
	and fini_array.
	* doc/as.texinfo: Document extra section types.
@
text
@d701 6
d1819 1
a1819 1
  ptr->r.record.p.pspoff = offset / 4;
d1853 1
a1853 1
  ptr->r.record.p.pspoff = offset / 4;
d1887 1
a1887 1
  ptr->r.record.p.pspoff = offset / 4;
d1964 1
a1964 1
  ptr->r.record.p.pspoff = offset / 4;
d1989 1
a1989 1
  ptr->r.record.p.pspoff = offset / 4;
d2023 1
a2023 1
  ptr->r.record.p.pspoff = offset / 4;
d2057 1
a2057 1
  ptr->r.record.p.pspoff = offset / 4;
d2098 1
a2098 1
  ptr->r.record.p.pspoff = offset / 4;
d2132 1
a2132 1
  ptr->r.record.p.pspoff = offset / 4;
d2166 1
a2166 1
  ptr->r.record.p.pspoff = offset / 4;
d2200 1
a2200 1
  ptr->r.record.p.pspoff = offset / 4;
d2257 1
a2257 1
  ptr->r.record.x.pspoff = offset / 4;
d2284 1
a2284 1
  ptr->r.record.x.pspoff = offset / 4;
@


1.115
log
@	* config/tc-ia64.c (start_unwind_section): Add linkonce_empty
	argument, don't do anything if current section is not
	.gnu.linkonce.t.* and linkonce_empty is set.
	(generate_unwind_image, dot_endp): Adjust callers, call
	start_unwind_section (*, 1) if nothing will be put into the
	section.
@
text
@a998 6
  if (STREQ ("init_array"))
    return SHT_INIT_ARRAY;

  if (STREQ ("fini_array"))
    return SHT_FINI_ARRAY;

@


1.114
log
@bfd/

2004-07-26  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (bfd_elf_section_data): Add a pointer for the
	linked-to section.
	(elf_linked_to_section): New.

	* elf.c (assign_section_numbers): Set up sh_link for
	SHF_LINK_ORDER.

	* elfxx-ia64.c (elfNN_ia64_final_write_processing): Set sh_info
	to sh_link for SHT_IA_64_UNWIND sections.

gas/

2004-07-26  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-ia64.c (start_unwind_section): Set the linked-to
	section.
	(ia64_elf_section_change_hook): Set the linked-to section for
	SHT_IA_64_UNWIND.
@
text
@d2 2
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d3301 1
a3301 1
start_unwind_section (const segT text_seg, int sec_index)
d3363 2
d3450 1
a3450 1
      start_unwind_section (text_seg, SPECIAL_SECTION_UNWIND_INFO);
d3491 2
d4172 1
a4172 1
      start_unwind_section (saved_seg, SPECIAL_SECTION_UNWIND);
d4212 3
@


1.113
log
@Make -meb/-mel options work.
* config/tc-ia64.c (default_big_endian): New.
(dot_byteorder, md_begin): Use it.
(md_parse_option): Set it.
@
text
@d3406 2
d11027 3
@


1.112
log
@Emit error for unaligned instructions.
	* config/tc-ia64.c (emit_one_bundle): Check and set insn_addr.
	* config/tc-ia64.h (md_frag_check): Define.
@
text
@d156 1
d159 3
d4413 1
a4413 2
	seginfo->tc_segment_info_data.endian
	  = TARGET_BYTES_BIG_ENDIAN ? 1 : 2;
d6534 1
d6539 1
d6712 1
a6712 1
  dot_byteorder (TARGET_BYTES_BIG_ENDIAN);
@


1.111
log
@2004-05-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-ia64.c (remove_marked_resource): Save, clear and
	restore the old slot when inserting srlz.i/srlz.d.
@
text
@d6132 1
d6164 8
@


1.110
log
@gas/

2004-05-27  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-ia64.c (ar_is_in_integer_unit): Removed.
	(ar_is_only_in_integer_unit): New.
	(ar_is_only_in_memory_unit): New.
	(generate_unwind_image): Silence gcc on 32bit host.
	(md_assemble): Use ar_is_only_in_integer_unit instead of
	ar_is_in_integer_unit. Check AR access.

gas/testsuite

2004-05-27  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/ia64/regs.d: Updated.
@
text
@d9563 1
a9563 2
	  int oldqp = CURR_SLOT.qp_regno;
	  struct ia64_opcode *oldidesc = CURR_SLOT.idesc;
d9565 1
a9565 1
	  CURR_SLOT.qp_regno = 0;
d9571 1
a9571 2
	  CURR_SLOT.qp_regno = oldqp;
	  CURR_SLOT.idesc = oldidesc;
d9584 1
a9584 2
	int oldqp = CURR_SLOT.qp_regno;
	struct ia64_opcode *oldidesc = CURR_SLOT.idesc;
d9586 1
a9586 1
	CURR_SLOT.qp_regno = 0;
d9592 1
a9592 2
	CURR_SLOT.qp_regno = oldqp;
	CURR_SLOT.idesc = oldidesc;
@


1.109
log
@Patch from David Mosberger-Tang.
* config/tc-ia64.c (dot_serialize): Declare.
(dot_serialize): New function.
(md_pseudo_table): Add ".serialize.data" and
".serialize.instruction" directives.
@
text
@a698 1
static int ar_is_in_integer_unit PARAMS ((int regnum));
d910 1
a910 1
/* Determine if application register REGNUM resides in the integer
d913 1
a913 2
ar_is_in_integer_unit (reg)
     int reg;
d916 2
d919 7
a925 5
  return (reg == 64	/* pfs */
	  || reg == 65	/* lc */
	  || reg == 66	/* ec */
	  /* ??? ias accepts and puts these in the integer unit.  */
	  || (reg >= 112 && reg <= 127));
d3452 2
a3453 1
		(offsetT) unwind.personality_routine, (char *) list);
d10027 7
a10033 3
	  if (CURR_SLOT.opnd[rop].X_op == O_register
	      && ar_is_in_integer_unit (CURR_SLOT.opnd[rop].X_add_number))
	    mnemonic = "mov.i";
d10035 1
a10035 1
	    mnemonic = "mov.m";
d10044 27
@


1.108
log
@2004-05-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-ia64.c (make_unw_section_name): Removed.
	(start_unwind_section): New function.
	(generate_unwind_image): Take const segT instead of const
	char *.
	(dot_handlerdata): Adjusted.
	(dot_endp): Likewise.
@
text
@d753 1
d4655 17
d5054 2
@


1.107
log
@	* read.c (read_a_source_file): Use demand_empty_rest_of_line.
	(demand_empty_rest_of_line): Issue an error here.
	(ignore_rest_of_line): Silently skip to end.
	(demand_copy_string): Issue an error, not warning.
	(equals): Likewise.
	* config/obj-elf.c (obj_elf_section_name): Likewise.
	(obj_elf_section): Likewise.
	* config/tc-arc.c (arc_extoper): Remove bogus NULL checks.
	(arc_extinst): Likewise.
	* config/tc-ia64.c (dot_saveb): Use demand_empty_rest_of_line.
	(dot_spill): Likewise.
	(dot_unwabi): Likewise.
	(dot_prologue): Likewise.
@
text
@a573 5
static char *special_linkonce_name[] =
  {
    ".gnu.linkonce.ia64unw.", ".gnu.linkonce.ia64unwi."
  };

a905 1
static void generate_unwind_image PARAMS ((const char *));
a909 25
/* Build the unwind section name by appending the (possibly stripped)
   text section NAME to the unwind PREFIX.  The resulting string
   pointer is assigned to RESULT.  The string is allocated on the
   stack, so this must be a macro...  */
#define make_unw_section_name(special, text_name, result)		   \
  {									   \
    const char *_prefix = special_section_name[special];		   \
    const char *_suffix = text_name;					   \
    size_t _prefix_len, _suffix_len;					   \
    char *_result;							   \
    if (strncmp (text_name, ".gnu.linkonce.t.",				   \
		 sizeof (".gnu.linkonce.t.") - 1) == 0)			   \
      {									   \
	_prefix = special_linkonce_name[special - SPECIAL_SECTION_UNWIND]; \
	_suffix += sizeof (".gnu.linkonce.t.") - 1;			   \
      }									   \
    _prefix_len = strlen (_prefix), _suffix_len = strlen (_suffix);	   \
    _result = alloca (_prefix_len + _suffix_len + 1);		   	   \
    memcpy (_result, _prefix, _prefix_len);				   \
    memcpy (_result + _prefix_len, _suffix, _suffix_len);		   \
    _result[_prefix_len + _suffix_len] = '\0';				   \
    result = _result;							   \
  }									   \
while (0)

d3287 5
d3293 110
a3402 2
generate_unwind_image (text_name)
     const char *text_name;
a3434 1
      char *sec_name;
d3438 1
a3438 4
      make_unw_section_name (SPECIAL_SECTION_UNWIND_INFO, text_name, sec_name);
      set_section (sec_name);
      bfd_set_section_flags (stdoutput, now_seg,
			     SEC_LOAD | SEC_ALLOC | SEC_READONLY);
a3486 7
  const char *text_name = segment_name (now_seg);

  /* If text section name starts with ".text" (which it should),
     strip this prefix off.  */
  if (strcmp (text_name, ".text") == 0)
    text_name = "";

d3496 1
a3496 1
  generate_unwind_image (text_name);
a4130 1
  const char *sec_name, *text_name;
a4145 43
  /*
    Use a slightly ugly scheme to derive the unwind section names from
    the text section name:

    text sect.  unwind table sect.
    name:       name:                      comments:
    ----------  -----------------          --------------------------------
    .text       .IA_64.unwind
    .text.foo   .IA_64.unwind.text.foo
    .foo        .IA_64.unwind.foo
    .gnu.linkonce.t.foo
		.gnu.linkonce.ia64unw.foo
    _info       .IA_64.unwind_info         gas issues error message (ditto)
    _infoFOO    .IA_64.unwind_infoFOO      gas issues error message (ditto)

    This mapping is done so that:

	(a) An object file with unwind info only in .text will use
	    unwind section names .IA_64.unwind and .IA_64.unwind_info.
	    This follows the letter of the ABI and also ensures backwards
	    compatibility with older toolchains.

	(b) An object file with unwind info in multiple text sections
	    will use separate unwind sections for each text section.
	    This allows us to properly set the "sh_info" and "sh_link"
	    fields in SHT_IA_64_UNWIND as required by the ABI and also
	    lets GNU ld support programs with multiple segments
	    containing unwind info (as might be the case for certain
	    embedded applications).

	(c) An error is issued if there would be a name clash.
  */
  text_name = segment_name (saved_seg);
  if (strncmp (text_name, "_info", 5) == 0)
    {
      as_bad ("Illegal section name `%s' (causes unwind section name clash)",
	      text_name);
      ignore_rest_of_line ();
      return;
    }
  if (strcmp (text_name, ".text") == 0)
    text_name = "";

d4150 1
a4150 1
    generate_unwind_image (text_name);
d4157 1
a4157 4
      make_unw_section_name (SPECIAL_SECTION_UNWIND, text_name, sec_name);
      set_section ((char *) sec_name);
      bfd_set_section_flags (stdoutput, now_seg,
			     SEC_LOAD | SEC_ALLOC | SEC_READONLY);
@


1.106
log
@2004-03-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-ia64.c (md_assemble): Properly handle NULL
	align_frag.
	(ia64_handle_align): Don't abort if failed to add a stop bit.
@
text
@d3620 1
a3620 1
    ignore_rest_of_line ();
d3652 1
a3652 1
    ignore_rest_of_line ();
d3928 1
a3928 1
    ignore_rest_of_line ();
d4023 1
a4023 1
	ignore_rest_of_line ();
@


1.105
log
@2004-03-03  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-ia64.c (dot_align): New.
	(ia64_do_align): Make it static.
	(md_pseudo_table): Use "dot_align" for "align".
	(ia64_md_do_align): Don't set align_frag here.
	(ia64_handle_align): Add a stop bit to the previous bundle if
	needed.

	* config/tc-ia64.h (ia64_do_align): Removed.
@
text
@d10013 2
a10014 1
	      assert (align_frag);
d10016 3
a10018 1
	  if (align_frag->fr_next == frag_now)
d10878 7
d10887 1
@


1.104
log
@2004-03-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-ia64.c (align_frag): New.
	(md_assemble): Set the tc_frag_data field in align_frag for
	IA64_OPCODE_FIRST instructions.
	(ia64_md_do_align): Set align_frag.
	(ia64_handle_align): Add a stop bit if needed.

	* config/tc-ia64.h (TC_FRAG_TYPE): New.
	(TC_FRAG_INIT): New.
@
text
@d708 1
d1139 2
a1140 3
void
ia64_do_align (nbytes)
     int nbytes;
d3037 8
d4971 1
a4971 1
    { "align", s_align_bytes, 0 },
a10838 2
  /* The current frag is an alignment frag.  */
  align_frag = frag_now;
d10870 12
@


1.103
log
@Fix unwind info problems with .align.
* config/tc-ia64.c (slot_index): New arg before_relax.  Use instead of
finalize_syms.
(fixup_unw_records): New arg before_relax.  Pass to slot_index.
(ia64_estimate_size_before_relax): New.
(ia64_convert_frag): Pass 0 to fixup_unw_records.  Add comment.
(generate_unwind_image): Pass 1 to fixup_unw_records.
* config/tc-ia64.h (ia64_estimate_size_before_relax): Declare.
(md_estimate_size_before_relax): Call ia64_estimate_size_before_relax.
@
text
@d639 3
d9996 18
a10013 1
    insn_group_break (1, 0, 0);
d10831 2
d10848 3
d10854 1
d10859 3
d10877 1
a10877 1
  memcpy (p, le_nop, 16);
@


1.102
log
@Yet another fix for -falign-loops problems.
	* config/tc-ia64.c (ia64_flush_insns): In addition to prologue,
	body, and endp, allow unwind records which do not have a "t"
	(time/instruction) field.
@
text
@d901 2
a902 1
					 unsigned long, fragS *));
d904 1
a904 1
static void fixup_unw_records PARAMS ((unw_rec_list *));
d2616 2
a2617 1
   containing FIRST_ADDR.  */
d2620 1
a2620 1
slot_index (slot_addr, slot_frag, first_addr, first_frag)
d2625 1
d2640 1
a2640 1
      if (finalize_syms)
d2642 2
a2643 2
	  /* We can get the final addresses only after relaxation is
	     done. */
d2722 1
a2722 1
fixup_unw_records (list)
d2724 1
d2735 1
a2735 1
		      first_addr, first_frag);
d2759 2
a2760 1
	    size = slot_index (last_addr, last_frag, first_addr, first_frag);
d2860 29
d2898 1
d2900 1
a2900 1
  fixup_unw_records (list);
d3324 1
a3324 1
  fixup_unw_records (list);
@


1.101
log
@Patch from Steve Ellcey for ia64-hpux.
* config/tc-ia64.h (ia64_frob_symbol): New declaration.
(tc_frob_symbol): New macro definition.
* config/tc-ia64.c (ia64_frob_symbol): New routine.
@
text
@d1095 1
a1095 2
      if (ptr->r.type == prologue || ptr->r.type == prologue_gr
	  || ptr->r.type == body || ptr->r.type == endp)
d1097 4
d1103 21
a1124 2
      else
	as_bad (_("Unwind directive not followed by an instruction."));
@


1.101.4.1
log
@Merge to 2.15 branch.
@
text
@a638 3
/* Remember the alignment frag.  */
static fragS *align_frag;

a704 1
static void dot_align (int);
d901 1
a901 2
					 unsigned long, fragS *,
					 int));
d903 1
a903 1
static void fixup_unw_records PARAMS ((unw_rec_list *, int));
d1095 2
a1096 1
      switch (ptr->r.type)
a1097 4
	case prologue:
	case prologue_gr:
	case body:
	case endp:
a1099 21
	  break;

	  /* Allow any record which doesn't have a "t" field (i.e.,
	     doesn't relate to a particular instruction).  */
	case unwabi:
	case br_gr:
	case copy_state:
	case fr_mem:
	case frgr_mem:
	case gr_gr:
	case gr_mem:
	case label_state:
	case rp_br:
	case spill_base:
	case spill_mask:
	  /* nothing */
	  break;

	default:
	  as_bad (_("Unwind directive not followed by an instruction."));
	  break;
d1101 2
d1112 3
a1114 2
static void
ia64_do_align (int nbytes)
d2593 1
a2593 2
   containing FIRST_ADDR.  If BEFORE_RELAX, then we use worst-case estimates
   for frag sizes.  */
d2596 1
a2596 1
slot_index (slot_addr, slot_frag, first_addr, first_frag, before_relax)
a2600 1
     int before_relax;
d2615 1
a2615 1
      if (! before_relax)
d2617 2
a2618 2
	  /* We can get the final addresses only during and after
	     relaxation.  */
d2697 1
a2697 1
fixup_unw_records (list, before_relax)
a2698 1
     int before_relax;
d2709 1
a2709 1
		      first_addr, first_frag, before_relax);
d2733 1
a2733 2
	    size = slot_index (last_addr, last_frag, first_addr, first_frag,
			       before_relax);
a2832 29
/* Estimate the size of a frag before relaxing.  We only have one type of frag
   to handle here, which is the unwind info frag.  */

int
ia64_estimate_size_before_relax (fragS *frag,
				 asection *segtype ATTRIBUTE_UNUSED)
{
  unw_rec_list *list;
  int len, size, pad;

  /* ??? This code is identical to the first part of ia64_convert_frag.  */
  list = (unw_rec_list *) frag->fr_opcode;
  fixup_unw_records (list, 0);

  len = calc_record_size (list);
  /* pad to pointer-size boundary.  */
  pad = len % md.pointer_size;
  if (pad != 0)
    len += md.pointer_size - pad;
  /* Add 8 for the header + a pointer for the personality offset.  */
  size = len + 8 + md.pointer_size;

  /* fr_var carries the max_chars that we created the fragment with.
     We must, of course, have allocated enough memory earlier.  */
  assert (frag->fr_var >= size);

  return frag->fr_fix + size;
}

a2841 1
  /* ??? This code is identical to ia64_estimate_size_before_relax.  */
d2843 1
a2843 1
  fixup_unw_records (list, 0);
a2976 8
dot_align (int arg)
{
  /* The current frag is an alignment frag.  */
  align_frag = frag_now;
  s_align_bytes (arg);
}

static void
d3267 1
a3267 1
  fixup_unw_records (list, 1);
d3552 1
a3552 1
    demand_empty_rest_of_line ();
d3584 1
a3584 1
    demand_empty_rest_of_line ();
d3860 1
a3860 1
    demand_empty_rest_of_line ();
d3955 1
a3955 1
	demand_empty_rest_of_line ();
d4903 1
a4903 1
    { "align", dot_align, 0 },
d9936 1
a9936 21
    {
      /* The alignment frag has to end with a stop bit only if the
	 next instruction after the alignment directive has to be
	 the first instruction in an instruction group.  */
      if (align_frag)
	{
	  while (align_frag->fr_type != rs_align_code)
	    {
	      align_frag = align_frag->fr_next;
	      if (!align_frag)
		break;
	    }
	  /* align_frag can be NULL if there are directives in
	     between.  */
	  if (align_frag && align_frag->fr_next == frag_now)
	    align_frag->tc_frag_data = 1;
	}

      insn_group_break (1, 0, 0);
    }
  align_frag = NULL;
a10768 3
  static const unsigned char le_nop_stop[]
    = { 0x0d, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00};
a10771 1
  const unsigned char *nop;
a10775 3
  /* Check if this frag has to end with a stop bit.  */
  nop = fragp->tc_frag_data ? le_nop_stop : le_nop;

a10778 20
  /* If no paddings are needed, we check if we need a stop bit.  */ 
  if (!bytes && fragp->tc_frag_data)
    {
      if (fragp->fr_fix < 16)
#if 1
	/* FIXME: It won't work with
	   .align 16
	   alloc r32=ar.pfs,1,2,4,0
	 */
	;
#else
	as_bad_where (fragp->fr_file, fragp->fr_line,
		      _("Can't add stop bit to mark end of instruction group"));
#endif
      else
	/* Bundles are always in little-endian byte order. Make sure
	   the previous bundle has the stop bit.  */
	*(p - 16) |= 1;
    }

d10791 1
a10791 1
  memcpy (p, nop, 16);
@


1.100
log
@Fix unwind abort while compiling glibc, reported by HJ.
	* config/tc-ia64.c (dot_endp): Delete call to output_endp.
	(generate_unwind_image): Re-add it here.
@
text
@d7122 17
@


1.99
log
@Fix region length calculations when regions end with .align padding.
* config/tc-ia64.c (output_endp): New.
(count_bits): Delete.
(ia64_flush_insns, process_one_record, optimize_unw_records): Handle
endp unwind records.
(fixup_unw_records): Handle endp unwind records.  Delete code for
shortening prologue regions not followed by a body record.
(dot_endp): Call add_unwind_entry to emit endp unwind record.
* config/tc-ia64.h (unw_record_type): Add endp.
@
text
@d3257 4
a4051 2

  add_unwind_entry (output_endp ());
@


1.98
log
@Fix testcase from David Mosberger.
* config/tc-ia64.c (ia64_convert_frag): Call md_number_to_chars to
fill padding bytes with zeroes.
(emit_one_bundle): New locals last_ptr, end_ptr.  Rewrite code that
sets unwind_record slot_number and slot_frag fields.
@
text
@d825 1
a899 1
static int count_bits PARAMS ((unsigned long));
d1091 2
a1092 2
     resolve those now.  We only handle body and prologue directives here.
     Give an error for others.  */
d1096 1
a1096 1
	  || ptr->r.type == body)
d1715 10
d2345 4
a2590 13
static int
count_bits (unsigned long mask)
{
  int n = 0;

  while (mask)
    {
      mask &= mask - 1;
      ++n;
    }
  return n;
}

d2684 2
a2685 2
      && (list->next == NULL
	  || (list->next->r.type == body && list->next->next == NULL)))
d2717 3
a2719 3
	    int size, dir_len = 0;
	    unsigned long last_addr;
	    fragS *last_frag;
d2724 1
a2724 3
	       the list, and determine the size of the region.  */
	    last_addr = list->next_slot_number;
	    last_frag = list->next_slot_frag;
d2727 1
a2727 1
		  || last->r.type == body)
d2733 1
a2733 35
	      else if (!last->next)
		{
		  /* In the absence of an explicit .body directive,
		     the prologue ends after the last instruction
		     covered by an unwind directive.  */
		  if (ptr->r.type != body)
		    {
		      last_addr = last->slot_number;
		      last_frag = last->slot_frag;
		      switch (last->r.type)
			{
			case frgr_mem:
			  dir_len = (count_bits (last->r.record.p.frmask)
				     + count_bits (last->r.record.p.grmask));
			  break;
			case fr_mem:
			case gr_mem:
			  dir_len += count_bits (last->r.record.p.rmask);
			  break;
			case br_mem:
			case br_gr:
			  dir_len += count_bits (last->r.record.p.brmask);
			  break;
			case gr_gr:
			  dir_len += count_bits (last->r.record.p.grmask);
			  break;
			default:
			  dir_len = 1;
			  break;
			}
		    }
		  break;
		}
	    size = (slot_index (last_addr, last_frag, first_addr, first_frag)
		    + dir_len);
d4048 2
@


1.97
log
@2004-01-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-ia64.c (emit_one_bundle): Add proper indentation.
@
text
@d2914 6
d6041 1
a6041 1
  unw_rec_list *ptr;
d6085 33
a6117 12
      /* Set the slot number for prologue/body records now as those
	 refer to the current point, not the point after the
	 instruction has been issued:  */
      /* Don't try to delete prologue/body records here, as that will cause
	 them to also be deleted from the master list of unwind records.  */
      for (ptr = md.slot[curr].unwind_record; ptr; ptr = ptr->next)
	if (ptr->r.type == prologue || ptr->r.type == prologue_gr
	    || ptr->r.type == body)
	  {
	    ptr->slot_number = (unsigned long) f + i;
	    ptr->slot_frag = frag_now;
	  }
d6322 14
a6335 9
      /* Set slot counts for non prologue/body unwind records.  */
      for (ptr = md.slot[curr].unwind_record; ptr; ptr = ptr->next)
	if (ptr->r.type != prologue && ptr->r.type != prologue_gr
	    && ptr->r.type != body)
	  {
	    ptr->slot_number = (unsigned long) f + i;
	    ptr->slot_frag = frag_now;
	  }
      md.slot[curr].unwind_record = NULL;
@


1.96
log
@2004-01-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-ia64.c (unwind): Move next_slot_number and
	next_slot_frag to ...
	(unw_rec_list): Here.
	(free_list_records): Removed.
	(output_unw_records): Likewise.
	(generate_unwind_image): Make it void.
	(alloc_record): Initialize next_slot_number and next_slot_frag.
	(slot_index): Take .org, .space and .align into account.
	(fixup_unw_records): Don't set slot_number to 0. Use
	list->next_slot_number and list->next_slot_frag instead of
	unwind.next_slot_number and unwind.next_slot_frag.
	(ia64_convert_frag): New.
	(generate_unwind_image): Generate a rs_machine_dependent frag
	for unwind record.
	(emit_one_bundle): Use list->next_slot_number and
	list->next_slot_frag instead of unwind.next_slot_number and
	unwind.next_slot_frag.

	* config/tc-ia64.h (md_convert_frag): Defined as
	ia64_convert_frag.
	(md_estimate_size_before_relax): Defined as (f)->fr_var.
@
text
@d6378 2
a6379 2
  unwind.list->next_slot_number = (unsigned long) f + 16;
  unwind.list->next_slot_frag = frag_now;
@


1.95
log
@Remove redundant returns in void functions.
@
text
@d655 2
a672 3
  unsigned long next_slot_number;
  fragS *next_slot_frag;

a824 1
static void free_list_records PARAMS ((unw_rec_list *));
a903 1
static int output_unw_records PARAMS ((unw_rec_list *, void **));
d906 1
a906 1
static int generate_unwind_image PARAMS ((const char *));
d1710 2
a1714 19
/* This function frees an entire list of record structures.  */

void
free_list_records (unw_rec_list *first)
{
  unw_rec_list *ptr;
  for (ptr = first; ptr != NULL;)
    {
      unw_rec_list *tmp = ptr;

      if ((tmp->r.type == prologue || tmp->r.type == prologue_gr)
	  && tmp->r.record.r.mask.i)
	free (tmp->r.record.r.mask.i);

      ptr = ptr->next;
      free (tmp);
    }
}

d2614 40
a2721 1
	    ptr->slot_number = 0;
d2724 2
a2725 2
	    last_addr = unwind.next_slot_number;
	    last_frag = unwind.next_slot_frag;
d2868 4
a2871 5
/* Helper routine for output_unw_records.  Emits the header for the unwind
   info.  */

static int
setup_unwind_header (int size, unsigned char **mem)
d2873 2
a2874 1
  int x, extra = 0;
d2877 4
d2882 13
a2894 13
  x = size % md.pointer_size;
  if (x != 0)
    extra = md.pointer_size - x;

  /* Add 8 for the header + a pointer for the
     personality offset.  */
  *mem = xmalloc (size + extra + 8 + md.pointer_size);

  /* Clear the padding area and personality.  */
  memset (*mem + 8 + size, 0, extra + md.pointer_size);

  /* Initialize the header area.  */
  if (unwind.personality_routine)
d2905 13
a2917 38
  md_number_to_chars (*mem, (((bfd_vma) 1 << 48)     /* Version.  */
			     | flag_value            /* U & E handler flags.  */
			     | ((size + extra) / md.pointer_size)), /* Length.  */
		      8);

  return extra;
}

/* Generate an unwind image from a record list.  Returns the number of
   bytes in the resulting image. The memory image itselof is returned
   in the 'ptr' parameter.  */
static int
output_unw_records (list, ptr)
     unw_rec_list *list;
     void **ptr;
{
  int size, extra;
  unsigned char *mem;

  *ptr = NULL;

  list = optimize_unw_records (list);
  fixup_unw_records (list);
  size = calc_record_size (list);

  if (size > 0 || unwind.force_unwind_entry)
    {
      unwind.force_unwind_entry = 0;
      extra = setup_unwind_header (size, &mem);

      vbyte_mem_ptr = mem + 8;
      process_unw_records (list, output_vbyte_mem);

      *ptr = mem;

      size += extra + 8 + md.pointer_size;
    }
  return size;
d3279 1
a3279 1
static int
d3283 2
a3284 2
  int size;
  void *unw_rec;
d3291 15
a3305 3
  size = output_unw_records (unwind.list, &unw_rec);
  if (size % md.pointer_size != 0)
    as_bad ("Unwind record is not a multiple of %d bytes.", md.pointer_size);
a3309 1
      unsigned char *where;
d3326 3
a3328 9

      where = (unsigned char *) frag_more (size);

      /* Issue a label for this address, and keep track of it to put it
	 in the unwind section.  */

      /* Copy the information from the unwind record into this section. The
	 data is already in the correct byte order.  */
      memcpy (where, unw_rec, size);
a3357 1
  free_list_records (unwind.list);
a3359 2

  return size;
d6376 5
a6380 2
  unwind.next_slot_number = (unsigned long) f + 16;
  unwind.next_slot_frag = frag_now;
@


1.94
log
@	* config/tc-hppa.c: Fix comment typos.
	* config/tc-i370.c: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-iq2000.h: Likewise.
@
text
@a10488 2

  return;
@


1.93
log
@	* config/tc-ia64.c (ia64_handle_align): Remove bogus be_nop.
@
text
@d701 1
a701 1
/* Forward delarations:  */
d2672 1
a2672 1
   this has been run, all neccessary information should be available
d2858 1
a2858 1
  /* pad to pointer-size boundry.  */
d6577 1
a6577 1
  /* Make sure fucntion pointers get initialized.  */
@


1.92
log
@gas/

2003-10-22  Andreas Schwab  <schwab@@suse.de>
	    H.J. Lu  <hongjiu.lu@@intel.com>
	    Jim Wilson <wilson@@specifixinc.com>

	* config/tc-ia64.c (update_qp_mutex): New.
	(note_register_values): Properly handle one of PRs in compare
	is PR0. Don't add a mutex relation for .and.orcm/.or.andcm.
	Clear mutex relation for .none/.unc. Don't clear mutex relation
	on predicated compare.

testsuite/

2003-10-22  Andreas Schwab  <schwab@@suse.de>
	    H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/ia64/dv-mutex-err.s: Add more tests for compare.
	* gas/ia64/dv-mutex.s: Likewise.

	* gas/ia64/dv-mutex-err.l: Updated.
	* gas/ia64/dv-mutex.d: Likewise.
@
text
@a10746 3
  static const unsigned char be_nop[]
    = { 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
	0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c};
d10771 2
a10772 1
  memcpy (p, (target_big_endian ? be_nop : le_nop), 16);
@


1.91
log
@	* config/tc-ia64.c (note_register_values): Warning fix.
	* config/tc-mips.c (append_insn): Likewise.
@
text
@d8729 71
d9064 2
a9065 2
      valueT p1mask = (valueT) 1 << p1;
      valueT p2mask = (valueT) 1 << p2;
d9067 2
a9068 2
      /* If one of the PRs is PR0, we can't really do anything.  */
      if (p1 == 0 || p2 == 0)
a9077 1
	  add_qp_mutex (p1mask | p2mask);
d9093 2
d9096 9
a9104 1
	  if (has_suffix_p (idesc->name, ".unc"))
d9106 2
a9107 1
	      add_qp_mutex (p1mask | p2mask);
d9110 4
a9113 4
		  add_qp_imply (CURR_SLOT.opnd[0].X_add_number - REG_P,
				CURR_SLOT.qp_regno);
		  add_qp_imply (CURR_SLOT.opnd[1].X_add_number - REG_P,
				CURR_SLOT.qp_regno);
a9114 8
	    }
	  else if (CURR_SLOT.qp_regno == 0)
	    {
	      add_qp_mutex (p1mask | p2mask);
	    }
	  else
	    {
	      clear_qp_mutex (p1mask | p2mask);
@


1.90
log
@Patch from David Mosberger.
	* config/tc-ia64.c (pseudo_func): Add ABI constants for linux,
	freebsd, openvms, and nsk (non-stop kernel).
@
text
@d8943 1
a8943 1
	    qp_changemask = ~(valueT) 0xFFFFFFFFFFF | idesc->operands[1];
@


1.89
log
@Move .file and .loc pseudo ops into obj-elf.c
@
text
@d541 7
a547 3
    { "svr4",	PSEUDO_FUNC_CONST, { 0 } },
    { "hpux",	PSEUDO_FUNC_CONST, { 1 } },
    { "nt",	PSEUDO_FUNC_CONST, { 2 } },
@


1.88
log
@gas/

2003-05-07  H.J. Lu <hongjiu.lu@@intel.com>

	* config/tc-ia64.c (alias_hash): New.
	(alias_name_hash): New.
	(secalias_hash): New.
	(secalias_name_hash): New.
	(md_pseudo_table): Add "secalias".
	(md_begin): Initialize alias_hash, alias_name_hash,
	secalias_hash and secalias_name_hash.
	(struct alias): New.
	(dot_alias): Implement .alias and .secalias directives.
	(do_alias): New.
	(ia64_adjust_symtab): New.
	(do_secalias): New.
	(ia64_frob_file): New.

	* config/tc-ia64.h (ia64_adjust_symtab): New.
	(tc_adjust_symtab): Defined.
	(ia64_frob_file): New.
	(tc_frob_file): Defined.

gas/testsuite/

2003-05-07  H.J. Lu <hongjiu.lu@@intel.com>

	* gas/ia64/ia64.exp: Add alias.

	* gas/ia64/alias.s: New.
	* gas/ia64/alias.d: Likewise.
@
text
@a4876 2
    { "file", (void (*) PARAMS ((int))) dwarf2_directive_file, 0 },
    { "loc", dwarf2_directive_loc, 0 },
@


1.87
log
@gas/

2003-05-03  H.J. Lu <hjl@@gnu.org>

	* config/obj-elf.c (obj_elf_parse_section_letters): Make it a
	fatal error for unknown section attribute.

	* config/tc-alpha.c (alpha_elf_section_letter): Return -1 for
	unknown section attribute.
	* config/tc-ia64.c (ia64_elf_section_letter): Likewise.
	* config/tc-ppc.c (ppc_section_letter): Likewise.

	* config/tc-ia64.c (ia64_elf_section_letter): Handle 'o'.
	(ia64_elf_section_type): Accept "unwind".

gas/testsuite/

2003-05-03  H.J. Lu <hjl@@gnu.org>

	* gas/ia64/ia64.exp: Add unwind.

	* gas/ia64/unwind.s: New. Test the new section attribute 'o'
	and the new section type "unwind".
	* gas/ia64/unwind.d: Likewise.
@
text
@a26 1
	.alias
d167 5
a4390 7
dot_alias (dummy)
     int dummy ATTRIBUTE_UNUSED;
{
  as_bad (".alias not implemented yet");
}

static void
d4935 1
d6579 5
d10742 166
@


1.86
log
@2003-05-01  H.J. Lu <hjl@@gnu.org>

	* config/tc-ia64.c (ia64_check_label): New.
	* config/tc-ia64.h (tc_check_label): New.

	* read.c (read_a_source_file): Call tc_check_label after
	creating a user-defined label if defined.
@
text
@d971 2
d974 2
a975 2
  *ptr_msg = _("Bad .section directive: want a,s,w,x,M,S,G,T in string");
  return 0;
d1007 3
@


1.85
log
@gas/

2003-04-30  H.J. Lu <hjl@@gnu.org>

	* config/tc-ia64.c (ia64_number_to_chars): New function pointer.
	(ia64_float_to_chars): Likewise.
	(dot_byteorder): Set target_big_endian, ia64_number_to_chars
	and ia64_float_to_chars by tc_segment_info_data.endian from
	the current segment if byteorder == -1.
	(md_begin): Call dot_byteorder to set target_big_endian.
	(md_atof): Call ia64_float_to_chars to convert floating point.
	(ia64_float_to_chars_bigendian): New function.
	(ia64_float_to_chars_littleendian): Likewise.
	(ia64_elf_section_change_hook): Likewise.

	* config/tc-ia64.h (ia64_number_to_chars): New.
	(md_number_to_chars): Changed to (*ia64_number_to_chars)
	(ia64_elf_section_change_hook): New.
	(md_elf_section_change_hook): Defined.
	(ia64_segment_info_type): New struct.
	(TC_SEGMENT_INFO_TYPE): Defined.

gas/testsuite/

2003-04-30  H.J. Lu <hjl@@gnu.org>

	* gas/ia64/ia64.exp: Add order.

	* gas/ia64/order.s: New file.
	* gas/ia64/order.d: Likewise.
@
text
@d10724 11
@


1.84
log
@gas/

2003-04-30  H.J. Lu <hjl@@gnu.org>

	* config/tc-ia64.c (md_section_align): Deleted.

	* config/tc-ia64.h (SUB_SEGMENT_ALIGN): New.
	(md_section_align): New.

gas/testsuite/

2003-04-29  H.J. Lu <hjl@@gnu.org>

	* gas/ia64/ia64.exp: Add align.

	* gas/ia64/align.d: New file.
	* gas/ia64/align.s: Likewise.

	* ia64/dependency-1.d: Remove the padding.

ld/testsuite/

2003-04-29  H.J. Lu <hjl@@gnu.org>

	* ld-ia64/tlsbin.dd: Updated.
	* ld-ia64/tlsbin.rd: Likewise.
	* ld-ia64/tlsbin.sd: Likewise.
	* ld-ia64/tlsbin.td: Likewise.
	* ld-ia64/tlspic.rd: Likewise.
	* ld-ia64/tlspic.sd: Likewise.
	* ld-ia64/tlspic.td: Likewise.
@
text
@d159 9
d4320 26
a4345 1
  target_big_endian = byteorder;
d6572 4
a6575 1
  target_big_endian = TARGET_BYTES_BIG_ENDIAN;
a10593 1
  LITTLENUM_TYPE *word;
a10627 1
  *size = prec * sizeof (LITTLENUM_TYPE);
d10629 2
a10630 5
  for (word = words + prec - 1; prec--;)
    {
      md_number_to_chars (lit, (long) (*word--), sizeof (LITTLENUM_TYPE));
      lit += sizeof (LITTLENUM_TYPE);
    }
d10634 1
a10634 1
      memset (lit, 0, 6);
d10637 3
d10693 30
@


1.83
log
@gas/

2003-04-30  H.J. Lu <hjl@@gnu.org>

	* config/tc-ia64.c (stmt_float_cons): Fix alignment for real10
	and add real16.
	(md_pseudo_table): Add "xreal16", "xreal16.ua", "real16" and
	"real16.ua".
	(md_atof): Add 6 byte padding of zero for real16.

gas/testsuite/

2003-04-29  H.J. Lu <hjl@@gnu.org>

	* gas/ia64/ia64.exp: Add real.

	* gas/ia64/real.s: New file.
	* gas/ia64/real.d: Likewise.
@
text
@a10607 12
/* Round up a section's size to the appropriate boundary.  */
valueT
md_section_align (seg, size)
     segT seg;
     valueT size;
{
  int align = bfd_get_section_alignment (stdoutput, seg);
  valueT mask = ((valueT) 1 << align) - 1;

  return (size + mask) & ~mask;
}

@


1.82
log
@	* config/tc-ia64.c (generate_unwind_image): Fix type of unw_rec to
	avoid aliasing issue.
@
text
@d4413 1
a4413 1
  size_t size;
d4417 8
a4424 2
    case 'd': size = 8; break;
    case 'x': size = 10; break;
d4428 1
a4428 1
      size = 4;
d4431 1
a4431 1
  ia64_do_align (size);
d4908 1
d4919 1
d4963 1
d4975 1
d10598 6
@


1.81
log
@        * dwarf2dbg.c (generic_dwarf2_emit_offset): New.
        (TC_DWARF2_EMIT_OFFSET): Provide default.
        (out_debug_aranges, out_debug_info): Use it.
        * config/tc-ia64.c (ia64_dwarf2_emit_offset): New.
        (ia64_cons_fix_new): Move FUNC_DTP_RELATIVE handling ...
        (ia64_gen_real_reloc_type): ... here.
        * config/tc-ia64.h (TC_DWARF2_EMIT_OFFSET): New.
@
text
@d3264 1
a3264 1
  unsigned char *unw_rec;
d3271 1
a3271 1
  size = output_unw_records (unwind.list, (void **) &unw_rec);
@


1.80
log
@Patch from David Mosberger.
	* config/tc-ia64.c (dot_vframesp): Correct error message.
	(dot_vframepsp): Ditto.
@
text
@d10036 14
a10090 10
      else if (exp->X_op == O_pseudo_fixup
	       && exp->X_op_symbol
	       && S_GET_VALUE (exp->X_op_symbol) == FUNC_DTP_RELATIVE)
	{
	  if (target_big_endian)
	    code = BFD_RELOC_IA64_DTPREL64MSB;
	  else
	    code = BFD_RELOC_IA64_DTPREL64LSB;
	  break;
	}
a10108 1

d10119 1
a10121 1
      /* ??? */
d10124 1
d10300 4
d10331 1
@


1.79
log
@	* symbols.c (S_FORCE_RELOC): Add "strict" param.
	* symbols.h (S_FORCE_RELOC): Likewise.
	* config/obj-aout.h (S_FORCE_RELOC): Likewise.
	* config/obj-bout.h (S_FORCE_RELOC): Likewise.
	* config/obj-coff.h (S_FORCE_RELOC): Likewise.
	* config/obj-ieee.h (S_FORCE_RELOC): Likewise.
	* config/obj-vms.h (S_FORCE_RELOC): Likewise.
	* write.c (generic_force_reloc): New function.
	(TC_FORCE_RELOCATION): Use it here instead of S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	(adjust_reloc_syms): Adjust S_FORCE_RELOC call.
	* as.h (generic_force_reloc): Declare.
	* doc/internals.texi (S_FORCE_RELOC): Update.
	(TC_FORCE_RELOCATION_SUB_SAME): Update.

	* config/tc-alpha.c (alpha_force_relocation): Adjust to use
	generic_force_reloc.
	(alpha_fix_adjustable): Likewise.
	* config/tc-arm.c (arm_force_relocation): Likewise.
	* config/tc-cris.c (md_cris_force_relocation): Likewise.
	* config/tc-frv.c (frv_force_relocation): Likewise.
	* config/tc-i386.c (md_apply_fix3): Likewise.
	* config/tc-ia64.c (ia64_force_relocation): Likewise.
	* config/tc-ip2k.c (ip2k_force_relocation): Likewise.
	* config/tc-m32r.c (m32r_force_relocation): Likewise.
	* config/tc-m68hc11.c (tc_m68hc11_force_relocation): Likewise.
	* config/tc-mcore.c (mcore_force_relocation): Likewise.
	* config/tc-mips.c (mips_force_relocation): Likewise.
	* config/tc-mmix.c (mmix_force_relocation): Likewise.
	* config/tc-ppc.c (ppc_force_relocation): Likewise.
	* config/tc-s390.c (tc_s390_force_relocation): Likewise.
	* config/tc-sh.c (sh_force_relocation): Likewise.
	(md_pcrel_from_section): Likewise.
	* config/tc-sparc.c (tc_gen_reloc): Likewise.
	* config/tc-v850.c (v850_force_relocation): Likewise.
	* config/tc-xstormy16.c (xstormy16_force_relocation): Likewise.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-mcore.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-sparc.h (tc_fix_adjustable): Likewise.

	* config/tc-d10v.c (d10v_force_relocation): Delete.
	* config/tc-d10v.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-dlx.c (md_dlx_force_relocation): Delete.
	* config/tc-dlx.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-fr30.c (fr30_force_relocation): Delete.
	* config/tc-fr30.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-mn10300.c (mn10300_force_relocation): Delete.
	* config/tc-mn10300.h (TC_FORCE_RELOCATION): Don't define.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-i960.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
	* config/tc-hppa.c (hppa_force_relocation): Adjust S_FORCE_RELOC call.
	* config/tc-mips.c (RELAX_BRANCH_TOOFAR): Warning fix.
	* config/tc-mips.h (TC_FORCE_RELOCATION_SUB_SAME): Don't define.
	* config/tc-openrisc.c (openrisc_force_relocation): Delete.
	* config/tc-openrisc.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sparc.c (elf32_sparc_force_relocation): Delete.
	* config/tc-sparc.h (TC_FORCE_RELOCATION): Don't define for ELF.
	* config/tc-i386.c (i386_force_relocation): Delete.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Don't define for
	BFD_ASSEMBLER.
	(EXTERN_FORCE_RELOC): Fix TE_PE and STRICT_PE_FORMAT nesting.
	* config/tc-m68k.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-pj.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sh.h (TC_FORCE_RELOCATION_SUB_ABS): Don't call
	S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-sh64.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
@
text
@d3071 1
a3071 1
    as_bad ("First operand to .vframesp must be a general register");
d3087 1
a3087 1
    as_bad ("First operand to .vframepsp must be a general register");
@


1.78
log
@	* elfxx-ia64.c (struct elfNN_ia64_link_hash_table): Add
	self_dtpmod_done and self_dtpmod_offset.
	(allocate_global_data_got): Only use one got entry for all
	dtpmod relocs against local symbols.
	(allocate_dynrel_entries): Only need .rela.got entry for
	dtpmod against global symbol.
	(elfNN_ia64_size_dynamic_sections): Initialize self_dtpmod_offset.
	Reserve space in .rela.got for the local dtpmod entry.
	(set_got_entry): Initialize the common local dtpmod .got entry.
	(elfNN_ia64_relocate_section): Handle R_IA_64_DTPREL64LSB
	and R_IA_64_DTPREL64MSB.

	* config/tc-ia64.c (ia64_cons_fix_new): Handle @@dtprel() in data.

	* ld-ia64/ia64.exp: New.
	* ld-ia64/tlsbin.dd: New test.
	* ld-ia64/tlsbinpic.s: New test.
	* ld-ia64/tlsbin.rd: New test.
	* ld-ia64/tlsbin.s: New test.
	* ld-ia64/tlsbin.sd: New test.
	* ld-ia64/tlsbin.td: New test.
	* ld-ia64/tlsg.s: New test.
	* ld-ia64/tlsg.sd: New test.
	* ld-ia64/tlslib.s: New test.
	* ld-ia64/tlspic1.s: New test.
	* ld-ia64/tlspic2.s: New test.
	* ld-ia64/tlspic.dd: New test.
	* ld-ia64/tlspic.rd: New test.
	* ld-ia64/tlspic.sd: New test.
	* ld-ia64/tlspic.td: New test.
@
text
@d10018 1
a10018 1
  return S_FORCE_RELOC (fix->fx_addsy);
@


1.77
log
@2002-12-08  H.J. Lu <hjl@@gnu.org>

	* config/tc-ia64.c (md_apply_fix3): Remove the PCREL hack
	copied from tc-i386.c.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d10075 10
@


1.76
log
@        * config/ia64.c (enum reloc_func): Add FUNC_LT_RELATIVE_X.
        (ia64_gen_real_reloc_type): Handle it.
        (pseudo_func): Add @@ltoffx.
        (md_begin): Build .<ltoffx>.
        (ia64_force_relocation): True for LTOFF22X and LDXMOV.

        * gas/ia64/ltoff22x-1.[ds]: New.
        * gas/ia64/ia64.exp: Run it.
@
text
@a10416 1
  int adjust = 0;
a10425 1
	  adjust = 1;
a10429 1
	  adjust = 1;
a10433 1
	  adjust = 1;
a10437 1
	  adjust = 1;
a10471 5

      /* ??? This is a hack copied from tc-i386.c to make PCREL relocs
	 work.  There should be a better way to handle this.  */
      if (adjust)
	fix->fx_offset += fix->fx_where + fix->fx_frag->fr_address;
@


1.75
log
@Patch to update IA-64 port to SDM 2.1.
bfd/ChangeLog
	* cpu-ia64-opc.c: Add operand constant "ar.csd".
gas/ChangeLog
	* config/tc-ia64.c (pseudo_func): Add "@@pause" constant for "hint"
	instruction.
	(emit_one_bundle): Handle "hint" instruction.
	(operand_match): Match IA64_OPND_AR_CSD.
gas/testsuite/ChangeLog
	* gas/ia64/opc-b.d: Update for instructions added by SDM2.1.
	* gas/ia64/opc-b.s: Ditto.
	* gas/ia64/opc-f.d: Ditto.
	* gas/ia64/opc-f.s: Ditto.
	* gas/ia64/opc-i.d: Ditto.
	* gas/ia64/opc-i.s: Ditto.
	* gas/ia64/opc-m.d: Ditto.
	* gas/ia64/opc-m.s: Ditto.
	* gas/ia64/opc-x.d: Ditto.
	* gas/ia64/opc-x.s: Ditto.
include/opcode/ChangeLog
	* ia64.h: Fix copyright message.
	(IA64_OPND_AR_CSD): New operand kind.
opcodes/ChangeLog
	* ia64-opc-d.c (ia64_opcodes_d): Add "hint" instruction.
	* ia64-opc-b.c: Add "hint.b" instruction.
	* ia64-opc-f.c: Add "hint.f" instruction.
	* ia64-opc-i.c: Add "hint.i" instruction.
	* ia64-opc-m.c: Add "hint.m", "fc.i", "ld16", "st16", and
	"cmp8xchg16" instructions.
	* ia64-opc-x.c: Add "hint.x" instruction.
	* ia64-opc.h (AR_CSD): New macro.
	* ia64-ic.tbl: Update according to SDM2.1.
	* ia64-raw.tbl: Ditto.
	* ia64-waw.tbl: Ditto.
	* ia64-gen.c (in_iclass): Handle "hint" like "nop".
	(lookup_regindex): Recognize AR[FCR], AR[EFLAG], AR[CSD],
	AR[SSD], AR[CFLG], AR[FSR], AR[FIR], and AR[FDR].
	* ia64-asmtab.c: Regenerate.
@
text
@d85 1
d491 1
d6549 4
d10009 3
d10168 8
@


1.74
log
@include/opcode/
        * ia64.h (enum ia64_opnd): Add IA64_OPND_LDXMOV.
bfd/
        * cpu-ia64-opc.c (elf64_ia64_operands): Add ldxmov entry.
opcodes/
        * ia64-opc-m.c: Add ld8.mov.
        * ia64-asmtab.c: Regenerate.
gas/
        * config/tc-ia64.c (operand_match): Add IA64_OPND_LDXMOV case.
gas/testsuite/
        * gas/ia64/ldxmov-1.[ds]: New.
        * gas/ia64/ldxmov-2.[ls]: New.
        * gas/ia64/ia64.exp: Run them.
@
text
@d522 3
d5038 5
d6167 1
a6167 1
      /* resolve dynamic opcodes such as "break" and "nop":  */
d6171 1
@


1.73
log
@	* config/tc-ia64.c (md_apply_fix3): Add default case.
@
text
@d5526 9
@


1.72
log
@	* symbols.c (S_SET_THREAD_LOCAL): New function.
	* symbols.h (S_SET_THREAD_LOCAL): New prototype.
	* config/tc-i386.c (md_apply_fix3): Call S_SET_THREAD_LOCAL
	for TLS relocations.
	* config/tc-ia64.c (md_apply_fix3): Likewise.
	* config/tc-alpha.c (md_apply_fix3): Likewise.

	* ld-i386/tlsnopic.rd: Change NOTYPE to TLS for UND sg* symbols.
@
text
@d10438 3
@


1.71
log
@gas reloc rewrite.
@
text
@d10416 1
a10416 1
      if (fix->fx_r_type == (int) BFD_RELOC_UNUSED)
d10418 1
d10426 12
@


1.70
log
@	* config/tc-arc.c (md_pseudo_table <dwarf2_directive_file>): Cast.
	* config/tc-frv.c: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ip2k.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-v850.c: Likewise.
@
text
@d9988 1
a9988 1
      return 0;
d9990 2
a9991 1
  return 0;
@


1.69
log
@	* elf.c (_bfd_elf_make_section_from_shdr): Set SEC_THREAD_LOCAL
	for symbols from SHF_TLS section.
	(_bfd_elf_print_private_bfd_data): Add PT_TLS.
	(elf_fake_sections): Set SHF_TLS for SEC_THREAD_LOCAL sections.
	(map_sections_to_segments): Build PT_TLS segment if necessary.
	(assign_file_positions_for_segments): Likewise.
	(get_program_header_size): Account for PT_TLS segment.
	(swap_out_syms): Set type of BSF_THREAD_LOCAL symbols and symbols from
	SEC_THREAD_LOCAL sections to STT_TLS.
	* reloc.c: Add 386 and IA-64 TLS relocs.
	* section.c (SEC_THREAD_LOCAL): Define.
	(SEC_CONSTRUCTOR_TEXT, SEC_CONSTRUCTOR_DATA, SEC_CONSTRUCTOR_BSS):
	Remove.
	* elflink.h (elf_link_add_object_symbols): Support .tcommon.
	(size_dynamic_sections): If DF_STATIC_TLS, set DF_FLAGS
	unconditionally.
	(struct elf_final_link_info): Add first_tls_sec.
	(elf_bfd_final_link): Set first_tls_sec.
	Compute elf_hash_table (info)->tls_segment.
	(elf_link_output_extsym): Handle STT_TLS symbols.
	(elf_link_input_bfd): Likewise.
	* syms.c (BSF_THREAD_LOCAL): Define.
	* bfd-in2.h: Rebuilt.
	* libbfd.h: Rebuilt.
	* elf32-i386.c (elf_i386_tls_transition, dtpoff_base, tpoff,
	elf_i386_mkobject, elf_i386_object_p): New functions.
	(elf_howto_table): Add TLS relocs.
	(elf_i386_reloc_type_lookup): Support TLS relocs.
	(elf_i386_info_to_howto_rel): Likewise.
	(struct elf_i386_link_hash_entry): Add tls_type.
	(struct elf_i386_obj_tdata): New.
	(elf_i386_hash_entry, elf_i386_tdata, elf_i386_local_got_tls_type):
	New macros.
	(struct elf_i386_link_hash_table): Add tls_ldm_got.
	(link_hash_newfunc): Clear tls_type.
	(elf_i386_check_relocs): Support TLS relocs.
	(elf_i386_gc_sweep_hook): Likewise.
	(allocate_dynrelocs): Likewise.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Likewise.
	(elf_i386_finish_dynamic_symbol): Likewise.
	(bfd_elf32_mkobject, elf_backend_object_p): Define.
	* elfxx-ia64.c (struct elfNN_ia64_dyn_sym_info): Add tprel_offset,
	dtpmod_offset, dtprel_offset, tprel_done, dtpmod_done, dtprel_done,
	want_tprel, want_dtpmod, want_dtprel.
	(elfNN_ia64_tprel_base, elfNN_ia64_dtprel_base): New functions.
	(ia64_howto_table): Add TLS relocs, rename R_IA64_LTOFF_TP22 to
	R_IA64_LTOFF_TPREL22.
	(elf_code_to_howto_index): Add TLS relocs.
	(elfNN_ia64_check_relocs): Support TLS relocs.
	(allocate_global_data_got): Account for TLS .got data.
	(allocate_dynrel_entries): Account for TLS dynamic relocations.
	(elfNN_ia64_install_value): Supprt TLS relocs.
	(set_got_entry): Support TLS relocs.
	(elfNN_ia64_relocate_section): Likewise.

	* config/obj-elf.c (elf_common): Renamed from obj_elf_common.
	(obj_elf_common): Call elf_common.
	(obj_elf_tls_common): New function.
	(elf_pseudo_tab): Support .tls_common.
	(special_sections): Add .tdata and .tbss.
	(obj_elf_change_section): Set SEC_THREAD_LOCAL for SHF_TLS
	sections.
	(obj_elf_parse_section_letters): Support T in section flags (SHF_TLS).
	(obj_elf_parse_section_letters): Include T in error message.
	* config/tc-ppc.c (ppc_section_letter): Likewise.
	* config/tc-alpha.c (alpha_elf_section_letter): Likewise.
	(tc_gen_reloc): Handle SEC_THREAD_LOCAL the same way as
	SEC_MERGE.
	* config/tc-sparc.c (md_apply_fix3): Likewise.
	* config/tc-i386.c (tc_i386_fix_adjustable): Add TLS relocs.
	Define them if not BFD_ASSEMBLER.
	(lex_got): Support @@TLSGD, @@TLSLDM, @@GOTTPOFF, @@TPOFF, @@DTPOFF
	and @@NTPOFF.
	(md_apply_fix3): Add TLS relocs.
	* config/tc-ia64.c (enum reloc_func): Add FUNC_DTP_MODULE,
	FUNC_DTP_RELATIVE, FUNC_TP_RELATIVE, FUNC_LT_DTP_MODULE,
	FUNC_LT_DTP_RELATIVE, FUNC_LT_TP_RELATIVE.
	(pseudo_func): Support @@dtpmod(), @@dtprel() and @@tprel().
	(ia64_elf_section_letter): Include T in error message.
	(md_begin): Support TLS operators.
	(md_operand): Likewise.
	(ia64_gen_real_reloc_type): Support TLS relocs.
	* testsuite/gas/i386/tlspic.s: New file.
	* testsuite/gas/i386/tlsd.s: New file.
	* testsuite/gas/i386/tlsnopic.s: New file.
	* testsuite/gas/i386/tlsd.d: New file.
	* testsuite/gas/i386/tlsnopic.d: New file.
	* testsuite/gas/i386/tlspic.d: New file.
	* testsuite/gas/i386/i386.exp: Add tlsd, tlsnopic and tlspic tests.
	* testsuite/gas/ia64/tls.s: New file.
	* testsuite/gas/ia64/tls.d: New file.
	* testsuite/gas/ia64/ia64.exp: Add tls test.
	* write.c (adjust_reloc_syms): Don't change symbols in
	SEC_THREAD_LOCAL sections to STT_SECTION + addend.

	* elf/common.h (PT_TLS, SHF_TLS, STT_TLS, DF_STATIC_TLS): Define.
	* elf/ia64.h (R_IA64_LTOFF_TPREL22): Renamed from R_IA64_LTOFF_TP22.
	* elf/i386.h: Add TLS relocs.

	* scripttempl/elf.sc: Add .rel{,a}.t{bss,data}, .tdata and .tbss.
	* ldlang.c (lang_add_section): Set SEC_THREAD_LOCAL for
	output section if necessary.  Handle .tbss.
	(lang_size_sections): Clear _raw_size for .tbss section
	(it allocates space in PT_TLS segment only).
	* ldwrite.c (build_link_order): Build link order for .tbss too.

	* readelf.c (get_segment_type): Add PT_TLS.
	(get_elf_section_flags): Add SHF_TLS.
	(get_dynamic_flags): Optimize.  Add DF_STATIC_TLS.
	(process_dynamic_segment): Use puts instead of printf.
	(get_symbol_type): Support STT_TLS.
	* objdump.c (dump_section_header): Remove SEC_CONSTRUCTOR_TEXT,
	SEC_CONSTRUCTOR_DATA, SEC_CONSTRUCTOR_BSS.
	Add SEC_THREAD_LOCAL.
@
text
@d4830 1
a4830 1
    { "file", dwarf2_directive_file, 0 },
@


1.69.2.1
log
@2002-10-31  David O'Brien  <obrien@@FreeBSD.org>
	* config/tc-ia64.c: Cast dwarf2_directive_file to int.
	* config/tc-sparc.c: Likewise.
	* config/tc-alpha.c: Cast s_alpha_file to int.
	* config/tc-alpha.h (TC_INIT_FIX_DATA): info is of type struct
	alpha_reloc_tag.

Approved by:  Alan Modra <amodra@@bigpond.net.au>
              Message-ID: <20021012184546.W979@@bubble.sa.bigpond.net.au>
@
text
@d4830 1
a4830 1
    { "file", (void (*) PARAMS ((int))) dwarf2_directive_file, 0 },
@


1.68
log
@	* config/tc-ia64.c: Fix formatting.
	* config/tc-ia64.h: Likewise.
@
text
@d80 2
d89 1
d92 3
d485 2
d494 1
d497 3
d958 1
a958 1
  *ptr_msg = _("Bad .section directive: want a,s,w,x,M,S in string");
d6509 8
d6545 4
d6557 12
d9865 6
a9870 4
	      if (S_GET_VALUE (e->X_op_symbol) == FUNC_FPTR_RELATIVE
		  && i == FUNC_LT_RELATIVE)
		i = FUNC_LT_FPTR_RELATIVE;
	      else
d9872 9
d10208 58
@


1.67
log
@        * config/tc-ia64.c (ia64_cons_fix_new): Handle 8 byte iplt reloc
        in 32-bit mode.
@
text
@d883 1
a883 1
   stack, so this must be a macro... */
d964 2
a965 2
	const char *str;
	size_t len;
d968 1
a968 1
  
d983 1
a983 1
  
d986 1
a986 1
  
d2824 1
a2824 1
  /* Add 8 for the header + a pointer for the 
d2829 1
a2829 1
  memset (*mem + 8 + size, 0 , extra + md.pointer_size);
d3291 1
a3291 1
	  exp.X_op  = O_symbol;
d3302 1
a3302 1
          else
d3311 1
a3311 1
		       md.pointer_size, & exp, 0, reloc);
d3774 1
a3774 1
      label_prologue_count * new_lpc = xmalloc (sizeof (* new_lpc));
d3786 2
a3787 2
  label_prologue_count * lpc = unwind.saved_prologue_counts;
  label_prologue_count * next;
d4023 1
a4023 1
	    
d4063 1
a4063 1
      /* Issue the values of  a) Proc Begin, b) Proc End, c) Unwind Record. */
d5140 1
a5140 1
	{ 
d5810 1
a5810 1
	      return 0;
d6202 2
a6203 2
	{
	  bfd_vma addr;
d6205 3
a6207 3
	  addr = frag_now->fr_address + frag_now_fix () - 16 + i;
	  dwarf2_gen_line_info (addr, &md.slot[curr].debug_line);
	}
d7462 1
a7462 1
	      for (i = idesc->num_outputs;i < NELEMS (idesc->operands); i++)
d7984 1
a7984 1
	      if (mask & ((valueT) 1<<16))
d8475 5
a8479 5
        {
          valueT mask = 0;
          if (idesc->operands[2] == IA64_OPND_IMM17)
            mask = CURR_SLOT.opnd[2].X_add_number;
          if (mask & ((valueT) 1 << 63))
d8481 1
a8481 1
        }
d8503 2
a8504 2
              int p1 = CURR_SLOT.opnd[0].X_add_number - REG_P;
              int p2 = CURR_SLOT.opnd[1].X_add_number - REG_P;
d8512 1
a8512 1
                  specs[count] = tmpl;
d8520 1
a8520 1
                  specs[count] = tmpl;
d8759 2
a8760 2
      const char *name;
      const char *suffix;
d9989 1
a9989 1
      /* In 32-bit mode, data8 could mean function descriptors too. */
d9991 19
a10009 18
          && exp->X_op_symbol
          && S_GET_VALUE (exp->X_op_symbol) == FUNC_IPLT_RELOC
          && !(md.flags & EF_IA_64_ABI64))
        {
          if (target_big_endian)
            code = BFD_RELOC_IA64_IPLTMSB;
          else
            code = BFD_RELOC_IA64_IPLTLSB;
          exp->X_op = O_symbol;
          break;
        }
       else {
         if (target_big_endian)
	   code = BFD_RELOC_IA64_DIR64MSB;
         else
	   code = BFD_RELOC_IA64_DIR64LSB;
         break;
       }
d10166 2
a10167 2
    case  FUNC_IPLT_RELOC:
        break;
d10271 1
a10271 1
     valueT * valP;
d10275 1
a10275 1
  valueT value = * valP;
@


1.66
log
@	* config/tc-ia64.c (fixup_unw_records): Clear region when seeing a
	body record so that an error is given for misplaced .save
	pseudo-ops.
@
text
@d9989 20
a10008 5
      if (target_big_endian)
	code = BFD_RELOC_IA64_DIR64MSB;
      else
	code = BFD_RELOC_IA64_DIR64LSB;
      break;
@


1.65
log
@Keep track of prologue counts across .label_state/.copy_state directives
@
text
@d2712 5
a2716 1
	    region = ptr;
@


1.64
log
@Add support for ia64-hpux target.
@
text
@d626 9
d661 2
d876 3
d3173 8
d3253 1
a3253 1
                      
d3313 1
d3740 55
d3808 1
d3824 1
d6419 5
@


1.64.2.1
log
@Preserve prologue count across .label_state/.copy_state directives.
@
text
@a625 9
/* Linked list of saved prologue counts.  A very poor
   implementation of a map from label numbers to prologue counts.  */
typedef struct label_prologue_count
{
  struct label_prologue_count *next;
  unsigned long label_number;
  unsigned int prologue_count;
} label_prologue_count;

a651 2
  /* Prologue counts at previous .label_state directives.  */
  struct label_prologue_count * saved_prologue_counts;
a864 3
static unsigned int get_saved_prologue_count PARAMS ((unsigned long));
static void save_prologue_count PARAMS ((unsigned long, unsigned int));
static void free_saved_prologue_counts PARAMS ((void));
a3158 8

  if (ecount >= unwind.prologue_count)
    {
      as_bad ("Epilogue count of %lu exceeds number of nested prologues (%u)",
	      ecount + 1, unwind.prologue_count);
      return;
    }

a3290 1
  free_saved_prologue_counts ();
a3716 55
static unsigned int
get_saved_prologue_count (lbl)
     unsigned long lbl;
{
  label_prologue_count *lpc = unwind.saved_prologue_counts;

  while (lpc != NULL && lpc->label_number != lbl)
    lpc = lpc->next;

  if (lpc != NULL)
    return lpc->prologue_count;

  as_bad ("Missing .label_state %ld", lbl);
  return 1;
}

static void
save_prologue_count (lbl, count)
     unsigned long lbl;
     unsigned int count;
{
  label_prologue_count *lpc = unwind.saved_prologue_counts;

  while (lpc != NULL && lpc->label_number != lbl)
    lpc = lpc->next;

  if (lpc != NULL)
    lpc->prologue_count = count;
  else
    {
      label_prologue_count * new_lpc = xmalloc (sizeof (* new_lpc));

      new_lpc->next = unwind.saved_prologue_counts;
      new_lpc->label_number = lbl;
      new_lpc->prologue_count = count;
      unwind.saved_prologue_counts = new_lpc;
    }
}

static void
free_saved_prologue_counts ()
{
  label_prologue_count * lpc = unwind.saved_prologue_counts;
  label_prologue_count * next;

  while (lpc != NULL)
    {
      next = lpc->next;
      free (lpc);
      lpc = next;
    }

  unwind.saved_prologue_counts = NULL;
}

a3729 1
  save_prologue_count (e.X_add_number, unwind.prologue_count);
a3744 1
  unwind.prologue_count = get_saved_prologue_count (e.X_add_number);
a6338 5
  --mconstant-gp	  mark output file as using the constant-GP model\n\
			  (sets ELF header flag EF_IA_64_CONS_GP)\n\
  --mauto-pic		  mark output file as using the constant-GP model\n\
			  without function descriptors (sets ELF header flag\n\
			  EF_IA_64_NOFUNCDESC_CONS_GP)\n\
@


1.64.2.2
log
@	* aclocal.m4: Regenerate.
	* config.in: Regenerate.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.

	Merge from mainline.
	2002-03-12  Andreas Schwab  <schwab@@suse.de>
	* config/tc-ia64.c (fixup_unw_records): Clear region when seeing a
	body record so that an error is given for misplaced .save
	pseudo-ops.

	2002-03-09  Alan Modra  <amodra@@bigpond.net.au>
	* config/tc-i386.h (REX_OPCODE): Define.
	(REX_MODE64, REX_EXTX, REX_EXTY, REX_EXTZ): Define.
	(rex_byte): typedef to int.
	* config/tc-i386.c: Group prototypes and vars together.
	Formatting fixes.  Remove occurrences of "register" keyword.
	(true): Delete.
	(false): Delete.
	(mode_from_disp_size): Add INLINE keyword to prototype.
	(fits_in_signed_byte): Likewise.
	(fits_in_unsigned_byte): Likewise.
	(fits_in_unsigned_word): Likewise.
	(fits_in_signed_word): Likewise.
	(fits_in_unsigned_long): Likewise.
	(fits_in_signed_long): Likewise.
	(type_names): Constify.
	(intel_float_operand): Constify param.
	(add_prefix): Use REX_OPCODE.
	(md_assemble): Likewise.  Modify for changed rex_byte.
	(parse_insn): Split out of md_assemble.
	(parse_operands): Likewise.
	(swap_operands): Likewise.
	(optimize_imm): Likewise.
	(optimize_disp): Likewise.
	(match_template): Likewise.
	(check_string): Likewise.
	(process_suffix): Likewise.
	(check_byte_reg): Likewise.
	(check_long_reg): Likewise.
	(check_qword_reg): Likewise.
	(check_word_reg): Likewise.
	(finalize_imm): Likewise.
	(process_operands): Likewise.
	(build_modrm_byte): Likewise.
	(output_insn): Likewise.
	(output_branch): Likewise.
	(output_jump): Likewise.
	(output_interseg_jump): Likewise.
	(output_disp): Likewise.
	(output_imm): Likewise.

	2002-03-06  Alan Modra  <amodra@@bigpond.net.au>
	* config/tc-i386.c (tc_gen_reloc): Don't attempt to handle 8 byte
	relocs except when BFD64.
	* write.c (number_to_chars_bigendian): Don't abort when N is
	larger than sizeof (VAL).
	(number_to_chars_littleendian): Likewise.

	2002-03-05  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* config/tc-hppa.c (md_apply_fix3): Add cast.
	(hppa_fix_adjustable): Adjust list of selectors using e_lrsel and
	e_rrsel.

	2002-03-04  H.J. Lu <hjl@@gnu.org>
	* config/obj-elf.c (special_section): Add .init_array,
	.fini_array and .preinit_array.
	* config/tc-ia64.h (ELF_TC_SPECIAL_SECTIONS): Remove
	.init_array and .fini_array.

	2002-03-01  Jakub Jelinek  <jakub@@redhat.com>
	* config/obj-elf.c (elf_copy_symbol_attributes): Don't copy
	visibility.
	(obj_frob_symbol): Copy visibility.
@
text
@d2712 1
a2712 5
	    if (ptr->r.type == body)
	      /* End of region.  */
	      region = 0;
	    else
	      region = ptr;
d3253 1
a3253 1

@


1.64.2.3
log
@        * config/tc-ia64.c (ia64_cons_fix_new): Handle 8 byte iplt reloc
        in 32-bit mode.
@
text
@d9989 5
a9993 20
      /* In 32-bit mode, data8 could mean function descriptors too. */
      if (exp->X_op == O_pseudo_fixup
          && exp->X_op_symbol
          && S_GET_VALUE (exp->X_op_symbol) == FUNC_IPLT_RELOC
          && !(md.flags & EF_IA_64_ABI64))
        {
          if (target_big_endian)
            code = BFD_RELOC_IA64_IPLTMSB;
          else
            code = BFD_RELOC_IA64_IPLTLSB;
          exp->X_op = O_symbol;
          break;
        }
       else {
         if (target_big_endian)
	   code = BFD_RELOC_IA64_DIR64MSB;
         else
	   code = BFD_RELOC_IA64_DIR64LSB;
         break;
       }
@


1.63
log
@        * config/tc-ia64.c (has_suffix_p): New.
        (note_register_values): Use it instead of strstr.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d953 3
a955 2
  len = sizeof (ELF_STRING_ia64_unwind_info) - 1;
  if (strncmp (str, ELF_STRING_ia64_unwind_info, len) == 0)
d958 1
a958 2
  len = sizeof (ELF_STRING_ia64_unwind_info_once) - 1;
  if (strncmp (str, ELF_STRING_ia64_unwind_info_once, len) == 0)
d961 1
a961 2
  len = sizeof (ELF_STRING_ia64_unwind) - 1;
  if (strncmp (str, ELF_STRING_ia64_unwind, len) == 0)
d964 1
a964 2
  len = sizeof (ELF_STRING_ia64_unwind_once) - 1;
  if (strncmp (str, ELF_STRING_ia64_unwind_once, len) == 0)
d967 6
d974 1
d2799 1
d2812 1
d2814 10
d2825 3
a2827 5
  md_number_to_chars (*mem, (((bfd_vma) 1 << 48)     /* version */
			     | (unwind.personality_routine
				? ((bfd_vma) 3 << 32) /* U & E handler flags */
				: 0)
			     | ((size + extra) / md.pointer_size)), /* length */
d3238 1
d3268 18
a3285 2
	  fix_new_exp (frag_now, frag_now_fix () - 8, 8,
	  		     &exp, 0, BFD_RELOC_IA64_LTOFF_FPTR64LSB);
d6649 1
a6649 3
  md.flags = EF_IA_64_ABI64;
  if (TARGET_BYTES_BIG_ENDIAN)
    md.flags |= EF_IA_64_BE;
d6662 1
a6662 1
#ifdef TE_AIX50
d6664 2
d6670 1
a6670 1
#ifdef TE_AIX50
d6672 2
d10060 3
@


1.62
log
@        * config/tc-ia64.c (errata_nop_necessary_p): Prototype.
        (make_unw_section_name): Constify local variables.
@
text
@d736 1
d8634 13
d8764 2
a8765 1
      else if (strstr (idesc->name, ".or.andcm") != NULL)
d8770 2
a8771 6
      else if (strstr (idesc->name, ".and.orcm") != NULL)
	{
	  add_qp_mutex (p1mask | p2mask);
	  clear_qp_implies (p1mask, p2mask);
	}
      else if (strstr (idesc->name, ".and") != NULL)
d8775 2
a8776 1
      else if (strstr (idesc->name, ".or") != NULL)
d8784 1
a8784 1
	  if (strstr (idesc->name, ".unc") != NULL)
@


1.61
log
@	* as.c (parse_args): Call md_after_parse_args if defined.
	* config/tc-ia64.h (md_after_parse_args): Define.
	* config/tc-ia64.c (ia64_after_parse_args): Reject --gstabs.
	* doc/internals.texi (CPU backend): Document md_after_parse_args.
@
text
@d722 1
d871 2
a872 2
    char *_prefix = special_section_name[special];			   \
    char *_suffix = text_name;						   \
@


1.60
log
@Update all uses of md_apply_fix to use md_apply_fix3.  Make it a void function.
@
text
@d6313 7
@


1.59
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d9882 1
a9882 1
     relocs available).  See md_apply_fix().  */
d10105 3
a10107 2
int
md_apply_fix3 (fix, valuep, seg)
d10109 1
a10109 1
     valueT *valuep;
d10113 1
a10113 1
  valueT value = *valuep;
d10156 1
a10156 1
	  return 1;
a10170 1
      return 1;
a10175 1
      return 1;
a10176 1
  return 1;
@


1.58
log
@        * config/tc-alpha.c (alpha_elf_section_letter): New.
        (alpha_elf_section_flags): New.
        * config/tc-alpha.h (md_elf_section_letter): New.
        (md_elf_section_flags): New.
        * config/tc-ia64.c (ia64_elf_section_letter): New.
        * config/tc-ia64.h (md_elf_section_letter): New.
@
text
@d46 1
d4518 1
a4518 1
      if (toupper (*input_line_pointer) != 'P'
d4526 1
a4526 1
      while (isdigit (*input_line_pointer))
d4543 1
a4543 1
	  if (toupper (*input_line_pointer) != 'P'
d4551 1
a4551 1
	  while (isdigit (*input_line_pointer))
d6783 1
a6783 1
		 && isdigit ((unsigned char) *input_line_pointer))
d6786 1
a6786 1
	    while (isdigit ((unsigned char) *input_line_pointer))
d6959 1
a6959 1
      if (name[1] == 'n' && isdigit (name[2]))
d6967 1
a6967 1
      if (name[1] == 'o' && name[2] == 'c' && isdigit (name[3]))
d6975 1
a6975 1
      if (name[1] == 'u' && name[2] == 't' && isdigit (name[3]))
@


1.57
log
@        * config/tc-ia64.c (FUNC_IPLT_RELOC): New.
        (pseudo_func): Add @@iplt.
        (pseudo_opcode): Add data16 and data16.ua.
        (md_begin): Set iplt pseudo.
        (ia64_cons_fix_new): Handle 16 byte iplt reloc specially.
@
text
@d919 14
@


1.56
log
@	* config/tc-ia64.c (dot_endp): Set function symbol sizes.
	* config/obj-elf.c (obj_elf_size): When size is constant, free
	and clear symbol_get_obj(sym)->size if any.
@
text
@d88 1
d487 1
d4801 1
d4812 1
d6388 4
d9837 15
d9863 1
d9991 1
@


1.55
log
@	* config/tc-alpha.h: Fix formatting.
	* config/tc-arc.c: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ia64.h: Likewise.
	* config/tc-m32r.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-pj.h: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-sparc.h: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-w65.h: Likewise.
@
text
@d3844 2
a3901 3
  expression (&e);
  demand_empty_rest_of_line ();

d3957 44
@


1.54
log
@32-bit unwind data for ia64-hpux, from Steve Ellcey
	* config/tc-ia64.c (special_section): Add SPECIAL_SECTION_INIT_ARRAY
	and SPECIAL_SECTION_FINI_ARRAY.
	(special_section_name): Add .init_array and .fini_array.
	(md_pseudo_table): Add init_array and fini_array.
	(md): Add pointer_size and pointer_size_shift fields.
	(setup_unwind_header): New static function.
	(output_unw_records): Modify to use setup_unwind_header.
	(generate_unwind_image, dot_endp): Modify to use md.pointer_size and
	md.pointer_size_shift.
	(md_begin): Initialize md.pointer_size and md.pointer_size_shift.
@
text
@d879 2
a880 2
    memcpy(_result, _prefix, _prefix_len);				   \
    memcpy(_result + _prefix_len, _suffix, _suffix_len);		   \
d2772 1
a2772 1
setup_unwind_header(int size, unsigned char **mem)
d2819 1
a2819 1
      extra = setup_unwind_header(size, &mem);
d7722 2
a7723 2
	      int or_andcm = strstr(idesc->name, "or.andcm") != NULL;
	      int and_orcm = strstr(idesc->name, "and.orcm") != NULL;
d7844 2
a7845 2
	      int or_andcm = strstr(idesc->name, "or.andcm") != NULL;
	      int and_orcm = strstr(idesc->name, "and.orcm") != NULL;
d8307 2
a8308 2
	      int or_andcm = strstr(idesc->name, "or.andcm") != NULL;
	      int and_orcm = strstr(idesc->name, "and.orcm") != NULL;
@


1.53
log
@Fix ia64-linux gas ehopt testsuite failure.
	* config/tc-ia64.c (md_pseudo_table): Add 2byte, 4byte, and 8byte.
@
text
@d64 1
d71 4
a74 1
    SPECIAL_SECTION_UNWIND_INFO
d286 3
d533 2
a534 1
    {".IA_64.unwind"}, {".IA_64.unwind_info"}
d2768 31
d2807 1
a2807 1
  int size, x, extra = 0;
a2815 5
  /* pad to 8 byte boundry.  */
  x = size % 8;
  if (x != 0)
    extra = 8 - x;

d2819 1
a2819 3

      /* Add 8 for the header + 8 more bytes for the personality offset.  */
      mem = xmalloc (size + extra + 16);
a2821 11
      /* Clear the padding area and personality.  */
      memset (mem + 8 + size, 0 , extra + 8);
      /* Initialize the header area.  */
      md_number_to_chars (mem,
			  (((bfd_vma) 1 << 48)     /* version */
			   | (unwind.personality_routine
			      ? ((bfd_vma) 3 << 32) /* U & E handler flags */
			      : 0)
			   | ((size + extra) / 8)),  /* length (dwords) */
			  8);

d2826 1
a2826 1
      size += extra + 16;
d3195 3
a3197 3
  if (size % 8 != 0)
    as_bad ("Unwind record is not a multiple of 8 bytes.");

d3210 4
a3213 3
      /* Make sure the section has 8 byte alignment.  */
      frag_align (3, 0, 0);
      record_alignment (now_seg, 3);
d3919 8
a3926 5
      /* Make sure the section has 8 byte alignment.  */
      record_alignment (now_seg, 3);

      ptr = frag_more (24);
      where = frag_now_fix () - 24;
d4634 2
d6512 13
@


1.52
log
@Fix 2 ia64-linux gas testsuite failures.
	* config/tc-ia64.c (is_conditional_branch): Rewrite to exclude mod
	sched branches.
@
text
@d4704 9
@


1.51
log
@	* elfxx-ia64.c (is_unwind_section_name): Consider linkonce unwind
	sections as well.
	(elfNN_ia64_final_write_processing): Map .gnu.linkonce.ia64unw.FOO
	to .gnu.linkonce.t.FOO text section.

	* readelf.c (process_unwind): Print all unwind sections, not just
	one.

	* config/tc-ia64.c (special_linkonce_name): New.
	(make_unw_section): Map .gnu.linkonce.t.FOO text section into
	.gnu.linkonce.ia64unw{,i}.FOO.
	(ia64_elf_section_type): Handle .gnu.linkonce.ia64unw{,i}.FOO.
	(dot_endp): Add comment about it.

	* elf/ia64.h (ELF_STRING_ia64_unwind_once): Define.
	(ELF_STRING_ia64_unwind_info_once): Define.

	* emulparams/elf64_ia64.sh (OTHER_READONLY_SECTIONS): Put
	.gnu.linkonce.ia64unw{,i} sections into corresponding .IA_64.unwind*
	output sections.
	* emulparams/elf64_aix.sh (OTHER_READONLY_SECTIONS): Likewise.
@
text
@d6917 6
a6922 1
/* Return true if idesc is a conditional branch instruction.  */
d6929 2
a6930 2
     br.ia is a conditional branch.  Everything that starts with brl is a
     conditional branch.  */
d6933 7
a6939 2
	      || (idesc->name[2] == '.' && idesc->name[3] != 'i')
	      || idesc->name[2] == 'l'));
@


1.50
log
@        * config/tc-ia64.c (generate_unwind_image): Align the fragment
        beginning a function's unwind info block.
@
text
@d529 5
d860 11
a870 2
    size_t _prefix_len = strlen (_prefix), _text_len = strlen (text_name); \
    char *_result = alloca (_prefix_len + _text_len + 1);		   \
d872 2
a873 2
    memcpy(_result + _prefix_len, text_name, _text_len);		   \
    _result[_prefix_len + _text_len] = '\0';				   \
d930 4
d938 4
d3845 2
@


1.49
log
@2001-04-27  David Mosberger  <davidm@@hpl.hp.com>

	* config/tc-ia64.c (dot_spillmem_p): Fix output_spill_?sprel_p()
	argument passing order: predicate goes last, not first.
@
text
@d3168 1
@


1.48
log
@Fix latent bug exposed by a gcc-3 bug fix.
	* tc-ia64.c (is_conditional_branch): Return true for br, brl, and br.
	excluding br.i.
@
text
@d3616 1
a3616 1
    add_unwind_entry (output_spill_psprel_p (qp, ab, reg, e3.X_add_number));
d3618 1
a3618 1
    add_unwind_entry (output_spill_sprel_p (qp, ab, reg, e3.X_add_number));
@


1.47
log
@Add local tag support.  Don't flush instructions for .xdata directives.
	* config/tc-ia64.c (md): New member keep_pending_output.
	(ia64_flush_pending_output): Flush only if md.keep_pending_output
	is not set.
	(dot_xdata): Turn on md.keep_pending_output for the duration of
	this function.
	(dot_xfloat_cons): Ditto.
	(dot_xstringer): Ditto.
	(dot_xdata_ua): Ditto.
	(dot_xfloat_cons_ua): Ditto.
	* config/tc-ia64.c (ia64_unrecognized_line, case '['): Add local
	label support.
@
text
@d6892 2
d6898 7
a6904 9
  return (strncmp (idesc->name, "br", 2) == 0
	  && (strcmp (idesc->name, "br") == 0
	      || strncmp (idesc->name, "br.cond", 7) == 0
	      || strncmp (idesc->name, "br.call", 7) == 0
	      || strncmp (idesc->name, "br.ret", 6) == 0
	      || strcmp (idesc->name, "brl") == 0
	      || strncmp (idesc->name, "brl.cond", 7) == 0
	      || strncmp (idesc->name, "brl.call", 7) == 0
	      || strncmp (idesc->name, "brl.ret", 6) == 0));
@


1.46
log
@Fix copyright notices
@
text
@d200 2
a201 1
      auto_align : 1;
d4155 1
d4159 1
d4203 1
d4207 1
d4218 1
d4222 1
d4234 1
d4240 1
d4252 1
d4258 1
d6627 1
d6634 23
a6656 2
	s = input_line_pointer;
	c = get_symbol_end ();
d6664 1
d6732 2
a6733 1
  if (bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE)
@


1.45
log
@Added ia64-*-aix* configuration.
@
text
@d2 1
a2 1
   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation.
@


1.44
log
@Improve gas error messages for invalid instructions.
	* cpu-ia64-opc.c (elf64_ia64_operands}: Fix typo: error string for
	C8 said "1" instead of "8".  Clarify error string for IMM22:
	"signed integer" instead of just "integer".
	* config/tc-ia64.c (enum operand_match_result): New type.
	(operand_match): Change return type to operand_match_result.
	Fix all returns appropriately, adding support for returning the
	out-of-range result.
	(parse_operands): New locals result, error_pos, out_of_range_pos,
	curr_out_of_range_pos.  Rewrite operand matching loop to give better
	error messages.
	* ia64-opc-d.c (ia64_opcodes_d): Break the "add" pattern into two
	separate variants: one for IMM22 and the other for IMM14.
	* ia64-asmtab.c: Regenerate.
@
text
@d6052 1
d6472 3
d6476 1
d6478 3
d6482 1
d6487 3
d6491 1
d6493 3
d6497 1
@


1.43
log
@Fix bugs in handling of the .restore directive.
	* config/tc-ia64.c (struct unwind): Add member "prologue_count".
	(dot_proc): Clear unwind.prologue_count to zero.
	(dot_prologue): Increment unwind.prologue_count.
	(dot_restore): If second operand is omitted, use
	unwind.prologue_count -1 for "ecount" (# of additional regions to
	pop).  Decrement unwind.prologue_count by number of regions
	popped.
@
text
@d127 7
d700 3
a702 2
static int operand_match PARAMS ((const struct ia64_opcode *idesc,
				  int index, expressionS *e));
d4751 1
a4751 1
static int
d4768 1
a4768 1
	return 1;
d4773 1
a4773 1
	return 1;
d4778 1
a4778 1
	return 1;
d4783 1
a4783 1
	return 1;
d4788 1
a4788 1
	return 1;
d4793 1
a4793 1
	return 1;
d4798 1
a4798 1
	return 1;
d4803 1
a4803 1
	return 1;
d4808 1
a4808 1
	return 1;
d4812 7
a4818 2
      if (e->X_op == O_constant && e->X_add_number == 1)
	return 1;
d4822 7
a4828 2
      if (e->X_op == O_constant && e->X_add_number == 8)
	return 1;
d4832 7
a4838 2
      if (e->X_op == O_constant && e->X_add_number == 16)
	return 1;
d4846 1
a4846 1
	return 1;
d4853 1
a4853 1
	return 1;
d4859 1
a4859 1
	return 1;
d4868 1
a4868 1
	return 1;
d4875 1
a4875 1
	return 1;
d4883 1
a4883 1
	return 1;
d4887 7
a4893 3
      if (e->X_op == O_register && e->X_add_number >= REG_GR
	  && e->X_add_number < REG_GR + 4)
	return 1;
d4910 1
a4910 1
	return 1;
d4915 1
a4915 1
	return 1;
d4923 7
a4929 3
      if (e->X_op == O_constant
	  && (bfd_vma) (e->X_add_number - 1) < ((bfd_vma) 1 << bits))
	return 1;
d4933 7
a4939 3
      if (e->X_op == O_constant
	  && (bfd_vma) (e->X_add_number - 1) < 3)
	return 1;
d4944 7
a4950 3
      if (e->X_op == O_constant
	  && (val == 0 || val == 7 || val == 15 || val == 16))
	return 1;
d4955 2
a4956 2
      if (e->X_add_number & 0x7)
	break;
d4959 7
a4965 3
      if (e->X_op == O_constant &&
	  (bfd_vma) e->X_add_number <= 96)
	return 1;
d4972 3
a4974 1
	    return 1;
d5000 1
a5000 1
	  return 1;
d5003 1
a5003 1
	return 1;
d5021 7
a5027 3
      if (e->X_op == O_constant
	  && (bfd_vma) e->X_add_number < ((bfd_vma) 1 << bits))
	return 1;
d5032 1
a5032 2
      if (e->X_op == O_constant
	  && (bfd_vma) e->X_add_number < ((bfd_vma) 1 << bits))
d5034 9
a5042 4
	  int lobits = e->X_add_number & 0x3;
	  if (((bfd_vma) e->X_add_number & 0x3C) != 0 && lobits == 0)
	    e->X_add_number |= (bfd_vma) 0x3;
	  return 1;
d5049 3
d5054 6
a5059 9
      if (e->X_op == O_constant
	  && ((e->X_add_number >= 0
	       && (bfd_vma) e->X_add_number < ((bfd_vma) 1 << 44))
	      || (e->X_add_number < 0
		  && (bfd_vma) -e->X_add_number <= ((bfd_vma) 1 << 44))))
	{
	  /* sign-extend */
	  if (e->X_add_number >= 0
	      && (e->X_add_number & ((bfd_vma) 1 << 43)) != 0)
d5061 7
a5067 1
	      e->X_add_number |= ~(((bfd_vma) 1 << 44) - 1);
d5069 2
a5070 1
	  return 1;
d5076 6
a5081 9
      if (e->X_op == O_constant
	  && ((e->X_add_number >= 0
	       && (bfd_vma) e->X_add_number < ((bfd_vma) 1 << 17))
	      || (e->X_add_number < 0
		  && (bfd_vma) -e->X_add_number <= ((bfd_vma) 1 << 17))))
	{
	  /* sign-extend */
	  if (e->X_add_number >= 0
	      && (e->X_add_number & ((bfd_vma) 1 << 16)) != 0)
d5083 7
a5089 1
	      e->X_add_number |= ~(((bfd_vma) 1 << 17) - 1);
d5091 2
a5092 1
	  return 1;
d5130 1
a5130 1
	  return 1;
d5134 1
a5134 1
	return 0;
d5141 1
a5141 1
	    return 0;
d5153 1
a5153 1
	    return 1;
d5162 1
a5162 1
	    return 0;
d5172 1
a5172 1
		return 1;
d5174 1
a5174 1
		return 0;
d5195 3
a5197 2
	return 1;
      break;
d5204 7
a5210 3
      if (e->X_op == O_constant
	  && (val == 1 || val == 4 || val == 8 || val == 16))
	return 1;
d5236 1
a5236 1
	  return 1;
d5243 1
a5243 1
	  return 1;
d5255 1
a5255 1
	  return 1;
d5265 1
a5265 1
  return 0;
d5313 1
a5313 1
  int sep = 0;
d5315 1
d5397 2
d5406 6
d5413 11
a5423 2
	if (!operand_match (idesc, i, CURR_SLOT.opnd + i))
	  break;
d5425 14
a5438 3
      if (i != num_operands)
	{
	  if (i > highest_unmatched_operand)
d5441 11
a5451 1
	      expected_operand = idesc->operands[i];
d5466 1
a5466 1
		highest_unmatched_operand + 1, mnemonic,
@


1.42
log
@Address comment from Richard about relocs always needing a type.
	* config/tc-ia64.c (operand_match, case TAG13): Make a BFD_RELOC_UNUSED
	reloc instead of a 0 reloc.
	(md_apply_fix3): Check for BFD_RELOC_UNUSED instead of 0, and mark it
	as done.
	* config/tc-ia64.h (TC_RELOC_RTSYM_LOC_FIXUP): Likewise.
@
text
@d627 1
d3051 1
a3051 1
  unsigned long ecount = 0;
d3064 1
a3064 1
      if (e1.X_op != O_constant)
d3066 1
a3066 1
	  as_bad ("Second operand to .restore must be constant");
d3069 1
a3069 1
      ecount = e1.X_op;
d3071 2
d3074 5
d3721 1
d3776 1
@


1.41
log
@        * config/tc-ia64.h (md_elf_section_type): New macro.
        (ELF_TC_SPECIAL_SECTIONS): Drop .IA_64.unwind and .IA_64.unwind_info
        (they're now handled via ia64_elf_section_type.

        * config/tc-ia64.c (unwind): New members saved_text_seg,
        saved_text_subseg, and force_unwind_entry.
        (optimize_unw_records): New function to optimize away unnecessary
        unwind directives.
        (ia64_elf_section_type): New function.
        (output_unw_records): Generate unwind info only if the size is
        non-zero or if it's forced for some other reason (e.g.,
        handlerdata or a personality routine).
        (generate_unwind_image): Don't switch back to previous
        section---stay inside the unwind info section instead so that
        handlerdata that may follow goes into the right place.
        (dot_handlerdata): Force generation of unwind entry and save the
        current active text segment before generating unwind image.
        (dot_unwentry): Force generation of unwind entry.
        (dot_personality): Ditto.
        (dot_endp): Generate unwind table entry only if there is
        some unwind info or the unwind entry was forced.

        * config/tc-ia64.c (make_unw_section_name): New macro to form
        unwind section name.
        (generate_unwind_image): Add "text_name" argument.  Use it to
        form unwind section name.
        (dot_handlerdata): Determine current segment (section) name and
        pass it to generate_unwind_image().
        (dot_endp): Determine current segment (section) name and use
        it to determine the appropriate unwind section name.
        (ia64_md_do_align): Add missing ATTRIBUTE_UNUSED declarations to
        n, fill, and max arguments.
@
text
@d5168 4
a5171 1
	  fix->code = ia64_gen_real_reloc_type (e->X_op_symbol, 0);
d9810 1
a9810 1
      switch (fix->fx_r_type)
d9812 2
a9813 1
	case 0:
d9817 2
a9818 4
	  break;

	default:
	  break;
@


1.40
log
@2001-02-06  H.J. Lu  <hjl@@gnu.org>

	* config/tc-ia64.h (TC_RELOC_RTSYM_LOC_FIXUP): New. Defined.

	* config/tc-ia64.c (md_parse_option): Only accept the valid
	ia64 options on "-axxx".
@
text
@d2 1
a2 1
   Copyright (C) 1998, 1999, 2000 Free Software Foundation.
d620 3
d831 1
d836 17
a852 1
static int generate_unwind_image PARAMS ((void));
d897 16
d2534 19
d2739 3
a2748 2
  /* Add 8 for the header + 8 more bytes for the personality offset.  */
  mem = xmalloc (size + extra + 16);
d2750 6
a2755 10
  vbyte_mem_ptr = mem + 8;
  /* Clear the padding area and personality.  */
  memset (mem + 8 + size, 0 , extra + 8);
  /* Initialize the header area.  */
  md_number_to_chars (mem, (((bfd_vma) 1 << 48)     /* version */
			    | (unwind.personality_routine
			       ? ((bfd_vma) 3 << 32) /* U & E handler flags */
			       : 0)
			    | ((size + extra) / 8)),  /* length (dwords) */
		      8);
d2757 11
a2767 1
  process_unw_records (list, output_vbyte_mem);
d2769 7
a2775 2
  *ptr = mem;
  return size + extra + 16;
d3123 2
a3124 1
generate_unwind_image ()
d3142 1
d3144 5
a3148 1
      set_section ((char *) special_section_name[SPECIAL_SECTION_UNWIND_INFO]);
d3164 1
a3174 1
      obj_elf_previous (0);
d3187 17
a3203 1
  generate_unwind_image ();
d3211 1
d3676 1
d3779 1
d3781 52
a3832 2
  saved_seg = now_seg;
  saved_subseg = now_subseg;
d3839 13
a3851 5
  /* If there was a .handlerdata, we haven't generated an image yet.  */
  if (unwind.info == 0)
    {
      generate_unwind_image ();
    }
d3853 2
a3854 2
  subseg_set (md.last_text_seg, 0);
  unwind.proc_end = expr_build_dot ();
d3856 3
a3858 1
  set_section ((char *) special_section_name[SPECIAL_SECTION_UNWIND]);
d3860 6
a3865 19
  /* Make sure the section has 8 byte alignment.  */
  record_alignment (now_seg, 3);

  ptr = frag_more (24);
  where = frag_now_fix () - 24;
  bytes_per_address = bfd_arch_bits_per_address (stdoutput) / 8;

  /* Issue the values of  a) Proc Begin,  b) Proc End,  c) Unwind Record.  */
  e.X_op = O_pseudo_fixup;
  e.X_op_symbol = pseudo_func[FUNC_SEG_RELATIVE].u.sym;
  e.X_add_number = 0;
  e.X_add_symbol = unwind.proc_start;
  ia64_cons_fix_new (frag_now, where, bytes_per_address, &e);

  e.X_op = O_pseudo_fixup;
  e.X_op_symbol = pseudo_func[FUNC_SEG_RELATIVE].u.sym;
  e.X_add_number = 0;
  e.X_add_symbol = unwind.proc_end;
  ia64_cons_fix_new (frag_now, where + bytes_per_address, bytes_per_address, &e);
a3866 2
  if (unwind.info != 0)
    {
d3870 17
a3886 2
      e.X_add_symbol = unwind.info;
      ia64_cons_fix_new (frag_now, where + (bytes_per_address * 2), bytes_per_address, &e);
a3887 3
  else
    md_number_to_chars (ptr + (bytes_per_address * 2), 0, bytes_per_address);

d9943 2
a9944 2
     int n;
     const char *fill;
d9946 1
a9946 1
     int max;
@


1.39
log
@Don't abort for invalid input, print an error message instead.
	* config/tc-ia64.c (errata_nop_necessary_p): Return 0 instead of
	aborting for invalid operands.
@
text
@a5836 1
      /* ??? Conflicts with gas' listing option.  */
d5842 2
@


1.38
log
@Fix assembler segfault on gcc/crtstuff.c file.
	* config/tc-ia64.c (ia64_flush_insns): Handle unwind directives
	not immediately followed by an instruction.
@
text
@d5226 1
d5228 1
a5228 1
	      abort ();
d5243 1
d5245 1
a5245 1
	      abort ();
d5275 1
d5277 1
a5277 1
	    abort ();
@


1.38.2.1
log
@Don't abort for invalid input, print an error message instead.
	* config/tc-ia64.c (errata_nop_necessary_p): Return 0 instead of
	aborting for invalid operands.
@
text
@a5225 1
	    /* Ignore invalid operands; they generate errors elsewhere.  */
d5227 1
a5227 1
	      return 0;
a5241 1
	    /* Ignore invalid operands; they generate errors elsewhere.  */
d5243 1
a5243 1
	      return 0;
a5272 1
	  /* Ignore invalid operands; they generate errors elsewhere.  */
d5274 1
a5274 1
	    return 0;
@


1.38.2.2
log
@Multiple IA-64 unwind section support.
@
text
@d2 1
a2 1
   Copyright (C) 1998, 1999, 2000, 2001 Free Software Foundation.
a619 3
  segT saved_text_seg;
  subsegT saved_text_subseg;
  unsigned int force_unwind_entry : 1;	/* force generation of unwind entry? */
a827 1
static unw_rec_list *optimize_unw_records PARAMS ((unw_rec_list *));
d832 1
a832 17
static int generate_unwind_image PARAMS ((const char *));

/* Build the unwind section name by appending the (possibly stripped)
   text section NAME to the unwind PREFIX.  The resulting string
   pointer is assigned to RESULT.  The string is allocated on the
   stack, so this must be a macro... */
#define make_unw_section_name(special, text_name, result)		   \
  {									   \
    char *_prefix = special_section_name[special];			   \
    size_t _prefix_len = strlen (_prefix), _text_len = strlen (text_name); \
    char *_result = alloca (_prefix_len + _text_len + 1);		   \
    memcpy(_result, _prefix, _prefix_len);				   \
    memcpy(_result + _prefix_len, text_name, _text_len);		   \
    _result[_prefix_len + _text_len] = '\0';				   \
    result = _result;							   \
  }									   \
while (0)
a876 16
int
ia64_elf_section_type (str, len)
	const char *str;
	size_t len;
{
  len = sizeof (ELF_STRING_ia64_unwind_info) - 1;
  if (strncmp (str, ELF_STRING_ia64_unwind_info, len) == 0)
    return SHT_PROGBITS;

  len = sizeof (ELF_STRING_ia64_unwind) - 1;
  if (strncmp (str, ELF_STRING_ia64_unwind, len) == 0)
    return SHT_IA_64_UNWIND;

  return -1;
}

a2497 19
/* Optimize unwind record directives.  */

static unw_rec_list *
optimize_unw_records (list)
     unw_rec_list *list;
{
  if (!list)
    return NULL;

  /* If the only unwind record is ".prologue" or ".prologue" followed
     by ".body", then we can optimize the unwind directives away.  */
  if (list->r.type == prologue
      && (list->next == NULL
	  || (list->next->r.type == body && list->next->next == NULL)))
    return NULL;

  return list;
}

a2683 3
  *ptr = NULL;

  list = optimize_unw_records (list);
d2691 2
d2694 10
a2703 6
  if (size > 0 || unwind.force_unwind_entry)
    {
      unwind.force_unwind_entry = 0;

      /* Add 8 for the header + 8 more bytes for the personality offset.  */
      mem = xmalloc (size + extra + 16);
d2705 1
a2705 11
      vbyte_mem_ptr = mem + 8;
      /* Clear the padding area and personality.  */
      memset (mem + 8 + size, 0 , extra + 8);
      /* Initialize the header area.  */
      md_number_to_chars (mem,
			  (((bfd_vma) 1 << 48)     /* version */
			   | (unwind.personality_routine
			      ? ((bfd_vma) 3 << 32) /* U & E handler flags */
			      : 0)
			   | ((size + extra) / 8)),  /* length (dwords) */
			  8);
d2707 2
a2708 7
      process_unw_records (list, output_vbyte_mem);

      *ptr = mem;

      size += extra + 16;
    }
  return size;
d3056 1
a3056 2
generate_unwind_image (text_name)
     const char *text_name;
a3073 1
      char *sec_name;
d3075 1
a3075 5

      make_unw_section_name (SPECIAL_SECTION_UNWIND_INFO, text_name, sec_name);
      set_section (sec_name);
      bfd_set_section_flags (stdoutput, now_seg,
			     SEC_LOAD | SEC_ALLOC | SEC_READONLY);
a3090 1

d3101 1
d3114 1
a3114 17
  const char *text_name = segment_name (now_seg);

  /* If text section name starts with ".text" (which it should),
     strip this prefix off.  */
  if (strcmp (text_name, ".text") == 0)
    text_name = "";

  unwind.force_unwind_entry = 1;

  /* Remember which segment we're in so we can switch back after .endp */
  unwind.saved_text_seg = now_seg;
  unwind.saved_text_subseg = now_subseg;

  /* Generate unwind info into unwind-info section and then leave that
     section as the currently active one so dataXX directives go into
     the language specific data area of the unwind info block.  */
  generate_unwind_image (text_name);
a3121 1
  unwind.force_unwind_entry = 1;
a3585 1
  unwind.force_unwind_entry = 1;
a3687 1
  const char *sec_name, *text_name;
d3689 2
a3690 52
  if (unwind.saved_text_seg)
    {
      saved_seg = unwind.saved_text_seg;
      saved_subseg = unwind.saved_text_subseg;
      unwind.saved_text_seg = NULL;
    }
  else
    {
      saved_seg = now_seg;
      saved_subseg = now_subseg;
    }

  /*
    Use a slightly ugly scheme to derive the unwind section names from
    the text section name:

    text sect.  unwind table sect.
    name:       name:                      comments:
    ----------  -----------------          --------------------------------
    .text       .IA_64.unwind
    .text.foo   .IA_64.unwind.text.foo
    .foo        .IA_64.unwind.foo
    _info       .IA_64.unwind_info         gas issues error message (ditto)
    _infoFOO    .IA_64.unwind_infoFOO      gas issues error message (ditto)

    This mapping is done so that:

	(a) An object file with unwind info only in .text will use
	    unwind section names .IA_64.unwind and .IA_64.unwind_info.
	    This follows the letter of the ABI and also ensures backwards
	    compatibility with older toolchains.

	(b) An object file with unwind info in multiple text sections
	    will use separate unwind sections for each text section.
	    This allows us to properly set the "sh_info" and "sh_link"
	    fields in SHT_IA_64_UNWIND as required by the ABI and also
	    lets GNU ld support programs with multiple segments
	    containing unwind info (as might be the case for certain
	    embedded applications).
	    
	(c) An error is issued if there would be a name clash.
  */
  text_name = segment_name (saved_seg);
  if (strncmp (text_name, "_info", 5) == 0)
    {
      as_bad ("Illegal section name `%s' (causes unwind section name clash)",
	      text_name);
      ignore_rest_of_line ();
      return;
    }
  if (strcmp (text_name, ".text") == 0)
    text_name = "";
d3697 5
a3701 13
  /* If there wasn't a .handlerdata, we haven't generated an image yet.  */
  if (!unwind.info)
    generate_unwind_image (text_name);

  if (unwind.info || unwind.force_unwind_entry)
    {
      subseg_set (md.last_text_seg, 0);
      unwind.proc_end = expr_build_dot ();

      make_unw_section_name (SPECIAL_SECTION_UNWIND, text_name, sec_name);
      set_section ((char *) sec_name);
      bfd_set_section_flags (stdoutput, now_seg,
			     SEC_LOAD | SEC_ALLOC | SEC_READONLY);
d3703 4
a3706 2
      /* Make sure the section has 8 byte alignment.  */
      record_alignment (now_seg, 3);
d3708 2
a3709 3
      ptr = frag_more (24);
      where = frag_now_fix () - 24;
      bytes_per_address = bfd_arch_bits_per_address (stdoutput) / 8;
d3711 16
a3726 6
      /* Issue the values of  a) Proc Begin, b) Proc End, c) Unwind Record. */
      e.X_op = O_pseudo_fixup;
      e.X_op_symbol = pseudo_func[FUNC_SEG_RELATIVE].u.sym;
      e.X_add_number = 0;
      e.X_add_symbol = unwind.proc_start;
      ia64_cons_fix_new (frag_now, where, bytes_per_address, &e);
d3728 2
d3733 5
a3737 16
      e.X_add_symbol = unwind.proc_end;
      ia64_cons_fix_new (frag_now, where + bytes_per_address,
			 bytes_per_address, &e);

      if (unwind.info)
	{
	  e.X_op = O_pseudo_fixup;
	  e.X_op_symbol = pseudo_func[FUNC_SEG_RELATIVE].u.sym;
	  e.X_add_number = 0;
	  e.X_add_symbol = unwind.info;
	  ia64_cons_fix_new (frag_now, where + (bytes_per_address * 2),
			     bytes_per_address, &e);
	}
      else
	md_number_to_chars (ptr + (bytes_per_address * 2), 0,
			    bytes_per_address);
a3738 1
    }
d9793 2
a9794 2
     int n ATTRIBUTE_UNUSED;
     const char *fill ATTRIBUTE_UNUSED;
d9796 1
a9796 1
     int max ATTRIBUTE_UNUSED;
@


1.38.2.3
log
@2001-02-14  Philip Blundell  <pb@@futuretv.com>

	From 2001-02-06  H.J. Lu  <hjl@@gnu.org>
	* config/tc-ia64.h (TC_RELOC_RTSYM_LOC_FIXUP): Do fixup if
	there is no relocation.

	From 2001-02-06  H.J. Lu  <hjl@@gnu.org>
	* config/tc-ia64.h (TC_RELOC_RTSYM_LOC_FIXUP): New. Defined.
	* config/tc-ia64.c (md_parse_option): Only accept the valid
	ia64 options on "-axxx".
@
text
@d5986 1
a5991 2
      if (strncmp (arg, "indirect=", 9) != 0)
        return 0;
@


1.38.2.4
log
@Fix bugs in the handling of the .restore directive.
	* config/tc-ia64.c (struct unwind): Add member "prologue_count".
	(dot_proc): Clear unwind.prologue_count to zero.
	(dot_prologue): Increment unwind.prologue_count.
	(dot_restore): If second operand is omitted, use
	unwind.prologue_count -1 for "ecount" (# of additional regions to
	pop).  Decrement unwind.prologue_count by number of regions
	popped.
@
text
@a626 1
  unsigned int prologue_count;	/* number of .prologues seen so far */
d3050 1
a3050 1
  unsigned long ecount;	/* # of _additional_ regions to pop */
d3063 1
a3063 1
      if (e2.X_op != O_constant || e2.X_add_number < 0)
d3065 1
a3065 1
	  as_bad ("Second operand to .restore must be a constant >= 0");
d3068 1
a3068 1
      ecount = e2.X_add_number;
a3069 2
  else
    ecount = unwind.prologue_count - 1;
a3070 5

  if (ecount < unwind.prologue_count)
    unwind.prologue_count -= ecount + 1;
  else
    unwind.prologue_count = 0;
a3712 1
  unwind.prologue_count = 0;
a3766 1
  ++unwind.prologue_count;
@


1.38.2.5
log
@Improve gas error messages for invalid instructions.
	* cpu-ia64-opc.c (elf64_ia64_operands}: Fix typo: error string for
	C8 said "1" instead of "8".  Clarify error string for IMM22:
	"signed integer" instead of just "integer".
	* config/tc-ia64.c (enum operand_match_result): New type.
	(operand_match): Change return type to operand_match_result.
	Fix all returns appropriately, adding support for returning the
	out-of-range result.
	(parse_operands): New locals result, error_pos, out_of_range_pos,
	curr_out_of_range_pos.  Rewrite operand matching loop to give better
	error messages.
	* ia64-opc-d.c (ia64_opcodes_d): Break the "add" pattern into two
	separate variants: one for IMM22 and the other for IMM14.
	* ia64-asmtab.c: Regenerate.
@
text
@a126 7
enum operand_match_result
  {
    OPERAND_MATCH,
    OPERAND_OUT_OF_RANGE,
    OPERAND_MISMATCH
  };

d693 2
a694 3
static enum operand_match_result operand_match PARAMS ((const struct ia64_opcode *idesc,
							int index,
							expressionS *e));
d4743 1
a4743 1
static enum operand_match_result
d4760 1
a4760 1
	return OPERAND_MATCH;
d4765 1
a4765 1
	return OPERAND_MATCH;
d4770 1
a4770 1
	return OPERAND_MATCH;
d4775 1
a4775 1
	return OPERAND_MATCH;
d4780 1
a4780 1
	return OPERAND_MATCH;
d4785 1
a4785 1
	return OPERAND_MATCH;
d4790 1
a4790 1
	return OPERAND_MATCH;
d4795 1
a4795 1
	return OPERAND_MATCH;
d4800 1
a4800 1
	return OPERAND_MATCH;
d4804 2
a4805 7
      if (e->X_op == O_constant)
	{
	  if (e->X_add_number == 1)
	    return OPERAND_MATCH;
	  else
	    return OPERAND_OUT_OF_RANGE;
	}
d4809 2
a4810 7
      if (e->X_op == O_constant)
	{
	  if (e->X_add_number == 8)
	    return OPERAND_MATCH;
	  else
	    return OPERAND_OUT_OF_RANGE;
	}
d4814 2
a4815 7
      if (e->X_op == O_constant)
	{
	  if (e->X_add_number == 16)
	    return OPERAND_MATCH;
	  else
	    return OPERAND_OUT_OF_RANGE;
	}
d4823 1
a4823 1
	return OPERAND_MATCH;
d4830 1
a4830 1
	return OPERAND_MATCH;
d4836 1
a4836 1
	return OPERAND_MATCH;
d4845 1
a4845 1
	return OPERAND_MATCH;
d4852 1
a4852 1
	return OPERAND_MATCH;
d4860 1
a4860 1
	return OPERAND_MATCH;
d4864 3
a4866 7
      if (e->X_op == O_register && e->X_add_number >= REG_GR)
	{ 
	  if (e->X_add_number < REG_GR + 4)
	    return OPERAND_MATCH;
	  else if (e->X_add_number < REG_GR + 128)
	    return OPERAND_OUT_OF_RANGE;
	}
d4883 1
a4883 1
	return OPERAND_MATCH;
d4888 1
a4888 1
	return OPERAND_MATCH;
d4896 3
a4898 7
      if (e->X_op == O_constant)
	{
	  if ((bfd_vma) (e->X_add_number - 1) < ((bfd_vma) 1 << bits))
	    return OPERAND_MATCH;
	  else
	    return OPERAND_OUT_OF_RANGE;
	}
d4902 3
a4904 7
      if (e->X_op == O_constant)
	{
	  if ((bfd_vma) (e->X_add_number - 1) < 3)
	    return OPERAND_MATCH;
	  else
	    return OPERAND_OUT_OF_RANGE;
	}
d4909 3
a4911 7
      if (e->X_op == O_constant)
	{
	  if ((val == 0 || val == 7 || val == 15 || val == 16))
	    return OPERAND_MATCH;
	  else
	    return OPERAND_OUT_OF_RANGE;
	}
d4916 2
a4917 2
      if (e->X_op == O_constant && e->X_add_number & 0x7)
	return OPERAND_OUT_OF_RANGE;
d4920 3
a4922 7
      if (e->X_op == O_constant)
	{
	  if ((bfd_vma) e->X_add_number <= 96)
	    return OPERAND_MATCH;
	  else
	    return OPERAND_OUT_OF_RANGE;
	}
d4929 1
a4929 3
	    return OPERAND_MATCH;
	  else
	    return OPERAND_OUT_OF_RANGE;
d4955 1
a4955 1
	  return OPERAND_MATCH;
d4958 1
a4958 1
	return OPERAND_MATCH;
d4976 3
a4978 7
      if (e->X_op == O_constant)
	{
	  if ((bfd_vma) e->X_add_number < ((bfd_vma) 1 << bits))
	    return OPERAND_MATCH;
	  else
	    return OPERAND_OUT_OF_RANGE;
	}
d4983 2
a4984 1
      if (e->X_op == O_constant)
d4986 4
a4989 9
	  if ((bfd_vma) e->X_add_number < ((bfd_vma) 1 << bits))
	    {
	      int lobits = e->X_add_number & 0x3;
	      if (((bfd_vma) e->X_add_number & 0x3C) != 0 && lobits == 0)
		e->X_add_number |= (bfd_vma) 0x3;
	      return OPERAND_MATCH;
	    }
	  else
	    return OPERAND_OUT_OF_RANGE;
a4995 3
	/* XXX technically, this is wrong: we should not be issuing warning
	   messages until we're sure this instruction pattern is going to
	   be used! */
d4998 9
a5006 6
      if (e->X_op == O_constant)
	{
	  if (((e->X_add_number >= 0
		&& (bfd_vma) e->X_add_number < ((bfd_vma) 1 << 44))
	       || (e->X_add_number < 0
		   && (bfd_vma) -e->X_add_number <= ((bfd_vma) 1 << 44))))
d5008 1
a5008 7
	      /* sign-extend */
	      if (e->X_add_number >= 0
		  && (e->X_add_number & ((bfd_vma) 1 << 43)) != 0)
		{
		  e->X_add_number |= ~(((bfd_vma) 1 << 44) - 1);
		}
	      return OPERAND_MATCH;
d5010 1
a5010 2
	  else
	    return OPERAND_OUT_OF_RANGE;
d5016 9
a5024 6
      if (e->X_op == O_constant)
	{
	  if (((e->X_add_number >= 0
		&& (bfd_vma) e->X_add_number < ((bfd_vma) 1 << 17))
	       || (e->X_add_number < 0
		   && (bfd_vma) -e->X_add_number <= ((bfd_vma) 1 << 17))))
d5026 1
a5026 7
	      /* sign-extend */
	      if (e->X_add_number >= 0
		  && (e->X_add_number & ((bfd_vma) 1 << 16)) != 0)
		{
		  e->X_add_number |= ~(((bfd_vma) 1 << 17) - 1);
		}
	      return OPERAND_MATCH;
d5028 1
a5028 2
	  else
	    return OPERAND_OUT_OF_RANGE;
d5066 1
a5066 1
	  return OPERAND_MATCH;
d5070 1
a5070 1
	return OPERAND_MISMATCH;
d5077 1
a5077 1
	    return OPERAND_OUT_OF_RANGE;
d5089 1
a5089 1
	    return OPERAND_MATCH;
d5098 1
a5098 1
	    return OPERAND_OUT_OF_RANGE;
d5108 1
a5108 1
		return OPERAND_MATCH;
d5110 1
a5110 1
		return OPERAND_OUT_OF_RANGE;
d5131 2
a5132 3
	return OPERAND_MATCH;
      else
	return OPERAND_OUT_OF_RANGE;
d5139 3
a5141 7
      if (e->X_op == O_constant)
	{
	  if ((val == 1 || val == 4 || val == 8 || val == 16))
	    return OPERAND_MATCH;
	  else
	    return OPERAND_OUT_OF_RANGE;
	}
d5167 1
a5167 1
	  return OPERAND_MATCH;
d5174 1
a5174 1
	  return OPERAND_MATCH;
d5183 1
a5183 1
	  return OPERAND_MATCH;
d5193 1
a5193 1
  return OPERAND_MISMATCH;
d5241 1
a5241 1
  int error_pos, out_of_range_pos, curr_out_of_range_pos, sep = 0;
a5242 1
  enum operand_match_result result;
a5323 2
  curr_out_of_range_pos = -1;
  error_pos = 0;
d5331 3
d5335 1
a5335 6
      /* Try to match all operands.  If we see an out-of-range operand,
	 then continue trying to match the rest of the operands, since if
	 the rest match, then this idesc will give the best error message.  */

      out_of_range_pos = -1;
      for (i = 0; i < num_operands && idesc->operands[i]; ++i)
d5337 1
a5337 25
	  result = operand_match (idesc, i, CURR_SLOT.opnd + i);
	  if (result != OPERAND_MATCH)
	    {
	      if (result != OPERAND_OUT_OF_RANGE)
		break;
	      if (out_of_range_pos < 0)
		/* remember position of the first out-of-range operand: */
		out_of_range_pos = i;
	    }
	}

      /* If we did not match all operands, or if at least one operand was
	 out-of-range, then this idesc does not match.  Keep track of which
	 idesc matched the most operands before failing.  If we have two
	 idescs that failed at the same position, and one had an out-of-range
	 operand, then prefer the out-of-range operand.  Thus if we have
	 "add r0=0x1000000,r1" we get an error saying the constant is out
	 of range instead of an error saying that the constant should have been
	 a register.  */

      if (i != num_operands || out_of_range_pos >= 0)
	{
	  if (i > highest_unmatched_operand
	      || (i == highest_unmatched_operand
		  && out_of_range_pos > curr_out_of_range_pos))
d5340 1
a5340 11
	      if (out_of_range_pos >= 0)
		{
		  expected_operand = idesc->operands[out_of_range_pos];
		  error_pos = out_of_range_pos;
		}
	      else
		{
		  expected_operand = idesc->operands[i];
		  error_pos = i;
		}
	      curr_out_of_range_pos = out_of_range_pos;
d5355 1
a5355 1
		error_pos + 1, mnemonic,
@


1.38.2.6
log
@Add local tag support.  Don't flush instructions for .xdata directives.
	* config/tc-ia64.c (md): New member keep_pending_output.
	(ia64_flush_pending_output): Flush only if md.keep_pending_output
	is not set.
	(dot_xdata): Turn on md.keep_pending_output for the duration of
	this function.
	(dot_xfloat_cons): Ditto.
	(dot_xstringer): Ditto.
	(dot_xdata_ua): Ditto.
	(dot_xfloat_cons_ua): Ditto.
	* config/tc-ia64.c (ia64_unrecognized_line, case '['): Add local
	label support.
@
text
@d200 1
a200 2
      auto_align : 1,
      keep_pending_output : 1;
a4153 1
  md.keep_pending_output = 1;
a4156 1
  md.keep_pending_output = 0;
a4199 1
  md.keep_pending_output = 1;
a4202 1
  md.keep_pending_output = 0;
a4212 1
  md.keep_pending_output = 1;
a4215 1
  md.keep_pending_output = 0;
a4226 1
  md.keep_pending_output = 1;
a4231 1
  md.keep_pending_output = 0;
a4242 1
  md.keep_pending_output = 1;
a4247 1
  md.keep_pending_output = 0;
a6595 1
	int temp;
d6602 2
a6603 23

	/* This implements just enough of read_a_source_file in read.c to
	   recognize labels.  */
	if (is_name_beginner (*input_line_pointer))
	  {
	    s = input_line_pointer;
	    c = get_symbol_end ();
	  }
	else if (LOCAL_LABELS_FB
		 && isdigit ((unsigned char) *input_line_pointer))
	  {
	    temp = 0;
	    while (isdigit ((unsigned char) *input_line_pointer))
	      temp = (temp * 10) + *input_line_pointer++ - '0';
	    fb_label_instance_inc (temp);
	    s = fb_label_name (temp, 0);
	    c = *input_line_pointer;
	  }
	else
	  {
	    s = NULL;
	    c = '\0';
	  }
a6610 1

d6678 1
a6678 2
  if (!md.keep_pending_output
      && bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE)
@


1.38.2.7
log
@Fix latent bug exposed by a gcc-3 bug fix.
	* tc-ia64.c (is_conditional_branch): Return true for br, brl, and br.
	excluding br.i.
@
text
@a6871 2
/* Return true if idesc is a conditional branch instruction.  */

d6876 9
a6884 7
  /* br is a conditional branch.  Everything that starts with br. except
     br.ia is a conditional branch.  Everything that starts with brl is a
     conditional branch.  */
  return (idesc->name[0] == 'b' && idesc->name[1] == 'r'
	  && (idesc->name[2] == '\0'
	      || (idesc->name[2] == '.' && idesc->name[3] != 'i')
	      || idesc->name[2] == 'l'));
@


1.38.2.8
log
@Add patch from David Mosberger for unwind info generation bug.
	* config/tc-ia64.c (dot_spillmem_p): Fix output_spill_?sprel_p()
	argument passing order: predicate goes last, not first.
@
text
@d3616 1
a3616 1
    add_unwind_entry (output_spill_psprel_p (ab, reg, e3.X_add_number, qp));
d3618 1
a3618 1
    add_unwind_entry (output_spill_sprel_p (ab, reg, e3.X_add_number, qp));
@


1.38.2.9
log
@        * config/tc-ia64.c (generate_unwind_image): Align the fragment
        beginning a function's unwind info block.
@
text
@a3167 1
      frag_align (3, 0, 0);
@


1.38.2.10
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
@


1.37
log
@	* as.h (rs_align_test): New.
	* frags.c (NOP_OPCODE): Move default from read.c.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New default.
	(frag_align_code): New.
	* frags.h (frag_align_code): Declare.
	* read.c (NOP_OPCODE): Remove.
	(do_align): Use frag_align_code.
	* write.c (NOP_OPCODE): Remove.
	(get_recorded_alignment): New.
	(cvt_frag_to_fill): Handle rs_align_test.
	(relax_segment): Likewise.
	(subsegs_finish): Align last subseg in section to the
	section alignment.  Use frag_align_code.
	* write.h (get_recorded_alignment): Declare.
	* config/obj-coff.c (size_section): Handle rs_align_test.
	(fill_section, fixup_mdeps): Likewise.
	(write_object_file): Use frag_align_code.

	* config/tc-alpha.c (alpha_align): Use frag_align_code.
	(alpha_handle_align): New.
	* config/tc-alpha.h (HANDLE_ALIGN): New.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-i386.h (md_do_align): Use frag_align_code.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-ia64.c (ia64_md_do_align): Don't do code alignment.
	(ia64_handle_align): New.
	* config/tc-ia64.h (HANDLE_ALIGN): New.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-m32r.c (m32r_do_align): Remove.
	(m32r_handle_align): New.
	(fill_insn): Use frag_align_code.
	* config/tc-m32r.h (md_do_align): Remove.
	(HANDLE_ALIGN, MAX_MEM_FOR_RS_ALIGN_CODE): New.
	* config/tc-m88k.c, config/tc-m88k.h: Similarly.
	* config/tc-mips.c, config/tc-mips.h: Similarly.

	* config/tc-sh.c (sh_cons_align): Use rs_align_test.
	(sh_handle_align): Likewise.  Handle rs_align_code.
	(sh_do_align): Remove.
	* config/tc-sh.h (md_do_align): Remove.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-sparc.c (sparc_cons_align): Use rs_align_test.
	(sparc_handle_align): Likewise.  Handle rs_align_code.
	* config/tc-sparc.h (md_do_align): Remove.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.
@
text
@d912 1
d939 16
@


1.36
log
@2000-12-03  Kazu Hirata  <kazu@@hxi.com>

	* tc-a29k.c: Fix formatting.
	* tc-alpha.c: Likewise.
	* tc-arm.c: Likewise.
	* tc-cris.c: Likewise.
	* tc-hppa.c: Likewise.
	* tc-i370.c: Likewise.
	* tc-i386.c: Likewise.
	* tc-i860.c: Likewise.
	* tc-i960.c: Likewise.
	* tc-ia64.c: Likewise.
	* tc-m68hc11.c: Likewise.
	* tc-m68k.c: Likewise.
	* tc-m88k.c: Likewise.
	* tc-pj.c: Likewise.
	* tc-ppc.c: Likewise.
	* tc-sh.c: Likewise.
	* tc-sparc.c: Likewise.
	* tc-tahoe.c: Likewise.
	* tc-vax.c: Likewise.
@
text
@d9771 1
a9771 1
int
d9778 1
a9778 2
  /* Fill any pending bundle with nops.  */
  if (bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE)
d9780 1
d9782 27
a9808 6
  /* When we align code in a text section, emit a bundle of 3 nops instead of
     zero bytes.  We can only do this if a multiple of 16 bytes was requested.
     N is log base 2 of the requested alignment.  */
  if (fill == NULL
      && bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE
      && n > 4)
d9810 5
a9814 17
      /* Use mfi bundle of nops with no stop bits.  */
      static const unsigned char be_nop[]
	= { 0x00, 0x04, 0x00, 0x00, 0x00, 0x00, 0x02, 0x00,
	    0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00, 0x0c};
      static const unsigned char le_nop[]
	= { 0x0c, 0x00, 0x00, 0x00, 0x01, 0x00, 0x00, 0x00,
	    0x00, 0x02, 0x00, 0x00, 0x00, 0x00, 0x04, 0x00};

      /* Make sure we are on a 16-byte boundary, in case someone has been
	 putting data into a text section.  */
      frag_align (4, 0, 0);

      if (target_big_endian)
	frag_align_pattern (n, be_nop, 16, max);
      else
	frag_align_pattern (n, le_nop, 16, max);
      return 1;
d9817 2
a9818 1
  return 0;
@


1.35
log
@Eliminate compiler warnings from IA-64 port.
	* config/tc-ia64.c (pseudo_func): Add missing initializers.
	(struct rsrc): Make line unsigned.
	(gr_values): Add missing initializer.
	(SLOT_NUM_NOT_SET): Add unsigned cast.
	(ia64_elf_section_flags, output_vbyte_mem, count_output, dot_radix,
	dot_fframe, dot_vframe, dot_vframesp, dot_vframepsp, dot_save,
	dot_restore, dot_restorereg, dot_restorereg_p, dot_handlerdata,
	dot_unwentry, dot_altrp, dot_saveg, dot_savef, dot_saveb, dot_savegf,
	dot_spill, dot_spillreg, dot_spillreg_p, dot_label_state,
	dot_copy_state, dot_unwabi, dot_personality, dot_proc, dot_body,
	dot_prologue, dot_endp, dot_regstk, dot_psr, dot_alias, dot_ln,
	dot_reg_val, dot_entry, dot_mem_offset, ia64_init, mark_resource,
	md_undefined_symbol, md_apply_fix3, tc_gen_reloc, ia64_md_do_align):
	Add ATTRIBUTE_UNUSED to unused parameters.
	(convert_expr_to_ab_reg): Add parens.
	(convert_expr_to_xy_reg): Add parens.  Comment out >= REG_GR test.
	(dot_prologue): Initialize grsave when declared.
	(md_pseudo_table): Add missing initializers.
	(operand_match): Add casts to bfd_vma.
	(emit_one_bundle): Delete unused local prev.  Make required_template
	unsigned.
	(specify_resource): Cast i to unsigned.
	(note_register_values): Use fprintf_vma.
	(print_dependency): Likewise.
@
text
@d5270 1
a5270 1
	  if (prev_group->g_reg_set_conditionally[regno]) 
d8513 1
a8513 1
		  regdepstotlen * sizeof(struct rsrc));
@


1.34
log
@Fix linux kernel unwind section alignment failure.
	* config/tc-ia64.c (generate_unwind_image): Call record_alignment
	for unwind info section.
	(dot_endp): Likewise for unwind section.
@
text
@d462 9
a470 9
    { "fptr",	PSEUDO_FUNC_RELOC },
    { "gprel",	PSEUDO_FUNC_RELOC },
    { "ltoff",	PSEUDO_FUNC_RELOC },
    { "pcrel",	PSEUDO_FUNC_RELOC },
    { "pltoff",	PSEUDO_FUNC_RELOC },
    { "secrel",	PSEUDO_FUNC_RELOC },
    { "segrel",	PSEUDO_FUNC_RELOC },
    { "ltv",	PSEUDO_FUNC_RELOC },
    { 0, },		/* placeholder for FUNC_LT_FPTR_RELATIVE */
d542 1
a542 1
  int line;                         /* what line marked this dependency */
d579 1
a579 1
} gr_values[128] = {{ 1, 0 }};
d600 1
a600 1
#define SLOT_NUM_NOT_SET        -1
d870 1
a870 1
     int attr, type;
d976 1
a976 1
     char *comment;
d993 2
a994 2
     char *ptr;
     char *comment;
d2706 1
a2706 1
  if (reg >= REG_GR + 4 && reg <= REG_GR + 7)
d2711 2
a2712 2
  else if ((reg >= REG_FR + 2 && reg <= REG_FR + 5)
	   || (reg >= REG_FR + 16 && reg <= REG_FR + 31))
d2717 1
a2717 1
  else if (reg >= REG_BR + 1 && reg <= REG_BR + 5)
d2759 1
a2759 1
  if (reg >= REG_GR && reg <= REG_GR + 127)
d2764 1
a2764 1
  else if (reg >= REG_FR && reg <= REG_FR + 127)
d2769 1
a2769 1
  else if (reg >= REG_BR && reg <= REG_BR + 7)
d2781 1
a2781 1
     int dummy;
d2821 1
a2821 1
     int dummy;
d2835 1
a2835 1
     int dummy;
d2854 1
a2854 1
     int dummy;
d2870 1
a2870 1
     int dummy;
d2886 1
a2886 1
     int dummy;
d2963 1
a2963 1
     int dummy;
d2991 1
a2991 1
     int dummy;
d3008 1
a3008 1
     int dummy;
d3095 1
a3095 1
     int dummy;
d3103 1
a3103 1
     int dummy;
d3110 1
a3110 1
     int dummy;
d3219 1
a3219 1
     int dummy;
d3247 1
a3247 1
     int dummy;
d3261 1
a3261 1
     int dummy;
d3296 1
a3296 1
     int dummy;
d3316 1
a3316 1
     int dummy;
d3333 1
a3333 1
     int dummy;
d3400 1
a3400 1
     int dummy;
d3499 1
a3499 1
     int dummy;
d3514 1
a3514 1
     int dummy;
d3529 1
a3529 1
     int dummy;
d3561 1
a3561 1
     int dummy;
d3576 1
a3576 1
     int dummy;
d3611 1
a3611 1
     int dummy;
d3622 1
a3622 1
     int dummy;
d3625 1
a3625 1
  int mask = 0, grsave;
d3663 1
a3663 1
     int dummy;
d3735 1
a3735 1
     int dummy;
d3886 1
a3886 1
     int dummy;
d3919 1
a3919 1
     int dummy;
d3926 1
a3926 1
     int dummy;
d4070 1
a4070 1
     int dummy;
d4323 1
a4323 1
     int dummy;
d4362 1
a4362 1
  int dummy;
d4392 15
a4406 15
    { "endp", dot_endp },
    { "file", dwarf2_directive_file },
    { "loc", dwarf2_directive_loc },

    { "fframe", dot_fframe },
    { "vframe", dot_vframe },
    { "vframesp", dot_vframesp },
    { "vframepsp", dot_vframepsp },
    { "save", dot_save },
    { "restore", dot_restore },
    { "restorereg", dot_restorereg },
    { "restorereg.p", dot_restorereg_p },
    { "handlerdata", dot_handlerdata },
    { "unwentry", dot_unwentry },
    { "altrp", dot_altrp },
d4409 6
a4414 6
    { "save.g", dot_saveg },
    { "save.f", dot_savef },
    { "save.b", dot_saveb },
    { "save.gf", dot_savegf },
    { "spill", dot_spill },
    { "spillreg", dot_spillreg },
d4417 1
a4417 1
    { "spillreg.p", dot_spillreg_p },
d4420 4
a4423 4
    { "label_state", dot_label_state },
    { "copy_state", dot_copy_state },
    { "unwabi", dot_unwabi },
    { "personality", dot_personality },
d4425 1
a4425 1
    { "estate", dot_estate },
d4473 1
a4473 1
    { "mem.offset", dot_mem_offset },
d4479 1
a4479 1
    { "reg.val", dot_reg_val },
d4824 1
a4824 1
	       && e->X_add_number < ((bfd_vma) 1 << 44))
d4826 1
a4826 1
		  && -e->X_add_number <= ((bfd_vma) 1 << 44))))
d4842 1
a4842 1
	       && e->X_add_number < ((bfd_vma) 1 << 17))
d4844 1
a4844 1
		  && -e->X_add_number <= ((bfd_vma) 1 << 17))))
d4953 2
a4954 2
      if ((val >= 0 && val < ((bfd_vma) 1 << (bits - 1)))
	  || (val < 0 && -val <= ((bfd_vma) 1 << (bits - 1))))
d5413 1
a5413 1
  unw_rec_list *ptr, *prev;
d5480 2
a5481 1
	  int required_slot, required_template;
d6162 2
a6163 2
     int argc;
     char **argv;
d6961 1
a6961 1
			if (i != (gr_values[regno].value & 0xFF))
d8306 5
a8310 2
	    fprintf (stderr, "  Know gr%d = 0x%llx\n",
		     regno, gr_values[regno].value);
d8502 2
a8503 2
     struct ia64_opcode *idesc;
     const struct ia64_dependency *dep;
d8540 6
a8545 3
	fprintf (stderr, " 0x%llx+0x%llx",
		 regdeps[depind].mem_offset.base,
		 regdeps[depind].mem_offset.offset);
d9132 1
a9132 1
     char *name;
d9599 1
a9599 1
     segT seg;
d9677 1
a9677 1
     asection *sec;
d9775 1
a9775 1
     int len;
@


1.33
log
@Fix assembler error on linux kernel mm/memory.c file.
	* config/tc-ia64.c (emit_one_bundle): Pass size of 8 not 4 to
	fix_new_exp.
@
text
@d3060 3
d3690 4
@


1.32
log
@	* as.c (debug_type): Init to DEBUG_UNSPECIFIED.
	* as.h (debug_type): Clarify documentation of the meaning
	of this variable.
	* dwarf2dbg.c (DWARF2_LINE_MIN_INSN_LENGTH): Default to 1.
	(print_stats): Fix parenthesis problem.
	(now_subseg_size): New.
	(dwarf2_finish): Use it.  If DEBUG_DWARF2, emit bits for .debug_info.
	(dwarf2_directive_file): Don't set debug_type.
	(dwarf2_where): Honor DEBUG_DWARF2 first.
	(dwarf2_emit_insn): Renamed from dwarf2_generate_asm_lineno;
	do nothing if not emitting dwarf2 debug info, or no work.
	* dwarf2dbg.h (dwarf2_emit_insn): Update.
	* ecoff.c (add_file): Turn on DEBUG_ECOFF only if DEBUG_UNSPECIFIED.
	(ecoff_new_file): Likewise.
	* read.c (generate_lineno_debug): Kill ecoff hackery.  Update
	commentary wrt dwarf2.

	* config/tc-alpha.c (alpha_adjust_symtab_relocs): Add
	ATTRIBUTE_UNUSED as needed.
	(emit_insn): Call dwarf2_emit_insn.
	(s_alpha_file): New.
	(s_alpha_loc): New.
	(s_alpha_coff_wrapper): Don't handle them.
	(md_pseudo_table): Update for .file and .loc.
	* config/tc-alpha.h (DWARF2_LINE_MIN_INSN_LENGTH): New.

	* config/tc-arm.c (output_inst): Update for dwarf2_emit_insn;
	don't protect with debug_type.
	* config/tc-hppa.c (md_assemble): Likewise.
	* config/tc-m68hc11.c (m68hc11_new_insn): Likewise.
	* config/tc-mn10300.c (md_assemble): Likewise.
	* config/tc-sh.c (md_assemble): Likewise.
	* config/tc-v850.c (md_assemble): Likewise.

	* config/tc-arm.c (arm_end_of_source): Remove.
	* config/tc-hppa.c (pa_end_of_source): Remove.
	* config/tc-m68hc11.c (m68hc11_end_of_source): Remove.
	* config/tc-mn10300.c (mn10300_finalize): Remove.
	* config/tc-sh.c (sh_finalize): Remove.
	* config/tc-v850.c (sh_finalize): Remove.

	* config/tc-arm.h (md_end): Remove.
	* config/tc-hppa.h (md_end): Remove.
	(DWARF2_LINE_MIN_INSN_LENGTH): New.
	* config/tc-m68hc11.h (md_end): Remove.
	* config/tc-mn10300.h (md_end): Remove.
	* config/tc-sh.h (md_end): Remove.
	* config/tc-v850.h (md_end): Remove.

	* config/tc-ia64.c (emit_one_bundle): Don't protect
	dwarf2 bits with debug_type.
	(md_assemble): Likewise.
	(ia64_end_of_source): Don't call dwarf2_finish.
@
text
@d5698 1
a5698 1
	  fix = fix_new_exp (frag_now, frag_now_fix () - 16 + i, 4,
@


1.31
log
@Fix minor typos in recent errata workaround patch.
	* config/tc-ia64.c (errata_nop_necessary_p): Abort if general regno
	>= 128 instead of > 128.  Abort if predicate regno is >= 64 instead of
	> 16.
@
text
@a5651 1
      if (debug_type == DEBUG_DWARF2)
a6198 3
  if (debug_type == DEBUG_DWARF2)
    dwarf2_finish ();

d9087 1
a9087 2
  if (debug_type == DEBUG_DWARF2)
    dwarf2_where (&CURR_SLOT.debug_line);
@


1.30
log
@Workaround for Itanium A/B step errata
@
text
@d5202 1
a5202 1
	    if (regno > 16)
d5218 1
a5218 1
	    if (regno > 128)
d5249 1
a5249 1
	  if (regno > 128)
@


1.29
log
@Extend earlier ia64-hpux patches to work correctly for ia64-linux.
	* config/tc-ia64.c (ia64_target_format): If EF_IA_64_BE not set, then
	return little endian bfd formats.
@
text
@d255 19
d5181 89
d5660 3
d5708 6
@


1.28
log
@2000-11-14  Kazu Hirata  <kazu@@hxi.com>

	* config/aout_gnu.h: Fix formatting.
	* config/atof-vax.c: Likewise.
	* config/m68k-parse.h: Likewise.
	* config/m88k-opcode.h: Likewise.
	* config/obj-elf.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-cris.c: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/te-386bsd.h: Likewise.
	* config/te-hppa.h: Likewise.
	* config/te-nbsd.h: Likewise.
	* config/te-ppcnw.h: Likewise.
	* config/te-sparcaout.h: Likewise.
	* config/te-tmips.h: Likewise.
	* config/vax-inst.h: Likewise.
	* config/vms-conf.h: Likewise.
@
text
@d6053 7
a6059 2
      if (md.flags & EF_IA_64_ABI64)
	return "elf64-ia64-big";
d6061 6
a6066 1
	return "elf32-ia64-big";
@


1.27
log
@Correct unwind region length calculations.
	* config/tc-ia64.c (struct unw_rec_list): Add slot_frag field.
	(struct unwind): Add next_slot_frag field.
	(slot_index): New parameters slot_frag and first_frag.  Add code
	to add in frag sizes when different.  Add comments.
	(fixup_unw_records): New locals first_frag and last_frag.  Pass new
	arguments to slot_index.
	(emit_one_bundle): Set slot_frag field.  Set next_slot_number after
	loop end.  Set next_slot_frag field.
@
text
@d2461 1
a2461 1
  
@


1.26
log
@ia64-hpux patches from Steve Ellcey.
	* config/tc-ia64.c (md_shortopts, md_parse_option, md_show_usage):
	Change M to m for -milp32 or -mlp64 to match gcc.
	(dot_endp): Use bytes_per_address instead of 8.
	(emit_one_bundle): Use number_to_chars_littleendian instead of
	md_number_to_chars.
	(fix_insn): Likewise.
	(ia64_init): New function.
	(ia64_target_format): New function.
	(md_begin): Set endianness, arch, and machine as appropriate.
	* config/tc-ia64.h: (TARGET_BYTES_BIG_ENDIAN, md_number_to_chars):
	Make these macros depend on TE_HPUX macro.
	(TARGET_FORMAT): Define.
	(HOST_SPECIAL_INIT): Define.
	* config/te-hpux.h: New file.
	* configure.in: Add "ia64-*-hpux*" target to configure.
	* configure: Regenerate.
@
text
@d565 9
d577 1
d586 1
d807 2
a808 1
static unsigned long slot_index PARAMS ((unsigned long, unsigned long));
d2421 4
d2426 5
a2430 1
slot_index (unsigned long slot_addr, unsigned long first_addr)
d2432 28
a2459 2
  return (3 * ((slot_addr >> 4) - (first_addr >> 4))
	  + ((slot_addr & 0x3) - (first_addr & 0x3)));
d2461 1
a2461 1

d2473 1
d2479 2
a2480 1
      t = slot_index (ptr->slot_number, first_addr);
d2490 1
d2493 1
d2498 1
d2504 1
d2515 1
d2540 2
a2541 1
	    size = slot_index (last_addr, first_addr) + dir_len;
d5350 4
a5353 1
	  ptr->slot_number = (unsigned long) f + i;
d5558 4
a5561 1
	  ptr->slot_number = (unsigned long) f + i;
a5562 1
      unwind.next_slot_number = (unsigned long) f + i + ((i == 2)?(0x10-2):1);
d5628 3
@


1.25
log
@Add tag support.  Error for dangling qualifying predicates.
	* config/tc-ia64.c (struct md): New field tag_fixups.
	(ia64_flush_insns): Handle tag_fixups.  Error if dangling
	qualifying predicate.
	(emit_one_bundle): Delete spurious multiplication by one.  Handle
	tag_fixups.
	(ia64_start_line): Error if dangling qualifying predicate.
	(defining_tag): New static variable.
	(ia64_unrecognized_line, case '['): Parse tags.
	(ia64_frob_label): Create tag_fixups.
	(md_assemble): Reset md.qp.X_op after using it.
@
text
@d159 1
a159 1
const char *md_shortopts = "M:N:x::";
d3591 1
d3616 1
d3623 1
a3623 1
  ia64_cons_fix_new (frag_now, where, 8, &e);
d3629 1
a3629 1
  ia64_cons_fix_new (frag_now, where + 8, 8, &e);
d3637 1
a3637 1
      ia64_cons_fix_new (frag_now, where + 16, 8, &e);
d3640 1
a3640 1
    md_number_to_chars (ptr + 16, 0, 8);
d5567 2
a5568 2
  md_number_to_chars (f + 0, t0, 8);
  md_number_to_chars (f + 8, t1, 8);
d5579 1
a5579 1
    case 'M':
d5693 2
a5694 2
  -Milp32|-Milp64|-Mlp64|-Mp64	select data model (default -Mlp64)\n\
  -Mle | -Mbe		  select little- or big-endian byte order (default -Mle)\n\
d5745 1
a5745 1
  int i, j, k, t, total, ar_base, cr_base, goodness, best, regnum;
d5754 1
a5754 1
  target_big_endian = 0;
d5953 9
a5961 3
  /* Default to 64-bit mode.  */
  /* ??? This overrides the -M options, but they aren't working anyways.  */
  md.flags |= EF_IA_64_ABI64;
d5969 31
d9387 2
a9388 2
  md_number_to_chars (fixpos + 0, t0, 8);
  md_number_to_chars (fixpos + 8, t1, 8);
@


1.24
log
@Better bundle template selection
@
text
@d222 1
d901 6
d909 3
d5489 1
a5489 1
	  addr = frag_now->fr_address + frag_now_fix () - 16 + 1 * i;
d5517 6
d5981 2
d5997 4
d6071 38
d6123 12
d8843 4
a8846 1
    qp_regno = md.qp.X_add_number - REG_P;
@


1.23
log
@Minor DV table update, minor DV checking bug fix.
	* config/tc-ia64.c (resources_match): Handle IA64_RS_PRr.
	* ia64-ic.tbl: Update from Intel.
	* ia64-asmtab.c: Regenerate.
@
text
@d5714 1
a5714 1
  if (match (templ, IA64_TYPE_F, slot))
d5716 1
a5716 1
  if (match (templ, IA64_TYPE_B, slot))
@


1.22
log
@Excise C++ style comments.
@
text
@d8080 1
d8089 1
a8089 1
			 rs->dependency->specifier == IA64_RS_PR ?
d8099 1
a8099 1
		     rs->dependency->specifier == IA64_RS_PR ?
@


1.21
log
@Fix ia64 gas testsuite.  Update ia64 DV tables.  Fix ia64 gas testsuite again.
gas/ChangeLog
	* config/tc-ia64.c (dv_sem): Add "stop".
	(specify_resource, case IA64_RS_PR): Only handles regs 1 to 15 now.
	(specify_resource, case IA64_RS_PRr): New for regs 16 to 62.
	(specify_resource, case IA64_RS_PR63): Reorder (note == 7) test to
	match above.
	(mark_resources): Check IA64_RS_PRr.
gas/testsuite/ChangeLog
	* gas/ia64/dv-raw-err.s: Add new testcases for PR%, 16 - 62.
	* gas/ia64/dv-waw-err.s: Likewise.
	* gas/ia64/dv-imply.d: Regenerate.
	* gas/ia64/dv-mutex.d, gas/ia64/dv-raw-err.l, gas/ia64/dv-safe.d,
	gas/ia64/dv-srlz.d, gas/ia64/dv-war-err.l, gas/ia64/dv-waw-err.l,
	gas/ia64/opc-f.d, gas/ia64/opc-i.d, gas/ia64/opc-m.d: Likewise.
include/opcode/ChangeLog
	* ia64.h (enum ia64_dependency_semantics): Add IA64_DVS_STOP.
opcodes/ChangeLog
	* ia64-dis.c (print_insn_ia64): Revert Aug 7 byte skip count change.
	* ia64-gen.c (parse_semantics): Handle IA64_DVS_STOP.
	(lookup_specifier): Handle "PR%, 1 to 15" and "PR%, 16 to 62".
	* ia64-ic.tbl, ia64-raw.tbl, ia64-war.tbl, ia64-waw.tbl: Update.
	* ia64-asmtab.c: Regnerate.
@
text
@d7913 1
a7913 1
      // FIXME keep GR values which are marked as "safe_across_calls"
@


1.20
log
@2000-09-15  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-h8300.h: Fix formatting.
	* config/tc-h8500.c: Likewise.
	* config/tc-h8500.h: Likewise.
	* config/tc-hppa.h: Likewise.
	* config/tc-i370.h: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i860.c: Likewise.
	* config/tc-i860.h: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ia64.h: Likewise.
@
text
@d531 1
a531 1
				"data", "instr", "specific", "other" };
d6924 2
d6929 1
a6929 1
	  if (idesc->operands[0] == IA64_OPND_PR_ROT)
d6931 75
a7005 1
	      for (i = 16; i < 63; i++)
d7008 3
a7010 1
		  specs[count++].index = i;
d7015 1
a7015 1
	      for (i = 1; i < 63; i++)
d7018 9
a7026 1
		  specs[count++].index = i;
d7030 17
d7055 6
a7060 10
	      if (mask & ((valueT) 1 << 16))
		mask |= ~(valueT) 0xffff;
	      for (i = 1; i < 63; i++)
		{
		  if (mask & ((valueT) 1 << i))
		    {
		      specs[count] = tmpl;
		      specs[count++].index = i;
		    }
		}
d7086 1
a7086 1
		      if (regno != 0)
d7101 1
a7101 1
	  if (CURR_SLOT.qp_regno != 0)
d7118 1
a7118 1
		  && p1 != 0 && p1 != 63)
d7127 1
a7127 1
		  && p2 != 0 && p2 != 63)
d7137 1
a7137 1
	      if (CURR_SLOT.qp_regno != 0)
d7144 1
a7144 1
		  for (i = 1; i < 63; i++)
d7538 2
d7545 8
a7569 10
      else if (note == 7)
	{
	  valueT mask = 0;
	  if (idesc->operands[2] == IA64_OPND_IMM17)
	    mask = CURR_SLOT.opnd[2].X_add_number;
	  if (mask & ((valueT) 1 << 63))
	    {
	      specs[count++] = tmpl;
	    }
	}
d8509 1
@


1.19
log
@Eliminate false DVs on parallel compares.
@
text
@d7022 1
a7022 1
		  specs[count].cmp_type = 
d7031 1
a7031 1
		  specs[count].cmp_type = 
d7480 1
a7480 1
	      if (p1 == 63 
d7485 1
a7485 1
		  specs[count++].cmp_type = 
d7493 1
a7493 1
		  specs[count++].cmp_type = 
d7979 1
a7979 1
	 writes are an OR. */
d7994 1
a7994 1
	    fprintf (stderr, 
d7997 1
a7997 1
		     dv_cmp_type[rs->cmp_type], 
d8001 1
a8001 1
		     
@


1.18
log
@2000-09-03  Kazu Hirata  <kazu@@hxi.com>

	* cgen.c: Fix formatting.
	* config/tc-ia64.c: Likewise.
@
text
@d524 1
d532 1
d6379 1
d7014 3
d7022 2
d7031 2
d7475 21
a7495 7
	      for (i = 0; i < idesc->num_outputs; i++)
		if ((idesc->operands[i] == IA64_OPND_P1
		     || idesc->operands[i] == IA64_OPND_P2)
		    && CURR_SLOT.opnd[i].X_add_number - REG_P == 63)
		  {
		    specs[count++] = tmpl;
		  }
d7976 26
@


1.17
log
@        * config/tc-ia64.c (emit_one_bundle): Stop collecting insns
        for template selection when a label is needed.
@
text
@d38 4
a41 4
        <reg>.safe_across_calls and any other DV-related directives I don't
          have documentation for.
        verify mod-sched-brs reads/writes are checked/marked (and other
        notes)
d113 1
a113 1
    /* The following pseudo-registers are used for unwind directives only: */
d132 4
a135 4
  {
    struct label_fix *next;
    struct symbol *sym;
  };
d157 1
a157 1
/* ia64-specific option processing: */
d251 1
a251 1
                                       the current DV-checking block.  */
d253 1
a253 1
                                       entry_labels */
d257 1
a257 1
/* application registers: */
d309 1
a309 1
/* control registers: */
d358 1
a358 1
    /* PSR constant masks: */
d396 1
a396 1
/* indirect register-sets/memory: */
d441 1
a441 1
    /* reloc pseudo functions (these must come first!): */
d452 1
a452 1
    /* mbtype4 constants: */
d459 1
a459 1
    /* fclass constants: */
d472 1
a472 1
    /* unwind-related constants: */
d477 1
a477 1
    /* unwind-related registers: */
d481 1
a481 1
/* 41-bit nop opcodes (one per unit): */
d530 1
a530 1
                                "data", "instr", "specific", "other" };
d595 1
a595 1
/* Forward delarations: */
d653 1
a653 1
static symbolS* declare_register PARAMS ((const char *name, int regnum));
d847 2
a848 1
  unsigned int sof;	/* size of frame */
d891 1
a891 1
     those now: */
d1052 1
a1052 1
  {
d1091 1
a1091 1
  }
d1153 51
a1203 51
      case mem_stack_f:
	r = 0;
	count += output_leb128 (bytes + count, w2 >> 4, 0);
	break;
      case mem_stack_v:
        r = 1;
	break;
      case spill_base:
        r = 2;
	break;
      case psp_sprel:
        r = 3;
	break;
      case rp_when:
        r = 4;
	break;
      case rp_psprel:
        r = 5;
	break;
      case pfs_when:
        r = 6;
	break;
      case pfs_psprel:
        r = 7;
	break;
      case preds_when:
        r = 8;
	break;
      case preds_psprel:
        r = 9;
	break;
      case lc_when:
        r = 10;
	break;
      case lc_psprel:
        r = 11;
	break;
      case unat_when:
        r = 12;
	break;
      case unat_psprel:
        r = 13;
	break;
      case fpsr_when:
        r = 14;
	break;
      case fpsr_psprel:
        r = 15;
	break;
      default:
	break;
d1221 59
a1279 59
      case rp_sprel:
        r = 1;
	break;
      case pfs_sprel:
        r = 2;
	break;
      case preds_sprel:
        r = 3;
	break;
      case lc_sprel:
        r = 4;
	break;
      case unat_sprel:
        r = 5;
	break;
      case fpsr_sprel:
        r = 6;
	break;
      case bsp_when:
        r = 7;
	break;
      case bsp_psprel:
        r = 8;
	break;
      case bsp_sprel:
        r = 9;
	break;
      case bspstore_when:
        r = 10;
	break;
      case bspstore_psprel:
        r = 11;
	break;
      case bspstore_sprel:
        r = 12;
	break;
      case rnat_when:
        r = 13;
	break;
      case rnat_psprel:
        r = 14;
	break;
      case rnat_sprel:
        r = 15;
	break;
      case priunat_when_gr:
        r = 16;
	break;
      case priunat_psprel:
        r = 17;
	break;
      case priunat_sprel:
        r = 18;
	break;
      case priunat_when_mem:
        r = 19;
	break;
      default:
	break;
d1398 2
a1399 2
  int ab;
  int reg;
d1491 1
d1504 1
d1509 1
a1509 1
  for (ptr = first; ptr != NULL; )
d1579 1
a1579 1
  ptr->r.record.p.spoff = offset/4;
d1613 1
a1613 1
  ptr->r.record.p.pspoff = offset/4;
d1622 1
a1622 1
  ptr->r.record.p.spoff = offset/4;
d1647 1
a1647 1
  ptr->r.record.p.pspoff = offset/4;
d1656 1
a1656 1
  ptr->r.record.p.spoff = offset/4;
d1681 1
a1681 1
  ptr->r.record.p.pspoff = offset/4;
d1690 1
a1690 1
  ptr->r.record.p.spoff = offset/4;
d1758 1
a1758 1
  ptr->r.record.p.pspoff = offset/4;
d1783 1
a1783 1
  ptr->r.record.p.pspoff = offset/4;
d1792 1
a1792 1
  ptr->r.record.p.spoff = offset/4;
d1817 1
a1817 1
  ptr->r.record.p.pspoff = offset/4;
d1826 1
a1826 1
  ptr->r.record.p.spoff = offset/4;
d1851 1
a1851 1
  ptr->r.record.p.pspoff = offset/4;
d1860 1
a1860 1
  ptr->r.record.p.spoff = offset/4;
d1892 1
a1892 1
  ptr->r.record.p.pspoff = offset/4;
d1901 1
a1901 1
  ptr->r.record.p.spoff = offset/4;
d1926 1
a1926 1
  ptr->r.record.p.pspoff = offset/4;
d1935 1
a1935 1
  ptr->r.record.p.spoff = offset/4;
d1960 1
a1960 1
  ptr->r.record.p.pspoff = offset/4;
d1969 1
a1969 1
  ptr->r.record.p.spoff = offset/4;
d1994 1
a1994 1
  ptr->r.record.p.pspoff = offset/4;
d2003 1
a2003 1
  ptr->r.record.p.spoff = offset/4;
d2051 1
a2051 1
  ptr->r.record.x.pspoff = offset/4;
d2064 1
a2064 1
  ptr->r.record.x.spoff = offset/4;
d2078 1
a2078 1
  ptr->r.record.x.pspoff = offset/4;
d2093 1
a2093 1
  ptr->r.record.x.spoff = offset/4;
d2132 1
d2142 6
a2147 6
      case gr_mem:
      case fr_mem:
      case br_mem:
      case frgr_mem:
	/* these are taken care of by prologue/prologue_gr */
	break;
d2149 7
a2155 31
      case prologue_gr:
      case prologue:
	if (ptr->r.type == prologue_gr)
	  output_R2_format (f, ptr->r.record.r.grmask,
			    ptr->r.record.r.grsave, ptr->r.record.r.rlen);
	else
	  output_R1_format (f, ptr->r.type, ptr->r.record.r.rlen);

	/* output descriptor(s) for union of register spills (if any): */
	gr_mask = ptr->r.record.r.mask.gr_mem;
	fr_mask = ptr->r.record.r.mask.fr_mem;
	if (fr_mask)
	  {
	    if ((fr_mask & ~0xfUL) == 0)
	      output_P6_format (f, fr_mem, fr_mask);
	    else
	      {
		output_P5_format (f, gr_mask, fr_mask);
		gr_mask = 0;
	      }
	  }
	if (gr_mask)
	  output_P6_format (f, gr_mem, gr_mask);
	if (ptr->r.record.r.mask.br_mem)
	  output_P1_format (f, ptr->r.record.r.mask.br_mem);

	/* output imask descriptor if necessary: */
	if (ptr->r.record.r.mask.i)
	  output_P4_format (f, ptr->r.record.r.mask.i,
			    ptr->r.record.r.imask_size);
	break;
d2157 146
a2302 122
      case body:
	output_R1_format (f, ptr->r.type, ptr->r.record.r.rlen);
	break;
      case mem_stack_f:
      case mem_stack_v:
	output_P7_format (f, ptr->r.type, ptr->r.record.p.t,
			  ptr->r.record.p.size);
	break;
      case psp_gr:
      case rp_gr:
      case pfs_gr:
      case preds_gr:
      case unat_gr:
      case lc_gr:
      case fpsr_gr:
      case priunat_gr:
      case bsp_gr:
      case bspstore_gr:
      case rnat_gr:
	output_P3_format (f, ptr->r.type, ptr->r.record.p.gr);
	break;
      case rp_br:
	output_P3_format (f, rp_br, ptr->r.record.p.br);
	break;
      case psp_sprel:
	output_P7_format (f, psp_sprel, ptr->r.record.p.spoff, 0);
	break;
      case rp_when:
      case pfs_when:
      case preds_when:
      case unat_when:
      case lc_when:
      case fpsr_when:
	output_P7_format (f, ptr->r.type, ptr->r.record.p.t, 0);
	break;
      case rp_psprel:
      case pfs_psprel:
      case preds_psprel:
      case unat_psprel:
      case lc_psprel:
      case fpsr_psprel:
      case spill_base:
	output_P7_format (f, ptr->r.type, ptr->r.record.p.pspoff, 0);
	break;
      case rp_sprel:
      case pfs_sprel:
      case preds_sprel:
      case unat_sprel:
      case lc_sprel:
      case fpsr_sprel:
      case priunat_sprel:
      case bsp_sprel:
      case bspstore_sprel:
      case rnat_sprel:
	output_P8_format (f, ptr->r.type, ptr->r.record.p.spoff);
	break;
      case gr_gr:
	output_P9_format (f, ptr->r.record.p.grmask, ptr->r.record.p.gr);
	break;
      case br_gr:
	output_P2_format (f, ptr->r.record.p.brmask, ptr->r.record.p.gr);
	break;
      case spill_mask:
	as_bad ("spill_mask record unimplemented.");
	break;
      case priunat_when_gr:
      case priunat_when_mem:
      case bsp_when:
      case bspstore_when:
      case rnat_when:
	output_P8_format (f, ptr->r.type, ptr->r.record.p.t);
	break;
      case priunat_psprel:
      case bsp_psprel:
      case bspstore_psprel:
      case rnat_psprel:
	output_P8_format (f, ptr->r.type, ptr->r.record.p.pspoff);
	break;
      case unwabi:
	output_P10_format (f, ptr->r.record.p.abi, ptr->r.record.p.context);
	break;
      case epilogue:
	output_B3_format (f, ptr->r.record.b.ecount, ptr->r.record.b.t);
	break;
      case label_state:
      case copy_state:
	output_B4_format (f, ptr->r.type, ptr->r.record.b.label);
	break;
      case spill_psprel:
	output_X1_format (f, ptr->r.type, ptr->r.record.x.ab,
			  ptr->r.record.x.reg, ptr->r.record.x.t,
			  ptr->r.record.x.pspoff);
	break;
      case spill_sprel:
	output_X1_format (f, ptr->r.type, ptr->r.record.x.ab,
			  ptr->r.record.x.reg, ptr->r.record.x.t,
			  ptr->r.record.x.spoff);
	break;
      case spill_reg:
	output_X2_format (f, ptr->r.record.x.ab, ptr->r.record.x.reg,
			  ptr->r.record.x.xy >> 1, ptr->r.record.x.xy,
			  ptr->r.record.x.treg, ptr->r.record.x.t);
	break;
      case spill_psprel_p:
	output_X3_format (f, ptr->r.type, ptr->r.record.x.qp,
			  ptr->r.record.x.ab, ptr->r.record.x.reg,
			  ptr->r.record.x.t, ptr->r.record.x.pspoff);
	break;
      case spill_sprel_p:
	output_X3_format (f, ptr->r.type, ptr->r.record.x.qp,
			  ptr->r.record.x.ab, ptr->r.record.x.reg,
			  ptr->r.record.x.t, ptr->r.record.x.spoff);
	break;
      case spill_reg_p:
	output_X4_format (f, ptr->r.record.x.qp, ptr->r.record.x.ab,
			  ptr->r.record.x.reg, ptr->r.record.x.xy >> 1,
			  ptr->r.record.x.xy, ptr->r.record.x.treg,
			  ptr->r.record.x.t);
	break;
      default:
	as_bad ("record_type_not_valid");
	break;
d2354 1
a2354 1
      imask_size = (region->r.record.r.rlen*2 + 7)/8 + 1;
d2362 2
a2363 2
  i = (t/4) + 1;
  pos = 2*(3 - t%4);
d2400 1
a2400 1
  return (3*((slot_addr >> 4) - (first_addr >> 4))
d2408 1
d2419 1
a2419 1
        as_bad (" Insn slot not set in unwind record.");
d2423 55
a2477 59
	  case prologue:
	  case prologue_gr:
	  case body:
	    {
	      unw_rec_list *last;
	      int size, dir_len = 0;
	      unsigned long last_addr;

	      first_addr = ptr->slot_number;
	      ptr->slot_number = 0;
	      /* Find either the next body/prologue start, or the end of
		 the list, and determine the size of the region.  */
	      last_addr = unwind.next_slot_number;
	      for (last = ptr->next; last != NULL; last = last->next)
		if (last->r.type == prologue || last->r.type == prologue_gr
		    || last->r.type == body)
		  {
		    last_addr = last->slot_number;
		    break;
		  }
		else if (!last->next)
		  {
		    /* In the absence of an explicit .body directive,
		       the prologue ends after the last instruction
		       covered by an unwind directive.  */
		    if (ptr->r.type != body)
		      {
			last_addr = last->slot_number;
			switch (last->r.type)
			  {
			  case frgr_mem:
			    dir_len = (count_bits (last->r.record.p.frmask)
				       + count_bits (last->r.record.p.grmask));
			    break;
			  case fr_mem:
			  case gr_mem:
			    dir_len += count_bits (last->r.record.p.rmask);
			    break;
			  case br_mem:
			  case br_gr:
			    dir_len += count_bits (last->r.record.p.brmask);
			    break;
			  case gr_gr:
			    dir_len += count_bits (last->r.record.p.grmask);
			    break;
			  default:
			    dir_len = 1;
			    break;
			  }
		      }
		    break;
		  }
	      size = slot_index (last_addr, first_addr) + dir_len;
	      rlen = ptr->r.record.r.rlen = size;
	      region = ptr;
	      break;
	    }
	  case epilogue:
	    ptr->r.record.b.t = rlen - 1 - t;
d2479 4
d2484 15
a2498 15
	  case mem_stack_f:
	  case mem_stack_v:
	  case rp_when:
	  case pfs_when:
	  case preds_when:
	  case unat_when:
	  case lc_when:
	  case fpsr_when:
	  case priunat_when_gr:
	  case priunat_when_mem:
	  case bsp_when:
	  case bspstore_when:
	  case rnat_when:
	    ptr->r.record.p.t = t;
	    break;
d2500 8
a2507 8
	  case spill_reg:
	  case spill_sprel:
	  case spill_psprel:
	  case spill_reg_p:
	  case spill_sprel_p:
	  case spill_psprel_p:
	    ptr->r.record.x.t = t;
	    break;
d2509 38
a2546 38
	  case frgr_mem:
	    if (!region)
	      {
		as_bad ("frgr_mem record before region record!\n");
		return;
	      }
	    region->r.record.r.mask.fr_mem |= ptr->r.record.p.frmask;
	    region->r.record.r.mask.gr_mem |= ptr->r.record.p.grmask;
	    set_imask (region, ptr->r.record.p.frmask, t, 1);
	    set_imask (region, ptr->r.record.p.grmask, t, 2);
	    break;
	  case fr_mem:
	    if (!region)
	      {
		as_bad ("fr_mem record before region record!\n");
		return;
	      }
	    region->r.record.r.mask.fr_mem |= ptr->r.record.p.rmask;
	    set_imask (region, ptr->r.record.p.rmask, t, 1);
	    break;
	  case gr_mem:
	    if (!region)
	      {
		as_bad ("gr_mem record before region record!\n");
		return;
	      }
	    region->r.record.r.mask.gr_mem |= ptr->r.record.p.rmask;
	    set_imask (region, ptr->r.record.p.rmask, t, 2);
	    break;
	  case br_mem:
	    if (!region)
	      {
		as_bad ("br_mem record before region record!\n");
		return;
	      }
	    region->r.record.r.mask.br_mem |= ptr->r.record.p.brmask;
	    set_imask (region, ptr->r.record.p.brmask, t, 3);
	    break;
d2548 16
a2563 16
	  case gr_gr:
	    if (!region)
	      {
		as_bad ("gr_gr record before region record!\n");
		return;
	      }
	    set_imask (region, ptr->r.record.p.grmask, t, 2);
	    break;
	  case br_gr:
	    if (!region)
	      {
		as_bad ("br_gr record before region record!\n");
		return;
	      }
	    set_imask (region, ptr->r.record.p.brmask, t, 3);
	    break;
d2565 2
a2566 2
	  default:
	    break;
d2706 1
a2706 1
      ignore_rest_of_line  ();
d2818 1
a2818 1
      if (e2.X_op == O_register && reg2 >=0 && reg2 < 128)
d2822 45
a2866 45
	      case REG_AR + AR_BSP:
	        add_unwind_entry (output_bsp_when ());
	        add_unwind_entry (output_bsp_gr (reg2));
		break;
	      case REG_AR + AR_BSPSTORE:
	        add_unwind_entry (output_bspstore_when ());
	        add_unwind_entry (output_bspstore_gr (reg2));
		break;
	      case REG_AR + AR_RNAT:
	        add_unwind_entry (output_rnat_when ());
	        add_unwind_entry (output_rnat_gr (reg2));
		break;
	      case REG_AR+AR_UNAT:
	        add_unwind_entry (output_unat_when ());
	        add_unwind_entry (output_unat_gr (reg2));
		break;
	      case REG_AR+AR_FPSR:
	        add_unwind_entry (output_fpsr_when ());
	        add_unwind_entry (output_fpsr_gr (reg2));
		break;
	      case REG_AR+AR_PFS:
	        add_unwind_entry (output_pfs_when ());
		if (! (unwind.prologue_mask & 4))
	          add_unwind_entry (output_pfs_gr (reg2));
		break;
	      case REG_AR+AR_LC:
	        add_unwind_entry (output_lc_when ());
	        add_unwind_entry (output_lc_gr (reg2));
		break;
	      case REG_BR:
		add_unwind_entry (output_rp_when ());
		if (! (unwind.prologue_mask & 8))
		  add_unwind_entry (output_rp_gr (reg2));
		break;
	      case REG_PR:
		add_unwind_entry (output_preds_when ());
		if (! (unwind.prologue_mask & 1))
		  add_unwind_entry (output_preds_gr (reg2));
		break;
	      case REG_PRIUNAT:
		add_unwind_entry (output_priunat_when_gr ());
		add_unwind_entry (output_priunat_gr (reg2));
		break;
	      default:
	        as_bad ("First operand not a valid register");
d2978 1
a2978 1
      where = (unsigned char *)frag_more (size);
d2988 1
a2988 1
        {
d2995 1
a2995 1
        }
d3006 1
a3006 1
dot_handlerdata  (dummy)
d3058 62
a3119 62
	      case REG_AR + AR_BSP:
	        add_unwind_entry (output_bsp_when ());
	        add_unwind_entry ((psprel
				   ? output_bsp_psprel
				   : output_bsp_sprel) (val));
		break;
	      case REG_AR + AR_BSPSTORE:
	        add_unwind_entry (output_bspstore_when ());
	        add_unwind_entry ((psprel
				   ? output_bspstore_psprel
				   : output_bspstore_sprel) (val));
		break;
	      case REG_AR + AR_RNAT:
	        add_unwind_entry (output_rnat_when ());
	        add_unwind_entry ((psprel
				   ? output_rnat_psprel
				   : output_rnat_sprel) (val));
		break;
	      case REG_AR + AR_UNAT:
	        add_unwind_entry (output_unat_when ());
	        add_unwind_entry ((psprel
				   ? output_unat_psprel
				   : output_unat_sprel) (val));
		break;
	      case REG_AR + AR_FPSR:
	        add_unwind_entry (output_fpsr_when ());
	        add_unwind_entry ((psprel
				   ? output_fpsr_psprel
				   : output_fpsr_sprel) (val));
		break;
	      case REG_AR + AR_PFS:
	        add_unwind_entry (output_pfs_when ());
	        add_unwind_entry ((psprel
				   ? output_pfs_psprel
				   : output_pfs_sprel) (val));
		break;
	      case REG_AR + AR_LC:
	        add_unwind_entry (output_lc_when ());
	        add_unwind_entry ((psprel
				   ? output_lc_psprel
				   : output_lc_sprel) (val));
		break;
	      case REG_BR:
		add_unwind_entry (output_rp_when ());
		add_unwind_entry ((psprel
				   ? output_rp_psprel
				   : output_rp_sprel) (val));
		break;
	      case REG_PR:
		add_unwind_entry (output_preds_when ());
		add_unwind_entry ((psprel
				   ? output_preds_psprel
				   : output_preds_sprel) (val));
		break;
	      case REG_PRIUNAT:
		add_unwind_entry (output_priunat_when_mem ());
		add_unwind_entry ((psprel
				   ? output_priunat_psprel
				   : output_priunat_sprel) (val));
		break;
	      default:
	        as_bad ("First operand not a valid register");
d3147 1
a3147 1
        {
d3149 1
a3149 1
	  if (e2.X_op == O_register && reg >=0 && reg < 128)
d3495 1
a3495 1
     function symbols: */
d3504 1
a3504 1
        {
d3547 1
a3547 1
	      ignore_rest_of_line ();
d3550 1
a3550 1
        {
d3686 1
a3686 1
  /* first, remove existing names from hash table: */
d3838 1
a3838 1
static char*
d3882 1
d3973 1
d3976 1
a3976 1
  int dummy;
d3995 2
a3996 2
      if (regno < REG_GR || regno > REG_GR+128)
        as_warn (_("Register value annotation ignored"));
d3998 5
a4002 5
        {
          gr_values[regno-REG_GR].known = 1;
          gr_values[regno-REG_GR].value = value;
          gr_values[regno-REG_GR].path = md.path;
        }
d4014 1
d4017 1
a4017 1
  int type;
d4033 1
a4033 1
        insn_group_break (1, 0, 0);
d4039 1
a4039 1
        insn_group_break (1, 0, 0);
d4045 1
a4045 1
        insn_group_break (1, 0, 0);
d4054 1
a4054 1
  valueT mask;
d4058 1
a4058 1
  for (regno = 0;regno < 64;regno++)
d4060 5
a4064 5
      if (mask & ((valueT) 1<<regno))
        {
          fprintf (stderr, "%s p%d", comma, regno);
          comma = ",";
        }
d4074 1
d4077 1
a4077 1
  int type;
d4086 22
a4107 22
        {
          as_bad (_("Missing predicate relation type"));
          ignore_rest_of_line ();
          return;
        }
      else
        {
          int len;
          char *form = demand_copy_C_string (&len);
          if (strcmp (form, "mutex") == 0)
            type = 'm';
          else if (strcmp (form, "clear") == 0)
            type = 'c';
          else if (strcmp (form, "imply") == 0)
            type = 'i';
          else
            {
              as_bad (_("Unrecognized predicate relation type"));
              ignore_rest_of_line ();
              return;
            }
        }
d4109 1
a4109 1
        ++input_line_pointer;
d4120 7
a4126 7
          || (regno = atoi (++input_line_pointer)) < 0
          || regno > 63)
        {
          as_bad (_("Predicate register expected"));
          ignore_rest_of_line ();
          return;
        }
d4128 1
a4128 1
        ++input_line_pointer;
d4130 1
a4130 1
        p1 = regno;
d4132 1
a4132 1
        p2 = regno;
d4135 4
a4138 3
        as_warn (_("Duplicate predicate register ignored"));
      mask |= bit; count++;
      /* see if it's a range */
d4140 29
a4168 28
        {
          valueT stop = 1;
          ++input_line_pointer;

          if (toupper (*input_line_pointer) != 'P'
              || (regno = atoi (++input_line_pointer)) < 0
              || regno > 63)
            {
              as_bad (_("Predicate register expected"));
              ignore_rest_of_line ();
              return;
            }
          while (isdigit (*input_line_pointer))
            ++input_line_pointer;
          stop <<= regno;
          if (bit >= stop)
            {
              as_bad (_("Bad register range"));
              ignore_rest_of_line ();
              return;
            }
          while (bit < stop)
            {
              bit <<= 1;
              mask |= bit; count++;
            }
          SKIP_WHITESPACE ();
        }
d4170 1
a4170 1
        break;
d4179 1
a4179 1
        mask = ~(valueT) 0;
d4185 1
a4185 1
        as_bad (_("Predicate source and target required"));
d4187 1
a4187 1
        as_bad (_("Use of p0 is not valid in this context"));
d4189 1
a4189 1
        add_qp_imply (p1, p2);
d4193 4
a4196 4
        {
          as_bad (_("At least two PR arguments expected"));
          break;
        }
d4198 4
a4201 4
        {
          as_bad (_("Use of p0 is not valid in this context"));
          break;
        }
d4207 4
a4210 4
        {
          as_bad (_("At least one PR argument expected"));
          break;
        }
d4212 5
a4216 5
        {
          fprintf (stderr, "Safe across calls: ");
          print_prmask (mask);
          fprintf (stderr, "\n");
        }
d4225 2
a4226 2
   Otherwise, only global labels are considered entry points.
 */
d4229 1
a4229 1
  int dummy;
d4244 2
a4245 2
        as_fatal (_("Inserting \"%s\" into entry hint table failed: %s"),
                    name, err);
d4264 2
a4265 2
   "base" is used to distinguish between offsets from a different base.
 */
d4283 1
a4283 1
/* ia64-specific pseudo-ops: */
d4369 1
a4369 1
    /* unaligned versions: */
d4412 1
a4412 1
    /* unaligned versions: */
d4423 2
a4424 1
static symbolS*
d4486 1
a4486 1
      /* constants: */
d4548 1
a4548 1
      /* register operands: */
d4599 1
a4599 1
      /* indirect operands: */
d4621 1
a4621 1
      /* immediate operands: */
d4657 1
a4657 1
        {
d4659 2
a4660 2
            return 1;
        }
d4662 4
a4665 4
        {
          /* FIXME -- need 62-bit relocation type */
          as_bad (_("62-bit relocation not yet implemented"));
        }
d4715 6
a4720 6
        {
          int lobits = e->X_add_number & 0x3;
          if (((bfd_vma) e->X_add_number & 0x3C) != 0 && lobits == 0)
            e->X_add_number |= (bfd_vma) 0x3;
          return 1;
        }
d4726 1
a4726 1
        as_warn (_("lower 16 bits of mask ignored"));
d4733 9
a4741 9
        {
          /* sign-extend */
          if (e->X_add_number >= 0
              && (e->X_add_number & ((bfd_vma) 1 << 43)) != 0)
            {
              e->X_add_number |= ~(((bfd_vma) 1 << 44) - 1);
            }
          return 1;
        }
d4751 9
a4759 9
        {
          /* sign-extend */
          if (e->X_add_number >= 0
              && (e->X_add_number & ((bfd_vma) 1 << 16)) != 0)
            {
              e->X_add_number |= ~(((bfd_vma) 1 << 17) - 1);
            }
          return 1;
        }
d4887 1
a4887 1
          else if (opnd == IA64_OPND_TGT64)
d4965 2
a4966 1
static struct ia64_opcode*
d5038 1
a5038 1
	  /* now we can parse the first arg: */
d5132 5
a5136 5
          val &= 0x3fffffffffffffffULL;
          if (val != slot->opnd[i].X_add_number)
            as_warn (_("Value truncated to 62 bits"));
          *insnp++ = (val >> 21) & 0x1ffffffffffLL;
          insn |= (((val & 0xfffff) << 6) | (((val >> 20) & 0x1) << 36));
d5226 1
a5226 1
  bfd_vma insn[3] = {-1, -1, -1};
d5243 1
a5243 1
     otherwise: */
d5262 1
a5262 1
  /* initialize instructions with appropriate nops: */
d5268 1
a5268 1
  /* now fill in slots with as many insns as possible: */
d5276 1
a5276 1
	 instruction has been issued: */
d5409 1
a5409 1
      /* resolve dynamic opcodes such as "break" and "nop": */
d5441 1
a5441 1
            case IA64_TYPE_X: insn_unit = IA64_UNIT_L; break;
d5453 1
a5453 1
              && insn_unit == IA64_UNIT_I
d5465 1
a5465 1
		  /* drop this insn so we don't livelock: */
d5477 1
a5477 1
	  addr = frag_now->fr_address + frag_now_fix () - 16 + 1*i;
d5499 1
a5499 1
      /* now is a good time to fix up the labels for this insn: */
d5519 1
a5519 1
      /* clear slot: */
d5585 1
a5585 1
          /* Suppress signon message.  */
d5623 5
a5627 5
        {
          /* set default mode to explicit */
          md.default_explicit_mode = 1;
          break;
        }
d5629 3
a5631 3
        {
          md.default_explicit_mode = 0;
        }
d5633 3
a5635 3
        {
          md.debug_dv = 1;
        }
d5637 8
a5644 8
        {
          md.default_explicit_mode = 1;
          md.debug_dv = 1;
        }
      else
        {
          as_bad (_("Unrecognized option '-x%s'"), arg);
        }
d5671 1
a5671 1
  fputs(_("\
d5736 2
a5737 2
      symbol_new (".<fptr>", undefined_section, FUNC_FPTR_RELATIVE,
		  &zero_address_frag);
d5740 2
a5741 2
      symbol_new (".<gprel>", undefined_section, FUNC_GP_RELATIVE,
		  &zero_address_frag);
d5744 2
a5745 2
      symbol_new (".<ltoff>", undefined_section, FUNC_LT_RELATIVE,
		  &zero_address_frag);
d5748 2
a5749 2
      symbol_new (".<pcrel>", undefined_section, FUNC_PC_RELATIVE,
		  &zero_address_frag);
d5752 2
a5753 2
      symbol_new (".<pltoff>", undefined_section, FUNC_PLT_RELATIVE,
		  &zero_address_frag);
d5756 2
a5757 2
      symbol_new (".<secrel>", undefined_section, FUNC_SEC_RELATIVE,
		  &zero_address_frag);
d5760 2
a5761 2
      symbol_new (".<segrel>", undefined_section, FUNC_SEG_RELATIVE,
		  &zero_address_frag);
d5764 2
a5765 2
      symbol_new (".<ltv>", undefined_section, FUNC_LTV_RELATIVE,
		  &zero_address_frag);
d5768 2
a5769 2
      symbol_new (".<ltoff.fptr>", undefined_section, FUNC_LT_FPTR_RELATIVE,
		  &zero_address_frag);
d5838 1
a5838 1
  /* general registers: */
d5847 1
a5847 1
  /* floating point registers: */
d5855 1
a5855 1
  /* application registers: */
d5864 1
a5864 1
  /* control registers: */
d5873 1
a5873 1
  /* predicate registers: */
d5881 1
a5881 1
  /* branch registers: */
d5903 1
a5903 1
  /* define synonyms for application registers: */
d5908 1
a5908 1
  /* define synonyms for control registers: */
d5917 1
a5917 1
  /* pseudo-registers used to specify unwind info: */
d5946 1
a5946 1
  /* terminate insn group upon reaching end of file: */
d5949 1
a5949 1
  /* emits slots we haven't written yet: */
d5971 1
a5971 1
        as_warn (_("Explicit stops are ignored in auto mode"));
d5973 1
a5973 1
        insn_group_break (1, 0, 0);
d6009 2
a6010 2
      /* bundling is only acceptable in explicit mode
         or when in default automatic mode */
d6012 7
a6018 7
        {
          if (!md.mode_explicitly_set
              && !md.default_explicit_mode)
            dot_dv_mode ('E');
          else
            as_warn (_("Found '{' after explicit switch to automatic mode"));
        }
d6030 4
a6033 4
          && md.explicit_mode
          && !md.mode_explicitly_set
          && !md.default_explicit_mode)
        dot_dv_mode ('A');
d6050 3
a6052 1
  return 0;	/* not a valid line */
d6069 1
a6069 1
      /* keep track of how many code entry points we've seen */
d6071 6
a6076 5
        {
          md.maxpaths += 20;
          md.entry_labels = (const char **)
            xrealloc ((void *)md.entry_labels, md.maxpaths * sizeof (char *));
        }
d6149 1
a6149 1
  /* first see if NAME is a known register name: */
d6166 1
a6166 1
  /* check for inN, locN, or outN: */
d6199 1
a6199 1
      /* the name is inN, locN, or outN; parse the register number: */
d6208 2
a6209 1
		as_bad ("Register number out of range 0..%u", dr->num_regs-1);
d6221 3
a6223 3
         Store the base register number in the low 16 bits of
         X_add_number and the size of the register set in the top 16
         bits.  */
d6237 3
a6239 3
  size_t len = strlen(name);
  if (len > 1 && name[len-1] == '#')
    name[len-1] = '\0';
d6245 1
a6245 1
  struct ia64_opcode *idesc;
d6248 8
a6255 8
          && (strcmp (idesc->name, "br") == 0
              || strncmp (idesc->name, "br.cond", 7) == 0
              || strncmp (idesc->name, "br.call", 7) == 0
              || strncmp (idesc->name, "br.ret", 6) == 0
              || strcmp (idesc->name, "brl") == 0
              || strncmp (idesc->name, "brl.cond", 7) == 0
              || strncmp (idesc->name, "brl.call", 7) == 0
              || strncmp (idesc->name, "brl.ret", 6) == 0));
d6259 2
a6260 1
   returns zero */
d6263 1
a6263 1
  struct ia64_opcode *idesc;
d6266 1
a6266 1
          || strncmp (idesc->name, "br.ia", 5) == 0);
d6270 2
a6271 1
   doubt, returns zero */
d6274 1
a6274 1
  struct ia64_opcode *idesc;
d6283 1
d6286 2
a6287 2
  int depind;
  struct ia64_opcode *idesc;
d6291 1
a6291 1
  for (i = 0;i < dep->nchks; i++)
d6293 2
a6294 2
      if (depind == DEP(dep->chks[i]))
        return i;
a6342 1

d6351 6
a6356 6
  const struct ia64_dependency *dep;
  struct ia64_opcode *idesc;
  int type;                         /* is this a DV chk or a DV reg? */
  struct rsrc specs[MAX_SPECS];     /* returned specific resources */
  int note;                         /* resource note for this insn's usage */
  int path;                         /* which execution path to examine */
d6391 11
a6401 11
        {
          if (idesc->operands[!rsrc_write] == IA64_OPND_AR3)
            {
              int regno = CURR_SLOT.opnd[!rsrc_write].X_add_number - REG_AR;
              if (regno >= 0 && regno <= 7)
                {
                  specs[count] = tmpl;
                  specs[count++].index = regno;
                }
            }
        }
d6403 11
a6413 11
        {
          for(i=0;i < 8;i++)
            {
              specs[count] = tmpl;
              specs[count++].index = i;
            }
        }
      else
        {
          UNHANDLED;
        }
d6438 4
a6441 4
              if (md.debug_dv)
                fprintf (stderr, "  Using hint for spill/fill\n");
	      /* the index isn't actually used, just set it to something
		 approximating the bit index */
d6456 19
a6474 19
        {
          if (idesc->operands[!rsrc_write] == IA64_OPND_AR3)
            {
              int regno = CURR_SLOT.opnd[!rsrc_write].X_add_number - REG_AR;
              if ((regno >= 8 && regno <= 15)
                  || (regno >= 20 && regno <= 23)
                  || (regno >= 31 && regno <= 39)
                  || (regno >= 41 && regno <= 47)
                  || (regno >= 67 && regno <= 111))
                {
                  specs[count] = tmpl;
                  specs[count++].index = regno;
                }
            }
        }
      else
        {
          UNHANDLED;
        }
d6479 12
a6490 12
        {
          if (idesc->operands[!rsrc_write] == IA64_OPND_AR3)
            {
              int regno = CURR_SLOT.opnd[!rsrc_write].X_add_number - REG_AR;
              if ((regno >= 48 && regno <= 63)
                  || (regno >= 112 && regno <= 127))
                {
                  specs[count] = tmpl;
                  specs[count++].index = regno;
                }
            }
        }
d6492 16
a6507 16
        {
          for (i=48;i < 64;i++)
            {
              specs[count] = tmpl;
              specs[count++].index = i;
            }
          for (i=112;i < 128;i++)
            {
              specs[count] = tmpl;
              specs[count++].index = i;
            }
        }
      else
        {
          UNHANDLED;
        }
d6512 28
a6539 28
        {
          UNHANDLED;
        }
      else
        {
          if (rsrc_write)
            {
              for (i=0;i < idesc->num_outputs;i++)
                if (idesc->operands[i] == IA64_OPND_B1
                    || idesc->operands[i] == IA64_OPND_B2)
                  {
                    specs[count] = tmpl;
                    specs[count++].index =
                      CURR_SLOT.opnd[i].X_add_number - REG_BR;
                  }
            }
          else
            {
              for (i = idesc->num_outputs;i < NELEMS(idesc->operands);i++)
                if (idesc->operands[i] == IA64_OPND_B1
                    || idesc->operands[i] == IA64_OPND_B2)
                  {
                    specs[count] = tmpl;
                    specs[count++].index =
                      CURR_SLOT.opnd[i].X_add_number - REG_BR;
                  }
            }
        }
d6544 21
a6564 21
        {
          if (idesc->operands[!rsrc_write] == IA64_OPND_CPUID_R3)
            {
              int regno = CURR_SLOT.opnd[!rsrc_write].X_add_number - REG_GR;
              if (regno >= 0 && regno < NELEMS(gr_values)
                  && KNOWN(regno))
                {
                  specs[count] = tmpl;
                  specs[count++].index = gr_values[regno].value & 0xFF;
                }
              else
                {
                  specs[count] = tmpl;
                  specs[count++].specific = 0;
                }
            }
        }
      else
        {
          UNHANDLED;
        }
d6569 17
a6585 17
        {
          if (idesc->operands[!rsrc_write] == IA64_OPND_DBR_R3)
            {
              int regno = CURR_SLOT.opnd[!rsrc_write].X_add_number - REG_GR;
              if (regno >= 0 && regno < NELEMS(gr_values)
                  && KNOWN(regno))
                {
                  specs[count] = tmpl;
                  specs[count++].index = gr_values[regno].value & 0xFF;
                }
              else
                {
                  specs[count] = tmpl;
                  specs[count++].specific = 0;
                }
            }
        }
d6587 8
a6594 8
        {
          specs[count] = tmpl;
          specs[count++].specific = 0;
        }
      else
        {
          UNHANDLED;
        }
d6599 21
a6619 21
        {
          if (idesc->operands[!rsrc_write] == IA64_OPND_IBR_R3)
            {
              int regno = CURR_SLOT.opnd[!rsrc_write].X_add_number - REG_GR;
              if (regno >= 0 && regno < NELEMS(gr_values)
                  && KNOWN(regno))
                {
                  specs[count] = tmpl;
                  specs[count++].index = gr_values[regno].value & 0xFF;
                }
              else
                {
                  specs[count] = tmpl;
                  specs[count++].specific = 0;
                }
            }
        }
      else
        {
          UNHANDLED;
        }
d6638 30
a6667 29
        {
          if (idesc->operands[!rsrc_write] == IA64_OPND_PKR_R3)
            {
              int regno = CURR_SLOT.opnd[!rsrc_write].X_add_number - REG_GR;
              if (regno >= 0 && regno < NELEMS(gr_values)
                  && KNOWN(regno))
                {
                  if (note == 3)
                    {
                      specs[count] = tmpl;
                      specs[count++].index = gr_values[regno].value & 0xFF;
                    }
                  else for (i=0;i < NELEMS(gr_values);i++)
                    {
                      /* uses all registers *except* the one in R3 */
                      if (i != (gr_values[regno].value & 0xFF))
                        {
                          specs[count] = tmpl;
                          specs[count++].index = i;
                        }
                    }
                }
              else
                {
                  specs[count] = tmpl;
                  specs[count++].specific = 0;
                }
            }
        }
d6669 5
a6673 5
        {
          /* probe et al.  */
          specs[count] = tmpl;
          specs[count++].specific = 0;
        }
d6678 25
a6702 25
        {
          if (idesc->operands[!rsrc_write] == IA64_OPND_PMC_R3
              || (!rsrc_write && idesc->operands[1] == IA64_OPND_PMD_R3))

            {
              int index = ((idesc->operands[1] == IA64_OPND_R3 && !rsrc_write)
                           ? 1 : !rsrc_write);
              int regno = CURR_SLOT.opnd[index].X_add_number - REG_GR;
              if (regno >= 0 && regno < NELEMS(gr_values)
                  && KNOWN(regno))
                {
                  specs[count] = tmpl;
                  specs[count++].index = gr_values[regno].value & 0xFF;
                }
              else
                {
                  specs[count] = tmpl;
                  specs[count++].specific = 0;
                }
            }
        }
      else
        {
          UNHANDLED;
        }
d6707 21
a6727 21
        {
          if (idesc->operands[!rsrc_write] == IA64_OPND_PMD_R3)
            {
              int regno = CURR_SLOT.opnd[!rsrc_write].X_add_number - REG_GR;
              if (regno >= 0 && regno < NELEMS(gr_values)
                  && KNOWN(regno))
                {
                  specs[count] = tmpl;
                  specs[count++].index = gr_values[regno].value & 0xFF;
                }
              else
                {
                  specs[count] = tmpl;
                  specs[count++].specific = 0;
                }
            }
        }
      else
        {
          UNHANDLED;
        }
d6732 17
a6748 17
        {
          if (idesc->operands[!rsrc_write] == IA64_OPND_RR_R3)
            {
              int regno = CURR_SLOT.opnd[!rsrc_write].X_add_number - REG_GR;
              if (regno >= 0 && regno < NELEMS(gr_values)
                  && KNOWN(regno))
                {
                  specs[count] = tmpl;
                  specs[count++].index = (gr_values[regno].value >> 61) & 0x7;
                }
              else
                {
                  specs[count] = tmpl;
                  specs[count++].specific = 0;
                }
            }
        }
d6750 8
a6757 8
        {
          specs[count] = tmpl;
          specs[count++].specific = 0;
        }
      else
        {
          UNHANDLED;
        }
d6762 14
a6775 14
        {
          /* handle mov-from-CR-IVR; it's a read that writes CR[IRR] */
          int regno = CURR_SLOT.opnd[1].X_add_number - REG_CR;
          if (rsrc_write
              && idesc->operands[1] == IA64_OPND_CR3
              && regno == CR_IVR)
            {
              for(i=0;i < 4;i++)
                {
                  specs[count] = tmpl;
                  specs[count++].index = CR_IRR0 + i;
                }
            }
        }
d6777 14
a6790 14
        {
          int regno = CURR_SLOT.opnd[!rsrc_write].X_add_number - REG_CR;
          if (idesc->operands[!rsrc_write] == IA64_OPND_CR3
              && regno >= CR_IRR0
              && regno <= CR_IRR3)
            {
              specs[count] = tmpl;
              specs[count++].index = regno;
            }
        }
      else
        {
          UNHANDLED;
        }
d6795 13
a6807 13
        {
          UNHANDLED;
        }
      else
        {
          int regno = CURR_SLOT.opnd[!rsrc_write].X_add_number - REG_CR;
          if (idesc->operands[!rsrc_write] == IA64_OPND_CR3
              && (regno == CR_LRR0 || regno == CR_LRR1))
            {
              specs[count] = tmpl;
              specs[count++].index = regno;
            }
        }
d6812 12
a6823 12
        {
          if (idesc->operands[!rsrc_write] == IA64_OPND_CR3)
            {
              specs[count] = tmpl;
              specs[count++].index =
                CURR_SLOT.opnd[!rsrc_write].X_add_number - REG_CR;
            }
        }
      else
        {
          UNHANDLED;
        }
d6829 3
a6831 3
        {
          UNHANDLED;
        }
d6833 22
a6854 22
        {
          if (dep->specifier == IA64_RS_FRb
              && idesc->operands[0] == IA64_OPND_F1)
            {
              specs[count] = tmpl;
              specs[count++].index = CURR_SLOT.opnd[0].X_add_number - REG_FR;
            }
        }
      else
        {
          for (i=idesc->num_outputs;i < NELEMS(idesc->operands);i++)
            {
              if (idesc->operands[i] == IA64_OPND_F2
                  || idesc->operands[i] == IA64_OPND_F3
                  || idesc->operands[i] == IA64_OPND_F4)
                {
                  specs[count] = tmpl;
                  specs[count++].index =
                    CURR_SLOT.opnd[i].X_add_number - REG_FR;
                }
            }
        }
d6859 6
a6864 6
        {
          /* This reference applies only to the GR whose value is loaded with
             data returned from memory */
          specs[count] = tmpl;
          specs[count++].index = CURR_SLOT.opnd[0].X_add_number - REG_GR;
        }
d6866 4
a6869 4
        {
          if (rsrc_write)
            {
              for (i= 0; i < idesc->num_outputs; i++)
d6886 10
a6895 10
            }
          else
            {
              /* Look for anything that reads a GR */
              for (i=0;i < NELEMS(idesc->operands);i++)
                {
                  if (idesc->operands[i] == IA64_OPND_MR3
                      || idesc->operands[i] == IA64_OPND_CPUID_R3
                      || idesc->operands[i] == IA64_OPND_DBR_R3
                      || idesc->operands[i] == IA64_OPND_IBR_R3
d6897 8
a6904 8
                      || idesc->operands[i] == IA64_OPND_PKR_R3
                      || idesc->operands[i] == IA64_OPND_PMC_R3
                      || idesc->operands[i] == IA64_OPND_PMD_R3
                      || idesc->operands[i] == IA64_OPND_RR_R3
                      || ((i >= idesc->num_outputs)
                          && (idesc->operands[i] == IA64_OPND_R1
                              || idesc->operands[i] == IA64_OPND_R2
                              || idesc->operands[i] == IA64_OPND_R3
d6907 12
a6918 12
                    {
                      specs[count] = tmpl;
                      specs[count++].index =
                        CURR_SLOT.opnd[i].X_add_number - REG_GR;
                    }
                }
            }
        }
      else
        {
          UNHANDLED;
        }
d6923 18
a6940 18
        {
          if (idesc->operands[0] == IA64_OPND_PR_ROT)
            {
              for (i=16;i < 63;i++)
                {
                  specs[count] = tmpl;
                  specs[count++].index = i;
                }
            }
          else
            {
              for (i=1;i < 63;i++)
                {
                  specs[count] = tmpl;
                  specs[count++].index = i;
                }
            }
        }
d6942 32
a6973 32
        {
          valueT mask = 0;
          /* mark only those registers indicated by the mask */
          if (rsrc_write
              && idesc->operands[0] == IA64_OPND_PR)
            {
              mask = CURR_SLOT.opnd[2].X_add_number;
              if (mask & ((valueT) 1<<16))
                mask |= ~(valueT) 0xffff;
              for (i=1;i < 63;i++)
                {
                  if (mask & ((valueT) 1<<i))
                    {
                      specs[count] = tmpl;
                      specs[count++].index = i;
                    }
                }
            }
          else if (rsrc_write
                   && idesc->operands[0] == IA64_OPND_PR_ROT)
            {
              for (i=16;i < 63;i++)
                {
                  specs[count] = tmpl;
                  specs[count++].index = i;
                }
            }
          else
            {
              UNHANDLED;
            }
        }
d6975 22
a6996 22
        {
          if (rsrc_write)
            {
              for (i=0;i < idesc->num_outputs;i++)
                {
                  if (idesc->operands[i] == IA64_OPND_P1
                      || idesc->operands[i] == IA64_OPND_P2)
                    {
                      int regno = CURR_SLOT.opnd[i].X_add_number - REG_P;
                      if (regno != 0)
                        {
                          specs[count] = tmpl;
                          specs[count++].index = regno;
                        }
                    }
                }
            }
          else
            {
              UNHANDLED;
            }
        }
d6998 7
a7004 7
        {
          if (CURR_SLOT.qp_regno != 0)
            {
              specs[count] = tmpl;
              specs[count++].index = CURR_SLOT.qp_regno;
            }
        }
d7006 41
a7046 41
        {
          if (rsrc_write)
            {
              int p1 = CURR_SLOT.opnd[0].X_add_number - REG_P;
              int p2 = CURR_SLOT.opnd[1].X_add_number - REG_P;
              if ((idesc->operands[0] == IA64_OPND_P1
                   || idesc->operands[0] == IA64_OPND_P2)
                  && p1 != 0 && p1 != 63)
                {
                  specs[count] = tmpl;
                  specs[count++].index = p1;
                }
              if ((idesc->operands[1] == IA64_OPND_P1
                   || idesc->operands[1] == IA64_OPND_P2)
                  && p2 != 0 && p2 != 63)
                {
                  specs[count] = tmpl;
                  specs[count++].index = p2;
                }
            }
          else
            {
              if (CURR_SLOT.qp_regno != 0)
                {
                  specs[count] = tmpl;
                  specs[count++].index = CURR_SLOT.qp_regno;
                }
              if (idesc->operands[1] == IA64_OPND_PR)
                {
                  for (i=1;i < 63;i++)
                    {
                      specs[count] = tmpl;
                      specs[count++].index = i;
                    }
                }
            }
        }
      else
        {
          UNHANDLED;
        }
d7051 1
a7051 1
         dep->regindex */
d7053 108
a7160 108
        {
          if (idesc->operands[!rsrc_write] == IA64_OPND_PSR_UM)
            {
              if (dep->regindex < 6)
                {
                  specs[count++] = tmpl;
                }
            }
          else if (idesc->operands[!rsrc_write] == IA64_OPND_PSR)
            {
              if (dep->regindex < 32
                  || dep->regindex == 35
                  || dep->regindex == 36
                  || (!rsrc_write && dep->regindex == PSR_CPL))
                {
                  specs[count++] = tmpl;
                }
            }
          else if (idesc->operands[!rsrc_write] == IA64_OPND_PSR_L)
            {
              if (dep->regindex < 32
                  || dep->regindex == 35
                  || dep->regindex == 36
                  || (rsrc_write && dep->regindex == PSR_CPL))
                {
                  specs[count++] = tmpl;
                }
            }
          else
            {
              /* Several PSR bits have very specific dependencies.  */
              switch (dep->regindex)
                {
                default:
                  specs[count++] = tmpl;
                  break;
                case PSR_IC:
                  if (rsrc_write)
                    {
                      specs[count++] = tmpl;
                    }
                  else
                    {
                      /* Only certain CR accesses use PSR.ic */
                      if (idesc->operands[0] == IA64_OPND_CR3
                          || idesc->operands[1] == IA64_OPND_CR3)
                        {
                          int index =
                            ((idesc->operands[0] == IA64_OPND_CR3)
                             ? 0 : 1);
                          int regno =
                            CURR_SLOT.opnd[index].X_add_number - REG_CR;

                          switch (regno)
                            {
                            default:
                              break;
                            case CR_ITIR:
                            case CR_IFS:
                            case CR_IIM:
                            case CR_IIP:
                            case CR_IPSR:
                            case CR_ISR:
                            case CR_IFA:
                            case CR_IHA:
                            case CR_IIPA:
                              specs[count++] = tmpl;
                              break;
                            }
                        }
                    }
                  break;
                case PSR_CPL:
                  if (rsrc_write)
                    {
                      specs[count++] = tmpl;
                    }
                  else
                    {
                      /* Only some AR accesses use cpl */
                      if (idesc->operands[0] == IA64_OPND_AR3
                          || idesc->operands[1] == IA64_OPND_AR3)
                        {
                          int index =
                            ((idesc->operands[0] == IA64_OPND_AR3)
                             ? 0 : 1);
                          int regno =
                            CURR_SLOT.opnd[index].X_add_number - REG_AR;

                          if (regno == AR_ITC
                              || (index == 0
                                  && (regno == AR_ITC
                                      || regno == AR_RSC
                                      || (regno >= AR_K0
                                          && regno <= AR_K7))))
                            {
                              specs[count++] = tmpl;
                            }
                        }
                      else
                        {
                          specs[count++] = tmpl;
                        }
                      break;
                    }
                }
            }
        }
d7162 15
a7176 15
        {
          valueT mask = 0;
          if (idesc->operands[0] == IA64_OPND_IMMU24)
            {
              mask = CURR_SLOT.opnd[0].X_add_number;
            }
          else
            {
              UNHANDLED;
            }
          if (mask & ((valueT) 1<<dep->regindex))
            {
              specs[count++] = tmpl;
            }
        }
d7178 19
a7196 19
        {
          int min = dep->regindex == PSR_DFL ? 2 : 32;
          int max = dep->regindex == PSR_DFL ? 31 : 127;
          /* dfh is read on FR32-127; dfl is read on FR2-31 */
          for (i=0;i < NELEMS(idesc->operands);i++)
            {
              if (idesc->operands[i] == IA64_OPND_F1
                  || idesc->operands[i] == IA64_OPND_F2
                  || idesc->operands[i] == IA64_OPND_F3
                  || idesc->operands[i] == IA64_OPND_F4)
                {
                  int reg = CURR_SLOT.opnd[i].X_add_number - REG_FR;
                  if (reg >= min && reg <= max)
                    {
                      specs[count++] = tmpl;
                    }
                }
            }
        }
d7198 17
a7214 17
        {
          int min = dep->regindex == PSR_MFL ? 2 : 32;
          int max = dep->regindex == PSR_MFL ? 31 : 127;
          /* mfh is read on writes to FR32-127; mfl is read on writes to
             FR2-31 */
          for (i=0;i < idesc->num_outputs;i++)
            {
              if (idesc->operands[i] == IA64_OPND_F1)
                {
                  int reg = CURR_SLOT.opnd[i].X_add_number - REG_FR;
                  if (reg >= min && reg <= max)
                    {
                      specs[count++] = tmpl;
                    }
                }
            }
        }
d7216 19
a7234 19
        {
          for (i=0;i < NELEMS(idesc->operands);i++)
            {
              if (idesc->operands[i] == IA64_OPND_R1
                  || idesc->operands[i] == IA64_OPND_R2
                  || idesc->operands[i] == IA64_OPND_R3)
                {
                  int regno = CURR_SLOT.opnd[i].X_add_number - REG_GR;
                  if (regno >= 16 && regno <= 31)
                    {
                      specs[count++] = tmpl;
                    }
                }
            }
        }
      else
        {
          UNHANDLED;
        }
d7239 11
a7249 11
        {
          int regno = CURR_SLOT.opnd[!rsrc_write].X_add_number - REG_AR;
          if (regno == AR_FPSR)
            {
              specs[count++] = tmpl;
            }
        }
      else
        {
          specs[count++] = tmpl;
        }
d7255 57
a7311 57
        {
          int regno = CURR_SLOT.opnd[!rsrc_write].X_add_number - REG_AR;
          if (idesc->operands[!rsrc_write] == IA64_OPND_AR3
              && regno == dep->regindex)
            {
              specs[count++] = tmpl;
            }
          /* other AR[REG] resources may be affected by AR accesses */
          else if (idesc->operands[0] == IA64_OPND_AR3)
            {
              /* AR[] writes */
              regno = CURR_SLOT.opnd[0].X_add_number - REG_AR;
              switch (dep->regindex)
                {
                default:
                  break;
                case AR_BSP:
                case AR_RNAT:
                  if (regno == AR_BSPSTORE)
                    {
                      specs[count++] = tmpl;
                    }
                case AR_RSC:
                  if (!rsrc_write &&
                      (regno == AR_BSPSTORE
                       || regno == AR_RNAT))
                    {
                      specs[count++] = tmpl;
                    }
                  break;
                }
            }
          else if (idesc->operands[1] == IA64_OPND_AR3)
            {
              /* AR[] reads */
              regno = CURR_SLOT.opnd[1].X_add_number - REG_AR;
              switch (dep->regindex)
                {
                default:
                  break;
                case AR_RSC:
                  if (regno == AR_BSPSTORE || regno == AR_RNAT)
                    {
                      specs[count++] = tmpl;
                    }
                  break;
                }
            }
          else
            {
              specs[count++] = tmpl;
            }
        }
      else
        {
          UNHANDLED;
        }
d7317 31
a7347 31
        {
          if (idesc->operands[!rsrc_write] == IA64_OPND_CR3)
            {
              int regno = CURR_SLOT.opnd[!rsrc_write].X_add_number - REG_CR;
              if (regno == dep->regindex)
                {
                  specs[count++] = tmpl;
                }
              else if (!rsrc_write)
                {
                  /* Reads from CR[IVR] affect other resources.  */
                  if (regno == CR_IVR)
                    {
                      if ((dep->regindex >= CR_IRR0
                           && dep->regindex <= CR_IRR3)
                          || dep->regindex == CR_TPR)
                        {
                          specs[count++] = tmpl;
                        }
                    }
                }
            }
          else
            {
              specs[count++] = tmpl;
            }
        }
      else
        {
          UNHANDLED;
        }
d7353 6
a7358 6
           && CURR_SLOT.opnd[0].X_add_number - REG_CR == CR_EOI)
          || (idesc->operands[1] == IA64_OPND_CR3
              && CURR_SLOT.opnd[1].X_add_number - REG_CR == CR_IVR))
        {
          specs[count++] = tmpl;
        }
d7361 9
a7369 9
    case IA64_RS_GR0:
      if (note == 1)
        {
          specs[count++] = tmpl;
        }
      else
        {
          UNHANDLED;
        }
d7374 53
a7426 53
        {
          specs[count++] = tmpl;
        }
      else
        {
          /* Check if any of the registers accessed are in the rotating region.
             mov to/from pr accesses CFM only when qp_regno is in the rotating
             region */
          for (i=0;i < NELEMS(idesc->operands);i++)
            {
              if (idesc->operands[i] == IA64_OPND_R1
                  || idesc->operands[i] == IA64_OPND_R2
                  || idesc->operands[i] == IA64_OPND_R3)
                {
                  int num = CURR_SLOT.opnd[i].X_add_number - REG_GR;
                  /* Assumes that md.rot.num_regs is always valid */
                  if (md.rot.num_regs > 0
                      && num > 31
                      && num < 31 + md.rot.num_regs)
                    {
                      specs[count] = tmpl;
                      specs[count++].specific = 0;
                    }
                }
              else if (idesc->operands[i] == IA64_OPND_F1
                       || idesc->operands[i] == IA64_OPND_F2
                       || idesc->operands[i] == IA64_OPND_F3
                       || idesc->operands[i] == IA64_OPND_F4)
                {
                  int num = CURR_SLOT.opnd[i].X_add_number - REG_FR;
                  if (num > 31)
                    {
                      specs[count] = tmpl;
                      specs[count++].specific = 0;
                    }
                }
              else if (idesc->operands[i] == IA64_OPND_P1
                       || idesc->operands[i] == IA64_OPND_P2)
                {
                  int num = CURR_SLOT.opnd[i].X_add_number - REG_P;
                  if (num > 15)
                    {
                      specs[count] = tmpl;
                      specs[count++].specific = 0;
                    }
                }
            }
          if (CURR_SLOT.qp_regno > 15)
            {
              specs[count] = tmpl;
              specs[count++].specific = 0;
            }
        }
d7431 3
a7433 3
        {
          specs[count++] = tmpl;
        }
d7435 9
a7443 9
        {
          if ((idesc->operands[0] == IA64_OPND_P1
               && CURR_SLOT.opnd[0].X_add_number - REG_P == 63)
              || (idesc->operands[1] == IA64_OPND_P2
                  && CURR_SLOT.opnd[1].X_add_number - REG_P == 63))
            {
              specs[count++] = tmpl;
            }
        }
d7445 6
a7450 6
        {
          if (CURR_SLOT.qp_regno == 63)
            {
              specs[count++] = tmpl;
            }
        }
d7452 9
a7460 9
        {
          valueT mask = 0;
          if (idesc->operands[2] == IA64_OPND_IMM17)
            mask = CURR_SLOT.opnd[2].X_add_number;
          if (mask & ((valueT) 1<<63))
            {
              specs[count++] = tmpl;
            }
        }
d7462 23
a7484 23
        {
          if (rsrc_write)
            {
              for (i=0;i < idesc->num_outputs;i++)
                if ((idesc->operands[i] == IA64_OPND_P1
                     || idesc->operands[i] == IA64_OPND_P2)
                    && CURR_SLOT.opnd[i].X_add_number - REG_P == 63)
                  {
                    specs[count++] = tmpl;
                  }
            }
          else
            {
              if (CURR_SLOT.qp_regno == 63)
                {
                  specs[count++] = tmpl;
                }
            }
        }
      else
        {
          UNHANDLED;
        }
d7489 2
a7490 2
         read resources have not yet been completely identified, so for now
         treat RSE as a single resource */
d7492 35
a7526 35
        {
          if (rsrc_write)
            {
              if (idesc->operands[0] == IA64_OPND_AR3
                  && CURR_SLOT.opnd[0].X_add_number - REG_AR == AR_BSPSTORE)
                {
                  specs[count] = tmpl;
                  specs[count++].index = 0; /* IA64_RSE_BSPLOAD/RNATBITINDEX */
                }
            }
          else
            {
              if (idesc->operands[0] == IA64_OPND_AR3)
                {
                  if (CURR_SLOT.opnd[0].X_add_number - REG_AR == AR_BSPSTORE
                      || CURR_SLOT.opnd[0].X_add_number - REG_AR == AR_RNAT)
                    {
                      specs[count++] = tmpl;
                    }
                }
              else if (idesc->operands[1] == IA64_OPND_AR3)
                {
                  if (CURR_SLOT.opnd[1].X_add_number - REG_AR == AR_BSP
                      || CURR_SLOT.opnd[1].X_add_number - REG_AR == AR_BSPSTORE
                      || CURR_SLOT.opnd[1].X_add_number - REG_AR == AR_RNAT)
                    {
                      specs[count++] = tmpl;
                    }
                }
            }
        }
      else
        {
          specs[count++] = tmpl;
        }
d7543 2
a7544 2
   QP of the marking instruction and a subsequent branch on the same QP.
*/
d7547 1
a7547 1
  valueT mask;
d7550 1
a7550 1
  for (i = 0;i < regdepslen;i++)
d7554 3
a7556 3
        {
          regdeps[i].link_to_qp_branch = 0;
        }
d7562 2
a7563 2
   Any changes to a PR clears the mutex relations which include that PR.
*/
d7566 1
a7566 1
  valueT mask;
d7574 9
a7582 9
        {
          if (md.debug_dv)
            {
              fprintf (stderr, "  Clearing mutex relation");
              print_prmask (qp_mutexes[i].prmask);
              fprintf (stderr, "\n");
            }
          qp_mutexes[i] = qp_mutexes[--qp_mutexeslen];
        }
d7584 1
a7584 1
        ++i;
d7590 2
a7591 2
   indicates the implied PR.
*/
d7594 2
a7595 2
  valueT p1_mask;
  valueT p2_mask;
d7603 7
a7609 7
          || (((valueT) 1 << qp_implies[i].p2) & p2_mask) != 0)
        {
          if (md.debug_dv)
            fprintf (stderr, "Clearing implied relation PR%d->PR%d\n",
                     qp_implies[i].p1, qp_implies[i].p2);
          qp_implies[i] = qp_implies[--qp_implieslen];
        }
d7611 1
a7611 1
        ++i;
d7615 2
a7616 1
/* add the PRs specified to the list of implied relations */
d7619 1
a7619 1
  int p1, p2;
d7625 1
a7625 1
  /* p0 is not meaningful here */
d7632 2
a7633 2
  /* if it exists already, ignore it */
  for (i=0;i < qp_implieslen;i++)
d7636 4
a7639 4
          && qp_implies[i].p2 == p2
          && qp_implies[i].path == md.path
          && !qp_implies[i].p2_branched)
        return;
d7646 2
a7647 2
        xrealloc ((void *)qp_implies,
                  qp_impliestotlen * sizeof (struct qp_imply));
d7659 1
a7659 1
  for (i=0;i < qp_implieslen;i++)
d7662 1
a7662 1
        add_qp_imply (p1, qp_implies[i].p2);
d7664 1
a7664 1
        add_qp_imply (qp_implies[i].p1, p2);
d7670 1
a7670 1
  for (i=0;i < qp_mutexeslen;i++)
d7673 1
a7673 1
        add_qp_mutex ((qp_mutexes[i].prmask & ~mask) | bit);
d7680 1
d7683 1
a7683 1
  valueT mask;
d7692 2
a7693 2
        xrealloc ((void *)qp_mutexes,
                  qp_mutexestotlen * sizeof (struct qpmutex));
d7711 1
a7711 1
  for (i=1;i < NELEMS(gr_values);i++)
d7718 1
a7718 1
   have to examine a group of strings to identify them.
a7719 1
 */
d7722 1
a7722 1
  struct ia64_opcode *idesc;
d7727 2
a7728 2
  /* invalidate values for registers being written to */
  for (i=0;i < idesc->num_outputs;i++)
d7731 7
a7737 7
          || idesc->operands[i] == IA64_OPND_R2
          || idesc->operands[i] == IA64_OPND_R3)
        {
          int regno = CURR_SLOT.opnd[i].X_add_number - REG_GR;
          if (regno > 0 && regno < NELEMS(gr_values))
            gr_values[regno].known = 0;
        }
d7745 5
a7749 5
               || idesc->operands[i] == IA64_OPND_P2)
        {
          int regno = CURR_SLOT.opnd[i].X_add_number - REG_P;
          qp_changemask |= (valueT) 1 << regno;
        }
d7751 7
a7757 7
        {
          if (idesc->operands[2] & (valueT) 0x10000)
            qp_changemask = ~(valueT) 0x1FFFF | idesc->operands[2];
          else
            qp_changemask = idesc->operands[2];
          break;
        }
d7759 8
a7766 8
        {
          if (idesc->operands[1] & ((valueT) 1 << 43))
            qp_changemask = ~(valueT) 0xFFFFFFFFFFF | idesc->operands[1];
          else
            qp_changemask = idesc->operands[1];
          qp_changemask &= ~(valueT) 0xFFFF;
          break;
        }
d7769 2
a7770 2
  /* Always clear qp branch flags on any PR change */
  /* FIXME there may be exceptions for certain compares */
d7773 1
a7773 1
  /* invalidate rotating registers on insns which affect RRBs in CFM */
d7778 4
a7781 4
        {
          for (i=32;i < 32+md.rot.num_regs;i++)
            gr_values[i].known = 0;
        }
d7785 2
a7786 2
  /* after a call, all register values are undefined, except those marked
     as "safe" */
d7788 1
a7788 1
           || strncmp (idesc->name, "brl.call", 7) == 0)
d7797 1
a7797 1
           || is_taken_branch (idesc))
d7803 1
a7803 1
  /* Look for mutex and implies relations */
d7805 3
a7807 3
            || idesc->operands[0] == IA64_OPND_P2)
           && (idesc->operands[1] == IA64_OPND_P1
               || idesc->operands[1] == IA64_OPND_P2))
d7814 1
a7814 1
      /* if one of the PRs is PR0, we can't really do anything */
d7816 4
a7819 4
        {
          if (md.debug_dv)
            fprintf (stderr, "  Ignoring PRs due to inclusion of p0\n");
        }
d7821 1
a7821 1
         with the following exceptions */
d7823 4
a7826 4
        {
          add_qp_mutex (p1mask | p2mask);
          clear_qp_implies (p2mask, p1mask);
        }
d7828 4
a7831 4
        {
          add_qp_mutex (p1mask | p2mask);
          clear_qp_implies (p1mask, p2mask);
        }
d7833 3
a7835 3
        {
          clear_qp_implies (0, p1mask | p2mask);
        }
d7837 27
a7863 27
        {
          clear_qp_mutex (p1mask | p2mask);
          clear_qp_implies (p1mask | p2mask, 0);
        }
      else
        {
          clear_qp_implies (p1mask | p2mask, p1mask | p2mask);
          if (strstr (idesc->name, ".unc") != NULL)
            {
              add_qp_mutex (p1mask | p2mask);
              if (CURR_SLOT.qp_regno != 0)
                {
                  add_qp_imply (CURR_SLOT.opnd[0].X_add_number - REG_P,
                                CURR_SLOT.qp_regno);
                  add_qp_imply (CURR_SLOT.opnd[1].X_add_number - REG_P,
                                CURR_SLOT.qp_regno);
                }
            }
          else if (CURR_SLOT.qp_regno == 0)
            {
              add_qp_mutex (p1mask | p2mask);
            }
          else
            {
              clear_qp_mutex (p1mask | p2mask);
            }
        }
d7865 1
a7865 1
  /* Look for mov imm insns into GRs */
d7867 4
a7870 4
      && (idesc->operands[1] == IA64_OPND_IMM22
          || idesc->operands[1] == IA64_OPND_IMMU64)
      && (strcmp(idesc->name, "mov") == 0
          || strcmp(idesc->name, "movl") == 0))
d7873 9
a7881 9
      if (regno > 0 && regno < NELEMS(gr_values))
        {
          gr_values[regno].known = 1;
          gr_values[regno].value = CURR_SLOT.opnd[1].X_add_number;
          gr_values[regno].path = md.path;
          if (md.debug_dv)
            fprintf (stderr, "  Know gr%d = 0x%llx\n",
                     regno, gr_values[regno].value);
        }
d7890 2
a7891 1
/* Return whether the given predicate registers are currently mutex */
d7894 3
a7896 3
  int p1;
  int p2;
  int path;
d7903 7
a7909 7
      mask = ((valueT) 1<<p1) | (valueT) 1<<p2;
      for (i=0;i < qp_mutexeslen;i++)
        {
          if (qp_mutexes[i].path >= path
              && (qp_mutexes[i].prmask & mask) == mask)
            return 1;
        }
d7916 2
a7917 2
   conflict.
 */
d7920 5
a7924 5
  struct rsrc *rs;
  struct ia64_opcode *idesc;
  int note;
  int qp_regno;
  int path;
d7941 12
a7952 12
          && specs[count].mem_offset.hint
          && rs->mem_offset.hint)
        {
          if (rs->mem_offset.base == specs[count].mem_offset.base)
            {
              if (((rs->mem_offset.offset >> 3) & 0x3F) ==
                  ((specs[count].mem_offset.offset >> 3) & 0x3F))
                return 1;
              else
                continue;
            }
        }
d7957 1
a7957 1
        return 2;
d7959 1
a7959 1
        return 1;
d7974 1
a7974 2
   instruction.
*/
d7978 3
a7980 3
  int insert_stop;
  int qp_regno;
  int save_current;
d7990 1
a7990 1
               (insert_stop ? " (w/stop)" : ""));
d7992 1
a7992 1
        fprintf (stderr, " effective for QP=%d", qp_regno);
d8002 5
a8006 5
          && regdeps[i].qp_regno != qp_regno)
        {
          ++i;
          continue;
        }
d8009 6
a8014 6
          && CURR_SLOT.src_file == regdeps[i].file
          && CURR_SLOT.src_line == regdeps[i].line)
        {
          ++i;
          continue;
        }
d8017 1
a8017 1
         those that have reached the appropriate state of insn serialization */
d8019 10
a8028 10
          || dep->semantics == IA64_DVS_IMPLIEDF
          || regdeps[i].insn_srlz == STATE_SRLZ)
        {
          print_dependency ("Removing", i);
          regdeps[i] = regdeps[--regdepslen];
        }
      else
        {
          if (dep->semantics == IA64_DVS_DATA
              || dep->semantics == IA64_DVS_INSTR
d8030 8
a8037 8
            {
              if (regdeps[i].insn_srlz == STATE_NONE)
                regdeps[i].insn_srlz = STATE_STOP;
              if (regdeps[i].data_srlz == STATE_NONE)
                regdeps[i].data_srlz = STATE_STOP;
            }
          ++i;
        }
d8041 2
a8042 1
/* Add the given resource usage spec to the list of active dependencies */
d8045 5
a8049 5
  struct ia64_opcode *idesc;
  const struct ia64_dependency *dep;
  struct rsrc *spec;
  int depind;
  int path;
d8055 2
a8056 2
        xrealloc ((void *)regdeps,
                  regdepstotlen * sizeof(struct rsrc));
d8072 2
a8073 2
  const char *action;
  int depind;
d8078 2
a8079 2
               action, dv_mode[(regdeps[depind].dependency)->mode],
               (regdeps[depind].dependency)->name);
d8081 1
a8081 1
        fprintf (stderr, " (%d)", regdeps[depind].index);
d8083 3
a8085 3
        fprintf (stderr, " 0x%llx+0x%llx",
                 regdeps[depind].mem_offset.base,
                 regdeps[depind].mem_offset.offset);
d8096 1
a8096 1
  for (i=0;i < regdepslen;i++)
d8110 7
a8116 7
          /* Note: as of 991210, all "other" dependencies are cleared by a
             data serialization.  This might change with new tables */
          || (regdeps[i].dependency)->semantics == IA64_DVS_OTHER)
        {
          print_dependency ("Removing", i);
          regdeps[i] = regdeps[--regdepslen];
        }
d8118 1
a8118 1
        ++i;
d8122 2
a8123 1
/* Insert stops and serializations as needed to avoid DVs */
d8126 1
a8126 1
  struct rsrc *rs;
d8136 1
a8136 1
        fprintf (stderr, "Inserting instr serialization\n");
d8138 1
a8138 1
        insn_group_break (1, 0, 0);
d8140 13
a8152 13
        {
          int oldqp = CURR_SLOT.qp_regno;
          struct ia64_opcode *oldidesc = CURR_SLOT.idesc;
          /* Manually jam a srlz.i insn into the stream */
          CURR_SLOT.qp_regno = 0;
          CURR_SLOT.idesc = ia64_find_opcode ("srlz.i");
          instruction_serialization ();
          md.curr_slot = (md.curr_slot + 1) % NUM_SLOTS;
          if (++md.num_slots_in_use >= NUM_SLOTS)
            emit_one_bundle ();
          CURR_SLOT.qp_regno = oldqp;
          CURR_SLOT.idesc = oldidesc;
        }
d8156 2
a8157 2
                            "other" types of DV are eliminated
                            by a data serialization */
d8160 1
a8160 1
        fprintf (stderr, "Inserting data serialization\n");
d8162 1
a8162 1
        insn_group_break (1, 0, 0);
d8164 11
a8174 11
        int oldqp = CURR_SLOT.qp_regno;
        struct ia64_opcode *oldidesc = CURR_SLOT.idesc;
        /* Manually jam a srlz.d insn into the stream */
        CURR_SLOT.qp_regno = 0;
        CURR_SLOT.idesc = ia64_find_opcode ("srlz.d");
        data_serialization ();
        md.curr_slot = (md.curr_slot + 1) % NUM_SLOTS;
        if (++md.num_slots_in_use >= NUM_SLOTS)
          emit_one_bundle ();
        CURR_SLOT.qp_regno = oldqp;
        CURR_SLOT.idesc = oldidesc;
d8180 1
a8180 1
        fprintf (stderr, "Inserting stop\n");
d8201 1
d8204 1
a8204 1
  struct ia64_opcode *idesc;
d8222 95
a8316 95
          || (chkind = depends_on (rs->depind, idesc)) == -1)
        {
          ++i; continue;
        }

      note = NOTE(opdeps->chks[chkind]);

      /* Check this resource against each execution path seen thus far */
      for (path=0;path <= md.path;path++)
        {
          int matchtype;

          /* If the dependency wasn't on the path being checked, ignore it */
          if (rs->path < path)
            continue;

          /* If the QP for this insn implies a QP which has branched, don't
             bother checking.  Ed. NOTE: I don't think this check is terribly
             useful; what's the point of generating code which will only be
             reached if its QP is zero?
             This code was specifically inserted to handle the following code,
             based on notes from Intel's DV checking code, where p1 implies p2.

                  mov r4 = 2
             (p2) br.cond L
             (p1) mov r4 = 7

          */
          if (CURR_SLOT.qp_regno != 0)
            {
              int skip = 0;
              int implies;
              for (implies=0;implies < qp_implieslen;implies++)
                {
                  if (qp_implies[implies].path >= path
                      && qp_implies[implies].p1 == CURR_SLOT.qp_regno
                      && qp_implies[implies].p2_branched)
                    {
                      skip = 1;
                      break;
                    }
                }
              if (skip)
                continue;
            }

          if ((matchtype = resources_match (rs, idesc, note,
                                            CURR_SLOT.qp_regno, path)) != 0)
            {
              char msg[1024];
              char pathmsg[256] = "";
              char indexmsg[256] = "";
              int certain = (matchtype == 1 && CURR_SLOT.qp_regno == 0);

              if (path != 0)
                sprintf (pathmsg, " when entry is at label '%s'",
                         md.entry_labels[path-1]);
              if (rs->specific && rs->index != 0)
                sprintf (indexmsg, ", specific resource number is %d",
                         rs->index);
              sprintf (msg, "Use of '%s' %s %s dependency '%s' (%s)%s%s",
                       idesc->name,
                       (certain ? "violates" : "may violate"),
                       dv_mode[dep->mode], dep->name,
                       dv_sem[dep->semantics],
                       pathmsg, indexmsg);

              if (md.explicit_mode)
                {
                  as_warn ("%s", msg);
                  if (path < md.path)
                    as_warn (_("Only the first path encountering the conflict "
                               "is reported"));
                  as_warn_where (rs->file, rs->line,
                                 _("This is the location of the "
                                   "conflicting usage"));
                  /* Don't bother checking other paths, to avoid duplicating
                     the same warning */
                  break;
                }
              else
                {
                  if (md.debug_dv)
                    fprintf(stderr, "%s @@ %s:%d\n", msg, rs->file, rs->line);

                  remove_marked_resource (rs);

                  /* since the set of dependencies has changed, start over */
                  /* FIXME -- since we're removing dvs as we go, we
                     probably don't really need to start over...  */
                  start_over = 1;
                  break;
                }
            }
        }
d8318 1
a8318 1
        i = 0;
d8320 1
a8320 1
        ++i;
d8324 2
a8325 1
/* register new dependencies based on the given opcode */
d8328 1
a8328 1
  struct ia64_opcode *idesc;
d8346 1
a8346 1
  for (i=0;i < opdeps->nregs;i++)
d8355 1
a8355 1
      note = NOTE(opdeps->regs[i]);
d8358 4
a8361 4
          && !(dep->mode == IA64_DV_WAR
               && (dep->specifier == IA64_RS_PR
                   || dep->specifier == IA64_RS_PR63)))
        continue;
d8367 2
a8368 2
        fprintf (stderr, "  No %s %s usage found (path %d)\n",
                 dv_mode[dep->mode], dep->name, md.path);
d8372 4
a8375 4
        {
          mark_resource (idesc, dep, &specs[count],
                         DEP(opdeps->regs[i]), md.path);
        }
d8378 1
a8378 1
         affect which indirect-access resources are accessed.  */
d8380 6
a8385 6
        {
        default:
          break;
        case IA64_RS_CPUID:
        case IA64_RS_DBR:
        case IA64_RS_IBR:
d8387 13
a8399 13
        case IA64_RS_PKR:
        case IA64_RS_PMC:
        case IA64_RS_PMD:
        case IA64_RS_RR:
          for (path=0;path < md.path;path++)
            {
              count = specify_resource (dep, idesc, DV_REG, specs, note, path);
              while (count-- > 0)
                mark_resource (idesc, dep, &specs[count],
                               DEP(opdeps->regs[i]), path);
            }
          break;
        }
d8403 2
a8404 1
/* remove dependencies when they no longer apply */
d8407 1
a8407 1
  struct ia64_opcode *idesc;
d8420 1
a8420 1
           || is_taken_branch (idesc))
d8422 3
a8424 3
      /* although technically the taken branch doesn't clear dependencies
         which require a srlz.[id], we don't follow the branch; the next
         instruction is assumed to start with a clean slate */
d8429 1
a8429 1
           && CURR_SLOT.qp_regno != 0)
d8433 23
a8455 23
      for (i=0;i < qp_implieslen;i++)
        {
          /* if the conditional branch's predicate is implied by the predicate
             in an existing dependency, remove that dependency */
          if (qp_implies[i].p2 == CURR_SLOT.qp_regno)
            {
              int depind = 0;
              /* note that this implied predicate takes a branch so that if
                 a later insn generates a DV but its predicate implies this
                 one, we can avoid the false DV warning */
              qp_implies[i].p2_branched = 1;
              while (depind < regdepslen)
                {
                  if (regdeps[depind].qp_regno == qp_implies[i].p1)
                    {
                      print_dependency ("Removing", depind);
                      regdeps[depind] = regdeps[--regdepslen];
                    }
                  else
                    ++depind;
                }
            }
        }
d8457 2
a8458 3
         cleared, provided that the QP hasn't been modified between the
         marking instruction and the branch.
      */
d8460 21
a8480 21
        {
          insn_group_break (0, CURR_SLOT.qp_regno, 1);
        }
      else
        {
          i = 0;
          while (i < regdepslen)
            {
              if (regdeps[i].qp_regno == CURR_SLOT.qp_regno
                  && regdeps[i].link_to_qp_branch
                  && (regdeps[i].file != CURR_SLOT.src_file
                      || regdeps[i].line != CURR_SLOT.src_line))
                {
                  /* Treat like a taken branch */
                  print_dependency ("Removing", i);
                  regdeps[i] = regdeps[--regdepslen];
                }
              else
                ++i;
            }
        }
d8485 1
d8488 1
a8488 1
  struct ia64_opcode *idesc;
d8493 3
a8495 3
               idesc->name, CURR_SLOT.src_line,
               idesc->dependencies->nchks,
               idesc->dependencies->nregs);
d8500 1
a8500 2
     check against the specific resources used.
  */
d8503 2
a8504 4
  /*
    Look up the instruction's regdeps (RAW writes, WAW writes, and WAR reads),
    then add them to the list of marked resources.
  */
d8549 1
a8549 1
  /* extract the opcode (mnemonic): */
d8561 1
a8561 1
  /* find the instruction descriptor matching the arguments: */
d8575 1
a8575 1
  /* Handle the dynamic ops we can handle now: */
d8633 1
a8633 1
  /* build the instruction: */
d8647 1
a8647 1
  /* check for dependency violations */
d8649 1
a8649 1
    check_dv(idesc);
d8666 2
a8667 1
symbolS*
d8677 1
d8690 1
a8690 1
      /* find what relocation pseudo-function we're dealing with: */
d8715 2
a8716 1
	  ++input_line_pointer;	/* skip '(' */
d8739 2
a8740 2
	  /* make sure gas doesn't get rid of local symbols that are used
	     in relocs: */
d9187 1
a9187 1
         work.  There should be a better way to handle this.  */
d9211 2
a9212 1
arelent*
d9242 1
a9242 1
char*
@


1.16
log
@2000-09-02  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-ia64.c: Fix formatting.
@
text
@d5236 1
a5236 1
      /* auto select appropriate template */
d5241 2
@


1.15
log
@        * config/tc-ia64.c (match): Don't inline.
        (extra_goodness): New.
        (md_begin): Prefer nop.f and nop.b for best_template.
@
text
@d41 1
a41 1
        notes) 
d187 1
a187 1
      manual_bundling : 1, 
d197 1
a197 1
       the end_of_insn_group for the last instruction in a bundle. */
d251 1
a251 1
                                       the current DV-checking block. */
d289 1
a289 1
    {"ar.ec",		66}, 
d539 1
a539 1
static valueT qp_safe_across_calls = 0; 
d551 2
a552 2
/* Keep track of static GR values so that indirect register usage can 
   sometimes be tracked. */
d663 1
a663 1
static bfd_reloc_code_real_type ia64_gen_real_reloc_type PARAMS ((struct symbol *sym, 
d928 1
a928 1
void 
d946 1
a946 1
void 
d968 1
a968 1
  
d1008 1
a1008 1
  
a1095 1

d1130 1
a1130 1
  
d1319 1
a1319 1
  if (label > 0x1f) 
d1379 1
a1379 1
  if (label <= 0x1f) 
d1384 1
a1384 1
  
d1419 1
a1419 1
  
d1491 1
a1491 1
alloc_record (unw_record_type t) 
d2127 1
a2127 1
/* Given a unw_rec_list process the correct format with the 
d2136 1
a2136 1
  switch (ptr->r.type) 
d2182 1
a2182 1
	output_P7_format (f, ptr->r.type, ptr->r.record.p.t, 
d2302 1
a2302 1
/* Given a unw_rec_list list, process all the records with 
d2369 1
a2369 1
	
d2402 1
a2402 1
   this has been run, all neccessary information should be available 
d2428 1
a2428 1
	      /* Find either the next body/prologue start, or the end of 
d2442 1
a2442 1
		       covered by an unwind directive. */
d2549 1
a2549 1
	    set_imask (region, ptr->r.record.p.grmask, t, 2); 
d2557 1
a2557 1
	    set_imask (region, ptr->r.record.p.brmask, t, 3); 
d2654 1
a2654 1
} 
d2687 1
a2687 1
} 
d2729 1
a2729 1
static void 
d2736 1
a2736 1
  
d2743 1
a2743 1
static void 
d2762 1
a2762 1
static void 
d2778 1
a2778 1
static void 
d2794 1
a2794 1
static void 
d2809 1
a2809 1
  
d2871 1
a2871 1
static void 
d2899 1
a2899 1
static void 
d2916 1
a2916 1
static void 
d3000 1
a3000 1
static void 
d3008 1
a3008 1
static void 
d3015 1
a3015 1
static void 
d3030 1
a3030 1
static void 
d3045 1
a3045 1
  
d3124 1
a3124 1
static void 
d3133 1
a3133 1
  
d3152 1
a3152 1
static void 
d3159 1
a3159 1
  
d3166 1
a3166 1
static void 
d3201 1
a3201 1
static void 
d3210 1
a3210 1
  
d3221 1
a3221 1
static void 
d3231 1
a3231 1
  
d3434 1
a3434 1
static void 
d3466 1
a3466 1
static void 
d3984 1
a3984 1
  else 
d4000 1
a4000 1
/* select dv checking mode 
d4005 1
a4005 1
   A stop is inserted when changing modes 
d4052 1
a4052 1
      if (mask & ((valueT)1<<regno))
d4082 1
a4082 1
      else 
d4086 1
a4086 1
          if (strcmp (form, "mutex") == 0) 
d4092 1
a4092 1
          else 
d4109 1
a4109 1
      
d4168 1
a4168 1
        mask = ~(valueT)0;
d4170 1
a4170 1
      clear_qp_implies (mask, (valueT)0);
d4252 1
a4252 1
/* .mem.offset offset, base 
d4315 2
a4316 2
    { "label_state", dot_label_state }, 
    { "copy_state", dot_copy_state }, 
d4649 1
a4649 1
      else 
d4706 1
a4706 1
            e->X_add_number |= (bfd_vma)0x3;
d4744 1
a4744 1
              e->X_add_number |= ~(((bfd_vma)1 << 17) - 1);
d4800 2
a4801 2
	  if (((val & (~(bfd_vma)0 << 32)) == 0)
	      && ((val & ((bfd_vma)1 << 31)) != 0))
d4840 2
a4841 2
	  if (((val & (~(bfd_vma)0 << 32)) == 0)
	      && ((val & ((bfd_vma)1 << 31)) != 0))
d4941 1
a4941 1
   found, NULL is returned instead. */
d5009 1
a5009 1
  
d5172 1
a5172 1
	case IA64_OPND_RR_R3:    
d5442 1
a5442 1
		 instruction isn't an X-unit, or an I-unit instruction 
d5570 1
a5570 1
          /* Suppress signon message. */
d5756 1
a5756 1
  /* Compute the table of best templates.  We compute goodness as a 
d6014 1
a6014 1
      if (md.detect_dv 
d6229 1
a6229 1
          && (strcmp (idesc->name, "br") == 0 
d6280 1
a6280 1
   marked nonspecific.  
d6286 1
a6286 1
   accesses CFM when qualifying predicate is in the rotating region. 
d6295 1
a6295 1
   statically. 
d6297 1
a6297 1
   set 
d6310 1
a6310 1
   with data returned from memory, not the post-incremented address register.  
d6315 1
a6315 1
   IC:rse-writers. 
d6317 1
a6317 1
   generate. 
d6341 1
a6341 1
 
d6435 1
a6435 1
        { 
d6483 1
a6483 1
      else 
d6503 1
a6503 1
                    specs[count++].index = 
d6514 1
a6514 1
                    specs[count++].index = 
d6648 1
a6648 1
          /* probe et al. */
d6659 1
a6659 1
            
d6732 1
a6732 1
      else 
d6739 1
a6739 1
      if (note == 0) 
d6743 1
a6743 1
          if (rsrc_write 
d6776 1
a6776 1
      else 
d6794 1
a6794 1
              specs[count++].index = 
d6828 1
a6828 1
                  specs[count++].index = 
d6853 1
a6853 1
		    specs[count++].index = 
d6865 1
a6865 1
          else 
d6887 1
a6887 1
                      specs[count++].index = 
d6893 1
a6893 1
      else 
d6927 2
a6928 2
              if (mask & ((valueT)1<<16))
                mask |= ~(valueT)0xffff;
d6931 1
a6931 1
                  if (mask & ((valueT)1<<i))
d7021 1
a7021 1
      else 
d7028 1
a7028 1
      /* Verify that the instruction is using the PSR bit indicated in 
d7059 1
a7059 1
          else 
d7061 1
a7061 1
              /* Several PSR bits have very specific dependencies. */
d7078 1
a7078 1
                          int index = 
d7081 1
a7081 1
                          int regno = 
d7108 1
a7108 1
                  else 
d7114 1
a7114 1
                          int index = 
d7117 1
a7117 1
                          int regno = 
d7119 1
a7119 1
                          
d7122 2
a7123 2
                                  && (regno == AR_ITC 
                                      || regno == AR_RSC 
d7128 1
a7128 1
                            }                  
d7146 1
a7146 1
          else 
d7150 1
a7150 1
          if (mask & ((valueT)1<<dep->regindex))
d7180 1
a7180 1
             FR2-31 */ 
d7230 1
a7230 1
    case IA64_RS_ARX: 
d7257 1
a7257 1
                      (regno == AR_BSPSTORE 
d7281 1
a7281 1
          else 
d7305 1
a7305 1
                  /* Reads from CR[IVR] affect other resources. */
d7434 1
a7434 1
          if (mask & ((valueT)1<<63))
d7501 1
a7501 1
      else 
d7521 1
a7521 1
   QP of the marking instruction and a subsequent branch on the same QP. 
d7530 1
a7530 1
      valueT bit = ((valueT)1 << regdeps[i].qp_regno);
d7538 1
a7538 1
/* Remove any mutexes which contain any of the PRs indicated in the mask. 
d7541 1
a7541 1
*/ 
d7580 2
a7581 2
      if ((((valueT)1 << qp_implies[i].p1) & p1_mask) != 0
          || (((valueT)1 << qp_implies[i].p2) & p2_mask) != 0)
d7584 1
a7584 1
            fprintf (stderr, "Clearing implied relation PR%d->PR%d\n", 
d7588 1
a7588 1
      else 
d7612 1
a7612 1
      if (qp_implies[i].p1 == p1 
d7623 1
a7623 1
        xrealloc ((void *)qp_implies, 
d7635 1
a7635 1
     as well. */
d7644 3
a7646 3
     relation containing p2, duplicate it and replace p2 with p1. */
  bit = (valueT)1 << p1;
  mask = (valueT)1 << p2;
a7653 1

d7668 1
a7668 1
        xrealloc ((void *)qp_mutexes, 
d7707 1
a7707 1
      if (idesc->operands[i] == IA64_OPND_R1 
d7721 1
a7721 1
      else if (idesc->operands[i] == IA64_OPND_P1 
d7725 1
a7725 1
          qp_changemask |= (valueT)1 << regno;
d7729 3
a7731 3
          if (idesc->operands[2] & (valueT)0x10000)
            qp_changemask = ~(valueT)0x1FFFF | idesc->operands[2];
          else 
d7737 2
a7738 2
          if (idesc->operands[1] & ((valueT)1 << 43))
            qp_changemask = ~(valueT)0xFFFFFFFFFFF | idesc->operands[1];
d7741 1
a7741 1
          qp_changemask &= ~(valueT)0xFFFF;
d7753 1
a7753 1
      qp_changemask |= ~(valueT)0xFFFF;
d7777 2
a7778 2
      clear_qp_mutex (~(valueT)0);
      clear_qp_implies (~(valueT)0, ~(valueT)0);
d7781 1
a7781 1
  else if ((idesc->operands[0] == IA64_OPND_P1 
d7787 3
a7789 3
      int p2 = CURR_SLOT.opnd[1].X_add_number - REG_P; 
      valueT p1mask = (valueT)1 << p1;
      valueT p2mask = (valueT)1 << p2;
d7826 1
a7826 1
                  add_qp_imply (CURR_SLOT.opnd[0].X_add_number - REG_P, 
d7828 1
a7828 1
                  add_qp_imply (CURR_SLOT.opnd[1].X_add_number - REG_P, 
d7836 1
a7836 1
          else 
d7856 1
a7856 1
            fprintf (stderr, "  Know gr%d = 0x%llx\n", 
d7860 1
a7860 1
  else 
d7879 1
a7879 1
      mask = ((valueT)1<<p1) | (valueT)1<<p2;
d7892 2
a7893 2
   conflict. 
 */ 
d7908 1
a7908 1
  if (qp_mutex (rs->qp_regno, qp_regno, path) 
d7922 1
a7922 1
              if (((rs->mem_offset.offset >> 3) & 0x3F) == 
d7931 1
a7931 1
       */ 
d7950 2
a7951 2
   instruction. 
*/ 
d7966 1
a7966 1
      fprintf (stderr, "  Insn group break%s", 
d8019 1
a8019 1
static void 
d8031 1
a8031 1
        xrealloc ((void *)regdeps, 
d8053 1
a8053 1
      fprintf (stderr, "  %s %s '%s'", 
d8108 1
a8108 1
      /* ...fall through... */
d8164 1
a8164 1
   list.  
d8170 1
a8170 1
   
d8174 1
a8174 1
   br.ret        
d8185 1
a8185 1
     loop if in auto mode. */
d8215 1
a8215 1
             reached if its QP is zero? 
d8223 2
a8224 2
          */  
          if (CURR_SLOT.qp_regno != 0) 
d8242 1
a8242 1
          if ((matchtype = resources_match (rs, idesc, note, 
d8254 1
a8254 1
                sprintf (indexmsg, ", specific resource number is %d", 
d8257 1
a8257 1
                       idesc->name, 
d8259 1
a8259 1
                       dv_mode[dep->mode], dep->name, 
d8280 1
a8280 1
                  
d8282 1
a8282 1
                  
d8285 1
a8285 1
                     probably don't really need to start over... */
d8310 1
a8310 1
     reads.  */ 
d8326 1
a8326 1
      
d8340 1
a8340 1
        fprintf (stderr, "  No %s %s usage found (path %d)\n", 
d8343 1
a8343 1
      
d8346 1
a8346 1
          mark_resource (idesc, dep, &specs[count], 
d8351 1
a8351 1
         affect which indirect-access resources are accessed. */
d8368 1
a8368 1
                mark_resource (idesc, dep, &specs[count], 
d8430 1
a8430 1
         marking instruction and the branch.  
d8443 1
a8443 1
                  && (regdeps[i].file != CURR_SLOT.src_file 
d8464 3
a8466 3
      fprintf (stderr, "Checking %s for violations (line %d, %d/%d)\n", 
               idesc->name, CURR_SLOT.src_line, 
               idesc->dependencies->nchks, 
d8470 1
a8470 1
  /* Look through the list of currently marked resources; if the current 
d8472 1
a8472 1
     check against the specific resources used.  
d8483 2
a8484 2
     requirements for being cleared 
     
d8499 1
a8499 1
     warning.  Keep track of as many as possible that are useful. */
d8502 1
a8502 1
  /* We don't need or want this anymore. */
d8827 1
a8827 1
  
d8888 1
a8888 1
   symbols in the pseudo_func array, or NULL. */
d9103 1
a9103 1
   (if possible). */
d9272 1
a9272 1
  valueT mask = ((valueT)1 << align) - 1;
d9304 1
a9304 1
	    
@


1.14
log
@Fix unwind section bug found by linux kernel.
	* config/tc-ia64.c (output_unw_records): Set U & E flags only if
	unwind.personality_routine is set.
@
text
@d5667 3
a5669 1
static inline int
d5692 13
d5757 5
a5761 1
  /* compute the table of best templates: */
d5775 1
a5775 1
			goodness = 3;
d5777 1
a5777 1
			goodness = 2;
d5780 1
a5780 1
		    goodness = 2;
d5782 5
a5786 1
		    goodness = 1;
d5791 1
a5791 1
		    goodness = 2;
d5793 1
a5793 1
		    goodness = 1;
d5796 1
a5796 1
		goodness = 1;
@


1.13
log
@Fix 3 DV bugs, and a few minor cleanups.
gas/
	* config/tc-ia64.c (specify_resource, case IA64_RS_GR): Handle
	postincrement modified registers.  Handle IA64_OPND_R3_2 addl
	source registers.
	(note_register_values): Handle IA64_OPND_R3_2 operands.
gas/testsuite/
	* gas/ia64/dv-raw-err.s: Add new tests for addl and postinc.
	* gas/ia64/dv-raw-err.l: Likewise.
	* gas/ia64/dv-waw-err.l: Update sed pattern.
	* gas/ia64/opc-f.pl: Delete fpsub, and fpadd comment.
	* gas/ia64/opc-f.s, gas/ia64/opc-f.d: Regenerate.
include/opcode/
	* ia64.h (IA64_OPCODE_POSTINC): New.
opcodes/
	* ia64-ic.tbl (pr-readers-nobr-nomovpr): Add addl, adds.  Delete
	break, mov-immediate, nop.
	* ia64-opc-f.c: Delete fpsub instructions.
	* ia64-opc-m.c: Add POSTINC to all instructions with postincrement
	address operand.  Rewrite using macros to avoid long lines.
	* ia64-opc.h (POSTINC): Define.
	* ia64-asmtab.c: Regenerate.
@
text
@d2592 4
a2595 2
  md_number_to_chars (mem, (  ((bfd_vma) 1 << 48)     /* version */
			    | ((bfd_vma) 3 << 32)     /* U & E handler flags */
@


1.12
log
@Add support for IA-64 specific elf header flags.
bfd/
2000-08-14  Jim Wilson  <wilson@@cygnus.com>
	* elf64-ia64.c (elf64_ia64_merge_private_bfd_data): Handle
	EF_IA_64_REDUCEDFP, EF_IA_64_CONS_GP, and EF_IA_64_NOFUNCDESC_CONS_GP.
	(elf64_ia64_print_private_bfd_data): Likewise.  Also handle
	EF_IA_64_ABSOLUTE.
gas/
2000-08-14  Jim Wilson  <wilson@@cygnus.com>
	* config/tc-ia64.c (md_longopts): Add -mconstant-gp and -mauto-pic.
	(md_parse_option):  Add OPTION_MCONSTANT_GP and OPTION_MAUTO_PIC.
	(md_begin): Change assignment to md.flag to OR in the new bit.
include/elf/
2000-08-14  Jim Wilson  <wilson@@cygnus.com>
	* elf/ia64.h (EF_IA_64_REDUCEDFP, EF_IA_64_CONS_GP,
	EF_IA_64_NOFUNCDESC_CONS_GP, EF_IA_64_ABSOLUTE): Define.
@
text
@d6823 17
a6839 11
              for (i=0;i < idesc->num_outputs;i++)
                {
                  if (idesc->operands[i] == IA64_OPND_R1
                      || idesc->operands[i] == IA64_OPND_R2
                      || idesc->operands[i] == IA64_OPND_R3)
                    {
                      specs[count] = tmpl;
                      specs[count++].index = 
                        CURR_SLOT.opnd[i].X_add_number - REG_GR;
                    }
                }
d6858 3
a6860 1
                              || idesc->operands[i] == IA64_OPND_R3)))
d7692 6
@


1.11
log
@        * config/tc-ia64.c (unwind): Add prologue_mask member.
        (dot_vframe): Elide psp_gr record if it overlaps prologue_gr.
        (dot_save): Likewise for pfs_gr, rp_gr, and preds_gr.
        (dot_body): Clear unwind.prologue_mask.
        (dot_prologue): Set it.  Accept a register second argument.
@
text
@d163 4
a166 1
    { NULL, no_argument, NULL, 0}
a5539 1
  /* Switches from the Intel assembler.  */
d5542 1
d5635 9
d5895 2
a5896 1
  md.flags = EF_IA_64_ABI64;
@


1.10
log
@Fix memory leaks for IA-64 opcode idescs.
gas/
	* config/tc-ia64.c (emit_one_bundle): Call ia64_free_opcode
	before ia64_find_opcode.
	(md_assemble): Likewise.
opcodes/
	* ia64-dis.c (print_insn_ia64): Call ia64_free_opcode at end.
@
text
@d587 1
d2751 2
a2752 1
      add_unwind_entry (output_psp_gr (reg));
d2835 2
a2836 1
	        add_unwind_entry (output_pfs_gr (reg2));
d2844 2
a2845 1
		add_unwind_entry (output_rp_gr (reg2));
d2849 2
a2850 1
		add_unwind_entry (output_preds_gr (reg2));
d3517 2
d3528 1
a3529 1
  unwind.prologue = 1;
d3542 2
d3545 4
a3548 5
	    {
	      int mask = e1.X_add_number;
	      int reg = e2.X_add_number;
	      add_unwind_entry (output_prologue_gr (mask, reg));
	    }
d3550 3
a3552 1
	    as_bad ("Second operand not a constant");
d3559 3
@


1.9
log
@Fix comments.
@
text
@d5393 1
d8497 1
d8521 1
@


1.8
log
@Move premature QP notation clearing to it's appropriate location.
@
text
@d9141 2
a9142 2
   of type type, and store the appropriate bytes in *lit.  The number
   of LITTLENUMS emitted is stored in *size.  An error message is
@


1.7
log
@unwind bug fixes needed for today's gcc patch.
	* config/tc-ia64.c (generate_unwind_image): Call ia64_flush_insns.
	(dot_endp): Don't call ia64_flush_insns.
	(emit_one_bundle): Don't delete prologue/body records from
	unwind_record list in first loop.  Rewrite second loop to account for
	this.
@
text
@d7709 7
a8333 3
      clear_register_values ();
      clear_qp_mutex (~(valueT)0);
      clear_qp_implies (~(valueT)0, ~(valueT)0);
@


1.6
log
@Patch from David Mosberger, cleanups to improve 32b-x-64b cross support.
	* config/tc-ia64.c: Add missing prototypes.
	(generate_unwind_image): Cast argument to output_unw_records call.
@
text
@d2945 4
a3567 1
  ia64_flush_insns ();
d5245 2
a5246 1
      prev = 0;
d5248 3
a5250 13
	{
	  if (ptr->r.type == prologue || ptr->r.type == prologue_gr
	      || ptr->r.type == body)
	    {
	      ptr->slot_number = (unsigned long) f + i;
	      if (prev)
		prev->next = ptr->next;
	      else
		md.slot[curr].unwind_record = ptr->next;
	    }
	  else
	    prev = ptr;
	}
d5450 6
a5455 6
      /* Set slot counts for unwind records.  */
      while (md.slot[curr].unwind_record) 
	{
	  md.slot[curr].unwind_record->slot_number = (unsigned long) f + i;
	  md.slot[curr].unwind_record = md.slot[curr].unwind_record->next;
	}
d5457 1
@


1.5
log
@IA-64 unwind info changes, fix errors, add missing pieces, and some cleanup.
	* config/tc-ia64.c (dot_restorereg_p): New function.
	(md_pseudo_table): Add restorereg.p.
	...
@
text
@d601 2
d605 2
d616 6
d642 1
d662 2
d671 3
d675 1
d677 3
d685 6
d692 12
d706 89
d2946 1
a2946 1
  size = output_unw_records (unwind.list, &unw_rec);
@


1.4
log
@        * config/tc-ia64.c (FUNC_PC_RELATIVE): New.
        (pseudo_func): Add pcrel.
        (operand_match):  Handle IA64_OPND_TGT64.
        (build_insn): Likewise.
        (md_begin): Initialize pseudo_func[FUNC_PC_RELATIVE].
        (ia64_gen_real_reloc_type): Handle FUNC_PC_RELATIVE.
        (fix_insn): Handle all three 64-bit relocation types.
@
text
@d2 1
a2 1
   Copyright (C) 1998, 1999 Free Software Foundation.
a34 2
	.save
	.vframe
d113 3
d256 11
a266 9
#define AR_K0           0
#define AR_K7           7
#define AR_RSC          16
#define AR_BSP          17
#define AR_BSPSTORE     18
#define AR_RNAT         19
#define AR_UNAT         36
#define AR_FPSR         40
#define AR_ITC          44
d425 1
d468 8
d561 1
a561 1
  unsigned long  slot_number;
d567 3
a569 2
/* TRUE if processing unwind directives in a prologue region.  */
static int unwind_prologue = 0;
d571 17
a587 13
/* Maintain a list of unwind entries for the current function.  */
static unw_rec_list *unwind_list = 0;
static unw_rec_list *unwind_tail = 0;

/* Any unwind entires that should be attached to the current
   slot that an insn is being constructed for.  */
static unw_rec_list *current_unwind_entry = 0;

/* These are used to create the unwind table entry for this function.  */
static symbolS *proc_start = 0;
static symbolS *proc_end = 0;
static symbolS *unwind_info = 0;
static symbolS *personality_routine = 0;
d606 1
a606 2
static void dot_savesp PARAMS ((int));
static void dot_savepsp PARAMS ((int));
d637 1
d830 1
a830 1
  int r;
a836 7
  if (rtype == prologue)
    r = 0;
  else
    if (rtype == body)
      r = 1;
    else
      as_bad ("record type is not valid");
d838 5
d870 1
a870 1
  int r, count;
d877 5
a881 7
  if (rtype == prologue)
    r = 0;
  else
    if (rtype == body)
      r = 1;
    else
      as_bad ("record type is not valid");
d917 1
a917 1
  int r;
d967 1
a967 1
output_P4_format (f, count, imask)
d969 2
a970 2
     int count;
     char *imask;
d972 2
a973 5
  char *bytes;
  bytes = alloca (count + 1);
  bytes[0] = UNW_P4;
  memcpy (bytes + 1, imask, count);
  (*f) (count + 1, bytes, NULL);
d999 6
a1004 8
  int r;
  if (rtype == fr_mem)
    r = 0;
  else
    if (rtype == gr_mem)
      r = 1;
    else
      as_bad ("Invalid record type for format P6");
d1018 1
a1018 1
  int r;
d1071 2
d1085 1
a1085 1
  int r;
d1147 2
d1188 1
a1188 1
  int r;
d1194 4
a1197 7
  if (rtype == label_state)
    r = 0;
  else
    if (rtype == copy_state)
      r = 1;
    else
      as_bad ("Invalid record type for format B1");
d1247 1
a1247 1
  int r;
d1254 5
a1258 7
  if (rtype == label_state)
    r = 0;
  else
    if (rtype == copy_state)
      r = 1;
    else
      as_bad ("Invalid record type for format B1");
d1266 2
a1267 2
format_a_b_reg (a, b, reg)
  int a, b;
d1271 1
a1271 2
  a = (a & 1);
  b = (b & 1);
d1273 1
a1273 1
  ret = (a << 6) | (a << 5) | reg;
d1278 1
a1278 1
output_X1_format (f, rtype, a, b, reg, t, w1)
d1281 1
a1281 1
     int a, b, reg;
d1286 1
a1286 1
  int r;
d1289 6
a1294 8
  if (rtype == spill_psprel)
    r = 0;
  else
    if (rtype = spill_sprel)
      r = 1;
    else
      as_bad ("Invalid record type for format X1");
  bytes[1] = ((r << 7) | format_a_b_reg (a, b, reg));
d1301 1
a1301 1
output_X2_format (f, a, b, reg, x, y, treg, t)
d1303 1
a1303 1
     int a, b, reg;
a1307 1
  int r;
d1310 1
a1310 1
  bytes[1] = (((x & 1) << 7) | format_a_b_reg (a, b, reg));
d1317 1
a1317 1
output_X3_format (f, rtype, qp, a, b, reg, t, w1)
d1321 1
a1321 1
     int a, b, reg;
d1326 1
a1326 1
  int r;
d1328 6
a1333 8
  bytes[0] = UNW_X1;
  if (rtype == spill_psprel_p)
    r = 0;
  else
    if (rtype = spill_sprel_p)
      r = 1;
    else
      as_bad ("Invalid record type for format X1");
d1335 1
a1335 1
  bytes[2] = format_a_b_reg (a, b, reg);
d1342 1
a1342 1
output_X4_format (f, qp, a, b, reg, x, y, treg, t)
d1345 1
a1345 1
     int a, b, reg;
a1349 1
  int r;
d1351 1
a1351 1
  bytes[0] = UNW_X2;
d1353 1
a1353 1
  bytes[2] = (((x & 1) << 7) | format_a_b_reg (a, b, reg));
a1370 7
/* This function frees a record list structure.  */
static void
free_record (unw_rec_list *ptr)
{
  free (ptr);
}

d1379 5
d1393 1
d1403 2
a1404 1
  ptr->r.record.r.mask = saved_mask;
d1446 1
a1446 1
  ptr->r.record.p.spoff = offset;
d1480 1
a1480 1
  ptr->r.record.p.pspoff = offset;
d1489 1
a1489 1
  ptr->r.record.p.spoff = offset;
d1514 1
a1514 1
  ptr->r.record.p.pspoff = offset;
d1523 1
a1523 1
  ptr->r.record.p.spoff = offset;
d1548 1
a1548 1
  ptr->r.record.p.pspoff = offset;
d1557 1
a1557 1
  ptr->r.record.p.spoff = offset;
d1625 1
a1625 12
  ptr->r.record.p.pspoff = offset;
  return ptr;
}

static unw_rec_list *
output_spill_mask ()
{
/* TODO - how to implement this record.... I guess GAS could fill in the
   correct fields from the record list and construct one of these
   after the symbols have been resolved and we know how big the
   region is.  This could be done in fixup_unw_records.  */
  unw_rec_list *ptr = NULL;
d1650 1
a1650 1
  ptr->r.record.p.pspoff = offset;
d1659 1
a1659 1
  ptr->r.record.p.spoff = offset;
d1684 1
a1684 1
  ptr->r.record.p.pspoff = offset;
d1693 1
a1693 1
  ptr->r.record.p.spoff = offset;
d1718 1
a1718 1
  ptr->r.record.p.pspoff = offset;
d1727 1
a1727 1
  ptr->r.record.p.spoff = offset;
d1759 1
a1759 1
  ptr->r.record.p.pspoff = offset;
d1768 1
a1768 1
  ptr->r.record.p.spoff = offset;
d1793 1
a1793 1
  ptr->r.record.p.pspoff = offset;
d1802 1
a1802 1
  ptr->r.record.p.spoff = offset;
d1827 1
a1827 1
  ptr->r.record.p.pspoff = offset;
d1836 1
a1836 1
  ptr->r.record.p.spoff = offset;
d1861 1
a1861 1
  ptr->r.record.p.pspoff = offset;
d1870 1
a1870 1
  ptr->r.record.p.spoff = offset;
d1875 3
a1877 1
output_epilogue ()
d1879 3
a1881 1
  unw_rec_list *ptr = NULL;
d1886 1
a1886 1
output_label_state ()
d1888 2
a1889 1
  unw_rec_list *ptr = NULL;
d1894 1
a1894 1
output_copy_state ()
d1896 2
a1897 1
  unw_rec_list *ptr = NULL;
d1902 10
a1911 1
output_spill_psprel (reg, offset)
d1916 1
d1918 1
a1918 1
  ptr->r.record.x.pspoff = offset;
d1923 2
a1924 1
output_spill_sprel (reg, offset)
d1929 1
d1931 1
a1931 1
  ptr->r.record.x.spoff = offset;
d1936 2
a1937 1
output_spill_psprel_p (reg, offset, predicate)
d1943 1
d1945 1
a1945 1
  ptr->r.record.x.pspoff = offset;
d1951 2
a1952 1
output_spill_sprel_p (reg, offset, predicate)
d1958 1
d1960 1
a1960 1
  ptr->r.record.x.spoff = offset;
d1966 2
a1967 1
output_spill_reg (reg, targ_reg, xy)
d1973 1
d1981 2
a1982 1
output_spill_reg_p (reg, targ_reg, xy, predicate)
d1989 1
d2004 2
d2008 8
d2017 30
a2049 4
      case prologue_gr:
	output_R2_format (f, ptr->r.record.r.mask, 
			  ptr->r.record.r.grsave, ptr->r.record.r.rlen);
	break;
a2102 7
      case fr_mem:
      case gr_mem:
	output_P6_format (f, ptr->r.type, ptr->r.record.p.rmask);
	break;
      case frgr_mem:
	output_P5_format (f, ptr->r.record.p.grmask, ptr->r.record.p.frmask);
	break;
a2105 3
      case br_mem:
	output_P1_format (f, ptr->r.record.p.brmask);
	break;
d2125 3
d2129 1
a2129 1
	as_bad ("epilogue record unimplemented.");
a2131 2
	as_bad ("label_state record unimplemented.");
	break;
d2133 1
a2133 1
	as_bad ("copy_state record unimplemented.");
d2136 4
d2141 4
d2146 4
d2151 4
d2156 4
d2161 4
a2164 1
	as_bad ("spill_* record unimplemented.");
d2194 76
d2278 3
a2280 2
  unw_rec_list *ptr;
  unsigned long first_addr = 0;
d2285 1
d2293 1
a2293 1
	      int size;
d2295 1
d2300 9
a2308 4
	      for (last = ptr; last->next != NULL; last = last->next)
		if (last->next->r.type == prologue
		    || last->next->r.type == prologue_gr
		    || last->next->r.type == body)
d2310 28
d2340 3
a2342 3
	      last_addr = last->slot_number;
	      size = ((last_addr - first_addr) / 16) * 3 + last_addr % 4;
	      ptr->r.record.r.rlen = size;
d2345 4
d2362 70
a2431 8
	    {
	      /* All the time fields.  */
	      int x = ptr->slot_number - first_addr;
	      ptr->r.record.p.t = (x / 16) * 3 + (ptr->slot_number % 4);
	      break;
	    }
	  /* TODO. We also need to combine all the register masks into a single
	     record. (Ie, all the save.g save.gf, save.f and save.br's)  */
d2472 85
d2586 2
a2587 2
  if (unwind_tail)
    unwind_tail->next = ptr;
d2589 2
a2590 2
    unwind_list = ptr;
  unwind_tail = ptr;
d2593 2
a2594 2
  if (current_unwind_entry == NULL)
    current_unwind_entry = ptr;
d2602 1
d2608 13
d2622 2
a2623 1
      add_unwind_entry (output_mem_stack_f (e.X_add_number));
d2625 2
d2630 17
a2646 1
dot_vframe (dummy)
d2649 10
a2658 1
  discard_rest_of_line ();
d2674 1
a2674 1
  reg1 = e1.X_add_number - REG_AR;
d2678 1
a2678 2
  if (e1.X_op == O_register 
      && ((reg1 >=0 && reg1 < 128) || reg1 == REG_BR - REG_AR))
d2684 1
a2684 1
	      case 17:		/* ar.bsp */
d2688 1
a2688 1
	      case 18:		/* ar.bspstore */
d2692 1
a2692 1
	      case 19:		/* ar.rnat */
d2696 1
a2696 1
	      case 36:		/* ar.unat */
d2700 1
a2700 1
	      case 40:		/* ar.fpsr */
d2704 1
a2704 1
	      case 64:		/* ar.pfs */
d2708 1
a2708 1
	      case 65:		/* ar.lc */
d2712 1
a2712 1
	      case REG_BR - REG_AR:	/* rp  */
d2716 8
d2725 1
a2725 1
	        as_bad ("first operand is unknown application register");
d2732 1
a2732 1
    as_bad ("First operand not a valid register");
d2739 71
a2809 1
  discard_rest_of_line ();
a2816 1
  int x;
d2819 3
a2821 3
  size = output_unw_records (unwind_list, &unw_rec);
  if (size % 4 != 0)
    as_bad ("Unwind record is ont a multiple of 4 bytes.");
a2825 1
      int x;
a2826 1
      unsigned char *personality;
a2827 1
      char *save;
d2831 1
a2831 1
      unwind_info = expr_build_dot ();
d2842 1
a2842 1
      if (personality_routine != 0)
d2845 1
a2845 1
	  exp.X_add_symbol = personality_routine;
d2849 1
a2849 1
	  personality_routine = 0;
d2854 2
a2855 2
  free_list_records (unwind_list);
  unwind_list = unwind_tail = current_unwind_entry = NULL;
d2865 1
d2872 1
a2872 1
  discard_rest_of_line ();
d2879 9
a2887 1
  discard_rest_of_line ();
d2891 2
a2892 2
dot_savesp (dummy)
     int dummy;
d2900 1
a2900 1
    as_bad ("No second operand to .savesp");
d2903 1
a2903 1
  reg1 = e1.X_add_number - REG_AR;
d2907 1
a2907 2
  if (e1.X_op == O_register 
      && ((reg1 >=0 && reg1 < 128) || reg1 == REG_BR - REG_AR || reg1 == REG_PR - REG_AR))
d2913 1
a2913 1
	      case 17:		/* ar.bsp */
d2915 3
a2917 1
	        add_unwind_entry (output_bsp_sprel (val));
d2919 1
a2919 1
	      case 18:		/* ar.bspstore */
d2921 3
a2923 1
	        add_unwind_entry (output_bspstore_sprel (val));
d2925 1
a2925 1
	      case 19:		/* ar.rnat */
d2927 3
a2929 1
	        add_unwind_entry (output_rnat_sprel (val));
d2931 1
a2931 1
	      case 36:		/* ar.unat */
d2933 3
a2935 1
	        add_unwind_entry (output_unat_sprel (val));
d2937 1
a2937 1
	      case 40:		/* ar.fpsr */
d2939 3
a2941 1
	        add_unwind_entry (output_fpsr_sprel (val));
d2943 1
a2943 1
	      case 64:		/* ar.pfs */
d2945 3
a2947 1
	        add_unwind_entry (output_pfs_sprel (val));
d2949 1
a2949 1
	      case 65:		/* ar.lc */
d2951 3
a2953 1
	        add_unwind_entry (output_lc_sprel (val));
d2955 1
a2955 1
	      case REG_BR - REG_AR:	/* rp  */
d2957 3
a2959 1
		add_unwind_entry (output_rp_sprel (val));
d2961 1
a2961 1
	      case REG_PR - REG_AR:     /* Predicate registers.  */
d2963 9
a2971 1
		add_unwind_entry (output_preds_sprel (val));
d2974 1
a2974 1
	        as_bad ("first operand is unknown application register");
d2981 1
a2981 8
    as_bad ("First operand not a valid register");
}

static void 
dot_savepsp (dummy)
     int dummy;
{
  discard_rest_of_line ();
d3016 1
a3016 1
  expressionS e1, e2;
d3023 1
a3023 4
    {
      int frmask = e1.X_add_number;
      add_unwind_entry (output_fr_mem (e1.X_add_number));
    }
d3030 5
a3034 2
  expressionS e1;
  int sep;
a3035 1
  
a3036 2
    as_bad ("Operand to .save.b must be a constant.");
  else
d3038 15
a3052 2
      int brmask = e1.X_add_number;
      add_unwind_entry (output_br_mem (brmask));
d3054 5
d3086 5
a3090 1
  parse_operand (&e);
d3095 177
d3273 2
a3274 1
      add_unwind_entry (output_spill_base (e.X_add_number));
d3276 16
d3298 26
a3323 1
  discard_rest_of_line ();
d3335 1
a3335 1
  personality_routine = symbol_find_or_make (name);
d3348 2
a3349 2
  proc_start = expr_build_dot ();
  /* Parse names of main and alternate entry points and mark them s
d3358 1
a3358 1
      if (proc_start == 0)
d3360 1
a3360 1
	  proc_start = sym;
d3372 2
a3373 2
  unwind_list = unwind_tail = current_unwind_entry = NULL;
  personality_routine = 0;
d3380 1
a3380 1
  unwind_prologue = 0;
d3382 1
d3389 4
a3392 3
  unwind_prologue = 1;
  SKIP_WHITESPACE ();
  if (! is_end_of_line[(unsigned char) *input_line_pointer])
a3394 1
      char sep;
d3399 2
a3425 1
  int size;
d3440 1
a3440 1
  if (unwind_info == 0)
d3446 1
a3446 1
  proc_end = expr_build_dot ();
d3456 1
a3456 1
  e.X_add_symbol = proc_start;
d3462 1
a3462 1
  e.X_add_symbol = proc_end;
d3465 1
a3465 1
  if (unwind_info != 0)
d3470 1
a3470 1
      e.X_add_symbol = unwind_info;
d3477 1
a3477 1
  proc_start = proc_end = unwind_info = 0;
d4146 2
d4150 2
d4154 3
a4156 3
    { "alprp", dot_altrp },
    { "savesp", dot_savesp },
    { "savepsp", dot_savepsp },
d4162 8
d5070 1
d5112 19
d5332 1
a5332 1
	  md.slot[curr].unwind_record->slot_number = (unsigned long) (f + i);
d5335 1
d5730 3
d8424 1
a8424 1
  if (current_unwind_entry)
d8426 2
a8427 2
      CURR_SLOT.unwind_record = current_unwind_entry;
      current_unwind_entry = NULL;
d8464 1
d8530 5
d8536 3
a8538 1
	  as_bad ("Unknown pseudo function `%s'", input_line_pointer - 1);
@


1.3
log
@Unwind info bug fixes from David Mosberger.
	* config/tc-ia64.c (output_P7_format, case mem_stack_f): Output fixed
	frame size in units of 16 bytes, as required per SW Conventions manual.
	(output_unw_records): Output info-block header as a dword to get
	byte-order right.
@
text
@d80 1
d438 1
d4008 5
a4012 3
          else 
            /* FIXME -- use appropriate relocation type */
            as_bad (_("long branch targets not implemented"));
d4229 14
a4242 1
      if (idesc->operands[i] == IA64_OPND_IMMU64)
d4244 1
a4244 1
	  val = slot->opnd[i].X_add_number;
d4249 4
a4252 4
	}
      else if (idesc->operands[i] == IA64_OPND_IMMU62)
        {
          val = slot->opnd[i].X_add_number & 0x3fffffffffffffffULL;
d4257 62
a4318 11
        }
      else if (idesc->operands[i] == IA64_OPND_TGT64)
        {
          // FIXME -- need to implement the target address encoding properly
          as_bad (_("long branch target encoding not implemented"));
          *insnp++ = 0;
        }
      else if (slot->opnd[i].X_op == O_register
	       || slot->opnd[i].X_op == O_constant
	       || slot->opnd[i].X_op == O_index
	       || slot->opnd[i].X_op == O_big)
d4320 2
a4321 1
	  if (slot->opnd[i].X_op == O_big)
d4323 2
a4324 3
	      /* This must be the value 0x10000000000000000.  */
	      assert (idesc->operands[i] == IA64_OPND_IMM8M1U8);
	      val = 0;
d4326 3
a4328 4
	  else
	    val = slot->opnd[i].X_add_number;

	  switch (idesc->operands[i])
d4330 2
a4331 42
	    case IA64_OPND_AR3:				val -= REG_AR; break;
	    case IA64_OPND_B1: case IA64_OPND_B2:	val -= REG_BR; break;
	    case IA64_OPND_CR3:				val -= REG_CR; break;
	    case IA64_OPND_F1: case IA64_OPND_F2:
	    case IA64_OPND_F3: case IA64_OPND_F4:	val -= REG_FR; break;
	    case IA64_OPND_P1: case IA64_OPND_P2:	val -= REG_P;  break;

	    case IA64_OPND_R1:	     case IA64_OPND_R2:
	    case IA64_OPND_R3:       case IA64_OPND_R3_2:
	    case IA64_OPND_CPUID_R3: case IA64_OPND_DBR_R3:
	    case IA64_OPND_DTR_R3:   case IA64_OPND_ITR_R3:
	    case IA64_OPND_IBR_R3:   case IA64_OPND_MR3:
	    case IA64_OPND_MSR_R3:   case IA64_OPND_PKR_R3:
	    case IA64_OPND_PMC_R3:   case IA64_OPND_PMD_R3:
	    case IA64_OPND_RR_R3:    
	      val -= REG_GR;
	      break;

	    default:
	      break;
	    }
	  odesc = elf64_ia64_operands + idesc->operands[i];
	  err = (*odesc->insert) (odesc, val, &insn);
	  if (err)
	    as_bad_where (slot->src_file, slot->src_line,
			  "Bad operand value: %s", err);
	  if (idesc->flags & IA64_OPCODE_PSEUDO)
	    {
	      if ((idesc->flags & IA64_OPCODE_F2_EQ_F3)
		  && odesc == elf64_ia64_operands + IA64_OPND_F3)
		{
		  o2desc = elf64_ia64_operands + IA64_OPND_F2;
		  (*o2desc->insert) (o2desc, val, &insn);
		      
		}
	      if ((idesc->flags & IA64_OPCODE_LEN_EQ_64MCNT)
		  && (odesc == elf64_ia64_operands + IA64_OPND_CPOS6a
		      || odesc == elf64_ia64_operands + IA64_OPND_POS6))
		{
		  o2desc = elf64_ia64_operands + IA64_OPND_LEN6;
		  (*o2desc->insert) (o2desc, 64 - val, &insn);
		}
d4827 4
d7994 13
d8110 1
a8110 1
  /* bundles are always in little-endian byte order */
d8118 2
a8119 2
  err = (*odesc->insert) (odesc, value, insn + slot);
  if (err)
d8121 20
a8140 2
      as_bad_where (fix->fx_file, fix->fx_line, err);
      return;
d8142 5
a8151 1
  
@


1.2
log
@Clean up F-unit assembly and tests.
@
text
@d1013 2
a1014 2
        r = 0;
	count += output_leb128 (bytes + count, w2, 0);
d2216 4
a2219 5
  md_number_to_chars (mem, 1, 2);	/* version number. */
  md_number_to_chars (mem + 2, 0x03, 2);  /* Set E and U handler bits.  */    

  /* Length in double words.  */
  md_number_to_chars (mem + 4, (size + extra) / 8, 4);
@


1.1
log
@IA-64 ELF support.
@
text
@d451 1
a451 1
    { "natval",	PSEUDO_FUNC_CONST, { 0x100 } },
d460 2
a3819 1
    case IA64_OPND_IMMU9:
d3829 12
@

