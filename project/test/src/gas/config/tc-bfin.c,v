head	1.42;
access;
symbols
	binutils-2_24-branch:1.42.0.8
	binutils-2_24-branchpoint:1.42
	binutils-2_21_1:1.41
	binutils-2_23_2:1.42
	binutils-2_23_1:1.42
	binutils-2_23:1.42
	binutils-2_23-branch:1.42.0.6
	binutils-2_23-branchpoint:1.42
	binutils-2_22_branch:1.42.0.4
	binutils-2_22:1.42
	binutils-2_22-branch:1.42.0.2
	binutils-2_22-branchpoint:1.42
	binutils-2_21:1.41
	binutils-2_21-branch:1.41.0.2
	binutils-2_21-branchpoint:1.41
	binutils-2_20_1:1.31
	binutils-2_20:1.31
	binutils-arc-20081103-branch:1.20.0.4
	binutils-arc-20081103-branchpoint:1.20
	binutils-2_20-branch:1.31.0.2
	binutils-2_20-branchpoint:1.31
	dje-cgen-play1-branch:1.21.0.2
	dje-cgen-play1-branchpoint:1.21
	arc-20081103-branch:1.20.0.2
	arc-20081103-branchpoint:1.20
	binutils-2_19_1:1.18
	binutils-2_19:1.18
	binutils-2_19-branch:1.18.0.2
	binutils-2_19-branchpoint:1.18
	binutils-2_18:1.10
	binutils-2_18-branch:1.10.0.2
	binutils-2_18-branchpoint:1.10
	binutils-csl-coldfire-4_1-32:1.4.2.1
	binutils-csl-sourcerygxx-4_1-32:1.4.2.1
	binutils-csl-innovasic-fido-3_4_4-33:1.4.2.1
	binutils-csl-coldfire-4_1-30:1.4.2.1
	binutils-csl-sourcerygxx-4_1-30:1.4.2.1
	binutils-csl-coldfire-4_1-28:1.4.2.1
	binutils-csl-sourcerygxx-4_1-29:1.4.2.1
	binutils-csl-sourcerygxx-4_1-28:1.4.2.1
	binutils-csl-arm-2006q3-27:1.4.2.1
	binutils-csl-sourcerygxx-4_1-27:1.4.2.1
	binutils-csl-arm-2006q3-26:1.4.2.1
	binutils-csl-sourcerygxx-4_1-26:1.4.2.1
	binutils-csl-sourcerygxx-4_1-25:1.4.2.1
	binutils-csl-sourcerygxx-4_1-24:1.4.2.1
	binutils-csl-sourcerygxx-4_1-23:1.4.2.1
	binutils-csl-sourcerygxx-4_1-21:1.4.2.1
	binutils-csl-arm-2006q3-21:1.4.2.1
	binutils-csl-sourcerygxx-4_1-22:1.4.2.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.4.2.1
	binutils-csl-sourcerygxx-4_1-20:1.4.2.1
	binutils-csl-arm-2006q3-19:1.4.2.1
	binutils-csl-sourcerygxx-4_1-19:1.4.2.1
	binutils-csl-sourcerygxx-4_1-18:1.4.2.1
	binutils-csl-renesas-4_1-9:1.4.2.1
	binutils-csl-renesas-4_1-8:1.4
	binutils-csl-renesas-4_1-7:1.4
	binutils-csl-renesas-4_1-6:1.4
	binutils-csl-sourcerygxx-4_1-17:1.4
	binutils-csl-sourcerygxx-4_1-14:1.4
	binutils-csl-sourcerygxx-4_1-15:1.4
	binutils-csl-sourcerygxx-4_1-13:1.4
	binutils-2_17:1.5
	binutils-csl-sourcerygxx-4_1-12:1.4
	binutils-csl-sourcerygxx-3_4_4-21:1.4
	binutils-csl-sourcerygxx-4_1-9:1.4
	binutils-csl-sourcerygxx-4_1-8:1.4
	binutils-csl-sourcerygxx-4_1-7:1.4
	binutils-csl-arm-2006q1-6:1.4
	binutils-csl-sourcerygxx-4_1-6:1.4
	binutils-csl-coldfire-4_1-11:1.4
	binutils-csl-sourcerygxx-3_4_4-19:1.4
	binutils-csl-coldfire-4_1-10:1.4
	binutils-csl-sourcerygxx-4_1-5:1.4
	binutils-csl-sourcerygxx-4_1-4:1.4
	binutils-csl-morpho-4_1-4:1.4
	binutils-csl-sourcerygxx-3_4_4-17:1.4
	binutils-2_17-branch:1.5.0.2
	binutils-2_17-branchpoint:1.5
	binutils-csl-2_17-branch:1.4.0.2
	binutils-csl-2_17-branchpoint:1.4
	binutils_latest_snapshot:1.42;
locks; strict;
comment	@ * @;


1.42
date	2011.03.15.00.17.00;	author vapier;	state Exp;
branches;
next	1.41;

1.41
date	2010.10.11.08.36.30;	author vapier;	state Exp;
branches;
next	1.40;

1.40
date	2010.10.11.08.35.53;	author vapier;	state Exp;
branches;
next	1.39;

1.39
date	2010.09.22.20.59.00;	author vapier;	state Exp;
branches;
next	1.38;

1.38
date	2010.09.22.20.19.53;	author vapier;	state Exp;
branches;
next	1.37;

1.37
date	2010.09.22.20.17.49;	author vapier;	state Exp;
branches;
next	1.36;

1.36
date	2010.09.22.19.17.19;	author vapier;	state Exp;
branches;
next	1.35;

1.35
date	2010.03.10.14.23.58;	author vapier;	state Exp;
branches;
next	1.34;

1.34
date	2010.03.10.13.03.29;	author vapier;	state Exp;
branches;
next	1.33;

1.33
date	2010.03.10.03.57.00;	author jiez;	state Exp;
branches;
next	1.32;

1.32
date	2009.12.11.13.42.10;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	2009.09.04.04.29.40;	author jiez;	state Exp;
branches;
next	1.30;

1.30
date	2009.09.03.18.03.38;	author jiez;	state Exp;
branches;
next	1.29;

1.29
date	2009.09.03.17.42.52;	author jiez;	state Exp;
branches;
next	1.28;

1.28
date	2009.09.03.16.32.40;	author jiez;	state Exp;
branches;
next	1.27;

1.27
date	2009.09.03.15.36.01;	author jiez;	state Exp;
branches;
next	1.26;

1.26
date	2009.09.02.07.24.20;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2009.09.01.05.56.30;	author jiez;	state Exp;
branches;
next	1.24;

1.24
date	2009.09.01.00.24.01;	author jiez;	state Exp;
branches;
next	1.23;

1.23
date	2009.08.11.18.44.12;	author bernds;	state Exp;
branches;
next	1.22;

1.22
date	2009.08.11.18.28.29;	author bernds;	state Exp;
branches;
next	1.21;

1.21
date	2009.06.22.17.56.01;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	2008.10.21.00.26.17;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2008.10.20.01.03.50;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2008.08.12.23.39.30;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2008.07.22.08.34.16;	author jiez;	state Exp;
branches;
next	1.16;

1.16
date	2008.04.23.18.40.34;	author vapier;	state Exp;
branches;
next	1.15;

1.15
date	2008.03.26.16.33.33;	author bernds;	state Exp;
branches;
next	1.14;

1.14
date	2007.10.17.16.45.55;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2007.10.08.15.26.42;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2007.10.08.10.09.58;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2007.10.08.10.05.28;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2007.07.03.11.01.04;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2006.06.07.11.27.57;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2006.05.23.06.01.12;	author jiez;	state Exp;
branches;
next	1.7;

1.7
date	2006.05.23.04.23.41;	author jiez;	state Exp;
branches;
next	1.6;

1.6
date	2006.04.23.22.12.43;	author kazu;	state Exp;
branches;
next	1.5;

1.5
date	2006.03.26.01.12.07;	author bernds;	state Exp;
branches;
next	1.4;

1.4
date	2005.10.24.18.35.59;	author bernds;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2005.10.24.16.31.22;	author jiez;	state Exp;
branches;
next	1.2;

1.2
date	2005.10.19.13.15.01;	author jiez;	state Exp;
branches;
next	1.1;

1.1
date	2005.09.30.15.05.06;	author clm;	state Exp;
branches;
next	;

1.4.2.1
date	2006.08.22.15.08.35;	author jsm28;	state Exp;
branches;
next	;


desc
@@


1.42
log
@gas: blackfin: add support for bf54x-0.4

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@/* tc-bfin.c -- Assembler for the ADI Blackfin.
   Copyright 2005, 2006, 2007, 2008, 2009, 2010
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include "as.h"
#include "struc-symbol.h"
#include "bfin-defs.h"
#include "obstack.h"
#include "safe-ctype.h"
#ifdef OBJ_ELF
#include "dwarf2dbg.h"
#endif
#include "libbfd.h"
#include "elf/common.h"
#include "elf/bfin.h"

extern int yyparse (void);
struct yy_buffer_state;
typedef struct yy_buffer_state *YY_BUFFER_STATE;
extern YY_BUFFER_STATE yy_scan_string (const char *yy_str);
extern void yy_delete_buffer (YY_BUFFER_STATE b);
static parse_state parse (char *line);

/* Global variables. */
struct bfin_insn *insn;
int last_insn_size;

extern struct obstack mempool;
FILE *errorf;

/* Flags to set in the elf header */
#define DEFAULT_FLAGS 0

#ifdef OBJ_FDPIC_ELF
# define DEFAULT_FDPIC EF_BFIN_FDPIC
#else
# define DEFAULT_FDPIC 0
#endif

static flagword bfin_flags = DEFAULT_FLAGS | DEFAULT_FDPIC;
static const char *bfin_pic_flag = DEFAULT_FDPIC ? "-mfdpic" : (const char *)0;

/* Blackfin specific function to handle FD-PIC pointer initializations.  */

static void
bfin_pic_ptr (int nbytes)
{
  expressionS exp;
  char *p;

  if (nbytes != 4)
    abort ();

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  if (is_it_end_of_statement ())
    {
      demand_empty_rest_of_line ();
      return;
    }

#ifdef md_cons_align
  md_cons_align (nbytes);
#endif

  do
    {
      bfd_reloc_code_real_type reloc_type = BFD_RELOC_BFIN_FUNCDESC;

      if (strncasecmp (input_line_pointer, "funcdesc(", 9) == 0)
	{
	  input_line_pointer += 9;
	  expression (&exp);
	  if (*input_line_pointer == ')')
	    input_line_pointer++;
	  else
	    as_bad (_("missing ')'"));
	}
      else
	error ("missing funcdesc in picptr");

      p = frag_more (4);
      memset (p, 0, 4);
      fix_new_exp (frag_now, p - frag_now->fr_literal, 4, &exp, 0,
		   reloc_type);
    }
  while (*input_line_pointer++ == ',');

  input_line_pointer--;			/* Put terminator back into stream. */
  demand_empty_rest_of_line ();
}

static void
bfin_s_bss (int ignore ATTRIBUTE_UNUSED)
{
  register int temp;

  temp = get_absolute_expression ();
  subseg_set (bss_section, (subsegT) temp);
  demand_empty_rest_of_line ();
}

const pseudo_typeS md_pseudo_table[] = {
  {"align", s_align_bytes, 0},
  {"byte2", cons, 2},
  {"byte4", cons, 4},
  {"picptr", bfin_pic_ptr, 4},
  {"code", obj_elf_section, 0},
  {"db", cons, 1},
  {"dd", cons, 4},
  {"dw", cons, 2},
  {"p", s_ignore, 0},
  {"pdata", s_ignore, 0},
  {"var", s_ignore, 0},
  {"bss", bfin_s_bss, 0},
  {0, 0, 0}
};

/* Characters that are used to denote comments and line separators. */
const char comment_chars[] = "#";
const char line_comment_chars[] = "#";
const char line_separator_chars[] = ";";

/* Characters that can be used to separate the mantissa from the
   exponent in floating point numbers. */
const char EXP_CHARS[] = "eE";

/* Characters that mean this number is a floating point constant.
   As in 0f12.456 or  0d1.2345e12.  */
const char FLT_CHARS[] = "fFdDxX";

typedef enum bfin_cpu_type
{
  BFIN_CPU_UNKNOWN,
  BFIN_CPU_BF504,
  BFIN_CPU_BF506,
  BFIN_CPU_BF512,
  BFIN_CPU_BF514,
  BFIN_CPU_BF516,
  BFIN_CPU_BF518,
  BFIN_CPU_BF522,
  BFIN_CPU_BF523,
  BFIN_CPU_BF524,
  BFIN_CPU_BF525,
  BFIN_CPU_BF526,
  BFIN_CPU_BF527,
  BFIN_CPU_BF531,
  BFIN_CPU_BF532,
  BFIN_CPU_BF533,
  BFIN_CPU_BF534,
  BFIN_CPU_BF536,
  BFIN_CPU_BF537,
  BFIN_CPU_BF538,
  BFIN_CPU_BF539,
  BFIN_CPU_BF542,
  BFIN_CPU_BF542M,
  BFIN_CPU_BF544,
  BFIN_CPU_BF544M,
  BFIN_CPU_BF547,
  BFIN_CPU_BF547M,
  BFIN_CPU_BF548,
  BFIN_CPU_BF548M,
  BFIN_CPU_BF549,
  BFIN_CPU_BF549M,
  BFIN_CPU_BF561,
  BFIN_CPU_BF592,
} bfin_cpu_t;

bfin_cpu_t bfin_cpu_type = BFIN_CPU_UNKNOWN;
/* -msi-revision support. There are three special values:
   -1      -msi-revision=none.
   0xffff  -msi-revision=any.  */
int bfin_si_revision;

unsigned int bfin_anomaly_checks = 0;

struct bfin_cpu
{
  const char *name;
  bfin_cpu_t type;
  int si_revision;
  unsigned int anomaly_checks;
};

struct bfin_cpu bfin_cpus[] =
{
  {"bf504", BFIN_CPU_BF504, 0x0000, AC_05000074},

  {"bf506", BFIN_CPU_BF506, 0x0000, AC_05000074},

  {"bf512", BFIN_CPU_BF512, 0x0002, AC_05000074},
  {"bf512", BFIN_CPU_BF512, 0x0001, AC_05000074},
  {"bf512", BFIN_CPU_BF512, 0x0000, AC_05000074},

  {"bf514", BFIN_CPU_BF514, 0x0002, AC_05000074},
  {"bf514", BFIN_CPU_BF514, 0x0001, AC_05000074},
  {"bf514", BFIN_CPU_BF514, 0x0000, AC_05000074},

  {"bf516", BFIN_CPU_BF516, 0x0002, AC_05000074},
  {"bf516", BFIN_CPU_BF516, 0x0001, AC_05000074},
  {"bf516", BFIN_CPU_BF516, 0x0000, AC_05000074},

  {"bf518", BFIN_CPU_BF518, 0x0002, AC_05000074},
  {"bf518", BFIN_CPU_BF518, 0x0001, AC_05000074},
  {"bf518", BFIN_CPU_BF518, 0x0000, AC_05000074},

  {"bf522", BFIN_CPU_BF522, 0x0002, AC_05000074},
  {"bf522", BFIN_CPU_BF522, 0x0001, AC_05000074},
  {"bf522", BFIN_CPU_BF522, 0x0000, AC_05000074},

  {"bf523", BFIN_CPU_BF523, 0x0002, AC_05000074},
  {"bf523", BFIN_CPU_BF523, 0x0001, AC_05000074},
  {"bf523", BFIN_CPU_BF523, 0x0000, AC_05000074},

  {"bf524", BFIN_CPU_BF524, 0x0002, AC_05000074},
  {"bf524", BFIN_CPU_BF524, 0x0001, AC_05000074},
  {"bf524", BFIN_CPU_BF524, 0x0000, AC_05000074},

  {"bf525", BFIN_CPU_BF525, 0x0002, AC_05000074},
  {"bf525", BFIN_CPU_BF525, 0x0001, AC_05000074},
  {"bf525", BFIN_CPU_BF525, 0x0000, AC_05000074},

  {"bf526", BFIN_CPU_BF526, 0x0002, AC_05000074},
  {"bf526", BFIN_CPU_BF526, 0x0001, AC_05000074},
  {"bf526", BFIN_CPU_BF526, 0x0000, AC_05000074},

  {"bf527", BFIN_CPU_BF527, 0x0002, AC_05000074},
  {"bf527", BFIN_CPU_BF527, 0x0001, AC_05000074},
  {"bf527", BFIN_CPU_BF527, 0x0000, AC_05000074},

  {"bf531", BFIN_CPU_BF531, 0x0006, AC_05000074},
  {"bf531", BFIN_CPU_BF531, 0x0005, AC_05000074},
  {"bf531", BFIN_CPU_BF531, 0x0004, AC_05000074},
  {"bf531", BFIN_CPU_BF531, 0x0003, AC_05000074},

  {"bf532", BFIN_CPU_BF532, 0x0006, AC_05000074},
  {"bf532", BFIN_CPU_BF532, 0x0005, AC_05000074},
  {"bf532", BFIN_CPU_BF532, 0x0004, AC_05000074},
  {"bf532", BFIN_CPU_BF532, 0x0003, AC_05000074},

  {"bf533", BFIN_CPU_BF533, 0x0006, AC_05000074},
  {"bf533", BFIN_CPU_BF533, 0x0005, AC_05000074},
  {"bf533", BFIN_CPU_BF533, 0x0004, AC_05000074},
  {"bf533", BFIN_CPU_BF533, 0x0003, AC_05000074},

  {"bf534", BFIN_CPU_BF534, 0x0003, AC_05000074},
  {"bf534", BFIN_CPU_BF534, 0x0002, AC_05000074},
  {"bf534", BFIN_CPU_BF534, 0x0001, AC_05000074},

  {"bf536", BFIN_CPU_BF536, 0x0003, AC_05000074},
  {"bf536", BFIN_CPU_BF536, 0x0002, AC_05000074},
  {"bf536", BFIN_CPU_BF536, 0x0001, AC_05000074},

  {"bf537", BFIN_CPU_BF537, 0x0003, AC_05000074},
  {"bf537", BFIN_CPU_BF537, 0x0002, AC_05000074},
  {"bf537", BFIN_CPU_BF537, 0x0001, AC_05000074},

  {"bf538", BFIN_CPU_BF538, 0x0005, AC_05000074},
  {"bf538", BFIN_CPU_BF538, 0x0004, AC_05000074},
  {"bf538", BFIN_CPU_BF538, 0x0003, AC_05000074},
  {"bf538", BFIN_CPU_BF538, 0x0002, AC_05000074},

  {"bf539", BFIN_CPU_BF539, 0x0005, AC_05000074},
  {"bf539", BFIN_CPU_BF539, 0x0004, AC_05000074},
  {"bf539", BFIN_CPU_BF539, 0x0003, AC_05000074},
  {"bf539", BFIN_CPU_BF539, 0x0002, AC_05000074},

  {"bf542m", BFIN_CPU_BF542M, 0x0003, AC_05000074},

  {"bf542", BFIN_CPU_BF542, 0x0004, AC_05000074},
  {"bf542", BFIN_CPU_BF542, 0x0002, AC_05000074},
  {"bf542", BFIN_CPU_BF542, 0x0001, AC_05000074},
  {"bf542", BFIN_CPU_BF542, 0x0000, AC_05000074},

  {"bf544m", BFIN_CPU_BF544M, 0x0003, AC_05000074},

  {"bf544", BFIN_CPU_BF544, 0x0004, AC_05000074},
  {"bf544", BFIN_CPU_BF544, 0x0002, AC_05000074},
  {"bf544", BFIN_CPU_BF544, 0x0001, AC_05000074},
  {"bf544", BFIN_CPU_BF544, 0x0000, AC_05000074},

  {"bf547m", BFIN_CPU_BF547M, 0x0003, AC_05000074},

  {"bf547", BFIN_CPU_BF547, 0x0004, AC_05000074},
  {"bf547", BFIN_CPU_BF547, 0x0002, AC_05000074},
  {"bf547", BFIN_CPU_BF547, 0x0001, AC_05000074},
  {"bf547", BFIN_CPU_BF547, 0x0000, AC_05000074},

  {"bf548m", BFIN_CPU_BF548M, 0x0003, AC_05000074},

  {"bf548", BFIN_CPU_BF548, 0x0004, AC_05000074},
  {"bf548", BFIN_CPU_BF548, 0x0002, AC_05000074},
  {"bf548", BFIN_CPU_BF548, 0x0001, AC_05000074},
  {"bf548", BFIN_CPU_BF548, 0x0000, AC_05000074},

  {"bf549m", BFIN_CPU_BF549M, 0x0003, AC_05000074},

  {"bf549", BFIN_CPU_BF549, 0x0004, AC_05000074},
  {"bf549", BFIN_CPU_BF549, 0x0002, AC_05000074},
  {"bf549", BFIN_CPU_BF549, 0x0001, AC_05000074},
  {"bf549", BFIN_CPU_BF549, 0x0000, AC_05000074},

  {"bf561", BFIN_CPU_BF561, 0x0005, AC_05000074},
  {"bf561", BFIN_CPU_BF561, 0x0003, AC_05000074},
  {"bf561", BFIN_CPU_BF561, 0x0002, AC_05000074},

  {"bf592", BFIN_CPU_BF592, 0x0001, AC_05000074},
  {"bf592", BFIN_CPU_BF592, 0x0000, AC_05000074},

  {NULL, 0, 0, 0}
};

/* Define bfin-specific command-line options (there are none). */
const char *md_shortopts = "";

#define OPTION_FDPIC		(OPTION_MD_BASE)
#define OPTION_NOPIC		(OPTION_MD_BASE + 1)
#define OPTION_MCPU		(OPTION_MD_BASE + 2)

struct option md_longopts[] =
{
  { "mcpu",		required_argument,	NULL, OPTION_MCPU	},
  { "mfdpic",		no_argument,		NULL, OPTION_FDPIC      },
  { "mnopic",		no_argument,		NULL, OPTION_NOPIC      },
  { "mno-fdpic",	no_argument,		NULL, OPTION_NOPIC      },
  { NULL,		no_argument,		NULL, 0                 },
};

size_t md_longopts_size = sizeof (md_longopts);


int
md_parse_option (int c ATTRIBUTE_UNUSED, char *arg ATTRIBUTE_UNUSED)
{
  switch (c)
    {
    default:
      return 0;

    case OPTION_MCPU:
      {
	const char *p, *q;
	int i;

	i = 0;
	while ((p = bfin_cpus[i].name) != NULL)
	  {
	    if (strncmp (arg, p, strlen (p)) == 0)
	      break;
	    i++;
	  }

	if (p == NULL)
	  as_fatal ("-mcpu=%s is not valid", arg);

	bfin_cpu_type = bfin_cpus[i].type;

	q = arg + strlen (p);

	if (*q == '\0')
	  {
	    bfin_si_revision = bfin_cpus[i].si_revision;
	    bfin_anomaly_checks |= bfin_cpus[i].anomaly_checks;
	  }
	else if (strcmp (q, "-none") == 0)
	  bfin_si_revision = -1;
      	else if (strcmp (q, "-any") == 0)
	  {
	    bfin_si_revision = 0xffff;
	    while (bfin_cpus[i].type == bfin_cpu_type)
	      {
		bfin_anomaly_checks |= bfin_cpus[i].anomaly_checks;
		i++;
	      }
	  }
	else
	  {
	    unsigned int si_major, si_minor;
	    int rev_len, n;

	    rev_len = strlen (q);

	    if (sscanf (q, "-%u.%u%n", &si_major, &si_minor, &n) != 2
		|| n != rev_len
		|| si_major > 0xff || si_minor > 0xff)
	      {
	      invalid_silicon_revision:
		as_fatal ("-mcpu=%s has invalid silicon revision", arg);
	      }

	    bfin_si_revision = (si_major << 8) | si_minor;

	    while (bfin_cpus[i].type == bfin_cpu_type
		   && bfin_cpus[i].si_revision != bfin_si_revision)
	      i++;

	    if (bfin_cpus[i].type != bfin_cpu_type)
	      goto invalid_silicon_revision;

	    bfin_anomaly_checks |= bfin_cpus[i].anomaly_checks;
	  }

	break;
      }

    case OPTION_FDPIC:
      bfin_flags |= EF_BFIN_FDPIC;
      bfin_pic_flag = "-mfdpic";
      break;

    case OPTION_NOPIC:
      bfin_flags &= ~(EF_BFIN_FDPIC);
      bfin_pic_flag = 0;
      break;
    }

  return 1;
}

void
md_show_usage (FILE * stream)
{
  fprintf (stream, _(" Blackfin specific assembler options:\n"));
  fprintf (stream, _("  -mcpu=<cpu[-sirevision]> specify the name of the target CPU\n"));
  fprintf (stream, _("  -mfdpic                  assemble for the FDPIC ABI\n"));
  fprintf (stream, _("  -mno-fdpic/-mnopic       disable -mfdpic\n"));
}

/* Perform machine-specific initializations.  */
void
md_begin ()
{
  /* Set the ELF flags if desired. */
  if (bfin_flags)
    bfd_set_private_flags (stdoutput, bfin_flags);

  /* Set the default machine type. */
  if (!bfd_set_arch_mach (stdoutput, bfd_arch_bfin, 0))
    as_warn (_("Could not set architecture and machine."));

  /* Ensure that lines can begin with '(', for multiple
     register stack pops. */
  lex_type ['('] = LEX_BEGIN_NAME;

#ifdef OBJ_ELF
  record_alignment (text_section, 2);
  record_alignment (data_section, 2);
  record_alignment (bss_section, 2);
#endif

  errorf = stderr;
  obstack_init (&mempool);

#ifdef DEBUG
  extern int debug_codeselection;
  debug_codeselection = 1;
#endif

  last_insn_size = 0;
}

/* Perform the main parsing, and assembly of the input here.  Also,
   call the required routines for alignment and fixups here.
   This is called for every line that contains real assembly code.  */

void
md_assemble (char *line)
{
  char *toP = 0;
  extern char *current_inputline;
  int size, insn_size;
  struct bfin_insn *tmp_insn;
  size_t len;
  static size_t buffer_len = 0;
  parse_state state;

  len = strlen (line);
  if (len + 2 > buffer_len)
    {
      if (buffer_len > 0)
	free (current_inputline);
      buffer_len = len + 40;
      current_inputline = xmalloc (buffer_len);
    }
  memcpy (current_inputline, line, len);
  current_inputline[len] = ';';
  current_inputline[len + 1] = '\0';

  state = parse (current_inputline);
  if (state == NO_INSN_GENERATED)
    return;

  for (insn_size = 0, tmp_insn = insn; tmp_insn; tmp_insn = tmp_insn->next)
    if (!tmp_insn->reloc || !tmp_insn->exp->symbol)
      insn_size += 2;

  if (insn_size)
    toP = frag_more (insn_size);

  last_insn_size = insn_size;

#ifdef DEBUG
  printf ("INS:");
#endif
  while (insn)
    {
      if (insn->reloc && insn->exp->symbol)
	{
	  char *prev_toP = toP - 2;
	  switch (insn->reloc)
	    {
	    case BFD_RELOC_BFIN_24_PCREL_JUMP_L:
	    case BFD_RELOC_24_PCREL:
	    case BFD_RELOC_BFIN_16_LOW:
	    case BFD_RELOC_BFIN_16_HIGH:
	      size = 4;
	      break;
	    default:
	      size = 2;
	    }

	  /* Following if condition checks for the arithmetic relocations.
	     If the case then it doesn't required to generate the code.
	     It has been assumed that, their ID will be contiguous.  */
	  if ((BFD_ARELOC_BFIN_PUSH <= insn->reloc
               && BFD_ARELOC_BFIN_COMP >= insn->reloc)
              || insn->reloc == BFD_RELOC_BFIN_16_IMM)
	    {
	      size = 2;
	    }
	  if (insn->reloc == BFD_ARELOC_BFIN_CONST
              || insn->reloc == BFD_ARELOC_BFIN_PUSH)
	    size = 4;

	  fix_new (frag_now,
                   (prev_toP - frag_now->fr_literal),
		   size, insn->exp->symbol, insn->exp->value,
                   insn->pcrel, insn->reloc);
	}
      else
	{
	  md_number_to_chars (toP, insn->value, 2);
	  toP += 2;
	}

#ifdef DEBUG
      printf (" reloc :");
      printf (" %02x%02x", ((unsigned char *) &insn->value)[0],
              ((unsigned char *) &insn->value)[1]);
      printf ("\n");
#endif
      insn = insn->next;
    }
#ifdef OBJ_ELF
  dwarf2_emit_insn (insn_size);
#endif

  while (*line++ != '\0')
    if (*line == '\n')
      bump_line_counters ();
}

/* Parse one line of instructions, and generate opcode for it.
   To parse the line, YACC and LEX are used, because the instruction set
   syntax doesn't confirm to the AT&T assembly syntax.
   To call a YACC & LEX generated parser, we must provide the input via
   a FILE stream, otherwise stdin is used by default.  Below the input
   to the function will be put into a temporary file, then the generated
   parser uses the temporary file for parsing.  */

static parse_state
parse (char *line)
{
  parse_state state;
  YY_BUFFER_STATE buffstate;

  buffstate = yy_scan_string (line);

  /* our lex requires setting the start state to keyword
     every line as the first word may be a keyword.
     Fixes a bug where we could not have keywords as labels.  */
  set_start_state ();

  /* Call yyparse here.  */
  state = yyparse ();
  if (state == SEMANTIC_ERROR)
    {
      as_bad (_("Parse failed."));
      insn = 0;
    }

  yy_delete_buffer (buffstate);
  return state;
}

/* We need to handle various expressions properly.
   Such as, [SP--] = 34, concerned by md_assemble().  */

void
md_operand (expressionS * expressionP)
{
  if (*input_line_pointer == '[')
    {
      as_tsktsk ("We found a '['!");
      input_line_pointer++;
      expression (expressionP);
    }
}

/* Handle undefined symbols. */
symbolS *
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
{
  return (symbolS *) 0;
}

int
md_estimate_size_before_relax (fragS * fragP ATTRIBUTE_UNUSED,
                               segT segment ATTRIBUTE_UNUSED)
{
  return 0;
}

/* Convert from target byte order to host byte order.  */

static int
md_chars_to_number (char *val, int n)
{
  int retval;

  for (retval = 0; n--;)
    {
      retval <<= 8;
      retval |= val[n];
    }
  return retval;
}

void
md_apply_fix (fixS *fixP, valueT *valueP, segT seg ATTRIBUTE_UNUSED)
{
  char *where = fixP->fx_frag->fr_literal + fixP->fx_where;

  long value = *valueP;
  long newval;

  switch (fixP->fx_r_type)
    {
    case BFD_RELOC_BFIN_GOT:
    case BFD_RELOC_BFIN_GOT17M4:
    case BFD_RELOC_BFIN_FUNCDESC_GOT17M4:
      fixP->fx_no_overflow = 1;
      newval = md_chars_to_number (where, 2);
      newval |= 0x0 & 0x7f;
      md_number_to_chars (where, newval, 2);
      break;

    case BFD_RELOC_BFIN_10_PCREL:
      if (!value)
	break;
      if (value < -1024 || value > 1022)
	as_bad_where (fixP->fx_file, fixP->fx_line,
                      _("pcrel too far BFD_RELOC_BFIN_10"));

      /* 11 bit offset even numbered, so we remove right bit.  */
      value = value >> 1;
      newval = md_chars_to_number (where, 2);
      newval |= value & 0x03ff;
      md_number_to_chars (where, newval, 2);
      break;

    case BFD_RELOC_BFIN_12_PCREL_JUMP:
    case BFD_RELOC_BFIN_12_PCREL_JUMP_S:
    case BFD_RELOC_12_PCREL:
      if (!value)
	break;

      if (value < -4096 || value > 4094)
	as_bad_where (fixP->fx_file, fixP->fx_line, _("pcrel too far BFD_RELOC_BFIN_12"));
      /* 13 bit offset even numbered, so we remove right bit.  */
      value = value >> 1;
      newval = md_chars_to_number (where, 2);
      newval |= value & 0xfff;
      md_number_to_chars (where, newval, 2);
      break;

    case BFD_RELOC_BFIN_16_LOW:
    case BFD_RELOC_BFIN_16_HIGH:
      fixP->fx_done = FALSE;
      break;

    case BFD_RELOC_BFIN_24_PCREL_JUMP_L:
    case BFD_RELOC_BFIN_24_PCREL_CALL_X:
    case BFD_RELOC_24_PCREL:
      if (!value)
	break;

      if (value < -16777216 || value > 16777214)
	as_bad_where (fixP->fx_file, fixP->fx_line, _("pcrel too far BFD_RELOC_BFIN_24"));

      /* 25 bit offset even numbered, so we remove right bit.  */
      value = value >> 1;
      value++;

      md_number_to_chars (where - 2, value >> 16, 1);
      md_number_to_chars (where, value, 1);
      md_number_to_chars (where + 1, value >> 8, 1);
      break;

    case BFD_RELOC_BFIN_5_PCREL:	/* LSETUP (a, b) : "a" */
      if (!value)
	break;
      if (value < 4 || value > 30)
	as_bad_where (fixP->fx_file, fixP->fx_line, _("pcrel too far BFD_RELOC_BFIN_5"));
      value = value >> 1;
      newval = md_chars_to_number (where, 1);
      newval = (newval & 0xf0) | (value & 0xf);
      md_number_to_chars (where, newval, 1);
      break;

    case BFD_RELOC_BFIN_11_PCREL:	/* LSETUP (a, b) : "b" */
      if (!value)
	break;
      value += 2;
      if (value < 4 || value > 2046)
	as_bad_where (fixP->fx_file, fixP->fx_line, _("pcrel too far BFD_RELOC_BFIN_11_PCREL"));
      /* 11 bit unsigned even, so we remove right bit.  */
      value = value >> 1;
      newval = md_chars_to_number (where, 2);
      newval |= value & 0x03ff;
      md_number_to_chars (where, newval, 2);
      break;

    case BFD_RELOC_8:
      if (value < -0x80 || value >= 0x7f)
	as_bad_where (fixP->fx_file, fixP->fx_line, _("rel too far BFD_RELOC_8"));
      md_number_to_chars (where, value, 1);
      break;

    case BFD_RELOC_BFIN_16_IMM:
    case BFD_RELOC_16:
      if (value < -0x8000 || value >= 0x7fff)
	as_bad_where (fixP->fx_file, fixP->fx_line, _("rel too far BFD_RELOC_16"));
      md_number_to_chars (where, value, 2);
      break;

    case BFD_RELOC_32:
      md_number_to_chars (where, value, 4);
      break;

    case BFD_RELOC_BFIN_PLTPC:
      md_number_to_chars (where, value, 2);
      break;

    case BFD_RELOC_BFIN_FUNCDESC:
    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
      fixP->fx_done = FALSE;
      break;

    default:
      if ((BFD_ARELOC_BFIN_PUSH > fixP->fx_r_type) || (BFD_ARELOC_BFIN_COMP < fixP->fx_r_type))
	{
	  fprintf (stderr, "Relocation %d not handled in gas." " Contact support.\n", fixP->fx_r_type);
	  return;
	}
    }

  if (!fixP->fx_addsy)
    fixP->fx_done = TRUE;

}

/* Round up a section size to the appropriate boundary.  */
valueT
md_section_align (segment, size)
     segT segment;
     valueT size;
{
  int boundary = bfd_get_section_alignment (stdoutput, segment);
  return ((size + (1 << boundary) - 1) & (-1 << boundary));
}


char *
md_atof (int type, char * litP, int * sizeP)
{
  return ieee_md_atof (type, litP, sizeP, FALSE);
}


/* If while processing a fixup, a reloc really needs to be created
   then it is done here.  */

arelent *
tc_gen_reloc (seg, fixp)
     asection *seg ATTRIBUTE_UNUSED;
     fixS *fixp;
{
  arelent *reloc;

  reloc		      = (arelent *) xmalloc (sizeof (arelent));
  reloc->sym_ptr_ptr  = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address      = fixp->fx_frag->fr_address + fixp->fx_where;

  reloc->addend = fixp->fx_offset;
  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);

  if (reloc->howto == (reloc_howto_type *) NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
		    /* xgettext:c-format.  */
		    _("reloc %d not supported by object file format"),
		    (int) fixp->fx_r_type);

      xfree (reloc);

      return NULL;
    }

  return reloc;
}

/*  The location from which a PC relative jump should be calculated,
    given a PC relative reloc.  */

long
md_pcrel_from_section (fixP, sec)
     fixS *fixP;
     segT sec;
{
  if (fixP->fx_addsy != (symbolS *) NULL
      && (!S_IS_DEFINED (fixP->fx_addsy)
      || S_GET_SEGMENT (fixP->fx_addsy) != sec))
    {
      /* The symbol is undefined (or is defined but not in this section).
         Let the linker figure it out.  */
      return 0;
    }
  return fixP->fx_frag->fr_address + fixP->fx_where;
}

/* Return true if the fix can be handled by GAS, false if it must
   be passed through to the linker.  */

bfd_boolean
bfin_fix_adjustable (fixS *fixP)
{
  switch (fixP->fx_r_type)
    {
  /* Adjust_reloc_syms doesn't know about the GOT.  */
    case BFD_RELOC_BFIN_GOT:
    case BFD_RELOC_BFIN_PLTPC:
  /* We need the symbol name for the VTABLE entries.  */
    case BFD_RELOC_VTABLE_INHERIT:
    case BFD_RELOC_VTABLE_ENTRY:
      return 0;

    default:
      return 1;
    }
}

/* Special extra functions that help bfin-parse.y perform its job.  */

struct obstack mempool;

INSTR_T
conscode (INSTR_T head, INSTR_T tail)
{
  if (!head)
    return tail;
  head->next = tail;
  return head;
}

INSTR_T
conctcode (INSTR_T head, INSTR_T tail)
{
  INSTR_T temp = (head);
  if (!head)
    return tail;
  while (temp->next)
    temp = temp->next;
  temp->next = tail;

  return head;
}

INSTR_T
note_reloc (INSTR_T code, Expr_Node * symbol, int reloc, int pcrel)
{
  /* Assert that the symbol is not an operator.  */
  gas_assert (symbol->type == Expr_Node_Reloc);

  return note_reloc1 (code, symbol->value.s_value, reloc, pcrel);

}

INSTR_T
note_reloc1 (INSTR_T code, const char *symbol, int reloc, int pcrel)
{
  code->reloc = reloc;
  code->exp = mkexpr (0, symbol_find_or_make (symbol));
  code->pcrel = pcrel;
  return code;
}

INSTR_T
note_reloc2 (INSTR_T code, const char *symbol, int reloc, int value, int pcrel)
{
  code->reloc = reloc;
  code->exp = mkexpr (value, symbol_find_or_make (symbol));
  code->pcrel = pcrel;
  return code;
}

INSTR_T
gencode (unsigned long x)
{
  INSTR_T cell = obstack_alloc (&mempool, sizeof (struct bfin_insn));
  memset (cell, 0, sizeof (struct bfin_insn));
  cell->value = (x);
  return cell;
}

int reloc;
int ninsns;
int count_insns;

static void *
allocate (int n)
{
  return obstack_alloc (&mempool, n);
}

Expr_Node *
Expr_Node_Create (Expr_Node_Type type,
	          Expr_Node_Value value,
                  Expr_Node *Left_Child,
                  Expr_Node *Right_Child)
{


  Expr_Node *node = (Expr_Node *) allocate (sizeof (Expr_Node));
  node->type = type;
  node->value = value;
  node->Left_Child = Left_Child;
  node->Right_Child = Right_Child;
  return node;
}

static const char *con = ".__constant";
static const char *op = ".__operator";
static INSTR_T Expr_Node_Gen_Reloc_R (Expr_Node * head);
INSTR_T Expr_Node_Gen_Reloc (Expr_Node *head, int parent_reloc);

INSTR_T
Expr_Node_Gen_Reloc (Expr_Node * head, int parent_reloc)
{
  /* Top level reloction expression generator VDSP style.
   If the relocation is just by itself, generate one item
   else generate this convoluted expression.  */

  INSTR_T note = NULL_CODE;
  INSTR_T note1 = NULL_CODE;
  int pcrel = 1;  /* Is the parent reloc pcrelative?
		  This calculation here and HOWTO should match.  */

  if (parent_reloc)
    {
      /*  If it's 32 bit quantity then 16bit code needs to be added.  */
      int value = 0;

      if (head->type == Expr_Node_Constant)
	{
	  /* If note1 is not null code, we have to generate a right
             aligned value for the constant. Otherwise the reloc is
             a part of the basic command and the yacc file
             generates this.  */
	  value = head->value.i_value;
	}
      switch (parent_reloc)
	{
	  /*  Some relocations will need to allocate extra words.  */
	case BFD_RELOC_BFIN_16_IMM:
	case BFD_RELOC_BFIN_16_LOW:
	case BFD_RELOC_BFIN_16_HIGH:
	  note1 = conscode (gencode (value), NULL_CODE);
	  pcrel = 0;
	  break;
	case BFD_RELOC_BFIN_PLTPC:
	  note1 = conscode (gencode (value), NULL_CODE);
	  pcrel = 0;
	  break;
	case BFD_RELOC_16:
	case BFD_RELOC_BFIN_GOT:
	case BFD_RELOC_BFIN_GOT17M4:
	case BFD_RELOC_BFIN_FUNCDESC_GOT17M4:
	  note1 = conscode (gencode (value), NULL_CODE);
	  pcrel = 0;
	  break;
	case BFD_RELOC_24_PCREL:
	case BFD_RELOC_BFIN_24_PCREL_JUMP_L:
	case BFD_RELOC_BFIN_24_PCREL_CALL_X:
	  /* These offsets are even numbered pcrel.  */
	  note1 = conscode (gencode (value >> 1), NULL_CODE);
	  break;
	default:
	  note1 = NULL_CODE;
	}
    }
  if (head->type == Expr_Node_Constant)
    note = note1;
  else if (head->type == Expr_Node_Reloc)
    {
      note = note_reloc1 (gencode (0), head->value.s_value, parent_reloc, pcrel);
      if (note1 != NULL_CODE)
	note = conscode (note1, note);
    }
  else if (head->type == Expr_Node_Binop
	   && (head->value.op_value == Expr_Op_Type_Add
	       || head->value.op_value == Expr_Op_Type_Sub)
	   && head->Left_Child->type == Expr_Node_Reloc
	   && head->Right_Child->type == Expr_Node_Constant)
    {
      int val = head->Right_Child->value.i_value;
      if (head->value.op_value == Expr_Op_Type_Sub)
	val = -val;
      note = conscode (note_reloc2 (gencode (0), head->Left_Child->value.s_value,
				    parent_reloc, val, 0),
		       NULL_CODE);
      if (note1 != NULL_CODE)
	note = conscode (note1, note);
    }
  else
    {
      /* Call the recursive function.  */
      note = note_reloc1 (gencode (0), op, parent_reloc, pcrel);
      if (note1 != NULL_CODE)
	note = conscode (note1, note);
      note = conctcode (Expr_Node_Gen_Reloc_R (head), note);
    }
  return note;
}

static INSTR_T
Expr_Node_Gen_Reloc_R (Expr_Node * head)
{

  INSTR_T note = 0;
  INSTR_T note1 = 0;

  switch (head->type)
    {
    case Expr_Node_Constant:
      note = conscode (note_reloc2 (gencode (0), con, BFD_ARELOC_BFIN_CONST, head->value.i_value, 0), NULL_CODE);
      break;
    case Expr_Node_Reloc:
      note = conscode (note_reloc (gencode (0), head, BFD_ARELOC_BFIN_PUSH, 0), NULL_CODE);
      break;
    case Expr_Node_Binop:
      note1 = conctcode (Expr_Node_Gen_Reloc_R (head->Left_Child), Expr_Node_Gen_Reloc_R (head->Right_Child));
      switch (head->value.op_value)
	{
	case Expr_Op_Type_Add:
	  note = conctcode (note1, conscode (note_reloc1 (gencode (0), op, BFD_ARELOC_BFIN_ADD, 0), NULL_CODE));
	  break;
	case Expr_Op_Type_Sub:
	  note = conctcode (note1, conscode (note_reloc1 (gencode (0), op, BFD_ARELOC_BFIN_SUB, 0), NULL_CODE));
	  break;
	case Expr_Op_Type_Mult:
	  note = conctcode (note1, conscode (note_reloc1 (gencode (0), op, BFD_ARELOC_BFIN_MULT, 0), NULL_CODE));
	  break;
	case Expr_Op_Type_Div:
	  note = conctcode (note1, conscode (note_reloc1 (gencode (0), op, BFD_ARELOC_BFIN_DIV, 0), NULL_CODE));
	  break;
	case Expr_Op_Type_Mod:
	  note = conctcode (note1, conscode (note_reloc1 (gencode (0), op, BFD_ARELOC_BFIN_MOD, 0), NULL_CODE));
	  break;
	case Expr_Op_Type_Lshift:
	  note = conctcode (note1, conscode (note_reloc1 (gencode (0), op, BFD_ARELOC_BFIN_LSHIFT, 0), NULL_CODE));
	  break;
	case Expr_Op_Type_Rshift:
	  note = conctcode (note1, conscode (note_reloc1 (gencode (0), op, BFD_ARELOC_BFIN_RSHIFT, 0), NULL_CODE));
	  break;
	case Expr_Op_Type_BAND:
	  note = conctcode (note1, conscode (note_reloc1 (gencode (0), op, BFD_ARELOC_BFIN_AND, 0), NULL_CODE));
	  break;
	case Expr_Op_Type_BOR:
	  note = conctcode (note1, conscode (note_reloc1 (gencode (0), op, BFD_ARELOC_BFIN_OR, 0), NULL_CODE));
	  break;
	case Expr_Op_Type_BXOR:
	  note = conctcode (note1, conscode (note_reloc1 (gencode (0), op, BFD_ARELOC_BFIN_XOR, 0), NULL_CODE));
	  break;
	case Expr_Op_Type_LAND:
	  note = conctcode (note1, conscode (note_reloc1 (gencode (0), op, BFD_ARELOC_BFIN_LAND, 0), NULL_CODE));
	  break;
	case Expr_Op_Type_LOR:
	  note = conctcode (note1, conscode (note_reloc1 (gencode (0), op, BFD_ARELOC_BFIN_LOR, 0), NULL_CODE));
	  break;
	default:
	  fprintf (stderr, "%s:%d:Unknown operator found for arithmetic" " relocation", __FILE__, __LINE__);


	}
      break;
    case Expr_Node_Unop:
      note1 = conscode (Expr_Node_Gen_Reloc_R (head->Left_Child), NULL_CODE);
      switch (head->value.op_value)
	{
	case Expr_Op_Type_NEG:
	  note = conctcode (note1, conscode (note_reloc1 (gencode (0), op, BFD_ARELOC_BFIN_NEG, 0), NULL_CODE));
	  break;
	case Expr_Op_Type_COMP:
	  note = conctcode (note1, conscode (note_reloc1 (gencode (0), op, BFD_ARELOC_BFIN_COMP, 0), NULL_CODE));
	  break;
	default:
	  fprintf (stderr, "%s:%d:Unknown operator found for arithmetic" " relocation", __FILE__, __LINE__);
	}
      break;
    default:
      fprintf (stderr, "%s:%d:Unknown node expression found during " "arithmetic relocation generation", __FILE__, __LINE__);
    }
  return note;
}

/* Blackfin opcode generation.  */

/* These functions are called by the generated parser
   (from bfin-parse.y), the register type classification
   happens in bfin-lex.l.  */

#include "bfin-aux.h"
#include "opcode/bfin.h"

#define INIT(t)  t c_code = init_##t
#define ASSIGN(x) c_code.opcode |= ((x & c_code.mask_##x)<<c_code.bits_##x)
#define ASSIGNF(x,f) c_code.opcode |= ((x & c_code.mask_##f)<<c_code.bits_##f)
#define ASSIGN_R(x) c_code.opcode |= (((x ? (x->regno & CODE_MASK) : 0) & c_code.mask_##x)<<c_code.bits_##x)

#define HI(x) ((x >> 16) & 0xffff)
#define LO(x) ((x      ) & 0xffff)

#define GROUP(x) ((x->regno & CLASS_MASK) >> 4)

#define GEN_OPCODE32()  \
	conscode (gencode (HI (c_code.opcode)), \
	conscode (gencode (LO (c_code.opcode)), NULL_CODE))

#define GEN_OPCODE16()  \
	conscode (gencode (c_code.opcode), NULL_CODE)


/*  32 BIT INSTRUCTIONS.  */


/* DSP32 instruction generation.  */

INSTR_T
bfin_gen_dsp32mac (int op1, int MM, int mmod, int w1, int P,
	           int h01, int h11, int h00, int h10, int op0,
                   REG_T dst, REG_T src0, REG_T src1, int w0)
{
  INIT (DSP32Mac);

  ASSIGN (op0);
  ASSIGN (op1);
  ASSIGN (MM);
  ASSIGN (mmod);
  ASSIGN (w0);
  ASSIGN (w1);
  ASSIGN (h01);
  ASSIGN (h11);
  ASSIGN (h00);
  ASSIGN (h10);
  ASSIGN (P);

  /* If we have full reg assignments, mask out LSB to encode
  single or simultaneous even/odd register moves.  */
  if (P)
    {
      dst->regno &= 0x06;
    }

  ASSIGN_R (dst);
  ASSIGN_R (src0);
  ASSIGN_R (src1);

  return GEN_OPCODE32 ();
}

INSTR_T
bfin_gen_dsp32mult (int op1, int MM, int mmod, int w1, int P,
	            int h01, int h11, int h00, int h10, int op0,
                    REG_T dst, REG_T src0, REG_T src1, int w0)
{
  INIT (DSP32Mult);

  ASSIGN (op0);
  ASSIGN (op1);
  ASSIGN (MM);
  ASSIGN (mmod);
  ASSIGN (w0);
  ASSIGN (w1);
  ASSIGN (h01);
  ASSIGN (h11);
  ASSIGN (h00);
  ASSIGN (h10);
  ASSIGN (P);

  if (P)
    {
      dst->regno &= 0x06;
    }

  ASSIGN_R (dst);
  ASSIGN_R (src0);
  ASSIGN_R (src1);

  return GEN_OPCODE32 ();
}

INSTR_T
bfin_gen_dsp32alu (int HL, int aopcde, int aop, int s, int x,
              REG_T dst0, REG_T dst1, REG_T src0, REG_T src1)
{
  INIT (DSP32Alu);

  ASSIGN (HL);
  ASSIGN (aopcde);
  ASSIGN (aop);
  ASSIGN (s);
  ASSIGN (x);
  ASSIGN_R (dst0);
  ASSIGN_R (dst1);
  ASSIGN_R (src0);
  ASSIGN_R (src1);

  return GEN_OPCODE32 ();
}

INSTR_T
bfin_gen_dsp32shift (int sopcde, REG_T dst0, REG_T src0,
                REG_T src1, int sop, int HLs)
{
  INIT (DSP32Shift);

  ASSIGN (sopcde);
  ASSIGN (sop);
  ASSIGN (HLs);

  ASSIGN_R (dst0);
  ASSIGN_R (src0);
  ASSIGN_R (src1);

  return GEN_OPCODE32 ();
}

INSTR_T
bfin_gen_dsp32shiftimm (int sopcde, REG_T dst0, int immag,
                   REG_T src1, int sop, int HLs)
{
  INIT (DSP32ShiftImm);

  ASSIGN (sopcde);
  ASSIGN (sop);
  ASSIGN (HLs);

  ASSIGN_R (dst0);
  ASSIGN (immag);
  ASSIGN_R (src1);

  return GEN_OPCODE32 ();
}

/* LOOP SETUP.  */

INSTR_T
bfin_gen_loopsetup (Expr_Node * psoffset, REG_T c, int rop,
               Expr_Node * peoffset, REG_T reg)
{
  int soffset, eoffset;
  INIT (LoopSetup);

  soffset = (EXPR_VALUE (psoffset) >> 1);
  ASSIGN (soffset);
  eoffset = (EXPR_VALUE (peoffset) >> 1);
  ASSIGN (eoffset);
  ASSIGN (rop);
  ASSIGN_R (c);
  ASSIGN_R (reg);

  return
      conscode (gencode (HI (c_code.opcode)),
		conctcode (Expr_Node_Gen_Reloc (psoffset, BFD_RELOC_BFIN_5_PCREL),
			   conctcode (gencode (LO (c_code.opcode)), Expr_Node_Gen_Reloc (peoffset, BFD_RELOC_BFIN_11_PCREL))));

}

/*  Call, Link.  */

INSTR_T
bfin_gen_calla (Expr_Node * addr, int S)
{
  int val;
  int high_val;
  int rel = 0;
  INIT (CALLa);

  switch(S){
   case 0 : rel = BFD_RELOC_BFIN_24_PCREL_JUMP_L; break;
   case 1 : rel = BFD_RELOC_24_PCREL; break;
   case 2 : rel = BFD_RELOC_BFIN_PLTPC; break;
   default : break;
  }

  ASSIGN (S);

  val = EXPR_VALUE (addr) >> 1;
  high_val = val >> 16;

  return conscode (gencode (HI (c_code.opcode) | (high_val & 0xff)),
                     Expr_Node_Gen_Reloc (addr, rel));
  }

INSTR_T
bfin_gen_linkage (int R, int framesize)
{
  INIT (Linkage);

  ASSIGN (R);
  ASSIGN (framesize);

  return GEN_OPCODE32 ();
}


/* Load and Store.  */

INSTR_T
bfin_gen_ldimmhalf (REG_T reg, int H, int S, int Z, Expr_Node * phword, int rel)
{
  int grp, hword;
  unsigned val = EXPR_VALUE (phword);
  INIT (LDIMMhalf);

  ASSIGN (H);
  ASSIGN (S);
  ASSIGN (Z);

  ASSIGN_R (reg);
  grp = (GROUP (reg));
  ASSIGN (grp);
  if (rel == 2)
    {
      return conscode (gencode (HI (c_code.opcode)), Expr_Node_Gen_Reloc (phword, BFD_RELOC_BFIN_16_IMM));
    }
  else if (rel == 1)
    {
      return conscode (gencode (HI (c_code.opcode)), Expr_Node_Gen_Reloc (phword, IS_H (*reg) ? BFD_RELOC_BFIN_16_HIGH : BFD_RELOC_BFIN_16_LOW));
    }
  else
    {
      hword = val;
      ASSIGN (hword);
    }
  return GEN_OPCODE32 ();
}

INSTR_T
bfin_gen_ldstidxi (REG_T ptr, REG_T reg, int W, int sz, int Z, Expr_Node * poffset)
{
  INIT (LDSTidxI);

  if (!IS_PREG (*ptr) || (!IS_DREG (*reg) && !Z))
    {
      fprintf (stderr, "Warning: possible mixup of Preg/Dreg\n");
      return 0;
    }

  ASSIGN_R (ptr);
  ASSIGN_R (reg);
  ASSIGN (W);
  ASSIGN (sz);

  ASSIGN (Z);

  if (poffset->type != Expr_Node_Constant)
    {
      /* a GOT relocation such as R0 = [P5 + symbol@@GOT] */
      /* distinguish between R0 = [P5 + symbol@@GOT] and
	 P5 = [P5 + _current_shared_library_p5_offset_]
      */
      if (poffset->type == Expr_Node_Reloc
	  && !strcmp (poffset->value.s_value,
		      "_current_shared_library_p5_offset_"))
	{
	  return  conscode (gencode (HI (c_code.opcode)),
			    Expr_Node_Gen_Reloc(poffset, BFD_RELOC_16));
	}
      else if (poffset->type != Expr_Node_GOT_Reloc)
	abort ();

      return conscode (gencode (HI (c_code.opcode)),
		       Expr_Node_Gen_Reloc(poffset->Left_Child,
					   poffset->value.i_value));
    }
  else
    {
      int value, offset;
      switch (sz)
	{				/* load/store access size */
	case 0:			/* 32 bit */
	  value = EXPR_VALUE (poffset) >> 2;
	  break;
	case 1:			/* 16 bit */
	  value = EXPR_VALUE (poffset) >> 1;
	  break;
	case 2:			/* 8 bit */
	  value = EXPR_VALUE (poffset);
	  break;
	default:
	  abort ();
	}

      offset = (value & 0xffff);
      ASSIGN (offset);
      return GEN_OPCODE32 ();
    }
}


INSTR_T
bfin_gen_ldst (REG_T ptr, REG_T reg, int aop, int sz, int Z, int W)
{
  INIT (LDST);

  if (!IS_PREG (*ptr) || (!IS_DREG (*reg) && !Z))
    {
      fprintf (stderr, "Warning: possible mixup of Preg/Dreg\n");
      return 0;
    }

  ASSIGN_R (ptr);
  ASSIGN_R (reg);
  ASSIGN (aop);
  ASSIGN (sz);
  ASSIGN (Z);
  ASSIGN (W);

  return GEN_OPCODE16 ();
}

INSTR_T
bfin_gen_ldstii (REG_T ptr, REG_T reg, Expr_Node * poffset, int W, int opc)
{
  int offset;
  int value = 0;
  INIT (LDSTii);

  if (!IS_PREG (*ptr))
    {
      fprintf (stderr, "Warning: possible mixup of Preg/Dreg\n");
      return 0;
    }

  switch (opc)
    {
    case 1:
    case 2:
      value = EXPR_VALUE (poffset) >> 1;
      break;
    case 0:
    case 3:
      value = EXPR_VALUE (poffset) >> 2;
      break;
    }

  ASSIGN_R (ptr);
  ASSIGN_R (reg);

  offset = value;
  ASSIGN (offset);
  ASSIGN (W);
  ASSIGNF (opc, op);

  return GEN_OPCODE16 ();
}

INSTR_T
bfin_gen_ldstiifp (REG_T sreg, Expr_Node * poffset, int W)
{
  /* Set bit 4 if it's a Preg.  */
  int reg = (sreg->regno & CODE_MASK) | (IS_PREG (*sreg) ? 0x8 : 0x0);
  int offset = ((~(EXPR_VALUE (poffset) >> 2)) & 0x1f) + 1;
  INIT (LDSTiiFP);
  ASSIGN (reg);
  ASSIGN (offset);
  ASSIGN (W);

  return GEN_OPCODE16 ();
}

INSTR_T
bfin_gen_ldstpmod (REG_T ptr, REG_T reg, int aop, int W, REG_T idx)
{
  INIT (LDSTpmod);

  ASSIGN_R (ptr);
  ASSIGN_R (reg);
  ASSIGN (aop);
  ASSIGN (W);
  ASSIGN_R (idx);

  return GEN_OPCODE16 ();
}

INSTR_T
bfin_gen_dspldst (REG_T i, REG_T reg, int aop, int W, int m)
{
  INIT (DspLDST);

  ASSIGN_R (i);
  ASSIGN_R (reg);
  ASSIGN (aop);
  ASSIGN (W);
  ASSIGN (m);

  return GEN_OPCODE16 ();
}

INSTR_T
bfin_gen_logi2op (int opc, int src, int dst)
{
  INIT (LOGI2op);

  ASSIGN (opc);
  ASSIGN (src);
  ASSIGN (dst);

  return GEN_OPCODE16 ();
}

INSTR_T
bfin_gen_brcc (int T, int B, Expr_Node * poffset)
{
  int offset;
  INIT (BRCC);

  ASSIGN (T);
  ASSIGN (B);
  offset = ((EXPR_VALUE (poffset) >> 1));
  ASSIGN (offset);
  return conscode (gencode (c_code.opcode), Expr_Node_Gen_Reloc (poffset, BFD_RELOC_BFIN_10_PCREL));
}

INSTR_T
bfin_gen_ujump (Expr_Node * poffset)
{
  int offset;
  INIT (UJump);

  offset = ((EXPR_VALUE (poffset) >> 1));
  ASSIGN (offset);

  return conscode (gencode (c_code.opcode),
                   Expr_Node_Gen_Reloc (
                       poffset, BFD_RELOC_BFIN_12_PCREL_JUMP_S));
}

INSTR_T
bfin_gen_alu2op (REG_T dst, REG_T src, int opc)
{
  INIT (ALU2op);

  ASSIGN_R (dst);
  ASSIGN_R (src);
  ASSIGN (opc);

  return GEN_OPCODE16 ();
}

INSTR_T
bfin_gen_compi2opd (REG_T dst, int src, int opc)
{
  INIT (COMPI2opD);

  ASSIGN_R (dst);
  ASSIGN (src);
  ASSIGNF (opc, op);

  return GEN_OPCODE16 ();
}

INSTR_T
bfin_gen_compi2opp (REG_T dst, int src, int opc)
{
  INIT (COMPI2opP);

  ASSIGN_R (dst);
  ASSIGN (src);
  ASSIGNF (opc, op);

  return GEN_OPCODE16 ();
}

INSTR_T
bfin_gen_dagmodik (REG_T i, int opc)
{
  INIT (DagMODik);

  ASSIGN_R (i);
  ASSIGNF (opc, op);

  return GEN_OPCODE16 ();
}

INSTR_T
bfin_gen_dagmodim (REG_T i, REG_T m, int opc, int br)
{
  INIT (DagMODim);

  ASSIGN_R (i);
  ASSIGN_R (m);
  ASSIGNF (opc, op);
  ASSIGN (br);

  return GEN_OPCODE16 ();
}

INSTR_T
bfin_gen_ptr2op (REG_T dst, REG_T src, int opc)
{
  INIT (PTR2op);

  ASSIGN_R (dst);
  ASSIGN_R (src);
  ASSIGN (opc);

  return GEN_OPCODE16 ();
}

INSTR_T
bfin_gen_comp3op (REG_T src0, REG_T src1, REG_T dst, int opc)
{
  INIT (COMP3op);

  ASSIGN_R (src0);
  ASSIGN_R (src1);
  ASSIGN_R (dst);
  ASSIGN (opc);

  return GEN_OPCODE16 ();
}

INSTR_T
bfin_gen_ccflag (REG_T x, int y, int opc, int I, int G)
{
  INIT (CCflag);

  ASSIGN_R (x);
  ASSIGN (y);
  ASSIGN (opc);
  ASSIGN (I);
  ASSIGN (G);

  return GEN_OPCODE16 ();
}

INSTR_T
bfin_gen_ccmv (REG_T src, REG_T dst, int T)
{
  int s, d;
  INIT (CCmv);

  ASSIGN_R (src);
  ASSIGN_R (dst);
  s = (GROUP (src));
  ASSIGN (s);
  d = (GROUP (dst));
  ASSIGN (d);
  ASSIGN (T);

  return GEN_OPCODE16 ();
}

INSTR_T
bfin_gen_cc2stat (int cbit, int opc, int D)
{
  INIT (CC2stat);

  ASSIGN (cbit);
  ASSIGNF (opc, op);
  ASSIGN (D);

  return GEN_OPCODE16 ();
}

INSTR_T
bfin_gen_regmv (REG_T src, REG_T dst)
{
  int gs, gd;
  INIT (RegMv);

  ASSIGN_R (src);
  ASSIGN_R (dst);

  gs = (GROUP (src));
  ASSIGN (gs);
  gd = (GROUP (dst));
  ASSIGN (gd);

  return GEN_OPCODE16 ();
}

INSTR_T
bfin_gen_cc2dreg (int opc, REG_T reg)
{
  INIT (CC2dreg);

  ASSIGNF (opc, op);
  ASSIGN_R (reg);

  return GEN_OPCODE16 ();
}

INSTR_T
bfin_gen_progctrl (int prgfunc, int poprnd)
{
  INIT (ProgCtrl);

  ASSIGN (prgfunc);
  ASSIGN (poprnd);

  return GEN_OPCODE16 ();
}

INSTR_T
bfin_gen_cactrl (REG_T reg, int a, int opc)
{
  INIT (CaCTRL);

  ASSIGN_R (reg);
  ASSIGN (a);
  ASSIGNF (opc, op);

  return GEN_OPCODE16 ();
}

INSTR_T
bfin_gen_pushpopmultiple (int dr, int pr, int d, int p, int W)
{
  INIT (PushPopMultiple);

  ASSIGN (dr);
  ASSIGN (pr);
  ASSIGN (d);
  ASSIGN (p);
  ASSIGN (W);

  return GEN_OPCODE16 ();
}

INSTR_T
bfin_gen_pushpopreg (REG_T reg, int W)
{
  int grp;
  INIT (PushPopReg);

  ASSIGN_R (reg);
  grp = (GROUP (reg));
  ASSIGN (grp);
  ASSIGN (W);

  return GEN_OPCODE16 ();
}

/* Pseudo Debugging Support.  */

INSTR_T
bfin_gen_pseudodbg (int fn, int reg, int grp)
{
  INIT (PseudoDbg);

  ASSIGN (fn);
  ASSIGN (reg);
  ASSIGN (grp);

  return GEN_OPCODE16 ();
}

INSTR_T
bfin_gen_pseudodbg_assert (int dbgop, REG_T regtest, int expected)
{
  int grp;
  INIT (PseudoDbg_Assert);

  ASSIGN (dbgop);
  ASSIGN_R (regtest);
  grp = GROUP (regtest);
  ASSIGN (grp);
  ASSIGN (expected);

  return GEN_OPCODE32 ();
}

INSTR_T
bfin_gen_pseudochr (int ch)
{
  INIT (PseudoChr);

  ASSIGN (ch);

  return GEN_OPCODE16 ();
}

/* Multiple instruction generation.  */

INSTR_T
bfin_gen_multi_instr (INSTR_T dsp32, INSTR_T dsp16_grp1, INSTR_T dsp16_grp2)
{
  INSTR_T walk;

  /* If it's a 0, convert into MNOP. */
  if (dsp32)
    {
      walk = dsp32->next;
      SET_MULTI_INSTRUCTION_BIT (dsp32);
    }
  else
    {
      dsp32 = gencode (0xc803);
      walk = gencode (0x1800);
      dsp32->next = walk;
    }

  if (!dsp16_grp1)
    {
      dsp16_grp1 = gencode (0x0000);
    }

  if (!dsp16_grp2)
    {
      dsp16_grp2 = gencode (0x0000);
    }

  walk->next = dsp16_grp1;
  dsp16_grp1->next = dsp16_grp2;
  dsp16_grp2->next = NULL_CODE;

  return dsp32;
}

INSTR_T
bfin_gen_loop (Expr_Node *exp, REG_T reg, int rop, REG_T preg)
{
  const char *loopsym;
  char *lbeginsym, *lendsym;
  Expr_Node_Value lbeginval, lendval;
  Expr_Node *lbegin, *lend;
  symbolS *sym;

  loopsym = exp->value.s_value;
  lbeginsym = (char *) xmalloc (strlen (loopsym) + strlen ("__BEGIN") + 5);
  lendsym = (char *) xmalloc (strlen (loopsym) + strlen ("__END") + 5);

  lbeginsym[0] = 0;
  lendsym[0] = 0;

  strcat (lbeginsym, "L$L$");
  strcat (lbeginsym, loopsym);
  strcat (lbeginsym, "__BEGIN");

  strcat (lendsym, "L$L$");
  strcat (lendsym, loopsym);
  strcat (lendsym, "__END");

  lbeginval.s_value = lbeginsym;
  lendval.s_value = lendsym;

  lbegin = Expr_Node_Create (Expr_Node_Reloc, lbeginval, NULL, NULL);
  lend   = Expr_Node_Create (Expr_Node_Reloc, lendval, NULL, NULL);

  sym = symbol_find(loopsym);
  if (!S_IS_LOCAL (sym) || (S_IS_LOCAL (sym) && !symbol_used_p (sym)))
    symbol_remove (sym, &symbol_rootP, &symbol_lastP);

  return bfin_gen_loopsetup (lbegin, reg, rop, lend, preg);
}

void
bfin_loop_attempt_create_label (Expr_Node *exp, int is_begin)
{
  char *name;
  name = fb_label_name (exp->value.i_value, is_begin);
  exp->value.s_value = xstrdup (name);
  exp->type = Expr_Node_Reloc;
}

void
bfin_loop_beginend (Expr_Node *exp, int begin)
{
  const char *loopsym;
  char *label_name;
  symbolS *linelabel;
  const char *suffix = begin ? "__BEGIN" : "__END";

  loopsym = exp->value.s_value;
  label_name = (char *) xmalloc (strlen (loopsym) + strlen (suffix) + 5);

  label_name[0] = 0;

  strcat (label_name, "L$L$");
  strcat (label_name, loopsym);
  strcat (label_name, suffix);

  linelabel = colon (label_name);

  /* LOOP_END follows the last instruction in the loop.
     Adjust label address.  */
  if (!begin)
    ((struct local_symbol *) linelabel)->lsy_value -= last_insn_size;
}

bfd_boolean
bfin_eol_in_insn (char *line)
{
   /* Allow a new-line to appear in the middle of a multi-issue instruction.  */

   char *temp = line;

  if (*line != '\n')
    return FALSE;

  /* A semi-colon followed by a newline is always the end of a line.  */
  if (line[-1] == ';')
    return FALSE;

  if (line[-1] == '|')
    return TRUE;

  /* If the || is on the next line, there might be leading whitespace.  */
  temp++;
  while (*temp == ' ' || *temp == '\t') temp++;

  if (*temp == '|')
    return TRUE;

  return FALSE;
}

bfd_boolean
bfin_start_label (char *s, char *ptr)
{
  while (s != ptr)
    {
      if (*s == '(' || *s == '[')
	return FALSE;
      s++;
    }

  return TRUE;
}

int
bfin_force_relocation (struct fix *fixp)
{
  if (fixp->fx_r_type ==BFD_RELOC_BFIN_16_LOW
      || fixp->fx_r_type == BFD_RELOC_BFIN_16_HIGH)
    return TRUE;

  return generic_force_reloc (fixp);
}

/* This is a stripped down version of the disassembler.  The only thing it
   does is return a mask of registers modified by an instruction.  Only
   instructions that can occur in a parallel-issue bundle are handled, and
   only the registers that can cause a conflict are recorded.  */

#define DREG_MASK(n) (0x101 << (n))
#define DREGH_MASK(n) (0x100 << (n))
#define DREGL_MASK(n) (0x001 << (n))
#define IREG_MASK(n) (1 << ((n) + 16))

static int
decode_ProgCtrl_0 (int iw0)
{
  if (iw0 == 0)
    return 0;
  abort ();
}

static int
decode_LDSTpmod_0 (int iw0)
{
  /* LDSTpmod
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 1 | 0 | 0 | 0 |.W.|.aop...|.reg.......|.idx.......|.ptr.......|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int W   = ((iw0 >> LDSTpmod_W_bits) & LDSTpmod_W_mask);
  int aop = ((iw0 >> LDSTpmod_aop_bits) & LDSTpmod_aop_mask);
  int idx = ((iw0 >> LDSTpmod_idx_bits) & LDSTpmod_idx_mask);
  int ptr = ((iw0 >> LDSTpmod_ptr_bits) & LDSTpmod_ptr_mask);
  int reg = ((iw0 >> LDSTpmod_reg_bits) & LDSTpmod_reg_mask);

  if (aop == 1 && W == 0 && idx == ptr)
    return DREGL_MASK (reg);
  else if (aop == 2 && W == 0 && idx == ptr)
    return DREGH_MASK (reg);
  else if (aop == 1 && W == 1 && idx == ptr)
    return 0;
  else if (aop == 2 && W == 1 && idx == ptr)
    return 0;
  else if (aop == 0 && W == 0)
    return DREG_MASK (reg);
  else if (aop == 1 && W == 0)
    return DREGL_MASK (reg);
  else if (aop == 2 && W == 0)
    return DREGH_MASK (reg);
  else if (aop == 3 && W == 0)
    return DREG_MASK (reg);
  else if (aop == 3 && W == 1)
    return DREG_MASK (reg);
  else if (aop == 0 && W == 1)
    return 0;
  else if (aop == 1 && W == 1)
    return 0;
  else if (aop == 2 && W == 1)
    return 0;
  else
    return 0;

  return 2;
}

static int
decode_dagMODim_0 (int iw0)
{
  /* dagMODim
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 1 | 0 | 0 | 1 | 1 | 1 | 1 | 0 |.br| 1 | 1 |.op|.m.....|.i.....|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int i  = ((iw0 >> DagMODim_i_bits) & DagMODim_i_mask);
  int opc  = ((iw0 >> DagMODim_op_bits) & DagMODim_op_mask);

  if (opc == 0 || opc == 1)
    return IREG_MASK (i);
  else
    return 0;

  return 2;
}

static int
decode_dagMODik_0 (int iw0)
{
  /* dagMODik
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 1 | 0 | 0 | 1 | 1 | 1 | 1 | 1 | 0 | 1 | 1 | 0 |.op....|.i.....|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int i  = ((iw0 >> DagMODik_i_bits) & DagMODik_i_mask);
  return IREG_MASK (i);
}

/* GOOD */
static int
decode_dspLDST_0 (int iw0)
{
  /* dspLDST
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 1 | 0 | 0 | 1 | 1 | 1 |.W.|.aop...|.m.....|.i.....|.reg.......|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int i   = ((iw0 >> DspLDST_i_bits) & DspLDST_i_mask);
  int m   = ((iw0 >> DspLDST_m_bits) & DspLDST_m_mask);
  int W   = ((iw0 >> DspLDST_W_bits) & DspLDST_W_mask);
  int aop = ((iw0 >> DspLDST_aop_bits) & DspLDST_aop_mask);
  int reg = ((iw0 >> DspLDST_reg_bits) & DspLDST_reg_mask);

  if (aop == 0 && W == 0 && m == 0)
    return DREG_MASK (reg) | IREG_MASK (i);
  else if (aop == 0 && W == 0 && m == 1)
    return DREGL_MASK (reg) | IREG_MASK (i);
  else if (aop == 0 && W == 0 && m == 2)
    return DREGH_MASK (reg) | IREG_MASK (i);
  else if (aop == 1 && W == 0 && m == 0)
    return DREG_MASK (reg) | IREG_MASK (i);
  else if (aop == 1 && W == 0 && m == 1)
    return DREGL_MASK (reg) | IREG_MASK (i);
  else if (aop == 1 && W == 0 && m == 2)
    return DREGH_MASK (reg) | IREG_MASK (i);
  else if (aop == 2 && W == 0 && m == 0)
    return DREG_MASK (reg);
  else if (aop == 2 && W == 0 && m == 1)
    return DREGL_MASK (reg);
  else if (aop == 2 && W == 0 && m == 2)
    return DREGH_MASK (reg);
  else if (aop == 0 && W == 1 && m == 0)
    return IREG_MASK (i);
  else if (aop == 0 && W == 1 && m == 1)
    return IREG_MASK (i);
  else if (aop == 0 && W == 1 && m == 2)
    return IREG_MASK (i);
  else if (aop == 1 && W == 1 && m == 0)
    return IREG_MASK (i);
  else if (aop == 1 && W == 1 && m == 1)
    return IREG_MASK (i);
  else if (aop == 1 && W == 1 && m == 2)
    return IREG_MASK (i);
  else if (aop == 2 && W == 1 && m == 0)
    return 0;
  else if (aop == 2 && W == 1 && m == 1)
    return 0;
  else if (aop == 2 && W == 1 && m == 2)
    return 0;
  else if (aop == 3 && W == 0)
    return DREG_MASK (reg) | IREG_MASK (i);
  else if (aop == 3 && W == 1)
    return IREG_MASK (i);

  abort ();
}

/* GOOD */
static int
decode_LDST_0 (int iw0)
{
  /* LDST
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 1 | 0 | 0 | 1 |.sz....|.W.|.aop...|.Z.|.ptr.......|.reg.......|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int Z   = ((iw0 >> LDST_Z_bits) & LDST_Z_mask);
  int W   = ((iw0 >> LDST_W_bits) & LDST_W_mask);
  int sz  = ((iw0 >> LDST_sz_bits) & LDST_sz_mask);
  int aop = ((iw0 >> LDST_aop_bits) & LDST_aop_mask);
  int reg = ((iw0 >> LDST_reg_bits) & LDST_reg_mask);

  if (aop == 0 && sz == 0 && Z == 0 && W == 0)
    return DREG_MASK (reg);
  else if (aop == 0 && sz == 0 && Z == 1 && W == 0)
    return 0;
  else if (aop == 0 && sz == 1 && Z == 0 && W == 0)
    return DREG_MASK (reg);
  else if (aop == 0 && sz == 1 && Z == 1 && W == 0)
    return DREG_MASK (reg);
  else if (aop == 0 && sz == 2 && Z == 0 && W == 0)
    return DREG_MASK (reg);
  else if (aop == 0 && sz == 2 && Z == 1 && W == 0)
    return DREG_MASK (reg);
  else if (aop == 1 && sz == 0 && Z == 0 && W == 0)
    return DREG_MASK (reg);
  else if (aop == 1 && sz == 0 && Z == 1 && W == 0)
    return 0;
  else if (aop == 1 && sz == 1 && Z == 0 && W == 0)
    return DREG_MASK (reg);
  else if (aop == 1 && sz == 1 && Z == 1 && W == 0)
    return DREG_MASK (reg);
  else if (aop == 1 && sz == 2 && Z == 0 && W == 0)
    return DREG_MASK (reg);
  else if (aop == 1 && sz == 2 && Z == 1 && W == 0)
    return DREG_MASK (reg);
  else if (aop == 2 && sz == 0 && Z == 0 && W == 0)
    return DREG_MASK (reg);
  else if (aop == 2 && sz == 0 && Z == 1 && W == 0)
    return 0;
  else if (aop == 2 && sz == 1 && Z == 0 && W == 0)
    return DREG_MASK (reg);
  else if (aop == 2 && sz == 1 && Z == 1 && W == 0)
    return DREG_MASK (reg);
  else if (aop == 2 && sz == 2 && Z == 0 && W == 0)
    return DREG_MASK (reg);
  else if (aop == 2 && sz == 2 && Z == 1 && W == 0)
    return DREG_MASK (reg);
  else if (aop == 0 && sz == 0 && Z == 0 && W == 1)
    return 0;
  else if (aop == 0 && sz == 0 && Z == 1 && W == 1)
    return 0;
  else if (aop == 0 && sz == 1 && Z == 0 && W == 1)
    return 0;
  else if (aop == 0 && sz == 2 && Z == 0 && W == 1)
    return 0;
  else if (aop == 1 && sz == 0 && Z == 0 && W == 1)
    return 0;
  else if (aop == 1 && sz == 0 && Z == 1 && W == 1)
    return 0;
  else if (aop == 1 && sz == 1 && Z == 0 && W == 1)
    return 0;
  else if (aop == 1 && sz == 2 && Z == 0 && W == 1)
    return 0;
  else if (aop == 2 && sz == 0 && Z == 0 && W == 1)
    return 0;
  else if (aop == 2 && sz == 0 && Z == 1 && W == 1)
    return 0;
  else if (aop == 2 && sz == 1 && Z == 0 && W == 1)
    return 0;
  else if (aop == 2 && sz == 2 && Z == 0 && W == 1)
    return 0;

  abort ();
}

static int
decode_LDSTiiFP_0 (int iw0)
{
  /* LDSTiiFP
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 1 | 0 | 1 | 1 | 1 | 0 |.W.|.offset............|.reg...........|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int reg = ((iw0 >> LDSTiiFP_reg_bits) & LDSTiiFP_reg_mask);
  int W = ((iw0 >> LDSTiiFP_W_bits) & LDSTiiFP_W_mask);

  if (W == 0)
    return reg < 8 ? DREG_MASK (reg) : 0;
  else
    return 0;
}

static int
decode_LDSTii_0 (int iw0)
{
  /* LDSTii
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 1 | 0 | 1 |.W.|.op....|.offset........|.ptr.......|.reg.......|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int reg = ((iw0 >> LDSTii_reg_bit) & LDSTii_reg_mask);
  int opc = ((iw0 >> LDSTii_op_bit) & LDSTii_op_mask);
  int W = ((iw0 >> LDSTii_W_bit) & LDSTii_W_mask);

  if (W == 0 && opc != 3)
    return DREG_MASK (reg);
  else if (W == 0 && opc == 3)
   return 0;
  else if (W == 1 && opc == 0)
    return 0;
  else if (W == 1 && opc == 1)
    return 0;
  else if (W == 1 && opc == 3)
    return 0;

  abort ();
}

static int
decode_dsp32mac_0 (int iw0, int iw1)
{
  int result = 0;
  /* dsp32mac
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 1 | 1 | 0 | 0 |.M.| 0 | 0 |.mmod..........|.MM|.P.|.w1|.op1...|
     |.h01|.h11|.w0|.op0...|.h00|.h10|.dst.......|.src0......|.src1..|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int op1  = ((iw0 >> (DSP32Mac_op1_bits - 16)) & DSP32Mac_op1_mask);
  int w1   = ((iw0 >> (DSP32Mac_w1_bits - 16)) & DSP32Mac_w1_mask);
  int P    = ((iw0 >> (DSP32Mac_p_bits - 16)) & DSP32Mac_p_mask);
  int mmod = ((iw0 >> (DSP32Mac_mmod_bits - 16)) & DSP32Mac_mmod_mask);
  int w0   = ((iw1 >> DSP32Mac_w0_bits) & DSP32Mac_w0_mask);
  int MM   = ((iw1 >> DSP32Mac_MM_bits) & DSP32Mac_MM_mask);
  int dst  = ((iw1 >> DSP32Mac_dst_bits) & DSP32Mac_dst_mask);
  int op0  = ((iw1 >> DSP32Mac_op0_bits) & DSP32Mac_op0_mask);

  if (w0 == 0 && w1 == 0 && op1 == 3 && op0 == 3)
    return 0;

  if (op1 == 3 && MM)
    return 0;

  if ((w1 || w0) && mmod == M_W32)
    return 0;

  if (((1 << mmod) & (P ? 0x131b : 0x1b5f)) == 0)
    return 0;

  if (w1 == 1 || op1 != 3)
    {
      if (w1)
	{
	  if (P)
	    return DREG_MASK (dst + 1);
	  else
	    return DREGH_MASK (dst);
	}
    }

  if (w0 == 1 || op0 != 3)
    {
      if (w0)
	{
	  if (P)
	    return DREG_MASK (dst);
	  else
	    return DREGL_MASK (dst);
	}
    }

  return result;
}

static int
decode_dsp32mult_0 (int iw0, int iw1)
{
  /* dsp32mult
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 1 | 1 | 0 | 0 |.M.| 0 | 1 |.mmod..........|.MM|.P.|.w1|.op1...|
     |.h01|.h11|.w0|.op0...|.h00|.h10|.dst.......|.src0......|.src1..|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int w1   = ((iw0 >> (DSP32Mac_w1_bits - 16)) & DSP32Mac_w1_mask);
  int P    = ((iw0 >> (DSP32Mac_p_bits - 16)) & DSP32Mac_p_mask);
  int mmod = ((iw0 >> (DSP32Mac_mmod_bits - 16)) & DSP32Mac_mmod_mask);
  int w0   = ((iw1 >> DSP32Mac_w0_bits) & DSP32Mac_w0_mask);
  int dst  = ((iw1 >> DSP32Mac_dst_bits) & DSP32Mac_dst_mask);
  int result = 0;

  if (w1 == 0 && w0 == 0)
    return 0;

  if (((1 << mmod) & (P ? 0x313 : 0x1b57)) == 0)
    return 0;

  if (w1)
    {
      if (P)
	return DREG_MASK (dst | 1);
      else
	return DREGH_MASK (dst);
    }

  if (w0)
    {
      if (P)
	return DREG_MASK (dst);
      else
	return DREGL_MASK (dst);
    }

  return result;
}

static int
decode_dsp32alu_0 (int iw0, int iw1)
{
  /* dsp32alu
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 1 | 1 | 0 | 0 |.M.| 1 | 0 | - | - | - |.HL|.aopcde............|
     |.aop...|.s.|.x.|.dst0......|.dst1......|.src0......|.src1......|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int s    = ((iw1 >> DSP32Alu_s_bits) & DSP32Alu_s_mask);
  int x    = ((iw1 >> DSP32Alu_x_bits) & DSP32Alu_x_mask);
  int aop  = ((iw1 >> DSP32Alu_aop_bits) & DSP32Alu_aop_mask);
  int dst0 = ((iw1 >> DSP32Alu_dst0_bits) & DSP32Alu_dst0_mask);
  int dst1 = ((iw1 >> DSP32Alu_dst1_bits) & DSP32Alu_dst1_mask);
  int HL   = ((iw0 >> (DSP32Alu_HL_bits - 16)) & DSP32Alu_HL_mask);
  int aopcde = ((iw0 >> (DSP32Alu_aopcde_bits - 16)) & DSP32Alu_aopcde_mask);

  if (aop == 0 && aopcde == 9 && s == 0)
    return 0;
  else if (aop == 2 && aopcde == 9 && HL == 0 && s == 0)
    return 0;
  else if (aop >= x * 2 && aopcde == 5)
    return HL ? DREGH_MASK (dst0) : DREGL_MASK (dst0);
  else if (HL == 0 && aopcde == 2)
    return DREGL_MASK (dst0);
  else if (HL == 1 && aopcde == 2)
    return DREGH_MASK (dst0);
  else if (HL == 0 && aopcde == 3)
    return DREGL_MASK (dst0);
  else if (HL == 1 && aopcde == 3)
    return DREGH_MASK (dst0);

  else if (aop == 0 && aopcde == 9 && s == 1)
    return 0;
  else if (aop == 1 && aopcde == 9 && s == 0)
    return 0;
  else if (aop == 2 && aopcde == 9 && s == 1)
    return 0;
  else if (aop == 3 && aopcde == 9 && s == 0)
    return 0;
  else if (aopcde == 8)
    return 0;
  else if (aop == 0 && aopcde == 11)
    return DREG_MASK (dst0);
  else if (aop == 1 && aopcde == 11)
    return HL ? DREGH_MASK (dst0) : DREGL_MASK (dst0);
  else if (aopcde == 11)
    return 0;
  else if (aopcde == 22)
    return DREG_MASK (dst0);

  else if ((aop == 0 || aop == 1) && aopcde == 14)
    return 0;
  else if (aop == 3 && HL == 0 && aopcde == 14)
    return 0;

  else if (aop == 3 && HL == 0 && aopcde == 15)
    return DREG_MASK (dst0);

  else if (aop == 1 && aopcde == 16)
    return 0;

  else if (aop == 0 && aopcde == 16)
    return 0;

  else if (aop == 3 && HL == 0 && aopcde == 16)
    return 0;

  else if (aop == 3 && HL == 0 && aopcde == 7)
    return DREG_MASK (dst0);
  else if ((aop == 0 || aop == 1 || aop == 2) && aopcde == 7)
    return DREG_MASK (dst0);

  else if (aop == 0 && aopcde == 12)
    return DREG_MASK (dst0);
  else if (aop == 1 && aopcde == 12)
    return DREG_MASK (dst0) | DREG_MASK (dst1);
  else if (aop == 3 && aopcde == 12)
    return HL ? DREGH_MASK (dst0) : DREGL_MASK (dst0);

  else if (aopcde == 0)
    return DREG_MASK (dst0);
  else if (aopcde == 1)
    return DREG_MASK (dst0) | DREG_MASK (dst1);

  else if (aop == 0 && aopcde == 10)
    return DREGL_MASK (dst0);
  else if (aop == 1 && aopcde == 10)
    return DREGL_MASK (dst0);

  else if ((aop == 1 || aop == 0) && aopcde == 4)
    return DREG_MASK (dst0);
  else if (aop == 2 && aopcde == 4)
    return DREG_MASK (dst0) | DREG_MASK (dst1);

  else if (aop == 0 && aopcde == 17)
    return DREG_MASK (dst0) | DREG_MASK (dst1);
  else if (aop == 1 && aopcde == 17)
    return DREG_MASK (dst0) | DREG_MASK (dst1);
  else if (aop == 0 && aopcde == 18)
    return 0;
  else if (aop == 3 && aopcde == 18)
    return 0;

  else if ((aop == 0 || aop == 1 || aop == 2) && aopcde == 6)
    return DREG_MASK (dst0);

  else if ((aop == 0 || aop == 1) && aopcde == 20)
    return DREG_MASK (dst0);

  else if ((aop == 0 || aop == 1) && aopcde == 21)
    return DREG_MASK (dst0) | DREG_MASK (dst1);

  else if (aop == 0 && aopcde == 23 && HL == 1)
    return DREG_MASK (dst0);
  else if (aop == 0 && aopcde == 23 && HL == 0)
    return DREG_MASK (dst0);

  else if (aop == 0 && aopcde == 24)
    return DREG_MASK (dst0);
  else if (aop == 1 && aopcde == 24)
    return DREG_MASK (dst0) | DREG_MASK (dst1);
  else if (aopcde == 13)
    return DREG_MASK (dst0) | DREG_MASK (dst1);
  else
    return 0;

  return 4;
}

static int
decode_dsp32shift_0 (int iw0, int iw1)
{
  /* dsp32shift
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 1 | 1 | 0 | 0 |.M.| 1 | 1 | 0 | 0 | - | - |.sopcde............|
     |.sop...|.HLs...|.dst0......| - | - | - |.src0......|.src1......|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int HLs  = ((iw1 >> DSP32Shift_HLs_bits) & DSP32Shift_HLs_mask);
  int sop  = ((iw1 >> DSP32Shift_sop_bits) & DSP32Shift_sop_mask);
  int src0 = ((iw1 >> DSP32Shift_src0_bits) & DSP32Shift_src0_mask);
  int src1 = ((iw1 >> DSP32Shift_src1_bits) & DSP32Shift_src1_mask);
  int dst0 = ((iw1 >> DSP32Shift_dst0_bits) & DSP32Shift_dst0_mask);
  int sopcde = ((iw0 >> (DSP32Shift_sopcde_bits - 16)) & DSP32Shift_sopcde_mask);

  if (sop == 0 && sopcde == 0)
    return HLs & 2 ? DREGH_MASK (dst0) : DREGL_MASK (dst0);
  else if (sop == 1 && sopcde == 0)
    return HLs & 2 ? DREGH_MASK (dst0) : DREGL_MASK (dst0);
  else if (sop == 2 && sopcde == 0)
    return HLs & 2 ? DREGH_MASK (dst0) : DREGL_MASK (dst0);
  else if (sop == 0 && sopcde == 3)
    return 0;
  else if (sop == 1 && sopcde == 3)
    return 0;
  else if (sop == 2 && sopcde == 3)
    return 0;
  else if (sop == 3 && sopcde == 3)
    return DREG_MASK (dst0);
  else if (sop == 0 && sopcde == 1)
    return DREG_MASK (dst0);
  else if (sop == 1 && sopcde == 1)
    return DREG_MASK (dst0);
  else if (sop == 2 && sopcde == 1)
    return DREG_MASK (dst0);
  else if (sopcde == 2)
    return DREG_MASK (dst0);
  else if (sopcde == 4)
    return DREG_MASK (dst0);
  else if (sop == 0 && sopcde == 5)
    return DREGL_MASK (dst0);
  else if (sop == 1 && sopcde == 5)
    return DREGL_MASK (dst0);
  else if (sop == 2 && sopcde == 5)
    return DREGL_MASK (dst0);
  else if (sop == 0 && sopcde == 6)
    return DREGL_MASK (dst0);
  else if (sop == 1 && sopcde == 6)
    return DREGL_MASK (dst0);
  else if (sop == 3 && sopcde == 6)
    return DREGL_MASK (dst0);
  else if (sop == 0 && sopcde == 7)
    return DREGL_MASK (dst0);
  else if (sop == 1 && sopcde == 7)
    return DREGL_MASK (dst0);
  else if (sop == 2 && sopcde == 7)
    return DREGL_MASK (dst0);
  else if (sop == 3 && sopcde == 7)
    return DREGL_MASK (dst0);
  else if (sop == 0 && sopcde == 8)
    return DREG_MASK (src0) | DREG_MASK (src1);
#if 0
    {
      OUTS (outf, "BITMUX (");
      OUTS (outf, dregs (src0));
      OUTS (outf, ", ");
      OUTS (outf, dregs (src1));
      OUTS (outf, ", A0) (ASR)");
    }
#endif
  else if (sop == 1 && sopcde == 8)
    return DREG_MASK (src0) | DREG_MASK (src1);
#if 0
    {
      OUTS (outf, "BITMUX (");
      OUTS (outf, dregs (src0));
      OUTS (outf, ", ");
      OUTS (outf, dregs (src1));
      OUTS (outf, ", A0) (ASL)");
    }
#endif
  else if (sopcde == 9)
    return sop < 2 ? DREGL_MASK (dst0) : DREG_MASK (dst0);
  else if (sopcde == 10)
    return DREG_MASK (dst0);
  else if (sop == 0 && sopcde == 11)
    return DREGL_MASK (dst0);
  else if (sop == 1 && sopcde == 11)
    return DREGL_MASK (dst0);
  else if (sop == 0 && sopcde == 12)
    return 0;
  else if (sop == 1 && sopcde == 12)
    return DREGL_MASK (dst0);
  else if (sop == 0 && sopcde == 13)
    return DREG_MASK (dst0);
  else if (sop == 1 && sopcde == 13)
    return DREG_MASK (dst0);
  else if (sop == 2 && sopcde == 13)
    return DREG_MASK (dst0);

  abort ();
}

static int
decode_dsp32shiftimm_0 (int iw0, int iw1)
{
  /* dsp32shiftimm
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+
     | 1 | 1 | 0 | 0 |.M.| 1 | 1 | 0 | 1 | - | - |.sopcde............|
     |.sop...|.HLs...|.dst0......|.immag.................|.src1......|
     +---+---+---+---|---+---+---+---|---+---+---+---|---+---+---+---+  */
  int sop      = ((iw1 >> DSP32ShiftImm_sop_bits) & DSP32ShiftImm_sop_mask);
  int bit8     = ((iw1 >> 8) & 0x1);
  int dst0     = ((iw1 >> DSP32ShiftImm_dst0_bits) & DSP32ShiftImm_dst0_mask);
  int sopcde   = ((iw0 >> (DSP32ShiftImm_sopcde_bits - 16)) & DSP32ShiftImm_sopcde_mask);
  int HLs      = ((iw1 >> DSP32ShiftImm_HLs_bits) & DSP32ShiftImm_HLs_mask);


  if (sop == 0 && sopcde == 0)
    return HLs & 2 ? DREGH_MASK (dst0) : DREGL_MASK (dst0);
  else if (sop == 1 && sopcde == 0 && bit8 == 0)
    return HLs & 2 ? DREGH_MASK (dst0) : DREGL_MASK (dst0);
  else if (sop == 1 && sopcde == 0 && bit8 == 1)
    return HLs & 2 ? DREGH_MASK (dst0) : DREGL_MASK (dst0);
  else if (sop == 2 && sopcde == 0 && bit8 == 0)
    return HLs & 2 ? DREGH_MASK (dst0) : DREGL_MASK (dst0);
  else if (sop == 2 && sopcde == 0 && bit8 == 1)
    return HLs & 2 ? DREGH_MASK (dst0) : DREGL_MASK (dst0);
  else if (sop == 2 && sopcde == 3 && HLs == 1)
    return 0;
  else if (sop == 0 && sopcde == 3 && HLs == 0 && bit8 == 0)
    return 0;
  else if (sop == 0 && sopcde == 3 && HLs == 0 && bit8 == 1)
    return 0;
  else if (sop == 0 && sopcde == 3 && HLs == 1 && bit8 == 0)
    return 0;
  else if (sop == 0 && sopcde == 3 && HLs == 1 && bit8 == 1)
    return 0;
  else if (sop == 1 && sopcde == 3 && HLs == 0)
    return 0;
  else if (sop == 1 && sopcde == 3 && HLs == 1)
    return 0;
  else if (sop == 2 && sopcde == 3 && HLs == 0)
    return 0;
  else if (sop == 1 && sopcde == 1 && bit8 == 0)
    return DREG_MASK (dst0);
  else if (sop == 1 && sopcde == 1 && bit8 == 1)
    return DREG_MASK (dst0);
  else if (sop == 2 && sopcde == 1 && bit8 == 1)
    return DREG_MASK (dst0);
  else if (sop == 2 && sopcde == 1 && bit8 == 0)
    return DREG_MASK (dst0);
  else if (sop == 0 && sopcde == 1)
    return DREG_MASK (dst0);
  else if (sop == 1 && sopcde == 2)
    return DREG_MASK (dst0);
  else if (sop == 2 && sopcde == 2 && bit8 == 1)
    return DREG_MASK (dst0);
  else if (sop == 2 && sopcde == 2 && bit8 == 0)
    return DREG_MASK (dst0);
  else if (sop == 3 && sopcde == 2)
    return DREG_MASK (dst0);
  else if (sop == 0 && sopcde == 2)
    return DREG_MASK (dst0);

  abort ();
}

int
insn_regmask (int iw0, int iw1)
{
  if ((iw0 & 0xf7ff) == 0xc003 && iw1 == 0x1800)
    return 0; /* MNOP */
  else if ((iw0 & 0xff00) == 0x0000)
    return decode_ProgCtrl_0 (iw0);
  else if ((iw0 & 0xffc0) == 0x0240)
    abort ();
  else if ((iw0 & 0xff80) == 0x0100)
    abort ();
  else if ((iw0 & 0xfe00) == 0x0400)
    abort ();
  else if ((iw0 & 0xfe00) == 0x0600)
    abort ();
  else if ((iw0 & 0xf800) == 0x0800)
    abort ();
  else if ((iw0 & 0xffe0) == 0x0200)
    abort ();
  else if ((iw0 & 0xff00) == 0x0300)
    abort ();
  else if ((iw0 & 0xf000) == 0x1000)
    abort ();
  else if ((iw0 & 0xf000) == 0x2000)
    abort ();
  else if ((iw0 & 0xf000) == 0x3000)
    abort ();
  else if ((iw0 & 0xfc00) == 0x4000)
    abort ();
  else if ((iw0 & 0xfe00) == 0x4400)
    abort ();
  else if ((iw0 & 0xf800) == 0x4800)
    abort ();
  else if ((iw0 & 0xf000) == 0x5000)
    abort ();
  else if ((iw0 & 0xf800) == 0x6000)
    abort ();
  else if ((iw0 & 0xf800) == 0x6800)
    abort ();
  else if ((iw0 & 0xf000) == 0x8000)
    return decode_LDSTpmod_0 (iw0);
  else if ((iw0 & 0xff60) == 0x9e60)
    return decode_dagMODim_0 (iw0);
  else if ((iw0 & 0xfff0) == 0x9f60)
    return decode_dagMODik_0 (iw0);
  else if ((iw0 & 0xfc00) == 0x9c00)
    return decode_dspLDST_0 (iw0);
  else if ((iw0 & 0xf000) == 0x9000)
    return decode_LDST_0 (iw0);
  else if ((iw0 & 0xfc00) == 0xb800)
    return decode_LDSTiiFP_0 (iw0);
  else if ((iw0 & 0xe000) == 0xA000)
    return decode_LDSTii_0 (iw0);
  else if ((iw0 & 0xff80) == 0xe080 && (iw1 & 0x0C00) == 0x0000)
    abort ();
  else if ((iw0 & 0xff00) == 0xe100 && (iw1 & 0x0000) == 0x0000)
    abort ();
  else if ((iw0 & 0xfe00) == 0xe200 && (iw1 & 0x0000) == 0x0000)
    abort ();
  else if ((iw0 & 0xfc00) == 0xe400 && (iw1 & 0x0000) == 0x0000)
    abort ();
  else if ((iw0 & 0xfffe) == 0xe800 && (iw1 & 0x0000) == 0x0000)
    abort ();
  else if ((iw0 & 0xf600) == 0xc000 && (iw1 & 0x0000) == 0x0000)
    return decode_dsp32mac_0 (iw0, iw1);
  else if ((iw0 & 0xf600) == 0xc200 && (iw1 & 0x0000) == 0x0000)
    return decode_dsp32mult_0 (iw0, iw1);
  else if ((iw0 & 0xf7c0) == 0xc400 && (iw1 & 0x0000) == 0x0000)
    return decode_dsp32alu_0 (iw0, iw1);
  else if ((iw0 & 0xf780) == 0xc600 && (iw1 & 0x01c0) == 0x0000)
    return decode_dsp32shift_0 (iw0, iw1);
  else if ((iw0 & 0xf780) == 0xc680 && (iw1 & 0x0000) == 0x0000)
    return decode_dsp32shiftimm_0 (iw0, iw1);
  else if ((iw0 & 0xff00) == 0xf800)
    abort ();
  else if ((iw0 & 0xFFC0) == 0xf000 && (iw1 & 0x0000) == 0x0000)
    abort ();

  abort ();
}
@


1.41
log
@gas: blackfin: support numeric local labels with LOOP_BEGIN/LOOP_END pseudo insns

The current LOOP_BEGIN/LOOP_END pseudo insns hit parser errors when trying
to use numeric local labels.  So add support for them.

Signed-off-by: David Gibson <david.gibson@@analog.com>
Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d289 1
d296 1
d303 1
d310 1
d317 1
@


1.40
log
@gas: blackfin: fix LOOP_BEGIN/LOOP_END pseudo insns handling of local labels

The current LOOP_BEGIN/LOOP_END pseudo insns hit "Internal errors" when
using local labels as the loop names due to attempts at removing them.

Signed-off-by: David Gibson <david.gibson@@analog.com>
Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d1908 9
@


1.39
log
@opcodes/gas: blackfin: support OUTC debug insn

The disassembler has partial (but incomplete/broken) support already for
the pseudo debug insn OUTC, so let's fix it up and finish it.  And now
that the disassembler can handle it, make sure our assembler can output
it too.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d1877 1
d1900 3
a1902 1
  symbol_remove (symbol_find (loopsym), &symbol_rootP, &symbol_lastP);
d1904 1
a1904 1
  return bfin_gen_loopsetup(lbegin, reg, rop, lend, preg);
@


1.38
log
@gas: blackfin: add support for BF51x-0.2 processors

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d1823 10
@


1.37
log
@gas: blackfin: add support for BF592 processors

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d210 1
d214 1
d218 1
d222 1
@


1.36
log
@gas: blackfin: allow end-of-line comments via #

We don't use the # character in the Blackfin assembly language, so let it
start end-of-line comments like most other assemblers.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d184 2
a185 1
  BFIN_CPU_BF561
d317 3
@


1.35
log
@strip trailing whitespace in Blackfin files
@
text
@d2 1
a2 1
   Copyright 2005, 2006, 2007, 2008, 2009
d139 1
a139 1
const char comment_chars[] = "";
@


1.34
log
@add support for Blackfin bf504/bf506
@
text
@d88 1
a88 1
      
d450 1
a450 1
  
d463 1
a463 1
#endif 
d853 1
a853 1
bfd_boolean  
d855 1
a855 1
{         
d857 1
a857 1
    {     
d865 1
a865 1
        
d868 1
a868 1
    }     
d1949 1
a1949 1
} 
d2442 1
a2442 1
  else if (aop == 1 && aopcde == 24) 
@


1.33
log
@	* doc/as.texinfo: Add Blackfin options.
	* doc/c-bfin.texi: Document -mfdpic, -mno-fdpic and -mnopic.
	* config/tc-bfin.c (md_show_usage): Show usage for all
	Blackfin specific options.
@
text
@d154 2
d205 4
@


1.32
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d421 1
a421 1
md_show_usage (FILE * stream ATTRIBUTE_UNUSED)
d423 4
a426 1
  fprintf (stream, _(" BFIN specific command line options:\n"));
@


1.31
log
@ 	gas/
	* config/bfin-parse.y (asm_1): Implement HLT instruction.
	Fix comments for DBGA, DBGAH and DBGAL.
	* config/tc-bfin.c (bfin_gen_pseudodbg_assert): Change according
	to the new encoding of DBGA, DBGAH, and DBGAL.

	include/
	* opcode/bfin.h (PseudoDbg_Assert): Add bits_grp and mask_grp.
	(PseudoDbg_Assert_grp_bits, PseudoDbg_Assert_grp_mask): Define.
	(PseudoDbg_Assert_dbgop_bits, PseudoDbg_Assert_dbgop_mask,
	PseudoDbg_Assert_dontcare_bits, PseudoDbg_Assert_dontcare_mask):
	Adjust accordingly.
	(init_PseudoDbg_Assert): Add PseudoDbg_Assert_grp_bits and
	PseudoDbg_Assert_grp_mask.

	opcodes/
	* bfin-dis.c (decode_pseudodbg_assert_0): Change according
	to the new encoding of DBGA, DBGAH, and DBGAL.
	(_print_insn_bfin): Likewise.
@
text
@d1137 1
d1306 1
a1306 1
  int reloc = 0;
d1310 3
a1312 3
   case 0 : reloc = BFD_RELOC_BFIN_24_PCREL_JUMP_L; break;
   case 1 : reloc = BFD_RELOC_24_PCREL; break;
   case 2 : reloc = BFD_RELOC_BFIN_PLTPC; break;
d1322 1
a1322 1
                     Expr_Node_Gen_Reloc (addr, reloc));
d1340 1
a1340 1
bfin_gen_ldimmhalf (REG_T reg, int H, int S, int Z, Expr_Node * phword, int reloc)
d1353 1
a1353 1
  if (reloc == 2)
d1357 1
a1357 1
  else if (reloc == 1)
d1454 1
a1454 1
bfin_gen_ldstii (REG_T ptr, REG_T reg, Expr_Node * poffset, int W, int op)
a1459 1

d1466 1
a1466 1
  switch (op)
d1484 1
a1484 1
  ASSIGN (op);
d1583 1
a1583 1
bfin_gen_compi2opd (REG_T dst, int src, int op)
d1589 1
a1589 1
  ASSIGN (op);
d1595 1
a1595 1
bfin_gen_compi2opp (REG_T dst, int src, int op)
d1601 1
a1601 1
  ASSIGN (op);
d1607 1
a1607 1
bfin_gen_dagmodik (REG_T i, int op)
d1612 1
a1612 1
  ASSIGN (op);
d1618 1
a1618 1
bfin_gen_dagmodim (REG_T i, REG_T m, int op, int br)
d1624 1
a1624 1
  ASSIGN (op);
d1687 1
a1687 1
bfin_gen_cc2stat (int cbit, int op, int D)
d1692 1
a1692 1
  ASSIGN (op);
d1716 1
a1716 1
bfin_gen_cc2dreg (int op, REG_T reg)
d1720 1
a1720 1
  ASSIGN (op);
d1738 1
a1738 1
bfin_gen_cactrl (REG_T reg, int a, int op)
d1744 1
a1744 1
  ASSIGN (op);
d1844 1
a1844 1
bfin_gen_loop (Expr_Node *expr, REG_T reg, int rop, REG_T preg)
d1851 1
a1851 1
  loopsym = expr->value.s_value;
d1878 1
a1878 1
bfin_loop_beginend (Expr_Node *expr, int begin)
d1882 1
a1882 1
  symbolS *line_label;
d1885 1
a1885 1
  loopsym = expr->value.s_value;
d1894 1
a1894 1
  line_label = colon (label_name);
d1899 1
a1899 1
    ((struct local_symbol *) line_label)->lsy_value -= last_insn_size;
d2021 1
a2021 1
  int op  = ((iw0 >> DagMODim_op_bits) & DagMODim_op_mask);
d2023 1
a2023 1
  if (op == 0 || op == 1)
d2202 1
a2202 1
  int op = ((iw0 >> LDSTii_op_bit) & LDSTii_op_mask);
d2205 1
a2205 1
  if (W == 0 && op != 3)
d2207 1
a2207 1
  else if (W == 0 && op == 3)
d2209 1
a2209 1
  else if (W == 1 && op == 0)
d2211 1
a2211 1
  else if (W == 1 && op == 1)
d2213 1
a2213 1
  else if (W == 1 && op == 3)
@


1.30
log
@	* config/tc-bfin.c (md_parse_option): Call as_fatal for bad
	-mcpu= option.
@
text
@d1794 1
d1799 2
@


1.29
log
@	gas/
	* config/bfin-parse.y: Remove trailing whitespace.
	(ccstat): Indent.
	* config/tc-bfin.c (struct bfin_reg_entry): Remove.
	(bfin_reg_info[]): Remove.

	opcodes/
	* bfin-dis.c (_print_insn_bfin): Don't declare.
	(print_insn_bfin): Don't declare.
	(dregs_pair): Remove.
	(ignore_bits): Remove.
	(ccstat): Remove.
@
text
@d354 1
a354 4
	  {
	    error ("-mcpu=%s is not valid", arg);
	    return 0;
	  }
d388 1
a388 2
		error ("-mcpu=%s has invalid silicon revision", arg);
		return 0;
@


1.28
log
@	* config/tc-bfin.c (md_assemble): Bump line counters if there is
	EOL in the instruction.

	testsuite/
	* gas/bfin/line_number.l, gas/bfin/line_number.s: New test.
	* gas/bfin/bfin.exp: Add the new test.
@
text
@a59 157
/* Registers list.  */
struct bfin_reg_entry
{
  const char *name;
  int number;
};

static const struct bfin_reg_entry bfin_reg_info[] = {
  {"R0.L", REG_RL0},
  {"R1.L", REG_RL1},
  {"R2.L", REG_RL2},
  {"R3.L", REG_RL3},
  {"R4.L", REG_RL4},
  {"R5.L", REG_RL5},
  {"R6.L", REG_RL6},
  {"R7.L", REG_RL7},
  {"R0.H", REG_RH0},
  {"R1.H", REG_RH1},
  {"R2.H", REG_RH2},
  {"R3.H", REG_RH3},
  {"R4.H", REG_RH4},
  {"R5.H", REG_RH5},
  {"R6.H", REG_RH6},
  {"R7.H", REG_RH7},
  {"R0", REG_R0},
  {"R1", REG_R1},
  {"R2", REG_R2},
  {"R3", REG_R3},
  {"R4", REG_R4},
  {"R5", REG_R5},
  {"R6", REG_R6},
  {"R7", REG_R7},
  {"P0", REG_P0},
  {"P0.H", REG_P0},
  {"P0.L", REG_P0},
  {"P1", REG_P1},
  {"P1.H", REG_P1},
  {"P1.L", REG_P1},
  {"P2", REG_P2},
  {"P2.H", REG_P2},
  {"P2.L", REG_P2},
  {"P3", REG_P3},
  {"P3.H", REG_P3},
  {"P3.L", REG_P3},
  {"P4", REG_P4},
  {"P4.H", REG_P4},
  {"P4.L", REG_P4},
  {"P5", REG_P5},
  {"P5.H", REG_P5},
  {"P5.L", REG_P5},
  {"SP", REG_SP},
  {"SP.L", REG_SP},
  {"SP.H", REG_SP},
  {"FP", REG_FP},
  {"FP.L", REG_FP},
  {"FP.H", REG_FP},
  {"A0x", REG_A0x},
  {"A1x", REG_A1x},
  {"A0w", REG_A0w},
  {"A1w", REG_A1w},
  {"A0.x", REG_A0x},
  {"A1.x", REG_A1x},
  {"A0.w", REG_A0w},
  {"A1.w", REG_A1w},
  {"A0", REG_A0},
  {"A0.L", REG_A0},
  {"A0.H", REG_A0},
  {"A1", REG_A1},
  {"A1.L", REG_A1},
  {"A1.H", REG_A1},
  {"I0", REG_I0},
  {"I0.L", REG_I0},
  {"I0.H", REG_I0},
  {"I1", REG_I1},
  {"I1.L", REG_I1},
  {"I1.H", REG_I1},
  {"I2", REG_I2},
  {"I2.L", REG_I2},
  {"I2.H", REG_I2},
  {"I3", REG_I3},
  {"I3.L", REG_I3},
  {"I3.H", REG_I3},
  {"M0", REG_M0},
  {"M0.H", REG_M0},
  {"M0.L", REG_M0},
  {"M1", REG_M1},
  {"M1.H", REG_M1},
  {"M1.L", REG_M1},
  {"M2", REG_M2},
  {"M2.H", REG_M2},
  {"M2.L", REG_M2},
  {"M3", REG_M3},
  {"M3.H", REG_M3},
  {"M3.L", REG_M3},
  {"B0", REG_B0},
  {"B0.H", REG_B0},
  {"B0.L", REG_B0},
  {"B1", REG_B1},
  {"B1.H", REG_B1},
  {"B1.L", REG_B1},
  {"B2", REG_B2},
  {"B2.H", REG_B2},
  {"B2.L", REG_B2},
  {"B3", REG_B3},
  {"B3.H", REG_B3},
  {"B3.L", REG_B3},
  {"L0", REG_L0},
  {"L0.H", REG_L0},
  {"L0.L", REG_L0},
  {"L1", REG_L1},
  {"L1.H", REG_L1},
  {"L1.L", REG_L1},
  {"L2", REG_L2},
  {"L2.H", REG_L2},
  {"L2.L", REG_L2},
  {"L3", REG_L3},
  {"L3.H", REG_L3},
  {"L3.L", REG_L3},
  {"AZ", S_AZ},
  {"AN", S_AN},
  {"AC0", S_AC0},
  {"AC1", S_AC1},
  {"AV0", S_AV0},
  {"AV0S", S_AV0S},
  {"AV1", S_AV1},
  {"AV1S", S_AV1S},
  {"AQ", S_AQ},
  {"V", S_V},
  {"VS", S_VS},
  {"sftreset", REG_sftreset},
  {"omode", REG_omode},
  {"excause", REG_excause},
  {"emucause", REG_emucause},
  {"idle_req", REG_idle_req},
  {"hwerrcause", REG_hwerrcause},
  {"CC", REG_CC},
  {"LC0", REG_LC0},
  {"LC1", REG_LC1},
  {"ASTAT", REG_ASTAT},
  {"RETS", REG_RETS},
  {"LT0", REG_LT0},
  {"LB0", REG_LB0},
  {"LT1", REG_LT1},
  {"LB1", REG_LB1},
  {"CYCLES", REG_CYCLES},
  {"CYCLES2", REG_CYCLES2},
  {"USP", REG_USP},
  {"SEQSTAT", REG_SEQSTAT},
  {"SYSCFG", REG_SYSCFG},
  {"RETI", REG_RETI},
  {"RETX", REG_RETX},
  {"RETN", REG_RETN},
  {"RETE", REG_RETE},
  {"EMUDAT", REG_EMUDAT},
  {0, 0}
};

@


1.27
log
@	* config/bfin-parse.y (asm_1): Add LOOP_BEGIN and LOOP_END.
	* config/tc-bfin.c (bfin_start_line_hook): Remove.
	(bfin_loop_beginend): New.
	* config/tc-bfin.h (bfin_start_line_hook): Don't declare.
	(md_start_line_hook): Don't define.
	* config/bfin-aux.h (bfin_loop_beginend): Declare.

	testsuite/
	* gas/bfin/loop.s, gas/bfin/loop.d: New test.
	* gas/bfin/loop2.s, gas/bfin/loop2.d: New test.
	* gas/bfin/loop3.s, gas/bfin/loop3.d: New test.
	* gas/bfin/bfin.exp: Add the new tests.
@
text
@d715 4
@


1.26
log
@update copyright dates
@
text
@a1018 117

/* Handle the LOOP_BEGIN and LOOP_END statements.
   Parse the Loop_Begin/Loop_End and create a label.  */
void
bfin_start_line_hook ()
{
  bfd_boolean maybe_begin = FALSE;
  bfd_boolean maybe_end = FALSE;

  char *c1, *label_name;
  symbolS *line_label;
  char *c = input_line_pointer;
  int cr_num = 0;

  while (ISSPACE (*c))
    {
      if (*c == '\n')
	cr_num++;
      c++;
    }

  /* Look for Loop_Begin or Loop_End statements.  */

  if (*c != 'L' && *c != 'l')
    return;

  c++;
  if (*c != 'O' && *c != 'o')
    return;

  c++;
  if (*c != 'O' && *c != 'o')
    return;
 
  c++;
  if (*c != 'P' && *c != 'p')
    return;

  c++;
  if (*c != '_')
    return;

  c++;
  if (*c == 'E' || *c == 'e')
    maybe_end = TRUE;
  else if (*c == 'B' || *c == 'b')
    maybe_begin = TRUE;
  else
    return;

  if (maybe_end)
    {
      c++;
      if (*c != 'N' && *c != 'n')
	return;

      c++;
      if (*c != 'D' && *c != 'd')
        return;
    }

  if (maybe_begin)
    {
      c++;
      if (*c != 'E' && *c != 'e')
	return;

      c++;
      if (*c != 'G' && *c != 'g')
        return;

      c++;
      if (*c != 'I' && *c != 'i')
	return;

      c++;
      if (*c != 'N' && *c != 'n')
        return;
    }

  c++;
  while (ISSPACE (*c)) c++;
  c1 = c;
  while (ISALPHA (*c) || ISDIGIT (*c) || *c == '_') c++;

  if (input_line_pointer[-1] == '\n')
    bump_line_counters ();

  while (cr_num--)
    bump_line_counters ();

  input_line_pointer = c;
  if (maybe_end)
    {
      label_name = (char *) xmalloc ((c - c1) + strlen ("__END") + 5);
      label_name[0] = 0;
      strcat (label_name, "L$L$");
      strncat (label_name, c1, c-c1);
      strcat (label_name, "__END");
    }
  else /* maybe_begin.  */
    {
      label_name = (char *) xmalloc ((c - c1) + strlen ("__BEGIN") + 5);
      label_name[0] = 0;
      strcat (label_name, "L$L$");
      strncat (label_name, c1, c-c1);
      strcat (label_name, "__BEGIN");
    }

  line_label = colon (label_name);

  /* Loop_End follows the last instruction in the loop.
     Adjust label address.  */
  if (maybe_end)
    ((struct local_symbol *) line_label)->lsy_value -= last_insn_size;
}

d2031 25
@


1.25
log
@	2007-09-28  Bernd Schmidt  <bernd.schmidt@@analog.com>
	* config/tc-bfin.c (bfin_fix_adjustable): Partially revert the
	2007-08-23 change; BFD_RELOC_BFIN_GOT is not adjustable.

	2007-08-23  Jie Zhang  <jie.zhang@@analog.com>
	* config/tc-bfin.c (bfin_fix_adjustable): Adjust
	BFD_RELOC_BFIN_GOT, BFD_RELOC_BFIN_GOT17M4 and
	BFD_RELOC_BFIN_FUNCDESC_GOT17M4.
@
text
@d2 1
a2 1
   Copyright 2005, 2006, 2007, 2008
@


1.24
log
@	* read.c (TC_START_LABEL): Add a new argument.
	(read_a_source_file): Pass the beginning of the symbol through
	the new argument of TC_START_LABEL.
	* config/tc-arm.h (TC_START_LABEL): Add a new argument.
	* config/tc-bfin.c (bfin_start_label): Only search '(' and '['
	from the beginning of the symbol.
	* config/tc-bfin.h (TC_START_LABEL): Add the new argument.
	* config/tc-d30v.h (TC_START_LABEL): Likewise.
	* config/tc-fr30.h (TC_START_LABEL): Likewise.
	* config/tc-m32c.h (TC_START_LABEL): Likewise.
	* config/tc-m32r.h (TC_START_LABEL): Likewise.
	* config/tc-mep.h (TC_START_LABEL): Likewise.

	testsuite/
	* gas/bfin/stack2.s: Add pop multiple instruction with a label
	on the same line.
	* gas/bfin/stack2.d: Adjust accordingly.
@
text
@a1007 2
    case BFD_RELOC_BFIN_GOT17M4:
    case BFD_RELOC_BFIN_FUNCDESC_GOT17M4:
@


1.23
log
@	From Jie Zhang  <jie.zhang@@analog.com>
	* config/tc-bfin.h (bfin_anomaly_checks): Declare.
	(AC_05000074): Define.
	(ENABLE_AC_05000074): Define.
	* config/tc-bfin.c (enum bfin_cpu_type): New.
	(bfin_cpu_t): Typedef.
	(bfin_cpu_type): Define.
	(bfin_si_revision): Define.
	(bfin_anomaly_checks): Define.
	(struct bfin_cpu): New.
	(bfin_cpus[]): New. (struct bfin_cpu_isa): Define.
	(bfin_isa): New global variable.
	(OPTION_MCPU): Define.
	(md_longopts[]): Add -mcpu option.
	(md_parse_option): Deal with -mcpu option and initialize
	bfin_anomaly_checks.
	* doc/c-bfin.texi: Rename BFIN to Blackfin throughout.  Document
	-mcpu option.
	* config/bfin-parse.y (gen_multi_instr_1): Check anomaly
	05000074.
@
text
@d2178 1
a2178 1
bfin_start_label (char *ptr)
d2180 6
a2185 7
  ptr--;
  while (!ISSPACE (*ptr) && !is_end_of_line[(unsigned char) *ptr])
    ptr--;

  ptr++;
  if (*ptr == '(' || *ptr == '[')
    return FALSE;
@


1.22
log
@gas/
	* config/bfin-parse.y (gen_multi_instr_1): New function.
	(asm): Use it instead of bfin_gen_multi_instr.
	(error): Add a format string when calling as_bad.
	* config/bfin-defs.h (insn_regmask): Declare.
	* config/tc-bfin.c (DREG_MASK, DREGH_MASK, DREGL_MASK, IREG_MASK): New
	macros.
	(decode_ProgCtrl_0, decode_LDSTpmod_0, decode_dagMODim_0,
	decode_dagMODik_0, decode_dspLDST_0, decode_LDST_0, decode_LDSTiiFP_0,
	decode_LDSTii_0, decode_dsp32mac_0, decode_dsp32mult_0,
	decode_dsp32alu_0, decode_dsp32shift_0, decode_dsp32shitimm_0,
	insn_regmask): New functions.
gas/testsuite/
	* gas/bfin/parallel.s: Add more test cases.
	* gas/bfin/parallel.d: Update accordingly.
	* gas/bfin/resource_conflict.l: New test.
	* gas/bfin/resource_conflict.s: New test.
	* gas/bfin/bfin.exp: Add resource_conflict.
@
text
@d308 162
d475 1
d479 1
d497 70
@


1.21
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d1167 1
a1167 2


d1966 740
@


1.20
log
@Remove unnecessary casts on obstack_alloc invocations.
@
text
@a905 2
#include <assert.h>

d934 1
a934 1
  assert (symbol->type == Expr_Node_Reloc);
@


1.19
log
@	* config/bfin-parse.y: Use C style comments.
	* config/tc-bfin.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-mips.c: Likewise.
@
text
@d963 1
a963 1
  INSTR_T cell = (INSTR_T) obstack_alloc (&mempool, sizeof (struct bfin_insn));
d976 1
a976 1
  return (void *) obstack_alloc (&mempool, n);
@


1.18
log
@Banish PARAMS and PTR.  Convert to ISO C.
Delete unnecessary forward declarations.
@
text
@d1455 2
a1456 2
	{				// load/store access size
	case 0:			// 32 bit
d1459 1
a1459 1
	case 1:			// 16 bit
d1462 1
a1462 1
	case 2:			// 8 bit
@


1.17
log
@	* config/tc-bfin.c (bfin_gen_loop): Remove loop symbol.
@
text
@d2 1
a2 1
   Copyright 2005, 2006, 2007
a39 2
static void bfin_s_bss PARAMS ((int));
static int md_chars_to_number PARAMS ((char *, int));
@


1.16
log
@2008-04-23  Mike Frysinger  <vapier@@gentoo.org>

	* Makefile.am (OBJ_FORMAT_CFILES): Add config/obj-fdpicelf.c.
	(OBJ_FORMAT_HFILES): Add config/obj-fdpicelf.h.
	(obj-fdpicelf.o): Define.
	* Makefile.in: Regenerate.
	* configure.tgt: Set bfd_gas to yes when fmt is fdpicelf.
	(bfin-*-*): Delete.
	(bfin-*-linux-uclibc): New; set fmt to fdpicelf and em to linux.
	(bfin-*-uclinux*): New; set fmt to elf and em to linux.
	* config/obj-fdpicelf.c: New.
	* config/obj-fdpicelf.h: Likewise.
	* config/tc-bfin.c (bfin_flags, bfin_pic_flag): Set default based on
	the OBJ_FDPIC_ELF define.
	(OPTION_NOPIC): Define.
	(md_longopts): Add mnopic and mno-fdpic.
	(md_parse_option): Handle OPTION_NOPIC.
@
text
@d1915 3
@


1.15
log
@gas/:
	* config/tc-bfin.c (bfin_start_line_hook): Localize the labels
	generated for LOOP_BEGIN and LOOP_END instructions.
	(bfin_gen_loop): Likewise.

gas/testsuite/:
	* gas/bfin/flow.d: Adjust since the generated labels for LOOP_BEGIN
	and LOOP_END instruction are local now.
	* gas/bfin/flow2.d: Likewise.
@
text
@d53 8
a60 2
static flagword bfin_flags = DEFAULT_FLAGS;
static const char *bfin_pic_flag = (const char *)0;
d314 1
d318 3
a320 1
  { "mfdpic",		no_argument,		NULL, OPTION_FDPIC	   },
d339 5
@


1.14
log
@Remove duplicate definitions of the md_atof() function
@
text
@d869 1
a869 1
      label_name = (char *) xmalloc ((c - c1) + strlen ("__END") + 1);
d871 1
d877 1
a877 1
      label_name = (char *) xmalloc ((c - c1) + strlen ("__BEGIN") + 1);
d879 1
d889 1
a889 2
    line_label->sy_value.X_add_number -= last_insn_size;

d1882 2
a1883 2
  lbeginsym = (char *) xmalloc (strlen (loopsym) + strlen ("__BEGIN") + 1);
  lendsym = (char *) xmalloc (strlen (loopsym) + strlen ("__END") + 1);
d1888 1
d1892 1
@


1.13
log
@PR gas/5121 gas/5122 gas/5123 gas/5124 gas/5125 gas/5126 gas/5129 gas/5131 gas/5132 gas/5137 gas/5143
* Makefile.am (CFILES): Add cgen.c
  (TARGET_CPU_CFILES): Add tc-iq2000.c, tc-maxq.c, tc-mt.c, tc-tic4x.c and xtensa-relax.c.
  (TARGET_CPU_HFILES): Add tc-iq2000.h, tc-maxq.h, tc-mt.h, tc-tic4x.h and xtensa-relax.h.
  (TARG_ENV_HFILES): Remove te-aux.h, te-delta.h, te-delt88.h, te-ic960.h, te-linux.h.
   Add te-aix5.h, te-armeabi.h, te-freebsd.h, te-gnu.h, te-interix.h, te-vxworks.h.
  (CONFIG_ATOF_CFILES): New variable.
  (POTFILES): Add CONFIG_ATOF_CFILES to dependencies.  Fix typo with dependency upon TARG_ENV_HFILES.
  (DEPTC): Do not put "#include opcodes/<foo>-desc.h" into cgen-desc.h when foo-desc.h does not exit.
   Run make dep-am.
* Makefile.in: Regenerate.
* doc/Makefile.in: Regenerate.
* po/POTFILES.in: Regenerate.
* po/es.po: Regenerate.
* po/fr.po: Regenerate.
* po/gas.pot: Regenerate.
* po/rw.po: Regenerate.
* po/tr.po: Regenerate.
* config/obj-elf.c (obj_elf_vtable_inherit): Allow for translation of error messages.
* config/obj-som.c: Likewise.
* config/tc-arc.c: Likewise.
* config/tc-arm.c: Likewise.
* config/tc-bfin.c: Likewise.
* config/tc-frv.c: Likewise.
@
text
@a692 8
/* Turn a string in input_line_pointer into a floating point
   constant of type type, and store the appropriate bytes in
   *litP.  The number of LITTLENUMS emitted is stored in *sizeP.
   An error message is returned, or NULL on OK.  */

/* Equal to MAX_PRECISION in atof-ieee.c.  */
#define MAX_LITTLENUMS 6

d694 3
a696 44
md_atof (type, litP, sizeP)
     char   type;
     char * litP;
     int *  sizeP;
{
  int              prec;
  LITTLENUM_TYPE   words [MAX_LITTLENUMS];
  LITTLENUM_TYPE   *wordP;
  char *           t;

  switch (type)
    {
    case 'f':
    case 'F':
      prec = 2;
      break;

    case 'd':
    case 'D':
      prec = 4;
      break;

   /* FIXME: Some targets allow other format chars for bigger sizes here.  */

    default:
      *sizeP = 0;
      return _("Bad call to md_atof()");
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;
  *sizeP = prec * sizeof (LITTLENUM_TYPE);

  *sizeP = prec * sizeof (LITTLENUM_TYPE);
  /* This loops outputs the LITTLENUMs in REVERSE order; in accord with
     the littleendianness of the processor.  */
  for (wordP = words + prec - 1; prec--;)
    {
      md_number_to_chars (litP, (valueT) (*wordP--), sizeof (LITTLENUM_TYPE));
      litP += sizeof (LITTLENUM_TYPE);
    }

  return 0;
@


1.12
log
@PR gas/5135
(Expr_Node_Gen_Reloc_R): Fix spelling typos in error messages.
@
text
@d249 1
a249 1
	    as_bad ("missing ')'");
d351 1
a351 1
    as_warn ("Could not set architecture and machine.");
d496 1
a496 1
      as_bad ("Parse failed.");
d571 1
a571 1
                      "pcrel too far BFD_RELOC_BFIN_10");
d587 1
a587 1
	as_bad_where (fixP->fx_file, fixP->fx_line, "pcrel too far BFD_RELOC_BFIN_12");
d607 1
a607 1
	as_bad_where (fixP->fx_file, fixP->fx_line, "pcrel too far BFD_RELOC_BFIN_24");
d622 1
a622 1
	as_bad_where (fixP->fx_file, fixP->fx_line, "pcrel too far BFD_RELOC_BFIN_5");
d634 1
a634 1
	as_bad_where (fixP->fx_file, fixP->fx_line, "pcrel too far BFD_RELOC_BFIN_11_PCREL");
d644 1
a644 1
	as_bad_where (fixP->fx_file, fixP->fx_line, "rel too far BFD_RELOC_8");
d651 1
a651 1
	as_bad_where (fixP->fx_file, fixP->fx_line, "rel too far BFD_RELOC_16");
@


1.11
log
@PR gas/5136
* config/tc-bfin.c (md_apply_fix): Fix error message.
@
text
@d1181 1
a1181 1
	  fprintf (stderr, "%s:%d:Unkonwn operator found for arithmetic" " relocation", __FILE__, __LINE__);
d1197 1
a1197 1
	  fprintf (stderr, "%s:%d:Unkonwn operator found for arithmetic" " relocation", __FILE__, __LINE__);
@


1.10
log
@Switch to GPLv3
@
text
@d651 1
a651 1
	as_bad_where (fixP->fx_file, fixP->fx_line, "rel too far BFD_RELOC_8");
@


1.9
log
@remove some duplicate #include's.
@
text
@d2 1
a2 1
   Copyright 2005, 2006
d9 1
a9 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.8
log
@	* config/tc-bfin.c (bfin_start_line_hook): Bump line counters
	if needed.
@
text
@d2 1
a2 1
   Copyright 2005
a23 1
#include "obj-elf.h"
a941 1
#include <stdio.h>
a942 3
#include <obstack.h>
#include <bfd.h>
#include "bfin-defs.h"
@


1.7
log
@	* config/bfin-defs.h (bfin_equals): Remove declaration.
	* config/bfin-parse.y (asm_1): Remove "expr ASSIGN expr".
	* config/tc-bfin.c (bfin_name_is_register): Remove.
	(bfin_equals): Remove.
	* config/tc-bfin.h (TC_EQUAL_IN_INSN): Redefine as 1.
	(bfin_name_is_register): Remove declaration.
@
text
@d837 1
d840 5
a844 1
    c++;
d910 6
@


1.6
log
@	* config/obj-coff.c, config/tc-arm.c, config/tc-bfin.c,
	config/tc-cris.c, config/tc-crx.c, config/tc-i386.c,
	config/tc-ia64.c, config/tc-maxq.c, config/tc-maxq.h,
	config/tc-mips.c, config/tc-msp430.c, config/tc-sh.c,
	config/tc-tic4x.c, config/tc-xtensa.c: Fix comment typos.
@
text
@a1971 36
bfin_name_is_register (char *name)
{
  int i;

  if (*name == '[' || *name == '(')
    return TRUE;

  if ((name[0] == 'W' || name[0] == 'w') && name[1] == '[')
    return TRUE;

  if ((name[0] == 'B' || name[0] == 'b') && name[1] == '[')
    return TRUE;

  for (i=0; bfin_reg_info[i].name != 0; i++)
   {
     if (!strcasecmp (bfin_reg_info[i].name, name))
       return TRUE;
   }
  return FALSE;
}

void
bfin_equals (Expr_Node *sym)
{
  char *c;

  c = input_line_pointer;
  while (*c != '=')
   c--;

  input_line_pointer = c;

  equals ((char *) sym->value.s_value, 1);
}

bfd_boolean
@


1.5
log
@	* config/bfin-defs.h (Expr_Node_Type enum): Add Expr_Node_GOT_Reloc.
	* config/bfin-lex.l: Recognize GOT17M4 and FUNCDESC_GOT17M4.
	* config/bfin-parse.y: Include "libbfd.h", "elf/common.h" and
	"elf/bfin.h".
	(GOT17M4, FUNCDESC_GOT17M4): New tokens of type <value>.
	(any_gotrel): New rule.
	(got): Use it, and create Expr_Node_GOT_Reloc nodes.
	* config/tc-bfin.c: Include "libbfd.h", "elf/common.h" and
	"elf/bfin.h".
	(DEFAULT_FLAGS, bfin_flags, bfin_pic_flag): New.
	(bfin_pic_ptr): New function.
	(md_pseudo_table): Add it for ".picptr".
	(OPTION_FDPIC): New macro.
	(md_longopts): Add -mfdpic.
	(md_parse_option): Handle it.
	(md_begin): Set BFD flags.
	(md_apply_fix3, bfin_fix_adjustable): Handle new relocs.
	(bfin_gen_ldstidxi): Adjust to match the trees that the parser gives
	us for GOT relocs.
	* Makefile.am (bfin-parse.o): Update dependencies.
	(DEPTC_bfin_elf): Likewise.
	* Makefile.in: Regenerate.
@
text
@d1057 1
a1057 1
	  /*  Some reloctions will need to allocate extra words.  */
@


1.4
log
@	* config/tc-bfin.c (Expr_Node_Gen_Reloc): If have symbol + constant,
	make a single reloc with an offset rather than a stack.
	* config/tc-bfin.h (MD_APPLY_SYM_VALUE): Define to 0.
@
text
@d31 3
d51 6
d214 61
d280 1
a291 11
static void
bfin_s_bss (int ignore ATTRIBUTE_UNUSED)
{
  register int temp;

  temp = get_absolute_expression ();
  subseg_set (bss_section, (subsegT) temp);
  demand_empty_rest_of_line ();
}


d308 6
a313 2
struct option md_longopts[] = {
  {NULL, no_argument, NULL, 0}
d315 1
d322 12
a333 1
  return 0;
d346 4
d559 2
d664 1
d811 4
a814 2
    case BFD_RELOC_BFIN_GOT :
    case BFD_RELOC_BFIN_PLTPC :
d1070 2
a1445 2
  int offset;
  int value = 0;
a1457 12
  switch (sz)
    {
    case 0:
      value = EXPR_VALUE (poffset) >> 2;
      break;
    case 1:
      value = EXPR_VALUE (poffset) >> 1;
      break;
    case 2:
      value = EXPR_VALUE (poffset);
      break;
    }
d1459 1
d1461 15
a1475 1
  ASSIGN (Z);
d1477 3
a1479 12
  offset = (value & 0xffff);
  ASSIGN (offset);
  /* TODO : test if you need to check this here.
     The reloc case should automatically generate instruction
     if constant.  */
  if(poffset->type != Expr_Node_Constant){
    /* A GOT relocation such as R0 = [P5 + symbol@@GOT].
       Distinguish between R0 = [P5 + symbol@@GOT] and
       P5 = [P5 + _current_shared_library_p5_offset_].  */
    if(!strcmp(poffset->value.s_value, "_current_shared_library_p5_offset_")){
      return  conscode (gencode (HI (c_code.opcode)),
			Expr_Node_Gen_Reloc(poffset, BFD_RELOC_16));
d1481 1
a1481 1
    else
d1483 19
a1501 2
      return  conscode (gencode (HI (c_code.opcode)),
			Expr_Node_Gen_Reloc(poffset, BFD_RELOC_BFIN_GOT));
a1502 4
  }
  else{
    return GEN_OPCODE32 ();
  }
@


1.4.2.1
log
@Merge changes between binutils-csl-2_17-branchpoint and
binutils-2_17, except for the addition of generated files to CVS.
@
text
@a30 3
#include "libbfd.h"
#include "elf/common.h"
#include "elf/bfin.h"
a47 6
/* Flags to set in the elf header */
#define DEFAULT_FLAGS 0

static flagword bfin_flags = DEFAULT_FLAGS;
static const char *bfin_pic_flag = (const char *)0;

a204 61
/* Blackfin specific function to handle FD-PIC pointer initializations.  */

static void
bfin_pic_ptr (int nbytes)
{
  expressionS exp;
  char *p;

  if (nbytes != 4)
    abort ();

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  if (is_it_end_of_statement ())
    {
      demand_empty_rest_of_line ();
      return;
    }

#ifdef md_cons_align
  md_cons_align (nbytes);
#endif

  do
    {
      bfd_reloc_code_real_type reloc_type = BFD_RELOC_BFIN_FUNCDESC;
      
      if (strncasecmp (input_line_pointer, "funcdesc(", 9) == 0)
	{
	  input_line_pointer += 9;
	  expression (&exp);
	  if (*input_line_pointer == ')')
	    input_line_pointer++;
	  else
	    as_bad ("missing ')'");
	}
      else
	error ("missing funcdesc in picptr");

      p = frag_more (4);
      memset (p, 0, 4);
      fix_new_exp (frag_now, p - frag_now->fr_literal, 4, &exp, 0,
		   reloc_type);
    }
  while (*input_line_pointer++ == ',');

  input_line_pointer--;			/* Put terminator back into stream. */
  demand_empty_rest_of_line ();
}

static void
bfin_s_bss (int ignore ATTRIBUTE_UNUSED)
{
  register int temp;

  temp = get_absolute_expression ();
  subseg_set (bss_section, (subsegT) temp);
  demand_empty_rest_of_line ();
}
a209 1
  {"picptr", bfin_pic_ptr, 4},
d221 11
d248 2
a249 6
#define OPTION_FDPIC		(OPTION_MD_BASE)

struct option md_longopts[] =
{
  { "mfdpic",		no_argument,		NULL, OPTION_FDPIC	   },
  { NULL,		no_argument,		NULL, 0                 },
a250 1

d257 1
a257 12
  switch (c)
    {
    default:
      return 0;

    case OPTION_FDPIC:
      bfin_flags |= EF_BFIN_FDPIC;
      bfin_pic_flag = "-mfdpic";
      break;
    }

  return 1;
a269 4
  /* Set the ELF flags if desired. */
  if (bfin_flags)
    bfd_set_private_flags (stdoutput, bfin_flags);

a478 2
    case BFD_RELOC_BFIN_GOT17M4:
    case BFD_RELOC_BFIN_FUNCDESC_GOT17M4:
a581 1
    case BFD_RELOC_BFIN_FUNCDESC:
d728 2
a729 4
    case BFD_RELOC_BFIN_GOT:
    case BFD_RELOC_BFIN_GOT17M4:
    case BFD_RELOC_BFIN_FUNCDESC_GOT17M4:
    case BFD_RELOC_BFIN_PLTPC:
a984 2
	case BFD_RELOC_BFIN_GOT17M4:
	case BFD_RELOC_BFIN_FUNCDESC_GOT17M4:
d1359 2
d1373 13
d1389 12
a1400 19
  if (poffset->type != Expr_Node_Constant)
    {
      /* a GOT relocation such as R0 = [P5 + symbol@@GOT] */
      /* distinguish between R0 = [P5 + symbol@@GOT] and
	 P5 = [P5 + _current_shared_library_p5_offset_]
      */
      if (poffset->type == Expr_Node_Reloc
	  && !strcmp (poffset->value.s_value,
		      "_current_shared_library_p5_offset_"))
	{
	  return  conscode (gencode (HI (c_code.opcode)),
			    Expr_Node_Gen_Reloc(poffset, BFD_RELOC_16));
	}
      else if (poffset->type != Expr_Node_GOT_Reloc)
	abort ();

      return conscode (gencode (HI (c_code.opcode)),
		       Expr_Node_Gen_Reloc(poffset->Left_Child,
					   poffset->value.i_value));
d1402 1
a1402 1
  else
d1404 2
a1405 19
      int value, offset;
      switch (sz)
	{				// load/store access size
	case 0:			// 32 bit
	  value = EXPR_VALUE (poffset) >> 2;
	  break;
	case 1:			// 16 bit
	  value = EXPR_VALUE (poffset) >> 1;
	  break;
	case 2:			// 8 bit
	  value = EXPR_VALUE (poffset);
	  break;
	default:
	  abort ();
	}

      offset = (value & 0xffff);
      ASSIGN (offset);
      return GEN_OPCODE32 ();
d1407 4
@


1.3
log
@bfd/
	* elf32-bfin.c (bfd_bfin_elf32_create_embedded_relocs): Fix signedness
	warning.
gas/
	* Makefile.am (bfin-parse.h): Renamed from bfin-parse.tab.h.
	(EXTRA_DIST): Add bfin-parse.h and bfin-lex.c.
	* Makefile.in: Regenerate.
	* config/bfin-lex.l: Include bfin-parse.h instead of bfin-parse.tab.h.
	* config/tc-bfin.c (md_chars_to_number): Change the type of first
	argument from unsigned char * to char * to remove signedness warnings.
@
text
@d1006 15
@


1.2
log
@	* config/tc-bfin.c (md_begin): Let the lex_type of '(' be
	LEX_BEGIN_NAME.
	(bfin_start_line_hook): Remove the workaround for LSETUP(.
	(bfin_name_is_register): Remove the workarounds for LSETUP(
	and SAA(.
	(bfin_start_label): Ditto.
@
text
@d39 1
a39 1
static int md_chars_to_number PARAMS ((unsigned char *, int));
d456 1
a456 3
md_chars_to_number (val, n)
     unsigned char *val;	/* Value in target byte order.  */
     int n;			/* Number of bytes in the input.  */
@


1.1
log
@	* Makefile.am: Bfin support.
	* Makefile.in: Regenerated.
	* aclocal.m4: Regenerated.
	* configure: Regenerated.
	* configure.in: Bfin support.
	* configure.tgt: Bfin support.
	* config/bfin-aux.h: New file.
	* config/bfin-defs.h: New file.
	* config/bfin-lex.l: New file.
	* config/bfin-parse.y: New file.
	* config/tc-bfin.c: New file.
	* config/tc-bfin.h: New file.
	* doc/Makefile.am: Recognize c-bfin.texi.
	* doc/Makefile.in: Regenerated.
	* doc/all.texi: Bfin support.
	* doc/as.texinfo: Likewise.
	* doc/c-bfin.texi: Document bfin-specific syntax and
	directives.
@
text
@d276 1
a276 1
  lex_type ['('] = 3;
a757 15
  /* Look for LSETUP(. */
  if (!strncasecmp (input_line_pointer, "lsetup(", 7))
    {
      /* Need to insert space between lsetup and paren.  */
      input_line_pointer --;
      input_line_pointer[0] = 'l';
      input_line_pointer[1] = 's';
      input_line_pointer[2] = 'e';
      input_line_pointer[3] = 't';
      input_line_pointer[4] = 'u';
      input_line_pointer[5] = 'p';
      input_line_pointer[6] = ' ';
      return;
    }

a1879 6
  if (!strncasecmp (name, "saa(", 4))
    return TRUE;

  if (!strncasecmp (name, "lsetup(", 7))
    return TRUE;

a1912 6
  if (!strncmp (ptr, "saa(", 4))
    return FALSE;

  if (!strncmp (ptr, "lsetup(", 7))
    return FALSE;

@

