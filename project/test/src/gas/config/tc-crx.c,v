head	1.27;
access;
symbols
	binutils-2_24-branch:1.27.0.4
	binutils-2_24-branchpoint:1.27
	binutils-2_21_1:1.25
	binutils-2_23_2:1.27
	binutils-2_23_1:1.27
	binutils-2_23:1.27
	binutils-2_23-branch:1.27.0.2
	binutils-2_23-branchpoint:1.27
	binutils-2_22_branch:1.25.0.6
	binutils-2_22:1.25
	binutils-2_22-branch:1.25.0.4
	binutils-2_22-branchpoint:1.25
	binutils-2_21:1.25
	binutils-2_21-branch:1.25.0.2
	binutils-2_21-branchpoint:1.25
	binutils-2_20_1:1.23
	binutils-2_20:1.23
	binutils-arc-20081103-branch:1.21.0.6
	binutils-arc-20081103-branchpoint:1.21
	binutils-2_20-branch:1.23.0.2
	binutils-2_20-branchpoint:1.23
	dje-cgen-play1-branch:1.22.0.2
	dje-cgen-play1-branchpoint:1.22
	arc-20081103-branch:1.21.0.4
	arc-20081103-branchpoint:1.21
	binutils-2_19_1:1.21
	binutils-2_19:1.21
	binutils-2_19-branch:1.21.0.2
	binutils-2_19-branchpoint:1.21
	binutils-2_18:1.19
	binutils-2_18-branch:1.19.0.2
	binutils-2_18-branchpoint:1.19
	binutils-csl-coldfire-4_1-32:1.17
	binutils-csl-sourcerygxx-4_1-32:1.17
	binutils-csl-innovasic-fido-3_4_4-33:1.17
	binutils-csl-sourcerygxx-3_4_4-32:1.13
	binutils-csl-coldfire-4_1-30:1.17
	binutils-csl-sourcerygxx-4_1-30:1.17
	binutils-csl-coldfire-4_1-28:1.17
	binutils-csl-sourcerygxx-4_1-29:1.17
	binutils-csl-sourcerygxx-4_1-28:1.17
	binutils-csl-arm-2006q3-27:1.17
	binutils-csl-sourcerygxx-4_1-27:1.17
	binutils-csl-arm-2006q3-26:1.17
	binutils-csl-sourcerygxx-4_1-26:1.17
	binutils-csl-sourcerygxx-4_1-25:1.17
	binutils-csl-sourcerygxx-4_1-24:1.17
	binutils-csl-sourcerygxx-4_1-23:1.17
	binutils-csl-sourcerygxx-4_1-21:1.17
	binutils-csl-arm-2006q3-21:1.17
	binutils-csl-sourcerygxx-4_1-22:1.17
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.17
	binutils-csl-sourcerygxx-4_1-20:1.17
	binutils-csl-arm-2006q3-19:1.17
	binutils-csl-sourcerygxx-4_1-19:1.17
	binutils-csl-sourcerygxx-4_1-18:1.17
	binutils-csl-renesas-4_1-9:1.17
	binutils-csl-sourcerygxx-3_4_4-25:1.13
	binutils-csl-renesas-4_1-8:1.17
	binutils-csl-renesas-4_1-7:1.17
	binutils-csl-renesas-4_1-6:1.17
	binutils-csl-sourcerygxx-4_1-17:1.17
	binutils-csl-sourcerygxx-4_1-14:1.17
	binutils-csl-sourcerygxx-4_1-15:1.17
	binutils-csl-sourcerygxx-4_1-13:1.17
	binutils-2_17:1.17
	binutils-csl-sourcerygxx-4_1-12:1.17
	binutils-csl-sourcerygxx-3_4_4-21:1.17
	binutils-csl-wrs-linux-3_4_4-24:1.13
	binutils-csl-wrs-linux-3_4_4-23:1.13
	binutils-csl-sourcerygxx-4_1-9:1.17
	binutils-csl-sourcerygxx-4_1-8:1.17
	binutils-csl-sourcerygxx-4_1-7:1.17
	binutils-csl-arm-2006q1-6:1.17
	binutils-csl-sourcerygxx-4_1-6:1.17
	binutils-csl-wrs-linux-3_4_4-22:1.13
	binutils-csl-coldfire-4_1-11:1.17
	binutils-csl-sourcerygxx-3_4_4-19:1.17
	binutils-csl-coldfire-4_1-10:1.17
	binutils-csl-sourcerygxx-4_1-5:1.17
	binutils-csl-sourcerygxx-4_1-4:1.17
	binutils-csl-wrs-linux-3_4_4-21:1.13
	binutils-csl-morpho-4_1-4:1.17
	binutils-csl-sourcerygxx-3_4_4-17:1.17
	binutils-csl-wrs-linux-3_4_4-20:1.13
	binutils-2_17-branch:1.17.0.4
	binutils-2_17-branchpoint:1.17
	binutils-csl-2_17-branch:1.17.0.2
	binutils-csl-2_17-branchpoint:1.17
	binutils-csl-gxxpro-3_4-branch:1.13.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.13
	binutils-2_16_1:1.13
	binutils-csl-arm-2005q1b:1.13
	binutils-2_16:1.13
	binutils-csl-arm-2005q1a:1.13
	binutils-csl-arm-2005q1-branch:1.13.0.4
	binutils-csl-arm-2005q1-branchpoint:1.13
	binutils-2_16-branch:1.13.0.2
	binutils-2_16-branchpoint:1.13
	csl-arm-2004-q3d:1.9
	csl-arm-2004-q3:1.4
	binutils_latest_snapshot:1.27;
locks; strict;
comment	@ * @;


1.27
date	2012.02.27.12.36.21;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2012.02.27.06.37.40;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2010.06.28.14.06.57;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2009.12.11.13.42.10;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2009.09.02.07.24.20;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2009.06.22.17.56.01;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2008.08.12.23.39.30;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2007.10.17.16.45.55;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2007.07.03.11.01.04;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2006.04.23.22.12.43;	author kazu;	state Exp;
branches;
next	1.17;

1.17
date	2006.02.10.12.21.43;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2005.07.14.15.34.16;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2005.06.07.17.54.16;	author zack;	state Exp;
branches;
next	1.14;

1.14
date	2005.05.05.09.12.54;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2004.12.23.13.49.14;	author tomerl;	state Exp;
branches;
next	1.12;

1.12
date	2004.11.29.16.23.10;	author tomerl;	state Exp;
branches;
next	1.11;

1.11
date	2004.11.08.13.50.47;	author tomerl;	state Exp;
branches;
next	1.10;

1.10
date	2004.11.05.11.02.04;	author tomerl;	state Exp;
branches;
next	1.9;

1.9
date	2004.10.28.10.13.14;	author tomerl;	state Exp;
branches;
next	1.8;

1.8
date	2004.10.27.10.28.22;	author tomerl;	state Exp;
branches;
next	1.7;

1.7
date	2004.10.25.09.30.55;	author tomerl;	state Exp;
branches;
next	1.6;

1.6
date	2004.10.07.14.48.08;	author tomerl;	state Exp;
branches;
next	1.5;

1.5
date	2004.10.07.14.18.13;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2004.09.20.14.25.36;	author tomerl;	state Exp;
branches;
next	1.3;

1.3
date	2004.09.03.14.31.40;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	2004.07.27.11.37.08;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	2004.07.07.17.28.50;	author nickc;	state Exp;
branches;
next	;


desc
@@


1.27
log
@	* config/tc-crx.c (check_range): Correct uint32_t misconceptions.
@
text
@/* tc-crx.c -- Assembler code for the CRX CPU core.
   Copyright 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2012
   Free Software Foundation, Inc.

   Contributed by Tomer Levi, NSC, Israel.
   Originally written for GAS 2.12 by Tomer Levi, NSC, Israel.
   Updates, BFDizing, GNUifying and ELF support by Tomer Levi.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the
   Free Software Foundation, 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "as.h"
#include "bfd_stdint.h"
#include "safe-ctype.h"
#include "dwarf2dbg.h"
#include "opcode/crx.h"
#include "elf/crx.h"

/* Word is considered here as a 16-bit unsigned short int.  */
#define WORD_SHIFT  16

/* Register is 4-bit size.  */
#define REG_SIZE   4

/* Maximum size of a single instruction (in words).  */
#define INSN_MAX_SIZE   3

/* Maximum bits which may be set in a `mask16' operand.  */
#define MAX_REGS_IN_MASK16  8

/* Utility macros for string comparison.  */
#define streq(a, b)           (strcmp (a, b) == 0)
#define strneq(a, b, c)       (strncmp (a, b, c) == 0)

/* Assign a number NUM, shifted by SHIFT bytes, into a location
   pointed by index BYTE of array 'output_opcode'.  */
#define CRX_PRINT(BYTE, NUM, SHIFT)   output_opcode[BYTE] |= (NUM << SHIFT)

/* Operand errors.  */
typedef enum
  {
    OP_LEGAL = 0,	/* Legal operand.  */
    OP_OUT_OF_RANGE,	/* Operand not within permitted range.  */
    OP_NOT_EVEN,	/* Operand is Odd number, should be even.  */
    OP_ILLEGAL_DISPU4,	/* Operand is not within DISPU4 range.  */
    OP_ILLEGAL_CST4,	/* Operand is not within CST4 range.  */
    OP_NOT_UPPER_64KB	/* Operand is not within the upper 64KB 
			   (0xFFFF0000-0xFFFFFFFF).  */
  }
op_err;

/* Opcode mnemonics hash table.  */
static struct hash_control *crx_inst_hash;
/* CRX registers hash table.  */
static struct hash_control *reg_hash;
/* CRX coprocessor registers hash table.  */
static struct hash_control *copreg_hash;
/* Current instruction we're assembling.  */
const inst *instruction;

/* Global variables.  */

/* Array to hold an instruction encoding.  */
long output_opcode[2];

/* Nonzero means a relocatable symbol.  */
int relocatable;

/* A copy of the original instruction (used in error messages).  */
char ins_parse[MAX_INST_LEN];

/* The current processed argument number.  */
int cur_arg_num;

/* Generic assembler global variables which must be defined by all targets.  */

/* Characters which always start a comment.  */
const char comment_chars[] = "#";

/* Characters which start a comment at the beginning of a line.  */
const char line_comment_chars[] = "#";

/* This array holds machine specific line separator characters.  */
const char line_separator_chars[] = ";";

/* Chars that can be used to separate mant from exp in floating point nums.  */
const char EXP_CHARS[] = "eE";

/* Chars that mean this number is a floating point constant as in 0f12.456  */
const char FLT_CHARS[] = "f'";

/* Target-specific multicharacter options, not const-declared at usage.  */
const char *md_shortopts = "";
struct option md_longopts[] =
{
  {NULL, no_argument, NULL, 0}
};
size_t md_longopts_size = sizeof (md_longopts);

/* This table describes all the machine specific pseudo-ops
   the assembler has to support.  The fields are:
   *** Pseudo-op name without dot.
   *** Function to call to execute this pseudo-op.
   *** Integer arg to pass to the function.  */

const pseudo_typeS md_pseudo_table[] =
{
  /* In CRX machine, align is in bytes (not a ptwo boundary).  */
  {"align", s_align_bytes, 0},
  {0, 0, 0}
};

/* CRX relaxation table.  */
const relax_typeS md_relax_table[] =
{
  /* bCC  */
  {0xfa, -0x100, 2, 1},			/*  8 */
  {0xfffe, -0x10000, 4, 2},		/* 16 */
  {0xfffffffe, -0xfffffffe, 6, 0},	/* 32 */

  /* bal  */
  {0xfffe, -0x10000, 4, 4},		/* 16 */
  {0xfffffffe, -0xfffffffe, 6, 0},	/* 32 */

  /* cmpbr/bcop  */
  {0xfe, -0x100, 4, 6},			/*  8 */
  {0xfffffe, -0x1000000, 6, 0}		/* 24 */
};

static void    reset_vars	        (char *);
static reg     get_register	        (char *);
static copreg  get_copregister	        (char *);
static argtype get_optype	        (operand_type);
static int     get_opbits	        (operand_type);
static int     get_opflags	        (operand_type);
static int     get_number_of_operands   (void);
static void    parse_operand	        (char *, ins *);
static int     gettrap		        (const char *);
static void    handle_LoadStor	        (const char *);
static int     get_cinv_parameters      (const char *);
static long    getconstant		(long, int);
static op_err  check_range		(long *, int, unsigned int, int);
static int     getreg_image	        (reg);
static void    parse_operands	        (ins *, char *);
static void    parse_insn	        (ins *, char *);
static void    print_operand	        (int, int, argument *);
static void    print_constant	        (int, int, argument *);
static int     exponent2scale	        (int);
static void    mask_reg		        (int, unsigned short *);
static void    process_label_constant   (char *, ins *);
static void    set_operand	        (char *, ins *);
static char *  preprocess_reglist       (char *, int *);
static int     assemble_insn	        (char *, ins *);
static void    print_insn	        (ins *);
static void    warn_if_needed		(ins *);
static int     adjust_if_needed		(ins *);

/* Return the bit size for a given operand.  */

static int
get_opbits (operand_type op)
{
  if (op < MAX_OPRD)
    return crx_optab[op].bit_size;
  else
    return 0;
}

/* Return the argument type of a given operand.  */

static argtype
get_optype (operand_type op)
{
  if (op < MAX_OPRD)
    return crx_optab[op].arg_type;
  else
    return nullargs;
}

/* Return the flags of a given operand.  */

static int
get_opflags (operand_type op)
{
  if (op < MAX_OPRD)
    return crx_optab[op].flags;
  else
    return 0;
}

/* Get the core processor register 'reg_name'.  */

static reg
get_register (char *reg_name)
{
  const reg_entry *rreg;

  rreg = (const reg_entry *) hash_find (reg_hash, reg_name);

  if (rreg != NULL)
    return rreg->value.reg_val;
  else
    return nullregister;
}

/* Get the coprocessor register 'copreg_name'.  */

static copreg
get_copregister (char *copreg_name)
{
  const reg_entry *coreg;

  coreg = (const reg_entry *) hash_find (copreg_hash, copreg_name);

  if (coreg != NULL)
    return coreg->value.copreg_val;
  else
    return nullcopregister;
}

/* Round up a section size to the appropriate boundary.  */

valueT
md_section_align (segT seg, valueT val)
{
  /* Round .text section to a multiple of 2.  */
  if (seg == text_section)
    return (val + 1) & ~1;
  return val;
}

/* Parse an operand that is machine-specific (remove '*').  */

void
md_operand (expressionS * exp)
{
  char c = *input_line_pointer;

  switch (c)
    {
    case '*':
      input_line_pointer++;
      expression (exp);
      break;
    default:
      break;
    }
}

/* Reset global variables before parsing a new instruction.  */

static void
reset_vars (char *op)
{
  cur_arg_num = relocatable = 0;
  memset (& output_opcode, '\0', sizeof (output_opcode));

  /* Save a copy of the original OP (used in error messages).  */
  strncpy (ins_parse, op, sizeof ins_parse - 1);
  ins_parse [sizeof ins_parse - 1] = 0;
}

/* This macro decides whether a particular reloc is an entry in a
   switch table.  It is used when relaxing, because the linker needs
   to know about all such entries so that it can adjust them if
   necessary.  */

#define SWITCH_TABLE(fix)				  \
  (   (fix)->fx_addsy != NULL				  \
   && (fix)->fx_subsy != NULL				  \
   && S_GET_SEGMENT ((fix)->fx_addsy) ==		  \
      S_GET_SEGMENT ((fix)->fx_subsy)			  \
   && S_GET_SEGMENT (fix->fx_addsy) != undefined_section  \
   && (   (fix)->fx_r_type == BFD_RELOC_CRX_NUM8	  \
       || (fix)->fx_r_type == BFD_RELOC_CRX_NUM16	  \
       || (fix)->fx_r_type == BFD_RELOC_CRX_NUM32))

/* See whether we need to force a relocation into the output file.
   This is used to force out switch and PC relative relocations when
   relaxing.  */

int
crx_force_relocation (fixS *fix)
{
  if (generic_force_reloc (fix) || SWITCH_TABLE (fix))
    return 1;

  return 0;
}

/* Generate a relocation entry for a fixup.  */

arelent *
tc_gen_reloc (asection *section ATTRIBUTE_UNUSED, fixS * fixP)
{
  arelent * reloc;

  reloc = xmalloc (sizeof (arelent));
  reloc->sym_ptr_ptr  = xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixP->fx_addsy);
  reloc->address = fixP->fx_frag->fr_address + fixP->fx_where;
  reloc->addend = fixP->fx_offset;

  if (fixP->fx_subsy != NULL)
    {
      if (SWITCH_TABLE (fixP))
	{
	  /* Keep the current difference in the addend.  */
	  reloc->addend = (S_GET_VALUE (fixP->fx_addsy)
			   - S_GET_VALUE (fixP->fx_subsy) + fixP->fx_offset);

	  switch (fixP->fx_r_type)
	    {
	    case BFD_RELOC_CRX_NUM8:
	      fixP->fx_r_type = BFD_RELOC_CRX_SWITCH8;
	      break;
	    case BFD_RELOC_CRX_NUM16:
	      fixP->fx_r_type = BFD_RELOC_CRX_SWITCH16;
	      break;
	    case BFD_RELOC_CRX_NUM32:
	      fixP->fx_r_type = BFD_RELOC_CRX_SWITCH32;
	      break;
	    default:
	      abort ();
	      break;
	    }
	}
      else
	{
	  /* We only resolve difference expressions in the same section.  */
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("can't resolve `%s' {%s section} - `%s' {%s section}"),
			fixP->fx_addsy ? S_GET_NAME (fixP->fx_addsy) : "0",
			segment_name (fixP->fx_addsy
				      ? S_GET_SEGMENT (fixP->fx_addsy)
				      : absolute_section),
			S_GET_NAME (fixP->fx_subsy),
			segment_name (S_GET_SEGMENT (fixP->fx_addsy)));
	}
    }

  gas_assert ((int) fixP->fx_r_type > 0);
  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixP->fx_r_type);

  if (reloc->howto == (reloc_howto_type *) NULL)
    {
      as_bad_where (fixP->fx_file, fixP->fx_line,
		    _("internal error: reloc %d (`%s') not supported by object file format"),
		    fixP->fx_r_type,
		    bfd_get_reloc_code_name (fixP->fx_r_type));
      return NULL;
    }
  gas_assert (!fixP->fx_pcrel == !reloc->howto->pc_relative);

  return reloc;
}

/* Prepare machine-dependent frags for relaxation.  */

int
md_estimate_size_before_relax (fragS *fragp, asection *seg)
{
  /* If symbol is undefined or located in a different section,
     select the largest supported relocation.  */
  relax_substateT subtype;
  relax_substateT rlx_state[] = {0, 2,
				 3, 4,
				 5, 6};

  for (subtype = 0; subtype < ARRAY_SIZE (rlx_state); subtype += 2)
    {
      if (fragp->fr_subtype == rlx_state[subtype]
	  && (!S_IS_DEFINED (fragp->fr_symbol)
	      || seg != S_GET_SEGMENT (fragp->fr_symbol)))
	{
	  fragp->fr_subtype = rlx_state[subtype + 1];
	  break;
	}
    }

  if (fragp->fr_subtype >= ARRAY_SIZE (md_relax_table))
    abort ();

  return md_relax_table[fragp->fr_subtype].rlx_length;
}

void
md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, fragS *fragP)
{
  /* 'opcode' points to the start of the instruction, whether
     we need to change the instruction's fixed encoding.  */
  char *opcode = fragP->fr_literal + fragP->fr_fix;
  bfd_reloc_code_real_type reloc;

  subseg_change (sec, 0);

  switch (fragP->fr_subtype)
    {
    case 0:
      reloc = BFD_RELOC_CRX_REL8;
      break;
    case 1:
      *opcode = 0x7e;
      reloc = BFD_RELOC_CRX_REL16;
      break;
    case 2:
      *opcode = 0x7f;
      reloc = BFD_RELOC_CRX_REL32;
      break;
    case 3:
      reloc = BFD_RELOC_CRX_REL16;
      break;
    case 4:
      *++opcode = 0x31;
      reloc = BFD_RELOC_CRX_REL32;
      break;
    case 5:
      reloc = BFD_RELOC_CRX_REL8_CMP;
      break;
    case 6:
      *++opcode = 0x31;
      reloc = BFD_RELOC_CRX_REL24;
      break;
    default:
      abort ();
      break;
    }

    fix_new (fragP, fragP->fr_fix,
	     bfd_get_reloc_size (bfd_reloc_type_lookup (stdoutput, reloc)),
	     fragP->fr_symbol, fragP->fr_offset, 1, reloc);
    fragP->fr_var = 0;
    fragP->fr_fix += md_relax_table[fragP->fr_subtype].rlx_length;
}

/* Process machine-dependent command line options.  Called once for
   each option on the command line that the machine-independent part of
   GAS does not understand.  */

int
md_parse_option (int c ATTRIBUTE_UNUSED, char *arg ATTRIBUTE_UNUSED)
{
  return 0;
}

/* Machine-dependent usage-output.  */

void
md_show_usage (FILE *stream ATTRIBUTE_UNUSED)
{
  return;
}

char *
md_atof (int type, char *litP, int *sizeP)
{
  return ieee_md_atof (type, litP, sizeP, target_big_endian);
}

/* Apply a fixS (fixup of an instruction or data that we didn't have
   enough info to complete immediately) to the data in a frag.
   Since linkrelax is nonzero and TC_LINKRELAX_FIXUP is defined to disable
   relaxation of debug sections, this function is called only when
   fixuping relocations of debug sections.  */

void
md_apply_fix (fixS *fixP, valueT *valP, segT seg)
{
  valueT val = * valP;
  char *buf = fixP->fx_frag->fr_literal + fixP->fx_where;
  fixP->fx_offset = 0;

  switch (fixP->fx_r_type)
    {
    case BFD_RELOC_CRX_NUM8:
      bfd_put_8 (stdoutput, (unsigned char) val, buf);
      break;
    case BFD_RELOC_CRX_NUM16:
      bfd_put_16 (stdoutput, val, buf);
      break;
    case BFD_RELOC_CRX_NUM32:
      bfd_put_32 (stdoutput, val, buf);
      break;
    default:
      /* We shouldn't ever get here because linkrelax is nonzero.  */
      abort ();
      break;
    }

  fixP->fx_done = 0;

  if (fixP->fx_addsy == NULL
      && fixP->fx_pcrel == 0)
    fixP->fx_done = 1;

  if (fixP->fx_pcrel == 1
      && fixP->fx_addsy != NULL
      && S_GET_SEGMENT (fixP->fx_addsy) == seg)
    fixP->fx_done = 1;
}

/* The location from which a PC relative jump should be calculated,
   given a PC relative reloc.  */

long
md_pcrel_from (fixS *fixp)
{
  return fixp->fx_frag->fr_address + fixp->fx_where;
}

/* This function is called once, at assembler startup time.  This should
   set up all the tables, etc that the MD part of the assembler needs.  */

void
md_begin (void)
{
  const char *hashret = NULL;
  int i = 0;

  /* Set up a hash table for the instructions.  */
  if ((crx_inst_hash = hash_new ()) == NULL)
    as_fatal (_("Virtual memory exhausted"));
  
  while (crx_instruction[i].mnemonic != NULL)
    {
      const char *mnemonic = crx_instruction[i].mnemonic;

      hashret = hash_insert (crx_inst_hash, mnemonic,
			     (void *) &crx_instruction[i]);

      if (hashret != NULL && *hashret != '\0')
	as_fatal (_("Can't hash `%s': %s\n"), crx_instruction[i].mnemonic,
		  *hashret == 0 ? _("(unknown reason)") : hashret);

      /* Insert unique names into hash table.  The CRX instruction set
	 has many identical opcode names that have different opcodes based
	 on the operands.  This hash table then provides a quick index to
	 the first opcode with a particular name in the opcode table.  */
      do
	{
	  ++i;
	}
      while (crx_instruction[i].mnemonic != NULL
	     && streq (crx_instruction[i].mnemonic, mnemonic));
    }

  /* Initialize reg_hash hash table.  */
  if ((reg_hash = hash_new ()) == NULL)
    as_fatal (_("Virtual memory exhausted"));

  {
    const reg_entry *regtab;

    for (regtab = crx_regtab;
	 regtab < (crx_regtab + NUMREGS); regtab++)
      {
	hashret = hash_insert (reg_hash, regtab->name, (void *) regtab);
	if (hashret)
	  as_fatal (_("Internal Error:  Can't hash %s: %s"),
		    regtab->name,
		    hashret);
      }
  }

  /* Initialize copreg_hash hash table.  */
  if ((copreg_hash = hash_new ()) == NULL)
    as_fatal (_("Virtual memory exhausted"));

  {
    const reg_entry *copregtab;

    for (copregtab = crx_copregtab; copregtab < (crx_copregtab + NUMCOPREGS);
	 copregtab++)
      {
	hashret = hash_insert (copreg_hash, copregtab->name,
			       (void *) copregtab);
	if (hashret)
	  as_fatal (_("Internal Error:  Can't hash %s: %s"),
		    copregtab->name,
		    hashret);
      }
  }
  /*  Set linkrelax here to avoid fixups in most sections.  */
  linkrelax = 1;
}

/* Process constants (immediate/absolute) 
   and labels (jump targets/Memory locations).  */

static void
process_label_constant (char *str, ins * crx_ins)
{
  char *saved_input_line_pointer;
  argument *cur_arg = &crx_ins->arg[cur_arg_num];  /* Current argument.  */

  saved_input_line_pointer = input_line_pointer;
  input_line_pointer = str;

  expression (&crx_ins->exp);
  
  switch (crx_ins->exp.X_op)
    {
    case O_big:
    case O_absent:
      /* Missing or bad expr becomes absolute 0.  */
      as_bad (_("missing or invalid displacement expression `%s' taken as 0"),
	      str);
      crx_ins->exp.X_op = O_constant;
      crx_ins->exp.X_add_number = 0;
      crx_ins->exp.X_add_symbol = (symbolS *) 0;
      crx_ins->exp.X_op_symbol = (symbolS *) 0;
      /* Fall through.  */

    case O_constant:
      cur_arg->X_op = O_constant;
      cur_arg->constant = crx_ins->exp.X_add_number;
      break;

    case O_symbol:
    case O_subtract:
    case O_add:
      cur_arg->X_op = O_symbol;
      crx_ins->rtype = BFD_RELOC_NONE;
      relocatable = 1;

      switch (cur_arg->type)
	{
	case arg_cr:
          if (IS_INSN_TYPE (LD_STOR_INS_INC))
	    crx_ins->rtype = BFD_RELOC_CRX_REGREL12;
          else if (IS_INSN_TYPE (CSTBIT_INS)
		   || IS_INSN_TYPE (STOR_IMM_INS))
	    crx_ins->rtype = BFD_RELOC_CRX_REGREL28;
          else
	    crx_ins->rtype = BFD_RELOC_CRX_REGREL32;
	  break;

	case arg_idxr:
	    crx_ins->rtype = BFD_RELOC_CRX_REGREL22;
	  break;
	
	case arg_c:
          if (IS_INSN_MNEMONIC ("bal") || IS_INSN_TYPE (DCR_BRANCH_INS))
	    crx_ins->rtype = BFD_RELOC_CRX_REL16;
	  else if (IS_INSN_TYPE (BRANCH_INS))
	    crx_ins->rtype = BFD_RELOC_CRX_REL8;
          else if (IS_INSN_TYPE (LD_STOR_INS) || IS_INSN_TYPE (STOR_IMM_INS)
		   || IS_INSN_TYPE (CSTBIT_INS))
	    crx_ins->rtype = BFD_RELOC_CRX_ABS32;
	  else if (IS_INSN_TYPE (BRANCH_NEQ_INS))
	    crx_ins->rtype = BFD_RELOC_CRX_REL4;
          else if (IS_INSN_TYPE (CMPBR_INS) || IS_INSN_TYPE (COP_BRANCH_INS))
	    crx_ins->rtype = BFD_RELOC_CRX_REL8_CMP;
	  break;
	
	case arg_ic:
          if (IS_INSN_TYPE (ARITH_INS))
	    crx_ins->rtype = BFD_RELOC_CRX_IMM32;
	  else if (IS_INSN_TYPE (ARITH_BYTE_INS))
	    crx_ins->rtype = BFD_RELOC_CRX_IMM16;
	  break;
	default:
	  break;
      }
      break;

    default:
      cur_arg->X_op = crx_ins->exp.X_op;
      break;
    }

  input_line_pointer = saved_input_line_pointer;
  return;
}

/* Get the values of the scale to be encoded -
   used for the scaled index mode of addressing.  */

static int
exponent2scale (int val)
{
  int exponent;

  /* If 'val' is 0, the following 'for' will be an endless loop.  */
  if (val == 0)
    return 0;

  for (exponent = 0; (val != 1); val >>= 1, exponent++)
    ;

  return exponent;
}

/* Parsing different types of operands
   -> constants		    Immediate/Absolute/Relative numbers
   -> Labels		    Relocatable symbols
   -> (rbase)		    Register base
   -> disp(rbase)	    Register relative
   -> disp(rbase)+	    Post-increment mode
   -> disp(rbase,ridx,scl)  Register index mode  */

static void
set_operand (char *operand, ins * crx_ins)
{
  char *operandS; /* Pointer to start of sub-opearand.  */
  char *operandE; /* Pointer to end of sub-opearand.  */
  expressionS scale;
  int scale_val;
  char *input_save, c;
  argument *cur_arg = &crx_ins->arg[cur_arg_num]; /* Current argument.  */

  /* Initialize pointers.  */
  operandS = operandE = operand;

  switch (cur_arg->type)
    {
    case arg_sc:    /* Case *+0x18.  */
    case arg_ic:    /* Case $0x18.  */
      operandS++;
    case arg_c:	    /* Case 0x18.  */
      /* Set constant.  */
      process_label_constant (operandS, crx_ins);
      
      if (cur_arg->type != arg_ic)
	cur_arg->type = arg_c;
      break;

    case arg_icr:   /* Case $0x18(r1).  */
      operandS++;
    case arg_cr:    /* Case 0x18(r1).   */
      /* Set displacement constant.  */
      while (*operandE != '(')
	operandE++;
      *operandE = '\0';
      process_label_constant (operandS, crx_ins);
      operandS = operandE;    
    case arg_rbase: /* Case (r1).  */
      operandS++;
      /* Set register base.  */
      while (*operandE != ')')
	operandE++;
      *operandE = '\0';
      if ((cur_arg->r = get_register (operandS)) == nullregister)
	as_bad (_("Illegal register `%s' in Instruction `%s'"),
		operandS, ins_parse);

      if (cur_arg->type != arg_rbase)
	cur_arg->type = arg_cr;
      break;

    case arg_idxr:
      /* Set displacement constant.  */
      while (*operandE != '(')
	operandE++;
      *operandE = '\0';
      process_label_constant (operandS, crx_ins);
      operandS = ++operandE;
      
      /* Set register base.  */
      while ((*operandE != ',') && (! ISSPACE (*operandE)))
	operandE++;
      *operandE++ = '\0';
      if ((cur_arg->r = get_register (operandS)) == nullregister)
	as_bad (_("Illegal register `%s' in Instruction `%s'"),
		operandS, ins_parse);

      /* Skip leading white space.  */
      while (ISSPACE (*operandE))
	operandE++;
      operandS = operandE;

      /* Set register index.  */
      while ((*operandE != ')') && (*operandE != ','))
	operandE++;
      c = *operandE;
      *operandE++ = '\0';

      if ((cur_arg->i_r = get_register (operandS)) == nullregister)
	as_bad (_("Illegal register `%s' in Instruction `%s'"),
		operandS, ins_parse);

      /* Skip leading white space.  */
      while (ISSPACE (*operandE))
	operandE++;
      operandS = operandE;

      /* Set the scale.  */
      if (c == ')')
	cur_arg->scale = 0;
      else
        {
	  while (*operandE != ')')
	    operandE++;
	  *operandE = '\0';

	  /* Preprocess the scale string.  */
	  input_save = input_line_pointer;
	  input_line_pointer = operandS;
	  expression (&scale);
	  input_line_pointer = input_save;

	  scale_val = scale.X_add_number;

	  /* Check if the scale value is legal.  */
          if (scale_val != 1 && scale_val != 2
              && scale_val != 4 && scale_val != 8)
	    as_bad (_("Illegal Scale - `%d'"), scale_val);

	  cur_arg->scale = exponent2scale (scale_val);
        }
      break;

    default:
      break;
    }
}

/* Parse a single operand.
   operand - Current operand to parse.
   crx_ins - Current assembled instruction.  */

static void
parse_operand (char *operand, ins * crx_ins)
{
  int ret_val;
  argument *cur_arg = &crx_ins->arg[cur_arg_num]; /* Current argument.  */

  /* Initialize the type to NULL before parsing.  */
  cur_arg->type = nullargs;

  /* Check whether this is a general processor register.  */
  if ((ret_val = get_register (operand)) != nullregister)
    {
      cur_arg->type = arg_r;
      cur_arg->r = ret_val;
      cur_arg->X_op = O_register;
      return;
    }

  /* Check whether this is a core [special] coprocessor register.  */
  if ((ret_val = get_copregister (operand)) != nullcopregister)
    {
      cur_arg->type = arg_copr;
      if (ret_val >= cs0)
	cur_arg->type = arg_copsr;
      cur_arg->cr = ret_val;
      cur_arg->X_op = O_register;
      return;
    }

  /* Deal with special characters.  */
  switch (operand[0])
    {
    case '$':
      if (strchr (operand, '(') != NULL)
	cur_arg->type = arg_icr;
      else
        cur_arg->type = arg_ic;
      goto set_params;
      break;

    case '*':
      cur_arg->type = arg_sc;
      goto set_params;
      break;

    case '(':
      cur_arg->type = arg_rbase;
      goto set_params;
      break;

    default:
	break;
    }
      
  if (strchr (operand, '(') != NULL)
    {
      if (strchr (operand, ',') != NULL
          && (strchr (operand, ',') > strchr (operand, '(')))
	    cur_arg->type = arg_idxr;
      else
	cur_arg->type = arg_cr;
    }
  else
    cur_arg->type = arg_c;
  goto set_params;

/* Parse an operand according to its type.  */
set_params:
  cur_arg->constant = 0;
  set_operand (operand, crx_ins);
}

/* Parse the various operands. Each operand is then analyzed to fillup 
   the fields in the crx_ins data structure.  */

static void
parse_operands (ins * crx_ins, char *operands)
{
  char *operandS;	       /* Operands string.  */
  char *operandH, *operandT;   /* Single operand head/tail pointers.  */
  int allocated = 0;	       /* Indicates a new operands string was allocated.  */
  char *operand[MAX_OPERANDS]; /* Separating the operands.  */
  int op_num = 0;	       /* Current operand number we are parsing.  */
  int bracket_flag = 0;	       /* Indicates a bracket '(' was found.  */
  int sq_bracket_flag = 0;     /* Indicates a square bracket '[' was found.  */

  /* Preprocess the list of registers, if necessary.  */
  operandS = operandH = operandT = (INST_HAS_REG_LIST) ?
    preprocess_reglist (operands, &allocated) : operands;

  while (*operandT != '\0')
    {
      if (*operandT == ',' && bracket_flag != 1 && sq_bracket_flag != 1)
        {
	  *operandT++ = '\0';
	  operand[op_num++] = strdup (operandH);
          operandH = operandT;
          continue;
        }

      if (*operandT == ' ')
	as_bad (_("Illegal operands (whitespace): `%s'"), ins_parse);

      if (*operandT == '(')
	bracket_flag = 1;
      else if (*operandT == '[')
	sq_bracket_flag = 1;

      if (*operandT == ')')
	{
	  if (bracket_flag)
	    bracket_flag = 0;
	  else
	    as_fatal (_("Missing matching brackets : `%s'"), ins_parse);
	}
      else if (*operandT == ']')
	{
	  if (sq_bracket_flag)
	    sq_bracket_flag = 0;
	  else
	    as_fatal (_("Missing matching brackets : `%s'"), ins_parse);
	}

      if (bracket_flag == 1 && *operandT == ')')
	bracket_flag = 0;
      else if (sq_bracket_flag == 1 && *operandT == ']')
	sq_bracket_flag = 0;

      operandT++;
    }

  /* Adding the last operand.  */
  operand[op_num++] = strdup (operandH);
  crx_ins->nargs = op_num;

  /* Verifying correct syntax of operands (all brackets should be closed).  */
  if (bracket_flag || sq_bracket_flag)
    as_fatal (_("Missing matching brackets : `%s'"), ins_parse);

  /* Now we parse each operand separately.  */
  for (op_num = 0; op_num < crx_ins->nargs; op_num++)
    {
      cur_arg_num = op_num;
      parse_operand (operand[op_num], crx_ins);
      free (operand[op_num]);
    }

  if (allocated)
    free (operandS);
}

/* Get the trap index in dispatch table, given its name.
   This routine is used by assembling the 'excp' instruction.  */

static int
gettrap (const char *s)
{
  const trap_entry *trap;

  for (trap = crx_traps; trap < (crx_traps + NUMTRAPS); trap++)
    if (strcasecmp (trap->name, s) == 0)
      return trap->entry;

  as_bad (_("Unknown exception: `%s'"), s);
  return 0;
}

/* Post-Increment instructions, as well as Store-Immediate instructions, are a 
   sub-group within load/stor instruction groups. 
   Therefore, when parsing a Post-Increment/Store-Immediate insn, we have to 
   advance the instruction pointer to the start of that sub-group (that is, up 
   to the first instruction of that type).
   Otherwise, the insn will be mistakenly identified as of type LD_STOR_INS.  */

static void
handle_LoadStor (const char *operands)
{
  /* Post-Increment instructions precede Store-Immediate instructions in 
     CRX instruction table, hence they are handled before. 
     This synchronization should be kept.  */

  /* Assuming Post-Increment insn has the following format :
     'MNEMONIC DISP(REG)+, REG' (e.g. 'loadw 12(r5)+, r6').
     LD_STOR_INS_INC are the only store insns containing a plus sign (+).  */
  if (strstr (operands, ")+") != NULL)
    {
      while (! IS_INSN_TYPE (LD_STOR_INS_INC))
	instruction++;
      return;
    }

  /* Assuming Store-Immediate insn has the following format :
     'MNEMONIC $DISP, ...' (e.g. 'storb $1, 12(r5)').
     STOR_IMM_INS are the only store insns containing a dollar sign ($).  */
  if (strstr (operands, "$") != NULL)
    while (! IS_INSN_TYPE (STOR_IMM_INS))
      instruction++;
}

/* Top level module where instruction parsing starts.
   crx_ins - data structure holds some information.
   operands - holds the operands part of the whole instruction.  */

static void
parse_insn (ins *insn, char *operands)
{
  int i;

  /* Handle instructions with no operands.  */
  for (i = 0; no_op_insn[i] != NULL; i++)
  {
    if (streq (no_op_insn[i], instruction->mnemonic))
    {
      insn->nargs = 0;
      return;
    }
  }

  /* Handle 'excp'/'cinv' instructions.  */
  if (IS_INSN_MNEMONIC ("excp") || IS_INSN_MNEMONIC ("cinv"))
    {
      insn->nargs = 1;
      insn->arg[0].type = arg_ic;
      insn->arg[0].constant = IS_INSN_MNEMONIC ("excp") ?
	gettrap (operands) : get_cinv_parameters (operands);
      insn->arg[0].X_op = O_constant;
      return;
    }

  /* Handle load/stor unique instructions before parsing.  */
  if (IS_INSN_TYPE (LD_STOR_INS))
    handle_LoadStor (operands);

  if (operands != NULL)
    parse_operands (insn, operands);
}

/* Cinv instruction requires special handling.  */

static int
get_cinv_parameters (const char *operand)
{
  const char *p = operand;
  int d_used = 0, i_used = 0, u_used = 0, b_used = 0;

  while (*++p != ']')
    {
      if (*p == ',' || *p == ' ')
	continue;

      if (*p == 'd')
	d_used = 1;
      else if (*p == 'i')
	i_used = 1;
      else if (*p == 'u')
	u_used = 1;
      else if (*p == 'b')
	b_used = 1;
      else
	as_bad (_("Illegal `cinv' parameter: `%c'"), *p);
    }

  return ((b_used ? 8 : 0)
	+ (d_used ? 4 : 0)
	+ (i_used ? 2 : 0)
	+ (u_used ? 1 : 0));
}

/* Retrieve the opcode image of a given register.
   If the register is illegal for the current instruction,
   issue an error.  */

static int
getreg_image (reg r)
{
  const reg_entry *rreg;
  char *reg_name;
  int is_procreg = 0; /* Nonzero means argument should be processor reg.  */

  if (((IS_INSN_MNEMONIC ("mtpr")) && (cur_arg_num == 1))
      || ((IS_INSN_MNEMONIC ("mfpr")) && (cur_arg_num == 0)) )
    is_procreg = 1;

  /* Check whether the register is in registers table.  */
  if (r < MAX_REG)
    rreg = &crx_regtab[r];
  /* Check whether the register is in coprocessor registers table.  */
  else if (r < (int) MAX_COPREG)
    rreg = &crx_copregtab[r-MAX_REG];
  /* Register not found.  */
  else
    {
      as_bad (_("Unknown register: `%d'"), r);
      return 0;
    }

  reg_name = rreg->name;

/* Issue a error message when register is illegal.  */
#define IMAGE_ERR \
  as_bad (_("Illegal register (`%s') in Instruction: `%s'"), \
	    reg_name, ins_parse);			     \
  break;

  switch (rreg->type)
  {
    case CRX_U_REGTYPE:
      if (is_procreg || (instruction->flags & USER_REG))
	return rreg->image;
      else
	IMAGE_ERR;

    case CRX_CFG_REGTYPE:
      if (is_procreg)
	return rreg->image;
      else
	IMAGE_ERR;

    case CRX_R_REGTYPE:
      if (! is_procreg)
	return rreg->image;
      else
	IMAGE_ERR;

    case CRX_C_REGTYPE:
    case CRX_CS_REGTYPE:
      return rreg->image;
      break;

    default:
      IMAGE_ERR;
  }

  return 0;
}

/* Routine used to represent integer X using NBITS bits.  */

static long
getconstant (long x, int nbits)
{
  return x & ((((1U << (nbits - 1)) - 1) << 1) | 1);
}

/* Print a constant value to 'output_opcode':
   ARG holds the operand's type and value.
   SHIFT represents the location of the operand to be print into.
   NBITS determines the size (in bits) of the constant.  */

static void
print_constant (int nbits, int shift, argument *arg)
{
  unsigned long mask = 0;

  long constant = getconstant (arg->constant, nbits);

  switch (nbits)
  {
    case 32:
    case 28:
    case 24:
    case 22:
      /* mask the upper part of the constant, that is, the bits
	 going to the lowest byte of output_opcode[0].
	 The upper part of output_opcode[1] is always filled,
	 therefore it is always masked with 0xFFFF.  */
      mask = (1 << (nbits - 16)) - 1;
      /* Divide the constant between two consecutive words :
		 0	   1	     2	       3
	    +---------+---------+---------+---------+
	    |	      | X X X X | X X X X |	    |
	    +---------+---------+---------+---------+
	      output_opcode[0]    output_opcode[1]     */

      CRX_PRINT (0, (constant >> WORD_SHIFT) & mask, 0);
      CRX_PRINT (1, (constant & 0xFFFF), WORD_SHIFT);
      break;

    case 16:
    case 12:
      /* Special case - in arg_cr, the SHIFT represents the location
	 of the REGISTER, not the constant, which is itself not shifted.  */
      if (arg->type == arg_cr)
	{
	  CRX_PRINT (0, constant,  0);
	  break;
	}

      /* When instruction size is 3 and 'shift' is 16, a 16-bit constant is 
	 always filling the upper part of output_opcode[1]. If we mistakenly 
	 write it to output_opcode[0], the constant prefix (that is, 'match')
	 will be overridden.
		 0	   1	     2	       3
	    +---------+---------+---------+---------+
	    | 'match' |         | X X X X |	    |
	    +---------+---------+---------+---------+
	      output_opcode[0]    output_opcode[1]     */

      if ((instruction->size > 2) && (shift == WORD_SHIFT))
	CRX_PRINT (1, constant, WORD_SHIFT);
      else
	CRX_PRINT (0, constant, shift);
      break;

    default:
      CRX_PRINT (0, constant,  shift);
      break;
  }
}

/* Print an operand to 'output_opcode', which later on will be
   printed to the object file:
   ARG holds the operand's type, size and value.
   SHIFT represents the printing location of operand.
   NBITS determines the size (in bits) of a constant operand.  */

static void
print_operand (int nbits, int shift, argument *arg)
{
  switch (arg->type)
    {
    case arg_r:
      CRX_PRINT (0, getreg_image (arg->r), shift);
      break;

    case arg_copr:
      if (arg->cr < c0 || arg->cr > c15)
	as_bad (_("Illegal Co-processor register in Instruction `%s' "),
		ins_parse);
      CRX_PRINT (0, getreg_image (arg->cr), shift);
      break;

    case arg_copsr:
      if (arg->cr < cs0 || arg->cr > cs15)
	as_bad (_("Illegal Co-processor special register in Instruction `%s' "),
		ins_parse);
      CRX_PRINT (0, getreg_image (arg->cr), shift);
      break;

    case arg_idxr:
      /*    16      12	      8    6         0
	    +--------------------------------+
	    | r_base | r_idx  | scl|  disp   |
	    +--------------------------------+	  */
      CRX_PRINT (0, getreg_image (arg->r), 12);
      CRX_PRINT (0, getreg_image (arg->i_r), 8);
      CRX_PRINT (0, arg->scale, 6);
    case arg_ic:
    case arg_c:
      print_constant (nbits, shift, arg);
      break;

    case arg_rbase:
      CRX_PRINT (0, getreg_image (arg->r), shift);
      break;

    case arg_cr:
      /* case base_cst4.  */
      if (instruction->flags & DISPU4MAP)
	print_constant (nbits, shift + REG_SIZE, arg);
      else
	/* rbase_disps<NN> and other such cases.  */
	print_constant (nbits, shift, arg);
      /* Add the register argument to the output_opcode.  */
      CRX_PRINT (0, getreg_image (arg->r), shift);
      break;

    default:
      break;
    }
}

/* Retrieve the number of operands for the current assembled instruction.  */

static int
get_number_of_operands (void)
{
  int i;

  for (i = 0; instruction->operands[i].op_type && i < MAX_OPERANDS; i++)
    ;
  return i;
}

/* Verify that the number NUM can be represented in BITS bits (that is, 
   within its permitted range), based on the instruction's FLAGS.  
   If UPDATE is nonzero, update the value of NUM if necessary.
   Return OP_LEGAL upon success, actual error type upon failure.  */

static op_err
check_range (long *num, int bits, int unsigned flags, int update)
{
  uint32_t max;
  int retval = OP_LEGAL;
  int bin;
  uint32_t upper_64kb = 0xffff0000;
  uint32_t value = *num;

  /* Verify operand value is even.  */
  if (flags & OP_EVEN)
    {
      if (value % 2)
	return OP_NOT_EVEN;
    }

  if (flags & OP_UPPER_64KB)
    {
      /* Check if value is to be mapped to upper 64 KB memory area.  */
      if ((value & upper_64kb) == upper_64kb)
	{
	  value -= upper_64kb;
	  if (update)
	    *num = value;
	}
      else
	return OP_NOT_UPPER_64KB;
    }

  if (flags & OP_SHIFT)
    {
      /* All OP_SHIFT args are also OP_SIGNED, so we want to keep the
	 sign.  However, right shift of a signed type with a negative
	 value is implementation defined.  See ISO C 6.5.7.  So we use
	 an unsigned type and sign extend afterwards.  */
      value >>= 1;
      value = (value ^ 0x40000000) - 0x40000000;
      if (update)
	*num = value;
    }
  else if (flags & OP_SHIFT_DEC)
    {
      value = (value >> 1) - 1;
      if (update)
	*num = value;
    }

  if (flags & OP_ESC)
    {
      /* 0x7e and 0x7f are reserved escape sequences of dispe9.  */
      if (value == 0x7e || value == 0x7f)
	return OP_OUT_OF_RANGE;
    }

  if (flags & OP_DISPU4)
    {
      int is_dispu4 = 0;

      uint32_t mul = (instruction->flags & DISPUB4 ? 1 
		      : instruction->flags & DISPUW4 ? 2
		      : instruction->flags & DISPUD4 ? 4
		      : 0);
      
      for (bin = 0; bin < cst4_maps; bin++)
	{
	  if (value == mul * bin)
	    {
	      is_dispu4 = 1;
	      if (update)
		*num = bin;
	      break;
	    }
	}
      if (!is_dispu4)
	retval = OP_ILLEGAL_DISPU4;
    }
  else if (flags & OP_CST4)
    {
      int is_cst4 = 0;

      for (bin = 0; bin < cst4_maps; bin++)
	{
	  if (value == (uint32_t) cst4_map[bin])
	    {
	      is_cst4 = 1;
	      if (update)
		*num = bin;
	      break;
	    }
	}
      if (!is_cst4)
	retval = OP_ILLEGAL_CST4;
    }
  else if (flags & OP_SIGNED)
    {
      max = 1;
      max = max << (bits - 1);
      value += max;
      max = ((max - 1) << 1) | 1;
      if (value > max)
	retval = OP_OUT_OF_RANGE;
    }
  else if (flags & OP_UNSIGNED)
    {
      max = 1;
      max = max << (bits - 1);
      max = ((max - 1) << 1) | 1;
      if (value > max)
	retval = OP_OUT_OF_RANGE;
    }
  return retval;
}

/* Assemble a single instruction:
   INSN is already parsed (that is, all operand values and types are set).
   For instruction to be assembled, we need to find an appropriate template in 
   the instruction table, meeting the following conditions:
    1: Has the same number of operands.
    2: Has the same operand types.
    3: Each operand size is sufficient to represent the instruction's values.
   Returns 1 upon success, 0 upon failure.  */

static int
assemble_insn (char *mnemonic, ins *insn)
{
  /* Type of each operand in the current template.  */
  argtype cur_type[MAX_OPERANDS];
  /* Size (in bits) of each operand in the current template.  */
  unsigned int cur_size[MAX_OPERANDS];
  /* Flags of each operand in the current template.  */
  unsigned int cur_flags[MAX_OPERANDS];
  /* Instruction type to match.  */
  unsigned int ins_type;
  /* Boolean flag to mark whether a match was found.  */
  int match = 0;
  int i;
  /* Nonzero if an instruction with same number of operands was found.  */
  int found_same_number_of_operands = 0;
  /* Nonzero if an instruction with same argument types was found.  */
  int found_same_argument_types = 0;
  /* Nonzero if a constant was found within the required range.  */
  int found_const_within_range  = 0;
  /* Argument number of an operand with invalid type.  */
  int invalid_optype = -1;
  /* Argument number of an operand with invalid constant value.  */
  int invalid_const  = -1;
  /* Operand error (used for issuing various constant error messages).  */
  op_err op_error, const_err = OP_LEGAL;

/* Retrieve data (based on FUNC) for each operand of a given instruction.  */
#define GET_CURRENT_DATA(FUNC, ARRAY)				  \
  for (i = 0; i < insn->nargs; i++)				  \
    ARRAY[i] = FUNC (instruction->operands[i].op_type)

#define GET_CURRENT_TYPE    GET_CURRENT_DATA(get_optype, cur_type)
#define GET_CURRENT_SIZE    GET_CURRENT_DATA(get_opbits, cur_size)
#define GET_CURRENT_FLAGS   GET_CURRENT_DATA(get_opflags, cur_flags)

  /* Instruction has no operands -> only copy the constant opcode.   */
  if (insn->nargs == 0)
    {
      output_opcode[0] = BIN (instruction->match, instruction->match_bits);
      return 1;
    }

  /* In some case, same mnemonic can appear with different instruction types.
     For example, 'storb' is supported with 3 different types :
     LD_STOR_INS, LD_STOR_INS_INC, STOR_IMM_INS.
     We assume that when reaching this point, the instruction type was 
     pre-determined. We need to make sure that the type stays the same
     during a search for matching instruction.  */
  ins_type = CRX_INS_TYPE(instruction->flags);

  while (/* Check that match is still not found.  */
	 match != 1
	 /* Check we didn't get to end of table.  */
	 && instruction->mnemonic != NULL
	 /* Check that the actual mnemonic is still available.  */
	 && IS_INSN_MNEMONIC (mnemonic)
	 /* Check that the instruction type wasn't changed.  */
	 && IS_INSN_TYPE(ins_type))
    {
      /* Check whether number of arguments is legal.  */
      if (get_number_of_operands () != insn->nargs)
	goto next_insn;
      found_same_number_of_operands = 1;

      /* Initialize arrays with data of each operand in current template.  */
      GET_CURRENT_TYPE;
      GET_CURRENT_SIZE;
      GET_CURRENT_FLAGS;

      /* Check for type compatibility.  */
      for (i = 0; i < insn->nargs; i++)
        {
	  if (cur_type[i] != insn->arg[i].type)
	    {
	      if (invalid_optype == -1)
		invalid_optype = i + 1;
	      goto next_insn;
	    }
	}
      found_same_argument_types = 1;

      for (i = 0; i < insn->nargs; i++)
	{
	  /* Reverse the operand indices for certain opcodes:
	     Index 0	  -->> 1
	     Index 1	  -->> 0	
	     Other index  -->> stays the same.  */
	  int j = instruction->flags & REVERSE_MATCH ? 
		  i == 0 ? 1 : 
		  i == 1 ? 0 : i : 
		  i;

	  /* Only check range - don't update the constant's value, since the 
	     current instruction may not be the last we try to match.  
	     The constant's value will be updated later, right before printing 
	     it to the object file.  */
  	  if ((insn->arg[j].X_op == O_constant) 
	       && (op_error = check_range (&insn->arg[j].constant, cur_size[j], 
					   cur_flags[j], 0)))
  	    {
	      if (invalid_const == -1)
	      {
		invalid_const = j + 1;
		const_err = op_error;
	      }
	      goto next_insn;
	    }
	  /* For symbols, we make sure the relocation size (which was already 
	     determined) is sufficient.  */
	  else if ((insn->arg[j].X_op == O_symbol)
		    && ((bfd_reloc_type_lookup (stdoutput, insn->rtype))->bitsize 
			 > cur_size[j]))
		  goto next_insn;
	}
      found_const_within_range = 1;

      /* If we got till here -> Full match is found.  */
      match = 1;
      break;

/* Try again with next instruction.  */
next_insn:
      instruction++;
    }

  if (!match)
    {
      /* We haven't found a match - instruction can't be assembled.  */
      if (!found_same_number_of_operands)
	as_bad (_("Incorrect number of operands"));
      else if (!found_same_argument_types)
	as_bad (_("Illegal type of operand (arg %d)"), invalid_optype);
      else if (!found_const_within_range)
      {
	switch (const_err)
	{
	case OP_OUT_OF_RANGE:
	  as_bad (_("Operand out of range (arg %d)"), invalid_const);
	  break;
	case OP_NOT_EVEN:
	  as_bad (_("Operand has odd displacement (arg %d)"), invalid_const);
	  break;
	case OP_ILLEGAL_DISPU4:
	  as_bad (_("Invalid DISPU4 operand value (arg %d)"), invalid_const);
	  break;
	case OP_ILLEGAL_CST4:
	  as_bad (_("Invalid CST4 operand value (arg %d)"), invalid_const);
	  break;
	case OP_NOT_UPPER_64KB:
	  as_bad (_("Operand value is not within upper 64 KB (arg %d)"), 
		    invalid_const);
	  break;
	default:
	  as_bad (_("Illegal operand (arg %d)"), invalid_const);
	  break;
	}
      }
      
      return 0;
    }
  else
    /* Full match - print the encoding to output file.  */
    {
      /* Make further checkings (such that couldn't be made earlier).
	 Warn the user if necessary.  */
      warn_if_needed (insn);
      
      /* Check whether we need to adjust the instruction pointer.  */
      if (adjust_if_needed (insn))
	/* If instruction pointer was adjusted, we need to update 
	   the size of the current template operands.  */
	GET_CURRENT_SIZE;

      for (i = 0; i < insn->nargs; i++)
        {
	  int j = instruction->flags & REVERSE_MATCH ? 
		  i == 0 ? 1 : 
		  i == 1 ? 0 : i : 
		  i;

	  /* This time, update constant value before printing it.  */
  	  if ((insn->arg[j].X_op == O_constant) 
	       && (check_range (&insn->arg[j].constant, cur_size[j], 
				cur_flags[j], 1) != OP_LEGAL))
	      as_fatal (_("Illegal operand (arg %d)"), j+1);
	}

      /* First, copy the instruction's opcode.  */
      output_opcode[0] = BIN (instruction->match, instruction->match_bits);

      for (i = 0; i < insn->nargs; i++)
        {
	  cur_arg_num = i;
          print_operand (cur_size[i], instruction->operands[i].shift, 
			 &insn->arg[i]);
        }
    }

  return 1;
}

/* Bunch of error checkings.
   The checks are made after a matching instruction was found.  */

void
warn_if_needed (ins *insn)
{
  /* If the post-increment address mode is used and the load/store 
     source register is the same as rbase, the result of the 
     instruction is undefined.  */
  if (IS_INSN_TYPE (LD_STOR_INS_INC))
    {
      /* Enough to verify that one of the arguments is a simple reg.  */
      if ((insn->arg[0].type == arg_r) || (insn->arg[1].type == arg_r))
	if (insn->arg[0].r == insn->arg[1].r)
	  as_bad (_("Same src/dest register is used (`r%d'), result is undefined"), 
		   insn->arg[0].r);
    }

  /* Some instruction assume the stack pointer as rptr operand.
     Issue an error when the register to be loaded is also SP.  */
  if (instruction->flags & NO_SP)
    {
      if (getreg_image (insn->arg[0].r) == getreg_image (sp))
	as_bad (_("`%s' has undefined result"), ins_parse);
    }

  /* If the rptr register is specified as one of the registers to be loaded, 
     the final contents of rptr are undefined. Thus, we issue an error.  */
  if (instruction->flags & NO_RPTR)
    {
      if ((1 << getreg_image (insn->arg[0].r)) & insn->arg[1].constant)
	as_bad (_("Same src/dest register is used (`r%d'), result is undefined"), 
	 getreg_image (insn->arg[0].r));
    }
}

/* In some cases, we need to adjust the instruction pointer although a 
   match was already found. Here, we gather all these cases.
   Returns 1 if instruction pointer was adjusted, otherwise 0.  */

int
adjust_if_needed (ins *insn)
{
  int ret_value = 0;

  /* Special check for 'addub $0, r0' instruction -
     The opcode '0000 0000 0000 0000' is not allowed.  */
  if (IS_INSN_MNEMONIC ("addub"))
    {
      if ((instruction->operands[0].op_type == cst4)
	  && instruction->operands[1].op_type == regr)
        {
          if (insn->arg[0].constant == 0 && insn->arg[1].r == r0)
	    {
	      instruction++;
	      ret_value = 1;
	    }
        }
    }

  /* Optimization: Omit a zero displacement in bit operations, 
     saving 2-byte encoding space (e.g., 'cbitw $8, 0(r1)').  */
  if (IS_INSN_TYPE (CSTBIT_INS))
    {
      if ((instruction->operands[1].op_type == rbase_disps12)
	   && (insn->arg[1].X_op == O_constant)
	   && (insn->arg[1].constant == 0))
            {
              instruction--;
	      ret_value = 1;
            }
    }

  return ret_value;
}

/* Set the appropriate bit for register 'r' in 'mask'.
   This indicates that this register is loaded or stored by
   the instruction.  */

static void
mask_reg (int r, unsigned short int *mask)
{
  if ((reg)r > (reg)sp)
    {
      as_bad (_("Invalid Register in Register List"));
      return;
    }

  *mask |= (1 << r);
}

/* Preprocess register list - create a 16-bit mask with one bit for each
   of the 16 general purpose registers. If a bit is set, it indicates
   that this register is loaded or stored by the instruction.  */

static char *
preprocess_reglist (char *param, int *allocated)
{
  char reg_name[MAX_REGNAME_LEN]; /* Current parsed register name.  */
  char *regP;			  /* Pointer to 'reg_name' string.  */
  int reg_counter = 0;		  /* Count number of parsed registers.  */
  unsigned short int mask = 0;	  /* Mask for 16 general purpose registers.  */
  char *new_param;		  /* New created operands string.  */
  char *paramP = param;		  /* Pointer to original opearands string.  */
  char maskstring[10];		  /* Array to print the mask as a string.  */
  int hi_found = 0, lo_found = 0; /* Boolean flags for hi/lo registers.  */
  reg r;
  copreg cr;

  /* If 'param' is already in form of a number, no need to preprocess.  */
  if (strchr (paramP, '{') == NULL)
    return param;

  /* Verifying correct syntax of operand.  */
  if (strchr (paramP, '}') == NULL)
    as_fatal (_("Missing matching brackets : `%s'"), ins_parse);

  while (*paramP++ != '{');

  new_param = (char *)xcalloc (MAX_INST_LEN, sizeof (char));
  *allocated = 1;
  strncpy (new_param, param, paramP - param - 1);

  while (*paramP != '}')
    {
      regP = paramP;
      memset (&reg_name, '\0', sizeof (reg_name));

      while (ISALNUM (*paramP))
	paramP++;

      strncpy (reg_name, regP, paramP - regP);

      /* Coprocessor register c<N>.  */
      if (IS_INSN_TYPE (COP_REG_INS))
        {
          if (((cr = get_copregister (reg_name)) == nullcopregister)
	      || (crx_copregtab[cr-MAX_REG].type != CRX_C_REGTYPE))
	    as_fatal (_("Illegal register `%s' in cop-register list"), reg_name);
	  mask_reg (getreg_image (cr - c0), &mask);
        }
      /* Coprocessor Special register cs<N>.  */
      else if (IS_INSN_TYPE (COPS_REG_INS))
        {
          if (((cr = get_copregister (reg_name)) == nullcopregister)
	      || (crx_copregtab[cr-MAX_REG].type != CRX_CS_REGTYPE))
	    as_fatal (_("Illegal register `%s' in cop-special-register list"), 
		      reg_name);
	  mask_reg (getreg_image (cr - cs0), &mask);
        }
      /* User register u<N>.  */
      else if (instruction->flags & USER_REG)
	{
	  if (streq(reg_name, "uhi"))
	    {
	      hi_found = 1;
	      goto next_inst;
	    }
	  else if (streq(reg_name, "ulo"))
	    {
	      lo_found = 1;
	      goto next_inst;
	    }
          else if (((r = get_register (reg_name)) == nullregister)
	      || (crx_regtab[r].type != CRX_U_REGTYPE))
	    as_fatal (_("Illegal register `%s' in user register list"), reg_name);
	  
	  mask_reg (getreg_image (r - u0), &mask);	  
	}
      /* General purpose register r<N>.  */
      else
        {
	  if (streq(reg_name, "hi"))
	    {
	      hi_found = 1;
	      goto next_inst;
	    }
	  else if (streq(reg_name, "lo"))
	    {
	      lo_found = 1;
	      goto next_inst;
	    }
          else if (((r = get_register (reg_name)) == nullregister)
	      || (crx_regtab[r].type != CRX_R_REGTYPE))
	    as_fatal (_("Illegal register `%s' in register list"), reg_name);

	  mask_reg (getreg_image (r - r0), &mask);
        }

      if (++reg_counter > MAX_REGS_IN_MASK16)
	as_bad (_("Maximum %d bits may be set in `mask16' operand"),
		MAX_REGS_IN_MASK16);

next_inst:
      while (!ISALNUM (*paramP) && *paramP != '}')
	  paramP++;
    }

  if (*++paramP != '\0')
    as_warn (_("rest of line ignored; first ignored character is `%c'"),
	     *paramP);

  switch (hi_found + lo_found)
    {
    case 0:
      /* At least one register should be specified.  */
      if (mask == 0)
	as_bad (_("Illegal `mask16' operand, operation is undefined - `%s'"),
		ins_parse);
      break;

    case 1:
      /* HI can't be specified without LO (and vise-versa).  */
      as_bad (_("HI/LO registers should be specified together"));
      break;

    case 2:
      /* HI/LO registers mustn't be masked with additional registers.  */
      if (mask != 0)
	as_bad (_("HI/LO registers should be specified without additional registers"));

    default:
      break;
    }

  sprintf (maskstring, "$0x%x", mask);
  strcat (new_param, maskstring);
  return new_param;
}

/* Print the instruction.
   Handle also cases where the instruction is relaxable/relocatable.  */

void
print_insn (ins *insn)
{
  unsigned int i, j, insn_size;
  char *this_frag;
  unsigned short words[4];
  int addr_mod;

  /* Arrange the insn encodings in a WORD size array.  */
  for (i = 0, j = 0; i < 2; i++)
    {
      words[j++] = (output_opcode[i] >> 16) & 0xFFFF;
      words[j++] = output_opcode[i] & 0xFFFF;
    }

  /* Handle relaxtion.  */
  if ((instruction->flags & RELAXABLE) && relocatable)
    {
      int relax_subtype;

      /* Write the maximal instruction size supported.  */
      insn_size = INSN_MAX_SIZE;

      /* bCC  */
      if (IS_INSN_TYPE (BRANCH_INS))
	relax_subtype = 0;
      /* bal  */
      else if (IS_INSN_TYPE (DCR_BRANCH_INS) || IS_INSN_MNEMONIC ("bal"))
	relax_subtype = 3;
      /* cmpbr/bcop  */
      else if (IS_INSN_TYPE (CMPBR_INS) || IS_INSN_TYPE (COP_BRANCH_INS))
	relax_subtype = 5;
      else
	abort ();

      this_frag = frag_var (rs_machine_dependent, insn_size * 2,
			    4, relax_subtype,
			    insn->exp.X_add_symbol,
			    insn->exp.X_add_number,
			    0);
    }
  else
    {
      insn_size = instruction->size;
      this_frag = frag_more (insn_size * 2);

      /* Handle relocation.  */
      if ((relocatable) && (insn->rtype != BFD_RELOC_NONE))
	{
	  reloc_howto_type *reloc_howto;
	  int size;

	  reloc_howto = bfd_reloc_type_lookup (stdoutput, insn->rtype);

	  if (!reloc_howto)
	    abort ();

	  size = bfd_get_reloc_size (reloc_howto);

	  if (size < 1 || size > 4)
	    abort ();

	  fix_new_exp (frag_now, this_frag - frag_now->fr_literal,
		       size, &insn->exp, reloc_howto->pc_relative,
		       insn->rtype);
	}
    }

  /* Verify a 2-byte code alignment.  */
  addr_mod = frag_now_fix () & 1;
  if (frag_now->has_code && frag_now->insn_addr != addr_mod)
    as_bad (_("instruction address is not a multiple of 2"));
  frag_now->insn_addr = addr_mod;
  frag_now->has_code = 1;

  /* Write the instruction encoding to frag.  */
  for (i = 0; i < insn_size; i++)
    {
      md_number_to_chars (this_frag, (valueT) words[i], 2);
      this_frag += 2;
    }
}

/* This is the guts of the machine-dependent assembler.  OP points to a
   machine dependent instruction.  This function is supposed to emit
   the frags/bytes it assembles to.  */

void
md_assemble (char *op)
{
  ins crx_ins;
  char *param;
  char c;

  /* Reset global variables for a new instruction.  */
  reset_vars (op);

  /* Strip the mnemonic.  */
  for (param = op; *param != 0 && !ISSPACE (*param); param++)
    ;
  c = *param;
  *param++ = '\0';

  /* Find the instruction.  */
  instruction = (const inst *) hash_find (crx_inst_hash, op);
  if (instruction == NULL)
    {
      as_bad (_("Unknown opcode: `%s'"), op);
      param[-1] = c;
      return;
    }

  /* Tie dwarf2 debug info to the address at the start of the insn.  */
  dwarf2_emit_insn (0);

  /* Parse the instruction's operands.  */
  parse_insn (&crx_ins, param);

  /* Assemble the instruction - return upon failure.  */
  if (assemble_insn (op, &crx_ins) == 0)
    {
      param[-1] = c;
      return;
    }

  /* Print the instruction.  */
  param[-1] = c;
  print_insn (&crx_ins);
}
@


1.26
log
@gas/
	* config/tc-crx.c: Include bfd_stdint.h.
	(getconstant): Remove irrelevant comment.  Don't fail due to
	sign-extension of int mask.
	(check_range): Rewrite using unsigned arithmetic throughout.
opcodes/
	* crx-dis.c (print_arg): Mask constant to 32 bits.
	* crx-opc.c (cst4_map): Use int array.
include/opcode/
	* crx.h (cst4_map): Update declaration.
@
text
@a1333 3
  /* Trim all values to 32 bits.  uint32_t can be more than 32 bits.  */
  value &= 0xffffffff;

d1361 1
a1361 1
      value = ((value ^ 0x40000000) - 0x40000000) & 0xffffffff;
d1407 1
a1407 1
	  if (value == ((uint32_t) cst4_map[bin] & 0xffffffff))
@


1.25
log
@	* config/obj-evax.h (S_SET_OTHER, S_SET_TYPE, S_SET_DESC): Don't define.
	* config/tc-crx.c (gettrap): Constify arg.
	(handle_LoadStor, get_cinv_parameters): Likewise.
	(getreg_image): Fix enum warning
	(md_assemble): Restore input line char.
	* config/tc-hppa.c (tc_gen_reloc): Fix enum warning.
	* config/tc-i960.c (mem_fmt): Rename var to fix shadow warning.
	* config/tc-sh.c (sh_fdpic): Only define when OBJ_ELF.
	(build_Mytes): Fix build failure for non-elf targets.
	* config/tc-tic4x.c (tic4x_eval): Restore terminator char.
	* config/tc-xtensa.c (xtensa_end_directive): Fix switch enum warning.

	* cgen.c (gas_cgen_md_apply_fix): Avoid set but unused warning.
	* ecoff.c (add_ecoff_symbol): Likewise.
	* itbl-ops.c (append_insns_as_macros): Likewise.
	* listing.c (debugging_pseudo): Likewise.
	* read.c (s_mri_common, stringer): Likewise.
	* config/obj-coff.c (coff_frob_section): Likewise.
	* config/tc-alpha.c (emit_ldgp, s_alpha_proc): Likewise.
	* config/tc-arm.c (my_get_expression): Likewise.
	* config/tc-hppa.c (process_exit, pa_type_args): Likewise.
	* config/tc-m32c.c (md_assemble): Likewise.
	* config/tc-microblaze.c (md_convert_frag): Likewise.
	* config/tc-mips.c (s_change_section): Likewise.
	* config/tc-mt.c (mt_fix_adjustable): Likewise.
	* config/tc-xtensa.c (xtensa_literal_pseudo): Likewise.

	* config/obj-aout.c (obj_aout_frob_symbol): Delete set but otherwise
	unused vars.
	* config/tc-alpha.c (load_expression): Likewise.
	(s_alpha_rdata, s_alpha_section, s_alpha_prologue): Likewise.
	* config/tc-arm.c (parse_neon_el_struct_list): Likewise.
	* config/tc-avr.c (extract_word): Likewise.
	* config/tc-cris.c (cris_get_expression): Likewise.
	* config/tc-d30v.c (build_insn, find_format): Likewise.
	* config/tc-dlx.c (machine_ip): Likewise.
	* config/tc-hppa.c (pa_get_absolute_expression): Likewise.
	* config/tc-i370.c (md_assemble): Likewise.
	* config/tc-i960.c (brtab_emit): Likewise.
	* config/tc-iq2000.c (s_iq2000_ent): Likewise.
	* config/tc-m32c.c (md_convert_frag): Likewise.
	* config/tc-m68hc11.c (fixup24, build_jump_insn): Likewise.
	(md_estimate_size_before_relax, md_apply_fix): Likewise.
	* config/tc-m68k.c (md_show_usage): Likewise.
	* config/tc-microblaze.c (microblaze_s_lcomm): Likewise.
	* config/tc-mips.c (s_mips_end): Likewise.
	* config/tc-mmix.c (mmix_byte, mmix_cons): Likewise.
	* config/tc-mn10300.c (md_assemble): Likewise.
	* config/tc-msp430.c (extract_word): Likewise.
	* config/tc-mt.c (md_assemble): Likewise.
	* config/tc-or32.c (machine_ip): Likewise.
	* config/tc-pj.c (md_apply_fix): Likewise.
	* config/tc-s390.c (md_gather_operands): Likewise.
	* config/tc-sh.c (sh_cons_align): Likewise.
	* config/tc-sparc.c (sparc_cons_align): Likewise.
	* config/tc-tic4x.c (tic4x_sect): Likewise.
	* config/tc-tic54x.c (tic54x_stringer): Likewise.
	* config/tc-vax.c (vip_op): Likewise.
	* config/tc-xstormy16.c (xstormy16_cons_fix_new): Likewise.
	* config/tc-xtensa.c (md_assemble): Likewise.
	(xtensa_fix_short_loop_frags, convert_frag_immed): Likewise.
	(xtensa_move_literals): Likewise.
@
text
@d2 1
a2 1
   Copyright 2004, 2005, 2006, 2007, 2008, 2009, 2010
d27 1
d1177 1
a1177 3
  /* The following expression avoids overflow if
     'nbits' is the number of bits in 'bfd_vma'.  */
  return (x & ((((1 << (nbits - 1)) - 1) << 1) | 1));
d1328 1
a1328 1
  long min, max;
d1331 2
a1332 2
  long upper_64kb = 0xFFFF0000;
  long value = *num;
d1334 2
a1335 5
  /* For hosts witah longs bigger than 32-bits make sure that the top 
     bits of a 32-bit negative value read in by the parser are set,
     so that the correct comparisons are made.  */
  if (value & 0x80000000)
    value |= (-1L << 31);
d1359 4
d1364 1
d1386 4
a1389 3
      int mul = (instruction->flags & DISPUB4) ? 1 
		: (instruction->flags & DISPUW4) ? 2
		: (instruction->flags & DISPUD4) ? 4 : 0;
d1393 1
a1393 1
	  if (value == (mul * bin))
d1410 1
a1410 1
	  if (value == cst4_map[bin])
d1423 5
a1427 3
      max = (1 << (bits - 1)) - 1;
      min = - (1 << (bits - 1));
      if ((value > max) || (value < min))
d1432 4
a1435 4
      max = ((((1 << (bits - 1)) - 1) << 1) | 1);
      min = 0;
      if (((unsigned long) value > (unsigned long) max) 
	    || ((unsigned long) value < (unsigned long) min))
@


1.24
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d2 2
a3 1
   Copyright 2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d151 3
a153 3
static int     gettrap		        (char *);
static void    handle_LoadStor	        (char *);
static int     get_cinv_parameters      (char *);
d990 1
a990 1
gettrap (char *s)
d1010 1
a1010 1
handle_LoadStor (char *operands)
d1075 1
a1075 1
get_cinv_parameters (char * operand)
d1077 1
a1077 1
  char *p = operand;
d1122 1
a1122 1
  else if (r < MAX_COPREG)
d1990 1
d2002 4
a2005 1
    return;
d2008 1
@


1.23
log
@update copyright dates
@
text
@d208 1
a208 1
  const reg_entry *reg;
d210 1
a210 1
  reg = (const reg_entry *) hash_find (reg_hash, reg_name);
d212 2
a213 2
  if (reg != NULL)
    return reg->value.reg_val;
d223 1
a223 1
  const reg_entry *copreg;
d225 1
a225 1
  copreg = (const reg_entry *) hash_find (copreg_hash, copreg_name);
d227 2
a228 2
  if (copreg != NULL)
    return copreg->value.copreg_val;
d1109 1
a1109 1
  const reg_entry *reg;
d1119 1
a1119 1
    reg = &crx_regtab[r];
d1122 1
a1122 1
    reg = &crx_copregtab[r-MAX_REG];
d1130 1
a1130 1
  reg_name = reg->name;
d1138 1
a1138 1
  switch (reg->type)
d1142 1
a1142 1
	return reg->image;
d1148 1
a1148 1
	return reg->image;
d1154 1
a1154 1
	return reg->image;
d1160 1
a1160 1
      return reg->image;
@


1.22
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d2 1
a2 1
   Copyright 2004, 2007, 2008 Free Software Foundation, Inc.
@


1.21
log
@Banish PARAMS and PTR.  Convert to ISO C.
Delete unnecessary forward declarations.
@
text
@d354 1
a354 1
  assert ((int) fixP->fx_r_type > 0);
d365 1
a365 1
  assert (!fixP->fx_pcrel == !reloc->howto->pc_relative);
@


1.20
log
@Remove duplicate definitions of the md_atof() function
@
text
@d2 1
a2 1
   Copyright 2004, 2007 Free Software Foundation, Inc.
d541 1
a541 1
	(PTR) &crx_instruction[i]);
d569 1
a569 1
	hashret = hash_insert (reg_hash, regtab->name, (PTR) regtab);
d587 2
a588 1
	hashret = hash_insert (copreg_hash, copregtab->name, (PTR) copregtab);
@


1.19
log
@Switch to GPLv3
@
text
@a465 5
/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */

d469 1
a469 44
  int prec;
  LITTLENUM_TYPE words[4];
  char *t;
  int i;

  switch (type)
    {
    case 'f':
      prec = 2;
      break;

    case 'd':
      prec = 4;
      break;

    default:
      *sizeP = 0;
      return _("bad call to md_atof");
    }

  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizeP = prec * 2;

  if (! target_big_endian)
    {
      for (i = prec - 1; i >= 0; i--)
	{
	  md_number_to_chars (litP, (valueT) words[i], 2);
	  litP += 2;
	}
    }
  else
    {
      for (i = 0; i < prec; i++)
	{
	  md_number_to_chars (litP, (valueT) words[i], 2);
	  litP += 2;
	}
    }

  return NULL;
@


1.18
log
@	* config/obj-coff.c, config/tc-arm.c, config/tc-bfin.c,
	config/tc-cris.c, config/tc-crx.c, config/tc-i386.c,
	config/tc-ia64.c, config/tc-maxq.c, config/tc-maxq.h,
	config/tc-mips.c, config/tc-msp430.c, config/tc-sh.c,
	config/tc-tic4x.c, config/tc-xtensa.c: Fix comment typos.
@
text
@d2 1
a2 1
   Copyright 2004 Free Software Foundation, Inc.
d12 1
a12 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.17
log
@(check_range): Ensure that the sign bit of a 32-bit value is propagated into
the upper bits of a 64-bit long.
@
text
@d1274 1
a1274 1
	 will be overriden.
@


1.16
log
@(reset_vars): Use strncpy to prevent overflowing the ins_parse buffer.
@
text
@d1381 6
@


1.15
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@d271 2
a272 1
  strcpy (ins_parse, op);
@


1.14
log
@Update the address and phone number of the FSF
@
text
@d526 1
a526 1
md_apply_fix3 (fixS *fixP, valueT *valP, segT seg)
@


1.13
log
@2004-12-23  Tomer Levi  <Tomer.Levi@@nsc.com>

	* config/tc-crx.c: Support 'bcop' relaxation (dealt as in 'cmp&branch' case).
@
text
@d22 2
a23 2
   Free Software Foundation, 59 Temple Place - Suite 330, Boston,
   MA 02111-1307, USA.  */
@


1.12
log
@2004-11-29  Tomer Levi  <Tomer.Levi@@nsc.com>

config/tc-crx.c: Major code cleanup. Remove unused variables and functions,
give functions a meaningful name, add comments.
(check_range): New function - Replace operand size calculation
with range checking.
(assemble_insn): Update Algorithm, improve error issuing.
(enum op_err): New - Operand error (for issuing operand error messages).
(process_label_constant): Bug fix regarding COP_BRANCH_INS relocation handling.
@
text
@d137 1
a137 1
  /* cmpbr  */
d710 1
a710 1
          else if (IS_INSN_TYPE (CMPBR_INS))
a711 2
          else if (IS_INSN_TYPE (COP_BRANCH_INS))
	    crx_ins->rtype = BFD_RELOC_CRX_REL24;
d1950 2
a1951 2
      /* cmpbr  */
      else if (IS_INSN_TYPE (CMPBR_INS))
@


1.11
log
@2004-11-08  Tomer Levi  <Tomer.Levi@@nsc.com>

	* config/tc-crx.c (print_insn): Check and set insn_addr.
	* config/tc-crx.h (md_frag_check): Define.
@
text
@a30 2
#include <limits.h>

a31 1
#define WORD_SIZE   16
a42 5
/* Escape to 16-bit immediate.  */
#define ESC_16  0xE
/* Escape to 32-bit immediate.  */
#define ESC_32  0xF

d47 1
a47 22
/* A mask to set n_bits starting from offset offs.  */
#define SET_BITS_MASK(offs,n_bits)    ((((1 << (n_bits)) - 1) << (offs)))
/* A mask to clear n_bits starting from offset offs.  */
#define CLEAR_BITS_MASK(offs,n_bits)  (~(((1 << (n_bits)) - 1) << (offs)))

/* Get the argument type for each operand of a given instruction.  */
#define GET_ACTUAL_TYPE						  \
  for (i = 0; i < insn->nargs; i++)				  \
    atyp_act[i] = getarg_type (instruction->operands[i].op_type)

/* Get the size (in bits) for each operand of a given instruction.  */
#define GET_ACTUAL_SIZE						  \
  for (i = 0; i < insn->nargs; i++)				  \
    bits_act[i] = getbits (instruction->operands[i].op_type)

/* Non-zero if OP is instruction with no operands.  */
#define NO_OPERANDS_INST(OP)			  \
  (streq (OP, "di") || streq (OP, "nop")	  \
   || streq (OP, "retx") || streq (OP, "ei")	  \
   || streq (OP, "wait") || streq (OP, "eiwait"))

/* Print a number NUM, shifted by SHIFT bytes, into a location
d51 13
d73 3
a75 1
/* Initialize global variables.  */
d77 1
d80 1
a80 6
/* Nonzero means a constant's bit-size was already set.  */
int size_was_set;
/* Nonzero means a negative constant.  */
int signflag;
/* Nonzero means a CST4 instruction.  */
int cst4flag;
d83 2
a84 1
/* Holds the current processed argument number.  */
d125 1
d142 1
a142 1
static void    reset_vars	        (char *, ins *);
d145 3
a147 4
static void    set_operand_size		(ins *);
static argtype getarg_type	        (operand_type);
static int     getbits		        (operand_type);
static int     get_flags	        (operand_type);
d153 2
a154 1
static unsigned long getconstant        (unsigned long, int);
a160 1
static void    mask_const	        (unsigned long *, int);
d162 1
a162 1
static int     process_label_constant   (char *, ins *);
d167 2
d173 1
a173 1
getbits (operand_type op)
d184 1
a184 1
getarg_type (operand_type op)
d195 1
a195 1
get_flags (operand_type op)
a232 8
/* Mask a constant to the number of bits it is to be mapped to.  */

static void
mask_const (unsigned long int *t, int size)
{
  *t &= (((LONGLONG)1 << size) - 1);
}

d265 1
a265 1
reset_vars (char *op, ins *crx_ins)
d267 1
a267 3
  unsigned int i;

  cur_arg_num = relocatable = size_was_set = signflag = cst4flag = 0;
a269 4
  /* Memset the 'signflag' field in every argument.  */
  for (i = 0; i < MAX_OPERANDS; i++)
    crx_ins->arg[i].signflag = 0;

d645 2
a646 2
/* Set the number of bits corresponding to a constant -
   here we check for possible overflow cases.  */
a648 160
set_operand_size (ins * crx_ins)
{
  int cnt_bits = 0;
  const cst4_entry *cst4_op;
  argument *cur_arg = &crx_ins->arg[cur_arg_num];  /* Current argument.  */
  unsigned long int temp = cur_arg->constant;

  /* If the constant's size was already set - nothing to do.  */
  if (size_was_set)
    return;

  /* Already dealt with negative numbers in process_label_constants.  */
  while (temp > 0)
    {
      temp >>= 1;
      cnt_bits++;
    }

  /* Arithmetic instructions :
     16-bit positive signed immediate -->> represent as 32-bit.  */
  if (IS_INSN_TYPE (ARITH_INS) && !relocatable && !signflag)
    {
      if (cnt_bits == 16)
        {
          cur_arg->size = 32;
          return;
        }
    }
  /* Index addressing mode :
     6-bit positive signed immediate -->> represent as 22-bit.  */
  if (IS_INSN_TYPE (LD_STOR_INS)
      || IS_INSN_TYPE (STOR_IMM_INS)
      || IS_INSN_TYPE (CSTBIT_INS))
    {
      if (!signflag && cur_arg->type == arg_idxr)
        {
          if (cnt_bits == 6)
            {
              cur_arg->size = 22;
              return;
            }
          if (cnt_bits == 22)
	    as_bad (_("Offset out of range in Instruction `%s'"), ins_parse);
        }
    }
  /* load/stor instructions :
     16-bit positive signed immediate -->> represent as 32-bit.  */
  if (IS_INSN_TYPE (LD_STOR_INS))
    {
      if (!signflag && cur_arg->type == arg_cr)
        {
          if (cnt_bits == 16)
            {
              cur_arg->size = 32;
              return;
            }
          if (cnt_bits == 32)
	    as_bad (_("Offset out of range in Instruction `%s'"), ins_parse);
        }
    }
  /* Post-increment mode :
     12-bit positive signed immediate -->> represent as 28-bit.  */
  if (IS_INSN_TYPE (CSTBIT_INS)
      || IS_INSN_TYPE (LD_STOR_INS_INC)
      || IS_INSN_TYPE (STOR_IMM_INS))
    {
      if (!signflag && cur_arg->type == arg_cr)
        {
          if (cnt_bits == 12)
            {
              cur_arg->size = 28;
              if (IS_INSN_TYPE (LD_STOR_INS_INC))
		as_bad (_("Offset out of range in Instruction `%s'"), ins_parse);
              return;
            }
          if (IS_INSN_TYPE (CSTBIT_INS) || IS_INSN_TYPE (STOR_IMM_INS))
            {
              if (cnt_bits == 28)
		as_bad (_("Offset out of range in Instruction `%s'"), ins_parse);
            }

        }
    }

  /* Handle negative cst4 mapping for arithmetic/cmp&br operations.  */
  if (signflag && !relocatable
      && ((IS_INSN_TYPE (ARITH_INS) || IS_INSN_TYPE (ARITH_BYTE_INS))
      || ((IS_INSN_TYPE (CMPBR_INS) && cur_arg_num == 0))))
    {
      for (cst4_op = cst4_map; cst4_op < (cst4_map + cst4_maps); cst4_op++)
	{
	  if (cur_arg->constant == (unsigned int)(-cst4_op->value))
	    {
	      cur_arg->size = 4;
	      cur_arg->constant = cst4_op->binary;
	      cur_arg->signflag = 0;
	      return;
	    }
	}
    }
  /* Because of the cst4 mapping -- -1 and -4 already handled above
     as well as for relocatable cases.  */
  if (signflag && IS_INSN_TYPE (ARITH_BYTE_INS))
    {
      if (!relocatable)
        {
          if (cur_arg->constant <= 0xffff)
            cur_arg->size = 16;
          else
	    /* Setting to 18 so that there is no match.  */
            cur_arg->size = 18;
        }
      else
        cur_arg->size = 16;
      return;
    }

  if (signflag && IS_INSN_TYPE (ARITH_INS))
    {
      /* For all immediates which can be expressed in less than 16 bits.  */
      if (cur_arg->constant <= 0xffff && !relocatable)
        {
          cur_arg->size = 16;
          return;
        }
      /* Either it is relocatable or not representable in 16 bits.  */
      if (cur_arg->constant < 0xffffffff || relocatable)
        {
          cur_arg->size = 32;
          return;
        }
      cur_arg->size = 33;
      return;
    }

  if (signflag && !relocatable)
    return;

  if (!relocatable)
    cur_arg->size = cnt_bits;

  /* Checking for Error Conditions.  */
  if (IS_INSN_TYPE (ARITH_INS) && !signflag)
    {
      if (cnt_bits > 32)
	as_bad (_("Cannot represent Immediate in %d bits in Instruction `%s'"),
		cnt_bits, ins_parse);
    }
  else if (IS_INSN_TYPE (ARITH_BYTE_INS) && !signflag)
    {
      if (cnt_bits > 16)
	as_bad (_("Cannot represent Immediate in %d bits in Instruction `%s'"),
		cnt_bits, ins_parse);
    }
}

/* Handle the constants immediate/absolute values and
   Labels (jump targets/Memory locations).  */

static int
d651 1
a651 5
  char *save;
  unsigned long int temp, cnt;
  const cst4_entry *cst4_op;
  int is_cst4 = 0;
  int constant_val = 0;
d654 1
a654 11
  save = input_line_pointer;
  signflag = 0;

  if (str[0] == '-')
    {
      signflag = 1;
      str++;
    }
  else if (str[0] == '+')
    str++;

d658 1
a658 1

d670 1
a670 1
      break;
d673 2
a674 247
      cur_arg->constant = constant_val = crx_ins->exp.X_add_number;
      if ((IS_INSN_TYPE (CMPBR_INS) || IS_INSN_TYPE (COP_BRANCH_INS))
	   && cur_arg_num == 2)
        {
          LONGLONG temp64 = 0;
          char ptr;
          char temp_str[30];
          unsigned int jump_value = 0;
          int BR_MASK = 0, BR_SIZE = 0;
          temp_str[0] = '\0';
          if (signflag)
            {
              temp_str[0] = '-';
              temp_str[1] = '\0';
            }
          strncat (temp_str, str, strlen (str));
	  temp64 = strtoll (temp_str, (char **) &ptr,0);

          if (temp64 % 2 != 0)
	    as_bad (_("Odd Offset in displacement in Instruction `%s'"),
		    ins_parse);

	  /* Determine the branch size.  */
          jump_value = (unsigned int)temp64 & 0xFFFFFFFF;
          if (((jump_value & 0xFFFFFF00) == 0xFFFFFF00)
	      || ((jump_value & 0xFFFFFF00) == 0x0))
            {
              BR_MASK = 0xFF;
              BR_SIZE = 8;
            }
          else
            if (((jump_value & 0xFF000000) == 0xFF000000)
		|| ((jump_value & 0xFF000000) == 0x0))
            {
              BR_MASK = 0xFFFFFF;
              BR_SIZE = 24;
            }
	  jump_value = jump_value >> 1;
          cur_arg->constant = jump_value & BR_MASK;
          cur_arg->size = BR_SIZE;
	  size_was_set = 1;
          cur_arg->signflag = signflag;
          input_line_pointer = save;
          return crx_ins->exp.X_op;
        }

      if (IS_INSN_TYPE (BRANCH_INS)
	  || IS_INSN_MNEMONIC ("bal")
	  || IS_INSN_TYPE (DCR_BRANCH_INS))
        {
          LONGLONG temp64 = 0;
          char ptr;
          char temp_str[30];
          unsigned int jump_value = 0;
          int BR_MASK = 0, BR_SIZE = 0;

          temp_str[0] = '\0';
          if (signflag)
            {
              temp_str[0] = '-';
              temp_str[1] = '\0';
            }
          strncat (temp_str, str, strlen (str));
	  temp64 = strtoll (temp_str, (char **) &ptr,0);

	  if (temp64 % 2 != 0)
	    as_bad (_("Odd Offset in displacement in Instruction `%s'"),
	    ins_parse);

	  /* Determine the branch size.  */
          jump_value = (unsigned int)temp64 & 0xFFFFFFFF;
          if (!IS_INSN_MNEMONIC ("bal") && !IS_INSN_TYPE (DCR_BRANCH_INS)
	      && (((jump_value & 0xFFFFFF00) == 0xFFFFFF00)
		  || ((jump_value & 0xFFFFFF00) == 0x0)))
            {
              BR_MASK = 0xFF;
              BR_SIZE = 8;
            }
          else if (((jump_value & 0xFFFF0000) == 0xFFFF0000)
		   || ((jump_value & 0xFFFF0000) == 0x0))
            {
              BR_MASK = 0xFFFF;
              BR_SIZE = 16;
            }
          else
            {
              BR_MASK = 0xFFFFFFFF;
              BR_SIZE = 32;
            }
	  jump_value = jump_value >> 1;
          cur_arg->constant = jump_value & BR_MASK;
          cur_arg->size = BR_SIZE;
	  size_was_set = 1;
          cur_arg->signflag = signflag;
          input_line_pointer = save;
          return crx_ins->exp.X_op;
        }
      /* Fix for movd $0xF12344, r0 -- signflag has to be set.  */
      if (constant_val < 0 && signflag != 1
          && !IS_INSN_TYPE (LD_STOR_INS) && !IS_INSN_TYPE (LD_STOR_INS_INC)
          && !IS_INSN_TYPE (CSTBIT_INS) && !IS_INSN_TYPE (STOR_IMM_INS)
          && !IS_INSN_TYPE (BRANCH_INS) && !IS_INSN_MNEMONIC ("bal"))
        {
          cur_arg->constant = ~(cur_arg->constant) + 1;
          signflag = 1;
        }
      /* For load/store instruction when the value is in the offset part.  */
      if (constant_val < 0 && signflag != 1
          && (IS_INSN_TYPE (LD_STOR_INS) || IS_INSN_TYPE (LD_STOR_INS_INC)
	      || IS_INSN_TYPE (CSTBIT_INS) || IS_INSN_TYPE (STOR_IMM_INS)))
        {
          if (cur_arg->type == arg_cr || cur_arg->type == arg_idxr)
            {
              cur_arg->constant = ~(cur_arg->constant) + 1;
              signflag = 1;
            }
        }
      if (signflag)
        {
          /* Signflag in never set in case of load store instructions
	     Mapping in case of only the arithinsn case.  */
          if ((cur_arg->constant != 1 && cur_arg->constant != 4)
	     || (!IS_INSN_TYPE (ARITH_INS)
		 && !IS_INSN_TYPE (ARITH_BYTE_INS)
		 && !IS_INSN_TYPE (CMPBR_INS)))
            {
              /* Counting the number of bits required to represent
	         the constant.  */
              cnt = 0;
              temp = cur_arg->constant - 1;
              while (temp > 0)
                {
                  temp >>= 1;
                  cnt++;
                }
              cur_arg->size = cnt + 1;
              cur_arg->constant = ~(cur_arg->constant) + 1;
              if (IS_INSN_TYPE (ARITH_INS) || IS_INSN_TYPE (ARITH_BYTE_INS))
                {
                  char ptr;
                  LONGLONG temp64;

		  temp64 = strtoull (str, (char **) &ptr, 0);
                  if (cnt < 4)
		    cur_arg->size = 5;

                  if (IS_INSN_TYPE (ARITH_INS))
                    {
                      if (cur_arg->size > 32
			  || (temp64 > ULONG_MAX))
			{
                          if (cur_arg->size > 32)
			    as_bad (_("In Instruction `%s': Immediate size is \
				    %lu bits cannot be accomodated"),
				    ins_parse, cnt + 1);

			  if (temp64 > ULONG_MAX)
			    as_bad (_("Value given more than 32 bits in \
				    Instruction `%s'"), ins_parse);
                        }
                    }
                  if (IS_INSN_TYPE (ARITH_BYTE_INS))
                    {
                      if (cur_arg->size > 16
			  || !((temp64 & 0xFFFF0000) == 0xFFFF0000
			       || (temp64 & 0xFFFF0000) == 0x0))
                        {
                          if (cur_arg->size > 16)
			    as_bad (_("In Instruction `%s': Immediate size is \
				    %lu bits cannot be accomodated"),
				    ins_parse, cnt + 1);

			  if (!((temp64 & 0xFFFF0000) == 0xFFFF0000
				|| (temp64 & 0xFFFF0000) == 0x0))
			    as_bad (_("Value given more than 16 bits in \
				    Instruction `%s'"), ins_parse);
                        }
                    }
                }
              if (IS_INSN_TYPE (LD_STOR_INS) && cur_arg->type == arg_cr)
                {
                  /* Cases handled ---
		     dispub4/dispuw4/dispud4 and for load store dispubwd4
		     is applicable only.  */
                  if (cur_arg->size <= 4)
                    cur_arg->size = 5;
                }
	      /* Argument number is checked to distinguish between
		 immediate and displacement in cmpbranch and bcopcond.  */
              if ((IS_INSN_TYPE (CMPBR_INS) || IS_INSN_TYPE (COP_BRANCH_INS))
		   && cur_arg_num == 2)
                {
                  if (cur_arg->size != 32)
                    cur_arg->constant >>= 1;
                }

	      mask_const (&cur_arg->constant, (int) cur_arg->size);
            }
        }
      else
        {
	  /* Argument number is checked to distinguish between
	     immediate and displacement in cmpbranch and bcopcond.  */
          if (((IS_INSN_TYPE (CMPBR_INS) || IS_INSN_TYPE (COP_BRANCH_INS))
		  && cur_arg_num == 2)
	        || IS_INSN_TYPE (BRANCH_NEQ_INS))
            {
              if (IS_INSN_TYPE (BRANCH_NEQ_INS))
                {
                  if (cur_arg->constant == 0)
		    as_bad (_("Instruction `%s' has Zero offset"), ins_parse);
                }

              if (cur_arg->constant % 2 != 0)
		as_bad (_("Instruction `%s' has odd offset"), ins_parse);

              if (IS_INSN_TYPE (BRANCH_NEQ_INS))
                {
                  if (cur_arg->constant > 32 || cur_arg->constant < 2)
		      as_bad (_("Instruction `%s' has illegal offset (%ld)"),
			      ins_parse, cur_arg->constant);

		  cur_arg->constant -= 2;
                }

              cur_arg->constant >>= 1;
              set_operand_size (crx_ins);
            }

	  /* Compare branch argument number zero to be compared -
	     mapped to cst4.  */
          if (IS_INSN_TYPE (CMPBR_INS) && cur_arg_num == 0)
            {
	      for (cst4_op = cst4_map; cst4_op < (cst4_map + cst4_maps); cst4_op++)
		{
		  if (cur_arg->constant == (unsigned int)cst4_op->value)
		    {
		      cur_arg->constant = cst4_op->binary;
		      is_cst4 = 1;
		      break;
		    }
		}
	      if (!is_cst4)
		as_bad (_("Instruction `%s' has invalid imm value as an \
			  operand"), ins_parse);
            }
        }
d679 2
a686 1
          /* Have to consider various cases here.  */
a687 1
	    /* 'load/stor <num>(reg)+'.  */
a690 1
	    /* 'stor imm' and '[stc]bit'.  */
a692 1
	    /* General load/stor instruction.  */
d694 2
a695 1
	    break;
a696 1
	  /* Index Mode 22 bits relocation.  */
d699 1
a700 3
	  /* Absolute types.  */
          /* Case for jumps...dx  types.  */
          /* For bal.  */
d710 1
a710 1
          else if (IS_INSN_TYPE (CMPBR_INS) || IS_INSN_TYPE (COP_BRANCH_INS))
d712 2
d715 1
a724 1
      cur_arg->size = (bfd_reloc_type_lookup (stdoutput, crx_ins->rtype))->bitsize;
d728 1
d732 2
a733 3
  input_line_pointer = save;
  cur_arg->signflag = signflag;
  return crx_ins->exp.X_op;
d896 2
a897 1
      goto set_size;
d907 2
a908 1
      goto set_size;
a951 26

/* Determine argument size.  */
set_size:
  switch (cur_arg->type)
    {
    /* The following are all registers, so set their size to REG_SIZE.  */
    case arg_r:
    case arg_copr:
    case arg_copsr:
    case arg_rbase:
      cur_arg->size = REG_SIZE;
      break;

    case arg_c:
    case arg_ic:
    case arg_sc:
    case arg_cr:
    case arg_icr:
    case arg_idxr:
      set_operand_size (crx_ins);
      break;

    default:
      as_bad (_("Illegal argument type in instruction `%s'"), ins_parse);
      break;
    }
d1088 13
a1100 1
  /* Handle 'excp'/'cinv' */
a1104 1
      insn->arg[0].size = 4;
d1107 1
d1218 1
a1218 3
/* Routine used to get the binary-string equivalent of a integer constant
   which currently require currbits to represent itself to be extended to
   nbits.  */
d1220 2
a1221 2
static unsigned long int
getconstant (unsigned long int x, int nbits)
a1222 21
  int cnt = 0;
  unsigned long int temp = x;

  while (temp > 0)
    {
      temp >>= 1;
      cnt++;
    }

  /* Escape sequence to next 16bit immediate.  */
  if (cnt > nbits)
    as_bad (_("Value `%ld' truncated to fit `%d' bits in instruction `%s'"),
	    x, cnt, ins_parse);
  else
    {
      if (signflag)
	x |= SET_BITS_MASK (cnt, nbits - cnt);
      else
	x &= CLEAR_BITS_MASK (cnt, nbits - cnt);
    }

d1342 2
a1343 3
      if ((instruction->flags & DISPU4MAP) && cst4flag)
	output_opcode[0] |= (getconstant (arg->constant, nbits)
			     << (shift + REG_SIZE));
d1368 117
a1484 9
/* Assemble a single instruction :
   Instruction has been parsed and all operand values set appropriately.
   Algorithm for assembling -
   For instruction to be assembled:
    Step 1: Find instruction in the array crx_instruction with same mnemonic.
    Step 2: Find instruction with same operand types.
    Step 3: If (size_of_operands) match then done, else increment the
	    array_index and goto Step3.
    Step 4: Cannot assemble
d1490 6
a1495 10
  /* Argument type of each operand in the instruction we are looking for.  */
  argtype atyp[MAX_OPERANDS];
  /* Argument type of each operand in the current instruction.  */
  argtype atyp_act[MAX_OPERANDS];
  /* Size (in bits) of each operand in the instruction we are looking for.  */
  int bits[MAX_OPERANDS];
  /* Size (in bits) of each operand in the current instruction.  */
  int bits_act[MAX_OPERANDS];
  /* Location (in bits) of each operand in the current instruction.  */
  int shift_act[MAX_OPERANDS];
d1498 1
d1500 22
a1521 9
  int done_flag = 0;
  int dispu4map_type = 0;
  int changed_already = 0;
  unsigned int temp_value = 0;
  int instrtype, i;
  /* A pointer to the argument's constant value.  */
  unsigned long int *cons;
  /* Pointer to loop over all cst4_map entries.  */
  const cst4_entry *cst4_op;
d1523 1
a1523 1
  /* Instruction has no operands -> copy only the constant opcode.   */
a1529 19
  /* Find instruction with same number of operands.  */
  while (get_number_of_operands () != insn->nargs
         && IS_INSN_MNEMONIC (mnemonic))
    instruction++;

  if (!IS_INSN_MNEMONIC (mnemonic))
    return 0;

  /* Initialize argument type and size of each given operand.  */
  for (i = 0; i < insn->nargs; i++)
    {
      atyp[i] = insn->arg[i].type;
      bits[i] = insn->arg[i].size;
    }

  /* Initialize argument type and size of each operand in current inst.  */
  GET_ACTUAL_TYPE;
  GET_ACTUAL_SIZE;

d1538 2
a1539 1
  while (match != 1
d1547 11
a1557 1
      /* Check for argement type compatibility.  */
d1560 8
a1567 8
          if (atyp_act[i] == atyp[i])
	    done_flag = 1;
          else
            {
              done_flag = 0;
              break;
            }
        }
d1569 1
a1569 1
      if (done_flag)
d1571 23
a1593 8
	  for (i = 0; i < insn->nargs; i++)
	    {
	      if ((get_flags (instruction->operands[i].op_type) & OPERAND_UNSIGNED)
		  && (insn->arg[i].signflag))
		    {
		      done_flag = 0;
		      break;
		    }
d1595 6
d1602 1
d1604 3
a1606 23
      if (done_flag == 0)
        {
	  /* Try again with next instruction.  */
          instruction++;
	  GET_ACTUAL_TYPE;
	  GET_ACTUAL_SIZE;
          continue;
        }
      else
        {
          /* Check for size compatibility.  */
          for (i = 0; i < insn->nargs; i++)
            {
              if (bits[i] > bits_act[i])
                {
		  /* Actual size is too small - try again.  */
                  done_flag = 0;
                  instruction++;
	  	  GET_ACTUAL_TYPE;
		  GET_ACTUAL_SIZE;
                  break;
                }
            }
d1608 4
a1611 1
        }
d1613 34
a1646 6
      if (done_flag == 1)
        {
	  /* Full match is found.  */
          match = 1;
          break;
        }
a1647 4

  if (match == 0)
    /* We haven't found a match - instruction can't be assembled.  */
    return 0;
d1649 1
a1649 1
    /* Full match - print the final image.  */
d1651 22
a1672 10
      /* If the post-increment address mode is used and the load/store 
	 source register is the same as rbase, the result of the 
	 instruction is undefined.  */
      if (IS_INSN_TYPE (LD_STOR_INS_INC))
	{
	  /* Enough to verify that one of the arguments is a simple reg.  */
	  if ((insn->arg[0].type == arg_r) || (insn->arg[1].type == arg_r))
	    if (insn->arg[0].r == insn->arg[1].r)
	      as_bad (_("Same src/dest register is used (`r%d'), result is undefined"), 
		       insn->arg[0].r);
d1675 4
a1678 3
      /* Optimization: Omit a zero displacement in bit operations, 
	 saving 2-byte encoding space (e.g., 'cbitw $8, 0(r1)').  */
      if (IS_INSN_TYPE (CSTBIT_INS) && !relocatable)
d1680 3
a1682 6
          if ((instruction->operands[1].op_type == rbase_disps12)
	       && (insn->arg[1].constant == 0))
                {
                  instruction--;
		  GET_ACTUAL_SIZE;
                }
d1684 1
d1686 2
a1687 7
      /* Some instruction assume the stack pointer as rptr operand.
	 Issue an error when the register to be loaded is also SP.  */
      if (instruction->flags & NO_SP)
        {
	  if (getreg_image (insn->arg[0].r) == getreg_image (sp))
	    as_bad (_("`%s' has undefined result"), ins_parse);
	}
d1689 2
a1690 8
      /* If the rptr register is specified as one of the registers to be loaded, 
	 the final contents of rptr are undefined. Thus, we issue an error.  */
      if (instruction->flags & NO_RPTR)
        {
	  if ((1 << getreg_image (insn->arg[0].r)) & insn->arg[1].constant)
	    as_bad (_("Same src/dest register is used (`r%d'), result is undefined"), 
	     getreg_image (insn->arg[0].r));
	}
d1692 14
a1705 57
      /* Handle positive constants.  */
      if (!signflag)
        {
          if ((instruction->flags & DISPU4MAP) && !relocatable)
            {
              /* Get the map type of the instruction.  */
              instrtype = instruction->flags & REVERSE_MATCH ? 0 : 1;
	      cons = &insn->arg[instrtype].constant;
              dispu4map_type = instruction->flags & DISPU4MAP;

	      switch (dispu4map_type)
		{
		case DISPUB4:
		  /* 14 and 15 are reserved escape sequences of dispub4.  */
                  if (*cons == 14 || *cons == 15)
                    {
                      instruction++;
		      GET_ACTUAL_SIZE;
                    }
		  break;

		case DISPUW4:
		  /* Mapping has to be done.  */
		  if (*cons <= 15 && *cons % 2 != 0)
                    {
                      instruction++;
		      GET_ACTUAL_SIZE;
                    }
                  else if (*cons > 15 && *cons < 27 && *cons % 2 == 0)
                    {
                      instruction--;
		      GET_ACTUAL_SIZE;
                    }
		  if (*cons < 27 && *cons % 2 == 0)
		    *cons /= 2;
		  break;

		case DISPUD4:
                  /* Mapping has to be done.  */
                  if (*cons <= 15 && *cons % 4 != 0)
                    {
                      instruction++;
		      GET_ACTUAL_SIZE;
                    }
                  else if (*cons > 15 && *cons < 53 && *cons % 4 == 0)
                    {
                      instruction--;
		      GET_ACTUAL_SIZE;
                    }
		  if (*cons < 53 && *cons % 4 == 0)
		    *cons /= 4;
		  break;
		default:
		  as_bad (_("Invalid DISPU4 type"));
		  break;
	      }
            }
d1707 7
a1713 37
	  /* Check whether a cst4 mapping has to be done.  */
	  if ((instruction->flags & CST4MAP) && !relocatable)
	    {
	      /* 'const' equals reserved escape sequences -->>
		 represent as i16.  */
	      if (insn->arg[0].constant == ESC_16
		  || insn->arg[0].constant == ESC_32)
		{
		  instruction++;
		  GET_ACTUAL_SIZE;
		}
	      else
		{
		  /* Loop over cst4_map entries.  */
		  for (cst4_op = cst4_map; cst4_op < (cst4_map + cst4_maps);
		       cst4_op++)
		    {
		      /* 'const' equals a binary, which is already mapped
			 by a different value -->> represent as i16.  */
		      if (insn->arg[0].constant == (unsigned int)cst4_op->binary
			  && cst4_op->binary != cst4_op->value)
			{
			  instruction++;
			  GET_ACTUAL_SIZE;
			}
		      /* 'const' equals a value bigger than 16 -->> map to
			 its binary and represent as cst4.  */
		      else if (insn->arg[0].constant == (unsigned int)cst4_op->value
			       && insn->arg[0].constant >= 16)
			{
			  instruction--;
			  insn->arg[0].constant = cst4_op->binary;
			  GET_ACTUAL_SIZE;
			}
		    }
		}
	    }
d1715 9
a1723 42
	  /* Special check for 'addub 0, r0' instruction -
	     The opcode '0000 0000 0000 0000' is not allowed.  */
          if (IS_INSN_MNEMONIC ("addub"))
            {
              if ((instruction->operands[0].op_type == cst4)
		  && instruction->operands[1].op_type == regr)
                {
                  if (insn->arg[0].constant == 0 && insn->arg[1].r == r0)
		    instruction++;
                }
            }
          if ((IS_INSN_TYPE (LD_STOR_INS) || IS_INSN_TYPE (CSTBIT_INS)
	       || IS_INSN_TYPE (STOR_IMM_INS)) & !relocatable)
            {
	      instrtype = instruction->flags & REVERSE_MATCH ? 0 : 1;
              changed_already = 0;
              /* Convert 32 bits accesses to 16 bits accesses.  */
              if (instruction->operands[instrtype].op_type == abs32)
                {
                  if ((insn->arg[instrtype].constant & 0xFFFF0000) == 0xFFFF0000)
                    {
                      instruction--;
                      insn->arg[instrtype].constant =
                        insn->arg[instrtype].constant & 0xFFFF;
                      insn->arg[instrtype].size = 16;
                      changed_already = 1;
		      GET_ACTUAL_SIZE;
                    }
                }
              /* Convert 16 bits accesses to 32 bits accesses.  */
              if (instruction->operands[instrtype].op_type == abs16
                  && changed_already != 1)
                {
                  instruction++;
                  insn->arg[instrtype].constant =
                    insn->arg[instrtype].constant & 0xFFFF;
                  insn->arg[instrtype].size = 32;
		  GET_ACTUAL_SIZE;
                }
              changed_already = 0;
            }
        }
d1725 3
a1727 19
      for (i = 0; i < insn->nargs; i++)
        {
	  /* Mark a CST4 argument, if exists.  */
	  if (get_flags (instruction->operands[i].op_type) & OPERAND_CST4)
	    cst4flag = 1;

	  /* Handle reserved escape sequences.  */
	  if ((get_flags (instruction->operands[i].op_type) & OPERAND_ESC)
	      && !relocatable)
            {
	      /* 0x7e and 0x7f are reserved escape sequences of dispe9.  */
	      if (insn->arg[i].constant == 0x7e || insn->arg[i].constant == 0x7f)
                {
		  /* Use a disps17 for these values.  */
                  instruction++;
		  GET_ACTUAL_SIZE;
                }
            }
	}
d1729 4
a1732 2
      /* First, copy the instruction's opcode.  */
      output_opcode[0] = BIN (instruction->match, instruction->match_bits);
d1734 6
a1739 2
      /* Swap the argument values in case bcop instructions.  */
      if (IS_INSN_TYPE (COP_BRANCH_INS))
d1741 5
a1745 3
          temp_value = insn->arg[0].constant;
          insn->arg[0].constant = insn->arg[1].constant;
          insn->arg[1].constant = temp_value;
d1747 1
d1749 11
a1759 7
      for (i = 0; i < insn->nargs; i++)
        {
	  shift_act[i] = instruction->operands[i].shift;
          signflag = insn->arg[i].signflag;
          cur_arg_num = i;
          print_operand (bits_act[i], shift_act[i], &insn->arg[i]);
        }
d1762 1
a1762 1
  return 1;
d2018 1
a2018 1
  reset_vars (op, &crx_ins);
d2037 2
a2038 6
  if (NO_OPERANDS_INST (op))
    /* Handle instructions with no operands.  */
    crx_ins.nargs = 0;
  else
    /* Parse the instruction's operands.  */
    parse_insn (&crx_ins, param);
d2040 1
a2040 1
  /* Assemble the instruction.  */
d2042 1
a2042 4
    {
      as_bad (_("Illegal operands in instruction : `%s'"), ins_parse);
      return;
    }
@


1.10
log
@2004-11-05  Tomer Levi  <Tomer.Levi@@nsc.com>

	* config/tc-crx.c: Rename argument types.
 	(processing_arg_number): Rename to 'cur_arg_num'.
	(get_number_of_bits): Rename to 'set_operand_size'.
	(get_operandtype): Rename to 'parse_operand', totally rewrite.
	(set_cons_rparams): Rename to 'set_operand', totally rewrite.
	(set_indexmode_parameters): Remove function, integrate its code into 'set_operand'.
	(set_operand_size): Get rid of 'Operand Number' function parameter - use global variable 'cur_arg_num' instead.
	Use a local 'argument' pointer to reference the current argument.
	(parse_operand): Likewise.
	(set_operand): Likewise.
	(process_label_constant): Likewise.
@
text
@d1232 1
a1232 1
      process_label_constant (operandS, crx_ins/*, op_num*/);
d1245 1
a1245 1
      process_label_constant (operandS, crx_ins/*, op_num*/);
d2385 1
d2447 7
@


1.9
log
@2004-10-28  Tomer Levi  <Tomer.Levi@@nsc.com>

* config/tc-crx.c (getreg_image): Bug fix, a return value was mistakenly ommited from CRX_C_REGTYPE and CRX_CS_REGTYPE cases.
@
text
@d102 1
a102 1
int processing_arg_number;
d161 1
a161 1
static void    get_number_of_bits       (ins *, int);
d166 1
a166 1
static void    get_operandtype	        (char *, int, ins *);
d179 2
a180 3
static int     process_label_constant   (char *, ins *, int);
static void    set_indexmode_parameters (char *, ins *, int);
static void    set_cons_rparams	        (char *, ins *, int);
d292 1
a292 2
  processing_arg_number = relocatable = size_was_set
    = signflag = cst4flag = 0;
d674 1
a674 1
/* Get the number of bits corresponding to a constant -
d678 1
a678 1
get_number_of_bits (ins * crx_ins, int op_num)
a680 1
  unsigned long int temp = crx_ins->arg[op_num].constant;
d682 2
d702 1
a702 1
          crx_ins->arg[op_num].size = 32;
d712 1
a712 1
      if (!signflag && crx_ins->arg[op_num].type == arg_icr)
d716 1
a716 1
              crx_ins->arg[op_num].size = 22;
d727 1
a727 1
      if (!signflag && crx_ins->arg[op_num].type == arg_cr)
d731 1
a731 1
              crx_ins->arg[op_num].size = 32;
d744 1
a744 1
      if (!signflag && crx_ins->arg[op_num].type == arg_cr)
d748 1
a748 1
              crx_ins->arg[op_num].size = 28;
d765 1
a765 1
      || ((IS_INSN_TYPE (CMPBR_INS) && op_num == 0))))
d769 1
a769 1
	  if (crx_ins->arg[op_num].constant == (unsigned int)(-cst4_op->value))
d771 3
a773 3
	      crx_ins->arg[op_num].size = 4;
	      crx_ins->arg[op_num].constant = cst4_op->binary;
	      crx_ins->arg[op_num].signflag = 0;
d784 2
a785 2
          if (crx_ins->arg[op_num].constant <= 0xffff)
            crx_ins->arg[op_num].size = 16;
d788 1
a788 1
            crx_ins->arg[op_num].size = 18;
d791 1
a791 1
        crx_ins->arg[op_num].size = 16;
d798 1
a798 1
      if (crx_ins->arg[op_num].constant <= 0xffff && !relocatable)
d800 1
a800 1
          crx_ins->arg[op_num].size = 16;
d804 1
a804 1
      if (crx_ins->arg[op_num].constant < 0xffffffff || relocatable)
d806 1
a806 1
          crx_ins->arg[op_num].size = 32;
d809 1
a809 1
      crx_ins->arg[op_num].size = 33;
d817 1
a817 1
    crx_ins->arg[op_num].size = cnt_bits;
d834 1
a834 1
/* Handle the constants -immediate/absolute values and
d838 1
a838 1
process_label_constant (char *str, ins * crx_ins, int number)
d843 1
a843 1
  int is_cst4=0;
d845 2
d876 1
a876 2
      crx_ins->arg[number].constant = crx_ins->exp.X_add_number;
      constant_val = crx_ins->exp.X_add_number;
d878 1
a878 1
	   && number == 2)
d914 2
a915 2
          crx_ins->arg[number].constant = jump_value & BR_MASK;
          crx_ins->arg[number].size = BR_SIZE;
d917 1
a917 1
          crx_ins->arg[number].signflag = signflag;
d966 2
a967 2
          crx_ins->arg[number].constant = jump_value & BR_MASK;
          crx_ins->arg[number].size = BR_SIZE;
d969 1
a969 1
          crx_ins->arg[number].signflag = signflag;
d979 1
a979 2
          crx_ins->arg[number].constant =
            ~(crx_ins->arg[number].constant) + 1;
d987 1
a987 2
          if (crx_ins->arg[number].type == arg_cr
              || crx_ins->arg[number].type == arg_icr)
d989 1
a989 2
              crx_ins->arg[number].constant =
                ~(crx_ins->arg[number].constant) + 1;
d997 1
a997 2
          if ((crx_ins->arg[number].constant != 1
               && crx_ins->arg[number].constant != 4)
d1005 1
a1005 1
              temp = crx_ins->arg[number].constant - 1;
d1011 2
a1012 3
              crx_ins->arg[number].size = cnt + 1;
              crx_ins->arg[number].constant =
                ~(crx_ins->arg[number].constant) + 1;
d1020 1
a1020 1
		    crx_ins->arg[number].size = 5;
d1024 1
a1024 1
                      if (crx_ins->arg[number].size > 32
d1027 1
a1027 1
                          if (crx_ins->arg[number].size > 32)
d1039 1
a1039 1
                      if (crx_ins->arg[number].size > 16
d1043 1
a1043 1
                          if (crx_ins->arg[number].size > 16)
d1055 1
a1055 1
              if (IS_INSN_TYPE (LD_STOR_INS) && crx_ins->arg[number].type == arg_cr)
d1060 2
a1061 2
                  if (crx_ins->arg[number].size <= 4)
                    crx_ins->arg[number].size = 5;
d1066 1
a1066 1
		   && number == 2)
d1068 2
a1069 3
                  if (crx_ins->arg[number].size != 32)
                    crx_ins->arg[number].constant =
                      crx_ins->arg[number].constant >> 1;
d1072 1
a1072 2
	      mask_const (&crx_ins->arg[number].constant,
                          (int) crx_ins->arg[number].size);
d1080 1
a1080 1
		  && number == 2)
d1085 1
a1085 1
                  if (crx_ins->arg[number].constant == 0)
d1089 1
a1089 1
              if (crx_ins->arg[number].constant % 2 != 0)
d1094 1
a1094 2
                  if (crx_ins->arg[number].constant > 32
                      || crx_ins->arg[number].constant < 2)
d1096 1
a1096 1
			      ins_parse, crx_ins->arg[number].constant);
d1098 1
a1098 1
		  crx_ins->arg[number].constant -= 2;
d1101 2
a1102 3
              crx_ins->arg[number].constant =
                crx_ins->arg[number].constant >> 1;
              get_number_of_bits (crx_ins, number);
d1107 1
a1107 1
          if (IS_INSN_TYPE (CMPBR_INS) && number == 0)
d1111 1
a1111 1
		  if (crx_ins->arg[number].constant == (unsigned int)cst4_op->value)
d1113 1
a1113 1
		      crx_ins->arg[number].constant = cst4_op->binary;
a1126 1
      crx_ins->arg[number].constant = 0;
d1130 1
a1130 1
      switch (crx_ins->arg[number].type)
d1145 1
a1145 1
	case arg_icr:
a1165 1
	case arg_dc:
d1174 1
a1174 1
      crx_ins->arg[number].size = (bfd_reloc_type_lookup (stdoutput, crx_ins->rtype))->bitsize;
d1182 1
a1182 1
  crx_ins->arg[number].signflag = signflag;
d1204 7
a1210 2
/* This is used to set the index mode parameters. Used to set the attributes of
   an indexmode type of operand. op_num is the operand number.  */
d1213 1
a1213 1
set_indexmode_parameters (char *operand, ins * crx_ins, int op_num)
d1215 45
a1259 7
  char address_str[30];
  char scale_str[MAX_OPERANDS];
  int scale_cnt = 0;
  char reg_name[MAX_REGNAME_LEN];
  char regindex_name[MAX_REGNAME_LEN];
  int i = 0;
  int reg_counter = 0, addr_cnt = 0, temp_int_val = 0;
d1261 13
a1273 19
  switch (crx_ins->arg[op_num].type)
    {
    case arg_icr:
      while (operand[i] != '(')
        {
          address_str[addr_cnt++] = operand[i];
          i++;
        }
      address_str[addr_cnt] = '\0';
      process_label_constant (address_str, crx_ins, op_num);
      i++;
      reg_counter = 0;
      while (operand[i] != ',' && operand[i] != ' ')
        {
          reg_name[reg_counter++] = operand[i];
          i++;
        }
      reg_name[reg_counter] = '\0';
      if ((crx_ins->arg[op_num].r = get_register (reg_name)) == nullregister)
d1275 12
a1286 1
		reg_name, ins_parse);
d1288 1
a1288 14
      i++;
      while (operand[i] == ' ')
	i++;

      reg_counter = 0;
      while (operand[i] != ')' && operand[i] != ',')
        {
          regindex_name[reg_counter++] = operand[i];
          i++;
        }
      regindex_name[reg_counter] = '\0';
      reg_counter = 0;
      if ((crx_ins->arg[op_num].i_r = get_register (regindex_name))
	    == nullregister)
d1290 1
a1290 5
		regindex_name, ins_parse);

      /* Setting the scale parameters.  */
      while (operand[i] == ' ')
	i++;
d1292 8
a1299 2
      if (operand[i] == ')')
	crx_ins->arg[op_num].scale = 0;
d1302 16
a1317 2
          if (operand[i] == ',')
            i++;
d1319 1
a1319 23
          while (operand[i] != ' ' && operand[i] != ')')
            {
              scale_str[scale_cnt++] = operand[i];
              i++;
            }

          scale_str[scale_cnt] = '\0';
          /* Preprocess the scale string.  */
          if (strstr (scale_str, "0x") != NULL
              || strstr (scale_str, "0X") != NULL)
            {
              sscanf (scale_str, "%x", &temp_int_val);
	      memset (&scale_str, '\0', sizeof (scale_str));
              sprintf (scale_str, "%d", temp_int_val);
            }
          /* Preprocess over.  */
          temp_int_val = atoi (scale_str);

          if (temp_int_val != 1 && temp_int_val != 2
              && temp_int_val != 4 && temp_int_val != 8)
	    as_bad (_("Illegal Scale - `%s'"), scale_str);

	  crx_ins->arg[op_num].scale = exponent2scale (temp_int_val);
d1322 1
d1328 3
a1330 5
/* Parsing the operands of types
   - constants
   - (rbase)
   - offset(rbase)
   - offset(rbase)+ (post-increment mode).  */
d1333 1
a1333 1
set_cons_rparams (char *operand, ins * crx_ins, int op_num)
d1335 5
a1339 37
  int i = 0, reg_count = 0;
  char reg_name[MAX_REGNAME_LEN];
  int change_flag = 0;

  if (crx_ins->arg[op_num].type == arg_dc)
    change_flag = 1;

  switch (crx_ins->arg[op_num].type)
    {
    case arg_sc: /* Case *+347.  */
    case arg_dc: /* Case $18.  */
      i++;
    case arg_c:/* Case where its a simple constant.  */
      process_label_constant (operand + i, crx_ins, op_num);
      crx_ins->arg[op_num].type = arg_c;
      break;
    case arg_dcr: /* Case $9(r13).  */
      operand++;
    case arg_cr: /* Case 9(r13.   */
      while (operand[i] != '(')
	i++;
      operand[i] = '\0';
      process_label_constant (operand, crx_ins, op_num);
      operand[i] = '(';
    case arg_rbase:
      i++;
      reg_count = 0;
      while (operand[i] != ')')
        {
          reg_name[reg_count] = operand[i];
          i++;
          reg_count++;
        }
      reg_name[reg_count] = '\0';
      if ((crx_ins->arg[op_num].r = get_register (reg_name)) == nullregister)
	as_bad (_("Illegal register `%s' in Instruction `%s'"),
		reg_name, ins_parse);
d1341 6
a1346 5
      if (crx_ins->arg[op_num].type != arg_rbase)
	crx_ins->arg[op_num].type = arg_cr;
      break;
    default:
      break;
a1347 3
  if (change_flag == 1)
    crx_ins->arg[op_num].type = arg_ic;
}
d1349 9
a1357 9
/* This is used to get the operand attributes -
   operand  - current operand to be used
   number - operand number
   crx_ins - current assembled instruction.  */

static void
get_operandtype (char *operand, int number, ins * crx_ins)
{
  int ret_val;
d1359 1
a1361 53
    /* When it is a register.  */
    case 'r':
    case 'c':
    case 'i':
    case 'u':
    case 's':
    case 'p':
    case 'l':
    case 'h':
      /* Check whether this is a general processor register.  */
      ret_val = get_register (operand);
      if (ret_val != nullregister)
        {
          crx_ins->arg[number].type = arg_r;
          crx_ins->arg[number].r = ret_val;
          crx_ins->arg[number].size = REG_SIZE;
        }
      else
        {
	  /* Check whether this is a core [special] coprocessor register.  */
          ret_val = get_copregister (operand);
          if (ret_val != nullcopregister)
            {
              crx_ins->arg[number].type = arg_copr;
              if (ret_val >= cs0)
		crx_ins->arg[number].type = arg_copsr;
              crx_ins->arg[number].cr = ret_val;
              crx_ins->arg[number].size = REG_SIZE;
            }
          else
            {
              if (strchr (operand, '(') != NULL)
                {
                  if (strchr (operand, ',') != NULL
                      && (strchr (operand, ',') > strchr (operand, '(')))
                    {
                      crx_ins->arg[number].type = arg_icr;
                      crx_ins->arg[number].constant = 0;
                      set_indexmode_parameters (operand, crx_ins, number);
                      get_number_of_bits (crx_ins, number);
                      return;
                    }
                  else
		    crx_ins->arg[number].type = arg_cr;
                }
              else
		crx_ins->arg[number].type = arg_c;
              crx_ins->arg[number].constant = 0;
              set_cons_rparams (operand, crx_ins, number);
              get_number_of_bits (crx_ins, number);
            }
        }
      break;
d1364 1
a1364 1
	crx_ins->arg[number].type = arg_dcr;
d1366 7
a1372 4
        crx_ins->arg[number].type = arg_dc;
      crx_ins->arg[number].constant = 0;
      set_cons_rparams (operand, crx_ins, number);
      get_number_of_bits (crx_ins, number);
d1376 2
a1377 3
      crx_ins->arg[number].type = arg_rbase;
      set_cons_rparams (operand, crx_ins, number);
      crx_ins->arg[number].size = REG_SIZE;
d1379 10
a1388 32
    case '*':
      crx_ins->arg[number].type = arg_sc;
      crx_ins->arg[number].constant = 0;
      set_cons_rparams (operand, crx_ins, number);
      get_number_of_bits (crx_ins, number);
      break;
    case '+':
    case '-':
    case '0':
    case '1':
    case '2':
    case '3':
    case '4':
    case '5':
    case '6':
    case '7':
    case '8':
    case '9':
      if (strchr (operand, '(') != NULL)
        {
          if (strchr (operand, ',') != NULL
              && (strchr (operand, ',') > strchr (operand, '(')))
            {
              crx_ins->arg[number].type = arg_icr;
              crx_ins->arg[number].constant = 0;
              set_indexmode_parameters (operand, crx_ins, number);
              get_number_of_bits (crx_ins, number);
              return;
            }
          else
	    crx_ins->arg[number].type = arg_cr;
        }
d1390 21
a1410 4
	crx_ins->arg[number].type = arg_c;
      crx_ins->arg[number].constant = 0;
      set_cons_rparams (operand, crx_ins, number);
      get_number_of_bits (crx_ins, number);
d1412 10
d1423 1
a1423 19
      if (strchr (operand, '(') != NULL)
        {
          if (strchr (operand, ',') != NULL
              && (strchr (operand, ',') > strchr (operand, '(')))
            {
              crx_ins->arg[number].type = arg_icr;
              crx_ins->arg[number].constant = 0;
              set_indexmode_parameters (operand, crx_ins, number);
              get_number_of_bits (crx_ins, number);
              return;
            }
          else
	    crx_ins->arg[number].type = arg_cr;
        }
      else
	crx_ins->arg[number].type = arg_c;
      crx_ins->arg[number].constant = 0;
      set_cons_rparams (operand, crx_ins, number);
      get_number_of_bits (crx_ins, number);
d1428 2
a1429 2
/* Operands are parsed over here, separated into various operands. Each operand
   is then analyzed to fillup the fields in the crx_ins data structure.  */
d1495 1
a1495 1
  /* Now to recongnize the operand types.  */
d1498 2
a1499 1
      get_operandtype (operand[op_num], op_num, crx_ins);
d1623 2
a1624 2
  if (((IS_INSN_MNEMONIC ("mtpr")) && (processing_arg_number == 1))
      || ((IS_INSN_MNEMONIC ("mfpr")) && (processing_arg_number == 0)) )
d1808 1
a1808 5
    case arg_ic:
      print_constant (nbits, shift, arg);
      break;

    case arg_icr:
d1816 2
a1836 4
    case arg_c:
      print_constant (nbits, shift, arg);
      break;

d1879 1
a1879 1
  int ins_type;
d2213 1
a2213 1
          processing_arg_number = i;
@


1.8
log
@* config/tc-crx.c: Remove global variable 'post_inc_mode'.
(get_flags): New function.
(get_number_of_bits): Edit comments, update numeric values to supported sizes.
(process_label_constant): Don't support the colon format (SYMBOL:[s|m|l]).
(set_cons_rparams): Support argument type 'arg_rbase'.
(get_operandtype): Bug fix in 'rbase' operand type parsing.
(handle_LoadStor): Bug fix, first handle post-increment mode.
(getreg_image): Remove redundant code, update according to latest CRX spec.
(print_constant): Bug fix relate to 3-word instructions.
(assemble_insn): Bug fix, when matching instructions, verify also instruction type (not only mnemonic).
Add various error checking.
(preprocess_reglist): Support HI/LO and user registers.
@
text
@d1749 1
@


1.7
log
@1. Check unsigned immediate operands validity. 2. Update coprocessor id to be unsigned immediate.
@
text
@a100 2
/* Nonzero means instruction is represented in post increment mode.  */
int post_inc_mode;
d164 1
d208 11
d294 1
a294 1
    = signflag = post_inc_mode = cst4flag = 0;
d611 1
a611 2
  crx_inst_hash = hash_new ();
  if (crx_inst_hash == NULL)
d613 1
a613 1

d638 2
a639 1
  reg_hash = hash_new ();
d656 2
a657 1
  copreg_hash = hash_new ();
d697 2
d703 1
a703 1
          crx_ins->arg[op_num].size = 17;
d707 2
a708 2
  /* If a signed +ve is represented in 6 bits then we have to represent
     it in 22 bits in case of the index mode of addressing.  */
a709 1
      || IS_INSN_TYPE (LD_STOR_INS_INC)
d717 1
a717 1
              crx_ins->arg[op_num].size = 7;
d724 2
a725 4
  /* If a signed +ve is represnted in 16 bits in case of load/stor disp16
     then change it to 17 bits.
     If a signed +ve is represnted in 12 bits in post increment instruction
     increase it to 13 bits.  */
d732 1
a732 1
              crx_ins->arg[op_num].size = 17;
d739 2
a740 1

d749 1
a749 1
              crx_ins->arg[op_num].size = 13;
d813 1
a845 2
  int cmp_br_type_flag = 0, i;
  int br_type_flag = 0;
a856 29
  /* Preprocessing for cmpbr instruction and getting the size flag.  */
  if (strstr (str, ":s") != NULL && (IS_INSN_TYPE (CMPBR_INS)
      || IS_INSN_TYPE (COP_BRANCH_INS)))
    cmp_br_type_flag = 8;

  if (strstr (str, ":l") != NULL && (IS_INSN_TYPE (CMPBR_INS)
      || IS_INSN_TYPE (COP_BRANCH_INS)))
    cmp_br_type_flag = 24;

  /* Branch instruction preprocessing.  */
  if (IS_INSN_TYPE (BRANCH_INS))
    {
      if (strstr (str, ":s") != NULL)
	br_type_flag = 8;
      else if (strstr (str, ":m") != NULL)
	br_type_flag = 16;
      else if (strstr (str, ":l") != NULL)
	br_type_flag = 32;
    }
  /* Making the label cleared for processing removing :lms etc from labels.  */
  if (cmp_br_type_flag != 0 || br_type_flag != 0)
    {
      i = 0;
      while (str[i] != ':')
        {
          i++;
        }
      str[i] = '\0';
    }
d1060 1
a1060 2
              if (IS_INSN_TYPE (LD_STOR_INS) && crx_ins->arg[number].type == arg_cr
                  && !post_inc_mode)
d1143 1
a1143 1
          /* Have to consider various cases here --load/stor++[bwd] rbase, reg.  */
d1145 1
d1149 1
a1149 1
	    /* 'stor[bwd] imm' and '[stc]bit[bwd]'.  */
d1152 1
a1152 1
	    /* General load store instruction.  */
d1166 1
a1166 19
            {
	      crx_ins->rtype = BFD_RELOC_CRX_REL8;

	      /* Overriding the above by the br_type_flag set above.  */
	      switch (br_type_flag)
		{
		default:
		  break;
		case 8:
		  crx_ins->rtype = BFD_RELOC_CRX_REL8;
		  break;
		case 16:
		  crx_ins->rtype = BFD_RELOC_CRX_REL16;
		  break;
		case 32:
		  crx_ins->rtype = BFD_RELOC_CRX_REL32;
		  break;
		}
            }
d1173 1
a1173 6
            {
              if (cmp_br_type_flag == 24)
		crx_ins->rtype = BFD_RELOC_CRX_REL24;
              else
		crx_ins->rtype = BFD_RELOC_CRX_REL8_CMP;
            }
d1311 1
a1311 1
   - rbase -> (register)
d1313 1
a1313 1
   - offset(rbase)+ - post increment mode.  */
d1342 1
d1356 2
a1357 5
      crx_ins->arg[op_num].type = arg_cr;
      /* Post increment is represented in assembly as offset (register)+.  */
      if (strstr (operand + i, "+") != NULL)
	/* There is a plus after the ')'.  */
	post_inc_mode = 1;
a1374 1
  char temp_operand[30];
d1442 3
a1444 26
      /* Augmenting a zero in front of an operand -- won't work for tbit/sbit.  */
      strcpy (temp_operand, "0");
      strcat (temp_operand, operand);
      if (strchr (temp_operand, ',') != NULL
          && (strchr (temp_operand, ',') > strchr (temp_operand, '(')))
        {
          crx_ins->arg[number].type = arg_icr;
          crx_ins->arg[number].constant = 0;
          set_indexmode_parameters (temp_operand, crx_ins, number);
          get_number_of_bits (crx_ins, number);
          return;
        }
      else
        {
          crx_ins->arg[number].type = arg_cr;
          crx_ins->arg[number].constant = 0;
          set_cons_rparams (temp_operand, crx_ins, number);
          get_number_of_bits (crx_ins, number);
          if ((! strneq (instruction->mnemonic, "load", 4))
              && (! strneq (instruction->mnemonic, "stor", 4)))
            {
              crx_ins->arg[number].type = arg_rbase;
              crx_ins->arg[number].size = REG_SIZE;
            }
          return;
        }
d1612 14
a1631 7

  /* Assuming Post-Increment insn has the following format :
     'MNEMONIC DISP(REG)+, REG' (e.g. 'loadw 12(r5)+, r6').
     LD_STOR_INS_INC are the only store insns containing a plus sign (+).  */
  if (strstr (operands, ")+") != NULL)
    while (! IS_INSN_TYPE (LD_STOR_INS_INC))
      instruction++;
d1700 1
a1700 5
  int special_register_flag = 0;
  int movpr_flag = 0; /* Nonzero means current mnemonic is 'mtpr'/'mfpr' */

  if (IS_INSN_MNEMONIC ("mtpr") || IS_INSN_MNEMONIC ("mfpr"))
    movpr_flag = 1;
d1704 1
a1704 1
    special_register_flag = 1;
d1730 5
d1736 1
a1736 2
    case CRX_MTPR_REGTYPE:
      if (movpr_flag && special_register_flag)
d1742 1
a1742 3
    case CRX_C_REGTYPE:
    case CRX_CS_REGTYPE:
      if (!(movpr_flag && special_register_flag))
d1747 4
d1835 11
a1845 3
      /* When instruction size is 3, a 16-bit constant is always
	 filling the upper part of output_opcode[1].  */
      if (instruction->size > 2)
d1893 1
a1893 1
	    |  reg   | r_base | scl|  disp   |
d1907 1
a1907 1
      if ((instruction->flags & CST4MAP) && cst4flag)
d1911 1
a1911 1
	/* rbase_dispu<NN> and other such cases.  */
d1962 2
d1966 1
a1966 1
  int cst4maptype = 0;
d2001 8
d2013 3
a2015 1
	 && IS_INSN_MNEMONIC (mnemonic))
a2027 6
      if (done_flag)
        {
          /* Check for post inc mode of the current instruction.  */
          if (post_inc_mode == 1 || IS_INSN_TYPE (LD_STOR_INS_INC))
            done_flag = (post_inc_mode == IS_INSN_TYPE (LD_STOR_INS_INC));
        }
d2033 6
a2038 8
	      if (((instruction->operands[i].op_type == us3)
		    || (instruction->operands[i].op_type == us4)
		    || (instruction->operands[i].op_type == us5))
		  && (insn->arg[i].signflag == 1))
		  {
		    done_flag = 0;
		    break;
		  }
d2082 4
a2085 5
      /* Error checking for Co-Processor instructions : 
	 The internal coprocessor 0 can only accept the 
	 "mtcr" and "mfcr" instructions.  */
      if (IS_INSN_TYPE (COP_REG_INS) || IS_INSN_TYPE (COPS_REG_INS)
	  || IS_INSN_TYPE (COP_BRANCH_INS))
d2087 34
a2120 9
	  /* The coprocessor id is always the first argument.  */
	  if ((instruction->operands[0].op_type == us4)
	      && (insn->arg[0].constant == 0)
	      && (! IS_INSN_MNEMONIC ("mtcr")
		  && ! IS_INSN_MNEMONIC ("mfcr")))
	    {
	      as_bad (_("Internal Coprocessor 0 doesn't support instruction `%s'"), 
			mnemonic);
	    }
d2122 1
d2126 1
a2126 1
          if (IS_INSN_TYPE (LD_STOR_INS) && !relocatable)
d2131 1
a2131 1
              cst4maptype = instruction->flags & CST4MAP;
d2133 1
a2133 1
	      switch (cst4maptype)
d2176 1
d2180 17
a2196 12
          if ((IS_INSN_TYPE (ARITH_BYTE_INS) || IS_INSN_TYPE (ARITH_INS))
	       && !relocatable)
            {
	      /* Check whether a cst4 mapping has to be done.  */
              if ((instruction->operands[0].op_type == cst4
		    || instruction->operands[0].op_type == i16)
		  && (instruction->operands[1].op_type == regr))
                {
		  /* 'const' equals reserved escape sequences -->>
		     represent as i16.  */
		  if (insn->arg[0].constant == ESC_16
		      || insn->arg[0].constant == ESC_32)
d2198 12
a2209 8
		      instruction++;
		      GET_ACTUAL_SIZE;
		    }
		  else
		    {
		      /* Loop over cst4_map entries.  */
		      for (cst4_op = cst4_map; cst4_op < (cst4_map + cst4_maps);
			   cst4_op++)
d2211 3
a2213 17
			  /* 'const' equals a binary, which is already mapped
			     by a different value -->> represent as i16.  */
			  if (insn->arg[0].constant == (unsigned int)cst4_op->binary
			      && cst4_op->binary != cst4_op->value)
			    {
			      instruction++;
			      GET_ACTUAL_SIZE;
			    }
			  /* 'const' equals a value bigger than 16 -->> map to
			     its binary and represent as cst4.  */
			  else if (insn->arg[0].constant == (unsigned int)cst4_op->value
				   && insn->arg[0].constant >= 16)
			    {
			      instruction--;
			      insn->arg[0].constant = cst4_op->binary;
			      GET_ACTUAL_SIZE;
			    }
a2216 27
	      /* Special check for 'addub 0, r0' instruction -
		 The opcode '0000 0000 0000 0000' is not allowed.  */
              if (IS_INSN_MNEMONIC ("addub"))
                {
                  if ((instruction->operands[0].op_type == cst4)
		      && instruction->operands[1].op_type == regr)
                    {
                      if (insn->arg[0].constant == 0 && insn->arg[1].r == r0)
			instruction++;
                    }
                }
            }
          if (IS_INSN_TYPE (LD_STOR_INS) || IS_INSN_TYPE (STOR_IMM_INS)
	      || IS_INSN_TYPE (LD_STOR_INS_INC))
            {
	      instrtype = instruction->flags & REVERSE_MATCH ? 0 : 1;
              if (instruction->operands[instrtype].op_type == rbase)
		instruction++;
            }
	  /* Error checking in case of post-increment instruction.  */
	  if (IS_INSN_TYPE (LD_STOR_INS_INC))
	    {
	      if (!((strneq (instruction->mnemonic, "stor", 4))
		    && (insn->arg[0].type != arg_r)))
		if (insn->arg[0].r == insn->arg[1].r)
		  as_bad (_("Invalid instruction : `%s' Source and Destination register \
			  same in Post INC mode"), ins_parse);
d2218 4
a2221 1
          if (IS_INSN_TYPE (CSTBIT_INS) && !relocatable)
d2223 2
a2224 1
              if (instruction->operands[1].op_type == rbase_dispu12)
d2226 2
a2227 5
                  if (insn->arg[1].constant == 0)
                    {
                      instruction--;
		      GET_ACTUAL_SIZE;
                    }
d2231 1
a2231 2
	       || IS_INSN_TYPE (STOR_IMM_INS)
               || IS_INSN_TYPE (LD_STOR_INS_INC)) & !relocatable)
d2260 11
a2270 1
          if (IS_INSN_TYPE (BRANCH_INS) && !relocatable)
d2273 1
a2273 1
	      if (insn->arg[0].constant == 0x7e || insn->arg[0].constant == 0x7f)
d2275 1
d2280 1
a2280 8
        }

      for (i = 0; i < insn->nargs; i++)
        {
          if (instruction->operands[i].op_type == cst4
              || instruction->operands[i].op_type == rbase_cst4)
            cst4flag = 1;
        }
d2335 1
d2366 3
a2368 2
          if ((cr = get_copregister (reg_name)) == nullcopregister)
	    as_bad (_("Illegal register `%s' in cop-register list"), reg_name);
d2374 3
a2376 2
          if ((cr = get_copregister (reg_name)) == nullcopregister)
	    as_bad (_("Illegal register `%s' in cop-special-register list"), 
d2380 19
d2402 15
a2416 3
          if ((r = get_register (reg_name)) == nullregister)
	    as_bad (_("Illegal register `%s' in register list"), reg_name);
	  mask_reg (getreg_image (r), &mask);
d2423 1
d2432 22
a2453 3
  if (mask == 0)
    as_bad (_("Illegal `mask16' operand, operation is undefined - `%s'"),
	    ins_parse);
@


1.6
log
@Add error checking for Co-Processor instructions
@
text
@d2074 15
d2136 1
a2136 1
	  if ((instruction->operands[0].op_type == i4)
@


1.5
log
@Add support for CRX co-processor opcodes
@
text
@d1713 1
a1713 1
  /* Handle load/stor post-increment instructions.  */
d2114 16
@


1.4
log
@Handle load/stor unique instructions before parsing
@
text
@d1727 1
a1727 1
  int d_used = 0, i_used = 0, u_used = 0;
d1740 2
d1746 2
a1747 1
  return ((d_used ? 4 : 0)
d2380 1
d2387 9
@


1.3
log
@Add LD and GAS testsuites for CRX port.
Fix several crx bugs.
@
text
@d169 1
a169 1
static void    handle_pi_insn	        (char *);
d1670 6
a1675 3
/* Post-Increment instructions are a sub-group within load/stor instruction
   groups. Therefore, when parsing a Post-Increment insn, we have to advance
   the instruction pointer to the start of that sub-group.  */
d1678 1
a1678 1
handle_pi_insn (char *operands)
d1680 7
d1688 2
a1689 1
     'MNEMONIC DISP(REG)+, REG' (e.g. 'loadw 12(r5)+, r6').  */
d1714 2
a1715 2
  if (IS_INSN_TYPE (LD_STOR_INS) || IS_INSN_TYPE (STOR_IMM_INS))
    handle_pi_insn (operands);
@


1.2
log
@Add CRX insns: pushx, popx
Add support to GAS for expressions which are the difference of two symbols
@
text
@a30 1
/* Include <limits.h> do define ULONG_MAX, LONG_MAX, LONG_MIN.  */
d125 2
a126 1
struct option md_longopts[] = {
d285 1
a285 1
  memset (&output_opcode, '\0', sizeof (output_opcode));
d331 1
a331 1
  reloc->sym_ptr_ptr  =  xmalloc (sizeof (asymbol *));
d343 1
a343 1
      
d882 11
a898 2
	  /* This variable causes a warning (is to be handles by string
	     type implementation).  */
d900 1
a900 2

          char ptr[20];
d911 1
a911 21
	  temp64 = strtol (temp_str, (char **) &ptr,0);
	  /* This is not accurate :
	     Actually overflow is allowed here (see comment below).
	     Originally the call was to 'strtoll', which isn't
	     identified by MSVC.  */
	  if ((temp64 == LONG_MAX) || (temp64 == LONG_MIN))
	    as_bad (_("Overflow in displacement in Instruction `%s'"),
		    ins_parse);

          /* If br *+x
	     It will be returned as '0' padded with 'x' uptill 64 bits
	     If br *-x
	     It will be returned as sign extended form

	     Then search for validity of representation
	     Check whether upper 38 bits are all zeroes or all ones
	     If not report error.  */
          if (!(((temp64 & UPPER31_MASK) == UPPER31_MASK)
		|| ((temp64 & UPPER31_MASK) == 0x0)))
	    as_bad (_("Overflow in displacement in Instruction `%s'"),
		    ins_parse);
d946 1
a946 1
          char ptr[20];
d958 1
a958 21
	  temp64 = strtol (temp_str, (char **) &ptr,0);
	  /* This is not accurate :
	     Actually overflow is allowed here (see comment below).
	     Originally the call was to 'strtoll', which isn't
	     identified by MSVC.  */
	  if ((temp64 == LONG_MAX) || (temp64 == LONG_MIN))
	    as_bad (_("Overflow in displacement in Instruction `%s'"),
		    ins_parse);

          /* If br *+x
	     It will be returned as '0' padded with 'x' uptill 64 bits
	     If br *-x
	     It will be returned as sign extended form

	     Then search for validity of representation
	     Check whether upper 31 bits are all zeroes or all ones
	     If not report error.  */
          if (!(((temp64 & UPPER31_MASK) == UPPER31_MASK)
		|| ((temp64 & UPPER31_MASK) == 0x0)))
	    as_bad (_("Overflow in displacement in Instruction `%s'"),
		    ins_parse);
d973 2
a974 3
          else
            if (((jump_value & 0xFFFF0000) == 0xFFFF0000)
		|| ((jump_value & 0xFFFF0000) == 0x0))
d1039 1
a1039 1
                  char ptr[30];
d1042 1
a1042 3
	  	  /* Tomer - Originally the call was to 'strtoull', which isn't
		     identified by MSVC. Instead we check for overflow.  */
		  temp64 = strtoul (str, (char **) &ptr, 0);
d1049 1
a1049 2
			  /* Tomer - check for overflow.  */
			  || (temp64 == ULONG_MAX))
d1056 1
a1056 2
			  /* Tomer - check for overflow.  */
			  if (temp64 == ULONG_MAX)
d1157 1
d1503 1
a1503 1
          set_cons_rparams (operand, crx_ins, number);
d1663 1
a1663 1
    if (streq (trap->name, s))
@


1.1
log
@Add new port: crx-elf
@
text
@d295 28
d337 36
a372 9
    /* We don't resolve difference expressions.  */
    as_bad_where (fixP->fx_file, fixP->fx_line,
		  _("can't resolve `%s' {%s section} - `%s' {%s section}"),
		  fixP->fx_addsy ? S_GET_NAME (fixP->fx_addsy) : "0",
		  segment_name (fixP->fx_addsy
				? S_GET_SEGMENT (fixP->fx_addsy)
				: absolute_section),
		  S_GET_NAME (fixP->fx_subsy),
		  segment_name (S_GET_SEGMENT (fixP->fx_addsy)));
@

