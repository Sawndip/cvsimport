head	1.36;
access;
symbols
	binutils-2_24-branch:1.36.0.10
	binutils-2_24-branchpoint:1.36
	binutils-2_21_1:1.36
	binutils-2_23_2:1.36
	binutils-2_23_1:1.36
	binutils-2_23:1.36
	binutils-2_23-branch:1.36.0.8
	binutils-2_23-branchpoint:1.36
	binutils-2_22_branch:1.36.0.6
	binutils-2_22:1.36
	binutils-2_22-branch:1.36.0.4
	binutils-2_22-branchpoint:1.36
	binutils-2_21:1.36
	binutils-2_21-branch:1.36.0.2
	binutils-2_21-branchpoint:1.36
	binutils-2_20_1:1.34
	binutils-2_20:1.34
	binutils-arc-20081103-branch:1.32.0.6
	binutils-arc-20081103-branchpoint:1.32
	binutils-2_20-branch:1.34.0.2
	binutils-2_20-branchpoint:1.34
	dje-cgen-play1-branch:1.33.0.2
	dje-cgen-play1-branchpoint:1.33
	arc-20081103-branch:1.32.0.4
	arc-20081103-branchpoint:1.32
	binutils-2_19_1:1.32
	binutils-2_19:1.32
	binutils-2_19-branch:1.32.0.2
	binutils-2_19-branchpoint:1.32
	binutils-2_18:1.31
	binutils-2_18-branch:1.31.0.2
	binutils-2_18-branchpoint:1.31
	binutils-csl-coldfire-4_1-32:1.29
	binutils-csl-sourcerygxx-4_1-32:1.29
	binutils-csl-innovasic-fido-3_4_4-33:1.29
	binutils-csl-sourcerygxx-3_4_4-32:1.25
	binutils-csl-coldfire-4_1-30:1.29
	binutils-csl-sourcerygxx-4_1-30:1.29
	binutils-csl-coldfire-4_1-28:1.29
	binutils-csl-sourcerygxx-4_1-29:1.29
	binutils-csl-sourcerygxx-4_1-28:1.29
	binutils-csl-arm-2006q3-27:1.29
	binutils-csl-sourcerygxx-4_1-27:1.29
	binutils-csl-arm-2006q3-26:1.29
	binutils-csl-sourcerygxx-4_1-26:1.29
	binutils-csl-sourcerygxx-4_1-25:1.29
	binutils-csl-sourcerygxx-4_1-24:1.29
	binutils-csl-sourcerygxx-4_1-23:1.29
	binutils-csl-sourcerygxx-4_1-21:1.29
	binutils-csl-arm-2006q3-21:1.29
	binutils-csl-sourcerygxx-4_1-22:1.29
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.29
	binutils-csl-sourcerygxx-4_1-20:1.29
	binutils-csl-arm-2006q3-19:1.29
	binutils-csl-sourcerygxx-4_1-19:1.29
	binutils-csl-sourcerygxx-4_1-18:1.29
	binutils-csl-renesas-4_1-9:1.29
	binutils-csl-sourcerygxx-3_4_4-25:1.25
	binutils-csl-renesas-4_1-8:1.29
	binutils-csl-renesas-4_1-7:1.29
	binutils-csl-renesas-4_1-6:1.29
	binutils-csl-sourcerygxx-4_1-17:1.29
	binutils-csl-sourcerygxx-4_1-14:1.29
	binutils-csl-sourcerygxx-4_1-15:1.29
	binutils-csl-sourcerygxx-4_1-13:1.29
	binutils-2_17:1.29
	binutils-csl-sourcerygxx-4_1-12:1.29
	binutils-csl-sourcerygxx-3_4_4-21:1.29
	binutils-csl-wrs-linux-3_4_4-24:1.25
	binutils-csl-wrs-linux-3_4_4-23:1.25
	binutils-csl-sourcerygxx-4_1-9:1.29
	binutils-csl-sourcerygxx-4_1-8:1.29
	binutils-csl-sourcerygxx-4_1-7:1.29
	binutils-csl-arm-2006q1-6:1.29
	binutils-csl-sourcerygxx-4_1-6:1.29
	binutils-csl-wrs-linux-3_4_4-22:1.25
	binutils-csl-coldfire-4_1-11:1.29
	binutils-csl-sourcerygxx-3_4_4-19:1.29
	binutils-csl-coldfire-4_1-10:1.29
	binutils-csl-sourcerygxx-4_1-5:1.29
	binutils-csl-sourcerygxx-4_1-4:1.29
	binutils-csl-wrs-linux-3_4_4-21:1.25
	binutils-csl-morpho-4_1-4:1.29
	binutils-csl-sourcerygxx-3_4_4-17:1.29
	binutils-csl-wrs-linux-3_4_4-20:1.25
	binutils-2_17-branch:1.29.0.4
	binutils-2_17-branchpoint:1.29
	binutils-csl-2_17-branch:1.29.0.2
	binutils-csl-2_17-branchpoint:1.29
	binutils-csl-gxxpro-3_4-branch:1.25.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.25
	binutils-2_16_1:1.25
	binutils-csl-arm-2005q1b:1.25
	binutils-2_16:1.25
	binutils-csl-arm-2005q1a:1.25
	binutils-csl-arm-2005q1-branch:1.25.0.4
	binutils-csl-arm-2005q1-branchpoint:1.25
	binutils-2_16-branch:1.25.0.2
	binutils-2_16-branchpoint:1.25
	csl-arm-2004-q3d:1.21
	csl-arm-2004-q3:1.20
	binutils-2_15:1.20
	binutils-2_15-branchpoint:1.20
	csl-arm-2004-q1a:1.20
	csl-arm-2004-q1:1.20
	binutils-2_15-branch:1.20.0.6
	cagney_bfdfile-20040213-branch:1.20.0.4
	cagney_bfdfile-20040213-branchpoint:1.20
	cagney_bigcore-20040122-branch:1.20.0.2
	cagney_bigcore-20040122-branchpoint:1.20
	csl-arm-2003-q4:1.20
	binutils-2_14:1.18
	binutils-2_14-branch:1.18.0.2
	binutils-2_14-branchpoint:1.18
	binutils-2_13_2_1:1.15
	binutils-2_13_2:1.15
	binutils-2_13_1:1.15
	binutils-2_13:1.15
	binutils-2_13-branchpoint:1.15
	binutils-2_13-branch:1.15.0.2
	binutils-2_12_1:1.14
	binutils-2_12:1.14
	binutils-2_12-branch:1.14.0.2
	binutils-2_12-branchpoint:1.14
	cygnus_cvs_20020108_pre:1.14
	binutils-2_11_2:1.6.2.1
	binutils-2_11_1:1.6.2.1
	binutils-2_11:1.6
	x86_64versiong3:1.6
	binutils-2_11-branch:1.6.0.2
	binutils-2_10_1:1.1
	binutils-2_10:1.1
	binutils-2_10-branch:1.1.0.2
	binutils-2_10-branchpoint:1.1
	binutils_latest_snapshot:1.36;
locks; strict;
comment	@ * @;


1.36
date	2010.06.28.14.06.57;	author amodra;	state Exp;
branches;
next	1.35;

1.35
date	2009.12.11.13.42.10;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	2009.07.24.11.45.00;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	2009.06.22.17.56.01;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2007.10.17.16.45.55;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	2007.07.03.11.01.04;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	2006.06.07.11.27.57;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2006.01.11.17.39.49;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2005.06.07.17.54.16;	author zack;	state Exp;
branches;
next	1.27;

1.27
date	2005.05.05.09.12.56;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	2005.03.24.20.40.26;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2005.03.03.11.47.50;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2005.03.01.02.00.15;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2005.02.23.12.28.04;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2005.01.31.23.18.27;	author bje;	state Exp;
branches;
next	1.21;

1.21
date	2004.11.03.01.54.24;	author hp;	state Exp;
branches;
next	1.20;

1.20
date	2003.11.21.14.38.06;	author kazu;	state Exp;
branches;
next	1.19;

1.19
date	2003.06.25.06.40.26;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2002.12.12.22.29.00;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2002.11.30.08.39.43;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2002.09.05.00.01.17;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.08.07.37.15;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2001.11.15.21.28.55;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2001.10.11.23.56.33;	author kazu;	state Exp;
branches;
next	1.12;

1.12
date	2001.09.19.08.13.04;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2001.09.19.05.33.24;	author hjl;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.11.16.46.38;	author jakub;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.30.06.15.49;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2001.07.23.14.02.12;	author kazu;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.08.23.24.23;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2001.01.14.18.54.06;	author kazu;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.12.03.06.49.22;	author kazu;	state Exp;
branches;
next	1.4;

1.4
date	2000.10.04.00.28.45;	author amodra;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.11.19.49.46;	author kazu;	state Exp;
branches;
next	1.2;

1.2
date	2000.07.07.16.58.24;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	2000.02.23.13.52.21;	author amodra;	state Exp;
branches;
next	;

1.6.2.1
date	2001.06.07.03.15.28;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.36
log
@	* config/obj-evax.h (S_SET_OTHER, S_SET_TYPE, S_SET_DESC): Don't define.
	* config/tc-crx.c (gettrap): Constify arg.
	(handle_LoadStor, get_cinv_parameters): Likewise.
	(getreg_image): Fix enum warning
	(md_assemble): Restore input line char.
	* config/tc-hppa.c (tc_gen_reloc): Fix enum warning.
	* config/tc-i960.c (mem_fmt): Rename var to fix shadow warning.
	* config/tc-sh.c (sh_fdpic): Only define when OBJ_ELF.
	(build_Mytes): Fix build failure for non-elf targets.
	* config/tc-tic4x.c (tic4x_eval): Restore terminator char.
	* config/tc-xtensa.c (xtensa_end_directive): Fix switch enum warning.

	* cgen.c (gas_cgen_md_apply_fix): Avoid set but unused warning.
	* ecoff.c (add_ecoff_symbol): Likewise.
	* itbl-ops.c (append_insns_as_macros): Likewise.
	* listing.c (debugging_pseudo): Likewise.
	* read.c (s_mri_common, stringer): Likewise.
	* config/obj-coff.c (coff_frob_section): Likewise.
	* config/tc-alpha.c (emit_ldgp, s_alpha_proc): Likewise.
	* config/tc-arm.c (my_get_expression): Likewise.
	* config/tc-hppa.c (process_exit, pa_type_args): Likewise.
	* config/tc-m32c.c (md_assemble): Likewise.
	* config/tc-microblaze.c (md_convert_frag): Likewise.
	* config/tc-mips.c (s_change_section): Likewise.
	* config/tc-mt.c (mt_fix_adjustable): Likewise.
	* config/tc-xtensa.c (xtensa_literal_pseudo): Likewise.

	* config/obj-aout.c (obj_aout_frob_symbol): Delete set but otherwise
	unused vars.
	* config/tc-alpha.c (load_expression): Likewise.
	(s_alpha_rdata, s_alpha_section, s_alpha_prologue): Likewise.
	* config/tc-arm.c (parse_neon_el_struct_list): Likewise.
	* config/tc-avr.c (extract_word): Likewise.
	* config/tc-cris.c (cris_get_expression): Likewise.
	* config/tc-d30v.c (build_insn, find_format): Likewise.
	* config/tc-dlx.c (machine_ip): Likewise.
	* config/tc-hppa.c (pa_get_absolute_expression): Likewise.
	* config/tc-i370.c (md_assemble): Likewise.
	* config/tc-i960.c (brtab_emit): Likewise.
	* config/tc-iq2000.c (s_iq2000_ent): Likewise.
	* config/tc-m32c.c (md_convert_frag): Likewise.
	* config/tc-m68hc11.c (fixup24, build_jump_insn): Likewise.
	(md_estimate_size_before_relax, md_apply_fix): Likewise.
	* config/tc-m68k.c (md_show_usage): Likewise.
	* config/tc-microblaze.c (microblaze_s_lcomm): Likewise.
	* config/tc-mips.c (s_mips_end): Likewise.
	* config/tc-mmix.c (mmix_byte, mmix_cons): Likewise.
	* config/tc-mn10300.c (md_assemble): Likewise.
	* config/tc-msp430.c (extract_word): Likewise.
	* config/tc-mt.c (md_assemble): Likewise.
	* config/tc-or32.c (machine_ip): Likewise.
	* config/tc-pj.c (md_apply_fix): Likewise.
	* config/tc-s390.c (md_gather_operands): Likewise.
	* config/tc-sh.c (sh_cons_align): Likewise.
	* config/tc-sparc.c (sparc_cons_align): Likewise.
	* config/tc-tic4x.c (tic4x_sect): Likewise.
	* config/tc-tic54x.c (tic54x_stringer): Likewise.
	* config/tc-vax.c (vip_op): Likewise.
	* config/tc-xstormy16.c (xstormy16_cons_fix_new): Likewise.
	* config/tc-xtensa.c (md_assemble): Likewise.
	(xtensa_fix_short_loop_frags, convert_frag_immed): Likewise.
	(xtensa_move_literals): Likewise.
@
text
@/* tc-i370.c -- Assembler for the IBM 360/370/390 instruction set.
   Loosely based on the ppc files by Linas Vepstas <linas@@linas.org> 1998, 99
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
   2004, 2005, 2006, 2007, 2009, 2010  Free Software Foundation, Inc.
   Written by Ian Lance Taylor, Cygnus Support.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* This assembler implements a very hacked version of an elf-like thing
   that gcc emits (when gcc is suitably hacked).  To make it behave more
   HLASM-like, try turning on the -M or --mri flag (as there are various
   similarities between HLASM and the MRI assemblers, such as section
   names, lack of leading . in pseudo-ops, DC and DS, etc.  */

#include "as.h"
#include "safe-ctype.h"
#include "subsegs.h"
#include "struc-symbol.h"

#include "opcode/i370.h"

#ifdef OBJ_ELF
#include "elf/i370.h"
#endif

/* This is the assembler for the System/390 Architecture.  */

/* Tell the main code what the endianness is.  */
extern int target_big_endian;


/* Generic assembler global variables which must be defined by all
   targets.  */

#ifdef OBJ_ELF
/* This string holds the chars that always start a comment.  If the
   pre-processor is disabled, these aren't very useful.  The macro
   tc_comment_chars points to this.  We use this, rather than the
   usual comment_chars, so that we can switch for Solaris conventions.  */
static const char i370_eabi_comment_chars[] = "#";

const char *i370_comment_chars = i370_eabi_comment_chars;
#else
const char comment_chars[] = "#";
#endif

/* Characters which start a comment at the beginning of a line.  */
const char line_comment_chars[] = "#*";

/* Characters which may be used to separate multiple commands on a
   single line.  */
const char line_separator_chars[] = ";";

/* Characters which are used to indicate an exponent in a floating
   point number.  */
const char EXP_CHARS[] = "eE";

/* Characters which mean that a number is a floating point constant,
   as in 0d1.0.  */
const char FLT_CHARS[] = "dD";

void
md_show_usage (FILE *stream)
{
  fprintf (stream, "\
S/370 options: (these have not yet been tested and may not work) \n\
-u        		ignored\n\
-mregnames        	Allow symbolic names for registers\n\
-mno-regnames        	Do not allow symbolic names for registers\n");
#ifdef OBJ_ELF
  fprintf (stream, "\
-mrelocatable        	support for GCC's -mrelocatble option\n\
-mrelocatable-lib       support for GCC's -mrelocatble-lib option\n\
-V        		print assembler version number\n");
#endif
}

/* Whether to use user friendly register names.  */
#define TARGET_REG_NAMES_P TRUE

static bfd_boolean reg_names_p = TARGET_REG_NAMES_P;


/* Predefined register names if -mregnames
   In general, there are lots of them, in an attempt to be compatible
   with a number of assemblers.  */

/* Structure to hold information about predefined registers.  */
struct pd_reg
  {
    char *name;
    int value;
  };

/* List of registers that are pre-defined:

   Each general register has predefined names of the form:
   1. r<reg_num> which has the value <reg_num>.
   2. r.<reg_num> which has the value <reg_num>.

   Each floating point register has predefined names of the form:
   1. f<reg_num> which has the value <reg_num>.
   2. f.<reg_num> which has the value <reg_num>.

   There are only four floating point registers, and these are
   commonly labelled 0,2,4 and 6.  Thus, there is no f1, f3, etc.

   There are individual registers as well:
   rbase or r.base has the value  3  (base register)
   rpgt or r.pgt   has the value  4  (page origin table pointer)
   rarg or r.arg   has the value 11  (argument pointer)
   rtca or r.tca   has the value 12  (table of contents pointer)
   rtoc or r.toc   has the value 12  (table of contents pointer)
   sp or r.sp      has the value 13  (stack pointer)
   dsa or r.dsa    has the value 13  (stack pointer)
   lr              has the value 14  (link reg)

   The table is sorted. Suitable for searching by a binary search.  */

static const struct pd_reg pre_defined_registers[] =
{
  { "arg", 11 },   /* Argument Pointer.  */
  { "base", 3 },   /* Base Reg.  */

  { "f.0", 0 },    /* Floating point registers.  */
  { "f.2", 2 },
  { "f.4", 4 },
  { "f.6", 6 },

  { "f0", 0 },
  { "f2", 2 },
  { "f4", 4 },
  { "f6", 6 },

  { "dsa",13 },    /* Stack pointer.  */
  { "lr", 14 },    /* Link Register.  */
  { "pgt", 4 },    /* Page Origin Table Pointer.  */

  { "r.0", 0 },    /* General Purpose Registers.  */
  { "r.1", 1 },
  { "r.10", 10 },
  { "r.11", 11 },
  { "r.12", 12 },
  { "r.13", 13 },
  { "r.14", 14 },
  { "r.15", 15 },
  { "r.2", 2 },
  { "r.3", 3 },
  { "r.4", 4 },
  { "r.5", 5 },
  { "r.6", 6 },
  { "r.7", 7 },
  { "r.8", 8 },
  { "r.9", 9 },

  { "r.arg", 11 },  /* Argument Pointer.  */
  { "r.base", 3 },  /* Base Reg.  */
  { "r.dsa", 13 },  /* Stack Pointer.  */
  { "r.pgt", 4 },   /* Page Origin Table Pointer.  */
  { "r.sp", 13 },   /* Stack Pointer.  */

  { "r.tca", 12 },  /* Pointer to the table of contents.  */
  { "r.toc", 12 },  /* Pointer to the table of contents.  */

  { "r0", 0 },      /* More general purpose registers.  */
  { "r1", 1 },
  { "r10", 10 },
  { "r11", 11 },
  { "r12", 12 },
  { "r13", 13 },
  { "r14", 14 },
  { "r15", 15 },
  { "r2", 2 },
  { "r3", 3 },
  { "r4", 4 },
  { "r5", 5 },
  { "r6", 6 },
  { "r7", 7 },
  { "r8", 8 },
  { "r9", 9 },

  { "rbase", 3 },  /* Base Reg.  */

  { "rtca", 12 },  /* Pointer to the table of contents.  */
  { "rtoc", 12 },  /* Pointer to the table of contents.  */

  { "sp", 13 },   /* Stack Pointer.  */

};

#define REG_NAME_CNT        (sizeof (pre_defined_registers) / sizeof (struct pd_reg))

/* Given NAME, find the register number associated with that name, return
   the integer value associated with the given name or -1 on failure.  */

static int
reg_name_search (const struct pd_reg *regs,
		 int regcount,
		 const char *name)
{
  int middle, low, high;
  int cmp;

  low = 0;
  high = regcount - 1;

  do
    {
      middle = (low + high) / 2;
      cmp = strcasecmp (name, regs[middle].name);
      if (cmp < 0)
        high = middle - 1;
      else if (cmp > 0)
        low = middle + 1;
      else
        return regs[middle].value;
    }
  while (low <= high);

  return -1;
}

/* Summary of register_name().

   in:        Input_line_pointer points to 1st char of operand.

   out:        An expressionS.
        The operand may have been a register: in this case, X_op == O_register,
        X_add_number is set to the register number, and truth is returned.
          Input_line_pointer->(next non-blank) char after operand, or is in its
        original state.  */

static bfd_boolean
register_name (expressionS *expressionP)
{
  int reg_number;
  char *name;
  char *start;
  char c;

  /* Find the spelling of the operand.  */
  start = name = input_line_pointer;
  if (name[0] == '%' && ISALPHA (name[1]))
    name = ++input_line_pointer;

  else if (!reg_names_p)
    return FALSE;

  while (' ' == *name)
    name = ++input_line_pointer;

  /* If it's a number, treat it as a number.  If it's alpha, look to
     see if it's in the register table.  */
  if (!ISALPHA (name[0]))
    reg_number = get_single_number ();
  else
    {
      c = get_symbol_end ();
      reg_number = reg_name_search (pre_defined_registers, REG_NAME_CNT, name);

      /* Put back the delimiting char.  */
      *input_line_pointer = c;
    }

  /* If numeric, make sure its not out of bounds.  */
  if ((0 <= reg_number) && (16 >= reg_number))
    {
      expressionP->X_op = O_register;
      expressionP->X_add_number = reg_number;

      /* Make the rest nice.  */
      expressionP->X_add_symbol = NULL;
      expressionP->X_op_symbol = NULL;
      return TRUE;
    }

  /* Reset the line as if we had not done anything.  */
  input_line_pointer = start;
  return FALSE;
}

/* Local variables.  */

/* The type of processor we are assembling for.  This is one or more
   of the I370_OPCODE flags defined in opcode/i370.h.  */
static int i370_cpu = 0;

/* The base register to use for opcode with optional operands.
   We define two of these: "text" and "other".  Normally, "text"
   would get used in the .text section for branches, while "other"
   gets used in the .data section for address constants.

   The idea of a second base register in a different section
   is foreign to the usual HLASM-style semantics; however, it
   allows us to provide support for dynamically loaded libraries,
   by allowing us to place address constants in a section other
   than the text section. The "other" section need not be the
   .data section, it can be any section that isn't the .text section.

   Note that HLASM defines a multiple, concurrent .using semantic
   that we do not: in calculating offsets, it uses either the most
   recent .using directive, or the one with the smallest displacement.
   This allows HLASM to support a quasi-block-scope-like behaviour.
   Handy for people writing assembly by hand ... but not supported
   by us.  */
static int i370_using_text_regno = -1;
static int i370_using_other_regno = -1;

/* The base address for address literals.  */
static expressionS i370_using_text_baseaddr;
static expressionS i370_using_other_baseaddr;

/* the "other" section, used only for syntax error detection.  */
static segT i370_other_section = undefined_section;

/* Opcode hash table.  */
static struct hash_control *i370_hash;

/* Macro hash table.  */
static struct hash_control *i370_macro_hash;

#ifdef OBJ_ELF
/* What type of shared library support to use.  */
static enum { SHLIB_NONE, SHLIB_PIC, SHILB_MRELOCATABLE } shlib = SHLIB_NONE;
#endif

/* Flags to set in the elf header.  */
static flagword i370_flags = 0;

#ifndef WORKING_DOT_WORD
int md_short_jump_size = 4;
int md_long_jump_size = 4;
#endif

#ifdef OBJ_ELF
const char *md_shortopts = "l:um:K:VQ:";
#else
const char *md_shortopts = "um:";
#endif
struct option md_longopts[] =
{
  {NULL, no_argument, NULL, 0}
};
size_t md_longopts_size = sizeof (md_longopts);

int
md_parse_option (int c, char *arg)
{
  switch (c)
    {
    case 'u':
      /* -u means that any undefined symbols should be treated as
         external, which is the default for gas anyhow.  */
      break;

#ifdef OBJ_ELF
    case 'K':
      /* Recognize -K PIC */
      if (strcmp (arg, "PIC") == 0 || strcmp (arg, "pic") == 0)
        {
          shlib = SHLIB_PIC;
          i370_flags |= EF_I370_RELOCATABLE_LIB;
        }
      else
        return 0;

      break;
#endif

    case 'm':

      /* -m360 mean to assemble for the ancient 360 architecture.  */
      if (strcmp (arg, "360") == 0 || strcmp (arg, "i360") == 0)
	i370_cpu = I370_OPCODE_360;
      /* -mxa means to assemble for the IBM 370 XA.  */
      else if (strcmp (arg, "xa") == 0)
	i370_cpu = I370_OPCODE_370_XA;
      /* -many means to assemble for any architecture (370/XA).  */
      else if (strcmp (arg, "any") == 0)
	i370_cpu = I370_OPCODE_370;

      else if (strcmp (arg, "regnames") == 0)
	reg_names_p = TRUE;

      else if (strcmp (arg, "no-regnames") == 0)
	reg_names_p = FALSE;

#ifdef OBJ_ELF
      /* -mrelocatable/-mrelocatable-lib -- warn about
	 initializations that require relocation.  */
      else if (strcmp (arg, "relocatable") == 0)
        {
          shlib = SHILB_MRELOCATABLE;
          i370_flags |= EF_I370_RELOCATABLE;
        }
      else if (strcmp (arg, "relocatable-lib") == 0)
        {
          shlib = SHILB_MRELOCATABLE;
          i370_flags |= EF_I370_RELOCATABLE_LIB;
        }
#endif
      else
        {
          as_bad (_("invalid switch -m%s"), arg);
          return 0;
        }
      break;

#ifdef OBJ_ELF
      /* -V: SVR4 argument to print version ID.  */
    case 'V':
      print_version_id ();
      break;

      /* -Qy, -Qn: SVR4 arguments controlling whether a .comment section
         should be emitted or not.  FIXME: Not implemented.  */
    case 'Q':
      break;

#endif

    default:
      return 0;
    }

  return 1;
}


/* Set i370_cpu if it is not already set.
   Currently defaults to the reasonable superset;
   but can be made more fine grained if desred.  */

static void
i370_set_cpu (void)
{
  const char *default_os  = TARGET_OS;
  const char *default_cpu = TARGET_CPU;

  /* Override with the superset for the moment.  */
  i370_cpu = I370_OPCODE_ESA390_SUPERSET;
  if (i370_cpu == 0)
    {
      if (strcmp (default_cpu, "i360") == 0)
        i370_cpu = I370_OPCODE_360;
      else if (strcmp (default_cpu, "i370") == 0)
        i370_cpu = I370_OPCODE_370;
      else if (strcmp (default_cpu, "XA") == 0)
        i370_cpu = I370_OPCODE_370_XA;
      else
        as_fatal ("Unknown default cpu = %s, os = %s", default_cpu, default_os);
    }
}

/* Figure out the BFD architecture to use.
   FIXME: specify the different 370 architectures.  */

enum bfd_architecture
i370_arch (void)
{
   return bfd_arch_i370;
}

/* This function is called when the assembler starts up.  It is called
   after the options have been parsed and the output file has been
   opened.  */

void
md_begin (void)
{
  const struct i370_opcode *op;
  const struct i370_opcode *op_end;
  const struct i370_macro *macro;
  const struct i370_macro *macro_end;
  bfd_boolean dup_insn = FALSE;

  i370_set_cpu ();

#ifdef OBJ_ELF
  /* Set the ELF flags if desired.  */
  if (i370_flags)
    bfd_set_private_flags (stdoutput, i370_flags);
#endif

  /* Insert the opcodes into a hash table.  */
  i370_hash = hash_new ();

   op_end = i370_opcodes + i370_num_opcodes;
   for (op = i370_opcodes; op < op_end; op++)
     {
       know ((op->opcode.i[0] & op->mask.i[0]) == op->opcode.i[0]
	     && (op->opcode.i[1] & op->mask.i[1]) == op->opcode.i[1]);

       if ((op->flags & i370_cpu) != 0)
         {
           const char *retval;

           retval = hash_insert (i370_hash, op->name, (void *) op);
           if (retval != (const char *) NULL)
             {
               as_bad (_("Internal assembler error for instruction %s"), op->name);
               dup_insn = TRUE;
             }
         }
     }

  /* Insert the macros into a hash table.  */
  i370_macro_hash = hash_new ();

  macro_end = i370_macros + i370_num_macros;
  for (macro = i370_macros; macro < macro_end; macro++)
    {
      if ((macro->flags & i370_cpu) != 0)
        {
          const char *retval;

          retval = hash_insert (i370_macro_hash, macro->name, (void *) macro);
          if (retval != (const char *) NULL)
            {
              as_bad (_("Internal assembler error for macro %s"), macro->name);
              dup_insn = TRUE;
            }
        }
    }

  if (dup_insn)
    abort ();
}

/* Insert an operand value into an instruction.  */

static i370_insn_t
i370_insert_operand (i370_insn_t insn,
		     const struct i370_operand *operand,
		     offsetT val)
{
  if (operand->insert)
    {
      const char *errmsg;

      /* Used for 48-bit insn's.  */
      errmsg = NULL;
      insn = (*operand->insert) (insn, (long) val, &errmsg);
      if (errmsg)
        as_bad ("%s", errmsg);
    }
  else
    /* This is used only for 16, 32 bit insn's.  */
    insn.i[0] |= (((long) val & ((1 << operand->bits) - 1))
		  << operand->shift);

  return insn;
}


#ifdef OBJ_ELF
/* Parse @@got, etc. and return the desired relocation.
   Currently, i370 does not support (don't really need to support) any
   of these fancier markups ... for example, no one is going to
   write 'L 6,=V(bogus)@@got' it just doesn't make sense (at least to me).
   So basically, we could get away with this routine returning
   BFD_RELOC_UNUSED in all circumstances.  However, I'll leave
   in for now in case someone ambitious finds a good use for this stuff ...
   this routine was pretty much just copied from the powerpc code ...  */

static bfd_reloc_code_real_type
i370_elf_suffix (char **str_p, expressionS *exp_p)
{
  struct map_bfd
  {
    char *string;
    int length;
    bfd_reloc_code_real_type reloc;
  };

  char ident[20];
  char *str = *str_p;
  char *str2;
  int ch;
  int len;
  struct map_bfd *ptr;

#define MAP(str,reloc) { str, sizeof (str) - 1, reloc }

  static struct map_bfd mapping[] =
  {
    /* warnings with -mrelocatable.  */
    MAP ("fixup",	BFD_RELOC_CTOR),
    { (char *)0, 0,	BFD_RELOC_UNUSED }
  };

  if (*str++ != '@@')
    return BFD_RELOC_UNUSED;

  for (ch = *str, str2 = ident;
       (str2 < ident + sizeof (ident) - 1
        && (ISALNUM (ch) || ch == '@@'));
       ch = *++str)
    *str2++ = TOLOWER (ch);

  *str2 = '\0';
  len = str2 - ident;

  ch = ident[0];
  for (ptr = &mapping[0]; ptr->length > 0; ptr++)
    if (ch == ptr->string[0]
        && len == ptr->length
        && memcmp (ident, ptr->string, ptr->length) == 0)
      {
        if (exp_p->X_add_number != 0
            && (ptr->reloc == BFD_RELOC_16_GOTOFF
        	|| ptr->reloc == BFD_RELOC_LO16_GOTOFF
        	|| ptr->reloc == BFD_RELOC_HI16_GOTOFF
        	|| ptr->reloc == BFD_RELOC_HI16_S_GOTOFF))
          as_warn (_("identifier+constant@@got means identifier@@got+constant"));

        /* Now check for identifier@@suffix+constant */
        if (*str == '-' || *str == '+')
          {
            char *orig_line = input_line_pointer;
            expressionS new_exp;

            input_line_pointer = str;
            expression (&new_exp);
            if (new_exp.X_op == O_constant)
              {
        	exp_p->X_add_number += new_exp.X_add_number;
        	str = input_line_pointer;
              }

            if (&input_line_pointer != str_p)
              input_line_pointer = orig_line;
          }

        *str_p = str;
        return ptr->reloc;
      }

  return BFD_RELOC_UNUSED;
}

/* Like normal .long/.short/.word, except support @@got, etc.
   Clobbers input_line_pointer, checks end-of-line.  */

static void
i370_elf_cons (int nbytes)   /* 1=.byte, 2=.word, 4=.long.  */
{
  expressionS exp;
  bfd_reloc_code_real_type reloc;

  if (is_it_end_of_statement ())
    {
      demand_empty_rest_of_line ();
      return;
    }

  do
    {
      expression (&exp);

      if (exp.X_op == O_symbol
          && *input_line_pointer == '@@'
          && (reloc = i370_elf_suffix (&input_line_pointer, &exp)) != BFD_RELOC_UNUSED)
        {
          reloc_howto_type *reloc_howto = bfd_reloc_type_lookup (stdoutput, reloc);
          int size = bfd_get_reloc_size (reloc_howto);

          if (size > nbytes)
            as_bad (_("%s relocations do not fit in %d bytes\n"),
		    reloc_howto->name, nbytes);
          else
            {
              char *p = frag_more ((int) nbytes);
              int offset = nbytes - size;

              fix_new_exp (frag_now, p - frag_now->fr_literal + offset, size, &exp, 0, reloc);
            }
        }
      else
        emit_expr (&exp, (unsigned int) nbytes);
    }
  while (*input_line_pointer++ == ',');

  input_line_pointer--;        	/* Put terminator back into stream.  */
  demand_empty_rest_of_line ();
}


/* ASCII to EBCDIC conversion table.  */
static unsigned char ascebc[256] =
{
 /*00  NL    SH    SX    EX    ET    NQ    AK    BL */
     0x00, 0x01, 0x02, 0x03, 0x37, 0x2D, 0x2E, 0x2F,
 /*08  BS    HT    LF    VT    FF    CR    SO    SI */
     0x16, 0x05, 0x15, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 /*10  DL    D1    D2    D3    D4    NK    SN    EB */
     0x10, 0x11, 0x12, 0x13, 0x3C, 0x3D, 0x32, 0x26,
 /*18  CN    EM    SB    EC    FS    GS    RS    US */
     0x18, 0x19, 0x3F, 0x27, 0x1C, 0x1D, 0x1E, 0x1F,
 /*20  SP     !     "     #     $     %     &     ' */
     0x40, 0x5A, 0x7F, 0x7B, 0x5B, 0x6C, 0x50, 0x7D,
 /*28   (     )     *     +     ,     -    .      / */
     0x4D, 0x5D, 0x5C, 0x4E, 0x6B, 0x60, 0x4B, 0x61,
 /*30   0     1     2     3     4     5     6     7 */
     0xF0, 0xF1, 0xF2, 0xF3, 0xF4, 0xF5, 0xF6, 0xF7,
 /*38   8     9     :     ;     <     =     >     ? */
     0xF8, 0xF9, 0x7A, 0x5E, 0x4C, 0x7E, 0x6E, 0x6F,
 /*40   @@     A     B     C     D     E     F     G */
     0x7C, 0xC1, 0xC2, 0xC3, 0xC4, 0xC5, 0xC6, 0xC7,
 /*48   H     I     J     K     L     M     N     O */
     0xC8, 0xC9, 0xD1, 0xD2, 0xD3, 0xD4, 0xD5, 0xD6,
 /*50   P     Q     R     S     T     U     V     W */
     0xD7, 0xD8, 0xD9, 0xE2, 0xE3, 0xE4, 0xE5, 0xE6,
 /*58   X     Y     Z     [     \     ]     ^     _ */
     0xE7, 0xE8, 0xE9, 0xAD, 0xE0, 0xBD, 0x5F, 0x6D,
 /*60   `     a     b     c     d     e     f     g */
     0x79, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87,
 /*68   h     i     j     k     l     m     n     o */
     0x88, 0x89, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96,
 /*70   p     q     r     s     t     u     v     w */
     0x97, 0x98, 0x99, 0xA2, 0xA3, 0xA4, 0xA5, 0xA6,
 /*78   x     y     z     {     |     }     ~    DL */
     0xA7, 0xA8, 0xA9, 0xC0, 0x4F, 0xD0, 0xA1, 0x07,
     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F,
     0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0xFF
};

/* EBCDIC to ASCII conversion table.  */
unsigned char ebcasc[256] =
{
 /*00  NU    SH    SX    EX    PF    HT    LC    DL */
     0x00, 0x01, 0x02, 0x03, 0x00, 0x09, 0x00, 0x7F,
 /*08              SM    VT    FF    CR    SO    SI */
     0x00, 0x00, 0x00, 0x0B, 0x0C, 0x0D, 0x0E, 0x0F,
 /*10  DE    D1    D2    TM    RS    NL    BS    IL */
     0x10, 0x11, 0x12, 0x13, 0x14, 0x0A, 0x08, 0x00,
 /*18  CN    EM    CC    C1    FS    GS    RS    US */
     0x18, 0x19, 0x00, 0x00, 0x1C, 0x1D, 0x1E, 0x1F,
 /*20  DS    SS    FS          BP    LF    EB    EC */
     0x00, 0x00, 0x00, 0x00, 0x00, 0x0A, 0x17, 0x1B,
 /*28              SM    C2    EQ    AK    BL       */
     0x00, 0x00, 0x00, 0x00, 0x05, 0x06, 0x07, 0x00,
 /*30              SY          PN    RS    UC    ET */
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x04,
 /*38                    C3    D4    NK          SU */
     0x00, 0x00, 0x00, 0x00, 0x14, 0x15, 0x00, 0x1A,
 /*40  SP                                           */
     0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 /*48                     .     <     (     +     | */
     0x00, 0x00, 0x00, 0x2E, 0x3C, 0x28, 0x2B, 0x7C,
 /*50   &                                           */
     0x26, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 /*58               !     $     *     )     ;     ^ */
     0x00, 0x00, 0x21, 0x24, 0x2A, 0x29, 0x3B, 0x5E,
 /*60   -     /                                     */
     0x2D, 0x2F, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 /*68                     ,     %     _     >     ? */
     0x00, 0x00, 0x00, 0x2C, 0x25, 0x5F, 0x3E, 0x3F,
 /*70                                               */
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 /*78         `     :     #     @@     '     =     " */
     0x00, 0x60, 0x3A, 0x23, 0x40, 0x27, 0x3D, 0x22,
 /*80         a     b     c     d     e     f     g */
     0x00, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67,
 /*88   h     i           {                         */
     0x68, 0x69, 0x00, 0x7B, 0x00, 0x00, 0x00, 0x00,
 /*90         j     k     l     m     n     o     p */
     0x00, 0x6A, 0x6B, 0x6C, 0x6D, 0x6E, 0x6F, 0x70,
 /*98   q     r           }                         */
     0x71, 0x72, 0x00, 0x7D, 0x00, 0x00, 0x00, 0x00,
 /*A0         ~     s     t     u     v     w     x */
     0x00, 0x7E, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78,
 /*A8   y     z                       [             */
     0x79, 0x7A, 0x00, 0x00, 0x00, 0x5B, 0x00, 0x00,
 /*B0                                               */
     0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 /*B8                                 ]             */
     0x00, 0x00, 0x00, 0x00, 0x00, 0x5D, 0x00, 0x00,
 /*C0   {     A     B     C     D     E     F     G */
     0x7B, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47,
 /*C8   H     I                                     */
     0x48, 0x49, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 /*D0   }     J     K     L     M     N     O     P */
     0x7D, 0x4A, 0x4B, 0x4C, 0x4D, 0x4E, 0x4F, 0x50,
 /*D8   Q     R                                     */
     0x51, 0x52, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 /*E0   \           S     T     U     V     W     X */
     0x5C, 0x00, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58,
 /*E8   Y     Z                                     */
     0x59, 0x5A, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
 /*F0   0     1     2     3     4     5     6     7 */
     0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37,
 /*F8   8     9                                     */
     0x38, 0x39, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF
};

/* EBCDIC translation tables needed for 3270 support.  */

static void
i370_ebcdic (int unused ATTRIBUTE_UNUSED)
{
  char *p, *end;
  char delim = 0;
  size_t nbytes;

  nbytes = strlen (input_line_pointer);
  end = input_line_pointer + nbytes;
  while ('\r' == *end) end --;
  while ('\n' == *end) end --;

  delim = *input_line_pointer;
  if (('\'' == delim) || ('\"' == delim))
    {
      input_line_pointer ++;
      end = rindex (input_line_pointer, delim);
    }

  if (end > input_line_pointer)
    {
      nbytes = end - input_line_pointer +1;
      p = frag_more (nbytes);
      while (end > input_line_pointer)
	{
	  *p = ascebc [(unsigned char) (*input_line_pointer)];
	  ++p; ++input_line_pointer;
	}
      *p = '\0';
    }
  if (delim == *input_line_pointer) ++input_line_pointer;
}


/* Stub out a couple of routines.  */

static void
i370_rmode (int unused ATTRIBUTE_UNUSED)
{
  as_tsktsk ("rmode ignored");
}

static void
i370_dsect (int sect)
{
  char *save_line = input_line_pointer;
  static char section[] = ".data\n";

  /* Just pretend this is .section .data.  */
  input_line_pointer = section;
  obj_elf_section (sect);

  input_line_pointer = save_line;
}

static void
i370_csect (int unused ATTRIBUTE_UNUSED)
{
  as_tsktsk ("csect not supported");
}


/* DC Define Const  is only partially supported.
   For samplecode on what to do, look at i370_elf_cons() above.
   This code handles pseudoops of the style
   DC   D'3.141592653'   # in sysv4, .double 3.14159265
   DC   F'1'             # in sysv4, .long   1.  */

static void
i370_dc (int unused ATTRIBUTE_UNUSED)
{
  char * p, tmp[50];
  int nbytes=0;
  expressionS exp;
  char type=0;
  char * clse;

  if (is_it_end_of_statement ())
    {
      demand_empty_rest_of_line ();
      return;
    }

  /* Figure out the size.  */
  type = *input_line_pointer++;
  switch (type)
    {
    case 'H':  /* 16-bit */
      nbytes = 2;
      break;
    case 'E':  /* 32-bit */
    case 'F':  /* 32-bit */
      nbytes = 4;
      break;
    case 'D':  /* 64-bit */
      nbytes = 8;
      break;
    default:
      as_bad (_("unsupported DC type"));
      return;
    }

  /* Get rid of pesky quotes.  */
  if ('\'' == *input_line_pointer)
    {
      ++input_line_pointer;
      clse = strchr (input_line_pointer, '\'');
      if (clse)
	*clse= ' ';
      else
	as_bad (_("missing end-quote"));
    }

  if ('\"' == *input_line_pointer)
    {
      ++input_line_pointer;
      clse = strchr (input_line_pointer, '\"');
      if (clse)
	*clse= ' ';
      else
	as_bad (_("missing end-quote"));
    }

  switch (type)
    {
    case 'H':  /* 16-bit */
    case 'F':  /* 32-bit */
      expression (&exp);
      emit_expr (&exp, nbytes);
      break;
    case 'E':  /* 32-bit */
      type = 'f';
    case 'D':  /* 64-bit */
      md_atof (type, tmp, &nbytes);
      p = frag_more (nbytes);
      memcpy (p, tmp, nbytes);
      break;
    default:
      as_bad (_("unsupported DC type"));
      return;
    }

  demand_empty_rest_of_line ();
}


/* Provide minimal support for DS Define Storage.  */

static void
i370_ds (int unused ATTRIBUTE_UNUSED)
{
  /* DS 0H or DS 0F or DS 0D.  */
  if ('0' == *input_line_pointer)
    {
      int alignment = 0;  /* Left shift 1 << align.  */
      input_line_pointer ++;
      switch (*input_line_pointer++)
	{
	case 'H':  /* 16-bit */
	  alignment = 1;
	  break;
	case 'F':  /* 32-bit */
	  alignment = 2;
	  break;
	case 'D':  /* 64-bit */
	  alignment = 3;
	  break;
	default:
	  as_bad (_("unsupported alignment"));
	  return;
	}
      frag_align (alignment, 0, 0);
      record_alignment (now_seg, alignment);
    }
  else
    as_bad (_("this DS form not yet supported"));
}

/* Solaris pseudo op to change to the .rodata section.  */

static void
i370_elf_rdata (int sect)
{
  char *save_line = input_line_pointer;
  static char section[] = ".rodata\n";

  /* Just pretend this is .section .rodata.  */
  input_line_pointer = section;
  obj_elf_section (sect);

  input_line_pointer = save_line;
}

/* Pseudo op to make file scope bss items.  */

static void
i370_elf_lcomm (int unused ATTRIBUTE_UNUSED)
{
  char *name;
  char c;
  char *p;
  offsetT size;
  symbolS *symbolP;
  offsetT align;
  segT old_sec;
  int old_subsec;
  char *pfrag;
  int align2;

  name = input_line_pointer;
  c = get_symbol_end ();

  /* Just after name is now '\0'.  */
  p = input_line_pointer;
  *p = c;
  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
      as_bad (_("Expected comma after symbol-name: rest of line ignored."));
      ignore_rest_of_line ();
      return;
    }

  /* Skip ','.  */
  input_line_pointer++;
  if ((size = get_absolute_expression ()) < 0)
    {
      as_warn (_(".COMMon length (%ld.) <0! Ignored."), (long) size);
      ignore_rest_of_line ();
      return;
    }

  /* The third argument to .lcomm is the alignment.  */
  if (*input_line_pointer != ',')
    align = 8;
  else
    {
      ++input_line_pointer;
      align = get_absolute_expression ();
      if (align <= 0)
        {
          as_warn (_("ignoring bad alignment"));
          align = 8;
        }
    }

  *p = 0;
  symbolP = symbol_find_or_make (name);
  *p = c;

  if (S_IS_DEFINED (symbolP) && ! S_IS_COMMON (symbolP))
    {
      as_bad (_("Ignoring attempt to re-define symbol `%s'."),
              S_GET_NAME (symbolP));
      ignore_rest_of_line ();
      return;
    }

  if (S_GET_VALUE (symbolP) && S_GET_VALUE (symbolP) != (valueT) size)
    {
      as_bad (_("Length of .lcomm \"%s\" is already %ld. Not changed to %ld."),
              S_GET_NAME (symbolP),
              (long) S_GET_VALUE (symbolP),
              (long) size);

      ignore_rest_of_line ();
      return;
    }

  /* Allocate_bss:  */
  old_sec = now_seg;
  old_subsec = now_subseg;
  if (align)
    {
      /* Convert to a power of 2 alignment.  */
      for (align2 = 0; (align & 1) == 0; align >>= 1, ++align2)
	;
      if (align != 1)
        {
          as_bad (_("Common alignment not a power of 2"));
          ignore_rest_of_line ();
          return;
        }
    }
  else
    align2 = 0;

  record_alignment (bss_section, align2);
  subseg_set (bss_section, 0);
  if (align2)
    frag_align (align2, 0, 0);
  if (S_GET_SEGMENT (symbolP) == bss_section)
    symbol_get_frag (symbolP)->fr_symbol = 0;
  symbol_set_frag (symbolP, frag_now);
  pfrag = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP, size,
        	    (char *) 0);
  *pfrag = 0;
  S_SET_SIZE (symbolP, size);
  S_SET_SEGMENT (symbolP, bss_section);
  subseg_set (old_sec, old_subsec);
  demand_empty_rest_of_line ();
}

/* Validate any relocations emitted for -mrelocatable, possibly adding
   fixups for word relocations in writable segments, so we can adjust
   them at runtime.  */

static void
i370_elf_validate_fix (fixS *fixp, segT seg)
{
  if (fixp->fx_done || fixp->fx_pcrel)
    return;

  switch (shlib)
    {
    case SHLIB_NONE:
    case SHLIB_PIC:
      return;

    case SHILB_MRELOCATABLE:
      if (fixp->fx_r_type <= BFD_RELOC_UNUSED
          && fixp->fx_r_type != BFD_RELOC_16_GOTOFF
          && fixp->fx_r_type != BFD_RELOC_HI16_GOTOFF
          && fixp->fx_r_type != BFD_RELOC_LO16_GOTOFF
          && fixp->fx_r_type != BFD_RELOC_HI16_S_GOTOFF
          && fixp->fx_r_type != BFD_RELOC_32_BASEREL
          && fixp->fx_r_type != BFD_RELOC_LO16_BASEREL
          && fixp->fx_r_type != BFD_RELOC_HI16_BASEREL
          && fixp->fx_r_type != BFD_RELOC_HI16_S_BASEREL
          && strcmp (segment_name (seg), ".got2") != 0
          && strcmp (segment_name (seg), ".dtors") != 0
          && strcmp (segment_name (seg), ".ctors") != 0
          && strcmp (segment_name (seg), ".fixup") != 0
          && strcmp (segment_name (seg), ".stab") != 0
          && strcmp (segment_name (seg), ".gcc_except_table") != 0
          && strcmp (segment_name (seg), ".ex_shared") != 0)
        {
          if ((seg->flags & (SEC_READONLY | SEC_CODE)) != 0
              || fixp->fx_r_type != BFD_RELOC_CTOR)
	    as_bad_where (fixp->fx_file, fixp->fx_line,
			  "Relocation cannot be done when using -mrelocatable");
        }
      return;
    default:
      break;
    }
}
#endif /* OBJ_ELF */


#define LITERAL_POOL_SUPPORT
#ifdef LITERAL_POOL_SUPPORT
/* Provide support for literal pools within the text section.
   Loosely based on similar code from tc-arm.c.
   We will use four symbols to locate four parts of the literal pool.
   These four sections contain 64,32,16 and 8-bit constants; we use
   four sections so that all memory access can be appropriately aligned.
   That is, we want to avoid mixing these together so that we don't
   waste space padding out to alignments.  The four pointers
   longlong_poolP, word_poolP, etc. point to a symbol labeling the
   start of each pool part.
 
   lit_pool_num increments from zero to infinity and uniquely id's
     -- its used to generate the *_poolP symbol name.  */

#define MAX_LITERAL_POOL_SIZE 1024

typedef struct literalS
{
  struct expressionS  exp;
  char * sym_name;
  char size;  /* 1,2,4 or 8 */
  short offset;
} literalT;

literalT literals[MAX_LITERAL_POOL_SIZE];
int next_literal_pool_place = 0; /* Next free entry in the pool.  */

static symbolS *longlong_poolP = NULL;   /* 64-bit pool entries.  */
static symbolS *word_poolP = NULL;       /* 32-bit pool entries.  */
static symbolS *short_poolP = NULL;      /* 16-bit pool entries.  */
static symbolS *byte_poolP = NULL;       /* 8-bit  pool entries.  */

static int lit_pool_num = 1;

/* Create a new, empty symbol.  */
static symbolS *
symbol_make_empty (void)
{
  return symbol_create (FAKE_LABEL_NAME, undefined_section,
  			(valueT) 0, &zero_address_frag);
}

/* Make the first argument an address-relative expression
   by subtracting the second argument.  */

static void
i370_make_relative (expressionS *exx, expressionS *baseaddr)
{
  if (O_constant == baseaddr->X_op)
    {
       exx->X_op = O_symbol;
       exx->X_add_number -= baseaddr->X_add_number;
    }
  else if (O_symbol == baseaddr->X_op)
    {
       exx->X_op = O_subtract;
       exx->X_op_symbol = baseaddr->X_add_symbol;
       exx->X_add_number -= baseaddr->X_add_number;
    }
  else if (O_uminus == baseaddr->X_op)
    {
       exx->X_op = O_add;
       exx->X_op_symbol = baseaddr->X_add_symbol;
       exx->X_add_number += baseaddr->X_add_number;
    }
  else
    as_bad (_("Missing or bad .using directive"));
}
/* Add an expression to the literal pool.  */

static  void
add_to_lit_pool (expressionS *exx, char *name, int sz)
{
  int lit_count = 0;
  int offset_in_pool = 0;

  /* Start a new pool, if necessary.  */
  if (8 == sz && NULL == longlong_poolP)
    longlong_poolP = symbol_make_empty ();
  else if (4 == sz && NULL == word_poolP)
    word_poolP = symbol_make_empty ();
  else if (2 == sz && NULL == short_poolP)
    short_poolP = symbol_make_empty ();
  else if (1 == sz && NULL == byte_poolP)
    byte_poolP = symbol_make_empty ();

  /* Check if this literal value is already in the pool.
     FIXME: We should probably be checking expressions
            of type O_symbol as well.
     FIXME: This is probably(certainly?) broken for O_big,
            which includes 64-bit long-longs.  */
  while (lit_count < next_literal_pool_place)
    {
      if (exx->X_op == O_constant
          && literals[lit_count].exp.X_op == exx->X_op
          && literals[lit_count].exp.X_add_number == exx->X_add_number
          && literals[lit_count].exp.X_unsigned == exx->X_unsigned
          && literals[lit_count].size == sz)
        break;
      else if (literals[lit_count].sym_name
	       && name
	       && !strcmp (name, literals[lit_count].sym_name))
        break;
      if (sz == literals[lit_count].size)
	offset_in_pool += sz;
      lit_count ++;
    }

  if (lit_count == next_literal_pool_place) /* new entry */
    {
      if (next_literal_pool_place > MAX_LITERAL_POOL_SIZE)
	as_bad (_("Literal Pool Overflow"));

      literals[next_literal_pool_place].exp = *exx;
      literals[next_literal_pool_place].size = sz;
      literals[next_literal_pool_place].offset = offset_in_pool;
      if (name)
	literals[next_literal_pool_place].sym_name = strdup (name);
      else
	literals[next_literal_pool_place].sym_name = NULL;
      next_literal_pool_place++;
    }

  /* ???_poolP points to the beginning of the literal pool.
     X_add_number is the offset from the beginning of the
     literal pool to this expr minus the location of the most
     recent .using directive.  Thus, the grand total value of the
     expression is the distance from .using to the literal.  */
  if (8 == sz)
    exx->X_add_symbol = longlong_poolP;
  else if (4 == sz)
    exx->X_add_symbol = word_poolP;
  else if (2 == sz)
    exx->X_add_symbol = short_poolP;
  else if (1 == sz)
    exx->X_add_symbol = byte_poolP;
  exx->X_add_number = offset_in_pool;
  exx->X_op_symbol = NULL;

  /* If the user has set up a base reg in another section,
     use that; otherwise use the text section.  */
  if (0 < i370_using_other_regno)
    i370_make_relative (exx, &i370_using_other_baseaddr);
  else
    i370_make_relative (exx, &i370_using_text_baseaddr);
}

/* The symbol setup for the literal pool is done in two steps.  First,
   a symbol that represents the start of the literal pool is created,
   above, in the add_to_pool() routine. This sym ???_poolP.
   However, we don't know what fragment its in until a bit later.
   So we defer the frag_now thing, and the symbol name, until .ltorg time.  */

/* Can't use symbol_new here, so have to create a symbol and then at
   a later date assign it a value. Thats what these functions do.  */

static void
symbol_locate (symbolS *symbolP,
	       const char *name,	/* It is copied, the caller can modify.  */
	       segT segment,		/* Segment identifier (SEG_<something>).  */
	       valueT valu,		/* Symbol value.  */
	       fragS *frag)		/* Associated fragment.  */
{
  size_t name_length;
  char *preserved_copy_of_name;

  name_length = strlen (name) + 1;      /* +1 for \0 */
  obstack_grow (&notes, name, name_length);
  preserved_copy_of_name = obstack_finish (&notes);

  S_SET_NAME (symbolP, preserved_copy_of_name);

  S_SET_SEGMENT (symbolP, segment);
  S_SET_VALUE (symbolP, valu);
  symbol_clear_list_pointers (symbolP);

  symbol_set_frag (symbolP, frag);

  /* Link to end of symbol chain.  */
  {
    extern int symbol_table_frozen;

    if (symbol_table_frozen)
      abort ();
  }

  symbol_append (symbolP, symbol_lastP, &symbol_rootP, &symbol_lastP);

  obj_symbol_new_hook (symbolP);

#ifdef tc_symbol_new_hook
  tc_symbol_new_hook (symbolP);
#endif

#define DEBUG_SYMS
#ifdef DEBUG_SYMS
  verify_symbol_chain(symbol_rootP, symbol_lastP);
#endif /* DEBUG_SYMS */
}

/* i370_addr_offset() will convert operand expressions
   that appear to be absolute into thier base-register
   relative form.  These expressions come in two types:

   (1) of the form "* + const" * where "*" means
   relative offset since the last using
   i.e. "*" means ".-using_baseaddr"

   (2) labels, which are never absolute, but are always
   relative to the last "using".  Anything with an alpha
   character is considered to be a label (since symbols
   can never be operands), and since we've already handled
   register operands. For example, "BL .L33" branch low
   to .L33 RX form insn frequently terminates for-loops.  */

static bfd_boolean
i370_addr_offset (expressionS *exx)
{
  char *dot, *lab;
  int islabel = 0;
  int all_digits = 0;

  /* Search for a label; anything with an alpha char will do.
     Local labels consist of N digits followed by either b or f.  */
  lab = input_line_pointer;
  while (*lab && (',' != *lab) && ('(' != *lab))
    {
      if (ISDIGIT (*lab))
	all_digits = 1;
      else if (ISALPHA (*lab))
	{
	  if (!all_digits)
	    {
	      islabel = 1;
	      break;
	    }
	  else if (('f' == *lab) || ('b' == *lab))
	    {
	      islabel = 1;
	      break;
	    }
	  if (all_digits)
	    break;
	}
      else if ('.' != *lab)
        break;
      ++lab;
    }

  /* See if operand has a * in it.  */
  dot = strchr (input_line_pointer, '*');

  if (!dot && !islabel)
    return FALSE;

  /* Replace * with . and let expr munch on it.  */
  if (dot)
    *dot = '.';
  expression (exx);

  /* OK, now we have to subtract the "using" location.
     Normally branches appear in the text section only.  */
  if (0 == strncmp (now_seg->name, ".text", 5) || 0 > i370_using_other_regno)
    i370_make_relative (exx, &i370_using_text_baseaddr);
  else
    i370_make_relative (exx, &i370_using_other_baseaddr);

  /* Put the * back.  */
  if (dot)
    *dot = '*';

  return TRUE;
}

/* Handle address constants of various sorts.  */
/* The currently supported types are
      =A(some_symb)
      =V(some_extern)
      =X'deadbeef'    hexadecimal
      =F'1234'        32-bit const int
      =H'1234'        16-bit const int.  */

static bfd_boolean
i370_addr_cons (expressionS *exp)
{
  char *name;
  char *sym_name, delim;
  int name_len;
  int hex_len = 0;
  int cons_len = 0;

  name = input_line_pointer;
  sym_name = input_line_pointer;
  /* Find the spelling of the operand.  */
  if (name[0] == '=' && ISALPHA (name[1]))
    name = ++input_line_pointer;
  else
    return FALSE;

  switch (name[0])
    {
    case 'A': /* A == address-of.  */
    case 'V': /* V == extern.  */
      ++input_line_pointer;
      expression (exp);

      /* We use a simple string name to collapse together
         multiple refrences to the same address literal.  */
      name_len = strcspn (sym_name, ", ");
      delim = *(sym_name + name_len);
      *(sym_name + name_len) = 0x0;
      add_to_lit_pool (exp, sym_name, 4);
      *(sym_name + name_len) = delim;

      break;
    case 'H':
    case 'F':
    case 'X':
    case 'E':  /* Single-precision float point.  */
    case 'D':  /* Double-precision float point.  */

      /* H == 16-bit fixed-point const; expression must be const.  */
      /* F == fixed-point const; expression must be const.  */
      /* X == fixed-point const; expression must be const.  */
      if ('H' == name[0]) cons_len = 2;
      else if ('F' == name[0]) cons_len = 4;
      else if ('X' == name[0]) cons_len = -1;
      else if ('E' == name[0]) cons_len = 4;
      else if ('D' == name[0]) cons_len = 8;

      /* Extract length, if it is present;
	 FIXME: assume single-digit length.  */
      if ('L' == name[1])
	{
	  /* Should work for ASCII and EBCDIC.  */
	  cons_len = name[2] - '0';
	  input_line_pointer += 2;
	}

      ++input_line_pointer;

      /* Get rid of pesky quotes.  */
      if ('\'' == *input_line_pointer)
	{
	  char * clse;

	  ++input_line_pointer;
	  clse = strchr (input_line_pointer, '\'');
	  if (clse)
	    *clse= ' ';
	  else
	    as_bad (_("missing end-quote"));
	}
      if ('\"' == *input_line_pointer)
	{
	  char * clse;

	  ++input_line_pointer;
	  clse = strchr (input_line_pointer, '\"');
	  if (clse)
	    *clse= ' ';
	  else
	    as_bad (_("missing end-quote"));
	}
      if (('X' == name[0]) || ('E' == name[0]) || ('D' == name[0]))
	{
	  char tmp[50];
	  char *save;

	  /* The length of hex constants is specified directly with L,
	     or implied through the number of hex digits. For example:
	     =X'AB'       one byte
	     =X'abcd'     two bytes
	     =X'000000AB' four bytes
	     =XL4'AB'     four bytes, left-padded withn zero.  */
	  if (('X' == name[0]) && (0 > cons_len))
	    {
	      save = input_line_pointer;
	      while (*save)
		{
		  if (ISXDIGIT (*save))
		    hex_len++;
		  save++;
		}
	      cons_len = (hex_len+1) /2;
	    }
	  /* I believe this works even for =XL8'dada0000beeebaaa'
	     which should parse out to X_op == O_big
	     Note that floats and doubles get represented as
	     0d3.14159265358979  or 0f 2.7.  */
	  tmp[0] = '0';
	  tmp[1] = name[0];
	  tmp[2] = 0;
	  strcat (tmp, input_line_pointer);
	  save = input_line_pointer;
	  input_line_pointer = tmp;
	  expression (exp);
	  input_line_pointer = save + (input_line_pointer-tmp-2);

	  /* Fix up lengths for floats and doubles.  */
	  if (O_big == exp->X_op)
	    exp->X_add_number = cons_len / CHARS_PER_LITTLENUM;
	}
      else
	expression (exp);

      /* O_big occurs when more than 4 bytes worth gets parsed.  */
      if ((exp->X_op != O_constant) && (exp->X_op != O_big))
	{
	  as_bad (_("expression not a constant"));
	  return FALSE;
	}
      add_to_lit_pool (exp, 0x0, cons_len);
      break;

    default:
      as_bad (_("Unknown/unsupported address literal type"));
      return FALSE;
    }

  return TRUE;
}


/* Dump the contents of the literal pool that we've accumulated so far.
   This aligns the pool to the size of the largest literal in the pool.  */

static void
i370_ltorg (int ignore ATTRIBUTE_UNUSED)
{
  int litsize;
  int lit_count = 0;
  int biggest_literal_size = 0;
  int biggest_align = 0;
  char pool_name[20];

  if (strncmp (now_seg->name, ".text", 5))
    {
      if (i370_other_section == undefined_section)
	as_bad (_(".ltorg without prior .using in section %s"),
		now_seg->name);

      if (i370_other_section != now_seg)
	as_bad (_(".ltorg in section %s paired to .using in section %s"),
		now_seg->name, i370_other_section->name);
    }

  if (! longlong_poolP
      && ! word_poolP
      && ! short_poolP
      && ! byte_poolP)
    /* Nothing to do.  */
    return;

  /* Find largest literal .. 2 4 or 8.  */
  lit_count = 0;
  while (lit_count < next_literal_pool_place)
    {
      if (biggest_literal_size < literals[lit_count].size)
	biggest_literal_size = literals[lit_count].size;
      lit_count ++;
    }
  if (1 == biggest_literal_size) biggest_align = 0;
  else if (2 == biggest_literal_size) biggest_align = 1;
  else if (4 == biggest_literal_size) biggest_align = 2;
  else if (8 == biggest_literal_size) biggest_align = 3;
  else as_bad (_("bad alignment of %d bytes in literal pool"), biggest_literal_size);
  if (0 == biggest_align) biggest_align = 1;

  /* Align pool for short, word, double word accesses.  */
  frag_align (biggest_align, 0, 0);
  record_alignment (now_seg, biggest_align);

  /* Note that the gas listing will print only the first five
     entries in the pool .... wonder how to make it print more.  */
  /* Output largest literals first, then the smaller ones.  */
  for (litsize=8; litsize; litsize /=2)
    {
      symbolS *current_poolP = NULL;
      switch (litsize)
	{
	case 8:
	  current_poolP = longlong_poolP; break;
	case 4:
	  current_poolP = word_poolP; break;
	case 2:
	  current_poolP = short_poolP; break;
	case 1:
	  current_poolP = byte_poolP; break;
	default:
	  as_bad (_("bad literal size\n"));
	}
      if (NULL == current_poolP)
	continue;
      sprintf (pool_name, ".LITP%01d%06d", litsize, lit_pool_num);
      symbol_locate (current_poolP, pool_name, now_seg,
		     (valueT) frag_now_fix (), frag_now);
      symbol_table_insert (current_poolP);

      lit_count = 0;
      while (lit_count < next_literal_pool_place)
	{
	  if (litsize == literals[lit_count].size)
	    {
#define EMIT_ADDR_CONS_SYMBOLS
#ifdef EMIT_ADDR_CONS_SYMBOLS
	      /* Create a bogus symbol, add it to the pool ...
	         For the most part, I think this is a useless exercise,
	         except that having these symbol names in the objects
	         is vaguely useful for debugging.  */
	      if (literals[lit_count].sym_name)
		{
		  symbolS * symP = symbol_make_empty ();
		  symbol_locate (symP, literals[lit_count].sym_name, now_seg,
				 (valueT) frag_now_fix (), frag_now);
		  symbol_table_insert (symP);
		}
#endif /* EMIT_ADDR_CONS_SYMBOLS */

	      emit_expr (&(literals[lit_count].exp), literals[lit_count].size);
	    }
	  lit_count ++;
	}
    }

  next_literal_pool_place = 0;
  longlong_poolP = NULL;
  word_poolP = NULL;
  short_poolP = NULL;
  byte_poolP = NULL;
  lit_pool_num++;
}

#endif /* LITERAL_POOL_SUPPORT */


/* Add support for the HLASM-like USING directive to indicate
   the base register to use ...  we don't support the full
   hlasm semantics for this ... we merely pluck a base address
   and a register number out.  We print a warning if using is
   called multiple times.  I suppose we should check to see
   if the regno is valid.  */

static void
i370_using (int ignore ATTRIBUTE_UNUSED)
{
  expressionS ex, baseaddr;
  int iregno;
  char *star;

  /* If "*" appears in a using, it means "."
     replace it with "." so that expr doesn't get confused.  */
  star = strchr (input_line_pointer, '*');
  if (star)
    *star = '.';

  /* The first arg to using will usually be ".", but it can
     be a more complex expression too.  */
  expression (&baseaddr);
  if (star)
    *star = '*';
  if (O_constant != baseaddr.X_op
      && O_symbol != baseaddr.X_op
      && O_uminus != baseaddr.X_op)
    as_bad (_(".using: base address expression illegal or too complex"));

  if (*input_line_pointer != '\0') ++input_line_pointer;

  /* The second arg to using had better be a register.  */
  register_name (&ex);
  demand_empty_rest_of_line ();
  iregno = ex.X_add_number;

  if (0 == strncmp (now_seg->name, ".text", 5))
    {
      i370_using_text_baseaddr = baseaddr;
      i370_using_text_regno = iregno;
    }
  else
    {
      i370_using_other_baseaddr = baseaddr;
      i370_using_other_regno = iregno;
      i370_other_section = now_seg;
    }
}

static void
i370_drop (int ignore ATTRIBUTE_UNUSED)
{
  expressionS ex;
  int iregno;

  register_name (&ex);
  demand_empty_rest_of_line ();
  iregno = ex.X_add_number;

  if (0 == strncmp (now_seg->name, ".text", 5))
    {
      if (iregno != i370_using_text_regno)
	as_bad (_("droping register %d in section %s does not match using register %d"),
		iregno, now_seg->name, i370_using_text_regno);

      i370_using_text_regno = -1;
      i370_using_text_baseaddr.X_op = O_absent;
    }
  else
    {
      if (iregno != i370_using_other_regno)
	as_bad (_("droping register %d in section %s does not match using register %d"),
		iregno, now_seg->name, i370_using_other_regno);

      if (i370_other_section != now_seg)
	as_bad (_("droping register %d in section %s previously used in section %s"),
		iregno, now_seg->name, i370_other_section->name);

      i370_using_other_regno = -1;
      i370_using_other_baseaddr.X_op = O_absent;
      i370_other_section = undefined_section;
    }
}


/* We need to keep a list of fixups.  We can't simply generate them as
   we go, because that would require us to first create the frag, and
   that would screw up references to ``.''.  */

struct i370_fixup
{
  expressionS exp;
  int opindex;
  bfd_reloc_code_real_type reloc;
};

#define MAX_INSN_FIXUPS 5

/* Handle a macro.  Gather all the operands, transform them as
   described by the macro, and call md_assemble recursively.  All the
   operands are separated by commas; we don't accept parentheses
   around operands here.  */

static void
i370_macro (char *str, const struct i370_macro *macro)
{
  char *operands[10];
  unsigned int count;
  char *s;
  unsigned int len;
  const char *format;
  int arg;
  char *send;
  char *complete;

  /* Gather the users operands into the operands array.  */
  count = 0;
  s = str;
  while (1)
    {
      if (count >= sizeof operands / sizeof operands[0])
        break;
      operands[count++] = s;
      s = strchr (s, ',');
      if (s == (char *) NULL)
        break;
      *s++ = '\0';
    }

  if (count != macro->operands)
    {
      as_bad (_("wrong number of operands"));
      return;
    }

  /* Work out how large the string must be (the size is unbounded
     because it includes user input).  */
  len = 0;
  format = macro->format;
  while (*format != '\0')
    {
      if (*format != '%')
        {
          ++len;
          ++format;
        }
      else
        {
          arg = strtol (format + 1, &send, 10);
          know (send != format && arg >= 0 && (unsigned) arg < count);
          len += strlen (operands[arg]);
          format = send;
        }
    }

  /* Put the string together.  */
  complete = s = alloca (len + 1);
  format = macro->format;
  while (*format != '\0')
    {
      if (*format != '%')
        *s++ = *format++;
      else
        {
          arg = strtol (format + 1, &send, 10);
          strcpy (s, operands[arg]);
          s += strlen (s);
          format = send;
        }
    }
  *s = '\0';

  /* Assemble the constructed instruction.  */
  md_assemble (complete);
}

/* This routine is called for each instruction to be assembled.  */

void
md_assemble (char *str)
{
  char *s;
  const struct i370_opcode *opcode;
  i370_insn_t insn;
  const unsigned char *opindex_ptr;
  int have_optional_index, have_optional_basereg, have_optional_reg;
  int skip_optional_index, skip_optional_basereg, skip_optional_reg;
  int use_text=0, use_other=0;
  int off_by_one;
  struct i370_fixup fixups[MAX_INSN_FIXUPS];
  int fc;
  char *f;
  int i;
#ifdef OBJ_ELF
  bfd_reloc_code_real_type reloc;
#endif

  /* Get the opcode.  */
  for (s = str; *s != '\0' && ! ISSPACE (*s); s++)
    ;
  if (*s != '\0')
    *s++ = '\0';

  /* Look up the opcode in the hash table.  */
  opcode = (const struct i370_opcode *) hash_find (i370_hash, str);
  if (opcode == (const struct i370_opcode *) NULL)
    {
      const struct i370_macro *macro;

      gas_assert (i370_macro_hash);
      macro = (const struct i370_macro *) hash_find (i370_macro_hash, str);
      if (macro == (const struct i370_macro *) NULL)
        as_bad (_("Unrecognized opcode: `%s'"), str);
      else
	i370_macro (s, macro);

      return;
    }

  insn = opcode->opcode;

  str = s;
  while (ISSPACE (*str))
    ++str;

  /* I370 operands are either expressions or address constants.
     Many operand types are optional.  The optional operands
     are always surrounded by parens, and are used to denote the base
     register ... e.g. "A R1, D2" or "A R1, D2(,B2) as opposed to
     the fully-formed "A R1, D2(X2,B2)".  Note also the = sign,
     such as A R1,=A(i) where the address-of operator =A implies
     use of both a base register, and a missing index register.

     So, before we start seriously parsing the operands, we check
     to see if we have an optional operand, and, if we do, we count
     the number of commas to see which operand should be omitted.  */

  have_optional_index = have_optional_basereg = have_optional_reg = 0;
  for (opindex_ptr = opcode->operands; *opindex_ptr != 0; opindex_ptr++)
    {
      const struct i370_operand *operand;

      operand = &i370_operands[*opindex_ptr];
      if ((operand->flags & I370_OPERAND_INDEX) != 0)
	have_optional_index = 1;
      if ((operand->flags & I370_OPERAND_BASE) != 0)
	have_optional_basereg = 1;
      if ((operand->flags & I370_OPERAND_OPTIONAL) != 0)
	have_optional_reg = 1;
    }

  skip_optional_index = skip_optional_basereg = skip_optional_reg = 0;
  if (have_optional_index || have_optional_basereg)
    {
      unsigned int opcount, nwanted;

      /* There is an optional operand.  Count the number of
	 commas and open-parens in the input line.  */
      if (*str == '\0')
	opcount = 0;
      else
	{
	  opcount = 1;
	  s = str;
	  while ((s = strpbrk (s, ",(=")) != (char *) NULL)
	    {
	      ++opcount;
	      ++s;
	      if (',' == *s) ++s;  /* avoid counting things like (, */
	      if ('=' == *s) { ++s; --opcount; }
	    }
	}

      /* If there are fewer operands in the line then are called
	 for by the instruction, we want to skip the optional
	 operand.  */
      nwanted = strlen ((char *) opcode->operands);
      if (have_optional_index)
	{
	  if (opcount < nwanted)
	    skip_optional_index = 1;
	  if (have_optional_basereg && ((opcount+1) < nwanted))
	    skip_optional_basereg = 1;
	  if (have_optional_reg && ((opcount+1) < nwanted))
	    skip_optional_reg = 1;
	}
      else
	{
	  if (have_optional_basereg && (opcount < nwanted))
	    skip_optional_basereg = 1;
	  if (have_optional_reg && (opcount < nwanted))
	    skip_optional_reg = 1;
	}
    }

  /* Perform some off-by-one hacks on the length field of certain instructions.
     Its such a shame to have to do this, but the problem is that HLASM got
     defined so that the lengths differ by one from the actual machine instructions.
     this code should probably be moved to a special inster-operand routine.
     Sigh. Affected instructions are Compare Logical, Move and Exclusive OR
     hack alert -- aren't *all* SS instructions affected ??  */
  off_by_one = 0;
  if (0 == strcasecmp ("CLC", opcode->name)
      || 0 == strcasecmp ("ED", opcode->name)
      || 0 == strcasecmp ("EDMK", opcode->name)
      || 0 == strcasecmp ("MVC", opcode->name)
      || 0 == strcasecmp ("MVCIN", opcode->name)
      || 0 == strcasecmp ("MVN", opcode->name)
      || 0 == strcasecmp ("MVZ", opcode->name)
      || 0 == strcasecmp ("NC", opcode->name)
      || 0 == strcasecmp ("OC", opcode->name)
      || 0 == strcasecmp ("XC", opcode->name))
    off_by_one = 1;

  /* Gather the operands.  */
  fc = 0;
  for (opindex_ptr = opcode->operands; *opindex_ptr != 0; opindex_ptr++)
    {
      const struct i370_operand *operand;
      char *hold;
      expressionS ex;

      operand = &i370_operands[*opindex_ptr];

      /* If this is an index operand, and we are skipping it,
	 just insert a zero.  */
      if (skip_optional_index &&
	  ((operand->flags & I370_OPERAND_INDEX) != 0))
        {
          insn = i370_insert_operand (insn, operand, 0);
          continue;
        }

      /* If this is the base operand, and we are skipping it,
	 just insert the current using basreg.  */
      if (skip_optional_basereg &&
          ((operand->flags & I370_OPERAND_BASE) != 0))
        {
          int basereg = -1;
          if (use_text)
            {
              if (0 == strncmp (now_seg->name, ".text", 5)
		  || 0 > i370_using_other_regno)
		basereg = i370_using_text_regno;
              else
		basereg = i370_using_other_regno;
            }
          else if (use_other)
            {
              if (0 > i370_using_other_regno)
		basereg = i370_using_text_regno;
              else
		basereg = i370_using_other_regno;
            }
          if (0 > basereg)
	    as_bad (_("not using any base register"));

          insn = i370_insert_operand (insn, operand, basereg);
          continue;
        }

      /* If this is an optional operand, and we are skipping it,
	 Use zero (since a non-zero value would denote a register)  */
      if (skip_optional_reg
	  && ((operand->flags & I370_OPERAND_OPTIONAL) != 0))
        {
          insn = i370_insert_operand (insn, operand, 0);
          continue;
        }

      /* Gather the operand.  */
      hold = input_line_pointer;
      input_line_pointer = str;

      /* Register names are only allowed where there are registers.  */
      if ((operand->flags & I370_OPERAND_GPR) != 0)
        {
          /* Quickie hack to get past things like (,r13).  */
          if (skip_optional_index && (',' == *input_line_pointer))
            {
              *input_line_pointer = ' ';
              input_line_pointer ++;
            }

          if (! register_name (&ex))
	    as_bad (_("expecting a register for operand %d"),
		    (int) (opindex_ptr - opcode->operands + 1));
        }

      /* Check for an address constant expression.  */
      /* We will put PSW-relative addresses in the text section,
         and address literals in the .data (or other) section.  */
      else if (i370_addr_cons (&ex))
	use_other = 1;
      else if (i370_addr_offset (&ex))
	use_text = 1;
      else expression (&ex);

      str = input_line_pointer;
      input_line_pointer = hold;

      /* Perform some off-by-one hacks on the length field of certain instructions.
         Its such a shame to have to do this, but the problem is that HLASM got
         defined so that the programmer specifies a length that is one greater
         than what the machine instruction wants.  Sigh.  */
      if (off_by_one && (0 == strcasecmp ("SS L", operand->name)))
	ex.X_add_number --;

      if (ex.X_op == O_illegal)
        as_bad (_("illegal operand"));
      else if (ex.X_op == O_absent)
        as_bad (_("missing operand"));
      else if (ex.X_op == O_register)
	insn = i370_insert_operand (insn, operand, ex.X_add_number);
      else if (ex.X_op == O_constant)
        {
#ifdef OBJ_ELF
          /* Allow @@HA, @@L, @@H on constants.
             Well actually, no we don't; there really don't make sense
             (at least not to me) for the i370.  However, this code is
             left here for any dubious future expansion reasons.  */
          char *orig_str = str;

          if ((reloc = i370_elf_suffix (&str, &ex)) != BFD_RELOC_UNUSED)
            switch (reloc)
              {
              default:
        	str = orig_str;
        	break;

              case BFD_RELOC_LO16:
        	/* X_unsigned is the default, so if the user has done
                   something which cleared it, we always produce a
                   signed value.  */
		ex.X_add_number = (((ex.X_add_number & 0xffff)
				    ^ 0x8000)
				   - 0x8000);
        	break;

              case BFD_RELOC_HI16:
        	ex.X_add_number = (ex.X_add_number >> 16) & 0xffff;
        	break;

              case BFD_RELOC_HI16_S:
        	ex.X_add_number = (((ex.X_add_number >> 16) & 0xffff)
        			   + ((ex.X_add_number >> 15) & 1));
        	break;
              }
#endif
          insn = i370_insert_operand (insn, operand, ex.X_add_number);
        }
#ifdef OBJ_ELF
      else if ((reloc = i370_elf_suffix (&str, &ex)) != BFD_RELOC_UNUSED)
        {
          as_tsktsk ("md_assemble(): suffixed relocations not supported\n");

          /* We need to generate a fixup for this expression.  */
          if (fc >= MAX_INSN_FIXUPS)
            as_fatal ("too many fixups");
          fixups[fc].exp = ex;
          fixups[fc].opindex = 0;
          fixups[fc].reloc = reloc;
          ++fc;
        }
#endif /* OBJ_ELF */
      else
        {
          /* We need to generate a fixup for this expression.  */
          /* Typically, the expression will just be a symbol ...
               printf ("insn %s needs fixup for %s \n",
                    opcode->name, ex.X_add_symbol->bsym->name);  */

          if (fc >= MAX_INSN_FIXUPS)
            as_fatal ("too many fixups");
          fixups[fc].exp = ex;
          fixups[fc].opindex = *opindex_ptr;
          fixups[fc].reloc = BFD_RELOC_UNUSED;
          ++fc;
        }

      /* Skip over delimiter (close paren, or comma).  */
      if ((')' == *str) && (',' == *(str+1)))
	++str;
      if (*str != '\0')
	++str;
    }

  while (ISSPACE (*str))
    ++str;

  if (*str != '\0')
    as_bad (_("junk at end of line: `%s'"), str);

  /* Write out the instruction.  */
  f = frag_more (opcode->len);
  if (4 >= opcode->len)
    md_number_to_chars (f, insn.i[0], opcode->len);
  else
    {
      md_number_to_chars (f, insn.i[0], 4);

      if (6 == opcode->len)
	md_number_to_chars ((f + 4), ((insn.i[1])>>16), 2);
      else
	{
	  /* Not used --- don't have any 8 byte instructions.  */
	  as_bad (_("Internal Error: bad instruction length"));
	  md_number_to_chars ((f + 4), insn.i[1], opcode->len -4);
	}
    }

  /* Create any fixups.  At this point we do not use a
     bfd_reloc_code_real_type, but instead just use the
     BFD_RELOC_UNUSED plus the operand index.  This lets us easily
     handle fixups for any operand type, although that is admittedly
     not a very exciting feature.  We pick a BFD reloc type in
     md_apply_fix.  */
  for (i = 0; i < fc; i++)
    {
      const struct i370_operand *operand;

      operand = &i370_operands[fixups[i].opindex];
      if (fixups[i].reloc != BFD_RELOC_UNUSED)
	{
	  reloc_howto_type *reloc_howto = bfd_reloc_type_lookup (stdoutput, fixups[i].reloc);
	  int size;
	  fixS *fixP;

	  if (!reloc_howto)
	    abort ();

	  size = bfd_get_reloc_size (reloc_howto);

	  if (size < 1 || size > 4)
	    abort ();

	  printf (" gwana doo fixup %d \n", i);
	  fixP = fix_new_exp (frag_now, f - frag_now->fr_literal, size,
         		      &fixups[i].exp, reloc_howto->pc_relative,
         		      fixups[i].reloc);

	  /* Turn off complaints that the addend is too large for things like
	     foo+100000@@ha.  */
	  switch (fixups[i].reloc)
	    {
	    case BFD_RELOC_16_GOTOFF:
	    case BFD_RELOC_LO16:
	    case BFD_RELOC_HI16:
	    case BFD_RELOC_HI16_S:
	      fixP->fx_no_overflow = 1;
	      break;
	    default:
	      break;
	    }
	}
      else
	{
	  fix_new_exp (frag_now, f - frag_now->fr_literal, opcode->len,
		       &fixups[i].exp,
		       (operand->flags & I370_OPERAND_RELATIVE) != 0,
		       ((bfd_reloc_code_real_type)
			(fixups[i].opindex + (int) BFD_RELOC_UNUSED)));
	}
    }
}


/* Pseudo-op handling.  */

/* The .byte pseudo-op.  This is similar to the normal .byte
   pseudo-op, but it can also take a single ASCII string.  */

static void
i370_byte (int ignore ATTRIBUTE_UNUSED)
{
  if (*input_line_pointer != '\"')
    {
      cons (1);
      return;
    }

  /* Gather characters.  A real double quote is doubled.  Unusual
     characters are not permitted.  */
  ++input_line_pointer;
  while (1)
    {
      char c;

      c = *input_line_pointer++;

      if (c == '\"')
        {
        if (*input_line_pointer != '\"')
            break;
          ++input_line_pointer;
        }

      FRAG_APPEND_1_CHAR (c);
    }

  demand_empty_rest_of_line ();
}

/* The .tc pseudo-op.  This is used when generating XCOFF and ELF.
   This takes two or more arguments.

   When generating XCOFF output, the first argument is the name to
   give to this location in the toc; this will be a symbol with class
   TC.  The rest of the arguments are 4 byte values to actually put at
   this location in the TOC; often there is just one more argument, a
   relocatable symbol reference.

   When not generating XCOFF output, the arguments are the same, but
   the first argument is simply ignored.  */

static void
i370_tc (int ignore ATTRIBUTE_UNUSED)
{

  /* Skip the TOC symbol name.  */
  while (is_part_of_name (*input_line_pointer)
         || *input_line_pointer == '['
         || *input_line_pointer == ']'
         || *input_line_pointer == '{'
         || *input_line_pointer == '}')
    ++input_line_pointer;

  /* Align to a four byte boundary.  */
  frag_align (2, 0, 0);
  record_alignment (now_seg, 2);

  if (*input_line_pointer != ',')
    demand_empty_rest_of_line ();
  else
    {
      ++input_line_pointer;
      cons (4);
    }
}

char *
md_atof (int type, char *litp, int *sizep)
{
  /* 360/370/390 have two float formats: an old, funky 360 single-precision
     format, and the ieee format.  Support only the ieee format.  */
  return ieee_md_atof (type, litp, sizep, TRUE);
}

/* Write a value out to the object file, using the appropriate
   endianness.  */

void
md_number_to_chars (char *buf, valueT val, int n)
{
  number_to_chars_bigendian (buf, val, n);
}

/* Align a section (I don't know why this is machine dependent).  */

valueT
md_section_align (asection *seg, valueT addr)
{
  int align = bfd_get_section_alignment (stdoutput, seg);

  return (addr + (1 << align) - 1) & (-1 << align);
}

/* We don't have any form of relaxing.  */

int
md_estimate_size_before_relax (fragS *fragp ATTRIBUTE_UNUSED,
			       asection *seg ATTRIBUTE_UNUSED)
{
  abort ();
  return 0;
}

/* Convert a machine dependent frag.  We never generate these.  */

void
md_convert_frag (bfd *abfd ATTRIBUTE_UNUSED,
		 asection *sec ATTRIBUTE_UNUSED,
		 fragS *fragp ATTRIBUTE_UNUSED)
{
  abort ();
}

/* We have no need to default values of symbols.  */

symbolS *
md_undefined_symbol (char *name ATTRIBUTE_UNUSED)
{
  return 0;
}

/* Functions concerning relocs.  */

/* The location from which a PC relative jump should be calculated,
   given a PC relative reloc.  */

long
md_pcrel_from_section (fixS *fixp, segT sec ATTRIBUTE_UNUSED)
{
  return fixp->fx_frag->fr_address + fixp->fx_where;
}

/* Apply a fixup to the object code.  This is called for all the
   fixups we generated by the call to fix_new_exp, above.  In the call
   above we used a reloc code which was the largest legal reloc code
   plus the operand index.  Here we undo that to recover the operand
   index.  At this point all symbol values should be fully resolved,
   and we attempt to completely resolve the reloc.  If we can not do
   that, we determine the correct reloc code and put it back in the
   fixup.

   See gas/cgen.c for more sample code and explanations of what's
   going on here.  */

void
md_apply_fix (fixS *fixP, valueT * valP, segT seg)
{
  valueT value = * valP;

  if (fixP->fx_addsy != NULL)
    {
#ifdef DEBUG
      printf ("\nmd_apply_fix: symbol %s at 0x%x (%s:%d) val=0x%x addend=0x%x\n",
	      S_GET_NAME (fixP->fx_addsy),
	      fixP->fx_frag->fr_address + fixP->fx_where,
	      fixP->fx_file, fixP->fx_line,
	      S_GET_VALUE (fixP->fx_addsy), value);
#endif
    }
  else
    fixP->fx_done = 1;

  /* Apply fixups to operands.  Note that there should be no relocations
     for any operands, since no instruction ever takes an operand
     that requires reloc.  */
  if ((int) fixP->fx_r_type >= (int) BFD_RELOC_UNUSED)
    {
      int opindex;
      const struct i370_operand *operand;
      char *where;
      i370_insn_t insn;

      opindex = (int) fixP->fx_r_type - (int) BFD_RELOC_UNUSED;

      operand = &i370_operands[opindex];

#ifdef DEBUG
      printf ("\nmd_apply_fix: fixup operand %s at 0x%x in %s:%d addend=0x%x\n",
	      operand->name,
	      fixP->fx_frag->fr_address + fixP->fx_where,
	      fixP->fx_file, fixP->fx_line,
	      value);
#endif
      /* Fetch the instruction, insert the fully resolved operand
         value, and stuff the instruction back again.
         fisxp->fx_size is the length of the instruction.  */
      where = fixP->fx_frag->fr_literal + fixP->fx_where;
      insn.i[0] = bfd_getb32 ((unsigned char *) where);

      if (6 <= fixP->fx_size)
	/* Deal with 48-bit insn's.  */
	insn.i[1] = bfd_getb32 (((unsigned char *) where)+4);

      insn = i370_insert_operand (insn, operand, (offsetT) value);
      bfd_putb32 ((bfd_vma) insn.i[0], (unsigned char *) where);

      if (6 <= fixP->fx_size)
	/* Deal with 48-bit insn's.  */
	bfd_putb32 ((bfd_vma) insn.i[1], (((unsigned char *) where)+4));

      /* We are done, right? right !!  */
      fixP->fx_done = 1;
      if (fixP->fx_done)
	/* Nothing else to do here.  */
	return;

      /* Determine a BFD reloc value based on the operand information.
	 We are only prepared to turn a few of the operands into
	 relocs.  In fact, we support *zero* operand relocations ...
	 Why?  Because we are not expecting the compiler to generate
	 any operands that need relocation.  Due to the 12-bit naturew of
	 i370 addressing, this would be unusual.  */
        {
          char *sfile;
          unsigned int sline;

          /* Use expr_symbol_where to see if this is an expression
             symbol.  */
          if (expr_symbol_where (fixP->fx_addsy, &sfile, &sline))
            as_bad_where (fixP->fx_file, fixP->fx_line,
        		  "unresolved expression that must be resolved");
          else
            as_bad_where (fixP->fx_file, fixP->fx_line,
        		  "unsupported relocation type");
          fixP->fx_done = 1;
          return;
        }
    }
  else
    {
      /* We branch to here if the fixup is not to a symbol that
         appears in an instruction operand, but is rather some
         declared storage.  */
#ifdef OBJ_ELF
      i370_elf_validate_fix (fixP, seg);
#endif
#ifdef DEBUG
      printf ("md_apply_fix: reloc case %d in segment  %s %s:%d\n",
	      fixP->fx_r_type, segment_name (seg), fixP->fx_file, fixP->fx_line);
      printf ("\tcurrent fixup value is 0x%x \n", value);
#endif
      switch (fixP->fx_r_type)
        {
        case BFD_RELOC_32:
        case BFD_RELOC_CTOR:
          if (fixP->fx_pcrel)
            fixP->fx_r_type = BFD_RELOC_32_PCREL;
	  /* Fall through.  */

        case BFD_RELOC_RVA:
        case BFD_RELOC_32_PCREL:
        case BFD_RELOC_32_BASEREL:
#ifdef DEBUG
          printf ("\t32 bit relocation at 0x%x\n",
		  fixP->fx_frag->fr_address + fixP->fx_where);
#endif
          md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
        		      value, 4);
          break;

        case BFD_RELOC_LO16:
        case BFD_RELOC_16:
          if (fixP->fx_pcrel)
            as_bad_where (fixP->fx_file, fixP->fx_line,
        		  "cannot emit PC relative %s relocation%s%s",
        		  bfd_get_reloc_code_name (fixP->fx_r_type),
        		  fixP->fx_addsy != NULL ? " against " : "",
        		  (fixP->fx_addsy != NULL
        		   ? S_GET_NAME (fixP->fx_addsy)
        		   : ""));

          md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
        		      value, 2);
          break;

          /* This case happens when you write, for example,
             lis %r3,(L1-L2)@@ha
             where L1 and L2 are defined later.  */
        case BFD_RELOC_HI16:
          if (fixP->fx_pcrel)
            abort ();
          md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
        		      value >> 16, 2);
          break;
        case BFD_RELOC_HI16_S:
          if (fixP->fx_pcrel)
            abort ();
          md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
        		      (value + 0x8000) >> 16, 2);
          break;

        case BFD_RELOC_8:
          if (fixP->fx_pcrel)
            abort ();

          md_number_to_chars (fixP->fx_frag->fr_literal + fixP->fx_where,
        		      value, 1);
          break;

        default:
          fprintf (stderr,
        	  "Gas failure, reloc value %d\n", fixP->fx_r_type);
          fflush (stderr);
          abort ();
        }
    }

  fixP->fx_addnumber = value;
}

/* Generate a reloc for a fixup.  */

arelent *
tc_gen_reloc (asection *seg ATTRIBUTE_UNUSED, fixS *fixp)
{
  arelent *reloc;

  reloc = xmalloc (sizeof (arelent));

  reloc->sym_ptr_ptr = xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixp->fx_addsy);
  reloc->address = fixp->fx_frag->fr_address + fixp->fx_where;
  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixp->fx_r_type);
  if (reloc->howto == (reloc_howto_type *) NULL)
    {
      as_bad_where (fixp->fx_file, fixp->fx_line,
        	    "reloc %d not supported by object file format", (int)fixp->fx_r_type);
      return NULL;
    }
  reloc->addend = fixp->fx_addnumber;

#ifdef DEBUG
  printf ("\ngen_reloc(): sym %s (%s:%d) at addr 0x%x addend=0x%x\n",
	  fixp->fx_addsy->bsym->name,
	  fixp->fx_file, fixp->fx_line,
	  reloc->address, reloc->addend);
#endif

  return reloc;
}

/* The target specific pseudo-ops which we support.  */

const pseudo_typeS md_pseudo_table[] =
{
  /* Pseudo-ops which must be overridden.  */
  { "byte",     i370_byte,	0 },

  { "dc",       i370_dc,	0 },
  { "ds",       i370_ds,	0 },
  { "rmode",    i370_rmode,	0 },
  { "csect",    i370_csect,	0 },
  { "dsect",    i370_dsect,	0 },

  /* enable ebcdic strings e.g. for 3270 support */
  { "ebcdic",   i370_ebcdic,	0 },

#ifdef OBJ_ELF
  { "long",     i370_elf_cons,	4 },
  { "word",     i370_elf_cons,	4 },
  { "short",    i370_elf_cons,	2 },
  { "rdata",    i370_elf_rdata,	0 },
  { "rodata",   i370_elf_rdata,	0 },
  { "lcomm",    i370_elf_lcomm,	0 },
#endif

  /* This pseudo-op is used even when not generating XCOFF output.  */
  { "tc",       i370_tc,	0 },

  /* dump the literal pool */
  { "ltorg",    i370_ltorg,	0 },

  /* support the hlasm-style USING directive */
  { "using",    i370_using,	0 },
  { "drop",     i370_drop,	0 },

  { NULL,       NULL,		0 }
};
@


1.35
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d4 1
a4 1
   2004, 2005, 2006, 2007, 2009  Free Software Foundation, Inc.
d1897 1
a1897 1
  char *s, *opcode_str;
a1917 1
  opcode_str = str;
a2034 1
      const char *errmsg;
a2038 1
      errmsg = NULL;
@


1.34
log
@        PR 10437
        * config/tc-alpha.c: Fix up uses of gas printf like functions so
        that the format string is a constant string.  Add translation
        support to message strings.
        * config/tc-arc.c: Likewise.
        * config/tc-arm.c: Likewise.
        * config/tc-cris.c: Likewise.
        * config/tc-fr30.c: Likewise.
        * config/tc-frv.c: Likewise.
        * config/tc-h8300.c: Likewise.
        * config/tc-hppa.c: Likewise.
        * config/tc-i370.c: Likewise.
        * config/tc-i960.c: Likewise.
        * config/tc-ia64.c: Likewise.
        * config/tc-m32r.c: Likewise.
        * config/tc-mep.c: Likewise.
        * config/tc-mips.c: Likewise.
        * config/tc-moxie.c: Likewise.
        * config/tc-msp430.c: Likewise.
        * config/tc-openrisc.c: Likewise.
        * config/tc-pdp11.c: Likewise.
        * config/tc-pj.c: Likewise.
        * config/tc-s390.c: Likewise.
        * config/tc-sh.c: Likewise.
        * config/tc-sh64.c: Likewise.
        * config/tc-sparc.c: Likewise.
        * config/tc-spu.c: Likewise.
        * config/tc-tic30.c: Likewise.
        * config/tc-tic4x.c: Likewise.
        * config/tc-tic54x.c: Likewise.
        * config/tc-v850.c: Likewise.
        * config/tc-xc16x.c: Likewise.
        * config/tc-xstormy16.c: Likewise.
        * config/tc-z80.c: Likewise.
        * config/tc-z8k.c: Likewise.
        * config/atof-ieee.c: Add translation support to as_warn
        messages.
        * config/obj-coff.c: Likewise.
@
text
@d903 1
a932 2
      char * close;

d934 3
a936 3
      close = strchr (input_line_pointer, '\'');
      if (close)
	*close= ' ';
a942 2
      char * close;

d944 3
a946 3
      close = strchr (input_line_pointer, '\"');
      if (close)
	*close= ' ';
d1523 2
a1524 1
	  char * close;
d1526 3
a1528 3
	  close = strchr (input_line_pointer, '\'');
	  if (close)
	    *close= ' ';
d1534 2
a1535 1
	  char * close;
d1537 3
a1539 3
	  close = strchr (input_line_pointer, '\"');
	  if (close)
	    *close= ' ';
@


1.33
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d4 1
a4 1
   2004, 2005, 2006, 2007 Free Software Foundation, Inc.
d419 1
a419 1
          as_bad ("invalid switch -m%s", arg);
d516 1
a516 1
               as_bad ("Internal assembler error for instruction %s", op->name);
d535 1
a535 1
              as_bad ("Internal assembler error for macro %s", macro->name);
d630 1
a630 1
          as_warn ("identifier+constant@@got means identifier@@got+constant");
d684 2
a685 1
            as_bad ("%s relocations do not fit in %d bytes\n", reloc_howto->name, nbytes);
d925 1
a925 1
      as_bad ("unsupported DC type");
d939 1
a939 1
	as_bad ("missing end-quote");
d951 1
a951 1
	as_bad ("missing end-quote");
d969 1
a969 1
      as_bad ("unsupported DC type");
d999 1
a999 1
	  as_bad ("unsupported alignment");
d1006 1
a1006 1
    as_bad ("this DS form not yet supported");
d1049 1
a1049 1
      as_bad ("Expected comma after symbol-name: rest of line ignored.");
d1058 1
a1058 1
      as_warn (".COMMon length (%ld.) <0! Ignored.", (long) size);
d1072 1
a1072 1
          as_warn ("ignoring bad alignment");
d1083 1
a1083 1
      as_bad ("Ignoring attempt to re-define symbol `%s'.",
d1091 1
a1091 1
      as_bad ("Length of .lcomm \"%s\" is already %ld. Not changed to %ld.",
d1110 1
a1110 1
          as_bad ("Common alignment not a power of 2");
d1248 1
a1248 1
    as_bad ("Missing or bad .using directive");
d1293 1
a1293 1
	as_bad ("Literal Pool Overflow");
d1532 1
a1532 1
	    as_bad ("missing end-quote");
d1542 1
a1542 1
	    as_bad ("missing end-quote");
d1589 1
a1589 1
	  as_bad ("expression not a constant");
d1596 1
a1596 1
      as_bad ("Unknown/unsupported address literal type");
d1619 1
a1619 1
	as_bad (".ltorg without prior .using in section %s",
d1623 1
a1623 1
	as_bad (".ltorg in section %s paired to .using in section %s",
d1646 1
a1646 1
  else as_bad ("bad alignment of %d bytes in literal pool", biggest_literal_size);
d1670 1
a1670 1
	  as_bad ("bad literal size\n");
d1744 1
a1744 1
    as_bad (".using: base address expression illegal or too complex");
d1779 1
a1779 1
	as_bad ("droping register %d in section %s does not match using register %d",
d1788 1
a1788 1
	as_bad ("droping register %d in section %s does not match using register %d",
d1792 1
a1792 1
	as_bad ("droping register %d in section %s previously used in section %s",
d1848 1
a1848 1
      as_bad ("wrong number of operands");
d1930 1
a1930 1
        as_bad ("Unrecognized opcode: `%s'", str);
d2075 1
a2075 1
	    as_bad ("not using any base register");
d2105 1
a2105 1
	    as_bad ("expecting a register for operand %d",
d2129 1
a2129 1
        as_bad ("illegal operand");
d2131 1
a2131 1
        as_bad ("missing operand");
d2211 1
a2211 1
    as_bad ("junk at end of line: `%s'", str);
d2226 1
a2226 1
	  as_bad ("Internal Error: bad instruction length");
@


1.32
log
@Remove duplicate definitions of the md_atof() function
@
text
@d1926 1
a1926 1
      assert (i370_macro_hash);
a2670 1

@


1.31
log
@Switch to GPLv3
@
text
@d961 1
a2358 5
/* Turn a string in input_line_pointer into a floating point constant
   of type TYPE, and store the appropriate bytes in *LITP.  The number
   of LITTLENUMS emitted is stored in *SIZEP.  An error message is
   returned, or NULL on OK.  */

a2361 24
  int prec;
  LITTLENUM_TYPE words[4];
  char *t;
  int i;

  switch (type)
    {
    case 'f':
    case 'E':
      type = 'f';
      prec = 2;
      break;

    case 'd':
    case 'D':
      type = 'd';
      prec = 4;
      break;

    default:
      *sizep = 0;
      return "bad call to md_atof";
    }

d2363 2
a2364 14
   * format, and the ieee format.  Support only the ieee format.  */
  t = atof_ieee (input_line_pointer, type, words);
  if (t)
    input_line_pointer = t;

  *sizep = prec * 2;

  for (i = 0; i < prec; i++)
    {
      md_number_to_chars (litp, (valueT) words[i], 2);
      litp += 2;
    }

  return NULL;
@


1.30
log
@remove some duplicate #include's.
@
text
@d4 1
a4 1
   2004, 2005, 2006 Free Software Foundation, Inc.
d11 1
a11 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.29
log
@Fixes for building on 64-bit hosts:
        * config/tc-avr.c (mod_index): New union to allow conversion
        between pointers and integers.
        (md_begin, avr_ldi_expression): Use it.
        * config/tc-i370.c (md_assemble): Add cast for argument to print
        statement.
        * config/tc-tic54x.c (subsym_substitute): Likewise.
        * config/tc-mn10200.c (md_assemble): Use a union to convert the
        opindex field of fr_cgen structure into a pointer so that it can
        be stored in a frag.
        * config/tc-mn10300.c (md_assemble): Likewise.
        * config/tc-frv.c (frv_debug_tomcat): Use %p to print pointer
        types.
        * config/tc-v850.c: Replace uses of (int) casts with correct
        types.
        * gas/tic54x/address.d: Work with 64bit hosts.
        * gas/tic54x/addrfar.d: Likewise.
        * gas/tic54x/align.d: Likewise.
        * gas/tic54x/all-opcodes.d: Likewise.
        * gas/tic54x/asg.d: Likewise.
        * gas/tic54x/cons.d: Likewise.
        * gas/tic54x/consfar.d: Likewise.
        * gas/tic54x/extaddr.d: Likewise.
        * gas/tic54x/field.d: Likewise.
        * gas/tic54x/labels.d: Likewise.
        * gas/tic54x/loop.d: Likewise.
        * gas/tic54x/lp.d: Likewise.
        * gas/tic54x/macro.d: Likewise.
        * gas/tic54x/math.d: Likewise.
        * gas/tic54x/opcodes.d: Likewise.
        * gas/tic54x/sections.d: Likewise.
       * gas/tic54x/set.d: Likewise.
       * gas/tic54x/struct.d: Likewise.
       * gas/tic54x/subsym.d: Likewise.
@
text
@a29 1
#include <stdio.h>
@


1.28
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@d4 1
a4 1
   2004, 2005 Free Software Foundation, Inc.
d2105 1
a2105 1
		    opindex_ptr - opcode->operands + 1);
@


1.27
log
@Update the address and phone number of the FSF
@
text
@d2235 1
a2235 1
     md_apply_fix3.  */
d2479 1
a2479 1
md_apply_fix3 (fixS *fixP, valueT * valP, segT seg)
d2486 1
a2486 1
      printf ("\nmd_apply_fix3: symbol %s at 0x%x (%s:%d) val=0x%x addend=0x%x\n",
d2511 1
a2511 1
      printf ("\nmd_apply_fix3: fixup operand %s at 0x%x in %s:%d addend=0x%x\n",
d2571 1
a2571 1
      printf ("md_apply_fix3: reloc case %d in segment  %s %s:%d\n",
@


1.26
log
@Convert unmaintained files over to ISO-C90 and fix formatting.
@
text
@d21 2
a22 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.25
log
@update copyright dates
@
text
@d25 4
a28 5
 * that gcc emits (when gcc is suitably hacked).  To make it behave more
 * HLASM-like, try turning on the -M or --mri flag (as there are various
 * similarities between HLASM and the MRI assemblers, such as section
 * names, lack of leading . in pseudo-ops, DC and DS, etc ...
 */
d42 1
a42 1
/* This is the assembler for the System/390 Architecture  */
d79 1
a79 2
md_show_usage (stream)
     FILE *stream;
a93 64

static void i370_byte PARAMS ((int));
static void i370_tc PARAMS ((int));
static void i370_ebcdic PARAMS ((int));

static void i370_dc PARAMS ((int));
static void i370_ds PARAMS ((int));
static void i370_rmode PARAMS ((int));
static void i370_csect PARAMS ((int));
static void i370_dsect PARAMS ((int));
static void i370_ltorg PARAMS ((int));
static void i370_using PARAMS ((int));
static void i370_drop PARAMS ((int));
static void i370_make_relative PARAMS ((expressionS *exp, expressionS *baseaddr));

#ifdef OBJ_ELF
static bfd_reloc_code_real_type i370_elf_suffix PARAMS ((char **, expressionS *));
static void i370_elf_cons PARAMS ((int));
static void i370_elf_rdata PARAMS ((int));
static void i370_elf_lcomm PARAMS ((int));
static void i370_elf_validate_fix PARAMS ((fixS *, segT));
#endif


/* The target specific pseudo-ops which we support.  */

const pseudo_typeS md_pseudo_table[] =
{
  /* Pseudo-ops which must be overridden.  */
  { "byte",     i370_byte,	0 },

  { "dc",       i370_dc,	0 },
  { "ds",       i370_ds,	0 },
  { "rmode",    i370_rmode,	0 },
  { "csect",    i370_csect,	0 },
  { "dsect",    i370_dsect,	0 },

  /* enable ebcdic strings e.g. for 3270 support */
  { "ebcdic",   i370_ebcdic,	0 },

#ifdef OBJ_ELF
  { "long",     i370_elf_cons,	4 },
  { "word",     i370_elf_cons,	4 },
  { "short",    i370_elf_cons,	2 },
  { "rdata",    i370_elf_rdata,	0 },
  { "rodata",   i370_elf_rdata,	0 },
  { "lcomm",    i370_elf_lcomm,	0 },
#endif

  /* This pseudo-op is used even when not generating XCOFF output.  */
  { "tc",       i370_tc,	0 },

  /* dump the literal pool */
  { "ltorg",    i370_ltorg,	0 },

  /* support the hlasm-style USING directive */
  { "using",    i370_using,	0 },
  { "drop",     i370_drop,	0 },

  { NULL,       NULL,		0 }
};

/* ***************************************************************** */

a98 5
static bfd_boolean register_name PARAMS ((expressionS *));
static void i370_set_cpu PARAMS ((void));
static i370_insn_t i370_insert_operand
  PARAMS ((i370_insn_t insn, const struct i370_operand *operand, offsetT val));
static void i370_macro PARAMS ((char *str, const struct i370_macro *macro));
d100 3
a102 3
/* Predefined register names if -mregnames */
/* In general, there are lots of them, in an attempt to be compatible */
/* with a number of assemblers.                      */
d138 2
a139 2
  { "arg", 11 },  /* Argument Pointer */
  { "base", 3 },  /* Base Reg */
d141 1
a141 1
  { "f.0", 0 },     /* Floating point registers */
d151 3
a153 3
  { "dsa",13 },    /* stack pointer */
  { "lr", 14 },    /* Link Register */
  { "pgt", 4 },    /* Page Origin Table Pointer */
d155 1
a155 1
  { "r.0", 0 },    /* General Purpose Registers */
d172 5
a176 5
  { "r.arg", 11 },  /* Argument Pointer */
  { "r.base", 3 },  /* Base Reg */
  { "r.dsa", 13 },  /* Stack Pointer */
  { "r.pgt", 4 },   /* Page Origin Table Pointer */
  { "r.sp", 13 },   /* Stack Pointer */
d178 2
a179 2
  { "r.tca", 12 },  /* Pointer to the table of contents */
  { "r.toc", 12 },  /* Pointer to the table of contents */
d181 1
a181 1
  { "r0", 0 },     /* More general purpose registers */
d198 1
a198 1
  { "rbase", 3 },  /* Base Reg */
d200 2
a201 2
  { "rtca", 12 },  /* Pointer to the table of contents */
  { "rtoc", 12 },  /* Pointer to the table of contents */
d203 1
a203 1
  { "sp", 13 },   /* Stack Pointer */
a211 3
static int reg_name_search
  PARAMS ((const struct pd_reg *, int, const char * name));

d213 3
a215 4
reg_name_search (regs, regcount, name)
     const struct pd_reg *regs;
     int regcount;
     const char *name;
d239 9
a247 11
/*
 * Summary of register_name().
 *
 * in:        Input_line_pointer points to 1st char of operand.
 *
 * out:        An expressionS.
 *      The operand may have been a register: in this case, X_op == O_register,
 *      X_add_number is set to the register number, and truth is returned.
 *        Input_line_pointer->(next non-blank) char after operand, or is in its
 *      original state.
 */
d250 1
a250 2
register_name (expressionP)
     expressionS *expressionP;
d271 1
a271 3
    {
      reg_number = get_single_number ();
    }
d305 17
a321 18
 * We define two of these: "text" and "other".  Normally, "text"
 * would get used in the .text section for branches, while "other"
 * gets used in the .data section for address constants.
 *
 * The idea of a second base register in a different section
 * is foreign to the usual HLASM-style semantics; however, it
 * allows us to provide support for dynamically loaded libraries,
 * by allowing us to place address constants in a section other
 * than the text section. The "other" section need not be the
 * .data section, it can be any section that isn't the .text section.
 *
 * Note that HLASM defines a multiple, concurrent .using semantic
 * that we do not: in calculating offsets, it uses either the most
 * recent .using directive, or the one with the smallest displacement.
 * This allows HLASM to support a quasi-block-scope-like behaviour.
 * Handy for people writing assembly by hand ... but not supported
 * by us.
 */
d325 1
a325 1
/* The base address for address literals */
d329 1
a329 1
/* the "other" section, used only for syntax error detection */
d339 1
a339 1
/* What type of shared library support to use */
d343 1
a343 1
/* Flags to set in the elf header */
d363 1
a363 3
md_parse_option (c, arg)
     int c;
     char *arg;
d388 1
a388 1
      /* -m360 mean to assemble for the ancient 360 architecture */
d391 1
a391 1
      /* -mxa means to assemble for the IBM 370 XA  */
d405 2
a406 1
      /* -mrelocatable/-mrelocatable-lib -- warn about initializations that require relocation */
a411 1

a416 1

d451 1
a451 1
i370_set_cpu ()
d456 1
a456 1
  /* override with the superset for the moment.  */
d471 2
a472 2
/* Figure out the BFD architecture to use.  */
/* hack alert -- specify the different 370 architectures  */
d475 1
a475 1
i370_arch ()
d485 1
a485 1
md_begin ()
d487 1
a487 1
  register const struct i370_opcode *op;
d514 1
a514 1
           retval = hash_insert (i370_hash, op->name, (PTR) op);
d533 1
a533 1
          retval = hash_insert (i370_macro_hash, macro->name, (PTR) macro);
d549 3
a551 4
i370_insert_operand (insn, operand, val)
     i370_insn_t insn;
     const struct i370_operand *operand;
     offsetT val;
d557 1
a557 1
      /* used for 48-bit insn's */
d564 3
a566 5
    {
      /* this is used only for 16, 32 bit insn's */
      insn.i[0] |= (((long) val & ((1 << operand->bits) - 1))
		    << operand->shift);
    }
d581 1
d583 1
a583 3
i370_elf_suffix (str_p, exp_p)
     char **str_p;
     expressionS *exp_p;
d599 1
a599 1
#define MAP(str,reloc) { str, sizeof (str)-1, reloc }
d615 1
a615 3
    {
      *str2++ = TOLOWER (ch);
    }
d658 3
a660 2
/* Like normal .long/.short/.word, except support @@got, etc.  */
/* clobbers input_line_pointer, checks end-of-line.  */
d662 1
a662 2
i370_elf_cons (nbytes)
     register int nbytes;        /* 1=.byte, 2=.word, 4=.long */
d676 1
a685 1

d688 1
a688 1
              register char *p = frag_more ((int) nbytes);
d826 2
a827 1
/* ebcdic translation tables needed for 3270 support */
d829 1
a829 2
i370_ebcdic (unused)
     int unused ATTRIBUTE_UNUSED;
d841 5
a845 4
  if (('\'' == delim) || ('\"' == delim)) {
    input_line_pointer ++;
    end = rindex (input_line_pointer, delim);
  }
d862 2
a863 1
/* stub out a couple of routines */
d865 1
a865 2
i370_rmode (unused)
     int unused ATTRIBUTE_UNUSED;
d871 1
a871 2
i370_dsect (sect)
     int sect;
d876 1
a876 1
  /* Just pretend this is .section .data */
d884 1
a884 2
i370_csect (unused)
     int unused ATTRIBUTE_UNUSED;
d891 5
a895 5
 * For samplecode on what to do, look at i370_elf_cons() above.
 * This code handles pseudoops of the style
 * DC   D'3.141592653'   # in sysv4, .double 3.14159265
 * DC   F'1'             # in sysv4, .long   1
 */
d897 1
a897 2
i370_dc (unused)
     int unused ATTRIBUTE_UNUSED;
d910 1
a910 1
  /* figure out the size */
d929 1
a929 1
  /* get rid of pesky quotes */
d933 1
d941 1
d945 1
d976 2
a977 1
/* provide minimal support for DS Define Storage */
d979 1
a979 2
i370_ds (unused)
     int unused ATTRIBUTE_UNUSED;
d981 1
a981 1
  /* DS 0H or DS 0F or DS 0D */
d984 1
a984 1
      int alignment = 0;  /* left shift 1<<align */
d1005 1
a1005 3
    {
      as_bad ("this DS form not yet supported");
    }
d1009 1
d1011 1
a1011 2
i370_elf_rdata (sect)
     int sect;
d1016 1
a1016 1
  /* Just pretend this is .section .rodata */
d1023 2
a1024 1
/* Pseudo op to make file scope bss items */
d1026 1
a1026 2
i370_elf_lcomm (unused)
     int unused ATTRIBUTE_UNUSED;
d1028 3
a1030 3
  register char *name;
  register char c;
  register char *p;
d1032 1
a1032 1
  register symbolS *symbolP;
d1042 1
a1042 1
  /* just after name is now '\0' */
d1053 2
a1054 1
  input_line_pointer++;        	/* skip ',' */
d1099 1
a1099 1
  /* allocate_bss: */
d1104 1
a1104 1
      /* convert to a power of 2 alignment */
d1136 1
d1138 1
a1138 3
i370_elf_validate_fix (fixp, seg)
     fixS *fixp;
     segT seg;
d1169 2
a1170 4
            {
              as_bad_where (fixp->fx_file, fixp->fx_line,
        		    "Relocation cannot be done when using -mrelocatable");
            }
d1173 2
d1182 12
a1193 14
/* Provide support for literal pools within the text section.  */
/* Loosely based on similar code from tc-arm.c  */
/*
 * We will use four symbols to locate four parts of the literal pool.
 *    These four sections contain 64,32,16 and 8-bit constants; we use
 *    four sections so that all memory access can be appropriately aligned.
 *    That is, we want to avoid mixing these together so that we don't
 *    waste space padding out to alignments.  The four pointers
 *    longlong_poolP, word_poolP, etc. point to a symbol labeling the
 *    start of each pool part.
 *
 * lit_pool_num increments from zero to infinity and uniquely id's
 *    -- its used to generate the *_poolP symbol name.
 */
d1206 1
a1206 1
int next_literal_pool_place = 0; /* Next free entry in the pool */
d1208 4
a1211 4
static symbolS *longlong_poolP = NULL;   /* 64-bit pool entries */
static symbolS *word_poolP = NULL;       /* 32-bit pool entries */
static symbolS *short_poolP = NULL;      /* 16-bit pool entries */
static symbolS *byte_poolP = NULL;       /* 8-bit  pool entries */
d1215 1
a1215 1
/* create a new, empty symbol */
d1223 28
a1250 1
/* add an expression to the literal pool */
d1257 1
a1257 1
  /* start a new pool, if necessary */
d1267 5
a1271 6
  /* Check if this literal value is already in the pool: */
  /* hack alert -- we should probably be checking expressions
   * of type O_symbol as well ...  */
  /* hack alert XXX this is probably(certainly?) broken for O_big,
   * which includes 64-bit long-longs ...
   */
d1292 1
a1292 3
        {
          as_bad ("Literal Pool Overflow");
        }
d1298 1
a1298 3
	{
	  literals[next_literal_pool_place].sym_name = strdup (name);
	}
d1300 1
a1300 3
	{
	  literals[next_literal_pool_place].sym_name = NULL;
	}
d1305 4
a1308 5
   * X_add_number is the offset from the beginning of the
   * literal pool to this expr minus the location of the most
   * recent .using directive.  Thus, the grand total value of the
   * expression is the distance from .using to the literal.
   */
d1321 1
a1321 1
   * use that; otherwise use the text section.  */
d1323 1
a1323 3
    {
      i370_make_relative (exx, &i370_using_other_baseaddr);
    }
d1325 1
a1325 3
    {
      i370_make_relative (exx, &i370_using_text_baseaddr);
    }
d1329 4
a1332 5
 * a symbol that represents the start of the literal pool is created,
 * above, in the add_to_pool() routine. This sym ???_poolP.
 * However, we don't know what fragment its in until a bit later.
 * So we defer the frag_now thing, and the symbol name, until .ltorg time
 */
d1335 1
a1335 3
   a later date assign it a value. Thats what these functions do */
static void symbol_locate
  PARAMS ((symbolS *, const char *, segT, valueT, fragS *));
d1338 5
a1342 6
symbol_locate (symbolP, name, segment, valu, frag)
     symbolS *symbolP;
     const char *name;		/* It is copied, the caller can modify */
     segT segment;		/* Segment identifier (SEG_<something>) */
     valueT valu;		/* Symbol value */
     fragS *frag;		/* Associated fragment */
d1359 1
a1359 3
  /*
   * Link to end of symbol chain.
   */
d1362 1
d1382 14
a1395 14
 * that appear to be absolute into thier base-register
 * relative form.  These expressions come in two types:
 *
 * (1) of the form "* + const" * where "*" means
 * relative offset since the last using
 * i.e. "*" means ".-using_baseaddr"
 *
 * (2) labels, which are never absolute, but are always
 * relative to the last "using".  Anything with an alpha
 * character is considered to be a label (since symbols
 * can never be operands), and since we've already handled
 * register operands. For example, "BL .L33" branch low
 * to .L33 RX form insn frequently terminates for-loops,
 */
d1403 2
a1404 2
  /* search for a label; anything with an alpha char will do */
  /* local labels consist of N digits followed by either b or f */
d1409 1
a1409 3
	{
	  all_digits = 1;
	}
d1430 1
a1430 1
  /* See if operand has a * in it */
d1436 1
a1436 1
  /* replace * with . and let expr munch on it.  */
d1441 2
a1442 2
  /* OK, now we have to subtract the "using" location  */
  /* normally branches appear in the text section only...  */
d1444 1
a1444 3
    {
      i370_make_relative (exx, &i370_using_text_baseaddr);
    }
d1446 1
a1446 3
    {
      i370_make_relative (exx, &i370_using_other_baseaddr);
    }
d1448 1
a1448 1
  /* put the * back */
d1455 1
a1455 1
/* handle address constants of various sorts */
d1457 6
a1462 6
 *    =A(some_symb)
 *    =V(some_extern)
 *    =X'deadbeef'    hexadecimal
 *    =F'1234'        32-bit const int
 *    =H'1234'        16-bit const int
 */
d1469 2
a1470 2
  int hex_len=0;
  int cons_len=0;
d1474 1
a1474 1
  /* Find the spelling of the operand */
d1476 1
a1476 3
    {
      name = ++input_line_pointer;
    }
d1478 2
a1479 3
    {
      return FALSE;
    }
d1482 2
a1483 4
    case 'A':
    case 'V':
      /* A == address-of */
      /* V == extern */
d1487 2
a1488 3
      /* we use a simple string name to collapse together
       * multiple refrences to the same address literal
       */
d1499 2
a1500 2
    case 'E':  /* single-precision float point */
    case 'D':  /* double-precision float point */
d1502 3
a1504 3
      /* H == 16-bit fixed-point const; expression must be const */
      /* F == fixed-point const; expression must be const */
      /* X == fixed-point const; expression must be const */
d1511 2
a1512 2
      /* extract length, if it is present; hack alert -- assume single-digit
       * length */
d1515 2
a1516 1
	  cons_len = name[2] - '0';  /* should work for ascii and ebcdic */
d1522 1
a1522 1
      /* get rid of pesky quotes */
d1549 5
a1553 6
	   * or implied through the number of hex digits. For example:
	   * =X'AB'       one byte
	   * =X'abcd'     two bytes
	   * =X'000000AB' four bytes
	   * =XL4'AB'     four bytes, left-padded withn zero
	   */
d1566 3
a1568 4
	   * which should parse out to X_op == O_big
	   * Note that floats and doubles get represented as
	   * 0d3.14159265358979  or 0f 2.7
	   */
d1578 1
a1578 1
	  /* fix up lengths for floats and doubles */
d1580 1
a1580 3
	    {
	      exp->X_add_number = cons_len / CHARS_PER_LITTLENUM;
	    }
d1583 3
a1585 4
	{
	  expression (exp);
	}
      /* O_big occurs when more than 4 bytes worth gets parsed */
d1604 1
a1604 2
 * This aligns the pool to the size of the largest literal in the pool.
 */
d1607 1
a1607 2
i370_ltorg (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1618 3
a1620 4
        {
          as_bad (".ltorg without prior .using in section %s",
		  now_seg->name);
        }
d1622 2
a1623 4
        {
	  as_bad (".ltorg in section %s paired to .using in section %s",
		  now_seg->name, i370_other_section->name);
        }
d1625 1
d1630 2
a1631 5
    {
      /* Nothing to do */
      /* as_tsktsk ("Nothing to put in the pool\n"); */
      return;
    }
d1633 1
a1633 1
  /* find largest literal .. 2 4 or 8 */
d1648 1
a1648 1
  /* Align pool for short, word, double word accesses */
d1653 2
a1654 3
   * entries in the pool .... wonder how to make it print more ...
   */
  /* output largest literals first, then the smaller ones.  */
d1685 4
a1688 5
	      /* create a bogus symbol, add it to the pool ...
	       * For the most part, I think this is a useless exercise,
	       * except that having these symbol names in the objects
	       * is vaguely useful for debugging ...
	       */
d1715 7
a1721 7
/* add support for the HLASM-like USING directive to indicate
 * the base register to use ...  we don't support the full
 * hlasm semantics for this ... we merely pluck a base address
 * and a register number out.  We print a warning if using is
 * called multiple times.  I suppose we should check to see
 * if the regno is valid ...
 */
d1723 1
a1723 2
i370_using (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1729 2
a1730 2
  /* if "*" appears in a using, it means "."  */
  /* replace it with "." so that expr doesn't get confused.  */
d1735 2
a1736 2
  /* the first arg to using will usually be ".", but it can
   * be a more complex expression too ...  */
a1742 1
  {
a1743 1
  }
d1747 1
a1747 1
  /* the second arg to using had better be a register */
d1766 1
a1766 2
i370_drop (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1778 3
a1780 4
        {
          as_bad ("droping register %d in section %s does not match using register %d",
		  iregno, now_seg->name, i370_using_text_regno);
        }
d1787 3
a1789 4
        {
          as_bad ("droping register %d in section %s does not match using register %d",
		  iregno, now_seg->name, i370_using_other_regno);
        }
d1791 3
a1793 4
        {
          as_bad ("droping register %d in section %s previously used in section %s",
		  iregno, now_seg->name, i370_other_section->name);
        }
a1799 29
/* Make the first argument an address-relative expression
 * by subtracting the second argument.
 */
static void
i370_make_relative (expressionS *exx, expressionS *baseaddr)
{

  if (O_constant == baseaddr->X_op)
    {
       exx->X_op = O_symbol;
       exx->X_add_number -= baseaddr->X_add_number;
    }
  else if (O_symbol == baseaddr->X_op)
    {
       exx->X_op = O_subtract;
       exx->X_op_symbol = baseaddr->X_add_symbol;
       exx->X_add_number -= baseaddr->X_add_number;
    }
  else if (O_uminus == baseaddr->X_op)
    {
       exx->X_op = O_add;
       exx->X_op_symbol = baseaddr->X_add_symbol;
       exx->X_add_number += baseaddr->X_add_number;
     }
  else
     {
       as_bad ("Missing or bad .using directive");
     }
}
d1812 79
a1890 1
#define MAX_INSN_FIXUPS (5)
d1895 1
a1895 2
md_assemble (str)
     char *str;
d1958 1
d2013 5
a2017 6
   * Its such a shame to have to do this, but the problem is that HLASM got
   * defined so that the lengths differ by one from the actual machine instructions.
   * this code should probably be moved to a special inster-operand routine.
   * Sigh. Affected instructions are Compare Logical, Move and Exclusive OR
   * hack alert -- aren't *all* SS instructions affected ??
   */
d2062 1
a2062 3
                {
                  basereg = i370_using_text_regno;
                }
d2064 1
a2064 3
                {
                  basereg = i370_using_other_regno;
                }
d2069 1
a2069 3
                {
                  basereg = i370_using_text_regno;
                }
d2071 1
a2071 3
                {
                  basereg = i370_using_other_regno;
                }
d2074 2
a2075 3
            {
              as_bad ("not using any base register");
            }
d2093 1
a2093 1
      /* register names are only allowed where there are registers ...  */
d2096 1
a2096 1
          /* quickie hack to get past things like (,r13) */
d2102 1
d2104 2
a2105 4
            {
              as_bad ("expecting a register for operand %d",
		      opindex_ptr - opcode->operands + 1);
            }
d2110 1
a2110 1
       * and address literals in the .data (or other) section.  */
d2112 1
a2112 1
	use_other=1;
d2114 1
a2114 1
	use_text=1;
d2120 4
a2123 6
      /* perform some off-by-one hacks on the length field of certain instructions.
       * Its such a shame to have to do this, but the problem is that HLASM got
       * defined so that the programmer specifies a length that is one greater
       * than what the machine instruction wants.
       * Sigh.
       */
d2125 1
a2125 3
	{
	  ex.X_add_number --;
	}
d2132 1
a2132 3
        {
          insn = i370_insert_operand (insn, operand, ex.X_add_number);
        }
d2137 3
a2139 3
           * Well actually, no we don't; there really don't make sense
           * (at least not to me) for the i370.  However, this code is
           * left here for any dubious future expansion reasons ...  */
a2183 1

d2188 2
a2189 3
           * printf ("insn %s needs fixup for %s \n",
           *        opcode->name, ex.X_add_symbol->bsym->name);
           */
d2199 1
a2199 1
      /* skip over delimiter (close paren, or comma) */
d2215 1
a2215 3
    {
      md_number_to_chars (f, insn.i[0], opcode->len);
    }
d2219 1
d2221 1
a2221 3
	{
	  md_number_to_chars ((f+4), ((insn.i[1])>>16), 2);
	}
d2224 1
a2224 1
	  /* not used --- don't have any 8 byte instructions */
d2226 1
a2226 1
	  md_number_to_chars ((f+4), insn.i[1], opcode->len -4);
a2284 79
/* Handle a macro.  Gather all the operands, transform them as
   described by the macro, and call md_assemble recursively.  All the
   operands are separated by commas; we don't accept parentheses
   around operands here.  */

static void
i370_macro (str, macro)
     char *str;
     const struct i370_macro *macro;
{
  char *operands[10];
  unsigned int count;
  char *s;
  unsigned int len;
  const char *format;
  int arg;
  char *send;
  char *complete;

  /* Gather the users operands into the operands array.  */
  count = 0;
  s = str;
  while (1)
    {
      if (count >= sizeof operands / sizeof operands[0])
        break;
      operands[count++] = s;
      s = strchr (s, ',');
      if (s == (char *) NULL)
        break;
      *s++ = '\0';
    }

  if (count != macro->operands)
    {
      as_bad ("wrong number of operands");
      return;
    }

  /* Work out how large the string must be (the size is unbounded
     because it includes user input).  */
  len = 0;
  format = macro->format;
  while (*format != '\0')
    {
      if (*format != '%')
        {
          ++len;
          ++format;
        }
      else
        {
          arg = strtol (format + 1, &send, 10);
          know (send != format && arg >= 0 && (unsigned) arg < count);
          len += strlen (operands[arg]);
          format = send;
        }
    }

  /* Put the string together.  */
  complete = s = (char *) alloca (len + 1);
  format = macro->format;
  while (*format != '\0')
    {
      if (*format != '%')
        *s++ = *format++;
      else
        {
          arg = strtol (format + 1, &send, 10);
          strcpy (s, operands[arg]);
          s += strlen (s);
          format = send;
        }
    }
  *s = '\0';

  /* Assemble the constructed instruction.  */
  md_assemble (complete);
}
d2292 1
a2292 2
i370_byte (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2335 1
a2335 2
i370_tc (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2365 1
a2365 4
md_atof (type, litp, sizep)
     int type;
     char *litp;
     int *sizep;
d2412 1
a2412 4
md_number_to_chars (buf, val, n)
     char *buf;
     valueT val;
     int n;
d2414 1
a2414 1
    number_to_chars_bigendian (buf, val, n);
d2420 1
a2420 3
md_section_align (seg, addr)
     asection *seg;
     valueT addr;
d2430 2
a2431 3
md_estimate_size_before_relax (fragp, seg)
     fragS *fragp ATTRIBUTE_UNUSED;
     asection *seg ATTRIBUTE_UNUSED;
d2440 3
a2442 4
md_convert_frag (abfd, sec, fragp)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec ATTRIBUTE_UNUSED;
     fragS *fragp ATTRIBUTE_UNUSED;
d2450 1
a2450 2
md_undefined_symbol (name)
     char *name ATTRIBUTE_UNUSED;
d2461 1
a2461 3
md_pcrel_from_section (fixp, sec)
     fixS *fixp;
     segT sec ATTRIBUTE_UNUSED;
d2476 1
a2476 2
   going on here ...
*/
d2479 1
a2479 4
md_apply_fix3 (fixP, valP, seg)
     fixS *fixP;
     valueT * valP;
     segT seg;
d2647 1
a2647 3
tc_gen_reloc (seg, fixp)
     asection *seg ATTRIBUTE_UNUSED;
     fixS *fixp;
d2651 1
a2651 1
  reloc = (arelent *) xmalloc (sizeof (arelent));
d2653 1
a2653 1
  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
d2674 39
@


1.24
log
@	* as.h (assert): Warning fix.
	* expr.c (expr): Correct assertion.
	* read.c (s_comm_internal): Remove assertion.
	* write.c (relax_segment): Enable vma assertion only for BFD_ASSEMBLER.
	(fixup_segment): Remove assertion.
	* config/tc-dlx.c (machine_ip): Remove untrue assertions.
	(md_apply_fix3): Likewise.
	* config/tc-i370.c (md_begin): Correct assertion.
	(i370_macro): Warning fix for assertion.
@
text
@d4 1
a4 1
   2005 Free Software Foundation, Inc.
@


1.23
log
@	* cgen.c: Warning fixes.
	* config/tc-arc.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-frv.c: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ip2k.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-xstormy16.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d591 2
a592 1
       know ((op->opcode & op->mask) == op->opcode);
d2426 1
a2426 1
          know (send != format && arg >= 0 && arg < count);
@


1.22
log
@	* config/atof-ieee.c, config/obj-coff.c, config/obj-elf.c,
	config/obj-ieee.c, config/obj-som.c, config/obj-vms.c,
	config/tc-a29k.c, config/tc-alpha.c, config/tc-arc.c,
	config/tc-arm.c, config/tc-d30v.c, config/tc-dlx.c,
	config/tc-fr30.c, config/tc-h8300.c, config/tc-h8500.c,
	config/tc-i370.c, config/tc-i386.c, config/tc-i960.c,
	config/tc-ia64.c, config/tc-m32r.c, config/tc-m32r.h,
	config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-mips.c,
	config/tc-mn10200.c, config/tc-msp430.c, config/tc-ns32k.c,
	config/tc-openrisc.c, config/tc-or32.c, config/tc-pdp11.c,
	config/tc-pj.c, config/tc-sparc.h, config/tc-tic54x.c,
	config/tc-tic80.c, config/tc-v850.c, config/tc-w65.c,
	config/tc-xtensa.c, config/tc-z8k.c, config/xtensa-relax.c: Remove
	#if 0'd code throughout.
@
text
@d3 2
a4 2
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
d2058 1
a2058 1
      nwanted = strlen (opcode->operands);
@


1.21
log
@	* symbols.c (colon) [!WORKING_DOT_WORD]: Don't declare
	md_short_jump_size, md_long_jump_size.
	* write.c [!WORKING_DOT_WORD]: Ditto.
	* tc.h [!WORKING_DOT_WORD]: Declare them here.  Drop const
	qualifier.
	* config/tc-cris.h (md_short_jump_size, md_long_jump_size): Don't
	declare.
	* config/tc-cris.c (md_short_jump_size, md_long_jump_size): Drop
	const qualifier in these definitions.
	* config/tc-i370.c, config/tc-m68k.c, config/tc-pdp11.c,
	config/tc-s390.c, config/tc-tahoe.c, config/tc-vax.c: Ditto.
@
text
@a689 5
#if 0
    MAP ("l",		BFD_RELOC_LO16),
    MAP ("h",		BFD_RELOC_HI16),
    MAP ("ha",		BFD_RELOC_HI16_S),
#endif
a2451 54
#if 0
/* For ELF, add support for SHF_EXCLUDE and SHT_ORDERED */

int
i370_section_letter (letter, ptr_msg)
     int letter;
     char **ptr_msg;
{
  if (letter == 'e')
    return SHF_EXCLUDE;

  *ptr_msg = "Bad .section directive: want a,e,w,x,M,S in string";
  return 0;
}

int
i370_section_word (str, len)
    char *str;
    size_t len;
{
  if (len == 7 && strncmp (str, "exclude", 7) == 0)
    return SHF_EXCLUDE;

  return -1;
}

int
i370_section_type (str, len)
    char *str;
    size_t len;
{
  if (len == 7 && strncmp (str, "ordered", 7) == 0)
     return SHT_ORDERED;

  return -1;
}

int
i370_section_flags (flags, attr, type)
     int flags;
     int attr;
     int type;
{
  if (type == SHT_ORDERED)
    flags |= SEC_ALLOC | SEC_LOAD | SEC_SORT_ENTRIES;

  if (attr & SHF_EXCLUDE)
    flags |= SEC_EXCLUDE;

  return flags;
}
#endif /* OBJ_ELF */


a2730 7
#if 0
      if ((operand->flags & I370_OPERAND_RELATIVE) != 0
          && operand->bits == 12
          && operand->shift == 0)
        fixP->fx_r_type = BFD_RELOC_I370_D12;
      else
#endif
@


1.20
log
@	* config/tc-hppa.c: Fix comment typos.
	* config/tc-i370.c: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-iq2000.h: Likewise.
@
text
@d428 2
a429 2
const int md_short_jump_size = 4;
const int md_long_jump_size = 4;
@


1.19
log
@Correct spelling of "relocatable".
@
text
@d1381 2
a1382 2
  /* ???_poolP points to the begining of the literal pool.
   * X_add_number is the offset from the begining of the
d1664 1
a1664 1
	  /* I beleive this works even for =XL8'dada0000beeebaaa'
d1797 1
a1797 1
	       * For the most part, I think this is a useless excercise,
d1849 1
a1849 1
   * be a more complex exprsssion too ...  */
d2191 1
a2191 1
       * and adress literals in the .data (or other) section.  */
@


1.18
log
@	* config/tc-i370.c (i370_ebcdic <unused>): Add ATTRIBUTE_UNUSED.
	(i370_rmode <unused>): Likewise.
	(i370_csect <unused>): Likewise.
	(i370_dc <unused>): Likewise.
	(i370_ds <unused>): Likewise.
	(i370_elf_lcomm <unused>): Likewise.
	(i370_ltorg <ignore>): Likewise.
	(i370_using <ignore>): Likewise.
	(i370_drop <ignore>): Likewise.
	(i370_byte <ignore>): Likewise.
	(i370_tc <ignore>): Likewise.
	(md_estimate_size_before_relax <fragp, seg>): Likewise.
	(md_convert_frag <all args>): Likewise.
	(md_undefined_symbol <name>): Likewise.
	(md_pcrel_from_section <sec>): Likewise.
	(tc_gen_reloc <seg>): Likewise.
	(i370_section_letter): #if 0 unused functions.
	(i370_section_word, i370_section_type, i370_section_flags): Likewise.
	(symbol_locate): Prototype.
@
text
@d3 1
a3 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d2555 1
a2555 1
   relocateable symbol reference.
@


1.17
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d923 1
a923 1
     int unused;
d958 1
a958 1
     int unused;
d979 1
a979 1
     int unused;
d992 2
a993 2
i370_dc(unused)
     int unused;
d1072 1
a1072 1
     int unused;
d1121 1
a1121 1
     int unused;
d1419 3
d1712 1
a1712 1
     int ignore;
d1836 1
a1836 1
     int ignore;
d1882 1
a1882 1
     int ignore;
d2457 1
a2457 1
#ifdef OBJ_ELF
d2518 1
a2518 1
     int ignore;
d2562 1
a2562 1
     int ignore;
d2666 2
a2667 2
     fragS *fragp;
     asection *seg;
d2677 3
a2679 3
     bfd *abfd;
     asection *sec;
     fragS *fragp;
d2688 1
a2688 1
     char *name;
d2701 1
a2701 1
     segT sec;
d2899 1
a2899 1
     asection *seg;
@


1.16
log
@gas reloc rewrite.
@
text
@d161 1
a161 1
#define TARGET_REG_NAMES_P true
d163 1
a163 1
static boolean reg_names_p = TARGET_REG_NAMES_P;
d165 1
a165 1
static boolean register_name PARAMS ((expressionS *));
d326 1
a326 1
static boolean
d341 1
a341 1
    return false;
d370 1
a370 1
      return true;
d375 1
a375 1
  return false;
d482 1
a482 1
	reg_names_p = true;
d485 1
a485 1
	reg_names_p = false;
d575 1
a575 1
  boolean dup_insn = false;
d601 1
a601 1
               dup_insn = true;
d620 1
a620 1
              dup_insn = true;
d1480 1
a1480 1
static boolean
d1520 1
a1520 1
    return false;
d1542 1
a1542 1
  return true;
d1553 1
a1553 1
static boolean
d1571 1
a1571 1
      return false;
d1689 1
a1689 1
	  return false;
d1696 1
a1696 1
      return false;
d1699 1
a1699 1
  return true;
@


1.15
log
@	* as.c: Replace CONST with const.
	* write.c: Likewise.
	* config/obj-coff.c: Likewise.
	* config/tc-a29k.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.c: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i860.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@a2725 30
      /* Notes:
         Branches to labels will come in here with fixP->fx_pcrel set to 1
         and fixP->fx_subsy not null, and holding the value of the base
         (i.e. the value of the .using). These we want to ignore.

         'Strong' and 'weak' symbols will come in here with
         fixP->fx_pcrel==0, fixP->fx_addsy defined, and
         *valuep holding the value of the symbol.

         'Strong' symbols will have S_GET_VALUE(fx_addsy) equal to zero,
         whereas 'weak' symbols will have S_GET_VALUE(fx_addsy) set to the
         symbol value (usually).

         We want to subtract S_GET_VALUE(fx_addsy) if it set, and
         for all practical purposes, do a fixup with value zero.  This
         is because the linker/loader, at a later time, will do this
         fixup with the correct value. If we fixup now with a value,
         it will get double-fixed, leading to garbage.

         Note that subsy will also be set for strong/weak symbols
         when the user program was compiled with -g.  In that case,
         subsy will hold the base address (i.e. the .using address).
      */

      if (fixP->fx_addsy->sy_used_in_reloc
          && S_GET_SEGMENT (fixP->fx_addsy) != absolute_section
          && S_GET_SEGMENT (fixP->fx_addsy) != undefined_section
          && ! bfd_is_com_section (S_GET_SEGMENT (fixP->fx_addsy)))
        value -= S_GET_VALUE (fixP->fx_addsy);

d2735 1
a2735 4
    {
      fixP->fx_done = 1;
      return;
    }
@


1.14
log
@Update all uses of md_apply_fix to use md_apply_fix3.  Make it a void function.
@
text
@d3 1
a3 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
d433 1
a433 1
CONST char *md_shortopts = "l:um:K:VQ:";
d435 1
a435 1
CONST char *md_shortopts = "um:";
d1422 1
a1422 1
     CONST char *name;		/* It is copied, the caller can modify */
@


1.13
log
@	* config/tc-alpha.c: Fix comment typos.
	* config/tc-cris.c: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-mn10200.c: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-v850.c: Likewise.
@
text
@d2324 1
a2324 1
     md_apply_fix.  */
d2716 4
a2719 4
int
md_apply_fix3 (fixp, valuep, seg)
     fixS *fixp;
     valueT *valuep;
d2722 1
a2722 1
  valueT value;
d2724 1
a2724 2
  value = *valuep;
  if (fixp->fx_addsy != NULL)
d2727 2
a2728 2
         Branches to labels will come in here with fixp->fx_pcrel set to 1
         and fixp->fx_subsy not null, and holding the value of the base
d2732 1
a2732 1
         fixp->fx_pcrel==0, fixp->fx_addsy defined, and
d2750 5
a2754 5
      if (fixp->fx_addsy->sy_used_in_reloc
          && S_GET_SEGMENT (fixp->fx_addsy) != absolute_section
          && S_GET_SEGMENT (fixp->fx_addsy) != undefined_section
          && ! bfd_is_com_section (S_GET_SEGMENT (fixp->fx_addsy)))
        value -= S_GET_VALUE (fixp->fx_addsy);
d2758 4
a2761 4
	      S_GET_NAME (fixp->fx_addsy),
	      fixp->fx_frag->fr_address + fixp->fx_where,
	      fixp->fx_file, fixp->fx_line,
	      S_GET_VALUE (fixp->fx_addsy), value);
d2766 2
a2767 2
      fixp->fx_done = 1;
      return 1;
d2773 1
a2773 1
  if ((int) fixp->fx_r_type >= (int) BFD_RELOC_UNUSED)
d2780 1
a2780 1
      opindex = (int) fixp->fx_r_type - (int) BFD_RELOC_UNUSED;
d2787 2
a2788 2
	      fixp->fx_frag->fr_address + fixp->fx_where,
	      fixp->fx_file, fixp->fx_line,
d2794 1
a2794 1
      where = fixp->fx_frag->fr_literal + fixp->fx_where;
d2796 5
a2800 4
      if (6 <= fixp->fx_size)
	{    /* deal with 48-bit insn's */
	  insn.i[1] = bfd_getb32 (((unsigned char *) where)+4);
	}
a2802 4
      if (6 <= fixp->fx_size)
	{   /* deal with 48-bit insn's */
	  bfd_putb32 ((bfd_vma) insn.i[1], (((unsigned char *) where)+4));
	}
d2804 9
a2812 7
      /* we are done, right? right !! */
      fixp->fx_done = 1;
      if (fixp->fx_done)
        {
          /* Nothing else to do here.  */
          return 1;
        }
d2824 1
a2824 1
        fixp->fx_r_type = BFD_RELOC_I370_D12;
d2833 2
a2834 2
          if (expr_symbol_where (fixp->fx_addsy, &sfile, &sline))
            as_bad_where (fixp->fx_file, fixp->fx_line,
d2837 1
a2837 1
            as_bad_where (fixp->fx_file, fixp->fx_line,
d2839 2
a2840 2
          fixp->fx_done = 1;
          return 1;
d2846 2
a2847 3
       * appears in an instruction operand, but is rather some
       * declared storage.
       */
d2849 1
a2849 1
      i370_elf_validate_fix (fixp, seg);
d2853 1
a2853 1
	      fixp->fx_r_type, segment_name (seg), fixp->fx_file, fixp->fx_line);
d2856 1
a2856 1
      switch (fixp->fx_r_type)
d2860 3
a2862 3
          if (fixp->fx_pcrel)
            fixp->fx_r_type = BFD_RELOC_32_PCREL;
	  /* fall through */
d2869 1
a2869 1
		  fixp->fx_frag->fr_address + fixp->fx_where);
d2871 1
a2871 1
          md_number_to_chars (fixp->fx_frag->fr_literal + fixp->fx_where,
d2877 2
a2878 2
          if (fixp->fx_pcrel)
            as_bad_where (fixp->fx_file, fixp->fx_line,
d2880 4
a2883 4
        		  bfd_get_reloc_code_name (fixp->fx_r_type),
        		  fixp->fx_addsy != NULL ? " against " : "",
        		  (fixp->fx_addsy != NULL
        		   ? S_GET_NAME (fixp->fx_addsy)
d2886 1
a2886 1
          md_number_to_chars (fixp->fx_frag->fr_literal + fixp->fx_where,
d2894 1
a2894 1
          if (fixp->fx_pcrel)
d2896 1
a2896 1
          md_number_to_chars (fixp->fx_frag->fr_literal + fixp->fx_where,
d2900 1
a2900 1
          if (fixp->fx_pcrel)
d2902 1
a2902 1
          md_number_to_chars (fixp->fx_frag->fr_literal + fixp->fx_where,
d2907 1
a2907 1
          if (fixp->fx_pcrel)
d2910 1
a2910 1
          md_number_to_chars (fixp->fx_frag->fr_literal + fixp->fx_where,
d2916 1
a2916 1
        	  "Gas failure, reloc value %d\n", fixp->fx_r_type);
d2922 1
a2922 3
  fixp->fx_addnumber = value;

  return 1;
@


1.12
log
@	* config/tc-i370.c: Fix typo in last change.
@
text
@d319 1
a319 1
 * out:        A expressionS.
d2186 1
a2186 1
      /* check for a address constant expression */
@


1.11
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d33 1
a33 1
#include "c=ctype.h"
@


1.10
log
@	* config/obj-elf.c (obj_elf_parse_section_letters): Use 'M' instead
	of 'm', 'S' instead of 's'.  Update bad_msg.
	* config/tc-ppc.c (ppc_section_letter): Update bad_msg.
	* config/tc-i370.c (i370_sectioN_letter): Update bad_msg.
@
text
@a31 1
#include <ctype.h>
d33 1
d337 1
a337 1
  if (name[0] == '%' && isalpha (name[1]))
d348 1
a348 1
  if (!isalpha (name[0]))
d705 1
a705 1
        && (isalnum (ch) || ch == '@@'));
d708 1
a708 1
      *str2++ = (islower (ch)) ? ch : tolower (ch);
d1492 1
a1492 1
      if (isdigit (*lab))
d1496 1
a1496 1
      else if (isalpha (*lab))
d1565 1
a1565 1
  if (name[0] == '=' && isalpha (name[1]))
d1655 1
a1655 1
		  if (isxdigit (*save))
d1982 1
a1982 1
  for (s = str; *s != '\0' && ! isspace (*s); s++)
d2007 1
a2007 1
  while (isspace (*str))
d2292 1
a2292 1
  while (isspace (*str))
@


1.9
log
@	* config/obj-elf.c (obj_elf_symver): Temporarily modify lex_type
	to include '@@' in symbol names when parsing versioned symbols
	rather than calling get_symbol_end multiple times.
	* config/tc-i370.c (register_name): Format fixes.  Don't call
	get_symbol_end after parsing number.
	* config/tc-mn10200.c (data_register_name): Format fixes.  Hoist
	code out of conditional.
	(address_register_name): Likewise.
	(other_register_name): Likewise.
	* config/tc-mn10300.c (r_register_name): Likewise.
	(xr_register_name): Likewise.
	(data_register_name): Likewise.
	(address_register_name): Likewise.
	(other_register_name): Likewise.
	* config/tc-ppc.c (register_name): Likewise.
	* config/tc-s390.c (register_name): Likewise.
@
text
@d2465 1
a2465 1
  *ptr_msg = "Bad .section directive: want a,w,x,e in string";
@


1.8
log
@	* config/tc-alpha.h: Fix formatting.
	* config/tc-arc.c: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-hppa.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ia64.h: Likewise.
	* config/tc-m32r.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-pj.h: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-sparc.h: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-w65.h: Likewise.
@
text
@d335 1
a335 1
  /* Find the spelling of the operand */
d346 2
a347 2
  /* if its a number, treat it as a number */
  /* if its alpha, look to see if it's in the register table */
a350 1
      c = get_symbol_end ();
d356 3
d361 1
a361 1
  /* if numeric, make sure its not out of bounds */
d367 1
a367 1
      /* make the rest nice */
a369 1
      *input_line_pointer = c;   /* put back the delimiting char */
d373 3
a375 4
    /* reset the line as if we had not done anything */
    *input_line_pointer = c;   /* put back the delimiting char */
    input_line_pointer = start; /* reset input_line pointer */
    return false;
@


1.7
log
@Fix copyright notices
@
text
@d350 1
a350 1
      reg_number = get_single_number();
d1120 1
a1120 1
i370_elf_lcomm(unused)
d1329 1
a1329 1
    longlong_poolP = symbol_make_empty();
d1331 1
a1331 1
    word_poolP = symbol_make_empty();
d1333 1
a1333 1
    short_poolP = symbol_make_empty();
d1335 1
a1335 1
    byte_poolP = symbol_make_empty();
d1364 1
a1364 1
          as_bad("Literal Pool Overflow");
d1438 1
a1438 1
  symbol_clear_list_pointers(symbolP);
d1492 1
a1492 1
      if (isdigit(*lab))
d1496 1
a1496 1
      else if (isalpha(*lab))
d1655 1
a1655 1
		  if (isxdigit(*save))
d1800 1
a1800 1
		  symbolS * symP = symbol_make_empty();
d2920 1
a2920 1
          fflush(stderr);
@


1.6
log
@2001-01-14  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-alpha.c: Fix formatting.
	* config/tc-arc.c: Likewise.
	* config/tc-arc.h: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-vax.c: Likewise.
@
text
@d3 2
a4 1
   Copyright (C) 1994, 95, 96, 97, 98, 99, 2000 Free Software Foundation, Inc.
@


1.6.2.1
log
@Update copyright notices.
@
text
@d3 1
a3 2
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
@


1.5
log
@2000-12-03  Kazu Hirata  <kazu@@hxi.com>

	* tc-a29k.c: Fix formatting.
	* tc-alpha.c: Likewise.
	* tc-arm.c: Likewise.
	* tc-cris.c: Likewise.
	* tc-hppa.c: Likewise.
	* tc-i370.c: Likewise.
	* tc-i386.c: Likewise.
	* tc-i860.c: Likewise.
	* tc-i960.c: Likewise.
	* tc-ia64.c: Likewise.
	* tc-m68hc11.c: Likewise.
	* tc-m68k.c: Likewise.
	* tc-m88k.c: Likewise.
	* tc-pj.c: Likewise.
	* tc-ppc.c: Likewise.
	* tc-sh.c: Likewise.
	* tc-sparc.c: Likewise.
	* tc-tahoe.c: Likewise.
	* tc-vax.c: Likewise.
@
text
@a2681 1
/*ARGSUSED*/
@


1.4
log
@Excise C++ style comments.
@
text
@d82 1
a82 1
  fprintf(stream, "\
d88 1
a88 1
  fprintf(stream, "\
d277 1
a277 1
#define REG_NAME_CNT        (sizeof(pre_defined_registers) / sizeof(struct pd_reg))
d440 1
a440 1
size_t md_longopts_size = sizeof(md_longopts);
d685 1
a685 1
#define MAP(str,reloc) { str, sizeof(str)-1, reloc }
d945 1
a945 1
	  *p = ascebc [(unsigned char)(*input_line_pointer)];
d2341 1
a2341 1
	    abort();
d2918 1
a2918 1
          fprintf(stderr,
@


1.3
log
@2000-09-11  Kazu Hirata  <kazu@@hxi.com>

	* config/tc-i370.c: Fix formatting.
	* config/tc-i960.c: Likewise.
	* config/tc-m68k.c: Likewise.
@
text
@d555 1
a555 1
// hack alert -- specify the different 370 architectures
d659 7
a665 8
 * Currently, i370 does not support (don't really need to support) any
 * of these fancier markups ... for example, no one is going to
 * write 'L 6,=V(bogus)@@got' it just doesn't make sense (at least to me).
 * So basically, we could get away with this routine returning
 * BFD_RELOC_UNUSED in all circumstances.  However, I'll leave
 * in for now in case someone ambitious finds a good use for this stuff ...
 * this routine was pretty much just copied from the powerpc code ...
 */
d689 8
a696 5
    //     MAP ("l",        	BFD_RELOC_LO16),
    //     MAP ("h",        	BFD_RELOC_HI16),
    //     MAP ("ha",        	BFD_RELOC_HI16_S),
    MAP ("fixup",        BFD_RELOC_CTOR),          /* warnings with -mrelocatable */
    { (char *)0,        0,	BFD_RELOC_UNUSED }
@


1.2
log
@Fix comments.
@
text
@d21 1
a21 1
   02111-1307, USA. */
a77 1

a117 1

a186 1

a193 1

d204 1
a204 1
   The table is sorted. Suitable for searching by a binary search. */
a220 1

d531 1
a531 1
   but can be made more fine grained if desred. */
d539 1
a539 1
  /* override with the superset for the moment. */
d579 1
a579 1
  /* Set the ELF flags if desired. */
d749 2
a750 2
/* Like normal .long/.short/.word, except support @@got, etc. */
/* clobbers input_line_pointer, checks end-of-line. */
d790 1
a790 1
  input_line_pointer--;        	/* Put terminator back into stream. */
a1270 1

d1274 1
a1274 1
/* Provide support for literal pools within the text section. */
d1525 1
a1525 1
  /* normally branches appear in the text section only... */
a1751 1

d1759 1
a1759 1
  /* output largest literals first, then the smaller ones. */
d1837 1
a1837 1
  /* replace it with "." so that expr doesn't get confused. */
d1843 1
a1843 1
   * be a more complex exprsssion too ... */
d2167 1
a2167 1
      /* register names are only allowed where there are registers ... */
d2185 1
a2185 1
       * and adress literals in the .data (or other) section. */
d2220 1
a2220 1
           * left here for any dubious future expansion reasons ... */
d2616 1
a2616 1
   * format, and the ieee format.  Support only the ieee format. */
a2700 1

d2792 1
a2792 1
         fisxp->fx_size is the length of the instruction. */
d2819 1
a2819 1
	 i370 addressing, this would be unusual. */
@


1.1
log
@Add IBM 370 support.
@
text
@d2588 2
a2589 2
   of type type, and store the appropriate bytes in *litp.  The number
   of LITTLENUMS emitted is stored in *sizep .  An error message is
@

