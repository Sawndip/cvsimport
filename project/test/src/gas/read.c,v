head	1.185;
access;
symbols
	binutils-2_24-branch:1.184.0.2
	binutils-2_24-branchpoint:1.184
	binutils-2_21_1:1.167.2.3
	binutils-2_23_2:1.180
	binutils-2_23_1:1.180
	binutils-2_23:1.180
	binutils-2_23-branch:1.180.0.2
	binutils-2_23-branchpoint:1.180
	binutils-2_22_branch:1.173.2.1.0.2
	binutils-2_22:1.173.2.1
	binutils-2_22-branch:1.173.0.2
	binutils-2_22-branchpoint:1.173
	binutils-2_21:1.167
	binutils-2_21-branch:1.167.0.2
	binutils-2_21-branchpoint:1.167
	binutils-2_20_1:1.153.2.3
	binutils-2_20:1.153.2.3
	binutils-arc-20081103-branch:1.142.0.4
	binutils-arc-20081103-branchpoint:1.142
	binutils-2_20-branch:1.153.0.2
	binutils-2_20-branchpoint:1.153
	dje-cgen-play1-branch:1.151.0.2
	dje-cgen-play1-branchpoint:1.151
	arc-20081103-branch:1.142.0.2
	arc-20081103-branchpoint:1.142
	binutils-2_19_1:1.140
	binutils-2_19:1.140
	binutils-2_19-branch:1.140.0.2
	binutils-2_19-branchpoint:1.140
	binutils-2_18:1.128
	binutils-2_18-branch:1.128.0.2
	binutils-2_18-branchpoint:1.128
	binutils-csl-coldfire-4_1-32:1.115
	binutils-csl-sourcerygxx-4_1-32:1.115
	binutils-csl-innovasic-fido-3_4_4-33:1.115
	binutils-csl-sourcerygxx-3_4_4-32:1.94.2.1
	binutils-csl-coldfire-4_1-30:1.115
	binutils-csl-sourcerygxx-4_1-30:1.115
	binutils-csl-coldfire-4_1-28:1.115
	binutils-csl-sourcerygxx-4_1-29:1.115
	binutils-csl-sourcerygxx-4_1-28:1.115
	binutils-csl-arm-2006q3-27:1.115
	binutils-csl-sourcerygxx-4_1-27:1.115
	binutils-csl-arm-2006q3-26:1.115
	binutils-csl-sourcerygxx-4_1-26:1.115
	binutils-csl-sourcerygxx-4_1-25:1.115
	binutils-csl-sourcerygxx-4_1-24:1.115
	binutils-csl-sourcerygxx-4_1-23:1.115
	binutils-csl-sourcerygxx-4_1-21:1.115
	binutils-csl-arm-2006q3-21:1.115
	binutils-csl-sourcerygxx-4_1-22:1.115
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.115
	binutils-csl-sourcerygxx-4_1-20:1.115
	binutils-csl-arm-2006q3-19:1.115
	binutils-csl-sourcerygxx-4_1-19:1.115
	binutils-csl-sourcerygxx-4_1-18:1.115
	binutils-csl-renesas-4_1-9:1.115
	binutils-csl-sourcerygxx-3_4_4-25:1.94.2.1
	binutils-csl-renesas-4_1-8:1.115
	binutils-csl-renesas-4_1-7:1.115
	binutils-csl-renesas-4_1-6:1.115
	binutils-csl-sourcerygxx-4_1-17:1.115
	binutils-csl-sourcerygxx-4_1-14:1.115
	binutils-csl-sourcerygxx-4_1-15:1.115
	binutils-csl-sourcerygxx-4_1-13:1.115
	binutils-2_17:1.115
	binutils-csl-sourcerygxx-4_1-12:1.115
	binutils-csl-sourcerygxx-3_4_4-21:1.115
	binutils-csl-wrs-linux-3_4_4-24:1.94
	binutils-csl-wrs-linux-3_4_4-23:1.94
	binutils-csl-sourcerygxx-4_1-9:1.115
	binutils-csl-sourcerygxx-4_1-8:1.115
	binutils-csl-sourcerygxx-4_1-7:1.115
	binutils-csl-arm-2006q1-6:1.115
	binutils-csl-sourcerygxx-4_1-6:1.115
	binutils-csl-wrs-linux-3_4_4-22:1.94
	binutils-csl-coldfire-4_1-11:1.115
	binutils-csl-sourcerygxx-3_4_4-19:1.115
	binutils-csl-coldfire-4_1-10:1.115
	binutils-csl-sourcerygxx-4_1-5:1.115
	binutils-csl-sourcerygxx-4_1-4:1.115
	binutils-csl-wrs-linux-3_4_4-21:1.94
	binutils-csl-morpho-4_1-4:1.115
	binutils-csl-sourcerygxx-3_4_4-17:1.115
	binutils-csl-wrs-linux-3_4_4-20:1.94
	binutils-2_17-branch:1.115.0.4
	binutils-2_17-branchpoint:1.115
	binutils-csl-2_17-branch:1.115.0.2
	binutils-csl-2_17-branchpoint:1.115
	binutils-csl-gxxpro-3_4-branch:1.94.2.1.0.2
	binutils-csl-gxxpro-3_4-branchpoint:1.94.2.1
	binutils-2_16_1:1.94.2.1
	binutils-csl-arm-2005q1b:1.94
	binutils-2_16:1.94.2.1
	binutils-csl-arm-2005q1a:1.94
	binutils-csl-arm-2005q1-branch:1.94.0.4
	binutils-csl-arm-2005q1-branchpoint:1.94
	binutils-2_16-branch:1.94.0.2
	binutils-2_16-branchpoint:1.94
	csl-arm-2004-q3d:1.79
	csl-arm-2004-q3:1.79
	binutils-2_15:1.75.4.2
	binutils-2_15-branchpoint:1.75
	csl-arm-2004-q1a:1.78
	csl-arm-2004-q1:1.77
	binutils-2_15-branch:1.75.0.4
	cagney_bfdfile-20040213-branch:1.75.0.2
	cagney_bfdfile-20040213-branchpoint:1.75
	cagney_bigcore-20040122-branch:1.73.0.2
	cagney_bigcore-20040122-branchpoint:1.73
	csl-arm-2003-q4:1.73
	binutils-2_14:1.59.2.1
	binutils-2_14-branch:1.59.0.2
	binutils-2_14-branchpoint:1.59
	binutils-2_13_2_1:1.52.2.1
	binutils-2_13_2:1.52.2.1
	binutils-2_13_1:1.52.2.1
	binutils-2_13:1.52
	binutils-2_13-branchpoint:1.52
	binutils-2_13-branch:1.52.0.2
	binutils-2_12_1:1.50
	binutils-2_12:1.50
	binutils-2_12-branch:1.50.0.2
	binutils-2_12-branchpoint:1.50
	cygnus_cvs_20020108_pre:1.50
	binutils-2_11_2:1.32.2.5
	binutils-2_11_1:1.32.2.5
	binutils-2_11:1.32
	x86_64versiong3:1.32
	binutils-2_11-branch:1.32.0.2
	binutils-2_10_1:1.18
	binutils-2_10:1.18
	binutils-2_10-branch:1.18.0.2
	binutils-2_10-branchpoint:1.18
	binutils_latest_snapshot:1.185
	repo-unification-2000-02-06:1.12
	binu_ss_19990721:1.8
	binu_ss_19990602:1.2
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.185
date	2013.10.14.09.15.09;	author nickc;	state Exp;
branches;
next	1.184;

1.184
date	2013.04.11.10.54.13;	author jules;	state Exp;
branches;
next	1.183;

1.183
date	2013.03.08.10.17.00;	author cltang;	state Exp;
branches;
next	1.182;

1.182
date	2013.01.10.19.51.54;	author hjl;	state Exp;
branches;
next	1.181;

1.181
date	2012.11.09.18.07.09;	author macro;	state Exp;
branches;
next	1.180;

1.180
date	2012.06.09.13.22.00;	author hjl;	state Exp;
branches;
next	1.179;

1.179
date	2012.06.07.12.47.23;	author amodra;	state Exp;
branches;
next	1.178;

1.178
date	2012.05.29.16.32.09;	author roland;	state Exp;
branches;
next	1.177;

1.177
date	2012.05.28.14.20.12;	author nickc;	state Exp;
branches;
next	1.176;

1.176
date	2012.03.13.17.01.34;	author roland;	state Exp;
branches;
next	1.175;

1.175
date	2012.03.13.16.59.55;	author roland;	state Exp;
branches;
next	1.174;

1.174
date	2011.10.12.21.07.07;	author amodra;	state Exp;
branches;
next	1.173;

1.173
date	2011.06.02.13.43.19;	author nickc;	state Exp;
branches
	1.173.2.1;
next	1.172;

1.172
date	2011.05.06.14.48.56;	author gingold;	state Exp;
branches;
next	1.171;

1.171
date	2011.03.18.10.46.52;	author amodra;	state Exp;
branches;
next	1.170;

1.170
date	2011.03.17.10.59.29;	author amodra;	state Exp;
branches;
next	1.169;

1.169
date	2011.02.15.18.01.07;	author rth;	state Exp;
branches;
next	1.168;

1.168
date	2010.12.01.21.34.10;	author macro;	state Exp;
branches;
next	1.167;

1.167
date	2010.08.02.13.19.44;	author amodra;	state Exp;
branches
	1.167.2.1;
next	1.166;

1.166
date	2010.06.28.14.06.56;	author amodra;	state Exp;
branches;
next	1.165;

1.165
date	2010.05.05.14.17.48;	author nathan;	state Exp;
branches;
next	1.164;

1.164
date	2010.04.21.18.17.45;	author hjl;	state Exp;
branches;
next	1.163;

1.163
date	2010.04.21.18.09.51;	author hjl;	state Exp;
branches;
next	1.162;

1.162
date	2010.04.09.14.40.18;	author nickc;	state Exp;
branches;
next	1.161;

1.161
date	2009.12.11.13.42.09;	author nickc;	state Exp;
branches;
next	1.160;

1.160
date	2009.11.19.08.41.27;	author jbeulich;	state Exp;
branches;
next	1.159;

1.159
date	2009.10.26.23.57.43;	author amodra;	state Exp;
branches;
next	1.158;

1.158
date	2009.10.15.10.58.34;	author amodra;	state Exp;
branches;
next	1.157;

1.157
date	2009.10.05.21.57.12;	author amodra;	state Exp;
branches;
next	1.156;

1.156
date	2009.09.29.14.17.07;	author nickc;	state Exp;
branches;
next	1.155;

1.155
date	2009.09.11.15.27.33;	author nickc;	state Exp;
branches;
next	1.154;

1.154
date	2009.09.08.10.36.38;	author amodra;	state Exp;
branches;
next	1.153;

1.153
date	2009.09.02.07.24.19;	author amodra;	state Exp;
branches
	1.153.2.1;
next	1.152;

1.152
date	2009.09.01.00.24.00;	author jiez;	state Exp;
branches;
next	1.151;

1.151
date	2009.06.22.17.56.00;	author nickc;	state Exp;
branches;
next	1.150;

1.150
date	2009.03.24.01.04.25;	author hjl;	state Exp;
branches;
next	1.149;

1.149
date	2009.03.05.15.27.58;	author jsm28;	state Exp;
branches;
next	1.148;

1.148
date	2009.01.26.14.36.42;	author ams;	state Exp;
branches;
next	1.147;

1.147
date	2009.01.19.11.50.31;	author ams;	state Exp;
branches;
next	1.146;

1.146
date	2009.01.16.10.26.47;	author ams;	state Exp;
branches;
next	1.145;

1.145
date	2009.01.15.13.03.05;	author ams;	state Exp;
branches;
next	1.144;

1.144
date	2008.11.14.13.03.25;	author nickc;	state Exp;
branches;
next	1.143;

1.143
date	2008.11.12.01.41.12;	author hp;	state Exp;
branches;
next	1.142;

1.142
date	2008.10.07.14.21.59;	author hjl;	state Exp;
branches;
next	1.141;

1.141
date	2008.10.06.08.17.47;	author nickc;	state Exp;
branches;
next	1.140;

1.140
date	2008.03.13.10.51.33;	author nickc;	state Exp;
branches;
next	1.139;

1.139
date	2008.03.03.15.28.57;	author hjl;	state Exp;
branches;
next	1.138;

1.138
date	2008.02.07.08.40.29;	author amodra;	state Exp;
branches;
next	1.137;

1.137
date	2008.01.25.16.18.40;	author nickc;	state Exp;
branches;
next	1.136;

1.136
date	2008.01.11.16.18.43;	author schwab;	state Exp;
branches;
next	1.135;

1.135
date	2008.01.09.17.30.58;	author bwilson;	state Exp;
branches;
next	1.134;

1.134
date	2007.11.04.23.49.08;	author dannysmith;	state Exp;
branches;
next	1.133;

1.133
date	2007.10.17.16.45.54;	author nickc;	state Exp;
branches;
next	1.132;

1.132
date	2007.10.15.02.01.25;	author amodra;	state Exp;
branches;
next	1.131;

1.131
date	2007.10.04.17.05.36;	author nickc;	state Exp;
branches;
next	1.130;

1.130
date	2007.09.18.01.05.44;	author amodra;	state Exp;
branches;
next	1.129;

1.129
date	2007.09.17.16.34.47;	author nickc;	state Exp;
branches;
next	1.128;

1.128
date	2007.07.03.11.01.03;	author nickc;	state Exp;
branches;
next	1.127;

1.127
date	2007.06.29.16.29.16;	author jsm28;	state Exp;
branches;
next	1.126;

1.126
date	2007.04.22.05.27.58;	author amodra;	state Exp;
branches;
next	1.125;

1.125
date	2007.04.21.06.54.56;	author amodra;	state Exp;
branches;
next	1.124;

1.124
date	2007.03.26.12.23.48;	author amodra;	state Exp;
branches;
next	1.123;

1.123
date	2007.03.09.23.25.59;	author aoliva;	state Exp;
branches;
next	1.122;

1.122
date	2007.03.09.07.14.23;	author aoliva;	state Exp;
branches;
next	1.121;

1.121
date	2006.08.29.15.19.43;	author nickc;	state Exp;
branches;
next	1.120;

1.120
date	2006.07.24.16.30.55;	author nickc;	state Exp;
branches;
next	1.119;

1.119
date	2006.07.17.10.40.11;	author ths;	state Exp;
branches;
next	1.118;

1.118
date	2006.07.16.10.19.19;	author ths;	state Exp;
branches;
next	1.117;

1.117
date	2006.06.07.11.27.57;	author amodra;	state Exp;
branches;
next	1.116;

1.116
date	2006.05.01.09.21.46;	author bje;	state Exp;
branches;
next	1.115;

1.115
date	2005.11.17.07.29.28;	author jbeulich;	state Exp;
branches;
next	1.114;

1.114
date	2005.11.16.01.49.48;	author amodra;	state Exp;
branches;
next	1.113;

1.113
date	2005.11.15.22.58.38;	author amodra;	state Exp;
branches;
next	1.112;

1.112
date	2005.11.04.19.45.24;	author aoliva;	state Exp;
branches;
next	1.111;

1.111
date	2005.10.27.07.40.07;	author jbeulich;	state Exp;
branches;
next	1.110;

1.110
date	2005.10.24.17.51.41;	author aoliva;	state Exp;
branches;
next	1.109;

1.109
date	2005.10.11.11.16.16;	author nickc;	state Exp;
branches;
next	1.108;

1.108
date	2005.09.21.00.12.19;	author amodra;	state Exp;
branches;
next	1.107;

1.107
date	2005.09.20.03.06.13;	author amodra;	state Exp;
branches;
next	1.106;

1.106
date	2005.08.11.01.25.20;	author amodra;	state Exp;
branches;
next	1.105;

1.105
date	2005.08.07.10.34.52;	author nickc;	state Exp;
branches;
next	1.104;

1.104
date	2005.05.17.14.02.27;	author jbeulich;	state Exp;
branches;
next	1.103;

1.103
date	2005.05.10.07.45.11;	author jbeulich;	state Exp;
branches;
next	1.102;

1.102
date	2005.05.06.06.38.10;	author jbeulich;	state Exp;
branches;
next	1.101;

1.101
date	2005.05.05.09.12.46;	author nickc;	state Exp;
branches;
next	1.100;

1.100
date	2005.04.29.00.22.26;	author bje;	state Exp;
branches;
next	1.99;

1.99
date	2005.04.26.17.15.18;	author hjl;	state Exp;
branches;
next	1.98;

1.98
date	2005.04.25.06.43.45;	author jbeulich;	state Exp;
branches;
next	1.97;

1.97
date	2005.04.11.12.46.35;	author jbeulich;	state Exp;
branches;
next	1.96;

1.96
date	2005.04.09.06.21.19;	author amodra;	state Exp;
branches;
next	1.95;

1.95
date	2005.04.09.03.48.09;	author amodra;	state Exp;
branches;
next	1.94;

1.94
date	2005.03.01.02.00.14;	author amodra;	state Exp;
branches
	1.94.2.1;
next	1.93;

1.93
date	2005.02.23.02.44.18;	author clm;	state Exp;
branches;
next	1.92;

1.92
date	2005.02.22.12.58.32;	author amodra;	state Exp;
branches;
next	1.91;

1.91
date	2005.02.21.08.39.52;	author amodra;	state Exp;
branches;
next	1.90;

1.90
date	2005.02.19.08.56.08;	author amodra;	state Exp;
branches;
next	1.89;

1.89
date	2005.02.17.13.46.00;	author amodra;	state Exp;
branches;
next	1.88;

1.88
date	2005.01.31.14.26.08;	author jbeulich;	state Exp;
branches;
next	1.87;

1.87
date	2005.01.21.05.54.38;	author bje;	state Exp;
branches;
next	1.86;

1.86
date	2005.01.20.06.46.41;	author amodra;	state Exp;
branches;
next	1.85;

1.85
date	2005.01.19.11.53.50;	author rsandifo;	state Exp;
branches;
next	1.84;

1.84
date	2004.12.29.10.21.58;	author amodra;	state Exp;
branches;
next	1.83;

1.83
date	2004.12.07.12.13.24;	author bje;	state Exp;
branches;
next	1.82;

1.82
date	2004.12.02.09.39.14;	author amodra;	state Exp;
branches;
next	1.81;

1.81
date	2004.11.22.13.05.26;	author hp;	state Exp;
branches;
next	1.80;

1.80
date	2004.11.10.03.28.44;	author amodra;	state Exp;
branches;
next	1.79;

1.79
date	2004.08.13.19.53.51;	author nickc;	state Exp;
branches;
next	1.78;

1.78
date	2004.04.19.09.32.55;	author nathan;	state Exp;
branches;
next	1.77;

1.77
date	2004.03.18.13.31.02;	author nathan;	state Exp;
branches;
next	1.76;

1.76
date	2004.03.12.17.48.12;	author bwilson;	state Exp;
branches;
next	1.75;

1.75
date	2004.02.09.12.12.42;	author nathan;	state Exp;
branches
	1.75.4.1;
next	1.74;

1.74
date	2004.02.06.16.00.20;	author nathan;	state Exp;
branches;
next	1.73;

1.73
date	2003.12.13.08.59.24;	author amodra;	state Exp;
branches;
next	1.72;

1.72
date	2003.12.13.08.23.01;	author amodra;	state Exp;
branches;
next	1.71;

1.71
date	2003.11.27.19.14.41;	author kazu;	state Exp;
branches;
next	1.70;

1.70
date	2003.10.27.12.45.17;	author kazu;	state Exp;
branches;
next	1.69;

1.69
date	2003.08.16.14.04.48;	author amodra;	state Exp;
branches;
next	1.68;

1.68
date	2003.07.30.17.21.52;	author ro;	state Exp;
branches;
next	1.67;

1.67
date	2003.07.28.20.35.59;	author ro;	state Exp;
branches;
next	1.66;

1.66
date	2003.07.22.15.27.06;	author hjl;	state Exp;
branches;
next	1.65;

1.65
date	2003.06.24.11.10.40;	author nickc;	state Exp;
branches;
next	1.64;

1.64
date	2003.06.11.23.16.57;	author rth;	state Exp;
branches;
next	1.63;

1.63
date	2003.06.02.22.48.58;	author amodra;	state Exp;
branches;
next	1.62;

1.62
date	2003.05.20.07.58.06;	author amodra;	state Exp;
branches;
next	1.61;

1.61
date	2003.05.13.01.51.40;	author hp;	state Exp;
branches;
next	1.60;

1.60
date	2003.05.02.02.41.45;	author hjl;	state Exp;
branches;
next	1.59;

1.59
date	2003.03.13.11.49.33;	author nickc;	state Exp;
branches
	1.59.2.1;
next	1.58;

1.58
date	2003.01.11.06.24.12;	author amodra;	state Exp;
branches;
next	1.57;

1.57
date	2002.12.02.15.42.08;	author nickc;	state Exp;
branches;
next	1.56;

1.56
date	2002.12.02.07.18.53;	author hp;	state Exp;
branches;
next	1.55;

1.55
date	2002.08.31.18.51.07;	author hp;	state Exp;
branches;
next	1.54;

1.54
date	2002.08.27.11.09.42;	author amodra;	state Exp;
branches;
next	1.53;

1.53
date	2002.08.14.16.38.14;	author nickc;	state Exp;
branches;
next	1.52;

1.52
date	2002.06.14.14.08.51;	author drow;	state Exp;
branches
	1.52.2.1;
next	1.51;

1.51
date	2002.05.03.02.25.33;	author kazu;	state Exp;
branches;
next	1.50;

1.50
date	2002.01.07.17.51.18;	author nickc;	state Exp;
branches;
next	1.49;

1.49
date	2001.10.12.08.56.17;	author nickc;	state Exp;
branches;
next	1.48;

1.48
date	2001.10.05.10.53.00;	author amodra;	state Exp;
branches;
next	1.47;

1.47
date	2001.09.19.05.33.19;	author hjl;	state Exp;
branches;
next	1.46;

1.46
date	2001.08.17.16.01.49;	author amodra;	state Exp;
branches;
next	1.45;

1.45
date	2001.08.01.01.44.25;	author amodra;	state Exp;
branches;
next	1.44;

1.44
date	2001.07.27.08.35.56;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2001.07.10.09.45.50;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	2001.07.09.08.19.17;	author nickc;	state Exp;
branches;
next	1.41;

1.41
date	2001.07.05.00.36.50;	author bje;	state Exp;
branches;
next	1.40;

1.40
date	2001.05.31.00.00.30;	author rth;	state Exp;
branches;
next	1.39;

1.39
date	2001.05.25.01.59.43;	author amodra;	state Exp;
branches;
next	1.38;

1.38
date	2001.05.25.00.01.30;	author amodra;	state Exp;
branches;
next	1.37;

1.37
date	2001.05.14.22.37.47;	author rth;	state Exp;
branches;
next	1.36;

1.36
date	2001.03.28.17.24.01;	author hjl;	state Exp;
branches;
next	1.35;

1.35
date	2001.03.27.19.13.55;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	2001.03.17.03.02.06;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2001.03.08.23.24.22;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2000.12.28.10.07.55;	author rth;	state Exp;
branches
	1.32.2.1;
next	1.31;

1.31
date	2000.11.17.08.47.51;	author rth;	state Exp;
branches;
next	1.30;

1.30
date	2000.11.07.01.18.45;	author kazu;	state Exp;
branches;
next	1.29;

1.29
date	2000.11.02.19.32.47;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2000.10.25.19.15.33;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	2000.09.12.03.56.22;	author kazu;	state Exp;
branches;
next	1.26;

1.26
date	2000.07.28.05.05.19;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2000.07.20.17.12.25;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2000.06.09.00.00.02;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2000.06.04.05.03.31;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2000.06.04.03.28.38;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2000.06.03.22.33.09;	author hjl;	state Exp;
branches;
next	1.20;

1.20
date	2000.06.02.02.52.09;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2000.04.21.20.22.22;	author wilson;	state Exp;
branches;
next	1.18;

1.18
date	2000.03.26.14.47.33;	author twall;	state Exp;
branches;
next	1.17;

1.17
date	2000.03.13.20.46.06;	author hp;	state Exp;
branches;
next	1.16;

1.16
date	2000.02.24.01.56.31;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2000.02.10.21.03.12;	author twall;	state Exp;
branches;
next	1.14;

1.14
date	2000.02.08.19.06.00;	author twall;	state Exp;
branches;
next	1.13;

1.13
date	2000.02.08.14.13.57;	author twall;	state Exp;
branches;
next	1.12;

1.12
date	2000.02.03.18.20.23;	author twall;	state Exp;
branches;
next	1.11;

1.11
date	2000.01.26.23.58.13;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2000.01.26.22.48.31;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	99.11.03.22.14.47;	author ian;	state Exp;
branches;
next	1.8;

1.8
date	99.07.11.20.19.58;	author ian;	state Exp;
branches;
next	1.7;

1.7
date	99.06.12.16.49.43;	author ian;	state Exp;
branches;
next	1.6;

1.6
date	99.06.10.21.36.37;	author ian;	state Exp;
branches;
next	1.5;

1.5
date	99.06.05.18.19.07;	author rth;	state Exp;
branches;
next	1.4;

1.4
date	99.06.03.02.51.09;	author rth;	state Exp;
branches;
next	1.3;

1.3
date	99.06.03.00.24.14;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.05.17.03.21.45;	author amodra;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.41;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.173.2.1
date	2011.10.25.03.06.33;	author amodra;	state Exp;
branches;
next	;

1.167.2.1
date	2011.02.01.12.25.40;	author amodra;	state Exp;
branches;
next	1.167.2.2;

1.167.2.2
date	2011.03.17.11.00.47;	author amodra;	state Exp;
branches;
next	1.167.2.3;

1.167.2.3
date	2011.05.29.04.51.37;	author amodra;	state Exp;
branches;
next	;

1.153.2.1
date	2009.09.08.10.53.21;	author amodra;	state Exp;
branches;
next	1.153.2.2;

1.153.2.2
date	2009.09.11.15.28.43;	author nickc;	state Exp;
branches;
next	1.153.2.3;

1.153.2.3
date	2009.10.07.08.35.59;	author amodra;	state Exp;
branches;
next	;

1.94.2.1
date	2005.04.12.12.14.23;	author amodra;	state Exp;
branches;
next	;

1.75.4.1
date	2004.03.12.17.55.20;	author bwilson;	state Exp;
branches;
next	1.75.4.2;

1.75.4.2
date	2004.04.09.18.28.10;	author drow;	state Exp;
branches;
next	;

1.59.2.1
date	2003.05.13.03.01.18;	author hp;	state Exp;
branches;
next	;

1.52.2.1
date	2002.09.23.22.14.22;	author drow;	state Exp;
branches;
next	;

1.32.2.1
date	2001.05.14.22.59.12;	author rth;	state Exp;
branches;
next	1.32.2.2;

1.32.2.2
date	2001.05.23.03.41.09;	author amodra;	state Exp;
branches;
next	1.32.2.3;

1.32.2.3
date	2001.05.31.00.05.15;	author rth;	state Exp;
branches;
next	1.32.2.4;

1.32.2.4
date	2001.06.07.03.15.25;	author amodra;	state Exp;
branches;
next	1.32.2.5;

1.32.2.5
date	2001.06.11.10.04.45;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.41;	author rth;	state Exp;
branches;
next	;


desc
@@


1.185
log
@	* gen-aout.c (main): Fix formatting.  Close file.

	* emultempl/aix.em (_read_file): Close file at end of function.

	* gas/all/itbl-test.c (main): Close fas.

	* read.c (add_include_dir): Use xrealloc.
	* config/tc-score.c (do_macro_bcmp): Initialise inst_main.
	* config/tc-tic6x.c (tic6x_parse_operand): Initialise second_reg.

	* readelf.c (decode_arm_unwind): Initialise addr structure.
	(process_symbol_table): Free lengths.
	* srcconv.c (wr_sc): Free info.

	* chew.c (perform): Free next.
@
text
@/* read.c - read a source file -
   Copyright 1986-2013 Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* If your chars aren't 8 bits, you will change this a bit (eg. to 0xFF).
   But then, GNU isn't spozed to run on your machine anyway.
   (RMS is so shortsighted sometimes.)  */
#define MASK_CHAR ((int)(unsigned char) -1)

/* This is the largest known floating point format (for now). It will
   grow when we do 4361 style flonums.  */
#define MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT (16)

/* Routines that read assembler source text to build spaghetti in memory.
   Another group of these functions is in the expr.c module.  */

#include "as.h"
#include "safe-ctype.h"
#include "subsegs.h"
#include "sb.h"
#include "macro.h"
#include "obstack.h"
#include "ecoff.h"
#include "dw2gencfi.h"
#include "wchar.h"

#ifndef TC_START_LABEL
#define TC_START_LABEL(x,y,z) (x == ':')
#endif

/* Set by the object-format or the target.  */
#ifndef TC_IMPLICIT_LCOMM_ALIGNMENT
#define TC_IMPLICIT_LCOMM_ALIGNMENT(SIZE, P2VAR)		\
  do								\
    {								\
      if ((SIZE) >= 8)						\
	(P2VAR) = 3;						\
      else if ((SIZE) >= 4)					\
	(P2VAR) = 2;						\
      else if ((SIZE) >= 2)					\
	(P2VAR) = 1;						\
      else							\
	(P2VAR) = 0;						\
    }								\
  while (0)
#endif

char *input_line_pointer;	/*->next char of source file to parse.  */

#if BITS_PER_CHAR != 8
/*  The following table is indexed by[(char)] and will break if
    a char does not have exactly 256 states (hopefully 0:255!)!  */
die horribly;
#endif

#ifndef LEX_AT
#define LEX_AT 0
#endif

#ifndef LEX_BR
/* The RS/6000 assembler uses {,},[,] as parts of symbol names.  */
#define LEX_BR 0
#endif

#ifndef LEX_PCT
/* The Delta 68k assembler permits % inside label names.  */
#define LEX_PCT 0
#endif

#ifndef LEX_QM
/* The PowerPC Windows NT assemblers permits ? inside label names.  */
#define LEX_QM 0
#endif

#ifndef LEX_HASH
/* The IA-64 assembler uses # as a suffix designating a symbol.  We include
   it in the symbol and strip it out in tc_canonicalize_symbol_name.  */
#define LEX_HASH 0
#endif

#ifndef LEX_DOLLAR
#define LEX_DOLLAR 3
#endif

#ifndef LEX_TILDE
/* The Delta 68k assembler permits ~ at start of label names.  */
#define LEX_TILDE 0
#endif

/* Used by is_... macros. our ctype[].  */
char lex_type[256] = {
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* @@ABCDEFGHIJKLMNO */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* PQRSTUVWXYZ[\]^_ */
  0, 0, 0, LEX_HASH, LEX_DOLLAR, LEX_PCT, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, /* _!"#$%&'()*+,-./ */
  1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, LEX_QM,	/* 0123456789:;<=>? */
  LEX_AT, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,	/* @@ABCDEFGHIJKLMNO */
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, LEX_BR, 0, LEX_BR, 0, 3, /* PQRSTUVWXYZ[\]^_ */
  0, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,	/* `abcdefghijklmno */
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, LEX_BR, 0, LEX_BR, LEX_TILDE, 0, /* pqrstuvwxyz{|}~.  */
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3,
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3
};

/* In: a character.
   Out: 1 if this character ends a line.
	2 if this character is a line separator.  */
char is_end_of_line[256] = {
#ifdef CR_EOL
  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0,	/* @@abcdefghijklmno */
#else
  1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0,	/* @@abcdefghijklmno */
#endif
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* _!"#$%&'()*+,-./ */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0123456789:;<=>? */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* */
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0	/* */
};

#ifndef TC_CASE_SENSITIVE
char original_case_string[128];
#endif

/* Functions private to this file.  */

static char *buffer;	/* 1st char of each buffer of lines is here.  */
static char *buffer_limit;	/*->1 + last char in buffer.  */

/* TARGET_BYTES_BIG_ENDIAN is required to be defined to either 0 or 1
   in the tc-<CPU>.h file.  See the "Porting GAS" section of the
   internals manual.  */
int target_big_endian = TARGET_BYTES_BIG_ENDIAN;

/* Variables for handling include file directory table.  */

/* Table of pointers to directories to search for .include's.  */
char **include_dirs;

/* How many are in the table.  */
int include_dir_count;

/* Length of longest in table.  */
int include_dir_maxlen = 1;

#ifndef WORKING_DOT_WORD
struct broken_word *broken_words;
int new_broken_words;
#endif

/* The current offset into the absolute section.  We don't try to
   build frags in the absolute section, since no data can be stored
   there.  We just keep track of the current offset.  */
addressT abs_section_offset;

/* If this line had an MRI style label, it is stored in this variable.
   This is used by some of the MRI pseudo-ops.  */
symbolS *line_label;

/* This global variable is used to support MRI common sections.  We
   translate such sections into a common symbol.  This variable is
   non-NULL when we are in an MRI common section.  */
symbolS *mri_common_symbol;

/* In MRI mode, after a dc.b pseudo-op with an odd number of bytes, we
   need to align to an even byte boundary unless the next pseudo-op is
   dc.b, ds.b, or dcb.b.  This variable is set to 1 if an alignment
   may be needed.  */
static int mri_pending_align;

#ifndef NO_LISTING
#ifdef OBJ_ELF
/* This variable is set to be non-zero if the next string we see might
   be the name of the source file in DWARF debugging information.  See
   the comment in emit_expr for the format we look for.  */
static int dwarf_file_string;
#endif
#endif

/* If the target defines the md_frag_max_var hook then we know
   enough to implement the .bundle_align_mode features.  */
#ifdef md_frag_max_var
# define HANDLE_BUNDLE
#endif

#ifdef HANDLE_BUNDLE
/* .bundle_align_mode sets this.  Normally it's zero.  When nonzero,
   it's the exponent of the bundle size, and aligned instruction bundle
   mode is in effect.  */
static unsigned int bundle_align_p2;

/* These are set by .bundle_lock and .bundle_unlock.  .bundle_lock sets
   bundle_lock_frag to frag_now and then starts a new frag with
   frag_align_code.  At the same time, bundle_lock_frain gets frchain_now,
   so that .bundle_unlock can verify that we didn't change segments.
   .bundle_unlock resets both to NULL.  If we detect a bundling violation,
   then we reset bundle_lock_frchain to NULL as an indicator that we've
   already diagnosed the error with as_bad and don't need a cascade of
   redundant errors, but bundle_lock_frag remains set to indicate that
   we are expecting to see .bundle_unlock.  */
static fragS *bundle_lock_frag;
static frchainS *bundle_lock_frchain;

/* This is incremented by .bundle_lock and decremented by .bundle_unlock,
   to allow nesting.  */
static unsigned int bundle_lock_depth;
#endif

static void do_s_func (int end_p, const char *default_prefix);
static void do_align (int, char *, int, int);
static void s_align (int, int);
static void s_altmacro (int);
static void s_bad_end (int);
static void s_reloc (int);
static int hex_float (int, char *);
static segT get_known_segmented_expression (expressionS * expP);
static void pobegin (void);
static size_t get_non_macro_line_sb (sb *);
static void generate_file_debug (void);
static char *_find_end_of_line (char *, int, int, int);

void
read_begin (void)
{
  const char *p;

  pobegin ();
  obj_read_begin_hook ();

  /* Something close -- but not too close -- to a multiple of 1024.
     The debugging malloc I'm using has 24 bytes of overhead.  */
  obstack_begin (&notes, chunksize);
  obstack_begin (&cond_obstack, chunksize);

  /* Use machine dependent syntax.  */
  for (p = line_separator_chars; *p; p++)
    is_end_of_line[(unsigned char) *p] = 2;
  /* Use more.  FIXME-SOMEDAY.  */

  if (flag_mri)
    lex_type['?'] = 3;
}

#ifndef TC_ADDRESS_BYTES
#define TC_ADDRESS_BYTES address_bytes

static inline int
address_bytes (void)
{
  /* Choose smallest of 1, 2, 4, 8 bytes that is large enough to
     contain an address.  */
  int n = (stdoutput->arch_info->bits_per_address - 1) / 8;
  n |= n >> 1;
  n |= n >> 2;
  n += 1;
  return n;
}
#endif

/* Set up pseudo-op tables.  */

static struct hash_control *po_hash;

static const pseudo_typeS potable[] = {
  {"abort", s_abort, 0},
  {"align", s_align_ptwo, 0},
  {"altmacro", s_altmacro, 1},
  {"ascii", stringer, 8+0},
  {"asciz", stringer, 8+1},
  {"balign", s_align_bytes, 0},
  {"balignw", s_align_bytes, -2},
  {"balignl", s_align_bytes, -4},
/* block  */
#ifdef HANDLE_BUNDLE
  {"bundle_align_mode", s_bundle_align_mode, 0},
  {"bundle_lock", s_bundle_lock, 0},
  {"bundle_unlock", s_bundle_unlock, 0},
#endif
  {"byte", cons, 1},
  {"comm", s_comm, 0},
  {"common", s_mri_common, 0},
  {"common.s", s_mri_common, 1},
  {"data", s_data, 0},
  {"dc", cons, 2},
#ifdef TC_ADDRESS_BYTES
  {"dc.a", cons, 0},
#endif
  {"dc.b", cons, 1},
  {"dc.d", float_cons, 'd'},
  {"dc.l", cons, 4},
  {"dc.s", float_cons, 'f'},
  {"dc.w", cons, 2},
  {"dc.x", float_cons, 'x'},
  {"dcb", s_space, 2},
  {"dcb.b", s_space, 1},
  {"dcb.d", s_float_space, 'd'},
  {"dcb.l", s_space, 4},
  {"dcb.s", s_float_space, 'f'},
  {"dcb.w", s_space, 2},
  {"dcb.x", s_float_space, 'x'},
  {"ds", s_space, 2},
  {"ds.b", s_space, 1},
  {"ds.d", s_space, 8},
  {"ds.l", s_space, 4},
  {"ds.p", s_space, 12},
  {"ds.s", s_space, 4},
  {"ds.w", s_space, 2},
  {"ds.x", s_space, 12},
  {"debug", s_ignore, 0},
#ifdef S_SET_DESC
  {"desc", s_desc, 0},
#endif
/* dim  */
  {"double", float_cons, 'd'},
/* dsect  */
  {"eject", listing_eject, 0},	/* Formfeed listing.  */
  {"else", s_else, 0},
  {"elsec", s_else, 0},
  {"elseif", s_elseif, (int) O_ne},
  {"end", s_end, 0},
  {"endc", s_endif, 0},
  {"endfunc", s_func, 1},
  {"endif", s_endif, 0},
  {"endm", s_bad_end, 0},
  {"endr", s_bad_end, 1},
/* endef  */
  {"equ", s_set, 0},
  {"equiv", s_set, 1},
  {"eqv", s_set, -1},
  {"err", s_err, 0},
  {"error", s_errwarn, 1},
  {"exitm", s_mexit, 0},
/* extend  */
  {"extern", s_ignore, 0},	/* We treat all undef as ext.  */
  {"appfile", s_app_file, 1},
  {"appline", s_app_line, 1},
  {"fail", s_fail, 0},
  {"file", s_app_file, 0},
  {"fill", s_fill, 0},
  {"float", float_cons, 'f'},
  {"format", s_ignore, 0},
  {"func", s_func, 0},
  {"global", s_globl, 0},
  {"globl", s_globl, 0},
  {"hword", cons, 2},
  {"if", s_if, (int) O_ne},
  {"ifb", s_ifb, 1},
  {"ifc", s_ifc, 0},
  {"ifdef", s_ifdef, 0},
  {"ifeq", s_if, (int) O_eq},
  {"ifeqs", s_ifeqs, 0},
  {"ifge", s_if, (int) O_ge},
  {"ifgt", s_if, (int) O_gt},
  {"ifle", s_if, (int) O_le},
  {"iflt", s_if, (int) O_lt},
  {"ifnb", s_ifb, 0},
  {"ifnc", s_ifc, 1},
  {"ifndef", s_ifdef, 1},
  {"ifne", s_if, (int) O_ne},
  {"ifnes", s_ifeqs, 1},
  {"ifnotdef", s_ifdef, 1},
  {"incbin", s_incbin, 0},
  {"include", s_include, 0},
  {"int", cons, 4},
  {"irp", s_irp, 0},
  {"irep", s_irp, 0},
  {"irpc", s_irp, 1},
  {"irepc", s_irp, 1},
  {"lcomm", s_lcomm, 0},
  {"lflags", s_ignore, 0},	/* Listing flags.  */
  {"linefile", s_app_line, 0},
  {"linkonce", s_linkonce, 0},
  {"list", listing_list, 1},	/* Turn listing on.  */
  {"llen", listing_psize, 1},
  {"long", cons, 4},
  {"lsym", s_lsym, 0},
  {"macro", s_macro, 0},
  {"mexit", s_mexit, 0},
  {"mri", s_mri, 0},
  {".mri", s_mri, 0},	/* Special case so .mri works in MRI mode.  */
  {"name", s_ignore, 0},
  {"noaltmacro", s_altmacro, 0},
  {"noformat", s_ignore, 0},
  {"nolist", listing_list, 0},	/* Turn listing off.  */
  {"nopage", listing_nopage, 0},
  {"octa", cons, 16},
  {"offset", s_struct, 0},
  {"org", s_org, 0},
  {"p2align", s_align_ptwo, 0},
  {"p2alignw", s_align_ptwo, -2},
  {"p2alignl", s_align_ptwo, -4},
  {"page", listing_eject, 0},
  {"plen", listing_psize, 0},
  {"print", s_print, 0},
  {"psize", listing_psize, 0},	/* Set paper size.  */
  {"purgem", s_purgem, 0},
  {"quad", cons, 8},
  {"reloc", s_reloc, 0},
  {"rep", s_rept, 0},
  {"rept", s_rept, 0},
  {"rva", s_rva, 4},
  {"sbttl", listing_title, 1},	/* Subtitle of listing.  */
/* scl  */
/* sect  */
  {"set", s_set, 0},
  {"short", cons, 2},
  {"single", float_cons, 'f'},
/* size  */
  {"space", s_space, 0},
  {"skip", s_space, 0},
  {"sleb128", s_leb128, 1},
  {"spc", s_ignore, 0},
  {"stabd", s_stab, 'd'},
  {"stabn", s_stab, 'n'},
  {"stabs", s_stab, 's'},
  {"string", stringer, 8+1},
  {"string8", stringer, 8+1},
  {"string16", stringer, 16+1},
  {"string32", stringer, 32+1},
  {"string64", stringer, 64+1},
  {"struct", s_struct, 0},
/* tag  */
  {"text", s_text, 0},

  /* This is for gcc to use.  It's only just been added (2/94), so gcc
     won't be able to use it for a while -- probably a year or more.
     But once this has been released, check with gcc maintainers
     before deleting it or even changing the spelling.  */
  {"this_GCC_requires_the_GNU_assembler", s_ignore, 0},
  /* If we're folding case -- done for some targets, not necessarily
     all -- the above string in an input file will be converted to
     this one.  Match it either way...  */
  {"this_gcc_requires_the_gnu_assembler", s_ignore, 0},

  {"title", listing_title, 0},	/* Listing title.  */
  {"ttl", listing_title, 0},
/* type  */
  {"uleb128", s_leb128, 0},
/* use  */
/* val  */
  {"xcom", s_comm, 0},
  {"xdef", s_globl, 0},
  {"xref", s_ignore, 0},
  {"xstabs", s_xstab, 's'},
  {"warning", s_errwarn, 0},
  {"weakref", s_weakref, 0},
  {"word", cons, 2},
  {"zero", s_space, 0},
  {NULL, NULL, 0}			/* End sentinel.  */
};

static offsetT
get_absolute_expr (expressionS *exp)
{
  expression_and_evaluate (exp);
  if (exp->X_op != O_constant)
    {
      if (exp->X_op != O_absent)
	as_bad (_("bad or irreducible absolute expression"));
      exp->X_add_number = 0;
    }
  return exp->X_add_number;
}

offsetT
get_absolute_expression (void)
{
  expressionS exp;

  return get_absolute_expr (&exp);
}

static int pop_override_ok = 0;
static const char *pop_table_name;

void
pop_insert (const pseudo_typeS *table)
{
  const char *errtxt;
  const pseudo_typeS *pop;
  for (pop = table; pop->poc_name; pop++)
    {
      errtxt = hash_insert (po_hash, pop->poc_name, (char *) pop);
      if (errtxt && (!pop_override_ok || strcmp (errtxt, "exists")))
	as_fatal (_("error constructing %s pseudo-op table: %s"), pop_table_name,
		  errtxt);
    }
}

#ifndef md_pop_insert
#define md_pop_insert()		pop_insert(md_pseudo_table)
#endif

#ifndef obj_pop_insert
#define obj_pop_insert()	pop_insert(obj_pseudo_table)
#endif

#ifndef cfi_pop_insert
#define cfi_pop_insert()	pop_insert(cfi_pseudo_table)
#endif

static void
pobegin (void)
{
  po_hash = hash_new ();

  /* Do the target-specific pseudo ops.  */
  pop_table_name = "md";
  md_pop_insert ();

  /* Now object specific.  Skip any that were in the target table.  */
  pop_table_name = "obj";
  pop_override_ok = 1;
  obj_pop_insert ();

  /* Now portable ones.  Skip any that we've seen already.  */
  pop_table_name = "standard";
  pop_insert (potable);

  /* Now CFI ones.  */
  pop_table_name = "cfi";
  pop_override_ok = 1;
  cfi_pop_insert ();
}

#define HANDLE_CONDITIONAL_ASSEMBLY()					\
  if (ignore_input ())							\
    {									\
      char *eol = find_end_of_line (input_line_pointer, flag_m68k_mri); \
      input_line_pointer = (input_line_pointer <= buffer_limit		\
			    && eol >= buffer_limit)			\
			   ? buffer_limit				\
			   : eol + 1;					\
      continue;								\
    }

/* This function is used when scrubbing the characters between #APP
   and #NO_APP.  */

static char *scrub_string;
static char *scrub_string_end;

static size_t
scrub_from_string (char *buf, size_t buflen)
{
  size_t copy;

  copy = scrub_string_end - scrub_string;
  if (copy > buflen)
    copy = buflen;
  memcpy (buf, scrub_string, copy);
  scrub_string += copy;
  return copy;
}

/* Helper function of read_a_source_file, which tries to expand a macro.  */
static int
try_macro (char term, const char *line)
{
  sb out;
  const char *err;
  macro_entry *macro;

  if (check_macro (line, &out, &err, &macro))
    {
      if (err != NULL)
	as_bad ("%s", err);
      *input_line_pointer++ = term;
      input_scrub_include_sb (&out,
			      input_line_pointer, 1);
      sb_kill (&out);
      buffer_limit =
	input_scrub_next_buffer (&input_line_pointer);
#ifdef md_macro_info
      md_macro_info (macro);
#endif
      return 1;
    }
  return 0;
}

#ifdef HANDLE_BUNDLE
/* Start a new instruction bundle.  Returns the rs_align_code frag that
   will be used to align the new bundle.  */
static fragS *
start_bundle (void)
{
  fragS *frag = frag_now;

  frag_align_code (0, 0);

  while (frag->fr_type != rs_align_code)
    frag = frag->fr_next;

  gas_assert (frag != frag_now);

  return frag;
}

/* Calculate the maximum size after relaxation of the region starting
   at the given frag and extending through frag_now (which is unfinished).  */
static unsigned int
pending_bundle_size (fragS *frag)
{
  unsigned int offset = frag->fr_fix;
  unsigned int size = 0;

  gas_assert (frag != frag_now);
  gas_assert (frag->fr_type == rs_align_code);

  while (frag != frag_now)
    {
      /* This should only happen in what will later become an error case.  */
      if (frag == NULL)
	return 0;

      size += frag->fr_fix;
      if (frag->fr_type == rs_machine_dependent)
	size += md_frag_max_var (frag);

      frag = frag->fr_next;
    }

  gas_assert (frag == frag_now);
  size += frag_now_fix ();
  if (frag->fr_type == rs_machine_dependent)
    size += md_frag_max_var (frag);

  gas_assert (size >= offset);

  return size - offset;
}

/* Finish off the frag created to ensure bundle alignment.  */
static void
finish_bundle (fragS *frag, unsigned int size)
{
  gas_assert (bundle_align_p2 > 0);
  gas_assert (frag->fr_type == rs_align_code);

  if (size > 1)
    {
      /* If there is more than a single byte, then we need to set up the
	 alignment frag.  Otherwise we leave it at its initial state from
	 calling frag_align_code (0, 0), so that it does nothing.  */
      frag->fr_offset = bundle_align_p2;
      frag->fr_subtype = size - 1;
    }

  /* We do this every time rather than just in s_bundle_align_mode
     so that we catch any affected section without needing hooks all
     over for all paths that do section changes.  It's cheap enough.  */
  record_alignment (now_seg, bundle_align_p2 - OCTETS_PER_BYTE_POWER);
}

/* Assemble one instruction.  This takes care of the bundle features
   around calling md_assemble.  */
static void
assemble_one (char *line)
{
  fragS *insn_start_frag = NULL;

  if (bundle_lock_frchain != NULL && bundle_lock_frchain != frchain_now)
    {
      as_bad (_("cannot change section or subsection inside .bundle_lock"));
      /* Clearing this serves as a marker that we have already complained.  */
      bundle_lock_frchain = NULL;
    }

  if (bundle_lock_frchain == NULL && bundle_align_p2 > 0)
    insn_start_frag = start_bundle ();

  md_assemble (line);

  if (bundle_lock_frchain != NULL)
    {
      /* Make sure this hasn't pushed the locked sequence
	 past the bundle size.  */
      unsigned int bundle_size = pending_bundle_size (bundle_lock_frag);
      if (bundle_size > (1U << bundle_align_p2))
	as_bad (_("\
.bundle_lock sequence at %u bytes but .bundle_align_mode limit is %u bytes"),
		bundle_size, 1U << bundle_align_p2);
    }
  else if (bundle_align_p2 > 0)
    {
      unsigned int insn_size = pending_bundle_size (insn_start_frag);

      if (insn_size > (1U << bundle_align_p2))
	as_bad (_("\
single instruction is %u bytes long but .bundle_align_mode limit is %u"),
		(unsigned int) insn_size, 1U << bundle_align_p2);

      finish_bundle (insn_start_frag, insn_size);
    }
}

#else  /* !HANDLE_BUNDLE */

# define assemble_one(line) md_assemble(line)

#endif  /* HANDLE_BUNDLE */

/* We read the file, putting things into a web that represents what we
   have been reading.  */
void
read_a_source_file (char *name)
{
  char c;
  char *s;		/* String of symbol, '\0' appended.  */
  int temp;
  pseudo_typeS *pop;

#ifdef WARN_COMMENTS
  found_comment = 0;
#endif

  buffer = input_scrub_new_file (name);

  listing_file (name);
  listing_newline (NULL);
  register_dependency (name);

  /* Generate debugging information before we've read anything in to denote
     this file as the "main" source file and not a subordinate one
     (e.g. N_SO vs N_SOL in stabs).  */
  generate_file_debug ();

  while ((buffer_limit = input_scrub_next_buffer (&input_line_pointer)) != 0)
    {				/* We have another line to parse.  */
#ifndef NO_LISTING
      /* In order to avoid listing macro expansion lines with labels
	 multiple times, keep track of which line was last issued.  */
      static char *last_eol;

      last_eol = NULL;
#endif
      while (input_line_pointer < buffer_limit)
	{
	  bfd_boolean was_new_line;
	  /* We have more of this buffer to parse.  */

	  /* We now have input_line_pointer->1st char of next line.
	     If input_line_pointer [-1] == '\n' then we just
	     scanned another line: so bump line counters.  */
	  was_new_line = is_end_of_line[(unsigned char) input_line_pointer[-1]];
	  if (was_new_line)
	    {
	      symbol_set_value_now (&dot_symbol);
#ifdef md_start_line_hook
	      md_start_line_hook ();
#endif
	      if (input_line_pointer[-1] == '\n')
		bump_line_counters ();
	    }

#ifndef NO_LISTING
	  /* If listing is on, and we are expanding a macro, then give
	     the listing code the contents of the expanded line.  */
	  if (listing)
	    {
	      if ((listing & LISTING_MACEXP) && macro_nest > 0)
		{
		  /* Find the end of the current expanded macro line.  */
		  s = find_end_of_line (input_line_pointer, flag_m68k_mri);

		  if (s != last_eol)
		    {
		      char *copy;
		      int len;

		      last_eol = s;
		      /* Copy it for safe keeping.  Also give an indication of
			 how much macro nesting is involved at this point.  */
		      len = s - input_line_pointer;
		      copy = (char *) xmalloc (len + macro_nest + 2);
		      memset (copy, '>', macro_nest);
		      copy[macro_nest] = ' ';
		      memcpy (copy + macro_nest + 1, input_line_pointer, len);
		      copy[macro_nest + 1 + len] = '\0';

		      /* Install the line with the listing facility.  */
		      listing_newline (copy);
		    }
		}
	      else
		listing_newline (NULL);
	    }
#endif
	  if (was_new_line)
	    {
	      line_label = NULL;

	      if (LABELS_WITHOUT_COLONS || flag_m68k_mri)
		{
		  /* Text at the start of a line must be a label, we
		     run down and stick a colon in.  */
		  if (is_name_beginner (*input_line_pointer))
		    {
		      char *line_start = input_line_pointer;
		      int mri_line_macro;

		      HANDLE_CONDITIONAL_ASSEMBLY ();

		      c = get_symbol_end ();

		      /* In MRI mode, the EQU and MACRO pseudoops must
			 be handled specially.  */
		      mri_line_macro = 0;
		      if (flag_m68k_mri)
			{
			  char *rest = input_line_pointer + 1;

			  if (*rest == ':')
			    ++rest;
			  if (*rest == ' ' || *rest == '\t')
			    ++rest;
			  if ((strncasecmp (rest, "EQU", 3) == 0
			       || strncasecmp (rest, "SET", 3) == 0)
			      && (rest[3] == ' ' || rest[3] == '\t'))
			    {
			      input_line_pointer = rest + 3;
			      equals (line_start,
				      strncasecmp (rest, "SET", 3) == 0);
			      continue;
			    }
			  if (strncasecmp (rest, "MACRO", 5) == 0
			      && (rest[5] == ' '
				  || rest[5] == '\t'
				  || is_end_of_line[(unsigned char) rest[5]]))
			    mri_line_macro = 1;
			}

		      /* In MRI mode, we need to handle the MACRO
			 pseudo-op specially: we don't want to put the
			 symbol in the symbol table.  */
		      if (!mri_line_macro
#ifdef TC_START_LABEL_WITHOUT_COLON
			  && TC_START_LABEL_WITHOUT_COLON(c,
							  input_line_pointer)
#endif
			  )
			line_label = colon (line_start);
		      else
			line_label = symbol_create (line_start,
						    absolute_section,
						    (valueT) 0,
						    &zero_address_frag);

		      *input_line_pointer = c;
		      if (c == ':')
			input_line_pointer++;
		    }
		}
	    }

	  /* We are at the beginning of a line, or similar place.
	     We expect a well-formed assembler statement.
	     A "symbol-name:" is a statement.

	     Depending on what compiler is used, the order of these tests
	     may vary to catch most common case 1st.
	     Each test is independent of all other tests at the (top)
	     level.  */
	  do
	    c = *input_line_pointer++;
	  while (c == '\t' || c == ' ' || c == '\f');

	  /* C is the 1st significant character.
	     Input_line_pointer points after that character.  */
	  if (is_name_beginner (c))
	    {
	      /* Want user-defined label or pseudo/opcode.  */
	      HANDLE_CONDITIONAL_ASSEMBLY ();

	      s = --input_line_pointer;
	      c = get_symbol_end ();	/* name's delimiter.  */

	      /* C is character after symbol.
		 That character's place in the input line is now '\0'.
		 S points to the beginning of the symbol.
		   [In case of pseudo-op, s->'.'.]
		 Input_line_pointer->'\0' where c was.  */
	      if (TC_START_LABEL (c, s, input_line_pointer))
		{
		  if (flag_m68k_mri)
		    {
		      char *rest = input_line_pointer + 1;

		      /* In MRI mode, \tsym: set 0 is permitted.  */
		      if (*rest == ':')
			++rest;

		      if (*rest == ' ' || *rest == '\t')
			++rest;

		      if ((strncasecmp (rest, "EQU", 3) == 0
			   || strncasecmp (rest, "SET", 3) == 0)
			  && (rest[3] == ' ' || rest[3] == '\t'))
			{
			  input_line_pointer = rest + 3;
			  equals (s, 1);
			  continue;
			}
		    }

		  line_label = colon (s);	/* User-defined label.  */
		  /* Put ':' back for error messages' sake.  */
		  *input_line_pointer++ = ':';
#ifdef tc_check_label
		  tc_check_label (line_label);
#endif
		  /* Input_line_pointer->after ':'.  */
		  SKIP_WHITESPACE ();
		}
	      else if ((c == '=' && input_line_pointer[1] == '=')
		       || ((c == ' ' || c == '\t')
			   && input_line_pointer[1] == '='
			   && input_line_pointer[2] == '='))
		{
		  equals (s, -1);
		  demand_empty_rest_of_line ();
		}
	      else if ((c == '='
		       || ((c == ' ' || c == '\t')
			    && input_line_pointer[1] == '='))
#ifdef TC_EQUAL_IN_INSN
			   && !TC_EQUAL_IN_INSN (c, s)
#endif
			   )
		{
		  equals (s, 1);
		  demand_empty_rest_of_line ();
		}
	      else
		{
		  /* Expect pseudo-op or machine instruction.  */
		  pop = NULL;

#ifndef TC_CASE_SENSITIVE
		  {
		    char *s2 = s;

		    strncpy (original_case_string, s2, sizeof (original_case_string));
		    original_case_string[sizeof (original_case_string) - 1] = 0;

		    while (*s2)
		      {
			*s2 = TOLOWER (*s2);
			s2++;
		      }
		  }
#endif
		  if (NO_PSEUDO_DOT || flag_m68k_mri)
		    {
		      /* The MRI assembler uses pseudo-ops without
			 a period.  */
		      pop = (pseudo_typeS *) hash_find (po_hash, s);
		      if (pop != NULL && pop->poc_handler == NULL)
			pop = NULL;
		    }

		  if (pop != NULL
		      || (!flag_m68k_mri && *s == '.'))
		    {
		      /* PSEUDO - OP.

			 WARNING: c has next char, which may be end-of-line.
			 We lookup the pseudo-op table with s+1 because we
			 already know that the pseudo-op begins with a '.'.  */

		      if (pop == NULL)
			pop = (pseudo_typeS *) hash_find (po_hash, s + 1);
		      if (pop && !pop->poc_handler)
			pop = NULL;

		      /* In MRI mode, we may need to insert an
			 automatic alignment directive.  What a hack
			 this is.  */
		      if (mri_pending_align
			  && (pop == NULL
			      || !((pop->poc_handler == cons
				    && pop->poc_val == 1)
				   || (pop->poc_handler == s_space
				       && pop->poc_val == 1)
#ifdef tc_conditional_pseudoop
				   || tc_conditional_pseudoop (pop)
#endif
				   || pop->poc_handler == s_if
				   || pop->poc_handler == s_ifdef
				   || pop->poc_handler == s_ifc
				   || pop->poc_handler == s_ifeqs
				   || pop->poc_handler == s_else
				   || pop->poc_handler == s_endif
				   || pop->poc_handler == s_globl
				   || pop->poc_handler == s_ignore)))
			{
			  do_align (1, (char *) NULL, 0, 0);
			  mri_pending_align = 0;

			  if (line_label != NULL)
			    {
			      symbol_set_frag (line_label, frag_now);
			      S_SET_VALUE (line_label, frag_now_fix ());
			    }
			}

		      /* Print the error msg now, while we still can.  */
		      if (pop == NULL)
			{
			  char *end = input_line_pointer;

			  *input_line_pointer = c;
			  s_ignore (0);
			  c = *--input_line_pointer;
			  *input_line_pointer = '\0';
			  if (! macro_defined || ! try_macro (c, s))
			    {
			      *end = '\0';
			      as_bad (_("unknown pseudo-op: `%s'"), s);
			      *input_line_pointer++ = c;
			    }
			  continue;
			}

		      /* Put it back for error messages etc.  */
		      *input_line_pointer = c;
		      /* The following skip of whitespace is compulsory.
			 A well shaped space is sometimes all that separates
			 keyword from operands.  */
		      if (c == ' ' || c == '\t')
			input_line_pointer++;

		      /* Input_line is restored.
			 Input_line_pointer->1st non-blank char
			 after pseudo-operation.  */
		      (*pop->poc_handler) (pop->poc_val);

		      /* If that was .end, just get out now.  */
		      if (pop->poc_handler == s_end)
			goto quit;
		    }
		  else
		    {
		      /* WARNING: c has char, which may be end-of-line.  */
		      /* Also: input_line_pointer->`\0` where c was.  */
		      *input_line_pointer = c;
		      input_line_pointer = _find_end_of_line (input_line_pointer, flag_m68k_mri, 1, 0);
		      c = *input_line_pointer;
		      *input_line_pointer = '\0';

		      generate_lineno_debug ();

		      if (macro_defined && try_macro (c, s))
			continue;

		      if (mri_pending_align)
			{
			  do_align (1, (char *) NULL, 0, 0);
			  mri_pending_align = 0;
			  if (line_label != NULL)
			    {
			      symbol_set_frag (line_label, frag_now);
			      S_SET_VALUE (line_label, frag_now_fix ());
			    }
			}

		      assemble_one (s); /* Assemble 1 instruction.  */

		      *input_line_pointer++ = c;

		      /* We resume loop AFTER the end-of-line from
			 this instruction.  */
		    }
		}
	      continue;
	    }

	  /* Empty statement?  */
	  if (is_end_of_line[(unsigned char) c])
	    continue;

	  if ((LOCAL_LABELS_DOLLAR || LOCAL_LABELS_FB) && ISDIGIT (c))
	    {
	      /* local label  ("4:")  */
	      char *backup = input_line_pointer;

	      HANDLE_CONDITIONAL_ASSEMBLY ();

	      temp = c - '0';

	      /* Read the whole number.  */
	      while (ISDIGIT (*input_line_pointer))
		{
		  temp = (temp * 10) + *input_line_pointer - '0';
		  ++input_line_pointer;
		}

	      if (LOCAL_LABELS_DOLLAR
		  && *input_line_pointer == '$'
		  && *(input_line_pointer + 1) == ':')
		{
		  input_line_pointer += 2;

		  if (dollar_label_defined (temp))
		    {
		      as_fatal (_("label \"%d$\" redefined"), temp);
		    }

		  define_dollar_label (temp);
		  colon (dollar_label_name (temp, 0));
		  continue;
		}

	      if (LOCAL_LABELS_FB
		  && *input_line_pointer++ == ':')
		{
		  fb_label_instance_inc (temp);
		  colon (fb_label_name (temp, 0));
		  continue;
		}

	      input_line_pointer = backup;
	    }			/* local label  ("4:") */

	  if (c && strchr (line_comment_chars, c))
	    {			/* Its a comment.  Better say APP or NO_APP.  */
	      sb sbuf;
	      char *ends;
	      char *new_buf;
	      char *new_tmp;
	      unsigned int new_length;
	      char *tmp_buf = 0;

	      s = input_line_pointer;
	      if (strncmp (s, "APP\n", 4))
		{
		  /* We ignore it.  */
		  ignore_rest_of_line ();
		  continue;
		}
	      bump_line_counters ();
	      s += 4;

	      ends = strstr (s, "#NO_APP\n");

	      if (!ends)
		{
		  unsigned int tmp_len;
		  unsigned int num;

		  /* The end of the #APP wasn't in this buffer.  We
		     keep reading in buffers until we find the #NO_APP
		     that goes with this #APP  There is one.  The specs
		     guarantee it...  */
		  tmp_len = buffer_limit - s;
		  tmp_buf = (char *) xmalloc (tmp_len + 1);
		  memcpy (tmp_buf, s, tmp_len);
		  do
		    {
		      new_tmp = input_scrub_next_buffer (&buffer);
		      if (!new_tmp)
			break;
		      else
			buffer_limit = new_tmp;
		      input_line_pointer = buffer;
		      ends = strstr (buffer, "#NO_APP\n");
		      if (ends)
			num = ends - buffer;
		      else
			num = buffer_limit - buffer;

		      tmp_buf = (char *) xrealloc (tmp_buf, tmp_len + num);
		      memcpy (tmp_buf + tmp_len, buffer, num);
		      tmp_len += num;
		    }
		  while (!ends);

		  input_line_pointer = ends ? ends + 8 : NULL;

		  s = tmp_buf;
		  ends = s + tmp_len;

		}
	      else
		{
		  input_line_pointer = ends + 8;
		}

	      scrub_string = s;
	      scrub_string_end = ends;

	      new_length = ends - s;
	      new_buf = (char *) xmalloc (new_length);
	      new_tmp = new_buf;
	      for (;;)
		{
		  size_t space;
		  size_t size;

		  space = (new_buf + new_length) - new_tmp;
		  size = do_scrub_chars (scrub_from_string, new_tmp, space);

		  if (size < space)
		    {
		      new_tmp[size] = 0;
		      break;
		    }

		  new_buf = (char *) xrealloc (new_buf, new_length + 100);
		  new_tmp = new_buf + new_length;
		  new_length += 100;
		}

	      if (tmp_buf)
		free (tmp_buf);

	      /* We've "scrubbed" input to the preferred format.  In the
		 process we may have consumed the whole of the remaining
		 file (and included files).  We handle this formatted
		 input similar to that of macro expansion, letting
		 actual macro expansion (possibly nested) and other
		 input expansion work.  Beware that in messages, line
		 numbers and possibly file names will be incorrect.  */
	      new_length = strlen (new_buf);
	      sb_build (&sbuf, new_length);
	      sb_add_buffer (&sbuf, new_buf, new_length);
	      input_scrub_include_sb (&sbuf, input_line_pointer, 0);
	      sb_kill (&sbuf);
	      buffer_limit = input_scrub_next_buffer (&input_line_pointer);
	      free (new_buf);
	      continue;
	    }

	  HANDLE_CONDITIONAL_ASSEMBLY ();

#ifdef tc_unrecognized_line
	  if (tc_unrecognized_line (c))
	    continue;
#endif
	  input_line_pointer--;
	  /* Report unknown char as error.  */
	  demand_empty_rest_of_line ();
	}
    }

 quit:
  symbol_set_value_now (&dot_symbol);

#ifdef HANDLE_BUNDLE
  if (bundle_lock_frag != NULL)
    {
      as_bad_where (bundle_lock_frag->fr_file, bundle_lock_frag->fr_line,
		    _(".bundle_lock with no matching .bundle_unlock"));
      bundle_lock_frag = NULL;
      bundle_lock_frchain = NULL;
      bundle_lock_depth = 0;
    }
#endif

#ifdef md_cleanup
  md_cleanup ();
#endif
  /* Close the input file.  */
  input_scrub_close ();
#ifdef WARN_COMMENTS
  {
    if (warn_comment && found_comment)
      as_warn_where (found_comment_file, found_comment,
		     "first comment found here");
  }
#endif
}

/* Convert O_constant expression EXP into the equivalent O_big representation.
   Take the sign of the number from SIGN rather than X_add_number.  */

static void
convert_to_bignum (expressionS *exp, int sign)
{
  valueT value;
  unsigned int i;

  value = exp->X_add_number;
  for (i = 0; i < sizeof (exp->X_add_number) / CHARS_PER_LITTLENUM; i++)
    {
      generic_bignum[i] = value & LITTLENUM_MASK;
      value >>= LITTLENUM_NUMBER_OF_BITS;
    }
  /* Add a sequence of sign bits if the top bit of X_add_number is not
     the sign of the original value.  */
  if ((exp->X_add_number < 0) == !sign)
    generic_bignum[i++] = sign ? LITTLENUM_MASK : 0;
  exp->X_op = O_big;
  exp->X_add_number = i;
}

/* For most MRI pseudo-ops, the line actually ends at the first
   nonquoted space.  This function looks for that point, stuffs a null
   in, and sets *STOPCP to the character that used to be there, and
   returns the location.

   Until I hear otherwise, I am going to assume that this is only true
   for the m68k MRI assembler.  */

char *
mri_comment_field (char *stopcp)
{
  char *s;
#ifdef TC_M68K
  int inquote = 0;

  know (flag_m68k_mri);

  for (s = input_line_pointer;
       ((!is_end_of_line[(unsigned char) *s] && *s != ' ' && *s != '\t')
	|| inquote);
       s++)
    {
      if (*s == '\'')
	inquote = !inquote;
    }
#else
  for (s = input_line_pointer;
       !is_end_of_line[(unsigned char) *s];
       s++)
    ;
#endif
  *stopcp = *s;
  *s = '\0';

  return s;
}

/* Skip to the end of an MRI comment field.  */

void
mri_comment_end (char *stop, int stopc)
{
  know (flag_mri);

  input_line_pointer = stop;
  *stop = stopc;
  while (!is_end_of_line[(unsigned char) *input_line_pointer])
    ++input_line_pointer;
}

void
s_abort (int ignore ATTRIBUTE_UNUSED)
{
  as_fatal (_(".abort detected.  Abandoning ship."));
}

/* Guts of .align directive.  N is the power of two to which to align.
   FILL may be NULL, or it may point to the bytes of the fill pattern.
   LEN is the length of whatever FILL points to, if anything.  MAX is
   the maximum number of characters to skip when doing the alignment,
   or 0 if there is no maximum.  */

static void
do_align (int n, char *fill, int len, int max)
{
  if (now_seg == absolute_section)
    {
      if (fill != NULL)
	while (len-- > 0)
	  if (*fill++ != '\0')
	    {
	      as_warn (_("ignoring fill value in absolute section"));
	      break;
	    }
      fill = NULL;
      len = 0;
    }

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif
#ifdef md_do_align
  md_do_align (n, fill, len, max, just_record_alignment);
#endif

  /* Only make a frag if we HAVE to...  */
  if (n != 0 && !need_pass_2)
    {
      if (fill == NULL)
	{
	  if (subseg_text_p (now_seg))
	    frag_align_code (n, max);
	  else
	    frag_align (n, 0, max);
	}
      else if (len <= 1)
	frag_align (n, *fill, max);
      else
	frag_align_pattern (n, fill, len, max);
    }

#ifdef md_do_align
 just_record_alignment: ATTRIBUTE_UNUSED_LABEL
#endif

  record_alignment (now_seg, n - OCTETS_PER_BYTE_POWER);
}

/* Handle the .align pseudo-op.  A positive ARG is a default alignment
   (in bytes).  A negative ARG is the negative of the length of the
   fill pattern.  BYTES_P is non-zero if the alignment value should be
   interpreted as the byte boundary, rather than the power of 2.  */
#ifndef TC_ALIGN_LIMIT
#define TC_ALIGN_LIMIT (stdoutput->arch_info->bits_per_address - 1)
#endif

static void
s_align (int arg, int bytes_p)
{
  unsigned int align_limit = TC_ALIGN_LIMIT;
  unsigned int align;
  char *stop = NULL;
  char stopc = 0;
  offsetT fill = 0;
  int max;
  int fill_p;

  if (flag_mri)
    stop = mri_comment_field (&stopc);

  if (is_end_of_line[(unsigned char) *input_line_pointer])
    {
      if (arg < 0)
	align = 0;
      else
	align = arg;	/* Default value from pseudo-op table.  */
    }
  else
    {
      align = get_absolute_expression ();
      SKIP_WHITESPACE ();
    }

  if (bytes_p)
    {
      /* Convert to a power of 2.  */
      if (align != 0)
	{
	  unsigned int i;

	  for (i = 0; (align & 1) == 0; align >>= 1, ++i)
	    ;
	  if (align != 1)
	    as_bad (_("alignment not a power of 2"));

	  align = i;
	}
    }

  if (align > align_limit)
    {
      align = align_limit;
      as_warn (_("alignment too large: %u assumed"), align);
    }

  if (*input_line_pointer != ',')
    {
      fill_p = 0;
      max = 0;
    }
  else
    {
      ++input_line_pointer;
      if (*input_line_pointer == ',')
	fill_p = 0;
      else
	{
	  fill = get_absolute_expression ();
	  SKIP_WHITESPACE ();
	  fill_p = 1;
	}

      if (*input_line_pointer != ',')
	max = 0;
      else
	{
	  ++input_line_pointer;
	  max = get_absolute_expression ();
	}
    }

  if (!fill_p)
    {
      if (arg < 0)
	as_warn (_("expected fill pattern missing"));
      do_align (align, (char *) NULL, 0, max);
    }
  else
    {
      int fill_len;

      if (arg >= 0)
	fill_len = 1;
      else
	fill_len = -arg;
      if (fill_len <= 1)
	{
	  char fill_char;

	  fill_char = fill;
	  do_align (align, &fill_char, fill_len, max);
	}
      else
	{
	  char ab[16];

	  if ((size_t) fill_len > sizeof ab)
	    abort ();
	  md_number_to_chars (ab, fill, fill_len);
	  do_align (align, ab, fill_len, max);
	}
    }

  demand_empty_rest_of_line ();

  if (flag_mri)
    mri_comment_end (stop, stopc);
}

/* Handle the .align pseudo-op on machines where ".align 4" means
   align to a 4 byte boundary.  */

void
s_align_bytes (int arg)
{
  s_align (arg, 1);
}

/* Handle the .align pseudo-op on machines where ".align 4" means align
   to a 2**4 boundary.  */

void
s_align_ptwo (int arg)
{
  s_align (arg, 0);
}

/* Switch in and out of alternate macro mode.  */

void
s_altmacro (int on)
{
  demand_empty_rest_of_line ();
  macro_set_alternate (on);
}

/* Read a symbol name from input_line_pointer.

   Stores the symbol name in a buffer and returns a pointer to this buffer.
   The buffer is xalloc'ed.  It is the caller's responsibility to free
   this buffer.

   The name is not left in the i_l_p buffer as it may need processing
   to handle escape characters.

   Advances i_l_p to the next non-whitespace character.

   If a symbol name could not be read, the routine issues an error
   messages, skips to the end of the line and returns NULL.  */

static char *
read_symbol_name (void)
{
  char * name;
  char * start;
  char c;

  c = *input_line_pointer++;

  if (c == '"')
    {
#define SYM_NAME_CHUNK_LEN 128
      ptrdiff_t len = SYM_NAME_CHUNK_LEN;
      char * name_end;
      unsigned int C;

      start = name = xmalloc (len + 1);

      name_end = name + SYM_NAME_CHUNK_LEN;

      while (is_a_char (C = next_char_of_string ()))
	{
	  if (name >= name_end)
	    {
	      ptrdiff_t sofar;

	      sofar = name - start;
	      len += SYM_NAME_CHUNK_LEN;
	      start = xrealloc (start, len + 1);
	      name_end = start + len;
	      name = start + sofar;
	    }

	  *name++ = (char) C;
	}
      *name = 0;

      /* Since quoted symbol names can contain non-ASCII characters,
	 check the string and warn if it cannot be recognised by the
	 current character set.  */
      if (mbstowcs (NULL, name, len) == (size_t) -1)
	as_warn (_("symbol name not recognised in the current locale"));
    }
  else if (is_name_beginner (c) || c == '\001')
    {
      ptrdiff_t len;

      name = input_line_pointer - 1;

      /* We accept \001 in a name in case this is
	 being called with a constructed string.  */
      while (is_part_of_name (c = *input_line_pointer++)
	     || c == '\001')
	;

      len = (input_line_pointer - name) - 1;
      start = xmalloc (len + 1);

      memcpy (start, name, len);
      start[len] = 0;

      /* Skip a name ender char if one is present.  */
      if (! is_name_ender (c))
	--input_line_pointer;
    }
  else
    name = start = NULL;

  if (name == start)
    {
      as_bad (_("expected symbol name"));
      ignore_rest_of_line ();
      return NULL;
    }

  SKIP_WHITESPACE ();

  return start;
}


symbolS *
s_comm_internal (int param,
		 symbolS *(*comm_parse_extra) (int, symbolS *, addressT))
{
  char *name;
  offsetT temp, size;
  symbolS *symbolP = NULL;
  char *stop = NULL;
  char stopc = 0;
  expressionS exp;

  if (flag_mri)
    stop = mri_comment_field (&stopc);

  if ((name = read_symbol_name ()) == NULL)
    goto out;

  /* Accept an optional comma after the name.  The comma used to be
     required, but Irix 5 cc does not generate it for .lcomm.  */
  if (*input_line_pointer == ',')
    input_line_pointer++;

  temp = get_absolute_expr (&exp);
  size = temp;
  size &= ((offsetT) 2 << (stdoutput->arch_info->bits_per_address - 1)) - 1;
  if (exp.X_op == O_absent)
    {
      as_bad (_("missing size expression"));
      ignore_rest_of_line ();
      goto out;
    }
  else if (temp != size || !exp.X_unsigned)
    {
      as_warn (_("size (%ld) out of range, ignored"), (long) temp);
      ignore_rest_of_line ();
      goto out;
    }

  symbolP = symbol_find_or_make (name);
  if ((S_IS_DEFINED (symbolP) || symbol_equated_p (symbolP))
      && !S_IS_COMMON (symbolP))
    {
      if (!S_IS_VOLATILE (symbolP))
	{
	  symbolP = NULL;
	  as_bad (_("symbol `%s' is already defined"), name);
	  ignore_rest_of_line ();
	  goto out;
	}
      symbolP = symbol_clone (symbolP, 1);
      S_SET_SEGMENT (symbolP, undefined_section);
      S_SET_VALUE (symbolP, 0);
      symbol_set_frag (symbolP, &zero_address_frag);
      S_CLEAR_VOLATILE (symbolP);
    }

  size = S_GET_VALUE (symbolP);
  if (size == 0)
    size = temp;
  else if (size != temp)
    as_warn (_("size of \"%s\" is already %ld; not changing to %ld"),
	     name, (long) size, (long) temp);

  if (comm_parse_extra != NULL)
    symbolP = (*comm_parse_extra) (param, symbolP, size);
  else
    {
      S_SET_VALUE (symbolP, (valueT) size);
      S_SET_EXTERNAL (symbolP);
      S_SET_SEGMENT (symbolP, bfd_com_section_ptr);
    }

  demand_empty_rest_of_line ();
 out:
  if (flag_mri)
    mri_comment_end (stop, stopc);
  if (name != NULL)
    free (name);
  return symbolP;
}

void
s_comm (int ignore)
{
  s_comm_internal (ignore, NULL);
}

/* The MRI COMMON pseudo-op.  We handle this by creating a common
   symbol with the appropriate name.  We make s_space do the right
   thing by increasing the size.  */

void
s_mri_common (int small ATTRIBUTE_UNUSED)
{
  char *name;
  char c;
  char *alc = NULL;
  symbolS *sym;
  offsetT align;
  char *stop = NULL;
  char stopc = 0;

  if (!flag_mri)
    {
      s_comm (0);
      return;
    }

  stop = mri_comment_field (&stopc);

  SKIP_WHITESPACE ();

  name = input_line_pointer;
  if (!ISDIGIT (*name))
    c = get_symbol_end ();
  else
    {
      do
	{
	  ++input_line_pointer;
	}
      while (ISDIGIT (*input_line_pointer));

      c = *input_line_pointer;
      *input_line_pointer = '\0';

      if (line_label != NULL)
	{
	  alc = (char *) xmalloc (strlen (S_GET_NAME (line_label))
				  + (input_line_pointer - name)
				  + 1);
	  sprintf (alc, "%s%s", name, S_GET_NAME (line_label));
	  name = alc;
	}
    }

  sym = symbol_find_or_make (name);
  *input_line_pointer = c;
  if (alc != NULL)
    free (alc);

  if (*input_line_pointer != ',')
    align = 0;
  else
    {
      ++input_line_pointer;
      align = get_absolute_expression ();
    }

  if (S_IS_DEFINED (sym) && !S_IS_COMMON (sym))
    {
      as_bad (_("symbol `%s' is already defined"), S_GET_NAME (sym));
      ignore_rest_of_line ();
      mri_comment_end (stop, stopc);
      return;
    }

  S_SET_EXTERNAL (sym);
  S_SET_SEGMENT (sym, bfd_com_section_ptr);
  mri_common_symbol = sym;

#ifdef S_SET_ALIGN
  if (align != 0)
    S_SET_ALIGN (sym, align);
#else
  (void) align;
#endif

  if (line_label != NULL)
    {
      expressionS exp;
      exp.X_op = O_symbol;
      exp.X_add_symbol = sym;
      exp.X_add_number = 0;
      symbol_set_value_expression (line_label, &exp);
      symbol_set_frag (line_label, &zero_address_frag);
      S_SET_SEGMENT (line_label, expr_section);
    }

  /* FIXME: We just ignore the small argument, which distinguishes
     COMMON and COMMON.S.  I don't know what we can do about it.  */

  /* Ignore the type and hptype.  */
  if (*input_line_pointer == ',')
    input_line_pointer += 2;
  if (*input_line_pointer == ',')
    input_line_pointer += 2;

  demand_empty_rest_of_line ();

  mri_comment_end (stop, stopc);
}

void
s_data (int ignore ATTRIBUTE_UNUSED)
{
  segT section;
  int temp;

  temp = get_absolute_expression ();
  if (flag_readonly_data_in_text)
    {
      section = text_section;
      temp += 1000;
    }
  else
    section = data_section;

  subseg_set (section, (subsegT) temp);

  demand_empty_rest_of_line ();
}

/* Handle the .appfile pseudo-op.  This is automatically generated by
   do_scrub_chars when a preprocessor # line comment is seen with a
   file name.  This default definition may be overridden by the object
   or CPU specific pseudo-ops.  This function is also the default
   definition for .file; the APPFILE argument is 1 for .appfile, 0 for
   .file.  */

void
s_app_file_string (char *file, int appfile ATTRIBUTE_UNUSED)
{
#ifdef LISTING
  if (listing)
    listing_source_file (file);
#endif
  register_dependency (file);
#ifdef obj_app_file
  obj_app_file (file, appfile);
#endif
}

void
s_app_file (int appfile)
{
  char *s;
  int length;

  /* Some assemblers tolerate immediately following '"'.  */
  if ((s = demand_copy_string (&length)) != 0)
    {
      int may_omit
	= (!new_logical_line_flags (s, -1, 1) && appfile);

      /* In MRI mode, the preprocessor may have inserted an extraneous
	 backquote.  */
      if (flag_m68k_mri
	  && *input_line_pointer == '\''
	  && is_end_of_line[(unsigned char) input_line_pointer[1]])
	++input_line_pointer;

      demand_empty_rest_of_line ();
      if (!may_omit)
	s_app_file_string (s, appfile);
    }
}

static int
get_linefile_number (int *flag)
{
  SKIP_WHITESPACE ();

  if (*input_line_pointer < '0' || *input_line_pointer > '9')
    return 0;

  *flag = get_absolute_expression ();

  return 1;
}

/* Handle the .appline pseudo-op.  This is automatically generated by
   do_scrub_chars when a preprocessor # line comment is seen.  This
   default definition may be overridden by the object or CPU specific
   pseudo-ops.  */

void
s_app_line (int appline)
{
  char *file = NULL;
  int l;

  /* The given number is that of the next line.  */
  if (appline)
    l = get_absolute_expression ();
  else if (!get_linefile_number (&l))
    {
      ignore_rest_of_line ();
      return;
    }

  l--;

  if (l < -1)
    /* Some of the back ends can't deal with non-positive line numbers.
       Besides, it's silly.  GCC however will generate a line number of
       zero when it is pre-processing builtins for assembler-with-cpp files:

	  # 0 "<built-in>"

       We do not want to barf on this, especially since such files are used
       in the GCC and GDB testsuites.  So we check for negative line numbers
       rather than non-positive line numbers.  */
    as_warn (_("line numbers must be positive; line number %d rejected"),
	     l + 1);
  else
    {
      int flags = 0;
      int length = 0;

      if (!appline)
	{
	  SKIP_WHITESPACE ();

	  if (*input_line_pointer == '"')
	    file = demand_copy_string (&length);

	  if (file)
	    {
	      int this_flag;

	      while (get_linefile_number (&this_flag))
		switch (this_flag)
		  {
		    /* From GCC's cpp documentation:
		       1: start of a new file.
		       2: returning to a file after having included
			  another file.
		       3: following text comes from a system header file.
		       4: following text should be treated as extern "C".

		       4 is nonsensical for the assembler; 3, we don't
		       care about, so we ignore it just in case a
		       system header file is included while
		       preprocessing assembly.  So 1 and 2 are all we
		       care about, and they are mutually incompatible.
		       new_logical_line_flags() demands this.  */
		  case 1:
		  case 2:
		    if (flags && flags != (1 << this_flag))
		      as_warn (_("incompatible flag %i in line directive"),
			       this_flag);
		    else
		      flags |= 1 << this_flag;
		    break;

		  case 3:
		  case 4:
		    /* We ignore these.  */
		    break;

		  default:
		    as_warn (_("unsupported flag %i in line directive"),
			     this_flag);
		    break;
		  }

	      if (!is_end_of_line[(unsigned char)*input_line_pointer])
		file = 0;
	    }
	}

      if (appline || file)
	{
	  new_logical_line_flags (file, l, flags);
#ifdef LISTING
	  if (listing)
	    listing_source_line (l);
#endif
	}
    }
  if (appline || file)
    demand_empty_rest_of_line ();
  else
    ignore_rest_of_line ();
}

/* Handle the .end pseudo-op.  Actually, the real work is done in
   read_a_source_file.  */

void
s_end (int ignore ATTRIBUTE_UNUSED)
{
  if (flag_mri)
    {
      /* The MRI assembler permits the start symbol to follow .end,
	 but we don't support that.  */
      SKIP_WHITESPACE ();
      if (!is_end_of_line[(unsigned char) *input_line_pointer]
	  && *input_line_pointer != '*'
	  && *input_line_pointer != '!')
	as_warn (_("start address not supported"));
    }
}

/* Handle the .err pseudo-op.  */

void
s_err (int ignore ATTRIBUTE_UNUSED)
{
  as_bad (_(".err encountered"));
  demand_empty_rest_of_line ();
}

/* Handle the .error and .warning pseudo-ops.  */

void
s_errwarn (int err)
{
  int len;
  /* The purpose for the conditional assignment is not to
     internationalize the directive itself, but that we need a
     self-contained message, one that can be passed like the
     demand_copy_C_string return value, and with no assumption on the
     location of the name of the directive within the message.  */
  char *msg
    = (err ? _(".error directive invoked in source file")
       : _(".warning directive invoked in source file"));

  if (!is_it_end_of_statement ())
    {
      if (*input_line_pointer != '\"')
	{
	  as_bad (_("%s argument must be a string"),
		  err ? ".error" : ".warning");
	  ignore_rest_of_line ();
	  return;
	}

      msg = demand_copy_C_string (&len);
      if (msg == NULL)
	return;
    }

  if (err)
    as_bad ("%s", msg);
  else
    as_warn ("%s", msg);
  demand_empty_rest_of_line ();
}

/* Handle the MRI fail pseudo-op.  */

void
s_fail (int ignore ATTRIBUTE_UNUSED)
{
  offsetT temp;
  char *stop = NULL;
  char stopc = 0;

  if (flag_mri)
    stop = mri_comment_field (&stopc);

  temp = get_absolute_expression ();
  if (temp >= 500)
    as_warn (_(".fail %ld encountered"), (long) temp);
  else
    as_bad (_(".fail %ld encountered"), (long) temp);

  demand_empty_rest_of_line ();

  if (flag_mri)
    mri_comment_end (stop, stopc);
}

void
s_fill (int ignore ATTRIBUTE_UNUSED)
{
  expressionS rep_exp;
  long size = 1;
  long fill = 0;
  char *p;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

#ifdef md_cons_align
  md_cons_align (1);
#endif

  get_known_segmented_expression (&rep_exp);
  if (*input_line_pointer == ',')
    {
      input_line_pointer++;
      size = get_absolute_expression ();
      if (*input_line_pointer == ',')
	{
	  input_line_pointer++;
	  fill = get_absolute_expression ();
	}
    }

  /* This is to be compatible with BSD 4.2 AS, not for any rational reason.  */
#define BSD_FILL_SIZE_CROCK_8 (8)
  if (size > BSD_FILL_SIZE_CROCK_8)
    {
      as_warn (_(".fill size clamped to %d"), BSD_FILL_SIZE_CROCK_8);
      size = BSD_FILL_SIZE_CROCK_8;
    }
  if (size < 0)
    {
      as_warn (_("size negative; .fill ignored"));
      size = 0;
    }
  else if (rep_exp.X_op == O_constant && rep_exp.X_add_number <= 0)
    {
      if (rep_exp.X_add_number < 0)
	as_warn (_("repeat < 0; .fill ignored"));
      size = 0;
    }

  if (size && !need_pass_2)
    {
      if (rep_exp.X_op == O_constant)
	{
	  p = frag_var (rs_fill, (int) size, (int) size,
			(relax_substateT) 0, (symbolS *) 0,
			(offsetT) rep_exp.X_add_number,
			(char *) 0);
	}
      else
	{
	  /* We don't have a constant repeat count, so we can't use
	     rs_fill.  We can get the same results out of rs_space,
	     but its argument is in bytes, so we must multiply the
	     repeat count by size.  */

	  symbolS *rep_sym;
	  rep_sym = make_expr_symbol (&rep_exp);
	  if (size != 1)
	    {
	      expressionS size_exp;
	      size_exp.X_op = O_constant;
	      size_exp.X_add_number = size;

	      rep_exp.X_op = O_multiply;
	      rep_exp.X_add_symbol = rep_sym;
	      rep_exp.X_op_symbol = make_expr_symbol (&size_exp);
	      rep_exp.X_add_number = 0;
	      rep_sym = make_expr_symbol (&rep_exp);
	    }

	  p = frag_var (rs_space, (int) size, (int) size,
			(relax_substateT) 0, rep_sym, (offsetT) 0, (char *) 0);
	}

      memset (p, 0, (unsigned int) size);

      /* The magic number BSD_FILL_SIZE_CROCK_4 is from BSD 4.2 VAX
	 flavoured AS.  The following bizarre behaviour is to be
	 compatible with above.  I guess they tried to take up to 8
	 bytes from a 4-byte expression and they forgot to sign
	 extend.  */
#define BSD_FILL_SIZE_CROCK_4 (4)
      md_number_to_chars (p, (valueT) fill,
			  (size > BSD_FILL_SIZE_CROCK_4
			   ? BSD_FILL_SIZE_CROCK_4
			   : (int) size));
      /* Note: .fill (),0 emits no frag (since we are asked to .fill 0 bytes)
	 but emits no error message because it seems a legal thing to do.
	 It is a degenerate case of .fill but could be emitted by a
	 compiler.  */
    }
  demand_empty_rest_of_line ();
}

void
s_globl (int ignore ATTRIBUTE_UNUSED)
{
  char *name;
  int c;
  symbolS *symbolP;
  char *stop = NULL;
  char stopc = 0;

  if (flag_mri)
    stop = mri_comment_field (&stopc);

  do
    {
      if ((name = read_symbol_name ()) == NULL)
	return;

      symbolP = symbol_find_or_make (name);
      S_SET_EXTERNAL (symbolP);

      SKIP_WHITESPACE ();
      c = *input_line_pointer;
      if (c == ',')
	{
	  input_line_pointer++;
	  SKIP_WHITESPACE ();
	  if (is_end_of_line[(unsigned char) *input_line_pointer])
	    c = '\n';
	}

      free (name);
    }
  while (c == ',');

  demand_empty_rest_of_line ();

  if (flag_mri)
    mri_comment_end (stop, stopc);
}

/* Handle the MRI IRP and IRPC pseudo-ops.  */

void
s_irp (int irpc)
{
  char *file, *eol;
  unsigned int line;
  sb s;
  const char *err;
  sb out;

  as_where (&file, &line);

  eol = find_end_of_line (input_line_pointer, 0);
  sb_build (&s, eol - input_line_pointer);
  sb_add_buffer (&s, input_line_pointer, eol - input_line_pointer);
  input_line_pointer = eol;

  sb_new (&out);

  err = expand_irp (irpc, 0, &s, &out, get_non_macro_line_sb);
  if (err != NULL)
    as_bad_where (file, line, "%s", err);

  sb_kill (&s);

  input_scrub_include_sb (&out, input_line_pointer, 1);
  sb_kill (&out);
  buffer_limit = input_scrub_next_buffer (&input_line_pointer);
}

/* Handle the .linkonce pseudo-op.  This tells the assembler to mark
   the section to only be linked once.  However, this is not supported
   by most object file formats.  This takes an optional argument,
   which is what to do about duplicates.  */

void
s_linkonce (int ignore ATTRIBUTE_UNUSED)
{
  enum linkonce_type type;

  SKIP_WHITESPACE ();

  type = LINKONCE_DISCARD;

  if (!is_end_of_line[(unsigned char) *input_line_pointer])
    {
      char *s;
      char c;

      s = input_line_pointer;
      c = get_symbol_end ();
      if (strcasecmp (s, "discard") == 0)
	type = LINKONCE_DISCARD;
      else if (strcasecmp (s, "one_only") == 0)
	type = LINKONCE_ONE_ONLY;
      else if (strcasecmp (s, "same_size") == 0)
	type = LINKONCE_SAME_SIZE;
      else if (strcasecmp (s, "same_contents") == 0)
	type = LINKONCE_SAME_CONTENTS;
      else
	as_warn (_("unrecognized .linkonce type `%s'"), s);

      *input_line_pointer = c;
    }

#ifdef obj_handle_link_once
  obj_handle_link_once (type);
#else /* ! defined (obj_handle_link_once) */
  {
    flagword flags;

    if ((bfd_applicable_section_flags (stdoutput) & SEC_LINK_ONCE) == 0)
      as_warn (_(".linkonce is not supported for this object file format"));

    flags = bfd_get_section_flags (stdoutput, now_seg);
    flags |= SEC_LINK_ONCE;
    switch (type)
      {
      default:
	abort ();
      case LINKONCE_DISCARD:
	flags |= SEC_LINK_DUPLICATES_DISCARD;
	break;
      case LINKONCE_ONE_ONLY:
	flags |= SEC_LINK_DUPLICATES_ONE_ONLY;
	break;
      case LINKONCE_SAME_SIZE:
	flags |= SEC_LINK_DUPLICATES_SAME_SIZE;
	break;
      case LINKONCE_SAME_CONTENTS:
	flags |= SEC_LINK_DUPLICATES_SAME_CONTENTS;
	break;
      }
    if (!bfd_set_section_flags (stdoutput, now_seg, flags))
      as_bad (_("bfd_set_section_flags: %s"),
	      bfd_errmsg (bfd_get_error ()));
  }
#endif /* ! defined (obj_handle_link_once) */

  demand_empty_rest_of_line ();
}

void
bss_alloc (symbolS *symbolP, addressT size, int align)
{
  char *pfrag;
  segT current_seg = now_seg;
  subsegT current_subseg = now_subseg;
  segT bss_seg = bss_section;

#if defined (TC_MIPS) || defined (TC_ALPHA)
  if (OUTPUT_FLAVOR == bfd_target_ecoff_flavour
      || OUTPUT_FLAVOR == bfd_target_elf_flavour)
    {
      /* For MIPS and Alpha ECOFF or ELF, small objects are put in .sbss.  */
      if (size <= bfd_get_gp_size (stdoutput))
	{
	  bss_seg = subseg_new (".sbss", 1);
	  seg_info (bss_seg)->bss = 1;
	  if (!bfd_set_section_flags (stdoutput, bss_seg, SEC_ALLOC))
	    as_warn (_("error setting flags for \".sbss\": %s"),
		     bfd_errmsg (bfd_get_error ()));
	}
    }
#endif
  subseg_set (bss_seg, 1);

  if (align)
    {
      record_alignment (bss_seg, align);
      frag_align (align, 0, 0);
    }

  /* Detach from old frag.  */
  if (S_GET_SEGMENT (symbolP) == bss_seg)
    symbol_get_frag (symbolP)->fr_symbol = NULL;

  symbol_set_frag (symbolP, frag_now);
  pfrag = frag_var (rs_org, 1, 1, 0, symbolP, size, NULL);
  *pfrag = 0;

#ifdef S_SET_SIZE
  S_SET_SIZE (symbolP, size);
#endif
  S_SET_SEGMENT (symbolP, bss_seg);

#ifdef OBJ_COFF
  /* The symbol may already have been created with a preceding
     ".globl" directive -- be careful not to step on storage class
     in that case.  Otherwise, set it to static.  */
  if (S_GET_STORAGE_CLASS (symbolP) != C_EXT)
    S_SET_STORAGE_CLASS (symbolP, C_STAT);
#endif /* OBJ_COFF */

  subseg_set (current_seg, current_subseg);
}

offsetT
parse_align (int align_bytes)
{
  expressionS exp;
  addressT align;

  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
    no_align:
      as_bad (_("expected alignment after size"));
      ignore_rest_of_line ();
      return -1;
    }

  input_line_pointer++;
  SKIP_WHITESPACE ();

  align = get_absolute_expr (&exp);
  if (exp.X_op == O_absent)
    goto no_align;

  if (!exp.X_unsigned)
    {
      as_warn (_("alignment negative; 0 assumed"));
      align = 0;
    }

  if (align_bytes && align != 0)
    {
      /* convert to a power of 2 alignment */
      unsigned int alignp2 = 0;
      while ((align & 1) == 0)
	align >>= 1, ++alignp2;
      if (align != 1)
	{
	  as_bad (_("alignment not a power of 2"));
	  ignore_rest_of_line ();
	  return -1;
	}
      align = alignp2;
    }
  return align;
}

/* Called from s_comm_internal after symbol name and size have been
   parsed.  NEEDS_ALIGN is 0 if it was an ".lcomm" (2 args only),
   1 if this was a ".bss" directive which has a 3rd argument
   (alignment as a power of 2), or 2 if this was a ".bss" directive
   with alignment in bytes.  */

symbolS *
s_lcomm_internal (int needs_align, symbolS *symbolP, addressT size)
{
  addressT align = 0;

  if (needs_align)
    {
      align = parse_align (needs_align - 1);
      if (align == (addressT) -1)
	return NULL;
    }
  else
    /* Assume some objects may require alignment on some systems.  */
    TC_IMPLICIT_LCOMM_ALIGNMENT (size, align);

  bss_alloc (symbolP, size, align);
  return symbolP;
}

void
s_lcomm (int needs_align)
{
  s_comm_internal (needs_align, s_lcomm_internal);
}

void
s_lcomm_bytes (int needs_align)
{
  s_comm_internal (needs_align * 2, s_lcomm_internal);
}

void
s_lsym (int ignore ATTRIBUTE_UNUSED)
{
  char *name;
  expressionS exp;
  symbolS *symbolP;

  /* We permit ANY defined expression: BSD4.2 demands constants.  */
  if ((name = read_symbol_name ()) == NULL)
    return;

  if (*input_line_pointer != ',')
    {
      as_bad (_("expected comma after \"%s\""), name);
      goto err_out;
    }

  input_line_pointer++;
  expression_and_evaluate (&exp);

  if (exp.X_op != O_constant
      && exp.X_op != O_register)
    {
      as_bad (_("bad expression"));
      goto err_out;
    }

  symbolP = symbol_find_or_make (name);

  if (S_GET_SEGMENT (symbolP) == undefined_section)
    {
      /* The name might be an undefined .global symbol; be sure to
	 keep the "external" bit.  */
      S_SET_SEGMENT (symbolP,
		     (exp.X_op == O_constant
		      ? absolute_section
		      : reg_section));
      S_SET_VALUE (symbolP, (valueT) exp.X_add_number);
    }
  else
    {
      as_bad (_("symbol `%s' is already defined"), name);
    }

  demand_empty_rest_of_line ();
  free (name);
  return;

 err_out:
  ignore_rest_of_line ();
  free (name);
  return;
}

/* Read a line into an sb.  Returns the character that ended the line
   or zero if there are no more lines.  */

static int
get_line_sb (sb *line, int in_macro)
{
  char *eol;

  if (input_line_pointer[-1] == '\n')
    bump_line_counters ();

  if (input_line_pointer >= buffer_limit)
    {
      buffer_limit = input_scrub_next_buffer (&input_line_pointer);
      if (buffer_limit == 0)
	return 0;
    }

  eol = _find_end_of_line (input_line_pointer, flag_m68k_mri, 0, in_macro);
  sb_add_buffer (line, input_line_pointer, eol - input_line_pointer);
  input_line_pointer = eol;

  /* Don't skip multiple end-of-line characters, because that breaks support
     for the IA-64 stop bit (;;) which looks like two consecutive end-of-line
     characters but isn't.  Instead just skip one end of line character and
     return the character skipped so that the caller can re-insert it if
     necessary.   */
  return *input_line_pointer++;
}

static size_t
get_non_macro_line_sb (sb *line)
{
  return get_line_sb (line, 0);
}

static size_t
get_macro_line_sb (sb *line)
{
  return get_line_sb (line, 1);
}

/* Define a macro.  This is an interface to macro.c.  */

void
s_macro (int ignore ATTRIBUTE_UNUSED)
{
  char *file, *eol;
  unsigned int line;
  sb s;
  const char *err;
  const char *name;

  as_where (&file, &line);

  eol = find_end_of_line (input_line_pointer, 0);
  sb_build (&s, eol - input_line_pointer);
  sb_add_buffer (&s, input_line_pointer, eol - input_line_pointer);
  input_line_pointer = eol;

  if (line_label != NULL)
    {
      sb label;
      size_t len;

      name = S_GET_NAME (line_label);
      len = strlen (name);
      sb_build (&label, len);
      sb_add_buffer (&label, name, len);
      err = define_macro (0, &s, &label, get_macro_line_sb, file, line, &name);
      sb_kill (&label);
    }
  else
    err = define_macro (0, &s, NULL, get_macro_line_sb, file, line, &name);
  if (err != NULL)
    as_bad_where (file, line, err, name);
  else
    {
      if (line_label != NULL)
	{
	  S_SET_SEGMENT (line_label, absolute_section);
	  S_SET_VALUE (line_label, 0);
	  symbol_set_frag (line_label, &zero_address_frag);
	}

      if (((NO_PSEUDO_DOT || flag_m68k_mri)
	   && hash_find (po_hash, name) != NULL)
	  || (!flag_m68k_mri
	      && *name == '.'
	      && hash_find (po_hash, name + 1) != NULL))
	as_warn_where (file,
		 line,
		 _("attempt to redefine pseudo-op `%s' ignored"),
		 name);
    }

  sb_kill (&s);
}

/* Handle the .mexit pseudo-op, which immediately exits a macro
   expansion.  */

void
s_mexit (int ignore ATTRIBUTE_UNUSED)
{
  if (macro_nest)
    {
      cond_exit_macro (macro_nest);
      buffer_limit = input_scrub_next_buffer (&input_line_pointer);
    }
  else
    as_warn (_("ignoring macro exit outside a macro definition."));
}

/* Switch in and out of MRI mode.  */

void
s_mri (int ignore ATTRIBUTE_UNUSED)
{
  int on;
#ifdef MRI_MODE_CHANGE
  int old_flag;
#endif

  on = get_absolute_expression ();
#ifdef MRI_MODE_CHANGE
  old_flag = flag_mri;
#endif
  if (on != 0)
    {
      flag_mri = 1;
#ifdef TC_M68K
      flag_m68k_mri = 1;
#endif
      macro_mri_mode (1);
    }
  else
    {
      flag_mri = 0;
#ifdef TC_M68K
      flag_m68k_mri = 0;
#endif
      macro_mri_mode (0);
    }

  /* Operator precedence changes in m68k MRI mode, so we need to
     update the operator rankings.  */
  expr_set_precedence ();

#ifdef MRI_MODE_CHANGE
  if (on != old_flag)
    MRI_MODE_CHANGE (on);
#endif

  demand_empty_rest_of_line ();
}

/* Handle changing the location counter.  */

static void
do_org (segT segment, expressionS *exp, int fill)
{
  if (segment != now_seg
      && segment != absolute_section
      && segment != expr_section)
    as_bad (_("invalid segment \"%s\""), segment_name (segment));

  if (now_seg == absolute_section)
    {
      if (fill != 0)
	as_warn (_("ignoring fill value in absolute section"));
      if (exp->X_op != O_constant)
	{
	  as_bad (_("only constant offsets supported in absolute section"));
	  exp->X_add_number = 0;
	}
      abs_section_offset = exp->X_add_number;
    }
  else
    {
      char *p;
      symbolS *sym = exp->X_add_symbol;
      offsetT off = exp->X_add_number * OCTETS_PER_BYTE;

      if (exp->X_op != O_constant && exp->X_op != O_symbol)
	{
	  /* Handle complex expressions.  */
	  sym = make_expr_symbol (exp);
	  off = 0;
	}

      p = frag_var (rs_org, 1, 1, (relax_substateT) 0, sym, off, (char *) 0);
      *p = fill;
    }
}

void
s_org (int ignore ATTRIBUTE_UNUSED)
{
  segT segment;
  expressionS exp;
  long temp_fill;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  /* The m68k MRI assembler has a different meaning for .org.  It
     means to create an absolute section at a given address.  We can't
     support that--use a linker script instead.  */
  if (flag_m68k_mri)
    {
      as_bad (_("MRI style ORG pseudo-op not supported"));
      ignore_rest_of_line ();
      return;
    }

  /* Don't believe the documentation of BSD 4.2 AS.  There is no such
     thing as a sub-segment-relative origin.  Any absolute origin is
     given a warning, then assumed to be segment-relative.  Any
     segmented origin expression ("foo+42") had better be in the right
     segment or the .org is ignored.

     BSD 4.2 AS warns if you try to .org backwards. We cannot because
     we never know sub-segment sizes when we are reading code.  BSD
     will crash trying to emit negative numbers of filler bytes in
     certain .orgs. We don't crash, but see as-write for that code.

     Don't make frag if need_pass_2==1.  */
  segment = get_known_segmented_expression (&exp);
  if (*input_line_pointer == ',')
    {
      input_line_pointer++;
      temp_fill = get_absolute_expression ();
    }
  else
    temp_fill = 0;

  if (!need_pass_2)
    do_org (segment, &exp, temp_fill);

  demand_empty_rest_of_line ();
}

/* Handle parsing for the MRI SECT/SECTION pseudo-op.  This should be
   called by the obj-format routine which handles section changing
   when in MRI mode.  It will create a new section, and return it.  It
   will set *TYPE to the section type: one of 'C' (code), 'D' (data),
   'M' (mixed), or 'R' (romable).  The flags will be set in the section.  */

void
s_mri_sect (char *type ATTRIBUTE_UNUSED)
{
#ifdef TC_M68K

  char *name;
  char c;
  segT seg;

  SKIP_WHITESPACE ();

  name = input_line_pointer;
  if (!ISDIGIT (*name))
    c = get_symbol_end ();
  else
    {
      do
	{
	  ++input_line_pointer;
	}
      while (ISDIGIT (*input_line_pointer));

      c = *input_line_pointer;
      *input_line_pointer = '\0';
    }

  name = xstrdup (name);

  *input_line_pointer = c;

  seg = subseg_new (name, 0);

  if (*input_line_pointer == ',')
    {
      int align;

      ++input_line_pointer;
      align = get_absolute_expression ();
      record_alignment (seg, align);
    }

  *type = 'C';
  if (*input_line_pointer == ',')
    {
      c = *++input_line_pointer;
      c = TOUPPER (c);
      if (c == 'C' || c == 'D' || c == 'M' || c == 'R')
	*type = c;
      else
	as_bad (_("unrecognized section type"));
      ++input_line_pointer;

      {
	flagword flags;

	flags = SEC_NO_FLAGS;
	if (*type == 'C')
	  flags = SEC_ALLOC | SEC_LOAD | SEC_READONLY | SEC_CODE;
	else if (*type == 'D' || *type == 'M')
	  flags = SEC_ALLOC | SEC_LOAD | SEC_DATA;
	else if (*type == 'R')
	  flags = SEC_ALLOC | SEC_LOAD | SEC_DATA | SEC_READONLY | SEC_ROM;
	if (flags != SEC_NO_FLAGS)
	  {
	    if (!bfd_set_section_flags (stdoutput, seg, flags))
	      as_warn (_("error setting flags for \"%s\": %s"),
		       bfd_section_name (stdoutput, seg),
		       bfd_errmsg (bfd_get_error ()));
	  }
      }
    }

  /* Ignore the HP type.  */
  if (*input_line_pointer == ',')
    input_line_pointer += 2;

  demand_empty_rest_of_line ();

#else /* ! TC_M68K */
#ifdef TC_I960

  char *name;
  char c;
  segT seg;

  SKIP_WHITESPACE ();

  name = input_line_pointer;
  c = get_symbol_end ();

  name = xstrdup (name);

  *input_line_pointer = c;

  seg = subseg_new (name, 0);

  if (*input_line_pointer != ',')
    *type = 'C';
  else
    {
      char *sectype;

      ++input_line_pointer;
      SKIP_WHITESPACE ();
      sectype = input_line_pointer;
      c = get_symbol_end ();
      if (*sectype == '\0')
	*type = 'C';
      else if (strcasecmp (sectype, "text") == 0)
	*type = 'C';
      else if (strcasecmp (sectype, "data") == 0)
	*type = 'D';
      else if (strcasecmp (sectype, "romdata") == 0)
	*type = 'R';
      else
	as_warn (_("unrecognized section type `%s'"), sectype);
      *input_line_pointer = c;
    }

  if (*input_line_pointer == ',')
    {
      char *seccmd;

      ++input_line_pointer;
      SKIP_WHITESPACE ();
      seccmd = input_line_pointer;
      c = get_symbol_end ();
      if (strcasecmp (seccmd, "absolute") == 0)
	{
	  as_bad (_("absolute sections are not supported"));
	  *input_line_pointer = c;
	  ignore_rest_of_line ();
	  return;
	}
      else if (strcasecmp (seccmd, "align") == 0)
	{
	  int align;

	  *input_line_pointer = c;
	  align = get_absolute_expression ();
	  record_alignment (seg, align);
	}
      else
	{
	  as_warn (_("unrecognized section command `%s'"), seccmd);
	  *input_line_pointer = c;
	}
    }

  demand_empty_rest_of_line ();

#else /* ! TC_I960 */
  /* The MRI assembler seems to use different forms of .sect for
     different targets.  */
  as_bad ("MRI mode not supported for this target");
  ignore_rest_of_line ();
#endif /* ! TC_I960 */
#endif /* ! TC_M68K */
}

/* Handle the .print pseudo-op.  */

void
s_print (int ignore ATTRIBUTE_UNUSED)
{
  char *s;
  int len;

  s = demand_copy_C_string (&len);
  if (s != NULL)
    printf ("%s\n", s);
  demand_empty_rest_of_line ();
}

/* Handle the .purgem pseudo-op.  */

void
s_purgem (int ignore ATTRIBUTE_UNUSED)
{
  if (is_it_end_of_statement ())
    {
      demand_empty_rest_of_line ();
      return;
    }

  do
    {
      char *name;
      char c;

      SKIP_WHITESPACE ();
      name = input_line_pointer;
      c = get_symbol_end ();
      delete_macro (name);
      *input_line_pointer = c;
      SKIP_WHITESPACE ();
    }
  while (*input_line_pointer++ == ',');

  --input_line_pointer;
  demand_empty_rest_of_line ();
}

/* Handle the .endm/.endr pseudo-ops.  */

static void
s_bad_end (int endr)
{
  as_warn (_(".end%c encountered without preceding %s"),
	   endr ? 'r' : 'm',
	   endr ? ".rept, .irp, or .irpc" : ".macro");
  demand_empty_rest_of_line ();
}

/* Handle the .rept pseudo-op.  */

void
s_rept (int ignore ATTRIBUTE_UNUSED)
{
  int count;

  count = get_absolute_expression ();

  do_repeat (count, "REPT", "ENDR");
}

/* This function provides a generic repeat block implementation.   It allows
   different directives to be used as the start/end keys.  */

void
do_repeat (int count, const char *start, const char *end)
{
  sb one;
  sb many;

  sb_new (&one);
  if (!buffer_and_nest (start, end, &one, get_non_macro_line_sb))
    {
      as_bad (_("%s without %s"), start, end);
      return;
    }

  sb_build (&many, count * one.len);
  while (count-- > 0)
    sb_add_sb (&many, &one);

  sb_kill (&one);

  input_scrub_include_sb (&many, input_line_pointer, 1);
  sb_kill (&many);
  buffer_limit = input_scrub_next_buffer (&input_line_pointer);
}

/* Like do_repeat except that any text matching EXPANDER in the
   block is replaced by the itteration count.  */

void
do_repeat_with_expander (int count,
			 const char * start,
			 const char * end,
			 const char * expander)
{
  sb one;
  sb many;

  sb_new (&one);
  if (!buffer_and_nest (start, end, &one, get_non_macro_line_sb))
    {
      as_bad (_("%s without %s"), start, end);
      return;
    }

  sb_new (&many);

  if (expander != NULL && strstr (one.ptr, expander) != NULL)
    {
      while (count -- > 0)
	{
	  int len;
	  char * sub;
	  sb processed;

	  sb_build (& processed, one.len);
	  sb_add_sb (& processed, & one);
	  sub = strstr (processed.ptr, expander);
	  len = sprintf (sub, "%d", count);
	  gas_assert (len < 8);
	  strcpy (sub + len, sub + 8);
	  processed.len -= (8 - len);
	  sb_add_sb (& many, & processed);
	  sb_kill (& processed);
	}
    }
  else
    while (count-- > 0)
      sb_add_sb (&many, &one);

  sb_kill (&one);

  input_scrub_include_sb (&many, input_line_pointer, 1);
  sb_kill (&many);
  buffer_limit = input_scrub_next_buffer (&input_line_pointer);
}

/* Skip to end of current repeat loop; EXTRA indicates how many additional
   input buffers to skip.  Assumes that conditionals preceding the loop end
   are properly nested.

   This function makes it easier to implement a premature "break" out of the
   loop.  The EXTRA arg accounts for other buffers we might have inserted,
   such as line substitutions.  */

void
end_repeat (int extra)
{
  cond_exit_macro (macro_nest);
  while (extra-- >= 0)
    buffer_limit = input_scrub_next_buffer (&input_line_pointer);
}

static void
assign_symbol (char *name, int mode)
{
  symbolS *symbolP;

  if (name[0] == '.' && name[1] == '\0')
    {
      /* Turn '. = mumble' into a .org mumble.  */
      segT segment;
      expressionS exp;

      segment = get_known_segmented_expression (&exp);

      if (!need_pass_2)
	do_org (segment, &exp, 0);

      return;
    }

  if ((symbolP = symbol_find (name)) == NULL
      && (symbolP = md_undefined_symbol (name)) == NULL)
    {
      symbolP = symbol_find_or_make (name);
#ifndef NO_LISTING
      /* When doing symbol listings, play games with dummy fragments living
	 outside the normal fragment chain to record the file and line info
	 for this symbol.  */
      if (listing & LISTING_SYMBOLS)
	{
	  extern struct list_info_struct *listing_tail;
	  fragS *dummy_frag = (fragS *) xcalloc (1, sizeof (fragS));
	  dummy_frag->line = listing_tail;
	  dummy_frag->fr_symbol = symbolP;
	  symbol_set_frag (symbolP, dummy_frag);
	}
#endif
#ifdef OBJ_COFF
      /* "set" symbols are local unless otherwise specified.  */
      SF_SET_LOCAL (symbolP);
#endif
    }

  if (S_IS_DEFINED (symbolP) || symbol_equated_p (symbolP))
    {
      if ((mode != 0 || !S_IS_VOLATILE (symbolP))
	  && !S_CAN_BE_REDEFINED (symbolP))
	{
	  as_bad (_("symbol `%s' is already defined"), name);
	  symbolP = symbol_clone (symbolP, 0);
	}
      /* If the symbol is volatile, copy the symbol and replace the
	 original with the copy, so that previous uses of the symbol will
	 retain the value of the symbol at the point of use.  */
      else if (S_IS_VOLATILE (symbolP))
	symbolP = symbol_clone (symbolP, 1);
    }

  if (mode == 0)
    S_SET_VOLATILE (symbolP);
  else if (mode < 0)
    S_SET_FORWARD_REF (symbolP);

  pseudo_set (symbolP);
}

/* Handle the .equ, .equiv, .eqv, and .set directives.  If EQUIV is 1,
   then this is .equiv, and it is an error if the symbol is already
   defined.  If EQUIV is -1, the symbol additionally is a forward
   reference.  */

void
s_set (int equiv)
{
  char *name;

  /* Especial apologies for the random logic:
     this just grew, and could be parsed much more simply!
     Dean in haste.  */
  if ((name = read_symbol_name ()) == NULL)
    return;

  if (*input_line_pointer != ',')
    {
      as_bad (_("expected comma after \"%s\""), name);
      ignore_rest_of_line ();
      free (name);
      return;
    }

  input_line_pointer++;
  assign_symbol (name, equiv);
  demand_empty_rest_of_line ();
  free (name);
}

void
s_space (int mult)
{
  expressionS exp;
  expressionS val;
  char *p = 0;
  char *stop = NULL;
  char stopc = 0;
  int bytes;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

#ifdef md_cons_align
  md_cons_align (1);
#endif

  if (flag_mri)
    stop = mri_comment_field (&stopc);

  /* In m68k MRI mode, we need to align to a word boundary, unless
     this is ds.b.  */
  if (flag_m68k_mri && mult > 1)
    {
      if (now_seg == absolute_section)
	{
	  abs_section_offset += abs_section_offset & 1;
	  if (line_label != NULL)
	    S_SET_VALUE (line_label, abs_section_offset);
	}
      else if (mri_common_symbol != NULL)
	{
	  valueT mri_val;

	  mri_val = S_GET_VALUE (mri_common_symbol);
	  if ((mri_val & 1) != 0)
	    {
	      S_SET_VALUE (mri_common_symbol, mri_val + 1);
	      if (line_label != NULL)
		{
		  expressionS *symexp;

		  symexp = symbol_get_value_expression (line_label);
		  know (symexp->X_op == O_symbol);
		  know (symexp->X_add_symbol == mri_common_symbol);
		  symexp->X_add_number += 1;
		}
	    }
	}
      else
	{
	  do_align (1, (char *) NULL, 0, 0);
	  if (line_label != NULL)
	    {
	      symbol_set_frag (line_label, frag_now);
	      S_SET_VALUE (line_label, frag_now_fix ());
	    }
	}
    }

  bytes = mult;

  expression (&exp);

  SKIP_WHITESPACE ();
  if (*input_line_pointer == ',')
    {
      ++input_line_pointer;
      expression (&val);
    }
  else
    {
      val.X_op = O_constant;
      val.X_add_number = 0;
    }

  if (val.X_op != O_constant
      || val.X_add_number < - 0x80
      || val.X_add_number > 0xff
      || (mult != 0 && mult != 1 && val.X_add_number != 0))
    {
      resolve_expression (&exp);
      if (exp.X_op != O_constant)
	as_bad (_("unsupported variable size or fill value"));
      else
	{
	  offsetT i;

	  if (mult == 0)
	    mult = 1;
	  bytes = mult * exp.X_add_number;
	  for (i = 0; i < exp.X_add_number; i++)
	    emit_expr (&val, mult);
	}
    }
  else
    {
      if (now_seg == absolute_section || mri_common_symbol != NULL)
	resolve_expression (&exp);

      if (exp.X_op == O_constant)
	{
	  offsetT repeat;

	  repeat = exp.X_add_number;
	  if (mult)
	    repeat *= mult;
	  bytes = repeat;
	  if (repeat <= 0)
	    {
	      if (!flag_mri)
		as_warn (_(".space repeat count is zero, ignored"));
	      else if (repeat < 0)
		as_warn (_(".space repeat count is negative, ignored"));
	      goto getout;
	    }

	  /* If we are in the absolute section, just bump the offset.  */
	  if (now_seg == absolute_section)
	    {
	      abs_section_offset += repeat;
	      goto getout;
	    }

	  /* If we are secretly in an MRI common section, then
	     creating space just increases the size of the common
	     symbol.  */
	  if (mri_common_symbol != NULL)
	    {
	      S_SET_VALUE (mri_common_symbol,
			   S_GET_VALUE (mri_common_symbol) + repeat);
	      goto getout;
	    }

	  if (!need_pass_2)
	    p = frag_var (rs_fill, 1, 1, (relax_substateT) 0, (symbolS *) 0,
			  (offsetT) repeat, (char *) 0);
	}
      else
	{
	  if (now_seg == absolute_section)
	    {
	      as_bad (_("space allocation too complex in absolute section"));
	      subseg_set (text_section, 0);
	    }

	  if (mri_common_symbol != NULL)
	    {
	      as_bad (_("space allocation too complex in common section"));
	      mri_common_symbol = NULL;
	    }

	  if (!need_pass_2)
	    p = frag_var (rs_space, 1, 1, (relax_substateT) 0,
			  make_expr_symbol (&exp), (offsetT) 0, (char *) 0);
	}

      if (p)
	*p = val.X_add_number;
    }

 getout:

  /* In MRI mode, after an odd number of bytes, we must align to an
     even word boundary, unless the next instruction is a dc.b, ds.b
     or dcb.b.  */
  if (flag_mri && (bytes & 1) != 0)
    mri_pending_align = 1;

  demand_empty_rest_of_line ();

  if (flag_mri)
    mri_comment_end (stop, stopc);
}

/* This is like s_space, but the value is a floating point number with
   the given precision.  This is for the MRI dcb.s pseudo-op and
   friends.  */

void
s_float_space (int float_type)
{
  offsetT count;
  int flen;
  char temp[MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT];
  char *stop = NULL;
  char stopc = 0;

#ifdef md_cons_align
  md_cons_align (1);
#endif

  if (flag_mri)
    stop = mri_comment_field (&stopc);

  count = get_absolute_expression ();

  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
      as_bad (_("missing value"));
      ignore_rest_of_line ();
      if (flag_mri)
	mri_comment_end (stop, stopc);
      return;
    }

  ++input_line_pointer;

  SKIP_WHITESPACE ();

  /* Skip any 0{letter} that may be present.  Don't even check if the
   * letter is legal.  */
  if (input_line_pointer[0] == '0'
      && ISALPHA (input_line_pointer[1]))
    input_line_pointer += 2;

  /* Accept :xxxx, where the x's are hex digits, for a floating point
     with the exact digits specified.  */
  if (input_line_pointer[0] == ':')
    {
      flen = hex_float (float_type, temp);
      if (flen < 0)
	{
	  ignore_rest_of_line ();
	  if (flag_mri)
	    mri_comment_end (stop, stopc);
	  return;
	}
    }
  else
    {
      char *err;

      err = md_atof (float_type, temp, &flen);
      know (flen <= MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT);
      know (err != NULL || flen > 0);
      if (err)
	{
	  as_bad (_("bad floating literal: %s"), err);
	  ignore_rest_of_line ();
	  if (flag_mri)
	    mri_comment_end (stop, stopc);
	  return;
	}
    }

  while (--count >= 0)
    {
      char *p;

      p = frag_more (flen);
      memcpy (p, temp, (unsigned int) flen);
    }

  demand_empty_rest_of_line ();

  if (flag_mri)
    mri_comment_end (stop, stopc);
}

/* Handle the .struct pseudo-op, as found in MIPS assemblers.  */

void
s_struct (int ignore ATTRIBUTE_UNUSED)
{
  char *stop = NULL;
  char stopc = 0;

  if (flag_mri)
    stop = mri_comment_field (&stopc);
  abs_section_offset = get_absolute_expression ();
#if defined (OBJ_ELF) || defined (OBJ_MAYBE_ELF)
  /* The ELF backend needs to know that we are changing sections, so
     that .previous works correctly. */
  if (IS_ELF)
    obj_elf_section_change_hook ();
#endif
  subseg_set (absolute_section, 0);
  demand_empty_rest_of_line ();
  if (flag_mri)
    mri_comment_end (stop, stopc);
}

void
s_text (int ignore ATTRIBUTE_UNUSED)
{
  int temp;

  temp = get_absolute_expression ();
  subseg_set (text_section, (subsegT) temp);
  demand_empty_rest_of_line ();
}

/* .weakref x, y sets x as an alias to y that, as long as y is not
   referenced directly, will cause y to become a weak symbol.  */
void
s_weakref (int ignore ATTRIBUTE_UNUSED)
{
  char *name;
  symbolS *symbolP;
  symbolS *symbolP2;
  expressionS exp;

  if ((name = read_symbol_name ()) == NULL)
    return;

  symbolP = symbol_find_or_make (name);

  if (S_IS_DEFINED (symbolP) || symbol_equated_p (symbolP))
    {
      if (!S_IS_VOLATILE (symbolP))
	{
	  as_bad (_("symbol `%s' is already defined"), name);
	  goto err_out;
	}
      symbolP = symbol_clone (symbolP, 1);
      S_CLEAR_VOLATILE (symbolP);
    }

  SKIP_WHITESPACE ();

  if (*input_line_pointer != ',')
    {
      as_bad (_("expected comma after \"%s\""), name);
      goto err_out;
    }

  input_line_pointer++;

  SKIP_WHITESPACE ();
  free (name);

  if ((name = read_symbol_name ()) == NULL)
    return;

  if ((symbolP2 = symbol_find_noref (name, 1)) == NULL
      && (symbolP2 = md_undefined_symbol (name)) == NULL)
    {
      symbolP2 = symbol_find_or_make (name);
      S_SET_WEAKREFD (symbolP2);
    }
  else
    {
      symbolS *symp = symbolP2;

      while (S_IS_WEAKREFR (symp) && symp != symbolP)
	{
	  expressionS *expP = symbol_get_value_expression (symp);

	  gas_assert (expP->X_op == O_symbol
		  && expP->X_add_number == 0);
	  symp = expP->X_add_symbol;
	}
      if (symp == symbolP)
	{
	  char *loop;

	  loop = concat (S_GET_NAME (symbolP),
			 " => ", S_GET_NAME (symbolP2), (const char *) NULL);

	  symp = symbolP2;
	  while (symp != symbolP)
	    {
	      char *old_loop = loop;

	      symp = symbol_get_value_expression (symp)->X_add_symbol;
	      loop = concat (loop, " => ", S_GET_NAME (symp),
			     (const char *) NULL);
	      free (old_loop);
	    }

	  as_bad (_("%s: would close weakref loop: %s"),
		  S_GET_NAME (symbolP), loop);

	  free (loop);
	  free (name);
	  ignore_rest_of_line ();
	  return;
	}

      /* Short-circuiting instead of just checking here might speed
	 things up a tiny little bit, but loop error messages would
	 miss intermediate links.  */
      /* symbolP2 = symp; */
    }

  memset (&exp, 0, sizeof (exp));
  exp.X_op = O_symbol;
  exp.X_add_symbol = symbolP2;

  S_SET_SEGMENT (symbolP, undefined_section);
  symbol_set_value_expression (symbolP, &exp);
  symbol_set_frag (symbolP, &zero_address_frag);
  S_SET_WEAKREFR (symbolP);

  demand_empty_rest_of_line ();
  free (name);
  return;

 err_out:
  ignore_rest_of_line ();
  free (name);
  return;
}


/* Verify that we are at the end of a line.  If not, issue an error and
   skip to EOL.  */

void
demand_empty_rest_of_line (void)
{
  SKIP_WHITESPACE ();
  if (is_end_of_line[(unsigned char) *input_line_pointer])
    input_line_pointer++;
  else
    {
      if (ISPRINT (*input_line_pointer))
	as_bad (_("junk at end of line, first unrecognized character is `%c'"),
		 *input_line_pointer);
      else
	as_bad (_("junk at end of line, first unrecognized character valued 0x%x"),
		 *input_line_pointer);
      ignore_rest_of_line ();
    }

  /* Return pointing just after end-of-line.  */
  know (is_end_of_line[(unsigned char) input_line_pointer[-1]]);
}

/* Silently advance to the end of line.  Use this after already having
   issued an error about something bad.  */

void
ignore_rest_of_line (void)
{
  while (input_line_pointer < buffer_limit
	 && !is_end_of_line[(unsigned char) *input_line_pointer])
    input_line_pointer++;

  input_line_pointer++;

  /* Return pointing just after end-of-line.  */
  know (is_end_of_line[(unsigned char) input_line_pointer[-1]]);
}

/* Sets frag for given symbol to zero_address_frag, except when the
   symbol frag is already set to a dummy listing frag.  */

static void
set_zero_frag (symbolS *symbolP)
{
  if (symbol_get_frag (symbolP)->fr_type != rs_dummy)
    symbol_set_frag (symbolP, &zero_address_frag);
}

/* In:	Pointer to a symbol.
	Input_line_pointer->expression.

   Out:	Input_line_pointer->just after any whitespace after expression.
	Tried to set symbol to value of expression.
	Will change symbols type, value, and frag;  */

void
pseudo_set (symbolS *symbolP)
{
  expressionS exp;
  segT seg;

  know (symbolP);		/* NULL pointer is logic error.  */

  if (!S_IS_FORWARD_REF (symbolP))
    (void) expression (&exp);
  else
    (void) deferred_expression (&exp);

  if (exp.X_op == O_illegal)
    as_bad (_("illegal expression"));
  else if (exp.X_op == O_absent)
    as_bad (_("missing expression"));
  else if (exp.X_op == O_big)
    {
      if (exp.X_add_number > 0)
	as_bad (_("bignum invalid"));
      else
	as_bad (_("floating point number invalid"));
    }
  else if (exp.X_op == O_subtract
	   && !S_IS_FORWARD_REF (symbolP)
	   && SEG_NORMAL (S_GET_SEGMENT (exp.X_add_symbol))
	   && (symbol_get_frag (exp.X_add_symbol)
	       == symbol_get_frag (exp.X_op_symbol)))
    {
      exp.X_op = O_constant;
      exp.X_add_number = (S_GET_VALUE (exp.X_add_symbol)
			  - S_GET_VALUE (exp.X_op_symbol));
    }

  if (symbol_section_p (symbolP))
    {
      as_bad ("attempt to set value of section symbol");
      return;
    }

  switch (exp.X_op)
    {
    case O_illegal:
    case O_absent:
    case O_big:
      exp.X_add_number = 0;
      /* Fall through.  */
    case O_constant:
      S_SET_SEGMENT (symbolP, absolute_section);
      S_SET_VALUE (symbolP, (valueT) exp.X_add_number);
      set_zero_frag (symbolP);
      break;

    case O_register:
#ifndef TC_GLOBAL_REGISTER_SYMBOL_OK
      if (S_IS_EXTERNAL (symbolP))
	{
	  as_bad ("can't equate global symbol `%s' with register name",
		  S_GET_NAME (symbolP));
	  return;
	}
#endif
      S_SET_SEGMENT (symbolP, reg_section);
      S_SET_VALUE (symbolP, (valueT) exp.X_add_number);
      set_zero_frag (symbolP);
      symbol_get_value_expression (symbolP)->X_op = O_register;
      break;

    case O_symbol:
      seg = S_GET_SEGMENT (exp.X_add_symbol);
      /* For x=undef+const, create an expression symbol.
	 For x=x+const, just update x except when x is an undefined symbol
	 For x=defined+const, evaluate x.  */
      if (symbolP == exp.X_add_symbol
	  && (seg != undefined_section
	      || !symbol_constant_p (symbolP)))
	{
	  *symbol_X_add_number (symbolP) += exp.X_add_number;
	  break;
	}
      else if (!S_IS_FORWARD_REF (symbolP) && seg != undefined_section)
	{
	  symbolS *s = exp.X_add_symbol;

	  if (S_IS_COMMON (s))
	    as_bad (_("`%s' can't be equated to common symbol '%s'"),
		    S_GET_NAME (symbolP), S_GET_NAME (s));

	  S_SET_SEGMENT (symbolP, seg);
	  S_SET_VALUE (symbolP, exp.X_add_number + S_GET_VALUE (s));
	  symbol_set_frag (symbolP, symbol_get_frag (s));
	  copy_symbol_attributes (symbolP, s);
	  break;
	}
      S_SET_SEGMENT (symbolP, undefined_section);
      symbol_set_value_expression (symbolP, &exp);
      copy_symbol_attributes (symbolP, exp.X_add_symbol);
      set_zero_frag (symbolP);
      break;

    default:
      /* The value is some complex expression.  */
      S_SET_SEGMENT (symbolP, expr_section);
      symbol_set_value_expression (symbolP, &exp);
      set_zero_frag (symbolP);
      break;
    }
}

/*			cons()

   CONStruct more frag of .bytes, or .words etc.
   Should need_pass_2 be 1 then emit no frag(s).
   This understands EXPRESSIONS.

   Bug (?)

   This has a split personality. We use expression() to read the
   value. We can detect if the value won't fit in a byte or word.
   But we can't detect if expression() discarded significant digits
   in the case of a long. Not worth the crocks required to fix it.  */

/* Select a parser for cons expressions.  */

/* Some targets need to parse the expression in various fancy ways.
   You can define TC_PARSE_CONS_EXPRESSION to do whatever you like
   (for example, the HPPA does this).  Otherwise, you can define
   BITFIELD_CONS_EXPRESSIONS to permit bitfields to be specified, or
   REPEAT_CONS_EXPRESSIONS to permit repeat counts.  If none of these
   are defined, which is the normal case, then only simple expressions
   are permitted.  */

#ifdef TC_M68K
static void
parse_mri_cons (expressionS *exp, unsigned int nbytes);
#endif

#ifndef TC_PARSE_CONS_EXPRESSION
#ifdef BITFIELD_CONS_EXPRESSIONS
#define TC_PARSE_CONS_EXPRESSION(EXP, NBYTES) parse_bitfield_cons (EXP, NBYTES)
static void
parse_bitfield_cons (expressionS *exp, unsigned int nbytes);
#endif
#ifdef REPEAT_CONS_EXPRESSIONS
#define TC_PARSE_CONS_EXPRESSION(EXP, NBYTES) parse_repeat_cons (EXP, NBYTES)
static void
parse_repeat_cons (expressionS *exp, unsigned int nbytes);
#endif

/* If we haven't gotten one yet, just call expression.  */
#ifndef TC_PARSE_CONS_EXPRESSION
#define TC_PARSE_CONS_EXPRESSION(EXP, NBYTES) expression (EXP)
#endif
#endif

void
do_parse_cons_expression (expressionS *exp,
			  int nbytes ATTRIBUTE_UNUSED)
{
  TC_PARSE_CONS_EXPRESSION (exp, nbytes);
}


/* Worker to do .byte etc statements.
   Clobbers input_line_pointer and checks end-of-line.  */

static void
cons_worker (int nbytes,	/* 1=.byte, 2=.word, 4=.long.  */
	     int rva)
{
  int c;
  expressionS exp;
  char *stop = NULL;
  char stopc = 0;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  if (flag_mri)
    stop = mri_comment_field (&stopc);

  if (is_it_end_of_statement ())
    {
      demand_empty_rest_of_line ();
      if (flag_mri)
	mri_comment_end (stop, stopc);
      return;
    }

#ifdef TC_ADDRESS_BYTES
  if (nbytes == 0)
    nbytes = TC_ADDRESS_BYTES ();
#endif

#ifdef md_cons_align
  md_cons_align (nbytes);
#endif

  c = 0;
  do
    {
#ifdef TC_M68K
      if (flag_m68k_mri)
	parse_mri_cons (&exp, (unsigned int) nbytes);
      else
#endif
	{
	  if (*input_line_pointer == '"')
	    {
	      as_bad (_("unexpected `\"' in expression"));
	      ignore_rest_of_line ();
	      return;
	    }
	  TC_PARSE_CONS_EXPRESSION (&exp, (unsigned int) nbytes);
	}

      if (rva)
	{
	  if (exp.X_op == O_symbol)
	    exp.X_op = O_symbol_rva;
	  else
	    as_fatal (_("rva without symbol"));
	}
      emit_expr (&exp, (unsigned int) nbytes);
      ++c;
    }
  while (*input_line_pointer++ == ',');

  /* In MRI mode, after an odd number of bytes, we must align to an
     even word boundary, unless the next instruction is a dc.b, ds.b
     or dcb.b.  */
  if (flag_mri && nbytes == 1 && (c & 1) != 0)
    mri_pending_align = 1;

  input_line_pointer--;		/* Put terminator back into stream.  */

  demand_empty_rest_of_line ();

  if (flag_mri)
    mri_comment_end (stop, stopc);
}

void
cons (int size)
{
  cons_worker (size, 0);
}

void
s_rva (int size)
{
  cons_worker (size, 1);
}

/* .reloc offset, reloc_name, symbol+addend.  */

void
s_reloc (int ignore ATTRIBUTE_UNUSED)
{
  char *stop = NULL;
  char stopc = 0;
  expressionS exp;
  char *r_name;
  int c;
  struct reloc_list *reloc;

  reloc = (struct reloc_list *) xmalloc (sizeof (*reloc));

  if (flag_mri)
    stop = mri_comment_field (&stopc);

  expression (&exp);
  switch (exp.X_op)
    {
    case O_illegal:
    case O_absent:
    case O_big:
    case O_register:
      as_bad (_("missing or bad offset expression"));
      goto err_out;
    case O_constant:
      exp.X_add_symbol = section_symbol (now_seg);
      exp.X_op = O_symbol;
      /* Fall thru */
    case O_symbol:
      if (exp.X_add_number == 0)
	{
	  reloc->u.a.offset_sym = exp.X_add_symbol;
	  break;
	}
      /* Fall thru */
    default:
      reloc->u.a.offset_sym = make_expr_symbol (&exp);
      break;
    }

  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
      as_bad (_("missing reloc type"));
      goto err_out;
    }

  ++input_line_pointer;
  SKIP_WHITESPACE ();
  r_name = input_line_pointer;
  c = get_symbol_end ();
  reloc->u.a.howto = bfd_reloc_name_lookup (stdoutput, r_name);
  *input_line_pointer = c;
  if (reloc->u.a.howto == NULL)
    {
      as_bad (_("unrecognized reloc type"));
      goto err_out;
    }

  exp.X_op = O_absent;
  SKIP_WHITESPACE ();
  if (*input_line_pointer == ',')
    {
      ++input_line_pointer;
      expression (&exp);
    }
  switch (exp.X_op)
    {
    case O_illegal:
    case O_big:
    case O_register:
      as_bad (_("bad reloc expression"));
    err_out:
      ignore_rest_of_line ();
      free (reloc);
      if (flag_mri)
	mri_comment_end (stop, stopc);
      return;
    case O_absent:
      reloc->u.a.sym = NULL;
      reloc->u.a.addend = 0;
      break;
    case O_constant:
      reloc->u.a.sym = NULL;
      reloc->u.a.addend = exp.X_add_number;
      break;
    case O_symbol:
      reloc->u.a.sym = exp.X_add_symbol;
      reloc->u.a.addend = exp.X_add_number;
      break;
    default:
      reloc->u.a.sym = make_expr_symbol (&exp);
      reloc->u.a.addend = 0;
      break;
    }

  as_where (&reloc->file, &reloc->line);
  reloc->next = reloc_list;
  reloc_list = reloc;

  demand_empty_rest_of_line ();
  if (flag_mri)
    mri_comment_end (stop, stopc);
}

/* Put the contents of expression EXP into the object file using
   NBYTES bytes.  If need_pass_2 is 1, this does nothing.  */

void
emit_expr (expressionS *exp, unsigned int nbytes)
{
  operatorT op;
  char *p;
  valueT extra_digit = 0;

  /* Don't do anything if we are going to make another pass.  */
  if (need_pass_2)
    return;

  frag_grow (nbytes);
  dot_value = frag_now_fix ();
  dot_frag = frag_now;

#ifndef NO_LISTING
#ifdef OBJ_ELF
  /* When gcc emits DWARF 1 debugging pseudo-ops, a line number will
     appear as a four byte positive constant in the .line section,
     followed by a 2 byte 0xffff.  Look for that case here.  */
  {
    static int dwarf_line = -1;

    if (strcmp (segment_name (now_seg), ".line") != 0)
      dwarf_line = -1;
    else if (dwarf_line >= 0
	     && nbytes == 2
	     && exp->X_op == O_constant
	     && (exp->X_add_number == -1 || exp->X_add_number == 0xffff))
      listing_source_line ((unsigned int) dwarf_line);
    else if (nbytes == 4
	     && exp->X_op == O_constant
	     && exp->X_add_number >= 0)
      dwarf_line = exp->X_add_number;
    else
      dwarf_line = -1;
  }

  /* When gcc emits DWARF 1 debugging pseudo-ops, a file name will
     appear as a 2 byte TAG_compile_unit (0x11) followed by a 2 byte
     AT_sibling (0x12) followed by a four byte address of the sibling
     followed by a 2 byte AT_name (0x38) followed by the name of the
     file.  We look for that case here.  */
  {
    static int dwarf_file = 0;

    if (strcmp (segment_name (now_seg), ".debug") != 0)
      dwarf_file = 0;
    else if (dwarf_file == 0
	     && nbytes == 2
	     && exp->X_op == O_constant
	     && exp->X_add_number == 0x11)
      dwarf_file = 1;
    else if (dwarf_file == 1
	     && nbytes == 2
	     && exp->X_op == O_constant
	     && exp->X_add_number == 0x12)
      dwarf_file = 2;
    else if (dwarf_file == 2
	     && nbytes == 4)
      dwarf_file = 3;
    else if (dwarf_file == 3
	     && nbytes == 2
	     && exp->X_op == O_constant
	     && exp->X_add_number == 0x38)
      dwarf_file = 4;
    else
      dwarf_file = 0;

    /* The variable dwarf_file_string tells stringer that the string
       may be the name of the source file.  */
    if (dwarf_file == 4)
      dwarf_file_string = 1;
    else
      dwarf_file_string = 0;
  }
#endif
#endif

  if (check_eh_frame (exp, &nbytes))
    return;

  op = exp->X_op;

  /* Allow `.word 0' in the absolute section.  */
  if (now_seg == absolute_section)
    {
      if (op != O_constant || exp->X_add_number != 0)
	as_bad (_("attempt to store value in absolute section"));
      abs_section_offset += nbytes;
      return;
    }

  /* Handle a negative bignum.  */
  if (op == O_uminus
      && exp->X_add_number == 0
      && symbol_get_value_expression (exp->X_add_symbol)->X_op == O_big
      && symbol_get_value_expression (exp->X_add_symbol)->X_add_number > 0)
    {
      int i;
      unsigned long carry;

      exp = symbol_get_value_expression (exp->X_add_symbol);

      /* Negate the bignum: one's complement each digit and add 1.  */
      carry = 1;
      for (i = 0; i < exp->X_add_number; i++)
	{
	  unsigned long next;

	  next = (((~(generic_bignum[i] & LITTLENUM_MASK))
		   & LITTLENUM_MASK)
		  + carry);
	  generic_bignum[i] = next & LITTLENUM_MASK;
	  carry = next >> LITTLENUM_NUMBER_OF_BITS;
	}

      /* We can ignore any carry out, because it will be handled by
	 extra_digit if it is needed.  */

      extra_digit = (valueT) -1;
      op = O_big;
    }

  if (op == O_absent || op == O_illegal)
    {
      as_warn (_("zero assumed for missing expression"));
      exp->X_add_number = 0;
      op = O_constant;
    }
  else if (op == O_big && exp->X_add_number <= 0)
    {
      as_bad (_("floating point number invalid"));
      exp->X_add_number = 0;
      op = O_constant;
    }
  else if (op == O_register)
    {
      as_warn (_("register value used as expression"));
      op = O_constant;
    }

  p = frag_more ((int) nbytes);

#ifndef WORKING_DOT_WORD
  /* If we have the difference of two symbols in a word, save it on
     the broken_words list.  See the code in write.c.  */
  if (op == O_subtract && nbytes == 2)
    {
      struct broken_word *x;

      x = (struct broken_word *) xmalloc (sizeof (struct broken_word));
      x->next_broken_word = broken_words;
      broken_words = x;
      x->seg = now_seg;
      x->subseg = now_subseg;
      x->frag = frag_now;
      x->word_goes_here = p;
      x->dispfrag = 0;
      x->add = exp->X_add_symbol;
      x->sub = exp->X_op_symbol;
      x->addnum = exp->X_add_number;
      x->added = 0;
      x->use_jump = 0;
      new_broken_words++;
      return;
    }
#endif

  /* If we have an integer, but the number of bytes is too large to
     pass to md_number_to_chars, handle it as a bignum.  */
  if (op == O_constant && nbytes > sizeof (valueT))
    {
      extra_digit = exp->X_unsigned ? 0 : -1;
      convert_to_bignum (exp, !exp->X_unsigned);
      op = O_big;
    }

  if (op == O_constant)
    {
      valueT get;
      valueT use;
      valueT mask;
      valueT hibit;
      valueT unmask;

      /* JF << of >= number of bits in the object is undefined.  In
	 particular SPARC (Sun 4) has problems.  */
      if (nbytes >= sizeof (valueT))
	{
	  mask = 0;
	  if (nbytes > sizeof (valueT))
	    hibit = 0;
	  else
	    hibit = (valueT) 1 << (nbytes * BITS_PER_CHAR - 1);
	}
      else
	{
	  /* Don't store these bits.  */
	  mask = ~(valueT) 0 << (BITS_PER_CHAR * nbytes);
	  hibit = (valueT) 1 << (nbytes * BITS_PER_CHAR - 1);
	}

      unmask = ~mask;		/* Do store these bits.  */

#ifdef NEVER
      "Do this mod if you want every overflow check to assume SIGNED 2's complement data.";
      mask = ~(unmask >> 1);	/* Includes sign bit now.  */
#endif

      get = exp->X_add_number;
      use = get & unmask;
      if ((get & mask) != 0
	  && ((get & mask) != mask
	      || (get & hibit) == 0))
	{		/* Leading bits contain both 0s & 1s.  */
#if defined (BFD64) && BFD_HOST_64BIT_LONG_LONG
#ifndef __MSVCRT__
	  as_warn (_("value 0x%llx truncated to 0x%llx"),
		   (unsigned long long) get, (unsigned long long) use);
#else
	  as_warn (_("value 0x%I64x truncated to 0x%I64x"),
		   (unsigned long long) get, (unsigned long long) use);
#endif
#else
	  as_warn (_("value 0x%lx truncated to 0x%lx"),
		   (unsigned long) get, (unsigned long) use);
#endif
	}
      /* Put bytes in right order.  */
      md_number_to_chars (p, use, (int) nbytes);
    }
  else if (op == O_big)
    {
      unsigned int size;
      LITTLENUM_TYPE *nums;

      size = exp->X_add_number * CHARS_PER_LITTLENUM;
      if (nbytes < size)
	{
	  int i = nbytes / CHARS_PER_LITTLENUM;
	  if (i != 0)
	    {
	      LITTLENUM_TYPE sign = 0;
	      if ((generic_bignum[--i]
		   & (1 << (LITTLENUM_NUMBER_OF_BITS - 1))) != 0)
		sign = ~(LITTLENUM_TYPE) 0;
	      while (++i < exp->X_add_number)
		if (generic_bignum[i] != sign)
		  break;
	    }
	  if (i < exp->X_add_number)
	    as_warn (_("bignum truncated to %d bytes"), nbytes);
	  size = nbytes;
	}

      if (nbytes == 1)
	{
	  md_number_to_chars (p, (valueT) generic_bignum[0], 1);
	  return;
	}
      know (nbytes % CHARS_PER_LITTLENUM == 0);

      if (target_big_endian)
	{
	  while (nbytes > size)
	    {
	      md_number_to_chars (p, extra_digit, CHARS_PER_LITTLENUM);
	      nbytes -= CHARS_PER_LITTLENUM;
	      p += CHARS_PER_LITTLENUM;
	    }

	  nums = generic_bignum + size / CHARS_PER_LITTLENUM;
	  while (size >= CHARS_PER_LITTLENUM)
	    {
	      --nums;
	      md_number_to_chars (p, (valueT) *nums, CHARS_PER_LITTLENUM);
	      size -= CHARS_PER_LITTLENUM;
	      p += CHARS_PER_LITTLENUM;
	    }
	}
      else
	{
	  nums = generic_bignum;
	  while (size >= CHARS_PER_LITTLENUM)
	    {
	      md_number_to_chars (p, (valueT) *nums, CHARS_PER_LITTLENUM);
	      ++nums;
	      size -= CHARS_PER_LITTLENUM;
	      p += CHARS_PER_LITTLENUM;
	      nbytes -= CHARS_PER_LITTLENUM;
	    }

	  while (nbytes >= CHARS_PER_LITTLENUM)
	    {
	      md_number_to_chars (p, extra_digit, CHARS_PER_LITTLENUM);
	      nbytes -= CHARS_PER_LITTLENUM;
	      p += CHARS_PER_LITTLENUM;
	    }
	}
    }
  else
    emit_expr_fix (exp, nbytes, frag_now, p);
}

void
emit_expr_fix (expressionS *exp, unsigned int nbytes, fragS *frag, char *p)
{
  memset (p, 0, nbytes);

  /* Generate a fixS to record the symbol value.  */

#ifdef TC_CONS_FIX_NEW
  TC_CONS_FIX_NEW (frag, p - frag->fr_literal, nbytes, exp);
#else
  {
    bfd_reloc_code_real_type r;

    switch (nbytes)
      {
      case 1:
	r = BFD_RELOC_8;
	break;
      case 2:
	r = BFD_RELOC_16;
	break;
      case 3:
	r = BFD_RELOC_24;
	break;
      case 4:
	r = BFD_RELOC_32;
	break;
      case 8:
	r = BFD_RELOC_64;
	break;
      default:
	as_bad (_("unsupported BFD relocation size %u"), nbytes);
	r = BFD_RELOC_32;
	break;
      }
    fix_new_exp (frag, p - frag->fr_literal, (int) nbytes, exp,
		 0, r);
  }
#endif
}

#ifdef BITFIELD_CONS_EXPRESSIONS

/* i960 assemblers, (eg, asm960), allow bitfields after ".byte" as
   w:x,y:z, where w and y are bitwidths and x and y are values.  They
   then pack them all together. We do a little better in that we allow
   them in words, longs, etc. and we'll pack them in target byte order
   for you.

   The rules are: pack least significant bit first, if a field doesn't
   entirely fit, put it in the next unit.  Overflowing the bitfield is
   explicitly *not* even a warning.  The bitwidth should be considered
   a "mask".

   To use this function the tc-XXX.h file should define
   BITFIELD_CONS_EXPRESSIONS.  */

static void
parse_bitfield_cons (exp, nbytes)
     expressionS *exp;
     unsigned int nbytes;
{
  unsigned int bits_available = BITS_PER_CHAR * nbytes;
  char *hold = input_line_pointer;

  (void) expression (exp);

  if (*input_line_pointer == ':')
    {
      /* Bitfields.  */
      long value = 0;

      for (;;)
	{
	  unsigned long width;

	  if (*input_line_pointer != ':')
	    {
	      input_line_pointer = hold;
	      break;
	    }			/* Next piece is not a bitfield.  */

	  /* In the general case, we can't allow
	     full expressions with symbol
	     differences and such.  The relocation
	     entries for symbols not defined in this
	     assembly would require arbitrary field
	     widths, positions, and masks which most
	     of our current object formats don't
	     support.

	     In the specific case where a symbol
	     *is* defined in this assembly, we
	     *could* build fixups and track it, but
	     this could lead to confusion for the
	     backends.  I'm lazy. I'll take any
	     SEG_ABSOLUTE. I think that means that
	     you can use a previous .set or
	     .equ type symbol.  xoxorich.  */

	  if (exp->X_op == O_absent)
	    {
	      as_warn (_("using a bit field width of zero"));
	      exp->X_add_number = 0;
	      exp->X_op = O_constant;
	    }			/* Implied zero width bitfield.  */

	  if (exp->X_op != O_constant)
	    {
	      *input_line_pointer = '\0';
	      as_bad (_("field width \"%s\" too complex for a bitfield"), hold);
	      *input_line_pointer = ':';
	      demand_empty_rest_of_line ();
	      return;
	    }			/* Too complex.  */

	  if ((width = exp->X_add_number) > (BITS_PER_CHAR * nbytes))
	    {
	      as_warn (_("field width %lu too big to fit in %d bytes: truncated to %d bits"),
		       width, nbytes, (BITS_PER_CHAR * nbytes));
	      width = BITS_PER_CHAR * nbytes;
	    }			/* Too big.  */

	  if (width > bits_available)
	    {
	      /* FIXME-SOMEDAY: backing up and reparsing is wasteful.  */
	      input_line_pointer = hold;
	      exp->X_add_number = value;
	      break;
	    }			/* Won't fit.  */

	  /* Skip ':'.  */
	  hold = ++input_line_pointer;

	  (void) expression (exp);
	  if (exp->X_op != O_constant)
	    {
	      char cache = *input_line_pointer;

	      *input_line_pointer = '\0';
	      as_bad (_("field value \"%s\" too complex for a bitfield"), hold);
	      *input_line_pointer = cache;
	      demand_empty_rest_of_line ();
	      return;
	    }			/* Too complex.  */

	  value |= ((~(-1 << width) & exp->X_add_number)
		    << ((BITS_PER_CHAR * nbytes) - bits_available));

	  if ((bits_available -= width) == 0
	      || is_it_end_of_statement ()
	      || *input_line_pointer != ',')
	    {
	      break;
	    }			/* All the bitfields we're gonna get.  */

	  hold = ++input_line_pointer;
	  (void) expression (exp);
	}

      exp->X_add_number = value;
      exp->X_op = O_constant;
      exp->X_unsigned = 1;
      exp->X_extrabit = 0;
    }
}

#endif /* BITFIELD_CONS_EXPRESSIONS */

/* Handle an MRI style string expression.  */

#ifdef TC_M68K
static void
parse_mri_cons (exp, nbytes)
     expressionS *exp;
     unsigned int nbytes;
{
  if (*input_line_pointer != '\''
      && (input_line_pointer[1] != '\''
	  || (*input_line_pointer != 'A'
	      && *input_line_pointer != 'E')))
    TC_PARSE_CONS_EXPRESSION (exp, nbytes);
  else
    {
      unsigned int scan;
      unsigned int result = 0;

      /* An MRI style string.  Cut into as many bytes as will fit into
	 a nbyte chunk, left justify if necessary, and separate with
	 commas so we can try again later.  */
      if (*input_line_pointer == 'A')
	++input_line_pointer;
      else if (*input_line_pointer == 'E')
	{
	  as_bad (_("EBCDIC constants are not supported"));
	  ++input_line_pointer;
	}

      input_line_pointer++;
      for (scan = 0; scan < nbytes; scan++)
	{
	  if (*input_line_pointer == '\'')
	    {
	      if (input_line_pointer[1] == '\'')
		{
		  input_line_pointer++;
		}
	      else
		break;
	    }
	  result = (result << 8) | (*input_line_pointer++);
	}

      /* Left justify.  */
      while (scan < nbytes)
	{
	  result <<= 8;
	  scan++;
	}

      /* Create correct expression.  */
      exp->X_op = O_constant;
      exp->X_add_number = result;

      /* Fake it so that we can read the next char too.  */
      if (input_line_pointer[0] != '\'' ||
	  (input_line_pointer[0] == '\'' && input_line_pointer[1] == '\''))
	{
	  input_line_pointer -= 2;
	  input_line_pointer[0] = ',';
	  input_line_pointer[1] = '\'';
	}
      else
	input_line_pointer++;
    }
}
#endif /* TC_M68K */

#ifdef REPEAT_CONS_EXPRESSIONS

/* Parse a repeat expression for cons.  This is used by the MIPS
   assembler.  The format is NUMBER:COUNT; NUMBER appears in the
   object file COUNT times.

   To use this for a target, define REPEAT_CONS_EXPRESSIONS.  */

static void
parse_repeat_cons (exp, nbytes)
     expressionS *exp;
     unsigned int nbytes;
{
  expressionS count;
  int i;

  expression (exp);

  if (*input_line_pointer != ':')
    {
      /* No repeat count.  */
      return;
    }

  ++input_line_pointer;
  expression (&count);
  if (count.X_op != O_constant
      || count.X_add_number <= 0)
    {
      as_warn (_("unresolvable or nonpositive repeat count; using 1"));
      return;
    }

  /* The cons function is going to output this expression once.  So we
     output it count - 1 times.  */
  for (i = count.X_add_number - 1; i > 0; i--)
    emit_expr (exp, nbytes);
}

#endif /* REPEAT_CONS_EXPRESSIONS */

/* Parse a floating point number represented as a hex constant.  This
   permits users to specify the exact bits they want in the floating
   point number.  */

static int
hex_float (int float_type, char *bytes)
{
  int length;
  int i;

  switch (float_type)
    {
    case 'f':
    case 'F':
    case 's':
    case 'S':
      length = 4;
      break;

    case 'd':
    case 'D':
    case 'r':
    case 'R':
      length = 8;
      break;

    case 'x':
    case 'X':
      length = 12;
      break;

    case 'p':
    case 'P':
      length = 12;
      break;

    default:
      as_bad (_("unknown floating type type '%c'"), float_type);
      return -1;
    }

  /* It would be nice if we could go through expression to parse the
     hex constant, but if we get a bignum it's a pain to sort it into
     the buffer correctly.  */
  i = 0;
  while (hex_p (*input_line_pointer) || *input_line_pointer == '_')
    {
      int d;

      /* The MRI assembler accepts arbitrary underscores strewn about
	 through the hex constant, so we ignore them as well.  */
      if (*input_line_pointer == '_')
	{
	  ++input_line_pointer;
	  continue;
	}

      if (i >= length)
	{
	  as_warn (_("floating point constant too large"));
	  return -1;
	}
      d = hex_value (*input_line_pointer) << 4;
      ++input_line_pointer;
      while (*input_line_pointer == '_')
	++input_line_pointer;
      if (hex_p (*input_line_pointer))
	{
	  d += hex_value (*input_line_pointer);
	  ++input_line_pointer;
	}
      if (target_big_endian)
	bytes[i] = d;
      else
	bytes[length - i - 1] = d;
      ++i;
    }

  if (i < length)
    {
      if (target_big_endian)
	memset (bytes + i, 0, length - i);
      else
	memset (bytes, 0, length - i);
    }

  return length;
}

/*			float_cons()

   CONStruct some more frag chars of .floats .ffloats etc.
   Makes 0 or more new frags.
   If need_pass_2 == 1, no frags are emitted.
   This understands only floating literals, not expressions. Sorry.

   A floating constant is defined by atof_generic(), except it is preceded
   by 0d 0f 0g or 0h. After observing the STRANGE way my BSD AS does its
   reading, I decided to be incompatible. This always tries to give you
   rounded bits to the precision of the pseudo-op. Former AS did premature
   truncation, restored noisy bits instead of trailing 0s AND gave you
   a choice of 2 flavours of noise according to which of 2 floating-point
   scanners you directed AS to use.

   In:	input_line_pointer->whitespace before, or '0' of flonum.  */

void
float_cons (/* Clobbers input_line-pointer, checks end-of-line.  */
	    int float_type	/* 'f':.ffloat ... 'F':.float ...  */)
{
  char *p;
  int length;			/* Number of chars in an object.  */
  char *err;		/* Error from scanning floating literal.  */
  char temp[MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT];

  if (is_it_end_of_statement ())
    {
      demand_empty_rest_of_line ();
      return;
    }

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

#ifdef md_cons_align
  md_cons_align (1);
#endif

  do
    {
      /* input_line_pointer->1st char of a flonum (we hope!).  */
      SKIP_WHITESPACE ();

      /* Skip any 0{letter} that may be present. Don't even check if the
	 letter is legal. Someone may invent a "z" format and this routine
	 has no use for such information. Lusers beware: you get
	 diagnostics if your input is ill-conditioned.  */
      if (input_line_pointer[0] == '0'
	  && ISALPHA (input_line_pointer[1]))
	input_line_pointer += 2;

      /* Accept :xxxx, where the x's are hex digits, for a floating
	 point with the exact digits specified.  */
      if (input_line_pointer[0] == ':')
	{
	  ++input_line_pointer;
	  length = hex_float (float_type, temp);
	  if (length < 0)
	    {
	      ignore_rest_of_line ();
	      return;
	    }
	}
      else
	{
	  err = md_atof (float_type, temp, &length);
	  know (length <= MAXIMUM_NUMBER_OF_CHARS_FOR_FLOAT);
	  know (err != NULL || length > 0);
	  if (err)
	    {
	      as_bad (_("bad floating literal: %s"), err);
	      ignore_rest_of_line ();
	      return;
	    }
	}

      if (!need_pass_2)
	{
	  int count;

	  count = 1;

#ifdef REPEAT_CONS_EXPRESSIONS
	  if (*input_line_pointer == ':')
	    {
	      expressionS count_exp;

	      ++input_line_pointer;
	      expression (&count_exp);

	      if (count_exp.X_op != O_constant
		  || count_exp.X_add_number <= 0)
		as_warn (_("unresolvable or nonpositive repeat count; using 1"));
	      else
		count = count_exp.X_add_number;
	    }
#endif

	  while (--count >= 0)
	    {
	      p = frag_more (length);
	      memcpy (p, temp, (unsigned int) length);
	    }
	}
      SKIP_WHITESPACE ();
    }
  while (*input_line_pointer++ == ',');

  /* Put terminator back into stream.  */
  --input_line_pointer;
  demand_empty_rest_of_line ();
}

/* Return the size of a LEB128 value.  */

static inline int
sizeof_sleb128 (offsetT value)
{
  int size = 0;
  unsigned byte;

  do
    {
      byte = (value & 0x7f);
      /* Sadly, we cannot rely on typical arithmetic right shift behaviour.
	 Fortunately, we can structure things so that the extra work reduces
	 to a noop on systems that do things "properly".  */
      value = (value >> 7) | ~(-(offsetT)1 >> 7);
      size += 1;
    }
  while (!(((value == 0) && ((byte & 0x40) == 0))
	   || ((value == -1) && ((byte & 0x40) != 0))));

  return size;
}

static inline int
sizeof_uleb128 (valueT value)
{
  int size = 0;

  do
    {
      value >>= 7;
      size += 1;
    }
  while (value != 0);

  return size;
}

int
sizeof_leb128 (valueT value, int sign)
{
  if (sign)
    return sizeof_sleb128 ((offsetT) value);
  else
    return sizeof_uleb128 (value);
}

/* Output a LEB128 value.  */

static inline int
output_sleb128 (char *p, offsetT value)
{
  char *orig = p;
  int more;

  do
    {
      unsigned byte = (value & 0x7f);

      /* Sadly, we cannot rely on typical arithmetic right shift behaviour.
	 Fortunately, we can structure things so that the extra work reduces
	 to a noop on systems that do things "properly".  */
      value = (value >> 7) | ~(-(offsetT)1 >> 7);

      more = !((((value == 0) && ((byte & 0x40) == 0))
		|| ((value == -1) && ((byte & 0x40) != 0))));
      if (more)
	byte |= 0x80;

      *p++ = byte;
    }
  while (more);

  return p - orig;
}

static inline int
output_uleb128 (char *p, valueT value)
{
  char *orig = p;

  do
    {
      unsigned byte = (value & 0x7f);
      value >>= 7;
      if (value != 0)
	/* More bytes to follow.  */
	byte |= 0x80;

      *p++ = byte;
    }
  while (value != 0);

  return p - orig;
}

int
output_leb128 (char *p, valueT value, int sign)
{
  if (sign)
    return output_sleb128 (p, (offsetT) value);
  else
    return output_uleb128 (p, value);
}

/* Do the same for bignums.  We combine sizeof with output here in that
   we don't output for NULL values of P.  It isn't really as critical as
   for "normal" values that this be streamlined.  */

static inline int
output_big_sleb128 (char *p, LITTLENUM_TYPE *bignum, int size)
{
  char *orig = p;
  valueT val = 0;
  int loaded = 0;
  unsigned byte;

  /* Strip leading sign extensions off the bignum.  */
  while (size > 1
	 && bignum[size - 1] == LITTLENUM_MASK
	 && bignum[size - 2] > LITTLENUM_MASK / 2)
    size--;

  do
    {
      /* OR in the next part of the littlenum.  */
      val |= (*bignum << loaded);
      loaded += LITTLENUM_NUMBER_OF_BITS;
      size--;
      bignum++;

      /* Add bytes until there are less than 7 bits left in VAL
	 or until every non-sign bit has been written.  */
      do
	{
	  byte = val & 0x7f;
	  loaded -= 7;
	  val >>= 7;
	  if (size > 0
	      || val != ((byte & 0x40) == 0 ? 0 : ((valueT) 1 << loaded) - 1))
	    byte |= 0x80;

	  if (orig)
	    *p = byte;
	  p++;
	}
      while ((byte & 0x80) != 0 && loaded >= 7);
    }
  while (size > 0);

  /* Mop up any left-over bits (of which there will be less than 7).  */
  if ((byte & 0x80) != 0)
    {
      /* Sign-extend VAL.  */
      if (val & (1 << (loaded - 1)))
	val |= ~0 << loaded;
      if (orig)
	*p = val & 0x7f;
      p++;
    }

  return p - orig;
}

static inline int
output_big_uleb128 (char *p, LITTLENUM_TYPE *bignum, int size)
{
  char *orig = p;
  valueT val = 0;
  int loaded = 0;
  unsigned byte;

  /* Strip leading zeros off the bignum.  */
  /* XXX: Is this needed?  */
  while (size > 0 && bignum[size - 1] == 0)
    size--;

  do
    {
      if (loaded < 7 && size > 0)
	{
	  val |= (*bignum << loaded);
	  loaded += 8 * CHARS_PER_LITTLENUM;
	  size--;
	  bignum++;
	}

      byte = val & 0x7f;
      loaded -= 7;
      val >>= 7;

      if (size > 0 || val)
	byte |= 0x80;

      if (orig)
	*p = byte;
      p++;
    }
  while (byte & 0x80);

  return p - orig;
}

static int
output_big_leb128 (char *p, LITTLENUM_TYPE *bignum, int size, int sign)
{
  if (sign)
    return output_big_sleb128 (p, bignum, size);
  else
    return output_big_uleb128 (p, bignum, size);
}

/* Generate the appropriate fragments for a given expression to emit a
   leb128 value.  */

static void
emit_leb128_expr (expressionS *exp, int sign)
{
  operatorT op = exp->X_op;
  unsigned int nbytes;

  if (op == O_absent || op == O_illegal)
    {
      as_warn (_("zero assumed for missing expression"));
      exp->X_add_number = 0;
      op = O_constant;
    }
  else if (op == O_big && exp->X_add_number <= 0)
    {
      as_bad (_("floating point number invalid"));
      exp->X_add_number = 0;
      op = O_constant;
    }
  else if (op == O_register)
    {
      as_warn (_("register value used as expression"));
      op = O_constant;
    }
  else if (op == O_constant
	   && sign
	   && (exp->X_add_number < 0) == !exp->X_extrabit)
    {
      /* We're outputting a signed leb128 and the sign of X_add_number
	 doesn't reflect the sign of the original value.  Convert EXP
	 to a correctly-extended bignum instead.  */
      convert_to_bignum (exp, exp->X_extrabit);
      op = O_big;
    }

  /* Let check_eh_frame know that data is being emitted.  nbytes == -1 is
     a signal that this is leb128 data.  It shouldn't optimize this away.  */
  nbytes = (unsigned int) -1;
  if (check_eh_frame (exp, &nbytes))
    abort ();

  /* Let the backend know that subsequent data may be byte aligned.  */
#ifdef md_cons_align
  md_cons_align (1);
#endif

  if (op == O_constant)
    {
      /* If we've got a constant, emit the thing directly right now.  */

      valueT value = exp->X_add_number;
      int size;
      char *p;

      size = sizeof_leb128 (value, sign);
      p = frag_more (size);
      output_leb128 (p, value, sign);
    }
  else if (op == O_big)
    {
      /* O_big is a different sort of constant.  */

      int size;
      char *p;

      size = output_big_leb128 (NULL, generic_bignum, exp->X_add_number, sign);
      p = frag_more (size);
      output_big_leb128 (p, generic_bignum, exp->X_add_number, sign);
    }
  else
    {
      /* Otherwise, we have to create a variable sized fragment and
	 resolve things later.  */

      frag_var (rs_leb128, sizeof_uleb128 (~(valueT) 0), 0, sign,
		make_expr_symbol (exp), 0, (char *) NULL);
    }
}

/* Parse the .sleb128 and .uleb128 pseudos.  */

void
s_leb128 (int sign)
{
  expressionS exp;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

  do
    {
      expression (&exp);
      emit_leb128_expr (&exp, sign);
    }
  while (*input_line_pointer++ == ',');

  input_line_pointer--;
  demand_empty_rest_of_line ();
}

static void
stringer_append_char (int c, int bitsize)
{
  if (!target_big_endian)
    FRAG_APPEND_1_CHAR (c);

  switch (bitsize)
    {
    case 64:
      FRAG_APPEND_1_CHAR (0);
      FRAG_APPEND_1_CHAR (0);
      FRAG_APPEND_1_CHAR (0);
      FRAG_APPEND_1_CHAR (0);
      /* Fall through.  */
    case 32:
      FRAG_APPEND_1_CHAR (0);
      FRAG_APPEND_1_CHAR (0);
      /* Fall through.  */
    case 16:
      FRAG_APPEND_1_CHAR (0);
      /* Fall through.  */
    case 8:
      break;
    default:
      /* Called with invalid bitsize argument.  */
      abort ();
      break;
    }
  if (target_big_endian)
    FRAG_APPEND_1_CHAR (c);
}

/* Worker to do .ascii etc statements.
   Reads 0 or more ',' separated, double-quoted strings.
   Caller should have checked need_pass_2 is FALSE because we don't
   check it.
   Checks for end-of-line.
   BITS_APPENDZERO says how many bits are in a target char.
   The bottom bit is set if a NUL char should be appended to the strings.  */

void
stringer (int bits_appendzero)
{
  const int bitsize = bits_appendzero & ~7;
  const int append_zero = bits_appendzero & 1;
  unsigned int c;
#if !defined(NO_LISTING) && defined (OBJ_ELF)
  char *start;
#endif

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

#ifdef md_cons_align
  md_cons_align (1);
#endif

  /* The following awkward logic is to parse ZERO or more strings,
     comma separated. Recall a string expression includes spaces
     before the opening '\"' and spaces after the closing '\"'.
     We fake a leading ',' if there is (supposed to be)
     a 1st, expression. We keep demanding expressions for each ','.  */
  if (is_it_end_of_statement ())
    {
      c = 0;			/* Skip loop.  */
      ++input_line_pointer;	/* Compensate for end of loop.  */
    }
  else
    {
      c = ',';			/* Do loop.  */
    }
  /* If we have been switched into the abs_section then we
     will not have an obstack onto which we can hang strings.  */
  if (now_seg == absolute_section)
    {
      as_bad (_("strings must be placed into a section"));
      c = 0;
      ignore_rest_of_line ();
    }

  while (c == ',' || c == '<' || c == '"')
    {
      SKIP_WHITESPACE ();
      switch (*input_line_pointer)
	{
	case '\"':
	  ++input_line_pointer;	/*->1st char of string.  */
#if !defined(NO_LISTING) && defined (OBJ_ELF)
	  start = input_line_pointer;
#endif

	  while (is_a_char (c = next_char_of_string ()))
	    stringer_append_char (c, bitsize);

	  if (append_zero)
	    stringer_append_char (0, bitsize);

	  know (input_line_pointer[-1] == '\"');

#if !defined(NO_LISTING) && defined (OBJ_ELF)
	  /* In ELF, when gcc is emitting DWARF 1 debugging output, it
	     will emit .string with a filename in the .debug section
	     after a sequence of constants.  See the comment in
	     emit_expr for the sequence.  emit_expr will set
	     dwarf_file_string to non-zero if this string might be a
	     source file name.  */
	  if (strcmp (segment_name (now_seg), ".debug") != 0)
	    dwarf_file_string = 0;
	  else if (dwarf_file_string)
	    {
	      c = input_line_pointer[-1];
	      input_line_pointer[-1] = '\0';
	      listing_source_file (start);
	      input_line_pointer[-1] = c;
	    }
#endif

	  break;
	case '<':
	  input_line_pointer++;
	  c = get_single_number ();
	  stringer_append_char (c, bitsize);
	  if (*input_line_pointer != '>')
	    as_bad (_("expected <nn>"));

	  input_line_pointer++;
	  break;
	case ',':
	  input_line_pointer++;
	  break;
	}
      SKIP_WHITESPACE ();
      c = *input_line_pointer;
    }

  demand_empty_rest_of_line ();
}

/* FIXME-SOMEDAY: I had trouble here on characters with the
    high bits set.  We'll probably also have trouble with
    multibyte chars, wide chars, etc.  Also be careful about
    returning values bigger than 1 byte.  xoxorich.  */

unsigned int
next_char_of_string (void)
{
  unsigned int c;

  c = *input_line_pointer++ & CHAR_MASK;
  switch (c)
    {
    case '\"':
      c = NOT_A_CHAR;
      break;

    case '\n':
      as_warn (_("unterminated string; newline inserted"));
      bump_line_counters ();
      break;

#ifndef NO_STRING_ESCAPES
    case '\\':
      switch (c = *input_line_pointer++)
	{
	case 'b':
	  c = '\b';
	  break;

	case 'f':
	  c = '\f';
	  break;

	case 'n':
	  c = '\n';
	  break;

	case 'r':
	  c = '\r';
	  break;

	case 't':
	  c = '\t';
	  break;

	case 'v':
	  c = '\013';
	  break;

	case '\\':
	case '"':
	  break;		/* As itself.  */

	case '0':
	case '1':
	case '2':
	case '3':
	case '4':
	case '5':
	case '6':
	case '7':
	case '8':
	case '9':
	  {
	    long number;
	    int i;

	    for (i = 0, number = 0;
		 ISDIGIT (c) && i < 3;
		 c = *input_line_pointer++, i++)
	      {
		number = number * 8 + c - '0';
	      }

	    c = number & 0xff;
	  }
	  --input_line_pointer;
	  break;

	case 'x':
	case 'X':
	  {
	    long number;

	    number = 0;
	    c = *input_line_pointer++;
	    while (ISXDIGIT (c))
	      {
		if (ISDIGIT (c))
		  number = number * 16 + c - '0';
		else if (ISUPPER (c))
		  number = number * 16 + c - 'A' + 10;
		else
		  number = number * 16 + c - 'a' + 10;
		c = *input_line_pointer++;
	      }
	    c = number & 0xff;
	    --input_line_pointer;
	  }
	  break;

	case '\n':
	  /* To be compatible with BSD 4.2 as: give the luser a linefeed!!  */
	  as_warn (_("unterminated string; newline inserted"));
	  c = '\n';
	  bump_line_counters ();
	  break;

	default:

#ifdef ONLY_STANDARD_ESCAPES
	  as_bad (_("bad escaped character in string"));
	  c = '?';
#endif /* ONLY_STANDARD_ESCAPES */

	  break;
	}
      break;
#endif /* ! defined (NO_STRING_ESCAPES) */

    default:
      break;
    }
  return (c);
}

static segT
get_segmented_expression (expressionS *expP)
{
  segT retval;

  retval = expression (expP);
  if (expP->X_op == O_illegal
      || expP->X_op == O_absent
      || expP->X_op == O_big)
    {
      as_bad (_("expected address expression"));
      expP->X_op = O_constant;
      expP->X_add_number = 0;
      retval = absolute_section;
    }
  return retval;
}

static segT
get_known_segmented_expression (expressionS *expP)
{
  segT retval = get_segmented_expression (expP);

  if (retval == undefined_section)
    {
      /* There is no easy way to extract the undefined symbol from the
	 expression.  */
      if (expP->X_add_symbol != NULL
	  && S_GET_SEGMENT (expP->X_add_symbol) != expr_section)
	as_warn (_("symbol \"%s\" undefined; zero assumed"),
		 S_GET_NAME (expP->X_add_symbol));
      else
	as_warn (_("some symbol undefined; zero assumed"));
      retval = absolute_section;
      expP->X_op = O_constant;
      expP->X_add_number = 0;
    }
  return retval;
}

char				/* Return terminator.  */
get_absolute_expression_and_terminator (long *val_pointer /* Return value of expression.  */)
{
  /* FIXME: val_pointer should probably be offsetT *.  */
  *val_pointer = (long) get_absolute_expression ();
  return (*input_line_pointer++);
}

/* Like demand_copy_string, but return NULL if the string contains any '\0's.
   Give a warning if that happens.  */

char *
demand_copy_C_string (int *len_pointer)
{
  char *s;

  if ((s = demand_copy_string (len_pointer)) != 0)
    {
      int len;

      for (len = *len_pointer; len > 0; len--)
	{
	  if (*s == 0)
	    {
	      s = 0;
	      len = 1;
	      *len_pointer = 0;
	      as_bad (_("this string may not contain \'\\0\'"));
	    }
	}
    }

  return s;
}

/* Demand string, but return a safe (=private) copy of the string.
   Return NULL if we can't read a string here.  */

char *
demand_copy_string (int *lenP)
{
  unsigned int c;
  int len;
  char *retval;

  len = 0;
  SKIP_WHITESPACE ();
  if (*input_line_pointer == '\"')
    {
      input_line_pointer++;	/* Skip opening quote.  */

      while (is_a_char (c = next_char_of_string ()))
	{
	  obstack_1grow (&notes, c);
	  len++;
	}
      /* JF this next line is so demand_copy_C_string will return a
	 null terminated string.  */
      obstack_1grow (&notes, '\0');
      retval = (char *) obstack_finish (&notes);
    }
  else
    {
      as_bad (_("missing string"));
      retval = NULL;
      ignore_rest_of_line ();
    }
  *lenP = len;
  return (retval);
}

/* In:	Input_line_pointer->next character.

   Do:	Skip input_line_pointer over all whitespace.

   Out:	1 if input_line_pointer->end-of-line.  */

int
is_it_end_of_statement (void)
{
  SKIP_WHITESPACE ();
  return (is_end_of_line[(unsigned char) *input_line_pointer]);
}

void
equals (char *sym_name, int reassign)
{
  char *stop = NULL;
  char stopc = 0;

  input_line_pointer++;
  if (*input_line_pointer == '=')
    input_line_pointer++;
  if (reassign < 0 && *input_line_pointer == '=')
    input_line_pointer++;

  while (*input_line_pointer == ' ' || *input_line_pointer == '\t')
    input_line_pointer++;

  if (flag_mri)
    stop = mri_comment_field (&stopc);

  assign_symbol (sym_name, reassign >= 0 ? !reassign : reassign);

  if (flag_mri)
    {
      demand_empty_rest_of_line ();
      mri_comment_end (stop, stopc);
    }
}

/* .incbin -- include a file verbatim at the current location.  */

void
s_incbin (int x ATTRIBUTE_UNUSED)
{
  FILE * binfile;
  char * path;
  char * filename;
  char * binfrag;
  long   skip = 0;
  long   count = 0;
  long   bytes;
  int    len;

#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

#ifdef md_cons_align
  md_cons_align (1);
#endif

  SKIP_WHITESPACE ();
  filename = demand_copy_string (& len);
  if (filename == NULL)
    return;

  SKIP_WHITESPACE ();

  /* Look for optional skip and count.  */
  if (* input_line_pointer == ',')
    {
      ++ input_line_pointer;
      skip = get_absolute_expression ();

      SKIP_WHITESPACE ();

      if (* input_line_pointer == ',')
	{
	  ++ input_line_pointer;

	  count = get_absolute_expression ();
	  if (count == 0)
	    as_warn (_(".incbin count zero, ignoring `%s'"), filename);

	  SKIP_WHITESPACE ();
	}
    }

  demand_empty_rest_of_line ();

  /* Try opening absolute path first, then try include dirs.  */
  binfile = fopen (filename, FOPEN_RB);
  if (binfile == NULL)
    {
      int i;

      path = (char *) xmalloc ((unsigned long) len + include_dir_maxlen + 5);

      for (i = 0; i < include_dir_count; i++)
	{
	  sprintf (path, "%s/%s", include_dirs[i], filename);

	  binfile = fopen (path, FOPEN_RB);
	  if (binfile != NULL)
	    break;
	}

      if (binfile == NULL)
	as_bad (_("file not found: %s"), filename);
    }
  else
    path = xstrdup (filename);

  if (binfile)
    {
      long   file_len;

      register_dependency (path);

      /* Compute the length of the file.  */
      if (fseek (binfile, 0, SEEK_END) != 0)
	{
	  as_bad (_("seek to end of .incbin file failed `%s'"), path);
	  goto done;
	}
      file_len = ftell (binfile);

      /* If a count was not specified use the remainder of the file.  */
      if (count == 0)
	count = file_len - skip;

      if (skip < 0 || count < 0 || file_len < 0 || skip + count > file_len)
	{
	  as_bad (_("skip (%ld) or count (%ld) invalid for file size (%ld)"),
		  skip, count, file_len);
	  goto done;
	}

      if (fseek (binfile, skip, SEEK_SET) != 0)
	{
	  as_bad (_("could not skip to %ld in file `%s'"), skip, path);
	  goto done;
	}

      /* Allocate frag space and store file contents in it.  */
      binfrag = frag_more (count);

      bytes = fread (binfrag, 1, count, binfile);
      if (bytes < count)
	as_warn (_("truncated file `%s', %ld of %ld bytes read"),
		 path, bytes, count);
    }
done:
  if (binfile != NULL)
    fclose (binfile);
  if (path)
    free (path);
}

/* .include -- include a file at this point.  */

void
s_include (int arg ATTRIBUTE_UNUSED)
{
  char *filename;
  int i;
  FILE *try_file;
  char *path;

  if (!flag_m68k_mri)
    {
      filename = demand_copy_string (&i);
      if (filename == NULL)
	{
	  /* demand_copy_string has already printed an error and
	     called ignore_rest_of_line.  */
	  return;
	}
    }
  else
    {
      SKIP_WHITESPACE ();
      i = 0;
      while (!is_end_of_line[(unsigned char) *input_line_pointer]
	     && *input_line_pointer != ' '
	     && *input_line_pointer != '\t')
	{
	  obstack_1grow (&notes, *input_line_pointer);
	  ++input_line_pointer;
	  ++i;
	}

      obstack_1grow (&notes, '\0');
      filename = (char *) obstack_finish (&notes);
      while (!is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
    }

  demand_empty_rest_of_line ();
  path = (char *) xmalloc ((unsigned long) i
			   + include_dir_maxlen + 5 /* slop */ );

  for (i = 0; i < include_dir_count; i++)
    {
      strcpy (path, include_dirs[i]);
      strcat (path, "/");
      strcat (path, filename);
      if (0 != (try_file = fopen (path, FOPEN_RT)))
	{
	  fclose (try_file);
	  goto gotit;
	}
    }

  free (path);
  path = filename;
gotit:
  /* malloc Storage leak when file is found on path.  FIXME-SOMEDAY.  */
  register_dependency (path);
  input_scrub_insert_file (path);
}

void
add_include_dir (char *path)
{
  int i;

  if (include_dir_count == 0)
    {
      include_dirs = (char **) xmalloc (2 * sizeof (*include_dirs));
      include_dirs[0] = ".";	/* Current dir.  */
      include_dir_count = 2;
    }
  else
    {
      include_dir_count++;
      include_dirs =
	(char **) xrealloc (include_dirs,
			    include_dir_count * sizeof (*include_dirs));
    }

  include_dirs[include_dir_count - 1] = path;	/* New one.  */

  i = strlen (path);
  if (i > include_dir_maxlen)
    include_dir_maxlen = i;
}

/* Output debugging information to denote the source file.  */

static void
generate_file_debug (void)
{
  if (debug_type == DEBUG_STABS)
    stabs_generate_asm_file ();
}

/* Output line number debugging information for the current source line.  */

void
generate_lineno_debug (void)
{
  switch (debug_type)
    {
    case DEBUG_UNSPECIFIED:
    case DEBUG_NONE:
    case DEBUG_DWARF:
      break;
    case DEBUG_STABS:
      stabs_generate_asm_lineno ();
      break;
    case DEBUG_ECOFF:
      ecoff_generate_asm_lineno ();
      break;
    case DEBUG_DWARF2:
      /* ??? We could here indicate to dwarf2dbg.c that something
	 has changed.  However, since there is additional backend
	 support that is required (calling dwarf2_emit_insn), we
	 let dwarf2dbg.c call as_where on its own.  */
      break;
    }
}

/* Output debugging information to mark a function entry point or end point.
   END_P is zero for .func, and non-zero for .endfunc.  */

void
s_func (int end_p)
{
  do_s_func (end_p, NULL);
}

/* Subroutine of s_func so targets can choose a different default prefix.
   If DEFAULT_PREFIX is NULL, use the target's "leading char".  */

static void
do_s_func (int end_p, const char *default_prefix)
{
  /* Record the current function so that we can issue an error message for
     misplaced .func,.endfunc, and also so that .endfunc needs no
     arguments.  */
  static char *current_name;
  static char *current_label;

  if (end_p)
    {
      if (current_name == NULL)
	{
	  as_bad (_("missing .func"));
	  ignore_rest_of_line ();
	  return;
	}

      if (debug_type == DEBUG_STABS)
	stabs_generate_asm_endfunc (current_name, current_label);

      current_name = current_label = NULL;
    }
  else /* ! end_p */
    {
      char *name, *label;
      char delim1, delim2;

      if (current_name != NULL)
	{
	  as_bad (_(".endfunc missing for previous .func"));
	  ignore_rest_of_line ();
	  return;
	}

      name = input_line_pointer;
      delim1 = get_symbol_end ();
      name = xstrdup (name);
      *input_line_pointer = delim1;
      SKIP_WHITESPACE ();
      if (*input_line_pointer != ',')
	{
	  if (default_prefix)
	    {
	      if (asprintf (&label, "%s%s", default_prefix, name) == -1)
		as_fatal ("%s", xstrerror (errno));
	    }
	  else
	    {
	      char leading_char = bfd_get_symbol_leading_char (stdoutput);
	      /* Missing entry point, use function's name with the leading
		 char prepended.  */
	      if (leading_char)
		{
		  if (asprintf (&label, "%c%s", leading_char, name) == -1)
		    as_fatal ("%s", xstrerror (errno));
		}
	      else
		label = name;
	    }
	}
      else
	{
	  ++input_line_pointer;
	  SKIP_WHITESPACE ();
	  label = input_line_pointer;
	  delim2 = get_symbol_end ();
	  label = xstrdup (label);
	  *input_line_pointer = delim2;
	}

      if (debug_type == DEBUG_STABS)
	stabs_generate_asm_func (name, label);

      current_name = name;
      current_label = label;
    }

  demand_empty_rest_of_line ();
}

#ifdef HANDLE_BUNDLE

void
s_bundle_align_mode (int arg ATTRIBUTE_UNUSED)
{
  unsigned int align = get_absolute_expression ();
  SKIP_WHITESPACE ();
  demand_empty_rest_of_line ();

  if (align > (unsigned int) TC_ALIGN_LIMIT)
    as_fatal (_(".bundle_align_mode alignment too large (maximum %u)"),
	      (unsigned int) TC_ALIGN_LIMIT);

  if (bundle_lock_frag != NULL)
    {
      as_bad (_("cannot change .bundle_align_mode inside .bundle_lock"));
      return;
    }

  bundle_align_p2 = align;
}

void
s_bundle_lock (int arg ATTRIBUTE_UNUSED)
{
  demand_empty_rest_of_line ();

  if (bundle_align_p2 == 0)
    {
      as_bad (_(".bundle_lock is meaningless without .bundle_align_mode"));
      return;
    }

  if (bundle_lock_depth == 0)
    {
      bundle_lock_frchain = frchain_now;
      bundle_lock_frag = start_bundle ();
    }
  ++bundle_lock_depth;
}

void
s_bundle_unlock (int arg ATTRIBUTE_UNUSED)
{
  unsigned int size;

  demand_empty_rest_of_line ();

  if (bundle_lock_frag == NULL)
    {
      as_bad (_(".bundle_unlock without preceding .bundle_lock"));
      return;
    }

  gas_assert (bundle_align_p2 > 0);

  gas_assert (bundle_lock_depth > 0);
  if (--bundle_lock_depth > 0)
    return;

  size = pending_bundle_size (bundle_lock_frag);

  if (size > (1U << bundle_align_p2))
    as_bad (_(".bundle_lock sequence is %u bytes, but bundle size only %u"),
	    size, 1 << bundle_align_p2);
  else
    finish_bundle (bundle_lock_frag, size);

  bundle_lock_frag = NULL;
  bundle_lock_frchain = NULL;
}

#endif  /* HANDLE_BUNDLE */

void
s_ignore (int arg ATTRIBUTE_UNUSED)
{
  ignore_rest_of_line ();
}

void
read_print_statistics (FILE *file)
{
  hash_print_statistics (file, "pseudo-op table", po_hash);
}

/* Inserts the given line into the input stream.

   This call avoids macro/conditionals nesting checking, since the contents of
   the line are assumed to replace the contents of a line already scanned.

   An appropriate use of this function would be substitution of input lines when
   called by md_start_line_hook().  The given line is assumed to already be
   properly scrubbed.  */

void
input_scrub_insert_line (const char *line)
{
  sb newline;
  size_t len = strlen (line);
  sb_build (&newline, len);
  sb_add_buffer (&newline, line, len);
  input_scrub_include_sb (&newline, input_line_pointer, 0);
  sb_kill (&newline);
  buffer_limit = input_scrub_next_buffer (&input_line_pointer);
}

/* Insert a file into the input stream; the path must resolve to an actual
   file; no include path searching or dependency registering is performed.  */

void
input_scrub_insert_file (char *path)
{
  input_scrub_include_file (path, input_line_pointer);
  buffer_limit = input_scrub_next_buffer (&input_line_pointer);
}

/* Find the end of a line, considering quotation and escaping of quotes.  */

#if !defined(TC_SINGLE_QUOTE_STRINGS) && defined(SINGLE_QUOTE_STRINGS)
# define TC_SINGLE_QUOTE_STRINGS 1
#endif

static char *
_find_end_of_line (char *s, int mri_string, int insn ATTRIBUTE_UNUSED,
		   int in_macro)
{
  char inquote = '\0';
  int inescape = 0;

  while (!is_end_of_line[(unsigned char) *s]
	 || (inquote && !ISCNTRL (*s))
	 || (inquote == '\'' && flag_mri)
#ifdef TC_EOL_IN_INSN
	 || (insn && TC_EOL_IN_INSN (s))
#endif
	 /* PR 6926:  When we are parsing the body of a macro the sequence
	    \@@ is special - it refers to the invocation count.  If the @@
	    character happens to be registered as a line-separator character
	    by the target, then the is_end_of_line[] test above will have
	    returned true, but we need to ignore the line separating
	    semantics in this particular case.  */
	 || (in_macro && inescape && *s == '@@')
	)
    {
      if (mri_string && *s == '\'')
	inquote ^= *s;
      else if (inescape)
	inescape = 0;
      else if (*s == '\\')
	inescape = 1;
      else if (!inquote
	       ? *s == '"'
#ifdef TC_SINGLE_QUOTE_STRINGS
		 || (TC_SINGLE_QUOTE_STRINGS && *s == '\'')
#endif
	       : *s == inquote)
	inquote ^= *s;
      ++s;
    }
  if (inquote)
    as_warn (_("missing closing `%c'"), inquote);
  if (inescape)
    as_warn (_("stray `\\'"));
  return s;
}

char *
find_end_of_line (char *s, int mri_string)
{
  return _find_end_of_line (s, mri_string, 0, 0);
}
@


1.184
log
@    gas/
    * read.c (convert_to_bignum): Add sign parameter. Use it
    instead of X_unsigned to determine sign of resulting bignum.
    (emit_expr): Pass extra argument to convert_to_bignum.
    (emit_leb128_expr): Use X_extrabit instead of X_unsigned. Pass
    X_extrabit to convert_to_bignum.
    (parse_bitfield_cons): Set X_extrabit.
    * expr.c (make_expr_symbol, expr_build_uconstant, operand):
    Initialise X_extrabit field as appropriate.
    (add_to_result): New.
    (subtract_from_result): New.
    (expr): Use above.
    * expr.h (expressionS): Add X_extrabit field.

    gas/testsuite/
    * gas/all/sleb128-2.s: New test.
    * gas/all/sleb128-3.s: Likewise.
    * gas/all/sleb128-4.s: Likewise.
    * gas/all/sleb128-5.s: Likewise.
    * gas/all/sleb128-7.s: Likewise.
    * gas/all/sleb128-2.d: New.
    * gas/all/sleb128-3.d: New.
    * gas/all/sleb123-4.d: New.
    * gas/all/sleb123-5.d: New.
    * gas/all/sleb123-7.d: New.
    * gas/all/gas.exp (sleb128-2, sleb128-3, sleb128-4, sleb128-5)
    (sleb128-7): Run new tests.
@
text
@d2 1
a2 3
   Copyright 1986, 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997,
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
   2010, 2011, 2012  Free Software Foundation, Inc.
d5795 2
a5796 2
	(char **) realloc (include_dirs,
			   include_dir_count * sizeof (*include_dirs));
@


1.183
log
@2013-03-08  Chung-Lin Tang  <cltang@@codesourcery.com>

	* write.h (struct fix): Add fx_dot_frag field.
	(dot_frag): Declare.
	* write.c (dot_frag): New variable.
	(fix_new_internal): Set fx_dot_frag field with dot_frag.
	(fixup_segment): Base calculation of fx_offset with fx_dot_frag.
	* expr.c (expr): Save value of frag_now in dot_frag when setting
	dot_value.
	* read.c (emit_expr): Likewise. Delete comments.
@
text
@d1309 1
a1309 1
   Take the sign of the number from X_unsigned rather than X_add_number.  */
d1312 1
a1312 1
convert_to_bignum (expressionS *exp)
d1325 2
a1326 2
  if ((exp->X_add_number < 0) != !exp->X_unsigned)
    generic_bignum[i++] = exp->X_unsigned ? 0 : LITTLENUM_MASK;
d4253 1
a4253 1
      convert_to_bignum (exp);
d4547 1
d5107 1
a5107 1
	   && (exp->X_add_number < 0) != !exp->X_unsigned)
d5112 1
a5112 1
      convert_to_bignum (exp);
@


1.182
log
@Remove trailing white spaces on gas

	* app.c: Remove trailing white spaces.
	* as.c: Likewise.
	* as.h: Likewise.
	* cond.c: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.h: Likewise.
	* ecoff.c: Likewise.
	* input-file.c: Likewise.
	* itbl-lex.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* sb.c: Likewise.
	* subsegs.c: Likewise.
	* symbols.c: Likewise.
	* write.c: Likewise.
	* config/tc-i386.c: Likewise.
	* doc/Makefile.am: Likewise.
	* doc/Makefile.in: Likewise.
	* doc/c-aarch64.texi: Likewise.
	* doc/c-alpha.texi: Likewise.
	* doc/c-arc.texi: Likewise.
	* doc/c-arm.texi: Likewise.
	* doc/c-avr.texi: Likewise.
	* doc/c-bfin.texi: Likewise.
	* doc/c-cr16.texi: Likewise.
	* doc/c-d10v.texi: Likewise.
	* doc/c-d30v.texi: Likewise.
	* doc/c-h8300.texi: Likewise.
	* doc/c-hppa.texi: Likewise.
	* doc/c-i370.texi: Likewise.
	* doc/c-i386.texi: Likewise.
	* doc/c-i860.texi: Likewise.
	* doc/c-m32c.texi: Likewise.
	* doc/c-m32r.texi: Likewise.
	* doc/c-m68hc11.texi: Likewise.
	* doc/c-m68k.texi: Likewise.
	* doc/c-microblaze.texi: Likewise.
	* doc/c-mips.texi: Likewise.
	* doc/c-msp430.texi: Likewise.
	* doc/c-mt.texi: Likewise.
	* doc/c-s390.texi: Likewise.
	* doc/c-score.texi: Likewise.
	* doc/c-sh.texi: Likewise.
	* doc/c-sh64.texi: Likewise.
	* doc/c-tic54x.texi: Likewise.
	* doc/c-tic6x.texi: Likewise.
	* doc/c-v850.texi: Likewise.
	* doc/c-xc16x.texi: Likewise.
	* doc/c-xgate.texi: Likewise.
	* doc/c-xtensa.texi: Likewise.
	* doc/c-z80.texi: Likewise.
	* doc/internals.texi: Likewise.
@
text
@a4089 2
  /* Grow the current frag now so that dot_value does not get invalidated
     if the frag were to fill up in the frag_more() call below.  */
d4092 1
@


1.181
log
@	* read.h (s_vendor_attribute): Move to...
	* config/obj-elf.h (obj_elf_vendor_attribute): ... here.
	* read.c (potable): Remove "gnu_attribute".
	(skip_whitespace, skip_past_char, skip_past_comma): Delete, move
	to config/obj-elf.c.
	(s_vendor_attribute): Delete, move to obj_elf_vendor_attribute
	in config/obj-elf.c.
	(s_gnu_attribute): Delete, move to obj_elf_gnu_attribute in
	config/obj-elf.c.
	* config/obj-elf.c (elf_pseudo_table): Add "gnu_attribute".
	(skip_whitespace, skip_past_char, skip_past_comma): New, moved
	from read.c.
	(obj_elf_vendor_attribute): New, moved from s_vendor_attribute
	in read.c.
	(obj_elf_gnu_attribute): New, moved from s_gnu_attribute in
	read.c.
	* config/tc-arm.c (s_arm_eabi_attribute): Rename
	s_vendor_attribute to obj_elf_vendor_attribute.
	* config/tc-tic6x.c (s_tic6x_c6xabi_attribute): Likewise.
@
text
@d1633 1
a1633 1
	  
d1675 1
a1675 1
    
@


1.180
log
@Allocate sufficient space for string buffer

	* input-scrub.c (input_scrub_include_sb): Use sb_build to
	allocate sufficient space for from_sb.  Use sb_terminate to
	terminate string.
	* read.c (read_a_source_file): Use sb_build to allocate
	sufficient space and replace sb_add_string with sb_add_buffer.
	(s_macro): Likewise.
	(input_scrub_insert_line): Likewise.
	(s_irp): Use sb_build to allocate sufficient space.
	(do_repeat): Use sb_build to allocate sufficient space
	for many.
	* sb.c (sb_build): Remove static.
	* sb.h (sb_build): New prototype.
@
text
@a246 3
#ifdef OBJ_ELF
static void s_gnu_attribute (int);
#endif
a377 3
#ifdef OBJ_ELF
  {"gnu_attribute", s_gnu_attribute, 0},
#endif
a2288 133
#ifdef OBJ_ELF
#define skip_whitespace(str)  do { if (*(str) == ' ') ++(str); } while (0)

static inline int
skip_past_char (char ** str, char c)
{
  if (**str == c)
    {
      (*str)++;
      return 0;
    }
  else
    return -1;
}
#define skip_past_comma(str) skip_past_char (str, ',')

/* Parse an attribute directive for VENDOR.
   Returns the attribute number read, or zero on error.  */
int
s_vendor_attribute (int vendor)
{
  expressionS exp;
  int type;
  int tag;
  unsigned int i = 0;
  char *s = NULL;

  /* Read the first number or name.  */
  skip_whitespace (input_line_pointer);
  s = input_line_pointer;
  if (ISDIGIT (*input_line_pointer))
    {
      expression (& exp);
      if (exp.X_op != O_constant)
	goto bad;
      tag = exp.X_add_number;
    }
  else
    {
      char *name;

      /* A name may contain '_', but no other punctuation.  */
      for (; ISALNUM (*input_line_pointer) || *input_line_pointer == '_';
	   ++input_line_pointer)
	i++;
      if (i == 0)
	goto bad;

      name = (char *) alloca (i + 1);
      memcpy (name, s, i);
      name[i] = '\0';

#ifndef CONVERT_SYMBOLIC_ATTRIBUTE
#define CONVERT_SYMBOLIC_ATTRIBUTE(a) -1
#endif

      tag = CONVERT_SYMBOLIC_ATTRIBUTE (name);
      if (tag == -1)
	{
	  as_bad (_("Attribute name not recognised: %s"), name);
	  ignore_rest_of_line ();
	  return 0;
	}
    }

  type = _bfd_elf_obj_attrs_arg_type (stdoutput, vendor, tag);

  if (skip_past_comma (&input_line_pointer) == -1)
    goto bad;
  if (type & 1)
    {
      expression (& exp);
      if (exp.X_op != O_constant)
	{
	  as_bad (_("expected numeric constant"));
	  ignore_rest_of_line ();
	  return 0;
	}
      i = exp.X_add_number;
    }
  if ((type & 3) == 3
      && skip_past_comma (&input_line_pointer) == -1)
    {
      as_bad (_("expected comma"));
      ignore_rest_of_line ();
      return 0;
    }
  if (type & 2)
    {
      int len;

      skip_whitespace (input_line_pointer);
      if (*input_line_pointer != '"')
	goto bad_string;
      s = demand_copy_C_string (&len);
    }

  switch (type & 3)
    {
    case 3:
      bfd_elf_add_obj_attr_int_string (stdoutput, vendor, tag, i, s);
      break;
    case 2:
      bfd_elf_add_obj_attr_string (stdoutput, vendor, tag, s);
      break;
    case 1:
      bfd_elf_add_obj_attr_int (stdoutput, vendor, tag, i);
      break;
    default:
      abort ();
    }

  demand_empty_rest_of_line ();
  return tag;
bad_string:
  as_bad (_("bad string constant"));
  ignore_rest_of_line ();
  return 0;
bad:
  as_bad (_("expected <tag> , <value>"));
  ignore_rest_of_line ();
  return 0;
}

/* Parse a .gnu_attribute directive.  */

static void
s_gnu_attribute (int ignored ATTRIBUTE_UNUSED)
{
  s_vendor_attribute (OBJ_ATTR_GNU);
}
#endif /* OBJ_ELF */

@


1.179
log
@	PR gas/14201
	* sb.h (sb_max_power_two): Delete.
	(struct sb): Delete "item" and "pot".  Make "len" a size_t.  Add "max".
	(sb_element): Delete.
	(sb_add_char, sb_add_buffer, sb_skip_comma, sb_skip_write): Update
	prototypes.
	* sb.c (string_count, free_list): Delete.
	(sb_build, sb_kill, sb_check): Rewrite.
	(scrub_from_sb, sb_add_char, sb_add_string, sb_add_buffer,
	sb_skip_white, sb_skip_comma): Replace assorted int params,
	vars and return types with size_t.
	* input-scrub.c: Likewise.
	* macro.c: Likewise.
	* macro.h: Likewise.
	* as.c: Likewise.
	* as.h: Likewise.
	* input-file.h: Likewise.
	* input-file.c: Likewise.
	* read.c: Likewise.
	* app.c: ..or ptrdiff_t.
	* input-file.c (input_file_get): Use ferror.
	(input_file_give_next_buffer): Use input_file_get.
@
text
@a1183 1
	      sb_new (&sbuf);
d1264 3
a1266 1
	      sb_add_string (&sbuf, new_buf);
a2440 1
  sb_new (&s);
d2442 1
a2776 1
  sb_new (&s);
d2778 1
d2785 1
d2787 4
a2790 2
      sb_new (&label);
      sb_add_string (&label, S_GET_NAME (line_label));
d3214 1
a3214 1
  sb_new (&many);
d3254 1
a3254 1
	  sb_new (& processed);
d6174 3
a6176 2
  sb_new (&newline);
  sb_add_string (&newline, line);
@


1.178
log
@gas/
	* read.c [HANDLE_BUNDLE] (bundle_lock_depth): New variable.
	(read_a_source_file) [HANDLE_BUNDLE]: Reset it.
	[HANDLE_BUNDLE] (s_bundle_lock, s_bundle_unlock): Allow nested
	pairs.

gas/testsuite/
	* gas/i386/bundle-bad.s: Remove nested .bundle_lock case.
	* gas/i386/bundle-bad.l: Remove expected error line.
	* gas/i386/bundle-lock.s: Add nested .bundle_lock case.
	* gas/i386/bundle-lock.d: Update expectations.
@
text
@d254 1
a254 1
static int get_non_macro_line_sb (sb *);
d582 2
a583 2
static int
scrub_from_string (char *buf, int buflen)
d585 1
a585 1
  int copy;
d1238 2
a1239 2
		  int space;
		  int size;
d2751 1
a2751 1
static int
d2757 1
a2757 1
static int
@


1.177
log
@	* read.c (read_symbol_name): New function.  Reads a symbol names.
	Allows escape codes in names.
	(s_comm_internal): Use read_symbol_name.
	(s_globl, s_lsym, s_set, s_weakref): Likewise.
	* doc/as.texinfo: Document support for multibyte characters in
	symbol names.

	* gas/elf/syms.s: New test - checks the generation of multibyte
	symbol names.
	* gas/elf/syms.d: New file - expected readelf output.
	* gas/elf/elf.exp: Add syms.

	* readelf.c (print_symbol): Display multibyte characters in symbol
	names.
	(process_section_headers): Use print_symbol.

	* ld-ifunc/ifunc-13a-i386.s: Fix use of .global directive.
	* ld-ifunc/ifunc-15a-i385.s: Likewise.
@
text
@d236 4
d1295 1
d6104 1
a6104 1
  if (bundle_lock_frag != NULL)
d6106 2
a6107 2
      as_bad (_("second .bundle_lock without .bundle_unlock"));
      return;
d6109 1
a6109 3

  bundle_lock_frchain = frchain_now;
  bundle_lock_frag = start_bundle ();
d6127 4
@


1.176
log
@Fix up last commit.
@
text
@d43 1
d1587 95
a1686 2
  char c;
  char *p;
d1696 2
a1697 14
  name = input_line_pointer;
  c = get_symbol_end ();
  /* Just after name is now '\0'.  */
  p = input_line_pointer;
  *p = c;

  if (name == p)
    {
      as_bad (_("expected symbol name"));
      ignore_rest_of_line ();
      goto out;
    }

  SKIP_WHITESPACE ();
a1719 1
  *p = 0;
a1727 1
	  *p = c;
a1744 1
  *p = c;
d1758 2
d2263 3
a2265 2
      name = input_line_pointer;
      c = get_symbol_end ();
a2268 1
      *input_line_pointer = c;
d2278 2
a2665 2
  char c;
  char *p;
d2670 2
a2671 13
  name = input_line_pointer;
  c = get_symbol_end ();
  p = input_line_pointer;
  *p = c;

  if (name == p)
    {
      as_bad (_("expected symbol name"));
      ignore_rest_of_line ();
      return;
    }

  SKIP_WHITESPACE ();
a2674 1
      *p = 0;
d2676 1
a2676 3
      *p = c;
      ignore_rest_of_line ();
      return;
d2686 1
a2686 2
      ignore_rest_of_line ();
      return;
a2688 1
  *p = 0;
a2705 1
  *p = c;
d2707 7
a3356 2
  char delim;
  char *end_name;
d3361 2
a3362 13
  name = input_line_pointer;
  delim = get_symbol_end ();
  end_name = input_line_pointer;
  *end_name = delim;

  if (name == end_name)
    {
      as_bad (_("expected symbol name"));
      ignore_rest_of_line ();
      return;
    }

  SKIP_WHITESPACE ();
a3365 1
      *end_name = 0;
a3366 1
      *end_name = delim;
d3368 1
a3372 2
  *end_name = 0;

a3373 2
  *end_name = delim;

d3375 1
a3678 2
  char delim;
  char *end_name;
d3683 2
a3684 11
  name = input_line_pointer;
  delim = get_symbol_end ();
  end_name = input_line_pointer;

  if (name == end_name)
    {
      as_bad (_("expected symbol name"));
      *end_name = delim;
      ignore_rest_of_line ();
      return;
    }
d3693 1
a3693 3
	  *end_name = delim;
	  ignore_rest_of_line ();
	  return;
a3698 2
  *end_name = delim;

a3702 1
      *end_name = 0;
d3704 1
a3704 3
      *end_name = delim;
      ignore_rest_of_line ();
      return;
d3710 1
d3712 2
a3713 10
  name = input_line_pointer;
  delim = get_symbol_end ();
  end_name = input_line_pointer;

  if (name == end_name)
    {
      as_bad (_("expected symbol name"));
      ignore_rest_of_line ();
      return;
    }
d3744 1
d3755 1
a3755 2

	  *end_name = delim;
a3765 2
  *end_name = delim;

d3776 7
@


1.175
log
@gas/
2012-03-12  Roland McGrath  <mcgrathr@@google.com>

	* config/tc-arm.c (arm_frag_max_var): New function.
	* config/tc-arm.h: Declare it.
	(md_frag_max_var): New macro.

	* config/tc-i386.c (i386_frag_max_var): New function.
	* config/tc-i386.h: Declare it.
	(md_frag_max_var): New macro.

	* doc/as.texinfo (Bundle directives): New node.
	(Pseudo Ops): Add it to the menu.
	* NEWS: Mention new feature.
	* read.c [md_frag_max_var] (HANDLE_BUNDLE): New macro.
	[HANDLE_BUNDLE] (bundle_align_p2): New variable.
	[HANDLE_BUNDLE] (bundle_lock_frchain, bundle_lock_frag): New variables.
	[HANDLE_BUNDLE] (start_bundle, pending_bundle_size, finish_bundle):
	New functions.
	(assemble_one): New function if [HANDLE_BUNDLE], #define directly
	to md_assembly if not.
	(read_a_source_file): Call assemble_one in place of md_assemble.
	(read_a_source_file) [HANDLE_BUNDLE]: Check for unterminated
	.bundle_lock at end of processing.
	[HANDLE_BUNDLE] (s_bundle_align_mode, s_bundle_lock, s_bundle_unlock):
	New functions.
	[HANDLE_BUNDLE] (potable): Add their entries.
	* read.h: Declare new functions.

gas/testsuite/
2012-03-12  Roland McGrath  <mcgrathr@@google.com>

	* gas/i386/bundle-bad.s: New file.
	* gas/i386/bundle-bad.d: New file.
	* gas/i386/bundle-bad.l: New file.
	* gas/i386/i386.exp: Run it.

	* gas/arm/bundle.s: New file.
	* gas/arm/bundle.d: New file.
	* gas/arm/bundle-lock.s: New file.
	* gas/arm/bundle-lock.d: New file.

	* gas/i386/bundle.s: New file.
	* gas/i386/bundle.d: New file.
	* gas/i386/x86-64-bundle.s: New file.
	* gas/i386/x86-64-bundle.d: New file.
	* gas/i386/bundle-lock.s: New file.
	* gas/i386/bundle-lock.d: New file.
	* gas/i386/i386.exp: Run them.
@
text
@d695 1
a695 1
  fragS *insn_start_frag;
@


1.174
log
@	* as.c (main): Define .gasversion. rather than __GAS_VERSION__.
	* frags.h (bss_address_frag): Delete
	(predefined_address_frag): New.
	* frags.c (frag_init): Init predefined_address_frag.  Delete ref
	to bss_addres_frag.
	* symbols.c (S_CAN_BE_REDEFINED): New function.
	* symbols.h (S_CAN_BE_REDEFINED): Declare.
	* read.c (assign_symbol): Use S_CAN_BE_REDEFINED.
@
text
@d4 1
a4 1
   2010, 2011  Free Software Foundation, Inc.
d212 25
d305 5
d616 122
d950 1
a950 1
              else if ((c == '=' && input_line_pointer[1] == '=')
d958 3
a960 3
              else if ((c == '='
                       || ((c == ' ' || c == '\t')
                            && input_line_pointer[1] == '='))
d962 1
a962 1
                           && !TC_EQUAL_IN_INSN (c, s)
d964 1
a964 1
                           )
d1102 1
a1102 1
		      md_assemble (s);	/* Assemble 1 instruction.  */
d1283 10
d1899 1
a1899 1
          # 0 "<built-in>"
d1928 1
a1928 1
		          another file.
d3771 1
a3771 1
  
d4017 1
a4017 1
        {
d5856 1
a5856 1
                           + include_dir_maxlen + 5 /* slop */ );
d6032 72
@


1.173
log
@Fix spelling mistakes.
@
text
@a3093 1
      /* Permit register names to be redefined.  */
d3095 1
a3095 1
	  && S_GET_SEGMENT (symbolP) != reg_section)
@


1.173.2.1
log
@	2011-10-13  Alan Modra  <amodra@@gmail.com>
	* as.c (main): Define .gasversion. rather than __GAS_VERSION__.
	* frags.h (bss_address_frag): Delete
	(predefined_address_frag): New.
	* frags.c (frag_init): Init predefined_address_frag.  Delete ref
	to bss_address_frag.
	* symbols.c (S_CAN_BE_REDEFINED): New function.
	* symbols.h (S_CAN_BE_REDEFINED): Declare.
	* read.c (assign_symbol): Use S_CAN_BE_REDEFINED.

	2011-10-12  Alan Modra  <amodra@@gmail.com>
	* symbols.c (local_symbol_make): Make global.
	* symbols.h (local_symbol_make): Declare.
	* as.c (main): Define __GAS_VERSION__.
@
text
@d3094 1
d3096 1
a3096 1
	  && !S_CAN_BE_REDEFINED (symbolP))
@


1.172
log
@2011-05-06  Tristan Gingold  <gingold@@adacore.com>

	* read.c (s_comm_internal): Remove code for OBJ_VMS.
	(s_data): Ditto.
	(s_text): Ditto.
	* write.c (write_object_file): Ditto.
	* symbols.c (define_sym_at_dot): Ditto.
	(colon): Ditto.
@
text
@d2938 1
a2938 1
  as_warn (_(".end%c encountered without preceeding %s"),
@


1.171
log
@	* read.c (read_a_source_file): Remove md_after_pass_hook.
	Move "quit" label before set of dot_symbol.
	* config/tc-d10v.h (md_after_pass_hook): Don't define.
	* config/tc-d30v.h (md_after_pass_hook): Likewise.
	* config/tc-m32r.h (md_after_pass_hook): Likewise.
	(md_cleanup): Define to call m32r_fill_insn.
@
text
@a1510 7
#ifdef OBJ_VMS
      {
	extern int flag_one;
	if (size == 0 || !flag_one)
	  S_GET_OTHER (symbolP) = const_flag;
      }
#endif
a1648 3
#ifdef OBJ_VMS
  const_flag = 0;
#endif
a3455 3
#ifdef OBJ_VMS
  const_flag &= ~IN_DEFAULT_SECTION;
#endif
@


1.170
log
@	PR 12569
	* expr.c (operand): Correct passing of "mode" to expr.
	* read.c (do_org): Allow expr_section.
	(get_known_segmented_expression): Don't assert anything about the
	segment.
@
text
@a1125 4

#ifdef md_after_pass_hook
      md_after_pass_hook ();
#endif
a1126 1
  symbol_set_value_now (&dot_symbol);
d1129 1
@


1.169
log
@	* dw2gencfi.c (dot_cfi_dummy): New.
	(cfi_pseudo_table) [!TARGET_USE_CFIPOP]: New.
	* read.c (pobegin): Unconditionally call cfi_pop_insert.
@
text
@d4 1
a4 1
   2010  Free Software Foundation, Inc.
d2656 3
a2658 1
  if (segment != now_seg && segment != absolute_section)
d5421 1
a5421 1
  segT retval;
d5423 1
a5423 1
  if ((retval = get_segmented_expression (expP)) == undefined_section)
d5437 1
a5437 2
  know (retval == absolute_section || SEG_NORMAL (retval));
  return (retval);
@


1.168
log
@	* symbols.h (dot_symbol): New declaration.
	(dot_symbol_init): New prototype.
	* symbols.c (dot_symbol): New variable.
	(symbol_clone): Assert it's not dot_symbol being cloned.
	(dot_symbol_init): New function.
	(symbol_clone_if_forward_ref): Create a new temporary symbol
	when trying to clone dot_symbol.
	* expr.c (current_location): Refer to dot_symbol instead of
	making a new temporary symbol.
	* read.c (read_a_source_file): Update dot_symbol as we go.
	* as.c (main): Call dot_symbol_init.
@
text
@d524 1
a524 1
#ifdef TARGET_USE_CFIPOP
a527 1
#endif
@


1.167
log
@	PR gas/11867
	* expr.c (operand <'-' and '~'>): Widen bignums.
	(operand <'!'>): Correct bignum result and convert to O_constant.
	* read.c (emit_expr): Don't assert on .byte bignum.  Don't display
	bignum truncated warning for sign extended bignums.
@
text
@d632 1
d1132 1
@


1.167.2.1
log
@backport from mainline
@
text
@a631 1
	      symbol_set_value_now (&dot_symbol);
a1130 1
  symbol_set_value_now (&dot_symbol);
@


1.167.2.2
log
@	PR 12569
	* expr.c (operand): Correct passing of "mode" to expr.
	* read.c (do_org): Allow expr_section.
	(get_known_segmented_expression): Don't assert anything about the
	segment.
@
text
@d4 1
a4 1
   2010, 2011  Free Software Foundation, Inc.
d2657 1
a2657 3
  if (segment != now_seg
      && segment != absolute_section
      && segment != expr_section)
d5420 1
a5420 1
  segT retval = get_segmented_expression (expP);
d5422 1
a5422 1
  if (retval == undefined_section)
d5436 2
a5437 1
  return retval;
@


1.167.2.3
log
@	PR 12365
	PR 12613
	PR 12632
	PR 12739
	PR 12753
	PR 12760
	PR 12763
Apply fix from mainline along with assorted other small fixes.
@
text
@d1127 4
d1132 1
a1134 1
  symbol_set_value_now (&dot_symbol);
@


1.166
log
@	* config/obj-evax.h (S_SET_OTHER, S_SET_TYPE, S_SET_DESC): Don't define.
	* config/tc-crx.c (gettrap): Constify arg.
	(handle_LoadStor, get_cinv_parameters): Likewise.
	(getreg_image): Fix enum warning
	(md_assemble): Restore input line char.
	* config/tc-hppa.c (tc_gen_reloc): Fix enum warning.
	* config/tc-i960.c (mem_fmt): Rename var to fix shadow warning.
	* config/tc-sh.c (sh_fdpic): Only define when OBJ_ELF.
	(build_Mytes): Fix build failure for non-elf targets.
	* config/tc-tic4x.c (tic4x_eval): Restore terminator char.
	* config/tc-xtensa.c (xtensa_end_directive): Fix switch enum warning.

	* cgen.c (gas_cgen_md_apply_fix): Avoid set but unused warning.
	* ecoff.c (add_ecoff_symbol): Likewise.
	* itbl-ops.c (append_insns_as_macros): Likewise.
	* listing.c (debugging_pseudo): Likewise.
	* read.c (s_mri_common, stringer): Likewise.
	* config/obj-coff.c (coff_frob_section): Likewise.
	* config/tc-alpha.c (emit_ldgp, s_alpha_proc): Likewise.
	* config/tc-arm.c (my_get_expression): Likewise.
	* config/tc-hppa.c (process_exit, pa_type_args): Likewise.
	* config/tc-m32c.c (md_assemble): Likewise.
	* config/tc-microblaze.c (md_convert_frag): Likewise.
	* config/tc-mips.c (s_change_section): Likewise.
	* config/tc-mt.c (mt_fix_adjustable): Likewise.
	* config/tc-xtensa.c (xtensa_literal_pseudo): Likewise.

	* config/obj-aout.c (obj_aout_frob_symbol): Delete set but otherwise
	unused vars.
	* config/tc-alpha.c (load_expression): Likewise.
	(s_alpha_rdata, s_alpha_section, s_alpha_prologue): Likewise.
	* config/tc-arm.c (parse_neon_el_struct_list): Likewise.
	* config/tc-avr.c (extract_word): Likewise.
	* config/tc-cris.c (cris_get_expression): Likewise.
	* config/tc-d30v.c (build_insn, find_format): Likewise.
	* config/tc-dlx.c (machine_ip): Likewise.
	* config/tc-hppa.c (pa_get_absolute_expression): Likewise.
	* config/tc-i370.c (md_assemble): Likewise.
	* config/tc-i960.c (brtab_emit): Likewise.
	* config/tc-iq2000.c (s_iq2000_ent): Likewise.
	* config/tc-m32c.c (md_convert_frag): Likewise.
	* config/tc-m68hc11.c (fixup24, build_jump_insn): Likewise.
	(md_estimate_size_before_relax, md_apply_fix): Likewise.
	* config/tc-m68k.c (md_show_usage): Likewise.
	* config/tc-microblaze.c (microblaze_s_lcomm): Likewise.
	* config/tc-mips.c (s_mips_end): Likewise.
	* config/tc-mmix.c (mmix_byte, mmix_cons): Likewise.
	* config/tc-mn10300.c (md_assemble): Likewise.
	* config/tc-msp430.c (extract_word): Likewise.
	* config/tc-mt.c (md_assemble): Likewise.
	* config/tc-or32.c (machine_ip): Likewise.
	* config/tc-pj.c (md_apply_fix): Likewise.
	* config/tc-s390.c (md_gather_operands): Likewise.
	* config/tc-sh.c (sh_cons_align): Likewise.
	* config/tc-sparc.c (sparc_cons_align): Likewise.
	* config/tc-tic4x.c (tic4x_sect): Likewise.
	* config/tc-tic54x.c (tic54x_stringer): Likewise.
	* config/tc-vax.c (vip_op): Likewise.
	* config/tc-xstormy16.c (xstormy16_cons_fix_new): Likewise.
	* config/tc-xtensa.c (md_assemble): Likewise.
	(xtensa_fix_short_loop_frags, convert_frag_immed): Likewise.
	(xtensa_move_literals): Likewise.
@
text
@a4265 2
      know (nbytes % CHARS_PER_LITTLENUM == 0);

d4269 13
a4281 1
	  as_warn (_("bignum truncated to %d bytes"), nbytes);
d4285 7
@


1.165
log
@	* read.c (cons_worker): Detect and reject unexpected string argument.

	testsuite/
	* gas/all/byte.s: New.
	* gas/all/byte.l: New.
	* gas/all/byte.d: New.
	* gas/all/gas.exp: Add it.
@
text
@d1613 2
d5160 1
d5162 1
d5202 1
d5204 1
d5214 1
a5214 2
#ifndef NO_LISTING
#ifdef OBJ_ELF
a5230 1
#endif
@


1.164
log
@Revert the accidental checkin.
@
text
@d3868 9
a3876 1
	TC_PARSE_CONS_EXPRESSION (&exp, (unsigned int) nbytes);
@


1.163
log
@Properly handle ".equ symbol, reg + NUM" in x86 Intel syntax.

gas/

2010-04-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11509
	* config/tc-i386-intel.c (i386_intel_simplify_register): New.
	(i386_intel_simplify): Use i386_is_register and
	i386_intel_simplify_register. Set X_md for O_register and
	check X_md for O_constant.
	(i386_intel_operand): Use i386_is_register.

	* config/tc-i386.c (i386_is_register): New.
	(x86_cons): Initialize the X_md field.  Use i386_is_register.
	(parse_register): Use i386_is_register.
	(tc_x86_parse_to_dw2regnum): Likewise.

gas/testsuite/

2010-04-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11509
	* gas/i386/equ.s: Add tests for ".equ symbol, reg + NUM".
	* gas/i386/equ.d: Updated.
@
text
@a473 1
  exp.X_md = 0;
@


1.162
log
@bfd/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * aoutx.h (aout_link_input_bfd): Remove unused variable sym_count.
        * elf-eh-frame.c (_bfd_elf_eh_frame_section_offset): Remove unused
        variables htab and hdr_info and mark info parameter as unused.
        * elf.c (prep_headers): Remove unused variable i_phdrp.
        (_bfd_elf_write_object_contents): Remove unused variable i_ehdrp.
        * elf32-i386.c (elf_i386_relocate_section): Mark variabled warned
        as unused.
        * peXXigen.c (pe_print_reloc): Remove unused variable datasize.
        * verilog.c (verilog_write_section): Remove unused variable
        address.

binutils/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * dwarf.c (process_debug_info): Remove unused variable
        cu_abbrev_offset_ptr.
        (display_debug_lines_decoded): Remove unused variable prev_line.
        * elfedit.c (process_archive): Remove unused variable
        file_name_size.
        * ieee.c (ieee_start_compilation_unit): Remove unused variable
        nindx.
        (ieee_set_type): Remove unused variables info, targetindx and
        baseindx.
        * objdump.c (disassmble_byte): Remove unused variable done_dot.
        * rddbg.c (read_section_stabs_debugging_info): Remove unused
        variable other.
        * readelf.c (dump_section_as_strings): Remove unused variable
        addr.
        (process_archive): Remove unused variable file_name_size.
        * stabs.c (parse_stab_string): Mark desc parameter as unused.
        Remove unused variable lineno.
        (parse_stab_struct_type): Remove unused variable orig.
        (stab_demangle_type): Remove unused variables constp, volatilep
        and hold.

gas/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * as.c (create_obj_attrs_section): Remove unused variable addr.
        * listing.c (listing_listing): Remove unused variable message.
        * read.c: Remove unnecessary register type qualifiers.
        (s_mri): Only define/use old_flag variable if MRI_MODE_CHANGE is
        defined.

ld/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * ldlang.c (wild_sort): Remove unused variable section_name.

opcodes/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * i386-dis.c (print_insn): Remove unused variable op.
        (OP_sI): Remove unused variable mask.
@
text
@d474 1
@


1.161
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d3 2
a4 2
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
   Free Software Foundation, Inc.
d1644 1
a1644 1
  register int temp;
d1686 1
a1686 1
  register char *s;
d1920 1
a1920 1
  register long fill = 0;
d2431 3
a2433 3
  register char *name;
  register char c;
  register char *p;
d2435 1
a2435 1
  register symbolS *symbolP;
d2610 4
a2613 1
  int on, old_flag;
d2616 1
d2618 1
d2688 1
a2688 1
  register segT segment;
d2690 1
a2690 1
  register long temp_fill;
d3460 1
a3460 1
  register int temp;
d3828 1
a3828 1
cons_worker (register int nbytes,	/* 1=.byte, 2=.word, 4=.long.  */
d4022 1
a4022 1
  register char *p;
d4199 3
a4201 3
      register valueT get;
      register valueT use;
      register valueT mask;
d4203 1
a4203 1
      register valueT unmask;
d4558 1
a4558 1
  register int i;
d4693 1
a4693 1
	    register int float_type	/* 'f':.ffloat ... 'F':.float ...  */)
d4695 1
a4695 1
  register char *p;
d4697 1
a4697 1
  register char *err;		/* Error from scanning floating literal.  */
d4794 2
a4795 2
  register int size = 0;
  register unsigned byte;
d4815 1
a4815 2
  register int size = 0;
  register unsigned byte;
a4818 1
      byte = (value & 0x7f);
d4841 2
a4842 2
  register char *orig = p;
  register int more;
d5249 1
a5249 1
  register unsigned int c;
d5369 1
a5369 1
get_segmented_expression (register expressionS *expP)
d5371 1
a5371 1
  register segT retval;
d5387 1
a5387 1
get_known_segmented_expression (register expressionS *expP)
d5389 1
a5389 1
  register segT retval;
d5423 1
a5423 1
  register char *s;
d5427 1
a5427 1
      register int len;
d5450 2
a5451 2
  register unsigned int c;
  register int len;
@


1.160
log
@gas/
2009-11-19  Jan Beulich  <jbeulich@@novell.com>

	* read.c (pseudo_set): Also call copy_symbol_attributes() for
	undefined target symbol.
@
text
@d592 3
a594 3
  register char c;
  register char *s;		/* String of symbol, '\0' appended.  */
  register int temp;
a682 1
		      char c;
d3200 1
a3200 1
	  valueT val;
d3202 2
a3203 2
	  val = S_GET_VALUE (mri_common_symbol);
	  if ((val & 1) != 0)
d3205 1
a3205 1
	      S_SET_VALUE (mri_common_symbol, val + 1);
@


1.159
log
@	PR gas/10850
	* listing.c (listing_flags): Delete.
	* listing.h: Likewise.
	* read.c (potable <lflags>): Call s_ignore.
@
text
@d3753 1
@


1.158
log
@	PR gas/1491
gas/
	* macro.c: Delete unnecessary function declarations.
	(buffer_and_nest): Support multiple labels per line for
	LABELS_WITHOUT_COLONS targets if the labels do have colons.
	(free_macro): Move so that we don't need forward declaration.
	* read.c (read_a_source_file): Take a copy of macro expansion line
	before we trim labels.
	* listing.c (listing_newline): Adjust stdin line save for
	input_line_pointer still at start of line.
gas/testsuite/
	* gas/macros/dot.s: Don't start macro invocations is first column.
	* gas/macros/dot.l: Update.
	* gas/macros/macros.exp: Run dot test on more targets.
@
text
@d374 1
a374 1
  {"lflags", listing_flags, 0},	/* Listing flags.  */
@


1.157
log
@	* read.c (s_reloc): Don't use expression_and_evaluate.
@
text
@d623 1
d629 2
a630 1
	  if (is_end_of_line[(unsigned char) input_line_pointer[-1]])
d637 1
d639 35
a685 1
		      LISTING_NEWLINE ();
a751 33
#ifndef NO_LISTING
	  /* If listing is on, and we are expanding a macro, then give
	     the listing code the contents of the expanded line.  */
	  if (listing)
	    {
	      if ((listing & LISTING_MACEXP) && macro_nest > 0)
		{
		  char *copy;
		  int len;

		  /* Find the end of the current expanded macro line.  */
		  s = find_end_of_line (input_line_pointer - 1, flag_m68k_mri);

		  if (s != last_eol)
		    {
		      last_eol = s;
		      /* Copy it for safe keeping.  Also give an indication of
			 how much macro nesting is involved at this point.  */
		      len = s - (input_line_pointer - 1);
		      copy = (char *) xmalloc (len + macro_nest + 2);
		      memset (copy, '>', macro_nest);
		      copy[macro_nest] = ' ';
		      memcpy (copy + macro_nest + 1, input_line_pointer - 1, len);
		      copy[macro_nest + 1 + len] = '\0';

		      /* Install the line with the listing facility.  */
		      listing_newline (copy);
		    }
		}
	      else
		listing_newline (NULL);
	    }
#endif
@


1.156
log
@bfd
        * Makefile.am (ALL_MACHINES): Add cpu-rx.lo.
        (ALL_MACHINES_CFILES): Add cpu-rx.c.
        (BFD32_BACKENDS): Add elf32-rx.lo.
        (BFD32_BACKENDS_CFILES): Add elf32-rx.c.
        * archures.c (bfd_architecture): Add bfd_arch_rx and bfd_mach_rx.
        Export bfd_rx_arch.
        (bfd_archures_list): Add bfd_rx_arch.
        * config.bfd: Add entry for rx-*-elf.
        * configure.in: Add entries for bfd_elf32_rx_le_vec and
        bfd_elf32_rx_be_vec.
        * reloc.c: Add RX relocations.
        * targets.c: Add RX target vectors.
        * Makefile.in: Regenerate.
        * bfd-in2.h: Regenerate.
        * configure: Regenerate.
        * libbfd.h: Regenerate.
        * cpu-rx.c: New file.
        * elf32-rx.c: New file.

binutils
        * readelf.c: Add support for RX target.
        * MAINTAINERS: Add DJ and NickC as maintainers for RX.

gas
        * Makefile.am: Add RX target.
        * configure.in: Likewise.
        * configure.tgt: Likewise.
        * read.c (do_repeat_with_expander): New function.
        * read.h: Provide a prototype for do_repeat_with_expander.
        * doc/Makefile.am: Add RX target documentation.
        * doc/all.texi: Likewise.
        * doc/as.texinfo: Likewise.
        * Makefile.in: Regenerate.
        * NEWS: Mention support for RX architecture.
        * configure: Regenerate.
        * doc/Makefile.in: Regenerate.
        * config/rx-defs.h: New file.
        * config/rx-parse.y: New file.
        * config/tc-rx.h: New file.
        * config/tc-rx.c: New file.
        * doc/c-rx.texi: New file.

gas/testsuite
        * gas/rx: New directory.
        * gas/rx/*: New set of test cases.
        * gas/elf/section2.e-rx: New expected output file.
        * gas/all/gas.exp: Add support for RX target.
        * gas/elf/elf.exp: Likewise.
        * gas/lns/lns.exp: Likewise.
        * gas/macros/macros.exp: Likewise.

include
        * dis-asm.h: Add prototype for print_insn_rx.

include/elf
        * rx.h: New file.

include/opcode
        * rx.h: New file.

ld
        * Makefile.am: Add rules to build RX emulation.
        * configure.tgt: Likewise.
        * NEWS: Mention support for RX architecture.
        * Makefile.in: Regenerate.
        * emulparams/elf32rx.sh: New file.
        * emultempl/rxelf.em: New file.

opcodes
        * Makefile.am: Add RX files.
        * configure.in: Add support for RX target.
        * disassemble.c: Likewise.
        * Makefile.in: Regenerate.
        * configure: Regenerate.
        * opc2c.c: New file.
        * rx-decode.c: New file.
        * rx-decode.opc: New file.
        * rx-dis.c: New file.
@
text
@d3965 1
a3965 1
      expression_and_evaluate (&exp);
@


1.155
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        * as.c (main): Call dwarf2_init.
        * config/obj-elf.c (struct group_list): New field.
        (build_group_lists): Use hash lookup.
        (free_section_idx): New function.
        (elf_frob_file): Adjust.
        * dwarf2dbg.c (all_segs_hash, last_seg_ptr): New variables.
        (get_line_subseg): Adjust.
        (dwarf2_init): New function.
        * dwarf2dbg.h (dwarf2_init): New declaration.
@
text
@d2984 51
@


1.154
log
@	* read.c (emit_expr_fix): Handle size 3.
	* config/tc-avr.c (md_assemble): Call dwarf2_emit_insn.
	* config/tc-d30v.c (write_long, write_1_short,
	write_2_short, md_assemble): Likewise.
	* config/tc-dlx.c (md_assemble): Likewise.
	* config/tc-i860.c (md_assemble): Likewise.
	* config/tc-mn10200.c (md_assemble): Likewise.
	* config/tc-pj.c (md_assemble): Likewise.
	* config/tc-vax.c (md_assemble): Likewise.
@
text
@d1037 1
a1037 1
		  tmp_buf = xmalloc (tmp_len + 1);
d1053 1
a1053 1
		      tmp_buf = xrealloc (tmp_buf, tmp_len + num);
d1090 1
a1090 1
		  new_buf = xrealloc (new_buf, new_length + 100);
d2100 1
a2100 1
      name = alloca (i + 1);
d3860 1
a3860 1
  reloc = xmalloc (sizeof (*reloc));
d5410 1
a5410 1
      retval = obstack_finish (&notes);
d5519 1
a5519 1
      path = xmalloc ((unsigned long) len + include_dir_maxlen + 5);
d5589 1
a5589 1
  FILE *try;
d5616 1
a5616 1
      filename = obstack_finish (&notes);
d5622 2
a5623 1
  path = xmalloc ((unsigned long) i + include_dir_maxlen + 5 /* slop */ );
d5630 1
a5630 1
      if (0 != (try = fopen (path, FOPEN_RT)))
d5632 1
a5632 1
	  fclose (try);
@


1.153
log
@update copyright dates
@
text
@d4268 3
@


1.153.2.1
log
@gas/
	* read.c (emit_expr_fix): Handle size 3.
	* config/tc-avr.c (md_assemble): Call dwarf2_emit_insn.
	* config/tc-d30v.c (write_long, write_1_short,
	write_2_short, md_assemble): Likewise.
	* config/tc-dlx.c (md_assemble): Likewise.
	* config/tc-i860.c (md_assemble): Likewise.
	* config/tc-mn10200.c (md_assemble): Likewise.
	* config/tc-pj.c (md_assemble): Likewise.
	* config/tc-vax.c (md_assemble): Likewise.
gas/testsuite/
	* gas/d30v/serial2.l: Adjust position of page break.
	* gas/lns/lns-common-1-alt.d: Match 2009-04-24 change.
	* gas/mt/ms1-16-003.d: Correct reloc name.
	* gas/mt/relocs.d: Elide incorrect file format strings.
@
text
@a4267 3
      case 3:
	r = BFD_RELOC_24;
	break;
@


1.153.2.2
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.
@
text
@d1037 1
a1037 1
		  tmp_buf = (char *) xmalloc (tmp_len + 1);
d1053 1
a1053 1
		      tmp_buf = (char *) xrealloc (tmp_buf, tmp_len + num);
d1090 1
a1090 1
		  new_buf = (char *) xrealloc (new_buf, new_length + 100);
d2100 1
a2100 1
      name = (char *) alloca (i + 1);
d3860 1
a3860 1
  reloc = (struct reloc_list *) xmalloc (sizeof (*reloc));
d5410 1
a5410 1
      retval = (char *) obstack_finish (&notes);
d5519 1
a5519 1
      path = (char *) xmalloc ((unsigned long) len + include_dir_maxlen + 5);
d5589 1
a5589 1
  FILE *try_file;
d5616 1
a5616 1
      filename = (char *) obstack_finish (&notes);
d5622 1
a5622 2
  path = (char *) xmalloc ((unsigned long) i
                           + include_dir_maxlen + 5 /* slop */ );
d5629 1
a5629 1
      if (0 != (try_file = fopen (path, FOPEN_RT)))
d5631 1
a5631 1
	  fclose (try_file);
@


1.153.2.3
log
@	* read.c (s_reloc): Don't use expression_and_evaluate.
@
text
@d3914 1
a3914 1
      expression (&exp);
@


1.152
log
@	* read.c (TC_START_LABEL): Add a new argument.
	(read_a_source_file): Pass the beginning of the symbol through
	the new argument of TC_START_LABEL.
	* config/tc-arm.h (TC_START_LABEL): Add a new argument.
	* config/tc-bfin.c (bfin_start_label): Only search '(' and '['
	from the beginning of the symbol.
	* config/tc-bfin.h (TC_START_LABEL): Add the new argument.
	* config/tc-d30v.h (TC_START_LABEL): Likewise.
	* config/tc-fr30.h (TC_START_LABEL): Likewise.
	* config/tc-m32c.h (TC_START_LABEL): Likewise.
	* config/tc-m32r.h (TC_START_LABEL): Likewise.
	* config/tc-mep.h (TC_START_LABEL): Likewise.

	testsuite/
	* gas/bfin/stack2.s: Add pop multiple instruction with a label
	on the same line.
	* gas/bfin/stack2.d: Adjust accordingly.
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
@


1.151
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d45 1
a45 1
#define TC_START_LABEL(x,y) (x == ':')
d763 1
a763 1
	      if (TC_START_LABEL (c, input_line_pointer))
@


1.150
log
@2009-03-23  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/9966
	* listing.c (listing_newline): Properly handle `\\"' and ';'.

	* read.c (is_end_of_line): Update comments for line separator.
	(read_begin): Set line separator in is_end_of_line to 2.
@
text
@d3492 1
a3492 1
	  assert (expP->X_op == O_symbol
@


1.149
log
@gas:
	* read.c (s_fill, s_space, s_float_space, float_cons, stringer,
	s_incbin): Call md_cons_align (1).

gas/testsuite:
	* gas/arm/mapmisc.d, gas/arm/mapmisc.dat, gas/arm/mapmisc.s: New.
@
text
@d128 2
a129 1
   Out: 1 if this character ends a line.  */
d243 1
a243 1
    is_end_of_line[(unsigned char) *p] = 1;
@


1.148
log
@2009-01-26  Andrew Stubbs  <ams@@codesourcery.com>

	gas/
	* config/tc-arm.c (attributes_set_explicitly): New array.
	(s_arm_eabi_attribute): Check return value from s_vendor_attribute.
	(cpu_arch): Add ARM_ARCH_V5T.
	(aeabi_set_attribute_int): New function.
	(aeabi_set_attribute_string): New function.
	(aeabi_set_public_attributes): Set attributes according to the user's
	intentions, rather than the actual state of the binary.
	Use aeabi_set_attribute_int and aeabi_set_attribute_string instead of
	bfd_elf_add_proc_attr_int and bfd_elf_add_proc_attr_string.
	Support WMMXv2. Use attribute names instead of numbers.
	* read.c (s_vendor_attribute): Change return type to int.
	Return the tag number that was set.
	* read.h (s_vendor_attribute): Change return type to int.

	gas/testsuite/
	* gas/arm/attr-cpu-directive.d: New file.
	* gas/arm/attr-cpu-directive.s: New file.
	* gas/arm/attr-default.d: New file.
	* gas/arm/attr-march-all.d: New file.
	* gas/arm/attr-march-armv1.d: New file.
	* gas/arm/attr-march-armv2.d: New file.
	* gas/arm/attr-march-armv2a.d: New file.
	* gas/arm/attr-march-armv2s.d: New file.
	* gas/arm/attr-march-armv3.d: New file.
	* gas/arm/attr-march-armv3m.d: New file.
	* gas/arm/attr-march-armv4.d: New file.
	* gas/arm/attr-march-armv4t.d: New file.
	* gas/arm/attr-march-armv4txm.d: New file.
	* gas/arm/attr-march-armv4xm.d: New file.
	* gas/arm/attr-march-armv5.d: New file.
	* gas/arm/attr-march-armv5t.d: New file.
	* gas/arm/attr-march-armv5te.d: New file.
	* gas/arm/attr-march-armv5tej.d: New file.
	* gas/arm/attr-march-armv5texp.d: New file.
	* gas/arm/attr-march-armv5txm.d: New file.
	* gas/arm/attr-march-armv6-m.d: New file.
	* gas/arm/attr-march-armv6.d: New file.
	* gas/arm/attr-march-armv6j.d: New file.
	* gas/arm/attr-march-armv6k.d: New file.
	* gas/arm/attr-march-armv6kt2.d: New file.
	* gas/arm/attr-march-armv6t2.d: New file.
	* gas/arm/attr-march-armv6z.d: New file.
	* gas/arm/attr-march-armv6zk.d: New file.
	* gas/arm/attr-march-armv6zkt2.d: New file.
	* gas/arm/attr-march-armv6zt2.d: New file.
	* gas/arm/attr-march-armv7-a.d: New file.
	* gas/arm/attr-march-armv7-m.d: New file.
	* gas/arm/attr-march-armv7-r.d: New file.
	* gas/arm/attr-march-armv7.d: New file.
	* gas/arm/attr-march-armv7a.d: New file.
	* gas/arm/attr-march-armv7m.d: New file.
	* gas/arm/attr-march-armv7r.d: New file.
	* gas/arm/attr-march-iwmmxt.d: New file.
	* gas/arm/attr-march-iwmmxt2.d: New file.
	* gas/arm/attr-march-xscale.d: New file.
	* gas/arm/attr-mcpu.d: New file.
	* gas/arm/attr-mfpu-arm1020e.d: New file.
	* gas/arm/attr-mfpu-arm1020t.d: New file.
	* gas/arm/attr-mfpu-arm1136jf-s.d: New file.
	* gas/arm/attr-mfpu-arm1136jfs.d: New file.
	* gas/arm/attr-mfpu-arm7500fe.d: New file.
	* gas/arm/attr-mfpu-fpa.d: New file.
	* gas/arm/attr-mfpu-fpa10.d: New file.
	* gas/arm/attr-mfpu-fpa11.d: New file.
	* gas/arm/attr-mfpu-fpe.d: New file.
	* gas/arm/attr-mfpu-fpe2.d: New file.
	* gas/arm/attr-mfpu-fpe3.d: New file.
	* gas/arm/attr-mfpu-maverick.d: New file.
	* gas/arm/attr-mfpu-neon-fp16.d: New file.
	* gas/arm/attr-mfpu-neon.d: New file.
	* gas/arm/attr-mfpu-softfpa.d: New file.
	* gas/arm/attr-mfpu-softvfp+vfp.d: New file.
	* gas/arm/attr-mfpu-softvfp.d: New file.
	* gas/arm/attr-mfpu-vfp.d: New file.
	* gas/arm/attr-mfpu-vfp10-r0.d: New file.
	* gas/arm/attr-mfpu-vfp10.d: New file.
	* gas/arm/attr-mfpu-vfp3.d: New file.
	* gas/arm/attr-mfpu-vfp9.d: New file.
	* gas/arm/attr-mfpu-vfpv2.d: New file.
	* gas/arm/attr-mfpu-vfpv3-d16.d: New file.
	* gas/arm/attr-mfpu-vfpv3.d: New file.
	* gas/arm/attr-mfpu-vfpxd.d: New file.
	* gas/arm/attr-order.d: Update Tag_ARM_ISA_use and Tag_THUMB_ISA_use.
	* gas/arm/attr-override-cpu-directive.d: New file.
	* gas/arm/attr-override-cpu-directive.s: New file.
	* gas/arm/attr-override-mcpu.d: New file.
	* gas/arm/attr-override-mcpu.s: New file.
	* gas/arm/blank.s: New file.
	* gas/arm/eabi_attr_1.d: Update Tag_ARM_ISA_use and Tag_THUMB_ISA_use.

	ld/testsuite/
	* ld-arm/attr-merge-3.attr: Update following gas change.
	* ld-arm/attr-merge-2.attr: Update Tag_ARM_ISA_use and
	Tag_THUMB_ISA_use following gas changes.
	* ld-arm/attr-merge-4.attr: Likewise.
	* ld-arm/attr-merge-5.attr: Likewise.
	* ld-arm/attr-merge-arch-1.attr: Likewise.
	* ld-arm/attr-merge-arch-2.attr: Likewise.
	* ld-arm/attr-merge-unknown-2.d: Likewise.
	* ld-arm/attr-merge-unknown-2r.d: Likewise.
	* ld-arm/attr-merge-unknown-3.d: Likewise.
	* ld-arm/attr-merge-wchar-00-nowarn.d: Likewise.
	* ld-arm/attr-merge-wchar-00.d: Likewise.
	* ld-arm/attr-merge-wchar-02-nowarn.d: Likewise.
	* ld-arm/attr-merge-wchar-02.d: Likewise.
	* ld-arm/attr-merge-wchar-04-nowarn.d: Likewise.
	* ld-arm/attr-merge-wchar-04.d: Likewise.
	* ld-arm/attr-merge-wchar-20-nowarn.d: Likewise.
	* ld-arm/attr-merge-wchar-20.d: Likewise.
	* ld-arm/attr-merge-wchar-22-nowarn.d: Likewise.
	* ld-arm/attr-merge-wchar-22.d: Likewise.
	* ld-arm/attr-merge-wchar-24-nowarn.d: Likewise.
	* ld-arm/attr-merge-wchar-40-nowarn.d: Likewise.
	* ld-arm/attr-merge-wchar-40.d: Likewise.
	* ld-arm/attr-merge-wchar-42-nowarn.d: Likewise.
	* ld-arm/attr-merge-wchar-44-nowarn.d: Likewise.
	* ld-arm/attr-merge-wchar-44.d: Likewise.
	* ld-arm/attr-merge.attr: Likewise.
@
text
@d1923 4
d3126 4
d3301 4
d4646 4
d5094 4
d5476 4
@


1.147
log
@2009-01-19  Andrew Stubbs  <ams@@codesourcery.com>

	bfd/
	* elf-attrs.c (is_default_attr): Support defaultless attributes.
	(bfd_elf_add_obj_attr_int): Get type from _bfd_elf_obj_attrs_arg_type.
	(bfd_elf_add_obj_attr_string): Likewise.
	(bfd_elf_add_obj_attr_int_string): Likewise.
	(_bfd_elf_parse_attributes): Allow for unknown flag bits in type.
	* elf-bfd.h (struct obj_attribute): Document new flag bit.
	* elf32-arm.c (elf32_arm_obj_attrs_arg_type): Specify that
	Tag_nodefaults has no default value.
	(elf32_arm_merge_eabi_attributes): Modify the Tag_nodefaults
	comment to reflect the new state.

	gas/
	* read.c (s_vendor_attribute): Allow for unknown flag bits in type.
@
text
@d2063 3
a2065 2
/* Parse an attribute directive for VENDOR.  */
void
d2108 1
a2108 1
	  return;
d2123 1
a2123 1
	  return;
d2132 1
a2132 1
      return;
d2160 1
a2160 1
  return;
d2164 1
a2164 1
  return;
d2168 1
@


1.146
log
@2009-01-16  Andrew Stubbs  <ams@@codesourcery.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	gas/
	* config/tc-arm.c (arm_copy_symbol_attributes): New function.
	* config/tc-arm.h (arm_copy_symbol_attributes): New prototype.
	(CONVERT_SYMBOLIC_ATTRIBUTE): New define.
	* read.c (s_vendor_attribute): Add support for symbolic tag names.
	Improve string parser.
	* doc/c-arm.texi (ARM Machine Directives): Document
	.eabi_attribute symbolic tag names.

	gas/testsuite/
	* gas/arm/attr-syntax.d: New file.
	* gas/arm/attr-syntax.s: New file.
@
text
@d2126 1
a2126 1
  if (type == 3
d2143 1
a2143 1
  switch (type)
@


1.145
log
@2009-01-15  Andrew Stubbs  <ams@@codesourcery.com>

	bfd/
	* elf-attrs.c (bfd_elf_add_obj_attr_compat): Rename to
	bfd_elf_add_obj_attr_int_string.
	Read Tag_compatibility from its new location in the attribute array,
	rather than the attribute list.
	(_bfd_elf_copy_obj_attributes): bfd_elf_add_obj_attr_compat ->
	bfd_elf_add_obj_attr_int_string.
	(_bfd_elf_parse_attributes): Likewise.
	(_bfd_elf_merge_object_attributes): There's now only one
	Tag_compatibility, and it's in the array, not the list.
	* elf-bfd.h (NUM_KNOWN_OBJ_ATTRIBUTES): Set to 33 to include
	Tag_compatibility.
	(bfd_elf_add_obj_attr_compat): Rename to
	bfd_elf_add_obj_attr_int_string.
	(bfd_elf_add_proc_attr_compat): Rename to
	bfd_elf_add_proc_attr_int_string.
	* elf32-arm.c (elf32_arm_merge_eabi_attributes): Explicitly don't handle
	Tag_compatibility.

	gas/
	* read.c (s_vendor_attribute): bfd_elf_add_obj_attr_compat ->
	bfd_elf_add_obj_attr_int_string.
@
text
@a2071 1
  char saved_char;
d2073 37
a2109 3
  expression (& exp);
  if (exp.X_op != O_constant)
    goto bad;
a2110 1
  tag = exp.X_add_number;
d2135 3
a2137 1
      skip_whitespace(input_line_pointer);
d2140 1
a2140 13
      input_line_pointer++;
      s = input_line_pointer;
      while (*input_line_pointer && *input_line_pointer != '"')
	input_line_pointer++;
      if (*input_line_pointer != '"')
	goto bad_string;
      saved_char = *input_line_pointer;
      *input_line_pointer = 0;
    }
  else
    {
      s = NULL;
      saved_char = 0;
a2157 5
  if (s)
    {
      *input_line_pointer = saved_char;
      input_line_pointer++;
    }
@


1.144
log
@        * read.c (emit_expr): Grow frag before filling it so that
        dot_value remains valid.
@
text
@d2124 1
a2124 1
      bfd_elf_add_obj_attr_compat (stdoutput, vendor, i, s);
@


1.143
log
@	* read.c (read_a_source_file): Rearrange evaluation order when
	looking for '=' to avoid conditional on undefined contents of
	input_line_pointer[1].
@
text
@d3937 3
@


1.142
log
@2008-10-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* read.c (pseudo_set): Don't allow global register symbol only
	if TC_GLOBAL_REGISTER_SYMBOL_OK is undefined.
	* symbols.c (S_SET_EXTERNAL): Likewise.

	* config/tc-mmix.h (TC_GLOBAL_REGISTER_SYMBOL_OK): Defined.

	* doc/internals.texi: Document TC_GLOBAL_REGISTER_SYMBOL_OK.
@
text
@d794 4
a797 4
              else if (input_line_pointer[1] == '='
		       && (c == '='
			   || ((c == ' ' || c == '\t')
			       && input_line_pointer[2] == '=')))
@


1.141
log
@        PR 6926
        * read.c (get_line_sb): Renamed to get_non_macro_line_sb.
        (_find_end_of_line): Add extra parameter indicating if the line is
        inside a macro.  If it is then do not allow the @@ character to be
        treated as a line separator character.
        (read_a_source): Update use of _find_end_of_line.
        (find_end_of_line): Likewise.
        (s_irp): Update use of get_line_sb.
        (s_macro): Likewise.
        (do_repeat): Likewise.
        (get_line_sb): New function.  Like the old version of get_line_sb
        except that it takes an extra parameter indicating whether the
        line is inside a macro.
        (get_macro_line_sb): New function.
@
text
@d3624 1
d3631 1
@


1.140
log
@PR gas/5895
   * read.c (s_mexit): Warn if attempting to exit a macro when not
   inside a macro definition.

   * gas/macros/exit.s: New test case.
   * gas/macros/macros.exp: Run the new test, expect it to produce an
   error result.
@
text
@d223 1
a223 1
static int get_line_sb (sb *);
d225 1
a225 1
static char *_find_end_of_line (char *, int, int);
d533 1
a533 1
      char *eol = find_end_of_line (input_line_pointer, flag_m68k_mri);	\
d926 1
a926 1
		      input_line_pointer = _find_end_of_line (input_line_pointer, flag_m68k_mri, 1);
d2181 1
a2181 1
  err = expand_irp (irpc, 0, &s, &out, get_line_sb);
d2471 1
a2471 1
get_line_sb (sb *line)
d2485 1
a2485 1
  eol = find_end_of_line (input_line_pointer, flag_m68k_mri);
d2497 12
d2533 1
a2533 1
      err = define_macro (0, &s, &label, get_line_sb, file, line, &name);
d2537 1
a2537 1
    err = define_macro (0, &s, NULL, get_line_sb, file, line, &name);
d2943 1
a2943 1
  if (!buffer_and_nest (start, end, &one, get_line_sb))
d5795 2
a5796 1
_find_end_of_line (char *s, int mri_string, int insn ATTRIBUTE_UNUSED)
d5807 7
d5841 1
a5841 1
  return _find_end_of_line (s, mri_string, 0);
@


1.139
log
@gas/

2008-03-03  Denys Vlasenko <vda.linux@@googlemail.com>
	    H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/5543
	* read.c (pseudo_set): Don't allow global register symbol.

	* symbols.c (S_SET_EXTERNAL): Don't allow register symbol
	global.

2008-03-03  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/5543
	* write.c (write_object_file): Don't allow symbols which were
	equated to register.  Stop if there is an error.

gas/testsuite/

2008-03-03  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/5543
	* gas/i386/i386.exp: Run inval-equ-1 and inval-equ-2.

	* gas/i386/inval-equ-1.l: New.
	* gas/i386/inval-equ-1.s: Likewise.
	* gas/i386/inval-equ-2.l: Likewise.
	* gas/i386/inval-equ-2.s: Likewise.
@
text
@d2557 7
a2563 2
  cond_exit_macro (macro_nest);
  buffer_limit = input_scrub_next_buffer (&input_line_pointer);
@


1.138
log
@	* read.c (s_weakref): Don't pass unadorned NULL to concat.
	* config/tc-i386.c (set_cpu_arch, md_parse_option): Likewise.
@
text
@d3607 6
@


1.137
log
@Add mingw I64 support for printing long and long long values
@
text
@d3452 1
a3452 1
			 " => ", S_GET_NAME (symbolP2), NULL);
d3459 2
a3460 1
	      loop = concat (loop, " => ", S_GET_NAME (symp), NULL);
@


1.136
log
@* read.c (s_space): Declare `repeat' as offsetT.
@
text
@d4115 1
d4119 4
@


1.135
log
@gas/
	* dwarf2dbg.c (out_sleb128): Delete.
	(size_fixed_inc_line_addr, emit_fixed_inc_line_addr): New.
	(out_fixed_inc_line_addr): Delete.
	(relax_inc_line_addr, dwarf2dbg_estimate_size_before_relax): Call new
	size_fixed_inc_line_addr if DWARF2_USE_FIXED_ADVANCE_PC is set.
	(dwarf2dbg_convert_frag): Likewise for emit_fixed_inc_line_addr.
	(process_entries): Remove calls to out_fixed_inc_line_addr.  When
	DWARF2_USE_FIXED_ADVANCE_PC is set, call relax_inc_line_addr.
	* read.h (emit_expr_fix): New prototype.
	* read.c (emit_expr): Move code to emit_expr_fix and use it here.
	(emit_expr_fix): New.
testsuite/
	* gas/lns/lns.exp: Run new lns-big-delta test for targets that set
	DWARF2_USE_FIXED_ADVANCE_PC.
	* gas/lns/lns-big-delta.s: New.
	* gas/lns/lns-big-delta.d: New.
@
text
@d3171 1
a3171 1
	  long repeat;
@


1.134
log
@include
	* coff/pe.h (COFF_ENCODE_ALIGNMENT) Define.

gas
	* read.c (ALIGN_LIMIT): Rename to ...
	(TC_ALIGN_LIMIT): Guard against prior definition.
	* config/tc-i386.h (TC_ALIGN_LIMIT)[TE_PE]: Define.

bfd
	* pe-i386.c (COFF_SECTION_ALIGNMENT_ENTRIES): Let .data, .text
	 and .bss section use the default.
	* pei-i386.c (COFF_SECTION_ALIGNMENT_ENTRIES): Likewise.

ld/testsuite
	* ld-scripts/align.exp: Enable for PECOFF.
	* ld-scripts/alignof.exp: Likewise.
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
d4178 7
a4184 2
    {
      memset (p, 0, nbytes);
d4186 1
a4186 1
      /* Now we need to generate a fixS to record the symbol value.  */
d4189 1
a4189 1
      TC_CONS_FIX_NEW (frag_now, p - frag_now->fr_literal, nbytes, exp);
d4191 4
d4196 16
a4211 23
	bfd_reloc_code_real_type r;

	switch (nbytes)
	  {
	  case 1:
	    r = BFD_RELOC_8;
	    break;
	  case 2:
	    r = BFD_RELOC_16;
	    break;
	  case 4:
	    r = BFD_RELOC_32;
	    break;
	  case 8:
	    r = BFD_RELOC_64;
	    break;
	  default:
	    as_bad (_("unsupported BFD relocation size %u"), nbytes);
	    r = BFD_RELOC_32;
	    break;
	  }
	fix_new_exp (frag_now, p - frag_now->fr_literal, (int) nbytes, exp,
		     0, r);
d4213 3
a4216 1
    }
@


1.133
log
@Remove duplicate definitions of the md_atof() function
@
text
@d1279 3
a1281 2

#define ALIGN_LIMIT (stdoutput->arch_info->bits_per_address - 1)
d1286 1
a1286 1
  unsigned int align_limit = ALIGN_LIMIT;
@


1.132
log
@	* read.c (do_s_func): Check asprintf return status.
	* stabs.c (stabs_generate_asm_func): Likewise.
	(stabs_generate_asm_endfunc): Likewise.
@
text
@d3300 1
a3300 1
      know (flen > 0);
d4605 1
a4605 1
	  know (length > 0);
@


1.131
log
@* read.c (potable): Add string8, string16, string32 and string64. Add bit size for stringer function.
 (stringer_append_char): New.
 (stringer): Use stringer_append_char().
* config/obj-coff.c (obj_coff_ident): Add bit size for stringer function.
* config/obj-elf.c (obj_elf_ident): Likewise.
* config/tc-alpha.c (s_alpha_stringer): Likewise.
* config/tc-dlx.c (dlx_pseudo_table): Likewise.
* config/tc-hppa.c (pa_stringer): Likewise.
* config/tc-ia64.c (md_pseudo_table, pseudo_opcode): Likewise.
* config/tc-m68hc11.c (md_pseudo_table): Likewise.
* config/tc-mcore.c (md_pseudo_table): Likewise.
* config/tc-mips.c (mips_pseudo_table): Likewise.
* config/tc-spu.c (md_pseudo_table): Likewise.
* config/tc-s390.c (md_pseudo_table): Likewise. Replace '2' by '1'.
* doc/as.texinfo (ABORT): Fix identing.
  (String): Document new string8, string16, string32, string64 functions.
* NEWS: Mention the new feature.

* testsuite/gas/all/gas.exp: Include new test "strings".
* testsuite/gas/all/string.s: New
* testsuite/gas/all/string.d: New.
@
text
@d5674 4
a5677 1
	    asprintf (&label, "%s%s", default_prefix, name);
d5684 4
a5687 1
		asprintf (&label, "%c%s", leading_char, name);
@


1.130
log
@	PR gas/5026
	* read.c (emit_expr): Only use long long if required and available.
@
text
@d273 2
a274 2
  {"ascii", stringer, 0},
  {"asciz", stringer, 1},
d419 5
a423 1
  {"string", stringer, 1},
d4968 34
a5001 1
/* We read 0 or more ',' separated, double-quoted strings.
d5003 4
a5006 1
   check it.  */
d5009 1
a5009 3
stringer (/* Worker to do .ascii etc statements.  */
	  /* Checks end-of-line.  */
	  register int append_zero	/* 0: don't append '\0', else 1.  */)
d5011 3
a5013 1
  register unsigned int c;
d5051 1
d5053 2
a5054 3
	    {
	      FRAG_APPEND_1_CHAR (c);
	    }
d5056 2
a5057 3
	    {
	      FRAG_APPEND_1_CHAR (0);
	    }
d5084 1
a5084 1
	  FRAG_APPEND_1_CHAR (c);
d5086 2
a5087 3
	    {
	      as_bad (_("expected <nn>"));
	    }
d5099 1
a5099 1
}				/* stringer() */
@


1.129
log
@PR gas/5026
* read.c (emit_expr): Use unsigned long long values in warning message about
  truncated expressions.
@
text
@d4109 1
d4112 4
@


1.128
log
@Switch to GPLv3
@
text
@d4109 2
a4110 2
	  as_warn (_("value 0x%lx truncated to 0x%lx"),
		   (unsigned long) get, (unsigned long) use);
@


1.127
log
@bfd:
	* elf-attrs.c: New.
	* Makefile.am (BFD32_BACKENDS): Add elf-attrs.lo.
	(BFD32_BACKENDS_CFILES): Add elf-attrs.c.
	(elf-attrs.lo): Generate dependencies.
	* Makefile.in: Regenerate.
	* configure.in (elf): Add elf-attrs.lo.
	* configure: Regenerate.
	* elf-bfd.h (struct elf_backend_data): Add entries for object
	attributes.
	(NUM_KNOWN_OBJ_ATTRIBUTES, obj_attribute, obj_attribute_list,
	OBJ_ATTR_PROC, OBJ_ATTR_GNU, OBJ_ATTR_FIRST, OBJ_ATTR_LAST,
	Tag_NULL, Tag_File, Tag_Section, Tag_Symbol, Tag_compatibility):
	New.
	(struct elf_obj_tdata): Add entries for object attributes.
	(elf_known_obj_attributes, elf_other_obj_attributes,
	elf_known_obj_attributes_proc, elf_other_obj_attributes_proc):
	New.
	(bfd_elf_obj_attr_size, bfd_elf_set_obj_attr_contents,
	bfd_elf_get_obj_attr_int, bfd_elf_add_obj_attr_int,
	bfd_elf_add_proc_attr_int, bfd_elf_add_obj_attr_string,
	bfd_elf_add_proc_attr_string, bfd_elf_add_obj_attr_compat,
	bfd_elf_add_proc_attr_compat, _bfd_elf_attr_strdup,
	_bfd_elf_copy_obj_attributes, _bfd_elf_obj_attrs_arg_type,
	_bfd_elf_parse_attributes, _bfd_elf_merge_object_attributes): New.
	* elf.c (_bfd_elf_copy_private_bfd_data): Copy object attributes.
	(bfd_section_from_shdr): Handle attributes sections.
	* elflink.c (bfd_elf_final_link): Handle attributes sections.
	* elfxx-target.h (elf_backend_obj_attrs_vendor,
	elf_backend_obj_attrs_section, elf_backend_obj_attrs_arg_type,
	elf_backend_obj_attrs_section_type): New.
	(elfNN_bed): Update.
	* elf32-arm.c (NUM_KNOWN_ATTRIBUTES, aeabi_attribute,
	aeabi_attribute_list): Remove.
	(struct elf32_arm_obj_tdata): Remove object attributes fields.
	(check_use_blx, bfd_elf32_arm_set_vfp11_fix, using_thumb2,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_eabi_attributes):
	Update for new object attributes interfaces.
	(uleb128_size, is_default_attr, eabi_attr_size,
	elf32_arm_eabi_attr_size, write_uleb128, write_eabi_attribute,
	elf32_arm_set_eabi_attr_contents, elf32_arm_bfd_final_link,
	elf32_arm_new_eabi_attr, elf32_arm_get_eabi_attr_int,
	elf32_arm_add_eabi_attr_int, attr_strdup,
	elf32_arm_add_eabi_attr_string, elf32_arm_add_eabi_attr_compat,
	copy_eabi_attributes, elf32_arm_parse_attributes): Remove.  Moved
	to generic code in elf-attrs.c.
	(elf32_arm_obj_attrs_arg_type): New.
	(elf32_arm_fake_sections): Do not handle .ARM.attributes.
	(elf32_arm_section_from_shdr): Do not handle SHT_ARM_ATTRIBUTES.
	(bfd_elf32_bfd_final_link): Remove.
	(elf_backend_obj_attrs_vendor, elf_backend_obj_attrs_section,
	elf_backend_obj_attrs_arg_type,
	elf_backend_obj_attrs_section_type): New.
	* elf32-bfin.c (bfin_elf_copy_private_bfd_data): Copy object
	attributes.
	* elf32-frv.c (frv_elf_copy_private_bfd_data): Likewise.
	* elf32-iq2000.c (iq2000_elf_copy_private_bfd_data): Likewise.
	* elf32-mep.c (mep_elf_copy_private_bfd_data): Likewise.
	* elf32-mt.c (mt_elf_copy_private_bfd_data): Likewise.
	* elf32-sh.c (sh_elf_copy_private_data): Likewise.
	* elf64-sh64.c (sh_elf64_copy_private_data_internal): Likewise.

binutils:
	* readelf.c (display_gnu_attribute): New.
	(process_arm_specific): Rearrange as process_attributes.
	(process_arm_specific): Replace by wrapper of process_attributes.

gas:
	* as.c (create_obj_attrs_section): New.
	(main): Call create_obj_attrs_section for ELF.
	* read.c (s_gnu_attribute, skip_whitespace, skip_past_char,
	skip_past_comma, s_vendor_attribute): New.
	(potable): Add gnu_attribute for ELF.
	* read.h (s_vendor_attribute): Declare.
	* config/tc-arm.c (s_arm_eabi_attribute): Replace by wrapper
	round s_vendor_attribute.
	(aeabi_set_public_attributes): Update for new attributes
	interfaces.
	(arm_md_end): Remove attributes contents setting now done
	generically.

include/elf:
	* arm.h (elf32_arm_add_eabi_attr_int,
	elf32_arm_add_eabi_attr_string, elf32_arm_add_eabi_attr_compat,
	elf32_arm_get_eabi_attr_int, elf32_arm_set_eabi_attr_contents,
	elf32_arm_eabi_attr_size, Tag_NULL, Tag_File, Tag_Section,
	Tag_Symbol, Tag_compatibility): Remove.
	* common.h (SHT_GNU_ATTRIBUTES): Define.

ld:
	* emulparams/armelf.sh (OTHER_SECTIONS): Remove .ARM.attributes.
	(ATTRS_SECTIONS): Define.
	* scripttempl/elf.sc, scripttempl/elf32sh-symbian.sc,
	scripttempl/elf_chaos.sc, scripttempl/elfi370.sc,
	scripttempl/elfxtensa.sc: Handle ATTRS_SECTIONS.
@
text
@d6 1
a6 1
This file is part of GAS, the GNU Assembler.
d8 14
a21 14
GAS is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GAS is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GAS; see the file COPYING.  If not, write to the Free
Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
02110-1301, USA.  */
@


1.126
log
@	* read.c (read_a_source_file): Skip multiple spaces to
	cover hack in mmix md_start_line_hook which overwrites a
	colon with a space.  Delete sermon and needless assertion.
@
text
@d216 3
d345 3
d2042 114
@


1.125
log
@gas/
	* expr.c (expr): Assert on rankarg, not rank which can be unsigned.
	* read.c (read_a_source_file): Remove buffer_limit[-1] assertion.
	Don't skip over NUL char.
	(pseudo_set): Set X_op for registers to O_register.
	* symbols.c (symbol_clone): Remove assertion that sym is defined.
	(resolve_symbol_value): Resolve O_register symbols.
	* config/tc-i386.c (parse_real_register): Don't use i386_float_regtab.
	Instead find st(0) by hash lookup.
	* config/tc-ppc.c (ppc_macro): Warning fix.
opcodes/
	* i386-opc.c (i386_float_regtab, i386_float_regtab_size): Delete.
	Move contents to..
	(i386_regtab): ..here.
	* i386-opc.h (i386_float_regtab, i386_float_regtab_size): Delete.
@
text
@d698 3
a700 9
	     Each test is independent of all other tests at the (top) level.
	     PLEASE make a compiler that doesn't use this assembler.
	     It is crufty to waste a compiler's time encoding things for this
	     assembler, which then wastes more time decoding it.
	     (And communicating via (linear) files is silly!
	     If you must pass stuff, please pass a tree!)  */
	  if ((c = *input_line_pointer++) == '\t'
	      || c == ' '
	      || c == '\f')
d702 1
a702 2

	  know (c != ' ');	/* No further leading whitespace.  */
@


1.124
log
@	* doc/as.texinfo (Reloc): Document.
	* read.c (potable): Add "reloc".
	(s_reloc): New function.
	* write.c (reloc_list): New global var.
	(resolve_reloc_expr_symbols): New function.
	(write_object_file): Call it.
	(write_relocs): Process reloc_list.
	* write.h (struct reloc_list): New.
	(reloc_list): Declare.
@
text
@a609 2
      know (buffer_limit[-1] == '\n');	/* Must have a sentinel.  */

d706 1
a706 2
	      || c == '\f'
	      || c == 0)
d3491 1
@


1.123
log
@* app.c (do_scrub_chars): Recognize comments after # line "file".
* read.c (get_linefile_number): New.
(s_app_line): Accept ill-formed .linefile lines as comments.
@
text
@d216 1
d395 1
d3674 107
@


1.122
log
@* app.c (do_scrub_chars): Turn #<line>"file"flags into .linefile.
* as.h (new_logical_line_flags): New.
* input-scrub.c (new_logical_line): Turned into wrapper for...
(new_logical_line_flags): this.  Handle flags.
* read.c (potable): Add linefile.  Adjust appline argument.
(s_app_file): Fake .appfiles no more.
(s_app_line): For .linefile, accept file name and flags.
@
text
@d1701 13
d1722 1
d1726 9
a1734 1
  l = get_absolute_expression () - 1;
a1750 1
      char *file = NULL;
d1755 4
a1758 1
	  file = demand_copy_string (&length);
d1764 1
a1764 1
	      while ((this_flag = get_absolute_expression ()))
d1799 3
d1805 3
a1807 1
      new_logical_line_flags (file, l, flags);
d1809 2
a1810 2
      if (listing)
	listing_source_line (l);
d1812 1
d1814 4
a1817 1
  demand_empty_rest_of_line ();
@


1.121
log
@* read.c (s_align): Initialize the 'stopc' variable to prevent
  compiler complaints about it being used without being initialized.
 (s_comm_internal, s_mri_common, s_fail, s_globl, s_space,
  s_float_space, s_struct, cons_worker, equals): Likewise.
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
d332 1
a332 1
  {"appline", s_app_line, 0},
d367 1
a1684 3
      /* If this is a fake .appfile, a fake newline was inserted into
	 the buffer.  Passing -2 to new_logical_line tells it to
	 account for it.  */
d1686 1
a1686 1
	= (!new_logical_line (s, appfile ? -2 : -1) && appfile);
d1707 1
a1707 1
s_app_line (int ignore ATTRIBUTE_UNUSED)
d1728 51
a1778 1
      new_logical_line ((char *) NULL, l);
@


1.120
log
@PR/2756
* read.c (read_a_source_file): Ignore unknown text after line comment
  character.  Fix misleading comment.
@
text
@d1285 1
a1285 1
  char stopc;
d1429 1
a1429 1
  char stopc;
d1541 1
a1541 1
  char stopc;
d1810 1
a1810 1
  char stopc;
d1932 1
a1932 1
  char stopc;
d2881 1
a2881 1
  char stopc;
d3057 1
a3057 1
  char stopc;
d3134 1
a3134 1
  char stopc;
d3517 1
a3517 1
  char stopc;
d5013 1
a5013 1
  char stopc;
@


1.119
log
@	* read.c (s_struct): Use IS_ELF.
	* config/tc-mips.c (md_begin, mips16_mark_labels, mips_ip,
	md_parse_option, s_change_sec, pic_need_relax, mips_fix_adjustable,
	tc_gen_reloc, mips_frob_file_after_relocs, s_mips_end, s_mips_frame,
	s_mips_mask): Likewise.
@
text
@a1009 1
	      bump_line_counters ();
d1012 6
a1017 1
		continue;	/* We ignore it */
d1116 1
a1116 1
	  /* Report unknown char as ignored.  */
@


1.118
log
@	* read.c (s_struct): Handle ELF section changing.
	* config/tc-mips.c (s_align): Leave enabling auto-align to the
	generic code.
	(s_change_sec): Try section changing only if we output ELF.
@
text
@d3138 1
a3138 1
  if (OUTPUT_FLAVOR == bfd_target_elf_flavour)
@


1.117
log
@remove some duplicate #include's.
@
text
@d3135 6
@


1.116
log
@	* listing.c (listing_listing): Remove useless loop.
	* macro.c (macro_expand): Remove is_positional local variable.
	* read.c (s_comm_internal): Simplify `if' condition 1 || x -> 1
	and simplify surrounding expressions, where possible.
	(assign_symbol): Likewise.
	(s_weakref): Likewise.
	* symbols.c (colon): Likewise.
@
text
@a40 1
#include "listing.h"
@


1.115
log
@gas/
2005-11-17  Jan Beulich  <jbeulich@@novell.com>


	* symbols.h (S_CLEAR_VOLATILE): Declare.
	* symbols.c (colon): Also accept redefinable symbols for
	redefinition. Clone them before modifying.
	(S_CLEAR_VOLATILE): Define.
	* cond.c (s_ifdef): Also test for equated symbols.
	* read.c (s_comm_internal): Also exclude non-redefinable
	equated symbols. Clone redefinable ones before modifying.
	(s_weakref): Clone redefinable symbols before modifying.
	* doc/internals.texi: Document sy_volatile, sy_forward_ref,
	S_IS_VOLATILE, S_SET_VOLATILE, S_CLEAR_VOLATILE,
	S_IS_FORWARD_REF, and S_SET_FORWARD_REF.

gas/testsuite/
2005-11-17  Jan Beulich  <jbeulich@@novell.com>

	* gas/all/cond.s: Also check ifdef works on equates and
	commons.
	* gas/all/cond.l: Adjust.
	* gas/all/redef2.s: Also test redefining equate to label.
	* gas/all/redef2.d: Adjust.
	* gas/all/redef3.[sd]: New.
	* gas/all/redef4.s: New.
	* gas/all/redef5.s: New.
	* gas/elf/redef.s: New, copied from original gas/all/redef2.s.
	* gas/elf/redef.d: Remove #source.
	* gas/all/gas.exp: Remove exclusion of iq2000-*-* from and
	adjust xfails for redefinition tests. Run new tests. Exclude
	alpha*-*-*, mips*-*-*, *c54x*-*-* from weakref tests.
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
d1481 1
a1481 4
      /* This could be avoided when the symbol wasn't used so far, but
	 the comment in struc-symbol.h says this flag isn't reliable.  */
      if (1 || !symbol_used_p (symbolP))
	symbolP = symbol_clone (symbolP, 1);
d2812 1
a2812 4
      else if (S_IS_VOLATILE (symbolP)
	  /* This could be avoided when the symbol wasn't used so far, but
	     the comment in struc-symbol.h says this flag isn't reliable.  */
	  && (1 || symbol_used_p (symbolP)))
d3183 1
a3183 1
      if(!S_IS_VOLATILE (symbolP))
d3190 1
a3190 4
      /* This could be avoided when the symbol wasn't used so far, but
	 the comment in struc-symbol.h says this flag isn't reliable.  */
      if (1 || !symbol_used_p (symbolP))
	symbolP = symbol_clone (symbolP, 1);
@


1.114
log
@	* config/tc-ppc.c (ppc_pe_comm): Set bfd_com_section segment.
	* config/tc-alpha.c (s_alpha_comm): Likewise.  Also, remove
	redundant check.
	* read.c (s_lsym): Remove non-BFD assembler sym handling.
@
text
@d1470 2
a1471 1
  if (S_IS_DEFINED (symbolP) && !S_IS_COMMON (symbolP))
d1473 16
a1488 5
      symbolP = NULL;
      as_bad (_("symbol `%s' is already defined"), name);
      *p = c;
      ignore_rest_of_line ();
      goto out;
d3189 12
a3200 4
      as_bad (_("symbol `%s' is already defined"), name);
      *end_name = delim;
      ignore_rest_of_line ();
      return;
@


1.113
log
@	* read.c (s_comm_internal): Set bfd_com_section segment.
	(s_mri_common): Likewise.
	* write.c (write_object_file): Remove non-BFD assembler common
	sym handling.
@
text
@d2238 1
a2238 9
  /* FIXME-SOON I pulled a (&& symbolP->sy_other == 0 &&
     symbolP->sy_desc == 0) out of this test because coff doesn't have
     those fields, and I can't see when they'd ever be tripped.  I
     don't think I understand why they were here so I may have
     introduced a bug. As recently as 1.37 didn't have this test
     anyway.  xoxorich.  */

  if (S_GET_SEGMENT (symbolP) == undefined_section
      && S_GET_VALUE (symbolP) == 0)
@


1.112
log
@gas/ChangeLog:
* read.c (s_weakref): Do not permit redefinitions.
* symbols.c (colon): Do not permit redefinitions of equated
symbols.
gas/testsuite/ChangeLog:
* gas/all/gas.exp: Remove weakref xfail.  Run weakref4.s.
* gas/all/weakref1.s: Move redefinition bits to...
* gas/all/weakref4.s: ... new file.
* gas/all/weakref1.d: Remove command moved to weakref1u.  Adjust
remaining command for leading tabs.  Regenerate.
* gas/all/weakref1l.d: Regenerate.
* gas/all/weakref1u.d: Likewise.
* gas/all/wealref1w.d: Likewise.
@
text
@d1493 1
d1587 1
@


1.111
log
@gas/
2005-10-27  Jan Beulich  <jbeulich@@novell.com>

	* read.c (assign_symbol): Also consider equates already defined.
	* symbols.c (symbol_clone): Also clone the underlying BFD symbol.
	* config/obj-coff.h (obj_symbol_clone_hook): New.
	(coff_obj_symbol_clone_hook): Declare.
	* config/obj-coff.c (coff_obj_symbol_clone_hook): New.

gas/testsuite/
2005-10-27  Jan Beulich  <jbeulich@@novell.com>

	* gas/all/gas.exp: Don't xfail equiv1 test anymore.
@
text
@d3181 8
@


1.110
log
@gas/ChangeLog:
* read.c (potable): Add weakref.
(s_weakref): New.
* read.h (s_weakref): Declare.
* struc-symbol.h (struct symbol): Add sy_weakrefr and sy_weakrefd.
* symbols.c (colon): Clear weakrefr.
(symbol_find_exact): Rename to, and reimplement in terms of...
(symbol_find_exact_noref): ... new function.
(symbol_find): Likewise...
(symbol_find_noref): ... ditto.
(resolve_symbol_value): Resolve weakrefr without setting their
values.
(S_SET_WEAK): Call hook.
(S_GET_VALUE): Follow weakref link.
(S_SET_VALUE): Clear weakrefr.
(S_IS_WEAK): Follow weakref link.
(S_IS_WEAKREFR, S_SET_WEAKREFR, S_CLEAR_WEAKREFR): New.
(S_IS_WEAKREFD, S_SET_WEAKREFD, S_CLEAR_WEAKREFD): New.
(symbol_set_value_expression, symbol_set_frag): Clear weakrefr.
(symbol_mark_used): Follow weakref link.
(print_symbol_value_1): Print weak, weakrefr and weakrefd.
* symbols.h (symbol_find_noref, symbol_find_exact_noref): Declare.
(S_IS_WEAKREFR, S_SET_WEAKREFR, S_CLEAR_WEAKREFR): Declare.
(S_IS_WEAKREFD, S_SET_WEAKREFD, S_CLEAR_WEAKREFD): Declare.
* write.c (adust_reloc_syms): Follow weakref link.  Do not
complain if target is undefined.
(write_object_file): Likewise.  Remove weakrefr symbols.  Drop
unreferenced weakrefd symbols.
* config/obj-coff.c (obj_frob_symbol): Do not force WEAKREFD
symbols EXTERNAL.
(pecoff_obj_set_weak_hook, pecoff_obj_clear_weak_hook): New.
* config/obj-coff.h (obj_set_weak_hook, obj_clear_weak_hook): Define.
* doc/as.texinfo: Document weakref.
* doc/internals.texi: Document new struct members, internal
functions and hooks.
gas/testsuite/ChangeLog:
* gas/all/weakref1.s, gas/all/weakref1.d: New test.
* gas/all/weakref1g.d, gas/all/weakref1l.d: New tests.
* gas/all/weakref1u.d, gas/all/weakref1w.d: New tests.
* gas/all/weakref2.s, gas/all/weakref3.s: New tests.
* gas/all/gas.exp: Run new tests.
@
text
@d2797 1
a2797 1
  if (S_IS_DEFINED (symbolP))
@


1.109
log
@This adjusts equate handling by
- allowing true forward references (which will always assume the referenced
  symbols have at the point of use) through the new .eqv pseudo-op and the
  new == operator
- disallowing changing .equiv-generated equates (so that the protection this
  provides is both forward and backward)
- snapshotting equates when their value gets changed so that previous uses
  don't get affected by the new value.
- allowing expressions in places where absolute expressions (or register
  names) are needed which were not completely resolvable at the point of
  their definition but which are fully resolvable at the point of use

In addition it fixes PR/288.
@
text
@d437 1
d3154 118
@


1.108
log
@	* read.c (pseudo_set): Don't set undefined symbols to expr_section.
@
text
@d326 1
d445 1
a445 1
  expression (exp);
d791 8
d2222 1
a2222 1
  expression (&exp);
d2755 1
a2755 1
assign_symbol (char *name, int no_reassign)
d2796 23
a2818 5
  /* Permit register names to be redefined.  */
  if (no_reassign
      && S_IS_DEFINED (symbolP)
      && S_GET_SEGMENT (symbolP) != reg_section)
    as_bad (_("symbol `%s' is already defined"), name);
d2823 4
a2826 3
/* Handle the .equ, .equiv and .set directives.  If EQUIV is 1, then
   this is .equiv, and it is an error if the symbol is already
   defined.  */
d2948 1
d2964 3
d3220 4
a3223 1
  (void) expression (&exp);
d3237 1
d3284 1
a3284 1
      else if (seg != undefined_section)
d4877 2
d4886 1
a4886 1
  assign_symbol (sym_name, !reassign);
@


1.107
log
@	* read.c (pseudo_set): Set segment of expression syms to expr_section.
@
text
@d3262 4
a3265 1
      /* Fall thru */
@


1.106
log
@	* README-vms: Delete.
	* config-gas.com: Delete.
	* makefile.vms: Delete.
	* vmsconf.sh: Delete.
	* config/atof-tahoe.c: Delete.
	* config/m88k-opcode.h: Delete.
	* config/obj-bout.c: Delete.
	* config/obj-bout.h: Delete.
	* config/obj-hp300.c: Delete.
	* config/obj-hp300.h: Delete.
	* config/tc-a29k.c: Delete.
	* config/tc-a29k.h: Delete.
	* config/tc-h8500.c: Delete.
	* config/tc-h8500.h: Delete.
	* config/tc-m88k.c: Delete.
	* config/tc-m88k.h: Delete.
	* config/tc-tahoe.c: Delete.
	* config/tc-tahoe.h: Delete.
	* config/tc-tic80.c: Delete.
	* config/tc-tic80.h: Delete.
	* config/tc-w65.c: Delete.
	* config/tc-w65.h: Delete.
	* config/te-aux.h: Delete.
	* config/te-delt88.h: Delete.
	* config/te-delta.h: Delete.
	* config/te-dpx2.h: Delete.
	* config/te-hp300.h: Delete.
	* config/te-ic960.h: Delete.
	* config/vms-a-conf.h: Delete.
	* doc/c-a29k.texi: Delete.
	* doc/c-h8500.texi: Delete.
	* doc/c-m88k.texi: Delete.
	* README: Remove obsolete examples, and list of supported targets.
	* Makefile.am: Remove a29k, h8500, m88k, tahoe, tic80, w65,
	bout and hp300 support.
	(DEP_FLAGS): Don't define BFD_ASSEMBLER.
	* configure.in: Remove --enable-bfd-assembler, need_bfd,
	primary_bfd_gas.
	* configure.tgt: Remove a29k, h8300-coff, h8500-*, i960 non-elf,
	m68k non bfd, m88k, or32-coff, tic80-*, vax non-bfd, w65k-*, *-nindy.
	* as.c: Remove all non-BFD_ASSEMBLER code, support for above targets.
	* as.h: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
	* input-file.c: Likewise.
	* listing.c: Likewise.
	* literal.c: Likewise.
	* messages.c: Likewise.
	* obj.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* stabs.c: Likewise.
	* struc-symbol.h: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* symbols.c: Likewise.
	* symbols.h: Likewise.
	* tc.h: Likewise.
	* write.c: Likewise.
	* write.h: Likewise.
	* config/aout_gnu.h: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-aout.h: Likewise.
	* config/obj-coff.c: Likewise.
	* config/obj-coff.h: Likewise.
	* config/obj-evax.h: Likewise.
	* config/obj-ieee.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-crx.h: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-d30v.h: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-fr30.h: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-hppa.h: Likewise.
	* config/tc-i370.h: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i860.h: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ip2k.h: Likewise.
	* config/tc-iq2000.h: Likewise.
	* config/tc-m32c.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m68k.h: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-maxq.h: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mn10200.h: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-mn10300.h: Likewise.
	* config/tc-ms1.h: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-msp430.h: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-ns32k.h: Likewise.
	* config/tc-openrisc.h: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.h: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic4x.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-vax.h: Likewise.
	* config/tc-xstormy16.h: Likewise.
	* config/tc-xtensa.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-z8k.h: Likewise.
	* config/vms-a-conf.h
	* doc/Makefile.am: Likewise.
	* doc/all.texi: Likewise.
	* doc/as.texinfo: Likewise.
	* doc/Makefile.in: Regenerate.
	* Makefile.in: Regenerate.
	* configure: Regenerate.
	* config.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d3265 2
a3266 3
      /* The value is some complex expression.
	 Set segment and frag back to that of a newly created symbol.  */
      S_SET_SEGMENT (symbolP, undefined_section);
@


1.105
log
@(s_app_line): Accept a line number of 0 for compatibility with gcc's output
for assembler-with-cpp files.
@
text
@a74 1
/* The m88k unfortunately uses @@ as a label beginner.  */
a99 1
/* The a29k assembler does not permits labels to start with $.  */
a246 1
#ifdef BFD_ASSEMBLER
a260 1
#endif
d822 2
a823 2
		      /* The MRI assembler and the m88k use pseudo-ops
			 without a period.  */
a1263 1
#ifdef BFD_ASSEMBLER
a1264 3
#else
#define ALIGN_LIMIT 15
#endif
a1443 1
#ifdef BFD_ASSEMBLER
a1444 1
#endif
a2007 1
#ifdef BFD_ASSEMBLER
a2036 3
#else /* ! defined (BFD_ASSEMBLER) */
  as_warn (_(".linkonce is not supported for this object file format"));
#endif /* ! defined (BFD_ASSEMBLER) */
a2058 1
#ifdef BFD_ASSEMBLER
a2061 1
#endif
d2474 1
a2474 2
   'M' (mixed), or 'R' (romable).  If BFD_ASSEMBLER is defined, the
   flags will be set in the section.  */
a2527 1
#ifdef BFD_ASSEMBLER
a2545 1
#endif
a3184 3
#if (defined (OBJ_AOUT) || defined (OBJ_BOUT)) && ! defined (BFD_ASSEMBLER)
  int ext;
#endif /* OBJ_AOUT or OBJ_BOUT */
a3215 3
#if (defined (OBJ_AOUT) || defined (OBJ_BOUT)) && ! defined (BFD_ASSEMBLER)
  ext = S_IS_EXTERNAL (symbolP);
#endif /* OBJ_AOUT or OBJ_BOUT */
a3271 7

#if (defined (OBJ_AOUT) || defined (OBJ_BOUT)) && ! defined (BFD_ASSEMBLER)
  if (ext)
    S_SET_EXTERNAL (symbolP);
  else
    S_CLEAR_EXTERNAL (symbolP);
#endif /* OBJ_AOUT or OBJ_BOUT */
d3691 1
a3691 8
      /* Now we need to generate a fixS to record the symbol value.
	 This is easy for BFD.  For other targets it can be more
	 complex.  For very complex cases (currently, the HPPA and
	 NS32K), you can define TC_CONS_FIX_NEW to do whatever you
	 want.  For simpler cases, you can define TC_CONS_RELOC to be
	 the name of the reloc code that should be stored in the fixS.
	 If neither is defined, the code uses NO_RELOC if it is
	 defined, and otherwise uses 0.  */
a3692 1
#ifdef BFD_ASSEMBLER
a3721 18
#else
#ifdef TC_CONS_FIX_NEW
      TC_CONS_FIX_NEW (frag_now, p - frag_now->fr_literal, nbytes, exp);
#else
      /* Figure out which reloc number to use.  Use TC_CONS_RELOC if
	 it is defined, otherwise use NO_RELOC if it is defined,
	 otherwise use 0.  */
#ifndef TC_CONS_RELOC
#ifdef NO_RELOC
#define TC_CONS_RELOC NO_RELOC
#else
#define TC_CONS_RELOC 0
#endif
#endif
      fix_new_exp (frag_now, p - frag_now->fr_literal, (int) nbytes, exp, 0,
		   TC_CONS_RELOC);
#endif /* TC_CONS_FIX_NEW */
#endif /* BFD_ASSEMBLER */
d5152 1
a5152 4
	      char leading_char = 0;
#ifdef BFD_ASSEMBLER
	      leading_char = bfd_get_symbol_leading_char (stdoutput);
#endif
@


1.104
log
@gas/
2005-05-17  Jan Beulich  <jbeulich@@novell.com>

	* read.c (_find_end_of_line): New.
	(find_end_of_line): New.
	(HANDLE_CONDITIONAL_ASSEMBLY): Use it.
	(read_a_source_file): Use it.
	(s_globl): Use it.
	(s_macro): Use it.
	(get_line_sb): Use it.
	(s_errwarn): Replace discard_rest_of_line by ignore_rest_of_line.
	(s_comm_internal): Likewise.
	(s_lsym): Likewise.
	(s_macro): Likewise.
	(s_ignore): Use ignore_rest_of_line.
	* read.h (find_end_of_line): Prototype.
	(discard_rest_of_line): Remove prototype. #define to
	ignore_rest_of_line.

gas/testsuite/
2005-05-17  Jan Beulich  <jbeulich@@novell.com>

	* gas/mmix/err-byte1.s: Adjust expected error text on line 10.
@
text
@d1701 2
a1702 1
  if (l < 0)
d1704 8
a1711 1
       Besides, it's silly.  */
@


1.103
log
@gas/
2005-05-10  Jan Beulich  <jbeulich@@novell.com>

	* read.c (s_macro): Move local variable 'local' to smaller scope.
	Call sb_kill on it when done.
@
text
@d224 1
d523 5
a527 3
      while (!is_end_of_line[(unsigned char) *input_line_pointer++])	\
	if (input_line_pointer == buffer_limit)				\
	  break;							\
d725 1
a725 3
		  for (s = input_line_pointer - 1; *s; ++s)
		    if (is_end_of_line[(unsigned char) *s])
		      break;
a914 5
		      int inquote = 0;
#ifdef QUOTES_IN_INSN
		      int inescape = 0;
#endif

d918 1
a918 20
		      while (!is_end_of_line[(unsigned char) *input_line_pointer]
			     || inquote
#ifdef TC_EOL_IN_INSN
			     || TC_EOL_IN_INSN (input_line_pointer)
#endif
			     )
			{
			  if (flag_m68k_mri && *input_line_pointer == '\'')
			    inquote = !inquote;
#ifdef QUOTES_IN_INSN
			  if (inescape)
			    inescape = 0;
			  else if (*input_line_pointer == '"')
			    inquote = !inquote;
			  else if (*input_line_pointer == '\\')
			    inescape = 1;
#endif
			  input_line_pointer++;
			}

d1439 1
a1439 1
      discard_rest_of_line ();
d1765 1
a1765 1
	  discard_rest_of_line ();
d1946 1
a1946 1
  char *file;
d1955 3
a1957 2
  while (!is_end_of_line[(unsigned char) *input_line_pointer])
    sb_add_char (&s, *input_line_pointer++);
d2205 1
a2205 1
      discard_rest_of_line ();
d2267 1
a2267 2
  char quote1, quote2, inquote;
  unsigned char c;
d2279 3
a2281 32
  /* If app.c sets any other characters to LEX_IS_STRINGQUOTE, this
     code needs to be changed.  */
  if (!flag_m68k_mri)
    quote1 = '"';
  else
    quote1 = '\0';

  quote2 = '\0';
  if (flag_m68k_mri)
    quote2 = '\'';
#ifdef LEX_IS_STRINGQUOTE
  quote2 = '\'';
#endif

  inquote = '\0';

  while ((c = * input_line_pointer ++) != 0
	 && (!is_end_of_line[c]
	     || (inquote != '\0' && c != '\n')))
    {
      if (inquote == c)
	inquote = '\0';
      else if (inquote == '\0')
	{
	  if (c == quote1)
	    inquote = quote1;
	  else if (c == quote2)
	    inquote = quote2;
	}

      sb_add_char (line, c);
    }
d2288 1
a2288 1
  return c;
d2296 1
a2296 1
  char *file;
d2305 3
a2307 2
  while (!is_end_of_line[(unsigned char) *input_line_pointer])
    sb_add_char (&s, *input_line_pointer++);
d2829 1
a2829 1
      discard_rest_of_line ();
a3173 13
void
discard_rest_of_line (void)
{
  while (input_line_pointer < buffer_limit
	 && !is_end_of_line[(unsigned char) *input_line_pointer])
    input_line_pointer++;

  input_line_pointer++;

  /* Return pointing just after end-of-line.  */
  know (is_end_of_line[(unsigned char) input_line_pointer[-1]]);
}

d5237 1
a5237 5
  while (!is_end_of_line[(unsigned char) *input_line_pointer])
    {
      ++input_line_pointer;
    }
  ++input_line_pointer;
d5275 48
@


1.102
log
@gas/
2005-05-06  Jan Beulich  <jbeulich@@novell.com>

	* cond.c (s_ifb): New.
	* read.c (potable): Add s_ifb as handler for .ifb and .ifnb.
	* read.h (s_ifb): Prototype.
	* doc/as.texinfo: Document .ifb and .ifnb.

gas/testsuite/
2005-05-06  Jan Beulich  <jbeulich@@novell.com>

	* gas/all/cond.s: Also test .ifb/.ifnb.
	* gas/all/cond.d: Adjust.
@
text
@a2350 1
  sb label;
a2359 1
  sb_new (&label);
d2361 2
a2362 1
    sb_add_string (&label, S_GET_NAME (line_label));
d2364 7
a2370 1
  err = define_macro (0, &s, &label, get_line_sb, file, line, &name);
@


1.101
log
@Update the address and phone number of the FSF
@
text
@d346 1
d355 1
@


1.100
log
@	* Makefile.am (GAS_CFILES): Remove bignum-copy.c.
	(GENERIC_OBJS): Likewise, remove bignum-copy.o.
	(bignum-copy.o): Remove.
	* Makefile.in: Regenerate.
	* makefile.vms (OBJS): Remove bignum-copy.obj.
	* symbols.h (local_symbol_make): Remove declaration.
	(verify_symbol_chain_2): Likewise.
	* symbols.c (local_symbol_make): Make static.
	(max_indent_level): Likewise.
	(verify_symbol_chain_2): Remove.
	* macro.c (macro_hash): Make static.
	* messages.c (fprint_value): Remove.
	* read.h (get_absolute_expr): Remove.
	(emit_leb128_expr): Likewise.
	(do_s_func): Likewise.
	* read.c (do_s_func): Make static.
	(emit_leb128_expr): Likewise.
	(get_absolute_expr): Likewise.
	* as.h (as_howmuch): Remove declaration.
	(fprint_value): Likewise.
	* as.c (myname): Make static.
	* input-scrub.c (as_howmuch): Remove.
	(as_1_char): Likewise.
	* input-file.h (input_file_is_open): Remove.
	* input-file.c (input_file_is_open): Likewise.
	* expr.h (expr_build_unary): Remove declaration.
	(expr_build_binary): Likewise.
	* expr.c (expr_build_unary): Remove.
	(expr_build_binary): Likewise.
	* hash.h (hash_replace): Remove declaration.
	(hash_delete): Likewise.
	* hash.c (hash_replace): Remove.
	(hash_delete): Likewise.
	* bignum-copy.c (bignum_copy): Move from here ..
	* config/tc-vax.c (bignum_copy): .. to here.
	* bignum.h (LOG_TO_BASE_2_OF_10): Remove.
	(bignum_copy): Remove extern declaration.
	* sb.h (string_count): Remove extern declaration.
	(sb_build, sb_add_buffer, sb_print, sb_print_at): Likewise.
	(sb_name): Likewise.
	* sb.c (dsize): Replace preprocessor macro with static int.
	(string_count): Make static.
	(sb_build, sb_add_buffer, sb_print, sb_print_at): Likewise.
	(sb_name): Likewise.
	* config/obj-coff.c (dim_index): Make static.
	* config/tc-i386.c (GOT_symbol): Likewise.
	(output_invalid_buf): Likewise.
	* doc/internals.texi (Warning and error messages): Remove the
	prototype for fprint_value.
@
text
@d20 2
a21 2
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.  */
@


1.99
log
@gas/

2005-04-26  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-multi.h (FAKE_LABEL_NAME): Defined.

	* read.c (pseudo_set): Disallow symbol set to common symbol.

	PR 857
	* write.c (write_object_file): Report common symbol name when
	disallowing local symbol set to common symbol.
	(adjust_reloc_syms): Disallow local symbol set to undefined
	symbol.

gas/testsuite/

2005-04-26  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/all/assign.s: Make `x' and `y' global.
@
text
@d214 1
d442 21
d4486 1
a4486 1
void
a4852 21
offsetT
get_absolute_expr (expressionS *exp)
{
  expression (exp);
  if (exp->X_op != O_constant)
    {
      if (exp->X_op != O_absent)
	as_bad (_("bad or irreducible absolute expression"));
      exp->X_add_number = 0;
    }
  return exp->X_add_number;
}

offsetT
get_absolute_expression (void)
{
  expressionS exp;

  return get_absolute_expr (&exp);
}

d5213 1
a5213 1
void
@


1.98
log
@gas/
2005-04-25  Jan Beulich  <jbeulich@@novell.com>

	* macro.c (macro_expand_body): Replace locals indicator parameters
	with actual macro_entry. New local variables macro_line and err.
	Don't return when encountering an error, just record the fact.
	Detect local symbol name colliding with parameter. Track line number
	inside of macro expansion.
	(do_formals): Move local variable name to wider scope. Check
	parameter of the same name doesn't already exist. In MRI mode, also
	check it doesn't collide with the argument count pseudo-parameter).
	(define_macro): Add file and line number parameters. Remove local
	variable namestr. New local variable error. Initialize macro_entry
	members file, line, and name. Don't return when encountering an
	error, just record the fact. Use %s in some diagnostics for read.c
	to insert the macro name. Free macro_entry on error.
	(macro_expand): Pass macro_entry to macro_epand_body. Don't return
	when encountering an error, just record the fact.
	(expand_irp): Don't return when encountering an error, just record
	the fact.
	* macro.h (macro_struct): New members name, file, and line.
	(define_macro): Add file and line number parameters.
	* read.c (s_macro): Pass file and line to define_macro. Tag warning
	regarding pseudo-op redefinition with the file/line that macro
	definition started at.

gas/testsuite/
2005-04-25  Jan Beulich  <jbeulich@@novell.com>

	* gas/macros/badarg.s: Add tests for collisions between/among macro
	parameters and local symbols.
	* gas/macros/badarg.l: Adjust.
@
text
@d3304 4
@


1.97
log
@gas/
2005-04-11  Jan Beulich  <jbeulich@@novell.com>

	* NEWS: Mention these changes and their effects.
	* macro.c (get_token): Use is_name_beginner/is_part_of_name/
	is_name_ender.
	(check_macro): Likewise.
	(buffer_and_nest): Likewise. Permit multiple labels. Don't discard
	labels together with the closing pseudo-op.
	(macro_expand_body): Adjust comment. Range-check input before use.
	Adjust mis-spelled diagnostic. Use is_name_beginner.
	* read.c (try_macro): New.
	(read_a_source_file): New static variable last_eol. Don't list
	macro expansion lines more than once. Call try_macro.
	(s_macro): Set section of line_label to absolute instead of undefined.
	* doc/as.texinfo: Add information on the caveats of these changes.

gas/testsuite/
2005-04-11  Jan Beulich  <jbeulich@@novell.com>

	* gas/macros/dot.[ls]: New.
	* gas/macros/macros.exp: Run new test.
@
text
@d2341 1
a2341 1
  err = define_macro (0, &s, &label, get_line_sb, &name);
d2343 1
a2343 1
    as_bad_where (file, line, "%s", err);
d2358 3
a2360 1
	as_warn (_("attempt to redefine pseudo-op `%s' ignored"),
@


1.96
log
@	* read.c (assign_symbol): Remove const from parm.  Fix xcalloc
	call.  Don't do the COFF hacks for multi-emulation gas.  Move
	demand_empty_rest_of_line back to caller.
	(s_set, equals): demand_empty_rest_of_line here.
@
text
@d523 26
d576 7
d702 11
a712 8
		  /* Copy it for safe keeping.  Also give an indication of
		     how much macro nesting is involved at this point.  */
		  len = s - (input_line_pointer - 1);
		  copy = (char *) xmalloc (len + macro_nest + 2);
		  memset (copy, '>', macro_nest);
		  copy[macro_nest] = ' ';
		  memcpy (copy + macro_nest + 1, input_line_pointer - 1, len);
		  copy[macro_nest + 1 + len] = '\0';
d714 3
a716 2
		  /* Install the line with the listing facility.  */
		  listing_newline (copy);
d856 2
a857 1
			  as_bad (_("unknown pseudo-op: `%s'"), s);
d860 8
d923 2
a924 22
		      if (macro_defined)
			{
			  sb out;
			  const char *err;
			  macro_entry *macro;

			  if (check_macro (s, &out, &err, &macro))
			    {
			      if (err != NULL)
				as_bad ("%s", err);
			      *input_line_pointer++ = c;
			      input_scrub_include_sb (&out,
						      input_line_pointer, 1);
			      sb_kill (&out);
			      buffer_limit =
				input_scrub_next_buffer (&input_line_pointer);
#ifdef md_macro_info
			      md_macro_info (macro);
#endif
			      continue;
			    }
			}
d2348 1
a2348 1
	  S_SET_SEGMENT (line_label, undefined_section);
@


1.95
log
@	PR gas/827
	* as.h (rs_dummy): Define.
	* symbols.c (symbol_X_add_number): New function.
	* symbols.h (symbol_X_add_number): Declare.
	* stabs.c (aout_process_stab): Tidy symbol frag setting.
	* read.c (assign_symbol): New function, split out from s_set.
	Use symbol_find_or_make.  Leave fr_type of dummy frag as rs_dummy.
	Fix COFF hacks for multi-emulation gas.
	(s_set): Call assign_symbol.  Remove "register" keyword.
	(set_zero_frag): New function.
	(pseudo_set): Always check for assignment to section syms.
	Always set segment and frag of symbol, and likewise extern for
	aout/bout.  Handle assignment of sym=sym+/-const specially.  Don't
	special case exp.X_add_number non-zero for O_symbol expressions.
	(equals): Use assign_symbol.
@
text
@d2751 1
a2751 1
assign_symbol (const char *name, int no_reassign)
d2780 1
a2780 1
	  fragS *dummy_frag = (fragS *) xcalloc (sizeof (fragS));
d2786 3
a2788 6
#if defined (OBJ_COFF) || defined (OBJ_MAYBE_COFF)
#if defined (BFD_ASSEMBLER) && defined (OBJ_MAYBE_COFF)
      if (OUTPUT_FLAVOR == bfd_target_coff_flavour)
#endif
	/* "set" symbols are local unless otherwise specified.  */
	SF_SET_LOCAL (symbolP);
a2798 2

  demand_empty_rest_of_line ();
d2843 2
d4923 4
a4926 1
    mri_comment_end (stop, stopc);
@


1.94
log
@	* as.h (assert): Warning fix.
	* expr.c (expr): Correct assertion.
	* read.c (s_comm_internal): Remove assertion.
	* write.c (relax_segment): Enable vma assertion only for BFD_ASSEMBLER.
	(fixup_segment): Remove assertion.
	* config/tc-dlx.c (machine_ip): Remove untrue assertions.
	(md_apply_fix3): Likewise.
	* config/tc-i370.c (md_begin): Correct assertion.
	(i370_macro): Warning fix for assertion.
@
text
@d2750 56
d2813 3
a2815 4
  register char *name;
  register char delim;
  register char *end_name;
  register symbolS *symbolP;
d2846 1
a2846 44
  if (name[0] == '.' && name[1] == '\0')
    {
      /* Turn '. = mumble' into a .org mumble.  */
      register segT segment;
      expressionS exp;

      segment = get_known_segmented_expression (&exp);

      if (!need_pass_2)
	do_org (segment, &exp, 0);

      *end_name = delim;
      return;
    }

  if ((symbolP = symbol_find (name)) == NULL
      && (symbolP = md_undefined_symbol (name)) == NULL)
    {
#ifndef NO_LISTING
      /* When doing symbol listings, play games with dummy fragments living
	 outside the normal fragment chain to record the file and line info
	 for this symbol.  */
      if (listing & LISTING_SYMBOLS)
	{
	  extern struct list_info_struct *listing_tail;
	  fragS *dummy_frag = (fragS *) xmalloc (sizeof (fragS));
	  memset (dummy_frag, 0, sizeof (fragS));
	  dummy_frag->fr_type = rs_fill;
	  dummy_frag->line = listing_tail;
	  symbolP = symbol_new (name, undefined_section, 0, dummy_frag);
	  dummy_frag->fr_symbol = symbolP;
	}
      else
#endif
	symbolP = symbol_new (name, undefined_section, 0, &zero_address_frag);

#ifdef OBJ_COFF
      /* "set" symbols are local unless otherwise specified.  */
      SF_SET_LOCAL (symbolP);
#endif /* OBJ_COFF */
    }

  symbol_table_insert (symbolP);

a2847 8

  if (equiv
      && S_IS_DEFINED (symbolP)
      && S_GET_SEGMENT (symbolP) != reg_section)
    as_bad (_("symbol `%s' is already defined"), S_GET_NAME (symbolP));

  pseudo_set (symbolP);
  demand_empty_rest_of_line ();
d3184 10
d3205 1
a3210 3
#if (defined (OBJ_AOUT) || defined (OBJ_BOUT)) && ! defined (BFD_ASSEMBLER)
  ext = S_IS_EXTERNAL (symbolP);
#endif /* OBJ_AOUT or OBJ_BOUT */
d3235 9
a3252 6
#if (defined (OBJ_AOUT) || defined (OBJ_BOUT)) && ! defined (BFD_ASSEMBLER)
      if (ext)
	S_SET_EXTERNAL (symbolP);
      else
	S_CLEAR_EXTERNAL (symbolP);
#endif /* OBJ_AOUT or OBJ_BOUT */
d3254 1
a3254 2
      if (exp.X_op != O_constant)
	symbol_set_frag (symbolP, &zero_address_frag);
d3260 1
a3260 1
      symbol_set_frag (symbolP, &zero_address_frag);
d3264 12
a3275 6
      if (S_GET_SEGMENT (exp.X_add_symbol) == undefined_section
	  || exp.X_add_number != 0)
	symbol_set_value_expression (symbolP, &exp);
      else if (symbol_section_p (symbolP))
	as_bad ("attempt to set value of section symbol");
      else
d3279 2
a3280 9
	  S_SET_SEGMENT (symbolP, S_GET_SEGMENT (s));
#if (defined (OBJ_AOUT) || defined (OBJ_BOUT)) && ! defined (BFD_ASSEMBLER)
	  if (ext)
	    S_SET_EXTERNAL (symbolP);
	  else
	    S_CLEAR_EXTERNAL (symbolP);
#endif /* OBJ_AOUT or OBJ_BOUT */
	  S_SET_VALUE (symbolP,
		       exp.X_add_number + S_GET_VALUE (s));
d3283 1
d3285 1
a3285 1
      break;
d3289 2
a3290 1
	 FIXME: Should we set the segment to anything?  */
d3292 1
d3295 7
a4909 1
  register symbolS *symbolP;	/* Symbol we are working with.  */
d4923 1
a4923 34
  if (sym_name[0] == '.' && sym_name[1] == '\0')
    {
      /* Turn '. = mumble' into a .org mumble.  */
      register segT segment;
      expressionS exp;

      segment = get_known_segmented_expression (&exp);
      if (!need_pass_2)
	do_org (segment, &exp, 0);
    }
  else
    {
#ifdef OBJ_COFF
      int local;

      symbolP = symbol_find (sym_name);
      local = symbolP == NULL;
      if (local)
#endif /* OBJ_COFF */
      symbolP = symbol_find_or_make (sym_name);
      /* Permit register names to be redefined.  */
      if (!reassign
	  && S_IS_DEFINED (symbolP)
	  && S_GET_SEGMENT (symbolP) != reg_section)
	as_bad (_("symbol `%s' is already defined"), S_GET_NAME (symbolP));

#ifdef OBJ_COFF
      /* "set" symbols are local unless otherwise specified.  */
      if (local)
	SF_SET_LOCAL (symbolP);
#endif /* OBJ_COFF */

      pseudo_set (symbolP);
    }
d4926 1
a4926 5
    {
      /* Check garbage after the expression.  */
      demand_empty_rest_of_line ();
      mri_comment_end (stop, stopc);
    }
@


1.94.2.1
log
@	PR gas/827
	* as.h (rs_dummy): Define.
	* symbols.c (symbol_X_add_number): New function.
	* symbols.h (symbol_X_add_number): Declare.
	* stabs.c (aout_process_stab): Tidy symbol frag setting.
	* read.c (assign_symbol): New function, split out from s_set.
	Use symbol_find_or_make.  Leave fr_type of dummy frag as rs_dummy.
	(s_set): Call assign_symbol.  Remove "register" keyword.
	(set_zero_frag): New function.
	(pseudo_set): Always check for assignment to section syms.
	Always set segment and frag of symbol, and likewise extern for
	aout/bout.  Handle assignment of sym=sym+/-const specially.  Don't
	special case exp.X_add_number non-zero for O_symbol expressions.
	(equals): Use assign_symbol.
@
text
@a2749 51
static void
assign_symbol (char *name, int no_reassign)
{
  symbolS *symbolP;

  if (name[0] == '.' && name[1] == '\0')
    {
      /* Turn '. = mumble' into a .org mumble.  */
      segT segment;
      expressionS exp;

      segment = get_known_segmented_expression (&exp);

      if (!need_pass_2)
	do_org (segment, &exp, 0);

      return;
    }

  if ((symbolP = symbol_find (name)) == NULL
      && (symbolP = md_undefined_symbol (name)) == NULL)
    {
      symbolP = symbol_find_or_make (name);
#ifndef NO_LISTING
      /* When doing symbol listings, play games with dummy fragments living
	 outside the normal fragment chain to record the file and line info
	 for this symbol.  */
      if (listing & LISTING_SYMBOLS)
	{
	  extern struct list_info_struct *listing_tail;
	  fragS *dummy_frag = (fragS *) xcalloc (1, sizeof (fragS));
	  dummy_frag->line = listing_tail;
	  dummy_frag->fr_symbol = symbolP;
	  symbol_set_frag (symbolP, dummy_frag);
	}
#endif
#ifdef OBJ_COFF
      /* "set" symbols are local unless otherwise specified.  */
      SF_SET_LOCAL (symbolP);
#endif
    }

  /* Permit register names to be redefined.  */
  if (no_reassign
      && S_IS_DEFINED (symbolP)
      && S_GET_SEGMENT (symbolP) != reg_section)
    as_bad (_("symbol `%s' is already defined"), name);

  pseudo_set (symbolP);
}

d2757 4
a2760 3
  char *name;
  char delim;
  char *end_name;
d2791 44
a2834 1
  assign_symbol (name, equiv);
d2837 6
a3179 10
/* Sets frag for given symbol to zero_address_frag, except when the
   symbol frag is already set to a dummy listing frag.  */

static void
set_zero_frag (symbolS *symbolP)
{
  if (symbol_get_frag (symbolP)->fr_type != rs_dummy)
    symbol_set_frag (symbolP, &zero_address_frag);
}

a3190 1
  segT seg;
d3196 3
a3222 9
  if (symbol_section_p (symbolP))
    {
      as_bad ("attempt to set value of section symbol");
      return;
    }
#if (defined (OBJ_AOUT) || defined (OBJ_BOUT)) && ! defined (BFD_ASSEMBLER)
  ext = S_IS_EXTERNAL (symbolP);
#endif /* OBJ_AOUT or OBJ_BOUT */

d3232 6
d3239 2
a3240 1
      set_zero_frag (symbolP);
d3246 1
a3246 1
      set_zero_frag (symbolP);
d3250 6
a3255 12
      seg = S_GET_SEGMENT (exp.X_add_symbol);
      /* For x=undef+const, create an expression symbol.
	 For x=x+const, just update x except when x is an undefined symbol
	 For x=defined+const, evaluate x.  */
      if (symbolP == exp.X_add_symbol
	  && (seg != undefined_section
	      || !symbol_constant_p (symbolP)))
	{
	  *symbol_X_add_number (symbolP) += exp.X_add_number;
	  break;
	}
      else if (seg != undefined_section)
d3259 9
a3267 2
	  S_SET_SEGMENT (symbolP, seg);
	  S_SET_VALUE (symbolP, exp.X_add_number + S_GET_VALUE (s));
a3269 1
	  break;
d3271 1
a3271 1
      /* Fall thru */
d3275 1
a3275 2
	 Set segment and frag back to that of a newly created symbol.  */
      S_SET_SEGMENT (symbolP, undefined_section);
a3276 1
      set_zero_frag (symbolP);
a3278 7

#if (defined (OBJ_AOUT) || defined (OBJ_BOUT)) && ! defined (BFD_ASSEMBLER)
  if (ext)
    S_SET_EXTERNAL (symbolP);
  else
    S_CLEAR_EXTERNAL (symbolP);
#endif /* OBJ_AOUT or OBJ_BOUT */
d4887 1
d4901 34
a4934 1
  assign_symbol (sym_name, !reassign);
d4938 1
@


1.93
log
@	* read.c (read_a_source_file): Reinstate TC_EQUAL_IN_INSN test.
	* doc/internals.texi (TC_EQUAL_IN_INSN): Reinstate.
@
text
@a1474 1
  know (symbolP == NULL || symbolP->sy_frag == &zero_address_frag);
@


1.92
log
@	* read.c: Warning fixes.
	* config/obj-elf.c: Likewise.
@
text
@d732 7
a738 3
	      else if (c == '='
		       || ((c == ' ' || c == '\t')
			   && input_line_pointer[1] == '='))
@


1.91
log
@gas/
	* read.c (address_bytes): New function.
	(TC_ADDRESS_BYTES): Default for BSD_ASSEMBLER to address_bytes.
	(potable): Add "dc.a".
	(cons_worker): Handle "dc.a".
	* doc/internals.texi (TC_ADDRESS_BYTES): Document.
ld/testsuite/
	* ld-elf/exclude1.s: Use ".dc.a".
	* ld-elfvsb/hidden2.s: Likewise.
@
text
@d4413 1
a4413 1
  int nbytes;
d4445 1
a4445 1
  nbytes = -1;
@


1.90
log
@	* config/tc-hppa.h (TC_EQUAL_IN_INSN): Delete.
	* read.c (read_a_source_file): Remove TC_EQUAL_IN_INSN test.
	* doc/internals.texi (TC_EQUAL_IN_INSN): Delete.
@
text
@d246 18
d284 3
d3359 5
@


1.89
log
@	* tc.h (struct relax_type, relax_typeS): Move from here..
	* as.h: ..to here.  Make rlx_forward and rlx_backward an offsetT.
	* ecoff.c (ecoff_new_file): Add appfile param.
	* ecoff.h (ecoff_new_file): Likewise.
	* itbl-lex.h: New file.
	* itbl-lex.l: Include itbl-lex.h.
	* itbl-parse.y: Likewise.
	(insntbl_line, yyparse, yylex): Move to itbl-lex.h.
	* read.c (s_app_file_string): Mark appfile possibly unused.
	* subsegs.c (seg_not_empty_p): Make sec possibly unused.
	* subsegs.h (struct seg_info_trash): Delete.
	(seg_info): Use segment_info_type instead.
	* config/obj-coff.c (struct filename_list): Make filename const char *.
	* config/obj-ecoff.h (obj_app_file): Pass app to ecoff_new_file.
	* config/obj-elf.c (elf_file_symbol): Similarly.
	* config/tc-a29k.c (md_apply_fix3): Make val a valueT.  Don't use
	signed right shift.
	* config/tc-arc.c (md_operand): Warning fix.
	* config/tc-arm.c (arm_parse_reloc): Only define when OBJ_ELF.
	(md_begin): Rearrange #if defined OBJ_COFF || defined OBJ_ELF.
	* config/tc-cris.h (TC_IMPLICIT_LCOMM_ALIGNMENT): Use do while.
	* config/tc-frv.c (frv_force_relocation): Warning fix.
	* config/tc-m68k.c (md_parse_option): Delete unused var.
	* config/tc-mcore.c (mylog2): Rename from log2 throughout.
	* config/tc-sparc.c: Likewise.
	(s_common): Warning fix.
	* config/tc-mips.c (append_insn): Use unsigned long long expressions.
	* config/tc-mmix.c (PUSHJSTUB_MAX, PUSHJSTUB_MIN): Define from
	addressT.
	* config/tc-s390.c (s390_insn): Delete test of unsigned >= 0.
	* config/tc-sh.c (sh_cfi_frame_initial_instructions,
	sh_regname_to_dw2regnum): Only define for OBJ_ELF.
	* config/tc-tic4x.c (tic4x_insert_reg): Use ISLOWER.
	(tic4x_do_align): Use TIC_NOP_OPCODE.
	* config/tc-tic4x.h (TIC_NOP_OPCODE): Rename from NOP_OPCODE.
	* config/tc-vax.c: Include netinet/in.h.
	(tc_headers_hook): Formatting.
	* config/tc-xstormy16.c (md_pcrel_from_section): Correct parens.
@
text
@d713 1
a713 5
			   && input_line_pointer[1] == '='
#ifdef TC_EQUAL_IN_INSN
			   && !TC_EQUAL_IN_INSN (c, input_line_pointer)
#endif
			   ))
@


1.88
log
@gas/
2005-01-31  Jan Beulich  <jbeulich@@novell.com>

	* macro.c (do_formals): Adjust to no longer accept empty parameter
	names.
	(define_macro): Adjust to no longer accept empty macro name, garbage
	following the parameters, or macros that were previously defined.
	* read.c (s_bad_end): Declare.
	(potable): Add endm. Handler for endr and endm is s_bad_end.
	(s_bad_end): Rename from s_bad_endr. Adjust to handle both .endm
	and .endr.
	* read.h (s_bad_endr): Remove.

gas/testsuite/
2005-01-31  Jan Beulich  <jbeulich@@novell.com>

	* gas/macros/badarg.[ls]: New.
	* gas/macros/end.[ls]: New.
	* gas/macros/redef.[ls]: New.
	* gas/macros/macros.exp (run_list_test): Copy from elsewhere.
	Run new tests.
@
text
@d1602 1
a1602 1
s_app_file_string (char *file, int appfile)
@


1.87
log
@	* as.h: Remove #if 0'd code.
	* atof-generic.c (atof_generic): Likewise.
	* ecoff.c (ecoff_directive_frame): Likewise.
	* frags.h (FRAG_APPEND_1_CHAR): Likewise.
	* itbl-ops.c (itbl_add_reg): Likewise.
	* listing.c (calc_hex): Likewise.
	* read.c (MASK_CHAR): Likewise.
	* subsegs.c (subsegs_print_statistics): Likewise.
	* symbols.c (indent): Likewise.
	* write.c (write_relocs): Likewise.
	(write_object_file): Likewise.
	(relax_frag): Likewise.
@
text
@d217 1
d302 2
a303 1
  {"endr", s_bad_endr, 0},
d2664 1
a2664 1
/* Handle the .rept pseudo-op.  */
d2666 2
a2667 2
void
s_bad_endr (int ignore ATTRIBUTE_UNUSED)
d2669 3
a2671 1
  as_warn (_(".endr encountered without preceeding .rept, .irc, or .irp"));
@


1.86
log
@	PR gas/684
	* read.c (s_incbin): Adjust default count for skip.  Check validity
	of count and skip rigorously.
@
text
@d23 1
a23 2
#if 0
/* If your chars aren't 8 bits, you will change this a bit.
a25 2
#define MASK_CHAR (0xFF)
#else
a26 1
#endif
@


1.85
log
@	* read.c (convert_to_bignum): New function, split out from...
	(emit_expr): ...here.  Handle the case where X_add_number is
	positive and the input value is negative.
	(output_big_sleb128): Fix setting of continuation bit.  Check whether
	the final byte needs to be sign-extended.  Fix size-shrinking loop.
	(emit_leb128_expr): When generating a signed leb128, see whether the
	sign of an O_constant's X_add_number matches the sign of the input
	value.  Use a bignum if not.
@
text
@d5003 1
a5003 1
      /* If a count was not specified use the size of the file.  */
d5005 1
a5005 1
	count = file_len;
d5007 1
a5007 1
      if (skip + count > file_len)
d5009 1
a5009 1
	  as_bad (_("skip (%ld) + count (%ld) larger than file size (%ld)"),
@


1.84
log
@	PR gas/619
	* read.c (s_comm_internal): Don't zero end of name until size
	expression has been parsed.
@
text
@d3 2
a4 1
   1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d1086 23
d3568 3
a3570 16
      valueT val;
      int gencnt;

      if (!exp->X_unsigned && exp->X_add_number < 0)
	extra_digit = (valueT) -1;
      val = (valueT) exp->X_add_number;
      gencnt = 0;
      do
	{
	  generic_bignum[gencnt] = val & LITTLENUM_MASK;
	  val >>= LITTLENUM_NUMBER_OF_BITS;
	  ++gencnt;
	}
      while (val != 0);
      op = exp->X_op = O_big;
      exp->X_add_number = gencnt;
d4290 3
a4292 1
  while (size > 0 && bignum[size - 1] == (LITTLENUM_TYPE) -1)
d4297 5
a4301 7
      if (loaded < 7 && size > 0)
	{
	  val |= (*bignum << loaded);
	  loaded += 8 * CHARS_PER_LITTLENUM;
	  size--;
	  bignum++;
	}
d4303 3
a4305 5
      byte = val & 0x7f;
      loaded -= 7;
      val >>= 7;

      if (size == 0)
d4307 5
a4311 3
	  if ((val == 0 && (byte & 0x40) == 0)
	      || (~(val | ~(((valueT) 1 << loaded) - 1)) == 0
		  && (byte & 0x40) != 0))
d4313 4
d4318 3
d4322 6
d4329 1
a4329 1
	*p = byte;
a4331 1
  while (byte & 0x80);
d4410 10
@


1.83
log
@	* read.c (s_align): Use an align_limit temporary to allay a GCC
	signed/unsigned comparison warning.
@
text
@a1379 1
  *p = 0;
a1387 1
      *p = c;
a1393 1
      *p = c;
d1398 1
@


1.82
log
@	* read.c (ALIGN_LIMIT): Define, increasing limit for BFD_ASSEMBLER.
	(s_align): Use it.
@
text
@d1207 1
d1247 1
a1247 1
  if (align > ALIGN_LIMIT)
d1249 1
a1249 1
      align = ALIGN_LIMIT;
@


1.81
log
@	* read.c (potable): Add "error" and "warning".
	(s_errwarn): New function.
	* read.h (s_errwarn): Declare.
	* doc/as.texinfo (Error, Warning): Document .error and .warning.
@
text
@d1198 6
d1207 1
a1207 1
  register unsigned int align;
d1246 1
a1246 1
  if (align > 15)
d1248 1
a1248 1
      align = 15;
@


1.80
log
@	* obj.h (struct format_ops <app_file>): Add int param.
	* read.h (s_app_file_string): Likewise.
	* read.c (s_app_file_string): Likewise.
	(s_app_file): Adjust s_app_file_string call.
	* config/tc-mips.c (s_mips_file): Likewise.
	* config/obj-coff.h (obj_app_file): Add app param.
	* config/obj-ecoff.h (obj_app_file): Likewise.
	* config/obj-multi.h (obj_app_file): Likewise.
	* config/obj-elf.h (elf_file_symbol): Likewise.
	* config/obj-elf.c (elf_file_symbol): Only emit one file symbol
	if called for # preprocessor lines.
@
text
@d309 1
d415 1
d1670 37
@


1.79
log
@Add and handle new --alternate command line option.
@
text
@d1573 1
a1573 1
s_app_file_string (char *file)
d1581 1
a1581 1
  obj_app_file (file);
d1609 1
a1609 1
	s_app_file_string (s);
@


1.78
log
@	* read.c (do_align): Call md_flush_pending_output, if defined.
@
text
@d219 1
d255 1
d356 1
d1326 9
@


1.77
log
@	* read.c (read_a_source_file): Use demand_empty_rest_of_line.
	(demand_empty_rest_of_line): Issue an error here.
	(ignore_rest_of_line): Silently skip to end.
	(demand_copy_string): Issue an error, not warning.
	(equals): Likewise.
	* config/obj-elf.c (obj_elf_section_name): Likewise.
	(obj_elf_section): Likewise.
	* config/tc-arc.c (arc_extoper): Remove bogus NULL checks.
	(arc_extinst): Likewise.
	* config/tc-ia64.c (dot_saveb): Use demand_empty_rest_of_line.
	(dot_spill): Likewise.
	(dot_unwabi): Likewise.
	(dot_prologue): Likewise.
@
text
@d1158 3
@


1.76
log
@        * read.c (s_leb128): Call md_flush_pending_output.
@
text
@d1056 1
a1056 1
	  ignore_rest_of_line ();
d3023 4
a3033 10
    ignore_rest_of_line ();

  /* Return having already swallowed end-of-line.  */
}

void
ignore_rest_of_line (void)
{
  /* For suspect lines: gives warning.  */
  if (!is_end_of_line[(unsigned char) *input_line_pointer])
d3036 1
a3036 1
	as_warn (_("rest of line ignored; first ignored character is `%c'"),
d3039 1
a3039 1
	as_warn (_("rest of line ignored; first ignored character valued 0x%x"),
d3041 6
d3048 9
a3056 4
      while (input_line_pointer < buffer_limit
	     && !is_end_of_line[(unsigned char) *input_line_pointer])
	input_line_pointer++;
    }
d4746 1
a4746 1
      as_warn (_("missing string"));
d4822 1
a4822 1
      ignore_rest_of_line ();
@


1.75
log
@	* read.h (IGNORE_OPCODE_CASE): Do not define. Replace with ...
	(TC_CASE_SENSITIVE): ... this.
	* read.c: Replace IGNORE_OPCODE_CASE with TC_CASE_SENSITIVE.
	* doc/internals.texi (TC_CASE_SENSITIVE): Document.
@
text
@d4375 4
@


1.75.4.1
log
@	* read.c (s_leb128): Call md_flush_pending_output.
@
text
@a4374 4
#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

@


1.75.4.2
log
@Merge to 2.15 branch.
@
text
@d1056 1
a1056 1
	  demand_empty_rest_of_line ();
a3022 4

/* Verify that we are at the end of a line.  If not, issue an error and
   skip to EOL.  */

d3030 10
d3042 1
a3042 1
	as_bad (_("junk at end of line, first unrecognized character is `%c'"),
d3045 1
a3045 1
	as_bad (_("junk at end of line, first unrecognized character valued 0x%x"),
d3047 4
a3050 1
      ignore_rest_of_line ();
a3051 14
  
  /* Return pointing just after end-of-line.  */
  know (is_end_of_line[(unsigned char) input_line_pointer[-1]]);
}

/* Silently advance to the end of line.  Use this after already having
   issued an error about something bad.  */

void
ignore_rest_of_line (void)
{
  while (input_line_pointer < buffer_limit
	 && !is_end_of_line[(unsigned char) *input_line_pointer])
    input_line_pointer++;
a4378 4
#ifdef md_flush_pending_output
  md_flush_pending_output ();
#endif

d4741 1
a4741 1
      as_bad (_("missing string"));
d4817 1
a4817 1
      demand_empty_rest_of_line ();
@


1.74
log
@.:
	* dwarf2dbg.c (DWARF2_ADDR_SIZE): Remove trailing ';'
	* read.h (SKIP_WHITESPACE): Turn into an expression.
	* read.c (read_a_source_file): A pseudo is removed by having a
	NULL handler.
testsuite:
	* gas/macros/test2.s: Lowercase it.
@
text
@d158 1
a158 1
#ifdef  IGNORE_OPCODE_CASE
d723 1
a723 1
#ifdef IGNORE_OPCODE_CASE
@


1.73
log
@	* read.c (s_lcomm_internal): Make global.
	* read.h (s_lcomm_internal): Declare.
	* config/obj-elf.c (elf_pseudo_table): Handle lcomm.
	(obj_elf_lcomm): New function.
@
text
@d757 2
@


1.72
log
@	* read.c: Remove unneeded prototypes.
	(s_comm): Split out code to..
	(s_comm_internal): ..here.  Tidy error returns.  Rearrange so that
	"name" from input line may be used in more places.  Merge code
	testing for valid size from elf_common.  Merge code from
	s_lcomm_internal.  Call comm_parse_extra.
	(bss_alloc): New function, split out of s_lcomm_internal and
	elf_common.
	(parse_align): Likewise.
	(s_lcomm_internal): Rewrite.
	(s_lcomm, s_lcomm_bytes): Use s_comm_internal.
	* read.h (bss_alloc, parse_align, s_comm_internal): Declare.
	* config/obj-elf.c (elf_common): Split out code to..
	(elf_common_parse): ..here.  Remove code common to s_comm_internal,
	parse_align and bss_alloc.  Rearrange and Tidy.
	* config/tc-alpha.h (TC_IMPLICIT_LCOMM_ALIGNMENT): Define.
@
text
@d2025 1
a2025 1
static symbolS *
@


1.71
log
@	* read.c: Convert to ISO-C.
	* read.h: Likewise.
@
text
@a216 2
static void cons_worker (int, int);
static int scrub_from_string (char *, int);
a218 1
static void s_lcomm_internal (int, int);
a219 10
static inline int sizeof_sleb128 (offsetT);
static inline int sizeof_uleb128 (valueT);
static inline int output_sleb128 (char *, offsetT);
static inline int output_uleb128 (char *, valueT);
static inline int output_big_sleb128 (char *, LITTLENUM_TYPE *, int);
static inline int output_big_uleb128 (char *, LITTLENUM_TYPE *, int);
static int output_big_leb128 (char *, LITTLENUM_TYPE *, int, int);
static void do_org (segT, expressionS *, int);
char *demand_copy_string (int *lenP);
static segT get_segmented_expression (expressionS *expP);
d1318 3
a1320 2
void
s_comm (int ignore ATTRIBUTE_UNUSED)
d1322 5
a1326 5
  register char *name;
  register char c;
  register char *p;
  offsetT temp;
  register symbolS *symbolP;
d1329 1
d1344 1
a1344 1
      return;
d1349 12
a1360 1
  if (*input_line_pointer != ',')
d1362 1
a1362 2
      *p = 0;
      as_bad (_("expected comma after \"%s\""), name);
d1365 1
a1365 3
      if (flag_mri)
	mri_comment_end (stop, stopc);
      return;
d1367 1
a1367 4

  input_line_pointer++;		/* skip ',' */

  if ((temp = get_absolute_expression ()) < 0)
d1369 2
a1370 2
      as_warn (_(".COMMon length (%lu) out of range ignored"),
	       (unsigned long) temp);
d1372 1
a1372 3
      if (flag_mri)
	mri_comment_end (stop, stopc);
      return;
a1374 1
  *p = 0;
a1375 2
  *p = c;

d1378 3
a1380 2
      as_bad (_("symbol `%s' is already defined"),
	      S_GET_NAME (symbolP));
d1382 1
a1382 3
      if (flag_mri)
	mri_comment_end (stop, stopc);
      return;
d1385 10
a1394 8
  if (S_GET_VALUE (symbolP))
    {
      if (S_GET_VALUE (symbolP) != (valueT) temp)
	as_bad (_("length of .comm \"%s\" is already %ld; not changing to %ld"),
		S_GET_NAME (symbolP),
		(long) S_GET_VALUE (symbolP),
		(long) temp);
    }
d1397 1
a1397 1
      S_SET_VALUE (symbolP, (valueT) temp);
d1399 7
a1406 8
#ifdef OBJ_VMS
  {
    extern int flag_one;
    if (!temp || !flag_one)
      S_GET_OTHER(symbolP) = const_flag;
  }
#endif /* not OBJ_VMS */
  know (symbolP->sy_frag == &zero_address_frag);
d1408 1
d1410 1
a1410 1

d1413 8
a1420 1
}				/* s_comm() */
d1917 2
a1918 8
static void
s_lcomm_internal (/* 1 if this was a ".bss" directive, which may
		     require a 3rd argument (alignment); 0 if it was
		     an ".lcomm" (2 args only).  */
		  int needs_align,
		  /* 1 if the alignment value should be interpreted as
		     the byte boundary, rather than the power of 2.  */
		  int bytes_p)
d1920 1
a1920 5
  register char *name;
  register char c;
  register char *p;
  register int temp;
  register symbolS *symbolP;
a1922 2
  const int max_alignment = 15;
  int align = 0;
a1924 35
  name = input_line_pointer;
  c = get_symbol_end ();
  p = input_line_pointer;
  *p = c;

  if (name == p)
    {
      as_bad (_("expected symbol name"));
      discard_rest_of_line ();
      return;
    }

  SKIP_WHITESPACE ();

  /* Accept an optional comma after the name.  The comma used to be
     required, but Irix 5 cc does not generate it.  */
  if (*input_line_pointer == ',')
    {
      ++input_line_pointer;
      SKIP_WHITESPACE ();
    }

  if (is_end_of_line[(unsigned char) *input_line_pointer])
    {
      as_bad (_("missing size expression"));
      return;
    }

  if ((temp = get_absolute_expression ()) < 0)
    {
      as_warn (_("BSS length (%d) < 0 ignored"), temp);
      ignore_rest_of_line ();
      return;
    }

d1930 1
a1930 1
      if ((unsigned) temp <= bfd_get_gp_size (stdoutput))
d1942 1
d1944 1
a1944 1
  if (!needs_align)
d1946 3
a1948 1
      TC_IMPLICIT_LCOMM_ALIGNMENT (temp, align);
d1950 3
a1952 4
      /* Still zero unless TC_IMPLICIT_LCOMM_ALIGNMENT set it.  */
      if (align)
	record_alignment (bss_seg, align);
    }
d1954 3
a1956 4
  if (needs_align)
    {
      align = 0;
      SKIP_WHITESPACE ();
d1958 4
a1961 6
      if (*input_line_pointer != ',')
	{
	  as_bad (_("expected comma after size"));
	  ignore_rest_of_line ();
	  return;
	}
d1963 7
a1969 2
      input_line_pointer++;
      SKIP_WHITESPACE ();
d1971 2
a1972 5
      if (is_end_of_line[(unsigned char) *input_line_pointer])
	{
	  as_bad (_("missing alignment"));
	  return;
	}
d1974 5
a1978 1
      align = get_absolute_expression ();
d1980 8
a1987 6
      if (bytes_p)
	{
	  /* Convert to a power of 2.  */
	  if (align != 0)
	    {
	      unsigned int i;
d1989 2
a1990 7
	      for (i = 0; (align & 1) == 0; align >>= 1, ++i)
		;
	      if (align != 1)
		as_bad (_("alignment not a power of 2"));
	      align = i;
	    }
	}
d1992 3
a1994 10
      if (align > max_alignment)
	{
	  align = max_alignment;
	  as_warn (_("alignment too large; %d assumed"), align);
	}
      else if (align < 0)
	{
	  align = 0;
	  as_warn (_("alignment negative; 0 assumed"));
	}
d1996 4
a1999 1
      record_alignment (bss_seg, align);
d2001 2
a2002 1
  else
d2004 5
a2008 3
      /* Assume some objects may require alignment on some systems.  */
#if defined (TC_ALPHA) && ! defined (VMS)
      if (temp > 1)
d2010 3
a2012 3
	  align = ffs (temp) - 1;
	  if (temp % (1 << align))
	    abort ();
d2014 1
a2014 1
#endif
d2016 8
d2025 4
a2028 3
  *p = 0;
  symbolP = symbol_find_or_make (name);
  *p = c;
d2030 1
a2030 12
  if (
#if (defined (OBJ_AOUT) || defined (OBJ_MAYBE_AOUT) \
     || defined (OBJ_BOUT) || defined (OBJ_MAYBE_BOUT))
#ifdef BFD_ASSEMBLER
      (OUTPUT_FLAVOR != bfd_target_aout_flavour
       || (S_GET_OTHER (symbolP) == 0 && S_GET_DESC (symbolP) == 0)) &&
#else
      (S_GET_OTHER (symbolP) == 0 && S_GET_DESC (symbolP) == 0) &&
#endif
#endif
      (S_GET_SEGMENT (symbolP) == bss_seg
       || (!S_IS_DEFINED (symbolP) && S_GET_VALUE (symbolP) == 0)))
d2032 3
a2034 31
      char *pfrag;

      subseg_set (bss_seg, 1);

      if (align)
	frag_align (align, 0, 0);

      /* Detach from old frag.  */
      if (S_GET_SEGMENT (symbolP) == bss_seg)
	symbol_get_frag (symbolP)->fr_symbol = NULL;

      symbol_set_frag (symbolP, frag_now);
      pfrag = frag_var (rs_org, 1, 1, (relax_substateT) 0, symbolP,
			(offsetT) temp, (char *) 0);
      *pfrag = 0;

      S_SET_SEGMENT (symbolP, bss_seg);

#ifdef OBJ_COFF
      /* The symbol may already have been created with a preceding
	 ".globl" directive -- be careful not to step on storage class
	 in that case.  Otherwise, set it to static.  */
      if (S_GET_STORAGE_CLASS (symbolP) != C_EXT)
	{
	  S_SET_STORAGE_CLASS (symbolP, C_STAT);
	}
#endif /* OBJ_COFF */

#ifdef S_SET_SIZE
      S_SET_SIZE (symbolP, temp);
#endif
d2037 2
a2038 3
    as_bad (_("symbol `%s' is already defined"), S_GET_NAME (symbolP));

  subseg_set (current_seg, current_subseg);
d2040 2
a2041 1
  demand_empty_rest_of_line ();
d2047 1
a2047 1
  s_lcomm_internal (needs_align, 0);
d2053 1
a2053 1
  s_lcomm_internal (needs_align, 1);
@


1.70
log
@	* ChangeLog: Fix typos.
	* ChangeLog-9295: Likewise.
	* as.c: Fix comment typos.
	* as.h: Likewise.
	* atof-generic.c: Likewise.
	* bit_fix.h: Likewise.
	* frags.h: Likewise.
	* hash.c: Likewise.
	* input-file.c: Likewise.
	* input-scrub.c: Likewise.
	* itbl-ops.c: Likewise.
	* itbl-parse.y: Likewise.
	* listing.c: Likewise.
	* macro.h: Likewise.
	* read.c: Likewise.
	* sb.c: Likewise.
	* sb.h: Likewise.
	* symbols.c: Likewise.
	* symbols.h: Likewise.
@
text
@d217 20
a236 20
static void cons_worker PARAMS ((int, int));
static int scrub_from_string PARAMS ((char *, int));
static void do_align PARAMS ((int, char *, int, int));
static void s_align PARAMS ((int, int));
static void s_lcomm_internal PARAMS ((int, int));
static int hex_float PARAMS ((int, char *));
static inline int sizeof_sleb128 PARAMS ((offsetT));
static inline int sizeof_uleb128 PARAMS ((valueT));
static inline int output_sleb128 PARAMS ((char *, offsetT));
static inline int output_uleb128 PARAMS ((char *, valueT));
static inline int output_big_sleb128 PARAMS ((char *, LITTLENUM_TYPE *, int));
static inline int output_big_uleb128 PARAMS ((char *, LITTLENUM_TYPE *, int));
static int output_big_leb128 PARAMS ((char *, LITTLENUM_TYPE *, int, int));
static void do_org PARAMS ((segT, expressionS *, int));
char *demand_copy_string PARAMS ((int *lenP));
static segT get_segmented_expression PARAMS ((expressionS *expP));
static segT get_known_segmented_expression PARAMS ((expressionS * expP));
static void pobegin PARAMS ((void));
static int get_line_sb PARAMS ((sb *));
static void generate_file_debug PARAMS ((void));
d239 1
a239 1
read_begin ()
d433 1
a433 2
pop_insert (table)
     const pseudo_typeS *table;
d459 1
a459 1
pobegin ()
d499 1
a499 3
scrub_from_string (buf, buflen)
     char *buf;
     int buflen;
d514 1
a514 2
read_a_source_file (name)
     char *name;
d1100 1
a1100 2
mri_comment_field (stopcp)
     char *stopcp;
d1131 1
a1131 3
mri_comment_end (stop, stopc)
     char *stop;
     int stopc;
d1142 1
a1142 2
s_abort (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1154 1
a1154 5
do_align (n, fill, len, max)
     int n;
     char *fill;
     int len;
     int max;
d1202 1
a1202 3
s_align (arg, bytes_p)
     int arg;
     int bytes_p;
d1317 1
a1317 2
s_align_bytes (arg)
     int arg;
d1326 1
a1326 2
s_align_ptwo (arg)
     int arg;
d1332 1
a1332 2
s_comm (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1430 1
a1430 2
s_mri_common (small)
     int small ATTRIBUTE_UNUSED;
d1529 1
a1529 2
s_data (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1559 1
a1559 2
s_app_file_string (file)
     char *file;
d1572 1
a1572 2
s_app_file (appfile)
     int appfile;
d1605 1
a1605 2
s_app_line (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1631 1
a1631 2
s_end (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1648 1
a1648 2
s_err (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1657 1
a1657 2
s_fail (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1679 1
a1679 2
s_fill (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1777 1
a1777 2
s_globl (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1817 1
a1817 2
s_irp (irpc)
     int irpc;
d1850 1
a1850 2
s_linkonce (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1921 7
a1927 7
s_lcomm_internal (needs_align, bytes_p)
     /* 1 if this was a ".bss" directive, which may require a 3rd argument
	(alignment); 0 if it was an ".lcomm" (2 args only).  */
     int needs_align;
     /* 1 if the alignment value should be interpreted as the byte boundary,
	rather than the power of 2.  */
     int bytes_p;
d2124 1
a2124 2
s_lcomm (needs_align)
     int needs_align;
d2130 1
a2130 2
s_lcomm_bytes (needs_align)
     int needs_align;
d2136 1
a2136 2
s_lsym (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2213 1
a2213 2
get_line_sb (line)
     sb *line;
d2272 1
a2272 2
s_macro (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2319 1
a2319 2
s_mexit (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2328 1
a2328 2
s_mri (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2366 1
a2366 4
do_org (segment, exp, fill)
     segT segment;
     expressionS *exp;
     int fill;
d2401 1
a2401 2
s_org (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2456 1
a2456 2
s_mri_sect (type)
     char *type ATTRIBUTE_UNUSED;
d2620 1
a2620 2
s_print (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2634 1
a2634 2
s_purgem (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2663 1
a2663 2
s_bad_endr (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2672 1
a2672 2
s_rept (ignore)
     int ignore ATTRIBUTE_UNUSED;
d2685 1
a2685 4
do_repeat (count, start, end)
     int count;
     const char *start;
     const char *end;
d2717 1
a2717 2
end_repeat (extra)
     int extra;
d2729 1
a2729 2
s_set (equiv)
     int equiv;
d2821 1
a2821 2
s_space (mult)
     int mult;
d2993 1
a2993 2
s_float_space (float_type)
     int float_type;
d3073 1
a3073 2
s_struct (ignore)
     int ignore ATTRIBUTE_UNUSED;
d3088 1
a3088 2
s_text (ignore)
     int ignore ATTRIBUTE_UNUSED;
d3101 1
a3101 1
demand_empty_rest_of_line ()
d3113 1
a3113 1
ignore_rest_of_line ()
d3137 1
a3137 1
discard_rest_of_line ()
d3157 1
a3157 2
pseudo_set (symbolP)
     symbolS *symbolP;
d3275 1
a3275 1
parse_mri_cons PARAMS ((expressionS *exp, unsigned int nbytes));
d3282 1
a3282 1
parse_bitfield_cons PARAMS ((expressionS *exp, unsigned int nbytes));
d3287 1
a3287 1
parse_repeat_cons PARAMS ((expressionS *exp, unsigned int nbytes));
d3308 2
a3309 3
cons_worker (nbytes, rva)
     register int nbytes;	/* 1=.byte, 2=.word, 4=.long.  */
     int rva;
d3372 1
a3372 2
cons (size)
     int size;
d3378 1
a3378 2
s_rva (size)
     int size;
d3387 1
a3387 3
emit_expr (exp, nbytes)
     expressionS *exp;
     unsigned int nbytes;
d3977 1
a3977 3
hex_float (float_type, bytes)
     int float_type;
     char *bytes;
d4079 2
a4080 3
float_cons (float_type)
     /* Clobbers input_line-pointer, checks end-of-line.  */
     register int float_type;	/* 'f':.ffloat ... 'F':.float ...  */
d4175 1
a4175 2
sizeof_sleb128 (value)
     offsetT value;
d4196 1
a4196 2
sizeof_uleb128 (value)
     valueT value;
d4213 1
a4213 3
sizeof_leb128 (value, sign)
     valueT value;
     int sign;
d4224 1
a4224 3
output_sleb128 (p, value)
     char *p;
     offsetT value;
d4251 1
a4251 3
output_uleb128 (p, value)
     char *p;
     valueT value;
d4271 1
a4271 4
output_leb128 (p, value, sign)
     char *p;
     valueT value;
     int sign;
d4284 1
a4284 4
output_big_sleb128 (p, bignum, size)
     char *p;
     LITTLENUM_TYPE *bignum;
     int size;
d4327 1
a4327 4
output_big_uleb128 (p, bignum, size)
     char *p;
     LITTLENUM_TYPE *bignum;
     int size;
d4366 1
a4366 4
output_big_leb128 (p, bignum, size, sign)
     char *p;
     LITTLENUM_TYPE *bignum;
     int size, sign;
d4378 1
a4378 3
emit_leb128_expr (exp, sign)
     expressionS *exp;
     int sign;
d4448 1
a4448 2
s_leb128 (sign)
     int sign;
d4468 3
a4470 3
stringer (append_zero)		/* Worker to do .ascii etc statements.  */
     /* Checks end-of-line.  */
     register int append_zero;	/* 0: don't append '\0', else 1.  */
d4568 1
a4568 1
next_char_of_string ()
d4690 1
a4690 2
get_segmented_expression (expP)
     register expressionS *expP;
d4708 1
a4708 2
get_known_segmented_expression (expP)
     register expressionS *expP;
d4731 1
a4731 2
get_absolute_expr (exp)
     expressionS *exp;
d4744 1
a4744 1
get_absolute_expression ()
d4752 1
a4752 2
get_absolute_expression_and_terminator (val_pointer)
     long *val_pointer;		/* Return value of expression.  */
d4763 1
a4763 2
demand_copy_C_string (len_pointer)
     int *len_pointer;
d4790 1
a4790 2
demand_copy_string (lenP)
     int *lenP;
d4829 1
a4829 1
is_it_end_of_statement ()
d4836 1
a4836 3
equals (sym_name, reassign)
     char *sym_name;
     int reassign;
d4898 1
a4898 2
s_incbin (x)
     int x ATTRIBUTE_UNUSED;
d5014 1
a5014 2
s_include (arg)
     int arg ATTRIBUTE_UNUSED;
d5074 1
a5074 2
add_include_dir (path)
     char *path;
d5102 1
a5102 1
generate_file_debug ()
d5111 1
a5111 1
generate_lineno_debug ()
d5138 1
a5138 2
s_func (end_p)
     int end_p;
d5147 1
a5147 3
do_s_func (end_p, default_prefix)
     int end_p;
     const char *default_prefix;
d5225 1
a5225 2
s_ignore (arg)
     int arg ATTRIBUTE_UNUSED;
d5235 1
a5235 2
read_print_statistics (file)
     FILE *file;
d5250 1
a5250 2
input_scrub_insert_line (line)
     const char *line;
d5264 1
a5264 2
input_scrub_insert_file (path)
     char *path;
@


1.69
log
@	* read.c (s_print): Check for NULL.
@
text
@d35 1
a35 1
/* Routines that read assembler source text to build spagetti in memory.
d626 1
a626 1
	  /* We are at the begining of a line, or similar place.
d985 1
a985 1
		     guarentee it...  */
d3803 1
a3803 1
   The rules are: pack least significat bit first, if a field doesn't
d4134 1
a4134 1
   truncatation, restored noisy bits instead of trailing 0s AND gave you
d5347 1
a5347 1
   An appropriate use of this function would be substition of input lines when
@


1.68
log
@	* read.c (s_space): Revert 2003-07-28 change.
@
text
@d54 1
a54 1
#define TC_IMPLICIT_LCOMM_ALIGNMENT(SIZE, P2VAR)        	\
d56 9
a64 9
    {                                                   	\
      if ((SIZE) >= 8)                                      	\
	(P2VAR) = 3;                                        	\
      else if ((SIZE) >= 4)                                 	\
	(P2VAR) = 2;                                        	\
      else if ((SIZE) >= 2)                                 	\
	(P2VAR) = 1;                                        	\
      else                                                  	\
	(P2VAR) = 0;                                        	\
d476 1
a476 1
  
d604 2
a605 2
                         pseudo-op specially: we don't want to put the
                         symbol in the symbol table.  */
d688 4
a691 4
	         That character's place in the input line is now '\0'.
	         S points to the beginning of the symbol.
	           [In case of pseudo-op, s->'.'.]
	         Input_line_pointer->'\0' where c was.  */
d757 1
a757 1
                         without a period.  */
d768 3
a770 3
		         WARNING: c has next char, which may be end-of-line.
		         We lookup the pseudo-op table with s+1 because we
		         already know that the pseudo-op begins with a '.'.  */
d776 2
a777 2
                         automatic alignment directive.  What a hack
                         this is.  */
d824 2
a825 2
		         Input_line_pointer->1st non-blank char
		         after pseudo-operation.  */
d1608 1
a1608 1
         backquote.  */
d1659 1
a1659 1
         but we don't support that.  */
d1785 4
a1788 4
         flavoured AS.  The following bizarre behaviour is to be
         compatible with above.  I guess they tried to take up to 8
         bytes from a 4-byte expression and they forgot to sign
         extend.  */
d1795 2
a1796 2
         but emits no error message because it seems a legal thing to do.
         It is a degenerate case of .fill but could be emitted by a
d2132 2
a2133 2
         ".globl" directive -- be careful not to step on storage class
         in that case.  Otherwise, set it to static.  */
d2668 2
a2669 1
  printf ("%s\n", s);
d2836 1
a2836 1
         for this symbol.  */
d3204 1
a3204 1
  	Input_line_pointer->expression.
d3207 2
a3208 2
  	Tried to set symbol to value of expression.
  	Will change symbols type, value, and frag;  */
d3305 1
a3305 1
/*  			cons()
d4123 1
a4123 1
/*  			float_cons()
d4166 3
a4168 3
         letter is legal. Someone may invent a "z" format and this routine
         has no use for such information. Lusers beware: you get
         diagnostics if your input is ill-conditioned.  */
d4174 1
a4174 1
         point with the exact digits specified.  */
d4587 1
a4587 1
  
d4609 5
a4613 5
             will emit .string with a filename in the .debug section
             after a sequence of constants.  See the comment in
             emit_expr for the sequence.  emit_expr will set
             dwarf_file_string to non-zero if this string might be a
             source file name.  */
d5123 1
a5123 1
             called ignore_rest_of_line.  */
@


1.67
log
@	* read.c (s_space): Don't warn about .space 0.
@
text
@d2973 3
a2975 1
	      if (repeat < 0)
@


1.66
log
@2003-07-22  H.J. Lu <hongjiu.lu@@intel.com>

	* read.c (do_parse_cons_expression): Mark nbytes unused to
	silence gcc.
@
text
@d2973 1
a2973 3
	      if (!flag_mri)
		as_warn (_(".space repeat count is zero, ignored"));
	      else if (repeat < 0)
@


1.65
log
@Update .comm error messages to assume an unsigned value.
Update relaxing code to work in 64-bit address spaces.
@
text
@d3351 2
a3352 1
do_parse_cons_expression (expressionS *exp, int nbytes)
@


1.64
log
@        * dw2gencfi.c (struct cfi_escape_data): New.
        (cfi_add_CFA_nop): Remove.
        (CFI_escape, dot_cfi_escape): New.
        (dot_cfi): Remove nop.
        (cfi_pseudo_table): Remove nop; add escape.
        (output_cfi_insn): Likewise.
        (select_cie_for_fde): Stop on escape.
        * dw2gencfi.h (cfi_add_CFA_nop): Remove.
        * read.c, read.h (do_parse_cons_expression): New.
        * doc/as.texinfo (.cfi_escape): New.

        * gas/cfi/cfi-common-3.[ds]: New.
        * gas/cfi/cfi.exp: Run it.
@
text
@d1392 2
a1393 1
      as_warn (_(".COMMon length (%ld) < 0 ignored"), (long) temp);
@


1.63
log
@	* read.c (emit_expr): Set dot_value.
	* dw2gencfi.c (output_fde): Remove pcrel reloc hack.
@
text
@d3349 7
@


1.62
log
@	* dw2gencfi.c, dw2gencfi.h: New files.
	* config/tc-i386.c (tc_x86_cfi_init): New function.
	* config/tc-i386.h (TARGET_USE_CFIPOP, tc_cfi_init): New defines.
	* as.c (parse_args): Set verbose flag on --verbose.
	(main): Call tc_cfi_init()/cfi_finish().
	* as.h (verbose): New external variable.
	* read.c (pobegin): Insert CFI pops to the list.
	* symbols.c (local_symbol_make): Make symbol external.
	* symbols.h (local_symbol_make): New prototype.
	* Makefile.am: Add dw2gencfi.[ch] files.  Run "make dep-am".
	* Makefile.in: Regenerate.
	* doc/as.texinfo: Added node "CFI directives" with description of
	all implemented .cfi_* directives.
	* doc/Makefile.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d3447 2
@


1.61
log
@	* read.c (old_buffer, old_input, old_limit): Remove variables.
 	(read_a_source_file): Delete label contin.
	<handling #APP/#NO_APP>: Use an "sb" to push #APP expansion into
	input as with macros, instead of in separate old_* variables.
	Zero-terminate string being scrubbed.
@
text
@d46 1
d455 4
d476 6
@


1.60
log
@2003-05-01  H.J. Lu <hjl@@gnu.org>

	* config/tc-ia64.c (ia64_check_label): New.
	* config/tc-ia64.h (tc_check_label): New.

	* read.c (read_a_source_file): Call tc_check_label after
	creating a user-defined label if defined.
@
text
@a170 4
static char *old_buffer;	/* JF a hack.  */
static char *old_input;
static char *old_limit;

d532 1
a532 3
    contin:			/* JF this goto is my fault I admit it.
				   Someone brave please re-write the whole
				   input section here?  Pleeze???  */
d950 1
d963 1
d1025 1
a1025 1
		      new_tmp += size;
a1035 6
	      old_buffer = buffer;
	      old_input = input_line_pointer;
	      old_limit = buffer_limit;
	      buffer = new_buf;
	      input_line_pointer = new_buf;
	      buffer_limit = new_tmp;
d1037 12
a1065 14

      if (old_buffer)
	{
	  free (buffer);
	  bump_line_counters ();
	  if (old_input != 0)
	    {
	      buffer = old_buffer;
	      input_line_pointer = old_input;
	      buffer_limit = old_limit;
	      old_buffer = 0;
	      goto contin;
	    }
	}
@


1.59
log
@(buffer_and_nest): Store more to sb instead of '\n'.
(get_line_sb): Return end of line character or '\n' if it is zero or
non-existent.
@
text
@d713 3
@


1.59.2.1
log
@	* read.c (old_buffer, old_input, old_limit): Remove variables.
 	(read_a_source_file): Delete label contin.
	<handling #APP/#NO_APP>: Use an "sb" to push #APP expansion into
	input as with macros, instead of in separate old_* variables.
	Zero-terminate string being scrubbed.
@
text
@d171 4
d536 3
a538 1

a952 1
	      sb sbuf;
a964 1
	      sb_new (&sbuf);
d1026 1
a1026 1
		      new_tmp[size] = 0;
d1037 6
a1043 12
	      /* We've "scrubbed" input to the preferred format.  In the
		 process we may have consumed the whole of the remaining
		 file (and included files).  We handle this formatted
		 input similar to that of macro expansion, letting
		 actual macro expansion (possibly nested) and other
		 input expansion work.  Beware that in messages, line
		 numbers and possibly file names will be incorrect.  */
	      sb_add_string (&sbuf, new_buf);
	      input_scrub_include_sb (&sbuf, input_line_pointer, 0);
	      sb_kill (&sbuf);
	      buffer_limit = input_scrub_next_buffer (&input_line_pointer);
	      free (new_buf);
d1061 14
@


1.58
log
@	* read.c (get_absolute_expr): New, split out from..
	(get_absolute_expression): ..here.
	* read.h (get_absolute_expr): Declare.
	* config/obj-elf.c (elf_common): Use offsetT for "temp" and "size".
	Trim size to arch bits_per_address, and test for negative input
	via get_absolute_expr.
@
text
@d2238 2
a2239 1
/* Read a line into an sb.  */
d2246 1
d2274 3
a2276 2
  while (!is_end_of_line[(unsigned char) *input_line_pointer]
	 || (inquote != '\0' && *input_line_pointer != '\n'))
d2278 1
a2278 1
      if (inquote == *input_line_pointer)
d2282 1
a2282 1
	  if (*input_line_pointer == quote1)
d2284 1
a2284 1
	  else if (*input_line_pointer == quote2)
d2288 1
a2288 1
      sb_add_char (line, *input_line_pointer++);
d2291 6
a2296 9
  while (input_line_pointer < buffer_limit
	 && is_end_of_line[(unsigned char) *input_line_pointer])
    {
      if (input_line_pointer[-1] == '\n')
	bump_line_counters ();
      ++input_line_pointer;
    }

  return 1;
@


1.57
log
@Remove GASP.
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d4805 14
d4823 1
a4823 8
  expression (&exp);
  if (exp.X_op != O_constant)
    {
      if (exp.X_op != O_absent)
	as_bad (_("bad or irreducible absolute expression"));
      exp.X_add_number = 0;
    }
  return exp.X_add_number;
@


1.56
log
@	* read.c (emit_expr) [WORKING_DOT_WORD]: Initialize x->use_jump.
@
text
@d865 1
a865 1
			  if (check_macro (s, &out, '\0', &err, &macro))
d1858 1
a1858 1
  err = expand_irp (irpc, 0, &s, &out, get_line_sb, '\0');
d2299 1
a2299 2
/* Define a macro.  This is an interface to macro.c, which is shared
   between gas and gasp.  */
@


1.55
log
@	* read.c (do_align): Use ATTRIBUTE_UNUSED_LABEL for label, not
	ATTRIBUTE_UNUSED.
@
text
@d3594 1
@


1.54
log
@	* dwarf2dbg.c: Always include dwarf2dbg.h.
	(dwarf2_directive_file): Adjust dummy version args.
	* ecoff.c (ecoff_directive_weakext): Add ATTRIBUTE_UNUSED.
	* expr.c (clean_up_expression <O_subtract>): Allow subtraction
	when symbol values differ.
	* read.c (do_align): Add ATTRIBUTE_UNUSED to label.
	(pseudo_set <O_subtract>): Remove unnecessary segment test.
	* config/obj-bout.c (obj_pseudo_table): Warning fix.
@
text
@d1200 1
a1200 1
 just_record_alignment: ATTRIBUTE_UNUSED
@


1.53
log
@Catch attempts to create strings in the abs section.
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d1200 1
a1200 1
 just_record_alignment:
a3234 2
	   && (S_GET_SEGMENT (exp.X_add_symbol)
	       == S_GET_SEGMENT (exp.X_op_symbol))
@


1.52
log
@2002-06-14  H.J. Lu  <hjl@@gnu.org>
            Daniel Jacobowitz  <drow@@mvista.com>

        * dwarf2dbg.h (dwarf2_directive_file): Return char *.
        * dwarf2dbg.c (dwarf2_directive_file): Return filename.
        * config/tc-mips.c (s_mips_file): Call s_app_file_string
        and new_logical_line for the first .file directive.
        * read.c (s_app_file_string): New function.
        (s_app_file): Call it.
        * read.h (s_app_file_string): Add declaration.

2002-06-14  Daniel Jacobowitz  <drow@@mvista.com>

        * configure.in: Remove MIPS_STABS_ELF.
        * configure: Regenerated.
        * config.in: Regenerated.
        * config/obj-elf.h (ECOFF_DEBUGGING): Define to mips_flag_mdebug
        for MIPS targets.
        * config/tc-mips.c (mips_pseudo_table): Remove #ifdef around
        ".extern".
        (pdr_seg): Declare unconditionally.
        (md_begin): Always generate .pdr unless ECOFF_DEBUGGING or not ELF.
        (s_mips_end): Likewise.  Generate stabs function markers.
        (s_mips_ent): Generate stabs function markers.
        (s_mips_frame): Always generate .pdr unless ECOFF_DEBUGGING or not
        ELF.
        (s_mips_mask): Likewise.
        (mips_flag_mdebug): New.
        (md_longopts): Add "mdebug" and "no-mdebug".
        (md_parse_options): Add OPTION_MDEBUG and OPTION_NO_MDEBUG.
        (mips_after_parse_args): Set mips_flag_mdebug.
        * doc/as.texinfo: Add "-mdebug" and "-no-mdebug" for MIPS.

2002-06-14  Daniel Jacobowitz  <drow@@mvista.com>

        * gas/mips/lineno.d: Use --gstabs.
        * gas/mips/mips.exp (lineno.s): Remove XFAIL.
@
text
@d4567 9
@


1.52.2.1
log
@2002-09-23  Daniel Jacobowitz  <drow@@mvista.com>

	Merge from mainline:
	2002-09-22  Mark Elbrecht  <snowball3@@softhome.net>
	* write.c: Delete set_segment_vma and prototype. Update all callers.

	2002-09-19  Jakub Jelinek  <jakub@@redhat.com>
	* config/tc-i386.c (tc_i386_fix_adjustable): Handle
	BFD_RELOC_386_TLS_IE and BFD_RELOC_386_TLS_GOTIE.
	(BFD_RELOC_386_TLS_IE, BFD_RELOC_386_TLS_GOTIE): Define to 0
	if not defined.
	(lex_got): Handle @@GOTNTPOFF and @@INDNTPOFF.
	(md_apply_fix3, tc_gen_reloc): Handle BFD_RELOC_386_TLS_IE and
	BFD_RELOC_386_TLS_GOTIE.

	2002-09-16  Chris Demetriou  <cgd@@broadcom.com>
	* config/tc-mips.c (IS_SEXT_32BIT_NUM): Move closer to top of file.
	(IS_SEXT_16BIT_NUM): New macro.
	(macro_build_ldst_constoffset): New function, to build a set of
	instructions to do a load or store from a constant offset relative
	to a given register.
	(macro, s_cprestore): Use macro_build_ldst_constoffset to implement
	.cprestore pseudo-op.

	2002-09-16  Elias Athanasopoulos  <eathan@@otenet.gr>
	* dwarf2dbg.c (out_debug_abbrev): Add support for the DW_AT_name field.
	(out_debug_info): Likewise.

	2002-09-13  Nick Clifton  <nickc@@redhat.com>
	* config/tc-ppc.c (md_assemble): Do not count FAKE operands
	when deciding if any operands have been skipped.

	2002-09-11  Jakub Jelinek  <jakub@@redhat.com>
	* config/tc-i386.c (md_apply_fix3): Allow addend for
	BFD_RELOC_386_TLS_LDO_32, BFD_RELOC_386_TLS_LE and
	BFD_RELOC_386_TLS_LE_32.

	2002-09-11  Nick Clifton  <nickc@@redhat.com>
	* po/tr.po: Updated Turkish translation.

	2002-09-04  Nick Clifton  <nickc@@redhat.com>
	* config/tc-ppc.c (md_begin): Do not insert non-BookE32
	instructions into the hash table if the target cpu is the BookE32.

	2002-08-20  Richard Sandiford  <rsandifo@@redhat.com>
	* config/tc-mips.c (macro2): Implement rotates by zero using shifts
	by zero.

	2002-08-15  Alexandre Oliva  <aoliva@@redhat.com>
	* config/tc-mips.c (macro_build_jalr): Make sure we generate
	the fix-up against on the right frag.
	(s_cpsetup): Likewise.  Parse third argument as expression, to
	handle global symbols and forward/backward labels correctly.

	2002-08-14  Nick Clifton  <nickc@@redhat.com>
	* read.c (stringer): Catch attempts to create strings in the abs
	section.

	2002-08-12  Richard Sandiford  <rsandifo@@redhat.com>
	* config/tc-mips.c (mips_ip): Don't work out the value of
	constant %hi()s here.

	2002-08-10  Alan Modra  <amodra@@bigpond.net.au>
	* config/tc-i386.c (tc_i386_fix_adjustable): Test OUTPUT_FLAVOR
	for ELF, and don't bother checking ELF relocs when non-ELF.
	(i386_immediate): Allow absolute_section expressions for aout.
	(i386_displacement): Likewise.  Also test bfd_is_com_section.
	(md_estimate_size_before_relax): Test OUTPUT_FLAVOR for ELF.
	(md_apply_fix3): Hack for bfd_install_relocation when fx_pcrel,
	not when fx_addsy.  Remove dead code.

	2002-08-06  George France <france@@handhelds.org>
	* config/tc-alpha.c (cpu_types): Enabled ev67, ev68,  -m21264a
	and m21264b processor names and cpu types.
	* doc/c-alpha.texi: Documented new types.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* config/tc-ppc.c (md_apply_fix3): Adjust 16 bit XCOFF reloc offset.

	2002-08-03  Jakub Jelinek  <jakub@@redhat.com>
	* config/tc-i386.c (output_insn): Save frag_now and frag_now_fix ()
	at start of insn, pass it to output_disp and output_imm.
	(output_disp): Added arguments.  If _GLOBAL_OFFSET_TABLE_ is seen
	in displacement for R_386_32 reloc, use R_386_GOTPC and compute
	properly addend.
	(output_imm): Added arguments.  Compute properly addend for
	R_386_GOTPC.
	(md_apply_fix3): Remove R_386_GOTPC handling.

	2002-07-31  Momchil Velikov  <velco@@fadata.bg>
	* config/tc-v850.c (md_assemble): Fix range check for immediate
	operand.

	2002-07-04  Bruno Haible  <bruno@@clisp.org>
	* config/tc-i386.h (ELF_TARGET_FORMAT): New macro.
	(TARGET_FORMAT): Use ELF_TARGET_FORMAT instead of "elf32-i386".
	* config/tc-i386.c (i386_target_format): Likewise.
	* config/tc-alpha.h (ELF_TARGET_FORMAT): New macro.
	(TARGET_FORMAT): Use ELF_TARGET_FORMAT instead of "elf64-alpha".
@
text
@a4566 9
  /* If we have been switched into the abs_section then we
     will not have an obstack onto which we can hang strings.  */
  if (now_seg == absolute_section)
    {
      as_bad (_("strings must be placed into a section"));
      c = 0;
      ignore_rest_of_line ();
    }
  
@


1.51
log
@	* as.h: Fix formatting.
	* cgen.c: Likewise.
	* cgen.h: Likewise.
	* dwarf2dbg.c: Likewise.
	* frags.h: Likewise.
	* gasp.c: Likewise.
	* macro.c: Likewise.
	* read.c: Likewise.
	* stabs.c: Likewise.
	* symbols.c: Likewise.
@
text
@d1575 14
d1613 1
a1613 10
	{
#ifdef LISTING
	  if (listing)
	    listing_source_file (s);
#endif
	  register_dependency (s);
#ifdef obj_app_file
	  obj_app_file (s);
#endif
	}
@


1.50
log
@do not allow size or nbytes to go negative.
@
text
@d48 1
a48 1
#define TC_START_LABEL(x,y) (x==':')
@


1.49
log
@Generate warning message if .endr is used without preceeding .rept/.irc/.irp
@
text
@d3686 1
a3686 1
	  while (size > 0)
d3697 1
a3697 1
	  while (size > 0)
d3706 1
a3706 1
	  while (nbytes > 0)
@


1.48
log
@	* subsegs.c (subseg_text_p): Return 0 for absolute section.
	* read.c (do_align): If in absolute section, warn about and ignore
	non-zero fill pattern.
@
text
@d318 1
d2692 10
@


1.47
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d1165 13
@


1.46
log
@	* ecoff.c (ecoff_frob_symbol): Remove casts from bfd_get_gp_size.
	(ecoff_build_symbols): Likewise.
	* read.c (s_lcomm_internal): Fix signed/unsigned warning.
@
text
@a37 3
/* For isdigit ().  */
#include <ctype.h>

d39 1
d740 1
a740 2
			if (isupper ((unsigned char) *s2))
			  *s2 = tolower (*s2);
d907 1
a907 2
	  if ((LOCAL_LABELS_DOLLAR || LOCAL_LABELS_FB)
	      && isdigit ((unsigned char) c))
d917 1
a917 1
	      while (isdigit ((unsigned char) *input_line_pointer))
d1452 1
a1452 1
  if (!isdigit ((unsigned char) *name))
d1460 1
a1460 1
      while (isdigit ((unsigned char) *input_line_pointer));
d2487 1
a2487 1
  if (!isdigit ((unsigned char) *name))
d2495 1
a2495 1
      while (isdigit ((unsigned char) *input_line_pointer));
d2520 1
a2520 1
      c = toupper ((unsigned char) c);
d3043 1
a3043 1
      && isalpha ((unsigned char) input_line_pointer[1]))
d3140 1
a3140 1
      if (isprint ((unsigned char) *input_line_pointer))
d4129 1
a4129 1
	  && isalpha ((unsigned char) input_line_pointer[1]))
d4667 1
a4667 1
		 isdigit (c) && i < 3;
d4685 1
a4685 1
	    while (isxdigit (c))
d4687 1
a4687 1
		if (isdigit (c))
d4689 1
a4689 1
		else if (isupper (c))
@


1.45
log
@	* read.c: Standardize error/warning messages - don't capitalise, no
	final period or newline, don't say "ignored" or "zero assumed" for
	as_bad messages.  In some cases, change the wording to that used
	elsewhere for similar messages.
	* app.c, as.c, atof-generic.c, cgen.c, cond.c, depend.c, dwarf2dbg.c,
	  ecoff.c, expr.c, frags.c, input-file.c, input-scrub.c, listing.c,
	  output-file.c, stabs.c, subsegs.c, symbols.c, write.c: Likewise.
	* ecoff.c (ecoff_directive_end): Test for missing name by
	comparing input line pointers rather than reading string.
	(ecoff_directive_ent): Likewise.
	* read.c (s_set): Likewise.
	(s_align): Report a warning rather than an error for
	alignment too large.
	(s_comm): Check for missing symbol name.
	(s_lcomm_internal): Likewise.
	(s_lsym): Likewise.
	(s_globl): Use is_end_of_line instead of looking for '\n'.
	(s_lcomm_internal): Likewise.
	(ignore_rest_of_line): Report a warning rather than an error.
@
text
@d1991 1
a1991 1
      if (temp <= bfd_get_gp_size (stdoutput))
@


1.44
log
@	* read.c (s_set): Check for missing symbol name.
@
text
@d803 1
a803 1
			  as_bad (_("Unknown pseudo-op:  `%s'"), s);
d1056 2
a1057 2
	  /* as_warn (_("Junk character %d."),c); Now done by ignore_rest.  */
	  input_line_pointer--;	/* Report unknown char as ignored.  */
d1239 1
a1239 1
	    as_bad (_("Alignment not a power of 2"));
d1248 1
a1248 1
      as_bad (_("Alignment too large: %u assumed"), align);
d1355 8
d1367 3
a1369 1
      as_bad (_("Expected comma after symbol-name: rest of line ignored."));
d1380 1
a1380 1
      as_warn (_(".COMMon length (%ld.) <0! Ignored."), (long) temp);
d1393 1
a1393 1
      as_bad (_("Ignoring attempt to re-define symbol `%s'."),
d1404 1
a1404 1
	as_bad (_("Length of .comm \"%s\" is already %ld. Not changed to %ld."),
d1494 1
a1494 1
      as_bad (_("attempt to re-define symbol `%s'"), S_GET_NAME (sym));
d1618 1
a1618 1
    as_warn (_("Line numbers must be positive; line number %d rejected."),
d1714 1
a1714 1
      as_warn (_(".fill size clamped to %d."), BSD_FILL_SIZE_CROCK_8);
d1719 1
a1719 1
      as_warn (_("Size negative: .fill ignored."));
d1725 1
a1725 1
	as_warn (_("Repeat < 0, .fill ignored"));
d1811 1
a1811 1
	  if (*input_line_pointer == '\n')
d1955 8
d1973 1
a1973 1
  if (*input_line_pointer == '\n')
d1975 1
a1975 1
      as_bad (_("Missing size expression"));
d1981 1
a1981 1
      as_warn (_("BSS length (%d.) <0! Ignored."), temp);
d2020 1
a2020 1
	  as_bad (_("Expected comma after size"));
d2028 1
a2028 1
      if (*input_line_pointer == '\n')
d2030 1
a2030 1
	  as_bad (_("Missing alignment"));
d2046 1
a2046 1
		as_bad (_("Alignment not a power of 2"));
d2054 1
a2054 1
	  as_warn (_("Alignment too large: %d. assumed."), align);
d2059 1
a2059 1
	  as_warn (_("Alignment negative. 0 assumed."));
d2127 1
a2127 2
    as_bad (_("Ignoring attempt to re-define symbol `%s'."),
	    S_GET_NAME (symbolP));
d2163 8
d2176 1
a2176 1
      as_bad (_("Expected comma after name \"%s\""), name);
d2216 1
a2216 1
      as_bad (_("Symbol %s already defined"), name);
d2391 1
a2391 2
    as_bad (_("invalid segment \"%s\"; segment \"%s\" assumed"),
	    segment_name (segment), segment_name (now_seg));
d2764 1
d2766 1
a2766 1
  if (name[0] == '\0')
a2768 1
      *end_name = delim;
a2772 1
  *end_name = delim;
d2778 1
a2778 1
      as_bad (_("Expected comma after name \"%s\""), name);
d2836 1
a2836 1
    as_bad (_("symbol `%s' already defined"), S_GET_NAME (symbolP));
d2922 1
a2922 1
	as_bad (_("Unsupported variable size or fill value"));
d3072 1
a3072 1
	  as_bad (_("Bad floating literal: %s"), err);
d3145 2
a3146 2
	as_bad (_("Rest of line ignored. First ignored character is `%c'."),
		*input_line_pointer);
d3148 2
a3149 2
	as_bad (_("Rest of line ignored. First ignored character valued 0x%x."),
		*input_line_pointer);
d3199 1
a3199 1
    as_bad (_("illegal expression; zero assumed"));
d3201 1
a3201 1
    as_bad (_("missing expression; zero assumed"));
d3205 1
a3205 1
	as_bad (_("bignum invalid; zero assumed"));
d3207 1
a3207 1
	as_bad (_("floating point number invalid; zero assumed"));
d3252 1
a3252 1
	as_bad ("invalid attempt to set value of section symbol");
d3540 1
a3540 1
      as_bad (_("floating point number invalid; zero assumed"));
d3636 1
a3636 1
	  as_warn (_("Value 0x%lx truncated to 0x%lx."),
d3652 1
a3652 1
	  as_warn (_("Bignum truncated to %d bytes"), nbytes);
d3983 1
a3983 1
      as_warn (_("Unresolvable or nonpositive repeat count; using 1"));
d4034 1
a4034 1
      as_bad (_("Unknown floating type type '%c'"), float_type);
d4056 1
a4056 1
	  as_warn (_("Floating point constant too large"));
d4155 1
a4155 1
	      as_bad (_("Bad floating literal: %s"), err);
d4439 1
a4439 1
      as_bad (_("floating point number invalid; zero assumed"));
d4587 1
a4587 1
	      as_bad (_("Expected <nn>"));
d4620 1
a4620 1
      as_warn (_("Unterminated string: Newline inserted."));
d4706 1
a4706 1
	  as_warn (_("Unterminated string: Newline inserted."));
d4714 1
a4714 1
	  as_bad (_("Bad escaped character in string, '?' assumed"));
d4740 1
a4740 1
      as_bad (_("expected address expression; zero assumed"));
d4781 1
a4781 1
	as_bad (_("bad or irreducible absolute expression; zero assumed"));
d4816 1
a4816 1
	      as_bad (_("This string may not contain \'\\0\'"));
d4853 1
a4853 1
      as_warn (_("Missing string"));
d4917 1
a4917 1
	as_bad (_("symbol `%s' already defined"), S_GET_NAME (symbolP));
@


1.43
log
@Use FOPEN_.. macros in calls to fopen().
@
text
@d2740 9
@


1.42
log
@Add .incbin pseudo op
@
text
@d3 1
a3 1
   1998, 1999, 2000 Free Software Foundation, Inc.
d4953 1
a4953 1
  binfile = fopen (filename, "rb");
d4964 1
a4964 1
	  binfile = fopen (path, "rb");
d4977 2
d4987 1
a4987 1
      len = ftell (binfile);
d4991 1
a4991 1
	count = len;
d4993 1
a4993 1
      if (skip + count > len)
d4996 1
a4996 1
		  skip, count, len);
d5069 1
a5069 1
      if (0 != (try = fopen (path, "r")))
@


1.41
log
@2001-07-05  Ben Elliston  <bje@@redhat.com>

	* read.c (s_fill): Correct spelling error in comments.
@
text
@d352 1
d4902 115
@


1.40
log
@        * read.c (emit_leb128_expr): Call md_cons_align.
@
text
@d1756 1
a1756 1
         flavoured AS.  The following bizzare behaviour is to be
d1759 1
a1759 1
         extend. Un*x Sux.  */
@


1.39
log
@Revert last patch.
@
text
@d4422 5
@


1.38
log
@	* expr.c (expr): Set return value to absolute_section for
	subtractive operations on symbols within a segment.
	* read.c (pseudo_set): Set segment for complex expressions.
@
text
@a3153 1
  segT seg;
d3163 1
a3163 1
  seg = expression (&exp);
d3239 2
a3240 1
      /* The value is some complex expression.  */
a3241 1
      S_SET_SEGMENT (symbolP, seg);
@


1.37
log
@        * ehopt.c (get_cie_info): Rename from eh_frame_code_alignment;
        also collect whether to expect an FDE augmentation.
        (check_eh_frame): Rewrite as a state machine.  Track where in
        an FDE we are located, skip any augmentation.
        (eh_frame_estimate_size_before_relax): Get code alignment from
        the fragment subtype.
        (eh_frame_relax_frag, eh_frame_convert_frag): Likewise.
        * read.c (emit_leb128_expr): Call check_eh_frame.
@
text
@d3154 1
d3164 1
a3164 1
  (void) expression (&exp);
d3240 1
a3240 2
      /* The value is some complex expression.
	 FIXME: Should we set the segment to anything?  */
d3242 1
@


1.36
log
@2001-03-28  H.J. Lu  <hjl@@gnu.org>

	* read.c (equals): Set to local for COFF only if it hasn't been
	defined before.
@
text
@d4396 1
d4415 6
@


1.35
log
@(for COFF) default symbols to being local.
@
text
@d4860 7
d4876 2
a4877 1
      SF_SET_LOCAL (symbolP);
@


1.34
log
@Teach .org to handle complex expressions
@
text
@d4866 6
@


1.33
log
@Fix copyright notices
@
text
@d2382 2
d2385 8
a2392 2
      p = frag_var (rs_org, 1, 1, (relax_substateT) 0, exp->X_add_symbol,
		    exp->X_add_number * OCTETS_PER_BYTE, (char *) NULL);
@


1.32
log
@	* as.h (rs_align_test): New.
	* frags.c (NOP_OPCODE): Move default from read.c.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New default.
	(frag_align_code): New.
	* frags.h (frag_align_code): Declare.
	* read.c (NOP_OPCODE): Remove.
	(do_align): Use frag_align_code.
	* write.c (NOP_OPCODE): Remove.
	(get_recorded_alignment): New.
	(cvt_frag_to_fill): Handle rs_align_test.
	(relax_segment): Likewise.
	(subsegs_finish): Align last subseg in section to the
	section alignment.  Use frag_align_code.
	* write.h (get_recorded_alignment): Declare.
	* config/obj-coff.c (size_section): Handle rs_align_test.
	(fill_section, fixup_mdeps): Likewise.
	(write_object_file): Use frag_align_code.

	* config/tc-alpha.c (alpha_align): Use frag_align_code.
	(alpha_handle_align): New.
	* config/tc-alpha.h (HANDLE_ALIGN): New.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-i386.h (md_do_align): Use frag_align_code.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-ia64.c (ia64_md_do_align): Don't do code alignment.
	(ia64_handle_align): New.
	* config/tc-ia64.h (HANDLE_ALIGN): New.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-m32r.c (m32r_do_align): Remove.
	(m32r_handle_align): New.
	(fill_insn): Use frag_align_code.
	* config/tc-m32r.h (md_do_align): Remove.
	(HANDLE_ALIGN, MAX_MEM_FOR_RS_ALIGN_CODE): New.
	* config/tc-m88k.c, config/tc-m88k.h: Similarly.
	* config/tc-mips.c, config/tc-mips.h: Similarly.

	* config/tc-sh.c (sh_cons_align): Use rs_align_test.
	(sh_handle_align): Likewise.  Handle rs_align_code.
	(sh_do_align): Remove.
	* config/tc-sh.h (md_do_align): Remove.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-sparc.c (sparc_cons_align): Use rs_align_test.
	(sparc_handle_align): Likewise.  Handle rs_align_code.
	* config/tc-sparc.h (md_do_align): Remove.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.
@
text
@d2 2
a3 2
   Copyright (C) 1986, 87, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99,
   2000 Free Software Foundation, Inc.
@


1.32.2.1
log
@        * ehopt.c (get_cie_info): Rename from eh_frame_code_alignment;
        also collect whether to expect an FDE augmentation.
        (check_eh_frame): Rewrite as a state machine.  Track where in
        an FDE we are located, skip any augmentation.
        (eh_frame_estimate_size_before_relax): Get code alignment from
        the fragment subtype.
        (eh_frame_relax_frag, eh_frame_convert_frag): Likewise.
        * read.c (emit_leb128_expr): Call check_eh_frame.
@
text
@a4387 1
  int nbytes;
a4405 6

  /* Let check_eh_frame know that data is being emitted.  nbytes == -1 is
     a signal that this is leb128 data.  It shouldn't optimize this away.  */
  nbytes = -1;
  if (check_eh_frame (exp, &nbytes))
    abort ();
@


1.32.2.2
log
@Merge from mainline.
@
text
@a4858 7
#ifdef OBJ_COFF
      int local;

      symbolP = symbol_find (sym_name);
      local = symbolP == NULL;
      if (local)
#endif /* OBJ_COFF */
a4864 7

#ifdef OBJ_COFF
      /* "set" symbols are local unless otherwise specified.  */
      if (local)
	SF_SET_LOCAL (symbolP);
#endif /* OBJ_COFF */

@


1.32.2.3
log
@        * read.c (emit_leb128_expr): Call md_cons_align.
@
text
@a4413 5
  /* Let the backend know that subsequent data may be byte aligned.  */
#ifdef md_cons_align
  md_cons_align (1);
#endif

@


1.32.2.4
log
@Update copyright notices.
@
text
@d2 2
a3 2
   Copyright 1986, 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997,
   1998, 1999, 2000 Free Software Foundation, Inc.
@


1.32.2.5
log
@Merge from mainline.
@
text
@a2381 2
      symbolS *sym = exp->X_add_symbol;
      offsetT off = exp->X_add_number * OCTETS_PER_BYTE;
d2383 2
a2384 8
      if (exp->X_op != O_constant && exp->X_op != O_symbol)
	{
	  /* Handle complex expressions.  */
	  sym = make_expr_symbol (exp);
	  off = 0;
	}

      p = frag_var (rs_org, 1, 1, (relax_substateT) 0, sym, off, (char *) 0);
@


1.31
log
@	* as.c (debug_type): Init to DEBUG_UNSPECIFIED.
	* as.h (debug_type): Clarify documentation of the meaning
	of this variable.
	* dwarf2dbg.c (DWARF2_LINE_MIN_INSN_LENGTH): Default to 1.
	(print_stats): Fix parenthesis problem.
	(now_subseg_size): New.
	(dwarf2_finish): Use it.  If DEBUG_DWARF2, emit bits for .debug_info.
	(dwarf2_directive_file): Don't set debug_type.
	(dwarf2_where): Honor DEBUG_DWARF2 first.
	(dwarf2_emit_insn): Renamed from dwarf2_generate_asm_lineno;
	do nothing if not emitting dwarf2 debug info, or no work.
	* dwarf2dbg.h (dwarf2_emit_insn): Update.
	* ecoff.c (add_file): Turn on DEBUG_ECOFF only if DEBUG_UNSPECIFIED.
	(ecoff_new_file): Likewise.
	* read.c (generate_lineno_debug): Kill ecoff hackery.  Update
	commentary wrt dwarf2.

	* config/tc-alpha.c (alpha_adjust_symtab_relocs): Add
	ATTRIBUTE_UNUSED as needed.
	(emit_insn): Call dwarf2_emit_insn.
	(s_alpha_file): New.
	(s_alpha_loc): New.
	(s_alpha_coff_wrapper): Don't handle them.
	(md_pseudo_table): Update for .file and .loc.
	* config/tc-alpha.h (DWARF2_LINE_MIN_INSN_LENGTH): New.

	* config/tc-arm.c (output_inst): Update for dwarf2_emit_insn;
	don't protect with debug_type.
	* config/tc-hppa.c (md_assemble): Likewise.
	* config/tc-m68hc11.c (m68hc11_new_insn): Likewise.
	* config/tc-mn10300.c (md_assemble): Likewise.
	* config/tc-sh.c (md_assemble): Likewise.
	* config/tc-v850.c (md_assemble): Likewise.

	* config/tc-arm.c (arm_end_of_source): Remove.
	* config/tc-hppa.c (pa_end_of_source): Remove.
	* config/tc-m68hc11.c (m68hc11_end_of_source): Remove.
	* config/tc-mn10300.c (mn10300_finalize): Remove.
	* config/tc-sh.c (sh_finalize): Remove.
	* config/tc-v850.c (sh_finalize): Remove.

	* config/tc-arm.h (md_end): Remove.
	* config/tc-hppa.h (md_end): Remove.
	(DWARF2_LINE_MIN_INSN_LENGTH): New.
	* config/tc-m68hc11.h (md_end): Remove.
	* config/tc-mn10300.h (md_end): Remove.
	* config/tc-sh.h (md_end): Remove.
	* config/tc-v850.h (md_end): Remove.

	* config/tc-ia64.c (emit_one_bundle): Don't protect
	dwarf2 bits with debug_type.
	(md_assemble): Likewise.
	(ia64_end_of_source): Don't call dwarf2_finish.
@
text
@a69 7
/* The NOP_OPCODE is for the alignment fill value.
   Fill it a nop instruction so that the disassembler does not choke
   on it.  */
#ifndef NOP_OPCODE
#define NOP_OPCODE 0x00
#endif

a1167 2
  char default_fill;

a1171 10
  if (fill == NULL)
    {
      if (subseg_text_p (now_seg))
	default_fill = NOP_OPCODE;
      else
	default_fill = 0;
      fill = &default_fill;
      len = 1;
    }

d1175 8
a1182 1
      if (len <= 1)
@


1.30
log
@2000-11-06  Kazu Hirata  <kazu@@hxi.com>

	* as.c: Fix formatting.
	* dwarf2dbg.c: Likewise.
	* itbl-ops.c: Likewise.
	* listing.c: Likewise.
	* macro.h: Likewise.
	* messages.c: Likewise.
	* read.c: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* write.c: Likewise.
@
text
@a4984 12
#ifdef ECOFF_DEBUGGING
  /* ECOFF assemblers automatically generate debugging information.
     FIXME: This should probably be handled elsewhere.  */
  if (debug_type == DEBUG_UNSPECIFIED)
    {
      if (ECOFF_DEBUGGING && ecoff_no_current_file ())
	debug_type = DEBUG_ECOFF;
      else
	debug_type = DEBUG_NONE;
    }
#endif

d4989 1
a4996 1
    case DEBUG_DWARF:
d4998 4
a5001 8
      /* This cannot safely be done in a generic manner.  A single
	 binary instruction word may span mutliple lines of assembler
	 source and may occupy a variable number of bytes.  Instead,
	 if a port wishes to support DWARF2 line number generation by
	 the assembler, it should add a call to dwarf2_generate_asm_lineno
	 inside md_assemble() at whatever point is appropriate.  Note,
	 such a port should also define md_end and make sure that
	 dwarf2_finish is called, to emit the accumulated line information.  */
@


1.29
log
@Preserve copy of case clobber opcodes so that .req pseudo op works
@
text
@d122 1
a122 2
char lex_type[256] =
{
d143 1
a143 2
char is_end_of_line[256] =
{
d276 1
a276 2
static const pseudo_typeS potable[] =
{
d610 2
a611 2
                          && TC_START_LABEL_WITHOUT_COLON(c,
                                                          input_line_pointer)
d613 1
a613 1
                          )
d659 1
a659 1
		  for (s = input_line_pointer - 1; *s ; ++s)
d665 1
a665 1
		  len = s - (input_line_pointer-1);
d745 1
a745 1
		    
d2094 1
a2094 1
      /* Detach from old frag.	*/
d3819 2
a3820 1
	  hold = ++input_line_pointer; /* skip ':' */
@


1.28
log
@Add --gdwarf2 support to ARM toolchain
@
text
@d168 4
a741 1
#define IGNORE_OPCODE_CASE
d745 4
@


1.27
log
@2000-09-11  Kazu Hirata  <kazu@@hxi.com>

	* bignum-copy.c: Fix formatting.
	* ehopt.c: Likewise.
	* flonum-copy.c: Likewise.
	* flonum-konst.c: Likewise.
	* flonum-mult.c: Likewise.
	* literal.c: Likewise.
	* read.c: Likewise.
	* sb.c: Likewise.
	* stabs.c: Likewise.
	* subsegs.c: Likewise.
@
text
@d5005 8
a5012 1
      /* FIXME.  */
@


1.26
log
@comment-finding hack for hppa-linux.
@
text
@d20 1
a20 1
02111-1307, USA. */
d630 1
a630 1
	    
d702 1
a702 1
		      
d705 1
a705 1
		      
d763 1
a763 1
		        
d794 1
a794 1
			  
d1048 1
a1048 1
	      
d1132 1
a1132 1
  
d1247 1
a1247 1
	  
d1363 1
a1363 1
  
d1372 1
a1372 1
  
d1374 1
a1374 1
  
d1383 1
a1383 1
  
d1387 1
a1387 1
  
d1397 1
a1397 1
  
d1462 1
a1462 1
      
d1760 1
a1760 1
      
d1762 1
a1762 1
      
d2006 1
a2006 1
      
d2013 1
a2013 1
      
d2016 1
a2016 1
      
d2022 1
a2022 1
      
d2024 1
a2024 1
      
d2039 1
a2039 1
      
d2050 1
a2050 1
      
d2089 1
a2089 1
      
d2154 1
a2154 1
  
d2163 1
a2163 1
  
d2166 1
a2166 1
  
d2174 1
a2174 1
  
d2200 1
a2200 1
  
d2238 1
a2238 1
  
d2251 1
a2251 1
      
d2254 1
a2254 1
  
d2262 1
a2262 1
  
d2475 1
a2475 1
      
d2948 1
a2948 1
	  
d2954 1
a2954 1
	  
d3117 1
a3117 1
      
d3122 1
a3122 1
  
d3137 1
a3137 1
  
d3144 1
a3144 1
  
d3247 1
a3247 1
  
d3251 1
a3251 1
  
d3253 1
a3253 1
  
d3901 1
a3901 1
      
d3905 1
a3905 1
      
d4053 1
a4053 1
  
d4058 1
a4058 1
  
d4066 1
a4066 1
  
d4140 1
a4140 1
	      
d4630 1
a4630 1
	    
d4774 1
a4774 1
  
d4816 1
a4816 1
  
d4818 1
a4818 1
  
d4909 1
a4909 1
      
d4915 1
a4915 1
  
d4918 1
a4918 1
  
d4930 1
a4930 1
  
@


1.25
log
@Fix formatting.
@
text
@d524 4
d1089 7
@


1.24
log
@Don't treat `;' as a line separator by default.
Explicitly mention `;' in line_separator_chars in each backend.
@
text
@d23 4
a26 5
#define MASK_CHAR (0xFF)	/* If your chars aren't 8 bits, you will
				   change this a bit.  But then, GNU isn't
				   spozed to run on your machine anyway.
				   (RMS is so shortsighted sometimes.)
				   */
d28 1
a28 1
#define MASK_CHAR ((int)(unsigned char)-1)
a30 1

d32 1
a32 2
   grow when we do 4361 style flonums. */

d38 1
a38 1
/* for isdigit() */
d55 13
a67 11
#define TC_IMPLICIT_LCOMM_ALIGNMENT(SIZE, P2VAR)        \
 do {                                                   \
  if ((SIZE) >= 8)                                      \
    (P2VAR) = 3;                                        \
  else if ((SIZE) >= 4)                                 \
    (P2VAR) = 2;                                        \
  else if ((SIZE) >= 2)                                 \
    (P2VAR) = 1;                                        \
  else                                                  \
    (P2VAR) = 0;                                        \
 } while (0)
d71 2
a72 3
 * fill it a nop instruction so that the disassembler does not choke
 * on it
 */
d77 1
a77 1
char *input_line_pointer;	/*->next char of source file to parse. */
d121 1
a121 1
/* used by is_... macros. our ctype[] */
d131 1
a131 1
  3, 3, 3, 3, 3, 3, 3, 3, 3, 3, 3, LEX_BR, 0, LEX_BR, LEX_TILDE, 0, /* pqrstuvwxyz{|}~. */
d142 2
a143 5

/*
 * In: a character.
 * Out: 1 if this character ends a line.
 */
d168 1
a168 1
/* Functions private to this file. */
d170 2
a171 2
static char *buffer;	/* 1st char of each buffer of lines is here. */
static char *buffer_limit;	/*->1 + last char in buffer. */
d173 3
a175 2
/* TARGET_BYTES_BIG_ENDIAN is required to be defined to either 0 or 1 in the
   tc-<CPU>.h file.  See the "Porting GAS" section of the internals manual. */
d178 1
a178 1
static char *old_buffer;	/* JF a hack */
d182 1
a182 1
/* Variables for handling include file directory table. */
d184 8
a191 4
char **include_dirs;	/* Table of pointers to directories to
			   search for .include's */
int include_dir_count;	/* How many are in the table */
int include_dir_maxlen = 1;/* Length of longest in table */
a247 1

d261 1
a261 1
  /* Use machine dependent syntax */
d264 1
a264 1
  /* Use more.  FIXME-SOMEDAY. */
d270 1
a270 1
/* set up pseudo-op tables */
d283 1
a283 1
/* block */
d315 1
a315 1
/* dim */
d317 2
a318 2
/* dsect */
  {"eject", listing_eject, 0},	/* Formfeed listing */
d326 1
a326 1
/* endef */
d331 2
a332 2
/* extend */
  {"extern", s_ignore, 0},	/* We treat all undef as ext */
d365 1
a365 1
  {"lflags", listing_flags, 0},	/* Listing flags */
d367 1
a367 1
  {"list", listing_list, 1},	/* Turn listing on */
d377 1
a377 1
  {"nolist", listing_list, 0},	/* Turn listing off */
d388 1
a388 1
  {"psize", listing_psize, 0},	/* set paper size */
d394 3
a396 3
  {"sbttl", listing_title, 1},	/* Subtitle of listing */
/* scl */
/* sect */
d400 1
a400 1
/* size */
d410 1
a410 1
/* tag */
d423 1
a423 1
  {"title", listing_title, 0},	/* Listing title */
d425 1
a425 1
/* type */
d427 2
a428 2
/* use */
/* val */
d435 1
a435 1
  {NULL, NULL, 0}			/* end sentinel */
d464 1
a464 1
static void 
d469 1
a469 1
  /* Do the target-specific pseudo ops. */
d473 1
a473 1
  /* Now object specific.  Skip any that were in the target table. */
d478 1
a478 1
  /* Now portable ones.  Skip any that we've seen already. */
d486 1
a486 1
      while (! is_end_of_line[(unsigned char) *input_line_pointer++])	\
a491 1

d513 3
a515 6
/*	read_a_source_file()
 *
 * We read the file, putting things into a web that
 * represents what we have been reading.
 */
void 
d520 1
a520 1
  register char *s;		/* string of symbol, '\0' appended */
d536 2
a537 2
    {				/* We have another line to parse. */
      know (buffer_limit[-1] == '\n');	/* Must have a sentinel. */
d543 1
a543 1
	  /* We have more of this buffer to parse. */
d545 3
a547 5
	  /*
	   * We now have input_line_pointer->1st char of next line.
	   * If input_line_pointer [-1] == '\n' then we just
	   * scanned another line: so bump line counters.
	   */
a552 1

d603 1
a603 1
		      if (! mri_line_macro 
d605 1
a605 1
                          && TC_START_LABEL_WITHOUT_COLON(c, 
d623 12
a634 14
	  /*
	   * We are at the begining of a line, or similar place.
	   * We expect a well-formed assembler statement.
	   * A "symbol-name:" is a statement.
	   *
	   * Depending on what compiler is used, the order of these tests
	   * may vary to catch most common case 1st.
	   * Each test is independent of all other tests at the (top) level.
	   * PLEASE make a compiler that doesn't use this assembler.
	   * It is crufty to waste a compiler's time encoding things for this
	   * assembler, which then wastes more time decoding it.
	   * (And communicating via (linear) files is silly!
	   * If you must pass stuff, please pass a tree!)
	   */
d639 3
a641 4
	    {
	      c = *input_line_pointer++;
	    }
	  know (c != ' ');	/* No further leading whitespace. */
d654 1
a654 1
		  for (s = input_line_pointer-1; *s ; ++s)
d664 2
a665 2
		  memcpy (copy + macro_nest + 1, input_line_pointer-1, len);
		  copy[macro_nest+1+len] = '\0';
d674 2
a675 5

	  /*
	   * C is the 1st significant character.
	   * Input_line_pointer points after that character.
	   */
d678 1
a678 1
	      /* want user-defined label or pseudo/opcode */
d682 8
a689 9
	      c = get_symbol_end ();	/* name's delimiter */
	      /*
	       * C is character after symbol.
	       * That character's place in the input line is now '\0'.
	       * S points to the beginning of the symbol.
	       *   [In case of pseudo-op, s->'.'.]
	       * Input_line_pointer->'\0' where c was.
	       */
	      if (TC_START_LABEL(c, input_line_pointer))
a695 1

d698 1
d701 1
d712 4
a715 3
		  line_label = colon (s);	/* user-defined label */
		  *input_line_pointer++ = ':';	/* Put ':' back for error messages' sake. */
		  /* Input_line_pointer->after ':'. */
a716 2


d722 1
a722 1
			   && ! TC_EQUAL_IN_INSN (c, input_line_pointer)
d730 2
a731 1
		{		/* expect pseudo-op or machine instruction */
a745 1

d756 1
a756 1
		      || (! flag_m68k_mri && *s == '.'))
d758 5
a762 7
		      /*
		       * PSEUDO - OP.
		       *
		       * WARNING: c has next char, which may be end-of-line.
		       * We lookup the pseudo-op table with s+1 because we
		       * already know that the pseudo-op begins with a '.'.
		       */
d772 4
a775 4
			      || ! ((pop->poc_handler == cons
				     && pop->poc_val == 1)
				    || (pop->poc_handler == s_space
					&& pop->poc_val == 1)
d777 1
a777 1
				    || tc_conditional_pseudoop (pop)
d779 8
a786 8
				    || pop->poc_handler == s_if
				    || pop->poc_handler == s_ifdef
				    || pop->poc_handler == s_ifc
				    || pop->poc_handler == s_ifeqs
				    || pop->poc_handler == s_else
				    || pop->poc_handler == s_endif
				    || pop->poc_handler == s_globl
				    || pop->poc_handler == s_ignore)))
d790 1
d798 1
a798 1
		      /* Print the error msg now, while we still can */
d807 1
a807 1
		      /* Put it back for error messages etc. */
d811 1
a811 1
			 keyword from operands. */
d814 4
a817 5
		      /*
		       * Input_line is restored.
		       * Input_line_pointer->1st non-blank char
		       * after pseudo-operation.
		       */
d831 2
a832 2
		      /* WARNING: c has char, which may be end-of-line. */
		      /* Also: input_line_pointer->`\0` where c was. */
d842 1
a842 1
			    inquote = ! inquote;
d847 1
a847 1
			    inquote = ! inquote;
d863 1
a863 1
                          macro_entry *macro;
d876 1
a876 1
                              md_macro_info (macro);
d893 1
a893 1
		      md_assemble (s);	/* Assemble 1 instruction. */
d898 3
a900 3
			 this instruction. */
		    }		/* if (*s=='.') */
		}		/* if c==':' */
d902 1
a902 2
	    }			/* if (is_name_beginner(c) */

d911 1
a911 1
	      /* local label  ("4:") */
d918 1
d923 1
a923 1
		}		/* read the whole number */
d953 1
a953 1
	    {			/* Its a comment.  Better say APP or NO_APP */
d976 1
a976 1
		     guarentee it. . . */
d1044 1
d1054 2
a1055 3

	  /* as_warn("Junk character %d.",c);  Now done by ignore_rest */
	  input_line_pointer--;	/* Report unknown char as ignored. */
d1057 1
a1057 1
	}			/* while (input_line_pointer<buffer_limit) */
d1076 1
a1076 1
    }				/* while (more buffers to scan) */
d1081 1
a1081 1
  md_cleanup();
d1083 2
a1084 1
  input_scrub_close ();		/* Close the input file */
d1099 1
a1100 2

  char *s;
d1106 1
a1106 1
       ((! is_end_of_line[(unsigned char) *s] && *s != ' ' && *s != '\t')
d1111 1
a1111 1
	inquote = ! inquote;
a1112 4
  *stopcp = *s;
  *s = '\0';
  return s;

d1114 3
a1116 4

  char *s;

  for (s = input_line_pointer; ! is_end_of_line[(unsigned char) *s]; s++)
d1118 1
d1121 1
a1122 3

#endif

d1136 1
a1136 1
  while (! is_end_of_line[(unsigned char) *input_line_pointer])
d1140 1
a1140 1
void 
d1153 1
a1153 1
static void 
d1176 1
a1176 1
  /* Only make a frag if we HAVE to. . . */
d1217 1
a1217 1
	align = arg;	/* Default value from pseudo-op table */
d1236 1
d1273 1
a1273 1
  if (! fill_p)
d1286 1
a1286 1
	fill_len = - arg;
d1314 1
a1314 1
void 
d1324 1
a1324 1
void 
d1331 1
a1331 1
void 
d1348 1
a1348 1
  /* just after name is now '\0' */
d1352 1
d1361 1
d1363 1
d1372 1
d1376 2
a1377 1
  if (S_IS_DEFINED (symbolP) && ! S_IS_COMMON (symbolP))
d1386 1
d1403 1
a1403 1
    if ( (!temp) || !flag_one)
d1431 1
a1431 1
  if (! flag_mri)
d1442 1
a1442 1
  if (! isdigit ((unsigned char) *name))
d1451 1
d1478 1
a1478 1
  if (S_IS_DEFINED (sym) && ! S_IS_COMMON (sym))
d1550 1
a1550 1
void 
d1557 1
a1557 1
  /* Some assemblers tolerate immediately following '"' */
d1564 1
a1564 1
	= (! new_logical_line (s, appfile ? -2 : -1) && appfile);
d1574 1
a1574 1
      if (! may_omit)
d1604 2
a1605 1
    as_warn (_("Line numbers must be positive; line number %d rejected."), l+1);
d1629 1
a1629 1
      if (! is_end_of_line[(unsigned char) *input_line_pointer]
d1671 1
a1671 1
void 
d1749 1
d1751 1
d1753 4
a1756 4
       * flavoured AS.  The following bizzare behaviour is to be
       * compatible with above.  I guess they tried to take up to 8
       * bytes from a 4-byte expression and they forgot to sign
       * extend. Un*x Sux. */
d1763 3
a1765 3
       * but emits no error message because it seems a legal thing to do.
       * It is a degenerate case of .fill but could be emitted by a compiler.
       */
d1770 1
a1770 1
void 
d1824 1
a1824 1
  while (! is_end_of_line[(unsigned char) *input_line_pointer])
d1855 1
a1855 1
  if (! is_end_of_line[(unsigned char) *input_line_pointer])
d1905 1
a1905 1
    if (! bfd_set_section_flags (stdoutput, now_seg, flags))
d1917 1
a1917 1
static void 
d1920 1
a1920 1
	(alignment); 0 if it was an ".lcomm" (2 args only)  */
d1923 1
a1923 1
	rather than the power of 2. */
d1974 1
a1974 1
	  if (! bfd_set_section_flags (stdoutput, bss_seg, SEC_ALLOC))
d1982 8
a1989 8
   if (!needs_align)
     {
       TC_IMPLICIT_LCOMM_ALIGNMENT (temp, align);

       /* Still zero unless TC_IMPLICIT_LCOMM_ALIGNMENT set it.  */
       if (align)
         record_alignment(bss_seg, align);
     }
d1995 1
d2002 1
d2005 1
d2011 1
d2013 1
d2028 1
d2039 1
d2041 1
a2041 1
    }				/* if needs align */
d2078 2
a2079 1
					/* detach from old frag	*/
d2084 1
a2084 1
      pfrag = frag_var (rs_org, 1, 1, (relax_substateT)0, symbolP,
d2093 1
a2093 1
         in that case.  Otherwise, set it to static. */
d2111 1
a2111 1
}				/* s_lcomm_internal() */
d2120 2
a2121 1
void s_lcomm_bytes (needs_align)
d2127 1
a2127 1
void 
d2137 1
a2137 1
  /* we permit ANY defined expression: BSD4.2 demands constants */
d2143 1
d2152 1
d2155 1
d2163 1
d2172 1
a2172 1
     anyway.  xoxorich. */
d2178 1
a2178 1
	 keep the "external" bit. */
d2189 1
d2192 1
a2192 1
}				/* s_lsym() */
d2214 1
a2214 1
  if (! flag_m68k_mri)
d2227 2
a2228 1
  while (! is_end_of_line[(unsigned char) *input_line_pointer]
d2240 1
d2243 1
d2251 1
d2272 1
a2272 1
  while (! is_end_of_line[(unsigned char) *input_line_pointer])
d2293 1
a2293 1
	  || (! flag_m68k_mri
d2386 1
a2386 1
void 
d2433 1
a2433 1
}				/* s_org() */
d2453 1
a2453 1
  
d2455 1
a2455 1
  if (! isdigit ((unsigned char) *name))
d2464 1
d2508 1
a2508 1
	    if (! bfd_set_section_flags (stdoutput, seg, flags))
d2594 1
a2594 1
  demand_empty_rest_of_line ();	  
d2659 1
a2659 1
  do_repeat(count, "REPT", "ENDR");
d2663 1
a2663 1
   different directives to be used as the start/end keys. */
d2667 3
a2669 3
      int count;
      const char *start;
      const char *end;
d2675 1
a2675 1
  if (! buffer_and_nest (start, end, &one, get_line_sb))
d2694 1
a2694 1
   are properly nested. 
d2698 1
a2698 1
   such as line substitutions. */
d2702 1
a2702 1
  int extra;
d2713 1
a2713 1
void 
d2722 3
a2724 5
  /*
   * Especial apologies for the random logic:
   * this just grew, and could be parsed much more simply!
   * Dean in haste.
   */
d2745 1
a2745 1
      /* Turn '. = mumble' into a .org mumble */
d2768 2
a2769 2
	  fragS *dummy_frag = (fragS *) xmalloc (sizeof(fragS));
	  memset (dummy_frag, 0, sizeof(fragS));
d2777 2
a2778 2
        symbolP = symbol_new (name, undefined_section, 0, &zero_address_frag);
			    
d2780 1
a2780 1
      /* "set" symbols are local unless otherwise specified. */
d2783 1
a2783 2

    }				/* make a new symbol */
d2796 1
a2796 1
}				/* s_set() */
d2798 1
a2798 1
void 
d2902 1
a2902 1
	      if (! flag_mri)
d2937 1
d2943 1
d3080 1
a3080 1
}				/* s_text() */
d3082 1
a3082 2

void 
d3087 1
a3087 3
    {
      input_line_pointer++;
    }
d3089 4
a3092 5
    {
      ignore_rest_of_line ();
    }
  /* Return having already swallowed end-of-line. */
}				/* Return pointing just after end-of-line. */
d3095 1
a3095 1
ignore_rest_of_line ()		/* For suspect lines: gives warning. */
d3097 1
d3106 1
d3109 1
a3109 3
	{
	  input_line_pointer++;
	}
d3111 4
a3114 1
  input_line_pointer++;		/* Return pointing just after end-of-line. */
d3122 6
a3127 5
         && !is_end_of_line[(unsigned char) *input_line_pointer])
    {
      input_line_pointer++;
    }
  input_line_pointer++;         /* Return pointing just after end-of-line. */
d3131 7
a3137 10
/*
 *			pseudo_set()
 *
 * In:	Pointer to a symbol.
 *	Input_line_pointer->expression.
 *
 * Out:	Input_line_pointer->just after any whitespace after expression.
 *	Tried to set symbol to value of expression.
 *	Will change symbols type, value, and frag;
 */
d3147 1
a3147 1
  know (symbolP);		/* NULL pointer is logic error. */
d3194 1
a3194 1
        symbol_set_frag (symbolP, &zero_address_frag);
d3235 12
a3246 14
/*
 *			cons()
 *
 * CONStruct more frag of .bytes, or .words etc.
 * Should need_pass_2 be 1 then emit no frag(s).
 * This understands EXPRESSIONS.
 *
 * Bug (?)
 *
 * This has a split personality. We use expression() to read the
 * value. We can detect if the value won't fit in a byte or word.
 * But we can't detect if expression() discarded significant digits
 * in the case of a long. Not worth the crocks required to fix it.
 */
d3266 1
a3266 1
static void 
d3281 4
a3284 4
/* worker to do .byte etc statements */
/* clobbers input_line_pointer, checks */
/* end-of-line. */
static void 
d3286 1
a3286 1
     register int nbytes;	/* 1=.byte, 2=.word, 4=.long */
d3341 1
a3341 1
  input_line_pointer--;		/* Put terminator back into stream. */
a3348 1

d3356 1
a3356 1
void 
d3474 1
a3474 1
	  next = (((~ (generic_bignum[i] & LITTLENUM_MASK))
d3539 1
a3539 1
      if (! exp->X_unsigned && exp->X_add_number < 0)
d3563 1
a3563 1
	 particular SPARC (Sun 4) has problems */
d3574 1
a3574 1
	  /* Don't store these bits. */
d3579 1
a3579 1
      unmask = ~mask;		/* Do store these bits. */
d3583 1
a3583 1
      mask = ~(unmask >> 1);	/* Includes sign bit now. */
d3591 1
a3591 1
	{		/* Leading bits contain both 0s & 1s. */
d3595 1
a3595 1
      /* put bytes in right order. */
d3730 1
a3730 1
static void 
d3741 2
a3742 1
    {			/* bitfields */
d3753 1
a3753 1
	    }			/* next piece is not a bitfield */
d3771 1
a3771 1
	     .equ type symbol.  xoxorich. */
d3778 1
a3778 1
	    }			/* implied zero width bitfield */
d3787 1
a3787 1
	    }			/* too complex */
d3794 1
a3794 1
	    }			/* too big */
d3802 1
a3802 1
	    }			/* won't fit */
d3816 1
a3816 1
	    }			/* too complex */
d3826 1
a3826 1
	    }			/* all the bitfields we're gonna get */
d3830 1
a3830 1
	}			/* forever loop */
d3835 2
a3836 2
    }				/* if looks like a bitfield */
}				/* parse_bitfield_cons() */
d3884 1
a3884 1
      /* Left justify */
d3890 2
a3891 1
      /* Create correct expression */
d3894 2
a3895 1
      /* Fake it so that we can read the next char too */
d4002 1
a4002 1
	 through the hex constant, so we ignore them as well. */
d4041 16
a4056 19
/*
 *			float_cons()
 *
 * CONStruct some more frag chars of .floats .ffloats etc.
 * Makes 0 or more new frags.
 * If need_pass_2 == 1, no frags are emitted.
 * This understands only floating literals, not expressions. Sorry.
 *
 * A floating constant is defined by atof_generic(), except it is preceded
 * by 0d 0f 0g or 0h. After observing the STRANGE way my BSD AS does its
 * reading, I decided to be incompatible. This always tries to give you
 * rounded bits to the precision of the pseudo-op. Former AS did premature
 * truncatation, restored noisy bits instead of trailing 0s AND gave you
 * a choice of 2 flavours of noise according to which of 2 floating-point
 * scanners you directed AS to use.
 *
 * In:	input_line_pointer->whitespace before, or '0' of flonum.
 *
 */
d4060 2
a4061 2
     /* Clobbers input_line-pointer, checks end-of-line. */
     register int float_type;	/* 'f':.ffloat ... 'F':.float ... */
d4064 2
a4065 2
  int length;			/* Number of chars in an object. */
  register char *err;		/* Error from scanning floating literal. */
d4080 1
a4080 1
      /* input_line_pointer->1st char of a flonum (we hope!). */
d4084 3
a4086 4
       * letter is legal. Someone may invent a "z" format and this routine
       * has no use for such information. Lusers beware: you get
       * diagnostics if your input is ill-conditioned.
       */
d4129 1
d4132 1
a4132 3
		{
		  as_warn (_("unresolvable or nonpositive repeat count; using 1"));
		}
d4148 2
a4149 1
  --input_line_pointer;		/* Put terminator back into stream.  */
d4151 1
a4151 1
}				/* float_cons() */
d4153 1
a4153 1
/* Return the size of a LEB128 value */
d4287 1
a4287 1
  while (size > 0 && bignum[size-1] == (LITTLENUM_TYPE)-1)
d4307 1
a4307 1
	      || (~(val | ~(((valueT)1 << loaded) - 1)) == 0
d4334 1
a4334 1
  while (size > 0 && bignum[size-1] == 0)
d4379 1
a4379 1
emit_leb128_expr(exp, sign)
d4428 1
a4428 1
      /* Otherwise, we have to create a variable sized fragment and 
d4431 1
a4431 1
      frag_var (rs_leb128, sizeof_uleb128 (~(valueT)0), 0, sign,
d4444 6
a4449 4
  do {
    expression (&exp);
    emit_leb128_expr (&exp, sign);
  } while (*input_line_pointer++ == ',');
d4455 3
a4457 7
/*
 *			stringer()
 *
 * We read 0 or more ',' separated, double-quoted strings.
 *
 * Caller should have checked need_pass_2 is FALSE because we don't check it.
 */
d4459 4
a4462 5

void 
stringer (append_zero)		/* Worker to do .ascii etc statements. */
     /* Checks end-of-line. */
     register int append_zero;	/* 0: don't append '\0', else 1 */
d4471 5
a4475 8
  /*
   * The following awkward logic is to parse ZERO or more strings,
   * comma separated. Recall a string expression includes spaces
   * before the opening '\"' and spaces after the closing '\"'.
   * We fake a leading ',' if there is (supposed to be)
   * a 1st, expression. We keep demanding expressions for each
   * ','.
   */
d4478 2
a4479 2
      c = 0;			/* Skip loop. */
      ++input_line_pointer;	/* Compensate for end of loop. */
d4483 1
a4483 1
      c = ',';			/* Do loop. */
d4491 1
a4491 1
	  ++input_line_pointer;	/*->1st char of string. */
d4548 1
a4548 1
    returning values bigger than 1 byte.  xoxorich. */
d4550 1
a4550 1
unsigned int 
d4597 1
a4597 1
	  break;		/* As itself. */
d4613 3
a4615 1
	    for (i = 0, number = 0; isdigit (c) && i < 3; c = *input_line_pointer++, i++)
d4619 1
d4648 1
a4648 1
	  /* To be compatible with BSD 4.2 as: give the luser a linefeed!! */
d4662 1
a4662 1
	}			/* switch on escaped char */
d4668 1
a4668 1
    }				/* switch on char */
d4670 1
a4670 1
}				/* next_char_of_string() */
d4691 1
a4691 1
static segT 
d4713 1
a4713 1
}				/* get_known_segmented_expression() */
d4730 1
a4730 1
char				/* return terminator */
d4732 1
a4732 1
     long *val_pointer;		/* return value of expression */
d4739 3
a4741 6
/*
 *			demand_copy_C_string()
 *
 * Like demand_copy_string, but return NULL if the string contains any '\0's.
 * Give a warning if that happens.
 */
d4763 1
d4767 3
a4769 6
/*
 *			demand_copy_string()
 *
 * Demand string, but return a safe (=private) copy of the string.
 * Return NULL if we can't read a string here.
 */
d4782 1
a4782 1
      input_line_pointer++;	/* Skip opening quote. */
d4790 1
a4790 1
	 null terminated string. */
d4802 1
a4802 1
}				/* demand_copy_string() */
d4804 7
a4810 10
/*
 *		is_it_end_of_statement()
 *
 * In:	Input_line_pointer->next character.
 *
 * Do:	Skip input_line_pointer over all whitespace.
 *
 * Out:	1 if input_line_pointer->end-of-line.
*/
int 
d4815 1
a4815 1
}				/* is_it_end_of_statement() */
d4817 1
a4817 1
void 
d4822 1
a4822 1
  register symbolS *symbolP;	/* symbol we are working with */
d4838 1
a4838 1
      /* Turn '. = mumble' into a .org mumble */
d4850 1
a4850 1
      if (! reassign
d4858 6
a4863 5
     {
       ignore_rest_of_line (); /* check garbage after the expression */
       mri_comment_end (stop, stopc);
     }
}				/* equals() */
d4865 1
a4865 1
/* .include -- include a file at this point. */
d4867 1
a4867 2
/* ARGSUSED */
void 
d4876 1
a4876 1
  if (! flag_m68k_mri)
d4890 1
a4890 1
      while (! is_end_of_line[(unsigned char) *input_line_pointer]
d4898 1
d4901 1
a4901 1
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
d4904 1
d4907 1
d4919 1
d4923 1
a4923 1
  /* malloc Storage leak when file is found on path.  FIXME-SOMEDAY. */
d4926 1
a4926 1
}				/* s_include() */
d4928 1
a4928 1
void 
d4937 1
a4937 1
      include_dirs[0] = ".";	/* Current dir */
d4943 3
a4945 2
      include_dirs = (char **) realloc (include_dirs,
				include_dir_count * sizeof (*include_dirs));
d4948 1
a4948 1
  include_dirs[include_dir_count - 1] = path;	/* New one */
d4953 1
a4953 1
}				/* add_include_dir() */
d4970 1
a4970 1
  /* ECOFF assemblers automatically generate debugging information. 
d4975 1
a4975 1
        debug_type = DEBUG_ECOFF;
d5039 2
a5040 2
      char *name,*label;
      char delim1,delim2;
d5092 1
a5092 1
void 
a5102 1

d5110 2
a5111 2
/* Inserts the given line into the input stream.  
   
d5121 1
a5121 1
  const char *line;
d5132 1
a5132 1
   file; no include path searching or dependency registering is performed.  */ 
d5136 1
a5136 1
  char *path;
a5140 2

/* end of read.c */
@


1.23
log
@(is_end_of_line): Add three missing lines of 0 initializers.
@
text
@a157 1
#ifdef TC_HPPA
a158 3
#else
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0,	/* 0123456789:;<=>? */
#endif
@


1.22
log
@(is_end_of_line): No ';' for TC_HPPA.
@
text
@d172 3
@


1.21
log
@2000-06-03  H.J. Lu  <hjl@@gnu.org>

	* read.c (is_end_of_line): Put back `;'.
@
text
@d158 3
d162 1
@


1.20
log
@is_end_of_line fixes.
@
text
@d158 1
a158 1
  0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,	/* 0123456789:;<=>? */
@


1.19
log
@IA-64 ELF support.
@
text
@a148 1
#define Z_ (0)
d152 1
a152 1
  99, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, 99, Z_, Z_, 99, Z_, Z_,	/* @@abcdefghijklmno */
d154 1
a154 1
  99, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, 99, Z_, Z_, Z_, Z_, Z_,	/* @@abcdefghijklmno */
d156 12
a167 17
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
#ifdef TC_HPPA
  Z_,99, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* _!"#$%&'()*+,-./ */
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* 0123456789:;<=>? */
#else
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, 99, Z_, Z_, Z_, Z_,	/* 0123456789:;<=>? */
#endif
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
  Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_, Z_,	/* */
a168 1
#undef Z_
@


1.18
log
@Add macro handling extensions and line substitution support.
@
text
@d108 2
@


1.17
log
@	* read.c (TC_IMPLICIT_LCOMM_ALIGNMENT): New default-definition.
	(s_lcomm_internal): Use it.
	* doc/internals.texi (CPU backend): Document it.
	* config/obj-evax.h (TC_IMPLICIT_LCOMM_ALIGNMENT): Set to 2**3
	bytes.
@
text
@d882 1
d884 1
a884 1
			  if (check_macro (s, &out, '\0', &err))
d890 1
a890 1
						      input_line_pointer);
d894 3
d1849 1
a1849 1
  input_scrub_include_sb (&out, input_line_pointer);
d2682 1
a2682 1
  input_scrub_include_sb (&many, input_line_pointer);
a4884 1
  char *newbuf;
d4935 1
a4935 2
  newbuf = input_scrub_include_file (path, input_line_pointer);
  buffer_limit = input_scrub_next_buffer (&input_line_pointer);
d5118 32
@


1.16
log
@Remove dead code when not TC_M68K.
@
text
@d56 15
d1991 1
d1994 1
a1994 14
       /* FIXME. This needs to be machine independent. */
       if (temp >= 8)
	 align = 3;
       else if (temp >= 4)
	 align = 2;
       else if (temp >= 2)
	 align = 1;
       else
	 align = 0;

#ifdef OBJ_EVAX
       /* FIXME: This needs to be done in a more general fashion.  */
       align = 3;
#endif
d1996 3
a1998 1
       record_alignment(bss_seg, align);
@


1.15
log
@Check label validity with TC_START_LABEL_WITHOUT_COLON if defined.
@
text
@d553 1
a553 5
	      if (flag_m68k_mri
#ifdef LABELS_WITHOUT_COLONS
		  || 1
#endif
		  )
d748 1
a748 5
		  if (flag_m68k_mri
#ifdef NO_PSEUDO_DOT
		      || 1
#endif
		      )
d2278 1
a2278 5
      if (((flag_m68k_mri
#ifdef NO_PSEUDO_DOT
	    || 1
#endif
	    )
d2322 1
d2324 1
d3250 1
d3253 1
d3308 1
d3312 1
d3834 1
d3897 1
@


1.14
log
@Remove redundant code for checking numbers with suffixes.  Add
functionality to break out of assembler loops.
@
text
@d602 6
a607 1
		      if (! mri_line_macro)
@


1.13
log
@New elseif directive has been added.
@
text
@d2647 15
a2664 2
  count = get_absolute_expression ();

d2666 1
a2666 1
  if (! buffer_and_nest ("REPT", "ENDR", &one, get_line_sb))
d2668 1
a2668 1
      as_bad (_("rept without endr"));
d2681 17
@


1.12
log
@octets vs bytes changes for GAS
@
text
@d309 1
@


1.11
log
@Make copyright date lists comply with GNU requirement
@
text
@d1197 1
a1197 1
  record_alignment (now_seg, n);
d2372 1
a2372 1
		    exp->X_add_number, (char *) NULL);
@


1.10
log
@This set of patches add support for aout emulation on the x86
assembler.  ie. You will be able to do "as --em=i386aout" on an x86
linux-elf assembler to generate aout format object files, rather than
using a separate assembler.  The aout emulation is enabled by giving
"--enable-targets=i386-linuxaout" to configure.
Oh yeah, there's a couple of fixes too.  Error messages shouldn't be
passed to printf in the format arg just in case someone puts a `%' in
the message.
@
text
@d2 2
a3 2
   Copyright (C) 1986, 87, 1990-99, 2000
   Free Software Foundation, Inc.
@


1.9
log
@	* read.c (pseudo_set): Reject attempts to set the value of a
	section symbol.
@
text
@d2 1
a2 1
   Copyright (C) 1986, 87, 90, 91, 92, 93, 94, 95, 96, 97, 98, 1999
d873 1
a873 1
				as_bad (err);
d2060 11
a2070 6
#if defined(OBJ_AOUT) | defined(OBJ_BOUT)
       S_GET_OTHER (symbolP) == 0 &&
       S_GET_DESC (symbolP) == 0 &&
#endif /* OBJ_AOUT or OBJ_BOUT */
       (S_GET_SEGMENT (symbolP) == bss_seg
	|| (!S_IS_DEFINED (symbolP) && S_GET_VALUE (symbolP) == 0)))
@


1.8
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Fill in structure initializations.  Add variable
	initializations.  Add casts.
	* dwarf2dbg.c (print_stats): Change i to size_t.
	* listing.c (listing_listing): Change list_line to unsigned int.
@
text
@d3166 2
@


1.7
log
@	* subsegs.c (subseg_text_p): New function.
	* as.h (subseg_text_p): Declare.
	* read.c (do_align): Use subseg_text_p to set the default fill.
	* write.c (subsegs_finish): Likewise.
	* config/obj-coff.c (write_object_file): Likewise.
	* config/tc-i386.h (md_maybe_text): Don't define.
	(md_do_align): Use subseg_text_p to set the default fill.
	* config/tc-m32r.c (m32r_do_align): Likewise.
	* config/tc-sh.c (sh_do_align): Likewise.
	* config/tc-sparc.h (md_do_align): Likewise.
@
text
@d422 1
a422 1
  {NULL}			/* end sentinel */
d1150 1
a1150 1
     int ignore;
d1340 1
a1340 1
     int ignore;
d1422 1
a1422 1
     int small;
d1521 1
a1521 1
     int ignore;
d1595 1
a1595 1
     int ignore;
d1621 1
a1621 1
     int ignore;
d1639 1
a1639 1
     int ignore;
d1649 1
a1649 1
     int ignore;
d1672 1
a1672 1
     int ignore;
d1769 1
a1769 1
     int ignore;
d1844 1
a1844 1
     int ignore;
d2122 1
a2122 1
     int ignore;
d2244 1
a2244 1
     int ignore;
d2296 1
a2296 1
     int ignore;
d2306 1
a2306 1
     int ignore;
d2374 1
a2374 1
     int ignore;
d2430 1
a2430 1
     char *type;
d2594 1
a2594 1
     int ignore;
d2608 1
a2608 1
     int ignore;
d2638 1
a2638 1
     int ignore;
d3010 1
a3010 1
     int ignore;
d3026 1
a3026 1
     int ignore;
d4835 1
a4835 1
     int arg;
d5057 1
a5057 1
     int arg;
@


1.6
log
@	* read.c (read_a_source_file): Only declare inescape if
	QUOTES_IN_INSN.
@
text
@d1176 1
a1176 15
      int maybe_text;

#ifdef BFD_ASSEMBLER
      if ((bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE) != 0)
	maybe_text = 1;
      else
	maybe_text = 0;
#else
      if (now_seg != data_section && now_seg != bss_section)
	maybe_text = 1;
      else
	maybe_text = 0;
#endif

      if (maybe_text)
@


1.5
log
@        * dwarf2dbg.c (*): Convert to K&R + prototypes.
        (dwarf2_gen_line_info): Kill unused variables.
        (dwarf2_finish): Likewise.
        (dwarf2_where): Likewise.
        (dwarf2_directive_file): If we've only got a string,
        hand off to s_app_file.
        * ecoff.c: Move the include of ecoff.h.
        * symbols.h (S_IS_FUNCTION): Prototype.
        * read.c (LEX_HASH): Supply a default.
        (lex_type): Use it.
        (s_globl): Update `c' after skipping whitespace.
        * read.h (LEX_END_NAME, is_name_ender): New.
        * expr.c (get_symbol_end): Respect it.
@
text
@d832 4
a835 1
		      int inquote = 0, inescape = 0;
@


1.4
log
@        * read.c (read_a_source_file): Conditionally allow matched "
        in lines passed to md_assemble.
@
text
@d92 4
d111 1
a111 1
  0, 0, 0, 0, LEX_DOLLAR, LEX_PCT, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, /* _!"#$%&'()*+,-./ */
d1796 2
d1800 1
a1800 1
      S_SET_EXTERNAL (symbolP);
@


1.3
log
@	* app.c (input_buffer): New static variable.
	(app_push): Save saved_input in allocated buffer.
	(app_pop): Restored saved_input.
	(do_scrub_chars): Change get parameter to take char * and int as
	arguments.  Change GET macro to pass input_buffer to get
	function.  Don't save input into allocated buffer.
	* as.h (do_scrub_chars): Update declaration.
	* input-file.c (input_file_get): Change to take char * and int.
	Read data into passed in buffer.  Remove static buffer.
	* read.c (scrub_from_string): Change to take char * and int.  Copy
	data into passed in buffer.
@
text
@d828 1
a828 1
		      int inquote = 0;
d842 8
d4416 1
a4416 1
 * We read 0 or more ',' seperated, double-quoted strings.
@


1.2
log
@/
Move bitfield overflow checks to after the md_apply_fix call in
fixup_segment so that md_apply_fix has a chance to modify value.
Handle 8 and 16-bit pcrel relocs for i386.
Prototypes and other minor code cleanups.
@
text
@d211 1
a211 1
static int scrub_from_string PARAMS ((char **));
d483 12
a494 9
scrub_from_string (from)
     char **from;
{
  int size;

  *from = scrub_string;
  size = scrub_string_end - scrub_string;
  scrub_string = scrub_string_end;
  return size;
d794 1
a794 1
			      line_label->sy_frag = frag_now;
d875 1
a875 1
			      line_label->sy_frag = frag_now;
d1495 6
a1500 4
      line_label->sy_value.X_op = O_symbol;
      line_label->sy_value.X_add_symbol = sym;
      line_label->sy_value.X_add_number = S_GET_VALUE (sym);
      line_label->sy_frag = &zero_address_frag;
d2072 1
a2072 1
	symbolP->sy_frag->fr_symbol = NULL;
d2074 1
a2074 1
      symbolP->sy_frag = frag_now;
d2269 1
a2269 1
	  line_label->sy_frag = &zero_address_frag;
d2791 6
a2796 3
		  know (line_label->sy_value.X_op == O_symbol);
		  know (line_label->sy_value.X_add_symbol == mri_common_symbol);
		  line_label->sy_value.X_add_number += 1;
d2805 1
a2805 1
	      line_label->sy_frag = frag_now;
d3125 2
a3126 1
	   && exp.X_add_symbol->sy_frag == exp.X_op_symbol->sy_frag)
d3150 1
a3150 1
        symbolP->sy_frag = &zero_address_frag;
d3156 1
a3156 1
      symbolP->sy_frag = &zero_address_frag;
d3162 1
a3162 1
	symbolP->sy_value = exp;
d3176 1
a3176 1
	  symbolP->sy_frag = s->sy_frag;
d3184 1
a3184 1
      symbolP->sy_value = exp;
d3413 2
a3414 2
      && exp->X_add_symbol->sy_value.X_op == O_big
      && exp->X_add_symbol->sy_value.X_add_number > 0)
d3419 1
a3419 1
      exp = &exp->X_add_symbol->sy_value;
@


1.1
log
@Initial revision
@
text
@d214 1
d216 7
d4218 1
a4218 1
static int
d4264 1
a4264 1
static int
d4306 1
a4306 1
static inline int
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

