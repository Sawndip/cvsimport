head	1.119;
access;
symbols
	binutils-2_24-branch:1.119.0.2
	binutils-2_24-branchpoint:1.119
	binutils-2_21_1:1.104.2.2
	binutils-2_23_2:1.116
	binutils-2_23_1:1.116
	binutils-2_23:1.116
	binutils-2_23-branch:1.116.0.2
	binutils-2_23-branchpoint:1.116
	binutils-2_22_branch:1.111.2.1.0.2
	binutils-2_22:1.111.2.1
	binutils-2_22-branch:1.111.0.2
	binutils-2_22-branchpoint:1.111
	binutils-2_21:1.104
	binutils-2_21-branch:1.104.0.2
	binutils-2_21-branchpoint:1.104
	binutils-2_20_1:1.96.2.5
	binutils-2_20:1.96.2.4
	binutils-arc-20081103-branch:1.93.0.4
	binutils-arc-20081103-branchpoint:1.93
	binutils-2_20-branch:1.96.0.2
	binutils-2_20-branchpoint:1.96
	dje-cgen-play1-branch:1.95.0.2
	dje-cgen-play1-branchpoint:1.95
	arc-20081103-branch:1.93.0.2
	arc-20081103-branchpoint:1.93
	binutils-2_19_1:1.91
	binutils-2_19:1.91
	binutils-2_19-branch:1.91.0.2
	binutils-2_19-branchpoint:1.91
	binutils-2_18:1.87
	binutils-2_18-branch:1.87.0.2
	binutils-2_18-branchpoint:1.87
	binutils-csl-coldfire-4_1-32:1.74
	binutils-csl-sourcerygxx-4_1-32:1.74
	binutils-csl-innovasic-fido-3_4_4-33:1.74
	binutils-csl-sourcerygxx-3_4_4-32:1.56.2.1
	binutils-csl-coldfire-4_1-30:1.74
	binutils-csl-sourcerygxx-4_1-30:1.74
	binutils-csl-coldfire-4_1-28:1.74
	binutils-csl-sourcerygxx-4_1-29:1.74
	binutils-csl-sourcerygxx-4_1-28:1.74
	binutils-csl-arm-2006q3-27:1.74
	binutils-csl-sourcerygxx-4_1-27:1.74
	binutils-csl-arm-2006q3-26:1.74
	binutils-csl-sourcerygxx-4_1-26:1.74
	binutils-csl-sourcerygxx-4_1-25:1.74
	binutils-csl-sourcerygxx-4_1-24:1.74
	binutils-csl-sourcerygxx-4_1-23:1.74
	binutils-csl-sourcerygxx-4_1-21:1.74
	binutils-csl-arm-2006q3-21:1.74
	binutils-csl-sourcerygxx-4_1-22:1.74
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.74
	binutils-csl-sourcerygxx-4_1-20:1.74
	binutils-csl-arm-2006q3-19:1.74
	binutils-csl-sourcerygxx-4_1-19:1.74
	binutils-csl-sourcerygxx-4_1-18:1.74
	binutils-csl-renesas-4_1-9:1.74
	binutils-csl-sourcerygxx-3_4_4-25:1.56.2.1
	binutils-csl-renesas-4_1-8:1.74
	binutils-csl-renesas-4_1-7:1.74
	binutils-csl-renesas-4_1-6:1.74
	binutils-csl-sourcerygxx-4_1-17:1.74
	binutils-csl-sourcerygxx-4_1-14:1.74
	binutils-csl-sourcerygxx-4_1-15:1.74
	binutils-csl-sourcerygxx-4_1-13:1.74
	binutils-2_17:1.74
	binutils-csl-sourcerygxx-4_1-12:1.74
	binutils-csl-sourcerygxx-3_4_4-21:1.74
	binutils-csl-wrs-linux-3_4_4-24:1.56
	binutils-csl-wrs-linux-3_4_4-23:1.56
	binutils-csl-sourcerygxx-4_1-9:1.74
	binutils-csl-sourcerygxx-4_1-8:1.74
	binutils-csl-sourcerygxx-4_1-7:1.74
	binutils-csl-arm-2006q1-6:1.74
	binutils-csl-sourcerygxx-4_1-6:1.74
	binutils-csl-wrs-linux-3_4_4-22:1.56
	binutils-csl-coldfire-4_1-11:1.74
	binutils-csl-sourcerygxx-3_4_4-19:1.74
	binutils-csl-coldfire-4_1-10:1.74
	binutils-csl-sourcerygxx-4_1-5:1.74
	binutils-csl-sourcerygxx-4_1-4:1.74
	binutils-csl-wrs-linux-3_4_4-21:1.56
	binutils-csl-morpho-4_1-4:1.74
	binutils-csl-sourcerygxx-3_4_4-17:1.74
	binutils-csl-wrs-linux-3_4_4-20:1.56
	binutils-2_17-branch:1.74.0.4
	binutils-2_17-branchpoint:1.74
	binutils-csl-2_17-branch:1.74.0.2
	binutils-csl-2_17-branchpoint:1.74
	binutils-csl-gxxpro-3_4-branch:1.56.2.1.0.2
	binutils-csl-gxxpro-3_4-branchpoint:1.56.2.1
	binutils-2_16_1:1.56.2.1
	binutils-csl-arm-2005q1b:1.56
	binutils-2_16:1.56.2.1
	binutils-csl-arm-2005q1a:1.56
	binutils-csl-arm-2005q1-branch:1.56.0.4
	binutils-csl-arm-2005q1-branchpoint:1.56
	binutils-2_16-branch:1.56.0.2
	binutils-2_16-branchpoint:1.56
	csl-arm-2004-q3d:1.51
	csl-arm-2004-q3:1.50
	binutils-2_15:1.48
	binutils-2_15-branchpoint:1.48
	csl-arm-2004-q1a:1.48
	csl-arm-2004-q1:1.48
	binutils-2_15-branch:1.48.0.6
	cagney_bfdfile-20040213-branch:1.48.0.4
	cagney_bfdfile-20040213-branchpoint:1.48
	cagney_bigcore-20040122-branch:1.48.0.2
	cagney_bigcore-20040122-branchpoint:1.48
	csl-arm-2003-q4:1.48
	binutils-2_14:1.43
	binutils-2_14-branch:1.43.0.2
	binutils-2_14-branchpoint:1.43
	binutils-2_13_2_1:1.36
	binutils-2_13_2:1.36
	binutils-2_13_1:1.36
	binutils-2_13:1.36
	binutils-2_13-branchpoint:1.36
	binutils-2_13-branch:1.36.0.2
	binutils-2_12_1:1.31.2.1
	binutils-2_12:1.31
	binutils-2_12-branch:1.31.0.2
	binutils-2_12-branchpoint:1.31
	cygnus_cvs_20020108_pre:1.31
	binutils-2_11_2:1.17.2.2
	binutils-2_11_1:1.17.2.2
	binutils-2_11:1.17
	x86_64versiong3:1.18
	binutils-2_11-branch:1.17.0.2
	binutils-2_10_1:1.12
	binutils-2_10:1.12
	binutils-2_10-branch:1.12.0.2
	binutils-2_10-branchpoint:1.12
	binutils_latest_snapshot:1.119
	repo-unification-2000-02-06:1.12
	binu_ss_19990721:1.9
	binu_ss_19990602:1.2
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.119
date	2013.08.21.05.55.13;	author amodra;	state Exp;
branches;
next	1.118;

1.118
date	2013.01.10.19.51.54;	author hjl;	state Exp;
branches;
next	1.117;

1.117
date	2012.11.09.08.29.31;	author hjl;	state Exp;
branches;
next	1.116;

1.116
date	2012.05.05.03.05.26;	author amodra;	state Exp;
branches;
next	1.115;

1.115
date	2012.02.21.09.13.01;	author iains;	state Exp;
branches;
next	1.114;

1.114
date	2012.01.10.11.48.26;	author gingold;	state Exp;
branches;
next	1.113;

1.113
date	2011.10.12.21.07.07;	author amodra;	state Exp;
branches;
next	1.112;

1.112
date	2011.10.12.02.57.07;	author amodra;	state Exp;
branches;
next	1.111;

1.111
date	2011.07.24.14.20.08;	author rsandifo;	state Exp;
branches
	1.111.2.1;
next	1.110;

1.110
date	2011.05.06.14.48.56;	author gingold;	state Exp;
branches;
next	1.109;

1.109
date	2011.02.28.04.45.59;	author amodra;	state Exp;
branches;
next	1.108;

1.108
date	2010.12.16.18.48.28;	author macro;	state Exp;
branches;
next	1.107;

1.107
date	2010.12.02.13.25.12;	author rsandifo;	state Exp;
branches;
next	1.106;

1.106
date	2010.12.01.21.34.10;	author macro;	state Exp;
branches;
next	1.105;

1.105
date	2010.12.01.20.35.13;	author macro;	state Exp;
branches;
next	1.104;

1.104
date	2010.07.28.09.36.22;	author amodra;	state Exp;
branches
	1.104.2.1;
next	1.103;

1.103
date	2010.07.28.08.43.46;	author amodra;	state Exp;
branches;
next	1.102;

1.102
date	2009.12.11.13.42.09;	author nickc;	state Exp;
branches;
next	1.101;

1.101
date	2009.12.08.03.14.28;	author hjl;	state Exp;
branches;
next	1.100;

1.100
date	2009.10.05.21.58.19;	author amodra;	state Exp;
branches;
next	1.99;

1.99
date	2009.09.23.06.10.08;	author amodra;	state Exp;
branches;
next	1.98;

1.98
date	2009.09.11.15.27.33;	author nickc;	state Exp;
branches;
next	1.97;

1.97
date	2009.09.09.13.19.51;	author amodra;	state Exp;
branches;
next	1.96;

1.96
date	2009.07.29.06.22.12;	author amodra;	state Exp;
branches
	1.96.2.1;
next	1.95;

1.95
date	2009.06.22.17.56.00;	author nickc;	state Exp;
branches;
next	1.94;

1.94
date	2009.05.22.18.11.58;	author hjl;	state Exp;
branches;
next	1.93;

1.93
date	2008.10.21.00.26.17;	author amodra;	state Exp;
branches
	1.93.4.1;
next	1.92;

1.92
date	2008.10.07.14.21.59;	author hjl;	state Exp;
branches;
next	1.91;

1.91
date	2008.08.22.06.07.45;	author amodra;	state Exp;
branches;
next	1.90;

1.90
date	2008.08.12.23.39.30;	author amodra;	state Exp;
branches;
next	1.89;

1.89
date	2008.07.30.04.34.57;	author amodra;	state Exp;
branches;
next	1.88;

1.88
date	2008.03.03.15.28.58;	author hjl;	state Exp;
branches;
next	1.87;

1.87
date	2007.07.12.07.16.39;	author nickc;	state Exp;
branches;
next	1.86;

1.86
date	2007.07.04.11.14.59;	author nickc;	state Exp;
branches;
next	1.85;

1.85
date	2007.07.03.11.01.03;	author nickc;	state Exp;
branches;
next	1.84;

1.84
date	2007.04.21.06.54.56;	author amodra;	state Exp;
branches;
next	1.83;

1.83
date	2007.03.15.12.11.49;	author drow;	state Exp;
branches;
next	1.82;

1.82
date	2007.03.08.06.59.25;	author amodra;	state Exp;
branches;
next	1.81;

1.81
date	2007.02.05.20.10.24;	author brolley;	state Exp;
branches;
next	1.80;

1.80
date	2006.11.15.21.47.49;	author amodra;	state Exp;
branches;
next	1.79;

1.79
date	2006.11.15.15.59.25;	author jbeulich;	state Exp;
branches;
next	1.78;

1.78
date	2006.11.08.06.31.39;	author amodra;	state Exp;
branches;
next	1.77;

1.77
date	2006.09.22.11.35.13;	author amodra;	state Exp;
branches;
next	1.76;

1.76
date	2006.07.17.12.49.50;	author amodra;	state Exp;
branches;
next	1.75;

1.75
date	2006.05.01.09.21.46;	author bje;	state Exp;
branches;
next	1.74;

1.74
date	2006.01.09.17.14.40;	author hjl;	state Exp;
branches
	1.74.4.1;
next	1.73;

1.73
date	2005.12.22.17.05.40;	author jbeulich;	state Exp;
branches;
next	1.72;

1.72
date	2005.12.05.17.00.36;	author danglin;	state Exp;
branches;
next	1.71;

1.71
date	2005.11.17.07.29.28;	author jbeulich;	state Exp;
branches;
next	1.70;

1.70
date	2005.11.14.23.11.30;	author amodra;	state Exp;
branches;
next	1.69;

1.69
date	2005.11.04.19.45.24;	author aoliva;	state Exp;
branches;
next	1.68;

1.68
date	2005.10.27.07.40.07;	author jbeulich;	state Exp;
branches;
next	1.67;

1.67
date	2005.10.24.17.51.41;	author aoliva;	state Exp;
branches;
next	1.66;

1.66
date	2005.10.11.11.16.16;	author nickc;	state Exp;
branches;
next	1.65;

1.65
date	2005.08.11.01.25.20;	author amodra;	state Exp;
branches;
next	1.64;

1.64
date	2005.05.17.11.56.08;	author nickc;	state Exp;
branches;
next	1.63;

1.63
date	2005.05.05.09.12.48;	author nickc;	state Exp;
branches;
next	1.62;

1.62
date	2005.04.29.00.22.27;	author bje;	state Exp;
branches;
next	1.61;

1.61
date	2005.04.20.17.39.57;	author hjl;	state Exp;
branches;
next	1.60;

1.60
date	2005.04.19.15.05.07;	author jbeulich;	state Exp;
branches;
next	1.59;

1.59
date	2005.04.11.00.08.08;	author amodra;	state Exp;
branches;
next	1.58;

1.58
date	2005.04.10.23.41.32;	author echristo;	state Exp;
branches;
next	1.57;

1.57
date	2005.04.09.03.48.09;	author amodra;	state Exp;
branches;
next	1.56;

1.56
date	2005.03.02.00.11.30;	author amodra;	state Exp;
branches
	1.56.2.1;
next	1.55;

1.55
date	2005.03.01.22.24.13;	author amodra;	state Exp;
branches;
next	1.54;

1.54
date	2005.01.21.05.54.38;	author bje;	state Exp;
branches;
next	1.53;

1.53
date	2004.11.09.01.01.17;	author hjl;	state Exp;
branches;
next	1.52;

1.52
date	2004.11.08.08.12.44;	author nickc;	state Exp;
branches;
next	1.51;

1.51
date	2004.11.03.01.54.24;	author hp;	state Exp;
branches;
next	1.50;

1.50
date	2004.06.21.10.59.54;	author nickc;	state Exp;
branches;
next	1.49;

1.49
date	2004.05.11.15.53.47;	author nickc;	state Exp;
branches;
next	1.48;

1.48
date	2003.11.30.19.07.12;	author kazu;	state Exp;
branches;
next	1.47;

1.47
date	2003.10.27.12.45.17;	author kazu;	state Exp;
branches;
next	1.46;

1.46
date	2003.05.27.19.19.29;	author rth;	state Exp;
branches;
next	1.45;

1.45
date	2003.05.27.16.00.04;	author rth;	state Exp;
branches;
next	1.44;

1.44
date	2003.05.20.07.58.06;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2003.01.24.01.12.30;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2003.01.23.12.51.04;	author amodra;	state Exp;
branches;
next	1.41;

1.41
date	2002.12.01.03.18.49;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2002.11.28.14.15.54;	author jakub;	state Exp;
branches;
next	1.39;

1.39
date	2002.09.20.14.47.14;	author nickc;	state Exp;
branches;
next	1.38;

1.38
date	2002.09.20.06.57.41;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	2002.09.05.00.01.15;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2002.06.12.16.39.29;	author bje;	state Exp;
branches;
next	1.35;

1.35
date	2002.06.07.14.57.50;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2002.05.18.12.53.30;	author kazu;	state Exp;
branches;
next	1.33;

1.33
date	2002.05.03.02.25.33;	author kazu;	state Exp;
branches;
next	1.32;

1.32
date	2002.04.03.04.10.28;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2001.09.19.05.33.20;	author hjl;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2001.09.09.14.01.16;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2001.08.09.14.42.07;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2001.08.01.01.44.25;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2001.07.23.13.03.39;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2001.07.05.05.49.13;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2001.06.05.08.29.59;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2001.05.25.10.07.43;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2001.05.24.23.44.06;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2001.05.22.10.23.48;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2001.04.14.06.57.28;	author aoliva;	state Exp;
branches;
next	1.20;

1.20
date	2001.03.30.02.19.36;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2001.03.08.23.24.22;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2001.02.24.09.57.24;	author ciceron;	state Exp;
branches;
next	1.17;

1.17
date	2001.01.23.22.15.01;	author kazu;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2001.01.15.22.53.58;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.11.01.32.35;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2000.08.10.19.00.08;	author kazu;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.19.01.01.04;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2000.02.03.18.20.23;	author twall;	state Exp;
branches;
next	1.11;

1.11
date	2000.01.26.22.48.31;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	99.08.03.15.29.03;	author ian;	state Exp;
branches;
next	1.9;

1.9
date	99.07.15.01.33.35;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	99.07.11.20.20.00;	author ian;	state Exp;
branches;
next	1.7;

1.7
date	99.06.11.21.07.45;	author ian;	state Exp;
branches;
next	1.6;

1.6
date	99.06.10.21.26.10;	author ian;	state Exp;
branches;
next	1.5;

1.5
date	99.06.10.14.45.58;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	99.06.03.09.49.04;	author ian;	state Exp;
branches;
next	1.3;

1.3
date	99.06.03.00.29.07;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.05.06.19.52.29;	author rth;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.41;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.111.2.1
date	2011.10.25.03.06.33;	author amodra;	state Exp;
branches;
next	;

1.104.2.1
date	2011.02.01.12.25.40;	author amodra;	state Exp;
branches;
next	1.104.2.2;

1.104.2.2
date	2011.02.28.04.46.33;	author amodra;	state Exp;
branches;
next	;

1.96.2.1
date	2009.09.09.13.20.28;	author amodra;	state Exp;
branches;
next	1.96.2.2;

1.96.2.2
date	2009.09.11.15.28.43;	author nickc;	state Exp;
branches;
next	1.96.2.3;

1.96.2.3
date	2009.09.23.06.10.49;	author amodra;	state Exp;
branches;
next	1.96.2.4;

1.96.2.4
date	2009.10.07.08.36.44;	author amodra;	state Exp;
branches;
next	1.96.2.5;

1.96.2.5
date	2009.12.16.01.52.13;	author hjl;	state Exp;
branches;
next	;

1.93.4.1
date	2009.09.10.15.09.31;	author amylaar;	state Exp;
branches;
next	;

1.74.4.1
date	2006.07.19.02.06.08;	author amodra;	state Exp;
branches;
next	;

1.56.2.1
date	2005.04.12.12.14.22;	author amodra;	state Exp;
branches;
next	;

1.31.2.1
date	2002.04.27.12.46.46;	author amodra;	state Exp;
branches;
next	;

1.17.2.1
date	2001.06.07.03.15.25;	author amodra;	state Exp;
branches;
next	1.17.2.2;

1.17.2.2
date	2001.06.11.10.04.46;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.41;	author rth;	state Exp;
branches;
next	;


desc
@@


1.119
log
@	* symbols.c (fb_label_instance_inc, fb_label_instance): Properly
	range check label number for use with fb_low_counter array.
@
text
@/* symbols.c -symbol table-
   Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
   2011, 2012 Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* #define DEBUG_SYMS / * to debug symbol list maintenance.  */

#include "as.h"
#include "safe-ctype.h"
#include "obstack.h"		/* For "symbols.h" */
#include "subsegs.h"
#include "struc-symbol.h"

/* This is non-zero if symbols are case sensitive, which is the
   default.  */
int symbols_case_sensitive = 1;

#ifndef WORKING_DOT_WORD
extern int new_broken_words;
#endif

/* symbol-name => struct symbol pointer */
static struct hash_control *sy_hash;

/* Table of local symbols.  */
static struct hash_control *local_hash;

/* Below are commented in "symbols.h".  */
symbolS *symbol_rootP;
symbolS *symbol_lastP;
symbolS abs_symbol;
symbolS dot_symbol;

#ifdef DEBUG_SYMS
#define debug_verify_symchain verify_symbol_chain
#else
#define debug_verify_symchain(root, last) ((void) 0)
#endif

#define DOLLAR_LABEL_CHAR	'\001'
#define LOCAL_LABEL_CHAR	'\002'

#ifndef TC_LABEL_IS_LOCAL
#define TC_LABEL_IS_LOCAL(name)	0
#endif

struct obstack notes;
#ifdef TE_PE
/* The name of an external symbol which is
   used to make weak PE symbol names unique.  */
const char * an_external_name;
#endif

static char *save_symbol_name (const char *);
static void fb_label_init (void);
static long dollar_label_instance (long);
static long fb_label_instance (long);

static void print_binary (FILE *, const char *, expressionS *);

/* Return a pointer to a new symbol.  Die if we can't make a new
   symbol.  Fill in the symbol's values.  Add symbol to end of symbol
   chain.

   This function should be called in the general case of creating a
   symbol.  However, if the output file symbol table has already been
   set, and you are certain that this symbol won't be wanted in the
   output file, you can call symbol_create.  */

symbolS *
symbol_new (const char *name, segT segment, valueT valu, fragS *frag)
{
  symbolS *symbolP = symbol_create (name, segment, valu, frag);

  /* Link to end of symbol chain.  */
  {
    extern int symbol_table_frozen;
    if (symbol_table_frozen)
      abort ();
  }
  symbol_append (symbolP, symbol_lastP, &symbol_rootP, &symbol_lastP);

  return symbolP;
}

/* Save a symbol name on a permanent obstack, and convert it according
   to the object file format.  */

static char *
save_symbol_name (const char *name)
{
  unsigned int name_length;
  char *ret;

  name_length = strlen (name) + 1;	/* +1 for \0.  */
  obstack_grow (&notes, name, name_length);
  ret = (char *) obstack_finish (&notes);

#ifdef tc_canonicalize_symbol_name
  ret = tc_canonicalize_symbol_name (ret);
#endif

  if (! symbols_case_sensitive)
    {
      char *s;

      for (s = ret; *s != '\0'; s++)
	*s = TOUPPER (*s);
    }

  return ret;
}

symbolS *
symbol_create (const char *name, /* It is copied, the caller can destroy/modify.  */
	       segT segment,	/* Segment identifier (SEG_<something>).  */
	       valueT valu,	/* Symbol value.  */
	       fragS *frag	/* Associated fragment.  */)
{
  char *preserved_copy_of_name;
  symbolS *symbolP;

  preserved_copy_of_name = save_symbol_name (name);

  symbolP = (symbolS *) obstack_alloc (&notes, sizeof (symbolS));

  /* symbol must be born in some fixed state.  This seems as good as any.  */
  memset (symbolP, 0, sizeof (symbolS));

  symbolP->bsym = bfd_make_empty_symbol (stdoutput);
  if (symbolP->bsym == NULL)
    as_fatal ("bfd_make_empty_symbol: %s", bfd_errmsg (bfd_get_error ()));
  S_SET_NAME (symbolP, preserved_copy_of_name);

  S_SET_SEGMENT (symbolP, segment);
  S_SET_VALUE (symbolP, valu);
  symbol_clear_list_pointers (symbolP);

  symbolP->sy_frag = frag;

  obj_symbol_new_hook (symbolP);

#ifdef tc_symbol_new_hook
  tc_symbol_new_hook (symbolP);
#endif

  return symbolP;
}


/* Local symbol support.  If we can get away with it, we keep only a
   small amount of information for local symbols.  */

static symbolS *local_symbol_convert (struct local_symbol *);

/* Used for statistics.  */

static unsigned long local_symbol_count;
static unsigned long local_symbol_conversion_count;

/* This macro is called with a symbol argument passed by reference.
   It returns whether this is a local symbol.  If necessary, it
   changes its argument to the real symbol.  */

#define LOCAL_SYMBOL_CHECK(s)						\
  (s->sy_flags.sy_local_symbol 						\
   ? (local_symbol_converted_p ((struct local_symbol *) s)		\
      ? (s = local_symbol_get_real_symbol ((struct local_symbol *) s),	\
	 0)								\
      : 1)								\
   : 0)

/* Create a local symbol and insert it into the local hash table.  */

struct local_symbol *
local_symbol_make (const char *name, segT section, valueT val, fragS *frag)
{
  char *name_copy;
  struct local_symbol *ret;

  ++local_symbol_count;

  name_copy = save_symbol_name (name);

  ret = (struct local_symbol *) obstack_alloc (&notes, sizeof *ret);
  ret->lsy_flags.sy_local_symbol = 1;
  ret->lsy_flags.sy_resolved = 0;
  ret->lsy_name = name_copy;
  ret->lsy_section = section;
  local_symbol_set_frag (ret, frag);
  ret->lsy_value = val;

  hash_jam (local_hash, name_copy, (void *) ret);

  return ret;
}

/* Convert a local symbol into a real symbol.  Note that we do not
   reclaim the space used by the local symbol.  */

static symbolS *
local_symbol_convert (struct local_symbol *locsym)
{
  symbolS *ret;

  gas_assert (locsym->lsy_flags.sy_local_symbol);
  if (local_symbol_converted_p (locsym))
    return local_symbol_get_real_symbol (locsym);

  ++local_symbol_conversion_count;

  ret = symbol_new (locsym->lsy_name, locsym->lsy_section, locsym->lsy_value,
		    local_symbol_get_frag (locsym));

  if (local_symbol_resolved_p (locsym))
    ret->sy_flags.sy_resolved = 1;

  /* Local symbols are always either defined or used.  */
  ret->sy_flags.sy_used = 1;

#ifdef TC_LOCAL_SYMFIELD_CONVERT
  TC_LOCAL_SYMFIELD_CONVERT (locsym, ret);
#endif

  symbol_table_insert (ret);

  local_symbol_mark_converted (locsym);
  local_symbol_set_real_symbol (locsym, ret);

  hash_jam (local_hash, locsym->lsy_name, NULL);

  return ret;
}

static void
define_sym_at_dot (symbolS *symbolP)
{
  symbolP->sy_frag = frag_now;
  S_SET_VALUE (symbolP, (valueT) frag_now_fix ());
  S_SET_SEGMENT (symbolP, now_seg);
}

/* We have just seen "<name>:".
   Creates a struct symbol unless it already exists.

   Gripes if we are redefining a symbol incompatibly (and ignores it).  */

symbolS *
colon (/* Just seen "x:" - rattle symbols & frags.  */
       const char *sym_name	/* Symbol name, as a cannonical string.  */
       /* We copy this string: OK to alter later.  */)
{
  register symbolS *symbolP;	/* Symbol we are working with.  */

  /* Sun local labels go out of scope whenever a non-local symbol is
     defined.  */
  if (LOCAL_LABELS_DOLLAR
      && !bfd_is_local_label_name (stdoutput, sym_name))
    dollar_label_clear ();

#ifndef WORKING_DOT_WORD
  if (new_broken_words)
    {
      struct broken_word *a;
      int possible_bytes;
      fragS *frag_tmp;
      char *frag_opcode;

      if (now_seg == absolute_section)
	{
	  as_bad (_("cannot define symbol `%s' in absolute section"), sym_name);
	  return NULL;
	}

      possible_bytes = (md_short_jump_size
			+ new_broken_words * md_long_jump_size);

      frag_tmp = frag_now;
      frag_opcode = frag_var (rs_broken_word,
			      possible_bytes,
			      possible_bytes,
			      (relax_substateT) 0,
			      (symbolS *) broken_words,
			      (offsetT) 0,
			      NULL);

      /* We want to store the pointer to where to insert the jump
	 table in the fr_opcode of the rs_broken_word frag.  This
	 requires a little hackery.  */
      while (frag_tmp
	     && (frag_tmp->fr_type != rs_broken_word
		 || frag_tmp->fr_opcode))
	frag_tmp = frag_tmp->fr_next;
      know (frag_tmp);
      frag_tmp->fr_opcode = frag_opcode;
      new_broken_words = 0;

      for (a = broken_words; a && a->dispfrag == 0; a = a->next_broken_word)
	a->dispfrag = frag_tmp;
    }
#endif /* WORKING_DOT_WORD */

#ifdef obj_frob_colon
  obj_frob_colon (sym_name);
#endif

  if ((symbolP = symbol_find (sym_name)) != 0)
    {
      S_CLEAR_WEAKREFR (symbolP);
#ifdef RESOLVE_SYMBOL_REDEFINITION
      if (RESOLVE_SYMBOL_REDEFINITION (symbolP))
	return symbolP;
#endif
      /* Now check for undefined symbols.  */
      if (LOCAL_SYMBOL_CHECK (symbolP))
	{
	  struct local_symbol *locsym = (struct local_symbol *) symbolP;

	  if (locsym->lsy_section != undefined_section
	      && (local_symbol_get_frag (locsym) != frag_now
		  || locsym->lsy_section != now_seg
		  || locsym->lsy_value != frag_now_fix ()))
	    {
	      as_bad (_("symbol `%s' is already defined"), sym_name);
	      return symbolP;
	    }

	  locsym->lsy_section = now_seg;
	  local_symbol_set_frag (locsym, frag_now);
	  locsym->lsy_value = frag_now_fix ();
	}
      else if (!(S_IS_DEFINED (symbolP) || symbol_equated_p (symbolP))
	       || S_IS_COMMON (symbolP)
	       || S_IS_VOLATILE (symbolP))
	{
	  if (S_IS_VOLATILE (symbolP))
	    {
	      symbolP = symbol_clone (symbolP, 1);
	      S_SET_VALUE (symbolP, 0);
	      S_CLEAR_VOLATILE (symbolP);
	    }
	  if (S_GET_VALUE (symbolP) == 0)
	    {
	      define_sym_at_dot (symbolP);
#ifdef N_UNDF
	      know (N_UNDF == 0);
#endif /* if we have one, it better be zero.  */

	    }
	  else
	    {
	      /* There are still several cases to check:

		 A .comm/.lcomm symbol being redefined as initialized
		 data is OK

		 A .comm/.lcomm symbol being redefined with a larger
		 size is also OK

		 This only used to be allowed on VMS gas, but Sun cc
		 on the sparc also depends on it.  */

	      if (((!S_IS_DEBUG (symbolP)
		    && (!S_IS_DEFINED (symbolP) || S_IS_COMMON (symbolP))
		    && S_IS_EXTERNAL (symbolP))
		   || S_GET_SEGMENT (symbolP) == bss_section)
		  && (now_seg == data_section
		      || now_seg == bss_section
		      || now_seg == S_GET_SEGMENT (symbolP)))
		{
		  /* Select which of the 2 cases this is.  */
		  if (now_seg != data_section)
		    {
		      /* New .comm for prev .comm symbol.

			 If the new size is larger we just change its
			 value.  If the new size is smaller, we ignore
			 this symbol.  */
		      if (S_GET_VALUE (symbolP)
			  < ((unsigned) frag_now_fix ()))
			{
			  S_SET_VALUE (symbolP, (valueT) frag_now_fix ());
			}
		    }
		  else
		    {
		      /* It is a .comm/.lcomm being converted to initialized
			 data.  */
		      define_sym_at_dot (symbolP);
		    }
		}
	      else
		{
#if (!defined (OBJ_AOUT) && !defined (OBJ_MAYBE_AOUT) \
     && !defined (OBJ_BOUT) && !defined (OBJ_MAYBE_BOUT))
		  static const char *od_buf = "";
#else
		  char od_buf[100];
		  od_buf[0] = '\0';
		  if (OUTPUT_FLAVOR == bfd_target_aout_flavour)
		    sprintf (od_buf, "%d.%d.",
			     S_GET_OTHER (symbolP),
			     S_GET_DESC (symbolP));
#endif
		  as_bad (_("symbol `%s' is already defined as \"%s\"/%s%ld"),
			    sym_name,
			    segment_name (S_GET_SEGMENT (symbolP)),
			    od_buf,
			    (long) S_GET_VALUE (symbolP));
		}
	    }			/* if the undefined symbol has no value  */
	}
      else
	{
	  /* Don't blow up if the definition is the same.  */
	  if (!(frag_now == symbolP->sy_frag
		&& S_GET_VALUE (symbolP) == frag_now_fix ()
		&& S_GET_SEGMENT (symbolP) == now_seg))
	    {
	      as_bad (_("symbol `%s' is already defined"), sym_name);
	      symbolP = symbol_clone (symbolP, 0);
	      define_sym_at_dot (symbolP);
	    }
	}

    }
  else if (! flag_keep_locals && bfd_is_local_label_name (stdoutput, sym_name))
    {
      symbolP = (symbolS *) local_symbol_make (sym_name, now_seg,
					       (valueT) frag_now_fix (),
					       frag_now);
    }
  else
    {
      symbolP = symbol_new (sym_name, now_seg, (valueT) frag_now_fix (),
			    frag_now);

      symbol_table_insert (symbolP);
    }

  if (mri_common_symbol != NULL)
    {
      /* This symbol is actually being defined within an MRI common
	 section.  This requires special handling.  */
      if (LOCAL_SYMBOL_CHECK (symbolP))
	symbolP = local_symbol_convert ((struct local_symbol *) symbolP);
      symbolP->sy_value.X_op = O_symbol;
      symbolP->sy_value.X_add_symbol = mri_common_symbol;
      symbolP->sy_value.X_add_number = S_GET_VALUE (mri_common_symbol);
      symbolP->sy_frag = &zero_address_frag;
      S_SET_SEGMENT (symbolP, expr_section);
      symbolP->sy_flags.sy_mri_common = 1;
    }

#ifdef tc_frob_label
  tc_frob_label (symbolP);
#endif
#ifdef obj_frob_label
  obj_frob_label (symbolP);
#endif

  return symbolP;
}

/* Die if we can't insert the symbol.  */

void
symbol_table_insert (symbolS *symbolP)
{
  register const char *error_string;

  know (symbolP);
  know (S_GET_NAME (symbolP));

  if (LOCAL_SYMBOL_CHECK (symbolP))
    {
      error_string = hash_jam (local_hash, S_GET_NAME (symbolP),
			       (void *) symbolP);
      if (error_string != NULL)
	as_fatal (_("inserting \"%s\" into symbol table failed: %s"),
		  S_GET_NAME (symbolP), error_string);
      return;
    }

  if ((error_string = hash_jam (sy_hash, S_GET_NAME (symbolP), (void *) symbolP)))
    {
      as_fatal (_("inserting \"%s\" into symbol table failed: %s"),
		S_GET_NAME (symbolP), error_string);
    }				/* on error  */
}

/* If a symbol name does not exist, create it as undefined, and insert
   it into the symbol table.  Return a pointer to it.  */

symbolS *
symbol_find_or_make (const char *name)
{
  register symbolS *symbolP;

  symbolP = symbol_find (name);

  if (symbolP == NULL)
    {
      if (! flag_keep_locals && bfd_is_local_label_name (stdoutput, name))
	{
	  symbolP = md_undefined_symbol ((char *) name);
	  if (symbolP != NULL)
	    return symbolP;

	  symbolP = (symbolS *) local_symbol_make (name, undefined_section,
						   (valueT) 0,
						   &zero_address_frag);
	  return symbolP;
	}

      symbolP = symbol_make (name);

      symbol_table_insert (symbolP);
    }				/* if symbol wasn't found */

  return (symbolP);
}

symbolS *
symbol_make (const char *name)
{
  symbolS *symbolP;

  /* Let the machine description default it, e.g. for register names.  */
  symbolP = md_undefined_symbol ((char *) name);

  if (!symbolP)
    symbolP = symbol_new (name, undefined_section, (valueT) 0, &zero_address_frag);

  return (symbolP);
}

symbolS *
symbol_clone (symbolS *orgsymP, int replace)
{
  symbolS *newsymP;
  asymbol *bsymorg, *bsymnew;

  /* Make sure we never clone the dot special symbol.  */
  gas_assert (orgsymP != &dot_symbol);

  /* Running local_symbol_convert on a clone that's not the one currently
     in local_hash would incorrectly replace the hash entry.  Thus the
     symbol must be converted here.  Note that the rest of the function
     depends on not encountering an unconverted symbol.  */
  if (LOCAL_SYMBOL_CHECK (orgsymP))
    orgsymP = local_symbol_convert ((struct local_symbol *) orgsymP);
  bsymorg = orgsymP->bsym;

  newsymP = (symbolS *) obstack_alloc (&notes, sizeof (*newsymP));
  *newsymP = *orgsymP;
  bsymnew = bfd_make_empty_symbol (bfd_asymbol_bfd (bsymorg));
  if (bsymnew == NULL)
    as_fatal ("bfd_make_empty_symbol: %s", bfd_errmsg (bfd_get_error ()));
  newsymP->bsym = bsymnew;
  bsymnew->name = bsymorg->name;
  bsymnew->flags = bsymorg->flags & ~BSF_SECTION_SYM;
  bsymnew->section = bsymorg->section;
  bfd_copy_private_symbol_data (bfd_asymbol_bfd (bsymorg), bsymorg,
				bfd_asymbol_bfd (bsymnew), bsymnew);

#ifdef obj_symbol_clone_hook
  obj_symbol_clone_hook (newsymP, orgsymP);
#endif

#ifdef tc_symbol_clone_hook
  tc_symbol_clone_hook (newsymP, orgsymP);
#endif

  if (replace)
    {
      if (symbol_rootP == orgsymP)
	symbol_rootP = newsymP;
      else if (orgsymP->sy_previous)
	{
	  orgsymP->sy_previous->sy_next = newsymP;
	  orgsymP->sy_previous = NULL;
	}
      if (symbol_lastP == orgsymP)
	symbol_lastP = newsymP;
      else if (orgsymP->sy_next)
	orgsymP->sy_next->sy_previous = newsymP;

      /* Symbols that won't be output can't be external.  */
      S_CLEAR_EXTERNAL (orgsymP);
      orgsymP->sy_previous = orgsymP->sy_next = orgsymP;
      debug_verify_symchain (symbol_rootP, symbol_lastP);

      symbol_table_insert (newsymP);
    }
  else
    {
      /* Symbols that won't be output can't be external.  */
      S_CLEAR_EXTERNAL (newsymP);
      newsymP->sy_previous = newsymP->sy_next = newsymP;
    }

  return newsymP;
}

/* Referenced symbols, if they are forward references, need to be cloned
   (without replacing the original) so that the value of the referenced
   symbols at the point of use .  */

#undef symbol_clone_if_forward_ref
symbolS *
symbol_clone_if_forward_ref (symbolS *symbolP, int is_forward)
{
  if (symbolP && !LOCAL_SYMBOL_CHECK (symbolP))
    {
      symbolS *add_symbol = symbolP->sy_value.X_add_symbol;
      symbolS *op_symbol = symbolP->sy_value.X_op_symbol;

      if (symbolP->sy_flags.sy_forward_ref)
	is_forward = 1;

      if (is_forward)
	{
	  /* assign_symbol() clones volatile symbols; pre-existing expressions
	     hold references to the original instance, but want the current
	     value.  Just repeat the lookup.  */
	  if (add_symbol && S_IS_VOLATILE (add_symbol))
	    add_symbol = symbol_find_exact (S_GET_NAME (add_symbol));
	  if (op_symbol && S_IS_VOLATILE (op_symbol))
	    op_symbol = symbol_find_exact (S_GET_NAME (op_symbol));
	}

      /* Re-using sy_resolving here, as this routine cannot get called from
	 symbol resolution code.  */
      if ((symbolP->bsym->section == expr_section
           || symbolP->sy_flags.sy_forward_ref)
	  && !symbolP->sy_flags.sy_resolving)
	{
	  symbolP->sy_flags.sy_resolving = 1;
	  add_symbol = symbol_clone_if_forward_ref (add_symbol, is_forward);
	  op_symbol = symbol_clone_if_forward_ref (op_symbol, is_forward);
	  symbolP->sy_flags.sy_resolving = 0;
	}

      if (symbolP->sy_flags.sy_forward_ref
	  || add_symbol != symbolP->sy_value.X_add_symbol
	  || op_symbol != symbolP->sy_value.X_op_symbol)
	{
	  if (symbolP != &dot_symbol)
	    {
	      symbolP = symbol_clone (symbolP, 0);
	      symbolP->sy_flags.sy_resolving = 0;
	    }
	  else
	    {
	      symbolP = symbol_temp_new_now ();
#ifdef tc_new_dot_label
	      tc_new_dot_label (symbolP);
#endif
	    }
	}

      symbolP->sy_value.X_add_symbol = add_symbol;
      symbolP->sy_value.X_op_symbol = op_symbol;
    }

  return symbolP;
}

symbolS *
symbol_temp_new (segT seg, valueT ofs, fragS *frag)
{
  return symbol_new (FAKE_LABEL_NAME, seg, ofs, frag);
}

symbolS *
symbol_temp_new_now (void)
{
  return symbol_temp_new (now_seg, frag_now_fix (), frag_now);
}

symbolS *
symbol_temp_make (void)
{
  return symbol_make (FAKE_LABEL_NAME);
}

/* Implement symbol table lookup.
   In:	A symbol's name as a string: '\0' can't be part of a symbol name.
   Out:	NULL if the name was not in the symbol table, else the address
   of a struct symbol associated with that name.  */

symbolS *
symbol_find_exact (const char *name)
{
  return symbol_find_exact_noref (name, 0);
}

symbolS *
symbol_find_exact_noref (const char *name, int noref)
{
  struct local_symbol *locsym;
  symbolS* sym;

  locsym = (struct local_symbol *) hash_find (local_hash, name);
  if (locsym != NULL)
    return (symbolS *) locsym;

  sym = ((symbolS *) hash_find (sy_hash, name));

  /* Any references to the symbol, except for the reference in
     .weakref, must clear this flag, such that the symbol does not
     turn into a weak symbol.  Note that we don't have to handle the
     local_symbol case, since a weakrefd is always promoted out of the
     local_symbol table when it is turned into a weak symbol.  */
  if (sym && ! noref)
    S_CLEAR_WEAKREFD (sym);

  return sym;
}

symbolS *
symbol_find (const char *name)
{
  return symbol_find_noref (name, 0);
}

symbolS *
symbol_find_noref (const char *name, int noref)
{
#ifdef tc_canonicalize_symbol_name
  {
    char *copy;
    size_t len = strlen (name) + 1;

    copy = (char *) alloca (len);
    memcpy (copy, name, len);
    name = tc_canonicalize_symbol_name (copy);
  }
#endif

  if (! symbols_case_sensitive)
    {
      char *copy;
      const char *orig;
      unsigned char c;

      orig = name;
      name = copy = (char *) alloca (strlen (name) + 1);

      while ((c = *orig++) != '\0')
	{
	  *copy++ = TOUPPER (c);
	}
      *copy = '\0';
    }

  return symbol_find_exact_noref (name, noref);
}

/* Once upon a time, symbols were kept in a singly linked list.  At
   least coff needs to be able to rearrange them from time to time, for
   which a doubly linked list is much more convenient.  Loic did these
   as macros which seemed dangerous to me so they're now functions.
   xoxorich.  */

/* Link symbol ADDME after symbol TARGET in the chain.  */

void
symbol_append (symbolS *addme, symbolS *target,
	       symbolS **rootPP, symbolS **lastPP)
{
  if (LOCAL_SYMBOL_CHECK (addme))
    abort ();
  if (target != NULL && LOCAL_SYMBOL_CHECK (target))
    abort ();

  if (target == NULL)
    {
      know (*rootPP == NULL);
      know (*lastPP == NULL);
      addme->sy_next = NULL;
      addme->sy_previous = NULL;
      *rootPP = addme;
      *lastPP = addme;
      return;
    }				/* if the list is empty  */

  if (target->sy_next != NULL)
    {
      target->sy_next->sy_previous = addme;
    }
  else
    {
      know (*lastPP == target);
      *lastPP = addme;
    }				/* if we have a next  */

  addme->sy_next = target->sy_next;
  target->sy_next = addme;
  addme->sy_previous = target;

  debug_verify_symchain (symbol_rootP, symbol_lastP);
}

/* Set the chain pointers of SYMBOL to null.  */

void
symbol_clear_list_pointers (symbolS *symbolP)
{
  if (LOCAL_SYMBOL_CHECK (symbolP))
    abort ();
  symbolP->sy_next = NULL;
  symbolP->sy_previous = NULL;
}

/* Remove SYMBOLP from the list.  */

void
symbol_remove (symbolS *symbolP, symbolS **rootPP, symbolS **lastPP)
{
  if (LOCAL_SYMBOL_CHECK (symbolP))
    abort ();

  if (symbolP == *rootPP)
    {
      *rootPP = symbolP->sy_next;
    }				/* if it was the root  */

  if (symbolP == *lastPP)
    {
      *lastPP = symbolP->sy_previous;
    }				/* if it was the tail  */

  if (symbolP->sy_next != NULL)
    {
      symbolP->sy_next->sy_previous = symbolP->sy_previous;
    }				/* if not last  */

  if (symbolP->sy_previous != NULL)
    {
      symbolP->sy_previous->sy_next = symbolP->sy_next;
    }				/* if not first  */

  debug_verify_symchain (*rootPP, *lastPP);
}

/* Link symbol ADDME before symbol TARGET in the chain.  */

void
symbol_insert (symbolS *addme, symbolS *target,
	       symbolS **rootPP, symbolS **lastPP ATTRIBUTE_UNUSED)
{
  if (LOCAL_SYMBOL_CHECK (addme))
    abort ();
  if (LOCAL_SYMBOL_CHECK (target))
    abort ();

  if (target->sy_previous != NULL)
    {
      target->sy_previous->sy_next = addme;
    }
  else
    {
      know (*rootPP == target);
      *rootPP = addme;
    }				/* if not first  */

  addme->sy_previous = target->sy_previous;
  target->sy_previous = addme;
  addme->sy_next = target;

  debug_verify_symchain (*rootPP, *lastPP);
}

void
verify_symbol_chain (symbolS *rootP, symbolS *lastP)
{
  symbolS *symbolP = rootP;

  if (symbolP == NULL)
    return;

  for (; symbol_next (symbolP) != NULL; symbolP = symbol_next (symbolP))
    {
      gas_assert (symbolP->bsym != NULL);
      gas_assert (symbolP->sy_flags.sy_local_symbol == 0);
      gas_assert (symbolP->sy_next->sy_previous == symbolP);
    }

  gas_assert (lastP == symbolP);
}

#ifdef OBJ_COMPLEX_RELC

static int
use_complex_relocs_for (symbolS * symp)
{
  switch (symp->sy_value.X_op)
    {
    case O_constant:
      return 0;

    case O_symbol:
    case O_symbol_rva:
    case O_uminus:
    case O_bit_not:
    case O_logical_not:
      if (  (S_IS_COMMON (symp->sy_value.X_add_symbol)
	   || S_IS_LOCAL (symp->sy_value.X_add_symbol))
	  &&
	      (S_IS_DEFINED (symp->sy_value.X_add_symbol)
	   && S_GET_SEGMENT (symp->sy_value.X_add_symbol) != expr_section))
	return 0;
      break;

    case O_multiply:
    case O_divide:
    case O_modulus:
    case O_left_shift:
    case O_right_shift:
    case O_bit_inclusive_or:
    case O_bit_or_not:
    case O_bit_exclusive_or:
    case O_bit_and:
    case O_add:
    case O_subtract:
    case O_eq:
    case O_ne:
    case O_lt:
    case O_le:
    case O_ge:
    case O_gt:
    case O_logical_and:
    case O_logical_or:

      if (  (S_IS_COMMON (symp->sy_value.X_add_symbol)
	   || S_IS_LOCAL (symp->sy_value.X_add_symbol))
	  &&
	    (S_IS_COMMON (symp->sy_value.X_op_symbol)
	   || S_IS_LOCAL (symp->sy_value.X_op_symbol))

	  && S_IS_DEFINED (symp->sy_value.X_add_symbol)
	  && S_IS_DEFINED (symp->sy_value.X_op_symbol)
	  && S_GET_SEGMENT (symp->sy_value.X_add_symbol) != expr_section
	  && S_GET_SEGMENT (symp->sy_value.X_op_symbol) != expr_section)
	return 0;
      break;

    default:
      break;
    }
  return 1;
}
#endif

static void
report_op_error (symbolS *symp, symbolS *left, operatorT op, symbolS *right)
{
  char *file;
  unsigned int line;
  segT seg_left = left ? S_GET_SEGMENT (left) : 0;
  segT seg_right = S_GET_SEGMENT (right);
  const char *opname;

  switch (op)
    {
    default:
      abort ();
      return;

    case O_uminus:		opname = "-"; break;
    case O_bit_not:		opname = "~"; break;
    case O_logical_not:		opname = "!"; break;
    case O_multiply:		opname = "*"; break;
    case O_divide:		opname = "/"; break;
    case O_modulus:		opname = "%"; break;
    case O_left_shift:		opname = "<<"; break;
    case O_right_shift:		opname = ">>"; break;
    case O_bit_inclusive_or:	opname = "|"; break;
    case O_bit_or_not:		opname = "|~"; break;
    case O_bit_exclusive_or:	opname = "^"; break;
    case O_bit_and:		opname = "&"; break;
    case O_add:			opname = "+"; break;
    case O_subtract:		opname = "-"; break;
    case O_eq:			opname = "=="; break;
    case O_ne:			opname = "!="; break;
    case O_lt:			opname = "<"; break;
    case O_le:			opname = "<="; break;
    case O_ge:			opname = ">="; break;
    case O_gt:			opname = ">"; break;
    case O_logical_and:		opname = "&&"; break;
    case O_logical_or:		opname = "||"; break;
    }

  if (expr_symbol_where (symp, &file, &line))
    {
      if (left)
	as_bad_where (file, line,
		      _("invalid operands (%s and %s sections) for `%s'"),
		      seg_left->name, seg_right->name, opname);
      else
	as_bad_where (file, line,
		      _("invalid operand (%s section) for `%s'"),
		      seg_right->name, opname);
    }
  else
    {
      const char *sname = S_GET_NAME (symp);

      if (left)
	as_bad (_("invalid operands (%s and %s sections) for `%s' when setting `%s'"),
		seg_left->name, seg_right->name, opname, sname);
      else
	as_bad (_("invalid operand (%s section) for `%s' when setting `%s'"),
		seg_right->name, opname, sname);
    }
}

/* Resolve the value of a symbol.  This is called during the final
   pass over the symbol table to resolve any symbols with complex
   values.  */

valueT
resolve_symbol_value (symbolS *symp)
{
  int resolved;
  valueT final_val = 0;
  segT final_seg;

  if (LOCAL_SYMBOL_CHECK (symp))
    {
      struct local_symbol *locsym = (struct local_symbol *) symp;

      final_val = locsym->lsy_value;
      if (local_symbol_resolved_p (locsym))
	return final_val;

      final_val += local_symbol_get_frag (locsym)->fr_address / OCTETS_PER_BYTE;

      if (finalize_syms)
	{
	  locsym->lsy_value = final_val;
	  local_symbol_mark_resolved (locsym);
	}

      return final_val;
    }

  if (symp->sy_flags.sy_resolved)
    {
      if (symp->sy_value.X_op == O_constant)
	return (valueT) symp->sy_value.X_add_number;
      else
	return 0;
    }

  resolved = 0;
  final_seg = S_GET_SEGMENT (symp);

  if (symp->sy_flags.sy_resolving)
    {
      if (finalize_syms)
	as_bad (_("symbol definition loop encountered at `%s'"),
		S_GET_NAME (symp));
      final_val = 0;
      resolved = 1;
    }
#ifdef OBJ_COMPLEX_RELC
  else if (final_seg == expr_section
	   && use_complex_relocs_for (symp))
    {
      symbolS * relc_symbol = NULL;
      char * relc_symbol_name = NULL;

      relc_symbol_name = symbol_relc_make_expr (& symp->sy_value);

      /* For debugging, print out conversion input & output.  */
#ifdef DEBUG_SYMS
      print_expr (& symp->sy_value);
      if (relc_symbol_name)
	fprintf (stderr, "-> relc symbol: %s\n", relc_symbol_name);
#endif

      if (relc_symbol_name != NULL)
	relc_symbol = symbol_new (relc_symbol_name, undefined_section,
				  0, & zero_address_frag);

      if (relc_symbol == NULL)
	{
	  as_bad (_("cannot convert expression symbol %s to complex relocation"),
		  S_GET_NAME (symp));
	  resolved = 0;
	}
      else
	{
	  symbol_table_insert (relc_symbol);

 	  /* S_CLEAR_EXTERNAL (relc_symbol); */
	  if (symp->bsym->flags & BSF_SRELC)
	    relc_symbol->bsym->flags |= BSF_SRELC;
	  else
	    relc_symbol->bsym->flags |= BSF_RELC;
	  /* symp->bsym->flags |= BSF_RELC; */
	  copy_symbol_attributes (symp, relc_symbol);
	  symp->sy_value.X_op = O_symbol;
	  symp->sy_value.X_add_symbol = relc_symbol;
	  symp->sy_value.X_add_number = 0;
	  resolved = 1;
	}

      final_seg = undefined_section;
      goto exit_dont_set_value;
    }
#endif
  else
    {
      symbolS *add_symbol, *op_symbol;
      offsetT left, right;
      segT seg_left, seg_right;
      operatorT op;
      int move_seg_ok;

      symp->sy_flags.sy_resolving = 1;

      /* Help out with CSE.  */
      add_symbol = symp->sy_value.X_add_symbol;
      op_symbol = symp->sy_value.X_op_symbol;
      final_val = symp->sy_value.X_add_number;
      op = symp->sy_value.X_op;

      switch (op)
	{
	default:
	  BAD_CASE (op);
	  break;

	case O_absent:
	  final_val = 0;
	  /* Fall through.  */

	case O_constant:
	  final_val += symp->sy_frag->fr_address / OCTETS_PER_BYTE;
	  if (final_seg == expr_section)
	    final_seg = absolute_section;
	  /* Fall through.  */

	case O_register:
	  resolved = 1;
	  break;

	case O_symbol:
	case O_symbol_rva:
	  left = resolve_symbol_value (add_symbol);
	  seg_left = S_GET_SEGMENT (add_symbol);
	  if (finalize_syms)
	    symp->sy_value.X_op_symbol = NULL;

	do_symbol:
	  if (S_IS_WEAKREFR (symp))
	    {
	      gas_assert (final_val == 0);
	      if (S_IS_WEAKREFR (add_symbol))
		{
		  gas_assert (add_symbol->sy_value.X_op == O_symbol
			  && add_symbol->sy_value.X_add_number == 0);
		  add_symbol = add_symbol->sy_value.X_add_symbol;
		  gas_assert (! S_IS_WEAKREFR (add_symbol));
		  symp->sy_value.X_add_symbol = add_symbol;
		}
	    }

	  if (symp->sy_flags.sy_mri_common)
	    {
	      /* This is a symbol inside an MRI common section.  The
		 relocation routines are going to handle it specially.
		 Don't change the value.  */
	      resolved = symbol_resolved_p (add_symbol);
	      break;
	    }

	  if (finalize_syms && final_val == 0)
	    {
	      if (LOCAL_SYMBOL_CHECK (add_symbol))
		add_symbol = local_symbol_convert ((struct local_symbol *)
						   add_symbol);
	      copy_symbol_attributes (symp, add_symbol);
	    }

	  /* If we have equated this symbol to an undefined or common
	     symbol, keep X_op set to O_symbol, and don't change
	     X_add_number.  This permits the routine which writes out
	     relocation to detect this case, and convert the
	     relocation to be against the symbol to which this symbol
	     is equated.  */
	  if (! S_IS_DEFINED (add_symbol)
#if defined (OBJ_COFF) && defined (TE_PE)
	      || S_IS_WEAK (add_symbol)
#endif
	      || S_IS_COMMON (add_symbol))
	    {
	      if (finalize_syms)
		{
		  symp->sy_value.X_op = O_symbol;
		  symp->sy_value.X_add_symbol = add_symbol;
		  symp->sy_value.X_add_number = final_val;
		  /* Use X_op_symbol as a flag.  */
		  symp->sy_value.X_op_symbol = add_symbol;
		}
	      final_seg = seg_left;
	      final_val = 0;
	      resolved = symbol_resolved_p (add_symbol);
	      symp->sy_flags.sy_resolving = 0;
	      goto exit_dont_set_value;
	    }
	  else if (finalize_syms
		   && ((final_seg == expr_section && seg_left != expr_section)
		       || symbol_shadow_p (symp)))
	    {
	      /* If the symbol is an expression symbol, do similarly
		 as for undefined and common syms above.  Handles
		 "sym +/- expr" where "expr" cannot be evaluated
		 immediately, and we want relocations to be against
		 "sym", eg. because it is weak.  */
	      symp->sy_value.X_op = O_symbol;
	      symp->sy_value.X_add_symbol = add_symbol;
	      symp->sy_value.X_add_number = final_val;
	      symp->sy_value.X_op_symbol = add_symbol;
	      final_seg = seg_left;
	      final_val += symp->sy_frag->fr_address + left;
	      resolved = symbol_resolved_p (add_symbol);
	      symp->sy_flags.sy_resolving = 0;
	      goto exit_dont_set_value;
	    }
	  else
	    {
	      final_val += symp->sy_frag->fr_address + left;
	      if (final_seg == expr_section || final_seg == undefined_section)
		final_seg = seg_left;
	    }

	  resolved = symbol_resolved_p (add_symbol);
	  if (S_IS_WEAKREFR (symp))
	    goto exit_dont_set_value;
	  break;

	case O_uminus:
	case O_bit_not:
	case O_logical_not:
	  left = resolve_symbol_value (add_symbol);
	  seg_left = S_GET_SEGMENT (add_symbol);

	  /* By reducing these to the relevant dyadic operator, we get
	     	!S -> S == 0 	permitted on anything,
		-S -> 0 - S 	only permitted on absolute
		~S -> S ^ ~0 	only permitted on absolute  */
	  if (op != O_logical_not && seg_left != absolute_section
	      && finalize_syms)
	    report_op_error (symp, NULL, op, add_symbol);

	  if (final_seg == expr_section || final_seg == undefined_section)
	    final_seg = absolute_section;

	  if (op == O_uminus)
	    left = -left;
	  else if (op == O_logical_not)
	    left = !left;
	  else
	    left = ~left;

	  final_val += left + symp->sy_frag->fr_address;

	  resolved = symbol_resolved_p (add_symbol);
	  break;

	case O_multiply:
	case O_divide:
	case O_modulus:
	case O_left_shift:
	case O_right_shift:
	case O_bit_inclusive_or:
	case O_bit_or_not:
	case O_bit_exclusive_or:
	case O_bit_and:
	case O_add:
	case O_subtract:
	case O_eq:
	case O_ne:
	case O_lt:
	case O_le:
	case O_ge:
	case O_gt:
	case O_logical_and:
	case O_logical_or:
	  left = resolve_symbol_value (add_symbol);
	  right = resolve_symbol_value (op_symbol);
	  seg_left = S_GET_SEGMENT (add_symbol);
	  seg_right = S_GET_SEGMENT (op_symbol);

	  /* Simplify addition or subtraction of a constant by folding the
	     constant into X_add_number.  */
	  if (op == O_add)
	    {
	      if (seg_right == absolute_section)
		{
		  final_val += right;
		  goto do_symbol;
		}
	      else if (seg_left == absolute_section)
		{
		  final_val += left;
		  add_symbol = op_symbol;
		  left = right;
		  seg_left = seg_right;
		  goto do_symbol;
		}
	    }
	  else if (op == O_subtract)
	    {
	      if (seg_right == absolute_section)
		{
		  final_val -= right;
		  goto do_symbol;
		}
	    }

	  move_seg_ok = 1;
	  /* Equality and non-equality tests are permitted on anything.
	     Subtraction, and other comparison operators are permitted if
	     both operands are in the same section.  Otherwise, both
	     operands must be absolute.  We already handled the case of
	     addition or subtraction of a constant above.  This will
	     probably need to be changed for an object file format which
	     supports arbitrary expressions, such as IEEE-695.  */
	  if (!(seg_left == absolute_section
		&& seg_right == absolute_section)
	      && !(op == O_eq || op == O_ne)
	      && !((op == O_subtract
		    || op == O_lt || op == O_le || op == O_ge || op == O_gt)
		   && seg_left == seg_right
		   && (seg_left != undefined_section
		       || add_symbol == op_symbol)))
	    {
	      /* Don't emit messages unless we're finalizing the symbol value,
		 otherwise we may get the same message multiple times.  */
	      if (finalize_syms)
		report_op_error (symp, add_symbol, op, op_symbol);
	      /* However do not move the symbol into the absolute section
		 if it cannot currently be resolved - this would confuse
		 other parts of the assembler into believing that the
		 expression had been evaluated to zero.  */
	      else
		move_seg_ok = 0;
	    }

	  if (move_seg_ok
	      && (final_seg == expr_section || final_seg == undefined_section))
	    final_seg = absolute_section;

	  /* Check for division by zero.  */
	  if ((op == O_divide || op == O_modulus) && right == 0)
	    {
	      /* If seg_right is not absolute_section, then we've
		 already issued a warning about using a bad symbol.  */
	      if (seg_right == absolute_section && finalize_syms)
		{
		  char *file;
		  unsigned int line;

		  if (expr_symbol_where (symp, &file, &line))
		    as_bad_where (file, line, _("division by zero"));
		  else
		    as_bad (_("division by zero when setting `%s'"),
			    S_GET_NAME (symp));
		}

	      right = 1;
	    }

	  switch (symp->sy_value.X_op)
	    {
	    case O_multiply:		left *= right; break;
	    case O_divide:		left /= right; break;
	    case O_modulus:		left %= right; break;
	    case O_left_shift:		left <<= right; break;
	    case O_right_shift:		left >>= right; break;
	    case O_bit_inclusive_or:	left |= right; break;
	    case O_bit_or_not:		left |= ~right; break;
	    case O_bit_exclusive_or:	left ^= right; break;
	    case O_bit_and:		left &= right; break;
	    case O_add:			left += right; break;
	    case O_subtract:		left -= right; break;
	    case O_eq:
	    case O_ne:
	      left = (left == right && seg_left == seg_right
		      && (seg_left != undefined_section
			  || add_symbol == op_symbol)
		      ? ~ (offsetT) 0 : 0);
	      if (symp->sy_value.X_op == O_ne)
		left = ~left;
	      break;
	    case O_lt:	left = left <  right ? ~ (offsetT) 0 : 0; break;
	    case O_le:	left = left <= right ? ~ (offsetT) 0 : 0; break;
	    case O_ge:	left = left >= right ? ~ (offsetT) 0 : 0; break;
	    case O_gt:	left = left >  right ? ~ (offsetT) 0 : 0; break;
	    case O_logical_and:	left = left && right; break;
	    case O_logical_or:	left = left || right; break;
	    default:		abort ();
	    }

	  final_val += symp->sy_frag->fr_address + left;
	  if (final_seg == expr_section || final_seg == undefined_section)
	    {
	      if (seg_left == undefined_section
		  || seg_right == undefined_section)
		final_seg = undefined_section;
	      else if (seg_left == absolute_section)
		final_seg = seg_right;
	      else
		final_seg = seg_left;
	    }
	  resolved = (symbol_resolved_p (add_symbol)
		      && symbol_resolved_p (op_symbol));
	  break;

	case O_big:
	case O_illegal:
	  /* Give an error (below) if not in expr_section.  We don't
	     want to worry about expr_section symbols, because they
	     are fictional (they are created as part of expression
	     resolution), and any problems may not actually mean
	     anything.  */
	  break;
	}

      symp->sy_flags.sy_resolving = 0;
    }

  if (finalize_syms)
    S_SET_VALUE (symp, final_val);

exit_dont_set_value:
  /* Always set the segment, even if not finalizing the value.
     The segment is used to determine whether a symbol is defined.  */
    S_SET_SEGMENT (symp, final_seg);

  /* Don't worry if we can't resolve an expr_section symbol.  */
  if (finalize_syms)
    {
      if (resolved)
	symp->sy_flags.sy_resolved = 1;
      else if (S_GET_SEGMENT (symp) != expr_section)
	{
	  as_bad (_("can't resolve value for symbol `%s'"),
		  S_GET_NAME (symp));
	  symp->sy_flags.sy_resolved = 1;
	}
    }

  return final_val;
}

static void resolve_local_symbol (const char *, void *);

/* A static function passed to hash_traverse.  */

static void
resolve_local_symbol (const char *key ATTRIBUTE_UNUSED, void *value)
{
  if (value != NULL)
    resolve_symbol_value ((symbolS *) value);
}

/* Resolve all local symbols.  */

void
resolve_local_symbol_values (void)
{
  hash_traverse (local_hash, resolve_local_symbol);
}

/* Obtain the current value of a symbol without changing any
   sub-expressions used.  */

int
snapshot_symbol (symbolS **symbolPP, valueT *valueP, segT *segP, fragS **fragPP)
{
  symbolS *symbolP = *symbolPP;

  if (LOCAL_SYMBOL_CHECK (symbolP))
    {
      struct local_symbol *locsym = (struct local_symbol *) symbolP;

      *valueP = locsym->lsy_value;
      *segP = locsym->lsy_section;
      *fragPP = local_symbol_get_frag (locsym);
    }
  else
    {
      expressionS exp = symbolP->sy_value;

      if (!symbolP->sy_flags.sy_resolved && exp.X_op != O_illegal)
	{
	  int resolved;

	  if (symbolP->sy_flags.sy_resolving)
	    return 0;
	  symbolP->sy_flags.sy_resolving = 1;
	  resolved = resolve_expression (&exp);
	  symbolP->sy_flags.sy_resolving = 0;
	  if (!resolved)
	    return 0;

	  switch (exp.X_op)
	    {
	    case O_constant:
	    case O_register:
	      if (!symbol_equated_p (symbolP))
		break;
	      /* Fall thru.  */
	    case O_symbol:
	    case O_symbol_rva:
	      symbolP = exp.X_add_symbol;
	      break;
	    default:
	      return 0;
	    }
	}

      *symbolPP = symbolP;
      *valueP = exp.X_add_number;
      *segP = symbolP->bsym->section;
      *fragPP = symbolP->sy_frag;

      if (*segP == expr_section)
	switch (exp.X_op)
	  {
	  case O_constant: *segP = absolute_section; break;
	  case O_register: *segP = reg_section; break;
	  default: break;
	  }
    }

  return 1;
}

/* Dollar labels look like a number followed by a dollar sign.  Eg, "42$".
   They are *really* local.  That is, they go out of scope whenever we see a
   label that isn't local.  Also, like fb labels, there can be multiple
   instances of a dollar label.  Therefor, we name encode each instance with
   the instance number, keep a list of defined symbols separate from the real
   symbol table, and we treat these buggers as a sparse array.  */

static long *dollar_labels;
static long *dollar_label_instances;
static char *dollar_label_defines;
static unsigned long dollar_label_count;
static unsigned long dollar_label_max;

int
dollar_label_defined (long label)
{
  long *i;

  know ((dollar_labels != NULL) || (dollar_label_count == 0));

  for (i = dollar_labels; i < dollar_labels + dollar_label_count; ++i)
    if (*i == label)
      return dollar_label_defines[i - dollar_labels];

  /* If we get here, label isn't defined.  */
  return 0;
}

static long
dollar_label_instance (long label)
{
  long *i;

  know ((dollar_labels != NULL) || (dollar_label_count == 0));

  for (i = dollar_labels; i < dollar_labels + dollar_label_count; ++i)
    if (*i == label)
      return (dollar_label_instances[i - dollar_labels]);

  /* If we get here, we haven't seen the label before.
     Therefore its instance count is zero.  */
  return 0;
}

void
dollar_label_clear (void)
{
  memset (dollar_label_defines, '\0', (unsigned int) dollar_label_count);
}

#define DOLLAR_LABEL_BUMP_BY 10

void
define_dollar_label (long label)
{
  long *i;

  for (i = dollar_labels; i < dollar_labels + dollar_label_count; ++i)
    if (*i == label)
      {
	++dollar_label_instances[i - dollar_labels];
	dollar_label_defines[i - dollar_labels] = 1;
	return;
      }

  /* If we get to here, we don't have label listed yet.  */

  if (dollar_labels == NULL)
    {
      dollar_labels = (long *) xmalloc (DOLLAR_LABEL_BUMP_BY * sizeof (long));
      dollar_label_instances = (long *) xmalloc (DOLLAR_LABEL_BUMP_BY * sizeof (long));
      dollar_label_defines = (char *) xmalloc (DOLLAR_LABEL_BUMP_BY);
      dollar_label_max = DOLLAR_LABEL_BUMP_BY;
      dollar_label_count = 0;
    }
  else if (dollar_label_count == dollar_label_max)
    {
      dollar_label_max += DOLLAR_LABEL_BUMP_BY;
      dollar_labels = (long *) xrealloc ((char *) dollar_labels,
					 dollar_label_max * sizeof (long));
      dollar_label_instances = (long *) xrealloc ((char *) dollar_label_instances,
					  dollar_label_max * sizeof (long));
      dollar_label_defines = (char *) xrealloc (dollar_label_defines, dollar_label_max);
    }				/* if we needed to grow  */

  dollar_labels[dollar_label_count] = label;
  dollar_label_instances[dollar_label_count] = 1;
  dollar_label_defines[dollar_label_count] = 1;
  ++dollar_label_count;
}

/* Caller must copy returned name: we re-use the area for the next name.

   The mth occurence of label n: is turned into the symbol "Ln^Am"
   where n is the label number and m is the instance number. "L" makes
   it a label discarded unless debugging and "^A"('\1') ensures no
   ordinary symbol SHOULD get the same name as a local label
   symbol. The first "4:" is "L4^A1" - the m numbers begin at 1.

   fb labels get the same treatment, except that ^B is used in place
   of ^A.  */

char *				/* Return local label name.  */
dollar_label_name (register long n,	/* we just saw "n$:" : n a number.  */
		   register int augend	/* 0 for current instance, 1 for new instance.  */)
{
  long i;
  /* Returned to caller, then copied.  Used for created names ("4f").  */
  static char symbol_name_build[24];
  register char *p;
  register char *q;
  char symbol_name_temporary[20];	/* Build up a number, BACKWARDS.  */

  know (n >= 0);
  know (augend == 0 || augend == 1);
  p = symbol_name_build;
#ifdef LOCAL_LABEL_PREFIX
  *p++ = LOCAL_LABEL_PREFIX;
#endif
  *p++ = 'L';

  /* Next code just does sprintf( {}, "%d", n);  */
  /* Label number.  */
  q = symbol_name_temporary;
  for (*q++ = 0, i = n; i; ++q)
    {
      *q = i % 10 + '0';
      i /= 10;
    }
  while ((*p = *--q) != '\0')
    ++p;

  *p++ = DOLLAR_LABEL_CHAR;		/* ^A  */

  /* Instance number.  */
  q = symbol_name_temporary;
  for (*q++ = 0, i = dollar_label_instance (n) + augend; i; ++q)
    {
      *q = i % 10 + '0';
      i /= 10;
    }
  while ((*p++ = *--q) != '\0');

  /* The label, as a '\0' ended string, starts at symbol_name_build.  */
  return symbol_name_build;
}

/* Somebody else's idea of local labels. They are made by "n:" where n
   is any decimal digit. Refer to them with
    "nb" for previous (backward) n:
   or "nf" for next (forward) n:.

   We do a little better and let n be any number, not just a single digit, but
   since the other guy's assembler only does ten, we treat the first ten
   specially.

   Like someone else's assembler, we have one set of local label counters for
   entire assembly, not one set per (sub)segment like in most assemblers. This
   implies that one can refer to a label in another segment, and indeed some
   crufty compilers have done just that.

   Since there could be a LOT of these things, treat them as a sparse
   array.  */

#define FB_LABEL_SPECIAL (10)

static long fb_low_counter[FB_LABEL_SPECIAL];
static long *fb_labels;
static long *fb_label_instances;
static long fb_label_count;
static long fb_label_max;

/* This must be more than FB_LABEL_SPECIAL.  */
#define FB_LABEL_BUMP_BY (FB_LABEL_SPECIAL + 6)

static void
fb_label_init (void)
{
  memset ((void *) fb_low_counter, '\0', sizeof (fb_low_counter));
}

/* Add one to the instance number of this fb label.  */

void
fb_label_instance_inc (long label)
{
  long *i;

  if ((unsigned long) label < FB_LABEL_SPECIAL)
    {
      ++fb_low_counter[label];
      return;
    }

  if (fb_labels != NULL)
    {
      for (i = fb_labels + FB_LABEL_SPECIAL;
	   i < fb_labels + fb_label_count; ++i)
	{
	  if (*i == label)
	    {
	      ++fb_label_instances[i - fb_labels];
	      return;
	    }			/* if we find it  */
	}			/* for each existing label  */
    }

  /* If we get to here, we don't have label listed yet.  */

  if (fb_labels == NULL)
    {
      fb_labels = (long *) xmalloc (FB_LABEL_BUMP_BY * sizeof (long));
      fb_label_instances = (long *) xmalloc (FB_LABEL_BUMP_BY * sizeof (long));
      fb_label_max = FB_LABEL_BUMP_BY;
      fb_label_count = FB_LABEL_SPECIAL;

    }
  else if (fb_label_count == fb_label_max)
    {
      fb_label_max += FB_LABEL_BUMP_BY;
      fb_labels = (long *) xrealloc ((char *) fb_labels,
				     fb_label_max * sizeof (long));
      fb_label_instances = (long *) xrealloc ((char *) fb_label_instances,
					      fb_label_max * sizeof (long));
    }				/* if we needed to grow  */

  fb_labels[fb_label_count] = label;
  fb_label_instances[fb_label_count] = 1;
  ++fb_label_count;
}

static long
fb_label_instance (long label)
{
  long *i;

  if ((unsigned long) label < FB_LABEL_SPECIAL)
    {
      return (fb_low_counter[label]);
    }

  if (fb_labels != NULL)
    {
      for (i = fb_labels + FB_LABEL_SPECIAL;
	   i < fb_labels + fb_label_count; ++i)
	{
	  if (*i == label)
	    {
	      return (fb_label_instances[i - fb_labels]);
	    }			/* if we find it  */
	}			/* for each existing label  */
    }

  /* We didn't find the label, so this must be a reference to the
     first instance.  */
  return 0;
}

/* Caller must copy returned name: we re-use the area for the next name.

   The mth occurence of label n: is turned into the symbol "Ln^Bm"
   where n is the label number and m is the instance number. "L" makes
   it a label discarded unless debugging and "^B"('\2') ensures no
   ordinary symbol SHOULD get the same name as a local label
   symbol. The first "4:" is "L4^B1" - the m numbers begin at 1.

   dollar labels get the same treatment, except that ^A is used in
   place of ^B.  */

char *				/* Return local label name.  */
fb_label_name (long n,	/* We just saw "n:", "nf" or "nb" : n a number.  */
	       long augend	/* 0 for nb, 1 for n:, nf.  */)
{
  long i;
  /* Returned to caller, then copied.  Used for created names ("4f").  */
  static char symbol_name_build[24];
  register char *p;
  register char *q;
  char symbol_name_temporary[20];	/* Build up a number, BACKWARDS.  */

  know (n >= 0);
#ifdef TC_MMIX
  know ((unsigned long) augend <= 2 /* See mmix_fb_label.  */);
#else
  know ((unsigned long) augend <= 1);
#endif
  p = symbol_name_build;
#ifdef LOCAL_LABEL_PREFIX
  *p++ = LOCAL_LABEL_PREFIX;
#endif
  *p++ = 'L';

  /* Next code just does sprintf( {}, "%d", n);  */
  /* Label number.  */
  q = symbol_name_temporary;
  for (*q++ = 0, i = n; i; ++q)
    {
      *q = i % 10 + '0';
      i /= 10;
    }
  while ((*p = *--q) != '\0')
    ++p;

  *p++ = LOCAL_LABEL_CHAR;		/* ^B  */

  /* Instance number.  */
  q = symbol_name_temporary;
  for (*q++ = 0, i = fb_label_instance (n) + augend; i; ++q)
    {
      *q = i % 10 + '0';
      i /= 10;
    }
  while ((*p++ = *--q) != '\0');

  /* The label, as a '\0' ended string, starts at symbol_name_build.  */
  return (symbol_name_build);
}

/* Decode name that may have been generated by foo_label_name() above.
   If the name wasn't generated by foo_label_name(), then return it
   unaltered.  This is used for error messages.  */

char *
decode_local_label_name (char *s)
{
  char *p;
  char *symbol_decode;
  int label_number;
  int instance_number;
  char *type;
  const char *message_format;
  int lindex = 0;

#ifdef LOCAL_LABEL_PREFIX
  if (s[lindex] == LOCAL_LABEL_PREFIX)
    ++lindex;
#endif

  if (s[lindex] != 'L')
    return s;

  for (label_number = 0, p = s + lindex + 1; ISDIGIT (*p); ++p)
    label_number = (10 * label_number) + *p - '0';

  if (*p == DOLLAR_LABEL_CHAR)
    type = "dollar";
  else if (*p == LOCAL_LABEL_CHAR)
    type = "fb";
  else
    return s;

  for (instance_number = 0, p++; ISDIGIT (*p); ++p)
    instance_number = (10 * instance_number) + *p - '0';

  message_format = _("\"%d\" (instance number %d of a %s label)");
  symbol_decode = (char *) obstack_alloc (&notes, strlen (message_format) + 30);
  sprintf (symbol_decode, message_format, label_number, instance_number, type);

  return symbol_decode;
}

/* Get the value of a symbol.  */

valueT
S_GET_VALUE (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return resolve_symbol_value (s);

  if (!s->sy_flags.sy_resolved)
    {
      valueT val = resolve_symbol_value (s);
      if (!finalize_syms)
	return val;
    }
  if (S_IS_WEAKREFR (s))
    return S_GET_VALUE (s->sy_value.X_add_symbol);

  if (s->sy_value.X_op != O_constant)
    {
      if (! s->sy_flags.sy_resolved
	  || s->sy_value.X_op != O_symbol
	  || (S_IS_DEFINED (s) && ! S_IS_COMMON (s)))
	as_bad (_("attempt to get value of unresolved symbol `%s'"),
		S_GET_NAME (s));
    }
  return (valueT) s->sy_value.X_add_number;
}

/* Set the value of a symbol.  */

void
S_SET_VALUE (symbolS *s, valueT val)
{
  if (LOCAL_SYMBOL_CHECK (s))
    {
      ((struct local_symbol *) s)->lsy_value = val;
      return;
    }

  s->sy_value.X_op = O_constant;
  s->sy_value.X_add_number = (offsetT) val;
  s->sy_value.X_unsigned = 0;
  S_CLEAR_WEAKREFR (s);
}

void
copy_symbol_attributes (symbolS *dest, symbolS *src)
{
  if (LOCAL_SYMBOL_CHECK (dest))
    dest = local_symbol_convert ((struct local_symbol *) dest);
  if (LOCAL_SYMBOL_CHECK (src))
    src = local_symbol_convert ((struct local_symbol *) src);

  /* In an expression, transfer the settings of these flags.
     The user can override later, of course.  */
#define COPIED_SYMFLAGS	(BSF_FUNCTION | BSF_OBJECT \
			 | BSF_GNU_INDIRECT_FUNCTION)
  dest->bsym->flags |= src->bsym->flags & COPIED_SYMFLAGS;

#ifdef OBJ_COPY_SYMBOL_ATTRIBUTES
  OBJ_COPY_SYMBOL_ATTRIBUTES (dest, src);
#endif

#ifdef TC_COPY_SYMBOL_ATTRIBUTES
  TC_COPY_SYMBOL_ATTRIBUTES (dest, src);
#endif
}

int
S_IS_FUNCTION (symbolS *s)
{
  flagword flags;

  if (LOCAL_SYMBOL_CHECK (s))
    return 0;

  flags = s->bsym->flags;

  return (flags & BSF_FUNCTION) != 0;
}

int
S_IS_EXTERNAL (symbolS *s)
{
  flagword flags;

  if (LOCAL_SYMBOL_CHECK (s))
    return 0;

  flags = s->bsym->flags;

  /* Sanity check.  */
  if ((flags & BSF_LOCAL) && (flags & BSF_GLOBAL))
    abort ();

  return (flags & BSF_GLOBAL) != 0;
}

int
S_IS_WEAK (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return 0;
  /* Conceptually, a weakrefr is weak if the referenced symbol is.  We
     could probably handle a WEAKREFR as always weak though.  E.g., if
     the referenced symbol has lost its weak status, there's no reason
     to keep handling the weakrefr as if it was weak.  */
  if (S_IS_WEAKREFR (s))
    return S_IS_WEAK (s->sy_value.X_add_symbol);
  return (s->bsym->flags & BSF_WEAK) != 0;
}

int
S_IS_WEAKREFR (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return 0;
  return s->sy_flags.sy_weakrefr != 0;
}

int
S_IS_WEAKREFD (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return 0;
  return s->sy_flags.sy_weakrefd != 0;
}

int
S_IS_COMMON (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return 0;
  return bfd_is_com_section (s->bsym->section);
}

int
S_IS_DEFINED (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return ((struct local_symbol *) s)->lsy_section != undefined_section;
  return s->bsym->section != undefined_section;
}


#ifndef EXTERN_FORCE_RELOC
#define EXTERN_FORCE_RELOC IS_ELF
#endif

/* Return true for symbols that should not be reduced to section
   symbols or eliminated from expressions, because they may be
   overridden by the linker.  */
int
S_FORCE_RELOC (symbolS *s, int strict)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return ((struct local_symbol *) s)->lsy_section == undefined_section;

  return ((strict
	   && ((s->bsym->flags & BSF_WEAK) != 0
	       || (EXTERN_FORCE_RELOC
		   && (s->bsym->flags & BSF_GLOBAL) != 0)))
	  || (s->bsym->flags & BSF_GNU_INDIRECT_FUNCTION) != 0
	  || s->bsym->section == undefined_section
	  || bfd_is_com_section (s->bsym->section));
}

int
S_IS_DEBUG (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return 0;
  if (s->bsym->flags & BSF_DEBUGGING)
    return 1;
  return 0;
}

int
S_IS_LOCAL (symbolS *s)
{
  flagword flags;
  const char *name;

  if (LOCAL_SYMBOL_CHECK (s))
    return 1;

  flags = s->bsym->flags;

  /* Sanity check.  */
  if ((flags & BSF_LOCAL) && (flags & BSF_GLOBAL))
    abort ();

  if (bfd_get_section (s->bsym) == reg_section)
    return 1;

  if (flag_strip_local_absolute
      /* Keep BSF_FILE symbols in order to allow debuggers to identify
	 the source file even when the object file is stripped.  */
      && (flags & (BSF_GLOBAL | BSF_FILE)) == 0
      && bfd_get_section (s->bsym) == absolute_section)
    return 1;

  name = S_GET_NAME (s);
  return (name != NULL
	  && ! S_IS_DEBUG (s)
	  && (strchr (name, DOLLAR_LABEL_CHAR)
	      || strchr (name, LOCAL_LABEL_CHAR)
	      || TC_LABEL_IS_LOCAL (name)
	      || (! flag_keep_locals
		  && (bfd_is_local_label (stdoutput, s->bsym)
		      || (flag_mri
			  && name[0] == '?'
			  && name[1] == '?')))));
}

int
S_IS_STABD (symbolS *s)
{
  return S_GET_NAME (s) == 0;
}

int
S_CAN_BE_REDEFINED (const symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return (local_symbol_get_frag ((struct local_symbol *) s)
	    == &predefined_address_frag);
  /* Permit register names to be redefined.  */
  return s->bsym->section == reg_section;
}

int
S_IS_VOLATILE (const symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return 0;
  return s->sy_flags.sy_volatile;
}

int
S_IS_FORWARD_REF (const symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return 0;
  return s->sy_flags.sy_forward_ref;
}

const char *
S_GET_NAME (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return ((struct local_symbol *) s)->lsy_name;
  return s->bsym->name;
}

segT
S_GET_SEGMENT (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return ((struct local_symbol *) s)->lsy_section;
  return s->bsym->section;
}

void
S_SET_SEGMENT (symbolS *s, segT seg)
{
  /* Don't reassign section symbols.  The direct reason is to prevent seg
     faults assigning back to const global symbols such as *ABS*, but it
     shouldn't happen anyway.  */

  if (LOCAL_SYMBOL_CHECK (s))
    {
      if (seg == reg_section)
	s = local_symbol_convert ((struct local_symbol *) s);
      else
	{
	  ((struct local_symbol *) s)->lsy_section = seg;
	  return;
	}
    }

  if (s->bsym->flags & BSF_SECTION_SYM)
    {
      if (s->bsym->section != seg)
	abort ();
    }
  else
    s->bsym->section = seg;
}

void
S_SET_EXTERNAL (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  if ((s->bsym->flags & BSF_WEAK) != 0)
    {
      /* Let .weak override .global.  */
      return;
    }
  if (s->bsym->flags & BSF_SECTION_SYM)
    {
      char * file;
      unsigned int line;

      /* Do not reassign section symbols.  */
      as_where (& file, & line);
      as_warn_where (file, line,
		     _("section symbols are already global"));
      return;
    }
#ifndef TC_GLOBAL_REGISTER_SYMBOL_OK
  if (S_GET_SEGMENT (s) == reg_section)
    {
      as_bad ("can't make register symbol `%s' global",
	      S_GET_NAME (s));
      return;
    }
#endif
  s->bsym->flags |= BSF_GLOBAL;
  s->bsym->flags &= ~(BSF_LOCAL | BSF_WEAK);

#ifdef TE_PE
  if (! an_external_name && S_GET_NAME(s)[0] != '.')
    an_external_name = S_GET_NAME (s);
#endif
}

void
S_CLEAR_EXTERNAL (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return;
  if ((s->bsym->flags & BSF_WEAK) != 0)
    {
      /* Let .weak override.  */
      return;
    }
  s->bsym->flags |= BSF_LOCAL;
  s->bsym->flags &= ~(BSF_GLOBAL | BSF_WEAK);
}

void
S_SET_WEAK (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
#ifdef obj_set_weak_hook
  obj_set_weak_hook (s);
#endif
  s->bsym->flags |= BSF_WEAK;
  s->bsym->flags &= ~(BSF_GLOBAL | BSF_LOCAL);
}

void
S_SET_WEAKREFR (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  s->sy_flags.sy_weakrefr = 1;
  /* If the alias was already used, make sure we mark the target as
     used as well, otherwise it might be dropped from the symbol
     table.  This may have unintended side effects if the alias is
     later redirected to another symbol, such as keeping the unused
     previous target in the symbol table.  Since it will be weak, it's
     not a big deal.  */
  if (s->sy_flags.sy_used)
    symbol_mark_used (s->sy_value.X_add_symbol);
}

void
S_CLEAR_WEAKREFR (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return;
  s->sy_flags.sy_weakrefr = 0;
}

void
S_SET_WEAKREFD (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  s->sy_flags.sy_weakrefd = 1;
  S_SET_WEAK (s);
}

void
S_CLEAR_WEAKREFD (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return;
  if (s->sy_flags.sy_weakrefd)
    {
      s->sy_flags.sy_weakrefd = 0;
      /* If a weakref target symbol is weak, then it was never
	 referenced directly before, not even in a .global directive,
	 so decay it to local.  If it remains undefined, it will be
	 later turned into a global, like any other undefined
	 symbol.  */
      if (s->bsym->flags & BSF_WEAK)
	{
#ifdef obj_clear_weak_hook
	  obj_clear_weak_hook (s);
#endif
	  s->bsym->flags &= ~BSF_WEAK;
	  s->bsym->flags |= BSF_LOCAL;
	}
    }
}

void
S_SET_THREAD_LOCAL (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  if (bfd_is_com_section (s->bsym->section)
      && (s->bsym->flags & BSF_THREAD_LOCAL) != 0)
    return;
  s->bsym->flags |= BSF_THREAD_LOCAL;
  if ((s->bsym->flags & BSF_FUNCTION) != 0)
    as_bad (_("Accessing function `%s' as thread-local object"),
	    S_GET_NAME (s));
  else if (! bfd_is_und_section (s->bsym->section)
	   && (s->bsym->section->flags & SEC_THREAD_LOCAL) == 0)
    as_bad (_("Accessing `%s' as thread-local object"),
	    S_GET_NAME (s));
}

void
S_SET_NAME (symbolS *s, const char *name)
{
  if (LOCAL_SYMBOL_CHECK (s))
    {
      ((struct local_symbol *) s)->lsy_name = name;
      return;
    }
  s->bsym->name = name;
}

void
S_SET_VOLATILE (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  s->sy_flags.sy_volatile = 1;
}

void
S_CLEAR_VOLATILE (symbolS *s)
{
  if (!LOCAL_SYMBOL_CHECK (s))
    s->sy_flags.sy_volatile = 0;
}

void
S_SET_FORWARD_REF (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  s->sy_flags.sy_forward_ref = 1;
}

/* Return the previous symbol in a chain.  */

symbolS *
symbol_previous (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    abort ();
  return s->sy_previous;
}

/* Return the next symbol in a chain.  */

symbolS *
symbol_next (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    abort ();
  return s->sy_next;
}

/* Return a pointer to the value of a symbol as an expression.  */

expressionS *
symbol_get_value_expression (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  return &s->sy_value;
}

/* Set the value of a symbol to an expression.  */

void
symbol_set_value_expression (symbolS *s, const expressionS *exp)
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  s->sy_value = *exp;
  S_CLEAR_WEAKREFR (s);
}

/* Return whether 2 symbols are the same.  */

int
symbol_same_p (symbolS *s1, symbolS *s2)
{
  if (s1->sy_flags.sy_local_symbol
      && local_symbol_converted_p ((struct local_symbol *) s1))
    s1 = local_symbol_get_real_symbol ((struct local_symbol *) s1);
  if (s2->sy_flags.sy_local_symbol
      && local_symbol_converted_p ((struct local_symbol *) s2))
    s2 = local_symbol_get_real_symbol ((struct local_symbol *) s2);
  return s1 == s2;
}

/* Return a pointer to the X_add_number component of a symbol.  */

offsetT *
symbol_X_add_number (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return (offsetT *) &((struct local_symbol *) s)->lsy_value;

  return &s->sy_value.X_add_number;
}

/* Set the value of SYM to the current position in the current segment.  */

void
symbol_set_value_now (symbolS *sym)
{
  S_SET_SEGMENT (sym, now_seg);
  S_SET_VALUE (sym, frag_now_fix ());
  symbol_set_frag (sym, frag_now);
}

/* Set the frag of a symbol.  */

void
symbol_set_frag (symbolS *s, fragS *f)
{
  if (LOCAL_SYMBOL_CHECK (s))
    {
      local_symbol_set_frag ((struct local_symbol *) s, f);
      return;
    }
  s->sy_frag = f;
  S_CLEAR_WEAKREFR (s);
}

/* Return the frag of a symbol.  */

fragS *
symbol_get_frag (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return local_symbol_get_frag ((struct local_symbol *) s);
  return s->sy_frag;
}

/* Mark a symbol as having been used.  */

void
symbol_mark_used (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return;
  s->sy_flags.sy_used = 1;
  if (S_IS_WEAKREFR (s))
    symbol_mark_used (s->sy_value.X_add_symbol);
}

/* Clear the mark of whether a symbol has been used.  */

void
symbol_clear_used (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  s->sy_flags.sy_used = 0;
}

/* Return whether a symbol has been used.  */

int
symbol_used_p (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return 1;
  return s->sy_flags.sy_used;
}

/* Mark a symbol as having been used in a reloc.  */

void
symbol_mark_used_in_reloc (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  s->sy_flags.sy_used_in_reloc = 1;
}

/* Clear the mark of whether a symbol has been used in a reloc.  */

void
symbol_clear_used_in_reloc (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return;
  s->sy_flags.sy_used_in_reloc = 0;
}

/* Return whether a symbol has been used in a reloc.  */

int
symbol_used_in_reloc_p (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return 0;
  return s->sy_flags.sy_used_in_reloc;
}

/* Mark a symbol as an MRI common symbol.  */

void
symbol_mark_mri_common (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  s->sy_flags.sy_mri_common = 1;
}

/* Clear the mark of whether a symbol is an MRI common symbol.  */

void
symbol_clear_mri_common (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return;
  s->sy_flags.sy_mri_common = 0;
}

/* Return whether a symbol is an MRI common symbol.  */

int
symbol_mri_common_p (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return 0;
  return s->sy_flags.sy_mri_common;
}

/* Mark a symbol as having been written.  */

void
symbol_mark_written (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return;
  s->sy_flags.sy_written = 1;
}

/* Clear the mark of whether a symbol has been written.  */

void
symbol_clear_written (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return;
  s->sy_flags.sy_written = 0;
}

/* Return whether a symbol has been written.  */

int
symbol_written_p (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return 0;
  return s->sy_flags.sy_written;
}

/* Mark a symbol has having been resolved.  */

void
symbol_mark_resolved (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    {
      local_symbol_mark_resolved ((struct local_symbol *) s);
      return;
    }
  s->sy_flags.sy_resolved = 1;
}

/* Return whether a symbol has been resolved.  */

int
symbol_resolved_p (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return local_symbol_resolved_p ((struct local_symbol *) s);
  return s->sy_flags.sy_resolved;
}

/* Return whether a symbol is a section symbol.  */

int
symbol_section_p (symbolS *s ATTRIBUTE_UNUSED)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return 0;
  return (s->bsym->flags & BSF_SECTION_SYM) != 0;
}

/* Return whether a symbol is equated to another symbol.  */

int
symbol_equated_p (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return 0;
  return s->sy_value.X_op == O_symbol;
}

/* Return whether a symbol is equated to another symbol, and should be
   treated specially when writing out relocs.  */

int
symbol_equated_reloc_p (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return 0;
  /* X_op_symbol, normally not used for O_symbol, is set by
     resolve_symbol_value to flag expression syms that have been
     equated.  */
  return (s->sy_value.X_op == O_symbol
#if defined (OBJ_COFF) && defined (TE_PE)
	  && ! S_IS_WEAK (s)
#endif
	  && ((s->sy_flags.sy_resolved && s->sy_value.X_op_symbol != NULL)
	      || ! S_IS_DEFINED (s)
	      || S_IS_COMMON (s)));
}

/* Return whether a symbol has a constant value.  */

int
symbol_constant_p (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return 1;
  return s->sy_value.X_op == O_constant;
}

/* Return whether a symbol was cloned and thus removed from the global
   symbol list.  */

int
symbol_shadow_p (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return 0;
  return s->sy_next == s;
}

/* Return the BFD symbol for a symbol.  */

asymbol *
symbol_get_bfdsym (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  return s->bsym;
}

/* Set the BFD symbol for a symbol.  */

void
symbol_set_bfdsym (symbolS *s, asymbol *bsym)
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  /* Usually, it is harmless to reset a symbol to a BFD section
     symbol. For example, obj_elf_change_section sets the BFD symbol
     of an old symbol with the newly created section symbol. But when
     we have multiple sections with the same name, the newly created
     section may have the same name as an old section. We check if the
     old symbol has been already marked as a section symbol before
     resetting it.  */
  if ((s->bsym->flags & BSF_SECTION_SYM) == 0)
    s->bsym = bsym;
  /* else XXX - What do we do now ?  */
}

#ifdef OBJ_SYMFIELD_TYPE

/* Get a pointer to the object format information for a symbol.  */

OBJ_SYMFIELD_TYPE *
symbol_get_obj (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  return &s->sy_obj;
}

/* Set the object format information for a symbol.  */

void
symbol_set_obj (symbolS *s, OBJ_SYMFIELD_TYPE *o)
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  s->sy_obj = *o;
}

#endif /* OBJ_SYMFIELD_TYPE */

#ifdef TC_SYMFIELD_TYPE

/* Get a pointer to the processor information for a symbol.  */

TC_SYMFIELD_TYPE *
symbol_get_tc (symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  return &s->sy_tc;
}

/* Set the processor information for a symbol.  */

void
symbol_set_tc (symbolS *s, TC_SYMFIELD_TYPE *o)
{
  if (LOCAL_SYMBOL_CHECK (s))
    s = local_symbol_convert ((struct local_symbol *) s);
  s->sy_tc = *o;
}

#endif /* TC_SYMFIELD_TYPE */

void
symbol_begin (void)
{
  symbol_lastP = NULL;
  symbol_rootP = NULL;		/* In case we have 0 symbols (!!)  */
  sy_hash = hash_new ();
  local_hash = hash_new ();

  memset ((char *) (&abs_symbol), '\0', sizeof (abs_symbol));
#if defined (EMIT_SECTION_SYMBOLS) || !defined (RELOC_REQUIRES_SYMBOL)
  abs_symbol.bsym = bfd_abs_section_ptr->symbol;
#endif
  abs_symbol.sy_value.X_op = O_constant;
  abs_symbol.sy_frag = &zero_address_frag;

  if (LOCAL_LABELS_FB)
    fb_label_init ();
}

void
dot_symbol_init (void)
{
  dot_symbol.bsym = bfd_make_empty_symbol (stdoutput);
  if (dot_symbol.bsym == NULL)
    as_fatal ("bfd_make_empty_symbol: %s", bfd_errmsg (bfd_get_error ()));
  dot_symbol.bsym->name = ".";
  dot_symbol.sy_flags.sy_forward_ref = 1;
  dot_symbol.sy_value.X_op = O_constant;
}

int indent_level;

/* Maximum indent level.
   Available for modification inside a gdb session.  */
static int max_indent_level = 8;

void
print_symbol_value_1 (FILE *file, symbolS *sym)
{
  const char *name = S_GET_NAME (sym);
  if (!name || !name[0])
    name = "(unnamed)";
  fprintf (file, "sym ");
  fprintf_vma (file, (bfd_vma) ((bfd_hostptr_t) sym));
  fprintf (file, " %s", name);

  if (LOCAL_SYMBOL_CHECK (sym))
    {
      struct local_symbol *locsym = (struct local_symbol *) sym;

      if (local_symbol_get_frag (locsym) != & zero_address_frag
	  && local_symbol_get_frag (locsym) != NULL)
	{
	  fprintf (file, " frag ");
	  fprintf_vma (file, (bfd_vma) ((bfd_hostptr_t) local_symbol_get_frag (locsym)));
        }
      if (local_symbol_resolved_p (locsym))
	fprintf (file, " resolved");
      fprintf (file, " local");
    }
  else
    {
      if (sym->sy_frag != &zero_address_frag)
	{
	  fprintf (file, " frag ");
	  fprintf_vma (file, (bfd_vma) ((bfd_hostptr_t) sym->sy_frag));
	}
      if (sym->sy_flags.sy_written)
	fprintf (file, " written");
      if (sym->sy_flags.sy_resolved)
	fprintf (file, " resolved");
      else if (sym->sy_flags.sy_resolving)
	fprintf (file, " resolving");
      if (sym->sy_flags.sy_used_in_reloc)
	fprintf (file, " used-in-reloc");
      if (sym->sy_flags.sy_used)
	fprintf (file, " used");
      if (S_IS_LOCAL (sym))
	fprintf (file, " local");
      if (S_IS_EXTERNAL (sym))
	fprintf (file, " extern");
      if (S_IS_WEAK (sym))
	fprintf (file, " weak");
      if (S_IS_DEBUG (sym))
	fprintf (file, " debug");
      if (S_IS_DEFINED (sym))
	fprintf (file, " defined");
    }
  if (S_IS_WEAKREFR (sym))
    fprintf (file, " weakrefr");
  if (S_IS_WEAKREFD (sym))
    fprintf (file, " weakrefd");
  fprintf (file, " %s", segment_name (S_GET_SEGMENT (sym)));
  if (symbol_resolved_p (sym))
    {
      segT s = S_GET_SEGMENT (sym);

      if (s != undefined_section
	  && s != expr_section)
	fprintf (file, " %lx", (unsigned long) S_GET_VALUE (sym));
    }
  else if (indent_level < max_indent_level
	   && S_GET_SEGMENT (sym) != undefined_section)
    {
      indent_level++;
      fprintf (file, "\n%*s<", indent_level * 4, "");
      if (LOCAL_SYMBOL_CHECK (sym))
	fprintf (file, "constant %lx",
		 (unsigned long) ((struct local_symbol *) sym)->lsy_value);
      else
	print_expr_1 (file, &sym->sy_value);
      fprintf (file, ">");
      indent_level--;
    }
  fflush (file);
}

void
print_symbol_value (symbolS *sym)
{
  indent_level = 0;
  print_symbol_value_1 (stderr, sym);
  fprintf (stderr, "\n");
}

static void
print_binary (FILE *file, const char *name, expressionS *exp)
{
  indent_level++;
  fprintf (file, "%s\n%*s<", name, indent_level * 4, "");
  print_symbol_value_1 (file, exp->X_add_symbol);
  fprintf (file, ">\n%*s<", indent_level * 4, "");
  print_symbol_value_1 (file, exp->X_op_symbol);
  fprintf (file, ">");
  indent_level--;
}

void
print_expr_1 (FILE *file, expressionS *exp)
{
  fprintf (file, "expr ");
  fprintf_vma (file, (bfd_vma) ((bfd_hostptr_t) exp));
  fprintf (file, " ");
  switch (exp->X_op)
    {
    case O_illegal:
      fprintf (file, "illegal");
      break;
    case O_absent:
      fprintf (file, "absent");
      break;
    case O_constant:
      fprintf (file, "constant %lx", (unsigned long) exp->X_add_number);
      break;
    case O_symbol:
      indent_level++;
      fprintf (file, "symbol\n%*s<", indent_level * 4, "");
      print_symbol_value_1 (file, exp->X_add_symbol);
      fprintf (file, ">");
    maybe_print_addnum:
      if (exp->X_add_number)
	fprintf (file, "\n%*s%lx", indent_level * 4, "",
		 (unsigned long) exp->X_add_number);
      indent_level--;
      break;
    case O_register:
      fprintf (file, "register #%d", (int) exp->X_add_number);
      break;
    case O_big:
      fprintf (file, "big");
      break;
    case O_uminus:
      fprintf (file, "uminus -<");
      indent_level++;
      print_symbol_value_1 (file, exp->X_add_symbol);
      fprintf (file, ">");
      goto maybe_print_addnum;
    case O_bit_not:
      fprintf (file, "bit_not");
      break;
    case O_multiply:
      print_binary (file, "multiply", exp);
      break;
    case O_divide:
      print_binary (file, "divide", exp);
      break;
    case O_modulus:
      print_binary (file, "modulus", exp);
      break;
    case O_left_shift:
      print_binary (file, "lshift", exp);
      break;
    case O_right_shift:
      print_binary (file, "rshift", exp);
      break;
    case O_bit_inclusive_or:
      print_binary (file, "bit_ior", exp);
      break;
    case O_bit_exclusive_or:
      print_binary (file, "bit_xor", exp);
      break;
    case O_bit_and:
      print_binary (file, "bit_and", exp);
      break;
    case O_eq:
      print_binary (file, "eq", exp);
      break;
    case O_ne:
      print_binary (file, "ne", exp);
      break;
    case O_lt:
      print_binary (file, "lt", exp);
      break;
    case O_le:
      print_binary (file, "le", exp);
      break;
    case O_ge:
      print_binary (file, "ge", exp);
      break;
    case O_gt:
      print_binary (file, "gt", exp);
      break;
    case O_logical_and:
      print_binary (file, "logical_and", exp);
      break;
    case O_logical_or:
      print_binary (file, "logical_or", exp);
      break;
    case O_add:
      indent_level++;
      fprintf (file, "add\n%*s<", indent_level * 4, "");
      print_symbol_value_1 (file, exp->X_add_symbol);
      fprintf (file, ">\n%*s<", indent_level * 4, "");
      print_symbol_value_1 (file, exp->X_op_symbol);
      fprintf (file, ">");
      goto maybe_print_addnum;
    case O_subtract:
      indent_level++;
      fprintf (file, "subtract\n%*s<", indent_level * 4, "");
      print_symbol_value_1 (file, exp->X_add_symbol);
      fprintf (file, ">\n%*s<", indent_level * 4, "");
      print_symbol_value_1 (file, exp->X_op_symbol);
      fprintf (file, ">");
      goto maybe_print_addnum;
    default:
      fprintf (file, "{unknown opcode %d}", (int) exp->X_op);
      break;
    }
  fflush (stdout);
}

void
print_expr (expressionS *exp)
{
  print_expr_1 (stderr, exp);
  fprintf (stderr, "\n");
}

void
symbol_print_statistics (FILE *file)
{
  hash_print_statistics (file, "symbol table", sy_hash);
  hash_print_statistics (file, "mini local symbol table", local_hash);
  fprintf (file, "%lu mini local symbols created, %lu converted\n",
	   local_symbol_count, local_symbol_conversion_count);
}

#ifdef OBJ_COMPLEX_RELC

/* Convert given symbol to a new complex-relocation symbol name.  This
   may be a recursive function, since it might be called for non-leaf
   nodes (plain symbols) in the expression tree.  The caller owns the
   returning string, so should free it eventually.  Errors are
   indicated via as_bad and a NULL return value.  The given symbol
   is marked with sy_used_in_reloc.  */

char *
symbol_relc_make_sym (symbolS * sym)
{
  char * terminal = NULL;
  const char * sname;
  char typetag;
  int sname_len;

  gas_assert (sym != NULL);

  /* Recurse to symbol_relc_make_expr if this symbol
     is defined as an expression or a plain value.  */
  if (   S_GET_SEGMENT (sym) == expr_section
      || S_GET_SEGMENT (sym) == absolute_section)
    return symbol_relc_make_expr (& sym->sy_value);

  /* This may be a "fake symbol" L0\001, referring to ".".
     Write out a special null symbol to refer to this position.  */
  if (! strcmp (S_GET_NAME (sym), FAKE_LABEL_NAME))
    return xstrdup (".");

  /* We hope this is a plain leaf symbol.  Construct the encoding
     as {S,s}II...:CCCCCCC....
     where 'S'/'s' means section symbol / plain symbol
     III is decimal for the symbol name length
     CCC is the symbol name itself.  */
  symbol_mark_used_in_reloc (sym);

  sname = S_GET_NAME (sym);
  sname_len = strlen (sname);
  typetag = symbol_section_p (sym) ? 'S' : 's';

  terminal = xmalloc (1 /* S or s */
		      + 8 /* sname_len in decimal */
		      + 1 /* _ spacer */
		      + sname_len /* name itself */
		      + 1 /* \0 */ );

  sprintf (terminal, "%c%d:%s", typetag, sname_len, sname);
  return terminal;
}

/* Convert given value to a new complex-relocation symbol name.  This
   is a non-recursive function, since it is be called for leaf nodes
   (plain values) in the expression tree.  The caller owns the
   returning string, so should free() it eventually.  No errors.  */

char *
symbol_relc_make_value (offsetT val)
{
  char * terminal = xmalloc (28);  /* Enough for long long.  */

  terminal[0] = '#';
  bfd_sprintf_vma (stdoutput, terminal + 1, val);
  return terminal;
}

/* Convert given expression to a new complex-relocation symbol name.
   This is a recursive function, since it traverses the entire given
   expression tree.  The caller owns the returning string, so should
   free() it eventually.  Errors are indicated via as_bad() and a NULL
   return value.  */

char *
symbol_relc_make_expr (expressionS * exp)
{
  char * opstr = NULL; /* Operator prefix string.  */
  int    arity = 0;    /* Arity of this operator.  */
  char * operands[3];  /* Up to three operands.  */
  char * concat_string = NULL;

  operands[0] = operands[1] = operands[2] = NULL;

  gas_assert (exp != NULL);

  /* Match known operators -> fill in opstr, arity, operands[] and fall
     through to construct subexpression fragments; may instead return
     string directly for leaf nodes.  */

  /* See expr.h for the meaning of all these enums.  Many operators
     have an unnatural arity (X_add_number implicitly added).  The
     conversion logic expands them to explicit "+" subexpressions.   */

  switch (exp->X_op)
    {
    default:
      as_bad ("Unknown expression operator (enum %d)", exp->X_op);
      break;

      /* Leaf nodes.  */
    case O_constant:
      return symbol_relc_make_value (exp->X_add_number);

    case O_symbol:
      if (exp->X_add_number)
	{
	  arity = 2;
	  opstr = "+";
	  operands[0] = symbol_relc_make_sym (exp->X_add_symbol);
	  operands[1] = symbol_relc_make_value (exp->X_add_number);
	  break;
	}
      else
	return symbol_relc_make_sym (exp->X_add_symbol);

      /* Helper macros for nesting nodes.  */

#define HANDLE_XADD_OPT1(str_) 						\
      if (exp->X_add_number)						\
        {								\
          arity = 2;							\
          opstr = "+:" str_;						\
          operands[0] = symbol_relc_make_sym (exp->X_add_symbol);	\
          operands[1] = symbol_relc_make_value (exp->X_add_number);	\
          break;							\
        }								\
      else								\
        {								\
          arity = 1;							\
          opstr = str_;							\
          operands[0] = symbol_relc_make_sym (exp->X_add_symbol);	\
        }								\
      break

#define HANDLE_XADD_OPT2(str_) 						\
      if (exp->X_add_number)						\
        {								\
          arity = 3;							\
          opstr = "+:" str_;						\
          operands[0] = symbol_relc_make_sym (exp->X_add_symbol);	\
          operands[1] = symbol_relc_make_sym (exp->X_op_symbol);	\
          operands[2] = symbol_relc_make_value (exp->X_add_number);	\
        }								\
      else								\
        {								\
          arity = 2;							\
          opstr = str_;							\
          operands[0] = symbol_relc_make_sym (exp->X_add_symbol);	\
          operands[1] = symbol_relc_make_sym (exp->X_op_symbol);	\
        } 								\
      break

      /* Nesting nodes.  */

    case O_uminus:       	HANDLE_XADD_OPT1 ("0-");
    case O_bit_not:      	HANDLE_XADD_OPT1 ("~");
    case O_logical_not:  	HANDLE_XADD_OPT1 ("!");
    case O_multiply:     	HANDLE_XADD_OPT2 ("*");
    case O_divide:       	HANDLE_XADD_OPT2 ("/");
    case O_modulus:      	HANDLE_XADD_OPT2 ("%");
    case O_left_shift:   	HANDLE_XADD_OPT2 ("<<");
    case O_right_shift:  	HANDLE_XADD_OPT2 (">>");
    case O_bit_inclusive_or:	HANDLE_XADD_OPT2 ("|");
    case O_bit_exclusive_or:	HANDLE_XADD_OPT2 ("^");
    case O_bit_and:      	HANDLE_XADD_OPT2 ("&");
    case O_add:          	HANDLE_XADD_OPT2 ("+");
    case O_subtract:     	HANDLE_XADD_OPT2 ("-");
    case O_eq:           	HANDLE_XADD_OPT2 ("==");
    case O_ne:           	HANDLE_XADD_OPT2 ("!=");
    case O_lt:           	HANDLE_XADD_OPT2 ("<");
    case O_le:           	HANDLE_XADD_OPT2 ("<=");
    case O_ge:           	HANDLE_XADD_OPT2 (">=");
    case O_gt:           	HANDLE_XADD_OPT2 (">");
    case O_logical_and:  	HANDLE_XADD_OPT2 ("&&");
    case O_logical_or:   	HANDLE_XADD_OPT2 ("||");
    }

  /* Validate & reject early.  */
  if (arity >= 1 && ((operands[0] == NULL) || (strlen (operands[0]) == 0)))
    opstr = NULL;
  if (arity >= 2 && ((operands[1] == NULL) || (strlen (operands[1]) == 0)))
    opstr = NULL;
  if (arity >= 3 && ((operands[2] == NULL) || (strlen (operands[2]) == 0)))
    opstr = NULL;

  if (opstr == NULL)
    concat_string = NULL;
  else
    {
      /* Allocate new string; include inter-operand padding gaps etc.  */
      concat_string = xmalloc (strlen (opstr)
			       + 1
			       + (arity >= 1 ? (strlen (operands[0]) + 1 ) : 0)
			       + (arity >= 2 ? (strlen (operands[1]) + 1 ) : 0)
			       + (arity >= 3 ? (strlen (operands[2]) + 0 ) : 0)
			       + 1);
      gas_assert (concat_string != NULL);

      /* Format the thing.  */
      sprintf (concat_string,
	       (arity == 0 ? "%s" :
		arity == 1 ? "%s:%s" :
		arity == 2 ? "%s:%s:%s" :
		/* arity == 3 */ "%s:%s:%s:%s"),
	       opstr, operands[0], operands[1], operands[2]);
    }

  /* Free operand strings (not opstr).  */
  if (arity >= 1) xfree (operands[0]);
  if (arity >= 2) xfree (operands[1]);
  if (arity >= 3) xfree (operands[2]);

  return concat_string;
}

#endif
@


1.118
log
@Remove trailing white spaces on gas

	* app.c: Remove trailing white spaces.
	* as.c: Likewise.
	* as.h: Likewise.
	* cond.c: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.h: Likewise.
	* ecoff.c: Likewise.
	* input-file.c: Likewise.
	* itbl-lex.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* sb.c: Likewise.
	* subsegs.c: Likewise.
	* symbols.c: Likewise.
	* write.c: Likewise.
	* config/tc-i386.c: Likewise.
	* doc/Makefile.am: Likewise.
	* doc/Makefile.in: Likewise.
	* doc/c-aarch64.texi: Likewise.
	* doc/c-alpha.texi: Likewise.
	* doc/c-arc.texi: Likewise.
	* doc/c-arm.texi: Likewise.
	* doc/c-avr.texi: Likewise.
	* doc/c-bfin.texi: Likewise.
	* doc/c-cr16.texi: Likewise.
	* doc/c-d10v.texi: Likewise.
	* doc/c-d30v.texi: Likewise.
	* doc/c-h8300.texi: Likewise.
	* doc/c-hppa.texi: Likewise.
	* doc/c-i370.texi: Likewise.
	* doc/c-i386.texi: Likewise.
	* doc/c-i860.texi: Likewise.
	* doc/c-m32c.texi: Likewise.
	* doc/c-m32r.texi: Likewise.
	* doc/c-m68hc11.texi: Likewise.
	* doc/c-m68k.texi: Likewise.
	* doc/c-microblaze.texi: Likewise.
	* doc/c-mips.texi: Likewise.
	* doc/c-msp430.texi: Likewise.
	* doc/c-mt.texi: Likewise.
	* doc/c-s390.texi: Likewise.
	* doc/c-score.texi: Likewise.
	* doc/c-sh.texi: Likewise.
	* doc/c-sh64.texi: Likewise.
	* doc/c-tic54x.texi: Likewise.
	* doc/c-tic6x.texi: Likewise.
	* doc/c-v850.texi: Likewise.
	* doc/c-xc16x.texi: Likewise.
	* doc/c-xgate.texi: Likewise.
	* doc/c-xtensa.texi: Likewise.
	* doc/c-z80.texi: Likewise.
	* doc/internals.texi: Likewise.
@
text
@d1752 1
a1752 1
  if (label < FB_LABEL_SPECIAL)
d1800 1
a1800 1
  if (label < FB_LABEL_SPECIAL)
@


1.117
log
@Remove trailing redundant `;'

bfd/

	* aout-tic30.c (MY_final_link_callback): Remove trailing
	redundant `;'.
	* coff-h8500.c (extra_case): Likewise.
	(bfd_coff_reloc16_get_value): Likewise.
	* dwarf2.c (_bfd_dwarf2_cleanup_debug_info): Likewise.
	* elf.c (_bfd_elf_slurp_version_tables): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_perform_relocation): Likewise.
	* opncls.c (bfd_calc_gnu_debuglink_crc32): Likewise.
	* plugin.c (add_symbols): Likewise.
	* reloc.c (bfd_check_overflow): Likewise.
	* vms-lib.c (_bfd_vms_lib_archive_p): Likewise.

binutils/

	* coffgrok.c (coff_grok): Remove trailing redundant `;'.
	* resrc.c (open_input_stream): Likewise.

gas/

	* config/atof-ieee.c (gen_to_words): Remove trailing redundant
	`;'.
	* config/atof-vax.c (flonum_gen2vax): Likewise.
	* config/tc-d10v.c (write_2_short): Likewise.
	* config/tc-i386-intel.c (i386_intel_simplify): Likewise.
	* config/tc-s390.c (tc_s390_force_relocation): Likewise.
	* config/tc-v850.c (md_parse_option): Likewise.
	* config/tc-xtensa.c (find_address_of_next_align_frag): Likewise.
	* dwarf2dbg.c (out_header): Likewise.
	* symbols.c (dollar_label_name): Likewise.
	(fb_label_name): Likewise.

ld/

	* testplug.c (record_add_file): Remove trailing redundant `;'.

opcodes/

	* aarch64-opc.h (gen_mask): Remove trailing redundant `;'.
	* ia64-gen.c (fetch_insn_class): Likewise.
@
text
@d956 1
a956 1
	  && 
d966 1
a966 1
      
d1120 1
a1120 1
	    relc_symbol->bsym->flags |= BSF_RELC;	  
d3123 1
a3123 1
     through to construct subexpression fragments; may instead return 
d3126 1
a3126 1
  /* See expr.h for the meaning of all these enums.  Many operators 
d3141 4
a3144 4
      if (exp->X_add_number) 
	{ 
	  arity = 2; 
	  opstr = "+"; 
d3170 1
a3170 1
      
d3227 1
a3227 1
      concat_string = xmalloc (strlen (opstr) 
d3234 1
a3234 1
      
d3236 1
a3236 1
      sprintf (concat_string, 
@


1.116
log
@Replace all uses of bfd_abs_section, bfd_com_section, bfd_und_section
and bfd_ind_section with their _ptr variants, or use corresponding
bfd_is_* macros.
@
text
@d1705 1
a1705 1
  while ((*p++ = *--q) != '\0');;
d1876 1
a1876 1
  while ((*p++ = *--q) != '\0');;
@


1.115
log
@
2012-02-21  Tristan Gingold  <gingold@@adacore.com>

	* config/tc-i386.h (OBJ_MACH_O): New section.
	(TC_FORCE_RELOCATION): Use obj_mach_o_force_reloc.
	(TC_FORCE_RELOCATION_SUB_SAME): New
	(TC_FORCE_RELOCATION_SUB_LOCAL): New.
	(TC_VALIDATE_FIX_SUB): New.
	* frags.h (struct frag): OBJ_FRAG_TYPE, new field.
	* symbols.c (colon): obj_frob_colon: New hook.
	* write.c (write_object_file): md_pre_relax_hook, new
	hook.
	* config/obj-macho.c (obj_mach_o_frob_colon): New.
	(obj_mach_o_frob_label): Record sub-section labels.
	(obj_mach_o_frob_symbol): Rename from obj_macho_frob_symbol.
	(obj_mach_o_set_subsections): New.
	(obj_mach_o_pre_relax_hook): New.
	(obj_mach_o_in_different_subsection): New.
	(obj_mach_o_force_reloc_sub_same): New.
	(obj_mach_o_force_reloc_sub_local): New.
	(obj_mach_o_force_reloc): New.
	* config/obj-macho.h (OBJ_SYMFIELD_TYPE): New.
	(obj_frob_colon): New Define.
	(obj_mach_o_frob_label): Renamed.
	(obj_mach_o_frob_symbol): Renamed.
	(OBJ_FRAG_TYPE): New.
	(obj_mach_o_in_different_subsection, obj_mach_o_force_reloc,
	 obj_mach_o_force_reloc_sub_same,
	 obj_mach_o_force_reloc_sub_local): New declarations.
@
text
@d4 1
a4 1
   2011 Free Software Foundation, Inc.
d2781 1
a2781 1
  abs_symbol.bsym = bfd_abs_section.symbol;
@


1.114
log
@2012-01-10  Tristan Gingold  <gingold@@adacore.com>

	* struc-symbol.h (struct symbol_flags): New struct, created from...
	(struct symbol): ... this one.  Add sy_flags field, remove flag fields.
	(struct local_symbol): Replace lsy_marker field by lsy_flags.
	Adjust comment.
	(local_symbol_resolved_p): Adjust.
	(local_symbol_mark_resolved): Likewise.
	* symbols.c (LOCAL_SYMBOL_CHECK): Adjust.
	(local_symbol_make, local_symbol_convert, colon)
	(symbol_clone_if_forward_ref, verify_symbol_chain)
	(resolve_symbol_value, snapshot_symbol, S_GET_VALUE)
	(S_IS_WEAKREFR, S_IS_WEAKREFD, S_IS_VOLATILE, S_IS_FORWARD_REF)
	(S_SET_WEAKREFR, S_CLEAR_WEAKREFR, S_SET_WEAKREFD)
	(S_CLEAR_WEAKREFD, S_SET_VOLATILE, S_CLEAR_VOLATILE)
	(S_SET_FORWARD_REF, symbol_same_p, symbol_mark_used)
	(symbol_clear_used, symbol_used_p, symbol_mark_used_in_reloc)
	(symbol_clear_used_in_reloc, symbol_used_in_reloc_p)
	(symbol_mark_mri_common, symbol_clear_mri_common)
	(symbol_mri_common_p, symbol_mark_written, symbol_clear_written)
	(symbol_written_p, symbol_mark_resolved, symbol_resolved_p)
	(symbol_equated_reloc_p, dot_symbol_init)
	(print_symbol_value_1): Adjust.
@
text
@d320 4
@


1.113
log
@	* as.c (main): Define .gasversion. rather than __GAS_VERSION__.
	* frags.h (bss_address_frag): Delete
	(predefined_address_frag): New.
	* frags.c (frag_init): Init predefined_address_frag.  Delete ref
	to bss_addres_frag.
	* symbols.c (S_CAN_BE_REDEFINED): New function.
	* symbols.h (S_CAN_BE_REDEFINED): Declare.
	* read.c (assign_symbol): Use S_CAN_BE_REDEFINED.
@
text
@d183 1
a183 1
  (s->bsym == NULL							\
d203 2
a204 1
  ret->lsy_marker = NULL;
d223 1
a223 1
  gas_assert (locsym->lsy_marker == NULL);
d233 1
a233 1
    ret->sy_resolved = 1;
d236 1
a236 1
  ret->sy_used = 1;
d465 1
a465 1
      symbolP->sy_mri_common = 1;
d632 1
a632 1
      if (symbolP->sy_forward_ref)
d648 3
a650 2
      if ((symbolP->bsym->section == expr_section || symbolP->sy_forward_ref)
	  && !symbolP->sy_resolving)
d652 1
a652 1
	  symbolP->sy_resolving = 1;
d655 1
a655 1
	  symbolP->sy_resolving = 0;
d658 1
a658 1
      if (symbolP->sy_forward_ref
d665 1
a665 1
	      symbolP->sy_resolving = 0;
d900 1
d1063 1
a1063 1
  if (symp->sy_resolved)
d1074 1
a1074 1
  if (symp->sy_resolving)
d1137 1
a1137 1
      symp->sy_resolving = 1;
d1186 1
a1186 1
	  if (symp->sy_mri_common)
d1226 1
a1226 1
	      symp->sy_resolving = 0;
d1245 1
a1245 1
	      symp->sy_resolving = 0;
d1449 1
a1449 1
      symp->sy_resolving = 0;
d1464 1
a1464 1
	symp->sy_resolved = 1;
d1469 1
a1469 1
	  symp->sy_resolved = 1;
d1515 1
a1515 1
      if (!symbolP->sy_resolved && exp.X_op != O_illegal)
d1519 1
a1519 1
	  if (symbolP->sy_resolving)
d1521 1
a1521 1
	  symbolP->sy_resolving = 1;
d1523 1
a1523 1
	  symbolP->sy_resolving = 0;
d1929 1
a1929 1
  if (!s->sy_resolved)
d1940 1
a1940 1
      if (! s->sy_resolved
d2038 1
a2038 1
  return s->sy_weakrefr != 0;
d2046 1
a2046 1
  return s->sy_weakrefd != 0;
d2157 1
a2157 1
  return s->sy_volatile;
d2165 1
a2165 1
  return s->sy_forward_ref;
d2280 1
a2280 1
  s->sy_weakrefr = 1;
d2287 1
a2287 1
  if (s->sy_used)
d2296 1
a2296 1
  s->sy_weakrefr = 0;
d2304 1
a2304 1
  s->sy_weakrefd = 1;
d2313 1
a2313 1
  if (s->sy_weakrefd)
d2315 1
a2315 1
      s->sy_weakrefd = 0;
d2366 1
a2366 1
  s->sy_volatile = 1;
d2373 1
a2373 1
    s->sy_volatile = 0;
d2381 1
a2381 1
  s->sy_forward_ref = 1;
d2430 1
a2430 1
  if (s1->bsym == NULL
d2433 1
a2433 1
  if (s2->bsym == NULL
d2491 1
a2491 1
  s->sy_used = 1;
d2503 1
a2503 1
  s->sy_used = 0;
d2513 1
a2513 1
  return s->sy_used;
d2523 1
a2523 1
  s->sy_used_in_reloc = 1;
d2533 1
a2533 1
  s->sy_used_in_reloc = 0;
d2543 1
a2543 1
  return s->sy_used_in_reloc;
d2553 1
a2553 1
  s->sy_mri_common = 1;
d2563 1
a2563 1
  s->sy_mri_common = 0;
d2573 1
a2573 1
  return s->sy_mri_common;
d2583 1
a2583 1
  s->written = 1;
d2593 1
a2593 1
  s->written = 0;
d2603 1
a2603 1
  return s->written;
d2616 1
a2616 1
  s->sy_resolved = 1;
d2626 1
a2626 1
  return s->sy_resolved;
d2664 1
a2664 1
	  && ((s->sy_resolved && s->sy_value.X_op_symbol != NULL)
d2793 1
a2793 1
  dot_symbol.sy_forward_ref = 1;
d2834 1
a2834 1
      if (sym->written)
d2836 1
a2836 1
      if (sym->sy_resolved)
d2838 1
a2838 1
      else if (sym->sy_resolving)
d2840 1
a2840 1
      if (sym->sy_used_in_reloc)
d2842 1
a2842 1
      if (sym->sy_used)
@


1.112
log
@	* symbols.c (local_symbol_make): Make global.
	* symbols.h (local_symbol_make): Declare.
	* as.c (main): Define __GAS_VERSION__.
@
text
@d2140 10
@


1.111
log
@bfd/
2011-02-25  Chao-ying Fu  <fu@@mips.com>
            Ilie Garbacea  <ilie@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>
            Catherine Moore  <clm@@codesourcery.com>
	    Richard Sandiford  <rdsandiford@@googlemail.com>

	* archures.c (bfd_mach_mips_micromips): New macro.
	* cpu-mips.c (I_micromips): New enum value.
	(arch_info_struct): Add bfd_mach_mips_micromips.
	* elfxx-mips.h (_bfd_mips_elf_is_target_special_symbol): New
	prototype.
	(_bfd_mips_elf_relax_section): Likewise.
	(_bfd_mips16_elf_reloc_unshuffle): Rename to...
	(_bfd_mips_elf_reloc_unshuffle): ... this.  Handle microMIPS
	ASE.
	(_bfd_mips16_elf_reloc_shuffle): Rename to...
	(_bfd_mips_elf_reloc_shuffle): ... this.  Handle microMIPS ASE.
	(gprel16_reloc_p): Handle microMIPS ASE.
	(literal_reloc_p): New function.
	* elf32-mips.c (elf_micromips_howto_table_rel): New variable.
	(_bfd_mips_elf32_gprel16_reloc): Handle microMIPS ASE.
	(mips16_gprel_reloc): Update for _bfd_mips_elf_reloc_unshuffle
	and _bfd_mips_elf_reloc_shuffle changes.
	(mips_elf_gprel32_reloc): Update comment.
	(micromips_reloc_map): New variable.
	(bfd_elf32_bfd_reloc_type_lookup): Handle microMIPS ASE.
	(mips_elf32_rtype_to_howto): Likewise.
	(mips_info_to_howto_rel): Likewise.
	(bfd_elf32_bfd_is_target_special_symbol): Define.
	(bfd_elf32_bfd_relax_section): Likewise.
	* elf64-mips.c (micromips_elf64_howto_table_rel): New variable.
	(micromips_elf64_howto_table_rela): Likewise.
	(mips16_gprel_reloc): Update for _bfd_mips_elf_reloc_unshuffle
	and _bfd_mips_elf_reloc_shuffle changes.
	(micromips_reloc_map): Likewise.
	(bfd_elf64_bfd_reloc_type_lookup): Handle microMIPS ASE.
	(bfd_elf64_bfd_reloc_name_lookup): Likewise.
	(mips_elf64_rtype_to_howto): Likewise.
	(bfd_elf64_bfd_is_target_special_symbol): Define.
	* elfn32-mips.c (elf_micromips_howto_table_rel): New variable.
	(elf_micromips_howto_table_rela): Likewise.
	(mips16_gprel_reloc): Update for _bfd_mips_elf_reloc_unshuffle
	and _bfd_mips_elf_reloc_shuffle changes.
	(micromips_reloc_map): Likewise.
	(bfd_elf32_bfd_reloc_type_lookup): Handle microMIPS ASE.
	(bfd_elf32_bfd_reloc_name_lookup): Likewise.
	(mips_elf_n32_rtype_to_howto): Likewise.
	(bfd_elf32_bfd_is_target_special_symbol): Define.
	* elfxx-mips.c (LA25_LUI_MICROMIPS_1): New macro.
	(LA25_LUI_MICROMIPS_2): Likewise.
	(LA25_J_MICROMIPS_1, LA25_J_MICROMIPS_2): Likewise.
	(LA25_ADDIU_MICROMIPS_1, LA25_ADDIU_MICROMIPS_2): Likewise.
	(TLS_RELOC_P): Handle microMIPS ASE.
	(mips_elf_create_stub_symbol): Adjust value of stub symbol if
	target is a microMIPS function.
	(micromips_reloc_p): New function.
	(micromips_reloc_shuffle_p): Likewise.
	(got16_reloc_p, call16_reloc_p): Handle microMIPS ASE.
	(got_disp_reloc_p, got_page_reloc_p): New functions.
	(got_ofst_reloc_p): Likewise.
	(got_hi16_reloc_p, got_lo16_reloc_p): Likewise.
	(call_hi16_reloc_p, call_lo16_reloc_p): Likewise.
	(hi16_reloc_p, lo16_reloc_p, jal_reloc_p): Handle microMIPS ASE.
	(micromips_branch_reloc_p): New function.
	(tls_gd_reloc_p, tls_ldm_reloc_p): Likewise.
	(tls_gottprel_reloc_p): Likewise.
	(_bfd_mips16_elf_reloc_unshuffle): Rename to...
	(_bfd_mips_elf_reloc_unshuffle): ... this.  Handle microMIPS
	ASE.
	(_bfd_mips16_elf_reloc_shuffle): Rename to...
	(_bfd_mips_elf_reloc_shuffle): ... this.  Handle microMIPS ASE.
	(_bfd_mips_elf_lo16_reloc): Handle microMIPS ASE.
	(mips_tls_got_index, mips_elf_got_page): Likewise.
	(mips_elf_create_local_got_entry): Likewise.
	(mips_elf_relocation_needs_la25_stub): Likewise.
	(mips_elf_calculate_relocation): Likewise.
	(mips_elf_perform_relocation): Likewise.
	(_bfd_mips_elf_symbol_processing): Likewise.
	(_bfd_mips_elf_add_symbol_hook): Likewise.
	(_bfd_mips_elf_link_output_symbol_hook): Likewise.
	(mips_elf_add_lo16_rel_addend): Likewise.
	(_bfd_mips_elf_check_relocs): Likewise.
	(mips_elf_adjust_addend): Likewise.
	(_bfd_mips_elf_relocate_section): Likewise.
	(mips_elf_create_la25_stub): Likewise.
	(_bfd_mips_vxworks_finish_dynamic_symbol): Likewise.
	(_bfd_mips_elf_gc_sweep_hook): Likewise.
	(_bfd_mips_elf_is_target_special_symbol): New function.
	(mips_elf_relax_delete_bytes): Likewise.
	(opcode_descriptor): New structure.
	(RA): New macro.
	(OP32_SREG, OP32_TREG, OP16_VALID_REG): Likewise.
	(b_insns_32, bc_insn_32, bz_insn_32, bzal_insn_32): New variables.
	(beq_insn_32): Likewise.
	(b_insn_16, bz_insn_16): New variables.
	(BZC32_REG_FIELD): New macro.
	(bz_rs_insns_32, bz_rt_insns_32): New variables.
	(bzc_insns_32, bz_insns_16):Likewise.
	(BZ16_REG, BZ16_REG_FIELD): New macros.
	(jal_insn_32_bd16, jal_insn_32_bd32): New variables.
	(jal_x_insn_32_bd32): Likewise.
	(j_insn_32, jalr_insn_32): Likewise.
	(ds_insns_32_bd16, ds_insns_32_bd32): Likewise.
	(jalr_insn_16_bd16, jalr_insn_16_bd32, jr_insn_16): Likewise.
	(JR16_REG): New macro.
	(ds_insns_16_bd16): New variable.
	(lui_insn): Likewise.
	(addiu_insn, addiupc_insn): Likewise.
	(ADDIUPC_REG_FIELD): New macro.
	(MOVE32_RD, MOVE32_RS): Likewise.
	(MOVE16_RD_FIELD, MOVE16_RS_FIELD): Likewise.
	(move_insns_32, move_insns_16): New variables.
	(nop_insn_32, nop_insn_16): Likewise.
	(MATCH): New macro.
	(find_match): New function.
	(check_br16_dslot, check_br32_dslot): Likewise.
	(check_br16, check_br32): Likewise.
	(IS_BITSIZE): New macro.
	(check_4byte_branch): New function.
	(_bfd_mips_elf_relax_section): Likewise.
	(_bfd_mips_elf_merge_private_bfd_data): Disallow linking MIPS16
	and microMIPS modules together.
	(_bfd_mips_elf_print_private_bfd_data):	Handle microMIPS ASE.
	* reloc.c (BFD_RELOC_MICROMIPS_7_PCREL_S1): New relocation.
	(BFD_RELOC_MICROMIPS_10_PCREL_S1): Likewise.
	(BFD_RELOC_MICROMIPS_16_PCREL_S1): Likewise.
	(BFD_RELOC_MICROMIPS_GPREL16): Likewise.
	(BFD_RELOC_MICROMIPS_JMP, BFD_RELOC_MICROMIPS_HI16): Likewise.
	(BFD_RELOC_MICROMIPS_HI16_S): Likewise.
	(BFD_RELOC_MICROMIPS_LO16): Likewise.
	(BFD_RELOC_MICROMIPS_LITERAL): Likewise.
	(BFD_RELOC_MICROMIPS_GOT16): Likewise.
	(BFD_RELOC_MICROMIPS_CALL16): Likewise.
	(BFD_RELOC_MICROMIPS_GOT_HI16): Likewise.
	(BFD_RELOC_MICROMIPS_GOT_LO16): Likewise.
	(BFD_RELOC_MICROMIPS_CALL_HI16): Likewise.
	(BFD_RELOC_MICROMIPS_CALL_LO16): Likewise.
	(BFD_RELOC_MICROMIPS_SUB): Likewise.
	(BFD_RELOC_MICROMIPS_GOT_PAGE): Likewise.
	(BFD_RELOC_MICROMIPS_GOT_OFST): Likewise.
	(BFD_RELOC_MICROMIPS_GOT_DISP): Likewise.
	(BFD_RELOC_MICROMIPS_HIGHEST): Likewise.
	(BFD_RELOC_MICROMIPS_HIGHER): Likewise.
	(BFD_RELOC_MICROMIPS_SCN_DISP): Likewise.
	(BFD_RELOC_MICROMIPS_JALR): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_GD): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_LDM): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_DTPREL_HI16): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_DTPREL_LO16): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_GOTTPREL): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_TPREL_HI16): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_TPREL_LO16): Likewise.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

binutils/
2011-02-25  Chao-ying Fu  <fu@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* readelf.c (get_machine_flags): Handle microMIPS ASE.
	(get_mips_symbol_other): Likewise.

gas/
2011-02-25  Maciej W. Rozycki  <macro@@codesourcery.com>
            Chao-ying Fu  <fu@@mips.com>
	    Richard Sandiford  <rdsandiford@@googlemail.com>

	* config/tc-mips.h (mips_segment_info): Add one bit for
	microMIPS.
	(TC_LABEL_IS_LOCAL): New macro.
	(mips_label_is_local): New prototype.
	* config/tc-mips.c (S0, S7): New macros.
	(emit_branch_likely_macro): New variable.
	(mips_set_options): Add micromips.
	(mips_opts): Initialise micromips to -1.
	(file_ase_micromips): New variable.
	(CPU_HAS_MICROMIPS): New macro.
	(hilo_interlocks): Set for microMIPS too.
	(gpr_interlocks): Likewise.
	(cop_interlocks): Likewise.
	(cop_mem_interlocks): Likewise.
	(HAVE_CODE_COMPRESSION): New macro.
	(micromips_op_hash): New variable.
	(micromips_nop16_insn, micromips_nop32_insn): New variables.
	(NOP_INSN): Handle microMIPS ASE.
	(mips32_to_micromips_reg_b_map): New macro.
	(mips32_to_micromips_reg_c_map): Likewise.
	(mips32_to_micromips_reg_d_map): Likewise.
	(mips32_to_micromips_reg_e_map): Likewise.
	(mips32_to_micromips_reg_f_map): Likewise.
	(mips32_to_micromips_reg_g_map): Likewise.
	(mips32_to_micromips_reg_l_map): Likewise.
	(mips32_to_micromips_reg_n_map): Likewise.
	(mips32_to_micromips_reg_h_map): New variable.
	(mips32_to_micromips_reg_m_map): Likewise.
	(mips32_to_micromips_reg_q_map): Likewise.
	(micromips_to_32_reg_h_map): New variable.
	(micromips_to_32_reg_i_map): Likewise.
	(micromips_to_32_reg_m_map): Likewise.
	(micromips_to_32_reg_q_map): Likewise.
	(micromips_to_32_reg_b_map): New macro.
	(micromips_to_32_reg_c_map): Likewise.
	(micromips_to_32_reg_d_map): Likewise.
	(micromips_to_32_reg_e_map): Likewise.
	(micromips_to_32_reg_f_map): Likewise.
	(micromips_to_32_reg_g_map): Likewise.
	(micromips_to_32_reg_l_map): Likewise.
	(micromips_to_32_reg_n_map): Likewise.
	(micromips_imm_b_map, micromips_imm_c_map): New macros.
	(RELAX_DELAY_SLOT_16BIT): New macro.
	(RELAX_DELAY_SLOT_SIZE_FIRST): Likewise.
	(RELAX_DELAY_SLOT_SIZE_SECOND): Likewise.
	(RELAX_MICROMIPS_ENCODE, RELAX_MICROMIPS_P): New macros.
	(RELAX_MICROMIPS_TYPE, RELAX_MICROMIPS_AT): Likewise.
	(RELAX_MICROMIPS_U16BIT, RELAX_MICROMIPS_UNCOND): Likewise.
	(RELAX_MICROMIPS_COMPACT, RELAX_MICROMIPS_LINK): Likewise.
	(RELAX_MICROMIPS_RELAX32, RELAX_MICROMIPS_TOOFAR16): Likewise.
	(RELAX_MICROMIPS_MARK_TOOFAR16): Likewise.
	(RELAX_MICROMIPS_CLEAR_TOOFAR16): Likewise.
	(RELAX_MICROMIPS_TOOFAR32): Likewise.
	(RELAX_MICROMIPS_MARK_TOOFAR32): Likewise.
	(RELAX_MICROMIPS_CLEAR_TOOFAR32): Likewise.
	(INSERT_OPERAND, EXTRACT_OPERAND): Handle microMIPS ASE.
	(mips_macro_warning): Add delay_slot_16bit_p, delay_slot_32bit_p,
	fsize and insns.
	(mips_mark_labels): New function.
	(mips16_small, mips16_ext): Remove variables, replacing with...
	(forced_insn_size): ... this.
	(append_insn, mips16_ip): Update accordingly.
	(micromips_insn_length): New function.
	(insn_length): Return the length of microMIPS instructions.
	(mips_record_mips16_mode): Rename to...
	(mips_record_compressed_mode): ... this.  Handle microMIPS ASE.
	(install_insn): Handle microMIPS ASE.
	(reglist_lookup): New function.
	(is_size_valid, is_delay_slot_valid): Likewise.
	(md_begin): Handle microMIPS ASE.
	(md_assemble): Likewise.  Update for append_insn interface change.
	(micromips_reloc_p): New function.
	(got16_reloc_p): Handle microMIPS ASE.
	(hi16_reloc_p): Likewise.
	(lo16_reloc_p): Likewise.
	(jmp_reloc_p): New function.
	(jalr_reloc_p): Likewise.
	(matching_lo_reloc): Handle microMIPS ASE.
	(insn_uses_reg, reg_needs_delay): Likewise.
	(mips_move_labels): Likewise.
	(mips16_mark_labels): Rename to...
	(mips_compressed_mark_labels): ... this.  Handle microMIPS ASE.
	(gpr_mod_mask): New function.
	(gpr_read_mask, gpr_write_mask): Handle microMIPS ASE.
	(fpr_read_mask, fpr_write_mask): Likewise.
	(insns_between, nops_for_vr4130, nops_for_insn): Likewise.
	(fix_loongson2f_nop, fix_loongson2f_jump): Likewise.
	(MICROMIPS_LABEL_CHAR): New macro.
	(micromips_target_label, micromips_target_name): New variables.
	(micromips_label_name, micromips_label_expr): New functions.
	(micromips_label_inc, micromips_add_label): Likewise.
	(mips_label_is_local): Likewise.
	(micromips_map_reloc): Likewise.
	(can_swap_branch_p): Handle microMIPS ASE.
	(append_insn): Add expansionp argument.  Handle microMIPS ASE.
	(start_noreorder, end_noreorder): Handle microMIPS ASE.
	(macro_start, macro_warning, macro_end): Likewise.
	(brk_fmt, cop12_fmt, jalr_fmt, lui_fmt): New variables.
	(mem12_fmt, mfhl_fmt, shft_fmt, trap_fmt): Likewise.
	(BRK_FMT, COP12_FMT, JALR_FMT, LUI_FMT): New macros.
	(MEM12_FMT, MFHL_FMT, SHFT_FMT, TRAP_FMT): Likewise.
	(macro_build): Handle microMIPS ASE.  Update for append_insn
	interface change.
	(mips16_macro_build): Update for append_insn interface change.
	(macro_build_jalr): Handle microMIPS ASE.
	(macro_build_lui): Likewise.  Simplify.
	(load_register): Handle microMIPS ASE.
	(load_address): Likewise.
	(move_register): Likewise.
	(macro_build_branch_likely): New function.
	(macro_build_branch_ccl): Likewise.
	(macro_build_branch_rs): Likewise.
	(macro_build_branch_rsrt): Likewise.
	(macro): Handle microMIPS ASE.
	(validate_micromips_insn): New function.
	(expr_const_in_range): Likewise.
	(mips_ip): Handle microMIPS ASE.
	(options): Add OPTION_MICROMIPS and OPTION_NO_MICROMIPS.
	(md_longopts): Add mmicromips and mno-micromips.
	(md_parse_option): Handle OPTION_MICROMIPS and
	OPTION_NO_MICROMIPS.
	(mips_after_parse_args): Handle microMIPS ASE.
	(md_pcrel_from): Handle microMIPS relocations.
	(mips_force_relocation): Likewise.
	(md_apply_fix): Likewise.
	(mips_align): Handle microMIPS ASE.
	(s_mipsset): Likewise.
	(s_cpload, s_cpsetup, s_cpreturn): Use relocation wrappers.
	(s_dtprel_internal): Likewise.
	(s_gpword, s_gpdword): Likewise.
	(s_insn): Handle microMIPS ASE.
	(s_mips_stab): Likewise.
	(relaxed_micromips_32bit_branch_length): New function.
	(relaxed_micromips_16bit_branch_length): New function.
	(md_estimate_size_before_relax): Handle microMIPS ASE.
	(mips_fix_adjustable): Likewise.
	(tc_gen_reloc): Handle microMIPS relocations.
	(mips_relax_frag): Handle microMIPS ASE.
	(md_convert_frag): Likewise.
	(mips_frob_file_after_relocs): Likewise.
	(mips_elf_final_processing): Likewise.
	(mips_nop_opcode): Likewise.
	(mips_handle_align): Likewise.
	(md_show_usage): Handle microMIPS options.
	* symbols.c (TC_LABEL_IS_LOCAL): New macro.
	(S_IS_LOCAL): Add a TC_LABEL_IS_LOCAL check.

	* doc/as.texinfo (Target MIPS options): Add -mmicromips and
	-mno-micromips.
	(-mmicromips, -mno-micromips): New options.
	* doc/c-mips.texi (-mmicromips, -mno-micromips): New options.
	(MIPS ISA): Document .set micromips and .set nomicromips.
	(MIPS insn): Update for microMIPS support.

gas/testsuite/
2011-02-25  Maciej W. Rozycki  <macro@@codesourcery.com>
            Chao-ying Fu  <fu@@mips.com>
	    Richard Sandiford  <rdsandiford@@googlemail.com>

	* gas/mips/micromips.d: New test.
	* gas/mips/micromips-branch-delay.d: Likewise.
	* gas/mips/micromips-branch-relax.d: Likewise.
	* gas/mips/micromips-branch-relax-pic.d: Likewise.
	* gas/mips/micromips-size-1.d: Likewise.
	* gas/mips/micromips-trap.d: Likewise.
	* gas/mips/micromips.l: New stderr output.
	* gas/mips/micromips-branch-delay.l: Likewise.
	* gas/mips/micromips-branch-relax.l: Likewise.
	* gas/mips/micromips-branch-relax-pic.l: Likewise.
	* gas/mips/micromips-size-0.l: New list test.
	* gas/mips/micromips-size-1.l: New stderr output.
	* gas/mips/micromips.s: New test source.
	* gas/mips/micromips-branch-delay.s: Likewise.
	* gas/mips/micromips-branch-relax.s: Likewise.
	* gas/mips/micromips-size-0.s: Likewise.
	* gas/mips/micromips-size-1.s: Likewise.
	* gas/mips/mips.exp: Run the new tests.

	* gas/mips/dli.s: Use .p2align.
	* gas/mips/elf_ase_micromips.d: New test.
	* gas/mips/elf_ase_micromips-2.d: Likewise.
	* gas/mips/micromips@@abs.d: Likewise.
	* gas/mips/micromips@@add.d: Likewise.
	* gas/mips/micromips@@alnv_ps-swap.d: Likewise.
	* gas/mips/micromips@@and.d: Likewise.
	* gas/mips/micromips@@beq.d: Likewise.
	* gas/mips/micromips@@bge.d: Likewise.
	* gas/mips/micromips@@bgeu.d: Likewise.
	* gas/mips/micromips@@blt.d: Likewise.
	* gas/mips/micromips@@bltu.d: Likewise.
	* gas/mips/micromips@@branch-likely.d: Likewise.
	* gas/mips/micromips@@branch-misc-1.d: Likewise.
	* gas/mips/micromips@@branch-misc-2-64.d: Likewise.
	* gas/mips/micromips@@branch-misc-2.d: Likewise.
	* gas/mips/micromips@@branch-misc-2pic-64.d: Likewise.
	* gas/mips/micromips@@branch-misc-2pic.d: Likewise.
	* gas/mips/micromips@@branch-misc-4-64.d: Likewise.
	* gas/mips/micromips@@branch-misc-4.d: Likewise.
	* gas/mips/micromips@@branch-self.d: Likewise.
	* gas/mips/micromips@@cache.d: Likewise.
	* gas/mips/micromips@@daddi.d: Likewise.
	* gas/mips/micromips@@dli.d: Likewise.
	* gas/mips/micromips@@elf-jal.d: Likewise.
	* gas/mips/micromips@@elf-rel2.d: Likewise.
	* gas/mips/micromips@@elfel-rel2.d: Likewise.
	* gas/mips/micromips@@elf-rel4.d: Likewise.
	* gas/mips/micromips@@jal-svr4pic.d: Likewise.
	* gas/mips/micromips@@jal-svr4pic-noreorder.d: Likewise.
	* gas/mips/micromips@@lb-svr4pic-ilocks.d: Likewise.
	* gas/mips/micromips@@li.d: Likewise.
	* gas/mips/micromips@@loc-swap-dis.d: Likewise.
	* gas/mips/micromips@@loc-swap.d: Likewise.
	* gas/mips/micromips@@mips1-fp.d: Likewise.
	* gas/mips/micromips@@mips32-cp2.d: Likewise.
	* gas/mips/micromips@@mips32-imm.d: Likewise.
	* gas/mips/micromips@@mips32-sf32.d: Likewise.
	* gas/mips/micromips@@mips32.d: Likewise.
	* gas/mips/micromips@@mips32r2-cp2.d: Likewise.
	* gas/mips/micromips@@mips32r2-fp32.d: Likewise.
	* gas/mips/micromips@@mips32r2-sync.d: Likewise.
	* gas/mips/micromips@@mips32r2.d: Likewise.
	* gas/mips/micromips@@mips4-branch-likely.d: Likewise.
	* gas/mips/micromips@@mips4-fp.d: Likewise.
	* gas/mips/micromips@@mips4.d: Likewise.
	* gas/mips/micromips@@mips5.d: Likewise.
	* gas/mips/micromips@@mips64-cp2.d: Likewise.
	* gas/mips/micromips@@mips64.d: Likewise.
	* gas/mips/micromips@@mips64r2.d: Likewise.
	* gas/mips/micromips@@pref.d: Likewise.
	* gas/mips/micromips@@relax-at.d: Likewise.
	* gas/mips/micromips@@relax.d: Likewise.
	* gas/mips/micromips@@rol-hw.d: Likewise.
	* gas/mips/micromips@@uld2-eb.d: Likewise.
	* gas/mips/micromips@@uld2-el.d: Likewise.
	* gas/mips/micromips@@ulh2-eb.d: Likewise.
	* gas/mips/micromips@@ulh2-el.d: Likewise.
	* gas/mips/micromips@@ulw2-eb-ilocks.d: Likewise.
	* gas/mips/micromips@@ulw2-el-ilocks.d: Likewise.
	* gas/mips/cache.d: Likewise.
	* gas/mips/daddi.d: Likewise.
	* gas/mips/mips32-imm.d: Likewise.
	* gas/mips/pref.d: Likewise.
	* gas/mips/elf-rel27.d: Handle microMIPS ASE.
	* gas/mips/l_d.d: Likewise.
	* gas/mips/l_d-n32.d: Likewise.
	* gas/mips/l_d-n64.d: Likewise.
	* gas/mips/ld.d: Likewise.
	* gas/mips/ld-n32.d: Likewise.
	* gas/mips/ld-n64.d: Likewise.
	* gas/mips/s_d.d: Likewise.
	* gas/mips/s_d-n32.d: Likewise.
	* gas/mips/s_d-n64.d: Likewise.
	* gas/mips/sd.d: Likewise.
	* gas/mips/sd-n32.d: Likewise.
	* gas/mips/sd-n64.d: Likewise.
	* gas/mips/mips32.d: Update immediates.
	* gas/mips/micromips@@mips32-cp2.s: New test source.
	* gas/mips/micromips@@mips32-imm.s: Likewise.
	* gas/mips/micromips@@mips32r2-cp2.s: Likewise.
	* gas/mips/micromips@@mips64-cp2.s: Likewise.
	* gas/mips/cache.s: Likewise.
	* gas/mips/daddi.s: Likewise.
	* gas/mips/mips32-imm.s: Likewise.
	* gas/mips/elf-rel4.s: Handle microMIPS ASE.
	* gas/mips/lb-pic.s: Likewise.
	* gas/mips/ld.s: Likewise.
	* gas/mips/mips32.s: Likewise.
	* gas/mips/mips.exp: Add the micromips arch.  Exclude mips16e
	from micromips.  Run mips32-imm.

	* gas/mips/jal-mask-11.d: New test.
	* gas/mips/jal-mask-12.d: Likewise.
	* gas/mips/micromips@@jal-mask-11.d: Likewise.
	* gas/mips/jal-mask-1.s: Source for the new tests.
	* gas/mips/jal-mask-21.d: New test.
	* gas/mips/jal-mask-22.d: Likewise.
	* gas/mips/micromips@@jal-mask-12.d: Likewise.
	* gas/mips/jal-mask-2.s: Source for the new tests.
	* gas/mips/mips.exp: Run the new tests.

	* gas/mips/mips16-e.d: Add --special-syms to `objdump'.
	* gas/mips/tmips16-e.d: Likewise.
	* gas/mips/mipsel16-e.d: Likewise.
	* gas/mips/tmipsel16-e.d: Likewise.

	* gas/mips/and.s: Adjust padding.
	* gas/mips/beq.s: Likewise.
	* gas/mips/bge.s: Likewise.
	* gas/mips/bgeu.s: Likewise.
	* gas/mips/blt.s: Likewise.
	* gas/mips/bltu.s: Likewise.
	* gas/mips/branch-misc-2.s: Likewise.
	* gas/mips/jal.s: Likewise.
	* gas/mips/li.s: Likewise.
	* gas/mips/mips4.s: Likewise.
	* gas/mips/mips4-fp.s: Likewise.
	* gas/mips/relax.s: Likewise.
	* gas/mips/and.d: Update accordingly.
	* gas/mips/elf-jal.d: Likewise.
	* gas/mips/jal.d: Likewise.
	* gas/mips/li.d: Likewise.
	* gas/mips/relax-at.d: Likewise.
	* gas/mips/relax.d: Likewise.

include/elf/
2011-02-25  Chao-ying Fu  <fu@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips.h (R_MICROMIPS_min): New relocations.
	(R_MICROMIPS_26_S1): Likewise.
	(R_MICROMIPS_HI16, R_MICROMIPS_LO16): Likewise.
	(R_MICROMIPS_GPREL16, R_MICROMIPS_LITERAL): Likewise.
	(R_MICROMIPS_GOT16, R_MICROMIPS_PC7_S1): Likewise.
	(R_MICROMIPS_PC10_S1, R_MICROMIPS_PC16_S1): Likewise.
	(R_MICROMIPS_CALL16, R_MICROMIPS_GOT_DISP): Likewise.
	(R_MICROMIPS_GOT_PAGE, R_MICROMIPS_GOT_OFST): Likewise.
	(R_MICROMIPS_GOT_HI16, R_MICROMIPS_GOT_LO16): Likewise.
	(R_MICROMIPS_SUB, R_MICROMIPS_HIGHER): Likewise.
	(R_MICROMIPS_HIGHEST, R_MICROMIPS_CALL_HI16): Likewise.
	(R_MICROMIPS_CALL_LO16, R_MICROMIPS_SCN_DISP): Likewise.
	(R_MICROMIPS_JALR, R_MICROMIPS_HI0_LO16): Likewise.
	(R_MICROMIPS_TLS_GD, R_MICROMIPS_TLS_LDM): Likewise.
	(R_MICROMIPS_TLS_DTPREL_HI, R_MICROMIPS_TLS_DTPREL_LO): Likewise.
	(R_MICROMIPS_TLS_GOTTPREL): Likewise.
	(R_MICROMIPS_TLS_TPREL_HI16): Likewise.
	(R_MICROMIPS_TLS_TPREL_LO16): Likewise.
	(R_MICROMIPS_GPREL7_S2, R_MICROMIPS_PC23_S2): Likewise.
	(R_MICROMIPS_max): Likewise.
	(EF_MIPS_ARCH_ASE_MICROMIPS): New macro.
	(STO_MIPS_ISA, STO_MIPS_FLAGS): Likewise.
	(ELF_ST_IS_MIPS_PLT, ELF_ST_SET_MIPS_PLT): Likewise.
	(STO_MICROMIPS): Likewise.
	(ELF_ST_IS_MICROMIPS, ELF_ST_SET_MICROMIPS): Likewise.
	(ELF_ST_IS_COMPRESSED): Likewise.
	(STO_MIPS_PLT, STO_MIPS_PIC): Rework.
	(ELF_ST_IS_MIPS_PIC, ELF_ST_SET_MIPS_PIC): Likewise.
	(STO_MIPS16, ELF_ST_IS_MIPS16, ELF_ST_SET_MIPS16): Likewise.

include/opcode/
2011-02-25  Chao-ying Fu  <fu@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips.h (OP_MASK_EXTLSB, OP_SH_EXTLSB): New macros.
	(OP_MASK_STYPE, OP_SH_STYPE): Likewise.
	(OP_MASK_CODE10, OP_SH_CODE10): Likewise.
	(OP_MASK_TRAP, OP_SH_TRAP): Likewise.
	(OP_MASK_OFFSET12, OP_SH_OFFSET12): Likewise.
	(OP_MASK_OFFSET10, OP_SH_OFFSET10): Likewise.
	(OP_MASK_RS3, OP_SH_RS3): Likewise.
	(OP_MASK_MB, OP_SH_MB, OP_MASK_MC, OP_SH_MC): Likewise.
	(OP_MASK_MD, OP_SH_MD, OP_MASK_ME, OP_SH_ME): Likewise.
	(OP_MASK_MF, OP_SH_MF, OP_MASK_MG, OP_SH_MG): Likewise.
	(OP_MASK_MJ, OP_SH_MJ, OP_MASK_ML, OP_SH_ML): Likewise.
	(OP_MASK_MP, OP_SH_MP, OP_MASK_MQ, OP_SH_MQ): Likewise.
	(OP_MASK_IMMA, OP_SH_IMMA, OP_MASK_IMMB, OP_SH_IMMB): Likewise.
	(OP_MASK_IMMC, OP_SH_IMMC, OP_MASK_IMMF, OP_SH_IMMF): Likewise.
	(OP_MASK_IMMG, OP_SH_IMMG, OP_MASK_IMMH, OP_SH_IMMH): Likewise.
	(OP_MASK_IMMI, OP_SH_IMMI, OP_MASK_IMMJ, OP_SH_IMMJ): Likewise.
	(OP_MASK_IMML, OP_SH_IMML, OP_MASK_IMMM, OP_SH_IMMM): Likewise.
	(OP_MASK_IMMN, OP_SH_IMMN, OP_MASK_IMMO, OP_SH_IMMO): Likewise.
	(OP_MASK_IMMP, OP_SH_IMMP, OP_MASK_IMMQ, OP_SH_IMMQ): Likewise.
	(OP_MASK_IMMU, OP_SH_IMMU, OP_MASK_IMMW, OP_SH_IMMW): Likewise.
	(OP_MASK_IMMX, OP_SH_IMMX, OP_MASK_IMMY, OP_SH_IMMY): Likewise.
	(INSN_WRITE_GPR_S): New macro.
	(INSN2_BRANCH_DELAY_16BIT, INSN2_BRANCH_DELAY_32BIT): Likewise.
	(INSN2_READ_FPR_D): Likewise.
	(INSN2_MOD_GPR_MB, INSN2_MOD_GPR_MC): Likewise.
	(INSN2_MOD_GPR_MD, INSN2_MOD_GPR_ME): Likewise.
	(INSN2_MOD_GPR_MF, INSN2_MOD_GPR_MG): Likewise.
	(INSN2_MOD_GPR_MJ, INSN2_MOD_GPR_MP): Likewise.
	(INSN2_MOD_GPR_MQ, INSN2_MOD_SP): Likewise.
	(INSN2_READ_GPR_31, INSN2_READ_GP, INSN2_READ_PC): Likewise.
	(INSN2_UNCOND_BRANCH, INSN2_COND_BRANCH): Likewise.
	(INSN2_MOD_GPR_MHI, INSN2_MOD_GPR_MM, INSN2_MOD_GPR_MN): Likewise.
	(CPU_MICROMIPS): New macro.
	(M_BC1FL, M_BC1TL, M_BC2FL, M_BC2TL): New enum values.
	(M_BEQL, M_BGEZ, M_BGEZL, M_BGEZALL, M_BGTZ, M_BGTZL): Likewise.
	(M_BLEZ, M_BLEZL, M_BLTZ, M_BLTZL, M_BLTZALL, M_BNEL): Likewise.
	(M_CACHE_OB, M_JALS_1, M_JALS_2, M_JALS_A): Likewise.
	(M_LDC2_OB, M_LDL_OB, M_LDM_AB, M_LDM_OB): Likewise.
	(M_LDP_AB, M_LDP_OB, M_LDR_OB, M_LL_OB, M_LLD_OB): Likewise.
	(M_LWC2_OB, M_LWL_OB, M_LWM_AB, M_LWM_OB): Likewise.
	(M_LWP_AB, M_LWP_OB, M_LWR_OB): Likewise.
	(M_LWU_OB, M_PREF_OB, M_SC_OB, M_SCD_OB): Likewise.
	(M_SDC2_OB, M_SDL_OB, M_SDM_AB, M_SDM_OB): Likewise.
	(M_SDP_AB, M_SDP_OB, M_SDR_OB): Likewise.
	(M_SWC2_OB, M_SWL_OB, M_SWM_AB, M_SWM_OB): Likewise.
	(M_SWP_AB, M_SWP_OB, M_SWR_OB): Likewise.
	(MICROMIPSOP_MASK_MAJOR, MICROMIPSOP_SH_MAJOR): New macros.
	(MICROMIPSOP_MASK_IMMEDIATE, MICROMIPSOP_SH_IMMEDIATE): Likewise.
	(MICROMIPSOP_MASK_DELTA, MICROMIPSOP_SH_DELTA): Likewise.
	(MICROMIPSOP_MASK_CODE10, MICROMIPSOP_SH_CODE10): Likewise.
	(MICROMIPSOP_MASK_TRAP, MICROMIPSOP_SH_TRAP): Likewise.
	(MICROMIPSOP_MASK_SHAMT, MICROMIPSOP_SH_SHAMT): Likewise.
	(MICROMIPSOP_MASK_TARGET, MICROMIPSOP_SH_TARGET): Likewise.
	(MICROMIPSOP_MASK_EXTLSB, MICROMIPSOP_SH_EXTLSB): Likewise.
	(MICROMIPSOP_MASK_EXTMSBD, MICROMIPSOP_SH_EXTMSBD): Likewise.
	(MICROMIPSOP_MASK_INSMSB, MICROMIPSOP_SH_INSMSB): Likewise.
	(MICROMIPSOP_MASK_CODE, MICROMIPSOP_SH_CODE): Likewise.
	(MICROMIPSOP_MASK_CODE2, MICROMIPSOP_SH_CODE2): Likewise.
	(MICROMIPSOP_MASK_CACHE, MICROMIPSOP_SH_CACHE): Likewise.
	(MICROMIPSOP_MASK_SEL, MICROMIPSOP_SH_SEL): Likewise.
	(MICROMIPSOP_MASK_OFFSET12, MICROMIPSOP_SH_OFFSET12): Likewise.
	(MICROMIPSOP_MASK_3BITPOS, MICROMIPSOP_SH_3BITPOS): Likewise.
	(MICROMIPSOP_MASK_STYPE, MICROMIPSOP_SH_STYPE): Likewise.
	(MICROMIPSOP_MASK_OFFSET10, MICROMIPSOP_SH_OFFSET10): Likewise.
	(MICROMIPSOP_MASK_RS, MICROMIPSOP_SH_RS): Likewise.
	(MICROMIPSOP_MASK_RT, MICROMIPSOP_SH_RT): Likewise.
	(MICROMIPSOP_MASK_RD, MICROMIPSOP_SH_RD): Likewise.
	(MICROMIPSOP_MASK_FS, MICROMIPSOP_SH_FS): Likewise.
	(MICROMIPSOP_MASK_FT, MICROMIPSOP_SH_FT): Likewise.
	(MICROMIPSOP_MASK_FD, MICROMIPSOP_SH_FD): Likewise.
	(MICROMIPSOP_MASK_FR, MICROMIPSOP_SH_FR): Likewise.
	(MICROMIPSOP_MASK_RS3, MICROMIPSOP_SH_RS3): Likewise.
	(MICROMIPSOP_MASK_PREFX, MICROMIPSOP_SH_PREFX): Likewise.
	(MICROMIPSOP_MASK_BCC, MICROMIPSOP_SH_BCC): Likewise.
	(MICROMIPSOP_MASK_CCC, MICROMIPSOP_SH_CCC): Likewise.
	(MICROMIPSOP_MASK_COPZ, MICROMIPSOP_SH_COPZ): Likewise.
	(MICROMIPSOP_MASK_MB, MICROMIPSOP_SH_MB): Likewise.
	(MICROMIPSOP_MASK_MC, MICROMIPSOP_SH_MC): Likewise.
	(MICROMIPSOP_MASK_MD, MICROMIPSOP_SH_MD): Likewise.
	(MICROMIPSOP_MASK_ME, MICROMIPSOP_SH_ME): Likewise.
	(MICROMIPSOP_MASK_MF, MICROMIPSOP_SH_MF): Likewise.
	(MICROMIPSOP_MASK_MG, MICROMIPSOP_SH_MG): Likewise.
	(MICROMIPSOP_MASK_MH, MICROMIPSOP_SH_MH): Likewise.
	(MICROMIPSOP_MASK_MI, MICROMIPSOP_SH_MI): Likewise.
	(MICROMIPSOP_MASK_MJ, MICROMIPSOP_SH_MJ): Likewise.
	(MICROMIPSOP_MASK_ML, MICROMIPSOP_SH_ML): Likewise.
	(MICROMIPSOP_MASK_MM, MICROMIPSOP_SH_MM): Likewise.
	(MICROMIPSOP_MASK_MN, MICROMIPSOP_SH_MN): Likewise.
	(MICROMIPSOP_MASK_MP, MICROMIPSOP_SH_MP): Likewise.
	(MICROMIPSOP_MASK_MQ, MICROMIPSOP_SH_MQ): Likewise.
	(MICROMIPSOP_MASK_IMMA, MICROMIPSOP_SH_IMMA): Likewise.
	(MICROMIPSOP_MASK_IMMB, MICROMIPSOP_SH_IMMB): Likewise.
	(MICROMIPSOP_MASK_IMMC, MICROMIPSOP_SH_IMMC): Likewise.
	(MICROMIPSOP_MASK_IMMD, MICROMIPSOP_SH_IMMD): Likewise.
	(MICROMIPSOP_MASK_IMME, MICROMIPSOP_SH_IMME): Likewise.
	(MICROMIPSOP_MASK_IMMF, MICROMIPSOP_SH_IMMF): Likewise.
	(MICROMIPSOP_MASK_IMMG, MICROMIPSOP_SH_IMMG): Likewise.
	(MICROMIPSOP_MASK_IMMH, MICROMIPSOP_SH_IMMH): Likewise.
	(MICROMIPSOP_MASK_IMMI, MICROMIPSOP_SH_IMMI): Likewise.
	(MICROMIPSOP_MASK_IMMJ, MICROMIPSOP_SH_IMMJ): Likewise.
	(MICROMIPSOP_MASK_IMML, MICROMIPSOP_SH_IMML): Likewise.
	(MICROMIPSOP_MASK_IMMM, MICROMIPSOP_SH_IMMM): Likewise.
	(MICROMIPSOP_MASK_IMMN, MICROMIPSOP_SH_IMMN): Likewise.
	(MICROMIPSOP_MASK_IMMO, MICROMIPSOP_SH_IMMO): Likewise.
	(MICROMIPSOP_MASK_IMMP, MICROMIPSOP_SH_IMMP): Likewise.
	(MICROMIPSOP_MASK_IMMQ, MICROMIPSOP_SH_IMMQ): Likewise.
	(MICROMIPSOP_MASK_IMMU, MICROMIPSOP_SH_IMMU): Likewise.
	(MICROMIPSOP_MASK_IMMW, MICROMIPSOP_SH_IMMW): Likewise.
	(MICROMIPSOP_MASK_IMMX, MICROMIPSOP_SH_IMMX): Likewise.
	(MICROMIPSOP_MASK_IMMY, MICROMIPSOP_SH_IMMY): Likewise.
	(MICROMIPSOP_MASK_CODE, MICROMIPSOP_SH_CODE): Likewise.
	(MICROMIPSOP_MASK_CODE2, MICROMIPSOP_SH_CODE2): Likewise.
	(MICROMIPSOP_MASK_CACHE, MICROMIPSOP_SH_CACHE): Likewise.
	(MICROMIPSOP_MASK_CODE20, MICROMIPSOP_SH_CODE20): Likewise.
	(MICROMIPSOP_MASK_PERFREG, MICROMIPSOP_SH_PERFREG): Likewise.
	(MICROMIPSOP_MASK_CODE19, MICROMIPSOP_SH_CODE19): Likewise.
	(MICROMIPSOP_MASK_ALN, MICROMIPSOP_SH_ALN): Likewise.
	(MICROMIPSOP_MASK_VECBYTE, MICROMIPSOP_SH_VECBYTE): Likewise.
	(MICROMIPSOP_MASK_VECALIGN, MICROMIPSOP_SH_VECALIGN): Likewise.
	(MICROMIPSOP_MASK_DSPACC, MICROMIPSOP_SH_DSPACC): Likewise.
	(MICROMIPSOP_MASK_DSPACC_S, MICROMIPSOP_SH_DSPACC_S): Likewise.
	(MICROMIPSOP_MASK_DSPSFT, MICROMIPSOP_SH_DSPSFT): Likewise.
	(MICROMIPSOP_MASK_DSPSFT_7, MICROMIPSOP_SH_DSPSFT_7): Likewise.
	(MICROMIPSOP_MASK_SA3, MICROMIPSOP_SH_SA3): Likewise.
	(MICROMIPSOP_MASK_SA4, MICROMIPSOP_SH_SA4): Likewise.
	(MICROMIPSOP_MASK_IMM8, MICROMIPSOP_SH_IMM8): Likewise.
	(MICROMIPSOP_MASK_IMM10, MICROMIPSOP_SH_IMM10): Likewise.
	(MICROMIPSOP_MASK_WRDSP, MICROMIPSOP_SH_WRDSP): Likewise.
	(MICROMIPSOP_MASK_RDDSP, MICROMIPSOP_SH_RDDSP): Likewise.
	(MICROMIPSOP_MASK_BP, MICROMIPSOP_SH_BP): Likewise.
	(MICROMIPSOP_MASK_MT_U, MICROMIPSOP_SH_MT_U): Likewise.
	(MICROMIPSOP_MASK_MT_H, MICROMIPSOP_SH_MT_H): Likewise.
	(MICROMIPSOP_MASK_MTACC_T, MICROMIPSOP_SH_MTACC_T): Likewise.
	(MICROMIPSOP_MASK_MTACC_D, MICROMIPSOP_SH_MTACC_D): Likewise.
	(MICROMIPSOP_MASK_BBITIND, MICROMIPSOP_SH_BBITIND): Likewise.
	(MICROMIPSOP_MASK_CINSPOS, MICROMIPSOP_SH_CINSPOS): Likewise.
	(MICROMIPSOP_MASK_CINSLM1, MICROMIPSOP_SH_CINSLM1): Likewise.
	(MICROMIPSOP_MASK_SEQI, MICROMIPSOP_SH_SEQI): Likewise.
	(micromips_opcodes): New declaration.
	(bfd_micromips_num_opcodes): Likewise.

ld/testsuite/
2011-02-25  Catherine Moore  <clm@@codesourcery.com>
            Chao-ying Fu  <fu@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* lib/ld-lib.exp (run_dump_test): Support distinct assembler
	flags for the same source named multiple times.
	* ld-mips-elf/jalx-1.s: New test source.
	* ld-mips-elf/jalx-1.d: New test output.
	* ld-mips-elf/jalx-1.ld: New test linker script.
	* ld-mips-elf/jalx-2-main.s: New test source.
	* ld-mips-elf/jalx-2-ex.s: Likewise.
	* ld-mips-elf/jalx-2-printf.s: Likewise.
	* ld-mips-elf/jalx-2.dd: New test output.
	* ld-mips-elf/jalx-2.ld: New test linker script.
	* ld-mips-elf/mips16-and-micromips.d: New test.
	* ld-mips-elf/mips-elf.exp: Run the new tests

opcodes/
2011-02-25  Chao-ying Fu  <fu@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* micromips-opc.c: New file.
	* mips-dis.c (micromips_to_32_reg_b_map): New array.
	(micromips_to_32_reg_c_map, micromips_to_32_reg_d_map): Likewise.
	(micromips_to_32_reg_e_map, micromips_to_32_reg_f_map): Likewise.
	(micromips_to_32_reg_g_map, micromips_to_32_reg_l_map): Likewise.
	(micromips_to_32_reg_q_map): Likewise.
	(micromips_imm_b_map, micromips_imm_c_map): Likewise.
	(micromips_ase): New variable.
	(is_micromips): New function.
	(set_default_mips_dis_options): Handle microMIPS ASE.
	(print_insn_micromips): New function.
	(is_compressed_mode_p): Likewise.
	(_print_insn_mips): Handle microMIPS instructions.
	* Makefile.am (CFILES): Add micromips-opc.c.
	* configure.in (bfd_mips_arch): Add micromips-opc.lo.
	* Makefile.in: Regenerate.
	* configure: Regenerate.

	* mips-dis.c (micromips_to_32_reg_h_map): New variable.
	(micromips_to_32_reg_i_map): Likewise.
	(micromips_to_32_reg_m_map): Likewise.
	(micromips_to_32_reg_n_map): New macro.
@
text
@a25 1

a28 1

d192 1
a192 1
static struct local_symbol *
@


1.111.2.1
log
@	2011-10-13  Alan Modra  <amodra@@gmail.com>
	* as.c (main): Define .gasversion. rather than __GAS_VERSION__.
	* frags.h (bss_address_frag): Delete
	(predefined_address_frag): New.
	* frags.c (frag_init): Init predefined_address_frag.  Delete ref
	to bss_address_frag.
	* symbols.c (S_CAN_BE_REDEFINED): New function.
	* symbols.h (S_CAN_BE_REDEFINED): Declare.
	* read.c (assign_symbol): Use S_CAN_BE_REDEFINED.

	2011-10-12  Alan Modra  <amodra@@gmail.com>
	* symbols.c (local_symbol_make): Make global.
	* symbols.h (local_symbol_make): Declare.
	* as.c (main): Define __GAS_VERSION__.
@
text
@d26 1
d30 1
d194 1
a194 1
struct local_symbol *
a2141 10
S_CAN_BE_REDEFINED (const symbolS *s)
{
  if (LOCAL_SYMBOL_CHECK (s))
    return (local_symbol_get_frag ((struct local_symbol *) s)
	    == &predefined_address_frag);
  /* Permit register names to be redefined.  */
  return s->bsym->section == reg_section;
}

int
@


1.110
log
@2011-05-06  Tristan Gingold  <gingold@@adacore.com>

	* read.c (s_comm_internal): Remove code for OBJ_VMS.
	(s_data): Ditto.
	(s_text): Ditto.
	* write.c (write_object_file): Ditto.
	* symbols.c (define_sym_at_dot): Ditto.
	(colon): Ditto.
@
text
@d62 4
d2127 1
@


1.109
log
@	* symbols.c (report_op_error): Remove unnecessary forward declaration.
	Add "op" parameter.  Report operator and operand segments in error
	message, not operand symbols.
	(resolve_symbol_value): Always set segment for equated symbols, not
	just when finalizing.  Adjust report_op_error calls.
@
text
@a252 3
#ifdef OBJ_VMS
  S_SET_OTHER (symbolP, const_flag);
#endif
a446 3
#ifdef OBJ_VMS
      S_SET_OTHER (symbolP, const_flag);
#endif /* OBJ_VMS */
@


1.108
log
@	* symbols.c (symbol_clone_if_forward_ref): Call tc_new_dot_label
	for new fake labels created off the dot special symbol.
	* config/tc-mips.h (tc_new_dot_label): New macro.
	(mips_record_label): New prototype.
	* config/tc-mips.c (my_getExpression): Remove MIPS16 fake label
	annotation.
	(s_cons, s_float_cons, s_gpword, s_gpdword): Only clear labels
	recorded once data expressions have been evaluated.
	(mips_define_label): Move code to record labels over to...
	(mips_record_label): ... this new function.
	* doc/internals.texi: Document tc_new_dot_label.
@
text
@d3 2
a4 2
   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
   Free Software Foundation, Inc.
a74 1
static void report_op_error (symbolS *, symbolS *, symbolS *);
d972 1
a972 1
report_op_error (symbolS *symp, symbolS *left, symbolS *right)
d976 33
a1008 2
  segT seg_left = S_GET_SEGMENT (left);
  segT seg_right = right ? S_GET_SEGMENT (right) : 0;
d1012 1
a1012 1
      if (seg_left == undefined_section)
d1014 3
a1016 3
		      _("undefined symbol `%s' in operation"),
		      S_GET_NAME (left));
      if (seg_right == undefined_section)
d1018 2
a1019 15
		      _("undefined symbol `%s' in operation"),
		      S_GET_NAME (right));
      if (seg_left != undefined_section
	  && seg_right != undefined_section)
	{
	  if (right)
	    as_bad_where (file, line,
			  _("invalid sections for operation on `%s' and `%s'"),
			  S_GET_NAME (left), S_GET_NAME (right));
	  else
	    as_bad_where (file, line,
			  _("invalid section for operation on `%s'"),
			  S_GET_NAME (left));
	}

d1023 8
a1030 16
      if (seg_left == undefined_section)
	as_bad (_("undefined symbol `%s' in operation setting `%s'"),
		S_GET_NAME (left), S_GET_NAME (symp));
      if (seg_right == undefined_section)
	as_bad (_("undefined symbol `%s' in operation setting `%s'"),
		S_GET_NAME (right), S_GET_NAME (symp));
      if (seg_left != undefined_section
	  && seg_right != undefined_section)
	{
	  if (right)
	    as_bad (_("invalid sections for operation on `%s' and `%s' setting `%s'"),
		    S_GET_NAME (left), S_GET_NAME (right), S_GET_NAME (symp));
	  else
	    as_bad (_("invalid section for operation on `%s' setting `%s'"),
		    S_GET_NAME (left), S_GET_NAME (symp));
	}
a1222 1
		  final_seg = seg_left;
d1224 1
d1273 1
a1273 1
	    report_op_error (symp, add_symbol, NULL);
d1350 1
a1350 1
		   && seg_right == absolute_section)
d1361 1
a1361 1
		report_op_error (symp, add_symbol, op_symbol);
@


1.107
log
@gas/
	* symbols.c (S_FORCE_RELOC): Return true for indirect functions
	even if !strict.
	* expr.c (operand): Don't convert absolute symbols to constants
	if S_FORCE_RELOC is true.
	(expr): Only reduce subtractions between different symbols if
	S_FORCE_RELOC is false for both of them.
	* write.c (fixup_segment): Don't remove symbols if S_FORCE_RELOC
	is true for them, regardless of their segment.

gas/testsuite/
	* gas/i386/ifunc-2.s, gas/i386/ifunc-2.l: New test.
	* gas/i386/ifunc-3.s, gas/i386/ifunc-3.d: Likeise.
	* gas/i386/i386.exp: Run them.
@
text
@d671 6
a676 1
	    symbolP = symbol_temp_new_now ();
@


1.106
log
@	* symbols.h (dot_symbol): New declaration.
	(dot_symbol_init): New prototype.
	* symbols.c (dot_symbol): New variable.
	(symbol_clone): Assert it's not dot_symbol being cloned.
	(dot_symbol_init): New function.
	(symbol_clone_if_forward_ref): Create a new temporary symbol
	when trying to clone dot_symbol.
	* expr.c (current_location): Refer to dot_symbol instead of
	making a new temporary symbol.
	* read.c (read_a_source_file): Update dot_symbol as we go.
	* as.c (main): Call dot_symbol_init.
@
text
@a2067 1
	       || (s->bsym->flags & BSF_GNU_INDIRECT_FUNCTION) != 0
d2070 1
@


1.105
log
@	* symbols.c (symbol_clone_if_forward_ref): Don't limit cloning
	to expr_section symbols; clone all equated symbols.  Clear
	sy_resolving of the cloned copy.
	* expr.c (operand): Only clone equated symbols on a final
	(i.e. non-equated) reference.
@
text
@d51 1
d561 3
d665 7
a671 2
	  symbolP = symbol_clone (symbolP, 0);
	  symbolP->sy_resolving = 0;
d2761 11
@


1.104
log
@	PR gas/11841
	* symbols.c (symbol_clone): Correct typo in previous patch.
@
text
@d648 2
a649 1
      if (symbolP->bsym->section == expr_section && !symbolP->sy_resolving)
d660 4
a663 1
	symbolP = symbol_clone (symbolP, 0);
@


1.104.2.1
log
@backport from mainline
@
text
@a50 1
symbolS dot_symbol;
a559 3
  /* Make sure we never clone the dot special symbol.  */
  gas_assert (orgsymP != &dot_symbol);

d648 1
a648 2
      if ((symbolP->bsym->section == expr_section || symbolP->sy_forward_ref)
	  && !symbolP->sy_resolving)
d659 1
a659 14
	{
	  if (symbolP != &dot_symbol)
	    {
	      symbolP = symbol_clone (symbolP, 0);
	      symbolP->sy_resolving = 0;
	    }
	  else
	    {
	      symbolP = symbol_temp_new_now ();
#ifdef tc_new_dot_label
	      tc_new_dot_label (symbolP);
#endif
	    }
	}
d2055 1
a2057 1
	  || (s->bsym->flags & BSF_GNU_INDIRECT_FUNCTION) != 0
a2747 11

void
dot_symbol_init (void)
{
  dot_symbol.bsym = bfd_make_empty_symbol (stdoutput);
  if (dot_symbol.bsym == NULL)
    as_fatal ("bfd_make_empty_symbol: %s", bfd_errmsg (bfd_get_error ()));
  dot_symbol.bsym->name = ".";
  dot_symbol.sy_forward_ref = 1;
  dot_symbol.sy_value.X_op = O_constant;
}
@


1.104.2.2
log
@	* symbols.c (report_op_error): Remove unnecessary forward declaration.
	Add "op" parameter.  Report operator and operand segments in error
	message, not operand symbols.
	(resolve_symbol_value): Always set segment for equated symbols, not
	just when finalizing.  Adjust report_op_error calls.
@
text
@d3 2
a4 2
   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010,
   2011 Free Software Foundation, Inc.
d75 1
d973 1
a973 1
report_op_error (symbolS *symp, symbolS *left, operatorT op, symbolS *right)
d977 2
a978 33
  segT seg_left = left ? S_GET_SEGMENT (left) : 0;
  segT seg_right = S_GET_SEGMENT (right);
  const char *opname;

  switch (op)
    {
    default:
      abort ();
      return;

    case O_uminus:		opname = "-"; break;
    case O_bit_not:		opname = "~"; break;
    case O_logical_not:		opname = "!"; break;
    case O_multiply:		opname = "*"; break;
    case O_divide:		opname = "/"; break;
    case O_modulus:		opname = "%"; break;
    case O_left_shift:		opname = "<<"; break;
    case O_right_shift:		opname = ">>"; break;
    case O_bit_inclusive_or:	opname = "|"; break;
    case O_bit_or_not:		opname = "|~"; break;
    case O_bit_exclusive_or:	opname = "^"; break;
    case O_bit_and:		opname = "&"; break;
    case O_add:			opname = "+"; break;
    case O_subtract:		opname = "-"; break;
    case O_eq:			opname = "=="; break;
    case O_ne:			opname = "!="; break;
    case O_lt:			opname = "<"; break;
    case O_le:			opname = "<="; break;
    case O_ge:			opname = ">="; break;
    case O_gt:			opname = ">"; break;
    case O_logical_and:		opname = "&&"; break;
    case O_logical_or:		opname = "||"; break;
    }
d982 1
a982 1
      if (left)
d984 3
a986 3
		      _("invalid operands (%s and %s sections) for `%s'"),
		      seg_left->name, seg_right->name, opname);
      else
d988 15
a1002 2
		      _("invalid operand (%s section) for `%s'"),
		      seg_right->name, opname);
d1006 16
a1021 8
      const char *sname = S_GET_NAME (symp);

      if (left)
	as_bad (_("invalid operands (%s and %s sections) for `%s' when setting `%s'"),
		seg_left->name, seg_right->name, opname, sname);
      else
	as_bad (_("invalid operand (%s section) for `%s' when setting `%s'"),
		seg_right->name, opname, sname);
d1214 1
a1215 1
	      final_seg = seg_left;
d1264 1
a1264 1
	    report_op_error (symp, NULL, op, add_symbol);
d1341 1
a1341 1
		&& seg_right == absolute_section)
d1352 1
a1352 1
		report_op_error (symp, add_symbol, op, op_symbol);
@


1.103
log
@	PR gas/11841
	* symbols.c (symbol_clone): Clear BSF_SECTION_SYM flag.
@
text
@d575 1
a575 1
  bsymnew->flags = bsymorg->flags & !BSF_SECTION_SYM;
@


1.102
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d575 2
a576 2
  bsymnew->flags =  bsymorg->flags;
  bsymnew->section =  bsymorg->section;
@


1.101
log
@Call symbol_same_p to check to if 2 symbols are the same.

gas/

2009-12-07  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11037
	* expr.c (resolve_expression): Call symbol_same_p to check
	if 2 symbols are the same.

	* symbols.c (symbol_same_p): New.
	* symbols.h (symbol_same_p): Likewise.

gas/testsuite/

2009-12-07  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11037
	* gas/i386/intelpic.s: Add testcases.
	* gas/i386/intelpic.d: Updated.
@
text
@d191 1
a191 1
local_symbol_make (const char *name, segT section, valueT value, fragS *frag)
d205 1
a205 1
  ret->lsy_value = value;
d1487 1
a1487 1
      expressionS expr = symbolP->sy_value;
d1489 1
a1489 1
      if (!symbolP->sy_resolved && expr.X_op != O_illegal)
d1496 1
a1496 1
	  resolved = resolve_expression (&expr);
d1501 1
a1501 1
	  switch (expr.X_op)
d1510 1
a1510 1
	      symbolP = expr.X_add_symbol;
d1518 1
a1518 1
      *valueP = expr.X_add_number;
d1523 1
a1523 1
	switch (expr.X_op)
d1865 1
a1865 1
  int index = 0;
d1868 2
a1869 2
  if (s[index] == LOCAL_LABEL_PREFIX)
    ++index;
d1872 1
a1872 1
  if (s[index] != 'L')
d1875 1
a1875 1
  for (label_number = 0, p = s + index + 1; ISDIGIT (*p); ++p)
@


1.100
log
@	PR gas/10704
	* symbols.c (snapshot_symbol): Revert 2006-01-09 patch for PR2117.
@
text
@d2388 14
@


1.99
log
@	* symbols.c (define_sym_at_dot): New function, extracted from..
	(colon): ..here.  Define error case cloned symbol.
@
text
@d1517 1
a1517 4
      /* Never change a defined symbol.  */
      if (symbolP->bsym->section == undefined_section
	  || symbolP->bsym->section == expr_section)
	*symbolPP = symbolP;
@


1.98
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        * as.c (main): Call dwarf2_init.
        * config/obj-elf.c (struct group_list): New field.
        (build_group_lists): Use hash lookup.
        (free_section_idx): New function.
        (elf_frob_file): Adjust.
        * dwarf2dbg.c (all_segs_hash, last_seg_ptr): New variables.
        (get_line_subseg): Adjust.
        (dwarf2_init): New function.
        * dwarf2dbg.h (dwarf2_init): New declaration.
@
text
@d249 11
d357 1
a357 6
	      symbolP->sy_frag = frag_now;
#ifdef OBJ_VMS
	      S_SET_OTHER (symbolP, const_flag);
#endif
	      S_SET_VALUE (symbolP, (valueT) frag_now_fix ());
	      S_SET_SEGMENT (symbolP, now_seg);
d402 1
a402 6
		      symbolP->sy_frag = frag_now;
#ifdef OBJ_VMS
		      S_SET_OTHER (symbolP, const_flag);
#endif
		      S_SET_VALUE (symbolP, (valueT) frag_now_fix ());
		      S_SET_SEGMENT (symbolP, now_seg);	/* Keep N_EXT bit.  */
d435 1
@


1.97
log
@	* config/obj-coff.h (USE_UNIQUE): Don't define.
	* config/obj-coff.c (weak_uniquify): Use an_external_name when TE_PE.
	* symbols.c (an_external_name): Define when TE_PE.
	(S_SET_EXTERNAL): Assign an_external_name when TE_PE.
	* tc.h (an_external_name): Declare when TE_PE.
@
text
@d112 1
a112 1
  ret = obstack_finish (&notes);
d140 1
a140 1
  symbolP = obstack_alloc (&notes, sizeof (symbolS));
d200 1
a200 1
  ret = obstack_alloc (&notes, sizeof *ret);
d566 1
a566 1
  newsymP = obstack_alloc (&notes, sizeof (*newsymP));
d1456 1
a1456 1
    resolve_symbol_value (value);
d1606 1
a1606 1
      dollar_label_defines = xmalloc (DOLLAR_LABEL_BUMP_BY);
d1617 1
a1617 1
      dollar_label_defines = xrealloc (dollar_label_defines, dollar_label_max);
d1890 1
a1890 1
  symbol_decode = obstack_alloc (&notes, strlen (message_format) + 30);
@


1.96
log
@	PR ld/10269
	* symbols.c (S_FORCE_RELOC): True for BSF_GNU_INDIRECT_FUNCTION.
	* config/tc-i386.c: Revert 2009-06-13 change.
	* config/tc-i386.h: Likewise.
@
text
@d62 1
a62 1
#ifdef USE_UNIQUE
d2207 1
a2207 1
#ifdef USE_UNIQUE
@


1.96.2.1
log
@	* config/obj-coff.h (USE_UNIQUE): Don't define.
	* config/obj-coff.c (weak_uniquify): Use an_external_name when TE_PE.
	* symbols.c (an_external_name): Define when TE_PE.
	(S_SET_EXTERNAL): Assign an_external_name when TE_PE.
	* tc.h (an_external_name): Declare when TE_PE.
@
text
@d62 1
a62 1
#ifdef TE_PE
d2207 1
a2207 1
#ifdef TE_PE
@


1.96.2.2
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.
@
text
@d112 1
a112 1
  ret = (char *) obstack_finish (&notes);
d140 1
a140 1
  symbolP = (symbolS *) obstack_alloc (&notes, sizeof (symbolS));
d200 1
a200 1
  ret = (struct local_symbol *) obstack_alloc (&notes, sizeof *ret);
d566 1
a566 1
  newsymP = (symbolS *) obstack_alloc (&notes, sizeof (*newsymP));
d1456 1
a1456 1
    resolve_symbol_value ((symbolS *) value);
d1606 1
a1606 1
      dollar_label_defines = (char *) xmalloc (DOLLAR_LABEL_BUMP_BY);
d1617 1
a1617 1
      dollar_label_defines = (char *) xrealloc (dollar_label_defines, dollar_label_max);
d1890 1
a1890 1
  symbol_decode = (char *) obstack_alloc (&notes, strlen (message_format) + 30);
@


1.96.2.3
log
@	* symbols.c (define_sym_at_dot): New function, extracted from..
	(colon): ..here.  Define error case cloned symbol.
@
text
@a248 11
static void
define_sym_at_dot (symbolS *symbolP)
{
  symbolP->sy_frag = frag_now;
#ifdef OBJ_VMS
  S_SET_OTHER (symbolP, const_flag);
#endif
  S_SET_VALUE (symbolP, (valueT) frag_now_fix ());
  S_SET_SEGMENT (symbolP, now_seg);
}

d346 6
a351 1
	      define_sym_at_dot (symbolP);
d396 6
a401 1
		      define_sym_at_dot (symbolP);
a433 1
	      define_sym_at_dot (symbolP);
@


1.96.2.4
log
@	PR gas/10704
	* symbols.c (snapshot_symbol): Revert 2006-01-09 patch for PR2117.
@
text
@d1517 4
a1520 1
      *symbolPP = symbolP;
@


1.96.2.5
log
@Fix PR gas/11037.

gas/

2009-12-15  H.J. Lu  <hongjiu.lu@@intel.com>

	Backport from trunk:
	2009-12-07  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11037
	* expr.c (resolve_expression): Call symbol_same_p to check
	if 2 symbols are the same.

	* symbols.c (symbol_same_p): New.
	* symbols.h (symbol_same_p): Likewise.

gas/testsuite/

2009-12-15  H.J. Lu  <hongjiu.lu@@intel.com>

	Backport from trunk:
	2009-12-07  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11037
	* gas/i386/intelpic.s: Add testcases.
	* gas/i386/intelpic.d: Updated.

	2009-10-28  Alan Modra  <amodra@@bigpond.net.au>

	* gas/i386/intelpic.d: Correct.

	2009-10-08  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/10704
	* gas/i386/intelpic.s: Add 2 new tests.
	* gas/i386/intelpic.d: Updated.
@
text
@a2387 14
/* Return whether 2 symbols are the same.  */

int
symbol_same_p (symbolS *s1, symbolS *s2)
{
  if (s1->bsym == NULL
      && local_symbol_converted_p ((struct local_symbol *) s1))
    s1 = local_symbol_get_real_symbol ((struct local_symbol *) s1);
  if (s2->bsym == NULL
      && local_symbol_converted_p ((struct local_symbol *) s2))
    s2 = local_symbol_get_real_symbol ((struct local_symbol *) s2);
  return s1 == s2;
}

@


1.95
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
d2056 1
@


1.94
log
@gas/

2009-05-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* symbols.c (COPIED_SYMFLAGS): Add BSF_GNU_INDIRECT_FUNCTION.

gas/testsuite/gas/

2009-05-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/elf/ifunc-1.d: New.
	* gas/elf/ifunc-1.s: Likewise.

	* gas/elf/elf.exp: Run ifunc-1.
@
text
@d220 1
a220 1
  assert (locsym->lsy_marker == NULL);
d882 2
a883 2
      assert (symbolP->bsym != NULL);
      assert (symbolP->sy_next->sy_previous == symbolP);
d886 1
a886 1
  assert (lastP == symbolP);
d1147 1
a1147 1
	      assert (final_val == 0);
d1150 1
a1150 1
		  assert (add_symbol->sy_value.X_op == O_symbol
d1153 1
a1153 1
		  assert (! S_IS_WEAKREFR (add_symbol));
d2989 1
a2989 1
  assert (sym != NULL);
d3054 1
a3054 1
  assert (exp != NULL);
d3167 1
a3167 1
      assert (concat_string != NULL);
@


1.93
log
@Remove unnecessary casts on obstack_alloc invocations.
@
text
@d1951 2
a1952 1
#define COPIED_SYMFLAGS	(BSF_FUNCTION | BSF_OBJECT)
@


1.93.4.1
log
@Commit patches for ARCompact support to binutils-arc-20081103-branch .
@
text
@d190 1
a190 1
struct local_symbol *
@


1.92
log
@2008-10-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* read.c (pseudo_set): Don't allow global register symbol only
	if TC_GLOBAL_REGISTER_SYMBOL_OK is undefined.
	* symbols.c (S_SET_EXTERNAL): Likewise.

	* config/tc-mmix.h (TC_GLOBAL_REGISTER_SYMBOL_OK): Defined.

	* doc/internals.texi: Document TC_GLOBAL_REGISTER_SYMBOL_OK.
@
text
@d140 1
a140 1
  symbolP = (symbolS *) obstack_alloc (&notes, sizeof (symbolS));
d200 1
a200 1
  ret = (struct local_symbol *) obstack_alloc (&notes, sizeof *ret);
@


1.91
log
@	* symbols.c (symbol_clone): Ensure clones are not external.
@
text
@d2194 1
d2201 1
@


1.90
log
@Banish PARAMS and PTR.  Convert to ISO C.
Delete unnecessary forward declarations.
@
text
@d599 3
d608 5
a612 1
    newsymP->sy_previous = newsymP->sy_next = newsymP;
@


1.89
log
@Silence gcc printf warnings
@
text
@d207 1
a207 1
  hash_jam (local_hash, name_copy, (PTR) ret);
d492 1
a492 1
			       (PTR) symbolP);
d499 1
a499 1
  if ((error_string = hash_jam (sy_hash, S_GET_NAME (symbolP), (PTR) symbolP)))
d1441 1
a1441 1
static void resolve_local_symbol (const char *, PTR);
d1446 1
a1446 1
resolve_local_symbol (const char *key ATTRIBUTE_UNUSED, PTR value)
@


1.88
log
@gas/

2008-03-03  Denys Vlasenko <vda.linux@@googlemail.com>
	    H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/5543
	* read.c (pseudo_set): Don't allow global register symbol.

	* symbols.c (S_SET_EXTERNAL): Don't allow register symbol
	global.

2008-03-03  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/5543
	* write.c (write_object_file): Don't allow symbols which were
	equated to register.  Stop if there is an error.

gas/testsuite/

2008-03-03  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/5543
	* gas/i386/i386.exp: Run inval-equ-1 and inval-equ-2.

	* gas/i386/inval-equ-1.l: New.
	* gas/i386/inval-equ-1.s: Likewise.
	* gas/i386/inval-equ-2.l: Likewise.
	* gas/i386/inval-equ-2.s: Likewise.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
d2794 1
a2794 1
	fprintf (file, " %lx", (long) S_GET_VALUE (sym));
d2803 1
a2803 1
		 (long) ((struct local_symbol *) sym)->lsy_value);
d2847 1
a2847 1
      fprintf (file, "constant %lx", (long) exp->X_add_number);
d2857 1
a2857 1
		 (long) exp->X_add_number);
@


1.87
log
@Add support for building on a 64-bit Windows host.
@
text
@d2187 6
@


1.86
log
@* symbols.c (symbol_relc_make_value): Use bfd_sprintf_vma in order to get the
  right length of printed value.
@
text
@d2731 3
a2733 1
  fprintf (file, "sym %lx %s", (unsigned long) sym, name);
d2738 2
a2739 1
      if (local_symbol_get_frag (locsym) != &zero_address_frag
d2741 4
a2744 1
	fprintf (file, " frag %lx", (long) local_symbol_get_frag (locsym));
d2752 4
a2755 1
	fprintf (file, " frag %lx", (long) sym->sy_frag);
d2829 3
a2831 1
  fprintf (file, "expr %lx ", (long) exp);
@


1.85
log
@Switch to GPLv3
@
text
@d3007 1
a3007 1
  sprintf_vma (& terminal[1], val);
@


1.84
log
@gas/
	* expr.c (expr): Assert on rankarg, not rank which can be unsigned.
	* read.c (read_a_source_file): Remove buffer_limit[-1] assertion.
	Don't skip over NUL char.
	(pseudo_set): Set X_op for registers to O_register.
	* symbols.c (symbol_clone): Remove assertion that sym is defined.
	(resolve_symbol_value): Resolve O_register symbols.
	* config/tc-i386.c (parse_real_register): Don't use i386_float_regtab.
	Instead find st(0) by hash lookup.
	* config/tc-ppc.c (ppc_macro): Warning fix.
opcodes/
	* i386-opc.c (i386_float_regtab, i386_float_regtab_size): Delete.
	Move contents to..
	(i386_regtab): ..here.
	* i386-opc.h (i386_float_regtab, i386_float_regtab_size): Delete.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.83
log
@	gas/
	* config/tc-arm.c (arm_copy_symbol_attributes): New.
	* config/tc-arm.h (arm_copy_symbol_attributes): Declare.
	(TC_COPY_SYMBOL_ATTRIBUTES): Define.
	* gas/symbols.c (copy_symbol_attributes): Use
	TC_COPY_SYMBOL_ATTRIBUTES.

	gas/testsuite/
	* gas/arm/thumbver.d, gas/arm/thumbver.s: New test.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
a565 2
  know (S_IS_DEFINED (orgsymP));

d1124 3
a1403 1
	case O_register:
@


1.82
log
@	* symbols.c (symbol_relc_make_sym): Comment typo fixes.
@
text
@d1950 4
@


1.81
log
@Support for Toshiba MeP and for complex relocations.
@
text
@d2944 1
a2944 1
   may bee a recursive function, since it might be called for non-leaf
d2946 2
a2947 2
   returning string, so should free() it eventually.  Errors are
   indicated via as_bad() and a NULL return value.  The given symbol
@


1.80
log
@	* symbols.c (resolve_symbol_value): Formatting.
@
text
@d884 63
d1049 47
d2940 216
@


1.79
log
@gas/
2006-11-15  Jan Beulich  <jbeulich@@novell.com>

	PR/3469
	* symbols.c (symbol_clone): Mark symbol ending up not on symbol
	chain by linking it to itself.
	(resolve_symbol_value): Also check symbol_shadow_p().
	(symbol_shadow_p): New.
	* symbols.h (symbol_shadow_p): Declare.

gas/testsuite/
2006-11-15  Jan Beulich  <jbeulich@@novell.com>

	* gas/elf/equ-reloc.[sd]: New.
	* gas/elf/elf.exp: Run new test.
@
text
@d1083 3
a1085 3
	  else if (finalize_syms &&
		   ((final_seg == expr_section && seg_left != expr_section) ||
		    symbol_shadow_p (symp)))
@


1.78
log
@	* symbols.c (symbol_create, symbol_clone): Don't set udata.p.
@
text
@d601 1
a601 1
      orgsymP->sy_next = NULL;
d606 2
d1083 3
a1085 2
	  else if (finalize_syms && final_seg == expr_section
		   && seg_left != expr_section)
d2498 11
@


1.77
log
@	* as.h (as_perror): Delete declaration.
	* gdbinit.in (as_perror): Delete breakpoint.
	* messages.c (as_perror): Delete function.
	* doc/internals.texi: Remove as_perror description.
	* listing.c (listing_print: Don't use as_perror.
	* output-file.c (output_file_create, output_file_close): Likewise.
	* symbols.c (symbol_create, symbol_clone): Likewise.
	* write.c (write_contents): Likewise.
	* config/obj-som.c (obj_som_version, obj_som_copyright): Likewise.
	* config/tc-tic54x.c (tic54x_mlib): Likewise.
@
text
@a147 1
  symbolP->bsym->udata.p = (PTR) symbolP;
a576 1
  bsymnew->udata.p = (PTR) newsymP;
@


1.76
log
@	* symbols.c (report_op_error): Fix pasto.  Don't use as_bad_where
	when file and line unknown.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003, 2004, 2005
d147 1
a147 1
    as_perror ("%s", "bfd_make_empty_symbol");
d573 1
a573 1
    as_perror ("%s", "bfd_make_empty_symbol");
@


1.75
log
@	* listing.c (listing_listing): Remove useless loop.
	* macro.c (macro_expand): Remove is_positional local variable.
	* read.c (s_comm_internal): Simplify `if' condition 1 || x -> 1
	and simplify surrounding expressions, where possible.
	(assign_symbol): Likewise.
	(s_weakref): Likewise.
	* symbols.c (colon): Likewise.
@
text
@d928 2
a929 3
	    as_bad_where (file, line,
			  _("invalid sections for operation on `%s' and `%s' setting `%s'"),
			  S_GET_NAME (left), S_GET_NAME (right), S_GET_NAME (symp));
d931 2
a932 3
	    as_bad_where (file, line,
			  _("invalid section for operation on `%s' setting `%s'"),
			  S_GET_NAME (left), S_GET_NAME (symp));
@


1.74
log
@gas/

2006-01-09  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/2117
	* symbols.c (snapshot_symbol): Don't change a defined symbol.

gas/testsuite/

2006-01-09  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/2117
	* gas/ia64/ia64.exp: Add ltoff22x-2, ltoff22x-3, ltoff22x-4 and
	ltoff22x-5.

	* gas/ia64/ltoff22x-2.d: New file.
	* gas/ia64/ltoff22x-2.s: Likewise.
	* gas/ia64/ltoff22x-3.d: Likewise.
	* gas/ia64/ltoff22x-3.s: Likewise.
	* gas/ia64/ltoff22x-4.d: Likewise.
	* gas/ia64/ltoff22x-4.s: Likewise.
	* gas/ia64/ltoff22x-5.d: Likewise.
	* gas/ia64/ltoff22x-5.s: Likewise.
@
text
@d339 1
a339 4
	  if (S_IS_VOLATILE (symbolP)
	      /* This could be avoided when the symbol wasn't used so far, but
		 the comment in struc-symbol.h says this flag isn't reliable.  */
	      && (1 || !symbol_used_p (symbolP)))
@


1.74.4.1
log
@	* symbols.c (report_op_error): Fix pasto.  Don't use as_bad_where
	when file and line unknown.
@
text
@d931 3
a933 2
	    as_bad (_("invalid sections for operation on `%s' and `%s' setting `%s'"),
		    S_GET_NAME (left), S_GET_NAME (right), S_GET_NAME (symp));
d935 3
a937 2
	    as_bad (_("invalid section for operation on `%s' setting `%s'"),
		    S_GET_NAME (left), S_GET_NAME (symp));
@


1.73
log
@gas/
2005-12-22  Jan Beulich  <jbeulich@@novell.com>

	* symbols.h (snapshot_symbol): First parameter is now pointer
	to pointer to symbolS.
	* symbols.c (snapshot_symbol): Likewise. Store resulting symbol
	there. Use symbol_equated_p.
	* expr.c (resolve_expression): Change first argument to
	snapshot_symbol. Track possibly changed add_symbol consistently
	across function. Resolve more special cases with known result.
	Also update final_val when replacing add_symbol.

gas/testsuite/
2005-12-22  Jan Beulich  <jbeulich@@novell.com>

	* gas/all/cond.s: Also check .if works on equates to undefined
	when the expression value can be known without knowing the
	value of the symbol.
	* gas/all/cond.l: Adjust.
	* gas/i386/equ.s: Also check .if works on (equates to)
	registers when the expression value can be known without
	knowing the value of the register.
	* gas/i386/equ.e: Adjust.
@
text
@d1402 4
a1405 1
      *symbolPP = symbolP;
@


1.72
log
@	Bug gas/1948
	* symbols.c (colon): Also check if now_seg is bss_section when a symbol
	is being redefined.
@
text
@d1358 1
a1358 1
snapshot_symbol (symbolS *symbolP, valueT *valueP, segT *segP, fragS **fragPP)
d1360 2
d1390 1
a1390 4
	      /* This check wouldn't be needed if pseudo_set() didn't set
		 symbols equated to bare symbols to undefined_section.  */
	      if (symbolP->bsym->section != undefined_section
		  || symbolP->sy_value.X_op != O_symbol)
d1402 1
@


1.71
log
@gas/
2005-11-17  Jan Beulich  <jbeulich@@novell.com>


	* symbols.h (S_CLEAR_VOLATILE): Declare.
	* symbols.c (colon): Also accept redefinable symbols for
	redefinition. Clone them before modifying.
	(S_CLEAR_VOLATILE): Define.
	* cond.c (s_ifdef): Also test for equated symbols.
	* read.c (s_comm_internal): Also exclude non-redefinable
	equated symbols. Clone redefinable ones before modifying.
	(s_weakref): Clone redefinable symbols before modifying.
	* doc/internals.texi: Document sy_volatile, sy_forward_ref,
	S_IS_VOLATILE, S_SET_VOLATILE, S_CLEAR_VOLATILE,
	S_IS_FORWARD_REF, and S_SET_FORWARD_REF.

gas/testsuite/
2005-11-17  Jan Beulich  <jbeulich@@novell.com>

	* gas/all/cond.s: Also check ifdef works on equates and
	commons.
	* gas/all/cond.l: Adjust.
	* gas/all/redef2.s: Also test redefining equate to label.
	* gas/all/redef2.d: Adjust.
	* gas/all/redef3.[sd]: New.
	* gas/all/redef4.s: New.
	* gas/all/redef5.s: New.
	* gas/elf/redef.s: New, copied from original gas/all/redef2.s.
	* gas/elf/redef.d: Remove #source.
	* gas/all/gas.exp: Remove exclusion of iq2000-*-* from and
	adjust xfails for redefinition tests. Run new tests. Exclude
	alpha*-*-*, mips*-*-*, *c54x*-*-* from weakref tests.
@
text
@d379 1
@


1.70
log
@	* symbols.c (S_GET_VALUE): Remove non-BFD assembler recursion guard.
@
text
@d336 2
a337 1
	       || S_IS_COMMON (symbolP))
d339 9
d434 4
a437 1
	    as_bad (_("symbol `%s' is already defined"), sym_name);
d2203 7
@


1.69
log
@gas/ChangeLog:
* read.c (s_weakref): Do not permit redefinitions.
* symbols.c (colon): Do not permit redefinitions of equated
symbols.
gas/testsuite/ChangeLog:
* gas/all/gas.exp: Remove weakref xfail.  Run weakref4.s.
* gas/all/weakref1.s: Move redefinition bits to...
* gas/all/weakref4.s: ... new file.
* gas/all/weakref1.d: Remove command moved to weakref1u.  Adjust
remaining command for leading tabs.  Regenerate.
* gas/all/weakref1l.d: Regenerate.
* gas/all/weakref1u.d: Likewise.
* gas/all/wealref1w.d: Likewise.
@
text
@a1784 8
      static symbolS *recur;

      /* FIXME: In non BFD assemblers, S_IS_DEFINED and S_IS_COMMON
	 may call S_GET_VALUE.  We use a static symbol to avoid the
	 immediate recursion.  */
      if (recur == s)
	return (valueT) s->sy_value.X_add_number;
      recur = s;
a1789 1
      recur = NULL;
@


1.68
log
@gas/
2005-10-27  Jan Beulich  <jbeulich@@novell.com>

	* read.c (assign_symbol): Also consider equates already defined.
	* symbols.c (symbol_clone): Also clone the underlying BFD symbol.
	* config/obj-coff.h (obj_symbol_clone_hook): New.
	(coff_obj_symbol_clone_hook): Declare.
	* config/obj-coff.c (coff_obj_symbol_clone_hook): New.

gas/testsuite/
2005-10-27  Jan Beulich  <jbeulich@@novell.com>

	* gas/all/gas.exp: Don't xfail equiv1 test anymore.
@
text
@d335 2
a336 1
      else if (!S_IS_DEFINED (symbolP) || S_IS_COMMON (symbolP))
@


1.67
log
@gas/ChangeLog:
* read.c (potable): Add weakref.
(s_weakref): New.
* read.h (s_weakref): Declare.
* struc-symbol.h (struct symbol): Add sy_weakrefr and sy_weakrefd.
* symbols.c (colon): Clear weakrefr.
(symbol_find_exact): Rename to, and reimplement in terms of...
(symbol_find_exact_noref): ... new function.
(symbol_find): Likewise...
(symbol_find_noref): ... ditto.
(resolve_symbol_value): Resolve weakrefr without setting their
values.
(S_SET_WEAK): Call hook.
(S_GET_VALUE): Follow weakref link.
(S_SET_VALUE): Clear weakrefr.
(S_IS_WEAK): Follow weakref link.
(S_IS_WEAKREFR, S_SET_WEAKREFR, S_CLEAR_WEAKREFR): New.
(S_IS_WEAKREFD, S_SET_WEAKREFD, S_CLEAR_WEAKREFD): New.
(symbol_set_value_expression, symbol_set_frag): Clear weakrefr.
(symbol_mark_used): Follow weakref link.
(print_symbol_value_1): Print weak, weakrefr and weakrefd.
* symbols.h (symbol_find_noref, symbol_find_exact_noref): Declare.
(S_IS_WEAKREFR, S_SET_WEAKREFR, S_CLEAR_WEAKREFR): Declare.
(S_IS_WEAKREFD, S_SET_WEAKREFD, S_CLEAR_WEAKREFD): Declare.
* write.c (adust_reloc_syms): Follow weakref link.  Do not
complain if target is undefined.
(write_object_file): Likewise.  Remove weakrefr symbols.  Drop
unreferenced weakrefd symbols.
* config/obj-coff.c (obj_frob_symbol): Do not force WEAKREFD
symbols EXTERNAL.
(pecoff_obj_set_weak_hook, pecoff_obj_clear_weak_hook): New.
* config/obj-coff.h (obj_set_weak_hook, obj_clear_weak_hook): Define.
* doc/as.texinfo: Document weakref.
* doc/internals.texi: Document new struct members, internal
functions and hooks.
gas/testsuite/ChangeLog:
* gas/all/weakref1.s, gas/all/weakref1.d: New test.
* gas/all/weakref1g.d, gas/all/weakref1l.d: New tests.
* gas/all/weakref1u.d, gas/all/weakref1w.d: New tests.
* gas/all/weakref2.s, gas/all/weakref3.s: New tests.
* gas/all/gas.exp: Run new tests.
@
text
@d545 1
d553 1
d559 18
@


1.66
log
@This adjusts equate handling by
- allowing true forward references (which will always assume the referenced
  symbols have at the point of use) through the new .eqv pseudo-op and the
  new == operator
- disallowing changing .equiv-generated equates (so that the protection this
  provides is both forward and backward)
- snapshotting equates when their value gets changed so that previous uses
  don't get affected by the new value.
- allowing expressions in places where absolute expressions (or register
  names) are needed which were not completely resolvable at the point of
  their definition but which are fully resolvable at the point of use

In addition it fixes PR/288.
@
text
@d312 1
d655 6
d662 1
d668 11
a678 1
  return ((symbolS *) hash_find (sy_hash, name));
d684 6
d717 1
a717 1
  return symbol_find_exact (name);
d997 13
d1079 2
d1759 3
d1796 1
d1852 6
d1862 16
d2076 3
d2084 57
d2223 1
d2258 1
d2279 2
d2604 2
d2611 4
@


1.65
log
@	* README-vms: Delete.
	* config-gas.com: Delete.
	* makefile.vms: Delete.
	* vmsconf.sh: Delete.
	* config/atof-tahoe.c: Delete.
	* config/m88k-opcode.h: Delete.
	* config/obj-bout.c: Delete.
	* config/obj-bout.h: Delete.
	* config/obj-hp300.c: Delete.
	* config/obj-hp300.h: Delete.
	* config/tc-a29k.c: Delete.
	* config/tc-a29k.h: Delete.
	* config/tc-h8500.c: Delete.
	* config/tc-h8500.h: Delete.
	* config/tc-m88k.c: Delete.
	* config/tc-m88k.h: Delete.
	* config/tc-tahoe.c: Delete.
	* config/tc-tahoe.h: Delete.
	* config/tc-tic80.c: Delete.
	* config/tc-tic80.h: Delete.
	* config/tc-w65.c: Delete.
	* config/tc-w65.h: Delete.
	* config/te-aux.h: Delete.
	* config/te-delt88.h: Delete.
	* config/te-delta.h: Delete.
	* config/te-dpx2.h: Delete.
	* config/te-hp300.h: Delete.
	* config/te-ic960.h: Delete.
	* config/vms-a-conf.h: Delete.
	* doc/c-a29k.texi: Delete.
	* doc/c-h8500.texi: Delete.
	* doc/c-m88k.texi: Delete.
	* README: Remove obsolete examples, and list of supported targets.
	* Makefile.am: Remove a29k, h8500, m88k, tahoe, tic80, w65,
	bout and hp300 support.
	(DEP_FLAGS): Don't define BFD_ASSEMBLER.
	* configure.in: Remove --enable-bfd-assembler, need_bfd,
	primary_bfd_gas.
	* configure.tgt: Remove a29k, h8300-coff, h8500-*, i960 non-elf,
	m68k non bfd, m88k, or32-coff, tic80-*, vax non-bfd, w65k-*, *-nindy.
	* as.c: Remove all non-BFD_ASSEMBLER code, support for above targets.
	* as.h: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
	* input-file.c: Likewise.
	* listing.c: Likewise.
	* literal.c: Likewise.
	* messages.c: Likewise.
	* obj.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* stabs.c: Likewise.
	* struc-symbol.h: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* symbols.c: Likewise.
	* symbols.h: Likewise.
	* tc.h: Likewise.
	* write.c: Likewise.
	* write.h: Likewise.
	* config/aout_gnu.h: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-aout.h: Likewise.
	* config/obj-coff.c: Likewise.
	* config/obj-coff.h: Likewise.
	* config/obj-evax.h: Likewise.
	* config/obj-ieee.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-crx.h: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-d30v.h: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-fr30.h: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-hppa.h: Likewise.
	* config/tc-i370.h: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i860.h: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ip2k.h: Likewise.
	* config/tc-iq2000.h: Likewise.
	* config/tc-m32c.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m68k.h: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-maxq.h: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mn10200.h: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-mn10300.h: Likewise.
	* config/tc-ms1.h: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-msp430.h: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-ns32k.h: Likewise.
	* config/tc-openrisc.h: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.h: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic4x.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-vax.h: Likewise.
	* config/tc-xstormy16.h: Likewise.
	* config/tc-xtensa.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-z8k.h: Likewise.
	* config/vms-a-conf.h
	* doc/Makefile.am: Likewise.
	* doc/all.texi: Likewise.
	* doc/as.texinfo: Likewise.
	* doc/Makefile.in: Regenerate.
	* Makefile.in: Regenerate.
	* configure: Regenerate.
	* config.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d541 88
d1280 65
d1903 16
d2044 16
@


1.64
log
@* config/tc-v850,h (TC_FIX_TYPE): Define. (TC_INIT_FIX_TYPE): Define.
* config/tc-v850.c (md_assemble): When creating a fix record the operand in the
    tc_fix_data field.
    (md_apply_fix3): When applying a resolved fix use the operand's insertion
    procedure to store the value, if the operand has been recorded.
* gas/v850/split-lo16.s: Add test for a lo() pseudo reloc corrupting an ld.w
    instruction.
* gas/v850/split-lo16.d: Add expected, correct (ie not corrupt) output.
@
text
@a90 1
#ifdef BFD_ASSEMBLER
a95 1
#endif
a144 1
#ifdef BFD_ASSEMBLER
a148 1
#endif
a155 4
#ifndef BFD_ASSEMBLER
  symbolP->sy_number = ~0;
  symbolP->sy_name_offset = (unsigned int) ~0;
#endif
a165 1
#ifdef BFD_ASSEMBLER
a248 7

#else /* ! BFD_ASSEMBLER */

#define LOCAL_SYMBOL_CHECK(s) 0
#define local_symbol_convert(s) ((symbolS *) s)

#endif /* ! BFD_ASSEMBLER */
d264 3
a266 13
  if (LOCAL_LABELS_DOLLAR)
    {
      int local;

#ifdef BFD_ASSEMBLER
      local = bfd_is_local_label_name (stdoutput, sym_name);
#else
      local = LOCAL_LABEL (sym_name);
#endif

      if (! local)
	dollar_label_clear ();
    }
a318 1
#ifdef BFD_ASSEMBLER
a332 1
#endif
a402 1
#ifdef BFD_ASSEMBLER
a403 1
#endif
a425 1
#ifdef BFD_ASSEMBLER
a431 1
#endif /* BFD_ASSEMBLER */
a505 1
#ifdef BFD_ASSEMBLER
a516 1
#endif
d566 1
a566 3
#ifdef BFD_ASSEMBLER
  {
    struct local_symbol *locsym;
d568 3
a570 5
    locsym = (struct local_symbol *) hash_find (local_hash, name);
    if (locsym != NULL)
      return (symbolS *) locsym;
  }
#endif
a629 1
#ifdef SYMBOLS_NEED_BACKPOINTERS
a630 1
#endif
a637 1
#ifdef SYMBOLS_NEED_BACKPOINTERS
a638 1
#endif /* SYMBOLS_NEED_BACKPOINTERS */
a647 2

#ifdef SYMBOLS_NEED_BACKPOINTERS
a648 1
#endif /* SYMBOLS_NEED_BACKPOINTERS */
a660 1
#ifdef SYMBOLS_NEED_BACKPOINTERS
a661 1
#endif
a663 1
#ifdef SYMBOLS_NEED_BACKPOINTERS
a722 2
#endif /* SYMBOLS_NEED_BACKPOINTERS */

a732 1
#ifdef BFD_ASSEMBLER
a733 2
#endif
#ifdef SYMBOLS_NEED_BACKPOINTERS
a734 4
#else
      /* Walk the list anyways, to make sure pointers are still good.  */
      ;
#endif /* SYMBOLS_NEED_BACKPOINTERS */
a805 1
#ifdef BFD_ASSEMBLER
a823 1
#endif
d909 1
a909 1
#if defined (OBJ_COFF) && defined (TE_PE) && (defined(BFD_ASSEMBLER) || defined(S_IS_WEAK))
a1154 5
#if defined (OBJ_AOUT) && ! defined (BFD_ASSEMBLER)
  /* The old a.out backend does not handle S_SET_SEGMENT correctly
     for a stab symbol, so we use this bad hack.  */
  if (final_seg != S_GET_SEGMENT (symp))
#endif
a1172 2
#ifdef BFD_ASSEMBLER

a1183 2
#endif

a1188 1
#ifdef BFD_ASSEMBLER
a1189 1
#endif
a1557 1
#ifdef BFD_ASSEMBLER
a1559 1
#endif
a1591 1
#ifdef BFD_ASSEMBLER
a1596 1
#endif
a1610 1
#ifdef BFD_ASSEMBLER
a1614 1
#endif
a1620 2
#ifdef BFD_ASSEMBLER

a1873 3
#endif /* BFD_ASSEMBLER */

#ifdef SYMBOLS_NEED_BACKPOINTERS
a1884 2
#endif /* SYMBOLS_NEED_BACKPOINTERS */

a1919 1
#ifdef BFD_ASSEMBLER
a1921 1
#endif
a1940 1
#ifdef BFD_ASSEMBLER
a1945 1
#endif
a1953 1
#ifdef BFD_ASSEMBLER
a1955 1
#endif
a2083 1
#ifdef BFD_ASSEMBLER
a2088 1
#endif
a2096 1
#ifdef BFD_ASSEMBLER
a2098 1
#endif
a2108 1
#ifdef BFD_ASSEMBLER
a2109 4
#else
  /* FIXME.  */
  return 0;
#endif
d2134 1
a2134 1
#if defined (OBJ_COFF) && defined (TE_PE) && (defined(BFD_ASSEMBLER) || defined(S_IS_WEAK))
a2151 2
#ifdef BFD_ASSEMBLER

a2180 2
#endif /* BFD_ASSEMBLER */

a2234 1
#ifdef BFD_ASSEMBLER
a2235 1
#endif
a2237 1
#ifdef BFD_ASSEMBLER
a2240 4
#else
  /* Can't initialise a union. Sigh.  */
  S_SET_SEGMENT (&abs_symbol, absolute_section);
#endif
a2263 1
#ifdef BFD_ASSEMBLER
a2270 1
#endif
a2308 1
#ifdef BFD_ASSEMBLER
a2312 1
#endif
a2462 1
#ifdef BFD_ASSEMBLER
a2465 1
#endif
@


1.63
log
@Update the address and phone number of the FSF
@
text
@d909 1
d1095 1
d1102 2
a1103 6
	     supports arbitrary expressions, such as IEEE-695.

	     Don't emit messages unless we're finalizing the symbol value,
	     otherwise we may get the same message multiple times.  */
	  if (finalize_syms
	      && !(seg_left == absolute_section
d1111 12
a1122 1
	    report_op_error (symp, add_symbol, op_symbol);
d1124 2
a1125 1
	  if (final_seg == expr_section || final_seg == undefined_section)
@


1.62
log
@	* Makefile.am (GAS_CFILES): Remove bignum-copy.c.
	(GENERIC_OBJS): Likewise, remove bignum-copy.o.
	(bignum-copy.o): Remove.
	* Makefile.in: Regenerate.
	* makefile.vms (OBJS): Remove bignum-copy.obj.
	* symbols.h (local_symbol_make): Remove declaration.
	(verify_symbol_chain_2): Likewise.
	* symbols.c (local_symbol_make): Make static.
	(max_indent_level): Likewise.
	(verify_symbol_chain_2): Remove.
	* macro.c (macro_hash): Make static.
	* messages.c (fprint_value): Remove.
	* read.h (get_absolute_expr): Remove.
	(emit_leb128_expr): Likewise.
	(do_s_func): Likewise.
	* read.c (do_s_func): Make static.
	(emit_leb128_expr): Likewise.
	(get_absolute_expr): Likewise.
	* as.h (as_howmuch): Remove declaration.
	(fprint_value): Likewise.
	* as.c (myname): Make static.
	* input-scrub.c (as_howmuch): Remove.
	(as_1_char): Likewise.
	* input-file.h (input_file_is_open): Remove.
	* input-file.c (input_file_is_open): Likewise.
	* expr.h (expr_build_unary): Remove declaration.
	(expr_build_binary): Likewise.
	* expr.c (expr_build_unary): Remove.
	(expr_build_binary): Likewise.
	* hash.h (hash_replace): Remove declaration.
	(hash_delete): Likewise.
	* hash.c (hash_replace): Remove.
	(hash_delete): Likewise.
	* bignum-copy.c (bignum_copy): Move from here ..
	* config/tc-vax.c (bignum_copy): .. to here.
	* bignum.h (LOG_TO_BASE_2_OF_10): Remove.
	(bignum_copy): Remove extern declaration.
	* sb.h (string_count): Remove extern declaration.
	(sb_build, sb_add_buffer, sb_print, sb_print_at): Likewise.
	(sb_name): Likewise.
	* sb.c (dsize): Replace preprocessor macro with static int.
	(string_count): Make static.
	(sb_build, sb_add_buffer, sb_print, sb_print_at): Likewise.
	(sb_name): Likewise.
	* config/obj-coff.c (dim_index): Make static.
	* config/tc-i386.c (GOT_symbol): Likewise.
	(output_invalid_buf): Likewise.
	* doc/internals.texi (Warning and error messages): Remove the
	prototype for fprint_value.
@
text
@d20 2
a21 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.61
log
@2005-04-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-aout.h (S_IS_EXTERN): Removed.
	* config/obj-bout.h (S_IS_EXTERN): Likewise.
	* config/obj-coff.h (S_IS_EXTERN): Likewise.
	* symbols.c (S_IS_EXTERN): Likewise.
	* symbols.h (S_IS_EXTERN): Likewise.

	* config/tc-alpha.c (tc_gen_reloc): Replace S_IS_EXTERN with
	S_IS_EXTERNAL.
	* config/tc-d10v.c (md_apply_fix3): Likewise.
	* config/tc-ia64.c (ia64_fix_adjustable): Likewise.
	* config/tc-iq2000.c (iq2000_fix_adjustable): Likewise.
	* config/tc-m32r.c (m32r_fix_adjustable): Likewise.
	* config/tc-mmix.c (mmix_adjust_symtab): Likewise.
	* config/tc-sh64.c (shmedia_frob_file_before_adjust): Likewise.
	(shmedia_md_convert_frag): Likewise.
	* symbols.c (print_symbol_value_1): Likewise.
	* write.c (write_object_file): Likewise.
@
text
@d200 1
a200 1
struct local_symbol *
a796 13
void
verify_symbol_chain_2 (symbolS *sym)
{
  symbolS *p = sym, *n = sym;
#ifdef SYMBOLS_NEED_BACKPOINTERS
  while (symbol_previous (p))
    p = symbol_previous (p);
#endif
  while (symbol_next (n))
    n = symbol_next (n);
  verify_symbol_chain (p, n);
}

d2351 1
a2351 1
int max_indent_level = 8;
@


1.60
log
@gas/
2005-04-19  Jan Beulich  <jbeulich@@novell.com>

	* symbols.h (symbol_find_base): Remove prototype.
	* symbols.c (save_symbol_name): Remove code section conditional upon
	STRIP_UNDERSCORE.
	(symbol_find): Remove.
	(symbol_find_base): Rename to symbol_find.
	* subsegs.c (section_symbol): Replace use of symbol_find_base with
	symbol_find.
	* config/obj-coff.c (tag_insert): Remove code section conditional
	upon STRIP_UNDERSCORE.
	(obj_coff_def): Likewise.
	(obj_coff_endef): Replace use of symbol_find_base with symbol_find.
	(coff_frob_symbol): Likewise.
	(yank_symbols): Likewise.
	(c_section_symbol): Likewise.
	* config/obj-coff.h (DO_NOT_STRIP): Remove.
	* config/tc-arm.c (symbol_locate): Remove code section conditional
	upon STRIP_UNDERSCORE.
	* config/tc-h8300.h (DO_NOT_STRIP): Remove.
	* config/tc-h8500.h (DO_NOT_STRIP): Remove.
	* config/tc-sh.h (DO_NOT_STRIP): Remove.
	* config/tc-w65.h (DO_NOT_STRIP): Remove.
	* config/tc-z8k.h (DO_NOT_STRIP): Remove.
@
text
@a1825 6
S_IS_EXTERN (symbolS *s)
{
  return S_IS_EXTERNAL (s);
}

int
d2402 1
a2402 1
      if (S_IS_EXTERN (sym))
@


1.59
log
@	* symbols.c (symbol_X_add_number): Change return type to "offsetT *".
	* symbols.h (symbol_X_add_number): Update prototype.
@
text
@a115 5
#ifdef STRIP_UNDERSCORE
  if (ret[0] == '_')
    ++ret;
#endif

a597 10
symbol_find (const char *name)
{
#ifdef STRIP_UNDERSCORE
  return (symbol_find_base (name, 1));
#else /* STRIP_UNDERSCORE */
  return (symbol_find_base (name, 0));
#endif /* STRIP_UNDERSCORE */
}

symbolS *
d614 1
a614 1
symbol_find_base (const char *name, int strip_underscore)
a615 3
  if (strip_underscore && *name == '_')
    name++;

@


1.58
log
@2005-04-10  Eric Christopher  <echristo@@redhat.com>

        * symbols.c (symbol_X_add_number): Fix warning.
@
text
@d2027 1
a2027 1
valueT *
d2032 1
a2032 1
    return &((struct local_symbol *) s)->lsy_value;
d2035 1
a2035 1
  return (valueT *)&s->sy_value.X_add_number;
@


1.57
log
@	PR gas/827
	* as.h (rs_dummy): Define.
	* symbols.c (symbol_X_add_number): New function.
	* symbols.h (symbol_X_add_number): Declare.
	* stabs.c (aout_process_stab): Tidy symbol frag setting.
	* read.c (assign_symbol): New function, split out from s_set.
	Use symbol_find_or_make.  Leave fr_type of dummy frag as rs_dummy.
	Fix COFF hacks for multi-emulation gas.
	(s_set): Call assign_symbol.  Remove "register" keyword.
	(set_zero_frag): New function.
	(pseudo_set): Always check for assignment to section syms.
	Always set segment and frag of symbol, and likewise extern for
	aout/bout.  Handle assignment of sym=sym+/-const specially.  Don't
	special case exp.X_add_number non-zero for O_symbol expressions.
	(equals): Use assign_symbol.
@
text
@d2035 1
a2035 1
  return &s->sy_value.X_add_number;
@


1.56
log
@	* symbols.c (fb_label_name): Fix silly thinko in last change.
@
text
@d2025 13
@


1.56.2.1
log
@	PR gas/827
	* as.h (rs_dummy): Define.
	* symbols.c (symbol_X_add_number): New function.
	* symbols.h (symbol_X_add_number): Declare.
	* stabs.c (aout_process_stab): Tidy symbol frag setting.
	* read.c (assign_symbol): New function, split out from s_set.
	Use symbol_find_or_make.  Leave fr_type of dummy frag as rs_dummy.
	(s_set): Call assign_symbol.  Remove "register" keyword.
	(set_zero_frag): New function.
	(pseudo_set): Always check for assignment to section syms.
	Always set segment and frag of symbol, and likewise extern for
	aout/bout.  Handle assignment of sym=sym+/-const specially.  Don't
	special case exp.X_add_number non-zero for O_symbol expressions.
	(equals): Use assign_symbol.
@
text
@a2024 13
/* Return a pointer to the X_add_number component of a symbol.  */

offsetT *
symbol_X_add_number (symbolS *s)
{
#ifdef BFD_ASSEMBLER
  if (LOCAL_SYMBOL_CHECK (s))
    return (offsetT *) &((struct local_symbol *) s)->lsy_value;
#endif

  return &s->sy_value.X_add_number;
}

@


1.55
log
@	* symbols.c (fb_label_name): Allow an augend of 2 for mmix.
also fix last changelog entry.
@
text
@a1563 1
  know (
d1565 1
a1565 1
	(unsigned long) augend <= 2 /* See mmix_fb_label.  */
d1567 1
a1567 1
	(unsigned long) augend <= 1
a1568 1
	);
@


1.54
log
@	* as.h: Remove #if 0'd code.
	* atof-generic.c (atof_generic): Likewise.
	* ecoff.c (ecoff_directive_frame): Likewise.
	* frags.h (FRAG_APPEND_1_CHAR): Likewise.
	* itbl-ops.c (itbl_add_reg): Likewise.
	* listing.c (calc_hex): Likewise.
	* read.c (MASK_CHAR): Likewise.
	* subsegs.c (subsegs_print_statistics): Likewise.
	* symbols.c (indent): Likewise.
	* write.c (write_relocs): Likewise.
	(write_object_file): Likewise.
	(relax_frag): Likewise.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003, 2004
d1564 7
a1570 1
  know (augend == 0 || augend == 1);
@


1.53
log
@2004-11-08  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 528
	* symbols.c (resolve_symbol_value): Convert weak symbols only
	for Windows PECOFF.
	(symbol_equated_reloc_p): Don't equate weaks when relocating
	only for Windows PECOFF.
@
text
@a2372 10
#if 0

static void
indent (void)
{
  printf ("%*s", indent_level * 4, "");
}

#endif

@


1.52
log
@Fix support for PECOFF weak symbols
@
text
@d998 1
a998 1
#if defined(BFD_ASSEMBLER) || defined(S_IS_WEAK)
d2242 1
a2242 1
#if defined(BFD_ASSEMBLER) || defined(S_IS_WEAK)
@


1.51
log
@	* symbols.c (colon) [!WORKING_DOT_WORD]: Don't declare
	md_short_jump_size, md_long_jump_size.
	* write.c [!WORKING_DOT_WORD]: Ditto.
	* tc.h [!WORKING_DOT_WORD]: Declare them here.  Drop const
	qualifier.
	* config/tc-cris.h (md_short_jump_size, md_long_jump_size): Don't
	declare.
	* config/tc-cris.c (md_short_jump_size, md_long_jump_size): Drop
	const qualifier in these definitions.
	* config/tc-i370.c, config/tc-m68k.c, config/tc-pdp11.c,
	config/tc-s390.c, config/tc-tahoe.c, config/tc-vax.c: Ditto.
@
text
@d62 5
d997 5
a1001 1
	  if (! S_IS_DEFINED (add_symbol) || S_IS_COMMON (add_symbol))
d1917 5
d1966 1
a1966 1
S_SET_NAME (symbolS *s, char *name)
d2242 3
@


1.50
log
@* gas/symbols.c: While discarding ordinary local absolute symbols
  when --strip-local-absolute is in effect, retain file symbols.
@
text
@a301 3
      extern const int md_short_jump_size;
      extern const int md_long_jump_size;

@


1.49
log
@Apply H.J.'s patch to fix label arithmetic when multiple same-name sections are involved
@
text
@d1815 3
a1817 1
      && (flags & BSF_GLOBAL) == 0
@


1.48
log
@	* symbols.c: Convert to ISO-C.
	* symbols.h: Likewise.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003
d2263 10
a2272 1
  s->bsym = bsym;
@


1.47
log
@	* ChangeLog: Fix typos.
	* ChangeLog-9295: Likewise.
	* as.c: Fix comment typos.
	* as.h: Likewise.
	* atof-generic.c: Likewise.
	* bit_fix.h: Likewise.
	* frags.h: Likewise.
	* hash.c: Likewise.
	* input-file.c: Likewise.
	* input-scrub.c: Likewise.
	* itbl-ops.c: Likewise.
	* itbl-parse.y: Likewise.
	* listing.c: Likewise.
	* macro.h: Likewise.
	* read.c: Likewise.
	* sb.c: Likewise.
	* sb.h: Likewise.
	* symbols.c: Likewise.
	* symbols.h: Likewise.
@
text
@d63 4
a66 4
static char *save_symbol_name PARAMS ((const char *));
static void fb_label_init PARAMS ((void));
static long dollar_label_instance PARAMS ((long));
static long fb_label_instance PARAMS ((long));
d68 2
a69 2
static void print_binary PARAMS ((FILE *, const char *, expressionS *));
static void report_op_error PARAMS ((symbolS *, symbolS *, symbolS *));
d81 1
a81 5
symbol_new (name, segment, valu, frag)
     const char *name;
     segT segment;
     valueT valu;
     fragS *frag;
d102 1
a102 2
save_symbol_name (name)
     const char *name;
d132 4
a135 5
symbol_create (name, segment, valu, frag)
     const char *name;		/* It is copied, the caller can destroy/modify.  */
     segT segment;		/* Segment identifier (SEG_<something>).  */
     valueT valu;		/* Symbol value.  */
     fragS *frag;		/* Associated fragment.  */
d179 1
a179 1
static symbolS *local_symbol_convert PARAMS ((struct local_symbol *));
d201 1
a201 5
local_symbol_make (name, section, value, frag)
     const char *name;
     segT section;
     valueT value;
     fragS *frag;
d226 1
a226 2
local_symbol_convert (locsym)
     struct local_symbol *locsym;
d272 3
a274 3
colon (sym_name)		/* Just seen "x:" - rattle symbols & frags.  */
     const char *sym_name;	/* Symbol name, as a cannonical string.  */
     /* We copy this string: OK to alter later.  */
d505 1
a505 2
symbol_table_insert (symbolP)
     symbolS *symbolP;
d533 1
a533 2
symbol_find_or_make (name)
     const char *name;
d564 1
a564 2
symbol_make (name)
     const char *name;
d578 1
a578 4
symbol_temp_new (seg, ofs, frag)
     segT seg;
     valueT ofs;
     fragS *frag;
d584 1
a584 1
symbol_temp_new_now ()
d590 1
a590 1
symbol_temp_make ()
d601 1
a601 2
symbol_find (name)
     const char *name;
d611 1
a611 2
symbol_find_exact (name)
     const char *name;
d627 1
a627 3
symbol_find_base (name, strip_underscore)
     const char *name;
     int strip_underscore;
d671 2
a672 5
symbol_append (addme, target, rootPP, lastPP)
     symbolS *addme;
     symbolS *target;
     symbolS **rootPP;
     symbolS **lastPP;
d717 1
a717 2
symbol_clear_list_pointers (symbolP)
     symbolS *symbolP;
d731 1
a731 4
symbol_remove (symbolP, rootPP, lastPP)
     symbolS *symbolP;
     symbolS **rootPP;
     symbolS **lastPP;
d762 2
a763 5
symbol_insert (addme, target, rootPP, lastPP)
     symbolS *addme;
     symbolS *target;
     symbolS **rootPP;
     symbolS **lastPP ATTRIBUTE_UNUSED;
d790 1
a790 3
verify_symbol_chain (rootP, lastP)
     symbolS *rootP;
     symbolS *lastP;
d814 1
a814 2
verify_symbol_chain_2 (sym)
     symbolS *sym;
d827 1
a827 3
report_op_error (symp, left, right)
     symbolS *symp;
     symbolS *left, *right;
d886 1
a886 2
resolve_symbol_value (symp)
     symbolS *symp;
d1254 1
a1254 1
static void resolve_local_symbol PARAMS ((const char *, PTR));
d1259 1
a1259 3
resolve_local_symbol (key, value)
     const char *key ATTRIBUTE_UNUSED;
     PTR value;
d1270 1
a1270 1
resolve_local_symbol_values ()
d1291 1
a1291 2
dollar_label_defined (label)
     long label;
d1306 1
a1306 2
dollar_label_instance (label)
     long label;
d1322 1
a1322 1
dollar_label_clear ()
d1330 1
a1330 2
define_dollar_label (label)
     long label;
d1380 2
a1381 3
dollar_label_name (n, augend)
     register long n;		/* we just saw "n$:" : n a number.  */
     register int augend;	/* 0 for current instance, 1 for new instance.  */
d1453 1
a1453 1
fb_label_init ()
d1461 1
a1461 2
fb_label_instance_inc (label)
     long label;
d1509 1
a1509 2
fb_label_instance (label)
     long label;
d1547 2
a1548 3
fb_label_name (n, augend)
     long n;			/* We just saw "n:", "nf" or "nb" : n a number.  */
     long augend;		/* 0 for nb, 1 for n:, nf.  */
d1596 1
a1596 2
decode_local_label_name (s)
     char *s;
d1637 1
a1637 2
S_GET_VALUE (s)
     symbolS *s;
d1673 1
a1673 3
S_SET_VALUE (s, val)
     symbolS *s;
     valueT val;
d1689 1
a1689 2
copy_symbol_attributes (dest, src)
     symbolS *dest, *src;
d1711 1
a1711 2
S_IS_FUNCTION (s)
     symbolS *s;
d1724 1
a1724 2
S_IS_EXTERNAL (s)
     symbolS *s;
d1741 1
a1741 2
S_IS_WEAK (s)
     symbolS *s;
d1749 1
a1749 2
S_IS_COMMON (s)
     symbolS *s;
d1757 1
a1757 2
S_IS_DEFINED (s)
     symbolS *s;
d1773 1
a1773 3
S_FORCE_RELOC (s, strict)
     symbolS *s;
     int strict;
d1787 1
a1787 2
S_IS_DEBUG (s)
     symbolS *s;
d1797 1
a1797 2
S_IS_LOCAL (s)
     symbolS *s;
d1832 1
a1832 2
S_IS_EXTERN (s)
     symbolS *s;
d1838 1
a1838 2
S_IS_STABD (s)
     symbolS *s;
d1844 1
a1844 2
S_GET_NAME (s)
     symbolS *s;
d1852 1
a1852 2
S_GET_SEGMENT (s)
     symbolS *s;
d1860 1
a1860 3
S_SET_SEGMENT (s, seg)
     symbolS *s;
     segT seg;
d1887 1
a1887 2
S_SET_EXTERNAL (s)
     symbolS *s;
d1912 1
a1912 2
S_CLEAR_EXTERNAL (s)
     symbolS *s;
d1926 1
a1926 2
S_SET_WEAK (s)
     symbolS *s;
d1935 1
a1935 2
S_SET_THREAD_LOCAL (s)
     symbolS *s;
d1953 1
a1953 3
S_SET_NAME (s, name)
     symbolS *s;
     char *name;
d1969 1
a1969 2
symbol_previous (s)
     symbolS *s;
d1981 1
a1981 2
symbol_next (s)
     symbolS *s;
d1991 1
a1991 2
symbol_get_value_expression (s)
     symbolS *s;
d2001 1
a2001 3
symbol_set_value_expression (s, exp)
     symbolS *s;
     const expressionS *exp;
d2011 1
a2011 2
symbol_set_value_now (sym)
     symbolS *sym;
d2021 1
a2021 3
symbol_set_frag (s, f)
     symbolS *s;
     fragS *f;
d2036 1
a2036 2
symbol_get_frag (s)
     symbolS *s;
d2048 1
a2048 2
symbol_mark_used (s)
     symbolS *s;
d2058 1
a2058 2
symbol_clear_used (s)
     symbolS *s;
d2068 1
a2068 2
symbol_used_p (s)
     symbolS *s;
d2078 1
a2078 2
symbol_mark_used_in_reloc (s)
     symbolS *s;
d2088 1
a2088 2
symbol_clear_used_in_reloc (s)
     symbolS *s;
d2098 1
a2098 2
symbol_used_in_reloc_p (s)
     symbolS *s;
d2108 1
a2108 2
symbol_mark_mri_common (s)
     symbolS *s;
d2118 1
a2118 2
symbol_clear_mri_common (s)
     symbolS *s;
d2128 1
a2128 2
symbol_mri_common_p (s)
     symbolS *s;
d2138 1
a2138 2
symbol_mark_written (s)
     symbolS *s;
d2148 1
a2148 2
symbol_clear_written (s)
     symbolS *s;
d2158 1
a2158 2
symbol_written_p (s)
     symbolS *s;
d2168 1
a2168 2
symbol_mark_resolved (s)
     symbolS *s;
d2183 1
a2183 2
symbol_resolved_p (s)
     symbolS *s;
d2195 1
a2195 2
symbol_section_p (s)
     symbolS *s ATTRIBUTE_UNUSED;
d2210 1
a2210 2
symbol_equated_p (s)
     symbolS *s;
d2221 1
a2221 2
symbol_equated_reloc_p (s)
     symbolS *s;
d2237 1
a2237 2
symbol_constant_p (s)
     symbolS *s;
d2249 1
a2249 2
symbol_get_bfdsym (s)
     symbolS *s;
d2259 1
a2259 3
symbol_set_bfdsym (s, bsym)
     symbolS *s;
     asymbol *bsym;
d2273 1
a2273 2
symbol_get_obj (s)
     symbolS *s;
d2283 1
a2283 3
symbol_set_obj (s, o)
     symbolS *s;
     OBJ_SYMFIELD_TYPE *o;
d2297 1
a2297 2
symbol_get_tc (s)
     symbolS *s;
d2307 1
a2307 3
symbol_set_tc (s, o)
     symbolS *s;
     TC_SYMFIELD_TYPE *o;
d2317 1
a2317 1
symbol_begin ()
d2351 1
a2351 1
indent ()
d2359 1
a2359 3
print_symbol_value_1 (file, sym)
     FILE *file;
     symbolS *sym;
d2429 1
a2429 2
print_symbol_value (sym)
     symbolS *sym;
d2437 1
a2437 4
print_binary (file, name, exp)
     FILE *file;
     const char *name;
     expressionS *exp;
d2449 1
a2449 3
print_expr_1 (file, exp)
     FILE *file;
     expressionS *exp;
d2561 1
a2561 2
print_expr (exp)
     expressionS *exp;
d2568 1
a2568 2
symbol_print_statistics (file)
     FILE *file;
@


1.46
log
@        * expr.c (make_expr_symbol): Fold FAKE_LABEL_NAME use into the
        symbol_create call.
        (current_location): Use symbol_temp_new_now.
        * stabs.c (s_stab_generic): Use symbol_temp_new.
        * symbols.c (temp_label_name): Remove.
        (symbol_temp_new, symbol_temp_make): Use FAKE_LABEL_NAME.
@
text
@d1467 1
a1467 1
/* Sombody else's idea of local labels. They are made by "n:" where n
@


1.45
log
@        * symbols.c (temp_label_name): New.
        (symbol_temp_new, symbol_temp_new_now, symbol_temp_make): New.
        (symbol_set_value_now): New.
        * symbols.h: Prototype them.
        * dwarf2dbg.c: Use them.
        (fake_label_name, symbol_new_now, set_symbol_value_now): Remove.
@
text
@a590 2
static const char temp_label_name[] = ".L0\001";

d597 1
a597 1
  return symbol_new (temp_label_name, seg, ofs, frag);
d609 1
a609 1
  return symbol_make (temp_label_name);
@


1.44
log
@	* dw2gencfi.c, dw2gencfi.h: New files.
	* config/tc-i386.c (tc_x86_cfi_init): New function.
	* config/tc-i386.h (TARGET_USE_CFIPOP, tc_cfi_init): New defines.
	* as.c (parse_args): Set verbose flag on --verbose.
	(main): Call tc_cfi_init()/cfi_finish().
	* as.h (verbose): New external variable.
	* read.c (pobegin): Insert CFI pops to the list.
	* symbols.c (local_symbol_make): Make symbol external.
	* symbols.h (local_symbol_make): New prototype.
	* Makefile.am: Add dw2gencfi.[ch] files.  Run "make dep-am".
	* Makefile.in: Regenerate.
	* doc/as.texinfo: Added node "CFI directives" with description of
	all implemented .cfi_* directives.
	* doc/Makefile.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d591 23
d2085 11
@


1.43
log
@Update copyright date
@
text
@a184 2
static struct local_symbol *local_symbol_make PARAMS ((const char *, segT,
						       valueT, fragS *));
d206 1
a206 1
static struct local_symbol *
@


1.42
log
@	* symbols.c (S_FORCE_RELOC): Add "strict" param.
	* symbols.h (S_FORCE_RELOC): Likewise.
	* config/obj-aout.h (S_FORCE_RELOC): Likewise.
	* config/obj-bout.h (S_FORCE_RELOC): Likewise.
	* config/obj-coff.h (S_FORCE_RELOC): Likewise.
	* config/obj-ieee.h (S_FORCE_RELOC): Likewise.
	* config/obj-vms.h (S_FORCE_RELOC): Likewise.
	* write.c (generic_force_reloc): New function.
	(TC_FORCE_RELOCATION): Use it here instead of S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	(adjust_reloc_syms): Adjust S_FORCE_RELOC call.
	* as.h (generic_force_reloc): Declare.
	* doc/internals.texi (S_FORCE_RELOC): Update.
	(TC_FORCE_RELOCATION_SUB_SAME): Update.

	* config/tc-alpha.c (alpha_force_relocation): Adjust to use
	generic_force_reloc.
	(alpha_fix_adjustable): Likewise.
	* config/tc-arm.c (arm_force_relocation): Likewise.
	* config/tc-cris.c (md_cris_force_relocation): Likewise.
	* config/tc-frv.c (frv_force_relocation): Likewise.
	* config/tc-i386.c (md_apply_fix3): Likewise.
	* config/tc-ia64.c (ia64_force_relocation): Likewise.
	* config/tc-ip2k.c (ip2k_force_relocation): Likewise.
	* config/tc-m32r.c (m32r_force_relocation): Likewise.
	* config/tc-m68hc11.c (tc_m68hc11_force_relocation): Likewise.
	* config/tc-mcore.c (mcore_force_relocation): Likewise.
	* config/tc-mips.c (mips_force_relocation): Likewise.
	* config/tc-mmix.c (mmix_force_relocation): Likewise.
	* config/tc-ppc.c (ppc_force_relocation): Likewise.
	* config/tc-s390.c (tc_s390_force_relocation): Likewise.
	* config/tc-sh.c (sh_force_relocation): Likewise.
	(md_pcrel_from_section): Likewise.
	* config/tc-sparc.c (tc_gen_reloc): Likewise.
	* config/tc-v850.c (v850_force_relocation): Likewise.
	* config/tc-xstormy16.c (xstormy16_force_relocation): Likewise.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-mcore.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-sparc.h (tc_fix_adjustable): Likewise.

	* config/tc-d10v.c (d10v_force_relocation): Delete.
	* config/tc-d10v.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-dlx.c (md_dlx_force_relocation): Delete.
	* config/tc-dlx.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-fr30.c (fr30_force_relocation): Delete.
	* config/tc-fr30.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-mn10300.c (mn10300_force_relocation): Delete.
	* config/tc-mn10300.h (TC_FORCE_RELOCATION): Don't define.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-i960.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
	* config/tc-hppa.c (hppa_force_relocation): Adjust S_FORCE_RELOC call.
	* config/tc-mips.c (RELAX_BRANCH_TOOFAR): Warning fix.
	* config/tc-mips.h (TC_FORCE_RELOCATION_SUB_SAME): Don't define.
	* config/tc-openrisc.c (openrisc_force_relocation): Delete.
	* config/tc-openrisc.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sparc.c (elf32_sparc_force_relocation): Delete.
	* config/tc-sparc.h (TC_FORCE_RELOCATION): Don't define for ELF.
	* config/tc-i386.c (i386_force_relocation): Delete.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Don't define for
	BFD_ASSEMBLER.
	(EXTERN_FORCE_RELOC): Fix TE_PE and STRICT_PE_FORMAT nesting.
	* config/tc-m68k.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-pj.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sh.h (TC_FORCE_RELOCATION_SUB_ABS): Don't call
	S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-sh64.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002
d323 1
a323 1
      
d494 1
a494 1
         section.  This requires special handling.  */
d850 1
a850 1
  
d873 1
a873 1
      
d1070 1
a1070 1
	    
d1073 1
a1073 1
	  
d1157 1
a1157 1
	  
d1684 2
a1685 2
         may call S_GET_VALUE.  We use a static symbol to avoid the
         immediate recursion.  */
@


1.41
log
@	* symbols.c (report_op_error): New function, broken out of ...
	(resolve_symbol_value): ... here. Use for both monadic and dyadic
	operators.
@
text
@d1810 1
a1810 1
S_FORCE_RELOC (s)
d1812 1
d1817 4
a1820 3
  return ((s->bsym->flags & BSF_WEAK) != 0
	  || (EXTERN_FORCE_RELOC
	      && (s->bsym->flags & BSF_GLOBAL) != 0)
@


1.40
log
@	* symbols.c (S_SET_THREAD_LOCAL): New function.
	* symbols.h (S_SET_THREAD_LOCAL): New prototype.
	* config/tc-i386.c (md_apply_fix3): Call S_SET_THREAD_LOCAL
	for TLS relocations.
	* config/tc-ia64.c (md_apply_fix3): Likewise.
	* config/tc-alpha.c (md_apply_fix3): Likewise.

	* ld-i386/tlsnopic.rd: Change NOTYPE to TLS for UND sg* symbols.
@
text
@d69 1
d841 57
d1063 11
a1081 2
	  if (final_seg == expr_section || final_seg == undefined_section)
	    final_seg = seg_left;
d1147 13
a1159 51
	  if ((op == O_eq || op == O_ne)
	      || ((op == O_subtract
		   || op == O_lt || op == O_le || op == O_ge || op == O_gt)
		  && seg_left == seg_right
		  && (seg_left != undefined_section
		      || add_symbol == op_symbol))
	      || (seg_left == absolute_section
		  && seg_right == absolute_section))
	    {
	      if (final_seg == expr_section || final_seg == undefined_section)
		final_seg = absolute_section;
	    }
	  else if (finalize_syms)
	    {
	      char *file;
	      unsigned int line;

	      if (expr_symbol_where (symp, &file, &line))
		{
		  if (seg_left == undefined_section)
		    as_bad_where (file, line,
				  _("undefined symbol `%s' in operation"),
				  S_GET_NAME (symp->sy_value.X_add_symbol));
		  if (seg_right == undefined_section)
		    as_bad_where (file, line,
				  _("undefined symbol `%s' in operation"),
				  S_GET_NAME (symp->sy_value.X_op_symbol));
		  if (seg_left != undefined_section
		      && seg_right != undefined_section)
		    as_bad_where (file, line,
				  _("invalid section for operation"));
		}
	      else
		{
		  if (seg_left == undefined_section)
		    as_bad (_("undefined symbol `%s' in operation setting `%s'"),
			    S_GET_NAME (symp->sy_value.X_add_symbol),
			    S_GET_NAME (symp));
		  if (seg_right == undefined_section)
		    as_bad (_("undefined symbol `%s' in operation setting `%s'"),
			    S_GET_NAME (symp->sy_value.X_op_symbol),
			    S_GET_NAME (symp));
		  if (seg_left != undefined_section
		      && seg_right != undefined_section)
		    as_bad (_("invalid section for operation setting `%s'"),
			    S_GET_NAME (symp));
		}
	      /* Prevent the error propagating.  */
	      if (final_seg == expr_section || final_seg == undefined_section)
		final_seg = absolute_section;
	    }
@


1.39
log
@symbols.c (colon): Do not allow symbols to be created in the absolute section
if WORKING_DOT_WORD is not defined and new_broken_words would require a new
frag to be created.
@
text
@d1954 19
@


1.38
log
@Do not allow symbols to be created in the absolute section.
@
text
@d290 1
a290 7
  if (now_seg == absolute_section)
    {
      as_bad (_("cannot define symbol `%s' in absolute section"), sym_name);
      return NULL;
    }

    /* Sun local labels go out of scope whenever a non-local symbol is
d316 7
@


1.37
log
@gas reloc rewrite.
@
text
@d290 7
a296 1
  /* Sun local labels go out of scope whenever a non-local symbol is
@


1.36
log
@	* symbols.c (resolve_symbol_value): Initialise final_val.
	* subsegs.c (subsegs_print_statistics): Cast frchp to void *.
@
text
@d1765 22
@


1.35
log
@	* symbols.c: Replace CONST by const throughout.
	(symbol_find_exact): Split out from..
	(symbol_find_base): ..here.
	* symbols.h: Replace CONST by const throughout.
	(symbol_find_exact): Declare.
	* config/obj-elf.c: #include "struc-symbol.h".
	(elf_frob_file): If group name matches an exported symbol, use that
	symbol for the signature and ".group" as the section name.
@
text
@d842 1
a842 1
  valueT final_val;
@


1.34
log
@	* app.c: Fix formatting.
	* as.c: Likewise.
	* ehopt.c: Likewise.
	* expr.c: Likewise.
	* input-file.c: Likewise.
	* listing.c: Likewise.
	* macro.h: Likewise.
	* stabs.c: Likewise.
	* symbols.c: Likewise.
@
text
@d3 1
a3 1
   1999, 2000, 2001
d572 1
a572 1
     CONST char *name;
d592 1
a592 1
     CONST char *name;
d602 17
d620 1
a620 1
     CONST char *name;
d653 1
a653 11
#ifdef BFD_ASSEMBLER
  {
    struct local_symbol *locsym;

    locsym = (struct local_symbol *) hash_find (local_hash, name);
    if (locsym != NULL)
      return (symbolS *) locsym;
  }
#endif

  return ((symbolS *) hash_find (sy_hash, name));
d1826 1
a1826 1
CONST char *
@


1.33
log
@	* as.h: Fix formatting.
	* cgen.c: Likewise.
	* cgen.h: Likewise.
	* dwarf2dbg.c: Likewise.
	* frags.h: Likewise.
	* gasp.c: Likewise.
	* macro.c: Likewise.
	* read.c: Likewise.
	* stabs.c: Likewise.
	* symbols.c: Likewise.
@
text
@d2401 1
a2401 1
          && s != expr_section)
@


1.32
log
@	* symbols.c (resolve_symbol_value <O_uminus, O_bit_not,
	O_logical_not>): Derive final_seg from add_symbol.
	<O_multiply..O_logical_or>: More final_seg twiddles.
@
text
@d442 3
a444 3
		    sprintf(od_buf, "%d.%d.",
			    S_GET_OTHER (symbolP),
			    S_GET_DESC (symbolP));
d1881 1
a1881 1
      
@


1.31
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d989 1
d1000 1
a1000 1
	    final_seg = absolute_section;
d1066 13
a1078 9
	  if (op != O_eq && op != O_ne
	      && (seg_left != absolute_section
		  || seg_right != absolute_section)
	      && ((op != O_subtract
		   && op != O_lt && op != O_le && op != O_ge && op != O_gt)
		  || seg_left != seg_right
		  || (seg_left == undefined_section
		      && add_symbol != op_symbol))
	      && finalize_syms)
d1113 3
d1171 9
a1179 1
	    final_seg = absolute_section;
@


1.31.2.1
log
@	Merge from mainline.
	2002-04-03  Alan Modra  <amodra@@bigpond.net.au>
	* symbols.c (resolve_symbol_value <O_uminus, O_bit_not,
	O_logical_not>): Derive final_seg from add_symbol.
	<O_multiply..O_logical_or>: More final_seg twiddles.
@
text
@a988 1
	  seg_left = S_GET_SEGMENT (add_symbol);
d999 1
a999 1
	    final_seg = seg_left;
d1065 9
a1073 13
	  if ((op == O_eq || op == O_ne)
	      || ((op == O_subtract
		   || op == O_lt || op == O_le || op == O_ge || op == O_gt)
		  && seg_left == seg_right
		  && (seg_left != undefined_section
		      || add_symbol == op_symbol))
	      || (seg_left == absolute_section
		  && seg_right == absolute_section))
	    {
	      if (final_seg == expr_section || final_seg == undefined_section)
		final_seg = absolute_section;
	    }
	  else if (finalize_syms)
a1107 3
	      /* Prevent the error propagating.  */
	      if (final_seg == expr_section || final_seg == undefined_section)
		final_seg = absolute_section;
d1163 1
a1163 9
	    {
	      if (seg_left == undefined_section
		  || seg_right == undefined_section)
		final_seg = undefined_section;
	      else if (seg_left == absolute_section)
		final_seg = seg_right;
	      else
		final_seg = seg_left;
	    }
@


1.30
log
@	* expr.c (expr): Move code setting "retval" to the end of the loop,
	and rearrange for efficiency.  For "PIC code" subtraction, use
	"rightseg" rather than recalculating.  For "symbol OP symbol"
	subtract, set "retval" to absolute_section if symbols in same
	section.
	* symbols.c (resolve_symbol_value): Resolve "sym +/- expr" to an
	O_symbol.  Simplify a +/- b code.  Allow equality and non-equality
	comparisons on symbols from any section.  Allow other comparison
	operators as for subtraction.
	(symbol_equated_reloc_p): New predicate function.
	* symbols.h (symbol_equated_reloc_p): Declare.
	* write.c (adjust_reloc_syms): Use symbol_equated_reloc_p.
	(write_relocs): Likewise.
	(write_object_file): Likewise.
	(relax_segment <rs_machine_dependent>): Ensure segment for
	expression syms is set correctly.
	* config/tc-mips.c (md_estimate_size_before_relax): Likewise.
	* config/tc-i386.c (md_assemble <Output jumps>): Don't lose part
	of a complex expression when setting up frag_var.
@
text
@a24 2
#include <ctype.h>

d27 1
d126 1
a126 1
      unsigned char *s;
d128 2
a129 3
      for (s = (unsigned char *) ret; *s != '\0'; s++)
	if (islower (*s))
	  *s = toupper (*s);
d631 1
a631 3
	  if (islower (c))
	    c = toupper (c);
	  *copy++ = c;
d1583 1
a1583 1
  for (label_number = 0, p = s + index + 1; isdigit ((unsigned char) *p); ++p)
d1593 1
a1593 1
  for (instance_number = 0, p++; isdigit ((unsigned char) *p); ++p)
@


1.29
log
@	* symbols.c: Add missing prototypes.
	* config/e-i386elf.c: Likewise.
	* config/e-i386coff.c: Likewise.
	* config/e-i386aout.c: Likewise.
	* config/obj-coff.c: Likewise.
	(def_symbol_in_progress, stack): Move definition.
	* config/obj-elf.c: Add missing prototypes.
	(obj_elf_change_section): Make static.
	(obj_elf_parse_section_letters): Likewise.
	(obj_elf_section_word): Likewise.
	(obj_elf_section_type): Likewise.
@
text
@d917 4
a921 1

d925 2
a926 2
                 relocation routines are going to handle it specially.
                 Don't change the value.  */
d939 6
a944 6
	  /* If we have equated this symbol to an undefined symbol, we
             keep X_op set to O_symbol, and we don't change
             X_add_number.  This permits the routine which writes out
             relocation to detect this case, and convert the
             relocation to be against the symbol to which this symbol
             is equated.  */
a948 1
		  final_seg = S_GET_SEGMENT (add_symbol);
d952 3
d961 18
d983 1
a983 1
		final_seg = S_GET_SEGMENT (add_symbol);
d1034 1
a1034 1
	  if (op == O_add || op == O_subtract)
d1038 1
a1038 6
		  if (op == O_add)
		    final_val += right;
		  else
		    final_val -= right;
		  op = O_symbol;
		  op_symbol = NULL;
d1041 1
a1041 1
	      else if (seg_left == absolute_section && op == O_add)
a1042 1
		  op = O_symbol;
d1046 9
a1054 1
		  op_symbol = NULL;
d1059 9
a1067 7
	  /* Subtraction is permitted if both operands are in the same
	     section.  Otherwise, both operands must be absolute.  We
	     already handled the case of addition or subtraction of a
	     constant above.  This will probably need to be changed
	     for an object file format which supports arbitrary
	     expressions, such as IEEE-695.  */
	  /* Don't emit messages unless we're finalizing the symbol value,
d1069 5
a1073 3
	  if ((seg_left != absolute_section
	       || seg_right != absolute_section)
	      && (op != O_subtract
d1075 2
a1076 1
		  || seg_left == undefined_section)
d1118 1
a1118 1
                 already issued a warning about using a bad symbol.  */
d1147 9
a1155 2
	    case O_eq:	left = left == right ? ~ (offsetT) 0 : 0; break;
	    case O_ne:	left = left != right ? ~ (offsetT) 0 : 0; break;
d2184 18
@


1.28
log
@	* read.c: Standardize error/warning messages - don't capitalise, no
	final period or newline, don't say "ignored" or "zero assumed" for
	as_bad messages.  In some cases, change the wording to that used
	elsewhere for similar messages.
	* app.c, as.c, atof-generic.c, cgen.c, cond.c, depend.c, dwarf2dbg.c,
	  ecoff.c, expr.c, frags.c, input-file.c, input-scrub.c, listing.c,
	  output-file.c, stabs.c, subsegs.c, symbols.c, write.c: Likewise.
	* ecoff.c (ecoff_directive_end): Test for missing name by
	comparing input line pointers rather than reading string.
	(ecoff_directive_ent): Likewise.
	* read.c (s_set): Likewise.
	(s_align): Report a warning rather than an error for
	alignment too large.
	(s_comm): Check for missing symbol name.
	(s_lcomm_internal): Likewise.
	(s_lsym): Likewise.
	(s_globl): Use is_end_of_line instead of looking for '\n'.
	(s_lcomm_internal): Likewise.
	(ignore_rest_of_line): Report a warning rather than an error.
@
text
@d64 1
@


1.27
log
@	* symbols.c (S_GET_VALUE): Don't treat O_constant and local
	symbols specially.  Always resolve, adding fr_address to value.
	* write.c (write_object_file): Don't add fr_address to sym values.
	(relax_frag): Likewise.
	(relax_segment): Likewise.
	* config/obj-ieee.c (do_symbols): Likewise.
	* config/tc-cris.c (md_convert_frag): Likewise.
	* config/tc-fr30.c (md_convert_frag): Likewise.
	* config/tc-i386.c (md_convert_frag): Likewise.
	* config/tc-m32r.c (md_convert_frag): Likewise.
	* config/tc-m68hc11.c (md_convert_frag): Likewise.
	* config/tc-mcore.c (md_convert_frag): Likewise.
	* config/tc-mips.c (mips16_extended_frag): Likewise.
	* config/tc-ns32k.c (md_convert_frag): Likewise.
	* config/tc-m68k.c (md_convert_frag_1): Likewise.
	(BRANCHBWL, BRABSJUNC, BRABSJCOND, BRANCHBW, FBRANCH, DBCCLBR,
	DBCCABSJ, PCREL1632, PCINDEX, ABSTOPCREL): Decrement.
	(md_relax_table): Remove first four entries.  Format.
	(md_estimate_size_before_relax): Remove old_fix.  Don't bother
	setting fr_var.  Simplify byte branch checks.
@
text
@d362 1
a362 1
	      as_bad (_("Symbol %s already defined."), sym_name);
d447 1
a447 1
		  as_bad (_("Symbol \"%s\" is already defined as \"%s\"/%s%ld."),
d461 1
a461 1
	    as_bad (_("Symbol %s already defined."), sym_name);
d524 1
a524 1
	as_fatal (_("Inserting \"%s\" into symbol table failed: %s"),
d531 1
a531 1
      as_fatal (_("Inserting \"%s\" into symbol table failed: %s"),
d876 1
a876 1
	as_bad (_("Symbol definition loop encountered at %s"),
d1055 1
a1055 1
				  _("undefined symbol %s in operation"),
d1059 1
a1059 1
				  _("undefined symbol %s in operation"),
d1069 1
a1069 1
		    as_bad (_("undefined symbol %s in operation setting %s"),
d1073 1
a1073 1
		    as_bad (_("undefined symbol %s in operation setting %s"),
d1078 1
a1078 1
		    as_bad (_("invalid section for operation setting %s"),
d1096 1
a1096 1
		    as_bad (_("division by zero when setting %s"),
d1168 1
a1168 1
	  as_bad (_("can't resolve value for symbol \"%s\""),
d1599 1
a1599 1
	as_bad (_("Attempt to get value of unresolved symbol %s"),
d1835 1
a1835 1
		     _("Section symbols are already global"));
@


1.26
log
@	* struc-symbol.h (struct local_symbol): Rename lsy_offset to
	lsy_value.  Correct typos in comments.
	* symbols.c (local_symbol_make): Update for name change.
	(local_symbol_convert): Likewise.
	(colon): Likewise.
	(S_GET_VALUE): Likewise.
	(S_SET_VALUE): Likewise.
	(print_symbol_value_1): Likewise.
	(resolve_symbol_value): Likewise.  Don't divide local sym values
	by OCTETS_PER_BYTE twice.
@
text
@d1577 1
a1577 1
    return ((struct local_symbol *) s)->lsy_value;
d1580 1
a1580 1
  if (!s->sy_resolved && s->sy_value.X_op != O_constant)
@


1.25
log
@Do not allow .globl to override .section
@
text
@d209 1
a209 1
local_symbol_make (name, section, offset, frag)
d212 1
a212 1
     valueT offset;
d227 1
a227 1
  ret->lsy_offset = offset;
d249 1
a249 1
  ret = symbol_new (locsym->lsy_name, locsym->lsy_section, locsym->lsy_offset,
d360 1
a360 1
		  || locsym->lsy_offset != frag_now_fix ()))
d368 1
a368 1
	  locsym->lsy_offset = frag_now_fix ();
d846 1
d848 1
a848 1
	return locsym->lsy_offset / bfd_octets_per_byte (stdoutput);
d850 1
a850 2
      final_val = (local_symbol_get_frag (locsym)->fr_address
		   + locsym->lsy_offset) / bfd_octets_per_byte (stdoutput);
d854 1
a854 1
	  locsym->lsy_offset = final_val;
d1577 1
a1577 1
    return ((struct local_symbol *) s)->lsy_offset;
d1616 1
a1616 1
      ((struct local_symbol *) s)->lsy_offset = val;
d2344 1
a2344 1
		 (long) ((struct local_symbol *) sym)->lsy_offset);
@


1.24
log
@	* symbols.c (resolve_symbol_value): Always set segment, even when
	not finalizing symbol value.
@
text
@d1827 11
@


1.23
log
@	* symbols.c (resolve_symbol_value): Clear sy_resolving before
	taking exit_dont_set_value.
@
text
@d945 1
a945 1
		  S_SET_SEGMENT (symp, S_GET_SEGMENT (add_symbol));
d1149 1
a1149 2
    {
      S_SET_VALUE (symp, final_val);
d1151 3
d1155 3
a1157 3
      /* The old a.out backend does not handle S_SET_SEGMENT correctly
         for a stab symbol, so we use this bad hack.  */
      if (final_seg != S_GET_SEGMENT (symp))
d1159 1
a1159 2
	S_SET_SEGMENT (symp, final_seg);
    }
a1160 1
exit_dont_set_value:
@


1.22
log
@	* symbols.c (resolve_symbol_value): Remove "finalize" param,
	instead use finalize_syms directly.  Don't treat expressions
	specially with regard to finalize_syms.  Update calls to self.
	(resolve_local_symbol): Update call to resolve_symbol_value.
	(S_GET_VALUE): Likewise.  Return resolve_symbol_value if
	!finalize_syms.
	* symbols.h (resolve_symbol_value): Update prototype.
	* config/obj-aout.c (obj_crawl_symbol_chain): Update call
	to resolve_symbol_value.
	* config/obj-bout.c (obj_crawl_symbol_chain): Likewise.
	* config/obj-coff.c (do_relocs_for): Likewise.
	(yank_symbols): Likewise.
	(fixup_segment): Likewise.
	* config/obj-vms.c (obj_crawl_symbol_chain): Likewise.
	* config/tc-mips.c (md_convert_frag): Likewise.
	* config/tc-ppc.c (ppc_frob_symbol): Likewise.
	(ppc_fix_adjustable): Likewise.
	* dwarf2dbg.c (dwarf2dbg_estimate_size_before_relax): Likewise.
	(dwarf2dbg_convert_frag): Likewise.
	* ehopt.c (eh_frame_estimate_size_before_relax): Likewise.
	(eh_frame_convert_frag): Likewise.
	* expr.c (make_expr_symbol): Likewise.
	* write.c (adjust_reloc_syms): Likewise.
	(write_object_file): Likewise.
	(relax_segment): Likewise.
	(fixup_segment): Likewise.
	(finalize_syms): Init to zero, and update comment.
	(write_object_file): Set finalize_syms to 1 rather than 2.
	* doc/internals.texi (sy_value): Mention finalize_syms.
	(S_GET_VALUE): Remove restriction on when S_GET_VALUE can be called.
@
text
@d952 1
@


1.21
log
@* struc-symbol.h (struct local_symbol): New TC_LOCAL_SYMFIELD_TYPE.
* symbols.c (local_symbol_convert): Call TC_LOCAL_SYMFIELD_CONVERT.
@
text
@d834 1
a834 1
resolve_symbol_value (symp, finalize)
a835 1
     int finalize;
d852 1
a852 1
      if (finalize)
a871 4
  /* Expressions aren't really symbols, so don't finalize their values
     until relaxation is complete.  */
  if (final_seg == expr_section && finalize != 2)
    finalize = 0;
d875 1
a875 1
      if (finalize)
d915 1
a915 1
	  left = resolve_symbol_value (add_symbol, finalize);
d927 1
a927 1
	  if (finalize && final_val == 0)
d943 1
a943 1
	      if (finalize)
d967 1
a967 1
	  left = resolve_symbol_value (add_symbol, finalize);
d1002 2
a1003 2
	  left = resolve_symbol_value (add_symbol, finalize);
	  right = resolve_symbol_value (op_symbol, finalize);
d1045 1
a1045 1
	      && finalize)
d1087 1
a1087 1
	      if (seg_right == absolute_section && finalize)
d1147 1
a1147 1
  if (finalize)
d1161 1
a1161 1
  if (finalize)
d1188 1
a1188 1
    resolve_symbol_value (value, finalize_syms);
d1581 2
a1582 2
      valueT val = resolve_symbol_value (s, finalize_syms);
      if (finalize_syms != 2 && S_GET_SEGMENT (s) == expr_section)
@


1.20
log
@Multi-pass relaxation machinery.
@
text
@d258 4
@


1.19
log
@Fix copyright notices
@
text
@d869 4
d1189 1
a1189 1
    resolve_symbol_value (value, 1);
d1581 5
a1585 1
    resolve_symbol_value (s, 1);
@


1.18
log
@	* symbols.c (decode_local_label_name): Initialize message_format
	only when an error is reported (perf pb due to I18N).
@
text
@d2 2
a3 1
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000, 2001
@


1.17
log
@2001-01-23  Kazu Hirata  <kazu@@hxi.com>

	* as.c: Fix formatting.
	* ehopt.c: Likewise.
	* messages.c: Likewise.
	* stabs.c: Likewise.
	* symbols.c: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
d1533 1
a1533 1
  const char *message_format = _("\"%d\" (instance number %d of a %s label)");
d1557 1
@


1.17.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2001
@


1.17.2.2
log
@Merge from mainline.
@
text
@d1534 1
a1534 1
  const char *message_format;
a1557 1
  message_format = _("\"%d\" (instance number %d of a %s label)");
a1815 11
      return;
    }
  if (s->bsym->flags & BSF_SECTION_SYM)
    {
      char * file;
      unsigned int line;
      
      /* Do not reassign section symbols.  */
      as_where (& file, & line);
      as_warn_where (file, line,
		     _("Section symbols are already global"));
@


1.16
log
@Delete output file upon fatal errors.
Treat multiple defintions of the same symbol as ordinary errors, not fatal ones
@
text
@d1535 1
a1535 1
  
d1540 1
a1540 1
  
@


1.15
log
@Fix local label code to use LOCAL_LABEL_PREFIX
@
text
@d442 1
a442 1
		  as_fatal (_("Symbol \"%s\" is already defined as \"%s\"/%s%ld."),
d456 2
a457 2
	    as_fatal (_("Symbol %s already defined."), sym_name);
	}			/* if this symbol is not yet defined  */
d477 1
a477 1
    }				/* if we have seen this symbol before  */
@


1.14
log
@2000-08-10  Kazu Hirata  <kazu@@hxi.com>

	* symbols.c: Fix formatting.
@
text
@d58 3
d1335 1
a1335 1
  *p++ = 1;			/* ^A  */
d1489 3
d1505 1
a1505 1
  *p++ = 2;			/* ^B  */
d1534 8
a1541 2

  if (s[0] != 'L')
d1544 1
a1544 1
  for (label_number = 0, p = s + 1; isdigit ((unsigned char) *p); ++p)
d1547 1
a1547 1
  if (*p == 1)
d1549 1
a1549 1
  else if (*p == 2)
d1736 2
a1737 2
	  && (strchr (name, '\001')
	      || strchr (name, '\002')
@


1.13
log
@Use bfd_octets_per_byte instead of OCTETS_PER_BYTE
@
text
@d22 1
a22 1
/* #define DEBUG_SYMS / * to debug symbol list maintenance */
d47 1
a47 1
/* Below are commented in "symbols.h". */
d66 1
a66 3
/* symbol_new()
  
   Return a pointer to a new symbol.  Die if we can't make a new
d69 1
a69 1
 
d84 1
a84 3
  /*
   * Link to end of symbol chain.
   */
d107 1
a107 1
  name_length = strlen (name) + 1;	/* +1 for \0 */
d134 4
a137 4
     const char *name;		/* It is copied, the caller can destroy/modify */
     segT segment;		/* Segment identifier (SEG_<something>) */
     valueT valu;		/* Symbol value */
     fragS *frag;		/* Associated fragment */
d146 1
a146 1
  /* symbol must be born in some fixed state.  This seems as good as any. */
d271 4
a275 9
/*
 *			colon()
 *
 * We have just seen "<name>:".
 * Creates a struct symbol unless it already exists.
 *
 * Gripes if we are redefining a symbol incompatibly (and ignores it).
 *
 */
d277 3
a279 3
colon (sym_name)		/* just seen "x:" - rattle symbols & frags */
     const char *sym_name;	/* symbol name, as a cannonical string */
     /* We copy this string: OK to alter later. */
d281 1
a281 1
  register symbolS *symbolP;	/* symbol we are working with */
d321 3
a323 3
      /* We want to store the pointer to where to insert the jump table in the
	 fr_opcode of the rs_broken_word frag.  This requires a little
	 hackery.  */
d343 1
a343 3
      /*
       *	Now check for undefined symbols
       */
d369 1
a369 1
	      S_SET_OTHER(symbolP, const_flag);
d375 1
a375 1
#endif /* if we have one, it better be zero. */
d380 10
a389 10
	      /*
	       *	There are still several cases to check:
	       *		A .comm/.lcomm symbol being redefined as
	       *			initialized data is OK
	       *		A .comm/.lcomm symbol being redefined with
	       *			a larger size is also OK
	       *
	       * This only used to be allowed on VMS gas, but Sun cc
	       * on the sparc also depends on it.
	       */
d398 1
a398 3
		  /*
		   *	Select which of the 2 cases this is
		   */
d401 5
a405 6
		      /*
		       *   New .comm for prev .comm symbol.
		       *	If the new size is larger we just
		       *	change its value.  If the new size
		       *	is smaller, we ignore this symbol
		       */
d418 1
a418 1
		      S_SET_OTHER(symbolP, const_flag);
d421 1
a421 1
		      S_SET_SEGMENT (symbolP, now_seg);	/* keep N_EXT bit */
d445 1
a445 1
	    }			/* if the undefined symbol has no value */
d449 1
a449 1
	  /* Don't blow up if the definition is the same */
d454 1
a454 1
	}			/* if this symbol is not yet defined */
d474 1
a474 1
    }				/* if we have seen this symbol before */
d500 1
d502 1
a502 8
/*
 *			symbol_table_insert()
 *
 * Die if we can't insert the symbol.
 *
 */

void 
d525 2
a526 2
    }				/* on error */
}				/* symbol_table_insert() */
d528 3
a530 6
/*
 *			symbol_find_or_make()
 *
 * If a symbol name does not exist, create it as undefined, and insert
 * it into the symbol table. Return a pointer to it.
 */
d561 1
a561 1
}				/* symbol_find_or_make() */
d569 1
a569 1
  /* Let the machine description default it, e.g. for register names. */
d576 1
a576 1
}				/* symbol_make() */
d578 4
a581 8
/*
 *			symbol_find()
 *
 * Implement symbol table lookup.
 * In:	A symbol's name as a string: '\0' can't be part of a symbol name.
 * Out:	NULL if the name was not in the symbol table, else the address
 *	of a struct symbol associated with that name.
 */
d592 1
a592 1
}				/* symbol_find() */
d644 7
a650 7
/*
 * Once upon a time, symbols were kept in a singly linked list.  At
 * least coff needs to be able to rearrange them from time to time, for
 * which a doubly linked list is much more convenient.  Loic did these
 * as macros which seemed dangerous to me so they're now functions.
 * xoxorich.
 */
d652 1
a652 2
/* Link symbol ADDME after symbol TARGET in the chain. */
void 
d675 1
a675 1
    }				/* if the list is empty */
d687 1
a687 1
    }				/* if we have a next */
d699 3
a701 2
/* Set the chain pointers of SYMBOL to null. */
void 
d714 3
a716 2
/* Remove SYMBOLP from the list. */
void 
d728 1
a728 1
    }				/* if it was the root */
d733 1
a733 1
    }				/* if it was the tail */
d738 1
a738 1
    }				/* if not last */
d743 1
a743 1
    }				/* if not first */
d748 3
a750 2
/* Link symbol ADDME before symbol TARGET in the chain. */
void 
d770 1
a770 1
    }				/* if not first */
d781 1
a781 1
void 
d869 2
a870 1
	as_bad (_("Symbol definition loop encountered at %s"), S_GET_NAME (symp));
d1055 2
a1056 1
		    as_bad_where (file, line, _("invalid section for operation"));
d1124 1
a1124 1
   	  break;
d1160 2
a1161 1
	  as_bad (_("can't resolve value for symbol \"%s\""), S_GET_NAME (symp));
d1209 1
a1209 1
int 
d1221 1
a1221 1
  /* if we get here, label isn't defined */
d1223 1
a1223 1
}				/* dollar_label_defined() */
d1237 2
a1238 2
  /* If we get here, we haven't seen the label before, therefore its instance
     count is zero.  */
d1242 1
a1242 1
void 
d1250 1
a1250 1
void 
d1264 1
a1264 1
  /* if we get to here, we don't have label listed yet. */
d1282 1
a1282 1
    }				/* if we needed to grow */
d1290 1
a1290 13
/*
 *			dollar_label_name()
 *
 * Caller must copy returned name: we re-use the area for the next name.
 *
 * The mth occurence of label n: is turned into the symbol "Ln^Am"
 * where n is the label number and m is the instance number. "L" makes
 * it a label discarded unless debugging and "^A"('\1') ensures no
 * ordinary symbol SHOULD get the same name as a local label
 * symbol. The first "4:" is "L4^A1" - the m numbers begin at 1.
 *
 * fb labels get the same treatment, except that ^B is used in place of ^A.
 */
d1292 10
a1301 1
char *				/* Return local label name. */
d1303 2
a1304 2
     register long n;		/* we just saw "n$:" : n a number */
     register int augend;	/* 0 for current instance, 1 for new instance */
d1307 1
a1307 1
  /* Returned to caller, then copied.  used for created names ("4f") */
d1311 1
a1311 1
  char symbol_name_temporary[20];	/* build up a number, BACKWARDS */
d1321 2
a1322 2
  /* Next code just does sprintf( {}, "%d", n); */
  /* label number */
d1332 1
a1332 1
  *p++ = 1;			/* ^A */
d1334 1
a1334 1
  /* instance number */
d1343 1
a1343 1
  /* The label, as a '\0' ended string, starts at symbol_name_build. */
d1347 16
a1362 17
/*
 * Sombody else's idea of local labels. They are made by "n:" where n
 * is any decimal digit. Refer to them with
 *  "nb" for previous (backward) n:
 *  or "nf" for next (forward) n:.
 *
 * We do a little better and let n be any number, not just a single digit, but
 * since the other guy's assembler only does ten, we treat the first ten
 * specially.
 *
 * Like someone else's assembler, we have one set of local label counters for
 * entire assembly, not one set per (sub)segment like in most assemblers. This
 * implies that one can refer to a label in another segment, and indeed some
 * crufty compilers have done just that.
 *
 * Since there could be a LOT of these things, treat them as a sparse array.
 */
d1372 1
a1372 1
/* this must be more than FB_LABEL_SPECIAL */
d1375 1
a1375 1
static void 
d1379 1
a1379 1
}				/* fb_label_init() */
d1381 3
a1383 2
/* add one to the instance number of this fb label */
void 
d1404 2
a1405 2
	    }			/* if we find it */
	}			/* for each existing label */
d1408 1
a1408 1
  /* if we get to here, we don't have label listed yet. */
d1425 1
a1425 1
    }				/* if we needed to grow */
d1432 1
a1432 1
static long 
d1451 2
a1452 2
	    }			/* if we find it */
	}			/* for each existing label */
d1460 10
a1469 12
/*
 *			fb_label_name()
 *
 * Caller must copy returned name: we re-use the area for the next name.
 *
 * The mth occurence of label n: is turned into the symbol "Ln^Bm"
 * where n is the label number and m is the instance number. "L" makes
 * it a label discarded unless debugging and "^B"('\2') ensures no
 * ordinary symbol SHOULD get the same name as a local label
 * symbol. The first "4:" is "L4^B1" - the m numbers begin at 1.
 *
 * dollar labels get the same treatment, except that ^A is used in place of ^B. */
d1471 1
a1471 1
char *				/* Return local label name. */
d1473 2
a1474 2
     long n;			/* we just saw "n:", "nf" or "nb" : n a number */
     long augend;		/* 0 for nb, 1 for n:, nf */
d1477 1
a1477 1
  /* Returned to caller, then copied.  used for created names ("4f") */
d1481 1
a1481 1
  char symbol_name_temporary[20];	/* build up a number, BACKWARDS */
d1488 2
a1489 2
  /* Next code just does sprintf( {}, "%d", n); */
  /* label number */
d1499 1
a1499 1
  *p++ = 2;			/* ^B */
d1501 1
a1501 1
  /* instance number */
d1510 1
a1510 1
  /* The label, as a '\0' ended string, starts at symbol_name_build. */
d1512 1
a1512 1
}				/* fb_label_name() */
d1514 3
a1516 5
/*
 * decode name that may have been generated by foo_label_name() above.  If
 * the name wasn't generated by foo_label_name(), then return it unaltered.
 * This is used for error messages.
 */
d1652 1
a1652 1
  /* sanity check */
d1709 1
a1709 1
  /* sanity check */
d1788 1
a1788 1
	abort();
d1806 1
a1806 1
  s->bsym->flags &= ~(BSF_LOCAL|BSF_WEAK);
d1821 1
a1821 1
  s->bsym->flags &= ~(BSF_GLOBAL|BSF_WEAK);
d1831 1
a1831 1
  s->bsym->flags &= ~(BSF_GLOBAL|BSF_LOCAL);
d2099 1
a2099 1
  /* FIXME */
d2211 1
a2211 1
  symbol_rootP = NULL;		/* In case we have 0 symbols (!!) */
d2223 1
a2223 1
  /* Can't initialise a union. Sigh. */
a2231 2


d2333 1
a2333 1
     const char * name;
a2477 2

/* end of symbols.c */
@


1.12
log
@octets vs bytes changes for GAS
@
text
@d865 1
a865 1
	return locsym->lsy_offset / OCTETS_PER_BYTE;
d868 1
a868 1
		   + locsym->lsy_offset) / OCTETS_PER_BYTE;
@


1.11
log
@This set of patches add support for aout emulation on the x86
assembler.  ie. You will be able to do "as --em=i386aout" on an x86
linux-elf assembler to generate aout format object files, rather than
using a separate assembler.  The aout emulation is enabled by giving
"--enable-targets=i386-linuxaout" to configure.
Oh yeah, there's a couple of fixes too.  Error messages shouldn't be
passed to printf in the format arg just in case someone puts a `%' in
the message.
@
text
@d865 1
a865 1
	return locsym->lsy_offset;
d868 1
a868 1
		   + locsym->lsy_offset);
d924 1
a924 1
	  final_val += symp->sy_frag->fr_address;
@


1.10
log
@	* config/obj-coff.c (coff_frob_symbol): Always update set_end with
	next_set_end even if the end symbol is being discarded.

	* gasp.c: Add ATTRIBUTE_UNUSED as needed for non-BFD_ASSEMBLER.
	* output-file.c, symbols.c, config/tc-i386.c: Likewise.
	* config/obj-coff.c: Likewise.
	(seg_info_type): Remove.
	(seg_info_off_by_4): Change to array of segT.
	(s_get_segment): Adjust accordingly.
	(obj_pseudo_table): Fully initialize sentinel entry.
@
text
@d2 1
a2 1
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 97, 98, 1999
d440 3
a442 6
#if defined (S_GET_OTHER) && defined (S_GET_DESC)
		  as_fatal (_("Symbol \"%s\" is already defined as \"%s\"/%d.%d.%ld."),
			    sym_name,
			    segment_name (S_GET_SEGMENT (symbolP)),
			    S_GET_OTHER (symbolP), S_GET_DESC (symbolP),
			    (long) S_GET_VALUE (symbolP));
d444 10
a453 1
		  as_fatal (_("Symbol \"%s\" is already defined as \"%s\"/%ld."),
d456 1
a457 1
#endif
@


1.9
log
@oops - omitted from previous delta
@
text
@d2115 1
a2115 1
     symbolS *s;
@


1.8
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Fill in structure initializations.  Add variable
	initializations.  Add casts.
	* dwarf2dbg.c (print_stats): Change i to size_t.
	* listing.c (listing_listing): Change list_line to unsigned int.
@
text
@d1335 3
@


1.7
log
@	* struc-symbol.h: Put local_symbol code in ifdef BFD_ASSEMBLER.
	* symbols.c: Likewise.
	* config/obj-aout.c (obj_crawl_symbol_chain): Refer directly to
	sy_next field when taking address, rather than symbol_next.
@
text
@d774 1
a774 1
     symbolS **lastPP;
d1193 1
a1193 1
     const char *key;
@


1.6
log
@	* symbols.c (resolve_symbol_value): Don't permit subtraction of
	undefined symbols.
@
text
@d357 1
d372 1
a619 2
  struct local_symbol *locsym;

d652 9
a660 3
  locsym = (struct local_symbol *) hash_find (local_hash, name);
  if (locsym != NULL)
    return (symbolS *) locsym;
d853 1
d872 1
d1577 1
d1580 1
d1611 1
d1617 1
d1924 1
d1930 1
d1940 1
d1943 1
d2085 1
d2091 1
d2101 1
d2104 1
d2283 1
d2291 1
d2330 1
d2335 1
@


1.5
log
@	* symbols.c (copy_symbol_attributes): Convert local symbols to
	regular symbols.
@
text
@d1043 5
a1047 2
	  if ((seg_left != absolute_section || seg_right != absolute_section)
	      && (op != O_subtract || seg_left != seg_right)
@


1.4
log
@	* symbols.c (symbol_set_tc): Correct name.
@
text
@d1614 1
a1614 1
    abort ();
d1616 1
a1616 1
    abort ();
@


1.3
log
@	Add support for storing local symbols in a small structure to save
	memory when assembling large files.
	* as.h: Don't include struc-symbol.h.
	(symbolS): Add typedef.
	* symbols.c: Include struc-symbol.h.
	(local_hash): New static variable.
	(save_symbol_name): New static function, from symbol_create.
	(symbol_create): Call save_symbol_name.
	(local_symbol_count): New static variable.
	(local_symbol_conversion_count): Likewise.
	(LOCAL_SYMBOL_CHECK): Define.
	(local_symbol_make): New static function.
	(local_symbol_convert): New static function.
	(colon): Handle local symbols.  Create local symbol for local
	label name.
	(symbol_table_insert): Handle local symbols.
	(symbol_find_or_make): Create local symbol for local label name.
	(symbol_find_base): Check for local symbol.
	(symbol_append, symbol_insert): Check for local symbols.
	(symbol_clear_list_pointers, symbol_remove): Likewise.
	(verify_symbol_chain): Likewise.
	(copy_symbol_attributes): Likewise.
	(resolve_symbol_value): Handle local symbols.
	(resolve_local_symbol): New static function.
	(resolve_local_symbol_values): New function.
	(S_GET_VALUE, S_SET_VALUE): Handle local symbols.
	(S_IS_FUNCTION, S_IS_EXTERNAL, S_IS_WEAK, S_IS_COMMON): Likewise.
	(S_IS_DEFINED, S_IS_DEBUG, S_IS_LOCAL, S_GET_NAME): Likewise.
	(S_GET_SEGMENT, S_SET_SEGMENT, S_SET_EXTERNAL): Likewise.
	(S_CLEAR_EXTERNAL, S_SET_WEAK, S_SET_NAME): Likewise.
	(symbol_previous, symbol_next): New functions.
	(symbol_get_value_expression): Likewise.
	(symbol_set_value_expression): Likewise.
	(symbol_set_frag, symbol_get_frag): Likewise.
	(symbol_mark_used, symbol_clear_used, symbol_used_p): Likewise.
	(symbol_mark_used_in_reloc): Likewise.
	(symbol_clear_used_in_reloc, symbol_used_in_reloc_p): Likewise.
	(symbol_mark_mri_common, symbol_clear_mri_common): Likewise.
	(symbol_mri_common_p): Likewise.
	(symbol_mark_written, symbol_clear_written): Likewise.
	(symbol_written_p): Likewise.
	(symbol_mark_resolved, symbol_resolved_p): Likewise.
	(symbol_section_p, symbol_equated_p): Likewise.
	(symbol_constant_p): Likewise.
	(symbol_get_bfdsym, symbol_set_bfdsym): Likewise.
	(symbol_get_obj, symbol_set_obj): Likewise.
	(symbol_get_tc, symbol_set_tc): Likewise.
	(symbol_begin): Initialize local_hash.
	(print_symbol_value_1): Handle local symbols.
	(symbol_print_statistics): Print local symbol statistics.
	* symbols.h: Include "struc-symbol.h" if not BFD_ASSEMBLER.
	Declare new symbols.c functions.  Move many declarations here from
	struc-symbol.h.
	(SYMBOLS_NEED_BACKPOINTERS): Define if needed.
	* struc-symbol.h (SYMBOLS_NEED_BACKPOINTERS): Don't set.
	(struct symbol): Move bsym to make it clearly the first field.
	Remove TARGET_SYMBOL_FIELDS.
	(symbolS): Don't typedef.
	(struct broken_word): Remove.
	(N_TYPE_seg, seg_N_TYPE): Move to symbol.h.
	(SEGMENT_TO_SYMBOL_TYPE, N_REGISTER): Likewise.
	(symbol_clear_list_pointers): Likewise.
	(symbol_insert, symbol_remove): Likewise.
	(symbol_previous, symbol_append): Likewise.
	(verify_symbol_chain, verify_symbol_chain_2): Likewise.
	(struct local_symbol): Define.
	(local_symbol_converted_p, local_symbol_mark_converted): Define.
	(local_symbol_resolved_p, local_symbol_mark_resolved): Define.
	(local_symbol_get_frag, local_symbol_set_frag): Define.
	(local_symbol_get_real_symbol): Define.
	(local_symbol_set_real_symbol): Define.
	Define.
	* write.c (write_object_file): Call resolve_local_symbol_values.
	* config/obj-ecoff.h (OBJ_SYMFIELD_TYPE): Define.
	(TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-elf.h (OBJ_SYMFIELD_TYPE): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-multi.h (struct elf_obj_sy): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	(ECOFF_DEBUG_TARGET_SYMBOL_FIELDS): Don't define.
	* config/tc-mcore.h: Don't include struc-symbol.h.
	(TARGET_SYMBOL_FIELDS): Don't define.
	(struct mcore_tc_sy): Define.
	(TC_SYMFIELD_TYPE): Define.
	* Many files: Use symbolS instead of struct symbol.  Use new
	accessor functions rather than referring to symbolS fields
	directly.
	* read.c (s_mri_common): Don't add in value of line_label.
	* config/tc-mips.c (md_apply_fix): Correct parenthesization when
	checking for SEC_LINK_ONCE.
	* config/tc-sh.h (sh_fix_adjustable): Declare.
@
text
@d2193 1
a2193 1
symbol_set_obj (s, o)
@


1.2
log
@        * symbols.c (symbol_find_base): Use memcpy instead of strcpy.
        Don't copy before downcaseing.
@
text
@d2 1
a2 1
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 97, 1998
d31 2
d44 3
d101 6
a106 6
symbolS *
symbol_create (name, segment, valu, frag)
     const char *name;		/* It is copied, the caller can destroy/modify */
     segT segment;		/* Segment identifier (SEG_<something>) */
     valueT valu;		/* Symbol value */
     fragS *frag;		/* Associated fragment */
d109 1
a109 2
  char *preserved_copy_of_name;
  symbolS *symbolP;
d113 2
a114 1
  preserved_copy_of_name = obstack_finish (&notes);
d116 2
a117 2
  if (preserved_copy_of_name[0] == '_')
    preserved_copy_of_name++;
d121 1
a121 2
  preserved_copy_of_name =
    tc_canonicalize_symbol_name (preserved_copy_of_name);
d128 1
a128 1
      for (s = (unsigned char *) preserved_copy_of_name; *s != '\0'; s++)
d133 15
d180 95
d355 18
a372 1
      if (!S_IS_DEFINED (symbolP) || S_IS_COMMON (symbolP))
d463 8
d486 2
d523 10
d556 14
d618 2
d652 4
d675 5
d720 2
d736 3
d770 5
d806 3
d847 19
d926 1
a926 1
	      resolved = add_symbol->sy_resolved;
d931 6
a936 1
	    copy_symbol_attributes (symp, add_symbol);
d954 1
a954 1
	      resolved = add_symbol->sy_resolved;
d964 1
a964 1
	  resolved = add_symbol->sy_resolved;
d983 1
a983 1
	  resolved = add_symbol->sy_resolved;
d1128 2
a1129 1
	  resolved = (add_symbol->sy_resolved && op_symbol->sy_resolved);
d1174 27
d1566 3
d1598 6
d1613 5
d1636 6
a1641 1
  flagword flags = s->bsym->flags;
d1650 6
a1655 1
  flagword flags = s->bsym->flags;
d1668 2
d1677 2
d1686 2
d1695 2
d1706 1
a1706 1
  flagword flags = s->bsym->flags;
d1709 5
d1756 2
d1765 2
d1779 11
d1803 2
d1818 2
d1833 2
d1844 5
d1853 351
d2210 3
d2230 1
d2257 34
a2290 20
  if (sym->sy_frag != &zero_address_frag)
    fprintf (file, " frag %lx", (long) sym->sy_frag);
  if (sym->written)
    fprintf (file, " written");
  if (sym->sy_resolved)
    fprintf (file, " resolved");
  else if (sym->sy_resolving)
    fprintf (file, " resolving");
  if (sym->sy_used_in_reloc)
    fprintf (file, " used-in-reloc");
  if (sym->sy_used)
    fprintf (file, " used");
  if (S_IS_LOCAL (sym))
    fprintf (file, " local");
  if (S_IS_EXTERN (sym))
    fprintf (file, " extern");
  if (S_IS_DEBUG (sym))
    fprintf (file, " debug");
  if (S_IS_DEFINED (sym))
    fprintf (file, " defined");
d2292 1
a2292 1
  if (sym->sy_resolved)
d2305 5
a2309 1
      print_expr_1 (file, &sym->sy_value);
d2467 5
@


1.1
log
@Initial revision
@
text
@d459 1
d461 2
a462 2
    copy = (char *) alloca (strlen (name) + 1);
    strcpy (copy, name);
d469 3
a471 1
      unsigned char *copy;
d473 10
a482 6
      copy = (unsigned char *) alloca (strlen (name) + 1);
      strcpy (copy, name);
      name = (const char *) copy;
      for (; *copy != '\0'; copy++)
	if (islower (*copy))
	  *copy = toupper (*copy);
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

