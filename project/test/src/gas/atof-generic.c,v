head	1.15;
access;
symbols
	binutils-2_24-branch:1.15.0.12
	binutils-2_24-branchpoint:1.15
	binutils-2_21_1:1.15
	binutils-2_23_2:1.15
	binutils-2_23_1:1.15
	binutils-2_23:1.15
	binutils-2_23-branch:1.15.0.10
	binutils-2_23-branchpoint:1.15
	binutils-2_22_branch:1.15.0.8
	binutils-2_22:1.15
	binutils-2_22-branch:1.15.0.6
	binutils-2_22-branchpoint:1.15
	binutils-2_21:1.15
	binutils-2_21-branch:1.15.0.4
	binutils-2_21-branchpoint:1.15
	binutils-2_20_1:1.15
	binutils-2_20:1.15
	binutils-arc-20081103-branch:1.13.0.8
	binutils-arc-20081103-branchpoint:1.13
	binutils-2_20-branch:1.15.0.2
	binutils-2_20-branchpoint:1.15
	dje-cgen-play1-branch:1.14.0.2
	dje-cgen-play1-branchpoint:1.14
	arc-20081103-branch:1.13.0.6
	arc-20081103-branchpoint:1.13
	binutils-2_19_1:1.13
	binutils-2_19:1.13
	binutils-2_19-branch:1.13.0.4
	binutils-2_19-branchpoint:1.13
	binutils-2_18:1.13
	binutils-2_18-branch:1.13.0.2
	binutils-2_18-branchpoint:1.13
	binutils-csl-coldfire-4_1-32:1.11
	binutils-csl-sourcerygxx-4_1-32:1.11
	binutils-csl-innovasic-fido-3_4_4-33:1.11
	binutils-csl-sourcerygxx-3_4_4-32:1.10
	binutils-csl-coldfire-4_1-30:1.11
	binutils-csl-sourcerygxx-4_1-30:1.11
	binutils-csl-coldfire-4_1-28:1.11
	binutils-csl-sourcerygxx-4_1-29:1.11
	binutils-csl-sourcerygxx-4_1-28:1.11
	binutils-csl-arm-2006q3-27:1.11
	binutils-csl-sourcerygxx-4_1-27:1.11
	binutils-csl-arm-2006q3-26:1.11
	binutils-csl-sourcerygxx-4_1-26:1.11
	binutils-csl-sourcerygxx-4_1-25:1.11
	binutils-csl-sourcerygxx-4_1-24:1.11
	binutils-csl-sourcerygxx-4_1-23:1.11
	binutils-csl-sourcerygxx-4_1-21:1.11
	binutils-csl-arm-2006q3-21:1.11
	binutils-csl-sourcerygxx-4_1-22:1.11
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.11
	binutils-csl-sourcerygxx-4_1-20:1.11
	binutils-csl-arm-2006q3-19:1.11
	binutils-csl-sourcerygxx-4_1-19:1.11
	binutils-csl-sourcerygxx-4_1-18:1.11
	binutils-csl-renesas-4_1-9:1.11
	binutils-csl-sourcerygxx-3_4_4-25:1.10
	binutils-csl-renesas-4_1-8:1.11
	binutils-csl-renesas-4_1-7:1.11
	binutils-csl-renesas-4_1-6:1.11
	binutils-csl-sourcerygxx-4_1-17:1.11
	binutils-csl-sourcerygxx-4_1-14:1.11
	binutils-csl-sourcerygxx-4_1-15:1.11
	binutils-csl-sourcerygxx-4_1-13:1.11
	binutils-2_17:1.11
	binutils-csl-sourcerygxx-4_1-12:1.11
	binutils-csl-sourcerygxx-3_4_4-21:1.11
	binutils-csl-wrs-linux-3_4_4-24:1.10
	binutils-csl-wrs-linux-3_4_4-23:1.10
	binutils-csl-sourcerygxx-4_1-9:1.11
	binutils-csl-sourcerygxx-4_1-8:1.11
	binutils-csl-sourcerygxx-4_1-7:1.11
	binutils-csl-arm-2006q1-6:1.11
	binutils-csl-sourcerygxx-4_1-6:1.11
	binutils-csl-wrs-linux-3_4_4-22:1.10
	binutils-csl-coldfire-4_1-11:1.11
	binutils-csl-sourcerygxx-3_4_4-19:1.11
	binutils-csl-coldfire-4_1-10:1.11
	binutils-csl-sourcerygxx-4_1-5:1.11
	binutils-csl-sourcerygxx-4_1-4:1.11
	binutils-csl-wrs-linux-3_4_4-21:1.10
	binutils-csl-morpho-4_1-4:1.11
	binutils-csl-sourcerygxx-3_4_4-17:1.11
	binutils-csl-wrs-linux-3_4_4-20:1.10
	binutils-2_17-branch:1.11.0.4
	binutils-2_17-branchpoint:1.11
	binutils-csl-2_17-branch:1.11.0.2
	binutils-csl-2_17-branchpoint:1.11
	binutils-csl-gxxpro-3_4-branch:1.10.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.10
	binutils-2_16_1:1.10
	binutils-csl-arm-2005q1b:1.10
	binutils-2_16:1.10
	binutils-csl-arm-2005q1a:1.10
	binutils-csl-arm-2005q1-branch:1.10.0.4
	binutils-csl-arm-2005q1-branchpoint:1.10
	binutils-2_16-branch:1.10.0.2
	binutils-2_16-branchpoint:1.10
	csl-arm-2004-q3d:1.8
	csl-arm-2004-q3:1.8
	binutils-2_15:1.8
	binutils-2_15-branchpoint:1.8
	csl-arm-2004-q1a:1.8
	csl-arm-2004-q1:1.8
	binutils-2_15-branch:1.8.0.6
	cagney_bfdfile-20040213-branch:1.8.0.4
	cagney_bfdfile-20040213-branchpoint:1.8
	cagney_bigcore-20040122-branch:1.8.0.2
	cagney_bigcore-20040122-branchpoint:1.8
	csl-arm-2003-q4:1.8
	binutils-2_14:1.6
	binutils-2_14-branch:1.6.0.6
	binutils-2_14-branchpoint:1.6
	binutils-2_13_2_1:1.6
	binutils-2_13_2:1.6
	binutils-2_13_1:1.6
	binutils-2_13:1.6
	binutils-2_13-branchpoint:1.6
	binutils-2_13-branch:1.6.0.4
	binutils-2_12_1:1.6
	binutils-2_12:1.6
	binutils-2_12-branch:1.6.0.2
	binutils-2_12-branchpoint:1.6
	cygnus_cvs_20020108_pre:1.6
	binutils-2_11_2:1.3.2.1
	binutils-2_11_1:1.3.2.1
	binutils-2_11:1.3
	x86_64versiong3:1.3
	binutils-2_11-branch:1.3.0.2
	binutils-2_10_1:1.2
	binutils-2_10:1.2
	binutils-2_10-branch:1.2.0.2
	binutils-2_10-branchpoint:1.2
	binutils_latest_snapshot:1.15
	repo-unification-2000-02-06:1.2
	binu_ss_19990721:1.2
	binu_ss_19990602:1.2
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2009.09.02.07.24.19;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2009.06.22.17.56.00;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2007.07.03.11.01.02;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2006.06.07.11.27.57;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2005.05.05.09.12.43;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2005.03.03.01.29.52;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2005.01.21.05.54.38;	author bje;	state Exp;
branches;
next	1.8;

1.8
date	2003.11.21.01.52.16;	author kazu;	state Exp;
branches;
next	1.7;

1.7
date	2003.10.27.12.45.17;	author kazu;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.19.05.33.18;	author hjl;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.01.01.44.25;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.08.23.24.21;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2000.09.07.21.04.26;	author kazu;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	99.05.28.15.28.51;	author devans;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.40;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2001.06.07.03.15.24;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.40;	author rth;	state Exp;
branches;
next	;


desc
@@


1.15
log
@update copyright dates
@
text
@/* atof_generic.c - turn a string of digits into a Flonum
   Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1998, 1999, 2000,
   2001, 2003, 2005, 2006, 2007, 2009 Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include "as.h"
#include "safe-ctype.h"

#ifndef FALSE
#define FALSE (0)
#endif
#ifndef TRUE
#define TRUE  (1)
#endif

#ifdef TRACE
static void flonum_print (const FLONUM_TYPE *);
#endif

#define ASSUME_DECIMAL_MARK_IS_DOT

/***********************************************************************\
 *									*
 *	Given a string of decimal digits , with optional decimal	*
 *	mark and optional decimal exponent (place value) of the		*
 *	lowest_order decimal digit: produce a floating point		*
 *	number. The number is 'generic' floating point: our		*
 *	caller will encode it for a specific machine architecture.	*
 *									*
 *	Assumptions							*
 *		uses base (radix) 2					*
 *		this machine uses 2's complement binary integers	*
 *		target flonums use "      "         "       "		*
 *		target flonums exponents fit in a long			*
 *									*
 \***********************************************************************/

/*

  Syntax:

  <flonum> ::= <optional-sign> <decimal-number> <optional-exponent>
  <optional-sign> ::= '+' | '-' | {empty}
  <decimal-number> ::= <integer>
  | <integer> <radix-character>
  | <integer> <radix-character> <integer>
  | <radix-character> <integer>

  <optional-exponent> ::= {empty}
  | <exponent-character> <optional-sign> <integer>

  <integer> ::= <digit> | <digit> <integer>
  <digit> ::= '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9'
  <exponent-character> ::= {one character from "string_of_decimal_exponent_marks"}
  <radix-character> ::= {one character from "string_of_decimal_marks"}

  */

int
atof_generic (/* return pointer to just AFTER number we read.  */
	      char **address_of_string_pointer,
	      /* At most one per number.  */
	      const char *string_of_decimal_marks,
	      const char *string_of_decimal_exponent_marks,
	      FLONUM_TYPE *address_of_generic_floating_point_number)
{
  int return_value;		/* 0 means OK.  */
  char *first_digit;
  unsigned int number_of_digits_before_decimal;
  unsigned int number_of_digits_after_decimal;
  long decimal_exponent;
  unsigned int number_of_digits_available;
  char digits_sign_char;

  /*
   * Scan the input string, abstracting (1)digits (2)decimal mark (3) exponent.
   * It would be simpler to modify the string, but we don't; just to be nice
   * to caller.
   * We need to know how many digits we have, so we can allocate space for
   * the digits' value.
   */

  char *p;
  char c;
  int seen_significant_digit;

#ifdef ASSUME_DECIMAL_MARK_IS_DOT
  gas_assert (string_of_decimal_marks[0] == '.'
	  && string_of_decimal_marks[1] == 0);
#define IS_DECIMAL_MARK(c)	((c) == '.')
#else
#define IS_DECIMAL_MARK(c)	(0 != strchr (string_of_decimal_marks, (c)))
#endif

  first_digit = *address_of_string_pointer;
  c = *first_digit;

  if (c == '-' || c == '+')
    {
      digits_sign_char = c;
      first_digit++;
    }
  else
    digits_sign_char = '+';

  switch (first_digit[0])
    {
    case 'n':
    case 'N':
      if (!strncasecmp ("nan", first_digit, 3))
	{
	  address_of_generic_floating_point_number->sign = 0;
	  address_of_generic_floating_point_number->exponent = 0;
	  address_of_generic_floating_point_number->leader =
	    address_of_generic_floating_point_number->low;
	  *address_of_string_pointer = first_digit + 3;
	  return 0;
	}
      break;

    case 'i':
    case 'I':
      if (!strncasecmp ("inf", first_digit, 3))
	{
	  address_of_generic_floating_point_number->sign =
	    digits_sign_char == '+' ? 'P' : 'N';
	  address_of_generic_floating_point_number->exponent = 0;
	  address_of_generic_floating_point_number->leader =
	    address_of_generic_floating_point_number->low;

	  first_digit += 3;
	  if (!strncasecmp ("inity", first_digit, 5))
	    first_digit += 5;

	  *address_of_string_pointer = first_digit;

	  return 0;
	}
      break;
    }

  number_of_digits_before_decimal = 0;
  number_of_digits_after_decimal = 0;
  decimal_exponent = 0;
  seen_significant_digit = 0;
  for (p = first_digit;
       (((c = *p) != '\0')
	&& (!c || !IS_DECIMAL_MARK (c))
	&& (!c || !strchr (string_of_decimal_exponent_marks, c)));
       p++)
    {
      if (ISDIGIT (c))
	{
	  if (seen_significant_digit || c > '0')
	    {
	      ++number_of_digits_before_decimal;
	      seen_significant_digit = 1;
	    }
	  else
	    {
	      first_digit++;
	    }
	}
      else
	{
	  break;		/* p -> char after pre-decimal digits.  */
	}
    }				/* For each digit before decimal mark.  */

#ifndef OLD_FLOAT_READS
  /* Ignore trailing 0's after the decimal point.  The original code here
   * (ifdef'd out) does not do this, and numbers like
   *	4.29496729600000000000e+09	(2**31)
   * come out inexact for some reason related to length of the digit
   * string.
   */
  if (c && IS_DECIMAL_MARK (c))
    {
      unsigned int zeros = 0;	/* Length of current string of zeros */

      for (p++; (c = *p) && ISDIGIT (c); p++)
	{
	  if (c == '0')
	    {
	      zeros++;
	    }
	  else
	    {
	      number_of_digits_after_decimal += 1 + zeros;
	      zeros = 0;
	    }
	}
    }
#else
  if (c && IS_DECIMAL_MARK (c))
    {
      for (p++;
	   (((c = *p) != '\0')
	    && (!c || !strchr (string_of_decimal_exponent_marks, c)));
	   p++)
	{
	  if (ISDIGIT (c))
	    {
	      /* This may be retracted below.  */
	      number_of_digits_after_decimal++;

	      if ( /* seen_significant_digit || */ c > '0')
		{
		  seen_significant_digit = TRUE;
		}
	    }
	  else
	    {
	      if (!seen_significant_digit)
		{
		  number_of_digits_after_decimal = 0;
		}
	      break;
	    }
	}			/* For each digit after decimal mark.  */
    }

  while (number_of_digits_after_decimal
	 && first_digit[number_of_digits_before_decimal
			+ number_of_digits_after_decimal] == '0')
    --number_of_digits_after_decimal;
#endif

  if (flag_m68k_mri)
    {
      while (c == '_')
	c = *++p;
    }
  if (c && strchr (string_of_decimal_exponent_marks, c))
    {
      char digits_exponent_sign_char;

      c = *++p;
      if (flag_m68k_mri)
	{
	  while (c == '_')
	    c = *++p;
	}
      if (c && strchr ("+-", c))
	{
	  digits_exponent_sign_char = c;
	  c = *++p;
	}
      else
	{
	  digits_exponent_sign_char = '+';
	}

      for (; (c); c = *++p)
	{
	  if (ISDIGIT (c))
	    {
	      decimal_exponent = decimal_exponent * 10 + c - '0';
	      /*
	       * BUG! If we overflow here, we lose!
	       */
	    }
	  else
	    {
	      break;
	    }
	}

      if (digits_exponent_sign_char == '-')
	{
	  decimal_exponent = -decimal_exponent;
	}
    }

  *address_of_string_pointer = p;

  number_of_digits_available =
    number_of_digits_before_decimal + number_of_digits_after_decimal;
  return_value = 0;
  if (number_of_digits_available == 0)
    {
      address_of_generic_floating_point_number->exponent = 0;	/* Not strictly necessary */
      address_of_generic_floating_point_number->leader
	= -1 + address_of_generic_floating_point_number->low;
      address_of_generic_floating_point_number->sign = digits_sign_char;
      /* We have just concocted (+/-)0.0E0 */

    }
  else
    {
      int count;		/* Number of useful digits left to scan.  */

      LITTLENUM_TYPE *digits_binary_low;
      unsigned int precision;
      unsigned int maximum_useful_digits;
      unsigned int number_of_digits_to_use;
      unsigned int more_than_enough_bits_for_digits;
      unsigned int more_than_enough_littlenums_for_digits;
      unsigned int size_of_digits_in_littlenums;
      unsigned int size_of_digits_in_chars;
      FLONUM_TYPE power_of_10_flonum;
      FLONUM_TYPE digits_flonum;

      precision = (address_of_generic_floating_point_number->high
		   - address_of_generic_floating_point_number->low
		   + 1);	/* Number of destination littlenums.  */

      /* Includes guard bits (two littlenums worth) */
      maximum_useful_digits = (((precision - 2))
			       * ( (LITTLENUM_NUMBER_OF_BITS))
			       * 1000000 / 3321928)
	+ 2;			/* 2 :: guard digits.  */

      if (number_of_digits_available > maximum_useful_digits)
	{
	  number_of_digits_to_use = maximum_useful_digits;
	}
      else
	{
	  number_of_digits_to_use = number_of_digits_available;
	}

      /* Cast these to SIGNED LONG first, otherwise, on systems with
	 LONG wider than INT (such as Alpha OSF/1), unsignedness may
	 cause unexpected results.  */
      decimal_exponent += ((long) number_of_digits_before_decimal
			   - (long) number_of_digits_to_use);

      more_than_enough_bits_for_digits
	= (number_of_digits_to_use * 3321928 / 1000000 + 1);

      more_than_enough_littlenums_for_digits
	= (more_than_enough_bits_for_digits
	   / LITTLENUM_NUMBER_OF_BITS)
	+ 2;

      /* Compute (digits) part. In "12.34E56" this is the "1234" part.
	 Arithmetic is exact here. If no digits are supplied then this
	 part is a 0 valued binary integer.  Allocate room to build up
	 the binary number as littlenums.  We want this memory to
	 disappear when we leave this function.  Assume no alignment
	 problems => (room for n objects) == n * (room for 1
	 object).  */

      size_of_digits_in_littlenums = more_than_enough_littlenums_for_digits;
      size_of_digits_in_chars = size_of_digits_in_littlenums
	* sizeof (LITTLENUM_TYPE);

      digits_binary_low = (LITTLENUM_TYPE *)
	alloca (size_of_digits_in_chars);

      memset ((char *) digits_binary_low, '\0', size_of_digits_in_chars);

      /* Digits_binary_low[] is allocated and zeroed.  */

      /*
       * Parse the decimal digits as if * digits_low was in the units position.
       * Emit a binary number into digits_binary_low[].
       *
       * Use a large-precision version of:
       * (((1st-digit) * 10 + 2nd-digit) * 10 + 3rd-digit ...) * 10 + last-digit
       */

      for (p = first_digit, count = number_of_digits_to_use; count; p++, --count)
	{
	  c = *p;
	  if (ISDIGIT (c))
	    {
	      /*
	       * Multiply by 10. Assume can never overflow.
	       * Add this digit to digits_binary_low[].
	       */

	      long carry;
	      LITTLENUM_TYPE *littlenum_pointer;
	      LITTLENUM_TYPE *littlenum_limit;

	      littlenum_limit = digits_binary_low
		+ more_than_enough_littlenums_for_digits
		- 1;

	      carry = c - '0';	/* char -> binary */

	      for (littlenum_pointer = digits_binary_low;
		   littlenum_pointer <= littlenum_limit;
		   littlenum_pointer++)
		{
		  long work;

		  work = carry + 10 * (long) (*littlenum_pointer);
		  *littlenum_pointer = work & LITTLENUM_MASK;
		  carry = work >> LITTLENUM_NUMBER_OF_BITS;
		}

	      if (carry != 0)
		{
		  /*
		   * We have a GROSS internal error.
		   * This should never happen.
		   */
		  as_fatal (_("failed sanity check"));
		}
	    }
	  else
	    {
	      ++count;		/* '.' doesn't alter digits used count.  */
	    }
	}

      /*
       * Digits_binary_low[] properly encodes the value of the digits.
       * Forget about any high-order littlenums that are 0.
       */
      while (digits_binary_low[size_of_digits_in_littlenums - 1] == 0
	     && size_of_digits_in_littlenums >= 2)
	size_of_digits_in_littlenums--;

      digits_flonum.low = digits_binary_low;
      digits_flonum.high = digits_binary_low + size_of_digits_in_littlenums - 1;
      digits_flonum.leader = digits_flonum.high;
      digits_flonum.exponent = 0;
      /*
       * The value of digits_flonum . sign should not be important.
       * We have already decided the output's sign.
       * We trust that the sign won't influence the other parts of the number!
       * So we give it a value for these reasons:
       * (1) courtesy to humans reading/debugging
       *     these numbers so they don't get excited about strange values
       * (2) in future there may be more meaning attached to sign,
       *     and what was
       *     harmless noise may become disruptive, ill-conditioned (or worse)
       *     input.
       */
      digits_flonum.sign = '+';

      {
	/*
	 * Compute the mantssa (& exponent) of the power of 10.
	 * If successful, then multiply the power of 10 by the digits
	 * giving return_binary_mantissa and return_binary_exponent.
	 */

	LITTLENUM_TYPE *power_binary_low;
	int decimal_exponent_is_negative;
	/* This refers to the "-56" in "12.34E-56".  */
	/* FALSE: decimal_exponent is positive (or 0) */
	/* TRUE:  decimal_exponent is negative */
	FLONUM_TYPE temporary_flonum;
	LITTLENUM_TYPE *temporary_binary_low;
	unsigned int size_of_power_in_littlenums;
	unsigned int size_of_power_in_chars;

	size_of_power_in_littlenums = precision;
	/* Precision has a built-in fudge factor so we get a few guard bits.  */

	decimal_exponent_is_negative = decimal_exponent < 0;
	if (decimal_exponent_is_negative)
	  {
	    decimal_exponent = -decimal_exponent;
	  }

	/* From now on: the decimal exponent is > 0. Its sign is separate.  */

	size_of_power_in_chars = size_of_power_in_littlenums
	  * sizeof (LITTLENUM_TYPE) + 2;

	power_binary_low = (LITTLENUM_TYPE *) alloca (size_of_power_in_chars);
	temporary_binary_low = (LITTLENUM_TYPE *) alloca (size_of_power_in_chars);
	memset ((char *) power_binary_low, '\0', size_of_power_in_chars);
	*power_binary_low = 1;
	power_of_10_flonum.exponent = 0;
	power_of_10_flonum.low = power_binary_low;
	power_of_10_flonum.leader = power_binary_low;
	power_of_10_flonum.high = power_binary_low + size_of_power_in_littlenums - 1;
	power_of_10_flonum.sign = '+';
	temporary_flonum.low = temporary_binary_low;
	temporary_flonum.high = temporary_binary_low + size_of_power_in_littlenums - 1;
	/*
	 * (power) == 1.
	 * Space for temporary_flonum allocated.
	 */

	/*
	 * ...
	 *
	 * WHILE	more bits
	 * DO	find next bit (with place value)
	 *	multiply into power mantissa
	 * OD
	 */
	{
	  int place_number_limit;
	  /* Any 10^(2^n) whose "n" exceeds this */
	  /* value will fall off the end of */
	  /* flonum_XXXX_powers_of_ten[].  */
	  int place_number;
	  const FLONUM_TYPE *multiplicand;	/* -> 10^(2^n) */

	  place_number_limit = table_size_of_flonum_powers_of_ten;

	  multiplicand = (decimal_exponent_is_negative
			  ? flonum_negative_powers_of_ten
			  : flonum_positive_powers_of_ten);

	  for (place_number = 1;/* Place value of this bit of exponent.  */
	       decimal_exponent;/* Quit when no more 1 bits in exponent.  */
	       decimal_exponent >>= 1, place_number++)
	    {
	      if (decimal_exponent & 1)
		{
		  if (place_number > place_number_limit)
		    {
		      /* The decimal exponent has a magnitude so great
			 that our tables can't help us fragment it.
			 Although this routine is in error because it
			 can't imagine a number that big, signal an
			 error as if it is the user's fault for
			 presenting such a big number.  */
		      return_value = ERROR_EXPONENT_OVERFLOW;
		      /* quit out of loop gracefully */
		      decimal_exponent = 0;
		    }
		  else
		    {
#ifdef TRACE
		      printf ("before multiply, place_number = %d., power_of_10_flonum:\n",
			      place_number);

		      flonum_print (&power_of_10_flonum);
		      (void) putchar ('\n');
#endif
#ifdef TRACE
		      printf ("multiplier:\n");
		      flonum_print (multiplicand + place_number);
		      (void) putchar ('\n');
#endif
		      flonum_multip (multiplicand + place_number,
				     &power_of_10_flonum, &temporary_flonum);
#ifdef TRACE
		      printf ("after multiply:\n");
		      flonum_print (&temporary_flonum);
		      (void) putchar ('\n');
#endif
		      flonum_copy (&temporary_flonum, &power_of_10_flonum);
#ifdef TRACE
		      printf ("after copy:\n");
		      flonum_print (&power_of_10_flonum);
		      (void) putchar ('\n');
#endif
		    } /* If this bit of decimal_exponent was computable.*/
		} /* If this bit of decimal_exponent was set.  */
	    } /* For each bit of binary representation of exponent */
#ifdef TRACE
	  printf ("after computing power_of_10_flonum:\n");
	  flonum_print (&power_of_10_flonum);
	  (void) putchar ('\n');
#endif
	}

      }

      /*
       * power_of_10_flonum is power of ten in binary (mantissa) , (exponent).
       * It may be the number 1, in which case we don't NEED to multiply.
       *
       * Multiply (decimal digits) by power_of_10_flonum.
       */

      flonum_multip (&power_of_10_flonum, &digits_flonum, address_of_generic_floating_point_number);
      /* Assert sign of the number we made is '+'.  */
      address_of_generic_floating_point_number->sign = digits_sign_char;

    }
  return return_value;
}

#ifdef TRACE
static void
flonum_print (f)
     const FLONUM_TYPE *f;
{
  LITTLENUM_TYPE *lp;
  char littlenum_format[10];
  sprintf (littlenum_format, " %%0%dx", sizeof (LITTLENUM_TYPE) * 2);
#define print_littlenum(LP)	(printf (littlenum_format, LP))
  printf ("flonum @@%p %c e%ld", f, f->sign, f->exponent);
  if (f->low < f->high)
    for (lp = f->high; lp >= f->low; lp--)
      print_littlenum (*lp);
  else
    for (lp = f->low; lp <= f->high; lp++)
      print_littlenum (*lp);
  printf ("\n");
  fflush (stdout);
}
#endif

/* end of atof_generic.c */
@


1.14
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d3 1
a3 1
   2001, 2003, 2005, 2006, 2007 Free Software Foundation, Inc.
@


1.13
log
@Switch to GPLv3
@
text
@d104 1
a104 1
  assert (string_of_decimal_marks[0] == '.'
@


1.12
log
@remove some duplicate #include's.
@
text
@d3 1
a3 1
   2001, 2003, 2005, 2006 Free Software Foundation, Inc.
d9 1
a9 1
   the Free Software Foundation; either version 2, or (at your option)
d12 4
a15 4
   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
@


1.11
log
@Update the address and phone number of the FSF
@
text
@d3 1
a3 1
   2001, 2003, 2005 Free Software Foundation, Inc.
a21 2
#include <string.h>

@


1.10
log
@update copyright dates
@
text
@d19 2
a20 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.9
log
@	* as.h: Remove #if 0'd code.
	* atof-generic.c (atof_generic): Likewise.
	* ecoff.c (ecoff_directive_frame): Likewise.
	* frags.h (FRAG_APPEND_1_CHAR): Likewise.
	* itbl-ops.c (itbl_add_reg): Likewise.
	* listing.c (calc_hex): Likewise.
	* read.c (MASK_CHAR): Likewise.
	* subsegs.c (subsegs_print_statistics): Likewise.
	* symbols.c (indent): Likewise.
	* write.c (write_relocs): Likewise.
	(write_object_file): Likewise.
	(relax_frag): Likewise.
@
text
@d2 2
a3 2
   Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
@


1.8
log
@	* app.c: Convert to ISO-C.
	* as.h: Likewise.
	* atof-generic.c: Likewise.
	* bignum-copy.c: Likewise.
	* bignum.h: Likewise.
	* cgen.c: Likewise.
	* cgen.h: Likewise.
	* cond.c: Likewise.
@
text
@a326 8
#if 0 /* The integer version below is very close, and it doesn't
	 require floating point support (which is currently buggy on
	 the Alpha).  */
      maximum_useful_digits = (((double) (precision - 2))
			       * ((double) (LITTLENUM_NUMBER_OF_BITS))
			       / (LOG_TO_BASE_2_OF_10))
	+ 2;			/* 2 :: guard digits.  */
#else
a330 1
#endif
a346 4
#if 0
      more_than_enough_bits_for_digits
	= ((((double) number_of_digits_to_use) * LOG_TO_BASE_2_OF_10) + 1);
#else
a348 1
#endif
@


1.7
log
@	* ChangeLog: Fix typos.
	* ChangeLog-9295: Likewise.
	* as.c: Fix comment typos.
	* as.h: Likewise.
	* atof-generic.c: Likewise.
	* bit_fix.h: Likewise.
	* frags.h: Likewise.
	* hash.c: Likewise.
	* input-file.c: Likewise.
	* input-scrub.c: Likewise.
	* itbl-ops.c: Likewise.
	* itbl-parse.y: Likewise.
	* listing.c: Likewise.
	* macro.h: Likewise.
	* read.c: Likewise.
	* sb.c: Likewise.
	* sb.h: Likewise.
	* symbols.c: Likewise.
	* symbols.h: Likewise.
@
text
@d35 1
a35 1
static void flonum_print PARAMS ((const FLONUM_TYPE *));
d78 6
a83 10
atof_generic (address_of_string_pointer,
	      string_of_decimal_marks,
	      string_of_decimal_exponent_marks,
	      address_of_generic_floating_point_number)
     /* return pointer to just AFTER number we read.  */
     char **address_of_string_pointer;
     /* At most one per number.  */
     const char *string_of_decimal_marks;
     const char *string_of_decimal_exponent_marks;
     FLONUM_TYPE *address_of_generic_floating_point_number;
@


1.6
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d475 1
a475 1
	 * If sucessful, then multiply the power of 10 by the digits
@


1.5
log
@	* read.c: Standardize error/warning messages - don't capitalise, no
	final period or newline, don't say "ignored" or "zero assumed" for
	as_bad messages.  In some cases, change the wording to that used
	elsewhere for similar messages.
	* app.c, as.c, atof-generic.c, cgen.c, cond.c, depend.c, dwarf2dbg.c,
	  ecoff.c, expr.c, frags.c, input-file.c, input-scrub.c, listing.c,
	  output-file.c, stabs.c, subsegs.c, symbols.c, write.c: Likewise.
	* ecoff.c (ecoff_directive_end): Test for missing name by
	comparing input line pointers rather than reading string.
	(ecoff_directive_ent): Likewise.
	* read.c (s_set): Likewise.
	(s_align): Report a warning rather than an error for
	alignment too large.
	(s_comm): Check for missing symbol name.
	(s_lcomm_internal): Likewise.
	(s_lsym): Likewise.
	(s_globl): Use is_end_of_line instead of looking for '\n'.
	(s_lcomm_internal): Likewise.
	(ignore_rest_of_line): Report a warning rather than an error.
@
text
@d2 1
a2 1
   Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1998, 1999, 2000
a21 1
#include <ctype.h>
d25 1
d174 1
a174 1
      if (isdigit ((unsigned char) c))
d203 1
a203 1
      for (p++; (c = *p) && isdigit ((unsigned char) c); p++)
d224 1
a224 1
	  if (isdigit ((unsigned char) c))
d278 1
a278 1
	  if (isdigit ((unsigned char) c))
d403 1
a403 1
	  if (isdigit ((unsigned char) c))
@


1.4
log
@Fix copyright notices
@
text
@d437 1
a437 1
		  as_fatal (_("failed sanity check."));
@


1.3
log
@2000-09-07  Kazu Hirata  <kazu@@hxi.com>

	* atof-generic.c: Fix formatting.
@
text
@d2 1
a2 1
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 98, 2000
@


1.3.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1998, 1999, 2000
@


1.2
log
@	-Wchar-subscripts cleanup
	* listing.c (listing_newline): Use unsigned char variable, so
 	calls to isascii,iscntrl are correct.
	* atof-generic.c (atof_generic): Cast arg to isdigit, et. al. with
	(unsigned char).
	* ecoff.c (ecoff_directive_ent,ecoff_stab): Ditto.
	* config/obj-elf.c (obj_elf_vtable_inherit): Ditto.
	* config/tc-mips.c (mips_ip,mips16_ip): Ditto.
	(my_getSmallExpression,get_number,s_mips_ent): Ditto.
@
text
@d2 1
a2 1
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 1998
d18 3
a20 2
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d82 1
a82 1
     /* return pointer to just AFTER number we read. */
d84 1
a84 1
     /* At most one per number. */
d89 1
a89 1
  int return_value;		/* 0 means OK. */
d188 1
a188 1
	  break;		/* p -> char after pre-decimal digits. */
d190 1
a190 1
    }				/* For each digit before decimal mark. */
d226 1
a226 1
	      /* This may be retracted below. */
d242 1
a242 1
	}			/* For each digit after decimal mark. */
a298 2


d313 1
a313 1
      int count;		/* Number of useful digits left to scan. */
d328 1
a328 1
		   + 1);	/* Number of destination littlenums. */
d337 1
a337 1
	+ 2;			/* 2 :: guard digits. */
d342 1
a342 1
	+ 2;			/* 2 :: guard digits. */
d390 1
a390 1
      /* Digits_binary_low[] is allocated and zeroed. */
d442 1
a442 1
	      ++count;		/* '.' doesn't alter digits used count. */
a445 1

d481 1
a481 1
	/* This refers to the "-56" in "12.34E-56". */
d490 1
a490 1
	/* Precision has a built-in fudge factor so we get a few guard bits. */
d498 1
a498 1
	/* From now on: the decimal exponent is > 0. Its sign is separate. */
d531 1
a531 1
	  /* flonum_XXXX_powers_of_ten[]. */
d541 2
a542 2
	  for (place_number = 1;/* Place value of this bit of exponent. */
	       decimal_exponent;/* Quit when no more 1 bits in exponent. */
d587 1
a587 1
		} /* If this bit of decimal_exponent was set. */
d606 1
a606 1
      /* Assert sign of the number we made is '+'. */
@


1.1
log
@Initial revision
@
text
@d223 1
a223 1
	  if (isdigit (c))
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

