head	1.37;
access;
symbols
	binutils-2_24-branch:1.37.0.2
	binutils-2_24-branchpoint:1.37
	binutils-2_21_1:1.36
	binutils-2_23_2:1.36
	binutils-2_23_1:1.36
	binutils-2_23:1.36
	binutils-2_23-branch:1.36.0.8
	binutils-2_23-branchpoint:1.36
	binutils-2_22_branch:1.36.0.6
	binutils-2_22:1.36
	binutils-2_22-branch:1.36.0.4
	binutils-2_22-branchpoint:1.36
	binutils-2_21:1.36
	binutils-2_21-branch:1.36.0.2
	binutils-2_21-branchpoint:1.36
	binutils-2_20_1:1.35.2.1
	binutils-2_20:1.35.2.1
	binutils-arc-20081103-branch:1.33.0.8
	binutils-arc-20081103-branchpoint:1.33
	binutils-2_20-branch:1.35.0.2
	binutils-2_20-branchpoint:1.35
	dje-cgen-play1-branch:1.34.0.2
	dje-cgen-play1-branchpoint:1.34
	arc-20081103-branch:1.33.0.6
	arc-20081103-branchpoint:1.33
	binutils-2_19_1:1.33
	binutils-2_19:1.33
	binutils-2_19-branch:1.33.0.4
	binutils-2_19-branchpoint:1.33
	binutils-2_18:1.33
	binutils-2_18-branch:1.33.0.2
	binutils-2_18-branchpoint:1.33
	binutils-csl-coldfire-4_1-32:1.27.2.1
	binutils-csl-sourcerygxx-4_1-32:1.27.2.1
	binutils-csl-innovasic-fido-3_4_4-33:1.27.2.1
	binutils-csl-sourcerygxx-3_4_4-32:1.23
	binutils-csl-coldfire-4_1-30:1.27.2.1
	binutils-csl-sourcerygxx-4_1-30:1.27.2.1
	binutils-csl-coldfire-4_1-28:1.27.2.1
	binutils-csl-sourcerygxx-4_1-29:1.27.2.1
	binutils-csl-sourcerygxx-4_1-28:1.27.2.1
	binutils-csl-arm-2006q3-27:1.27.2.1
	binutils-csl-sourcerygxx-4_1-27:1.27.2.1
	binutils-csl-arm-2006q3-26:1.27.2.1
	binutils-csl-sourcerygxx-4_1-26:1.27.2.1
	binutils-csl-sourcerygxx-4_1-25:1.27.2.1
	binutils-csl-sourcerygxx-4_1-24:1.27.2.1
	binutils-csl-sourcerygxx-4_1-23:1.27.2.1
	binutils-csl-sourcerygxx-4_1-21:1.27.2.1
	binutils-csl-arm-2006q3-21:1.27.2.1
	binutils-csl-sourcerygxx-4_1-22:1.27.2.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.27.2.1
	binutils-csl-sourcerygxx-4_1-20:1.27.2.1
	binutils-csl-arm-2006q3-19:1.27.2.1
	binutils-csl-sourcerygxx-4_1-19:1.27.2.1
	binutils-csl-sourcerygxx-4_1-18:1.27.2.1
	binutils-csl-renesas-4_1-9:1.27.2.1
	binutils-csl-sourcerygxx-3_4_4-25:1.23
	binutils-csl-renesas-4_1-8:1.27
	binutils-csl-renesas-4_1-7:1.27
	binutils-csl-renesas-4_1-6:1.27
	binutils-csl-sourcerygxx-4_1-17:1.27
	binutils-csl-sourcerygxx-4_1-14:1.27
	binutils-csl-sourcerygxx-4_1-15:1.27
	binutils-csl-sourcerygxx-4_1-13:1.27
	binutils-2_17:1.27.4.1
	binutils-csl-sourcerygxx-4_1-12:1.27
	binutils-csl-sourcerygxx-3_4_4-21:1.27
	binutils-csl-wrs-linux-3_4_4-24:1.23
	binutils-csl-wrs-linux-3_4_4-23:1.23
	binutils-csl-sourcerygxx-4_1-9:1.27
	binutils-csl-sourcerygxx-4_1-8:1.27
	binutils-csl-sourcerygxx-4_1-7:1.27
	binutils-csl-arm-2006q1-6:1.27
	binutils-csl-sourcerygxx-4_1-6:1.27
	binutils-csl-wrs-linux-3_4_4-22:1.23
	binutils-csl-coldfire-4_1-11:1.27
	binutils-csl-sourcerygxx-3_4_4-19:1.27
	binutils-csl-coldfire-4_1-10:1.27
	binutils-csl-sourcerygxx-4_1-5:1.27
	binutils-csl-sourcerygxx-4_1-4:1.27
	binutils-csl-wrs-linux-3_4_4-21:1.23
	binutils-csl-morpho-4_1-4:1.27
	binutils-csl-sourcerygxx-3_4_4-17:1.27
	binutils-csl-wrs-linux-3_4_4-20:1.23
	binutils-2_17-branch:1.27.0.4
	binutils-2_17-branchpoint:1.27
	binutils-csl-2_17-branch:1.27.0.2
	binutils-csl-2_17-branchpoint:1.27
	binutils-csl-gxxpro-3_4-branch:1.23.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.23
	binutils-2_16_1:1.23
	binutils-csl-arm-2005q1b:1.23
	binutils-2_16:1.23
	binutils-csl-arm-2005q1a:1.23
	binutils-csl-arm-2005q1-branch:1.23.0.4
	binutils-csl-arm-2005q1-branchpoint:1.23
	binutils-2_16-branch:1.23.0.2
	binutils-2_16-branchpoint:1.23
	csl-arm-2004-q3d:1.17
	csl-arm-2004-q3:1.17
	binutils-2_15:1.15
	binutils-2_15-branchpoint:1.15
	csl-arm-2004-q1a:1.15
	csl-arm-2004-q1:1.15
	binutils-2_15-branch:1.15.0.6
	cagney_bfdfile-20040213-branch:1.15.0.4
	cagney_bfdfile-20040213-branchpoint:1.15
	cagney_bigcore-20040122-branch:1.15.0.2
	cagney_bigcore-20040122-branchpoint:1.15
	csl-arm-2003-q4:1.15
	binutils-2_14:1.13
	binutils-2_14-branch:1.13.0.2
	binutils-2_14-branchpoint:1.13
	binutils-2_13_2_1:1.11
	binutils-2_13_2:1.11
	binutils-2_13_1:1.11
	binutils-2_13:1.11
	binutils-2_13-branchpoint:1.11
	binutils-2_13-branch:1.11.0.2
	binutils-2_12_1:1.10
	binutils-2_12:1.10
	binutils-2_12-branch:1.10.0.2
	binutils-2_12-branchpoint:1.10
	cygnus_cvs_20020108_pre:1.10
	binutils-2_11_2:1.7.2.1
	binutils-2_11_1:1.7.2.1
	binutils-2_11:1.7
	x86_64versiong3:1.7
	binutils-2_11-branch:1.7.0.2
	binutils-2_10_1:1.5
	binutils-2_10:1.5
	binutils-2_10-branch:1.5.0.2
	binutils-2_10-branchpoint:1.5
	binutils_latest_snapshot:1.37
	repo-unification-2000-02-06:1.5
	binu_ss_19990721:1.5
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.37
date	2013.01.10.19.51.54;	author hjl;	state Exp;
branches;
next	1.36;

1.36
date	2009.09.11.15.27.33;	author nickc;	state Exp;
branches;
next	1.35;

1.35
date	2009.09.02.07.24.19;	author amodra;	state Exp;
branches
	1.35.2.1;
next	1.34;

1.34
date	2009.06.22.17.56.00;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	2007.07.03.11.01.03;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2007.02.16.03.40.17;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2006.12.02.16.24.37;	author hjl;	state Exp;
branches;
next	1.30;

1.30
date	2006.05.03.23.52.15;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2006.05.03.14.26.41;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2006.05.01.05.41.40;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2005.08.11.16.22.08;	author hp;	state Exp;
branches
	1.27.2.1
	1.27.4.1;
next	1.26;

1.26
date	2005.08.11.01.25.20;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2005.05.05.09.12.48;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2005.04.19.15.05.07;	author jbeulich;	state Exp;
branches;
next	1.23;

1.23
date	2005.03.03.11.47.45;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2005.03.03.01.29.53;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2005.02.17.13.46.00;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2005.02.07.17.53.26;	author nathan;	state Exp;
branches;
next	1.19;

1.19
date	2005.01.27.16.33.47;	author nathan;	state Exp;
branches;
next	1.18;

1.18
date	2005.01.21.05.54.38;	author bje;	state Exp;
branches;
next	1.17;

1.17
date	2004.07.19.19.15.43;	author hjl;	state Exp;
branches;
next	1.16;

1.16
date	2004.05.11.15.53.47;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2003.12.03.03.39.58;	author kazu;	state Exp;
branches;
next	1.14;

1.14
date	2003.07.25.14.35.54;	author hjl;	state Exp;
branches;
next	1.13;

1.13
date	2002.12.08.03.47.57;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2002.09.05.00.01.15;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2002.06.12.16.39.29;	author bje;	state Exp;
branches;
next	1.10;

1.10
date	2001.10.05.10.53.00;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2001.08.01.01.44.25;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.08.23.24.22;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2000.11.07.01.18.45;	author kazu;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2000.09.12.03.56.22;	author kazu;	state Exp;
branches;
next	1.5;

1.5
date	99.06.27.08.29.27;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	99.06.22.19.04.42;	author ian;	state Exp;
branches;
next	1.3;

1.3
date	99.06.12.16.49.44;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.06.03.00.29.06;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.41;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.35.2.1
date	2009.09.11.15.28.43;	author nickc;	state Exp;
branches;
next	;

1.27.2.1
date	2006.08.22.15.08.31;	author jsm28;	state Exp;
branches;
next	;

1.27.4.1
date	2006.05.01.05.43.40;	author amodra;	state Exp;
branches;
next	;

1.7.2.1
date	2001.06.07.03.15.25;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.41;	author rth;	state Exp;
branches;
next	;


desc
@@


1.37
log
@Remove trailing white spaces on gas

	* app.c: Remove trailing white spaces.
	* as.c: Likewise.
	* as.h: Likewise.
	* cond.c: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.h: Likewise.
	* ecoff.c: Likewise.
	* input-file.c: Likewise.
	* itbl-lex.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* sb.c: Likewise.
	* subsegs.c: Likewise.
	* symbols.c: Likewise.
	* write.c: Likewise.
	* config/tc-i386.c: Likewise.
	* doc/Makefile.am: Likewise.
	* doc/Makefile.in: Likewise.
	* doc/c-aarch64.texi: Likewise.
	* doc/c-alpha.texi: Likewise.
	* doc/c-arc.texi: Likewise.
	* doc/c-arm.texi: Likewise.
	* doc/c-avr.texi: Likewise.
	* doc/c-bfin.texi: Likewise.
	* doc/c-cr16.texi: Likewise.
	* doc/c-d10v.texi: Likewise.
	* doc/c-d30v.texi: Likewise.
	* doc/c-h8300.texi: Likewise.
	* doc/c-hppa.texi: Likewise.
	* doc/c-i370.texi: Likewise.
	* doc/c-i386.texi: Likewise.
	* doc/c-i860.texi: Likewise.
	* doc/c-m32c.texi: Likewise.
	* doc/c-m32r.texi: Likewise.
	* doc/c-m68hc11.texi: Likewise.
	* doc/c-m68k.texi: Likewise.
	* doc/c-microblaze.texi: Likewise.
	* doc/c-mips.texi: Likewise.
	* doc/c-msp430.texi: Likewise.
	* doc/c-mt.texi: Likewise.
	* doc/c-s390.texi: Likewise.
	* doc/c-score.texi: Likewise.
	* doc/c-sh.texi: Likewise.
	* doc/c-sh64.texi: Likewise.
	* doc/c-tic54x.texi: Likewise.
	* doc/c-tic6x.texi: Likewise.
	* doc/c-v850.texi: Likewise.
	* doc/c-xc16x.texi: Likewise.
	* doc/c-xgate.texi: Likewise.
	* doc/c-xtensa.texi: Likewise.
	* doc/c-z80.texi: Likewise.
	* doc/internals.texi: Likewise.
@
text
@/* subsegs.c - subsegments -
   Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2009
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Segments & sub-segments.  */

#include "as.h"

#include "subsegs.h"
#include "obstack.h"

frchainS *frchain_now;

static struct obstack frchains;

static fragS dummy_frag;


void
subsegs_begin (void)
{
  obstack_begin (&frchains, chunksize);
#if __GNUC__ >= 2
  obstack_alignment_mask (&frchains) = __alignof__ (frchainS) - 1;
#endif

  frchain_now = NULL;		/* Warn new_subseg() that we are booting.  */
  frag_now = &dummy_frag;
}

/*
 *			subseg_change()
 *
 * Change the subsegment we are in, BUT DO NOT MAKE A NEW FRAG for the
 * subsegment. If we are already in the correct subsegment, change nothing.
 * This is used eg as a worker for subseg_set [which does make a new frag_now]
 * and for changing segments after we have read the source. We construct eg
 * fixSs even after the source file is read, so we do have to keep the
 * segment context correct.
 */
void
subseg_change (register segT seg, register int subseg)
{
  segment_info_type *seginfo = seg_info (seg);
  now_seg = seg;
  now_subseg = subseg;

  if (! seginfo)
    {
      seginfo = (segment_info_type *) xcalloc (1, sizeof (*seginfo));
      seginfo->bfd_section = seg;
      bfd_set_section_userdata (stdoutput, seg, seginfo);
    }
}

static void
subseg_set_rest (segT seg, subsegT subseg)
{
  frchainS *frcP;		/* crawl frchain chain */
  frchainS **lastPP;		/* address of last pointer */
  frchainS *newP;		/* address of new frchain */
  segment_info_type *seginfo;

  mri_common_symbol = NULL;

  if (frag_now && frchain_now)
    frchain_now->frch_frag_now = frag_now;

  gas_assert (frchain_now == 0
	  || frchain_now->frch_last == frag_now);

  subseg_change (seg, (int) subseg);

  seginfo = seg_info (seg);

  /* Attempt to find or make a frchain for that subsection.
     We keep the list sorted by subsection number.  */
  for (frcP = *(lastPP = &seginfo->frchainP);
       frcP != NULL;
       frcP = *(lastPP = &frcP->frch_next))
    if (frcP->frch_subseg >= subseg)
      break;

  if (frcP == NULL || frcP->frch_subseg != subseg)
    {
      /* This should be the only code that creates a frchainS.  */

      newP = (frchainS *) obstack_alloc (&frchains, sizeof (frchainS));
      newP->frch_subseg = subseg;
      newP->fix_root = NULL;
      newP->fix_tail = NULL;
      obstack_begin (&newP->frch_obstack, chunksize);
#if __GNUC__ >= 2
      obstack_alignment_mask (&newP->frch_obstack) = __alignof__ (fragS) - 1;
#endif
      newP->frch_frag_now = frag_alloc (&newP->frch_obstack);
      newP->frch_frag_now->fr_type = rs_fill;
      newP->frch_cfi_data = NULL;

      newP->frch_root = newP->frch_last = newP->frch_frag_now;

      *lastPP = newP;
      newP->frch_next = frcP;
      frcP = newP;
    }

  frchain_now = frcP;
  frag_now = frcP->frch_frag_now;

  gas_assert (frchain_now->frch_last == frag_now);
}

/*
 *			subseg_set(segT, subsegT)
 *
 * If you attempt to change to the current subsegment, nothing happens.
 *
 * In:	segT, subsegT code for new subsegment.
 *	frag_now -> incomplete frag for current subsegment.
 *	If frag_now==NULL, then there is no old, incomplete frag, so
 *	the old frag is not closed off.
 *
 * Out:	now_subseg, now_seg updated.
 *	Frchain_now points to the (possibly new) struct frchain for this
 *	sub-segment.
 */

segT
subseg_get (const char *segname, int force_new)
{
  segT secptr;
  segment_info_type *seginfo;
  const char *now_seg_name = (now_seg
			      ? bfd_get_section_name (stdoutput, now_seg)
			      : 0);

  if (!force_new
      && now_seg_name
      && (now_seg_name == segname
	  || !strcmp (now_seg_name, segname)))
    return now_seg;

  if (!force_new)
    secptr = bfd_make_section_old_way (stdoutput, segname);
  else
    secptr = bfd_make_section_anyway (stdoutput, segname);

  seginfo = seg_info (secptr);
  if (! seginfo)
    {
      secptr->output_section = secptr;
      seginfo = (segment_info_type *) xcalloc (1, sizeof (*seginfo));
      seginfo->bfd_section = secptr;
      bfd_set_section_userdata (stdoutput, secptr, seginfo);
    }
  return secptr;
}

segT
subseg_new (const char *segname, subsegT subseg)
{
  segT secptr;

  secptr = subseg_get (segname, 0);
  subseg_set_rest (secptr, subseg);
  return secptr;
}

/* Like subseg_new, except a new section is always created, even if
   a section with that name already exists.  */
segT
subseg_force_new (const char *segname, subsegT subseg)
{
  segT secptr;

  secptr = subseg_get (segname, 1);
  subseg_set_rest (secptr, subseg);
  return secptr;
}

void
subseg_set (segT secptr, subsegT subseg)
{
  if (! (secptr == now_seg && subseg == now_subseg))
    subseg_set_rest (secptr, subseg);
  mri_common_symbol = NULL;
}

#ifndef obj_sec_sym_ok_for_reloc
#define obj_sec_sym_ok_for_reloc(SEC)	0
#endif

symbolS *
section_symbol (segT sec)
{
  segment_info_type *seginfo = seg_info (sec);
  symbolS *s;

  if (seginfo == 0)
    abort ();
  if (seginfo->sym)
    return seginfo->sym;

#ifndef EMIT_SECTION_SYMBOLS
#define EMIT_SECTION_SYMBOLS 1
#endif

  if (! EMIT_SECTION_SYMBOLS || symbol_table_frozen)
    {
      /* Here we know it won't be going into the symbol table.  */
      s = symbol_create (sec->symbol->name, sec, 0, &zero_address_frag);
    }
  else
    {
      segT seg;
      s = symbol_find (sec->symbol->name);
      /* We have to make sure it is the right symbol when we
	 have multiple sections with the same section name.  */
      if (s == NULL
	  || ((seg = S_GET_SEGMENT (s)) != sec
	      && seg != undefined_section))
	s = symbol_new (sec->symbol->name, sec, 0, &zero_address_frag);
      else if (seg == undefined_section)
	{
	  S_SET_SEGMENT (s, sec);
	  symbol_set_frag (s, &zero_address_frag);
	}
    }

  S_CLEAR_EXTERNAL (s);

  /* Use the BFD section symbol, if possible.  */
  if (obj_sec_sym_ok_for_reloc (sec))
    symbol_set_bfdsym (s, sec->symbol);
  else
    symbol_get_bfdsym (s)->flags |= BSF_SECTION_SYM;

  seginfo->sym = s;
  return s;
}

/* Return whether the specified segment is thought to hold text.  */

int
subseg_text_p (segT sec)
{
  return (bfd_get_section_flags (stdoutput, sec) & SEC_CODE) != 0;
}

/* Return non zero if SEC has at least one byte of data.  It is
   possible that we'll return zero even on a non-empty section because
   we don't know all the fragment types, and it is possible that an
   fr_fix == 0 one still contributes data.  Think of this as
   seg_definitely_not_empty_p.  */

int
seg_not_empty_p (segT sec ATTRIBUTE_UNUSED)
{
  segment_info_type *seginfo = seg_info (sec);
  frchainS *chain;
  fragS *frag;

  if (!seginfo)
    return 0;

  for (chain = seginfo->frchainP; chain; chain = chain->frch_next)
    {
      for (frag = chain->frch_root; frag; frag = frag->fr_next)
	if (frag->fr_fix)
	  return 1;
      if (obstack_next_free (&chain->frch_obstack)
	  != chain->frch_last->fr_literal)
	return 1;
    }
  return 0;
}

void
subsegs_print_statistics (FILE *file)
{
  frchainS *frchp;
  asection *s;

  fprintf (file, "frag chains:\n");
  for (s = stdoutput->sections; s; s = s->next)
    {
      segment_info_type *seginfo;

      /* Skip gas-internal sections.  */
      if (segment_name (s)[0] == '*')
	continue;

      seginfo = seg_info (s);
      if (!seginfo)
	continue;

      for (frchp = seginfo->frchainP; frchp; frchp = frchp->frch_next)
	{
	  int count = 0;
	  fragS *fragp;

	  for (fragp = frchp->frch_root; fragp; fragp = fragp->fr_next)
	    count++;

	  fprintf (file, "\n");
	  fprintf (file, "\t%p %-10s\t%10d frags\n", (void *) frchp,
		   segment_name (s), count);
	}
    }
}

/* end of subsegs.c */
@


1.36
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        * as.c (main): Call dwarf2_init.
        * config/obj-elf.c (struct group_list): New field.
        (build_group_lists): Use hash lookup.
        (free_section_idx): New function.
        (elf_frob_file): Adjust.
        * dwarf2dbg.c (all_segs_hash, last_seg_ptr): New variables.
        (get_line_subseg): Adjust.
        (dwarf2_init): New function.
        * dwarf2dbg.h (dwarf2_init): New declaration.
@
text
@d283 1
a283 1
  
@


1.35
log
@update copyright dates
@
text
@d68 1
a68 1
      seginfo = xcalloc (1, sizeof (*seginfo));
d106 1
a106 1
      newP = obstack_alloc (&frchains, sizeof (frchainS));
d170 1
a170 1
      seginfo = xcalloc (1, sizeof (*seginfo));
@


1.35.2.1
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.
@
text
@d68 1
a68 1
      seginfo = (segment_info_type *) xcalloc (1, sizeof (*seginfo));
d106 1
a106 1
      newP = (frchainS *) obstack_alloc (&frchains, sizeof (frchainS));
d170 1
a170 1
      seginfo = (segment_info_type *) xcalloc (1, sizeof (*seginfo));
@


1.34
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
@


1.33
log
@Switch to GPLv3
@
text
@d87 1
a87 1
  assert (frchain_now == 0
d128 1
a128 1
  assert (frchain_now->frch_last == frag_now);
@


1.32
log
@	* subsegs.c (subseg_change, subseg_get): Use xcalloc rather than
	xmalloc, memset.  Don't bother assigning NULL to known zero mem.
	(subseg_set_rest): Remove unnecessary cast.
	* write.c: Include libbfd.h.  Replace PTR with void * throughout.
	Remove unnecessary forward declarations and casts.
	(set_symtab): Delete extern bfd_alloc.
	(fixup_segment): Move.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.31
log
@Really check in the patch.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
d68 1
a68 4
      seginfo = (segment_info_type *) xmalloc (sizeof (*seginfo));
      memset ((PTR) seginfo, 0, sizeof (*seginfo));
      seginfo->fix_root = NULL;
      seginfo->fix_tail = NULL;
d70 1
a70 2
      seginfo->sym = 0;
      bfd_set_section_userdata (stdoutput, seg, (PTR) seginfo);
d106 1
a106 1
      newP = (frchainS *) obstack_alloc (&frchains, sizeof (frchainS));
d170 1
a170 4
      seginfo = (segment_info_type *) xmalloc (sizeof (*seginfo));
      memset ((PTR) seginfo, 0, sizeof (*seginfo));
      seginfo->fix_root = NULL;
      seginfo->fix_tail = NULL;
d172 1
a172 5
      bfd_set_section_userdata (stdoutput, secptr, (PTR) seginfo);
      seginfo->frchainP = NULL;
      seginfo->lineno_list_head = seginfo->lineno_list_tail = NULL;
      seginfo->sym = NULL;
      seginfo->dot = NULL;
@


1.30
log
@	* subsegs.h (struct frchain): Delete frch_seg.
	(frchain_root): Delete.
	(seg_info): Define as macro.
	* subsegs.c (frchain_root): Delete.
	(abs_seg_info, und_seg_info, absolute_frchain): Delete.
	(subsegs_begin, subseg_change): Adjust for above.
	(subseg_set_rest): Likewise.  Add new frchain structs to seginfo
	rather than to one big list.
	(subseg_get): Don't special case abs, und sections.
	(subseg_new, subseg_force_new): Don't set frchainP here.
	(seg_info): Delete.
	(subsegs_print_statistics): Adjust frag chain control list traversal.
	* debug.c (dmp_frags):  Likewise.
	* dwarf2dbg.c (first_frag_for_seg): Don't start looking for frag
	at frchain_root.  Make use of known frchain ordering.
	(last_frag_for_seg): Likewise.
	(get_frag_fix): Likewise.  Add seg param.
	(process_entries, out_debug_aranges): Adjust get_frag_fix calls.
	* write.c (chain_frchains_together_1): Adjust for struct frchain.
	(SUB_SEGMENT_ALIGN): Likewise.
	(subsegs_finish): Adjust frchain list traversal.
	* config/tc-xtensa.c (xtensa_cleanup_align_frags): Likewise.
	(xtensa_fix_target_frags, xtensa_mark_narrow_branches): Likewise.
	(xtensa_mark_zcl_first_insns, xtensa_fix_a0_b_retw_frags): Likewise.
	(xtensa_fix_b_j_loop_end_frags): Likewise.
	(xtensa_fix_close_loop_end_frags): Likewise.
	(xtensa_fix_short_loop_frags, xtensa_sanity_check): Likewise.
	(retrieve_segment_info): Delete frch_seg initialisation.
@
text
@d120 1
@


1.29
log
@bfd/
	* libbfd-in.h (_bfd_generic_new_section_hook): Declare.
	* section.c (bfd_abs_symbol, bfd_com_symbol): Delete.
	(bfd_und_symbol, bfd_ind_symbol): Delete.
	(BFD_FAKE_SECTION): Remove SYM_PTR param, set symbol_ptr_ptr to
	&SEC.symbol.
	(STD_SECTION): Adjust.
	(_bfd_generic_new_section_hook): New function, extracted from..
	(bfd_section_init): ..here.
	(bfd_make_section_old_way): Call new_section_hook for abs, com,
	und and ind sections.
	* elf.c (_bfd_elf_large_com_section): Adjust.
	* aoutx.h (new_section_hook): Call _bfd_generic_new_section_hook.
	* pdp11.c (new_section_hook): Likewise.
	* coffcode.h (coff_new_section_hook): Likewise.
	* ecoff.c (_bfd_ecoff_new_section_hook): Likewise.
	* elf.c (_bfd_elf_new_section_hook): Likewise.
	* vms.c (vms_new_section_hook): Likwise.
	* elf32-arm.c (elf32_arm_new_section_hook): Check used_by_bfd isn't
	already set.
	* elf32-sh64.c (sh64_elf_new_section_hook): Likewise.
	* elf32-xtensa.c (elf_xtensa_new_section_hook): Likewise.
	* elf64-mmix.c (mmix_elf_new_section_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_new_section_hook): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_new_section_hook): Likewise.
	* elfxx-sparc.c (_bfd_sparc_elf_new_section_hook): Likewise.
	* ieee.c (ieee_new_section_hook): Likewise.  Call
	_bfd_generic_new_section_hook too.
	* mmo.c (mmo_new_section_hook): Likewise.
	* oasys.c (oasys_new_section_hook): Likewise.
	* som.c (som_new_section_hook): Likewise.
	* coff-w65.c (reloc_processing): Don't use bfd_abs_symbol.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
gas/
	* subsegs.c (subseg_get): Don't call obj_sec_set_private_data.
	* config/obj-elf.h (obj_sec_set_private_data): Delete.
	* config/tc-hppa.c (tc_gen_reloc): Don't use bfd_abs_symbol.
	* config/tc-mn10300.c (tc_gen_reloc): Likewise.
@
text
@d30 1
a30 1
frchainS *frchain_root, *frchain_now;
a33 7
/* Gas segment information for bfd_abs_section_ptr and
   bfd_und_section_ptr.  */
static segment_info_type *abs_seg_info;
static segment_info_type *und_seg_info;

static void subseg_set_rest (segT, subsegT);

a35 1
static frchainS absolute_frchain;
a44 1
  frchain_root = NULL;
a45 1

a46 6

  absolute_frchain.frch_seg = absolute_section;
  absolute_frchain.frch_subseg = 0;
  absolute_frchain.fix_root = absolute_frchain.fix_tail = 0;
  absolute_frchain.frch_frag_now = &zero_address_frag;
  absolute_frchain.frch_root = absolute_frchain.frch_last = &zero_address_frag;
d62 1
a62 1
  segment_info_type *seginfo;
a65 4
  if (now_seg == absolute_section)
    return;

  seginfo = (segment_info_type *) bfd_get_section_userdata (stdoutput, seg);
d74 1
a74 6
      if (seg == bfd_abs_section_ptr)
	abs_seg_info = seginfo;
      else if (seg == bfd_und_section_ptr)
	und_seg_info = seginfo;
      else
	bfd_set_section_userdata (stdoutput, seg, (PTR) seginfo);
d81 2
a82 2
  register frchainS *frcP;	/* crawl frchain chain */
  register frchainS **lastPP;	/* address of last pointer */
d84 1
a91 2
	  || now_seg == undefined_section
	  || now_seg == absolute_section
d96 1
a96 10
  if (seg == absolute_section)
    {
      frchain_now = &absolute_frchain;
      frag_now = &zero_address_frag;
      return;
    }

  assert (frchain_now == 0
	  || now_seg == undefined_section
	  || frchain_now->frch_last == frag_now);
d98 4
a101 8
  /*
   * Attempt to find or make a frchain for that sub seg.
   * Crawl along chain of frchainSs, begins @@ frchain_root.
   * If we need to make a frchainS, link it into correct
   * position of chain rooted in frchain_root.
   */
  for (frcP = *(lastPP = &frchain_root);
       frcP && frcP->frch_seg <= seg;
d103 4
d108 1
a108 35
      if (frcP->frch_seg == seg
	  && frcP->frch_subseg >= subseg)
	{
	  break;
	}
    }
  /*
   * frcP:		Address of the 1st frchainS in correct segment with
   *		frch_subseg >= subseg.
   *		We want to either use this frchainS, or we want
   *		to insert a new frchainS just before it.
   *
   *		If frcP==NULL, then we are at the end of the chain
   *		of frchainS-s. A NULL frcP means we fell off the end
   *		of the chain looking for a
   *		frch_subseg >= subseg, so we
   *		must make a new frchainS.
   *
   *		If we ever maintain a pointer to
   *		the last frchainS in the chain, we change that pointer
   *		ONLY when frcP==NULL.
   *
   * lastPP:	Address of the pointer with value frcP;
   *		Never NULL.
   *		May point to frchain_root.
   *
   */
  if (!frcP
      || (frcP->frch_seg > seg
	  || frcP->frch_subseg > subseg))	/* Kinky logic only works with 2 segments.  */
    {
      /*
       * This should be the only code that creates a frchainS.
       */
      segment_info_type *seginfo;
a111 1
      newP->frch_seg = seg;
d124 1
a124 6
      newP->frch_next = frcP;	/* perhaps NULL */

      seginfo = seg_info (seg);
      if (seginfo && (!seginfo->frchainP || seginfo->frchainP == frcP))
	seginfo->frchainP = newP;

d127 1
a127 3
  /*
   * Here with frcP pointing to the frchainS for subseg.
   */
a146 1
 *	Frchain_root updated if needed.
d172 1
a172 4
      /* Check whether output_section is set first because secptr may
	 be bfd_abs_section_ptr.  */
      if (secptr->output_section != secptr)
	secptr->output_section = secptr;
d178 1
a178 6
      if (secptr == bfd_abs_section_ptr)
	abs_seg_info = seginfo;
      else if (secptr == bfd_und_section_ptr)
	und_seg_info = seginfo;
      else
	bfd_set_section_userdata (stdoutput, secptr, (PTR) seginfo);
a190 1
  segment_info_type *seginfo;
a193 3
  seginfo = seg_info (secptr);
  if (! seginfo->frchainP)
    seginfo->frchainP = frchain_now;
a202 1
  segment_info_type *seginfo;
a205 3
  seginfo = seg_info (secptr);
  if (! seginfo->frchainP)
    seginfo->frchainP = frchain_now;
a220 13
/* Get the gas information we are storing for a section.  */

segment_info_type *
seg_info (segT sec)
{
  if (sec == bfd_abs_section_ptr)
    return abs_seg_info;
  else if (sec == bfd_und_section_ptr)
    return und_seg_info;
  else
    return (segment_info_type *) bfd_get_section_userdata (stdoutput, sec);
}

d310 2
d313 1
a313 1
  for (frchp = frchain_root; frchp; frchp = frchp->frch_next)
d315 1
a315 2
      int count = 0;
      fragS *fragp;
d317 2
a318 3
      /* If frch_subseg is non-zero, it's probably been chained onto
	 the end of a previous subsection.  Don't count it again.  */
      if (frchp->frch_subseg != 0)
d321 2
a322 2
      /* Skip gas-internal sections.  */
      if (segment_name (frchp->frch_seg)[0] == '*')
d325 1
a325 1
      for (fragp = frchp->frch_root; fragp; fragp = fragp->fr_next)
d327 9
a335 1
	  count++;
a336 3
      fprintf (file, "\n");
      fprintf (file, "\t%p %-10s\t%10d frags\n", (void *) frchp,
	       segment_name (frchp->frch_seg), count);
@


1.28
log
@	* subsegs.c (subseg_set_rest): Always set seginfp->frchainP if NULL.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003, 2004, 2005
a246 4
#ifdef obj_sec_set_private_data
  obj_sec_set_private_data (stdoutput, secptr);
#endif

@


1.27
log
@	* subsegs.c (subseg_change): Move declaration of seginfo to before
	first statement.
@
text
@d197 1
a197 1
      if (seginfo && seginfo->frchainP == frcP)
@


1.27.2.1
log
@Merge changes between binutils-csl-2_17-branchpoint and
binutils-2_17, except for the addition of generated files to CVS.
@
text
@d197 1
a197 1
      if (seginfo && (!seginfo->frchainP || seginfo->frchainP == frcP))
@


1.27.4.1
log
@	* subsegs.c (subseg_set_rest): Always set seginfp->frchainP if NULL.
@
text
@d197 1
a197 1
      if (seginfo && (!seginfo->frchainP || seginfo->frchainP == frcP))
@


1.26
log
@	* README-vms: Delete.
	* config-gas.com: Delete.
	* makefile.vms: Delete.
	* vmsconf.sh: Delete.
	* config/atof-tahoe.c: Delete.
	* config/m88k-opcode.h: Delete.
	* config/obj-bout.c: Delete.
	* config/obj-bout.h: Delete.
	* config/obj-hp300.c: Delete.
	* config/obj-hp300.h: Delete.
	* config/tc-a29k.c: Delete.
	* config/tc-a29k.h: Delete.
	* config/tc-h8500.c: Delete.
	* config/tc-h8500.h: Delete.
	* config/tc-m88k.c: Delete.
	* config/tc-m88k.h: Delete.
	* config/tc-tahoe.c: Delete.
	* config/tc-tahoe.h: Delete.
	* config/tc-tic80.c: Delete.
	* config/tc-tic80.h: Delete.
	* config/tc-w65.c: Delete.
	* config/tc-w65.h: Delete.
	* config/te-aux.h: Delete.
	* config/te-delt88.h: Delete.
	* config/te-delta.h: Delete.
	* config/te-dpx2.h: Delete.
	* config/te-hp300.h: Delete.
	* config/te-ic960.h: Delete.
	* config/vms-a-conf.h: Delete.
	* doc/c-a29k.texi: Delete.
	* doc/c-h8500.texi: Delete.
	* doc/c-m88k.texi: Delete.
	* README: Remove obsolete examples, and list of supported targets.
	* Makefile.am: Remove a29k, h8500, m88k, tahoe, tic80, w65,
	bout and hp300 support.
	(DEP_FLAGS): Don't define BFD_ASSEMBLER.
	* configure.in: Remove --enable-bfd-assembler, need_bfd,
	primary_bfd_gas.
	* configure.tgt: Remove a29k, h8300-coff, h8500-*, i960 non-elf,
	m68k non bfd, m88k, or32-coff, tic80-*, vax non-bfd, w65k-*, *-nindy.
	* as.c: Remove all non-BFD_ASSEMBLER code, support for above targets.
	* as.h: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
	* input-file.c: Likewise.
	* listing.c: Likewise.
	* literal.c: Likewise.
	* messages.c: Likewise.
	* obj.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* stabs.c: Likewise.
	* struc-symbol.h: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* symbols.c: Likewise.
	* symbols.h: Likewise.
	* tc.h: Likewise.
	* write.c: Likewise.
	* write.h: Likewise.
	* config/aout_gnu.h: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-aout.h: Likewise.
	* config/obj-coff.c: Likewise.
	* config/obj-coff.h: Likewise.
	* config/obj-evax.h: Likewise.
	* config/obj-ieee.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-crx.h: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-d30v.h: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-fr30.h: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-hppa.h: Likewise.
	* config/tc-i370.h: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i860.h: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ip2k.h: Likewise.
	* config/tc-iq2000.h: Likewise.
	* config/tc-m32c.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m68k.h: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-maxq.h: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mn10200.h: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-mn10300.h: Likewise.
	* config/tc-ms1.h: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-msp430.h: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-ns32k.h: Likewise.
	* config/tc-openrisc.h: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.h: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic4x.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-vax.h: Likewise.
	* config/tc-xstormy16.h: Likewise.
	* config/tc-xtensa.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-z8k.h: Likewise.
	* config/vms-a-conf.h
	* doc/Makefile.am: Likewise.
	* doc/all.texi: Likewise.
	* doc/as.texinfo: Likewise.
	* doc/Makefile.in: Regenerate.
	* Makefile.in: Regenerate.
	* configure: Regenerate.
	* config.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d78 1
a80 1
  segment_info_type *seginfo;
@


1.25
log
@Update the address and phone number of the FSF
@
text
@a33 32
#ifndef BFD_ASSEMBLER
#ifdef MANY_SEGMENTS
segment_info_type segment_info[SEG_MAXIMUM_ORDINAL];

#else
/* Commented in "subsegs.h".  */
frchainS *data0_frchainP, *bss0_frchainP;

#endif /* MANY_SEGMENTS */
char const *const seg_name[] = {
  "absolute",
#ifdef MANY_SEGMENTS
  "e0", "e1", "e2", "e3", "e4", "e5", "e6", "e7", "e8", "e9",
  "e10", "e11", "e12", "e13", "e14", "e15", "e16", "e17", "e18", "e19",
  "e20", "e21", "e22", "e23", "e24", "e25", "e26", "e27", "e28", "e29",
  "e30", "e31", "e32", "e33", "e34", "e35", "e36", "e37", "e38", "e39",
#else
  "text",
  "data",
  "bss",
#endif /* MANY_SEGMENTS */
  "unknown",
  "ASSEMBLER-INTERNAL-LOGIC-ERROR!",
  "expr",
  "debug",
  "transfert vector preload",
  "transfert vector postload",
  "register",
  "",
};				/* Used by error reporters, dumpers etc.  */
#else /* BFD_ASSEMBLER */

a38 2
#endif /* BFD_ASSEMBLER */

a47 16
  /* Check table(s) seg_name[], seg_N_TYPE[] is in correct order */
#if !defined (MANY_SEGMENTS) && !defined (BFD_ASSEMBLER)
  know (SEG_ABSOLUTE == 0);
  know (SEG_TEXT == 1);
  know (SEG_DATA == 2);
  know (SEG_BSS == 3);
  know (SEG_UNKNOWN == 4);
  know (SEG_GOOF == 5);
  know (SEG_EXPR == 6);
  know (SEG_DEBUG == 7);
  know (SEG_NTV == 8);
  know (SEG_PTV == 9);
  know (SEG_REGISTER == 10);
  know (SEG_MAXIMUM_ORDINAL == SEG_REGISTER);
#endif

a57 21
#ifndef BFD_ASSEMBLER
  now_subseg = 42;		/* Lie for 1st call to subseg_new.  */
#ifdef MANY_SEGMENTS
  {
    int i;
    for (i = SEG_E0; i < SEG_UNKNOWN; i++)
      {
	subseg_set (i, 0);
	segment_info[i].frchainP = frchain_now;
      }
  }
#else
  subseg_set (SEG_DATA, 0);	/* .data 0 */
  data0_frchainP = frchain_now;

  subseg_set (SEG_BSS, 0);
  bss0_frchainP = frchain_now;

#endif /* ! MANY_SEGMENTS */
#endif /* ! BFD_ASSEMBLER */

a59 1
#ifdef BFD_ASSEMBLER
a60 1
#endif
d80 1
d85 2
a86 26
#ifdef BFD_ASSEMBLER
  {
    segment_info_type *seginfo;
    seginfo = (segment_info_type *) bfd_get_section_userdata (stdoutput, seg);
    if (! seginfo)
      {
	seginfo = (segment_info_type *) xmalloc (sizeof (*seginfo));
	memset ((PTR) seginfo, 0, sizeof (*seginfo));
	seginfo->fix_root = NULL;
	seginfo->fix_tail = NULL;
	seginfo->bfd_section = seg;
	seginfo->sym = 0;
	if (seg == bfd_abs_section_ptr)
	  abs_seg_info = seginfo;
	else if (seg == bfd_und_section_ptr)
	  und_seg_info = seginfo;
	else
	  bfd_set_section_userdata (stdoutput, seg, (PTR) seginfo);
      }
  }
#else
#ifdef MANY_SEGMENTS
  seg_fix_rootP = &segment_info[seg].fix_root;
  seg_fix_tailP = &segment_info[seg].fix_tail;
#else
  if (seg == SEG_DATA)
d88 12
a99 2
      seg_fix_rootP = &data_fix_root;
      seg_fix_tailP = &data_fix_tail;
a100 14
  else if (seg == SEG_TEXT)
    {
      seg_fix_rootP = &text_fix_root;
      seg_fix_tailP = &text_fix_tail;
    }
  else
    {
      know (seg == SEG_BSS);
      seg_fix_rootP = &bss_fix_root;
      seg_fix_tailP = &bss_fix_tail;
    }

#endif
#endif
d177 2
a181 1
#ifdef BFD_ASSEMBLER
a183 1
#endif
d196 3
a198 8
#ifdef BFD_ASSEMBLER
      {
	segment_info_type *seginfo;
	seginfo = seg_info (seg);
	if (seginfo && seginfo->frchainP == frcP)
	  seginfo->frchainP = newP;
      }
#endif
a226 67
#ifndef BFD_ASSEMBLER

segT
subseg_new (segname, subseg)
     const char *segname;
     subsegT subseg;
{
  int i;

  for (i = 0; i < (int) SEG_MAXIMUM_ORDINAL; i++)
    {
      const char *s;

      s = segment_name ((segT) i);
      if (strcmp (segname, s) == 0
	  || (segname[0] == '.'
	      && strcmp (segname + 1, s) == 0))
	{
	  subseg_set ((segT) i, subseg);
	  return (segT) i;
	}
#ifdef obj_segment_name
      s = obj_segment_name ((segT) i);
      if (strcmp (segname, s) == 0
	  || (segname[0] == '.'
	      && strcmp (segname + 1, s) == 0))
	{
	  subseg_set ((segT) i, subseg);
	  return (segT) i;
	}
#endif
    }

#ifdef obj_add_segment
  {
    segT new_seg;
    new_seg = obj_add_segment (segname);
    subseg_set (new_seg, subseg);
    return new_seg;
  }
#else
  as_bad (_("attempt to switch to nonexistent segment \"%s\""), segname);
  return now_seg;
#endif
}

void
subseg_set (seg, subseg)	/* begin assembly for a new sub-segment */
     register segT seg;		/* SEG_DATA or SEG_TEXT */
     register subsegT subseg;
{
#ifndef MANY_SEGMENTS
  know (seg == SEG_DATA
	|| seg == SEG_TEXT
	|| seg == SEG_BSS
	|| seg == SEG_ABSOLUTE);
#endif

  if (seg != now_seg || subseg != now_subseg)
    {				/* we just changed sub-segments */
      subseg_set_rest (seg, subseg);
    }
  mri_common_symbol = NULL;
}

#else /* BFD_ASSEMBLER */

a380 2
#endif /* BFD_ASSEMBLER */

a382 14
#ifndef BFD_ASSEMBLER
const char * const nontext_section_names[] = {
  ".eh_frame",
  ".gcc_except_table",
#ifdef OBJ_COFF
#ifndef COFF_LONG_SECTION_NAMES
  ".eh_fram",
  ".gcc_exc",
#endif
#endif
  NULL
};
#endif /* ! BFD_ASSEMBLER */

a385 1
#ifdef BFD_ASSEMBLER
a386 20
#else /* ! BFD_ASSEMBLER */
  const char * const *p;

  if (sec == data_section || sec == bss_section || sec == absolute_section)
    return 0;

  for (p = nontext_section_names; *p != NULL; ++p)
    {
      if (strcmp (segment_name (sec), *p) == 0)
	return 0;

#ifdef obj_segment_name
      if (strcmp (obj_segment_name (sec), *p) == 0)
	return 0;
#endif
    }

  return 1;

#endif /* ! BFD_ASSEMBLER */
@


1.24
log
@gas/
2005-04-19  Jan Beulich  <jbeulich@@novell.com>

	* symbols.h (symbol_find_base): Remove prototype.
	* symbols.c (save_symbol_name): Remove code section conditional upon
	STRIP_UNDERSCORE.
	(symbol_find): Remove.
	(symbol_find_base): Rename to symbol_find.
	* subsegs.c (section_symbol): Replace use of symbol_find_base with
	symbol_find.
	* config/obj-coff.c (tag_insert): Remove code section conditional
	upon STRIP_UNDERSCORE.
	(obj_coff_def): Likewise.
	(obj_coff_endef): Replace use of symbol_find_base with symbol_find.
	(coff_frob_symbol): Likewise.
	(yank_symbols): Likewise.
	(c_section_symbol): Likewise.
	* config/obj-coff.h (DO_NOT_STRIP): Remove.
	* config/tc-arm.c (symbol_locate): Remove code section conditional
	upon STRIP_UNDERSCORE.
	* config/tc-h8300.h (DO_NOT_STRIP): Remove.
	* config/tc-h8500.h (DO_NOT_STRIP): Remove.
	* config/tc-sh.h (DO_NOT_STRIP): Remove.
	* config/tc-w65.h (DO_NOT_STRIP): Remove.
	* config/tc-z8k.h (DO_NOT_STRIP): Remove.
@
text
@d20 2
a21 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.23
log
@update copyright dates
@
text
@d527 1
a527 1
      s = symbol_find_base (sec->symbol->name, 0);
@


1.22
log
@update copyright dates
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2004, 2005
@


1.21
log
@	* tc.h (struct relax_type, relax_typeS): Move from here..
	* as.h: ..to here.  Make rlx_forward and rlx_backward an offsetT.
	* ecoff.c (ecoff_new_file): Add appfile param.
	* ecoff.h (ecoff_new_file): Likewise.
	* itbl-lex.h: New file.
	* itbl-lex.l: Include itbl-lex.h.
	* itbl-parse.y: Likewise.
	(insntbl_line, yyparse, yylex): Move to itbl-lex.h.
	* read.c (s_app_file_string): Mark appfile possibly unused.
	* subsegs.c (seg_not_empty_p): Make sec possibly unused.
	* subsegs.h (struct seg_info_trash): Delete.
	(seg_info): Use segment_info_type instead.
	* config/obj-coff.c (struct filename_list): Make filename const char *.
	* config/obj-ecoff.h (obj_app_file): Pass app to ecoff_new_file.
	* config/obj-elf.c (elf_file_symbol): Similarly.
	* config/tc-a29k.c (md_apply_fix3): Make val a valueT.  Don't use
	signed right shift.
	* config/tc-arc.c (md_operand): Warning fix.
	* config/tc-arm.c (arm_parse_reloc): Only define when OBJ_ELF.
	(md_begin): Rearrange #if defined OBJ_COFF || defined OBJ_ELF.
	* config/tc-cris.h (TC_IMPLICIT_LCOMM_ALIGNMENT): Use do while.
	* config/tc-frv.c (frv_force_relocation): Warning fix.
	* config/tc-m68k.c (md_parse_option): Delete unused var.
	* config/tc-mcore.c (mylog2): Rename from log2 throughout.
	* config/tc-sparc.c: Likewise.
	(s_common): Warning fix.
	* config/tc-mips.c (append_insn): Use unsigned long long expressions.
	* config/tc-mmix.c (PUSHJSTUB_MAX, PUSHJSTUB_MIN): Define from
	addressT.
	* config/tc-s390.c (s390_insn): Delete test of unsigned >= 0.
	* config/tc-sh.c (sh_cfi_frame_initial_instructions,
	sh_regname_to_dw2regnum): Only define for OBJ_ELF.
	* config/tc-tic4x.c (tic4x_insert_reg): Use ISLOWER.
	(tic4x_do_align): Use TIC_NOP_OPCODE.
	* config/tc-tic4x.h (TIC_NOP_OPCODE): Rename from NOP_OPCODE.
	* config/tc-vax.c: Include netinet/in.h.
	(tc_headers_hook): Formatting.
	* config/tc-xstormy16.c (md_pcrel_from_section): Correct parens.
@
text
@d3 1
a3 1
   1999, 2000, 2002, 2004, 2005
@


1.20
log
@	* as.h (seg_not_empty_p): Return int, not bfd_boolean.
	* subsegs.c (seg_not_empty_p): Likewise.
@
text
@d3 1
a3 1
   1999, 2000, 2002, 2004
d605 1
a605 1
seg_not_empty_p (segT sec)
@


1.19
log
@	* dwarf2dbg.c (dwarf2_finish): Correct logic for determining when
	to emit .debug_line and other debug sections.
	* as.h (seg_not_empty_p): Declare.
	* subsegs.c (seg_not_empty_p): New predicate.
@
text
@d604 1
a604 1
bfd_boolean
@


1.18
log
@	* as.h: Remove #if 0'd code.
	* atof-generic.c (atof_generic): Likewise.
	* ecoff.c (ecoff_directive_frame): Likewise.
	* frags.h (FRAG_APPEND_1_CHAR): Likewise.
	* itbl-ops.c (itbl_add_reg): Likewise.
	* listing.c (calc_hex): Likewise.
	* read.c (MASK_CHAR): Likewise.
	* subsegs.c (subsegs_print_statistics): Likewise.
	* symbols.c (indent): Likewise.
	* write.c (write_relocs): Likewise.
	(write_object_file): Likewise.
	(relax_frag): Likewise.
@
text
@d598 28
@


1.17
log
@2004-07-19  Christopher Faylor  <cgf@@timesys.com>
	    H.J. Lu  <hongjiu.lu@@intel.com>

	* subsegs.c (section_symbol): Don't create a new segment when
	existing segment is undefined.
@
text
@a618 21
#if 0
	  switch (fragp->fr_type)
	    {
	    case rs_fill:
	      fprintf (file, "f"); break;
	    case rs_align:
	      fprintf (file, "a"); break;
	    case rs_align_code:
	      fprintf (file, "c"); break;
	    case rs_org:
	      fprintf (file, "o"); break;
	    case rs_machine_dependent:
	      fprintf (file, "m"); break;
	    case rs_space:
	      fprintf (file, "s"); break;
	    case 0:
	      fprintf (file, "0"); break;
	    default:
	      fprintf (file, "?"); break;
	    }
#endif
@


1.16
log
@Apply H.J.'s patch to fix label arithmetic when multiple same-name sections are involved
@
text
@d526 1
d530 3
a532 1
      if (s == NULL || S_GET_SEGMENT (s) != sec)
d534 1
a534 1
      else
d536 2
a537 5
	  if (S_GET_SEGMENT (s) == undefined_section)
	    {
	      S_SET_SEGMENT (s, sec);
	      symbol_set_frag (s, &zero_address_frag);
	    }
@


1.15
log
@	* messages.c: Convert to ISO-C.
	* obj.h: Likewise.
	* output-file.c: Likewise.
	* output-file.h: Likewise.
	* sb.c: Likewise.
	* sb.h: Likewise.
	* stabs.c: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* tc.h: Likewise.
@
text
@d3 1
a3 1
   1999, 2000, 2002
d527 3
a529 1
      if (s == NULL)
@


1.14
log
@bfd/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (bfd_elf_special_section): New.
	(elf_backend_data): Add special_sections, a pointer to
	bfd_elf_special_section.
	(elf_section_type). New.
	(elf_section_flags): New.
	(_bfd_elf_get_sec_type_attr): New.

	* elf.c (_bfd_elf_make_section_from_shdr): Always use the
	real section type/flags.
	(special_sections): New.
	(get_special_section): New.
	(_bfd_elf_get_sec_type_attr): New.
	(_bfd_elf_new_section_hook): Check special_section to set
	elf_section_type and elf_section_flags.
	(elf_fake_sections): Don't use section name to set ELF section
	data.

	* elf32-m32r.c (m32r_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-m68hc11.c (elf32_m68hc11_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-mcore.c (mcore_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-ppc.c (ppc_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-sh64.c (sh64_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-v850.c (v850_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf32-xtensa.c (elf_xtensa_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-alpha.c (elf64_alpha_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-hppa.c (elf64_hppa_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-ppc.c (ppc64_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elf64-sh64.c (sh64_elf64_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-ia64.c (elfNN_ia64_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-mips.c (_bfd_mips_elf_special_sections): New.

	* elfxx-mips.h (_bfd_mips_elf_special_sections): New.
	(elf_backend_special_sections): Defined.

	* elfxx-target.h (elf_backend_special_sections): New. Default
	to NULL.
	(elfNN_bed): Initialize special_sections.

	* section.c (bfd_abs_section): Remove const.
	(bfd_und_section): Likewise.
	(bfd_com_section): Likewise.
	(bfd_ind_section): Likewise.

gas/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-elf.c (special_sections): Removed.
	(obj_elf_change_section): Call _bfd_elf_get_sec_type_attr. Set
	elf_section_type and elf_section_flags.
	(elf_frob_file): Set SHT_GROUP.

	* config/obj-elf.h (obj_sec_set_private_data): New.

	* config/tc-alpha.h (ELF_TC_SPECIAL_SECTIONS): Removed.
	* config/tc-ia64.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mips.h: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-sh64.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-xtensa.h: Likewise.

	* config/tc-v850.h (SHF_V850_GPREL): Removed.
	(SHF_V850_EPREL): Likewise.
	(SHF_V850_R0REL): Likewise.

	* subsegs.c (subseg_get): Call obj_sec_set_private_data if it
	is defined.

include/elf/

2003-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* v850.h (SHF_V850_GPREL): New.
	(SHF_V850_EPREL): Likewise.
	(SHF_V850_R0REL): Likewise.
@
text
@d73 1
a73 1
static void subseg_set_rest PARAMS ((segT, subsegT));
d80 1
a80 1
subsegs_begin ()
d149 1
a149 3
subseg_change (seg, subseg)
     register segT seg;
     register int subseg;
d204 1
a204 3
subseg_set_rest (seg, subseg)
     segT seg;
     subsegT subseg;
d400 1
a400 3
subseg_get (segname, force_new)
     const char *segname;
     int force_new;
d450 1
a450 3
subseg_new (segname, subseg)
     const char *segname;
     subsegT subseg;
d466 1
a466 3
subseg_force_new (segname, subseg)
     const char *segname;
     subsegT subseg;
d480 1
a480 3
subseg_set (secptr, subseg)
     segT secptr;
     subsegT subseg;
d494 1
a494 2
seg_info (sec)
     segT sec;
d505 1
a505 2
section_symbol (sec)
     segT sec;
d570 1
a570 2
subseg_text_p (sec)
     segT sec;
d597 1
a597 2
subsegs_print_statistics (file)
     FILE *file;
@


1.13
log
@	* subsegs.c (section_symbol): Use the symbol, not the section, name.
@
text
@d425 4
@


1.12
log
@gas reloc rewrite.
@
text
@d429 1
a429 1
         be bfd_abs_section_ptr.  */
d532 1
a532 1
      s = symbol_create (sec->name, sec, 0, &zero_address_frag);
d536 1
a536 1
      s = symbol_find_base (sec->name, 0);
d538 1
a538 1
	s = symbol_new (sec->name, sec, 0, &zero_address_frag);
@


1.11
log
@	* symbols.c (resolve_symbol_value): Initialise final_val.
	* subsegs.c (subsegs_print_statistics): Cast frchp to void *.
@
text
@d3 1
a3 1
   1999, 2000
d529 1
a529 5
  if (! EMIT_SECTION_SYMBOLS
#ifdef BFD_ASSEMBLER
      || symbol_table_frozen
#endif
      )
d554 2
@


1.10
log
@	* subsegs.c (subseg_text_p): Return 0 for absolute section.
	* read.c (do_align): If in absolute section, warn about and ignore
	non-zero fill pattern.
@
text
@d655 1
a655 1
      fprintf (file, "\t%p %-10s\t%10d frags\n", frchp,
@


1.9
log
@	* read.c: Standardize error/warning messages - don't capitalise, no
	final period or newline, don't say "ignored" or "zero assumed" for
	as_bad messages.  In some cases, change the wording to that used
	elsewhere for similar messages.
	* app.c, as.c, atof-generic.c, cgen.c, cond.c, depend.c, dwarf2dbg.c,
	  ecoff.c, expr.c, frags.c, input-file.c, input-scrub.c, listing.c,
	  output-file.c, stabs.c, subsegs.c, symbols.c, write.c: Likewise.
	* ecoff.c (ecoff_directive_end): Test for missing name by
	comparing input line pointers rather than reading string.
	(ecoff_directive_ent): Likewise.
	* read.c (s_set): Likewise.
	(s_align): Report a warning rather than an error for
	alignment too large.
	(s_comm): Check for missing symbol name.
	(s_lcomm_internal): Likewise.
	(s_lsym): Likewise.
	(s_globl): Use is_end_of_line instead of looking for '\n'.
	(s_lcomm_internal): Likewise.
	(ignore_rest_of_line): Report a warning rather than an error.
@
text
@d590 1
a590 1
  if (sec == data_section || sec == bss_section)
@


1.8
log
@Fix copyright notices
@
text
@d377 1
a377 1
  as_bad (_("Attempt to switch to nonexistent segment \"%s\""), segname);
@


1.7
log
@2000-11-06  Kazu Hirata  <kazu@@hxi.com>

	* as.c: Fix formatting.
	* dwarf2dbg.c: Likewise.
	* itbl-ops.c: Likewise.
	* listing.c: Likewise.
	* macro.h: Likewise.
	* messages.c: Likewise.
	* read.c: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* write.c: Likewise.
@
text
@d2 2
a3 1
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
@


1.7.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000
@


1.6
log
@2000-09-11  Kazu Hirata  <kazu@@hxi.com>

	* bignum-copy.c: Fix formatting.
	* ehopt.c: Likewise.
	* flonum-copy.c: Likewise.
	* flonum-konst.c: Likewise.
	* flonum-mult.c: Likewise.
	* literal.c: Likewise.
	* read.c: Likewise.
	* sb.c: Likewise.
	* stabs.c: Likewise.
	* subsegs.c: Likewise.
@
text
@d22 1
a22 3
/*
 * Segments & sub-segments.
 */
d42 1
a42 2
char const *const seg_name[] =
{
d567 1
a567 2
const char * const nontext_section_names[] =
{
@


1.5
log
@1999-06-27  H.J. Lu  <hjl@@gnu.org>
	* subsegs.c (subseg_text_p): Use 1/0 instead of true/false for
	non BFD_ASSEMBLER case.
@
text
@d2 1
a2 1
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 97, 98, 1999
d40 1
a40 1
/* Commented in "subsegs.h". */
d65 1
a65 1
};				/* Used by error reporters, dumpers etc. */
d106 1
a106 1
  frchain_now = NULL;		/* Warn new_subseg() that we are booting. */
d111 1
a111 1
  now_subseg = 42;		/* Lie for 1st call to subseg_new. */
d278 1
a278 1
	  || frcP->frch_subseg > subseg))	/* Kinky logic only works with 2 segments. */
d310 1
a310 1
      
@


1.4
log
@	* subsegs.c (subseg_text_p): Rewrite non BFD_ASSEMBLER case to use
	a list of names, to try obj_segment_name, and to try abbreviated
	names when using COFF without long section names.
@
text
@d594 1
a594 1
    return false;
d599 1
a599 1
	return false;
d603 1
a603 1
	return false;
d607 1
a607 1
  return true;
@


1.3
log
@	* subsegs.c (subseg_text_p): New function.
	* as.h (subseg_text_p): Declare.
	* read.c (do_align): Use subseg_text_p to set the default fill.
	* write.c (subsegs_finish): Likewise.
	* config/obj-coff.c (write_object_file): Likewise.
	* config/tc-i386.h (md_maybe_text): Don't define.
	(md_do_align): Use subseg_text_p to set the default fill.
	* config/tc-m32r.c (m32r_do_align): Likewise.
	* config/tc-sh.c (sh_do_align): Likewise.
	* config/tc-sparc.h (md_do_align): Likewise.
@
text
@d569 15
d590 14
a603 4
#else
  return (sec != data_section
	  && sec != bss_section
	  && strcmp (segment_name (sec), ".eh_frame") != 0);
d605 5
@


1.2
log
@	Add support for storing local symbols in a small structure to save
	memory when assembling large files.
	* as.h: Don't include struc-symbol.h.
	(symbolS): Add typedef.
	* symbols.c: Include struc-symbol.h.
	(local_hash): New static variable.
	(save_symbol_name): New static function, from symbol_create.
	(symbol_create): Call save_symbol_name.
	(local_symbol_count): New static variable.
	(local_symbol_conversion_count): Likewise.
	(LOCAL_SYMBOL_CHECK): Define.
	(local_symbol_make): New static function.
	(local_symbol_convert): New static function.
	(colon): Handle local symbols.  Create local symbol for local
	label name.
	(symbol_table_insert): Handle local symbols.
	(symbol_find_or_make): Create local symbol for local label name.
	(symbol_find_base): Check for local symbol.
	(symbol_append, symbol_insert): Check for local symbols.
	(symbol_clear_list_pointers, symbol_remove): Likewise.
	(verify_symbol_chain): Likewise.
	(copy_symbol_attributes): Likewise.
	(resolve_symbol_value): Handle local symbols.
	(resolve_local_symbol): New static function.
	(resolve_local_symbol_values): New function.
	(S_GET_VALUE, S_SET_VALUE): Handle local symbols.
	(S_IS_FUNCTION, S_IS_EXTERNAL, S_IS_WEAK, S_IS_COMMON): Likewise.
	(S_IS_DEFINED, S_IS_DEBUG, S_IS_LOCAL, S_GET_NAME): Likewise.
	(S_GET_SEGMENT, S_SET_SEGMENT, S_SET_EXTERNAL): Likewise.
	(S_CLEAR_EXTERNAL, S_SET_WEAK, S_SET_NAME): Likewise.
	(symbol_previous, symbol_next): New functions.
	(symbol_get_value_expression): Likewise.
	(symbol_set_value_expression): Likewise.
	(symbol_set_frag, symbol_get_frag): Likewise.
	(symbol_mark_used, symbol_clear_used, symbol_used_p): Likewise.
	(symbol_mark_used_in_reloc): Likewise.
	(symbol_clear_used_in_reloc, symbol_used_in_reloc_p): Likewise.
	(symbol_mark_mri_common, symbol_clear_mri_common): Likewise.
	(symbol_mri_common_p): Likewise.
	(symbol_mark_written, symbol_clear_written): Likewise.
	(symbol_written_p): Likewise.
	(symbol_mark_resolved, symbol_resolved_p): Likewise.
	(symbol_section_p, symbol_equated_p): Likewise.
	(symbol_constant_p): Likewise.
	(symbol_get_bfdsym, symbol_set_bfdsym): Likewise.
	(symbol_get_obj, symbol_set_obj): Likewise.
	(symbol_get_tc, symbol_set_tc): Likewise.
	(symbol_begin): Initialize local_hash.
	(print_symbol_value_1): Handle local symbols.
	(symbol_print_statistics): Print local symbol statistics.
	* symbols.h: Include "struc-symbol.h" if not BFD_ASSEMBLER.
	Declare new symbols.c functions.  Move many declarations here from
	struc-symbol.h.
	(SYMBOLS_NEED_BACKPOINTERS): Define if needed.
	* struc-symbol.h (SYMBOLS_NEED_BACKPOINTERS): Don't set.
	(struct symbol): Move bsym to make it clearly the first field.
	Remove TARGET_SYMBOL_FIELDS.
	(symbolS): Don't typedef.
	(struct broken_word): Remove.
	(N_TYPE_seg, seg_N_TYPE): Move to symbol.h.
	(SEGMENT_TO_SYMBOL_TYPE, N_REGISTER): Likewise.
	(symbol_clear_list_pointers): Likewise.
	(symbol_insert, symbol_remove): Likewise.
	(symbol_previous, symbol_append): Likewise.
	(verify_symbol_chain, verify_symbol_chain_2): Likewise.
	(struct local_symbol): Define.
	(local_symbol_converted_p, local_symbol_mark_converted): Define.
	(local_symbol_resolved_p, local_symbol_mark_resolved): Define.
	(local_symbol_get_frag, local_symbol_set_frag): Define.
	(local_symbol_get_real_symbol): Define.
	(local_symbol_set_real_symbol): Define.
	Define.
	* write.c (write_object_file): Call resolve_local_symbol_values.
	* config/obj-ecoff.h (OBJ_SYMFIELD_TYPE): Define.
	(TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-elf.h (OBJ_SYMFIELD_TYPE): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-multi.h (struct elf_obj_sy): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	(ECOFF_DEBUG_TARGET_SYMBOL_FIELDS): Don't define.
	* config/tc-mcore.h: Don't include struc-symbol.h.
	(TARGET_SYMBOL_FIELDS): Don't define.
	(struct mcore_tc_sy): Define.
	(TC_SYMFIELD_TYPE): Define.
	* Many files: Use symbolS instead of struct symbol.  Use new
	accessor functions rather than referring to symbolS fields
	directly.
	* read.c (s_mri_common): Don't add in value of line_label.
	* config/tc-mips.c (md_apply_fix): Correct parenthesization when
	checking for SEC_LINK_ONCE.
	* config/tc-sh.h (sh_fix_adjustable): Declare.
@
text
@d567 15
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 1997
d550 1
a550 1
	      s->sy_frag = &zero_address_frag;
d559 1
a559 1
    s->bsym = sec->symbol;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

