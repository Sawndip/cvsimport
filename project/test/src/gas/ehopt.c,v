head	1.22;
access;
symbols
	binutils-2_24-branch:1.22.0.8
	binutils-2_24-branchpoint:1.22
	binutils-2_21_1:1.21
	binutils-2_23_2:1.22
	binutils-2_23_1:1.22
	binutils-2_23:1.22
	binutils-2_23-branch:1.22.0.6
	binutils-2_23-branchpoint:1.22
	binutils-2_22_branch:1.22.0.4
	binutils-2_22:1.22
	binutils-2_22-branch:1.22.0.2
	binutils-2_22-branchpoint:1.22
	binutils-2_21:1.21
	binutils-2_21-branch:1.21.0.2
	binutils-2_21-branchpoint:1.21
	binutils-2_20_1:1.20.2.1
	binutils-2_20:1.20.2.1
	binutils-arc-20081103-branch:1.16.0.6
	binutils-arc-20081103-branchpoint:1.16
	binutils-2_20-branch:1.20.0.2
	binutils-2_20-branchpoint:1.20
	dje-cgen-play1-branch:1.18.0.2
	dje-cgen-play1-branchpoint:1.18
	arc-20081103-branch:1.16.0.4
	arc-20081103-branchpoint:1.16
	binutils-2_19_1:1.16.2.1
	binutils-2_19:1.16
	binutils-2_19-branch:1.16.0.2
	binutils-2_19-branchpoint:1.16
	binutils-2_18:1.15
	binutils-2_18-branch:1.15.0.2
	binutils-2_18-branchpoint:1.15
	binutils-csl-coldfire-4_1-32:1.14
	binutils-csl-sourcerygxx-4_1-32:1.14
	binutils-csl-innovasic-fido-3_4_4-33:1.14
	binutils-csl-sourcerygxx-3_4_4-32:1.12
	binutils-csl-coldfire-4_1-30:1.14
	binutils-csl-sourcerygxx-4_1-30:1.14
	binutils-csl-coldfire-4_1-28:1.14
	binutils-csl-sourcerygxx-4_1-29:1.14
	binutils-csl-sourcerygxx-4_1-28:1.14
	binutils-csl-arm-2006q3-27:1.14
	binutils-csl-sourcerygxx-4_1-27:1.14
	binutils-csl-arm-2006q3-26:1.14
	binutils-csl-sourcerygxx-4_1-26:1.14
	binutils-csl-sourcerygxx-4_1-25:1.14
	binutils-csl-sourcerygxx-4_1-24:1.14
	binutils-csl-sourcerygxx-4_1-23:1.14
	binutils-csl-sourcerygxx-4_1-21:1.14
	binutils-csl-arm-2006q3-21:1.14
	binutils-csl-sourcerygxx-4_1-22:1.14
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.14
	binutils-csl-sourcerygxx-4_1-20:1.14
	binutils-csl-arm-2006q3-19:1.14
	binutils-csl-sourcerygxx-4_1-19:1.14
	binutils-csl-sourcerygxx-4_1-18:1.14
	binutils-csl-renesas-4_1-9:1.14
	binutils-csl-sourcerygxx-3_4_4-25:1.12
	binutils-csl-renesas-4_1-8:1.14
	binutils-csl-renesas-4_1-7:1.14
	binutils-csl-renesas-4_1-6:1.14
	binutils-csl-sourcerygxx-4_1-17:1.14
	binutils-csl-sourcerygxx-4_1-14:1.14
	binutils-csl-sourcerygxx-4_1-15:1.14
	binutils-csl-sourcerygxx-4_1-13:1.14
	binutils-2_17:1.14
	binutils-csl-sourcerygxx-4_1-12:1.14
	binutils-csl-sourcerygxx-3_4_4-21:1.14
	binutils-csl-wrs-linux-3_4_4-24:1.12
	binutils-csl-wrs-linux-3_4_4-23:1.12
	binutils-csl-sourcerygxx-4_1-9:1.14
	binutils-csl-sourcerygxx-4_1-8:1.14
	binutils-csl-sourcerygxx-4_1-7:1.14
	binutils-csl-arm-2006q1-6:1.14
	binutils-csl-sourcerygxx-4_1-6:1.14
	binutils-csl-wrs-linux-3_4_4-22:1.12
	binutils-csl-coldfire-4_1-11:1.14
	binutils-csl-sourcerygxx-3_4_4-19:1.14
	binutils-csl-coldfire-4_1-10:1.14
	binutils-csl-sourcerygxx-4_1-5:1.14
	binutils-csl-sourcerygxx-4_1-4:1.14
	binutils-csl-wrs-linux-3_4_4-21:1.12
	binutils-csl-morpho-4_1-4:1.14
	binutils-csl-sourcerygxx-3_4_4-17:1.14
	binutils-csl-wrs-linux-3_4_4-20:1.12
	binutils-2_17-branch:1.14.0.4
	binutils-2_17-branchpoint:1.14
	binutils-csl-2_17-branch:1.14.0.2
	binutils-csl-2_17-branchpoint:1.14
	binutils-csl-gxxpro-3_4-branch:1.12.0.12
	binutils-csl-gxxpro-3_4-branchpoint:1.12
	binutils-2_16_1:1.12
	binutils-csl-arm-2005q1b:1.12
	binutils-2_16:1.12
	binutils-csl-arm-2005q1a:1.12
	binutils-csl-arm-2005q1-branch:1.12.0.10
	binutils-csl-arm-2005q1-branchpoint:1.12
	binutils-2_16-branch:1.12.0.8
	binutils-2_16-branchpoint:1.12
	csl-arm-2004-q3d:1.12
	csl-arm-2004-q3:1.12
	binutils-2_15:1.12
	binutils-2_15-branchpoint:1.12
	csl-arm-2004-q1a:1.12
	csl-arm-2004-q1:1.12
	binutils-2_15-branch:1.12.0.6
	cagney_bfdfile-20040213-branch:1.12.0.4
	cagney_bfdfile-20040213-branchpoint:1.12
	cagney_bigcore-20040122-branch:1.12.0.2
	cagney_bigcore-20040122-branchpoint:1.12
	csl-arm-2003-q4:1.12
	binutils-2_14:1.11
	binutils-2_14-branch:1.11.0.2
	binutils-2_14-branchpoint:1.11
	binutils-2_13_2_1:1.10
	binutils-2_13_2:1.10
	binutils-2_13_1:1.10
	binutils-2_13:1.10
	binutils-2_13-branchpoint:1.10
	binutils-2_13-branch:1.10.0.2
	binutils-2_12_1:1.9
	binutils-2_12:1.9
	binutils-2_12-branch:1.9.0.2
	binutils-2_12-branchpoint:1.9
	cygnus_cvs_20020108_pre:1.9
	binutils-2_11_2:1.4.2.3
	binutils-2_11_1:1.4.2.3
	binutils-2_11:1.4
	x86_64versiong3:1.4
	binutils-2_11-branch:1.4.0.2
	binutils-2_10_1:1.1.1.1
	binutils-2_10:1.1.1.1
	binutils-2_10-branch:1.1.1.1.0.2
	binutils-2_10-branchpoint:1.1.1.1
	binutils_latest_snapshot:1.22
	repo-unification-2000-02-06:1.1.1.1
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2011.04.26.15.28.07;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2009.09.11.15.27.33;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	2009.09.02.07.24.19;	author amodra;	state Exp;
branches
	1.20.2.1;
next	1.19;

1.19
date	2009.07.10.15.26.58;	author tromey;	state Exp;
branches;
next	1.18;

1.18
date	2009.06.22.17.56.00;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2008.11.28.21.28.28;	author jakub;	state Exp;
branches;
next	1.16;

1.16
date	2007.11.06.17.15.10;	author nickc;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2007.07.03.11.01.03;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2005.08.11.01.25.20;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.05.09.12.44;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2003.11.22.16.03.03;	author kazu;	state Exp;
branches;
next	1.11;

1.11
date	2003.04.18.11.53.12;	author jakub;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.18.12.53.30;	author kazu;	state Exp;
branches;
next	1.9;

1.9
date	2001.05.22.10.23.48;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.15.06.10.43;	author rth;	state Exp;
branches;
next	1.7;

1.7
date	2001.05.14.22.37.47;	author rth;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.30.07.07.09;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.08.23.24.22;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2001.01.23.22.15.01;	author kazu;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2000.11.18.00.13.28;	author rth;	state Exp;
branches;
next	1.2;

1.2
date	2000.09.12.03.56.22;	author kazu;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.40;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.20.2.1
date	2009.09.11.15.28.43;	author nickc;	state Exp;
branches;
next	;

1.16.2.1
date	2009.01.14.09.00.25;	author gingold;	state Exp;
branches;
next	;

1.4.2.1
date	2001.05.14.22.59.12;	author rth;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2001.05.15.06.10.28;	author rth;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2001.06.07.03.15.24;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.40;	author rth;	state Exp;
branches;
next	;


desc
@@


1.22
log
@	* dw2gencfi.c (dwcfi_seg_list): New struct.
	(dwcfi_hash): New static hash variable.
	(get_debugseg_name): New.
	(alloc_debugseg_item): New.
	(make_debug_seg): New.
	(dwcfi_hash_insert): New.
	(dwcfi_hash_find): New.
	(dwcfi_hash_find_or_make): New.
	(cfi_insn_data): New member cur_seg.
	(cie_entry): Likewise.
	(fde_entry): New cseg and handled members.
	(alloc_fde_entry): Initialize cseg member.
	(alloc_cfi_insn_data): Initialize cur_seg member.
	(dot_cfi_sections): Compare for beginning of
	section names via strncmp.
	(get_cfi_seg): New.
	(cfi_finish): Treat link-once sections.
	(is_now_linkonce_segment): New local helper.
	(output_cie): Ignore cie entries not member of current
	segment.
	(output_fde): Likewise.
	(select_cie_for_fde): Likewise.
	(cfi_change_reg_numbers): Add new argument for current segment
	and ignore insn elements, if not part of current segment.
	* ehopt.c (get_cie_info): Use strncmp for
	section name matching.
	(heck_eh_frame): Likewise.

	* coffcode.h (sec_to_styp_flags): Allow linkonce for
	debugging sections.

	* scripttempl/pe.sc: Handle .eh_frame($|.)* sections.
	* scripttempl/pep.sc: Likewise.

	* ld-pe/pe.exp: Add cfi/cfi32 tests.
	* ld-pe/cfi.d: New.
	* ld-pe/cfi32.d: New.
	* ld-pe/cfia.s: New.
	* ld-pe/cfib.s: New.
@
text
@/* ehopt.c--optimize gcc exception frame information.
   Copyright 1998, 2000, 2001, 2003, 2005, 2007, 2008, 2009
   Free Software Foundation, Inc.
   Written by Ian Lance Taylor <ian@@cygnus.com>.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include "as.h"
#include "subsegs.h"
#include "struc-symbol.h"

/* We include this ELF file, even though we may not be assembling for
   ELF, since the exception frame information is always in a format
   derived from DWARF.  */

#include "dwarf2.h"

/* Try to optimize gcc 2.8 exception frame information.

   Exception frame information is emitted for every function in the
   .eh_frame or .debug_frame sections.  Simple information for a function
   with no exceptions looks like this:

__FRAME_BEGIN__:
	.4byte	.LLCIE1	/ Length of Common Information Entry
.LSCIE1:
#if .eh_frame
	.4byte	0x0	/ CIE Identifier Tag
#elif .debug_frame
	.4byte	0xffffffff / CIE Identifier Tag
#endif
	.byte	0x1	/ CIE Version
	.byte	0x0	/ CIE Augmentation (none)
	.byte	0x1	/ ULEB128 0x1 (CIE Code Alignment Factor)
	.byte	0x7c	/ SLEB128 -4 (CIE Data Alignment Factor)
	.byte	0x8	/ CIE RA Column
	.byte	0xc	/ DW_CFA_def_cfa
	.byte	0x4	/ ULEB128 0x4
	.byte	0x4	/ ULEB128 0x4
	.byte	0x88	/ DW_CFA_offset, column 0x8
	.byte	0x1	/ ULEB128 0x1
	.align 4
.LECIE1:
	.set	.LLCIE1,.LECIE1-.LSCIE1	/ CIE Length Symbol
	.4byte	.LLFDE1	/ FDE Length
.LSFDE1:
	.4byte	.LSFDE1-__FRAME_BEGIN__	/ FDE CIE offset
	.4byte	.LFB1	/ FDE initial location
	.4byte	.LFE1-.LFB1	/ FDE address range
	.byte	0x4	/ DW_CFA_advance_loc4
	.4byte	.LCFI0-.LFB1
	.byte	0xe	/ DW_CFA_def_cfa_offset
	.byte	0x8	/ ULEB128 0x8
	.byte	0x85	/ DW_CFA_offset, column 0x5
	.byte	0x2	/ ULEB128 0x2
	.byte	0x4	/ DW_CFA_advance_loc4
	.4byte	.LCFI1-.LCFI0
	.byte	0xd	/ DW_CFA_def_cfa_register
	.byte	0x5	/ ULEB128 0x5
	.byte	0x4	/ DW_CFA_advance_loc4
	.4byte	.LCFI2-.LCFI1
	.byte	0x2e	/ DW_CFA_GNU_args_size
	.byte	0x4	/ ULEB128 0x4
	.byte	0x4	/ DW_CFA_advance_loc4
	.4byte	.LCFI3-.LCFI2
	.byte	0x2e	/ DW_CFA_GNU_args_size
	.byte	0x0	/ ULEB128 0x0
	.align 4
.LEFDE1:
	.set	.LLFDE1,.LEFDE1-.LSFDE1	/ FDE Length Symbol

   The immediate issue we can address in the assembler is the
   DW_CFA_advance_loc4 followed by a four byte value.  The value is
   the difference of two addresses in the function.  Since gcc does
   not know this value, it always uses four bytes.  We will know the
   value at the end of assembly, so we can do better.  */

struct cie_info
{
  unsigned code_alignment;
  int z_augmentation;
};

static int get_cie_info (struct cie_info *);

/* Extract information from the CIE.  */

static int
get_cie_info (struct cie_info *info)
{
  fragS *f;
  fixS *fix;
  int offset;
  char CIE_id;
  char augmentation[10];
  int iaug;
  int code_alignment = 0;

  /* We should find the CIE at the start of the section.  */

  f = seg_info (now_seg)->frchainP->frch_root;
  fix = seg_info (now_seg)->frchainP->fix_root;

  /* Look through the frags of the section to find the code alignment.  */

  /* First make sure that the CIE Identifier Tag is 0/-1.  */

  if (strncmp (segment_name (now_seg), ".debug_frame", 12) == 0)
    CIE_id = (char)0xff;
  else
    CIE_id = 0;

  offset = 4;
  while (f != NULL && offset >= f->fr_fix)
    {
      offset -= f->fr_fix;
      f = f->fr_next;
    }
  if (f == NULL
      || f->fr_fix - offset < 4
      || f->fr_literal[offset] != CIE_id
      || f->fr_literal[offset + 1] != CIE_id
      || f->fr_literal[offset + 2] != CIE_id
      || f->fr_literal[offset + 3] != CIE_id)
    return 0;

  /* Next make sure the CIE version number is 1.  */

  offset += 4;
  while (f != NULL && offset >= f->fr_fix)
    {
      offset -= f->fr_fix;
      f = f->fr_next;
    }
  if (f == NULL
      || f->fr_fix - offset < 1
      || f->fr_literal[offset] != 1)
    return 0;

  /* Skip the augmentation (a null terminated string).  */

  iaug = 0;
  ++offset;
  while (1)
    {
      while (f != NULL && offset >= f->fr_fix)
	{
	  offset -= f->fr_fix;
	  f = f->fr_next;
	}
      if (f == NULL)
	return 0;

      while (offset < f->fr_fix && f->fr_literal[offset] != '\0')
	{
	  if ((size_t) iaug < (sizeof augmentation) - 1)
	    {
	      augmentation[iaug] = f->fr_literal[offset];
	      ++iaug;
	    }
	  ++offset;
	}
      if (offset < f->fr_fix)
	break;
    }
  ++offset;
  while (f != NULL && offset >= f->fr_fix)
    {
      offset -= f->fr_fix;
      f = f->fr_next;
    }
  if (f == NULL)
    return 0;

  augmentation[iaug] = '\0';
  if (augmentation[0] == '\0')
    {
      /* No augmentation.  */
    }
  else if (strcmp (augmentation, "eh") == 0)
    {
      /* We have to skip a pointer.  Unfortunately, we don't know how
	 large it is.  We find out by looking for a matching fixup.  */
      while (fix != NULL
	     && (fix->fx_frag != f || fix->fx_where != offset))
	fix = fix->fx_next;
      if (fix == NULL)
	offset += 4;
      else
	offset += fix->fx_size;
      while (f != NULL && offset >= f->fr_fix)
	{
	  offset -= f->fr_fix;
	  f = f->fr_next;
	}
      if (f == NULL)
	return 0;
    }
  else if (augmentation[0] != 'z')
    return 0;

  /* We're now at the code alignment factor, which is a ULEB128.  If
     it isn't a single byte, forget it.  */

  code_alignment = f->fr_literal[offset] & 0xff;
  if ((code_alignment & 0x80) != 0)
    code_alignment = 0;

  info->code_alignment = code_alignment;
  info->z_augmentation = (augmentation[0] == 'z');

  return 1;
}

enum frame_state
{
  state_idle,
  state_saw_size,
  state_saw_cie_offset,
  state_saw_pc_begin,
  state_seeing_aug_size,
  state_skipping_aug,
  state_wait_loc4,
  state_saw_loc4,
  state_error,
};

/* This function is called from emit_expr.  It looks for cases which
   we can optimize.

   Rather than try to parse all this information as we read it, we
   look for a single byte DW_CFA_advance_loc4 followed by a 4 byte
   difference.  We turn that into a rs_cfa_advance frag, and handle
   those frags at the end of the assembly.  If the gcc output changes
   somewhat, this optimization may stop working.

   This function returns non-zero if it handled the expression and
   emit_expr should not do anything, or zero otherwise.  It can also
   change *EXP and *PNBYTES.  */

int
check_eh_frame (expressionS *exp, unsigned int *pnbytes)
{
  struct frame_data
  {
    enum frame_state state;

    int cie_info_ok;
    struct cie_info cie_info;

    symbolS *size_end_sym;
    fragS *loc4_frag;
    int loc4_fix;

    int aug_size;
    int aug_shift;
  };

  static struct frame_data eh_frame_data;
  static struct frame_data debug_frame_data;
  struct frame_data *d;

  /* Don't optimize.  */
  if (flag_traditional_format)
    return 0;

#ifdef md_allow_eh_opt
  if (! md_allow_eh_opt)
    return 0;
#endif

  /* Select the proper section data.  */
  if (strncmp (segment_name (now_seg), ".eh_frame", 9) == 0
      && segment_name (now_seg)[9] != '_')
    d = &eh_frame_data;
  else if (strncmp (segment_name (now_seg), ".debug_frame", 12) == 0)
    d = &debug_frame_data;
  else
    return 0;

  if (d->state >= state_saw_size && S_IS_DEFINED (d->size_end_sym))
    {
      /* We have come to the end of the CIE or FDE.  See below where
         we set saw_size.  We must check this first because we may now
         be looking at the next size.  */
      d->state = state_idle;
    }

  switch (d->state)
    {
    case state_idle:
      if (*pnbytes == 4)
	{
	  /* This might be the size of the CIE or FDE.  We want to know
	     the size so that we don't accidentally optimize across an FDE
	     boundary.  We recognize the size in one of two forms: a
	     symbol which will later be defined as a difference, or a
	     subtraction of two symbols.  Either way, we can tell when we
	     are at the end of the FDE because the symbol becomes defined
	     (in the case of a subtraction, the end symbol, from which the
	     start symbol is being subtracted).  Other ways of describing
	     the size will not be optimized.  */
	  if ((exp->X_op == O_symbol || exp->X_op == O_subtract)
	      && ! S_IS_DEFINED (exp->X_add_symbol))
	    {
	      d->state = state_saw_size;
	      d->size_end_sym = exp->X_add_symbol;
	    }
	}
      break;

    case state_saw_size:
    case state_saw_cie_offset:
      /* Assume whatever form it appears in, it appears atomically.  */
      d->state = (enum frame_state) (d->state + 1);
      break;

    case state_saw_pc_begin:
      /* Decide whether we should see an augmentation.  */
      if (! d->cie_info_ok
	  && ! (d->cie_info_ok = get_cie_info (&d->cie_info)))
	d->state = state_error;
      else if (d->cie_info.z_augmentation)
	{
	  d->state = state_seeing_aug_size;
	  d->aug_size = 0;
	  d->aug_shift = 0;
	}
      else
	d->state = state_wait_loc4;
      break;

    case state_seeing_aug_size:
      /* Bytes == -1 means this comes from an leb128 directive.  */
      if ((int)*pnbytes == -1 && exp->X_op == O_constant)
	{
	  d->aug_size = exp->X_add_number;
	  d->state = state_skipping_aug;
	}
      else if (*pnbytes == 1 && exp->X_op == O_constant)
	{
	  unsigned char byte = exp->X_add_number;
	  d->aug_size |= (byte & 0x7f) << d->aug_shift;
	  d->aug_shift += 7;
	  if ((byte & 0x80) == 0)
	    d->state = state_skipping_aug;
	}
      else
	d->state = state_error;
      if (d->state == state_skipping_aug && d->aug_size == 0)
	d->state = state_wait_loc4;
      break;

    case state_skipping_aug:
      if ((int)*pnbytes < 0)
	d->state = state_error;
      else
	{
	  int left = (d->aug_size -= *pnbytes);
	  if (left == 0)
	    d->state = state_wait_loc4;
	  else if (left < 0)
	    d->state = state_error;
	}
      break;

    case state_wait_loc4:
      if (*pnbytes == 1
	  && exp->X_op == O_constant
	  && exp->X_add_number == DW_CFA_advance_loc4)
	{
	  /* This might be a DW_CFA_advance_loc4.  Record the frag and the
	     position within the frag, so that we can change it later.  */
	  frag_grow (1);
	  d->state = state_saw_loc4;
	  d->loc4_frag = frag_now;
	  d->loc4_fix = frag_now_fix ();
	}
      break;

    case state_saw_loc4:
      d->state = state_wait_loc4;
      if (*pnbytes != 4)
	break;
      if (exp->X_op == O_constant)
	{
	  /* This is a case which we can optimize.  The two symbols being
	     subtracted were in the same frag and the expression was
	     reduced to a constant.  We can do the optimization entirely
	     in this function.  */
	  if (exp->X_add_number < 0x40)
	    {
	      d->loc4_frag->fr_literal[d->loc4_fix]
		= DW_CFA_advance_loc | exp->X_add_number;
	      /* No more bytes needed.  */
	      return 1;
	    }
	  else if (exp->X_add_number < 0x100)
	    {
	      d->loc4_frag->fr_literal[d->loc4_fix] = DW_CFA_advance_loc1;
	      *pnbytes = 1;
	    }
	  else if (exp->X_add_number < 0x10000)
	    {
	      d->loc4_frag->fr_literal[d->loc4_fix] = DW_CFA_advance_loc2;
	      *pnbytes = 2;
	    }
	}
      else if (exp->X_op == O_subtract && d->cie_info.code_alignment == 1)
	{
	  /* This is a case we can optimize.  The expression was not
	     reduced, so we can not finish the optimization until the end
	     of the assembly.  We set up a variant frag which we handle
	     later.  */
	  frag_var (rs_cfa, 4, 0, 1 << 3, make_expr_symbol (exp),
		    d->loc4_fix, (char *) d->loc4_frag);
	  return 1;
	}
      else if ((exp->X_op == O_divide
		|| exp->X_op == O_right_shift)
	       && d->cie_info.code_alignment > 1)
	{
	  if (exp->X_add_symbol->bsym
	      && exp->X_op_symbol->bsym
	      && exp->X_add_symbol->sy_value.X_op == O_subtract
	      && exp->X_op_symbol->sy_value.X_op == O_constant
	      && ((exp->X_op == O_divide
		   ? exp->X_op_symbol->sy_value.X_add_number
		   : (offsetT) 1 << exp->X_op_symbol->sy_value.X_add_number)
		  == (offsetT) d->cie_info.code_alignment))
	    {
	      /* This is a case we can optimize as well.  The expression was
		 not reduced, so we can not finish the optimization until the
		 end of the assembly.  We set up a variant frag which we
		 handle later.  */
	      frag_var (rs_cfa, 4, 0, d->cie_info.code_alignment << 3,
			make_expr_symbol (&exp->X_add_symbol->sy_value),
			d->loc4_fix, (char *) d->loc4_frag);
	      return 1;
	    }
	}
      break;

    case state_error:
      /* Just skipping everything.  */
      break;
    }

  return 0;
}

/* The function estimates the size of a rs_cfa variant frag based on
   the current values of the symbols.  It is called before the
   relaxation loop.  We set fr_subtype{0:2} to the expected length.  */

int
eh_frame_estimate_size_before_relax (fragS *frag)
{
  offsetT diff;
  int ca = frag->fr_subtype >> 3;
  int ret;

  diff = resolve_symbol_value (frag->fr_symbol);

  gas_assert (ca > 0);
  diff /= ca;
  if (diff < 0x40)
    ret = 0;
  else if (diff < 0x100)
    ret = 1;
  else if (diff < 0x10000)
    ret = 2;
  else
    ret = 4;

  frag->fr_subtype = (frag->fr_subtype & ~7) | ret;

  return ret;
}

/* This function relaxes a rs_cfa variant frag based on the current
   values of the symbols.  fr_subtype{0:2} is the current length of
   the frag.  This returns the change in frag length.  */

int
eh_frame_relax_frag (fragS *frag)
{
  int oldsize, newsize;

  oldsize = frag->fr_subtype & 7;
  newsize = eh_frame_estimate_size_before_relax (frag);
  return newsize - oldsize;
}

/* This function converts a rs_cfa variant frag into a normal fill
   frag.  This is called after all relaxation has been done.
   fr_subtype{0:2} will be the desired length of the frag.  */

void
eh_frame_convert_frag (fragS *frag)
{
  offsetT diff;
  fragS *loc4_frag;
  int loc4_fix, ca;

  loc4_frag = (fragS *) frag->fr_opcode;
  loc4_fix = (int) frag->fr_offset;

  diff = resolve_symbol_value (frag->fr_symbol);

  ca = frag->fr_subtype >> 3;
  gas_assert (ca > 0);
  diff /= ca;
  switch (frag->fr_subtype & 7)
    {
    case 0:
      gas_assert (diff < 0x40);
      loc4_frag->fr_literal[loc4_fix] = DW_CFA_advance_loc | diff;
      break;

    case 1:
      gas_assert (diff < 0x100);
      loc4_frag->fr_literal[loc4_fix] = DW_CFA_advance_loc1;
      frag->fr_literal[frag->fr_fix] = diff;
      break;

    case 2:
      gas_assert (diff < 0x10000);
      loc4_frag->fr_literal[loc4_fix] = DW_CFA_advance_loc2;
      md_number_to_chars (frag->fr_literal + frag->fr_fix, diff, 2);
      break;

    default:
      md_number_to_chars (frag->fr_literal + frag->fr_fix, diff, 4);
      break;
    }

  frag->fr_fix += frag->fr_subtype & 7;
  frag->fr_type = rs_fill;
  frag->fr_subtype = 0;
  frag->fr_offset = 0;
}
@


1.21
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        * as.c (main): Call dwarf2_init.
        * config/obj-elf.c (struct group_list): New field.
        (build_group_lists): Use hash lookup.
        (free_section_idx): New function.
        (elf_frob_file): Adjust.
        * dwarf2dbg.c (all_segs_hash, last_seg_ptr): New variables.
        (get_line_subseg): Adjust.
        (dwarf2_init): New function.
        * dwarf2dbg.h (dwarf2_init): New declaration.
@
text
@d123 1
a123 1
  if (strcmp (segment_name (now_seg), ".debug_frame") == 0)
d288 2
a289 1
  if (strcmp (segment_name (now_seg), ".eh_frame") == 0)
d291 1
a291 1
  else if (strcmp (segment_name (now_seg), ".debug_frame") == 0)
@


1.20
log
@update copyright dates
@
text
@d230 13
d261 1
a261 12
    enum frame_state
    {
      state_idle,
      state_saw_size,
      state_saw_cie_offset,
      state_saw_pc_begin,
      state_seeing_aug_size,
      state_skipping_aug,
      state_wait_loc4,
      state_saw_loc4,
      state_error,
    } state;
d329 1
a329 1
      d->state += 1;
@


1.20.2.1
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.
@
text
@a229 13
enum frame_state
{
  state_idle,
  state_saw_size,
  state_saw_cie_offset,
  state_saw_pc_begin,
  state_seeing_aug_size,
  state_skipping_aug,
  state_wait_loc4,
  state_saw_loc4,
  state_error,
};

d248 12
a259 1
    enum frame_state state;
d327 1
a327 1
      d->state = (enum frame_state) (d->state + 1);
@


1.19
log
@bfd
	* Makefile.am (dwarf2.lo): Use dwarf2.h, not elf/dwarf2.h.
	(elf-eh-frame.lo): Likewise.
	(elf32-bfin.lo): Likewise.
	(elf32-frv.lo): Likewise.
	(elf32-xc16x.lo): Likewise.
	* Makefile.in: Rebuild.
	* dwarf2.c: Included dwarf.h, not elf/dwarf2.h.
	* elf-eh-frame.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-xc16x.c: Likewise.
binutils
	* Makefile.am (dwarf.o): Refer to dwarf2.h, not elf/dwarf2.h.
	* Makefile.in: Rebuild.
	* dwarf.c: Include dwarf2.h, not elf/dwarf2.h.
gas
	* Makefile.am (DEPTC_alpha_ecoff): Refer to dwarf2.h, not
	elf/dwarf2.h.
	(DEPTC_alpha_elf): Likewise.
	(DEPTC_alpha_evax): Likewise.
	(DEPTC_arm_elf): Likewise.
	(DEPTC_hppa_elf): Likewise.
	(DEPTC_i386_aout): Likewise.
	(DEPTC_i386_coff): Likewise.
	(DEPTC_i386_elf): Likewise.
	(DEPTC_m68k_aout): Likewise.
	(DEPTC_m68k_coff): Likewise.
	(DEPTC_m68k_elf): Likewise.
	(DEPTC_mips_coff): Likewise.
	(DEPTC_mips_ecoff): Likewise.
	(DEPTC_mips_elf): Likewise.
	(DEPTC_ppc_coff): Likewise.
	(DEPTC_ppc_elf): Likewise.
	(DEPTC_s390_elf): Likewise.
	(DEPTC_sh_coff): Likewise.
	(DEPTC_sh_elf): Likewise.
	(DEPTC_sh64_elf): Likewise.
	(DEPTC_sparc_aout): Likewise.
	(DEPTC_sparc_coff): Likewise.
	(DEPTC_sparc_elf): Likewise.
	(as.o): Likewise.
	(dwarf2dbg.o): Likewise.
	(dw2gencfi.o): Likewise.
	(ehopt.o): Likewise.
	(read.o): Likewise.
	* Makefile.in: Rebuild.
	* dw2gencfi.h: Include dwarf2.h, not elf/dwarf2.h.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
gdb
	* dwarf2-frame.c: Include dwarf2.h, not elf/dwarf2.h.
	* dwarf2expr.c: Likewise.
	* dwarf2loc.c: Likewise.
	* dwarf2read.c: Likewise.
	* sh-tdep.c: Likewise.
	* xtensa-tdep.c: Likewise.
include
	* dwarf2.h: New file, moved from elf/.
include/elf

	* dwarf2.h: Move to `..'.
@
text
@d2 1
a2 1
   Copyright 1998, 2000, 2001, 2003, 2005, 2007, 2008
@


1.18
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d31 1
a31 1
#include "elf/dwarf2.h"
@


1.17
log
@	* Makefile.am (ehopt.o): Add struc-symbol.h.
	* Makefile.in: Regenerated.
	* ehopt.c: Include struc-symbol.h.
	(check_eh_frame): For very small O_constant DW_CFA_advance_loc4
	create correct DW_CFA_advance_loc.  Handle O_subtract only
	for code alignment factor 1, otherwise handle O_divide or
	O_right_shift of O_subtract and O_constant.
	(eh_frame_estimate_size_before_relax): Always divide by ca.
	(eh_frame_convert_frag): Likewise.

	* dw2gencfi.c (output_cfi_insn): Scale DW_CFA_advance_loc1,
	DW_CFA_advance_loc2 and DW_CFA_advance_loc4 outputs.
@
text
@d477 1
a477 1
  assert (ca > 0);
d524 1
a524 1
  assert (ca > 0);
d529 1
a529 1
      assert (diff < 0x40);
d534 1
a534 1
      assert (diff < 0x100);
d540 1
a540 1
      assert (diff < 0x10000);
@


1.16
log
@* ehopt.c (check_eh_frame): If md_allow_eh_opt is defined, invoke it to see if the optimizations should be applied.
* config/tc-mn10300.h (md_allow_eh_opt): Define.  Only allow call frame optimization if linker relaxation is not enabled.
* gas/elf/elf.exp: Disable ehopt test for mn10300.
@
text
@d2 2
a3 1
   Copyright 1998, 2000, 2001, 2003, 2005, 2007 Free Software Foundation, Inc.
d25 1
d403 1
a403 3
	  if (d->cie_info.code_alignment > 0
	      && exp->X_add_number % d->cie_info.code_alignment == 0
	      && exp->X_add_number / d->cie_info.code_alignment < 0x40)
d406 1
a406 2
		= DW_CFA_advance_loc
		  | (exp->X_add_number / d->cie_info.code_alignment);
d421 1
a421 1
      else if (exp->X_op == O_subtract)
d427 1
a427 8
	  int fr_subtype;

	  if (d->cie_info.code_alignment > 0)
	    fr_subtype = d->cie_info.code_alignment << 3;
	  else
	    fr_subtype = 0;

	  frag_var (rs_cfa, 4, 0, fr_subtype, make_expr_symbol (exp),
d431 23
d477 3
a479 1
  if (ca > 0 && diff % ca == 0 && diff / ca < 0x40)
d516 1
a516 1
  int loc4_fix;
d523 3
d529 2
a530 5
      {
	int ca = frag->fr_subtype >> 3;
	assert (ca > 0 && diff % ca == 0 && diff / ca < 0x40);
	loc4_frag->fr_literal[loc4_fix] = DW_CFA_advance_loc | (diff / ca);
      }
@


1.16.2.1
log
@Back-port of:
2009-01-14  Jakub Jelinek  <jakub@@redhat.com>

	* Makefile.am (ehopt.o): Add struc-symbol.h.
	* Makefile.in: Regenerated.
	* ehopt.c: Include struc-symbol.h.
	(check_eh_frame): For very small O_constant DW_CFA_advance_loc4
	create correct DW_CFA_advance_loc.  Handle O_subtract only
	for code alignment factor 1, otherwise handle O_divide or
	O_right_shift of O_subtract and O_constant.
	(eh_frame_estimate_size_before_relax): Always divide by ca.
	(eh_frame_convert_frag): Likewise.

2009-01-14  John David Anglin  <dave.anglin@@nrc-cnrc.gc.ca>

	* dw2gencfi.c (output_cfi_insn): Scale DW_CFA_advance_loc1,
	DW_CFA_advance_loc2 and DW_CFA_advance_loc4 outputs.
@
text
@d2 1
a2 2
   Copyright 1998, 2000, 2001, 2003, 2005, 2007, 2008
   Free Software Foundation, Inc.
a23 1
#include "struc-symbol.h"
d401 3
a403 1
	  if (exp->X_add_number < 0x40)
d406 2
a407 1
		= DW_CFA_advance_loc | exp->X_add_number;
d422 1
a422 1
      else if (exp->X_op == O_subtract && d->cie_info.code_alignment == 1)
d428 8
a435 1
	  frag_var (rs_cfa, 4, 0, 1 << 3, make_expr_symbol (exp),
a438 23
      else if ((exp->X_op == O_divide
		|| exp->X_op == O_right_shift)
	       && d->cie_info.code_alignment > 1)
	{
	  if (exp->X_add_symbol->bsym
	      && exp->X_op_symbol->bsym
	      && exp->X_add_symbol->sy_value.X_op == O_subtract
	      && exp->X_op_symbol->sy_value.X_op == O_constant
	      && ((exp->X_op == O_divide
		   ? exp->X_op_symbol->sy_value.X_add_number
		   : (offsetT) 1 << exp->X_op_symbol->sy_value.X_add_number)
		  == (offsetT) d->cie_info.code_alignment))
	    {
	      /* This is a case we can optimize as well.  The expression was
		 not reduced, so we can not finish the optimization until the
		 end of the assembly.  We set up a variant frag which we
		 handle later.  */
	      frag_var (rs_cfa, 4, 0, d->cie_info.code_alignment << 3,
			make_expr_symbol (&exp->X_add_symbol->sy_value),
			d->loc4_fix, (char *) d->loc4_frag);
	      return 1;
	    }
	}
d462 1
a462 3
  assert (ca > 0);
  diff /= ca;
  if (diff < 0x40)
d499 1
a499 1
  int loc4_fix, ca;
a505 3
  ca = frag->fr_subtype >> 3;
  assert (ca > 0);
  diff /= ca;
d509 5
a513 2
      assert (diff < 0x40);
      loc4_frag->fr_literal[loc4_fix] = DW_CFA_advance_loc | diff;
@


1.15
log
@Switch to GPLv3
@
text
@d278 5
@


1.14
log
@	* README-vms: Delete.
	* config-gas.com: Delete.
	* makefile.vms: Delete.
	* vmsconf.sh: Delete.
	* config/atof-tahoe.c: Delete.
	* config/m88k-opcode.h: Delete.
	* config/obj-bout.c: Delete.
	* config/obj-bout.h: Delete.
	* config/obj-hp300.c: Delete.
	* config/obj-hp300.h: Delete.
	* config/tc-a29k.c: Delete.
	* config/tc-a29k.h: Delete.
	* config/tc-h8500.c: Delete.
	* config/tc-h8500.h: Delete.
	* config/tc-m88k.c: Delete.
	* config/tc-m88k.h: Delete.
	* config/tc-tahoe.c: Delete.
	* config/tc-tahoe.h: Delete.
	* config/tc-tic80.c: Delete.
	* config/tc-tic80.h: Delete.
	* config/tc-w65.c: Delete.
	* config/tc-w65.h: Delete.
	* config/te-aux.h: Delete.
	* config/te-delt88.h: Delete.
	* config/te-delta.h: Delete.
	* config/te-dpx2.h: Delete.
	* config/te-hp300.h: Delete.
	* config/te-ic960.h: Delete.
	* config/vms-a-conf.h: Delete.
	* doc/c-a29k.texi: Delete.
	* doc/c-h8500.texi: Delete.
	* doc/c-m88k.texi: Delete.
	* README: Remove obsolete examples, and list of supported targets.
	* Makefile.am: Remove a29k, h8500, m88k, tahoe, tic80, w65,
	bout and hp300 support.
	(DEP_FLAGS): Don't define BFD_ASSEMBLER.
	* configure.in: Remove --enable-bfd-assembler, need_bfd,
	primary_bfd_gas.
	* configure.tgt: Remove a29k, h8300-coff, h8500-*, i960 non-elf,
	m68k non bfd, m88k, or32-coff, tic80-*, vax non-bfd, w65k-*, *-nindy.
	* as.c: Remove all non-BFD_ASSEMBLER code, support for above targets.
	* as.h: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
	* input-file.c: Likewise.
	* listing.c: Likewise.
	* literal.c: Likewise.
	* messages.c: Likewise.
	* obj.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* stabs.c: Likewise.
	* struc-symbol.h: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* symbols.c: Likewise.
	* symbols.h: Likewise.
	* tc.h: Likewise.
	* write.c: Likewise.
	* write.h: Likewise.
	* config/aout_gnu.h: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-aout.h: Likewise.
	* config/obj-coff.c: Likewise.
	* config/obj-coff.h: Likewise.
	* config/obj-evax.h: Likewise.
	* config/obj-ieee.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-crx.h: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-d30v.h: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-fr30.h: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-hppa.h: Likewise.
	* config/tc-i370.h: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i860.h: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ip2k.h: Likewise.
	* config/tc-iq2000.h: Likewise.
	* config/tc-m32c.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m68k.h: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-maxq.h: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mn10200.h: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-mn10300.h: Likewise.
	* config/tc-ms1.h: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-msp430.h: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-ns32k.h: Likewise.
	* config/tc-openrisc.h: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.h: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic4x.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-vax.h: Likewise.
	* config/tc-xstormy16.h: Likewise.
	* config/tc-xtensa.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-z8k.h: Likewise.
	* config/vms-a-conf.h
	* doc/Makefile.am: Likewise.
	* doc/all.texi: Likewise.
	* doc/as.texinfo: Likewise.
	* doc/Makefile.in: Regenerate.
	* Makefile.in: Regenerate.
	* configure: Regenerate.
	* config.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d2 1
a2 1
   Copyright 1998, 2000, 2001, 2003, 2005 Free Software Foundation, Inc.
d5 1
a5 1
This file is part of GAS, the GNU Assembler.
d7 14
a20 14
GAS is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GAS is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GAS; see the file COPYING.  If not, write to the Free
Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
02110-1301, USA.  */
@


1.13
log
@Update the address and phone number of the FSF
@
text
@d2 1
a2 1
   Copyright 1998, 2000, 2001, 2003 Free Software Foundation, Inc.
a113 1
#if defined (BFD_ASSEMBLER) || defined (MANY_SEGMENTS)
a114 4
#else
  f = frchain_now->frch_root;
#endif
#ifdef BFD_ASSEMBLER
a115 3
#else
  fix = *seg_fix_rootP;
#endif
@


1.12
log
@	* ehopt.c: Convert to ISO-C.
	* emul.h: Likewise.
	* expr.c: Likewise.
	* expr.h: Likewise.
	* flonum-copy.c: Likewise.
	* flonum-mult.c: Likewise.
	* flonum.h: Likewise.
	* frags.c: Likewise.
	* frags.h: Likewise.
@
text
@d19 2
a20 2
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.  */
@


1.11
log
@	* ehopt.c (check_eh_frame): For aug_size == 0
	in state_seeing_aug_size state skip the state_skipping_aug
	state.
@
text
@d97 1
a97 1
static int get_cie_info PARAMS ((struct cie_info *));
d102 1
a102 2
get_cie_info (info)
     struct cie_info *info;
d250 1
a250 3
check_eh_frame (exp, pnbytes)
     expressionS *exp;
     unsigned int *pnbytes;
d457 1
a457 2
eh_frame_estimate_size_before_relax (frag)
     fragS *frag;
d484 1
a484 2
eh_frame_relax_frag (frag)
     fragS *frag;
d498 1
a498 2
eh_frame_convert_frag (frag)
     fragS *frag;
@


1.10
log
@	* app.c: Fix formatting.
	* as.c: Likewise.
	* ehopt.c: Likewise.
	* expr.c: Likewise.
	* input-file.c: Likewise.
	* listing.c: Likewise.
	* macro.h: Likewise.
	* stabs.c: Likewise.
	* symbols.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 1998, 2000, 2001 Free Software Foundation, Inc.
d366 2
@


1.9
log
@	* symbols.c (resolve_symbol_value): Remove "finalize" param,
	instead use finalize_syms directly.  Don't treat expressions
	specially with regard to finalize_syms.  Update calls to self.
	(resolve_local_symbol): Update call to resolve_symbol_value.
	(S_GET_VALUE): Likewise.  Return resolve_symbol_value if
	!finalize_syms.
	* symbols.h (resolve_symbol_value): Update prototype.
	* config/obj-aout.c (obj_crawl_symbol_chain): Update call
	to resolve_symbol_value.
	* config/obj-bout.c (obj_crawl_symbol_chain): Likewise.
	* config/obj-coff.c (do_relocs_for): Likewise.
	(yank_symbols): Likewise.
	(fixup_segment): Likewise.
	* config/obj-vms.c (obj_crawl_symbol_chain): Likewise.
	* config/tc-mips.c (md_convert_frag): Likewise.
	* config/tc-ppc.c (ppc_frob_symbol): Likewise.
	(ppc_fix_adjustable): Likewise.
	* dwarf2dbg.c (dwarf2dbg_estimate_size_before_relax): Likewise.
	(dwarf2dbg_convert_frag): Likewise.
	* ehopt.c (eh_frame_estimate_size_before_relax): Likewise.
	(eh_frame_convert_frag): Likewise.
	* expr.c (make_expr_symbol): Likewise.
	* write.c (adjust_reloc_syms): Likewise.
	(write_object_file): Likewise.
	(relax_segment): Likewise.
	(fixup_segment): Likewise.
	(finalize_syms): Init to zero, and update comment.
	(write_object_file): Set finalize_syms to 1 rather than 2.
	* doc/internals.texi (sy_value): Mention finalize_syms.
	(S_GET_VALUE): Remove restriction on when S_GET_VALUE can be called.
@
text
@d373 1
a373 1
          int left = (d->aug_size -= *pnbytes);
@


1.8
log
@        * ehopt.c (eh_frame_convert_frag): Fix missed subtype adjustment
        last change.
@
text
@d465 1
a465 1
  diff = resolve_symbol_value (frag->fr_symbol, 0);
d511 1
a511 1
  diff = resolve_symbol_value (frag->fr_symbol, finalize_syms);
@


1.7
log
@        * ehopt.c (get_cie_info): Rename from eh_frame_code_alignment;
        also collect whether to expect an FDE augmentation.
        (check_eh_frame): Rewrite as a state machine.  Track where in
        an FDE we are located, skip any augmentation.
        (eh_frame_estimate_size_before_relax): Get code alignment from
        the fragment subtype.
        (eh_frame_relax_frag, eh_frame_convert_frag): Likewise.
        * read.c (emit_leb128_expr): Call check_eh_frame.
@
text
@d540 1
a540 1
  frag->fr_fix += frag->fr_subtype;
d542 1
@


1.6
log
@Pass finalize_syms on calls to resolve_symbol_value.
@
text
@d91 7
a97 1
static int eh_frame_code_alignment PARAMS ((int));
d99 1
a99 1
/* Get the code alignment factor from the CIE.  */
d102 2
a103 2
eh_frame_code_alignment (in_seg)
     int in_seg;
a104 3
  /* ??? Assume .eh_frame and .debug_frame have the same alignment.  */
  static int code_alignment;

d111 1
a111 7

  if (code_alignment != 0)
    return code_alignment;

  /* Can't find the alignment if we've changed sections.  */
  if (! in_seg)
    return -1;
d147 1
a147 4
    {
      code_alignment = -1;
      return -1;
    }
d160 1
a160 4
    {
      code_alignment = -1;
      return -1;
    }
d174 2
a175 4
	{
	  code_alignment = -1;
	  return -1;
	}
d195 1
a195 4
    {
      code_alignment = -1;
      return -1;
    }
d219 1
a219 9
	{
	  code_alignment = -1;
	  return -1;
	}
    }
  else
    {
      code_alignment = -1;
      return -1;
d221 2
d228 5
a232 5
  if ((code_alignment & 0x80) != 0 || code_alignment == 0)
    {
      code_alignment = -1;
      return -1;
    }
d234 1
a234 1
  return code_alignment;
d257 16
a274 2
    int saw_size;
    int saw_advance_loc4;
d276 3
d297 1
a297 1
  if (d->saw_size && S_IS_DEFINED (d->size_end_sym))
d302 1
a302 2
      d->saw_size = 0;
      d->saw_advance_loc4 = 0;
d305 1
a305 2
  if (! d->saw_size
      && *pnbytes == 4)
d307 2
a308 11
      /* This might be the size of the CIE or FDE.  We want to know
         the size so that we don't accidentally optimize across an FDE
         boundary.  We recognize the size in one of two forms: a
         symbol which will later be defined as a difference, or a
         subtraction of two symbols.  Either way, we can tell when we
         are at the end of the FDE because the symbol becomes defined
         (in the case of a subtraction, the end symbol, from which the
         start symbol is being subtracted).  Other ways of describing
         the size will not be optimized.  */
      if ((exp->X_op == O_symbol || exp->X_op == O_subtract)
	  && ! S_IS_DEFINED (exp->X_add_symbol))
d310 15
a324 2
	  d->saw_size = 1;
	  d->size_end_sym = exp->X_add_symbol;
d326 1
a326 18
    }
  else if (d->saw_size
	   && *pnbytes == 1
	   && exp->X_op == O_constant
	   && exp->X_add_number == DW_CFA_advance_loc4)
    {
      /* This might be a DW_CFA_advance_loc4.  Record the frag and the
         position within the frag, so that we can change it later.  */
      d->saw_advance_loc4 = 1;
      frag_grow (1);
      d->loc4_frag = frag_now;
      d->loc4_fix = frag_now_fix ();
    }
  else if (d->saw_advance_loc4
	   && *pnbytes == 4
	   && exp->X_op == O_constant)
    {
      int ca;
d328 20
a347 4
      /* This is a case which we can optimize.  The two symbols being
         subtracted were in the same frag and the expression was
         reduced to a constant.  We can do the optimization entirely
         in this function.  */
d349 3
a351 4
      d->saw_advance_loc4 = 0;

      ca = eh_frame_code_alignment (1);
      if (ca < 0)
d353 2
a354 1
	  /* Don't optimize.  */
d356 1
a356 2
      else if (exp->X_add_number % ca == 0
	       && exp->X_add_number / ca < 0x40)
d358 5
a362 4
	  d->loc4_frag->fr_literal[d->loc4_fix]
	    = DW_CFA_advance_loc | (exp->X_add_number / ca);
	  /* No more bytes needed.  */
	  return 1;
d364 8
a371 1
      else if (exp->X_add_number < 0x100)
d373 5
a377 2
	  d->loc4_frag->fr_literal[d->loc4_fix] = DW_CFA_advance_loc1;
	  *pnbytes = 1;
d379 6
a384 1
      else if (exp->X_add_number < 0x10000)
d386 6
a391 2
	  d->loc4_frag->fr_literal[d->loc4_fix] = DW_CFA_advance_loc2;
	  *pnbytes = 2;
d393 1
a393 9
    }
  else if (d->saw_advance_loc4
	   && *pnbytes == 4
	   && exp->X_op == O_subtract)
    {
      /* This is a case we can optimize.  The expression was not
         reduced, so we can not finish the optimization until the end
         of the assembly.  We set up a variant frag which we handle
         later.  */
d395 43
a437 1
      d->saw_advance_loc4 = 0;
d439 5
a443 2
      frag_var (rs_cfa, 4, 0, 0, make_expr_symbol (exp),
		d->loc4_fix, (char *) d->loc4_frag);
d445 3
a447 1
      return 1;
a448 2
  else
    d->saw_advance_loc4 = 0;
d455 1
a455 1
   relaxation loop.  We set fr_subtype to the expected length.  */
a460 1
  int ca;
d462 1
a464 1
  ca = eh_frame_code_alignment (0);
d467 1
a467 3
  if (ca < 0)
    ret = 4;
  else if (diff % ca == 0 && diff / ca < 0x40)
d476 1
a476 1
  frag->fr_subtype = ret;
d482 2
a483 2
   values of the symbols.  fr_subtype is the current length of the
   frag.  This returns the change in frag length.  */
d491 1
a491 1
  oldsize = frag->fr_subtype;
d498 1
a498 1
   fr_subtype will be the desired length of the frag.  */
d513 1
a513 1
  if (frag->fr_subtype == 0)
d515 7
a521 1
      int ca;
d523 1
a523 6
      ca = eh_frame_code_alignment (0);
      assert (ca > 0 && diff % ca == 0 && diff / ca < 0x40);
      loc4_frag->fr_literal[loc4_fix] = DW_CFA_advance_loc | (diff / ca);
    }
  else if (frag->fr_subtype == 1)
    {
d527 3
a529 3
    }
  else if (frag->fr_subtype == 2)
    {
d533 5
a538 2
  else
    md_number_to_chars (frag->fr_literal + frag->fr_fix, diff, 4);
@


1.5
log
@Fix copyright notices
@
text
@d460 1
a460 1
  diff = resolve_symbol_value (frag->fr_symbol, 1);
@


1.4
log
@2001-01-23  Kazu Hirata  <kazu@@hxi.com>

	* as.c: Fix formatting.
	* ehopt.c: Likewise.
	* messages.c: Likewise.
	* stabs.c: Likewise.
	* symbols.c: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1998, 2000 Free Software Foundation, Inc.
@


1.4.2.1
log
@        * ehopt.c (get_cie_info): Rename from eh_frame_code_alignment;
        also collect whether to expect an FDE augmentation.
        (check_eh_frame): Rewrite as a state machine.  Track where in
        an FDE we are located, skip any augmentation.
        (eh_frame_estimate_size_before_relax): Get code alignment from
        the fragment subtype.
        (eh_frame_relax_frag, eh_frame_convert_frag): Likewise.
        * read.c (emit_leb128_expr): Call check_eh_frame.
@
text
@d91 1
a91 7
struct cie_info
{
  unsigned code_alignment;
  int z_augmentation;
};

static int get_cie_info PARAMS ((struct cie_info *));
d93 1
a93 1
/* Extract information from the CIE.  */
d96 2
a97 2
get_cie_info (info)
     struct cie_info *info;
d99 3
d108 7
a114 1
  int code_alignment = 0;
d150 4
a153 1
    return 0;
d166 4
a169 1
    return 0;
d183 4
a186 2
	return 0;

d206 4
a209 1
    return 0;
d233 9
a241 1
	return 0;
a242 2
  else if (augmentation[0] != 'z')
    return 0;
d248 5
a252 5
  if ((code_alignment & 0x80) != 0)
    code_alignment = 0;

  info->code_alignment = code_alignment;
  info->z_augmentation = (augmentation[0] == 'z');
d254 1
a254 1
  return 1;
a276 16
    enum frame_state
    {
      state_idle,
      state_saw_size,
      state_saw_cie_offset,
      state_saw_pc_begin,
      state_seeing_aug_size,
      state_skipping_aug,
      state_wait_loc4,
      state_saw_loc4,
      state_error,
    } state;

    int cie_info_ok;
    struct cie_info cie_info;

d279 2
a281 3

    int aug_size;
    int aug_shift;
d300 1
a300 1
  if (d->state >= state_saw_size && S_IS_DEFINED (d->size_end_sym))
d305 2
a306 1
      d->state = state_idle;
d309 2
a310 1
  switch (d->state)
d312 11
a322 2
    case state_idle:
      if (*pnbytes == 4)
d324 2
a325 15
	  /* This might be the size of the CIE or FDE.  We want to know
	     the size so that we don't accidentally optimize across an FDE
	     boundary.  We recognize the size in one of two forms: a
	     symbol which will later be defined as a difference, or a
	     subtraction of two symbols.  Either way, we can tell when we
	     are at the end of the FDE because the symbol becomes defined
	     (in the case of a subtraction, the end symbol, from which the
	     start symbol is being subtracted).  Other ways of describing
	     the size will not be optimized.  */
	  if ((exp->X_op == O_symbol || exp->X_op == O_subtract)
	      && ! S_IS_DEFINED (exp->X_add_symbol))
	    {
	      d->state = state_saw_size;
	      d->size_end_sym = exp->X_add_symbol;
	    }
d327 23
a349 1
      break;
d351 1
a351 20
    case state_saw_size:
    case state_saw_cie_offset:
      /* Assume whatever form it appears in, it appears atomically.  */
      d->state += 1;
      break;

    case state_saw_pc_begin:
      /* Decide whether we should see an augmentation.  */
      if (! d->cie_info_ok
	  && ! (d->cie_info_ok = get_cie_info (&d->cie_info)))
	d->state = state_error;
      else if (d->cie_info.z_augmentation)
	{
	  d->state = state_seeing_aug_size;
	  d->aug_size = 0;
	  d->aug_shift = 0;
	}
      else
	d->state = state_wait_loc4;
      break;
d353 2
a354 3
    case state_seeing_aug_size:
      /* Bytes == -1 means this comes from an leb128 directive.  */
      if ((int)*pnbytes == -1 && exp->X_op == O_constant)
d356 1
a356 2
	  d->aug_size = exp->X_add_number;
	  d->state = state_skipping_aug;
d358 2
a359 1
      else if (*pnbytes == 1 && exp->X_op == O_constant)
d361 4
a364 5
	  unsigned char byte = exp->X_add_number;
	  d->aug_size |= (byte & 0x7f) << d->aug_shift;
	  d->aug_shift += 7;
	  if ((byte & 0x80) == 0)
	    d->state = state_skipping_aug;
d366 1
a366 8
      else
	d->state = state_error;
      break;

    case state_skipping_aug:
      if ((int)*pnbytes < 0)
	d->state = state_error;
      else
d368 2
a369 5
          int left = (d->aug_size -= *pnbytes);
	  if (left == 0)
	    d->state = state_wait_loc4;
	  else if (left < 0)
	    d->state = state_error;
d371 1
a371 6
      break;

    case state_wait_loc4:
      if (*pnbytes == 1
	  && exp->X_op == O_constant
	  && exp->X_add_number == DW_CFA_advance_loc4)
d373 2
a374 6
	  /* This might be a DW_CFA_advance_loc4.  Record the frag and the
	     position within the frag, so that we can change it later.  */
	  frag_grow (1);
	  d->state = state_saw_loc4;
	  d->loc4_frag = frag_now;
	  d->loc4_fix = frag_now_fix ();
d376 9
a384 1
      break;
d386 1
a386 43
    case state_saw_loc4:
      d->state = state_wait_loc4;
      if (*pnbytes != 4)
	break;
      if (exp->X_op == O_constant)
	{
	  /* This is a case which we can optimize.  The two symbols being
	     subtracted were in the same frag and the expression was
	     reduced to a constant.  We can do the optimization entirely
	     in this function.  */
	  if (d->cie_info.code_alignment > 0
	      && exp->X_add_number % d->cie_info.code_alignment == 0
	      && exp->X_add_number / d->cie_info.code_alignment < 0x40)
	    {
	      d->loc4_frag->fr_literal[d->loc4_fix]
		= DW_CFA_advance_loc
		  | (exp->X_add_number / d->cie_info.code_alignment);
	      /* No more bytes needed.  */
	      return 1;
	    }
	  else if (exp->X_add_number < 0x100)
	    {
	      d->loc4_frag->fr_literal[d->loc4_fix] = DW_CFA_advance_loc1;
	      *pnbytes = 1;
	    }
	  else if (exp->X_add_number < 0x10000)
	    {
	      d->loc4_frag->fr_literal[d->loc4_fix] = DW_CFA_advance_loc2;
	      *pnbytes = 2;
	    }
	}
      else if (exp->X_op == O_subtract)
	{
	  /* This is a case we can optimize.  The expression was not
	     reduced, so we can not finish the optimization until the end
	     of the assembly.  We set up a variant frag which we handle
	     later.  */
	  int fr_subtype;

	  if (d->cie_info.code_alignment > 0)
	    fr_subtype = d->cie_info.code_alignment << 3;
	  else
	    fr_subtype = 0;
d388 2
a389 5
	  frag_var (rs_cfa, 4, 0, fr_subtype, make_expr_symbol (exp),
		    d->loc4_fix, (char *) d->loc4_frag);
	  return 1;
	}
      break;
d391 1
a391 3
    case state_error:
      /* Just skipping everything.  */
      break;
d393 2
d401 1
a401 1
   relaxation loop.  We set fr_subtype{0:2} to the expected length.  */
d407 1
a408 1
  int ca = frag->fr_subtype >> 3;
d411 1
d414 3
a416 1
  if (ca > 0 && diff % ca == 0 && diff / ca < 0x40)
d425 1
a425 1
  frag->fr_subtype = (frag->fr_subtype & ~7) | ret;
d431 2
a432 2
   values of the symbols.  fr_subtype{0:2} is the current length of
   the frag.  This returns the change in frag length.  */
d440 1
a440 1
  oldsize = frag->fr_subtype & 7;
d447 1
a447 1
   fr_subtype{0:2} will be the desired length of the frag.  */
d462 1
a462 1
  switch (frag->fr_subtype & 7)
d464 1
a464 7
    case 0:
      {
	int ca = frag->fr_subtype >> 3;
	assert (ca > 0 && diff % ca == 0 && diff / ca < 0x40);
	loc4_frag->fr_literal[loc4_fix] = DW_CFA_advance_loc | (diff / ca);
      }
      break;
d466 6
a471 1
    case 1:
d475 3
a477 3
      break;

    case 2:
a480 5
      break;

    default:
      md_number_to_chars (frag->fr_literal + frag->fr_fix, diff, 4);
      break;
d482 2
@


1.4.2.2
log
@        * ehopt.c (eh_frame_convert_frag): Fix missed subtype adjustment
        last change.
@
text
@d540 1
a540 1
  frag->fr_fix += frag->fr_subtype & 7;
a541 1
  frag->fr_subtype = 0;
@


1.4.2.3
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1998, 2000, 2001 Free Software Foundation, Inc.
@


1.3
log
@        * ehopt.c (eh_frame_code_alignment): New arg `in_seg', update all
        callers.  Don't switch segments.  Expect CIE == -1 in .debug_frame.
        (check_eh_frame): Handle .eh_frame and .debug_frame concurrently.
@
text
@d283 1
a283 1
  
@


1.2
log
@2000-09-11  Kazu Hirata  <kazu@@hxi.com>

	* bignum-copy.c: Fix formatting.
	* ehopt.c: Likewise.
	* flonum-copy.c: Likewise.
	* flonum-konst.c: Likewise.
	* flonum-mult.c: Likewise.
	* literal.c: Likewise.
	* read.c: Likewise.
	* sb.c: Likewise.
	* stabs.c: Likewise.
	* subsegs.c: Likewise.
@
text
@d34 2
a35 2
   .eh_frame section.  Simple information for a function with no
   exceptions looks like this:
d40 1
d42 3
d91 1
a91 1
static int eh_frame_code_alignment PARAMS ((void));
d96 2
a97 1
eh_frame_code_alignment ()
d99 1
d101 1
a101 2
  segT current_seg;
  subsegT current_subseg;
d105 1
d112 5
a116 1
  /* We should find the CIE at the start of the .eh_frame section.  */
a117 3
  current_seg = now_seg;
  current_subseg = now_subseg;
  subseg_new (".eh_frame", 0);
a127 1
  subseg_set (current_seg, current_subseg);
d131 6
a136 1
  /* First make sure that the CIE Identifier Tag is 0.  */
d146 4
a149 4
      || f->fr_literal[offset] != 0
      || f->fr_literal[offset + 1] != 0
      || f->fr_literal[offset + 2] != 0
      || f->fr_literal[offset + 3] != 0)
d275 16
a290 5
  static int saw_size;
  static symbolS *size_end_sym;
  static int saw_advance_loc4;
  static fragS *loc4_frag;
  static int loc4_fix;
d292 9
a300 2
  if (saw_size
      && S_IS_DEFINED (size_end_sym))
d305 2
a306 2
      saw_size = 0;
      saw_advance_loc4 = 0;
d309 2
a310 11
  if (flag_traditional_format)
    {
      /* Don't optimize.  */
    }
  else if (strcmp (segment_name (now_seg), ".eh_frame") != 0)
    {
      saw_size = 0;
      saw_advance_loc4 = 0;
    }
  else if (! saw_size
	   && *pnbytes == 4)
d324 2
a325 2
	  saw_size = 1;
	  size_end_sym = exp->X_add_symbol;
d328 1
a328 1
  else if (saw_size
d335 1
a335 1
      saw_advance_loc4 = 1;
d337 2
a338 2
      loc4_frag = frag_now;
      loc4_fix = frag_now_fix ();
d340 1
a340 1
  else if (saw_advance_loc4
d351 1
a351 1
      saw_advance_loc4 = 0;
d353 1
a353 1
      ca = eh_frame_code_alignment ();
d361 1
a361 1
	  loc4_frag->fr_literal[loc4_fix]
d368 1
a368 1
	  loc4_frag->fr_literal[loc4_fix] = DW_CFA_advance_loc1;
d373 1
a373 1
	  loc4_frag->fr_literal[loc4_fix] = DW_CFA_advance_loc2;
d377 1
a377 1
  else if (saw_advance_loc4
a380 1

d386 1
a386 1
      saw_advance_loc4 = 0;
d389 1
a389 1
		loc4_fix, (char *) loc4_frag);
d394 1
a394 1
    saw_advance_loc4 = 0;
d411 1
a411 1
  ca = eh_frame_code_alignment ();
d466 1
a466 1
      ca = eh_frame_code_alignment ();
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1998 Free Software Foundation, Inc.
d20 1
a20 1
02111-1307, USA. */
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

