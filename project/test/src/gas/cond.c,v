head	1.23;
access;
symbols
	binutils-2_24-branch:1.23.0.2
	binutils-2_24-branchpoint:1.23
	binutils-2_21_1:1.21
	binutils-2_23_2:1.22
	binutils-2_23_1:1.22
	binutils-2_23:1.22
	binutils-2_23-branch:1.22.0.6
	binutils-2_23-branchpoint:1.22
	binutils-2_22_branch:1.22.0.4
	binutils-2_22:1.22
	binutils-2_22-branch:1.22.0.2
	binutils-2_22-branchpoint:1.22
	binutils-2_21:1.21
	binutils-2_21-branch:1.21.0.4
	binutils-2_21-branchpoint:1.21
	binutils-2_20_1:1.21
	binutils-2_20:1.21
	binutils-arc-20081103-branch:1.20.0.10
	binutils-arc-20081103-branchpoint:1.20
	binutils-2_20-branch:1.21.0.2
	binutils-2_20-branchpoint:1.21
	dje-cgen-play1-branch:1.20.0.8
	dje-cgen-play1-branchpoint:1.20
	arc-20081103-branch:1.20.0.6
	arc-20081103-branchpoint:1.20
	binutils-2_19_1:1.20
	binutils-2_19:1.20
	binutils-2_19-branch:1.20.0.4
	binutils-2_19-branchpoint:1.20
	binutils-2_18:1.20
	binutils-2_18-branch:1.20.0.2
	binutils-2_18-branchpoint:1.20
	binutils-csl-coldfire-4_1-32:1.18
	binutils-csl-sourcerygxx-4_1-32:1.18
	binutils-csl-innovasic-fido-3_4_4-33:1.18
	binutils-csl-sourcerygxx-3_4_4-32:1.14
	binutils-csl-coldfire-4_1-30:1.18
	binutils-csl-sourcerygxx-4_1-30:1.18
	binutils-csl-coldfire-4_1-28:1.18
	binutils-csl-sourcerygxx-4_1-29:1.18
	binutils-csl-sourcerygxx-4_1-28:1.18
	binutils-csl-arm-2006q3-27:1.18
	binutils-csl-sourcerygxx-4_1-27:1.18
	binutils-csl-arm-2006q3-26:1.18
	binutils-csl-sourcerygxx-4_1-26:1.18
	binutils-csl-sourcerygxx-4_1-25:1.18
	binutils-csl-sourcerygxx-4_1-24:1.18
	binutils-csl-sourcerygxx-4_1-23:1.18
	binutils-csl-sourcerygxx-4_1-21:1.18
	binutils-csl-arm-2006q3-21:1.18
	binutils-csl-sourcerygxx-4_1-22:1.18
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.18
	binutils-csl-sourcerygxx-4_1-20:1.18
	binutils-csl-arm-2006q3-19:1.18
	binutils-csl-sourcerygxx-4_1-19:1.18
	binutils-csl-sourcerygxx-4_1-18:1.18
	binutils-csl-renesas-4_1-9:1.18
	binutils-csl-sourcerygxx-3_4_4-25:1.14
	binutils-csl-renesas-4_1-8:1.18
	binutils-csl-renesas-4_1-7:1.18
	binutils-csl-renesas-4_1-6:1.18
	binutils-csl-sourcerygxx-4_1-17:1.18
	binutils-csl-sourcerygxx-4_1-14:1.18
	binutils-csl-sourcerygxx-4_1-15:1.18
	binutils-csl-sourcerygxx-4_1-13:1.18
	binutils-2_17:1.18
	binutils-csl-sourcerygxx-4_1-12:1.18
	binutils-csl-sourcerygxx-3_4_4-21:1.18
	binutils-csl-wrs-linux-3_4_4-24:1.14
	binutils-csl-wrs-linux-3_4_4-23:1.14
	binutils-csl-sourcerygxx-4_1-9:1.18
	binutils-csl-sourcerygxx-4_1-8:1.18
	binutils-csl-sourcerygxx-4_1-7:1.18
	binutils-csl-arm-2006q1-6:1.18
	binutils-csl-sourcerygxx-4_1-6:1.18
	binutils-csl-wrs-linux-3_4_4-22:1.14
	binutils-csl-coldfire-4_1-11:1.18
	binutils-csl-sourcerygxx-3_4_4-19:1.18
	binutils-csl-coldfire-4_1-10:1.18
	binutils-csl-sourcerygxx-4_1-5:1.18
	binutils-csl-sourcerygxx-4_1-4:1.18
	binutils-csl-wrs-linux-3_4_4-21:1.14
	binutils-csl-morpho-4_1-4:1.18
	binutils-csl-sourcerygxx-3_4_4-17:1.18
	binutils-csl-wrs-linux-3_4_4-20:1.14
	binutils-2_17-branch:1.18.0.4
	binutils-2_17-branchpoint:1.18
	binutils-csl-2_17-branch:1.18.0.2
	binutils-csl-2_17-branchpoint:1.18
	binutils-csl-gxxpro-3_4-branch:1.14.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.14
	binutils-2_16_1:1.14
	binutils-csl-arm-2005q1b:1.14
	binutils-2_16:1.14
	binutils-csl-arm-2005q1a:1.14
	binutils-csl-arm-2005q1-branch:1.14.0.4
	binutils-csl-arm-2005q1-branchpoint:1.14
	binutils-2_16-branch:1.14.0.2
	binutils-2_16-branchpoint:1.14
	csl-arm-2004-q3d:1.13
	csl-arm-2004-q3:1.13
	binutils-2_15:1.13
	binutils-2_15-branchpoint:1.13
	csl-arm-2004-q1a:1.13
	csl-arm-2004-q1:1.13
	binutils-2_15-branch:1.13.0.6
	cagney_bfdfile-20040213-branch:1.13.0.4
	cagney_bfdfile-20040213-branchpoint:1.13
	cagney_bigcore-20040122-branch:1.13.0.2
	cagney_bigcore-20040122-branchpoint:1.13
	csl-arm-2003-q4:1.13
	binutils-2_14:1.12
	binutils-2_14-branch:1.12.0.2
	binutils-2_14-branchpoint:1.12
	binutils-2_13_2_1:1.11
	binutils-2_13_2:1.11
	binutils-2_13_1:1.11
	binutils-2_13:1.11
	binutils-2_13-branchpoint:1.11
	binutils-2_13-branch:1.11.0.4
	binutils-2_12_1:1.11
	binutils-2_12:1.11
	binutils-2_12-branch:1.11.0.2
	binutils-2_12-branchpoint:1.11
	cygnus_cvs_20020108_pre:1.11
	binutils-2_11_2:1.7.2.2
	binutils-2_11_1:1.7.2.2
	binutils-2_11:1.7.2.2
	x86_64versiong3:1.7
	binutils-2_11-branch:1.7.0.2
	binutils-2_10_1:1.5
	binutils-2_10:1.5
	binutils-2_10-branch:1.5.0.2
	binutils-2_10-branchpoint:1.5
	binutils_latest_snapshot:1.23
	repo-unification-2000-02-06:1.3
	binu_ss_19990721:1.3
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.23
date	2013.01.10.19.51.54;	author hjl;	state Exp;
branches;
next	1.22;

1.22
date	2011.05.17.16.15.59;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2009.09.02.07.24.19;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2007.07.03.11.01.02;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2006.06.07.11.27.57;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2005.11.17.07.29.28;	author jbeulich;	state Exp;
branches;
next	1.17;

1.17
date	2005.10.11.11.16.16;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.06.06.38.10;	author jbeulich;	state Exp;
branches;
next	1.15;

1.15
date	2005.05.05.09.12.43;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.03.01.29.52;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2003.11.21.01.52.16;	author kazu;	state Exp;
branches;
next	1.12;

1.12
date	2002.07.19.11.35.06;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2001.08.01.01.44.25;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.31.06.47.54;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.31.02.06.24;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.08.23.24.22;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2000.10.11.20.24.32;	author kazu;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2000.08.31.23.17.47;	author kazu;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.24.01.56.31;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2000.02.08.14.13.57;	author twall;	state Exp;
branches;
next	1.3;

1.3
date	99.07.11.20.19.54;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.06.03.00.28.56;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.40;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.7.2.1
date	2001.03.31.02.08.38;	author amodra;	state Exp;
branches;
next	1.7.2.2;

1.7.2.2
date	2001.03.31.06.49.33;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.40;	author rth;	state Exp;
branches;
next	;


desc
@@


1.23
log
@Remove trailing white spaces on gas

	* app.c: Remove trailing white spaces.
	* as.c: Likewise.
	* as.h: Likewise.
	* cond.c: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.h: Likewise.
	* ecoff.c: Likewise.
	* input-file.c: Likewise.
	* itbl-lex.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* sb.c: Likewise.
	* subsegs.c: Likewise.
	* symbols.c: Likewise.
	* write.c: Likewise.
	* config/tc-i386.c: Likewise.
	* doc/Makefile.am: Likewise.
	* doc/Makefile.in: Likewise.
	* doc/c-aarch64.texi: Likewise.
	* doc/c-alpha.texi: Likewise.
	* doc/c-arc.texi: Likewise.
	* doc/c-arm.texi: Likewise.
	* doc/c-avr.texi: Likewise.
	* doc/c-bfin.texi: Likewise.
	* doc/c-cr16.texi: Likewise.
	* doc/c-d10v.texi: Likewise.
	* doc/c-d30v.texi: Likewise.
	* doc/c-h8300.texi: Likewise.
	* doc/c-hppa.texi: Likewise.
	* doc/c-i370.texi: Likewise.
	* doc/c-i386.texi: Likewise.
	* doc/c-i860.texi: Likewise.
	* doc/c-m32c.texi: Likewise.
	* doc/c-m32r.texi: Likewise.
	* doc/c-m68hc11.texi: Likewise.
	* doc/c-m68k.texi: Likewise.
	* doc/c-microblaze.texi: Likewise.
	* doc/c-mips.texi: Likewise.
	* doc/c-msp430.texi: Likewise.
	* doc/c-mt.texi: Likewise.
	* doc/c-s390.texi: Likewise.
	* doc/c-score.texi: Likewise.
	* doc/c-sh.texi: Likewise.
	* doc/c-sh64.texi: Likewise.
	* doc/c-tic54x.texi: Likewise.
	* doc/c-tic6x.texi: Likewise.
	* doc/c-v850.texi: Likewise.
	* doc/c-xc16x.texi: Likewise.
	* doc/c-xgate.texi: Likewise.
	* doc/c-xtensa.texi: Likewise.
	* doc/c-z80.texi: Likewise.
	* doc/internals.texi: Likewise.
@
text
@/* cond.c - conditional assembly pseudo-ops, and .include
   Copyright 1990, 1991, 1992, 1993, 1995, 1997, 1998, 2000, 2001, 2002,
   2003, 2005, 2006, 2007 Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include "as.h"
#include "sb.h"
#include "macro.h"

#include "obstack.h"

/* This is allocated to grow and shrink as .ifdef/.endif pairs are
   scanned.  */
struct obstack cond_obstack;

struct file_line {
  char *file;
  unsigned int line;
};

/* We push one of these structures for each .if, and pop it at the
   .endif.  */

struct conditional_frame {
  /* The source file & line number of the "if".  */
  struct file_line if_file_line;
  /* The source file & line of the "else".  */
  struct file_line else_file_line;
  /* The previous conditional.  */
  struct conditional_frame *previous_cframe;
  /* Have we seen an else yet?  */
  int else_seen;
  /* Whether we are currently ignoring input.  */
  int ignoring;
  /* Whether a conditional at a higher level is ignoring input.
     Set also when a branch of an "if .. elseif .." tree has matched
     to prevent further matches.  */
  int dead_tree;
  /* Macro nesting level at which this conditional was created.  */
  int macro_nest;
};

static void initialize_cframe (struct conditional_frame *cframe);
static char *get_mri_string (int, int *);

static struct conditional_frame *current_cframe = NULL;

/* Performs the .ifdef (test_defined == 1) and
   the .ifndef (test_defined == 0) pseudo op.  */

void
s_ifdef (int test_defined)
{
  /* Points to name of symbol.  */
  char *name;
  /* Points to symbol.  */
  symbolS *symbolP;
  struct conditional_frame cframe;
  char c;

  /* Leading whitespace is part of operand.  */
  SKIP_WHITESPACE ();
  name = input_line_pointer;

  if (!is_name_beginner (*name))
    {
      as_bad (_("invalid identifier for \".ifdef\""));
      obstack_1grow (&cond_obstack, 0);
      ignore_rest_of_line ();
      return;
    }

  c = get_symbol_end ();
  symbolP = symbol_find (name);
  *input_line_pointer = c;

  initialize_cframe (&cframe);

  if (cframe.dead_tree)
    cframe.ignoring = 1;
  else
    {
      int is_defined;

      /* Use the same definition of 'defined' as .equiv so that a symbol
	 which has been referenced but not yet given a value/address is
	 considered to be undefined.  */
      is_defined =
	symbolP != NULL
	&& (S_IS_DEFINED (symbolP) || symbol_equated_p (symbolP))
	&& S_GET_SEGMENT (symbolP) != reg_section;

      cframe.ignoring = ! (test_defined ^ is_defined);
    }

  current_cframe = ((struct conditional_frame *)
		    obstack_copy (&cond_obstack, &cframe,
				  sizeof (cframe)));

  if (LISTING_SKIP_COND ()
      && cframe.ignoring
      && (cframe.previous_cframe == NULL
	  || ! cframe.previous_cframe->ignoring))
    listing_list (2);

  demand_empty_rest_of_line ();
}

void
s_if (int arg)
{
  expressionS operand;
  struct conditional_frame cframe;
  int t;
  char *stop = NULL;
  char stopc;

  if (flag_mri)
    stop = mri_comment_field (&stopc);

  /* Leading whitespace is part of operand.  */
  SKIP_WHITESPACE ();

  if (current_cframe != NULL && current_cframe->ignoring)
    {
      operand.X_add_number = 0;
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
    }
  else
    {
      expression_and_evaluate (&operand);
      if (operand.X_op != O_constant)
	as_bad (_("non-constant expression in \".if\" statement"));
    }

  switch ((operatorT) arg)
    {
    case O_eq: t = operand.X_add_number == 0; break;
    case O_ne: t = operand.X_add_number != 0; break;
    case O_lt: t = operand.X_add_number < 0; break;
    case O_le: t = operand.X_add_number <= 0; break;
    case O_ge: t = operand.X_add_number >= 0; break;
    case O_gt: t = operand.X_add_number > 0; break;
    default:
      abort ();
      return;
    }

  /* If the above error is signaled, this will dispatch
     using an undefined result.  No big deal.  */
  initialize_cframe (&cframe);
  cframe.ignoring = cframe.dead_tree || ! t;
  current_cframe = ((struct conditional_frame *)
		    obstack_copy (&cond_obstack, &cframe, sizeof (cframe)));

  if (LISTING_SKIP_COND ()
      && cframe.ignoring
      && (cframe.previous_cframe == NULL
	  || ! cframe.previous_cframe->ignoring))
    listing_list (2);

  if (flag_mri)
    mri_comment_end (stop, stopc);

  demand_empty_rest_of_line ();
}

/* Performs the .ifb (test_blank == 1) and
   the .ifnb (test_blank == 0) pseudo op.  */

void
s_ifb (int test_blank)
{
  struct conditional_frame cframe;

  initialize_cframe (&cframe);

  if (cframe.dead_tree)
    cframe.ignoring = 1;
  else
    {
      int is_eol;

      SKIP_WHITESPACE ();
      is_eol = is_end_of_line[(unsigned char) *input_line_pointer];
      cframe.ignoring = (test_blank == !is_eol);
    }

  current_cframe = ((struct conditional_frame *)
		    obstack_copy (&cond_obstack, &cframe,
				  sizeof (cframe)));

  if (LISTING_SKIP_COND ()
      && cframe.ignoring
      && (cframe.previous_cframe == NULL
	  || ! cframe.previous_cframe->ignoring))
    listing_list (2);

  ignore_rest_of_line ();
}

/* Get a string for the MRI IFC or IFNC pseudo-ops.  */

static char *
get_mri_string (int terminator, int *len)
{
  char *ret;
  char *s;

  SKIP_WHITESPACE ();
  s = ret = input_line_pointer;
  if (*input_line_pointer == '\'')
    {
      ++s;
      ++input_line_pointer;
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	{
	  *s++ = *input_line_pointer++;
	  if (s[-1] == '\'')
	    {
	      if (*input_line_pointer != '\'')
		break;
	      ++input_line_pointer;
	    }
	}
      SKIP_WHITESPACE ();
    }
  else
    {
      while (*input_line_pointer != terminator
	     && ! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
      s = input_line_pointer;
      while (s > ret && (s[-1] == ' ' || s[-1] == '\t'))
	--s;
    }

  *len = s - ret;
  return ret;
}

/* The MRI IFC and IFNC pseudo-ops.  */

void
s_ifc (int arg)
{
  char *stop = NULL;
  char stopc;
  char *s1, *s2;
  int len1, len2;
  int res;
  struct conditional_frame cframe;

  if (flag_mri)
    stop = mri_comment_field (&stopc);

  s1 = get_mri_string (',', &len1);

  if (*input_line_pointer != ',')
    as_bad (_("bad format for ifc or ifnc"));
  else
    ++input_line_pointer;

  s2 = get_mri_string (';', &len2);

  res = len1 == len2 && strncmp (s1, s2, len1) == 0;

  initialize_cframe (&cframe);
  cframe.ignoring = cframe.dead_tree || ! (res ^ arg);
  current_cframe = ((struct conditional_frame *)
		    obstack_copy (&cond_obstack, &cframe, sizeof (cframe)));

  if (LISTING_SKIP_COND ()
      && cframe.ignoring
      && (cframe.previous_cframe == NULL
	  || ! cframe.previous_cframe->ignoring))
    listing_list (2);

  if (flag_mri)
    mri_comment_end (stop, stopc);

  demand_empty_rest_of_line ();
}

void
s_elseif (int arg)
{
  if (current_cframe == NULL)
    {
      as_bad (_("\".elseif\" without matching \".if\""));
    }
  else if (current_cframe->else_seen)
    {
      as_bad (_("\".elseif\" after \".else\""));
      as_bad_where (current_cframe->else_file_line.file,
		    current_cframe->else_file_line.line,
		    _("here is the previous \".else\""));
      as_bad_where (current_cframe->if_file_line.file,
		    current_cframe->if_file_line.line,
		    _("here is the previous \".if\""));
    }
  else
    {
      as_where (&current_cframe->else_file_line.file,
		&current_cframe->else_file_line.line);

      current_cframe->dead_tree |= !current_cframe->ignoring;
      current_cframe->ignoring = current_cframe->dead_tree;
    }

  if (current_cframe == NULL || current_cframe->ignoring)
    {
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;

      if (current_cframe == NULL)
	return;
    }
  else
    {
      expressionS operand;
      int t;

      /* Leading whitespace is part of operand.  */
      SKIP_WHITESPACE ();

      expression_and_evaluate (&operand);
      if (operand.X_op != O_constant)
	as_bad (_("non-constant expression in \".elseif\" statement"));

      switch ((operatorT) arg)
	{
	case O_eq: t = operand.X_add_number == 0; break;
	case O_ne: t = operand.X_add_number != 0; break;
	case O_lt: t = operand.X_add_number < 0; break;
	case O_le: t = operand.X_add_number <= 0; break;
	case O_ge: t = operand.X_add_number >= 0; break;
	case O_gt: t = operand.X_add_number > 0; break;
	default:
	  abort ();
	  return;
	}

      current_cframe->ignoring = current_cframe->dead_tree || ! t;
    }

  if (LISTING_SKIP_COND ()
      && (current_cframe->previous_cframe == NULL
	  || ! current_cframe->previous_cframe->ignoring))
    {
      if (! current_cframe->ignoring)
	listing_list (1);
      else
	listing_list (2);
    }

  demand_empty_rest_of_line ();
}

void
s_endif (int arg ATTRIBUTE_UNUSED)
{
  struct conditional_frame *hold;

  if (current_cframe == NULL)
    {
      as_bad (_("\".endif\" without \".if\""));
    }
  else
    {
      if (LISTING_SKIP_COND ()
	  && current_cframe->ignoring
	  && (current_cframe->previous_cframe == NULL
	      || ! current_cframe->previous_cframe->ignoring))
	listing_list (1);

      hold = current_cframe;
      current_cframe = current_cframe->previous_cframe;
      obstack_free (&cond_obstack, hold);
    }				/* if one pop too many */

  if (flag_mri)
    {
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
    }

  demand_empty_rest_of_line ();
}

void
s_else (int arg ATTRIBUTE_UNUSED)
{
  if (current_cframe == NULL)
    {
      as_bad (_("\".else\" without matching \".if\""));
    }
  else if (current_cframe->else_seen)
    {
      as_bad (_("duplicate \".else\""));
      as_bad_where (current_cframe->else_file_line.file,
		    current_cframe->else_file_line.line,
		    _("here is the previous \".else\""));
      as_bad_where (current_cframe->if_file_line.file,
		    current_cframe->if_file_line.line,
		    _("here is the previous \".if\""));
    }
  else
    {
      as_where (&current_cframe->else_file_line.file,
		&current_cframe->else_file_line.line);

      current_cframe->ignoring =
	current_cframe->dead_tree | !current_cframe->ignoring;

      if (LISTING_SKIP_COND ()
	  && (current_cframe->previous_cframe == NULL
	      || ! current_cframe->previous_cframe->ignoring))
	{
	  if (! current_cframe->ignoring)
	    listing_list (1);
	  else
	    listing_list (2);
	}

      current_cframe->else_seen = 1;
    }

  if (flag_mri)
    {
      while (! is_end_of_line[(unsigned char) *input_line_pointer])
	++input_line_pointer;
    }

  demand_empty_rest_of_line ();
}

void
s_ifeqs (int arg)
{
  char *s1, *s2;
  int len1, len2;
  int res;
  struct conditional_frame cframe;

  s1 = demand_copy_C_string (&len1);

  SKIP_WHITESPACE ();
  if (*input_line_pointer != ',')
    {
      as_bad (_(".ifeqs syntax error"));
      ignore_rest_of_line ();
      return;
    }

  ++input_line_pointer;

  s2 = demand_copy_C_string (&len2);

  res = len1 == len2 && strncmp (s1, s2, len1) == 0;

  initialize_cframe (&cframe);
  cframe.ignoring = cframe.dead_tree || ! (res ^ arg);
  current_cframe = ((struct conditional_frame *)
		    obstack_copy (&cond_obstack, &cframe, sizeof (cframe)));

  if (LISTING_SKIP_COND ()
      && cframe.ignoring
      && (cframe.previous_cframe == NULL
	  || ! cframe.previous_cframe->ignoring))
    listing_list (2);

  demand_empty_rest_of_line ();
}

int
ignore_input (void)
{
  char *s;

  s = input_line_pointer;

  if (NO_PSEUDO_DOT || flag_m68k_mri)
    {
      if (s[-1] != '.')
	--s;
    }
  else
    {
      if (s[-1] != '.')
	return (current_cframe != NULL) && (current_cframe->ignoring);
    }

  /* We cannot ignore certain pseudo ops.  */
  if (((s[0] == 'i'
	|| s[0] == 'I')
       && (!strncasecmp (s, "if", 2)
	   || !strncasecmp (s, "ifdef", 5)
	   || !strncasecmp (s, "ifndef", 6)))
      || ((s[0] == 'e'
	   || s[0] == 'E')
	  && (!strncasecmp (s, "else", 4)
	      || !strncasecmp (s, "endif", 5)
	      || !strncasecmp (s, "endc", 4))))
    return 0;

  return (current_cframe != NULL) && (current_cframe->ignoring);
}

static void
initialize_cframe (struct conditional_frame *cframe)
{
  memset (cframe, 0, sizeof (*cframe));
  as_where (&cframe->if_file_line.file,
	    &cframe->if_file_line.line);
  cframe->previous_cframe = current_cframe;
  cframe->dead_tree = current_cframe != NULL && current_cframe->ignoring;
  cframe->macro_nest = macro_nest;
}

/* Give an error if a conditional is unterminated inside a macro or
   the assembly as a whole.  If NEST is non negative, we are being
   called because of the end of a macro expansion.  If NEST is
   negative, we are being called at the of the input files.  */

void
cond_finish_check (int nest)
{
  if (current_cframe != NULL && current_cframe->macro_nest >= nest)
    {
      if (nest >= 0)
	as_bad (_("end of macro inside conditional"));
      else
	as_bad (_("end of file inside conditional"));
      as_bad_where (current_cframe->if_file_line.file,
		    current_cframe->if_file_line.line,
		    _("here is the start of the unterminated conditional"));
      if (current_cframe->else_seen)
	as_bad_where (current_cframe->else_file_line.file,
		      current_cframe->else_file_line.line,
		      _("here is the \"else\" of the unterminated conditional"));
    }
}

/* This function is called when we exit out of a macro.  We assume
   that any conditionals which began within the macro are correctly
   nested, and just pop them off the stack.  */

void
cond_exit_macro (int nest)
{
  while (current_cframe != NULL && current_cframe->macro_nest >= nest)
    {
      struct conditional_frame *hold;

      hold = current_cframe;
      current_cframe = current_cframe->previous_cframe;
      obstack_free (&cond_obstack, hold);
    }
}
@


1.22
log
@	* config/tc-m32r.c (md_show_usage): Fix typos in descriptions.
	* config/tc-mt.c (md_assemble): Fix typos in warning messages.
	* cond.c (s_else): Fix typos in error messages.
	* config/tc-pj.c (md_assemble): Fix typo in error message.
@
text
@d94 1
a94 1
  
d194 1
a194 1
  
@


1.21
log
@update copyright dates
@
text
@d314 1
a314 1
		    _("here is the previous \"else\""));
d317 1
a317 1
		    _("here is the previous \"if\""));
d417 1
a417 1
      as_bad (_("duplicate \"else\""));
d420 1
a420 1
		    _("here is the previous \"else\""));
d423 1
a423 1
		    _("here is the previous \"if\""));
@


1.20
log
@Switch to GPLv3
@
text
@d3 1
a3 1
   2003, 2006, 2007 Free Software Foundation, Inc.
@


1.19
log
@remove some duplicate #include's.
@
text
@d3 1
a3 1
   2003, 2006 Free Software Foundation, Inc.
d9 1
a9 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.18
log
@gas/
2005-11-17  Jan Beulich  <jbeulich@@novell.com>


	* symbols.h (S_CLEAR_VOLATILE): Declare.
	* symbols.c (colon): Also accept redefinable symbols for
	redefinition. Clone them before modifying.
	(S_CLEAR_VOLATILE): Define.
	* cond.c (s_ifdef): Also test for equated symbols.
	* read.c (s_comm_internal): Also exclude non-redefinable
	equated symbols. Clone redefinable ones before modifying.
	(s_weakref): Clone redefinable symbols before modifying.
	* doc/internals.texi: Document sy_volatile, sy_forward_ref,
	S_IS_VOLATILE, S_SET_VOLATILE, S_CLEAR_VOLATILE,
	S_IS_FORWARD_REF, and S_SET_FORWARD_REF.

gas/testsuite/
2005-11-17  Jan Beulich  <jbeulich@@novell.com>

	* gas/all/cond.s: Also check ifdef works on equates and
	commons.
	* gas/all/cond.l: Adjust.
	* gas/all/redef2.s: Also test redefining equate to label.
	* gas/all/redef2.d: Adjust.
	* gas/all/redef3.[sd]: New.
	* gas/all/redef4.s: New.
	* gas/all/redef5.s: New.
	* gas/elf/redef.s: New, copied from original gas/all/redef2.s.
	* gas/elf/redef.d: Remove #source.
	* gas/all/gas.exp: Remove exclusion of iq2000-*-* from and
	adjust xfails for redefinition tests. Run new tests. Exclude
	alpha*-*-*, mips*-*-*, *c54x*-*-* from weakref tests.
@
text
@d3 1
a3 1
   2003 Free Software Foundation, Inc.
d23 1
@


1.17
log
@This adjusts equate handling by
- allowing true forward references (which will always assume the referenced
  symbols have at the point of use) through the new .eqv pseudo-op and the
  new == operator
- disallowing changing .equiv-generated equates (so that the protection this
  provides is both forward and backward)
- snapshotting equates when their value gets changed so that previous uses
  don't get affected by the new value.
- allowing expressions in places where absolute expressions (or register
  names) are needed which were not completely resolvable at the point of
  their definition but which are fully resolvable at the point of use

In addition it fixes PR/288.
@
text
@d105 1
a105 1
	&& S_IS_DEFINED (symbolP)
@


1.16
log
@gas/
2005-05-06  Jan Beulich  <jbeulich@@novell.com>

	* cond.c (s_ifb): New.
	* read.c (potable): Add s_ifb as handler for .ifb and .ifnb.
	* read.h (s_ifb): Prototype.
	* doc/as.texinfo: Document .ifb and .ifnb.

gas/testsuite/
2005-05-06  Jan Beulich  <jbeulich@@novell.com>

	* gas/all/cond.s: Also test .ifb/.ifnb.
	* gas/all/cond.d: Adjust.
@
text
@d147 1
a147 1
      expression (&operand);
d343 1
a343 1
      expression (&operand);
@


1.15
log
@Update the address and phone number of the FSF
@
text
@d184 34
@


1.14
log
@update copyright dates
@
text
@d19 2
a20 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.13
log
@	* app.c: Convert to ISO-C.
	* as.h: Likewise.
	* atof-generic.c: Likewise.
	* bignum-copy.c: Likewise.
	* bignum.h: Likewise.
	* cgen.c: Likewise.
	* cgen.h: Likewise.
	* cond.c: Likewise.
@
text
@d2 2
a3 2
   Copyright 1990, 1991, 1992, 1993, 1995, 1997, 1998, 2000, 2001
   Free Software Foundation, Inc.
@


1.12
log
@Make .ifdef treat a referenced but not yet defined symbol as if it were
undefined, in exactly the same way as .equiv.
@
text
@d58 2
a59 2
static void initialize_cframe PARAMS ((struct conditional_frame *cframe));
static char *get_mri_string PARAMS ((int, int *));
d67 1
a67 2
s_ifdef (test_defined)
     int test_defined;
d125 1
a125 2
s_if (arg)
     int arg;
d187 1
a187 3
get_mri_string (terminator, len)
     int terminator;
     int *len;
d227 1
a227 2
s_ifc (arg)
     int arg;
d268 1
a268 2
s_elseif (arg)
     int arg;
d343 1
a343 2
s_endif (arg)
     int arg ATTRIBUTE_UNUSED;
d374 1
a374 2
s_else (arg)
     int arg ATTRIBUTE_UNUSED;
d421 1
a421 2
s_ifeqs (arg)
     int arg;
d459 1
a459 1
ignore_input ()
d493 1
a493 2
initialize_cframe (cframe)
     struct conditional_frame *cframe;
d509 1
a509 2
cond_finish_check (nest)
     int nest;
d532 1
a532 2
cond_exit_macro (nest)
     int nest;
@


1.11
log
@	* read.c: Standardize error/warning messages - don't capitalise, no
	final period or newline, don't say "ignored" or "zero assumed" for
	as_bad messages.  In some cases, change the wording to that used
	elsewhere for similar messages.
	* app.c, as.c, atof-generic.c, cgen.c, cond.c, depend.c, dwarf2dbg.c,
	  ecoff.c, expr.c, frags.c, input-file.c, input-scrub.c, listing.c,
	  output-file.c, stabs.c, subsegs.c, symbols.c, write.c: Likewise.
	* ecoff.c (ecoff_directive_end): Test for missing name by
	comparing input line pointers rather than reading string.
	(ecoff_directive_ent): Likewise.
	* read.c (s_set): Likewise.
	(s_align): Report a warning rather than an error for
	alignment too large.
	(s_comm): Check for missing symbol name.
	(s_lcomm_internal): Likewise.
	(s_lsym): Likewise.
	(s_globl): Use is_end_of_line instead of looking for '\n'.
	(s_lcomm_internal): Likewise.
	(ignore_rest_of_line): Report a warning rather than an error.
@
text
@d63 3
d67 2
a68 2
s_ifdef (arg)
     int arg;
d71 1
a71 1
  register char *name;
d73 1
a73 1
  register symbolS *symbolP;
d75 1
d86 1
d88 9
d99 12
a110 1
      char c;
d112 9
a120 15
      c = get_symbol_end ();
      symbolP = symbol_find (name);
      *input_line_pointer = c;

      initialize_cframe (&cframe);
      cframe.ignoring = cframe.dead_tree || !((symbolP != 0) ^ arg);
      current_cframe = ((struct conditional_frame *)
			obstack_copy (&cond_obstack, &cframe,
				      sizeof (cframe)));

      if (LISTING_SKIP_COND ()
	  && cframe.ignoring
	  && (cframe.previous_cframe == NULL
	      || ! cframe.previous_cframe->ignoring))
	listing_list (2);
d122 1
a122 2
      demand_empty_rest_of_line ();
    }				/* if a valid identifyer name */
@


1.10
log
@Fix conditional assembly listings when more than one .else/.elsif
@
text
@d260 1
a260 1
      as_bad (_("\".elseif\" without matching \".if\" - ignored"));
d264 1
a264 1
      as_bad (_("\".elseif\" after \".else\" - ignored"));
d368 1
a368 1
      as_bad (_(".else without matching .if - ignored"));
d372 1
a372 1
      as_bad (_("duplicate \"else\" - ignored"));
@


1.9
log
@* cond.c (s_endif): Correct handling of "if .. elseif .." trees.
Don't abort on NULL current_cframe.
@
text
@a257 3
  expressionS operand;
  int t;

d277 3
a279 13
      if (!current_cframe->dead_tree)
	{
	  current_cframe->dead_tree = !current_cframe->ignoring;
	  current_cframe->ignoring = !current_cframe->ignoring;
	  if (LISTING_SKIP_COND ())
	    {
	      if (! current_cframe->ignoring)
		listing_list (1);
	      else
		listing_list (2);
	    }
	}			/* if not a dead tree */
    }				/* if error else do it */
d285 3
a287 1
      return;
d289 7
d297 3
a299 2
  /* Leading whitespace is part of operand.  */
  SKIP_WHITESPACE ();
d301 12
a312 3
  expression (&operand);
  if (operand.X_op != O_constant)
    as_bad (_("non-constant expression in \".elseif\" statement"));
d314 1
a314 11
  switch ((operatorT) arg)
    {
    case O_eq: t = operand.X_add_number == 0; break;
    case O_ne: t = operand.X_add_number != 0; break;
    case O_lt: t = operand.X_add_number < 0; break;
    case O_le: t = operand.X_add_number <= 0; break;
    case O_ge: t = operand.X_add_number >= 0; break;
    case O_gt: t = operand.X_add_number > 0; break;
    default:
      abort ();
      return;
a316 2
  current_cframe->ignoring = current_cframe->dead_tree || ! t;

a317 1
      && current_cframe->ignoring
d320 6
a325 1
    listing_list (2);
a368 1

d385 6
a390 1
      if (!current_cframe->dead_tree)
d392 5
a396 9
	  current_cframe->ignoring = !current_cframe->ignoring;
	  if (LISTING_SKIP_COND ())
	    {
	      if (! current_cframe->ignoring)
		listing_list (1);
	      else
		listing_list (2);
	    }
	}			/* if not a dead tree */
d399 1
a399 1
    }				/* if error else do it */
@


1.8
log
@Fix copyright notices
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1995, 1997, 1998, 2000
d50 3
a52 1
  /* Whether a conditional at a higher level is ignoring input.  */
a263 1

d282 1
d294 1
a294 4
  /* Leading whitespace is part of operand.  */
  SKIP_WHITESPACE ();

  if (current_cframe != NULL && current_cframe->ignoring)
a295 1
      operand.X_add_number = 0;
d298 1
d300 7
a306 6
  else
    {
      expression (&operand);
      if (operand.X_op != O_constant)
	as_bad (_("non-constant expression in \".elseif\" statement"));
    }
@


1.7
log
@2000-10-12  Kazu Hirata  <kazu@@hxi.com>

	* app.c: Fix formatting.
	* as.c: Likewise.
	* as.h: Likewise.
	* bit_fix.h: Likewise.
	* cgen.c: Likewise.
	* cgen.h: Likewise.
	* cond.c: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 95, 96, 97, 98, 99, 2000
@


1.7.2.1
log
@* cond.c (s_endif): Correct handling of "if .. elseif .." trees.
Don't abort on NULL current_cframe.
@
text
@d2 1
a2 1
   Copyright 1990, 1991, 1992, 1993, 1995, 1997, 1998, 2000, 2001
d50 1
a50 3
  /* Whether a conditional at a higher level is ignoring input.
     Set also when a branch of an "if .. elseif .." tree has matched
     to prevent further matches.  */
d262 1
a280 1
	  current_cframe->dead_tree = !current_cframe->ignoring;
d292 4
a295 1
  if (current_cframe == NULL || current_cframe->ignoring)
d297 1
a299 1
      return;
d301 6
a306 7

  /* Leading whitespace is part of operand.  */
  SKIP_WHITESPACE ();

  expression (&operand);
  if (operand.X_op != O_constant)
    as_bad (_("non-constant expression in \".elseif\" statement"));
@


1.7.2.2
log
@Fix conditional assembly listings when more than one .else/.elseif
@
text
@d258 3
d280 13
a292 3
      current_cframe->dead_tree |= !current_cframe->ignoring;
      current_cframe->ignoring = current_cframe->dead_tree;
    }
d298 1
a298 3

      if (current_cframe == NULL)
	return;
a299 4
  else
    {
      expressionS operand;
      int t;
d301 2
a302 2
      /* Leading whitespace is part of operand.  */
      SKIP_WHITESPACE ();
d304 3
a306 3
      expression (&operand);
      if (operand.X_op != O_constant)
	as_bad (_("non-constant expression in \".elseif\" statement"));
d308 12
a319 12
      switch ((operatorT) arg)
	{
	case O_eq: t = operand.X_add_number == 0; break;
	case O_ne: t = operand.X_add_number != 0; break;
	case O_lt: t = operand.X_add_number < 0; break;
	case O_le: t = operand.X_add_number <= 0; break;
	case O_ge: t = operand.X_add_number >= 0; break;
	case O_gt: t = operand.X_add_number > 0; break;
	default:
	  abort ();
	  return;
	}
d321 1
a321 2
      current_cframe->ignoring = current_cframe->dead_tree || ! t;
    }
d324 1
d327 1
a327 6
    {
      if (! current_cframe->ignoring)
	listing_list (1);
      else
	listing_list (2);
    }
d371 1
d388 1
a388 6
      current_cframe->ignoring =
	current_cframe->dead_tree | !current_cframe->ignoring;

      if (LISTING_SKIP_COND ()
	  && (current_cframe->previous_cframe == NULL
	      || ! current_cframe->previous_cframe->ignoring))
d390 9
a398 5
	  if (! current_cframe->ignoring)
	    listing_list (1);
	  else
	    listing_list (2);
	}
d401 1
a401 1
    }
@


1.6
log
@2000-08-31  Kazu Hirata  <kazu@@hxi.com>

	* as.c: Fix formatting.
	* cond.c: Likewise.
@
text
@d31 1
a31 2
struct file_line
{
d39 1
a39 2
struct conditional_frame
{
@


1.5
log
@Remove dead code when not TC_M68K.
@
text
@d27 2
a28 1
/* This is allocated to grow and shrink as .ifdef/.endif pairs are scanned. */
d63 1
a63 1
void 
d67 4
a70 2
  register char *name;		/* points to name of symbol */
  register symbolS *symbolP;	/* Points to symbol */
d73 2
a74 1
  SKIP_WHITESPACE ();		/* Leading whitespace is part of operand. */
d105 1
a105 1
}				/* s_ifdef() */
d107 1
a107 1
void 
d120 2
a121 1
  SKIP_WHITESPACE ();		/* Leading whitespace is part of operand. */
d166 1
a166 1
}				/* s_if() */
d254 1
a254 1
void 
d294 2
a295 2

  SKIP_WHITESPACE ();		/* Leading whitespace is part of operand. */
d309 1
a309 1
  
d334 1
a334 1
void 
d364 1
a364 1
}				/* s_endif() */
d366 1
a366 1
void 
d412 1
a412 1
}				/* s_else() */
d414 1
a414 1
void 
d451 1
a451 1
}				/* s_ifeqs() */
d453 1
a453 1
int 
d485 1
a485 1
}				/* ignore_input() */
d487 1
a487 1
static void 
a540 2

/* end of cond.c */
@


1.4
log
@New elseif directive has been added.
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 95, 96, 97, 98, 1999
d455 1
a455 5
  if (flag_m68k_mri
#ifdef NO_PSEUDO_DOT
      || 1
#endif
      )
@


1.3
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Fill in structure initializations.  Add variable
	initializations.  Add casts.
	* dwarf2dbg.c (print_stats): Change i to size_t.
	* listing.c (listing_listing): Change list_line to unsigned int.
@
text
@d250 80
@


1.2
log
@	Add support for storing local symbols in a small structure to save
	memory when assembling large files.
	* as.h: Don't include struc-symbol.h.
	(symbolS): Add typedef.
	* symbols.c: Include struc-symbol.h.
	(local_hash): New static variable.
	(save_symbol_name): New static function, from symbol_create.
	(symbol_create): Call save_symbol_name.
	(local_symbol_count): New static variable.
	(local_symbol_conversion_count): Likewise.
	(LOCAL_SYMBOL_CHECK): Define.
	(local_symbol_make): New static function.
	(local_symbol_convert): New static function.
	(colon): Handle local symbols.  Create local symbol for local
	label name.
	(symbol_table_insert): Handle local symbols.
	(symbol_find_or_make): Create local symbol for local label name.
	(symbol_find_base): Check for local symbol.
	(symbol_append, symbol_insert): Check for local symbols.
	(symbol_clear_list_pointers, symbol_remove): Likewise.
	(verify_symbol_chain): Likewise.
	(copy_symbol_attributes): Likewise.
	(resolve_symbol_value): Handle local symbols.
	(resolve_local_symbol): New static function.
	(resolve_local_symbol_values): New function.
	(S_GET_VALUE, S_SET_VALUE): Handle local symbols.
	(S_IS_FUNCTION, S_IS_EXTERNAL, S_IS_WEAK, S_IS_COMMON): Likewise.
	(S_IS_DEFINED, S_IS_DEBUG, S_IS_LOCAL, S_GET_NAME): Likewise.
	(S_GET_SEGMENT, S_SET_SEGMENT, S_SET_EXTERNAL): Likewise.
	(S_CLEAR_EXTERNAL, S_SET_WEAK, S_SET_NAME): Likewise.
	(symbol_previous, symbol_next): New functions.
	(symbol_get_value_expression): Likewise.
	(symbol_set_value_expression): Likewise.
	(symbol_set_frag, symbol_get_frag): Likewise.
	(symbol_mark_used, symbol_clear_used, symbol_used_p): Likewise.
	(symbol_mark_used_in_reloc): Likewise.
	(symbol_clear_used_in_reloc, symbol_used_in_reloc_p): Likewise.
	(symbol_mark_mri_common, symbol_clear_mri_common): Likewise.
	(symbol_mri_common_p): Likewise.
	(symbol_mark_written, symbol_clear_written): Likewise.
	(symbol_written_p): Likewise.
	(symbol_mark_resolved, symbol_resolved_p): Likewise.
	(symbol_section_p, symbol_equated_p): Likewise.
	(symbol_constant_p): Likewise.
	(symbol_get_bfdsym, symbol_set_bfdsym): Likewise.
	(symbol_get_obj, symbol_set_obj): Likewise.
	(symbol_get_tc, symbol_set_tc): Likewise.
	(symbol_begin): Initialize local_hash.
	(print_symbol_value_1): Handle local symbols.
	(symbol_print_statistics): Print local symbol statistics.
	* symbols.h: Include "struc-symbol.h" if not BFD_ASSEMBLER.
	Declare new symbols.c functions.  Move many declarations here from
	struc-symbol.h.
	(SYMBOLS_NEED_BACKPOINTERS): Define if needed.
	* struc-symbol.h (SYMBOLS_NEED_BACKPOINTERS): Don't set.
	(struct symbol): Move bsym to make it clearly the first field.
	Remove TARGET_SYMBOL_FIELDS.
	(symbolS): Don't typedef.
	(struct broken_word): Remove.
	(N_TYPE_seg, seg_N_TYPE): Move to symbol.h.
	(SEGMENT_TO_SYMBOL_TYPE, N_REGISTER): Likewise.
	(symbol_clear_list_pointers): Likewise.
	(symbol_insert, symbol_remove): Likewise.
	(symbol_previous, symbol_append): Likewise.
	(verify_symbol_chain, verify_symbol_chain_2): Likewise.
	(struct local_symbol): Define.
	(local_symbol_converted_p, local_symbol_mark_converted): Define.
	(local_symbol_resolved_p, local_symbol_mark_resolved): Define.
	(local_symbol_get_frag, local_symbol_set_frag): Define.
	(local_symbol_get_real_symbol): Define.
	(local_symbol_set_real_symbol): Define.
	Define.
	* write.c (write_object_file): Call resolve_local_symbol_values.
	* config/obj-ecoff.h (OBJ_SYMFIELD_TYPE): Define.
	(TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-elf.h (OBJ_SYMFIELD_TYPE): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-multi.h (struct elf_obj_sy): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	(ECOFF_DEBUG_TARGET_SYMBOL_FIELDS): Don't define.
	* config/tc-mcore.h: Don't include struc-symbol.h.
	(TARGET_SYMBOL_FIELDS): Don't define.
	(struct mcore_tc_sy): Define.
	(TC_SYMFIELD_TYPE): Define.
	* Many files: Use symbolS instead of struct symbol.  Use new
	accessor functions rather than referring to symbolS fields
	directly.
	* read.c (s_mri_common): Don't add in value of line_label.
	* config/tc-mips.c (md_apply_fix): Correct parenthesization when
	checking for SEC_LINK_ONCE.
	* config/tc-sh.h (sh_fix_adjustable): Declare.
@
text
@d251 1
a251 1
     int arg;
d283 1
a283 1
     int arg;
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1990, 91, 92, 93, 95, 96, 97, 1998
d67 1
a67 1
  register struct symbol *symbolP;	/* Points to symbol */
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

