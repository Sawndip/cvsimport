head	1.33;
access;
symbols
	binutils-2_24-branch:1.33.0.2
	binutils-2_24-branchpoint:1.33
	binutils-2_21_1:1.26
	binutils-2_23_2:1.32.2.1
	binutils-2_23_1:1.32.2.1
	binutils-2_23:1.32.2.1
	binutils-2_23-branch:1.32.0.2
	binutils-2_23-branchpoint:1.32
	binutils-2_22_branch:1.30.2.1.0.2
	binutils-2_22:1.30.2.1
	binutils-2_22-branch:1.30.0.2
	binutils-2_22-branchpoint:1.30
	binutils-2_21:1.26
	binutils-2_21-branch:1.26.0.2
	binutils-2_21-branchpoint:1.26
	binutils-2_20_1:1.25.2.1
	binutils-2_20:1.25.2.1
	binutils-arc-20081103-branch:1.23.0.4
	binutils-arc-20081103-branchpoint:1.23
	binutils-2_20-branch:1.25.0.2
	binutils-2_20-branchpoint:1.25
	dje-cgen-play1-branch:1.24.0.2
	dje-cgen-play1-branchpoint:1.24
	arc-20081103-branch:1.23.0.2
	arc-20081103-branchpoint:1.23
	binutils-2_19_1:1.22
	binutils-2_19:1.22
	binutils-2_19-branch:1.22.0.4
	binutils-2_19-branchpoint:1.22
	binutils-2_18:1.22
	binutils-2_18-branch:1.22.0.2
	binutils-2_18-branchpoint:1.22
	binutils-csl-coldfire-4_1-32:1.18.2.1
	binutils-csl-sourcerygxx-4_1-32:1.18.2.1
	binutils-csl-innovasic-fido-3_4_4-33:1.18.2.1
	binutils-csl-sourcerygxx-3_4_4-32:1.16
	binutils-csl-coldfire-4_1-30:1.18.2.1
	binutils-csl-sourcerygxx-4_1-30:1.18.2.1
	binutils-csl-coldfire-4_1-28:1.18.2.1
	binutils-csl-sourcerygxx-4_1-29:1.18.2.1
	binutils-csl-sourcerygxx-4_1-28:1.18.2.1
	binutils-csl-arm-2006q3-27:1.18.2.1
	binutils-csl-sourcerygxx-4_1-27:1.18.2.1
	binutils-csl-arm-2006q3-26:1.18.2.1
	binutils-csl-sourcerygxx-4_1-26:1.18.2.1
	binutils-csl-sourcerygxx-4_1-25:1.18.2.1
	binutils-csl-sourcerygxx-4_1-24:1.18.2.1
	binutils-csl-sourcerygxx-4_1-23:1.18.2.1
	binutils-csl-sourcerygxx-4_1-21:1.18.2.1
	binutils-csl-arm-2006q3-21:1.18.2.1
	binutils-csl-sourcerygxx-4_1-22:1.18.2.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.18.2.1
	binutils-csl-sourcerygxx-4_1-20:1.18.2.1
	binutils-csl-arm-2006q3-19:1.18.2.1
	binutils-csl-sourcerygxx-4_1-19:1.18.2.1
	binutils-csl-sourcerygxx-4_1-18:1.18.2.1
	binutils-csl-renesas-4_1-9:1.18.2.1
	binutils-csl-sourcerygxx-3_4_4-25:1.16
	binutils-csl-renesas-4_1-8:1.18
	binutils-csl-renesas-4_1-7:1.18
	binutils-csl-renesas-4_1-6:1.18
	binutils-csl-sourcerygxx-4_1-17:1.18
	binutils-csl-sourcerygxx-4_1-14:1.18
	binutils-csl-sourcerygxx-4_1-15:1.18
	binutils-csl-sourcerygxx-4_1-13:1.18
	binutils-2_17:1.20
	binutils-csl-sourcerygxx-4_1-12:1.18
	binutils-csl-sourcerygxx-3_4_4-21:1.18
	binutils-csl-wrs-linux-3_4_4-24:1.16
	binutils-csl-wrs-linux-3_4_4-23:1.16
	binutils-csl-sourcerygxx-4_1-9:1.18
	binutils-csl-sourcerygxx-4_1-8:1.18
	binutils-csl-sourcerygxx-4_1-7:1.18
	binutils-csl-arm-2006q1-6:1.18
	binutils-csl-sourcerygxx-4_1-6:1.18
	binutils-csl-wrs-linux-3_4_4-22:1.16
	binutils-csl-coldfire-4_1-11:1.18
	binutils-csl-sourcerygxx-3_4_4-19:1.18
	binutils-csl-coldfire-4_1-10:1.18
	binutils-csl-sourcerygxx-4_1-5:1.18
	binutils-csl-sourcerygxx-4_1-4:1.18
	binutils-csl-wrs-linux-3_4_4-21:1.16
	binutils-csl-morpho-4_1-4:1.18
	binutils-csl-sourcerygxx-3_4_4-17:1.18
	binutils-csl-wrs-linux-3_4_4-20:1.16
	binutils-2_17-branch:1.20.0.2
	binutils-2_17-branchpoint:1.20
	binutils-csl-2_17-branch:1.18.0.2
	binutils-csl-2_17-branchpoint:1.18
	binutils-csl-gxxpro-3_4-branch:1.16.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.16
	binutils-2_16_1:1.16
	binutils-csl-arm-2005q1b:1.16
	binutils-2_16:1.16
	binutils-csl-arm-2005q1a:1.16
	binutils-csl-arm-2005q1-branch:1.16.0.4
	binutils-csl-arm-2005q1-branchpoint:1.16
	binutils-2_16-branch:1.16.0.2
	binutils-2_16-branchpoint:1.16
	csl-arm-2004-q3d:1.15
	csl-arm-2004-q3:1.15
	binutils-2_15:1.15
	binutils-2_15-branchpoint:1.15
	csl-arm-2004-q1a:1.15
	csl-arm-2004-q1:1.15
	binutils-2_15-branch:1.15.0.4
	cagney_bfdfile-20040213-branch:1.15.0.2
	cagney_bfdfile-20040213-branchpoint:1.15
	cagney_bigcore-20040122-branch:1.14.0.2
	cagney_bigcore-20040122-branchpoint:1.14
	csl-arm-2003-q4:1.14
	binutils-2_14:1.12
	binutils-2_14-branch:1.12.0.6
	binutils-2_14-branchpoint:1.12
	binutils-2_13_2_1:1.12
	binutils-2_13_2:1.12
	binutils-2_13_1:1.12
	binutils-2_13:1.12
	binutils-2_13-branchpoint:1.12
	binutils-2_13-branch:1.12.0.4
	binutils-2_12_1:1.12
	binutils-2_12:1.12
	binutils-2_12-branch:1.12.0.2
	binutils-2_12-branchpoint:1.12
	cygnus_cvs_20020108_pre:1.12
	binutils-2_11_2:1.8.2.1
	binutils-2_11_1:1.8.2.1
	binutils-2_11:1.8
	x86_64versiong3:1.8
	binutils-2_11-branch:1.8.0.2
	binutils-2_10_1:1.2.2.1
	binutils-2_10:1.2.2.1
	binutils-2_10-branch:1.2.0.2
	binutils-2_10-branchpoint:1.2
	binutils_latest_snapshot:1.33
	repo-unification-2000-02-06:1.2
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.33
date	2012.08.03.22.23.44;	author macro;	state Exp;
branches;
next	1.32;

1.32
date	2012.06.30.00.27.31;	author amodra;	state Exp;
branches
	1.32.2.1;
next	1.31;

1.31
date	2011.10.12.21.07.07;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2011.08.01.08.05.49;	author gingold;	state Exp;
branches
	1.30.2.1;
next	1.29;

1.29
date	2011.07.29.07.34.14;	author gingold;	state Exp;
branches;
next	1.28;

1.28
date	2011.07.27.06.54.12;	author gingold;	state Exp;
branches;
next	1.27;

1.27
date	2011.07.25.13.34.40;	author gingold;	state Exp;
branches;
next	1.26;

1.26
date	2009.09.11.15.27.33;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2009.09.02.07.24.19;	author amodra;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2009.06.22.17.56.00;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2008.10.21.00.26.17;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2007.07.03.11.01.03;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2006.04.18.09.58.26;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2006.04.06.04.38.33;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2006.04.04.08.04.57;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.10.15.10.04;	author matz;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2005.05.05.09.12.45;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2005.03.03.01.29.53;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2004.01.23.12.52.19;	author rsandifo;	state Exp;
branches;
next	1.14;

1.14
date	2003.11.22.16.03.03;	author kazu;	state Exp;
branches;
next	1.13;

1.13
date	2003.07.15.01.33.54;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.15.09.16.46;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.14.17.43.32;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2001.08.01.01.44.25;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.08.23.24.22;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2000.12.28.10.07.55;	author rth;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.08.31.18.36.18;	author kazu;	state Exp;
branches;
next	1.6;

1.6
date	2000.07.22.04.23.48;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.23.05.07.47;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2000.05.23.04.48.21;	author amodra;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.02.00.12.48;	author amodra;	state Exp;
branches;
next	1.2;

1.2
date	2000.02.03.18.20.23;	author twall;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	99.05.03.07.28.40;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.32.2.1
date	2012.09.04.14.37.55;	author gingold;	state Exp;
branches;
next	;

1.30.2.1
date	2011.10.25.03.06.33;	author amodra;	state Exp;
branches;
next	;

1.25.2.1
date	2009.09.11.15.28.43;	author nickc;	state Exp;
branches;
next	;

1.18.2.1
date	2006.08.22.15.08.31;	author jsm28;	state Exp;
branches;
next	;

1.8.2.1
date	2001.06.07.03.15.24;	author amodra;	state Exp;
branches;
next	;

1.2.2.1
date	2000.05.23.05.04.29;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.40;	author rth;	state Exp;
branches;
next	;


desc
@@


1.33
log
@	* frags.c (frag_grow): Never shrink the obstack size requested
	below the default.
@
text
@/* frags.c - manage frags -
   Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2001, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2011, 2012
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include "as.h"
#include "subsegs.h"
#include "obstack.h"

extern fragS zero_address_frag;
extern fragS predefined_address_frag;

/* Initialization for frag routines.  */

void
frag_init (void)
{
  zero_address_frag.fr_type = rs_fill;
  predefined_address_frag.fr_type = rs_fill;
}

/* Check that we're not trying to assemble into a section that can't
   allocate frags (currently, this is only possible in the absolute
   section), or into an mri common.  */

static void
frag_alloc_check (const struct obstack *ob)
{
  if (ob->chunk_size == 0)
    {
      as_bad (_("attempt to allocate data in absolute section"));
      subseg_set (text_section, 0);
    }

  if (mri_common_symbol != NULL)
    {
      as_bad (_("attempt to allocate data in common section"));
      mri_common_symbol = NULL;
    }
}

/* Allocate a frag on the specified obstack.
   Call this routine from everywhere else, so that all the weird alignment
   hackery can be done in just one place.  */

fragS *
frag_alloc (struct obstack *ob)
{
  fragS *ptr;
  int oalign;

  (void) obstack_alloc (ob, 0);
  oalign = obstack_alignment_mask (ob);
  obstack_alignment_mask (ob) = 0;
  ptr = (fragS *) obstack_alloc (ob, SIZEOF_STRUCT_FRAG);
  obstack_alignment_mask (ob) = oalign;
  memset (ptr, 0, SIZEOF_STRUCT_FRAG);
  return ptr;
}

/* Try to augment current frag by nchars chars.
   If there is no room, close of the current frag with a ".fill 0"
   and begin a new frag. Unless the new frag has nchars chars available
   do not return. Do not set up any fields of *now_frag.  */

void
frag_grow (unsigned int nchars)
{
  if (obstack_room (&frchain_now->frch_obstack) < nchars)
    {
      long oldc;
      long newc;

      /* Try to allocate a bit more than needed right now.  But don't do
         this if we would waste too much memory.  Especially necessary
         for extremely big (like 2GB initialized) frags.  */
      if (nchars < 0x10000)
        newc = 2 * nchars;
      else
        newc = nchars + 0x10000;
      newc += SIZEOF_STRUCT_FRAG;

      /* Check for possible overflow.  */
      if (newc < 0)
        as_fatal (_("can't extend frag %u chars"), nchars);

      /* Force to allocate at least NEWC bytes, but not less than the
         default.  */
      oldc = obstack_chunk_size (&frchain_now->frch_obstack);
      if (newc > oldc)
	obstack_chunk_size (&frchain_now->frch_obstack) = newc;

      while (obstack_room (&frchain_now->frch_obstack) < nchars)
        {
          /* Not enough room in this frag.  Close it and start a new one.
             This must be done in a loop because the created frag may not
             be big enough if the current obstack chunk is used.  */
          frag_wane (frag_now);
          frag_new (0);
        }

      /* Restore the old chunk size.  */
      obstack_chunk_size (&frchain_now->frch_obstack) = oldc;
    }
}

/* Call this to close off a completed frag, and start up a new (empty)
   frag, in the same subsegment as the old frag.
   [frchain_now remains the same but frag_now is updated.]
   Because this calculates the correct value of fr_fix by
   looking at the obstack 'frags', it needs to know how many
   characters at the end of the old frag belong to the maximal
   variable part;  The rest must belong to fr_fix.
   It doesn't actually set up the old frag's fr_var.  You may have
   set fr_var == 1, but allocated 10 chars to the end of the frag;
   In this case you pass old_frags_var_max_size == 10.
   In fact, you may use fr_var for something totally unrelated to the
   size of the variable part of the frag;  None of the generic frag
   handling code makes use of fr_var.

   Make a new frag, initialising some components. Link new frag at end
   of frchain_now.  */

void
frag_new (int old_frags_var_max_size
	  /* Number of chars (already allocated on obstack frags) in
	     variable_length part of frag.  */)
{
  fragS *former_last_fragP;
  frchainS *frchP;

  gas_assert (frchain_now->frch_last == frag_now);

  /* Fix up old frag's fr_fix.  */
  frag_now->fr_fix = frag_now_fix_octets () - old_frags_var_max_size;
  /* Make sure its type is valid.  */
  gas_assert (frag_now->fr_type != 0);

  /* This will align the obstack so the next struct we allocate on it
     will begin at a correct boundary.  */
  obstack_finish (&frchain_now->frch_obstack);
  frchP = frchain_now;
  know (frchP);
  former_last_fragP = frchP->frch_last;
  gas_assert (former_last_fragP != 0);
  gas_assert (former_last_fragP == frag_now);
  frag_now = frag_alloc (&frchP->frch_obstack);

  as_where (&frag_now->fr_file, &frag_now->fr_line);

  /* Generally, frag_now->points to an address rounded up to next
     alignment.  However, characters will add to obstack frags
     IMMEDIATELY after the struct frag, even if they are not starting
     at an alignment address.  */
  former_last_fragP->fr_next = frag_now;
  frchP->frch_last = frag_now;

#ifndef NO_LISTING
  {
    extern struct list_info_struct *listing_tail;
    frag_now->line = listing_tail;
  }
#endif

  gas_assert (frchain_now->frch_last == frag_now);

  frag_now->fr_next = NULL;
}

/* Start a new frag unless we have n more chars of room in the current frag.
   Close off the old frag with a .fill 0.

   Return the address of the 1st char to write into. Advance
   frag_now_growth past the new chars.  */

char *
frag_more (int nchars)
{
  register char *retval;

  frag_alloc_check (&frchain_now->frch_obstack);
  frag_grow (nchars);
  retval = obstack_next_free (&frchain_now->frch_obstack);
  obstack_blank_fast (&frchain_now->frch_obstack, nchars);
  return (retval);
}

/* Close the current frag, setting its fields for a relaxable frag.  Start a
   new frag.  */

static void
frag_var_init (relax_stateT type, int max_chars, int var,
               relax_substateT subtype, symbolS *symbol, offsetT offset,
               char *opcode)
{
  frag_now->fr_var = var;
  frag_now->fr_type = type;
  frag_now->fr_subtype = subtype;
  frag_now->fr_symbol = symbol;
  frag_now->fr_offset = offset;
  frag_now->fr_opcode = opcode;
#ifdef USING_CGEN
  frag_now->fr_cgen.insn = 0;
  frag_now->fr_cgen.opindex = 0;
  frag_now->fr_cgen.opinfo = 0;
#endif
#ifdef TC_FRAG_INIT
  TC_FRAG_INIT (frag_now);
#endif
  as_where (&frag_now->fr_file, &frag_now->fr_line);

  frag_new (max_chars);
}

/* Start a new frag unless we have max_chars more chars of room in the
   current frag.  Close off the old frag with a .fill 0.

   Set up a machine_dependent relaxable frag, then start a new frag.
   Return the address of the 1st char of the var part of the old frag
   to write into.  */

char *
frag_var (relax_stateT type, int max_chars, int var, relax_substateT subtype,
	  symbolS *symbol, offsetT offset, char *opcode)
{
  register char *retval;

  frag_grow (max_chars);
  retval = obstack_next_free (&frchain_now->frch_obstack);
  obstack_blank_fast (&frchain_now->frch_obstack, max_chars);
  frag_var_init (type, max_chars, var, subtype, symbol, offset, opcode);
  return retval;
}

/* OVE: This variant of frag_var assumes that space for the tail has been
	allocated by caller.
	No call to frag_grow is done.  */

char *
frag_variant (relax_stateT type, int max_chars, int var,
	      relax_substateT subtype, symbolS *symbol, offsetT offset,
	      char *opcode)
{
  register char *retval;

  retval = obstack_next_free (&frchain_now->frch_obstack);
  frag_var_init (type, max_chars, var, subtype, symbol, offset, opcode);

  return retval;
}

/* Reduce the variable end of a frag to a harmless state.  */

void
frag_wane (register fragS *fragP)
{
  fragP->fr_type = rs_fill;
  fragP->fr_offset = 0;
  fragP->fr_var = 0;
}

/* Return the number of bytes by which the current frag can be grown.  */

int
frag_room (void)
{
  return obstack_room (&frchain_now->frch_obstack);
}

/* Make an alignment frag.  The size of this frag will be adjusted to
   force the next frag to have the appropriate alignment.  ALIGNMENT
   is the power of two to which to align.  FILL_CHARACTER is the
   character to use to fill in any bytes which are skipped.  MAX is
   the maximum number of characters to skip when doing the alignment,
   or 0 if there is no maximum.  */

void
frag_align (int alignment, int fill_character, int max)
{
  if (now_seg == absolute_section)
    {
      addressT new_off;
      addressT mask;

      mask = (~(addressT) 0) << alignment;
      new_off = (abs_section_offset + ~mask) & mask;
      if (max == 0 || new_off - abs_section_offset <= (addressT) max)
	abs_section_offset = new_off;
    }
  else
    {
      char *p;

      p = frag_var (rs_align, 1, 1, (relax_substateT) max,
		    (symbolS *) 0, (offsetT) alignment, (char *) 0);
      *p = fill_character;
    }
}

/* Make an alignment frag like frag_align, but fill with a repeating
   pattern rather than a single byte.  ALIGNMENT is the power of two
   to which to align.  FILL_PATTERN is the fill pattern to repeat in
   the bytes which are skipped.  N_FILL is the number of bytes in
   FILL_PATTERN.  MAX is the maximum number of characters to skip when
   doing the alignment, or 0 if there is no maximum.  */

void
frag_align_pattern (int alignment, const char *fill_pattern,
		    int n_fill, int max)
{
  char *p;

  p = frag_var (rs_align, n_fill, n_fill, (relax_substateT) max,
		(symbolS *) 0, (offsetT) alignment, (char *) 0);
  memcpy (p, fill_pattern, n_fill);
}

/* The NOP_OPCODE is for the alignment fill value.  Fill it with a nop
   instruction so that the disassembler does not choke on it.  */
#ifndef NOP_OPCODE
#define NOP_OPCODE 0x00
#endif

/* Use this to restrict the amount of memory allocated for representing
   the alignment code.  Needs to be large enough to hold any fixed sized
   prologue plus the replicating portion.  */
#ifndef MAX_MEM_FOR_RS_ALIGN_CODE
  /* Assume that if HANDLE_ALIGN is not defined then no special action
     is required to code fill, which means that we get just repeat the
     one NOP_OPCODE byte.  */
# ifndef HANDLE_ALIGN
#  define MAX_MEM_FOR_RS_ALIGN_CODE  1
# else
#  define MAX_MEM_FOR_RS_ALIGN_CODE  ((1 << alignment) - 1)
# endif
#endif

void
frag_align_code (int alignment, int max)
{
  char *p;

  p = frag_var (rs_align_code, MAX_MEM_FOR_RS_ALIGN_CODE, 1,
		(relax_substateT) max, (symbolS *) 0,
		(offsetT) alignment, (char *) 0);
  *p = NOP_OPCODE;
}

addressT
frag_now_fix_octets (void)
{
  if (now_seg == absolute_section)
    return abs_section_offset;

  return ((char *) obstack_next_free (&frchain_now->frch_obstack)
	  - frag_now->fr_literal);
}

addressT
frag_now_fix (void)
{
  return frag_now_fix_octets () / OCTETS_PER_BYTE;
}

void
frag_append_1_char (int datum)
{
  frag_alloc_check (&frchain_now->frch_obstack);
  if (obstack_room (&frchain_now->frch_obstack) <= 1)
    {
      frag_wane (frag_now);
      frag_new (0);
    }
  obstack_1grow (&frchain_now->frch_obstack, datum);
}

/* Return TRUE if FRAG1 and FRAG2 have a fixed relationship between
   their start addresses.  Set OFFSET to the difference in address
   not already accounted for in the frag FR_ADDRESS.  */

bfd_boolean
frag_offset_fixed_p (const fragS *frag1, const fragS *frag2, offsetT *offset)
{
  const fragS *frag;
  offsetT off;

  /* Start with offset initialised to difference between the two frags.
     Prior to assigning frag addresses this will be zero.  */
  off = frag1->fr_address - frag2->fr_address;
  if (frag1 == frag2)
    {
      *offset = off;
      return TRUE;
    }

  /* Maybe frag2 is after frag1.  */
  frag = frag1;
  while (frag->fr_type == rs_fill)
    {
      off += frag->fr_fix + frag->fr_offset * frag->fr_var;
      frag = frag->fr_next;
      if (frag == NULL)
	break;
      if (frag == frag2)
	{
	  *offset = off;
	  return TRUE;
	}
    }

  /* Maybe frag1 is after frag2.  */
  off = frag1->fr_address - frag2->fr_address;
  frag = frag2;
  while (frag->fr_type == rs_fill)
    {
      off -= frag->fr_fix + frag->fr_offset * frag->fr_var;
      frag = frag->fr_next;
      if (frag == NULL)
	break;
      if (frag == frag1)
	{
	  *offset = off;
	  return TRUE;
	}
    }

  return FALSE;
}
@


1.32
log
@	* frags.h (frag_offset_fixed_p): Update prototype.
	* frags.c (frag_offset_fixed_p): Change type of "offset" to offsetT.
	* expr.c (expr, resolve_expression): Likewise for frag_off var.
@
text
@d104 2
a105 1
      /* Force to allocate at least NEWC bytes.  */
d107 2
a108 1
      obstack_chunk_size (&frchain_now->frch_obstack) = newc;
@


1.32.2.1
log
@bfd/
2012-08-09  Maciej W. Rozycki  <macro@@codesourcery.com>

	* elfxx-mips.c (LA25_LUI_MICROMIPS_1, LA25_LUI_MICROMIPS_2):
	Remove macros, folding them into...
	(LA25_LUI_MICROMIPS): ... this new macro.
	(LA25_J_MICROMIPS_1, LA25_J_MICROMIPS_2): Likewise into...
	(LA25_J_MICROMIPS): ... this new macro.
	(LA25_ADDIU_MICROMIPS_1, LA25_ADDIU_MICROMIPS_2): Likewise
	into...
	(LA25_ADDIU_MICROMIPS): ... this new macro.
	(bfd_put_micromips_32, bfd_get_micromips_32): New functions.
	(mips_elf_create_la25_stub): Use them.
	(check_br32_dslot, check_br32, check_relocated_bzc): Likewise.
	(_bfd_mips_elf_relax_section): Likewise.

gas/
	* config/tc-mips.c (NO_ISA_COP, COP_INSN): Remove macros.
	(is_opcode_valid): Remove coprocessor instruction exclusions.
	Replace OPCODE_IS_MEMBER with opcode_is_member.
	(is_opcode_valid_16): Replace OPCODE_IS_MEMBER with
	opcode_is_member.
	(macro): Remove coprocessor instruction exclusions.

gas/
	* gas/mips/mips.exp: Set has_newabi for all Linux targets.
	* gas/mips/cfi-n64-1.d: Adjust for targets that do not infer the
	ISA from the ABI.
	* gas/mips/elf-rel-got-n32.d: Likewise.
	* gas/mips/elf-rel-got-n64.d: Likewise.
	* gas/mips/elf-rel-xgot-n32.d: Likewise.
	* gas/mips/elf-rel-xgot-n64.d: Likewise.
	* gas/mips/elf-rel18.d: Likewise.
	* gas/mips/elf-rel28-n32.d: Likewise.
	* gas/mips/elf-rel28-n64.d: Likewise.
	* gas/mips/jal-newabi.d: Likewise.
	* gas/mips/ldstla-n64-shared.d: Likewise.
	* gas/mips/ldstla-n64-sym32.d: Likewise.
	* gas/mips/ldstla-n64.d: Likewise.
	* gas/mips/macro-warn-1-n32.d: Likewise.
	* gas/mips/macro-warn-2-n32.d: Likewise.
	* gas/mips/n32-consec.d: Likewise.

include/
2012-08-13  Richard Sandiford  <rdsandiford@@googlemail.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips.h (mips_opcode): Add the exclusions field.
	(OPCODE_IS_MEMBER): Remove macro.
	(cpu_is_member): New inline function.
	(opcode_is_member): Likewise.

ld/
	* emulparams/elf32bmip.sh: Make _gp hidden.
	* emulparams/elf32bmipn32-defs.sh: Likewise.
	* emulparams/elf32mipswindiss.sh: Likewise.
	* scripttempl/mips.sc: Likewise.

ld/
2012-08-28  Maciej W. Rozycki  <macro@@codesourcery.com>

	* ld-elf/export-class.sd: New test.
	* ld-elf/export-class.vd: New test.
	* ld-elf/export-class-def.s: New test source.
	* ld-elf/export-class-dep.s: New test source.
	* ld-elf/export-class-lib.s: New test source.
	* ld-elf/export-class-ref.s: New test source.
	* ld-elf/export-class-lib.ver: New test version script.
	* ld-elf/export-class.exp: New test script.
	* ld-arm/arm-export-class.rd: New test.
	* ld-arm/arm-export-class.xd: New test.
	* ld-arm/export-class.exp: New test script.
	* ld-i386/i386-export-class.rd: New test.
	* ld-i386/i386-export-class.xd: New test.
	* ld-i386/export-class.exp: New test script.
	* ld-mips-elf/mips-32-export-class.rd: New test.
	* ld-mips-elf/mips-32-export-class.xd: New test.
	* ld-mips-elf/mips-64-export-class.rd: New test.
	* ld-mips-elf/mips-64-export-class.xd: New test.
	* ld-mips-elf/export-class.exp: New test script.
	* ld-powerpc/powerpc-32-export-class.rd: New test.
	* ld-powerpc/powerpc-32-export-class.xd: New test.
	* ld-powerpc/powerpc-64-export-class.rd: New test.
	* ld-powerpc/powerpc-64-export-class.xd: New test.
	* ld-powerpc/export-class.exp: New test script.
	* ld-x86-64/x86-64-64-export-class.rd: New test.
	* ld-x86-64/x86-64-x32-export-class.rd: New test.
	* ld-x86-64/export-class.exp: New test script.

opcodes/
2012-08-14  Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips-dis.c (print_insn_args): Add GET_OP and GET_OP_S local
	macros, use local variables for info struct member accesses,
	update the type of the variable used to hold the instruction
	word.
	(print_insn_mips, print_mips16_insn_arg): Likewise.
	(print_insn_mips16): Add GET_OP and GET_OP_S local macros, use
	local variables for info struct member accesses.
	(print_insn_micromips): Add GET_OP_S local macro.
	(_print_insn_mips): Update the type of the variable used to hold
	the instruction word.
@
text
@d104 1
a104 2
      /* Force to allocate at least NEWC bytes, but not less than the
         default.  */
d106 1
a106 2
      if (newc > oldc)
	obstack_chunk_size (&frchain_now->frch_obstack) = newc;
@


1.31
log
@	* as.c (main): Define .gasversion. rather than __GAS_VERSION__.
	* frags.h (bss_address_frag): Delete
	(predefined_address_frag): New.
	* frags.c (frag_init): Init predefined_address_frag.  Delete ref
	to bss_addres_frag.
	* symbols.c (S_CAN_BE_REDEFINED): New function.
	* symbols.h (S_CAN_BE_REDEFINED): Declare.
	* read.c (assign_symbol): Use S_CAN_BE_REDEFINED.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2003, 2004, 2005, 2006, 2007, 2008, 2009
d397 1
a397 1
frag_offset_fixed_p (const fragS *frag1, const fragS *frag2, bfd_vma *offset)
d400 1
a400 1
  bfd_vma off;
@


1.30
log
@2011-08-01  Tristan Gingold  <gingold@@adacore.com>

	* frags.c (frag_grow): Simplify the code.
@
text
@d28 1
a28 1
extern fragS bss_address_frag;
d36 1
a36 1
  bss_address_frag.fr_type = rs_fill;
@


1.30.2.1
log
@	2011-10-13  Alan Modra  <amodra@@gmail.com>
	* as.c (main): Define .gasversion. rather than __GAS_VERSION__.
	* frags.h (bss_address_frag): Delete
	(predefined_address_frag): New.
	* frags.c (frag_init): Init predefined_address_frag.  Delete ref
	to bss_address_frag.
	* symbols.c (S_CAN_BE_REDEFINED): New function.
	* symbols.h (S_CAN_BE_REDEFINED): Declare.
	* read.c (assign_symbol): Use S_CAN_BE_REDEFINED.

	2011-10-12  Alan Modra  <amodra@@gmail.com>
	* symbols.c (local_symbol_make): Make global.
	* symbols.h (local_symbol_make): Declare.
	* as.c (main): Define __GAS_VERSION__.
@
text
@d28 1
a28 1
extern fragS predefined_address_frag;
d36 1
a36 1
  predefined_address_frag.fr_type = rs_fill;
@


1.29
log
@2011-07-29  Tristan Gingold  <gingold@@adacore.com>

	* frags.c (frag_var_init): New function.
	(frag_var): Call frag_var_init to initialize.
	(frag_variant): Ditto.
@
text
@a87 1
      unsigned int n;
d89 1
a90 3
      frag_wane (frag_now);
      frag_new (0);
      oldc = frchain_now->frch_obstack.chunk_size;
d93 1
a93 1
	 for extremely big (like 2GB initialized) frags.  */
d95 1
a95 1
	frchain_now->frch_obstack.chunk_size = 2 * nchars;
d97 22
a118 10
        frchain_now->frch_obstack.chunk_size = nchars + 0x10000;
      frchain_now->frch_obstack.chunk_size += SIZEOF_STRUCT_FRAG;
      if (frchain_now->frch_obstack.chunk_size > 0)
	while ((n = obstack_room (&frchain_now->frch_obstack)) < nchars
	       && (unsigned long) frchain_now->frch_obstack.chunk_size > nchars)
	  {
	    frag_wane (frag_now);
	    frag_new (0);
	  }
      frchain_now->frch_obstack.chunk_size = oldc;
a119 2
  if (obstack_room (&frchain_now->frch_obstack) < nchars)
    as_fatal (_("can't extend frag %u chars"), nchars);
@


1.28
log
@2011-07-27  Tristan Gingold  <gingold@@adacore.com>

	* frags.c (frag_grow): Revert previous patch.
@
text
@d196 2
a197 2
/* Start a new frag unless we have max_chars more chars of room in the
   current frag.  Close off the old frag with a .fill 0.
d199 4
a202 7
   Set up a machine_dependent relaxable frag, then start a new frag.
   Return the address of the 1st char of the var part of the old frag
   to write into.  */

char *
frag_var (relax_stateT type, int max_chars, int var, relax_substateT subtype,
	  symbolS *symbol, offsetT offset, char *opcode)
a203 5
  register char *retval;

  frag_grow (max_chars);
  retval = obstack_next_free (&frchain_now->frch_obstack);
  obstack_blank_fast (&frchain_now->frch_obstack, max_chars);
d219 1
d221 20
a240 1
  return (retval);
d255 3
a257 17
  frag_now->fr_var = var;
  frag_now->fr_type = type;
  frag_now->fr_subtype = subtype;
  frag_now->fr_symbol = symbol;
  frag_now->fr_offset = offset;
  frag_now->fr_opcode = opcode;
#ifdef USING_CGEN
  frag_now->fr_cgen.insn = 0;
  frag_now->fr_cgen.opindex = 0;
  frag_now->fr_cgen.opinfo = 0;
#endif
#ifdef TC_FRAG_INIT
  TC_FRAG_INIT (frag_now);
#endif
  as_where (&frag_now->fr_file, &frag_now->fr_line);
  frag_new (max_chars);
  return (retval);
@


1.27
log
@2011-07-25  Tristan Gingold  <gingold@@adacore.com>

	* frags.c (frag_grow): Simplify the code.
@
text
@d78 1
a78 1
/* Try to augment current frag by NCHARS chars.
d80 2
a81 1
   and begin a new frag.  Do not set up any fields of *now_frag.  */
d88 1
a89 1
      long newc;
a90 1
      /* Not enough room in this frag.  Close it.  */
d92 2
a93 1

d96 1
a96 1
         for extremely big (like 2GB initialized) frags.  */
d98 1
a98 1
        newc = 2 * nchars;
d100 10
a109 19
        newc = nchars + 0x10000;
      newc += SIZEOF_STRUCT_FRAG;

      if (newc > 0)
        {
          /* Force to allocate at least NEWC bytes.  */
          oldc = obstack_chunk_size (&frchain_now->frch_obstack);
          obstack_chunk_size (&frchain_now->frch_obstack) = newc;

          /* Do the real work: create a new frag.  */
          frag_new (0);

          /* Restore the old chunk size.  */
          obstack_chunk_size (&frchain_now->frch_obstack) = oldc;
        }

      /* Check for success (also handles negative values of NEWC).  */
      if (obstack_room (&frchain_now->frch_obstack) < nchars)
        as_fatal (_("can't extend frag %u chars"), nchars);
d111 2
@


1.26
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        * as.c (main): Call dwarf2_init.
        * config/obj-elf.c (struct group_list): New field.
        (build_group_lists): Use hash lookup.
        (free_section_idx): New function.
        (elf_frob_file): Adjust.
        * dwarf2dbg.c (all_segs_hash, last_seg_ptr): New variables.
        (get_line_subseg): Adjust.
        (dwarf2_init): New function.
        * dwarf2dbg.h (dwarf2_init): New declaration.
@
text
@d78 1
a78 1
/* Try to augment current frag by nchars chars.
d80 1
a80 2
   and begin a new frag. Unless the new frag has nchars chars available
   do not return. Do not set up any fields of *now_frag.  */
a86 1
      unsigned int n;
d88 1
d90 1
d92 1
a92 2
      frag_new (0);
      oldc = frchain_now->frch_obstack.chunk_size;
d95 1
a95 1
	 for extremely big (like 2GB initialized) frags.  */
d97 1
a97 1
	frchain_now->frch_obstack.chunk_size = 2 * nchars;
d99 19
a117 10
        frchain_now->frch_obstack.chunk_size = nchars + 0x10000;
      frchain_now->frch_obstack.chunk_size += SIZEOF_STRUCT_FRAG;
      if (frchain_now->frch_obstack.chunk_size > 0)
	while ((n = obstack_room (&frchain_now->frch_obstack)) < nchars
	       && (unsigned long) frchain_now->frch_obstack.chunk_size > nchars)
	  {
	    frag_wane (frag_now);
	    frag_new (0);
	  }
      frchain_now->frch_obstack.chunk_size = oldc;
a118 2
  if (obstack_room (&frchain_now->frch_obstack) < nchars)
    as_fatal (_("can't extend frag %u chars"), nchars);
@


1.25
log
@update copyright dates
@
text
@d72 1
a72 1
  ptr = obstack_alloc (ob, SIZEOF_STRUCT_FRAG);
@


1.25.2.1
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.
@
text
@d72 1
a72 1
  ptr = (fragS *) obstack_alloc (ob, SIZEOF_STRUCT_FRAG);
@


1.24
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2003, 2004, 2005, 2006, 2007
@


1.23
log
@Remove unnecessary casts on obstack_alloc invocations.
@
text
@d140 1
a140 1
  assert (frchain_now->frch_last == frag_now);
d145 1
a145 1
  assert (frag_now->fr_type != 0);
d153 2
a154 2
  assert (former_last_fragP != 0);
  assert (former_last_fragP == frag_now);
d173 1
a173 1
  assert (frchain_now->frch_last == frag_now);
@


1.22
log
@Switch to GPLv3
@
text
@d72 1
a72 1
  ptr = (fragS *) obstack_alloc (ob, SIZEOF_STRUCT_FRAG);
@


1.21
log
@	* frags.c (frag_offset_fixed_p): Constify args.
	* frags.h (frag_offset_fixed_p): Ditto.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2003, 2004, 2005, 2006
d10 1
a10 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.20
log
@	* frags.c (frag_offset_fixed_p): Reinitialise offset before
	second scan.
@
text
@d392 1
a392 1
frag_offset_fixed_p (fragS *frag1, fragS *frag2, bfd_vma *offset)
d394 1
a394 1
  fragS *frag;
@


1.19
log
@	PR 997
	* frags.c (frag_offset_fixed_p): New function.
	* frags.h (frag_offset_fixed_p): Declare.
	* expr.c (expr): Use frag_offset_fixed_p when simplifying subtraction.
	(resolve_expression): Likewise.
@
text
@d422 1
@


1.18
log
@gas/
        * frags.c (frag_grow): Don't be too greedy in allocating memory.
        * config/tc-hppa.c (pa_block): Check arguments to .block[z].

gas/testsuite/
        * gas/hppa/parse/block1.s: Use official limit (0x3fffffff) for
        .block.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2003, 2004
d386 52
@


1.18.2.1
log
@Merge changes between binutils-csl-2_17-branchpoint and
binutils-2_17, except for the addition of generated files to CVS.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2003, 2004, 2005, 2006
a385 53

/* Return TRUE if FRAG1 and FRAG2 have a fixed relationship between
   their start addresses.  Set OFFSET to the difference in address
   not already accounted for in the frag FR_ADDRESS.  */

bfd_boolean
frag_offset_fixed_p (fragS *frag1, fragS *frag2, bfd_vma *offset)
{
  fragS *frag;
  bfd_vma off;

  /* Start with offset initialised to difference between the two frags.
     Prior to assigning frag addresses this will be zero.  */
  off = frag1->fr_address - frag2->fr_address;
  if (frag1 == frag2)
    {
      *offset = off;
      return TRUE;
    }

  /* Maybe frag2 is after frag1.  */
  frag = frag1;
  while (frag->fr_type == rs_fill)
    {
      off += frag->fr_fix + frag->fr_offset * frag->fr_var;
      frag = frag->fr_next;
      if (frag == NULL)
	break;
      if (frag == frag2)
	{
	  *offset = off;
	  return TRUE;
	}
    }

  /* Maybe frag1 is after frag2.  */
  off = frag1->fr_address - frag2->fr_address;
  frag = frag2;
  while (frag->fr_type == rs_fill)
    {
      off -= frag->fr_fix + frag->fr_offset * frag->fr_var;
      frag = frag->fr_next;
      if (frag == NULL)
	break;
      if (frag == frag1)
	{
	  *offset = off;
	  return TRUE;
	}
    }

  return FALSE;
}
@


1.17
log
@Update the address and phone number of the FSF
@
text
@d94 8
a101 1
      frchain_now->frch_obstack.chunk_size = 2 * nchars + SIZEOF_STRUCT_FRAG;
@


1.16
log
@update copyright dates
@
text
@d20 2
a21 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.15
log
@	* frags.h (frag_room): Declare.
	* frags.c (frag_room): New function.
	* doc/internals.texi: Document it.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2003
@


1.14
log
@	* ehopt.c: Convert to ISO-C.
	* emul.h: Likewise.
	* expr.c: Likewise.
	* expr.h: Likewise.
	* flonum-copy.c: Likewise.
	* flonum-mult.c: Likewise.
	* flonum.h: Likewise.
	* frags.c: Likewise.
	* frags.h: Likewise.
@
text
@d265 8
@


1.13
log
@	* frags.c (frag_more): Move segment checks to..
	(frag_alloc_check): ..here.  New function.
	(frag_append_1_char): Call frag_alloc_check.
@
text
@d33 1
a33 1
frag_init ()
d64 1
a64 2
frag_alloc (ob)
     struct obstack *ob;
d84 1
a84 2
frag_grow (nchars)
     unsigned int nchars;
d126 3
a128 4
frag_new (old_frags_var_max_size)
     /* Number of chars (already allocated on obstack frags) in
	variable_length part of frag.  */
     int old_frags_var_max_size;
d178 1
a178 2
frag_more (nchars)
     int nchars;
d197 2
a198 8
frag_var (type, max_chars, var, subtype, symbol, offset, opcode)
     relax_stateT type;
     int max_chars;
     int var;
     relax_substateT subtype;
     symbolS *symbol;
     offsetT offset;
     char *opcode;
d229 3
a231 8
frag_variant (type, max_chars, var, subtype, symbol, offset, opcode)
     relax_stateT type;
     int max_chars;
     int var;
     relax_substateT subtype;
     symbolS *symbol;
     offsetT offset;
     char *opcode;
d258 1
a258 2
frag_wane (fragP)
     register fragS *fragP;
d273 1
a273 4
frag_align (alignment, fill_character, max)
     int alignment;
     int fill_character;
     int max;
d303 2
a304 5
frag_align_pattern (alignment, fill_pattern, n_fill, max)
     int alignment;
     const char *fill_pattern;
     int n_fill;
     int max;
d334 1
a334 3
frag_align_code (alignment, max)
     int alignment;
     int max;
d345 1
a345 1
frag_now_fix_octets ()
d355 1
a355 1
frag_now_fix ()
d361 1
a361 2
frag_append_1_char (datum)
     int datum;
@


1.12
log
@revert last change.
@
text
@d3 1
a3 1
   1999, 2000
d39 20
d186 1
a186 12
  if (now_seg == absolute_section)
    {
      as_bad (_("attempt to allocate data in absolute section"));
      subseg_set (text_section, 0);
    }

  if (mri_common_symbol != NULL)
    {
      as_bad (_("attempt to allocate data in common section"));
      mri_common_symbol = NULL;
    }

d388 1
@


1.11
log
@Use frag_make_room() to grow the obstack.
@
text
@a67 6
  /* Try really hard to grow the obstack.  Creating a new obstack can
     disable expression optimisations that would otherwise occur if
     two symbols were located in the same obstack.  */
  if (obstack_room (&frchain_now->frch_obstack) < nchars)
    obstack_make_room (& frchain_now->frch_obstack, 2 * nchars);

@


1.10
log
@	* read.c: Standardize error/warning messages - don't capitalise, no
	final period or newline, don't say "ignored" or "zero assumed" for
	as_bad messages.  In some cases, change the wording to that used
	elsewhere for similar messages.
	* app.c, as.c, atof-generic.c, cgen.c, cond.c, depend.c, dwarf2dbg.c,
	  ecoff.c, expr.c, frags.c, input-file.c, input-scrub.c, listing.c,
	  output-file.c, stabs.c, subsegs.c, symbols.c, write.c: Likewise.
	* ecoff.c (ecoff_directive_end): Test for missing name by
	comparing input line pointers rather than reading string.
	(ecoff_directive_ent): Likewise.
	* read.c (s_set): Likewise.
	(s_align): Report a warning rather than an error for
	alignment too large.
	(s_comm): Check for missing symbol name.
	(s_lcomm_internal): Likewise.
	(s_lsym): Likewise.
	(s_globl): Use is_end_of_line instead of looking for '\n'.
	(s_lcomm_internal): Likewise.
	(ignore_rest_of_line): Report a warning rather than an error.
@
text
@d68 6
@


1.9
log
@Fix copyright notices
@
text
@d87 1
a87 1
    as_fatal (_("Can't extend frag %d. chars"), nchars);
@


1.8
log
@	* as.h (rs_align_test): New.
	* frags.c (NOP_OPCODE): Move default from read.c.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New default.
	(frag_align_code): New.
	* frags.h (frag_align_code): Declare.
	* read.c (NOP_OPCODE): Remove.
	(do_align): Use frag_align_code.
	* write.c (NOP_OPCODE): Remove.
	(get_recorded_alignment): New.
	(cvt_frag_to_fill): Handle rs_align_test.
	(relax_segment): Likewise.
	(subsegs_finish): Align last subseg in section to the
	section alignment.  Use frag_align_code.
	* write.h (get_recorded_alignment): Declare.
	* config/obj-coff.c (size_section): Handle rs_align_test.
	(fill_section, fixup_mdeps): Likewise.
	(write_object_file): Use frag_align_code.

	* config/tc-alpha.c (alpha_align): Use frag_align_code.
	(alpha_handle_align): New.
	* config/tc-alpha.h (HANDLE_ALIGN): New.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-i386.h (md_do_align): Use frag_align_code.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-ia64.c (ia64_md_do_align): Don't do code alignment.
	(ia64_handle_align): New.
	* config/tc-ia64.h (HANDLE_ALIGN): New.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-m32r.c (m32r_do_align): Remove.
	(m32r_handle_align): New.
	(fill_insn): Use frag_align_code.
	* config/tc-m32r.h (md_do_align): Remove.
	(HANDLE_ALIGN, MAX_MEM_FOR_RS_ALIGN_CODE): New.
	* config/tc-m88k.c, config/tc-m88k.h: Similarly.
	* config/tc-mips.c, config/tc-mips.h: Similarly.

	* config/tc-sh.c (sh_cons_align): Use rs_align_test.
	(sh_handle_align): Likewise.  Handle rs_align_code.
	(sh_do_align): Remove.
	* config/tc-sh.h (md_do_align): Remove.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-sparc.c (sparc_cons_align): Use rs_align_test.
	(sparc_handle_align): Likewise.  Handle rs_align_code.
	* config/tc-sparc.h (md_do_align): Remove.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.
@
text
@d2 2
a3 1
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
@


1.8.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000
@


1.7
log
@2000-08-31  Kazu Hirata  <kazu@@hxi.com>

	* frags.c: Fix formatting.
	* macro.c: Likewise.
@
text
@d325 33
@


1.6
log
@Correct absolute section alignment.
@
text
@d30 1
d41 1
d58 6
a63 9
/*
 *			frag_grow()
 *
 * Try to augment current frag by nchars chars.
 * If there is no room, close of the current frag with a ".fill 0"
 * and begin a new frag. Unless the new frag has nchars chars available
 * do not return. Do not set up any fields of *now_frag.
 */
void 
d89 18
a106 21
/*
 *			frag_new()
 *
 * Call this to close off a completed frag, and start up a new (empty)
 * frag, in the same subsegment as the old frag.
 * [frchain_now remains the same but frag_now is updated.]
 * Because this calculates the correct value of fr_fix by
 * looking at the obstack 'frags', it needs to know how many
 * characters at the end of the old frag belong to the maximal
 * variable part;  The rest must belong to fr_fix.
 * It doesn't actually set up the old frag's fr_var.  You may have
 * set fr_var == 1, but allocated 10 chars to the end of the frag;
 * In this case you pass old_frags_var_max_size == 10.
 * In fact, you may use fr_var for something totally unrelated to the
 * size of the variable part of the frag;  None of the generic frag
 * handling code makes use of fr_var.
 *
 * Make a new frag, initialising some components. Link new frag at end
 * of frchain_now.
 */
void 
d109 1
a109 1
	variable_length part of frag. */
d123 1
a123 1
     will begin at a correct boundary. */
d137 1
a137 1
     at an alignment address. */
d151 1
a151 1
}				/* frag_new() */
d153 5
a157 9
/*
 *			frag_more()
 *
 * Start a new frag unless we have n more chars of room in the current frag.
 * Close off the old frag with a .fill 0.
 *
 * Return the address of the 1st char to write into. Advance
 * frag_now_growth past the new chars.
 */
d181 1
a181 1
}				/* frag_more() */
d183 6
a188 10
/*
 *			frag_var()
 *
 * Start a new frag unless we have max_chars more chars of room in the current frag.
 * Close off the old frag with a .fill 0.
 *
 * Set up a machine_dependent relaxable frag, then start a new frag.
 * Return the address of the 1st char of the var part of the old frag
 * to write into.
 */
d224 3
a226 7
/*
 *			frag_variant()
 *
 * OVE: This variant of frag_var assumes that space for the tail has been
 *      allocated by caller.
 *      No call to frag_grow is done.
 */
d258 1
a258 1
}				/* frag_variant() */
d260 3
a262 6
/*
 *			frag_wane()
 *
 * Reduce the variable end of a frag to a harmless state.
 */
void 
d278 1
a278 1
void 
d289 2
a290 2
      mask = (~ (addressT) 0) << alignment;
      new_off = (abs_section_offset + ~ mask) & mask;
d311 1
a311 1
void 
d331 2
a332 2
  return ((char*) obstack_next_free (&frchain_now->frch_obstack)
          - frag_now->fr_literal);
d338 1
a338 1
  return frag_now_fix_octets() / OCTETS_PER_BYTE;
a351 2

/* end of frags.c */
@


1.5
log
@Missed copyright update in last patch.
@
text
@d306 1
d308 2
a309 2
      new_off = ((abs_section_offset + alignment - 1)
		 &~ ((1 << alignment) - 1));
@


1.4
log
@Pass jump reloc in fr_var so it can be used in
md_estimate_size_before_relax, replacing old kludge.
@
text
@d2 1
a2 1
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 97, 1998
@


1.3
log
@Assorted code cleanup and fixes for hppa.  Re-enable elf32-hppa as
it now compiles even if it doesn't work too well.
@
text
@d98 8
a105 5
 * characters at the end of the old frag belong to (the maximal)
 * fr_var: the rest must belong to fr_fix.
 * It doesn't actually set up the old frag's fr_var: you may have
 * set fr_var == 1, but allocated 10 chars to the end of the frag:
 * in this case you pass old_frags_var_max_size == 10.
@


1.2
log
@octets vs bytes changes for GAS
@
text
@d77 7
a83 5
      while ((n = obstack_room (&frchain_now->frch_obstack)) < nchars)
	{
	  frag_wane (frag_now);
	  frag_new (0);
	}
@


1.2.2.1
log
@Pass jump reloc in fr_var so it can be used in
md_estimate_size_before_relax, replacing old kludge.
@
text
@d2 1
a2 1
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
d96 5
a100 8
 * characters at the end of the old frag belong to the maximal
 * variable part;  The rest must belong to fr_fix.
 * It doesn't actually set up the old frag's fr_var.  You may have
 * set fr_var == 1, but allocated 10 chars to the end of the frag;
 * In this case you pass old_frags_var_max_size == 10.
 * In fact, you may use fr_var for something totally unrelated to the
 * size of the variable part of the frag;  None of the generic frag
 * handling code makes use of fr_var.
@


1.1
log
@Initial revision
@
text
@d117 1
a117 1
  frag_now->fr_fix = frag_now_fix () - old_frags_var_max_size;
d339 1
a339 1
frag_now_fix ()
d343 9
a351 2
  return (addressT) ((char*) obstack_next_free (&frchain_now->frch_obstack)
		     - frag_now->fr_literal);
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

