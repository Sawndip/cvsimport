head	1.41;
access;
symbols
	binutils-2_24-branch:1.41.0.4
	binutils-2_24-branchpoint:1.41
	binutils-2_21_1:1.38
	binutils-2_23_2:1.41
	binutils-2_23_1:1.41
	binutils-2_23:1.41
	binutils-2_23-branch:1.41.0.2
	binutils-2_23-branchpoint:1.41
	binutils-2_22_branch:1.39.0.4
	binutils-2_22:1.39
	binutils-2_22-branch:1.39.0.2
	binutils-2_22-branchpoint:1.39
	binutils-2_21:1.38
	binutils-2_21-branch:1.38.0.2
	binutils-2_21-branchpoint:1.38
	binutils-2_20_1:1.36
	binutils-2_20:1.36
	binutils-arc-20081103-branch:1.33.0.8
	binutils-arc-20081103-branchpoint:1.33
	binutils-2_20-branch:1.36.0.2
	binutils-2_20-branchpoint:1.36
	dje-cgen-play1-branch:1.35.0.2
	dje-cgen-play1-branchpoint:1.35
	arc-20081103-branch:1.33.0.6
	arc-20081103-branchpoint:1.33
	binutils-2_19_1:1.33
	binutils-2_19:1.33
	binutils-2_19-branch:1.33.0.4
	binutils-2_19-branchpoint:1.33
	binutils-2_18:1.33
	binutils-2_18-branch:1.33.0.2
	binutils-2_18-branchpoint:1.33
	binutils-csl-coldfire-4_1-32:1.30
	binutils-csl-sourcerygxx-4_1-32:1.30
	binutils-csl-innovasic-fido-3_4_4-33:1.30
	binutils-csl-sourcerygxx-3_4_4-32:1.26
	binutils-csl-coldfire-4_1-30:1.30
	binutils-csl-sourcerygxx-4_1-30:1.30
	binutils-csl-coldfire-4_1-28:1.30
	binutils-csl-sourcerygxx-4_1-29:1.30
	binutils-csl-sourcerygxx-4_1-28:1.30
	binutils-csl-arm-2006q3-27:1.30
	binutils-csl-sourcerygxx-4_1-27:1.30
	binutils-csl-arm-2006q3-26:1.30
	binutils-csl-sourcerygxx-4_1-26:1.30
	binutils-csl-sourcerygxx-4_1-25:1.30
	binutils-csl-sourcerygxx-4_1-24:1.30
	binutils-csl-sourcerygxx-4_1-23:1.30
	binutils-csl-sourcerygxx-4_1-21:1.30
	binutils-csl-arm-2006q3-21:1.30
	binutils-csl-sourcerygxx-4_1-22:1.30
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.30
	binutils-csl-sourcerygxx-4_1-20:1.30
	binutils-csl-arm-2006q3-19:1.30
	binutils-csl-sourcerygxx-4_1-19:1.30
	binutils-csl-sourcerygxx-4_1-18:1.30
	binutils-csl-renesas-4_1-9:1.30
	binutils-csl-sourcerygxx-3_4_4-25:1.26
	binutils-csl-renesas-4_1-8:1.30
	binutils-csl-renesas-4_1-7:1.30
	binutils-csl-renesas-4_1-6:1.30
	binutils-csl-sourcerygxx-4_1-17:1.30
	binutils-csl-sourcerygxx-4_1-14:1.30
	binutils-csl-sourcerygxx-4_1-15:1.30
	binutils-csl-sourcerygxx-4_1-13:1.30
	binutils-2_17:1.30
	binutils-csl-sourcerygxx-4_1-12:1.30
	binutils-csl-sourcerygxx-3_4_4-21:1.30
	binutils-csl-wrs-linux-3_4_4-24:1.26
	binutils-csl-wrs-linux-3_4_4-23:1.26
	binutils-csl-sourcerygxx-4_1-9:1.30
	binutils-csl-sourcerygxx-4_1-8:1.30
	binutils-csl-sourcerygxx-4_1-7:1.30
	binutils-csl-arm-2006q1-6:1.30
	binutils-csl-sourcerygxx-4_1-6:1.30
	binutils-csl-wrs-linux-3_4_4-22:1.26
	binutils-csl-coldfire-4_1-11:1.30
	binutils-csl-sourcerygxx-3_4_4-19:1.30
	binutils-csl-coldfire-4_1-10:1.30
	binutils-csl-sourcerygxx-4_1-5:1.30
	binutils-csl-sourcerygxx-4_1-4:1.30
	binutils-csl-wrs-linux-3_4_4-21:1.26
	binutils-csl-morpho-4_1-4:1.30
	binutils-csl-sourcerygxx-3_4_4-17:1.30
	binutils-csl-wrs-linux-3_4_4-20:1.26
	binutils-2_17-branch:1.30.0.4
	binutils-2_17-branchpoint:1.30
	binutils-csl-2_17-branch:1.30.0.2
	binutils-csl-2_17-branchpoint:1.30
	binutils-csl-gxxpro-3_4-branch:1.26.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.26
	binutils-2_16_1:1.26
	binutils-csl-arm-2005q1b:1.26
	binutils-2_16:1.26
	binutils-csl-arm-2005q1a:1.26
	binutils-csl-arm-2005q1-branch:1.26.0.4
	binutils-csl-arm-2005q1-branchpoint:1.26
	binutils-2_16-branch:1.26.0.2
	binutils-2_16-branchpoint:1.26
	csl-arm-2004-q3d:1.24
	csl-arm-2004-q3:1.24
	binutils-2_15:1.23
	binutils-2_15-branchpoint:1.23
	csl-arm-2004-q1a:1.23
	csl-arm-2004-q1:1.23
	binutils-2_15-branch:1.23.0.6
	cagney_bfdfile-20040213-branch:1.23.0.4
	cagney_bfdfile-20040213-branchpoint:1.23
	cagney_bigcore-20040122-branch:1.23.0.2
	cagney_bigcore-20040122-branchpoint:1.23
	csl-arm-2003-q4:1.23
	binutils-2_14:1.21
	binutils-2_14-branch:1.21.0.2
	binutils-2_14-branchpoint:1.21
	binutils-2_13_2_1:1.18
	binutils-2_13_2:1.18
	binutils-2_13_1:1.18
	binutils-2_13:1.18
	binutils-2_13-branchpoint:1.18
	binutils-2_13-branch:1.18.0.2
	binutils-2_12_1:1.17
	binutils-2_12:1.17
	binutils-2_12-branch:1.17.0.2
	binutils-2_12-branchpoint:1.17
	cygnus_cvs_20020108_pre:1.17
	binutils-2_11_2:1.8.2.2
	binutils-2_11_1:1.8.2.2
	binutils-2_11:1.8
	x86_64versiong3:1.9
	binutils-2_11-branch:1.8.0.2
	binutils-2_10_1:1.2
	binutils-2_10:1.2
	binutils-2_10-branch:1.2.0.2
	binutils-2_10-branchpoint:1.2
	binutils_latest_snapshot:1.41
	repo-unification-2000-02-06:1.2
	binu_ss_19990721:1.2
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.41
date	2012.05.17.15.13.15;	author nickc;	state Exp;
branches;
next	1.40;

1.40
date	2012.02.20.10.25.02;	author nickc;	state Exp;
branches;
next	1.39;

1.39
date	2011.09.08.16.07.10;	author nickc;	state Exp;
branches;
next	1.38;

1.38
date	2010.06.28.14.06.56;	author amodra;	state Exp;
branches;
next	1.37;

1.37
date	2010.02.26.02.30.26;	author devans;	state Exp;
branches;
next	1.36;

1.36
date	2009.09.02.07.24.19;	author amodra;	state Exp;
branches;
next	1.35;

1.35
date	2009.06.22.17.56.00;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	2009.05.13.21.41.38;	author dj;	state Exp;
branches;
next	1.33;

1.33
date	2007.07.03.11.01.02;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2007.02.05.20.10.24;	author brolley;	state Exp;
branches;
next	1.31;

1.31
date	2006.06.07.11.27.57;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2005.06.07.17.54.15;	author zack;	state Exp;
branches;
next	1.29;

1.29
date	2005.05.05.09.12.43;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2005.03.21.15.31.37;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	2005.03.16.18.09.04;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	2005.02.23.12.28.02;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2005.01.25.20.22.31;	author aoliva;	state Exp;
branches;
next	1.24;

1.24
date	2004.06.25.16.11.09;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2003.11.21.01.52.16;	author kazu;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.10.22.08.45;	author devans;	state Exp;
branches;
next	1.21;

1.21
date	2003.04.08.12.47.07;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	2003.02.20.18.59.31;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2002.09.05.00.01.15;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.03.02.25.33;	author kazu;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.17.19.50.31;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2001.11.15.21.28.53;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2001.10.13.09.46.09;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.01.01.44.25;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2001.07.06.19.09.22;	author jhealy;	state Exp;
branches;
next	1.12;

1.12
date	2001.05.16.23.06.02;	author jjohnstn;	state Exp;
branches;
next	1.11;

1.11
date	2001.03.17.03.02.06;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2001.03.08.23.24.22;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2001.02.16.12.29.39;	author mrg;	state Exp;
branches;
next	1.8;

1.8
date	2001.01.12.23.34.43;	author fche;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.10.11.20.24.32;	author kazu;	state Exp;
branches;
next	1.6;

1.6
date	2000.09.06.02.36.20;	author kazu;	state Exp;
branches;
next	1.5;

1.5
date	2000.07.31.22.08.14;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.26.22.39.08;	author brolley;	state Exp;
branches;
next	1.3;

1.3
date	2000.06.24.15.10.45;	author fche;	state Exp;
branches;
next	1.2;

1.2
date	99.06.03.12.51.21;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.40;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.8.2.1
date	2001.06.07.03.15.24;	author amodra;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2001.06.11.10.04.38;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.40;	author rth;	state Exp;
branches;
next	;


desc
@@


1.41
log
@	PR 14072
	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.
	* alpha-opc.c: Include sysdep.h before any other header file.
	* alpha-dis.c: Likewise.
	* avr-dis.c: Likewise.
	* cgen-opc.c: Likewise.
	* cr16-dis.c: Likewise.
	* cris-dis.c: Likewise.
	* crx-dis.c: Likewise.
	* d10v-dis.c: Likewise.
	* d10v-opc.c: Likewise.
	* d30v-dis.c: Likewise.
	* d30v-opc.c: Likewise.
	* h8500-dis.c: Likewise.
	* i370-dis.c: Likewise.
	* i370-opc.c: Likewise.
	* m10200-dis.c: Likewise.
	* m10300-dis.c: Likewise.
	* micromips-opc.c: Likewise.
	* mips-opc.c: Likewise.
	* mips61-opc.c: Likewise.
	* moxie-dis.c: Likewise.
	* or32-opc.c: Likewise.
	* pj-dis.c: Likewise.
	* ppc-dis.c: Likewise.
	* ppc-opc.c: Likewise.
	* s390-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* sh64-dis.c: Likewise.
	* sparc-dis.c: Likewise.
	* sparc-opc.c: Likewise.
	* spu-dis.c: Likewise.
	* tic30-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
	* tic80-dis.c: Likewise.
	* tic80-opc.c: Likewise.
	* tilegx-dis.c: Likewise.
	* tilepro-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* v850-opc.c: Likewise.
	* vax-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* xgate-dis.c: Likewise.
	* xtensa-dis.c: Likewise.
	* rl78-decode.opc: Likewise.
	* rl78-decode.c: Regenerate.
	* rx-decode.opc: Likewise.
	* rx-decode.c: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* bfd-in.h: Generate an error if included before config.h.
	* sysdep.h: Likewise.
	* bfd-in2.h: Regenerate.
	* compress.c: Remove #include "config.h".
	* plugin.c: Likewise.
	* elf32-m68hc1x.c: Include sysdep.h before alloca-conf.h.
	* elf64-hppa.c: Likewise.
	* som.c: Likewise.
	* xsymc.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* Makefile.am: Use wrappers around C files generated by flex.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* itbl-lex-wrapper.c: New file.
	* config/bfin-lex-wrapper.c: New file.
	* cgen.c: Include as.h before setjmp.h.
	* config/tc-dlx.c: Include as.h before any other header.
	* config/tc-h8300.c: Likewise.
	* config/tc-lm32.c: Likewise.
	* config/tc-mep.c: Likewise.
	* config/tc-microblaze.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-xtensa.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* unwind-ia64.h: Include config.h.
@
text
@/* GAS interface for targets using CGEN: Cpu tools GENerator.
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005,
   2006, 2007, 2009, 2010, 2011, 2012  Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free Software
   Foundation, 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */

#include "as.h"
#include <setjmp.h>
#include "symcat.h"
#include "cgen-desc.h"
#include "subsegs.h"
#include "cgen.h"
#include "dwarf2dbg.h"

#include "symbols.h"
#include "struc-symbol.h"

#ifdef OBJ_COMPLEX_RELC
static expressionS * make_right_shifted_expr
  (expressionS *, const int, const int);

static unsigned long gas_cgen_encode_addend
  (const unsigned long, const unsigned long, const unsigned long, \
   const unsigned long, const unsigned long, const unsigned long, \
   const unsigned long);

static char * weak_operand_overflow_check
  (const expressionS *, const CGEN_OPERAND *);

static void queue_fixup_recursively
  (const int, const int, expressionS *, \
   const CGEN_MAYBE_MULTI_IFLD *, const int, const int);

static int rightshift = 0;
#endif
static void queue_fixup (int, int, expressionS *);

/* Opcode table descriptor, must be set by md_begin.  */

CGEN_CPU_DESC gas_cgen_cpu_desc;

/* Callback to insert a register into the symbol table.
   A target may choose to let GAS parse the registers.
   ??? Not currently used.  */

void
cgen_asm_record_register (name, number)
     char *name;
     int number;
{
  /* Use symbol_create here instead of symbol_new so we don't try to
     output registers into the object file's symbol table.  */
  symbol_table_insert (symbol_create (name, reg_section,
				      number, &zero_address_frag));
}

/* We need to keep a list of fixups.  We can't simply generate them as
   we go, because that would require us to first create the frag, and
   that would screw up references to ``.''.

   This is used by cpu's with simple operands.  It keeps knowledge of what
   an `expressionS' is and what a `fixup' is out of CGEN which for the time
   being is preferable.

   OPINDEX is the index in the operand table.
   OPINFO is something the caller chooses to help in reloc determination.  */

struct fixup
{
  int opindex;
  int opinfo;
  expressionS exp;
  struct cgen_maybe_multi_ifield * field;
  int msb_field_p;
};

static struct fixup fixups[GAS_CGEN_MAX_FIXUPS];
static int num_fixups;

/* Prepare to parse an instruction.
   ??? May wish to make this static and delete calls in md_assemble.  */

void
gas_cgen_init_parse ()
{
  num_fixups = 0;
}

/* Queue a fixup.  */

static void
queue_fixup (opindex, opinfo, expP)
     int           opindex;
     int           opinfo;
     expressionS * expP;
{
  /* We need to generate a fixup for this expression.  */
  if (num_fixups >= GAS_CGEN_MAX_FIXUPS)
    as_fatal (_("too many fixups"));
  fixups[num_fixups].exp     = *expP;
  fixups[num_fixups].opindex = opindex;
  fixups[num_fixups].opinfo  = opinfo;
  ++ num_fixups;
}

/* The following functions allow fixup chains to be stored, retrieved,
   and swapped.  They are a generalization of a pre-existing scheme
   for storing, restoring and swapping fixup chains that was used by
   the m32r port.  The functionality is essentially the same, only
   instead of only being able to store a single fixup chain, an entire
   array of fixup chains can be stored.  It is the user's responsibility
   to keep track of how many fixup chains have been stored and which
   elements of the array they are in.

   The algorithms used are the same as in the old scheme.  Other than the
   "array-ness" of the whole thing, the functionality is identical to the
   old scheme.

   gas_cgen_initialize_saved_fixups_array():
      Sets num_fixups_in_chain to 0 for each element. Call this from
      md_begin() if you plan to use these functions and you want the
      fixup count in each element to be set to 0 initially.  This is
      not necessary, but it's included just in case.  It performs
      the same function for each element in the array of fixup chains
      that gas_init_parse() performs for the current fixups.

   gas_cgen_save_fixups (element):
      element - element number of the array you wish to store the fixups
                to.  No mechanism is built in for tracking what element
                was last stored to.

   gas_cgen_restore_fixups (element):
      element - element number of the array you wish to restore the fixups
                from.

   gas_cgen_swap_fixups(int element):
       element - swap the current fixups with those in this element number.
*/

struct saved_fixups
{
  struct fixup fixup_chain[GAS_CGEN_MAX_FIXUPS];
  int num_fixups_in_chain;
};

static struct saved_fixups stored_fixups[MAX_SAVED_FIXUP_CHAINS];

void
gas_cgen_initialize_saved_fixups_array ()
{
  int i = 0;

  while (i < MAX_SAVED_FIXUP_CHAINS)
    stored_fixups[i++].num_fixups_in_chain = 0;
}

void
gas_cgen_save_fixups (i)
     int i;
{
  if (i < 0 || i >= MAX_SAVED_FIXUP_CHAINS)
    {
      as_fatal ("index into stored_fixups[] out of bounds");
      return;
    }

  stored_fixups[i].num_fixups_in_chain = num_fixups;
  memcpy (stored_fixups[i].fixup_chain, fixups,
	  sizeof (fixups[0]) * num_fixups);
  num_fixups = 0;
}

void
gas_cgen_restore_fixups (i)
     int i;
{
  if (i < 0 || i >= MAX_SAVED_FIXUP_CHAINS)
    {
      as_fatal ("index into stored_fixups[] out of bounds");
      return;
    }

  num_fixups = stored_fixups[i].num_fixups_in_chain;
  memcpy (fixups, stored_fixups[i].fixup_chain,
	  (sizeof (stored_fixups[i].fixup_chain[0])) * num_fixups);
  stored_fixups[i].num_fixups_in_chain = 0;
}

void
gas_cgen_swap_fixups (i)
     int i;
{
  if (i < 0 || i >= MAX_SAVED_FIXUP_CHAINS)
    {
      as_fatal ("index into stored_fixups[] out of bounds");
      return;
    }

  if (num_fixups == 0)
    gas_cgen_restore_fixups (i);

  else if (stored_fixups[i].num_fixups_in_chain == 0)
    gas_cgen_save_fixups (i);

  else
    {
      int tmp;
      struct fixup tmp_fixup;

      tmp = stored_fixups[i].num_fixups_in_chain;
      stored_fixups[i].num_fixups_in_chain = num_fixups;
      num_fixups = tmp;

      for (tmp = GAS_CGEN_MAX_FIXUPS; tmp--;)
	{
	  tmp_fixup = stored_fixups[i].fixup_chain [tmp];
	  stored_fixups[i].fixup_chain[tmp] = fixups [tmp];
	  fixups [tmp] = tmp_fixup;
	}
    }
}

/* Default routine to record a fixup.
   This is a cover function to fix_new.
   It exists because we record INSN with the fixup.

   FRAG and WHERE are their respective arguments to fix_new_exp.
   LENGTH is in bits.
   OPINFO is something the caller chooses to help in reloc determination.

   At this point we do not use a bfd_reloc_code_real_type for
   operands residing in the insn, but instead just use the
   operand index.  This lets us easily handle fixups for any
   operand type.  We pick a BFD reloc type in md_apply_fix.  */

fixS *
gas_cgen_record_fixup (frag, where, insn, length, operand, opinfo, symbol, offset)
     fragS *              frag;
     int                  where;
     const CGEN_INSN *    insn;
     int                  length;
     const CGEN_OPERAND * operand;
     int                  opinfo;
     symbolS *            symbol;
     offsetT              offset;
{
  fixS *fixP;

  /* It may seem strange to use operand->attrs and not insn->attrs here,
     but it is the operand that has a pc relative relocation.  */
  fixP = fix_new (frag, where, length / 8, symbol, offset,
		  CGEN_OPERAND_ATTR_VALUE (operand, CGEN_OPERAND_PCREL_ADDR),
		  (bfd_reloc_code_real_type)
		    ((int) BFD_RELOC_UNUSED
		     + (int) operand->type));
  fixP->fx_cgen.insn = insn;
  fixP->fx_cgen.opinfo = opinfo;
  fixP->fx_cgen.field = NULL;
  fixP->fx_cgen.msb_field_p = 0;

  return fixP;
}

/* Default routine to record a fixup given an expression.
   This is a cover function to fix_new_exp.
   It exists because we record INSN with the fixup.

   FRAG and WHERE are their respective arguments to fix_new_exp.
   LENGTH is in bits.
   OPINFO is something the caller chooses to help in reloc determination.

   At this point we do not use a bfd_reloc_code_real_type for
   operands residing in the insn, but instead just use the
   operand index.  This lets us easily handle fixups for any
   operand type.  We pick a BFD reloc type in md_apply_fix.  */

fixS *
gas_cgen_record_fixup_exp (frag, where, insn, length, operand, opinfo, exp)
     fragS *              frag;
     int                  where;
     const CGEN_INSN *    insn;
     int                  length;
     const CGEN_OPERAND * operand;
     int                  opinfo;
     expressionS *        exp;
{
  fixS *fixP;

  /* It may seem strange to use operand->attrs and not insn->attrs here,
     but it is the operand that has a pc relative relocation.  */
  fixP = fix_new_exp (frag, where, length / 8, exp,
		      CGEN_OPERAND_ATTR_VALUE (operand, CGEN_OPERAND_PCREL_ADDR),
		      (bfd_reloc_code_real_type)
		        ((int) BFD_RELOC_UNUSED
			 + (int) operand->type));
  fixP->fx_cgen.insn = insn;
  fixP->fx_cgen.opinfo = opinfo;
  fixP->fx_cgen.field = NULL;
  fixP->fx_cgen.msb_field_p = 0;

  return fixP;
}

#ifdef OBJ_COMPLEX_RELC
static symbolS *
expr_build_binary (operatorT op, symbolS * s1, symbolS * s2)
{
  expressionS e;

  e.X_op = op;
  e.X_add_symbol = s1;
  e.X_op_symbol = s2;
  e.X_add_number = 0;
  return make_expr_symbol (& e);
}
#endif

/* Used for communication between the next two procedures.  */
static jmp_buf expr_jmp_buf;
static int expr_jmp_buf_p;

/* Callback for cgen interface.  Parse the expression at *STRP.
   The result is an error message or NULL for success (in which case
   *STRP is advanced past the parsed text).
   WANT is an indication of what the caller is looking for.
   If WANT == CGEN_ASM_PARSE_INIT the caller is beginning to try to match
   a table entry with the insn, reset the queued fixups counter.
   An enum cgen_parse_operand_result is stored in RESULTP.
   OPINDEX is the operand's table entry index.
   OPINFO is something the caller chooses to help in reloc determination.
   The resulting value is stored in VALUEP.  */

const char *
gas_cgen_parse_operand (cd, want, strP, opindex, opinfo, resultP, valueP)

#ifdef OBJ_COMPLEX_RELC
     CGEN_CPU_DESC cd;
#else
     CGEN_CPU_DESC cd ATTRIBUTE_UNUSED;
#endif
     enum cgen_parse_operand_type want;
     const char **strP;
     int opindex;
     int opinfo;
     enum cgen_parse_operand_result *resultP;
     bfd_vma *valueP;
{
#ifdef __STDC__
  /* These are volatile to survive the setjmp.  */
  char * volatile hold;
  enum cgen_parse_operand_result * volatile resultP_1;
  volatile int opinfo_1;
#else
  static char *hold;
  static enum cgen_parse_operand_result *resultP_1;
  int opinfo_1;
#endif
  const char *errmsg;
  expressionS exp;

#ifdef OBJ_COMPLEX_RELC
  volatile int              signed_p = 0;
  symbolS *                 stmp = NULL;
  bfd_reloc_code_real_type  reloc_type;
  const CGEN_OPERAND *      operand;
  fixS                      dummy_fixup;
#endif
  if (want == CGEN_PARSE_OPERAND_INIT)
    {
      gas_cgen_init_parse ();
      return NULL;
    }

  resultP_1 = resultP;
  hold = input_line_pointer;
  input_line_pointer = (char *) *strP;
  opinfo_1 = opinfo;

  /* We rely on md_operand to longjmp back to us.
     This is done via gas_cgen_md_operand.  */
  if (setjmp (expr_jmp_buf) != 0)
    {
      expr_jmp_buf_p = 0;
      input_line_pointer = (char *) hold;
      *resultP_1 = CGEN_PARSE_OPERAND_RESULT_ERROR;
      return _("illegal operand");
    }

  expr_jmp_buf_p = 1;
  expression (&exp);
  expr_jmp_buf_p = 0;
  errmsg = NULL;

  *strP = input_line_pointer;
  input_line_pointer = hold;

#ifdef TC_CGEN_PARSE_FIX_EXP
  opinfo_1 = TC_CGEN_PARSE_FIX_EXP (opinfo_1, & exp);
#endif

  /* FIXME: Need to check `want'.  */

  switch (exp.X_op)
    {
    case O_illegal:
      errmsg = _("illegal operand");
      *resultP = CGEN_PARSE_OPERAND_RESULT_ERROR;
      break;
    case O_absent:
      errmsg = _("missing operand");
      *resultP = CGEN_PARSE_OPERAND_RESULT_ERROR;
      break;
    case O_constant:
      if (want == CGEN_PARSE_OPERAND_SYMBOLIC)
	goto de_fault;
      *valueP = exp.X_add_number;
      *resultP = CGEN_PARSE_OPERAND_RESULT_NUMBER;
      break;
    case O_register:
      *valueP = exp.X_add_number;
      *resultP = CGEN_PARSE_OPERAND_RESULT_REGISTER;
      break;
    de_fault:
    default:
#ifdef OBJ_COMPLEX_RELC
      /* Look up operand, check to see if there's an obvious
	 overflow (this helps disambiguate some insn parses).  */
      operand = cgen_operand_lookup_by_num (cd, opindex);
      errmsg = weak_operand_overflow_check (& exp, operand);

      if (! errmsg)
	{
	  /* Fragment the expression as necessary, and queue a reloc.  */
	  memset (& dummy_fixup, 0, sizeof (fixS));

	  reloc_type = md_cgen_lookup_reloc (0, operand, & dummy_fixup);

	  if (exp.X_op == O_symbol
	      && reloc_type == BFD_RELOC_RELC
	      && exp.X_add_symbol->sy_value.X_op == O_constant
	      && (!exp.X_add_symbol->bsym
		  || (exp.X_add_symbol->bsym->section != expr_section
		      && exp.X_add_symbol->bsym->section != absolute_section
		      && exp.X_add_symbol->bsym->section != undefined_section)))
	    {
	      /* Local labels will have been (eagerly) turned into constants
		 by now, due to the inappropriately deep insight of the
		 expression parser.  Unfortunately make_expr_symbol
		 prematurely dives into the symbol evaluator, and in this
		 case it gets a bad answer, so we manually create the
		 expression symbol we want here.  */
	      stmp = symbol_create (FAKE_LABEL_NAME, expr_section, 0,
				    & zero_address_frag);
	      symbol_set_value_expression (stmp, & exp);
	    }
	  else
	    stmp = make_expr_symbol (& exp);

	  /* If this is a pc-relative RELC operand, we
	     need to subtract "." from the expression.  */
 	  if (reloc_type == BFD_RELOC_RELC
	      && CGEN_OPERAND_ATTR_VALUE (operand, CGEN_OPERAND_PCREL_ADDR))
 	    stmp = expr_build_binary (O_subtract, stmp, expr_build_dot ());

	  /* FIXME: this is not a perfect heuristic for figuring out
	     whether an operand is signed: it only works when the operand
	     is an immediate. it's not terribly likely that any other
	     values will be signed relocs, but it's possible. */
	  if (operand && (operand->hw_type == HW_H_SINT))
	    signed_p = 1;

	  if (stmp->bsym && (stmp->bsym->section == expr_section)
	      && ! S_IS_LOCAL (stmp))
	    {
	      if (signed_p)
		stmp->bsym->flags |= BSF_SRELC;
	      else
		stmp->bsym->flags |= BSF_RELC;
	    }

	  /* Now package it all up for the fixup emitter.  */
	  exp.X_op = O_symbol;
	  exp.X_op_symbol = 0;
	  exp.X_add_symbol = stmp;
	  exp.X_add_number = 0;

	  /* Re-init rightshift quantity, just in case.  */
	  rightshift = operand->length;
	  queue_fixup_recursively (opindex, opinfo_1, & exp,
				   (reloc_type == BFD_RELOC_RELC) ?
				   & (operand->index_fields) : 0,
				   signed_p, -1);
	}
      * resultP = errmsg
	? CGEN_PARSE_OPERAND_RESULT_ERROR
	: CGEN_PARSE_OPERAND_RESULT_QUEUED;
      *valueP = 0;
#else
      queue_fixup (opindex, opinfo_1, &exp);
      *valueP = 0;
      *resultP = CGEN_PARSE_OPERAND_RESULT_QUEUED;
#endif
      break;
    }

  return errmsg;
}

/* md_operand handler to catch unrecognized expressions and halt the
   parsing process so the next entry can be tried.

   ??? This could be done differently by adding code to `expression'.  */

void
gas_cgen_md_operand (expressionP)
     expressionS *expressionP ATTRIBUTE_UNUSED;
{
  /* Don't longjmp if we're not called from within cgen_parse_operand().  */
  if (expr_jmp_buf_p)
    longjmp (expr_jmp_buf, 1);
}

/* Finish assembling instruction INSN.
   BUF contains what we've built up so far.
   LENGTH is the size of the insn in bits.
   RELAX_P is non-zero if relaxable insns should be emitted as such.
   Otherwise they're emitted in non-relaxable forms.
   The "result" is stored in RESULT if non-NULL.  */

void
gas_cgen_finish_insn (insn, buf, length, relax_p, result)
     const CGEN_INSN *insn;
     CGEN_INSN_BYTES_PTR buf;
     unsigned int length;
     int relax_p;
     finished_insnS *result;
{
  int i;
  int relax_operand;
  char *f;
  unsigned int byte_len = length / 8;

  /* ??? Target foo issues various warnings here, so one might want to provide
     a hook here.  However, our caller is defined in tc-foo.c so there
     shouldn't be a need for a hook.  */

  /* Write out the instruction.
     It is important to fetch enough space in one call to `frag_more'.
     We use (f - frag_now->fr_literal) to compute where we are and we
     don't want frag_now to change between calls.

     Relaxable instructions: We need to ensure we allocate enough
     space for the largest insn.  */

  if (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_RELAXED))
    /* These currently shouldn't get here.  */
    abort ();

  /* Is there a relaxable insn with the relaxable operand needing a fixup?  */

  relax_operand = -1;
  if (relax_p && CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_RELAXABLE))
    {
      /* Scan the fixups for the operand affected by relaxing
	 (i.e. the branch address).  */

      for (i = 0; i < num_fixups; ++i)
	{
	  if (CGEN_OPERAND_ATTR_VALUE (cgen_operand_lookup_by_num (gas_cgen_cpu_desc, fixups[i].opindex),
				       CGEN_OPERAND_RELAX))
	    {
	      relax_operand = i;
	      break;
	    }
	}
    }

  if (relax_operand != -1)
    {
      int max_len;
      fragS *old_frag;
      expressionS *exp;
      symbolS *sym;
      offsetT off;

#ifdef TC_CGEN_MAX_RELAX
      max_len = TC_CGEN_MAX_RELAX (insn, byte_len);
#else
      max_len = CGEN_MAX_INSN_SIZE;
#endif
      /* Ensure variable part and fixed part are in same fragment.  */
      /* FIXME: Having to do this seems like a hack.  */
      frag_grow (max_len);

      /* Allocate space for the fixed part.  */
      f = frag_more (byte_len);

      /* Create a relaxable fragment for this instruction.  */
      old_frag = frag_now;

      exp = &fixups[relax_operand].exp;
      sym = exp->X_add_symbol;
      off = exp->X_add_number;
      if (exp->X_op != O_constant && exp->X_op != O_symbol)
	{
	  /* Handle complex expressions.  */
	  sym = make_expr_symbol (exp);
	  off = 0;
	}

      frag_var (rs_machine_dependent,
		max_len - byte_len /* max chars */,
		0 /* variable part already allocated */,
		/* FIXME: When we machine generate the relax table,
		   machine generate a macro to compute subtype.  */
		1 /* subtype */,
		sym,
		off,
		f);

      /* Record the operand number with the fragment so md_convert_frag
	 can use gas_cgen_md_record_fixup to record the appropriate reloc.  */
      old_frag->fr_cgen.insn    = insn;
      old_frag->fr_cgen.opindex = fixups[relax_operand].opindex;
      old_frag->fr_cgen.opinfo  = fixups[relax_operand].opinfo;
      if (result)
	result->frag = old_frag;
    }
  else
    {
      f = frag_more (byte_len);
      if (result)
	result->frag = frag_now;
    }

  /* If we're recording insns as numbers (rather than a string of bytes),
     target byte order handling is deferred until now.  */
#if CGEN_INT_INSN_P
  cgen_put_insn_value (gas_cgen_cpu_desc, (unsigned char *) f, length, *buf);
#else
  memcpy (f, buf, byte_len);
#endif

  /* Emit DWARF2 debugging information.  */
  dwarf2_emit_insn (byte_len);

  /* Create any fixups.  */
  for (i = 0; i < num_fixups; ++i)
    {
      fixS *fixP;
      const CGEN_OPERAND *operand =
	cgen_operand_lookup_by_num (gas_cgen_cpu_desc, fixups[i].opindex);

      /* Don't create fixups for these.  That's done during relaxation.
	 We don't need to test for CGEN_INSN_RELAXED as they can't get here
	 (see above).  */
      if (relax_p
	  && CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_RELAXABLE)
	  && CGEN_OPERAND_ATTR_VALUE (operand, CGEN_OPERAND_RELAX))
	continue;

#ifndef md_cgen_record_fixup_exp
#define md_cgen_record_fixup_exp gas_cgen_record_fixup_exp
#endif

      fixP = md_cgen_record_fixup_exp (frag_now, f - frag_now->fr_literal,
				       insn, length, operand,
				       fixups[i].opinfo,
				       &fixups[i].exp);
      fixP->fx_cgen.field = fixups[i].field;
      fixP->fx_cgen.msb_field_p = fixups[i].msb_field_p;
      if (result)
	result->fixups[i] = fixP;
    }

  if (result)
    {
      result->num_fixups = num_fixups;
      result->addr = f;
    }
}

#ifdef OBJ_COMPLEX_RELC
/* Queue many fixups, recursively. If the field is a multi-ifield,
   repeatedly queue its sub-parts, right shifted to fit into the field (we
   assume here multi-fields represent a left-to-right, MSB0-LSB0
   reading). */

static void
queue_fixup_recursively (const int                      opindex,
			 const int                      opinfo,
			 expressionS *                  expP,
			 const CGEN_MAYBE_MULTI_IFLD *  field,
			 const int                      signed_p,
			 const int                      part_of_multi)
{
  if (field && field->count)
    {
      int i;

      for (i = 0; i < field->count; ++ i)
	queue_fixup_recursively (opindex, opinfo, expP,
				 & (field->val.multi[i]), signed_p, i);
    }
  else
    {
      expressionS * new_exp = expP;

#ifdef DEBUG
      printf ("queueing fixup for field %s\n",
	      (field ? field->val.leaf->name : "??"));
      print_symbol_value (expP->X_add_symbol);
#endif
      if (field && part_of_multi != -1)
	{
	  rightshift -= field->val.leaf->length;

	  /* Shift reloc value by number of bits remaining after this
	     field.  */
	  if (rightshift)
	    new_exp = make_right_shifted_expr (expP, rightshift, signed_p);
	}

      /* Truncate reloc values to length, *after* leftmost one.  */
      fixups[num_fixups].msb_field_p = (part_of_multi <= 0);
      fixups[num_fixups].field = (CGEN_MAYBE_MULTI_IFLD *) field;

      queue_fixup (opindex, opinfo, new_exp);
    }
}

/* Encode the self-describing RELC reloc format's addend.  */

static unsigned long
gas_cgen_encode_addend (const unsigned long start,    /* in bits */
			const unsigned long len,      /* in bits */
			const unsigned long oplen,    /* in bits */
			const unsigned long wordsz,   /* in bytes */
			const unsigned long chunksz,  /* in bytes */
			const unsigned long signed_p,
			const unsigned long trunc_p)
{
  unsigned long res = 0L;

  res |= start    & 0x3F;
  res |= (oplen   & 0x3F) << 6;
  res |= (len     & 0x3F) << 12;
  res |= (wordsz  & 0xF)  << 18;
  res |= (chunksz & 0xF)  << 22;
  res |= (CGEN_INSN_LSB0_P ? 1 : 0) << 27;
  res |= signed_p << 28;
  res |= trunc_p << 29;

  return res;
}

/* Purpose: make a weak check that the expression doesn't overflow the
   operand it's to be inserted into.

   Rationale: some insns used to use %operators to disambiguate during a
   parse. when these %operators are translated to expressions by the macro
   expander, the ambiguity returns. we attempt to disambiguate by field
   size.

   Method: check to see if the expression's top node is an O_and operator,
   and the mask is larger than the operand length. This would be an
   overflow, so signal it by returning an error string. Any other case is
   ambiguous, so we assume it's OK and return NULL.  */

static char *
weak_operand_overflow_check (const expressionS *  exp,
			     const CGEN_OPERAND * operand)
{
  const unsigned long len = operand->length;
  unsigned long mask;
  unsigned long opmask = (((1L << (len - 1)) - 1) << 1) | 1;

  if (!exp)
    return NULL;

  if (exp->X_op != O_bit_and)
    {
      /* Check for implicit overflow flag.  */
      if (CGEN_OPERAND_ATTR_VALUE
	  (operand, CGEN_OPERAND_RELOC_IMPLIES_OVERFLOW))
	return _("a reloc on this operand implies an overflow");
      return NULL;
    }

  mask = exp->X_add_number;

  if (exp->X_add_symbol
      && exp->X_add_symbol->sy_value.X_op == O_constant)
    mask |= exp->X_add_symbol->sy_value.X_add_number;

  if (exp->X_op_symbol
      && exp->X_op_symbol->sy_value.X_op == O_constant)
    mask |= exp->X_op_symbol->sy_value.X_add_number;

  /* Want to know if mask covers more bits than opmask.
     this is the same as asking if mask has any bits not in opmask,
     or whether (mask & ~opmask) is nonzero.  */
  if (mask && (mask & ~opmask))
    {
#ifdef DEBUG
      printf ("overflow: (mask = %8.8x, ~opmask = %8.8x, AND = %8.8x)\n",
	      mask, ~opmask, (mask & ~opmask));
#endif
      return _("operand mask overflow");
    }

  return NULL;
}

static expressionS *
make_right_shifted_expr (expressionS * exp,
			 const int     amount,
			 const int     signed_p)
{
  symbolS * stmp = 0;
  expressionS * new_exp;

  stmp = expr_build_binary (O_right_shift,
			    make_expr_symbol (exp),
			    expr_build_uconstant (amount));

  if (signed_p)
    stmp->bsym->flags |= BSF_SRELC;
  else
    stmp->bsym->flags |= BSF_RELC;

  /* Then wrap that in a "symbol expr" for good measure.  */
  new_exp = xmalloc (sizeof (expressionS));
  memset (new_exp, 0, sizeof (expressionS));
  new_exp->X_op = O_symbol;
  new_exp->X_op_symbol = 0;
  new_exp->X_add_symbol = stmp;
  new_exp->X_add_number = 0;

  return new_exp;
}

#endif

/* Apply a fixup to the object code.  This is called for all the
   fixups we generated by the call to fix_new_exp, above.  In the call
   above we used a reloc code which was the largest legal reloc code
   plus the operand index.  Here we undo that to recover the operand
   index.  At this point all symbol values should be fully resolved,
   and we attempt to completely resolve the reloc.  If we can not do
   that, we determine the correct reloc code and put it back in the fixup.  */

/* FIXME: This function handles some of the fixups and bfd_install_relocation
   handles the rest.  bfd_install_relocation (or some other bfd function)
   should handle them all.  */

void
gas_cgen_md_apply_fix (fixP, valP, seg)
     fixS *   fixP;
     valueT * valP;
     segT     seg ATTRIBUTE_UNUSED;
{
  char *where = fixP->fx_frag->fr_literal + fixP->fx_where;
  valueT value = * valP;
  /* Canonical name, since used a lot.  */
  CGEN_CPU_DESC cd = gas_cgen_cpu_desc;

  if (fixP->fx_addsy == (symbolS *) NULL)
    fixP->fx_done = 1;

  /* We don't actually support subtracting a symbol.  */
  if (fixP->fx_subsy != (symbolS *) NULL)
    as_bad_where (fixP->fx_file, fixP->fx_line, _("expression too complex"));

  if ((int) fixP->fx_r_type >= (int) BFD_RELOC_UNUSED)
    {
      int opindex = (int) fixP->fx_r_type - (int) BFD_RELOC_UNUSED;
      const CGEN_OPERAND *operand = cgen_operand_lookup_by_num (cd, opindex);
      const char *errmsg;
      bfd_reloc_code_real_type reloc_type;
      CGEN_FIELDS *fields = alloca (CGEN_CPU_SIZEOF_FIELDS (cd));
      const CGEN_INSN *insn = fixP->fx_cgen.insn;
#ifdef OBJ_COMPLEX_RELC
      int start;
      int length;
      int signed_p = 0;

      if (fixP->fx_cgen.field)
	{
	  /* Use the twisty little pointer path
	     back to the ifield if it exists.  */
	  start = fixP->fx_cgen.field->val.leaf->start;
	  length = fixP->fx_cgen.field->val.leaf->length;
	}
      else
	{
	  /* Or the far less useful operand-size guesstimate.  */
	  start = operand->start;
	  length = operand->length;
	}

      /* FIXME: this is not a perfect heuristic for figuring out
         whether an operand is signed: it only works when the operand
         is an immediate. it's not terribly likely that any other
         values will be signed relocs, but it's possible. */
      if (operand && (operand->hw_type == HW_H_SINT))
        signed_p = 1;
#endif

      /* If the reloc has been fully resolved finish the operand here.  */
      /* FIXME: This duplicates the capabilities of code in BFD.  */
      if (fixP->fx_done
	  /* FIXME: If partial_inplace isn't set bfd_install_relocation won't
	     finish the job.  Testing for pcrel is a temporary hack.  */
	  || fixP->fx_pcrel)
	{
	  CGEN_CPU_SET_FIELDS_BITSIZE (cd) (fields, CGEN_INSN_BITSIZE (insn));
	  CGEN_CPU_SET_VMA_OPERAND (cd) (cd, opindex, fields, (bfd_vma) value);

#if CGEN_INT_INSN_P
	  {
	    CGEN_INSN_INT insn_value =
	      cgen_get_insn_value (cd, (unsigned char *) where,
				   CGEN_INSN_BITSIZE (insn));

	    /* ??? 0 is passed for `pc'.  */
	    errmsg = CGEN_CPU_INSERT_OPERAND (cd) (cd, opindex, fields,
						   &insn_value, (bfd_vma) 0);
	    cgen_put_insn_value (cd, (unsigned char *) where,
				 CGEN_INSN_BITSIZE (insn), insn_value);
	  }
#else
	  /* ??? 0 is passed for `pc'.  */
	  errmsg = CGEN_CPU_INSERT_OPERAND (cd) (cd, opindex, fields,
						 (unsigned char *) where,
						 (bfd_vma) 0);
#endif
	  if (errmsg)
	    as_bad_where (fixP->fx_file, fixP->fx_line, "%s", errmsg);
	}

      if (fixP->fx_done)
	return;

      /* The operand isn't fully resolved.  Determine a BFD reloc value
	 based on the operand information and leave it to
	 bfd_install_relocation.  Note that this doesn't work when
	 partial_inplace == false.  */

      reloc_type = md_cgen_lookup_reloc (insn, operand, fixP);
#ifdef OBJ_COMPLEX_RELC
      if (reloc_type == BFD_RELOC_RELC)
	{
	  /* Change addend to "self-describing" form,
	     for BFD to handle in the linker.  */
	  value = gas_cgen_encode_addend (start, operand->length,
					  length, fixP->fx_size,
					  cd->insn_chunk_bitsize / 8,
					  signed_p,
					  ! (fixP->fx_cgen.msb_field_p));
	}
#endif

      if (reloc_type != BFD_RELOC_NONE)
	fixP->fx_r_type = reloc_type;
      else
	{
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("unresolved expression that must be resolved"));
	  fixP->fx_done = 1;
	  return;
	}
    }
  else if (fixP->fx_done)
    {
      /* We're finished with this fixup.  Install it because
	 bfd_install_relocation won't be called to do it.  */
      switch (fixP->fx_r_type)
	{
	case BFD_RELOC_8:
	  md_number_to_chars (where, value, 1);
	  break;
	case BFD_RELOC_16:
	  md_number_to_chars (where, value, 2);
	  break;
	case BFD_RELOC_32:
	  md_number_to_chars (where, value, 4);
	  break;
	case BFD_RELOC_64:
	  md_number_to_chars (where, value, 8);
	  break;
	default:
	  as_bad_where (fixP->fx_file, fixP->fx_line,
			_("internal error: can't install fix for reloc type %d (`%s')"),
			fixP->fx_r_type, bfd_get_reloc_code_name (fixP->fx_r_type));
	  break;
	}
    }
  /* else
     bfd_install_relocation will be called to finish things up.  */

  /* Tuck `value' away for use by tc_gen_reloc.
     See the comment describing fx_addnumber in write.h.
     This field is misnamed (or misused :-).  */
  fixP->fx_addnumber = value;
}

bfd_reloc_code_real_type
gas_cgen_pcrel_r_type (bfd_reloc_code_real_type r)
{
  switch (r)
    {
    case BFD_RELOC_8:  r = BFD_RELOC_8_PCREL;  break;
    case BFD_RELOC_16: r = BFD_RELOC_16_PCREL; break;
    case BFD_RELOC_24: r = BFD_RELOC_24_PCREL; break;
    case BFD_RELOC_32: r = BFD_RELOC_32_PCREL; break;
    case BFD_RELOC_64: r = BFD_RELOC_64_PCREL; break;
    default:
      break;
    }
  return r;
}

/* Translate internal representation of relocation info to BFD target format.

   FIXME: To what extent can we get all relevant targets to use this?  */

arelent *
gas_cgen_tc_gen_reloc (section, fixP)
     asection * section ATTRIBUTE_UNUSED;
     fixS *     fixP;
{
  bfd_reloc_code_real_type r_type = fixP->fx_r_type;
  arelent *reloc;

  reloc = (arelent *) xmalloc (sizeof (arelent));

#ifdef GAS_CGEN_PCREL_R_TYPE
  if (fixP->fx_pcrel)
    r_type = GAS_CGEN_PCREL_R_TYPE (r_type);
#endif
  reloc->howto = bfd_reloc_type_lookup (stdoutput, r_type);

  if (reloc->howto == (reloc_howto_type *) NULL)
    {
      as_bad_where (fixP->fx_file, fixP->fx_line,
		    _("relocation is not supported"));
      return NULL;
    }

  gas_assert (!fixP->fx_pcrel == !reloc->howto->pc_relative);

  reloc->sym_ptr_ptr = (asymbol **) xmalloc (sizeof (asymbol *));
  *reloc->sym_ptr_ptr = symbol_get_bfdsym (fixP->fx_addsy);

  /* Use fx_offset for these cases.  */
  if (fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY
      || fixP->fx_r_type == BFD_RELOC_VTABLE_INHERIT)
    reloc->addend = fixP->fx_offset;
  else
    reloc->addend = fixP->fx_addnumber;

  reloc->address = fixP->fx_frag->fr_address + fixP->fx_where;
  return reloc;
}

/* Perform any cgen specific initialisation.
   Called after gas_cgen_cpu_desc has been created.  */

void
gas_cgen_begin ()
{
  if (flag_signed_overflow_ok)
    cgen_set_signed_overflow_ok (gas_cgen_cpu_desc);
  else
    cgen_clear_signed_overflow_ok (gas_cgen_cpu_desc);
}
@


1.40
log
@	* cgen.c (gas_cgen_parse_operand): Do not set BSF_RELC flag on
	local symbols.
@
text
@d3 1
a3 1
   2006, 2007, 2009, 2010, 2011 Free Software Foundation, Inc.
d21 1
a22 1
#include "as.h"
@


1.39
log
@	* cgen.c (gas_cgen_pcrel_r_type): New function.
	(gas_cgen_tc_gen_reloc): Check for GAS_CGEN_PCREL_R_TYPE.
	* cgen.h (gas_cgen_pcrel_r_type): Declare.
@
text
@d486 2
a487 1
	  if (stmp->bsym && (stmp->bsym->section == expr_section))
@


1.38
log
@	* config/obj-evax.h (S_SET_OTHER, S_SET_TYPE, S_SET_DESC): Don't define.
	* config/tc-crx.c (gettrap): Constify arg.
	(handle_LoadStor, get_cinv_parameters): Likewise.
	(getreg_image): Fix enum warning
	(md_assemble): Restore input line char.
	* config/tc-hppa.c (tc_gen_reloc): Fix enum warning.
	* config/tc-i960.c (mem_fmt): Rename var to fix shadow warning.
	* config/tc-sh.c (sh_fdpic): Only define when OBJ_ELF.
	(build_Mytes): Fix build failure for non-elf targets.
	* config/tc-tic4x.c (tic4x_eval): Restore terminator char.
	* config/tc-xtensa.c (xtensa_end_directive): Fix switch enum warning.

	* cgen.c (gas_cgen_md_apply_fix): Avoid set but unused warning.
	* ecoff.c (add_ecoff_symbol): Likewise.
	* itbl-ops.c (append_insns_as_macros): Likewise.
	* listing.c (debugging_pseudo): Likewise.
	* read.c (s_mri_common, stringer): Likewise.
	* config/obj-coff.c (coff_frob_section): Likewise.
	* config/tc-alpha.c (emit_ldgp, s_alpha_proc): Likewise.
	* config/tc-arm.c (my_get_expression): Likewise.
	* config/tc-hppa.c (process_exit, pa_type_args): Likewise.
	* config/tc-m32c.c (md_assemble): Likewise.
	* config/tc-microblaze.c (md_convert_frag): Likewise.
	* config/tc-mips.c (s_change_section): Likewise.
	* config/tc-mt.c (mt_fix_adjustable): Likewise.
	* config/tc-xtensa.c (xtensa_literal_pseudo): Likewise.

	* config/obj-aout.c (obj_aout_frob_symbol): Delete set but otherwise
	unused vars.
	* config/tc-alpha.c (load_expression): Likewise.
	(s_alpha_rdata, s_alpha_section, s_alpha_prologue): Likewise.
	* config/tc-arm.c (parse_neon_el_struct_list): Likewise.
	* config/tc-avr.c (extract_word): Likewise.
	* config/tc-cris.c (cris_get_expression): Likewise.
	* config/tc-d30v.c (build_insn, find_format): Likewise.
	* config/tc-dlx.c (machine_ip): Likewise.
	* config/tc-hppa.c (pa_get_absolute_expression): Likewise.
	* config/tc-i370.c (md_assemble): Likewise.
	* config/tc-i960.c (brtab_emit): Likewise.
	* config/tc-iq2000.c (s_iq2000_ent): Likewise.
	* config/tc-m32c.c (md_convert_frag): Likewise.
	* config/tc-m68hc11.c (fixup24, build_jump_insn): Likewise.
	(md_estimate_size_before_relax, md_apply_fix): Likewise.
	* config/tc-m68k.c (md_show_usage): Likewise.
	* config/tc-microblaze.c (microblaze_s_lcomm): Likewise.
	* config/tc-mips.c (s_mips_end): Likewise.
	* config/tc-mmix.c (mmix_byte, mmix_cons): Likewise.
	* config/tc-mn10300.c (md_assemble): Likewise.
	* config/tc-msp430.c (extract_word): Likewise.
	* config/tc-mt.c (md_assemble): Likewise.
	* config/tc-or32.c (machine_ip): Likewise.
	* config/tc-pj.c (md_apply_fix): Likewise.
	* config/tc-s390.c (md_gather_operands): Likewise.
	* config/tc-sh.c (sh_cons_align): Likewise.
	* config/tc-sparc.c (sparc_cons_align): Likewise.
	* config/tc-tic4x.c (tic4x_sect): Likewise.
	* config/tc-tic54x.c (tic54x_stringer): Likewise.
	* config/tc-vax.c (vip_op): Likewise.
	* config/tc-xstormy16.c (xstormy16_cons_fix_new): Likewise.
	* config/tc-xtensa.c (md_assemble): Likewise.
	(xtensa_fix_short_loop_frags, convert_frag_immed): Likewise.
	(xtensa_move_literals): Likewise.
@
text
@d3 1
a3 1
   2006, 2007, 2009, 2010 Free Software Foundation, Inc.
d1021 16
d1046 1
d1048 1
d1051 6
a1056 1
  reloc->howto = bfd_reloc_type_lookup (stdoutput, fixP->fx_r_type);
@


1.37
log
@	* cgen.c: Whitespace fixes.
	(weak_operand_overflow_check): Formatting fix.
@
text
@d3 1
a3 1
   2006, 2007, 2009 Free Software Foundation, Inc.
d896 1
d921 1
@


1.36
log
@update copyright dates
@
text
@d413 1
a413 1
#endif 
d469 2
a470 2
	    } 
	  else 
d474 1
a474 1
	     need to subtract "." from the expression.  */	  
d477 1
a477 1
 	    stmp = expr_build_binary (O_subtract, stmp, expr_build_dot ()); 
d485 1
a485 1
	  
d493 1
a493 1
	  
d499 1
a499 1
	      
d502 1
a502 1
	  queue_fixup_recursively (opindex, opinfo_1, & exp,  
d515 1
a515 1
#endif      
d713 1
a713 1
  
d715 1
a715 1
	queue_fixup_recursively (opindex, opinfo, expP, 
d734 1
a734 1
	    new_exp = make_right_shifted_expr (expP, rightshift, signed_p);	  
d736 1
a736 1
      
d740 1
a740 1
      
d747 1
a747 1
static unsigned long 
d777 1
a777 1
   
d797 1
a797 1
      if (CGEN_OPERAND_ATTR_VALUE 
d802 1
a802 1
  
d805 2
a806 2
  if (exp->X_add_symbol &&
      exp->X_add_symbol->sy_value.X_op == O_constant)
d809 2
a810 2
  if (exp->X_op_symbol &&
      exp->X_op_symbol->sy_value.X_op == O_constant)
d813 1
a813 1
  /* Want to know if mask covers more bits than opmask. 
d825 1
a825 1
  return NULL;  
a827 1

d836 1
a836 1
  stmp = expr_build_binary (O_right_shift, 
d839 1
a839 1
  
d844 1
a844 1
  
d852 1
a852 1
  
d855 1
d857 1
d901 1
a901 1
	{	      
d968 3
a970 3
					  length, fixP->fx_size, 
					  cd->insn_chunk_bitsize / 8, 
					  signed_p, 
@


1.35
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d3 1
a3 1
   2006, 2007 Free Software Foundation, Inc.
@


1.34
log
@* cgen.c (gas_cgen_parse_operand): Guard against NULL pointers.
@
text
@d1038 1
a1038 1
  assert (!fixP->fx_pcrel == !reloc->howto->pc_relative);
a1064 1

@


1.33
log
@Switch to GPLv3
@
text
@d455 4
a458 3
	      && exp.X_add_symbol->bsym->section != expr_section
	      && exp.X_add_symbol->bsym->section != absolute_section
	      && exp.X_add_symbol->bsym->section != undefined_section)
@


1.32
log
@Support for Toshiba MeP and for complex relocations.
@
text
@d3 1
a3 1
   2006 Free Software Foundation, Inc.
d9 1
a9 1
   the Free Software Foundation; either version 2, or (at your option)
d12 4
a15 4
   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
@


1.31
log
@remove some duplicate #include's.
@
text
@d29 21
d87 2
d272 2
d312 2
d318 14
d349 4
d354 1
d375 7
d439 72
d514 1
d682 2
d695 161
d894 24
d960 12
a1026 1

d1064 1
@


1.30
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@d2 2
a3 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
   Free Software Foundation, Inc.
d22 1
a22 3
#include "ansidecl.h"
#include "libiberty.h"
#include "bfd.h"
a24 1
#include "as.h"
@


1.29
log
@Update the address and phone number of the FSF
@
text
@d228 1
a228 1
   operand type.  We pick a BFD reloc type in md_apply_fix3.  */
d267 1
a267 1
   operand type.  We pick a BFD reloc type in md_apply_fix3.  */
d583 1
a583 1
gas_cgen_md_apply_fix3 (fixP, valP, seg)
@


1.28
log
@Fix typo introduced byprevious delta.
@
text
@d19 1
a19 1
   Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.27
log
@(gas_cgen_parse_operand): Copy opinfo parameter into a local variable in case
it is clobbered by the setjmp.
@
text
@d362 1
a362 1
  opinfo = TC_CGEN_PARSE_FIX_EXP (opinfo_1, & exp);
@


1.26
log
@	* cgen.c: Warning fixes.
	* config/tc-arc.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-d10v.c: Likewise.
	* config/tc-d30v.c: Likewise.
	* config/tc-frv.c: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-ia64.c: Likewise.
	* config/tc-ip2k.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh64.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-xstormy16.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@d323 1
d327 1
d341 1
d362 1
a362 1
  opinfo = TC_CGEN_PARSE_FIX_EXP (opinfo, & exp);
d389 1
a389 1
      queue_fixup (opindex, opinfo, &exp);
@


1.25
log
@bfd/ChangeLog:
2004-12-10  Alexandre Oliva  <aoliva@@redhat.com>
* elf32-frv.c (elf32_frv_relocate_section): Force local binding
for TLSMOFF.
* reloc.c: Add R_FRV_TLSMOFF.
* elf32-frv.c (elf32_frv_howto_table): Likewise.
(frv_reloc_map, frv_reloc_type_lookup): Map it.
(elf32_frv_relocate_section): Handle it.
(elf32_frv_check_relocs): Likewise.
* libbfd.h, bfd-in2.h: Rebuilt.
2004-11-26  Alexandre Oliva  <aoliva@@redhat.com>
* elf32-frv.c (_frvfdpic_emit_got_relocs_plt_entries): Don't crash
when given an undefweak TLS symbol.  Fix constant TLS PLT entries
such that they return the constant in gr9.
(_frvfdpic_relax_tls_entries): Don't crash for undefweak TLS
symbols.
(_frvfdpic_size_got_plt): Set _cooked_size of dynamic sections.
too, such that they shrink on relaxation.
(elf32_frvfdpic_finish_dynamic_sections): Check __ROFIXUP_END__ as
marking the position right past the _GLOBAL_OFFSET_TABLE_ value.
(_frvfdpic_assign_plt_entries): Shrink constant TLS PLT entries
if we can guarantee the use of 16-bit constants.
2004-11-10  Alexandre Oliva  <aoliva@@redhat.com>
Introduce TLS support for FR-V FDPIC.
* reloc.c: Add TLS relocations.
* elf32-frv.c (elf32_frv_howto_table): Add TLS relocations.
(elf32_frv_rel_tlsdesc_value_howto): New.
(elf32_frv_rel_tlsoff_howto): New.
(frv_reloc_map): Add new mappings.
(struct frvfdpic_elf_link_hash_table): Add pointer to summary
reloc information.
(frvfdpic_dynamic_got_plt_info): New.
(frvfdpic_plt_tls_ret_offset): New.
(ELF_DYNAMIC_INTERPRETER, DEFAULT_STACK_SIZE): Move earlier.
(struct _frvfdpic_dynamic_got_info): Likewise.  Add TLS members.
(struct _frvfdpic_dynamic_got_plt_info): Likewise.
(FRVFDPIC_SYM_LOCAL): Regard symbols defined in the absolute
section as local.
(struct frvfdpic_relocs_info): Add TLS fields.
(frvfdpic_relocs_info_hash): Warning clean up.
(frvfdpic_relocs_info_find): Initialize tlsplt_entry.
(frvfdpic_pic_merge_early_relocs_info): Merge TLS fields.
(FRVFDPIC_TLS_BIAS): Define.
(tls_biased_base): New.
(_frvfdpic_emit_got_relocs_plt_entries): Deal with TLS
relocations.
(frv_reloc_type_lookup): Likewise.
(frvfdpic_info_to_howto_rel): Likewise.
(elf32_frv_relocate_section): Likewise.
(_frv_create_got_section): Create the PLT section here.
(elf32_frvfdpic_create_dynamic_sections): Not here.
(_frvfdpic_count_nontls_entries): Move out of...
(_frvfdpic_count_got_plt_entries): ... here.
(_frvfdpic_count_tls_entries): Likewise.  Add TLS support.
(_frvfdpic_count_relocs_fixups): Likewise.  Add relaxation
support.
(_frvfdpic_relax_tls_entries): New.
(_frvfdpic_compute_got_alloc_data): Add TLS support.
(_frvfdpic_get_tlsdesc_entry): New.
(_frvfdpic_assign_got_entries): Add TLS support.
(_frvfdpic_assign_plt_entries): Likewise.
(_frvfdpic_reset_got_plt_entries): New.
(_frvfdpic_size_got_plt): Move out of...
(elf32_frvfdpic_size_dynamic_sections): ... here.
(_frvfdpic_relax_got_plt_entries): New.
(elf32_frvfdpic_relax_section): New.
(elf32_frvfdpic_finish_dynamic_sections): Add TLS sanity check.
(elf32_frv_check_relocs): Add TLS support.
(bfd_elf32_bfd_relax_section): Define for FDPIC.
* libbfd.h, bfd-in2.h: Rebuilt.
cpu/ChangeLog:
2004-11-10  Alexandre Oliva  <aoliva@@redhat.com>
* frv.cpu: Add support for TLS annotations in loads and calll.
* frv.opc (parse_symbolic_address): New.
(parse_ldd_annotation): New.
(parse_call_annotation): New.
(parse_ld_annotation): New.
(parse_ulo16, parse_uslo16): Use parse_symbolic_address.
Introduce TLS relocations.
(parse_d12, parse_s12, parse_u12): Likewise.
(parse_uhi16): Likewise.  Fix constant checking on 64-bit host.
(parse_call_label, print_at): New.
gas/ChangeLog:
* config/tc-frv.c (md_apply_fix3): Mark TLS symbols as such.
2004-12-10  Alexandre Oliva  <aoliva@@redhat.com>
* config/tc-frv.c (frv_pic_ptr): Add tlsmoff support.
2004-11-10  Alexandre Oliva  <aoliva@@redhat.com>
* cgen.c (gas_cgen_parse_operand): Handle
CGEN_PARSE_OPERAND_SYMBOLIC.
* config/tc-frv.c (md_cgen_lookup_reloc): Handle TLS relocations.
(frv_force_relocation): Likewise.  Fix handling of PIC
relocations.
(md_apply_fix3): Likewise.
include/elf/ChangeLog:
2004-12-10  Alexandre Oliva  <aoliva@@redhat.com>
* frv.h: Add R_FRV_TLSMOFF.
2004-11-10  Alexandre Oliva  <aoliva@@redhat.com>
* frv.h: Add TLS relocations.
include/opcode/ChangeLog:
2004-11-10  Alexandre Oliva  <aoliva@@redhat.com>
* cgen.h (enum cgen_parse_operand_type): Add
CGEN_PARSE_OPERAND_SYMBOLIC.
ld/testsuite/ChangeLog:
* ld-frv/fdpic.exp: Add -mfdpic to ASFLAGS.
* ld-frv/tls.exp: Likewise.
2004-11-26  Alexandre Oliva  <aoliva@@redhat.com>
* ld-frv/tls-3.s: New.
* ld-frv/tls-static-3.d: New.
* ld-frv/tls-dynamic-3.d: New.
* ld-frv/tls-pie-3.d: New.
* ld-frv/tls-shared-3.d: New.
* ld-frv/tls-relax-static-3.d: New.
* ld-frv/tls-relax-dynamic-3.d: New.
* ld-frv/tls-relax-pie-3.d: New.
* ld-frv/tls-relax-shared-3.d: New.
* ld-frv/tls.exp: Run the new tests.
* ld-frv/tls-dynamic-2.d: Adjust for improved relaxation.
* ld-frv/tls-relax-dynamic-2.d: Likewise.
* ld-frv/tls-relax-initial-shared-2.d: Likewise.
2004-11-10  Alexandre Oliva  <aoliva@@redhat.com>
* ld-frv/tls-1-dep.s: New.
* ld-frv/tls-1-shared.lds: New.
* ld-frv/tls-1.s: New.
* ld-frv/tls-2.s: New.
* ld-frv/tls-dynamic-1.d: New.
* ld-frv/tls-dynamic-2.d: New.
* ld-frv/tls-initial-shared-2.d: New.
* ld-frv/tls-pie-1.d: New.
* ld-frv/tls-relax-dynamic-1.d: New.
* ld-frv/tls-relax-dynamic-2.d: New.
* ld-frv/tls-relax-initial-shared-2.d: New.
* ld-frv/tls-relax-pie-1.d: New.
* ld-frv/tls-relax-shared-1.d: New.
* ld-frv/tls-relax-shared-2.d: New.
* ld-frv/tls-relax-static-1.d: New.
* ld-frv/tls-shared-1-fail.d: New.
* ld-frv/tls-shared-1.d: New.
* ld-frv/tls-shared-2.d: New.
* ld-frv/tls-static-1.d: New.
* ld-frv/tls.exp: New.
* ld-frv/fdpic-pie-1.d: Adjust for 64-bit host.
* ld-frv/fdpic-pie-2.d: Likewise.
* ld-frv/fdpic-pie-6.d: Likewise.
* ld-frv/fdpic-pie-7.d: Likewise.
* ld-frv/fdpic-pie-8.d: Likewise.
* ld-frv/fdpic-shared-1.d: Likewise.
* ld-frv/fdpic-shared-2.d: Likewise.
* ld-frv/fdpic-shared-3.d: Likewise.
* ld-frv/fdpic-shared-4.d: Likewise.
* ld-frv/fdpic-shared-5.d: Likewise.
* ld-frv/fdpic-shared-6.d: Likewise.
* ld-frv/fdpic-shared-7.d: Likewise.
* ld-frv/fdpic-shared-8.d: Likewise.
* ld-frv/fdpic-shared-local-2.d: Likewise.
* ld-frv/fdpic-shared-local-8.d: Likewise.
* ld-frv/fdpic-static-1.d: Likewise.
* ld-frv/fdpic-static-2.d: Likewise.
* ld-frv/fdpic-static-6.d: Likewise.
* ld-frv/fdpic-static-7.d: Likewise.
* ld-frv/fdpic-static-8.d: Likewise.
opcodes/ChangeLog:
2004-11-10  Alexandre Oliva  <aoliva@@redhat.com>
* frv-asm.c: Rebuilt.
* frv-desc.c: Rebuilt.
* frv-desc.h: Rebuilt.
* frv-dis.c: Rebuilt.
* frv-ibld.c: Rebuilt.
* frv-opc.c: Rebuilt.
* frv-opc.h: Rebuilt.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d525 1
a525 1
  cgen_put_insn_value (gas_cgen_cpu_desc, f, length, *buf);
d619 2
a620 1
	      cgen_get_insn_value (cd, where, CGEN_INSN_BITSIZE (insn));
d625 2
a626 2
	    cgen_put_insn_value (cd, where, CGEN_INSN_BITSIZE (insn),
				 insn_value);
d630 2
a631 1
	  errmsg = CGEN_CPU_INSERT_OPERAND (cd) (cd, opindex, fields, where,
@


1.24
log
@Add support for M32R GOT relocs
@
text
@d375 2
d384 1
@


1.23
log
@	* app.c: Convert to ISO-C.
	* as.h: Likewise.
	* atof-generic.c: Likewise.
	* bignum-copy.c: Likewise.
	* bignum.h: Likewise.
	* cgen.c: Likewise.
	* cgen.h: Likewise.
	* cond.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d358 4
@


1.22
log
@opcodes:
	* cgen-asm.in (@@arch@@_cgen_assemble_insn): CGEN_INSN_RELAX renamed to
	CGEN_INSN_RELAXED.
	* fr30-asm.c,fr30-desc.c,fr30-desc.h: Regenerate.
	* frv-asm.c,frv-desc.c,frv-desc.h: Regenerate.
	* ip2k-asm.c,ip2k-desc.c,ip2k-desc.h: Regenerate.
	* iq2000-asm.c,iq2000-desc.c,iq2000-desc.h: Regenerate.
	* m32r-asm.c,m32r-desc.c,m32r-desc.h,m32r-opc.c: Regenerate.
	* openrisc-asm.c,openrisc-desc.c,openrisc-desc.h: Regenerate.
	* xstormy16-asm.c,xstormy16-desc.c,xstormy16-desc.h: Regenerate.
gas:
	* cgen.c (gas_cgen_finish_insn): CGEN_INSN_RELAX renamed to
	CGEN_INSN_RELAXED.
	* config/tc-fr30.c (md_estimate_size_before_relax): Ditto.
	* config/tc-m32r.c (md_estimate_size_before_relax): Ditto.
	* config/tc-openrisc.c (md_estimate_size_before_relax): Ditto.
@
text
@d32 1
a32 1
static void queue_fixup PARAMS ((int, int, expressionS *));
@


1.21
log
@* as.c (perform_an_assembly_pass): If using cgen, call gas_cgen_begin.
* cgen.c (gas_cgen_begin): New function.  If flag_signed_overflow_ok is set
call cgen_set_signed_overflow_ok otherwise call cgen_clear_signed_overflow_ok.
* cgen.h: Prototype gas_cgen_begin.
* testsuite/gas/m32r/m32r.exp: Run signed-relocs test.
* testsuite/gas/m32r/signed-relocs.s: New file: Test signed relocs.
* testsuite/gas/m32r/signed-relocs.d: New file: Expected results
@
text
@d434 1
a434 1
  if (CGEN_INSN_ATTR_VALUE (insn, CGEN_INSN_RELAX))
d534 1
a534 1
	 We don't need to test for CGEN_INSN_RELAX as they can't get here
@


1.20
log
@Fix typo: intial -> initial.
@
text
@d719 12
@


1.19
log
@gas reloc rewrite.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002
d5 1
a5 1
This file is part of GAS, the GNU Assembler.
d7 13
a19 13
GAS is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GAS is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GAS; see the file COPYING.  If not, write to the Free Software
Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d64 2
a65 1
struct fixup {
d116 1
a116 1
      fixup count in each element to be set to 0 intially.  This is
d134 2
a135 1
struct saved_fixups {
a244 1

a282 1

@


1.18
log
@	* as.h: Fix formatting.
	* cgen.c: Likewise.
	* cgen.h: Likewise.
	* dwarf2dbg.c: Likewise.
	* frags.h: Likewise.
	* gasp.c: Likewise.
	* macro.c: Likewise.
	* read.c: Likewise.
	* stabs.c: Likewise.
	* symbols.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
a582 11
  /* FIXME FIXME FIXME: The value we are passed in *valuep includes
     the symbol values.  Since we are using BFD_ASSEMBLER, if we are
     doing this relocation the code in write.c is going to call
     bfd_install_relocation, which is also going to use the symbol
     value.  That means that if the reloc is fully resolved we want to
     use *valuep since bfd_install_relocation is not being used.
     However, if the reloc is not fully resolved we do not want to use
     *valuep, and must use fx_offset instead.  However, if the reloc
     is PC relative, we do want to use *valuep since it includes the
     result of md_pcrel_from.  This is confusing.  */

d586 3
a588 19
  else if (fixP->fx_pcrel)
    ;

  else
    {
      value = fixP->fx_offset;

      if (fixP->fx_subsy != (symbolS *) NULL)
	{
	  if (S_GET_SEGMENT (fixP->fx_subsy) == absolute_section)
	    value -= S_GET_VALUE (fixP->fx_subsy);
	  else
	    {
	      /* We don't actually support subtracting a symbol.  */
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("expression too complex"));
	    }
	}
    }
@


1.17
log
@Fix compile time warning messages.
@
text
@d108 2
a109 2
   The algorithms used are the same as in the old scheme.  Other than the 
   "array-ness" of the whole thing, the functionality is identical to the 
d176 1
a176 1
  memcpy (fixups,stored_fixups[i].fixup_chain,
@


1.16
log
@Update all uses of md_apply_fix to use md_apply_fix3.  Make it a void function.
@
text
@d32 2
d327 1
a327 1
  const char *errmsg = NULL;
d353 1
@


1.15
log
@Fix formatting
@
text
@d224 1
a224 1
   operand type.  We pick a BFD reloc type in md_apply_fix.  */
d264 1
a264 1
   operand type.  We pick a BFD reloc type in md_apply_fix.  */
d569 2
a570 2
int
gas_cgen_md_apply_fix3 (fixP, valueP, seg)
d572 1
a572 1
     valueT * valueP;
d576 1
a576 1
  valueT value;
d592 2
a593 4
    {
      value = *valueP;
      fixP->fx_done = 1;
    }
d595 2
a596 1
    value = *valueP;
d600 1
d654 1
a654 1
	return 1;
d662 1
d664 1
a664 3
	{
	  fixP->fx_r_type = reloc_type;
	}
d670 1
a670 1
	  return 1;
a704 2

  return 1;
@


1.14
log
@	* read.c: Standardize error/warning messages - don't capitalise, no
	final period or newline, don't say "ignored" or "zero assumed" for
	as_bad messages.  In some cases, change the wording to that used
	elsewhere for similar messages.
	* app.c, as.c, atof-generic.c, cgen.c, cond.c, depend.c, dwarf2dbg.c,
	  ecoff.c, expr.c, frags.c, input-file.c, input-scrub.c, listing.c,
	  output-file.c, stabs.c, subsegs.c, symbols.c, write.c: Likewise.
	* ecoff.c (ecoff_directive_end): Test for missing name by
	comparing input line pointers rather than reading string.
	(ecoff_directive_ent): Likewise.
	* read.c (s_set): Likewise.
	(s_align): Report a warning rather than an error for
	alignment too large.
	(s_comm): Check for missing symbol name.
	(s_lcomm_internal): Likewise.
	(s_lsym): Likewise.
	(s_globl): Use is_end_of_line instead of looking for '\n'.
	(s_lcomm_internal): Likewise.
	(ignore_rest_of_line): Report a warning rather than an error.
@
text
@d132 2
a133 2
     struct fixup fixup_chain[GAS_CGEN_MAX_FIXUPS];
     int num_fixups_in_chain;
d138 1
a138 1
void 
d141 4
a144 3
   int i = 0;
   while (i < MAX_SAVED_FIXUP_CHAINS)
      stored_fixups[i++].num_fixups_in_chain = 0;
d147 3
a149 2
void 
gas_cgen_save_fixups (int i)
d151 10
a160 9
      if (i < 0 || i >= MAX_SAVED_FIXUP_CHAINS)
      {
          as_fatal("index into stored_fixups[] out of bounds");
          return;
      }
      stored_fixups[i].num_fixups_in_chain = num_fixups;
      memcpy(stored_fixups[i].fixup_chain, fixups,
                    sizeof (fixups[0])*num_fixups);
      num_fixups = 0;
d163 3
a165 2
void 
gas_cgen_restore_fixups (int i)
d167 10
a176 9
      if (i < 0 || i >= MAX_SAVED_FIXUP_CHAINS)
      {
          as_fatal("index into stored_fixups[] out of bounds");
          return;
      }
      num_fixups = stored_fixups[i].num_fixups_in_chain;
      memcpy(fixups,stored_fixups[i].fixup_chain,
                    (sizeof (stored_fixups[i].fixup_chain[0]))*num_fixups);
      stored_fixups[i].num_fixups_in_chain = 0;
d179 3
a181 2
void 
gas_cgen_swap_fixups (int i)
d183 8
a190 2
     int tmp;
     struct fixup tmp_fixup;
d192 18
a209 26
     if (i < 0 || i >= MAX_SAVED_FIXUP_CHAINS)
     {
         as_fatal("index into stored_fixups[] out of bounds");
         return;
     }

     if (num_fixups == 0)
     {
       gas_cgen_restore_fixups (i);
     }
     else if (stored_fixups[i].num_fixups_in_chain == 0)
     {
       gas_cgen_save_fixups (i);
     }
     else
     {
       tmp = stored_fixups[i].num_fixups_in_chain;
       stored_fixups[i].num_fixups_in_chain = num_fixups;
       num_fixups = tmp;

       for (tmp = GAS_CGEN_MAX_FIXUPS; tmp--;)
       {
         tmp_fixup          = stored_fixups[i].fixup_chain [tmp];
         stored_fixups[i].fixup_chain[tmp] = fixups [tmp];
         fixups [tmp]       = tmp_fixup;
       }
d345 1
a345 1
      return "illegal operand";
d699 2
a700 4
  else
    {
      /* bfd_install_relocation will be called to finish things up.  */
    }
@


1.13
log
@2001-07-06  John Healy  <jhealy@@redhat.com>

        * cgen.c (gas_cgen_save_fixups): Modified to allow more than one
        set of fixups to be stored.
        (gas_cgen_restore_fixups): Modified to allow the fixup chain to be
        restored to be chosen from any that are saved.
        (gas_cgen_swap_fixups): Modified to allow the current set of
        fixups to be swapped with any other set that has been saved.
        (gas_cgen_initialize_saved_fixups_array): New routine.
        * cgen.h: Modifed prototypes for gas_cgen_save_fixups,
        gas_cgen_restore_fixups, and gas_cgen_swap_fixups.  Added definitions
        or MAX_SAVED_FIXUP_CHAINS.
        * config/tc-m32r.c (assemble_two_insns): Changed calls to fixup
        store, swap and restore fuctions to reflect the new interface.
@
text
@d151 1
a151 1
          as_fatal("Index into stored_fixups[] out of bounds.");
d165 1
a165 1
          as_fatal("Index into stored_fixups[] out of bounds.");
d182 1
a182 1
         as_fatal("Index into stored_fixups[] out of bounds.");
@


1.12
log
@
2001-05-16  Jeff Johnston  <jjohnstn@@redhat.com>

        * cgen.c (gas_cgen_tc_gen_reloc): Changed error message when
        howto entry is not found.

Fix for 105023-CR-1.
@
text
@d97 38
a134 6
/* The following three functions allow a backup of the fixup chain to be made,
   and to have this backup be swapped with the current chain.  This allows
   certain ports, eg the m32r, to swap two instructions and swap their fixups
   at the same time.  */
/* ??? I think with cgen_asm_finish_insn (or something else) there is no
   more need for this.  */
d136 1
a136 2
static struct fixup saved_fixups[GAS_CGEN_MAX_FIXUPS];
static int saved_num_fixups;
d138 2
a139 2
void
gas_cgen_save_fixups ()
d141 4
a144 1
  saved_num_fixups = num_fixups;
d146 12
a157 3
  memcpy (saved_fixups, fixups, sizeof (fixups[0]) * num_fixups);

  num_fixups = 0;
d160 2
a161 2
void
gas_cgen_restore_fixups ()
d163 9
a171 5
  num_fixups = saved_num_fixups;

  memcpy (fixups, saved_fixups, sizeof (fixups[0]) * num_fixups);

  saved_num_fixups = 0;
d174 2
a175 2
void
gas_cgen_swap_fixups ()
d177 2
a178 2
  int tmp;
  struct fixup tmp_fixup;
d180 26
a205 20
  if (num_fixups == 0)
    {
      gas_cgen_restore_fixups ();
    }
  else if (saved_num_fixups == 0)
    {
      gas_cgen_save_fixups ();
    }
  else
    {
      tmp = saved_num_fixups;
      saved_num_fixups = num_fixups;
      num_fixups = tmp;

      for (tmp = GAS_CGEN_MAX_FIXUPS; tmp--;)
	{
	  tmp_fixup          = saved_fixups [tmp];
	  saved_fixups [tmp] = fixups [tmp];
	  fixups [tmp]       = tmp_fixup;
	}
@


1.11
log
@Teach .org to handle complex expressions
@
text
@d672 1
a672 2
		    _("internal error: can't export reloc type %d (`%s')"),
		    fixP->fx_r_type, bfd_get_reloc_code_name (fixP->fx_r_type));
@


1.10
log
@Fix copyright notices
@
text
@d401 3
d420 10
d436 2
a437 2
		fixups[relax_operand].exp.X_add_symbol,
		fixups[relax_operand].exp.X_add_number,
@


1.9
log
@2001-02-16  matthew green  <mrg@@redhat.com>

 	* gas/cgen.c (gas_cgen_md_apply_fix3): Support BFD_RELOC_64.
@
text
@d2 2
a3 1
   Copyright (C) 1996, 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
@


1.8
log
@* gas/cgen feature

2001-01-12  Frank Ch. Eigler  <fche@@redhat.com>

	* cgen.c (gas_cgen_finish_insn): Call dwarf2_emit_insn.
@
text
@d618 3
a620 1
	/* FIXME: later add support for 64 bits.  */
@


1.8.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001
   Free Software Foundation, Inc.
@


1.8.2.2
log
@Merge from mainline.
@
text
@a400 3
      expressionS *exp;
      symbolS *sym;
      offsetT off;
a416 10
      exp = &fixups[relax_operand].exp;
      sym = exp->X_add_symbol;
      off = exp->X_add_number;
      if (exp->X_op != O_constant && exp->X_op != O_symbol)
	{
	  /* Handle complex expressions.  */
	  sym = make_expr_symbol (exp);
	  off = 0;
	}

d423 2
a424 2
		sym,
		off,
d619 1
a619 3
	case BFD_RELOC_64:
	  md_number_to_chars (where, value, 8);
	  break;
d657 2
a658 1
		    _("relocation is not supported"));
@


1.7
log
@2000-10-12  Kazu Hirata  <kazu@@hxi.com>

	* app.c: Fix formatting.
	* as.c: Likewise.
	* as.h: Likewise.
	* bit_fix.h: Likewise.
	* cgen.c: Likewise.
	* cgen.h: Likewise.
	* cond.c: Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
d29 1
d448 3
@


1.6
log
@2000-09-03  Kazu Hirata  <kazu@@hxi.com>

	* cgen.c: Fix formatting.
	* config/tc-ia64.c: Likewise.
@
text
@d60 1
a60 2
struct fixup
{
d89 1
a89 1
  fixups[num_fixups].exp     = * expP;
d317 1
a317 1
      queue_fixup (opindex, opinfo, & exp);
@


1.5
log
@Add --pcrel option to m68k port
@
text
@d18 1
a18 1
Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA. */
d40 1
a40 1
     char * name;
d46 1
a46 1
				      number, & zero_address_frag));
d67 1
a67 1
static struct fixup fixups [GAS_CGEN_MAX_FIXUPS];
d103 1
a103 1
static struct fixup saved_fixups [GAS_CGEN_MAX_FIXUPS];
d110 1
a110 1
  
d120 1
a120 1
  
d145 1
a145 1
      
d179 1
a179 1
  fixS * fixP;
d218 1
a218 1
  fixS * fixP;
d253 1
a253 1
     const char ** strP;
d256 2
a257 2
     enum cgen_parse_operand_result * resultP;
     bfd_vma * valueP;
d264 2
a265 2
  static char * hold;
  static enum cgen_parse_operand_result * resultP_1;
d267 1
a267 1
  const char * errmsg = NULL;
d278 1
a278 1
  input_line_pointer = (char *) * strP;
d286 1
a286 1
      * resultP_1 = CGEN_PARSE_OPERAND_RESULT_ERROR;
d291 1
a291 1
  expression (& exp);
d294 1
a294 1
  * strP = input_line_pointer;
d301 1
a301 1
    case O_illegal :
d303 1
a303 1
      * resultP = CGEN_PARSE_OPERAND_RESULT_ERROR;
d305 1
a305 1
    case O_absent :
d307 1
a307 1
      * resultP = CGEN_PARSE_OPERAND_RESULT_ERROR;
d309 3
a311 3
    case O_constant :
      * valueP = exp.X_add_number;
      * resultP = CGEN_PARSE_OPERAND_RESULT_NUMBER;
d313 3
a315 3
    case O_register :
      * valueP = exp.X_add_number;
      * resultP = CGEN_PARSE_OPERAND_RESULT_REGISTER;
d317 1
a317 1
    default :
d319 2
a320 2
      * valueP = 0;
      * resultP = CGEN_PARSE_OPERAND_RESULT_QUEUED;
d334 1
a334 1
     expressionS * expressionP ATTRIBUTE_UNUSED;
d350 1
a350 1
     const CGEN_INSN * insn;
d354 1
a354 1
     finished_insnS * result;
d358 1
a358 1
  char * f;
d374 2
a375 1
    abort (); /* These currently shouldn't get here.  */
d385 1
a385 1
      for (i = 0; i < num_fixups; ++ i)
d399 1
a399 1
      fragS * old_frag;
d468 6
a473 6
	fixP = md_cgen_record_fixup_exp (frag_now, f - frag_now->fr_literal,
					 insn, length, operand,
					 fixups[i].opinfo,
					 & fixups[i].exp);
	if (result)
	  result->fixups[i] = fixP;
d501 1
a501 1
  char * where = fixP->fx_frag->fr_literal + fixP->fx_where;
d503 1
a503 1
  /* canonical name, since used a lot */
d505 1
a505 1
  
d519 1
a519 1
      value = * valueP;
d523 1
a523 1
    value = * valueP;
d534 1
a534 1
 	      as_bad_where (fixP->fx_file, fixP->fx_line,
d564 1
a564 1
	    /* ??? 0 is passed for `pc' */
d571 3
a573 3
	    /* ??? 0 is passed for `pc' */
	    errmsg = CGEN_CPU_INSERT_OPERAND (cd) (cd, opindex, fields, where,
						   (bfd_vma) 0);
d645 1
a645 1
  arelent * reloc;
d663 2
a664 2
  /* Use fx_offset for these cases */
  if (   fixP->fx_r_type == BFD_RELOC_VTABLE_ENTRY
d666 1
a666 1
    reloc->addend  = fixP->fx_offset;
d668 1
a668 1
    reloc->addend  = fixP->fx_addnumber;
@


1.4
log
@2000-07-26  Dave Brolley  <brolley@@redhat.com>

	* cgen.c (queue_fixup): Declare opinfo.
	(gas_cgen_parse_operand): Mark unused parameters with ATTRIBUTE_UNUSED.
	(gas_cgen_md_operand): Ditto.
	(gas_cgen_md_apply_fix3): Ditto.
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
@


1.3
log
@* cgen assembler fixes; approved by original author <devans>

2000-06-24  Frank Ch. Eigler  <fche@@redhat.com>

	* cgen.c (expr_jmp_buf_p): New validity flag for expr_jmp_buf.
	(gas_cgen_parse_operand): Set it around expression() call.
	(gas_cgen_md_operand): Test for it before longjmp().
@
text
@d84 1
d251 1
a251 1
     CGEN_CPU_DESC cd;
d334 1
a334 1
     expressionS * expressionP;
d498 1
a498 1
     segT     seg;
d641 1
a641 1
     asection * section;
@


1.2
log
@	* cgen.c: Update for symbol handling changes.
@
text
@d235 1
d283 1
d289 1
d291 1
d335 3
a337 1
  longjmp (expr_jmp_buf, 1);
@


1.1
log
@Initial revision
@
text
@d652 2
a653 1
  reloc->sym_ptr_ptr = & fixP->fx_addsy->bsym;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

