head	1.22;
access;
symbols
	binutils-2_24-branch:1.22.0.10
	binutils-2_24-branchpoint:1.22
	binutils-2_21_1:1.22
	binutils-2_23_2:1.22
	binutils-2_23_1:1.22
	binutils-2_23:1.22
	binutils-2_23-branch:1.22.0.8
	binutils-2_23-branchpoint:1.22
	binutils-2_22_branch:1.22.0.6
	binutils-2_22:1.22
	binutils-2_22-branch:1.22.0.4
	binutils-2_22-branchpoint:1.22
	binutils-2_21:1.22
	binutils-2_21-branch:1.22.0.2
	binutils-2_21-branchpoint:1.22
	binutils-2_20_1:1.21
	binutils-2_20:1.21
	binutils-arc-20081103-branch:1.19.0.8
	binutils-arc-20081103-branchpoint:1.19
	binutils-2_20-branch:1.21.0.4
	binutils-2_20-branchpoint:1.21
	dje-cgen-play1-branch:1.21.0.2
	dje-cgen-play1-branchpoint:1.21
	arc-20081103-branch:1.19.0.6
	arc-20081103-branchpoint:1.19
	binutils-2_19_1:1.19
	binutils-2_19:1.19
	binutils-2_19-branch:1.19.0.4
	binutils-2_19-branchpoint:1.19
	binutils-2_18:1.19
	binutils-2_18-branch:1.19.0.2
	binutils-2_18-branchpoint:1.19
	binutils-csl-coldfire-4_1-32:1.16
	binutils-csl-sourcerygxx-4_1-32:1.16
	binutils-csl-innovasic-fido-3_4_4-33:1.16
	binutils-csl-sourcerygxx-3_4_4-32:1.15
	binutils-csl-coldfire-4_1-30:1.16
	binutils-csl-sourcerygxx-4_1-30:1.16
	binutils-csl-coldfire-4_1-28:1.16
	binutils-csl-sourcerygxx-4_1-29:1.16
	binutils-csl-sourcerygxx-4_1-28:1.16
	binutils-csl-arm-2006q3-27:1.16
	binutils-csl-sourcerygxx-4_1-27:1.16
	binutils-csl-arm-2006q3-26:1.16
	binutils-csl-sourcerygxx-4_1-26:1.16
	binutils-csl-sourcerygxx-4_1-25:1.16
	binutils-csl-sourcerygxx-4_1-24:1.16
	binutils-csl-sourcerygxx-4_1-23:1.16
	binutils-csl-sourcerygxx-4_1-21:1.16
	binutils-csl-arm-2006q3-21:1.16
	binutils-csl-sourcerygxx-4_1-22:1.16
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.16
	binutils-csl-sourcerygxx-4_1-20:1.16
	binutils-csl-arm-2006q3-19:1.16
	binutils-csl-sourcerygxx-4_1-19:1.16
	binutils-csl-sourcerygxx-4_1-18:1.16
	binutils-csl-renesas-4_1-9:1.16
	binutils-csl-sourcerygxx-3_4_4-25:1.15
	binutils-csl-renesas-4_1-8:1.16
	binutils-csl-renesas-4_1-7:1.16
	binutils-csl-renesas-4_1-6:1.16
	binutils-csl-sourcerygxx-4_1-17:1.16
	binutils-csl-sourcerygxx-4_1-14:1.16
	binutils-csl-sourcerygxx-4_1-15:1.16
	binutils-csl-sourcerygxx-4_1-13:1.16
	binutils-2_17:1.16
	binutils-csl-sourcerygxx-4_1-12:1.16
	binutils-csl-sourcerygxx-3_4_4-21:1.16
	binutils-csl-wrs-linux-3_4_4-24:1.15
	binutils-csl-wrs-linux-3_4_4-23:1.15
	binutils-csl-sourcerygxx-4_1-9:1.16
	binutils-csl-sourcerygxx-4_1-8:1.16
	binutils-csl-sourcerygxx-4_1-7:1.16
	binutils-csl-arm-2006q1-6:1.16
	binutils-csl-sourcerygxx-4_1-6:1.16
	binutils-csl-wrs-linux-3_4_4-22:1.15
	binutils-csl-coldfire-4_1-11:1.16
	binutils-csl-sourcerygxx-3_4_4-19:1.16
	binutils-csl-coldfire-4_1-10:1.16
	binutils-csl-sourcerygxx-4_1-5:1.16
	binutils-csl-sourcerygxx-4_1-4:1.16
	binutils-csl-wrs-linux-3_4_4-21:1.15
	binutils-csl-morpho-4_1-4:1.16
	binutils-csl-sourcerygxx-3_4_4-17:1.16
	binutils-csl-wrs-linux-3_4_4-20:1.15
	binutils-2_17-branch:1.16.0.4
	binutils-2_17-branchpoint:1.16
	binutils-csl-2_17-branch:1.16.0.2
	binutils-csl-2_17-branchpoint:1.16
	binutils-csl-gxxpro-3_4-branch:1.15.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.15
	binutils-2_16_1:1.15
	binutils-csl-arm-2005q1b:1.15
	binutils-2_16:1.15
	binutils-csl-arm-2005q1a:1.15
	binutils-csl-arm-2005q1-branch:1.15.0.4
	binutils-csl-arm-2005q1-branchpoint:1.15
	binutils-2_16-branch:1.15.0.2
	binutils-2_16-branchpoint:1.15
	csl-arm-2004-q3d:1.13
	csl-arm-2004-q3:1.13
	binutils-2_15:1.13
	binutils-2_15-branchpoint:1.13
	csl-arm-2004-q1a:1.13
	csl-arm-2004-q1:1.13
	binutils-2_15-branch:1.13.0.6
	cagney_bfdfile-20040213-branch:1.13.0.4
	cagney_bfdfile-20040213-branchpoint:1.13
	cagney_bigcore-20040122-branch:1.13.0.2
	cagney_bigcore-20040122-branchpoint:1.13
	csl-arm-2003-q4:1.13
	binutils-2_14:1.11
	binutils-2_14-branch:1.11.0.2
	binutils-2_14-branchpoint:1.11
	binutils-2_13_2_1:1.10.4.1
	binutils-2_13_2:1.10.4.1
	binutils-2_13_1:1.10.4.1
	binutils-2_13:1.10
	binutils-2_13-branchpoint:1.10
	binutils-2_13-branch:1.10.0.4
	binutils-2_12_1:1.10
	binutils-2_12:1.10
	binutils-2_12-branch:1.10.0.2
	binutils-2_12-branchpoint:1.10
	cygnus_cvs_20020108_pre:1.10
	binutils-2_11_2:1.6.2.2
	binutils-2_11_1:1.6.2.2
	binutils-2_11:1.6
	x86_64versiong3:1.6
	binutils-2_11-branch:1.6.0.2
	binutils-2_10_1:1.3
	binutils-2_10:1.3
	binutils-2_10-branch:1.3.0.2
	binutils-2_10-branchpoint:1.3
	binutils_latest_snapshot:1.22
	repo-unification-2000-02-06:1.3
	binu_ss_19990721:1.3
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2010.06.28.14.06.56;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2009.06.22.17.56.00;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	2009.01.02.14.21.53;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2007.07.03.11.01.03;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2007.03.29.09.05.27;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2006.06.07.11.27.57;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.05.09.12.45;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2005.03.03.01.29.53;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2005.01.21.05.54.38;	author bje;	state Exp;
branches;
next	1.13;

1.13
date	2003.11.24.03.37.58;	author kazu;	state Exp;
branches;
next	1.12;

1.12
date	2003.10.27.12.45.17;	author kazu;	state Exp;
branches;
next	1.11;

1.11
date	2002.10.30.03.56.39;	author drow;	state Exp;
branches;
next	1.10;

1.10
date	2001.10.11.12.20.25;	author kazu;	state Exp;
branches
	1.10.4.1;
next	1.9;

1.9
date	2001.07.10.09.45.50;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2001.05.03.02.07.01;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.08.23.24.22;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2000.11.10.00.46.17;	author kazu;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.11.07.01.18.45;	author kazu;	state Exp;
branches;
next	1.4;

1.4
date	2000.09.09.20.23.15;	author kazu;	state Exp;
branches;
next	1.3;

1.3
date	99.06.10.21.35.32;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.06.10.20.35.46;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.41;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.10.4.1
date	2002.10.30.03.54.28;	author drow;	state Exp;
branches;
next	;

1.6.2.1
date	2001.06.07.03.15.25;	author amodra;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.06.11.10.04.45;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.41;	author rth;	state Exp;
branches;
next	;


desc
@@


1.22
log
@	* config/obj-evax.h (S_SET_OTHER, S_SET_TYPE, S_SET_DESC): Don't define.
	* config/tc-crx.c (gettrap): Constify arg.
	(handle_LoadStor, get_cinv_parameters): Likewise.
	(getreg_image): Fix enum warning
	(md_assemble): Restore input line char.
	* config/tc-hppa.c (tc_gen_reloc): Fix enum warning.
	* config/tc-i960.c (mem_fmt): Rename var to fix shadow warning.
	* config/tc-sh.c (sh_fdpic): Only define when OBJ_ELF.
	(build_Mytes): Fix build failure for non-elf targets.
	* config/tc-tic4x.c (tic4x_eval): Restore terminator char.
	* config/tc-xtensa.c (xtensa_end_directive): Fix switch enum warning.

	* cgen.c (gas_cgen_md_apply_fix): Avoid set but unused warning.
	* ecoff.c (add_ecoff_symbol): Likewise.
	* itbl-ops.c (append_insns_as_macros): Likewise.
	* listing.c (debugging_pseudo): Likewise.
	* read.c (s_mri_common, stringer): Likewise.
	* config/obj-coff.c (coff_frob_section): Likewise.
	* config/tc-alpha.c (emit_ldgp, s_alpha_proc): Likewise.
	* config/tc-arm.c (my_get_expression): Likewise.
	* config/tc-hppa.c (process_exit, pa_type_args): Likewise.
	* config/tc-m32c.c (md_assemble): Likewise.
	* config/tc-microblaze.c (md_convert_frag): Likewise.
	* config/tc-mips.c (s_change_section): Likewise.
	* config/tc-mt.c (mt_fix_adjustable): Likewise.
	* config/tc-xtensa.c (xtensa_literal_pseudo): Likewise.

	* config/obj-aout.c (obj_aout_frob_symbol): Delete set but otherwise
	unused vars.
	* config/tc-alpha.c (load_expression): Likewise.
	(s_alpha_rdata, s_alpha_section, s_alpha_prologue): Likewise.
	* config/tc-arm.c (parse_neon_el_struct_list): Likewise.
	* config/tc-avr.c (extract_word): Likewise.
	* config/tc-cris.c (cris_get_expression): Likewise.
	* config/tc-d30v.c (build_insn, find_format): Likewise.
	* config/tc-dlx.c (machine_ip): Likewise.
	* config/tc-hppa.c (pa_get_absolute_expression): Likewise.
	* config/tc-i370.c (md_assemble): Likewise.
	* config/tc-i960.c (brtab_emit): Likewise.
	* config/tc-iq2000.c (s_iq2000_ent): Likewise.
	* config/tc-m32c.c (md_convert_frag): Likewise.
	* config/tc-m68hc11.c (fixup24, build_jump_insn): Likewise.
	(md_estimate_size_before_relax, md_apply_fix): Likewise.
	* config/tc-m68k.c (md_show_usage): Likewise.
	* config/tc-microblaze.c (microblaze_s_lcomm): Likewise.
	* config/tc-mips.c (s_mips_end): Likewise.
	* config/tc-mmix.c (mmix_byte, mmix_cons): Likewise.
	* config/tc-mn10300.c (md_assemble): Likewise.
	* config/tc-msp430.c (extract_word): Likewise.
	* config/tc-mt.c (md_assemble): Likewise.
	* config/tc-or32.c (machine_ip): Likewise.
	* config/tc-pj.c (md_apply_fix): Likewise.
	* config/tc-s390.c (md_gather_operands): Likewise.
	* config/tc-sh.c (sh_cons_align): Likewise.
	* config/tc-sparc.c (sparc_cons_align): Likewise.
	* config/tc-tic4x.c (tic4x_sect): Likewise.
	* config/tc-tic54x.c (tic54x_stringer): Likewise.
	* config/tc-vax.c (vip_op): Likewise.
	* config/tc-xstormy16.c (xstormy16_cons_fix_new): Likewise.
	* config/tc-xtensa.c (md_assemble): Likewise.
	(xtensa_fix_short_loop_frags, convert_frag_immed): Likewise.
	(xtensa_move_literals): Likewise.
@
text
@/* itbl-ops.c
   Copyright 1997, 1999, 2000, 2001, 2002, 2003, 2005, 2006, 2007,
   2009, 2010  Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/*======================================================================*/
/*
 * Herein lies the support for dynamic specification of processor
 * instructions and registers.  Mnemonics, values, and formats for each
 * instruction and register are specified in an ascii file consisting of
 * table entries.  The grammar for the table is defined in the document
 * "Processor instruction table specification".
 *
 * Instructions use the gnu assembler syntax, with the addition of
 * allowing mnemonics for register.
 * Eg. "func $2,reg3,0x100,symbol ; comment"
 * 	func - opcode name
 * 	$n - register n
 * 	reg3 - mnemonic for processor's register defined in table
 * 	0xddd..d - immediate value
 * 	symbol - address of label or external symbol
 *
 * First, itbl_parse reads in the table of register and instruction
 * names and formats, and builds a list of entries for each
 * processor/type combination.  lex and yacc are used to parse
 * the entries in the table and call functions defined here to
 * add each entry to our list.
 *
 * Then, when assembling or disassembling, these functions are called to
 * 1) get information on a processor's registers and
 * 2) assemble/disassemble an instruction.
 * To assemble(disassemble) an instruction, the function
 * itbl_assemble(itbl_disassemble) is called to search the list of
 * instruction entries, and if a match is found, uses the format
 * described in the instruction entry structure to complete the action.
 *
 * Eg. Suppose we have a Mips coprocessor "cop3" with data register "d2"
 * and we want to define function "pig" which takes two operands.
 *
 * Given the table entries:
 * 	"p3 insn pig 0x1:24-21 dreg:20-16 immed:15-0"
 * 	"p3 dreg d2 0x2"
 * and that the instruction encoding for coprocessor pz has encoding:
 * 	#define MIPS_ENCODE_COP_NUM(z) ((0x21|(z<<1))<<25)
 * 	#define ITBL_ENCODE_PNUM(pnum) MIPS_ENCODE_COP_NUM(pnum)
 *
 * a structure to describe the instruction might look something like:
 *      struct itbl_entry = {
 *      e_processor processor = e_p3
 *      e_type type = e_insn
 *      char *name = "pig"
 *      uint value = 0x1
 *      uint flags = 0
 *      struct itbl_range range = 24-21
 *      struct itbl_field *field = {
 *              e_type type = e_dreg
 *              struct itbl_range range = 20-16
 *              struct itbl_field *next = {
 *                      e_type type = e_immed
 *                      struct itbl_range range = 15-0
 *                      struct itbl_field *next = 0
 *                      };
 *              };
 *      struct itbl_entry *next = 0
 *      };
 *
 * And the assembler instructions:
 * 	"pig d2,0x100"
 * 	"pig $2,0x100"
 *
 * would both assemble to the hex value:
 * 	"0x4e220100"
 *
 */

#include "as.h"
#include "itbl-ops.h"
#include <itbl-parse.h>

/* #define DEBUG */

#ifdef DEBUG
#include <assert.h>
#define ASSERT(x) gas_assert (x)
#define DBG(x) printf x
#else
#define ASSERT(x)
#define DBG(x)
#endif

#ifndef min
#define min(a,b) (a<b?a:b)
#endif

int itbl_have_entries = 0;

/*======================================================================*/
/* structures for keeping itbl format entries */

struct itbl_range {
  int sbit;			/* mask starting bit position */
  int ebit;			/* mask ending bit position */
};

struct itbl_field {
  e_type type;			/* dreg/creg/greg/immed/symb */
  struct itbl_range range;	/* field's bitfield range within instruction */
  unsigned long flags;		/* field flags */
  struct itbl_field *next;	/* next field in list */
};

/* These structures define the instructions and registers for a processor.
 * If the type is an instruction, the structure defines the format of an
 * instruction where the fields are the list of operands.
 * The flags field below uses the same values as those defined in the
 * gnu assembler and are machine specific.  */
struct itbl_entry {
  e_processor processor;	/* processor number */
  e_type type;			/* dreg/creg/greg/insn */
  char *name;			/* mnemionic name for insn/register */
  unsigned long value;		/* opcode/instruction mask/register number */
  unsigned long flags;		/* effects of the instruction */
  struct itbl_range range;	/* bit range within instruction for value */
  struct itbl_field *fields;	/* list of operand definitions (if any) */
  struct itbl_entry *next;	/* next entry */
};

/* local data and structures */

static int itbl_num_opcodes = 0;
/* Array of entries for each processor and entry type */
static struct itbl_entry *entries[e_nprocs][e_ntypes];

/* local prototypes */
static unsigned long build_opcode (struct itbl_entry *e);
static e_type get_type (int yytype);
static e_processor get_processor (int yyproc);
static struct itbl_entry **get_entries (e_processor processor,
					e_type type);
static struct itbl_entry *find_entry_byname (e_processor processor,
					e_type type, char *name);
static struct itbl_entry *find_entry_byval (e_processor processor,
			e_type type, unsigned long val, struct itbl_range *r);
static struct itbl_entry *alloc_entry (e_processor processor,
		e_type type, char *name, unsigned long value);
static unsigned long apply_range (unsigned long value, struct itbl_range r);
static unsigned long extract_range (unsigned long value, struct itbl_range r);
static struct itbl_field *alloc_field (e_type type, int sbit,
					int ebit, unsigned long flags);

/*======================================================================*/
/* Interfaces to the parser */

/* Open the table and use lex and yacc to parse the entries.
 * Return 1 for failure; 0 for success.  */

int
itbl_parse (char *insntbl)
{
  extern FILE *yyin;
  extern int yyparse (void);

  yyin = fopen (insntbl, FOPEN_RT);
  if (yyin == 0)
    {
      printf ("Can't open processor instruction specification file \"%s\"\n",
	      insntbl);
      return 1;
    }

  while (yyparse ())
    ;

  fclose (yyin);
  itbl_have_entries = 1;
  return 0;
}

/* Add a register entry */

struct itbl_entry *
itbl_add_reg (int yyprocessor, int yytype, char *regname,
	      int regnum)
{
  return alloc_entry (get_processor (yyprocessor), get_type (yytype), regname,
		      (unsigned long) regnum);
}

/* Add an instruction entry */

struct itbl_entry *
itbl_add_insn (int yyprocessor, char *name, unsigned long value,
	       int sbit, int ebit, unsigned long flags)
{
  struct itbl_entry *e;
  e = alloc_entry (get_processor (yyprocessor), e_insn, name, value);
  if (e)
    {
      e->range.sbit = sbit;
      e->range.ebit = ebit;
      e->flags = flags;
      itbl_num_opcodes++;
    }
  return e;
}

/* Add an operand to an instruction entry */

struct itbl_field *
itbl_add_operand (struct itbl_entry *e, int yytype, int sbit,
		  int ebit, unsigned long flags)
{
  struct itbl_field *f, **last_f;
  if (!e)
    return 0;
  /* Add to end of fields' list.  */
  f = alloc_field (get_type (yytype), sbit, ebit, flags);
  if (f)
    {
      last_f = &e->fields;
      while (*last_f)
	last_f = &(*last_f)->next;
      *last_f = f;
      f->next = 0;
    }
  return f;
}

/*======================================================================*/
/* Interfaces for assembler and disassembler */

#ifndef STAND_ALONE
static void append_insns_as_macros (void);

/* Initialize for gas.  */

void
itbl_init (void)
{
  struct itbl_entry *e, **es;
  e_processor procn;
  e_type type;

  if (!itbl_have_entries)
    return;

  /* Since register names don't have a prefix, put them in the symbol table so
     they can't be used as symbols.  This simplifies argument parsing as
     we can let gas parse registers for us.  */
  /* Use symbol_create instead of symbol_new so we don't try to
     output registers into the object file's symbol table.  */

  for (type = e_regtype0; type < e_nregtypes; type++)
    for (procn = e_p0; procn < e_nprocs; procn++)
      {
	es = get_entries (procn, type);
	for (e = *es; e; e = e->next)
	  {
	    symbol_table_insert (symbol_create (e->name, reg_section,
						e->value, &zero_address_frag));
	  }
      }
  append_insns_as_macros ();
}

/* Append insns to opcodes table and increase number of opcodes
 * Structure of opcodes table:
 * struct itbl_opcode
 * {
 *   const char *name;
 *   const char *args; 		- string describing the arguments.
 *   unsigned long match; 	- opcode, or ISA level if pinfo=INSN_MACRO
 *   unsigned long mask; 	- opcode mask, or macro id if pinfo=INSN_MACRO
 *   unsigned long pinfo; 	- insn flags, or INSN_MACRO
 * };
 * examples:
 *	{"li",      "t,i",  0x34000000, 0xffe00000, WR_t    },
 *	{"li",      "t,I",  0,    (int) M_LI,   INSN_MACRO  },
 */

static char *form_args (struct itbl_entry *e);
static void
append_insns_as_macros (void)
{
  struct ITBL_OPCODE_STRUCT *new_opcodes, *o;
  struct itbl_entry *e, **es;
  int n, size, new_size, new_num_opcodes;
#ifdef USE_MACROS
  int id;
#endif

  if (!itbl_have_entries)
    return;

  if (!itbl_num_opcodes)	/* no new instructions to add! */
    {
      return;
    }
  DBG (("previous num_opcodes=%d\n", ITBL_NUM_OPCODES));

  new_num_opcodes = ITBL_NUM_OPCODES + itbl_num_opcodes;
  ASSERT (new_num_opcodes >= itbl_num_opcodes);

  size = sizeof (struct ITBL_OPCODE_STRUCT) * ITBL_NUM_OPCODES;
  ASSERT (size >= 0);
  DBG (("I get=%d\n", size / sizeof (ITBL_OPCODES[0])));

  new_size = sizeof (struct ITBL_OPCODE_STRUCT) * new_num_opcodes;
  ASSERT (new_size > size);

  /* FIXME since ITBL_OPCODES culd be a static table,
		we can't realloc or delete the old memory.  */
  new_opcodes = (struct ITBL_OPCODE_STRUCT *) malloc (new_size);
  if (!new_opcodes)
    {
      printf (_("Unable to allocate memory for new instructions\n"));
      return;
    }
  if (size)			/* copy preexisting opcodes table */
    memcpy (new_opcodes, ITBL_OPCODES, size);

  /* FIXME! some NUMOPCODES are calculated expressions.
		These need to be changed before itbls can be supported.  */

#ifdef USE_MACROS
  id = ITBL_NUM_MACROS;		/* begin the next macro id after the last */
#endif
  o = &new_opcodes[ITBL_NUM_OPCODES];	/* append macro to opcodes list */
  for (n = e_p0; n < e_nprocs; n++)
    {
      es = get_entries (n, e_insn);
      for (e = *es; e; e = e->next)
	{
	  /* name,    args,   mask,       match,  pinfo
		 * {"li",      "t,i",  0x34000000, 0xffe00000, WR_t    },
		 * {"li",      "t,I",  0,    (int) M_LI,   INSN_MACRO  },
		 * Construct args from itbl_fields.
		*/
	  o->name = e->name;
	  o->args = strdup (form_args (e));
	  o->mask = apply_range (e->value, e->range);
	  /* FIXME how to catch during assembly? */
	  /* mask to identify this insn */
	  o->match = apply_range (e->value, e->range);
	  o->pinfo = 0;

#ifdef USE_MACROS
	  o->mask = id++;	/* FIXME how to catch during assembly? */
	  o->match = 0;		/* for macros, the insn_isa number */
	  o->pinfo = INSN_MACRO;
#endif

	  /* Don't add instructions which caused an error */
	  if (o->args)
	    o++;
	  else
	    new_num_opcodes--;
	}
    }
  ITBL_OPCODES = new_opcodes;
  ITBL_NUM_OPCODES = new_num_opcodes;

  /* FIXME
		At this point, we can free the entries, as they should have
		been added to the assembler's tables.
		Don't free name though, since name is being used by the new
		opcodes table.

		Eventually, we should also free the new opcodes table itself
		on exit.
	*/
}

static char *
form_args (struct itbl_entry *e)
{
  static char s[31];
  char c = 0, *p = s;
  struct itbl_field *f;

  ASSERT (e);
  for (f = e->fields; f; f = f->next)
    {
      switch (f->type)
	{
	case e_dreg:
	  c = 'd';
	  break;
	case e_creg:
	  c = 't';
	  break;
	case e_greg:
	  c = 's';
	  break;
	case e_immed:
	  c = 'i';
	  break;
	case e_addr:
	  c = 'a';
	  break;
	default:
	  c = 0;		/* ignore; unknown field type */
	}
      if (c)
	{
	  if (p != s)
	    *p++ = ',';
	  *p++ = c;
	}
    }
  *p = 0;
  return s;
}
#endif /* !STAND_ALONE */

/* Get processor's register name from val */

int
itbl_get_reg_val (char *name, unsigned long *pval)
{
  e_type t;
  e_processor p;

  for (p = e_p0; p < e_nprocs; p++)
    {
      for (t = e_regtype0; t < e_nregtypes; t++)
	{
	  if (itbl_get_val (p, t, name, pval))
	    return 1;
	}
    }
  return 0;
}

char *
itbl_get_name (e_processor processor, e_type type, unsigned long val)
{
  struct itbl_entry *r;
  /* type depends on instruction passed */
  r = find_entry_byval (processor, type, val, 0);
  if (r)
    return r->name;
  else
    return 0;			/* error; invalid operand */
}

/* Get processor's register value from name */

int
itbl_get_val (e_processor processor, e_type type, char *name,
	      unsigned long *pval)
{
  struct itbl_entry *r;
  /* type depends on instruction passed */
  r = find_entry_byname (processor, type, name);
  if (r == NULL)
    return 0;
  *pval = r->value;
  return 1;
}

/* Assemble instruction "name" with operands "s".
 * name - name of instruction
 * s - operands
 * returns - long word for assembled instruction */

unsigned long
itbl_assemble (char *name, char *s)
{
  unsigned long opcode;
  struct itbl_entry *e = NULL;
  struct itbl_field *f;
  char *n;
  int processor;

  if (!name || !*name)
    return 0;			/* error!  must have an opcode name/expr */

  /* find entry in list of instructions for all processors */
  for (processor = 0; processor < e_nprocs; processor++)
    {
      e = find_entry_byname (processor, e_insn, name);
      if (e)
	break;
    }
  if (!e)
    return 0;			/* opcode not in table; invalid instruction */
  opcode = build_opcode (e);

  /* parse opcode's args (if any) */
  for (f = e->fields; f; f = f->next)	/* for each arg, ...  */
    {
      struct itbl_entry *r;
      unsigned long value;
      if (!s || !*s)
	return 0;		/* error - not enough operands */
      n = itbl_get_field (&s);
      /* n should be in form $n or 0xhhh (are symbol names valid?? */
      switch (f->type)
	{
	case e_dreg:
	case e_creg:
	case e_greg:
	  /* Accept either a string name
			 * or '$' followed by the register number */
	  if (*n == '$')
	    {
	      n++;
	      value = strtol (n, 0, 10);
	      /* FIXME! could have "0l"... then what?? */
	      if (value == 0 && *n != '0')
		return 0;	/* error; invalid operand */
	    }
	  else
	    {
	      r = find_entry_byname (e->processor, f->type, n);
	      if (r)
		value = r->value;
	      else
		return 0;	/* error; invalid operand */
	    }
	  break;
	case e_addr:
	  /* use assembler's symbol table to find symbol */
	  /* FIXME!! Do we need this?
				if so, what about relocs??
				my_getExpression (&imm_expr, s);
				return 0;	/-* error; invalid operand *-/
				break;
			*/
	  /* If not a symbol, fall thru to IMMED */
	case e_immed:
	  if (*n == '0' && *(n + 1) == 'x')	/* hex begins 0x...  */
	    {
	      n += 2;
	      value = strtol (n, 0, 16);
	      /* FIXME! could have "0xl"... then what?? */
	    }
	  else
	    {
	      value = strtol (n, 0, 10);
	      /* FIXME! could have "0l"... then what?? */
	      if (value == 0 && *n != '0')
		return 0;	/* error; invalid operand */
	    }
	  break;
	default:
	  return 0;		/* error; invalid field spec */
	}
      opcode |= apply_range (value, f->range);
    }
  if (s && *s)
    return 0;			/* error - too many operands */
  return opcode;		/* done! */
}

/* Disassemble instruction "insn".
 * insn - instruction
 * s - buffer to hold disassembled instruction
 * returns - 1 if succeeded; 0 if failed
 */

int
itbl_disassemble (char *s, unsigned long insn)
{
  e_processor processor;
  struct itbl_entry *e;
  struct itbl_field *f;

  if (!ITBL_IS_INSN (insn))
    return 0;			/* error */
  processor = get_processor (ITBL_DECODE_PNUM (insn));

  /* find entry in list */
  e = find_entry_byval (processor, e_insn, insn, 0);
  if (!e)
    return 0;			/* opcode not in table; invalid instruction */
  strcpy (s, e->name);

  /* Parse insn's args (if any).  */
  for (f = e->fields; f; f = f->next)	/* for each arg, ...  */
    {
      struct itbl_entry *r;
      unsigned long value;
      char s_value[20];

      if (f == e->fields)	/* First operand is preceded by tab.  */
	strcat (s, "\t");
      else			/* ','s separate following operands.  */
	strcat (s, ",");
      value = extract_range (insn, f->range);
      /* n should be in form $n or 0xhhh (are symbol names valid?? */
      switch (f->type)
	{
	case e_dreg:
	case e_creg:
	case e_greg:
	  /* Accept either a string name
	     or '$' followed by the register number.  */
	  r = find_entry_byval (e->processor, f->type, value, &f->range);
	  if (r)
	    strcat (s, r->name);
	  else
	    {
	      sprintf (s_value, "$%lu", value);
	      strcat (s, s_value);
	    }
	  break;
	case e_addr:
	  /* Use assembler's symbol table to find symbol.  */
	  /* FIXME!! Do we need this?  If so, what about relocs??  */
	  /* If not a symbol, fall through to IMMED.  */
	case e_immed:
	  sprintf (s_value, "0x%lx", value);
	  strcat (s, s_value);
	  break;
	default:
	  return 0;		/* error; invalid field spec */
	}
    }
  return 1;			/* Done!  */
}

/*======================================================================*/
/*
 * Local functions for manipulating private structures containing
 * the names and format for the new instructions and registers
 * for each processor.
 */

/* Calculate instruction's opcode and function values from entry */

static unsigned long
build_opcode (struct itbl_entry *e)
{
  unsigned long opcode;

  opcode = apply_range (e->value, e->range);
  opcode |= ITBL_ENCODE_PNUM (e->processor);
  return opcode;
}

/* Calculate absolute value given the relative value and bit position range
 * within the instruction.
 * The range is inclusive where 0 is least significant bit.
 * A range of { 24, 20 } will have a mask of
 * bit   3           2            1
 * pos: 1098 7654 3210 9876 5432 1098 7654 3210
 * bin: 0000 0001 1111 0000 0000 0000 0000 0000
 * hex:    0    1    f    0    0    0    0    0
 * mask: 0x01f00000.
 */

static unsigned long
apply_range (unsigned long rval, struct itbl_range r)
{
  unsigned long mask;
  unsigned long aval;
  int len = MAX_BITPOS - r.sbit;

  ASSERT (r.sbit >= r.ebit);
  ASSERT (MAX_BITPOS >= r.sbit);
  ASSERT (r.ebit >= 0);

  /* create mask by truncating 1s by shifting */
  mask = 0xffffffff << len;
  mask = mask >> len;
  mask = mask >> r.ebit;
  mask = mask << r.ebit;

  aval = (rval << r.ebit) & mask;
  return aval;
}

/* Calculate relative value given the absolute value and bit position range
 * within the instruction.  */

static unsigned long
extract_range (unsigned long aval, struct itbl_range r)
{
  unsigned long mask;
  unsigned long rval;
  int len = MAX_BITPOS - r.sbit;

  /* create mask by truncating 1s by shifting */
  mask = 0xffffffff << len;
  mask = mask >> len;
  mask = mask >> r.ebit;
  mask = mask << r.ebit;

  rval = (aval & mask) >> r.ebit;
  return rval;
}

/* Extract processor's assembly instruction field name from s;
 * forms are "n args" "n,args" or "n" */
/* Return next argument from string pointer "s" and advance s.
 * delimiters are " ,()" */

char *
itbl_get_field (char **S)
{
  static char n[128];
  char *s;
  int len;

  s = *S;
  if (!s || !*s)
    return 0;
  /* FIXME: This is a weird set of delimiters.  */
  len = strcspn (s, " \t,()");
  ASSERT (128 > len + 1);
  strncpy (n, s, len);
  n[len] = 0;
  if (s[len] == '\0')
    s = 0;			/* no more args */
  else
    s += len + 1;		/* advance to next arg */

  *S = s;
  return n;
}

/* Search entries for a given processor and type
 * to find one matching the name "n".
 * Return a pointer to the entry */

static struct itbl_entry *
find_entry_byname (e_processor processor,
		   e_type type, char *n)
{
  struct itbl_entry *e, **es;

  es = get_entries (processor, type);
  for (e = *es; e; e = e->next)	/* for each entry, ...  */
    {
      if (!strcmp (e->name, n))
	return e;
    }
  return 0;
}

/* Search entries for a given processor and type
 * to find one matching the value "val" for the range "r".
 * Return a pointer to the entry.
 * This function is used for disassembling fields of an instruction.
 */

static struct itbl_entry *
find_entry_byval (e_processor processor, e_type type,
		  unsigned long val, struct itbl_range *r)
{
  struct itbl_entry *e, **es;
  unsigned long eval;

  es = get_entries (processor, type);
  for (e = *es; e; e = e->next)	/* for each entry, ...  */
    {
      if (processor != e->processor)
	continue;
      /* For insns, we might not know the range of the opcode,
	 * so a range of 0 will allow this routine to match against
	 * the range of the entry to be compared with.
	 * This could cause ambiguities.
	 * For operands, we get an extracted value and a range.
	 */
      /* if range is 0, mask val against the range of the compared entry.  */
      if (r == 0)		/* if no range passed, must be whole 32-bits
			 * so create 32-bit value from entry's range */
	{
	  eval = apply_range (e->value, e->range);
	  val &= apply_range (0xffffffff, e->range);
	}
      else if ((r->sbit == e->range.sbit && r->ebit == e->range.ebit)
	       || (e->range.sbit == 0 && e->range.ebit == 0))
	{
	  eval = apply_range (e->value, *r);
	  val = apply_range (val, *r);
	}
      else
	continue;
      if (val == eval)
	return e;
    }
  return 0;
}

/* Return a pointer to the list of entries for a given processor and type.  */

static struct itbl_entry **
get_entries (e_processor processor, e_type type)
{
  return &entries[processor][type];
}

/* Return an integral value for the processor passed from yyparse.  */

static e_processor
get_processor (int yyproc)
{
  /* translate from yacc's processor to enum */
  if (yyproc >= e_p0 && yyproc < e_nprocs)
    return (e_processor) yyproc;
  return e_invproc;		/* error; invalid processor */
}

/* Return an integral value for the entry type passed from yyparse.  */

static e_type
get_type (int yytype)
{
  switch (yytype)
    {
      /* translate from yacc's type to enum */
    case INSN:
      return e_insn;
    case DREG:
      return e_dreg;
    case CREG:
      return e_creg;
    case GREG:
      return e_greg;
    case ADDR:
      return e_addr;
    case IMMED:
      return e_immed;
    default:
      return e_invtype;		/* error; invalid type */
    }
}

/* Allocate and initialize an entry */

static struct itbl_entry *
alloc_entry (e_processor processor, e_type type,
	     char *name, unsigned long value)
{
  struct itbl_entry *e, **es;
  if (!name)
    return 0;
  e = (struct itbl_entry *) malloc (sizeof (struct itbl_entry));
  if (e)
    {
      memset (e, 0, sizeof (struct itbl_entry));
      e->name = (char *) malloc (sizeof (strlen (name)) + 1);
      if (e->name)
	strcpy (e->name, name);
      e->processor = processor;
      e->type = type;
      e->value = value;
      es = get_entries (e->processor, e->type);
      e->next = *es;
      *es = e;
    }
  return e;
}

/* Allocate and initialize an entry's field */

static struct itbl_field *
alloc_field (e_type type, int sbit, int ebit,
	     unsigned long flags)
{
  struct itbl_field *f;
  f = (struct itbl_field *) malloc (sizeof (struct itbl_field));
  if (f)
    {
      memset (f, 0, sizeof (struct itbl_field));
      f->type = type;
      f->range.sbit = sbit;
      f->range.ebit = ebit;
      f->flags = flags;
    }
  return f;
}
@


1.21
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d3 1
a3 1
   2009  Free Software Foundation, Inc.
d303 4
a306 1
  int n, id, size, new_size, new_num_opcodes;
d341 1
d343 1
@


1.20
log
@        * or32-opc.c (or32_print_register, or32_print_immediate,
        disassemble_insn): Don't rely on undefined sprintf behaviour.

        * itbl-ops.c (itbl_disassemble): Don't rely on undefined sprintf
        behaviour.
@
text
@d100 1
a100 1
#define ASSERT(x) assert(x)
@


1.19
log
@Switch to GPLv3
@
text
@d2 2
a3 2
   Copyright 1997, 1999, 2000, 2001, 2002, 2003, 2005, 2006, 2007
   Free Software Foundation, Inc.
d596 1
d615 4
a618 1
	    sprintf (s, "%s$%lu", s, value);
d625 2
a626 1
	  sprintf (s, "%s0x%lx", s, value);
@


1.18
log
@* itbl-ops.c (itbl_entry): Remove unnecessary and excessively long initialization.
* itbl-ops.h (enum e_processor): Initialise the e_nprocs field using ITBL_NUMBER_OF_PROCESSORS.
* itbl-parse.y (yyerror): Remove use of redundant macro PARAMS.
@
text
@d2 1
a2 1
   Copyright 1997, 1999, 2000, 2001, 2002, 2003, 2005, 2006
d9 1
a9 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.17
log
@remove some duplicate #include's.
@
text
@d148 1
a148 6
static struct itbl_entry *entries[e_nprocs][e_ntypes] = {
  {0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0},
  {0, 0, 0, 0, 0, 0}
};
@


1.16
log
@Update the address and phone number of the FSF
@
text
@d2 1
a2 1
   Copyright 1997, 1999, 2000, 2001, 2002, 2003, 2005
d92 1
a92 3
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
a253 2
#include "as.h"
#include "symbols.h"
@


1.15
log
@update copyright dates
@
text
@d19 2
a20 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.14
log
@	* as.h: Remove #if 0'd code.
	* atof-generic.c (atof_generic): Likewise.
	* ecoff.c (ecoff_directive_frame): Likewise.
	* frags.h (FRAG_APPEND_1_CHAR): Likewise.
	* itbl-ops.c (itbl_add_reg): Likewise.
	* listing.c (calc_hex): Likewise.
	* read.c (MASK_CHAR): Likewise.
	* subsegs.c (subsegs_print_statistics): Likewise.
	* symbols.c (indent): Likewise.
	* write.c (write_relocs): Likewise.
	(write_object_file): Likewise.
	(relax_frag): Likewise.
@
text
@d2 2
a3 1
   Copyright 1997, 1999, 2000, 2001 Free Software Foundation, Inc.
@


1.13
log
@	* hash.c: Convert to ISO-C.
	* hash.h: Likewise.
	* input-file.c: Likewise.
	* input-file.h: Likewise.
	* input-scrub.c: Likewise.
	* itbl-ops.c: Likewise.
	* itbl-ops.h: Likewise.
@
text
@a206 12
#if 0
#include "as.h"
#include "symbols.h"
  /* Since register names don't have a prefix, we put them in the symbol table so
     they can't be used as symbols.  This also simplifies argument parsing as
     we can let gas parse registers for us.  The recorded register number is
     regnum.  */
  /* Use symbol_create here instead of symbol_new so we don't try to
     output registers into the object file's symbol table.  */
  symbol_table_insert (symbol_create (regname, reg_section,
				      regnum, &zero_address_frag));
#endif
@


1.12
log
@	* ChangeLog: Fix typos.
	* ChangeLog-9295: Likewise.
	* as.c: Fix comment typos.
	* as.h: Likewise.
	* atof-generic.c: Likewise.
	* bit_fix.h: Likewise.
	* frags.h: Likewise.
	* hash.c: Likewise.
	* input-file.c: Likewise.
	* input-scrub.c: Likewise.
	* itbl-ops.c: Likewise.
	* itbl-parse.y: Likewise.
	* listing.c: Likewise.
	* macro.h: Likewise.
	* read.c: Likewise.
	* sb.c: Likewise.
	* sb.h: Likewise.
	* symbols.c: Likewise.
	* symbols.h: Likewise.
@
text
@d157 15
a171 17
static unsigned long build_opcode PARAMS ((struct itbl_entry *e));
static e_type get_type PARAMS ((int yytype));
static e_processor get_processor PARAMS ((int yyproc));
static struct itbl_entry **get_entries PARAMS ((e_processor processor,
						e_type type));
static struct itbl_entry *find_entry_byname PARAMS ((e_processor processor,
					e_type type, char *name));
static struct itbl_entry *find_entry_byval PARAMS ((e_processor processor,
			e_type type, unsigned long val, struct itbl_range *r));
static struct itbl_entry *alloc_entry PARAMS ((e_processor processor,
		e_type type, char *name, unsigned long value));
static unsigned long apply_range PARAMS ((unsigned long value,
						struct itbl_range r));
static unsigned long extract_range PARAMS ((unsigned long value,
						struct itbl_range r));
static struct itbl_field *alloc_field PARAMS ((e_type type, int sbit,
					int ebit, unsigned long flags));
@


1.11
log
@        * itbl-lex.l: Use #include <> for generated headers.
        * itbl-ops.c: Likewise.
@
text
@d354 1
a354 1
  if (size)			/* copy prexisting opcodes table */
d375 1
a375 1
	  /* FIXME how to catch durring assembly? */
d381 1
a381 1
	  o->mask = id++;	/* FIXME how to catch durring assembly? */
d619 1
a619 1
      if (f == e->fields)	/* First operand is preceeded by tab.  */
@


1.10
log
@	* app.c: Fix comment typos.
	* bit_fix.h: Likewise.
	* expr.c: Likewise.
	* itbl-ops.c: Likewise.
@
text
@d95 1
a95 1
#include "itbl-parse.h"
@


1.10.4.1
log
@        * itbl-lex.l: Use #include <> for generated headers.
        * itbl-ops.c: Likewise.
@
text
@d95 1
a95 1
#include <itbl-parse.h>
@


1.9
log
@Use FOPEN_.. macros in calls to fopen().
@
text
@d510 1
a510 1
    return 0;			/* error!  must have a opcode name/expr */
@


1.8
log
@Warning fixes and configure/makefile tweaks by Thiemo Seufer.
@
text
@d186 2
a187 1
  yyin = fopen (insntbl, "r");
d194 4
a197 4
  else
    {
      while (yyparse ());
    }
@


1.7
log
@Fix copyright notices
@
text
@d2 1
a2 1
   Copyright 1997, 1999, 2000 Free Software Foundation, Inc.
d503 1
a503 1
  struct itbl_entry *e;
@


1.6
log
@2000-11-09  Kazu Hirata  <kazu@@hxi.com>

	* itbl-ops.c: Fix comment typos.
@
text
@d2 1
a2 1
   Copyright (C) 1997, 1998, 1999 Free Software Foundation, Inc.
@


1.6.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1997, 1999, 2000, 2001 Free Software Foundation, Inc.
@


1.6.2.2
log
@Merge from mainline.
@
text
@d503 1
a503 1
  struct itbl_entry *e = NULL;
@


1.5
log
@2000-11-06  Kazu Hirata  <kazu@@hxi.com>

	* as.c: Fix formatting.
	* dwarf2dbg.c: Likewise.
	* itbl-ops.c: Likewise.
	* listing.c: Likewise.
	* macro.h: Likewise.
	* messages.c: Likewise.
	* read.c: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* write.c: Likewise.
@
text
@d519 1
a519 1
    return 0;			/* opcode not in table; invalid instrustion */
d609 1
a609 1
    return 0;			/* opcode not in table; invalid instrustion */
@


1.4
log
@2000-09-09  Kazu Hirata  <kazu@@hxi.com>

	* input-file.c: Fix formatting.
	* itbl-ops.c: Likewise.
	* messages.c: Likewise.
@
text
@d117 11
a127 13
struct itbl_range
  {
    int sbit;			/* mask starting bit position */
    int ebit;			/* mask ending bit position */
  };

struct itbl_field
  {
    e_type type;		/* dreg/creg/greg/immed/symb */
    struct itbl_range range;	/* field's bitfield range within instruction */
    unsigned long flags;	/* field flags */
    struct itbl_field *next;	/* next field in list */
  };
d134 10
a143 11
struct itbl_entry
  {
    e_processor processor;	/* processor number */
    e_type type;		/* dreg/creg/greg/insn */
    char *name;			/* mnemionic name for insn/register */
    unsigned long value;	/* opcode/instruction mask/register number */
    unsigned long flags;	/* effects of the instruction */
    struct itbl_range range;	/* bit range within instruction for value */
    struct itbl_field *fields;	/* list of operand definitions (if any) */
    struct itbl_entry *next;	/* next entry */
  };
d149 1
a149 2
static struct itbl_entry *entries[e_nprocs][e_ntypes] =
{
d272 2
a273 1
/* initialize for gas */
d282 1
a282 1
	return;
d297 1
a297 1
					     e->value, &zero_address_frag));
d327 1
a327 1
	return;
d603 1
a603 1
    return 0;			/* error*/
d612 1
a612 1
  /* parse insn's args (if any) */
d618 1
a618 1
      if (f == e->fields)	/* first operand is preceeded by tab */
d620 1
a620 1
      else			/* ','s separate following operands */
d630 1
a630 1
			 * or '$' followed by the register number */
d638 3
a640 5
	  /* use assembler's symbol table to find symbol */
	  /* FIXME!! Do we need this?
			 *   if so, what about relocs??
			*/
	  /* If not a symbol, fall thru to IMMED */
d648 1
a648 1
  return 1;			/* done! */
@


1.3
log
@	* itbl-ops.c (itbl_disassemble): Change sprintf format strings to
	match parameters.
	(find_entry_byval): Add parens to avoid warning.
@
text
@a130 1

d135 1
a135 1
 * gnu assembler and are machine specific. */
a147 1

d164 1
a164 1
static struct itbl_entry **get_entries PARAMS ((e_processor processor, 
d166 1
a166 1
static struct itbl_entry *find_entry_byname PARAMS ((e_processor processor, 
d168 1
a168 1
static struct itbl_entry *find_entry_byval PARAMS ((e_processor processor, 
d170 1
a170 1
static struct itbl_entry *alloc_entry PARAMS ((e_processor processor, 
d172 1
a172 1
static unsigned long apply_range PARAMS ((unsigned long value, 
d174 1
a174 1
static unsigned long extract_range PARAMS ((unsigned long value, 
d176 1
a176 1
static struct itbl_field *alloc_field PARAMS ((e_type type, int sbit, 
a178 1

a181 1

d185 1
a185 1
int 
d212 1
a212 1
#if 0				
d255 1
a255 1
  /* Add to end of fields' list. */
a267 1

d277 1
a277 1
void 
d289 1
a289 1
     we can let gas parse registers for us. */
d306 2
a307 3

/* Append insns to opcodes table and increase number of opcodes 
 * Structure of opcodes table: 
d311 4
a314 4
 *   const char *args; 		- string describing the arguments.  
 *   unsigned long match; 	- opcode, or ISA level if pinfo=INSN_MACRO 
 *   unsigned long mask; 	- opcode mask, or macro id if pinfo=INSN_MACRO 
 *   unsigned long pinfo; 	- insn flags, or INSN_MACRO 
d322 1
a322 1
static void 
d349 1
a349 1
		we can't realloc or delete the old memory. */
d360 1
a360 1
		These need to be changed before itbls can be supported. */
d404 1
a404 1
		Eventually, we should also free the new opcodes table itself 
a450 1

a496 1

d502 1
a502 1
unsigned long 
d526 1
a526 1
  for (f = e->fields; f; f = f->next)	/* for each arg, ... */
d568 1
a568 1
	  if (*n == '0' && *(n + 1) == 'x')	/* hex begins 0x... */
d598 1
a598 1
int 
d616 1
a616 1
  for (f = e->fields; f; f = f->next)	/* for each arg, ... */
d665 1
a665 1
static unsigned long 
d686 1
a686 1
static unsigned long 
d710 1
a710 1
static unsigned long 
d767 1
a767 1
  for (e = *es; e; e = e->next)	/* for each entry, ... */
d789 1
a789 1
  for (e = *es; e; e = e->next)	/* for each entry, ... */
d799 1
a799 1
      /* if range is 0, mask val against the range of the compared entry. */
d820 1
a820 1
/* Return a pointer to the list of entries for a given processor and type. */
d828 1
a828 1
/* Return an integral value for the processor passed from yyparse. */
d830 1
a830 1
static e_processor 
d839 1
a839 1
/* Return an integral value for the entry type passed from yyparse. */
d841 1
a841 1
static e_type 
a862 1

@


1.2
log
@	Based on patches from John W. Woznack <jwoznack@@concentric.net>:
	* itbl-ops.c (itbl_get_reg_val): Add pval parameter.  Return
	indication of success rather than a value.
	(itbl_get_val): Likewise.
	(itbl_get_field): Use strcspn.  Change delimiters to include
	parens.
	* itbl-ops.h (itbl_get_reg_val): Update declaration.
	(itbl_get_val): Likewise.
	* config/tc-mips.c (mips_ip): Update call to itbl_get_reg_val.
@
text
@d646 1
a646 1
	    sprintf (s, "%s$%d", s, value);
d655 1
a655 1
	  sprintf (s, "%s0x%x", s, value);
d744 1
a744 1
  char *p, *ps, *s;
d814 2
a815 2
      else if (r->sbit == e->range.sbit && r->ebit == e->range.ebit
	       || e->range.sbit == 0 && e->range.ebit == 0)
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1997, 1998  Free Software Foundation, Inc.
d460 2
a461 2
unsigned long 
itbl_get_reg_val (char *name)
d465 1
a465 1
  int r = 0;
d467 7
a473 5
    for (t = e_regtype0; t < e_nregtypes; t++)
      {
	if (r = itbl_get_val (p, t, name), r)
	  return r;
      }
d491 3
a493 2
unsigned long 
itbl_get_val (e_processor processor, e_type type, char *name)
d498 4
a501 4
  if (r)
    return r->value;
  else
    return 0;			/* error; invalid operand */
d738 1
a738 1
 * delimiters are " ,\0" */
d750 2
a751 10
  p = s + strlen (s);
  if (ps = strchr (s, ','), ps)
    p = ps;
  if (ps = strchr (s, ' '), ps)
    p = min (p, ps);
  if (ps = strchr (s, '\0'), ps)
    p = min (p, ps);
  if (p == 0)
    return 0;			/* error! */
  len = p - s;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

