head	1.4;
access;
symbols
	binutils-2_24-branch:1.4.0.2
	binutils-2_24-branchpoint:1.4
	binutils-2_21_1:1.3
	binutils-2_23_2:1.3
	binutils-2_23_1:1.3
	binutils-2_23:1.3
	binutils-2_23-branch:1.3.0.8
	binutils-2_23-branchpoint:1.3
	binutils-2_22_branch:1.3.0.6
	binutils-2_22:1.3
	binutils-2_22-branch:1.3.0.4
	binutils-2_22-branchpoint:1.3
	binutils-2_21:1.3
	binutils-2_21-branch:1.3.0.2
	binutils-2_21-branchpoint:1.3
	binutils-2_20_1:1.1
	binutils-2_20:1.1
	binutils-arc-20081103-branch:1.1.0.16
	binutils-arc-20081103-branchpoint:1.1
	binutils-2_20-branch:1.1.0.14
	binutils-2_20-branchpoint:1.1
	dje-cgen-play1-branch:1.1.0.12
	dje-cgen-play1-branchpoint:1.1
	arc-20081103-branch:1.1.0.10
	arc-20081103-branchpoint:1.1
	binutils-2_19_1:1.1
	binutils-2_19:1.1
	binutils-2_19-branch:1.1.0.8
	binutils-2_19-branchpoint:1.1
	binutils-2_18:1.1
	binutils-2_18-branch:1.1.0.6
	binutils-2_18-branchpoint:1.1
	binutils-csl-coldfire-4_1-32:1.1
	binutils-csl-sourcerygxx-4_1-32:1.1
	binutils-csl-innovasic-fido-3_4_4-33:1.1
	binutils-csl-coldfire-4_1-30:1.1
	binutils-csl-sourcerygxx-4_1-30:1.1
	binutils-csl-coldfire-4_1-28:1.1
	binutils-csl-sourcerygxx-4_1-29:1.1
	binutils-csl-sourcerygxx-4_1-28:1.1
	binutils-csl-arm-2006q3-27:1.1
	binutils-csl-sourcerygxx-4_1-27:1.1
	binutils-csl-arm-2006q3-26:1.1
	binutils-csl-sourcerygxx-4_1-26:1.1
	binutils-csl-sourcerygxx-4_1-25:1.1
	binutils-csl-sourcerygxx-4_1-24:1.1
	binutils-csl-sourcerygxx-4_1-23:1.1
	binutils-csl-sourcerygxx-4_1-21:1.1
	binutils-csl-arm-2006q3-21:1.1
	binutils-csl-sourcerygxx-4_1-22:1.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.1
	binutils-csl-sourcerygxx-4_1-20:1.1
	binutils-csl-arm-2006q3-19:1.1
	binutils-csl-sourcerygxx-4_1-19:1.1
	binutils-csl-sourcerygxx-4_1-18:1.1
	binutils-csl-renesas-4_1-9:1.1
	binutils-csl-renesas-4_1-8:1.1
	binutils-csl-renesas-4_1-7:1.1
	binutils-csl-renesas-4_1-6:1.1
	binutils-csl-sourcerygxx-4_1-17:1.1
	binutils-csl-sourcerygxx-4_1-14:1.1
	binutils-csl-sourcerygxx-4_1-15:1.1
	binutils-csl-sourcerygxx-4_1-13:1.1
	binutils-2_17:1.1
	binutils-csl-sourcerygxx-4_1-12:1.1
	binutils-csl-sourcerygxx-3_4_4-21:1.1
	binutils-csl-sourcerygxx-4_1-9:1.1
	binutils-csl-sourcerygxx-4_1-8:1.1
	binutils-csl-sourcerygxx-4_1-7:1.1
	binutils-csl-arm-2006q1-6:1.1
	binutils-csl-sourcerygxx-4_1-6:1.1
	binutils-csl-coldfire-4_1-11:1.1
	binutils-csl-sourcerygxx-3_4_4-19:1.1
	binutils-csl-coldfire-4_1-10:1.1
	binutils-csl-sourcerygxx-4_1-5:1.1
	binutils-csl-sourcerygxx-4_1-4:1.1
	binutils-csl-morpho-4_1-4:1.1
	binutils-csl-sourcerygxx-3_4_4-17:1.1
	binutils-2_17-branch:1.1.0.4
	binutils-2_17-branchpoint:1.1
	binutils-csl-2_17-branch:1.1.0.2
	binutils-csl-2_17-branchpoint:1.1
	binutils_latest_snapshot:1.4;
locks; strict;
comment	@# @;


1.4
date	2012.12.17.16.56.00;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2009.12.19.19.34.07;	author devans;	state Exp;
branches;
next	1.2;

1.2
date	2009.10.19.15.27.39;	author devans;	state Exp;
branches;
next	1.1;

1.1
date	2006.02.17.14.36.25;	author nickc;	state Exp;
branches;
next	;


desc
@@


1.4
log
@Add copyright notices
@
text
@# Copyright 2012
# Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  

#
# Some xc16x tests
#
proc do_xc16x_add {} {
    set testname "add.s: xc16x add word tests"
    set x 0

    gas_start "add.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 0001\[^\n\]*\n"  { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0002 0809\[^\n\]*\n"  { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0004 080D\[^\n\]*\n"  { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0006 0803\[^\n\]*\n"  { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0008 06F0D204\[^\n\]*\n"  { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000c 02F0EDFF\[^\n\]*\n"  { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0010 04F0EDFF\[^\n\]*\n"  { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof				    { break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 7] then { pass $testname } else { fail $testname }
}

proc do_xc16x_addb {} {
    set testname "addb.s: xc16x add byte tests"
    set x 0

    gas_start "addb.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 0102\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0002 0909\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0004 090D\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0006 0902\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0008 07F03300\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000c 03F08723\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0010 05F08723\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 7] then { pass $testname } else { fail $testname }
}

proc do_xc16x_addc {} {
    set testname "addc.s: xc16x add with carry tests"
    set x 0

    gas_start "addc.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 1001\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0002 1809\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0004 180D\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0006 16F03400\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000a 16F05634\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000e 12F08723\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0012 14F08723\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 7] then { pass $testname } else { fail $testname }
}

proc do_xc16x_addcb {} {
    set testname "addcb.s: xc16x add byte with carry tests"
    set x 0

    gas_start "addcb.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 1102\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0002 1909\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0004 190D\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0006 17F00200\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000a 17F02300\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000e 15F08723\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 6] then { pass $testname } else { fail $testname }
}

proc do_xc16x_sub {} {
    set testname "sub.s: xc16x sub tests"
    set x 0

    gas_start "sub.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 2001\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0002 2809\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0004 280D\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0006 2801\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0008 26F04376\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000c 22F04376\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0010 24F04376\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 7] then { pass $testname } else { fail $testname }
}

proc do_xc16x_subb {} {
    set testname "subb.s: xc16x sub byte tests"
    set x 0

    gas_start "subb.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 2102\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0002 2909\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0004 290D\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0006 2901\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0008 27F04300\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000c 23F04376\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0010 25F04376\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 7] then { pass $testname } else { fail $testname }
}

proc do_xc16x_subc {} {
    set testname "subc.s: xc16x sub with carry tests"
    set x 0

    gas_start "subc.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 3001\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0002 3809\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0004 380D\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0006 3802\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0008 36F04300\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000c 32F04376\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0010 34F04376\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 7] then { pass $testname } else { fail $testname }
}

proc do_xc16x_subcb {} {
    set testname "subcb.s: xc16x sub byte with carry tests"
    set x 0

    gas_start "subcb.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 3102\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0002 3909\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0004 390D\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0006 3902\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0008 37F04300\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000c 33F04376\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0010 35F04376\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 7] then { pass $testname } else { fail $testname }
}

proc do_xc16x_and {} {
    set testname "and.s: xc16x and tests"
    set x 0

    gas_start "and.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 6001\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0002 6809\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0004 680D\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0006 6803\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0008 66F0BEFC\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000c 62F03002\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0010 64F02003\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 7] then { pass $testname } else { fail $testname }
}

proc do_xc16x_andb {} {
    set testname "andb.s: xc16x and byte tests"
    set x 0

    gas_start "andb.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 6102\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0002 6909\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0004 690D\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0006 6903\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0008 67F0BE00\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000c 63F03002\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0010 65F02003\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 7] then { pass $testname } else { fail $testname }
}

proc do_xc16x_or {} {
    set testname "or.s: xc16x or tests"
    set x 0

    gas_start "or.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 7001\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0002 7809\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0004 780D\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0006 7803\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0008 76F03402\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000c 72F03645\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0010 74F03645\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 7] then { pass $testname } else { fail $testname }
}

proc do_xc16x_xor {} {
    set testname "xor.s: xc16x xor tests"
    set x 0

    gas_start "xor.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 5001\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0002 5809\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0004 580D\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0006 5803\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0008 56F03402\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000c 52F03402\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0010 54F03402\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 7] then { pass $testname } else { fail $testname }
}

proc do_xc16x_xorb {} {
    set testname "xorb.s: xc16x xorb tests"
    set x 0

    gas_start "xorb.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 5102\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0002 5909\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0004 590D\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0006 5903\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0008 57F03400\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000c 53F00324\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0010 55F00324\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 7] then { pass $testname } else { fail $testname }
    
}

proc do_xc16x_mov {} {
    set testname "mov.s: xc16x mov tests"
    set x 0

    gas_start "mov.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 F001\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0002 E6F00200\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0006 E6F0BEFC\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000a A801\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000c 9801\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000e B810\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0010 8810\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0012 C801\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0014 D801\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0016 E801\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0018 D400CBFF\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 001c C400CBFF\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0020 8400CBFF\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0024 9400CBFF\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0028 F2F0CBFF\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 002c F6F0CBFF\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 16] then { pass $testname } else { fail $testname }
}

proc do_xc16x_movb {} {
    set testname "movb.s: xc16x movb tests"
    set x 0

    gas_start "movb.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 F3F00000\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0004 E7F01200\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0008 B4020000\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000c 9902\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000e 8902\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0010 E932\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0012 C932\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0014 D923\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0016 E923\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0018 F4033412\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 001c E4033412\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0020 A4033412\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0024 A403FFEE\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0028 B4033412\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 002c F3F01200\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0030 F7F01200\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 16] then { pass $testname } else { fail $testname }
}

proc do_xc16x_movbs {} {
    set testname "movbs.s: xc16x mov byte tests"
    set x 0

    gas_start "movbs.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 D020\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0002 D2F0FF00\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0006 D5F0CBFF\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 3] then { pass $testname } else { fail $testname }
}

proc do_xc16x_movbz {} {
    set testname "movbz.s: xc16x movbz tests"
    set x 0

    gas_start "movbz.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 C002\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0002 C2F0DD23\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0006 C5F02300\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 3] then { pass $testname } else { fail $testname }
}

proc do_xc16x_pushpop {} {
    set testname "pushpop.s: xc16x push/pop tests"
    set x 0

    gas_start "pushpop.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 FCF0\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0002 ECF0\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 2] then { pass $testname } else { fail $testname }
}

proc do_xc16x_shlrol {} {
    set testname "shlrol.s: xc16x shift and rotate tests"
    set x 0

    gas_start "shlrol.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 4C01\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0002 5C40\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0004 6C01\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0006 7C40\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0008 0C01\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000a 1C40\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000c 2C01\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000e 3C40\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0010 AC01\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0012 BC40\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 10] then { pass $testname } else { fail $testname }
}

proc do_xc16x_neg {} {
    set testname "neg.s: xc16x neg tests"
    set x 0

    gas_start "neg.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 8100\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0002 A100\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 2] then { pass $testname } else { fail $testname }
}
proc do_xc16x_mul {} {
    set testname "mul.s: xc16x multiply tests"
    set x 0

    gas_start "mul.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 0B01\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0002 1B01\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 2] then { pass $testname } else { fail $testname }
}

proc do_xc16x_div {} {
    set testname "div.s: xc16x division tests"
    set x 0

    gas_start "div.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 4B00\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0002 6B00\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0004 7B00\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0006 5B00\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 4] then { pass $testname } else { fail $testname }
}

proc do_xc16x_jmpa {} {
    set testname "jmpa.s: xc16x jump absolute test"
    set x 0

    gas_start "jmpa.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 EA00AAAA\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0004 EA20AAAA\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0008 EA30AAAA\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000c EA40AAAA\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0010 EA50AAAA\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0014 EA60AAAA\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0018 EA70AAAA\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 001c EA80AAAA\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0020 EA90AAAA\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0024 EA20AAAA\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0028 EA30AAAA\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 002c EA80AAAA\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0030 EAF0AAAA\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0034 EA90AAAA\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0038 EAE0AAAA\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 003c EAB0AAAA\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0040 EAD0AAAA\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0044 EAA0AAAA\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0048 EA10AAAA\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 19] then { pass $testname } else { fail $testname }
}

proc do_xc16x_jmpi {} {
    set testname "jmpi.s: xc16x jmp immidiate tests "
    set x 0

    gas_start "jmpi.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 9C07\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0002 9C27\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0004 9C37\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0006 9C47\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0008 9C57\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000a 9C67\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000c 9C77\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000e 9C87\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0010 9C97\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0012 9C27\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0014 9C37\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0016 9C87\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0018 9CF7\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 001a 9C97\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 001c 9CE7\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 001e 9CB7\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0020 9CD7\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0022 9CA7\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0024 9C17\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 19] then { pass $testname } else { fail $testname }
}


proc do_xc16x_jmpr {} {
    set testname "jmpr.s: xc16x jump relative tests"
    set x 0

    gas_start "jmpr.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 0DFF\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0002 2DFE\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0004 3DFD\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0006 4DFC\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0008 5DFB\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000a 6DFA\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000c 7DF9\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000e 8DF8\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0010 9DF7\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0012 2DF6\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0014 3DF5\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0016 8DF4\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0018 FDF3\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 001a 9DF2\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 001c EDF1\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 001e BDF0\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0020 DDEF\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0022 ADEE\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0024 1DED\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0026 CDEC\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 20] then { pass $testname } else { fail $testname }
}

proc do_xc16x_syscontrol1 {} {
    set testname "syscontrol1.s: xc16x system control insrutions tests"
    set x 0

    gas_start "syscontrol1.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 B748B7B7\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0004 8C00\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0006 87788787\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000a 97689797\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000e A758A7A7\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0012 A55AA5A5\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0016 857A8585\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 001a B54AB5B5\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 8] then { pass $testname } else { fail $testname }
}

proc do_xc16x_syscontrol2 {} {
    set testname "syscontrol2.s: xc16x syscontrol2 tests"
    set x 0

    gas_start "syscontrol2.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 D1B0\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0002 D1A0\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0004 D190\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0006 D180\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0008 D130\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000a D120\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000c D110\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000e D100\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0010 DC75\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0012 D770FF03\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0016 DCF5\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0018 D7F0FF03\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 001c DC35\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 001e D7300100\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0022 DCB5\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0024 D7B00100\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 16] then { pass $testname } else { fail $testname }
}

proc do_xc16x_cpl {} {
    set testname "cpl.s: xc16x compliment tests"
    set x 0

    gas_start "cpl.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 9100\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0002 B100\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 2] then { pass $testname } else { fail $testname }
}

proc do_xc16x_cmp {} {
    set testname "cmp.s: xc16x misc tests"
    set x 0

    gas_start "cmp.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 4001\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0002 4809\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0004 480D\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0006 4803\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0008 46F03402\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000c 42F05234\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 6] then { pass $testname } else { fail $testname }
}

proc do_xc16x_cmpb {} {
    set testname "cmpb.s: xc16x cmp byte tests"
    set x 0

    gas_start "cmpb.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 4102\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0002 4909\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0004 490D\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0006 4903\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0008 47F02200\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000c 43F03402\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 6] then { pass $testname } else { fail $testname }
}

proc do_xc16x_cmpi {} {
    set testname "cmpi.s: xc16x cmpi tests"
    set x 0

    gas_start "cmpi.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 A0F0\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0002 A6F0CBFC\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0006 A2F0CBFF\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000a B0F0\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000c B6F0CBFC\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0010 B2F0CBFF\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0014 80F0\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0016 86F0CBFC\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 001a 82F0CBFF\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 001e 90F0\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0020 96F0CBFC\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0024 92F0CBFF\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 12] then { pass $testname } else { fail $testname }
}

proc do_xc16x_calli {} {
    set testname "calli.s: xc16x call tests"
    set x 0

    gas_start "calli.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 AB01\[^\n\]*\n"   { set x [expr $x+1] }
    	    -re " +\[0-9\]+ 0002 AB21\[^\n\]*\n"   { set x [expr $x+1] }
    	    -re " +\[0-9\]+ 0004 AB31\[^\n\]*\n"   { set x [expr $x+1] }
    	    -re " +\[0-9\]+ 0006 AB41\[^\n\]*\n"   { set x [expr $x+1] }
    	    -re " +\[0-9\]+ 0008 AB51\[^\n\]*\n"   { set x [expr $x+1] }
    	    -re " +\[0-9\]+ 000a AB61\[^\n\]*\n"   { set x [expr $x+1] }
    	    -re " +\[0-9\]+ 000c AB71\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000e AB81\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0010 AB91\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0012 AB21\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0014 AB31\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0016 AB81\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0018 ABF1\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 001a AB91\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 001c ABE1\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 001e ABB1\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0020 ABD1\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0022 AB11\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0024 ABC1\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 19] then { pass $testname } else { fail $testname }
}

proc do_xc16x_calla {} {
    set testname "calla.s: xc16x call tests"
    set x 0

    gas_start "calla.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 CA00AAAA\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0004 CA20AAAA\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0008 CA30AAAA\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000c CA40AAAA\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0010 CA50AAAA\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0014 CA60AAAA\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0018 CA70AAAA\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 001c CA80AAAA\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0020 CA90AAAA\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0024 CA20AAAA\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0028 CA30AAAA\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 002c CA80AAAA\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0030 CAF0AAAA\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0034 CA90AAAA\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0038 CAE0AAAA\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 003c CAB0AAAA\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0040 CAD0AAAA\[^\n\]*\n"   { set x [expr $x+1] }
    	    -re " +\[0-9\]+ 0044 CAA0AAAA\[^\n\]*\n"   { set x [expr $x+1] }
    	    -re " +\[0-9\]+ 0048 CA10AAAA\[^\n\]*\n"   { set x [expr $x+1] }
    	    -re " +\[0-9\]+ 004c CAC0AAAA\[^\n\]*\n"   { set x [expr $x+1] }
    	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 20] then { pass $testname } else { fail $testname }
}


proc do_xc16x_bit {} {
    set testname "bit.s: xc16x bit manipulation tests"
    set x 0

    gas_start "bit.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 1EF0\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0002 1FF0\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0004 4AF0F012\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0008 3AF0F023\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000c 6AF0F041\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0010 5AF0F021\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0014 7AF0F021\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0018 2AF0F021\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 8] then { pass $testname } else { fail $testname }
}

proc do_xc16x_bfldl {} {
    set testname "bfldl.s: xc16x bitwise modify masked data tests"
    set x 0

    gas_start "bfldl.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 0AF0870E\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0004 1AF00EFF\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 2] then { pass $testname } else { fail $testname }
}

proc do_xc16x_ret {} {
    set testname "ret.s: xc16x ret tests"
    set x 0

    gas_start "ret.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 CB00\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0002 FB88\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0004 DB00\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0006 EBF5\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 4] then { pass $testname } else { fail $testname }
}

proc do_xc16x_trap {} {
    set testname "trap.s: xc16x add/sub tests"
    set x 0

    gas_start "trap.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 9B04\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 1] then { pass $testname } else { fail $testname }
}

proc do_xc16x_orb {} {
    set testname "orb.s: xc16x or byte instructions tests"
    set x 0

    gas_start "orb.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 7102\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0002 7909\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0004 790D\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0006 7903\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0008 77F02300\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 000c 73F03402\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0010 75F03402\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 7] then { pass $testname } else { fail $testname }
}


proc do_xc16x_prior {} {
    set testname "prior.s: Determine no shift cycles tests"
    set x 0

    gas_start "prior.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 2B01\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 1] then { pass $testname } else { fail $testname }
}

proc do_xc16x_nop {} {
    set testname "nop.s: no operation nop tests"
    set x 0

    gas_start "nop.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 CC00\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0002 CC00\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 2] then { pass $testname } else { fail $testname }
}


proc do_xc16x_scxt {} {
    set testname "scxt.s: push direct word to system stack tests"
    set x 0

    gas_start "scxt.s" "-al"

    # Check each instruction bit pattern to verify it got
    # assembled correctly.
    while 1 {
	expect {
	    -re " +\[0-9\]+ 0000 C6F0FFFF\[^\n\]*\n"   { set x [expr $x+1] }
	    -re " +\[0-9\]+ 0004 D6F0FFFF\[^\n\]*\n"   { set x [expr $x+1] }
	    timeout 				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x == 2] then { pass $testname } else { fail $testname }
}


if [istarget xc16x*-*-*] then {
    # Test the basic xc16x instruction parser
    do_xc16x_add
    do_xc16x_addb
    do_xc16x_addc
    do_xc16x_addcb
    do_xc16x_sub
    do_xc16x_subb
    do_xc16x_subc
    do_xc16x_subcb
    do_xc16x_and
    do_xc16x_andb
    do_xc16x_or
    do_xc16x_xor
    do_xc16x_xorb
    do_xc16x_mov
    do_xc16x_movb
    do_xc16x_movbs
    do_xc16x_movbz
    do_xc16x_shlrol
    do_xc16x_neg
    do_xc16x_mul
    do_xc16x_div
    do_xc16x_jmpa
    do_xc16x_jmpi
    do_xc16x_jmpr
    do_xc16x_syscontrol1
    do_xc16x_syscontrol2
    do_xc16x_cpl
    do_xc16x_cmp
    do_xc16x_cmpb
    do_xc16x_cmpi
    do_xc16x_calla
    do_xc16x_calli
    do_xc16x_bit
    do_xc16x_bfldl
    do_xc16x_ret
    do_xc16x_trap
    do_xc16x_orb
    do_xc16x_prior
    do_xc16x_nop
    do_xc16x_scxt
    
}
@


1.3
log
@	* gas/xc16x/xc16x.exp (*): Add missing " in timeout cases.
@
text
@d1 17
@


1.2
log
@	* config/tc-xc16x.c (md_cgen_lookup_reloc): Ensure fix_size is set
	correctly for all 16 bit relocs.  Return BFD_RELOC_NONE if reloc
	isn't recognized, not BFD_RELOC_XC16X_SOF.

	testsuite:
	* gas/xc16x/shlrol.s: Specify constant shift amount.
	* gas/xc16x/xc16x.exp (do_xc16x_shlrol): Update expected output.
@
text
@d21 1
a21 1
	    timeout 				{ perror "timeout\n; break }
d51 1
a51 1
	    timeout 				{ perror "timeout\n; break }
d81 1
a81 1
	    timeout 				{ perror "timeout\n; break }
d110 1
a110 1
	    timeout 				{ perror "timeout\n; break }
d140 1
a140 1
	    timeout 				{ perror "timeout\n; break }
d170 1
a170 1
	    timeout 				{ perror "timeout\n; break }
d200 1
a200 1
	    timeout 				{ perror "timeout\n; break }
d230 1
a230 1
	    timeout 				{ perror "timeout\n; break }
d260 1
a260 1
	    timeout 				{ perror "timeout\n; break }
d290 1
a290 1
	    timeout 				{ perror "timeout\n; break }
d320 1
a320 1
	    timeout 				{ perror "timeout\n; break }
d350 1
a350 1
	    timeout 				{ perror "timeout\n; break }
d380 1
a380 1
	    timeout 				{ perror "timeout\n; break }
d420 1
a420 1
	    timeout 				{ perror "timeout\n; break }
d459 1
a459 1
	    timeout 				{ perror "timeout\n; break }
d485 1
a485 1
	    timeout 				{ perror "timeout\n; break }
d511 1
a511 1
	    timeout 				{ perror "timeout\n; break }
d536 1
a536 1
	    timeout 				{ perror "timeout\n; break }
d569 1
a569 1
	    timeout 				{ perror "timeout\n; break }
d594 1
a594 1
	    timeout 				{ perror "timeout\n; break }
d618 1
a618 1
	    timeout 				{ perror "timeout\n; break }
d645 1
a645 1
	    timeout 				{ perror "timeout\n; break }
d687 1
a687 1
	    timeout 				{ perror "timeout\n; break }
d729 1
a729 1
	    timeout 				{ perror "timeout\n; break }
d773 1
a773 1
	    timeout 				{ perror "timeout\n; break }
d804 1
a804 1
	    timeout 				{ perror "timeout\n; break }
d843 1
a843 1
	    timeout 				{ perror "timeout\n; break }
d868 1
a868 1
	    timeout 				{ perror "timeout\n; break }
d897 1
a897 1
	    timeout 				{ perror "timeout\n; break }
d926 1
a926 1
	    timeout 				{ perror "timeout\n; break }
d961 1
a961 1
	    timeout 				{ perror "timeout\n; break }
d1003 1
a1003 1
	    timeout 				{ perror "timeout\n; break }
d1046 1
a1046 1
    	    timeout 				{ perror "timeout\n; break }
d1078 1
a1078 1
	    timeout 				{ perror "timeout\n; break }
d1103 1
a1103 1
	    timeout 				{ perror "timeout\n; break }
d1130 1
a1130 1
	    timeout 				{ perror "timeout\n; break }
d1154 1
a1154 1
	    timeout 				{ perror "timeout\n; break }
d1184 1
a1184 1
	    timeout 				{ perror "timeout\n; break }
d1209 1
a1209 1
	    timeout 				{ perror "timeout\n; break }
d1234 1
a1234 1
	    timeout 				{ perror "timeout\n; break }
d1260 1
a1260 1
	    timeout 				{ perror "timeout\n; break }
@


1.1
log
@Add support for the Infineon XC16X.
@
text
@d560 1
a560 1
	    -re " +\[0-9\]+ 0002 5C00\[^\n\]*\n"   { set x [expr $x+1] }
d562 1
a562 1
	    -re " +\[0-9\]+ 0006 7C00\[^\n\]*\n"   { set x [expr $x+1] }
d564 1
a564 1
	    -re " +\[0-9\]+ 000a 1C00\[^\n\]*\n"   { set x [expr $x+1] }
d566 1
a566 1
	    -re " +\[0-9\]+ 000e 3C00\[^\n\]*\n"   { set x [expr $x+1] }
d568 1
a568 1
	    -re " +\[0-9\]+ 0012 BC00\[^\n\]*\n"   { set x [expr $x+1] }
@

