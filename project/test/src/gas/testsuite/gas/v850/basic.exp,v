head	1.10;
access;
symbols
	binutils-2_24-branch:1.10.0.2
	binutils-2_24-branchpoint:1.10
	binutils-2_21_1:1.8
	binutils-2_23_2:1.8
	binutils-2_23_1:1.8
	binutils-2_23:1.8
	binutils-2_23-branch:1.8.0.10
	binutils-2_23-branchpoint:1.8
	binutils-2_22_branch:1.8.0.8
	binutils-2_22:1.8
	binutils-2_22-branch:1.8.0.6
	binutils-2_22-branchpoint:1.8
	binutils-2_21:1.8
	binutils-2_21-branch:1.8.0.4
	binutils-2_21-branchpoint:1.8
	binutils-2_20_1:1.8
	binutils-2_20:1.8
	binutils-arc-20081103-branch:1.7.0.10
	binutils-arc-20081103-branchpoint:1.7
	binutils-2_20-branch:1.8.0.2
	binutils-2_20-branchpoint:1.8
	dje-cgen-play1-branch:1.7.0.8
	dje-cgen-play1-branchpoint:1.7
	arc-20081103-branch:1.7.0.6
	arc-20081103-branchpoint:1.7
	binutils-2_19_1:1.7
	binutils-2_19:1.7
	binutils-2_19-branch:1.7.0.4
	binutils-2_19-branchpoint:1.7
	binutils-2_18:1.7
	binutils-2_18-branch:1.7.0.2
	binutils-2_18-branchpoint:1.7
	binutils-csl-coldfire-4_1-32:1.6
	binutils-csl-sourcerygxx-4_1-32:1.6
	binutils-csl-innovasic-fido-3_4_4-33:1.6
	binutils-csl-sourcerygxx-3_4_4-32:1.5
	binutils-csl-coldfire-4_1-30:1.6
	binutils-csl-sourcerygxx-4_1-30:1.6
	binutils-csl-coldfire-4_1-28:1.6
	binutils-csl-sourcerygxx-4_1-29:1.6
	binutils-csl-sourcerygxx-4_1-28:1.6
	binutils-csl-arm-2006q3-27:1.6
	binutils-csl-sourcerygxx-4_1-27:1.6
	binutils-csl-arm-2006q3-26:1.6
	binutils-csl-sourcerygxx-4_1-26:1.6
	binutils-csl-sourcerygxx-4_1-25:1.6
	binutils-csl-sourcerygxx-4_1-24:1.6
	binutils-csl-sourcerygxx-4_1-23:1.6
	binutils-csl-sourcerygxx-4_1-21:1.6
	binutils-csl-arm-2006q3-21:1.6
	binutils-csl-sourcerygxx-4_1-22:1.6
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.6
	binutils-csl-sourcerygxx-4_1-20:1.6
	binutils-csl-arm-2006q3-19:1.6
	binutils-csl-sourcerygxx-4_1-19:1.6
	binutils-csl-sourcerygxx-4_1-18:1.6
	binutils-csl-renesas-4_1-9:1.6
	binutils-csl-sourcerygxx-3_4_4-25:1.5
	binutils-csl-renesas-4_1-8:1.6
	binutils-csl-renesas-4_1-7:1.6
	binutils-csl-renesas-4_1-6:1.6
	binutils-csl-sourcerygxx-4_1-17:1.6
	binutils-csl-sourcerygxx-4_1-14:1.6
	binutils-csl-sourcerygxx-4_1-15:1.6
	binutils-csl-sourcerygxx-4_1-13:1.6
	binutils-2_17:1.6
	binutils-csl-sourcerygxx-4_1-12:1.6
	binutils-csl-sourcerygxx-3_4_4-21:1.6
	binutils-csl-wrs-linux-3_4_4-24:1.5
	binutils-csl-wrs-linux-3_4_4-23:1.5
	binutils-csl-sourcerygxx-4_1-9:1.6
	binutils-csl-sourcerygxx-4_1-8:1.6
	binutils-csl-sourcerygxx-4_1-7:1.6
	binutils-csl-arm-2006q1-6:1.6
	binutils-csl-sourcerygxx-4_1-6:1.6
	binutils-csl-wrs-linux-3_4_4-22:1.5
	binutils-csl-coldfire-4_1-11:1.6
	binutils-csl-sourcerygxx-3_4_4-19:1.6
	binutils-csl-coldfire-4_1-10:1.6
	binutils-csl-sourcerygxx-4_1-5:1.6
	binutils-csl-sourcerygxx-4_1-4:1.6
	binutils-csl-wrs-linux-3_4_4-21:1.5
	binutils-csl-morpho-4_1-4:1.6
	binutils-csl-sourcerygxx-3_4_4-17:1.6
	binutils-csl-wrs-linux-3_4_4-20:1.5
	binutils-2_17-branch:1.6.0.4
	binutils-2_17-branchpoint:1.6
	binutils-csl-2_17-branch:1.6.0.2
	binutils-csl-2_17-branchpoint:1.6
	binutils-csl-gxxpro-3_4-branch:1.5.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.5
	binutils-2_16_1:1.5
	binutils-csl-arm-2005q1b:1.5
	binutils-2_16:1.5
	binutils-csl-arm-2005q1a:1.5
	binutils-csl-arm-2005q1-branch:1.5.0.4
	binutils-csl-arm-2005q1-branchpoint:1.5
	binutils-2_16-branch:1.5.0.2
	binutils-2_16-branchpoint:1.5
	csl-arm-2004-q3d:1.3
	csl-arm-2004-q3:1.3
	binutils-2_15:1.3
	binutils-2_15-branchpoint:1.3
	csl-arm-2004-q1a:1.3
	csl-arm-2004-q1:1.3
	binutils-2_15-branch:1.3.0.6
	cagney_bfdfile-20040213-branch:1.3.0.4
	cagney_bfdfile-20040213-branchpoint:1.3
	cagney_bigcore-20040122-branch:1.3.0.2
	cagney_bigcore-20040122-branchpoint:1.3
	csl-arm-2003-q4:1.3
	binutils-2_14:1.2
	binutils-2_14-branch:1.2.0.2
	binutils-2_14-branchpoint:1.2
	binutils-2_13_2_1:1.1.1.1
	binutils-2_13_2:1.1.1.1
	binutils-2_13_1:1.1.1.1
	binutils-2_13:1.1.1.1
	binutils-2_13-branchpoint:1.1.1.1
	binutils-2_13-branch:1.1.1.1.0.8
	binutils-2_12_1:1.1.1.1
	binutils-2_12:1.1.1.1
	binutils-2_12-branch:1.1.1.1.0.6
	binutils-2_12-branchpoint:1.1.1.1
	cygnus_cvs_20020108_pre:1.1.1.1
	binutils-2_11_2:1.1.1.1
	binutils-2_11_1:1.1.1.1
	binutils-2_11:1.1.1.1
	x86_64versiong3:1.1.1.1
	binutils-2_11-branch:1.1.1.1.0.4
	binutils-2_10_1:1.1.1.1
	binutils-2_10:1.1.1.1
	binutils-2_10-branch:1.1.1.1.0.2
	binutils-2_10-branchpoint:1.1.1.1
	binutils_latest_snapshot:1.10
	repo-unification-2000-02-06:1.1.1.1
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@# @;


1.10
date	2013.01.15.08.45.44;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2013.01.14.13.11.31;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2009.09.02.07.24.26;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2007.07.03.11.01.11;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2005.05.05.09.13.19;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2005.03.03.11.48.02;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2004.12.16.16.56.04;	author rsandifo;	state Exp;
branches;
next	1.3;

1.3
date	2003.09.04.11.04.36;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	2002.09.09.01.54.44;	author bje;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.52;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.05.03.07.28.52;	author rth;	state Exp;
branches;
next	;


desc
@@


1.10
log
@	* config/tc-v850.c (md_assemble): Allow signed values for
	V850E_IMMEDIATE.

	* gas/v850/basic.exp: Allow for variations in reloc names.
	* gas/v850/split-lo16.d: Likewise.

	* gas/v850/v850e1.s: Add more tests of the PREPARE insn.
	* gas/v850/v850e1.d: Update expected disassembly.

	* v850-dis.c (get_operand_value): Sign extend V850E_IMMEDIATE
	values.
	* v850-opc.c (IMM16LO): Add V850_OPERAND_SIGNED attribute.
@
text
@# Copyright (C) 1996, 2002, 2003, 2004, 2005, 2007, 2013
# Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */

# Please email any bugs, comments, and/or additions to this file to:
# dejagnu@@gnu.org

# Written by Cygnus Support.

proc do_arith {} {
    set testname "arith.s: Arithmetic operations"
    set x 0

    gas_start "arith.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    # -re "^ +\[0-9\]+ 0000 489A0000\[^\n\]*\n"	{ set x [expr $x+1] }
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000 C531\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0002 4532\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0004 05360700\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0008 4530\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000a E530\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000c E532\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000e E5360700\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0012 E537A000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0016 BF32\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0018 C530\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001a 2532\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001c A530\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001e 65360700\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0022 8530\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0024 E537C000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0028 DF32\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 002a E5378000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 002e 9F32\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0030 A531\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0032 8531\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==20] then { pass $testname } else { fail $testname }
}

proc do_bit {} {
    set testname "bit.s: bit operations"
    set x 0

    gas_start "bit.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000 C6AF1000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0004 C66F1000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0008 C62F1000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000c C6EF1000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==4] then { pass $testname } else { fail $testname }
}

proc do_branch {} {
    set testname "branch.s: branch operations"
    set x 0

    gas_start "branch.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000 8F05\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0002 FEFD\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0004 E6FD\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0006 D7FD\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0008 CBFD\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000a B9FD\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000c A1FD\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000e 93FD\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0010 82FD\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0012 FAF5\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0014 E0F5\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0016 D8F5\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0018 C4F5\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001a BCF5\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001c A1F5\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001e 99F5\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0020 82F5\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0022 FAED\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0024 E5ED\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0026 DDED\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==20] then { pass $testname } else { fail $testname }
}

proc do_compare {} {
    set testname "compare.s: compare operations"
    set x 0

    gas_start "compare.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000 E531\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0002 6532\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0004 E02F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0008 E82F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000c E12F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0010 E12F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0014 E92F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0018 E92F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001c E22F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0020 EA2F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0024 E32F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0028 EB2F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 002c E42F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0030 E42F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0034 EC2F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0038 EC2F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 003c E52F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0040 ED2F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0044 E62F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0048 EE2F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 004c E72F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0050 EF2F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0054 6531\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==23] then { pass $testname } else { fail $testname }
}

proc do_jumps {} {
    set testname "jumps.s: jumps operations"
    set x 0

    gas_start "jumps.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000 802F0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0004 6500\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0006 BF07FAFF\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==3] then { pass $testname } else { fail $testname }
}

proc do_logical {} {
    set testname "logical.s: logical operations"
    set x 0

    gas_start "logical.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000 4531\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0002 C5360700\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0006 2530\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0008 0531\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000a 85360700\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000e 2531\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0010 A5360700\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==7] then { pass $testname } else { fail $testname }
}

proc do_mem {} {
    set testname "mem.s: memory operations"
    set x 0

    gas_start "mem.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000 05370500\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0004 25370400\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0008 25370500\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000c 4033\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000e 4034\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0010 4035\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0012 462F0500\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0016 662F0400\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001a 662F0500\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001e C033\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0020 C034\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0022 4135\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==12] then { pass $testname } else { fail $testname }
}

proc do_misc {} {
    set testname "misc.s: misc operations"
    set x 0

    gas_start "misc.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000 E0076001\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0004 E0876001\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0008 E0072001\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000c 0000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 000e E0074001\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0012 E0070001\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0016 FF070001\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001a E72F2000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 001e E53F4000\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==9] then { pass $testname } else { fail $testname }
}

proc do_move {} {
    set testname "move.s: move operations"
    set x 0

    gas_start "move.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000 0530\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0002 0532\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0004 25360700\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0008 45360700\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==4] then { pass $testname } else { fail $testname }
}

proc do_hilo {} {
    set testname "hilo.s: hilo tests"
    set x 0

    gas_start "hilo.s" "-al"

    # Instead of having a variable for each match string just increment the
    # total number of matches seen.  That's simpler when testing large numbers
    # of instructions (as these tests to).
    while 1 {
	expect {
	    -re "^ +\[0-9\]+ 0000 200EEFBE\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0004 410EAEDE\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "^ +\[0-9\]+ 0008 410EADDE\[^\n\]*\n"	{ set x [expr $x+1] }
	    -re "\[^\n\]*\n"				{ }
	    timeout				{ perror "timeout\n"; break }
	    eof					{ break }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    gas_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==3] then { pass $testname } else { fail $testname }
}


proc do_simple_reloc_tests {} {
    set testname "reloc.s: Test for proper relocations (part 2)"
    set x 0

    if [gas_test_old "reloc.s" "-mgcc-abi" "Test for proper relocation (part 1)"] then {
	objdump_start_no_subdir "a.out" "-r"

	while 1 {
	    expect {
		-re "^00000002\[^\n\]*R_V8\[A-Z0-9_\]+\[^\n\]*\n"
			{ set x [expr $x+1] }
		-re "^00000006\[^\n\]*R_V8\[A-Z0-9_\]+\[^\n\]*\n"
			{ set x [expr $x+1] }
		-re "^0000000a\[^\n\]*R_V8\[A-Z0-9_\]+\[^\n\]*\n"
			{ set x [expr $x+1] }
		-re "^0000000e\[^\n\]*R_V8\[A-Z0-9_\]+\[^\n\]*\n"
			{ set x [expr $x+1] }
		-re "^00000012\[^\n\]*R_V8\[A-Z0-9_\]+\[^\n\]*\n"
			{ set x [expr $x+1] }
		-re "^00000016\[^\n\]*R_V8\[A-Z0-9_\]+\[^\n\]*\n"
			{ set x [expr $x+1] }
		-re "\[^\n\]*\n"				{ }
		timeout			{ perror "timeout\n"; break }
		eof				{ break }
	    }
	}
    }

    # This was intended to do any cleanup necessary.  It kinda looks like it
    # isn't needed, but just in case, please keep it in for now.
    objdump_finish

    # Did we find what we were looking for?  If not, flunk it.
    if [expr $x==6] then { pass $testname } else { fail $testname }
}

if [istarget v850*-*-*] then {
    # Test the basic instruction parser.
    do_arith
    do_bit
    do_branch
    do_compare
    do_jumps
    do_logical
    do_mem
    do_misc
    do_move

    # Make sure we handle lo() hi() and hi0() correctly.
    do_hilo

    # Check for proper relocs on lo, hi, hi0, zdaoff, tdaoff and sdaoff
    # expressions
    do_simple_reloc_tests

    gas_test "hilo2.s" "" "" "hi/lo regression test"
    gas_test "fepsw.s" "" "" "eqsw regression test"

    gas_test_error "range.s" "-mwarn-signed-overflow" "Check for range error on byte load/store"
    run_dump_test "v850e1"
    run_dump_test "split-lo16"
}
@


1.9
log
@	* gas/v850/basic.exp (reloc part 1): Pass -mgcc-abi to gas.
	* gas/v850/split-lo16.d: Likewise.
@
text
@d389 1
a389 1
		-re "^00000002\[^\n\]*R_V850_LO16\[^\n\]*\n"
d391 1
a391 1
		-re "^00000006\[^\n\]*R_V850_HI16_S\[^\n\]*\n"
d393 1
a393 1
		-re "^0000000a\[^\n\]*R_V850_HI16\[^\n\]*\n"
d395 1
a395 1
		-re "^0000000e\[^\n\]*R_V850_ZDA_16_16_OFFSET\[^\n\]*\n"
d397 1
a397 1
		-re "^00000012\[^\n\]*R_V850_TDA_16_16_OFFSET\[^\n\]*\n"
d399 1
a399 1
		-re "^00000016\[^\n\]*R_V850_SDA_16_16_OFFSET\[^\n\]*\n"
@


1.8
log
@update copyright dates
@
text
@d1 1
a1 1
# Copyright (C) 1996, 2002, 2003, 2004, 2005, 2007
d384 1
a384 1
    if [gas_test_old "reloc.s" "" "Test for proper relocation (part 1)"] then {
@


1.7
log
@Switch to GPLv3
@
text
@d1 2
a2 1
# Copyright (C) 1996, 2002, 2003, 2004, 2007 Free Software Foundation, Inc.
@


1.6
log
@Update the address and phone number of the FSF
@
text
@d1 1
a1 1
# Copyright (C) 1996, 2002, 2003, 2004 Free Software Foundation, Inc.
d5 1
a5 1
# the Free Software Foundation; either version 2 of the License, or
@


1.5
log
@update copyright dates
@
text
@d15 1
a15 1
# Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.4
log
@include/elf/
	* v850.h (R_V850_LO16_SPLIT_OFFSET): New reloc.

bfd/
	* reloc.c (BFD_RELOC_V850_LO16_SPLIT_OFFSET): New bfd_reloc_code_type.
	* elf32-v850.c (v850_elf_howto_table): Add entry for
	R_V850_LO16_SPLIT_OFFSET.
	(v850_elf_reloc_map): Map it to BFD_RELOC_V850_LO16_SPLIT_OFFSET.
	(v850_elf_perform_lo16_relocation): New function, extracted from...
	(v850_elf_perform_relocation): ...here.  Use it to handle
	R_V850_LO16_SPLIT_OFFSET.
	(v850_elf_check_relocs, v850_elf_final_link_relocate): Handle
	R_V850_LO16_SPLIT_OFFSET.
	* libbfd.h, bfd-in2.h: Regenerate.

gas/
	* config/tc-v850.c (handle_lo16): New function.
	(v850_reloc_prefix): Use it to check lo().
	(md_assemble, md_apply_fix3): Handle BFD_RELOC_V850_LO16_SPLIT_OFFSET.

gas/testsuite/
	* gas/v850/split-lo16.{s,d}: New test.
	* gas/v850/v850.exp: Run it.

ld/testsuite/
	* ld-v850: New directory.
@
text
@d1 1
a1 1
# Copyright (C) 1996, 2003 Free Software Foundation, Inc.
@


1.3
log
@Add binutils support for v850e1 processor
@
text
@d439 1
@


1.2
log
@2002-09-08  Ben Elliston  <bje@@redhat.com>

	* gas/hppa/basic/basic.exp: Update DejaGnu mail address.
	* gas/hppa/parse/parse.exp: Likewise.
	* gas/hppa/reloc/reloc.exp: Likewise.
	* gas/hppa/unsorted/unsorted.exp: Likewise.
	* gas/mn10200/basic.exp: Likewise.
	* gas/mn10300/basic.exp: Likewise.
	* gas/sh/basic.exp: Likewise.
	* gas/sh/sh64/sh64.exp: Likewise.
	* gas/v850/basic.exp: Likewise.
	* lib/gas-defs.exp: Likewise.

	* gas/all/gas.exp: Removing limping support for DejaGnu 1.1.1.
	* gasp/gasp.exp: Likewise.
@
text
@d1 1
a1 1
# Copyright (C) 1996 Free Software Foundation, Inc.
d438 1
@


1.1
log
@Initial revision
@
text
@d18 1
a18 1
# DejaGnu@@cygnus.com
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

