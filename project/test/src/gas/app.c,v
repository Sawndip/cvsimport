head	1.56;
access;
symbols
	binutils-2_24-branch:1.56.0.2
	binutils-2_24-branchpoint:1.56
	binutils-2_21_1:1.52
	binutils-2_23_2:1.55
	binutils-2_23_1:1.55
	binutils-2_23:1.55
	binutils-2_23-branch:1.55.0.2
	binutils-2_23-branchpoint:1.55
	binutils-2_22_branch:1.52.0.6
	binutils-2_22:1.52
	binutils-2_22-branch:1.52.0.4
	binutils-2_22-branchpoint:1.52
	binutils-2_21:1.52
	binutils-2_21-branch:1.52.0.2
	binutils-2_21-branchpoint:1.52
	binutils-2_20_1:1.50.2.1
	binutils-2_20:1.50.2.1
	binutils-arc-20081103-branch:1.48.0.4
	binutils-arc-20081103-branchpoint:1.48
	binutils-2_20-branch:1.50.0.2
	binutils-2_20-branchpoint:1.50
	dje-cgen-play1-branch:1.49.0.2
	dje-cgen-play1-branchpoint:1.49
	arc-20081103-branch:1.48.0.2
	arc-20081103-branchpoint:1.48
	binutils-2_19_1:1.47.2.1
	binutils-2_19:1.47.2.1
	binutils-2_19-branch:1.47.0.2
	binutils-2_19-branchpoint:1.47
	binutils-2_18:1.44
	binutils-2_18-branch:1.44.0.2
	binutils-2_18-branchpoint:1.44
	binutils-csl-coldfire-4_1-32:1.34
	binutils-csl-sourcerygxx-4_1-32:1.34
	binutils-csl-innovasic-fido-3_4_4-33:1.34
	binutils-csl-sourcerygxx-3_4_4-32:1.29
	binutils-csl-coldfire-4_1-30:1.34
	binutils-csl-sourcerygxx-4_1-30:1.34
	binutils-csl-coldfire-4_1-28:1.34
	binutils-csl-sourcerygxx-4_1-29:1.34
	binutils-csl-sourcerygxx-4_1-28:1.34
	binutils-csl-arm-2006q3-27:1.34
	binutils-csl-sourcerygxx-4_1-27:1.34
	binutils-csl-arm-2006q3-26:1.34
	binutils-csl-sourcerygxx-4_1-26:1.34
	binutils-csl-sourcerygxx-4_1-25:1.34
	binutils-csl-sourcerygxx-4_1-24:1.34
	binutils-csl-sourcerygxx-4_1-23:1.34
	binutils-csl-sourcerygxx-4_1-21:1.34
	binutils-csl-arm-2006q3-21:1.34
	binutils-csl-sourcerygxx-4_1-22:1.34
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.34
	binutils-csl-sourcerygxx-4_1-20:1.34
	binutils-csl-arm-2006q3-19:1.34
	binutils-csl-sourcerygxx-4_1-19:1.34
	binutils-csl-sourcerygxx-4_1-18:1.34
	binutils-csl-renesas-4_1-9:1.34
	binutils-csl-sourcerygxx-3_4_4-25:1.29
	binutils-csl-renesas-4_1-8:1.34
	binutils-csl-renesas-4_1-7:1.34
	binutils-csl-renesas-4_1-6:1.34
	binutils-csl-sourcerygxx-4_1-17:1.34
	binutils-csl-sourcerygxx-4_1-14:1.34
	binutils-csl-sourcerygxx-4_1-15:1.34
	binutils-csl-sourcerygxx-4_1-13:1.34
	binutils-2_17:1.34
	binutils-csl-sourcerygxx-4_1-12:1.34
	binutils-csl-sourcerygxx-3_4_4-21:1.34
	binutils-csl-wrs-linux-3_4_4-24:1.29
	binutils-csl-wrs-linux-3_4_4-23:1.29
	binutils-csl-sourcerygxx-4_1-9:1.34
	binutils-csl-sourcerygxx-4_1-8:1.34
	binutils-csl-sourcerygxx-4_1-7:1.34
	binutils-csl-arm-2006q1-6:1.34
	binutils-csl-sourcerygxx-4_1-6:1.34
	binutils-csl-wrs-linux-3_4_4-22:1.29
	binutils-csl-coldfire-4_1-11:1.34
	binutils-csl-sourcerygxx-3_4_4-19:1.34
	binutils-csl-coldfire-4_1-10:1.34
	binutils-csl-sourcerygxx-4_1-5:1.34
	binutils-csl-sourcerygxx-4_1-4:1.34
	binutils-csl-wrs-linux-3_4_4-21:1.29
	binutils-csl-morpho-4_1-4:1.34
	binutils-csl-sourcerygxx-3_4_4-17:1.34
	binutils-csl-wrs-linux-3_4_4-20:1.29
	binutils-2_17-branch:1.34.0.4
	binutils-2_17-branchpoint:1.34
	binutils-csl-2_17-branch:1.34.0.2
	binutils-csl-2_17-branchpoint:1.34
	binutils-csl-gxxpro-3_4-branch:1.29.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.29
	binutils-2_16_1:1.29
	binutils-csl-arm-2005q1b:1.29
	binutils-2_16:1.29
	binutils-csl-arm-2005q1a:1.29
	binutils-csl-arm-2005q1-branch:1.29.0.4
	binutils-csl-arm-2005q1-branchpoint:1.29
	binutils-2_16-branch:1.29.0.2
	binutils-2_16-branchpoint:1.29
	csl-arm-2004-q3d:1.28
	csl-arm-2004-q3:1.28
	binutils-2_15:1.28
	binutils-2_15-branchpoint:1.28
	csl-arm-2004-q1a:1.28
	csl-arm-2004-q1:1.28
	binutils-2_15-branch:1.28.0.6
	cagney_bfdfile-20040213-branch:1.28.0.4
	cagney_bfdfile-20040213-branchpoint:1.28
	cagney_bigcore-20040122-branch:1.28.0.2
	cagney_bigcore-20040122-branchpoint:1.28
	csl-arm-2003-q4:1.28
	binutils-2_14:1.24.2.1
	binutils-2_14-branch:1.24.0.2
	binutils-2_14-branchpoint:1.24
	binutils-2_13_2_1:1.19
	binutils-2_13_2:1.19
	binutils-2_13_1:1.19
	binutils-2_13:1.19
	binutils-2_13-branchpoint:1.19
	binutils-2_13-branch:1.19.0.2
	binutils-2_12_1:1.17
	binutils-2_12:1.17
	binutils-2_12-branch:1.17.0.2
	binutils-2_12-branchpoint:1.17
	cygnus_cvs_20020108_pre:1.17
	binutils-2_11_2:1.13.2.1
	binutils-2_11_1:1.13.2.1
	binutils-2_11:1.13
	x86_64versiong3:1.13
	binutils-2_11-branch:1.13.0.2
	binutils-2_10_1:1.8
	binutils-2_10:1.8
	binutils-2_10-branch:1.8.0.2
	binutils-2_10-branchpoint:1.8
	binutils_latest_snapshot:1.56
	repo-unification-2000-02-06:1.4
	binu_ss_19990721:1.3
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.56
date	2013.01.10.19.51.54;	author hjl;	state Exp;
branches;
next	1.55;

1.55
date	2012.06.07.12.47.23;	author amodra;	state Exp;
branches;
next	1.54;

1.54
date	2012.05.16.15.25.30;	author nickc;	state Exp;
branches;
next	1.53;

1.53
date	2012.01.26.14.56.49;	author nickc;	state Exp;
branches;
next	1.52;

1.52
date	2010.03.25.21.12.28;	author jsm28;	state Exp;
branches;
next	1.51;

1.51
date	2009.09.11.15.27.33;	author nickc;	state Exp;
branches;
next	1.50;

1.50
date	2009.09.02.07.24.19;	author amodra;	state Exp;
branches
	1.50.2.1;
next	1.49;

1.49
date	2009.06.22.17.56.00;	author nickc;	state Exp;
branches;
next	1.48;

1.48
date	2008.09.29.14.20.39;	author nickc;	state Exp;
branches;
next	1.47;

1.47
date	2008.07.18.22.25.07;	author dj;	state Exp;
branches
	1.47.2.1;
next	1.46;

1.46
date	2008.06.17.16.01.28;	author nickc;	state Exp;
branches;
next	1.45;

1.45
date	2008.06.04.16.10.21;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	2007.07.20.08.20.27;	author nickc;	state Exp;
branches;
next	1.43;

1.43
date	2007.07.03.11.01.02;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	2007.07.03.02.42.16;	author amodra;	state Exp;
branches;
next	1.41;

1.41
date	2007.05.28.19.32.58;	author nathan;	state Exp;
branches;
next	1.40;

1.40
date	2007.05.15.10.06.03;	author shinwell;	state Exp;
branches;
next	1.39;

1.39
date	2007.03.15.14.58.05;	author hjl;	state Exp;
branches;
next	1.38;

1.38
date	2007.03.09.23.25.59;	author aoliva;	state Exp;
branches;
next	1.37;

1.37
date	2007.03.09.07.14.23;	author aoliva;	state Exp;
branches;
next	1.36;

1.36
date	2006.06.07.11.27.57;	author amodra;	state Exp;
branches;
next	1.35;

1.35
date	2006.05.09.04.54.32;	author bje;	state Exp;
branches;
next	1.34;

1.34
date	2006.03.10.10.57.18;	author bje;	state Exp;
branches;
next	1.33;

1.33
date	2005.10.25.17.40.17;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2005.09.29.02.20.50;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2005.09.28.12.31.44;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2005.05.05.09.12.43;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	2005.03.03.01.29.52;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2003.11.24.09.24.39;	author jakub;	state Exp;
branches;
next	1.27;

1.27
date	2003.11.22.04.46.36;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2003.11.21.01.52.16;	author kazu;	state Exp;
branches;
next	1.25;

1.25
date	2003.06.07.14.53.59;	author hjl;	state Exp;
branches;
next	1.24;

1.24
date	2003.04.24.12.36.07;	author nickc;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2003.04.23.17.51.41;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2003.04.22.17.46.51;	author hjl;	state Exp;
branches;
next	1.21;

1.21
date	2003.02.19.10.46.52;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2002.08.27.23.34.18;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2002.05.18.12.53.30;	author kazu;	state Exp;
branches;
next	1.18;

1.18
date	2002.05.02.13.01.50;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2001.10.11.12.20.25;	author kazu;	state Exp;
branches;
next	1.16;

1.16
date	2001.08.01.01.44.25;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2001.07.25.15.23.19;	author brolley;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.08.23.24.21;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2000.10.11.20.24.32;	author kazu;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2000.08.30.03.51.46;	author kazu;	state Exp;
branches;
next	1.11;

1.11
date	2000.07.28.05.05.19;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2000.06.09.00.00.02;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.21.20.22.22;	author wilson;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.02.06.27.50;	author ian;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.24.01.56.31;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.23.13.52.21;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.10.21.00.10;	author twall;	state Exp;
branches;
next	1.4;

1.4
date	99.11.09.17.14.45;	author aph;	state Exp;
branches;
next	1.3;

1.3
date	99.07.11.20.19.53;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.06.03.00.24.11;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.40;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.50.2.1
date	2009.09.11.15.28.43;	author nickc;	state Exp;
branches;
next	;

1.47.2.1
date	2008.09.29.14.21.33;	author nickc;	state Exp;
branches;
next	;

1.24.2.1
date	2003.04.30.08.45.53;	author amodra;	state Exp;
branches;
next	;

1.13.2.1
date	2001.06.07.03.15.24;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.40;	author rth;	state Exp;
branches;
next	;


desc
@@


1.56
log
@Remove trailing white spaces on gas

	* app.c: Remove trailing white spaces.
	* as.c: Likewise.
	* as.h: Likewise.
	* cond.c: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.h: Likewise.
	* ecoff.c: Likewise.
	* input-file.c: Likewise.
	* itbl-lex.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* sb.c: Likewise.
	* subsegs.c: Likewise.
	* symbols.c: Likewise.
	* write.c: Likewise.
	* config/tc-i386.c: Likewise.
	* doc/Makefile.am: Likewise.
	* doc/Makefile.in: Likewise.
	* doc/c-aarch64.texi: Likewise.
	* doc/c-alpha.texi: Likewise.
	* doc/c-arc.texi: Likewise.
	* doc/c-arm.texi: Likewise.
	* doc/c-avr.texi: Likewise.
	* doc/c-bfin.texi: Likewise.
	* doc/c-cr16.texi: Likewise.
	* doc/c-d10v.texi: Likewise.
	* doc/c-d30v.texi: Likewise.
	* doc/c-h8300.texi: Likewise.
	* doc/c-hppa.texi: Likewise.
	* doc/c-i370.texi: Likewise.
	* doc/c-i386.texi: Likewise.
	* doc/c-i860.texi: Likewise.
	* doc/c-m32c.texi: Likewise.
	* doc/c-m32r.texi: Likewise.
	* doc/c-m68hc11.texi: Likewise.
	* doc/c-m68k.texi: Likewise.
	* doc/c-microblaze.texi: Likewise.
	* doc/c-mips.texi: Likewise.
	* doc/c-msp430.texi: Likewise.
	* doc/c-mt.texi: Likewise.
	* doc/c-s390.texi: Likewise.
	* doc/c-score.texi: Likewise.
	* doc/c-sh.texi: Likewise.
	* doc/c-sh64.texi: Likewise.
	* doc/c-tic54x.texi: Likewise.
	* doc/c-tic6x.texi: Likewise.
	* doc/c-v850.texi: Likewise.
	* doc/c-xc16x.texi: Likewise.
	* doc/c-xgate.texi: Likewise.
	* doc/c-xtensa.texi: Likewise.
	* doc/c-z80.texi: Likewise.
	* doc/internals.texi: Likewise.
@
text
@/* This is the Assembler Pre-Processor
   Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000, 2001, 2002, 2003, 2005, 2006, 2007, 2008, 2009, 2010, 2012
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Modified by Allen Wirfs-Brock, Instantiations Inc 2/90.  */
/* App, the assembler pre-processor.  This pre-processor strips out
   excess spaces, turns single-quoted characters into a decimal
   constant, and turns the # in # <number> <filename> <garbage> into a
   .linefile.  This needs better error-handling.  */

#include "as.h"

#if (__STDC__ != 1)
#ifndef const
#define const  /* empty */
#endif
#endif

#ifdef H_TICK_HEX
int enable_h_tick_hex = 0;
#endif

#ifdef TC_M68K
/* Whether we are scrubbing in m68k MRI mode.  This is different from
   flag_m68k_mri, because the two flags will be affected by the .mri
   pseudo-op at different times.  */
static int scrub_m68k_mri;

/* The pseudo-op which switches in and out of MRI mode.  See the
   comment in do_scrub_chars.  */
static const char mri_pseudo[] = ".mri 0";
#else
#define scrub_m68k_mri 0
#endif

#if defined TC_ARM && defined OBJ_ELF
/* The pseudo-op for which we need to special-case `@@' characters.
   See the comment in do_scrub_chars.  */
static const char   symver_pseudo[] = ".symver";
static const char * symver_state;
#endif

static char lex[256];
static const char symbol_chars[] =
"$._ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";

#define LEX_IS_SYMBOL_COMPONENT		1
#define LEX_IS_WHITESPACE		2
#define LEX_IS_LINE_SEPARATOR		3
#define LEX_IS_COMMENT_START		4
#define LEX_IS_LINE_COMMENT_START	5
#define	LEX_IS_TWOCHAR_COMMENT_1ST	6
#define	LEX_IS_STRINGQUOTE		8
#define	LEX_IS_COLON			9
#define	LEX_IS_NEWLINE			10
#define	LEX_IS_ONECHAR_QUOTE		11
#ifdef TC_V850
#define LEX_IS_DOUBLEDASH_1ST		12
#endif
#ifdef TC_M32R
#define DOUBLEBAR_PARALLEL
#endif
#ifdef DOUBLEBAR_PARALLEL
#define LEX_IS_DOUBLEBAR_1ST		13
#endif
#define LEX_IS_PARALLEL_SEPARATOR	14
#ifdef H_TICK_HEX
#define LEX_IS_H			15
#endif
#define IS_SYMBOL_COMPONENT(c)		(lex[c] == LEX_IS_SYMBOL_COMPONENT)
#define IS_WHITESPACE(c)		(lex[c] == LEX_IS_WHITESPACE)
#define IS_LINE_SEPARATOR(c)		(lex[c] == LEX_IS_LINE_SEPARATOR)
#define IS_PARALLEL_SEPARATOR(c)	(lex[c] == LEX_IS_PARALLEL_SEPARATOR)
#define IS_COMMENT(c)			(lex[c] == LEX_IS_COMMENT_START)
#define IS_LINE_COMMENT(c)		(lex[c] == LEX_IS_LINE_COMMENT_START)
#define	IS_NEWLINE(c)			(lex[c] == LEX_IS_NEWLINE)

static int process_escape (int);

/* FIXME-soon: The entire lexer/parser thingy should be
   built statically at compile time rather than dynamically
   each and every time the assembler is run.  xoxorich.  */

void
do_scrub_begin (int m68k_mri ATTRIBUTE_UNUSED)
{
  const char *p;
  int c;

  lex[' '] = LEX_IS_WHITESPACE;
  lex['\t'] = LEX_IS_WHITESPACE;
  lex['\r'] = LEX_IS_WHITESPACE;
  lex['\n'] = LEX_IS_NEWLINE;
  lex[':'] = LEX_IS_COLON;

#ifdef TC_M68K
  scrub_m68k_mri = m68k_mri;

  if (! m68k_mri)
#endif
    {
      lex['"'] = LEX_IS_STRINGQUOTE;

#if ! defined (TC_HPPA) && ! defined (TC_I370)
      /* I370 uses single-quotes to delimit integer, float constants.  */
      lex['\''] = LEX_IS_ONECHAR_QUOTE;
#endif

#ifdef SINGLE_QUOTE_STRINGS
      lex['\''] = LEX_IS_STRINGQUOTE;
#endif
    }

  /* Note: if any other character can be LEX_IS_STRINGQUOTE, the loop
     in state 5 of do_scrub_chars must be changed.  */

  /* Note that these override the previous defaults, e.g. if ';' is a
     comment char, then it isn't a line separator.  */
  for (p = symbol_chars; *p; ++p)
    lex[(unsigned char) *p] = LEX_IS_SYMBOL_COMPONENT;

  for (c = 128; c < 256; ++c)
    lex[c] = LEX_IS_SYMBOL_COMPONENT;

#ifdef tc_symbol_chars
  /* This macro permits the processor to specify all characters which
     may appears in an operand.  This will prevent the scrubber from
     discarding meaningful whitespace in certain cases.  The i386
     backend uses this to support prefixes, which can confuse the
     scrubber as to whether it is parsing operands or opcodes.  */
  for (p = tc_symbol_chars; *p; ++p)
    lex[(unsigned char) *p] = LEX_IS_SYMBOL_COMPONENT;
#endif

  /* The m68k backend wants to be able to change comment_chars.  */
#ifndef tc_comment_chars
#define tc_comment_chars comment_chars
#endif
  for (p = tc_comment_chars; *p; p++)
    lex[(unsigned char) *p] = LEX_IS_COMMENT_START;

  for (p = line_comment_chars; *p; p++)
    lex[(unsigned char) *p] = LEX_IS_LINE_COMMENT_START;

  for (p = line_separator_chars; *p; p++)
    lex[(unsigned char) *p] = LEX_IS_LINE_SEPARATOR;

#ifdef tc_parallel_separator_chars
  /* This macro permits the processor to specify all characters which
     separate parallel insns on the same line.  */
  for (p = tc_parallel_separator_chars; *p; p++)
    lex[(unsigned char) *p] = LEX_IS_PARALLEL_SEPARATOR;
#endif

  /* Only allow slash-star comments if slash is not in use.
     FIXME: This isn't right.  We should always permit them.  */
  if (lex['/'] == 0)
    lex['/'] = LEX_IS_TWOCHAR_COMMENT_1ST;

#ifdef TC_M68K
  if (m68k_mri)
    {
      lex['\''] = LEX_IS_STRINGQUOTE;
      lex[';'] = LEX_IS_COMMENT_START;
      lex['*'] = LEX_IS_LINE_COMMENT_START;
      /* The MRI documentation says '!' is LEX_IS_COMMENT_START, but
	 then it can't be used in an expression.  */
      lex['!'] = LEX_IS_LINE_COMMENT_START;
    }
#endif

#ifdef TC_V850
  lex['-'] = LEX_IS_DOUBLEDASH_1ST;
#endif
#ifdef DOUBLEBAR_PARALLEL
  lex['|'] = LEX_IS_DOUBLEBAR_1ST;
#endif
#ifdef TC_D30V
  /* Must do this is we want VLIW instruction with "->" or "<-".  */
  lex['-'] = LEX_IS_SYMBOL_COMPONENT;
#endif

#ifdef H_TICK_HEX
  if (enable_h_tick_hex)
    {
      lex['h'] = LEX_IS_H;
      lex['H'] = LEX_IS_H;
    }
#endif
}

/* Saved state of the scrubber.  */
static int state;
static int old_state;
static char *out_string;
static char out_buf[20];
static int add_newlines;
static char *saved_input;
static size_t saved_input_len;
static char input_buffer[32 * 1024];
static const char *mri_state;
static char mri_last_ch;

/* Data structure for saving the state of app across #include's.  Note that
   app is called asynchronously to the parsing of the .include's, so our
   state at the time .include is interpreted is completely unrelated.
   That's why we have to save it all.  */

struct app_save
{
  int          state;
  int          old_state;
  char *       out_string;
  char         out_buf[sizeof (out_buf)];
  int          add_newlines;
  char *       saved_input;
  size_t       saved_input_len;
#ifdef TC_M68K
  int          scrub_m68k_mri;
#endif
  const char * mri_state;
  char         mri_last_ch;
#if defined TC_ARM && defined OBJ_ELF
  const char * symver_state;
#endif
};

char *
app_push (void)
{
  register struct app_save *saved;

  saved = (struct app_save *) xmalloc (sizeof (*saved));
  saved->state = state;
  saved->old_state = old_state;
  saved->out_string = out_string;
  memcpy (saved->out_buf, out_buf, sizeof (out_buf));
  saved->add_newlines = add_newlines;
  if (saved_input == NULL)
    saved->saved_input = NULL;
  else
    {
      saved->saved_input = (char *) xmalloc (saved_input_len);
      memcpy (saved->saved_input, saved_input, saved_input_len);
      saved->saved_input_len = saved_input_len;
    }
#ifdef TC_M68K
  saved->scrub_m68k_mri = scrub_m68k_mri;
#endif
  saved->mri_state = mri_state;
  saved->mri_last_ch = mri_last_ch;
#if defined TC_ARM && defined OBJ_ELF
  saved->symver_state = symver_state;
#endif

  /* do_scrub_begin() is not useful, just wastes time.  */

  state = 0;
  saved_input = NULL;
  add_newlines = 0;

  return (char *) saved;
}

void
app_pop (char *arg)
{
  register struct app_save *saved = (struct app_save *) arg;

  /* There is no do_scrub_end ().  */
  state = saved->state;
  old_state = saved->old_state;
  out_string = saved->out_string;
  memcpy (out_buf, saved->out_buf, sizeof (out_buf));
  add_newlines = saved->add_newlines;
  if (saved->saved_input == NULL)
    saved_input = NULL;
  else
    {
      gas_assert (saved->saved_input_len <= sizeof (input_buffer));
      memcpy (input_buffer, saved->saved_input, saved->saved_input_len);
      saved_input = input_buffer;
      saved_input_len = saved->saved_input_len;
      free (saved->saved_input);
    }
#ifdef TC_M68K
  scrub_m68k_mri = saved->scrub_m68k_mri;
#endif
  mri_state = saved->mri_state;
  mri_last_ch = saved->mri_last_ch;
#if defined TC_ARM && defined OBJ_ELF
  symver_state = saved->symver_state;
#endif

  free (arg);
}

/* @@@@ This assumes that \n &c are the same on host and target.  This is not
   necessarily true.  */

static int
process_escape (int ch)
{
  switch (ch)
    {
    case 'b':
      return '\b';
    case 'f':
      return '\f';
    case 'n':
      return '\n';
    case 'r':
      return '\r';
    case 't':
      return '\t';
    case '\'':
      return '\'';
    case '"':
      return '\"';
    default:
      return ch;
    }
}

/* This function is called to process input characters.  The GET
   parameter is used to retrieve more input characters.  GET should
   set its parameter to point to a buffer, and return the length of
   the buffer; it should return 0 at end of file.  The scrubbed output
   characters are put into the buffer starting at TOSTART; the TOSTART
   buffer is TOLEN bytes in length.  The function returns the number
   of scrubbed characters put into TOSTART.  This will be TOLEN unless
   end of file was seen.  This function is arranged as a state
   machine, and saves its state so that it may return at any point.
   This is the way the old code used to work.  */

size_t
do_scrub_chars (size_t (*get) (char *, size_t), char *tostart, size_t tolen)
{
  char *to = tostart;
  char *toend = tostart + tolen;
  char *from;
  char *fromend;
  size_t fromlen;
  register int ch, ch2 = 0;
  /* Character that started the string we're working on.  */
  static char quotechar;

  /*State 0: beginning of normal line
	  1: After first whitespace on line (flush more white)
	  2: After first non-white (opcode) on line (keep 1white)
	  3: after second white on line (into operands) (flush white)
	  4: after putting out a .linefile, put out digits
	  5: parsing a string, then go to old-state
	  6: putting out \ escape in a "d string.
	  7: no longer used
	  8: no longer used
	  9: After seeing symbol char in state 3 (keep 1white after symchar)
	 10: After seeing whitespace in state 9 (keep white before symchar)
	 11: After seeing a symbol character in state 0 (eg a label definition)
	 -1: output string in out_string and go to the state in old_state
	 -2: flush text until a '*' '/' is seen, then go to state old_state
#ifdef TC_V850
	 12: After seeing a dash, looking for a second dash as a start
	     of comment.
#endif
#ifdef DOUBLEBAR_PARALLEL
	 13: After seeing a vertical bar, looking for a second
	     vertical bar as a parallel expression separator.
#endif
#ifdef TC_PREDICATE_START_CHAR
	 14: After seeing a predicate start character at state 0, looking
	     for a predicate end character as predicate.
	 15: After seeing a predicate start character at state 1, looking
	     for a predicate end character as predicate.
#endif
#ifdef TC_Z80
	 16: After seeing an 'a' or an 'A' at the start of a symbol
	 17: After seeing an 'f' or an 'F' in state 16
#endif
	  */

  /* I added states 9 and 10 because the MIPS ECOFF assembler uses
     constructs like ``.loc 1 20''.  This was turning into ``.loc
     120''.  States 9 and 10 ensure that a space is never dropped in
     between characters which could appear in an identifier.  Ian
     Taylor, ian@@cygnus.com.

     I added state 11 so that something like "Lfoo add %r25,%r26,%r27" works
     correctly on the PA (and any other target where colons are optional).
     Jeff Law, law@@cs.utah.edu.

     I added state 13 so that something like "cmp r1, r2 || trap #1" does not
     get squashed into "cmp r1,r2||trap#1", with the all important space
     between the 'trap' and the '#1' being eliminated.  nickc@@cygnus.com  */

  /* This macro gets the next input character.  */

#define GET()							\
  (from < fromend						\
   ? * (unsigned char *) (from++)				\
   : (saved_input = NULL,					\
      fromlen = (*get) (input_buffer, sizeof input_buffer),	\
      from = input_buffer,					\
      fromend = from + fromlen,					\
      (fromlen == 0						\
       ? EOF							\
       : * (unsigned char *) (from++))))

  /* This macro pushes a character back on the input stream.  */

#define UNGET(uch) (*--from = (uch))

  /* This macro puts a character into the output buffer.  If this
     character fills the output buffer, this macro jumps to the label
     TOFULL.  We use this rather ugly approach because we need to
     handle two different termination conditions: EOF on the input
     stream, and a full output buffer.  It would be simpler if we
     always read in the entire input stream before processing it, but
     I don't want to make such a significant change to the assembler's
     memory usage.  */

#define PUT(pch)				\
  do						\
    {						\
      *to++ = (pch);				\
      if (to >= toend)				\
	goto tofull;				\
    }						\
  while (0)

  if (saved_input != NULL)
    {
      from = saved_input;
      fromend = from + saved_input_len;
    }
  else
    {
      fromlen = (*get) (input_buffer, sizeof input_buffer);
      if (fromlen == 0)
	return 0;
      from = input_buffer;
      fromend = from + fromlen;
    }

  while (1)
    {
      /* The cases in this switch end with continue, in order to
	 branch back to the top of this while loop and generate the
	 next output character in the appropriate state.  */
      switch (state)
	{
	case -1:
	  ch = *out_string++;
	  if (*out_string == '\0')
	    {
	      state = old_state;
	      old_state = 3;
	    }
	  PUT (ch);
	  continue;

	case -2:
	  for (;;)
	    {
	      do
		{
		  ch = GET ();

		  if (ch == EOF)
		    {
		      as_warn (_("end of file in comment"));
		      goto fromeof;
		    }

		  if (ch == '\n')
		    PUT ('\n');
		}
	      while (ch != '*');

	      while ((ch = GET ()) == '*')
		;

	      if (ch == EOF)
		{
		  as_warn (_("end of file in comment"));
		  goto fromeof;
		}

	      if (ch == '/')
		break;

	      UNGET (ch);
	    }

	  state = old_state;
	  UNGET (' ');
	  continue;

	case 4:
	  ch = GET ();
	  if (ch == EOF)
	    goto fromeof;
	  else if (ch >= '0' && ch <= '9')
	    PUT (ch);
	  else
	    {
	      while (ch != EOF && IS_WHITESPACE (ch))
		ch = GET ();
	      if (ch == '"')
		{
		  quotechar = ch;
		  state = 5;
		  old_state = 3;
		  PUT (ch);
		}
	      else
		{
		  while (ch != EOF && ch != '\n')
		    ch = GET ();
		  state = 0;
		  PUT (ch);
		}
	    }
	  continue;

	case 5:
	  /* We are going to copy everything up to a quote character,
	     with special handling for a backslash.  We try to
	     optimize the copying in the simple case without using the
	     GET and PUT macros.  */
	  {
	    char *s;
	    ptrdiff_t len;

	    for (s = from; s < fromend; s++)
	      {
		ch = *s;
		if (ch == '\\'
		    || ch == quotechar
		    || ch == '\n')
		  break;
	      }
	    len = s - from;
	    if (len > toend - to)
	      len = toend - to;
	    if (len > 0)
	      {
		memcpy (to, from, len);
		to += len;
		from += len;
		if (to >= toend)
		  goto tofull;
	      }
	  }

	  ch = GET ();
	  if (ch == EOF)
	    {
	      /* This buffer is here specifically so
		 that the UNGET below will work.  */
	      static char one_char_buf[1];

	      as_warn (_("end of file in string; '%c' inserted"), quotechar);
	      state = old_state;
	      from = fromend = one_char_buf + 1;
	      fromlen = 1;
	      UNGET ('\n');
	      PUT (quotechar);
	    }
	  else if (ch == quotechar)
	    {
	      state = old_state;
	      PUT (ch);
	    }
#ifndef NO_STRING_ESCAPES
	  else if (ch == '\\')
	    {
	      state = 6;
	      PUT (ch);
	    }
#endif
	  else if (scrub_m68k_mri && ch == '\n')
	    {
	      /* Just quietly terminate the string.  This permits lines like
		   bne	label	loop if we haven't reach end yet.  */
	      state = old_state;
	      UNGET (ch);
	      PUT ('\'');
	    }
	  else
	    {
	      PUT (ch);
	    }
	  continue;

	case 6:
	  state = 5;
	  ch = GET ();
	  switch (ch)
	    {
	      /* Handle strings broken across lines, by turning '\n' into
		 '\\' and 'n'.  */
	    case '\n':
	      UNGET ('n');
	      add_newlines++;
	      PUT ('\\');
	      continue;

	    case EOF:
	      as_warn (_("end of file in string; '%c' inserted"), quotechar);
	      PUT (quotechar);
	      continue;

	    case '"':
	    case '\\':
	    case 'b':
	    case 'f':
	    case 'n':
	    case 'r':
	    case 't':
	    case 'v':
	    case 'x':
	    case 'X':
	    case '0':
	    case '1':
	    case '2':
	    case '3':
	    case '4':
	    case '5':
	    case '6':
	    case '7':
	      break;

	    default:
#ifdef ONLY_STANDARD_ESCAPES
	      as_warn (_("unknown escape '\\%c' in string; ignored"), ch);
#endif
	      break;
	    }
	  PUT (ch);
	  continue;

#ifdef DOUBLEBAR_PARALLEL
	case 13:
	  ch = GET ();
	  if (ch != '|')
	    abort ();

	  /* Reset back to state 1 and pretend that we are parsing a
	     line from just after the first white space.  */
	  state = 1;
	  PUT ('|');
#ifdef TC_TIC6X
	  /* "||^" is used for SPMASKed instructions.  */
	  ch = GET ();
	  if (ch == EOF)
	    goto fromeof;
	  else if (ch == '^')
	    PUT ('^');
	  else
	    UNGET (ch);
#endif
	  continue;
#endif
#ifdef TC_Z80
	case 16:
	  /* We have seen an 'a' at the start of a symbol, look for an 'f'.  */
	  ch = GET ();
	  if (ch == 'f' || ch == 'F')
	    {
	      state = 17;
	      PUT (ch);
	    }
	  else
	    {
	      state = 9;
	      break;
	    }
	case 17:
	  /* We have seen "af" at the start of a symbol,
	     a ' here is a part of that symbol.  */
	  ch = GET ();
	  state = 9;
	  if (ch == '\'')
	    /* Change to avoid warning about unclosed string.  */
	    PUT ('`');
	  else if (ch != EOF)
	    UNGET (ch);
	  break;
#endif
	}

      /* OK, we are somewhere in states 0 through 4 or 9 through 11.  */

      /* flushchar: */
      ch = GET ();

#ifdef TC_PREDICATE_START_CHAR
      if (ch == TC_PREDICATE_START_CHAR && (state == 0 || state == 1))
	{
	  state += 14;
	  PUT (ch);
	  continue;
	}
      else if (state == 14 || state == 15)
	{
	  if (ch == TC_PREDICATE_END_CHAR)
	    {
	      state -= 14;
	      PUT (ch);
	      ch = GET ();
	    }
	  else
	    {
	      PUT (ch);
	      continue;
	    }
	}
#endif

    recycle:

#if defined TC_ARM && defined OBJ_ELF
      /* We need to watch out for .symver directives.  See the comment later
	 in this function.  */
      if (symver_state == NULL)
	{
	  if ((state == 0 || state == 1) && ch == symver_pseudo[0])
	    symver_state = symver_pseudo + 1;
	}
      else
	{
	  /* We advance to the next state if we find the right
	     character.  */
	  if (ch != '\0' && (*symver_state == ch))
	    ++symver_state;
	  else if (*symver_state != '\0')
	    /* We did not get the expected character, or we didn't
	       get a valid terminating character after seeing the
	       entire pseudo-op, so we must go back to the beginning.  */
	    symver_state = NULL;
	  else
	    {
	      /* We've read the entire pseudo-op.  If this is the end
		 of the line, go back to the beginning.  */
	      if (IS_NEWLINE (ch))
		symver_state = NULL;
	    }
	}
#endif /* TC_ARM && OBJ_ELF */

#ifdef TC_M68K
      /* We want to have pseudo-ops which control whether we are in
	 MRI mode or not.  Unfortunately, since m68k MRI mode affects
	 the scrubber, that means that we need a special purpose
	 recognizer here.  */
      if (mri_state == NULL)
	{
	  if ((state == 0 || state == 1)
	      && ch == mri_pseudo[0])
	    mri_state = mri_pseudo + 1;
	}
      else
	{
	  /* We advance to the next state if we find the right
	     character, or if we need a space character and we get any
	     whitespace character, or if we need a '0' and we get a
	     '1' (this is so that we only need one state to handle
	     ``.mri 0'' and ``.mri 1'').  */
	  if (ch != '\0'
	      && (*mri_state == ch
		  || (*mri_state == ' '
		      && lex[ch] == LEX_IS_WHITESPACE)
		  || (*mri_state == '0'
		      && ch == '1')))
	    {
	      mri_last_ch = ch;
	      ++mri_state;
	    }
	  else if (*mri_state != '\0'
		   || (lex[ch] != LEX_IS_WHITESPACE
		       && lex[ch] != LEX_IS_NEWLINE))
	    {
	      /* We did not get the expected character, or we didn't
		 get a valid terminating character after seeing the
		 entire pseudo-op, so we must go back to the
		 beginning.  */
	      mri_state = NULL;
	    }
	  else
	    {
	      /* We've read the entire pseudo-op.  mips_last_ch is
		 either '0' or '1' indicating whether to enter or
		 leave MRI mode.  */
	      do_scrub_begin (mri_last_ch == '1');
	      mri_state = NULL;

	      /* We continue handling the character as usual.  The
		 main gas reader must also handle the .mri pseudo-op
		 to control expression parsing and the like.  */
	    }
	}
#endif

      if (ch == EOF)
	{
	  if (state != 0)
	    {
	      as_warn (_("end of file not at end of a line; newline inserted"));
	      state = 0;
	      PUT ('\n');
	    }
	  goto fromeof;
	}

      switch (lex[ch])
	{
	case LEX_IS_WHITESPACE:
	  do
	    {
	      ch = GET ();
	    }
	  while (ch != EOF && IS_WHITESPACE (ch));
	  if (ch == EOF)
	    goto fromeof;

	  if (state == 0)
	    {
	      /* Preserve a single whitespace character at the
		 beginning of a line.  */
	      state = 1;
	      UNGET (ch);
	      PUT (' ');
	      break;
	    }

#ifdef KEEP_WHITE_AROUND_COLON
	  if (lex[ch] == LEX_IS_COLON)
	    {
	      /* Only keep this white if there's no white *after* the
		 colon.  */
	      ch2 = GET ();
	      if (ch2 != EOF)
		UNGET (ch2);
	      if (!IS_WHITESPACE (ch2))
		{
		  state = 9;
		  UNGET (ch);
		  PUT (' ');
		  break;
		}
	    }
#endif
	  if (IS_COMMENT (ch)
	      || ch == '/'
	      || IS_LINE_SEPARATOR (ch)
	      || IS_PARALLEL_SEPARATOR (ch))
	    {
	      if (scrub_m68k_mri)
		{
		  /* In MRI mode, we keep these spaces.  */
		  UNGET (ch);
		  PUT (' ');
		  break;
		}
	      goto recycle;
	    }

	  /* If we're in state 2 or 11, we've seen a non-white
	     character followed by whitespace.  If the next character
	     is ':', this is whitespace after a label name which we
	     normally must ignore.  In MRI mode, though, spaces are
	     not permitted between the label and the colon.  */
	  if ((state == 2 || state == 11)
	      && lex[ch] == LEX_IS_COLON
	      && ! scrub_m68k_mri)
	    {
	      state = 1;
	      PUT (ch);
	      break;
	    }

	  switch (state)
	    {
	    case 1:
	      /* We can arrive here if we leave a leading whitespace
		 character at the beginning of a line.  */
	      goto recycle;
	    case 2:
	      state = 3;
	      if (to + 1 < toend)
		{
		  /* Optimize common case by skipping UNGET/GET.  */
		  PUT (' ');	/* Sp after opco */
		  goto recycle;
		}
	      UNGET (ch);
	      PUT (' ');
	      break;
	    case 3:
#ifndef TC_KEEP_OPERAND_SPACES
	      /* For TI C6X, we keep these spaces as they may separate
		 functional unit specifiers from operands.  */
	      if (scrub_m68k_mri)
#endif
		{
		  /* In MRI mode, we keep these spaces.  */
		  UNGET (ch);
		  PUT (' ');
		  break;
		}
	      goto recycle;	/* Sp in operands */
	    case 9:
	    case 10:
#ifndef TC_KEEP_OPERAND_SPACES
	      if (scrub_m68k_mri)
#endif
		{
		  /* In MRI mode, we keep these spaces.  */
		  state = 3;
		  UNGET (ch);
		  PUT (' ');
		  break;
		}
	      state = 10;	/* Sp after symbol char */
	      goto recycle;
	    case 11:
	      if (LABELS_WITHOUT_COLONS || flag_m68k_mri)
		state = 1;
	      else
		{
		  /* We know that ch is not ':', since we tested that
		     case above.  Therefore this is not a label, so it
		     must be the opcode, and we've just seen the
		     whitespace after it.  */
		  state = 3;
		}
	      UNGET (ch);
	      PUT (' ');	/* Sp after label definition.  */
	      break;
	    default:
	      BAD_CASE (state);
	    }
	  break;

	case LEX_IS_TWOCHAR_COMMENT_1ST:
	  ch2 = GET ();
	  if (ch2 == '*')
	    {
	      for (;;)
		{
		  do
		    {
		      ch2 = GET ();
		      if (ch2 != EOF && IS_NEWLINE (ch2))
			add_newlines++;
		    }
		  while (ch2 != EOF && ch2 != '*');

		  while (ch2 == '*')
		    ch2 = GET ();

		  if (ch2 == EOF || ch2 == '/')
		    break;

		  /* This UNGET will ensure that we count newlines
		     correctly.  */
		  UNGET (ch2);
		}

	      if (ch2 == EOF)
		as_warn (_("end of file in multiline comment"));

	      ch = ' ';
	      goto recycle;
	    }
#ifdef DOUBLESLASH_LINE_COMMENTS
	  else if (ch2 == '/')
	    {
	      do
		{
		  ch = GET ();
		}
	      while (ch != EOF && !IS_NEWLINE (ch));
	      if (ch == EOF)
		as_warn ("end of file in comment; newline inserted");
	      state = 0;
	      PUT ('\n');
	      break;
	    }
#endif
	  else
	    {
	      if (ch2 != EOF)
		UNGET (ch2);
	      if (state == 9 || state == 10)
		state = 3;
	      PUT (ch);
	    }
	  break;

	case LEX_IS_STRINGQUOTE:
	  quotechar = ch;
	  if (state == 10)
	    {
	      /* Preserve the whitespace in foo "bar".  */
	      UNGET (ch);
	      state = 3;
	      PUT (' ');

	      /* PUT didn't jump out.  We could just break, but we
		 know what will happen, so optimize a bit.  */
	      ch = GET ();
	      old_state = 3;
	    }
	  else if (state == 9)
	    old_state = 3;
	  else
	    old_state = state;
	  state = 5;
	  PUT (ch);
	  break;

#ifndef IEEE_STYLE
	case LEX_IS_ONECHAR_QUOTE:
#ifdef H_TICK_HEX
	  if (state == 9 && enable_h_tick_hex)
	    {
	      char c;

	      c = GET ();
	      as_warn ("'%c found after symbol", c);
	      UNGET (c);
	    }
#endif
	  if (state == 10)
	    {
	      /* Preserve the whitespace in foo 'b'.  */
	      UNGET (ch);
	      state = 3;
	      PUT (' ');
	      break;
	    }
	  ch = GET ();
	  if (ch == EOF)
	    {
	      as_warn (_("end of file after a one-character quote; \\0 inserted"));
	      ch = 0;
	    }
	  if (ch == '\\')
	    {
	      ch = GET ();
	      if (ch == EOF)
		{
		  as_warn (_("end of file in escape character"));
		  ch = '\\';
		}
	      else
		ch = process_escape (ch);
	    }
	  sprintf (out_buf, "%d", (int) (unsigned char) ch);

	  /* None of these 'x constants for us.  We want 'x'.  */
	  if ((ch = GET ()) != '\'')
	    {
#ifdef REQUIRE_CHAR_CLOSE_QUOTE
	      as_warn (_("missing close quote; (assumed)"));
#else
	      if (ch != EOF)
		UNGET (ch);
#endif
	    }
	  if (strlen (out_buf) == 1)
	    {
	      PUT (out_buf[0]);
	      break;
	    }
	  if (state == 9)
	    old_state = 3;
	  else
	    old_state = state;
	  state = -1;
	  out_string = out_buf;
	  PUT (*out_string++);
	  break;
#endif

	case LEX_IS_COLON:
#ifdef KEEP_WHITE_AROUND_COLON
	  state = 9;
#else
	  if (state == 9 || state == 10)
	    state = 3;
	  else if (state != 3)
	    state = 1;
#endif
	  PUT (ch);
	  break;

	case LEX_IS_NEWLINE:
	  /* Roll out a bunch of newlines from inside comments, etc.  */
	  if (add_newlines)
	    {
	      --add_newlines;
	      UNGET (ch);
	    }
	  /* Fall through.  */

	case LEX_IS_LINE_SEPARATOR:
	  state = 0;
	  PUT (ch);
	  break;

	case LEX_IS_PARALLEL_SEPARATOR:
	  state = 1;
	  PUT (ch);
	  break;

#ifdef TC_V850
	case LEX_IS_DOUBLEDASH_1ST:
	  ch2 = GET ();
	  if (ch2 != '-')
	    {
	      if (ch2 != EOF)
		UNGET (ch2);
	      goto de_fault;
	    }
	  /* Read and skip to end of line.  */
	  do
	    {
	      ch = GET ();
	    }
	  while (ch != EOF && ch != '\n');

	  if (ch == EOF)
	    as_warn (_("end of file in comment; newline inserted"));

	  state = 0;
	  PUT ('\n');
	  break;
#endif
#ifdef DOUBLEBAR_PARALLEL
	case LEX_IS_DOUBLEBAR_1ST:
	  ch2 = GET ();
	  if (ch2 != EOF)
	    UNGET (ch2);
	  if (ch2 != '|')
	    goto de_fault;

	  /* Handle '||' in two states as invoking PUT twice might
	     result in the first one jumping out of this loop.  We'd
	     then lose track of the state and one '|' char.  */
	  state = 13;
	  PUT ('|');
	  break;
#endif
	case LEX_IS_LINE_COMMENT_START:
	  /* FIXME-someday: The two character comment stuff was badly
	     thought out.  On i386, we want '/' as line comment start
	     AND we want C style comments.  hence this hack.  The
	     whole lexical process should be reworked.  xoxorich.  */
	  if (ch == '/')
	    {
	      ch2 = GET ();
	      if (ch2 == '*')
		{
		  old_state = 3;
		  state = -2;
		  break;
		}
	      else
		{
		  UNGET (ch2);
		}
	    }

	  if (state == 0 || state == 1)	/* Only comment at start of line.  */
	    {
	      int startch;

	      startch = ch;

	      do
		{
		  ch = GET ();
		}
	      while (ch != EOF && IS_WHITESPACE (ch));

	      if (ch == EOF)
		{
		  as_warn (_("end of file in comment; newline inserted"));
		  PUT ('\n');
		  break;
		}

	      if (ch < '0' || ch > '9' || state != 0 || startch != '#')
		{
		  /* Not a cpp line.  */
		  while (ch != EOF && !IS_NEWLINE (ch))
		    ch = GET ();
		  if (ch == EOF)
		    as_warn (_("end of file in comment; newline inserted"));
		  state = 0;
		  PUT ('\n');
		  break;
		}
	      /* Looks like `# 123 "filename"' from cpp.  */
	      UNGET (ch);
	      old_state = 4;
	      state = -1;
	      if (scrub_m68k_mri)
		out_string = "\tlinefile ";
	      else
		out_string = "\t.linefile ";
	      PUT (*out_string++);
	      break;
	    }

#ifdef TC_D10V
	  /* All insns end in a char for which LEX_IS_SYMBOL_COMPONENT is true.
	     Trap is the only short insn that has a first operand that is
	     neither register nor label.
	     We must prevent exef0f ||trap #1 to degenerate to exef0f ||trap#1 .
	     We can't make '#' LEX_IS_SYMBOL_COMPONENT because it is
	     already LEX_IS_LINE_COMMENT_START.  However, it is the
	     only character in line_comment_chars for d10v, hence we
	     can recognize it as such.  */
	  /* An alternative approach would be to reset the state to 1 when
	     we see '||', '<'- or '->', but that seems to be overkill.  */
	  if (state == 10)
	    PUT (' ');
#endif
	  /* We have a line comment character which is not at the
	     start of a line.  If this is also a normal comment
	     character, fall through.  Otherwise treat it as a default
	     character.  */
	  if (strchr (tc_comment_chars, ch) == NULL
	      && (! scrub_m68k_mri
		  || (ch != '!' && ch != '*')))
	    goto de_fault;
	  if (scrub_m68k_mri
	      && (ch == '!' || ch == '*' || ch == '#')
	      && state != 1
	      && state != 10)
	    goto de_fault;
	  /* Fall through.  */
	case LEX_IS_COMMENT_START:
#if defined TC_ARM && defined OBJ_ELF
	  /* On the ARM, `@@' is the comment character.
	     Unfortunately this is also a special character in ELF .symver
	     directives (and .type, though we deal with those another way).
	     So we check if this line is such a directive, and treat
	     the character as default if so.  This is a hack.  */
	  if ((symver_state != NULL) && (*symver_state == 0))
	    goto de_fault;
#endif

#ifdef TC_ARM
	  /* For the ARM, care is needed not to damage occurrences of \@@
	     by stripping the @@ onwards.  Yuck.  */
	  if (to > tostart && *(to - 1) == '\\')
	    /* Do not treat the @@ as a start-of-comment.  */
	    goto de_fault;
#endif

#ifdef WARN_COMMENTS
	  if (!found_comment)
	    as_where (&found_comment_file, &found_comment);
#endif
	  do
	    {
	      ch = GET ();
	    }
	  while (ch != EOF && !IS_NEWLINE (ch));
	  if (ch == EOF)
	    as_warn (_("end of file in comment; newline inserted"));
	  state = 0;
	  PUT ('\n');
	  break;

#ifdef H_TICK_HEX
	case LEX_IS_H:
	  /* Look for strings like H'[0-9A-Fa-f] and if found, replace
	     the H' with 0x to make them gas-style hex characters.  */
	  if (enable_h_tick_hex)
	    {
	      char quot;

	      quot = GET ();
	      if (quot == '\'')
		{
		  UNGET ('x');
		  ch = '0';
		}
	      else
		UNGET (quot);
	    }
	  /* FALL THROUGH */
#endif

	case LEX_IS_SYMBOL_COMPONENT:
	  if (state == 10)
	    {
	      /* This is a symbol character following another symbol
		 character, with whitespace in between.  We skipped
		 the whitespace earlier, so output it now.  */
	      UNGET (ch);
	      state = 3;
	      PUT (' ');
	      break;
	    }

#ifdef TC_Z80
	  /* "af'" is a symbol containing '\''.  */
	  if (state == 3 && (ch == 'a' || ch == 'A'))
	    {
	      state = 16;
	      PUT (ch);
	      ch = GET ();
	      if (ch == 'f' || ch == 'F')
		{
		  state = 17;
		  PUT (ch);
		  break;
		}
	      else
		{
		  state = 9;
		  if (ch == EOF || !IS_SYMBOL_COMPONENT (ch))
		    {
		      if (ch != EOF)
			UNGET (ch);
		      break;
		    }
		}
	    }
#endif
	  if (state == 3)
	    state = 9;

	  /* This is a common case.  Quickly copy CH and all the
	     following symbol component or normal characters.  */
	  if (to + 1 < toend
	      && mri_state == NULL
#if defined TC_ARM && defined OBJ_ELF
	      && symver_state == NULL
#endif
	      )
	    {
	      char *s;
	      ptrdiff_t len;

	      for (s = from; s < fromend; s++)
		{
		  int type;

		  ch2 = *(unsigned char *) s;
		  type = lex[ch2];
		  if (type != 0
		      && type != LEX_IS_SYMBOL_COMPONENT)
		    break;
		}

	      if (s > from)
		/* Handle the last character normally, for
		   simplicity.  */
		--s;

	      len = s - from;

	      if (len > (toend - to) - 1)
		len = (toend - to) - 1;

	      if (len > 0)
		{
		  PUT (ch);
		  memcpy (to, from, len);
		  to += len;
		  from += len;
		  if (to >= toend)
		    goto tofull;
		  ch = GET ();
		}
	    }

	  /* Fall through.  */
	default:
	de_fault:
	  /* Some relatively `normal' character.  */
	  if (state == 0)
	    {
	      state = 11;	/* Now seeing label definition.  */
	    }
	  else if (state == 1)
	    {
	      state = 2;	/* Ditto.  */
	    }
	  else if (state == 9)
	    {
	      if (!IS_SYMBOL_COMPONENT (ch))
		state = 3;
	    }
	  else if (state == 10)
	    {
	      if (ch == '\\')
		{
		  /* Special handling for backslash: a backslash may
		     be the beginning of a formal parameter (of a
		     macro) following another symbol character, with
		     whitespace in between.  If that is the case, we
		     output a space before the parameter.  Strictly
		     speaking, correct handling depends upon what the
		     macro parameter expands into; if the parameter
		     expands into something which does not start with
		     an operand character, then we don't want to keep
		     the space.  We don't have enough information to
		     make the right choice, so here we are making the
		     choice which is more likely to be correct.  */
		  if (to + 1 >= toend)
		    {
		      /* If we're near the end of the buffer, save the
		         character for the next time round.  Otherwise
		         we'll lose our state.  */
		      UNGET (ch);
		      goto tofull;
		    }
		  *to++ = ' ';
		}

	      state = 3;
	    }
	  PUT (ch);
	  break;
	}
    }

  /*NOTREACHED*/

 fromeof:
  /* We have reached the end of the input.  */
  return to - tostart;

 tofull:
  /* The output buffer is full.  Save any input we have not yet
     processed.  */
  if (fromend > from)
    {
      saved_input = from;
      saved_input_len = fromend - from;
    }
  else
    saved_input = NULL;

  return to - tostart;
}
@


1.55
log
@	PR gas/14201
	* sb.h (sb_max_power_two): Delete.
	(struct sb): Delete "item" and "pot".  Make "len" a size_t.  Add "max".
	(sb_element): Delete.
	(sb_add_char, sb_add_buffer, sb_skip_comma, sb_skip_write): Update
	prototypes.
	* sb.c (string_count, free_list): Delete.
	(sb_build, sb_kill, sb_check): Rewrite.
	(scrub_from_sb, sb_add_char, sb_add_string, sb_add_buffer,
	sb_skip_white, sb_skip_comma): Replace assorted int params,
	vars and return types with size_t.
	* input-scrub.c: Likewise.
	* macro.c: Likewise.
	* macro.h: Likewise.
	* as.c: Likewise.
	* as.h: Likewise.
	* input-file.h: Likewise.
	* input-file.c: Likewise.
	* read.c: Likewise.
	* app.c: ..or ptrdiff_t.
	* input-file.c (input_file_get): Use ferror.
	(input_file_give_next_buffer): Use input_file_get.
@
text
@d687 1
a687 1
	  if (ch == 'f' || ch == 'F') 
d1333 1
a1333 1
	  if (state == 3 && (ch == 'a' || ch == 'A')) 
d1338 1
a1338 1
	      if (ch == 'f' || ch == 'F') 
@


1.54
log
@	PR gas/14082
	* app.c (do_scrub_chars): Prevent possible out of bounds access to
	lex[] array.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003, 2005, 2006, 2007, 2008, 2009, 2010
d217 1
a217 1
static int saved_input_len;
d235 1
a235 1
  int          saved_input_len;
d298 1
a298 1
      gas_assert (saved->saved_input_len <= (int) (sizeof input_buffer));
d354 2
a355 2
int
do_scrub_chars (int (*get) (char *, int), char *tostart, int tolen)
d361 1
a361 1
  int fromlen;
d551 1
a551 1
	    int len;
d1369 1
a1369 1
	      int len;
@


1.53
log
@	PR gas/13624
	* app.c (app_push): Set 'add_newlines' to zero after saving.
@
text
@d1347 1
a1347 1
		  if (!IS_SYMBOL_COMPONENT (ch)) 
@


1.52
log
@bfd:
	* Makefile.am (ALL_MACHINES): Add cpu-tic6x.lo.
	(ALL_MACHINES_CFILES): Add cpu-tic6x.c.
	(BFD32_BACKENDS): Add elf32-tic6x.lo.
	(BFD32_BACKENDS_CFILES): Add elf32-tic6x.c.
	* Makefile.in: Regenerate.
	* archures.c (bfd_arch_tic6x, bfd_tic6x_arch): New.
	(bfd_archures_list): Update.
	* config.bfd (tic6x-*-elf): New.
	* configure.in (bfd_elf32_tic6x_be_vec, bfd_elf32_tic6x_le_vec):
	New.
	* configure: Regenerate.
	* cpu-tic6x.c, elf32-tic6x.c: New.
	* reloc.c (BFD_RELOC_C6000_PCR_S21, BFD_RELOC_C6000_PCR_S12,
	BFD_RELOC_C6000_PCR_S10, BFD_RELOC_C6000_PCR_S7,
	BFD_RELOC_C6000_ABS_S16, BFD_RELOC_C6000_ABS_L16,
	BFD_RELOC_C6000_ABS_H16, BFD_RELOC_C6000_SBR_U15_B,
	BFD_RELOC_C6000_SBR_U15_H, BFD_RELOC_C6000_SBR_U15_W,
	BFD_RELOC_C6000_SBR_S16, BFD_RELOC_C6000_SBR_L16_B,
	BFD_RELOC_C6000_SBR_L16_H, BFD_RELOC_C6000_SBR_L16_W,
	BFD_RELOC_C6000_SBR_H16_B, BFD_RELOC_C6000_SBR_H16_H,
	BFD_RELOC_C6000_SBR_H16_W, BFD_RELOC_C6000_SBR_GOT_U15_W,
	BFD_RELOC_C6000_SBR_GOT_L16_W, BFD_RELOC_C6000_SBR_GOT_H16_W,
	BFD_RELOC_C6000_DSBT_INDEX, BFD_RELOC_C6000_PREL31,
	BFD_RELOC_C6000_COPY, BFD_RELOC_C6000_ALIGN,
	BFD_RELOC_C6000_FPHEAD, BFD_RELOC_C6000_NOCMP): New.
	* targets.c (bfd_elf32_tic6x_be_vec, bfd_elf32_tic6x_le_vec): New.
	(_bfd_target_vector): Update.
	* bfd-in2.h, libbfd.h: Regenerate.

binutils:
	* MAINTAINERS: Add self as TI C6X maintainer.
	* NEWS: Add news entry for TI C6X support.
	* readelf.c: Include elf/tic6x.h.
	(guess_is_rela): Handle EM_TI_C6000.
	(dump_relocations): Likewise.
	(get_tic6x_dynamic_type): New.
	(get_dynamic_type): Call it.
	(get_machine_flags): Handle EF_C6000_REL.
	(get_osabi_name): Handle machine-specific values only for relevant
	machines.  Handle C6X values.
	(get_tic6x_segment_type): New.
	(get_segment_type): Call it.
	(get_tic6x_section_type_name): New.
	(get_section_type_name): Call it.
	(is_32bit_abs_reloc, is_16bit_abs_reloc, is_none_reloc): Handle
	EM_TI_C6000.

gas:
	* Makefile.am (TARGET_CPU_CFILES): Add config/tc-tic6x.c.
	(TARGET_CPU_HFILES): Add config/tc-tic6x.h.
	* Makefile.in: Regenerate.
	* NEWS: Add news entry for TI C6X support.
	* app.c (do_scrub_chars): Handle "||^" for TI C6X.  Handle
	TC_PREDICATE_START_CHAR and TC_PREDICATE_END_CHAR.  Keep spaces in
	operands if TC_KEEP_OPERAND_SPACES.
	* configure.tgt (tic6x-*-*): New.
	* config/tc-ia64.h (TC_PREDICATE_START_CHAR,
	TC_PREDICATE_END_CHAR): Define.
	* config/tc-tic6x.c, config/tc-tic6x.h: New.
	* doc/Makefile.am (CPU_DOCS): Add c-tic6x.texi.
	* doc/Makefile.in: Regenerate.
	* doc/all.texi (TIC6X): Define.
	* doc/as.texinfo: Add TI C6X documentation.  Include c-tic6x.texi.
	* doc/c-tic6x.texi: New.

gas/testsuite:
	* gas/tic6x: New directory and testcases.

include:
	* dis-asm.h (print_insn_tic6x): Declare.

include/elf:
	* common.h (ELFOSABI_C6000_ELFABI, ELFOSABI_C6000_LINUX): Define.
	* tic6x.h: New.

include/opcode:
	* tic6x-control-registers.h, tic6x-insn-formats.h,
	tic6x-opcode-table.h, tic6x.h: New.

ld:
	* Makefile.am (ALL_EMULATIONS): Add eelf32_tic6x_be.o and
	eelf32_tic6x_le.o.
	(eelf32_tic6x_be.c, eelf32_tic6x_le.c): New.
	* NEWS: Add news entry for TI C6X support.
	* configure.tgt (tic6x-*-*): New.
	* emulparams/elf32_tic6x_be.sh, emulparams/elf32_tic6x_le.sh: New.

ld/testsuite:
	* ld-elf/flags1.d, ld-elf/merge.d: XFAIL for tic6x-*-*.
	* ld-elf/sec-to-seg.exp: Set B_test_same_seg to 0 for tic6x-*-*.
	* ld-tic6x: New directory and testcases.

opcodes:
	* Makefile.am (TARGET_LIBOPCODES_CFILES): Add tic6x-dis.c.
	* Makefile.in: Regenerate.
	* configure.in (bfd_tic6x_arch): New.
	* configure: Regenerate.
	* disassemble.c (ARCH_tic6x): Define if ARCH_all.
	(disassembler): Handle TI C6X.
	* tic6x-dis.c: New.
@
text
@d278 1
@


1.51
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        * as.c (main): Call dwarf2_init.
        * config/obj-elf.c (struct group_list): New field.
        (build_group_lists): Use hash lookup.
        (free_section_idx): New function.
        (elf_frob_file): Adjust.
        * dwarf2dbg.c (all_segs_hash, last_seg_ptr): New variables.
        (get_line_subseg): Adjust.
        (dwarf2_init): New function.
        * dwarf2dbg.h (dwarf2_init): New declaration.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003, 2005, 2006, 2007, 2008
d387 5
a391 5
#ifdef TC_IA64
	 14: After seeing a `(' at state 0, looking for a `)' as
	     predicate.
	 15: After seeing a `(' at state 1, looking for a `)' as
	     predicate.
d670 10
d715 2
a716 2
#ifdef TC_IA64
      if (ch == '(' && (state == 0 || state == 1))
d724 1
a724 1
	  if (ch == ')')
d918 3
d922 1
d932 1
d934 1
@


1.50
log
@update copyright dates
@
text
@d261 1
a261 1
      saved->saved_input = xmalloc (saved_input_len);
@


1.50.2.1
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.
@
text
@d261 1
a261 1
      saved->saved_input = (char *) xmalloc (saved_input_len);
@


1.49
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003, 2006, 2007
@


1.48
log
@  PR 6878
   * app.c (do_scrub_chars): Only issue warnings about tick
   characters detected in symbol strings if hex ticks are supported.
@
text
@d297 1
a297 1
      assert (saved->saved_input_len <= (int) (sizeof input_buffer));
@


1.47
log
@* config/tc-m32c.h (H_TICK_HEX): Define.
* config/tc-m32c.c (OPTION_H_TICK_HEX): Define.
(md_longopts): Add support for it.
(md_parse_option): Likewise.
* doc/as.texinfo (Overview): Add new m32c options.
* doc/c-m32c.texi (M32C-Modifiers): Likewise

* as.h: (enable_h_tick_hex): New.
* app.c (enable_h_tick_hex): New.
(LEX_IS_H): New.
(do_scrub_begin): Mark 'H' and 'h' as special if enable_h_tick_hex.
(do_scrub_chars): If enable_h_tick_hex and 'h', check for H'00
style hex constants and convert the input stream to 0x00 style.
(do_scrub_chars): If a 'X style character constant is found after
a symbol character (like you're or X'00), warn the user.
@
text
@d1027 2
a1028 1
	  if (state == 9)
d1036 1
@


1.47.2.1
log
@PR 6878
   * app.c (do_scrub_chars): Only issue warnings about tick
   characters detected in symbol strings if hex ticks are supported.
@
text
@d1027 1
a1027 2
#ifdef H_TICK_HEX
	  if (state == 9 && enable_h_tick_hex)
a1034 1
#endif
@


1.46
log
@        * app.c (do_scrub_chars): Do not UNGET an EOF value.

        * ti.h (GET_SCNHDR_NLNNO): Provide an alternative version of this
        macro which does not trigger an array bounds warning in gcc.
        (PUT_SCNHDR_NLNNO): Likewise.
        (GET_SCNHDR_FLAGS): Likewise.
        (PUT_SCNHDR_FLAGS): Likewise.
        (GET_SCNHDR_PAGE): Likewise.
        (PUT_SCNHDR_PAGE): Likewise.
@
text
@d37 4
d85 3
d200 8
d1027 8
d1280 20
@


1.45
log
@            * app.c (do_scrub_chars): Do not UNGET an EOF value.
@
text
@d679 1
a679 1
	  else
d1100 2
a1101 1
	      UNGET (ch2);
d1287 2
a1288 1
		      UNGET (ch);
a1411 1

@


1.44
log
@    * app.c (do_scrub_chars): Provide a one character buffer to hold a
      pushed back newline at the end of an unterminated quoted string.
@
text
@d835 2
a836 1
	      UNGET (ch2);
d1120 2
a1121 1
	  UNGET (ch2);
@


1.43
log
@Switch to GPLv3
@
text
@d561 4
d567 2
@


1.42
log
@	PR 4722
	* app.c (do_scrub_chars <state 5>): Check for output buffer full
	after memcpy.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2, or (at your option)
d13 4
a16 4
   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
@


1.41
log
@	* app.c (do_scrub_chars): Cope with \ at end of buffer.x
@
text
@d553 2
@


1.40
log
@	gas/
	* app.c (do_scrub_chars): Don't damage \@@ pseudo-variables.

	gas/testsuite/
	* gas/arm/backslash-at.d: New.
	* gas/arm/backslash-at.s: New.
@
text
@d1363 9
a1371 1
		  PUT (' ');
@


1.39
log
@2007-03-15  Alexandre Oliva  <aoliva@@redhat.com>

	PR gas/4184
	* app.c (do_scrub_chars): PUT after setting states.
@
text
@d1222 9
@


1.38
log
@* app.c (do_scrub_chars): Recognize comments after # line "file".
* read.c (get_linefile_number): New.
(s_app_line): Accept ill-formed .linefile lines as comments.
@
text
@a512 2
		  PUT (' ');
		  PUT (ch);
d516 1
@


1.37
log
@* app.c (do_scrub_chars): Turn #<line>"file"flags into .linefile.
* as.h (new_logical_line_flags): New.
* input-scrub.c (new_logical_line): Turned into wrapper for...
(new_logical_line_flags): this.  Handle flags.
* read.c (potable): Add linefile.  Adjust appline argument.
(s_app_file): Fake .appfiles no more.
(s_app_line): For .linefile, accept file name and flags.
@
text
@d358 1
a358 1
	  8: After putting out a .appfile string, flush until newline.
d517 1
a517 1
		  old_state = 8;
a637 10
	case 8:
	  do
	    if ((ch = GET ()) == EOF)
	      goto fromeof;
	    else
	      PUT (ch);
	  while (ch != '\n');
	  state = 0;
	  continue;

@


1.36
log
@remove some duplicate #include's.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003, 2006
d24 4
a27 4
/* App, the assembler pre-processor.  This pre-processor strips out excess
   spaces, turns single-quoted characters into a decimal constant, and turns
   # <number> <filename> <garbage> into a .line <number>\n.file <filename>
   pair.  This needs better error-handling.  */
d354 1
a354 1
	  4: after putting out a .line, put out digits
d357 1
a357 1
	  7: After putting out a .appfile, put out string.
d513 5
a517 8
		  UNGET (ch);
		  if (scrub_m68k_mri)
		    out_string = "\n\tappfile ";
		  else
		    out_string = "\n\t.appfile ";
		  old_state = 7;
		  state = -1;
		  PUT (*out_string++);
a637 8
	case 7:
	  ch = GET ();
	  quotechar = ch;
	  state = 5;
	  old_state = 8;
	  PUT (ch);
	  continue;

d640 5
a644 4
	    ch = GET ();
	  while (ch != '\n' && ch != EOF);
	  if (ch == EOF)
	    goto fromeof;
a645 1
	  PUT (ch);
d1188 1
a1188 1
		out_string = "\tappline ";
d1190 1
a1190 1
		out_string = "\t.appline ";
@


1.35
log
@        * expr.c (operand): Remove `if (0 && ..)' statement and
        subsequently unused target_op label.  Collapse `if (1 || ..)'
        statement.
        * app.c (do_scrub_chars): Remove unused case 0, as it is handled
        separately above the switch.
@
text
@d3 1
a3 1
   1999, 2000, 2001, 2002, 2003
d29 1
a29 2
#include <stdio.h>
#include "as.h"			/* For BAD_CASE() only.  */
@


1.34
log
@	* app.c (do_scrub_chars): Simplify string handling.
@
text
@a890 3
	    case 0:
	      state++;
	      goto recycle;	/* Punted leading sp */
@


1.33
log
@Add support for the Z80 processor family
@
text
@d1338 3
a1340 20
		  if (len > 8)
		    {
		      memcpy (to, from, len);
		      to += len;
		      from += len;
		    }
		  else
		    {
		      switch (len)
			{
			case 8: *to++ = *from++;
			case 7: *to++ = *from++;
			case 6: *to++ = *from++;
			case 5: *to++ = *from++;
			case 4: *to++ = *from++;
			case 3: *to++ = *from++;
			case 2: *to++ = *from++;
			case 1: *to++ = *from++;
			}
		    }
@


1.32
log
@	* app.c (do_scrub_chars): Match open and close quote of strings.
	Remove redundant EOF test in case 7.
@
text
@d379 4
d672 26
d1275 24
@


1.31
log
@	* app.c (do_scrub_chars <LEX_IS_SYMBOL_COMPONENT>): Check for full
	buffer after copying string.
@
text
@d348 2
a540 2
		/* This condition must be changed if the type of any
		   other character can be LEX_IS_STRINGQUOTE.  */
d542 1
a542 2
		    || ch == '"'
		    || ch == '\''
d560 1
a560 1
	      as_warn (_("end of file in string; inserted '\"'"));
d563 1
a563 1
	      PUT ('"');
d565 1
a565 1
	  else if (lex[ch] == LEX_IS_STRINGQUOTE)
d605 2
a606 2
	      as_warn (_("end of file in string; '\"' inserted"));
	      PUT ('"');
d640 1
a642 2
	  if (ch == EOF)
	    goto fromeof;
d976 1
@


1.30
log
@Update the address and phone number of the FSF
@
text
@d1305 2
@


1.29
log
@update copyright dates
@
text
@d20 2
a21 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.28
log
@	* app.c (do_scrub_chars): Add PUT (ch) and ch = GET ()
	when transitioning from states 14 or 15 to 0 or 1.
@
text
@d3 1
a3 1
   1999, 2000, 2002, 2003
@


1.27
log
@	* app.c (do_scrub_chars): Revert 2003-04-23 and 2003-04-22.
@
text
@d687 5
a691 1
	    state -= 14;
@


1.26
log
@	* app.c: Convert to ISO-C.
	* as.h: Likewise.
	* atof-generic.c: Likewise.
	* bignum-copy.c: Likewise.
	* bignum.h: Likewise.
	* cgen.c: Likewise.
	* cgen.h: Likewise.
	* cond.c: Likewise.
@
text
@d1311 1
a1311 2
	      if (IS_SYMBOL_COMPONENT (ch))
		state = 11;	/* Now seeing label definition.  */
d1315 1
a1315 2
	      if (IS_SYMBOL_COMPONENT (ch))
		state = 2;	/* Ditto.  */
@


1.25
log
@2003-06-07  H.J. Lu <hongjiu.lu@@intel.com>

	* app.c (do_scrub_chars): Add states 14 and 15 to handle
	predicate for ia64.
@
text
@d90 1
a90 1
static int process_escape PARAMS ((int));
d97 1
a97 2
do_scrub_begin (m68k_mri)
     int m68k_mri ATTRIBUTE_UNUSED;
d233 1
a233 1
app_push ()
d269 1
a269 2
app_pop (arg)
     char *arg;
d305 1
a305 2
process_escape (ch)
     int ch;
d340 1
a340 4
do_scrub_chars (get, tostart, tolen)
     int (*get) PARAMS ((char *, int));
     char *tostart;
     int tolen;
@


1.24
log
@Add support for h8300hn and h8300sn
@
text
@d377 6
d682 19
@


1.24.2.1
log
@	* config/tc-hppa.c (hppa_symbol_chars): Revert 2003-04-28 change.
	* config/tc-hppa.h (tc_symbol_chars): Likewise.
	* config/tc-ppc.c (ppc_symbol_chars): Revert 2003-04-24 change.
	* config/tc-ppc.h (tc_symbol_chars): Likewise.
	* app.c (do_scrub_chars): Revert 2003-04-23 and 2003-04-22 changes.
@
text
@d1292 2
a1293 1
	      state = 11;	/* Now seeing label definition.  */
d1297 2
a1298 1
	      state = 2;	/* Ditto.  */
d1302 1
a1302 1
	      if (lex[ch] != LEX_IS_SYMBOL_COMPONENT)
@


1.23
log
@More checks for valid labels
@
text
@d30 1
a30 1
#include "as.h"			/* For BAD_CASE() only */
@


1.22
log
@2003-04-22  H.J. Lu <hjl@@gnu.org>

	* app.c (do_scrub_chars): Check for valid label.
@
text
@d23 1
a23 1
/* Modified by Allen Wirfs-Brock, Instantiations Inc 2/90 */
d118 1
a118 1
      /* I370 uses single-quotes to delimit integer, float constants */
d133 1
a133 3
    {
      lex[(unsigned char) *p] = LEX_IS_SYMBOL_COMPONENT;
    }				/* declare symbol characters */
d153 1
a153 3
    {
      lex[(unsigned char) *p] = LEX_IS_COMMENT_START;
    }				/* declare comment chars */
d156 1
a156 3
    {
      lex[(unsigned char) *p] = LEX_IS_LINE_COMMENT_START;
    }				/* declare line comment chars */
d159 1
a159 3
    {
      lex[(unsigned char) *p] = LEX_IS_LINE_SEPARATOR;
    }				/* declare line separators */
d165 1
a165 3
    {
      lex[(unsigned char) *p] = LEX_IS_PARALLEL_SEPARATOR;
    }				/* declare parallel separators */
d171 1
a171 3
    {
      lex['/'] = LEX_IS_TWOCHAR_COMMENT_1ST;
    }
d192 1
a192 1
  /* must do this is we want VLIW instruction with "->" or "<-" */
d195 1
a195 1
}				/* do_scrub_begin() */
d197 1
a197 1
/* Saved state of the scrubber */
d214 2
a215 1
struct app_save {
d301 1
a301 1
}				/* app_pop() */
d305 1
d581 1
a581 2
		   bne	label	loop if we haven't reach end yet
		 */
d672 1
a672 1
      /* OK, we are somewhere in states 0 through 4 or 9 through 11 */
d957 1
a957 1
	      /* Preserve the whitespace in foo "bar" */
d979 1
a979 1
	      /* Preserve the whitespace in foo 'b' */
d1074 1
d1076 2
a1077 3
	    {
	      as_warn (_("end of file in comment; newline inserted"));
	    }
d1087 2
a1088 3
	    {
	      goto de_fault;
	    }
d1114 1
a1114 1
	    } /* bad hack */
d1127 1
d1134 1
d1248 1
d1250 4
a1253 5
		{
		  /* Handle the last character normally, for
		     simplicity.  */
		  --s;
		}
d1255 1
d1258 1
d1293 1
a1293 1
		state = 11;	/* Now seeing label definition */
d1297 2
a1298 1
	      state = 2;	/* Ditto */
a1350 1
/* end of app.c */
@


1.21
log
@	* app.c (do_scrub_chars): Handle '||' in two states.
@
text
@d1300 2
a1301 1
	      state = 11;	/* Now seeing label definition */
d1309 1
a1309 1
	      if (lex[ch] != LEX_IS_SYMBOL_COMPONENT)
@


1.20
log
@	* app.c (do_scrub_chars): Don't test IGNORE_NONSTANDARD_ESCAPES.  Tidy.
@
text
@d3 1
a3 1
   1999, 2000, 2002
d192 1
a192 1
         then it can't be used in an expression.  */
d380 2
a381 1
         12: After seeing a dash, looking for a second dash as a start of comment.
d384 2
a385 1
	 13: After seeing a vertical bar, looking for a second vertical bar as a parallel expression seperator.
d455 2
a456 2
         branch back to the top of this while loop and generate the
         next output character in the appropriate state.  */
d539 3
a541 3
             with special handling for a backslash.  We try to
             optimize the copying in the simple case without using the
             GET and PUT macros.  */
d550 1
a550 1
                   other character can be LEX_IS_STRINGQUOTE.  */
d668 13
d721 3
a723 3
         MRI mode or not.  Unfortunately, since m68k MRI mode affects
         the scrubber, that means that we need a special purpose
         recognizer here.  */
d760 2
a761 2
                 either '0' or '1' indicating whether to enter or
                 leave MRI mode.  */
d766 2
a767 2
                 main gas reader must also handle the .mri pseudo-op
                 to control expression parsing and the like.  */
d808 1
a808 1
                 colon.  */
d896 3
a898 3
                     case above.  Therefore this is not a label, so it
                     must be the opcode, and we've just seen the
                     whitespace after it.  */
d930 1
a930 1
                     correctly.  */
d974 1
a974 1
                 know what will happen, so optimize a bit.  */
d1096 1
a1098 1
	      UNGET (ch2);
d1101 4
a1104 4
	  /* Reset back to state 1 and pretend that we are parsing a line from
	     just after the first white space.  */
	  state = 1;
	  PUT ('|');
d1237 1
a1237 1
             following symbol component or normal characters.  */
d1261 1
a1261 1
                     simplicity.  */
@


1.19
log
@	* app.c: Fix formatting.
	* as.c: Likewise.
	* ehopt.c: Likewise.
	* expr.c: Likewise.
	* input-file.c: Likewise.
	* listing.c: Likewise.
	* macro.h: Likewise.
	* stabs.c: Likewise.
	* symbols.c: Likewise.
@
text
@d3 1
a3 1
   1999, 2000
d614 5
d638 1
a638 1
#if defined(IGNORE_NONSTANDARD_ESCAPES) | defined(ONLY_STANDARD_ESCAPES)
d640 1
d642 1
a643 10
#else  /* ONLY_STANDARD_ESCAPES */
	    default:
	      /* Accept \x as x for any x */
	      break;
#endif /* ONLY_STANDARD_ESCAPES */

	    case EOF:
	      as_warn (_("end of file in string; '\"' inserted"));
	      PUT ('"');
	      continue;
@


1.18
log
@	* app.c (mri_pseudo): Only declare for TC_M68K.
@
text
@d427 7
a433 7
#define PUT(pch)			\
  do					\
    {					\
      *to++ = (pch);			\
      if (to >= toend)			\
        goto tofull;			\
    }					\
@


1.17
log
@	* app.c: Fix comment typos.
	* bit_fix.h: Likewise.
	* expr.c: Likewise.
	* itbl-ops.c: Likewise.
@
text
@a42 3
#else
#define scrub_m68k_mri 0
#endif
d47 3
@


1.16
log
@	* read.c: Standardize error/warning messages - don't capitalise, no
	final period or newline, don't say "ignored" or "zero assumed" for
	as_bad messages.  In some cases, change the wording to that used
	elsewhere for similar messages.
	* app.c, as.c, atof-generic.c, cgen.c, cond.c, depend.c, dwarf2dbg.c,
	  ecoff.c, expr.c, frags.c, input-file.c, input-scrub.c, listing.c,
	  output-file.c, stabs.c, subsegs.c, symbols.c, write.c: Likewise.
	* ecoff.c (ecoff_directive_end): Test for missing name by
	comparing input line pointers rather than reading string.
	(ecoff_directive_ent): Likewise.
	* read.c (s_set): Likewise.
	(s_align): Report a warning rather than an error for
	alignment too large.
	(s_comm): Check for missing symbol name.
	(s_lcomm_internal): Likewise.
	(s_lsym): Likewise.
	(s_globl): Use is_end_of_line instead of looking for '\n'.
	(s_lcomm_internal): Likewise.
	(ignore_rest_of_line): Report a warning rather than an error.
@
text
@d390 1
a390 1
     between characters which could appear in a identifier.  Ian
@


1.15
log
@2001-07-25  Dave Brolley  <brolley@@redhat.com>

	* app.c (LEX_IS_PARALLEL_SEPARATOR): New macro.
	(IS_PARALLEL_SEPARATOR): New macro.
	(do_scrub_begin): Set up characters in tc_parallel_separator_chars
	as LEX_IS_PARALLEL_SEPARATOR, if it is defined.
	(do_scrub_chars): Handle LEX_PARALLEL_SEPARATOR chars like
	LEX_LINE_SEPARATOR except that we go to state 1 (as if the label has
	been seen).
@
text
@d569 1
a569 1
	      as_warn (_("end of file in string: inserted '\"'"));
d635 1
a635 1
	      as_warn (_("Unknown escape '\\%c' in string: Ignored"), ch);
d644 1
a644 1
	      as_warn (_("End of file in string: '\"' inserted"));
d1007 1
a1007 1
	      as_warn (_("Missing close quote: (assumed)"));
d1139 1
a1139 1
		    as_warn (_("EOF in Comment: Newline inserted"));
@


1.14
log
@Fix copyright notices
@
text
@d81 1
d85 1
d169 9
d810 2
a811 1
	      || IS_LINE_SEPARATOR (ch))
d1051 5
@


1.13
log
@2000-10-12  Kazu Hirata  <kazu@@hxi.com>

	* app.c: Fix formatting.
	* as.c: Likewise.
	* as.h: Likewise.
	* bit_fix.h: Likewise.
	* cgen.c: Likewise.
	* cgen.h: Likewise.
	* cond.c: Likewise.
@
text
@d2 2
a3 1
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
@


1.13.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998,
   1999, 2000
@


1.12
log
@2000-08-29  Kazu Hirata  <kazu@@hxi.com>

	* app.c: Fix a comment typo.  Fix formatting.
@
text
@d214 8
a221 9
struct app_save
  {
    int          state;
    int          old_state;
    char *       out_string;
    char         out_buf[sizeof (out_buf)];
    int          add_newlines;
    char *       saved_input;
    int          saved_input_len;
d223 1
a223 1
    int          scrub_m68k_mri;
d225 2
a226 2
    const char * mri_state;
    char         mri_last_ch;
d228 1
a228 1
    const char * symver_state;
d230 1
a230 1
  };
d781 14
a794 13
          if (lex[ch] == LEX_IS_COLON)
            {
              /* only keep this white if there's no white *after* the colon */
              ch2 = GET ();
              UNGET (ch2);
              if (!IS_WHITESPACE (ch2))
                {
                  state = 9;
                  UNGET (ch);
                  PUT (' ');
                  break;
                }
            }
d1017 1
a1017 1
          state = 9;
d1043 1
a1043 1
	  ch2 = GET();
d1065 1
a1065 1
	  ch2 = GET();
d1143 4
a1146 3
	     We can't make '#' LEX_IS_SYMBOL_COMPONENT because it is already
	     LEX_IS_LINE_COMMENT_START.  However, it is the only character in
	     line_comment_chars for d10v, hence we can recognize it as such.  */
d1149 2
a1150 1
	  if (state == 10) PUT (' ');
d1170 3
a1172 3
	     directives (and .type, though we deal with those another way).  So
	     we check if this line is such a directive, and treat the character
	     as default if so.  This is a hack.  */
d1222 1
a1222 1
		  ch2 = * (unsigned char *) s;
@


1.11
log
@comment-finding hack for hppa-linux.
@
text
@d51 1
a51 1
/* The pseudo-op for which we need to special-case `@@' characters. 
d91 1
a91 1
   each and every time the assembler is run.  xoxorich. */
d93 1
a93 1
void 
d261 1
a261 1
  /* do_scrub_begin() is not useful, just wastes time. */
d269 1
a269 1
void 
d275 1
a275 1
  /* There is no do_scrub_end (). */
d305 1
a305 1
static int 
d1034 1
a1034 1
	  /* fall thru into... */
d1049 1
a1049 1
	  /* read and skip to end of line */
d1062 1
a1062 1
#endif	    
d1077 1
a1077 1
#endif	    
d1126 1
a1126 1
	      /* Loks like `# 123 "filename"' from cpp.  */
d1257 1
a1257 1
		    } 
@


1.10
log
@Don't treat `;' as a line separator by default.
Explicitly mention `;' in line_separator_chars in each backend.
@
text
@d1174 4
@


1.9
log
@IA-64 ELF support.
@
text
@a103 1
  lex[';'] = LEX_IS_LINE_SEPARATOR;
@


1.8
log
@	* app.c: Add ATTRIBUTE_UNUSED as needed.
	* config/tc-ppc.c: Likewise.
	(ppc_size): Make unsigned long.
	(ppc_insert_operand): Add casts to avoid warnings.
@
text
@d916 15
@


1.7
log
@Remove dead code when not TC_M68K.
@
text
@d95 1
a95 1
     int m68k_mri;
@


1.6
log
@Add IBM 370 support.
@
text
@d2 1
a2 1
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 97, 98, 1999
d37 1
d42 3
a99 2
  scrub_m68k_mri = m68k_mri;

d107 3
d111 1
d174 1
d184 1
d224 1
d226 1
d253 1
d255 1
d292 1
d294 1
d867 1
a867 5
	      if (flag_m68k_mri
#ifdef LABELS_WITHOUT_COLONS
		  || 1
#endif
		  )
@


1.5
log
@New preprocessor options.
@
text
@d109 2
a110 1
#ifndef TC_HPPA
@


1.4
log
@1999-11-08  Andrew Haley  <aph@@cygnus.com>

	* app.c (do_scrub_chars): When in State 10, treat backslash
	characters in the same way as as symbol characters.
@
text
@d71 3
d180 1
a180 1
#ifdef TC_M32R
d357 1
a357 1
#ifdef TC_M32R
d767 15
d991 3
d998 1
d1038 1
a1038 1
#ifdef TC_M32R
@


1.3
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Fill in structure initializations.  Add variable
	initializations.  Add casts.
	* dwarf2dbg.c (print_stats): Change i to size_t.
	* listing.c (listing_listing): Change list_line to unsigned int.
@
text
@d1230 17
@


1.2
log
@	* app.c (input_buffer): New static variable.
	(app_push): Save saved_input in allocated buffer.
	(app_pop): Restored saved_input.
	(do_scrub_chars): Change get parameter to take char * and int as
	arguments.  Change GET macro to pass input_buffer to get
	function.  Don't save input into allocated buffer.
	* as.h (do_scrub_chars): Update declaration.
	* input-file.c (input_file_get): Change to take char * and int.
	Read data into passed in buffer.  Remove static buffer.
	* read.c (scrub_from_string): Change to take char * and int.  Copy
	data into passed in buffer.
@
text
@d270 1
a270 1
      assert (saved->saved_input_len <= sizeof input_buffer);
@


1.1
log
@Initial revision
@
text
@d194 1
d231 8
a238 2
  saved->saved_input = saved_input;
  saved->saved_input_len = saved_input_len;
d266 10
a275 2
  saved_input = saved->saved_input;
  saved_input_len = saved->saved_input_len;
d326 1
a326 1
     int (*get) PARAMS ((char **));
d375 9
a383 12
#define GET()				\
  (from < fromend			\
   ? * (unsigned char *) (from++)	\
   : ((saved_input != NULL		\
       ? (free (saved_input),		\
	  saved_input = NULL,		\
	  0)				\
       : 0),				\
      fromlen = (*get) (&from),		\
      fromend = from + fromlen,		\
      (fromlen == 0			\
       ? EOF				\
d415 1
a415 1
      fromlen = (*get) (&from);
d418 1
d1248 1
a1248 7
      char *save;

      save = (char *) xmalloc (fromend - from);
      memcpy (save, from, fromend - from);
      if (saved_input != NULL)
	free (saved_input);
      saved_input = save;
d1252 2
a1253 7
    {
      if (saved_input != NULL)
	{
	  free (saved_input);
	  saved_input = NULL;
	}
    }
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

