head	1.52;
access;
symbols
	binutils-2_24-branch:1.52.0.2
	binutils-2_24-branchpoint:1.52
	binutils-2_21_1:1.49
	binutils-2_23_2:1.51
	binutils-2_23_1:1.51
	binutils-2_23:1.51
	binutils-2_23-branch:1.51.0.2
	binutils-2_23-branchpoint:1.51
	binutils-2_22_branch:1.50.0.4
	binutils-2_22:1.50
	binutils-2_22-branch:1.50.0.2
	binutils-2_22-branchpoint:1.50
	binutils-2_21:1.49
	binutils-2_21-branch:1.49.0.2
	binutils-2_21-branchpoint:1.49
	binutils-2_20_1:1.41.2.2
	binutils-2_20:1.41.2.1
	binutils-arc-20081103-branch:1.36.0.4
	binutils-arc-20081103-branchpoint:1.36
	binutils-2_20-branch:1.41.0.2
	binutils-2_20-branchpoint:1.41
	dje-cgen-play1-branch:1.37.0.2
	dje-cgen-play1-branchpoint:1.37
	arc-20081103-branch:1.36.0.2
	arc-20081103-branchpoint:1.36
	binutils-2_19_1:1.34.2.1
	binutils-2_19:1.34.2.1
	binutils-2_19-branch:1.34.0.2
	binutils-2_19-branchpoint:1.34
	binutils-2_18:1.32
	binutils-2_18-branch:1.32.0.2
	binutils-2_18-branchpoint:1.32
	binutils-csl-coldfire-4_1-32:1.29
	binutils-csl-sourcerygxx-4_1-32:1.29
	binutils-csl-innovasic-fido-3_4_4-33:1.29
	binutils-csl-sourcerygxx-3_4_4-32:1.27
	binutils-csl-coldfire-4_1-30:1.29
	binutils-csl-sourcerygxx-4_1-30:1.29
	binutils-csl-coldfire-4_1-28:1.29
	binutils-csl-sourcerygxx-4_1-29:1.29
	binutils-csl-sourcerygxx-4_1-28:1.29
	binutils-csl-arm-2006q3-27:1.29
	binutils-csl-sourcerygxx-4_1-27:1.29
	binutils-csl-arm-2006q3-26:1.29
	binutils-csl-sourcerygxx-4_1-26:1.29
	binutils-csl-sourcerygxx-4_1-25:1.29
	binutils-csl-sourcerygxx-4_1-24:1.29
	binutils-csl-sourcerygxx-4_1-23:1.29
	binutils-csl-sourcerygxx-4_1-21:1.29
	binutils-csl-arm-2006q3-21:1.29
	binutils-csl-sourcerygxx-4_1-22:1.29
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.29
	binutils-csl-sourcerygxx-4_1-20:1.29
	binutils-csl-arm-2006q3-19:1.29
	binutils-csl-sourcerygxx-4_1-19:1.29
	binutils-csl-sourcerygxx-4_1-18:1.29
	binutils-csl-renesas-4_1-9:1.29
	binutils-csl-sourcerygxx-3_4_4-25:1.27
	binutils-csl-renesas-4_1-8:1.29
	binutils-csl-renesas-4_1-7:1.29
	binutils-csl-renesas-4_1-6:1.29
	binutils-csl-sourcerygxx-4_1-17:1.29
	binutils-csl-sourcerygxx-4_1-14:1.29
	binutils-csl-sourcerygxx-4_1-15:1.29
	binutils-csl-sourcerygxx-4_1-13:1.29
	binutils-2_17:1.29
	binutils-csl-sourcerygxx-4_1-12:1.29
	binutils-csl-sourcerygxx-3_4_4-21:1.29
	binutils-csl-wrs-linux-3_4_4-24:1.27
	binutils-csl-wrs-linux-3_4_4-23:1.27
	binutils-csl-sourcerygxx-4_1-9:1.29
	binutils-csl-sourcerygxx-4_1-8:1.29
	binutils-csl-sourcerygxx-4_1-7:1.29
	binutils-csl-arm-2006q1-6:1.29
	binutils-csl-sourcerygxx-4_1-6:1.29
	binutils-csl-wrs-linux-3_4_4-22:1.27
	binutils-csl-coldfire-4_1-11:1.29
	binutils-csl-sourcerygxx-3_4_4-19:1.29
	binutils-csl-coldfire-4_1-10:1.29
	binutils-csl-sourcerygxx-4_1-5:1.29
	binutils-csl-sourcerygxx-4_1-4:1.29
	binutils-csl-wrs-linux-3_4_4-21:1.27
	binutils-csl-morpho-4_1-4:1.29
	binutils-csl-sourcerygxx-3_4_4-17:1.29
	binutils-csl-wrs-linux-3_4_4-20:1.27
	binutils-2_17-branch:1.29.0.4
	binutils-2_17-branchpoint:1.29
	binutils-csl-2_17-branch:1.29.0.2
	binutils-csl-2_17-branchpoint:1.29
	binutils-csl-gxxpro-3_4-branch:1.27.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.27
	binutils-2_16_1:1.27
	binutils-csl-arm-2005q1b:1.27
	binutils-2_16:1.27
	binutils-csl-arm-2005q1a:1.27
	binutils-csl-arm-2005q1-branch:1.27.0.4
	binutils-csl-arm-2005q1-branchpoint:1.27
	binutils-2_16-branch:1.27.0.2
	binutils-2_16-branchpoint:1.27
	csl-arm-2004-q3d:1.25
	csl-arm-2004-q3:1.25
	binutils-2_15:1.25
	binutils-2_15-branchpoint:1.25
	csl-arm-2004-q1a:1.25
	csl-arm-2004-q1:1.25
	binutils-2_15-branch:1.25.0.6
	cagney_bfdfile-20040213-branch:1.25.0.4
	cagney_bfdfile-20040213-branchpoint:1.25
	cagney_bigcore-20040122-branch:1.25.0.2
	cagney_bigcore-20040122-branchpoint:1.25
	csl-arm-2003-q4:1.25
	binutils-2_14:1.21
	binutils-2_14-branch:1.21.0.4
	binutils-2_14-branchpoint:1.21
	binutils-2_13_2_1:1.21
	binutils-2_13_2:1.21
	binutils-2_13_1:1.21
	binutils-2_13:1.21
	binutils-2_13-branchpoint:1.21
	binutils-2_13-branch:1.21.0.2
	binutils-2_12_1:1.18
	binutils-2_12:1.18
	binutils-2_12-branch:1.18.0.2
	binutils-2_12-branchpoint:1.18
	cygnus_cvs_20020108_pre:1.18
	binutils-2_11_2:1.12.2.1
	binutils-2_11_1:1.12.2.1
	binutils-2_11:1.12.2.1
	x86_64versiong3:1.12
	binutils-2_11-branch:1.12.0.2
	binutils-2_10_1:1.8
	binutils-2_10:1.8
	binutils-2_10-branch:1.8.0.2
	binutils-2_10-branchpoint:1.8
	binutils_latest_snapshot:1.52
	repo-unification-2000-02-06:1.6
	binu_ss_19990721:1.4
	binu_ss_19990602:1.2
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.52
date	2013.03.26.14.16.59;	author nickc;	state Exp;
branches;
next	1.51;

1.51
date	2012.07.27.03.32.21;	author segher;	state Exp;
branches;
next	1.50;

1.50
date	2011.02.28.18.32.52;	author ktietz;	state Exp;
branches;
next	1.49;

1.49
date	2010.06.28.14.06.56;	author amodra;	state Exp;
branches;
next	1.48;

1.48
date	2010.04.09.14.40.18;	author nickc;	state Exp;
branches;
next	1.47;

1.47
date	2010.03.09.00.41.24;	author amodra;	state Exp;
branches;
next	1.46;

1.46
date	2010.01.12.01.10.55;	author amodra;	state Exp;
branches;
next	1.45;

1.45
date	2009.12.11.13.42.09;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	2009.10.26.23.57.43;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2009.10.15.10.58.34;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2009.09.11.15.27.33;	author nickc;	state Exp;
branches;
next	1.41;

1.41
date	2009.09.02.07.24.19;	author amodra;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2009.08.29.22.10.59;	author nickc;	state Exp;
branches;
next	1.39;

1.39
date	2009.07.16.00.37.28;	author hjl;	state Exp;
branches;
next	1.38;

1.38
date	2009.07.14.12.54.47;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	2009.03.24.01.04.25;	author hjl;	state Exp;
branches;
next	1.36;

1.36
date	2008.10.03.20.21.33;	author kazu;	state Exp;
branches;
next	1.35;

1.35
date	2008.09.24.14.38.03;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2008.04.11.09.06.02;	author nickc;	state Exp;
branches
	1.34.2.1;
next	1.33;

1.33
date	2008.04.10.12.45.17;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2007.07.03.11.01.03;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	2006.09.22.11.35.13;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2006.05.01.09.21.46;	author bje;	state Exp;
branches;
next	1.29;

1.29
date	2005.08.11.01.25.20;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2005.05.05.09.12.45;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	2005.03.03.01.29.53;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2005.01.21.05.54.38;	author bje;	state Exp;
branches;
next	1.25;

1.25
date	2003.12.19.15.23.40;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2003.11.24.17.52.33;	author kazu;	state Exp;
branches;
next	1.23;

1.23
date	2003.11.23.02.14.21;	author kazu;	state Exp;
branches;
next	1.22;

1.22
date	2003.10.27.12.45.17;	author kazu;	state Exp;
branches;
next	1.21;

1.21
date	2002.06.26.01.18.42;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.25.12.53.29;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2002.05.18.12.53.30;	author kazu;	state Exp;
branches;
next	1.18;

1.18
date	2001.09.25.12.09.45;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2001.09.19.05.33.19;	author hjl;	state Exp;
branches;
next	1.16;

1.16
date	2001.08.01.01.44.25;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2001.07.10.09.45.50;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2001.03.31.06.47.54;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2001.03.08.23.24.22;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2001.01.01.01.51.17;	author hjl;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2000.12.29.23.48.10;	author hjl;	state Exp;
branches;
next	1.10;

1.10
date	2000.11.07.01.18.45;	author kazu;	state Exp;
branches;
next	1.9;

1.9
date	2000.08.31.06.11.03;	author kazu;	state Exp;
branches;
next	1.8;

1.8
date	2000.03.27.23.47.08;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.21.12.01.25;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2000.02.04.19.45.19;	author twall;	state Exp;
branches;
next	1.5;

1.5
date	2000.02.03.18.20.23;	author twall;	state Exp;
branches;
next	1.4;

1.4
date	99.07.11.20.19.57;	author ian;	state Exp;
branches;
next	1.3;

1.3
date	99.06.03.00.29.03;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.05.28.15.28.53;	author devans;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.41;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.41.2.1
date	2009.09.11.15.28.43;	author nickc;	state Exp;
branches;
next	1.41.2.2;

1.41.2.2
date	2010.01.12.01.11.15;	author amodra;	state Exp;
branches;
next	;

1.34.2.1
date	2008.09.24.14.40.06;	author amodra;	state Exp;
branches;
next	;

1.12.2.1
date	2001.03.31.06.49.33;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.41;	author rth;	state Exp;
branches;
next	;


desc
@@


1.52
log
@	PR gas/15295
	* listing.c (rebuffer_line): Rewrite to avoid seeking back to the
	start of the file each time.
@
text
@/* listing.c - maintain assembly listings
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001, 2002, 2003, 2005, 2006, 2007, 2008, 2009, 2010
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Contributed by Steve Chamberlain <sac@@cygnus.com>

 A listing page looks like:

 LISTING_HEADER  sourcefilename pagenumber
 TITLE LINE
 SUBTITLE LINE
 linenumber address data  source
 linenumber address data  source
 linenumber address data  source
 linenumber address data  source

 If not overridden, the listing commands are:

 .title  "stuff"
 	Put "stuff" onto the title line
 .sbttl  "stuff"
        Put stuff onto the subtitle line

  If these commands come within 10 lines of the top of the page, they
  will affect the page they are on, as well as any subsequent page

 .eject
 	Thow a page
 .list
 	Increment the enable listing counter
 .nolist
 	Decrement the enable listing counter

 .psize Y[,X]
 	Set the paper size to X wide and Y high. Setting a psize Y of
	zero will suppress form feeds except where demanded by .eject

 If the counter goes below zero, listing is suppressed.

 Listings are a maintained by read calling various listing_<foo>
 functions.  What happens most is that the macro NO_LISTING is not
 defined (from the Makefile), then the macro LISTING_NEWLINE expands
 into a call to listing_newline.  The call is done from read.c, every
 time it sees a newline, and -l is on the command line.

 The function listing_newline remembers the frag associated with the
 newline, and creates a new frag - note that this is wasteful, but not
 a big deal, since listing slows things down a lot anyway.  The
 function also remembers when the filename changes.

 When all the input has finished, and gas has had a chance to settle
 down, the listing is output. This is done by running down the list of
 frag/source file records, and opening the files as needed and printing
 out the bytes and chars associated with them.

 The only things which the architecture can change about the listing
 are defined in these macros:

 LISTING_HEADER		The name of the architecture
 LISTING_WORD_SIZE      The make of the number of bytes in a word, this determines
 			the clumping of the output data. eg a value of
			2 makes words look like 1234 5678, whilst 1
			would make the same value look like 12 34 56
			78
 LISTING_LHS_WIDTH      Number of words of above size for the lhs

 LISTING_LHS_WIDTH_SECOND   Number of words for the data on the lhs
 			for the second line

 LISTING_LHS_CONT_LINES	Max number of lines to use up for a continuation
 LISTING_RHS_WIDTH      Number of chars from the input file to print
                        on a line.  */

#include "as.h"
#include "filenames.h"
#include "obstack.h"
#include "safe-ctype.h"
#include "input-file.h"
#include "subsegs.h"
#include "bfdver.h"
#include <time.h>
#include <stdarg.h>

#ifndef NO_LISTING

#ifndef LISTING_HEADER
#define LISTING_HEADER "GAS LISTING"
#endif
#ifndef LISTING_WORD_SIZE
#define LISTING_WORD_SIZE 4
#endif
#ifndef LISTING_LHS_WIDTH
#define LISTING_LHS_WIDTH ((LISTING_WORD_SIZE) > 4 ? 1 : 4 / (LISTING_WORD_SIZE))
#endif
#ifndef LISTING_LHS_WIDTH_SECOND
#define LISTING_LHS_WIDTH_SECOND LISTING_LHS_WIDTH
#endif
#ifndef LISTING_RHS_WIDTH
#define LISTING_RHS_WIDTH 100
#endif
#ifndef LISTING_LHS_CONT_LINES
#define LISTING_LHS_CONT_LINES 4
#endif
#define MAX_DATELEN 30

/* This structure remembers which .s were used.  */
typedef struct file_info_struct
{
  struct file_info_struct * next;
  char *                    filename;
  long                      pos;
  unsigned int              linenum;
  int                       at_end;
} file_info_type;

enum edict_enum
{
  EDICT_NONE,
  EDICT_SBTTL,
  EDICT_TITLE,
  EDICT_NOLIST,
  EDICT_LIST,
  EDICT_NOLIST_NEXT,
  EDICT_EJECT
};


struct list_message
{
  char *message;
  struct list_message *next;
};

/* This structure remembers which line from which file goes into which
   frag.  */
struct list_info_struct
{
  /* Frag which this line of source is nearest to.  */
  fragS *frag;

  /* The actual line in the source file.  */
  unsigned int line;

  /* Pointer to the file info struct for the file which this line
     belongs to.  */
  file_info_type *file;

  /* The expanded text of any macro that may have been executing.  */
  char *line_contents;

  /* Next in list.  */
  struct list_info_struct *next;

  /* Pointer to the file info struct for the high level language
     source line that belongs here.  */
  file_info_type *hll_file;

  /* High level language source line.  */
  unsigned int hll_line;

  /* Pointers to linked list of messages associated with this line.  */
  struct list_message *messages, *last_message;

  enum edict_enum edict;
  char *edict_arg;

  /* Nonzero if this line is to be omitted because it contains
     debugging information.  This can become a flags field if we come
     up with more information to store here.  */
  int debugging;
};

typedef struct list_info_struct list_info_type;

int listing_lhs_width        = LISTING_LHS_WIDTH;
int listing_lhs_width_second = LISTING_LHS_WIDTH_SECOND;
int listing_lhs_cont_lines   = LISTING_LHS_CONT_LINES;
int listing_rhs_width        = LISTING_RHS_WIDTH;

struct list_info_struct *        listing_tail;

static file_info_type *          file_info_head;
static file_info_type *          last_open_file_info;
static FILE *                    last_open_file;
static struct list_info_struct * head;
static int                       paper_width = 200;
static int                       paper_height = 60;

extern int                       listing;

/* File to output listings to.  */
static FILE *list_file;

/* This static array is used to keep the text of data to be printed
   before the start of the line.  */

#define MAX_BYTES							\
  (((LISTING_WORD_SIZE * 2) + 1) * listing_lhs_width			\
   + ((((LISTING_WORD_SIZE * 2) + 1) * listing_lhs_width_second)	\
      * listing_lhs_cont_lines)						\
   + 20)

static char *data_buffer;

/* Prototypes.  */
static void listing_message (const char *, const char *);
static file_info_type *file_info (const char *);
static void new_frag (void);
static void listing_page (list_info_type *);
static unsigned int calc_hex (list_info_type *);
static void print_lines (list_info_type *, unsigned int, char *, unsigned int);
static void list_symbol_table (void);
static int debugging_pseudo (list_info_type *, const char *);
static void listing_listing (char *);

static void
listing_message (const char *name, const char *message)
{
  if (listing_tail != (list_info_type *) NULL)
    {
      unsigned int l = strlen (name) + strlen (message) + 1;
      char *n = (char *) xmalloc (l);
      struct list_message *lm = xmalloc (sizeof *lm);
      strcpy (n, name);
      strcat (n, message);
      lm->message = n;
      lm->next = NULL;

      if (listing_tail->last_message)
	listing_tail->last_message->next = lm;
      else
	listing_tail->messages = lm;
      listing_tail->last_message = lm;
    }
}

void
listing_warning (const char *message)
{
  listing_message (_("Warning:"), message);
}

void
listing_error (const char *message)
{
  listing_message (_("Error:"), message);
}

static file_info_type *
file_info (const char *file_name)
{
  /* Find an entry with this file name.  */
  file_info_type *p = file_info_head;

  while (p != (file_info_type *) NULL)
    {
      if (filename_cmp (p->filename, file_name) == 0)
	return p;
      p = p->next;
    }

  /* Make new entry.  */
  p = (file_info_type *) xmalloc (sizeof (file_info_type));
  p->next = file_info_head;
  file_info_head = p;
  p->filename = xstrdup (file_name);
  p->pos = 0;
  p->linenum = 0;
  p->at_end = 0;

  return p;
}

static void
new_frag (void)
{
  frag_wane (frag_now);
  frag_new (0);
}

void
listing_newline (char *ps)
{
  char *file;
  unsigned int line;
  static unsigned int last_line = 0xffff;
  static char *last_file = NULL;
  list_info_type *new_i = NULL;

  if (listing == 0)
    return;

  if (now_seg == absolute_section)
    return;

#ifdef OBJ_ELF
  /* In ELF, anything in a section beginning with .debug or .line is
     considered to be debugging information.  This includes the
     statement which switches us into the debugging section, which we
     can only set after we are already in the debugging section.  */
  if ((listing & LISTING_NODEBUG) != 0
      && listing_tail != NULL
      && ! listing_tail->debugging)
    {
      const char *segname;

      segname = segment_name (now_seg);
      if (strncmp (segname, ".debug", sizeof ".debug" - 1) == 0
	  || strncmp (segname, ".line", sizeof ".line" - 1) == 0)
	listing_tail->debugging = 1;
    }
#endif

  as_where (&file, &line);
  if (ps == NULL)
    {
      if (line == last_line
	  && !(last_file && file && filename_cmp (file, last_file)))
	return;

      new_i = (list_info_type *) xmalloc (sizeof (list_info_type));

      /* Detect if we are reading from stdin by examining the file
	 name returned by as_where().

	 [FIXME: We rely upon the name in the strcmp below being the
	 same as the one used by input_scrub_new_file(), if that is
	 not true, then this code will fail].

	 If we are reading from stdin, then we need to save each input
	 line here (assuming of course that we actually have a line of
	 input to read), so that it can be displayed in the listing
	 that is produced at the end of the assembly.  */
      if (strcmp (file, _("{standard input}")) == 0
	  && input_line_pointer != NULL)
	{
	  char *copy;
	  int len;
	  int seen_quote = 0;
	  int seen_slash = 0;

	  for (copy = input_line_pointer;
	       *copy && (seen_quote
			 || is_end_of_line [(unsigned char) *copy] != 1);
	       copy++)
	    {
	      if (seen_slash)
		seen_slash = 0;
	      else if (*copy == '\\')
		seen_slash = 1;
	      else if (*copy == '"')
		seen_quote = !seen_quote;
	    }

	  len = copy - input_line_pointer + 1;

	  copy = (char *) xmalloc (len);

	  if (copy != NULL)
	    {
	      char *src = input_line_pointer;
	      char *dest = copy;

	      while (--len)
		{
		  unsigned char c = *src++;

		  /* Omit control characters in the listing.  */
		  if (!ISCNTRL (c))
		    *dest++ = c;
		}

	      *dest = 0;
	    }

	  new_i->line_contents = copy;
	}
      else
	new_i->line_contents = NULL;
    }
  else
    {
      new_i = (list_info_type *) xmalloc (sizeof (list_info_type));
      new_i->line_contents = ps;
    }

  last_line = line;
  last_file = file;

  new_frag ();

  if (listing_tail)
    listing_tail->next = new_i;
  else
    head = new_i;

  listing_tail = new_i;

  new_i->frag = frag_now;
  new_i->line = line;
  new_i->file = file_info (file);
  new_i->next = (list_info_type *) NULL;
  new_i->messages = NULL;
  new_i->last_message = NULL;
  new_i->edict = EDICT_NONE;
  new_i->hll_file = (file_info_type *) NULL;
  new_i->hll_line = 0;
  new_i->debugging = 0;

  new_frag ();

#ifdef OBJ_ELF
  /* In ELF, anything in a section beginning with .debug or .line is
     considered to be debugging information.  */
  if ((listing & LISTING_NODEBUG) != 0)
    {
      const char *segname;

      segname = segment_name (now_seg);
      if (strncmp (segname, ".debug", sizeof ".debug" - 1) == 0
	  || strncmp (segname, ".line", sizeof ".line" - 1) == 0)
	new_i->debugging = 1;
    }
#endif
}

/* Attach all current frags to the previous line instead of the
   current line.  This is called by the MIPS backend when it discovers
   that it needs to add some NOP instructions; the added NOP
   instructions should go with the instruction that has the delay, not
   with the new instruction.  */

void
listing_prev_line (void)
{
  list_info_type *l;
  fragS *f;

  if (head == (list_info_type *) NULL
      || head == listing_tail)
    return;

  new_frag ();

  for (l = head; l->next != listing_tail; l = l->next)
    ;

  for (f = frchain_now->frch_root; f != (fragS *) NULL; f = f->fr_next)
    if (f->line == listing_tail)
      f->line = l;

  listing_tail->frag = frag_now;
  new_frag ();
}

/* This function returns the next source line from the file supplied,
   truncated to size.  It appends a fake line to the end of each input
   file to make using the returned buffer simpler.  */

static char *
buffer_line (file_info_type *file, char *line, unsigned int size)
{
  unsigned int count = 0;
  int c;
  char *p = line;

  /* If we couldn't open the file, return an empty line.  */
  if (file->at_end)
    return "";

  /* Check the cache and see if we last used this file.  */
  if (!last_open_file_info || file != last_open_file_info)
    {
      if (last_open_file)
	{
	  last_open_file_info->pos = ftell (last_open_file);
	  fclose (last_open_file);
	}

      /* Open the file in the binary mode so that ftell above can
	 return a reliable value that we can feed to fseek below.  */
      last_open_file_info = file;
      last_open_file = fopen (file->filename, FOPEN_RB);
      if (last_open_file == NULL)
	{
	  file->at_end = 1;
	  return "";
	}

      /* Seek to where we were last time this file was open.  */
      if (file->pos)
	fseek (last_open_file, file->pos, SEEK_SET);
    }

  /* Leave room for null.  */
  size -= 1;

  c = fgetc (last_open_file);

  while (c != EOF && c != '\n' && c != '\r')
    {
      if (count < size)
	*p++ = c;
      count++;

      c = fgetc (last_open_file);
    }

  /* If '\r' is followed by '\n', swallow that.  Likewise, if '\n'
     is followed by '\r', swallow that as well.  */
  if (c == '\r' || c == '\n')
    {
      int next = fgetc (last_open_file);

      if ((c == '\r' && next != '\n')
	  || (c == '\n' && next != '\r'))
	ungetc (next, last_open_file);
    }

  if (c == EOF)
    {
      file->at_end = 1;
      if (count + 2 < size)
	{
	  *p++ = '.';
	  *p++ = '.';
	  *p++ = '.';
	}
    }
  file->linenum++;
  *p++ = 0;
  return line;
}


/* This function rewinds the requested file back to the line requested,
   reads it in again into the buffer provided and then restores the file
   back to its original location.  Returns the buffer pointer upon success
   or an empty string if an error occurs.  */

static char *
rebuffer_line (file_info_type *  file,
	       unsigned int      linenum,
	       char *            buffer,
	       unsigned int      size)
{
  unsigned int count = 0;
  unsigned int current_line;
  char * p = buffer;
  long pos;
  long pos2;
  int c;
  bfd_boolean found = FALSE;

  /* Sanity checks.  */
  if (file == NULL || buffer == NULL || size <= 1 || file->linenum <= linenum)
    return "";

  /* Check the cache and see if we last used this file.  */
  if (last_open_file_info == NULL || file != last_open_file_info)
    {
      if (last_open_file)
	{
	  last_open_file_info->pos = ftell (last_open_file);
	  fclose (last_open_file);
	}

      /* Open the file in the binary mode so that ftell above can
	 return a reliable value that we can feed to fseek below.  */
      last_open_file_info = file;
      last_open_file = fopen (file->filename, FOPEN_RB);
      if (last_open_file == NULL)
	{
	  file->at_end = 1;
	  return "";
	}

      /* Seek to where we were last time this file was open.  */
      if (file->pos)
	fseek (last_open_file, file->pos, SEEK_SET);
    }

  /* Remember where we are in the current file.  */
  pos2 = pos = ftell (last_open_file);
  if (pos < 3)
    return "";
  current_line = file->linenum;

  /* Leave room for the nul at the end of the buffer.  */
  size -= 1;
  buffer[size] = 0;

  /* Increment the current line count by one.
     This is to allow for the fact that we are searching for the
     start of a previous line, but we do this by detecting end-of-line
     character(s) not start-of-line characters.  */
  ++ current_line;

  while (pos2 > 0 && ! found)
    {
      char * ptr;

      /* Move backwards through the file, looking for earlier lines.  */
      pos2 = (long) size > pos2 ? 0 : pos2 - size;
      fseek (last_open_file, pos2, SEEK_SET);

      /* Our caller has kindly provided us with a buffer, so we use it.  */
      if (fread (buffer, 1, size, last_open_file) != size)
	{
	  as_warn (_("unable to rebuffer file: %s\n"), file->filename);
	  return "";
	}

      for (ptr = buffer + size; ptr >= buffer; -- ptr)
	{
	  if (*ptr == '\n')
	    {
	      -- current_line;

	      if (current_line == linenum)
		{
		  /* We have found the start of the line we seek.  */
		  found = TRUE;

		  /* FIXME: We could skip the read-in-the-line code
		     below if we know that we already have the whole
		     line in the buffer.  */

		  /* Advance pos2 to the newline character we have just located.  */
		  pos2 += (ptr - buffer);

		  /* Skip the newline and, if present, the carriage return.  */
		  if (ptr + 1 == buffer + size)
		    {
		      ++pos2;
		      if (fgetc (last_open_file) == '\r')
			++ pos2;
		    }
		  else
		    pos2 += (ptr[1] == '\r' ? 2 : 1);

		  /* Move the file pointer to this location.  */
		  fseek (last_open_file, pos2, SEEK_SET);
		  break;
		}
	    }
	}
    }

  /* Read in the line.  */
  c = fgetc (last_open_file);

  while (c != EOF && c != '\n' && c != '\r')
    {
      if (count < size)
	*p++ = c;
      count++;

      c = fgetc (last_open_file);
    }

  /* If '\r' is followed by '\n', swallow that.  Likewise, if '\n'
     is followed by '\r', swallow that as well.  */
  if (c == '\r' || c == '\n')
    {
      int next = fgetc (last_open_file);

      if ((c == '\r' && next != '\n')
	  || (c == '\n' && next != '\r'))
	ungetc (next, last_open_file);
    }

  /* Terminate the line.  */
  *p++ = 0;

  /* Reset the file position.  */
  fseek (last_open_file, pos, SEEK_SET);

  return buffer;
}

static const char *fn;

static unsigned int eject;	/* Eject pending */
static unsigned int page;	/* Current page number */
static char *title;		/* Current title */
static char *subtitle;		/* Current subtitle */
static unsigned int on_page;	/* Number of lines printed on current page */

static void
listing_page (list_info_type *list)
{
  /* Grope around, see if we can see a title or subtitle edict coming up
     soon.  (we look down 10 lines of the page and see if it's there)  */
  if ((eject || (on_page >= (unsigned int) paper_height))
      && paper_height != 0)
    {
      unsigned int c = 10;
      int had_title = 0;
      int had_subtitle = 0;

      page++;

      while (c != 0 && list)
	{
	  if (list->edict == EDICT_SBTTL && !had_subtitle)
	    {
	      had_subtitle = 1;
	      subtitle = list->edict_arg;
	    }
	  if (list->edict == EDICT_TITLE && !had_title)
	    {
	      had_title = 1;
	      title = list->edict_arg;
	    }
	  list = list->next;
	  c--;
	}

      if (page > 1)
	{
	  fprintf (list_file, "\f");
	}

      fprintf (list_file, "%s %s \t\t\tpage %d\n", LISTING_HEADER, fn, page);
      fprintf (list_file, "%s\n", title);
      fprintf (list_file, "%s\n", subtitle);
      on_page = 3;
      eject = 0;
    }
}

/* Print a line into the list_file.  Update the line count
   and if necessary start a new page.  */

static void
emit_line (list_info_type * list, const char * format, ...)
{
  va_list args;

  va_start (args, format);

  vfprintf (list_file, format, args);
  on_page++;
  listing_page (list);

  va_end (args);
}

static unsigned int
calc_hex (list_info_type *list)
{
  int data_buffer_size;
  list_info_type *first = list;
  unsigned int address = ~(unsigned int) 0;
  fragS *frag;
  fragS *frag_ptr;
  unsigned int octet_in_frag;

  /* Find first frag which says it belongs to this line.  */
  frag = list->frag;
  while (frag && frag->line != list)
    frag = frag->fr_next;

  frag_ptr = frag;

  data_buffer_size = 0;

  /* Dump all the frags which belong to this line.  */
  while (frag_ptr != (fragS *) NULL && frag_ptr->line == first)
    {
      /* Print as many bytes from the fixed part as is sensible.  */
      octet_in_frag = 0;
      while ((offsetT) octet_in_frag < frag_ptr->fr_fix
	     && data_buffer_size < MAX_BYTES - 3)
	{
	  if (address == ~(unsigned int) 0)
	    address = frag_ptr->fr_address / OCTETS_PER_BYTE;

	  sprintf (data_buffer + data_buffer_size,
		   "%02X",
		   (frag_ptr->fr_literal[octet_in_frag]) & 0xff);
	  data_buffer_size += 2;
	  octet_in_frag++;
	}
      if (frag_ptr->fr_type == rs_fill)
	{
	  unsigned int var_rep_max = octet_in_frag;
	  unsigned int var_rep_idx = octet_in_frag;

	  /* Print as many bytes from the variable part as is sensible.  */
	  while (((offsetT) octet_in_frag
		  < (frag_ptr->fr_fix + frag_ptr->fr_var * frag_ptr->fr_offset))
		 && data_buffer_size < MAX_BYTES - 3)
	    {
	      if (address == ~(unsigned int) 0)
		address = frag_ptr->fr_address / OCTETS_PER_BYTE;

	      sprintf (data_buffer + data_buffer_size,
		       "%02X",
		       (frag_ptr->fr_literal[var_rep_idx]) & 0xff);
	      data_buffer_size += 2;

	      var_rep_idx++;
	      octet_in_frag++;

	      if ((offsetT) var_rep_idx >= frag_ptr->fr_fix + frag_ptr->fr_var)
		var_rep_idx = var_rep_max;
	    }
	}

      frag_ptr = frag_ptr->fr_next;
    }
  data_buffer[data_buffer_size] = '\0';
  return address;
}

static void
print_lines (list_info_type *list, unsigned int lineno,
	     char *string, unsigned int address)
{
  unsigned int idx;
  unsigned int nchars;
  unsigned int lines;
  unsigned int octet_in_word = 0;
  char *src = data_buffer;
  int cur;
  struct list_message *msg;

  /* Print the stuff on the first line.  */
  listing_page (list);
  nchars = (LISTING_WORD_SIZE * 2 + 1) * listing_lhs_width;

  /* Print the hex for the first line.  */
  if (address == ~(unsigned int) 0)
    {
      fprintf (list_file, "% 4d     ", lineno);
      for (idx = 0; idx < nchars; idx++)
	fprintf (list_file, " ");

      emit_line (NULL, "\t%s\n", string ? string : "");
      return;
    }

  if (had_errors ())
    fprintf (list_file, "% 4d ???? ", lineno);
  else
    fprintf (list_file, "% 4d %04x ", lineno, address);

  /* And the data to go along with it.  */
  idx = 0;
  cur = 0;
  while (src[cur] && idx < nchars)
    {
      int offset;
      offset = cur;
      fprintf (list_file, "%c%c", src[offset], src[offset + 1]);
      cur += 2;
      octet_in_word++;

      if (octet_in_word == LISTING_WORD_SIZE)
	{
	  fprintf (list_file, " ");
	  idx++;
	  octet_in_word = 0;
	}

      idx += 2;
    }

  for (; idx < nchars; idx++)
    fprintf (list_file, " ");

  emit_line (list, "\t%s\n", string ? string : "");

  for (msg = list->messages; msg; msg = msg->next)
    emit_line (list, "****  %s\n", msg->message);

  for (lines = 0;
       lines < (unsigned int) listing_lhs_cont_lines
	 && src[cur];
       lines++)
    {
      nchars = ((LISTING_WORD_SIZE * 2) + 1) * listing_lhs_width_second - 1;
      idx = 0;

      /* Print any more lines of data, but more compactly.  */
      fprintf (list_file, "% 4d      ", lineno);

      while (src[cur] && idx < nchars)
	{
	  int offset;
	  offset = cur;
	  fprintf (list_file, "%c%c", src[offset], src[offset + 1]);
	  cur += 2;
	  idx += 2;
	  octet_in_word++;

	  if (octet_in_word == LISTING_WORD_SIZE)
	    {
	      fprintf (list_file, " ");
	      idx++;
	      octet_in_word = 0;
	    }
	}

      emit_line (list, "\n");
    }
}

static void
list_symbol_table (void)
{
  extern symbolS *symbol_rootP;
  int got_some = 0;

  symbolS *ptr;
  eject = 1;
  listing_page (NULL);

  for (ptr = symbol_rootP; ptr != (symbolS *) NULL; ptr = symbol_next (ptr))
    {
      if (SEG_NORMAL (S_GET_SEGMENT (ptr))
	  || S_GET_SEGMENT (ptr) == absolute_section)
	{
	  /* Don't report section symbols.  They are not interesting.  */
	  if (symbol_section_p (ptr))
	    continue;

	  if (S_GET_NAME (ptr))
	    {
	      char buf[30], fmt[8];
	      valueT val = S_GET_VALUE (ptr);

	      /* @@@@ Note that this is dependent on the compilation options,
		 not solely on the target characteristics.  */
	      if (sizeof (val) == 4 && sizeof (int) == 4)
		sprintf (buf, "%08lx", (unsigned long) val);
	      else if (sizeof (val) <= sizeof (unsigned long))
		{
		  sprintf (fmt, "%%0%lulx",
			   (unsigned long) (sizeof (val) * 2));
		  sprintf (buf, fmt, (unsigned long) val);
		}
#if defined (BFD64)
	      else if (sizeof (val) > 4)
		sprintf_vma (buf, val);
#endif
	      else
		abort ();

	      if (!got_some)
		{
		  fprintf (list_file, "DEFINED SYMBOLS\n");
		  on_page++;
		  got_some = 1;
		}

	      if (symbol_get_frag (ptr) && symbol_get_frag (ptr)->line)
		{
		  fprintf (list_file, "%20s:%-5d  %s:%s %s\n",
			   symbol_get_frag (ptr)->line->file->filename,
			   symbol_get_frag (ptr)->line->line,
			   segment_name (S_GET_SEGMENT (ptr)),
			   buf, S_GET_NAME (ptr));
		}
	      else
		{
		  fprintf (list_file, "%33s:%s %s\n",
			   segment_name (S_GET_SEGMENT (ptr)),
			   buf, S_GET_NAME (ptr));
		}

	      on_page++;
	      listing_page (NULL);
	    }
	}

    }
  if (!got_some)
    {
      fprintf (list_file, "NO DEFINED SYMBOLS\n");
      on_page++;
    }
  emit_line (NULL, "\n");

  got_some = 0;

  for (ptr = symbol_rootP; ptr != (symbolS *) NULL; ptr = symbol_next (ptr))
    {
      if (S_GET_NAME (ptr) && strlen (S_GET_NAME (ptr)) != 0)
	{
	  if (S_GET_SEGMENT (ptr) == undefined_section)
	    {
	      if (!got_some)
		{
		  got_some = 1;

		  emit_line (NULL, "UNDEFINED SYMBOLS\n");
		}

	      emit_line (NULL, "%s\n", S_GET_NAME (ptr));
	    }
	}
    }

  if (!got_some)
    emit_line (NULL, "NO UNDEFINED SYMBOLS\n");
}

typedef struct cached_line
{
  file_info_type * file;
  unsigned int     line;
  char             buffer [LISTING_RHS_WIDTH];
} cached_line;

static void
print_source (file_info_type *  current_file,
	      list_info_type *  list,
	      unsigned int      width)
{
#define NUM_CACHE_LINES  3
  static cached_line cached_lines[NUM_CACHE_LINES];
  static int next_free_line = 0;
  cached_line * cache = NULL;

  if (current_file->linenum > list->hll_line
      && list->hll_line > 0)
    {
      /* This can happen with modern optimizing compilers.  The source
	 lines from the high level language input program are split up
	 and interleaved, meaning the line number we want to display
	 (list->hll_line) can have already been displayed.  We have
	 three choices:

	   a. Do nothing, since we have already displayed the source
	      line.  This was the old behaviour.

	   b. Display the particular line requested again, but only
	      that line.  This is the new behaviour.

	   c. Display the particular line requested again and reset
	      the current_file->line_num value so that we redisplay
	      all the following lines as well the next time we
	      encounter a larger line number.  */
      int i;

      /* Check the cache, maybe we already have the line saved.  */
      for (i = 0; i < NUM_CACHE_LINES; i++)
	if (cached_lines[i].file == current_file
	    && cached_lines[i].line == list->hll_line)
	  {
	    cache = cached_lines + i;
	    break;
	  }

      if (i == NUM_CACHE_LINES)
	{
	  cache = cached_lines + next_free_line;
	  next_free_line ++;
	  if (next_free_line == NUM_CACHE_LINES)
	    next_free_line = 0;

	  cache->file = current_file;
	  cache->line = list->hll_line;
	  cache->buffer[0] = 0;
	  rebuffer_line (current_file, cache->line, cache->buffer, width);
	}

      emit_line (list, "%4u:%-13s **** %s\n",
		 cache->line, cache->file->filename, cache->buffer);
      return;
    }

  if (!current_file->at_end)
    {
      int num_lines_shown = 0;

      while (current_file->linenum < list->hll_line
	     && !current_file->at_end)
	{
	  char *p;

	  cache = cached_lines + next_free_line;
	  cache->file = current_file;
	  cache->line = current_file->linenum + 1;
	  cache->buffer[0] = 0;
	  p = buffer_line (current_file, cache->buffer, width);

	  /* Cache optimization:  If printing a group of lines
	     cache the first and last lines in the group.  */
	  if (num_lines_shown == 0)
	    {
	      next_free_line ++;
	      if (next_free_line == NUM_CACHE_LINES)
		next_free_line = 0;
	    }

	  emit_line (list, "%4u:%-13s **** %s\n",
		     cache->line, cache->file->filename, p);
	  num_lines_shown ++;
	}
    }
}

/* Sometimes the user doesn't want to be bothered by the debugging
   records inserted by the compiler, see if the line is suspicious.  */

static int
debugging_pseudo (list_info_type *list, const char *line)
{
#ifdef OBJ_ELF
  static int in_debug;
  int was_debug;
#endif

  if (list->debugging)
    {
#ifdef OBJ_ELF
      in_debug = 1;
#endif
      return 1;
    }
#ifdef OBJ_ELF
  was_debug = in_debug;
  in_debug = 0;
#endif

  while (ISSPACE (*line))
    line++;

  if (*line != '.')
    {
#ifdef OBJ_ELF
      /* The ELF compiler sometimes emits blank lines after switching
         out of a debugging section.  If the next line drops us back
         into debugging information, then don't print the blank line.
         This is a hack for a particular compiler behaviour, not a
         general case.  */
      if (was_debug
	  && *line == '\0'
	  && list->next != NULL
	  && list->next->debugging)
	{
	  in_debug = 1;
	  return 1;
	}
#endif

      return 0;
    }

  line++;

  if (strncmp (line, "def", 3) == 0)
    return 1;
  if (strncmp (line, "val", 3) == 0)
    return 1;
  if (strncmp (line, "scl", 3) == 0)
    return 1;
  if (strncmp (line, "line", 4) == 0)
    return 1;
  if (strncmp (line, "endef", 5) == 0)
    return 1;
  if (strncmp (line, "ln", 2) == 0)
    return 1;
  if (strncmp (line, "type", 4) == 0)
    return 1;
  if (strncmp (line, "size", 4) == 0)
    return 1;
  if (strncmp (line, "dim", 3) == 0)
    return 1;
  if (strncmp (line, "tag", 3) == 0)
    return 1;
  if (strncmp (line, "stabs", 5) == 0)
    return 1;
  if (strncmp (line, "stabn", 5) == 0)
    return 1;

  return 0;
}

static void
listing_listing (char *name ATTRIBUTE_UNUSED)
{
  list_info_type *list = head;
  file_info_type *current_hll_file = (file_info_type *) NULL;
  char *buffer;
  char *p;
  int show_listing = 1;
  unsigned int width;

  buffer = (char *) xmalloc (listing_rhs_width);
  data_buffer = (char *) xmalloc (MAX_BYTES);
  eject = 1;
  list = head->next;

  while (list)
    {
      unsigned int list_line;

      width = listing_rhs_width > paper_width ? paper_width :
	listing_rhs_width;

      list_line = list->line;
      switch (list->edict)
	{
	case EDICT_LIST:
	  /* Skip all lines up to the current.  */
	  list_line--;
	  break;
	case EDICT_NOLIST:
	  show_listing--;
	  break;
	case EDICT_NOLIST_NEXT:
	  if (show_listing == 0)
	    list_line--;
	  break;
	case EDICT_EJECT:
	  break;
	case EDICT_NONE:
	  break;
	case EDICT_TITLE:
	  title = list->edict_arg;
	  break;
	case EDICT_SBTTL:
	  subtitle = list->edict_arg;
	  break;
	default:
	  abort ();
	}

      if (show_listing <= 0)
	{
	  while (list->file->linenum < list_line
		 && !list->file->at_end)
	    p = buffer_line (list->file, buffer, width);
	}

      if (list->edict == EDICT_LIST
	  || (list->edict == EDICT_NOLIST_NEXT && show_listing == 0))
	{
	  /* Enable listing for the single line that caused the enable.  */
	  list_line++;
	  show_listing++;
	}

      if (show_listing > 0)
	{
	  /* Scan down the list and print all the stuff which can be done
	     with this line (or lines).  */
	  if (list->hll_file)
	    current_hll_file = list->hll_file;

	  if (current_hll_file && list->hll_line && (listing & LISTING_HLL))
	    print_source (current_hll_file, list, width);

	  if (list->line_contents)
	    {
	      if (!((listing & LISTING_NODEBUG)
		    && debugging_pseudo (list, list->line_contents)))
		print_lines (list,
			     list->file->linenum == 0 ? list->line : list->file->linenum,
			     list->line_contents, calc_hex (list));

	      free (list->line_contents);
	      list->line_contents = NULL;
	    }
	  else
	    {
	      while (list->file->linenum < list_line
		     && !list->file->at_end)
		{
		  unsigned int address;

		  p = buffer_line (list->file, buffer, width);

		  if (list->file->linenum < list_line)
		    address = ~(unsigned int) 0;
		  else
		    address = calc_hex (list);

		  if (!((listing & LISTING_NODEBUG)
			&& debugging_pseudo (list, p)))
		    print_lines (list, list->file->linenum, p, address);
		}
	    }

	  if (list->edict == EDICT_EJECT)
	    eject = 1;
	}

      if (list->edict == EDICT_NOLIST_NEXT && show_listing == 1)
	--show_listing;

      list = list->next;
    }

  free (buffer);
  free (data_buffer);
  data_buffer = NULL;
}

/* Print time stamp in ISO format:  yyyy-mm-ddThh:mm:ss.ss+/-zzzz.  */

static void
print_timestamp (void)
{
  const time_t now = time (NULL);
  struct tm * timestamp;
  char stampstr[MAX_DATELEN];

  /* Any portable way to obtain subsecond values???  */
  timestamp = localtime (&now);
  strftime (stampstr, MAX_DATELEN, "%Y-%m-%dT%H:%M:%S.000%z", timestamp);
  fprintf (list_file, _("\n time stamp    \t: %s\n\n"), stampstr);
}

static void
print_single_option (char * opt, int *pos)
{
  int opt_len = strlen (opt);

   if ((*pos + opt_len) < paper_width)
     {
        fprintf (list_file, _("%s "), opt);
        *pos = *pos + opt_len;
     }
   else
     {
        fprintf (list_file, _("\n\t%s "), opt);
        *pos = opt_len;
     }
}

/* Print options passed to as.  */

static void
print_options (char ** argv)
{
  const char *field_name = _("\n options passed\t: ");
  int pos = strlen (field_name);
  char **p;

  fputs (field_name, list_file);
  for (p = &argv[1]; *p != NULL; p++)
    if (**p == '-')
      {
        /* Ignore these.  */
        if (strcmp (*p, "-o") == 0)
          {
            if (p[1] != NULL)
              p++;
            continue;
          }
        if (strcmp (*p, "-v") == 0)
          continue;

        print_single_option (*p, &pos);
      }
}

/* Print a first section with basic info like file names, as version,
   options passed, target, and timestamp.
   The format of this section is as follows:

   AS VERSION

   fieldname TAB ':' fieldcontents
  { TAB fieldcontents-cont }  */

static void
listing_general_info (char ** argv)
{
  /* Print the stuff on the first line.  */
  eject = 1;
  listing_page (NULL);

  fprintf (list_file,
           _(" GNU assembler version %s (%s)\n\t using BFD version %s."),
           VERSION, TARGET_ALIAS, BFD_VERSION_STRING);
  print_options (argv);
  fprintf (list_file, _("\n input file    \t: %s"), fn);
  fprintf (list_file, _("\n output file   \t: %s"), out_file_name);
  fprintf (list_file, _("\n target        \t: %s"), TARGET_CANONICAL);
  print_timestamp ();
}

void
listing_print (char *name, char **argv)
{
  int using_stdout;

  title = "";
  subtitle = "";

  if (name == NULL)
    {
      list_file = stdout;
      using_stdout = 1;
    }
  else
    {
      list_file = fopen (name, FOPEN_WT);
      if (list_file != NULL)
	using_stdout = 0;
      else
	{
	  as_warn (_("can't open %s: %s"), name, xstrerror (errno));
	  list_file = stdout;
	  using_stdout = 1;
	}
    }

  if (listing & LISTING_NOFORM)
    paper_height = 0;

  if (listing & LISTING_GENERAL)
    listing_general_info (argv);

  if (listing & LISTING_LISTING)
    listing_listing (name);

  if (listing & LISTING_SYMBOLS)
    list_symbol_table ();

  if (! using_stdout)
    {
      if (fclose (list_file) == EOF)
	as_warn (_("can't close %s: %s"), name, xstrerror (errno));
    }

  if (last_open_file)
    fclose (last_open_file);
}

void
listing_file (const char *name)
{
  fn = name;
}

void
listing_eject (int ignore ATTRIBUTE_UNUSED)
{
  if (listing)
    listing_tail->edict = EDICT_EJECT;
}

/* Turn listing on or off.  An argument of 0 means to turn off
   listing.  An argument of 1 means to turn on listing.  An argument
   of 2 means to turn off listing, but as of the next line; that is,
   the current line should be listed, but the next line should not.  */

void
listing_list (int on)
{
  if (listing)
    {
      switch (on)
	{
	case 0:
	  if (listing_tail->edict == EDICT_LIST)
	    listing_tail->edict = EDICT_NONE;
	  else
	    listing_tail->edict = EDICT_NOLIST;
	  break;
	case 1:
	  if (listing_tail->edict == EDICT_NOLIST
	      || listing_tail->edict == EDICT_NOLIST_NEXT)
	    listing_tail->edict = EDICT_NONE;
	  else
	    listing_tail->edict = EDICT_LIST;
	  break;
	case 2:
	  listing_tail->edict = EDICT_NOLIST_NEXT;
	  break;
	default:
	  abort ();
	}
    }
}

void
listing_psize (int width_only)
{
  if (! width_only)
    {
      paper_height = get_absolute_expression ();

      if (paper_height < 0 || paper_height > 1000)
	{
	  paper_height = 0;
	  as_warn (_("strange paper height, set to no form"));
	}

      if (*input_line_pointer != ',')
	{
	  demand_empty_rest_of_line ();
	  return;
	}

      ++input_line_pointer;
    }

  paper_width = get_absolute_expression ();

  demand_empty_rest_of_line ();
}

void
listing_nopage (int ignore ATTRIBUTE_UNUSED)
{
  paper_height = 0;
}

void
listing_title (int depth)
{
  int quoted;
  char *start;
  char *ttl;
  unsigned int length;

  SKIP_WHITESPACE ();
  if (*input_line_pointer != '\"')
    quoted = 0;
  else
    {
      quoted = 1;
      ++input_line_pointer;
    }

  start = input_line_pointer;

  while (*input_line_pointer)
    {
      if (quoted
	  ? *input_line_pointer == '\"'
	  : is_end_of_line[(unsigned char) *input_line_pointer])
	{
	  if (listing)
	    {
	      length = input_line_pointer - start;
	      ttl = (char *) xmalloc (length + 1);
	      memcpy (ttl, start, length);
	      ttl[length] = 0;
	      listing_tail->edict = depth ? EDICT_SBTTL : EDICT_TITLE;
	      listing_tail->edict_arg = ttl;
	    }
	  if (quoted)
	    input_line_pointer++;
	  demand_empty_rest_of_line ();
	  return;
	}
      else if (*input_line_pointer == '\n')
	{
	  as_bad (_("new line in title"));
	  demand_empty_rest_of_line ();
	  return;
	}
      else
	{
	  input_line_pointer++;
	}
    }
}

void
listing_source_line (unsigned int line)
{
  if (listing)
    {
      new_frag ();
      listing_tail->hll_line = line;
      new_frag ();
    }
}

void
listing_source_file (const char *file)
{
  if (listing)
    listing_tail->hll_file = file_info (file);
}

#else

/* Dummy functions for when compiled without listing enabled.  */

void
listing_list (int on)
{
  s_ignore (0);
}

void
listing_eject (int ignore)
{
  s_ignore (0);
}

void
listing_psize (int ignore)
{
  s_ignore (0);
}

void
listing_nopage (int ignore)
{
  s_ignore (0);
}

void
listing_title (int depth)
{
  s_ignore (0);
}

void
listing_file (const char *name)
{
}

void
listing_newline (char *name)
{
}

void
listing_source_line (unsigned int n)
{
}

void
listing_source_file (const char *n)
{
}

#endif
@


1.51
log
@2012-07-26  Segher Boessenkool  <segher@@kernel.crashing.org>

gas/
        * listing.c (struct list_message): New.
        (struct list_info_struct): Delete "message".  Add "messages"
        and "last_message".
        (listing_message): Adjust.
        (listing_newline): Adjust.
        (print_lines): Adjust.
@
text
@d556 2
a557 1
   back to its original location.  */
d566 1
a566 1
  unsigned int current_line = 1;
d569 1
d571 1
d574 1
a574 1
  if (file == NULL || buffer == NULL || size == 0 || file->linenum <= linenum)
d602 4
a605 1
  pos = ftell (last_open_file);
d607 3
a609 2
  /* Go back to the beginning.  */
  fseek (last_open_file, 0, SEEK_SET);
d611 7
a617 2
  /* Skip lines prior to the one we are interested in.  */
  while (current_line < linenum)
d619 8
a626 3
      /* fgets only stops on newlines and has a size limit,
	 so we read one character at a time instead.  */
      do
d628 2
a629 1
	  c = fgetc (last_open_file);
a630 1
      while (c != EOF && c != '\n' && c != '\r');
d632 10
a641 1
      ++ current_line;
d643 16
a658 3
      if (c == '\r' || c == '\n')
	{
	  int next = fgetc (last_open_file);
d660 5
a664 5
	  /* If '\r' is followed by '\n', swallow that.  Likewise, if '\n'
	     is followed by '\r', swallow that as well.  */
	  if ((c == '\r' && next != '\n')
	      || (c == '\n' && next != '\r'))
	    ungetc (next, last_open_file);
a667 3
  /* Leave room for the nul at the end of the buffer.  */
  size -= 1;

@


1.50
log
@ChangeLog binutils/
2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* debug.c (debug_start_source): Use filename_(n)cmp.
	* ieee.c (ieee_finish_compilation_unit): Likewise.
	(ieee_lineno): Likewise.
	* nlmconv.c (main): Likewise.
	* objcopy.c (strip_main): Likewise.
	(copy_main): Likewise.
	* objdump.c (show_line): Likewise.
	(dump_reloc_set): Likewise.
	* srconv.c (main): Likewise.
	* wrstabs.c (stab_lineno): Likewise.

ChangeLog gas/
2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* depend.c (register_dependency): Use filename_(n)cmp.
	* dwarf2dbg.c (get_filenum): Likewise.
	* ecoff.c (add_file): Likewise.
	(ecoff_generate_asm_lineno): Likewise.
	* input-scrub.c (new_logical_line_flags): Likewise.
	* listing.c (file_info): Likewise.
	(listing_newline): Likewise.
	* remap.c (remap_debug_filename): Likewise.
	* stabs.c (generate_asm_file): Likewise.
	(stabs_generate_asm_lineno): Likewise.
@
text
@d146 6
d179 2
a180 2
  /* Pointer to any error message associated with this line.  */
  char *message;
d241 1
d244 8
a251 1
      listing_tail->message = n;
d421 2
a422 1
  new_i->message = (char *) NULL;
d810 1
d858 2
a859 2
  if (list->message)
    emit_line (list, "****  %s\n", list->message);
@


1.49
log
@	* config/obj-evax.h (S_SET_OTHER, S_SET_TYPE, S_SET_DESC): Don't define.
	* config/tc-crx.c (gettrap): Constify arg.
	(handle_LoadStor, get_cinv_parameters): Likewise.
	(getreg_image): Fix enum warning
	(md_assemble): Restore input line char.
	* config/tc-hppa.c (tc_gen_reloc): Fix enum warning.
	* config/tc-i960.c (mem_fmt): Rename var to fix shadow warning.
	* config/tc-sh.c (sh_fdpic): Only define when OBJ_ELF.
	(build_Mytes): Fix build failure for non-elf targets.
	* config/tc-tic4x.c (tic4x_eval): Restore terminator char.
	* config/tc-xtensa.c (xtensa_end_directive): Fix switch enum warning.

	* cgen.c (gas_cgen_md_apply_fix): Avoid set but unused warning.
	* ecoff.c (add_ecoff_symbol): Likewise.
	* itbl-ops.c (append_insns_as_macros): Likewise.
	* listing.c (debugging_pseudo): Likewise.
	* read.c (s_mri_common, stringer): Likewise.
	* config/obj-coff.c (coff_frob_section): Likewise.
	* config/tc-alpha.c (emit_ldgp, s_alpha_proc): Likewise.
	* config/tc-arm.c (my_get_expression): Likewise.
	* config/tc-hppa.c (process_exit, pa_type_args): Likewise.
	* config/tc-m32c.c (md_assemble): Likewise.
	* config/tc-microblaze.c (md_convert_frag): Likewise.
	* config/tc-mips.c (s_change_section): Likewise.
	* config/tc-mt.c (mt_fix_adjustable): Likewise.
	* config/tc-xtensa.c (xtensa_literal_pseudo): Likewise.

	* config/obj-aout.c (obj_aout_frob_symbol): Delete set but otherwise
	unused vars.
	* config/tc-alpha.c (load_expression): Likewise.
	(s_alpha_rdata, s_alpha_section, s_alpha_prologue): Likewise.
	* config/tc-arm.c (parse_neon_el_struct_list): Likewise.
	* config/tc-avr.c (extract_word): Likewise.
	* config/tc-cris.c (cris_get_expression): Likewise.
	* config/tc-d30v.c (build_insn, find_format): Likewise.
	* config/tc-dlx.c (machine_ip): Likewise.
	* config/tc-hppa.c (pa_get_absolute_expression): Likewise.
	* config/tc-i370.c (md_assemble): Likewise.
	* config/tc-i960.c (brtab_emit): Likewise.
	* config/tc-iq2000.c (s_iq2000_ent): Likewise.
	* config/tc-m32c.c (md_convert_frag): Likewise.
	* config/tc-m68hc11.c (fixup24, build_jump_insn): Likewise.
	(md_estimate_size_before_relax, md_apply_fix): Likewise.
	* config/tc-m68k.c (md_show_usage): Likewise.
	* config/tc-microblaze.c (microblaze_s_lcomm): Likewise.
	* config/tc-mips.c (s_mips_end): Likewise.
	* config/tc-mmix.c (mmix_byte, mmix_cons): Likewise.
	* config/tc-mn10300.c (md_assemble): Likewise.
	* config/tc-msp430.c (extract_word): Likewise.
	* config/tc-mt.c (md_assemble): Likewise.
	* config/tc-or32.c (machine_ip): Likewise.
	* config/tc-pj.c (md_apply_fix): Likewise.
	* config/tc-s390.c (md_gather_operands): Likewise.
	* config/tc-sh.c (sh_cons_align): Likewise.
	* config/tc-sparc.c (sparc_cons_align): Likewise.
	* config/tc-tic4x.c (tic4x_sect): Likewise.
	* config/tc-tic54x.c (tic54x_stringer): Likewise.
	* config/tc-vax.c (vip_op): Likewise.
	* config/tc-xstormy16.c (xstormy16_cons_fix_new): Likewise.
	* config/tc-xtensa.c (md_assemble): Likewise.
	(xtensa_fix_short_loop_frags, convert_frag_immed): Likewise.
	(xtensa_move_literals): Likewise.
@
text
@d93 1
d261 1
a261 1
      if (strcmp (p->filename, file_name) == 0)
d322 1
a322 1
	  && !(last_file && file && strcmp (file, last_file)))
@


1.48
log
@bfd/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * aoutx.h (aout_link_input_bfd): Remove unused variable sym_count.
        * elf-eh-frame.c (_bfd_elf_eh_frame_section_offset): Remove unused
        variables htab and hdr_info and mark info parameter as unused.
        * elf.c (prep_headers): Remove unused variable i_phdrp.
        (_bfd_elf_write_object_contents): Remove unused variable i_ehdrp.
        * elf32-i386.c (elf_i386_relocate_section): Mark variabled warned
        as unused.
        * peXXigen.c (pe_print_reloc): Remove unused variable datasize.
        * verilog.c (verilog_write_section): Remove unused variable
        address.

binutils/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * dwarf.c (process_debug_info): Remove unused variable
        cu_abbrev_offset_ptr.
        (display_debug_lines_decoded): Remove unused variable prev_line.
        * elfedit.c (process_archive): Remove unused variable
        file_name_size.
        * ieee.c (ieee_start_compilation_unit): Remove unused variable
        nindx.
        (ieee_set_type): Remove unused variables info, targetindx and
        baseindx.
        * objdump.c (disassmble_byte): Remove unused variable done_dot.
        * rddbg.c (read_section_stabs_debugging_info): Remove unused
        variable other.
        * readelf.c (dump_section_as_strings): Remove unused variable
        addr.
        (process_archive): Remove unused variable file_name_size.
        * stabs.c (parse_stab_string): Mark desc parameter as unused.
        Remove unused variable lineno.
        (parse_stab_struct_type): Remove unused variable orig.
        (stab_demangle_type): Remove unused variables constp, volatilep
        and hold.

gas/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * as.c (create_obj_attrs_section): Remove unused variable addr.
        * listing.c (listing_listing): Remove unused variable message.
        * read.c: Remove unnecessary register type qualifiers.
        (s_mri): Only define/use old_flag variable if MRI_MODE_CHANGE is
        defined.

ld/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * ldlang.c (wild_sort): Remove unused variable section_name.

opcodes/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * i386-dis.c (print_insn): Remove unused variable op.
        (OP_sI): Remove unused variable mask.
@
text
@d1078 1
d1081 1
d1085 1
d1087 1
d1090 1
a1090 1

d1093 1
@


1.47
log
@	PR gas/11356
	* listing.c (listing_newline): Correct backslash quote logic.
@
text
@a1148 1
  char *message;
a1212 2
	  message = 0;

@


1.46
log
@	PR 11122
	* listing.c (print_source): Add one to line number.
@
text
@d350 6
a355 4
	      if (*copy == '\\')
		seen_slash = ! seen_slash;
	      else if (*copy == '"' && seen_slash)
		seen_quote = ! seen_quote;
@


1.45
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2005, 2006, 2007, 2008, 2009
d1050 1
a1050 1
	  cache->line = current_file->linenum;
@


1.44
log
@	PR gas/10850
	* listing.c (listing_flags): Delete.
	* listing.h: Likewise.
	* read.c (potable <lflags>): Call s_ignore.
@
text
@a1045 1
	  cached_line * cache = cached_lines + next_free_line;
d1048 1
@


1.43
log
@	PR gas/1491
gas/
	* macro.c: Delete unnecessary function declarations.
	(buffer_and_nest): Support multiple labels per line for
	LABELS_WITHOUT_COLONS targets if the labels do have colons.
	(free_macro): Move so that we don't need forward declaration.
	* read.c (read_a_source_file): Take a copy of macro expansion line
	before we trim labels.
	* listing.c (listing_newline): Adjust stdin line save for
	input_line_pointer still at start of line.
gas/testsuite/
	* gas/macros/dot.s: Don't start macro invocations is first column.
	* gas/macros/dot.l: Update.
	* gas/macros/macros.exp: Run dot test on more targets.
@
text
@a1411 8
void
listing_flags (int ignore ATTRIBUTE_UNUSED)
{
  while ((*input_line_pointer++) && (*input_line_pointer != '\n'))
    input_line_pointer++;

}

a1553 6
listing_flags (int ignore)
{
  s_ignore (0);
}

void
@


1.42
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        * as.c (main): Call dwarf2_init.
        * config/obj-elf.c (struct group_list): New field.
        (build_group_lists): Use hash lookup.
        (free_section_idx): New function.
        (elf_frob_file): Adjust.
        * dwarf2dbg.c (all_segs_hash, last_seg_ptr): New variables.
        (get_line_subseg): Adjust.
        (dwarf2_init): New function.
        * dwarf2dbg.h (dwarf2_init): New declaration.
@
text
@d345 1
a345 1
	  for (copy = input_line_pointer - 1;
d356 1
a356 1
	  len = (copy - input_line_pointer) + 2;
d362 1
a362 1
	      char *src = input_line_pointer - 1;
@


1.41
log
@update copyright dates
@
text
@d133 12
d175 1
a175 10
  enum
    {
      EDICT_NONE,
      EDICT_SBTTL,
      EDICT_TITLE,
      EDICT_NOLIST,
      EDICT_LIST,
      EDICT_NOLIST_NEXT,
      EDICT_EJECT
    } edict;
d266 1
a266 1
  p = xmalloc (sizeof (file_info_type));
d358 1
a358 1
	  copy = xmalloc (len);
d1153 2
a1154 2
  buffer = xmalloc (listing_rhs_width);
  data_buffer = xmalloc (MAX_BYTES);
d1515 1
a1515 1
	      ttl = xmalloc (length + 1);
@


1.41.2.1
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.
@
text
@a132 12
enum edict_enum
{
  EDICT_NONE,
  EDICT_SBTTL,
  EDICT_TITLE,
  EDICT_NOLIST,
  EDICT_LIST,
  EDICT_NOLIST_NEXT,
  EDICT_EJECT
};


d163 10
a172 1
  enum edict_enum edict;
d263 1
a263 1
  p = (file_info_type *) xmalloc (sizeof (file_info_type));
d355 1
a355 1
	  copy = (char *) xmalloc (len);
d1150 2
a1151 2
  buffer = (char *) xmalloc (listing_rhs_width);
  data_buffer = (char *) xmalloc (MAX_BYTES);
d1512 1
a1512 1
	      ttl = (char *) xmalloc (length + 1);
@


1.41.2.2
log
@	PR 11122
	* listing.c (print_source): Add one to line number.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2005, 2006, 2007, 2008, 2009, 2010
d1050 1
a1050 1
	  cache->line = current_file->linenum + 1;
@


1.40
log
@        Updated sources to avoid using the identifier name "new", which is a
        keyword in c++.

        * bfd/aoutx.h (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol.
        * bfd/coffgen.c (coff_make_empty_symbol)
        (coff_bfd_make_debug_symbol): Rename variable new to new_symbol.
        * bfd/cpu-ia64-opc.c (ext_reg, ins_imms_scaled): Rename variable
        new to new_insn.
        * bfd/doc/chew.c (newentry, add_intrinsic): Rename variable new to
        new_d.
        * bfd/ecoff.c (_bfd_ecoff_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/elf32-m68k.c (elf_m68k_get_got_entry_type): Rename argument
        new to new_reloc.
        * bfd/hash.c (bfd_hash_lookup): Rename variable new to new_string.
        * bfd/ieee.c (ieee_make_empty_symbol): Rename variable new to
        new_symbol.
        * bfd/linker.c (bfd_new_link_order): Rename variable new to
        new_lo.
        * bfd/mach-o.c (bfd_mach_o_sizeof_headers): Rename variable new to
        symbol.
        * bfd/oasys.c (oasys_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/pdp11.c (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol_type.
        * bfd/plugin.c (bfd_plugin_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/rs6000-core.c (CoreHdr, VmInfo): Rename union member new to
        new_dump.
        (read_hdr, rs6000coff_core_p)
        (rs6000coff_core_file_matches_executable_p)
        (rs6000coff_core_file_failing_command)
        (rs6000coff_core_file_failing_signal): Updated function to use new
        union member name.
        * bfd/som.c (som_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/syms.c (_bfd_generic_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/tekhex.c (first_phase, tekhex_make_empty_symbol): Rename
        variable new to new_symbol.
        * binutils/nlmconv.c (main): Rename variable new to new_name.
        * gas/config/tc-arm.c (insert_reg_alias): Rename variable new to
        new_reg.
        * gas/config/tc-dlx.c (parse_operand): Rename variable new to
        new_pos.
        * gas/config/tc-ia64.c (ia64_gen_real_reloc_type): Rename variable
        new to newr.
        * gas/config/tc-mcore.c (parse_exp, parse_imm): Rename variable
        new to new_pointer.
        * gas/config/tc-microblaze.c (parse_exp, parse_imm, check_got):
        Change name from new to new_pointer.
        * gas/config/tc-or32.c (parse_operand): Rename variable new to
        new_pointer.
        * gas/config/tc-pdp11.c (md_assemble): Rename variable new to
        new_pointer.
        * gas/config/tc-pj.c (alias): Change argument new to new_name.
        * gas/config/tc-score.c (s3_build_score_ops_hsh): Rename variable
        new to new_opcode. (s3_build_dependency_insn_hsh) Rename variable
        new to new_i2n. (s3_convert): Rename variables old and new to
        r_old and r_new.
        * gas/config/tc-score7.c (s7_build_score_ops_hsh): Rename variable
        new to new_opcode. (s7_build_dependency_insn_hsh): Rename variable
        new to new_i2d. (s7_b32_relax_to_b16, s7_convert_frag): Rename
        variables old and new to r_old and r_new.
        * gas/config/tc-sh.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-sh64.c (shmedia_parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-tic4x.c (tic4x_operand_parse): Rename variable new
        to new_pointer.
        * gas/config/tc-z8k.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/listing.c (listing_newline): Rename variable new to new_i.
        * ld/ldexp.c (exp_intop, exp_bigintop, exp_relop, exp_binop)
        (exp_trinop, exp_unop, exp_nameop, exp_assop): Rename variable new
        to new_e.
        * ld/ldfile.c (ldfile_add_library_path): Rename variable new to
        new_dirs. (ldfile_add_arch): Rename variable new to new_arch.
        * ld/ldlang.c (new_statement, lang_final, lang_add_wild)
        (lang_target, lang_add_fill, lang_add_data, lang_add_assignment)
        (lang_add_insert): Rename variable new to new_stmt. (new_afile):
        Added missing cast. (lang_memory_region_lookup): Rename variable
        new to new_region. (init_os): Rename variable new to
        new_userdata. (lang_add_section): Rename variable new to
        new_section. (ldlang_add_undef): Rename variable new to
        new_undef. (realsymbol): Rename variable new to new_name.
        * opcodes/z8kgen.c (internal, gas): Rename variable new to new_op.

        Updated sources to avoid using the identifier name "template",
        which is a keyword in c++.

        * bfd/elf32-arm.c (struct stub_def): Rename member template to
        template_sequence. (arm_build_one_stub,
        find_stub_size_and_template, arm_size_one_stub, arm_map_one_stub):
        Rename variable template to template_sequence.
        * bfd/elfxx-ia64.c (elfNN_ia64_relax_br, elfNN_ia64_relax_brl):
        Rename variable template to template_val.
        * gas/config/tc-arm.c (struct asm_cond, struct asm_psr, struct
        asm_barrier_opt): Change member template to
        template_name. (md_begin): Update code to reflect new member
        names.
        * gas/config/tc-i386.c (struct templates, struct _i386_insn)
        (match_template, cpu_flags_match, match_reg_size, match_mem_size)
        (operand_size_match, md_begin, i386_print_statistics, pi)
        (build_vex_prefix, md_assemble, parse_insn, optimize_imm)
        (optimize_disp): Updated code to use new names. (parse_insn):
        Added casts.
        * gas/config/tc-ia64.c (dot_template, emit_one_bundle): Updated
        code to use new names.
        * gas/config/tc-score.c (struct s3_asm_opcode): Renamed member
        template to template_name. (s3_parse_16_32_inst, s3_parse_48_inst,
        s3_do_macro_ldst_label, s3_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-score7.c (struct s7_asm_opcode): Renamed member
        template to template_name. (s7_parse_16_32_inst,
        s7_do_macro_ldst_label, s7_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-tic30.c (md_begin, struct tic30_insn)
        (md_assemble): Update code to use new names.
        * gas/config/tc-tic54x.c (struct _tic54x_insn, md_begin)
        (optimize_insn, tic54x_parse_insn, next_line_shows_parallel):
        Update code to use new names.
        * include/opcode/tic30.h (template): Rename type template to
        insn_template. Updated code to use new name.
        * include/opcode/tic54x.h (template): Rename type template to
        insn_template.
        * opcodes/cris-dis.c (bytes_to_skip): Update code to use new name.
        * opcodes/i386-dis.c (putop): Update code to use new name.
        * opcodes/i386-gen.c (process_i386_opcodes): Update code to use
        new name.
        * opcodes/i386-opc.h (struct template): Rename struct template to
        insn_template. Update code accordingly.
        * opcodes/i386-tbl.h (i386_optab): Update type to use new name.
        * opcodes/ia64-dis.c (print_insn_ia64): Rename variable template
        to template_val.
        * opcodes/tic30-dis.c (struct instruction, get_tic30_instruction):
        Update code to use new name.
        * opcodes/tic54x-dis.c (has_lkaddr, get_insn_size)
        (print_parallel_instruction, print_insn_tic54x, tic54x_get_insn):
        Update code to use new name.
        * opcodes/tic54x-opc.c (tic54x_unknown_opcode, tic54x_optab):
        Update type to new name.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2005, 2006, 2007, 2008
@


1.39
log
@2009-07-15  Kai Tietz  <kai.tietz@@onevision.com>

	* listing.c (print_source): Initialize cache by NULL.
@
text
@d288 1
a288 1
  list_info_type *new = NULL;
d321 1
a321 1
      new = (list_info_type *) xmalloc (sizeof (list_info_type));
d374 1
a374 1
	  new->line_contents = copy;
d377 1
a377 1
	new->line_contents = NULL;
d381 2
a382 2
      new = xmalloc (sizeof (list_info_type));
      new->line_contents = ps;
d391 1
a391 1
    listing_tail->next = new;
d393 1
a393 1
    head = new;
d395 1
a395 1
  listing_tail = new;
d397 9
a405 9
  new->frag = frag_now;
  new->line = line;
  new->file = file_info (file);
  new->next = (list_info_type *) NULL;
  new->message = (char *) NULL;
  new->edict = EDICT_NONE;
  new->hll_file = (file_info_type *) NULL;
  new->hll_line = 0;
  new->debugging = 0;
d419 1
a419 1
	new->debugging = 1;
@


1.38
log
@    gas/
    * config/tc-arm.c (md_assemble): Added validation.

    gas/testsuite
    * gas/arm/thumb-w-bad.d: New test case.
    * gas/arm/thumb-w-bad.l: New file.
    * gas/arm/thumb-w-bad.s: New file.
    * gas/arm/thumb-w-good.d: New test case.
    * gas/arm/thumb-w-good.s: New file.
@
text
@d986 1
a986 1
  cached_line * cache;
@


1.37
log
@2009-03-23  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/9966
	* listing.c (listing_newline): Properly handle `\\"' and ';'.

	* read.c (is_end_of_line): Update comments for line separator.
	(read_begin): Set line separator in is_end_of_line to 2.
@
text
@d99 1
a216 1
static char *buffer_line (file_info_type *, char *, unsigned int);
a220 1
static void print_source (file_info_type *, list_info_type *, char *, unsigned int);
d455 1
a455 1
   file to make.  */
a461 1

a491 2
  c = fgetc (last_open_file);

d495 2
a503 1

d511 1
d532 111
d694 17
d801 1
a801 6
      fprintf (list_file, "\t%s\n", string ? string : "");

      on_page++;

      listing_page (0);

d834 1
a834 3
  fprintf (list_file, "\t%s\n", string ? string : "");
  on_page++;
  listing_page (list);
d837 1
a837 5
    {
      fprintf (list_file, "****  %s\n", list->message);
      listing_page (list);
      on_page++;
    }
d867 1
a867 3
      fprintf (list_file, "\n");
      on_page++;
      listing_page (list);
d879 1
a879 1
  listing_page (0);
d935 1
a935 1
	      listing_page (0);
d945 1
a945 3
  fprintf (list_file, "\n");
  on_page++;
  listing_page (0);
d958 2
a959 3
		  fprintf (list_file, "UNDEFINED SYMBOLS\n");
		  on_page++;
		  listing_page (0);
d961 2
a962 3
	      fprintf (list_file, "%s\n", S_GET_NAME (ptr));
	      on_page++;
	      listing_page (0);
d966 1
d968 1
a968 5
    {
      fprintf (list_file, "NO UNDEFINED SYMBOLS\n");
      on_page++;
      listing_page (0);
    }
d971 7
d979 57
a1035 3
print_source (file_info_type *current_file, list_info_type *list,
	      char *buffer, unsigned int width)
{
d1038 2
d1043 16
a1058 1
	  char *p = buffer_line (current_file, buffer, width);
d1060 3
a1062 4
	  fprintf (list_file, "%4u:%-13s **** %s\n", current_file->linenum,
		   current_file->filename, p);
	  on_page++;
	  listing_page (list);
d1215 1
a1215 1
	    print_source (current_hll_file, list, buffer, width);
d1336 1
a1336 1
  listing_page (0);
@


1.36
log
@	* listing.c (buffer_line): Open the source file with FOPEN_RB.
	Manually process line ends.
@
text
@d341 1
d345 1
a345 1
			 || (! is_end_of_line [(unsigned char) *copy]));
d347 6
a352 2
	    if (*copy == '"' && copy[-1] != '\\')
	      seen_quote = ! seen_quote;
@


1.35
log
@	PR 6913
	* listing.c (print_options): Don't call fprintf without format string.
@
text
@d474 2
d477 1
a477 1
      last_open_file = fopen (file->filename, FOPEN_RT);
d494 1
a494 1
  while (c != EOF && c != '\n')
d503 11
@


1.34
log
@        * listing.c (print_timestamp): Use localtime rather than
        localtime_r since not all build environments provide the latter.
@
text
@d1103 1
a1103 1
  fprintf (list_file, field_name);
@


1.34.2.1
log
@	PR 6913
	* listing.c (print_options): Don't call fprintf without format string.
@
text
@d1103 1
a1103 1
  fputs (field_name, list_file);
@


1.33
log
@        * listing.c: Add -ag listing flag to show general information in
        listings such as gas version, passed options, and time stamp.
        (listing_general_info): New function.
        (print_options): New function.
        (print_single_option): New function.
        (print_timestamp): New function.
        (MAX_DATELEN): Define.
        (listing_print): Add call to listing_general_info.
        * listing.h (LISTING_GENERAL): Define.
        (listing_print): Add new parameter.
        * as.c (show_usage): Print new switch.
        (parse_args): Parse new switch.
        (main): Pass command line on to listing_print.
        * NEWS: Mention this new feature.
        * doc/as.texinfo: Document the new sub-option.

        * gas/all/gas.exp: Check the performance of the -ag command line
        switch.
@
text
@d1068 1
a1068 1
  struct tm timestamp;
d1072 2
a1073 2
  localtime_r (&now, &timestamp);
  strftime (stampstr, MAX_DATELEN, "%Y-%m-%dT%H:%M:%S.000%z", &timestamp);
@


1.32
log
@Switch to GPLv3
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2005, 2006, 2007
d97 2
d120 1
d1062 85
d1148 1
a1148 1
listing_print (char *name)
d1176 3
@


1.31
log
@	* as.h (as_perror): Delete declaration.
	* gdbinit.in (as_perror): Delete breakpoint.
	* messages.c (as_perror): Delete function.
	* doc/internals.texi: Remove as_perror description.
	* listing.c (listing_print: Don't use as_perror.
	* output-file.c (output_file_create, output_file_close): Likewise.
	* symbols.c (symbol_create, symbol_clone): Likewise.
	* write.c (write_contents): Likewise.
	* config/obj-som.c (obj_som_version, obj_som_copyright): Likewise.
	* config/tc-tic54x.c (tic54x_mlib): Likewise.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2005, 2006
d10 1
a10 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.30
log
@	* listing.c (listing_listing): Remove useless loop.
	* macro.c (macro_expand): Remove is_positional local variable.
	* read.c (s_comm_internal): Simplify `if' condition 1 || x -> 1
	and simplify surrounding expressions, where possible.
	(assign_symbol): Likewise.
	(s_weakref): Likewise.
	* symbols.c (colon): Likewise.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2005
d1079 1
a1079 2
	  bfd_set_error (bfd_error_system_call);
	  as_perror (_("can't open list file: %s"), name);
d1097 1
a1097 4
	{
	  bfd_set_error (bfd_error_system_call);
	  as_perror (_("error closing list file: %s"), name);
	}
@


1.29
log
@	* README-vms: Delete.
	* config-gas.com: Delete.
	* makefile.vms: Delete.
	* vmsconf.sh: Delete.
	* config/atof-tahoe.c: Delete.
	* config/m88k-opcode.h: Delete.
	* config/obj-bout.c: Delete.
	* config/obj-bout.h: Delete.
	* config/obj-hp300.c: Delete.
	* config/obj-hp300.h: Delete.
	* config/tc-a29k.c: Delete.
	* config/tc-a29k.h: Delete.
	* config/tc-h8500.c: Delete.
	* config/tc-h8500.h: Delete.
	* config/tc-m88k.c: Delete.
	* config/tc-m88k.h: Delete.
	* config/tc-tahoe.c: Delete.
	* config/tc-tahoe.h: Delete.
	* config/tc-tic80.c: Delete.
	* config/tc-tic80.h: Delete.
	* config/tc-w65.c: Delete.
	* config/tc-w65.h: Delete.
	* config/te-aux.h: Delete.
	* config/te-delt88.h: Delete.
	* config/te-delta.h: Delete.
	* config/te-dpx2.h: Delete.
	* config/te-hp300.h: Delete.
	* config/te-ic960.h: Delete.
	* config/vms-a-conf.h: Delete.
	* doc/c-a29k.texi: Delete.
	* doc/c-h8500.texi: Delete.
	* doc/c-m88k.texi: Delete.
	* README: Remove obsolete examples, and list of supported targets.
	* Makefile.am: Remove a29k, h8500, m88k, tahoe, tic80, w65,
	bout and hp300 support.
	(DEP_FLAGS): Don't define BFD_ASSEMBLER.
	* configure.in: Remove --enable-bfd-assembler, need_bfd,
	primary_bfd_gas.
	* configure.tgt: Remove a29k, h8300-coff, h8500-*, i960 non-elf,
	m68k non bfd, m88k, or32-coff, tic80-*, vax non-bfd, w65k-*, *-nindy.
	* as.c: Remove all non-BFD_ASSEMBLER code, support for above targets.
	* as.h: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
	* input-file.c: Likewise.
	* listing.c: Likewise.
	* literal.c: Likewise.
	* messages.c: Likewise.
	* obj.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* stabs.c: Likewise.
	* struc-symbol.h: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* symbols.c: Likewise.
	* symbols.h: Likewise.
	* tc.h: Likewise.
	* write.c: Likewise.
	* write.h: Likewise.
	* config/aout_gnu.h: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-aout.h: Likewise.
	* config/obj-coff.c: Likewise.
	* config/obj-coff.h: Likewise.
	* config/obj-evax.h: Likewise.
	* config/obj-ieee.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-crx.h: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-d30v.h: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-fr30.h: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-hppa.h: Likewise.
	* config/tc-i370.h: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i860.h: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ip2k.h: Likewise.
	* config/tc-iq2000.h: Likewise.
	* config/tc-m32c.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m68k.h: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-maxq.h: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mn10200.h: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-mn10300.h: Likewise.
	* config/tc-ms1.h: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-msp430.h: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-ns32k.h: Likewise.
	* config/tc-openrisc.h: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.h: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic4x.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-vax.h: Likewise.
	* config/tc-xstormy16.h: Likewise.
	* config/tc-xtensa.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-z8k.h: Likewise.
	* config/vms-a-conf.h
	* doc/Makefile.am: Likewise.
	* doc/all.texi: Likewise.
	* doc/as.texinfo: Likewise.
	* doc/Makefile.in: Regenerate.
	* Makefile.in: Regenerate.
	* configure: Regenerate.
	* config.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@a948 9
  list = head;

  while (list != (list_info_type *) NULL && 0)
    {
      if (list->next)
	list->frag = list->next->frag;
      list = list->next;
    }

@


1.28
log
@Update the address and phone number of the FSF
@
text
@a751 1
#ifdef BFD_ASSEMBLER
d755 1
a755 1
#endif
d1088 1
a1088 3
#ifdef BFD_ASSEMBLER
      bfd_set_error (bfd_error_system_call);
#endif
a1107 1
#ifdef BFD_ASSEMBLER
a1108 1
#endif
@


1.27
log
@update copyright dates
@
text
@d20 2
a21 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.26
log
@	* as.h: Remove #if 0'd code.
	* atof-generic.c (atof_generic): Likewise.
	* ecoff.c (ecoff_directive_frame): Likewise.
	* frags.h (FRAG_APPEND_1_CHAR): Likewise.
	* itbl-ops.c (itbl_add_reg): Likewise.
	* listing.c (calc_hex): Likewise.
	* read.c (MASK_CHAR): Likewise.
	* subsegs.c (subsegs_print_statistics): Likewise.
	* symbols.c (indent): Likewise.
	* write.c (write_relocs): Likewise.
	(write_object_file): Likewise.
	(relax_frag): Likewise.
@
text
@d3 1
a3 1
   2001, 2002, 2003
@


1.25
log
@Fix calls to as_perror() so that the errno system message will be printed.
Fix as_perror() so that errno is not corrupted.
@
text
@a615 4
#if 0
	      data_buffer[data_buffer_size++] = '*';
	      data_buffer[data_buffer_size++] = '*';
#endif
@


1.24
log
@	* listing.c: Convert to ISO-C.
	* listing.h: Likewise.
	* macro.c: Likewise.
	* macro.h: Likewise.
@
text
@d3 1
a3 1
   2001, 2002
d6 1
a6 1
This file is part of GAS, the GNU Assembler.
d8 14
a21 14
GAS is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

GAS is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with GAS; see the file COPYING.  If not, write to the Free
Software Foundation, 59 Temple Place - Suite 330, Boston, MA
02111-1307, USA.  */
d23 1
a23 2
/*
 Contributed by Steve Chamberlain <sac@@cygnus.com>
d90 1
a90 2
                        on a line
*/
d120 2
a121 1
typedef struct file_info_struct {
d131 2
a132 1
struct list_info_struct {
d138 1
d152 1
d159 10
a168 9
  enum {
    EDICT_NONE,
    EDICT_SBTTL,
    EDICT_TITLE,
    EDICT_NOLIST,
    EDICT_LIST,
    EDICT_NOLIST_NEXT,
    EDICT_EJECT
  } edict;
d210 2
a211 2
static void listing_message (const char *name, const char *message);
static file_info_type *file_info (const char *file_name);
d213 4
a216 5
static char *buffer_line (file_info_type *file, char *line, unsigned int size);
static void listing_page (list_info_type *list);
static unsigned int calc_hex (list_info_type *list);
static void print_lines (list_info_type *, unsigned int,
			 char *, unsigned int);
d218 1
a218 2
static void print_source (file_info_type *current_file, list_info_type *list,
			  char *buffer, unsigned int width);
d220 1
a220 1
static void listing_listing (char *name);
d261 1
a261 2

  p = (file_info_type *) xmalloc (sizeof (file_info_type));
a274 1

a276 1

d374 1
a374 1
      new = (list_info_type *) xmalloc (sizeof (list_info_type));
d592 1
a592 3
	    {
	      address = frag_ptr->fr_address / OCTETS_PER_BYTE;
	    }
d611 2
a612 3
		{
		  address = frag_ptr->fr_address / OCTETS_PER_BYTE;
		}
d859 1
a931 1

a960 1

d1022 1
a1022 3
	    {
	      current_hll_file = list->hll_file;
	    }
d1025 1
a1025 3
	    {
	      print_source (current_hll_file, list, buffer, width);
	    }
d1031 4
a1034 5
		{
		  print_lines (list,
			       list->file->linenum == 0 ? list->line : list->file->linenum,
			       list->line_contents, calc_hex (list));
		}
d1059 1
a1059 3
	    {
	      eject = 1;
	    }
d1093 3
d1103 1
a1103 3
    {
      paper_height = 0;
    }
d1106 1
a1106 3
    {
      listing_listing (name);
    }
d1109 1
a1109 3
    {
      list_symbol_table ();
    }
d1114 6
a1119 1
	as_perror (_("error closing list file: %s"), name);
d1123 1
a1123 3
    {
      fclose (last_open_file);
    }
a1326 1

a1331 1

a1336 1

a1341 1

@


1.23
log
@	* README-vms: Fix comment typos.
	* as.h: Likewise.
	* dwarf2dbg.c: Likewise.
	* ecoff.c: Likewise.
	* hash.c: Likewise.
	* listing.c: Likewise.
	* write.c: Likewise.
@
text
@d207 13
a219 16
static void listing_message PARAMS ((const char *name, const char *message));
static file_info_type *file_info PARAMS ((const char *file_name));
static void new_frag PARAMS ((void));
static char *buffer_line PARAMS ((file_info_type *file,
				  char *line, unsigned int size));
static void listing_page PARAMS ((list_info_type *list));
static unsigned int calc_hex PARAMS ((list_info_type *list));
static void print_lines PARAMS ((list_info_type *, unsigned int,
				 char *, unsigned int));
static void list_symbol_table PARAMS ((void));
static void print_source PARAMS ((file_info_type *current_file,
				  list_info_type *list,
				  char *buffer,
				  unsigned int width));
static int debugging_pseudo PARAMS ((list_info_type *, const char *));
static void listing_listing PARAMS ((char *name));
d222 1
a222 3
listing_message (name, message)
     const char *name;
     const char *message;
d235 1
a235 2
listing_warning (message)
     const char *message;
d241 1
a241 2
listing_error (message)
     const char *message;
d247 1
a247 2
file_info (file_name)
     const char *file_name;
d273 1
a273 1
new_frag ()
d282 1
a282 2
listing_newline (ps)
     char *ps;
d426 1
a426 1
listing_prev_line ()
d453 1
a453 4
buffer_line (file, line, size)
     file_info_type *file;
     char *line;
     unsigned int size;
d524 1
a524 2
listing_page (list)
     list_info_type *list;
d567 1
a567 2
calc_hex (list)
     list_info_type *list;
d642 2
a643 5
print_lines (list, lineno, string, address)
     list_info_type *list;
     unsigned int lineno;
     char *string;
     unsigned int address;
d747 1
a747 1
list_symbol_table ()
d855 2
a856 5
print_source (current_file, list, buffer, width)
     file_info_type *current_file;
     list_info_type *list;
     char *buffer;
     unsigned int width;
d876 1
a876 3
debugging_pseudo (list, line)
     list_info_type *list;
     const char *line;
d946 1
a946 2
listing_listing (name)
     char *name ATTRIBUTE_UNUSED;
d1087 1
a1087 2
listing_print (name)
     char *name;
d1140 1
a1140 2
listing_file (name)
     const char *name;
d1146 1
a1146 2
listing_eject (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1153 1
a1153 2
listing_flags (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1166 1
a1166 2
listing_list (on)
     int on;
d1195 1
a1195 2
listing_psize (width_only)
     int width_only;
d1222 1
a1222 2
listing_nopage (ignore)
     int ignore ATTRIBUTE_UNUSED;
d1228 1
a1228 2
listing_title (depth)
     int depth;
d1280 1
a1280 2
listing_source_line (line)
     unsigned int line;
d1291 1
a1291 2
listing_source_file (file)
     const char *file;
d1302 1
a1302 2
listing_flags (ignore)
     int ignore;
d1308 1
a1308 2
listing_list (on)
     int on;
d1314 1
a1314 2
listing_eject (ignore)
     int ignore;
d1320 1
a1320 2
listing_psize (ignore)
     int ignore;
d1326 1
a1326 2
listing_nopage (ignore)
     int ignore;
d1332 1
a1332 2
listing_title (depth)
     int depth;
d1338 1
a1338 2
listing_file (name)
     const char *name;
d1344 1
a1344 2
listing_newline (name)
     char *name;
d1350 1
a1350 2
listing_source_line (n)
     unsigned int n;
d1356 1
a1356 2
listing_source_file (n)
     const char *n;
@


1.22
log
@	* ChangeLog: Fix typos.
	* ChangeLog-9295: Likewise.
	* as.c: Fix comment typos.
	* as.h: Likewise.
	* atof-generic.c: Likewise.
	* bit_fix.h: Likewise.
	* frags.h: Likewise.
	* hash.c: Likewise.
	* input-file.c: Likewise.
	* input-scrub.c: Likewise.
	* itbl-ops.c: Likewise.
	* itbl-parse.y: Likewise.
	* listing.c: Likewise.
	* macro.h: Likewise.
	* read.c: Likewise.
	* sb.c: Likewise.
	* sb.h: Likewise.
	* symbols.c: Likewise.
	* symbols.h: Likewise.
@
text
@d1 1
a1 1
/* listing.c - mainting assembly listings
@


1.21
log
@	* ecoff.c: (get_tag): Replace strcpy with xstrdup.
	(ecoff_directive_def): Likewise.
	(ecoff_directive_tag): Likewise.
	* listing.c (file_info): Likewise.
	* hash.c (what): Likewise.
@
text
@d68 1
a68 1
 function also rememebers when the filename changes.
d89 1
a89 1
 LISTING_LHS_CONT_LINES	Max number of lines to use up for a continutation
d130 1
a130 1
/* This structure rememebrs which line from which file goes into which
@


1.20
log
@	* Makefile.am (OBJS): Depend on ansidecl.h and fopen-same.h.
	* Makefile.in: Regenerate.
	* dep-in.sed: Reorder to match OBJS in Makefile.am.
	* configure.in (ALL_OBJ_DEPS): Add symcat.h when need_bfd.
	* configure: Regenerate.
	* as.h: Use #include "" instead of <> for local header files.
	* flonum-konst.c: Likewise.
	* flonum-mult.c: Likewise.
	* gasp.c: Likewise.
	* listing.c: Likewise.
	* config/tc-ia64.h: Likewise.
	* config/tc-v850.h: Likewise.
@
text
@d272 1
a272 2
  p->filename = xmalloc ((unsigned long) strlen (file_name) + 1);
  strcpy (p->filename, file_name);
@


1.19
log
@	* app.c: Fix formatting.
	* as.c: Likewise.
	* ehopt.c: Likewise.
	* expr.c: Likewise.
	* input-file.c: Likewise.
	* listing.c: Likewise.
	* macro.h: Likewise.
	* stabs.c: Likewise.
	* symbols.c: Likewise.
@
text
@d3 1
a3 1
   2001
d95 1
a95 1
#include <obstack.h>
@


1.18
log
@	* listing.c (buffer_line): Don't write past the end of `line' when
	EOF is reached.
@
text
@d619 17
a635 17
    if (frag_ptr->fr_type == rs_fill)
      {
	unsigned int var_rep_max = octet_in_frag;
	unsigned int var_rep_idx = octet_in_frag;

	/* Print as many bytes from the variable part as is sensible.  */
	while (((offsetT) octet_in_frag
		< (frag_ptr->fr_fix + frag_ptr->fr_var * frag_ptr->fr_offset))
	       && data_buffer_size < MAX_BYTES - 3)
	  {
	    if (address == ~(unsigned int) 0)
	      {
		address = frag_ptr->fr_address / OCTETS_PER_BYTE;
	      }
	    sprintf (data_buffer + data_buffer_size,
		     "%02X",
		     (frag_ptr->fr_literal[var_rep_idx]) & 0xff);
d637 2
a638 2
	    data_buffer[data_buffer_size++] = '*';
	    data_buffer[data_buffer_size++] = '*';
d640 1
a640 1
	    data_buffer_size += 2;
d642 2
a643 2
	    var_rep_idx++;
	    octet_in_frag++;
d645 4
a648 4
	    if ((offsetT) var_rep_idx >= frag_ptr->fr_fix + frag_ptr->fr_var)
	      var_rep_idx = var_rep_max;
	  }
      }
d1066 1
a1066 1
 		  print_lines (list,
@


1.17
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d516 6
a521 3
      *p++ = '.';
      *p++ = '.';
      *p++ = '.';
@


1.16
log
@	* read.c: Standardize error/warning messages - don't capitalise, no
	final period or newline, don't say "ignored" or "zero assumed" for
	as_bad messages.  In some cases, change the wording to that used
	elsewhere for similar messages.
	* app.c, as.c, atof-generic.c, cgen.c, cond.c, depend.c, dwarf2dbg.c,
	  ecoff.c, expr.c, frags.c, input-file.c, input-scrub.c, listing.c,
	  output-file.c, stabs.c, subsegs.c, symbols.c, write.c: Likewise.
	* ecoff.c (ecoff_directive_end): Test for missing name by
	comparing input line pointers rather than reading string.
	(ecoff_directive_ent): Likewise.
	* read.c (s_set): Likewise.
	(s_align): Report a warning rather than an error for
	alignment too large.
	(s_comm): Check for missing symbol name.
	(s_lcomm_internal): Likewise.
	(s_lsym): Likewise.
	(s_globl): Use is_end_of_line instead of looking for '\n'.
	(s_lcomm_internal): Likewise.
	(ignore_rest_of_line): Report a warning rather than an error.
@
text
@a93 2
#include <ctype.h>

d96 1
d372 1
a372 1
		  if (isascii (c) && ! iscntrl (c))
d910 1
a910 1
  while (isspace ((unsigned char) *line))
@


1.15
log
@Use FOPEN_.. macros in calls to fopen().
@
text
@d1298 1
a1298 1
	  as_bad (_("New line in title"));
@


1.14
log
@Fix conditional assembly listings when more than one .else/.elsif
@
text
@d488 1
a488 1
      last_open_file = fopen (file->filename, "r");
d1124 1
a1124 1
      list_file = fopen (name, "w");
@


1.13
log
@Fix copyright notices
@
text
@d2 2
a3 1
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
d1011 2
d1035 2
a1036 1
      if (list->edict == EDICT_LIST)
d1097 1
a1097 1
      if (list->edict == EDICT_NOLIST_NEXT)
@


1.12
log
@2000-12-31  H.J. Lu  <hjl@@gnu.org>

	* listing.c (listing_message): Allocate string only if it is
	used.

	* configure: Rebuild.
@
text
@d2 1
a2 1
   Copyright (C) 1991, 92, 93, 94, 95, 96, 97, 98, 99, 2000
@


1.12.2.1
log
@Fix conditional assembly listings when more than one .else/.elseif
@
text
@d2 1
a2 2
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001
a1009 2
	  if (show_listing == 0)
	    list_line--;
d1032 1
a1032 2
      if (list->edict == EDICT_LIST
	  || (list->edict == EDICT_NOLIST_NEXT && show_listing == 0))
d1093 1
a1093 1
      if (list->edict == EDICT_NOLIST_NEXT && show_listing == 1)
@


1.11
log
@2000-12-29  H.J. Lu  <hjl@@gnu.org>

	* listing.c (calc_hex): Print the variable part only if the
	fragment type is rs_fill.
@
text
@a228 4
  unsigned int l = strlen (name) + strlen (message) + 1;
  char *n = (char *) xmalloc (l);
  strcpy (n, name);
  strcat (n, message);
d231 4
@


1.10
log
@2000-11-06  Kazu Hirata  <kazu@@hxi.com>

	* as.c: Fix formatting.
	* dwarf2dbg.c: Likewise.
	* itbl-ops.c: Likewise.
	* listing.c: Likewise.
	* macro.h: Likewise.
	* messages.c: Likewise.
	* read.c: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* write.c: Likewise.
@
text
@d616 1
@


1.9
log
@2000-08-31  Kazu Hirata  <kazu@@hxi.com>

	* listing.c: Fix formatting.
@
text
@d122 1
a122 2
typedef struct file_info_struct
{
d128 1
a128 2
}
file_info_type;
d132 1
a132 2
struct list_info_struct
{
d157 9
a165 10
  enum
    {
      EDICT_NONE,
      EDICT_SBTTL,
      EDICT_TITLE,
      EDICT_NOLIST,
      EDICT_LIST,
      EDICT_NOLIST_NEXT,
      EDICT_EJECT
    } edict;
d193 1
a193 1
static FILE * list_file;
d208 1
a208 1
static file_info_type * file_info PARAMS ((const char *file_name));
@


1.8
log
@Default LISTING_LHS_WIDTH to depend on LISTING_WORD_SIZE so that bytes per
line is 4.  Fix tests for LISTING_WORD_SIZE==1.
@
text
@d2 1
a2 1
   Copyright (C) 1991, 92, 93, 94, 95, 96, 97, 98, 1999
d20 1
a20 1
02111-1307, USA. */
d23 1
a23 3
 Contributed by Steve Chamberlain
 		sac@@cygnus.com

a57 1

d121 1
a121 1
/* This structure remembers which .s were used */
d133 1
a133 1
   frag */
d136 2
a137 2
  /* Frag which this line of source is nearest to */
  fragS * frag;
d139 1
a139 1
  /* The actual line in the source file */
d142 2
a143 2
     belongs to */
  file_info_type * file;
d146 1
a146 1
  char * line_contents;
d148 2
a149 2
  /* Next in list */
  struct list_info_struct * next;
d152 3
a154 3
     source line that belongs here */
  file_info_type * hll_file;
  /* High level language source line */
d157 2
a158 2
  /* Pointer to any error message associated with this line */
  char * message;
d170 1
a170 1
  char * edict_arg;
a179 1

d208 1
a208 1
static char * data_buffer;
d214 1
a214 1
static char * buffer_line PARAMS ((file_info_type *file,
a227 1

d261 1
a261 1
  /* Find an entry with this file name */
d271 1
a271 1
  /* Make new entry */
a284 1

d331 2
a332 1
      if (line == last_line && !(last_file && file && strcmp (file, last_file)))
d344 4
a347 4
	 If we are reading from stdin, then we need to save each input line
	 here (assuming of course that we actually have a line of input to read),
	 so that it can be displayed in the listing that is produced at the end
	 of the assembly.  */
d351 1
a351 1
	  char * copy;
d356 4
a359 4
	       * copy && (seen_quote
			  || (! is_end_of_line [(unsigned char) * copy]));
	       copy ++)
	    if (* copy == '"' && copy[-1] != '\\')
d368 3
a370 3
	      char * src = input_line_pointer - 1;
	      char * dest = copy;
	      
d373 1
a373 1
		  unsigned char c = * src ++;
d377 1
a377 1
		    * dest ++ = c;
d379 1
a379 1
	      
d382 1
a382 1
	  
d396 1
a396 1
  
d403 1
a403 1
  
d415 1
a415 1
  
d462 3
a464 5
/*
 This function returns the next source line from the file supplied,
 truncated to size.  It appends a fake line to the end of each input
 file to make
*/
d468 1
a468 1
     file_info_type * file;
d477 1
a477 1
  /* If we couldn't open the file, return an empty line */
d497 1
a497 1
      
d500 1
a500 1
	fseek(last_open_file, file->pos, SEEK_SET);
d505 2
a506 1
  size -= 1;			/* leave room for null */
a528 1

d533 3
a535 4
static char *title;		/* current title */
static char *subtitle;		/* current subtitle */
static unsigned int on_page;	/* number of lines printed on current page */

d542 3
a544 2
     soon  (we look down 10 lines of the page and see if it's there)*/
  if ((eject || (on_page >= (unsigned int) paper_height)) && paper_height != 0)
a567 1

a580 1

d583 1
a583 1
     list_info_type * list;
d587 1
a587 1
  unsigned int address = ~ (unsigned int) 0;
d592 1
a592 1
  /* Find first frag which says it belongs to this line */
d601 1
a601 1
  /* Dump all the frags which belong to this line */
d604 1
a604 1
      /* Print as many bytes from the fixed part as is sensible */
d609 1
a609 1
	  if (address == ~ (unsigned int) 0)
d624 1
a624 1
	/* Print as many bytes from the variable part as is sensible */
d629 1
a629 1
	    if (address == ~ (unsigned int) 0)
a655 5





d670 1
a670 1
  /* Print the stuff on the first line */
d673 3
a675 3
  
  /* Print the hex for the first line */
  if (address == ~ (unsigned int) 0)
d682 3
a684 3
      
      on_page ++;
      
d695 1
a695 1
  /* And the data to go along with it */
d702 1
a702 1
      fprintf (list_file, "%c%c", src[offset], src[offset+1]);
d705 1
a705 1
      
d712 1
a712 1
      
d715 1
a715 1
  
d718 1
a718 1
  
d722 1
a722 1
  
d729 1
a729 1
  
d733 1
a733 1
       lines ++)
d735 1
a735 2
      nchars = ((LISTING_WORD_SIZE * 2) + 1)
	* listing_lhs_width_second - 1;
d737 2
a738 2
      
      /* Print any more lines of data, but more compactly */
d740 1
a740 1
      
d743 3
a745 3
          int offset;
          offset = cur;
          fprintf (list_file, "%c%c", src[offset], src[offset+1]);
d749 1
a749 1
	  
d757 1
a757 1
      
d759 1
a759 1
      on_page ++;
a763 1

d828 1
a828 1
	      on_page ++;
a994 1

d1080 1
a1080 1
		    address = ~ (unsigned int) 0;
d1112 1
a1112 1
  
a1160 1

a1219 1

a1307 2


a1327 2


d1330 1
a1330 2

/* Dummy functions for when compiled without listing enabled */
d1339 1
a1339 1
void 
d1346 1
a1346 1
void 
d1353 1
a1353 1
void 
d1367 1
a1367 1
void 
d1381 1
a1381 1
void 
d1388 1
a1388 1
void 
d1394 2
a1395 1
void 
@


1.7
log
@This lot mainly cleans up `comparison between signed and unsigned' gcc
warnings.  One usused var, and a macro parenthesis fix too.  Also check
input sections are elf when doing gc in elflink.h.
@
text
@d112 1
a112 1
#define LISTING_LHS_WIDTH 1
d115 1
a115 1
#define LISTING_LHS_WIDTH_SECOND 1
@


1.6
log
@Remove conditionals causing a bug in listings.
@
text
@a681 1
  int end = strlen(src);
@


1.5
log
@octets vs bytes changes for GAS
@
text
@a715 1
#if TARGET_BYTES_BIG_ENDIAN != 0
a717 6
#else
      offset = (cur & ~(LISTING_WORD_SIZE * 2 - 1)) 
        + (LISTING_WORD_SIZE - octet_in_word - 1) * 2;
      if (offset < end)
        fprintf (list_file, "%c%c", src[offset], src[offset+1]);
#endif
a759 1
#if TARGET_BYTES_BIG_ENDIAN != 0
a761 6
#else
          offset = (cur & ~(LISTING_WORD_SIZE * 2 - 1))
            + (LISTING_WORD_SIZE - octet_in_word - 1) * 2;
          if (offset < end)
            fprintf (list_file, "%c%c", src[offset], src[offset+1]);
#endif
@


1.4
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Fill in structure initializations.  Add variable
	initializations.  Add casts.
	* dwarf2dbg.c (print_stats): Change i to size_t.
	* listing.c (listing_listing): Change list_line to unsigned int.
@
text
@d599 1
a599 1
  unsigned int byte_in_frag;
d614 2
a615 2
      byte_in_frag = 0;
      while ((offsetT) byte_in_frag < frag_ptr->fr_fix
d620 1
a620 1
	      address = frag_ptr->fr_address;
d625 1
a625 1
		   (frag_ptr->fr_literal[byte_in_frag]) & 0xff);
d627 1
a627 1
	  byte_in_frag++;
d630 2
a631 2
	unsigned int var_rep_max = byte_in_frag;
	unsigned int var_rep_idx = byte_in_frag;
d634 2
a635 2
	while (((offsetT) byte_in_frag
		< frag_ptr->fr_fix + frag_ptr->fr_var * frag_ptr->fr_offset)
d640 1
a640 1
		address = frag_ptr->fr_address;
d652 1
a652 1
	    byte_in_frag++;
d680 1
a680 1
  unsigned int byte_in_word = 0;
d682 2
d712 2
a713 2
  
  while (*src && idx < nchars)
d715 12
a726 3
      fprintf (list_file, "%c%c", src[0], src[1]);
      src += 2;
      byte_in_word++;
d728 1
a728 1
      if (byte_in_word == LISTING_WORD_SIZE)
d732 1
a732 1
	  byte_in_word = 0;
d754 1
a754 1
	 && *src;
d764 1
a764 1
      while (*src && idx < nchars)
d766 11
a776 2
	  fprintf (list_file, "%c%c", src[0], src[1]);
	  src += 2;
d778 1
a778 1
	  byte_in_word++;
d780 1
a780 1
	  if (byte_in_word == LISTING_WORD_SIZE)
d784 1
a784 1
	      byte_in_word = 0;
@


1.3
log
@	Add support for storing local symbols in a small structure to save
	memory when assembling large files.
	* as.h: Don't include struc-symbol.h.
	(symbolS): Add typedef.
	* symbols.c: Include struc-symbol.h.
	(local_hash): New static variable.
	(save_symbol_name): New static function, from symbol_create.
	(symbol_create): Call save_symbol_name.
	(local_symbol_count): New static variable.
	(local_symbol_conversion_count): Likewise.
	(LOCAL_SYMBOL_CHECK): Define.
	(local_symbol_make): New static function.
	(local_symbol_convert): New static function.
	(colon): Handle local symbols.  Create local symbol for local
	label name.
	(symbol_table_insert): Handle local symbols.
	(symbol_find_or_make): Create local symbol for local label name.
	(symbol_find_base): Check for local symbol.
	(symbol_append, symbol_insert): Check for local symbols.
	(symbol_clear_list_pointers, symbol_remove): Likewise.
	(verify_symbol_chain): Likewise.
	(copy_symbol_attributes): Likewise.
	(resolve_symbol_value): Handle local symbols.
	(resolve_local_symbol): New static function.
	(resolve_local_symbol_values): New function.
	(S_GET_VALUE, S_SET_VALUE): Handle local symbols.
	(S_IS_FUNCTION, S_IS_EXTERNAL, S_IS_WEAK, S_IS_COMMON): Likewise.
	(S_IS_DEFINED, S_IS_DEBUG, S_IS_LOCAL, S_GET_NAME): Likewise.
	(S_GET_SEGMENT, S_SET_SEGMENT, S_SET_EXTERNAL): Likewise.
	(S_CLEAR_EXTERNAL, S_SET_WEAK, S_SET_NAME): Likewise.
	(symbol_previous, symbol_next): New functions.
	(symbol_get_value_expression): Likewise.
	(symbol_set_value_expression): Likewise.
	(symbol_set_frag, symbol_get_frag): Likewise.
	(symbol_mark_used, symbol_clear_used, symbol_used_p): Likewise.
	(symbol_mark_used_in_reloc): Likewise.
	(symbol_clear_used_in_reloc, symbol_used_in_reloc_p): Likewise.
	(symbol_mark_mri_common, symbol_clear_mri_common): Likewise.
	(symbol_mri_common_p): Likewise.
	(symbol_mark_written, symbol_clear_written): Likewise.
	(symbol_written_p): Likewise.
	(symbol_mark_resolved, symbol_resolved_p): Likewise.
	(symbol_section_p, symbol_equated_p): Likewise.
	(symbol_constant_p): Likewise.
	(symbol_get_bfdsym, symbol_set_bfdsym): Likewise.
	(symbol_get_obj, symbol_set_obj): Likewise.
	(symbol_get_tc, symbol_set_tc): Likewise.
	(symbol_begin): Initialize local_hash.
	(print_symbol_value_1): Handle local symbols.
	(symbol_print_statistics): Print local symbol statistics.
	* symbols.h: Include "struc-symbol.h" if not BFD_ASSEMBLER.
	Declare new symbols.c functions.  Move many declarations here from
	struc-symbol.h.
	(SYMBOLS_NEED_BACKPOINTERS): Define if needed.
	* struc-symbol.h (SYMBOLS_NEED_BACKPOINTERS): Don't set.
	(struct symbol): Move bsym to make it clearly the first field.
	Remove TARGET_SYMBOL_FIELDS.
	(symbolS): Don't typedef.
	(struct broken_word): Remove.
	(N_TYPE_seg, seg_N_TYPE): Move to symbol.h.
	(SEGMENT_TO_SYMBOL_TYPE, N_REGISTER): Likewise.
	(symbol_clear_list_pointers): Likewise.
	(symbol_insert, symbol_remove): Likewise.
	(symbol_previous, symbol_append): Likewise.
	(verify_symbol_chain, verify_symbol_chain_2): Likewise.
	(struct local_symbol): Define.
	(local_symbol_converted_p, local_symbol_mark_converted): Define.
	(local_symbol_resolved_p, local_symbol_mark_resolved): Define.
	(local_symbol_get_frag, local_symbol_set_frag): Define.
	(local_symbol_get_real_symbol): Define.
	(local_symbol_set_real_symbol): Define.
	Define.
	* write.c (write_object_file): Call resolve_local_symbol_values.
	* config/obj-ecoff.h (OBJ_SYMFIELD_TYPE): Define.
	(TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-elf.h (OBJ_SYMFIELD_TYPE): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-multi.h (struct elf_obj_sy): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	(ECOFF_DEBUG_TARGET_SYMBOL_FIELDS): Don't define.
	* config/tc-mcore.h: Don't include struc-symbol.h.
	(TARGET_SYMBOL_FIELDS): Don't define.
	(struct mcore_tc_sy): Define.
	(TC_SYMFIELD_TYPE): Define.
	* Many files: Use symbolS instead of struct symbol.  Use new
	accessor functions rather than referring to symbolS fields
	directly.
	* read.c (s_mri_common): Don't add in value of line_label.
	* config/tc-mips.c (md_apply_fix): Correct parenthesization when
	checking for SEC_LINK_ONCE.
	* config/tc-sh.h (sh_fix_adjustable): Declare.
@
text
@d981 1
a981 1
     char *name;
d1009 1
a1009 1
      int list_line;
d1183 1
a1183 1
     int ignore;
d1191 1
a1191 1
     int ignore;
d1264 1
a1264 1
     int ignore;
@


1.2
log
@	-Wchar-subscripts cleanup
	* listing.c (listing_newline): Use unsigned char variable, so
 	calls to isascii,iscntrl are correct.
	* atof-generic.c (atof_generic): Cast arg to isdigit, et. al. with
	(unsigned char).
	* ecoff.c (ecoff_directive_ent,ecoff_stab): Ditto.
	* config/obj-elf.c (obj_elf_vtable_inherit): Ditto.
	* config/tc-mips.c (mips_ip,mips16_ip): Ditto.
	(my_getSmallExpression,get_number,s_mips_ent): Ditto.
@
text
@d792 1
a792 1
	  if (ptr->bsym->flags & BSF_SECTION_SYM)
d824 1
a824 1
	      if (ptr->sy_frag && ptr->sy_frag->line)
d827 2
a828 2
			   ptr->sy_frag->line->file->filename,
			   ptr->sy_frag->line->line,
@


1.1
log
@Initial revision
@
text
@d378 1
a378 1
		  char c = * src ++;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

