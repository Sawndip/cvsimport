head	1.27;
access;
symbols
	binutils-2_24-branch:1.27.0.2
	binutils-2_24-branchpoint:1.27
	binutils-2_21_1:1.25
	binutils-2_23_2:1.26.6.1
	binutils-2_23_1:1.26
	binutils-2_23:1.26
	binutils-2_23-branch:1.26.0.6
	binutils-2_23-branchpoint:1.26
	binutils-2_22_branch:1.26.0.4
	binutils-2_22:1.26
	binutils-2_22-branch:1.26.0.2
	binutils-2_22-branchpoint:1.26
	binutils-2_21:1.25
	binutils-2_21-branch:1.25.0.2
	binutils-2_21-branchpoint:1.25
	binutils-2_20_1:1.23.6.1
	binutils-2_20:1.23.6.1
	binutils-arc-20081103-branch:1.23.0.8
	binutils-arc-20081103-branchpoint:1.23
	binutils-2_20-branch:1.23.0.6
	binutils-2_20-branchpoint:1.23
	dje-cgen-play1-branch:1.23.0.4
	dje-cgen-play1-branchpoint:1.23
	arc-20081103-branch:1.23.0.2
	arc-20081103-branchpoint:1.23
	binutils-2_19_1:1.22
	binutils-2_19:1.22
	binutils-2_19-branch:1.22.0.2
	binutils-2_19-branchpoint:1.22
	binutils-2_18:1.20
	binutils-2_18-branch:1.20.0.2
	binutils-2_18-branchpoint:1.20
	binutils-csl-coldfire-4_1-32:1.19
	binutils-csl-sourcerygxx-4_1-32:1.19
	binutils-csl-innovasic-fido-3_4_4-33:1.19
	binutils-csl-sourcerygxx-3_4_4-32:1.13
	binutils-csl-coldfire-4_1-30:1.19
	binutils-csl-sourcerygxx-4_1-30:1.19
	binutils-csl-coldfire-4_1-28:1.19
	binutils-csl-sourcerygxx-4_1-29:1.19
	binutils-csl-sourcerygxx-4_1-28:1.19
	binutils-csl-arm-2006q3-27:1.19
	binutils-csl-sourcerygxx-4_1-27:1.19
	binutils-csl-arm-2006q3-26:1.19
	binutils-csl-sourcerygxx-4_1-26:1.19
	binutils-csl-sourcerygxx-4_1-25:1.19
	binutils-csl-sourcerygxx-4_1-24:1.19
	binutils-csl-sourcerygxx-4_1-23:1.19
	binutils-csl-sourcerygxx-4_1-21:1.19
	binutils-csl-arm-2006q3-21:1.19
	binutils-csl-sourcerygxx-4_1-22:1.19
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.19
	binutils-csl-sourcerygxx-4_1-20:1.19
	binutils-csl-arm-2006q3-19:1.19
	binutils-csl-sourcerygxx-4_1-19:1.19
	binutils-csl-sourcerygxx-4_1-18:1.19
	binutils-csl-renesas-4_1-9:1.19
	binutils-csl-sourcerygxx-3_4_4-25:1.13
	binutils-csl-renesas-4_1-8:1.19
	binutils-csl-renesas-4_1-7:1.19
	binutils-csl-renesas-4_1-6:1.19
	binutils-csl-sourcerygxx-4_1-17:1.19
	binutils-csl-sourcerygxx-4_1-14:1.19
	binutils-csl-sourcerygxx-4_1-15:1.19
	binutils-csl-sourcerygxx-4_1-13:1.19
	binutils-2_17:1.19
	binutils-csl-sourcerygxx-4_1-12:1.19
	binutils-csl-sourcerygxx-3_4_4-21:1.19
	binutils-csl-wrs-linux-3_4_4-24:1.13.4.1
	binutils-csl-wrs-linux-3_4_4-23:1.13.4.1
	binutils-csl-sourcerygxx-4_1-9:1.19
	binutils-csl-sourcerygxx-4_1-8:1.19
	binutils-csl-sourcerygxx-4_1-7:1.19
	binutils-csl-arm-2006q1-6:1.19
	binutils-csl-sourcerygxx-4_1-6:1.19
	binutils-csl-wrs-linux-3_4_4-22:1.13.4.1
	binutils-csl-coldfire-4_1-11:1.19
	binutils-csl-sourcerygxx-3_4_4-19:1.19
	binutils-csl-coldfire-4_1-10:1.19
	binutils-csl-sourcerygxx-4_1-5:1.19
	binutils-csl-sourcerygxx-4_1-4:1.19
	binutils-csl-wrs-linux-3_4_4-21:1.13.4.1
	binutils-csl-morpho-4_1-4:1.19
	binutils-csl-sourcerygxx-3_4_4-17:1.19
	binutils-csl-wrs-linux-3_4_4-20:1.13.4.1
	binutils-2_17-branch:1.19.0.4
	binutils-2_17-branchpoint:1.19
	binutils-csl-2_17-branch:1.19.0.2
	binutils-csl-2_17-branchpoint:1.19
	binutils-csl-gxxpro-3_4-branch:1.13.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.13
	binutils-2_16_1:1.13
	binutils-csl-arm-2005q1b:1.13.4.1
	binutils-2_16:1.13
	binutils-csl-arm-2005q1a:1.13
	binutils-csl-arm-2005q1-branch:1.13.0.4
	binutils-csl-arm-2005q1-branchpoint:1.13
	binutils-2_16-branch:1.13.0.2
	binutils-2_16-branchpoint:1.13
	csl-arm-2004-q3d:1.12
	csl-arm-2004-q3:1.12
	binutils-2_15:1.12
	binutils-2_15-branchpoint:1.12
	csl-arm-2004-q1a:1.12
	csl-arm-2004-q1:1.12
	binutils-2_15-branch:1.12.0.6
	cagney_bfdfile-20040213-branch:1.12.0.4
	cagney_bfdfile-20040213-branchpoint:1.12
	cagney_bigcore-20040122-branch:1.12.0.2
	cagney_bigcore-20040122-branchpoint:1.12
	csl-arm-2003-q4:1.12
	binutils-2_14:1.9
	binutils-2_14-branch:1.9.0.4
	binutils-2_14-branchpoint:1.9
	binutils-2_13_2_1:1.9
	binutils-2_13_2:1.9
	binutils-2_13_1:1.9
	binutils-2_13:1.9
	binutils-2_13-branchpoint:1.9
	binutils-2_13-branch:1.9.0.2
	binutils-2_12_1:1.8
	binutils-2_12:1.8
	binutils-2_12-branch:1.8.0.2
	binutils-2_12-branchpoint:1.8
	cygnus_cvs_20020108_pre:1.8
	binutils-2_11_2:1.6.2.1
	binutils-2_11_1:1.6.2.1
	binutils-2_11:1.6
	x86_64versiong3:1.6
	binutils-2_11-branch:1.6.0.2
	binutils-2_10_1:1.3
	binutils-2_10:1.3
	binutils-2_10-branch:1.3.0.2
	binutils-2_10-branchpoint:1.3
	binutils_latest_snapshot:1.27
	repo-unification-2000-02-06:1.3
	binu_ss_19990721:1.3
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.27
date	2013.01.10.17.11.17;	author roland;	state Exp;
branches;
next	1.26;

1.26
date	2011.04.20.12.52.15;	author amodra;	state Exp;
branches
	1.26.6.1;
next	1.25;

1.25
date	2009.12.11.13.42.09;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2009.09.11.15.27.33;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2008.10.21.00.26.17;	author amodra;	state Exp;
branches
	1.23.6.1;
next	1.22;

1.22
date	2008.08.12.23.39.30;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2008.08.11.07.40.22;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2007.07.03.11.01.03;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2005.05.18.05.40.06;	author zack;	state Exp;
branches;
next	1.18;

1.18
date	2005.05.05.09.12.45;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2005.04.29.16.56.12;	author hjl;	state Exp;
branches;
next	1.16;

1.16
date	2005.04.29.00.22.26;	author bje;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.14.09.00.35;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2005.04.12.08.42.38;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2005.03.03.01.29.53;	author amodra;	state Exp;
branches
	1.13.4.1;
next	1.12;

1.12
date	2003.11.24.03.37.58;	author kazu;	state Exp;
branches;
next	1.11;

1.11
date	2003.11.23.02.14.21;	author kazu;	state Exp;
branches;
next	1.10;

1.10
date	2003.10.27.12.45.17;	author kazu;	state Exp;
branches;
next	1.9;

1.9
date	2002.06.26.01.18.42;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2001.09.19.05.33.19;	author hjl;	state Exp;
branches;
next	1.7;

1.7
date	2001.03.08.23.24.22;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2000.10.30.21.59.01;	author kazu;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.08.08.21.42.59;	author kazu;	state Exp;
branches;
next	1.4;

1.4
date	2000.07.10.15.15.01;	author amodra;	state Exp;
branches;
next	1.3;

1.3
date	99.07.11.20.19.56;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.06.02.23.22.50;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.40;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.26.6.1
date	2013.01.10.17.13.05;	author roland;	state Exp;
branches;
next	;

1.23.6.1
date	2009.09.11.15.28.43;	author nickc;	state Exp;
branches;
next	;

1.13.4.1
date	2005.04.26.05.31.40;	author zack;	state Exp;
branches;
next	;

1.6.2.1
date	2001.06.07.03.15.24;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.40;	author rth;	state Exp;
branches;
next	;


desc
@@


1.27
log
@gas/
	* hash.c (hash_new_sized): Make it global.
	* hash.h: Declare it.
	* macro.c (define_macro): Use hash_new_sized instead of hash_new,
	pass a small size.
@
text
@/* hash.c -- gas hash table code
   Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,
   2000, 2001, 2002, 2003, 2005, 2007, 2008, 2009, 2011, 2013
   Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* This version of the hash table code is a wholescale replacement of
   the old hash table code, which was fairly bad.  This is based on
   the hash table code in BFD, but optimized slightly for the
   assembler.  The assembler does not need to derive structures that
   are stored in the hash table.  Instead, it always stores a pointer.
   The assembler uses the hash table mostly to store symbols, and we
   don't need to confuse the symbol structure with a hash table
   structure.  */

#include "as.h"
#include "safe-ctype.h"
#include "obstack.h"

/* An entry in a hash table.  */

struct hash_entry {
  /* Next entry for this hash code.  */
  struct hash_entry *next;
  /* String being hashed.  */
  const char *string;
  /* Hash code.  This is the full hash code, not the index into the
     table.  */
  unsigned long hash;
  /* Pointer being stored in the hash table.  */
  void *data;
};

/* A hash table.  */

struct hash_control {
  /* The hash array.  */
  struct hash_entry **table;
  /* The number of slots in the hash table.  */
  unsigned int size;
  /* An obstack for this hash table.  */
  struct obstack memory;

#ifdef HASH_STATISTICS
  /* Statistics.  */
  unsigned long lookups;
  unsigned long hash_compares;
  unsigned long string_compares;
  unsigned long insertions;
  unsigned long replacements;
  unsigned long deletions;
#endif /* HASH_STATISTICS */
};

/* The default number of entries to use when creating a hash table.
   Note this value can be reduced to 4051 by using the command line
   switch --reduce-memory-overheads, or set to other values by using
   the --hash-size=<NUMBER> switch.  */

static unsigned long gas_hash_table_size = 65537;

void
set_gas_hash_table_size (unsigned long size)
{
  gas_hash_table_size = bfd_hash_set_default_size (size);
}

/* Create a hash table.  This return a control block.  */

struct hash_control *
hash_new_sized (unsigned long size)
{
  unsigned long alloc;
  struct hash_control *ret;

  ret = (struct hash_control *) xmalloc (sizeof *ret);
  obstack_begin (&ret->memory, chunksize);
  alloc = size * sizeof (struct hash_entry *);
  ret->table = (struct hash_entry **) obstack_alloc (&ret->memory, alloc);
  memset (ret->table, 0, alloc);
  ret->size = size;

#ifdef HASH_STATISTICS
  ret->lookups = 0;
  ret->hash_compares = 0;
  ret->string_compares = 0;
  ret->insertions = 0;
  ret->replacements = 0;
  ret->deletions = 0;
#endif

  return ret;
}

struct hash_control *
hash_new (void)
{
  return hash_new_sized (gas_hash_table_size);
}

/* Delete a hash table, freeing all allocated memory.  */

void
hash_die (struct hash_control *table)
{
  obstack_free (&table->memory, 0);
  free (table);
}

/* Look up a string in a hash table.  This returns a pointer to the
   hash_entry, or NULL if the string is not in the table.  If PLIST is
   not NULL, this sets *PLIST to point to the start of the list which
   would hold this hash entry.  If PHASH is not NULL, this sets *PHASH
   to the hash code for KEY.

   Each time we look up a string, we move it to the start of the list
   for its hash code, to take advantage of referential locality.  */

static struct hash_entry *
hash_lookup (struct hash_control *table, const char *key, size_t len,
	     struct hash_entry ***plist, unsigned long *phash)
{
  unsigned long hash;
  size_t n;
  unsigned int c;
  unsigned int hindex;
  struct hash_entry **list;
  struct hash_entry *p;
  struct hash_entry *prev;

#ifdef HASH_STATISTICS
  ++table->lookups;
#endif

  hash = 0;
  for (n = 0; n < len; n++)
    {
      c = key[n];
      hash += c + (c << 17);
      hash ^= hash >> 2;
    }
  hash += len + (len << 17);
  hash ^= hash >> 2;

  if (phash != NULL)
    *phash = hash;

  hindex = hash % table->size;
  list = table->table + hindex;

  if (plist != NULL)
    *plist = list;

  prev = NULL;
  for (p = *list; p != NULL; p = p->next)
    {
#ifdef HASH_STATISTICS
      ++table->hash_compares;
#endif

      if (p->hash == hash)
	{
#ifdef HASH_STATISTICS
	  ++table->string_compares;
#endif

	  if (strncmp (p->string, key, len) == 0 && p->string[len] == '\0')
	    {
	      if (prev != NULL)
		{
		  prev->next = p->next;
		  p->next = *list;
		  *list = p;
		}

	      return p;
	    }
	}

      prev = p;
    }

  return NULL;
}

/* Insert an entry into a hash table.  This returns NULL on success.
   On error, it returns a printable string indicating the error.  It
   is considered to be an error if the entry already exists in the
   hash table.  */

const char *
hash_insert (struct hash_control *table, const char *key, void *val)
{
  struct hash_entry *p;
  struct hash_entry **list;
  unsigned long hash;

  p = hash_lookup (table, key, strlen (key), &list, &hash);
  if (p != NULL)
    return "exists";

#ifdef HASH_STATISTICS
  ++table->insertions;
#endif

  p = (struct hash_entry *) obstack_alloc (&table->memory, sizeof (*p));
  p->string = key;
  p->hash = hash;
  p->data = val;

  p->next = *list;
  *list = p;

  return NULL;
}

/* Insert or replace an entry in a hash table.  This returns NULL on
   success.  On error, it returns a printable string indicating the
   error.  If an entry already exists, its value is replaced.  */

const char *
hash_jam (struct hash_control *table, const char *key, void *val)
{
  struct hash_entry *p;
  struct hash_entry **list;
  unsigned long hash;

  p = hash_lookup (table, key, strlen (key), &list, &hash);
  if (p != NULL)
    {
#ifdef HASH_STATISTICS
      ++table->replacements;
#endif

      p->data = val;
    }
  else
    {
#ifdef HASH_STATISTICS
      ++table->insertions;
#endif

      p = (struct hash_entry *) obstack_alloc (&table->memory, sizeof (*p));
      p->string = key;
      p->hash = hash;
      p->data = val;

      p->next = *list;
      *list = p;
    }

  return NULL;
}

/* Replace an existing entry in a hash table.  This returns the old
   value stored for the entry.  If the entry is not found in the hash
   table, this does nothing and returns NULL.  */

void *
hash_replace (struct hash_control *table, const char *key, void *value)
{
  struct hash_entry *p;
  void *ret;

  p = hash_lookup (table, key, strlen (key), NULL, NULL);
  if (p == NULL)
    return NULL;

#ifdef HASH_STATISTICS
  ++table->replacements;
#endif

  ret = p->data;

  p->data = value;

  return ret;
}

/* Find an entry in a hash table, returning its value.  Returns NULL
   if the entry is not found.  */

void *
hash_find (struct hash_control *table, const char *key)
{
  struct hash_entry *p;

  p = hash_lookup (table, key, strlen (key), NULL, NULL);
  if (p == NULL)
    return NULL;

  return p->data;
}

/* As hash_find, but KEY is of length LEN and is not guaranteed to be
   NUL-terminated.  */

void *
hash_find_n (struct hash_control *table, const char *key, size_t len)
{
  struct hash_entry *p;

  p = hash_lookup (table, key, len, NULL, NULL);
  if (p == NULL)
    return NULL;

  return p->data;
}

/* Delete an entry from a hash table.  This returns the value stored
   for that entry, or NULL if there is no such entry.  */

void *
hash_delete (struct hash_control *table, const char *key, int freeme)
{
  struct hash_entry *p;
  struct hash_entry **list;

  p = hash_lookup (table, key, strlen (key), &list, NULL);
  if (p == NULL)
    return NULL;

  if (p != *list)
    abort ();

#ifdef HASH_STATISTICS
  ++table->deletions;
#endif

  *list = p->next;

  if (freeme)
    obstack_free (&table->memory, p);

  return p->data;
}

/* Traverse a hash table.  Call the function on every entry in the
   hash table.  */

void
hash_traverse (struct hash_control *table,
	       void (*pfn) (const char *key, void *value))
{
  unsigned int i;

  for (i = 0; i < table->size; ++i)
    {
      struct hash_entry *p;

      for (p = table->table[i]; p != NULL; p = p->next)
	(*pfn) (p->string, p->data);
    }
}

/* Print hash table statistics on the specified file.  NAME is the
   name of the hash table, used for printing a header.  */

void
hash_print_statistics (FILE *f ATTRIBUTE_UNUSED,
		       const char *name ATTRIBUTE_UNUSED,
		       struct hash_control *table ATTRIBUTE_UNUSED)
{
#ifdef HASH_STATISTICS
  unsigned int i;
  unsigned long total;
  unsigned long empty;

  fprintf (f, "%s hash statistics:\n", name);
  fprintf (f, "\t%lu lookups\n", table->lookups);
  fprintf (f, "\t%lu hash comparisons\n", table->hash_compares);
  fprintf (f, "\t%lu string comparisons\n", table->string_compares);
  fprintf (f, "\t%lu insertions\n", table->insertions);
  fprintf (f, "\t%lu replacements\n", table->replacements);
  fprintf (f, "\t%lu deletions\n", table->deletions);

  total = 0;
  empty = 0;
  for (i = 0; i < table->size; ++i)
    {
      struct hash_entry *p;

      if (table->table[i] == NULL)
	++empty;
      else
	{
	  for (p = table->table[i]; p != NULL; p = p->next)
	    ++total;
	}
    }

  fprintf (f, "\t%g average chain length\n", (double) total / table->size);
  fprintf (f, "\t%lu empty slots\n", empty);
#endif
}

#ifdef TEST

/* This test program is left over from the old hash table code.  */

/* Number of hash tables to maintain (at once) in any testing.  */
#define TABLES (6)

/* We can have 12 statistics.  */
#define STATBUFSIZE (12)

/* Display statistics here.  */
int statbuf[STATBUFSIZE];

/* Human farts here.  */
char answer[100];

/* We test many hash tables at once.  */
char *hashtable[TABLES];

/* Points to current hash_control.  */
char *h;
char **pp;
char *p;
char *name;
char *value;
int size;
int used;
char command;

/* Number 0:TABLES-1 of current hashed symbol table.  */
int number;

int
main ()
{
  void applicatee ();
  void destroy ();
  char *what ();
  int *ip;

  number = 0;
  h = 0;
  printf ("type h <RETURN> for help\n");
  for (;;)
    {
      printf ("hash_test command: ");
      gets (answer);
      command = answer[0];
      command = TOLOWER (command);	/* Ecch!  */
      switch (command)
	{
	case '#':
	  printf ("old hash table #=%d.\n", number);
	  whattable ();
	  break;
	case '?':
	  for (pp = hashtable; pp < hashtable + TABLES; pp++)
	    {
	      printf ("address of hash table #%d control block is %xx\n",
		      pp - hashtable, *pp);
	    }
	  break;
	case 'a':
	  hash_traverse (h, applicatee);
	  break;
	case 'd':
	  hash_traverse (h, destroy);
	  hash_die (h);
	  break;
	case 'f':
	  p = hash_find (h, name = what ("symbol"));
	  printf ("value of \"%s\" is \"%s\"\n", name, p ? p : "NOT-PRESENT");
	  break;
	case 'h':
	  printf ("# show old, select new default hash table number\n");
	  printf ("? display all hashtable control block addresses\n");
	  printf ("a apply a simple display-er to each symbol in table\n");
	  printf ("d die: destroy hashtable\n");
	  printf ("f find value of nominated symbol\n");
	  printf ("h this help\n");
	  printf ("i insert value into symbol\n");
	  printf ("j jam value into symbol\n");
	  printf ("n new hashtable\n");
	  printf ("r replace a value with another\n");
	  printf ("s say what %% of table is used\n");
	  printf ("q exit this program\n");
	  printf ("x delete a symbol from table, report its value\n");
	  break;
	case 'i':
	  p = hash_insert (h, name = what ("symbol"), value = what ("value"));
	  if (p)
	    {
	      printf ("symbol=\"%s\"  value=\"%s\"  error=%s\n", name, value,
		      p);
	    }
	  break;
	case 'j':
	  p = hash_jam (h, name = what ("symbol"), value = what ("value"));
	  if (p)
	    {
	      printf ("symbol=\"%s\"  value=\"%s\"  error=%s\n", name, value, p);
	    }
	  break;
	case 'n':
	  h = hashtable[number] = (char *) hash_new ();
	  break;
	case 'q':
	  exit (EXIT_SUCCESS);
	case 'r':
	  p = hash_replace (h, name = what ("symbol"), value = what ("value"));
	  printf ("old value was \"%s\"\n", p ? p : "{}");
	  break;
	case 's':
	  hash_say (h, statbuf, STATBUFSIZE);
	  for (ip = statbuf; ip < statbuf + STATBUFSIZE; ip++)
	    {
	      printf ("%d ", *ip);
	    }
	  printf ("\n");
	  break;
	case 'x':
	  p = hash_delete (h, name = what ("symbol"));
	  printf ("old value was \"%s\"\n", p ? p : "{}");
	  break;
	default:
	  printf ("I can't understand command \"%c\"\n", command);
	  break;
	}
    }
}

char *
what (description)
     char *description;
{
  printf ("   %s : ", description);
  gets (answer);
  return xstrdup (answer);
}

void
destroy (string, value)
     char *string;
     char *value;
{
  free (string);
  free (value);
}

void
applicatee (string, value)
     char *string;
     char *value;
{
  printf ("%.20s-%.20s\n", string, value);
}

/* Determine number: what hash table to use.
   Also determine h: points to hash_control.  */

void
whattable ()
{
  for (;;)
    {
      printf ("   what hash table (%d:%d) ?  ", 0, TABLES - 1);
      gets (answer);
      sscanf (answer, "%d", &number);
      if (number >= 0 && number < TABLES)
	{
	  h = hashtable[number];
	  if (!h)
	    {
	      printf ("warning: current hash-table-#%d. has no hash-control\n", number);
	    }
	  return;
	}
      else
	{
	  printf ("invalid hash table number: %d\n", number);
	}
    }
}

#endif /* TEST */
@


1.26
log
@bfd/
	* hash.c (bfd_default_hash_table_size): Make it an unsigned long.
	(bfd_hash_table_init_n): Overflow checking.
	(bfd_hash_set_default_size): Return current size.  Take unsigned long
	arg.  Add 65537 to hash_size primes.
	* bfd-in.h (bfd_hash_set_default_size): Update prototype.
	* bfd-in2.h: Regenerate.
gas/
	* hash.c (set_gas_hash_table_size): Use bfd_hash_set_default_size.
	(hash_new_sized): New function, split out from..
	(hash_new): ..here.
ld/
	* ld.h (ld_config_type <hash_table_size>): Make it an unsigned long.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2005, 2007, 2008, 2009, 2011
d86 1
a86 1
static struct hash_control *
@


1.26.6.1
log
@gas/
	* hash.c (hash_new_sized): Make it global.
	* hash.h: Declare it.
	* macro.c (define_macro): Use hash_new_sized instead of hash_new,
	pass a small size.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2005, 2007, 2008, 2009, 2011, 2013
d86 1
a86 1
struct hash_control *
@


1.25
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2005, 2007, 2008, 2009
d81 1
a81 22
  gas_hash_table_size = size;
}

/* FIXME: This function should be amalgmated with bfd/hash.c:bfd_hash_set_default_size().  */
static unsigned long
get_gas_hash_table_size (void)
{
  /* Extend this prime list if you want more granularity of hash table size.  */
  static const unsigned long hash_size_primes[] =
    {
      1021, 4051, 8599, 16699, 65537
    };
  unsigned int hindex;

  /* Work out the best prime number near the hash_size.
     FIXME: This could be a more sophisticated algorithm,
     but is it really worth implementing it ?   */
  for (hindex = 0; hindex < ARRAY_SIZE (hash_size_primes) - 1; ++ hindex)
    if (gas_hash_table_size <= hash_size_primes[hindex])
      break;

  return hash_size_primes[hindex];
d86 2
a87 2
struct hash_control *
hash_new (void)
a88 1
  unsigned long size;
a91 2
  size = get_gas_hash_table_size ();

d111 6
@


1.24
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        * as.c (main): Call dwarf2_init.
        * config/obj-elf.c (struct group_list): New field.
        (build_group_lists): Use hash lookup.
        (free_section_idx): New function.
        (elf_frob_file): Adjust.
        * dwarf2dbg.c (all_segs_hash, last_seg_ptr): New variables.
        (get_line_subseg): Adjust.
        (dwarf2_init): New function.
        * dwarf2dbg.h (dwarf2_init): New declaration.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2005, 2007, 2008
d93 1
a93 1
  unsigned int index;
d98 2
a99 2
  for (index = 0; index < ARRAY_SIZE (hash_size_primes) - 1; ++index)
    if (gas_hash_table_size <= hash_size_primes[index])
d102 1
a102 1
  return hash_size_primes[index];
d160 1
a160 1
  unsigned int index;
d182 2
a183 2
  index = hash % table->size;
  list = table->table + index;
d226 1
a226 1
hash_insert (struct hash_control *table, const char *key, void *value)
d243 1
a243 1
  p->data = value;
d256 1
a256 1
hash_jam (struct hash_control *table, const char *key, void *value)
d269 1
a269 1
      p->data = value;
d280 1
a280 1
      p->data = value;
@


1.23
log
@Remove unnecessary casts on obstack_alloc invocations.
@
text
@d116 1
a116 1
  ret = xmalloc (sizeof *ret);
d119 1
a119 1
  ret->table = obstack_alloc (&ret->memory, alloc);
d240 1
a240 1
  p = obstack_alloc (&table->memory, sizeof (*p));
d277 1
a277 1
      p = obstack_alloc (&table->memory, sizeof (*p));
@


1.23.6.1
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.
@
text
@d116 1
a116 1
  ret = (struct hash_control *) xmalloc (sizeof *ret);
d119 1
a119 1
  ret->table = (struct hash_entry **) obstack_alloc (&ret->memory, alloc);
d240 1
a240 1
  p = (struct hash_entry *) obstack_alloc (&table->memory, sizeof (*p));
d277 1
a277 1
      p = (struct hash_entry *) obstack_alloc (&table->memory, sizeof (*p));
@


1.22
log
@Banish PARAMS and PTR.  Convert to ISO C.
Delete unnecessary forward declarations.
@
text
@d240 1
a240 1
  p = (struct hash_entry *) obstack_alloc (&table->memory, sizeof (*p));
d277 1
a277 1
      p = (struct hash_entry *) obstack_alloc (&table->memory, sizeof (*p));
@


1.21
log
@	PR 6575
	* hash.c: Expand PTR to void *.
	(hash_delete): Add "freeme" parameter.  Call obstack_free.
	* hash.h: Expand PTR to void *.
	(hash_delete): Update prototype.
	* macro.c (macro_expand_body): hash_delete LOCALs from formal_hash.
	* config/tc-tic54x.c (tic54x_remove_local_label): Update hash_delete
	call.
	(subsym_substitute): Likewise.
	* doc/internals.texi (hash_delete): Update.
@
text
@d293 1
a293 1
PTR
d317 1
a317 1
PTR
d332 1
a332 1
PTR
d347 1
a347 1
PTR
@


1.20
log
@Switch to GPLv3
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2005, 2007
d47 1
a47 1
  PTR data;
d226 1
a226 1
hash_insert (struct hash_control *table, const char *key, PTR value)
d256 1
a256 1
hash_jam (struct hash_control *table, const char *key, PTR value)
d294 1
a294 1
hash_replace (struct hash_control *table, const char *key, PTR value)
d297 1
a297 1
  PTR ret;
d348 1
a348 1
hash_delete (struct hash_control *table, const char *key)
d366 2
a367 3
  /* Note that we never reclaim the memory for this entry.  If gas
     ever starts deleting hash table entries in a big way, this will
     have to change.  */
d377 1
a377 1
	       void (*pfn) (const char *key, PTR value))
@


1.19
log
@include/elf:
	* arm.h: Import complete list of official relocation names
	and numbers from AAELF.  Define FAKE_RELOCs for old names.
	Remove a few old names no longer used anywhere.

bfd:
	* elf32-arm.c: Wherever possible, use official reloc names
	from AAELF.
	(elf32_arm_howto_table, elf32_arm_tls_gd32_howto)
	(elf32_arm_tls_ldo32_howto, elf32_arm_tls_ldm32_howto)
	(elf32_arm_tls_le32_howto, elf32_arm_tls_ie32_howto)
	(elf32_arm_vtinherit_howto, elf32_arm_vtentry_howto)
	(elf32_arm_pc11_howto, elf32_arm_thm_pc9_howto, elf32_arm_got_prel)
	(elf32_arm_r_howto): Replace with elf32_arm_howto_table_1,
	elf32_arm_howto_table_2, and elf32_arm_howto_table_3.
	Add many new relocations from AAELF.
	(elf32_arm_howto_from_type): Update to match.
	(elf32_arm_reloc_map): Add entries for R_ARM_THM_JUMP24,
	R_ARM_THM_JUMP11, R_ARM_THM_JUMP19, R_ARM_THM_JUMP8,
	R_ARM_THM_JUMP6, R_ARM_GNU_VTINHERIT, and R_ARM_GNU_VTENTRY.
	(elf32_arm_reloc_type_lookup): Use elf32_arm_howto_from_type.
	(elf32_arm_final_link_relocate): Add support for
	R_ARM_THM_JUMP24, R_ARM_THM_JUMP19, R_ARM_THM_JUMP6.  Remove
	case entries redundant with default.

	* reloc.c: Reorganize ARM relocations.  Add Thumb
	assembler-internal relocations BFD_RELOC_ARM_T32_OFFSET_U8,
	BFD_RELOC_ARM_T32_OFFSET_IMM, BFD_RELOC_ARM_T32_IMMEDIATE.
	Add visible relocations BFD_RELOC_THUMB_PCREL_BRANCH7,
	BFD_RELOC_THUMB_BRANCH20, BFD_RELOC_THUMB_BRANCH25.
	Delete unused relocations BFD_RELOC_ARM_GOT12, BFD_RELOC_ARM_COPY.
	* bfd-in2.h, libbfd.h: Regenerate.

opcodes:
	* arm-dis.c (thumb_opcodes): Add disassembly for V6T2 16-bit
	instructions.  Adjust disassembly of some opcodes to match
	unified syntax.
	(thumb32_opcodes): New table.
	(print_insn_thumb): Rename print_insn_thumb16; don't handle
	two-halfword branches here.
	(print_insn_thumb32): New function.
	(print_insn): Choose among print_insn_arm, print_insn_thumb16,
	and print_insn_thumb32.  Be consistent about order of
	halfwords when printing 32-bit instructions.

gas:
	* hash.c (hash_lookup): Add len parameter.  All callers changed.
	(hash_find_n): New interface.
	* hash.h: Prototype hash_find_n.
	* sb.c: Include as.h.
	(scrub_from_sb, sb_to_scrub, scrub_position): New statics.
	(sb_scrub_and_add_sb): New interface.
	* sb.h: Prototype sb_scrub_and_add_sb.
	* input-scrub.c (input_scrub_include_sb): Use sb_scrub_and_add_sb.

	* config/tc-arm.h (TC_FORCE_RELOCATION_LOCAL): Remove
	reference to BFD_RELOC_ARM_GOT12 which is never generated.
	* config/tc-arm.c: Rewrite, adding Thumb-2 support.

gas/testsuite:
	* gas/arm/arm.exp: Convert all existing "gas_test" tests to
	"run_dump_test" tests.  Run more tests unconditionally.  Run new tests.
	* gas/arm/arch4t.s, gas/arm/arch6zk.s, gas/arm/arm3.s, gas/arm/arm6.s
	* gas/arm/arm7dm.s, gas/arm/bignum1.s, gas/arm/float.s
	* gas/arm/immed.s, gas/arm/iwmmxt.s, gas/arm/offset.s, gas/arm/thumb.s:
	Adjust to work as a dump test.
	* gas/arm/arch4t.d, gas/arm/arch6zk.d, gas/arm/arm3.d, gas/arm/arm6.d
	* gas/arm/arm7dm.d, gas/arm/bignum1.d, gas/arm/float.d
	* gas/arm/immed.d, gas/arm/iwmmxt.d, gas/arm/offset.d, gas/arm/thumb.d:
	New files.

	* gas/arm/armv1-bad.l, gas/arm/armv1-bad.s: Remove tests for
	diagnostics that don't happen in the first pass anymore.

	* gas/arm/iwmmxt-bad.l, gas/arm/r15-bad.l, gas/arm/req.l
	* gas/arm/vfp-bad.l:
	Update expected diagnostics.
	* gas/arm/pic.d: Update expected reloc name.
	* gas/arm/thumbv6.d: CPY no longer appears in disassembly.
	* gas/arm/r15-bad.s: Avoid two-argument mul.
	* gas/arm/req.s: Adjust comments.
	* gas/arm/maverick.d, gas/arm/maverick.s: Avoid inappropriate
	use of PC.

	* gas/arm/macro-1.d, gas/arm/macro1.s
	* gas/arm/t16-bad.l, gas/arm/t16-bad.s
	* gas/arm/tcompat.d, gas/arm/tcompat.s
	* gas/arm/tcompat2.d, gas/arm/tcompat2.s
	* gas/arm/thumb32.d, gas/arm/thumb32.s
	New test pair.

ld/testsuite:
	* ld-arm/mixed-app.d: Adjust expected disassembly a little.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2005
d10 1
a10 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.18
log
@Update the address and phone number of the FSF
@
text
@a152 5
static struct hash_entry *hash_lookup (struct hash_control *,
				       const char *,
				       struct hash_entry ***,
				       unsigned long *);

d154 1
a154 1
hash_lookup (struct hash_control *table, const char *key,
d157 3
a159 4
  register unsigned long hash;
  unsigned int len;
  register const unsigned char *s;
  register unsigned int c;
d170 1
a170 3
  len = 0;
  s = (const unsigned char *) key;
  while ((c = *s++) != '\0')
d172 1
a174 1
      ++len;
d201 1
a201 1
	  if (strcmp (p->string, key) == 0)
d232 1
a232 1
  p = hash_lookup (table, key, &list, &hash);
d262 1
a262 1
  p = hash_lookup (table, key, &list, &hash);
d299 1
a299 1
  p = hash_lookup (table, key, NULL, NULL);
d322 16
a337 1
  p = hash_lookup (table, key, NULL, NULL);
d353 1
a353 1
  p = hash_lookup (table, key, &list, NULL);
@


1.17
log
@2005-04-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* hash.c: Undo the last change.
	* hash.h: Likewise.
@
text
@d20 2
a21 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.16
log
@	* Makefile.am (GAS_CFILES): Remove bignum-copy.c.
	(GENERIC_OBJS): Likewise, remove bignum-copy.o.
	(bignum-copy.o): Remove.
	* Makefile.in: Regenerate.
	* makefile.vms (OBJS): Remove bignum-copy.obj.
	* symbols.h (local_symbol_make): Remove declaration.
	(verify_symbol_chain_2): Likewise.
	* symbols.c (local_symbol_make): Make static.
	(max_indent_level): Likewise.
	(verify_symbol_chain_2): Remove.
	* macro.c (macro_hash): Make static.
	* messages.c (fprint_value): Remove.
	* read.h (get_absolute_expr): Remove.
	(emit_leb128_expr): Likewise.
	(do_s_func): Likewise.
	* read.c (do_s_func): Make static.
	(emit_leb128_expr): Likewise.
	(get_absolute_expr): Likewise.
	* as.h (as_howmuch): Remove declaration.
	(fprint_value): Likewise.
	* as.c (myname): Make static.
	* input-scrub.c (as_howmuch): Remove.
	(as_1_char): Likewise.
	* input-file.h (input_file_is_open): Remove.
	* input-file.c (input_file_is_open): Likewise.
	* expr.h (expr_build_unary): Remove declaration.
	(expr_build_binary): Likewise.
	* expr.c (expr_build_unary): Remove.
	(expr_build_binary): Likewise.
	* hash.h (hash_replace): Remove declaration.
	(hash_delete): Likewise.
	* hash.c (hash_replace): Remove.
	(hash_delete): Likewise.
	* bignum-copy.c (bignum_copy): Move from here ..
	* config/tc-vax.c (bignum_copy): .. to here.
	* bignum.h (LOG_TO_BASE_2_OF_10): Remove.
	(bignum_copy): Remove extern declaration.
	* sb.h (string_count): Remove extern declaration.
	(sb_build, sb_add_buffer, sb_print, sb_print_at): Likewise.
	(sb_name): Likewise.
	* sb.c (dsize): Replace preprocessor macro with static int.
	(string_count): Make static.
	(sb_build, sb_add_buffer, sb_print, sb_print_at): Likewise.
	(sb_name): Likewise.
	* config/obj-coff.c (dim_index): Make static.
	* config/tc-i386.c (GOT_symbol): Likewise.
	(output_invalid_buf): Likewise.
	* doc/internals.texi (Warning and error messages): Remove the
	prototype for fprint_value.
@
text
@d297 25
d337 29
@


1.15
log
@* as.c (main): Move parse_args before symbol_begin and frag_init so that the
  hash table size can be set before it is used.
* hash.c: Use an unsigned long type for the size of the hash tables.
* hash.h (set_gas_hash_table_size): Update the prototype.
@
text
@a296 25
/* Replace an existing entry in a hash table.  This returns the old
   value stored for the entry.  If the entry is not found in the hash
   table, this does nothing and returns NULL.  */

PTR
hash_replace (struct hash_control *table, const char *key, PTR value)
{
  struct hash_entry *p;
  PTR ret;

  p = hash_lookup (table, key, NULL, NULL);
  if (p == NULL)
    return NULL;

#ifdef HASH_STATISTICS
  ++table->replacements;
#endif

  ret = p->data;

  p->data = value;

  return ret;
}

a311 29
/* Delete an entry from a hash table.  This returns the value stored
   for that entry, or NULL if there is no such entry.  */

PTR
hash_delete (struct hash_control *table, const char *key)
{
  struct hash_entry *p;
  struct hash_entry **list;

  p = hash_lookup (table, key, &list, NULL);
  if (p == NULL)
    return NULL;

  if (p != *list)
    abort ();

#ifdef HASH_STATISTICS
  ++table->deletions;
#endif

  *list = p->next;

  /* Note that we never reclaim the memory for this entry.  If gas
     ever starts deleting hash table entries in a big way, this will
     have to change.  */

  return p->data;
}

@


1.14
log
@* hash.c (DEFAULT_SIZE): Delete.  Replace with:
  (gas_hash_table_size): New static variable.
  (set_gas_hash_table_size): New function:  Records a requested size for the hash tables.
  (get_gas_hash_table_size): New function: Return a prime number near the requested size of the hash table.
  (hash_new): Use get_gas_hash_table_size.
* hash.h: Add a prototype for set_gas_hash_table_size.
* as.c (show_usage): Add description of new switches: --hash-size and --reduce-memory-overheads.
  (option_values): Add OPTION_HASH_TABLE_SIZE and OPTION_REDUCE_MEMORY_OVERHEADS.
  (std_longpopts): Add entries for the new options.
  (parse_args): Handle the new options.
* Makefile.am: Add a dependency of as.c on hash.h.
* Makefile.in: Regenerate.
* doc/as.texinfo: Document the new switches.
* NEWS: Mention the new switches.
@
text
@d76 1
a76 1
static unsigned int gas_hash_table_size = 65537;
d79 1
a79 1
set_gas_hash_table_size (unsigned int size)
d85 1
a85 1
static unsigned int
d89 1
a89 1
  static const unsigned int hash_size_primes[] =
d110 2
a111 1
  unsigned int size;
a112 1
  unsigned int alloc;
@


1.13
log
@update copyright dates
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
a35 4
/* The default number of entries to use when creating a hash table.  */

#define DEFAULT_SIZE (4051)

d71 34
d114 1
a114 1
  size = DEFAULT_SIZE;
d116 1
a116 1
  ret = (struct hash_control *) xmalloc (sizeof *ret);
d119 1
a119 1
  ret->table = (struct hash_entry **) obstack_alloc (&ret->memory, alloc);
@


1.13.4.1
log
@	Thumb32 assembler.

	* include/elf/arm.h: Import full set of relocation names from
	latest AAELF.  Make the primary name of all relocations be the one
	AAELF specifies.  Provide aliases under the traditional names.
	Kill FIRST_INVALID_RELOC_* and LAST_INVALID_RELOC_*.
	* bfd/reloc.c: Reorganize ARM relocations.  Remove ARM relocations
	that are never generated.  Document more of the relocations.  Add
	relocations for Thumb32.
	* bfd/libbfd.h, bfd/bfd-in2.h: Regenerate.
	* bfd/elf32-arm.c: Reorganize howto tables.  Implement Thumb32
	relocations.
	* ld/testsuite/ld-arm/mixed-app.d: Adjust expectations for
	renamed relocations.

	* gas/hash.c (hash_find_n): New interface.
	* gas/hash.h: Prototype it.

	* gas/config/tc-arm.c: Rewrite and reorganize.  Implement 32-bit
	Thumb instructions.
	* gas/testsuite/gas/arm: Convert all "gas_test" style tests to
	"run_dump_test" style tests, for more thorough testing.  Make
	adjustments to expectations where necessary.
	* gas/testsuite/gas/arm/t16-bad.s, gas/testsuite/gas/arm/tcompat.s
	* gas/testsuite/gas/arm/tcompat2.s, gas/testsuite/gas/arm/thumb32.s:
	New test cases.

	* opcodes/arm-dis.c: Add support for Thumb32 instructions and
	16-bit V6T2 instructions.
@
text
@d123 5
d129 1
a129 1
hash_lookup (struct hash_control *table, const char *key, size_t len,
d132 4
a135 3
  unsigned long hash;
  size_t n;
  unsigned int c;
d146 3
a148 1
  for (n = 0; n < len; n++)
a149 1
      c = key[n];
d152 1
d179 1
a179 1
	  if (strncmp (p->string, key, len) == 0 && p->string[len] == '\0')
d210 1
a210 1
  p = hash_lookup (table, key, strlen (key), &list, &hash);
d240 1
a240 1
  p = hash_lookup (table, key, strlen (key), &list, &hash);
d277 1
a277 1
  p = hash_lookup (table, key, strlen (key), NULL, NULL);
d300 1
a300 16
  p = hash_lookup (table, key, strlen (key), NULL, NULL);
  if (p == NULL)
    return NULL;

  return p->data;
}

/* As hash_find, but KEY is of length LEN and is not guaranteed to be
   NUL-terminated.  */

PTR
hash_find_n (struct hash_control *table, const char *key, size_t len)
{
  struct hash_entry *p;

  p = hash_lookup (table, key, len, NULL, NULL);
d316 1
a316 1
  p = hash_lookup (table, key, strlen (key), &list, NULL);
@


1.12
log
@	* hash.c: Convert to ISO-C.
	* hash.h: Likewise.
	* input-file.c: Likewise.
	* input-file.h: Likewise.
	* input-scrub.c: Likewise.
	* itbl-ops.c: Likewise.
	* itbl-ops.h: Likewise.
@
text
@d3 1
a3 1
   2000, 2001, 2002
@


1.11
log
@	* README-vms: Fix comment typos.
	* as.h: Likewise.
	* dwarf2dbg.c: Likewise.
	* ecoff.c: Likewise.
	* hash.c: Likewise.
	* listing.c: Likewise.
	* write.c: Likewise.
@
text
@d78 1
a78 1
hash_new ()
d108 1
a108 2
hash_die (table)
     struct hash_control *table;
d123 4
a126 4
static struct hash_entry *hash_lookup PARAMS ((struct hash_control *,
					       const char *,
					       struct hash_entry ***,
					       unsigned long *));
d129 2
a130 5
hash_lookup (table, key, plist, phash)
     struct hash_control *table;
     const char *key;
     struct hash_entry ***plist;
     unsigned long *phash;
d204 1
a204 4
hash_insert (table, key, value)
     struct hash_control *table;
     const char *key;
     PTR value;
d234 1
a234 4
hash_jam (table, key, value)
     struct hash_control *table;
     const char *key;
     PTR value;
d272 1
a272 4
hash_replace (table, key, value)
     struct hash_control *table;
     const char *key;
     PTR value;
d296 1
a296 3
hash_find (table, key)
     struct hash_control *table;
     const char *key;
d311 1
a311 3
hash_delete (table, key)
     struct hash_control *table;
     const char *key;
d340 2
a341 3
hash_traverse (table, pfn)
     struct hash_control *table;
     void (*pfn) PARAMS ((const char *key, PTR value));
d358 3
a360 4
hash_print_statistics (f, name, table)
     FILE *f ATTRIBUTE_UNUSED;
     const char *name ATTRIBUTE_UNUSED;
     struct hash_control *table ATTRIBUTE_UNUSED;
@


1.10
log
@	* ChangeLog: Fix typos.
	* ChangeLog-9295: Likewise.
	* as.c: Fix comment typos.
	* as.h: Likewise.
	* atof-generic.c: Likewise.
	* bit_fix.h: Likewise.
	* frags.h: Likewise.
	* hash.c: Likewise.
	* input-file.c: Likewise.
	* input-scrub.c: Likewise.
	* itbl-ops.c: Likewise.
	* itbl-parse.y: Likewise.
	* listing.c: Likewise.
	* macro.h: Likewise.
	* read.c: Likewise.
	* sb.c: Likewise.
	* sb.h: Likewise.
	* symbols.c: Likewise.
	* symbols.h: Likewise.
@
text
@d26 1
a26 1
   asssembler.  The assembler does not need to derive structures that
@


1.9
log
@	* ecoff.c: (get_tag): Replace strcpy with xstrdup.
	(ecoff_directive_def): Likewise.
	(ecoff_directive_tag): Likewise.
	* listing.c (file_info): Likewise.
	* hash.c (what): Likewise.
@
text
@d433 1
a433 1
/* Points to curent hash_control.  */
@


1.8
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d3 1
a3 1
   2000, 2001
a548 3
  char *retval;
  char *malloc ();

d551 1
a551 8
  /* Will one day clean up answer here.  */
  retval = malloc (strlen (answer) + 1);
  if (!retval)
    {
      error ("room");
    }
  (void) strcpy (retval, answer);
  return (retval);
@


1.7
log
@Fix copyright notices
@
text
@d3 1
a3 1
   2000
d33 1
d462 1
a462 2
      if (isupper (command))
	command = tolower (command);	/* Ecch!  */
@


1.6
log
@2000-10-30  Kazu Hirata  <kazu@@hxi.com>

	* expr.c: Fix formatting.
	* flonum-copy.c: Likewise.
	* flonum.h: Likewise.
	* gasp.c: Likewise.
	* hash.c: Likewise.
@
text
@d2 2
a3 1
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 98, 99, 2000
@


1.6.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1998, 1999,
   2000
@


1.5
log
@2000-08-09  Kazu Hirata  <kazu@@hxi.com>

	* hash.c: Fix formatting.
@
text
@d40 1
a40 2
struct hash_entry
{
d54 1
a54 2
struct hash_control
{
@


1.4
log
@More warning fixes, and a tweak in tc-hppa.c to check constant
branch offsets a little more thoroughly.
@
text
@d102 1
a102 1
  return ret;  
d225 1
a225 1
  p = (struct hash_entry *) obstack_alloc (&table->memory, sizeof(*p));
d265 1
a265 1
      p = (struct hash_entry *) obstack_alloc (&table->memory, sizeof(*p));
d418 17
a434 8
#define TABLES (6)		/* number of hash tables to maintain */
				/* (at once) in any testing */
#define STATBUFSIZE (12)	/* we can have 12 statistics */

int statbuf[STATBUFSIZE];	/* display statistics here */
char answer[100];		/* human farts here */
char *hashtable[TABLES];	/* we test many hash tables at once */
char *h;			/* points to curent hash_control */
d442 3
a444 2
int number;			/* number 0:TABLES-1 of current hashed */
				/* symbol table */
d463 1
a463 1
	command = tolower (command);	/* ecch! */
d473 2
a474 2
	      printf ("address of hash table #%d control block is %xx\n"
		      ,pp - hashtable, *pp);
d555 1
a555 1
  /* will one day clean up answer here */
a573 1

d582 3
d586 1
a586 2
whattable ()			/* determine number: what hash table to use */
			        /* also determine h: points to hash_control */
a587 1

d609 1
a609 3
#endif /* #ifdef TEST */

/* end of hash.c */
@


1.3
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Fill in structure initializations.  Add variable
	initializations.  Add casts.
	* dwarf2dbg.c (print_stats): Change i to size_t.
	* listing.c (listing_listing): Change list_line to unsigned int.
@
text
@d2 1
a2 1
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 98, 1999
d225 1
a225 1
  p = obstack_alloc (&table->memory, sizeof *p);
d265 1
a265 1
      p = obstack_alloc (&table->memory, sizeof *p);
@


1.2
log
@	* hash.h: Neaten.  Declare hash_traverse.
	* hash.c: Complete rewrite based on BFD hashing code.
@
text
@d377 3
a379 3
     FILE *f;
     const char *name;
     struct hash_control *table;
@


1.1
log
@Initial revision
@
text
@d1 2
a2 2
/* hash.c - hash table lookup strings -
   Copyright (C) 1987, 90, 91, 92, 93, 94, 95, 96, 1998
d18 12
a29 117
   along with GAS; see the file COPYING.  If not, write to
   the Free Software Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */

/*
 * BUGS, GRIPES, APOLOGIA etc.
 *
 * A typical user doesn't need ALL this: I intend to make a library out
 * of it one day - Dean Elsner.
 * Also, I want to change the definition of a symbol to (address,length)
 * so I can put arbitrary binary in the names stored. [see hsh.c for that]
 *
 * This slime is common coupled inside the module. Com-coupling (and other
 * vandalism) was done to speed running time. The interfaces at the
 * module's edges are adequately clean.
 *
 * There is no way to (a) run a test script through this heap and (b)
 * compare results with previous scripts, to see if we have broken any
 * code. Use GNU (f)utilities to do this. A few commands assist test.
 * The testing is awkward: it tries to be both batch & interactive.
 * For now, interactive rules!
 */

/*
 *  The idea is to implement a symbol table. A test jig is here.
 *  Symbols are arbitrary strings; they can't contain '\0'.
 *	[See hsh.c for a more general symbol flavour.]
 *  Each symbol is associated with a char*, which can point to anything
 *  you want, allowing an arbitrary property list for each symbol.
 *
 *  The basic operations are:
 *
 *    new                     creates symbol table, returns handle
 *    find (symbol)           returns char*
 *    insert (symbol,char*)   error if symbol already in table
 *    delete (symbol)         returns char* if symbol was in table
 *    apply                   so you can delete all symbols before die()
 *    die                     destroy symbol table (free up memory)
 *
 *  Supplementary functions include:
 *
 *    say                     how big? what % full?
 *    replace (symbol,newval) report previous value
 *    jam (symbol,value)      assert symbol:=value
 *
 *  You, the caller, have control over errors: this just reports them.
 *
 *  This package requires malloc(), free().
 *  Malloc(size) returns NULL or address of char[size].
 *  Free(address) frees same.
 */

/*
 *  The code and its structures are re-enterent.
 *
 *  Before you do anything else, you must call hash_new() which will
 *  return the address of a hash-table-control-block.  You then use
 *  this address as a handle of the symbol table by passing it to all
 *  the other hash_...() functions.  The only approved way to recover
 *  the memory used by the symbol table is to call hash_die() with the
 *  handle of the symbol table.
 *
 *  Before you call hash_die() you normally delete anything pointed to
 *  by individual symbols. After hash_die() you can't use that symbol
 *  table again.
 *
 *  The char* you associate with a symbol may not be NULL (0) because
 *  NULL is returned whenever a symbol is not in the table. Any other
 *  value is OK, except DELETED, #defined below.
 *
 *  When you supply a symbol string for insertion, YOU MUST PRESERVE THE
 *  STRING until that symbol is deleted from the table. The reason is that
 *  only the address you supply, NOT the symbol string itself, is stored
 *  in the symbol table.
 *
 *  You may delete and add symbols arbitrarily.
 *  Any or all symbols may have the same 'value' (char *). In fact, these
 *  routines don't do anything with your symbol values.
 *
 *  You have no right to know where the symbol:char* mapping is stored,
 *  because it moves around in memory; also because we may change how it
 *  works and we don't want to break your code do we? However the handle
 *  (address of struct hash_control) is never changed in
 *  the life of the symbol table.
 *
 *  What you CAN find out about a symbol table is:
 *    how many slots are in the hash table?
 *    how many slots are filled with symbols?
 *    (total hashes,collisions) for (reads,writes) (*)
 *  All of the above values vary in time.
 *  (*) some of these numbers will not be meaningful if we change the
 *  internals. */

/*
 *  I N T E R N A L
 *
 *  Hash table is an array of hash_entries; each entry is a pointer to a
 *  a string and a user-supplied value 1 char* wide.
 *
 *  The array always has 2 ** n elements, n>0, n integer.
 *  There is also a 'wall' entry after the array, which is always empty
 *  and acts as a sentinel to stop running off the end of the array.
 *  When the array gets too full, we create a new array twice as large
 *  and re-hash the symbols into the new array, then forget the old array.
 *  (Of course, we copy the values into the new array before we junk the
 *  old array!)
 *
 */

#include <stdio.h>

#ifndef FALSE
#define FALSE	(0)
#define TRUE	(!FALSE)
#endif /* no FALSE yet */

#include <ctype.h>
#define min(a, b)	((a) < (b) ? (a) : (b))
d32 1
d34 1
a34 1
#define error	as_fatal
d36 1
a36 28
static char _deleted_[1];
#define DELETED     ((PTR)_deleted_)	/* guarenteed unique address */
#define START_POWER    (10)	/* power of two: size of new hash table */

/* TRUE if a symbol is in entry @@ ptr.  */
#define islive(ptr) (ptr->hash_string && ptr->hash_string!=DELETED)

enum stat_enum {
  /* Number of slots in hash table.  The wall does not count here.
     We expect this is always a power of 2.  */
  STAT_SIZE = 0,
  /* Number of hash_ask calls.  */
  STAT_ACCESS,
  STAT_ACCESS_w,
  /* Number of collisions (total).  This may exceed STAT_ACCESS if we
     have lots of collisions/access.  */
  STAT_COLLIDE,
  STAT_COLLIDE_w,
  /* Slots used right now.  */
  STAT_USED,
  /* How many string compares?  */
  STAT_STRCMP,
  STAT_STRCMP_w,
  /* Size of statistics block... this must be last.  */
  STATLENGTH
};
#define STAT__READ     (0)	/* reading */
#define STAT__WRITE    (1)	/* writing */
d38 1
a38 4
/* When we grow a hash table, by what power of two do we increase it?  */
#define GROW_FACTOR 1
/* When should we grow it?  */
#define FULL_VALUE(N)	((N) / 2)
a39 13
/* #define SUSPECT to do runtime checks */
/* #define TEST to be a test jig for hash...() */

#ifdef TEST
/* TEST: use smaller hash table */
#undef  START_POWER
#define START_POWER (3)
#undef  START_SIZE
#define START_SIZE  (8)
#undef  START_FULL
#define START_FULL  (4)
#endif

d42 9
a50 5
  const char *hash_string;	/* points to where the symbol string is */
  /* NULL means slot is not used */
  /* DELETED means slot was deleted */
  PTR hash_value;		/* user's datum, associated with symbol */
  unsigned long h;
d53 20
a72 9
struct hash_control {
  struct hash_entry *hash_where;/* address of hash table */
  int hash_sizelog;		/* Log of ( hash_mask + 1 ) */
  int hash_mask;		/* masks a hash into index into table */
  int hash_full;		/* when hash_stat[STAT_USED] exceeds this, */
  /* grow table */
  struct hash_entry *hash_wall;	/* point just after last (usable) entry */
  /* here we have some statistics */
  int hash_stat[STATLENGTH];	/* lies & statistics */
a73 2

/*------------------ plan ---------------------------------- i = internal
d75 1
a75 47
  struct hash_control * c;
  struct hash_entry   * e;                                                    i
  int                   b[z];     buffer for statistics
  z         size of b
  char                * s;        symbol string (address) [ key ]
  char                * v;        value string (address)  [datum]
  boolean               f;        TRUE if we found s in hash table            i
  char                * t;        error string; 0 means OK
  int                   a;        access type [0...n)                         i

  c=hash_new       ()             create new hash_control

  hash_die         (c)            destroy hash_control (and hash table)
  table should be empty.
  doesn't check if table is empty.
  c has no meaning after this.

  hash_say         (c,b,z)        report statistics of hash_control.
  also report number of available statistics.

  v=hash_delete    (c,s)          delete symbol, return old value if any.
  ask()                       NULL means no old value.
  f

  v=hash_replace   (c,s,v)        replace old value of s with v.
  ask()                       NULL means no old value: no table change.
  f

  t=hash_insert    (c,s,v)        insert (s,v) in c.
  ask()                       return error string.
  f                           it is an error to insert if s is already
  in table.
  if any error, c is unchanged.

  t=hash_jam       (c,s,v)        assert that new value of s will be v.       i
  ask()                       it may decide to GROW the table.            i
  f                                                                       i
  grow()                                                                  i
  t=hash_grow      (c)            grow the hash table.                        i
  jam()                       will invoke JAM.                            i

  ?=hash_apply     (c,y)          apply y() to every symbol in c.
  y                           evtries visited in 'unspecified' order.

  v=hash_find      (c,s)          return value of s, or NULL if s not in c.
  ask()
  f
a76 21
  f,e=hash_ask()   (c,s,a)        return slot where s SHOULD live.            i
  code()                      maintain collision stats in c.              i

  .=hash_code      (c,s)          compute hash-code for s,                    i
  from parameters of c.                       i

  */

/* Returned by hash_ask() to stop extra testing. hash_ask() wants to
   return both a slot and a status. This is the status.  TRUE: found
   symbol FALSE: absent: empty or deleted slot Also returned by
   hash_jam().  TRUE: we replaced a value FALSE: we inserted a value.  */
static char hash_found;

static struct hash_entry *hash_ask PARAMS ((struct hash_control *,
					    const char *, int));
static int hash_code PARAMS ((struct hash_control *, const char *));
static const char *hash_grow PARAMS ((struct hash_control *));

/* Create a new hash table.  Return NULL if failed; otherwise return handle
   (address of struct hash).  */
d80 23
a102 27
  struct hash_control *retval;
  struct hash_entry *room;	/* points to hash table */
  struct hash_entry *wall;
  struct hash_entry *entry;
  int *ip;		/* scan stats block of struct hash_control */
  int *nd;		/* limit of stats block */

  room = (struct hash_entry *) xmalloc (sizeof (struct hash_entry)
					/* +1 for the wall entry */
					* ((1 << START_POWER) + 1));
  retval = (struct hash_control *) xmalloc (sizeof (struct hash_control));

  nd = retval->hash_stat + STATLENGTH;
  for (ip = retval->hash_stat; ip < nd; ip++)
    *ip = 0;

  retval->hash_stat[STAT_SIZE] = 1 << START_POWER;
  retval->hash_mask = (1 << START_POWER) - 1;
  retval->hash_sizelog = START_POWER;
  /* works for 1's compl ok */
  retval->hash_where = room;
  retval->hash_wall =
    wall = room + (1 << START_POWER);
  retval->hash_full = FULL_VALUE (1 << START_POWER);
  for (entry = room; entry <= wall; entry++)
    entry->hash_string = NULL;
  return retval;
d105 2
a106 10
/*
 *           h a s h _ d i e ( )
 *
 * Table should be empty, but this is not checked.
 * To empty the table, try hash_apply()ing a symbol deleter.
 * Return to free memory both the hash table and it's control
 * block.
 * 'handle' has no meaning after this function.
 * No errors are recoverable.
 */
d108 2
a109 2
hash_die (handle)
     struct hash_control *handle;
d111 2
a112 2
  free ((char *) handle->hash_where);
  free ((char *) handle);
a113 23

#ifdef TEST
/*
 *           h a s h _ s a y ( )
 *
 * Return the size of the statistics table, and as many statistics as
 * we can until either (a) we have run out of statistics or (b) caller
 * has run out of buffer.
 * NOTE: hash_say treats all statistics alike.
 * These numbers may change with time, due to insertions, deletions
 * and expansions of the table.
 * The first "statistic" returned is the length of hash_stat[].
 * Then contents of hash_stat[] are read out (in ascending order)
 * until your buffer or hash_stat[] is exausted.
 */
static void
hash_say (handle, buffer, bufsiz)
     struct hash_control *handle;
     int buffer[ /*bufsiz*/ ];
     int bufsiz;
{
  int *nd;		/* limit of statistics block */
  int *ip;		/* scan statistics */
d115 38
a152 3
  ip = handle->hash_stat;
  nd = ip + min (bufsiz - 1, STATLENGTH);
  if (bufsiz > 0)		/* trust nothing! bufsiz<=0 is dangerous */
d154 3
a156 5
      *buffer++ = STATLENGTH;
      for (; ip < nd; ip++, buffer++)
	{
	  *buffer = *ip;
	}
d158 17
a174 1
}
a175 18

/*
 *           h a s h _ d e l e t e ( )
 *
 * Try to delete a symbol from the table.
 * If it was there, return its value (and adjust STAT_USED).
 * Otherwise, return NULL.
 * Anyway, the symbol is not present after this function.
 *
 */
PTR				/* NULL if string not in table, else */
/* returns value of deleted symbol */
hash_delete (handle, string)
     struct hash_control *handle;
     const char *string;
{
  PTR retval;
  struct hash_entry *entry;
d177 1
a177 8
  entry = hash_ask (handle, string, STAT__WRITE);
  if (hash_found)
    {
      retval = entry->hash_value;
      entry->hash_string = DELETED;
      handle->hash_stat[STAT_USED] -= 1;
#ifdef SUSPECT
      if (handle->hash_stat[STAT_USED] < 0)
d179 15
a193 1
	  error ("hash_delete");
d195 2
a196 1
#endif /* def SUSPECT */
d198 2
a199 5
  else
    {
      retval = NULL;
    }
  return (retval);
d201 10
a210 13

/*
 *                   h a s h _ r e p l a c e ( )
 *
 * Try to replace the old value of a symbol with a new value.
 * Normally return the old value.
 * Return NULL and don't change the table if the symbol is not already
 * in the table.
 */
PTR
hash_replace (handle, string, value)
     struct hash_control *handle;
     const char *string;
d213 19
a231 2
  struct hash_entry *entry;
  char *retval;
d233 1
a233 12
  entry = hash_ask (handle, string, STAT__WRITE);
  if (hash_found)
    {
      retval = entry->hash_value;
      entry->hash_value = value;
    }
  else
    {
      retval = NULL;
    }
  ;
  return retval;
d235 9
a243 13

/*
 *                   h a s h _ i n s e r t ( )
 *
 * Insert a (symbol-string, value) into the hash table.
 * Return an error string, 0 means OK.
 * It is an 'error' to insert an existing symbol.
 */

const char *			/* return error string */
hash_insert (handle, string, value)
     struct hash_control *handle;
     const char *string;
d246 3
a248 2
  struct hash_entry *entry;
  const char *retval;
d250 2
a251 2
  retval = 0;
  if (handle->hash_stat[STAT_USED] > handle->hash_full)
d253 5
a257 1
      retval = hash_grow (handle);
d259 1
a259 1
  if (!retval)
d261 11
a271 11
      entry = hash_ask (handle, string, STAT__WRITE);
      if (hash_found)
	{
	  retval = "exists";
	}
      else
	{
	  entry->hash_value = value;
	  entry->hash_string = string;
	  handle->hash_stat[STAT_USED] += 1;
	}
d273 2
a274 1
  return retval;
d276 9
a284 19

/*
 *               h a s h _ j a m ( )
 *
 * Regardless of what was in the symbol table before, after hash_jam()
 * the named symbol has the given value. The symbol is either inserted or
 * (its value is) replaced.
 * An error message string is returned, 0 means OK.
 *
 * WARNING: this may decide to grow the hashed symbol table.
 * To do this, we call hash_grow(), WHICH WILL recursively CALL US.
 *
 * We report status internally: hash_found is TRUE if we replaced, but
 * false if we inserted.
 */
const char *
hash_jam (handle, string, value)
     struct hash_control *handle;
     const char *string;
d287 2
a288 2
  const char *retval;
  struct hash_entry *entry;
d290 3
a292 17
  retval = 0;
  if (handle->hash_stat[STAT_USED] > handle->hash_full)
    {
      retval = hash_grow (handle);
    }
  if (!retval)
    {
      entry = hash_ask (handle, string, STAT__WRITE);
      if (!hash_found)
	{
	  entry->hash_string = string;
	  handle->hash_stat[STAT_USED] += 1;
	}
      entry->hash_value = value;
    }
  return retval;
}
d294 2
a295 27
/*
 *               h a s h _ g r o w ( )
 *
 * Grow a new (bigger) hash table from the old one.
 * We choose to double the hash table's size.
 * Return a human-scrutible error string: 0 if OK.
 * Warning! This uses hash_jam(), which had better not recurse
 * back here! Hash_jam() conditionally calls us, but we ALWAYS
 * call hash_jam()!
 * Internal.
 */
static const char *
hash_grow (handle)		/* make a hash table grow */
     struct hash_control *handle;
{
  struct hash_entry *newwall;
  struct hash_entry *newwhere;
  struct hash_entry *newtrack;
  struct hash_entry *oldtrack;
  struct hash_entry *oldwhere;
  struct hash_entry *oldwall;
  int temp;
  int newsize;
  const char *string;
  const char *retval;
#ifdef SUSPECT
  int oldused;
d298 1
a298 45
  /*
   * capture info about old hash table
   */
  oldwhere = handle->hash_where;
  oldwall = handle->hash_wall;
#ifdef SUSPECT
  oldused = handle->hash_stat[STAT_USED];
#endif
  /*
   * attempt to get enough room for a hash table twice as big
   */
  temp = handle->hash_stat[STAT_SIZE];
  newwhere = ((struct hash_entry *)
	      xmalloc ((unsigned long) ((temp << (GROW_FACTOR + 1))
					/* +1 for wall slot */
					* sizeof (struct hash_entry))));
  if (newwhere == NULL)
    return "no_room";

  /*
   * have enough room: now we do all the work.
   * double the size of everything in handle.
   */
  handle->hash_mask = ((handle->hash_mask + 1) << GROW_FACTOR) - 1;
  handle->hash_stat[STAT_SIZE] <<= GROW_FACTOR;
  newsize = handle->hash_stat[STAT_SIZE];
  handle->hash_where = newwhere;
  handle->hash_full <<= GROW_FACTOR;
  handle->hash_sizelog += GROW_FACTOR;
  handle->hash_wall = newwall = newwhere + newsize;
  /* Set all those pesky new slots to vacant.  */
  for (newtrack = newwhere; newtrack <= newwall; newtrack++)
    newtrack->hash_string = NULL;
  /* We will do a scan of the old table, the hard way, using the
   * new control block to re-insert the data into new hash table.  */
  handle->hash_stat[STAT_USED] = 0;
  for (oldtrack = oldwhere; oldtrack < oldwall; oldtrack++)
    if (((string = oldtrack->hash_string) != NULL) && string != DELETED)
      if ((retval = hash_jam (handle, string, oldtrack->hash_value)))
	return retval;

#ifdef SUSPECT
  if (handle->hash_stat[STAT_USED] != oldused)
    return "hash_used";
#endif
d300 1
a300 3
  /* We have a completely faked up control block.
     Return the old hash table.  */
  free ((char *) oldwhere);
d302 1
a302 1
  return 0;
d304 8
a311 44

#ifdef TEST
/*
 *          h a s h _ a p p l y ( )
 *
 * Use this to scan each entry in symbol table.
 * For each symbol, this calls (applys) a nominated function supplying the
 * symbol's value (and the symbol's name).
 * The idea is you use this to destroy whatever is associted with
 * any values in the table BEFORE you destroy the table with hash_die.
 * Of course, you can use it for other jobs; whenever you need to
 * visit all extant symbols in the table.
 *
 * We choose to have a call-you-back idea for two reasons:
 *  asthetic: it is a neater idea to use apply than an explicit loop
 *  sensible: if we ever had to grow the symbol table (due to insertions)
 *            then we would lose our place in the table when we re-hashed
 *            symbols into the new table in a different order.
 *
 * The order symbols are visited depends entirely on the hashing function.
 * Whenever you insert a (symbol, value) you risk expanding the table. If
 * you do expand the table, then the hashing function WILL change, so you
 * MIGHT get a different order of symbols visited. In other words, if you
 * want the same order of visiting symbols as the last time you used
 * hash_apply() then you better not have done any hash_insert()s or
 * hash_jam()s since the last time you used hash_apply().
 *
 * In future we may use the value returned by your nominated function.
 * One idea is to abort the scan if, after applying the function to a
 * certain node, the function returns a certain code.
 *
 * The function you supply should be of the form:
 *      void myfunct(string,value)
 *              char * string;        |* the symbol's name *|
 *              char * value;         |* the symbol's value *|
 *      {
 *        |* ... *|
 *      }
 *
 */
void
hash_apply (handle, function)
     struct hash_control *handle;
     void (*function) ();
d313 1
a313 2
  struct hash_entry *entry;
  struct hash_entry *wall;
d315 5
a319 8
  wall = handle->hash_wall;
  for (entry = handle->hash_where; entry < wall; entry++)
    {
      if (islive (entry))	/* silly code: tests entry->string twice! */
	{
	  (*function) (entry->hash_string, entry->hash_value);
	}
    }
d321 4
a324 8
#endif

/*
 *          h a s h _ f i n d ( )
 *
 * Given symbol string, find value (if any).
 * Return found value or NULL.
 */
d326 3
a328 3
hash_find (handle, string)
     struct hash_control *handle;
     const char *string;
d330 2
a331 1
  struct hash_entry *entry;
d333 2
a334 4
  entry = hash_ask (handle, string, STAT__READ);
  if (hash_found)
    return entry->hash_value;
  else
d336 15
d352 8
a359 15

/*
 *          h a s h _ a s k ( )
 *
 * Searches for given symbol string.
 * Return the slot where it OUGHT to live. It may be there.
 * Return hash_found: TRUE only if symbol is in that slot.
 * Access argument is to help keep statistics in control block.
 * Internal.
 */
static struct hash_entry *	/* string slot, may be empty or deleted */
hash_ask (handle, string, access_type)
     struct hash_control *handle;
     const char *string;
     int access_type;
d361 3
a363 14
  const char *s;
  struct hash_entry *slot;
  int collision;	/* count collisions */
  int strcmps;
  int hcode;

  /* start looking here */
  hcode = hash_code (handle, string);
  slot = handle->hash_where + (hcode & handle->hash_mask);

  handle->hash_stat[STAT_ACCESS + access_type] += 1;
  collision = strcmps = 0;
  hash_found = FALSE;
  while (((s = slot->hash_string) != NULL) && s != DELETED)
d365 4
a368 54
      if (string == s)
	{
	  hash_found = TRUE;
	  break;
	}
      if (slot->h == (unsigned long) hcode)
	{
	  if (!strcmp (string, s))
	    {
	      hash_found = TRUE;
	      break;
	    }
	  strcmps++;
	}
      collision++;
      slot++;
    }
  /*
   * slot:                                                      return:
   *       in use:     we found string                           slot
   *       at empty:
   *                   at wall:        we fell off: wrap round   ????
   *                   in table:       dig here                  slot
   *       at DELETED: dig here                                  slot
   */
  if (slot == handle->hash_wall)
    {
      slot = handle->hash_where;/* now look again */
      while (((s = slot->hash_string) != NULL) && s != DELETED)
	{
	  if (string == s)
	    {
	      hash_found = TRUE;
	      break;
	    }
	  if (slot->h == (unsigned long) hcode)
	    {
	      if (!strcmp (string, s))
		{
		  hash_found = TRUE;
		  break;
		}
	      strcmps++;
	    }
	  collision++;
	  slot++;
	}
      /*
       * slot:                                                   return:
       *       in use: we found it                                slot
       *       empty:  wall:         ERROR IMPOSSIBLE             !!!!
       *               in table:     dig here                     slot
       *       DELETED:dig here                                   slot
       */
a369 5
  handle->hash_stat[STAT_COLLIDE + access_type] += collision;
  handle->hash_stat[STAT_STRCMP + access_type] += strcmps;
  if (!hash_found)
    slot->h = hcode;
  return slot;			/* also return hash_found */
a370 18

/*
 *           h a s h _ c o d e
 *
 * Does hashing of symbol string to hash number.
 * Internal.
 */
static int
hash_code (handle, string)
     struct hash_control *handle;
     const char *string;
{
#if 1 /* There seems to be some interesting property of this function
	 that prevents the bfd version below from being an adequate
	 substitute.  @@@@ Figure out what this property is!  */
  long h;		/* hash code built here */
  long c;		/* each character lands here */
  int n;		/* Amount to shift h by */
d372 2
a373 13
  n = (handle->hash_sizelog - 3);
  h = 0;
  while ((c = *string++) != 0)
    {
      h += c;
      h = (h << 3) + (h >> n) + c;
    }
  return h;
#else
  /* from bfd */
  unsigned long h = 0;
  unsigned int len = 0;
  unsigned int c;
a374 12
  while ((c = *string++) != 0)
    {
      h += c + (c << 17);
      h ^= h >> 2;
      ++len;
    }
  h += len + (len << 17);
  h ^= h >> 2;
  return h;
#endif
}

d376 2
a377 2
hash_print_statistics (file, name, h)
     FILE *file;
d379 1
a379 1
     struct hash_control *h;
d381 18
a398 1
  unsigned long sz, used, pct;
d400 8
a407 2
  if (h == 0)
    return;
d409 3
a411 18
  sz = h->hash_stat[STAT_SIZE];
  used = h->hash_stat[STAT_USED];
  pct = (used * 100 + sz / 2) / sz;

  fprintf (file, "%s hash statistics:\n\t%lu/%lu slots used (%lu%%)\n",
	   name, used, sz, pct);

#define P(name, off)							\
  fprintf (file, "\t%-16s %6dr + %6dw = %7d\n", name,			\
	   h->hash_stat[off+STAT__READ],				\
	   h->hash_stat[off+STAT__WRITE],				\
	   h->hash_stat[off+STAT__READ] + h->hash_stat[off+STAT__WRITE])

  P ("accesses:", STAT_ACCESS);
  P ("collisions:", STAT_COLLIDE);
  P ("string compares:", STAT_STRCMP);

#undef P
a413 3
/*
 * Here is a test program to exercise above.
 */
d416 2
d419 1
a419 1
/* (at once) in any testing */
d434 1
a434 1
/* symbol table */
d436 1
d468 1
a468 1
	  hash_apply (h, applicatee);
d471 1
a471 1
	  hash_apply (h, destroy);
d573 1
d575 1
a575 1
     /* also determine h: points to hash_control */
a597 2


@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

