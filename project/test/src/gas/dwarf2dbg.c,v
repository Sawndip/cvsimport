head	1.121;
access;
symbols
	binutils-2_24-branch:1.121.0.2
	binutils-2_24-branchpoint:1.121
	binutils-2_21_1:1.107.2.1
	binutils-2_23_2:1.116.2.1
	binutils-2_23_1:1.116
	binutils-2_23:1.116
	binutils-2_23-branch:1.116.0.2
	binutils-2_23-branchpoint:1.116
	binutils-2_22_branch:1.114.0.4
	binutils-2_22:1.114
	binutils-2_22-branch:1.114.0.2
	binutils-2_22-branchpoint:1.114
	binutils-2_21:1.107
	binutils-2_21-branch:1.107.0.2
	binutils-2_21-branchpoint:1.107
	binutils-2_20_1:1.104.2.1
	binutils-2_20:1.104.2.1
	binutils-arc-20081103-branch:1.98.0.6
	binutils-arc-20081103-branchpoint:1.98
	binutils-2_20-branch:1.104.0.2
	binutils-2_20-branchpoint:1.104
	dje-cgen-play1-branch:1.102.0.2
	dje-cgen-play1-branchpoint:1.102
	arc-20081103-branch:1.98.0.4
	arc-20081103-branchpoint:1.98
	binutils-2_19_1:1.98
	binutils-2_19:1.98
	binutils-2_19-branch:1.98.0.2
	binutils-2_19-branchpoint:1.98
	binutils-2_18:1.89.2.1
	binutils-2_18-branch:1.89.0.2
	binutils-2_18-branchpoint:1.89
	binutils-csl-coldfire-4_1-32:1.81.2.1
	binutils-csl-sourcerygxx-4_1-32:1.81.2.1
	binutils-csl-innovasic-fido-3_4_4-33:1.81.2.1
	binutils-csl-sourcerygxx-3_4_4-32:1.74
	binutils-csl-coldfire-4_1-30:1.81.2.1
	binutils-csl-sourcerygxx-4_1-30:1.81.2.1
	binutils-csl-coldfire-4_1-28:1.81.2.1
	binutils-csl-sourcerygxx-4_1-29:1.81.2.1
	binutils-csl-sourcerygxx-4_1-28:1.81.2.1
	binutils-csl-arm-2006q3-27:1.81.2.1
	binutils-csl-sourcerygxx-4_1-27:1.81.2.1
	binutils-csl-arm-2006q3-26:1.81.2.1
	binutils-csl-sourcerygxx-4_1-26:1.81.2.1
	binutils-csl-sourcerygxx-4_1-25:1.81.2.1
	binutils-csl-sourcerygxx-4_1-24:1.81.2.1
	binutils-csl-sourcerygxx-4_1-23:1.81.2.1
	binutils-csl-sourcerygxx-4_1-21:1.81.2.1
	binutils-csl-arm-2006q3-21:1.81.2.1
	binutils-csl-sourcerygxx-4_1-22:1.81.2.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.81.2.1
	binutils-csl-sourcerygxx-4_1-20:1.81.2.1
	binutils-csl-arm-2006q3-19:1.81.2.1
	binutils-csl-sourcerygxx-4_1-19:1.81.2.1
	binutils-csl-sourcerygxx-4_1-18:1.81.2.1
	binutils-csl-renesas-4_1-9:1.81.2.1
	binutils-csl-sourcerygxx-3_4_4-25:1.74
	binutils-csl-renesas-4_1-8:1.81
	binutils-csl-renesas-4_1-7:1.81
	binutils-csl-renesas-4_1-6:1.81
	binutils-csl-sourcerygxx-4_1-17:1.81
	binutils-csl-sourcerygxx-4_1-14:1.81
	binutils-csl-sourcerygxx-4_1-15:1.81
	binutils-csl-sourcerygxx-4_1-13:1.81
	binutils-2_17:1.81.4.1
	binutils-csl-sourcerygxx-4_1-12:1.81
	binutils-csl-sourcerygxx-3_4_4-21:1.81
	binutils-csl-wrs-linux-3_4_4-24:1.74
	binutils-csl-wrs-linux-3_4_4-23:1.74
	binutils-csl-sourcerygxx-4_1-9:1.81
	binutils-csl-sourcerygxx-4_1-8:1.81
	binutils-csl-sourcerygxx-4_1-7:1.81
	binutils-csl-arm-2006q1-6:1.81
	binutils-csl-sourcerygxx-4_1-6:1.81
	binutils-csl-wrs-linux-3_4_4-22:1.74
	binutils-csl-coldfire-4_1-11:1.81
	binutils-csl-sourcerygxx-3_4_4-19:1.81
	binutils-csl-coldfire-4_1-10:1.81
	binutils-csl-sourcerygxx-4_1-5:1.81
	binutils-csl-sourcerygxx-4_1-4:1.81
	binutils-csl-wrs-linux-3_4_4-21:1.74
	binutils-csl-morpho-4_1-4:1.81
	binutils-csl-sourcerygxx-3_4_4-17:1.81
	binutils-csl-wrs-linux-3_4_4-20:1.74
	binutils-2_17-branch:1.81.0.4
	binutils-2_17-branchpoint:1.81
	binutils-csl-2_17-branch:1.81.0.2
	binutils-csl-2_17-branchpoint:1.81
	binutils-csl-gxxpro-3_4-branch:1.74.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.74
	binutils-2_16_1:1.74
	binutils-csl-arm-2005q1b:1.74
	binutils-2_16:1.74
	binutils-csl-arm-2005q1a:1.74
	binutils-csl-arm-2005q1-branch:1.74.0.4
	binutils-csl-arm-2005q1-branchpoint:1.74
	binutils-2_16-branch:1.74.0.2
	binutils-2_16-branchpoint:1.74
	csl-arm-2004-q3d:1.71
	csl-arm-2004-q3:1.70
	binutils-2_15:1.69
	binutils-2_15-branchpoint:1.69
	csl-arm-2004-q1a:1.70
	csl-arm-2004-q1:1.69
	binutils-2_15-branch:1.69.0.4
	cagney_bfdfile-20040213-branch:1.69.0.2
	cagney_bfdfile-20040213-branchpoint:1.69
	cagney_bigcore-20040122-branch:1.67.0.2
	cagney_bigcore-20040122-branchpoint:1.67
	csl-arm-2003-q4:1.67
	binutils-2_14:1.62
	binutils-2_14-branch:1.62.0.2
	binutils-2_14-branchpoint:1.62
	binutils-2_13_2_1:1.51.2.2
	binutils-2_13_2:1.51.2.2
	binutils-2_13_1:1.51.2.2
	binutils-2_13:1.51.2.1
	binutils-2_13-branchpoint:1.51
	binutils-2_13-branch:1.51.0.2
	binutils-2_12_1:1.44
	binutils-2_12:1.44
	binutils-2_12-branch:1.44.0.2
	binutils-2_12-branchpoint:1.44
	cygnus_cvs_20020108_pre:1.44
	binutils-2_11_2:1.31.2.4
	binutils-2_11_1:1.31.2.4
	binutils-2_11:1.31.2.2
	x86_64versiong3:1.33
	binutils-2_11-branch:1.31.0.2
	binutils-2_10_1:1.14
	binutils-2_10:1.14
	binutils-2_10-branch:1.14.0.2
	binutils-2_10-branchpoint:1.14
	binutils_latest_snapshot:1.121
	repo-unification-2000-02-06:1.13
	binu_ss_19990721:1.10;
locks; strict;
comment	@ * @;


1.121
date	2013.06.14.13.30.28;	author rsandifo;	state Exp;
branches;
next	1.120;

1.120
date	2013.06.14.13.24.40;	author rsandifo;	state Exp;
branches;
next	1.119;

1.119
date	2013.04.29.13.38.58;	author nickc;	state Exp;
branches;
next	1.118;

1.118
date	2012.11.09.08.29.31;	author hjl;	state Exp;
branches;
next	1.117;

1.117
date	2012.08.01.13.46.55;	author jwlemke;	state Exp;
branches;
next	1.116;

1.116
date	2012.06.28.11.31.13;	author nickc;	state Exp;
branches
	1.116.2.1;
next	1.115;

1.115
date	2012.04.30.14.32.28;	author mark;	state Exp;
branches;
next	1.114;

1.114
date	2011.09.08.12.18.27;	author rsandifo;	state Exp;
branches;
next	1.113;

1.113
date	2011.09.05.19.18.59;	author rsandifo;	state Exp;
branches;
next	1.112;

1.112
date	2011.07.28.16.35.46;	author nickc;	state Exp;
branches;
next	1.111;

1.111
date	2011.03.31.08.02.41;	author gingold;	state Exp;
branches;
next	1.110;

1.110
date	2011.03.10.18.26.28;	author msnyder;	state Exp;
branches;
next	1.109;

1.109
date	2011.03.10.00.52.09;	author msnyder;	state Exp;
branches;
next	1.108;

1.108
date	2011.02.28.18.32.52;	author ktietz;	state Exp;
branches;
next	1.107;

1.107
date	2010.07.05.15.07.19;	author hjl;	state Exp;
branches
	1.107.2.1;
next	1.106;

1.106
date	2009.12.11.13.42.09;	author nickc;	state Exp;
branches;
next	1.105;

1.105
date	2009.09.11.15.27.33;	author nickc;	state Exp;
branches;
next	1.104;

1.104
date	2009.09.02.07.24.19;	author amodra;	state Exp;
branches
	1.104.2.1;
next	1.103;

1.103
date	2009.07.10.15.26.58;	author tromey;	state Exp;
branches;
next	1.102;

1.102
date	2009.06.22.17.56.00;	author nickc;	state Exp;
branches;
next	1.101;

1.101
date	2009.04.24.18.31.28;	author ccoutant;	state Exp;
branches;
next	1.100;

1.100
date	2009.03.03.10.04.58;	author gingold;	state Exp;
branches;
next	1.99;

1.99
date	2009.01.15.12.42.52;	author nickc;	state Exp;
branches;
next	1.98;

1.98
date	2008.08.05.08.13.48;	author amodra;	state Exp;
branches;
next	1.97;

1.97
date	2008.08.04.10.55.47;	author amodra;	state Exp;
branches;
next	1.96;

1.96
date	2008.04.07.23.56.18;	author amodra;	state Exp;
branches;
next	1.95;

1.95
date	2008.01.09.17.30.58;	author bwilson;	state Exp;
branches;
next	1.94;

1.94
date	2007.11.19.19.37.18;	author bwilson;	state Exp;
branches;
next	1.93;

1.93
date	2007.11.19.19.33.23;	author bwilson;	state Exp;
branches;
next	1.92;

1.92
date	2007.11.19.18.15.53;	author bwilson;	state Exp;
branches;
next	1.91;

1.91
date	2007.08.29.20.03.43;	author drow;	state Exp;
branches;
next	1.90;

1.90
date	2007.08.24.21.49.55;	author jsm28;	state Exp;
branches;
next	1.89;

1.89
date	2007.07.03.11.01.02;	author nickc;	state Exp;
branches
	1.89.2.1;
next	1.88;

1.88
date	2006.10.13.11.36.03;	author nickc;	state Exp;
branches;
next	1.87;

1.87
date	2006.08.08.19.09.33;	author bwilson;	state Exp;
branches;
next	1.86;

1.86
date	2006.08.08.08.29.08;	author nickc;	state Exp;
branches;
next	1.85;

1.85
date	2006.06.07.11.27.57;	author amodra;	state Exp;
branches;
next	1.84;

1.84
date	2006.05.05.16.55.28;	author nickc;	state Exp;
branches;
next	1.83;

1.83
date	2006.05.03.23.52.15;	author amodra;	state Exp;
branches;
next	1.82;

1.82
date	2006.04.28.04.07.33;	author amodra;	state Exp;
branches;
next	1.81;

1.81
date	2006.02.28.00.38.19;	author amodra;	state Exp;
branches
	1.81.2.1
	1.81.4.1;
next	1.80;

1.80
date	2005.09.20.21.00.15;	author rth;	state Exp;
branches;
next	1.79;

1.79
date	2005.09.20.18.24.43;	author rth;	state Exp;
branches;
next	1.78;

1.78
date	2005.09.07.19.22.40;	author rth;	state Exp;
branches;
next	1.77;

1.77
date	2005.09.07.11.41.24;	author rth;	state Exp;
branches;
next	1.76;

1.76
date	2005.08.11.01.25.20;	author amodra;	state Exp;
branches;
next	1.75;

1.75
date	2005.05.05.09.12.44;	author nickc;	state Exp;
branches;
next	1.74;

1.74
date	2005.03.03.01.29.52;	author amodra;	state Exp;
branches;
next	1.73;

1.73
date	2005.01.27.16.33.41;	author nathan;	state Exp;
branches;
next	1.72;

1.72
date	2004.11.22.16.29.33;	author bwilson;	state Exp;
branches;
next	1.71;

1.71
date	2004.11.02.09.49.25;	author nickc;	state Exp;
branches;
next	1.70;

1.70
date	2004.04.29.16.40.18;	author nickc;	state Exp;
branches;
next	1.69;

1.69
date	2004.02.13.16.12.46;	author aj;	state Exp;
branches;
next	1.68;

1.68
date	2004.02.06.16.00.20;	author nathan;	state Exp;
branches;
next	1.67;

1.67
date	2003.12.06.16.16.51;	author kazu;	state Exp;
branches;
next	1.66;

1.66
date	2003.11.23.02.14.21;	author kazu;	state Exp;
branches;
next	1.65;

1.65
date	2003.11.21.13.28.35;	author kazu;	state Exp;
branches;
next	1.64;

1.64
date	2003.07.16.03.09.31;	author amodra;	state Exp;
branches;
next	1.63;

1.63
date	2003.05.27.16.00.04;	author rth;	state Exp;
branches;
next	1.62;

1.62
date	2003.04.21.18.23.25;	author rth;	state Exp;
branches;
next	1.61;

1.61
date	2003.03.11.22.00.33;	author rth;	state Exp;
branches;
next	1.60;

1.60
date	2003.01.28.11.20.36;	author nickc;	state Exp;
branches;
next	1.59;

1.59
date	2002.12.25.21.20.31;	author aoliva;	state Exp;
branches;
next	1.58;

1.58
date	2002.12.04.01.03.05;	author amodra;	state Exp;
branches;
next	1.57;

1.57
date	2002.11.30.08.39.42;	author amodra;	state Exp;
branches;
next	1.56;

1.56
date	2002.11.26.21.55.15;	author dj;	state Exp;
branches;
next	1.55;

1.55
date	2002.11.18.21.08.52;	author kevinb;	state Exp;
branches;
next	1.54;

1.54
date	2002.09.17.02.55.57;	author rth;	state Exp;
branches;
next	1.53;

1.53
date	2002.08.27.11.09.42;	author amodra;	state Exp;
branches;
next	1.52;

1.52
date	2002.08.01.15.04.41;	author drow;	state Exp;
branches;
next	1.51;

1.51
date	2002.06.14.14.08.51;	author drow;	state Exp;
branches
	1.51.2.1;
next	1.50;

1.50
date	2002.05.23.06.51.41;	author hjl;	state Exp;
branches;
next	1.49;

1.49
date	2002.05.22.16.15.18;	author hjl;	state Exp;
branches;
next	1.48;

1.48
date	2002.05.13.10.24.14;	author nickc;	state Exp;
branches;
next	1.47;

1.47
date	2002.05.11.10.32.35;	author nickc;	state Exp;
branches;
next	1.46;

1.46
date	2002.05.03.02.25.33;	author kazu;	state Exp;
branches;
next	1.45;

1.45
date	2002.04.17.23.08.42;	author geoffk;	state Exp;
branches;
next	1.44;

1.44
date	2001.12.04.23.07.26;	author msnyder;	state Exp;
branches;
next	1.43;

1.43
date	2001.11.15.05.18.22;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2001.09.18.10.08.14;	author amodra;	state Exp;
branches;
next	1.41;

1.41
date	2001.08.01.01.44.25;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2001.06.19.05.40.55;	author amodra;	state Exp;
branches;
next	1.39;

1.39
date	2001.05.22.10.23.48;	author amodra;	state Exp;
branches;
next	1.38;

1.38
date	2001.04.12.16.00.32;	author jason;	state Exp;
branches;
next	1.37;

1.37
date	2001.03.30.07.07.09;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2001.03.30.02.19.36;	author amodra;	state Exp;
branches;
next	1.35;

1.35
date	2001.03.17.18.23.41;	author rth;	state Exp;
branches;
next	1.34;

1.34
date	2001.03.08.23.24.22;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	2001.02.24.04.59.03;	author hjl;	state Exp;
branches;
next	1.32;

1.32
date	2001.02.01.18.08.47;	author rth;	state Exp;
branches;
next	1.31;

1.31
date	2000.12.22.20.36.02;	author hjl;	state Exp;
branches
	1.31.2.1;
next	1.30;

1.30
date	2000.12.14.20.29.25;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	2000.12.14.20.16.20;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2000.12.14.01.12.43;	author kazu;	state Exp;
branches;
next	1.27;

1.27
date	2000.12.13.18.48.04;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	2000.12.13.18.46.41;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2000.12.13.18.42.28;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2000.12.12.21.21.39;	author hjl;	state Exp;
branches;
next	1.23;

1.23
date	2000.12.05.00.56.02;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2000.11.29.21.42.41;	author rth;	state Exp;
branches;
next	1.21;

1.21
date	2000.11.17.18.07.32;	author rth;	state Exp;
branches;
next	1.20;

1.20
date	2000.11.17.08.47.51;	author rth;	state Exp;
branches;
next	1.19;

1.19
date	2000.11.13.01.10.05;	author hjl;	state Exp;
branches;
next	1.18;

1.18
date	2000.11.07.01.18.45;	author kazu;	state Exp;
branches;
next	1.17;

1.17
date	2000.10.25.19.15.33;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2000.10.17.20.21.45;	author kazu;	state Exp;
branches;
next	1.15;

1.15
date	2000.08.18.01.42.14;	author kazu;	state Exp;
branches;
next	1.14;

1.14
date	2000.02.22.07.21.23;	author ian;	state Exp;
branches;
next	1.13;

1.13
date	99.08.27.09.03.18;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	99.08.26.12.13.01;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	99.08.26.11.11.43;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	99.07.15.11.27.08;	author ian;	state Exp;
branches;
next	1.9;

1.9
date	99.07.11.20.19.55;	author ian;	state Exp;
branches;
next	1.8;

1.8
date	99.06.26.16.10.10;	author rth;	state Exp;
branches;
next	1.7;

1.7
date	99.06.12.08.53.18;	author ian;	state Exp;
branches;
next	1.6;

1.6
date	99.06.12.08.47.59;	author ian;	state Exp;
branches;
next	1.5;

1.5
date	99.06.11.21.06.43;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	99.06.05.23.15.28;	author rth;	state Exp;
branches;
next	1.3;

1.3
date	99.06.05.18.19.03;	author rth;	state Exp;
branches;
next	1.2;

1.2
date	99.06.03.03.20.21;	author rth;	state Exp;
branches;
next	1.1;

1.1
date	99.06.03.02.51.53;	author rth;	state Exp;
branches;
next	;

1.116.2.1
date	2013.01.21.13.48.43;	author amodra;	state Exp;
branches;
next	;

1.107.2.1
date	2011.05.29.04.51.34;	author amodra;	state Exp;
branches;
next	;

1.104.2.1
date	2009.09.11.15.28.43;	author nickc;	state Exp;
branches;
next	;

1.89.2.1
date	2007.08.24.21.56.45;	author jsm28;	state Exp;
branches;
next	;

1.81.2.1
date	2006.08.22.15.08.31;	author jsm28;	state Exp;
branches;
next	;

1.81.4.1
date	2006.05.10.02.15.25;	author amodra;	state Exp;
branches;
next	;

1.51.2.1
date	2002.08.01.15.03.02;	author drow;	state Exp;
branches;
next	1.51.2.2;

1.51.2.2
date	2002.09.23.22.14.22;	author drow;	state Exp;
branches;
next	;

1.31.2.1
date	2001.02.01.18.10.44;	author rth;	state Exp;
branches;
next	1.31.2.2;

1.31.2.2
date	2001.04.02.21.53.30;	author pb;	state Exp;
branches;
next	1.31.2.3;

1.31.2.3
date	2001.06.07.03.15.24;	author amodra;	state Exp;
branches;
next	1.31.2.4;

1.31.2.4
date	2001.06.11.10.04.44;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.121
log
@gas/
	* dwarf2dbg.h (dwarf2_move_insn): Declare.
	* dwarf2dbg.c (line_subseg): Add pmove_tail.
	(get_line_subseg): Add create_p argument.  Initialize pmove_tail.
	(dwarf2_gen_line_info_1): Update call accordingly.
	(dwarf2_move_insn): New function.
	* config/tc-mips.c (append_insn): Use dwarf2_move_insn.

gas/testsuite/
	* gas/mips/loc-swap-3.d, gas/mips/loc-swap-3.s: New test.
	* gas/mips/mips.exp: Run it.
@
text
@/* dwarf2dbg.c - DWARF2 debug support
   Copyright 1999-2013 Free Software Foundation, Inc.
   Contributed by David Mosberger-Tang <davidm@@hpl.hp.com>

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Logical line numbers can be controlled by the compiler via the
   following directives:

	.file FILENO "file.c"
	.loc  FILENO LINENO [COLUMN] [basic_block] [prologue_end] \
	      [epilogue_begin] [is_stmt VALUE] [isa VALUE] \
	      [discriminator VALUE]
*/

#include "as.h"
#include "safe-ctype.h"

#ifdef HAVE_LIMITS_H
#include <limits.h>
#else
#ifdef HAVE_SYS_PARAM_H
#include <sys/param.h>
#endif
#ifndef INT_MAX
#define INT_MAX (int) (((unsigned) (-1)) >> 1)
#endif
#endif

#include "dwarf2dbg.h"
#include <filenames.h>

#ifdef HAVE_DOS_BASED_FILE_SYSTEM
/* We need to decide which character to use as a directory separator.
   Just because HAVE_DOS_BASED_FILE_SYSTEM is defined, it does not
   necessarily mean that the backslash character is the one to use.
   Some environments, eg Cygwin, can support both naming conventions.
   So we use the heuristic that we only need to use the backslash if
   the path is an absolute path starting with a DOS style drive
   selector.  eg C: or D:  */
# define INSERT_DIR_SEPARATOR(string, offset) \
  do \
    { \
      if (offset > 1 \
	  && string[0] != 0 \
	  && string[1] == ':') \
       string [offset] = '\\'; \
      else \
       string [offset] = '/'; \
    } \
  while (0)
#else
# define INSERT_DIR_SEPARATOR(string, offset) string[offset] = '/'
#endif

#ifndef DWARF2_FORMAT
# define DWARF2_FORMAT(SEC) dwarf2_format_32bit
#endif

#ifndef DWARF2_ADDR_SIZE
# define DWARF2_ADDR_SIZE(bfd) (bfd_arch_bits_per_address (bfd) / 8)
#endif

#ifndef DWARF2_FILE_NAME
#define DWARF2_FILE_NAME(FILENAME, DIRNAME) FILENAME
#endif

#ifndef DWARF2_FILE_TIME_NAME
#define DWARF2_FILE_TIME_NAME(FILENAME,DIRNAME) 0
#endif

#ifndef DWARF2_FILE_SIZE_NAME
#define DWARF2_FILE_SIZE_NAME(FILENAME,DIRNAME) 0
#endif

#ifndef DWARF2_VERSION
#define DWARF2_VERSION 2
#endif

/* The .debug_aranges version has been 2 in DWARF version 2, 3 and 4. */
#ifndef DWARF2_ARANGES_VERSION
#define DWARF2_ARANGES_VERSION 2
#endif

/* This implementation output version 2 .debug_line information. */
#ifndef DWARF2_LINE_VERSION
#define DWARF2_LINE_VERSION 2
#endif

#include "subsegs.h"

#include "dwarf2.h"

/* Since we can't generate the prolog until the body is complete, we
   use three different subsegments for .debug_line: one holding the
   prolog, one for the directory and filename info, and one for the
   body ("statement program").  */
#define DL_PROLOG	0
#define DL_FILES	1
#define DL_BODY		2

/* If linker relaxation might change offsets in the code, the DWARF special
   opcodes and variable-length operands cannot be used.  If this macro is
   nonzero, use the DW_LNS_fixed_advance_pc opcode instead.  */
#ifndef DWARF2_USE_FIXED_ADVANCE_PC
# define DWARF2_USE_FIXED_ADVANCE_PC	linkrelax
#endif

/* First special line opcde - leave room for the standard opcodes.
   Note: If you want to change this, you'll have to update the
   "standard_opcode_lengths" table that is emitted below in
   out_debug_line().  */
#define DWARF2_LINE_OPCODE_BASE		13

#ifndef DWARF2_LINE_BASE
  /* Minimum line offset in a special line info. opcode.  This value
     was chosen to give a reasonable range of values.  */
# define DWARF2_LINE_BASE		-5
#endif

/* Range of line offsets in a special line info. opcode.  */
#ifndef DWARF2_LINE_RANGE
# define DWARF2_LINE_RANGE		14
#endif

#ifndef DWARF2_LINE_MIN_INSN_LENGTH
  /* Define the architecture-dependent minimum instruction length (in
     bytes).  This value should be rather too small than too big.  */
# define DWARF2_LINE_MIN_INSN_LENGTH	1
#endif

/* Flag that indicates the initial value of the is_stmt_start flag.  */
#define	DWARF2_LINE_DEFAULT_IS_STMT	1

/* Given a special op, return the line skip amount.  */
#define SPECIAL_LINE(op) \
	(((op) - DWARF2_LINE_OPCODE_BASE)%DWARF2_LINE_RANGE + DWARF2_LINE_BASE)

/* Given a special op, return the address skip amount (in units of
   DWARF2_LINE_MIN_INSN_LENGTH.  */
#define SPECIAL_ADDR(op) (((op) - DWARF2_LINE_OPCODE_BASE)/DWARF2_LINE_RANGE)

/* The maximum address skip amount that can be encoded with a special op.  */
#define MAX_SPECIAL_ADDR_DELTA		SPECIAL_ADDR(255)

struct line_entry {
  struct line_entry *next;
  symbolS *label;
  struct dwarf2_line_info loc;
};

struct line_subseg {
  struct line_subseg *next;
  subsegT subseg;
  struct line_entry *head;
  struct line_entry **ptail;
  struct line_entry **pmove_tail;
};

struct line_seg {
  struct line_seg *next;
  segT seg;
  struct line_subseg *head;
  symbolS *text_start;
  symbolS *text_end;
};

/* Collects data for all line table entries during assembly.  */
static struct line_seg *all_segs;
/* Hash used to quickly lookup a segment by name, avoiding the need to search
   through the all_segs list.  */
static struct hash_control *all_segs_hash;
static struct line_seg **last_seg_ptr;

struct file_entry {
  const char *filename;
  unsigned int dir;
};

/* Table of files used by .debug_line.  */
static struct file_entry *files;
static unsigned int files_in_use;
static unsigned int files_allocated;

/* Table of directories used by .debug_line.  */
static char **dirs;
static unsigned int dirs_in_use;
static unsigned int dirs_allocated;

/* TRUE when we've seen a .loc directive recently.  Used to avoid
   doing work when there's nothing to do.  */
bfd_boolean dwarf2_loc_directive_seen;

/* TRUE when we're supposed to set the basic block mark whenever a
   label is seen.  */
bfd_boolean dwarf2_loc_mark_labels;

/* Current location as indicated by the most recent .loc directive.  */
static struct dwarf2_line_info current = {
  1, 1, 0, 0,
  DWARF2_LINE_DEFAULT_IS_STMT ? DWARF2_FLAG_IS_STMT : 0,
  0
};

/* The size of an address on the target.  */
static unsigned int sizeof_address;

static unsigned int get_filenum (const char *, unsigned int);

#ifndef TC_DWARF2_EMIT_OFFSET
#define TC_DWARF2_EMIT_OFFSET  generic_dwarf2_emit_offset

/* Create an offset to .dwarf2_*.  */

static void
generic_dwarf2_emit_offset (symbolS *symbol, unsigned int size)
{
  expressionS exp;

  exp.X_op = O_symbol;
  exp.X_add_symbol = symbol;
  exp.X_add_number = 0;
  emit_expr (&exp, size);
}
#endif

/* Find or create (if CREATE_P) an entry for SEG+SUBSEG in ALL_SEGS.  */

static struct line_subseg *
get_line_subseg (segT seg, subsegT subseg, bfd_boolean create_p)
{
  static segT last_seg;
  static subsegT last_subseg;
  static struct line_subseg *last_line_subseg;

  struct line_seg *s;
  struct line_subseg **pss, *lss;

  if (seg == last_seg && subseg == last_subseg)
    return last_line_subseg;

  s = (struct line_seg *) hash_find (all_segs_hash, seg->name);
  if (s == NULL)
    {
      if (!create_p)
	return NULL;

      s = (struct line_seg *) xmalloc (sizeof (*s));
      s->next = NULL;
      s->seg = seg;
      s->head = NULL;
      *last_seg_ptr = s;
      last_seg_ptr = &s->next;
      hash_insert (all_segs_hash, seg->name, s);
    }
  gas_assert (seg == s->seg);

  for (pss = &s->head; (lss = *pss) != NULL ; pss = &lss->next)
    {
      if (lss->subseg == subseg)
	goto found_subseg;
      if (lss->subseg > subseg)
	break;
    }

  lss = (struct line_subseg *) xmalloc (sizeof (*lss));
  lss->next = *pss;
  lss->subseg = subseg;
  lss->head = NULL;
  lss->ptail = &lss->head;
  lss->pmove_tail = &lss->head;
  *pss = lss;

 found_subseg:
  last_seg = seg;
  last_subseg = subseg;
  last_line_subseg = lss;

  return lss;
}

/* Record an entry for LOC occurring at LABEL.  */

static void
dwarf2_gen_line_info_1 (symbolS *label, struct dwarf2_line_info *loc)
{
  struct line_subseg *lss;
  struct line_entry *e;

  e = (struct line_entry *) xmalloc (sizeof (*e));
  e->next = NULL;
  e->label = label;
  e->loc = *loc;

  lss = get_line_subseg (now_seg, now_subseg, TRUE);
  *lss->ptail = e;
  lss->ptail = &e->next;
}

/* Record an entry for LOC occurring at OFS within the current fragment.  */

void
dwarf2_gen_line_info (addressT ofs, struct dwarf2_line_info *loc)
{
  static unsigned int line = -1;
  static unsigned int filenum = -1;

  symbolS *sym;

  /* Early out for as-yet incomplete location information.  */
  if (loc->filenum == 0 || loc->line == 0)
    return;

  /* Don't emit sequences of line symbols for the same line when the
     symbols apply to assembler code.  It is necessary to emit
     duplicate line symbols when a compiler asks for them, because GDB
     uses them to determine the end of the prologue.  */
  if (debug_type == DEBUG_DWARF2
      && line == loc->line && filenum == loc->filenum)
    return;

  line = loc->line;
  filenum = loc->filenum;

  if (linkrelax)
    {
      char name[120];

      /* Use a non-fake name for the line number location,
	 so that it can be referred to by relocations.  */
      sprintf (name, ".Loc.%u.%u", line, filenum);
      sym = symbol_new (name, now_seg, ofs, frag_now);
    }
  else
    sym = symbol_temp_new (now_seg, ofs, frag_now);
  dwarf2_gen_line_info_1 (sym, loc);
}

/* Returns the current source information.  If .file directives have
   been encountered, the info for the corresponding source file is
   returned.  Otherwise, the info for the assembly source file is
   returned.  */

void
dwarf2_where (struct dwarf2_line_info *line)
{
  if (debug_type == DEBUG_DWARF2)
    {
      char *filename;
      as_where (&filename, &line->line);
      line->filenum = get_filenum (filename, 0);
      line->column = 0;
      line->flags = DWARF2_FLAG_IS_STMT;
      line->isa = current.isa;
      line->discriminator = current.discriminator;
    }
  else
    *line = current;
}

/* A hook to allow the target backend to inform the line number state
   machine of isa changes when assembler debug info is enabled.  */

void
dwarf2_set_isa (unsigned int isa)
{
  current.isa = isa;
}

/* Called for each machine instruction, or relatively atomic group of
   machine instructions (ie built-in macro).  The instruction or group
   is SIZE bytes in length.  If dwarf2 line number generation is called
   for, emit a line statement appropriately.  */

void
dwarf2_emit_insn (int size)
{
  struct dwarf2_line_info loc;

  if (!dwarf2_loc_directive_seen && debug_type != DEBUG_DWARF2)
    return;

  dwarf2_where (&loc);

  dwarf2_gen_line_info (frag_now_fix () - size, &loc);
  dwarf2_consume_line_info ();
}

/* Move all previously-emitted line entries for the current position by
   DELTA bytes.  This function cannot be used to move the same entries
   twice.  */

void
dwarf2_move_insn (int delta)
{
  struct line_subseg *lss;
  struct line_entry *e;
  valueT now;

  if (delta == 0)
    return;

  lss = get_line_subseg (now_seg, now_subseg, FALSE);
  if (!lss)
    return;

  now = frag_now_fix ();
  while ((e = *lss->pmove_tail))
    {
      if (S_GET_VALUE (e->label) == now)
	S_SET_VALUE (e->label, now + delta);
      lss->pmove_tail = &e->next;
    }
}

/* Called after the current line information has been either used with
   dwarf2_gen_line_info or saved with a machine instruction for later use.
   This resets the state of the line number information to reflect that
   it has been used.  */

void
dwarf2_consume_line_info (void)
{
  /* Unless we generate DWARF2 debugging information for each
     assembler line, we only emit one line symbol for one LOC.  */
  dwarf2_loc_directive_seen = FALSE;

  current.flags &= ~(DWARF2_FLAG_BASIC_BLOCK
		     | DWARF2_FLAG_PROLOGUE_END
		     | DWARF2_FLAG_EPILOGUE_BEGIN);
  current.discriminator = 0;
}

/* Called for each (preferably code) label.  If dwarf2_loc_mark_labels
   is enabled, emit a basic block marker.  */

void
dwarf2_emit_label (symbolS *label)
{
  struct dwarf2_line_info loc;

  if (!dwarf2_loc_mark_labels)
    return;
  if (S_GET_SEGMENT (label) != now_seg)
    return;
  if (!(bfd_get_section_flags (stdoutput, now_seg) & SEC_CODE))
    return;
  if (files_in_use == 0 && debug_type != DEBUG_DWARF2)
    return;

  dwarf2_where (&loc);

  loc.flags |= DWARF2_FLAG_BASIC_BLOCK;

  dwarf2_gen_line_info_1 (label, &loc);
  dwarf2_consume_line_info ();
}

/* Get a .debug_line file number for FILENAME.  If NUM is nonzero,
   allocate it on that file table slot, otherwise return the first
   empty one.  */

static unsigned int
get_filenum (const char *filename, unsigned int num)
{
  static unsigned int last_used, last_used_dir_len;
  const char *file;
  size_t dir_len;
  unsigned int i, dir;

  if (num == 0 && last_used)
    {
      if (! files[last_used].dir
	  && filename_cmp (filename, files[last_used].filename) == 0)
	return last_used;
      if (files[last_used].dir
	  && filename_ncmp (filename, dirs[files[last_used].dir],
			    last_used_dir_len) == 0
	  && IS_DIR_SEPARATOR (filename [last_used_dir_len])
	  && filename_cmp (filename + last_used_dir_len + 1,
			   files[last_used].filename) == 0)
	return last_used;
    }

  file = lbasename (filename);
  /* Don't make empty string from / or A: from A:/ .  */
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
  if (file <= filename + 3)
    file = filename;
#else
  if (file == filename + 1)
    file = filename;
#endif
  dir_len = file - filename;

  dir = 0;
  if (dir_len)
    {
#ifndef DWARF2_DIR_SHOULD_END_WITH_SEPARATOR
      --dir_len;
#endif
      for (dir = 1; dir < dirs_in_use; ++dir)
	if (filename_ncmp (filename, dirs[dir], dir_len) == 0
	    && dirs[dir][dir_len] == '\0')
	  break;

      if (dir >= dirs_in_use)
	{
	  if (dir >= dirs_allocated)
	    {
	      dirs_allocated = dir + 32;
	      dirs = (char **)
		     xrealloc (dirs, (dir + 32) * sizeof (const char *));
	    }

	  dirs[dir] = (char *) xmalloc (dir_len + 1);
	  memcpy (dirs[dir], filename, dir_len);
	  dirs[dir][dir_len] = '\0';
	  dirs_in_use = dir + 1;
	}
    }

  if (num == 0)
    {
      for (i = 1; i < files_in_use; ++i)
	if (files[i].dir == dir
	    && files[i].filename
	    && filename_cmp (file, files[i].filename) == 0)
	  {
	    last_used = i;
	    last_used_dir_len = dir_len;
	    return i;
	  }
    }
  else
    i = num;

  if (i >= files_allocated)
    {
      unsigned int old = files_allocated;

      files_allocated = i + 32;
      files = (struct file_entry *)
	xrealloc (files, (i + 32) * sizeof (struct file_entry));

      memset (files + old, 0, (i + 32 - old) * sizeof (struct file_entry));
    }

  files[i].filename = num ? file : xstrdup (file);
  files[i].dir = dir;
  if (files_in_use < i + 1)
    files_in_use = i + 1;
  last_used = i;
  last_used_dir_len = dir_len;

  return i;
}

/* Handle two forms of .file directive:
   - Pass .file "source.c" to s_app_file
   - Handle .file 1 "source.c" by adding an entry to the DWARF-2 file table

   If an entry is added to the file table, return a pointer to the filename. */

char *
dwarf2_directive_file (int dummy ATTRIBUTE_UNUSED)
{
  offsetT num;
  char *filename;
  int filename_len;

  /* Continue to accept a bare string and pass it off.  */
  SKIP_WHITESPACE ();
  if (*input_line_pointer == '"')
    {
      s_app_file (0);
      return NULL;
    }

  num = get_absolute_expression ();
  filename = demand_copy_C_string (&filename_len);
  if (filename == NULL)
    return NULL;
  demand_empty_rest_of_line ();

  if (num < 1)
    {
      as_bad (_("file number less than one"));
      return NULL;
    }

  /* A .file directive implies compiler generated debug information is
     being supplied.  Turn off gas generated debug info.  */
  debug_type = DEBUG_NONE;

  if (num < (int) files_in_use && files[num].filename != 0)
    {
      as_bad (_("file number %ld already allocated"), (long) num);
      return NULL;
    }

  get_filenum (filename, num);

  return filename;
}

void
dwarf2_directive_loc (int dummy ATTRIBUTE_UNUSED)
{
  offsetT filenum, line;

  /* If we see two .loc directives in a row, force the first one to be
     output now.  */
  if (dwarf2_loc_directive_seen)
    dwarf2_emit_insn (0);

  filenum = get_absolute_expression ();
  SKIP_WHITESPACE ();
  line = get_absolute_expression ();

  if (filenum < 1)
    {
      as_bad (_("file number less than one"));
      return;
    }
  if (filenum >= (int) files_in_use || files[filenum].filename == 0)
    {
      as_bad (_("unassigned file number %ld"), (long) filenum);
      return;
    }

  current.filenum = filenum;
  current.line = line;
  current.discriminator = 0;

#ifndef NO_LISTING
  if (listing)
    {
      if (files[filenum].dir)
	{
	  size_t dir_len = strlen (dirs[files[filenum].dir]);
	  size_t file_len = strlen (files[filenum].filename);
	  char *cp = (char *) alloca (dir_len + 1 + file_len + 1);

	  memcpy (cp, dirs[files[filenum].dir], dir_len);
	  INSERT_DIR_SEPARATOR (cp, dir_len);
	  memcpy (cp + dir_len + 1, files[filenum].filename, file_len);
	  cp[dir_len + file_len + 1] = '\0';
	  listing_source_file (cp);
	}
      else
	listing_source_file (files[filenum].filename);
      listing_source_line (line);
    }
#endif

  SKIP_WHITESPACE ();
  if (ISDIGIT (*input_line_pointer))
    {
      current.column = get_absolute_expression ();
      SKIP_WHITESPACE ();
    }

  while (ISALPHA (*input_line_pointer))
    {
      char *p, c;
      offsetT value;

      p = input_line_pointer;
      c = get_symbol_end ();

      if (strcmp (p, "basic_block") == 0)
	{
	  current.flags |= DWARF2_FLAG_BASIC_BLOCK;
	  *input_line_pointer = c;
	}
      else if (strcmp (p, "prologue_end") == 0)
	{
	  current.flags |= DWARF2_FLAG_PROLOGUE_END;
	  *input_line_pointer = c;
	}
      else if (strcmp (p, "epilogue_begin") == 0)
	{
	  current.flags |= DWARF2_FLAG_EPILOGUE_BEGIN;
	  *input_line_pointer = c;
	}
      else if (strcmp (p, "is_stmt") == 0)
	{
	  *input_line_pointer = c;
	  value = get_absolute_expression ();
	  if (value == 0)
	    current.flags &= ~DWARF2_FLAG_IS_STMT;
	  else if (value == 1)
	    current.flags |= DWARF2_FLAG_IS_STMT;
	  else
	    {
	      as_bad (_("is_stmt value not 0 or 1"));
	      return;
	    }
	}
      else if (strcmp (p, "isa") == 0)
	{
	  *input_line_pointer = c;
	  value = get_absolute_expression ();
	  if (value >= 0)
	    current.isa = value;
	  else
	    {
	      as_bad (_("isa number less than zero"));
	      return;
	    }
	}
      else if (strcmp (p, "discriminator") == 0)
	{
	  *input_line_pointer = c;
	  value = get_absolute_expression ();
	  if (value >= 0)
	    current.discriminator = value;
	  else
	    {
	      as_bad (_("discriminator less than zero"));
	      return;
	    }
	}
      else
	{
	  as_bad (_("unknown .loc sub-directive `%s'"), p);
	  *input_line_pointer = c;
	  return;
	}

      SKIP_WHITESPACE ();
    }

  demand_empty_rest_of_line ();
  dwarf2_loc_directive_seen = TRUE;
  debug_type = DEBUG_NONE;
}

void
dwarf2_directive_loc_mark_labels (int dummy ATTRIBUTE_UNUSED)
{
  offsetT value = get_absolute_expression ();

  if (value != 0 && value != 1)
    {
      as_bad (_("expected 0 or 1"));
      ignore_rest_of_line ();
    }
  else
    {
      dwarf2_loc_mark_labels = value != 0;
      demand_empty_rest_of_line ();
    }
}

static struct frag *
first_frag_for_seg (segT seg)
{
  return seg_info (seg)->frchainP->frch_root;
}

static struct frag *
last_frag_for_seg (segT seg)
{
  frchainS *f = seg_info (seg)->frchainP;

  while (f->frch_next != NULL)
    f = f->frch_next;

  return f->frch_last;
}

/* Emit a single byte into the current segment.  */

static inline void
out_byte (int byte)
{
  FRAG_APPEND_1_CHAR (byte);
}

/* Emit a statement program opcode into the current segment.  */

static inline void
out_opcode (int opc)
{
  out_byte (opc);
}

/* Emit a two-byte word into the current segment.  */

static inline void
out_two (int data)
{
  md_number_to_chars (frag_more (2), data, 2);
}

/* Emit a four byte word into the current segment.  */

static inline void
out_four (int data)
{
  md_number_to_chars (frag_more (4), data, 4);
}

/* Emit an unsigned "little-endian base 128" number.  */

static void
out_uleb128 (addressT value)
{
  output_leb128 (frag_more (sizeof_leb128 (value, 0)), value, 0);
}

/* Emit a signed "little-endian base 128" number.  */

static void
out_leb128 (addressT value)
{
  output_leb128 (frag_more (sizeof_leb128 (value, 1)), value, 1);
}

/* Emit a tuple for .debug_abbrev.  */

static inline void
out_abbrev (int name, int form)
{
  out_uleb128 (name);
  out_uleb128 (form);
}

/* Get the size of a fragment.  */

static offsetT
get_frag_fix (fragS *frag, segT seg)
{
  frchainS *fr;

  if (frag->fr_next)
    return frag->fr_fix;

  /* If a fragment is the last in the chain, special measures must be
     taken to find its size before relaxation, since it may be pending
     on some subsegment chain.  */
  for (fr = seg_info (seg)->frchainP; fr; fr = fr->frch_next)
    if (fr->frch_last == frag)
      return (char *) obstack_next_free (&fr->frch_obstack) - frag->fr_literal;

  abort ();
}

/* Set an absolute address (may result in a relocation entry).  */

static void
out_set_addr (symbolS *sym)
{
  expressionS exp;

  out_opcode (DW_LNS_extended_op);
  out_uleb128 (sizeof_address + 1);

  out_opcode (DW_LNE_set_address);
  exp.X_op = O_symbol;
  exp.X_add_symbol = sym;
  exp.X_add_number = 0;
  emit_expr (&exp, sizeof_address);
}

static void scale_addr_delta (addressT *);

static void
scale_addr_delta (addressT *addr_delta)
{
  static int printed_this = 0;
  if (DWARF2_LINE_MIN_INSN_LENGTH > 1)
    {
      if (*addr_delta % DWARF2_LINE_MIN_INSN_LENGTH != 0  && !printed_this)
        {
	  as_bad("unaligned opcodes detected in executable segment");
          printed_this = 1;
        }
      *addr_delta /= DWARF2_LINE_MIN_INSN_LENGTH;
    }
}

/* Encode a pair of line and address skips as efficiently as possible.
   Note that the line skip is signed, whereas the address skip is unsigned.

   The following two routines *must* be kept in sync.  This is
   enforced by making emit_inc_line_addr abort if we do not emit
   exactly the expected number of bytes.  */

static int
size_inc_line_addr (int line_delta, addressT addr_delta)
{
  unsigned int tmp, opcode;
  int len = 0;

  /* Scale the address delta by the minimum instruction length.  */
  scale_addr_delta (&addr_delta);

  /* INT_MAX is a signal that this is actually a DW_LNE_end_sequence.
     We cannot use special opcodes here, since we want the end_sequence
     to emit the matrix entry.  */
  if (line_delta == INT_MAX)
    {
      if (addr_delta == MAX_SPECIAL_ADDR_DELTA)
	len = 1;
      else
	len = 1 + sizeof_leb128 (addr_delta, 0);
      return len + 3;
    }

  /* Bias the line delta by the base.  */
  tmp = line_delta - DWARF2_LINE_BASE;

  /* If the line increment is out of range of a special opcode, we
     must encode it with DW_LNS_advance_line.  */
  if (tmp >= DWARF2_LINE_RANGE)
    {
      len = 1 + sizeof_leb128 (line_delta, 1);
      line_delta = 0;
      tmp = 0 - DWARF2_LINE_BASE;
    }

  /* Bias the opcode by the special opcode base.  */
  tmp += DWARF2_LINE_OPCODE_BASE;

  /* Avoid overflow when addr_delta is large.  */
  if (addr_delta < 256 + MAX_SPECIAL_ADDR_DELTA)
    {
      /* Try using a special opcode.  */
      opcode = tmp + addr_delta * DWARF2_LINE_RANGE;
      if (opcode <= 255)
	return len + 1;

      /* Try using DW_LNS_const_add_pc followed by special op.  */
      opcode = tmp + (addr_delta - MAX_SPECIAL_ADDR_DELTA) * DWARF2_LINE_RANGE;
      if (opcode <= 255)
	return len + 2;
    }

  /* Otherwise use DW_LNS_advance_pc.  */
  len += 1 + sizeof_leb128 (addr_delta, 0);

  /* DW_LNS_copy or special opcode.  */
  len += 1;

  return len;
}

static void
emit_inc_line_addr (int line_delta, addressT addr_delta, char *p, int len)
{
  unsigned int tmp, opcode;
  int need_copy = 0;
  char *end = p + len;

  /* Line number sequences cannot go backward in addresses.  This means
     we've incorrectly ordered the statements in the sequence.  */
  gas_assert ((offsetT) addr_delta >= 0);

  /* Scale the address delta by the minimum instruction length.  */
  scale_addr_delta (&addr_delta);

  /* INT_MAX is a signal that this is actually a DW_LNE_end_sequence.
     We cannot use special opcodes here, since we want the end_sequence
     to emit the matrix entry.  */
  if (line_delta == INT_MAX)
    {
      if (addr_delta == MAX_SPECIAL_ADDR_DELTA)
	*p++ = DW_LNS_const_add_pc;
      else
	{
	  *p++ = DW_LNS_advance_pc;
	  p += output_leb128 (p, addr_delta, 0);
	}

      *p++ = DW_LNS_extended_op;
      *p++ = 1;
      *p++ = DW_LNE_end_sequence;
      goto done;
    }

  /* Bias the line delta by the base.  */
  tmp = line_delta - DWARF2_LINE_BASE;

  /* If the line increment is out of range of a special opcode, we
     must encode it with DW_LNS_advance_line.  */
  if (tmp >= DWARF2_LINE_RANGE)
    {
      *p++ = DW_LNS_advance_line;
      p += output_leb128 (p, line_delta, 1);

      line_delta = 0;
      tmp = 0 - DWARF2_LINE_BASE;
      need_copy = 1;
    }

  /* Prettier, I think, to use DW_LNS_copy instead of a "line +0, addr +0"
     special opcode.  */
  if (line_delta == 0 && addr_delta == 0)
    {
      *p++ = DW_LNS_copy;
      goto done;
    }

  /* Bias the opcode by the special opcode base.  */
  tmp += DWARF2_LINE_OPCODE_BASE;

  /* Avoid overflow when addr_delta is large.  */
  if (addr_delta < 256 + MAX_SPECIAL_ADDR_DELTA)
    {
      /* Try using a special opcode.  */
      opcode = tmp + addr_delta * DWARF2_LINE_RANGE;
      if (opcode <= 255)
	{
	  *p++ = opcode;
	  goto done;
	}

      /* Try using DW_LNS_const_add_pc followed by special op.  */
      opcode = tmp + (addr_delta - MAX_SPECIAL_ADDR_DELTA) * DWARF2_LINE_RANGE;
      if (opcode <= 255)
	{
	  *p++ = DW_LNS_const_add_pc;
	  *p++ = opcode;
	  goto done;
	}
    }

  /* Otherwise use DW_LNS_advance_pc.  */
  *p++ = DW_LNS_advance_pc;
  p += output_leb128 (p, addr_delta, 0);

  if (need_copy)
    *p++ = DW_LNS_copy;
  else
    *p++ = tmp;

 done:
  gas_assert (p == end);
}

/* Handy routine to combine calls to the above two routines.  */

static void
out_inc_line_addr (int line_delta, addressT addr_delta)
{
  int len = size_inc_line_addr (line_delta, addr_delta);
  emit_inc_line_addr (line_delta, addr_delta, frag_more (len), len);
}

/* Write out an alternative form of line and address skips using
   DW_LNS_fixed_advance_pc opcodes.  This uses more space than the default
   line and address information, but it is required if linker relaxation
   could change the code offsets.  The following two routines *must* be
   kept in sync.  */
#define ADDR_DELTA_LIMIT 50000

static int
size_fixed_inc_line_addr (int line_delta, addressT addr_delta)
{
  int len = 0;

  /* INT_MAX is a signal that this is actually a DW_LNE_end_sequence.  */
  if (line_delta != INT_MAX)
    len = 1 + sizeof_leb128 (line_delta, 1);

  if (addr_delta > ADDR_DELTA_LIMIT)
    {
      /* DW_LNS_extended_op */
      len += 1 + sizeof_leb128 (sizeof_address + 1, 0);
      /* DW_LNE_set_address */
      len += 1 + sizeof_address;
    }
  else
    /* DW_LNS_fixed_advance_pc */
    len += 3;

  if (line_delta == INT_MAX)
    /* DW_LNS_extended_op + DW_LNE_end_sequence */
    len += 3;
  else
    /* DW_LNS_copy */
    len += 1;

  return len;
}

static void
emit_fixed_inc_line_addr (int line_delta, addressT addr_delta, fragS *frag,
			  char *p, int len)
{
  expressionS *pexp;
  char *end = p + len;

  /* Line number sequences cannot go backward in addresses.  This means
     we've incorrectly ordered the statements in the sequence.  */
  gas_assert ((offsetT) addr_delta >= 0);

  /* Verify that we have kept in sync with size_fixed_inc_line_addr.  */
  gas_assert (len == size_fixed_inc_line_addr (line_delta, addr_delta));

  /* INT_MAX is a signal that this is actually a DW_LNE_end_sequence.  */
  if (line_delta != INT_MAX)
    {
      *p++ = DW_LNS_advance_line;
      p += output_leb128 (p, line_delta, 1);
    }

  pexp = symbol_get_value_expression (frag->fr_symbol);

  /* The DW_LNS_fixed_advance_pc opcode has a 2-byte operand so it can
     advance the address by at most 64K.  Linker relaxation (without
     which this function would not be used) could change the operand by
     an unknown amount.  If the address increment is getting close to
     the limit, just reset the address.  */
  if (addr_delta > ADDR_DELTA_LIMIT)
    {
      symbolS *to_sym;
      expressionS exp;

      gas_assert (pexp->X_op == O_subtract);
      to_sym = pexp->X_add_symbol;

      *p++ = DW_LNS_extended_op;
      p += output_leb128 (p, sizeof_address + 1, 0);
      *p++ = DW_LNE_set_address;
      exp.X_op = O_symbol;
      exp.X_add_symbol = to_sym;
      exp.X_add_number = 0;
      emit_expr_fix (&exp, sizeof_address, frag, p);
      p += sizeof_address;
    }
  else
    {
      *p++ = DW_LNS_fixed_advance_pc;
      emit_expr_fix (pexp, 2, frag, p);
      p += 2;
    }

  if (line_delta == INT_MAX)
    {
      *p++ = DW_LNS_extended_op;
      *p++ = 1;
      *p++ = DW_LNE_end_sequence;
    }
  else
    *p++ = DW_LNS_copy;

  gas_assert (p == end);
}

/* Generate a variant frag that we can use to relax address/line
   increments between fragments of the target segment.  */

static void
relax_inc_line_addr (int line_delta, symbolS *to_sym, symbolS *from_sym)
{
  expressionS exp;
  int max_chars;

  exp.X_op = O_subtract;
  exp.X_add_symbol = to_sym;
  exp.X_op_symbol = from_sym;
  exp.X_add_number = 0;

  /* The maximum size of the frag is the line delta with a maximum
     sized address delta.  */
  if (DWARF2_USE_FIXED_ADVANCE_PC)
    max_chars = size_fixed_inc_line_addr (line_delta,
					  -DWARF2_LINE_MIN_INSN_LENGTH);
  else
    max_chars = size_inc_line_addr (line_delta, -DWARF2_LINE_MIN_INSN_LENGTH);

  frag_var (rs_dwarf2dbg, max_chars, max_chars, 1,
	    make_expr_symbol (&exp), line_delta, NULL);
}

/* The function estimates the size of a rs_dwarf2dbg variant frag
   based on the current values of the symbols.  It is called before
   the relaxation loop.  We set fr_subtype to the expected length.  */

int
dwarf2dbg_estimate_size_before_relax (fragS *frag)
{
  offsetT addr_delta;
  int size;

  addr_delta = resolve_symbol_value (frag->fr_symbol);
  if (DWARF2_USE_FIXED_ADVANCE_PC)
    size = size_fixed_inc_line_addr (frag->fr_offset, addr_delta);
  else
    size = size_inc_line_addr (frag->fr_offset, addr_delta);

  frag->fr_subtype = size;

  return size;
}

/* This function relaxes a rs_dwarf2dbg variant frag based on the
   current values of the symbols.  fr_subtype is the current length
   of the frag.  This returns the change in frag length.  */

int
dwarf2dbg_relax_frag (fragS *frag)
{
  int old_size, new_size;

  old_size = frag->fr_subtype;
  new_size = dwarf2dbg_estimate_size_before_relax (frag);

  return new_size - old_size;
}

/* This function converts a rs_dwarf2dbg variant frag into a normal
   fill frag.  This is called after all relaxation has been done.
   fr_subtype will be the desired length of the frag.  */

void
dwarf2dbg_convert_frag (fragS *frag)
{
  offsetT addr_diff;

  if (DWARF2_USE_FIXED_ADVANCE_PC)
    {
      /* If linker relaxation is enabled then the distance bewteen the two
	 symbols in the frag->fr_symbol expression might change.  Hence we
	 cannot rely upon the value computed by resolve_symbol_value.
	 Instead we leave the expression unfinalized and allow
	 emit_fixed_inc_line_addr to create a fixup (which later becomes a
	 relocation) that will allow the linker to correctly compute the
	 actual address difference.  We have to use a fixed line advance for
	 this as we cannot (easily) relocate leb128 encoded values.  */
      int saved_finalize_syms = finalize_syms;

      finalize_syms = 0;
      addr_diff = resolve_symbol_value (frag->fr_symbol);
      finalize_syms = saved_finalize_syms;
    }
  else
    addr_diff = resolve_symbol_value (frag->fr_symbol);

  /* fr_var carries the max_chars that we created the fragment with.
     fr_subtype carries the current expected length.  We must, of
     course, have allocated enough memory earlier.  */
  gas_assert (frag->fr_var >= (int) frag->fr_subtype);

  if (DWARF2_USE_FIXED_ADVANCE_PC)
    emit_fixed_inc_line_addr (frag->fr_offset, addr_diff, frag,
			      frag->fr_literal + frag->fr_fix,
			      frag->fr_subtype);
  else
    emit_inc_line_addr (frag->fr_offset, addr_diff,
			frag->fr_literal + frag->fr_fix, frag->fr_subtype);

  frag->fr_fix += frag->fr_subtype;
  frag->fr_type = rs_fill;
  frag->fr_var = 0;
  frag->fr_offset = 0;
}

/* Generate .debug_line content for the chain of line number entries
   beginning at E, for segment SEG.  */

static void
process_entries (segT seg, struct line_entry *e)
{
  unsigned filenum = 1;
  unsigned line = 1;
  unsigned column = 0;
  unsigned isa = 0;
  unsigned flags = DWARF2_LINE_DEFAULT_IS_STMT ? DWARF2_FLAG_IS_STMT : 0;
  fragS *last_frag = NULL, *frag;
  addressT last_frag_ofs = 0, frag_ofs;
  symbolS *last_lab = NULL, *lab;
  struct line_entry *next;

  if (flag_dwarf_sections)
    {
      char * name;
      const char * sec_name;

      /* Switch to the relevent sub-section before we start to emit
	 the line number table.

	 FIXME: These sub-sections do not have a normal Line Number
	 Program Header, thus strictly speaking they are not valid
	 DWARF sections.  Unfortunately the DWARF standard assumes
	 a one-to-one relationship between compilation units and
	 line number tables.  Thus we have to have a .debug_line
	 section, as well as our sub-sections, and we have to ensure
	 that all of the sub-sections are merged into a proper
	 .debug_line section before a debugger sees them.  */
	 
      sec_name = bfd_get_section_name (stdoutput, seg);
      if (strcmp (sec_name, ".text") != 0)
	{
	  unsigned int len;

	  len = strlen (sec_name);
	  name = xmalloc (len + 11 + 2);
	  sprintf (name, ".debug_line%s", sec_name);
	  subseg_set (subseg_get (name, FALSE), 0);
	}
      else
	/* Don't create a .debug_line.text section -
	   that is redundant.  Instead just switch back to the
	   normal .debug_line section.  */
	subseg_set (subseg_get (".debug_line", FALSE), 0);
    }

  do
    {
      int line_delta;

      if (filenum != e->loc.filenum)
	{
	  filenum = e->loc.filenum;
	  out_opcode (DW_LNS_set_file);
	  out_uleb128 (filenum);
	}

      if (column != e->loc.column)
	{
	  column = e->loc.column;
	  out_opcode (DW_LNS_set_column);
	  out_uleb128 (column);
	}

      if (e->loc.discriminator != 0)
	{
	  out_opcode (DW_LNS_extended_op);
	  out_leb128 (1 + sizeof_leb128 (e->loc.discriminator, 0));
	  out_opcode (DW_LNE_set_discriminator);
	  out_uleb128 (e->loc.discriminator);
	}

      if (isa != e->loc.isa)
	{
	  isa = e->loc.isa;
	  out_opcode (DW_LNS_set_isa);
	  out_uleb128 (isa);
	}

      if ((e->loc.flags ^ flags) & DWARF2_FLAG_IS_STMT)
	{
	  flags = e->loc.flags;
	  out_opcode (DW_LNS_negate_stmt);
	}

      if (e->loc.flags & DWARF2_FLAG_BASIC_BLOCK)
	out_opcode (DW_LNS_set_basic_block);

      if (e->loc.flags & DWARF2_FLAG_PROLOGUE_END)
	out_opcode (DW_LNS_set_prologue_end);

      if (e->loc.flags & DWARF2_FLAG_EPILOGUE_BEGIN)
	out_opcode (DW_LNS_set_epilogue_begin);

      /* Don't try to optimize away redundant entries; gdb wants two
	 entries for a function where the code starts on the same line as
	 the {, and there's no way to identify that case here.  Trust gcc
	 to optimize appropriately.  */
      line_delta = e->loc.line - line;
      lab = e->label;
      frag = symbol_get_frag (lab);
      frag_ofs = S_GET_VALUE (lab);

      if (last_frag == NULL)
	{
	  out_set_addr (lab);
	  out_inc_line_addr (line_delta, 0);
	}
      else if (frag == last_frag && ! DWARF2_USE_FIXED_ADVANCE_PC)
	out_inc_line_addr (line_delta, frag_ofs - last_frag_ofs);
      else
	relax_inc_line_addr (line_delta, lab, last_lab);

      line = e->loc.line;
      last_lab = lab;
      last_frag = frag;
      last_frag_ofs = frag_ofs;

      next = e->next;
      free (e);
      e = next;
    }
  while (e);

  /* Emit a DW_LNE_end_sequence for the end of the section.  */
  frag = last_frag_for_seg (seg);
  frag_ofs = get_frag_fix (frag, seg);
  if (frag == last_frag && ! DWARF2_USE_FIXED_ADVANCE_PC)
    out_inc_line_addr (INT_MAX, frag_ofs - last_frag_ofs);
  else
    {
      lab = symbol_temp_new (seg, frag_ofs, frag);
      relax_inc_line_addr (INT_MAX, lab, last_lab);
    }
}

/* Emit the directory and file tables for .debug_line.  */

static void
out_file_list (void)
{
  size_t size;
  const char *dir;
  char *cp;
  unsigned int i;

  /* Emit directory list.  */
  for (i = 1; i < dirs_in_use; ++i)
    {
      dir = remap_debug_filename (dirs[i]);
      size = strlen (dir) + 1;
      cp = frag_more (size);
      memcpy (cp, dir, size);
    }
  /* Terminate it.  */
  out_byte ('\0');

  for (i = 1; i < files_in_use; ++i)
    {
      const char *fullfilename;

      if (files[i].filename == NULL)
	{
	  as_bad (_("unassigned file number %ld"), (long) i);
	  /* Prevent a crash later, particularly for file 1.  */
	  files[i].filename = "";
	  continue;
	}

      fullfilename = DWARF2_FILE_NAME (files[i].filename,
				       files[i].dir ? dirs [files [i].dir] : "");
      size = strlen (fullfilename) + 1;
      cp = frag_more (size);
      memcpy (cp, fullfilename, size);

      out_uleb128 (files[i].dir);	/* directory number */
      /* Output the last modification timestamp.  */
      out_uleb128 (DWARF2_FILE_TIME_NAME (files[i].filename,
				          files[i].dir ? dirs [files [i].dir] : ""));
      /* Output the filesize.  */
      out_uleb128 (DWARF2_FILE_SIZE_NAME (files[i].filename,
				          files[i].dir ? dirs [files [i].dir] : ""));
    }

  /* Terminate filename list.  */
  out_byte (0);
}

/* Switch to SEC and output a header length field.  Return the size of
   offsets used in SEC.  The caller must set EXPR->X_add_symbol value
   to the end of the section.  */

static int
out_header (asection *sec, expressionS *exp)
{
  symbolS *start_sym;
  symbolS *end_sym;

  subseg_set (sec, 0);
  start_sym = symbol_temp_new_now ();
  end_sym = symbol_temp_make ();

  /* Total length of the information.  */
  exp->X_op = O_subtract;
  exp->X_add_symbol = end_sym;
  exp->X_op_symbol = start_sym;

  switch (DWARF2_FORMAT (sec))
    {
    case dwarf2_format_32bit:
      exp->X_add_number = -4;
      emit_expr (exp, 4);
      return 4;

    case dwarf2_format_64bit:
      exp->X_add_number = -12;
      out_four (-1);
      emit_expr (exp, 8);
      return 8;

    case dwarf2_format_64bit_irix:
      exp->X_add_number = -8;
      emit_expr (exp, 8);
      return 8;
    }

  as_fatal (_("internal error: unknown dwarf2 format"));
  return 0;
}

/* Emit the collected .debug_line data.  */

static void
out_debug_line (segT line_seg)
{
  expressionS exp;
  symbolS *prologue_end;
  symbolS *line_end;
  struct line_seg *s;
  int sizeof_offset;

  sizeof_offset = out_header (line_seg, &exp);
  line_end = exp.X_add_symbol;

  /* Version.  */
  out_two (DWARF2_LINE_VERSION);

  /* Length of the prologue following this length.  */
  prologue_end = symbol_temp_make ();
  exp.X_add_symbol = prologue_end;
  exp.X_add_number = - (4 + 2 + 4);
  emit_expr (&exp, sizeof_offset);

  /* Parameters of the state machine.  */
  out_byte (DWARF2_LINE_MIN_INSN_LENGTH);
  out_byte (DWARF2_LINE_DEFAULT_IS_STMT);
  out_byte (DWARF2_LINE_BASE);
  out_byte (DWARF2_LINE_RANGE);
  out_byte (DWARF2_LINE_OPCODE_BASE);

  /* Standard opcode lengths.  */
  out_byte (0);			/* DW_LNS_copy */
  out_byte (1);			/* DW_LNS_advance_pc */
  out_byte (1);			/* DW_LNS_advance_line */
  out_byte (1);			/* DW_LNS_set_file */
  out_byte (1);			/* DW_LNS_set_column */
  out_byte (0);			/* DW_LNS_negate_stmt */
  out_byte (0);			/* DW_LNS_set_basic_block */
  out_byte (0);			/* DW_LNS_const_add_pc */
  out_byte (1);			/* DW_LNS_fixed_advance_pc */
  out_byte (0);			/* DW_LNS_set_prologue_end */
  out_byte (0);			/* DW_LNS_set_epilogue_begin */
  out_byte (1);			/* DW_LNS_set_isa */

  out_file_list ();

  symbol_set_value_now (prologue_end);

  /* For each section, emit a statement program.  */
  for (s = all_segs; s; s = s->next)
    if (SEG_NORMAL (s->seg))
      process_entries (s->seg, s->head->head);
    else
      as_warn ("dwarf line number information for %s ignored",
	       segment_name (s->seg));

  if (flag_dwarf_sections)
    /* We have to switch to the special .debug_line_end section
       before emitting the end-of-debug_line symbol.  The linker
       script arranges for this section to be placed after all the
       (potentially garbage collected) .debug_line.<foo> sections.
       This section contains the line_end symbol which is used to
       compute the size of the linked .debug_line section, as seen
       in the DWARF Line Number header.  */
    subseg_set (subseg_get (".debug_line_end", FALSE), 0);

  symbol_set_value_now (line_end);
}

static void
out_debug_ranges (segT ranges_seg)
{
  unsigned int addr_size = sizeof_address;
  struct line_seg *s;
  expressionS exp;
  unsigned int i;

  subseg_set (ranges_seg, 0);

  /* Base Address Entry.  */
  for (i = 0; i < addr_size; i++)
    out_byte (0xff);
  for (i = 0; i < addr_size; i++)
    out_byte (0);

  /* Range List Entry.  */
  for (s = all_segs; s; s = s->next)
    {
      fragS *frag;
      symbolS *beg, *end;

      frag = first_frag_for_seg (s->seg);
      beg = symbol_temp_new (s->seg, 0, frag);
      s->text_start = beg;

      frag = last_frag_for_seg (s->seg);
      end = symbol_temp_new (s->seg, get_frag_fix (frag, s->seg), frag);
      s->text_end = end;

      exp.X_op = O_symbol;
      exp.X_add_symbol = beg;
      exp.X_add_number = 0;
      emit_expr (&exp, addr_size);

      exp.X_op = O_symbol;
      exp.X_add_symbol = end;
      exp.X_add_number = 0;
      emit_expr (&exp, addr_size);
    }

  /* End of Range Entry.   */
  for (i = 0; i < addr_size; i++)
    out_byte (0);
  for (i = 0; i < addr_size; i++)
    out_byte (0);
}

/* Emit data for .debug_aranges.  */

static void
out_debug_aranges (segT aranges_seg, segT info_seg)
{
  unsigned int addr_size = sizeof_address;
  struct line_seg *s;
  expressionS exp;
  symbolS *aranges_end;
  char *p;
  int sizeof_offset;

  sizeof_offset = out_header (aranges_seg, &exp);
  aranges_end = exp.X_add_symbol;

  /* Version.  */
  out_two (DWARF2_ARANGES_VERSION);

  /* Offset to .debug_info.  */
  TC_DWARF2_EMIT_OFFSET (section_symbol (info_seg), sizeof_offset);

  /* Size of an address (offset portion).  */
  out_byte (addr_size);

  /* Size of a segment descriptor.  */
  out_byte (0);

  /* Align the header.  */
  frag_align (ffs (2 * addr_size) - 1, 0, 0);

  for (s = all_segs; s; s = s->next)
    {
      fragS *frag;
      symbolS *beg, *end;

      frag = first_frag_for_seg (s->seg);
      beg = symbol_temp_new (s->seg, 0, frag);
      s->text_start = beg;

      frag = last_frag_for_seg (s->seg);
      end = symbol_temp_new (s->seg, get_frag_fix (frag, s->seg), frag);
      s->text_end = end;

      exp.X_op = O_symbol;
      exp.X_add_symbol = beg;
      exp.X_add_number = 0;
      emit_expr (&exp, addr_size);

      exp.X_op = O_subtract;
      exp.X_add_symbol = end;
      exp.X_op_symbol = beg;
      exp.X_add_number = 0;
      emit_expr (&exp, addr_size);
    }

  p = frag_more (2 * addr_size);
  md_number_to_chars (p, 0, addr_size);
  md_number_to_chars (p + addr_size, 0, addr_size);

  symbol_set_value_now (aranges_end);
}

/* Emit data for .debug_abbrev.  Note that this must be kept in
   sync with out_debug_info below.  */

static void
out_debug_abbrev (segT abbrev_seg,
		  segT info_seg ATTRIBUTE_UNUSED,
		  segT line_seg ATTRIBUTE_UNUSED)
{
  subseg_set (abbrev_seg, 0);

  out_uleb128 (1);
  out_uleb128 (DW_TAG_compile_unit);
  out_byte (DW_CHILDREN_no);
  if (DWARF2_FORMAT (line_seg) == dwarf2_format_32bit)
    out_abbrev (DW_AT_stmt_list, DW_FORM_data4);
  else
    out_abbrev (DW_AT_stmt_list, DW_FORM_data8);
  if (all_segs->next == NULL)
    {
      out_abbrev (DW_AT_low_pc, DW_FORM_addr);
      if (DWARF2_VERSION < 4)
	out_abbrev (DW_AT_high_pc, DW_FORM_addr);
      else
	out_abbrev (DW_AT_high_pc, (sizeof_address == 4
				    ? DW_FORM_data4 : DW_FORM_data8));
    }
  else
    {
      if (DWARF2_FORMAT (info_seg) == dwarf2_format_32bit)
	out_abbrev (DW_AT_ranges, DW_FORM_data4);
      else
	out_abbrev (DW_AT_ranges, DW_FORM_data8);
    }
  out_abbrev (DW_AT_name, DW_FORM_string);
  out_abbrev (DW_AT_comp_dir, DW_FORM_string);
  out_abbrev (DW_AT_producer, DW_FORM_string);
  out_abbrev (DW_AT_language, DW_FORM_data2);
  out_abbrev (0, 0);

  /* Terminate the abbreviations for this compilation unit.  */
  out_byte (0);
}

/* Emit a description of this compilation unit for .debug_info.  */

static void
out_debug_info (segT info_seg, segT abbrev_seg, segT line_seg, segT ranges_seg)
{
  char producer[128];
  const char *comp_dir;
  const char *dirname;
  expressionS exp;
  symbolS *info_end;
  char *p;
  int len;
  int sizeof_offset;

  sizeof_offset = out_header (info_seg, &exp);
  info_end = exp.X_add_symbol;

  /* DWARF version.  */
  out_two (DWARF2_VERSION);

  /* .debug_abbrev offset */
  TC_DWARF2_EMIT_OFFSET (section_symbol (abbrev_seg), sizeof_offset);

  /* Target address size.  */
  out_byte (sizeof_address);

  /* DW_TAG_compile_unit DIE abbrev */
  out_uleb128 (1);

  /* DW_AT_stmt_list */
  TC_DWARF2_EMIT_OFFSET (section_symbol (line_seg),
			 (DWARF2_FORMAT (line_seg) == dwarf2_format_32bit
			  ? 4 : 8));

  /* These two attributes are emitted if all of the code is contiguous.  */
  if (all_segs->next == NULL)
    {
      /* DW_AT_low_pc */
      exp.X_op = O_symbol;
      exp.X_add_symbol = all_segs->text_start;
      exp.X_add_number = 0;
      emit_expr (&exp, sizeof_address);

      /* DW_AT_high_pc */
      if (DWARF2_VERSION < 4)
	exp.X_op = O_symbol;
      else
	{
	  exp.X_op = O_subtract;
	  exp.X_op_symbol = all_segs->text_start;
	}
      exp.X_add_symbol = all_segs->text_end;
      exp.X_add_number = 0;
      emit_expr (&exp, sizeof_address);
    }
  else
    {
      /* This attribute is emitted if the code is disjoint.  */
      /* DW_AT_ranges.  */
      TC_DWARF2_EMIT_OFFSET (section_symbol (ranges_seg), sizeof_offset);
    }

  /* DW_AT_name.  We don't have the actual file name that was present
     on the command line, so assume files[1] is the main input file.
     We're not supposed to get called unless at least one line number
     entry was emitted, so this should always be defined.  */
  if (files_in_use == 0)
    abort ();
  if (files[1].dir)
    {
      dirname = remap_debug_filename (dirs[files[1].dir]);
      len = strlen (dirname);
#ifdef TE_VMS
      /* Already has trailing slash.  */
      p = frag_more (len);
      memcpy (p, dirname, len);
#else
      p = frag_more (len + 1);
      memcpy (p, dirname, len);
      INSERT_DIR_SEPARATOR (p, len);
#endif
    }
  len = strlen (files[1].filename) + 1;
  p = frag_more (len);
  memcpy (p, files[1].filename, len);

  /* DW_AT_comp_dir */
  comp_dir = remap_debug_filename (getpwd ());
  len = strlen (comp_dir) + 1;
  p = frag_more (len);
  memcpy (p, comp_dir, len);

  /* DW_AT_producer */
  sprintf (producer, "GNU AS %s", VERSION);
  len = strlen (producer) + 1;
  p = frag_more (len);
  memcpy (p, producer, len);

  /* DW_AT_language.  Yes, this is probably not really MIPS, but the
     dwarf2 draft has no standard code for assembler.  */
  out_two (DW_LANG_Mips_Assembler);

  symbol_set_value_now (info_end);
}

void
dwarf2_init (void)
{
  all_segs_hash = hash_new ();
  last_seg_ptr = &all_segs;
}


/* Finish the dwarf2 debug sections.  We emit .debug.line if there
   were any .file/.loc directives, or --gdwarf2 was given, or if the
   file has a non-empty .debug_info section and an empty .debug_line
   section.  If we emit .debug_line, and the .debug_info section is
   empty, we also emit .debug_info, .debug_aranges and .debug_abbrev.
   ALL_SEGS will be non-null if there were any .file/.loc directives,
   or --gdwarf2 was given and there were any located instructions
   emitted.  */

void
dwarf2_finish (void)
{
  segT line_seg;
  struct line_seg *s;
  segT info_seg;
  int emit_other_sections = 0;
  int empty_debug_line = 0;

  info_seg = bfd_get_section_by_name (stdoutput, ".debug_info");
  emit_other_sections = info_seg == NULL || !seg_not_empty_p (info_seg);

  line_seg = bfd_get_section_by_name (stdoutput, ".debug_line");
  empty_debug_line = line_seg == NULL || !seg_not_empty_p (line_seg);

  /* We can't construct a new debug_line section if we already have one.
     Give an error.  */
  if (all_segs && !empty_debug_line)
    as_fatal ("duplicate .debug_line sections");

  if ((!all_segs && emit_other_sections)
      || (!emit_other_sections && !empty_debug_line))
    /* If there is no line information and no non-empty .debug_info
       section, or if there is both a non-empty .debug_info and a non-empty
       .debug_line, then we do nothing.  */
    return;

  /* Calculate the size of an address for the target machine.  */
  sizeof_address = DWARF2_ADDR_SIZE (stdoutput);

  /* Create and switch to the line number section.  */
  line_seg = subseg_new (".debug_line", 0);
  bfd_set_section_flags (stdoutput, line_seg, SEC_READONLY | SEC_DEBUGGING);

  /* For each subsection, chain the debug entries together.  */
  for (s = all_segs; s; s = s->next)
    {
      struct line_subseg *lss = s->head;
      struct line_entry **ptail = lss->ptail;

      while ((lss = lss->next) != NULL)
	{
	  *ptail = lss->head;
	  ptail = lss->ptail;
	}
    }

  out_debug_line (line_seg);

  /* If this is assembler generated line info, and there is no
     debug_info already, we need .debug_info and .debug_abbrev
     sections as well.  */
  if (emit_other_sections)
    {
      segT abbrev_seg;
      segT aranges_seg;
      segT ranges_seg;

      gas_assert (all_segs);

      info_seg = subseg_new (".debug_info", 0);
      abbrev_seg = subseg_new (".debug_abbrev", 0);
      aranges_seg = subseg_new (".debug_aranges", 0);

      bfd_set_section_flags (stdoutput, info_seg,
			     SEC_READONLY | SEC_DEBUGGING);
      bfd_set_section_flags (stdoutput, abbrev_seg,
			     SEC_READONLY | SEC_DEBUGGING);
      bfd_set_section_flags (stdoutput, aranges_seg,
			     SEC_READONLY | SEC_DEBUGGING);

      record_alignment (aranges_seg, ffs (2 * sizeof_address) - 1);

      if (all_segs->next == NULL)
	ranges_seg = NULL;
      else
	{
	  ranges_seg = subseg_new (".debug_ranges", 0);
	  bfd_set_section_flags (stdoutput, ranges_seg,
				 SEC_READONLY | SEC_DEBUGGING);
	  record_alignment (ranges_seg, ffs (2 * sizeof_address) - 1);
	  out_debug_ranges (ranges_seg);
	}

      out_debug_aranges (aranges_seg, info_seg);
      out_debug_abbrev (abbrev_seg, info_seg, line_seg);
      out_debug_info (info_seg, abbrev_seg, line_seg, ranges_seg);
    }
}
@


1.120
log
@gas/
	Revert:

	2011-09-05  Richard Sandiford  <rdsandiford@@googlemail.com>

	PR gas/13024
	* dwarf2dbg.c (pending_lines, pending_lines_tail): New variables.
	(dwarf2_gen_line_info_1): Delete.
	(dwarf2_push_line, dwarf2_flush_pending_lines): New functions.
	(dwarf2_gen_line_info, dwarf2_emit_label): Use them.
	(dwarf2_consume_line_info): Call dwarf2_flush_pending_lines.
	(dwarf2_directive_loc): Push previous .locs instead of generating
	them immediately.
@
text
@d172 1
d242 1
a242 1
/* Find or create an entry for SEG+SUBSEG in ALL_SEGS.  */
d245 1
a245 1
get_line_subseg (segT seg, subsegT subseg)
d260 3
d286 1
d310 1
a310 1
  lss = get_line_subseg (now_seg, now_subseg);
d404 27
@


1.119
log
@	* elflink.c (_bfd_elf_gc_mark_extra_sections): Remove mark from
	fragmented .debug_line sections associated with unmarked code
	sections.

	* dwarf.c (read_debug_line_header): New function.  Reads in a
	header in a .debug_line section.
	(display_debug_lines_raw): Use new function.  Handle fragmentary
	.debug_line sections.
	(display_debug_lines_decoded): Likewise.
	* readelf.c (process_section_headers): Handle fragmenatry
	.debug_line sections.
	(display_debug_section): Likewise.

	* as.c (Options): Add -gdwarf-sections.
	(parse_args): Likewise.
	* as.h (flag_dwarf_sections): Declare.
	* dwarf2dbg.c (emit_fixed_inc_line_addr): Skip section changes.
	(process_entries): When -gdwarf-sections is enabled generate
	fragmentary .debug_line sections.
	(out_debug_line): Set the section for the .debug_line section end
	symbol.
	* doc/as.texinfo: Document -gdwarf-sections.
	* NEWS: Mention -gdwarf-sections.

	* gas/elf/dwarf2-3.d: Fix expected readelf output.

	* scripttempl/DWARF.sc: Add support for .debug_line.* and
	.debug_line_end.
@
text
@a218 4
/* Lines that are at the same location as CURRENT, and which are waiting
   for a label.  */
static struct line_entry *pending_lines, **pending_lines_tail = &pending_lines;

d292 1
a292 1
/* Push LOC onto the pending lines list.  */
d295 1
a295 1
dwarf2_push_line (struct dwarf2_line_info *loc)
d297 1
d302 1
a302 1
  e->label = NULL;
d305 3
a307 29
  *pending_lines_tail = e;
  pending_lines_tail = &(*pending_lines_tail)->next;
}

/* Emit all pending line information.  LABEL is the label with which the
   lines should be associated, or null if they should be associated with
   the current position.  */

static void
dwarf2_flush_pending_lines (symbolS *label)
{
  if (pending_lines)
    {
      struct line_subseg *lss;
      struct line_entry *e;

      if (!label)
	label = symbol_temp_new_now ();

      for (e = pending_lines; e; e = e->next)
	e->label = label;

      lss = get_line_subseg (now_seg, now_subseg);
      *lss->ptail = pending_lines;
      lss->ptail = pending_lines_tail;

      pending_lines = NULL;
      pending_lines_tail = &pending_lines;
    }
d318 2
a334 1
  dwarf2_push_line (loc);
d342 1
a342 1
      dwarf2_flush_pending_lines (symbol_new (name, now_seg, ofs, frag_now));
d345 2
a346 1
    dwarf2_flush_pending_lines (symbol_temp_new (now_seg, ofs, frag_now));
a406 5
  /* If the consumer has stashed the current location away for later use,
     assume that any earlier location information should be associated
     with ".".  */
  dwarf2_flush_pending_lines (NULL);

d438 1
a438 2
  dwarf2_push_line (&loc);
  dwarf2_flush_pending_lines (label);
d598 1
a598 1
    dwarf2_push_line (&current);
@


1.118
log
@Remove trailing redundant `;'

bfd/

	* aout-tic30.c (MY_final_link_callback): Remove trailing
	redundant `;'.
	* coff-h8500.c (extra_case): Likewise.
	(bfd_coff_reloc16_get_value): Likewise.
	* dwarf2.c (_bfd_dwarf2_cleanup_debug_info): Likewise.
	* elf.c (_bfd_elf_slurp_version_tables): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_perform_relocation): Likewise.
	* opncls.c (bfd_calc_gnu_debuglink_crc32): Likewise.
	* plugin.c (add_symbols): Likewise.
	* reloc.c (bfd_check_overflow): Likewise.
	* vms-lib.c (_bfd_vms_lib_archive_p): Likewise.

binutils/

	* coffgrok.c (coff_grok): Remove trailing redundant `;'.
	* resrc.c (open_input_stream): Likewise.

gas/

	* config/atof-ieee.c (gen_to_words): Remove trailing redundant
	`;'.
	* config/atof-vax.c (flonum_gen2vax): Likewise.
	* config/tc-d10v.c (write_2_short): Likewise.
	* config/tc-i386-intel.c (i386_intel_simplify): Likewise.
	* config/tc-s390.c (tc_s390_force_relocation): Likewise.
	* config/tc-v850.c (md_parse_option): Likewise.
	* config/tc-xtensa.c (find_address_of_next_align_frag): Likewise.
	* dwarf2dbg.c (out_header): Likewise.
	* symbols.c (dollar_label_name): Likewise.
	(fb_label_name): Likewise.

ld/

	* testplug.c (record_add_file): Remove trailing redundant `;'.

opcodes/

	* aarch64-opc.h (gen_mask): Remove trailing redundant `;'.
	* ia64-gen.c (fetch_insn_class): Likewise.
@
text
@d2 1
a2 2
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
   Free Software Foundation, Inc.
a1110 1
  segT line_seg;
d1117 3
a1127 1
  line_seg = subseg_get (".debug_line", 0);
a1147 1
      subseg_change (line_seg, 0);
a1153 1
      subseg_change (line_seg, 0);
d1295 34
d1569 10
@


1.117
log
@gas/ChangeLog:
2012-08-01  James Lemke  <jwlemke@@codesourcery.com>

	* gas/dwarf2dbg.c (out_set_addr): Allow for non-constant value of
	DWARF2_LINE_MIN_INSN_LENGTH
	* gas/config/tc-ppc.c (ppc_dwarf2_line_min_insn_length): Declare
	and initialize.
	(md_apply_fix): Branch addr can be a multiple of 2 or 4.
	* gas/config/tc-ppc.h (DWARF2_LINE_MIN_INSN_LENGTH): Now a
	variable reference.

gas/testsuite/ChangeLog:
2012-08-01  James Lemke  <jwlemke@@codesourcery.com>

	* gas/cfi/cfi-ppc-1.d: Allow for code alignment of 2 or 4.

ld/ChangeLog:
2012-08-01  James Lemke  <jwlemke@@codesourcery.com>

	* ld/testsuite/ld-gc/pr13683.d: XFAIL for powerpc*-*-eabivle.
@
text
@d1450 1
a1450 1
  start_sym = symbol_temp_new_now ();;
@


1.116
log
@	* dwarf2dbg.c (DWARF2_USE_FIXED_ADVANCE_PC): Enable when using
	linker relaxation.
	(dwarf2_gen_line_info): Generate real, local, labels for line
	numbers.
	(dwarf2dbg_convert_frag): Do not finalize the computation of the
	frag's symbol value when linker relaxation is enabled.
	(ADDR_DELTA_LIMIT): Define.
	(size_fixed_inc_line_addr): Use ADDR_DELTA_LIMIT.
	(emit_fixed_inc_line_addr): Likewise.
	* write.c (fixup_segment): If the subtraction of two symbols
	cannot be resolved but is valid, then prevent bogus range warnings
	by pre-biasing add_number.
	* config/tc-h8300.h (DWARF2_USE_FIXED_ADVANCE_PC): Define to 0.

	* gas/lns/lns.exp: Use alternate lns-common test for targets
	enabling linker relaxation.
	* gas/lns/lns-big-delta.d: Allow for output from architectures
	with 32-bit addresses.
@
text
@a884 1
#if DWARF2_LINE_MIN_INSN_LENGTH > 1
d891 1
a891 1
  if (*addr_delta % DWARF2_LINE_MIN_INSN_LENGTH != 0)
d893 6
a898 3
      if (!printed_this)
	as_bad("unaligned opcodes detected in executable segment");
      printed_this = 1;
a899 1
  *addr_delta /= DWARF2_LINE_MIN_INSN_LENGTH;
a900 3
#else
#define scale_addr_delta(A)
#endif
@


1.116.2.1
log
@	PR 12549
	PR 14493
	PR 14567
	PR 14662
	PR 14758
	PR 14813
	PR 14904
	PR 14915
	PR 14926
	PR 14950
	PR 14962
	Apply mainline patches
@
text
@d885 1
d892 1
a892 1
  if (DWARF2_LINE_MIN_INSN_LENGTH > 1)
d894 3
a896 6
      if (*addr_delta % DWARF2_LINE_MIN_INSN_LENGTH != 0  && !printed_this)
        {
	  as_bad("unaligned opcodes detected in executable segment");
          printed_this = 1;
        }
      *addr_delta /= DWARF2_LINE_MIN_INSN_LENGTH;
d898 1
d900 3
@


1.115
log
@gas: Make dwarf2dbg.c versions specific and add DW_AT_high_pc case for DWARF 4+.

    * dwarf2dbg.c (DWARF2_ARANGES_VERSION): New define to 2.
    (DWARF2_LINE_VERSION): Likewise.
    (out_debug_line): Use DWARF2_LINE_VERSION not DWARF2_VERSION.
    (out_debug_aranges): Use DWARF2_ARANGES_VERSION not DWARF2_VERSION.
    (out_debug_abbrev): Use DW_FORM_data for DW_AT_high_pc when
    DWARF2_VERSION >= 4.
    (out_debug_info): Use difference between start and end as data
    value for DW_AT_high_pc when DWARF2_VERSION >= 4.
    * config/tc-ia64.h (DWARF2_LINE_VERSION): Override it.
@
text
@d122 1
a122 1
# define DWARF2_USE_FIXED_ADVANCE_PC	0
d364 11
a374 1
  dwarf2_flush_pending_lines (symbol_temp_new (now_seg, ofs, frag_now));
d1077 1
d1088 1
a1088 1
  if (addr_delta > 50000)
d1136 1
a1136 1
  if (addr_delta > 50000)
d1245 18
a1262 1
  addr_diff = resolve_symbol_value (frag->fr_symbol);
@


1.114
log
@gas/
	PR gas/13167
	* dwarf2dbg.c (dwarf2_flush_pending_lines): Use symbol_temp_new_now.

gas/testsuite/
	PR gas/13167
	* gas/ia64/pr13167.d, gas/ia64/pr13167.s: New test.
	* gas/ia64/ia64.exp: Run it.
@
text
@d96 10
d1470 1
a1470 1
  out_two (DWARF2_VERSION);
d1578 1
a1578 1
  out_two (DWARF2_VERSION);
d1644 5
a1648 1
      out_abbrev (DW_AT_high_pc, DW_FORM_addr);
d1711 7
a1717 1
      exp.X_op = O_symbol;
@


1.113
log
@gas/
	PR gas/13024
	* dwarf2dbg.c (pending_lines, pending_lines_tail): New variables.
	(dwarf2_gen_line_info_1): Delete.
	(dwarf2_push_line, dwarf2_flush_pending_lines): New functions.
	(dwarf2_gen_line_info, dwarf2_emit_label): Use them.
	(dwarf2_consume_line_info): Call dwarf2_flush_pending_lines.
	(dwarf2_directive_loc): Push previous .locs instead of generating
	them immediately.

gas/testsuite/
	* gas/mips/loc-swap-2.s, gas/mips/loc-swap-2.d,
	gas/mips/micromips@@loc-swap-2.d,
	gas/mips/mips16@@loc-swap-2.d: New test.
	* gas/mips/mips.exp: Run it.
@
text
@d316 1
a316 1
	label = symbol_temp_new (now_seg, 0, frag_now);
@


1.112
log
@	* dwarf2dbg.c (out_debug_line): Ignore non-normal segments, with a
	warning.
	* doc/as.texinfo (Offset): Document .offset directive.

	testsuite/
	* gas/elf/warn-2.s: New.
@
text
@d210 4
d287 1
a287 1
/* Record an entry for LOC occurring at LABEL.  */
d290 1
a290 1
dwarf2_gen_line_info_1 (symbolS *label, struct dwarf2_line_info *loc)
a291 1
  struct line_subseg *lss;
d296 1
a296 1
  e->label = label;
d299 29
a327 3
  lss = get_line_subseg (now_seg, now_subseg);
  *lss->ptail = e;
  lss->ptail = &e->next;
a337 2
  symbolS *sym;

d353 2
a354 2
  sym = symbol_temp_new (now_seg, ofs, frag_now);
  dwarf2_gen_line_info_1 (sym, loc);
d415 5
d451 2
a452 1
  dwarf2_gen_line_info_1 (label, &loc);
d612 1
a612 1
    dwarf2_emit_insn (0);
@


1.111
log
@2011-03-31  Tristan Gingold  <gingold@@adacore.com>

	* dwarf2dbg.c (DWARF2_VERSION): Define.
	(out_debug_line): Use it.
	(out_debug_aranges): Ditto.
	(out_debug_info): Ditto.
	* config/tc-ia64.h (DWARF2_VERSION): Override it.
@
text
@d1462 5
a1466 1
    process_entries (s->seg, s->head->head);
@


1.110
log
@2011-03-10  Michael Snyder  <msnyder@@vmware.com>

	Revert the following change:
	* dwarf2dbg.c (out_file_list): Free malloced 'dir'.
	(out_debug_info): Free malloced 'dirname' and 'comp_dir'.
@
text
@d92 4
d1427 1
a1427 1
  out_two (2);
d1531 1
a1531 1
  out_two (2);
d1634 1
a1634 1
  out_two (2);
@


1.109
log
@2011-03-09  Michael Snyder  <msnyder@@vmware.com>

	* dwarf2dbg.c (out_file_list): Free malloced 'dir'.
	(out_debug_info): Free malloced 'dirname' and 'comp_dir'.
	(emit_fixed_inc_line_addr): Assign instead of conditional
	in assert.
@
text
@a1330 1
      xfree ((char *) dir);
a1686 1
      xfree ((char *) dirname);
a1696 1
  xfree ((char *) comp_dir);
@


1.108
log
@ChangeLog binutils/
2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* debug.c (debug_start_source): Use filename_(n)cmp.
	* ieee.c (ieee_finish_compilation_unit): Likewise.
	(ieee_lineno): Likewise.
	* nlmconv.c (main): Likewise.
	* objcopy.c (strip_main): Likewise.
	(copy_main): Likewise.
	* objdump.c (show_line): Likewise.
	(dump_reloc_set): Likewise.
	* srconv.c (main): Likewise.
	* wrstabs.c (stab_lineno): Likewise.

ChangeLog gas/
2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* depend.c (register_dependency): Use filename_(n)cmp.
	* dwarf2dbg.c (get_filenum): Likewise.
	* ecoff.c (add_file): Likewise.
	(ecoff_generate_asm_lineno): Likewise.
	* input-scrub.c (new_logical_line_flags): Likewise.
	* listing.c (file_info): Likewise.
	(listing_newline): Likewise.
	* remap.c (remap_debug_filename): Likewise.
	* stabs.c (generate_asm_file): Likewise.
	(stabs_generate_asm_lineno): Likewise.
@
text
@d1083 1
a1083 1
      gas_assert (pexp->X_op = O_subtract);
d1331 1
d1688 1
d1699 1
@


1.107
log
@Don't generate .debug_line section if it isn't empty.

binutils/testsuite/

2010-07-05  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/10531
	PR gas/11789
	* binutils-all/objdump.W: Remove bogus line debug info.

gas/

2010-07-05  Jim Wilson  <wilson@@codesourcery.com>

	PR gas/10531
	PR gas/11789
	* dwarf2dbg.c (dwarf2_finish): Don't generate .debug_line section
	if it isn't empty.

gas/testsuite/

2010-07-05  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/10531
	PR gas/11789
	* gas/i386/dw2-compress-1.d: Remove bogus line debug info.

	* gas/elf/dwarf2-1.d: New.
	* gas/elf/dwarf2-1.s: Likewise.
	* gas/elf/dwarf2-2.d: Likewise.
	* gas/elf/dwarf2-2.s: Likewise.
	* gas/elf/dwarf2-3.d: Likewise.
	* gas/elf/dwarf2-3.s: Likewise.
	* gas/i386/debug1.d: Likewise.
	* gas/i386/debug1.s: Likewise.

	* gas/elf/elf.exp: Run dwarf2-1, dwarf2-2 and dwarf2-3.

	* gas/i386/i386.exp: Run debug1 for both 32bit and 64bit.
@
text
@d434 1
a434 1
	  && strcmp (filename, files[last_used].filename) == 0)
d437 2
a438 2
	  && strncmp (filename, dirs[files[last_used].dir],
		      last_used_dir_len) == 0
d440 2
a441 2
	  && strcmp (filename + last_used_dir_len + 1,
		     files[last_used].filename) == 0)
d463 1
a463 1
	if (strncmp (filename, dirs[dir], dir_len) == 0
d488 1
a488 1
	    && strcmp (file, files[i].filename) == 0)
@


1.107.2.1
log
@	PR 12365
	PR 12613
	PR 12632
	PR 12739
	PR 12753
	PR 12760
	PR 12763
Apply fix from mainline along with assorted other small fixes.
@
text
@d1083 1
a1083 1
      gas_assert (pexp->X_op == O_subtract);
@


1.106
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d1721 6
a1726 5
   file has a non-empty .debug_info section.  If we emit .debug_line,
   and the .debug_info section is empty, we also emit .debug_info,
   .debug_aranges and .debug_abbrev.  ALL_SEGS will be non-null if
   there were any .file/.loc directives, or --gdwarf2 was given and
   there were any located instructions emitted.  */
d1735 1
d1740 13
a1752 3
  if (!all_segs && emit_other_sections)
    /* There is no line information and no non-empty .debug_info
       section.  */
@


1.105
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        * as.c (main): Call dwarf2_init.
        * config/obj-elf.c (struct group_list): New field.
        (build_group_lists): Use hash lookup.
        (free_section_idx): New function.
        (elf_frob_file): Adjust.
        * dwarf2dbg.c (all_segs_hash, last_seg_ptr): New variables.
        (get_line_subseg): Adjust.
        (dwarf2_init): New function.
        * dwarf2dbg.h (dwarf2_init): New declaration.
@
text
@d219 1
a219 1
  expressionS expr;
d221 4
a224 4
  expr.X_op = O_symbol;
  expr.X_add_symbol = symbol;
  expr.X_add_number = 0;
  emit_expr (&expr, size);
d238 1
a238 1
  struct line_subseg **pss, *ss;
d256 1
a256 1
  for (pss = &s->head; (ss = *pss) != NULL ; pss = &ss->next)
d258 1
a258 1
      if (ss->subseg == subseg)
d260 1
a260 1
      if (ss->subseg > subseg)
d264 6
a269 6
  ss = (struct line_subseg *) xmalloc (sizeof (*ss));
  ss->next = *pss;
  ss->subseg = subseg;
  ss->head = NULL;
  ss->ptail = &ss->head;
  *pss = ss;
d274 1
a274 1
  last_line_subseg = ss;
d276 1
a276 1
  return ss;
d284 1
a284 1
  struct line_subseg *ss;
d292 3
a294 3
  ss = get_line_subseg (now_seg, now_subseg);
  *ss->ptail = e;
  ss->ptail = &e->next;
d816 1
a816 1
  expressionS expr;
d822 4
a825 4
  expr.X_op = O_symbol;
  expr.X_add_symbol = sym;
  expr.X_add_number = 0;
  emit_expr (&expr, sizeof_address);
d1055 1
a1055 1
  expressionS *exp;
d1070 1
a1070 1
  exp = symbol_get_value_expression (frag->fr_symbol);
d1081 1
a1081 1
      expressionS expr;
d1083 2
a1084 2
      gas_assert (exp->X_op = O_subtract);
      to_sym = exp->X_add_symbol;
d1089 3
a1091 3
      expr.X_op = O_symbol;
      expr.X_add_symbol = to_sym;
      expr.X_add_number = 0;
d1093 1
a1093 1
      emit_expr_fix (&expr, sizeof_address, frag, p);
d1100 1
a1100 1
      emit_expr_fix (exp, 2, frag, p);
d1122 1
a1122 1
  expressionS expr;
d1125 4
a1128 4
  expr.X_op = O_subtract;
  expr.X_add_symbol = to_sym;
  expr.X_op_symbol = from_sym;
  expr.X_add_number = 0;
d1139 1
a1139 1
	    make_expr_symbol (&expr), line_delta, NULL);
d1371 1
a1371 1
out_header (asection *sec, expressionS *expr)
d1381 3
a1383 3
  expr->X_op = O_subtract;
  expr->X_add_symbol = end_sym;
  expr->X_op_symbol = start_sym;
d1388 2
a1389 2
      expr->X_add_number = -4;
      emit_expr (expr, 4);
d1393 1
a1393 1
      expr->X_add_number = -12;
d1395 1
a1395 1
      emit_expr (expr, 8);
d1399 2
a1400 2
      expr->X_add_number = -8;
      emit_expr (expr, 8);
d1413 1
a1413 1
  expressionS expr;
d1419 2
a1420 2
  sizeof_offset = out_header (line_seg, &expr);
  line_end = expr.X_add_symbol;
d1427 3
a1429 3
  expr.X_add_symbol = prologue_end;
  expr.X_add_number = - (4 + 2 + 4);
  emit_expr (&expr, sizeof_offset);
d1468 1
a1468 1
  expressionS expr;
d1493 9
a1501 9
      expr.X_op = O_symbol;
      expr.X_add_symbol = beg;
      expr.X_add_number = 0;
      emit_expr (&expr, addr_size);

      expr.X_op = O_symbol;
      expr.X_add_symbol = end;
      expr.X_add_number = 0;
      emit_expr (&expr, addr_size);
d1518 1
a1518 1
  expressionS expr;
d1523 2
a1524 2
  sizeof_offset = out_header (aranges_seg, &expr);
  aranges_end = expr.X_add_symbol;
d1554 10
a1563 10
      expr.X_op = O_symbol;
      expr.X_add_symbol = beg;
      expr.X_add_number = 0;
      emit_expr (&expr, addr_size);

      expr.X_op = O_subtract;
      expr.X_add_symbol = end;
      expr.X_op_symbol = beg;
      expr.X_add_number = 0;
      emit_expr (&expr, addr_size);
d1620 1
a1620 1
  expressionS expr;
d1626 2
a1627 2
  sizeof_offset = out_header (info_seg, &expr);
  info_end = expr.X_add_symbol;
d1650 4
a1653 4
      expr.X_op = O_symbol;
      expr.X_add_symbol = all_segs->text_start;
      expr.X_add_number = 0;
      emit_expr (&expr, sizeof_address);
d1656 4
a1659 4
      expr.X_op = O_symbol;
      expr.X_add_symbol = all_segs->text_end;
      expr.X_add_number = 0;
      emit_expr (&expr, sizeof_address);
d1753 2
a1754 2
      struct line_subseg *ss = s->head;
      struct line_entry **ptail = ss->ptail;
d1756 1
a1756 1
      while ((ss = ss->next) != NULL)
d1758 2
a1759 2
	  *ptail = ss->head;
	  ptail = ss->ptail;
@


1.104
log
@update copyright dates
@
text
@d171 4
d237 1
a237 1
  struct line_seg **ps, *s;
d243 12
a254 9
  for (ps = &all_segs; (s = *ps) != NULL; ps = &s->next)
    if (s->seg == seg)
      goto found_seg;

  s = (struct line_seg *) xmalloc (sizeof (*s));
  s->next = NULL;
  s->seg = seg;
  s->head = NULL;
  *ps = s;
a255 1
 found_seg:
d476 1
a476 1
	  dirs[dir] = xmalloc (dir_len + 1);
d1711 8
@


1.104.2.1
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.
@
text
@d470 1
a470 1
	  dirs[dir] = (char *) xmalloc (dir_len + 1);
@


1.103
log
@bfd
	* Makefile.am (dwarf2.lo): Use dwarf2.h, not elf/dwarf2.h.
	(elf-eh-frame.lo): Likewise.
	(elf32-bfin.lo): Likewise.
	(elf32-frv.lo): Likewise.
	(elf32-xc16x.lo): Likewise.
	* Makefile.in: Rebuild.
	* dwarf2.c: Included dwarf.h, not elf/dwarf2.h.
	* elf-eh-frame.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-xc16x.c: Likewise.
binutils
	* Makefile.am (dwarf.o): Refer to dwarf2.h, not elf/dwarf2.h.
	* Makefile.in: Rebuild.
	* dwarf.c: Include dwarf2.h, not elf/dwarf2.h.
gas
	* Makefile.am (DEPTC_alpha_ecoff): Refer to dwarf2.h, not
	elf/dwarf2.h.
	(DEPTC_alpha_elf): Likewise.
	(DEPTC_alpha_evax): Likewise.
	(DEPTC_arm_elf): Likewise.
	(DEPTC_hppa_elf): Likewise.
	(DEPTC_i386_aout): Likewise.
	(DEPTC_i386_coff): Likewise.
	(DEPTC_i386_elf): Likewise.
	(DEPTC_m68k_aout): Likewise.
	(DEPTC_m68k_coff): Likewise.
	(DEPTC_m68k_elf): Likewise.
	(DEPTC_mips_coff): Likewise.
	(DEPTC_mips_ecoff): Likewise.
	(DEPTC_mips_elf): Likewise.
	(DEPTC_ppc_coff): Likewise.
	(DEPTC_ppc_elf): Likewise.
	(DEPTC_s390_elf): Likewise.
	(DEPTC_sh_coff): Likewise.
	(DEPTC_sh_elf): Likewise.
	(DEPTC_sh64_elf): Likewise.
	(DEPTC_sparc_aout): Likewise.
	(DEPTC_sparc_coff): Likewise.
	(DEPTC_sparc_elf): Likewise.
	(as.o): Likewise.
	(dwarf2dbg.o): Likewise.
	(dw2gencfi.o): Likewise.
	(ehopt.o): Likewise.
	(read.o): Likewise.
	* Makefile.in: Rebuild.
	* dw2gencfi.h: Include dwarf2.h, not elf/dwarf2.h.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
gdb
	* dwarf2-frame.c: Include dwarf2.h, not elf/dwarf2.h.
	* dwarf2expr.c: Likewise.
	* dwarf2loc.c: Likewise.
	* dwarf2read.c: Likewise.
	* sh-tdep.c: Likewise.
	* xtensa-tdep.c: Likewise.
include
	* dwarf2.h: New file, moved from elf/.
include/elf

	* dwarf2.h: Move to `..'.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
@


1.102
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d94 1
a94 1
#include "elf/dwarf2.h"
@


1.101
log
@	* NEWS: Add item about discriminator support.
	* dwarf2dbg.h (struct dwarf2_line_info): Add discriminator field.
	* dwarf2dbg.c (current): Add discriminator field.
	(dwarf2_where): Copy discriminator value.
	(dwarf2_consume_line_info): Set discriminator to 0.
	(dwarf2_directive_loc): Process discriminator sub-op.
	(out_leb128): New function.
	(process_entries): Output DW_LNE_set_discriminator.
	* doc/as.texinfo: Add discriminator operand to .loc directive.
	* testsuite/gas/lns/lns-common-1.d: Add test for discriminator.
	* testsuite/gas/lns/lns-common-1.s: Likewise.
@
text
@d916 1
a916 1
  assert ((offsetT) addr_delta >= 0);
d997 1
a997 1
  assert (p == end);
d1055 1
a1055 1
  assert ((offsetT) addr_delta >= 0);
d1077 1
a1077 1
      assert (exp->X_op = O_subtract);
d1107 1
a1107 1
  assert (p == end);
d1186 1
a1186 1
  assert (frag->fr_var >= (int) frag->fr_subtype);
d1760 1
a1760 1
      assert (all_segs);
@


1.100
log
@2009-03-03  Tristan Gingold  <gingold@@adacore.com>
	    Eric Botcazou  <ebotcazou@@adacore.com>
	    Douglas B Rupp  <rupp@@gnat.com>

	* doc/as.texinfo (Overview): Mention -replace/-noreplace options
	for Alpha.
	* doc/c-alpha.texi (Alpha Options): Document -replace/-noreplace.
	* config/tc-alpha.h (TC_VALIDATE_FIX_SUB): Define to 1 (evax).
	(OBJ_SYMFIELD_TYPE): Remove.
	(tc_canonicalize_symbol_name): Define to evax_shorten_name.
	(TC_IMPLICIT_LCOMM_ALIGNMENT): For alignment to 3 on evax.
	(tc_frob_file_before_fix): Do not defined on evax.
	* config/tc-alpha.c: Always includes dwarf2dbg.h.
	Include vms.h if OBJ_EVAX.
	(struct alpha_fixup): Add xtrasym and procsym (evax only).
	(enum alpha_macro_arg): Remove trailing comma.
	(md_longopts): Add replace and noreplace arguments (evax only).
	(alpha_evax_proc_hash): New variable.
	(alpha_link_section): Make it global.
	(alpha_ctors_section, alpha_dtors_section): Removed.
	(alpha_ctors_symbol, alpha_dtors_symbol): Ditto.
	(alpha_lit8_section): Ifndef'ed on evax.
	(alpha_lit8_symbol): Ditto.
	(alpha_prologue_label): New variable.
	(alpha_linkage_symbol): New variable (evax only).
	(alpha_flag_replace): Ditto.
	(struct alpha_evax_procs): Add handler and handler_data field.
	(alpha_evax_proc): Now of type pointer.
	(alpha_linkage_fixup_root, alpha_linkage_fixup_tail): New variables.
	(struct alpha_reloc_tag): Add sym and psym fields (evax only).
	(get_alpha_reloc_tag): Initialize sym and psym fields (evax only).
	(alpha_adjust_relocs): Ifndef'ed on evax.
	(load_expression): Add opname argument.
	Implement LDA/BSR optimization for evax.
	(emit_lda): Adjust for new prototype of load_expression.
	(emit_ir_load): Ditto. Do not nothing for GP if ..lk symbols.
	(emit_loadstore): Likewise.
	(emit_ldXu): Likewise.
	(emit_stX): Likewise.
	(emit_jsrjmp): Likewise.  Implement LDA/BSR optimization for evax.
	(emit_ldgp): Avoid warning in evax case.
	(add_to_link_pool): Make it static.  Return symbolic expression rather
	than number expression for the offset.
	(s_alpha_text): Create .text symbol for evax if not already created.
	(s_alpha_comm): Do not create specific section for common symbol.
	Fill common area with zeros for evax.
	(s_alpha_prologue): Create alpha_prologue_label.
	(s_alpha_section_name): New function (evax).
	(s_alpha_section_word): Likewise.
	(section_name): New static variabke moved out from ...
	(s_alpha_section): ... here.  Create new sections on demand.
	(s_alpha_literals): New function (evax).
	(s_alpha_ent): Create alpha_evax_proc instance and insert it in the
	alpha_evax_proc_hash table.
	(s_alpha_handler): New function (evax).
	(s_alpha_frame): Adjust for new type of alpha_evax_proc.
	(s_alpha_prologue): New function (evax).
	(s_alpha_pdesc): Adjust for new type of alpha_evax_proc and new
	handling of procedures with hash table.
	Add support for condition handlers.
	(s_alpha_linkage): Create linkage_fixup instance and chain it.
	(s_alpha_fp_save): Adjust for new type of alpha_evax_proc.
	(s_alpha_mask): Likewise.
	(s_alpha_fmask): Likewise.
	(s_alpha_end): Clear alpha_evax_proc.
	(s_alpha_align): Increase max_alignment to 16.
	(alpha_print_token): Call print_expr_1 instead of print_expr.
	(md_pseudo_table): Add "section", "literals", "handler" and
	"handler_data" (evax).  Do not ignore "prologue" on evax.
	Fix indentation.
	(md_begin): Create hash table for alpha_evax_proc_hash.
	(md_parse_option): Handle OPTION_REPLACE and OPTION_NOREPLACE.
	(md_show_usage): Mention -replace/-noreplace for evax.
	(md_apply_fix): Handle evax relocs (_NOP, _LDA, _BSR and _BOH).
	(alpha_force_relocation): Likewise.
	(alpha_fix_adjustable): Likewise. Add BFD_RELOC_16 case.
	(tc_gen_reloc): Likewise.  Add BFD_RELOC_ALPHA_LINKAGE for evax.
	(emit_insn): New cases for evax specific relocs.
	(assemble_insn): Fix indentation.
	Take care of -MDISP in operand table.
	* config/obj-evax.h (struct alpha_linkage_fixups): New struct.
	(OBJ_SYMFIELD_TYPE): New macro.
	(obj_symbol_new_hook): Define.
	(obj_frob_symbol, obj_frob_file_before_adjust): Ditto.
	(obj_frob_file_before_fix): Ditto.
	(PDSC_S_M_HANDLER_VALID): New macro.
	(PDSC_S_M_HANDLER_DATA_VALID): Ditto.
	(TC_IMPLICIT_LCOMM_ALIGNMENT): Remove.
	Add prototypes for functions declared in obj-evax.c
	* config/obj-evax.c: Include subsegs.h, struc-symbol.h, safe-ctype.h.
	(s_evax_weak): Convert to ansi-C.
	(evax_symbol_new_hook): New function.
	(evax_frob_symbol): Ditto.
	(evax_frob_file_before_adjust): Ditto.
	(evax_frob_file_before_fix): Ditto.
	(evax_shorten_name): Ditto.
	(crc32): Ditto.
	(encode_32): Ditto.
	(encode_16): Ditto.
	(decode_16): Ditto.
	(shorten_identifier): Ditto.
	(is_truncated_identifier): Ditto.
	* dwarf2dbg.c (out_debug_info): Do not append trailing slash on	VMS.
	* as.c (close_output_file): Remove #ifndef OBJ_VMS.
	(main): Ditto.
@
text
@d28 2
a29 1
	      [epilogue_begin] [is_stmt VALUE] [isa VALUE]
d198 2
a199 1
  DWARF2_LINE_DEFAULT_IS_STMT ? DWARF2_FLAG_IS_STMT : 0
d336 1
d385 1
d588 1
d667 12
d768 8
d1236 8
@


1.99
log
@        * include/elf/ia64.h (SHT_IA_64_VMS_DISPLAY_NAME_INFO,
        EF_IA_64_ARCHVER_1): New macros. Minor reformatting.

        * bfd/Makefile.am (BFD32_BACKENDS): Add new object vmsutil.lo
        (BFD32_BACKENDS_CFILES): Add new file vmsutil.c
        (vmsutil.lo): Add dependency rule
        * bfd/Makefile.in: Regenerate
        * bfd/config.bfd (ia64*-*-*vms*): Add case.
        * bfd/configure.in (bfd_elf64_ia64_vms_vec): Add case.
        * bfd/configure: Regenerate
        * bfd/vmsutil.[ch]: New files
        * bfd/elf-bfd.h (struct bfd_elf_special_section): Change type of
        attr to bfd_vma.
        * bfd/elfxx-ia64.c (elfNN_vms_post_process_headers,
        elfNN_vms_section_processing, elfNN_vms_final_write_processing,
        elfNN_vms_close_and_cleanup, elfNN_vms_section_from_shdr,
        elfNN_vms_object_p): New functions
        * bfd/targets.c (bfd_elf64_ia64_vms_vec): New target.

        * gas/configure.tgt(ia64-*-*vms*): New target.
        * gas/dwarf2dbg.h (dwarf2_loc_mark_labels): Make extern.
        * gas/tc.h (md_number_to_chars): Declare iff undefined.
        * gas/config/obj-elf.c (obj_elf_change_section): Change type of
        arg attr to bfd_vma.
        (obj_elf_parse_section_letters): Return a bfd_vma. Change type of
        variables attr, md_attr to bfd_vma.
        (obj_elf_section_word): Likewise.
        (obj_elf_section): Change type of variable attr to bfd_vma
        * gas/config/obj-elf.h (obj_elf_change_section): Change type of
        arg attr to bfd_vma
        * gas/config/tc-ia64.c (bfdver.h,time.h): Include.
        (ia64_elf_section_letter): Now returns a bfd_vma.
        Handle VMS specific attributes.
        (ia64_elf_section_flags): Arg attr now a bfd_vma.
        (ia64_init): Don't turn on dependency checking for VMS.
        (ia64_target_format): Check for VMS flag bit.
        (do_alias): Hande decc$ functions.
        (get_vms_time): New function.
        (ia64_vms_note): New function.
        * gas/config/tc-ia64.h (ia64_elf_section_letter): Now returns a bfd_vma.
        (ia64_elf_section_flags): Arg attr now a bfd_vma.
        (tc_init_after_args): Define for VMS.
        * gas/config/tc-alpha.c (alpha_elf_section_letter): Return a bfd_vma.
        (alpha_elf_section_flags): Change type of arg attr to bfd_vma.
        * gas/config/tc-alpha.h: Likewise.
        * gas/config/tc-i386.c (x86_64_section_letter): Return a bfd_vma.
        (x86_64_section_word): Return a bfd_vma.
        * gas/config/tc-i386.h: Likewise.
        * gas/config/tc-ip2k.c (ip2k_elf_section_flags): Change type of arg
        attr to bfd_vma.
        * gas/config/tc-ip2k.h: Likewise.
        * gas/config/tc-mep.c (mep_elf_section_letter): Return a bfd_vma.
        (mep_elf_section_flags): Change type of arg attr to bfd_vma.
        * gas/config/tc-mep.h: Likewise.
        * gas/config/tc-ppc.c  (ppc_section_letter): Return a bfd_vma.
        (ppc_section_word): Return a bfd_vma.
        (ppc_section_flags): Change type of arg attr to bfd_vma.
        * gas/config/tc-ppc.h: Likewise.
        * gas/config/te-vms.h (DWARF2_DIR_SHOULD_END_WITH_SEPARATOR,
        DWAR2_FILE_TIME_NAME, DWARF2_FILE_SIZE_NAME, DWARF2_FILEN_NAME):
        New file with new macros
        * gas/dwarf2dbg.c (get_filenum, out_file_list): Default and call new
        macros.
@
text
@d1639 5
d1647 1
@


1.98
log
@	PR gas/6656
	* dwarf2dbg.c (dwarf2_directive_file): Disable gas generated
	debug info if we see compiler generated debug info.
	(dwarf2_directive_loc): Likewise.  Remove redundant debug_type test.
@
text
@d79 12
d449 1
d451 1
d1298 2
d1308 3
a1310 1
      size = strlen (files[i].filename) + 1;
d1312 1
a1312 1
      memcpy (cp, files[i].filename, size);
d1315 6
a1320 2
      out_uleb128 (0);			/* last modification timestamp */
      out_uleb128 (0);			/* filesize */
@


1.97
log
@	* dwarf2dbg.c: Remove superfluous forward function declarations.
	(DWARF2_FORMAT): Add section arg.
	(out_header): New function, split out from..
	(out_debug_line): ..here.
	(out_debug_aranges): Use out_header.
	(out_debug_abbrev): Add info_seg and line_seg args.  Use
	DW_FORM_data8 (for DW_AT_stmt_list) if line_seg is 64-bit.
	(out_debug_info): Use out_header.  Output 8 byte DW_AT_stmt_list
	if line_seg is 64-bit.
	(dwarf2_finish): Adjust out_debug_abbrev call.
	* config/tc-mips.h (DWARF2_FORMAT, mips_dwarf2_format): Add sec arg.
	* config/tc-mips.c (mips_dwarf2_format): Likewise.
@
text
@d528 4
d550 1
a550 1
  if (dwarf2_loc_directive_seen && debug_type != DEBUG_DWARF2)
d660 1
@


1.96
log
@	* dwarf2dbg.c (dwarf2_emit_insn): Simplify test before dwarf2_where
	call.  Delete out of date comment.
	(dwarf2_consume_line_info): Always clear dwarf2_loc_directive_seen.
	(dwarf2_emit_label): Don't emit unless there has been a previous
	.file or we are outputting assembler generated debug.
	dwarf2_consume_line_info after emitting line info, not before.
	(out_debug_info): Simplify files_in_use test.
@
text
@d72 1
a72 1
# define DWARF2_FORMAT() dwarf2_format_32bit
a190 1
static struct line_subseg *get_line_subseg (segT, subsegT);
d192 1
a192 22
static struct frag *first_frag_for_seg (segT);
static struct frag *last_frag_for_seg (segT);
static void out_byte (int);
static void out_opcode (int);
static void out_two (int);
static void out_four (int);
static void out_abbrev (int, int);
static void out_uleb128 (addressT);
static offsetT get_frag_fix (fragS *, segT);
static void out_set_addr (symbolS *);
static int size_inc_line_addr (int, addressT);
static void emit_inc_line_addr (int, addressT, char *, int);
static int size_fixed_inc_line_addr (int, addressT);
static void emit_fixed_inc_line_addr (int, addressT, fragS *, char *, int);
static void out_inc_line_addr (int, addressT);
static void relax_inc_line_addr (int, symbolS *, symbolS *);
static void process_entries (segT, struct line_entry *);
static void out_file_list (void);
static void out_debug_line (segT);
static void out_debug_aranges (segT, segT);
static void out_debug_abbrev (segT);

d1300 42
a1347 1
  symbolS *line_start;
a1350 1
  enum dwarf2_format d2f;
d1353 2
a1354 35
  subseg_set (line_seg, 0);

  line_start = symbol_temp_new_now ();
  prologue_end = symbol_temp_make ();
  line_end = symbol_temp_make ();

  /* Total length of the information for this compilation unit.  */
  expr.X_op = O_subtract;
  expr.X_add_symbol = line_end;
  expr.X_op_symbol = line_start;

  d2f = DWARF2_FORMAT ();
  if (d2f == dwarf2_format_32bit)
    {
      expr.X_add_number = -4;
      emit_expr (&expr, 4);
      sizeof_offset = 4;
    }
  else if (d2f == dwarf2_format_64bit)
    {
      expr.X_add_number = -12;
      out_four (-1);
      emit_expr (&expr, 8);
      sizeof_offset = 8;
    }
  else if (d2f == dwarf2_format_64bit_irix)
    {
      expr.X_add_number = -8;
      emit_expr (&expr, 8);
      sizeof_offset = 8;
    }
  else
    {
      as_fatal (_("internal error: unknown dwarf2 format"));
    }
d1360 1
a1360 1
  expr.X_op = O_subtract;
a1361 1
  expr.X_op_symbol = line_start;
a1450 1
  addressT size, skip;
d1453 1
d1455 1
d1457 2
a1458 16
  size = 4 + 2 + 4 + 1 + 1;

  skip = 2 * addr_size - (size & (2 * addr_size - 1));
  if (skip == 2 * addr_size)
    skip = 0;
  size += skip;

  for (s = all_segs; s; s = s->next)
    size += 2 * addr_size;

  size += 2 * addr_size;

  subseg_set (aranges_seg, 0);

  /* Length of the compilation unit.  */
  out_four (size - 4);
d1464 1
a1464 2
  /* ??? sizeof_offset */
  TC_DWARF2_EMIT_OFFSET (section_symbol (info_seg), 4);
d1473 1
a1473 2
  if (skip)
    frag_align (ffs (2 * addr_size) - 1, 0, 0);
d1503 2
d1511 3
a1513 1
out_debug_abbrev (segT abbrev_seg)
d1520 4
a1523 1
  out_abbrev (DW_AT_stmt_list, DW_FORM_data4);
d1531 1
a1531 1
      if (DWARF2_FORMAT () == dwarf2_format_32bit)
a1554 1
  symbolS *info_start;
a1557 1
  enum dwarf2_format d2f;
d1560 2
a1561 34
  subseg_set (info_seg, 0);

  info_start = symbol_temp_new_now ();
  info_end = symbol_temp_make ();

  /* Compilation Unit length.  */
  expr.X_op = O_subtract;
  expr.X_add_symbol = info_end;
  expr.X_op_symbol = info_start;

  d2f = DWARF2_FORMAT ();
  if (d2f == dwarf2_format_32bit)
    {
      expr.X_add_number = -4;
      emit_expr (&expr, 4);
      sizeof_offset = 4;
    }
  else if (d2f == dwarf2_format_64bit)
    {
      expr.X_add_number = -12;
      out_four (-1);
      emit_expr (&expr, 8);
      sizeof_offset = 8;
    }
  else if (d2f == dwarf2_format_64bit_irix)
    {
      expr.X_add_number = -8;
      emit_expr (&expr, 8);
      sizeof_offset = 8;
    }
  else
    {
      as_fatal (_("internal error: unknown dwarf2 format"));
    }
d1576 3
a1578 2
  /* ??? sizeof_offset */
  TC_DWARF2_EMIT_OFFSET (section_symbol (line_seg), 4);
d1721 1
a1721 1
      out_debug_abbrev (abbrev_seg);
@


1.95
log
@gas/
	* dwarf2dbg.c (out_sleb128): Delete.
	(size_fixed_inc_line_addr, emit_fixed_inc_line_addr): New.
	(out_fixed_inc_line_addr): Delete.
	(relax_inc_line_addr, dwarf2dbg_estimate_size_before_relax): Call new
	size_fixed_inc_line_addr if DWARF2_USE_FIXED_ADVANCE_PC is set.
	(dwarf2dbg_convert_frag): Likewise for emit_fixed_inc_line_addr.
	(process_entries): Remove calls to out_fixed_inc_line_addr.  When
	DWARF2_USE_FIXED_ADVANCE_PC is set, call relax_inc_line_addr.
	* read.h (emit_expr_fix): New prototype.
	* read.c (emit_expr): Move code to emit_expr_fix and use it here.
	(emit_expr_fix): New.
testsuite/
	* gas/lns/lns.exp: Run new lns-big-delta test for targets that set
	DWARF2_USE_FIXED_ADVANCE_PC.
	* gas/lns/lns-big-delta.s: New.
	* gas/lns/lns-big-delta.d: New.
@
text
@d60 2
a61 2
          && string[0] != 0 \
          && string[1] == ':') \
d349 1
a349 1
/* A hook to allow the target backend to inform the line number state 
d368 1
a368 10
  if (dwarf2_loc_directive_seen)
    {
      /* Use the last location established by a .loc directive, not
	 the value returned by dwarf2_where().  That calls as_where()
	 which will return either the logical input file name (foo.c)
	or the physical input file name (foo.s) and not the file name
	specified in the most recent .loc directive (eg foo.h).  */
      loc = current;
    }
  else if (debug_type != DEBUG_DWARF2)
d370 2
a371 2
  else
    dwarf2_where (&loc);
d387 1
a387 2
  if (debug_type != DEBUG_DWARF2)
    dwarf2_loc_directive_seen = FALSE;
d408 4
a411 5
  
  if (debug_type == DEBUG_DWARF2)
    dwarf2_where (&loc);
  else
    loc = current;
d415 1
a416 1
  dwarf2_gen_line_info_1 (label, &loc);
d656 1
a656 1
          *input_line_pointer = c;
d669 1
a669 1
          *input_line_pointer = c;
d1424 1
a1424 1
  for (i = 0; i < addr_size; i++) 
d1426 1
a1426 1
  for (i = 0; i < addr_size; i++) 
d1455 1
a1455 1
  for (i = 0; i < addr_size; i++) 
d1457 1
a1457 1
  for (i = 0; i < addr_size; i++) 
d1663 1
a1663 1
  if (!files || files_in_use < 1)
d1752 1
a1752 1
      
d1771 1
a1771 1
	  bfd_set_section_flags (stdoutput, ranges_seg, 
@


1.94
log
@	* dwarf2dbg.h (dwarf2_loc_directive_seen): New.
	* dwarf2dbg.c (loc_directive_seen): Make external and rename to...
	(dwarf2_loc_directive_seen): ...this.
	(dwarf2_emit_insn, dwarf2_consume_line_info)
	(dwarf2_emit_label, dwarf2_directive_loc): Use new name.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
a200 1
static void out_sleb128 (addressT);
d205 2
a207 1
static void out_fixed_inc_line_addr (int, symbolS *, symbolS *);
a764 8
/* Emit a signed "little-endian base 128" number.  */

static void
out_sleb128 (addressT value)
{
  output_leb128 (frag_more (sizeof_leb128 (value, 1)), value, 1);
}

d1000 33
a1032 2
   line and address information, but it helps support linker relaxation that
   changes the code offsets.  */
d1035 2
a1036 1
out_fixed_inc_line_addr (int line_delta, symbolS *to_sym, symbolS *from_sym)
d1038 7
a1044 1
  expressionS expr;
d1047 15
a1061 1
  if (line_delta == INT_MAX)
d1063 10
a1072 2
      out_opcode (DW_LNS_fixed_advance_pc);
      expr.X_op = O_subtract;
a1073 1
      expr.X_op_symbol = from_sym;
d1075 11
a1085 1
      emit_expr (&expr, 2);
d1087 5
a1091 4
      out_opcode (DW_LNS_extended_op);
      out_byte (1);
      out_opcode (DW_LNE_end_sequence);
      return;
d1093 2
d1096 1
a1096 11
  out_opcode (DW_LNS_advance_line);
  out_sleb128 (line_delta);

  out_opcode (DW_LNS_fixed_advance_pc);
  expr.X_op = O_subtract;
  expr.X_add_symbol = to_sym;
  expr.X_op_symbol = from_sym;
  expr.X_add_number = 0;
  emit_expr (&expr, 2);

  out_opcode (DW_LNS_copy);
d1115 5
a1119 1
  max_chars = size_inc_line_addr (line_delta, -DWARF2_LINE_MIN_INSN_LENGTH);
d1136 4
a1139 1
  size = size_inc_line_addr (frag->fr_offset, addr_delta);
d1177 7
a1183 2
  emit_inc_line_addr (frag->fr_offset, addr_diff,
		      frag->fr_literal + frag->fr_fix, frag->fr_subtype);
d1261 1
a1261 3
      else if (DWARF2_USE_FIXED_ADVANCE_PC)
	out_fixed_inc_line_addr (line_delta, lab, last_lab);
      else if (frag == last_frag)
d1280 1
a1280 6
  if (DWARF2_USE_FIXED_ADVANCE_PC)
    {
      lab = symbol_temp_new (seg, frag_ofs, frag);
      out_fixed_inc_line_addr (INT_MAX, lab, last_lab);
    }
  else if (frag == last_frag)
@


1.93
log
@	* dwarf2dbg.c (dwarf2_emit_label): Use dwarf2_consume_line_info.
@
text
@d176 1
a176 1
static bfd_boolean loc_directive_seen;
d368 1
a368 1
  if (loc_directive_seen)
d397 1
a397 1
    loc_directive_seen = FALSE;
d579 1
a579 1
  if (loc_directive_seen && debug_type != DEBUG_DWARF2)
d688 1
a688 1
  loc_directive_seen = TRUE;
@


1.92
log
@	* dwarf2dbg.c (dwarf2_consume_line_info): New.
	(dwarf2_emit_insn): Use it here.
	(dwarf2_directive_loc): Fix check for consecutive .loc directives
	when debug_type is DEBUG_DWARF2.
	* dwarf2dbg.h (dwarf2_consume_line_info): New prototype.
	* config/tc-ia64.c (ia64_flush_insns): Call dwarf2_consume_line_info.
	(md_assemble): Likewise.
testsuite/
	* gas/lns/lns.exp: Run lns-common-1 with alternate source for ia64.
	* gas/lns/lns-common-1-ia64.s: New file.
@
text
@d422 1
a422 4
    {
      loc = current;
      loc_directive_seen = FALSE;
    }
d426 1
a426 4
  current.flags &= ~(DWARF2_FLAG_BASIC_BLOCK
		     | DWARF2_FLAG_PROLOGUE_END
		     | DWARF2_FLAG_EPILOGUE_BEGIN);

@


1.91
log
@	* dwarf2dbg.c (dwarf2_directive_loc): Emit duplicate .loc directives.

	* gas/lns/lns-duplicate.d, gas/lns/lns-duplicate.s: New.
	* gas/lns/lns.exp: Run lns-duplicate.
@
text
@a375 5

      /* Unless we generate DWARF2 debugging information for each
	 assembler line, we only emit one line symbol for one LOC.  */
      if (debug_type != DEBUG_DWARF2)
	loc_directive_seen = FALSE;
d383 15
d585 1
a585 1
  if (loc_directive_seen)
@


1.90
log
@2007-08-24  Joseph Myers  <joseph@@codesourcery.com>
            Paul Brook  <paul@@codesourcery.com>

	* remap.c: New.
	* as.h (remap_debug_filename, add_debug_prefix_map): Declare.
	* as.c (show_usage): Document --debug-prefix-map option.
	(parse_args): Handle --debug-prefix-map.
	* dwarf2dbg.c (out_file_list, out_debug_info): Remap debug paths.
	* stabs.c (stabs_generate_asm_file): Remap debug paths.
	* Makefile.am (GAS_CFILES): Add remap.c
	(GENERIC_OBJS): Add remap.o.
	Regenerate dependencies.
	* Makefile.in: Regenerate.
	* doc/as.texinfo (--debug-prefix-map): Document.
@
text
@d573 5
@


1.89
log
@Switch to GPLv3
@
text
@d1227 1
d1234 2
a1235 1
      size = strlen (dirs[i]) + 1;
d1237 1
a1237 1
      memcpy (cp, dirs[i], size);
d1519 2
a1520 1
  char *comp_dir;
d1610 2
a1611 1
      len = strlen (dirs[files[1].dir]);
d1613 1
a1613 1
      memcpy (p, dirs[files[1].dir], len);
d1621 1
a1621 1
  comp_dir = getpwd ();
@


1.89.2.1
log
@2007-08-24  Joseph Myers  <joseph@@codesourcery.com>
            Paul Brook  <paul@@codesourcery.com>

	* remap.c: New.
	* as.h (remap_debug_filename, add_debug_prefix_map): Declare.
	* as.c (show_usage): Document --debug-prefix-map option.
	(parse_args): Handle --debug-prefix-map.
	* dwarf2dbg.c (out_file_list, out_debug_info): Remap debug paths.
	* stabs.c (stabs_generate_asm_file): Remap debug paths.
	* Makefile.am (GAS_CFILES): Add remap.c
	(GENERIC_OBJS): Add remap.o.
	Regenerate dependencies.
	* Makefile.in: Regenerate.
	* doc/as.texinfo (--debug-prefix-map): Document.
@
text
@a1226 1
  const char *dir;
d1233 1
a1233 2
      dir = remap_debug_filename (dirs[i]);
      size = strlen (dir) + 1;
d1235 1
a1235 1
      memcpy (cp, dir, size);
d1517 1
a1517 2
  const char *comp_dir;
  const char *dirname;
d1607 1
a1607 2
      dirname = remap_debug_filename (dirs[files[1].dir]);
      len = strlen (dirname);
d1609 1
a1609 1
      memcpy (p, dirname, len);
d1617 1
a1617 1
  comp_dir = remap_debug_filename (getpwd ());
@


1.88
log
@* dwarf2dbg.c (out_debug_info): Use TC_DWARF2_EMIT_OFFSET to emit a disjoint DW_AT range.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
d10 1
a10 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.87
log
@gas/ChangeLog:
	* dwarf2dbg.c (DWARF2_USE_FIXED_ADVANCE_PC): New.
	(out_sleb128): New.
	(out_fixed_inc_line_addr): New.
	(process_entries): Use out_fixed_inc_line_addr when
	DWARF2_USE_FIXED_ADVANCE_PC is set.
	* config/tc-xtensa.h (DWARF2_USE_FIXED_ADVANCE_PC): Define.
gas/testsuite/ChangeLog:
	* gas/lns/lns-common-1-alt.d: New file.
	* gas/lns/lns.exp: Use lns-common-1-alt.d for xtensa targets.
@
text
@d1594 3
a1596 7
      /* This attributes is emitted if the code is disjoint.  */
      
      /* DW_AT_ranges */
      expr.X_op = O_symbol;
      expr.X_add_symbol = section_symbol (ranges_seg);
      expr.X_add_number = 0;
      emit_expr (&expr, sizeof_address);
@


1.86
log
@* dwarf2dbg.c (out_debug_info): Add new parameter ranges_seg and emit
  DW_AT_ranges when code in compilation unit is not contiguous.
  (out_debug_abbrev): Emit DW_AT_ranges abbreviation if code in is not contiguous.
  (dwarf2_finish): Create and pass ranges_seg to out_debug_info.
  (out_debug_ranges): New function to emit .debug_ranges section when code is not contiguous.
@
text
@d91 7
d201 1
d207 1
d756 8
d997 39
d1186 2
d1207 6
a1212 1
  if (frag == last_frag)
@


1.85
log
@remove some duplicate #include's.
@
text
@a204 1
static void out_debug_info (segT, segT, segT);
d207 1
a207 2
# define TC_DWARF2_EMIT_OFFSET  generic_dwarf2_emit_offset
static void generic_dwarf2_emit_offset (symbolS *, unsigned int);
d1291 48
d1431 7
d1451 1
a1451 1
out_debug_info (segT info_seg, segT abbrev_seg, segT line_seg)
d1514 1
a1514 2
  /* These two attributes may only be emitted if all of the code is
     contiguous.  Multiple sections are not that.  */
d1529 10
d1629 1
d1646 11
d1659 1
a1659 1
      out_debug_info (info_seg, abbrev_seg, line_seg);
@


1.84
log
@PR gas/2582
* dwarf2dbg.c (INSERT_DIR_SEPARATOR): New macro.  Handles the insertion of a
  directory separator character into a string at a given offset.  Uses
  heuristics to decide when to use a backslash character rather than a
  forward-slash character.
  (dwarf2_directive_loc): Use the macro.
  (out_debug_info): Likewise.
@
text
@a30 1
#include "ansidecl.h"
@


1.83
log
@	* subsegs.h (struct frchain): Delete frch_seg.
	(frchain_root): Delete.
	(seg_info): Define as macro.
	* subsegs.c (frchain_root): Delete.
	(abs_seg_info, und_seg_info, absolute_frchain): Delete.
	(subsegs_begin, subseg_change): Adjust for above.
	(subseg_set_rest): Likewise.  Add new frchain structs to seginfo
	rather than to one big list.
	(subseg_get): Don't special case abs, und sections.
	(subseg_new, subseg_force_new): Don't set frchainP here.
	(seg_info): Delete.
	(subsegs_print_statistics): Adjust frag chain control list traversal.
	* debug.c (dmp_frags):  Likewise.
	* dwarf2dbg.c (first_frag_for_seg): Don't start looking for frag
	at frchain_root.  Make use of known frchain ordering.
	(last_frag_for_seg): Likewise.
	(get_frag_fix): Likewise.  Add seg param.
	(process_entries, out_debug_aranges): Adjust get_frag_fix calls.
	* write.c (chain_frchains_together_1): Adjust for struct frchain.
	(SUB_SEGMENT_ALIGN): Likewise.
	(subsegs_finish): Adjust frchain list traversal.
	* config/tc-xtensa.c (xtensa_cleanup_align_frags): Likewise.
	(xtensa_fix_target_frags, xtensa_mark_narrow_branches): Likewise.
	(xtensa_mark_zcl_first_insns, xtensa_fix_a0_b_retw_frags): Likewise.
	(xtensa_fix_b_j_loop_end_frags): Likewise.
	(xtensa_fix_close_loop_end_frags): Likewise.
	(xtensa_fix_short_loop_frags, xtensa_sanity_check): Likewise.
	(retrieve_segment_info): Delete frch_seg initialisation.
@
text
@d49 23
d595 1
a595 1
	  cp[dir_len] = '/';
d1490 1
a1490 1
      p[len] = '/';
@


1.82
log
@	* dwarf2dbg.c (get_line_subseg): Attach new struct line_seg to end
	of list rather than beginning.
@
text
@d172 1
a172 1
static offsetT get_frag_fix (fragS *);
d673 1
a673 8
  frchainS *f, *first = NULL;

  for (f = frchain_root; f; f = f->frch_next)
    if (f->frch_seg == seg
	&& (! first || first->frch_subseg > f->frch_subseg))
      first = f;

  return first ? first->frch_root : NULL;
d679 1
a679 1
  frchainS *f, *last = NULL;
d681 2
a682 4
  for (f = frchain_root; f; f = f->frch_next)
    if (f->frch_seg == seg
	&& (! last || last->frch_subseg < f->frch_subseg))
      last= f;
d684 1
a684 1
  return last ? last->frch_last : NULL;
d739 1
a739 1
get_frag_fix (fragS *frag)
d749 1
a749 1
  for (fr = frchain_root; fr; fr = fr->frch_next)
d1128 1
a1128 1
  frag_ofs = get_frag_fix (frag);
d1326 1
a1326 1
      end = symbol_temp_new (s->seg, get_frag_fix (frag), frag);
@


1.81
log
@	* dwarf2dbg.c (get_filenum): Don't inadvertently decrease files_in_use.
@
text
@d212 1
a212 1
  struct line_seg *s;
d218 1
a218 1
  for (s = all_segs; s; s = s->next)
d223 1
a223 1
  s->next = all_segs;
d226 1
a226 1
  all_segs = s;
@


1.81.2.1
log
@Merge changes between binutils-csl-2_17-branchpoint and
binutils-2_17, except for the addition of generated files to CVS.
@
text
@d212 1
a212 1
  struct line_seg **ps, *s;
d218 1
a218 1
  for (ps = &all_segs; (s = *ps) != NULL; ps = &s->next)
d223 1
a223 1
  s->next = NULL;
d226 1
a226 1
  *ps = s;
@


1.81.4.1
log
@	* dwarf2dbg.c (get_line_subseg): Attach new struct line_seg to end
	of list rather than beginning.
@
text
@d212 1
a212 1
  struct line_seg **ps, *s;
d218 1
a218 1
  for (ps = &all_segs; (s = *ps) != NULL; ps = &s->next)
d223 1
a223 1
  s->next = NULL;
d226 1
a226 1
  *ps = s;
@


1.80
log
@        * dwarf2dbg.c (process_entries): Fix uninitialized variable warning.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004, 2005
d487 2
a488 1
  files_in_use = i + 1;
@


1.79
log
@        * dwarf2dbg.c (struct line_entry): Replace frag and frag_ofs
        with label.
        (dwarf2_loc_mark_labels): New.
        (dwarf2_gen_line_info_1): Split out of ...
        (dwarf2_gen_line_info): ... here.  Create the temp symbol here.
        (dwarf2_emit_label): New.
        (dwarf2_directive_loc_mark_labels): New.
        (out_set_addr): Take a symbol instead of frag+ofs.
        (relax_inc_line_addr): Likewise.
        (emit_inc_line_addr): Assert delta non-negative.
        (process_entries): Remove dead code.  Update to work with temp
        symbols instead of frag+ofs.
        * dwarf2dbg.h (dwarf2_directive_loc_mark_labels): Declare.
        (dwarf2_emit_label, dwarf2_loc_mark_labels): Declare.
        * config/obj-elf.c (elf_pseudo_tab): Add loc_mark_labels.
        * config/obj-elf.h (obj_frob_label): New.
        * config/tc-alpha.c (alpha_define_label): Call dwarf2_emit_label.
        * config/tc-arm.c, config/tc-hppa.c, config/tc-m68k.c,
        config/tc-mips.c, config/tc-ppc.c, config/tc-sh.c, config/tc-xtensa.c:
        Similarly in the respective tc_frob_label implementation functions.
        * config/tc-i386.c (md_pseudo_table): Move file and loc to
        non-elf section; add loc_mark_labels.
        * config/tc-ia64.c (struct label_fix): Add dw2_mark_labels.
        (ia64_flush_insns): Check for marked labels; emit line entry if so.
        (emit_one_bundle): Similarly.
        (ia64_frob_label): Record marked labels.
        * config/tc-m68hc11.h (tc_frob_label): Remove.
        * config/tc-ms1.c (md_pseudo_table): Remove file and loc.
        * config/tc-sh.h (tc_frob_label): Pass sym to sh_frob_label.
        * config/tc-sh64.h (tc_frob_label): Likewise.
        * doc/as.texinfo (LNS directives): Docuement .loc_mark_blocks.
@
text
@d1061 1
a1061 1
  symbolS *last_lab, *lab;
d1064 1
a1064 1
  while (e)
d1132 1
@


1.78
log
@        * dwarf2dbg.c (dwarf2_where): Set line->isa.
        (dwarf2_set_isa): New.
        (dwarf2_directive_loc): Rearrange to allow all options on one line.
        * dwarf2dbg.h (dwarf2_set_isa): Declare.
        * doc/as.texinfo: Update .loc documentation.

        * gas/lns/lns-common-1.d: Don't match header or special opcode numbers.
        * gas/lns/lns-common-1.s: Update for syntax change.
        * gas/lns/lns-diag-1.[sl]: Likewise.
@
text
@d108 1
a108 2
  fragS *frag;
  addressT frag_ofs;
d149 4
d173 1
a173 1
static void out_set_addr (segT, fragS *, addressT);
d177 1
a177 2
static void relax_inc_line_addr (int, segT, fragS *, addressT,
				 fragS *, addressT);
d252 18
a274 2
  struct line_subseg *ss;
  struct line_entry *e;
d278 2
d295 2
a296 9
  e = (struct line_entry *) xmalloc (sizeof (*e));
  e->next = NULL;
  e->frag = frag_now;
  e->frag_ofs = ofs;
  e->loc = *loc;

  ss = get_line_subseg (now_seg, now_subseg);
  *ss->ptail = e;
  ss->ptail = &e->next;
d365 32
d651 17
d767 1
a767 1
out_set_addr (segT seg, fragS *frag, addressT ofs)
a769 3
  symbolS *sym;

  sym = symbol_temp_new (seg, ofs, frag);
d873 4
d972 1
a972 3
relax_inc_line_addr (int line_delta, segT seg,
		     fragS *to_frag, addressT to_ofs,
		     fragS *from_frag, addressT from_ofs)
a973 1
  symbolS *to_sym, *from_sym;
a976 3
  to_sym = symbol_temp_new (seg, to_ofs, to_frag);
  from_sym = symbol_temp_new (seg, from_ofs, from_frag);

d1059 3
a1061 4
  fragS *frag = NULL;
  fragS *last_frag;
  addressT frag_ofs = 0;
  addressT last_frag_ofs;
d1066 1
a1066 1
      int changed = 0;
a1072 1
	  changed = 1;
a1079 1
	  changed = 1;
a1086 1
	  changed = 1;
a1092 1
	  changed = 1;
d1096 1
a1096 4
	{
	  out_opcode (DW_LNS_set_basic_block);
	  changed = 1;
	}
d1099 1
a1099 4
	{
	  out_opcode (DW_LNS_set_prologue_end);
	  changed = 1;
	}
d1102 1
a1102 4
	{
	  out_opcode (DW_LNS_set_epilogue_begin);
	  changed = 1;
	}
d1108 4
a1111 13
      if (1 /* line != e->loc.line || changed */)
	{
	  int line_delta = e->loc.line - line;
	  if (frag == NULL)
	    {
	      out_set_addr (seg, e->frag, e->frag_ofs);
	      out_inc_line_addr (line_delta, 0);
	    }
	  else if (frag == e->frag)
	    out_inc_line_addr (line_delta, e->frag_ofs - frag_ofs);
	  else
	    relax_inc_line_addr (line_delta, seg, e->frag, e->frag_ofs,
				 frag, frag_ofs);
d1113 1
a1113 5
	  frag = e->frag;
	  frag_ofs = e->frag_ofs;
	  line = e->loc.line;
	}
      else if (frag == NULL)
d1115 2
a1116 3
	  out_set_addr (seg, e->frag, e->frag_ofs);
	  frag = e->frag;
	  frag_ofs = e->frag_ofs;
d1118 9
d1134 2
a1135 2
  last_frag = last_frag_for_seg (seg);
  last_frag_ofs = get_frag_fix (last_frag);
d1137 1
a1137 1
    out_inc_line_addr (INT_MAX, last_frag_ofs - frag_ofs);
d1139 4
a1142 2
    relax_inc_line_addr (INT_MAX, seg, last_frag, last_frag_ofs,
			 frag, frag_ofs);
@


1.77
log
@        * dwarf2dbg.c: Include safe-ctype.h.
        (DWARF2_LINE_OPCODE_BASE): Bump to 13.
        (current): Initialize.
        (dwarf2_emit_insn): Clear DWARF2_FLAG_BASIC_BLOCK,
        DWARF2_FLAG_PROLOGUE_END, DWARF2_FLAG_EPILOGUE_BEGIN.
        (dwarf2_directive_file): Cope with invalid filename.
        (dwarf2_directive_loc): Add handling for basic_block, prologue_end,
        epilogue_begin, is_stmt, isa.
        (emit_inc_line_addr): Move line_delta == 0, addr_delta == 0 special
        case down lower.
        (process_entries): Handle isa, DWARF2_FLAG_PROLOGUE_END,
        and DWARF2_FLAG_EPILOGUE_BEGIN.
        (out_debug_line): Emit sizes for DW_LNS_set_prologue_end,
        DW_LNS_set_epilogue_begin, DW_LNS_set_isa.
        * dwarf2dbg.h (DWARF2_FLAG_IS_STMT): Rename from DWARF2_FLAG_BEGIN_STMT.        (DWARF2_FLAG_BASIC_BLOCK): Rename from DWARF2_FLAG_BEGIN_BLOCK.
        (DWARF2_FLAG_PROLOGUE_END, DWARF2_FLAG_EPILOGUE_BEGIN): New.
        (struct dwarf2_line_info): Add isa member.
        * doc/as.texinfo (LNS directives): New node.
@
text
@d27 2
a28 6
	.loc  FILENO LINENO [COLUMN]
	.loc  basic_block
	.loc  prologue_end
	.loc  epilogue_begin
	.loc  is_stmt [VALUE]
	.loc  isa [VALUE]
d286 5
d301 1
d307 9
d496 41
d538 7
a544 1
  if (ISALPHA (*input_line_pointer))
d576 4
a579 1
	    as_bad (_("is_stmt value not 0 or 1"));
d585 2
a586 2
	  if (value < 0)
	    as_bad (_("isa number less than zero"));
d588 4
a591 1
	    current.isa = value;
d595 1
a595 1
	  as_bad (_("unknown .loc sub-directive %s"), p);
d597 1
a598 4
    }
  else
    {
      offsetT filenum, line, column;
a599 3
      filenum = get_absolute_expression ();
      SKIP_WHITESPACE ();
      line = get_absolute_expression ();
a600 37
      column = get_absolute_expression ();

      if (filenum < 1)
	{
	  as_bad (_("file number less than one"));
	  return;
	}
      if (filenum >= (int) files_in_use || files[filenum].filename == 0)
	{
	  as_bad (_("unassigned file number %ld"), (long) filenum);
	  return;
	}

      current.filenum = filenum;
      current.line = line;
      current.column = column;

#ifndef NO_LISTING
      if (listing)
	{
	  if (files[filenum].dir)
	    {
	      size_t dir_len = strlen (dirs[files[filenum].dir]);
	      size_t file_len = strlen (files[filenum].filename);
	      char *cp = (char *) alloca (dir_len + 1 + file_len + 1);

	      memcpy (cp, dirs[files[filenum].dir], dir_len);
	      cp[dir_len] = '/';
	      memcpy (cp + dir_len + 1, files[filenum].filename, file_len);
	      cp[dir_len + file_len + 1] = '\0';
	      listing_source_file (cp);
	    }
	  else
	    listing_source_file (files[filenum].filename);
	  listing_source_line (line);
	}
#endif
@


1.76
log
@	* README-vms: Delete.
	* config-gas.com: Delete.
	* makefile.vms: Delete.
	* vmsconf.sh: Delete.
	* config/atof-tahoe.c: Delete.
	* config/m88k-opcode.h: Delete.
	* config/obj-bout.c: Delete.
	* config/obj-bout.h: Delete.
	* config/obj-hp300.c: Delete.
	* config/obj-hp300.h: Delete.
	* config/tc-a29k.c: Delete.
	* config/tc-a29k.h: Delete.
	* config/tc-h8500.c: Delete.
	* config/tc-h8500.h: Delete.
	* config/tc-m88k.c: Delete.
	* config/tc-m88k.h: Delete.
	* config/tc-tahoe.c: Delete.
	* config/tc-tahoe.h: Delete.
	* config/tc-tic80.c: Delete.
	* config/tc-tic80.h: Delete.
	* config/tc-w65.c: Delete.
	* config/tc-w65.h: Delete.
	* config/te-aux.h: Delete.
	* config/te-delt88.h: Delete.
	* config/te-delta.h: Delete.
	* config/te-dpx2.h: Delete.
	* config/te-hp300.h: Delete.
	* config/te-ic960.h: Delete.
	* config/vms-a-conf.h: Delete.
	* doc/c-a29k.texi: Delete.
	* doc/c-h8500.texi: Delete.
	* doc/c-m88k.texi: Delete.
	* README: Remove obsolete examples, and list of supported targets.
	* Makefile.am: Remove a29k, h8500, m88k, tahoe, tic80, w65,
	bout and hp300 support.
	(DEP_FLAGS): Don't define BFD_ASSEMBLER.
	* configure.in: Remove --enable-bfd-assembler, need_bfd,
	primary_bfd_gas.
	* configure.tgt: Remove a29k, h8300-coff, h8500-*, i960 non-elf,
	m68k non bfd, m88k, or32-coff, tic80-*, vax non-bfd, w65k-*, *-nindy.
	* as.c: Remove all non-BFD_ASSEMBLER code, support for above targets.
	* as.h: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
	* input-file.c: Likewise.
	* listing.c: Likewise.
	* literal.c: Likewise.
	* messages.c: Likewise.
	* obj.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* stabs.c: Likewise.
	* struc-symbol.h: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* symbols.c: Likewise.
	* symbols.h: Likewise.
	* tc.h: Likewise.
	* write.c: Likewise.
	* write.h: Likewise.
	* config/aout_gnu.h: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-aout.h: Likewise.
	* config/obj-coff.c: Likewise.
	* config/obj-coff.h: Likewise.
	* config/obj-evax.h: Likewise.
	* config/obj-ieee.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-crx.h: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-d30v.h: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-fr30.h: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-hppa.h: Likewise.
	* config/tc-i370.h: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i860.h: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ip2k.h: Likewise.
	* config/tc-iq2000.h: Likewise.
	* config/tc-m32c.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m68k.h: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-maxq.h: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mn10200.h: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-mn10300.h: Likewise.
	* config/tc-ms1.h: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-msp430.h: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-ns32k.h: Likewise.
	* config/tc-openrisc.h: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.h: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic4x.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-vax.h: Likewise.
	* config/tc-xstormy16.h: Likewise.
	* config/tc-xtensa.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-z8k.h: Likewise.
	* config/vms-a-conf.h
	* doc/Makefile.am: Likewise.
	* doc/all.texi: Likewise.
	* doc/as.texinfo: Likewise.
	* doc/Makefile.in: Regenerate.
	* Makefile.in: Regenerate.
	* configure: Regenerate.
	* config.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d24 1
a24 1
   following two directives:
d28 6
a33 2

   FILENO is the filenumber.  */
d37 1
d76 2
a77 2
   dwarf2_finish().  */
#define DWARF2_LINE_OPCODE_BASE		10
d96 1
a96 4
/* Flag that indicates the initial value of the is_stmt_start flag.
   In the present implementation, we do not mark any lines as
   the beginning of a source statement, because that information
   is not made available by the GCC front-end.  */
d155 4
a158 1
static struct dwarf2_line_info current;
d299 1
a299 1
      line->flags = DWARF2_FLAG_BEGIN_STMT;
d332 1
a332 1
    dwarf2_where (& loc);
d335 4
d461 2
d485 5
a489 1
  offsetT filenum, line, column;
d491 2
a492 6
  filenum = get_absolute_expression ();
  SKIP_WHITESPACE ();
  line = get_absolute_expression ();
  SKIP_WHITESPACE ();
  column = get_absolute_expression ();
  demand_empty_rest_of_line ();
d494 40
a533 4
  if (filenum < 1)
    {
      as_bad (_("file number less than one"));
      return;
d535 1
a535 1
  if (filenum >= (int) files_in_use || files[filenum].filename == 0)
d537 7
a543 3
      as_bad (_("unassigned file number %ld"), (long) filenum);
      return;
    }
d545 10
a554 4
  current.filenum = filenum;
  current.line = line;
  current.column = column;
  current.flags = DWARF2_FLAG_BEGIN_STMT;
d556 3
a558 1
  loc_directive_seen = TRUE;
d561 1
a561 3
  if (listing)
    {
      if (files[filenum].dir)
d563 15
a577 9
	  size_t dir_len = strlen (dirs[files[filenum].dir]);
	  size_t file_len = strlen (files[filenum].filename);
	  char *cp = (char *) alloca (dir_len + 1 + file_len + 1);

	  memcpy (cp, dirs[files[filenum].dir], dir_len);
	  cp[dir_len] = '/';
	  memcpy (cp + dir_len + 1, files[filenum].filename, file_len);
	  cp[dir_len + file_len + 1] = '\0';
	  listing_source_file (cp);
d579 1
a579 3
      else
	listing_source_file (files[filenum].filename);
      listing_source_line (line);
d581 3
a583 1
#endif
a824 8
      /* Prettier, I think, to use DW_LNS_copy instead of a
	 "line +0, addr +0" special opcode.  */
      if (addr_delta == 0)
	{
	  *p++ = DW_LNS_copy;
	  goto done;
	}

d830 8
d979 2
a980 1
  unsigned flags = DWARF2_LINE_DEFAULT_IS_STMT ? DWARF2_FLAG_BEGIN_STMT : 0;
d1007 9
a1015 1
      if ((e->loc.flags ^ flags) & DWARF2_FLAG_BEGIN_STMT)
d1022 1
a1022 1
      if (e->loc.flags & DWARF2_FLAG_BEGIN_BLOCK)
d1028 12
d1202 3
@


1.75
log
@Update the address and phone number of the FSF
@
text
@a55 2
#ifdef BFD_ASSEMBLER

a1424 51

#else
void
dwarf2_finish ()
{
}

int
dwarf2dbg_estimate_size_before_relax (frag)
     fragS *frag ATTRIBUTE_UNUSED;
{
  as_fatal (_("dwarf2 is not supported for this object file format"));
  return 0;
}

int
dwarf2dbg_relax_frag (frag)
     fragS *frag ATTRIBUTE_UNUSED;
{
  as_fatal (_("dwarf2 is not supported for this object file format"));
  return 0;
}

void
dwarf2dbg_convert_frag (frag)
     fragS *frag ATTRIBUTE_UNUSED;
{
  as_fatal (_("dwarf2 is not supported for this object file format"));
}

void
dwarf2_emit_insn (size)
     int size ATTRIBUTE_UNUSED;
{
}

char *
dwarf2_directive_file (dummy)
     int dummy ATTRIBUTE_UNUSED;
{
  s_app_file (0);
  return NULL;
}

void
dwarf2_directive_loc (dummy)
     int dummy ATTRIBUTE_UNUSED;
{
  as_fatal (_("dwarf2 is not supported for this object file format"));
}
#endif /* BFD_ASSEMBLER */
@


1.74
log
@update copyright dates
@
text
@d20 2
a21 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.73
log
@	* dwarf2dbg.c (dwarf2_finish): Correct logic for determining when
	to emit .debug_line and other debug sections.
	* as.h (seg_not_empty_p): Declare.
	* subsegs.c (seg_not_empty_p): New predicate.
@
text
@d2 2
a3 1
   Copyright 1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
@


1.72
log
@        * dwarf2dbg.c (dwarf2_finish): Don't write a .debug_line section
        without a corresponding .debug_info section.
@
text
@d1352 8
d1365 5
d1371 3
a1373 9
  /* We don't need to do anything unless:
     - Some debug information was recorded via .file/.loc or
       generated by GAS (--gdwarf2)
     - or, there is a user-provided .debug_info section which could
       reference the file table in the .debug_line section we generate
       below.  */
  if (all_segs == NULL
      && (bfd_get_section_by_name (stdoutput, ".debug_info") == NULL
	  || files_in_use == 0))
d1398 4
a1401 3
  /* If this is assembler generated line info, we need .debug_info
     and .debug_abbrev sections as well.  */
  if (all_segs != NULL && debug_type == DEBUG_DWARF2)
a1403 1
      segT info_seg;
d1406 2
@


1.71
log
@(dwarf2_finish): Check for the existence of a file table before deciding to
 produce a .debug_line section to match up with a user provided .debug_info
 section.
@
text
@d1359 2
a1360 2
     - Some debug information was recorded via .file/.loc
     - or, we are generating DWARF2 information ourself (--gdwarf2)
a1364 1
      && debug_type != DEBUG_DWARF2
@


1.70
log
@Add support for generating DWARF2 debug sections in the x86 PE port
@
text
@d1366 2
a1367 1
      && bfd_get_section_by_name (stdoutput, ".debug_info") == NULL)
@


1.69
log
@2004-02-13  Hannes Reinecke  <hare@@suse.de>
            Jakub Jelinek  <jakub@@redhat.com>

	* dwarf2dbg.c (get_filenum): Do not read beyond allocated memory.
@
text
@d1374 1
a1374 1
  bfd_set_section_flags (stdoutput, line_seg, SEC_READONLY);
d1403 6
a1408 3
      bfd_set_section_flags (stdoutput, info_seg, SEC_READONLY);
      bfd_set_section_flags (stdoutput, abbrev_seg, SEC_READONLY);
      bfd_set_section_flags (stdoutput, aranges_seg, SEC_READONLY);
@


1.68
log
@.:
	* dwarf2dbg.c (DWARF2_ADDR_SIZE): Remove trailing ';'
	* read.h (SKIP_WHITESPACE): Turn into an expression.
	* read.c (read_a_source_file): A pseudo is removed by having a
	NULL handler.
testsuite:
	* gas/macros/test2.s: Lowercase it.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d375 1
a375 1
	if (memcmp (filename, dirs[dir], dir_len) == 0
@


1.67
log
@	* dwarf2dbg.c: Convert to ISO-C.
	* write.c: Likewise.
	* write.h: Likewise.
@
text
@d52 1
a52 1
# define DWARF2_ADDR_SIZE(bfd) (bfd_arch_bits_per_address (bfd) / 8);
@


1.66
log
@	* README-vms: Fix comment typos.
	* as.h: Likewise.
	* dwarf2dbg.c: Likewise.
	* ecoff.c: Likewise.
	* hash.c: Likewise.
	* listing.c: Likewise.
	* write.c: Likewise.
@
text
@d643 1
a643 2
scale_addr_delta (addr_delta)
     addressT *addr_delta;
@


1.65
log
@	* depend.c: Convert to ISO-C.
	* dwarf2dbg.c: Likewise.
	* dwarf2dbg.h: Likewise.
@
text
@d250 1
a250 1
/* Record an entry for LOC ocurring at OFS within the current fragment.  */
@


1.64
log
@	* dwarf2dbg.c (get_frag_fix): Revert 2001-11-15 change.
	(generic_dwarf2_emit_offset): Don't define function when
	TC__DWARF2_EMIT_OFFSET is defined.
@
text
@d159 23
a181 23
static struct line_subseg *get_line_subseg PARAMS ((segT, subsegT));
static unsigned int get_filenum PARAMS ((const char *, unsigned int));
static struct frag *first_frag_for_seg PARAMS ((segT));
static struct frag *last_frag_for_seg PARAMS ((segT));
static void out_byte PARAMS ((int));
static void out_opcode PARAMS ((int));
static void out_two PARAMS ((int));
static void out_four PARAMS ((int));
static void out_abbrev PARAMS ((int, int));
static void out_uleb128 PARAMS ((addressT));
static offsetT get_frag_fix PARAMS ((fragS *));
static void out_set_addr PARAMS ((segT, fragS *, addressT));
static int size_inc_line_addr PARAMS ((int, addressT));
static void emit_inc_line_addr PARAMS ((int, addressT, char *, int));
static void out_inc_line_addr PARAMS ((int, addressT));
static void relax_inc_line_addr PARAMS ((int, segT, fragS *, addressT,
					 fragS *, addressT));
static void process_entries PARAMS ((segT, struct line_entry *));
static void out_file_list PARAMS ((void));
static void out_debug_line PARAMS ((segT));
static void out_debug_aranges PARAMS ((segT, segT));
static void out_debug_abbrev PARAMS ((segT));
static void out_debug_info PARAMS ((segT, segT, segT));
d185 1
a185 1
static void generic_dwarf2_emit_offset PARAMS ((symbolS *, unsigned int));
d190 1
a190 3
generic_dwarf2_emit_offset (symbol, size)
     symbolS *symbol;
     unsigned int size;
d204 1
a204 3
get_line_subseg (seg, subseg)
     segT seg;
     subsegT subseg;
d253 1
a253 3
dwarf2_gen_line_info (ofs, loc)
     addressT ofs;
     struct dwarf2_line_info *loc;
d287 1
a287 2
dwarf2_where (line)
     struct dwarf2_line_info *line;
d307 1
a307 2
dwarf2_emit_insn (size)
     int size;
d338 1
a338 3
get_filenum (filename, num)
     const char *filename;
     unsigned int num;
d437 1
a437 2
dwarf2_directive_file (dummy)
     int dummy ATTRIBUTE_UNUSED;
d473 1
a473 2
dwarf2_directive_loc (dummy)
     int dummy ATTRIBUTE_UNUSED;
d525 1
a525 2
first_frag_for_seg (seg)
     segT seg;
d538 1
a538 2
last_frag_for_seg (seg)
     segT seg;
d553 1
a553 2
out_byte (byte)
     int byte;
d561 1
a561 2
out_opcode (opc)
     int opc;
d569 1
a569 2
out_two (data)
     int data;
d577 1
a577 2
out_four (data)
     int data;
d585 1
a585 2
out_uleb128 (value)
     addressT value;
d593 1
a593 2
out_abbrev (name, form)
     int name, form;
d602 1
a602 2
get_frag_fix (frag)
     fragS *frag;
d622 1
a622 4
out_set_addr (seg, frag, ofs)
     segT seg;
     fragS *frag;
     addressT ofs;
d640 1
a640 1
static void scale_addr_delta PARAMS ((addressT *));
d667 1
a667 3
size_inc_line_addr (line_delta, addr_delta)
     int line_delta;
     addressT addr_delta;
d726 1
a726 5
emit_inc_line_addr (line_delta, addr_delta, p, len)
     int line_delta;
     addressT addr_delta;
     char *p;
     int len;
d817 1
a817 3
out_inc_line_addr (line_delta, addr_delta)
     int line_delta;
     addressT addr_delta;
d827 3
a829 5
relax_inc_line_addr (line_delta, seg, to_frag, to_ofs, from_frag, from_ofs)
     int line_delta;
     segT seg;
     fragS *to_frag, *from_frag;
     addressT to_ofs, from_ofs;
d856 1
a856 2
dwarf2dbg_estimate_size_before_relax (frag)
     fragS *frag;
d874 1
a874 2
dwarf2dbg_relax_frag (frag)
     fragS *frag;
d889 1
a889 2
dwarf2dbg_convert_frag (frag)
     fragS *frag;
d913 1
a913 3
process_entries (seg, e)
     segT seg;
     struct line_entry *e;
d1005 1
a1005 1
out_file_list ()
d1047 1
a1047 2
out_debug_line (line_seg)
     segT line_seg;
d1135 1
a1135 3
out_debug_aranges (aranges_seg, info_seg)
     segT aranges_seg;
     segT info_seg;
d1211 1
a1211 2
out_debug_abbrev (abbrev_seg)
     segT abbrev_seg;
d1237 1
a1237 4
out_debug_info (info_seg, abbrev_seg, line_seg)
     segT info_seg;
     segT abbrev_seg;
     segT line_seg;
d1354 1
a1354 1
dwarf2_finish ()
@


1.63
log
@        * symbols.c (temp_label_name): New.
        (symbol_temp_new, symbol_temp_new_now, symbol_temp_make): New.
        (symbol_set_value_now): New.
        * symbols.h: Prototype them.
        * dwarf2dbg.c: Use them.
        (fake_label_name, symbol_new_now, set_symbol_value_now): Remove.
@
text
@a54 4
#ifndef TC_DWARF2_EMIT_OFFSET
# define TC_DWARF2_EMIT_OFFSET  generic_dwarf2_emit_offset
#endif

a158 1
static void generic_dwarf2_emit_offset PARAMS((symbolS *, unsigned int));
d183 4
d201 1
d635 1
a635 5
      {
	long align_mask = -1 << get_recorded_alignment (fr->frch_seg);
	return (((char *) obstack_next_free (&fr->frch_obstack)
		 - frag->fr_literal) + ~align_mask) & align_mask;
      }
@


1.62
log
@        * dwarf2dbg.c (get_filenum): Skip as-yet unassigned file numbers.
        (out_file_list): Assign non-null filename after generating error.
@
text
@a159 3
/* Fake label name.  */
static char const fake_label_name[] = ".L0\001";

a173 2
static symbolS *symbol_new_now PARAMS ((void));
static void set_symbol_value_now PARAMS ((symbolS *));
a618 19
/* Create a new fake symbol whose value is the current position.  */

static symbolS *
symbol_new_now ()
{
  return symbol_new (fake_label_name, now_seg, frag_now_fix (), frag_now);
}

/* Set the value of SYM to the current position in the current segment.  */

static void
set_symbol_value_now (sym)
     symbolS *sym;
{
  S_SET_SEGMENT (sym, now_seg);
  S_SET_VALUE (sym, frag_now_fix ());
  symbol_set_frag (sym, frag_now);
}

d655 1
a655 1
  sym = symbol_new (fake_label_name, seg, ofs, frag);
d873 2
a874 2
  to_sym = symbol_new (fake_label_name, seg, to_ofs, to_frag);
  from_sym = symbol_new (fake_label_name, seg, from_ofs, from_frag);
d1103 3
a1105 3
  line_start = symbol_new_now ();
  prologue_end = symbol_make (fake_label_name);
  line_end = symbol_make (fake_label_name);
d1167 1
a1167 1
  set_symbol_value_now (prologue_end);
d1173 1
a1173 1
  set_symbol_value_now (line_end);
d1229 1
a1229 1
      beg = symbol_new (fake_label_name, s->seg, 0, frag);
d1233 1
a1233 1
      end = symbol_new (fake_label_name, s->seg, get_frag_fix (frag), frag);
d1301 2
a1302 2
  info_start = symbol_new_now ();
  info_end = symbol_make (fake_label_name);
d1400 1
a1400 1
  set_symbol_value_now (info_end);
@


1.61
log
@        * dwarf2dbg.c (generic_dwarf2_emit_offset): New.
        (TC_DWARF2_EMIT_OFFSET): Provide default.
        (out_debug_aranges, out_debug_info): Use it.
        * config/tc-ia64.c (ia64_dwarf2_emit_offset): New.
        (ia64_cons_fix_new): Move FUNC_DTP_RELATIVE handling ...
        (ia64_gen_real_reloc_type): ... here.
        * config/tc-ia64.h (TC_DWARF2_EMIT_OFFSET): New.
@
text
@d414 1
d1093 2
@


1.60
log
@Add code to create and use directory tables.
@
text
@d55 3
d166 1
d193 15
d1231 2
a1232 4
  expr.X_op = O_symbol;
  expr.X_add_symbol = section_symbol (info_seg);
  expr.X_add_number = 0;
  emit_expr (&expr, 4);
d1359 1
a1359 4
  expr.X_op = O_symbol;
  expr.X_add_symbol = section_symbol (abbrev_seg);
  expr.X_add_number = 0;
  emit_expr (&expr, sizeof_offset);
d1368 2
a1369 4
  expr.X_op = O_symbol;
  expr.X_add_symbol = section_symbol (line_seg);
  expr.X_add_number = 0;
  emit_expr (&expr, 4);
@


1.59
log
@* dwarf2dbg.c (DWARF2_ADDR_SIZE): New macro.
(dwarf2_finish): Use it.
* doc/internals.texi (DWARF2_ADDR_SIZE): Document it.
* config/tc-mips.h (DWARF2_ADDR_SIZE): Override.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d45 1
d136 1
a136 1
  char *filename;
d145 5
d164 1
a164 1
static unsigned int get_filenum PARAMS ((const char *));
d286 1
a286 1
      line->filenum = get_filenum (filename);
d327 3
a329 1
/* Get a .debug_line file number for FILENAME.  */
d332 1
a332 1
get_filenum (filename)
d334 1
d336 47
a382 2
  static unsigned int last_used;
  unsigned int i;
d384 6
a389 3
  if (last_used)
    if (strcmp (filename, files[last_used].filename) == 0)
      return last_used;
d391 13
a403 3
  for (i = 1; i < files_in_use; ++i)
    if (strcmp (filename, files[i].filename) == 0)
      return i;
d416 2
a417 2
  files[i].filename = xstrdup (filename);
  files[i].dir = 0;
d420 1
d463 1
a463 15
  if (num >= (int) files_allocated)
    {
      unsigned int old = files_allocated;

      files_allocated = num + 16;
      files = (struct file_entry *)
	xrealloc (files, (num + 16) * sizeof (struct file_entry));

      /* Zero the new memory.  */
      memset (files + old, 0, (num + 16 - old) * sizeof (struct file_entry));
    }

  files[num].filename = filename;
  files[num].dir = 0;
  files_in_use = num + 1;
d502 14
a515 1
      listing_source_file (files[filenum].filename);
d1058 8
a1065 1
  /* Terminate directory list.  */
d1382 7
@


1.58
log
@	* dwarf2dbg.c (scale_addr_delta): Correct parameter.  Move prototype
	inside #if.
@
text
@d47 1
a47 1
#define DWARF2_FORMAT() dwarf2_format_32bit
d50 5
d1349 1
a1349 1
  sizeof_address = bfd_arch_bits_per_address (stdoutput) / 8;
@


1.57
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@a176 1
static void scale_addr_delta PARAMS ((int *));
d600 2
d604 1
a604 1
     int *addr_delta;
@


1.56
log
@* dwarf2dbg.c (scale_addr_delta): New.
(size_inc_line_addr): Use it.
(emit_inc_line_addr): Use it.
@
text
@d139 1
a139 1
/* True when we've seen a .loc directive recently.  Used to avoid
d141 1
a141 1
static boolean loc_directive_seen;
d307 1
a307 1
	loc_directive_seen = false;
d439 1
a439 1
  loc_directive_seen = true;
@


1.55
log
@Add support for 64-bit DWARF 2 formats to gas.
@
text
@d177 1
d600 18
d634 1
a634 4
#if DWARF2_LINE_MIN_INSN_LENGTH > 1
  assert (addr_delta % DWARF2_LINE_MIN_INSN_LENGTH == 0);
  addr_delta /= DWARF2_LINE_MIN_INSN_LENGTH;
#endif
a696 1
#if DWARF2_LINE_MIN_INSN_LENGTH > 1
d698 2
a699 3
  assert (addr_delta % DWARF2_LINE_MIN_INSN_LENGTH == 0);
  addr_delta /= DWARF2_LINE_MIN_INSN_LENGTH;
#endif
@


1.54
log
@        * dwarf2dbg.c (out_debug_abbrev): Add support for the DW_AT_name field.
        (out_debug_info): Likewise.
@
text
@d46 4
d1006 2
d1019 25
a1043 2
  expr.X_add_number = -4;
  emit_expr (&expr, 4);
d1053 1
a1053 1
  emit_expr (&expr, 4);
d1206 2
d1218 25
a1242 2
  expr.X_add_number = -4;
  emit_expr (&expr, 4);
d1251 1
a1251 1
  emit_expr (&expr, 4);
@


1.53
log
@	* dwarf2dbg.c: Always include dwarf2dbg.h.
	(dwarf2_directive_file): Adjust dummy version args.
	* ecoff.c (ecoff_directive_weakext): Add ATTRIBUTE_UNUSED.
	* expr.c (clean_up_expression <O_subtract>): Allow subtraction
	when symbol values differ.
	* read.c (do_align): Add ATTRIBUTE_UNUSED to label.
	(pseudo_set <O_subtract>): Remove unnecessary segment test.
	* config/obj-bout.c (obj_pseudo_table): Warning fix.
@
text
@d1152 1
d1227 10
@


1.52
log
@2002-08-01  H.J. Lu  <hjl@@gnu.org>
            Daniel Jacobowitz  <drow@@mvista.com>

        * dwarf2dbg.c (dwarf2_finish): Don't emit unreferenced
        .debug_line section unless it has line information.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001 Free Software Foundation, Inc.
d44 2
a47 1
#include "dwarf2dbg.h"
d1344 1
a1344 1
void
d1349 1
@


1.51
log
@2002-06-14  H.J. Lu  <hjl@@gnu.org>
            Daniel Jacobowitz  <drow@@mvista.com>

        * dwarf2dbg.h (dwarf2_directive_file): Return char *.
        * dwarf2dbg.c (dwarf2_directive_file): Return filename.
        * config/tc-mips.c (s_mips_file): Call s_app_file_string
        and new_logical_line for the first .file directive.
        * read.c (s_app_file_string): New function.
        (s_app_file): Call it.
        * read.h (s_app_file_string): Add declaration.

2002-06-14  Daniel Jacobowitz  <drow@@mvista.com>

        * configure.in: Remove MIPS_STABS_ELF.
        * configure: Regenerated.
        * config.in: Regenerated.
        * config/obj-elf.h (ECOFF_DEBUGGING): Define to mips_flag_mdebug
        for MIPS targets.
        * config/tc-mips.c (mips_pseudo_table): Remove #ifdef around
        ".extern".
        (pdr_seg): Declare unconditionally.
        (md_begin): Always generate .pdr unless ECOFF_DEBUGGING or not ELF.
        (s_mips_end): Likewise.  Generate stabs function markers.
        (s_mips_ent): Generate stabs function markers.
        (s_mips_frame): Always generate .pdr unless ECOFF_DEBUGGING or not
        ELF.
        (s_mips_mask): Likewise.
        (mips_flag_mdebug): New.
        (md_longopts): Add "mdebug" and "no-mdebug".
        (md_parse_options): Add OPTION_MDEBUG and OPTION_NO_MDEBUG.
        (mips_after_parse_args): Set mips_flag_mdebug.
        * doc/as.texinfo: Add "-mdebug" and "-no-mdebug" for MIPS.

2002-06-14  Daniel Jacobowitz  <drow@@mvista.com>

        * gas/mips/lineno.d: Use --gstabs.
        * gas/mips/mips.exp (lineno.s): Remove XFAIL.
@
text
@d1251 9
a1259 2
  /* If no debug information was recorded, nothing to do.  */
  if (all_segs == NULL && files_in_use <= 1)
@


1.51.2.1
log
@2002-08-01  H.J. Lu  <hjl@@gnu.org>
            Daniel Jacobowitz  <drow@@mvista.com>

        * dwarf2dbg.c (dwarf2_finish): Don't emit unreferenced
        .debug_line section unless it has line information.
@
text
@d1251 2
a1252 9
  /* We don't need to do anything unless:
     - Some debug information was recorded via .file/.loc
     - or, we are generating DWARF2 information ourself (--gdwarf2)
     - or, there is a user-provided .debug_info section which could
       reference the file table in the .debug_line section we generate
       below.  */
  if (all_segs == NULL
      && debug_type != DEBUG_DWARF2
      && bfd_get_section_by_name (stdoutput, ".debug_info") == NULL)
@


1.51.2.2
log
@2002-09-23  Daniel Jacobowitz  <drow@@mvista.com>

	Merge from mainline:
	2002-09-22  Mark Elbrecht  <snowball3@@softhome.net>
	* write.c: Delete set_segment_vma and prototype. Update all callers.

	2002-09-19  Jakub Jelinek  <jakub@@redhat.com>
	* config/tc-i386.c (tc_i386_fix_adjustable): Handle
	BFD_RELOC_386_TLS_IE and BFD_RELOC_386_TLS_GOTIE.
	(BFD_RELOC_386_TLS_IE, BFD_RELOC_386_TLS_GOTIE): Define to 0
	if not defined.
	(lex_got): Handle @@GOTNTPOFF and @@INDNTPOFF.
	(md_apply_fix3, tc_gen_reloc): Handle BFD_RELOC_386_TLS_IE and
	BFD_RELOC_386_TLS_GOTIE.

	2002-09-16  Chris Demetriou  <cgd@@broadcom.com>
	* config/tc-mips.c (IS_SEXT_32BIT_NUM): Move closer to top of file.
	(IS_SEXT_16BIT_NUM): New macro.
	(macro_build_ldst_constoffset): New function, to build a set of
	instructions to do a load or store from a constant offset relative
	to a given register.
	(macro, s_cprestore): Use macro_build_ldst_constoffset to implement
	.cprestore pseudo-op.

	2002-09-16  Elias Athanasopoulos  <eathan@@otenet.gr>
	* dwarf2dbg.c (out_debug_abbrev): Add support for the DW_AT_name field.
	(out_debug_info): Likewise.

	2002-09-13  Nick Clifton  <nickc@@redhat.com>
	* config/tc-ppc.c (md_assemble): Do not count FAKE operands
	when deciding if any operands have been skipped.

	2002-09-11  Jakub Jelinek  <jakub@@redhat.com>
	* config/tc-i386.c (md_apply_fix3): Allow addend for
	BFD_RELOC_386_TLS_LDO_32, BFD_RELOC_386_TLS_LE and
	BFD_RELOC_386_TLS_LE_32.

	2002-09-11  Nick Clifton  <nickc@@redhat.com>
	* po/tr.po: Updated Turkish translation.

	2002-09-04  Nick Clifton  <nickc@@redhat.com>
	* config/tc-ppc.c (md_begin): Do not insert non-BookE32
	instructions into the hash table if the target cpu is the BookE32.

	2002-08-20  Richard Sandiford  <rsandifo@@redhat.com>
	* config/tc-mips.c (macro2): Implement rotates by zero using shifts
	by zero.

	2002-08-15  Alexandre Oliva  <aoliva@@redhat.com>
	* config/tc-mips.c (macro_build_jalr): Make sure we generate
	the fix-up against on the right frag.
	(s_cpsetup): Likewise.  Parse third argument as expression, to
	handle global symbols and forward/backward labels correctly.

	2002-08-14  Nick Clifton  <nickc@@redhat.com>
	* read.c (stringer): Catch attempts to create strings in the abs
	section.

	2002-08-12  Richard Sandiford  <rsandifo@@redhat.com>
	* config/tc-mips.c (mips_ip): Don't work out the value of
	constant %hi()s here.

	2002-08-10  Alan Modra  <amodra@@bigpond.net.au>
	* config/tc-i386.c (tc_i386_fix_adjustable): Test OUTPUT_FLAVOR
	for ELF, and don't bother checking ELF relocs when non-ELF.
	(i386_immediate): Allow absolute_section expressions for aout.
	(i386_displacement): Likewise.  Also test bfd_is_com_section.
	(md_estimate_size_before_relax): Test OUTPUT_FLAVOR for ELF.
	(md_apply_fix3): Hack for bfd_install_relocation when fx_pcrel,
	not when fx_addsy.  Remove dead code.

	2002-08-06  George France <france@@handhelds.org>
	* config/tc-alpha.c (cpu_types): Enabled ev67, ev68,  -m21264a
	and m21264b processor names and cpu types.
	* doc/c-alpha.texi: Documented new types.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* config/tc-ppc.c (md_apply_fix3): Adjust 16 bit XCOFF reloc offset.

	2002-08-03  Jakub Jelinek  <jakub@@redhat.com>
	* config/tc-i386.c (output_insn): Save frag_now and frag_now_fix ()
	at start of insn, pass it to output_disp and output_imm.
	(output_disp): Added arguments.  If _GLOBAL_OFFSET_TABLE_ is seen
	in displacement for R_386_32 reloc, use R_386_GOTPC and compute
	properly addend.
	(output_imm): Added arguments.  Compute properly addend for
	R_386_GOTPC.
	(md_apply_fix3): Remove R_386_GOTPC handling.

	2002-07-31  Momchil Velikov  <velco@@fadata.bg>
	* config/tc-v850.c (md_assemble): Fix range check for immediate
	operand.

	2002-07-04  Bruno Haible  <bruno@@clisp.org>
	* config/tc-i386.h (ELF_TARGET_FORMAT): New macro.
	(TARGET_FORMAT): Use ELF_TARGET_FORMAT instead of "elf32-i386".
	* config/tc-i386.c (i386_target_format): Likewise.
	* config/tc-alpha.h (ELF_TARGET_FORMAT): New macro.
	(TARGET_FORMAT): Use ELF_TARGET_FORMAT instead of "elf64-alpha".
@
text
@a1150 1
  out_abbrev (DW_AT_name, DW_FORM_string);
a1224 10

  /* DW_AT_name.  We don't have the actual file name that was present
     on the command line, so assume files[1] is the main input file.
     We're not supposed to get called unless at least one line number
     entry was emitted, so this should always be defined.  */
  if (!files || files_in_use < 1)
    abort ();
  len = strlen (files[1].filename) + 1;
  p = frag_more (len);
  memcpy (p, files[1].filename, len);
@


1.50
log
@2002-05-22  H.J. Lu <hjl@@gnu.org>

	* dwarf2dbg.c (dwarf2_directive_loc): Call listing_source_file
	for source file.
@
text
@d347 3
a349 1
/* Handle the .file directive.  */
d351 3
a353 1
void
d366 1
a366 1
      return;
d376 1
a376 1
      return;
d382 1
a382 1
      return;
d400 2
@


1.49
log
@2002-05-22  H.J. Lu <hjl@@gnu.org>

	* dwarf2dbg.c (dwarf2_emit_insn): Emit only one line symbol
	for one .loc for compiler.
@
text
@d431 4
a434 1
    listing_source_line (line);
@


1.48
log
@Do not reset loc_directive_seen in dwarf2_emit_insn.
@
text
@d290 13
a302 6
    /* Use the last location established by a .loc directive, not
       the value returned by dwarf2_where().  That calls as_where()
       which will return either the logical input file name (foo.c)
       or the physical input file name (foo.s) and not the file name
       specified in the most recent .loc directive (eg foo.h).  */
    loc = current;
@


1.47
log
@Use the 'current' struct filled by dwarf2_directive_loc, instead of calling
dwarf2_where.
@
text
@d289 8
a296 1
  if (debug_type != DEBUG_DWARF2 && ! loc_directive_seen)
d298 2
a299 1
  loc_directive_seen = false;
a300 6
  /* Use the last location established by a .loc directive, not
     the value returned by dwarf2_where().  That calls as_where()
     which will return either the logical input file name (foo.c)
     or the physical input file name (foo.s) and not the file name
     specified in the most recent .loc directive (eg foo.h).  */
  loc = current;
@


1.46
log
@	* as.h: Fix formatting.
	* cgen.c: Likewise.
	* cgen.h: Likewise.
	* dwarf2dbg.c: Likewise.
	* frags.h: Likewise.
	* gasp.c: Likewise.
	* macro.c: Likewise.
	* read.c: Likewise.
	* stabs.c: Likewise.
	* symbols.c: Likewise.
@
text
@d293 6
a298 1
  dwarf2_where (&loc);
@


1.45
log
@	* dwarf2dbg.c (dwarf2_gen_line_info): Do emit duplicate line
	numbers, gdb relies on them to detect the start of the prologue.
@
text
@d244 1
a244 1
  if (debug_type == DEBUG_DWARF2 
@


1.44
log
@2001-11-16  Michael Snyder  <msnyder@@redhat.com>

	* stabs.c (stabs_generate_asm_lineno): Remember file and line number
	from one call to the next, and eliminate consecutive duplicates
	(thereby emitting only one line symbol per source line).
	* dwarf2dbg.c (dwarf2_gen_line_info): Ditto.
@
text
@d240 6
a245 2
  /* Don't emit sequences of line symbols for the same line. */
  if (line == loc->line && filenum == loc->filenum)
@


1.43
log
@gas/ChangeLog
	* dwarf2dbg.c (get_frag_fix): Align last frag size.
@
text
@d233 2
d239 7
@


1.42
log
@	* dwarf2dbg.c (dwarf2_directive_file): Avoid signed/unsigned warning.

	* write.c (set_symtab): Update bfd_alloc declaration.  Use a temp
	var to ensure bfd_alloc arg is the right type.
	(write_object_file): Cast args of bfd_seek.  Replace bfd_write with
	bfd_bwrite.

	* config/obj-coff.c: Replace calls to bfd_write with calls to
	bfd_bwrite.  Cast args of bfd_seek.

	* config/obj-elf.c (obj_elf_change_section): Avoid signed/unsigned
	warning.

	* config/tc-mn10300.c (set_arch_mach): Make param unsigned.

	* config/tc-tic54x.c (tic54x_mlib): Replace bfd_read call with
	call to bfd_bread.
@
text
@d527 3
a529 2
	return ((char *) obstack_next_free (&fr->frch_obstack)
		- frag->fr_literal);
@


1.41
log
@	* read.c: Standardize error/warning messages - don't capitalise, no
	final period or newline, don't say "ignored" or "zero assumed" for
	as_bad messages.  In some cases, change the wording to that used
	elsewhere for similar messages.
	* app.c, as.c, atof-generic.c, cgen.c, cond.c, depend.c, dwarf2dbg.c,
	  ecoff.c, expr.c, frags.c, input-file.c, input-scrub.c, listing.c,
	  output-file.c, stabs.c, subsegs.c, symbols.c, write.c: Likewise.
	* ecoff.c (ecoff_directive_end): Test for missing name by
	comparing input line pointers rather than reading string.
	(ecoff_directive_ent): Likewise.
	* read.c (s_set): Likewise.
	(s_align): Report a warning rather than an error for
	alignment too large.
	(s_comm): Check for missing symbol name.
	(s_lcomm_internal): Likewise.
	(s_lsym): Likewise.
	(s_globl): Use is_end_of_line instead of looking for '\n'.
	(s_lcomm_internal): Likewise.
	(ignore_rest_of_line): Report a warning rather than an error.
@
text
@d348 1
a348 1
  if (num < files_in_use && files[num].filename != 0)
@


1.40
log
@	* dwarf2dbg.c (dwarf2_finish): Output file info even when no
	line info.
@
text
@d344 1
a344 1
      as_bad (_("File number less than one"));
d350 1
a350 1
      as_bad (_("File number %ld already allocated"), (long) num);
d386 1
a386 1
      as_bad (_("File number less than one"));
d391 1
a391 1
      as_bad (_("Unassigned file number %ld"), (long) filenum);
d936 1
a936 1
	  as_bad (_("Unassigned file number %u"), i);
@


1.39
log
@	* symbols.c (resolve_symbol_value): Remove "finalize" param,
	instead use finalize_syms directly.  Don't treat expressions
	specially with regard to finalize_syms.  Update calls to self.
	(resolve_local_symbol): Update call to resolve_symbol_value.
	(S_GET_VALUE): Likewise.  Return resolve_symbol_value if
	!finalize_syms.
	* symbols.h (resolve_symbol_value): Update prototype.
	* config/obj-aout.c (obj_crawl_symbol_chain): Update call
	to resolve_symbol_value.
	* config/obj-bout.c (obj_crawl_symbol_chain): Likewise.
	* config/obj-coff.c (do_relocs_for): Likewise.
	(yank_symbols): Likewise.
	(fixup_segment): Likewise.
	* config/obj-vms.c (obj_crawl_symbol_chain): Likewise.
	* config/tc-mips.c (md_convert_frag): Likewise.
	* config/tc-ppc.c (ppc_frob_symbol): Likewise.
	(ppc_fix_adjustable): Likewise.
	* dwarf2dbg.c (dwarf2dbg_estimate_size_before_relax): Likewise.
	(dwarf2dbg_convert_frag): Likewise.
	* ehopt.c (eh_frame_estimate_size_before_relax): Likewise.
	(eh_frame_convert_frag): Likewise.
	* expr.c (make_expr_symbol): Likewise.
	* write.c (adjust_reloc_syms): Likewise.
	(write_object_file): Likewise.
	(relax_segment): Likewise.
	(fixup_segment): Likewise.
	(finalize_syms): Init to zero, and update comment.
	(write_object_file): Set finalize_syms to 1 rather than 2.
	* doc/internals.texi (sy_value): Mention finalize_syms.
	(S_GET_VALUE): Remove restriction on when S_GET_VALUE can be called.
@
text
@d1215 1
a1215 1
  if (all_segs == NULL)
d1242 1
a1242 1
  if (debug_type == DEBUG_DWARF2)
@


1.38
log
@        * dwarf2dbg.c (process_entries): Don't optimize redundant line notes.
@
text
@d775 1
a775 1
  addr_delta = resolve_symbol_value (frag->fr_symbol, 0);
d809 1
a809 1
  addr_diff = resolve_symbol_value (frag->fr_symbol, finalize_syms);
@


1.37
log
@Pass finalize_syms on calls to resolve_symbol_value.
@
text
@d876 5
a880 1
      if (line != e->loc.line || changed)
@


1.36
log
@Multi-pass relaxation machinery.
@
text
@d809 1
a809 1
  addr_diff = resolve_symbol_value (frag->fr_symbol, 1);
@


1.35
log
@        * dwarf2dbg.c (user_filenum, user_filenum_allocated): Remove.
        (dwarf2_directive_loc): Don't use them.
        (dwarf2_directive_file): Reject duplicate file definitions.
        (get_filenum): Zero allocated memory.
        (out_file_list): Complain about missing file definitions.
@
text
@d327 1
a327 1
  const char *filename;
d350 1
a350 1
      as_bad (_("File number %d already allocated"), num);
@


1.34
log
@Fix copyright notices
@
text
@a133 5
/* Correlate file numbers as given by the user in .file/.loc directives
   with the file numbers used in the output debug info.  */
static unsigned int *user_filenum;
static unsigned int user_filenum_allocated;

d303 2
d308 2
d342 1
a342 1
  if (num < 0)
d344 1
a344 1
      as_bad (_("File number less than zero"));
d348 1
a348 1
  if (num >= (int) user_filenum_allocated)
d350 3
a352 1
      unsigned int old = user_filenum_allocated;
d354 7
a360 3
      user_filenum_allocated = num + 16;
      user_filenum = (unsigned int *)
	xrealloc (user_filenum, (num + 16) * sizeof (unsigned int));
d363 1
a363 1
      memset (user_filenum + old, 0, (num + 16 - old) * sizeof (unsigned int));
d366 3
a368 1
  user_filenum[num] = get_filenum (filename);
d384 1
a384 1
  if (filenum < 0)
d386 1
a386 1
      as_bad (_("File number less than zero"));
d389 1
a389 2
  if (filenum >= (int) user_filenum_allocated
      || user_filenum[filenum] == 0)
d395 1
a395 1
  current.filenum = user_filenum[filenum];
d930 6
@


1.33
log
@2001-02-23  H.J. Lu  <hjl@@gnu.org>

	* dwarf2dbg.c (dwarf2_directive_file): Call s_app_file (0) if
	BFD_ASSEMBLER is not defined.
@
text
@d2 1
a2 1
   Copyright (C) 1999, 2000 Free Software Foundation, Inc.
@


1.32
log
@        * dwarf2dbg.c (out_debug_abbrev): Terminate the abbreviations
        for the compilation unit with a zero byte.
@
text
@d1287 1
a1287 1
  as_fatal (_("dwarf2 is not supported for this object file format"));
@


1.31
log
@2000-12-22  H.J. Lu  <hjl@@gnu.org>

	* dwarf2dbg.c (dwarf2_finish): Remove #if BFD_ASSEMBLER.
@
text
@d1102 3
@


1.31.2.1
log
@        * dwarf2dbg.c (out_debug_abbrev): Terminate the abbreviations
        for the compilation unit with a zero byte.
@
text
@a1101 3

  /* Terminate the abbreviations for this compilation unit.  */
  out_byte (0);
@


1.31.2.2
log
@2001-04-02  Philip Blundell  <philb@@gnu.org>

	From 2001-03-17  Richard Henderson  <rth@@redhat.com>
	* dwarf2dbg.c (user_filenum, user_filenum_allocated): Remove.
	(dwarf2_directive_loc): Don't use them.
	(dwarf2_directive_file): Reject duplicate file definitions.
	(get_filenum): Zero allocated memory.
	(out_file_list): Complain about missing file definitions.
@
text
@d134 5
a307 2
      unsigned int old = files_allocated;

a310 2

      memset (files + old, 0, (i + 32 - old) * sizeof (struct file_entry));
d343 1
a343 1
  if (num < 1)
d345 1
a345 1
      as_bad (_("File number less than one"));
d349 1
a349 1
  if (num < files_in_use && files[num].filename != 0)
d351 1
a351 3
      as_bad (_("File number %d already allocated"), num);
      return;
    }
d353 3
a355 7
  if (num >= (int) files_allocated)
    {
      unsigned int old = files_allocated;

      files_allocated = num + 16;
      files = (struct file_entry *)
	xrealloc (files, (num + 16) * sizeof (struct file_entry));
d358 1
a358 1
      memset (files + old, 0, (num + 16 - old) * sizeof (struct file_entry));
d361 1
a361 3
  files[num].filename = filename;
  files[num].dir = 0;
  files_in_use = num + 1;
d377 1
a377 1
  if (filenum < 1)
d379 1
a379 1
      as_bad (_("File number less than one"));
d382 2
a383 1
  if (filenum >= (int) files_in_use || files[filenum].filename == 0)
d389 1
a389 1
  current.filenum = filenum;
a923 6
      if (files[i].filename == NULL)
	{
	  as_bad (_("Unassigned file number %u"), i);
	  continue;
	}

@


1.31.2.3
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1999, 2000, 2001 Free Software Foundation, Inc.
@


1.31.2.4
log
@Merge from mainline.
@
text
@d327 1
a327 1
  char *filename;
d350 1
a350 1
      as_bad (_("File number %ld already allocated"), (long) num);
d876 1
a876 5
      /* Don't try to optimize away redundant entries; gdb wants two
	 entries for a function where the code starts on the same line as
	 the {, and there's no way to identify that case here.  Trust gcc
	 to optimize appropriately.  */
      if (1 /* line != e->loc.line || changed */)
d1299 1
a1299 1
  s_app_file (0);
@


1.30
log
@oops - omitted terminating #endif
@
text
@a1199 1
#ifdef BFD_ASSEMBLER
a1200 4
#else
  /* FIXME.  */
  sizeof_address = 4;
#endif
a1203 1
#ifdef BFD_ASSEMBLER
a1204 1
#endif
a1232 1
#ifdef BFD_ASSEMBLER
a1235 1
#endif
@


1.29
log
@If we don't have <limits.h>, try including <sys/param.h> if we have it.
@
text
@d42 1
@


1.28
log
@2000-12-13  Kazu Hirata  <kazu@@hxi.com>

	* as.h: Fix formatting.
	* cgen.h: Likewise.
	* dwarf2dbg.c: Likewise.
	* input-scrub.c: Likewise.
	* read.h: Likewise.
@
text
@d36 3
a40 1
#endif
@


1.27
log
@aadd conditionals around definition of INT_MAX
@
text
@d37 1
a37 1
#define INT_MAX (int) (((unsigned)(-1)) >> 1)
d96 1
a96 3

struct line_entry
{
d103 1
a103 2
struct line_subseg
{
d110 1
a110 2
struct line_seg
{
d121 1
a121 2
struct file_entry
{
d192 1
a192 1
  for (s = all_segs; s ; s = s->next)  
d206 1
a206 1
        goto found_subseg;
d281 1
a281 1
     
d307 1
a307 1
	xrealloc (files, (i + 32) * sizeof(struct file_entry));
d310 1
a310 1
  files[i].filename = xstrdup(filename);
d355 1
a355 1
      memset (user_filenum + old, 0, (num + 16 - old) * sizeof(unsigned int));
a397 1

d405 1
a405 1
  for (f = frchain_root; f ; f = f->frch_next)
d419 1
a419 1
  for (f = frchain_root; f ; f = f->frch_next)
d515 1
a515 1
  for (fr = frchain_root; fr ; fr = fr->frch_next)
d564 1
a564 1
#if DWARF2_LINE_MIN_INSN_LENGTH > 1  
d630 1
a630 1
#if DWARF2_LINE_MIN_INSN_LENGTH > 1  
d786 1
a786 1
  
d807 1
a807 1
  emit_inc_line_addr (frag->fr_offset, addr_diff, 
d903 1
a903 1
    relax_inc_line_addr (INT_MAX, seg, last_frag, last_frag_ofs, 
d992 1
a992 1
  for (s = all_segs; s ; s = s->next)
d1013 2
a1014 2
  skip = 2*addr_size - (size & (2*addr_size - 1));
  if (skip == 2*addr_size)
d1018 2
a1019 2
  for (s = all_segs; s ; s = s->next)
    size += 2*addr_size;
d1021 1
a1021 1
  size += 2*addr_size;
d1045 1
a1045 1
    frag_align (ffs (2*addr_size) - 1, 0, 0);
d1047 1
a1047 1
  for (s = all_segs; s ; s = s->next)
d1119 1
a1119 1
  info_start = symbol_new_now();
d1211 1
a1211 1
  for (s = all_segs; s ; s = s->next)
d1243 1
a1243 1
      record_alignment (aranges_seg, ffs (2*sizeof_address) - 1);
@


1.26
log
@Adde dfinition if INT_MAX if limits.h is not included
@
text
@d36 1
d38 1
@


1.25
log
@#include <limits.h> only if it exists.
@
text
@d35 2
@


1.24
log
@2000-12-12  H.J. Lu  <hjl@@gnu.org>

	* dwarf2dbg.c: Enabled only if BFD_ASSEMBLER is defined.

	* read.h (outputting_stabs_line_debug): Change it to int.
	* stabs.c (outputting_stabs_line_debug): Likewise.
@
text
@d31 3
d35 1
a35 2

#include "as.h"
@


1.23
log
@Add outputting_stabs_line_debug varaible and D10v code to use it
@
text
@d34 3
d1250 50
@


1.22
log
@        * dwarf2dbg.c: Rewrite from scratch.  Queue all debugging output
        until dwarf2_finish; use relaxation to get cross-fragment offsets;
        thread multiple subsegments properly; handle multiple code
        sections properly; emit proper compilation unit info for assembler
        generated debugging.

        * as.h (enum _relax_state): Add rs_dwarf2dbg.
        * dwarf2dbg.h (struct dwarf2_line_info): Remove filename.
        (dwarf2dbg_estimate_size_before_relax): Declare.
        (dwarf2dbg_relax_frag, dwarf2dbg_convert_frag): Declare.
        * write.c: Include dwarf2dbg.h.
        (cvt_frag_to_fill): Handle rs_dwarf2dbg.
        (relax_segment): Likewise.
@
text
@d342 1
a342 1
  if (num >= user_filenum_allocated)
d375 1
a375 1
  if (filenum >= user_filenum_allocated
d561 1
d564 1
d627 1
d631 1
a631 1

d802 1
a802 1
  assert (frag->fr_var >= frag->fr_subtype);
@


1.21
log
@        * dwarf2dbg.c (dwarf2_gen_line_info): Early out for no line number.
        * config/obj-elf.h (ECOFF_DEBUGGING) [TC_ALPHA]: Adjust for
        tri-state definition of alpha_flag_mdebug.
        * config/tc-alpha.c (alpha_flag_mdebug): Init to -1.
        (s_alpha_file): Store first .file directive.
        (s_alpha_stab): New.
        (md_pseudo_table): Add stabs and stabn.
@
text
@d31 1
a75 6
/* Flag that indicates the initial value of the is_stmt_start flag.
   In the present implementation, we do not mark any lines as
   the beginning of a source statement, because that information
   is not made available by the GCC front-end.  */
#define	DWARF2_LINE_DEFAULT_IS_STMT	1

d87 33
a119 76
#define INITIAL_STATE						\
  /* Initialize as per DWARF2.0 standard.  */			\
  0,					/* address */		\
  1,					/* file */		\
  1,					/* line */		\
  0,					/* column */		\
  DWARF2_LINE_DEFAULT_IS_STMT,		/* is_stmt */		\
  0,					/* basic_block */	\
  1					/* empty_sequence */

static struct {
    /* state machine state as per DWARF2 manual: */
    struct dwarf2_sm {
	addressT addr;
	unsigned int filenum;
	unsigned int line;
	unsigned int column;
	unsigned int
	  is_stmt : 1,
	  basic_block : 1,
	  empty_sequence : 1;		/* current code sequence has no DWARF2 directives? */
    } sm;

    unsigned int
      any_dwarf2_directives : 1;	/* did we emit any DWARF2 line debug directives? */

    fragS * frag;	/* frag that "addr" is relative to */
    segT text_seg;	/* text segment "addr" is relative to */
    subsegT text_subseg;
    segT line_seg;	/* ".debug_line" segment */
    int last_filename;	/* index of last filename that was used */
    int num_filenames;	/* index of last filename in use */
    int filename_len;	/* length of the filename array */
    struct {
	int dir;	/* valid after gen_dir_list() only */
	char *name; /* full path before gen_dir_list(), filename afterwards */
    } *file;

    struct dwarf2_line_info current;	/* current source info */

    /* counters for statistical purposes */
    unsigned int num_line_entries;
    unsigned int opcode_hist[256];	/* histogram of opcode frequencies */
} ls = {
    {
      INITIAL_STATE
    },
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    0,
    NULL,
    { NULL, 0, 0, 0, 0 },
    0,
    {
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0
    }
d122 32
a153 1
/* Function prototypes.  */
d155 63
a217 10
static void out_sleb128 PARAMS ((offsetT));
static void gen_addr_line PARAMS ((int, addressT));
static void reset_state_machine PARAMS ((void));
static void out_set_addr PARAMS ((addressT));
static void out_end_sequence PARAMS ((void));
static int get_filenum PARAMS ((int, char *));
static void gen_dir_list PARAMS ((void));
static void gen_file_list PARAMS ((void));
static void print_stats PARAMS ((unsigned long));
static addressT now_subseg_size PARAMS ((void));
d219 2
a220 2
#define out_byte(byte)	FRAG_APPEND_1_CHAR(byte)
#define out_opcode(opc)	(out_byte ((opc)), ++ls.opcode_hist[(opc) & 0xff])
d222 1
a222 1
/* Output an unsigned "little-endian base 128" number.  */
d224 4
a227 3
static void
out_uleb128 (value)
     addressT value;
d229 2
a230 1
  unsigned char byte, more = 0x80;
d232 20
a251 1
  do
d253 5
a257 5
      byte = value & 0x7f;
      value >>= 7;
      if (value == 0)
	more = 0;
      out_byte (more | byte);
d259 21
a279 1
  while (more);
d282 1
a282 1
/* Output a signed "little-endian base 128" number.  */
d284 3
a286 3
static void
out_sleb128 (value)
     offsetT value;
d288 2
a289 1
  unsigned char byte, more = 0x80;
d291 9
a299 1
  do
d301 3
a303 6
      byte = value & 0x7f;
      value >>= 7;
      if (((value == 0) && ((byte & 0x40) == 0))
	  || ((value == -1) && ((byte & 0x40) != 0)))
	more = 0;
      out_byte (more | byte);
d305 7
a311 1
  while (more);
d314 1
a314 3
/* Encode a pair of line and address skips as efficiently as possible.
   Note that the line skip is signed, whereas the address skip is
   unsigned.  */
d316 3
a318 4
static void
gen_addr_line (line_delta, addr_delta)
     int line_delta;
     addressT addr_delta;
d320 15
a334 1
  unsigned int tmp, opcode;
d336 5
a340 1
  tmp = line_delta - DWARF2_LINE_BASE;
d342 1
a342 1
  if (tmp >= DWARF2_LINE_RANGE)
d344 8
a351 4
      out_opcode (DW_LNS_advance_line);
      out_sleb128 (line_delta);
      tmp = 0 - DWARF2_LINE_BASE;
      line_delta = 0;
d354 15
a368 1
  tmp += DWARF2_LINE_OPCODE_BASE;
d370 1
a370 3
  /* Try using a special opcode.  */
  opcode = tmp + addr_delta * DWARF2_LINE_RANGE;
  if (opcode <= 255)
d372 1
a372 1
      out_opcode (opcode);
d375 2
a376 4

  /* Try using DW_LNS_const_add_pc followed by special op.  */
  opcode = tmp + (addr_delta - MAX_SPECIAL_ADDR_DELTA) * DWARF2_LINE_RANGE;
  if (opcode <= 255)
d378 1
a378 2
      out_opcode (DW_LNS_const_add_pc);
      out_opcode (opcode);
d382 68
a449 2
  out_opcode (DW_LNS_advance_pc);
  out_uleb128 (addr_delta);
d451 7
a457 6
  if (line_delta)
    /* Output line-delta.  */
    out_opcode (tmp);
  else
    /* Append new row with current info.  */
    out_opcode (DW_LNS_copy);
d460 2
d463 2
a464 1
reset_state_machine ()
d466 14
a479 1
  static const struct dwarf2_sm initial_state = { INITIAL_STATE };
d481 4
a484 1
  ls.sm = initial_state;
d487 1
a487 1
/* Set an absolute address (may results in a relocation entry).  */
d490 13
a502 2
out_set_addr (addr)
     addressT addr;
d504 14
a517 5
  subsegT saved_subseg;
  segT saved_seg;
  expressionS expr;
  symbolS *sym;
  int bytes_per_address;
d519 2
a520 2
  saved_seg = now_seg;
  saved_subseg = now_subseg;
d522 1
a522 2
  subseg_set (ls.text_seg, ls.text_subseg);
  sym = symbol_new (".L0\001", now_seg, addr, frag_now);
d524 8
a531 1
  subseg_set (saved_seg, saved_subseg);
d533 1
a533 6
#ifdef BFD_ASSEMBLER
  bytes_per_address = bfd_arch_bits_per_address (stdoutput) / 8;
#else
  /* FIXME.  */
  bytes_per_address = 4;
#endif
d536 1
a536 1
  out_uleb128 (bytes_per_address + 1);
d542 1
a542 1
  emit_expr (&expr, bytes_per_address);
d545 2
a546 2
/* Emit DW_LNS_end_sequence and reset state machine.  Does not
   preserve the current segment/sub-segment!  */
d548 8
a555 2
static void
out_end_sequence ()
d557 2
a558 2
  addressT addr, delta;
  fragS *text_frag;
d560 8
a567 1
  if (ls.text_seg)
d569 2
a570 14
      subseg_set (ls.text_seg, ls.text_subseg);
#ifdef md_current_text_addr
      addr = md_current_text_addr ();
#else
      addr = frag_now_fix ();
#endif
      text_frag = frag_now;
      subseg_set (ls.line_seg, DL_BODY);
      if (text_frag != ls.frag)
	{
	  out_set_addr (addr);
	  ls.sm.addr = addr;
	  ls.frag = text_frag;
	}
d572 14
a585 11
	{
	  delta = (addr - ls.sm.addr) / DWARF2_LINE_MIN_INSN_LENGTH;
	  if (delta > 0)
	    {
	      /* Advance address without updating the line-debug
		 matrix---the end_sequence entry is used only to tell
		 the debugger the end of the sequence.  */
	      out_opcode (DW_LNS_advance_pc);
	      out_uleb128 (delta);
	    }
	}
a586 2
  else
    subseg_set (ls.line_seg, DL_BODY);
d588 10
a597 3
  out_opcode (DW_LNS_extended_op);
  out_uleb128 (1);
  out_byte (DW_LNE_end_sequence);
d599 5
a603 2
  reset_state_machine ();
}
d605 2
a606 4
/* Look up a filenumber either by filename or by filenumber.  If both
   a filenumber and a filename are specified, lookup by filename takes
   precedence.  If the filename cannot be found, it is added to the
   filetable and the filenumber for the new entry is returned.  */
d608 2
a609 7
static int
get_filenum (filenum, file)
     int filenum;
     char *file;
{
  int i, last = filenum - 1;
  char char0 = file[0];
d611 2
a612 4
  /* If filenum is out of range of the filename table, then try using the
     table entry returned from the previous call.  */
  if (last >= ls.num_filenames || last < 0)
    last = ls.last_filename;
d614 10
a623 4
  /* Do a quick check against the specified or previously used filenum.  */
  if (ls.num_filenames > 0 && ls.file[last].name[0] == char0
      && strcmp (ls.file[last].name + 1, file + 1) == 0)
    return last + 1;
d625 8
a632 2
  /* No match, fall back to simple linear scan.  */
  for (i = 0; i < ls.num_filenames; ++i)
d634 3
a636 2
      if (ls.file[i].name[0] == char0
	  && strcmp (ls.file[i].name + 1, file + 1) == 0)
d638 2
a639 2
	  ls.last_filename = i;
	  return i + 1;
d641 5
d648 6
a653 2
  /* No match, enter new filename.  */
  if (ls.num_filenames >= ls.filename_len)
d655 2
a656 8
      ls.filename_len += 13;
      ls.file = xrealloc (ls.file, ls.filename_len * sizeof (ls.file[0]));
    }
  ls.file[ls.num_filenames].dir = 0;
  ls.file[ls.num_filenames].name = file;
  ls.last_filename = ls.num_filenames;
  return ++ls.num_filenames;
}
d658 7
a664 2
/* Emit an entry in the line number table if the address or line has changed.
   ADDR is relative to the current frag in the text section.  */
d666 4
a669 10
void
dwarf2_gen_line_info (addr, l)
     addressT addr;
     struct dwarf2_line_info *l;
{
  unsigned int filenum = l->filenum;
  unsigned int any_output = 0;
  subsegT saved_subseg;
  segT saved_seg;
  fragS *saved_frag;
d671 2
a672 3
  if (flag_debug)
    fprintf (stderr, "line: addr %lx file `%s' line %u col %u flags %x\n",
	     (unsigned long) addr, l->filename, l->line, l->column, l->flags);
d674 2
a675 1
  if (filenum > 0 && !l->filename)
d677 11
a687 1
      if (filenum >= (unsigned int) ls.num_filenames)
d689 3
a691 2
	  as_warn ("Encountered bad file number in line number debug info!");
	  return;
d694 7
a700 2
  else if (l->filename)
    filenum = get_filenum (filenum, l->filename);
d702 19
a720 2
    /* No filename, no filnum => no play.  */
    return;
d722 10
a731 3
  /* Early out for as-yet incomplete location information.  */
  if (l->line == 0)
    return;
d733 2
a734 5
  /* Must save these before the subseg_new call, as that call will change
     them.  */
  saved_seg = now_seg;
  saved_subseg = now_subseg;
  saved_frag = frag_now;
d736 4
a739 5
  if (!ls.line_seg)
    {
#ifdef BFD_ASSEMBLER
      symbolS *secsym;
#endif
d741 3
a743 1
      ls.line_seg = subseg_new (".debug_line", 0);
d745 3
a747 2
#ifdef BFD_ASSEMBLER
      bfd_set_section_flags (stdoutput, ls.line_seg, SEC_READONLY);
d749 10
a758 8
      /* We're going to need this symbol.  */
      secsym = symbol_find (".debug_line");
      if (secsym != NULL)
	symbol_set_bfdsym (secsym, ls.line_seg->symbol);
      else
	symbol_table_insert (section_symbol (ls.line_seg));
#endif
    }
d760 2
a761 1
  subseg_set (ls.line_seg, DL_BODY);
d763 1
a763 15
  if (ls.text_seg != saved_seg || ls.text_subseg != saved_subseg)
    {
      if (!ls.sm.empty_sequence)
	{
	  /* Terminate previous sequence.  */
	  out_end_sequence ();
	  ls.sm.empty_sequence = 1;
	}
      any_output = 1;
      ls.text_seg = saved_seg;
      ls.text_subseg = saved_subseg;
      out_set_addr (addr);
      ls.sm.addr = addr;
      ls.frag = saved_frag;
    }
d765 2
a766 7
  if (ls.sm.filenum != filenum)
    {
      any_output = 1;
      out_opcode (DW_LNS_set_file);
      out_uleb128 (filenum);
      ls.sm.filenum = filenum;
    }
d768 9
a776 7
  if (ls.sm.column != l->column)
    {
      any_output = 1;
      out_opcode (DW_LNS_set_column);
      out_uleb128 (l->column);
      ls.sm.column = l->column;
    }
d778 5
a782 5
  if (((l->flags & DWARF2_FLAG_BEGIN_STMT) != 0) != ls.sm.is_stmt)
    {
      any_output = 1;
      out_opcode (DW_LNS_negate_stmt);
    }
d784 3
a786 5
  if (l->flags & DWARF2_FLAG_BEGIN_BLOCK)
    {
      any_output = 1;
      out_opcode (DW_LNS_set_basic_block);
    }
d788 5
a792 19
  if (ls.sm.line != l->line)
    {
      any_output = 1;
      if (saved_frag != ls.frag)
	{
	  /* If a new frag got allocated (for whatever reason), then
	     deal with it by generating a reference symbol.  Note: no
	     end_sequence needs to be generated because the address did
	     not really decrease (only the reference point changed).  */
	  out_set_addr (addr);
	  ls.sm.addr = addr;
	  ls.frag = saved_frag;
	}
      gen_addr_line (l->line - ls.sm.line,
		     (addr - ls.sm.addr) / DWARF2_LINE_MIN_INSN_LENGTH);
      ls.sm.basic_block = 0;
      ls.sm.line = l->line;
      ls.sm.addr = addr;
    }
d794 1
a794 1
  subseg_set (saved_seg, saved_subseg);
d796 12
a807 3
  ls.num_line_entries += any_output;
  if (any_output)
    ls.sm.empty_sequence = 0;
d810 3
d814 3
a816 1
gen_dir_list ()
d818 29
a846 2
  char *str, *slash, *dir_list, *dp, *cp;
  int i, j, num_dirs;
d848 6
a853 2
  dir_list = frag_more (0);
  num_dirs = 0;
d855 7
a861 5
  for (i = 0; i < ls.num_filenames; ++i)
    {
      str = ls.file[i].name;
      slash = strrchr (str, '/');
      if (slash)
d863 2
a864 2
	  *slash = '\0';
	  for (j = 0, dp = dir_list; j < num_dirs; ++j)
d866 2
a867 6
	      if (strcmp (str, dp) == 0)
		{
		  ls.file[i].dir = j + 1;
		  break;
		}
	      dp += strlen (dp);
d869 15
a883 10
	  if (j >= num_dirs)
	    {
	      /* Didn't find this directory: append it to the list.  */
	      size_t size = strlen (str) + 1;
	      cp = frag_more (size);
	      memcpy (cp, str, size);
	      ls.file[i].dir = ++num_dirs;
	    }
	  *slash = '/';
	  ls.file[i].name = slash + 1;
d885 4
d891 8
a898 2
  /* Terminate directory list.  */
  out_byte ('\0');
d901 2
d904 1
a904 1
gen_file_list ()
d908 4
a911 1
  int i;
d913 1
a913 1
  for (i = 0; i < ls.num_filenames; ++i)
d915 1
a915 1
      size = strlen (ls.file[i].name) + 1;
d917 1
a917 1
      memcpy (cp, ls.file[i].name, size);
d919 1
a919 1
      out_uleb128 (ls.file[i].dir);	/* directory number */
d928 2
d931 2
a932 2
print_stats (total_size)
     unsigned long total_size;
d934 54
a987 7
  static const char *opc_name[] = {
    "extended", "copy", "advance_pc", "advance_line", "set_file",
    "set_column", "negate_stmt", "set_basic_block", "const_add_pc",
    "fixed_advance_pc"
  };
  size_t i;
  int j;
d989 2
a990 2
  fprintf (stderr, "Average size: %g bytes/line\n",
	   total_size / (double) ls.num_line_entries);
d992 1
a992 1
  fprintf (stderr, "\nStandard opcode histogram:\n");
d994 10
a1003 7
  for (i = 0; i < sizeof (opc_name) / sizeof (opc_name[0]); ++i)
    {
      fprintf (stderr, "%s", opc_name[i]);
      for (j = strlen (opc_name[i]); j < 16; ++j)
	fprintf (stderr, " ");
      fprintf (stderr, ": %u\n", ls.opcode_hist[i]);
    }
d1005 1
a1005 1
  fprintf (stderr, "\nSpecial opcodes:\naddr\t\t\t\tline skip\n");
d1007 4
a1010 4
  fprintf (stderr, "skip: ");
  for (j = DWARF2_LINE_BASE; j < DWARF2_LINE_BASE + DWARF2_LINE_RANGE; ++j)
    fprintf (stderr, "%3d", j);
  fprintf (stderr, "\n-----");
d1012 2
a1013 11
  for (; i < 256; ++i)
    {
      j = SPECIAL_LINE (i);
      if (j == DWARF2_LINE_BASE)
	fprintf (stderr, "\n%4u: ",
		 (unsigned int) (DWARF2_LINE_MIN_INSN_LENGTH
				 * SPECIAL_ADDR (i)));
      fprintf (stderr, " %2u", ls.opcode_hist[i]);
    }
  fprintf (stderr, "\n");
}
d1015 1
a1015 3
/* Compute the size of the current subsegment, taking all fragments
   into account.  Note that we don't generate variant frags, so the
   fixed portion is all we need to consider.  */
d1017 1
a1017 5
static addressT
now_subseg_size ()
{
  struct frag *f;
  addressT size = 0;
d1019 2
a1020 2
  for (f = frchain_now->frch_root; f ; f = f->fr_next)
    size += f->fr_fix;
d1022 2
a1023 2
  return size + frag_now_fix_octets ();
}
d1025 5
a1029 7
void
dwarf2_finish ()
{
  addressT body_size, total_size, prolog_size;
  subsegT saved_subseg;
  segT saved_seg;
  char *cp;
d1031 2
a1032 3
  if (!ls.line_seg)
    /* No .debug_line segment, no work to do.  */
    return;
d1034 2
a1035 2
  saved_seg = now_seg;
  saved_subseg = now_subseg;
d1037 33
a1069 44
  if (!ls.sm.empty_sequence)
    out_end_sequence ();
  subseg_set (ls.line_seg, DL_BODY);
  total_size = body_size = now_subseg_size ();

  /* Now generate the directory and file lists.  */
  subseg_set (ls.line_seg, DL_FILES);
  gen_dir_list ();
  gen_file_list ();
  total_size += now_subseg_size ();

  /* And now the header ("statement program prolog", in DWARF2 lingo...).  */
  subseg_set (ls.line_seg, DL_PROLOG);

  cp = frag_more (15 + DWARF2_LINE_OPCODE_BASE - 1);

  total_size += now_subseg_size ();
  prolog_size = total_size - body_size - 10;

#define STUFF(val,size)				\
      do {					\
	md_number_to_chars (cp, val, size);	\
	cp += size;				\
      } while (0)

  STUFF (total_size - 4, 4);	/* length */
  STUFF (2, 2);			/* version */
  STUFF (prolog_size, 4);	/* prologue_length */
  STUFF (DWARF2_LINE_MIN_INSN_LENGTH, 1);
  STUFF (DWARF2_LINE_DEFAULT_IS_STMT, 1);
  STUFF (DWARF2_LINE_BASE, 1);
  STUFF (DWARF2_LINE_RANGE, 1);
  STUFF (DWARF2_LINE_OPCODE_BASE, 1);

  /* standard_opcode_lengths: */
  STUFF (0, 1);			/* DW_LNS_copy */
  STUFF (1, 1);			/* DW_LNS_advance_pc */
  STUFF (1, 1);			/* DW_LNS_advance_line */
  STUFF (1, 1);			/* DW_LNS_set_file */
  STUFF (1, 1);			/* DW_LNS_set_column */
  STUFF (0, 1);			/* DW_LNS_negate_stmt */
  STUFF (0, 1);			/* DW_LNS_set_basic_block */
  STUFF (0, 1);			/* DW_LNS_const_add_pc */
  STUFF (1, 1);			/* DW_LNS_fixed_advance_pc */
d1071 2
a1072 1
#undef STUFF
d1074 5
a1078 7
  /* If this is assembler generated line info, add a .debug_info
     section as well.  */
  if (debug_type == DEBUG_DWARF2)
    {
      segT info_seg = subseg_new (".debug_info", 0);
      segT abbrev_seg = subseg_new (".debug_abbrev", 0);
      char *len;
d1080 14
a1093 4
#ifdef BFD_ASSEMBLER
      bfd_set_section_flags (stdoutput, info_seg, SEC_READONLY);
      bfd_set_section_flags (stdoutput, abbrev_seg, SEC_READONLY);
#endif
d1095 1
a1095 2
      subseg_set (info_seg, 0);
      len = frag_more (4);
d1097 13
a1109 5
#define STUFF(val, size)			\
      do {					\
	cp = frag_more (size);			\
	md_number_to_chars (cp, (val), (size));	\
      } while(0)
d1111 1
a1111 2
      STUFF (2, 2);             /* Dwarf version */
      STUFF (0, 4);		/* Offset into (final!) .debug_abbrev.  */
d1113 2
a1114 6
      /* Pointer size.  */
#ifdef BFD_ASSEMBLER
      STUFF (bfd_arch_bits_per_address (stdoutput) / 8, 1);
#else
      STUFF (4, 1);
#endif
d1116 6
a1121 2
      /* FIXME: Add a DW_TAG_compile_unit DIE.  The line info cannot
	 even be seen without it.  */
d1123 2
a1124 3
      /* Set size of debug_info.  */
      md_number_to_chars (len, now_subseg_size () - 4, 4);
    }
d1126 5
a1130 1
  subseg_set (saved_seg, saved_subseg);
d1132 2
a1133 3
  if (flag_debug)
    print_stats (total_size);
}
d1135 2
a1136 5
void
dwarf2_directive_file (dummy)
     int dummy ATTRIBUTE_UNUSED;
{
  int len;
d1138 5
a1142 9
  /* Continue to accept a bare string and pass it off.  */
  SKIP_WHITESPACE ();
  if (*input_line_pointer == '"')
    {
      s_app_file (0);
      return;
    }

  ls.any_dwarf2_directives = 1;
d1144 32
a1175 2
  ls.current.filenum = get_absolute_expression ();
  ls.current.filename = demand_copy_C_string (&len);
d1177 1
a1177 1
  demand_empty_rest_of_line ();
d1181 1
a1181 2
dwarf2_directive_loc (dummy)
     int dummy ATTRIBUTE_UNUSED;
d1183 2
a1184 1
  ls.any_dwarf2_directives = 1;
d1186 3
a1188 6
  ls.current.filenum = get_absolute_expression ();
  SKIP_WHITESPACE ();
  ls.current.line = get_absolute_expression ();
  SKIP_WHITESPACE ();
  ls.current.column = get_absolute_expression ();
  demand_empty_rest_of_line ();
d1190 7
a1196 1
  ls.current.flags = DWARF2_FLAG_BEGIN_STMT;
d1198 4
a1201 3
#ifndef NO_LISTING
  if (listing)
    listing_source_line (ls.current.line);
a1202 1
}
d1204 2
a1205 5
void
dwarf2_where (line)
     struct dwarf2_line_info *line;
{
  if (debug_type == DEBUG_DWARF2)
d1207 8
a1214 4
      as_where (&line->filename, &line->line);
      line->filenum = 0;
      line->column = 0;
      line->flags = DWARF2_FLAG_BEGIN_STMT;
a1215 3
  else
    *line = ls.current;
}
d1217 1
a1217 4
/* Called for each machine instruction, or relatively atomic group of
   machine instructions (ie built-in macro).  The instruction or group
   is SIZE bytes in length.  If dwarf2 line number generation is called
   for, emit a line statement appropriately.  */
d1219 11
a1229 6
void
dwarf2_emit_insn (size)
     int size;
{
  addressT addr;
  struct dwarf2_line_info debug_line;
d1231 5
a1235 2
  if (debug_type != DEBUG_DWARF2 && ! ls.any_dwarf2_directives)
    return;
d1237 1
a1237 6
  /* Reset any_dwarf2_directives so that we won't waste time 
     determining that no information has changed between insns.  */
  ls.any_dwarf2_directives = 0;
     
  /* First update the notion of the current source line.  */
  dwarf2_where (&debug_line);
d1239 4
a1242 6
  /* We want the offset of the start of this
     instruction within the the current frag.  */
  addr = frag_now_fix () - size;

  /* And record the information.  */
  dwarf2_gen_line_info (addr, &debug_line);
@


1.20
log
@	* as.c (debug_type): Init to DEBUG_UNSPECIFIED.
	* as.h (debug_type): Clarify documentation of the meaning
	of this variable.
	* dwarf2dbg.c (DWARF2_LINE_MIN_INSN_LENGTH): Default to 1.
	(print_stats): Fix parenthesis problem.
	(now_subseg_size): New.
	(dwarf2_finish): Use it.  If DEBUG_DWARF2, emit bits for .debug_info.
	(dwarf2_directive_file): Don't set debug_type.
	(dwarf2_where): Honor DEBUG_DWARF2 first.
	(dwarf2_emit_insn): Renamed from dwarf2_generate_asm_lineno;
	do nothing if not emitting dwarf2 debug info, or no work.
	* dwarf2dbg.h (dwarf2_emit_insn): Update.
	* ecoff.c (add_file): Turn on DEBUG_ECOFF only if DEBUG_UNSPECIFIED.
	(ecoff_new_file): Likewise.
	* read.c (generate_lineno_debug): Kill ecoff hackery.  Update
	commentary wrt dwarf2.

	* config/tc-alpha.c (alpha_adjust_symtab_relocs): Add
	ATTRIBUTE_UNUSED as needed.
	(emit_insn): Call dwarf2_emit_insn.
	(s_alpha_file): New.
	(s_alpha_loc): New.
	(s_alpha_coff_wrapper): Don't handle them.
	(md_pseudo_table): Update for .file and .loc.
	* config/tc-alpha.h (DWARF2_LINE_MIN_INSN_LENGTH): New.

	* config/tc-arm.c (output_inst): Update for dwarf2_emit_insn;
	don't protect with debug_type.
	* config/tc-hppa.c (md_assemble): Likewise.
	* config/tc-m68hc11.c (m68hc11_new_insn): Likewise.
	* config/tc-mn10300.c (md_assemble): Likewise.
	* config/tc-sh.c (md_assemble): Likewise.
	* config/tc-v850.c (md_assemble): Likewise.

	* config/tc-arm.c (arm_end_of_source): Remove.
	* config/tc-hppa.c (pa_end_of_source): Remove.
	* config/tc-m68hc11.c (m68hc11_end_of_source): Remove.
	* config/tc-mn10300.c (mn10300_finalize): Remove.
	* config/tc-sh.c (sh_finalize): Remove.
	* config/tc-v850.c (sh_finalize): Remove.

	* config/tc-arm.h (md_end): Remove.
	* config/tc-hppa.h (md_end): Remove.
	(DWARF2_LINE_MIN_INSN_LENGTH): New.
	* config/tc-m68hc11.h (md_end): Remove.
	* config/tc-mn10300.h (md_end): Remove.
	* config/tc-sh.h (md_end): Remove.
	* config/tc-v850.h (md_end): Remove.

	* config/tc-ia64.c (emit_one_bundle): Don't protect
	dwarf2 bits with debug_type.
	(md_assemble): Likewise.
	(ia64_end_of_source): Don't call dwarf2_finish.
@
text
@d447 4
@


1.19
log
@2000-11-12  H.J. Lu  (hjl@@gnu.org)

	* dwarf2dbg.c (dwarf2_generate_asm_lineno): Use addressT
	instead of bfd_vma for non-bfd assemblers.
@
text
@d66 1
a66 1
# define DWARF2_LINE_MIN_INSN_LENGTH	4
d181 1
d647 2
a648 2
		 ((unsigned int)
		  DWARF2_LINE_MIN_INSN_LENGTH * SPECIAL_ADDR (i)));
d654 16
d687 2
a688 1
  total_size = body_size = frag_now_fix ();
d694 1
a694 1
  total_size += frag_now_fix ();
d701 1
a701 1
  total_size += frag_now_fix ();
d704 6
a709 1
# define STUFF(val,size)	md_number_to_chars (cp, val, size); cp += size;
d730 41
a792 5
  if (debug_type == DEBUG_NONE)
    /* Automatically turn on DWARF2 debug info unless something else
       has been selected.  */
    debug_type = DEBUG_DWARF2;

d824 1
a824 3
  if (ls.any_dwarf2_directives)
    *line = ls.current;
  else
d831 2
d835 4
a838 2
/* Generate a DWARF2 line statement for an
   instruction of SIZE bytes in length.  */
d841 1
a841 1
dwarf2_generate_asm_lineno (size)
d845 4
a848 1
  static struct dwarf2_line_info debug_line;
d850 4
d859 1
a859 1
  addr = frag_now->fr_address + frag_now_fix () - size;
@


1.18
log
@2000-11-06  Kazu Hirata  <kazu@@hxi.com>

	* as.c: Fix formatting.
	* dwarf2dbg.c: Likewise.
	* itbl-ops.c: Likewise.
	* listing.c: Likewise.
	* macro.h: Likewise.
	* messages.c: Likewise.
	* read.c: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* write.c: Likewise.
@
text
@d783 1
a783 1
  bfd_vma addr;
@


1.17
log
@Add --gdwarf2 support to ARM toolchain
@
text
@d785 1
a785 1
  
d787 2
a788 2
  dwarf2_where (& debug_line);
  
d792 1
a792 1
  
d794 1
a794 1
  dwarf2_gen_line_info (addr, & debug_line);
a795 1

@


1.16
log
@2000-10-17  Kazu Hirata  <kazu@@hxi.com>

	* debug.c: Fix formatting.
	* depend.c: Likewise.
	* dwarf2dbg.c: Likewise.
	* dwarf2dbg.h: Likewise.
	* ecoff.c: Likewise.
	* expr.c: Likewise.
	* expr.h: Likewise.
	* flonum-konst.c: Likewise.
	* frags.h: Likewise.
@
text
@d775 22
@


1.15
log
@2000-08-17  Kazu Hirata  <kazu@@hxi.com>

	* dwarf2dbg.c: Fix formatting.
@
text
@d102 1
a102 2
static struct
  {
d104 1
a104 2
    struct dwarf2_sm
      {
d113 1
a113 2
      }
    sm;
d125 1
a125 2
    struct
      {
d128 1
a128 2
      }
    *file;
d135 1
a135 3
  }
ls =
  {
d168 1
a168 1
  };
d248 1
a248 1
  opcode = tmp + addr_delta*DWARF2_LINE_RANGE;
d613 5
a617 6
  static const char *opc_name[] =
    {
      "extended", "copy", "advance_pc", "advance_line", "set_file",
      "set_column", "negate_stmt", "set_basic_block", "const_add_pc",
      "fixed_advance_pc"
    };
@


1.14
log
@	From Brad Lucier <lucier@@math.purdue.edu>:
	* dwarf2dbg.c (print_stats): Add cast to force printf argument to
	match format.
@
text
@d135 1
a135 1
    struct dwarf2_line_info current;	/* current source info: */
d137 1
a137 1
    /* counters for statistical purposes: */
d177 1
a177 2

/* Function prototypes: */
a188 1

d193 1
d212 1
d234 1
d254 1
a254 1
  /* try using a special opcode: */
d262 2
a263 2
  /* try using DW_LNS_const_add_pc followed by special op: */
  opcode = tmp + (addr_delta - MAX_SPECIAL_ADDR_DELTA)*DWARF2_LINE_RANGE;
d275 2
a276 1
    out_opcode (tmp);		/* output line-delta */
d278 2
a279 1
    out_opcode (DW_LNS_copy);	/* append new row with current info */
d290 2
a291 1
/* Set an absolute address (may results in a relocation entry): */
d329 1
d359 1
a359 1
		 the debugger the end of the sequence.*/
d379 1
d398 1
a398 1
  /* no match, fall back to simple linear scan: */
d409 1
a409 1
  /* no match: enter new filename */
d450 2
a451 1
    return;	/* no filename, no filnum => no play */
d473 1
a473 1
        symbol_set_bfdsym (secsym, ls.line_seg->symbol);
d475 1
a475 1
        symbol_table_insert (section_symbol (ls.line_seg));
d485 2
a486 1
	  out_end_sequence ();		/* terminate previous sequence */
d579 1
a579 1
	      /* didn't find this directory: append it to the list */
d589 3
a591 1
  out_byte ('\0');	/* terminate directory list */
d611 3
a613 1
  out_byte (0);		/* terminate filename list */
d634 1
a634 1
  for (i = 0; i < sizeof (opc_name)/sizeof (opc_name[0]); ++i)
d670 1
a670 1
    /* no .debug_line segment, no work to do... */
d680 1
a680 1
  /* now generate the directory and file lists: */
d686 1
a686 1
  /* and now the header ("statement program prolog", in DWARF2 lingo...) */
@


1.13
log
@Apply Jim Wilson's patch to track current frag for line number changes.
@
text
@d2 1
a2 1
   Copyright (C) 1999 Free Software Foundation, Inc.
d642 2
a643 1
		 DWARF2_LINE_MIN_INSN_LENGTH*SPECIAL_ADDR (i));
@


1.12
log
@This makes the line number info for the end of a function match what the
standard specifies.  The current code could confuse a debugger.
@
text
@d81 1
a81 1
/* Given a special op, return the line skip amount: */
d89 1
a89 1
/* The maximum address skip amont that can be encoded with a special op: */
d93 1
a93 1
  /* initialize as per DWARF2.0 standard: */			\
d121 1
d153 1
d329 1
d339 1
d341 1
a341 1
      if (addr < ls.sm.addr)
d345 1
d415 3
d427 1
d450 1
d486 1
d520 1
a520 1
      if (addr < ls.sm.addr)
d522 4
a525 8
	  /* This happens when a new frag got allocated (for whatever
	     reason).  Deal with it by generating a reference symbol.
	     Note: no end_sequence needs to be generated because the
	     address did not really decrease (only the reference point
	     changed).

	     ??? Perhaps we should directly check for a change of
	     frag_now instead?  */
d528 1
@


1.11
log
@Applied patch from Jim Wilson to fix several bugs in line table generation.
@
text
@d344 1
a344 1
	  delta = addr - ls.sm.addr;
d346 7
a352 1
	    gen_addr_line (0, delta / DWARF2_LINE_MIN_INSN_LENGTH);
@


1.10
log
@	* dwarf2dbg.c (dwarf2_gen_line_info): Don't assume that long long
	or %llx work.
@
text
@d362 1
a362 1
   filetable the filenumber for the new entry is returned.  */
d371 3
a373 1
  if (last >= ls.num_filenames)
d376 1
a376 1
  /* do a quick check against the previously used filename: */
d400 1
d431 5
a455 2
  saved_seg = now_seg;
  saved_subseg = now_subseg;
@


1.9
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Fill in structure initializations.  Add variable
	initializations.  Add casts.
	* dwarf2dbg.c (print_stats): Change i to size_t.
	* listing.c (listing_listing): Change list_line to unsigned int.
@
text
@d412 2
a413 2
    fprintf (stderr, "line: addr %llx file `%s' line %u col %u flags %x\n",
	     (long long) addr, l->filename, l->line, l->column, l->flags);
@


1.8
log
@David Mosberger  <davidm@@hpl.hp.com>
        * dwarf2dbg.c (dwarf2_gen_line_info): Don't call
        out_end_sequence() when the address decreases due to a new frag.
        (gen_dir_list): Set ls.file[i].dir to j + 1 (not j) because file
        numbering starts with 1.
@
text
@d145 28
d371 1
a371 1
  if ((unsigned) last >= ls.num_filenames)
d417 1
a417 1
      if (filenum >= ls.num_filenames)
d594 2
a595 1
  int i, j;
d690 1
a690 1
     int dummy;
d717 1
a717 1
     int dummy;
@


1.7
log
@	* dwarf2dbg.c: Include elf/dwarf2.h with "", not <>.
	* Makefile.am: Rebuild dependencies.
	* Makefile.in: Rebuild.
@
text
@d471 8
a478 5
	  if (!ls.sm.empty_sequence)
	    {
	      out_end_sequence ();
	      ls.sm.empty_sequence = 1;
	    }
d516 1
a516 1
		  ls.file[i].dir = j;
@


1.6
log
@fix copyrights
@
text
@d36 1
a36 1
#include <elf/dwarf2.h>
@


1.5
log
@	* dwarf2dbg.c: Change bfd_vma to addressT and bfd_signed_vma to
	offsetT.
	(out_set_addr): Don't use BYTES_PER_ADDRESS.  Instead, get the
	value from the output file architecture.
	(dwarf2_gen_line_info): Ifdef BFD_ASSEMBLER specific code.
	* dwarf2dbg.h: Change bfd_vma to addressT.
@
text
@d2 1
a2 1
   Copyright (C) 1999 Hewlett-Packard Co
d20 1
a20 1
   02111-1307, USA.
d22 1
a22 1
   Logical line numbers can be controlled by the compiler via the
@


1.4
log
@        * dwarf2dbg.c (dwarf2_gen_line_info): Mirror the section symbol
        creation logic from obj_elf_create_section.
        * config/obj-elf.c (elf_pseudo_tab): Add pushsection/popsection.
        (section_stack): New.
        (special_sections): Make const.
        (obj_elf_section): Gut and rewrite parsing.
        (obj_elf_change_section): New function broken out of obj_elf_section.
        (obj_elf_parse_section_letters): Likewise.
        (obj_elf_section_word): Likewise.
        (obj_elf_section_type): Likewise.
        (obj_elf_previous): Treat as a toggle.
        (obj_elf_popsection): New.
        * config/tc-ppc.c (ppc_section_word): Take str+len not ptr_str.
        (ppc_section_type): Likewise.
        * config/tc-ppc.h: Likewise.
        * expr.h (struct expressionS): Don't make X_op a bitfield.
        * config/tc-alpha.c: Update for symbol handling changes.
        (md_apply_fix) [case GPREL]: Use now_seg instead of absolute_section.
        (load_expression, emit_ir_load, emit_loadstore, emit_jsrjmp): Likewise.
@
text
@a37 2
#define BYTES_PER_ADDRESS	(BFD_ARCH_SIZE / 8)

d107 1
a107 1
	bfd_vma addr;
d149 3
a151 3
static void out_uleb128 PARAMS ((bfd_vma));
static void out_sleb128 PARAMS ((bfd_signed_vma));
static void gen_addr_line PARAMS ((int, bfd_vma));
d153 1
a153 1
static void out_set_addr PARAMS ((bfd_vma));
d167 1
a167 1
     bfd_vma value;
d185 1
a185 1
     bfd_signed_vma value;
d207 1
a207 1
     bfd_vma addr_delta;
d260 1
a260 1
     bfd_vma addr;
d266 1
d276 7
d284 1
a284 1
  out_uleb128 (BYTES_PER_ADDRESS + 1);
d290 1
a290 1
  emit_expr (&expr, BYTES_PER_ADDRESS);
d298 1
a298 1
  bfd_vma addr, delta;
d375 1
a375 1
     bfd_vma addr;
d402 1
d404 1
d407 2
d417 1
d599 1
a599 1
  bfd_vma body_size, total_size, prolog_size;
@


1.3
log
@        * dwarf2dbg.c (*): Convert to K&R + prototypes.
        (dwarf2_gen_line_info): Kill unused variables.
        (dwarf2_finish): Likewise.
        (dwarf2_where): Likewise.
        (dwarf2_directive_file): If we've only got a string,
        hand off to s_app_file.
        * ecoff.c: Move the include of ecoff.h.
        * symbols.h (S_IS_FUNCTION): Prototype.
        * read.c (LEX_HASH): Supply a default.
        (lex_type): Use it.
        (s_globl): Update `c' after skipping whitespace.
        * read.h (LEX_END_NAME, is_name_ender): New.
        * expr.c (get_symbol_end): Respect it.
@
text
@d396 2
d402 5
a406 1
      (void) section_symbol (ls.line_seg);
@


1.2
log
@        * dwarf2dbg.c (dwarf2_gen_line_info): Use section_symbol
        instead of doing the work by hand.
@
text
@d149 14
d168 2
a169 1
out_uleb128 (bfd_vma value)
d186 2
a187 1
out_sleb128 (bfd_signed_vma value)
d207 3
a209 1
gen_addr_line (int line_delta, bfd_vma addr_delta)
d252 1
a252 1
reset_state_machine (void)
d261 2
a262 1
out_set_addr (bfd_vma addr)
d290 1
a290 1
out_end_sequence (void)
d330 3
a332 1
get_filenum (int filenum, char *file)
d368 3
a370 1
dwarf2_gen_line_info (bfd_vma addr, struct dwarf2_line_info *l)
a375 1
  char *frag;
d378 1
a378 1
    fprintf (stderr, "line: addr %llx file `%s' line %u col %u flags %lx\n",
d477 1
a477 1
gen_dir_list (void)
d517 1
a517 1
gen_file_list (void)
d536 3
a538 2
void
print_stats (unsigned long total_size)
d580 1
a580 1
dwarf2_finish (void)
d582 2
a583 2
  bfd_vma addr, body_size, total_size, prolog_size;
  subsegT saved_subseg, line_prolog;
d640 2
a641 1
dwarf2_directive_file (int dummy)
d645 8
d667 2
a668 1
dwarf2_directive_loc (int dummy)
d688 2
a689 1
dwarf2_where (struct dwarf2_line_info *line)
a694 2
      char *filename;

@


1.1
log
@        * as.c (parse_args): Add option -gdwarf2 to allow requesting
        DWARF2 debug info (line information only, at this point).
        * as.h: Update comment about supported debug formats.
        * dwarf2dbg.c, dwarf2dbg.h: New files.
        * Makefile.am (GAS_CFILES, HFILES, GENERIC_OBJS): Add them.
@
text
@d374 2
a375 1
      symbolS *secsym;
d377 2
a378 7
      ls.line_seg = subseg_get (".debug_line", DL_BODY);
      bfd_set_section_flags (stdoutput, ls.line_seg, SEC_READONLY);
      secsym = symbol_find (".debug_line");
      if (secsym)
	secsym->bsym = ls.line_seg->symbol;
      else
	symbol_table_insert (section_symbol (ls.line_seg));
@

