head	1.57;
access;
symbols
	binutils-2_24-branch:1.57.0.2
	binutils-2_24-branchpoint:1.57
	binutils-2_21_1:1.54
	binutils-2_23_2:1.56.2.1
	binutils-2_23_1:1.56
	binutils-2_23:1.56
	binutils-2_23-branch:1.56.0.2
	binutils-2_23-branchpoint:1.56
	binutils-2_22_branch:1.55.0.4
	binutils-2_22:1.55
	binutils-2_22-branch:1.55.0.2
	binutils-2_22-branchpoint:1.55
	binutils-2_21:1.54
	binutils-2_21-branch:1.54.0.2
	binutils-2_21-branchpoint:1.54
	binutils-2_20_1:1.48.8.1
	binutils-2_20:1.48.8.1
	binutils-arc-20081103-branch:1.48.0.10
	binutils-arc-20081103-branchpoint:1.48
	binutils-2_20-branch:1.48.0.8
	binutils-2_20-branchpoint:1.48
	dje-cgen-play1-branch:1.48.0.6
	dje-cgen-play1-branchpoint:1.48
	arc-20081103-branch:1.48.0.4
	arc-20081103-branchpoint:1.48
	binutils-2_19_1:1.48
	binutils-2_19:1.48
	binutils-2_19-branch:1.48.0.2
	binutils-2_19-branchpoint:1.48
	binutils-2_18:1.46
	binutils-2_18-branch:1.46.0.2
	binutils-2_18-branchpoint:1.46
	binutils-csl-coldfire-4_1-32:1.42
	binutils-csl-sourcerygxx-4_1-32:1.42
	binutils-csl-innovasic-fido-3_4_4-33:1.42
	binutils-csl-sourcerygxx-3_4_4-32:1.29
	binutils-csl-coldfire-4_1-30:1.42
	binutils-csl-sourcerygxx-4_1-30:1.42
	binutils-csl-coldfire-4_1-28:1.42
	binutils-csl-sourcerygxx-4_1-29:1.42
	binutils-csl-sourcerygxx-4_1-28:1.42
	binutils-csl-arm-2006q3-27:1.42
	binutils-csl-sourcerygxx-4_1-27:1.42
	binutils-csl-arm-2006q3-26:1.42
	binutils-csl-sourcerygxx-4_1-26:1.42
	binutils-csl-sourcerygxx-4_1-25:1.42
	binutils-csl-sourcerygxx-4_1-24:1.42
	binutils-csl-sourcerygxx-4_1-23:1.42
	binutils-csl-sourcerygxx-4_1-21:1.42
	binutils-csl-arm-2006q3-21:1.42
	binutils-csl-sourcerygxx-4_1-22:1.42
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.42
	binutils-csl-sourcerygxx-4_1-20:1.42
	binutils-csl-arm-2006q3-19:1.42
	binutils-csl-sourcerygxx-4_1-19:1.42
	binutils-csl-sourcerygxx-4_1-18:1.42
	binutils-csl-renesas-4_1-9:1.42
	binutils-csl-sourcerygxx-3_4_4-25:1.29
	binutils-csl-renesas-4_1-8:1.42
	binutils-csl-renesas-4_1-7:1.42
	binutils-csl-renesas-4_1-6:1.42
	binutils-csl-sourcerygxx-4_1-17:1.42
	binutils-csl-sourcerygxx-4_1-14:1.42
	binutils-csl-sourcerygxx-4_1-15:1.42
	binutils-csl-sourcerygxx-4_1-13:1.42
	binutils-2_17:1.42
	binutils-csl-sourcerygxx-4_1-12:1.42
	binutils-csl-sourcerygxx-3_4_4-21:1.42
	binutils-csl-wrs-linux-3_4_4-24:1.29
	binutils-csl-wrs-linux-3_4_4-23:1.29
	binutils-csl-sourcerygxx-4_1-9:1.42
	binutils-csl-sourcerygxx-4_1-8:1.42
	binutils-csl-sourcerygxx-4_1-7:1.42
	binutils-csl-arm-2006q1-6:1.42
	binutils-csl-sourcerygxx-4_1-6:1.42
	binutils-csl-wrs-linux-3_4_4-22:1.29
	binutils-csl-coldfire-4_1-11:1.42
	binutils-csl-sourcerygxx-3_4_4-19:1.42
	binutils-csl-coldfire-4_1-10:1.42
	binutils-csl-sourcerygxx-4_1-5:1.42
	binutils-csl-sourcerygxx-4_1-4:1.42
	binutils-csl-wrs-linux-3_4_4-21:1.29
	binutils-csl-morpho-4_1-4:1.42
	binutils-csl-sourcerygxx-3_4_4-17:1.42
	binutils-csl-wrs-linux-3_4_4-20:1.29
	binutils-2_17-branch:1.42.0.4
	binutils-2_17-branchpoint:1.42
	binutils-csl-2_17-branch:1.42.0.2
	binutils-csl-2_17-branchpoint:1.42
	binutils-csl-gxxpro-3_4-branch:1.29.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.29
	binutils-2_16_1:1.29
	binutils-csl-arm-2005q1b:1.29
	binutils-2_16:1.29
	binutils-csl-arm-2005q1a:1.29
	binutils-csl-arm-2005q1-branch:1.29.0.4
	binutils-csl-arm-2005q1-branchpoint:1.29
	binutils-2_16-branch:1.29.0.2
	binutils-2_16-branchpoint:1.29
	csl-arm-2004-q3d:1.26
	csl-arm-2004-q3:1.25
	binutils-2_15:1.23
	binutils-2_15-branchpoint:1.23
	csl-arm-2004-q1a:1.23
	csl-arm-2004-q1:1.23
	binutils-2_15-branch:1.23.0.6
	cagney_bfdfile-20040213-branch:1.23.0.4
	cagney_bfdfile-20040213-branchpoint:1.23
	cagney_bigcore-20040122-branch:1.23.0.2
	cagney_bigcore-20040122-branchpoint:1.23
	csl-arm-2003-q4:1.23
	binutils-2_14:1.21.2.1
	binutils-2_14-branch:1.21.0.2
	binutils-2_14-branchpoint:1.21
	binutils-2_13_2_1:1.17
	binutils-2_13_2:1.17
	binutils-2_13_1:1.17
	binutils-2_13:1.17
	binutils-2_13-branchpoint:1.17
	binutils-2_13-branch:1.17.0.2
	binutils-2_12_1:1.16
	binutils-2_12:1.16
	binutils-2_12-branch:1.16.0.2
	binutils-2_12-branchpoint:1.16
	cygnus_cvs_20020108_pre:1.15
	binutils-2_11_2:1.11.2.1
	binutils-2_11_1:1.11.2.1
	binutils-2_11:1.11
	x86_64versiong3:1.11
	binutils-2_11-branch:1.11.0.2
	binutils-2_10_1:1.6
	binutils-2_10:1.6
	binutils-2_10-branch:1.6.0.2
	binutils-2_10-branchpoint:1.6
	binutils_latest_snapshot:1.57
	repo-unification-2000-02-06:1.5
	binu_ss_19990721:1.2
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.57
date	2013.01.10.17.11.17;	author roland;	state Exp;
branches;
next	1.56;

1.56
date	2012.06.07.12.47.23;	author amodra;	state Exp;
branches
	1.56.2.1;
next	1.55;

1.55
date	2011.03.30.15.10.37;	author nickc;	state Exp;
branches;
next	1.54;

1.54
date	2010.08.18.05.56.41;	author amodra;	state Exp;
branches;
next	1.53;

1.53
date	2010.07.23.06.44.25;	author amodra;	state Exp;
branches;
next	1.52;

1.52
date	2010.04.20.15.54.48;	author nickc;	state Exp;
branches;
next	1.51;

1.51
date	2009.12.11.13.42.09;	author nickc;	state Exp;
branches;
next	1.50;

1.50
date	2009.10.15.10.58.34;	author amodra;	state Exp;
branches;
next	1.49;

1.49
date	2009.09.11.15.27.33;	author nickc;	state Exp;
branches;
next	1.48;

1.48
date	2008.08.12.23.39.30;	author amodra;	state Exp;
branches
	1.48.8.1;
next	1.47;

1.47
date	2008.08.11.07.40.22;	author amodra;	state Exp;
branches;
next	1.46;

1.46
date	2007.07.03.11.01.03;	author nickc;	state Exp;
branches;
next	1.45;

1.45
date	2007.01.12.10.57.02;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	2006.06.07.11.27.57;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2006.05.01.09.21.46;	author bje;	state Exp;
branches;
next	1.42;

1.42
date	2006.02.28.07.57.09;	author jbeulich;	state Exp;
branches;
next	1.41;

1.41
date	2006.02.28.07.55.36;	author jbeulich;	state Exp;
branches;
next	1.40;

1.40
date	2005.11.07.01.47.54;	author amodra;	state Exp;
branches;
next	1.39;

1.39
date	2005.08.09.15.47.46;	author nickc;	state Exp;
branches;
next	1.38;

1.38
date	2005.08.08.11.15.33;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	2005.05.10.07.48.24;	author jbeulich;	state Exp;
branches;
next	1.36;

1.36
date	2005.05.06.06.50.29;	author jbeulich;	state Exp;
branches;
next	1.35;

1.35
date	2005.05.05.09.12.46;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	2005.05.03.12.02.46;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	2005.04.29.00.22.26;	author bje;	state Exp;
branches;
next	1.32;

1.32
date	2005.04.25.06.43.45;	author jbeulich;	state Exp;
branches;
next	1.31;

1.31
date	2005.04.18.13.35.44;	author jbeulich;	state Exp;
branches;
next	1.30;

1.30
date	2005.04.11.12.46.35;	author jbeulich;	state Exp;
branches;
next	1.29;

1.29
date	2005.03.03.01.29.53;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2005.01.31.14.30.33;	author jbeulich;	state Exp;
branches;
next	1.27;

1.27
date	2005.01.31.14.26.08;	author jbeulich;	state Exp;
branches;
next	1.26;

1.26
date	2004.10.07.15.16.08;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2004.08.16.08.34.28;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2004.08.13.19.53.51;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2003.11.24.17.52.33;	author kazu;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.02.15.03.20;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2003.03.13.11.49.33;	author nickc;	state Exp;
branches
	1.21.2.1;
next	1.20;

1.20
date	2003.01.03.21.47.20;	author scox;	state Exp;
branches;
next	1.19;

1.19
date	2002.12.02.15.42.08;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2002.11.11.08.42.52;	author hp;	state Exp;
branches;
next	1.17;

1.17
date	2002.05.03.02.25.33;	author kazu;	state Exp;
branches;
next	1.16;

1.16
date	2002.01.17.11.28.49;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2001.09.19.05.33.19;	author hjl;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.10.02.49.27;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2001.06.12.10.35.20;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.08.23.24.22;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2000.12.12.19.28.12;	author nickc;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2000.08.31.18.36.18;	author kazu;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.25.17.59.21;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2000.06.14.04.58.50;	author ulfc;	state Exp;
branches;
next	1.7;

1.7
date	2000.05.01.14.01.06;	author clm;	state Exp;
branches;
next	1.6;

1.6
date	2000.03.26.14.47.33;	author twall;	state Exp;
branches;
next	1.5;

1.5
date	99.11.12.15.39.46;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	99.11.12.11.02.56;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	99.11.11.16.35.12;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	99.06.03.00.23.27;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.41;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.56.2.1
date	2013.01.10.17.13.05;	author roland;	state Exp;
branches;
next	;

1.48.8.1
date	2009.09.11.15.28.43;	author nickc;	state Exp;
branches;
next	;

1.21.2.1
date	2003.06.02.19.06.52;	author drow;	state Exp;
branches;
next	;

1.11.2.1
date	2001.06.07.03.15.25;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.41;	author rth;	state Exp;
branches;
next	;


desc
@@


1.57
log
@gas/
	* hash.c (hash_new_sized): Make it global.
	* hash.h: Declare it.
	* macro.c (define_macro): Use hash_new_sized instead of hash_new,
	pass a small size.
@
text
@/* macro.c - macro support for gas
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003,
   2004, 2005, 2006, 2007, 2008, 2011, 2012, 2013 Free Software Foundation, Inc.

   Written by Steve and Judy Chamberlain of Cygnus Support,
      sac@@cygnus.com

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include "as.h"
#include "safe-ctype.h"
#include "sb.h"
#include "macro.h"

/* The routines in this file handle macro definition and expansion.
   They are called by gas.  */

#define ISWHITE(x) ((x) == ' ' || (x) == '\t')

#define ISSEP(x) \
 ((x) == ' ' || (x) == '\t' || (x) == ',' || (x) == '"' || (x) == ';' \
  || (x) == ')' || (x) == '(' \
  || ((macro_alternate || macro_mri) && ((x) == '<' || (x) == '>')))

#define ISBASE(x) \
  ((x) == 'b' || (x) == 'B' \
   || (x) == 'q' || (x) == 'Q' \
   || (x) == 'h' || (x) == 'H' \
   || (x) == 'd' || (x) == 'D')

/* The macro hash table.  */

struct hash_control *macro_hash;

/* Whether any macros have been defined.  */

int macro_defined;

/* Whether we are in alternate syntax mode.  */

static int macro_alternate;

/* Whether we are in MRI mode.  */

static int macro_mri;

/* Whether we should strip '@@' characters.  */

static int macro_strip_at;

/* Function to use to parse an expression.  */

static size_t (*macro_expr) (const char *, size_t, sb *, offsetT *);

/* Number of macro expansions that have been done.  */

static int macro_number;

/* Initialize macro processing.  */

void
macro_init (int alternate, int mri, int strip_at,
	    size_t (*exp) (const char *, size_t, sb *, offsetT *))
{
  macro_hash = hash_new ();
  macro_defined = 0;
  macro_alternate = alternate;
  macro_mri = mri;
  macro_strip_at = strip_at;
  macro_expr = exp;
}

/* Switch in and out of alternate mode on the fly.  */

void
macro_set_alternate (int alternate)
{
  macro_alternate = alternate;
}

/* Switch in and out of MRI mode on the fly.  */

void
macro_mri_mode (int mri)
{
  macro_mri = mri;
}

/* Read input lines till we get to a TO string.
   Increase nesting depth if we get a FROM string.
   Put the results into sb at PTR.
   FROM may be NULL (or will be ignored) if TO is "ENDR".
   Add a new input line to an sb using GET_LINE.
   Return 1 on success, 0 on unexpected EOF.  */

int
buffer_and_nest (const char *from, const char *to, sb *ptr,
		 size_t (*get_line) (sb *))
{
  size_t from_len;
  size_t to_len = strlen (to);
  int depth = 1;
  size_t line_start = ptr->len;
  size_t more = get_line (ptr);

  if (to_len == 4 && strcasecmp (to, "ENDR") == 0)
    {
      from = NULL;
      from_len = 0;
    }
  else
    from_len = strlen (from);

  while (more)
    {
      /* Try to find the first pseudo op on the line.  */
      size_t i = line_start;
      bfd_boolean had_colon = FALSE;

      /* With normal syntax we can suck what we want till we get
	 to the dot.  With the alternate, labels have to start in
	 the first column, since we can't tell what's a label and
	 what's a pseudoop.  */

      if (! LABELS_WITHOUT_COLONS)
	{
	  /* Skip leading whitespace.  */
	  while (i < ptr->len && ISWHITE (ptr->ptr[i]))
	    i++;
	}

      for (;;)
	{
	  /* Skip over a label, if any.  */
	  if (i >= ptr->len || ! is_name_beginner (ptr->ptr[i]))
	    break;
	  i++;
	  while (i < ptr->len && is_part_of_name (ptr->ptr[i]))
	    i++;
	  if (i < ptr->len && is_name_ender (ptr->ptr[i]))
	    i++;
	  /* Skip whitespace.  */
	  while (i < ptr->len && ISWHITE (ptr->ptr[i]))
	    i++;
	  /* Check for the colon.  */
	  if (i >= ptr->len || ptr->ptr[i] != ':')
	    {
	      /* LABELS_WITHOUT_COLONS doesn't mean we cannot have a
		 colon after a label.  If we do have a colon on the
		 first label then handle more than one label on the
		 line, assuming that each label has a colon.  */
	      if (LABELS_WITHOUT_COLONS && !had_colon)
		break;
	      i = line_start;
	      break;
	    }
	  i++;
	  line_start = i;
	  had_colon = TRUE;
	}

      /* Skip trailing whitespace.  */
      while (i < ptr->len && ISWHITE (ptr->ptr[i]))
	i++;

      if (i < ptr->len && (ptr->ptr[i] == '.'
			   || NO_PSEUDO_DOT
			   || macro_mri))
	{
	  if (! flag_m68k_mri && ptr->ptr[i] == '.')
	    i++;
	  if (from == NULL
	     && strncasecmp (ptr->ptr + i, "IRPC", from_len = 4) != 0
	     && strncasecmp (ptr->ptr + i, "IRP", from_len = 3) != 0
	     && strncasecmp (ptr->ptr + i, "IREPC", from_len = 5) != 0
	     && strncasecmp (ptr->ptr + i, "IREP", from_len = 4) != 0
	     && strncasecmp (ptr->ptr + i, "REPT", from_len = 4) != 0
	     && strncasecmp (ptr->ptr + i, "REP", from_len = 3) != 0)
	    from_len = 0;
	  if ((from != NULL
	       ? strncasecmp (ptr->ptr + i, from, from_len) == 0
	       : from_len > 0)
	      && (ptr->len == (i + from_len)
		  || ! (is_part_of_name (ptr->ptr[i + from_len])
			|| is_name_ender (ptr->ptr[i + from_len]))))
	    depth++;
	  if (strncasecmp (ptr->ptr + i, to, to_len) == 0
	      && (ptr->len == (i + to_len)
		  || ! (is_part_of_name (ptr->ptr[i + to_len])
			|| is_name_ender (ptr->ptr[i + to_len]))))
	    {
	      depth--;
	      if (depth == 0)
		{
		  /* Reset the string to not include the ending rune.  */
		  ptr->len = line_start;
		  break;
		}
	    }
	}

      /* Add the original end-of-line char to the end and keep running.  */
      sb_add_char (ptr, more);
      line_start = ptr->len;
      more = get_line (ptr);
    }

  /* Return 1 on success, 0 on unexpected EOF.  */
  return depth == 0;
}

/* Pick up a token.  */

static size_t
get_token (size_t idx, sb *in, sb *name)
{
  if (idx < in->len
      && is_name_beginner (in->ptr[idx]))
    {
      sb_add_char (name, in->ptr[idx++]);
      while (idx < in->len
	     && is_part_of_name (in->ptr[idx]))
	{
	  sb_add_char (name, in->ptr[idx++]);
	}
      if (idx < in->len
	     && is_name_ender (in->ptr[idx]))
	{
	  sb_add_char (name, in->ptr[idx++]);
	}
    }
  /* Ignore trailing &.  */
  if (macro_alternate && idx < in->len && in->ptr[idx] == '&')
    idx++;
  return idx;
}

/* Pick up a string.  */

static size_t
getstring (size_t idx, sb *in, sb *acc)
{
  while (idx < in->len
	 && (in->ptr[idx] == '"'
	     || (in->ptr[idx] == '<' && (macro_alternate || macro_mri))
	     || (in->ptr[idx] == '\'' && macro_alternate)))
    {
      if (in->ptr[idx] == '<')
	{
	  int nest = 0;
	  idx++;
	  while ((in->ptr[idx] != '>' || nest)
		 && idx < in->len)
	    {
	      if (in->ptr[idx] == '!')
		{
		  idx++;
		  sb_add_char (acc, in->ptr[idx++]);
		}
	      else
		{
		  if (in->ptr[idx] == '>')
		    nest--;
		  if (in->ptr[idx] == '<')
		    nest++;
		  sb_add_char (acc, in->ptr[idx++]);
		}
	    }
	  idx++;
	}
      else if (in->ptr[idx] == '"' || in->ptr[idx] == '\'')
	{
	  char tchar = in->ptr[idx];
	  int escaped = 0;

	  idx++;

	  while (idx < in->len)
	    {
	      if (in->ptr[idx - 1] == '\\')
		escaped ^= 1;
	      else
		escaped = 0;

	      if (macro_alternate && in->ptr[idx] == '!')
		{
		  idx ++;

		  sb_add_char (acc, in->ptr[idx]);

		  idx ++;
		}
	      else if (escaped && in->ptr[idx] == tchar)
		{
		  sb_add_char (acc, tchar);
		  idx ++;
		}
	      else
		{
		  if (in->ptr[idx] == tchar)
		    {
		      idx ++;

		      if (idx >= in->len || in->ptr[idx] != tchar)
			break;
		    }

		  sb_add_char (acc, in->ptr[idx]);
		  idx ++;
		}
	    }
	}
    }

  return idx;
}

/* Fetch string from the input stream,
   rules:
    'Bxyx<whitespace>  	-> return 'Bxyza
    %<expr>		-> return string of decimal value of <expr>
    "string"		-> return string
    (string)		-> return (string-including-whitespaces)
    xyx<whitespace>     -> return xyz.  */

static size_t
get_any_string (size_t idx, sb *in, sb *out)
{
  sb_reset (out);
  idx = sb_skip_white (idx, in);

  if (idx < in->len)
    {
      if (in->len > idx + 2 && in->ptr[idx + 1] == '\'' && ISBASE (in->ptr[idx]))
	{
	  while (!ISSEP (in->ptr[idx]))
	    sb_add_char (out, in->ptr[idx++]);
	}
      else if (in->ptr[idx] == '%' && macro_alternate)
	{
	  offsetT val;
	  char buf[20];

	  /* Turns the next expression into a string.  */
	  /* xgettext: no-c-format */
	  idx = (*macro_expr) (_("% operator needs absolute expression"),
			       idx + 1,
			       in,
			       &val);
	  sprintf (buf, "%" BFD_VMA_FMT "d", val);
	  sb_add_string (out, buf);
	}
      else if (in->ptr[idx] == '"'
	       || (in->ptr[idx] == '<' && (macro_alternate || macro_mri))
	       || (macro_alternate && in->ptr[idx] == '\''))
	{
	  if (macro_alternate && ! macro_strip_at && in->ptr[idx] != '<')
	    {
	      /* Keep the quotes.  */
	      sb_add_char (out, '"');
	      idx = getstring (idx, in, out);
	      sb_add_char (out, '"');
	    }
	  else
	    {
	      idx = getstring (idx, in, out);
	    }
	}
      else
	{
	  char *br_buf = (char *) xmalloc (1);
	  char *in_br = br_buf;

	  *in_br = '\0';
	  while (idx < in->len
		 && (*in_br
		     || (in->ptr[idx] != ' '
			 && in->ptr[idx] != '\t'))
		 && in->ptr[idx] != ','
		 && (in->ptr[idx] != '<'
		     || (! macro_alternate && ! macro_mri)))
	    {
	      char tchar = in->ptr[idx];

	      switch (tchar)
		{
		case '"':
		case '\'':
		  sb_add_char (out, in->ptr[idx++]);
		  while (idx < in->len
			 && in->ptr[idx] != tchar)
		    sb_add_char (out, in->ptr[idx++]);
		  if (idx == in->len)
		    {
		      free (br_buf);
		      return idx;
		    }
		  break;
		case '(':
		case '[':
		  if (in_br > br_buf)
		    --in_br;
		  else
		    {
		      br_buf = (char *) xmalloc (strlen (in_br) + 2);
		      strcpy (br_buf + 1, in_br);
		      free (in_br);
		      in_br = br_buf;
		    }
		  *in_br = tchar;
		  break;
		case ')':
		  if (*in_br == '(')
		    ++in_br;
		  break;
		case ']':
		  if (*in_br == '[')
		    ++in_br;
		  break;
		}
	      sb_add_char (out, tchar);
	      ++idx;
	    }
	  free (br_buf);
	}
    }

  return idx;
}

/* Allocate a new formal.  */

static formal_entry *
new_formal (void)
{
  formal_entry *formal;

  formal = (formal_entry *) xmalloc (sizeof (formal_entry));

  sb_new (&formal->name);
  sb_new (&formal->def);
  sb_new (&formal->actual);
  formal->next = NULL;
  formal->type = FORMAL_OPTIONAL;
  return formal;
}

/* Free a formal.  */

static void
del_formal (formal_entry *formal)
{
  sb_kill (&formal->actual);
  sb_kill (&formal->def);
  sb_kill (&formal->name);
  free (formal);
}

/* Pick up the formal parameters of a macro definition.  */

static size_t
do_formals (macro_entry *macro, size_t idx, sb *in)
{
  formal_entry **p = &macro->formals;
  const char *name;

  idx = sb_skip_white (idx, in);
  while (idx < in->len)
    {
      formal_entry *formal = new_formal ();
      size_t cidx;

      idx = get_token (idx, in, &formal->name);
      if (formal->name.len == 0)
	{
	  if (macro->formal_count)
	    --idx;
	  del_formal (formal);	/* 'formal' goes out of scope.  */
	  break;
	}
      idx = sb_skip_white (idx, in);
      /* This is a formal.  */
      name = sb_terminate (&formal->name);
      if (! macro_mri
	  && idx < in->len
	  && in->ptr[idx] == ':'
	  && (! is_name_beginner (':')
	      || idx + 1 >= in->len
	      || ! is_part_of_name (in->ptr[idx + 1])))
	{
	  /* Got a qualifier.  */
	  sb qual;

	  sb_new (&qual);
	  idx = get_token (sb_skip_white (idx + 1, in), in, &qual);
	  sb_terminate (&qual);
	  if (qual.len == 0)
	    as_bad_where (macro->file,
			  macro->line,
			  _("Missing parameter qualifier for `%s' in macro `%s'"),
			  name,
			  macro->name);
	  else if (strcmp (qual.ptr, "req") == 0)
	    formal->type = FORMAL_REQUIRED;
	  else if (strcmp (qual.ptr, "vararg") == 0)
	    formal->type = FORMAL_VARARG;
	  else
	    as_bad_where (macro->file,
			  macro->line,
			  _("`%s' is not a valid parameter qualifier for `%s' in macro `%s'"),
			  qual.ptr,
			  name,
			  macro->name);
	  sb_kill (&qual);
	  idx = sb_skip_white (idx, in);
	}
      if (idx < in->len && in->ptr[idx] == '=')
	{
	  /* Got a default.  */
	  idx = get_any_string (idx + 1, in, &formal->def);
	  idx = sb_skip_white (idx, in);
	  if (formal->type == FORMAL_REQUIRED)
	    {
	      sb_reset (&formal->def);
	      as_warn_where (macro->file,
			    macro->line,
			    _("Pointless default value for required parameter `%s' in macro `%s'"),
			    name,
			    macro->name);
	    }
	}

      /* Add to macro's hash table.  */
      if (! hash_find (macro->formal_hash, name))
	hash_jam (macro->formal_hash, name, formal);
      else
	as_bad_where (macro->file,
		      macro->line,
		      _("A parameter named `%s' already exists for macro `%s'"),
		      name,
		      macro->name);

      formal->index = macro->formal_count++;
      *p = formal;
      p = &formal->next;
      if (formal->type == FORMAL_VARARG)
	break;
      cidx = idx;
      idx = sb_skip_comma (idx, in);
      if (idx != cidx && idx >= in->len)
	{
	  idx = cidx;
	  break;
	}
    }

  if (macro_mri)
    {
      formal_entry *formal = new_formal ();

      /* Add a special NARG formal, which macro_expand will set to the
	 number of arguments.  */
      /* The same MRI assemblers which treat '@@' characters also use
	 the name $NARG.  At least until we find an exception.  */
      if (macro_strip_at)
	name = "$NARG";
      else
	name = "NARG";

      sb_add_string (&formal->name, name);

      /* Add to macro's hash table.  */
      if (hash_find (macro->formal_hash, name))
	as_bad_where (macro->file,
		      macro->line,
		      _("Reserved word `%s' used as parameter in macro `%s'"),
		      name,
		      macro->name);
      hash_jam (macro->formal_hash, name, formal);

      formal->index = NARG_INDEX;
      *p = formal;
    }

  return idx;
}

/* Free the memory allocated to a macro.  */

static void
free_macro (macro_entry *macro)
{
  formal_entry *formal;

  for (formal = macro->formals; formal; )
    {
      formal_entry *f;

      f = formal;
      formal = formal->next;
      del_formal (f);
    }
  hash_die (macro->formal_hash);
  sb_kill (&macro->sub);
  free (macro);
}

/* Define a new macro.  Returns NULL on success, otherwise returns an
   error message.  If NAMEP is not NULL, *NAMEP is set to the name of
   the macro which was defined.  */

const char *
define_macro (size_t idx, sb *in, sb *label,
	      size_t (*get_line) (sb *),
	      char *file, unsigned int line,
	      const char **namep)
{
  macro_entry *macro;
  sb name;
  const char *error = NULL;

  macro = (macro_entry *) xmalloc (sizeof (macro_entry));
  sb_new (&macro->sub);
  sb_new (&name);
  macro->file = file;
  macro->line = line;

  macro->formal_count = 0;
  macro->formals = 0;
  macro->formal_hash = hash_new_sized (7);

  idx = sb_skip_white (idx, in);
  if (! buffer_and_nest ("MACRO", "ENDM", &macro->sub, get_line))
    error = _("unexpected end of file in macro `%s' definition");
  if (label != NULL && label->len != 0)
    {
      sb_add_sb (&name, label);
      macro->name = sb_terminate (&name);
      if (idx < in->len && in->ptr[idx] == '(')
	{
	  /* It's the label: MACRO (formals,...)  sort  */
	  idx = do_formals (macro, idx + 1, in);
	  if (idx < in->len && in->ptr[idx] == ')')
	    idx = sb_skip_white (idx + 1, in);
	  else if (!error)
	    error = _("missing `)' after formals in macro definition `%s'");
	}
      else
	{
	  /* It's the label: MACRO formals,...  sort  */
	  idx = do_formals (macro, idx, in);
	}
    }
  else
    {
      size_t cidx;

      idx = get_token (idx, in, &name);
      macro->name = sb_terminate (&name);
      if (name.len == 0)
	error = _("Missing macro name");
      cidx = sb_skip_white (idx, in);
      idx = sb_skip_comma (cidx, in);
      if (idx == cidx || idx < in->len)
	idx = do_formals (macro, idx, in);
      else
	idx = cidx;
    }
  if (!error && idx < in->len)
    error = _("Bad parameter list for macro `%s'");

  /* And stick it in the macro hash table.  */
  for (idx = 0; idx < name.len; idx++)
    name.ptr[idx] = TOLOWER (name.ptr[idx]);
  if (hash_find (macro_hash, macro->name))
    error = _("Macro `%s' was already defined");
  if (!error)
    error = hash_jam (macro_hash, macro->name, (void *) macro);

  if (namep != NULL)
    *namep = macro->name;

  if (!error)
    macro_defined = 1;
  else
    free_macro (macro);

  return error;
}

/* Scan a token, and then skip KIND.  */

static size_t
get_apost_token (size_t idx, sb *in, sb *name, int kind)
{
  idx = get_token (idx, in, name);
  if (idx < in->len
      && in->ptr[idx] == kind
      && (! macro_mri || macro_strip_at)
      && (! macro_strip_at || kind == '@@'))
    idx++;
  return idx;
}

/* Substitute the actual value for a formal parameter.  */

static size_t
sub_actual (size_t start, sb *in, sb *t, struct hash_control *formal_hash,
	    int kind, sb *out, int copyifnotthere)
{
  size_t src;
  formal_entry *ptr;

  src = get_apost_token (start, in, t, kind);
  /* See if it's in the macro's hash table, unless this is
     macro_strip_at and kind is '@@' and the token did not end in '@@'.  */
  if (macro_strip_at
      && kind == '@@'
      && (src == start || in->ptr[src - 1] != '@@'))
    ptr = NULL;
  else
    ptr = (formal_entry *) hash_find (formal_hash, sb_terminate (t));
  if (ptr)
    {
      if (ptr->actual.len)
	{
	  sb_add_sb (out, &ptr->actual);
	}
      else
	{
	  sb_add_sb (out, &ptr->def);
	}
    }
  else if (kind == '&')
    {
      /* Doing this permits people to use & in macro bodies.  */
      sb_add_char (out, '&');
      sb_add_sb (out, t);
      if (src != start && in->ptr[src - 1] == '&')
	sb_add_char (out, '&');
    }
  else if (copyifnotthere)
    {
      sb_add_sb (out, t);
    }
  else
    {
      sb_add_char (out, '\\');
      sb_add_sb (out, t);
    }
  return src;
}

/* Expand the body of a macro.  */

static const char *
macro_expand_body (sb *in, sb *out, formal_entry *formals,
		   struct hash_control *formal_hash, const macro_entry *macro)
{
  sb t;
  size_t src = 0;
  int inquote = 0, macro_line = 0;
  formal_entry *loclist = NULL;
  const char *err = NULL;

  sb_new (&t);

  while (src < in->len && !err)
    {
      if (in->ptr[src] == '&')
	{
	  sb_reset (&t);
	  if (macro_mri)
	    {
	      if (src + 1 < in->len && in->ptr[src + 1] == '&')
		src = sub_actual (src + 2, in, &t, formal_hash, '\'', out, 1);
	      else
		sb_add_char (out, in->ptr[src++]);
	    }
	  else
	    {
	      /* Permit macro parameter substition delineated with
		 an '&' prefix and optional '&' suffix.  */
	      src = sub_actual (src + 1, in, &t, formal_hash, '&', out, 0);
	    }
	}
      else if (in->ptr[src] == '\\')
	{
	  src++;
	  if (src < in->len && in->ptr[src] == '(')
	    {
	      /* Sub in till the next ')' literally.  */
	      src++;
	      while (src < in->len && in->ptr[src] != ')')
		{
		  sb_add_char (out, in->ptr[src++]);
		}
	      if (src < in->len)
		src++;
	      else if (!macro)
		err = _("missing `)'");
	      else
		as_bad_where (macro->file, macro->line + macro_line, _("missing `)'"));
	    }
	  else if (src < in->len && in->ptr[src] == '@@')
	    {
	      /* Sub in the macro invocation number.  */

	      char buffer[10];
	      src++;
	      sprintf (buffer, "%d", macro_number);
	      sb_add_string (out, buffer);
	    }
	  else if (src < in->len && in->ptr[src] == '&')
	    {
	      /* This is a preprocessor variable name, we don't do them
		 here.  */
	      sb_add_char (out, '\\');
	      sb_add_char (out, '&');
	      src++;
	    }
	  else if (macro_mri && src < in->len && ISALNUM (in->ptr[src]))
	    {
	      int ind;
	      formal_entry *f;

	      if (ISDIGIT (in->ptr[src]))
		ind = in->ptr[src] - '0';
	      else if (ISUPPER (in->ptr[src]))
		ind = in->ptr[src] - 'A' + 10;
	      else
		ind = in->ptr[src] - 'a' + 10;
	      ++src;
	      for (f = formals; f != NULL; f = f->next)
		{
		  if (f->index == ind - 1)
		    {
		      if (f->actual.len != 0)
			sb_add_sb (out, &f->actual);
		      else
			sb_add_sb (out, &f->def);
		      break;
		    }
		}
	    }
	  else
	    {
	      sb_reset (&t);
	      src = sub_actual (src, in, &t, formal_hash, '\'', out, 0);
	    }
	}
      else if ((macro_alternate || macro_mri)
	       && is_name_beginner (in->ptr[src])
	       && (! inquote
		   || ! macro_strip_at
		   || (src > 0 && in->ptr[src - 1] == '@@')))
	{
	  if (! macro
	      || src + 5 >= in->len
	      || strncasecmp (in->ptr + src, "LOCAL", 5) != 0
	      || ! ISWHITE (in->ptr[src + 5])
	      /* PR 11507: Skip keyword LOCAL if it is found inside a quoted string.  */
	      || inquote)
	    {
	      sb_reset (&t);
	      src = sub_actual (src, in, &t, formal_hash,
				(macro_strip_at && inquote) ? '@@' : '\'',
				out, 1);
	    }
	  else
	    {
	      src = sb_skip_white (src + 5, in);
	      while (in->ptr[src] != '\n')
		{
		  const char *name;
		  formal_entry *f = new_formal ();

		  src = get_token (src, in, &f->name);
		  name = sb_terminate (&f->name);
		  if (! hash_find (formal_hash, name))
		    {
		      static int loccnt;
		      char buf[20];

		      f->index = LOCAL_INDEX;
		      f->next = loclist;
		      loclist = f;

		      sprintf (buf, IS_ELF ? ".LL%04x" : "LL%04x", ++loccnt);
		      sb_add_string (&f->actual, buf);

		      err = hash_jam (formal_hash, name, f);
		      if (err != NULL)
			break;
		    }
		  else
		    {
		      as_bad_where (macro->file,
				    macro->line + macro_line,
				    _("`%s' was already used as parameter (or another local) name"),
				    name);
		      del_formal (f);
		    }

		  src = sb_skip_comma (src, in);
		}
	    }
	}
      else if (in->ptr[src] == '"'
	       || (macro_mri && in->ptr[src] == '\''))
	{
	  inquote = !inquote;
	  sb_add_char (out, in->ptr[src++]);
	}
      else if (in->ptr[src] == '@@' && macro_strip_at)
	{
	  ++src;
	  if (src < in->len
	      && in->ptr[src] == '@@')
	    {
	      sb_add_char (out, '@@');
	      ++src;
	    }
	}
      else if (macro_mri
	       && in->ptr[src] == '='
	       && src + 1 < in->len
	       && in->ptr[src + 1] == '=')
	{
	  formal_entry *ptr;

	  sb_reset (&t);
	  src = get_token (src + 2, in, &t);
	  ptr = (formal_entry *) hash_find (formal_hash, sb_terminate (&t));
	  if (ptr == NULL)
	    {
	      /* FIXME: We should really return a warning string here,
		 but we can't, because the == might be in the MRI
		 comment field, and, since the nature of the MRI
		 comment field depends upon the exact instruction
		 being used, we don't have enough information here to
		 figure out whether it is or not.  Instead, we leave
		 the == in place, which should cause a syntax error if
		 it is not in a comment.  */
	      sb_add_char (out, '=');
	      sb_add_char (out, '=');
	      sb_add_sb (out, &t);
	    }
	  else
	    {
	      if (ptr->actual.len)
		{
		  sb_add_string (out, "-1");
		}
	      else
		{
		  sb_add_char (out, '0');
		}
	    }
	}
      else
	{
	  if (in->ptr[src] == '\n')
	    ++macro_line;
	  sb_add_char (out, in->ptr[src++]);
	}
    }

  sb_kill (&t);

  while (loclist != NULL)
    {
      formal_entry *f;
      const char *name;

      f = loclist->next;
      name = sb_terminate (&loclist->name);
      hash_delete (formal_hash, name, f == NULL);
      del_formal (loclist);
      loclist = f;
    }

  return err;
}

/* Assign values to the formal parameters of a macro, and expand the
   body.  */

static const char *
macro_expand (size_t idx, sb *in, macro_entry *m, sb *out)
{
  sb t;
  formal_entry *ptr;
  formal_entry *f;
  int is_keyword = 0;
  int narg = 0;
  const char *err = NULL;

  sb_new (&t);

  /* Reset any old value the actuals may have.  */
  for (f = m->formals; f; f = f->next)
    sb_reset (&f->actual);
  f = m->formals;
  while (f != NULL && f->index < 0)
    f = f->next;

  if (macro_mri)
    {
      /* The macro may be called with an optional qualifier, which may
	 be referred to in the macro body as \0.  */
      if (idx < in->len && in->ptr[idx] == '.')
	{
	  /* The Microtec assembler ignores this if followed by a white space.
	     (Macro invocation with empty extension) */
	  idx++;
	  if (    idx < in->len
		  && in->ptr[idx] != ' '
		  && in->ptr[idx] != '\t')
	    {
	      formal_entry *n = new_formal ();

	      n->index = QUAL_INDEX;

	      n->next = m->formals;
	      m->formals = n;

	      idx = get_any_string (idx, in, &n->actual);
	    }
	}
    }

  /* Peel off the actuals and store them away in the hash tables' actuals.  */
  idx = sb_skip_white (idx, in);
  while (idx < in->len)
    {
      size_t scan;

      /* Look and see if it's a positional or keyword arg.  */
      scan = idx;
      while (scan < in->len
	     && !ISSEP (in->ptr[scan])
	     && !(macro_mri && in->ptr[scan] == '\'')
	     && (!macro_alternate && in->ptr[scan] != '='))
	scan++;
      if (scan < in->len && !macro_alternate && in->ptr[scan] == '=')
	{
	  is_keyword = 1;

	  /* It's OK to go from positional to keyword.  */

	  /* This is a keyword arg, fetch the formal name and
	     then the actual stuff.  */
	  sb_reset (&t);
	  idx = get_token (idx, in, &t);
	  if (in->ptr[idx] != '=')
	    {
	      err = _("confusion in formal parameters");
	      break;
	    }

	  /* Lookup the formal in the macro's list.  */
	  ptr = (formal_entry *) hash_find (m->formal_hash, sb_terminate (&t));
	  if (!ptr)
	    {
	      as_bad (_("Parameter named `%s' does not exist for macro `%s'"),
		      t.ptr,
		      m->name);
	      sb_reset (&t);
	      idx = get_any_string (idx + 1, in, &t);
	    }
	  else
	    {
	      /* Insert this value into the right place.  */
	      if (ptr->actual.len)
		{
		  as_warn (_("Value for parameter `%s' of macro `%s' was already specified"),
			   ptr->name.ptr,
			   m->name);
		  sb_reset (&ptr->actual);
		}
	      idx = get_any_string (idx + 1, in, &ptr->actual);
	      if (ptr->actual.len > 0)
		++narg;
	    }
	}
      else
	{
	  if (is_keyword)
	    {
	      err = _("can't mix positional and keyword arguments");
	      break;
	    }

	  if (!f)
	    {
	      formal_entry **pf;
	      int c;

	      if (!macro_mri)
		{
		  err = _("too many positional arguments");
		  break;
		}

	      f = new_formal ();

	      c = -1;
	      for (pf = &m->formals; *pf != NULL; pf = &(*pf)->next)
		if ((*pf)->index >= c)
		  c = (*pf)->index + 1;
	      if (c == -1)
		c = 0;
	      *pf = f;
	      f->index = c;
	    }

	  if (f->type != FORMAL_VARARG)
	    idx = get_any_string (idx, in, &f->actual);
	  else
	    {
	      sb_add_buffer (&f->actual, in->ptr + idx, in->len - idx);
	      idx = in->len;
	    }
	  if (f->actual.len > 0)
	    ++narg;
	  do
	    {
	      f = f->next;
	    }
	  while (f != NULL && f->index < 0);
	}

      if (! macro_mri)
	idx = sb_skip_comma (idx, in);
      else
	{
	  if (in->ptr[idx] == ',')
	    ++idx;
	  if (ISWHITE (in->ptr[idx]))
	    break;
	}
    }

  if (! err)
    {
      for (ptr = m->formals; ptr; ptr = ptr->next)
	{
	  if (ptr->type == FORMAL_REQUIRED && ptr->actual.len == 0)
	    as_bad (_("Missing value for required parameter `%s' of macro `%s'"),
		    ptr->name.ptr,
		    m->name);
	}

      if (macro_mri)
	{
	  char buffer[20];

	  sb_reset (&t);
	  sb_add_string (&t, macro_strip_at ? "$NARG" : "NARG");
	  ptr = (formal_entry *) hash_find (m->formal_hash, sb_terminate (&t));
	  sprintf (buffer, "%d", narg);
	  sb_add_string (&ptr->actual, buffer);
	}

      err = macro_expand_body (&m->sub, out, m->formals, m->formal_hash, m);
    }

  /* Discard any unnamed formal arguments.  */
  if (macro_mri)
    {
      formal_entry **pf;

      pf = &m->formals;
      while (*pf != NULL)
	{
	  if ((*pf)->name.len != 0)
	    pf = &(*pf)->next;
	  else
	    {
	      f = (*pf)->next;
	      del_formal (*pf);
	      *pf = f;
	    }
	}
    }

  sb_kill (&t);
  if (!err)
    macro_number++;

  return err;
}

/* Check for a macro.  If one is found, put the expansion into
   *EXPAND.  Return 1 if a macro is found, 0 otherwise.  */

int
check_macro (const char *line, sb *expand,
	     const char **error, macro_entry **info)
{
  const char *s;
  char *copy, *cls;
  macro_entry *macro;
  sb line_sb;

  if (! is_name_beginner (*line)
      && (! macro_mri || *line != '.'))
    return 0;

  s = line + 1;
  while (is_part_of_name (*s))
    ++s;
  if (is_name_ender (*s))
    ++s;

  copy = (char *) alloca (s - line + 1);
  memcpy (copy, line, s - line);
  copy[s - line] = '\0';
  for (cls = copy; *cls != '\0'; cls ++)
    *cls = TOLOWER (*cls);

  macro = (macro_entry *) hash_find (macro_hash, copy);

  if (macro == NULL)
    return 0;

  /* Wrap the line up in an sb.  */
  sb_new (&line_sb);
  while (*s != '\0' && *s != '\n' && *s != '\r')
    sb_add_char (&line_sb, *s++);

  sb_new (expand);
  *error = macro_expand (0, &line_sb, macro, expand);

  sb_kill (&line_sb);

  /* Export the macro information if requested.  */
  if (info)
    *info = macro;

  return 1;
}

/* Delete a macro.  */

void
delete_macro (const char *name)
{
  char *copy;
  size_t i, len;
  macro_entry *macro;

  len = strlen (name);
  copy = (char *) alloca (len + 1);
  for (i = 0; i < len; ++i)
    copy[i] = TOLOWER (name[i]);
  copy[i] = '\0';

  /* We can only ask hash_delete to free memory if we are deleting
     macros in reverse order to their definition.
     So just clear out the entry.  */
  if ((macro = (macro_entry *) hash_find (macro_hash, copy)) != NULL)
    {
      hash_jam (macro_hash, copy, NULL);
      free_macro (macro);
    }
  else
    as_warn (_("Attempt to purge non-existant macro `%s'"), copy);
}

/* Handle the MRI IRP and IRPC pseudo-ops.  These are handled as a
   combined macro definition and execution.  This returns NULL on
   success, or an error message otherwise.  */

const char *
expand_irp (int irpc, size_t idx, sb *in, sb *out, size_t (*get_line) (sb *))
{
  sb sub;
  formal_entry f;
  struct hash_control *h;
  const char *err;

  idx = sb_skip_white (idx, in);

  sb_new (&sub);
  if (! buffer_and_nest (NULL, "ENDR", &sub, get_line))
    return _("unexpected end of file in irp or irpc");

  sb_new (&f.name);
  sb_new (&f.def);
  sb_new (&f.actual);

  idx = get_token (idx, in, &f.name);
  if (f.name.len == 0)
    return _("missing model parameter");

  h = hash_new ();
  err = hash_jam (h, sb_terminate (&f.name), &f);
  if (err != NULL)
    return err;

  f.index = 1;
  f.next = NULL;
  f.type = FORMAL_OPTIONAL;

  sb_reset (out);

  idx = sb_skip_comma (idx, in);
  if (idx >= in->len)
    {
      /* Expand once with a null string.  */
      err = macro_expand_body (&sub, out, &f, h, 0);
    }
  else
    {
      bfd_boolean in_quotes = FALSE;

      if (irpc && in->ptr[idx] == '"')
	{
	  in_quotes = TRUE;
	  ++idx;
	}

      while (idx < in->len)
	{
	  if (!irpc)
	    idx = get_any_string (idx, in, &f.actual);
	  else
	    {
	      if (in->ptr[idx] == '"')
		{
		  size_t nxt;

		  if (irpc)
		    in_quotes = ! in_quotes;

		  nxt = sb_skip_white (idx + 1, in);
		  if (nxt >= in->len)
		    {
		      idx = nxt;
		      break;
		    }
		}
	      sb_reset (&f.actual);
	      sb_add_char (&f.actual, in->ptr[idx]);
	      ++idx;
	    }

	  err = macro_expand_body (&sub, out, &f, h, 0);
	  if (err != NULL)
	    break;
	  if (!irpc)
	    idx = sb_skip_comma (idx, in);
	  else if (! in_quotes)
	    idx = sb_skip_white (idx, in);
	}
    }

  hash_die (h);
  sb_kill (&f.actual);
  sb_kill (&f.def);
  sb_kill (&f.name);
  sb_kill (&sub);

  return err;
}
@


1.56
log
@	PR gas/14201
	* sb.h (sb_max_power_two): Delete.
	(struct sb): Delete "item" and "pot".  Make "len" a size_t.  Add "max".
	(sb_element): Delete.
	(sb_add_char, sb_add_buffer, sb_skip_comma, sb_skip_write): Update
	prototypes.
	* sb.c (string_count, free_list): Delete.
	(sb_build, sb_kill, sb_check): Rewrite.
	(scrub_from_sb, sb_add_char, sb_add_string, sb_add_buffer,
	sb_skip_white, sb_skip_comma): Replace assorted int params,
	vars and return types with size_t.
	* input-scrub.c: Likewise.
	* macro.c: Likewise.
	* macro.h: Likewise.
	* as.c: Likewise.
	* as.h: Likewise.
	* input-file.h: Likewise.
	* input-file.c: Likewise.
	* read.c: Likewise.
	* app.c: ..or ptrdiff_t.
	* input-file.c (input_file_get): Use ferror.
	(input_file_give_next_buffer): Use input_file_get.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007, 2008, 2011, 2012 Free Software Foundation, Inc.
d577 1
a577 1
         number of arguments.  */
d579 1
a579 1
         the name $NARG.  At least until we find an exception.  */
d645 1
a645 1
  macro->formal_hash = hash_new ();
d953 7
a959 7
                 but we can't, because the == might be in the MRI
                 comment field, and, since the nature of the MRI
                 comment field depends upon the exact instruction
                 being used, we don't have enough information here to
                 figure out whether it is or not.  Instead, we leave
                 the == in place, which should cause a syntax error if
                 it is not in a comment.  */
d1026 1
a1026 1
         be referred to in the macro body as \0.  */
d1352 1
a1352 1
	  
@


1.56.2.1
log
@gas/
	* hash.c (hash_new_sized): Make it global.
	* hash.h: Declare it.
	* macro.c (define_macro): Use hash_new_sized instead of hash_new,
	pass a small size.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007, 2008, 2011, 2012, 2013 Free Software Foundation, Inc.
d577 1
a577 1
	 number of arguments.  */
d579 1
a579 1
	 the name $NARG.  At least until we find an exception.  */
d645 1
a645 1
  macro->formal_hash = hash_new_sized (7);
d953 7
a959 7
		 but we can't, because the == might be in the MRI
		 comment field, and, since the nature of the MRI
		 comment field depends upon the exact instruction
		 being used, we don't have enough information here to
		 figure out whether it is or not.  Instead, we leave
		 the == in place, which should cause a syntax error if
		 it is not in a comment.  */
d1026 1
a1026 1
	 be referred to in the macro body as \0.  */
d1352 1
a1352 1

@


1.55
log
@	* macro.c (get_any_string): Free malloced br_buf.
	(do_formals): Free 'formal'.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007, 2008, 2011 Free Software Foundation, Inc.
d68 1
a68 1
static int (*macro_expr) (const char *, int, sb *, int *);
d78 1
a78 1
	    int (*exp) (const char *, int, sb *, int *))
d113 1
a113 1
		 int (*get_line) (sb *))
d115 2
a116 2
  int from_len;
  int to_len = strlen (to);
d118 2
a119 3
  int line_start = ptr->len;

  int more = get_line (ptr);
d132 1
a132 1
      int i = line_start;
d229 2
a230 2
static int
get_token (int idx, sb *in, sb *name)
d255 2
a256 2
static int
getstring (int idx, sb *in, sb *acc)
d341 2
a342 2
static int
get_any_string (int idx, sb *in, sb *out)
d356 1
a356 1
	  int val;
d365 1
a365 1
	  sprintf (buf, "%d", val);
d476 2
a477 2
static int
do_formals (macro_entry *macro, int idx, sb *in)
d486 1
a486 1
      int cidx;
d628 2
a629 2
define_macro (int idx, sb *in, sb *label,
	      int (*get_line) (sb *),
d671 1
a671 1
      int cidx;
d708 2
a709 2
static int
get_apost_token (int idx, sb *in, sb *name, int kind)
d722 2
a723 2
static int
sub_actual (int start, sb *in, sb *t, struct hash_control *formal_hash,
d726 1
a726 1
  int src;
d776 2
a777 1
  int src = 0, inquote = 0, macro_line = 0;
d1005 1
a1005 1
macro_expand (int idx, sb *in, macro_entry *m, sb *out)
d1052 1
a1052 1
      int scan;
d1292 1
a1292 1
expand_irp (int irpc, int idx, sb *in, sb *out, int (*get_line) (sb *))
d1348 1
a1348 1
		  int nxt;
@


1.54
log
@	* macro.c (sub_actual): Add back ampersand suffix when no
	substitution.
	(macro_expand_body): Correct comment.
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
d122 1
a122 1
  if (to_len == 4 && strcasecmp(to, "ENDR") == 0)
d387 1
a387 1
	  char *br_buf = (char *) xmalloc(1);
d410 4
a413 1
		    return idx;
d421 3
a423 3
		      br_buf = (char *) xmalloc(strlen(in_br) + 2);
		      strcpy(br_buf + 1, in_br);
		      free(in_br);
d440 1
a440 1
	  free(br_buf);
d494 1
@


1.53
log
@	PR gas/11834
	* macro.c (macro_expand): Recover gracefully from named args that
	don't match params.
@
text
@d751 2
d793 2
a794 3
	      /* FIXME: Why do we do this?  */
	      /* At least in alternate mode this seems correct; without this
	         one can't append a literal to a parameter.  */
@


1.52
log
@        PR gas/11507
        * macro.c (macro_expand_body): Do not treat LOCAL as a keyword in
        altmacro mode if found inside a quoted string.

        * gas/macros/altmacro.s: New test.
        * gas/macros/altmacro.d: Expected output.
@
text
@d1075 7
a1081 3
	    as_bad (_("Parameter named `%s' does not exist for macro `%s'"),
		    t.ptr,
		    m->name);
@


1.51
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d871 3
a873 1
	      || ! ISWHITE (in->ptr[src + 5]))
@


1.50
log
@	PR gas/1491
gas/
	* macro.c: Delete unnecessary function declarations.
	(buffer_and_nest): Support multiple labels per line for
	LABELS_WITHOUT_COLONS targets if the labels do have colons.
	(free_macro): Move so that we don't need forward declaration.
	* read.c (read_a_source_file): Take a copy of macro expansion line
	before we trim labels.
	* listing.c (listing_newline): Adjust stdin line save for
	input_line_pointer still at start of line.
gas/testsuite/
	* gas/macros/dot.s: Don't start macro invocations is first column.
	* gas/macros/dot.l: Update.
	* gas/macros/macros.exp: Run dot test on more targets.
@
text
@d78 1
a78 1
	    int (*expr) (const char *, int, sb *, int *))
d85 1
a85 1
  macro_expr = expr;
d1207 1
a1207 1
  char *copy, *cs;
d1224 2
a1225 2
  for (cs = copy; *cs != '\0'; cs++)
    *cs = TOLOWER (*cs);
@


1.49
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        * as.c (main): Call dwarf2_init.
        * config/obj-elf.c (struct group_list): New field.
        (build_group_lists): Use hash lookup.
        (free_section_idx): New function.
        (elf_frob_file): Adjust.
        * dwarf2dbg.c (all_segs_hash, last_seg_ptr): New variables.
        (get_line_subseg): Adjust.
        (dwarf2_init): New function.
        * dwarf2dbg.h (dwarf2_init): New declaration.
@
text
@a32 15
/* Internal functions.  */

static int get_token (int, sb *, sb *);
static int getstring (int, sb *, sb *);
static int get_any_string (int, sb *, sb *);
static formal_entry *new_formal (void);
static void del_formal (formal_entry *);
static int do_formals (macro_entry *, int, sb *);
static int get_apost_token (int, sb *, sb *, int);
static int sub_actual (int, sb *, sb *, struct hash_control *, int, sb *, int);
static const char *macro_expand_body
  (sb *, sb *, formal_entry *, struct hash_control *, const macro_entry *);
static const char *macro_expand (int, sb *, macro_entry *, sb *);
static void free_macro(macro_entry *);

d134 1
a157 2
	  if (LABELS_WITHOUT_COLONS)
	    break;
d164 6
d175 1
d600 20
a1248 20
/* Free the memory allocated to a macro.  */

static void
free_macro(macro_entry *macro)
{
  formal_entry *formal;

  for (formal = macro->formals; formal; )
    {
      formal_entry *f;

      f = formal;
      formal = formal->next;
      del_formal (f);
    }
  hash_die (macro->formal_hash);
  sb_kill (&macro->sub);
  free (macro);
}

@


1.48
log
@Banish PARAMS and PTR.  Convert to ISO C.
Delete unnecessary forward declarations.
@
text
@d396 1
a396 1
	  char *br_buf = xmalloc(1);
d427 1
a427 1
		      br_buf = xmalloc(strlen(in_br) + 2);
d460 1
a460 1
  formal = xmalloc (sizeof (formal_entry));
d1276 1
a1276 1
  if ((macro = hash_find (macro_hash, copy)) != NULL)
@


1.48.8.1
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.
@
text
@d396 1
a396 1
	  char *br_buf = (char *) xmalloc(1);
d427 1
a427 1
		      br_buf = (char *) xmalloc(strlen(in_br) + 2);
d460 1
a460 1
  formal = (formal_entry *) xmalloc (sizeof (formal_entry));
d1276 1
a1276 1
  if ((macro = (macro_entry *) hash_find (macro_hash, copy)) != NULL)
@


1.47
log
@	PR 6575
	* hash.c: Expand PTR to void *.
	(hash_delete): Add "freeme" parameter.  Call obstack_free.
	* hash.h: Expand PTR to void *.
	(hash_delete): Update prototype.
	* macro.c (macro_expand_body): hash_delete LOCALs from formal_hash.
	* config/tc-tic54x.c (tic54x_remove_local_label): Update hash_delete
	call.
	(subsym_substitute): Likewise.
	* doc/internals.texi (hash_delete): Update.
@
text
@d679 1
a679 1
    error = hash_jam (macro_hash, macro->name, (PTR) macro);
@


1.46
log
@Switch to GPLv3
@
text
@d3 1
a3 1
   2004, 2005, 2006, 2007 Free Software Foundation, Inc.
d971 1
d974 2
a975 3
      /* Setting the value to NULL effectively deletes the entry.  We
         avoid calling hash_delete because it doesn't reclaim memory.  */
      hash_jam (formal_hash, sb_terminate (&loclist->name), NULL);
d1273 3
a1275 1
  /* Since hash_delete doesn't free memory, just clear out the entry.  */
@


1.45
log
@PR gas/3856
* macro.c (expand_irp): Do not ignore spaces inside quoted strings.
@
text
@d3 1
a3 1
   2004, 2005, 2006 Free Software Foundation, Inc.
d12 1
a12 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.44
log
@remove some duplicate #include's.
@
text
@d1328 2
d1331 5
a1335 1
	++idx;
d1346 3
d1360 1
d1366 1
a1366 1
	  else
@


1.43
log
@	* listing.c (listing_listing): Remove useless loop.
	* macro.c (macro_expand): Remove is_positional local variable.
	* read.c (s_comm_internal): Simplify `if' condition 1 || x -> 1
	and simplify surrounding expressions, where possible.
	(assign_symbol): Likewise.
	(s_weakref): Likewise.
	* symbols.c (colon): Likewise.
@
text
@d3 1
a3 1
   2004, 2005 Free Software Foundation, Inc.
a24 32
#include "config.h"

#ifndef __GNUC__
# if HAVE_ALLOCA_H
#  include <alloca.h>
# else
#  ifdef _AIX
/* Indented so that pre-ansi C compilers will ignore it, rather than
   choke on it.  Some versions of AIX require this to be the first
   thing in the file.  */
 #pragma alloca
#  else
#   ifndef alloca /* predefined by HP cc +Olibcalls */
#    if !defined (__STDC__) && !defined (__hpux)
extern char *alloca ();
#    else
extern void *alloca ();
#    endif /* __STDC__, __hpux */
#   endif /* alloca */
#  endif /* _AIX */
# endif /* HAVE_ALLOCA_H */
#endif /* __GNUC__ */

#include <stdio.h>
#ifdef HAVE_STRING_H
#include <string.h>
#else
#include <strings.h>
#endif
#ifdef HAVE_STDLIB_H
#include <stdlib.h>
#endif
a25 1
#include "libiberty.h"
a27 1
#include "hash.h"
a29 2
#include "asintl.h"

@


1.42
log
@gas/
2006-02-28  Jan Beulich  <jbeulich@@novell.com>

	* macro.c (get_any_string): Don't insert quotes for <>-quoted input.

gas/testsuite/
2006-02-28  Jan Beulich  <jbeulich@@novell.com>

	* gas/all/altmacro.s: Adjust.
	* gas/all/altmac2.s: Adjust.
@
text
@a1027 1
  int is_positional = 0;
a1117 2
	  /* This is a positional arg.  */
	  is_positional = 1;
@


1.41
log
@gas/
2006-02-28  Jan Beulich  <jbeulich@@novell.com>

	PR/1070
	* macro.c (getstring): Don't treat parentheses special anymore.
	(get_any_string): Don't consider '(' and ')' as quoting anymore.
	Special-case '(', ')', '[', and ']' when dealing with non-quoting
	characters.

gas/testsuite/
2006-02-28  Jan Beulich  <jbeulich@@novell.com>

	* gas/macros/paren[sd]: New.
	* gas/macros/macros.exp: Run new test.
@
text
@d418 1
a418 1
	  if (macro_alternate && ! macro_strip_at)
d421 1
a421 2
	      sb_add_char (out, '\"');

d423 1
a423 1
	      sb_add_char (out, '\"');
@


1.40
log
@	* macro.c (buffer_and_nest): Skip labels regardless of
	NO_PSEUDO_DOT and flag_m68k_mri.
@
text
@a305 1
	     || in->ptr[idx] == '('
a311 3
	  char start_char = '>';
	  char end_char = '>';

d313 1
a313 1
	  while ((in->ptr[idx] != end_char || nest)
d323 1
a323 1
		  if (in->ptr[idx] == end_char)
d325 1
a325 1
		  if (in->ptr[idx] == start_char)
a331 22
      else if (in->ptr[idx] == '(')
	{
	  int nest = 0;
	  char c;

	  do
	    {
	      c = in->ptr[idx];

	      if (c == '!')
		c = in->ptr[++idx];
	      else if (c == ')')
		nest--;
	      else if (c == '(')
		nest++;

	      sb_add_char (acc, c);
	      idx++;
	    }
	  while ((c != ')' || nest)
		 && idx < in->len);
	}
a414 1
	       || in->ptr[idx] == '('
d433 4
d438 3
a440 2
		 && in->ptr[idx] != ' '
		 && in->ptr[idx] != '\t'
d445 3
a447 2
	      if (in->ptr[idx] == '"'
		  || in->ptr[idx] == '\'')
d449 2
a450 2
		  char tchar = in->ptr[idx];

d457 22
d480 2
a481 1
	      sb_add_char (out, in->ptr[idx++]);
d483 1
@


1.39
log
@PR 1070
* macro.c (getstring): Do not treat round parentheses exactly the same as angle
brackets - the parentheses need to be preserved and passed on to the macro processing code.
@
text
@d183 1
a183 1
      /* Try and find the first pseudo op on the line.  */
d186 13
a198 1
      if (! NO_PSEUDO_DOT && ! flag_m68k_mri)
d200 18
a217 35
	  /* With normal syntax we can suck what we want till we get
	     to the dot.  With the alternate, labels have to start in
	     the first column, since we can't tell what's a label and
	     whats a pseudoop.  */

	  if (! LABELS_WITHOUT_COLONS)
	    {
	      /* Skip leading whitespace.  */
	      while (i < ptr->len && ISWHITE (ptr->ptr[i]))
		i++;
	    }

	  for (;;)
	    {
	      /* Skip over a label, if any.  */
	      if (i >= ptr->len || ! is_name_beginner (ptr->ptr[i]))
		break;
	      i++;
	      while (i < ptr->len && is_part_of_name (ptr->ptr[i]))
		i++;
	      if (i < ptr->len && is_name_ender (ptr->ptr[i]))
		i++;
	      if (LABELS_WITHOUT_COLONS)
		break;
	      /* Skip whitespace.  */
	      while (i < ptr->len && ISWHITE (ptr->ptr[i]))
		i++;
	      /* Check for the colon.  */
	      if (i >= ptr->len || ptr->ptr[i] != ':')
		{
		  i = line_start;
		  break;
		}
	      i++;
	      line_start = i;
d219 3
a222 1
	}
@


1.38
log
@PR 1070
* macro.c (getstring): Treat round parentheses in the same way as angle brackets.
(get_any_string): Likewise.
@
text
@d313 1
a313 2
      if (in->ptr[idx] == '<'
	  || in->ptr[idx] == '(')
d316 2
a317 2
	  char start_char = in->ptr[idx];
	  char end_char = in->ptr[idx] == '<' ? '>' : ')';
d339 22
d413 1
a413 1
    (string)		-> return string
@


1.37
log
@gas/
2005-05-10  Jan Beulich  <jbeulich@@novell.com>

	* macro.c (get_any_string): Remove the two last parameters. Replace
	references to the former expand parameter by using macro_alternate.
	Simplify loop condition for checking for end-of-string.
	(get_string): Remove redunant call to sb_skip_white.
	(do_formals): Remove two last arguments to get_any_string.
	(macro_expand): Likewise.
	(expand_irp): Likewise.
@
text
@d309 1
d313 2
a314 1
      if (in->ptr[idx] == '<')
d317 3
d321 1
a321 1
	  while ((in->ptr[idx] != '>' || nest)
d331 1
a331 1
		  if (in->ptr[idx] == '>')
d333 1
a333 1
		  if (in->ptr[idx] == '<')
d390 4
a393 4
    %<char>		-> return string of decimal value of x
    "<string>"		-> return string
    xyx<whitespace>     -> return xyz
*/
d412 1
d423 1
d453 1
@


1.36
log
@gas/
2005-05-06  Jan Beulich  <jbeulich@@novell.com>

	* macro.c (new_formal, del_formal): New.
	(do_formals): Use new_formal. Check for and parse qualifier. Warn if
	required argument has default value. Stop looking for more formal
	when there was a vararg one.
	(macro_expand_body): Use new_formal and del_formal.
	(macro_expand): Likewise. Initialize local variable err. Don't
	return immediately when encountering an error. Warn when keyword
	argument already had a value assigned. Eliminate duplicate clearing
	of argument value. When current positional argument matches parameter
	of vararg type, assign to it all the remaining arguments. Issue error
	when required parameter does not have value.
	(free_macro): Use del_formal.
	(expand_irp): Initialize formal type. Free buffers associated with
	formal prior to returning.
	* macro.h (struct formal_struct): Add new field 'type' with new
	enumeration type 'formal_type'.
	* doc/as.texinfo: Document macro parameter qualifiers.
	* NEWS: Mention new functionality.

gas/testsuite/
2005-05-06  Jan Beulich  <jbeulich@@novell.com>

	* gas/macros/badarg.s: Add check for bad qualifier specification.
	* gas/macros/badarg.l: Adjust.
	* gas/macros/vararg.[sd]: New.
	* gas/macros/macros.exp: Run new test.
@
text
@d73 1
a73 1
static int get_any_string (int, sb *, sb *, int, int);
a306 2
  idx = sb_skip_white (idx, in);

d391 1
a391 1
get_any_string (int idx, sb *in, sb *out, int expand, int pretend_quoted)
d403 1
a403 3
      else if (in->ptr[idx] == '%'
	       && macro_alternate
	       && expand)
d420 1
a420 3
	  if (macro_alternate
	      && ! macro_strip_at
	      && expand)
d436 5
a440 8
		 && (in->ptr[idx] == '"'
		     || in->ptr[idx] == '\''
		     || pretend_quoted
		     || (in->ptr[idx] != ' '
			 && in->ptr[idx] != '\t'
			 && in->ptr[idx] != ','
			 && (in->ptr[idx] != '<'
			     || (! macro_alternate && ! macro_mri)))))
d549 1
a549 1
	  idx = get_any_string (idx + 1, in, &formal->def, 1, 0);
d1034 1
a1034 1
	      idx = get_any_string (idx, in, &n->actual, 1, 0);
d1084 1
a1084 1
	      idx = get_any_string (idx + 1, in, &ptr->actual, 0, 0);
d1123 1
a1123 1
	    idx = get_any_string (idx, in, &f->actual, 1, 0);
d1344 1
a1344 1
	    idx = get_any_string (idx, in, &f.actual, 1, 0);
@


1.35
log
@Update the address and phone number of the FSF
@
text
@d74 2
d470 28
d509 1
a509 1
      formal_entry *formal;
a511 6
      formal = (formal_entry *) xmalloc (sizeof (formal_entry));

      sb_new (&formal->name);
      sb_new (&formal->def);
      sb_new (&formal->actual);

d521 34
d560 9
a571 1
      name = sb_terminate (&formal->name);
d582 4
a592 3
      *p = formal;
      p = &formal->next;
      *p = NULL;
d597 1
a597 1
      formal_entry *formal;
a600 6
      formal = (formal_entry *) xmalloc (sizeof (formal_entry));

      sb_new (&formal->name);
      sb_new (&formal->def);
      sb_new (&formal->actual);

a620 1
      formal->next = NULL;
d890 1
a890 1
		  formal_entry *f;
a891 2
		  f = (formal_entry *) xmalloc (sizeof (formal_entry));
		  sb_new (&f->name);
a898 2
		      sb_new (&f->def);
		      sb_new (&f->actual);
d916 1
a916 2
		      sb_kill (&f->name);
		      free (f);
d993 1
a993 4
      sb_kill (&loclist->name);
      sb_kill (&loclist->def);
      sb_kill (&loclist->actual);
      free (loclist);
d1012 1
a1012 1
  const char *err;
d1036 1
a1036 1
	      formal_entry *n;
a1037 4
	      n = (formal_entry *) xmalloc (sizeof (formal_entry));
	      sb_new (&n->name);
	      sb_new (&n->def);
	      sb_new (&n->actual);
d1072 4
a1075 1
	    return _("confusion in formal parameters");
d1080 3
a1082 1
	    return _("macro formal argument does not exist");
d1086 7
a1092 1
	      sb_reset (&ptr->actual);
d1103 4
a1106 1
	    return _("can't mix positional and keyword arguments");
d1114 4
a1117 1
		return _("too many positional arguments");
d1119 1
a1119 5
	      f = (formal_entry *) xmalloc (sizeof (formal_entry));
	      sb_new (&f->name);
	      sb_new (&f->def);
	      sb_new (&f->actual);
	      f->next = NULL;
d1131 7
a1137 2
	  sb_reset (&f->actual);
	  idx = get_any_string (idx, in, &f->actual, 1, 0);
d1158 1
a1158 1
  if (macro_mri)
d1160 11
a1170 1
      char buffer[20];
d1172 8
a1179 6
      sb_reset (&t);
      sb_add_string (&t, macro_strip_at ? "$NARG" : "NARG");
      ptr = (formal_entry *) hash_find (m->formal_hash, sb_terminate (&t));
      sb_reset (&ptr->actual);
      sprintf (buffer, "%d", narg);
      sb_add_string (&ptr->actual, buffer);
a1181 2
  err = macro_expand_body (&m->sub, out, m->formals, m->formal_hash, m);

a1193 3
	      sb_kill (&(*pf)->name);
	      sb_kill (&(*pf)->def);
	      sb_kill (&(*pf)->actual);
d1195 1
a1195 1
	      free (*pf);
d1267 1
a1267 1
      void *ptr;
d1269 1
a1269 4
      sb_kill (&formal->name);
      sb_kill (&formal->def);
      sb_kill (&formal->actual);
      ptr = formal;
d1271 1
a1271 1
      free (ptr);
d1336 1
d1382 3
@


1.34
log
@* config/obj-ecoff.c (ecoff_frob_file_before_fix): Fix invocations of bfd_section_list... macros.
* config/tc-mmix.c (mmix_frob_file): Likewise.
* config/tc-xtensa.c (xtensa_remove_section): Likewise.
	(xtensa_insert_section): Likewise.

* macro.c (macro_hash): Remove static.
* macro.h (macro_hash): Provide an external declaration.
@
text
@d22 2
a23 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.33
log
@	* Makefile.am (GAS_CFILES): Remove bignum-copy.c.
	(GENERIC_OBJS): Likewise, remove bignum-copy.o.
	(bignum-copy.o): Remove.
	* Makefile.in: Regenerate.
	* makefile.vms (OBJS): Remove bignum-copy.obj.
	* symbols.h (local_symbol_make): Remove declaration.
	(verify_symbol_chain_2): Likewise.
	* symbols.c (local_symbol_make): Make static.
	(max_indent_level): Likewise.
	(verify_symbol_chain_2): Remove.
	* macro.c (macro_hash): Make static.
	* messages.c (fprint_value): Remove.
	* read.h (get_absolute_expr): Remove.
	(emit_leb128_expr): Likewise.
	(do_s_func): Likewise.
	* read.c (do_s_func): Make static.
	(emit_leb128_expr): Likewise.
	(get_absolute_expr): Likewise.
	* as.h (as_howmuch): Remove declaration.
	(fprint_value): Likewise.
	* as.c (myname): Make static.
	* input-scrub.c (as_howmuch): Remove.
	(as_1_char): Likewise.
	* input-file.h (input_file_is_open): Remove.
	* input-file.c (input_file_is_open): Likewise.
	* expr.h (expr_build_unary): Remove declaration.
	(expr_build_binary): Likewise.
	* expr.c (expr_build_unary): Remove.
	(expr_build_binary): Likewise.
	* hash.h (hash_replace): Remove declaration.
	(hash_delete): Likewise.
	* hash.c (hash_replace): Remove.
	(hash_delete): Likewise.
	* bignum-copy.c (bignum_copy): Move from here ..
	* config/tc-vax.c (bignum_copy): .. to here.
	* bignum.h (LOG_TO_BASE_2_OF_10): Remove.
	(bignum_copy): Remove extern declaration.
	* sb.h (string_count): Remove extern declaration.
	(sb_build, sb_add_buffer, sb_print, sb_print_at): Likewise.
	(sb_name): Likewise.
	* sb.c (dsize): Replace preprocessor macro with static int.
	(string_count): Make static.
	(sb_build, sb_add_buffer, sb_print, sb_print_at): Likewise.
	(sb_name): Likewise.
	* config/obj-coff.c (dim_index): Make static.
	* config/tc-i386.c (GOT_symbol): Likewise.
	(output_invalid_buf): Likewise.
	* doc/internals.texi (Warning and error messages): Remove the
	prototype for fprint_value.
@
text
@d97 1
a97 1
static struct hash_control *macro_hash;
@


1.32
log
@gas/
2005-04-25  Jan Beulich  <jbeulich@@novell.com>

	* macro.c (macro_expand_body): Replace locals indicator parameters
	with actual macro_entry. New local variables macro_line and err.
	Don't return when encountering an error, just record the fact.
	Detect local symbol name colliding with parameter. Track line number
	inside of macro expansion.
	(do_formals): Move local variable name to wider scope. Check
	parameter of the same name doesn't already exist. In MRI mode, also
	check it doesn't collide with the argument count pseudo-parameter).
	(define_macro): Add file and line number parameters. Remove local
	variable namestr. New local variable error. Initialize macro_entry
	members file, line, and name. Don't return when encountering an
	error, just record the fact. Use %s in some diagnostics for read.c
	to insert the macro name. Free macro_entry on error.
	(macro_expand): Pass macro_entry to macro_epand_body. Don't return
	when encountering an error, just record the fact.
	(expand_irp): Don't return when encountering an error, just record
	the fact.
	* macro.h (macro_struct): New members name, file, and line.
	(define_macro): Add file and line number parameters.
	* read.c (s_macro): Pass file and line to define_macro. Tag warning
	regarding pseudo-op redefinition with the file/line that macro
	definition started at.

gas/testsuite/
2005-04-25  Jan Beulich  <jbeulich@@novell.com>

	* gas/macros/badarg.s: Add tests for collisions between/among macro
	parameters and local symbols.
	* gas/macros/badarg.l: Adjust.
@
text
@d97 1
a97 1
struct hash_control *macro_hash;
@


1.31
log
@gas/
2005-04-18  Jan Beulich  <jbeulich@@novell.com>

	* macro.c (free_token): New, freeing all the memory associated with a
	macro.
	(do_formals): Move initializers to ...
	(define_macro): ... here.
	(delete_macro): Convert passed in name to lower case. Warn when
	purging macro that doesn't exist. Use hash_jam instead of hash_delete.

gas/testsuite/
2005-04-18  Jan Beulich  <jbeulich@@novell.com>

	* gas/macros/purge.[ls]: New.
	* gas/macros/macros.exp: Run new test.
@
text
@d78 1
a78 1
  (sb *, sb *, formal_entry *, struct hash_control *, int);
d474 1
d505 9
a513 1
      hash_jam (macro->formal_hash, sb_terminate (&formal->name), formal);
a530 1
      const char *name;
d550 6
d572 3
a574 1
	      int (*get_line) (sb *), const char **namep)
d578 1
a578 1
  const char *namestr;
d583 2
d592 1
a592 1
    return _("unexpected end of file in macro definition");
d596 1
d601 4
a604 3
	  if (idx >= in->len || in->ptr[idx] != ')')
	    return _("missing ) after formals");
	  idx = sb_skip_white (idx + 1, in);
d617 1
d619 1
a619 1
	return _("Missing macro name");
d627 2
a628 2
  if (idx < in->len)
    return _("Bad macro parameter list");
d633 4
a636 4
  namestr = sb_terminate (&name);
  if (hash_find (macro_hash, namestr))
    return _("Macro with this name was already defined");
  hash_jam (macro_hash, namestr, (PTR) macro);
d638 2
a639 1
  macro_defined = 1;
d641 4
a644 2
  if (namep != NULL)
    *namep = namestr;
d646 1
a646 1
  return NULL;
d714 1
a714 1
		   struct hash_control *formal_hash, int locals)
d717 1
a717 2
  int src = 0;
  int inquote = 0;
d719 1
d723 1
a723 1
  while (src < in->len)
d738 2
a739 1
	      /* At least in alternate mode this seems correct.  */
d754 1
a754 1
	      if (in->ptr[src] == ')')
d756 2
d759 1
a759 1
		return _("misplaced `)'");
d814 1
a814 1
	  if (! locals
a825 2
	      formal_entry *f;

d829 2
a830 3
		  static int loccnt;
		  char buf[20];
		  const char *err;
d834 12
a845 5
		  sb_new (&f->def);
		  sb_new (&f->actual);
		  f->index = LOCAL_INDEX;
		  f->next = loclist;
		  loclist = f;
d847 16
a862 8
		  src = get_token (src, in, &f->name);
		  ++loccnt;
		  sprintf (buf, IS_ELF ? ".LL%04x" : "LL%04x", loccnt);
		  sb_add_string (&f->actual, buf);

		  err = hash_jam (formal_hash, sb_terminate (&f->name), f);
		  if (err != NULL)
		    return err;
d922 2
d945 1
a945 1
  return NULL;
d1104 1
a1104 3
  err = macro_expand_body (&m->sub, out, m->formals, m->formal_hash, 1);
  if (err != NULL)
    return err;
d1129 2
a1130 1
  macro_number++;
d1132 1
a1132 1
  return NULL;
a1273 2
      if (err != NULL)
	return err;
d1302 1
a1302 1
	    return err;
d1313 1
a1313 1
  return NULL;
@


1.30
log
@gas/
2005-04-11  Jan Beulich  <jbeulich@@novell.com>

	* NEWS: Mention these changes and their effects.
	* macro.c (get_token): Use is_name_beginner/is_part_of_name/
	is_name_ender.
	(check_macro): Likewise.
	(buffer_and_nest): Likewise. Permit multiple labels. Don't discard
	labels together with the closing pseudo-op.
	(macro_expand_body): Adjust comment. Range-check input before use.
	Adjust mis-spelled diagnostic. Use is_name_beginner.
	* read.c (try_macro): New.
	(read_a_source_file): New static variable last_eol. Don't list
	macro expansion lines more than once. Call try_macro.
	(s_macro): Set section of line_label to absolute instead of undefined.
	* doc/as.texinfo: Add information on the caveats of these changes.

gas/testsuite/
2005-04-11  Jan Beulich  <jbeulich@@novell.com>

	* gas/macros/dot.[ls]: New.
	* gas/macros/macros.exp: Run new test.
@
text
@d80 1
a474 2
  macro->formal_count = 0;
  macro->formal_hash = hash_new ();
d570 1
d1145 23
d1173 18
a1190 1
  hash_delete (macro_hash, name);
@


1.29
log
@update copyright dates
@
text
@d190 31
a220 15
	  /* Skip leading whitespace.  */
	  while (i < ptr->len && ISWHITE (ptr->ptr[i]))
	    i++;

	  /* Skip over a label.  */
	  while (i < ptr->len
		 && (ISALNUM (ptr->ptr[i])
		     || ptr->ptr[i] == '_'
		     || ptr->ptr[i] == '$'))
	    i++;

	  /* And a colon.  */
	  if (i < ptr->len
	      && ptr->ptr[i] == ':')
	    i++;
d245 2
a246 1
		  || ! ISALNUM (ptr->ptr[i + from_len])))
d250 2
a251 1
		  || ! ISALNUM (ptr->ptr[i + to_len])))
d279 1
a279 3
      && (ISALPHA (in->ptr[idx])
	  || in->ptr[idx] == '_'
	  || in->ptr[idx] == '$'))
d283 6
a288 3
	     && (ISALNUM (in->ptr[idx])
		 || in->ptr[idx] == '_'
		 || in->ptr[idx] == '$'))
d714 1
d721 1
a721 1
	  if (in->ptr[src] == '(')
d732 1
a732 1
		return _("missplaced )");
d734 1
a734 1
	  else if (in->ptr[src] == '@@')
d743 1
a743 1
	  else if (in->ptr[src] == '&')
d751 1
a751 1
	  else if (macro_mri && ISALNUM (in->ptr[src]))
d782 1
a782 3
	       && (ISALPHA (in->ptr[src])
		   || in->ptr[src] == '_'
		   || in->ptr[src] == '$')
d1107 1
a1107 3
  if (! ISALPHA (*line)
      && *line != '_'
      && *line != '$'
d1112 3
a1114 3
  while (ISALNUM (*s)
	 || *s == '_'
	 || *s == '$')
@


1.28
log
@gas/
2005-01-31  Jan Beulich  <jbeulich@@novell.com>

	* macro.c (buffer_and_nest): Allow 'from' being NULL; handle anything
	that can end with .endr in that case. Make requiring/permitting
	pseudo-ops without leading dot closer to the logic in read.c serving
	the same purpose.
	(expand_irp): Don't pass a mnemonic to buffer_and_nest as it will be
	ignored.

gas/testsuite/
2005-01-31  Jan Beulich  <jbeulich@@novell.com>

	* gas/macros/repeat.[ds]: New.
	* gas/macros/macros.exp: Run new test.
@
text
@d2 2
a3 2
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
@


1.27
log
@gas/
2005-01-31  Jan Beulich  <jbeulich@@novell.com>

	* macro.c (do_formals): Adjust to no longer accept empty parameter
	names.
	(define_macro): Adjust to no longer accept empty macro name, garbage
	following the parameters, or macros that were previously defined.
	* read.c (s_bad_end): Declare.
	(potable): Add endm. Handler for endr and endm is s_bad_end.
	(s_bad_end): Rename from s_bad_endr. Adjust to handle both .endm
	and .endr.
	* read.h (s_bad_endr): Remove.

gas/testsuite/
2005-01-31  Jan Beulich  <jbeulich@@novell.com>

	* gas/macros/badarg.[ls]: New.
	* gas/macros/end.[ls]: New.
	* gas/macros/redef.[ls]: New.
	* gas/macros/macros.exp (run_list_test): Copy from elsewhere.
	Run new tests.
@
text
@d155 1
d163 1
a163 1
  int from_len = strlen (from);
d170 8
d183 1
a183 1
      if (! macro_alternate && ! macro_mri)
d187 1
a187 1
	     the first column, since we cant tell what's a label and
d212 1
a212 1
			   || macro_alternate
d215 1
a215 1
	  if (ptr->ptr[i] == '.')
d217 11
a227 1
	  if (strncasecmp (ptr->ptr + i, from, from_len) == 0
a1143 1
  const char *mn;
a1148 5
  if (irpc)
    mn = "IRPC";
  else
    mn = "IRP";

d1152 1
a1152 1
  if (! buffer_and_nest (mn, "ENDR", &sub, get_line))
@


1.26
log
@For ELF targets use .LL rather than LL as  the prefix for symbol names generated
from the LOCAL macro directive.
@
text
@d438 1
d442 1
a449 1
      idx = sb_skip_white (idx, in);
d452 5
a456 1
	break;
d458 2
a459 1
      if (formal->name.len)
d461 3
a463 6
	  /* This is a formal.  */
	  if (idx < in->len && in->ptr[idx] == '=')
	    {
	      /* Got a default.  */
	      idx = get_any_string (idx + 1, in, &formal->def, 1, 0);
	    }
d469 2
a470 1
      formal->index = macro->formal_count;
d472 5
a476 1
      macro->formal_count++;
d544 1
a544 1
	  if (in->ptr[idx] != ')')
d546 1
d556 2
d559 8
a566 2
      idx = sb_skip_comma (idx, in);
      idx = do_formals (macro, idx, in);
d568 2
d575 2
@


1.25
log
@(macro_set_alternate): Use ISO C90 formatting.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d57 1
d760 1
a760 1
		  sprintf (buf, "LL%04x", loccnt);
@


1.24
log
@Add and handle new --alternate command line option.
@
text
@d138 1
a138 2
macro_set_alternate(alternate)
     int alternate;
@


1.23
log
@	* listing.c: Convert to ISO-C.
	* listing.h: Likewise.
	* macro.c: Likewise.
	* macro.h: Likewise.
@
text
@d135 9
@


1.22
log
@	* macro.c (sub_actual): Don't lose string if it turns out that
	&string wasn't an arg.
@
text
@d70 6
a75 7
static int get_token PARAMS ((int, sb *, sb *));
static int getstring PARAMS ((int, sb *, sb *));
static int get_any_string PARAMS ((int, sb *, sb *, int, int));
static int do_formals PARAMS ((macro_entry *, int, sb *));
static int get_apost_token PARAMS ((int, sb *, sb *, int));
static int sub_actual
  PARAMS ((int, sb *, sb *, struct hash_control *, int, sb *, int));
d77 2
a78 2
  PARAMS ((sb *, sb *, formal_entry *, struct hash_control *, int));
static const char *macro_expand PARAMS ((int, sb *, macro_entry *, sb *));
d115 1
a115 1
static int (*macro_expr) PARAMS ((const char *, int, sb *, int *));
d124 2
a125 5
macro_init (alternate, mri, strip_at, expr)
     int alternate;
     int mri;
     int strip_at;
     int (*expr) PARAMS ((const char *, int, sb *, int *));
d138 1
a138 2
macro_mri_mode (mri)
     int mri;
d150 2
a151 5
buffer_and_nest (from, to, ptr, get_line)
     const char *from;
     const char *to;
     sb *ptr;
     int (*get_line) PARAMS ((sb *));
d230 1
a230 4
get_token (idx, in, name)
     int idx;
     sb *in;
     sb *name;
d255 1
a255 4
getstring (idx, in, acc)
     int idx;
     sb *in;
     sb *acc;
d343 1
a343 6
get_any_string (idx, in, out, expand, pretend_quoted)
     int idx;
     sb *in;
     sb *out;
     int expand;
     int pretend_quoted;
d423 1
a423 4
do_formals (macro, idx, in)
     macro_entry *macro;
     int idx;
     sb *in;
d503 2
a504 6
define_macro (idx, in, label, get_line, namep)
     int idx;
     sb *in;
     sb *label;
     int (*get_line) PARAMS ((sb *));
     const char **namep;
d560 1
a560 5
get_apost_token (idx, in, name, kind)
     int idx;
     sb *in;
     sb *name;
     int kind;
d574 2
a575 8
sub_actual (start, in, t, formal_hash, kind, out, copyifnotthere)
     int start;
     sb *in;
     sb *t;
     struct hash_control *formal_hash;
     int kind;
     sb *out;
     int copyifnotthere;
d621 2
a622 6
macro_expand_body (in, out, formals, formal_hash, locals)
     sb *in;
     sb *out;
     formal_entry *formals;
     struct hash_control *formal_hash;
     int locals;
d844 1
a844 5
macro_expand (idx, in, m, out)
     int idx;
     sb *in;
     macro_entry *m;
     sb *out;
d1032 2
a1033 5
check_macro (line, expand, error, info)
     const char *line;
     sb *expand;
     const char **error;
     macro_entry **info;
d1083 1
a1083 2
delete_macro (name)
     const char *name;
d1093 1
a1093 6
expand_irp (irpc, idx, in, out, get_line)
     int irpc;
     int idx;
     sb *in;
     sb *out;
     int (*get_line) PARAMS ((sb *));
@


1.21
log
@(buffer_and_nest): Store more to sb instead of '\n'.
(get_line_sb): Return end of line character or '\n' if it is zero or
non-existent.
@
text
@d640 1
@


1.21.2.1
log
@	* macro.c (sub_actual): Don't lose string if it turns out that
	&string wasn't an arg.
@
text
@a639 1
      sb_add_sb (out, t);
@


1.20
log
@	* configure.in: Add iq2000-elf target.
	* configure: Regenerate.
	* config/tc-iq2000.c: New file.
	* config/tc-iq2000.h: Likewise.
@
text
@d225 2
a226 2
      /* Add a CR to the end and keep running.  */
      sb_add_char (ptr, '\n');
@


1.19
log
@Remove GASP.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d96 1
a96 1
static struct hash_control *macro_hash;
@


1.18
log
@	* macro.c (get_any_string): Correct logic for not going beyond end
	of in->ptr[].
@
text
@d1 1
a1 1
/* macro.c - macro support for gas and gasp
d66 1
a66 1
   They are called by both gasp and gas.  */
d78 2
a79 2
  PARAMS ((sb *, sb *, formal_entry *, struct hash_control *, int, int));
static const char *macro_expand PARAMS ((int, sb *, macro_entry *, sb *, int));
d102 1
a102 1
/* Whether we are in GASP alternate mode.  */
d656 1
a656 1
macro_expand_body (in, out, formals, formal_hash, comment_char, locals)
a660 1
     int comment_char;
d691 1
a691 8
	  if (in->ptr[src] == comment_char && comment_char != '\0')
	    {
	      /* This is a comment, just drop the rest of the line.  */
	      while (src < in->len
		     && in->ptr[src] != '\n')
		src++;
	    }
	  else if (in->ptr[src] == '(')
d774 1
a774 1
	      while (in->ptr[src] != '\n' && in->ptr[src] != comment_char)
a800 11
      else if (comment_char != '\0'
	       && in->ptr[src] == comment_char
	       && src + 1 < in->len
	       && in->ptr[src + 1] == comment_char
	       && !inquote)
	{
	  /* Two comment chars in a row cause the rest of the line to
             be dropped.  */
	  while (src < in->len && in->ptr[src] != '\n')
	    src++;
	}
d883 1
a883 1
macro_expand (idx, in, m, out, comment_char)
a887 1
     int comment_char;
d937 1
a937 1
  while (idx < in->len && in->ptr[idx] != comment_char)
d1039 1
a1039 2
  err = macro_expand_body (&m->sub, out, m->formals, m->formal_hash,
			   comment_char, 1);
d1072 1
a1072 2
   *EXPAND.  COMMENT_CHAR is the comment character--this is used by
   gasp.  Return 1 if a macro is found, 0 otherwise.  */
d1075 1
a1075 1
check_macro (line, expand, comment_char, error, info)
a1077 1
     int comment_char;
d1115 1
a1115 1
  *error = macro_expand (0, &line_sb, macro, expand, comment_char);
d1140 1
a1140 1
expand_irp (irpc, idx, in, out, get_line, comment_char)
a1145 1
     int comment_char;
d1183 1
a1183 1
  if (idx >= in->len || in->ptr[idx] == comment_char)
d1186 1
a1186 1
      err = macro_expand_body (&sub, out, &f, h, comment_char, 0);
d1194 1
a1194 1
      while (idx < in->len && in->ptr[idx] != comment_char)
d1205 1
a1205 1
		  if (nxt >= in->len || in->ptr[nxt] == comment_char)
d1215 1
a1215 1
	  err = macro_expand_body (&sub, out, &f, h, comment_char, 0);
@


1.17
log
@	* as.h: Fix formatting.
	* cgen.c: Likewise.
	* cgen.h: Likewise.
	* dwarf2dbg.c: Likewise.
	* frags.h: Likewise.
	* gasp.c: Likewise.
	* macro.c: Likewise.
	* read.c: Likewise.
	* stabs.c: Likewise.
	* symbols.c: Likewise.
@
text
@d369 1
a369 1
      if (in->len > 2 && in->ptr[idx + 1] == '\'' && ISBASE (in->ptr[idx]))
@


1.16
log
@Add no-c-format comment to prevent confusion when translating string.
@
text
@d386 1
a386 1
	  sprintf(buf, "%d", val);
d931 23
a953 23
        {
          /* The Microtec assembler ignores this if followed by a white space.
    		   (Macro invocation with empty extension) */
          idx++;
          if (    idx < in->len
	            && in->ptr[idx] != ' '
               && in->ptr[idx] != '\t')
            {
              formal_entry *n;

              n = (formal_entry *) xmalloc (sizeof (formal_entry));
              sb_new (&n->name);
              sb_new (&n->def);
              sb_new (&n->actual);
              n->index = QUAL_INDEX;

              n->next = m->formals;
              m->formals = n;

              idx = get_any_string (idx, in, &n->actual, 1, 0);
            }
        }
  }
@


1.15
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
d381 1
@


1.14
log
@	* as.h (alloca): Don't declare if __GNUC__.  Remove an old comment.
	Comment indentation of #pragma.
	* macro.c (alloca): Likewise.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000
a53 1
#include <ctype.h>
d58 1
d186 1
a186 1
		 && (isalnum ((unsigned char) ptr->ptr[i])
d209 1
a209 1
		  || ! isalnum (ptr->ptr[i + from_len])))
d213 1
a213 1
		  || ! isalnum (ptr->ptr[i + to_len])))
d244 1
a244 1
      && (isalpha ((unsigned char) in->ptr[idx])
d250 1
a250 1
	     && (isalnum ((unsigned char) in->ptr[idx])
d570 1
a570 2
    if (isupper ((unsigned char) name.ptr[idx]))
      name.ptr[idx] = tolower (name.ptr[idx]);
d728 1
a728 2
	  else if (macro_mri
		   && isalnum ((unsigned char) in->ptr[src]))
d733 1
a733 1
	      if (isdigit ((unsigned char) in->ptr[src]))
d735 1
a735 1
	      else if (isupper ((unsigned char) in->ptr[src]))
d759 1
a759 1
	       && (isalpha ((unsigned char) in->ptr[src])
d1108 1
a1108 1
  if (! isalpha ((unsigned char) *line)
d1115 1
a1115 1
  while (isalnum ((unsigned char) *s)
d1124 1
a1124 2
    if (isupper ((unsigned char) *cs))
      *cs = tolower (*cs);
@


1.13
log
@Fix m68k/mri mode problems.
@
text
@d27 1
a27 10
/* AIX requires this to be the first thing in the file.  */
#ifdef __GNUC__
# ifndef alloca
#  ifdef __STDC__
extern void *alloca ();
#  else
extern char *alloca ();
#  endif
# endif
#else
d32 3
d46 1
a46 1
#endif
@


1.12
log
@Fix copyright notices
@
text
@d938 9
a946 2
	{
	  formal_entry *n;
d948 5
a952 5
	  n = (formal_entry *) xmalloc (sizeof (formal_entry));
	  sb_new (&n->name);
	  sb_new (&n->def);
	  sb_new (&n->actual);
	  n->index = QUAL_INDEX;
d954 2
a955 2
	  n->next = m->formals;
	  m->formals = n;
d957 4
a960 3
	  idx = get_any_string (idx + 1, in, &n->actual, 1, 0);
	}
    }
@


1.11
log
@Fix formatting
@
text
@d2 1
a2 1
   Copyright (C) 1994, 95, 96, 97, 98, 99, 2000
@


1.11.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1997, 1998, 1999, 2000
@


1.10
log
@2000-08-31  Kazu Hirata  <kazu@@hxi.com>

	* frags.c: Fix formatting.
	* macro.c: Likewise.
@
text
@d323 1
a323 1
		  idx++;
d327 1
a327 1
		  idx++;
d332 1
a332 1
		  idx++;
d338 1
a338 1
		      idx++;
d345 1
a345 1
		  idx++;
@


1.9
log
@Fix spelling typos.
Remove use of DEFUN().
@
text
@d2 2
a3 1
   Copyright (C) 1994, 95, 96, 97, 98, 1999 Free Software Foundation, Inc.
d23 1
a23 1
   02111-1307, USA. */
d176 1
a176 1
      /* Try and find the first pseudo op on the line */
d184 1
a184 1
	     whats a pseudoop */
d186 1
a186 1
	  /* Skip leading whitespace */
d190 1
a190 1
	  /* Skip over a label */
d197 1
a197 1
	  /* And a colon */
d203 1
a203 1
      /* Skip trailing whitespace */
d212 1
a212 1
	      i++;
d214 2
a215 1
	      && (ptr->len == (i + from_len) || ! isalnum (ptr->ptr[i + from_len])))
d218 2
a219 1
	      && (ptr->len == (i + to_len) || ! isalnum (ptr->ptr[i + to_len])))
d224 1
a224 1
		  /* Reset the string to not include the ending rune */
d231 1
a231 1
      /* Add a CR to the end and keep running */
d263 1
a263 1
  /* Ignore trailing & */
d280 1
a280 1
	 && (in->ptr[idx] == '"' 
d293 1
a293 1
		  idx++  ;
d311 1
a311 1
	  
d313 1
a313 1
	  
d316 1
a316 1
	      if (in->ptr[idx-1] == '\\')
d323 2
a324 2
		  idx ++;
		  
d327 1
a327 1
		  idx ++;
d332 1
a332 1
		  idx ++;
d338 2
a339 2
		      idx ++;
		      
d343 1
a343 1
		  
d345 1
a345 1
		  idx ++;
d350 1
a350 1
  
d375 1
a375 1
      if (in->len > 2 && in->ptr[idx+1] == '\'' && ISBASE (in->ptr[idx]))
d386 1
a386 1
	  /* Turns the next expression into a string */
d402 2
a403 2
	      /* Keep the quotes */
	      sb_add_char (out,  '\"');
d406 1
a406 1
	      sb_add_char (out,  '\"');
d413 1
a413 1
      else 
d415 1
a415 1
	  while (idx < in->len 
d418 1
a418 1
		     || pretend_quoted 
d425 1
a425 1
	      if (in->ptr[idx] == '"' 
d432 1
a432 1
		    sb_add_char (out, in->ptr[idx++]);		    
d434 1
a434 1
		    return idx;	      
d473 1
a473 1
	  /* This is a formal */
d476 1
a476 1
	      /* Got a default */
d481 1
a481 1
      /* Add to macro's hash table */
d514 1
a514 1
      /* Add to macro's hash table */
d556 1
a556 1
	  /* It's the label: MACRO (formals,...)  sort */
d563 1
a563 1
	  /* It's the label: MACRO formals,...  sort */
d574 1
a574 1
  /* and stick it in the macro hash table */
d651 1
a651 1
  else 
d700 1
a700 1
	      /* This is a comment, just drop the rest of the line */
d707 1
a707 1
	      /* Sub in till the next ')' literally */
d720 1
a720 1
	      /* Sub in the macro invocation number */
d730 1
a730 1
		 here */
d925 2
a926 2
  
  /* Reset any old value the actuals may have */
d928 1
a928 1
      sb_reset (&f->actual);
d954 1
a954 1
  /* Peel off the actuals and store them away in the hash tables' actuals */
d960 1
a960 1
      /* Look and see if it's a positional or keyword arg */
d974 1
a974 1
	     then the actual stuff */
d980 1
a980 1
	  /* Lookup the formal in the macro's list */
d986 1
a986 1
	      /* Insert this value into the right place */
d995 1
a995 1
	  /* This is a positional arg */
d1142 1
a1142 1
  /* export the macro information if requested */
d1187 1
a1187 1
  
@


1.8
log
@2000-06-13  Ulf Carlsson  <ulfc@@engr.sgi.com>

	* macro.c (getstring): Make it possible to escape the quote
	character.
@
text
@d308 1
d310 1
d320 5
a324 2
		  idx++  ;
		  sb_add_char (acc, in->ptr[idx++]);
d329 1
a329 1
		  idx++;
d335 2
a336 1
		      idx++;
d340 1
d342 1
a342 1
		  idx++;
@


1.7
log
@* macro.c (macro_expand_body): Don't prepend macro number with zeroes.
@
text
@d307 1
d311 5
d320 5
@


1.6
log
@Add macro handling extensions and line substitution support.
@
text
@d703 1
a703 1
	      sprintf (buffer, "%05d", macro_number);
@


1.5
log
@fix typo.
@
text
@a72 36
/* Structures used to store macros. 

   Each macro knows its name and included text.  It gets built with a
   list of formal arguments, and also keeps a hash table which points
   into the list to speed up formal search.  Each formal knows its
   name and its default value.  Each time the macro is expanded, the
   formals get the actual values attatched to them. */

/* describe the formal arguments to a macro */

typedef struct formal_struct
  {
    struct formal_struct *next;	/* next formal in list */
    sb name;			/* name of the formal */
    sb def;			/* the default value */
    sb actual;			/* the actual argument (changed on each expansion) */
    int index;			/* the index of the formal 0..formal_count-1 */
  }
formal_entry;

/* Other values found in the index field of a formal_entry.  */
#define QUAL_INDEX (-1)
#define NARG_INDEX (-2)
#define LOCAL_INDEX (-3)

/* describe the macro. */

typedef struct macro_struct
  {
    sb sub;			/* substitution text. */
    int formal_count;		/* number of formal args. */
    formal_entry *formals;	/* pointer to list of formal_structs */
    struct hash_control *formal_hash; /* hash table of formals. */
  }
macro_entry;

d1075 1
a1075 1
check_macro (line, expand, comment_char, error)
d1080 1
d1120 4
@


1.4
log
@do not look beyond the end of the buffer
@
text
@d249 1
a249 1
	      && (ptr->len == (i + from_len || ! isalnum (ptr->ptr[i + from_len]))))
@


1.3
log
@Look for seperator after TO and FROM tokens when exploring nested structures
@
text
@d249 1
a249 1
	      && ! isalnum (ptr->ptr[i + from_len]))
d252 1
a252 1
	      && ! isalnum (ptr->ptr[i + to_len]))
@


1.2
log
@	* gasp.c (chunksize): New variable.
	* macro.c (macro_expand_body): Call hash_jam with NULL rather than
	hash_delete
.CVS: ----------------------------------------------------------------------
@
text
@d248 2
a249 1
	  if (strncasecmp (ptr->ptr + i, from, from_len) == 0)
d251 2
a252 1
	  if (strncasecmp (ptr->ptr + i, to, to_len) == 0)
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1994, 95, 96, 97, 1998 Free Software Foundation, Inc.
d905 3
a907 1
      hash_delete (formal_hash, sb_terminate (&loclist->name));
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

