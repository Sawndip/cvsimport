head	1.156;
access;
symbols
	binutils-2_24-branch:1.156.0.2
	binutils-2_24-branchpoint:1.156
	binutils-2_21_1:1.136.2.1
	binutils-2_23_2:1.151.2.1
	binutils-2_23_1:1.151
	binutils-2_23:1.151
	binutils-2_23-branch:1.151.0.2
	binutils-2_23-branchpoint:1.151
	binutils-2_22_branch:1.145.2.1.0.2
	binutils-2_22:1.145.2.1
	binutils-2_22-branch:1.145.0.2
	binutils-2_22-branchpoint:1.145
	binutils-2_21:1.136
	binutils-2_21-branch:1.136.0.2
	binutils-2_21-branchpoint:1.136
	binutils-2_20_1:1.126.2.2
	binutils-2_20:1.126.2.1
	binutils-arc-20081103-branch:1.121.0.4
	binutils-arc-20081103-branchpoint:1.121
	binutils-2_20-branch:1.126.0.2
	binutils-2_20-branchpoint:1.126
	dje-cgen-play1-branch:1.123.0.2
	dje-cgen-play1-branchpoint:1.123
	arc-20081103-branch:1.121.0.2
	arc-20081103-branchpoint:1.121
	binutils-2_19_1:1.118.2.2
	binutils-2_19:1.118.2.2
	binutils-2_19-branch:1.118.0.2
	binutils-2_19-branchpoint:1.118
	binutils-2_18:1.114
	binutils-2_18-branch:1.114.0.2
	binutils-2_18-branchpoint:1.114
	binutils-csl-coldfire-4_1-32:1.99.2.1
	binutils-csl-sourcerygxx-4_1-32:1.99.2.1
	binutils-csl-innovasic-fido-3_4_4-33:1.99.2.1
	binutils-csl-sourcerygxx-3_4_4-32:1.85
	binutils-csl-coldfire-4_1-30:1.99.2.1
	binutils-csl-sourcerygxx-4_1-30:1.99.2.1
	binutils-csl-coldfire-4_1-28:1.99.2.1
	binutils-csl-sourcerygxx-4_1-29:1.99.2.1
	binutils-csl-sourcerygxx-4_1-28:1.99.2.1
	binutils-csl-arm-2006q3-27:1.99.2.1
	binutils-csl-sourcerygxx-4_1-27:1.99.2.1
	binutils-csl-arm-2006q3-26:1.99.2.1
	binutils-csl-sourcerygxx-4_1-26:1.99.2.1
	binutils-csl-sourcerygxx-4_1-25:1.99.2.1
	binutils-csl-sourcerygxx-4_1-24:1.99.2.1
	binutils-csl-sourcerygxx-4_1-23:1.99.2.1
	binutils-csl-sourcerygxx-4_1-21:1.99.2.1
	binutils-csl-arm-2006q3-21:1.99.2.1
	binutils-csl-sourcerygxx-4_1-22:1.99.2.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.99.2.1
	binutils-csl-sourcerygxx-4_1-20:1.99.2.1
	binutils-csl-arm-2006q3-19:1.99.2.1
	binutils-csl-sourcerygxx-4_1-19:1.99.2.1
	binutils-csl-sourcerygxx-4_1-18:1.99.2.1
	binutils-csl-renesas-4_1-9:1.99.2.1
	binutils-csl-sourcerygxx-3_4_4-25:1.85
	binutils-csl-renesas-4_1-8:1.99
	binutils-csl-renesas-4_1-7:1.99
	binutils-csl-renesas-4_1-6:1.99
	binutils-csl-sourcerygxx-4_1-17:1.99
	binutils-csl-sourcerygxx-4_1-14:1.99
	binutils-csl-sourcerygxx-4_1-15:1.99
	binutils-csl-sourcerygxx-4_1-13:1.99
	binutils-2_17:1.99.4.1
	binutils-csl-sourcerygxx-4_1-12:1.99
	binutils-csl-sourcerygxx-3_4_4-21:1.99
	binutils-csl-wrs-linux-3_4_4-24:1.85
	binutils-csl-wrs-linux-3_4_4-23:1.85
	binutils-csl-sourcerygxx-4_1-9:1.99
	binutils-csl-sourcerygxx-4_1-8:1.99
	binutils-csl-sourcerygxx-4_1-7:1.99
	binutils-csl-arm-2006q1-6:1.99
	binutils-csl-sourcerygxx-4_1-6:1.99
	binutils-csl-wrs-linux-3_4_4-22:1.85
	binutils-csl-coldfire-4_1-11:1.99
	binutils-csl-sourcerygxx-3_4_4-19:1.99
	binutils-csl-coldfire-4_1-10:1.99
	binutils-csl-sourcerygxx-4_1-5:1.99
	binutils-csl-sourcerygxx-4_1-4:1.99
	binutils-csl-wrs-linux-3_4_4-21:1.85
	binutils-csl-morpho-4_1-4:1.99
	binutils-csl-sourcerygxx-3_4_4-17:1.99
	binutils-csl-wrs-linux-3_4_4-20:1.85
	binutils-2_17-branch:1.99.0.4
	binutils-2_17-branchpoint:1.99
	binutils-csl-2_17-branch:1.99.0.2
	binutils-csl-2_17-branchpoint:1.99
	binutils-csl-gxxpro-3_4-branch:1.85.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.85
	binutils-2_16_1:1.85
	binutils-csl-arm-2005q1b:1.85
	binutils-2_16:1.85
	binutils-csl-arm-2005q1a:1.85
	binutils-csl-arm-2005q1-branch:1.85.0.4
	binutils-csl-arm-2005q1-branchpoint:1.85
	binutils-2_16-branch:1.85.0.2
	binutils-2_16-branchpoint:1.85
	csl-arm-2004-q3d:1.79
	csl-arm-2004-q3:1.78
	binutils-2_15:1.76
	binutils-2_15-branchpoint:1.76
	csl-arm-2004-q1a:1.76
	csl-arm-2004-q1:1.76
	binutils-2_15-branch:1.76.0.6
	cagney_bfdfile-20040213-branch:1.76.0.4
	cagney_bfdfile-20040213-branchpoint:1.76
	cagney_bigcore-20040122-branch:1.76.0.2
	cagney_bigcore-20040122-branchpoint:1.76
	csl-arm-2003-q4:1.76
	binutils-2_14:1.71
	binutils-2_14-branch:1.71.0.2
	binutils-2_14-branchpoint:1.71
	binutils-2_13_2_1:1.58.2.2
	binutils-2_13_2:1.58.2.2
	binutils-2_13_1:1.58.2.1
	binutils-2_13:1.58
	binutils-2_13-branchpoint:1.58
	binutils-2_13-branch:1.58.0.2
	binutils-2_12_1:1.52.2.1
	binutils-2_12:1.52
	binutils-2_12-branch:1.52.0.2
	binutils-2_12-branchpoint:1.52
	cygnus_cvs_20020108_pre:1.52
	binutils-2_11_2:1.25.2.2
	binutils-2_11_1:1.25.2.2
	binutils-2_11:1.25.2.1
	x86_64versiong3:1.26
	binutils-2_11-branch:1.25.0.2
	binutils-2_10_1:1.11
	binutils-2_10:1.11
	binutils-2_10-branch:1.11.0.2
	binutils-2_10-branchpoint:1.11
	binutils_latest_snapshot:1.156
	repo-unification-2000-02-06:1.11
	binu_ss_19990721:1.8
	binu_ss_19990602:1.2
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.156
date	2013.05.29.16.22.13;	author macro;	state Exp;
branches;
next	1.155;

1.155
date	2013.03.08.10.17.00;	author cltang;	state Exp;
branches;
next	1.154;

1.154
date	2013.02.04.12.34.17;	author amodra;	state Exp;
branches;
next	1.153;

1.153
date	2013.01.10.19.51.54;	author hjl;	state Exp;
branches;
next	1.152;

1.152
date	2012.10.01.06.46.16;	author amodra;	state Exp;
branches;
next	1.151;

1.151
date	2012.07.02.07.35.06;	author nickc;	state Exp;
branches
	1.151.2.1;
next	1.150;

1.150
date	2012.06.28.11.31.13;	author nickc;	state Exp;
branches;
next	1.149;

1.149
date	2012.02.21.13.39.36;	author iains;	state Exp;
branches;
next	1.148;

1.148
date	2012.02.21.09.13.01;	author iains;	state Exp;
branches;
next	1.147;

1.147
date	2012.01.17.00.20.30;	author amodra;	state Exp;
branches;
next	1.146;

1.146
date	2011.11.15.13.08.17;	author macro;	state Exp;
branches;
next	1.145;

1.145
date	2011.08.18.14.10.35;	author amodra;	state Exp;
branches
	1.145.2.1;
next	1.144;

1.144
date	2011.08.04.20.53.58;	author hjl;	state Exp;
branches;
next	1.143;

1.143
date	2011.08.04.10.24.00;	author amodra;	state Exp;
branches;
next	1.142;

1.142
date	2011.08.01.09.05.40;	author gingold;	state Exp;
branches;
next	1.141;

1.141
date	2011.05.06.14.48.56;	author gingold;	state Exp;
branches;
next	1.140;

1.140
date	2011.01.31.16.43.13;	author nickc;	state Exp;
branches;
next	1.139;

1.139
date	2011.01.19.00.24.23;	author hjl;	state Exp;
branches;
next	1.138;

1.138
date	2011.01.18.18.55.58;	author hjl;	state Exp;
branches;
next	1.137;

1.137
date	2010.12.02.13.25.12;	author rsandifo;	state Exp;
branches;
next	1.136;

1.136
date	2010.10.29.12.10.34;	author hjl;	state Exp;
branches
	1.136.2.1;
next	1.135;

1.135
date	2010.10.25.03.03.18;	author amodra;	state Exp;
branches;
next	1.134;

1.134
date	2010.10.19.12.14.23;	author amodra;	state Exp;
branches;
next	1.133;

1.133
date	2010.10.19.11.59.18;	author amodra;	state Exp;
branches;
next	1.132;

1.132
date	2010.07.03.20.52.24;	author ccoutant;	state Exp;
branches;
next	1.131;

1.131
date	2010.05.04.16.21.07;	author nickc;	state Exp;
branches;
next	1.130;

1.130
date	2010.04.29.14.44.14;	author nickc;	state Exp;
branches;
next	1.129;

1.129
date	2010.01.23.12.05.32;	author rsandifo;	state Exp;
branches;
next	1.128;

1.128
date	2009.12.11.13.42.10;	author nickc;	state Exp;
branches;
next	1.127;

1.127
date	2009.09.11.15.27.33;	author nickc;	state Exp;
branches;
next	1.126;

1.126
date	2009.09.02.07.24.19;	author amodra;	state Exp;
branches
	1.126.2.1;
next	1.125;

1.125
date	2009.08.31.18.45.26;	author hjl;	state Exp;
branches;
next	1.124;

1.124
date	2009.08.17.11.45.21;	author ktietz;	state Exp;
branches;
next	1.123;

1.123
date	2009.06.22.17.56.00;	author nickc;	state Exp;
branches;
next	1.122;

1.122
date	2009.03.10.14.38.03;	author hp;	state Exp;
branches;
next	1.121;

1.121
date	2008.09.19.10.00.40;	author amodra;	state Exp;
branches;
next	1.120;

1.120
date	2008.09.19.02.11.02;	author amodra;	state Exp;
branches;
next	1.119;

1.119
date	2008.09.15.13.53.17;	author amodra;	state Exp;
branches;
next	1.118;

1.118
date	2008.08.20.13.43.32;	author amodra;	state Exp;
branches
	1.118.2.1;
next	1.117;

1.117
date	2008.07.30.04.34.57;	author amodra;	state Exp;
branches;
next	1.116;

1.116
date	2008.06.24.01.49.36;	author amodra;	state Exp;
branches;
next	1.115;

1.115
date	2008.03.03.15.28.58;	author hjl;	state Exp;
branches;
next	1.114;

1.114
date	2007.07.12.07.16.39;	author nickc;	state Exp;
branches;
next	1.113;

1.113
date	2007.07.03.11.01.03;	author nickc;	state Exp;
branches;
next	1.112;

1.112
date	2007.03.26.12.23.48;	author amodra;	state Exp;
branches;
next	1.111;

1.111
date	2007.03.14.11.03.38;	author amodra;	state Exp;
branches;
next	1.110;

1.110
date	2007.02.22.05.54.51;	author amodra;	state Exp;
branches;
next	1.109;

1.109
date	2007.02.17.23.13.48;	author amodra;	state Exp;
branches;
next	1.108;

1.108
date	2007.02.17.07.25.49;	author amodra;	state Exp;
branches;
next	1.107;

1.107
date	2007.02.17.07.22.22;	author amodra;	state Exp;
branches;
next	1.106;

1.106
date	2007.02.17.07.20.56;	author amodra;	state Exp;
branches;
next	1.105;

1.105
date	2007.02.16.03.40.17;	author amodra;	state Exp;
branches;
next	1.104;

1.104
date	2007.02.01.14.12.18;	author amodra;	state Exp;
branches;
next	1.103;

1.103
date	2006.10.26.00.17.49;	author bje;	state Exp;
branches;
next	1.102;

1.102
date	2006.09.22.11.35.13;	author amodra;	state Exp;
branches;
next	1.101;

1.101
date	2006.05.07.23.03.48;	author amodra;	state Exp;
branches;
next	1.100;

1.100
date	2006.05.03.23.52.15;	author amodra;	state Exp;
branches;
next	1.99;

1.99
date	2005.11.17.13.32.26;	author aoliva;	state Exp;
branches
	1.99.2.1
	1.99.4.1;
next	1.98;

1.98
date	2005.11.15.22.58.38;	author amodra;	state Exp;
branches;
next	1.97;

1.97
date	2005.10.25.14.07.44;	author hjl;	state Exp;
branches;
next	1.96;

1.96
date	2005.10.24.17.51.41;	author aoliva;	state Exp;
branches;
next	1.95;

1.95
date	2005.08.29.16.30.14;	author nickc;	state Exp;
branches;
next	1.94;

1.94
date	2005.08.18.09.26.16;	author nickc;	state Exp;
branches;
next	1.93;

1.93
date	2005.08.11.01.25.20;	author amodra;	state Exp;
branches;
next	1.92;

1.92
date	2005.06.07.17.54.15;	author zack;	state Exp;
branches;
next	1.91;

1.91
date	2005.05.31.18.36.28;	author cpg;	state Exp;
branches;
next	1.90;

1.90
date	2005.05.09.14.20.49;	author hjl;	state Exp;
branches;
next	1.89;

1.89
date	2005.05.05.09.12.49;	author nickc;	state Exp;
branches;
next	1.88;

1.88
date	2005.05.03.01.04.46;	author hjl;	state Exp;
branches;
next	1.87;

1.87
date	2005.04.26.17.15.18;	author hjl;	state Exp;
branches;
next	1.86;

1.86
date	2005.04.20.17.39.57;	author hjl;	state Exp;
branches;
next	1.85;

1.85
date	2005.03.03.01.29.53;	author amodra;	state Exp;
branches;
next	1.84;

1.84
date	2005.03.01.02.00.14;	author amodra;	state Exp;
branches;
next	1.83;

1.83
date	2005.03.01.00.43.57;	author amodra;	state Exp;
branches;
next	1.82;

1.82
date	2005.02.07.03.13.10;	author hp;	state Exp;
branches;
next	1.81;

1.81
date	2005.01.21.05.54.38;	author bje;	state Exp;
branches;
next	1.80;

1.80
date	2005.01.10.17.22.49;	author hjl;	state Exp;
branches;
next	1.79;

1.79
date	2004.11.03.01.54.24;	author hp;	state Exp;
branches;
next	1.78;

1.78
date	2004.08.05.16.55.00;	author bwilson;	state Exp;
branches;
next	1.77;

1.77
date	2004.07.02.06.40.19;	author amodra;	state Exp;
branches;
next	1.76;

1.76
date	2003.12.06.16.16.51;	author kazu;	state Exp;
branches;
next	1.75;

1.75
date	2003.11.23.02.14.21;	author kazu;	state Exp;
branches;
next	1.74;

1.74
date	2003.08.16.13.35.08;	author amodra;	state Exp;
branches;
next	1.73;

1.73
date	2003.06.24.11.10.41;	author nickc;	state Exp;
branches;
next	1.72;

1.72
date	2003.06.11.10.32.08;	author ths;	state Exp;
branches;
next	1.71;

1.71
date	2003.04.07.03.54.00;	author ths;	state Exp;
branches;
next	1.70;

1.70
date	2003.04.01.15.50.29;	author nickc;	state Exp;
branches;
next	1.69;

1.69
date	2003.02.12.23.21.08;	author amodra;	state Exp;
branches;
next	1.68;

1.68
date	2003.01.23.12.51.04;	author amodra;	state Exp;
branches;
next	1.67;

1.67
date	2002.12.12.22.46.45;	author amodra;	state Exp;
branches;
next	1.66;

1.66
date	2002.11.30.08.39.42;	author amodra;	state Exp;
branches;
next	1.65;

1.65
date	2002.11.28.14.13.51;	author jakub;	state Exp;
branches;
next	1.64;

1.64
date	2002.11.20.12.56.01;	author amodra;	state Exp;
branches;
next	1.63;

1.63
date	2002.11.01.10.42.25;	author amodra;	state Exp;
branches;
next	1.62;

1.62
date	2002.09.23.11.58.00;	author dj;	state Exp;
branches;
next	1.61;

1.61
date	2002.09.19.23.51.35;	author amodra;	state Exp;
branches;
next	1.60;

1.60
date	2002.09.05.00.01.15;	author amodra;	state Exp;
branches;
next	1.59;

1.59
date	2002.08.28.03.35.59;	author amodra;	state Exp;
branches;
next	1.58;

1.58
date	2002.06.08.07.37.14;	author amodra;	state Exp;
branches
	1.58.2.1;
next	1.57;

1.57
date	2002.05.23.13.12.51;	author jakub;	state Exp;
branches;
next	1.56;

1.56
date	2002.05.23.08.08.46;	author amodra;	state Exp;
branches;
next	1.55;

1.55
date	2002.05.13.01.23.51;	author amodra;	state Exp;
branches;
next	1.54;

1.54
date	2002.05.01.00.33.09;	author amodra;	state Exp;
branches;
next	1.53;

1.53
date	2002.03.06.04.59.35;	author amodra;	state Exp;
branches;
next	1.52;

1.52
date	2002.01.05.13.13.16;	author amodra;	state Exp;
branches
	1.52.2.1;
next	1.51;

1.51
date	2001.11.28.19.15.14;	author jakub;	state Exp;
branches;
next	1.50;

1.50
date	2001.11.23.12.17.21;	author jakub;	state Exp;
branches;
next	1.49;

1.49
date	2001.11.15.21.28.53;	author nickc;	state Exp;
branches;
next	1.48;

1.48
date	2001.11.13.14.22.40;	author twall;	state Exp;
branches;
next	1.47;

1.47
date	2001.10.18.17.38.53;	author hp;	state Exp;
branches;
next	1.46;

1.46
date	2001.09.18.10.08.14;	author amodra;	state Exp;
branches;
next	1.45;

1.45
date	2001.09.09.14.01.16;	author amodra;	state Exp;
branches;
next	1.44;

1.44
date	2001.08.01.01.44.25;	author amodra;	state Exp;
branches;
next	1.43;

1.43
date	2001.07.26.03.39.29;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2001.07.23.13.03.39;	author amodra;	state Exp;
branches;
next	1.41;

1.41
date	2001.07.03.15.04.19;	author nickc;	state Exp;
branches;
next	1.40;

1.40
date	2001.06.27.08.49.42;	author nickc;	state Exp;
branches;
next	1.39;

1.39
date	2001.06.27.07.02.24;	author amodra;	state Exp;
branches;
next	1.38;

1.38
date	2001.06.27.03.14.47;	author amodra;	state Exp;
branches;
next	1.37;

1.37
date	2001.05.27.12.17.38;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2001.05.26.12.45.15;	author amodra;	state Exp;
branches;
next	1.35;

1.35
date	2001.05.24.23.33.00;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2001.05.24.08.19.32;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2001.05.22.10.23.48;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2001.04.13.00.34.36;	author jakub;	state Exp;
branches;
next	1.31;

1.31
date	2001.04.04.03.05.47;	author hp;	state Exp;
branches;
next	1.30;

1.30
date	2001.03.30.02.19.36;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2001.03.23.18.15.49;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2001.03.20.03.12.01;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2001.03.08.23.24.22;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	2001.02.13.21.27.51;	author ian;	state Exp;
branches;
next	1.25;

1.25
date	2000.12.28.19.14.37;	author rth;	state Exp;
branches
	1.25.2.1;
next	1.24;

1.24
date	2000.12.28.10.07.55;	author rth;	state Exp;
branches;
next	1.23;

1.23
date	2000.11.29.21.42.41;	author rth;	state Exp;
branches;
next	1.22;

1.22
date	2000.11.07.01.18.45;	author kazu;	state Exp;
branches;
next	1.21;

1.21
date	2000.10.07.12.52.15;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2000.09.05.03.53.02;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2000.08.23.18.20.44;	author aoliva;	state Exp;
branches;
next	1.18;

1.18
date	2000.08.22.04.52.39;	author aoliva;	state Exp;
branches;
next	1.17;

1.17
date	2000.08.22.01.20.41;	author echristo;	state Exp;
branches;
next	1.16;

1.16
date	2000.08.18.18.45.05;	author aoliva;	state Exp;
branches;
next	1.15;

1.15
date	2000.07.20.20.07.09;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2000.06.29.23.10.08;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.29.22.51.58;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2000.04.03.12.05.31;	author hp;	state Exp;
branches;
next	1.11;

1.11
date	99.09.12.03.44.41;	author ian;	state Exp;
branches;
next	1.10;

1.10
date	99.09.11.14.59.14;	author ian;	state Exp;
branches;
next	1.9;

1.9
date	99.07.28.23.19.26;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	99.07.14.14.02.33;	author ian;	state Exp;
branches;
next	1.7;

1.7
date	99.07.11.20.20.01;	author ian;	state Exp;
branches;
next	1.6;

1.6
date	99.06.12.22.15.51;	author ian;	state Exp;
branches;
next	1.5;

1.5
date	99.06.12.16.49.45;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	99.06.11.19.03.05;	author ian;	state Exp;
branches;
next	1.3;

1.3
date	99.06.03.00.29.09;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.05.17.03.21.46;	author amodra;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.28.41;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.151.2.1
date	2013.01.21.13.48.43;	author amodra;	state Exp;
branches;
next	;

1.145.2.1
date	2011.11.15.13.10.06;	author macro;	state Exp;
branches;
next	;

1.136.2.1
date	2011.02.01.12.25.40;	author amodra;	state Exp;
branches;
next	;

1.126.2.1
date	2009.09.11.15.28.43;	author nickc;	state Exp;
branches;
next	1.126.2.2;

1.126.2.2
date	2010.01.30.09.58.02;	author rsandifo;	state Exp;
branches;
next	;

1.118.2.1
date	2008.09.15.13.56.31;	author amodra;	state Exp;
branches;
next	1.118.2.2;

1.118.2.2
date	2008.09.19.10.53.51;	author amodra;	state Exp;
branches;
next	;

1.99.2.1
date	2006.08.22.15.08.31;	author jsm28;	state Exp;
branches;
next	;

1.99.4.1
date	2006.05.10.02.11.16;	author amodra;	state Exp;
branches;
next	;

1.58.2.1
date	2002.09.23.22.14.22;	author drow;	state Exp;
branches;
next	1.58.2.2;

1.58.2.2
date	2002.11.20.13.11.01;	author amodra;	state Exp;
branches;
next	;

1.52.2.1
date	2002.03.28.06.25.03;	author amodra;	state Exp;
branches;
next	;

1.25.2.1
date	2001.03.30.03.11.27;	author amodra;	state Exp;
branches;
next	1.25.2.2;

1.25.2.2
date	2001.05.23.03.41.09;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.28.41;	author rth;	state Exp;
branches;
next	;


desc
@@


1.156
log
@	gas/
	* write.c (resolve_reloc_expr_symbols): On REL targets don't
	convert relocs who have no relocatable field either.  Rephrase
	the conditional so that the PC-relative check is only applied
	for REL targets.

	gas/testsuite/
	* gas/mips/jalr3.d: New test.
	* gas/mips/jalr3-n32.d: New test.
	* gas/mips/jalr3-n64.d: New test.
	* gas/mips/jalr3.s: New test source.
	* gas/mips/mips.exp: Run the new tests.

	ld/testsuite/
	* ld-mips-elf/jalr3.dd: New test.
	* ld-mips-elf/jalr3.ld: New test linker script.
	* ld-mips-elf/mips-elf.exp: Run the new test.
@
text
@/* write.c - emit .o file
   Copyright 1986, 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997,
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009,
   2010, 2011, 2012 Free Software Foundation, Inc.

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* This thing should be set up to do byteordering correctly.  But...  */

#include "as.h"
#include "subsegs.h"
#include "obstack.h"
#include "output-file.h"
#include "dwarf2dbg.h"
#include "libbfd.h"
#include "compress-debug.h"

#ifndef TC_FORCE_RELOCATION
#define TC_FORCE_RELOCATION(FIX)		\
  (generic_force_reloc (FIX))
#endif

#ifndef TC_FORCE_RELOCATION_ABS
#define TC_FORCE_RELOCATION_ABS(FIX)		\
  (TC_FORCE_RELOCATION (FIX))
#endif

#ifndef TC_FORCE_RELOCATION_LOCAL
#define TC_FORCE_RELOCATION_LOCAL(FIX)		\
  (!(FIX)->fx_pcrel				\
   || TC_FORCE_RELOCATION (FIX))
#endif

#ifndef TC_FORCE_RELOCATION_SUB_SAME
#define TC_FORCE_RELOCATION_SUB_SAME(FIX, SEG)	\
  (! SEG_NORMAL (SEG))
#endif

#ifndef md_register_arithmetic
# define md_register_arithmetic 1
#endif

#ifndef TC_FORCE_RELOCATION_SUB_ABS
#define TC_FORCE_RELOCATION_SUB_ABS(FIX, SEG)	\
  (!md_register_arithmetic && (SEG) == reg_section)
#endif

#ifndef TC_FORCE_RELOCATION_SUB_LOCAL
#ifdef DIFF_EXPR_OK
#define TC_FORCE_RELOCATION_SUB_LOCAL(FIX, SEG)	\
  (!md_register_arithmetic && (SEG) == reg_section)
#else
#define TC_FORCE_RELOCATION_SUB_LOCAL(FIX, SEG)	1
#endif
#endif

#ifndef TC_VALIDATE_FIX_SUB
#ifdef UNDEFINED_DIFFERENCE_OK
/* The PA needs this for PIC code generation.  */
#define TC_VALIDATE_FIX_SUB(FIX, SEG)			\
  (md_register_arithmetic || (SEG) != reg_section)
#else
#define TC_VALIDATE_FIX_SUB(FIX, SEG)			\
  ((md_register_arithmetic || (SEG) != reg_section)	\
   && ((FIX)->fx_r_type == BFD_RELOC_GPREL32		\
       || (FIX)->fx_r_type == BFD_RELOC_GPREL16))
#endif
#endif

#ifndef TC_LINKRELAX_FIXUP
#define TC_LINKRELAX_FIXUP(SEG) 1
#endif

#ifndef MD_APPLY_SYM_VALUE
#define MD_APPLY_SYM_VALUE(FIX) 1
#endif

#ifndef TC_FINALIZE_SYMS_BEFORE_SIZE_SEG
#define TC_FINALIZE_SYMS_BEFORE_SIZE_SEG 1
#endif

#ifndef	MD_PCREL_FROM_SECTION
#define MD_PCREL_FROM_SECTION(FIX, SEC) md_pcrel_from (FIX)
#endif

#ifndef TC_FAKE_LABEL
#define TC_FAKE_LABEL(NAME) (strcmp ((NAME), FAKE_LABEL_NAME) == 0)
#endif

/* Positive values of TC_FX_SIZE_SLACK allow a target to define
   fixups that far past the end of a frag.  Having such fixups
   is of course most most likely a bug in setting fx_size correctly.
   A negative value disables the fixup check entirely, which is
   appropriate for something like the Renesas / SuperH SH_COUNT
   reloc.  */
#ifndef TC_FX_SIZE_SLACK
#define TC_FX_SIZE_SLACK(FIX) 0
#endif

/* Used to control final evaluation of expressions.  */
int finalize_syms = 0;

int symbol_table_frozen;

symbolS *abs_section_sym;

/* Remember the value of dot when parsing expressions.  */
addressT dot_value;

/* The frag that dot_value is based from.  */
fragS *dot_frag;

/* Relocs generated by ".reloc" pseudo.  */
struct reloc_list* reloc_list;

void print_fixup (fixS *);

/* We generally attach relocs to frag chains.  However, after we have
   chained these all together into a segment, any relocs we add after
   that must be attached to a segment.  This will include relocs added
   in md_estimate_size_for_relax, for example.  */
static int frags_chained = 0;

static int n_fixups;

#define RELOC_ENUM enum bfd_reloc_code_real

/* Create a fixS in obstack 'notes'.  */

static fixS *
fix_new_internal (fragS *frag,		/* Which frag?  */
		  int where,		/* Where in that frag?  */
		  int size,		/* 1, 2, or 4 usually.  */
		  symbolS *add_symbol,	/* X_add_symbol.  */
		  symbolS *sub_symbol,	/* X_op_symbol.  */
		  offsetT offset,	/* X_add_number.  */
		  int pcrel,		/* TRUE if PC-relative relocation.  */
		  RELOC_ENUM r_type	/* Relocation type.  */,
		  int at_beginning)	/* Add to the start of the list?  */
{
  fixS *fixP;

  n_fixups++;

  fixP = (fixS *) obstack_alloc (&notes, sizeof (fixS));

  fixP->fx_frag = frag;
  fixP->fx_where = where;
  fixP->fx_size = size;
  /* We've made fx_size a narrow field; check that it's wide enough.  */
  if (fixP->fx_size != size)
    {
      as_bad (_("field fx_size too small to hold %d"), size);
      abort ();
    }
  fixP->fx_addsy = add_symbol;
  fixP->fx_subsy = sub_symbol;
  fixP->fx_offset = offset;
  fixP->fx_dot_value = dot_value;
  fixP->fx_dot_frag = dot_frag;
  fixP->fx_pcrel = pcrel;
  fixP->fx_r_type = r_type;
  fixP->fx_im_disp = 0;
  fixP->fx_pcrel_adjust = 0;
  fixP->fx_bit_fixP = 0;
  fixP->fx_addnumber = 0;
  fixP->fx_tcbit = 0;
  fixP->fx_tcbit2 = 0;
  fixP->fx_done = 0;
  fixP->fx_no_overflow = 0;
  fixP->fx_signed = 0;

#ifdef USING_CGEN
  fixP->fx_cgen.insn = NULL;
  fixP->fx_cgen.opinfo = 0;
#endif

#ifdef TC_FIX_TYPE
  TC_INIT_FIX_DATA (fixP);
#endif

  as_where (&fixP->fx_file, &fixP->fx_line);

  {

    fixS **seg_fix_rootP = (frags_chained
			    ? &seg_info (now_seg)->fix_root
			    : &frchain_now->fix_root);
    fixS **seg_fix_tailP = (frags_chained
			    ? &seg_info (now_seg)->fix_tail
			    : &frchain_now->fix_tail);

    if (at_beginning)
      {
	fixP->fx_next = *seg_fix_rootP;
	*seg_fix_rootP = fixP;
	if (fixP->fx_next == NULL)
	  *seg_fix_tailP = fixP;
      }
    else
      {
	fixP->fx_next = NULL;
	if (*seg_fix_tailP)
	  (*seg_fix_tailP)->fx_next = fixP;
	else
	  *seg_fix_rootP = fixP;
	*seg_fix_tailP = fixP;
      }
  }

  return fixP;
}

/* Create a fixup relative to a symbol (plus a constant).  */

fixS *
fix_new (fragS *frag,		/* Which frag?  */
	 int where,			/* Where in that frag?  */
	 int size,			/* 1, 2, or 4 usually.  */
	 symbolS *add_symbol,	/* X_add_symbol.  */
	 offsetT offset,		/* X_add_number.  */
	 int pcrel,			/* TRUE if PC-relative relocation.  */
	 RELOC_ENUM r_type		/* Relocation type.  */)
{
  return fix_new_internal (frag, where, size, add_symbol,
			   (symbolS *) NULL, offset, pcrel, r_type, FALSE);
}

/* Create a fixup for an expression.  Currently we only support fixups
   for difference expressions.  That is itself more than most object
   file formats support anyhow.  */

fixS *
fix_new_exp (fragS *frag,		/* Which frag?  */
	     int where,			/* Where in that frag?  */
	     int size,			/* 1, 2, or 4 usually.  */
	     expressionS *exp,		/* Expression.  */
	     int pcrel,			/* TRUE if PC-relative relocation.  */
	     RELOC_ENUM r_type		/* Relocation type.  */)
{
  symbolS *add = NULL;
  symbolS *sub = NULL;
  offsetT off = 0;

  switch (exp->X_op)
    {
    case O_absent:
      break;

    case O_register:
      as_bad (_("register value used as expression"));
      break;

    case O_add:
      /* This comes up when _GLOBAL_OFFSET_TABLE_+(.-L0) is read, if
	 the difference expression cannot immediately be reduced.  */
      {
	symbolS *stmp = make_expr_symbol (exp);

	exp->X_op = O_symbol;
	exp->X_op_symbol = 0;
	exp->X_add_symbol = stmp;
	exp->X_add_number = 0;

	return fix_new_exp (frag, where, size, exp, pcrel, r_type);
      }

    case O_symbol_rva:
      add = exp->X_add_symbol;
      off = exp->X_add_number;
      r_type = BFD_RELOC_RVA;
      break;

    case O_uminus:
      sub = exp->X_add_symbol;
      off = exp->X_add_number;
      break;

    case O_subtract:
      sub = exp->X_op_symbol;
      /* Fall through.  */
    case O_symbol:
      add = exp->X_add_symbol;
      /* Fall through.  */
    case O_constant:
      off = exp->X_add_number;
      break;

    default:
      add = make_expr_symbol (exp);
      break;
    }

  return fix_new_internal (frag, where, size, add, sub, off, pcrel,
			   r_type, FALSE);
}

/* Create a fixup at the beginning of FRAG.  The arguments are the same
   as for fix_new, except that WHERE is implicitly 0.  */

fixS *
fix_at_start (fragS *frag, int size, symbolS *add_symbol,
	      offsetT offset, int pcrel, RELOC_ENUM r_type)
{
  return fix_new_internal (frag, 0, size, add_symbol,
			   (symbolS *) NULL, offset, pcrel, r_type, TRUE);
}

/* Generic function to determine whether a fixup requires a relocation.  */
int
generic_force_reloc (fixS *fix)
{
  if (fix->fx_r_type == BFD_RELOC_VTABLE_INHERIT
      || fix->fx_r_type == BFD_RELOC_VTABLE_ENTRY)
    return 1;

  if (fix->fx_addsy == NULL)
    return 0;

  return S_FORCE_RELOC (fix->fx_addsy, fix->fx_subsy == NULL);
}

/* Append a string onto another string, bumping the pointer along.  */
void
append (char **charPP, char *fromP, unsigned long length)
{
  /* Don't trust memcpy() of 0 chars.  */
  if (length == 0)
    return;

  memcpy (*charPP, fromP, length);
  *charPP += length;
}

/* This routine records the largest alignment seen for each segment.
   If the beginning of the segment is aligned on the worst-case
   boundary, all of the other alignments within it will work.  At
   least one object format really uses this info.  */

void
record_alignment (/* Segment to which alignment pertains.  */
		  segT seg,
		  /* Alignment, as a power of 2 (e.g., 1 => 2-byte
		     boundary, 2 => 4-byte boundary, etc.)  */
		  int align)
{
  if (seg == absolute_section)
    return;

  if ((unsigned int) align > bfd_get_section_alignment (stdoutput, seg))
    bfd_set_section_alignment (stdoutput, seg, align);
}

int
get_recorded_alignment (segT seg)
{
  if (seg == absolute_section)
    return 0;

  return bfd_get_section_alignment (stdoutput, seg);
}

/* Reset the section indices after removing the gas created sections.  */

static void
renumber_sections (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, void *countparg)
{
  int *countp = (int *) countparg;

  sec->index = *countp;
  ++*countp;
}

static fragS *
chain_frchains_together_1 (segT section, struct frchain *frchp)
{
  fragS dummy, *prev_frag = &dummy;
  fixS fix_dummy, *prev_fix = &fix_dummy;

  for (; frchp; frchp = frchp->frch_next)
    {
      prev_frag->fr_next = frchp->frch_root;
      prev_frag = frchp->frch_last;
      gas_assert (prev_frag->fr_type != 0);
      if (frchp->fix_root != (fixS *) NULL)
	{
	  if (seg_info (section)->fix_root == (fixS *) NULL)
	    seg_info (section)->fix_root = frchp->fix_root;
	  prev_fix->fx_next = frchp->fix_root;
	  seg_info (section)->fix_tail = frchp->fix_tail;
	  prev_fix = frchp->fix_tail;
	}
    }
  gas_assert (prev_frag != &dummy
	      && prev_frag->fr_type != 0);
  prev_frag->fr_next = 0;
  return prev_frag;
}

static void
chain_frchains_together (bfd *abfd ATTRIBUTE_UNUSED,
			 segT section,
			 void *xxx ATTRIBUTE_UNUSED)
{
  segment_info_type *info;

  /* BFD may have introduced its own sections without using
     subseg_new, so it is possible that seg_info is NULL.  */
  info = seg_info (section);
  if (info != (segment_info_type *) NULL)
    info->frchainP->frch_last
      = chain_frchains_together_1 (section, info->frchainP);

  /* Now that we've chained the frags together, we must add new fixups
     to the segment, not to the frag chain.  */
  frags_chained = 1;
}

static void
cvt_frag_to_fill (segT sec ATTRIBUTE_UNUSED, fragS *fragP)
{
  switch (fragP->fr_type)
    {
    case rs_align:
    case rs_align_code:
    case rs_align_test:
    case rs_org:
    case rs_space:
#ifdef HANDLE_ALIGN
      HANDLE_ALIGN (fragP);
#endif
      know (fragP->fr_next != NULL);
      fragP->fr_offset = (fragP->fr_next->fr_address
			  - fragP->fr_address
			  - fragP->fr_fix) / fragP->fr_var;
      if (fragP->fr_offset < 0)
	{
	  as_bad_where (fragP->fr_file, fragP->fr_line,
			_("attempt to .org/.space backwards? (%ld)"),
			(long) fragP->fr_offset);
	  fragP->fr_offset = 0;
	}
      fragP->fr_type = rs_fill;
      break;

    case rs_fill:
      break;

    case rs_leb128:
      {
	valueT value = S_GET_VALUE (fragP->fr_symbol);
	int size;

	size = output_leb128 (fragP->fr_literal + fragP->fr_fix, value,
			      fragP->fr_subtype);

	fragP->fr_fix += size;
	fragP->fr_type = rs_fill;
	fragP->fr_var = 0;
	fragP->fr_offset = 0;
	fragP->fr_symbol = NULL;
      }
      break;

    case rs_cfa:
      eh_frame_convert_frag (fragP);
      break;

    case rs_dwarf2dbg:
      dwarf2dbg_convert_frag (fragP);
      break;

    case rs_machine_dependent:
      md_convert_frag (stdoutput, sec, fragP);

      gas_assert (fragP->fr_next == NULL
	      || ((offsetT) (fragP->fr_next->fr_address - fragP->fr_address)
		  == fragP->fr_fix));

      /* After md_convert_frag, we make the frag into a ".space 0".
	 md_convert_frag() should set up any fixSs and constants
	 required.  */
      frag_wane (fragP);
      break;

#ifndef WORKING_DOT_WORD
    case rs_broken_word:
      {
	struct broken_word *lie;

	if (fragP->fr_subtype)
	  {
	    fragP->fr_fix += md_short_jump_size;
	    for (lie = (struct broken_word *) (fragP->fr_symbol);
		 lie && lie->dispfrag == fragP;
		 lie = lie->next_broken_word)
	      if (lie->added == 1)
		fragP->fr_fix += md_long_jump_size;
	  }
	frag_wane (fragP);
      }
      break;
#endif

    default:
      BAD_CASE (fragP->fr_type);
      break;
    }
#ifdef md_frag_check
  md_frag_check (fragP);
#endif
}

struct relax_seg_info
{
  int pass;
  int changed;
};

static void
relax_seg (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, void *xxx)
{
  segment_info_type *seginfo = seg_info (sec);
  struct relax_seg_info *info = (struct relax_seg_info *) xxx;

  if (seginfo && seginfo->frchainP
      && relax_segment (seginfo->frchainP->frch_root, sec, info->pass))
    info->changed = 1;
}

static void
size_seg (bfd *abfd, asection *sec, void *xxx ATTRIBUTE_UNUSED)
{
  flagword flags;
  fragS *fragp;
  segment_info_type *seginfo;
  int x;
  valueT size, newsize;

  subseg_change (sec, 0);

  seginfo = seg_info (sec);
  if (seginfo && seginfo->frchainP)
    {
      for (fragp = seginfo->frchainP->frch_root; fragp; fragp = fragp->fr_next)
	cvt_frag_to_fill (sec, fragp);
      for (fragp = seginfo->frchainP->frch_root;
	   fragp->fr_next;
	   fragp = fragp->fr_next)
	/* Walk to last elt.  */
	;
      size = fragp->fr_address + fragp->fr_fix;
    }
  else
    size = 0;

  flags = bfd_get_section_flags (abfd, sec);
  if (size == 0 && bfd_get_section_size (sec) != 0 &&
    (flags & SEC_HAS_CONTENTS) != 0)
    return;

  if (size > 0 && ! seginfo->bss)
    flags |= SEC_HAS_CONTENTS;

  flags &= ~SEC_RELOC;
  x = bfd_set_section_flags (abfd, sec, flags);
  gas_assert (x);

  newsize = md_section_align (sec, size);
  x = bfd_set_section_size (abfd, sec, newsize);
  gas_assert (x);

  /* If the size had to be rounded up, add some padding in the last
     non-empty frag.  */
  gas_assert (newsize >= size);
  if (size != newsize)
    {
      fragS *last = seginfo->frchainP->frch_last;
      fragp = seginfo->frchainP->frch_root;
      while (fragp->fr_next != last)
	fragp = fragp->fr_next;
      last->fr_address = size;
      if ((newsize - size) % fragp->fr_var == 0)
	fragp->fr_offset += (newsize - size) / fragp->fr_var;
      else
	/* If we hit this abort, it's likely due to subsegs_finish not
	   providing sufficient alignment on the last frag, and the
	   machine dependent code using alignment frags with fr_var
	   greater than 1.  */
	abort ();
    }

#ifdef tc_frob_section
  tc_frob_section (sec);
#endif
#ifdef obj_frob_section
  obj_frob_section (sec);
#endif
}

#ifdef DEBUG2
static void
dump_section_relocs (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, FILE *stream)
{
  segment_info_type *seginfo = seg_info (sec);
  fixS *fixp = seginfo->fix_root;

  if (!fixp)
    return;

  fprintf (stream, "sec %s relocs:\n", sec->name);
  while (fixp)
    {
      symbolS *s = fixp->fx_addsy;

      fprintf (stream, "  %08lx: type %d ", (unsigned long) fixp,
	       (int) fixp->fx_r_type);
      if (s == NULL)
	fprintf (stream, "no sym\n");
      else
	{
	  print_symbol_value_1 (stream, s);
	  fprintf (stream, "\n");
	}
      fixp = fixp->fx_next;
    }
}
#else
#define dump_section_relocs(ABFD,SEC,STREAM)	((void) 0)
#endif

#ifndef EMIT_SECTION_SYMBOLS
#define EMIT_SECTION_SYMBOLS 1
#endif

/* Resolve U.A.OFFSET_SYM and U.A.SYM fields of RELOC_LIST entries,
   and check for validity.  Convert RELOC_LIST from using U.A fields
   to U.B fields.  */
static void
resolve_reloc_expr_symbols (void)
{
  bfd_vma addr_mask = 1;
  struct reloc_list *r;

  /* Avoid a shift by the width of type.  */
  addr_mask <<= bfd_arch_bits_per_address (stdoutput) - 1;
  addr_mask <<= 1;
  addr_mask -= 1;

  for (r = reloc_list; r; r = r->next)
    {
      reloc_howto_type *howto = r->u.a.howto;
      expressionS *symval;
      symbolS *sym;
      bfd_vma offset, addend;
      asection *sec;

      resolve_symbol_value (r->u.a.offset_sym);
      symval = symbol_get_value_expression (r->u.a.offset_sym);

      offset = 0;
      sym = NULL;
      if (symval->X_op == O_constant)
	sym = r->u.a.offset_sym;
      else if (symval->X_op == O_symbol)
	{
	  sym = symval->X_add_symbol;
	  offset = symval->X_add_number;
	  symval = symbol_get_value_expression (symval->X_add_symbol);
	}
      if (sym == NULL
	  || symval->X_op != O_constant
	  || (sec = S_GET_SEGMENT (sym)) == NULL
	  || !SEG_NORMAL (sec))
	{
	  as_bad_where (r->file, r->line, _("invalid offset expression"));
	  sec = NULL;
	}
      else
	offset += S_GET_VALUE (sym);

      sym = NULL;
      addend = r->u.a.addend;
      if (r->u.a.sym != NULL)
	{
	  resolve_symbol_value (r->u.a.sym);
	  symval = symbol_get_value_expression (r->u.a.sym);
	  if (symval->X_op == O_constant)
	    sym = r->u.a.sym;
	  else if (symval->X_op == O_symbol)
	    {
	      sym = symval->X_add_symbol;
	      addend += symval->X_add_number;
	      symval = symbol_get_value_expression (symval->X_add_symbol);
	    }
	  if (symval->X_op != O_constant)
	    {
	      as_bad_where (r->file, r->line, _("invalid reloc expression"));
	      sec = NULL;
	    }
	  else if (sym != NULL)
	    {
	      /* Convert relocs against local symbols to refer to the
	         corresponding section symbol plus offset instead.  Keep
	         PC-relative relocs of the REL variety intact though to
		 prevent the offset from overflowing the relocated field,
	         unless it has enough bits to cover the whole address
	         space.  */
	      if (S_IS_LOCAL (sym) && !symbol_section_p (sym)
		  && (sec->use_rela_p
		      || (howto->partial_inplace
			  && (!howto->pc_relative
			      || howto->src_mask == addr_mask))))
		{
		  asection *symsec = S_GET_SEGMENT (sym);
		  if (!(((symsec->flags & SEC_MERGE) != 0
			 && addend != 0)
			|| (symsec->flags & SEC_THREAD_LOCAL) != 0))
		    {
		      addend += S_GET_VALUE (sym);
		      sym = section_symbol (symsec);
		    }
		}
	      symbol_mark_used_in_reloc (sym);
	    }
	}
      if (sym == NULL)
	{
	  if (abs_section_sym == NULL)
	    abs_section_sym = section_symbol (absolute_section);
	  sym = abs_section_sym;
	}

      r->u.b.sec = sec;
      r->u.b.s = symbol_get_bfdsym (sym);
      r->u.b.r.sym_ptr_ptr = &r->u.b.s;
      r->u.b.r.address = offset;
      r->u.b.r.addend = addend;
      r->u.b.r.howto = howto;
    }
}

/* This pass over fixups decides whether symbols can be replaced with
   section symbols.  */

static void
adjust_reloc_syms (bfd *abfd ATTRIBUTE_UNUSED,
		   asection *sec,
		   void *xxx ATTRIBUTE_UNUSED)
{
  segment_info_type *seginfo = seg_info (sec);
  fixS *fixp;

  if (seginfo == NULL)
    return;

  dump_section_relocs (abfd, sec, stderr);

  for (fixp = seginfo->fix_root; fixp; fixp = fixp->fx_next)
    if (fixp->fx_done)
      /* Ignore it.  */
      ;
    else if (fixp->fx_addsy)
      {
	symbolS *sym;
	asection *symsec;

#ifdef DEBUG5
	fprintf (stderr, "\n\nadjusting fixup:\n");
	print_fixup (fixp);
#endif

	sym = fixp->fx_addsy;

	/* All symbols should have already been resolved at this
	   point.  It is possible to see unresolved expression
	   symbols, though, since they are not in the regular symbol
	   table.  */
	resolve_symbol_value (sym);

	if (fixp->fx_subsy != NULL)
	  resolve_symbol_value (fixp->fx_subsy);

	/* If this symbol is equated to an undefined or common symbol,
	   convert the fixup to being against that symbol.  */
	while (symbol_equated_reloc_p (sym)
	       || S_IS_WEAKREFR (sym))
	  {
	    symbolS *newsym = symbol_get_value_expression (sym)->X_add_symbol;
	    if (sym == newsym)
	      break;
	    fixp->fx_offset += symbol_get_value_expression (sym)->X_add_number;
	    fixp->fx_addsy = newsym;
	    sym = newsym;
	  }

	if (symbol_mri_common_p (sym))
	  {
	    fixp->fx_offset += S_GET_VALUE (sym);
	    fixp->fx_addsy = symbol_get_value_expression (sym)->X_add_symbol;
	    continue;
	  }

	/* If the symbol is undefined, common, weak, or global (ELF
	   shared libs), we can't replace it with the section symbol.  */
	if (S_FORCE_RELOC (fixp->fx_addsy, 1))
	  continue;

	/* Is there some other (target cpu dependent) reason we can't adjust
	   this one?  (E.g. relocations involving function addresses on
	   the PA.  */
#ifdef tc_fix_adjustable
	if (! tc_fix_adjustable (fixp))
	  continue;
#endif

	/* Since we're reducing to section symbols, don't attempt to reduce
	   anything that's already using one.  */
	if (symbol_section_p (sym))
	  continue;

	symsec = S_GET_SEGMENT (sym);
	if (symsec == NULL)
	  abort ();

	if (bfd_is_abs_section (symsec))
	  {
	    /* The fixup_segment routine normally will not use this
	       symbol in a relocation.  */
	    continue;
	  }

	/* Don't try to reduce relocs which refer to non-local symbols
	   in .linkonce sections.  It can lead to confusion when a
	   debugging section refers to a .linkonce section.  I hope
	   this will always be correct.  */
	if (symsec != sec && ! S_IS_LOCAL (sym))
	  {
	    if ((symsec->flags & SEC_LINK_ONCE) != 0
		|| (IS_ELF
		    /* The GNU toolchain uses an extension for ELF: a
		       section beginning with the magic string
		       .gnu.linkonce is a linkonce section.  */
		    && strncmp (segment_name (symsec), ".gnu.linkonce",
				sizeof ".gnu.linkonce" - 1) == 0))
	      continue;
	  }

	/* Never adjust a reloc against local symbol in a merge section
	   with non-zero addend.  */
	if ((symsec->flags & SEC_MERGE) != 0
	    && (fixp->fx_offset != 0 || fixp->fx_subsy != NULL))
	  continue;

	/* Never adjust a reloc against TLS local symbol.  */
	if ((symsec->flags & SEC_THREAD_LOCAL) != 0)
	  continue;

	/* We refetch the segment when calling section_symbol, rather
	   than using symsec, because S_GET_VALUE may wind up changing
	   the section when it calls resolve_symbol_value.  */
	fixp->fx_offset += S_GET_VALUE (sym);
	fixp->fx_addsy = section_symbol (S_GET_SEGMENT (sym));
#ifdef DEBUG5
	fprintf (stderr, "\nadjusted fixup:\n");
	print_fixup (fixp);
#endif
      }

  dump_section_relocs (abfd, sec, stderr);
}

/* fixup_segment()

   Go through all the fixS's in a segment and see which ones can be
   handled now.  (These consist of fixS where we have since discovered
   the value of a symbol, or the address of the frag involved.)
   For each one, call md_apply_fix to put the fix into the frag data.
   Ones that we couldn't completely handle here will be output later
   by emit_relocations.  */

static void
fixup_segment (fixS *fixP, segT this_segment)
{
  valueT add_number;
  fragS *fragP;
  segT add_symbol_segment = absolute_section;

  if (fixP != NULL && abs_section_sym == NULL)
    abs_section_sym = section_symbol (absolute_section);

  /* If the linker is doing the relaxing, we must not do any fixups.

     Well, strictly speaking that's not true -- we could do any that
     are PC-relative and don't cross regions that could change size.
     And for the i960 we might be able to turn callx/callj into bal
     anyways in cases where we know the maximum displacement.  */
  if (linkrelax && TC_LINKRELAX_FIXUP (this_segment))
    {
      for (; fixP; fixP = fixP->fx_next)
	if (!fixP->fx_done)
	  {
	    if (fixP->fx_addsy == NULL)
	      {
		/* There was no symbol required by this relocation.
		   However, BFD doesn't really handle relocations
		   without symbols well. So fake up a local symbol in
		   the absolute section.  */
		fixP->fx_addsy = abs_section_sym;
	      }
	    symbol_mark_used_in_reloc (fixP->fx_addsy);
	    if (fixP->fx_subsy != NULL)
	      symbol_mark_used_in_reloc (fixP->fx_subsy);
	  }
      return;
    }

  for (; fixP; fixP = fixP->fx_next)
    {
#ifdef DEBUG5
      fprintf (stderr, "\nprocessing fixup:\n");
      print_fixup (fixP);
#endif

      fragP = fixP->fx_frag;
      know (fragP);
#ifdef TC_VALIDATE_FIX
      TC_VALIDATE_FIX (fixP, this_segment, skip);
#endif
      add_number = fixP->fx_offset;

      if (fixP->fx_addsy != NULL)
	add_symbol_segment = S_GET_SEGMENT (fixP->fx_addsy);

      if (fixP->fx_subsy != NULL)
	{
	  segT sub_symbol_segment;
	  resolve_symbol_value (fixP->fx_subsy);
	  sub_symbol_segment = S_GET_SEGMENT (fixP->fx_subsy);
	  if (fixP->fx_addsy != NULL
	      && sub_symbol_segment == add_symbol_segment
	      && !S_FORCE_RELOC (fixP->fx_addsy, 0)
	      && !S_FORCE_RELOC (fixP->fx_subsy, 0)
	      && !TC_FORCE_RELOCATION_SUB_SAME (fixP, add_symbol_segment))
	    {
	      add_number += S_GET_VALUE (fixP->fx_addsy);
	      add_number -= S_GET_VALUE (fixP->fx_subsy);
	      fixP->fx_offset = add_number;
	      fixP->fx_addsy = NULL;
	      fixP->fx_subsy = NULL;
#ifdef TC_M68K
	      /* See the comment below about 68k weirdness.  */
	      fixP->fx_pcrel = 0;
#endif
	    }
	  else if (sub_symbol_segment == absolute_section
		   && !S_FORCE_RELOC (fixP->fx_subsy, 0)
		   && !TC_FORCE_RELOCATION_SUB_ABS (fixP, add_symbol_segment))
	    {
	      add_number -= S_GET_VALUE (fixP->fx_subsy);
	      fixP->fx_offset = add_number;
	      fixP->fx_subsy = NULL;
	    }
	  else if (sub_symbol_segment == this_segment
		   && !S_FORCE_RELOC (fixP->fx_subsy, 0)
		   && !TC_FORCE_RELOCATION_SUB_LOCAL (fixP, add_symbol_segment))
	    {
	      add_number -= S_GET_VALUE (fixP->fx_subsy);
	      fixP->fx_offset = (add_number + fixP->fx_dot_value
				 + fixP->fx_dot_frag->fr_address);

	      /* Make it pc-relative.  If the back-end code has not
		 selected a pc-relative reloc, cancel the adjustment
		 we do later on all pc-relative relocs.  */
	      if (0
#ifdef TC_M68K
		  /* Do this for m68k even if it's already described
		     as pc-relative.  On the m68k, an operand of
		     "pc@@(foo-.-2)" should address "foo" in a
		     pc-relative mode.  */
		  || 1
#endif
		  || !fixP->fx_pcrel)
		add_number += MD_PCREL_FROM_SECTION (fixP, this_segment);
	      fixP->fx_subsy = NULL;
	      fixP->fx_pcrel = 1;
	    }
	  else if (!TC_VALIDATE_FIX_SUB (fixP, add_symbol_segment))
	    {
	      if (!md_register_arithmetic
		  && (add_symbol_segment == reg_section
		      || sub_symbol_segment == reg_section))
		as_bad_where (fixP->fx_file, fixP->fx_line,
			      _("register value used as expression"));
	      else
		as_bad_where (fixP->fx_file, fixP->fx_line,
			      _("can't resolve `%s' {%s section} - `%s' {%s section}"),
			      fixP->fx_addsy ? S_GET_NAME (fixP->fx_addsy) : "0",
			      segment_name (add_symbol_segment),
			      S_GET_NAME (fixP->fx_subsy),
			      segment_name (sub_symbol_segment));
	    }
	  else if (sub_symbol_segment != undefined_section
		   && ! bfd_is_com_section (sub_symbol_segment)
		   && MD_APPLY_SYM_VALUE (fixP))
	    add_number -= S_GET_VALUE (fixP->fx_subsy);
	}

      if (fixP->fx_addsy)
	{
	  if (add_symbol_segment == this_segment
	      && !S_FORCE_RELOC (fixP->fx_addsy, 0)
	      && !TC_FORCE_RELOCATION_LOCAL (fixP))
	    {
	      /* This fixup was made when the symbol's segment was
		 SEG_UNKNOWN, but it is now in the local segment.
		 So we know how to do the address without relocation.  */
	      add_number += S_GET_VALUE (fixP->fx_addsy);
	      fixP->fx_offset = add_number;
	      if (fixP->fx_pcrel)
		add_number -= MD_PCREL_FROM_SECTION (fixP, this_segment);
	      fixP->fx_addsy = NULL;
	      fixP->fx_pcrel = 0;
	    }
	  else if (add_symbol_segment == absolute_section
		   && !S_FORCE_RELOC (fixP->fx_addsy, 0)
		   && !TC_FORCE_RELOCATION_ABS (fixP))
	    {
	      add_number += S_GET_VALUE (fixP->fx_addsy);
	      fixP->fx_offset = add_number;
	      fixP->fx_addsy = NULL;
	    }
	  else if (add_symbol_segment != undefined_section
		   && ! bfd_is_com_section (add_symbol_segment)
		   && MD_APPLY_SYM_VALUE (fixP))
	    add_number += S_GET_VALUE (fixP->fx_addsy);
	}

      if (fixP->fx_pcrel)
	{
	  add_number -= MD_PCREL_FROM_SECTION (fixP, this_segment);
	  if (!fixP->fx_done && fixP->fx_addsy == NULL)
	    {
	      /* There was no symbol required by this relocation.
		 However, BFD doesn't really handle relocations
		 without symbols well. So fake up a local symbol in
		 the absolute section.  */
	      fixP->fx_addsy = abs_section_sym;
	    }
	}

      if (!fixP->fx_done)
	md_apply_fix (fixP, &add_number, this_segment);

      if (!fixP->fx_done)
	{
	  if (fixP->fx_addsy == NULL)
	    fixP->fx_addsy = abs_section_sym;
	  symbol_mark_used_in_reloc (fixP->fx_addsy);
	  if (fixP->fx_subsy != NULL)
	    symbol_mark_used_in_reloc (fixP->fx_subsy);
	}

      if (!fixP->fx_bit_fixP && !fixP->fx_no_overflow && fixP->fx_size != 0)
	{
	  if (fixP->fx_size < sizeof (valueT))
	    {
	      valueT mask;

	      mask = 0;
	      mask--;		/* Set all bits to one.  */
	      mask <<= fixP->fx_size * 8 - (fixP->fx_signed ? 1 : 0);
	      if ((add_number & mask) != 0 && (add_number & mask) != mask)
		{
		  char buf[50], buf2[50];
		  sprint_value (buf, fragP->fr_address + fixP->fx_where);
		  if (add_number > 1000)
		    sprint_value (buf2, add_number);
		  else
		    sprintf (buf2, "%ld", (long) add_number);
		  as_bad_where (fixP->fx_file, fixP->fx_line,
				_("value of %s too large for field of %d bytes at %s"),
				buf2, fixP->fx_size, buf);
		} /* Generic error checking.  */
	    }
#ifdef WARN_SIGNED_OVERFLOW_WORD
	  /* Warn if a .word value is too large when treated as a signed
	     number.  We already know it is not too negative.  This is to
	     catch over-large switches generated by gcc on the 68k.  */
	  if (!flag_signed_overflow_ok
	      && fixP->fx_size == 2
	      && add_number > 0x7fff)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("signed .word overflow; switch may be too large; %ld at 0x%lx"),
			  (long) add_number,
			  (long) (fragP->fr_address + fixP->fx_where));
#endif
	}			/* Not a bit fix.  */

#ifdef TC_VALIDATE_FIX
    skip:  ATTRIBUTE_UNUSED_LABEL
      ;
#endif
#ifdef DEBUG5
      fprintf (stderr, "result:\n");
      print_fixup (fixP);
#endif
    }				/* For each fixS in this segment.  */
}

static void
fix_segment (bfd *abfd ATTRIBUTE_UNUSED,
	     asection *sec,
	     void *xxx ATTRIBUTE_UNUSED)
{
  segment_info_type *seginfo = seg_info (sec);

  fixup_segment (seginfo->fix_root, sec);
}

static void
install_reloc (asection *sec, arelent *reloc, fragS *fragp,
	       char *file, unsigned int line)
{
  char *err;
  bfd_reloc_status_type s;
  asymbol *sym;

  if (reloc->sym_ptr_ptr != NULL
      && (sym = *reloc->sym_ptr_ptr) != NULL
      && (sym->flags & BSF_KEEP) == 0
      && ((sym->flags & BSF_SECTION_SYM) == 0
	  || (EMIT_SECTION_SYMBOLS
	      && !bfd_is_abs_section (sym->section))))
    as_bad_where (file, line, _("redefined symbol cannot be used on reloc"));

  s = bfd_install_relocation (stdoutput, reloc,
			      fragp->fr_literal, fragp->fr_address,
			      sec, &err);
  switch (s)
    {
    case bfd_reloc_ok:
      break;
    case bfd_reloc_overflow:
      as_bad_where (file, line, _("relocation overflow"));
      break;
    case bfd_reloc_outofrange:
      as_bad_where (file, line, _("relocation out of range"));
      break;
    default:
      as_fatal (_("%s:%u: bad return from bfd_install_relocation: %x"),
		file, line, s);
    }
}

static fragS *
get_frag_for_reloc (fragS *last_frag,
		    const segment_info_type *seginfo,
		    const struct reloc_list *r)
{
  fragS *f;

  for (f = last_frag; f != NULL; f = f->fr_next)
    if (f->fr_address <= r->u.b.r.address
	&& r->u.b.r.address < f->fr_address + f->fr_fix)
      return f;

  for (f = seginfo->frchainP->frch_root; f != NULL; f = f->fr_next)
    if (f->fr_address <= r->u.b.r.address
	&& r->u.b.r.address < f->fr_address + f->fr_fix)
      return f;

  as_bad_where (r->file, r->line,
		_("reloc not within (fixed part of) section"));
  return NULL;
}

static void
write_relocs (bfd *abfd, asection *sec, void *xxx ATTRIBUTE_UNUSED)
{
  segment_info_type *seginfo = seg_info (sec);
  unsigned int n;
  struct reloc_list *my_reloc_list, **rp, *r;
  arelent **relocs;
  fixS *fixp;
  fragS *last_frag;

  /* If seginfo is NULL, we did not create this section; don't do
     anything with it.  */
  if (seginfo == NULL)
    return;

  n = 0;
  for (fixp = seginfo->fix_root; fixp; fixp = fixp->fx_next)
    if (!fixp->fx_done)
      n++;

#ifdef RELOC_EXPANSION_POSSIBLE
  n *= MAX_RELOC_EXPANSION;
#endif

  /* Extract relocs for this section from reloc_list.  */
  rp = &reloc_list;
  my_reloc_list = NULL;
  while ((r = *rp) != NULL)
    {
      if (r->u.b.sec == sec)
	{
	  *rp = r->next;
	  r->next = my_reloc_list;
	  my_reloc_list = r;
	  n++;
	}
      else
	rp = &r->next;
    }

  relocs = (arelent **) xcalloc (n, sizeof (arelent *));

  n = 0;
  r = my_reloc_list;
  last_frag = NULL;
  for (fixp = seginfo->fix_root; fixp != (fixS *) NULL; fixp = fixp->fx_next)
    {
      int fx_size, slack;
      offsetT loc;
      arelent **reloc;
#ifndef RELOC_EXPANSION_POSSIBLE
      arelent *rel;

      reloc = &rel;
#endif

      if (fixp->fx_done)
	continue;

      fx_size = fixp->fx_size;
      slack = TC_FX_SIZE_SLACK (fixp);
      if (slack > 0)
	fx_size = fx_size > slack ? fx_size - slack : 0;
      loc = fixp->fx_where + fx_size;
      if (slack >= 0 && loc > fixp->fx_frag->fr_fix)
	as_bad_where (fixp->fx_file, fixp->fx_line,
		      _("internal error: fixup not contained within frag"));

#ifndef RELOC_EXPANSION_POSSIBLE
      *reloc = tc_gen_reloc (sec, fixp);
#else
      reloc = tc_gen_reloc (sec, fixp);
#endif

      while (*reloc)
	{
	  while (r != NULL && r->u.b.r.address < (*reloc)->address)
	    {
	      fragS *f = get_frag_for_reloc (last_frag, seginfo, r);
	      if (f != NULL)
		{
		  last_frag = f;
		  relocs[n++] = &r->u.b.r;
		  install_reloc (sec, &r->u.b.r, f, r->file, r->line);
		}
	      r = r->next;
	    }
	  relocs[n++] = *reloc;
	  install_reloc (sec, *reloc, fixp->fx_frag,
			 fixp->fx_file, fixp->fx_line);
#ifndef RELOC_EXPANSION_POSSIBLE
	  break;
#else
	  reloc++;
#endif
	}
    }

  while (r != NULL)
    {
      fragS *f = get_frag_for_reloc (last_frag, seginfo, r);
      if (f != NULL)
	{
	  last_frag = f;
	  relocs[n++] = &r->u.b.r;
	  install_reloc (sec, &r->u.b.r, f, r->file, r->line);
	}
      r = r->next;
    }

#ifdef DEBUG4
  {
    unsigned int k, j, nsyms;
    asymbol **sympp;
    sympp = bfd_get_outsymbols (stdoutput);
    nsyms = bfd_get_symcount (stdoutput);
    for (k = 0; k < n; k++)
      if (((*relocs[k]->sym_ptr_ptr)->flags & BSF_SECTION_SYM) == 0)
	{
	  for (j = 0; j < nsyms; j++)
	    if (sympp[j] == *relocs[k]->sym_ptr_ptr)
	      break;
	  if (j == nsyms)
	    abort ();
	}
  }
#endif

  if (n)
    {
      flagword flags = bfd_get_section_flags (abfd, sec);
      flags |= SEC_RELOC;
      bfd_set_section_flags (abfd, sec, flags);
      bfd_set_reloc (stdoutput, sec, relocs, n);
    }

#ifdef SET_SECTION_RELOCS
  SET_SECTION_RELOCS (sec, relocs, n);
#endif

#ifdef DEBUG3
  {
    unsigned int k;

    fprintf (stderr, "relocs for sec %s\n", sec->name);
    for (k = 0; k < n; k++)
      {
	arelent *rel = relocs[k];
	asymbol *s = *rel->sym_ptr_ptr;
	fprintf (stderr, "  reloc %2d @@%p off %4lx : sym %-10s addend %lx\n",
		 k, rel, (unsigned long)rel->address, s->name,
		 (unsigned long)rel->addend);
      }
  }
#endif
}

static int
compress_frag (struct z_stream_s *strm, const char *contents, int in_size,
	       fragS **last_newf, struct obstack *ob)
{
  int out_size;
  int total_out_size = 0;
  fragS *f = *last_newf;
  char *next_out;
  int avail_out;

  /* Call the compression routine repeatedly until it has finished
     processing the frag.  */
  while (in_size > 0)
    {
      /* Reserve all the space available in the current chunk.
         If none is available, start a new frag.  */
      avail_out = obstack_room (ob);
      if (avail_out <= 0)
        {
          obstack_finish (ob);
          f = frag_alloc (ob);
	  f->fr_type = rs_fill;
          (*last_newf)->fr_next = f;
          *last_newf = f;
          avail_out = obstack_room (ob);
        }
      if (avail_out <= 0)
	as_fatal (_("can't extend frag"));
      next_out = obstack_next_free (ob);
      obstack_blank_fast (ob, avail_out);
      out_size = compress_data (strm, &contents, &in_size,
				&next_out, &avail_out);
      if (out_size < 0)
        return -1;

      f->fr_fix += out_size;
      total_out_size += out_size;

      /* Return unused space.  */
      if (avail_out > 0)
	obstack_blank_fast (ob, -avail_out);
    }

  return total_out_size;
}

static void
compress_debug (bfd *abfd, asection *sec, void *xxx ATTRIBUTE_UNUSED)
{
  segment_info_type *seginfo = seg_info (sec);
  fragS *f;
  fragS *first_newf;
  fragS *last_newf;
  struct obstack *ob = &seginfo->frchainP->frch_obstack;
  bfd_size_type uncompressed_size = (bfd_size_type) sec->size;
  bfd_size_type compressed_size;
  const char *section_name;
  char *compressed_name;
  char *header;
  struct z_stream_s *strm;
  int x;
  flagword flags = bfd_get_section_flags (abfd, sec);

  if (seginfo == NULL
      || sec->size < 32
      || (flags & (SEC_ALLOC | SEC_HAS_CONTENTS)) == SEC_ALLOC)
    return;

  section_name = bfd_get_section_name (stdoutput, sec);
  if (strncmp (section_name, ".debug_", 7) != 0)
    return;

  strm = compress_init ();
  if (strm == NULL)
    return;

  /* Create a new frag to contain the "ZLIB" header.  */
  first_newf = frag_alloc (ob);
  if (obstack_room (ob) < 12)
    first_newf = frag_alloc (ob);
  if (obstack_room (ob) < 12)
    as_fatal (_("can't extend frag %u chars"), 12);
  last_newf = first_newf;
  obstack_blank_fast (ob, 12);
  last_newf->fr_type = rs_fill;
  last_newf->fr_fix = 12;
  header = last_newf->fr_literal;
  memcpy (header, "ZLIB", 4);
  header[11] = uncompressed_size; uncompressed_size >>= 8;
  header[10] = uncompressed_size; uncompressed_size >>= 8;
  header[9] = uncompressed_size; uncompressed_size >>= 8;
  header[8] = uncompressed_size; uncompressed_size >>= 8;
  header[7] = uncompressed_size; uncompressed_size >>= 8;
  header[6] = uncompressed_size; uncompressed_size >>= 8;
  header[5] = uncompressed_size; uncompressed_size >>= 8;
  header[4] = uncompressed_size;
  compressed_size = 12;

  /* Stream the frags through the compression engine, adding new frags
     as necessary to accomodate the compressed output.  */
  for (f = seginfo->frchainP->frch_root;
       f;
       f = f->fr_next)
    {
      offsetT fill_size;
      char *fill_literal;
      offsetT count;
      int out_size;

      gas_assert (f->fr_type == rs_fill);
      if (f->fr_fix)
	{
	  out_size = compress_frag (strm, f->fr_literal, f->fr_fix,
				    &last_newf, ob);
	  if (out_size < 0)
	    return;
	  compressed_size += out_size;
	}
      fill_literal = f->fr_literal + f->fr_fix;
      fill_size = f->fr_var;
      count = f->fr_offset;
      gas_assert (count >= 0);
      if (fill_size && count)
	{
	  while (count--)
	    {
	      out_size = compress_frag (strm, fill_literal, (int) fill_size,
				        &last_newf, ob);
	      if (out_size < 0)
		return;
	      compressed_size += out_size;
	    }
	}
    }

  /* Flush the compression state.  */
  for (;;)
    {
      int avail_out;
      char *next_out;
      int out_size;

      /* Reserve all the space available in the current chunk.
	 If none is available, start a new frag.  */
      avail_out = obstack_room (ob);
      if (avail_out <= 0)
	{
	  fragS *newf;

	  obstack_finish (ob);
	  newf = frag_alloc (ob);
	  newf->fr_type = rs_fill;
	  last_newf->fr_next = newf;
	  last_newf = newf;
	  avail_out = obstack_room (ob);
	}
      if (avail_out <= 0)
	as_fatal (_("can't extend frag"));
      next_out = obstack_next_free (ob);
      obstack_blank_fast (ob, avail_out);
      x = compress_finish (strm, &next_out, &avail_out, &out_size);
      if (x < 0)
	return;

      last_newf->fr_fix += out_size;
      compressed_size += out_size;

      /* Return unused space.  */
      if (avail_out > 0)
	obstack_blank_fast (ob, -avail_out);

      if (x == 0)
	break;
    }

  /* Replace the uncompressed frag list with the compressed frag list.  */
  seginfo->frchainP->frch_root = first_newf;
  seginfo->frchainP->frch_last = last_newf;

  /* Update the section size and its name.  */
  x = bfd_set_section_size (abfd, sec, compressed_size);
  gas_assert (x);
  compressed_name = (char *) xmalloc (strlen (section_name) + 2);
  compressed_name[0] = '.';
  compressed_name[1] = 'z';
  strcpy (compressed_name + 2, section_name + 1);
  bfd_section_name (stdoutput, sec) = compressed_name;
}

static void
write_contents (bfd *abfd ATTRIBUTE_UNUSED,
		asection *sec,
		void *xxx ATTRIBUTE_UNUSED)
{
  segment_info_type *seginfo = seg_info (sec);
  addressT offset = 0;
  fragS *f;

  /* Write out the frags.  */
  if (seginfo == NULL
      || !(bfd_get_section_flags (abfd, sec) & SEC_HAS_CONTENTS))
    return;

  for (f = seginfo->frchainP->frch_root;
       f;
       f = f->fr_next)
    {
      int x;
      addressT fill_size;
      char *fill_literal;
      offsetT count;

      gas_assert (f->fr_type == rs_fill);
      if (f->fr_fix)
	{
	  x = bfd_set_section_contents (stdoutput, sec,
					f->fr_literal, (file_ptr) offset,
					(bfd_size_type) f->fr_fix);
	  if (!x)
	    as_fatal (_("can't write %s: %s"), stdoutput->filename,
		      bfd_errmsg (bfd_get_error ()));
	  offset += f->fr_fix;
	}
      fill_literal = f->fr_literal + f->fr_fix;
      fill_size = f->fr_var;
      count = f->fr_offset;
      gas_assert (count >= 0);
      if (fill_size && count)
	{
	  char buf[256];
	  if (fill_size > sizeof (buf))
	    {
	      /* Do it the old way. Can this ever happen?  */
	      while (count--)
		{
		  x = bfd_set_section_contents (stdoutput, sec,
						fill_literal,
						(file_ptr) offset,
						(bfd_size_type) fill_size);
		  if (!x)
		    as_fatal (_("can't write %s: %s"), stdoutput->filename,
			      bfd_errmsg (bfd_get_error ()));
		  offset += fill_size;
		}
	    }
	  else
	    {
	      /* Build a buffer full of fill objects and output it as
		 often as necessary. This saves on the overhead of
		 potentially lots of bfd_set_section_contents calls.  */
	      int n_per_buf, i;
	      if (fill_size == 1)
		{
		  n_per_buf = sizeof (buf);
		  memset (buf, *fill_literal, n_per_buf);
		}
	      else
		{
		  char *bufp;
		  n_per_buf = sizeof (buf) / fill_size;
		  for (i = n_per_buf, bufp = buf; i; i--, bufp += fill_size)
		    memcpy (bufp, fill_literal, fill_size);
		}
	      for (; count > 0; count -= n_per_buf)
		{
		  n_per_buf = n_per_buf > count ? count : n_per_buf;
		  x = bfd_set_section_contents
		    (stdoutput, sec, buf, (file_ptr) offset,
		     (bfd_size_type) n_per_buf * fill_size);
		  if (!x)
		    as_fatal (_("cannot write to output file '%s': %s"),
			      stdoutput->filename,
			      bfd_errmsg (bfd_get_error ()));
		  offset += n_per_buf * fill_size;
		}
	    }
	}
    }
}

static void
merge_data_into_text (void)
{
  seg_info (text_section)->frchainP->frch_last->fr_next =
    seg_info (data_section)->frchainP->frch_root;
  seg_info (text_section)->frchainP->frch_last =
    seg_info (data_section)->frchainP->frch_last;
  seg_info (data_section)->frchainP = 0;
}

static void
set_symtab (void)
{
  int nsyms;
  asymbol **asympp;
  symbolS *symp;
  bfd_boolean result;

  /* Count symbols.  We can't rely on a count made by the loop in
     write_object_file, because *_frob_file may add a new symbol or
     two.  */
  nsyms = 0;
  for (symp = symbol_rootP; symp; symp = symbol_next (symp))
    nsyms++;

  if (nsyms)
    {
      int i;
      bfd_size_type amt = (bfd_size_type) nsyms * sizeof (asymbol *);

      asympp = (asymbol **) bfd_alloc (stdoutput, amt);
      symp = symbol_rootP;
      for (i = 0; i < nsyms; i++, symp = symbol_next (symp))
	{
	  asympp[i] = symbol_get_bfdsym (symp);
	  if (asympp[i]->flags != BSF_SECTION_SYM
	      || !(bfd_is_const_section (asympp[i]->section)
		   && asympp[i]->section->symbol == asympp[i]))
	    asympp[i]->flags |= BSF_KEEP;
	  symbol_mark_written (symp);
	}
    }
  else
    asympp = 0;
  result = bfd_set_symtab (stdoutput, asympp, nsyms);
  gas_assert (result);
  symbol_table_frozen = 1;
}

/* Finish the subsegments.  After every sub-segment, we fake an
   ".align ...".  This conforms to BSD4.2 brane-damage.  We then fake
   ".fill 0" because that is the kind of frag that requires least
   thought.  ".align" frags like to have a following frag since that
   makes calculating their intended length trivial.  */

#ifndef SUB_SEGMENT_ALIGN
#ifdef HANDLE_ALIGN
/* The last subsegment gets an alignment corresponding to the alignment
   of the section.  This allows proper nop-filling at the end of
   code-bearing sections.  */
#define SUB_SEGMENT_ALIGN(SEG, FRCHAIN)					\
  (!(FRCHAIN)->frch_next ? get_recorded_alignment (SEG) : 0)
#else
#define SUB_SEGMENT_ALIGN(SEG, FRCHAIN) 0
#endif
#endif

void
subsegs_finish (void)
{
  struct frchain *frchainP;
  asection *s;

  for (s = stdoutput->sections; s; s = s->next)
    {
      segment_info_type *seginfo = seg_info (s);
      if (!seginfo)
	continue;

      for (frchainP = seginfo->frchainP;
	   frchainP != NULL;
	   frchainP = frchainP->frch_next)
	{
	  int alignment = 0;

	  subseg_set (s, frchainP->frch_subseg);

	  /* This now gets called even if we had errors.  In that case,
	     any alignment is meaningless, and, moreover, will look weird
	     if we are generating a listing.  */
	  if (!had_errors ())
	    {
	      alignment = SUB_SEGMENT_ALIGN (now_seg, frchainP);
	      if ((bfd_get_section_flags (now_seg->owner, now_seg) & SEC_MERGE)
		  && now_seg->entsize)
		{
		  unsigned int entsize = now_seg->entsize;
		  int entalign = 0;

		  while ((entsize & 1) == 0)
		    {
		      ++entalign;
		      entsize >>= 1;
		    }
		  if (entalign > alignment)
		    alignment = entalign;
		}
	    }

	  if (subseg_text_p (now_seg))
	    frag_align_code (alignment, 0);
	  else
	    frag_align (alignment, 0, 0);

	  /* frag_align will have left a new frag.
	     Use this last frag for an empty ".fill".

	     For this segment ...
	     Create a last frag. Do not leave a "being filled in frag".  */
	  frag_wane (frag_now);
	  frag_now->fr_fix = 0;
	  know (frag_now->fr_next == NULL);
	}
    }
}

/* Write the object file.  */

void
write_object_file (void)
{
  struct relax_seg_info rsi;
#ifndef WORKING_DOT_WORD
  fragS *fragP;			/* Track along all frags.  */
#endif

#ifdef md_pre_output_hook
  md_pre_output_hook;
#endif

  /* Do we really want to write it?  */
  {
    int n_warns, n_errs;
    n_warns = had_warnings ();
    n_errs = had_errors ();
    /* The -Z flag indicates that an object file should be generated,
       regardless of warnings and errors.  */
    if (flag_always_generate_output)
      {
	if (n_warns || n_errs)
	  as_warn (_("%d error%s, %d warning%s, generating bad object file"),
		   n_errs, n_errs == 1 ? "" : "s",
		   n_warns, n_warns == 1 ? "" : "s");
      }
    else
      {
	if (n_errs)
	  as_fatal (_("%d error%s, %d warning%s, no object file generated"),
		    n_errs, n_errs == 1 ? "" : "s",
		    n_warns, n_warns == 1 ? "" : "s");
      }
  }

#ifdef md_pre_relax_hook
  md_pre_relax_hook;
#endif

  /* From now on, we don't care about sub-segments.  Build one frag chain
     for each segment. Linked thru fr_next.  */

  /* Remove the sections created by gas for its own purposes.  */
  {
    int i;

    bfd_section_list_remove (stdoutput, reg_section);
    bfd_section_list_remove (stdoutput, expr_section);
    stdoutput->section_count -= 2;
    i = 0;
    bfd_map_over_sections (stdoutput, renumber_sections, &i);
  }

  bfd_map_over_sections (stdoutput, chain_frchains_together, (char *) 0);

  /* We have two segments. If user gave -R flag, then we must put the
     data frags into the text segment. Do this before relaxing so
     we know to take advantage of -R and make shorter addresses.  */
  if (flag_readonly_data_in_text)
    {
      merge_data_into_text ();
    }

  rsi.pass = 0;
  while (1)
    {
#ifndef WORKING_DOT_WORD
      /* We need to reset the markers in the broken word list and
	 associated frags between calls to relax_segment (via
	 relax_seg).  Since the broken word list is global, we do it
	 once per round, rather than locally in relax_segment for each
	 segment.  */
      struct broken_word *brokp;

      for (brokp = broken_words;
	   brokp != (struct broken_word *) NULL;
	   brokp = brokp->next_broken_word)
	{
	  brokp->added = 0;

	  if (brokp->dispfrag != (fragS *) NULL
	      && brokp->dispfrag->fr_type == rs_broken_word)
	    brokp->dispfrag->fr_subtype = 0;
	}
#endif

      rsi.changed = 0;
      bfd_map_over_sections (stdoutput, relax_seg, &rsi);
      rsi.pass++;
      if (!rsi.changed)
	break;
    }

  /* Note - Most ports will use the default value of
     TC_FINALIZE_SYMS_BEFORE_SIZE_SEG, which 1.  This will force
     local symbols to be resolved, removing their frag information.
     Some ports however, will not have finished relaxing all of
     their frags and will still need the local symbol frag
     information.  These ports can set
     TC_FINALIZE_SYMS_BEFORE_SIZE_SEG to 0.  */
  finalize_syms = TC_FINALIZE_SYMS_BEFORE_SIZE_SEG;

  bfd_map_over_sections (stdoutput, size_seg, (char *) 0);

  /* Relaxation has completed.  Freeze all syms.  */
  finalize_syms = 1;

#ifdef md_post_relax_hook
  md_post_relax_hook;
#endif

#ifndef WORKING_DOT_WORD
  {
    struct broken_word *lie;
    struct broken_word **prevP;

    prevP = &broken_words;
    for (lie = broken_words; lie; lie = lie->next_broken_word)
      if (!lie->added)
	{
	  expressionS exp;

	  subseg_change (lie->seg, lie->subseg);
	  exp.X_op = O_subtract;
	  exp.X_add_symbol = lie->add;
	  exp.X_op_symbol = lie->sub;
	  exp.X_add_number = lie->addnum;
#ifdef TC_CONS_FIX_NEW
	  TC_CONS_FIX_NEW (lie->frag,
			   lie->word_goes_here - lie->frag->fr_literal,
			   2, &exp);
#else
	  fix_new_exp (lie->frag,
		       lie->word_goes_here - lie->frag->fr_literal,
		       2, &exp, 0, BFD_RELOC_16);
#endif
	  *prevP = lie->next_broken_word;
	}
      else
	prevP = &(lie->next_broken_word);

    for (lie = broken_words; lie;)
      {
	struct broken_word *untruth;
	char *table_ptr;
	addressT table_addr;
	addressT from_addr, to_addr;
	int n, m;

	subseg_change (lie->seg, lie->subseg);
	fragP = lie->dispfrag;

	/* Find out how many broken_words go here.  */
	n = 0;
	for (untruth = lie;
	     untruth && untruth->dispfrag == fragP;
	     untruth = untruth->next_broken_word)
	  if (untruth->added == 1)
	    n++;

	table_ptr = lie->dispfrag->fr_opcode;
	table_addr = (lie->dispfrag->fr_address
		      + (table_ptr - lie->dispfrag->fr_literal));
	/* Create the jump around the long jumps.  This is a short
	   jump from table_ptr+0 to table_ptr+n*long_jump_size.  */
	from_addr = table_addr;
	to_addr = table_addr + md_short_jump_size + n * md_long_jump_size;
	md_create_short_jump (table_ptr, from_addr, to_addr, lie->dispfrag,
			      lie->add);
	table_ptr += md_short_jump_size;
	table_addr += md_short_jump_size;

	for (m = 0;
	     lie && lie->dispfrag == fragP;
	     m++, lie = lie->next_broken_word)
	  {
	    if (lie->added == 2)
	      continue;
	    /* Patch the jump table.  */
	    for (untruth = (struct broken_word *) (fragP->fr_symbol);
		 untruth && untruth->dispfrag == fragP;
		 untruth = untruth->next_broken_word)
	      {
		if (untruth->use_jump == lie)
		  {
		    /* This is the offset from ??? to table_ptr+0.
		       The target is the same for all users of this
		       md_long_jump, but the "sub" bases (and hence the
		       offsets) may be different.  */
		    addressT to_word = table_addr - S_GET_VALUE (untruth->sub);
#ifdef TC_CHECK_ADJUSTED_BROKEN_DOT_WORD
		    TC_CHECK_ADJUSTED_BROKEN_DOT_WORD (to_word, untruth);
#endif
		    md_number_to_chars (untruth->word_goes_here, to_word, 2);
		  }
	      }

	    /* Install the long jump.  */
	    /* This is a long jump from table_ptr+0 to the final target.  */
	    from_addr = table_addr;
	    to_addr = S_GET_VALUE (lie->add) + lie->addnum;
	    md_create_long_jump (table_ptr, from_addr, to_addr, lie->dispfrag,
				 lie->add);
	    table_ptr += md_long_jump_size;
	    table_addr += md_long_jump_size;
	  }
      }
  }
#endif /* not WORKING_DOT_WORD  */

  /* Resolve symbol values.  This needs to be done before processing
     the relocations.  */
  if (symbol_rootP)
    {
      symbolS *symp;

      for (symp = symbol_rootP; symp; symp = symbol_next (symp))
	resolve_symbol_value (symp);
    }
  resolve_local_symbol_values ();
  resolve_reloc_expr_symbols ();

  PROGRESS (1);

#ifdef tc_frob_file_before_adjust
  tc_frob_file_before_adjust ();
#endif
#ifdef obj_frob_file_before_adjust
  obj_frob_file_before_adjust ();
#endif

  bfd_map_over_sections (stdoutput, adjust_reloc_syms, (char *) 0);

#ifdef tc_frob_file_before_fix
  tc_frob_file_before_fix ();
#endif
#ifdef obj_frob_file_before_fix
  obj_frob_file_before_fix ();
#endif

  bfd_map_over_sections (stdoutput, fix_segment, (char *) 0);

  /* Set up symbol table, and write it out.  */
  if (symbol_rootP)
    {
      symbolS *symp;
      bfd_boolean skip_next_symbol = FALSE;

      for (symp = symbol_rootP; symp; symp = symbol_next (symp))
	{
	  int punt = 0;
	  const char *name;

	  if (skip_next_symbol)
	    {
	      /* Don't do anything besides moving the value of the
		 symbol from the GAS value-field to the BFD value-field.  */
	      symbol_get_bfdsym (symp)->value = S_GET_VALUE (symp);
	      skip_next_symbol = FALSE;
	      continue;
	    }

	  if (symbol_mri_common_p (symp))
	    {
	      if (S_IS_EXTERNAL (symp))
		as_bad (_("%s: global symbols not supported in common sections"),
			S_GET_NAME (symp));
	      symbol_remove (symp, &symbol_rootP, &symbol_lastP);
	      continue;
	    }

	  name = S_GET_NAME (symp);
	  if (name)
	    {
	      const char *name2 =
		decode_local_label_name ((char *) S_GET_NAME (symp));
	      /* They only differ if `name' is a fb or dollar local
		 label name.  */
	      if (name2 != name && ! S_IS_DEFINED (symp))
		as_bad (_("local label `%s' is not defined"), name2);
	    }

	  /* Do it again, because adjust_reloc_syms might introduce
	     more symbols.  They'll probably only be section symbols,
	     but they'll still need to have the values computed.  */
	  resolve_symbol_value (symp);

	  /* Skip symbols which were equated to undefined or common
	     symbols.  */
	  if (symbol_equated_reloc_p (symp)
	      || S_IS_WEAKREFR (symp))
	    {
	      const char *sname = S_GET_NAME (symp);

	      if (S_IS_COMMON (symp)
		  && !TC_FAKE_LABEL (sname)
		  && !S_IS_WEAKREFR (symp)
		  && (!S_IS_EXTERNAL (symp) || S_IS_LOCAL (symp)))
		{
		  expressionS *e = symbol_get_value_expression (symp);

		  as_bad (_("Local symbol `%s' can't be equated to common symbol `%s'"),
			  sname, S_GET_NAME (e->X_add_symbol));
		}
	      if (S_GET_SEGMENT (symp) == reg_section)
		{
		  /* Report error only if we know the symbol name.  */
		  if (S_GET_NAME (symp) != reg_section->name)
		    as_bad (_("can't make global register symbol `%s'"),
			    sname);
		}
	      symbol_remove (symp, &symbol_rootP, &symbol_lastP);
	      continue;
	    }

#ifdef obj_frob_symbol
	  obj_frob_symbol (symp, punt);
#endif
#ifdef tc_frob_symbol
	  if (! punt || symbol_used_in_reloc_p (symp))
	    tc_frob_symbol (symp, punt);
#endif

	  /* If we don't want to keep this symbol, splice it out of
	     the chain now.  If EMIT_SECTION_SYMBOLS is 0, we never
	     want section symbols.  Otherwise, we skip local symbols
	     and symbols that the frob_symbol macros told us to punt,
	     but we keep such symbols if they are used in relocs.  */
	  if (symp == abs_section_sym
	      || (! EMIT_SECTION_SYMBOLS
		  && symbol_section_p (symp))
	      /* Note that S_IS_EXTERNAL and S_IS_LOCAL are not always
		 opposites.  Sometimes the former checks flags and the
		 latter examines the name...  */
	      || (!S_IS_EXTERNAL (symp)
		  && (punt || S_IS_LOCAL (symp) ||
		      (S_IS_WEAKREFD (symp) && ! symbol_used_p (symp)))
		  && ! symbol_used_in_reloc_p (symp)))
	    {
	      symbol_remove (symp, &symbol_rootP, &symbol_lastP);

	      /* After symbol_remove, symbol_next(symp) still returns
		 the one that came after it in the chain.  So we don't
		 need to do any extra cleanup work here.  */
	      continue;
	    }

	  /* Make sure we really got a value for the symbol.  */
	  if (! symbol_resolved_p (symp))
	    {
	      as_bad (_("can't resolve value for symbol `%s'"),
		      S_GET_NAME (symp));
	      symbol_mark_resolved (symp);
	    }

	  /* Set the value into the BFD symbol.  Up til now the value
	     has only been kept in the gas symbolS struct.  */
	  symbol_get_bfdsym (symp)->value = S_GET_VALUE (symp);

	  /* A warning construct is a warning symbol followed by the
	     symbol warned about.  Don't let anything object-format or
	     target-specific muck with it; it's ready for output.  */
	  if (symbol_get_bfdsym (symp)->flags & BSF_WARNING)
	    skip_next_symbol = TRUE;
	}
    }

  PROGRESS (1);

  /* Now do any format-specific adjustments to the symbol table, such
     as adding file symbols.  */
#ifdef tc_adjust_symtab
  tc_adjust_symtab ();
#endif
#ifdef obj_adjust_symtab
  obj_adjust_symtab ();
#endif

  /* Stop if there is an error.  */
  if (had_errors ())
    return;

  /* Now that all the sizes are known, and contents correct, we can
     start writing to the file.  */
  set_symtab ();

  /* If *_frob_file changes the symbol value at this point, it is
     responsible for moving the changed value into symp->bsym->value
     as well.  Hopefully all symbol value changing can be done in
     *_frob_symbol.  */
#ifdef tc_frob_file
  tc_frob_file ();
#endif
#ifdef obj_frob_file
  obj_frob_file ();
#endif
#ifdef obj_coff_generate_pdata
  obj_coff_generate_pdata ();
#endif
  bfd_map_over_sections (stdoutput, write_relocs, (char *) 0);

#ifdef tc_frob_file_after_relocs
  tc_frob_file_after_relocs ();
#endif
#ifdef obj_frob_file_after_relocs
  obj_frob_file_after_relocs ();
#endif

  /* Once all relocations have been written, we can compress the
     contents of the debug sections.  This needs to be done before
     we start writing any sections, because it will affect the file
     layout, which is fixed once we start writing contents.  */
  if (flag_compress_debug)
    bfd_map_over_sections (stdoutput, compress_debug, (char *) 0);

  bfd_map_over_sections (stdoutput, write_contents, (char *) 0);
}

#ifdef TC_GENERIC_RELAX_TABLE
/* Relax a fragment by scanning TC_GENERIC_RELAX_TABLE.  */

long
relax_frag (segT segment, fragS *fragP, long stretch)
{
  const relax_typeS *this_type;
  const relax_typeS *start_type;
  relax_substateT next_state;
  relax_substateT this_state;
  offsetT growth;
  offsetT aim;
  addressT target;
  addressT address;
  symbolS *symbolP;
  const relax_typeS *table;

  target = fragP->fr_offset;
  address = fragP->fr_address;
  table = TC_GENERIC_RELAX_TABLE;
  this_state = fragP->fr_subtype;
  start_type = this_type = table + this_state;
  symbolP = fragP->fr_symbol;

  if (symbolP)
    {
      fragS *sym_frag;

      sym_frag = symbol_get_frag (symbolP);

#ifndef DIFF_EXPR_OK
      know (sym_frag != NULL);
#endif
      know (S_GET_SEGMENT (symbolP) != absolute_section
	    || sym_frag == &zero_address_frag);
      target += S_GET_VALUE (symbolP);

      /* If SYM_FRAG has yet to be reached on this pass, assume it
	 will move by STRETCH just as we did, unless there is an
	 alignment frag between here and SYM_FRAG.  An alignment may
	 well absorb any STRETCH, and we don't want to choose a larger
	 branch insn by overestimating the needed reach of this
	 branch.  It isn't critical to calculate TARGET exactly;  We
	 know we'll be doing another pass if STRETCH is non-zero.  */

      if (stretch != 0
	  && sym_frag->relax_marker != fragP->relax_marker
	  && S_GET_SEGMENT (symbolP) == segment)
	{
	  if (stretch < 0
	      || sym_frag->region == fragP->region)
	    target += stretch;
	  /* If we get here we know we have a forward branch.  This
	     relax pass may have stretched previous instructions so
	     far that omitting STRETCH would make the branch
	     negative.  Don't allow this in case the negative reach is
	     large enough to require a larger branch instruction.  */
	  else if (target < address)
	    target = fragP->fr_next->fr_address + stretch;
	}
    }

  aim = target - address - fragP->fr_fix;
#ifdef TC_PCREL_ADJUST
  /* Currently only the ns32k family needs this.  */
  aim += TC_PCREL_ADJUST (fragP);
#endif

#ifdef md_prepare_relax_scan
  /* Formerly called M68K_AIM_KLUDGE.  */
  md_prepare_relax_scan (fragP, address, aim, this_state, this_type);
#endif

  if (aim < 0)
    {
      /* Look backwards.  */
      for (next_state = this_type->rlx_more; next_state;)
	if (aim >= this_type->rlx_backward)
	  next_state = 0;
	else
	  {
	    /* Grow to next state.  */
	    this_state = next_state;
	    this_type = table + this_state;
	    next_state = this_type->rlx_more;
	  }
    }
  else
    {
      /* Look forwards.  */
      for (next_state = this_type->rlx_more; next_state;)
	if (aim <= this_type->rlx_forward)
	  next_state = 0;
	else
	  {
	    /* Grow to next state.  */
	    this_state = next_state;
	    this_type = table + this_state;
	    next_state = this_type->rlx_more;
	  }
    }

  growth = this_type->rlx_length - start_type->rlx_length;
  if (growth != 0)
    fragP->fr_subtype = this_state;
  return growth;
}

#endif /* defined (TC_GENERIC_RELAX_TABLE)  */

/* Relax_align. Advance location counter to next address that has 'alignment'
   lowest order bits all 0s, return size of adjustment made.  */
static relax_addressT
relax_align (register relax_addressT address,	/* Address now.  */
	     register int alignment	/* Alignment (binary).  */)
{
  relax_addressT mask;
  relax_addressT new_address;

  mask = ~((~0) << alignment);
  new_address = (address + mask) & (~mask);
#ifdef LINKER_RELAXING_SHRINKS_ONLY
  if (linkrelax)
    /* We must provide lots of padding, so the linker can discard it
       when needed.  The linker will not add extra space, ever.  */
    new_address += (1 << alignment);
#endif
  return (new_address - address);
}

/* Now we have a segment, not a crowd of sub-segments, we can make
   fr_address values.

   Relax the frags.

   After this, all frags in this segment have addresses that are correct
   within the segment. Since segments live in different file addresses,
   these frag addresses may not be the same as final object-file
   addresses.  */

int
relax_segment (struct frag *segment_frag_root, segT segment, int pass)
{
  unsigned long frag_count;
  struct frag *fragP;
  relax_addressT address;
  int region;
  int ret;

  /* In case md_estimate_size_before_relax() wants to make fixSs.  */
  subseg_change (segment, 0);

  /* For each frag in segment: count and store  (a 1st guess of)
     fr_address.  */
  address = 0;
  region = 0;
  for (frag_count = 0, fragP = segment_frag_root;
       fragP;
       fragP = fragP->fr_next, frag_count ++)
    {
      fragP->region = region;
      fragP->relax_marker = 0;
      fragP->fr_address = address;
      address += fragP->fr_fix;

      switch (fragP->fr_type)
	{
	case rs_fill:
	  address += fragP->fr_offset * fragP->fr_var;
	  break;

	case rs_align:
	case rs_align_code:
	case rs_align_test:
	  {
	    addressT offset = relax_align (address, (int) fragP->fr_offset);

	    if (fragP->fr_subtype != 0 && offset > fragP->fr_subtype)
	      offset = 0;

	    if (offset % fragP->fr_var != 0)
	      {
		as_bad_where (fragP->fr_file, fragP->fr_line,
			      _("alignment padding (%lu bytes) not a multiple of %ld"),
			      (unsigned long) offset, (long) fragP->fr_var);
		offset -= (offset % fragP->fr_var);
	      }

	    address += offset;
	    region += 1;
	  }
	  break;

	case rs_org:
	  /* Assume .org is nugatory. It will grow with 1st relax.  */
	  region += 1;
	  break;

	case rs_space:
	  break;

	case rs_machine_dependent:
	  /* If fr_symbol is an expression, this call to
	     resolve_symbol_value sets up the correct segment, which will
	     likely be needed in md_estimate_size_before_relax.  */
	  if (fragP->fr_symbol)
	    resolve_symbol_value (fragP->fr_symbol);

	  address += md_estimate_size_before_relax (fragP, segment);
	  break;

#ifndef WORKING_DOT_WORD
	  /* Broken words don't concern us yet.  */
	case rs_broken_word:
	  break;
#endif

	case rs_leb128:
	  /* Initial guess is always 1; doing otherwise can result in
	     stable solutions that are larger than the minimum.  */
	  address += fragP->fr_offset = 1;
	  break;

	case rs_cfa:
	  address += eh_frame_estimate_size_before_relax (fragP);
	  break;

	case rs_dwarf2dbg:
	  address += dwarf2dbg_estimate_size_before_relax (fragP);
	  break;

	default:
	  BAD_CASE (fragP->fr_type);
	  break;
	}
    }

  /* Do relax().  */
  {
    unsigned long max_iterations;

    /* Cumulative address adjustment.  */
    offsetT stretch;

    /* Have we made any adjustment this pass?  We can't just test
       stretch because one piece of code may have grown and another
       shrank.  */
    int stretched;

    /* Most horrible, but gcc may give us some exception data that
       is impossible to assemble, of the form

       .align 4
       .byte 0, 0
       .uleb128 end - start
       start:
       .space 128*128 - 1
       .align 4
       end:

       If the leb128 is two bytes in size, then end-start is 128*128,
       which requires a three byte leb128.  If the leb128 is three
       bytes in size, then end-start is 128*128-1, which requires a
       two byte leb128.  We work around this dilemma by inserting
       an extra 4 bytes of alignment just after the .align.  This
       works because the data after the align is accessed relative to
       the end label.

       This counter is used in a tiny state machine to detect
       whether a leb128 followed by an align is impossible to
       relax.  */
    int rs_leb128_fudge = 0;

    /* We want to prevent going into an infinite loop where one frag grows
       depending upon the location of a symbol which is in turn moved by
       the growing frag.  eg:

	 foo = .
	 .org foo+16
	 foo = .

       So we dictate that this algorithm can be at most O2.  */
    max_iterations = frag_count * frag_count;
    /* Check for overflow.  */
    if (max_iterations < frag_count)
      max_iterations = frag_count;

    ret = 0;
    do
      {
	stretch = 0;
	stretched = 0;

	for (fragP = segment_frag_root; fragP; fragP = fragP->fr_next)
	  {
	    offsetT growth = 0;
	    addressT was_address;
	    offsetT offset;
	    symbolS *symbolP;

	    fragP->relax_marker ^= 1;
	    was_address = fragP->fr_address;
	    address = fragP->fr_address += stretch;
	    symbolP = fragP->fr_symbol;
	    offset = fragP->fr_offset;

	    switch (fragP->fr_type)
	      {
	      case rs_fill:	/* .fill never relaxes.  */
		growth = 0;
		break;

#ifndef WORKING_DOT_WORD
		/* JF:  This is RMS's idea.  I do *NOT* want to be blamed
		   for it I do not want to write it.  I do not want to have
		   anything to do with it.  This is not the proper way to
		   implement this misfeature.  */
	      case rs_broken_word:
		{
		  struct broken_word *lie;
		  struct broken_word *untruth;

		  /* Yes this is ugly (storing the broken_word pointer
		     in the symbol slot).  Still, this whole chunk of
		     code is ugly, and I don't feel like doing anything
		     about it.  Think of it as stubbornness in action.  */
		  growth = 0;
		  for (lie = (struct broken_word *) (fragP->fr_symbol);
		       lie && lie->dispfrag == fragP;
		       lie = lie->next_broken_word)
		    {

		      if (lie->added)
			continue;

		      offset = (S_GET_VALUE (lie->add)
				+ lie->addnum
				- S_GET_VALUE (lie->sub));
		      if (offset <= -32768 || offset >= 32767)
			{
			  if (flag_warn_displacement)
			    {
			      char buf[50];
			      sprint_value (buf, (addressT) lie->addnum);
			      as_warn_where (fragP->fr_file, fragP->fr_line,
					     _(".word %s-%s+%s didn't fit"),
					     S_GET_NAME (lie->add),
					     S_GET_NAME (lie->sub),
					     buf);
			    }
			  if (fragP->fr_subtype == 0)
			    {
			      fragP->fr_subtype++;
			      growth += md_short_jump_size;
			    }

			  /* Redirect *all* words of this table with the same
			     target, lest we have to handle the case where the
			     same target but with a offset that fits on this
			     round overflows at the next relaxation round.  */
			  for (untruth = (struct broken_word *) (fragP->fr_symbol);
			       untruth && untruth->dispfrag == lie->dispfrag;
			       untruth = untruth->next_broken_word)
			    if ((symbol_get_frag (untruth->add)
				 == symbol_get_frag (lie->add))
				&& (S_GET_VALUE (untruth->add)
				    == S_GET_VALUE (lie->add)))
			      {
				untruth->added = 2;
				untruth->use_jump = lie;
			      }

			  lie->added = 1;
			  growth += md_long_jump_size;
			}
		    }

		  break;
		}		/* case rs_broken_word  */
#endif
	      case rs_align:
	      case rs_align_code:
	      case rs_align_test:
		{
		  addressT oldoff, newoff;

		  oldoff = relax_align (was_address + fragP->fr_fix,
					(int) offset);
		  newoff = relax_align (address + fragP->fr_fix,
					(int) offset);

		  if (fragP->fr_subtype != 0)
		    {
		      if (oldoff > fragP->fr_subtype)
			oldoff = 0;
		      if (newoff > fragP->fr_subtype)
			newoff = 0;
		    }

		  growth = newoff - oldoff;

		  /* If this align happens to follow a leb128 and
		     we have determined that the leb128 is bouncing
		     in size, then break the cycle by inserting an
		     extra alignment.  */
		  if (growth < 0
		      && (rs_leb128_fudge & 16) != 0
		      && (rs_leb128_fudge & 15) >= 2)
		    {
		      segment_info_type *seginfo = seg_info (segment);
		      struct obstack *ob = &seginfo->frchainP->frch_obstack;
		      struct frag *newf;

		      newf = frag_alloc (ob);
		      obstack_blank_fast (ob, fragP->fr_var);
		      obstack_finish (ob);
		      memcpy (newf, fragP, SIZEOF_STRUCT_FRAG);
		      memcpy (newf->fr_literal,
			      fragP->fr_literal + fragP->fr_fix,
			      fragP->fr_var);
		      newf->fr_type = rs_fill;
		      newf->fr_address = address + fragP->fr_fix + newoff;
		      newf->fr_fix = 0;
		      newf->fr_offset = (((offsetT) 1 << fragP->fr_offset)
					 / fragP->fr_var);
		      if (newf->fr_offset * newf->fr_var
			  != (offsetT) 1 << fragP->fr_offset)
			{
			  newf->fr_offset = (offsetT) 1 << fragP->fr_offset;
			  newf->fr_var = 1;
			}
		      /* Include size of new frag in GROWTH.  */
		      growth += newf->fr_offset * newf->fr_var;
		      /* Adjust the new frag address for the amount
			 we'll add when we process the new frag.  */
		      newf->fr_address -= stretch + growth;
		      newf->relax_marker ^= 1;
		      fragP->fr_next = newf;
#ifdef DEBUG
		      as_warn (_("padding added"));
#endif
		    }
		}
		break;

	      case rs_org:
		{
		  addressT target = offset;
		  addressT after;

		  if (symbolP)
		    {
		      /* Convert from an actual address to an octet offset
			 into the section.  Here it is assumed that the
			 section's VMA is zero, and can omit subtracting it
			 from the symbol's value to get the address offset.  */
		      know (S_GET_SEGMENT (symbolP)->vma == 0);
		      target += S_GET_VALUE (symbolP) * OCTETS_PER_BYTE;
		    }

		  know (fragP->fr_next);
		  after = fragP->fr_next->fr_address + stretch;
		  growth = target - after;
		  if (growth < 0)
		    {
		      growth = 0;

		      /* Don't error on first few frag relax passes.
			 The symbol might be an expression involving
			 symbol values from other sections.  If those
			 sections have not yet been processed their
			 frags will all have zero addresses, so we
			 will calculate incorrect values for them.  The
			 number of passes we allow before giving an
			 error is somewhat arbitrary.  It should be at
			 least one, with larger values requiring
			 increasingly contrived dependencies between
			 frags to trigger a false error.  */
		      if (pass < 2)
			{
			  /* Force another pass.  */
			  ret = 1;
			  break;
			}

		      /* Growth may be negative, but variable part of frag
			 cannot have fewer than 0 chars.  That is, we can't
			 .org backwards.  */
		      as_bad_where (fragP->fr_file, fragP->fr_line,
				    _("attempt to move .org backwards"));

		      /* We've issued an error message.  Change the
			 frag to avoid cascading errors.  */
		      fragP->fr_type = rs_align;
		      fragP->fr_subtype = 0;
		      fragP->fr_offset = 0;
		      fragP->fr_fix = after - address;
		    }
		}
		break;

	      case rs_space:
		growth = 0;
		if (symbolP)
		  {
		    offsetT amount;

		    amount = S_GET_VALUE (symbolP);
		    if (S_GET_SEGMENT (symbolP) != absolute_section
			|| S_IS_COMMON (symbolP)
			|| ! S_IS_DEFINED (symbolP))
		      {
			as_bad_where (fragP->fr_file, fragP->fr_line,
				      _(".space specifies non-absolute value"));
			/* Prevent repeat of this error message.  */
			fragP->fr_symbol = 0;
		      }
		    else if (amount < 0)
		      {
			/* Don't error on first few frag relax passes.
			   See rs_org comment for a longer explanation.  */
			if (pass < 2)
			  {
			    ret = 1;
			    break;
			  }

			as_warn_where (fragP->fr_file, fragP->fr_line,
				       _(".space or .fill with negative value, ignored"));
			fragP->fr_symbol = 0;
		      }
		    else
		      growth = (was_address + fragP->fr_fix + amount
				- fragP->fr_next->fr_address);
		  }
		break;

	      case rs_machine_dependent:
#ifdef md_relax_frag
		growth = md_relax_frag (segment, fragP, stretch);
#else
#ifdef TC_GENERIC_RELAX_TABLE
		/* The default way to relax a frag is to look through
		   TC_GENERIC_RELAX_TABLE.  */
		growth = relax_frag (segment, fragP, stretch);
#endif /* TC_GENERIC_RELAX_TABLE  */
#endif
		break;

	      case rs_leb128:
		{
		  valueT value;
		  offsetT size;

		  value = resolve_symbol_value (fragP->fr_symbol);
		  size = sizeof_leb128 (value, fragP->fr_subtype);
		  growth = size - fragP->fr_offset;
		  fragP->fr_offset = size;
		}
		break;

	      case rs_cfa:
		growth = eh_frame_relax_frag (fragP);
		break;

	      case rs_dwarf2dbg:
		growth = dwarf2dbg_relax_frag (fragP);
		break;

	      default:
		BAD_CASE (fragP->fr_type);
		break;
	      }
	    if (growth)
	      {
		stretch += growth;
		stretched = 1;
		if (fragP->fr_type == rs_leb128)
		  rs_leb128_fudge += 16;
		else if (fragP->fr_type == rs_align
			 && (rs_leb128_fudge & 16) != 0
			 && stretch == 0)
		  rs_leb128_fudge += 16;
		else
		  rs_leb128_fudge = 0;
	      }
	  }

	if (stretch == 0
	    && (rs_leb128_fudge & 16) == 0
	    && (rs_leb128_fudge & -16) != 0)
	  rs_leb128_fudge += 1;
	else
	  rs_leb128_fudge = 0;
      }
    /* Until nothing further to relax.  */
    while (stretched && -- max_iterations);

    if (stretched)
      as_fatal (_("Infinite loop encountered whilst attempting to compute the addresses of symbols in section %s"),
		segment_name (segment));
  }

  for (fragP = segment_frag_root; fragP; fragP = fragP->fr_next)
    if (fragP->last_fr_address != fragP->fr_address)
      {
	fragP->last_fr_address = fragP->fr_address;
	ret = 1;
      }
  return ret;
}

void
number_to_chars_bigendian (char *buf, valueT val, int n)
{
  if (n <= 0)
    abort ();
  while (n--)
    {
      buf[n] = val & 0xff;
      val >>= 8;
    }
}

void
number_to_chars_littleendian (char *buf, valueT val, int n)
{
  if (n <= 0)
    abort ();
  while (n--)
    {
      *buf++ = val & 0xff;
      val >>= 8;
    }
}

void
write_print_statistics (FILE *file)
{
  fprintf (file, "fixups: %d\n", n_fixups);
}

/* For debugging.  */
extern int indent_level;

void
print_fixup (fixS *fixp)
{
  indent_level = 1;
  fprintf (stderr, "fix ");
  fprintf_vma (stderr, (bfd_vma)((bfd_hostptr_t) fixp));
  fprintf (stderr, " %s:%d",fixp->fx_file, fixp->fx_line);
  if (fixp->fx_pcrel)
    fprintf (stderr, " pcrel");
  if (fixp->fx_pcrel_adjust)
    fprintf (stderr, " pcrel_adjust=%d", fixp->fx_pcrel_adjust);
  if (fixp->fx_im_disp)
    {
#ifdef TC_NS32K
      fprintf (stderr, " im_disp=%d", fixp->fx_im_disp);
#else
      fprintf (stderr, " im_disp");
#endif
    }
  if (fixp->fx_tcbit)
    fprintf (stderr, " tcbit");
  if (fixp->fx_done)
    fprintf (stderr, " done");
  fprintf (stderr, "\n    size=%d frag=", fixp->fx_size);
  fprintf_vma (stderr, (bfd_vma) ((bfd_hostptr_t) fixp->fx_frag));
  fprintf (stderr, " where=%ld offset=%lx addnumber=%lx",
	   (long) fixp->fx_where,
	   (unsigned long) fixp->fx_offset,
	   (unsigned long) fixp->fx_addnumber);
  fprintf (stderr, "\n    %s (%d)", bfd_get_reloc_code_name (fixp->fx_r_type),
	   fixp->fx_r_type);
  if (fixp->fx_addsy)
    {
      fprintf (stderr, "\n   +<");
      print_symbol_value_1 (stderr, fixp->fx_addsy);
      fprintf (stderr, ">");
    }
  if (fixp->fx_subsy)
    {
      fprintf (stderr, "\n   -<");
      print_symbol_value_1 (stderr, fixp->fx_subsy);
      fprintf (stderr, ">");
    }
  fprintf (stderr, "\n");
#ifdef TC_FIX_DATA_PRINT
  TC_FIX_DATA_PRINT (stderr, fixp);
#endif
}
@


1.155
log
@2013-03-08  Chung-Lin Tang  <cltang@@codesourcery.com>

	* write.h (struct fix): Add fx_dot_frag field.
	(dot_frag): Declare.
	* write.c (dot_frag): New variable.
	(fix_new_internal): Set fx_dot_frag field with dot_frag.
	(fixup_segment): Base calculation of fx_offset with fx_dot_frag.
	* expr.c (expr): Save value of frag_now in dot_frag when setting
	dot_value.
	* read.c (emit_expr): Likewise. Delete comments.
@
text
@d725 4
a728 3
		  && !(howto->partial_inplace
		       && howto->pc_relative
		       && howto->src_mask != addr_mask))
@


1.154
log
@	* write.c (fixup_segment): Return void.  Delete seg_reloc_count
	related code.
	(TC_ADJUST_RELOC_COUNT): Delete.
	* config/tc-i960.h (TC_ADJUST_RELOC_COUNT): Delete.
@
text
@d125 3
d175 1
d984 1
a984 1
				 + fixP->fx_frag->fr_address);
@


1.153
log
@Remove trailing white spaces on gas

	* app.c: Remove trailing white spaces.
	* as.c: Likewise.
	* as.h: Likewise.
	* cond.c: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.h: Likewise.
	* ecoff.c: Likewise.
	* input-file.c: Likewise.
	* itbl-lex.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* sb.c: Likewise.
	* subsegs.c: Likewise.
	* symbols.c: Likewise.
	* write.c: Likewise.
	* config/tc-i386.c: Likewise.
	* doc/Makefile.am: Likewise.
	* doc/Makefile.in: Likewise.
	* doc/c-aarch64.texi: Likewise.
	* doc/c-alpha.texi: Likewise.
	* doc/c-arc.texi: Likewise.
	* doc/c-arm.texi: Likewise.
	* doc/c-avr.texi: Likewise.
	* doc/c-bfin.texi: Likewise.
	* doc/c-cr16.texi: Likewise.
	* doc/c-d10v.texi: Likewise.
	* doc/c-d30v.texi: Likewise.
	* doc/c-h8300.texi: Likewise.
	* doc/c-hppa.texi: Likewise.
	* doc/c-i370.texi: Likewise.
	* doc/c-i386.texi: Likewise.
	* doc/c-i860.texi: Likewise.
	* doc/c-m32c.texi: Likewise.
	* doc/c-m32r.texi: Likewise.
	* doc/c-m68hc11.texi: Likewise.
	* doc/c-m68k.texi: Likewise.
	* doc/c-microblaze.texi: Likewise.
	* doc/c-mips.texi: Likewise.
	* doc/c-msp430.texi: Likewise.
	* doc/c-mt.texi: Likewise.
	* doc/c-s390.texi: Likewise.
	* doc/c-score.texi: Likewise.
	* doc/c-sh.texi: Likewise.
	* doc/c-sh64.texi: Likewise.
	* doc/c-tic54x.texi: Likewise.
	* doc/c-tic6x.texi: Likewise.
	* doc/c-v850.texi: Likewise.
	* doc/c-xc16x.texi: Likewise.
	* doc/c-xgate.texi: Likewise.
	* doc/c-xtensa.texi: Likewise.
	* doc/c-z80.texi: Likewise.
	* doc/internals.texi: Likewise.
@
text
@a32 4
#ifndef TC_ADJUST_RELOC_COUNT
#define TC_ADJUST_RELOC_COUNT(FIX, COUNT)
#endif

d889 2
d892 1
a892 5
   Result is a count of how many relocation structs will be needed to
   handle the remaining fixS's that we couldn't completely handle here.
   These will be output later by emit_relocations().  */

static long
a894 1
  long seg_reloc_count = 0;
a923 1
	    seg_reloc_count++;
d925 1
a925 2
      TC_ADJUST_RELOC_COUNT (fixP, seg_reloc_count);
      return seg_reloc_count;
a1066 1
	  ++seg_reloc_count;
a1118 3

  TC_ADJUST_RELOC_COUNT (fixP, seg_reloc_count);
  return seg_reloc_count;
@


1.152
log
@	* write.c (chain_frchains_together_1): Reorder assertion to avoid
	uninit warning.
@
text
@d1185 1
a1185 1
  
@


1.151
log
@	* write.c (fixup_segment): Only perform the subtraction of an
	fx_subsy symbol if MD_APPLY_SYM_VALUE allows it and the symbol is
	properly defined.
	* config/tc-msp430.h (MD_APPLY_SYM_VALUE): Define.
@
text
@d409 2
a410 2
  gas_assert (prev_frag->fr_type != 0);
  gas_assert (prev_frag != &dummy);
@


1.151.2.1
log
@	PR 12549
	PR 14493
	PR 14567
	PR 14662
	PR 14758
	PR 14813
	PR 14904
	PR 14915
	PR 14926
	PR 14950
	PR 14962
	Apply mainline patches
@
text
@d409 2
a410 2
  gas_assert (prev_frag != &dummy
	      && prev_frag->fr_type != 0);
@


1.150
log
@	* dwarf2dbg.c (DWARF2_USE_FIXED_ADVANCE_PC): Enable when using
	linker relaxation.
	(dwarf2_gen_line_info): Generate real, local, labels for line
	numbers.
	(dwarf2dbg_convert_frag): Do not finalize the computation of the
	frag's symbol value when linker relaxation is enabled.
	(ADDR_DELTA_LIMIT): Define.
	(size_fixed_inc_line_addr): Use ADDR_DELTA_LIMIT.
	(emit_fixed_inc_line_addr): Likewise.
	* write.c (fixup_segment): If the subtraction of two symbols
	cannot be resolved but is valid, then prevent bogus range warnings
	by pre-biasing add_number.
	* config/tc-h8300.h (DWARF2_USE_FIXED_ADVANCE_PC): Define to 0.

	* gas/lns/lns.exp: Use alternate lns-common test for targets
	enabling linker relaxation.
	* gas/lns/lns-big-delta.d: Allow for output from architectures
	with 32-bit addresses.
@
text
@d1007 1
a1007 6
	  else if (TC_VALIDATE_FIX_SUB (fixP, add_symbol_segment))
	    /* If the fix is valid, subtract fx_subsy here.  The addition of
	       fx_addsy will be performed below.  Doing this prevents bogus
	       warnings from the range check below.  */
	      add_number -= S_GET_VALUE (fixP->fx_subsy);
	  else
d1022 4
@


1.149
log
@provide a hook to allow checking errors just before we output the file.

gas:

	* write.c (write_object_file): Add md_pre_output_hook.
	* config/obj-macho.c (obj_mach_o_check_before_writing): New.
	(obj_mach_o_pre_output_hook): New.
	* config/obj-macho.h (md_pre_output_hook): Define.
	(obj_mach_o_pre_output_hook): Declare.
@
text
@d1007 6
a1012 1
	  else if (!TC_VALIDATE_FIX_SUB (fixP, add_symbol_segment))
@


1.148
log
@
2012-02-21  Tristan Gingold  <gingold@@adacore.com>

	* config/tc-i386.h (OBJ_MACH_O): New section.
	(TC_FORCE_RELOCATION): Use obj_mach_o_force_reloc.
	(TC_FORCE_RELOCATION_SUB_SAME): New
	(TC_FORCE_RELOCATION_SUB_LOCAL): New.
	(TC_VALIDATE_FIX_SUB): New.
	* frags.h (struct frag): OBJ_FRAG_TYPE, new field.
	* symbols.c (colon): obj_frob_colon: New hook.
	* write.c (write_object_file): md_pre_relax_hook, new
	hook.
	* config/obj-macho.c (obj_mach_o_frob_colon): New.
	(obj_mach_o_frob_label): Record sub-section labels.
	(obj_mach_o_frob_symbol): Rename from obj_macho_frob_symbol.
	(obj_mach_o_set_subsections): New.
	(obj_mach_o_pre_relax_hook): New.
	(obj_mach_o_in_different_subsection): New.
	(obj_mach_o_force_reloc_sub_same): New.
	(obj_mach_o_force_reloc_sub_local): New.
	(obj_mach_o_force_reloc): New.
	* config/obj-macho.h (OBJ_SYMFIELD_TYPE): New.
	(obj_frob_colon): New Define.
	(obj_mach_o_frob_label): Renamed.
	(obj_mach_o_frob_symbol): Renamed.
	(OBJ_FRAG_TYPE): New.
	(obj_mach_o_in_different_subsection, obj_mach_o_force_reloc,
	 obj_mach_o_force_reloc_sub_same,
	 obj_mach_o_force_reloc_sub_local): New declarations.
@
text
@d1770 4
@


1.147
log
@	* write.c (fix_new_internal): Don't mark used parameter as unused.
@
text
@d1793 4
@


1.146
log
@	* write.c (dump_section_relocs): Don't convert PC-relative relocs
	that have an in-place addend narrower than the addresses used.
@
text
@d4 1
a4 1
   2010, 2011 Free Software Foundation, Inc.
d154 1
a154 1
		  RELOC_ENUM r_type ATTRIBUTE_UNUSED /* Relocation type.  */,
@


1.145
log
@	* write.c (resolve_reloc_expr_symbols): Convert local symbols
	on relocs to section+offset.
	(get_frag_for_reloc): New function.
	(write_relocs): Merge sort fixup relocs with those from .reloc
	directives.
@
text
@d657 1
d660 5
d667 1
a671 1
      reloc_howto_type *howto;
d718 10
a727 1
	      if (S_IS_LOCAL (sym) && !symbol_section_p (sym))
a747 2
      howto = r->u.a.howto;

@


1.145.2.1
log
@	Apply mainline patches
	2011-11-15  Maciej W. Rozycki  <macro@@codesourcery.com>
	* write.c (dump_section_relocs): Don't convert PC-relative relocs
	that have an in-place addend narrower than the addresses used.
@
text
@a656 1
  bfd_vma addr_mask = 1;
a658 5
  /* Avoid a shift by the width of type.  */
  addr_mask <<= bfd_arch_bits_per_address (stdoutput) - 1;
  addr_mask <<= 1;
  addr_mask -= 1;

a660 1
      reloc_howto_type *howto = r->u.a.howto;
d665 1
d712 1
a712 10
	      /* Convert relocs against local symbols to refer to the
	         corresponding section symbol plus offset instead.  Keep
	         PC-relative relocs of the REL variety intact though to
		 prevent the offset from overflowing the relocated field,
	         unless it has enough bits to cover the whole address
	         space.  */
	      if (S_IS_LOCAL (sym) && !symbol_section_p (sym)
		  && !(howto->partial_inplace
		       && howto->pc_relative
		       && howto->src_mask != addr_mask))
d733 2
@


1.144
log
@Call bfd_cache_close_all on error

2011-08-04  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/13056
	* output-file.c (output_file_close): Call bfd_cache_close_all
	on error.

	* write.c (write_object_file): Revert the last change.
@
text
@d4 1
a4 1
   2010 Free Software Foundation, Inc.
d711 14
a724 1
	    symbol_mark_used_in_reloc (sym);
d1162 22
a1187 1
  unsigned int i;
d1192 1
d1226 3
a1228 1
  i = 0;
a1230 1
      int j;
d1233 6
d1253 4
a1256 2
      {
	arelent *reloc = tc_gen_reloc (sec, fixp);
d1258 18
a1275 5
	if (!reloc)
	  continue;
	relocs[i++] = reloc;
	j = 1;
      }
d1277 1
a1277 6
      {
	arelent **reloc = tc_gen_reloc (sec, fixp);

	for (j = 0; reloc[j]; j++)
	  relocs[i++] = reloc[j];
      }
d1279 2
d1282 10
a1291 3
      for ( ; j != 0; --j)
	install_reloc (sec, relocs[i - j], fixp->fx_frag,
		       fixp->fx_file, fixp->fx_line);
a1292 1
  n = i;
a1311 17
  for (r = my_reloc_list; r != NULL; r = r->next)
    {
      fragS *f;
      for (f = seginfo->frchainP->frch_root; f; f = f->fr_next)
	if (f->fr_address <= r->u.b.r.address
	    && r->u.b.r.address < f->fr_address + f->fr_fix)
	  break;
      if (f == NULL)
	as_bad_where (r->file, r->line,
		      _("reloc not within (fixed part of) section"));
      else
	{
	  relocs[n++] = &r->u.b.r;
	  install_reloc (sec, &r->u.b.r, f, r->file, r->line);
	}
    }

@


1.143
log
@	* write.c (write_object_file): Call set_symtab even if we had
	errors.
@
text
@a2075 2
  set_symtab ();

d2082 1
@


1.142
log
@2011-08-01  Tristan Gingold  <gingold@@adacore.com>

	* write.c (write_relocs): Fix -Wshadow in DEBUG3 and DEBUG4.
@
text
@d2076 2
a2083 1
  set_symtab ();
@


1.141
log
@2011-05-06  Tristan Gingold  <gingold@@adacore.com>

	* read.c (s_comm_internal): Remove code for OBJ_VMS.
	(s_data): Ditto.
	(s_text): Ditto.
	* write.c (write_object_file): Ditto.
	* symbols.c (define_sym_at_dot): Ditto.
	(colon): Ditto.
@
text
@d1236 1
a1236 1
    unsigned int i, j, nsyms;
d1240 2
a1241 2
    for (i = 0; i < n; i++)
      if (((*relocs[i]->sym_ptr_ptr)->flags & BSF_SECTION_SYM) == 0)
d1244 1
a1244 1
	    if (sympp[j] == *relocs[i]->sym_ptr_ptr)
d1283 2
a1284 3
    unsigned int i;
    arelent *r;
    asymbol *s;
d1286 1
a1286 1
    for (i = 0; i < n; i++)
d1288 2
a1289 2
	r = relocs[i];
	s = *r->sym_ptr_ptr;
d1291 2
a1292 1
		 i, r, (unsigned long)r->address, s->name, (unsigned long)r->addend);
@


1.140
log
@	* write.c (write_contents): Include output file name and bfd error
	value when reporting the inability to write to the output file.
	* config/tc-rx.c (rx_handle_align): Do not insert NOPs into align
	frag that has a non-zero fill value.

	* gas/all/align.d: Skip for the RX.
	* gas/elf/group1a.d: Likewise.
	* gas/elf/groupautoa.d: Likewise.
	* gas/elf/elf.exp: Do not run section5 test for the RX port.
	* gas/elf/section4.d: Likewise.
	* gas/elf/section7.d: Likewise.
	* gas/macros/semi.s: Fill with a non-zero pattern.
	* gas/macros/semi.d: Expect non-zero fill value.
	* gas/rx/bcnd.d: Update expected disassembly.
	* gas/rx/bra.d: Likewise.
	* gas/rx/macros.inc: Add reg1 macro.
	* gas/rx/max.sm: Use reg1 macro to avoid generating illegal NOP
	instruction.
	* gas/rx/mov.sm: Likewise.
	* gas/rx/max.d: Update expected disassembly.
	* gas/rx/mov.d: Likewise.
	* gas/rx/rx-asm-good.s: Use Renesas section names.
	* gas/rx/rx-asm-good.d: Update expected disassembly.
@
text
@a1736 7
#ifdef	OBJ_VMS
  /* Under VMS we try to be compatible with VAX-11 "C".  Thus, we call
     a routine to check for the definition of the procedure "_main",
     and if so -- fix it up so that it can be program entry point.  */
  vms_check_for_main ();
#endif /* OBJ_VMS  */

@


1.139
log
@Don't compress debug sections smaller than 32 bytes.

2011-01-18  H.J. Lu  <hongjiu.lu@@intel.com>

	* write.c (compress_debug): Return if section size is small than
	32 byte.
@
text
@d1568 3
a1570 1
		    as_fatal (_("cannot write to output file"));
@


1.138
log
@Don't compress empty debug sections.

gas/

2011-01-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/12409
	* write.c (compress_debug): Return if section size is 0.

gas/testsuite/

2011-01-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/12409
	* gas/elf/dwarf2-4.d: New.
	* gas/elf/dwarf2-4.s: Likewise.
@
text
@d1362 1
a1362 1
      || sec->size == 0
@


1.137
log
@gas/
	* symbols.c (S_FORCE_RELOC): Return true for indirect functions
	even if !strict.
	* expr.c (operand): Don't convert absolute symbols to constants
	if S_FORCE_RELOC is true.
	(expr): Only reduce subtractions between different symbols if
	S_FORCE_RELOC is false for both of them.
	* write.c (fixup_segment): Don't remove symbols if S_FORCE_RELOC
	is true for them, regardless of their segment.

gas/testsuite/
	* gas/i386/ifunc-2.s, gas/i386/ifunc-2.l: New test.
	* gas/i386/ifunc-3.s, gas/i386/ifunc-3.d: Likeise.
	* gas/i386/i386.exp: Run them.
@
text
@d1362 1
@


1.136
log
@Add compressed debug section support to binutils and ld.

bfd/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>
	    Cary Coutant  <ccoutant@@google.com>

	* archive.c (bfd_openr_next_archived_file): Copy BFD_COMPRESS
	and BFD_DECOMPRESS.

	* bfd.c (BFD_COMPRESS): New.
	(BFD_DECOMPRESS): Likewise.
	(BFD_FLAGS_SAVED): Likewise.
	(bfd_preserve_save): Replace BFD_IN_MEMORY with BFD_FLAGS_SAVED.

	* compress.c (bfd_uncompress_section_contents): Removed.
	(get_uncompressed_size): New.
	(decompress_contents): Likewise.
	(bfd_compress_section_contents): Likewise.
	(bfd_get_full_section_contents): Likewise.
	(bfd_is_section_compressed): Likewise.
	(bfd_init_section_decompress_status): Likewise.
	(bfd_init_section_compress_status): Likewise.

	* dwarf2.c (dwarf_debug_sections): New.
	(dwarf_debug_section_enum): Likewise.
	(read_section): Remove section_name and compressed_section_name.
	Add dwarf_debug_section_enum.  Try compressed debug section.
	(read_indirect_string): Updated.
	(read_abbrevs): Likewise.
	(decode_line_info): Likewise.
	(read_debug_ranges): Likewise.
	(find_line): Updated.

	* ecoff.c (bfd_debug_section): Add compress_status and
	compressed_size.

	* elf.c (_bfd_elf_make_section_from_shdr): Call
	bfd_is_section_compressed to check if a DWARF debug section is
	compressed.  Call bfd_init_section_compress_status or
	bfd_init_section_decompress_status if needed.

	* elflink.c (elf_link_input_bfd): Replace bfd_get_section_contents
	with bfd_get_full_section_contents.
	* merge.c (_bfd_add_merge_section): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents): Likewise.
	* simple.c (bfd_simple_get_relocated_section_contents): Likewise.

	* elfxx-target.h (TARGET_BIG_SYM): Allow BFD_COMPRESS and
	BFD_DECOMPRESS.
	(TARGET_LITTLE_SYM): Likewise.

	* libbfd-in.h (dwarf_debug_section): New.
	(dwarf_debug_sections): Likewise.

	* libbfd.c (_bfd_generic_get_section_contents): Issue an error
	when getting contents on compressed/decompressed section.

	* section.c (COMPRESS_SECTION_NONE): New.
	(COMPRESS_SECTION_DONE): Likewise.
	(DECOMPRESS_SECTION_SIZED): Likewise.
	(BFD_FAKE_SECTION): Add compress_status and compressed_size.
	(bfd_malloc_and_get_section): Replace bfd_get_section_contents
	with bfd_get_full_section_contents.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.

binutils/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* addr2line.c (process_file): Set BFD_DECOMPRESS.

	* objcopy.c (do_debug_sections): New.
	(OPTION_COMPRESS_DEBUG_SECTIONS): New.
	(OPTION_DECOMPRESS_DEBUG_SECTIONS): Likewise.
	(copy_options): Add OPTION_COMPRESS_DEBUG_SECTIONS and
	OPTION_DECOMPRESS_DEBUG_SECTIONS.
	(copy_usage): Add --compress-debug-sections and
	--decompress-debug-sections.
	(copy_file): Set BFD_COMPRESS or BFD_DECOMPRESS.
	(copy_section): Replace bfd_get_section_contents with
	bfd_get_full_section_contents.
	(copy_main): Handle OPTION_COMPRESS_DEBUG_SECTIONS and
	OPTION_DECOMPRESS_DEBUG_SECTIONS.  Check do_debug_sections to
	rename DWARF debug sections.

	* objdump.c (load_specific_debug_section): Replace
	bfd_get_section_contents with bfd_get_full_section_contents.
	Remove bfd_uncompress_section_contents.
	(dump_section): Replace bfd_get_section_contents with
	bfd_get_full_section_contents.
	(display_file): Set BFD_DECOMPRESS if needed.

	* readelf.c (uncompress_section_contents): Set buffer to NULL
	to indiate decompression failure.
	(load_specific_debug_section): Always call
	uncompress_section_contents.

	* doc/binutils.texi: Document --compress-debug-sections and
	--decompress-debug-sections.

binutils/testsuite/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* binutils-all/compress.exp: New.
	* binutils-all/dw2-1.S: Likewise.
	* binutils-all/dw2-2.S: Likewise.
	* binutils-all/libdw2-compressed.out: Likewise.
	* binutils-all/libdw2.out: Likewise.

gas/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* write.c (compress_debug): Optimize section flags check.

gas/testsuite/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf/dwarf2-1.s: Replace .zdebug_abbrev section with
	.debug_abbrev section.
	* elf/dwarf2-2.3: Likewise.

	* elf/dwarf2-1.d: Pass --compress-debug-sections to assembler.
	Updated.
	* elf/dwarf2-2.d: Likewise.

	* gas/i386/i386.exp: Remove xfail on dw2-compress-2 and
	x86-64-dw2-compress-2.

ld/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldfile.c (ldfile_try_open_bfd): Set BFD_DECOMPRESS after
	bfd_openr returns.
	* emultempl/elf32.em (gld${EMULATION_NAME}_try_needed): Likewise.

	* scripttempl/elf.sc: Include compressed DWARF debug sections.

ld/testsuite/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-elf/compress.exp: New.
	* ld-elf/compress1.s: Likewise.
	* ld-elf/compress1a.d: Likewise.
	* ld-elf/compress1b.d: Likewise.
	* ld-elf/compress1c.d: Likewise.
@
text
@d935 2
d950 1
d958 1
d1001 1
d1015 1
@


1.136.2.1
log
@backport from mainline
@
text
@a934 2
	      && !S_FORCE_RELOC (fixP->fx_addsy, 0)
	      && !S_FORCE_RELOC (fixP->fx_subsy, 0)
a947 1
		   && !S_FORCE_RELOC (fixP->fx_subsy, 0)
a954 1
		   && !S_FORCE_RELOC (fixP->fx_subsy, 0)
a996 1
	      && !S_FORCE_RELOC (fixP->fx_addsy, 0)
a1009 1
		   && !S_FORCE_RELOC (fixP->fx_addsy, 0)
@


1.135
log
@	PR gas/12049
	* write.c (relax_frag): Don't allow forward branches to temporarily
	becomde backward branches.
@
text
@d1353 1
d1356 1
a1356 2
      || !(bfd_get_section_flags (abfd, sec) & SEC_HAS_CONTENTS)
      || (bfd_get_section_flags (abfd, sec) & SEC_ALLOC))
@


1.134
log
@	* write.c (relax_segment): Correct address on frag added to stop
	leb128/align frags bouncing.
@
text
@d2166 7
@


1.133
log
@	PR gas/12049
	* frags.h (struct frag): Add "region" field.
	* write.c (relax_frag): Don't add "stretch" to forward reference
	target if there is an intervening org or align.
	(relax_segment): Set region.
@
text
@d2528 1
d2538 1
a2538 2
		      /* Include growth of new frag, because rs_fill
			 frags don't normally grow.  */
d2540 3
a2542 4
		      /* The new frag address is newoff.  Adjust this
			 for the amount we'll add when we process the
			 new frag.  */
		      newf->fr_address = newoff - stretch - growth;
@


1.132
log
@bfd/ChangeLog:

	* compress.c (bfd_uncompress_section_contents): Add ATTRIBUTE_UNUSED.
	* dwarf2.c (read_and_uncompress_section): New function.
	(read_section): Call it.
	(find_line): Likewise.

binutils/ChangeLog:

	* objdump.c (load_specific_debug_section): Decompress section contents
	before applying relocations.
	* readelf.c (load_specific_debug_section): Update section size after
	decompression.

gas/ChangeLog:

	* Makefile.am: Add compress-debug.c and compress-debug.h.
	* Makefile.in: Regenerate.
	* config.in: Add HAVE_ZLIB_H.
	* configure.in: Check for zlib.h.
	* configure: Regenerate.

	* as.c (parse_args): Add --compress-debug-sections and
	--nocompress-debug-sections.
	* as.h (flag_compress_debug): New variable.
	* compress-debug.c: New file.
	* compress-debug.h: New file.
	* write.c: Include compress-debug.h.
	(compress_frag): New function.
	(compress_debug): New function.
	(write_object_file): Compress debug sections if requested.
@
text
@d3 2
a4 2
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
   Free Software Foundation, Inc.
d2151 7
a2157 4
      /* If frag has yet to be reached on this pass,
	 assume it will move by STRETCH just as we did.
	 If this is not so, it will be because some frag
	 between grows, and that will force another pass.  */
d2163 3
a2165 1
	  target += stretch;
d2253 1
d2262 1
d2267 1
d2296 1
d2301 4
a2305 1
	  /* Assume .org is nugatory. It will grow with 1st relax.  */
@


1.131
log
@        * write.c (fixup_segment): Revert previous delta.
        * config/tc-arm.h (TC_FORCE_RELOCATION_LOCAL): Also force the
        generation of relocations for fixups against weak symbols.
@
text
@d31 1
d1292 188
d2104 7
@


1.130
log
@        * write.c (fixup_segment): Do not assume we know the section a
        defined weak symbol is in.
        * config/tc-arm.c (relax_adr, relax_branch, md_apply_fix): Treat
        weak symbols as not known to be in the same section, even if they
        are defined.

        * gas/arm/weakdef-1.s: New.
        * gas/arm/weakdef-1.d: New.
        * gas/arm/weakdef-2.s: New.
        * gas/arm/weakdef-2.d: New.
        * gas/arm/weakdef-2.l: New.
@
text
@d995 1
a995 3
	  if (S_IS_WEAK (fixP->fx_addsy))
	    ; // even if it is defined, it might be overridden later
	  else if (add_symbol_segment == this_segment
@


1.129
log
@bfd/
	* coff-rs6000.c (xcoff_howto_table): Change size to 0 and bitsize to 1.
	(_bfd_xcoff_reloc_type_lookup): Handle BFD_RELOC_NONE.
	* coff64-rs6000.c (xcoff64_howto_table): Change size to 0 and
	bitsize to 1.
	(xcoff64_reloc_type_lookup): Handle BFD_RELOC_NONE.

gas/
	* write.h (fix_at_start): Declare.
	* write.c (fix_new_internal): Add at_beginning parameter.
	Use it instead of REVERSE_SORT_RELOCS.  Fix the handling of
	seg_fix_tailP for the at_beginning/REVERSE_SORT_RELOCS case.
	(fix_new, fix_new_exp): Update accordingly.
	(fix_at_start): New function.
	* config/tc-ppc.c (md_pseudo_table): Add .ref to the OBJ_XCOFF section.
	(ppc_ref): New function, for OBJ_XCOFF.
	(md_apply_fix): Handle BFD_RELOC_NONE for OBJ_XCOFF.
	* config/te-i386aix.h (REVERSE_SORT_RELOCS): Remove #undef.

gas/testsuite/
	* gas/ppc/xcoff-ref-1.s, gas/ppc/xcoff-ref-1.l: New test.
	* gas/ppc/aix.exp: Run it.


ld/testsuite/
	* ld-powerpc/aix-ref-1-32.od, ld-powerpc/aix-ref-1-64.od,
	ld-powerpc/aix-ref-1.s: New tests.
	* ld-powerpc/aix52.exp: Run them.
@
text
@d995 3
a997 1
	  if (add_symbol_segment == this_segment
@


1.128
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d153 2
a154 1
		  RELOC_ENUM r_type ATTRIBUTE_UNUSED /* Relocation type.  */)
a197 4
  /* Usually, we want relocs sorted numerically, but while
     comparing to older versions of gas that have relocs
     reverse sorted, it is convenient to have this compile
     time option.  xoxorich.  */
d207 7
a213 11
#ifdef REVERSE_SORT_RELOCS

    fixP->fx_next = *seg_fix_rootP;
    *seg_fix_rootP = fixP;

#else /* REVERSE_SORT_RELOCS  */

    fixP->fx_next = NULL;

    if (*seg_fix_tailP)
      (*seg_fix_tailP)->fx_next = fixP;
d215 8
a222 4
      *seg_fix_rootP = fixP;
    *seg_fix_tailP = fixP;

#endif /* REVERSE_SORT_RELOCS  */
d240 1
a240 1
			   (symbolS *) NULL, offset, pcrel, r_type);
d308 13
a320 1
  return fix_new_internal (frag, where, size, add, sub, off, pcrel, r_type);
@


1.127
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        * as.c (main): Call dwarf2_init.
        * config/obj-elf.c (struct group_list): New field.
        (build_group_lists): Use hash lookup.
        (free_section_idx): New function.
        (elf_frob_file): Adjust.
        * dwarf2dbg.c (all_segs_hash, last_seg_ptr): New variables.
        (get_line_subseg): Adjust.
        (dwarf2_init): New function.
        * dwarf2dbg.h (dwarf2_init): New declaration.
@
text
@d1790 2
a1791 1
	      const char *name = S_GET_NAME (symp);
d1793 1
a1793 1
		  && !TC_FAKE_LABEL (name)
d1798 1
d1800 1
a1800 1
			  name, S_GET_NAME (e->X_add_symbol));
d1807 1
a1807 1
			    name);
@


1.126
log
@update copyright dates
@
text
@d159 1
a159 1
  fixP = obstack_alloc (&notes, sizeof (fixS));
d1173 1
a1173 1
  relocs = xcalloc (n, sizeof (arelent *));
d1401 1
a1401 1
      asympp = bfd_alloc (stdoutput, amt);
@


1.126.2.1
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.
@
text
@d159 1
a159 1
  fixP = (fixS *) obstack_alloc (&notes, sizeof (fixS));
d1173 1
a1173 1
  relocs = (arelent **) xcalloc (n, sizeof (arelent *));
d1401 1
a1401 1
      asympp = (asymbol **) bfd_alloc (stdoutput, amt);
@


1.126.2.2
log
@bfd/
	* coff-rs6000.c (xcoff_howto_table): Change size to 0 and bitsize to 1.
	(_bfd_xcoff_reloc_type_lookup): Handle BFD_RELOC_NONE.
	* coff64-rs6000.c (xcoff64_howto_table): Change size to 0 and
	bitsize to 1.
	(xcoff64_reloc_type_lookup): Handle BFD_RELOC_NONE.

gas/
	* write.h (fix_at_start): Declare.
	* write.c (fix_new_internal): Add at_beginning parameter.
	Use it instead of REVERSE_SORT_RELOCS.  Fix the handling of
	seg_fix_tailP for the at_beginning/REVERSE_SORT_RELOCS case.
	(fix_new, fix_new_exp): Update accordingly.
	(fix_at_start): New function.
	* config/tc-ppc.c (md_pseudo_table): Add .ref to the OBJ_XCOFF section.
	(ppc_ref): New function, for OBJ_XCOFF.
	(md_apply_fix): Handle BFD_RELOC_NONE for OBJ_XCOFF.
	* config/te-i386aix.h (REVERSE_SORT_RELOCS): Remove #undef.

gas/testsuite/
	* gas/ppc/xcoff-ref-1.s, gas/ppc/xcoff-ref-1.l: New test.
	* gas/ppc/aix.exp: Run it.


ld/testsuite/
	* ld-powerpc/aix-ref-1-32.od, ld-powerpc/aix-ref-1-64.od,
	ld-powerpc/aix-ref-1.s: New tests.
	* ld-powerpc/aix52.exp: Run them.
@
text
@d153 1
a153 2
		  RELOC_ENUM r_type ATTRIBUTE_UNUSED /* Relocation type.  */,
		  int at_beginning)	/* Add to the start of the list?  */
d197 4
d210 11
a220 7
    if (at_beginning)
      {
	fixP->fx_next = *seg_fix_rootP;
	*seg_fix_rootP = fixP;
	if (fixP->fx_next == NULL)
	  *seg_fix_tailP = fixP;
      }
d222 4
a225 8
      {
	fixP->fx_next = NULL;
	if (*seg_fix_tailP)
	  (*seg_fix_tailP)->fx_next = fixP;
	else
	  *seg_fix_rootP = fixP;
	*seg_fix_tailP = fixP;
      }
d243 1
a243 1
			   (symbolS *) NULL, offset, pcrel, r_type, FALSE);
d311 1
a311 13
  return fix_new_internal (frag, where, size, add, sub, off, pcrel,
			   r_type, FALSE);
}

/* Create a fixup at the beginning of FRAG.  The arguments are the same
   as for fix_new, except that WHERE is implicitly 0.  */

fixS *
fix_at_start (fragS *frag, int size, symbolS *add_symbol,
	      offsetT offset, int pcrel, RELOC_ENUM r_type)
{
  return fix_new_internal (frag, 0, size, add_symbol,
			   (symbolS *) NULL, offset, pcrel, r_type, TRUE);
@


1.125
log
@2009-08-31  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/10570
	* write.c (write_object_file): Revert the accidental change
	made in revision 1.124 on 2009-08-17.
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
@


1.124
log
@2009-08-17  Kai Tietz  <kai.tietz@@onevision.com>

        * config/obj-coff-seh.c: New file.
        * config/obj-coff-seh.h: Likewise.
        * config/obj-coff.c (obj-coff-seh.c): Add include.
        (coff_pseudo_table): Add new .seh... commands.
        * config/obj-coff.h (obj_coff_seh_do_final): Add new
        function prototype.
        (obj_coff_generate_pdata): New obj-coff hook.
        * gas/write.c (size_seg): Avoid sizing of already sized
        sections.
        (write_object_file): Call conditional hook
        objc_coff_generate_pdata.
        * Makefile.am: Add dependencies for new files.
        * Makefile.in: Regenerated.
@
text
@d1897 1
a1897 1
#ifdef tc_frob_file_after_reloc
d1903 1
@


1.123
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d563 3
d1892 3
a1894 1

d1897 1
a1897 1
#ifdef tc_frob_file_after_relocs
a1902 1

@


1.122
log
@	* write.c (write_object_file) [!WORKING_DOT_WORD]: When patching
	the jump table for multiple overflowing entries with the same
	target, handle base symbols being different.
	(relax_segment) <case rs_broken_word, second loop>: Whenever a
	single entry overflows, arrange to redirect all entries with the
	same target.
@
text
@d389 1
a389 1
      assert (prev_frag->fr_type != 0);
d399 2
a400 2
  assert (prev_frag->fr_type != 0);
  assert (prev_frag != &dummy);
d481 1
a481 1
      assert (fragP->fr_next == NULL
d569 1
a569 1
  assert (x);
d573 1
a573 1
  assert (x);
d577 1
a577 1
  assert (newsize >= size);
d1302 1
a1302 1
      assert (f->fr_type == rs_fill);
d1316 1
a1316 1
      assert (count >= 0);
d1413 1
a1413 1
  assert (result);
@


1.121
log
@	* write.c (TC_FORCE_RELOCATION_SUB_LOCAL): Heed md_register_arithmetic.
	(TC_VALIDATE_FIX_SUB): Likewise.
	* config/tc-frv.h (TC_FORCE_RELOCATION_SUB_LOCAL): Likewise.
	* config/tc-hppa.h (TC_FORCE_RELOCATION_SUB_LOCAL): Likewise.
	* config/tc-mn10300.h (TC_VALIDATE_FIX_SUB): Likewise.
	* config/tc-sh.h (TC_VALIDATE_FIX_SUB): Likewise.
	(TC_FORCE_RELOCATION_SUB_LOCAL): Likewise.
	* config/tc-sh64.h (TC_VALIDATE_FIX_SUB): Likewise.
	* config/tc-xtensa.h (TC_VALIDATE_FIX_SUB): Likewise.
	* doc/internals.texi (TC_FORCE_RELOCATION_SUB_ABS,
	TC_FORCE_RELOCATION_SUB_LOCAL, TC_VALIDATE_FIX_SUB): Show new param.
@
text
@d1674 1
a1674 7
	    /* This is the offset from ??? to table_ptr+0.  */
	    to_addr = table_addr - S_GET_VALUE (lie->sub);
#ifdef TC_CHECK_ADJUSTED_BROKEN_DOT_WORD
	    TC_CHECK_ADJUSTED_BROKEN_DOT_WORD (to_addr, lie);
#endif
	    md_number_to_chars (lie->word_goes_here, to_addr, 2);
	    for (untruth = lie->next_broken_word;
d1679 11
a1689 1
		  md_number_to_chars (untruth->word_goes_here, to_addr, 2);
a2232 1
			  lie->added = 1;
d2238 6
a2243 1
			  for (untruth = lie->next_broken_word;
d2254 2
@


1.120
log
@	* write.c (md_register_arithmetic): Define.
	(fixup_segment): Adjust TC_FORCE_RELOCATION_SUB_ABS invocation.
	Modify error message when registers involved.
	(TC_FORCE_RELOCATION_SUB_ABS): Heed md_register_arithmetic.
	* config/tc-sh.h (TC_FORCE_RELOCATION_SUB_ABS): Likewise.
@
text
@d68 2
a69 1
#define TC_FORCE_RELOCATION_SUB_LOCAL(FIX)	0
d71 1
a71 1
#define TC_FORCE_RELOCATION_SUB_LOCAL(FIX)	1
d78 2
a79 1
#define TC_VALIDATE_FIX_SUB(FIX) 1
d81 4
a84 3
#define TC_VALIDATE_FIX_SUB(FIX)		\
  ((FIX)->fx_r_type == BFD_RELOC_GPREL32	\
   || (FIX)->fx_r_type == BFD_RELOC_GPREL16)
d942 1
a942 1
		   && !TC_FORCE_RELOCATION_SUB_LOCAL (fixP))
d964 1
a964 1
	  else if (!TC_VALIDATE_FIX_SUB (fixP))
@


1.119
log
@	* write.c (install_reloc): Correct EMIT_SECTION_SYMBOLS test.
@
text
@d57 4
d62 2
a63 1
#define TC_FORCE_RELOCATION_SUB_ABS(FIX)	0
d932 1
a932 1
		   && !TC_FORCE_RELOCATION_SUB_ABS (fixP))
d963 12
a974 6
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("can't resolve `%s' {%s section} - `%s' {%s section}"),
			    fixP->fx_addsy ? S_GET_NAME (fixP->fx_addsy) : "0",
			    segment_name (add_symbol_segment),
			    S_GET_NAME (fixP->fx_subsy),
			    segment_name (sub_symbol_segment));
@


1.118
log
@	PR 6848
	* write.c (install_reloc): Check that reloc symbols have been
	written.
	(set_symtab): Mark symbols with BSF_KEEP.
@
text
@d1093 2
a1094 2
	  || !EMIT_SECTION_SYMBOLS
	  || !bfd_is_abs_section (sym->section)))
@


1.118.2.1
log
@	* write.c (install_reloc): Correct EMIT_SECTION_SYMBOLS test.
@
text
@d1093 2
a1094 2
	  || (EMIT_SECTION_SYMBOLS
	      && !bfd_is_abs_section (sym->section))))
@


1.118.2.2
log
@	* write.c (md_register_arithmetic): Define.
	(fixup_segment): Pass segment to TC_FORCE_RELOCATION_SUB_ABS,
	TC_FORCE_RELOCATION_SUB_LOCAL, TC_VALIDATE_FIX_SUB invocations.
	Modify error message when registers involved.
	(TC_FORCE_RELOCATION_SUB_ABS): Heed md_register_arithmetic.
	(TC_FORCE_RELOCATION_SUB_LOCAL, TC_VALIDATE_FIX_SUB): Likewise.
	* config/tc-frv.h (TC_FORCE_RELOCATION_SUB_LOCAL): Likewise.
	* config/tc-hppa.h (TC_FORCE_RELOCATION_SUB_LOCAL): Likewise.
	* config/tc-mn10300.h (TC_VALIDATE_FIX_SUB): Likewise.
	* config/tc-sh.h (TC_FORCE_RELOCATION_SUB_ABS): Likewise.
	(TC_FORCE_RELOCATION_SUB_LOCAL, TC_VALIDATE_FIX_SUB): Likewise.
	* config/tc-sh64.h (TC_VALIDATE_FIX_SUB): Likewise.
	* config/tc-xtensa.h (TC_VALIDATE_FIX_SUB): Likewise.
	* doc/internals.texi (TC_FORCE_RELOCATION_SUB_ABS,
	TC_FORCE_RELOCATION_SUB_LOCAL, TC_VALIDATE_FIX_SUB): Show new param.
@
text
@a56 4
#ifndef md_register_arithmetic
# define md_register_arithmetic 1
#endif

d58 1
a58 2
#define TC_FORCE_RELOCATION_SUB_ABS(FIX, SEG)	\
  (!md_register_arithmetic && (SEG) == reg_section)
d63 1
a63 2
#define TC_FORCE_RELOCATION_SUB_LOCAL(FIX, SEG)	\
  (!md_register_arithmetic && (SEG) == reg_section)
d65 1
a65 1
#define TC_FORCE_RELOCATION_SUB_LOCAL(FIX, SEG)	1
d72 1
a72 2
#define TC_VALIDATE_FIX_SUB(FIX, SEG)			\
  (md_register_arithmetic || (SEG) != reg_section)
d74 3
a76 4
#define TC_VALIDATE_FIX_SUB(FIX, SEG)			\
  ((md_register_arithmetic || (SEG) != reg_section)	\
   && ((FIX)->fx_r_type == BFD_RELOC_GPREL32		\
       || (FIX)->fx_r_type == BFD_RELOC_GPREL16))
d927 1
a927 1
		   && !TC_FORCE_RELOCATION_SUB_ABS (fixP, add_symbol_segment))
d934 1
a934 1
		   && !TC_FORCE_RELOCATION_SUB_LOCAL (fixP, add_symbol_segment))
d956 1
a956 1
	  else if (!TC_VALIDATE_FIX_SUB (fixP, add_symbol_segment))
d958 6
a963 12
	      if (!md_register_arithmetic
		  && (add_symbol_segment == reg_section
		      || sub_symbol_segment == reg_section))
		as_bad_where (fixP->fx_file, fixP->fx_line,
			      _("register value used as expression"));
	      else
		as_bad_where (fixP->fx_file, fixP->fx_line,
			      _("can't resolve `%s' {%s section} - `%s' {%s section}"),
			      fixP->fx_addsy ? S_GET_NAME (fixP->fx_addsy) : "0",
			      segment_name (add_symbol_segment),
			      S_GET_NAME (fixP->fx_subsy),
			      segment_name (sub_symbol_segment));
@


1.117
log
@Silence gcc printf warnings
@
text
@d1087 9
d1389 4
@


1.116
log
@	* write.c (relax_segment <rs_org>): Include current stretch
	value when calculating whether .org is backwards.
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
d2519 2
a2520 1
	   (long) fixp->fx_offset, (long) fixp->fx_addnumber);
@


1.115
log
@gas/

2008-03-03  Denys Vlasenko <vda.linux@@googlemail.com>
	    H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/5543
	* read.c (pseudo_set): Don't allow global register symbol.

	* symbols.c (S_SET_EXTERNAL): Don't allow register symbol
	global.

2008-03-03  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/5543
	* write.c (write_object_file): Don't allow symbols which were
	equated to register.  Stop if there is an error.

gas/testsuite/

2008-03-03  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/5543
	* gas/i386/i386.exp: Run inval-equ-1 and inval-equ-2.

	* gas/i386/inval-equ-1.l: New.
	* gas/i386/inval-equ-1.s: Likewise.
	* gas/i386/inval-equ-2.l: Likewise.
	* gas/i386/inval-equ-2.s: Likewise.
@
text
@d2308 1
a2308 1
		  after = fragP->fr_next->fr_address;
d2343 1
a2343 2
		      fragP->fr_fix = after - was_address;
		      break;
a2344 4

		  /* This is an absolute growth factor  */
		  growth -= stretch;
		  break;
d2346 1
@


1.114
log
@Add support for building on a 64-bit Windows host.
@
text
@d1766 7
d1840 4
@


1.113
log
@Switch to GPLv3
@
text
@d2489 3
a2491 1
  fprintf (stderr, "fix %lx %s:%d", (long) fixp, fixp->fx_file, fixp->fx_line);
d2508 4
a2511 2
  fprintf (stderr, "\n    size=%d frag=%lx where=%ld offset=%lx addnumber=%lx",
	   fixp->fx_size, (long) fixp->fx_frag, (long) fixp->fx_where,
@


1.112
log
@	* doc/as.texinfo (Reloc): Document.
	* read.c (potable): Add "reloc".
	(s_reloc): New function.
	* write.c (reloc_list): New global var.
	(resolve_reloc_expr_symbols): New function.
	(write_object_file): Call it.
	(write_relocs): Process reloc_list.
	* write.h (struct reloc_list): New.
	(reloc_list): Declare.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.111
log
@	PR 4029
	* write.c (relax_segment): Insert extra alignment padding
	to break infinite relax loop when given impossible
	gcc_except_table assembly.
@
text
@d120 3
d630 80
d1113 1
d1131 16
d1210 17
d1684 1
@


1.110
log
@	* write.c (size_seg): Always clear SEC_RELOC here.
	(install_reloc): New function, extracted from..
	(write_relocs): ..here.  Combine RELOC_EXPANSION_POSSIBLE code
	with !RELOC_EXPANSION_POSSIBLE code.  Don't add fr_offset when
	testing frag size.  Set SEC_RELOC here.
@
text
@d1963 32
a1994 7
    offsetT stretch;	/* May be any size, 0 or negative.  */
    /* Cumulative number of addresses we have relaxed this pass.
       We may have relaxed more than one address.  */
    int stretched;	/* Have we stretched on this pass?  */
    /* This is 'cuz stretch may be zero, when, in fact some piece of code
       grew, and another shrank.  If a branch instruction doesn't fit anymore,
       we could be scrod.  */
d2117 43
d2299 8
d2309 7
@


1.109
log
@	* write.c (TC_FX_SIZE_SLACK): Define.
	(write_relocs): Reinstate check for fixup within frag.
	* config/tc-bfin.h (TC_FX_SIZE_SLACK): Define.
	* config/tc-h8300.h (TC_FX_SIZE_SLACK): Define.
	* config/tc-mmix.h (TC_FX_SIZE_SLACK): Define.
	* config/tc-sh.h (TC_FX_SIZE_SLACK): Define.
	* config/tc-xstormy16.h (TC_FX_SIZE_SLACK): Define.
@
text
@d556 1
a556 5
  /* @@@@ This is just an approximation.  */
  if (seginfo && seginfo->fix_root)
    flags |= SEC_RELOC;
  else
    flags &= ~SEC_RELOC;
d999 26
a1031 1
  char *err;
d1040 6
a1045 1
    n++;
a1046 2
#ifndef RELOC_EXPANSION_POSSIBLE
  /* Set up reloc information as well.  */
d1052 1
a1052 2
      arelent *reloc;
      bfd_reloc_status_type s;
d1057 1
a1057 11
	{
	  n--;
	  continue;
	}

      reloc = tc_gen_reloc (sec, fixp);
      if (!reloc)
	{
	  n--;
	  continue;
	}
d1064 1
a1064 2
      if (slack >= 0
	  && loc > fixp->fx_frag->fr_fix + fixp->fx_frag->fr_offset)
d1068 3
a1070 26
      s = bfd_install_relocation (stdoutput, reloc,
				  fixp->fx_frag->fr_literal,
				  fixp->fx_frag->fr_address,
				  sec, &err);
      switch (s)
	{
	case bfd_reloc_ok:
	  break;
	case bfd_reloc_overflow:
	  as_bad_where (fixp->fx_file, fixp->fx_line,
			_("relocation overflow"));
	  break;
	case bfd_reloc_outofrange:
	  as_bad_where (fixp->fx_file, fixp->fx_line,
			_("relocation out of range"));
	  break;
	default:
	  as_fatal (_("%s:%u: bad return from bfd_install_relocation: %x"),
		    fixp->fx_file, fixp->fx_line, s);
	}
      relocs[i++] = reloc;
    }
#else
  n = n * MAX_RELOC_EXPANSION;
  /* Set up reloc information as well.  */
  relocs = xcalloc (n, sizeof (arelent *));
d1072 1
a1072 12
  i = 0;
  for (fixp = seginfo->fix_root; fixp != (fixS *) NULL; fixp = fixp->fx_next)
    {
      arelent **reloc;
      bfd_reloc_status_type s;
      int j;
      int fx_size, slack;
      offsetT loc;

      if (fixp->fx_done)
	{
	  n--;
d1074 6
a1079 3
	}

      reloc = tc_gen_reloc (sec, fixp);
d1081 1
a1081 2
      for (j = 0; reloc[j]; j++)
	{
d1083 2
a1084 12
	  assert (i <= n);
	}

      fx_size = fixp->fx_size;
      slack = TC_FX_SIZE_SLACK (fixp);
      if (slack > 0)
	fx_size = fx_size > slack ? fx_size - slack : 0;
      loc = fixp->fx_where + fx_size;
      if (slack >= 0
	  && loc > fixp->fx_frag->fr_fix + fixp->fx_frag->fr_offset)
	as_bad_where (fixp->fx_file, fixp->fx_line,
		      _("internal error: fixup not contained within frag"));
d1086 3
a1088 23
      for (j = 0; reloc[j]; j++)
	{
	  s = bfd_install_relocation (stdoutput, reloc[j],
				      fixp->fx_frag->fr_literal,
				      fixp->fx_frag->fr_address,
				      sec, &err);
	  switch (s)
	    {
	    case bfd_reloc_ok:
	      break;
	    case bfd_reloc_overflow:
	      as_bad_where (fixp->fx_file, fixp->fx_line,
			    _("relocation overflow"));
	      break;
	    case bfd_reloc_outofrange:
	      as_bad_where (fixp->fx_file, fixp->fx_line,
			    _("relocation out of range"));
	      break;
	    default:
	      as_fatal (_("%s:%u: bad return from bfd_install_relocation: %x"),
			fixp->fx_file, fixp->fx_line, s);
	    }
	}
a1090 1
#endif
d1111 6
a1116 5
    bfd_set_reloc (stdoutput, sec, relocs, n);
  else
    bfd_set_section_flags (abfd, sec,
			   (bfd_get_section_flags (abfd, sec)
			    & (flagword) ~SEC_RELOC));
@


1.108
log
@remove unused var
@
text
@d100 10
d1030 2
d1046 9
a1054 6
      /*
	This test is triggered inappropriately for the SH:
         if (fixp->fx_where + fixp->fx_size
	     > fixp->fx_frag->fr_fix + fixp->fx_frag->fr_offset)
	     abort ();
      */
d1089 2
d1105 8
a1112 2
      if (fixp->fx_where + fixp->fx_size
	  > fixp->fx_frag->fr_fix + fixp->fx_frag->fr_offset)
d1115 1
@


1.107
log
@remove unused var
@
text
@a1072 1
      symbolS *sym;
@


1.106
log
@	* write.c: White space fixes.
	(fixup_segment): Move symbol_mri_common_p adjustments..
	(write_relocs): ..and symbol_equated_reloc_p adjustments..
	(adjust_reloc_syms): ..to here.
@
text
@a1019 1
      symbolS *sym;
@


1.105
log
@	* subsegs.c (subseg_change, subseg_get): Use xcalloc rather than
	xmalloc, memset.  Don't bother assigning NULL to known zero mem.
	(subseg_set_rest): Remove unnecessary cast.
	* write.c: Include libbfd.h.  Replace PTR with void * throughout.
	Remove unnecessary forward declarations and casts.
	(set_symtab): Delete extern bfd_alloc.
	(fixup_segment): Move.
@
text
@d664 2
a665 2
	if (symbol_equated_reloc_p (sym)
	    || S_IS_WEAKREFR (sym))
d667 3
d671 2
a672 2
	    sym = symbol_get_value_expression (sym)->X_add_symbol;
	    fixp->fx_addsy = sym;
d677 2
a678 1
	    /* These symbols are handled specially in fixup_segment.  */
d707 1
a707 1
               symbol in a relocation.  */
d712 3
a714 3
           in .linkonce sections.  It can lead to confusion when a
           debugging section refers to a .linkonce section.  I hope
           this will always be correct.  */
a814 9
      if (fixP->fx_addsy != NULL
	  && symbol_mri_common_p (fixP->fx_addsy))
	{
	  add_number += S_GET_VALUE (fixP->fx_addsy);
	  fixP->fx_offset = add_number;
	  fixP->fx_addsy
	    = symbol_get_value_expression (fixP->fx_addsy)->X_add_symbol;
	}

a1027 18
      /* If this is an undefined symbol which was equated to another
         symbol, then generate the reloc against the latter symbol
         rather than the former.  */
      sym = fixp->fx_addsy;
      while (symbol_equated_reloc_p (sym))
	{
	  symbolS *n;

	  /* We must avoid looping, as that can occur with a badly
	     written program.  */
	  n = symbol_get_value_expression (sym)->X_add_symbol;
	  if (n == sym)
	    break;
	  fixp->fx_offset += symbol_get_value_expression (sym)->X_add_number;
	  sym = n;
	}
      fixp->fx_addsy = sym;

a1082 18
      /* If this is an undefined symbol which was equated to another
         symbol, then generate the reloc against the latter symbol
         rather than the former.  */
      sym = fixp->fx_addsy;
      while (symbol_equated_reloc_p (sym))
	{
	  symbolS *n;

	  /* We must avoid looping, as that can occur with a badly
	     written program.  */
	  n = symbol_get_value_expression (sym)->X_add_symbol;
	  if (n == sym)
	    break;
	  fixp->fx_offset += symbol_get_value_expression (sym)->X_add_number;
	  sym = n;
	}
      fixp->fx_addsy = sym;

d1662 1
a1662 1
             symbols.  */
d2003 3
a2005 3
         foo = .
         .org foo+16
         foo = .
d2007 1
a2007 1
	So we dictate that this algorithm can be at most O2.  */
d2130 5
a2134 5
                      /* Convert from an actual address to an octet offset
                         into the section.  Here it is assumed that the
                         section's VMA is zero, and can omit subtracting it
                         from the symbol's value to get the address offset.  */
                      know (S_GET_SEGMENT (symbolP)->vma == 0);
d2170 1
a2170 1
                         frag to avoid cascading errors.  */
@


1.104
log
@	* write.h (struct fix <fx_pcrel_adjust, fx_size>): Move.
	(struct fix <fx_plt>): Rename to tcbit2.
	* write.c (fix_new_internal): Adjust.
	(TC_FORCE_RELOCATION_LOCAL): Don't test fx_plt.
	* config/tc-arm.h (TC_FORCE_RELOCATION_LOCAL): Likewise.
	* config/tc-cris.h (TC_FORCE_RELOCATION_LOCAL): Likewise.
	* config/tc-i386.h (TC_FORCE_RELOCATION_LOCAL): Likewise.
	* config/tc-i960.h (TC_FORCE_RELOCATION_LOCAL): Likewise.
	* config/tc-sh.h (TC_FORCE_RELOCATION_LOCAL): Likewise.
	* config/tc-sh64.h (TC_FORCE_RELOCATION_LOCAL): Likewise.
	* config/tc-sparc.h (TC_FORCE_RELOCATION_LOCAL): Likewise.
	* config/tc-msp430.c (msp430_force_relocation_local): Likewise.
	* config/tc-ia64.c (emit_one_bundle): Don't set fx_plt.
	* config/tc-ia64.h (TC_FORCE_RELOCATION_LOCAL): Don't test fx_plt.
	Instead, compare fx_r_type.
	* config/tc-xtensa.c (xg_add_opcode_fix, md_apply_fix): Use
	fx_tcbit in place of fx_plt.
	* config/tc-xtensa.h (TC_FORCE_RELOCATION_LOCAL): Define.
	* doc/internals.texi (TC_FORCE_RELOCATION_LOCAL): Remove reference
	to fx_plt.
@
text
@d30 1
a111 2
static void renumber_sections (bfd *, asection *, PTR);

a121 16
static fixS *fix_new_internal (fragS *, int where, int size,
			       symbolS *add, symbolS *sub,
			       offsetT offset, int pcrel,
			       RELOC_ENUM r_type);
static long fixup_segment (fixS *, segT);
static relax_addressT relax_align (relax_addressT addr, int align);
static fragS *chain_frchains_together_1 (segT, struct frchain *);
static void chain_frchains_together (bfd *, segT, PTR);
static void cvt_frag_to_fill (segT, fragS *);
static void adjust_reloc_syms (bfd *, asection *, PTR);
static void fix_segment (bfd *, asection *, PTR);
static void write_relocs (bfd *, asection *, PTR);
static void write_contents (bfd *, asection *, PTR);
static void set_symtab (void);
static void merge_data_into_text (void);

d138 1
a138 1
  fixP = (fixS *) obstack_alloc (&notes, sizeof (fixS));
d350 1
a350 1
renumber_sections (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, PTR countparg)
d387 1
a387 1
			 PTR xxx ATTRIBUTE_UNUSED)
a514 2
static void size_seg (bfd *, asection *, PTR);

d516 1
a516 1
size_seg (bfd *abfd, asection *sec, PTR xxx ATTRIBUTE_UNUSED)
d627 1
a627 1
		   PTR xxx ATTRIBUTE_UNUSED)
d747 240
d990 1
a990 1
	     PTR xxx ATTRIBUTE_UNUSED)
d998 1
a998 1
write_relocs (bfd *abfd, asection *sec, PTR xxx ATTRIBUTE_UNUSED)
d1018 1
a1018 1
  relocs = (arelent **) xcalloc (n, sizeof (arelent *));
d1090 1
a1090 1
  relocs = (arelent **) xcalloc (n, sizeof (arelent *));
d1211 1
a1211 1
		PTR xxx ATTRIBUTE_UNUSED)
a1313 1
  extern PTR bfd_alloc (bfd *, bfd_size_type);
d1327 1
a1327 1
      asympp = (asymbol **) bfd_alloc (stdoutput, amt);
a2319 240
/* fixup_segment()

   Go through all the fixS's in a segment and see which ones can be
   handled now.  (These consist of fixS where we have since discovered
   the value of a symbol, or the address of the frag involved.)
   For each one, call md_apply_fix to put the fix into the frag data.

   Result is a count of how many relocation structs will be needed to
   handle the remaining fixS's that we couldn't completely handle here.
   These will be output later by emit_relocations().  */

static long
fixup_segment (fixS *fixP, segT this_segment)
{
  long seg_reloc_count = 0;
  valueT add_number;
  fragS *fragP;
  segT add_symbol_segment = absolute_section;

  if (fixP != NULL && abs_section_sym == NULL)
    abs_section_sym = section_symbol (absolute_section);

  /* If the linker is doing the relaxing, we must not do any fixups.

     Well, strictly speaking that's not true -- we could do any that
     are PC-relative and don't cross regions that could change size.
     And for the i960 we might be able to turn callx/callj into bal
     anyways in cases where we know the maximum displacement.  */
  if (linkrelax && TC_LINKRELAX_FIXUP (this_segment))
    {
      for (; fixP; fixP = fixP->fx_next)
	if (!fixP->fx_done)
	  {
	    if (fixP->fx_addsy == NULL)
	      {
		/* There was no symbol required by this relocation.
		   However, BFD doesn't really handle relocations
		   without symbols well. So fake up a local symbol in
		   the absolute section.  */
		fixP->fx_addsy = abs_section_sym;
	      }
	    symbol_mark_used_in_reloc (fixP->fx_addsy);
	    if (fixP->fx_subsy != NULL)
	      symbol_mark_used_in_reloc (fixP->fx_subsy);
	    seg_reloc_count++;
	  }
      TC_ADJUST_RELOC_COUNT (fixP, seg_reloc_count);
      return seg_reloc_count;
    }

  for (; fixP; fixP = fixP->fx_next)
    {
#ifdef DEBUG5
      fprintf (stderr, "\nprocessing fixup:\n");
      print_fixup (fixP);
#endif

      fragP = fixP->fx_frag;
      know (fragP);
#ifdef TC_VALIDATE_FIX
      TC_VALIDATE_FIX (fixP, this_segment, skip);
#endif
      add_number = fixP->fx_offset;

      if (fixP->fx_addsy != NULL
	  && symbol_mri_common_p (fixP->fx_addsy))
	{
	  add_number += S_GET_VALUE (fixP->fx_addsy);
	  fixP->fx_offset = add_number;
	  fixP->fx_addsy
	    = symbol_get_value_expression (fixP->fx_addsy)->X_add_symbol;
	}

      if (fixP->fx_addsy != NULL)
	add_symbol_segment = S_GET_SEGMENT (fixP->fx_addsy);

      if (fixP->fx_subsy != NULL)
	{
	  segT sub_symbol_segment;
	  resolve_symbol_value (fixP->fx_subsy);
	  sub_symbol_segment = S_GET_SEGMENT (fixP->fx_subsy);
	  if (fixP->fx_addsy != NULL
	      && sub_symbol_segment == add_symbol_segment
	      && !TC_FORCE_RELOCATION_SUB_SAME (fixP, add_symbol_segment))
	    {
	      add_number += S_GET_VALUE (fixP->fx_addsy);
	      add_number -= S_GET_VALUE (fixP->fx_subsy);
	      fixP->fx_offset = add_number;
	      fixP->fx_addsy = NULL;
	      fixP->fx_subsy = NULL;
#ifdef TC_M68K
	      /* See the comment below about 68k weirdness.  */
	      fixP->fx_pcrel = 0;
#endif
	    }
	  else if (sub_symbol_segment == absolute_section
		   && !TC_FORCE_RELOCATION_SUB_ABS (fixP))
	    {
	      add_number -= S_GET_VALUE (fixP->fx_subsy);
	      fixP->fx_offset = add_number;
	      fixP->fx_subsy = NULL;
	    }
	  else if (sub_symbol_segment == this_segment
		   && !TC_FORCE_RELOCATION_SUB_LOCAL (fixP))
	    {
	      add_number -= S_GET_VALUE (fixP->fx_subsy);
	      fixP->fx_offset = (add_number + fixP->fx_dot_value
				 + fixP->fx_frag->fr_address);

	      /* Make it pc-relative.  If the back-end code has not
		 selected a pc-relative reloc, cancel the adjustment
		 we do later on all pc-relative relocs.  */
	      if (0
#ifdef TC_M68K
		  /* Do this for m68k even if it's already described
		     as pc-relative.  On the m68k, an operand of
		     "pc@@(foo-.-2)" should address "foo" in a
		     pc-relative mode.  */
		  || 1
#endif
		  || !fixP->fx_pcrel)
		add_number += MD_PCREL_FROM_SECTION (fixP, this_segment);
	      fixP->fx_subsy = NULL;
	      fixP->fx_pcrel = 1;
	    }
	  else if (!TC_VALIDATE_FIX_SUB (fixP))
	    {
	      as_bad_where (fixP->fx_file, fixP->fx_line,
			    _("can't resolve `%s' {%s section} - `%s' {%s section}"),
			    fixP->fx_addsy ? S_GET_NAME (fixP->fx_addsy) : "0",
			    segment_name (add_symbol_segment),
			    S_GET_NAME (fixP->fx_subsy),
			    segment_name (sub_symbol_segment));
	    }
	}

      if (fixP->fx_addsy)
	{
	  if (add_symbol_segment == this_segment
	      && !TC_FORCE_RELOCATION_LOCAL (fixP))
	    {
	      /* This fixup was made when the symbol's segment was
		 SEG_UNKNOWN, but it is now in the local segment.
		 So we know how to do the address without relocation.  */
	      add_number += S_GET_VALUE (fixP->fx_addsy);
	      fixP->fx_offset = add_number;
	      if (fixP->fx_pcrel)
		add_number -= MD_PCREL_FROM_SECTION (fixP, this_segment);
	      fixP->fx_addsy = NULL;
	      fixP->fx_pcrel = 0;
	    }
	  else if (add_symbol_segment == absolute_section
		   && !TC_FORCE_RELOCATION_ABS (fixP))
	    {
	      add_number += S_GET_VALUE (fixP->fx_addsy);
	      fixP->fx_offset = add_number;
	      fixP->fx_addsy = NULL;
	    }
	  else if (add_symbol_segment != undefined_section
		   && ! bfd_is_com_section (add_symbol_segment)
		   && MD_APPLY_SYM_VALUE (fixP))
	    add_number += S_GET_VALUE (fixP->fx_addsy);
	}

      if (fixP->fx_pcrel)
	{
	  add_number -= MD_PCREL_FROM_SECTION (fixP, this_segment);
	  if (!fixP->fx_done && fixP->fx_addsy == NULL)
	    {
	      /* There was no symbol required by this relocation.
		 However, BFD doesn't really handle relocations
		 without symbols well. So fake up a local symbol in
		 the absolute section.  */
	      fixP->fx_addsy = abs_section_sym;
	    }
	}

      if (!fixP->fx_done)
	md_apply_fix (fixP, &add_number, this_segment);

      if (!fixP->fx_done)
	{
	  ++seg_reloc_count;
	  if (fixP->fx_addsy == NULL)
	    fixP->fx_addsy = abs_section_sym;
	  symbol_mark_used_in_reloc (fixP->fx_addsy);
	  if (fixP->fx_subsy != NULL)
	    symbol_mark_used_in_reloc (fixP->fx_subsy);
	}

      if (!fixP->fx_bit_fixP && !fixP->fx_no_overflow && fixP->fx_size != 0)
	{
	  if (fixP->fx_size < sizeof (valueT))
	    {
	      valueT mask;

	      mask = 0;
	      mask--;		/* Set all bits to one.  */
	      mask <<= fixP->fx_size * 8 - (fixP->fx_signed ? 1 : 0);
	      if ((add_number & mask) != 0 && (add_number & mask) != mask)
		{
		  char buf[50], buf2[50];
		  sprint_value (buf, fragP->fr_address + fixP->fx_where);
		  if (add_number > 1000)
		    sprint_value (buf2, add_number);
		  else
		    sprintf (buf2, "%ld", (long) add_number);
		  as_bad_where (fixP->fx_file, fixP->fx_line,
				_("value of %s too large for field of %d bytes at %s"),
				buf2, fixP->fx_size, buf);
		} /* Generic error checking.  */
	    }
#ifdef WARN_SIGNED_OVERFLOW_WORD
	  /* Warn if a .word value is too large when treated as a signed
	     number.  We already know it is not too negative.  This is to
	     catch over-large switches generated by gcc on the 68k.  */
	  if (!flag_signed_overflow_ok
	      && fixP->fx_size == 2
	      && add_number > 0x7fff)
	    as_bad_where (fixP->fx_file, fixP->fx_line,
			  _("signed .word overflow; switch may be too large; %ld at 0x%lx"),
			  (long) add_number,
			  (long) (fragP->fr_address + fixP->fx_where));
#endif
	}			/* Not a bit fix.  */

#ifdef TC_VALIDATE_FIX
    skip:  ATTRIBUTE_UNUSED_LABEL
      ;
#endif
#ifdef DEBUG5
      fprintf (stderr, "result:\n");
      print_fixup (fixP);
#endif
    }				/* For each fixS in this segment.  */

  TC_ADJUST_RELOC_COUNT (fixP, seg_reloc_count);
  return seg_reloc_count;
}

@


1.103
log
@	* write.c (chain_frchains_together_1): Assert that this function
	never returns a pointer to the auto variable `dummy'.
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
a47 1
   || (FIX)->fx_plt				\
a170 1
  fixP->fx_plt = 0;
d177 1
@


1.102
log
@	* as.h (as_perror): Delete declaration.
	* gdbinit.in (as_perror): Delete breakpoint.
	* messages.c (as_perror): Delete function.
	* doc/internals.texi: Remove as_perror description.
	* listing.c (listing_print: Don't use as_perror.
	* output-file.c (output_file_create, output_file_close): Likewise.
	* symbols.c (symbol_create, symbol_clone): Likewise.
	* write.c (write_contents): Likewise.
	* config/obj-som.c (obj_som_version, obj_som_copyright): Likewise.
	* config/tc-tic54x.c (tic54x_mlib): Likewise.
@
text
@d397 1
@


1.101
log
@	* write.c (relax_segment): Add pass count arg.  Don't error on
	negative org/space on first two passes.
	(relax_seg_info): New struct.
	(relax_seg, write_object_file): Adjust.
	* write.h (relax_segment): Update prototype.
@
text
@d1017 2
a1018 5
	    {
	      bfd_perror (stdoutput->filename);
	      as_perror (_("FATAL: Can't write %s"), stdoutput->filename);
	      exit (EXIT_FAILURE);
	    }
d1038 2
a1039 6
		    {
		      bfd_perror (stdoutput->filename);
		      as_perror (_("FATAL: Can't write %s"),
				 stdoutput->filename);
		      exit (EXIT_FAILURE);
		    }
@


1.100
log
@	* subsegs.h (struct frchain): Delete frch_seg.
	(frchain_root): Delete.
	(seg_info): Define as macro.
	* subsegs.c (frchain_root): Delete.
	(abs_seg_info, und_seg_info, absolute_frchain): Delete.
	(subsegs_begin, subseg_change): Adjust for above.
	(subseg_set_rest): Likewise.  Add new frchain structs to seginfo
	rather than to one big list.
	(subseg_get): Don't special case abs, und sections.
	(subseg_new, subseg_force_new): Don't set frchainP here.
	(seg_info): Delete.
	(subsegs_print_statistics): Adjust frag chain control list traversal.
	* debug.c (dmp_frags):  Likewise.
	* dwarf2dbg.c (first_frag_for_seg): Don't start looking for frag
	at frchain_root.  Make use of known frchain ordering.
	(last_frag_for_seg): Likewise.
	(get_frag_fix): Likewise.  Add seg param.
	(process_entries, out_debug_aranges): Adjust get_frag_fix calls.
	* write.c (chain_frchains_together_1): Adjust for struct frchain.
	(SUB_SEGMENT_ALIGN): Likewise.
	(subsegs_finish): Adjust frchain list traversal.
	* config/tc-xtensa.c (xtensa_cleanup_align_frags): Likewise.
	(xtensa_fix_target_frags, xtensa_mark_narrow_branches): Likewise.
	(xtensa_mark_zcl_first_insns, xtensa_fix_a0_b_retw_frags): Likewise.
	(xtensa_fix_b_j_loop_end_frags): Likewise.
	(xtensa_fix_close_loop_end_frags): Likewise.
	(xtensa_fix_short_loop_frags, xtensa_sanity_check): Likewise.
	(retrieve_segment_info): Delete frch_seg initialisation.
@
text
@d515 5
a519 1
static void relax_seg (bfd *, asection *, PTR);
d522 1
a522 1
relax_seg (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, PTR xxx)
d525 1
d528 2
a529 5
      && relax_segment (seginfo->frchainP->frch_root, sec))
    {
      int *result = (int *) xxx;
      *result = 1;
    }
d1211 1
d1270 1
a1272 2
      int changed;

d1293 4
a1296 3
      changed = 0;
      bfd_map_over_sections (stdoutput, relax_seg, &changed);
      if (!changed)
d1727 1
a1727 1
relax_segment (struct frag *segment_frag_root, segT segment)
d1841 1
d1971 20
d2003 1
a2003 1
		      growth = stretch;
d2029 8
a2097 1
  ret = 0;
@


1.99
log
@* config/tc-ppc.c (ppc_frob_file_before_adjust): Do not reference
dotname.
* write.c (write_object_file): Do not remove used weakrefd.
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
d382 1
a382 1
  for (; frchp && frchp->frch_seg == section; frchp = frchp->frch_next)
d1139 1
a1139 2
  (!(FRCHAIN)->frch_next || (FRCHAIN)->frch_next->frch_seg != (SEG)	\
   ? get_recorded_alignment (SEG) : 0)
d1149 1
d1151 1
a1151 1
  for (frchainP = frchain_root; frchainP; frchainP = frchainP->frch_next)
d1153 3
a1155 1
      int alignment = 0;
d1157 7
a1163 1
      subseg_set (frchainP->frch_seg, frchainP->frch_subseg);
d1165 4
a1168 8
      /* This now gets called even if we had errors.  In that case,
         any alignment is meaningless, and, moreover, will look weird
         if we are generating a listing.  */
      if (!had_errors ())
	{
	  alignment = SUB_SEGMENT_ALIGN (now_seg, frchainP);
	  if ((bfd_get_section_flags (now_seg->owner, now_seg) & SEC_MERGE)
	      && now_seg->entsize)
d1170 6
a1175 2
	      unsigned int entsize = now_seg->entsize;
	      int entalign = 0;
d1177 7
a1183 4
	      while ((entsize & 1) == 0)
		{
		  ++entalign;
		  entsize >>= 1;
a1184 2
	      if (entalign > alignment)
		alignment = entalign;
a1185 1
	}
d1187 4
a1190 4
      if (subseg_text_p (now_seg))
	frag_align_code (alignment, 0);
      else
	frag_align (alignment, 0, 0);
d1192 2
a1193 2
      /* frag_align will have left a new frag.
	 Use this last frag for an empty ".fill".
d1195 6
a1200 5
	 For this segment ...
	 Create a last frag. Do not leave a "being filled in frag".  */
      frag_wane (frag_now);
      frag_now->fr_fix = 0;
      know (frag_now->fr_next == NULL);
@


1.99.2.1
log
@Merge changes between binutils-csl-2_17-branchpoint and
binutils-2_17, except for the addition of generated files to CVS.
@
text
@d515 1
a515 5
struct relax_seg_info
{
  int pass;
  int changed;
};
d518 1
a518 1
relax_seg (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, void *xxx)
a520 1
  struct relax_seg_info *info = (struct relax_seg_info *) xxx;
d523 5
a527 2
      && relax_segment (seginfo->frchainP->frch_root, sec, info->pass))
    info->changed = 1;
a1199 1
  struct relax_seg_info rsi;
a1257 1
  rsi.pass = 0;
d1260 2
d1282 3
a1284 4
      rsi.changed = 0;
      bfd_map_over_sections (stdoutput, relax_seg, &rsi);
      rsi.pass++;
      if (!rsi.changed)
d1715 1
a1715 1
relax_segment (struct frag *segment_frag_root, segT segment, int pass)
a1828 1
    ret = 0;
a1957 20
		      growth = 0;

		      /* Don't error on first few frag relax passes.
			 The symbol might be an expression involving
			 symbol values from other sections.  If those
			 sections have not yet been processed their
			 frags will all have zero addresses, so we
			 will calculate incorrect values for them.  The
			 number of passes we allow before giving an
			 error is somewhat arbitrary.  It should be at
			 least one, with larger values requiring
			 increasingly contrived dependencies between
			 frags to trigger a false error.  */
		      if (pass < 2)
			{
			  /* Force another pass.  */
			  ret = 1;
			  break;
			}

d1970 1
a1970 1
		      break;
a1995 8
			/* Don't error on first few frag relax passes.
			   See rs_org comment for a longer explanation.  */
			if (pass < 2)
			  {
			    ret = 1;
			    break;
			  }

d2057 1
@


1.99.4.1
log
@	* write.c (relax_segment): Add pass count arg.  Don't error on
	negative org/space on first two passes.
	(relax_seg_info): New struct.
	(relax_seg, write_object_file): Adjust.
	* write.h (relax_segment): Update prototype.
@
text
@d515 1
a515 5
struct relax_seg_info
{
  int pass;
  int changed;
};
d518 1
a518 1
relax_seg (bfd *abfd ATTRIBUTE_UNUSED, asection *sec, void *xxx)
a520 1
  struct relax_seg_info *info = (struct relax_seg_info *) xxx;
d523 5
a527 2
      && relax_segment (seginfo->frchainP->frch_root, sec, info->pass))
    info->changed = 1;
a1199 1
  struct relax_seg_info rsi;
a1257 1
  rsi.pass = 0;
d1260 2
d1282 3
a1284 4
      rsi.changed = 0;
      bfd_map_over_sections (stdoutput, relax_seg, &rsi);
      rsi.pass++;
      if (!rsi.changed)
d1715 1
a1715 1
relax_segment (struct frag *segment_frag_root, segT segment, int pass)
a1828 1
    ret = 0;
a1957 20
		      growth = 0;

		      /* Don't error on first few frag relax passes.
			 The symbol might be an expression involving
			 symbol values from other sections.  If those
			 sections have not yet been processed their
			 frags will all have zero addresses, so we
			 will calculate incorrect values for them.  The
			 number of passes we allow before giving an
			 error is somewhat arbitrary.  It should be at
			 least one, with larger values requiring
			 increasingly contrived dependencies between
			 frags to trigger a false error.  */
		      if (pass < 2)
			{
			  /* Force another pass.  */
			  ret = 1;
			  break;
			}

d1970 1
a1970 1
		      break;
a1995 8
			/* Don't error on first few frag relax passes.
			   See rs_org comment for a longer explanation.  */
			if (pass < 2)
			  {
			    ret = 1;
			    break;
			  }

d2057 1
@


1.98
log
@	* read.c (s_comm_internal): Set bfd_com_section segment.
	(s_mri_common): Likewise.
	* write.c (write_object_file): Remove non-BFD assembler common
	sym handling.
@
text
@d1516 2
a1517 1
		  && (punt || S_IS_LOCAL (symp) || S_IS_WEAKREFD (symp))
@


1.97
log
@2005-10-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* write.c (adjust_reloc_syms): Undo the change made on
	2005-04-26 to allow local symbol set to undefined symbol.
@
text
@a1495 6
	  /* So far, common symbols have been treated like undefined symbols.
	     Put them in the common section now.  */
	  if (S_IS_DEFINED (symp) == 0
	      && S_GET_VALUE (symp) != 0)
	    S_SET_SEGMENT (symp, bfd_com_section_ptr);

@


1.96
log
@gas/ChangeLog:
* read.c (potable): Add weakref.
(s_weakref): New.
* read.h (s_weakref): Declare.
* struc-symbol.h (struct symbol): Add sy_weakrefr and sy_weakrefd.
* symbols.c (colon): Clear weakrefr.
(symbol_find_exact): Rename to, and reimplement in terms of...
(symbol_find_exact_noref): ... new function.
(symbol_find): Likewise...
(symbol_find_noref): ... ditto.
(resolve_symbol_value): Resolve weakrefr without setting their
values.
(S_SET_WEAK): Call hook.
(S_GET_VALUE): Follow weakref link.
(S_SET_VALUE): Clear weakrefr.
(S_IS_WEAK): Follow weakref link.
(S_IS_WEAKREFR, S_SET_WEAKREFR, S_CLEAR_WEAKREFR): New.
(S_IS_WEAKREFD, S_SET_WEAKREFD, S_CLEAR_WEAKREFD): New.
(symbol_set_value_expression, symbol_set_frag): Clear weakrefr.
(symbol_mark_used): Follow weakref link.
(print_symbol_value_1): Print weak, weakrefr and weakrefd.
* symbols.h (symbol_find_noref, symbol_find_exact_noref): Declare.
(S_IS_WEAKREFR, S_SET_WEAKREFR, S_CLEAR_WEAKREFR): Declare.
(S_IS_WEAKREFD, S_SET_WEAKREFD, S_CLEAR_WEAKREFD): Declare.
* write.c (adust_reloc_syms): Follow weakref link.  Do not
complain if target is undefined.
(write_object_file): Likewise.  Remove weakrefr symbols.  Drop
unreferenced weakrefd symbols.
* config/obj-coff.c (obj_frob_symbol): Do not force WEAKREFD
symbols EXTERNAL.
(pecoff_obj_set_weak_hook, pecoff_obj_clear_weak_hook): New.
* config/obj-coff.h (obj_set_weak_hook, obj_clear_weak_hook): Define.
* doc/as.texinfo: Document weakref.
* doc/internals.texi: Document new struct members, internal
functions and hooks.
gas/testsuite/ChangeLog:
* gas/all/weakref1.s, gas/all/weakref1.d: New test.
* gas/all/weakref1g.d, gas/all/weakref1l.d: New tests.
* gas/all/weakref1u.d, gas/all/weakref1w.d: New tests.
* gas/all/weakref2.s, gas/all/weakref3.s: New tests.
* gas/all/gas.exp: Run new tests.
@
text
@a683 9
	    symbolS *new_sym
	      = symbol_get_value_expression (sym)->X_add_symbol;
	    const char *name = S_GET_NAME (sym);
	    if (!S_IS_COMMON (new_sym)
		&& !TC_FAKE_LABEL (name)
		&& !S_IS_WEAKREFR (sym)
		&& (!S_IS_EXTERNAL (sym) || S_IS_LOCAL (sym)))
	      as_bad (_("Local symbol `%s' can't be equated to undefined symbol `%s'"),
		      name, S_GET_NAME (new_sym));
d685 1
a685 1
	    sym = new_sym;
@


1.95
log
@(generic_force_reloc): Do not call S_FORCE_RELOC if there is no symbol.
@
text
@d681 2
a682 1
	if (symbol_equated_reloc_p (sym))
d689 1
d1488 2
a1489 1
	  if (symbol_equated_reloc_p (symp))
d1494 1
d1531 1
a1531 1
		  && (punt || S_IS_LOCAL (symp))
@


1.94
log
@(relax_segment): Count the number of frags being processed and use this to
compute a maximum limit on the number of iterations that will be allowed when
attempting to relax the segment.
@
text
@d319 3
@


1.93
log
@	* README-vms: Delete.
	* config-gas.com: Delete.
	* makefile.vms: Delete.
	* vmsconf.sh: Delete.
	* config/atof-tahoe.c: Delete.
	* config/m88k-opcode.h: Delete.
	* config/obj-bout.c: Delete.
	* config/obj-bout.h: Delete.
	* config/obj-hp300.c: Delete.
	* config/obj-hp300.h: Delete.
	* config/tc-a29k.c: Delete.
	* config/tc-a29k.h: Delete.
	* config/tc-h8500.c: Delete.
	* config/tc-h8500.h: Delete.
	* config/tc-m88k.c: Delete.
	* config/tc-m88k.h: Delete.
	* config/tc-tahoe.c: Delete.
	* config/tc-tahoe.h: Delete.
	* config/tc-tic80.c: Delete.
	* config/tc-tic80.h: Delete.
	* config/tc-w65.c: Delete.
	* config/tc-w65.h: Delete.
	* config/te-aux.h: Delete.
	* config/te-delt88.h: Delete.
	* config/te-delta.h: Delete.
	* config/te-dpx2.h: Delete.
	* config/te-hp300.h: Delete.
	* config/te-ic960.h: Delete.
	* config/vms-a-conf.h: Delete.
	* doc/c-a29k.texi: Delete.
	* doc/c-h8500.texi: Delete.
	* doc/c-m88k.texi: Delete.
	* README: Remove obsolete examples, and list of supported targets.
	* Makefile.am: Remove a29k, h8500, m88k, tahoe, tic80, w65,
	bout and hp300 support.
	(DEP_FLAGS): Don't define BFD_ASSEMBLER.
	* configure.in: Remove --enable-bfd-assembler, need_bfd,
	primary_bfd_gas.
	* configure.tgt: Remove a29k, h8300-coff, h8500-*, i960 non-elf,
	m68k non bfd, m88k, or32-coff, tic80-*, vax non-bfd, w65k-*, *-nindy.
	* as.c: Remove all non-BFD_ASSEMBLER code, support for above targets.
	* as.h: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
	* input-file.c: Likewise.
	* listing.c: Likewise.
	* literal.c: Likewise.
	* messages.c: Likewise.
	* obj.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* stabs.c: Likewise.
	* struc-symbol.h: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* symbols.c: Likewise.
	* symbols.h: Likewise.
	* tc.h: Likewise.
	* write.c: Likewise.
	* write.h: Likewise.
	* config/aout_gnu.h: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-aout.h: Likewise.
	* config/obj-coff.c: Likewise.
	* config/obj-coff.h: Likewise.
	* config/obj-evax.h: Likewise.
	* config/obj-ieee.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-crx.h: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-d30v.h: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-fr30.h: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-hppa.h: Likewise.
	* config/tc-i370.h: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i860.h: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ip2k.h: Likewise.
	* config/tc-iq2000.h: Likewise.
	* config/tc-m32c.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m68k.h: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-maxq.h: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mn10200.h: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-mn10300.h: Likewise.
	* config/tc-ms1.h: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-msp430.h: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-ns32k.h: Likewise.
	* config/tc-openrisc.h: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.h: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic4x.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-vax.h: Likewise.
	* config/tc-xstormy16.h: Likewise.
	* config/tc-xtensa.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-z8k.h: Likewise.
	* config/vms-a-conf.h
	* doc/Makefile.am: Likewise.
	* doc/all.texi: Likewise.
	* doc/as.texinfo: Likewise.
	* doc/Makefile.in: Regenerate.
	* Makefile.in: Regenerate.
	* configure: Regenerate.
	* config.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d1724 3
a1726 2
  register struct frag *fragP;
  register relax_addressT address;
d1735 3
a1737 1
  for (fragP = segment_frag_root; fragP; fragP = fragP->fr_next)
d1813 1
d1822 14
d2054 1
a2054 1
	  }			/* For each frag in the segment.  */
d2056 7
a2062 2
    while (stretched);		/* Until nothing further to relax.  */
  }				/* do_relax  */
@


1.92
log
@gas:
	* cgen.c, cgen.h, tc.h, write.c, config/obj-coff.c
	* config/tc-a29k.c, config/tc-alpha.c, config/tc-alpha.h
	* config/tc-arc.c, config/tc-arc.h, config/tc-arm.c
	* config/tc-arm.h, config/tc-avr.c, config/tc-avr.h
	* config/tc-cris.c, config/tc-crx.c, config/tc-d10v.c
	* config/tc-d10v.h, config/tc-d30v.c, config/tc-d30v.h
	* config/tc-dlx.c, config/tc-dlx.h, config/tc-fr30.h
	* config/tc-frv.c, config/tc-frv.h, config/tc-h8300.c
	* config/tc-h8500.c, config/tc-hppa.c, config/tc-hppa.h
	* config/tc-i370.c, config/tc-i370.h, config/tc-i386.c
	* config/tc-i386.h, config/tc-i860.c, config/tc-i860.h
	* config/tc-i960.c, config/tc-i960.h, config/tc-ia64.c
	* config/tc-ip2k.c, config/tc-ip2k.h, config/tc-iq2000.c
	* config/tc-iq2000.h, config/tc-m32r.c, config/tc-m32r.h
	* config/tc-m68hc11.c, config/tc-m68hc11.h, config/tc-m68k.c
	* config/tc-m68k.h, config/tc-m88k.c, config/tc-maxq.c
	* config/tc-mcore.c, config/tc-mcore.h, config/tc-mips.c
	* config/tc-mips.h, config/tc-mmix.c, config/tc-mn10200.c
	* config/tc-mn10300.c, config/tc-msp430.c, config/tc-ns32k.c
	* config/tc-openrisc.h, config/tc-or32.c, config/tc-or32.h
	* config/tc-pdp11.c, config/tc-pj.c, config/tc-pj.h
	* config/tc-ppc.c, config/tc-ppc.h, config/tc-s390.c
	* config/tc-s390.h, config/tc-sh64.c, config/tc-sh.c
	* config/tc-sh.h, config/tc-sparc.c, config/tc-sparc.h
	* config/tc-tahoe.c, config/tc-tic30.c, config/tc-tic4x.c
	* config/tc-tic54x.c, config/tc-tic80.c, config/tc-v850.c
	* config/tc-v850.h, config/tc-vax.c, config/tc-vax.h
	* config/tc-w65.c, config/tc-xstormy16.c, config/tc-xstormy16.h
	* config/tc-xtensa.c, config/tc-z8k.c:
	Replace all instances of the string "_apply_fix3" with
	"_apply_fix".
	* po/POTFILES.in, po/gas.pot: Regenerate.
bfd:
	* coff-i386.c: Change md_apply_fix3 to md_apply_fix in comment.
cgen:
	* doc/porting.texi: Change all mention of md_apply_fix3 and
	gas_cgen_md_apply_fix3 to md_apply_fix and gas_cgen_md_apply_fix
	respectively.
@
text
@a73 1
#ifdef BFD_ASSEMBLER
a76 3
#else
#define TC_VALIDATE_FIX_SUB(FIX) 0
#endif
a111 1
#ifdef BFD_ASSEMBLER
a118 26
#endif

#ifndef BFD_ASSEMBLER

#ifndef MANY_SEGMENTS
struct frag *text_frag_root;
struct frag *data_frag_root;
struct frag *bss_frag_root;

struct frag *text_last_frag;	/* Last frag in segment.  */
struct frag *data_last_frag;	/* Last frag in segment.  */
static struct frag *bss_last_frag;	/* Last frag in segment.  */
#endif

#ifndef BFD
static object_headers headers;
#endif

long string_byte_count;
char *next_object_file_charP;	/* Tracks object file bytes.  */

#ifndef OBJ_VMS
int magic_number_for_object_file = DEFAULT_MAGIC_NUMBER_FOR_OBJECT_FILE;
#endif

#endif /* BFD_ASSEMBLER  */
a121 1
#ifdef BFD_ASSEMBLER
a122 3
#else
#define RELOC_ENUM int
#endif
a127 1
#if defined (BFD_ASSEMBLER) || (!defined (BFD) && !defined (OBJ_VMS))
a128 1
#endif
a129 1
#if defined (BFD_ASSEMBLER) || ! defined (BFD)
a130 2
#endif
#ifdef BFD_ASSEMBLER
a137 2
#endif
#if defined (BFD_ASSEMBLER) || (! defined (BFD) && ! defined (OBJ_AOUT))
a138 6
#endif
#if ! defined (BFD_ASSEMBLER) && ! defined (BFD)
static void cvt_frag_to_fill (object_headers *, segT, fragS *);
static void remove_subsegs (frchainS *, int, fragS **, fragS **);
static void relax_and_size_all_segments (void);
#endif
a172 1
#if defined(NEED_FX_R_TYPE) || defined (BFD_ASSEMBLER)
a173 1
#endif
a199 1
#ifdef BFD_ASSEMBLER
a205 1
#endif
a284 2

#if defined(BFD_ASSEMBLER)
a285 7
#else
#if defined(TC_RVA_RELOC)
      r_type = TC_RVA_RELOC;
#else
      as_fatal (_("rva not supported"));
#endif
#endif
a314 1
#ifdef BFD_ASSEMBLER
d318 1
a318 1
#endif
a333 4
#ifndef BFD_ASSEMBLER
int section_alignment[SEG_MAXIMUM_ORDINAL];
#endif

d348 1
a348 1
#ifdef BFD_ASSEMBLER
a350 4
#else
  if (align > section_alignment[(int) seg])
    section_alignment[(int) seg] = align;
#endif
d358 1
a358 1
#ifdef BFD_ASSEMBLER
a359 3
#else
  return section_alignment[(int) seg];
#endif
a361 2
#ifdef BFD_ASSEMBLER

a372 4
#endif /* defined (BFD_ASSEMBLER)  */

#if defined (BFD_ASSEMBLER) || ! defined (BFD)

a376 1
#ifdef BFD_ASSEMBLER
a377 1
#endif
a383 1
#ifdef BFD_ASSEMBLER
a391 1
#endif
a397 4
#endif

#ifdef BFD_ASSEMBLER

a416 16
#endif

#if !defined (BFD) && !defined (BFD_ASSEMBLER)

static void
remove_subsegs (frchainS *head, int seg, fragS **root, fragS **last)
{
  *root = head->frch_root;
  *last = chain_frchains_together_1 (seg, head);
}

#endif /* BFD  */

#if defined (BFD_ASSEMBLER) || !defined (BFD)

#ifdef BFD_ASSEMBLER
a418 4
#else
static void
cvt_frag_to_fill (object_headers *headersP, segT sec, fragS *fragP)
#endif
a471 1
#ifdef BFD_ASSEMBLER
a472 3
#else
      md_convert_frag (headersP, sec, fragP);
#endif
a511 3
#endif /* defined (BFD_ASSEMBLER) || !defined (BFD)  */

#ifdef BFD_ASSEMBLER
a1083 1
#endif
a1084 1
#if defined(BFD_ASSEMBLER) || (!defined (BFD) && !defined(OBJ_AOUT))
a1087 1
#if defined(BFD_ASSEMBLER) || defined(MANY_SEGMENTS)
a1092 17
#else
  fixS *tmp;

  text_last_frag->fr_next = data_frag_root;
  text_last_frag = data_last_frag;
  data_last_frag = NULL;
  data_frag_root = NULL;
  if (text_fix_root)
    {
      for (tmp = text_fix_root; tmp->fx_next; tmp = tmp->fx_next);;
      tmp->fx_next = data_fix_root;
      text_fix_tail = data_fix_tail;
    }
  else
    text_fix_root = data_fix_root;
  data_fix_root = NULL;
#endif
a1093 1
#endif /* BFD_ASSEMBLER || (! BFD && ! OBJ_AOUT)  */
a1094 88
#if !defined (BFD_ASSEMBLER) && !defined (BFD)
static void
relax_and_size_all_segments ()
{
  fragS *fragP;

  relax_segment (text_frag_root, SEG_TEXT);
  relax_segment (data_frag_root, SEG_DATA);
  relax_segment (bss_frag_root, SEG_BSS);

  /* Now the addresses of frags are correct within the segment.  */
  know (text_last_frag->fr_type == rs_fill && text_last_frag->fr_offset == 0);
  H_SET_TEXT_SIZE (&headers, text_last_frag->fr_address);
  text_last_frag->fr_address = H_GET_TEXT_SIZE (&headers);

  /* Join the 2 segments into 1 huge segment.
     To do this, re-compute every rn_address in the SEG_DATA frags.
     Then join the data frags after the text frags.

     Determine a_data [length of data segment].  */
  if (data_frag_root)
    {
      register relax_addressT slide;

      know ((text_last_frag->fr_type == rs_fill)
	    && (text_last_frag->fr_offset == 0));

      H_SET_DATA_SIZE (&headers, data_last_frag->fr_address);
      data_last_frag->fr_address = H_GET_DATA_SIZE (&headers);
      slide = H_GET_TEXT_SIZE (&headers);	/* & in file of the data segment.  */
#ifdef OBJ_BOUT
#define RoundUp(N,S) (((N)+(S)-1)&-(S))
      /* For b.out: If the data section has a strict alignment
	 requirement, its load address in the .o file will be
	 rounded up from the size of the text section.  These
	 two values are *not* the same!  Similarly for the bss
	 section....  */
      slide = RoundUp (slide, 1 << section_alignment[SEG_DATA]);
#endif

      for (fragP = data_frag_root; fragP; fragP = fragP->fr_next)
	fragP->fr_address += slide;

      know (text_last_frag != 0);
      text_last_frag->fr_next = data_frag_root;
    }
  else
    {
      H_SET_DATA_SIZE (&headers, 0);
    }

#ifdef OBJ_BOUT
  /* See above comments on b.out data section address.  */
  {
    addressT bss_vma;
    if (data_last_frag == 0)
      bss_vma = H_GET_TEXT_SIZE (&headers);
    else
      bss_vma = data_last_frag->fr_address;
    bss_vma = RoundUp (bss_vma, 1 << section_alignment[SEG_BSS]);
    bss_address_frag.fr_address = bss_vma;
  }
#else /* ! OBJ_BOUT  */
  bss_address_frag.fr_address = (H_GET_TEXT_SIZE (&headers) +
				 H_GET_DATA_SIZE (&headers));

#endif /* ! OBJ_BOUT  */

  /* Slide all the frags.  */
  if (bss_frag_root)
    {
      relax_addressT slide = bss_address_frag.fr_address;

      for (fragP = bss_frag_root; fragP; fragP = fragP->fr_next)
	fragP->fr_address += slide;
    }

  if (bss_last_frag)
    H_SET_BSS_SIZE (&headers,
		    bss_last_frag->fr_address - bss_frag_root->fr_address);
  else
    H_SET_BSS_SIZE (&headers, 0);
}
#endif /* ! BFD_ASSEMBLER && ! BFD  */

#if defined (BFD_ASSEMBLER) || !defined (BFD)

#ifdef BFD_ASSEMBLER
a1129 1
#endif
a1145 1
#ifdef BFD_ASSEMBLER
a1146 3
#else
#define SUB_SEGMENT_ALIGN(SEG, FRCHAIN) 2
#endif
a1166 1
#ifdef BFD_ASSEMBLER
a1180 1
#endif
d1204 1
a1204 1
#if ! defined (BFD_ASSEMBLER) || ! defined (WORKING_DOT_WORD)
a1240 1
#ifdef BFD_ASSEMBLER
a1252 5
#else
  remove_subsegs (frchain_root, SEG_TEXT, &text_frag_root, &text_last_frag);
  remove_subsegs (data0_frchainP, SEG_DATA, &data_frag_root, &data_last_frag);
  remove_subsegs (bss0_frchainP, SEG_BSS, &bss_frag_root, &bss_last_frag);
#endif
a1256 1
#if !defined (OBJ_AOUT) || defined (BFD_ASSEMBLER)
a1260 1
#endif
a1261 1
#ifdef BFD_ASSEMBLER
a1301 3
#else
  relax_and_size_all_segments ();
#endif /* BFD_ASSEMBLER  */
a1309 58
#ifndef BFD_ASSEMBLER
  /* Crawl the symbol chain.

     For each symbol whose value depends on a frag, take the address of
     that frag and subsume it into the value of the symbol.
     After this, there is just one way to lookup a symbol value.
     Values are left in their final state for object file emission.
     We adjust the values of 'L' local symbols, even if we do
     not intend to emit them to the object file, because their values
     are needed for fix-ups.

     Unless we saw a -L flag, remove all symbols that begin with 'L'
     from the symbol chain.  (They are still pointed to by the fixes.)

     Count the remaining symbols.
     Assign a symbol number to each symbol.
     Count the number of string-table chars we will emit.
     Put this info into the headers as appropriate.  */
  know (zero_address_frag.fr_address == 0);
  string_byte_count = 4;

  obj_crawl_symbol_chain (&headers);

  if (string_byte_count == 4)
    string_byte_count = 0;

  H_SET_STRING_SIZE (&headers, string_byte_count);

  /* Addresses of frags now reflect addresses we use in the object file.
     Symbol values are correct.
     Scan the frags, converting any ".org"s and ".align"s to ".fill"s.
     Also converting any machine-dependent frags using md_convert_frag();  */
  subseg_change (SEG_TEXT, 0);

  for (fragP = text_frag_root; fragP; fragP = fragP->fr_next)
    {
      /* At this point we have linked all the frags into a single
         chain.  However, cvt_frag_to_fill may call md_convert_frag
         which may call fix_new.  We need to ensure that fix_new adds
         the fixup to the right section.  */
      if (fragP == data_frag_root)
	subseg_change (SEG_DATA, 0);

      cvt_frag_to_fill (&headers, SEG_TEXT, fragP);

      /* Some assert macros don't work with # directives mixed in.  */
#ifndef NDEBUG
      if (!(fragP->fr_next == NULL
#ifdef OBJ_BOUT
	    || fragP->fr_next == data_frag_root
#endif
	    || ((offsetT) (fragP->fr_next->fr_address - fragP->fr_address)
		== (fragP->fr_fix + fragP->fr_offset * fragP->fr_var))))
	abort ();
#endif
    }
#endif /* ! BFD_ASSEMBLER  */

a1325 1
#ifdef BFD_ASSEMBLER
a1334 17
#else
#if defined(TC_SPARC) || defined(TC_A29K) || defined(NEED_FX_R_TYPE)
	  fix_new_exp (lie->frag,
		       lie->word_goes_here - lie->frag->fr_literal,
		       2, &exp, 0, NO_RELOC);
#else
#ifdef TC_NS32K
	  fix_new_ns32k_exp (lie->frag,
			     lie->word_goes_here - lie->frag->fr_literal,
			     2, &exp, 0, 0, 2, 0, 0);
#else
	  fix_new_exp (lie->frag,
		       lie->word_goes_here - lie->frag->fr_literal,
		       2, &exp, 0, 0);
#endif /* TC_NS32K  */
#endif /* TC_SPARC|TC_A29K|NEED_FX_R_TYPE  */
#endif /* BFD_ASSEMBLER  */
a1404 126
#ifndef BFD_ASSEMBLER
#ifndef	OBJ_VMS
  {				/* not vms  */
    char *the_object_file;
    long object_file_size;
    /* Scan every FixS performing fixups. We had to wait until now to
       do this because md_convert_frag() may have made some fixSs.  */
    int trsize, drsize;

    subseg_change (SEG_TEXT, 0);
    trsize = md_reloc_size * fixup_segment (text_fix_root, SEG_TEXT);
    subseg_change (SEG_DATA, 0);
    drsize = md_reloc_size * fixup_segment (data_fix_root, SEG_DATA);
    H_SET_RELOCATION_SIZE (&headers, trsize, drsize);

    /* FIXME: Move this stuff into the pre-write-hook.  */
    H_SET_MAGIC_NUMBER (&headers, magic_number_for_object_file);
    H_SET_ENTRY_POINT (&headers, 0);

    obj_pre_write_hook (&headers);	/* Extra coff stuff.  */

    object_file_size = H_GET_FILE_SIZE (&headers);
    next_object_file_charP = the_object_file = xmalloc (object_file_size);

    output_file_create (out_file_name);

    obj_header_append (&next_object_file_charP, &headers);

    know ((next_object_file_charP - the_object_file)
	  == H_GET_HEADER_SIZE (&headers));

    /* Emit code.  */
    for (fragP = text_frag_root; fragP; fragP = fragP->fr_next)
      {
	register long count;
	register char *fill_literal;
	register long fill_size;

	PROGRESS (1);
	know (fragP->fr_type == rs_fill);
	append (&next_object_file_charP, fragP->fr_literal,
		(unsigned long) fragP->fr_fix);
	fill_literal = fragP->fr_literal + fragP->fr_fix;
	fill_size = fragP->fr_var;
	know (fragP->fr_offset >= 0);

	for (count = fragP->fr_offset; count; count--)
	  append (&next_object_file_charP, fill_literal,
		  (unsigned long) fill_size);
      }

    know ((next_object_file_charP - the_object_file)
	  == (H_GET_HEADER_SIZE (&headers)
	      + H_GET_TEXT_SIZE (&headers)
	      + H_GET_DATA_SIZE (&headers)));

    /* Emit relocations.  */
    obj_emit_relocations (&next_object_file_charP, text_fix_root,
			  (relax_addressT) 0);
    know ((next_object_file_charP - the_object_file)
	  == (H_GET_HEADER_SIZE (&headers)
	      + H_GET_TEXT_SIZE (&headers)
	      + H_GET_DATA_SIZE (&headers)
	      + H_GET_TEXT_RELOCATION_SIZE (&headers)));
#ifdef TC_I960
    /* Make addresses in data relocation directives relative to beginning of
       first data fragment, not end of last text fragment:  alignment of the
       start of the data segment may place a gap between the segments.  */
    obj_emit_relocations (&next_object_file_charP, data_fix_root,
			  data0_frchainP->frch_root->fr_address);
#else /* TC_I960  */
    obj_emit_relocations (&next_object_file_charP, data_fix_root,
			  text_last_frag->fr_address);
#endif /* TC_I960  */

    know ((next_object_file_charP - the_object_file)
	  == (H_GET_HEADER_SIZE (&headers)
	      + H_GET_TEXT_SIZE (&headers)
	      + H_GET_DATA_SIZE (&headers)
	      + H_GET_TEXT_RELOCATION_SIZE (&headers)
	      + H_GET_DATA_RELOCATION_SIZE (&headers)));

    /* Emit line number entries.  */
    OBJ_EMIT_LINENO (&next_object_file_charP, lineno_rootP, the_object_file);
    know ((next_object_file_charP - the_object_file)
	  == (H_GET_HEADER_SIZE (&headers)
	      + H_GET_TEXT_SIZE (&headers)
	      + H_GET_DATA_SIZE (&headers)
	      + H_GET_TEXT_RELOCATION_SIZE (&headers)
	      + H_GET_DATA_RELOCATION_SIZE (&headers)
	      + H_GET_LINENO_SIZE (&headers)));

    /* Emit symbols.  */
    obj_emit_symbols (&next_object_file_charP, symbol_rootP);
    know ((next_object_file_charP - the_object_file)
	  == (H_GET_HEADER_SIZE (&headers)
	      + H_GET_TEXT_SIZE (&headers)
	      + H_GET_DATA_SIZE (&headers)
	      + H_GET_TEXT_RELOCATION_SIZE (&headers)
	      + H_GET_DATA_RELOCATION_SIZE (&headers)
	      + H_GET_LINENO_SIZE (&headers)
	      + H_GET_SYMBOL_TABLE_SIZE (&headers)));

    /* Emit strings.  */
    if (string_byte_count > 0)
      obj_emit_strings (&next_object_file_charP);

#ifdef BFD_HEADERS
    bfd_seek (stdoutput, (file_ptr) 0, 0);
    bfd_bwrite (the_object_file, (bfd_size_type) object_file_size, stdoutput);
#else

    /* Write the data to the file.  */
    output_file_append (the_object_file, object_file_size, out_file_name);
    free (the_object_file);
#endif
  }
#else /* OBJ_VMS  */
  /* Now do the VMS-dependent part of writing the object file.  */
  vms_write_object_file (H_GET_TEXT_SIZE (&headers),
			 H_GET_DATA_SIZE (&headers),
			 H_GET_BSS_SIZE (&headers),
			 text_frag_root, data_frag_root);
#endif /* OBJ_VMS  */
#else /* BFD_ASSEMBLER  */

a1590 1
#endif /* BFD_ASSEMBLER  */
a1591 1
#endif /* ! BFD  */
a1593 1

a1623 6
#if !defined (MANY_SEGMENTS) && !defined (BFD_ASSEMBLER)
      know ((S_GET_SEGMENT (symbolP) == SEG_ABSOLUTE)
	    || (S_GET_SEGMENT (symbolP) == SEG_DATA)
	    || (S_GET_SEGMENT (symbolP) == SEG_BSS)
	    || (S_GET_SEGMENT (symbolP) == SEG_TEXT));
#endif
a1727 3
#if !defined (MANY_SEGMENTS) && !defined (BFD_ASSEMBLER)
  know (segment == SEG_DATA || segment == SEG_TEXT || segment == SEG_BSS);
#endif
a1933 9
#if !defined (MANY_SEGMENTS) && !defined (BFD_ASSEMBLER)
		      know ((S_GET_SEGMENT (symbolP) == SEG_ABSOLUTE)
			    || (S_GET_SEGMENT (symbolP) == SEG_DATA)
			    || (S_GET_SEGMENT (symbolP) == SEG_TEXT)
			    || S_GET_SEGMENT (symbolP) == SEG_BSS);
		      know (symbolP->sy_frag);
		      know (!(S_GET_SEGMENT (symbolP) == SEG_ABSOLUTE)
			    || (symbolP->sy_frag == &zero_address_frag));
#endif
a1937 1
#ifdef BFD_ASSEMBLER
a1938 1
#endif
a2050 2
#if defined (BFD_ASSEMBLER) || (!defined (BFD) && !defined (OBJ_VMS))

d2071 1
a2071 7
    {
#ifndef BFD_ASSEMBLER
      abs_section_sym = &abs_symbol;
#else
      abs_section_sym = section_symbol (absolute_section);
#endif
    }
a2209 1
#ifdef BFD_ASSEMBLER
a2210 1
#endif
a2290 2
#endif /* defined (BFD_ASSEMBLER) || (!defined (BFD) && !defined (OBJ_VMS)) */

a2347 1
#ifdef BFD_ASSEMBLER
a2349 5
#else
#ifdef NEED_FX_R_TYPE
  fprintf (stderr, " r_type=%d", fixp->fx_r_type);
#endif
#endif
@


1.91
log
@2005-05-31  Christian Groessler  <chris@@groessler.org>

	* write.c (dump_section_relocs): Convert to ISO-C.
	(write_relocs): Avoid signed/unsigned and fprintf argument
	warnings in debug code.
@
text
@d2525 1
a2525 1
   For each one, call md_apply_fix3 to put the fix into the frag data.
d2706 1
a2706 1
	md_apply_fix3 (fixP, &add_number, this_segment);
@


1.90
log
@2005-05-09  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 936
	* config/tc-sh64.c (sh64_fake_label): New.

	* config/tc-sh64.h (TC_FAKE_LABEL): New.

	* doc/internals.texi (TC_FAKE_LABEL): Document.

	* write.c (TC_FAKE_LABEL): New.
	(adjust_reloc_syms): Use it.
	(write_object_file): Likewise.
@
text
@d716 1
a716 4
dump_section_relocs (abfd, sec, stream_)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     char *stream_;
a717 1
  FILE *stream = (FILE *) stream_;
d1059 1
a1059 1
    int i, j, nsyms;
d1088 1
a1088 1
    int i;
d1096 2
a1097 2
	fprintf (stderr, "  reloc %2d @@%08x off %4x : sym %-10s addend %x\n",
		 i, r, r->address, s->name, r->addend);
@


1.89
log
@Update the address and phone number of the FSF
@
text
@d100 4
d802 1
a802 1
		&& strcmp (name, FAKE_LABEL_NAME)
d1935 1
a1935 1
		  && strcmp (name, FAKE_LABEL_NAME)
@


1.88
log
@bfd/

2005-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfd.c (bfd): Remove section_tail and add section_last.
	(bfd_preserve): Likewise.
	(bfd_preserve_save): Likewise.
	(bfd_preserve_restore): Likewise.
	* opncls.c (_bfd_new_bfd): Likewise.

	* coffcode.h (coff_compute_section_file_positions): Updated.
	(coff_compute_section_file_positions): Likewise.
	* elf.c (assign_section_numbers): Likewise.
	* elf32-i370.c (i370_elf_size_dynamic_sections): Likewise.
	* elf64-mmix.c (mmix_elf_final_link): Likewise.
	* elfxx-ia64.c (elfNN_ia64_object_p): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_link_hash_table_create): Likewise.
	* sunos.c (sunos_add_dynamic_symbols): Likewise.
	* xcofflink.c (_bfd_xcoff_bfd_final_link): Likewise.

	* ecoff.c (bfd_debug_section): Initialize prev.

	* section.c (bfd_section): Add prev.
	(bfd_section_list_remove): Updated.
	(bfd_section_list_append): New.
	(bfd_section_list_insert_after): New.
	(bfd_section_list_insert_before): New.
	(bfd_section_list_insert): Removed.
	(bfd_section_removed_from_list): Updated.
	(STD_SECTION): Initialize prev.
	(bfd_section_init): Updated.
	(bfd_section_list_clear): Updated.

	* bfd-in2.h: Regenerated.

gas/

2005-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* write.c (write_object_file): Use bfd_section_double_list_remove
	to remove sections.

ld/

2005-05-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* emultempl/elf32.em (gld${EMULATION_NAME}_strip_empty_section):
	Updated for bfd_section_list_remove change.
	* ldlang.c (lang_insert_orphan): Likewise.
	(strip_excluded_output_sections): Likewise.
	(sort_sections_by_lma): New.
	(lang_check_section_addresses): Sort the sections before
	checking addresses.
@
text
@d20 2
a21 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.87
log
@gas/

2005-04-26  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-multi.h (FAKE_LABEL_NAME): Defined.

	* read.c (pseudo_set): Disallow symbol set to common symbol.

	PR 857
	* write.c (write_object_file): Report common symbol name when
	disallowing local symbol set to common symbol.
	(adjust_reloc_syms): Disallow local symbol set to undefined
	symbol.

gas/testsuite/

2005-04-26  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/all/assign.s: Make `x' and `y' global.
@
text
@a1473 1
    asection **seclist;
d1476 3
a1478 11
    seclist = &stdoutput->sections;
    while (*seclist)
      {
	if (*seclist == reg_section || *seclist == expr_section)
	  {
	    bfd_section_list_remove (stdoutput, seclist);
	    stdoutput->section_count--;
	  }
	else
	  seclist = &(*seclist)->next;
      }
@


1.86
log
@2005-04-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-aout.h (S_IS_EXTERN): Removed.
	* config/obj-bout.h (S_IS_EXTERN): Likewise.
	* config/obj-coff.h (S_IS_EXTERN): Likewise.
	* symbols.c (S_IS_EXTERN): Likewise.
	* symbols.h (S_IS_EXTERN): Likewise.

	* config/tc-alpha.c (tc_gen_reloc): Replace S_IS_EXTERN with
	S_IS_EXTERNAL.
	* config/tc-d10v.c (md_apply_fix3): Likewise.
	* config/tc-ia64.c (ia64_fix_adjustable): Likewise.
	* config/tc-iq2000.c (iq2000_fix_adjustable): Likewise.
	* config/tc-m32r.c (m32r_fix_adjustable): Likewise.
	* config/tc-mmix.c (mmix_adjust_symtab): Likewise.
	* config/tc-sh64.c (shmedia_frob_file_before_adjust): Likewise.
	(shmedia_md_convert_frag): Likewise.
	* symbols.c (print_symbol_value_1): Likewise.
	* write.c (write_object_file): Likewise.
@
text
@d790 2
a791 2
	/* If this symbol is equated to an undefined symbol, convert
           the fixup to being against that symbol.  */
d794 8
d803 1
a803 1
	    sym = symbol_get_value_expression (sym)->X_add_symbol;
d1938 9
a1946 3
	      if (S_IS_COMMON (symp))
		as_bad (_("`%s' can't be equated to common symbol"),
			S_GET_NAME (symp));
@


1.85
log
@update copyright dates
@
text
@d1959 1
a1959 1
	      /* Note that S_IS_EXTERN and S_IS_LOCAL are not always
d1962 1
a1962 1
	      || (!S_IS_EXTERN (symp)
@


1.84
log
@	* as.h (assert): Warning fix.
	* expr.c (expr): Correct assertion.
	* read.c (s_comm_internal): Remove assertion.
	* write.c (relax_segment): Enable vma assertion only for BFD_ASSEMBLER.
	(fixup_segment): Remove assertion.
	* config/tc-dlx.c (machine_ip): Remove untrue assertions.
	(md_apply_fix3): Likewise.
	* config/tc-i370.c (md_begin): Correct assertion.
	(i370_macro): Warning fix for assertion.
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001, 2002, 2003, 2004
@


1.83
log
@	* configure.in (AC_C_BIGENDIAN): Invoke.
	* configure: Regenerate.
	* write.c (write_object_file <!BFD_ASSEMBLER>): Don't use sizeof
	host variable to set string header size.
	* config/obj-aout.c (obj_header_append): Don't use host structs.
	(obj_symbol_to_chars): Likewise.
	(obj_emit_strings): Likewise.  Use the passed in output pointer.
	* config/obj-aout.h (H_GET_FILE_SIZE): Include H_GET_LINENO_SIZE.
	* config/obj-bout.c (obj_emit_relocations): Use md_reloc_size,
	not sizeof host struct.
	(obj_header_append, obj_symbol_to_chars): Don't use host structs.
	(obj_emit_strings): Likewise.
	* config/obj-bout.h (EXEC_BYTES_SIZE): Define.
	(N_TXTOFF, H_GET_FILE_SIZE, H_GET_HEADER_SIZE): Use instead of
	sizeof host struct.
	(H_SET_SYMBOL_TABLE_SIZE): Hard code sym size rather than using
	sizeof host struct.
	(host_number_to_chars): Define.
	* config/obj-hp300.c (hp300_header_append): Don't use sizeof
	host internal struct to set header sizes.
	* config/tc-i960.c (md_number_to_field): Warning fix.
	(md_ri_to_chars): Use host byte order.
	(get_cdisp, md_apply_fix3): Warning fix.
@
text
@d2398 3
a2400 1
                      know (S_GET_SECTION (symbolP)->vma == 0);
a2587 1
	  know (fixP->fx_addsy->sy_value.X_op == O_symbol);
@


1.82
log
@	* write.c (write_object_file): Recognize warning-symbol construct
	and skip object- and target- handling for the second symbol.
@
text
@d1572 1
a1572 1
  string_byte_count = sizeof (string_byte_count);
d1576 1
a1576 1
  if (string_byte_count == sizeof (string_byte_count))
@


1.81
log
@	* as.h: Remove #if 0'd code.
	* atof-generic.c (atof_generic): Likewise.
	* ecoff.c (ecoff_directive_frame): Likewise.
	* frags.h (FRAG_APPEND_1_CHAR): Likewise.
	* itbl-ops.c (itbl_add_reg): Likewise.
	* listing.c (calc_hex): Likewise.
	* read.c (MASK_CHAR): Likewise.
	* subsegs.c (subsegs_print_statistics): Likewise.
	* symbols.c (indent): Likewise.
	* write.c (write_relocs): Likewise.
	(write_object_file): Likewise.
	(relax_frag): Likewise.
@
text
@d1885 1
d1892 9
d1985 6
@


1.80
log
@2005-01-10  H.J. Lu  <hongjiu.lu@@intel.com>

	* write.c (write_object_file): Disallow a symbol equated to
	common symbol.
@
text
@d945 6
a950 6
#if 0
      /* This test is triggered inappropriately for the SH.  */
      if (fixp->fx_where + fixp->fx_size
	  > fixp->fx_frag->fr_fix + fixp->fx_frag->fr_offset)
	abort ();
#endif
a1931 7
#if 0
	  printf ("symbol `%s'\n\t@@%x: value=%d flags=%x seg=%s\n",
		  S_GET_NAME (symp), symp,
		  S_GET_VALUE (symp),
		  symbol_get_bfdsym (symp)->flags,
		  segment_name (S_GET_SEGMENT (symp)));
#endif
a2078 5
/* #else */
  /* This machine doesn't want to use pcrel_adjust.
     In that case, pcrel_adjust should be zero.  */
#if 0
  assert (fragP->fr_targ.ns32k.pcrel_adjust == 0);
d2080 3
a2082 2
#endif
#ifdef md_prepare_relax_scan /* formerly called M68K_AIM_KLUDGE  */
@


1.79
log
@	* symbols.c (colon) [!WORKING_DOT_WORD]: Don't declare
	md_short_jump_size, md_long_jump_size.
	* write.c [!WORKING_DOT_WORD]: Ditto.
	* tc.h [!WORKING_DOT_WORD]: Declare them here.  Drop const
	qualifier.
	* config/tc-cris.h (md_short_jump_size, md_long_jump_size): Don't
	declare.
	* config/tc-cris.c (md_short_jump_size, md_long_jump_size): Drop
	const qualifier in these definitions.
	* config/tc-i370.c, config/tc-m68k.c, config/tc-pdp11.c,
	config/tc-s390.c, config/tc-tahoe.c, config/tc-vax.c: Ditto.
@
text
@d1920 3
@


1.78
log
@	* write.c (relax_segment): Use was_address instead of address when
	setting fr_fix field for align frag due to backwards .org.
@
text
@a99 5
#ifndef WORKING_DOT_WORD
extern const int md_short_jump_size;
extern const int md_long_jump_size;
#endif

@


1.77
log
@	* frags.h (struct frag): Add has_code and insn_addr fields.
	* write.c (cvt_frag_to_fill): Invoke md_frag_check.
	* config/tc-ppc.c (md_assemble): Check and set insn_addr.
	* config/tc-ppc.h (md_frag_check): Define.
@
text
@d2415 1
a2415 1
		      fragP->fr_fix = after - address;
@


1.76
log
@	* dwarf2dbg.c: Convert to ISO-C.
	* write.c: Likewise.
	* write.h: Likewise.
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001, 2002, 2003
d619 3
@


1.75
log
@	* README-vms: Fix comment typos.
	* as.h: Likewise.
	* dwarf2dbg.c: Likewise.
	* ecoff.c: Likewise.
	* hash.c: Likewise.
	* listing.c: Likewise.
	* write.c: Likewise.
@
text
@d115 1
a115 1
void print_fixup PARAMS ((fixS *));
d118 1
a118 1
static void renumber_sections PARAMS ((bfd *, asection *, PTR));
d160 4
a163 4
static fixS *fix_new_internal PARAMS ((fragS *, int where, int size,
				       symbolS *add, symbolS *sub,
				       offsetT offset, int pcrel,
				       RELOC_ENUM r_type));
d165 1
a165 1
static long fixup_segment PARAMS ((fixS *, segT));
d167 1
a167 1
static relax_addressT relax_align PARAMS ((relax_addressT addr, int align));
d169 1
a169 1
static fragS *chain_frchains_together_1 PARAMS ((segT, struct frchain *));
d172 7
a178 7
static void chain_frchains_together PARAMS ((bfd *, segT, PTR));
static void cvt_frag_to_fill PARAMS ((segT, fragS *));
static void adjust_reloc_syms PARAMS ((bfd *, asection *, PTR));
static void fix_segment PARAMS ((bfd *, asection *, PTR));
static void write_relocs PARAMS ((bfd *, asection *, PTR));
static void write_contents PARAMS ((bfd *, asection *, PTR));
static void set_symtab PARAMS ((void));
d181 1
a181 1
static void merge_data_into_text PARAMS ((void));
d184 3
a186 3
static void cvt_frag_to_fill PARAMS ((object_headers *, segT, fragS *));
static void remove_subsegs PARAMS ((frchainS *, int, fragS **, fragS **));
static void relax_and_size_all_segments PARAMS ((void));
d192 8
a199 10
fix_new_internal (frag, where, size, add_symbol, sub_symbol, offset, pcrel,
		  r_type)
     fragS *frag;		/* Which frag?  */
     int where;			/* Where in that frag?  */
     int size;			/* 1, 2, or 4 usually.  */
     symbolS *add_symbol;	/* X_add_symbol.  */
     symbolS *sub_symbol;	/* X_op_symbol.  */
     offsetT offset;		/* X_add_number.  */
     int pcrel;			/* TRUE if PC-relative relocation.  */
     RELOC_ENUM r_type ATTRIBUTE_UNUSED; /* Relocation type.  */
d284 7
a290 8
fix_new (frag, where, size, add_symbol, offset, pcrel, r_type)
     fragS *frag;		/* Which frag?  */
     int where;			/* Where in that frag?  */
     int size;			/* 1, 2, or 4 usually.  */
     symbolS *add_symbol;	/* X_add_symbol.  */
     offsetT offset;		/* X_add_number.  */
     int pcrel;			/* TRUE if PC-relative relocation.  */
     RELOC_ENUM r_type;		/* Relocation type.  */
d301 6
a306 7
fix_new_exp (frag, where, size, exp, pcrel, r_type)
     fragS *frag;		/* Which frag?  */
     int where;			/* Where in that frag?  */
     int size;			/* 1, 2, or 4 usually.  */
     expressionS *exp;		/* Expression.  */
     int pcrel;			/* TRUE if PC-relative relocation.  */
     RELOC_ENUM r_type;		/* Relocation type.  */
d375 1
a375 2
generic_force_reloc (fix)
     fixS *fix;
d387 1
a387 4
append (charPP, fromP, length)
     char **charPP;
     char *fromP;
     unsigned long length;
d407 5
a411 6
record_alignment (seg, align)
     /* Segment to which alignment pertains.  */
     segT seg;
     /* Alignment, as a power of 2 (e.g., 1 => 2-byte boundary, 2 => 4-byte
	boundary, etc.)  */
     int align;
d425 1
a425 2
get_recorded_alignment (seg)
     segT seg;
d441 1
a441 4
renumber_sections (abfd, sec, countparg)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     PTR countparg;
d454 1
a454 3
chain_frchains_together_1 (section, frchp)
     segT section;
     struct frchain *frchp;
d487 3
a489 4
chain_frchains_together (abfd, section, xxx)
     bfd *abfd ATTRIBUTE_UNUSED;
     segT section;
     PTR xxx ATTRIBUTE_UNUSED;
d510 1
a510 5
remove_subsegs (head, seg, root, last)
     frchainS *head;
     int seg;
     fragS **root;
     fragS **last;
d522 1
a522 3
cvt_frag_to_fill (sec, fragP)
     segT sec ATTRIBUTE_UNUSED;
     fragS *fragP;
d525 1
a525 4
cvt_frag_to_fill (headersP, sec, fragP)
     object_headers *headersP;
     segT sec;
     fragS *fragP;
d624 2
a625 1
static void relax_seg PARAMS ((bfd *, asection *, PTR));
d627 1
a627 4
relax_seg (abfd, sec, xxx)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     PTR xxx;
d639 2
a640 1
static void size_seg PARAMS ((bfd *, asection *, PTR));
d642 1
a642 4
size_seg (abfd, sec, xxx)
     bfd *abfd;
     asection *sec;
     PTR xxx ATTRIBUTE_UNUSED;
d755 3
a757 4
adjust_reloc_syms (abfd, sec, xxx)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     PTR xxx ATTRIBUTE_UNUSED;
d877 3
a879 4
fix_segment (abfd, sec, xxx)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     PTR xxx ATTRIBUTE_UNUSED;
d887 1
a887 4
write_relocs (abfd, sec, xxx)
     bfd *abfd;
     asection *sec;
     PTR xxx ATTRIBUTE_UNUSED;
d1098 3
a1100 4
write_contents (abfd, sec, xxx)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
     PTR xxx ATTRIBUTE_UNUSED;
d1196 1
a1196 1
merge_data_into_text ()
d1313 1
a1313 1
set_symtab ()
d1319 1
a1319 1
  extern PTR bfd_alloc PARAMS ((bfd *, bfd_size_type));
d1373 1
a1373 1
subsegs_finish ()
d1426 1
a1426 1
write_object_file ()
d2029 1
a2029 4
relax_frag (segment, fragP, stretch)
     segT segment;
     fragS *fragP;
     long stretch;
d2136 2
a2137 3
relax_align (address, alignment)
     register relax_addressT address;	/* Address now.  */
     register int alignment;	/* Alignment (binary).  */
d2164 1
a2164 3
relax_segment (segment_frag_root, segment)
     struct frag *segment_frag_root;
     segT segment;
d2519 1
a2519 3
fixup_segment (fixP, this_segment)
     fixS *fixP;
     segT this_segment;
d2759 1
a2759 4
number_to_chars_bigendian (buf, val, n)
     char *buf;
     valueT val;
     int n;
d2771 1
a2771 4
number_to_chars_littleendian (buf, val, n)
     char *buf;
     valueT val;
     int n;
d2783 1
a2783 2
write_print_statistics (file)
     FILE *file;
d2792 1
a2792 2
print_fixup (fixp)
     fixS *fixp;
@


1.74
log
@	* write.c (fixup_segment): When handling an expression involving
	the subtraction of two symbols in the same segment, don't clear
	fx_pcrel except for TC_M68K.
@
text
@d1392 1
a1392 1
/* The last subsegment gets an aligment corresponding to the alignment
@


1.73
log
@Update .comm error messages to assume an unsigned value.
Update relaxing code to work in 64-bit address spaces.
@
text
@a2644 9
	      /* If the back-end code has selected a pc-relative
		 reloc, adjust the value to be pc-relative.  */
	      if (1
#ifdef TC_M68K
		  /* See the comment below about 68k weirdness.  */
		  && 0
#endif
		  && fixP->fx_pcrel)
		add_number -= MD_PCREL_FROM_SECTION (fixP, this_segment); 
d2647 2
d2650 1
@


1.72
log
@	* write.c (write_relocs): Use xcalloc. Fix relocs initialization
	in the RELOC_EXPANSION_POSSIBLE case.
@
text
@d1138 1
a1138 1
  unsigned long offset = 0;
d1151 1
a1151 1
      unsigned long fill_size;
d1153 1
a1153 1
      long count;
d1313 1
a1313 1
    long bss_vma;
d2073 1
a2073 1
  long growth;
d2296 1
a2296 1
    long stretch;	/* May be any size, 0 or negative.  */
d2311 1
a2311 1
	    long growth = 0;
d2446 1
a2446 1
				    _("attempt to .org backwards"));
d2505 1
a2505 1
		  int size;
@


1.71
log
@	* write.c (write_relocs): Remove unused variable.
@
text
@d941 1
a941 2
  relocs = (arelent **) xmalloc (n * sizeof (arelent *));
  memset ((char *) relocs, 0, n * sizeof (arelent *));
d1013 1
a1013 1
  relocs = (arelent **) xmalloc (n * sizeof (arelent *));
@


1.70
log
@Add Xtensa port
@
text
@a1019 1
      char *data;
a1054 1
      data = fixp->fx_frag->fr_literal + fixp->fx_where;
@


1.69
log
@	* write.c (TC_FORCE_RELOCATION_SUB_SAME): Revert last change.
	* config/tc-s390.h (TC_FORCE_RELOCATION_SUB_SAME): Define.
@
text
@d1589 4
@


1.68
log
@	* symbols.c (S_FORCE_RELOC): Add "strict" param.
	* symbols.h (S_FORCE_RELOC): Likewise.
	* config/obj-aout.h (S_FORCE_RELOC): Likewise.
	* config/obj-bout.h (S_FORCE_RELOC): Likewise.
	* config/obj-coff.h (S_FORCE_RELOC): Likewise.
	* config/obj-ieee.h (S_FORCE_RELOC): Likewise.
	* config/obj-vms.h (S_FORCE_RELOC): Likewise.
	* write.c (generic_force_reloc): New function.
	(TC_FORCE_RELOCATION): Use it here instead of S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	(adjust_reloc_syms): Adjust S_FORCE_RELOC call.
	* as.h (generic_force_reloc): Declare.
	* doc/internals.texi (S_FORCE_RELOC): Update.
	(TC_FORCE_RELOCATION_SUB_SAME): Update.

	* config/tc-alpha.c (alpha_force_relocation): Adjust to use
	generic_force_reloc.
	(alpha_fix_adjustable): Likewise.
	* config/tc-arm.c (arm_force_relocation): Likewise.
	* config/tc-cris.c (md_cris_force_relocation): Likewise.
	* config/tc-frv.c (frv_force_relocation): Likewise.
	* config/tc-i386.c (md_apply_fix3): Likewise.
	* config/tc-ia64.c (ia64_force_relocation): Likewise.
	* config/tc-ip2k.c (ip2k_force_relocation): Likewise.
	* config/tc-m32r.c (m32r_force_relocation): Likewise.
	* config/tc-m68hc11.c (tc_m68hc11_force_relocation): Likewise.
	* config/tc-mcore.c (mcore_force_relocation): Likewise.
	* config/tc-mips.c (mips_force_relocation): Likewise.
	* config/tc-mmix.c (mmix_force_relocation): Likewise.
	* config/tc-ppc.c (ppc_force_relocation): Likewise.
	* config/tc-s390.c (tc_s390_force_relocation): Likewise.
	* config/tc-sh.c (sh_force_relocation): Likewise.
	(md_pcrel_from_section): Likewise.
	* config/tc-sparc.c (tc_gen_reloc): Likewise.
	* config/tc-v850.c (v850_force_relocation): Likewise.
	* config/tc-xstormy16.c (xstormy16_force_relocation): Likewise.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-mcore.h (TC_FORCE_RELOCATION): Likewise.
	* config/tc-sparc.h (tc_fix_adjustable): Likewise.

	* config/tc-d10v.c (d10v_force_relocation): Delete.
	* config/tc-d10v.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-dlx.c (md_dlx_force_relocation): Delete.
	* config/tc-dlx.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-fr30.c (fr30_force_relocation): Delete.
	* config/tc-fr30.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-mn10300.c (mn10300_force_relocation): Delete.
	* config/tc-mn10300.h (TC_FORCE_RELOCATION): Don't define.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-i960.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
	* config/tc-hppa.c (hppa_force_relocation): Adjust S_FORCE_RELOC call.
	* config/tc-mips.c (RELAX_BRANCH_TOOFAR): Warning fix.
	* config/tc-mips.h (TC_FORCE_RELOCATION_SUB_SAME): Don't define.
	* config/tc-openrisc.c (openrisc_force_relocation): Delete.
	* config/tc-openrisc.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sparc.c (elf32_sparc_force_relocation): Delete.
	* config/tc-sparc.h (TC_FORCE_RELOCATION): Don't define for ELF.
	* config/tc-i386.c (i386_force_relocation): Delete.
	* config/tc-i386.h (TC_FORCE_RELOCATION): Don't define for
	BFD_ASSEMBLER.
	(EXTERN_FORCE_RELOC): Fix TE_PE and STRICT_PE_FORMAT nesting.
	* config/tc-m68k.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-pj.h (TC_FORCE_RELOCATION): Don't define.
	* config/tc-sh.h (TC_FORCE_RELOCATION_SUB_ABS): Don't call
	S_FORCE_RELOC.
	(TC_FORCE_RELOCATION_SUB_SAME): Test TC_FORCE_RELOCATION too.
	* config/tc-sh64.h (TC_FORCE_RELOCATION_SUB_SAME): Likewise.
@
text
@d54 1
a54 1
  (! SEG_NORMAL (SEG) || TC_FORCE_RELOCATION (FIX))
@


1.67
log
@	* write.c (write_object_file): Fix signed/unsigned warning.
	* config/e-crisaout.c (crisaout_bfd_name): Prototype.
	* config/e-criself.c (criself_bfd_name): Prototype.
	* config/obj-aout.c (s_sect): Remove unused function.
	* config/obj-bout.c (obj_bout_line <ignore>): Add ATTRIBUTE_UNUSED.
	* config/obj-coff.c (coff_last_bf): Don't declare for OBJ_XCOFF.
	(fixup_mdeps <h>): Add ATTRIBUTE_UNUSED.
	* config/obj-ecoff.c (ecoff_frob_file <addr>): Likewise.
	* config/obj-vms.c (setup_basic_type <spnt>): Likewise.
	(VMS_RSYM_Parse <Current_Routine>): Likewise.
	(vms_fixup_text_section <text_siz>): Likewise.
	(synthesize_data_segment <data_size>): Likewise.
	(vms_fixup_xtors_section <sect_no>): Likewise.
	(structure_count): Don't use implicit int type.
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001, 2002
d37 1
a37 1
  (S_FORCE_RELOC ((FIX)->fx_addsy))
d54 1
a54 1
  (! SEG_NORMAL (SEG))
d377 13
d839 1
a839 1
	if (S_FORCE_RELOC (fixp->fx_addsy))
@


1.66
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d1627 1
a1627 1
	    || ((fragP->fr_next->fr_address - fragP->fr_address)
@


1.65
log
@	* write.c (subsegs_finish): For SEC_MERGE sections pad last fragment
	to entsize.
@
text
@d694 1
a694 1
  assert (x == true);
d698 1
a698 1
  assert (x == true);
d1151 1
a1151 1
	  if (x == false)
d1175 1
a1175 1
		  if (x == false)
d1209 1
a1209 1
		  if (x != true)
d1343 1
a1343 1
  boolean result;
d1369 1
a1369 1
  assert (result == true);
@


1.64
log
@	* write.c (adjust_reloc_syms): Don't reduce SEC_MERGE fixups with
	fx_subsy non-NULL.
@
text
@d1412 19
a1430 1
	alignment = SUB_SEGMENT_ALIGN (now_seg, frchainP);
@


1.63
log
@	* write.c (TC_FORCE_RELOCATION_SUB_ABS): Default to zero.
	(TC_FORCE_RELOCATION_SUB_LOCAL): Likewise when DIFF_EXPR_OK.
	* doc/internals.texi (TC_FORCE_RELOCATION_SUB_ABS): Document changed
	default.
@
text
@d871 2
a872 1
	if ((symsec->flags & SEC_MERGE) != 0 && fixp->fx_offset != 0)
@


1.62
log
@* write.c: Delete set_segment_vma and prototype. Update all callers.
@
text
@d58 1
a58 2
#define TC_FORCE_RELOCATION_SUB_ABS(FIX)	\
  (S_FORCE_RELOC ((FIX)->fx_subsy))
d63 1
a63 2
#define TC_FORCE_RELOCATION_SUB_LOCAL(FIX)	\
  (S_FORCE_RELOC ((FIX)->fx_subsy))
d65 1
a65 1
#define TC_FORCE_RELOCATION_SUB_LOCAL(FIX) 1
@


1.61
log
@	* write.h (struct fix): Add fx_dot_value.
	(dot_value): Declare.
	* write.c (dot_value): New var.
	(fix_new_internal): Save dot_value as fx_dot_value.
	* expr.c (expr): Update dot_value.
@
text
@a189 3
#if defined (BFD_ASSEMBLER) && defined (OBJ_COFF) && defined (TE_GO32)
static void set_segment_vma PARAMS ((bfd *, asection *, PTR));
#endif
a1374 14
#if defined (BFD_ASSEMBLER) && defined (OBJ_COFF) && defined (TE_GO32)
static void
set_segment_vma (abfd, sec, xxx)
     bfd *abfd;
     asection *sec;
     PTR xxx ATTRIBUTE_UNUSED;
{
  static bfd_vma addr = 0;

  bfd_set_section_vma (abfd, sec, addr);
  addr += bfd_section_size (abfd, sec);
}
#endif /* BFD_ASSEMBLER && OBJ_COFF && !TE_PE  */

a1557 8

#if defined (BFD_ASSEMBLER) && defined (OBJ_COFF) && defined (TE_GO32)
  /* Now that the segments have their final sizes, run through the
     sections and set their vma and lma. !BFD gas sets them, and BFD gas
     should too. Currently, only DJGPP uses this code, but other
     COFF targets may need to execute this too.  */
  bfd_map_over_sections (stdoutput, set_segment_vma, (char *) 0);
#endif
@


1.60
log
@gas reloc rewrite.
@
text
@d114 3
d226 1
d2663 2
a2664 1
	      fixP->fx_offset = add_number;
@


1.59
log
@	* write.c (BFD_FAST_SECTION_FILL): Remove unused macro.
	(TC_ADJUST_RELOC_COUNT): Tweak param name.
	(TC_FORCE_RELOCATION, TC_FORCE_RELOCATION_SECTION): Likewise.
	(TC_FIX_ADJUSTABLE, MD_PCREL_FROM_SECTION): Likewise.
	(RELOC_ENUM): Define.
	(fix_new_internal): Use RELOC_ENUM.
	(fix_new, fix_new_exp): Likewise.
	(adjust_reloc_syms): Comment.  Remove unnecessary tests on sym != NULL.
	Replace gotos with continue.
	(write_relocs): Formatting.  Avoid symbol loops in
	RELOC_EXPANSION_POSSIBLE case too.  Report bfd_reloc_outofrange
	errors, and error number in other cases.
	(fixup_segment): Remove param names from prototype.  Rename
	"this_segment_type" to "this_segment".  Update linkrelax comment.
	Remove "size, "place" and "where" local vars.  Formatting.  Update
	"no symbol" comment.  Remove #if 0 and #if 1.
@
text
@d36 2
a37 1
#define TC_FORCE_RELOCATION(FIX) 0
d40 44
a83 2
#ifndef TC_FORCE_RELOCATION_SECTION
#define TC_FORCE_RELOCATION_SECTION(FIX, SEG) TC_FORCE_RELOCATION (FIX)
d90 2
a91 2
#ifndef TC_FIX_ADJUSTABLE
#define TC_FIX_ADJUSTABLE(FIX) 1
d111 3
d174 1
d825 18
d849 2
a850 29
	    /* The fixup_segment routine will not use this symbol in a
               relocation unless TC_FORCE_RELOCATION returns 1.  */
	    if (TC_FORCE_RELOCATION (fixp))
	      {
		symbol_mark_used_in_reloc (fixp->fx_addsy);
#ifdef UNDEFINED_DIFFERENCE_OK
		if (fixp->fx_subsy != NULL)
		  symbol_mark_used_in_reloc (fixp->fx_subsy);
#endif
	      }
	    continue;
	  }

	/* If it's one of these sections, assume the symbol is
	   definitely going to be output.  The code in
	   md_estimate_size_before_relax in tc-mips.c uses this test
	   as well, so if you change this code you should look at that
	   code.  */
	if (bfd_is_und_section (symsec)
	    || bfd_is_com_section (symsec))
	  {
	    symbol_mark_used_in_reloc (fixp->fx_addsy);
#ifdef UNDEFINED_DIFFERENCE_OK
	    /* We have the difference of an undefined symbol and some
	       other symbol.  Make sure to mark the other symbol as used
	       in a relocation so that it will always be output.  */
	    if (fixp->fx_subsy)
	      symbol_mark_used_in_reloc (fixp->fx_subsy);
#endif
d860 8
a867 45
	    boolean linkonce;

	    linkonce = false;
#ifdef BFD_ASSEMBLER
	    if ((bfd_get_section_flags (stdoutput, symsec) & SEC_LINK_ONCE)
		!= 0)
	      linkonce = true;
#endif
#ifdef OBJ_ELF
	    /* The GNU toolchain uses an extension for ELF: a section
               beginning with the magic string .gnu.linkonce is a
               linkonce section.  */
	    if (strncmp (segment_name (symsec), ".gnu.linkonce",
			 sizeof ".gnu.linkonce" - 1) == 0)
	      linkonce = true;
#endif

	    if (linkonce)
	      {
		symbol_mark_used_in_reloc (fixp->fx_addsy);
#ifdef UNDEFINED_DIFFERENCE_OK
		if (fixp->fx_subsy != NULL)
		  symbol_mark_used_in_reloc (fixp->fx_subsy);
#endif
		continue;
	      }
	  }

	/* Since we're reducing to section symbols, don't attempt to reduce
	   anything that's already using one.  */
	if (symbol_section_p (sym))
	  {
	    symbol_mark_used_in_reloc (fixp->fx_addsy);
	    continue;
	  }

#ifdef BFD_ASSEMBLER
	/* We can never adjust a reloc against a weak symbol.  If we
           did, and the weak symbol was overridden by a real symbol
           somewhere else, then our relocation would be pointing at
           the wrong area of memory.  */
	if (S_IS_WEAK (sym))
	  {
	    symbol_mark_used_in_reloc (fixp->fx_addsy);
	    continue;
d873 1
a873 4
	  {
	    symbol_mark_used_in_reloc (fixp->fx_addsy);
	    continue;
	  }
d877 1
a877 30
	  {
	    symbol_mark_used_in_reloc (fixp->fx_addsy);
	    continue;
	  }
#endif

	/* Is there some other reason we can't adjust this one?  (E.g.,
	   call/bal links in i960-bout symbols.)  */
#ifdef obj_fix_adjustable
	if (! obj_fix_adjustable (fixp))
	  {
	    symbol_mark_used_in_reloc (fixp->fx_addsy);
	    continue;
	  }
#endif

	/* Is there some other (target cpu dependent) reason we can't adjust
	   this one?  (E.g. relocations involving function addresses on
	   the PA.  */
#ifdef tc_fix_adjustable
	if (! tc_fix_adjustable (fixp))
	  {
	    symbol_mark_used_in_reloc (fixp->fx_addsy);
	    continue;
	  }
#endif

	/* If the section symbol isn't going to be output, the relocs
	   at least should still work.  If not, figure out what to do
	   when we run into that case.
d879 1
a879 1
	   We refetch the segment when calling section_symbol, rather
a883 1
	symbol_mark_used_in_reloc (fixp->fx_addsy);
a888 7
    else
      {
	/* There was no symbol required by this relocation.  However,
	   BFD doesn't really handle relocations without symbols well.
	   So fake up a local symbol in the absolute section.  */
	fixp->fx_addsy = section_symbol (absolute_section);
      }
d894 11
a921 2
  fixup_segment (seginfo->fix_root, sec);

d1899 9
d1977 3
a1979 2
	  if ((! EMIT_SECTION_SYMBOLS
	       && symbol_section_p (symp))
d1984 1
a1984 1
		  && (S_IS_LOCAL (symp) || punt)
d2092 1
a2092 1
      know (!(S_GET_SEGMENT (symbolP) == absolute_section)
a2537 4
#ifndef TC_RELOC_RTSYM_LOC_FIXUP
#define TC_RELOC_RTSYM_LOC_FIXUP(X) (1)
#endif

a2554 2
  symbolS *add_symbolP;
  symbolS *sub_symbolP;
a2555 1
  int pcrel, plt;
d2559 9
d2577 15
a2591 1
	seg_reloc_count++;
a2604 1
      add_symbolP = fixP->fx_addsy;
a2607 1
      sub_symbolP = fixP->fx_subsy;
a2608 2
      pcrel = fixP->fx_pcrel;
      plt = fixP->fx_plt;
d2610 2
a2611 2
      if (add_symbolP != NULL
	  && symbol_mri_common_p (add_symbolP))
d2613 2
a2614 2
	  know (add_symbolP->sy_value.X_op == O_symbol);
	  add_number += S_GET_VALUE (add_symbolP);
d2616 2
a2617 2
	  add_symbolP = fixP->fx_addsy =
	    symbol_get_value_expression (add_symbolP)->X_add_symbol;
d2620 2
a2621 2
      if (add_symbolP)
	add_symbol_segment = S_GET_SEGMENT (add_symbolP);
d2623 1
a2623 1
      if (sub_symbolP)
d2625 6
a2630 30
	  resolve_symbol_value (sub_symbolP);
	  if (add_symbolP == NULL || add_symbol_segment == absolute_section)
	    {
	      if (add_symbolP != NULL)
		{
		  add_number += S_GET_VALUE (add_symbolP);
		  add_symbolP = NULL;
		  fixP->fx_addsy = NULL;
		}

	      /* It's just -sym.  */
	      if (S_GET_SEGMENT (sub_symbolP) == absolute_section)
		{
		  add_number -= S_GET_VALUE (sub_symbolP);
		  fixP->fx_subsy = NULL;
		}
	      else if (pcrel
		       && S_GET_SEGMENT (sub_symbolP) == this_segment)
		{
		  /* Should try converting to a constant.  */
		  goto bad_sub_reloc;
		}
	      else
	      bad_sub_reloc:
		as_bad_where (fixP->fx_file, fixP->fx_line,
			      _("negative of non-absolute symbol `%s'"),
			      S_GET_NAME (sub_symbolP));
	    }
	  else if (S_GET_SEGMENT (sub_symbolP) == add_symbol_segment
		   && SEG_NORMAL (add_symbol_segment))
d2632 5
a2636 12
	      /* Difference of 2 symbols from same segment.
		 Can't make difference of 2 undefineds: 'value' means
		 something different for N_UNDF.  */
#ifdef TC_I960
	      /* Makes no sense to use the difference of 2 arbitrary symbols
		 as the target of a call instruction.  */
	      if (fixP->fx_tcbit)
		as_bad_where (fixP->fx_file, fixP->fx_line,
			      _("callj to difference of two symbols"));
#endif /* TC_I960  */
	      add_number += (S_GET_VALUE (add_symbolP)
			     - S_GET_VALUE (sub_symbolP));
d2642 12
a2653 15
		  && pcrel)
		add_number -= MD_PCREL_FROM_SECTION (fixP, this_segment);

	      add_symbolP = NULL;
	      pcrel = 0;	/* No further pcrel processing.  */

	      /* Let the target machine make the final determination
		 as to whether or not a relocation will be needed to
		 handle this fixup.  */
	      if (!TC_FORCE_RELOCATION_SECTION (fixP, this_segment))
		{
		  fixP->fx_pcrel = 0;
		  fixP->fx_addsy = NULL;
		  fixP->fx_subsy = NULL;
		}
d2655 2
a2656 1
	  else
d2658 2
a2659 3
	      /* Different segments in subtraction.  */
	      know (!(S_IS_EXTERNAL (sub_symbolP)
		      && (S_GET_SEGMENT (sub_symbolP) == absolute_section)));
d2661 4
a2664 8
	      if ((S_GET_SEGMENT (sub_symbolP) == absolute_section))
		add_number -= S_GET_VALUE (sub_symbolP);

#ifdef DIFF_EXPR_OK
	      else if (S_GET_SEGMENT (sub_symbolP) == this_segment)
		{
		  /* Make it pc-relative.  */
		  if (0
d2666 19
a2684 47
		      /* Do this for m68k even if it's already described
			 as pc-relative.  On the m68k, an operand of
			 "pc@@(foo-.-2)" should address "foo" in a
			 pc-relative mode.  */
		      || 1
#endif
		      || !pcrel)
		    {
		      add_number += MD_PCREL_FROM_SECTION (fixP,
							   this_segment);
		      pcrel = 1;
		      fixP->fx_pcrel = 1;
		    }

		  add_number -= S_GET_VALUE (sub_symbolP);
		  sub_symbolP = 0;
		  fixP->fx_subsy = 0;
		}
#endif
#ifdef UNDEFINED_DIFFERENCE_OK
	      /* The PA needs this for PIC code generation.  We basically
		 don't want to do anything if we have the difference of two
		 symbols at this point.  */
	      else if (1)
		{
		  /* Leave it alone.  */
		}
#endif
#ifdef BFD_ASSEMBLER
	      else if (fixP->fx_r_type == BFD_RELOC_GPREL32
		       || fixP->fx_r_type == BFD_RELOC_GPREL16)
		{
		  /* Leave it alone.  */
		}
#endif
	      else
		{
		  char buf[50];
		  sprint_value (buf, fragP->fr_address + fixP->fx_where);
		  as_bad_where (fixP->fx_file, fixP->fx_line,
				_("subtraction of two symbols in different sections `%s' {%s section} - `%s' {%s section} at file address %s"),
				S_GET_NAME (add_symbolP),
				segment_name (S_GET_SEGMENT (add_symbolP)),
				S_GET_NAME (sub_symbolP),
				segment_name (S_GET_SEGMENT (sub_symbolP)),
				buf);
		}
d2688 1
a2688 1
      if (add_symbolP)
d2690 2
a2691 2
	  if (add_symbol_segment == this_segment && pcrel && !plt
	      && TC_RELOC_RTSYM_LOC_FIXUP (fixP))
d2696 6
a2701 22
#ifdef TC_I960
	      /* reloc_callj() may replace a 'call' with a 'calls' or a
		 'bal', in which cases it modifies *fixP as appropriate.
		 In the case of a 'calls', no further work is required,
		 and *fixP has been set up to make the rest of the code
		 below a no-op.  */
	      reloc_callj (fixP);
#endif /* TC_I960  */

	      add_number += S_GET_VALUE (add_symbolP);
	      add_number -= MD_PCREL_FROM_SECTION (fixP, this_segment);
	      /* Lie.  Don't want further pcrel processing.  */
	      pcrel = 0;

	      /* Let the target machine make the final determination
		 as to whether or not a relocation will be needed to
		 handle this fixup.  */
	      if (!TC_FORCE_RELOCATION (fixP))
		{
		  fixP->fx_pcrel = 0;
		  fixP->fx_addsy = NULL;
		}
d2703 2
a2704 1
	  else
d2706 5
a2710 20
	      if (add_symbol_segment == absolute_section
		  && ! pcrel)
		{
#ifdef TC_I960
		  /* See comment about reloc_callj() above.  */
		  reloc_callj (fixP);
#endif /* TC_I960  */
		  add_number += S_GET_VALUE (add_symbolP);

		  /* Let the target machine make the final determination
		     as to whether or not a relocation will be needed to
		     handle this fixup.  */

		  if (!TC_FORCE_RELOCATION (fixP))
		    {
		      fixP->fx_addsy = NULL;
		      add_symbolP = NULL;
		    }
		}
	      else if (add_symbol_segment == undefined_section
d2712 1
a2712 1
		       || bfd_is_com_section (add_symbol_segment)
d2714 2
a2715 32
		       )
		{
#ifdef TC_I960
		  if ((int) fixP->fx_bit_fixP == 13)
		    {
		      /* This is a COBR instruction.  They have only a
			 13-bit displacement and are only to be used
			 for local branches: flag as error, don't generate
			 relocation.  */
		      as_bad_where (fixP->fx_file, fixP->fx_line,
				    _("can't use COBR format with external label"));
		      fixP->fx_addsy = NULL;
		      fixP->fx_done = 1;
		      continue;
		    }		/* COBR.  */
#endif /* TC_I960  */

#ifdef OBJ_COFF
#ifdef TE_I386AIX
		  if (S_IS_COMMON (add_symbolP))
		    add_number += S_GET_VALUE (add_symbolP);
#endif /* TE_I386AIX  */
#endif /* OBJ_COFF  */
		  ++seg_reloc_count;
		}
	      else
		{
		  seg_reloc_count++;
		  if (TC_FIX_ADJUSTABLE (fixP))
		    add_number += S_GET_VALUE (add_symbolP);
		}
	    }
d2718 1
a2718 1
      if (pcrel)
d2721 1
a2721 1
	  if (add_symbolP == 0)
d2723 5
a2727 7
#ifndef BFD_ASSEMBLER
	      fixP->fx_addsy = &abs_symbol;
#else
	      fixP->fx_addsy = section_symbol (absolute_section);
#endif
	      symbol_mark_used_in_reloc (fixP->fx_addsy);
	      ++seg_reloc_count;
d2733 10
@


1.58
log
@	* as.c: Replace CONST with const.
	* write.c: Likewise.
	* config/obj-coff.c: Likewise.
	* config/tc-a29k.c: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-dlx.c: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8500.c: Likewise.
	* config/tc-i370.c: Likewise.
	* config/tc-i860.c: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-m68hc11.c: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m88k.c: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mips.c: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-pdp11.c: Likewise.
	* config/tc-pj.c: Likewise.
	* config/tc-s390.c: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tahoe.c: Likewise.
	* config/tc-tic80.c: Likewise.
	* config/tc-v850.c: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-w65.c: Likewise.
	* config/tc-z8k.c: Likewise.
@
text
@a30 4
/* This looks like a good idea.  Let's try turning it on always, for now.  */
#undef  BFD_FAST_SECTION_FILL
#define BFD_FAST_SECTION_FILL

d32 1
a32 1
#define TC_ADJUST_RELOC_COUNT(FIXP,COUNT)
d36 1
a36 1
#define TC_FORCE_RELOCATION(FIXP) 0
d40 1
a40 1
#define TC_FORCE_RELOCATION_SECTION(FIXP,SEG) TC_FORCE_RELOCATION(FIXP)
d48 1
a48 1
#define TC_FIX_ADJUSTABLE(fix) 1
d56 1
a56 1
#define MD_PCREL_FROM_SECTION(FIXP, SEC) md_pcrel_from(FIXP)
d108 1
a108 4
static fixS *fix_new_internal PARAMS ((fragS *, int where, int size,
				       symbolS *add, symbolS *sub,
				       offsetT offset, int pcrel,
				       bfd_reloc_code_real_type r_type));
d110 3
d116 1
a116 2
				       int r_type));
#endif
d118 1
a118 1
static long fixup_segment PARAMS ((fixS * fixP, segT this_segment_type));
d156 1
a156 5
#ifdef BFD_ASSEMBLER
     bfd_reloc_code_real_type r_type; /* Relocation type.  */
#else
     int r_type;		/* Relocation type.  */
#endif
d247 1
a247 5
#ifdef BFD_ASSEMBLER
     bfd_reloc_code_real_type r_type; /* Relocation type.  */
#else
     int r_type;		/* Relocation type.  */
#endif
d264 1
a264 5
#ifdef BFD_ASSEMBLER
     bfd_reloc_code_real_type r_type; /* Relocation type.  */
#else
     int r_type;		/* Relocation type.  */
#endif
d721 3
d758 1
a758 2
	if (sym != NULL)
	  resolve_symbol_value (sym);
d765 1
a765 1
	if (sym != NULL && symbol_equated_reloc_p (sym))
d772 1
a772 1
	if (sym != NULL && symbol_mri_common_p (sym))
d775 1
a775 1
	    goto done;
a778 1

d794 1
a794 1
	    goto done;
d813 1
a813 1
	    goto done;
d846 1
a846 1
		goto done;
d855 1
a855 1
	    goto done;
d866 1
a866 1
	    goto done;
d871 1
a871 1
	if ((symsec->flags & SEC_MERGE) && fixp->fx_offset)
d874 1
a874 1
	    goto done;
d878 1
a878 1
	if (symsec->flags & SEC_THREAD_LOCAL)
d881 1
a881 1
	    goto done;
d891 1
a891 1
	    goto done;
d902 1
a902 1
	    goto done;
a919 3

      done:
	;
a920 1
#if 1 /* def RELOC_REQUIRES_SYMBOL  */
d925 1
a925 3
	   (At least, the COFF support doesn't.)  So for now we fake up
	   a local symbol in the absolute section.  */

a926 3
#if 0
	fixp->fx_addsy->sy_used_in_reloc = 1;
#endif
a927 1
#endif
d1015 2
a1016 1
	  as_bad_where (fixp->fx_file, fixp->fx_line, _("relocation overflow"));
d1019 2
a1020 1
	  as_bad_where (fixp->fx_file, fixp->fx_line, _("relocation out of range"));
d1053 11
a1063 1
	sym = symbol_get_value_expression (sym)->X_add_symbol;
d1092 4
d1097 2
a1098 2
	      as_fatal (_("%s:%u: bad return from bfd_install_relocation"),
			fixp->fx_file, fixp->fx_line);
d2574 3
a2576 3
fixup_segment (fixP, this_segment_type)
     register fixS *fixP;
     segT this_segment_type;	/* N_TYPE bits for segment.  */
a2581 3
  int size;
  char *place;
  long where;
d2588 5
a2592 6
     Well, strictly speaking that's not true -- we could do any that are
     PC-relative and don't cross regions that could change size.  And for the
     i960 (the only machine for which we've got a relaxing linker right now),
     we might be able to turn callx/callj into bal anyways in cases where we
     know the maximum displacement.  */
  if (linkrelax && TC_LINKRELAX_FIXUP (this_segment_type))
a2608 3
      where = fixP->fx_where;
      place = fragP->fr_literal + where;
      size = fixP->fx_size;
d2611 1
a2611 1
      TC_VALIDATE_FIX (fixP, this_segment_type, skip);
d2650 1
a2650 1
		       && S_GET_SEGMENT (sub_symbolP) == this_segment_type)
d2682 1
a2682 1
		add_number -= MD_PCREL_FROM_SECTION (fixP, this_segment_type);
d2690 1
a2690 1
	      if (!TC_FORCE_RELOCATION_SECTION (fixP, this_segment_type))
d2707 1
a2707 1
	      else if (S_GET_SEGMENT (sub_symbolP) == this_segment_type)
d2721 1
a2721 1
							   this_segment_type);
d2750 1
a2750 1
		  sprint_value (buf, fragP->fr_address + where);
d2764 1
a2764 1
	  if (add_symbol_segment == this_segment_type && pcrel && !plt
d2780 1
a2780 1
	      add_number -= MD_PCREL_FROM_SECTION (fixP, this_segment_type);
d2854 1
a2854 1
	  add_number -= MD_PCREL_FROM_SECTION (fixP, this_segment_type);
d2868 1
a2868 1
	md_apply_fix3 (fixP, & add_number, this_segment_type);
d2870 1
a2870 1
      if (!fixP->fx_bit_fixP && !fixP->fx_no_overflow && size > 0)
d2872 1
a2872 1
	  if ((size_t) size < sizeof (valueT))
d2878 1
a2878 1
	      mask <<= size * 8 - (fixP->fx_signed ? 1 : 0);
d2882 1
a2882 1
		  sprint_value (buf, fragP->fr_address + where);
d2889 1
a2889 1
				buf2, size, buf);
d2897 1
a2897 1
	      && size == 2
d2902 1
a2902 1
			  (unsigned long) (fragP->fr_address + where));
@


1.58.2.1
log
@2002-09-23  Daniel Jacobowitz  <drow@@mvista.com>

	Merge from mainline:
	2002-09-22  Mark Elbrecht  <snowball3@@softhome.net>
	* write.c: Delete set_segment_vma and prototype. Update all callers.

	2002-09-19  Jakub Jelinek  <jakub@@redhat.com>
	* config/tc-i386.c (tc_i386_fix_adjustable): Handle
	BFD_RELOC_386_TLS_IE and BFD_RELOC_386_TLS_GOTIE.
	(BFD_RELOC_386_TLS_IE, BFD_RELOC_386_TLS_GOTIE): Define to 0
	if not defined.
	(lex_got): Handle @@GOTNTPOFF and @@INDNTPOFF.
	(md_apply_fix3, tc_gen_reloc): Handle BFD_RELOC_386_TLS_IE and
	BFD_RELOC_386_TLS_GOTIE.

	2002-09-16  Chris Demetriou  <cgd@@broadcom.com>
	* config/tc-mips.c (IS_SEXT_32BIT_NUM): Move closer to top of file.
	(IS_SEXT_16BIT_NUM): New macro.
	(macro_build_ldst_constoffset): New function, to build a set of
	instructions to do a load or store from a constant offset relative
	to a given register.
	(macro, s_cprestore): Use macro_build_ldst_constoffset to implement
	.cprestore pseudo-op.

	2002-09-16  Elias Athanasopoulos  <eathan@@otenet.gr>
	* dwarf2dbg.c (out_debug_abbrev): Add support for the DW_AT_name field.
	(out_debug_info): Likewise.

	2002-09-13  Nick Clifton  <nickc@@redhat.com>
	* config/tc-ppc.c (md_assemble): Do not count FAKE operands
	when deciding if any operands have been skipped.

	2002-09-11  Jakub Jelinek  <jakub@@redhat.com>
	* config/tc-i386.c (md_apply_fix3): Allow addend for
	BFD_RELOC_386_TLS_LDO_32, BFD_RELOC_386_TLS_LE and
	BFD_RELOC_386_TLS_LE_32.

	2002-09-11  Nick Clifton  <nickc@@redhat.com>
	* po/tr.po: Updated Turkish translation.

	2002-09-04  Nick Clifton  <nickc@@redhat.com>
	* config/tc-ppc.c (md_begin): Do not insert non-BookE32
	instructions into the hash table if the target cpu is the BookE32.

	2002-08-20  Richard Sandiford  <rsandifo@@redhat.com>
	* config/tc-mips.c (macro2): Implement rotates by zero using shifts
	by zero.

	2002-08-15  Alexandre Oliva  <aoliva@@redhat.com>
	* config/tc-mips.c (macro_build_jalr): Make sure we generate
	the fix-up against on the right frag.
	(s_cpsetup): Likewise.  Parse third argument as expression, to
	handle global symbols and forward/backward labels correctly.

	2002-08-14  Nick Clifton  <nickc@@redhat.com>
	* read.c (stringer): Catch attempts to create strings in the abs
	section.

	2002-08-12  Richard Sandiford  <rsandifo@@redhat.com>
	* config/tc-mips.c (mips_ip): Don't work out the value of
	constant %hi()s here.

	2002-08-10  Alan Modra  <amodra@@bigpond.net.au>
	* config/tc-i386.c (tc_i386_fix_adjustable): Test OUTPUT_FLAVOR
	for ELF, and don't bother checking ELF relocs when non-ELF.
	(i386_immediate): Allow absolute_section expressions for aout.
	(i386_displacement): Likewise.  Also test bfd_is_com_section.
	(md_estimate_size_before_relax): Test OUTPUT_FLAVOR for ELF.
	(md_apply_fix3): Hack for bfd_install_relocation when fx_pcrel,
	not when fx_addsy.  Remove dead code.

	2002-08-06  George France <france@@handhelds.org>
	* config/tc-alpha.c (cpu_types): Enabled ev67, ev68,  -m21264a
	and m21264b processor names and cpu types.
	* doc/c-alpha.texi: Documented new types.

	2002-08-06  Alan Modra  <amodra@@bigpond.net.au>
	* config/tc-ppc.c (md_apply_fix3): Adjust 16 bit XCOFF reloc offset.

	2002-08-03  Jakub Jelinek  <jakub@@redhat.com>
	* config/tc-i386.c (output_insn): Save frag_now and frag_now_fix ()
	at start of insn, pass it to output_disp and output_imm.
	(output_disp): Added arguments.  If _GLOBAL_OFFSET_TABLE_ is seen
	in displacement for R_386_32 reloc, use R_386_GOTPC and compute
	properly addend.
	(output_imm): Added arguments.  Compute properly addend for
	R_386_GOTPC.
	(md_apply_fix3): Remove R_386_GOTPC handling.

	2002-07-31  Momchil Velikov  <velco@@fadata.bg>
	* config/tc-v850.c (md_assemble): Fix range check for immediate
	operand.

	2002-07-04  Bruno Haible  <bruno@@clisp.org>
	* config/tc-i386.h (ELF_TARGET_FORMAT): New macro.
	(TARGET_FORMAT): Use ELF_TARGET_FORMAT instead of "elf32-i386".
	* config/tc-i386.c (i386_target_format): Likewise.
	* config/tc-alpha.h (ELF_TARGET_FORMAT): New macro.
	(TARGET_FORMAT): Use ELF_TARGET_FORMAT instead of "elf64-alpha".
@
text
@d145 3
d1414 14
d1611 8
@


1.58.2.2
log
@	* write.c (adjust_reloc_syms): Don't reduce SEC_MERGE fixups with
	fx_subsy non-NULL.
@
text
@d884 1
a884 2
	if ((symsec->flags & SEC_MERGE) != 0
	    && (fixp->fx_offset != 0 || fixp->fx_subsy != NULL))
@


1.57
log
@	* elf.c (_bfd_elf_make_section_from_shdr): Set SEC_THREAD_LOCAL
	for symbols from SHF_TLS section.
	(_bfd_elf_print_private_bfd_data): Add PT_TLS.
	(elf_fake_sections): Set SHF_TLS for SEC_THREAD_LOCAL sections.
	(map_sections_to_segments): Build PT_TLS segment if necessary.
	(assign_file_positions_for_segments): Likewise.
	(get_program_header_size): Account for PT_TLS segment.
	(swap_out_syms): Set type of BSF_THREAD_LOCAL symbols and symbols from
	SEC_THREAD_LOCAL sections to STT_TLS.
	* reloc.c: Add 386 and IA-64 TLS relocs.
	* section.c (SEC_THREAD_LOCAL): Define.
	(SEC_CONSTRUCTOR_TEXT, SEC_CONSTRUCTOR_DATA, SEC_CONSTRUCTOR_BSS):
	Remove.
	* elflink.h (elf_link_add_object_symbols): Support .tcommon.
	(size_dynamic_sections): If DF_STATIC_TLS, set DF_FLAGS
	unconditionally.
	(struct elf_final_link_info): Add first_tls_sec.
	(elf_bfd_final_link): Set first_tls_sec.
	Compute elf_hash_table (info)->tls_segment.
	(elf_link_output_extsym): Handle STT_TLS symbols.
	(elf_link_input_bfd): Likewise.
	* syms.c (BSF_THREAD_LOCAL): Define.
	* bfd-in2.h: Rebuilt.
	* libbfd.h: Rebuilt.
	* elf32-i386.c (elf_i386_tls_transition, dtpoff_base, tpoff,
	elf_i386_mkobject, elf_i386_object_p): New functions.
	(elf_howto_table): Add TLS relocs.
	(elf_i386_reloc_type_lookup): Support TLS relocs.
	(elf_i386_info_to_howto_rel): Likewise.
	(struct elf_i386_link_hash_entry): Add tls_type.
	(struct elf_i386_obj_tdata): New.
	(elf_i386_hash_entry, elf_i386_tdata, elf_i386_local_got_tls_type):
	New macros.
	(struct elf_i386_link_hash_table): Add tls_ldm_got.
	(link_hash_newfunc): Clear tls_type.
	(elf_i386_check_relocs): Support TLS relocs.
	(elf_i386_gc_sweep_hook): Likewise.
	(allocate_dynrelocs): Likewise.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Likewise.
	(elf_i386_finish_dynamic_symbol): Likewise.
	(bfd_elf32_mkobject, elf_backend_object_p): Define.
	* elfxx-ia64.c (struct elfNN_ia64_dyn_sym_info): Add tprel_offset,
	dtpmod_offset, dtprel_offset, tprel_done, dtpmod_done, dtprel_done,
	want_tprel, want_dtpmod, want_dtprel.
	(elfNN_ia64_tprel_base, elfNN_ia64_dtprel_base): New functions.
	(ia64_howto_table): Add TLS relocs, rename R_IA64_LTOFF_TP22 to
	R_IA64_LTOFF_TPREL22.
	(elf_code_to_howto_index): Add TLS relocs.
	(elfNN_ia64_check_relocs): Support TLS relocs.
	(allocate_global_data_got): Account for TLS .got data.
	(allocate_dynrel_entries): Account for TLS dynamic relocations.
	(elfNN_ia64_install_value): Supprt TLS relocs.
	(set_got_entry): Support TLS relocs.
	(elfNN_ia64_relocate_section): Likewise.

	* config/obj-elf.c (elf_common): Renamed from obj_elf_common.
	(obj_elf_common): Call elf_common.
	(obj_elf_tls_common): New function.
	(elf_pseudo_tab): Support .tls_common.
	(special_sections): Add .tdata and .tbss.
	(obj_elf_change_section): Set SEC_THREAD_LOCAL for SHF_TLS
	sections.
	(obj_elf_parse_section_letters): Support T in section flags (SHF_TLS).
	(obj_elf_parse_section_letters): Include T in error message.
	* config/tc-ppc.c (ppc_section_letter): Likewise.
	* config/tc-alpha.c (alpha_elf_section_letter): Likewise.
	(tc_gen_reloc): Handle SEC_THREAD_LOCAL the same way as
	SEC_MERGE.
	* config/tc-sparc.c (md_apply_fix3): Likewise.
	* config/tc-i386.c (tc_i386_fix_adjustable): Add TLS relocs.
	Define them if not BFD_ASSEMBLER.
	(lex_got): Support @@TLSGD, @@TLSLDM, @@GOTTPOFF, @@TPOFF, @@DTPOFF
	and @@NTPOFF.
	(md_apply_fix3): Add TLS relocs.
	* config/tc-ia64.c (enum reloc_func): Add FUNC_DTP_MODULE,
	FUNC_DTP_RELATIVE, FUNC_TP_RELATIVE, FUNC_LT_DTP_MODULE,
	FUNC_LT_DTP_RELATIVE, FUNC_LT_TP_RELATIVE.
	(pseudo_func): Support @@dtpmod(), @@dtprel() and @@tprel().
	(ia64_elf_section_letter): Include T in error message.
	(md_begin): Support TLS operators.
	(md_operand): Likewise.
	(ia64_gen_real_reloc_type): Support TLS relocs.
	* testsuite/gas/i386/tlspic.s: New file.
	* testsuite/gas/i386/tlsd.s: New file.
	* testsuite/gas/i386/tlsnopic.s: New file.
	* testsuite/gas/i386/tlsd.d: New file.
	* testsuite/gas/i386/tlsnopic.d: New file.
	* testsuite/gas/i386/tlspic.d: New file.
	* testsuite/gas/i386/i386.exp: Add tlsd, tlsnopic and tlspic tests.
	* testsuite/gas/ia64/tls.s: New file.
	* testsuite/gas/ia64/tls.d: New file.
	* testsuite/gas/ia64/ia64.exp: Add tls test.
	* write.c (adjust_reloc_syms): Don't change symbols in
	SEC_THREAD_LOCAL sections to STT_SECTION + addend.

	* elf/common.h (PT_TLS, SHF_TLS, STT_TLS, DF_STATIC_TLS): Define.
	* elf/ia64.h (R_IA64_LTOFF_TPREL22): Renamed from R_IA64_LTOFF_TP22.
	* elf/i386.h: Add TLS relocs.

	* scripttempl/elf.sc: Add .rel{,a}.t{bss,data}, .tdata and .tbss.
	* ldlang.c (lang_add_section): Set SEC_THREAD_LOCAL for
	output section if necessary.  Handle .tbss.
	(lang_size_sections): Clear _raw_size for .tbss section
	(it allocates space in PT_TLS segment only).
	* ldwrite.c (build_link_order): Build link order for .tbss too.

	* readelf.c (get_segment_type): Add PT_TLS.
	(get_elf_section_flags): Add SHF_TLS.
	(get_dynamic_flags): Optimize.  Add DF_STATIC_TLS.
	(process_dynamic_segment): Use puts instead of printf.
	(get_symbol_type): Support STT_TLS.
	* objdump.c (dump_section_header): Remove SEC_CONSTRUCTOR_TEXT,
	SEC_CONSTRUCTOR_DATA, SEC_CONSTRUCTOR_BSS.
	Add SEC_THREAD_LOCAL.
@
text
@d3 1
a3 1
   1998, 1999, 2000, 2001
d64 2
a65 2
extern CONST int md_short_jump_size;
extern CONST int md_long_jump_size;
@


1.56
log
@	* write.c (size_seg): Check adjustment to last frag.
	(SUB_SEGMENT_ALIGN): If HANDLE_ALIGN defined, pad out last frag to
	section alignment.
	* config/obj-coff.c (SUB_SEGMENT_ALIGN): Likewise.
	* config/obj-ieee.c (SUB_SEGMENT_ALIGN): Likewise.
	(write_object_file): Invoke md_do_align if available, and use
	frag_align_code on text sections.
	* config/obj-vms.h (SUB_SEGMENT_ALIGN): Now two args.
	* config/tc-m88k.h (SUB_SEGMENT_ALIGN): Likewise.
	* config/tc-ppc.h (SUB_SEGMENT_ALIGN): Likewise.
	* config/tc-sh.h (SUB_SEGMENT_ALIGN): Likewise.
	* config/tc-i386.h (SUB_SEGMENT_ALIGN): Likewise.  Define for
	BFD_ASSEMBLER too.
@
text
@d892 7
@


1.55
log
@	* write.c (subsegs_finish): Don't specially align last subseg.
@
text
@d681 8
a688 1
      fragp->fr_offset += newsize - size;
d1428 8
d1437 1
a1437 1
#define SUB_SEGMENT_ALIGN(SEG) (0)
d1439 2
a1440 1
#define SUB_SEGMENT_ALIGN(SEG) (2)
d1451 1
a1451 1
      int alignment;
d1458 2
a1459 1
      alignment = had_errors () ? 0 : SUB_SEGMENT_ALIGN (now_seg);
@


1.54
log
@	* write.c (cvt_frag_to_fill): Set fr_offset to zero on .org
	backwards to prevent cascading errors.
@
text
@a1443 6
      /* The last subsegment gets an aligment corresponding to the
	 alignment of the section.  This allows proper nop-filling
	 at the end of code-bearing sections.  */
      if (!frchainP->frch_next || frchainP->frch_next->frch_seg != now_seg)
	alignment = get_recorded_alignment (now_seg);

@


1.53
log
@	* config/tc-i386.c (tc_gen_reloc): Don't attempt to handle 8 byte
	relocs except when BFD64.

	* write.c (number_to_chars_bigendian): Don't abort when N is
	larger than sizeof (VAL).
	(number_to_chars_littleendian): Likewise.
@
text
@d530 1
@


1.52
log
@	* write.c (write_object_file): Make use of bfd_section_list_remove.
	* config/obj-ecoff.c (ecoff_frob_file): Likewise.
	* config/tc-mmix.c (mmix_frob_file): Likewise.
@
text
@d2926 1
a2926 1
  if ((size_t) n > sizeof (val) || n <= 0)
d2941 1
a2941 1
  if ((size_t) n > sizeof (val) || n <= 0)
@


1.52.2.1
log
@	* aclocal.m4: Regenerate.
	* config.in: Regenerate.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.

	Merge from mainline.
	2002-03-12  Andreas Schwab  <schwab@@suse.de>
	* config/tc-ia64.c (fixup_unw_records): Clear region when seeing a
	body record so that an error is given for misplaced .save
	pseudo-ops.

	2002-03-09  Alan Modra  <amodra@@bigpond.net.au>
	* config/tc-i386.h (REX_OPCODE): Define.
	(REX_MODE64, REX_EXTX, REX_EXTY, REX_EXTZ): Define.
	(rex_byte): typedef to int.
	* config/tc-i386.c: Group prototypes and vars together.
	Formatting fixes.  Remove occurrences of "register" keyword.
	(true): Delete.
	(false): Delete.
	(mode_from_disp_size): Add INLINE keyword to prototype.
	(fits_in_signed_byte): Likewise.
	(fits_in_unsigned_byte): Likewise.
	(fits_in_unsigned_word): Likewise.
	(fits_in_signed_word): Likewise.
	(fits_in_unsigned_long): Likewise.
	(fits_in_signed_long): Likewise.
	(type_names): Constify.
	(intel_float_operand): Constify param.
	(add_prefix): Use REX_OPCODE.
	(md_assemble): Likewise.  Modify for changed rex_byte.
	(parse_insn): Split out of md_assemble.
	(parse_operands): Likewise.
	(swap_operands): Likewise.
	(optimize_imm): Likewise.
	(optimize_disp): Likewise.
	(match_template): Likewise.
	(check_string): Likewise.
	(process_suffix): Likewise.
	(check_byte_reg): Likewise.
	(check_long_reg): Likewise.
	(check_qword_reg): Likewise.
	(check_word_reg): Likewise.
	(finalize_imm): Likewise.
	(process_operands): Likewise.
	(build_modrm_byte): Likewise.
	(output_insn): Likewise.
	(output_branch): Likewise.
	(output_jump): Likewise.
	(output_interseg_jump): Likewise.
	(output_disp): Likewise.
	(output_imm): Likewise.

	2002-03-06  Alan Modra  <amodra@@bigpond.net.au>
	* config/tc-i386.c (tc_gen_reloc): Don't attempt to handle 8 byte
	relocs except when BFD64.
	* write.c (number_to_chars_bigendian): Don't abort when N is
	larger than sizeof (VAL).
	(number_to_chars_littleendian): Likewise.

	2002-03-05  John David Anglin  <dave@@hiauly1.hia.nrc.ca>
	* config/tc-hppa.c (md_apply_fix3): Add cast.
	(hppa_fix_adjustable): Adjust list of selectors using e_lrsel and
	e_rrsel.

	2002-03-04  H.J. Lu <hjl@@gnu.org>
	* config/obj-elf.c (special_section): Add .init_array,
	.fini_array and .preinit_array.
	* config/tc-ia64.h (ELF_TC_SPECIAL_SECTIONS): Remove
	.init_array and .fini_array.

	2002-03-01  Jakub Jelinek  <jakub@@redhat.com>
	* config/obj-elf.c (elf_copy_symbol_attributes): Don't copy
	visibility.
	(obj_frob_symbol): Copy visibility.
@
text
@d2926 1
a2926 1
  if (n <= 0)
d2941 1
a2941 1
  if (n <= 0)
@


1.51
log
@	* elf64-alpha.c (ALPHA_ELF_GOT_ENTRY_RELOCS_XLATED): Defined.
	(elf64_alpha_relocate_section): Translate local_got_entries
	for STT_SECTION symbol to SHF_MERGE section the first time
	we see it.
	* elfxx-ia64.c (struct elfNN_ia64_local_hash_entry): Add
	sec_merge_done.
	(get_local_sym_hash): New, extracted from get_dyn_sym_info.
	(get_dyn_sym_info): Use it.
	(elfNN_ia64_relocate_section): Translate local dyn entries
	for STT_SECTION symbol to SHF_MERGE section the first time
	we see it.

        * write.c (adjust_reloc_syms): Mark SEC_MERGE symbols as used
        in reloc if it has non-zero addend.
        * config/tc-alpha.c (tc_gen_reloc): Reinstall SEC_MERGE check.
        * config/tc-sparc.c (md_apply_fix3): Likewise.
@
text
@d1510 1
a1510 1
    asection **seclist, *sec;
d1514 1
a1514 1
    while (seclist && *seclist)
d1516 1
a1516 2
	sec = *seclist;
	while (sec == reg_section || sec == expr_section)
d1518 1
a1518 2
	    sec = sec->next;
	    *seclist = sec;
a1519 2
	    if (!sec)
	      break;
d1521 1
a1521 1
	if (*seclist)
@


1.50
log
@	* elf.c (_bfd_elf_rela_local_sym): New.
	* elflink.h (elf_link_input_bfd): Don't consider empty
	merged sections as removed in relocation tests.
	* elf-bfd.h (_bfd_elf_rela_local_sym): Add prototype.
	* elf32-i386.c (elf_i386_relocate_section): Handle relocs
	against STT_SECTION symbol of SHF_MERGE section.
	* elf32-arm.h (elf32_arm_relocate_section): Likewise.
	* elf32-avr.c (elf32_avr_relocate_section): Call
	_bfd_elf_rela_local_sym.
	* elf32-cris.c (cris_elf_relocate_section): Likewise.
	* elf32-d10v.c (elf32_d10v_relocate_section): Likewise.
	* elf32-fr30.c (fr30_final_link_relocate): Likewise.
	* elf32-h8300.c (elf32_h8_relocate_section): Likewise.
	* elf32-hppa.c (elf32_hppa_relocate_section): Likewise.
	* elf32-i370.c (i370_elf_relocate_section): Likewise.
	* elf32-i860.c (elf32_i860_relocate_section): Likewise.
	* elf32-m32r.c (m32r_elf_relocate_section): Likewise.
	* elf32-m68k.c (elf_m68k_relocate_section): Likewise.
	* elf32-mcore.c (mcore_elf_relocate_section): Likewise.
	* elf32-openrisc.c (openrisc_elf_relocate_section): Likewise.
	* elf32-ppc.c (ppc_elf_relocate_section): Likewise.
	* elf32-s390.c (elf_s390_relocate_section): Likewise.
	* elf32-sparc.c (elf32_sparc_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_relocate_section): Likewise.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf64-mmix.c (mmix_elf_relocate_section): Likewise.
	* elf64-ppc.c (ppc64_elf_relocate_section): Likewise.
	* elf64-s390.c (elf_s390_relocate_section): Likewise.
	* elf64-sparc.c (sparc64_elf_relocate_section): Likewise.
	* elf64-x86-64.c (elf64_x86_64_relocate_section): Likewise.
	* elf-hppa.h (elf_hppa_relocate_section): Likewise.
	* elf-m10200.c (mn10200_elf_relocate_section): Likewise.
	* elf-m10300.c (mn10300_elf_relocate_section): Likewise.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Likewise.
	* elf32-sh.c (sh_elf_relocate_section): Likewise for
	!partial_inplace relocs. Handle relocs against STT_SECTION
	symbol of SHF_MERGE for partial_inplace relocs.

	* config/tc-alpha.c (tc_gen_reloc): Remove SEC_MERGE test.
	* write.c (adjust_reloc_syms): Don't handle relocs against
	SEC_MERGE section symbols specially.
	(fixup_segment): Likewise.
@
text
@d876 8
@


1.49
log
@Update all uses of md_apply_fix to use md_apply_fix3.  Make it a void function.
@
text
@a875 7

	/* Never adjust a reloc against local symbol in a merge section.  */
	if (symsec->flags & SEC_MERGE)
	  {
	    symbol_mark_used_in_reloc (fixp->fx_addsy);
	    goto done;
	  }
a2810 3
		       || (bfd_get_section_flags (stdoutput,
						  add_symbol_segment)
			   & SEC_MERGE) != 0
@


1.48
log
@Fix tic54x testsuite failures and Lmem disassembly bugs.
@
text
@d2561 1
a2561 1
   For each one, call md_apply_fix to put the fix into the frag data.
d2872 1
a2872 19
	{
#ifdef MD_APPLY_FIX3
	  md_apply_fix3 (fixP, &add_number, this_segment_type);
#else
#ifdef BFD_ASSEMBLER
	  md_apply_fix (fixP, &add_number);
#else
	  md_apply_fix (fixP, add_number);
#endif
#endif

#ifndef TC_HANDLES_FX_DONE
	  /* If the tc-* files haven't been converted, assume it's handling
	     it the old way, where a null fx_addsy means that the fix has
	     been applied completely, and no further work is needed.  */
	  if (fixP->fx_addsy == 0 && fixP->fx_pcrel == 0)
	    fixP->fx_done = 1;
#endif
	}
@


1.47
log
@	* write.c (fixup_segment): Handle fixups for SEC_MERGE sections as
	for undefined symbols.
@
text
@d2433 6
a2438 1
		      target += S_GET_VALUE (symbolP);
@


1.46
log
@	* dwarf2dbg.c (dwarf2_directive_file): Avoid signed/unsigned warning.

	* write.c (set_symtab): Update bfd_alloc declaration.  Use a temp
	var to ensure bfd_alloc arg is the right type.
	(write_object_file): Cast args of bfd_seek.  Replace bfd_write with
	bfd_bwrite.

	* config/obj-coff.c: Replace calls to bfd_write with calls to
	bfd_bwrite.  Cast args of bfd_seek.

	* config/obj-elf.c (obj_elf_change_section): Avoid signed/unsigned
	warning.

	* config/tc-mn10300.c (set_arch_mach): Make param unsigned.

	* config/tc-tic54x.c (tic54x_mlib): Replace bfd_read call with
	call to bfd_bread.
@
text
@d2813 3
@


1.45
log
@	* expr.c (expr): Move code setting "retval" to the end of the loop,
	and rearrange for efficiency.  For "PIC code" subtraction, use
	"rightseg" rather than recalculating.  For "symbol OP symbol"
	subtract, set "retval" to absolute_section if symbols in same
	section.
	* symbols.c (resolve_symbol_value): Resolve "sym +/- expr" to an
	O_symbol.  Simplify a +/- b code.  Allow equality and non-equality
	comparisons on symbols from any section.  Allow other comparison
	operators as for subtraction.
	(symbol_equated_reloc_p): New predicate function.
	* symbols.h (symbol_equated_reloc_p): Declare.
	* write.c (adjust_reloc_syms): Use symbol_equated_reloc_p.
	(write_relocs): Likewise.
	(write_object_file): Likewise.
	(relax_segment <rs_machine_dependent>): Ensure segment for
	expression syms is set correctly.
	* config/tc-mips.c (md_estimate_size_before_relax): Likewise.
	* config/tc-i386.c (md_assemble <Output jumps>): Don't lose part
	of a complex expression when setting up frag_var.
@
text
@d1368 1
a1368 1
  extern PTR bfd_alloc PARAMS ((bfd *, size_t));
d1380 1
d1382 1
a1382 2
      asympp = (asymbol **) bfd_alloc (stdoutput,
				       nsyms * sizeof (asymbol *));
d1883 2
a1884 2
    bfd_seek (stdoutput, 0, 0);
    bfd_write (the_object_file, 1, object_file_size, stdoutput);
@


1.44
log
@	* read.c: Standardize error/warning messages - don't capitalise, no
	final period or newline, don't say "ignored" or "zero assumed" for
	as_bad messages.  In some cases, change the wording to that used
	elsewhere for similar messages.
	* app.c, as.c, atof-generic.c, cgen.c, cond.c, depend.c, dwarf2dbg.c,
	  ecoff.c, expr.c, frags.c, input-file.c, input-scrub.c, listing.c,
	  output-file.c, stabs.c, subsegs.c, symbols.c, write.c: Likewise.
	* ecoff.c (ecoff_directive_end): Test for missing name by
	comparing input line pointers rather than reading string.
	(ecoff_directive_ent): Likewise.
	* read.c (s_set): Likewise.
	(s_align): Report a warning rather than an error for
	alignment too large.
	(s_comm): Check for missing symbol name.
	(s_lcomm_internal): Likewise.
	(s_lsym): Likewise.
	(s_globl): Use is_end_of_line instead of looking for '\n'.
	(s_lcomm_internal): Likewise.
	(ignore_rest_of_line): Report a warning rather than an error.
@
text
@d772 1
a772 2
	if (sym != NULL && symbol_equated_p (sym)
	    && (! S_IS_DEFINED (sym) || S_IS_COMMON (sym)))
d985 1
a985 1
         symbol, then use generate the reloc against the latter symbol
d988 1
a988 2
      while (symbol_equated_p (sym)
	     && (! S_IS_DEFINED (sym) || S_IS_COMMON (sym)))
d1060 1
a1060 2
      while (symbol_equated_p (sym)
	     && (! S_IS_DEFINED (sym) || S_IS_COMMON (sym)))
d1960 1
a1960 2
	  if (symbol_equated_p (symp)
	      && (! S_IS_DEFINED (symp) || S_IS_COMMON (symp)))
d2263 6
@


1.43
log
@	* write.c (relax_segment <rs_space>): Account for fr_fix.
@
text
@d1237 1
a1237 1
		    as_fatal (_("Cannot write to output file."));
d1486 1
a1486 1
	  as_warn (_("%d error%s, %d warning%s, generating bad object file.\n"),
d1493 1
a1493 1
	  as_fatal (_("%d error%s, %d warning%s, no object file generated.\n"),
d1953 1
a1953 1
		as_bad (_("local label %s is not defined"), name2);
d2016 1
a2016 1
	      as_bad (_("can't resolve value for symbol \"%s\""),
d2443 1
a2443 1
				    _("attempt to .org backwards ignored"));
d2652 1
a2652 1
			      _("Negative of non-absolute symbol %s"),
d2666 1
a2666 1
			      _("callj to difference of 2 symbols"));
d2746 1
a2746 1
				_("Subtraction of two symbols in different sections \"%s\" {%s section} - \"%s\" {%s section} at file address %s."),
d2900 1
a2900 1
				_("Value of %s too large for field of %d bytes at %s"),
d2912 1
a2912 1
			  _("Signed .word overflow; switch may be too large; %ld at 0x%lx"),
@


1.42
log
@	* symbols.c (S_GET_VALUE): Don't treat O_constant and local
	symbols specially.  Always resolve, adding fr_address to value.
	* write.c (write_object_file): Don't add fr_address to sym values.
	(relax_frag): Likewise.
	(relax_segment): Likewise.
	* config/obj-ieee.c (do_symbols): Likewise.
	* config/tc-cris.c (md_convert_frag): Likewise.
	* config/tc-fr30.c (md_convert_frag): Likewise.
	* config/tc-i386.c (md_convert_frag): Likewise.
	* config/tc-m32r.c (md_convert_frag): Likewise.
	* config/tc-m68hc11.c (md_convert_frag): Likewise.
	* config/tc-mcore.c (md_convert_frag): Likewise.
	* config/tc-mips.c (mips16_extended_frag): Likewise.
	* config/tc-ns32k.c (md_convert_frag): Likewise.
	* config/tc-m68k.c (md_convert_frag_1): Likewise.
	(BRANCHBWL, BRABSJUNC, BRABSJCOND, BRANCHBW, FBRANCH, DBCCLBR,
	DBCCABSJ, PCREL1632, PCINDEX, ABSTOPCREL): Decrement.
	(md_relax_table): Remove first four entries.  Format.
	(md_estimate_size_before_relax): Remove old_fix.  Don't bother
	setting fr_var.  Simplify byte branch checks.
@
text
@d2482 1
a2482 1
		      growth = (was_address + amount
@


1.41
log
@Fix mips16 testsuite failure by allowing finalize_syms to be set before
size_segs is called.
@
text
@a1752 3
#ifdef BFD_ASSEMBLER
	    to_addr -= symbol_get_frag (lie->sub)->fr_address;
#endif
a1768 3
#ifdef BFD_ASSEMBLER
	    to_addr += symbol_get_frag (lie->add)->fr_address;
#endif
d2112 1
a2112 1
      target += S_GET_VALUE (symbolP) + sym_frag->fr_address;
d2353 1
a2353 2
		      offset = (symbol_get_frag (lie->add)->fr_address
				+ S_GET_VALUE (lie->add)
d2355 1
a2355 2
				- (symbol_get_frag (lie->sub)->fr_address
				   + S_GET_VALUE (lie->sub)));
d2431 2
a2432 3
		      target += (S_GET_VALUE (symbolP)
				 + symbol_get_frag (symbolP)->fr_address);
		    }		/* if we have a symbol  */
@


1.40
log
@Do not set finalize_syms until after the segments have been sized.
Some backends may still need to access the syms's frags in order to
adjust relaxed frags.
@
text
@d55 4
d1582 9
a1590 3
  /* Note - we do not set finalize_syms here because some targets
     do not finish sizing all of their frags until after size_seg
     has completed.  */
@


1.39
log
@	* write.c (fixup_segment <Difference of 2 syms same seg>): Don't
	subtract MD_PCREL_FROM_SECTION for 68k.
	(fixup_segment <Difference of 2 syms different seg>): Only fudge
	by adding MD_PCREL_FROM_SECTION for 68k or if not already pcrel.
@
text
@a1576 2
  /* Relaxation has completed.  Freeze all syms.  */
  finalize_syms = 1;
d1578 3
d1584 3
a1587 1
#endif /* BFD_ASSEMBLER  */
@


1.38
log
@	* write.c (fixup_segment <Difference of 2 syms same seg>): If
	pcrel, subtract MD_PCREL_FROM_SECTION value.
@
text
@d2666 6
a2671 1
	      if (pcrel)
d2697 1
a2697 9
	      else if (S_GET_SEGMENT (sub_symbolP) == this_segment_type
#if 0
		       /* Do this even if it's already described as
			  pc-relative.  For example, on the m68k, an
			  operand of "pc@@(foo-.-2)" should address
			  "foo" in a pc-relative mode.  */
		       && pcrel
#endif
		       )
d2700 17
a2716 4
		  add_number += (MD_PCREL_FROM_SECTION (fixP, this_segment_type)
				 - S_GET_VALUE (sub_symbolP));
		  pcrel = 1;
		  fixP->fx_pcrel = 1;
@


1.37
log
@	* write.c (relax_segment <rs_space>): Check the section of a
	symbol to determine whether it is absolute rather than comparing
	its frag against zero_address_frag as listings play tricks with
	frags.
@
text
@d2664 4
a2667 2
	      add_number += S_GET_VALUE (add_symbolP) -
		S_GET_VALUE (sub_symbolP);
@


1.36
log
@	* write.c (relax_segment <rs_space>): Calculate growth using
	addresses before stretch.  Prevent repeated error messages.
	From Peter Jakubek  <pjak@@snafu.de>
	Use as_bad_where and as_warn_where to pinpoint errors.
@
text
@d2462 1
a2462 1
		    if (symbol_get_frag (symbolP) != &zero_address_frag
@


1.35
log
@	* write.c (relax_segment): Don't zap fr_symbol when relaxing.
@
text
@d2244 3
a2246 2
		as_bad (_("alignment padding (%lu bytes) not a multiple of %ld"),
			(unsigned long) offset, (long) fragP->fr_var);
d2357 5
a2361 4
			      as_warn (_(".word %s-%s+%s didn't fit"),
				       S_GET_NAME (lie->add),
				       S_GET_NAME (lie->sub),
				       buf);
d2456 1
a2464 3
		      as_bad_where (fragP->fr_file, fragP->fr_line,
				    _(".space specifies non-absolute value"));
		    if (amount < 0)
d2466 9
a2474 2
			as_warn (_(".space or .fill with negative value, ignored"));
			amount = 0;
d2477 3
a2479 2
		    growth = (fragP->fr_address + amount
			      - fragP->fr_next->fr_address);
a2480 2
		else
		  growth = 0;
@


1.34
log
@	* write.c (write_object_file): Set finalize_syms = 1 before
	size_seg is called.
@
text
@d2456 3
a2458 1
		    growth = S_GET_VALUE (symbolP);
d2464 1
a2464 2
		    fragP->fr_symbol = 0;
		    if (growth < 0)
d2467 2
a2468 1
			growth = 0;
d2470 2
@


1.33
log
@	* symbols.c (resolve_symbol_value): Remove "finalize" param,
	instead use finalize_syms directly.  Don't treat expressions
	specially with regard to finalize_syms.  Update calls to self.
	(resolve_local_symbol): Update call to resolve_symbol_value.
	(S_GET_VALUE): Likewise.  Return resolve_symbol_value if
	!finalize_syms.
	* symbols.h (resolve_symbol_value): Update prototype.
	* config/obj-aout.c (obj_crawl_symbol_chain): Update call
	to resolve_symbol_value.
	* config/obj-bout.c (obj_crawl_symbol_chain): Likewise.
	* config/obj-coff.c (do_relocs_for): Likewise.
	(yank_symbols): Likewise.
	(fixup_segment): Likewise.
	* config/obj-vms.c (obj_crawl_symbol_chain): Likewise.
	* config/tc-mips.c (md_convert_frag): Likewise.
	* config/tc-ppc.c (ppc_frob_symbol): Likewise.
	(ppc_fix_adjustable): Likewise.
	* dwarf2dbg.c (dwarf2dbg_estimate_size_before_relax): Likewise.
	(dwarf2dbg_convert_frag): Likewise.
	* ehopt.c (eh_frame_estimate_size_before_relax): Likewise.
	(eh_frame_convert_frag): Likewise.
	* expr.c (make_expr_symbol): Likewise.
	* write.c (adjust_reloc_syms): Likewise.
	(write_object_file): Likewise.
	(relax_segment): Likewise.
	(fixup_segment): Likewise.
	(finalize_syms): Init to zero, and update comment.
	(write_object_file): Set finalize_syms to 1 rather than 2.
	* doc/internals.texi (sy_value): Mention finalize_syms.
	(S_GET_VALUE): Remove restriction on when S_GET_VALUE can be called.
@
text
@d1577 3
d1583 1
a1584 3

  /* Relaxation has completed.  Freeze all syms.  */
  finalize_syms = 1;
@


1.32
log
@bfd/
	* libbfd-in.h (_bfd_merge_section): New.
	(_bfd_write_merged_section): New.
	(_bfd_merged_section_offset): New.
	* libbfd.h: Rebuilt.
	* linker.c (_bfd_generic_link_output_symbols): Handle
	discard_sec_merge.
	* aoutx.h (aout_link_write_symbols): Likewise.
	* pdp11.c (aout_link_write_symbols): Likewise.
	* elflink.h (elf_link_add_object_symbols): Call _bfd_merge_section.
	(elf_bfd_final_link): Adjust global symbols pointing into SEC_MERGE
	sections.
	(elf_link_sec_merge_syms): New.
	(elf_link_input_bfd): Call _bfd_merged_section_offset
	and _bfd_write_merged_section.
	Handle discard_sec_merge.
	* elf-bfd.h (struct elf_link_hash_table): Add merge_info
	field.
	(struct bfd_elf_section_data): Likewise.
	* elf.c (_bfd_elf_make_section_from_shdr): Set SEC_MERGE and
	SEC_STRINGS section flags and entsize from their ELF counterparts.
	(_bfd_elf_link_hash_table_init): Initialize merge_info.
	(elf_fake_sections): Set SHF_MERGE, SHF_STRINGS and sh_entsize
	from their BFD counterparts.
	* merge.c: New file.
	* Makefile.am: Add strtab.lo.
	* Makefile.in: Rebuilt.
include/
	* bfdlink.h (bfd_link_discard): Add discard_sec_merge.
gas/
	* config/obj-elf.c (obj_elf_change_section): Add entsize argument,
	handle SHF_MERGE and SHF_STRINGS.
	(obj_elf_parse_section_letters): Set SHF_MERGE and SHF_STRINGS.
	(obj_elf_section): Allow additional argument specifying entity size.
	* write.c (adjust_reloc_syms): Keep relocations against local symbols
	in SEC_MERGE sections.
ld/
	* ldmain.c (main): Default to discard_sec_merge.
	* lexsup.c (OPTION_DISCARD_NONE): Define.
	(ld_options): Add --discard-none.
	(parse_args): Handle OPTION_DISCARD_NONE.
	* ldlang.c (wild_doit): SEC_MERGE should be set in the output
	section only if SEC_MERGE and SEC_STRINGS flags and entsize of
	all its input sections match.
@
text
@d64 2
a65 4
/* Used to control final evaluation of expressions that are more
   complex than symbol + constant.  1 means set final value for simple
   expressions, 2 means set final value for more complex expressions.  */
int finalize_syms = 1;
d761 1
a761 1
	  resolve_symbol_value (sym, finalize_syms);
d764 1
a764 1
	  resolve_symbol_value (fixp->fx_subsy, finalize_syms);
d1583 1
a1583 1
  finalize_syms = 2;
d1903 1
a1903 1
	resolve_symbol_value (symp, finalize_syms);
d1951 1
a1951 1
	  resolve_symbol_value (symp, finalize_syms);
d2489 1
a2489 1
		  value = resolve_symbol_value (fragP->fr_symbol, 0);
d2612 1
a2612 1
	  resolve_symbol_value (sub_symbolP, finalize_syms);
@


1.31
log
@	* write.c (write_object_file): Reset broken word state before
	calling relax_seg.
@
text
@d875 7
@


1.30
log
@Multi-pass relaxation machinery.
@
text
@d1547 20
@


1.29
log
@fix_new_exp: Print an error if passed a register.
@
text
@d64 5
a129 1
static void relax_and_size_seg PARAMS ((bfd *, asection *, PTR));
d604 1
d606 18
a623 1
relax_and_size_seg (abfd, sec, xxx)
a635 2
  flags = bfd_get_section_flags (abfd, sec);

a638 1
      relax_segment (seginfo->frchainP->frch_root, sec);
d651 2
d763 1
a763 1
	  resolve_symbol_value (sym, 1);
d766 1
a766 1
	  resolve_symbol_value (fixp->fx_subsy, 1);
d1543 10
a1552 1
  bfd_map_over_sections (stdoutput, relax_and_size_seg, (char *) 0);
d1557 3
d1878 1
a1878 1
	resolve_symbol_value (symp, 1);
d1926 1
a1926 1
	  resolve_symbol_value (symp, 1);
d2177 1
a2177 1
void
d2184 2
d2267 1
a2267 1
    long stretched;	/* Have we stretched on this pass?  */
d2274 2
a2275 1
	stretch = stretched = 0;
d2384 2
a2385 2
		  long target = offset;
		  long after;
d2486 1
a2486 1
		stretched++;
d2493 8
a2500 4
  /* We now have valid fr_address'es for each frag.  */

  /* All fr_address's are correct, relative to their own segment.
     We have made all the fixS we will ever make.  */
d2587 1
a2587 1
	  resolve_symbol_value (sub_symbolP, 1);
@


1.28
log
@Use `relax_marker' instead of fragile address test code to determine
whether a frag's fr_address has been updated.
@
text
@d286 4
@


1.27
log
@Fix copyright notices
@
text
@a1998 22
static int is_dnrange PARAMS ((fragS *, fragS *));

/* Subroutines of relax_segment.  */

static int
is_dnrange (f1, f2)
     fragS *f1;
     fragS *f2;
{
  addressT f2addr;

  f2addr = f2->fr_address;
  for (; f1; f1 = f1->fr_next)
    {
      if (f1->fr_next == f2)
	return 1;
      if (f1->fr_address > f2addr)
	break;
    }
  return 0;
}

d2011 10
a2020 8
  long aim, target, growth;
  symbolS *symbolP = fragP->fr_symbol;
  long offset = fragP->fr_offset;
  /* Recompute was_address by undoing "+= stretch" done by relax_segment.  */
  unsigned long was_address = fragP->fr_address - stretch;
  unsigned long address = fragP->fr_address;
  const relax_typeS *table = TC_GENERIC_RELAX_TABLE;

d2023 1
a2023 1
  target = offset;
d2047 1
a2047 3
	 between grows, and that will force another pass.

	 Beware zero-length frags.  */
d2050 2
a2051 4
	  && S_GET_SEGMENT (symbolP) == segment
	  && (sym_frag->fr_address > was_address
	      || (sym_frag->fr_address == was_address
		  && is_dnrange (fragP, sym_frag))))
d2158 1
d2244 1
@


1.26
log
@	* write.c (is_dnrange): Stop as soon as the address becomes
	larger.
	(relax_frag): Add segment parameter.  Only call symbol_get_frag
	once.  Only call is_dnrange if the symbol is in the same segment,
	and the symbol address is larger.
	(relax_segment): Pass segment to md_relax_frag and relax_frag.
	* write.h (relax_frag): Update declaration.
	* config/tc-fr30.c (fr30_relax_frag): Add segment parameter.  Pass
	it to relax_frag.
	* config/tc-m32r.c (m32r_relax_frag): Likewise.
	* config/tc-m32r.h (md_relax_frag): Add segment parameter.
	(m32r_relax_frag): Update declaration.
	* config/tc-mips.h (md_relax_frag): Add segment parameter.
	* config/tc-tic54x.h (md_relax_frag): Likewise.
	* doc/internals.texi (CPU backend): Update documentation for
	md_relax_frag.
@
text
@d2 2
a3 1
   Copyright (C) 1986, 87, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
@


1.25
log
@        * write.c (subsegs_finish): Fix thinko last change -- don't
        "optimize" the alignment == 0 case.
@
text
@d2001 1
d2007 3
d2011 6
a2016 2
    if (f1->fr_next == f2)
      return 1;
d2023 2
a2024 1
relax_frag (fragP, stretch)
d2046 4
d2057 1
a2057 1
      know (symbolP->sy_frag);
d2060 2
a2061 2
	    || symbolP->sy_frag == &zero_address_frag);
      target += S_GET_VALUE (symbolP) + symbol_get_frag (symbolP)->fr_address;
d2068 1
a2068 3
	 Beware zero-length frags.

	 There should be a faster way to do this.  */
d2070 5
a2074 2
      if (symbol_get_frag (symbolP)->fr_address >= was_address
	  && is_dnrange (fragP, symbol_get_frag (symbolP)))
d2430 1
a2430 1
		growth = md_relax_frag (fragP, stretch);
d2435 1
a2435 1
		growth = relax_frag (fragP, stretch);
@


1.25.2.1
log
@rth's fix for relaxation ordering problem.
@
text
@d124 1
a124 2
static void relax_seg PARAMS ((bfd *, asection *, PTR));
static void size_seg PARAMS ((bfd *, asection *, PTR));
d596 1
a596 15
relax_seg (abfd, sec, do_code)
     bfd *abfd;
     asection *sec;
     PTR do_code;
{
  flagword flags = bfd_get_section_flags (abfd, sec);
  segment_info_type *seginfo = seg_info (sec);

  if (!(flags & SEC_CODE) == !do_code
      && seginfo && seginfo->frchainP)
    relax_segment (seginfo->frchainP->frch_root, sec);
}

static void
size_seg (abfd, sec, xxx)
d609 2
d614 1
a626 2
  flags = bfd_get_section_flags (abfd, sec);

d1517 1
a1517 3
  bfd_map_over_sections (stdoutput, relax_seg, (char *) 1);
  bfd_map_over_sections (stdoutput, relax_seg, (char *) 0);
  bfd_map_over_sections (stdoutput, size_seg, (char *) 0);
@


1.25.2.2
log
@Merge from mainline.
@
text
@d2 1
a2 2
   Copyright 1986, 1987, 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997,
   1998, 1999, 2000, 2001
a285 4
    case O_register:
      as_bad (_("register value used as expression"));
      break;

d2014 14
d2031 1
a2031 2
relax_frag (segment, fragP, stretch)
     segT segment;
d2039 8
a2046 10
  long growth;
  offsetT aim;
  addressT target;
  addressT address;
  symbolS *symbolP;
  const relax_typeS *table;

  target = fragP->fr_offset;
  address = fragP->fr_address;
  table = TC_GENERIC_RELAX_TABLE;
d2049 1
a2049 1
  symbolP = fragP->fr_symbol;
a2052 4
      fragS *sym_frag;

      sym_frag = symbol_get_frag (symbolP);

d2060 1
a2060 1
      know (sym_frag != NULL);
d2063 2
a2064 2
	    || sym_frag == &zero_address_frag);
      target += S_GET_VALUE (symbolP) + sym_frag->fr_address;
d2069 5
a2073 1
	 between grows, and that will force another pass.  */
d2075 2
a2076 3
      if (stretch != 0
	  && sym_frag->relax_marker != fragP->relax_marker
	  && S_GET_SEGMENT (symbolP) == segment)
a2182 1
      fragP->relax_marker = 0;
d2252 1
a2252 1
    int stretched;	/* Have we stretched on this pass?  */
d2259 1
a2259 2
	stretch = 0;
	stretched = 0;
a2267 1
	    fragP->relax_marker ^= 1;
d2367 2
a2368 2
		  addressT target = offset;
		  addressT after;
d2432 1
a2432 1
		growth = md_relax_frag (segment, fragP, stretch);
d2437 1
a2437 1
		growth = relax_frag (segment, fragP, stretch);
d2469 1
a2469 1
		stretched = 1;
@


1.24
log
@	* as.h (rs_align_test): New.
	* frags.c (NOP_OPCODE): Move default from read.c.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New default.
	(frag_align_code): New.
	* frags.h (frag_align_code): Declare.
	* read.c (NOP_OPCODE): Remove.
	(do_align): Use frag_align_code.
	* write.c (NOP_OPCODE): Remove.
	(get_recorded_alignment): New.
	(cvt_frag_to_fill): Handle rs_align_test.
	(relax_segment): Likewise.
	(subsegs_finish): Align last subseg in section to the
	section alignment.  Use frag_align_code.
	* write.h (get_recorded_alignment): Declare.
	* config/obj-coff.c (size_section): Handle rs_align_test.
	(fill_section, fixup_mdeps): Likewise.
	(write_object_file): Use frag_align_code.

	* config/tc-alpha.c (alpha_align): Use frag_align_code.
	(alpha_handle_align): New.
	* config/tc-alpha.h (HANDLE_ALIGN): New.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-i386.h (md_do_align): Use frag_align_code.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-ia64.c (ia64_md_do_align): Don't do code alignment.
	(ia64_handle_align): New.
	* config/tc-ia64.h (HANDLE_ALIGN): New.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-m32r.c (m32r_do_align): Remove.
	(m32r_handle_align): New.
	(fill_insn): Use frag_align_code.
	* config/tc-m32r.h (md_do_align): Remove.
	(HANDLE_ALIGN, MAX_MEM_FOR_RS_ALIGN_CODE): New.
	* config/tc-m88k.c, config/tc-m88k.h: Similarly.
	* config/tc-mips.c, config/tc-mips.h: Similarly.

	* config/tc-sh.c (sh_cons_align): Use rs_align_test.
	(sh_handle_align): Likewise.  Handle rs_align_code.
	(sh_do_align): Remove.
	* config/tc-sh.h (md_do_align): Remove.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.

	* config/tc-sparc.c (sparc_cons_align): Use rs_align_test.
	(sparc_handle_align): Likewise.  Handle rs_align_code.
	* config/tc-sparc.h (md_do_align): Remove.
	(MAX_MEM_FOR_RS_ALIGN_CODE): New.
@
text
@d1416 4
a1419 7
      if (alignment > 0)
	{
	  if (subseg_text_p (now_seg))
	    frag_align_code (alignment, 0);
	  else
	    frag_align (alignment, 0, 0);
	}
@


1.23
log
@        * dwarf2dbg.c: Rewrite from scratch.  Queue all debugging output
        until dwarf2_finish; use relaxation to get cross-fragment offsets;
        thread multiple subsegments properly; handle multiple code
        sections properly; emit proper compilation unit info for assembler
        generated debugging.

        * as.h (enum _relax_state): Add rs_dwarf2dbg.
        * dwarf2dbg.h (struct dwarf2_line_info): Remove filename.
        (dwarf2dbg_estimate_size_before_relax): Declare.
        (dwarf2dbg_relax_frag, dwarf2dbg_convert_frag): Declare.
        * write.c: Include dwarf2dbg.h.
        (cvt_frag_to_fill): Handle rs_dwarf2dbg.
        (relax_segment): Likewise.
@
text
@a33 6
/* The NOP_OPCODE is for the alignment fill value.  Fill it with a nop
   instruction so that the disassembler does not choke on it.  */
#ifndef NOP_OPCODE
#define NOP_OPCODE 0x00
#endif

d380 13
d504 1
d1401 2
d1408 15
a1422 3
      frag_align (had_errors () ? 0 : SUB_SEGMENT_ALIGN (now_seg),
		  subseg_text_p (now_seg) ? NOP_OPCODE : 0,
		  0);
d2181 1
d2331 1
@


1.22
log
@2000-11-06  Kazu Hirata  <kazu@@hxi.com>

	* as.c: Fix formatting.
	* dwarf2dbg.c: Likewise.
	* itbl-ops.c: Likewise.
	* listing.c: Likewise.
	* macro.h: Likewise.
	* messages.c: Likewise.
	* read.c: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* write.c: Likewise.
@
text
@d28 1
d538 4
d2201 4
d2419 4
@


1.21
log
@Make elf section symbols global for link-once sections.
@
text
@d58 1
a58 1
		  
@


1.20
log
@Miscellaneous tiny fixes.
@
text
@d1011 1
a1011 1
         symbol, then use generate the reloc against the latter symbol
@


1.19
log
@* write.c (TC_FIX_ADJUSTABLE): Remove the duplicate.
@
text
@d902 1
a902 1
  int i;
@


1.18
log
@* write.c (TC_FIX_ADJUSTABLE): Define to 1, if not defined.
(fixup_segment) Use it instead of TC_DONT_FIX_NON_ADJUSTABLE.
* config/tc-i386.h (TC_DONT_FIX_NON_ADJUSTABLE): Remove.
<OBJ_ELF, OBJ_COFF, TE_PE> (TC_FIX_ADJUSTABLE): Define.
* config/tc-arm.h (TC_DONT_FIX_NON_ADJUSTABLE): Remove.
<OBJ_ELF> (TC_FIX_ADJUSTABLE): Define.
* config/tc-i960.h, config/tc-m68k.h, config/tc-v850.h:
Likewise.
@
text
@a50 4
#ifndef TC_FIX_ADJUSTABLE
#define TC_FIX_ADJUSTABLE(fix) 1
#endif
		  
@


1.17
log
@2000-08-22  Eric Christopher  <echristo@@cygnus.com>

	* config/tc-mn10300.c: (md_apply_fix): New function.
	(mn10300_force_relocation): New function.
	(mn10300_fix_adjustable): New function.

	* config/tc-mn10300.h: (TC_FORCE_RELOCATION): Define.
	(TC_HANDLES_FX_DONE): Define.
	(obj_fix_adjustable): Define.
	(MD_APPLY_FIX3): Define.
	(TC_LINKRELAX_FIXUP): Define.

	* write.c: (TC_LINKRELAX_FIXUP):  Define if not
	previously defined.
	(fixup_segment): Use TC_LINKRELAX_FIXUP.

	* doc/internals.texi: Document TC_LINKRELAX_FIXUP.
@
text
@d51 4
d59 4
d2721 1
a2721 10
#ifdef TC_DONT_FIX_NON_ADJUSTABLE
		  if (1
#ifdef obj_fix_adjustable
		      && obj_fix_adjustable (fixP)
#endif
#ifdef tc_fix_adjustable
		      && tc_fix_adjustable (fixP)
#endif
		      )
#endif
@


1.16
log
@* write.c (fixup_segment) [TC_DONT_FIX_NON_ADJUSTABLE]: Use
obj_fix_adjustable() and tc_fix_adjustable() to tell whether to
add a symbol's address.  Removed all target-specific #ifdefs that
used to accomplished the same.
* config/tc-v850.h (TC_DONT_FIX_NON_ADJUSTABLE): Define.
* config/tc-m68k.h (TC_DONT_FIX_NON_ADJUSTABLE): Define.
* config/tc-arm.h (TC_DONT_FIX_NON_ADJUSTABLE): Define.
* config/tc-i960.h (TC_DONT_FIX_NON_ADJUSTABLE): Define.
* config/tc-i386.h (TC_DONT_FIX_NON_ADJUSTABLE): Define.
@
text
@d51 4
d291 1
a291 1
	
d296 1
a296 1
	
d1242 1
a1242 1
    
d1504 1
a1504 1
    
d1512 1
a1512 1
    
d1515 1
a1515 1
    
d2113 1
a2113 1
  
d2115 1
a2115 1
  
d2211 1
a2211 1
	
d2468 1
a2468 1
  if (linkrelax)
@


1.15
log
@Fix formatting.
@
text
@d2709 4
a2712 8
#if !(defined (TC_V850) && defined (OBJ_ELF))
#if !(defined (TC_M68K) && defined (OBJ_ELF))
#if !(defined (TC_ARM)  && defined (OBJ_ELF))
#if !(defined (TC_I960) && defined (OBJ_ELF))
#if !defined (TC_I386) || !(defined (OBJ_ELF) || defined (OBJ_COFF)) || defined (TE_PE)
		  add_number += S_GET_VALUE (add_symbolP);
#endif
#endif
d2714 2
d2717 1
d2719 1
@


1.14
log
@Fix previous delta so that it is only used for TE_GO32 and not !TE_PE.
@
text
@d2 1
a2 1
   Copyright (C) 1986, 87, 90, 91, 92, 93, 94, 95, 96, 97, 98, 1999
d22 1
a22 1
/* This thing should be set up to do byteordering correctly.  But... */
d80 3
a82 3
struct frag *text_last_frag;	/* Last frag in segment. */
struct frag *data_last_frag;	/* Last frag in segment. */
static struct frag *bss_last_frag;	/* Last frag in segment. */
d90 1
a90 1
char *next_object_file_charP;	/* Tracks object file bytes. */
d96 1
a96 1
#endif /* BFD_ASSEMBLER */
d139 2
a140 5
/*
 *			fix_new()
 *
 * Create a fixS in obstack 'notes'.
 */
d144 7
a150 7
     fragS *frag;		/* Which frag? */
     int where;			/* Where in that frag? */
     int size;			/* 1, 2, or 4 usually. */
     symbolS *add_symbol;	/* X_add_symbol. */
     symbolS *sub_symbol;	/* X_op_symbol. */
     offsetT offset;		/* X_add_number. */
     int pcrel;			/* TRUE if PC-relative relocation. */
d152 1
a152 1
     bfd_reloc_code_real_type r_type; /* Relocation type */
d154 1
a154 1
     int r_type;		/* Relocation type */
d195 1
a195 1
  TC_INIT_FIX_DATA(fixP);
d203 1
a203 2
     time option.  xoxorich. */

d220 1
a220 1
#else /* REVERSE_SORT_RELOCS */
d230 1
a230 2
#endif /* REVERSE_SORT_RELOCS */

d240 6
a245 6
     fragS *frag;		/* Which frag? */
     int where;			/* Where in that frag? */
     int size;			/* 1, 2, or 4 usually. */
     symbolS *add_symbol;	/* X_add_symbol. */
     offsetT offset;		/* X_add_number. */
     int pcrel;			/* TRUE if PC-relative relocation. */
d247 1
a247 1
     bfd_reloc_code_real_type r_type; /* Relocation type */
d249 1
a249 1
     int r_type;		/* Relocation type */
d262 3
a264 3
     fragS *frag;		/* Which frag? */
     int where;			/* Where in that frag? */
     int size;			/* 1, 2, or 4 usually. */
d266 1
a266 1
     int pcrel;			/* TRUE if PC-relative relocation. */
d268 1
a268 1
     bfd_reloc_code_real_type r_type; /* Relocation type */
d270 1
a270 1
     int r_type;		/* Relocation type */
d287 1
d292 1
d306 1
a306 1
      as_fatal(_("rva not supported"));
d321 1
a321 1
      /* Fall through.   */
d331 1
a331 2
  return fix_new_internal (frag, where, size, add, sub, off,
			   pcrel, r_type);
d341 1
a341 1
  /* Don't trust memcpy() of 0 chars. */
d353 5
a357 6
/*
 * This routine records the largest alignment seen for each segment.
 * If the beginning of the segment is aligned on the worst-case
 * boundary, all of the other alignments within it will work.  At
 * least one object format really uses this info.
 */
d360 1
a360 1
     /* Segment to which alignment pertains */
d393 1
a393 1
#endif /* defined (BFD_ASSEMBLER) */
d444 2
a445 2
   info->frchainP->frch_last
     = chain_frchains_together_1 (section, info->frchainP);
d467 1
a467 1
#endif /* BFD */
d474 1
a474 1
     segT sec;
d540 3
a542 5
      /*
       * After md_convert_frag, we make the frag into a ".space 0".
       * Md_convert_frag() should set up any fixSs and constants
       * required.
       */
d571 1
a571 1
#endif /* defined (BFD_ASSEMBLER) || !defined (BFD) */
d599 2
a600 1
	/* walk to last elt */;
d697 2
a698 1
      /* ignore it */;
d717 1
a717 1
	
d741 1
a741 1
	
d857 1
a857 1
	   the section when it calls resolve_symbol_value. */
d869 1
a869 1
#if 1/*def RELOC_REQUIRES_SYMBOL*/
d878 3
a880 1
/*	fixp->fx_addsy->sy_used_in_reloc = 1; */
d914 1
a914 1
  memset ((char*)relocs, 0, n * sizeof (arelent*));
d1015 2
a1016 2
          relocs[i++] = reloc[j];
          assert(i <= n);
d1024 1
a1024 1
        {
d1029 1
a1029 1
          switch (s)
d1041 1
a1041 1
        }
d1104 1
a1104 1
      || ! (bfd_get_section_flags (abfd, sec) & SEC_HAS_CONTENTS))
d1137 1
a1137 1
	  if (fill_size > sizeof(buf))
d1139 1
a1139 1
	      /* Do it the old way. Can this ever happen? */
d1149 2
a1150 1
		      as_perror (_("FATAL: Can't write %s"), stdoutput->filename);
d1170 1
a1170 1
		  n_per_buf = sizeof(buf)/fill_size;
d1172 1
a1172 1
		    memcpy(bufp, fill_literal, fill_size);
d1177 3
a1179 3
		  x = bfd_set_section_contents (stdoutput, sec,
						buf, (file_ptr) offset,
						(bfd_size_type) n_per_buf * fill_size);
d1218 1
a1218 1
#endif /* BFD_ASSEMBLER || (! BFD && ! OBJ_AOUT) */
a1228 3
  /*
   * Now the addresses of frags are correct within the segment.
   */
d1230 1
d1235 5
a1239 7
  /*
   * Join the 2 segments into 1 huge segment.
   * To do this, re-compute every rn_address in the SEG_DATA frags.
   * Then join the data frags after the text frags.
   *
   * Determine a_data [length of data segment].
   */
d1244 2
a1245 1
      know ((text_last_frag->fr_type == rs_fill) && (text_last_frag->fr_offset == 0));
d1249 1
a1249 1
      slide = H_GET_TEXT_SIZE (&headers);	/* & in file of the data segment. */
d1261 1
a1261 3
	{
	  fragP->fr_address += slide;
	}			/* for each data frag */
d1282 1
a1282 1
#else /* ! OBJ_BOUT */
d1286 1
a1286 1
#endif /* ! OBJ_BOUT */
d1288 1
a1288 1
  /* Slide all the frags */
d1294 1
a1294 3
	{
	  fragP->fr_address += slide;
	}			/* for each bss frag */
d1303 1
a1303 1
#endif /* ! BFD_ASSEMBLER && ! BFD */
d1353 1
a1353 1
  
d1357 1
a1357 1
#endif /* BFD_ASSEMBLER && OBJ_COFF && !TE_PE */
a1393 1

d1406 1
a1406 1
  fragS *fragP;			/* Track along all frags. */
d1435 1
a1435 1
     and if so -- fix it up so that it can be program entry point. */
d1437 1
a1437 1
#endif /* OBJ_VMS */
d1488 1
a1488 1
#endif /* BFD_ASSEMBLER */
d1499 17
a1515 21
  /*
   *
   * Crawl the symbol chain.
   *
   * For each symbol whose value depends on a frag, take the address of
   * that frag and subsume it into the value of the symbol.
   * After this, there is just one way to lookup a symbol value.
   * Values are left in their final state for object file emission.
   * We adjust the values of 'L' local symbols, even if we do
   * not intend to emit them to the object file, because their values
   * are needed for fix-ups.
   *
   * Unless we saw a -L flag, remove all symbols that begin with 'L'
   * from the symbol chain.  (They are still pointed to by the fixes.)
   *
   * Count the remaining symbols.
   * Assign a symbol number to each symbol.
   * Count the number of string-table chars we will emit.
   * Put this info into the headers as appropriate.
   *
   */
d1526 4
a1529 6
  /*
   * Addresses of frags now reflect addresses we use in the object file.
   * Symbol values are correct.
   * Scan the frags, converting any ".org"s and ".align"s to ".fill"s.
   * Also converting any machine-dependent frags using md_convert_frag();
   */
d1554 1
a1554 1
#endif /* ! BFD_ASSEMBLER */
d1575 2
a1576 2
		       lie->word_goes_here - lie->frag->fr_literal,
		       2, &exp);
d1596 3
a1598 3
#endif /* TC_NS32K */
#endif /* TC_SPARC|TC_A29K|NEED_FX_R_TYPE */
#endif /* BFD_ASSEMBLER */
d1617 3
a1619 1
	for (untruth = lie; untruth && untruth->dispfrag == fragP; untruth = untruth->next_broken_word)
d1624 2
a1625 1
	table_addr = lie->dispfrag->fr_address + (table_ptr - lie->dispfrag->fr_literal);
d1630 2
a1631 1
	md_create_short_jump (table_ptr, from_addr, to_addr, lie->dispfrag, lie->add);
d1635 3
a1637 1
	for (m = 0; lie && lie->dispfrag == fragP; m++, lie = lie->next_broken_word)
d1641 2
a1642 2
	    /* Patch the jump table */
	    /* This is the offset from ??? to table_ptr+0 */
d1651 3
a1653 1
	    for (untruth = lie->next_broken_word; untruth && untruth->dispfrag == fragP; untruth = untruth->next_broken_word)
d1659 2
a1660 2
	    /* Install the long jump */
	    /* this is a long jump from table_ptr+0 to the final target */
d1666 2
a1667 1
	    md_create_long_jump (table_ptr, from_addr, to_addr, lie->dispfrag, lie->add);
d1673 1
a1673 1
#endif /* not WORKING_DOT_WORD */
d1677 1
a1677 1
  {				/* not vms */
d1680 2
a1681 4
    /*
     * Scan every FixS performing fixups. We had to wait until now to do
     * this because md_convert_frag() may have made some fixSs.
     */
d1690 1
a1690 1
    /* FIXME move this stuff into the pre-write-hook */
d1694 1
a1694 1
    obj_pre_write_hook (&headers);	/* extra coff stuff */
d1703 2
a1704 1
    know ((next_object_file_charP - the_object_file) == H_GET_HEADER_SIZE (&headers));
d1706 1
a1706 3
    /*
     * Emit code.
     */
d1715 2
a1716 1
	append (&next_object_file_charP, fragP->fr_literal, (unsigned long) fragP->fr_fix);
d1722 3
a1724 7
	  {
	    append (&next_object_file_charP, fill_literal, (unsigned long) fill_size);
	  }			/* for each  */

      }				/* for each code frag. */

    know ((next_object_file_charP - the_object_file) == (H_GET_HEADER_SIZE (&headers) + H_GET_TEXT_SIZE (&headers) + H_GET_DATA_SIZE (&headers)));
d1726 13
a1738 5
    /*
     * Emit relocations.
     */
    obj_emit_relocations (&next_object_file_charP, text_fix_root, (relax_addressT) 0);
    know ((next_object_file_charP - the_object_file) == (H_GET_HEADER_SIZE (&headers) + H_GET_TEXT_SIZE (&headers) + H_GET_DATA_SIZE (&headers) + H_GET_TEXT_RELOCATION_SIZE (&headers)));
d1741 17
a1757 13
     * first data fragment, not end of last text fragment:  alignment of the
     * start of the data segment may place a gap between the segments.
     */
    obj_emit_relocations (&next_object_file_charP, data_fix_root, data0_frchainP->frch_root->fr_address);
#else /* TC_I960 */
    obj_emit_relocations (&next_object_file_charP, data_fix_root, text_last_frag->fr_address);
#endif /* TC_I960 */

    know ((next_object_file_charP - the_object_file) == (H_GET_HEADER_SIZE (&headers) + H_GET_TEXT_SIZE (&headers) + H_GET_DATA_SIZE (&headers) + H_GET_TEXT_RELOCATION_SIZE (&headers) + H_GET_DATA_RELOCATION_SIZE (&headers)));

    /*
     * Emit line number entries.
     */
d1759 7
a1765 1
    know ((next_object_file_charP - the_object_file) == (H_GET_HEADER_SIZE (&headers) + H_GET_TEXT_SIZE (&headers) + H_GET_DATA_SIZE (&headers) + H_GET_TEXT_RELOCATION_SIZE (&headers) + H_GET_DATA_RELOCATION_SIZE (&headers) + H_GET_LINENO_SIZE (&headers)));
d1767 1
a1767 3
    /*
     * Emit symbols.
     */
d1769 8
a1776 5
    know ((next_object_file_charP - the_object_file) == (H_GET_HEADER_SIZE (&headers) + H_GET_TEXT_SIZE (&headers) + H_GET_DATA_SIZE (&headers) + H_GET_TEXT_RELOCATION_SIZE (&headers) + H_GET_DATA_RELOCATION_SIZE (&headers) + H_GET_LINENO_SIZE (&headers) + H_GET_SYMBOL_TABLE_SIZE (&headers)));

    /*
     * Emit strings.
     */
d1778 1
d1780 1
a1780 3
      {
	obj_emit_strings (&next_object_file_charP);
      }				/* only if we have a string table */
d1787 1
a1787 1
    /* Write the data to the file */
d1791 3
a1793 5
  }				/* non vms output */
#else /* OBJ_VMS */
  /*
   *	Now do the VMS-dependent part of writing the object file
   */
d1798 2
a1799 2
#endif /* OBJ_VMS */
#else /* BFD_ASSEMBLER */
d1821 1
a1821 1
  bfd_map_over_sections (stdoutput, adjust_reloc_syms, (char *)0);
d1845 2
a1846 1
	      const char *name2 = decode_local_label_name ((char *)S_GET_NAME (symp));
d1903 1
a1906 1

d1960 1
a1960 1
#endif /* BFD_ASSEMBLER */
d1962 1
a1962 14
#endif /* ! BFD */

/*
 *			relax_segment()
 *
 * Now we have a segment, not a crowd of sub-segments, we can make fr_address
 * values.
 *
 * Relax the frags.
 *
 * After this, all frags in this segment have addresses that are correct
 * within the segment. Since segments live in different file addresses,
 * these frag addresses may not be the same as final object-file addresses.
 */
d2016 1
a2016 1
      target +=	S_GET_VALUE (symbolP) + symbol_get_frag (symbolP)->fr_address;
d2036 3
a2038 3
  /* Currently only the ns32k family needs this */
  aim += TC_PCREL_ADJUST(fragP);
/*#else*/
d2041 3
a2043 1
/*  assert (fragP->fr_targ.ns32k.pcrel_adjust == 0);*/
d2045 1
a2045 1
#ifdef md_prepare_relax_scan /* formerly called M68K_AIM_KLUDGE */
d2051 1
a2051 1
      /* Look backwards. */
d2057 1
a2057 1
	    /* Grow to next state. */
d2065 1
a2065 1
      /* Look forwards. */
d2071 1
a2071 1
	    /* Grow to next state. */
d2084 1
a2084 1
#endif /* defined (TC_GENERIC_RELAX_TABLE) */
d2090 2
a2091 2
     register relax_addressT address;	/* Address now. */
     register int alignment;	/* Alignment (binary). */
d2107 10
d2127 1
a2127 1
  /* In case md_estimate_size_before_relax() wants to make fixSs. */
d2173 1
a2173 1
	  /* Broken words don't concern us yet */
d2179 1
a2179 1
	  /* Initial guess is always 1; doing otherwise can result in 
d2191 2
a2192 2
	}			/* switch(fr_type) */
    }				/* for each frag in the segment */
d2196 4
a2199 5
    long stretch;	/* May be any size, 0 or negative. */
    /* Cumulative number of addresses we have */
    /* relaxed this pass. */
    /* We may have relaxed more than one address. */
    long stretched;	/* Have we stretched on this pass? */
d2207 1
d2222 1
a2222 1
	      case rs_fill:	/* .fill never relaxes. */
d2287 1
a2287 1
		}		/* case rs_broken_word */
d2329 1
a2329 1
		    }		/* if we have a symbol */
d2338 1
a2338 1
			 .org backwards. */
d2351 2
a2352 1
		  growth -= stretch;	/* This is an absolute growth factor */
d2384 1
a2384 1
#endif /* TC_GENERIC_RELAX_TABLE */
d2413 1
a2413 1
	  }			/* For each frag in the segment. */
d2415 2
a2416 2
    while (stretched);		/* Until nothing further to relax. */
  }				/* do_relax */
d2418 5
a2422 9
  /*
   * We now have valid fr_address'es for each frag.
   */

  /*
   * All fr_address's are correct, relative to their own segment.
   * We have made all the fixS we will ever make.
   */
}				/* relax_segment() */
d2444 1
a2444 1
     segT this_segment_type;	/* N_TYPE bits for segment. */
a2473 1

a2478 1

d2518 1
a2518 1
	      /* It's just -sym */
d2541 1
a2541 1
		 something different for N_UNDF. */
d2548 1
a2548 1
#endif /* TC_I960 */
d2553 1
a2553 1
	      pcrel = 0;	/* No further pcrel processing. */
d2567 1
a2567 1
	      /* Different segments in subtraction. */
d2576 5
a2580 3
#if 0 /* Do this even if it's already described as pc-relative.  For example,
	 on the m68k, an operand of "pc@@(foo-.-2)" should address "foo" in a
	 pc-relative mode.  */
d2630 3
a2632 5
	      /*
	       * This fixup was made when the symbol's segment was
	       * SEG_UNKNOWN, but it is now in the local segment.
	       * So we know how to do the address without relocation.
	       */
d2638 1
a2638 1
		 below a no-op. */
d2640 1
a2640 1
#endif /* TC_I960 */
d2644 2
a2645 1
	      pcrel = 0;	/* Lie. Don't want further pcrel processing. */
d2664 1
a2664 1
#endif /* TC_I960 */
d2687 3
a2689 4
		       * 13-bit displacement and are only to be used
		       * for local branches: flag as error, don't generate
		       * relocation.
		       */
d2695 2
a2696 2
		    }		/* COBR */
#endif /* TC_I960 */
d2702 2
a2703 2
#endif /* TE_I386AIX */
#endif /* OBJ_COFF */
d2767 1
a2767 1
	      mask--;		/* set all bits to one */
d2780 1
a2780 1
		} /* generic error checking */
d2794 1
a2794 1
	}			/* not a bit fix */
d2804 1
a2804 1
    }				/* For each fixS in this segment. */
d2849 1
a2849 1
/* for debugging */
a2901 2

/* end of write.c */
@


1.13
log
@Set vma and lma for segment when using the BFD_ASSEMBLER for COFF format files.
@
text
@d135 1
a135 1
#if defined (BFD_ASSEMBLER) && defined (OBJ_COFF) && !defined (TE_PE)
d1354 1
a1354 1
#if defined (BFD_ASSEMBLER) && defined (OBJ_COFF) && !defined (TE_PE)
d1500 1
a1500 1
#if defined (BFD_ASSEMBLER) && defined (OBJ_COFF) && !defined (TE_PE)
d1502 3
a1504 2
     sections and set their vma and lma. The !BFD_ASSEMBLER case takes
     care of this in write_object_file in config/obj-coff.c.  */
@


1.12
log
@	* write.c (write_object_file) [! WORKING_DOT_WORD]: If defined,
	call TC_CHECK_ADJUSTED_BROKEN_DOT_WORD for each word after
	adjustments.
@
text
@d135 3
d1354 14
d1499 7
@


1.11
log
@	* write.c (write_relocs): Call SET_SECTION_RELOCS if it is
	defined.
	* config/obj-coff.h (SET_SECTION_RELOCS): Define.
	* doc/internals.texi (Object format backend): Document
	SET_SECTION_RELOCS.
@
text
@d1632 3
@


1.10
log
@	* write.c (dump_section_relocs): Call print_symbol_value_1 to
	print the symbol, rather than printing it here.

1999-09-11  Donn Terry  <donn@@interix.com>

	* write.c (adjust_reloc_syms): Print adjusted fixup.
@
text
@d1071 4
@


1.9
log
@
Fix an overflow checking bug uncovered when a 32 bit target is compiled
with a 64 bit bfd.
@
text
@d648 1
a648 1
     bfd *abfd;
d663 6
a668 1
      if (s)
d670 2
a671 11
	  fprintf (stream, "  %08x: %s(%s", fixp, S_GET_NAME (s),
		   s->bsym->section->name);
	  if (s->bsym->flags & BSF_SECTION_SYM)
	    {
	      fprintf (stream, " section sym");
	      if (S_GET_VALUE (s))
		fprintf (stream, "+%x", S_GET_VALUE (s));
	    }
	  else
	    fprintf (stream, "+%x", S_GET_VALUE (s));
	  fprintf (stream, ")+%x\n", fixp->fx_offset);
a672 2
      else
	fprintf (stream, "  %08x: type %d no sym\n", fixp, fixp->fx_r_type);
d863 4
@


1.8
log
@	* write.c (cvt_frag_to_fill): Use frag file and line in rs_org
	error message.
	(relax_segment): Likewise.  After giving a rs_org error, convert
	the frag to rs_align to avoid cascading errors.
@
text
@d2736 1
a2736 1
	      valueT mask, hibit;
a2737 1
	      /* set all bits to one */
d2739 3
a2741 14
	      mask--;
	      /* Technically, combining these produces an undefined result
		 if size is sizeof (valueT), though I think these two
		 half-way operations should both be defined.  And the
		 compiler should be able to combine them if it's valid on
		 the host architecture.  */
	      mask <<= size * 4;
	      mask <<= size * 4;
	      hibit = (valueT) 1 << (size * 8 - 1);
	      if (((add_number & mask) != 0
		   || (fixP->fx_signed
		       && (add_number & hibit) != 0))
		  && ((add_number & mask) != mask
		      || (add_number & hibit) == 0))
@


1.7
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Fill in structure initializations.  Add variable
	initializations.  Add casts.
	* dwarf2dbg.c (print_stats): Change i to size_t.
	* listing.c (listing_listing): Change list_line to unsigned int.
@
text
@d501 3
a503 2
	  as_bad (_("attempt to .org/.space backwards? (%ld)"),
		  (long) fragP->fr_offset);
d2306 10
a2315 2
		      as_bad (_("attempt to .org backwards ignored"));
		      growth = 0;
@


1.6
log
@	* write.c (adjust_reloc_syms): Rather than never reducing reloc
	which refer to symbols in linkonce sections, permit reducing the
	relocs if the symbol is local.
@
text
@d385 1
a385 1
     bfd *abfd;
d436 1
a436 1
     bfd *abfd;			/* unused */
d438 1
a438 1
     PTR xxx;			/* unused */
d581 1
a581 1
     PTR xxx;
d691 1
a691 1
     bfd *abfd;
d693 1
a693 1
     PTR xxx;
d892 1
a892 1
     PTR xxx;
d1091 1
a1091 1
     bfd *abfd;
d1093 1
a1093 1
     PTR xxx;
d2772 2
a2773 1
    skip: ;
@


1.5
log
@	* subsegs.c (subseg_text_p): New function.
	* as.h (subseg_text_p): Declare.
	* read.c (do_align): Use subseg_text_p to set the default fill.
	* write.c (subsegs_finish): Likewise.
	* config/obj-coff.c (write_object_file): Likewise.
	* config/tc-i386.h (md_maybe_text): Don't define.
	(md_do_align): Use subseg_text_p to set the default fill.
	* config/tc-m32r.c (m32r_do_align): Likewise.
	* config/tc-sh.c (sh_do_align): Likewise.
	* config/tc-sparc.h (md_do_align): Likewise.
@
text
@d783 5
a787 5
	/* Don't try to reduce relocs which refer to .linkonce
           sections.  It can lead to confusion when a debugging
           section refers to a .linkonce section.  I hope this will
           always be correct.  */
	if (symsec != sec)
@


1.4
log
@1999-06-11  Martin Dorey  <mdorey@@madge.com>
	* write.c (fixup_segment): Don't add symbol value for i960 ELF.
	* config/tc-i960.c (s_leafproc): Don't call tc_set_bal_of_cal if
	OBJ_ELF.
	(md_apply_fix): Simplify BFD_ASSEMBLER handling.
@
text
@d1375 2
a1376 1
		  NOP_OPCODE, 0);
@


1.3
log
@	Add support for storing local symbols in a small structure to save
	memory when assembling large files.
	* as.h: Don't include struc-symbol.h.
	(symbolS): Add typedef.
	* symbols.c: Include struc-symbol.h.
	(local_hash): New static variable.
	(save_symbol_name): New static function, from symbol_create.
	(symbol_create): Call save_symbol_name.
	(local_symbol_count): New static variable.
	(local_symbol_conversion_count): Likewise.
	(LOCAL_SYMBOL_CHECK): Define.
	(local_symbol_make): New static function.
	(local_symbol_convert): New static function.
	(colon): Handle local symbols.  Create local symbol for local
	label name.
	(symbol_table_insert): Handle local symbols.
	(symbol_find_or_make): Create local symbol for local label name.
	(symbol_find_base): Check for local symbol.
	(symbol_append, symbol_insert): Check for local symbols.
	(symbol_clear_list_pointers, symbol_remove): Likewise.
	(verify_symbol_chain): Likewise.
	(copy_symbol_attributes): Likewise.
	(resolve_symbol_value): Handle local symbols.
	(resolve_local_symbol): New static function.
	(resolve_local_symbol_values): New function.
	(S_GET_VALUE, S_SET_VALUE): Handle local symbols.
	(S_IS_FUNCTION, S_IS_EXTERNAL, S_IS_WEAK, S_IS_COMMON): Likewise.
	(S_IS_DEFINED, S_IS_DEBUG, S_IS_LOCAL, S_GET_NAME): Likewise.
	(S_GET_SEGMENT, S_SET_SEGMENT, S_SET_EXTERNAL): Likewise.
	(S_CLEAR_EXTERNAL, S_SET_WEAK, S_SET_NAME): Likewise.
	(symbol_previous, symbol_next): New functions.
	(symbol_get_value_expression): Likewise.
	(symbol_set_value_expression): Likewise.
	(symbol_set_frag, symbol_get_frag): Likewise.
	(symbol_mark_used, symbol_clear_used, symbol_used_p): Likewise.
	(symbol_mark_used_in_reloc): Likewise.
	(symbol_clear_used_in_reloc, symbol_used_in_reloc_p): Likewise.
	(symbol_mark_mri_common, symbol_clear_mri_common): Likewise.
	(symbol_mri_common_p): Likewise.
	(symbol_mark_written, symbol_clear_written): Likewise.
	(symbol_written_p): Likewise.
	(symbol_mark_resolved, symbol_resolved_p): Likewise.
	(symbol_section_p, symbol_equated_p): Likewise.
	(symbol_constant_p): Likewise.
	(symbol_get_bfdsym, symbol_set_bfdsym): Likewise.
	(symbol_get_obj, symbol_set_obj): Likewise.
	(symbol_get_tc, symbol_set_tc): Likewise.
	(symbol_begin): Initialize local_hash.
	(print_symbol_value_1): Handle local symbols.
	(symbol_print_statistics): Print local symbol statistics.
	* symbols.h: Include "struc-symbol.h" if not BFD_ASSEMBLER.
	Declare new symbols.c functions.  Move many declarations here from
	struc-symbol.h.
	(SYMBOLS_NEED_BACKPOINTERS): Define if needed.
	* struc-symbol.h (SYMBOLS_NEED_BACKPOINTERS): Don't set.
	(struct symbol): Move bsym to make it clearly the first field.
	Remove TARGET_SYMBOL_FIELDS.
	(symbolS): Don't typedef.
	(struct broken_word): Remove.
	(N_TYPE_seg, seg_N_TYPE): Move to symbol.h.
	(SEGMENT_TO_SYMBOL_TYPE, N_REGISTER): Likewise.
	(symbol_clear_list_pointers): Likewise.
	(symbol_insert, symbol_remove): Likewise.
	(symbol_previous, symbol_append): Likewise.
	(verify_symbol_chain, verify_symbol_chain_2): Likewise.
	(struct local_symbol): Define.
	(local_symbol_converted_p, local_symbol_mark_converted): Define.
	(local_symbol_resolved_p, local_symbol_mark_resolved): Define.
	(local_symbol_get_frag, local_symbol_set_frag): Define.
	(local_symbol_get_real_symbol): Define.
	(local_symbol_set_real_symbol): Define.
	Define.
	* write.c (write_object_file): Call resolve_local_symbol_values.
	* config/obj-ecoff.h (OBJ_SYMFIELD_TYPE): Define.
	(TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-elf.h (OBJ_SYMFIELD_TYPE): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	* config/obj-multi.h (struct elf_obj_sy): Add local field.  If
	ECOFF_DEBUGGING, add ECOFF fields.
	(ELF_TARGET_SYMBOL_FIELDS, TARGET_SYMBOL_FIELDS): Don't define.
	(ECOFF_DEBUG_TARGET_SYMBOL_FIELDS): Don't define.
	* config/tc-mcore.h: Don't include struc-symbol.h.
	(TARGET_SYMBOL_FIELDS): Don't define.
	(struct mcore_tc_sy): Define.
	(TC_SYMFIELD_TYPE): Define.
	* Many files: Use symbolS instead of struct symbol.  Use new
	accessor functions rather than referring to symbolS fields
	directly.
	* read.c (s_mri_common): Don't add in value of line_label.
	* config/tc-mips.c (md_apply_fix): Correct parenthesization when
	checking for SEC_LINK_ONCE.
	* config/tc-sh.h (sh_fix_adjustable): Declare.
@
text
@d2674 1
d2677 1
@


1.2
log
@/
Move bitfield overflow checks to after the md_apply_fix call in
fixup_segment so that md_apply_fix has a chance to modify value.
Handle 8 and 16-bit pcrel relocs for i386.
Prototypes and other minor code cleanups.
@
text
@d2 1
a2 1
   Copyright (C) 1986, 87, 90, 91, 92, 93, 94, 95, 96, 97, 1998
d722 1
a722 1
	if (sym != NULL && ! sym->sy_resolved)
d725 1
a725 1
	if (fixp->fx_subsy != NULL && ! fixp->fx_subsy->sy_resolved)
d730 1
a730 1
	if (sym != NULL && sym->sy_value.X_op == O_symbol
d733 2
a734 2
	    fixp->fx_offset += sym->sy_value.X_add_number;
	    sym = sym->sy_value.X_add_symbol;
d738 1
a738 1
	if (sym != NULL && sym->sy_mri_common)
d755 1
a755 1
		fixp->fx_addsy->sy_used_in_reloc = 1;
d758 1
a758 1
		  fixp->fx_subsy->sy_used_in_reloc = 1;
d772 1
a772 1
	    fixp->fx_addsy->sy_used_in_reloc = 1;
d778 1
a778 1
	      fixp->fx_subsy->sy_used_in_reloc = 1;
d808 1
a808 1
		fixp->fx_addsy->sy_used_in_reloc = 1;
d811 1
a811 1
		  fixp->fx_subsy->sy_used_in_reloc = 1;
d819 1
a819 1
	if (sym->bsym->flags & BSF_SECTION_SYM)
d821 1
a821 1
	    fixp->fx_addsy->sy_used_in_reloc = 1;
d832 1
a832 1
	    fixp->fx_addsy->sy_used_in_reloc = 1;
d842 1
a842 1
	    fixp->fx_addsy->sy_used_in_reloc = 1;
d853 1
a853 1
	    fixp->fx_addsy->sy_used_in_reloc = 1;
d867 1
a867 1
	fixp->fx_addsy->sy_used_in_reloc = 1;
d934 1
a934 1
      while (sym->sy_value.X_op == O_symbol
d941 1
a941 1
	  n = sym->sy_value.X_add_symbol;
d944 1
a944 1
	  fixp->fx_offset += sym->sy_value.X_add_number;
d1007 1
a1007 1
      while (sym->sy_value.X_op == O_symbol
d1009 1
a1009 1
	sym = sym->sy_value.X_add_symbol;
d1336 2
a1337 2
	  asympp[i] = symp->bsym;
	  symp->written = 1;
d1626 1
a1626 1
	    to_addr -= lie->sub->sy_frag->fr_address;
d1640 1
a1640 1
	    to_addr += lie->add->sy_frag->fr_address;
d1773 1
a1773 2
	if (!symp->sy_resolved)
	  resolve_symbol_value (symp, 1);
d1775 1
d1798 1
a1798 1
	  if (symp->sy_mri_common)
d1820 1
a1820 13
	  if (! symp->sy_resolved)
	    {
	      if (symp->sy_value.X_op == O_constant)
		{
		  /* This is the normal case; skip the call.  */
		  S_SET_VALUE (symp,
			       (S_GET_VALUE (symp)
				+ symp->sy_frag->fr_address));
		  symp->sy_resolved = 1;
		}
	      else
		resolve_symbol_value (symp, 1);
	    }
d1824 1
a1824 1
	  if (symp->sy_value.X_op == O_symbol
d1840 2
a1841 2
		  symp->bsym->flags,
		  segment_name (symp->bsym->section));
d1848 1
a1848 1
	  if (! punt || symp->sy_used_in_reloc)
d1858 1
a1858 1
	       && (symp->bsym->flags & BSF_SECTION_SYM) != 0)
d1864 1
a1864 1
		  && ! symp->sy_used_in_reloc))
d1875 1
a1875 1
	  if (! symp->sy_resolved)
d1879 1
a1879 1
	      symp->sy_resolved = 1;
d1884 1
a1884 1
	  symp->bsym->value = S_GET_VALUE (symp);
d1993 1
a1993 3
      target +=
	S_GET_VALUE (symbolP)
	  + symbolP->sy_frag->fr_address;
d2004 2
a2005 2
      if (symbolP->sy_frag->fr_address >= was_address
	  && is_dnrange (fragP, symbolP->sy_frag))
d2214 1
a2214 1
		      offset = (lie->add->sy_frag->fr_address
d2217 1
a2217 1
				- (lie->sub->sy_frag->fr_address
d2239 4
a2242 2
			    if ((untruth->add->sy_frag == lie->add->sy_frag)
				&& S_GET_VALUE (untruth->add) == S_GET_VALUE (lie->add))
d2292 2
a2293 2
		      target += S_GET_VALUE (symbolP)
			+ symbolP->sy_frag->fr_address;
d2316 1
a2316 1
		    if (symbolP->sy_frag != &zero_address_frag
d2456 1
a2456 1
	  && add_symbolP->sy_mri_common)
d2461 2
a2462 1
	  add_symbolP = fixP->fx_addsy = add_symbolP->sy_value.X_add_symbol;
d2694 1
a2694 1
	      fixP->fx_addsy->sy_used_in_reloc = 1;
@


1.1
log
@Initial revision
@
text
@d2710 21
a2778 20
      if (!fixP->fx_done)
	{
#ifdef MD_APPLY_FIX3
	  md_apply_fix3 (fixP, &add_number, this_segment_type);
#else
#ifdef BFD_ASSEMBLER
	  md_apply_fix (fixP, &add_number);
#else
	  md_apply_fix (fixP, add_number);
#endif
#endif

#ifndef TC_HANDLES_FX_DONE
	  /* If the tc-* files haven't been converted, assume it's handling
	     it the old way, where a null fx_addsy means that the fix has
	     been applied completely, and no further work is needed.  */
	  if (fixP->fx_addsy == 0 && fixP->fx_pcrel == 0)
	    fixP->fx_done = 1;
#endif
	}
d2828 1
a2828 1
  fprintf (stderr, "fixups: %d\n", n_fixups);
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

