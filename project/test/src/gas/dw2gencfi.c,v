head	1.58;
access;
symbols
	binutils-2_24-branch:1.58.0.2
	binutils-2_24-branchpoint:1.58
	binutils-2_21_1:1.49
	binutils-2_23_2:1.57
	binutils-2_23_1:1.57
	binutils-2_23:1.57
	binutils-2_23-branch:1.57.0.6
	binutils-2_23-branchpoint:1.57
	binutils-2_22_branch:1.57.0.4
	binutils-2_22:1.57
	binutils-2_22-branch:1.57.0.2
	binutils-2_22-branchpoint:1.57
	binutils-2_21:1.49
	binutils-2_21-branch:1.49.0.2
	binutils-2_21-branchpoint:1.49
	binutils-2_20_1:1.42.4.2
	binutils-2_20:1.42.4.2
	binutils-arc-20081103-branch:1.39.0.4
	binutils-arc-20081103-branchpoint:1.39
	binutils-2_20-branch:1.42.0.4
	binutils-2_20-branchpoint:1.42
	dje-cgen-play1-branch:1.42.0.2
	dje-cgen-play1-branchpoint:1.42
	arc-20081103-branch:1.39.0.2
	arc-20081103-branchpoint:1.39
	binutils-2_19_1:1.36.2.4
	binutils-2_19:1.36.2.3
	binutils-2_19-branch:1.36.0.2
	binutils-2_19-branchpoint:1.36
	binutils-2_18:1.32
	binutils-2_18-branch:1.32.0.2
	binutils-2_18-branchpoint:1.32
	binutils-csl-coldfire-4_1-32:1.28
	binutils-csl-sourcerygxx-4_1-32:1.28
	binutils-csl-innovasic-fido-3_4_4-33:1.28
	binutils-csl-sourcerygxx-3_4_4-32:1.22
	binutils-csl-coldfire-4_1-30:1.28
	binutils-csl-sourcerygxx-4_1-30:1.28
	binutils-csl-coldfire-4_1-28:1.28
	binutils-csl-sourcerygxx-4_1-29:1.28
	binutils-csl-sourcerygxx-4_1-28:1.28
	binutils-csl-arm-2006q3-27:1.28
	binutils-csl-sourcerygxx-4_1-27:1.28
	binutils-csl-arm-2006q3-26:1.28
	binutils-csl-sourcerygxx-4_1-26:1.28
	binutils-csl-sourcerygxx-4_1-25:1.28
	binutils-csl-sourcerygxx-4_1-24:1.28
	binutils-csl-sourcerygxx-4_1-23:1.28
	binutils-csl-sourcerygxx-4_1-21:1.28
	binutils-csl-arm-2006q3-21:1.28
	binutils-csl-sourcerygxx-4_1-22:1.28
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.28
	binutils-csl-sourcerygxx-4_1-20:1.28
	binutils-csl-arm-2006q3-19:1.28
	binutils-csl-sourcerygxx-4_1-19:1.28
	binutils-csl-sourcerygxx-4_1-18:1.28
	binutils-csl-renesas-4_1-9:1.28
	binutils-csl-sourcerygxx-3_4_4-25:1.22
	binutils-csl-renesas-4_1-8:1.28
	binutils-csl-renesas-4_1-7:1.28
	binutils-csl-renesas-4_1-6:1.28
	binutils-csl-sourcerygxx-4_1-17:1.28
	binutils-csl-sourcerygxx-4_1-14:1.28
	binutils-csl-sourcerygxx-4_1-15:1.28
	binutils-csl-sourcerygxx-4_1-13:1.28
	binutils-2_17:1.28
	binutils-csl-sourcerygxx-4_1-12:1.28
	binutils-csl-sourcerygxx-3_4_4-21:1.28
	binutils-csl-wrs-linux-3_4_4-24:1.22
	binutils-csl-wrs-linux-3_4_4-23:1.22
	binutils-csl-sourcerygxx-4_1-9:1.28
	binutils-csl-sourcerygxx-4_1-8:1.28
	binutils-csl-sourcerygxx-4_1-7:1.28
	binutils-csl-arm-2006q1-6:1.28
	binutils-csl-sourcerygxx-4_1-6:1.28
	binutils-csl-wrs-linux-3_4_4-22:1.22
	binutils-csl-coldfire-4_1-11:1.28
	binutils-csl-sourcerygxx-3_4_4-19:1.28
	binutils-csl-coldfire-4_1-10:1.28
	binutils-csl-sourcerygxx-4_1-5:1.28
	binutils-csl-sourcerygxx-4_1-4:1.28
	binutils-csl-wrs-linux-3_4_4-21:1.22
	binutils-csl-morpho-4_1-4:1.28
	binutils-csl-sourcerygxx-3_4_4-17:1.28
	binutils-csl-wrs-linux-3_4_4-20:1.22
	binutils-2_17-branch:1.28.0.4
	binutils-2_17-branchpoint:1.28
	binutils-csl-2_17-branch:1.28.0.2
	binutils-csl-2_17-branchpoint:1.28
	binutils-csl-gxxpro-3_4-branch:1.22.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.22
	binutils-2_16_1:1.22
	binutils-csl-arm-2005q1b:1.22
	binutils-2_16:1.22
	binutils-csl-arm-2005q1a:1.22
	binutils-csl-arm-2005q1-branch:1.22.0.4
	binutils-csl-arm-2005q1-branchpoint:1.22
	binutils-2_16-branch:1.22.0.2
	binutils-2_16-branchpoint:1.22
	csl-arm-2004-q3d:1.19
	csl-arm-2004-q3:1.18
	binutils-2_15:1.15.6.1
	binutils-2_15-branchpoint:1.15
	csl-arm-2004-q1a:1.16
	csl-arm-2004-q1:1.16
	binutils-2_15-branch:1.15.0.6
	cagney_bfdfile-20040213-branch:1.15.0.4
	cagney_bfdfile-20040213-branchpoint:1.15
	cagney_bigcore-20040122-branch:1.15.0.2
	cagney_bigcore-20040122-branchpoint:1.15
	csl-arm-2003-q4:1.15
	binutils_latest_snapshot:1.58;
locks; strict;
comment	@ * @;


1.58
date	2013.01.10.19.51.54;	author hjl;	state Exp;
branches;
next	1.57;

1.57
date	2011.08.07.16.32.20;	author rth;	state Exp;
branches;
next	1.56;

1.56
date	2011.05.10.02.36.41;	author amodra;	state Exp;
branches;
next	1.55;

1.55
date	2011.05.09.13.17.56;	author pbrook;	state Exp;
branches;
next	1.54;

1.54
date	2011.05.07.05.37.54;	author amodra;	state Exp;
branches;
next	1.53;

1.53
date	2011.05.05.13.11.36;	author amodra;	state Exp;
branches;
next	1.52;

1.52
date	2011.04.26.15.28.07;	author nickc;	state Exp;
branches;
next	1.51;

1.51
date	2011.02.16.16.51.23;	author rth;	state Exp;
branches;
next	1.50;

1.50
date	2011.02.15.18.01.07;	author rth;	state Exp;
branches;
next	1.49;

1.49
date	2010.09.02.22.43.45;	author rth;	state Exp;
branches;
next	1.48;

1.48
date	2010.03.15.15.11.13;	author tschwinge;	state Exp;
branches;
next	1.47;

1.47
date	2010.03.15.15.08.02;	author tschwinge;	state Exp;
branches;
next	1.46;

1.46
date	2009.12.11.13.42.09;	author nickc;	state Exp;
branches;
next	1.45;

1.45
date	2009.11.04.09.52.00;	author mkuvyrkov;	state Exp;
branches;
next	1.44;

1.44
date	2009.10.02.11.33.49;	author jakub;	state Exp;
branches;
next	1.43;

1.43
date	2009.09.11.15.27.33;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	2009.06.22.17.56.00;	author nickc;	state Exp;
branches
	1.42.4.1;
next	1.41;

1.41
date	2009.06.09.15.12.45;	author jakub;	state Exp;
branches;
next	1.40;

1.40
date	2008.11.28.21.28.28;	author jakub;	state Exp;
branches;
next	1.39;

1.39
date	2008.10.09.17.31.43;	author ebotcazou;	state Exp;
branches;
next	1.38;

1.38
date	2008.09.30.04.44.29;	author amodra;	state Exp;
branches;
next	1.37;

1.37
date	2008.09.24.23.21.04;	author rth;	state Exp;
branches;
next	1.36;

1.36
date	2008.09.07.22.54.53;	author danglin;	state Exp;
branches
	1.36.2.1;
next	1.35;

1.35
date	2008.08.21.19.49.22;	author rth;	state Exp;
branches;
next	1.34;

1.34
date	2008.02.13.10.14.37;	author jbeulich;	state Exp;
branches;
next	1.33;

1.33
date	2007.09.26.07.02.07;	author jbeulich;	state Exp;
branches;
next	1.32;

1.32
date	2007.07.03.11.01.02;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	2006.11.03.07.29.37;	author jakub;	state Exp;
branches;
next	1.30;

1.30
date	2006.11.03.07.27.38;	author jakub;	state Exp;
branches;
next	1.29;

1.29
date	2006.10.26.00.16.50;	author bje;	state Exp;
branches;
next	1.28;

1.28
date	2006.02.27.23.07.06;	author jakub;	state Exp;
branches;
next	1.27;

1.27
date	2005.11.17.08.33.36;	author jbeulich;	state Exp;
branches;
next	1.26;

1.26
date	2005.10.11.11.16.16;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2005.09.28.14.51.02;	author jbeulich;	state Exp;
branches;
next	1.24;

1.24
date	2005.08.11.01.25.20;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2005.05.05.09.12.43;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2005.02.16.05.04.09;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2004.12.16.08.57.23;	author jbeulich;	state Exp;
branches;
next	1.20;

1.20
date	2004.12.16.08.53.43;	author jbeulich;	state Exp;
branches;
next	1.19;

1.19
date	2004.10.07.15.18.09;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2004.09.09.13.32.46;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2004.05.13.14.41.18;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2004.03.07.08.51.20;	author rth;	state Exp;
branches;
next	1.15;

1.15
date	2003.08.29.20.32.55;	author jakub;	state Exp;
branches
	1.15.6.1;
next	1.14;

1.14
date	2003.08.29.20.20.17;	author jakub;	state Exp;
branches;
next	1.13;

1.13
date	2003.06.18.17.58.47;	author jakub;	state Exp;
branches;
next	1.12;

1.12
date	2003.06.11.23.16.57;	author rth;	state Exp;
branches;
next	1.11;

1.11
date	2003.06.08.03.59.44;	author rth;	state Exp;
branches;
next	1.10;

1.10
date	2003.06.05.09.23.47;	author mludvig;	state Exp;
branches;
next	1.9;

1.9
date	2003.06.05.06.53.40;	author rth;	state Exp;
branches;
next	1.8;

1.8
date	2003.06.05.05.25.38;	author rth;	state Exp;
branches;
next	1.7;

1.7
date	2003.06.02.22.48.59;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2003.05.31.19.36.44;	author rth;	state Exp;
branches;
next	1.5;

1.5
date	2003.05.27.16.52.46;	author rth;	state Exp;
branches;
next	1.4;

1.4
date	2003.05.21.11.31.07;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2003.05.20.14.31.44;	author mludvig;	state Exp;
branches;
next	1.2;

1.2
date	2003.05.20.11.35.45;	author amodra;	state Exp;
branches;
next	1.1;

1.1
date	2003.05.20.07.58.06;	author amodra;	state Exp;
branches;
next	;

1.42.4.1
date	2009.09.11.15.28.43;	author nickc;	state Exp;
branches;
next	1.42.4.2;

1.42.4.2
date	2009.10.06.10.59.08;	author gingold;	state Exp;
branches;
next	;

1.36.2.1
date	2008.09.25.21.55.51;	author rth;	state Exp;
branches;
next	1.36.2.2;

1.36.2.2
date	2008.09.29.10.45.29;	author nickc;	state Exp;
branches;
next	1.36.2.3;

1.36.2.3
date	2008.10.09.17.32.29;	author ebotcazou;	state Exp;
branches;
next	1.36.2.4;

1.36.2.4
date	2009.01.14.09.00.24;	author gingold;	state Exp;
branches;
next	;

1.15.6.1
date	2004.04.09.18.28.10;	author drow;	state Exp;
branches;
next	;


desc
@@


1.58
log
@Remove trailing white spaces on gas

	* app.c: Remove trailing white spaces.
	* as.c: Likewise.
	* as.h: Likewise.
	* cond.c: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.h: Likewise.
	* ecoff.c: Likewise.
	* input-file.c: Likewise.
	* itbl-lex.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* sb.c: Likewise.
	* subsegs.c: Likewise.
	* symbols.c: Likewise.
	* write.c: Likewise.
	* config/tc-i386.c: Likewise.
	* doc/Makefile.am: Likewise.
	* doc/Makefile.in: Likewise.
	* doc/c-aarch64.texi: Likewise.
	* doc/c-alpha.texi: Likewise.
	* doc/c-arc.texi: Likewise.
	* doc/c-arm.texi: Likewise.
	* doc/c-avr.texi: Likewise.
	* doc/c-bfin.texi: Likewise.
	* doc/c-cr16.texi: Likewise.
	* doc/c-d10v.texi: Likewise.
	* doc/c-d30v.texi: Likewise.
	* doc/c-h8300.texi: Likewise.
	* doc/c-hppa.texi: Likewise.
	* doc/c-i370.texi: Likewise.
	* doc/c-i386.texi: Likewise.
	* doc/c-i860.texi: Likewise.
	* doc/c-m32c.texi: Likewise.
	* doc/c-m32r.texi: Likewise.
	* doc/c-m68hc11.texi: Likewise.
	* doc/c-m68k.texi: Likewise.
	* doc/c-microblaze.texi: Likewise.
	* doc/c-mips.texi: Likewise.
	* doc/c-msp430.texi: Likewise.
	* doc/c-mt.texi: Likewise.
	* doc/c-s390.texi: Likewise.
	* doc/c-score.texi: Likewise.
	* doc/c-sh.texi: Likewise.
	* doc/c-sh64.texi: Likewise.
	* doc/c-tic54x.texi: Likewise.
	* doc/c-tic6x.texi: Likewise.
	* doc/c-v850.texi: Likewise.
	* doc/c-xc16x.texi: Likewise.
	* doc/c-xgate.texi: Likewise.
	* doc/c-xtensa.texi: Likewise.
	* doc/c-z80.texi: Likewise.
	* doc/internals.texi: Likewise.
@
text
@/* dw2gencfi.c - Support for generating Dwarf2 CFI information.
   Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
   Contributed by Michal Ludvig <mludvig@@suse.cz>

   This file is part of GAS, the GNU Assembler.

   GAS is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   GAS is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with GAS; see the file COPYING.  If not, write to the Free
   Software Foundation, 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include "as.h"
#include "dw2gencfi.h"
#include "subsegs.h"
#include "dwarf2dbg.h"

#ifdef TARGET_USE_CFIPOP

/* By default, use difference expressions if DIFF_EXPR_OK is defined.  */
#ifndef CFI_DIFF_EXPR_OK
# ifdef DIFF_EXPR_OK
#  define CFI_DIFF_EXPR_OK 1
# else
#  define CFI_DIFF_EXPR_OK 0
# endif
#endif

#ifndef CFI_DIFF_LSDA_OK
#define CFI_DIFF_LSDA_OK CFI_DIFF_EXPR_OK
#endif

#if CFI_DIFF_EXPR_OK == 1 && CFI_DIFF_LSDA_OK == 0
# error "CFI_DIFF_EXPR_OK should imply CFI_DIFF_LSDA_OK"
#endif

/* We re-use DWARF2_LINE_MIN_INSN_LENGTH for the code alignment field
   of the CIE.  Default to 1 if not otherwise specified.  */
#ifndef DWARF2_LINE_MIN_INSN_LENGTH
#define DWARF2_LINE_MIN_INSN_LENGTH 1
#endif

/* By default, use 32-bit relocations from .eh_frame into .text.  */
#ifndef DWARF2_FDE_RELOC_SIZE
#define DWARF2_FDE_RELOC_SIZE 4
#endif

/* By default, use a read-only .eh_frame section.  */
#ifndef DWARF2_EH_FRAME_READ_ONLY
#define DWARF2_EH_FRAME_READ_ONLY SEC_READONLY
#endif

#ifndef EH_FRAME_ALIGNMENT
#define EH_FRAME_ALIGNMENT (bfd_get_arch_size (stdoutput) == 64 ? 3 : 2)
#endif

#ifndef tc_cfi_frame_initial_instructions
#define tc_cfi_frame_initial_instructions() ((void)0)
#endif

#ifndef tc_cfi_startproc
# define tc_cfi_startproc() ((void)0)
#endif

#ifndef tc_cfi_endproc
# define tc_cfi_endproc(fde) ((void) (fde))
#endif

#ifndef DWARF2_FORMAT
#define DWARF2_FORMAT(SEC) dwarf2_format_32bit
#endif

#ifndef DWARF2_ADDR_SIZE
#define DWARF2_ADDR_SIZE(bfd) (bfd_arch_bits_per_address (bfd) / 8)
#endif

#if SUPPORT_FRAME_LINKONCE
#define CUR_SEG(structp) structp->cur_seg
#define SET_CUR_SEG(structp, seg) structp->cur_seg = seg
#define HANDLED(structp) structp->handled
#define SET_HANDLED(structp, val) structp->handled = val
#else
#define CUR_SEG(structp) NULL
#define SET_CUR_SEG(structp, seg) (void) (0 && seg)
#define HANDLED(structp) 0
#define SET_HANDLED(structp, val) (void) (0 && val)
#endif

/* Private segment collection list.  */
struct dwcfi_seg_list
{
  segT   seg;
  int    subseg;
  char * seg_name;
};

#define FRAME_NAME ".eh_frame"

static struct hash_control *dwcfi_hash;

/* Build based on segment the derived .debug_...
   segment name containing origin segment's postfix name part.  */

static char *
get_debugseg_name (segT seg, const char *base_name)
{
  const char *name;

  if (!seg)
    name = "";
  else
    {
      const char * dollar;
      const char * dot;

      name = bfd_get_section_name (stdoutput, seg);

      dollar = strchr (name, '$');
      dot = strchr (name + 1, '.');

      if (!dollar && !dot)
	name = "";
      else if (!dollar)
	name = dot;
      else if (!dot)
	name = dollar;
      else if (dot < dollar)
	name = dot;
      else
	name = dollar;
    }

  return concat (base_name, name, NULL);
}

/* Allocate a dwcfi_seg_list structure.  */

static struct dwcfi_seg_list *
alloc_debugseg_item (segT seg, int subseg, char *name)
{
  struct dwcfi_seg_list *r;

  r = (struct dwcfi_seg_list *)
    xmalloc (sizeof (struct dwcfi_seg_list) + strlen (name));
  r->seg = seg;
  r->subseg = subseg;
  r->seg_name = name;
  return r;
}

static segT
is_now_linkonce_segment (void)
{
  if ((bfd_get_section_flags (stdoutput, now_seg)
       & (SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD
	  | SEC_LINK_DUPLICATES_ONE_ONLY | SEC_LINK_DUPLICATES_SAME_SIZE
	  | SEC_LINK_DUPLICATES_SAME_CONTENTS)) != 0)
    return now_seg;
  return NULL;
}

/* Generate debug... segment with same linkonce properties
   of based segment.  */

static segT
make_debug_seg (segT cseg, char *name, int sflags)
{
  segT save_seg = now_seg;
  int save_subseg = now_subseg;
  segT r;
  flagword flags;

  r = subseg_new (name, 0);

  /* Check if code segment is marked as linked once.  */
  if (!cseg)
    flags = 0;
  else
    flags = bfd_get_section_flags (stdoutput, cseg)
      & (SEC_LINK_ONCE | SEC_LINK_DUPLICATES_DISCARD
         | SEC_LINK_DUPLICATES_ONE_ONLY | SEC_LINK_DUPLICATES_SAME_SIZE
         | SEC_LINK_DUPLICATES_SAME_CONTENTS);

  /* Add standard section flags.  */
  flags |= sflags;

  /* Apply possibly linked once flags to new generated segment, too.  */
  if (!bfd_set_section_flags (stdoutput, r, flags))
    as_bad (_("bfd_set_section_flags: %s"),
	    bfd_errmsg (bfd_get_error ()));

  /* Restore to previous segment.  */
  if (save_seg != NULL)
    subseg_set (save_seg, save_subseg);
  return r;
}

static void
dwcfi_hash_insert (const char *name, struct dwcfi_seg_list *item)
{
  const char *error_string;

  if ((error_string = hash_jam (dwcfi_hash, name, (char *) item)))
    as_fatal (_("Inserting \"%s\" into structure table failed: %s"),
	      name, error_string);
}

static struct dwcfi_seg_list *
dwcfi_hash_find (char *name)
{
  return (struct dwcfi_seg_list *) hash_find (dwcfi_hash, name);
}

static struct dwcfi_seg_list *
dwcfi_hash_find_or_make (segT cseg, const char *base_name, int flags)
{
  struct dwcfi_seg_list *item;
  char *name;

  /* Initialize dwcfi_hash once.  */
  if (!dwcfi_hash)
    dwcfi_hash = hash_new ();

  name = get_debugseg_name (cseg, base_name);

  item = dwcfi_hash_find (name);
  if (!item)
    {
      item = alloc_debugseg_item (make_debug_seg (cseg, name, flags), 0, name);

      dwcfi_hash_insert (item->seg_name, item);
    }
  else
    free (name);

  return item;
}

/* ??? Share this with dwarf2cfg.c.  */
#ifndef TC_DWARF2_EMIT_OFFSET
#define TC_DWARF2_EMIT_OFFSET  generic_dwarf2_emit_offset

/* Create an offset to .dwarf2_*.  */

static void
generic_dwarf2_emit_offset (symbolS *symbol, unsigned int size)
{
  expressionS exp;

  exp.X_op = O_symbol;
  exp.X_add_symbol = symbol;
  exp.X_add_number = 0;
  emit_expr (&exp, size);
}
#endif

struct cfi_escape_data
{
  struct cfi_escape_data *next;
  expressionS exp;
};

struct cie_entry
{
  struct cie_entry *next;
#if SUPPORT_FRAME_LINKONCE
  segT cur_seg;
#endif
  symbolS *start_address;
  unsigned int return_column;
  unsigned int signal_frame;
  unsigned char per_encoding;
  unsigned char lsda_encoding;
  expressionS personality;
  struct cfi_insn_data *first, *last;
};

/* List of FDE entries.  */

struct fde_entry *all_fde_data;
static struct fde_entry **last_fde_data = &all_fde_data;

/* List of CIEs so that they could be reused.  */
static struct cie_entry *cie_root;

/* Stack of old CFI data, for save/restore.  */
struct cfa_save_data
{
  struct cfa_save_data *next;
  offsetT cfa_offset;
};

/* Current open FDE entry.  */
struct frch_cfi_data
{
  struct fde_entry *cur_fde_data;
  symbolS *last_address;
  offsetT cur_cfa_offset;
  struct cfa_save_data *cfa_save_stack;
};

/* Construct a new FDE structure and add it to the end of the fde list.  */

static struct fde_entry *
alloc_fde_entry (void)
{
  struct fde_entry *fde = (struct fde_entry *)
      xcalloc (1, sizeof (struct fde_entry));

  frchain_now->frch_cfi_data = (struct frch_cfi_data *)
      xcalloc (1, sizeof (struct frch_cfi_data));
  frchain_now->frch_cfi_data->cur_fde_data = fde;
  *last_fde_data = fde;
  last_fde_data = &fde->next;
  SET_CUR_SEG (fde, is_now_linkonce_segment ());
  SET_HANDLED (fde, 0);
  fde->last = &fde->data;
  fde->return_column = DWARF2_DEFAULT_RETURN_COLUMN;
  fde->per_encoding = DW_EH_PE_omit;
  fde->lsda_encoding = DW_EH_PE_omit;

  return fde;
}

/* The following functions are available for a backend to construct its
   own unwind information, usually from legacy unwind directives.  */

/* Construct a new INSN structure and add it to the end of the insn list
   for the currently active FDE.  */

static struct cfi_insn_data *
alloc_cfi_insn_data (void)
{
  struct cfi_insn_data *insn = (struct cfi_insn_data *)
      xcalloc (1, sizeof (struct cfi_insn_data));
  struct fde_entry *cur_fde_data = frchain_now->frch_cfi_data->cur_fde_data;

  *cur_fde_data->last = insn;
  cur_fde_data->last = &insn->next;
  SET_CUR_SEG (insn, is_now_linkonce_segment ());
  return insn;
}

/* Construct a new FDE structure that begins at LABEL.  */

void
cfi_new_fde (symbolS *label)
{
  struct fde_entry *fde = alloc_fde_entry ();
  fde->start_address = label;
  frchain_now->frch_cfi_data->last_address = label;
}

/* End the currently open FDE.  */

void
cfi_end_fde (symbolS *label)
{
  frchain_now->frch_cfi_data->cur_fde_data->end_address = label;
  free (frchain_now->frch_cfi_data);
  frchain_now->frch_cfi_data = NULL;
}

/* Set the return column for the current FDE.  */

void
cfi_set_return_column (unsigned regno)
{
  frchain_now->frch_cfi_data->cur_fde_data->return_column = regno;
}

/* Universal functions to store new instructions.  */

static void
cfi_add_CFA_insn (int insn)
{
  struct cfi_insn_data *insn_ptr = alloc_cfi_insn_data ();

  insn_ptr->insn = insn;
}

static void
cfi_add_CFA_insn_reg (int insn, unsigned regno)
{
  struct cfi_insn_data *insn_ptr = alloc_cfi_insn_data ();

  insn_ptr->insn = insn;
  insn_ptr->u.r = regno;
}

static void
cfi_add_CFA_insn_offset (int insn, offsetT offset)
{
  struct cfi_insn_data *insn_ptr = alloc_cfi_insn_data ();

  insn_ptr->insn = insn;
  insn_ptr->u.i = offset;
}

static void
cfi_add_CFA_insn_reg_reg (int insn, unsigned reg1, unsigned reg2)
{
  struct cfi_insn_data *insn_ptr = alloc_cfi_insn_data ();

  insn_ptr->insn = insn;
  insn_ptr->u.rr.reg1 = reg1;
  insn_ptr->u.rr.reg2 = reg2;
}

static void
cfi_add_CFA_insn_reg_offset (int insn, unsigned regno, offsetT offset)
{
  struct cfi_insn_data *insn_ptr = alloc_cfi_insn_data ();

  insn_ptr->insn = insn;
  insn_ptr->u.ri.reg = regno;
  insn_ptr->u.ri.offset = offset;
}

/* Add a CFI insn to advance the PC from the last address to LABEL.  */

void
cfi_add_advance_loc (symbolS *label)
{
  struct cfi_insn_data *insn = alloc_cfi_insn_data ();

  insn->insn = DW_CFA_advance_loc;
  insn->u.ll.lab1 = frchain_now->frch_cfi_data->last_address;
  insn->u.ll.lab2 = label;

  frchain_now->frch_cfi_data->last_address = label;
}

/* Add a DW_CFA_offset record to the CFI data.  */

void
cfi_add_CFA_offset (unsigned regno, offsetT offset)
{
  unsigned int abs_data_align;

  gas_assert (DWARF2_CIE_DATA_ALIGNMENT != 0);
  cfi_add_CFA_insn_reg_offset (DW_CFA_offset, regno, offset);

  abs_data_align = (DWARF2_CIE_DATA_ALIGNMENT < 0
		    ? -DWARF2_CIE_DATA_ALIGNMENT : DWARF2_CIE_DATA_ALIGNMENT);
  if (offset % abs_data_align)
    as_bad (_("register save offset not a multiple of %u"), abs_data_align);
}

/* Add a DW_CFA_def_cfa record to the CFI data.  */

void
cfi_add_CFA_def_cfa (unsigned regno, offsetT offset)
{
  cfi_add_CFA_insn_reg_offset (DW_CFA_def_cfa, regno, offset);
  frchain_now->frch_cfi_data->cur_cfa_offset = offset;
}

/* Add a DW_CFA_register record to the CFI data.  */

void
cfi_add_CFA_register (unsigned reg1, unsigned reg2)
{
  cfi_add_CFA_insn_reg_reg (DW_CFA_register, reg1, reg2);
}

/* Add a DW_CFA_def_cfa_register record to the CFI data.  */

void
cfi_add_CFA_def_cfa_register (unsigned regno)
{
  cfi_add_CFA_insn_reg (DW_CFA_def_cfa_register, regno);
}

/* Add a DW_CFA_def_cfa_offset record to the CFI data.  */

void
cfi_add_CFA_def_cfa_offset (offsetT offset)
{
  cfi_add_CFA_insn_offset (DW_CFA_def_cfa_offset, offset);
  frchain_now->frch_cfi_data->cur_cfa_offset = offset;
}

void
cfi_add_CFA_restore (unsigned regno)
{
  cfi_add_CFA_insn_reg (DW_CFA_restore, regno);
}

void
cfi_add_CFA_undefined (unsigned regno)
{
  cfi_add_CFA_insn_reg (DW_CFA_undefined, regno);
}

void
cfi_add_CFA_same_value (unsigned regno)
{
  cfi_add_CFA_insn_reg (DW_CFA_same_value, regno);
}

void
cfi_add_CFA_remember_state (void)
{
  struct cfa_save_data *p;

  cfi_add_CFA_insn (DW_CFA_remember_state);

  p = (struct cfa_save_data *) xmalloc (sizeof (*p));
  p->cfa_offset = frchain_now->frch_cfi_data->cur_cfa_offset;
  p->next = frchain_now->frch_cfi_data->cfa_save_stack;
  frchain_now->frch_cfi_data->cfa_save_stack = p;
}

void
cfi_add_CFA_restore_state (void)
{
  struct cfa_save_data *p;

  cfi_add_CFA_insn (DW_CFA_restore_state);

  p = frchain_now->frch_cfi_data->cfa_save_stack;
  if (p)
    {
      frchain_now->frch_cfi_data->cur_cfa_offset = p->cfa_offset;
      frchain_now->frch_cfi_data->cfa_save_stack = p->next;
      free (p);
    }
  else
    as_bad (_("CFI state restore without previous remember"));
}


/* Parse CFI assembler directives.  */

static void dot_cfi (int);
static void dot_cfi_escape (int);
static void dot_cfi_sections (int);
static void dot_cfi_startproc (int);
static void dot_cfi_endproc (int);
static void dot_cfi_personality (int);
static void dot_cfi_lsda (int);
static void dot_cfi_val_encoded_addr (int);

const pseudo_typeS cfi_pseudo_table[] =
  {
    { "cfi_sections", dot_cfi_sections, 0 },
    { "cfi_startproc", dot_cfi_startproc, 0 },
    { "cfi_endproc", dot_cfi_endproc, 0 },
    { "cfi_def_cfa", dot_cfi, DW_CFA_def_cfa },
    { "cfi_def_cfa_register", dot_cfi, DW_CFA_def_cfa_register },
    { "cfi_def_cfa_offset", dot_cfi, DW_CFA_def_cfa_offset },
    { "cfi_adjust_cfa_offset", dot_cfi, CFI_adjust_cfa_offset },
    { "cfi_offset", dot_cfi, DW_CFA_offset },
    { "cfi_rel_offset", dot_cfi, CFI_rel_offset },
    { "cfi_register", dot_cfi, DW_CFA_register },
    { "cfi_return_column", dot_cfi, CFI_return_column },
    { "cfi_restore", dot_cfi, DW_CFA_restore },
    { "cfi_undefined", dot_cfi, DW_CFA_undefined },
    { "cfi_same_value", dot_cfi, DW_CFA_same_value },
    { "cfi_remember_state", dot_cfi, DW_CFA_remember_state },
    { "cfi_restore_state", dot_cfi, DW_CFA_restore_state },
    { "cfi_window_save", dot_cfi, DW_CFA_GNU_window_save },
    { "cfi_escape", dot_cfi_escape, 0 },
    { "cfi_signal_frame", dot_cfi, CFI_signal_frame },
    { "cfi_personality", dot_cfi_personality, 0 },
    { "cfi_lsda", dot_cfi_lsda, 0 },
    { "cfi_val_encoded_addr", dot_cfi_val_encoded_addr, 0 },
    { NULL, NULL, 0 }
  };

static void
cfi_parse_separator (void)
{
  SKIP_WHITESPACE ();
  if (*input_line_pointer == ',')
    input_line_pointer++;
  else
    as_bad (_("missing separator"));
}

#ifndef tc_parse_to_dw2regnum
static void
tc_parse_to_dw2regnum (expressionS *exp)
{
# ifdef tc_regname_to_dw2regnum
  SKIP_WHITESPACE ();
  if (is_name_beginner (*input_line_pointer)
      || (*input_line_pointer == '%'
	  && is_name_beginner (*++input_line_pointer)))
    {
      char *name, c;

      name = input_line_pointer;
      c = get_symbol_end ();

      exp->X_op = O_constant;
      exp->X_add_number = tc_regname_to_dw2regnum (name);

      *input_line_pointer = c;
    }
  else
# endif
    expression_and_evaluate (exp);
}
#endif

static unsigned
cfi_parse_reg (void)
{
  int regno;
  expressionS exp;

  tc_parse_to_dw2regnum (&exp);
  switch (exp.X_op)
    {
    case O_register:
    case O_constant:
      regno = exp.X_add_number;
      break;

    default:
      regno = -1;
      break;
    }

  if (regno < 0)
    {
      as_bad (_("bad register expression"));
      regno = 0;
    }

  return regno;
}

static offsetT
cfi_parse_const (void)
{
  return get_absolute_expression ();
}

static void
dot_cfi (int arg)
{
  offsetT offset;
  unsigned reg1, reg2;

  if (frchain_now->frch_cfi_data == NULL)
    {
      as_bad (_("CFI instruction used without previous .cfi_startproc"));
      ignore_rest_of_line ();
      return;
    }

  /* If the last address was not at the current PC, advance to current.  */
  if (symbol_get_frag (frchain_now->frch_cfi_data->last_address) != frag_now
      || S_GET_VALUE (frchain_now->frch_cfi_data->last_address)
	 != frag_now_fix ())
    cfi_add_advance_loc (symbol_temp_new_now ());

  switch (arg)
    {
    case DW_CFA_offset:
      reg1 = cfi_parse_reg ();
      cfi_parse_separator ();
      offset = cfi_parse_const ();
      cfi_add_CFA_offset (reg1, offset);
      break;

    case CFI_rel_offset:
      reg1 = cfi_parse_reg ();
      cfi_parse_separator ();
      offset = cfi_parse_const ();
      cfi_add_CFA_offset (reg1,
			  offset - frchain_now->frch_cfi_data->cur_cfa_offset);
      break;

    case DW_CFA_def_cfa:
      reg1 = cfi_parse_reg ();
      cfi_parse_separator ();
      offset = cfi_parse_const ();
      cfi_add_CFA_def_cfa (reg1, offset);
      break;

    case DW_CFA_register:
      reg1 = cfi_parse_reg ();
      cfi_parse_separator ();
      reg2 = cfi_parse_reg ();
      cfi_add_CFA_register (reg1, reg2);
      break;

    case DW_CFA_def_cfa_register:
      reg1 = cfi_parse_reg ();
      cfi_add_CFA_def_cfa_register (reg1);
      break;

    case DW_CFA_def_cfa_offset:
      offset = cfi_parse_const ();
      cfi_add_CFA_def_cfa_offset (offset);
      break;

    case CFI_adjust_cfa_offset:
      offset = cfi_parse_const ();
      cfi_add_CFA_def_cfa_offset (frchain_now->frch_cfi_data->cur_cfa_offset
				  + offset);
      break;

    case DW_CFA_restore:
      for (;;)
	{
	  reg1 = cfi_parse_reg ();
	  cfi_add_CFA_restore (reg1);
	  SKIP_WHITESPACE ();
	  if (*input_line_pointer != ',')
	    break;
	  ++input_line_pointer;
	}
      break;

    case DW_CFA_undefined:
      for (;;)
	{
	  reg1 = cfi_parse_reg ();
	  cfi_add_CFA_undefined (reg1);
	  SKIP_WHITESPACE ();
	  if (*input_line_pointer != ',')
	    break;
	  ++input_line_pointer;
	}
      break;

    case DW_CFA_same_value:
      reg1 = cfi_parse_reg ();
      cfi_add_CFA_same_value (reg1);
      break;

    case CFI_return_column:
      reg1 = cfi_parse_reg ();
      cfi_set_return_column (reg1);
      break;

    case DW_CFA_remember_state:
      cfi_add_CFA_remember_state ();
      break;

    case DW_CFA_restore_state:
      cfi_add_CFA_restore_state ();
      break;

    case DW_CFA_GNU_window_save:
      cfi_add_CFA_insn (DW_CFA_GNU_window_save);
      break;

    case CFI_signal_frame:
      frchain_now->frch_cfi_data->cur_fde_data->signal_frame = 1;
      break;

    default:
      abort ();
    }

  demand_empty_rest_of_line ();
}

static void
dot_cfi_escape (int ignored ATTRIBUTE_UNUSED)
{
  struct cfi_escape_data *head, **tail, *e;
  struct cfi_insn_data *insn;

  if (frchain_now->frch_cfi_data == NULL)
    {
      as_bad (_("CFI instruction used without previous .cfi_startproc"));
      ignore_rest_of_line ();
      return;
    }

  /* If the last address was not at the current PC, advance to current.  */
  if (symbol_get_frag (frchain_now->frch_cfi_data->last_address) != frag_now
      || S_GET_VALUE (frchain_now->frch_cfi_data->last_address)
	 != frag_now_fix ())
    cfi_add_advance_loc (symbol_temp_new_now ());

  tail = &head;
  do
    {
      e = (struct cfi_escape_data *) xmalloc (sizeof (*e));
      do_parse_cons_expression (&e->exp, 1);
      *tail = e;
      tail = &e->next;
    }
  while (*input_line_pointer++ == ',');
  *tail = NULL;

  insn = alloc_cfi_insn_data ();
  insn->insn = CFI_escape;
  insn->u.esc = head;

  --input_line_pointer;
  demand_empty_rest_of_line ();
}

static void
dot_cfi_personality (int ignored ATTRIBUTE_UNUSED)
{
  struct fde_entry *fde;
  offsetT encoding;

  if (frchain_now->frch_cfi_data == NULL)
    {
      as_bad (_("CFI instruction used without previous .cfi_startproc"));
      ignore_rest_of_line ();
      return;
    }

  fde = frchain_now->frch_cfi_data->cur_fde_data;
  encoding = cfi_parse_const ();
  if (encoding == DW_EH_PE_omit)
    {
      demand_empty_rest_of_line ();
      fde->per_encoding = encoding;
      return;
    }

  if ((encoding & 0xff) != encoding
      || ((encoding & 0x70) != 0
#if CFI_DIFF_EXPR_OK || defined tc_cfi_emit_pcrel_expr
	  && (encoding & 0x70) != DW_EH_PE_pcrel
#endif
	  )
	 /* leb128 can be handled, but does something actually need it?  */
      || (encoding & 7) == DW_EH_PE_uleb128
      || (encoding & 7) > DW_EH_PE_udata8)
    {
      as_bad (_("invalid or unsupported encoding in .cfi_personality"));
      ignore_rest_of_line ();
      return;
    }

  if (*input_line_pointer++ != ',')
    {
      as_bad (_(".cfi_personality requires encoding and symbol arguments"));
      ignore_rest_of_line ();
      return;
    }

  expression_and_evaluate (&fde->personality);
  switch (fde->personality.X_op)
    {
    case O_symbol:
      break;
    case O_constant:
      if ((encoding & 0x70) == DW_EH_PE_pcrel)
	encoding = DW_EH_PE_omit;
      break;
    default:
      encoding = DW_EH_PE_omit;
      break;
    }

  fde->per_encoding = encoding;

  if (encoding == DW_EH_PE_omit)
    {
      as_bad (_("wrong second argument to .cfi_personality"));
      ignore_rest_of_line ();
      return;
    }

  demand_empty_rest_of_line ();
}

static void
dot_cfi_lsda (int ignored ATTRIBUTE_UNUSED)
{
  struct fde_entry *fde;
  offsetT encoding;

  if (frchain_now->frch_cfi_data == NULL)
    {
      as_bad (_("CFI instruction used without previous .cfi_startproc"));
      ignore_rest_of_line ();
      return;
    }

  fde = frchain_now->frch_cfi_data->cur_fde_data;
  encoding = cfi_parse_const ();
  if (encoding == DW_EH_PE_omit)
    {
      demand_empty_rest_of_line ();
      fde->lsda_encoding = encoding;
      return;
    }

  if ((encoding & 0xff) != encoding
      || ((encoding & 0x70) != 0
#if CFI_DIFF_LSDA_OK || defined tc_cfi_emit_pcrel_expr
	  && (encoding & 0x70) != DW_EH_PE_pcrel
#endif
	  )
	 /* leb128 can be handled, but does something actually need it?  */
      || (encoding & 7) == DW_EH_PE_uleb128
      || (encoding & 7) > DW_EH_PE_udata8)
    {
      as_bad (_("invalid or unsupported encoding in .cfi_lsda"));
      ignore_rest_of_line ();
      return;
    }

  if (*input_line_pointer++ != ',')
    {
      as_bad (_(".cfi_lsda requires encoding and symbol arguments"));
      ignore_rest_of_line ();
      return;
    }

  fde->lsda_encoding = encoding;

  expression_and_evaluate (&fde->lsda);
  switch (fde->lsda.X_op)
    {
    case O_symbol:
      break;
    case O_constant:
      if ((encoding & 0x70) == DW_EH_PE_pcrel)
	encoding = DW_EH_PE_omit;
      break;
    default:
      encoding = DW_EH_PE_omit;
      break;
    }

  fde->lsda_encoding = encoding;

  if (encoding == DW_EH_PE_omit)
    {
      as_bad (_("wrong second argument to .cfi_lsda"));
      ignore_rest_of_line ();
      return;
    }

  demand_empty_rest_of_line ();
}

static void
dot_cfi_val_encoded_addr (int ignored ATTRIBUTE_UNUSED)
{
  struct cfi_insn_data *insn_ptr;
  offsetT encoding;

  if (frchain_now->frch_cfi_data == NULL)
    {
      as_bad (_("CFI instruction used without previous .cfi_startproc"));
      ignore_rest_of_line ();
      return;
    }

  /* If the last address was not at the current PC, advance to current.  */
  if (symbol_get_frag (frchain_now->frch_cfi_data->last_address) != frag_now
      || S_GET_VALUE (frchain_now->frch_cfi_data->last_address)
	 != frag_now_fix ())
    cfi_add_advance_loc (symbol_temp_new_now ());

  insn_ptr = alloc_cfi_insn_data ();
  insn_ptr->insn = CFI_val_encoded_addr;

  insn_ptr->u.ea.reg = cfi_parse_reg ();

  cfi_parse_separator ();
  encoding = cfi_parse_const ();
  if ((encoding & 0xff) != encoding
      || ((encoding & 0x70) != 0
#if CFI_DIFF_EXPR_OK || defined tc_cfi_emit_pcrel_expr
	  && (encoding & 0x70) != DW_EH_PE_pcrel
#endif
	  )
	 /* leb128 can be handled, but does something actually need it?  */
      || (encoding & 7) == DW_EH_PE_uleb128
      || (encoding & 7) > DW_EH_PE_udata8)
    {
      as_bad (_("invalid or unsupported encoding in .cfi_lsda"));
      encoding = DW_EH_PE_omit;
    }

  cfi_parse_separator ();
  expression_and_evaluate (&insn_ptr->u.ea.exp);
  switch (insn_ptr->u.ea.exp.X_op)
    {
    case O_symbol:
      break;
    case O_constant:
      if ((encoding & 0x70) != DW_EH_PE_pcrel)
        break;
    default:
      encoding = DW_EH_PE_omit;
      break;
    }

  insn_ptr->u.ea.encoding = encoding;
  if (encoding == DW_EH_PE_omit)
    {
      as_bad (_("wrong third argument to .cfi_val_encoded_addr"));
      ignore_rest_of_line ();
      return;
    }

  demand_empty_rest_of_line ();
}

/* By default emit .eh_frame only, not .debug_frame.  */
#define CFI_EMIT_eh_frame	(1 << 0)
#define CFI_EMIT_debug_frame	(1 << 1)
#define CFI_EMIT_target		(1 << 2)
static int cfi_sections = CFI_EMIT_eh_frame;

static void
dot_cfi_sections (int ignored ATTRIBUTE_UNUSED)
{
  int sections = 0;

  SKIP_WHITESPACE ();
  if (is_name_beginner (*input_line_pointer))
    while (1)
      {
	char *name, c;

	name = input_line_pointer;
	c = get_symbol_end ();

	if (strncmp (name, ".eh_frame", sizeof ".eh_frame") == 0
	    && name[9] != '_')
	  sections |= CFI_EMIT_eh_frame;
	else if (strncmp (name, ".debug_frame", sizeof ".debug_frame") == 0)
	  sections |= CFI_EMIT_debug_frame;
#ifdef tc_cfi_section_name
	else if (strcmp (name, tc_cfi_section_name) == 0)
	  sections |= CFI_EMIT_target;
#endif
	else
	  {
	    *input_line_pointer = c;
	    input_line_pointer = name;
	    break;
	  }

	*input_line_pointer = c;
	SKIP_WHITESPACE ();
	if (*input_line_pointer == ',')
	  {
	    name = input_line_pointer++;
	    SKIP_WHITESPACE ();
	    if (!is_name_beginner (*input_line_pointer))
	      {
		input_line_pointer = name;
		break;
	      }
	  }
	else if (is_name_beginner (*input_line_pointer))
	  break;
      }

  demand_empty_rest_of_line ();
  cfi_sections = sections;
}

static void
dot_cfi_startproc (int ignored ATTRIBUTE_UNUSED)
{
  int simple = 0;

  if (frchain_now->frch_cfi_data != NULL)
    {
      as_bad (_("previous CFI entry not closed (missing .cfi_endproc)"));
      ignore_rest_of_line ();
      return;
    }

  cfi_new_fde (symbol_temp_new_now ());

  SKIP_WHITESPACE ();
  if (is_name_beginner (*input_line_pointer))
    {
      char *name, c;

      name = input_line_pointer;
      c = get_symbol_end ();

      if (strcmp (name, "simple") == 0)
	{
	  simple = 1;
	  *input_line_pointer = c;
	}
      else
	input_line_pointer = name;
    }
  demand_empty_rest_of_line ();

  frchain_now->frch_cfi_data->cur_cfa_offset = 0;
  if (!simple)
    tc_cfi_frame_initial_instructions ();

  if ((cfi_sections & CFI_EMIT_target) != 0)
    tc_cfi_startproc ();
}

static void
dot_cfi_endproc (int ignored ATTRIBUTE_UNUSED)
{
  struct fde_entry *fde;

  if (frchain_now->frch_cfi_data == NULL)
    {
      as_bad (_(".cfi_endproc without corresponding .cfi_startproc"));
      ignore_rest_of_line ();
      return;
    }

  fde = frchain_now->frch_cfi_data->cur_fde_data;

  cfi_end_fde (symbol_temp_new_now ());

  demand_empty_rest_of_line ();

  if ((cfi_sections & CFI_EMIT_target) != 0)
    tc_cfi_endproc (fde);
}


/* Emit a single byte into the current segment.  */

static inline void
out_one (int byte)
{
  FRAG_APPEND_1_CHAR (byte);
}

/* Emit a two-byte word into the current segment.  */

static inline void
out_two (int data)
{
  md_number_to_chars (frag_more (2), data, 2);
}

/* Emit a four byte word into the current segment.  */

static inline void
out_four (int data)
{
  md_number_to_chars (frag_more (4), data, 4);
}

/* Emit an unsigned "little-endian base 128" number.  */

static void
out_uleb128 (addressT value)
{
  output_leb128 (frag_more (sizeof_leb128 (value, 0)), value, 0);
}

/* Emit an unsigned "little-endian base 128" number.  */

static void
out_sleb128 (offsetT value)
{
  output_leb128 (frag_more (sizeof_leb128 (value, 1)), value, 1);
}

static void
output_cfi_insn (struct cfi_insn_data *insn)
{
  offsetT offset;
  unsigned int regno;

  switch (insn->insn)
    {
    case DW_CFA_advance_loc:
      {
	symbolS *from = insn->u.ll.lab1;
	symbolS *to = insn->u.ll.lab2;

	if (symbol_get_frag (to) == symbol_get_frag (from))
	  {
	    addressT delta = S_GET_VALUE (to) - S_GET_VALUE (from);
	    addressT scaled = delta / DWARF2_LINE_MIN_INSN_LENGTH;

	    if (scaled <= 0x3F)
	      out_one (DW_CFA_advance_loc + scaled);
	    else if (scaled <= 0xFF)
	      {
		out_one (DW_CFA_advance_loc1);
		out_one (scaled);
	      }
	    else if (scaled <= 0xFFFF)
	      {
		out_one (DW_CFA_advance_loc2);
		out_two (scaled);
	      }
	    else
	      {
		out_one (DW_CFA_advance_loc4);
		out_four (scaled);
	      }
	  }
	else
	  {
	    expressionS exp;

	    exp.X_op = O_subtract;
	    exp.X_add_symbol = to;
	    exp.X_op_symbol = from;
	    exp.X_add_number = 0;

	    /* The code in ehopt.c expects that one byte of the encoding
	       is already allocated to the frag.  This comes from the way
	       that it scans the .eh_frame section looking first for the
	       .byte DW_CFA_advance_loc4.  */
	    *frag_more (1) = DW_CFA_advance_loc4;

	    frag_var (rs_cfa, 4, 0, DWARF2_LINE_MIN_INSN_LENGTH << 3,
		      make_expr_symbol (&exp), frag_now_fix () - 1,
		      (char *) frag_now);
	  }
      }
      break;

    case DW_CFA_def_cfa:
      offset = insn->u.ri.offset;
      if (offset < 0)
	{
	  out_one (DW_CFA_def_cfa_sf);
	  out_uleb128 (insn->u.ri.reg);
	  out_sleb128 (offset / DWARF2_CIE_DATA_ALIGNMENT);
	}
      else
	{
	  out_one (DW_CFA_def_cfa);
	  out_uleb128 (insn->u.ri.reg);
	  out_uleb128 (offset);
	}
      break;

    case DW_CFA_def_cfa_register:
    case DW_CFA_undefined:
    case DW_CFA_same_value:
      out_one (insn->insn);
      out_uleb128 (insn->u.r);
      break;

    case DW_CFA_def_cfa_offset:
      offset = insn->u.i;
      if (offset < 0)
	{
	  out_one (DW_CFA_def_cfa_offset_sf);
	  out_sleb128 (offset / DWARF2_CIE_DATA_ALIGNMENT);
	}
      else
	{
	  out_one (DW_CFA_def_cfa_offset);
	  out_uleb128 (offset);
	}
      break;

    case DW_CFA_restore:
      regno = insn->u.r;
      if (regno <= 0x3F)
	{
	  out_one (DW_CFA_restore + regno);
	}
      else
	{
	  out_one (DW_CFA_restore_extended);
	  out_uleb128 (regno);
	}
      break;

    case DW_CFA_offset:
      regno = insn->u.ri.reg;
      offset = insn->u.ri.offset / DWARF2_CIE_DATA_ALIGNMENT;
      if (offset < 0)
	{
	  out_one (DW_CFA_offset_extended_sf);
	  out_uleb128 (regno);
	  out_sleb128 (offset);
	}
      else if (regno <= 0x3F)
	{
	  out_one (DW_CFA_offset + regno);
	  out_uleb128 (offset);
	}
      else
	{
	  out_one (DW_CFA_offset_extended);
	  out_uleb128 (regno);
	  out_uleb128 (offset);
	}
      break;

    case DW_CFA_register:
      out_one (DW_CFA_register);
      out_uleb128 (insn->u.rr.reg1);
      out_uleb128 (insn->u.rr.reg2);
      break;

    case DW_CFA_remember_state:
    case DW_CFA_restore_state:
      out_one (insn->insn);
      break;

    case DW_CFA_GNU_window_save:
      out_one (DW_CFA_GNU_window_save);
      break;

    case CFI_escape:
      {
	struct cfi_escape_data *e;
	for (e = insn->u.esc; e ; e = e->next)
	  emit_expr (&e->exp, 1);
	break;
      }

    case CFI_val_encoded_addr:
      {
        unsigned encoding = insn->u.ea.encoding;
        offsetT encoding_size;

	if (encoding == DW_EH_PE_omit)
	  break;
	out_one (DW_CFA_val_expression);
	out_uleb128 (insn->u.ea.reg);

        switch (encoding & 0x7)
	  {
	  case DW_EH_PE_absptr:
	    encoding_size = DWARF2_ADDR_SIZE (stdoutput);
	    break;
	  case DW_EH_PE_udata2:
	    encoding_size = 2;
	    break;
	  case DW_EH_PE_udata4:
	    encoding_size = 4;
	    break;
	  case DW_EH_PE_udata8:
	    encoding_size = 8;
	    break;
	  default:
	    abort ();
	  }

	/* If the user has requested absolute encoding,
	   then use the smaller DW_OP_addr encoding.  */
	if (insn->u.ea.encoding == DW_EH_PE_absptr)
	  {
	    out_uleb128 (1 + encoding_size);
	    out_one (DW_OP_addr);
	  }
	else
	  {
	    out_uleb128 (1 + 1 + encoding_size);
	    out_one (DW_OP_GNU_encoded_addr);
	    out_one (encoding);

	    if ((encoding & 0x70) == DW_EH_PE_pcrel)
	      {
#if CFI_DIFF_EXPR_OK
		insn->u.ea.exp.X_op = O_subtract;
		insn->u.ea.exp.X_op_symbol = symbol_temp_new_now ();
#elif defined (tc_cfi_emit_pcrel_expr)
		tc_cfi_emit_pcrel_expr (&insn->u.ea.exp, encoding_size);
		break;
#else
		abort ();
#endif
	      }
	  }
	emit_expr (&insn->u.ea.exp, encoding_size);
      }
      break;

    default:
      abort ();
    }
}

static offsetT
encoding_size (unsigned char encoding)
{
  if (encoding == DW_EH_PE_omit)
    return 0;
  switch (encoding & 0x7)
    {
    case 0:
      return bfd_get_arch_size (stdoutput) == 64 ? 8 : 4;
    case DW_EH_PE_udata2:
      return 2;
    case DW_EH_PE_udata4:
      return 4;
    case DW_EH_PE_udata8:
      return 8;
    default:
      abort ();
    }
}

static void
output_cie (struct cie_entry *cie, bfd_boolean eh_frame, int align)
{
  symbolS *after_size_address, *end_address;
  expressionS exp;
  struct cfi_insn_data *i;
  offsetT augmentation_size;
  int enc;
  enum dwarf2_format fmt = DWARF2_FORMAT (now_seg);

  cie->start_address = symbol_temp_new_now ();
  after_size_address = symbol_temp_make ();
  end_address = symbol_temp_make ();

  exp.X_op = O_subtract;
  exp.X_add_symbol = end_address;
  exp.X_op_symbol = after_size_address;
  exp.X_add_number = 0;

  if (eh_frame || fmt == dwarf2_format_32bit)
    emit_expr (&exp, 4);			/* Length.  */
  else
    {
      if (fmt == dwarf2_format_64bit)
	out_four (-1);
      emit_expr (&exp, 8);			/* Length.  */
    }
  symbol_set_value_now (after_size_address);
  if (eh_frame)
    out_four (0);				/* CIE id.  */
  else
    {
      out_four (-1);				/* CIE id.  */
      if (fmt != dwarf2_format_32bit)
	out_four (-1);
    }
  out_one (DW_CIE_VERSION);			/* Version.  */
  if (eh_frame)
    {
      out_one ('z');				/* Augmentation.  */
      if (cie->per_encoding != DW_EH_PE_omit)
	out_one ('P');
      if (cie->lsda_encoding != DW_EH_PE_omit)
	out_one ('L');
      out_one ('R');
    }
  if (cie->signal_frame)
    out_one ('S');
  out_one (0);
  out_uleb128 (DWARF2_LINE_MIN_INSN_LENGTH);	/* Code alignment.  */
  out_sleb128 (DWARF2_CIE_DATA_ALIGNMENT);	/* Data alignment.  */
  if (DW_CIE_VERSION == 1)			/* Return column.  */
    out_one (cie->return_column);
  else
    out_uleb128 (cie->return_column);
  if (eh_frame)
    {
      augmentation_size = 1 + (cie->lsda_encoding != DW_EH_PE_omit);
      if (cie->per_encoding != DW_EH_PE_omit)
	augmentation_size += 1 + encoding_size (cie->per_encoding);
      out_uleb128 (augmentation_size);		/* Augmentation size.  */

      if (cie->per_encoding != DW_EH_PE_omit)
	{
	  offsetT size = encoding_size (cie->per_encoding);
	  out_one (cie->per_encoding);
	  exp = cie->personality;
	  if ((cie->per_encoding & 0x70) == DW_EH_PE_pcrel)
	    {
#if CFI_DIFF_EXPR_OK
	      exp.X_op = O_subtract;
	      exp.X_op_symbol = symbol_temp_new_now ();
	      emit_expr (&exp, size);
#elif defined (tc_cfi_emit_pcrel_expr)
	      tc_cfi_emit_pcrel_expr (&exp, size);
#else
	      abort ();
#endif
	    }
	  else
	    emit_expr (&exp, size);
	}

      if (cie->lsda_encoding != DW_EH_PE_omit)
	out_one (cie->lsda_encoding);
    }

  switch (DWARF2_FDE_RELOC_SIZE)
    {
    case 2:
      enc = DW_EH_PE_sdata2;
      break;
    case 4:
      enc = DW_EH_PE_sdata4;
      break;
    case 8:
      enc = DW_EH_PE_sdata8;
      break;
    default:
      abort ();
    }
#if CFI_DIFF_EXPR_OK || defined tc_cfi_emit_pcrel_expr
  enc |= DW_EH_PE_pcrel;
#endif
  if (eh_frame)
    out_one (enc);

  if (cie->first)
    {
      for (i = cie->first; i != cie->last; i = i->next)
        {
	  if (CUR_SEG (i) != CUR_SEG (cie))
	    continue;
	  output_cfi_insn (i);
	}
    }

  frag_align (align, DW_CFA_nop, 0);
  symbol_set_value_now (end_address);
}

static void
output_fde (struct fde_entry *fde, struct cie_entry *cie,
	    bfd_boolean eh_frame, struct cfi_insn_data *first,
	    int align)
{
  symbolS *after_size_address, *end_address;
  expressionS exp;
  offsetT augmentation_size;
  enum dwarf2_format fmt = DWARF2_FORMAT (now_seg);
  int offset_size;
  int addr_size;

  after_size_address = symbol_temp_make ();
  end_address = symbol_temp_make ();

  exp.X_op = O_subtract;
  exp.X_add_symbol = end_address;
  exp.X_op_symbol = after_size_address;
  exp.X_add_number = 0;
  if (eh_frame || fmt == dwarf2_format_32bit)
    offset_size = 4;
  else
    {
      if (fmt == dwarf2_format_64bit)
	out_four (-1);
      offset_size = 8;
    }
  emit_expr (&exp, offset_size);		/* Length.  */
  symbol_set_value_now (after_size_address);

  if (eh_frame)
    {
      exp.X_op = O_subtract;
      exp.X_add_symbol = after_size_address;
      exp.X_op_symbol = cie->start_address;
      exp.X_add_number = 0;
      emit_expr (&exp, offset_size);		/* CIE offset.  */
    }
  else
    {
      TC_DWARF2_EMIT_OFFSET (cie->start_address, offset_size);
    }

  if (eh_frame)
    {
      exp.X_op = O_subtract;
      exp.X_add_number = 0;
#if CFI_DIFF_EXPR_OK
      exp.X_add_symbol = fde->start_address;
      exp.X_op_symbol = symbol_temp_new_now ();
      emit_expr (&exp, DWARF2_FDE_RELOC_SIZE);	/* Code offset.  */
#else
      exp.X_op = O_symbol;
      exp.X_add_symbol = fde->start_address;
#ifdef tc_cfi_emit_pcrel_expr
      tc_cfi_emit_pcrel_expr (&exp, DWARF2_FDE_RELOC_SIZE);	 /* Code offset.  */
#else
      emit_expr (&exp, DWARF2_FDE_RELOC_SIZE);	/* Code offset.  */
#endif
#endif
      addr_size = DWARF2_FDE_RELOC_SIZE;
    }
  else
    {
      exp.X_op = O_symbol;
      exp.X_add_symbol = fde->start_address;
      exp.X_add_number = 0;
      addr_size = DWARF2_ADDR_SIZE (stdoutput);
      emit_expr (&exp, addr_size);
    }

  exp.X_op = O_subtract;
  exp.X_add_symbol = fde->end_address;
  exp.X_op_symbol = fde->start_address;		/* Code length.  */
  exp.X_add_number = 0;
  emit_expr (&exp, addr_size);

  augmentation_size = encoding_size (fde->lsda_encoding);
  if (eh_frame)
    out_uleb128 (augmentation_size);		/* Augmentation size.  */

  if (fde->lsda_encoding != DW_EH_PE_omit)
    {
      exp = fde->lsda;
      if ((fde->lsda_encoding & 0x70) == DW_EH_PE_pcrel)
	{
#if CFI_DIFF_LSDA_OK
	  exp.X_op = O_subtract;
	  exp.X_op_symbol = symbol_temp_new_now ();
	  emit_expr (&exp, augmentation_size);
#elif defined (tc_cfi_emit_pcrel_expr)
	  tc_cfi_emit_pcrel_expr (&exp, augmentation_size);
#else
	  abort ();
#endif
	}
      else
	emit_expr (&exp, augmentation_size);
    }

  for (; first; first = first->next)
    if (CUR_SEG (first) == CUR_SEG (fde))
      output_cfi_insn (first);

  frag_align (align, DW_CFA_nop, 0);
  symbol_set_value_now (end_address);
}

static struct cie_entry *
select_cie_for_fde (struct fde_entry *fde, bfd_boolean eh_frame,
		    struct cfi_insn_data **pfirst, int align)
{
  struct cfi_insn_data *i, *j;
  struct cie_entry *cie;

  for (cie = cie_root; cie; cie = cie->next)
    {
      if (CUR_SEG (cie) != CUR_SEG (fde))
	continue;
      if (cie->return_column != fde->return_column
	  || cie->signal_frame != fde->signal_frame
	  || cie->per_encoding != fde->per_encoding
	  || cie->lsda_encoding != fde->lsda_encoding)
	continue;
      if (cie->per_encoding != DW_EH_PE_omit)
	{
	  if (cie->personality.X_op != fde->personality.X_op
	      || cie->personality.X_add_number
		 != fde->personality.X_add_number)
	    continue;
	  switch (cie->personality.X_op)
	    {
	    case O_constant:
	      if (cie->personality.X_unsigned != fde->personality.X_unsigned)
		continue;
	      break;
	    case O_symbol:
	      if (cie->personality.X_add_symbol
		  != fde->personality.X_add_symbol)
		continue;
	      break;
	    default:
	      abort ();
	    }
	}
      for (i = cie->first, j = fde->data;
	   i != cie->last && j != NULL;
	   i = i->next, j = j->next)
	{
	  if (i->insn != j->insn)
	    goto fail;
	  switch (i->insn)
	    {
	    case DW_CFA_advance_loc:
	    case DW_CFA_remember_state:
	      /* We reached the first advance/remember in the FDE,
		 but did not reach the end of the CIE list.  */
	      goto fail;

	    case DW_CFA_offset:
	    case DW_CFA_def_cfa:
	      if (i->u.ri.reg != j->u.ri.reg)
		goto fail;
	      if (i->u.ri.offset != j->u.ri.offset)
		goto fail;
	      break;

	    case DW_CFA_register:
	      if (i->u.rr.reg1 != j->u.rr.reg1)
		goto fail;
	      if (i->u.rr.reg2 != j->u.rr.reg2)
		goto fail;
	      break;

	    case DW_CFA_def_cfa_register:
	    case DW_CFA_restore:
	    case DW_CFA_undefined:
	    case DW_CFA_same_value:
	      if (i->u.r != j->u.r)
		goto fail;
	      break;

	    case DW_CFA_def_cfa_offset:
	      if (i->u.i != j->u.i)
		goto fail;
	      break;

	    case CFI_escape:
	    case CFI_val_encoded_addr:
	      /* Don't bother matching these for now.  */
	      goto fail;

	    default:
	      abort ();
	    }
	}

      /* Success if we reached the end of the CIE list, and we've either
	 run out of FDE entries or we've encountered an advance,
	 remember, or escape.  */
      if (i == cie->last
	  && (!j
	      || j->insn == DW_CFA_advance_loc
	      || j->insn == DW_CFA_remember_state
	      || j->insn == CFI_escape
	      || j->insn == CFI_val_encoded_addr))
	{
	  *pfirst = j;
	  return cie;
	}

    fail:;
    }

  cie = (struct cie_entry *) xmalloc (sizeof (struct cie_entry));
  cie->next = cie_root;
  cie_root = cie;
  SET_CUR_SEG (cie, CUR_SEG (fde));
  cie->return_column = fde->return_column;
  cie->signal_frame = fde->signal_frame;
  cie->per_encoding = fde->per_encoding;
  cie->lsda_encoding = fde->lsda_encoding;
  cie->personality = fde->personality;
  cie->first = fde->data;

  for (i = cie->first; i ; i = i->next)
    if (i->insn == DW_CFA_advance_loc
	|| i->insn == DW_CFA_remember_state
	|| i->insn == CFI_escape
	|| i->insn == CFI_val_encoded_addr)
      break;

  cie->last = i;
  *pfirst = i;

  output_cie (cie, eh_frame, align);

  return cie;
}

#ifdef md_reg_eh_frame_to_debug_frame
static void
cfi_change_reg_numbers (struct cfi_insn_data *insn, segT ccseg)
{
  for (; insn; insn = insn->next)
    {
      if (CUR_SEG (insn) != ccseg)
        continue;
      switch (insn->insn)
	{
	case DW_CFA_advance_loc:
	case DW_CFA_def_cfa_offset:
	case DW_CFA_remember_state:
	case DW_CFA_restore_state:
	case DW_CFA_GNU_window_save:
	case CFI_escape:
	  break;

	case DW_CFA_def_cfa:
	case DW_CFA_offset:
	  insn->u.ri.reg = md_reg_eh_frame_to_debug_frame (insn->u.ri.reg);
	  break;

	case DW_CFA_def_cfa_register:
	case DW_CFA_undefined:
	case DW_CFA_same_value:
	case DW_CFA_restore:
	  insn->u.r = md_reg_eh_frame_to_debug_frame (insn->u.r);
	  break;

	case DW_CFA_register:
	  insn->u.rr.reg1 = md_reg_eh_frame_to_debug_frame (insn->u.rr.reg1);
	  insn->u.rr.reg2 = md_reg_eh_frame_to_debug_frame (insn->u.rr.reg2);
	  break;

	case CFI_val_encoded_addr:
	  insn->u.ea.reg = md_reg_eh_frame_to_debug_frame (insn->u.ea.reg);
	  break;

	default:
	  abort ();
	}
    }
}
#else
#define cfi_change_reg_numbers(insn, cseg) do { } while (0)
#endif

static segT
get_cfi_seg (segT cseg, const char *base, flagword flags, int align)
{
  if (SUPPORT_FRAME_LINKONCE)
    {
      struct dwcfi_seg_list *l;

      l = dwcfi_hash_find_or_make (cseg, base, flags);

      cseg = l->seg;
      subseg_set (cseg, l->subseg);
    }
  else
    {
      cseg = subseg_new (base, 0);
      bfd_set_section_flags (stdoutput, cseg, flags);
    }
  record_alignment (cseg, align);
  return cseg;
}

void
cfi_finish (void)
{
  struct cie_entry *cie, *cie_next;
  segT cfi_seg, ccseg;
  struct fde_entry *fde;
  struct cfi_insn_data *first;
  int save_flag_traditional_format, seek_next_seg;

  if (all_fde_data == 0)
    return;

  if ((cfi_sections & CFI_EMIT_eh_frame) != 0)
    {
      /* Make sure check_eh_frame doesn't do anything with our output.  */
      save_flag_traditional_format = flag_traditional_format;
      flag_traditional_format = 1;

      if (!SUPPORT_FRAME_LINKONCE)
	{
	  /* Open .eh_frame section.  */
	  cfi_seg = get_cfi_seg (NULL, ".eh_frame",
				 (SEC_ALLOC | SEC_LOAD | SEC_DATA
				  | DWARF2_EH_FRAME_READ_ONLY),
				 EH_FRAME_ALIGNMENT);
#ifdef md_fix_up_eh_frame
	  md_fix_up_eh_frame (cfi_seg);
#else
	  (void) cfi_seg;
#endif
	}

      do
        {
	  ccseg = NULL;
	  seek_next_seg = 0;

	  for (cie = cie_root; cie; cie = cie_next)
	    {
	      cie_next = cie->next;
	      free ((void *) cie);
	    }
	  cie_root = NULL;

	  for (fde = all_fde_data; fde ; fde = fde->next)
	    {
	      if (SUPPORT_FRAME_LINKONCE)
		{
		  if (HANDLED (fde))
		    continue;
		  if (seek_next_seg && CUR_SEG (fde) != ccseg)
		    {
		      seek_next_seg = 2;
		      continue;
		    }
		  if (!seek_next_seg)
		    {
		      ccseg = CUR_SEG (fde);
		      /* Open .eh_frame section.  */
		      cfi_seg = get_cfi_seg (ccseg, ".eh_frame",
					     (SEC_ALLOC | SEC_LOAD | SEC_DATA
					      | DWARF2_EH_FRAME_READ_ONLY),
					     EH_FRAME_ALIGNMENT);
#ifdef md_fix_up_eh_frame
		      md_fix_up_eh_frame (cfi_seg);
#else
		      (void) cfi_seg;
#endif
		      seek_next_seg = 1;
		    }
		  SET_HANDLED (fde, 1);
		}

	      if (fde->end_address == NULL)
		{
		  as_bad (_("open CFI at the end of file; missing .cfi_endproc directive"));
		  fde->end_address = fde->start_address;
		}

	      cie = select_cie_for_fde (fde, TRUE, &first, 2);
	      output_fde (fde, cie, TRUE, first,
			  fde->next == NULL ? EH_FRAME_ALIGNMENT : 2);
	    }
	}
      while (SUPPORT_FRAME_LINKONCE && seek_next_seg == 2);

      if (SUPPORT_FRAME_LINKONCE)
	for (fde = all_fde_data; fde ; fde = fde->next)
	  SET_HANDLED (fde, 0);

      flag_traditional_format = save_flag_traditional_format;
    }

  if ((cfi_sections & CFI_EMIT_debug_frame) != 0)
    {
      int alignment = ffs (DWARF2_ADDR_SIZE (stdoutput)) - 1;

      if (!SUPPORT_FRAME_LINKONCE)
	get_cfi_seg (NULL, ".debug_frame",
		     SEC_READONLY | SEC_DEBUGGING,
		     alignment);

      do
        {
	  ccseg = NULL;
	  seek_next_seg = 0;

	  for (cie = cie_root; cie; cie = cie_next)
	    {
	      cie_next = cie->next;
	      free ((void *) cie);
	    }
	  cie_root = NULL;

	  for (fde = all_fde_data; fde ; fde = fde->next)
	    {
	      if (SUPPORT_FRAME_LINKONCE)
		{
		  if (HANDLED (fde))
		    continue;
		  if (seek_next_seg && CUR_SEG (fde) != ccseg)
		    {
		      seek_next_seg = 2;
		      continue;
		    }
		  if (!seek_next_seg)
		    {
		      ccseg = CUR_SEG (fde);
		      /* Open .debug_frame section.  */
		      get_cfi_seg (ccseg, ".debug_frame",
				   SEC_READONLY | SEC_DEBUGGING,
				   alignment);
		      seek_next_seg = 1;
		    }
		  SET_HANDLED (fde, 1);
		}
	      if (fde->end_address == NULL)
		{
		  as_bad (_("open CFI at the end of file; missing .cfi_endproc directive"));
		  fde->end_address = fde->start_address;
		}

	      fde->per_encoding = DW_EH_PE_omit;
	      fde->lsda_encoding = DW_EH_PE_omit;
	      cfi_change_reg_numbers (fde->data, ccseg);
	      cie = select_cie_for_fde (fde, FALSE, &first, alignment);
	      output_fde (fde, cie, FALSE, first, alignment);
	    }
	}
      while (SUPPORT_FRAME_LINKONCE && seek_next_seg == 2);

      if (SUPPORT_FRAME_LINKONCE)
	for (fde = all_fde_data; fde ; fde = fde->next)
	  SET_HANDLED (fde, 0);
    }
}

#else /* TARGET_USE_CFIPOP */

/* Emit an intelligible error message for missing support.  */

static void
dot_cfi_dummy (int ignored ATTRIBUTE_UNUSED)
{
  as_bad (_("CFI is not supported for this target"));
  ignore_rest_of_line ();
}

const pseudo_typeS cfi_pseudo_table[] =
  {
    { "cfi_sections", dot_cfi_dummy, 0 },
    { "cfi_startproc", dot_cfi_dummy, 0 },
    { "cfi_endproc", dot_cfi_dummy, 0 },
    { "cfi_def_cfa", dot_cfi_dummy, 0 },
    { "cfi_def_cfa_register", dot_cfi_dummy, 0 },
    { "cfi_def_cfa_offset", dot_cfi_dummy, 0 },
    { "cfi_adjust_cfa_offset", dot_cfi_dummy, 0 },
    { "cfi_offset", dot_cfi_dummy, 0 },
    { "cfi_rel_offset", dot_cfi_dummy, 0 },
    { "cfi_register", dot_cfi_dummy, 0 },
    { "cfi_return_column", dot_cfi_dummy, 0 },
    { "cfi_restore", dot_cfi_dummy, 0 },
    { "cfi_undefined", dot_cfi_dummy, 0 },
    { "cfi_same_value", dot_cfi_dummy, 0 },
    { "cfi_remember_state", dot_cfi_dummy, 0 },
    { "cfi_restore_state", dot_cfi_dummy, 0 },
    { "cfi_window_save", dot_cfi_dummy, 0 },
    { "cfi_escape", dot_cfi_dummy, 0 },
    { "cfi_signal_frame", dot_cfi_dummy, 0 },
    { "cfi_personality", dot_cfi_dummy, 0 },
    { "cfi_lsda", dot_cfi_dummy, 0 },
    { "cfi_val_encoded_addr", dot_cfi_dummy, 0 },
    { NULL, NULL, 0 }
  };

void
cfi_finish (void)
{
}
#endif /* TARGET_USE_CFIPOP */
@


1.57
log
@        * dw2gencfi.c (all_fde_data): Export.
        * dw2gencfi.h (all_fde_data): Declare.
        * config/tc-alpha.c (alpha_elf_md_end): Don't convert legacy unwind
        info to cfi unwind info if the user already has supplied some.
@
text
@d89 1
a89 1
#define SET_CUR_SEG(structp, seg) structp->cur_seg = seg 
@


1.56
log
@	* dw2gencfi.c (tc_cfi_endproc): Avoid "set but not used" error.
@
text
@d290 1
a290 1
static struct fde_entry *all_fde_data;
@


1.55
log
@2011-05-09  Paul Brook  <paul@@codesourcery.com>

	bfd/
	* elf32-tic6x.c (is_tic6x_elf_unwind_section_name,
	elf32_tic6x_fake_sections): New functions.
	(elf_backend_fake_sections): Define.

	gas/
	* config/tc-tic6x.c (streq): Define.
	(tic6x_get_unwind): New.
	(s_tic6x_cantunwind, s_tic6x_handlerdata, s_tic6x_endp,
	s_tic6x_personalityindex, s_tic6x_personality): New functions.
	(md_pseudo_table): Add "endp", "handlerdata", "personalityindex",
	"personality" and "cantunwind".
	(tic6x_regname_to_dw2regnum, tic6x_frame_initial_instructions,
	tic6x_start_unwind_section, tic6x_unwind_frame_regs,
	tic6x_pop_rts_offset_little, tic6x_pop_rts_offset_big,
	tic6x_unwind_reg_from_dwarf, tic6x_flush_unwind_word,
	tic6x_unwind_byte, tic6x_unwind_2byte, tic6x_unwind_uleb,
	tic6x_cfi_startproc, output_exidx_entry, tic6x_output_unwinding,
	tic6x_cfi_endproc): New.
	* config/tc-tic6x.h (TIC6X_NUM_UNWIND_REGS): Define.
	(tic6x_unwind_info): New.
	(tic6x_segment_info_type): Add marked_pr_dependency, unwind and
	text_unwind.
	(TARGET_USE_CFIPOP, tc_regname_to_dw2regnum,
	tc_cfi_frame_initial_instructions, DWARF2_DEFAULT_RETURN_COLUMN,
	DWARF2_CIE_DATA_ALIGNMENT, tc_cfi_startproc, tc_cfi_endproc,
	tc_cfi_section_name): Define.
	* doc/c-tic6x.texi: Document new unwinding directives.
	* dw2gencfi.c (tc_cfi_startproc, tc_cfi_endproc): Add default
	definitions.
	(cfi_insn_data, fde_entry, CFI_adjust_cfa_offset, CFI_return_column,
	CFI_rel_offset, CFI_escape, CFI_signal_frame, CFI_val_encoded_addr):
	Move to dw2gencfi.h.
	(CFI_EMIT_target): Define.
	(dot_cfi_sections): Check tc_cfi_section_name.
	(dot_cfi_startproc): Use tc_cfi_startproc.
	(dot_cfi_endproc): Use tc_cfi_endproc.
	* dw2gencfi.h (cfi_insn_data, fde_entry, CFI_adjust_cfa_offset,
	CFI_return_column, CFI_rel_offset, CFI_escape, CFI_signal_frame,
	CFI_val_encoded_addr):  Move to here from dw2gencfi.c.

	gas/testsuite:
	* gas/tic6x/unwind-1.d: New test.
	* gas/tic6x/unwind-1.s: New test.
	* gas/tic6x/unwind-2.d: New test.
	* gas/tic6x/unwind-2.s: New test.
	* gas/tic6x/unwind-3.d: New test.
	* gas/tic6x/unwind-3.s: New test.
	* gas/tic6x/unwind-bad-1.d: New test.
	* gas/tic6x/unwind-bad-1.s: New test.
	* gas/tic6x/unwind-bad-1.l: New test.
	* gas/tic6x/unwind-bad-2.d: New test.
	* gas/tic6x/unwind-bad-2.s: New test.
	* gas/tic6x/unwind-bad-2.l: New test.

	include/
	* elf/tic6x.h (ELF_STRING_C6000_unwind,
	ELF_STRING_C6000_unwind_info, ELF_STRING_C6000_unwind_once,
	ELF_STRING_C6000_unwind_info_once): Define.
@
text
@d76 1
a76 1
# define tc_cfi_endproc(fde) ((void)0)
@


1.54
log
@	* dw2gencfi.c (CUR_SEG, SET_CUR_SEG, HANDLED, SET_HANDLED): Define.
	Use throughout in place of #if SUPPORT_FRAME_LINKONCE.
	(struct fde_entry): Rename cseg to cur_seg.
	(cfi_change_reg_numbers): Remove ATTRIBUTE_UNUSED.
	(get_cfi_seg): Likewise.  Use if (SUPPORT_FRAME_LINKONCE) rather
	that #if SUPPORT_FRAME_LINKONCE.
	(cfi_finish): Likewise.
@
text
@d71 8
a86 6
#if defined (TE_PE) || defined (TE_PEP)
#define SUPPORT_FRAME_LINKONCE 1
#else
#define SUPPORT_FRAME_LINKONCE 0
#endif

a272 61
struct cfi_insn_data
{
  struct cfi_insn_data *next;
#if SUPPORT_FRAME_LINKONCE
  segT cur_seg;
#endif
  int insn;
  union
  {
    struct
    {
      unsigned reg;
      offsetT offset;
    } ri;

    struct
    {
      unsigned reg1;
      unsigned reg2;
    } rr;

    unsigned r;
    offsetT i;

    struct
    {
      symbolS *lab1;
      symbolS *lab2;
    } ll;

    struct cfi_escape_data *esc;

    struct
    {
      unsigned reg, encoding;
      expressionS exp;
    } ea;
  } u;
};

struct fde_entry
{
  struct fde_entry *next;
#if SUPPORT_FRAME_LINKONCE
  segT cur_seg;
#endif
  symbolS *start_address;
  symbolS *end_address;
  struct cfi_insn_data *data;
  struct cfi_insn_data **last;
  unsigned char per_encoding;
  unsigned char lsda_encoding;
  expressionS personality;
  expressionS lsda;
  unsigned int return_column;
  unsigned int signal_frame;
#if SUPPORT_FRAME_LINKONCE
  int handled;
#endif
};

a554 8
/* Fake CFI type; outside the byte range of any real CFI insn.  */
#define CFI_adjust_cfa_offset	0x100
#define CFI_return_column	0x101
#define CFI_rel_offset		0x102
#define CFI_escape		0x103
#define CFI_signal_frame	0x104
#define CFI_val_encoded_addr	0x105

d1023 1
d1045 4
d1111 3
d1119 2
d1128 2
d1133 3
@


1.53
log
@	* dw2gencfi.c (SUPPORT_FRAME_LINKONCE): Define.  Use throughout
	file to conditionally compile code added 2011-04-26.
	(cfi_change_reg_numbers): Add ATTRIBUTE_UNUSED on params only used
	when SUPPORT_FRAME_LINKONCE.
	(get_cfi_seg): Likewise.  Reintroduce old code for when not
	SUPPORT_FRAME_LINKONCE.
	(cfi_finish): Move get_cfi_seg calls out of loop when not
	SUPPORT_FRAME_LINKONCE.  Avoid unused var warning.
@
text
@d86 11
a245 1
#endif
d315 1
a315 1
  segT cseg;
d384 2
a385 4
#if SUPPORT_FRAME_LINKONCE
  fde->cseg = is_now_linkonce_segment ();
  fde->handled = 0;
#endif
d409 1
a409 3
#if SUPPORT_FRAME_LINKONCE
  insn->cur_seg = is_now_linkonce_segment ();
#endif
d1578 1
a1578 2
#if SUPPORT_FRAME_LINKONCE
	  if (i->cur_seg != cie->cur_seg)
a1579 1
#endif
d1689 1
a1689 3
#if SUPPORT_FRAME_LINKONCE
    if (first->cur_seg == fde->cseg)
#endif
d1705 1
a1705 2
#if SUPPORT_FRAME_LINKONCE
      if (cie->cur_seg != fde->cseg)
a1706 1
#endif
d1805 1
a1805 3
#if SUPPORT_FRAME_LINKONCE
  cie->cur_seg = fde->cseg;
#endif
d1830 1
a1830 1
cfi_change_reg_numbers (struct cfi_insn_data *insn, segT ccseg ATTRIBUTE_UNUSED)
d1834 1
a1834 2
#if SUPPORT_FRAME_LINKONCE
      if (insn->cur_seg != ccseg)
a1835 1
#endif
d1877 1
a1877 2
get_cfi_seg (segT cseg ATTRIBUTE_UNUSED,
	     const char *base, flagword flags, int align)
d1879 3
a1881 2
#if SUPPORT_FRAME_LINKONCE
  struct dwcfi_seg_list *l;
d1883 1
a1883 1
  l = dwcfi_hash_find_or_make (cseg, base, flags);
d1885 8
a1892 6
  cseg = l->seg;
  subseg_set (cseg, l->subseg);
#else
  cseg = subseg_new (base, 0);
  bfd_set_section_flags (stdoutput, cseg, flags);
#endif
d1915 7
a1921 6
#if !SUPPORT_FRAME_LINKONCE
      /* Open .eh_frame section.  */
      cfi_seg = get_cfi_seg (NULL, ".eh_frame",
			     SEC_ALLOC | SEC_LOAD | SEC_DATA
			     | DWARF2_EH_FRAME_READ_ONLY,
			     EH_FRAME_ALIGNMENT);
d1923 1
a1923 1
      md_fix_up_eh_frame (cfi_seg);
d1925 1
a1925 2
      (void) cfi_seg;
#endif
d1927 1
d1943 17
a1959 16
#if SUPPORT_FRAME_LINKONCE
	      if (fde->handled != 0)
	        continue;
	      if (seek_next_seg && fde->cseg != ccseg)
	        {
		  seek_next_seg = 2;
		  continue;
		}
	      if (!seek_next_seg)
	        {
		  ccseg = fde->cseg;
		  /* Open .eh_frame section.  */
		  cfi_seg = get_cfi_seg (ccseg, ".eh_frame",
					 SEC_ALLOC | SEC_LOAD | SEC_DATA
					 | DWARF2_EH_FRAME_READ_ONLY,
					 EH_FRAME_ALIGNMENT);
d1961 1
a1961 1
		  md_fix_up_eh_frame (cfi_seg);
d1963 1
a1963 1
		  (void) cfi_seg;
d1965 3
a1967 1
		  seek_next_seg = 1;
a1968 2
	      fde->handled = 1;
#endif
d1983 3
a1985 4
#if SUPPORT_FRAME_LINKONCE
      for (fde = all_fde_data; fde ; fde = fde->next)
        fde->handled = 0;
#endif
d1994 5
a1998 5
#if !SUPPORT_FRAME_LINKONCE
      get_cfi_seg (NULL, ".debug_frame",
		   SEC_READONLY | SEC_DEBUGGING,
		   alignment);
#endif
d2013 19
a2031 16
#if SUPPORT_FRAME_LINKONCE
	      if (fde->handled != 0)
	        continue;
	      if (seek_next_seg && fde->cseg != ccseg)
	        {
		  seek_next_seg = 2;
		  continue;
		}
	      if (!seek_next_seg)
	        {
		  ccseg = fde->cseg;
		  /* Open .debug_frame section.  */
		  get_cfi_seg (ccseg, ".debug_frame",
			       SEC_READONLY | SEC_DEBUGGING,
			       alignment);
		  seek_next_seg = 1;
a2032 2
	      fde->handled = 1;
#endif
d2048 3
a2050 4
#if SUPPORT_FRAME_LINKONCE
      for (fde = all_fde_data; fde ; fde = fde->next)
        fde->handled = 0;
#endif
@


1.52
log
@	* dw2gencfi.c (dwcfi_seg_list): New struct.
	(dwcfi_hash): New static hash variable.
	(get_debugseg_name): New.
	(alloc_debugseg_item): New.
	(make_debug_seg): New.
	(dwcfi_hash_insert): New.
	(dwcfi_hash_find): New.
	(dwcfi_hash_find_or_make): New.
	(cfi_insn_data): New member cur_seg.
	(cie_entry): Likewise.
	(fde_entry): New cseg and handled members.
	(alloc_fde_entry): Initialize cseg member.
	(alloc_cfi_insn_data): Initialize cur_seg member.
	(dot_cfi_sections): Compare for beginning of
	section names via strncmp.
	(get_cfi_seg): New.
	(cfi_finish): Treat link-once sections.
	(is_now_linkonce_segment): New local helper.
	(output_cie): Ignore cie entries not member of current
	segment.
	(output_fde): Likewise.
	(select_cie_for_fde): Likewise.
	(cfi_change_reg_numbers): Add new argument for current segment
	and ignore insn elements, if not part of current segment.
	* ehopt.c (get_cie_info): Use strncmp for
	section name matching.
	(heck_eh_frame): Likewise.

	* coffcode.h (sec_to_styp_flags): Allow linkonce for
	debugging sections.

	* scripttempl/pe.sc: Handle .eh_frame($|.)* sections.
	* scripttempl/pep.sc: Likewise.

	* ld-pe/pe.exp: Add cfi/cfi32 tests.
	* ld-pe/cfi.d: New.
	* ld-pe/cfi32.d: New.
	* ld-pe/cfia.s: New.
	* ld-pe/cfib.s: New.
@
text
@d79 7
a150 1
#if defined (TE_PE) || defined (TE_PEP)
a155 1
#endif
d235 1
d264 1
d266 1
d304 1
d306 1
d317 1
d319 1
d325 1
d327 1
d374 1
d377 1
d401 1
d403 1
a403 1

d1572 1
d1575 1
d1685 4
a1688 4
    {
      if (first->cur_seg == fde->cseg)
        output_cfi_insn (first);
    }
d1703 5
a1707 2
      if (cie->cur_seg != fde->cseg
          || cie->return_column != fde->return_column
d1805 1
d1807 1
d1832 1
a1832 1
cfi_change_reg_numbers (struct cfi_insn_data *insn, segT ccseg)
d1836 1
d1839 1
d1881 2
a1882 1
get_cfi_seg (segT cseg, const char *base, flagword flags, int align)
d1884 1
d1889 8
a1896 3
  subseg_set (l->seg, l->subseg);
  record_alignment (l->seg, align);
  return l->seg;
d1917 13
a1932 1
	  cfi_seg = NULL;
d1934 1
d1944 1
d1962 2
d1968 1
d1981 1
a1981 1
      while (seek_next_seg == 2);
d1983 1
d1986 1
d1995 5
a2002 1
	  cfi_seg = NULL;
d2004 1
d2014 1
d2026 3
a2028 3
		  cfi_seg = get_cfi_seg (ccseg, ".debug_frame",
					 SEC_READONLY | SEC_DEBUGGING,
					 alignment);
d2032 1
d2046 1
a2046 1
      while (seek_next_seg == 2);
d2048 1
d2051 1
@


1.51
log
@Fix comment typo.
@
text
@d2 1
a2 1
   Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d40 1
a40 1
# define CFI_DIFF_LSDA_OK CFI_DIFF_EXPR_OK
d49 2
a50 2
#ifndef  DWARF2_LINE_MIN_INSN_LENGTH
# define DWARF2_LINE_MIN_INSN_LENGTH 1
d55 1
a55 1
# define DWARF2_FDE_RELOC_SIZE 4
d60 1
a60 1
# define DWARF2_EH_FRAME_READ_ONLY SEC_READONLY
d64 1
a64 1
# define EH_FRAME_ALIGNMENT (bfd_get_arch_size (stdoutput) == 64 ? 3 : 2)
d68 1
a68 1
# define tc_cfi_frame_initial_instructions() ((void)0)
d72 1
a72 1
# define DWARF2_FORMAT(SEC) dwarf2_format_32bit
d76 1
a76 1
# define DWARF2_ADDR_SIZE(bfd) (bfd_arch_bits_per_address (bfd) / 8)
d79 152
d249 2
a250 1
struct cfi_escape_data {
d258 1
d260 4
a263 2
  union {
    struct {
d268 2
a269 1
    struct {
d277 2
a278 1
    struct {
d285 2
a286 1
    struct {
d296 1
d307 1
d313 1
d323 1
a324 1
/* List of FDE entries.  */
d360 2
a361 1

d385 1
d392 1
a392 1
void 
d402 1
a402 1
void 
d421 1
a421 1
cfi_add_CFA_insn(int insn)
d638 1
a638 1
tc_parse_to_dw2regnum(expressionS *exp)
d1020 1
a1020 1
  
d1083 2
a1084 1
	if (strcmp (name, ".eh_frame") == 0)
d1086 1
a1086 1
	else if (strcmp (name, ".debug_frame") == 0)
d1418 1
a1418 1
      
d1552 8
a1559 2
    for (i = cie->first; i != cie->last; i = i->next)
      output_cfi_insn (i);
d1666 4
a1669 1
    output_cfi_insn (first);
d1684 2
a1685 1
      if (cie->return_column != fde->return_column
d1783 1
d1808 1
a1808 1
cfi_change_reg_numbers (struct cfi_insn_data *insn)
d1811 12
a1822 9
    switch (insn->insn)
      {
      case DW_CFA_advance_loc:
      case DW_CFA_def_cfa_offset:
      case DW_CFA_remember_state:
      case DW_CFA_restore_state:
      case DW_CFA_GNU_window_save:
      case CFI_escape:
	break;
d1824 4
a1827 4
      case DW_CFA_def_cfa:
      case DW_CFA_offset:
	insn->u.ri.reg = md_reg_eh_frame_to_debug_frame (insn->u.ri.reg);
	break;
d1829 6
a1834 6
      case DW_CFA_def_cfa_register:
      case DW_CFA_undefined:
      case DW_CFA_same_value:
      case DW_CFA_restore:
	insn->u.r = md_reg_eh_frame_to_debug_frame (insn->u.r);
	break;
d1836 4
a1839 4
      case DW_CFA_register:
	insn->u.rr.reg1 = md_reg_eh_frame_to_debug_frame (insn->u.rr.reg1);
	insn->u.rr.reg2 = md_reg_eh_frame_to_debug_frame (insn->u.rr.reg2);
	break;
d1841 3
a1843 3
      case CFI_val_encoded_addr:
	insn->u.ea.reg = md_reg_eh_frame_to_debug_frame (insn->u.ea.reg);
	break;
d1845 4
a1848 3
      default:
	abort ();
      }
d1851 1
a1851 1
#define cfi_change_reg_numbers(insn) do { } while (0)
d1854 12
d1869 2
a1870 1
  segT cfi_seg;
d1872 2
a1873 1
  int save_flag_traditional_format;
a1879 12
      /* Open .eh_frame section.  */
      cfi_seg = subseg_new (".eh_frame", 0);
      bfd_set_section_flags (stdoutput, cfi_seg,
			     SEC_ALLOC | SEC_LOAD | SEC_DATA
			     | DWARF2_EH_FRAME_READ_ONLY);
      subseg_set (cfi_seg, 0);
      record_alignment (cfi_seg, EH_FRAME_ALIGNMENT);

#ifdef md_fix_up_eh_frame
      md_fix_up_eh_frame (cfi_seg);
#endif

d1884 11
a1894 4
      for (fde = all_fde_data; fde ; fde = fde->next)
	{
	  struct cfi_insn_data *first;
	  struct cie_entry *cie;
d1896 1
a1896 1
	  if (fde->end_address == NULL)
d1898 31
a1928 2
	      as_bad (_("open CFI at the end of file; missing .cfi_endproc directive"));
	      fde->end_address = fde->start_address;
d1930 2
d1933 2
a1934 4
	  cie = select_cie_for_fde (fde, TRUE, &first, 2);
	  output_fde (fde, cie, TRUE, first,
		      fde->next == NULL ? EH_FRAME_ALIGNMENT : 2);
	}
a1940 1
      struct cie_entry *cie, *cie_next;
d1943 11
a1953 6
      for (cie = cie_root; cie; cie = cie_next)
	{
	  cie_next = cie->next;
	  free ((void *) cie);
	}
      cie_root = NULL;
d1955 1
a1955 12
      /* Open .debug_frame section.  */
      cfi_seg = subseg_new (".debug_frame", 0);
      bfd_set_section_flags (stdoutput, cfi_seg,
			     SEC_READONLY | SEC_DEBUGGING);
      subseg_set (cfi_seg, 0);
      record_alignment (cfi_seg, alignment);

      for (fde = all_fde_data; fde ; fde = fde->next)
	{
	  struct cfi_insn_data *first;

	  if (fde->end_address == NULL)
d1957 28
a1984 2
	      as_bad (_("open CFI at the end of file; missing .cfi_endproc directive"));
	      fde->end_address = fde->start_address;
d1986 2
d1989 2
a1990 6
	  fde->per_encoding = DW_EH_PE_omit;
	  fde->lsda_encoding = DW_EH_PE_omit;
	  cfi_change_reg_numbers (fde->data);
	  cie = select_cie_for_fde (fde, FALSE, &first, alignment);
	  output_fde (fde, cie, FALSE, first, alignment);
	}
@


1.50
log
@	* dw2gencfi.c (dot_cfi_dummy): New.
	(cfi_pseudo_table) [!TARGET_USE_CFIPOP]: New.
	* read.c (pobegin): Unconditionally call cfi_pop_insert.
@
text
@d1761 1
a1761 1
/* Emit an intelligable error message for missing support.  */
@


1.49
log
@	* dw2gencfi.c (TC_DWARF2_EMIT_OFFSET): Provide default.
	(output_fde): Use it.  Make sure to fully init exp before using it.
testsuite/
	* gas/cfi/cfi-common-1.d: Use objdump instead of readelf to dump.
	* gas/cfi/cfi-common-2.d, gas/cfi/cfi-common-3.d,
	gas/cfi/cfi-common-4.d, gas/cfi/cfi-common-6.d,
	gas/cfi/cfi-common-7.d, gas/cfi/cfi-x86_64.d: Likewise.
	* gas/cfi/cfi-x86_64.s: Remove .type directives.
	* gas/cfi/cfi.exp: Run for pecoff objects too.
	* gas/cfi/reloc-pe-i386.d, gas/cfi/reloc-pe-i386.s: New test.
@
text
@d1760 37
@


1.48
log
@2010-03-15  Thomas Schwinge  <thomas@@codesourcery.com>

	* dw2gencfi.c (output_cie): Consider emitting the S augmentation in all
	cases, and not only for .eh_frame.
@
text
@d79 18
d1426 1
d1429 2
d1434 1
a1434 3
      exp.X_op = O_symbol;
      exp.X_add_symbol = cie->start_address;
      exp.X_op_symbol = NULL;
a1435 1
  emit_expr (&exp, offset_size);		/* CIE offset.  */
d1439 2
a1447 1
      exp.X_op_symbol = NULL;
d1458 1
d1460 1
d1468 1
@


1.47
log
@2010-03-15  Thomas Schwinge  <thomas@@codesourcery.com>

	* dw2gencfi.c (output_cie): Make it more explicit which code paths
	belong to .eh_frame only.
@
text
@a1305 2
      if (cie->signal_frame)
	out_one ('S');
d1307 2
@


1.46
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d2 1
a2 1
   Copyright 2003, 2004, 2005, 2006, 2007, 2008, 2009
d1322 2
a1323 7
    }
  if (cie->per_encoding != DW_EH_PE_omit)
    {
      offsetT size = encoding_size (cie->per_encoding);
      out_one (cie->per_encoding);
      exp = cie->personality;
      if ((cie->per_encoding & 0x70) == DW_EH_PE_pcrel)
d1325 5
d1331 3
a1333 3
	  exp.X_op = O_subtract;
	  exp.X_op_symbol = symbol_temp_new_now ();
	  emit_expr (&exp, size);
d1335 1
a1335 1
	  tc_cfi_emit_pcrel_expr (&exp, size);
d1337 1
a1337 1
	  abort ();
d1339 3
d1343 3
a1345 2
      else
	emit_expr (&exp, size);
a1346 2
  if (cie->lsda_encoding != DW_EH_PE_omit)
    out_one (cie->lsda_encoding);
@


1.45
log
@2009-11-04  Daniel Jacobowitz  <dan@@codesourcery.com>
	    Maxim Kuvyrkov  <maxim@@codesourcery.com>

	* config/tc-m68k.h (CF_DIFF_EXPR_OK): Define to 0 for uClinux.
	(CFI_DIFF_LSDA_OK): Define.
	* config/te-uclinux.h: New file.
	* configure.tgt (m68k-uclinux): Define em.
	* dw2gencfi.c (CFI_DIFF_LSDA_OK): New macro.
	(dot_cfi_lsda, output_fde): Use instead of CFI_DIFF_EXPR_OK.
@
text
@a1718 1
	  struct cie_entry *cie;
@


1.44
log
@	* dw2gencfi.c: Include dwarf2dbg.h.
	(DWARF2_FORMAT): Define if not defined.
	(dot_cfi_sections): New function.
	(cfi_pseudo_table): Handle .cfi_sections.
	(CFI_EMIT_eh_frame, CFI_EMIT_debug_frame): Define.
	(cfi_sections): New variable.
	(output_cie, output_fde, select_cie_for_fde): Add eh_frame
	argument, add supporting for outputting .debug_frame
	section.
	(cfi_change_reg_numbers): New function or macro.
	(cfi_finish): Only emit .eh_frame if
	cfi_sections & CFI_EMIT_eh_frame.  Emit .debug_frame if
	cfi_sections & CFI_EMIT_debug_frame.
	* config/tc-ppc.h (md_reg_eh_frame_to_debug_frame): Define.
	* doc/as.texinfo (CFI directives): Document .cfi_sections.
@
text
@d39 8
d769 1
a769 1
#if CFI_DIFF_EXPR_OK || defined tc_cfi_emit_pcrel_expr
d1456 1
a1456 1
#if CFI_DIFF_EXPR_OK
@


1.43
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        * as.c (main): Call dwarf2_init.
        * config/obj-elf.c (struct group_list): New field.
        (build_group_lists): Use hash lookup.
        (free_section_idx): New function.
        (elf_frob_file): Adjust.
        * dwarf2dbg.c (all_segs_hash, last_seg_ptr): New variables.
        (get_line_subseg): Adjust.
        (dwarf2_init): New function.
        * dwarf2dbg.h (dwarf2_init): New declaration.
@
text
@d26 1
d63 4
d394 1
d411 1
d874 50
d1254 1
a1254 1
output_cie (struct cie_entry *cie)
d1261 1
d1272 8
a1279 1
  emit_expr (&exp, 4);				/* Length.  */
d1281 8
a1288 1
  out_four (0);					/* CIE id.  */
d1290 11
a1300 8
  out_one ('z');				/* Augmentation.  */
  if (cie->per_encoding != DW_EH_PE_omit)
    out_one ('P');
  if (cie->lsda_encoding != DW_EH_PE_omit)
    out_one ('L');
  out_one ('R');
  if (cie->signal_frame)
    out_one ('S');
d1308 7
a1314 4
  augmentation_size = 1 + (cie->lsda_encoding != DW_EH_PE_omit);
  if (cie->per_encoding != DW_EH_PE_omit)
    augmentation_size += 1 + encoding_size (cie->per_encoding);
  out_uleb128 (augmentation_size);		/* Augmentation size.  */
d1355 2
a1356 1
  out_one (enc);
d1362 1
a1362 1
  frag_align (2, DW_CFA_nop, 0);
d1368 2
a1369 1
	    struct cfi_insn_data *first, int align)
d1374 3
d1385 9
a1393 1
  emit_expr (&exp, 4);				/* Length.  */
d1396 12
a1407 3
  exp.X_add_symbol = after_size_address;
  exp.X_op_symbol = cie->start_address;
  emit_expr (&exp, 4);				/* CIE offset.  */
d1409 2
d1412 3
a1414 3
  exp.X_add_symbol = fde->start_address;
  exp.X_op_symbol = symbol_temp_new_now ();
  emit_expr (&exp, DWARF2_FDE_RELOC_SIZE);	/* Code offset.  */
d1416 3
a1418 3
  exp.X_op = O_symbol;
  exp.X_add_symbol = fde->start_address;
  exp.X_op_symbol = NULL;
d1420 1
a1420 1
  tc_cfi_emit_pcrel_expr (&exp, DWARF2_FDE_RELOC_SIZE);	 /* Code offset.  */
d1422 1
a1422 1
  emit_expr (&exp, DWARF2_FDE_RELOC_SIZE);	/* Code offset.  */
a1423 1
  exp.X_op = O_subtract;
d1425 8
d1434 1
d1437 1
a1437 1
  emit_expr (&exp, DWARF2_FDE_RELOC_SIZE);
d1440 2
a1441 1
  out_uleb128 (augmentation_size);		/* Augmentation size.  */
d1470 2
a1471 1
select_cie_for_fde (struct fde_entry *fde, struct cfi_insn_data **pfirst)
d1592 2
a1593 2
   
  output_cie (cie);
d1598 44
d1652 9
a1660 7
  /* Open .eh_frame section.  */
  cfi_seg = subseg_new (".eh_frame", 0);
  bfd_set_section_flags (stdoutput, cfi_seg,
			 SEC_ALLOC | SEC_LOAD | SEC_DATA
			 | DWARF2_EH_FRAME_READ_ONLY);
  subseg_set (cfi_seg, 0);
  record_alignment (cfi_seg, EH_FRAME_ALIGNMENT);
d1663 1
a1663 1
  md_fix_up_eh_frame (cfi_seg);
d1666 3
a1668 3
  /* Make sure check_eh_frame doesn't do anything with our output.  */
  save_flag_traditional_format = flag_traditional_format;
  flag_traditional_format = 1;
d1670 20
a1689 1
  for (fde = all_fde_data; fde ; fde = fde->next)
d1691 2
a1692 2
      struct cfi_insn_data *first;
      struct cie_entry *cie;
d1694 1
a1694 1
      if (fde->end_address == NULL)
d1696 2
a1697 2
	  as_bad (_("open CFI at the end of file; missing .cfi_endproc directive"));
	  fde->end_address = fde->start_address;
d1699 13
d1713 12
a1724 2
      cie = select_cie_for_fde (fde, &first);
      output_fde (fde, cie, first, fde->next == NULL ? EH_FRAME_ALIGNMENT : 2);
a1725 2

  flag_traditional_format = save_flag_traditional_format;
@


1.42
log
@        * gas/app, gas/as.c, gas/as.h, gas/atof-generic.c, gas/cgen.c,
        gas/config/atof-ieee.c, gas/config/obj-aout.c,
        gas/config/obj-coff.c, gas/config/obj-ecoff.c,
        gas/config/obj-elf.c, gas/config/obj-som.c, gas/config/tc-alpha.c,
        gas/config/tc-arc.c, gas/config/tc-arm.c, gas/config/tc-cr16.c,
        gas/config/tc-cris.c, gas/config/tc-crx.c, gas/config/tc-d30v.c,
        gas/config/tc-dlx.c, gas/config/tc-hppa.c, gas/config/tc-i370.c,
        gas/config/tc-i386-intel.c, gas/config/tc-i386.c,
        gas/config/tc-i860.c, gas/config/tc-i960.c, gas/config/tc-ia64.c,
        gas/config/tc-iq2000.c, gas/config/tc-m32c.c,
        gas/config/tc-m32r.c, gas/config/tc-m68hc11.c,
        gas/config/tc-m68k.c, gas/config/tc-maxq.c, gas/config/tc-mcore.c,
        gas/config/tc-mep.c, gas/config/tc-mips.c, gas/config/tc-mmix.c,
        gas/config/tc-mn10300.c, gas/config/tc-moxie.c,
        gas/config/tc-ns32k.c, gas/config/tc-pj.c, gas/config/tc-ppc.c,
        gas/config/tc-s390.c, gas/config/tc-score.c,
        gas/config/tc-score7.c, gas/config/tc-sh.c, gas/config/tc-sparc.c,
        gas/config/tc-spu.c, gas/config/tc-tic30.c, gas/config/tc-vax.c,
        gas/config/tc-xtensa.c, gas/config/xtensa-relax.c,
        gas/dw2gencfi.c, gas/dwarf2dbg.c, gas/ehopt.c, gas/expr.c,
        gas/frags.c, gas/input-file.c, gas/read.c, gas/sb.c,
        gas/subsegs.c, gas/symbols.c, gas/write.c: Change the name of the
        gas macro `assert' to `gas_assert'.
@
text
@d66 4
d94 1
a94 4
    struct cfi_escape_data {
      struct cfi_escape_data *next;
      expressionS exp;
    } *esc;
d159 2
a160 1
  struct fde_entry *fde = xcalloc (1, sizeof (struct fde_entry));
d162 2
a163 1
  frchain_now->frch_cfi_data = xcalloc (1, sizeof (struct frch_cfi_data));
d185 2
a186 1
  struct cfi_insn_data *insn = xcalloc (1, sizeof (struct cfi_insn_data));
d360 1
a360 1
  p = xmalloc (sizeof (*p));
d644 1
a644 1
      e = xmalloc (sizeof (*e));
d1461 1
a1461 1
  cie = xmalloc (sizeof (struct cie_entry));
@


1.42.4.1
log
@        * po/bfd.pot: Updated by the Translation project.
        * po/binutils.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gold.pot: Updated by the Translation project.
        * po/gprof.pot: Updated by the Translation project.
        * po/sv.po: Updated Swedish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.
        * po/ld.pot: Updated by the Translation project.
        * po/fi.po: Updated Finnish translation.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.

        Updated soruces in ld/* to compile cleanly with -Wc++-compat:
        * ld.h (enum endian_enum,enum symbolic_enum,enum dynamic_list_enum): Move to top level.
        * ldcref.c: Add casts.
        * ldctor.c: Add casts.
        * ldexp.c
        * ldexp.h (enum node_tree_enum,enum phase_enum): Move to top level.
        * ldlang.c: Add casts. (lang_insert_orphan): Use enum name instead of integer.
        * ldlang.h (enum statement_enum): Move to top level.
        * ldmain.c: Add casts.
        * ldwrite.c: Add casts.
        * lexsup.c: Add casts. (enum control_enum): Move to top level.
        * mri.c: Add casts. (mri_draw_tree): Use enum name instead of integer.

        Updated sources to compile cleanly with -Wc++-compat:
        * basic_blocks.c: Add casts.
        * cg_dfn.c: Add cast.
        * corefile.c: Add casts.
        * gmon_io.c: Add casts.
        * hist.c: Add cast.
        * source.c: Add cast.
        * sym_ids.c (struct match): Moved to top level.
@
text
@a65 4
struct cfi_escape_data {
  struct cfi_escape_data *next;
  expressionS exp;
};
d90 4
a93 1
    struct cfi_escape_data *esc;
d158 1
a158 2
  struct fde_entry *fde = (struct fde_entry *)
      xcalloc (1, sizeof (struct fde_entry));
d160 1
a160 2
  frchain_now->frch_cfi_data = (struct frch_cfi_data *)
      xcalloc (1, sizeof (struct frch_cfi_data));
d182 1
a182 2
  struct cfi_insn_data *insn = (struct cfi_insn_data *)
      xcalloc (1, sizeof (struct cfi_insn_data));
d356 1
a356 1
  p = (struct cfa_save_data *) xmalloc (sizeof (*p));
d640 1
a640 1
      e = (struct cfi_escape_data *) xmalloc (sizeof (*e));
d1457 1
a1457 1
  cie = (struct cie_entry *) xmalloc (sizeof (struct cie_entry));
@


1.42.4.2
log
@2009-10-06  Jakub Jelinek  <jakub@@redhat.com>

	* dw2gencfi.c: Include dwarf2dbg.h.
	(DWARF2_FORMAT): Define if not defined.
	(dot_cfi_sections): New function.
	(cfi_pseudo_table): Handle .cfi_sections.
	(CFI_EMIT_eh_frame, CFI_EMIT_debug_frame): Define.
	(cfi_sections): New variable.
	(output_cie, output_fde, select_cie_for_fde): Add eh_frame
	argument, add supporting for outputting .debug_frame
	section.
	(cfi_change_reg_numbers): New function or macro.
	(cfi_finish): Only emit .eh_frame if
	cfi_sections & CFI_EMIT_eh_frame.  Emit .debug_frame if
	cfi_sections & CFI_EMIT_debug_frame.
	* config/tc-ppc.h (md_reg_eh_frame_to_debug_frame): Define.
	* doc/as.texinfo (CFI directives): Document .cfi_sections.
@
text
@a25 1
#include "dwarf2dbg.h"
a61 4
#ifndef DWARF2_FORMAT
# define DWARF2_FORMAT(SEC) dwarf2_format_32bit
#endif

a388 1
static void dot_cfi_sections (int);
a404 1
    { "cfi_sections", dot_cfi_sections, 0 },
a866 50
/* By default emit .eh_frame only, not .debug_frame.  */
#define CFI_EMIT_eh_frame	(1 << 0)
#define CFI_EMIT_debug_frame	(1 << 1)
static int cfi_sections = CFI_EMIT_eh_frame;

static void
dot_cfi_sections (int ignored ATTRIBUTE_UNUSED)
{
  int sections = 0;

  SKIP_WHITESPACE ();
  if (is_name_beginner (*input_line_pointer))
    while (1)
      {
	char *name, c;

	name = input_line_pointer;
	c = get_symbol_end ();

	if (strcmp (name, ".eh_frame") == 0)
	  sections |= CFI_EMIT_eh_frame;
	else if (strcmp (name, ".debug_frame") == 0)
	  sections |= CFI_EMIT_debug_frame;
	else
	  {
	    *input_line_pointer = c;
	    input_line_pointer = name;
	    break;
	  }

	*input_line_pointer = c;
	SKIP_WHITESPACE ();
	if (*input_line_pointer == ',')
	  {
	    name = input_line_pointer++;
	    SKIP_WHITESPACE ();
	    if (!is_name_beginner (*input_line_pointer))
	      {
		input_line_pointer = name;
		break;
	      }
	  }
	else if (is_name_beginner (*input_line_pointer))
	  break;
      }

  demand_empty_rest_of_line ();
  cfi_sections = sections;
}

d1197 1
a1197 1
output_cie (struct cie_entry *cie, bfd_boolean eh_frame, int align)
a1203 1
  enum dwarf2_format fmt = DWARF2_FORMAT (now_seg);
d1214 1
a1214 8
  if (eh_frame || fmt == dwarf2_format_32bit)
    emit_expr (&exp, 4);			/* Length.  */
  else
    {
      if (fmt == dwarf2_format_64bit)
	out_four (-1);
      emit_expr (&exp, 8);			/* Length.  */
    }
d1216 1
a1216 8
  if (eh_frame)
    out_four (0);				/* CIE id.  */
  else
    {
      out_four (-1);				/* CIE id.  */
      if (fmt != dwarf2_format_32bit)
	out_four (-1);
    }
d1218 8
a1225 11
  if (eh_frame)
    {
      out_one ('z');				/* Augmentation.  */
      if (cie->per_encoding != DW_EH_PE_omit)
	out_one ('P');
      if (cie->lsda_encoding != DW_EH_PE_omit)
	out_one ('L');
      out_one ('R');
      if (cie->signal_frame)
	out_one ('S');
    }
d1233 4
a1236 7
  if (eh_frame)
    {
      augmentation_size = 1 + (cie->lsda_encoding != DW_EH_PE_omit);
      if (cie->per_encoding != DW_EH_PE_omit)
	augmentation_size += 1 + encoding_size (cie->per_encoding);
      out_uleb128 (augmentation_size);		/* Augmentation size.  */
    }
d1277 1
a1277 2
  if (eh_frame)
    out_one (enc);
d1283 1
a1283 1
  frag_align (align, DW_CFA_nop, 0);
d1289 1
a1289 2
	    bfd_boolean eh_frame, struct cfi_insn_data *first,
	    int align)
a1293 3
  enum dwarf2_format fmt = DWARF2_FORMAT (now_seg);
  int offset_size;
  int addr_size;
d1302 1
a1302 9
  if (eh_frame || fmt == dwarf2_format_32bit)
    offset_size = 4;
  else
    {
      if (fmt == dwarf2_format_64bit)
	out_four (-1);
      offset_size = 8;
    }
  emit_expr (&exp, offset_size);		/* Length.  */
d1305 3
a1307 12
  if (eh_frame)
    {
      exp.X_add_symbol = after_size_address;
      exp.X_op_symbol = cie->start_address;
    }
  else
    {
      exp.X_op = O_symbol;
      exp.X_add_symbol = cie->start_address;
      exp.X_op_symbol = NULL;
    }
  emit_expr (&exp, offset_size);		/* CIE offset.  */
a1308 2
  if (eh_frame)
    {
d1310 3
a1312 3
      exp.X_add_symbol = fde->start_address;
      exp.X_op_symbol = symbol_temp_new_now ();
      emit_expr (&exp, DWARF2_FDE_RELOC_SIZE);	/* Code offset.  */
d1314 3
a1316 3
      exp.X_op = O_symbol;
      exp.X_add_symbol = fde->start_address;
      exp.X_op_symbol = NULL;
d1318 1
a1318 1
      tc_cfi_emit_pcrel_expr (&exp, DWARF2_FDE_RELOC_SIZE);	 /* Code offset.  */
d1320 1
a1320 1
      emit_expr (&exp, DWARF2_FDE_RELOC_SIZE);	/* Code offset.  */
d1322 1
a1323 8
      addr_size = DWARF2_FDE_RELOC_SIZE;
    }
  else
    {
      exp.X_add_symbol = fde->start_address;
      addr_size = DWARF2_ADDR_SIZE (stdoutput);
      emit_expr (&exp, addr_size);
    }
a1324 1
  exp.X_op = O_subtract;
d1327 1
a1327 1
  emit_expr (&exp, addr_size);
d1330 1
a1330 2
  if (eh_frame)
    out_uleb128 (augmentation_size);		/* Augmentation size.  */
d1359 1
a1359 2
select_cie_for_fde (struct fde_entry *fde, bfd_boolean eh_frame,
		    struct cfi_insn_data **pfirst, int align)
d1480 2
a1481 2

  output_cie (cie, eh_frame, align);
a1485 44
#ifdef md_reg_eh_frame_to_debug_frame
static void
cfi_change_reg_numbers (struct cfi_insn_data *insn)
{
  for (; insn; insn = insn->next)
    switch (insn->insn)
      {
      case DW_CFA_advance_loc:
      case DW_CFA_def_cfa_offset:
      case DW_CFA_remember_state:
      case DW_CFA_restore_state:
      case DW_CFA_GNU_window_save:
      case CFI_escape:
	break;

      case DW_CFA_def_cfa:
      case DW_CFA_offset:
	insn->u.ri.reg = md_reg_eh_frame_to_debug_frame (insn->u.ri.reg);
	break;

      case DW_CFA_def_cfa_register:
      case DW_CFA_undefined:
      case DW_CFA_same_value:
      case DW_CFA_restore:
	insn->u.r = md_reg_eh_frame_to_debug_frame (insn->u.r);
	break;

      case DW_CFA_register:
	insn->u.rr.reg1 = md_reg_eh_frame_to_debug_frame (insn->u.rr.reg1);
	insn->u.rr.reg2 = md_reg_eh_frame_to_debug_frame (insn->u.rr.reg2);
	break;

      case CFI_val_encoded_addr:
	insn->u.ea.reg = md_reg_eh_frame_to_debug_frame (insn->u.ea.reg);
	break;

      default:
	abort ();
      }
}
#else
#define cfi_change_reg_numbers(insn) do { } while (0)
#endif

d1496 7
a1502 9
  if ((cfi_sections & CFI_EMIT_eh_frame) != 0)
    {
      /* Open .eh_frame section.  */
      cfi_seg = subseg_new (".eh_frame", 0);
      bfd_set_section_flags (stdoutput, cfi_seg,
			     SEC_ALLOC | SEC_LOAD | SEC_DATA
			     | DWARF2_EH_FRAME_READ_ONLY);
      subseg_set (cfi_seg, 0);
      record_alignment (cfi_seg, EH_FRAME_ALIGNMENT);
d1505 1
a1505 1
      md_fix_up_eh_frame (cfi_seg);
d1508 3
a1510 3
      /* Make sure check_eh_frame doesn't do anything with our output.  */
      save_flag_traditional_format = flag_traditional_format;
      flag_traditional_format = 1;
d1512 1
a1512 20
      for (fde = all_fde_data; fde ; fde = fde->next)
	{
	  struct cfi_insn_data *first;
	  struct cie_entry *cie;

	  if (fde->end_address == NULL)
	    {
	      as_bad (_("open CFI at the end of file; missing .cfi_endproc directive"));
	      fde->end_address = fde->start_address;
	    }

	  cie = select_cie_for_fde (fde, TRUE, &first, 2);
	  output_fde (fde, cie, TRUE, first,
		      fde->next == NULL ? EH_FRAME_ALIGNMENT : 2);
	}

      flag_traditional_format = save_flag_traditional_format;
    }

  if ((cfi_sections & CFI_EMIT_debug_frame) != 0)
d1514 2
a1515 2
      struct cie_entry *cie, *cie_next;
      int alignment = ffs (DWARF2_ADDR_SIZE (stdoutput)) - 1;
d1517 1
a1517 1
      for (cie = cie_root; cie; cie = cie_next)
d1519 2
a1520 2
	  cie_next = cie->next;
	  free ((void *) cie);
a1521 1
      cie_root = NULL;
d1523 3
a1525 11
      /* Open .debug_frame section.  */
      cfi_seg = subseg_new (".debug_frame", 0);
      bfd_set_section_flags (stdoutput, cfi_seg,
			     SEC_READONLY | SEC_DEBUGGING);
      subseg_set (cfi_seg, 0);
      record_alignment (cfi_seg, alignment);

      for (fde = all_fde_data; fde ; fde = fde->next)
	{
	  struct cfi_insn_data *first;
	  struct cie_entry *cie;
d1527 1
a1527 13
	  if (fde->end_address == NULL)
	    {
	      as_bad (_("open CFI at the end of file; missing .cfi_endproc directive"));
	      fde->end_address = fde->start_address;
	    }

	  fde->per_encoding = DW_EH_PE_omit;
	  fde->lsda_encoding = DW_EH_PE_omit;
	  cfi_change_reg_numbers (fde->data);
	  cie = select_cie_for_fde (fde, FALSE, &first, alignment);
	  output_fde (fde, cie, FALSE, first, alignment);
	}
    }
@


1.41
log
@	* dw2gencfi.c (output_cfi_insn): Initialize fragment before rs_cfa
	to DW_CFA_advance_loc4.

	* gas/cfi/cfi-common-7.d: New test.
	* gas/cfi/cfi-common-7.s: New.
	* gas/cfi/cfi.exp: Add cfi-common-7 test.
@
text
@d288 1
a288 1
  assert (DWARF2_CIE_DATA_ALIGNMENT != 0);
@


1.40
log
@	* Makefile.am (ehopt.o): Add struc-symbol.h.
	* Makefile.in: Regenerated.
	* ehopt.c: Include struc-symbol.h.
	(check_eh_frame): For very small O_constant DW_CFA_advance_loc4
	create correct DW_CFA_advance_loc.  Handle O_subtract only
	for code alignment factor 1, otherwise handle O_divide or
	O_right_shift of O_subtract and O_constant.
	(eh_frame_estimate_size_before_relax): Always divide by ca.
	(eh_frame_convert_frag): Likewise.

	* dw2gencfi.c (output_cfi_insn): Scale DW_CFA_advance_loc1,
	DW_CFA_advance_loc2 and DW_CFA_advance_loc4 outputs.
@
text
@d2 2
a3 1
   Copyright 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
d1005 1
a1005 1
	    frag_more (1);
@


1.39
log
@	* dw2gencfi.c (cfi_finish): Deal with md_fix_up_eh_frame.
	* config/tc-i386.h (md_fix_up_eh_frame): Define on Solaris.
	(i386_solaris_fix_up_eh_frame): Declare.
	* config/tc-i386.c (i386_solaris_fix_up_eh_frame): New function.
@
text
@d2 1
a2 1
   Copyright 2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
d975 1
a975 1
	    else if (delta <= 0xFF)
d978 1
a978 1
		out_one (delta);
d980 1
a980 1
	    else if (delta <= 0xFFFF)
d983 1
a983 1
		out_two (delta);
d988 1
a988 1
		out_four (delta);
@


1.38
log
@	* dw2gencfi.c (output_cfi_insn): Fix typo in invocation of
	tc_cfi_emit_pcrel_expr macro.
@
text
@d1499 4
@


1.37
log
@include/
	* elf/dwarf2.h (DW_OP_GNU_encoded_addr): New.
binutils/
	* dwarf.c (size_of_encoded_value, get_encoded_value): Move up.
	(decode_location_expression): Add section parameter.  Handle
	DW_OP_GNU_encoded_addr.
	(read_and_display_attr_value): Update decode_location_expression call.
	(display_debug_loc, display_debug_frames): Likewise.
gas/
        * dw2gencfi.c (DWARF2_ADDR_SIZE): Provide default.
        (struct cfi_insn_data): Add ea member.
        (CFI_val_encoded_addr, dot_cfi_val_encoded_addr): New.
        (output_cfi_insn): Handle CFI_val_encoded_addr.
        (select_cie_for_fde): Don't match CFI_val_encoded_addr.
        * doc/as.texinfo (.cfi_val_encoded_addr): Document.
@
text
@d1155 1
a1155 1
		tc_cfi_emit_pcrel_expr (&insn.u.ea.exp, encoding_size);
@


1.36
log
@	* dw2gencfi.c (CFI_DIFF_EXPR_OK): Define if not defined.
	(dot_cfi_personality): Use CFI_DIFF_EXPR_OK instead of DIFF_EXPR_OK.
	(dot_cfi_lsda, output_cie, output_fde): Likewise.
	* config/tc-hppa.h (CFI_DIFF_EXPR_OK): Define.
@
text
@d61 4
d93 5
d388 1
d396 1
d420 1
d669 1
a669 1
  encoding = get_absolute_expression ();
d739 1
a739 1
  encoding = get_absolute_expression ();
d798 65
d1108 58
d1430 1
d1446 2
a1447 1
	      || j->insn == CFI_escape))
d1469 2
a1470 1
	|| i->insn == CFI_escape)
@


1.36.2.1
log
@include/
        * elf/dwarf2.h (DW_OP_GNU_encoded_addr): New.
binutils/
        * dwarf.c (size_of_encoded_value, get_encoded_value): Move up.
        (decode_location_expression): Add section parameter.  Handle
        DW_OP_GNU_encoded_addr.
        (read_and_display_attr_value): Update decode_location_expression call.
        (display_debug_loc, display_debug_frames): Likewise.
gas/
        * dw2gencfi.c (DWARF2_ADDR_SIZE): Provide default.
        (struct cfi_insn_data): Add ea member.
        (CFI_val_encoded_addr, dot_cfi_val_encoded_addr): New.
        (output_cfi_insn): Handle CFI_val_encoded_addr.
        (select_cie_for_fde): Don't match CFI_val_encoded_addr.
        * doc/as.texinfo (.cfi_val_encoded_addr): Document.
@
text
@a60 4
#ifndef DWARF2_ADDR_SIZE
# define DWARF2_ADDR_SIZE(bfd) (bfd_arch_bits_per_address (bfd) / 8)
#endif

a88 5

    struct {
      unsigned reg, encoding;
      expressionS exp;
    } ea;
a378 1
static void dot_cfi_val_encoded_addr (int);
a385 1
#define CFI_val_encoded_addr	0x105
a408 1
    { "cfi_val_encoded_addr", dot_cfi_val_encoded_addr, 0 },
d657 1
a657 1
  encoding = cfi_parse_const ();
d727 1
a727 1
  encoding = cfi_parse_const ();
a785 65
dot_cfi_val_encoded_addr (int ignored ATTRIBUTE_UNUSED)
{
  struct cfi_insn_data *insn_ptr;
  offsetT encoding;

  if (frchain_now->frch_cfi_data == NULL)
    {
      as_bad (_("CFI instruction used without previous .cfi_startproc"));
      ignore_rest_of_line ();
      return;
    }

  /* If the last address was not at the current PC, advance to current.  */
  if (symbol_get_frag (frchain_now->frch_cfi_data->last_address) != frag_now
      || S_GET_VALUE (frchain_now->frch_cfi_data->last_address)
	 != frag_now_fix ())
    cfi_add_advance_loc (symbol_temp_new_now ());

  insn_ptr = alloc_cfi_insn_data ();
  insn_ptr->insn = CFI_val_encoded_addr;
  
  insn_ptr->u.ea.reg = cfi_parse_reg ();

  cfi_parse_separator ();
  encoding = cfi_parse_const ();
  if ((encoding & 0xff) != encoding
      || ((encoding & 0x70) != 0
#if CFI_DIFF_EXPR_OK || defined tc_cfi_emit_pcrel_expr
	  && (encoding & 0x70) != DW_EH_PE_pcrel
#endif
	  )
	 /* leb128 can be handled, but does something actually need it?  */
      || (encoding & 7) == DW_EH_PE_uleb128
      || (encoding & 7) > DW_EH_PE_udata8)
    {
      as_bad (_("invalid or unsupported encoding in .cfi_lsda"));
      encoding = DW_EH_PE_omit;
    }

  cfi_parse_separator ();
  expression_and_evaluate (&insn_ptr->u.ea.exp);
  switch (insn_ptr->u.ea.exp.X_op)
    {
    case O_symbol:
      break;
    case O_constant:
      if ((encoding & 0x70) != DW_EH_PE_pcrel)
        break;
    default:
      encoding = DW_EH_PE_omit;
      break;
    }

  insn_ptr->u.ea.encoding = encoding;
  if (encoding == DW_EH_PE_omit)
    {
      as_bad (_("wrong third argument to .cfi_val_encoded_addr"));
      ignore_rest_of_line ();
      return;
    }

  demand_empty_rest_of_line ();
}

static void
a1030 58
    case CFI_val_encoded_addr:
      {
        unsigned encoding = insn->u.ea.encoding;
        offsetT encoding_size;

	if (encoding == DW_EH_PE_omit)
	  break;
	out_one (DW_CFA_val_expression);
	out_uleb128 (insn->u.ea.reg);

        switch (encoding & 0x7)
	  {
	  case DW_EH_PE_absptr:
	    encoding_size = DWARF2_ADDR_SIZE (stdoutput);
	    break;
	  case DW_EH_PE_udata2:
	    encoding_size = 2;
	    break;
	  case DW_EH_PE_udata4:
	    encoding_size = 4;
	    break;
	  case DW_EH_PE_udata8:
	    encoding_size = 8;
	    break;
	  default:
	    abort ();
	  }

	/* If the user has requested absolute encoding,
	   then use the smaller DW_OP_addr encoding.  */
	if (insn->u.ea.encoding == DW_EH_PE_absptr)
	  {
	    out_uleb128 (1 + encoding_size);
	    out_one (DW_OP_addr);
	  }
	else
	  {
	    out_uleb128 (1 + 1 + encoding_size);
	    out_one (DW_OP_GNU_encoded_addr);
	    out_one (encoding);

	    if ((encoding & 0x70) == DW_EH_PE_pcrel)
	      {
#if CFI_DIFF_EXPR_OK
		insn->u.ea.exp.X_op = O_subtract;
		insn->u.ea.exp.X_op_symbol = symbol_temp_new_now ();
#elif defined (tc_cfi_emit_pcrel_expr)
		tc_cfi_emit_pcrel_expr (&insn.u.ea.exp, encoding_size);
		break;
#else
		abort ();
#endif
	      }
	  }
	emit_expr (&insn->u.ea.exp, encoding_size);
      }
      break;
      
a1294 1
	    case CFI_val_encoded_addr:
d1310 1
a1310 2
	      || j->insn == CFI_escape
	      || j->insn == CFI_val_encoded_addr))
d1332 1
a1332 2
	|| i->insn == CFI_escape
	|| i->insn == CFI_val_encoded_addr)
@


1.36.2.2
log
@        * dw2gencfi.c (output_cfi_insn): Fix typo in invocation of
        tc_cfi_emit_pcrel_expr macro.
@
text
@d1155 1
a1155 1
		tc_cfi_emit_pcrel_expr (&insn->u.ea.exp, encoding_size);
@


1.36.2.3
log
@	* dw2gencfi.c (cfi_finish): Deal with md_fix_up_eh_frame.
	* config/tc-i386.h (md_fix_up_eh_frame): Define on Solaris.
	(i386_solaris_fix_up_eh_frame): Declare.
	* config/tc-i386.c (i386_solaris_fix_up_eh_frame): New function.
@
text
@a1498 4
#ifdef md_fix_up_eh_frame
  md_fix_up_eh_frame (cfi_seg);
#endif

@


1.36.2.4
log
@Back-port of:
2009-01-14  Jakub Jelinek  <jakub@@redhat.com>

	* Makefile.am (ehopt.o): Add struc-symbol.h.
	* Makefile.in: Regenerated.
	* ehopt.c: Include struc-symbol.h.
	(check_eh_frame): For very small O_constant DW_CFA_advance_loc4
	create correct DW_CFA_advance_loc.  Handle O_subtract only
	for code alignment factor 1, otherwise handle O_divide or
	O_right_shift of O_subtract and O_constant.
	(eh_frame_estimate_size_before_relax): Always divide by ca.
	(eh_frame_convert_frag): Likewise.

2009-01-14  John David Anglin  <dave.anglin@@nrc-cnrc.gc.ca>

	* dw2gencfi.c (output_cfi_insn): Scale DW_CFA_advance_loc1,
	DW_CFA_advance_loc2 and DW_CFA_advance_loc4 outputs.
@
text
@d2 1
a2 1
   Copyright 2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
d975 1
a975 1
	    else if (scaled <= 0xFF)
d978 1
a978 1
		out_one (scaled);
d980 1
a980 1
	    else if (scaled <= 0xFFFF)
d983 1
a983 1
		out_two (scaled);
d988 1
a988 1
		out_four (scaled);
@


1.35
log
@        * dw2gencfi.c (DWARF2_FDE_RELOC_SIZE): New.
        (output_cie, output_fde): Use it.
        (DWARF2_EH_FRAME_READ_ONLY): New.
        (cfi_finish): Use it.

        * config/tc-hppa.h (DWARF2_FDE_RELOC_SIZE): Set to 8 for 64-bit.
        (DWARF2_CIE_DATA_ALIGNMENT): Change sign.
        (DWARF2_EH_FRAME_READ_ONLY): New.
        * config/tc-hppa.c (tc_gen_reloc): Generate pc-relative relocations
        from the results of DIFF_EXPR_OK manipulation.
@
text
@d28 9
d667 1
a667 1
#if defined DIFF_EXPR_OK || defined tc_cfi_emit_pcrel_expr
d737 1
a737 1
#if defined DIFF_EXPR_OK || defined tc_cfi_emit_pcrel_expr
d1104 1
a1104 1
#ifdef DIFF_EXPR_OK
d1134 1
a1134 1
#if defined DIFF_EXPR_OK || defined tc_cfi_emit_pcrel_expr
d1169 1
a1169 1
#ifdef DIFF_EXPR_OK
d1197 1
a1197 1
#ifdef DIFF_EXPR_OK
@


1.34
log
@gas/
2008-02-13  Jan Beulich  <jbeulich@@novell.com>

	* config/tc-i386.c (allow_pseudo_reg): New.
	(parse_real_register): Check for NULL just once. Allow all
	register table entries when allow_pseudo_reg is non-zero.
	Don't allow any registers without type when allow_pseudo_reg
	is zero.
	(tc_x86_regname_to_dw2regnum): Replace with ...
	(tc_x86_parse_to_dw2regnum): ... this.
	(tc_x86_frame_initial_instructions): Adjust for above change.
	* config/tc-i386.h (tc_regname_to_dw2regnum): Remove.
	(tc_parse_to_dw2regnum): New.
	(tc_x86_regname_to_dw2regnum): Replace with ...
	(tc_x86_parse_to_dw2regnum): ... this.
	* dw2gencfi.c (tc_parse_to_dw2regnum): New, broken out of ...
	(cfi_parse_reg): ... this. Use tc_parse_to_dw2regnum. Adjust
	error handling.

gas/testsuite/
2008-02-13  Jan Beulich  <jbeulich@@novell.com>

	* gas/cfi/cfi-i386.s: Add code testing use of all registers.
	Fix a few comments.
	* gas/cfi/cfi-x86_64.s: Likewise.
	* gas/cfi/cfi-i386.d, gas/cfi/cfi-x86_64.d: Adjust.

opcodes/
2008-02-13  Jan Beulich  <jbeulich@@novell.com>

	* i386-gen.c (process_i386_registers): Process new fields.
	* i386-opc.h (reg_entry): Shrink reg_flags and reg_num to
	unsigned char. Add dw2_regnum and Dw2Inval.
	* i386-reg.tbl: Provide initializers for dw2_regnum. Add pseudo
	register names.
	* i386-tbl.h: Re-generate.
@
text
@d34 10
d1054 1
d1110 15
d1126 1
a1126 3
  out_one (DW_EH_PE_pcrel | DW_EH_PE_sdata4);
#else
  out_one (DW_EH_PE_sdata4);
d1128 1
d1163 1
a1163 1
  emit_expr (&exp, 4);				/* Code offset.  */
d1169 1
a1169 1
  tc_cfi_emit_pcrel_expr (&exp, 4);		/* Code offset.  */
d1171 1
a1171 1
  emit_expr (&exp, 4);				/* Code offset.  */
d1178 1
a1178 1
  emit_expr (&exp, 4);
d1347 2
a1348 1
			 SEC_ALLOC | SEC_LOAD | SEC_DATA | SEC_READONLY);
@


1.33
log
@gas/
2007-09-26  Jan Beulich  <jbeulich@@novell.com>

	* dw2gencfi.c: Conditionalize whole body upon TARGET_USE_CFIPOP.
	(cfi_finish): Add second empty instance.
@
text
@d403 3
a405 2
static unsigned
cfi_parse_reg (void)
d407 1
a407 4
  int regno;
  expressionS exp;

#ifdef tc_regname_to_dw2regnum
d418 2
a419 5
      if ((regno = tc_regname_to_dw2regnum (name)) < 0)
	{
	  as_bad (_("bad register expression"));
	  regno = 0;
	}
a421 1
      return regno;
d423 4
d429 7
a435 1
  expression_and_evaluate (&exp);
d444 6
a451 1
      break;
@


1.32
log
@Switch to GPLv3
@
text
@d26 1
a33 12
/* If TARGET_USE_CFIPOP is defined, it is required that the target
   provide the following definitions.  Otherwise provide them to 
   allow compilation to continue.  */
#ifndef TARGET_USE_CFIPOP
# ifndef  DWARF2_DEFAULT_RETURN_COLUMN
#  define DWARF2_DEFAULT_RETURN_COLUMN 0
# endif
# ifndef  DWARF2_CIE_DATA_ALIGNMENT
#  define DWARF2_CIE_DATA_ALIGNMENT 1
# endif
#endif

d1338 7
@


1.31
log
@	* dw2gencfi.c (struct fde_entry): Add per_encoding, lsda_encoding,
	personality and lsda.
	(struct cie_entry): Add per_encoding, lsda_encoding and personality.
	(alloc_fde_entry): Initialize per_encoding and lsda_encoding.
	(cfi_pseudo_table): Handle .cfi_personality and .cfi_lsda.
	(dot_cfi_personality, dot_cfi_lsda, encoding_size): New functions.
	(output_cie): Output personality including its encoding and LSDA encoding.
	(output_fde): Output LSDA.
	(select_cie_for_fde): Don't share CIE if personality, its encoding or
	LSDA encoding are different.  Copy the 3 fields from fde_entry to
	cie_entry.
	* doc/as.texinfo (.cfi_personality, .cfi_lsda): Document.

	* gas/cfi/cfi-common-6.d: New test.
	* gas/cfi/cfi-common-6.s: New.
	* gas/cfi/cfi.exp: Add cfi-common-6 test.
@
text
@d2 1
a2 1
   Copyright 2003, 2004, 2005, 2006 Free Software Foundation, Inc.
d9 1
a9 1
   the Free Software Foundation; either version 2, or (at your option)
@


1.30
log
@	* subsegs.h (struct frchain): Add frch_cfi_data field.
	* dw2gencfi.c: Include subsegs.h.
	(cur_fde_data, last_address, cur_cfa_offset, cfa_save_stack): Removed.
	(struct frch_cfi_data): New type.
	(unused_cfi_data): New variable.
	(alloc_fde_entry): Move cur_fde_data, last_address, cur_cfa_offset
	and cfa_save_stack static vars into a structure pointed from
	each frchain.
	(alloc_cfi_insn_data, cfi_new_fde, cfi_end_fde, cfi_set_return_column,
	cfi_add_advance_loc, cfi_add_CFA_def_cfa, cfi_add_CFA_def_cfa_offset,
	cfi_add_CFA_remember_state, cfi_add_CFA_restore_state, dot_cfi,
	dot_cfi_escape, dot_cfi_startproc, dot_cfi_endproc, cfi_finish):
	Likewise.

	* gas/cfi/cfi-common-5.d: New test.
	* gas/cfi/cfi-common-5.s: New.
	* gas/cfi/cfi.exp: Add cfi-common-5 test.
@
text
@d91 4
d105 3
d149 2
d369 2
d399 2
d627 142
d883 2
a884 2
	        out_one (DW_CFA_advance_loc1);
	        out_one (delta);
d888 2
a889 2
	        out_one (DW_CFA_advance_loc2);
	        out_two (delta);
d893 2
a894 2
	        out_one (DW_CFA_advance_loc4);
	        out_four (delta);
d1019 20
d1045 1
d1061 4
d1075 26
a1100 1
  out_uleb128 (1);				/* Augmentation size.  */
d1121 1
d1137 1
a1137 1
#ifdef DIFF_EXPR_OK  
d1157 21
a1177 1
  out_uleb128 (0);				/* Augmentation size.  */
d1195 3
a1197 1
	  || cie->signal_frame != fde->signal_frame)
d1199 21
d1292 3
@


1.29
log
@	* dw2gencfi.c (cfi_add_CFA_offset):
	Assert DWARF2_CIE_DATA_ALIGNMENT is non-zero.
@
text
@d24 1
a104 5
/* Current open FDE entry.  */
static struct fde_entry *cur_fde_data;
static symbolS *last_address;
static offsetT cur_cfa_offset;

d119 8
a126 1
static struct cfa_save_data *cfa_save_stack;
d135 2
a136 1
  cur_fde_data = fde;
d156 1
d171 1
a171 1
  last_address = label;
d179 3
a181 2
  cur_fde_data->end_address = label;
  cur_fde_data = NULL;
d189 1
a189 1
  cur_fde_data->return_column = regno;
d248 1
a248 1
  insn->u.ll.lab1 = last_address;
d251 1
a251 1
  last_address = label;
d276 1
a276 1
  cur_cfa_offset = offset;
d301 1
a301 1
  cur_cfa_offset = offset;
d330 3
a332 3
  p->cfa_offset = cur_cfa_offset;
  p->next = cfa_save_stack;
  cfa_save_stack = p;
d342 1
a342 1
  p = cfa_save_stack;
d345 2
a346 2
      cur_cfa_offset = p->cfa_offset;
      cfa_save_stack = p->next;
d458 1
a458 1
  if (!cur_fde_data)
d466 3
a468 2
  if (symbol_get_frag (last_address) != frag_now
      || S_GET_VALUE (last_address) != frag_now_fix ())
d484 2
a485 1
      cfi_add_CFA_offset (reg1, offset - cur_cfa_offset);
d514 2
a515 1
      cfi_add_CFA_def_cfa_offset (cur_cfa_offset + offset);
d565 1
a565 1
      cur_fde_data->signal_frame = 1;
d581 1
a581 1
  if (!cur_fde_data)
d589 3
a591 2
  if (symbol_get_frag (last_address) != frag_now
      || S_GET_VALUE (last_address) != frag_now_fix ())
d618 1
a618 1
  if (cur_fde_data)
d645 1
a645 1
  cur_cfa_offset = 0;
d653 1
a653 1
  if (! cur_fde_data)
a1065 6
  if (cur_fde_data)
    {
      as_bad (_("open CFI at the end of file; missing .cfi_endproc directive"));
      cur_fde_data->end_address = cur_fde_data->start_address;
    }

d1085 6
@


1.28
log
@bfd/
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Handle S flag.
	(_bfd_elf_write_section_eh_frame): Likewise.
gas/
	* dw2gencfi.c (struct fde_entry, struct cie_entry): Add signal_frame
	field.
	(CFI_signal_frame): Define.
	(cfi_pseudo_table): Add .cfi_signal_frame.
	(dot_cfi): Handle CFI_signal_frame.
	(output_cie): Handle cie->signal_frame.
	(select_cie_for_fde): Don't share CIE if signal_frame flag is
	different.  Copy signal_frame from FDE to newly created CIE.
	* doc/as.texinfo: Document .cfi_signal_frame.
@
text
@d255 1
@


1.27
log
@gas/
2005-11-17  Jan Beulich  <jbeulich@@novell.com>

	* dw2gencfi.c (dot_cfi): Put argument parsing for cases
	DW_CFA_restore and DW_CFA_undefined in a loop.
@
text
@d2 1
a2 1
   Copyright 2003, 2004, 2005 Free Software Foundation, Inc.
d91 1
d99 1
d359 1
d380 1
d554 4
d875 2
d957 2
a958 1
      if (cie->return_column != fde->return_column)
d1031 1
@


1.26
log
@This adjusts equate handling by
- allowing true forward references (which will always assume the referenced
  symbols have at the point of use) through the new .eqv pseudo-op and the
  new == operator
- disallowing changing .equiv-generated equates (so that the protection this
  provides is both forward and backward)
- snapshotting equates when their value gets changed so that previous uses
  don't get affected by the new value.
- allowing expressions in places where absolute expressions (or register
  names) are needed which were not completely resolvable at the point of
  their definition but which are fully resolvable at the point of use

In addition it fixes PR/288.
@
text
@d505 9
a513 2
      reg1 = cfi_parse_reg ();
      cfi_add_CFA_restore (reg1);
d517 9
a525 2
      reg1 = cfi_parse_reg ();
      cfi_add_CFA_undefined (reg1);
@


1.25
log
@gas/
2005-09-28  Jan Beulich  <jbeulich@@novell.com>

	* dw2gencfi.c (dot_cfi): Call ignore_rest_of_line when not fully
	parsing the input.
	(dot_cfi_startproc): Likewise.
	(dot_cfi_endproc): Likewise. Also check no extra input was given.
	(dot_cfi_escape): Likewise.
@
text
@d418 1
a418 1
  expression (&exp);
@


1.24
log
@	* README-vms: Delete.
	* config-gas.com: Delete.
	* makefile.vms: Delete.
	* vmsconf.sh: Delete.
	* config/atof-tahoe.c: Delete.
	* config/m88k-opcode.h: Delete.
	* config/obj-bout.c: Delete.
	* config/obj-bout.h: Delete.
	* config/obj-hp300.c: Delete.
	* config/obj-hp300.h: Delete.
	* config/tc-a29k.c: Delete.
	* config/tc-a29k.h: Delete.
	* config/tc-h8500.c: Delete.
	* config/tc-h8500.h: Delete.
	* config/tc-m88k.c: Delete.
	* config/tc-m88k.h: Delete.
	* config/tc-tahoe.c: Delete.
	* config/tc-tahoe.h: Delete.
	* config/tc-tic80.c: Delete.
	* config/tc-tic80.h: Delete.
	* config/tc-w65.c: Delete.
	* config/tc-w65.h: Delete.
	* config/te-aux.h: Delete.
	* config/te-delt88.h: Delete.
	* config/te-delta.h: Delete.
	* config/te-dpx2.h: Delete.
	* config/te-hp300.h: Delete.
	* config/te-ic960.h: Delete.
	* config/vms-a-conf.h: Delete.
	* doc/c-a29k.texi: Delete.
	* doc/c-h8500.texi: Delete.
	* doc/c-m88k.texi: Delete.
	* README: Remove obsolete examples, and list of supported targets.
	* Makefile.am: Remove a29k, h8500, m88k, tahoe, tic80, w65,
	bout and hp300 support.
	(DEP_FLAGS): Don't define BFD_ASSEMBLER.
	* configure.in: Remove --enable-bfd-assembler, need_bfd,
	primary_bfd_gas.
	* configure.tgt: Remove a29k, h8300-coff, h8500-*, i960 non-elf,
	m68k non bfd, m88k, or32-coff, tic80-*, vax non-bfd, w65k-*, *-nindy.
	* as.c: Remove all non-BFD_ASSEMBLER code, support for above targets.
	* as.h: Likewise.
	* dw2gencfi.c: Likewise.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
	* input-file.c: Likewise.
	* listing.c: Likewise.
	* literal.c: Likewise.
	* messages.c: Likewise.
	* obj.h: Likewise.
	* output-file.c: Likewise.
	* read.c: Likewise.
	* stabs.c: Likewise.
	* struc-symbol.h: Likewise.
	* subsegs.c: Likewise.
	* subsegs.h: Likewise.
	* symbols.c: Likewise.
	* symbols.h: Likewise.
	* tc.h: Likewise.
	* write.c: Likewise.
	* write.h: Likewise.
	* config/aout_gnu.h: Likewise.
	* config/obj-aout.c: Likewise.
	* config/obj-aout.h: Likewise.
	* config/obj-coff.c: Likewise.
	* config/obj-coff.h: Likewise.
	* config/obj-evax.h: Likewise.
	* config/obj-ieee.h: Likewise.
	* config/tc-arm.c: Likewise.
	* config/tc-arm.h: Likewise.
	* config/tc-avr.c: Likewise.
	* config/tc-avr.h: Likewise.
	* config/tc-crx.h: Likewise.
	* config/tc-d10v.h: Likewise.
	* config/tc-d30v.h: Likewise.
	* config/tc-dlx.h: Likewise.
	* config/tc-fr30.h: Likewise.
	* config/tc-frv.h: Likewise.
	* config/tc-h8300.c: Likewise.
	* config/tc-h8300.h: Likewise.
	* config/tc-hppa.h: Likewise.
	* config/tc-i370.h: Likewise.
	* config/tc-i386.c: Likewise.
	* config/tc-i386.h: Likewise.
	* config/tc-i860.h: Likewise.
	* config/tc-i960.c: Likewise.
	* config/tc-i960.h: Likewise.
	* config/tc-ip2k.h: Likewise.
	* config/tc-iq2000.h: Likewise.
	* config/tc-m32c.h: Likewise.
	* config/tc-m32r.h: Likewise.
	* config/tc-m68hc11.h: Likewise.
	* config/tc-m68k.c: Likewise.
	* config/tc-m68k.h: Likewise.
	* config/tc-maxq.c: Likewise.
	* config/tc-maxq.h: Likewise.
	* config/tc-mcore.c: Likewise.
	* config/tc-mcore.h: Likewise.
	* config/tc-mn10200.h: Likewise.
	* config/tc-mn10300.c: Likewise.
	* config/tc-mn10300.h: Likewise.
	* config/tc-ms1.h: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-msp430.h: Likewise.
	* config/tc-ns32k.c: Likewise.
	* config/tc-ns32k.h: Likewise.
	* config/tc-openrisc.h: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-or32.h: Likewise.
	* config/tc-ppc.c: Likewise.
	* config/tc-ppc.h: Likewise.
	* config/tc-s390.h: Likewise.
	* config/tc-sh.c: Likewise.
	* config/tc-sh.h: Likewise.
	* config/tc-sparc.c: Likewise.
	* config/tc-tic30.c: Likewise.
	* config/tc-tic30.h: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic4x.h: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-tic54x.h: Likewise.
	* config/tc-v850.h: Likewise.
	* config/tc-vax.c: Likewise.
	* config/tc-vax.h: Likewise.
	* config/tc-xstormy16.h: Likewise.
	* config/tc-xtensa.h: Likewise.
	* config/tc-z8k.c: Likewise.
	* config/tc-z8k.h: Likewise.
	* config/vms-a-conf.h
	* doc/Makefile.am: Likewise.
	* doc/all.texi: Likewise.
	* doc/as.texinfo: Likewise.
	* doc/Makefile.in: Regenerate.
	* Makefile.in: Regenerate.
	* configure: Regenerate.
	* config.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d450 1
d552 1
d575 3
d588 1
d623 1
d628 2
@


1.23
log
@Update the address and phone number of the FSF
@
text
@d45 1
a45 5
# ifdef BFD_ASSEMBLER
#  define EH_FRAME_ALIGNMENT (bfd_get_arch_size (stdoutput) == 64 ? 3 : 2)
# else
#  define EH_FRAME_ALIGNMENT 2
# endif
a1030 1
#ifdef BFD_ASSEMBLER
a1032 1
#endif
@


1.22
log
@	* dw2gencfi.c (output_cie, output_fde): Use DW_CFA_nop rather
	than zero.
@
text
@d19 2
a20 2
   Software Foundation, 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.21
log
@gas/
2004-12-15 Jan Beulich  <jbeulich@@novell.com>

	* dw2gencfi.c (dot.cfi.startproc): Clear cur_cfa_offset so
	'.cfi_startproc simple' doesn't inherit the old value.
@
text
@d2 1
a2 1
   Copyright 2003, 2004 Free Software Foundation, Inc.
d866 1
a866 1
  frag_align (2, 0, 0);
d916 1
a916 1
  frag_align (align, 0, 0);
@


1.20
log
@gas/
2004-12-15  Jan Beulich  <jbeulich@@novell.com>

	* dw2gencfi.c (output_cfi_insn): Adjust DW_CFA_def_cfa_sf generation
	to emit a signed and factored offset. Adjust DW_CFA_def_cfa_offset_sf
	generation to emit a factored offset.
@
text
@d610 1
@


1.19
log
@When separating CIE out from FDE, treat a DW_CFA_remember_state as we do a
DW_CFA_advance_loc.  Test to make sure that this feature continues to work.
@
text
@d731 1
a731 1
	  out_uleb128 (offset);
d753 1
a753 1
	  out_sleb128 (offset);
@


1.18
log
@	* dw2gencfi.c (select_cie_for_fde): When separating CIE out
	from FDE, treat a CFI_escape as we do a DW_CFA_advance_loc.
@
text
@d2 1
a2 1
   Copyright 2003 Free Software Foundation, Inc.
d28 1
a28 1
#ifndef DWARF2_LINE_MIN_INSN_LENGTH
d36 1
a36 1
# ifndef DWARF2_DEFAULT_RETURN_COLUMN
d39 1
a39 1
# ifndef DWARF2_CIE_DATA_ALIGNMENT
d344 2
d841 1
a841 1
  emit_expr (&exp, 4);				/* Length */
d843 3
a845 3
  out_four (0);					/* CIE id */
  out_one (DW_CIE_VERSION);			/* Version */
  out_one ('z');				/* Augmentation */
d848 2
a849 2
  out_uleb128 (DWARF2_LINE_MIN_INSN_LENGTH);	/* Code alignment */
  out_sleb128 (DWARF2_CIE_DATA_ALIGNMENT);	/* Data alignment */
d854 1
a854 1
  out_uleb128 (1);				/* Augmentation size */
d883 1
a883 1
  emit_expr (&exp, 4);				/* Length */
d888 1
a888 1
  emit_expr (&exp, 4);				/* CIE offset */
d893 1
a893 1
  emit_expr (&exp, 4);				/* Code offset */
d899 1
a899 1
  tc_cfi_emit_pcrel_expr (&exp, 4);		/* Code offset */
d901 1
a901 1
  emit_expr (&exp, 4);				/* Code offset */
d907 1
a907 1
  exp.X_op_symbol = fde->start_address;		/* Code length */
d910 1
a910 1
  out_uleb128 (0);				/* Augmentation size */
d938 3
a940 2
	      /* We reached the first advance in the FDE, but did not
		 reach the end of the CIE list.  */
d981 2
a982 2
	 run out of FDE entries or we've encountered an advance or
	 escape.  */
d986 1
d1004 1
@


1.17
log
@Handle dwarf3 format CIE entries.
@
text
@d978 6
a983 2
	 run out of FDE entries or we've encountered an advance.  */
      if (i == cie->last && (!j || j->insn == DW_CFA_advance_loc))
d999 2
a1000 1
    if (i->insn == DW_CFA_advance_loc)
@


1.16
log
@        * dw2gencfi.c (output_cie): Align length to 4 byte boundary.
        (cfi_finish): Likewise for fde.

        * gas/alpha/elf-reloc-8.d, gas/cfi/cfi-alpha-1.d,
        gas/cfi/cfi-alpha-2.d, gas/cfi/cfi-alpha-3.d, gas/cfi/cfi-common-1.d,
        gas/cfi/cfi-common-2.d, gas/cfi/cfi-common-3.d: Adjust offsets.
@
text
@d848 4
a851 1
  out_one (cie->return_column);			/* Return column */
@


1.15
log
@s/.cfi_gnu_window_save/.cfi_window_save/g
@
text
@d860 1
d910 1
a910 2
  if (align)
    frag_align (align, 0, 0);
d1038 1
a1038 1
      output_fde (fde, cie, first, fde->next == NULL ? EH_FRAME_ALIGNMENT : 0);
@


1.15.6.1
log
@Merge to 2.15 branch.
@
text
@a859 1
  frag_align (2, 0, 0);
d909 2
a910 1
  frag_align (align, 0, 0);
d1038 1
a1038 1
      output_fde (fde, cie, first, fde->next == NULL ? EH_FRAME_ALIGNMENT : 2);
@


1.14
log
@	* dw2gencfi.c (cfi_pseudo_table): Add cfi_gnu_window_save.
	(dot_cfi, output_cfi_insn): Handle DW_CFA_GNU_window_save.
	(output_cie): Don't use DW_EH_PE_pcrel if neither DIFF_EXPR_OK
	nor tc_cfi_emit_pcrel_expr are defined.
	(output_fde): Use tc_cfi_emit_pcrel_expr if available and
	DIFF_EXPR_OK is not defined.
	* config/tc-sparc.h (TARGET_USE_CFIPOP): Define.
	(tc_cfi_frame_initial_instructions, tc_regname_to_dw2regnum,
	tc_cfi_emit_pcrel_expr): Define.
	(sparc_cfi_frame_initial_instructions, sparc_regname_to_dw2regnum,
	sparc_cfi_emit_pcrel_expr): New prototypes.
	(sparc_cie_data_alignment): New decl.
	(DWARF2_DEFAULT_RETURN_COLUMN, DWARF2_CIE_DATA_ALIGNMENT): Define.
	* config/tc-sparc.c: Include dw2gencfi.h.
	(sparc_cie_data_alignment): New variable.
	(md_begin): Initialize it.
	(sparc_cfi_frame_initial_instructions): New function.
	(sparc_regname_to_dw2regnum): Likewise.
	(sparc_cfi_emit_pcrel_expr): Likewise.
	* doc/as.texinfo: Document .cfi_gnu_window_save.

	* config/tc-sparc.c (s_common): Cast last argument to long and
	change format string to shut up warning.
testsuite/
	* gas/cfi/cfi-sparc-1.s: New test.
	* gas/cfi/cfi-sparc-1.d: New test.
	* gas/cfi/cfi-sparc64-1.s: New test.
	* gas/cfi/cfi-sparc64-1.d: New test.
	* gas/cfi/cfi.exp: Run them.
@
text
@d377 1
a377 1
    { "cfi_gnu_window_save", dot_cfi, DW_CFA_GNU_window_save },
@


1.13
log
@	* dw2gencfi.c (EH_FRAME_ALIGNMENT): Define if not defined.
	(output_cie): Don't pad.
	(output_fde): Add align argument.  Pad to align if not 0.
	(cfi_finish): Set .eh_frame alignment to EH_FRAME_ALIGNMENT.
	Pad just last FDE to EH_FRAME_ALIGNMENT.

	* gas/cfi/cfi-i386.d: Regenerated.
	* gas/cfi/cfi-common-1.d: Regenerated.
	* gas/cfi/cfi-common-2.d: Regenerated.
	* gas/cfi/cfi-common-3.d: Regenerated.
	* gas/cfi/cfi-x86_64.d: Regenerated.
	* gas/cfi/cfi-alpha-1.d: Regenerated.
	* gas/cfi/cfi-alpha-2.d: Regenerated.
	* gas/cfi/cfi-alpha-3.d: Regenerated.
@
text
@d377 1
d533 4
d806 4
d850 1
d852 3
d883 2
a884 1
  
d888 11
@


1.12
log
@        * dw2gencfi.c (struct cfi_escape_data): New.
        (cfi_add_CFA_nop): Remove.
        (CFI_escape, dot_cfi_escape): New.
        (dot_cfi): Remove nop.
        (cfi_pseudo_table): Remove nop; add escape.
        (output_cfi_insn): Likewise.
        (select_cie_for_fde): Stop on escape.
        * dw2gencfi.h (cfi_add_CFA_nop): Remove.
        * read.c, read.h (do_parse_cons_expression): New.
        * doc/as.texinfo (.cfi_escape): New.

        * gas/cfi/cfi-common-3.[ds]: New.
        * gas/cfi/cfi.exp: Run it.
@
text
@d44 8
a846 1
  frag_align (2, 0, 0);
d852 1
a852 1
	    struct cfi_insn_data *first)
d884 2
a885 1
  frag_align (2, 0, 0);
d1001 1
a1001 1
  record_alignment (cfi_seg, 2);
d1013 1
a1013 1
      output_fde (fde, cie, first);
@


1.11
log
@        * dw2gencfi.c (struct cfa_save_data, cfa_save_stack): New.
        (cfi_add_CFA_offset): Detect invalid offsets.
        (cfi_add_CFA_remember_state): Save cur_cfa_offset.
        (cfi_add_CFA_restore_state): Restore it.
        (CFI_rel_offset): New.
        (cfi_pseudo_table): Add it.
        (dot_cfi): Handle it.

        * gas/cfi/cfi-common-1.d, gas/cfi/cfi-common-1.s: New.
        * gas/cfi/cfi-common-2.d, gas/cfi/cfi-common-2.s: New.
        * gas/cfi/cfi-diag-1.d, gas/cfi/cfi-diag-1.s: New.
        * gas/cfi/cfi.exp: Run them.
@
text
@d71 5
a337 6
void
cfi_add_CFA_nop (void)
{
  cfi_add_CFA_insn (DW_CFA_nop);
}

d342 1
d350 1
d369 1
a369 1
    { "cfi_nop", dot_cfi, DW_CFA_nop },
a523 4
    case DW_CFA_nop:
      cfi_add_CFA_nop ();
      break;

d532 33
a789 1
    case DW_CFA_nop:
d793 8
d931 4
@


1.10
log
@2003-06-05  Michal Ludvig  <mludvig@@suse.cz>

	* dw2gencfi.c (cfi_add_CFA_insn, cfi_add_CFA_insn_reg)
	(cfi_add_CFA_insn_reg_reg, cfi_add_CFA_insn_reg_offset): New.
	(cfi_add_CFA_offset, cfi_add_CFA_def_cfa)
	(cfi_add_CFA_register, cfi_add_CFA_def_cfa_register)
	(cfi_add_CFA_def_cfa_offset): Use cfi_add_CFA_insn_*().
	(cfi_add_CFA_restore, cfi_add_CFA_undefined)
	(cfi_add_CFA_same_value, cfi_add_CFA_remember_state)
	(cfi_add_CFA_restore_state, cfi_add_CFA_nop): New.
	(cfi_pseudo_table): New directives .cfi_return_column,
	.cfi_restore, .cfi_undefined, .cfi_same_value,
	.cfi_remember_state, .cfi_restore_state, .cfi_nop.
	(dot_cfi, output_cfi_insn): Handle new directives.
	* dw2gencfi.h (cfi_add_CFA_restore, cfi_add_CFA_undefined)
	(cfi_add_CFA_same_value, cfi_add_CFA_remember_state)
	(cfi_add_CFA_restore_state, cfi_add_CFA_nop): New prototypes.
@
text
@d105 8
d242 2
d245 5
d307 2
d310 5
d320 2
d323 8
d349 1
d360 1
d457 7
@


1.9
log
@        * dw2gencfi.c (output_cfi_insn): Fix typo for negative offsets.
@
text
@d167 48
d234 1
a234 5
  struct cfi_insn_data *insn = alloc_cfi_insn_data ();
  
  insn->insn = DW_CFA_offset;
  insn->u.ri.reg = regno;
  insn->u.ri.offset = offset;
d242 1
a242 6
  struct cfi_insn_data *insn = alloc_cfi_insn_data ();
  
  insn->insn = DW_CFA_def_cfa;
  insn->u.ri.reg = regno;
  insn->u.ri.offset = offset;

d251 1
a251 5
  struct cfi_insn_data *insn = alloc_cfi_insn_data ();
  
  insn->insn = DW_CFA_register;
  insn->u.rr.reg1 = reg1;
  insn->u.rr.reg2 = reg2;
d259 1
a259 4
  struct cfi_insn_data *insn = alloc_cfi_insn_data ();
  
  insn->insn = DW_CFA_def_cfa_register;
  insn->u.r = regno;
d267 33
a299 4
  struct cfi_insn_data *insn = alloc_cfi_insn_data ();
  
  insn->insn = DW_CFA_def_cfa_offset;
  insn->u.i = offset;
d301 4
a304 1
  cur_cfa_offset = offset;
d315 2
a316 1
#define CFI_adjust_cfa_offset 0x100
d328 7
a417 1
      /* Instructions that take two arguments (register, integer). */
d419 6
d429 1
a429 5

      if (arg == DW_CFA_def_cfa)
	cfi_add_CFA_def_cfa (reg1, offset);
      else
	cfi_add_CFA_offset (reg1, offset);
a431 1
      /* Instructions that take two arguments (register, register). */
a435 1

a438 1
      /* Instructions that take one register argument.  */
a443 1
      /* Instructions that take one integer argument.  */
a448 1
      /* Special handling for pseudo-instruction.  */
d454 32
d656 4
a659 2
      out_one (DW_CFA_def_cfa_register);
      out_uleb128 (insn->u.i);
d676 13
d717 2
d720 1
a720 1
      out_one (DW_CFA_nop);
d842 3
@


1.8
log
@        * dw2gencfi.c (cfi_finish): Set .eh_frame read-only.
@
text
@d579 1
a579 1
	  out_one (DW_CFA_offset_extended);
@


1.7
log
@	* read.c (emit_expr): Set dot_value.
	* dw2gencfi.c (output_fde): Remove pcrel reloc hack.
@
text
@d788 1
a788 1
			 SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA);
@


1.6
log
@        * dw2gencfi.c (output_fde): Use fix_new to emit pc-relative reloc.
        (cfi_finish): Set flag_traditional_format around .eh_frame data.

        * gas/alpha/elf-reloc-8.d: Correct .eh_frame relocs.
        * gas/cfi/cfi-alpha-2.d: New.
        * gas/cfi/cfi-alpha-2.s: New.
        * gas/cfi/cfi.exp: Run it.
@
text
@a668 7
  /* ??? Unsure why this works and the following doesn't.  
     Symptom was incorrect addends to the relocation.  */
#if 1
  memset (frag_more (4), 0, 4);			/* Code offset */
  fix_new (frag_now, frag_now_fix () - 4, 4,
	   fde->start_address, 0, 1, BFD_RELOC_32);
#else
d671 1
a671 2
  emit_expr (&exp, 4);
#endif
@


1.5
log
@        * dw2gencfi.c, dw2gencfi.h: Rewrite from scratch.
        * as.c (main): Always call cfi_finish.
        * config/tc-i386.c (x86_dwarf2_return_column): New.
        (x86_cie_data_alignment): New.
        (md_begin): Set them.
        (tc_x86_cfi_init): Remove.
        (tc_x86_regname_to_dw2regnum): Fix 32-bit register numbers;
        return int, not unsigned long; don't as_bad here.
        (tc_x86_frame_initial_instructions): Streamline; use
        updated api.
        * config/tc-i386.h (tc_cfi_init): Remove.
        (DWARF2_DEFAULT_RETURN_COLUMN): New.
        (DWARF2_CIE_DATA_ALIGNMENT): New.

        * gas/cfi/cfi-i386.d: Update for dw2gencfi rewrite.
        * gas/cfi/cfi-x86_64.d: Likewise.
        * gas/cfi/cfi-i386-2.d: New.
        * gas/cfi/cfi-i386-2.s: New.
@
text
@d669 7
d678 2
a679 1
  emit_expr (&exp, 4);				/* Code offset */
d781 1
d801 4
d813 2
@


1.4
log
@Fix dw3gencfi.c so that it will build on targets that do not define BFD_ASSEMBLER.
@
text
@a21 1
#include <errno.h>
d25 25
a49 1
struct cie_entry
d51 21
a71 4
  unsigned long offset;
  size_t size;
  void *data;
  struct cie_entry *next;
d74 1
a74 1
struct cfi_data
d76 6
a81 3
  enum cfi_insn insn;
  long param[2];
  struct cfi_data *next;
d84 1
a84 1
struct cfi_info
d86 4
a89 6
  addressT start_address;
  addressT end_address;
  addressT last_address;
  const char *labelname;
  struct cfi_data *data;
  struct cfi_info *next;
d92 9
a100 2
/* Current open CFI entry.  */
static struct cfi_info *cfi_info;
d105 11
a115 2
/* Current target config.  */
static struct cfi_config current_config;
d117 2
a118 2
/* This is the main entry point to the CFI machinery.  */
static void dot_cfi (int arg);
d120 8
a127 13
const pseudo_typeS cfi_pseudo_table[] =
  {
    { "cfi_verbose", dot_cfi, CFI_verbose },
    { "cfi_startproc", dot_cfi, CFI_startproc },
    { "cfi_endproc", dot_cfi, CFI_endproc },
    { "cfi_def_cfa", dot_cfi, CFA_def_cfa },
    { "cfi_def_cfa_register", dot_cfi, CFA_def_cfa_register },
    { "cfi_def_cfa_offset", dot_cfi, CFA_def_cfa_offset },
    { "cfi_adjust_cfa_offset", dot_cfi, CFI_adjust_cfa_offset },
    { "cfi_offset", dot_cfi, CFA_offset },
    { "cfi_register", dot_cfi, CFA_register },
    { NULL, NULL, 0 }
  };
d129 2
a130 2
static const char *
cfi_insn_str (enum cfi_insn insn)
d132 4
a135 41
  switch (insn)
    {
    case CFA_nop:
      return "CFA_nop";
    case CFA_set_loc:
      return "CFA_set_loc";
    case CFA_advance_loc1:
      return "CFA_advance_loc1";
    case CFA_advance_loc2:
      return "CFA_advance_loc2";
    case CFA_advance_loc4:
      return "CFA_advance_loc4";
    case CFA_offset_extended:
      return "CFA_offset_extended";
    case CFA_resotre_extended:
      return "CFA_resotre_extended";
    case CFA_undefined:
      return "CFA_undefined";
    case CFA_same_value:
      return "CFA_same_value";
    case CFA_register:
      return "CFA_register";
    case CFA_remember_state:
      return "CFA_remember_state";
    case CFA_restore_state:
      return "CFA_restore_state";
    case CFA_def_cfa:
      return "CFA_def_cfa";
    case CFA_def_cfa_register:
      return "CFA_def_cfa_register";
    case CFA_def_cfa_offset:
      return "CFA_def_cfa_offset";
    case CFA_advance_loc:
      return "CFA_advance_loc";
    case CFA_offset:
      return "CFA_offset";
    case CFA_restore:
      return "CFA_restore";
    default:
      break;
    }
d137 1
a137 1
  return "CFA_unknown";
d140 4
a143 2
static struct cfi_data *
alloc_cfi_data (void)
d145 3
a147 1
  return (struct cfi_data *) xcalloc (sizeof (struct cfi_info), 1);
d150 4
a153 2
static struct cfi_info *
alloc_cfi_info (void)
d155 2
a156 1
  return (struct cfi_info *) xcalloc (sizeof (struct cfi_info), 1);
d159 4
a162 3
/* Parse arguments.  */
static int
cfi_parse_arg (long *param, int resolvereg)
d164 2
a165 3
  long value;
  int retval = -1;
  int nchars;
d167 6
a172 2
  assert (param != NULL);
  SKIP_WHITESPACE ();
d174 3
a176 11
  if (sscanf (input_line_pointer, "%li%n", &value, &nchars) >= 1)
    {
      input_line_pointer += nchars;
      retval = 1;
    }
#ifdef tc_regname_to_dw2regnum
  else if (resolvereg && ((is_name_beginner (*input_line_pointer))
			   || (*input_line_pointer == '%'
			       && is_name_beginner (*(++input_line_pointer)))))
    {
      char *name, c, *p;
d178 2
a179 3
      name = input_line_pointer;
      c = get_symbol_end ();
      p = input_line_pointer;
d181 1
a181 2
      if ((value = tc_regname_to_dw2regnum (name)) >= 0)
	retval = 1;
d183 9
a191 7
      *p = c;
    }
#endif
  else
    as_bad (resolvereg ?
	    _("can't convert argument to a register number") :
	    _("can't convert argument to an integer"));
d193 1
a193 2
  if (retval > 0)
    *param = value;
d195 8
a202 6
  SKIP_WHITESPACE ();
  if (*input_line_pointer == ',')
    {
      input_line_pointer++;
      SKIP_WHITESPACE ();
    }
d204 1
a204 1
  return retval;
d207 4
a210 2
static int
cfi_parse_reg (long *param)
d212 5
a216 1
  return cfi_parse_arg (param, 1);
d219 4
a222 2
static int
cfi_parse_const (long *param)
d224 4
a227 1
  return cfi_parse_arg (param, 0);
d230 2
d233 1
a233 1
cfi_add_insn (enum cfi_insn insn, long param0, long param1)
d235 4
a238 1
  struct cfi_data *data_ptr;
d240 2
a241 8
  if (!cfi_info->data)
    {
      cfi_info->data = alloc_cfi_data ();
      data_ptr = cfi_info->data;
    }
  else
    {
      data_ptr = cfi_info->data;
d243 2
a244 2
      while (data_ptr && data_ptr->next)
	data_ptr = data_ptr->next;
d246 3
a248 1
      data_ptr->next = alloc_cfi_data ();
d250 2
a251 2
      data_ptr = data_ptr->next;
    }
d253 12
a264 4
  data_ptr->insn = insn;
  data_ptr->param[0] = param0;
  data_ptr->param[1] = param1;
}
d267 1
a267 1
cfi_advance_loc (void)
d269 5
a273 6
  addressT curr_address = frag_now_fix ();
  if (cfi_info->last_address == curr_address)
    return;
  cfi_add_insn (CFA_advance_loc,
		(long) (curr_address - cfi_info->last_address), 0);
  cfi_info->last_address = curr_address;
d276 2
a277 2
static long
get_current_offset (struct cfi_info *info)
d279 2
a280 2
  long current_offset = 0;
  struct cfi_data *data = info->data;
d282 5
a286 2
  current_offset = 0;
  while (data)
d288 13
a300 5
      if (data->insn == CFA_def_cfa)
	current_offset = data->param[1];
      else if (data->insn == CFA_def_cfa_offset)
	current_offset = data->param[0];
      data = data->next;
d302 9
d312 13
a324 1
  return current_offset;
d328 1
a328 1
cfi_make_insn (int arg)
d330 2
a331 1
  long param[2] = { 0, 0 };
d333 1
a333 1
  if (!cfi_info)
d339 4
a342 1
  cfi_advance_loc ();
d347 10
a356 14
    case CFA_offset:
    case CFA_def_cfa:
      if (cfi_parse_reg (&param[0]) < 0)
	{
	  as_bad (_("first argument to %s is not a register"),
		  cfi_insn_str (arg));
	  return;
	}
      if (cfi_parse_const (&param[1]) < 0)
	{
	  as_bad (_("second argument to %s is not a number"),
		  cfi_insn_str (arg));
	  return;
	}
d359 7
a365 13
    case CFA_register:
      if (cfi_parse_reg (&param[0]) < 0)
	{
	  as_bad (_("first argument to %s is not a register"),
		  cfi_insn_str (arg));
	  return;
	}
      if (cfi_parse_reg (&param[1]) < 0)
	{
	  as_bad (_("second argument to %s is not a register"),
		  cfi_insn_str (arg));
	  return;
	}
d369 3
a371 6
    case CFA_def_cfa_register:
      if (cfi_parse_reg (&param[0]) < 0)
	{
	  as_bad (_("argument to %s is not a register"), cfi_insn_str (arg));
	  return;
	}
d375 3
a377 6
    case CFA_def_cfa_offset:
      if (cfi_parse_const (&param[0]) < 0)
	{
	  as_bad (_("argument to %s is not a number"), cfi_insn_str (arg));
	  return;
	}
d382 2
a383 8
      if (cfi_parse_const (&param[0]) < 0)
	{
	  as_bad (_("argument to %s is not a number"),
		    ".cfi_adjust_cfa_offset");
	  return;
	}
      param[0] += get_current_offset (cfi_info);
      arg = CFA_def_cfa_offset;
d387 1
a387 2
      as_bad (_("unknown CFI instruction %d (%s)"), arg, cfi_insn_str (arg));
      return;
d389 2
a390 1
  cfi_add_insn (arg, param[0], param[1]);
d393 2
a394 2
static symbolS *
cfi_get_label (void)
d396 1
a396 3
  char symname[40], *symbase=".Llbl_cfi";
  symbolS *symbolP;
  unsigned int i = 0;
d398 1
a398 3
  snprintf (symname, sizeof (symname), "%s_0x%lx",
	    symbase, (long) frag_now_fix ());
  while ((symbolP = symbol_find (symname)))
d400 3
a402 3
      if ((S_GET_VALUE (symbolP) == frag_now_fix ())
	  && (S_GET_SEGMENT (symbolP) == now_seg))
	return symbolP;
d404 17
a420 2
      snprintf (symname, sizeof (symname), "%s_0x%lx_%u",
		symbase, (long) frag_now_fix (), i++);
d422 4
a425 8
#ifdef BFD_ASSEMBLER
  symbolP = (symbolS *) local_symbol_make (symname, now_seg,
					   (valueT) frag_now_fix (),
					   frag_now);
#else
  symbolP = symbol_make (symname);
#endif
  return symbolP;
d429 1
a429 1
dot_cfi_startproc (void)
d431 1
a431 5
#ifdef tc_cfi_frame_initial_instructions
  const char *simple = "simple";
#endif

  if (cfi_info)
d433 1
a433 1
      as_bad (_("previous CFI entry not closed (missing .cfi_endproc)"));
d437 5
a441 6
#if defined(TARGET_USE_CFIPOP)
  /* Because this file is linked even for architectures that 
     don't use CFI, we must wrap this call.  */
  if (current_config.addr_length == 0)
    tc_cfi_init ();
#endif
d443 5
a447 1
  cfi_info = alloc_cfi_info ();
d449 1
a449 3
  cfi_info->start_address = frag_now_fix ();
  cfi_info->last_address = cfi_info->start_address;
  cfi_info->labelname = S_GET_NAME (cfi_get_label ());
d451 4
a454 7
  SKIP_WHITESPACE ();
#ifdef tc_cfi_frame_initial_instructions
  if (strncmp (simple, input_line_pointer, strlen (simple)) != 0)
    tc_cfi_frame_initial_instructions ();
  else
    input_line_pointer += strlen (simple);
#endif
d457 1
a457 3
#define cfi_is_advance_insn(insn)				\
  ((insn >= CFA_set_loc && insn <= CFA_advance_loc4)		\
   || insn == CFA_advance_loc)
d459 5
a463 1
/* Output CFI instructions to the file.  */
d465 1
a465 10
enum data_types
  {
    t_ascii = 0,
    t_byte = 1,
    t_half = 2,
    t_long = 4,
    t_quad = 8,
    t_uleb128 = 0x10,
    t_sleb128 = 0x11
  };
d467 2
a468 2
static int
output_data (char **p, unsigned long *size, enum data_types type, long value)
d470 2
a471 2
  char *ptr = *p;
  unsigned int ret_size;
d473 1
a473 62
  switch (type)
    {
    case t_byte:
      ret_size = 1;
      break;
    case t_half:
      ret_size = 2;
      break;
    case t_long:
      ret_size = 4;
      break;
    case t_quad:
    case t_uleb128:
    case t_sleb128:
      ret_size = 8;
      break;
    default:
      /* This should never happen - throw an internal error.  */
      as_fatal (_("unknown type %d"), type);
      return 0;
    }

  if (*size < ret_size)
    {
      as_bad (_("output_data buffer is too small"));
      return 0;
    }

  switch (type)
    {
    case t_byte:
      *ptr = (char) value;
      if (verbose)
	printf ("\t.byte\t0x%x\n", (unsigned char) *ptr);
      break;
    case t_half:
      *(short *) ptr = (short) value & 0xFFFF;
      if (verbose)
	printf ("\t.half\t0x%x\n", (unsigned short) *ptr);
      break;
    case t_long:
      *(int *) ptr = (int) value & 0xFFFFFFFF;
      if (verbose)
	printf ("\t.long\t0x%x\n", (unsigned int) *ptr);
      break;
    case t_quad:
      *(long long *) ptr = (long long) value & 0xFFFFFFFF;
      if (verbose)
	printf ("\t.quad\t0x%x\n", (unsigned int) *ptr);
      break;
    case t_uleb128:
    case t_sleb128:
      ret_size = output_leb128 (ptr, value, type == t_sleb128);
      if (verbose)
	printf ("\t.%s\t0x%lx\n",
		type == t_sleb128 ? "sleb128" : "uleb128",
		value);
      break;
    default:
      as_fatal (_("unknown type %d"), type);
      return 0;
    }
d475 4
a478 4
  *size -= ret_size;
  *p += ret_size;

  return ret_size;
d481 2
a482 2
static int
cfi_output_insn (struct cfi_data *data, char **buf, unsigned long *buf_size)
d484 2
a485 2
  char **pbuf = buf, *orig_buf = *buf;
  unsigned long size;
d487 1
a487 4
  if (!data || !buf)
    as_fatal (_("cfi_output_insn called with NULL pointer"));

  switch (data->insn)
d489 57
a545 8
    case CFA_advance_loc:
      if (verbose)
	printf ("\t# %s(%ld)\n", cfi_insn_str (data->insn),
		data->param[0]);
      if (data->param[0] <= 0x3F)
	{
	  output_data (pbuf, buf_size, t_byte, CFA_advance_loc +
		       (data->param[0] / current_config.code_align));
d547 1
a547 1
      else if (data->param[0] <= 0xFF)
d549 3
a551 3
	  output_data (pbuf, buf_size, t_byte, CFA_advance_loc1);
	  output_data (pbuf, buf_size, t_byte,
		       data->param[0] / current_config.code_align);
d553 10
a562 1
      else if (data->param[0] <= 0xFFFF)
d564 2
a565 3
	  output_data (pbuf, buf_size, t_byte, CFA_advance_loc2);
	  output_data (pbuf, buf_size, t_half,
		       data->param[0] / current_config.code_align);
d569 2
a570 3
	  output_data (pbuf, buf_size, t_byte, CFA_advance_loc4);
	  output_data (pbuf, buf_size, t_long,
		       data->param[0] / current_config.code_align);
d574 14
a587 26
    case CFA_def_cfa:
      if (verbose)
	printf ("\t# CFA_def_cfa(%ld,%ld)\n",
		data->param[0], data->param[1]);
      output_data (pbuf, buf_size, t_byte, CFA_def_cfa);
      output_data (pbuf, buf_size, t_uleb128, data->param[0]);
      output_data (pbuf, buf_size, t_uleb128, data->param[1]);
      break;

    case CFA_def_cfa_register:
    case CFA_def_cfa_offset:
      if (verbose)
	printf ("\t# %s(%ld)\n", cfi_insn_str (data->insn),
		data->param[0]);
      output_data (pbuf, buf_size, t_byte, data->insn);
      output_data (pbuf, buf_size, t_uleb128, data->param[0]);
      break;

    case CFA_offset:
      if (verbose)
	printf ("\t# %s(%ld,%ld)\n", cfi_insn_str (data->insn),
		data->param[0], data->param[1]);

      /* Check whether to use CFA_offset or CFA_offset_extended.  */
      if (data->param[0] <= 0x3F)
	output_data (pbuf, buf_size, t_byte, CFA_offset + data->param[0]);
d590 3
a592 2
	  output_data (pbuf, buf_size, t_byte, CFA_offset_extended);
	  output_data (pbuf, buf_size, t_uleb128, data->param[0]);
a593 2
      output_data (pbuf, buf_size, t_uleb128,
		   data->param[1] / current_config.data_align);
d596 8
a603 13
    case CFA_register:
      if (verbose)
	printf ("\t# %s(%ld,%ld)\n", cfi_insn_str (data->insn),
		data->param[0], data->param[1]);
      output_data (pbuf, buf_size, t_byte, CFA_register);
      output_data (pbuf, buf_size, t_uleb128, data->param[0]);
      output_data (pbuf, buf_size, t_uleb128, data->param[1]);
      break;

    case CFA_nop:
      if (verbose)
	printf ("\t# CFA_nop\n");
      output_data (pbuf, buf_size, t_byte, CFA_nop);
d607 1
a607 2
      as_warn ("CFA_unknown[%d](%ld,%ld)", data->insn,
	       data->param[0], data->param[1]);
a608 4
  size = *pbuf - orig_buf;
  *buf = *pbuf;
  *buf_size -= size;
  return size;
d612 1
a612 1
dot_cfi_endproc (void)
d614 1
a614 6
  struct cfi_data *data_ptr;
  struct cie_entry *cie_ptr;
  char *cie_buf, *fde_buf, *pbuf, *where;
  unsigned long buf_size, cie_size, fde_size, last_cie_offset;
  unsigned long fde_initloc_offset, fde_len_offset, fde_offset;
  segT saved_seg, cfi_seg;
d616 31
d648 16
a663 6
  if (! cfi_info)
    {
      as_bad (_(".cfi_endproc without corresponding .cfi_startproc"));
      return;
    }
  cfi_info->end_address = frag_now_fix ();
d665 7
a671 8
  /* Open .eh_frame section.  */
  saved_seg = now_seg;
  cfi_seg = subseg_new (".eh_frame", 0);
#ifdef BFD_ASSEMBLER
  bfd_set_section_flags (stdoutput, cfi_seg,
			 SEC_ALLOC | SEC_LOAD | SEC_RELOC | SEC_DATA);
#endif
  subseg_set (cfi_seg, 0);
d673 3
a675 79
  /* Build CIE.  */
  cie_buf = xcalloc (1024, 1);
  /* Skip space for CIE length.  */
  pbuf = cie_buf + 4;
  buf_size = 1020;

  if (verbose)
    printf ("# CIE *****\n");

  /* CIE id.  */
  output_data (&pbuf, &buf_size, t_long, 0x0);
  /* Version.  */
  output_data (&pbuf, &buf_size, t_byte, 1);
  /* Augmentation.  */
  output_data (&pbuf, &buf_size, t_byte, 0);
  /* Code alignment.  */
  output_data (&pbuf, &buf_size, t_uleb128, current_config.code_align);
  /* Data alignment.  */
  output_data (&pbuf, &buf_size, t_sleb128, current_config.data_align);
  /* Return address column.  */
  output_data (&pbuf, &buf_size, t_byte, current_config.ra_column);

  /* Build CFI instructions.  */
  data_ptr = cfi_info->data;
  while (data_ptr && !cfi_is_advance_insn (data_ptr->insn))
    {
      cfi_output_insn (data_ptr, &pbuf, &buf_size);
      data_ptr = data_ptr->next;
    }

  /* Align the whole data to current_config.eh_align.  */
  cie_size = pbuf - cie_buf;
  cie_size += current_config.eh_align - cie_size % current_config.eh_align;

  /* CIE length.  */
  pbuf = cie_buf;
  output_data (&pbuf, &buf_size, t_long, cie_size - 4);

  /* OK, we built the CIE. Let's write it to the file...  */
  last_cie_offset = frag_now_fix ();

  /* Check if we have already emitted the exactly same CIE. 
     If yes then use its offset instead and don't put out 
     the new one.  */
  cie_ptr = cie_root;
  while (cie_ptr)
    {
      if (cie_ptr->size == cie_size - 4
	  && memcmp (cie_ptr->data, cie_buf + 4, cie_ptr->size) == 0)
	break;
      cie_ptr = cie_ptr->next;
    }

  /* If we have found the same CIE, use it...  */
  if (cie_ptr)
    {
      if (verbose)
	printf ("# Duplicate CIE found. Previous is at offset %lu\n",
		cie_ptr->offset);
      last_cie_offset = cie_ptr->offset;
    }
  else
    {
      /* Otherwise join this CIE to the list.  */
      where = (unsigned char *) frag_more (cie_size);
      memcpy (where, cie_buf, cie_size);
      if (cie_root)
	{
	  cie_ptr = cie_root;
	  while (cie_ptr->next)
	    cie_ptr = cie_ptr->next;
	  cie_ptr->next = calloc (sizeof (struct cie_entry), 1);
	  cie_ptr = cie_ptr->next;
	}
      else
	{
	  cie_root = calloc (sizeof (struct cie_entry), 1);
	  cie_ptr = cie_root;
	}
d677 1
a677 5
      cie_ptr->size = cie_size - 4;
      cie_ptr->data = calloc (cie_ptr->size, 1);
      cie_ptr->offset = last_cie_offset;
      memcpy (cie_ptr->data, cie_buf + 4, cie_ptr->size);
    }
d679 2
a680 2
  /* Clean up.  */
  free (cie_buf);
d682 3
a684 4
  /* Build the FDE...  */
  fde_buf = xcalloc (1024, 1);
  pbuf = fde_buf;
  buf_size = 1024;
d686 5
a690 2
  /* Offset of this FDE in current fragment.  */
  fde_offset = frag_now_fix ();
d692 1
a692 1
  if (verbose)
d694 14
a707 5
      printf ("# FDE: start=0x%lx, end=0x%lx, delta=%d\n",
	      (long) cfi_info->start_address,
	      (long) cfi_info->end_address,
	      (int) (cfi_info->end_address - cfi_info->start_address));
    }
d709 7
a715 4
  /* FDE length (t_long, 4 bytes) - will be set later.  */
  fde_len_offset = pbuf - fde_buf;
  pbuf += 4;
  buf_size -= 4;
d717 6
a722 2
  /* CIE pointer - offset from here.  */
  output_data (&pbuf, &buf_size, t_long, fde_offset - last_cie_offset + 4);
d724 4
a727 4
  /* FDE initial location - this must be set relocatable!  */
  fde_initloc_offset = pbuf - fde_buf + fde_offset;
  output_data (&pbuf, &buf_size, current_config.addr_length,
	       cfi_info->start_address);
d729 4
a732 3
  /* FDE address range.  */
  output_data (&pbuf, &buf_size, current_config.addr_length,
	       cfi_info->end_address - cfi_info->start_address);
d734 4
a737 5
  while (data_ptr)
    {
      cfi_output_insn (data_ptr, &pbuf, &buf_size);
      data_ptr = data_ptr->next;
    }
d739 7
a745 2
  fde_size = pbuf - fde_buf;
  fde_size += current_config.eh_align - fde_size % current_config.eh_align;
d747 2
a748 4
  /* Now we can set FDE length.  */
  pbuf = fde_buf + fde_len_offset;
  buf_size = 4;
  output_data (&pbuf, &buf_size, t_long, fde_size - 4);
d750 5
a754 3
  /* Copy FDE to objfile.  */
  where = (unsigned char *) frag_more (fde_size);
  memcpy (where, fde_buf, fde_size);
d756 3
a758 11
  /* Set relocation for initial address.  */
  buf_size = current_config.addr_length;
  memset (&exp, 0, sizeof (exp));
  exp.X_op = O_symbol;
  exp.X_add_symbol = symbol_find (cfi_info->labelname);
  fix_new_exp (frag_now, fde_initloc_offset,
	       current_config.addr_length,
	       &exp, 0, current_config.reloc_type);

  /* Clean up.  */
  free (fde_buf);
d760 4
a763 2
  free (cfi_info);
  cfi_info = NULL;
d765 1
a765 2
  /* Restore previous segment.  */
  subseg_set (saved_seg, 0);
d769 1
a769 1
dot_cfi (int arg)
d771 2
a772 1
  long param;
d774 1
a774 1
  switch (arg)
d776 2
a777 23
    case CFI_startproc:
      dot_cfi_startproc ();
      break;
    case CFI_endproc:
      dot_cfi_endproc ();
      break;
    case CFA_def_cfa:
    case CFA_def_cfa_register:
    case CFA_def_cfa_offset:
    case CFA_offset:
    case CFA_register:
    case CFI_adjust_cfa_offset:
      cfi_make_insn (arg);
      break;
    case CFI_verbose:
      if (cfi_parse_const (&param) >= 0)
	verbose = (int) param;
      else
	verbose = 1;
      break;
    default:
      as_bad (_("unknown CFI code 0x%x (%s)"), arg, cfi_insn_str (arg));
      break;
a778 2
  ignore_rest_of_line ();
}
d780 11
a790 5
void
cfi_set_config (struct cfi_config *cfg)
{
  assert (cfg != NULL);
  assert (cfg->addr_length > 0);
d792 4
a795 2
  current_config = *cfg;
}
d797 3
a799 5
void
cfi_finish (void)
{
  if (cfi_info)
    as_bad (_("open CFI at the end of file; missing .cfi_endproc directive"));
@


1.3
log
@2003-05-20  Michal Ludvig  <mludvig@@suse.cz>

	* as.c (main): Remove tc_cfi_init().
	* dw2gencfi.c (cfi_parse_arg): Allow regnames beginning
	with '%'.
	(cfi_pseudo_table): Add "cfi_register" entry.
	(cfi_make_insn): Handle CFA_register.
	(cfi_output_insn): Ditto.
	(dot_cfi): Ditto.
	(cfi_get_label): Add 'simple' modifier to .cfi_startproc.
	(dot_cfi_endproc): Reuse already emitted CIEs.
	* testsuite/gas/cfi/cfi-i386.d: New pattern.
	* testsuite/gas/cfi/cfi-x86-64.d: Ditto.
@
text
@d354 2
a355 3
	{
	  return symbolP;
	}
d359 1
d363 3
d372 1
d374 1
d604 1
a604 1
  void *saved_seg, *cfi_seg;
d617 1
d620 1
@


1.2
log
@	* dw2gencfi.c (cfi_parse_arg): Only use tc_regname_to_dw2regnum if
	defined.
	(dot_cfi_endproc): Avoid C99 construct.
@
text
@d26 31
d73 1
a124 19
struct cfi_data
{
  enum cfi_insn insn;
  long param[2];
  struct cfi_data *next;
};

struct cfi_info
{
  addressT start_address;
  addressT end_address;
  addressT last_address;
  const char *labelname;
  struct cfi_data *data;
  struct cfi_info *next;
};

static struct cfi_info *cfi_info;

d154 3
a156 1
  else if (resolvereg && (is_name_beginner (*input_line_pointer)))
d289 15
d369 2
d377 7
d390 1
d392 4
a395 1
  tc_cfi_frame_initial_instructions ();
d403 2
a415 2
/* Output CFI instructions to the file.  */

d439 2
a440 1
      as_warn (_("unknown type %d"), type);
d481 1
a481 1
      as_warn ("unknown type %d", type);
d533 2
a534 1
	printf ("\t# CFA_def_cfa(%ld,%ld)\n", data->param[0], data->param[1]);
d566 9
d595 1
d597 2
a598 2
  unsigned long  buf_size, cie_size, fde_size, last_cie_offset;
  unsigned long	fde_initloc_offset, fde_len_offset;
d656 45
a700 2
  where = (unsigned char *) frag_more (cie_size);
  memcpy (where, cie_buf, cie_size);
d710 3
d727 1
a727 1
  output_data (&pbuf, &buf_size, t_long, cie_size + 4);
d730 1
a730 1
  fde_initloc_offset = pbuf - fde_buf;
a751 3
  /* Adjust initloc offset.  */
  fde_initloc_offset += frag_now_fix ();

d792 1
@


1.1
log
@	* dw2gencfi.c, dw2gencfi.h: New files.
	* config/tc-i386.c (tc_x86_cfi_init): New function.
	* config/tc-i386.h (TARGET_USE_CFIPOP, tc_cfi_init): New defines.
	* as.c (parse_args): Set verbose flag on --verbose.
	(main): Call tc_cfi_init()/cfi_finish().
	* as.h (verbose): New external variable.
	* read.c (pobegin): Insert CFI pops to the list.
	* symbols.c (local_symbol_make): Make symbol external.
	* symbols.h (local_symbol_make): New prototype.
	* Makefile.am: Add dw2gencfi.[ch] files.  Run "make dep-am".
	* Makefile.in: Regenerate.
	* doc/as.texinfo: Added node "CFI directives" with description of
	all implemented .cfi_* directives.
	* doc/Makefile.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@a127 1
  char *name, c, *p;
d140 1
d143 2
d154 1
d545 1
a659 1
  expressionS exp;
@

