head	1.33;
access;
symbols
	binutils-2_24-branch:1.33.0.2
	binutils-2_24-branchpoint:1.33
	binutils-2_21_1:1.30
	binutils-2_23_2:1.32
	binutils-2_23_1:1.32
	binutils-2_23:1.32
	binutils-2_23-branch:1.32.0.2
	binutils-2_23-branchpoint:1.32
	binutils-2_22_branch:1.30.0.8
	binutils-2_22:1.30
	binutils-2_22-branch:1.30.0.6
	binutils-2_22-branchpoint:1.30
	binutils-2_21:1.30
	binutils-2_21-branch:1.30.0.4
	binutils-2_21-branchpoint:1.30
	binutils-2_20_1:1.30
	binutils-2_20:1.30
	binutils-arc-20081103-branch:1.28.0.6
	binutils-arc-20081103-branchpoint:1.28
	binutils-2_20-branch:1.30.0.2
	binutils-2_20-branchpoint:1.30
	dje-cgen-play1-branch:1.29.0.2
	dje-cgen-play1-branchpoint:1.29
	arc-20081103-branch:1.28.0.4
	arc-20081103-branchpoint:1.28
	binutils-2_19_1:1.28
	binutils-2_19:1.28
	binutils-2_19-branch:1.28.0.2
	binutils-2_19-branchpoint:1.28
	binutils-2_18:1.26
	binutils-2_18-branch:1.26.0.2
	binutils-2_18-branchpoint:1.26
	binutils-csl-coldfire-4_1-32:1.22
	binutils-csl-sourcerygxx-4_1-32:1.22
	binutils-csl-innovasic-fido-3_4_4-33:1.22
	binutils-csl-sourcerygxx-3_4_4-32:1.21
	binutils-csl-coldfire-4_1-30:1.22
	binutils-csl-sourcerygxx-4_1-30:1.22
	binutils-csl-coldfire-4_1-28:1.22
	binutils-csl-sourcerygxx-4_1-29:1.22
	binutils-csl-sourcerygxx-4_1-28:1.22
	binutils-csl-arm-2006q3-27:1.22
	binutils-csl-sourcerygxx-4_1-27:1.22
	binutils-csl-arm-2006q3-26:1.22
	binutils-csl-sourcerygxx-4_1-26:1.22
	binutils-csl-sourcerygxx-4_1-25:1.22
	binutils-csl-sourcerygxx-4_1-24:1.22
	binutils-csl-sourcerygxx-4_1-23:1.22
	binutils-csl-sourcerygxx-4_1-21:1.22
	binutils-csl-arm-2006q3-21:1.22
	binutils-csl-sourcerygxx-4_1-22:1.22
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.22
	binutils-csl-sourcerygxx-4_1-20:1.22
	binutils-csl-arm-2006q3-19:1.22
	binutils-csl-sourcerygxx-4_1-19:1.22
	binutils-csl-sourcerygxx-4_1-18:1.22
	binutils-csl-renesas-4_1-9:1.22
	binutils-csl-sourcerygxx-3_4_4-25:1.21
	binutils-csl-renesas-4_1-8:1.22
	binutils-csl-renesas-4_1-7:1.22
	binutils-csl-renesas-4_1-6:1.22
	binutils-csl-sourcerygxx-4_1-17:1.22
	binutils-csl-sourcerygxx-4_1-14:1.22
	binutils-csl-sourcerygxx-4_1-15:1.22
	binutils-csl-sourcerygxx-4_1-13:1.22
	binutils-2_17:1.22
	binutils-csl-sourcerygxx-4_1-12:1.22
	binutils-csl-sourcerygxx-3_4_4-21:1.22
	binutils-csl-wrs-linux-3_4_4-24:1.21
	binutils-csl-wrs-linux-3_4_4-23:1.21
	binutils-csl-sourcerygxx-4_1-9:1.22
	binutils-csl-sourcerygxx-4_1-8:1.22
	binutils-csl-sourcerygxx-4_1-7:1.22
	binutils-csl-arm-2006q1-6:1.22
	binutils-csl-sourcerygxx-4_1-6:1.22
	binutils-csl-wrs-linux-3_4_4-22:1.21
	binutils-csl-coldfire-4_1-11:1.22
	binutils-csl-sourcerygxx-3_4_4-19:1.22
	binutils-csl-coldfire-4_1-10:1.22
	binutils-csl-sourcerygxx-4_1-5:1.22
	binutils-csl-sourcerygxx-4_1-4:1.22
	binutils-csl-wrs-linux-3_4_4-21:1.21
	binutils-csl-morpho-4_1-4:1.22
	binutils-csl-sourcerygxx-3_4_4-17:1.22
	binutils-csl-wrs-linux-3_4_4-20:1.21
	binutils-2_17-branch:1.22.0.4
	binutils-2_17-branchpoint:1.22
	binutils-csl-2_17-branch:1.22.0.2
	binutils-csl-2_17-branchpoint:1.22
	binutils-csl-gxxpro-3_4-branch:1.21.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.21
	binutils-2_16_1:1.21
	binutils-csl-arm-2005q1b:1.21
	binutils-2_16:1.21
	binutils-csl-arm-2005q1a:1.21
	binutils-csl-arm-2005q1-branch:1.21.0.4
	binutils-csl-arm-2005q1-branchpoint:1.21
	binutils-2_16-branch:1.21.0.2
	binutils-2_16-branchpoint:1.21
	csl-arm-2004-q3d:1.19
	csl-arm-2004-q3:1.19
	binutils-2_15:1.19
	binutils-2_15-branchpoint:1.19
	csl-arm-2004-q1a:1.19
	csl-arm-2004-q1:1.19
	binutils-2_15-branch:1.19.0.6
	cagney_bfdfile-20040213-branch:1.19.0.4
	cagney_bfdfile-20040213-branchpoint:1.19
	cagney_bigcore-20040122-branch:1.19.0.2
	cagney_bigcore-20040122-branchpoint:1.19
	csl-arm-2003-q4:1.19
	binutils-2_14:1.17
	binutils-2_14-branch:1.17.0.2
	binutils-2_14-branchpoint:1.17
	binutils-2_13_2_1:1.15.2.1
	binutils-2_13_2:1.15.2.1
	binutils-2_13_1:1.15.2.1
	binutils-2_13:1.15
	binutils-2_13-branchpoint:1.15
	binutils-2_13-branch:1.15.0.2
	binutils-2_12_1:1.7.2.1
	binutils-2_12:1.7
	binutils-2_12-branch:1.7.0.2
	binutils-2_12-branchpoint:1.7
	cygnus_cvs_20020108_pre:1.7
	binutils-2_11_2:1.4.2.1
	binutils-2_11_1:1.4.2.1
	binutils-2_11:1.4
	x86_64versiong3:1.4
	binutils-2_11-branch:1.4.0.2
	binutils-2_10_1:1.2
	binutils-2_10:1.2
	binutils-2_10-branch:1.2.0.2
	binutils-2_10-branchpoint:1.2
	binutils_latest_snapshot:1.33
	repo-unification-2000-02-06:1.2
	binu_ss_19990721:1.2
	binu_ss_19990602:1.2
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.33
date	2012.07.28.08.21.48;	author ktietz;	state Exp;
branches;
next	1.32;

1.32
date	2011.10.25.08.03.17;	author ktietz;	state Exp;
branches;
next	1.31;

1.31
date	2011.10.11.15.56.28;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	2009.09.02.07.22.32;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2008.12.23.10.00.31;	author ktietz;	state Exp;
branches;
next	1.28;

1.28
date	2008.03.16.07.26.56;	author briand;	state Exp;
branches;
next	1.27;

1.27
date	2007.09.11.14.05.09;	author ktietz;	state Exp;
branches;
next	1.26;

1.26
date	2007.07.05.16.54.45;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2007.05.24.11.01.07;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2007.05.23.08.48.29;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2007.04.26.14.46.59;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2005.05.08.14.17.39;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2005.02.17.12.59.59;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2005.01.17.16.24.12;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2003.09.14.12.20.16;	author aj;	state Exp;
branches;
next	1.18;

1.18
date	2003.06.28.02.37.43;	author dannysmith;	state Exp;
branches;
next	1.17;

1.17
date	2003.03.31.10.15.58;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2002.08.14.10.44.54;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2002.05.05.23.19.32;	author amodra;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2002.04.16.08.12.56;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2002.04.15.14.12.37;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2002.04.10.08.14.27;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2002.04.09.17.23.18;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2002.04.09.15.59.12;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2002.04.09.15.23.38;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2002.04.09.15.21.00;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.19.05.33.16;	author hjl;	state Exp;
branches
	1.7.2.1;
next	1.6;

1.6
date	2001.07.17.01.19.19;	author dj;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.13.06.43.57;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2000.10.12.17.47.35;	author dj;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2000.06.13.21.21.42;	author dj;	state Exp;
branches;
next	1.2;

1.2
date	99.05.12.22.03.10;	author dj;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.29.10;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.15.2.1
date	2002.09.23.22.13.11;	author drow;	state Exp;
branches;
next	;

1.7.2.1
date	2002.05.09.11.53.25;	author amodra;	state Exp;
branches;
next	;

1.4.2.1
date	2001.06.07.03.12.28;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.10;	author rth;	state Exp;
branches;
next	;


desc
@@


1.33
log
@       * rcparse.y (FILEVERSION): Use optcnumexpr instead of cnumexpr.
       (PRODUCTVERSION): Likewise.

       * binutils-all/windres/version_small.rc: New test.
       * binutils-all/windres/version_small.rsd: Likewise.
@
text
@%{ /* rcparse.y -- parser for Windows rc files
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2007, 2008,
   2011  Free Software Foundation, Inc.
   Written by Ian Lance Taylor, Cygnus Support.
   Extended by Kai Tietz, Onevision.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */


/* This is a parser for Windows rc files.  It is based on the parser
   by Gunther Ebert <gunther.ebert@@ixos-leipzig.de>.  */

#include "sysdep.h"
#include "bfd.h"
#include "bucomm.h"
#include "libiberty.h"
#include "windres.h"
#include "safe-ctype.h"

/* The current language.  */

static unsigned short language;

/* The resource information during a sub statement.  */

static rc_res_res_info sub_res_info;

/* Dialog information.  This is built by the nonterminals styles and
   controls.  */

static rc_dialog dialog;

/* This is used when building a style.  It is modified by the
   nonterminal styleexpr.  */

static unsigned long style;

/* These are used when building a control.  They are set before using
   control_params.  */

static rc_uint_type base_style;
static rc_uint_type default_style;
static rc_res_id class;
static rc_res_id res_text_field;
static unichar null_unichar;

/* This is used for COMBOBOX, LISTBOX and EDITTEXT which
   do not allow resource 'text' field in control definition. */
static const rc_res_id res_null_text = { 1, {{0, &null_unichar}}};

%}

%union
{
  rc_accelerator acc;
  rc_accelerator *pacc;
  rc_dialog_control *dialog_control;
  rc_menuitem *menuitem;
  struct
  {
    rc_rcdata_item *first;
    rc_rcdata_item *last;
  } rcdata;
  rc_rcdata_item *rcdata_item;
  rc_fixed_versioninfo *fixver;
  rc_ver_info *verinfo;
  rc_ver_stringtable *verstringtable;
  rc_ver_stringinfo *verstring;
  rc_ver_varinfo *vervar;
  rc_toolbar_item *toobar_item;
  rc_res_id id;
  rc_res_res_info res_info;
  struct
  {
    rc_uint_type on;
    rc_uint_type off;
  } memflags;
  struct
  {
    rc_uint_type val;
    /* Nonzero if this number was explicitly specified as long.  */
    int dword;
  } i;
  rc_uint_type il;
  rc_uint_type is;
  const char *s;
  struct
  {
    rc_uint_type length;
    const char *s;
  } ss;
  unichar *uni;
  struct
  {
    rc_uint_type length;
    const unichar *s;
  } suni;
};

%token BEG END
%token ACCELERATORS VIRTKEY ASCII NOINVERT SHIFT CONTROL ALT
%token BITMAP
%token CURSOR
%token DIALOG DIALOGEX EXSTYLE CAPTION CLASS STYLE
%token AUTO3STATE AUTOCHECKBOX AUTORADIOBUTTON CHECKBOX COMBOBOX CTEXT
%token DEFPUSHBUTTON EDITTEXT GROUPBOX LISTBOX LTEXT PUSHBOX PUSHBUTTON
%token RADIOBUTTON RTEXT SCROLLBAR STATE3 USERBUTTON
%token BEDIT HEDIT IEDIT
%token FONT
%token ICON
%token ANICURSOR ANIICON DLGINCLUDE DLGINIT FONTDIR HTML MANIFEST PLUGPLAY VXD TOOLBAR BUTTON
%token LANGUAGE CHARACTERISTICS VERSIONK
%token MENU MENUEX MENUITEM SEPARATOR POPUP CHECKED GRAYED HELP INACTIVE
%token MENUBARBREAK MENUBREAK
%token MESSAGETABLE
%token RCDATA
%token STRINGTABLE
%token VERSIONINFO FILEVERSION PRODUCTVERSION FILEFLAGSMASK FILEFLAGS
%token FILEOS FILETYPE FILESUBTYPE BLOCKSTRINGFILEINFO BLOCKVARFILEINFO
%token VALUE
%token <s> BLOCK
%token MOVEABLE FIXED PURE IMPURE PRELOAD LOADONCALL DISCARDABLE
%token NOT
%token <uni> QUOTEDUNISTRING
%token <s> QUOTEDSTRING STRING
%token <i> NUMBER
%token <suni> SIZEDUNISTRING
%token <ss> SIZEDSTRING
%token IGNORED_TOKEN

%type <pacc> acc_entries
%type <acc> acc_entry acc_event
%type <dialog_control> control control_params
%type <menuitem> menuitems menuitem menuexitems menuexitem
%type <rcdata> optrcdata_data optrcdata_data_int rcdata_data
%type <rcdata_item> opt_control_data
%type <fixver> fixedverinfo
%type <verinfo> verblocks
%type <verstringtable> verstringtables
%type <verstring> vervals
%type <vervar> vertrans
%type <toobar_item> toolbar_data
%type <res_info> suboptions memflags_move_discard memflags_move
%type <memflags> memflag
%type <id> id rcdata_id optresidc resref resid cresid
%type <il> exstyle parennumber
%type <il> numexpr posnumexpr cnumexpr optcnumexpr cposnumexpr
%type <is> acc_options acc_option menuitem_flags menuitem_flag
%type <s> file_name
%type <uni> res_unicode_string resname res_unicode_string_concat
%type <ss> sizedstring
%type <suni> sizedunistring res_unicode_sizedstring res_unicode_sizedstring_concat
%type <i> sizednumexpr sizedposnumexpr

%left '|'
%left '^'
%left '&'
%left '+' '-'
%left '*' '/' '%'
%right '~' NEG

%%

input:
	  /* empty */
	| input accelerator
	| input bitmap
	| input cursor
	| input dialog
	| input font
	| input icon
	| input language
	| input menu
	| input menuex
	| input messagetable
	| input stringtable
	| input toolbar
	| input user
	| input versioninfo
	| input IGNORED_TOKEN
	;

/* Accelerator resources.  */

accelerator:
	  id ACCELERATORS suboptions BEG acc_entries END
	  {
	    define_accelerator ($1, &$3, $5);
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
	  }
	;

acc_entries:
	  /* empty */
	  {
	    $$ = NULL;
	  }
	| acc_entries acc_entry
	  {
	    rc_accelerator *a;

	    a = (rc_accelerator *) res_alloc (sizeof *a);
	    *a = $2;
	    if ($1 == NULL)
	      $$ = a;
	    else
	      {
		rc_accelerator **pp;

		for (pp = &$1->next; *pp != NULL; pp = &(*pp)->next)
		  ;
		*pp = a;
		$$ = $1;
	      }
	  }
	;

acc_entry:
	  acc_event cposnumexpr
	  {
	    $$ = $1;
	    $$.id = $2;
	  }
	| acc_event cposnumexpr ',' acc_options
	  {
	    $$ = $1;
	    $$.id = $2;
	    $$.flags |= $4;
	    if (($$.flags & ACC_VIRTKEY) == 0
		&& ($$.flags & (ACC_SHIFT | ACC_CONTROL)) != 0)
	      rcparse_warning (_("inappropriate modifiers for non-VIRTKEY"));
	  }
	;

acc_event:
	  QUOTEDSTRING
	  {
	    const char *s = $1;
	    char ch;

	    $$.next = NULL;
	    $$.id = 0;
	    ch = *s;
	    if (ch != '^')
	      $$.flags = 0;
	    else
	      {
		$$.flags = ACC_CONTROL | ACC_VIRTKEY;
		++s;
		ch = TOUPPER (s[0]);
	      }
	    $$.key = ch;
	    if (s[1] != '\0')
	      rcparse_warning (_("accelerator should only be one character"));
	  }
	| posnumexpr
	  {
	    $$.next = NULL;
	    $$.flags = 0;
	    $$.id = 0;
	    $$.key = $1;
	  }
	;

acc_options:
	  acc_option
	  {
	    $$ = $1;
	  }
	| acc_options ',' acc_option
	  {
	    $$ = $1 | $3;
	  }
	/* I've had one report that the comma is optional.  */
	| acc_options acc_option
	  {
	    $$ = $1 | $2;
	  }
	;

acc_option:
	  VIRTKEY
	  {
	    $$ = ACC_VIRTKEY;
	  }
	| ASCII
	  {
	    /* This is just the absence of VIRTKEY.  */
	    $$ = 0;
	  }
	| NOINVERT
	  {
	    $$ = ACC_NOINVERT;
	  }
	| SHIFT
	  {
	    $$ = ACC_SHIFT;
	  }
	| CONTROL
	  {
	    $$ = ACC_CONTROL;
	  }
	| ALT
	  {
	    $$ = ACC_ALT;
	  }
	;

/* Bitmap resources.  */

bitmap:
	  id BITMAP memflags_move file_name
	  {
	    define_bitmap ($1, &$3, $4);
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
	  }
	;

/* Cursor resources.  */

cursor:
	  id CURSOR memflags_move_discard file_name
	  {
	    define_cursor ($1, &$3, $4);
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
	  }
	;

/* Dialog resources.  */

dialog:
	  id DIALOG memflags_move exstyle posnumexpr cnumexpr cnumexpr
	    cnumexpr
	    {
	      memset (&dialog, 0, sizeof dialog);
	      dialog.x = $5;
	      dialog.y = $6;
	      dialog.width = $7;
	      dialog.height = $8;
	      dialog.style = WS_POPUP | WS_BORDER | WS_SYSMENU;
	      dialog.exstyle = $4;
	      dialog.menu.named = 1;
	      dialog.class.named = 1;
	      dialog.font = NULL;
	      dialog.ex = NULL;
	      dialog.controls = NULL;
	      sub_res_info = $3;
	      style = 0;
	    }
	    styles BEG controls END
	  {
	    define_dialog ($1, &sub_res_info, &dialog);
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
	  }
	| id DIALOGEX memflags_move exstyle posnumexpr cnumexpr cnumexpr
	    cnumexpr
	    {
	      memset (&dialog, 0, sizeof dialog);
	      dialog.x = $5;
	      dialog.y = $6;
	      dialog.width = $7;
	      dialog.height = $8;
	      dialog.style = WS_POPUP | WS_BORDER | WS_SYSMENU;
	      dialog.exstyle = $4;
	      dialog.menu.named = 1;
	      dialog.class.named = 1;
	      dialog.font = NULL;
	      dialog.ex = ((rc_dialog_ex *)
			   res_alloc (sizeof (rc_dialog_ex)));
	      memset (dialog.ex, 0, sizeof (rc_dialog_ex));
	      dialog.controls = NULL;
	      sub_res_info = $3;
	      style = 0;
	    }
	    styles BEG controls END
	  {
	    define_dialog ($1, &sub_res_info, &dialog);
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
	  }
	| id DIALOGEX memflags_move exstyle posnumexpr cnumexpr cnumexpr
	    cnumexpr cnumexpr
	    {
	      memset (&dialog, 0, sizeof dialog);
	      dialog.x = $5;
	      dialog.y = $6;
	      dialog.width = $7;
	      dialog.height = $8;
	      dialog.style = WS_POPUP | WS_BORDER | WS_SYSMENU;
	      dialog.exstyle = $4;
	      dialog.menu.named = 1;
	      dialog.class.named = 1;
	      dialog.font = NULL;
	      dialog.ex = ((rc_dialog_ex *)
			   res_alloc (sizeof (rc_dialog_ex)));
	      memset (dialog.ex, 0, sizeof (rc_dialog_ex));
	      dialog.ex->help = $9;
	      dialog.controls = NULL;
	      sub_res_info = $3;
	      style = 0;
	    }
	    styles BEG controls END
	  {
	    define_dialog ($1, &sub_res_info, &dialog);
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
	  }
	;

exstyle:
	  /* empty */
	  {
	    $$ = 0;
	  }
	| EXSTYLE '=' numexpr
	  {
	    $$ = $3;
	  }
	;

styles:
	  /* empty */
	| styles CAPTION res_unicode_string_concat
	  {
	    dialog.style |= WS_CAPTION;
	    style |= WS_CAPTION;
	    dialog.caption = $3;
	  }
	| styles CLASS id
	  {
	    dialog.class = $3;
	  }
	| styles STYLE
	    styleexpr
	  {
	    dialog.style = style;
	  }
	| styles EXSTYLE numexpr
	  {
	    dialog.exstyle = $3;
	  }
	| styles CLASS res_unicode_string_concat
	  {
	    res_unistring_to_id (& dialog.class, $3);
	  }
	| styles FONT numexpr ',' res_unicode_string_concat
	  {
	    dialog.style |= DS_SETFONT;
	    style |= DS_SETFONT;
	    dialog.pointsize = $3;
	    dialog.font = $5;
	    if (dialog.ex != NULL)
	      {
		dialog.ex->weight = 0;
		dialog.ex->italic = 0;
		dialog.ex->charset = 1;
	      }
	  }
	| styles FONT numexpr ',' res_unicode_string_concat cnumexpr
	  {
	    dialog.style |= DS_SETFONT;
	    style |= DS_SETFONT;
	    dialog.pointsize = $3;
	    dialog.font = $5;
	    if (dialog.ex == NULL)
	      rcparse_warning (_("extended FONT requires DIALOGEX"));
	    else
	      {
		dialog.ex->weight = $6;
		dialog.ex->italic = 0;
		dialog.ex->charset = 1;
	      }
	  }
	| styles FONT numexpr ',' res_unicode_string_concat cnumexpr cnumexpr
	  {
	    dialog.style |= DS_SETFONT;
	    style |= DS_SETFONT;
	    dialog.pointsize = $3;
	    dialog.font = $5;
	    if (dialog.ex == NULL)
	      rcparse_warning (_("extended FONT requires DIALOGEX"));
	    else
	      {
		dialog.ex->weight = $6;
		dialog.ex->italic = $7;
		dialog.ex->charset = 1;
	      }
	  }
	| styles FONT numexpr ',' res_unicode_string_concat cnumexpr cnumexpr cnumexpr
	  {
	    dialog.style |= DS_SETFONT;
	    style |= DS_SETFONT;
	    dialog.pointsize = $3;
	    dialog.font = $5;
	    if (dialog.ex == NULL)
	      rcparse_warning (_("extended FONT requires DIALOGEX"));
	    else
	      {
		dialog.ex->weight = $6;
		dialog.ex->italic = $7;
		dialog.ex->charset = $8;
	      }
	  }
	| styles MENU id
	  {
	    dialog.menu = $3;
	  }
	| styles CHARACTERISTICS numexpr
	  {
	    sub_res_info.characteristics = $3;
	  }
	| styles LANGUAGE numexpr cnumexpr
	  {
	    sub_res_info.language = $3 | ($4 << SUBLANG_SHIFT);
	  }
	| styles VERSIONK numexpr
	  {
	    sub_res_info.version = $3;
	  }
	;

controls:
	  /* empty */
	| controls control
	  {
	    rc_dialog_control **pp;

	    for (pp = &dialog.controls; *pp != NULL; pp = &(*pp)->next)
	      ;
	    *pp = $2;
	  }
	;

control:
	  AUTO3STATE optresidc
	    {
	      default_style = BS_AUTO3STATE | WS_TABSTOP;
	      base_style = BS_AUTO3STATE;
	      class.named = 0;
	      class.u.id = CTL_BUTTON;
	      res_text_field = $2;	
	    }
	    control_params
	  {
	    $$ = $4;
	  }
	| AUTOCHECKBOX optresidc
	    {
	      default_style = BS_AUTOCHECKBOX | WS_TABSTOP;
	      base_style = BS_AUTOCHECKBOX;
	      class.named = 0;
	      class.u.id = CTL_BUTTON;
	      res_text_field = $2;	
	    }
	    control_params
	  {
	    $$ = $4;
	  }
	| AUTORADIOBUTTON optresidc
	    {
	      default_style = BS_AUTORADIOBUTTON | WS_TABSTOP;
	      base_style = BS_AUTORADIOBUTTON;
	      class.named = 0;
	      class.u.id = CTL_BUTTON;
	      res_text_field = $2;	
	    }
	    control_params
	  {
	    $$ = $4;
	  }
	| BEDIT optresidc
	    {
	      default_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
	      base_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
	      class.named = 0;
	      class.u.id = CTL_EDIT;
	      res_text_field = $2;	
	    }
	    control_params
	  {
	    $$ = $4;
	    if (dialog.ex == NULL)
	      rcparse_warning (_("BEDIT requires DIALOGEX"));
	    res_string_to_id (&$$->class, "BEDIT");
	  }
	| CHECKBOX optresidc
	    {
	      default_style = BS_CHECKBOX | WS_TABSTOP;
	      base_style = BS_CHECKBOX | WS_TABSTOP;
	      class.named = 0;
	      class.u.id = CTL_BUTTON;
	      res_text_field = $2;	
	    }
	    control_params
	  {
	    $$ = $4;
	  }
	| COMBOBOX
	    {
	      /* This is as per MSDN documentation.  With some (???)
		 versions of MS rc.exe their is no default style.  */
	      default_style = CBS_SIMPLE | WS_TABSTOP;
	      base_style = 0;
	      class.named = 0;
	      class.u.id = CTL_COMBOBOX;
	      res_text_field = res_null_text;	
	    }
	    control_params
	  {
	    $$ = $3;
	  }
	| CONTROL optresidc numexpr cresid control_styleexpr cnumexpr
	    cnumexpr cnumexpr cnumexpr optcnumexpr opt_control_data
	  {
	    $$ = define_control ($2, $3, $6, $7, $8, $9, $4, style, $10);
	    if ($11 != NULL)
	      {
		if (dialog.ex == NULL)
		  rcparse_warning (_("control data requires DIALOGEX"));
		$$->data = $11;
	      }
	  }
	| CONTROL optresidc numexpr cresid control_styleexpr cnumexpr
	    cnumexpr cnumexpr cnumexpr cnumexpr cnumexpr opt_control_data
	  {
	    $$ = define_control ($2, $3, $6, $7, $8, $9, $4, style, $10);
	    if (dialog.ex == NULL)
	      rcparse_warning (_("help ID requires DIALOGEX"));
	    $$->help = $11;
	    $$->data = $12;
	  }
	| CTEXT optresidc
	    {
	      default_style = SS_CENTER | WS_GROUP;
	      base_style = SS_CENTER;
	      class.named = 0;
	      class.u.id = CTL_STATIC;
	      res_text_field = $2;	
	    }
	    control_params
	  {
	    $$ = $4;
	  }
	| DEFPUSHBUTTON optresidc
	    {
	      default_style = BS_DEFPUSHBUTTON | WS_TABSTOP;
	      base_style = BS_DEFPUSHBUTTON | WS_TABSTOP;
	      class.named = 0;
	      class.u.id = CTL_BUTTON;
	      res_text_field = $2;	
	    }
	    control_params
	  {
	    $$ = $4;
	  }
	| EDITTEXT
	    {
	      default_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
	      base_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
	      class.named = 0;
	      class.u.id = CTL_EDIT;
	      res_text_field = res_null_text;	
	    }
	    control_params
	  {
	    $$ = $3;
	  }
	| GROUPBOX optresidc
	    {
	      default_style = BS_GROUPBOX;
	      base_style = BS_GROUPBOX;
	      class.named = 0;
	      class.u.id = CTL_BUTTON;
	      res_text_field = $2;	
	    }
	    control_params
	  {
	    $$ = $4;
	  }
	| HEDIT optresidc
	    {
	      default_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
	      base_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
	      class.named = 0;
	      class.u.id = CTL_EDIT;
	      res_text_field = $2;	
	    }
	    control_params
	  {
	    $$ = $4;
	    if (dialog.ex == NULL)
	      rcparse_warning (_("IEDIT requires DIALOGEX"));
	    res_string_to_id (&$$->class, "HEDIT");
	  }
	| ICON resref numexpr cnumexpr cnumexpr opt_control_data
          {
	    $$ = define_icon_control ($2, $3, $4, $5, 0, 0, 0, $6,
				      dialog.ex);
          }
	| ICON resref numexpr cnumexpr cnumexpr cnumexpr cnumexpr
	    opt_control_data
          {
	    $$ = define_icon_control ($2, $3, $4, $5, 0, 0, 0, $8,
				      dialog.ex);
          }
	| ICON resref numexpr cnumexpr cnumexpr cnumexpr cnumexpr
	    icon_styleexpr optcnumexpr opt_control_data
          {
	    $$ = define_icon_control ($2, $3, $4, $5, style, $9, 0, $10,
				      dialog.ex);
          }
	| ICON resref numexpr cnumexpr cnumexpr cnumexpr cnumexpr
	    icon_styleexpr cnumexpr cnumexpr opt_control_data
          {
	    $$ = define_icon_control ($2, $3, $4, $5, style, $9, $10, $11,
				      dialog.ex);
          }
	| IEDIT optresidc
	    {
	      default_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
	      base_style = ES_LEFT | WS_BORDER | WS_TABSTOP;
	      class.named = 0;
	      class.u.id = CTL_EDIT;
	      res_text_field = $2;	
	    }
	    control_params
	  {
	    $$ = $4;
	    if (dialog.ex == NULL)
	      rcparse_warning (_("IEDIT requires DIALOGEX"));
	    res_string_to_id (&$$->class, "IEDIT");
	  }
	| LISTBOX
	    {
	      default_style = LBS_NOTIFY | WS_BORDER;
	      base_style = LBS_NOTIFY | WS_BORDER;
	      class.named = 0;
	      class.u.id = CTL_LISTBOX;
	      res_text_field = res_null_text;	
	    }
	    control_params
	  {
	    $$ = $3;
	  }
	| LTEXT optresidc
	    {
	      default_style = SS_LEFT | WS_GROUP;
	      base_style = SS_LEFT;
	      class.named = 0;
	      class.u.id = CTL_STATIC;
	      res_text_field = $2;	
	    }
	    control_params
	  {
	    $$ = $4;
	  }
	| PUSHBOX optresidc
	    {
	      default_style = BS_PUSHBOX | WS_TABSTOP;
	      base_style = BS_PUSHBOX;
	      class.named = 0;
	      class.u.id = CTL_BUTTON;
	    }
	    control_params
	  {
	    $$ = $4;
	  }
	| PUSHBUTTON optresidc
	    {
	      default_style = BS_PUSHBUTTON | WS_TABSTOP;
	      base_style = BS_PUSHBUTTON | WS_TABSTOP;
	      class.named = 0;
	      class.u.id = CTL_BUTTON;
	      res_text_field = $2;	
	    }
	    control_params
	  {
	    $$ = $4;
	  }
	| RADIOBUTTON optresidc
	    {
	      default_style = BS_RADIOBUTTON | WS_TABSTOP;
	      base_style = BS_RADIOBUTTON;
	      class.named = 0;
	      class.u.id = CTL_BUTTON;
	      res_text_field = $2;	
	    }
	    control_params
	  {
	    $$ = $4;
	  }
	| RTEXT optresidc
	    {
	      default_style = SS_RIGHT | WS_GROUP;
	      base_style = SS_RIGHT;
	      class.named = 0;
	      class.u.id = CTL_STATIC;
	      res_text_field = $2;	
	    }
	    control_params
	  {
	    $$ = $4;
	  }
	| SCROLLBAR
	    {
	      default_style = SBS_HORZ;
	      base_style = 0;
	      class.named = 0;
	      class.u.id = CTL_SCROLLBAR;
	      res_text_field = res_null_text;	
	    }
	    control_params
	  {
	    $$ = $3;
	  }
	| STATE3 optresidc
	    {
	      default_style = BS_3STATE | WS_TABSTOP;
	      base_style = BS_3STATE;
	      class.named = 0;
	      class.u.id = CTL_BUTTON;
	      res_text_field = $2;	
	    }
	    control_params
	  {
	    $$ = $4;
	  }
	| USERBUTTON resref numexpr ',' numexpr ',' numexpr ','
	    numexpr ',' numexpr ',' 
	    { style = WS_CHILD | WS_VISIBLE; }
	    styleexpr optcnumexpr
	  {
	    rc_res_id cid;
	    cid.named = 0;
	    cid.u.id = CTL_BUTTON;
	    $$ = define_control ($2, $3, $5, $7, $9, $11, cid,
				 style, $15);
	  }
	;

/* Parameters for a control.  The static variables DEFAULT_STYLE,
   BASE_STYLE, and CLASS must be initialized before this nonterminal
   is used.  DEFAULT_STYLE is the style to use if no style expression
   is specified.  BASE_STYLE is the base style to use if a style
   expression is specified; the style expression modifies the base
   style.  CLASS is the class of the control.  */

control_params:
	  numexpr cnumexpr cnumexpr cnumexpr cnumexpr opt_control_data
	  {
	    $$ = define_control (res_text_field, $1, $2, $3, $4, $5, class,
				 default_style | WS_CHILD | WS_VISIBLE, 0);
	    if ($6 != NULL)
	      {
		if (dialog.ex == NULL)
		  rcparse_warning (_("control data requires DIALOGEX"));
		$$->data = $6;
	      }
	  }
	| numexpr cnumexpr cnumexpr cnumexpr cnumexpr
	    control_params_styleexpr optcnumexpr opt_control_data
	  {
	    $$ = define_control (res_text_field, $1, $2, $3, $4, $5, class, style, $7);
	    if ($8 != NULL)
	      {
		if (dialog.ex == NULL)
		  rcparse_warning (_("control data requires DIALOGEX"));
		$$->data = $8;
	      }
	  }
	| numexpr cnumexpr cnumexpr cnumexpr cnumexpr
	    control_params_styleexpr cnumexpr cnumexpr opt_control_data
	  {
	    $$ = define_control (res_text_field, $1, $2, $3, $4, $5, class, style, $7);
	    if (dialog.ex == NULL)
	      rcparse_warning (_("help ID requires DIALOGEX"));
	    $$->help = $8;
	    $$->data = $9;
	  }
	;

cresid:
	  ',' resid
	  {
	    if ($2.named)
	      res_unistring_to_id (&$$, $2.u.n.name);
	    else
	      $$=$2;
	  }
	;

optresidc:
	  /* empty */
	  {
	    res_string_to_id (&$$, "");
	  }
	| resid ',' { $$=$1; }
	;

resid:
	  posnumexpr
	  {
	    $$.named = 0;
	    $$.u.id = $1;
	  }
	| res_unicode_string_concat
	  {
	    $$.named = 1;
	    $$.u.n.name = $1;
	    $$.u.n.length = unichar_len ($1);
	  }
	;

opt_control_data:
	  /* empty */
	  {
	    $$ = NULL;
	  }
	| BEG optrcdata_data END
	  {
	    $$ = $2.first;
	  }
	;

/* These only exist to parse a reduction out of a common case.  */

control_styleexpr:
	  ','
	  { style = WS_CHILD | WS_VISIBLE; }
	  styleexpr
	;

icon_styleexpr:
	  ','
	  { style = SS_ICON | WS_CHILD | WS_VISIBLE; }
	  styleexpr
	;

control_params_styleexpr:
	  ','
	  { style = base_style | WS_CHILD | WS_VISIBLE; }
	  styleexpr
	;

/* Font resources.  */

font:
	  id FONT memflags_move_discard file_name
	  {
	    define_font ($1, &$3, $4);
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
	  }
	;

/* Icon resources.  */

icon:
	  id ICON memflags_move_discard file_name
	  {
	    define_icon ($1, &$3, $4);
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
	  }
	;

/* Language command.  This changes the static variable language, which
   affects all subsequent resources.  */

language:
	  LANGUAGE numexpr cnumexpr
	  {
	    language = $2 | ($3 << SUBLANG_SHIFT);
	  }
	;

/* Menu resources.  */

menu:
	  id MENU suboptions BEG menuitems END
	  {
	    define_menu ($1, &$3, $5);
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
	  }
	;

menuitems:
	  /* empty */
	  {
	    $$ = NULL;
	  }
	| menuitems menuitem
	  {
	    if ($1 == NULL)
	      $$ = $2;
	    else
	      {
		rc_menuitem **pp;

		for (pp = &$1->next; *pp != NULL; pp = &(*pp)->next)
		  ;
		*pp = $2;
		$$ = $1;
	      }
	  }
	;

menuitem:
	  MENUITEM res_unicode_string_concat cnumexpr menuitem_flags
	  {
	    $$ = define_menuitem ($2, $3, $4, 0, 0, NULL);
	  }
	| MENUITEM SEPARATOR
	  {
	    $$ = define_menuitem (NULL, 0, 0, 0, 0, NULL);
	  }
	| POPUP res_unicode_string_concat menuitem_flags BEG menuitems END
	  {
	    $$ = define_menuitem ($2, 0, $3, 0, 0, $5);
	  }
	;

menuitem_flags:
	  /* empty */
	  {
	    $$ = 0;
	  }
	| menuitem_flags ',' menuitem_flag
	  {
	    $$ = $1 | $3;
	  }
	| menuitem_flags menuitem_flag
	  {
	    $$ = $1 | $2;
	  }
	;

menuitem_flag:
	  CHECKED
	  {
	    $$ = MENUITEM_CHECKED;
	  }
	| GRAYED
	  {
	    $$ = MENUITEM_GRAYED;
	  }
	| HELP
	  {
	    $$ = MENUITEM_HELP;
	  }
	| INACTIVE
	  {
	    $$ = MENUITEM_INACTIVE;
	  }
	| MENUBARBREAK
	  {
	    $$ = MENUITEM_MENUBARBREAK;
	  }
	| MENUBREAK
	  {
	    $$ = MENUITEM_MENUBREAK;
	  }
	;

/* Menuex resources.  */

menuex:
	  id MENUEX suboptions BEG menuexitems END
	  {
	    define_menu ($1, &$3, $5);
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
	  }
	;

menuexitems:
	  /* empty */
	  {
	    $$ = NULL;
	  }
	| menuexitems menuexitem
	  {
	    if ($1 == NULL)
	      $$ = $2;
	    else
	      {
		rc_menuitem **pp;

		for (pp = &$1->next; *pp != NULL; pp = &(*pp)->next)
		  ;
		*pp = $2;
		$$ = $1;
	      }
	  }
	;

menuexitem:
	  MENUITEM res_unicode_string_concat
	  {
	    $$ = define_menuitem ($2, 0, 0, 0, 0, NULL);
	  }
	| MENUITEM res_unicode_string_concat cnumexpr
	  {
	    $$ = define_menuitem ($2, $3, 0, 0, 0, NULL);
	  }
	| MENUITEM res_unicode_string_concat cnumexpr cnumexpr optcnumexpr
	  {
	    $$ = define_menuitem ($2, $3, $4, $5, 0, NULL);
	  }
 	| MENUITEM SEPARATOR
 	  {
 	    $$ = define_menuitem (NULL, 0, 0, 0, 0, NULL);
 	  }
	| POPUP res_unicode_string_concat BEG menuexitems END
	  {
	    $$ = define_menuitem ($2, 0, 0, 0, 0, $4);
	  }
	| POPUP res_unicode_string_concat cnumexpr BEG menuexitems END
	  {
	    $$ = define_menuitem ($2, $3, 0, 0, 0, $5);
	  }
	| POPUP res_unicode_string_concat cnumexpr cnumexpr BEG menuexitems END
	  {
	    $$ = define_menuitem ($2, $3, $4, 0, 0, $6);
	  }
	| POPUP res_unicode_string_concat cnumexpr cnumexpr cnumexpr optcnumexpr
	    BEG menuexitems END
	  {
	    $$ = define_menuitem ($2, $3, $4, $5, $6, $8);
	  }
	;

/* Messagetable resources.  */

messagetable:
	  id MESSAGETABLE memflags_move file_name
	  {
	    define_messagetable ($1, &$3, $4);
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
	  }
	;

/* We use a different lexing algorithm, because rcdata strings may
   contain embedded null bytes, and we need to know the length to use.  */

optrcdata_data:
	  {
	    rcparse_rcdata ();
	  }
	  optrcdata_data_int
	  {
	    rcparse_normal ();
	    $$ = $2;
	  }
	;

optrcdata_data_int:
	  /* empty */
	  {
	    $$.first = NULL;
	    $$.last = NULL;
	  }
	| rcdata_data
	  {
	    $$ = $1;
	  }
	;

rcdata_data:
	  sizedstring
	  {
	    rc_rcdata_item *ri;

	    ri = define_rcdata_string ($1.s, $1.length);
	    $$.first = ri;
	    $$.last = ri;
	  }
	| sizedunistring
	  {
	    rc_rcdata_item *ri;

	    ri = define_rcdata_unistring ($1.s, $1.length);
	    $$.first = ri;
	    $$.last = ri;
	  }
	| sizednumexpr
	  {
	    rc_rcdata_item *ri;

	    ri = define_rcdata_number ($1.val, $1.dword);
	    $$.first = ri;
	    $$.last = ri;
	  }
	| rcdata_data ',' sizedstring
	  {
	    rc_rcdata_item *ri;

	    ri = define_rcdata_string ($3.s, $3.length);
	    $$.first = $1.first;
	    $1.last->next = ri;
	    $$.last = ri;
	  }
	| rcdata_data ',' sizedunistring
	  {
	    rc_rcdata_item *ri;

	    ri = define_rcdata_unistring ($3.s, $3.length);
	    $$.first = $1.first;
	    $1.last->next = ri;
	    $$.last = ri;
	  }
	| rcdata_data ',' sizednumexpr
	  {
	    rc_rcdata_item *ri;

	    ri = define_rcdata_number ($3.val, $3.dword);
	    $$.first = $1.first;
	    $1.last->next = ri;
	    $$.last = ri;
	  }
	| rcdata_data ','
	  {
	    $$=$1;
	  }
	;

/* Stringtable resources.  */

stringtable:
	  STRINGTABLE suboptions BEG 
	    { sub_res_info = $2; rcparse_rcdata (); }
	    string_data END { rcparse_normal (); }
	;

string_data:
	  /* empty */
	| string_data numexpr res_unicode_sizedstring_concat
	  {
	    define_stringtable (&sub_res_info, $2, $3.s, $3.length);
	    rcparse_discard_strings ();
	  }
	| string_data numexpr ',' res_unicode_sizedstring_concat
	  {
	    define_stringtable (&sub_res_info, $2, $4.s, $4.length);
	    rcparse_discard_strings ();
	  }
	| string_data error
	  {
	    rcparse_warning (_("invalid stringtable resource."));
	    abort ();
	  }
	;

rcdata_id:
	id
	  {
	    $$=$1;
	  }
      | HTML
	{
	  $$.named = 0;
	  $$.u.id = 23;
	}
      | RCDATA
        {
          $$.named = 0;
          $$.u.id = RT_RCDATA;
        }
      | MANIFEST
        {
          $$.named = 0;
          $$.u.id = RT_MANIFEST;
        }
      | PLUGPLAY
        {
          $$.named = 0;
          $$.u.id = RT_PLUGPLAY;
        }
      | VXD
        {
          $$.named = 0;
          $$.u.id = RT_VXD;
        }
      | DLGINCLUDE
        {
          $$.named = 0;
          $$.u.id = RT_DLGINCLUDE;
        }
      | DLGINIT
        {
          $$.named = 0;
          $$.u.id = RT_DLGINIT;
        }
      | ANICURSOR
        {
          $$.named = 0;
          $$.u.id = RT_ANICURSOR;
        }
      | ANIICON
        {
          $$.named = 0;
          $$.u.id = RT_ANIICON;
        }
      ;

/* User defined resources.  We accept general suboptions in the
   file_name case to keep the parser happy.  */

user:
	  id rcdata_id suboptions BEG optrcdata_data END
	  {
	    define_user_data ($1, $2, &$3, $5.first);
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
	  }
	| id rcdata_id suboptions file_name
	  {
	    define_user_file ($1, $2, &$3, $4);
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
	  }
	;

toolbar:
	id TOOLBAR suboptions numexpr cnumexpr BEG toolbar_data END
	{
	  define_toolbar ($1, &$3, $4, $5, $7);
	}
	;

toolbar_data: /* empty */ { $$= NULL; }
	| toolbar_data BUTTON id
	{
	  rc_toolbar_item *c,*n;
	  c = $1;
	  n= (rc_toolbar_item *)
	      res_alloc (sizeof (rc_toolbar_item));
	  if (c != NULL)
	    while (c->next != NULL)
	      c = c->next;
	  n->prev = c;
	  n->next = NULL;
	  if (c != NULL)
	    c->next = n;
	  n->id = $3;
	  if ($1 == NULL)
	    $$ = n;
	  else
	    $$ = $1;
	}
	| toolbar_data SEPARATOR
	{
	  rc_toolbar_item *c,*n;
	  c = $1;
	  n= (rc_toolbar_item *)
	      res_alloc (sizeof (rc_toolbar_item));
	  if (c != NULL)
	    while (c->next != NULL)
	      c = c->next;
	  n->prev = c;
	  n->next = NULL;
	  if (c != NULL)
	    c->next = n;
	  n->id.named = 0;
	  n->id.u.id = 0;
	  if ($1 == NULL)
	    $$ = n;
	  else
	    $$ = $1;
	}
	;

/* Versioninfo resources.  */

versioninfo:
	  id VERSIONINFO fixedverinfo BEG verblocks END
	  {
	    define_versioninfo ($1, language, $3, $5);
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
	  }
	;

fixedverinfo:
	  /* empty */
	  {
	    $$ = ((rc_fixed_versioninfo *)
		  res_alloc (sizeof (rc_fixed_versioninfo)));
	    memset ($$, 0, sizeof (rc_fixed_versioninfo));
	  }
	| fixedverinfo FILEVERSION numexpr optcnumexpr optcnumexpr
	  optcnumexpr
	  {
	    $1->file_version_ms = ($3 << 16) | $4;
	    $1->file_version_ls = ($5 << 16) | $6;
	    $$ = $1;
	  }
	| fixedverinfo PRODUCTVERSION numexpr optcnumexpr optcnumexpr
	  optcnumexpr
	  {
	    $1->product_version_ms = ($3 << 16) | $4;
	    $1->product_version_ls = ($5 << 16) | $6;
	    $$ = $1;
	  }
	| fixedverinfo FILEFLAGSMASK numexpr
	  {
	    $1->file_flags_mask = $3;
	    $$ = $1;
	  }
	| fixedverinfo FILEFLAGS numexpr
	  {
	    $1->file_flags = $3;
	    $$ = $1;
	  }
	| fixedverinfo FILEOS numexpr
	  {
	    $1->file_os = $3;
	    $$ = $1;
	  }
	| fixedverinfo FILETYPE numexpr
	  {
	    $1->file_type = $3;
	    $$ = $1;
	  }
	| fixedverinfo FILESUBTYPE numexpr
	  {
	    $1->file_subtype = $3;
	    $$ = $1;
	  }
	;

/* To handle verblocks successfully, the lexer handles BLOCK
   specially.  A BLOCK "StringFileInfo" is returned as
   BLOCKSTRINGFILEINFO.  A BLOCK "VarFileInfo" is returned as
   BLOCKVARFILEINFO.  A BLOCK with some other string returns BLOCK
   with the string as the value.  */

verblocks:
	  /* empty */
	  {
	    $$ = NULL;
	  }
	| verblocks BLOCKSTRINGFILEINFO BEG verstringtables END
	  {
	    $$ = append_ver_stringfileinfo ($1, $4);
	  }
	| verblocks BLOCKVARFILEINFO BEG VALUE res_unicode_string_concat vertrans END
	  {
	    $$ = append_ver_varfileinfo ($1, $5, $6);
	  }
	;

verstringtables:
      /* empty */
	  {
	    $$ = NULL;
	  }
	| verstringtables BLOCK BEG vervals END
	  {
	    $$ = append_ver_stringtable ($1, $2, $4);
	  }
	;

vervals:
	  /* empty */
	  {
	    $$ = NULL;
	  }
	| vervals VALUE res_unicode_string_concat ',' res_unicode_string_concat
	  {
	    $$ = append_verval ($1, $3, $5);
	  }
	;

vertrans:
	  /* empty */
	  {
	    $$ = NULL;
	  }
	| vertrans cnumexpr cnumexpr
	  {
	    $$ = append_vertrans ($1, $2, $3);
	  }
	;

/* A resource ID.  */

id:
	  posnumexpr
	  {
	    $$.named = 0;
	    $$.u.id = $1;
	  }
	| resname
	  {
	    res_unistring_to_id (&$$, $1);
	  }
	;

/* A resource reference.  */

resname:
	  res_unicode_string
	  {
	    $$ = $1;
	  }
	| STRING
	  {
	    unichar *h = NULL;
	    unicode_from_ascii ((rc_uint_type *) NULL, &h, $1);
	    $$ = h;
	  }
	;


resref:
	  posnumexpr ','
	  {
	    $$.named = 0;
	    $$.u.id = $1;
	  }
	| resname
	  {
	    res_unistring_to_id (&$$, $1);
	  }
	| resname ','
	  {
	    res_unistring_to_id (&$$, $1);
	  }
	;

/* Generic suboptions.  These may appear before the BEGIN in any
   multiline statement.  */

suboptions:
	  /* empty */
	  {
	    memset (&$$, 0, sizeof (rc_res_res_info));
	    $$.language = language;
	    /* FIXME: Is this the right default?  */
	    $$.memflags = MEMFLAG_MOVEABLE | MEMFLAG_PURE | MEMFLAG_DISCARDABLE;
	  }
	| suboptions memflag
	  {
	    $$ = $1;
	    $$.memflags |= $2.on;
	    $$.memflags &=~ $2.off;
	  }
	| suboptions CHARACTERISTICS numexpr
	  {
	    $$ = $1;
	    $$.characteristics = $3;
	  }
	| suboptions LANGUAGE numexpr cnumexpr
	  {
	    $$ = $1;
	    $$.language = $3 | ($4 << SUBLANG_SHIFT);
	  }
	| suboptions VERSIONK numexpr
	  {
	    $$ = $1;
	    $$.version = $3;
	  }
	;

/* Memory flags which default to MOVEABLE and DISCARDABLE.  */

memflags_move_discard:
	  /* empty */
	  {
	    memset (&$$, 0, sizeof (rc_res_res_info));
	    $$.language = language;
	    $$.memflags = MEMFLAG_MOVEABLE | MEMFLAG_DISCARDABLE;
	  }
	| memflags_move_discard memflag
	  {
	    $$ = $1;
	    $$.memflags |= $2.on;
	    $$.memflags &=~ $2.off;
	  }
	;

/* Memory flags which default to MOVEABLE.  */

memflags_move:
	  /* empty */
	  {
	    memset (&$$, 0, sizeof (rc_res_res_info));
	    $$.language = language;
	    $$.memflags = MEMFLAG_MOVEABLE | MEMFLAG_PURE | MEMFLAG_DISCARDABLE;
	  }
	| memflags_move memflag
	  {
	    $$ = $1;
	    $$.memflags |= $2.on;
	    $$.memflags &=~ $2.off;
	  }
	;

/* Memory flags.  This returns a struct with two integers, because we
   sometimes want to set bits and we sometimes want to clear them.  */

memflag:
	  MOVEABLE
	  {
	    $$.on = MEMFLAG_MOVEABLE;
	    $$.off = 0;
	  }
	| FIXED
	  {
	    $$.on = 0;
	    $$.off = MEMFLAG_MOVEABLE;
	  }
	| PURE
	  {
	    $$.on = MEMFLAG_PURE;
	    $$.off = 0;
	  }
	| IMPURE
	  {
	    $$.on = 0;
	    $$.off = MEMFLAG_PURE;
	  }
	| PRELOAD
	  {
	    $$.on = MEMFLAG_PRELOAD;
	    $$.off = 0;
	  }
	| LOADONCALL
	  {
	    $$.on = 0;
	    $$.off = MEMFLAG_PRELOAD;
	  }
	| DISCARDABLE
	  {
	    $$.on = MEMFLAG_DISCARDABLE;
	    $$.off = 0;
	  }
	;

/* A file name.  */

file_name:
	  QUOTEDSTRING
	  {
	    $$ = $1;
	  }
	| STRING
	  {
	    $$ = $1;
	  }
	;

/* Concat string */
res_unicode_string_concat:
	  res_unicode_string
	  {
	    $$ = $1;
	  }
	|
	  res_unicode_string_concat res_unicode_string
	  {
	    rc_uint_type l1 = unichar_len ($1);
	    rc_uint_type l2 = unichar_len ($2);
	    unichar *h = (unichar *) res_alloc ((l1 + l2 + 1) * sizeof (unichar));
	    if (l1 != 0)
	      memcpy (h, $1, l1 * sizeof (unichar));
	    if (l2 != 0)
	      memcpy (h + l1, $2, l2  * sizeof (unichar));
	    h[l1 + l2] = 0;
	    $$ = h;
	  }
	;

res_unicode_string:
	  QUOTEDUNISTRING
	  {
	    $$ = unichar_dup ($1);
	  }
	| QUOTEDSTRING
	  {
	    unichar *h = NULL;
	    unicode_from_ascii ((rc_uint_type *) NULL, &h, $1);
	    $$ = h;
	  }
	;

res_unicode_sizedstring:
	  sizedunistring
	  {
	    $$ = $1;
	  }
	| sizedstring
	  {
	    unichar *h = NULL;
	    rc_uint_type l = 0;
	    unicode_from_ascii_len (&l, &h, $1.s, $1.length);
	    $$.s = h;
	    $$.length = l;
	  }
	;

/* Concat string */
res_unicode_sizedstring_concat:
	  res_unicode_sizedstring
	  {
	    $$ = $1;
	  }
	|
	  res_unicode_sizedstring_concat res_unicode_sizedstring
	  {
	    rc_uint_type l1 = $1.length;
	    rc_uint_type l2 = $2.length;
	    unichar *h = (unichar *) res_alloc ((l1 + l2 + 1) * sizeof (unichar));
	    if (l1 != 0)
	      memcpy (h, $1.s, l1 * sizeof (unichar));
	    if (l2 != 0)
	      memcpy (h + l1, $2.s, l2  * sizeof (unichar));
	    h[l1 + l2] = 0;
	    $$.length = l1 + l2;
	    $$.s = h;
	  }
	;

sizedstring:
	  SIZEDSTRING
	  {
	    $$ = $1;
	  }
	| sizedstring SIZEDSTRING
	  {
	    rc_uint_type l = $1.length + $2.length;
	    char *h = (char *) res_alloc (l);
	    memcpy (h, $1.s, $1.length);
	    memcpy (h + $1.length, $2.s, $2.length);
	    $$.s = h;
	    $$.length = l;
	  }
	;

sizedunistring:
	  SIZEDUNISTRING
	  {
	    $$ = $1;
	  }
	| sizedunistring SIZEDUNISTRING
	  {
	    rc_uint_type l = $1.length + $2.length;
	    unichar *h = (unichar *) res_alloc (l * sizeof (unichar));
	    memcpy (h, $1.s, $1.length * sizeof (unichar));
	    memcpy (h + $1.length, $2.s, $2.length  * sizeof (unichar));
	    $$.s = h;
	    $$.length = l;
	  }
	;

/* A style expression.  This changes the static variable STYLE.  We do
   it this way because rc appears to permit a style to be set to
   something like
       WS_GROUP | NOT WS_TABSTOP
   to mean that a default of WS_TABSTOP should be removed.  Anything
   which wants to accept a style must first set STYLE to the default
   value.  The styleexpr nonterminal will change STYLE as specified by
   the user.  Note that we do not accept arbitrary expressions here,
   just numbers separated by '|'.  */

styleexpr:
	  parennumber
	  {
	    style |= $1;
	  }
	| NOT parennumber
	  {
	    style &=~ $2;
	  }
	| styleexpr '|' parennumber
	  {
	    style |= $3;
	  }
	| styleexpr '|' NOT parennumber
	  {
	    style &=~ $4;
	  }
	;

parennumber:
	  NUMBER
	  {
	    $$ = $1.val;
	  }
	| '(' numexpr ')'
	  {
	    $$ = $2;
	  }
	;

/* An optional expression with a leading comma.  */

optcnumexpr:
	  /* empty */
	  {
	    $$ = 0;
	  }
	| cnumexpr
	  {
	    $$ = $1;
	  }
	;

/* An expression with a leading comma.  */

cnumexpr:
	  ',' numexpr
	  {
	    $$ = $2;
	  }
	;

/* A possibly negated numeric expression.  */

numexpr:
	  sizednumexpr
	  {
	    $$ = $1.val;
	  }
	;

/* A possibly negated expression with a size.  */

sizednumexpr:
	  NUMBER
	  {
	    $$ = $1;
	  }
	| '(' sizednumexpr ')'
	  {
	    $$ = $2;
	  }
	| '~' sizednumexpr %prec '~'
	  {
	    $$.val = ~ $2.val;
	    $$.dword = $2.dword;
	  }
	| '-' sizednumexpr %prec NEG
	  {
	    $$.val = - $2.val;
	    $$.dword = $2.dword;
	  }
	| sizednumexpr '*' sizednumexpr
	  {
	    $$.val = $1.val * $3.val;
	    $$.dword = $1.dword || $3.dword;
	  }
	| sizednumexpr '/' sizednumexpr
	  {
	    $$.val = $1.val / $3.val;
	    $$.dword = $1.dword || $3.dword;
	  }
	| sizednumexpr '%' sizednumexpr
	  {
	    $$.val = $1.val % $3.val;
	    $$.dword = $1.dword || $3.dword;
	  }
	| sizednumexpr '+' sizednumexpr
	  {
	    $$.val = $1.val + $3.val;
	    $$.dword = $1.dword || $3.dword;
	  }
	| sizednumexpr '-' sizednumexpr
	  {
	    $$.val = $1.val - $3.val;
	    $$.dword = $1.dword || $3.dword;
	  }
	| sizednumexpr '&' sizednumexpr
	  {
	    $$.val = $1.val & $3.val;
	    $$.dword = $1.dword || $3.dword;
	  }
	| sizednumexpr '^' sizednumexpr
	  {
	    $$.val = $1.val ^ $3.val;
	    $$.dword = $1.dword || $3.dword;
	  }
	| sizednumexpr '|' sizednumexpr
	  {
	    $$.val = $1.val | $3.val;
	    $$.dword = $1.dword || $3.dword;
	  }
	;

/* An expression with a leading comma which does not use unary
   negation.  */

cposnumexpr:
	  ',' posnumexpr
	  {
	    $$ = $2;
	  }
	;

/* An expression which does not use unary negation.  */

posnumexpr:
	  sizedposnumexpr
	  {
	    $$ = $1.val;
	  }
	;

/* An expression which does not use unary negation.  We separate unary
   negation to avoid parsing conflicts when two numeric expressions
   appear consecutively.  */

sizedposnumexpr:
	  NUMBER
	  {
	    $$ = $1;
	  }
	| '(' sizednumexpr ')'
	  {
	    $$ = $2;
	  }
	| '~' sizednumexpr %prec '~'
	  {
	    $$.val = ~ $2.val;
	    $$.dword = $2.dword;
	  }
	| sizedposnumexpr '*' sizednumexpr
	  {
	    $$.val = $1.val * $3.val;
	    $$.dword = $1.dword || $3.dword;
	  }
	| sizedposnumexpr '/' sizednumexpr
	  {
	    $$.val = $1.val / $3.val;
	    $$.dword = $1.dword || $3.dword;
	  }
	| sizedposnumexpr '%' sizednumexpr
	  {
	    $$.val = $1.val % $3.val;
	    $$.dword = $1.dword || $3.dword;
	  }
	| sizedposnumexpr '+' sizednumexpr
	  {
	    $$.val = $1.val + $3.val;
	    $$.dword = $1.dword || $3.dword;
	  }
	| sizedposnumexpr '-' sizednumexpr
	  {
	    $$.val = $1.val - $3.val;
	    $$.dword = $1.dword || $3.dword;
	  }
	| sizedposnumexpr '&' sizednumexpr
	  {
	    $$.val = $1.val & $3.val;
	    $$.dword = $1.dword || $3.dword;
	  }
	| sizedposnumexpr '^' sizednumexpr
	  {
	    $$.val = $1.val ^ $3.val;
	    $$.dword = $1.dword || $3.dword;
	  }
	| sizedposnumexpr '|' sizednumexpr
	  {
	    $$.val = $1.val | $3.val;
	    $$.dword = $1.dword || $3.dword;
	  }
	;

%%

/* Set the language from the command line.  */

void
rcparse_set_language (int lang)
{
  language = lang;
}
@


1.32
log
@2011-10-25  Kai Tietz  <ktietz@@redhat.com>

	* winduni.h (unicode_from_ascii_len): New prototype.
	* winduni.c (unicode_from_ascii_len): New function.
	* windres.h (define_stringtable): Add additional length argument.
	* windres.c (define_stringtable): Add length argument for string.
	* rcparse.y (res_unicode_sizedstring): New rule.
	(res_unicode_sizedstring_concat): Likewise.
	(string_data): Adjust rule.

2011-10-25  Kai Tietz  <ktietz@@redhat.com>

	* binutils-all/windres/strtab4.rc: New test.
	* binutils-all/windres/strtab4.rsd: Likewise.
@
text
@d1426 2
a1427 1
	| fixedverinfo FILEVERSION numexpr cnumexpr cnumexpr cnumexpr
d1433 2
a1434 1
	| fixedverinfo PRODUCTVERSION numexpr cnumexpr cnumexpr cnumexpr
@


1.31
log
@	PR binutils/13051
	Fix a syntax error bug when compiling rc files with the VERSIONINFO resource
	containing more than one language block inside a single StringFileInfo block.

	* windint.h (rc_ver_stringtable): New structure definition.
	(rc_ver_info): Use it.
	* rcparse.y (verstringtable): New variable.
	(verstringtables): New type.
	(verstringtables:): New rule declaration.
	(verblocks:): Use it.
	* resrc.c (append_ver_stringtable): New function.
	(append_ver_stringfileinfo): Update to use stringtables.
	* windres.h (append_ver_stringfileinfo): Update declaration.
	(append_ver_stringtable): New declaration.
	* resrc.c (write_rc_versioninfo): Update to support multiple blocks.
	* resbin.c (bin_to_res_version): Likewise.
	(res_to_bin_versioninfo): Likewise.

	* binutils-all\windres\version.rsd: Regenerate.
	* binutils-all\windres\version_cat.rsd: Regenerate.
	* binutils-all\windres\version_mlang.rc: Add new test.
	* binutils-all\windres\version_mlang.rsd: Likewise.
@
text
@d167 1
a167 1
%type <suni> sizedunistring
d1263 2
a1264 2
	    { sub_res_info = $2; }
	    string_data END
d1269 1
a1269 1
	| string_data numexpr res_unicode_string_concat
d1271 1
a1271 1
	    define_stringtable (&sub_res_info, $2, $3);
d1274 1
a1274 1
	| string_data numexpr ',' res_unicode_string_concat
d1276 1
a1276 1
	    define_stringtable (&sub_res_info, $2, $4);
d1721 37
@


1.30
log
@update copyright dates
@
text
@d2 2
a3 2
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2007, 2008
   Free Software Foundation, Inc.
d82 1
d154 1
d1476 1
a1476 1
	| verblocks BLOCKSTRINGFILEINFO BEG BLOCK BEG vervals END END
d1478 1
a1478 1
	    $$ = append_ver_stringfileinfo ($1, $4, $6);
d1486 11
@


1.29
log
@2008-12-23  Kai Tietz  <kai.tietz@@onevision.com>

	* rcparse.y (rcdata_data): Allow empty comma elements.
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2007
@


1.28
log
@	* rcparse.y (resid): Allow control text to span multiple lines.
@
text
@d1251 4
@


1.27
log
@PR/5020: STRINGTABLE doesn't work in 2.18 windres.
@
text
@d929 1
a929 1
	| res_unicode_string
@


1.26
log
@Change sources over to using GPLv3
@
text
@a1265 2
	    if (yychar != YYEMPTY)
	      YYERROR;
a1270 2
	    if (yychar != YYEMPTY)
	      YYERROR;
d1273 5
@


1.25
log
@* rcparse.y: Join strings for elements having no side-effects in "rc"-grammar.
* testsuite/binutils-all/windres/version_cat.rc: New.
* testsuite/binutils-all/windres/version_cat.rsd: New.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d24 1
@


1.24
log
@Updated windres tool
@
text
@d162 1
a162 1
%type <uni> res_unicode_string resname
d445 1
a445 1
	| styles CAPTION res_unicode_string
d464 1
a464 1
	| styles CLASS res_unicode_string
d468 1
a468 1
	| styles FONT numexpr ',' res_unicode_string
d481 1
a481 1
	| styles FONT numexpr ',' res_unicode_string cnumexpr
d496 1
a496 1
	| styles FONT numexpr ',' res_unicode_string cnumexpr cnumexpr
d511 1
a511 1
	| styles FONT numexpr ',' res_unicode_string cnumexpr cnumexpr cnumexpr
d1035 1
a1035 1
	  MENUITEM res_unicode_string cnumexpr menuitem_flags
d1043 1
a1043 1
	| POPUP res_unicode_string menuitem_flags BEG menuitems END
d1125 1
a1125 1
	  MENUITEM res_unicode_string
d1129 1
a1129 1
	| MENUITEM res_unicode_string cnumexpr
d1133 1
a1133 1
	| MENUITEM res_unicode_string cnumexpr cnumexpr optcnumexpr
d1141 1
a1141 1
	| POPUP res_unicode_string BEG menuexitems END
d1145 1
a1145 1
	| POPUP res_unicode_string cnumexpr BEG menuexitems END
d1149 1
a1149 1
	| POPUP res_unicode_string cnumexpr cnumexpr BEG menuexitems END
d1153 1
a1153 1
	| POPUP res_unicode_string cnumexpr cnumexpr cnumexpr optcnumexpr
d1262 1
a1262 1
	| string_data numexpr res_unicode_string
d1269 1
a1269 1
	| string_data numexpr ',' res_unicode_string
d1472 1
a1472 1
	| verblocks BLOCKVARFILEINFO BEG VALUE res_unicode_string vertrans END
d1483 1
a1483 1
	| vervals VALUE res_unicode_string ',' res_unicode_string
a1507 1

d1668 21
@


1.23
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d5 1
d29 1
d40 1
a40 1
static struct res_res_info sub_res_info;
d45 1
a45 1
static struct dialog dialog;
d55 4
a58 4
static unsigned long base_style;
static unsigned long default_style;
static unsigned long class;
static struct res_id res_text_field;
d63 1
a63 1
static const struct res_id res_null_text = { 1, {{0, &null_unichar}}};
d69 4
a72 4
  struct accelerator acc;
  struct accelerator *pacc;
  struct dialog_control *dialog_control;
  struct menuitem *menuitem;
d75 2
a76 2
    struct rcdata_item *first;
    struct rcdata_item *last;
d78 8
a85 8
  struct rcdata_item *rcdata_item;
  struct stringtable_data *stringtable;
  struct fixed_versioninfo *fixver;
  struct ver_info *verinfo;
  struct ver_stringinfo *verstring;
  struct ver_varinfo *vervar;
  struct res_id id;
  struct res_res_info res_info;
d88 2
a89 2
    unsigned short on;
    unsigned short off;
d93 1
a93 1
    unsigned long val;
d97 2
a98 2
  unsigned long il;
  unsigned short is;
d102 1
a102 1
    unsigned long length;
d105 6
d124 1
d137 1
d140 1
d154 1
d157 1
a157 1
%type <id> id optresidc resref
d161 4
a164 1
%type <s> file_name resname
a187 1
	| input rcdata
d189 1
d214 1
a214 1
	    struct accelerator *a;
d216 1
a216 1
	    a = (struct accelerator *) res_alloc (sizeof *a);
d222 1
a222 1
		struct accelerator **pp;
d264 1
a264 2
		ch = *s;
		ch = TOUPPER (ch);
d388 3
a390 3
	      dialog.ex = ((struct dialog_ex *)
			   res_alloc (sizeof (struct dialog_ex)));
	      memset (dialog.ex, 0, sizeof (struct dialog_ex));
d415 3
a417 3
	      dialog.ex = ((struct dialog_ex *)
			   res_alloc (sizeof (struct dialog_ex)));
	      memset (dialog.ex, 0, sizeof (struct dialog_ex));
d445 1
a445 1
	| styles CAPTION QUOTEDSTRING
d449 1
a449 1
	    unicode_from_ascii ((int *) NULL, &dialog.caption, $3);
d464 1
a464 1
	| styles CLASS QUOTEDSTRING
d466 1
a466 1
	    res_string_to_id (& dialog.class, $3);
d468 1
a468 1
	| styles FONT numexpr ',' QUOTEDSTRING
d473 1
a473 1
	    unicode_from_ascii ((int *) NULL, &dialog.font, $5);
d481 1
a481 1
	| styles FONT numexpr ',' QUOTEDSTRING cnumexpr
d486 1
a486 1
	    unicode_from_ascii ((int *) NULL, &dialog.font, $5);
d496 1
a496 1
	| styles FONT numexpr ',' QUOTEDSTRING cnumexpr cnumexpr
d501 1
a501 1
	    unicode_from_ascii ((int *) NULL, &dialog.font, $5);
d511 1
a511 1
	| styles FONT numexpr ',' QUOTEDSTRING cnumexpr cnumexpr cnumexpr
d516 1
a516 1
	    unicode_from_ascii ((int *) NULL, &dialog.font, $5);
d548 1
a548 1
	    struct dialog_control **pp;
d561 2
a562 1
	      class = CTL_BUTTON;
d573 2
a574 1
	      class = CTL_BUTTON;
d585 2
a586 1
	      class = CTL_BUTTON;
d597 2
a598 1
	      class = CTL_EDIT;
d612 2
a613 1
	      class = CTL_BUTTON;
d626 2
a627 1
	      class = CTL_COMBOBOX;
d634 1
a634 1
	| CONTROL optresidc numexpr cnumexpr control_styleexpr cnumexpr
d645 1
a645 1
	| CONTROL optresidc numexpr cnumexpr control_styleexpr cnumexpr
a653 24
	| CONTROL optresidc numexpr ',' QUOTEDSTRING control_styleexpr
	    cnumexpr cnumexpr cnumexpr cnumexpr optcnumexpr opt_control_data
	  {
	    $$ = define_control ($2, $3, $7, $8, $9, $10, 0, style, $11);
	    if ($12 != NULL)
	      {
		if (dialog.ex == NULL)
		  rcparse_warning ("control data requires DIALOGEX");
		$$->data = $12;
	      }
	    $$->class.named = 1;
  	    unicode_from_ascii (&$$->class.u.n.length, &$$->class.u.n.name, $5);
	  }
	| CONTROL optresidc numexpr ',' QUOTEDSTRING control_styleexpr
	    cnumexpr cnumexpr cnumexpr cnumexpr cnumexpr cnumexpr opt_control_data
	  {
	    $$ = define_control ($2, $3, $7, $8, $9, $10, 0, style, $11);
	    if (dialog.ex == NULL)
	      rcparse_warning ("help ID requires DIALOGEX");
	    $$->help = $12;
	    $$->data = $13;
	    $$->class.named = 1;
  	    unicode_from_ascii (&$$->class.u.n.length, &$$->class.u.n.name, $5);
	  }
d658 2
a659 1
	      class = CTL_STATIC;
d670 2
a671 1
	      class = CTL_BUTTON;
d682 2
a683 1
	      class = CTL_EDIT;
d694 2
a695 1
	      class = CTL_BUTTON;
d706 2
a707 1
	      class = CTL_EDIT;
d744 2
a745 1
	      class = CTL_EDIT;
d759 2
a760 1
	      class = CTL_LISTBOX;
d771 2
a772 1
	      class = CTL_STATIC;
d783 2
a784 1
	      class = CTL_BUTTON;
d794 2
a795 1
	      class = CTL_BUTTON;
d806 2
a807 1
	      class = CTL_BUTTON;
d818 2
a819 1
	      class = CTL_STATIC;
d830 2
a831 1
	      class = CTL_SCROLLBAR;
d842 2
a843 1
	      class = CTL_BUTTON;
d855 4
a858 1
	    $$ = define_control ($2, $3, $5, $7, $9, $11, CTL_BUTTON,
d904 10
d919 5
a923 1
	| posnumexpr ','
d928 1
a928 1
	| QUOTEDSTRING
d930 3
a932 5
	    res_string_to_id (&$$, $1);
	  }
	| QUOTEDSTRING ','
	  {
	    res_string_to_id (&$$, $1);
d1024 1
a1024 1
		struct menuitem **pp;
d1035 1
a1035 1
	  MENUITEM QUOTEDSTRING cnumexpr menuitem_flags
d1043 1
a1043 1
	| POPUP QUOTEDSTRING menuitem_flags BEG menuitems END
d1114 1
a1114 1
		struct menuitem **pp;
d1125 1
a1125 1
	  MENUITEM QUOTEDSTRING
d1129 1
a1129 1
	| MENUITEM QUOTEDSTRING cnumexpr
d1133 1
a1133 1
	| MENUITEM QUOTEDSTRING cnumexpr cnumexpr optcnumexpr
d1141 1
a1141 1
	| POPUP QUOTEDSTRING BEG menuexitems END
d1145 1
a1145 1
	| POPUP QUOTEDSTRING cnumexpr BEG menuexitems END
d1149 1
a1149 1
	| POPUP QUOTEDSTRING cnumexpr cnumexpr BEG menuexitems END
d1153 1
a1153 1
	| POPUP QUOTEDSTRING cnumexpr cnumexpr cnumexpr optcnumexpr
a1171 19
/* Rcdata resources.  */

rcdata:
	  id RCDATA suboptions BEG optrcdata_data END
	  {
	    define_rcdata ($1, &$3, $5.first);
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
	  }
	| id RCDATA suboptions file_name
	  {
	    define_rcdata_file ($1, &$3, $4);
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
	  }
	;

d1199 1
a1199 1
	  SIZEDSTRING
d1201 1
a1201 1
	    struct rcdata_item *ri;
d1207 8
d1217 1
a1217 1
	    struct rcdata_item *ri;
d1223 1
a1223 1
	| rcdata_data ',' SIZEDSTRING
d1225 1
a1225 1
	    struct rcdata_item *ri;
d1232 9
d1243 1
a1243 1
	    struct rcdata_item *ri;
d1262 1
a1262 1
	| string_data numexpr QUOTEDSTRING
d1269 1
a1269 1
	| string_data numexpr ',' QUOTEDSTRING
d1278 52
d1334 1
a1334 1
	  id id suboptions BEG optrcdata_data END
d1341 1
a1341 1
	| id id suboptions file_name
d1350 49
d1414 3
a1416 3
	    $$ = ((struct fixed_versioninfo *)
		  res_alloc (sizeof (struct fixed_versioninfo)));
	    memset ($$, 0, sizeof (struct fixed_versioninfo));
d1472 1
a1472 1
	| verblocks BLOCKVARFILEINFO BEG VALUE QUOTEDSTRING vertrans END
d1483 1
a1483 1
	| vervals VALUE QUOTEDSTRING ',' QUOTEDSTRING
d1508 2
a1509 1
	| STRING
d1511 1
a1511 8
	    char *copy, *s;

	    /* It seems that resource ID's are forced to upper case.  */
	    copy = xstrdup ($1);
	    for (s = copy; *s != '\0'; s++)
	      *s = TOUPPER (*s);
	    res_string_to_id (&$$, copy);
	    free (copy);
d1518 1
a1518 1
	  QUOTEDSTRING
d1522 1
a1522 1
	| QUOTEDSTRING ','
d1524 3
a1526 5
	    $$ = $1;
	  }
	| STRING ','
	  {
	    $$ = $1;
d1539 5
a1543 8
	    char *copy, *s;

	    /* It seems that resource ID's are forced to upper case.  */
	    copy = xstrdup ($1);
	    for (s = copy; *s != '\0'; s++)
	      *s = TOUPPER (*s);
	    res_string_to_id (&$$, copy);
	    free (copy);
d1553 1
a1553 1
	    memset (&$$, 0, sizeof (struct res_res_info));
d1586 1
a1586 1
	    memset (&$$, 0, sizeof (struct res_res_info));
d1603 1
a1603 1
	    memset (&$$, 0, sizeof (struct res_res_info));
d1669 45
@


1.22
log
@Update FSF address
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005
d26 1
a27 1
#include "bucomm.h"
@


1.21
log
@	* deflex.l (YY_NO_UNPUT): Define.
	* rclex.l (YY_NO_UNPUT): Define.
	* rcparse.y (null_unichar): New static var.
	(res_null_text): Use it rather than attempting to init from wchar_t.
	* windres.c: Include assert.h and time.h before getopt.h.
	Include config.h and unistd.h too.
@
text
@d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.20
log
@PR binutils/647
* rcparse.y (RCDATA): Allow a filename to be supplied as the parameter.
  Parse it with define_rcdata_file().
* resrc.c (define_rcdata_file): New function.
* windres.h: Provide a prototype for the new function.

* resrc.c (define_user_file): Fix typo by replacing "font file" with "file".
@
text
@d57 1
d61 1
a61 1
static const struct res_id res_null_text = { 1, {{0, L""}}};
@


1.19
log
@	* addr2line.c: Convert to ISO C90 prototypes, change PTR, remove
	unneeded (void *) casts.
	* ar.c: Likewise.
	* arlex.l: Likewise.
	* arparse.y: Likewise.
	* arsup.c: Likewise.
	* binemul.c: Likewise.
	* binemul.h: Likewise.
	* bucomm.c: Likewise.
	* bucomm.h: Likewise.
	* budbg.h: Likewise.
	* budemang.c: Likewise.
	* budemang.h: Likewise.
	* coffdump.c: Likewise.
	* coffgrok.c: Likewise.
	* cxxfilt.c: Likewise.
	* debug.c: Likewise.
	* debug.h: Likewise.
	* deflex.l: Likewise.
	* dlltool.c: Likewise.
	* dlltool.h: Likewise.
	* dllwrap.c: Likewise.
	* emul_aix.c: Likewise.
	* filemode.c: Likewise.
	* ieee.c: Likewise.
	* nlmconv.c: Likewise.
	* nlmconv.h: Likewise.
	* nlmheader.y: Likewise.
	* nm.c: Likewise.
	* prdbg.c: Likewise.
	* rclex.l: Likewise.
	* rcparse.y: Likewise.
	* rdcoff.c: Likewise.
	* rddbg.c: Likewise.
	* rename.c: Likewise.
	* resbin.c: Likewise.
	* rescoff.c: Likewise.
	* resrc.c: Likewise.
	* size.c: Likewise.
	* srconv.c: Likewise.
	* stabs.c: Likewise.
	* strings.c: Likewise.
	* sysdump.c: Likewise.
	* sysinfo.y: Likewise.
	* syslex.l: Likewise.
	* unwind-ia64.c: Likewise.
	* unwind-ia64.h: Likewise.
	* version.c: Likewise.
	* windres.c: Likewise.
	* windres.h: Likewise.
	* winduni.c: Likewise.
	* wrstabs.c: Likewise.
@
text
@d2 2
a3 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d1156 7
@


1.18
log
@	* rcparse.y (res_text_field): New res_id variable.
	(res_null_text): New static const struct res_id object,
	with empty unicode name field.
	(control): Pop parsing of optresidc up one level. Set
	res_text_field to $2 except for controls which do not accept
	a text field.  Set res_text_field to res_null_text for the
	special cases (viz. COMBOBOX, EDITTEXT, LISTBOX, SCROLLBAR).
	(control_params): Adjust to use res_text_field rather
	than optresidc.
	(COMBOBOX): Add comment about discrepency between documented
	vs. observed default style.
	* resrc.c (define_control): Make first param const.
	* windres.h (define_control): Adjust prototype.

testsuite:

	* binutils-all/windres/checkbox.rc: New file.
	* binutils-all/windres/checkbox.rsd: New file.
	* binutils-all/windres/combobox.rc: New file.
	* binutils-all/windres/combobox.rsd: New file.
	* binutils-all/windres/edittext.rc: New file.
	* binutils-all/windres/edittext.rsd: New file.
	* binutils-all/windres/listbox.rc: New file.
	* binutils-all/windres/listbox.rsd: New file.
	* binutils-all/windres/scrollbar.rc: New file.
	* binutils-all/windres/scrollbar.rsd: New file.
@
text
@d1765 1
a1765 2
rcparse_set_language (lang)
     int lang;
@


1.17
log
@Allow resource IDs to be strings or numbers.
Add a test for this.
@
text
@d55 5
d541 1
a541 1
	  AUTO3STATE
d546 1
d550 1
a550 1
	    $$ = $3;
d552 1
a552 1
	| AUTOCHECKBOX
d557 1
d561 1
a561 1
	    $$ = $3;
d563 1
a563 1
	| AUTORADIOBUTTON
d568 1
d572 1
a572 1
	    $$ = $3;
d574 1
a574 1
	| BEDIT
d579 1
d583 1
a583 1
	    $$ = $3;
d588 1
a588 1
	| CHECKBOX
d593 1
d597 1
a597 1
	    $$ = $3;
d601 2
d606 1
d656 1
a656 1
	| CTEXT
d661 1
d665 1
a665 1
	    $$ = $3;
d667 1
a667 1
	| DEFPUSHBUTTON
d672 1
d676 1
a676 1
	    $$ = $3;
d683 1
d689 1
a689 1
	| GROUPBOX
d694 1
d698 1
a698 1
	    $$ = $3;
d700 1
a700 1
	| HEDIT
d705 1
d709 1
a709 1
	    $$ = $3;
d737 1
a737 1
	| IEDIT
d742 1
d746 1
a746 1
	    $$ = $3;
d756 1
d762 1
a762 1
	| LTEXT
d767 1
d771 1
a771 1
	    $$ = $3;
d773 1
a773 1
	| PUSHBOX
d781 1
a781 1
	    $$ = $3;
d783 1
a783 1
	| PUSHBUTTON
d788 1
d792 1
a792 1
	    $$ = $3;
d794 1
a794 1
	| RADIOBUTTON
d799 1
d803 1
a803 1
	    $$ = $3;
d805 1
a805 1
	| RTEXT
d810 1
d814 1
a814 1
	    $$ = $3;
d821 1
d827 1
a827 1
	| STATE3
d832 1
d836 1
a836 1
	    $$ = $3;
d856 1
a856 2
	  optresidc numexpr cnumexpr cnumexpr cnumexpr cnumexpr
	    opt_control_data
d858 1
a858 1
	    $$ = define_control ($1, $2, $3, $4, $5, $6, class,
d860 1
a860 1
	    if ($7 != NULL)
d864 1
a864 1
		$$->data = $7;
d867 1
a867 1
	| optresidc numexpr cnumexpr cnumexpr cnumexpr cnumexpr
d870 2
a871 2
	    $$ = define_control ($1, $2, $3, $4, $5, $6, class, style, $8);
	    if ($9 != NULL)
d875 1
a875 1
		$$->data = $9;
d878 1
a878 1
	| optresidc numexpr cnumexpr cnumexpr cnumexpr cnumexpr
d881 1
a881 1
	    $$ = define_control ($1, $2, $3, $4, $5, $6, class, style, $8);
d884 2
a885 2
	    $$->help = $9;
	    $$->data = $10;
@


1.16
log
@Don't warn about ALT use with non-VIRTKEY.
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d138 1
a138 1
%type <id> id resref
d142 1
a142 1
%type <s> optstringc file_name resname
d599 1
a599 1
	| CONTROL optstringc numexpr cnumexpr control_styleexpr cnumexpr
d610 1
a610 1
	| CONTROL optstringc numexpr cnumexpr control_styleexpr cnumexpr
d619 1
a619 1
	| CONTROL optstringc numexpr ',' QUOTEDSTRING control_styleexpr
d632 1
a632 1
	| CONTROL optstringc numexpr ',' QUOTEDSTRING control_styleexpr
d812 1
a812 1
	| USERBUTTON QUOTEDSTRING ',' numexpr ',' numexpr ',' numexpr ','
d817 2
a818 2
	    $$ = define_control ($2, $4, $6, $8, $10, $12, CTL_BUTTON,
				 style, $16);
d830 1
a830 1
	  optstringc numexpr cnumexpr cnumexpr cnumexpr cnumexpr
d842 1
a842 1
	| optstringc numexpr cnumexpr cnumexpr cnumexpr cnumexpr
d853 1
a853 1
	| optstringc numexpr cnumexpr cnumexpr cnumexpr cnumexpr
d864 1
a864 1
optstringc:
d867 6
a872 1
	    $$ = NULL;
d876 1
a876 1
	    $$ = $1;
d880 1
a880 1
	    $$ = $1;
@


1.15
log
@	* rcparse.y: Remove newcmd rule.  Move rcparse_discard_strings
	call to rules that need no lookahead.  Check for no lookahead.

	* rclex.l (get_string): Correct "strings" list handling.
	* resrc.c (read_rc_file): Discard strings.
@
text
@d222 1
a222 1
		&& ($$.flags & (ACC_SHIFT | ACC_CONTROL | ACC_ALT)) != 0)
@


1.15.2.1
log
@2002-09-23  Daniel Jacobowitz  <drow@@mvista.com>

	Merge from mainline:
	2002-09-11  Nick Clifton  <nickc@@redhat.com>
	* po/tr.po: Updated Turkish translation.

	2002-08-14  Luke Dunstan  <infidel@@users.sourceforge.net>
	* rcparse.y (acc_entry): Don't warn about ALT use with
	non-VIRTKEY.

	2002-08-09  Nick Clifton  <nickc@@redhat.com>
	* po/sv.po: Updated Swedish translation.

	2002-07-31  Nick Clifton  <nickc@@redhat.com>
	* addr2line.c (process_file): Rename parameter 'filename' to
	'file_name' in order to avoid shadowing global symbol of the
	same name.
	(main): Likewise.
@
text
@d222 1
a222 1
		&& ($$.flags & (ACC_SHIFT | ACC_CONTROL)) != 0)
@


1.14
log
@Define MEMFLAGS_DISCARDABLE by default for dialogs.
Add a test for this.
@
text
@d156 15
a170 22
	| input newcmd accelerator
	| input newcmd bitmap
	| input newcmd cursor
	| input newcmd dialog
	| input newcmd font
	| input newcmd icon
	| input newcmd language
	| input newcmd menu
	| input newcmd menuex
	| input newcmd messagetable
	| input newcmd rcdata
	| input newcmd stringtable
	| input newcmd user
	| input newcmd versioninfo
	| input newcmd IGNORED_TOKEN
	;

newcmd:
	  /* empty */
	  {
	    rcparse_discard_strings ();
	  }
d179 3
d308 3
d320 3
d350 3
d377 3
d405 3
d916 3
d928 3
d950 3
d1040 3
d1109 3
d1121 3
d1203 3
d1210 3
d1223 3
d1230 3
d1242 3
@


1.13
log
@Allow two to five parameter in FONT statement of DIALOGEX resources.
@
text
@d1360 1
a1360 1
	    $$.memflags = MEMFLAG_MOVEABLE | MEMFLAG_PURE;
d1409 1
a1409 1
	    $$.memflags = MEMFLAG_MOVEABLE | MEMFLAG_PURE;
@


1.12
log
@Regernated recently created expected output files using MSVC.
Set MEMFLAG_PURE by default - bug exposed by regenerated files.
@
text
@d442 21
d476 16
@


1.11
log
@Add WS_CAPTION dialog style if CAPTION is specified.
Add testcase.
@
text
@d1323 1
a1323 1
	    $$.memflags = MEMFLAG_MOVEABLE;
d1372 1
a1372 1
	    $$.memflags = MEMFLAG_MOVEABLE;
@


1.10
log
@Don't add default dialog style when explicit style specified.
Print style even if it is 0.
Add testcase.
@
text
@d415 2
@


1.9
log
@Fix typo in BEDIT warning.
@
text
@d343 1
d367 1
d392 1
a421 1
	    { style = dialog.style; }
d437 1
d444 1
@


1.8
log
@Apply patch from Bernd Herd to fix quoted class definitions inside dialogs.
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d522 1
a522 1
	      rcparse_warning (_("IEDIT requires DIALOGEX"));
d576 1
a576 1
  	    unicode_from_ascii(&$$->class.u.n.length, &$$->class.u.n.name, $5);
d587 1
a587 1
  	    unicode_from_ascii(&$$->class.u.n.length, &$$->class.u.n.name, $5);
@


1.7
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d428 4
@


1.7.2.1
log
@Merge from mainline
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d156 22
a177 15
	| input accelerator
	| input bitmap
	| input cursor
	| input dialog
	| input font
	| input icon
	| input language
	| input menu
	| input menuex
	| input messagetable
	| input rcdata
	| input stringtable
	| input user
	| input versioninfo
	| input IGNORED_TOKEN
a185 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a311 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a320 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a342 1
	      style = 0;
a346 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a365 1
	      style = 0;
a369 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a389 1
	      style = 0;
a393 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a411 2
	    dialog.style |= WS_CAPTION;
	    style |= WS_CAPTION;
d419 1
a427 4
	| styles CLASS QUOTEDSTRING
	  {
	    res_string_to_id (& dialog.class, $3);
	  }
a430 1
	    style |= DS_SETFONT;
a432 21
	    if (dialog.ex != NULL)
	      {
		dialog.ex->weight = 0;
		dialog.ex->italic = 0;
		dialog.ex->charset = 1;
	      }
	  }
	| styles FONT numexpr ',' QUOTEDSTRING cnumexpr
	  {
	    dialog.style |= DS_SETFONT;
	    style |= DS_SETFONT;
	    dialog.pointsize = $3;
	    unicode_from_ascii ((int *) NULL, &dialog.font, $5);
	    if (dialog.ex == NULL)
	      rcparse_warning (_("extended FONT requires DIALOGEX"));
	    else
	      {
		dialog.ex->weight = $6;
		dialog.ex->italic = 0;
		dialog.ex->charset = 1;
	      }
a436 16
	    style |= DS_SETFONT;
	    dialog.pointsize = $3;
	    unicode_from_ascii ((int *) NULL, &dialog.font, $5);
	    if (dialog.ex == NULL)
	      rcparse_warning (_("extended FONT requires DIALOGEX"));
	    else
	      {
		dialog.ex->weight = $6;
		dialog.ex->italic = $7;
		dialog.ex->charset = 1;
	      }
	  }
	| styles FONT numexpr ',' QUOTEDSTRING cnumexpr cnumexpr cnumexpr
	  {
	    dialog.style |= DS_SETFONT;
	    style |= DS_SETFONT;
a444 1
		dialog.ex->charset = $8;
d518 1
a518 1
	      rcparse_warning (_("BEDIT requires DIALOGEX"));
d572 1
a572 1
  	    unicode_from_ascii (&$$->class.u.n.length, &$$->class.u.n.name, $5);
d583 1
a583 1
  	    unicode_from_ascii (&$$->class.u.n.length, &$$->class.u.n.name, $5);
a857 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a866 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a885 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a972 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a1038 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a1047 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a1126 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a1130 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a1140 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a1144 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
a1153 3
	    if (yychar != YYEMPTY)
	      YYERROR;
	    rcparse_discard_strings ();
d1313 1
a1313 1
	    $$.memflags = MEMFLAG_MOVEABLE | MEMFLAG_PURE | MEMFLAG_DISCARDABLE;
d1362 1
a1362 1
	    $$.memflags = MEMFLAG_MOVEABLE | MEMFLAG_PURE | MEMFLAG_DISCARDABLE;
@


1.6
log
@* rcparse.y (styles): use SUBLANG_SHIFT instead of 8 (or the more
correct 10).
* resrc.c (write_rc_resource): Likewise.
* windres.h (SUBLANG_SHIFT): Define - as 10.
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
d29 1
a29 2

#include <ctype.h>
d247 1
a247 1
		ch = toupper ((unsigned char) ch);
d1261 1
a1261 2
	      if (islower ((unsigned char) *s))
		*s = toupper ((unsigned char) *s);
d1298 1
a1298 2
	      if (islower ((unsigned char) *s))
	        *s = toupper ((unsigned char) *s);
@


1.5
log
@Fix typos in ChangeLogs and update copyright notices
@
text
@d458 1
a458 1
	    sub_res_info.language = $3 | ($4 << 8);
d877 1
a877 1
	    language = $2 | ($3 << 8);
d1332 1
a1332 1
	    $$.language = $3 | ($4 << 8);
@


1.4
log
@* Make comma after string after icon/control optional.
@
text
@d2 1
a2 1
   Copyright 1997, 1998 Free Software Foundation, Inc.
@


1.4.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
@


1.3
log
@* rcparse.y (control): ICON controls take an id as the first
parameter, not an optional string.  Also, call new convenience
function that takes res_id's.
* resrc.c (define_control): missing text means zero-length string,
not zero ID.
(define_icon_control): New.
* windres.h: declare define_icon_control.
@
text
@d139 1
a139 1
%type <id> id
d143 1
a143 1
%type <s> optstringc file_name
d639 1
a639 1
	| ICON id cnumexpr cnumexpr cnumexpr opt_control_data
d644 1
a644 1
	| ICON id cnumexpr cnumexpr cnumexpr cnumexpr cnumexpr
d650 1
a650 1
	| ICON id cnumexpr cnumexpr cnumexpr cnumexpr cnumexpr
d656 1
a656 1
	| ICON id numexpr cnumexpr cnumexpr cnumexpr cnumexpr
d812 4
d1264 38
@


1.2
log
@	* rclex.l: add code to suppress certain output from cpp, replace
	all returns with MAYBE_RETURN
	(MAYBE_RETURN): new, implement the suppression by returning
	IGNORED_TOKEN as needed.
	(cpp_line): remember which file we're in, mark data from included
	*.h files for suppression.
	* rcparse.y (input): allow IGNORED_TOKEN outside of known constructs
@
text
@d639 12
a650 12
	| ICON optstringc numexpr cnumexpr cnumexpr opt_control_data
	  {
	    $$ = define_control ($2, $3, $4, $5, 0, 0, CTL_STATIC,
				 SS_ICON | WS_CHILD | WS_VISIBLE, 0);
	    if ($6 != NULL)
	      {
		if (dialog.ex == NULL)
		  rcparse_warning (_("control data requires DIALOGEX"));
		$$->data = $6;
	      }
	  }
	| ICON optstringc numexpr cnumexpr cnumexpr cnumexpr cnumexpr
d652 5
a656 11
	  {
    	    $$ = define_control ($2, $3, $4, $5, $6, $7, CTL_STATIC,
				 style, $9);
	    if ($10 != NULL)
	      {
		if (dialog.ex == NULL)
		  rcparse_warning (_("control data requires DIALOGEX"));
		$$->data = $10;
	      }
	  }
	| ICON optstringc numexpr cnumexpr cnumexpr cnumexpr cnumexpr
d658 4
a661 8
	  {
    	    $$ = define_control ($2, $3, $4, $5, $6, $7, CTL_STATIC,
				 style, $9);
	    if (dialog.ex == NULL)
	      rcparse_warning (_("help ID requires DIALOGEX"));
	    $$->help = $10;
	    $$->data = $11;
	  }
@


1.1
log
@Initial revision
@
text
@d125 1
d171 1
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

