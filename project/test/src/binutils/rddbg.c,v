head	1.15;
access;
symbols
	binutils-2_24-branch:1.15.0.10
	binutils-2_24-branchpoint:1.15
	binutils-2_21_1:1.15
	binutils-2_23_2:1.15
	binutils-2_23_1:1.15
	binutils-2_23:1.15
	binutils-2_23-branch:1.15.0.8
	binutils-2_23-branchpoint:1.15
	binutils-2_22_branch:1.15.0.6
	binutils-2_22:1.15
	binutils-2_22-branch:1.15.0.4
	binutils-2_22-branchpoint:1.15
	binutils-2_21:1.15
	binutils-2_21-branch:1.15.0.2
	binutils-2_21-branchpoint:1.15
	binutils-2_20_1:1.14
	binutils-2_20:1.14
	binutils-arc-20081103-branch:1.14.0.10
	binutils-arc-20081103-branchpoint:1.14
	binutils-2_20-branch:1.14.0.8
	binutils-2_20-branchpoint:1.14
	dje-cgen-play1-branch:1.14.0.6
	dje-cgen-play1-branchpoint:1.14
	arc-20081103-branch:1.14.0.4
	arc-20081103-branchpoint:1.14
	binutils-2_19_1:1.14
	binutils-2_19:1.14
	binutils-2_19-branch:1.14.0.2
	binutils-2_19-branchpoint:1.14
	binutils-2_18:1.13
	binutils-2_18-branch:1.13.0.2
	binutils-2_18-branchpoint:1.13
	binutils-csl-coldfire-4_1-32:1.11
	binutils-csl-sourcerygxx-4_1-32:1.11
	binutils-csl-innovasic-fido-3_4_4-33:1.11
	binutils-csl-sourcerygxx-3_4_4-32:1.9
	binutils-csl-coldfire-4_1-30:1.11
	binutils-csl-sourcerygxx-4_1-30:1.11
	binutils-csl-coldfire-4_1-28:1.11
	binutils-csl-sourcerygxx-4_1-29:1.11
	binutils-csl-sourcerygxx-4_1-28:1.11
	binutils-csl-arm-2006q3-27:1.11
	binutils-csl-sourcerygxx-4_1-27:1.11
	binutils-csl-arm-2006q3-26:1.11
	binutils-csl-sourcerygxx-4_1-26:1.11
	binutils-csl-sourcerygxx-4_1-25:1.11
	binutils-csl-sourcerygxx-4_1-24:1.11
	binutils-csl-sourcerygxx-4_1-23:1.11
	binutils-csl-sourcerygxx-4_1-21:1.11
	binutils-csl-arm-2006q3-21:1.11
	binutils-csl-sourcerygxx-4_1-22:1.11
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.11
	binutils-csl-sourcerygxx-4_1-20:1.11
	binutils-csl-arm-2006q3-19:1.11
	binutils-csl-sourcerygxx-4_1-19:1.11
	binutils-csl-sourcerygxx-4_1-18:1.11
	binutils-csl-renesas-4_1-9:1.11
	binutils-csl-sourcerygxx-3_4_4-25:1.9
	binutils-csl-renesas-4_1-8:1.11
	binutils-csl-renesas-4_1-7:1.11
	binutils-csl-renesas-4_1-6:1.11
	binutils-csl-sourcerygxx-4_1-17:1.11
	binutils-csl-sourcerygxx-4_1-14:1.11
	binutils-csl-sourcerygxx-4_1-15:1.11
	binutils-csl-sourcerygxx-4_1-13:1.11
	binutils-2_17:1.11
	binutils-csl-sourcerygxx-4_1-12:1.11
	binutils-csl-sourcerygxx-3_4_4-21:1.11
	binutils-csl-wrs-linux-3_4_4-24:1.9
	binutils-csl-wrs-linux-3_4_4-23:1.9
	binutils-csl-sourcerygxx-4_1-9:1.11
	binutils-csl-sourcerygxx-4_1-8:1.11
	binutils-csl-sourcerygxx-4_1-7:1.11
	binutils-csl-arm-2006q1-6:1.11
	binutils-csl-sourcerygxx-4_1-6:1.11
	binutils-csl-wrs-linux-3_4_4-22:1.9
	binutils-csl-coldfire-4_1-11:1.11
	binutils-csl-sourcerygxx-3_4_4-19:1.11
	binutils-csl-coldfire-4_1-10:1.11
	binutils-csl-sourcerygxx-4_1-5:1.11
	binutils-csl-sourcerygxx-4_1-4:1.11
	binutils-csl-wrs-linux-3_4_4-21:1.9
	binutils-csl-morpho-4_1-4:1.11
	binutils-csl-sourcerygxx-3_4_4-17:1.11
	binutils-csl-wrs-linux-3_4_4-20:1.9
	binutils-2_17-branch:1.11.0.4
	binutils-2_17-branchpoint:1.11
	binutils-csl-2_17-branch:1.11.0.2
	binutils-csl-2_17-branchpoint:1.11
	binutils-csl-gxxpro-3_4-branch:1.9.0.12
	binutils-csl-gxxpro-3_4-branchpoint:1.9
	binutils-2_16_1:1.9
	binutils-csl-arm-2005q1b:1.9
	binutils-2_16:1.9
	binutils-csl-arm-2005q1a:1.9
	binutils-csl-arm-2005q1-branch:1.9.0.10
	binutils-csl-arm-2005q1-branchpoint:1.9
	binutils-2_16-branch:1.9.0.8
	binutils-2_16-branchpoint:1.9
	csl-arm-2004-q3d:1.9
	csl-arm-2004-q3:1.9
	binutils-2_15:1.9
	binutils-2_15-branchpoint:1.9
	csl-arm-2004-q1a:1.9
	csl-arm-2004-q1:1.9
	binutils-2_15-branch:1.9.0.6
	cagney_bfdfile-20040213-branch:1.9.0.4
	cagney_bfdfile-20040213-branchpoint:1.9
	cagney_bigcore-20040122-branch:1.9.0.2
	cagney_bigcore-20040122-branchpoint:1.9
	csl-arm-2003-q4:1.9
	binutils-2_14:1.8
	binutils-2_14-branch:1.8.0.2
	binutils-2_14-branchpoint:1.8
	binutils-2_13_2_1:1.5
	binutils-2_13_2:1.5
	binutils-2_13_1:1.5
	binutils-2_13:1.5
	binutils-2_13-branchpoint:1.5
	binutils-2_13-branch:1.5.0.2
	binutils-2_12_1:1.4
	binutils-2_12:1.4
	binutils-2_12-branch:1.4.0.2
	binutils-2_12-branchpoint:1.4
	cygnus_cvs_20020108_pre:1.4
	binutils-2_11_2:1.3.2.1
	binutils-2_11_1:1.3.2.1
	binutils-2_11:1.3
	x86_64versiong3:1.3
	binutils-2_11-branch:1.3.0.2
	binutils-2_10_1:1.2.2.1
	binutils-2_10:1.2.2.1
	binutils-2_10-branch:1.2.0.2
	binutils-2_10-branchpoint:1.2
	binutils_latest_snapshot:1.15
	repo-unification-2000-02-06:1.1.1.1
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.15
date	2010.04.09.14.40.13;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2008.06.12.11.57.40;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2007.07.05.16.54.45;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2007.04.26.14.46.59;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2005.12.22.18.11.09;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2005.05.08.14.17.39;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2003.09.14.12.20.16;	author aj;	state Exp;
branches;
next	1.8;

1.8
date	2003.02.04.14.31.04;	author schwab;	state Exp;
branches;
next	1.7;

1.7
date	2002.11.30.08.39.41;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2002.11.11.23.15.38;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.23.04.11.56;	author kazu;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.13.06.43.57;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.07.04.34.50;	author amodra;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2000.03.28.01.11.27;	author nickc;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	99.05.03.07.29.10;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.3.2.1
date	2001.06.07.03.12.28;	author amodra;	state Exp;
branches;
next	;

1.2.2.1
date	2000.04.07.04.39.25;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.10;	author rth;	state Exp;
branches;
next	;


desc
@@


1.15
log
@bfd/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * aoutx.h (aout_link_input_bfd): Remove unused variable sym_count.
        * elf-eh-frame.c (_bfd_elf_eh_frame_section_offset): Remove unused
        variables htab and hdr_info and mark info parameter as unused.
        * elf.c (prep_headers): Remove unused variable i_phdrp.
        (_bfd_elf_write_object_contents): Remove unused variable i_ehdrp.
        * elf32-i386.c (elf_i386_relocate_section): Mark variabled warned
        as unused.
        * peXXigen.c (pe_print_reloc): Remove unused variable datasize.
        * verilog.c (verilog_write_section): Remove unused variable
        address.

binutils/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * dwarf.c (process_debug_info): Remove unused variable
        cu_abbrev_offset_ptr.
        (display_debug_lines_decoded): Remove unused variable prev_line.
        * elfedit.c (process_archive): Remove unused variable
        file_name_size.
        * ieee.c (ieee_start_compilation_unit): Remove unused variable
        nindx.
        (ieee_set_type): Remove unused variables info, targetindx and
        baseindx.
        * objdump.c (disassmble_byte): Remove unused variable done_dot.
        * rddbg.c (read_section_stabs_debugging_info): Remove unused
        variable other.
        * readelf.c (dump_section_as_strings): Remove unused variable
        addr.
        (process_archive): Remove unused variable file_name_size.
        * stabs.c (parse_stab_string): Mark desc parameter as unused.
        Remove unused variable lineno.
        (parse_stab_struct_type): Remove unused variable orig.
        (stab_demangle_type): Remove unused variables constp, volatilep
        and hold.

gas/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * as.c (create_obj_attrs_section): Remove unused variable addr.
        * listing.c (listing_listing): Remove unused variable message.
        * read.c: Remove unnecessary register type qualifiers.
        (s_mri): Only define/use old_flag variable if MRI_MODE_CHANGE is
        defined.

ld/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * ldlang.c (wild_sort): Remove unused variable section_name.

opcodes/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * i386-dis.c (print_insn): Remove unused variable op.
        (OP_sI): Remove unused variable mask.
@
text
@/* rddbg.c -- Read debugging information into a generic form.
   Copyright 1995, 1996, 1997, 2000, 2002, 2003, 2005, 2007, 2008,
   2010  Free Software Foundation, Inc.
   Written by Ian Lance Taylor <ian@@cygnus.com>.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */


/* This file reads debugging information into a generic form.  This
   file knows how to dig the debugging information out of an object
   file.  */

#include "sysdep.h"
#include "bfd.h"
#include "libiberty.h"
#include "bucomm.h"
#include "debug.h"
#include "budbg.h"

static bfd_boolean read_section_stabs_debugging_info
  (bfd *, asymbol **, long, void *, bfd_boolean *);
static bfd_boolean read_symbol_stabs_debugging_info
  (bfd *, asymbol **, long, void *, bfd_boolean *);
static bfd_boolean read_ieee_debugging_info (bfd *, void *, bfd_boolean *);
static void save_stab (int, int, bfd_vma, const char *);
static void stab_context (void);
static void free_saved_stabs (void);

/* Read debugging information from a BFD.  Returns a generic debugging
   pointer.  */

void *
read_debugging_info (bfd *abfd, asymbol **syms, long symcount, bfd_boolean no_messages)
{
  void *dhandle;
  bfd_boolean found;

  dhandle = debug_init ();
  if (dhandle == NULL)
    return NULL;

  if (! read_section_stabs_debugging_info (abfd, syms, symcount, dhandle,
					   &found))
    return NULL;

  if (bfd_get_flavour (abfd) == bfd_target_aout_flavour)
    {
      if (! read_symbol_stabs_debugging_info (abfd, syms, symcount, dhandle,
					      &found))
	return NULL;
    }

  if (bfd_get_flavour (abfd) == bfd_target_ieee_flavour)
    {
      if (! read_ieee_debugging_info (abfd, dhandle, &found))
	return NULL;
    }

  /* Try reading the COFF symbols if we didn't find any stabs in COFF
     sections.  */
  if (! found
      && bfd_get_flavour (abfd) == bfd_target_coff_flavour
      && symcount > 0)
    {
      if (! parse_coff (abfd, syms, symcount, dhandle))
	return NULL;
      found = TRUE;
    }

  if (! found)
    {
      if (! no_messages)
	non_fatal (_("%s: no recognized debugging information"),
		   bfd_get_filename (abfd));
      return NULL;
    }

  return dhandle;
}

/* Read stabs in sections debugging information from a BFD.  */

static bfd_boolean
read_section_stabs_debugging_info (bfd *abfd, asymbol **syms, long symcount,
				   void *dhandle, bfd_boolean *pfound)
{
  static struct
    {
      const char *secname;
      const char *strsecname;
    }
  names[] =
    {
      { ".stab", ".stabstr" },
      { "LC_SYMTAB.stabs", "LC_SYMTAB.stabstr" },
      { "$GDB_SYMBOLS$", "$GDB_STRINGS$" }
    };
  unsigned int i;
  void *shandle;

  *pfound = FALSE;
  shandle = NULL;

  for (i = 0; i < sizeof names / sizeof names[0]; i++)
    {
      asection *sec, *strsec;

      sec = bfd_get_section_by_name (abfd, names[i].secname);
      strsec = bfd_get_section_by_name (abfd, names[i].strsecname);
      if (sec != NULL && strsec != NULL)
	{
	  bfd_size_type stabsize, strsize;
	  bfd_byte *stabs, *strings;
	  bfd_byte *stab;
	  bfd_size_type stroff, next_stroff;

	  stabsize = bfd_section_size (abfd, sec);
	  stabs = (bfd_byte *) xmalloc (stabsize);
	  if (! bfd_get_section_contents (abfd, sec, stabs, 0, stabsize))
	    {
	      fprintf (stderr, "%s: %s: %s\n",
		       bfd_get_filename (abfd), names[i].secname,
		       bfd_errmsg (bfd_get_error ()));
	      return FALSE;
	    }

	  strsize = bfd_section_size (abfd, strsec);
	  strings = (bfd_byte *) xmalloc (strsize);
	  if (! bfd_get_section_contents (abfd, strsec, strings, 0, strsize))
	    {
	      fprintf (stderr, "%s: %s: %s\n",
		       bfd_get_filename (abfd), names[i].strsecname,
		       bfd_errmsg (bfd_get_error ()));
	      return FALSE;
	    }

	  if (shandle == NULL)
	    {
	      shandle = start_stab (dhandle, abfd, TRUE, syms, symcount);
	      if (shandle == NULL)
		return FALSE;
	    }

	  *pfound = TRUE;

	  stroff = 0;
	  next_stroff = 0;
	  for (stab = stabs; stab < stabs + stabsize; stab += 12)
	    {
	      unsigned int strx;
	      int type;
	      int other ATTRIBUTE_UNUSED;
	      int desc;
	      bfd_vma value;

	      /* This code presumes 32 bit values.  */

	      strx = bfd_get_32 (abfd, stab);
	      type = bfd_get_8 (abfd, stab + 4);
	      other = bfd_get_8 (abfd, stab + 5);
	      desc = bfd_get_16 (abfd, stab + 6);
	      value = bfd_get_32 (abfd, stab + 8);

	      if (type == 0)
		{
		  /* Special type 0 stabs indicate the offset to the
		     next string table.  */
		  stroff = next_stroff;
		  next_stroff += value;
		}
	      else
		{
		  char *f, *s;

		  f = NULL;

		  if (stroff + strx > strsize)
		    {
		      fprintf (stderr, "%s: %s: stab entry %ld is corrupt, strx = 0x%x, type = %d\n",
			       bfd_get_filename (abfd), names[i].secname,
			       (long) (stab - stabs) / 12, strx, type);
		      continue;
		    }

		  s = (char *) strings + stroff + strx;

		  while (s[strlen (s) - 1] == '\\'
			 && stab + 12 < stabs + stabsize)
		    {
		      char *p;

		      stab += 12;
		      p = s + strlen (s) - 1;
		      *p = '\0';
		      s = concat (s,
				  ((char *) strings
				   + stroff
				   + bfd_get_32 (abfd, stab)),
				  (const char *) NULL);

		      /* We have to restore the backslash, because, if
			 the linker is hashing stabs strings, we may
			 see the same string more than once.  */
		      *p = '\\';

		      if (f != NULL)
			free (f);
		      f = s;
		    }

		  save_stab (type, desc, value, s);

		  if (! parse_stab (dhandle, shandle, type, desc, value, s))
		    {
		      stab_context ();
		      free_saved_stabs ();
		      return FALSE;
		    }

		  /* Don't free f, since I think the stabs code
		     expects strings to hang around.  This should be
		     straightened out.  FIXME.  */
		}
	    }

	  free_saved_stabs ();
	  free (stabs);

	  /* Don't free strings, since I think the stabs code expects
	     the strings to hang around.  This should be straightened
	     out.  FIXME.  */
	}
    }

  if (shandle != NULL)
    {
      if (! finish_stab (dhandle, shandle))
	return FALSE;
    }

  return TRUE;
}

/* Read stabs in the symbol table.  */

static bfd_boolean
read_symbol_stabs_debugging_info (bfd *abfd, asymbol **syms, long symcount,
				  void *dhandle, bfd_boolean *pfound)
{
  void *shandle;
  asymbol **ps, **symend;

  shandle = NULL;
  symend = syms + symcount;
  for (ps = syms; ps < symend; ps++)
    {
      symbol_info i;

      bfd_get_symbol_info (abfd, *ps, &i);

      if (i.type == '-')
	{
	  const char *s;
	  char *f;

	  if (shandle == NULL)
	    {
	      shandle = start_stab (dhandle, abfd, FALSE, syms, symcount);
	      if (shandle == NULL)
		return FALSE;
	    }

	  *pfound = TRUE;

	  s = i.name;
	  f = NULL;
	  while (s[strlen (s) - 1] == '\\'
		 && ps + 1 < symend)
	    {
	      char *sc, *n;

	      ++ps;
	      sc = xstrdup (s);
	      sc[strlen (sc) - 1] = '\0';
	      n = concat (sc, bfd_asymbol_name (*ps), (const char *) NULL);
	      free (sc);
	      if (f != NULL)
		free (f);
	      f = n;
	      s = n;
	    }

	  save_stab (i.stab_type, i.stab_desc, i.value, s);

	  if (! parse_stab (dhandle, shandle, i.stab_type, i.stab_desc,
			    i.value, s))
	    {
	      stab_context ();
	      free_saved_stabs ();
	      return FALSE;
	    }

	  /* Don't free f, since I think the stabs code expects
	     strings to hang around.  This should be straightened out.
	     FIXME.  */
	}
    }

  free_saved_stabs ();

  if (shandle != NULL)
    {
      if (! finish_stab (dhandle, shandle))
	return FALSE;
    }

  return TRUE;
}

/* Read IEEE debugging information.  */

static bfd_boolean
read_ieee_debugging_info (bfd *abfd, void *dhandle, bfd_boolean *pfound)
{
  asection *dsec;
  bfd_size_type size;
  bfd_byte *contents;

  /* The BFD backend puts the debugging information into a section
     named .debug.  */

  dsec = bfd_get_section_by_name (abfd, ".debug");
  if (dsec == NULL)
    return TRUE;

  size = bfd_section_size (abfd, dsec);
  contents = (bfd_byte *) xmalloc (size);
  if (! bfd_get_section_contents (abfd, dsec, contents, 0, size))
    return FALSE;

  if (! parse_ieee (dhandle, abfd, contents, size))
    return FALSE;

  free (contents);

  *pfound = TRUE;

  return TRUE;
}

/* Record stabs strings, so that we can give some context for errors.  */

#define SAVE_STABS_COUNT (16)

struct saved_stab
{
  int type;
  int desc;
  bfd_vma value;
  char *string;
};

static struct saved_stab saved_stabs[SAVE_STABS_COUNT];
static int saved_stabs_index;

/* Save a stabs string.  */

static void
save_stab (int type, int desc, bfd_vma value, const char *string)
{
  if (saved_stabs[saved_stabs_index].string != NULL)
    free (saved_stabs[saved_stabs_index].string);
  saved_stabs[saved_stabs_index].type = type;
  saved_stabs[saved_stabs_index].desc = desc;
  saved_stabs[saved_stabs_index].value = value;
  saved_stabs[saved_stabs_index].string = xstrdup (string);
  saved_stabs_index = (saved_stabs_index + 1) % SAVE_STABS_COUNT;
}

/* Provide context for an error.  */

static void
stab_context (void)
{
  int i;

  fprintf (stderr, _("Last stabs entries before error:\n"));
  fprintf (stderr, "n_type n_desc n_value  string\n");

  i = saved_stabs_index;
  do
    {
      struct saved_stab *stabp;

      stabp = saved_stabs + i;
      if (stabp->string != NULL)
	{
	  const char *s;

	  s = bfd_get_stab_name (stabp->type);
	  if (s != NULL)
	    fprintf (stderr, "%-6s", s);
	  else if (stabp->type == 0)
	    fprintf (stderr, "HdrSym");
	  else
	    fprintf (stderr, "%-6d", stabp->type);
	  fprintf (stderr, " %-6d ", stabp->desc);
	  fprintf_vma (stderr, stabp->value);
	  if (stabp->type != 0)
	    fprintf (stderr, " %s", stabp->string);
	  fprintf (stderr, "\n");
	}
      i = (i + 1) % SAVE_STABS_COUNT;
    }
  while (i != saved_stabs_index);
}

/* Free the saved stab strings.  */

static void
free_saved_stabs (void)
{
  int i;

  for (i = 0; i < SAVE_STABS_COUNT; i++)
    {
      if (saved_stabs[i].string != NULL)
	{
	  free (saved_stabs[i].string);
	  saved_stabs[i].string = NULL;
	}
    }

  saved_stabs_index = 0;
}
@


1.14
log
@        PR binutils/6483
        * objdump.c (dump_bfd): If the -g option found no STABS or IEEE
        debug information to display, try dumping DWARF information
        instead.
        * rddbg.c (read_debugging_info): Add a parameter to suppress the
        display of a warning message when no debug information is found.
        * budbg.h (read_debugging_info): Update prototype.
        * objcopy.c (copy_object): Continue to allow read_debugging_info
        to produce warning messages.
        * doc/binutils.texi (--debugging): Document new behaviour of the
        -g/--debugging option.
@
text
@d2 2
a3 2
   Copyright 1995, 1996, 1997, 2000, 2002, 2003, 2005, 2007, 2008
   Free Software Foundation, Inc.
d167 1
a167 1
	      int other;
@


1.13
log
@Change sources over to using GPLv3
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 2000, 2002, 2003, 2005, 2007
d48 1
a48 1
read_debugging_info (bfd *abfd, asymbol **syms, long symcount)
d87 3
a89 2
      non_fatal (_("%s: no recognized debugging information"),
		 bfd_get_filename (abfd));
@


1.12
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d23 1
@


1.11
log
@(read_section_stabs_debugging_info): Add $GDB_SYMBOLS$ entry to names[]
 array for SOM binaries.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 2000, 2002, 2003, 2005
d27 1
d29 1
a30 1
#include "libiberty.h"
@


1.10
log
@Update FSF address
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 2000, 2002, 2003
d103 7
a109 2
    } names[] = { { ".stab", ".stabstr" },
		  { "LC_SYMTAB.stabs", "LC_SYMTAB.stabstr" } };
@


1.9
log
@	* addr2line.c: Convert to ISO C90 prototypes, change PTR, remove
	unneeded (void *) casts.
	* ar.c: Likewise.
	* arlex.l: Likewise.
	* arparse.y: Likewise.
	* arsup.c: Likewise.
	* binemul.c: Likewise.
	* binemul.h: Likewise.
	* bucomm.c: Likewise.
	* bucomm.h: Likewise.
	* budbg.h: Likewise.
	* budemang.c: Likewise.
	* budemang.h: Likewise.
	* coffdump.c: Likewise.
	* coffgrok.c: Likewise.
	* cxxfilt.c: Likewise.
	* debug.c: Likewise.
	* debug.h: Likewise.
	* deflex.l: Likewise.
	* dlltool.c: Likewise.
	* dlltool.h: Likewise.
	* dllwrap.c: Likewise.
	* emul_aix.c: Likewise.
	* filemode.c: Likewise.
	* ieee.c: Likewise.
	* nlmconv.c: Likewise.
	* nlmconv.h: Likewise.
	* nlmheader.y: Likewise.
	* nm.c: Likewise.
	* prdbg.c: Likewise.
	* rclex.l: Likewise.
	* rcparse.y: Likewise.
	* rdcoff.c: Likewise.
	* rddbg.c: Likewise.
	* rename.c: Likewise.
	* resbin.c: Likewise.
	* rescoff.c: Likewise.
	* resrc.c: Likewise.
	* size.c: Likewise.
	* srconv.c: Likewise.
	* stabs.c: Likewise.
	* strings.c: Likewise.
	* sysdump.c: Likewise.
	* sysinfo.y: Likewise.
	* syslex.l: Likewise.
	* unwind-ia64.c: Likewise.
	* unwind-ia64.h: Likewise.
	* version.c: Likewise.
	* windres.c: Likewise.
	* windres.h: Likewise.
	* winduni.c: Likewise.
	* wrstabs.c: Likewise.
@
text
@d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.8
log
@	* rddbg.c (read_section_stabs_debugging_info): Cast ptrdiff_t to
	long and use %ld in printf format.
@
text
@d2 2
a3 1
   Copyright 1995, 1996, 1997, 2000, 2002 Free Software Foundation, Inc.
d34 1
a34 1
  PARAMS ((bfd *, asymbol **, long, PTR, bfd_boolean *));
d36 5
a40 9
  PARAMS ((bfd *, asymbol **, long, PTR, bfd_boolean *));
static bfd_boolean read_ieee_debugging_info
  PARAMS ((bfd *, PTR, bfd_boolean *));
static void save_stab
  PARAMS ((int, int, bfd_vma, const char *));
static void stab_context
  PARAMS ((void));
static void free_saved_stabs
  PARAMS ((void));
d45 2
a46 5
PTR
read_debugging_info (abfd, syms, symcount)
     bfd *abfd;
     asymbol **syms;
     long symcount;
d48 1
a48 1
  PTR dhandle;
d96 2
a97 6
read_section_stabs_debugging_info (abfd, syms, symcount, dhandle, pfound)
     bfd *abfd;
     asymbol **syms;
     long symcount;
     PTR dhandle;
     bfd_boolean *pfound;
d106 1
a106 1
  PTR shandle;
d254 2
a255 6
read_symbol_stabs_debugging_info (abfd, syms, symcount, dhandle, pfound)
     bfd *abfd;
     asymbol **syms;
     long symcount;
     PTR dhandle;
     bfd_boolean *pfound;
d257 1
a257 1
  PTR shandle;
d330 1
a330 4
read_ieee_debugging_info (abfd, dhandle, pfound)
     bfd *abfd;
     PTR dhandle;
     bfd_boolean *pfound;
d376 1
a376 5
save_stab (type, desc, value, string)
     int type;
     int desc;
     bfd_vma value;
     const char *string;
d390 1
a390 1
stab_context ()
d428 1
a428 1
free_saved_stabs ()
@


1.7
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d196 1
a196 1
		      fprintf (stderr, "%s: %s: stab entry %d is corrupt, strx = 0x%x, type = %d\n",
d198 1
a198 1
			       (stab - stabs) / 12, strx, type);
@


1.6
log
@	* rddbg.c (read_section_stabs_debugging_info): Also recognize
	LC_SYMTAB.stab/LC_SYMTAB.stabstr as a valid pair of sections.
@
text
@d32 12
a43 8
static boolean read_section_stabs_debugging_info
  PARAMS ((bfd *, asymbol **, long, PTR, boolean *));
static boolean read_symbol_stabs_debugging_info
  PARAMS ((bfd *, asymbol **, long, PTR, boolean *));
static boolean read_ieee_debugging_info PARAMS ((bfd *, PTR, boolean *));
static void save_stab PARAMS ((int, int, bfd_vma, const char *));
static void stab_context PARAMS ((void));
static void free_saved_stabs PARAMS ((void));
d55 1
a55 1
  boolean found;
d86 1
a86 1
      found = true;
d101 1
a101 1
static boolean
d107 1
a107 1
     boolean *pfound;
d118 1
a118 1
  *pfound = false;
d141 1
a141 1
	      return false;
d151 1
a151 1
	      return false;
d156 1
a156 1
	      shandle = start_stab (dhandle, abfd, true, syms, symcount);
d158 1
a158 1
		return false;
d161 1
a161 1
	  *pfound = true;
d234 1
a234 1
		      return false;
d255 1
a255 1
	return false;
d258 1
a258 1
  return true;
d263 1
a263 1
static boolean
d269 1
a269 1
     boolean *pfound;
d289 1
a289 1
	      shandle = start_stab (dhandle, abfd, false, syms, symcount);
d291 1
a291 1
		return false;
d294 1
a294 1
	  *pfound = true;
d321 1
a321 1
	      return false;
d335 1
a335 1
	return false;
d338 1
a338 1
  return true;
d343 1
a343 1
static boolean
d347 1
a347 1
     boolean *pfound;
d358 1
a358 1
    return true;
d363 1
a363 1
    return false;
d366 1
a366 1
    return false;
d370 1
a370 1
  *pfound = true;
d372 1
a372 1
  return true;
@


1.5
log
@	* rdcoff.c: Fix formatting.
	* rddbg.c: Likewise.
	* readelf.c: Likewise.
	* rename.c: Likewise.
	* resbin.c: Likewise.
	* resrc.c: Likewise.
	* resres.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 2000 Free Software Foundation, Inc.
d109 2
a110 1
    } names[] = { { ".stab", ".stabstr" } };
d180 1
a180 1
                     next string table.  */
d215 2
a216 2
                         the linker is hashing stabs strings, we may
                         see the same string more than once.  */
d234 2
a235 2
                     expects strings to hang around.  This should be
                     straightened out.  FIXME.  */
d243 2
a244 2
             the strings to hang around.  This should be straightened
             out.  FIXME.  */
@


1.4
log
@Fix typos in ChangeLogs and update copyright notices
@
text
@d188 1
a188 1
		  
d196 1
a196 1
		  
d198 1
a198 1
		  
@


1.3
log
@A mostly cosmetic tidy up of warnings and error message reporting.
@
text
@d2 1
a2 1
   Copyright (C) 1995, 96, 97, 98, 2000 Free Software Foundation, Inc.
@


1.3.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 2000 Free Software Foundation, Inc.
@


1.2
log
@catch out of range string offset in corrupt stab entry
@
text
@d2 1
a2 1
   Copyright (C) 1995, 96, 1997, 1998 Free Software Foundation, Inc.
d87 2
a88 2
      fprintf (stderr, _("%s: no recognized debugging information\n"),
	       bfd_get_filename (abfd));
d162 1
a162 1
	      bfd_size_type strx;
@


1.2.2.1
log
@A mostly cosmetic tidy up of warnings and error message reporting.
@
text
@d2 1
a2 1
   Copyright (C) 1995, 96, 97, 98, 2000 Free Software Foundation, Inc.
d87 2
a88 2
      non_fatal (_("%s: no recognized debugging information"),
		 bfd_get_filename (abfd));
d162 1
a162 1
	      unsigned int strx;
@


1.1
log
@Initial revision
@
text
@d188 9
d198 1
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

