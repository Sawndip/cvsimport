head	1.45;
access;
symbols
	binutils-2_24-branch:1.45.0.4
	binutils-2_24-branchpoint:1.45
	binutils-2_21_1:1.42
	binutils-2_23_2:1.45
	binutils-2_23_1:1.45
	binutils-2_23:1.45
	binutils-2_23-branch:1.45.0.2
	binutils-2_23-branchpoint:1.45
	binutils-2_22_branch:1.44.0.4
	binutils-2_22:1.44
	binutils-2_22-branch:1.44.0.2
	binutils-2_22-branchpoint:1.44
	binutils-2_21:1.42
	binutils-2_21-branch:1.42.0.2
	binutils-2_21-branchpoint:1.42
	binutils-2_20_1:1.39
	binutils-2_20:1.39
	binutils-arc-20081103-branch:1.36.0.4
	binutils-arc-20081103-branchpoint:1.36
	binutils-2_20-branch:1.39.0.2
	binutils-2_20-branchpoint:1.39
	dje-cgen-play1-branch:1.38.0.2
	dje-cgen-play1-branchpoint:1.38
	arc-20081103-branch:1.36.0.2
	arc-20081103-branchpoint:1.36
	binutils-2_19_1:1.35
	binutils-2_19:1.35
	binutils-2_19-branch:1.35.0.2
	binutils-2_19-branchpoint:1.35
	binutils-2_18:1.33
	binutils-2_18-branch:1.33.0.2
	binutils-2_18-branchpoint:1.33
	binutils-csl-coldfire-4_1-32:1.27.2.1
	binutils-csl-sourcerygxx-4_1-32:1.27.2.1
	binutils-csl-innovasic-fido-3_4_4-33:1.27.2.1
	binutils-csl-sourcerygxx-3_4_4-32:1.23.6.2
	binutils-csl-coldfire-4_1-30:1.27.2.1
	binutils-csl-sourcerygxx-4_1-30:1.27.2.1
	binutils-csl-coldfire-4_1-28:1.27.2.1
	binutils-csl-sourcerygxx-4_1-29:1.27.2.1
	binutils-csl-sourcerygxx-4_1-28:1.27.2.1
	binutils-csl-arm-2006q3-27:1.27.2.1
	binutils-csl-sourcerygxx-4_1-27:1.27.2.1
	binutils-csl-arm-2006q3-26:1.27.2.1
	binutils-csl-sourcerygxx-4_1-26:1.27.2.1
	binutils-csl-sourcerygxx-4_1-25:1.27.2.1
	binutils-csl-sourcerygxx-4_1-24:1.27
	binutils-csl-sourcerygxx-4_1-23:1.27
	binutils-csl-sourcerygxx-4_1-21:1.27
	binutils-csl-arm-2006q3-21:1.27
	binutils-csl-sourcerygxx-4_1-22:1.27
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.27
	binutils-csl-sourcerygxx-4_1-20:1.27
	binutils-csl-arm-2006q3-19:1.27
	binutils-csl-sourcerygxx-4_1-19:1.27
	binutils-csl-sourcerygxx-4_1-18:1.27
	binutils-csl-renesas-4_1-9:1.27
	binutils-csl-sourcerygxx-3_4_4-25:1.23.6.2
	binutils-csl-renesas-4_1-8:1.27
	binutils-csl-renesas-4_1-7:1.27
	binutils-csl-renesas-4_1-6:1.27
	binutils-csl-sourcerygxx-4_1-17:1.27
	binutils-csl-sourcerygxx-4_1-14:1.27
	binutils-csl-sourcerygxx-4_1-15:1.27
	binutils-csl-sourcerygxx-4_1-13:1.27
	binutils-2_17:1.27
	binutils-csl-sourcerygxx-4_1-12:1.27
	binutils-csl-sourcerygxx-3_4_4-21:1.27
	binutils-csl-wrs-linux-3_4_4-24:1.23
	binutils-csl-wrs-linux-3_4_4-23:1.23
	binutils-csl-sourcerygxx-4_1-9:1.27
	binutils-csl-sourcerygxx-4_1-8:1.27
	binutils-csl-sourcerygxx-4_1-7:1.27
	binutils-csl-arm-2006q1-6:1.27
	binutils-csl-sourcerygxx-4_1-6:1.27
	binutils-csl-wrs-linux-3_4_4-22:1.23
	binutils-csl-coldfire-4_1-11:1.27
	binutils-csl-sourcerygxx-3_4_4-19:1.27
	binutils-csl-coldfire-4_1-10:1.27
	binutils-csl-sourcerygxx-4_1-5:1.27
	binutils-csl-sourcerygxx-4_1-4:1.27
	binutils-csl-wrs-linux-3_4_4-21:1.23
	binutils-csl-morpho-4_1-4:1.27
	binutils-csl-sourcerygxx-3_4_4-17:1.27
	binutils-csl-wrs-linux-3_4_4-20:1.23
	binutils-2_17-branch:1.27.0.4
	binutils-2_17-branchpoint:1.27
	binutils-csl-2_17-branch:1.27.0.2
	binutils-csl-2_17-branchpoint:1.27
	binutils-csl-gxxpro-3_4-branch:1.23.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.23
	binutils-2_16_1:1.23
	binutils-csl-arm-2005q1b:1.23
	binutils-2_16:1.23
	binutils-csl-arm-2005q1a:1.23
	binutils-csl-arm-2005q1-branch:1.23.0.4
	binutils-csl-arm-2005q1-branchpoint:1.23
	binutils-2_16-branch:1.23.0.2
	binutils-2_16-branchpoint:1.23
	csl-arm-2004-q3d:1.21
	csl-arm-2004-q3:1.20
	binutils-2_15:1.20
	binutils-2_15-branchpoint:1.20
	csl-arm-2004-q1a:1.20
	csl-arm-2004-q1:1.20
	binutils-2_15-branch:1.20.0.6
	cagney_bfdfile-20040213-branch:1.20.0.4
	cagney_bfdfile-20040213-branchpoint:1.20
	cagney_bigcore-20040122-branch:1.20.0.2
	cagney_bigcore-20040122-branchpoint:1.20
	csl-arm-2003-q4:1.20
	binutils-2_14:1.18
	binutils-2_14-branch:1.18.0.2
	binutils-2_14-branchpoint:1.18
	binutils-2_13_2_1:1.13
	binutils-2_13_2:1.13
	binutils-2_13_1:1.13
	binutils-2_13:1.13
	binutils-2_13-branchpoint:1.13
	binutils-2_13-branch:1.13.0.2
	binutils-2_12_1:1.11.2.1
	binutils-2_12:1.11
	binutils-2_12-branch:1.11.0.2
	binutils-2_12-branchpoint:1.11
	cygnus_cvs_20020108_pre:1.10
	binutils-2_11_2:1.8.2.1
	binutils-2_11_1:1.8.2.1
	binutils-2_11:1.8
	x86_64versiong3:1.8
	binutils-2_11-branch:1.8.0.2
	binutils-2_10_1:1.5.2.2
	binutils-2_10:1.5.2.2
	binutils-2_10-branch:1.5.0.2
	binutils-2_10-branchpoint:1.5
	binutils_latest_snapshot:1.45
	repo-unification-2000-02-06:1.5
	binu_ss_19990721:1.4
	binu_ss_19990602:1.3
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.45
date	2012.02.09.04.51.44;	author amodra;	state Exp;
branches;
next	1.44;

1.44
date	2011.06.02.13.43.18;	author nickc;	state Exp;
branches;
next	1.43;

1.43
date	2011.04.13.07.50.14;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	2010.06.17.13.55.35;	author nickc;	state Exp;
branches;
next	1.41;

1.41
date	2009.11.16.11.12.37;	author ktietz;	state Exp;
branches;
next	1.40;

1.40
date	2009.09.11.11.16.19;	author nickc;	state Exp;
branches;
next	1.39;

1.39
date	2009.09.02.07.22.32;	author amodra;	state Exp;
branches;
next	1.38;

1.38
date	2009.02.09.15.40.24;	author ktietz;	state Exp;
branches;
next	1.37;

1.37
date	2009.01.06.15.36.05;	author ktietz;	state Exp;
branches;
next	1.36;

1.36
date	2008.10.21.00.26.17;	author amodra;	state Exp;
branches;
next	1.35;

1.35
date	2008.01.09.10.40.32;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	2007.10.08.13.50.18;	author carlos;	state Exp;
branches;
next	1.33;

1.33
date	2007.07.05.16.54.45;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2007.07.05.09.51.30;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	2007.06.18.15.30.33;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	2007.05.23.08.48.29;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	2007.04.26.14.46.59;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2007.02.17.13.33.54;	author jsm28;	state Exp;
branches;
next	1.27;

1.27
date	2005.10.03.19.37.44;	author mmitchel;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2005.09.30.20.04.21;	author mmitchel;	state Exp;
branches;
next	1.25;

1.25
date	2005.09.30.16.37.31;	author mmitchel;	state Exp;
branches;
next	1.24;

1.24
date	2005.05.08.14.17.39;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2005.03.03.11.46.12;	author amodra;	state Exp;
branches
	1.23.6.1;
next	1.22;

1.22
date	2005.02.17.12.59.59;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2004.10.18.14.04.40;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	2003.10.27.13.20.32;	author kazu;	state Exp;
branches;
next	1.19;

1.19
date	2003.09.14.12.20.17;	author aj;	state Exp;
branches;
next	1.18;

1.18
date	2003.04.23.09.00.22;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2003.04.22.17.31.08;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2003.04.05.08.21.46;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2003.04.03.13.40.51;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2003.04.01.23.09.29;	author cgf;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.05.23.25.27;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2002.04.09.16.55.47;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2002.01.23.16.12.56;	author nickc;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2001.09.19.05.33.17;	author hjl;	state Exp;
branches;
next	1.9;

1.9
date	2001.03.13.06.43.58;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.07.04.34.50;	author amodra;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	2000.04.04.14.32.29;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.03.14.10.03;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2000.01.07.22.33.48;	author nickc;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	99.06.07.03.16.55;	author schwab;	state Exp;
branches;
next	1.3;

1.3
date	99.05.25.12.10.24;	author dj;	state Exp;
branches;
next	1.2;

1.2
date	99.05.11.21.06.16;	author dj;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.29.10;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.27.2.1
date	2006.10.16.20.21.23;	author nathan;	state Exp;
branches;
next	;

1.23.6.1
date	2005.08.30.19.57.32;	author mmitchel;	state Exp;
branches;
next	1.23.6.2;

1.23.6.2
date	2005.11.29.03.45.00;	author mmitchel;	state Exp;
branches;
next	;

1.11.2.1
date	2002.05.09.11.53.26;	author amodra;	state Exp;
branches;
next	;

1.8.2.1
date	2001.06.07.03.12.28;	author amodra;	state Exp;
branches;
next	;

1.5.2.1
date	2000.04.05.05.36.41;	author amodra;	state Exp;
branches;
next	1.5.2.2;

1.5.2.2
date	2000.04.07.04.39.25;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.10;	author rth;	state Exp;
branches;
next	;


desc
@@


1.45
log
@	* sysdep.h: Include sys/stat.h here.
	* ar.c: Don't include headers already included by sysdep.h.
	* bucomm.c: Likewise.
	* budbg.h: Likewise.
	* dlltool.h: Likewise.
	* elfedit.c: Likewise.
	* nlmconv.c: Likewise.
	* objcopy.c: Likewise.
	* objdump.c: Likewise.
	* objdump.h: Likewise.
	* readelf.c: Likewise.
	* rename.c: Likewise.
	* resrc.c: Likewise.
	* strings.c: Likewise.
	* windres.c: Likewise.
	* od-macho.c: Ensure #include sysdep.h is first.
	* od-xcoff.c: Likewise.
	* dllwrap.c: Remove alloca pragma handled by sysdep.h, and
	remove duplicate headers.
	* dlltool.c: Likewise and ensure #include sysdep.h is first.
@
text
@/* windres.c -- a program to manipulate Windows resources
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007, 2008,
   2009, 2011, 2012 Free Software Foundation, Inc.
   Written by Ian Lance Taylor, Cygnus Support.
   Rewritten by Kai Tietz, Onevision.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* This program can read and write Windows resources in various
   formats.  In particular, it can act like the rc resource compiler
   program, and it can act like the cvtres res to COFF conversion
   program.

   It is based on information taken from the following sources:

   * Microsoft documentation.

   * The rcl program, written by Gunther Ebert
     <gunther.ebert@@ixos-leipzig.de>.

   * The res2coff program, written by Pedro A. Aranda <paag@@tid.es>.  */

#include "sysdep.h"
#include <assert.h>
#include <time.h>
#include "bfd.h"
#include "getopt.h"
#include "bucomm.h"
#include "libiberty.h"
#include "safe-ctype.h"
#include "obstack.h"
#include "windres.h"

/* Used by resrc.c at least.  */

int verbose = 0;

int target_is_bigendian = 0;
const char *def_target_arch;

static void set_endianness (bfd *, const char *);

/* An enumeration of format types.  */

enum res_format
{
  /* Unknown format.  */
  RES_FORMAT_UNKNOWN,
  /* Textual RC file.  */
  RES_FORMAT_RC,
  /* Binary RES file.  */
  RES_FORMAT_RES,
  /* COFF file.  */
  RES_FORMAT_COFF
};

/* A structure used to map between format types and strings.  */

struct format_map
{
  const char *name;
  enum res_format format;
};

/* A mapping between names and format types.  */

static const struct format_map format_names[] =
{
  { "rc", RES_FORMAT_RC },
  { "res", RES_FORMAT_RES },
  { "coff", RES_FORMAT_COFF },
  { NULL, RES_FORMAT_UNKNOWN }
};

/* A mapping from file extensions to format types.  */

static const struct format_map format_fileexts[] =
{
  { "rc", RES_FORMAT_RC },
  { "res", RES_FORMAT_RES },
  { "exe", RES_FORMAT_COFF },
  { "obj", RES_FORMAT_COFF },
  { "o", RES_FORMAT_COFF },
  { NULL, RES_FORMAT_UNKNOWN }
};

/* A list of include directories.  */

struct include_dir
{
  struct include_dir *next;
  char *dir;
};

static struct include_dir *include_dirs;

/* Static functions.  */

static void res_init (void);
static int extended_menuitems (const rc_menuitem *);
static enum res_format format_from_name (const char *, int);
static enum res_format format_from_filename (const char *, int);
static void usage (FILE *, int);
static int cmp_res_entry (const void *, const void *);
static rc_res_directory *sort_resources (rc_res_directory *);
static void reswr_init (void);
static const char * quot (const char *);

static rc_uint_type target_get_8 (const void *, rc_uint_type);
static void target_put_8 (void *, rc_uint_type);
static rc_uint_type target_get_16 (const void *, rc_uint_type);
static void target_put_16 (void *, rc_uint_type);
static rc_uint_type target_get_32 (const void *, rc_uint_type);
static void target_put_32 (void *, rc_uint_type);


/* When we are building a resource tree, we allocate everything onto
   an obstack, so that we can free it all at once if we want.  */

#define obstack_chunk_alloc xmalloc
#define obstack_chunk_free free

/* The resource building obstack.  */

static struct obstack res_obstack;

/* Initialize the resource building obstack.  */

static void
res_init (void)
{
  obstack_init (&res_obstack);
}

/* Allocate space on the resource building obstack.  */

void *
res_alloc (rc_uint_type bytes)
{
  return obstack_alloc (&res_obstack, (size_t) bytes);
}

/* We also use an obstack to save memory used while writing out a set
   of resources.  */

static struct obstack reswr_obstack;

/* Initialize the resource writing obstack.  */

static void
reswr_init (void)
{
  obstack_init (&reswr_obstack);
}

/* Allocate space on the resource writing obstack.  */

void *
reswr_alloc (rc_uint_type bytes)
{
  return obstack_alloc (&reswr_obstack, (size_t) bytes);
}

/* Open a file using the include directory search list.  */

FILE *
open_file_search (const char *filename, const char *mode, const char *errmsg,
		  char **real_filename)
{
  FILE *e;
  struct include_dir *d;

  e = fopen (filename, mode);
  if (e != NULL)
    {
      *real_filename = xstrdup (filename);
      return e;
    }

  if (errno == ENOENT)
    {
      for (d = include_dirs; d != NULL; d = d->next)
	{
	  char *n;

	  n = (char *) xmalloc (strlen (d->dir) + strlen (filename) + 2);
	  sprintf (n, "%s/%s", d->dir, filename);
	  e = fopen (n, mode);
	  if (e != NULL)
	    {
	      *real_filename = n;
	      return e;
	    }

	  if (errno != ENOENT)
	    break;
	}
    }

  fatal (_("can't open %s `%s': %s"), errmsg, filename, strerror (errno));

  /* Return a value to avoid a compiler warning.  */
  return NULL;
}

/* Compare two resource ID's.  We consider name entries to come before
   numeric entries, because that is how they appear in the COFF .rsrc
   section.  */

int
res_id_cmp (rc_res_id a, rc_res_id b)
{
  if (! a.named)
    {
      if (b.named)
	return 1;
      if (a.u.id > b.u.id)
	return 1;
      else if (a.u.id < b.u.id)
	return -1;
      else
	return 0;
    }
  else
    {
      unichar *as, *ase, *bs, *bse;

      if (! b.named)
	return -1;

      as = a.u.n.name;
      ase = as + a.u.n.length;
      bs = b.u.n.name;
      bse = bs + b.u.n.length;

      while (as < ase)
	{
	  int i;

	  if (bs >= bse)
	    return 1;
	  i = (int) *as - (int) *bs;
	  if (i != 0)
	    return i;
	  ++as;
	  ++bs;
	}

      if (bs < bse)
	return -1;

      return 0;
    }
}

/* Print a resource ID.  */

void
res_id_print (FILE *stream, rc_res_id id, int quote)
{
  if (! id.named)
    fprintf (stream, "%u", (int) id.u.id);
  else
    {
      if (quote)
	unicode_print_quoted (stream, id.u.n.name, id.u.n.length);
      else
      unicode_print (stream, id.u.n.name, id.u.n.length);
    }
}

/* Print a list of resource ID's.  */

void
res_ids_print (FILE *stream, int cids, const rc_res_id *ids)
{
  int i;

  for (i = 0; i < cids; i++)
    {
      res_id_print (stream, ids[i], 1);
      if (i + 1 < cids)
	fprintf (stream, ": ");
    }
}

/* Convert an ASCII string to a resource ID.  */

void
res_string_to_id (rc_res_id *res_id, const char *string)
{
  res_id->named = 1;
  unicode_from_ascii (&res_id->u.n.length, &res_id->u.n.name, string);
}

/* Convert an unicode string to a resource ID.  */
void
res_unistring_to_id (rc_res_id *res_id, const unichar *u)
{
  res_id->named = 1;
  res_id->u.n.length = unichar_len (u);
  res_id->u.n.name = unichar_dup_uppercase (u);
}

/* Define a resource.  The arguments are the resource tree, RESOURCES,
   and the location at which to put it in the tree, CIDS and IDS.
   This returns a newly allocated rc_res_resource structure, which the
   caller is expected to initialize.  If DUPOK is non-zero, then if a
   resource with this ID exists, it is returned.  Otherwise, a warning
   is issued, and a new resource is created replacing the existing
   one.  */

rc_res_resource *
define_resource (rc_res_directory **resources, int cids,
		 const rc_res_id *ids, int dupok)
{
  rc_res_entry *re = NULL;
  int i;

  assert (cids > 0);
  for (i = 0; i < cids; i++)
    {
      rc_res_entry **pp;

      if (*resources == NULL)
	{
	  static unsigned int timeval;

	  /* Use the same timestamp for every resource created in a
             single run.  */
	  if (timeval == 0)
	    timeval = time (NULL);

	  *resources = ((rc_res_directory *)
			res_alloc (sizeof (rc_res_directory)));
	  (*resources)->characteristics = 0;
	  (*resources)->time = timeval;
	  (*resources)->major = 0;
	  (*resources)->minor = 0;
	  (*resources)->entries = NULL;
	}

      for (pp = &(*resources)->entries; *pp != NULL; pp = &(*pp)->next)
	if (res_id_cmp ((*pp)->id, ids[i]) == 0)
	  break;

      if (*pp != NULL)
	re = *pp;
      else
	{
	  re = (rc_res_entry *) res_alloc (sizeof (rc_res_entry));
	  re->next = NULL;
	  re->id = ids[i];
	  if ((i + 1) < cids)
	    {
	      re->subdir = 1;
	      re->u.dir = NULL;
	    }
	  else
	    {
	      re->subdir = 0;
	      re->u.res = NULL;
	    }

	  *pp = re;
	}

      if ((i + 1) < cids)
	{
	  if (! re->subdir)
	    {
	      fprintf (stderr, "%s: ", program_name);
	      res_ids_print (stderr, i, ids);
	      fprintf (stderr, _(": expected to be a directory\n"));
	      xexit (1);
	    }

	  resources = &re->u.dir;
	}
    }

  if (re->subdir)
    {
      fprintf (stderr, "%s: ", program_name);
      res_ids_print (stderr, cids, ids);
      fprintf (stderr, _(": expected to be a leaf\n"));
      xexit (1);
    }

  if (re->u.res != NULL)
    {
      if (dupok)
	return re->u.res;

      fprintf (stderr, _("%s: warning: "), program_name);
      res_ids_print (stderr, cids, ids);
      fprintf (stderr, _(": duplicate value\n"));
    }

  re->u.res = ((rc_res_resource *)
	       res_alloc (sizeof (rc_res_resource)));
  memset (re->u.res, 0, sizeof (rc_res_resource));

  re->u.res->type = RES_TYPE_UNINITIALIZED;
  return re->u.res;
}

/* Define a standard resource.  This is a version of define_resource
   that just takes type, name, and language arguments.  */

rc_res_resource *
define_standard_resource (rc_res_directory **resources, int type,
			  rc_res_id name, rc_uint_type language, int dupok)
{
  rc_res_id a[3];

  a[0].named = 0;
  a[0].u.id = type;
  a[1] = name;
  a[2].named = 0;
  a[2].u.id = language;
  return define_resource (resources, 3, a, dupok);
}

/* Comparison routine for resource sorting.  */

static int
cmp_res_entry (const void *p1, const void *p2)
{
  const rc_res_entry **re1, **re2;

  re1 = (const rc_res_entry **) p1;
  re2 = (const rc_res_entry **) p2;
  return res_id_cmp ((*re1)->id, (*re2)->id);
}

/* Sort the resources.  */

static rc_res_directory *
sort_resources (rc_res_directory *resdir)
{
  int c, i;
  rc_res_entry *re;
  rc_res_entry **a;

  if (resdir->entries == NULL)
    return resdir;

  c = 0;
  for (re = resdir->entries; re != NULL; re = re->next)
    ++c;

  /* This is a recursive routine, so using xmalloc is probably better
     than alloca.  */
  a = (rc_res_entry **) xmalloc (c * sizeof (rc_res_entry *));

  for (i = 0, re = resdir->entries; re != NULL; re = re->next, i++)
    a[i] = re;

  qsort (a, c, sizeof (rc_res_entry *), cmp_res_entry);

  resdir->entries = a[0];
  for (i = 0; i < c - 1; i++)
    a[i]->next = a[i + 1];
  a[i]->next = NULL;

  free (a);

  /* Now sort the subdirectories.  */

  for (re = resdir->entries; re != NULL; re = re->next)
    if (re->subdir)
      re->u.dir = sort_resources (re->u.dir);

  return resdir;
}

/* Return whether the dialog resource DIALOG is a DIALOG or a
   DIALOGEX.  */

int
extended_dialog (const rc_dialog *dialog)
{
  const rc_dialog_control *c;

  if (dialog->ex != NULL)
    return 1;

  for (c = dialog->controls; c != NULL; c = c->next)
    if (c->data != NULL || c->help != 0)
      return 1;

  return 0;
}

/* Return whether MENUITEMS are a MENU or a MENUEX.  */

int
extended_menu (const rc_menu *menu)
{
  return extended_menuitems (menu->items);
}

static int
extended_menuitems (const rc_menuitem *menuitems)
{
  const rc_menuitem *mi;

  for (mi = menuitems; mi != NULL; mi = mi->next)
    {
      if (mi->help != 0 || mi->state != 0)
	return 1;
      if (mi->popup != NULL && mi->id != 0)
	return 1;
      if ((mi->type
	   & ~ (MENUITEM_CHECKED
		| MENUITEM_GRAYED
		| MENUITEM_HELP
		| MENUITEM_INACTIVE
		| MENUITEM_MENUBARBREAK
		| MENUITEM_MENUBREAK))
	  != 0)
	return 1;
      if (mi->popup != NULL)
	{
	  if (extended_menuitems (mi->popup))
	    return 1;
	}
    }

  return 0;
}

/* Convert a string to a format type, or exit if it can't be done.  */

static enum res_format
format_from_name (const char *name, int exit_on_error)
{
  const struct format_map *m;

  for (m = format_names; m->name != NULL; m++)
    if (strcasecmp (m->name, name) == 0)
      break;

  if (m->name == NULL && exit_on_error)
    {
      non_fatal (_("unknown format type `%s'"), name);
      fprintf (stderr, _("%s: supported formats:"), program_name);
      for (m = format_names; m->name != NULL; m++)
	fprintf (stderr, " %s", m->name);
      fprintf (stderr, "\n");
      xexit (1);
    }

  return m->format;
}

/* Work out a format type given a file name.  If INPUT is non-zero,
   it's OK to look at the file itself.  */

static enum res_format
format_from_filename (const char *filename, int input)
{
  const char *ext;
  FILE *e;
  bfd_byte b1, b2, b3, b4, b5;
  int magic;

  /* If we have an extension, see if we recognize it as implying a
     particular format.  */
  ext = strrchr (filename, '.');
  if (ext != NULL)
    {
      const struct format_map *m;

      ++ext;
      for (m = format_fileexts; m->name != NULL; m++)
	if (strcasecmp (m->name, ext) == 0)
	  return m->format;
    }

  /* If we don't recognize the name of an output file, assume it's a
     COFF file.  */
  if (! input)
    return RES_FORMAT_COFF;

  /* Read the first few bytes of the file to see if we can guess what
     it is.  */
  e = fopen (filename, FOPEN_RB);
  if (e == NULL)
    fatal ("%s: %s", filename, strerror (errno));

  b1 = getc (e);
  b2 = getc (e);
  b3 = getc (e);
  b4 = getc (e);
  b5 = getc (e);

  fclose (e);

  /* A PE executable starts with 0x4d 0x5a.  */
  if (b1 == 0x4d && b2 == 0x5a)
    return RES_FORMAT_COFF;

  /* A COFF .o file starts with a COFF magic number.  */
  magic = (b2 << 8) | b1;
  switch (magic)
    {
    case 0x14c: /* i386 */
    case 0x166: /* MIPS */
    case 0x184: /* Alpha */
    case 0x268: /* 68k */
    case 0x1f0: /* PowerPC */
    case 0x290: /* PA */
      return RES_FORMAT_COFF;
    }

  /* A RES file starts with 0x0 0x0 0x0 0x0 0x20 0x0 0x0 0x0.  */
  if (b1 == 0 && b2 == 0 && b3 == 0 && b4 == 0 && b5 == 0x20)
    return RES_FORMAT_RES;

  /* If every character is printable or space, assume it's an RC file.  */
  if ((ISPRINT (b1) || ISSPACE (b1))
      && (ISPRINT (b2) || ISSPACE (b2))
      && (ISPRINT (b3) || ISSPACE (b3))
      && (ISPRINT (b4) || ISSPACE (b4))
      && (ISPRINT (b5) || ISSPACE (b5)))
    return RES_FORMAT_RC;

  /* Otherwise, we give up.  */
  fatal (_("can not determine type of file `%s'; use the -J option"),
	 filename);

  /* Return something to silence the compiler warning.  */
  return RES_FORMAT_UNKNOWN;
}

/* Print a usage message and exit.  */

static void
usage (FILE *stream, int status)
{
  fprintf (stream, _("Usage: %s [option(s)] [input-file] [output-file]\n"),
	   program_name);
  fprintf (stream, _(" The options are:\n\
  -i --input=<file>            Name input file\n\
  -o --output=<file>           Name output file\n\
  -J --input-format=<format>   Specify input format\n\
  -O --output-format=<format>  Specify output format\n\
  -F --target=<target>         Specify COFF target\n\
     --preprocessor=<program>  Program to use to preprocess rc file\n\
     --preprocessor-arg=<arg>  Additional preprocessor argument\n\
  -I --include-dir=<dir>       Include directory when preprocessing rc file\n\
  -D --define <sym>[=<val>]    Define SYM when preprocessing rc file\n\
  -U --undefine <sym>          Undefine SYM when preprocessing rc file\n\
  -v --verbose                 Verbose - tells you what it's doing\n\
  -c --codepage=<codepage>     Specify default codepage\n\
  -l --language=<val>          Set language when reading rc file\n\
     --use-temp-file           Use a temporary file instead of popen to read\n\
                               the preprocessor output\n\
     --no-use-temp-file        Use popen (default)\n"));
#ifdef YYDEBUG
  fprintf (stream, _("\
     --yydebug                 Turn on parser debugging\n"));
#endif
  fprintf (stream, _("\
  -r                           Ignored for compatibility with rc\n\
  @@<file>                      Read options from <file>\n\
  -h --help                    Print this help message\n\
  -V --version                 Print version information\n"));
  fprintf (stream, _("\
FORMAT is one of rc, res, or coff, and is deduced from the file name\n\
extension if not specified.  A single file name is an input file.\n\
No input-file is stdin, default rc.  No output-file is stdout, default rc.\n"));

  list_supported_targets (program_name, stream);

  if (REPORT_BUGS_TO[0] && status == 0)
    fprintf (stream, _("Report bugs to %s\n"), REPORT_BUGS_TO);

  exit (status);
}

/* Quote characters that will confuse the shell when we run the preprocessor.  */

static const char *
quot (const char *string)
{
  static char *buf = 0;
  static int buflen = 0;
  int slen = strlen (string);
  const char *src;
  char *dest;

  if ((buflen < slen * 2 + 2) || ! buf)
    {
      buflen = slen * 2 + 2;
      if (buf)
	free (buf);
      buf = (char *) xmalloc (buflen);
    }

  for (src=string, dest=buf; *src; src++, dest++)
    {
      if (*src == '(' || *src == ')' || *src == ' ')
	*dest++ = '\\';
      *dest = *src;
    }
  *dest = 0;
  return buf;
}

/* Long options.  */

enum option_values
{
  /* 150 isn't special; it's just an arbitrary non-ASCII char value.  */
  OPTION_PREPROCESSOR	= 150,
  OPTION_USE_TEMP_FILE,
  OPTION_NO_USE_TEMP_FILE,
  OPTION_YYDEBUG,
  OPTION_INCLUDE_DIR,
  OPTION_PREPROCESSOR_ARG
};

static const struct option long_options[] =
{
  {"input", required_argument, 0, 'i'},
  {"output", required_argument, 0, 'o'},
  {"input-format", required_argument, 0, 'J'},
  {"output-format", required_argument, 0, 'O'},
  {"target", required_argument, 0, 'F'},
  {"preprocessor", required_argument, 0, OPTION_PREPROCESSOR},
  {"preprocessor-arg", required_argument, 0, OPTION_PREPROCESSOR_ARG},
  {"include-dir", required_argument, 0, OPTION_INCLUDE_DIR},
  {"define", required_argument, 0, 'D'},
  {"undefine", required_argument, 0, 'U'},
  {"verbose", no_argument, 0, 'v'},
  {"codepage", required_argument, 0, 'c'},
  {"language", required_argument, 0, 'l'},
  {"use-temp-file", no_argument, 0, OPTION_USE_TEMP_FILE},
  {"no-use-temp-file", no_argument, 0, OPTION_NO_USE_TEMP_FILE},
  {"yydebug", no_argument, 0, OPTION_YYDEBUG},
  {"version", no_argument, 0, 'V'},
  {"help", no_argument, 0, 'h'},
  {0, no_argument, 0, 0}
};

void
windres_add_include_dir (const char *p)
{
  struct include_dir *n, **pp;

  /* Computing paths is often complicated and error prone.
     The easiest way to check for mistakes is at the time
     we add them to include_dirs.  */
  assert (p != NULL);
  assert (*p != '\0');

  n = xmalloc (sizeof *n);
  n->next = NULL;
  n->dir = (char * ) p;

  for (pp = &include_dirs; *pp != NULL; pp = &(*pp)->next)
    ;
  *pp = n;
}

/* This keeps gcc happy when using -Wmissing-prototypes -Wstrict-prototypes.  */
int main (int, char **);

/* The main function.  */

int
main (int argc, char **argv)
{
  int c;
  char *input_filename;
  char *output_filename;
  enum res_format input_format;
  enum res_format input_format_tmp;
  enum res_format output_format;
  char *target;
  char *preprocessor;
  char *preprocargs;
  const char *quotedarg;
  int language;
  rc_res_directory *resources;
  int use_temp_file;

#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

  program_name = argv[0];
  xmalloc_set_program_name (program_name);

  expandargv (&argc, &argv);

  bfd_init ();
  set_default_bfd_target ();

  res_init ();

  input_filename = NULL;
  output_filename = NULL;
  input_format = RES_FORMAT_UNKNOWN;
  output_format = RES_FORMAT_UNKNOWN;
  target = NULL;
  preprocessor = NULL;
  preprocargs = NULL;
  language = 0x409;   /* LANG_ENGLISH, SUBLANG_ENGLISH_US.  */
  use_temp_file = 0;

  while ((c = getopt_long (argc, argv, "c:f:i:l:o:I:J:O:F:D:U:rhHvV", long_options,
			   (int *) 0)) != EOF)
    {
      switch (c)
	{
	case 'c':
	  {
	    rc_uint_type ncp;

	    if (optarg[0] == '0' && (optarg[1] == 'x' || optarg[1] == 'X'))
	      ncp = (rc_uint_type) strtol (optarg + 2, NULL, 16);
	    else
	      ncp = (rc_uint_type) strtol (optarg, NULL, 10);
	    if (ncp == CP_UTF16 || ! unicode_is_valid_codepage (ncp))
	      fatal (_("invalid codepage specified.\n"));
	    wind_default_codepage = wind_current_codepage = ncp;
	  }
	  break;

	case 'i':
	  input_filename = optarg;
	  break;

	case 'f':
	  /* For compatibility with rc we accept "-fo <name>" as being the
	     equivalent of "-o <name>".  We do not advertise this fact
	     though, as we do not want users to use non-GNU like command
	     line switches.  */
	  if (*optarg != 'o')
	    fatal (_("invalid option -f\n"));
	  optarg++;
	  if (* optarg == 0)
	    {
	      if (optind == argc)
		fatal (_("No filename following the -fo option.\n"));
	      optarg = argv [optind++];
	    }
	  /* Fall through.  */

	case 'o':
	  output_filename = optarg;
	  break;

	case 'J':
	  input_format = format_from_name (optarg, 1);
	  break;

	case 'O':
	  output_format = format_from_name (optarg, 1);
	  break;

	case 'F':
	  target = optarg;
	  break;

	case OPTION_PREPROCESSOR:
	  preprocessor = optarg;
	  break;

	case OPTION_PREPROCESSOR_ARG:
	  if (preprocargs == NULL)
	    {
	      quotedarg = quot (optarg);
	      preprocargs = xstrdup (quotedarg);
	    }
	  else
	    {
	      char *n;

	      quotedarg = quot (optarg);
	      n = xmalloc (strlen (preprocargs) + strlen (quotedarg) + 2);
	      sprintf (n, "%s %s", preprocargs, quotedarg);
	      free (preprocargs);
	      preprocargs = n;
	    }
	  break;

	case 'D':
	case 'U':
	  if (preprocargs == NULL)
	    {
	      quotedarg = quot (optarg);
	      preprocargs = xmalloc (strlen (quotedarg) + 3);
	      sprintf (preprocargs, "-%c%s", c, quotedarg);
	    }
	  else
	    {
	      char *n;

	      quotedarg = quot (optarg);
	      n = xmalloc (strlen (preprocargs) + strlen (quotedarg) + 4);
	      sprintf (n, "%s -%c%s", preprocargs, c, quotedarg);
	      free (preprocargs);
	      preprocargs = n;
	    }
	  break;

	case 'r':
	  /* Ignored for compatibility with rc.  */
	  break;

	case 'v':
	  verbose ++;
	  break;

	case 'I':
	  /* For backward compatibility, should be removed in the future.  */
	  input_format_tmp = format_from_name (optarg, 0);
	  if (input_format_tmp != RES_FORMAT_UNKNOWN)
	    {
	      struct stat statbuf;
	      char modebuf[11];
	      
	      if (stat (optarg, & statbuf) == 0
		  /* Coded this way to avoid importing knowledge of S_ISDIR into this file.  */
		  && (mode_string (statbuf.st_mode, modebuf), modebuf[0] == 'd'))
		/* We have a -I option with a directory name that just happens
		   to match a format name as well.  eg: -I res  Assume that the
		   user knows what they are doing and do not complain.  */
		;
	      else
		{
		  fprintf (stderr,
			   _("Option -I is deprecated for setting the input format, please use -J instead.\n"));
		  input_format = input_format_tmp;
		  break;
		}
	    }
	  /* Fall through.  */

	case OPTION_INCLUDE_DIR:
	  if (preprocargs == NULL)
	    {
	      quotedarg = quot (optarg);
	      preprocargs = xmalloc (strlen (quotedarg) + 3);
	      sprintf (preprocargs, "-I%s", quotedarg);
	    }
	  else
	    {
	      char *n;

	      quotedarg = quot (optarg);
	      n = xmalloc (strlen (preprocargs) + strlen (quotedarg) + 4);
	      sprintf (n, "%s -I%s", preprocargs, quotedarg);
	      free (preprocargs);
	      preprocargs = n;
	    }

	  windres_add_include_dir (optarg);

	  break;

	case 'l':
	  language = strtol (optarg, (char **) NULL, 16);
	  break;

	case OPTION_USE_TEMP_FILE:
	  use_temp_file = 1;
	  break;

	case OPTION_NO_USE_TEMP_FILE:
	  use_temp_file = 0;
	  break;

#ifdef YYDEBUG
	case OPTION_YYDEBUG:
	  yydebug = 1;
	  break;
#endif

	case 'h':
	case 'H':
	  usage (stdout, 0);
	  break;

	case 'V':
	  print_version ("windres");
	  break;

	default:
	  usage (stderr, 1);
	  break;
	}
    }

  if (input_filename == NULL && optind < argc)
    {
      input_filename = argv[optind];
      ++optind;
    }

  if (output_filename == NULL && optind < argc)
    {
      output_filename = argv[optind];
      ++optind;
    }

  if (argc != optind)
    usage (stderr, 1);

  if (input_format == RES_FORMAT_UNKNOWN)
    {
      if (input_filename == NULL)
	input_format = RES_FORMAT_RC;
      else
	input_format = format_from_filename (input_filename, 1);
    }

  if (output_format == RES_FORMAT_UNKNOWN)
    {
      if (output_filename == NULL)
	output_format = RES_FORMAT_RC;
      else
	output_format = format_from_filename (output_filename, 0);
    }

  set_endianness (NULL, target);

  /* Read the input file.  */
  switch (input_format)
    {
    default:
      abort ();
    case RES_FORMAT_RC:
      resources = read_rc_file (input_filename, preprocessor, preprocargs,
				language, use_temp_file);
      break;
    case RES_FORMAT_RES:
      resources = read_res_file (input_filename);
      break;
    case RES_FORMAT_COFF:
      resources = read_coff_rsrc (input_filename, target);
      break;
    }

  if (resources == NULL)
    fatal (_("no resources"));

  /* Sort the resources.  This is required for COFF, convenient for
     rc, and unimportant for res.  */
  resources = sort_resources (resources);

  /* Write the output file.  */
  reswr_init ();

  switch (output_format)
    {
    default:
      abort ();
    case RES_FORMAT_RC:
      write_rc_file (output_filename, resources);
      break;
    case RES_FORMAT_RES:
      write_res_file (output_filename, resources);
      break;
    case RES_FORMAT_COFF:
      write_coff_file (output_filename, target, resources);
      break;
    }

  xexit (0);
  return 0;
}

static void
set_endianness (bfd *abfd, const char *target)
{
  const bfd_target *target_vec;

  def_target_arch = NULL;
  target_vec = bfd_get_target_info (target, abfd, &target_is_bigendian, NULL,
                                   &def_target_arch);
  if (! target_vec)
    fatal ("Can't detect target endianness and architecture.");
  if (! def_target_arch)
    fatal ("Can't detect architecture.");
}

bfd *
windres_open_as_binary (const char *filename, int rdmode)
{
  bfd *abfd;

  abfd = (rdmode ? bfd_openr (filename, "binary") : bfd_openw (filename, "binary"));
  if (! abfd)
    fatal ("can't open `%s' for %s", filename, (rdmode ? "input" : "output"));

  if (rdmode && ! bfd_check_format (abfd, bfd_object))
    fatal ("can't open `%s' for input.", filename);
  
  return abfd;
}

void
set_windres_bfd_endianness (windres_bfd *wrbfd, int is_bigendian)
{
  assert (!! wrbfd);
  switch (WR_KIND(wrbfd))
  {
  case WR_KIND_BFD_BIN_L:
    if (is_bigendian)
      WR_KIND(wrbfd) = WR_KIND_BFD_BIN_B;
    break;
  case WR_KIND_BFD_BIN_B:
    if (! is_bigendian)
      WR_KIND(wrbfd) = WR_KIND_BFD_BIN_L;
    break;
  default:
    /* only binary bfd can be overriden. */
    abort ();
  }
}

void
set_windres_bfd (windres_bfd *wrbfd, bfd *abfd, asection *sec, rc_uint_type kind)
{
  assert (!! wrbfd);
  switch (kind)
  {
  case WR_KIND_TARGET:
    abfd = NULL;
    sec = NULL;
    break;
  case WR_KIND_BFD:
  case WR_KIND_BFD_BIN_L:
  case WR_KIND_BFD_BIN_B:
    assert (!! abfd);
    assert (!!sec);
    break;
  default:
    abort ();
  }
  WR_KIND(wrbfd) = kind;
  WR_BFD(wrbfd) = abfd;
  WR_SECTION(wrbfd) = sec;
}

void
set_windres_bfd_content (windres_bfd *wrbfd, const void *data, rc_uint_type off,
			 rc_uint_type length)
{
  if (WR_KIND(wrbfd) != WR_KIND_TARGET)
    {
      if (! bfd_set_section_contents (WR_BFD(wrbfd), WR_SECTION(wrbfd), data, off, length))
	bfd_fatal ("bfd_set_section_contents");
    }
  else
    abort ();
}

void
get_windres_bfd_content (windres_bfd *wrbfd, void *data, rc_uint_type off,
			 rc_uint_type length)
{
  if (WR_KIND(wrbfd) != WR_KIND_TARGET)
    {
      if (! bfd_get_section_contents (WR_BFD(wrbfd), WR_SECTION(wrbfd), data, off, length))
	bfd_fatal ("bfd_get_section_contents");
    }
  else
    abort ();
}

void
windres_put_8 (windres_bfd *wrbfd, void *p, rc_uint_type value)
{
  switch (WR_KIND(wrbfd))
    {
    case WR_KIND_TARGET:
      target_put_8 (p, value);
      break;
    case WR_KIND_BFD:
    case WR_KIND_BFD_BIN_L:
    case WR_KIND_BFD_BIN_B:
      bfd_put_8 (WR_BFD(wrbfd), value, p);
      break;
    default:
      abort ();
    }
}

void
windres_put_16 (windres_bfd *wrbfd, void *data, rc_uint_type value)
{
  switch (WR_KIND(wrbfd))
    {
    case WR_KIND_TARGET:
      target_put_16 (data, value);
      break;
    case WR_KIND_BFD:
    case WR_KIND_BFD_BIN_B:
      bfd_put_16 (WR_BFD(wrbfd), value, data);
      break;
    case WR_KIND_BFD_BIN_L:
      bfd_putl16 (value, data);
      break;
    default:
      abort ();
    }
}

void
windres_put_32 (windres_bfd *wrbfd, void *data, rc_uint_type value)
{
  switch (WR_KIND(wrbfd))
    {
    case WR_KIND_TARGET:
      target_put_32 (data, value);
      break;
    case WR_KIND_BFD:
    case WR_KIND_BFD_BIN_B:
      bfd_put_32 (WR_BFD(wrbfd), value, data);
      break;
    case WR_KIND_BFD_BIN_L:
      bfd_putl32 (value, data);
      break;
    default:
      abort ();
    }
}

rc_uint_type
windres_get_8 (windres_bfd *wrbfd, const void *data, rc_uint_type length)
{
  if (length < 1)
    fatal ("windres_get_8: unexpected eob.");
  switch (WR_KIND(wrbfd))
    {
    case WR_KIND_TARGET:
      return target_get_8 (data, length);
    case WR_KIND_BFD:
    case WR_KIND_BFD_BIN_B:
    case WR_KIND_BFD_BIN_L:
      return bfd_get_8 (WR_BFD(wrbfd), data);
    default:
      abort ();
    }
  return 0;
}

rc_uint_type
windres_get_16 (windres_bfd *wrbfd, const void *data, rc_uint_type length)
{
  if (length < 2)
    fatal ("windres_get_16: unexpected eob.");
  switch (WR_KIND(wrbfd))
    {
    case WR_KIND_TARGET:
      return target_get_16 (data, length);
    case WR_KIND_BFD:
    case WR_KIND_BFD_BIN_B:
      return bfd_get_16 (WR_BFD(wrbfd), data);
    case WR_KIND_BFD_BIN_L:
      return bfd_getl16 (data);
    default:
      abort ();
    }
  return 0;
}

rc_uint_type
windres_get_32 (windres_bfd *wrbfd, const void *data, rc_uint_type length)
{
  if (length < 4)
    fatal ("windres_get_32: unexpected eob.");
  switch (WR_KIND(wrbfd))
    {
    case WR_KIND_TARGET:
      return target_get_32 (data, length);
    case WR_KIND_BFD:
    case WR_KIND_BFD_BIN_B:
      return bfd_get_32 (WR_BFD(wrbfd), data);
    case WR_KIND_BFD_BIN_L:
      return bfd_getl32 (data);
    default:
      abort ();
    }
  return 0;
}

static rc_uint_type
target_get_8 (const void *p, rc_uint_type length)
{
  rc_uint_type ret;
  
  if (length < 1)
    fatal ("Resource too small for getting 8-bit value.");

  ret = (rc_uint_type) *((const bfd_byte *) p);
  return ret & 0xff;
}

static rc_uint_type
target_get_16 (const void *p, rc_uint_type length)
{
  if (length < 2)
    fatal ("Resource too small for getting 16-bit value.");
  
  if (target_is_bigendian)
    return bfd_getb16 (p);
  else
    return bfd_getl16 (p);
}

static rc_uint_type
target_get_32 (const void *p, rc_uint_type length)
{
  if (length < 4)
    fatal ("Resource too small for getting 32-bit value.");
  
  if (target_is_bigendian)
    return bfd_getb32 (p);
  else
    return bfd_getl32 (p);
}

static void
target_put_8 (void *p, rc_uint_type value)
{
  assert (!! p);
  *((bfd_byte *) p)=(bfd_byte) value;
}

static void
target_put_16 (void *p, rc_uint_type value)
{
  assert (!! p);
  
  if (target_is_bigendian)
    bfd_putb16 (value, p);
  else
    bfd_putl16 (value, p);
}

static void
target_put_32 (void *p, rc_uint_type value)
{
  assert (!! p);
  
  if (target_is_bigendian)
    bfd_putb32 (value, p);
  else
    bfd_putl32 (value, p);
}

static int isInComment = 0;

int wr_printcomment (FILE *e, const char *fmt, ...)
{
  va_list arg;
  int r = 0;

  if (isInComment)
    r += fprintf (e, "\n   ");
  else
    fprintf (e, "/* ");
  isInComment = 1;
  if (fmt == NULL)
    return r;
  va_start (arg, fmt);
  r += vfprintf (e, fmt, arg);
  va_end (arg);
  return r;
}

int wr_print (FILE *e, const char *fmt, ...)
{
  va_list arg;
  int r = 0;
  if (isInComment)
    r += fprintf (e, ".  */\n");
  isInComment = 0;
  if (! fmt)
    return r;
  va_start (arg, fmt);
  r += vfprintf (e, fmt, arg);
  va_end (arg);
  return r;    
}
@


1.44
log
@Fix spelling mistakes.
@
text
@d3 1
a3 1
   2009, 2011 Free Software Foundation, Inc.
a47 1
#include <sys/stat.h>
@


1.43
log
@	* windres.c (usage): Add new --preprocessor-arg option.
	(option_values): Add new OPTION_PREPROCESSOR_ARG enumerator.
	(option long_options): Add preprocessor-arg option.
	(main): Handle it.
	* doc/binutils.texi: Add documentation for --preprocessor-arg
	option.
	* NEWS: Add line about new --preprocessor-arg option for windres.

	* binutils-all/windres/windres.exp: Add '// cpparg <option>' command
	to rc file interpretation to specify addition pre-processor commands
	as script option.
	* binutils-all/windres/strtab3.rc: New.
	* binutils-all/windres/strtab3.rsd: New.
	* binutils-all/windres/README: Add note about cpparg script option.
	argument
@
text
@d57 1
a57 1
static void set_endianess (bfd *, const char *);
d1052 1
a1052 1
  set_endianess (NULL, target);
d1101 1
a1101 1
set_endianess (bfd *abfd, const char *target)
d1109 1
a1109 1
    fatal ("Can't detect target endianess and architecture.");
d1130 1
a1130 1
set_windres_bfd_endianess (windres_bfd *wrbfd, int is_bigendian)
@


1.42
log
@        PR binutils/11711
        * windres.c (enum option_values): New enum.
        (long_options): Use separate option number for --include-dir
        option.
        (main): Separate backwards compatibility check from code to
        implement --include-dir.  Check to see if directory exists and do
        not complain if it does.
@
text
@d3 1
a3 1
   2009 Free Software Foundation, Inc.
d668 1
d738 2
a739 1
  OPTION_INCLUDE_DIR
d750 1
d895 18
@


1.41
log
@2009-11-16  Kai Tietz  <kai.tietz@@onevision.com>

        * windmc.c (set_endianess): Use bfd_get_target_info.
        * windres.c (set_endianess): Likewise.
        (find_arch_match): Removed.
@
text
@d48 1
d730 9
a738 6
/* 150 isn't special; it's just an arbitrary non-ASCII char value.  */

#define OPTION_PREPROCESSOR	150
#define OPTION_USE_TEMP_FILE	(OPTION_PREPROCESSOR + 1)
#define OPTION_NO_USE_TEMP_FILE	(OPTION_USE_TEMP_FILE + 1)
#define OPTION_YYDEBUG		(OPTION_NO_USE_TEMP_FILE + 1)
d748 1
a748 1
  {"include-dir", required_argument, 0, 'I'},
d925 17
a941 4
	      fprintf (stderr,
	      	       _("Option -I is deprecated for setting the input format, please use -J instead.\n"));
	      input_format = input_format_tmp;
	      break;
d943 1
d945 1
@


1.40
log
@       * obcopy.c (copy_object): New parameter `input_arch', architecture
       of input file, if not specified in input file itself; all callers
       updated; `binary_architecture' hack removed.
       (copy_archive, copy_file): New parameter `input_arch', for
       `copy_object' usage.
       (copy_main): Accept `-B' (`--binary-architecture') option also
       for any arch-less input ifile format, not only `binary'; remove
       bfd_external_binary_architecture hack; instead, add `input_arch'
       to calls to `copy_file'.
       * windres.c, windmc.c : Obsolete and useless external references
       to `bfd_external_binary_architecture' or `bfd_external_machine'
       removed.

       * binary.c (binary_object_p): Remove bfd_external_binary_architecture
       hack.  objcopy `-B' (`--binary-architecture') option is now handled
       in a generic way.
@
text
@a1059 19
static int
find_arch_match(const char *tname,const char **arch)
{
  while (*arch != NULL)
    {
      const char *in_a = strstr (*arch, tname);
      char end_ch = (in_a ? in_a[strlen(tname)] : 0);

      if (in_a && (in_a == *arch || in_a[-1] == ':')
	  && end_ch == 0)
        {
	  def_target_arch = *arch;
	  return 1;
        }
      arch++;
    }
  return 0;
}

d1066 2
a1067 1
  target_vec = bfd_find_target (target, abfd);
d1070 2
a1071 37
  target_is_bigendian = ((target_vec->byteorder == BFD_ENDIAN_BIG) ? 1 : 0);

  {
    const char *  tname = target_vec->name;
    const char ** arches = bfd_arch_list();

    if (arches && tname)
      {
	char *hyp = strchr (tname, '-');

	if (hyp != NULL)
	  {
	    tname = ++hyp;

	    /* Make sure we dectect architecture names
	       for triplets like "pe-arm-wince-little".  */
	    if (!find_arch_match (tname, arches))
	      {
		char *new_tname = (char *) alloca (strlen (hyp) + 1);
		strcpy (new_tname, hyp);
		while ((hyp = strrchr (new_tname, '-')) != NULL)
		  {
		    *hyp = 0;
		    if (find_arch_match (new_tname, arches))
		      break;
		  }
	      }
	  }
	else
	  find_arch_match (tname, arches);
      }

    free (arches);

    if (! def_target_arch)
      fatal ("Can't detect architecture.");
  }
@


1.39
log
@update copyright dates
@
text
@a48 5
/* Defined in bfd/binary.c.  Used to set architecture and machine of input
   binary files.  */
extern enum bfd_architecture  bfd_external_binary_architecture;
extern unsigned long          bfd_external_machine;

@


1.38
log
@2009-02-09  Kai Tietz  <kai.tietz@@onevision.com>

	* windres.c (set_endianess): Copy name without leading '-'.
@
text
@d2 2
a3 2
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2007
   Free Software Foundation, Inc.
@


1.37
log
@2009-01-06  Kai Tietz  <kai.tietz@@onevision.com>

        * windres.c (set_endianess): Get architecture name
        for internal target names like "pe-arm-wince-little".
        (find_arch_match): New helper.
        * ChangeLog: Reset it.
        * ChangeLog-2008: Moved old ChangeLog.
@
text
@d1105 1
a1105 1
	    tname = hyp + 1;
@


1.36
log
@Remove unnecessary casts on obstack_alloc invocations.
@
text
@d1065 19
d1101 1
a1101 1
	const char ** arch = arches;
d1103 1
a1103 3
	if (strchr (tname, '-') != NULL)
	  tname = strchr (tname, '-') + 1;
	while (*arch != NULL)
d1105 1
a1105 2
	    const char *in_a = strstr (*arch, tname);
	    char end_ch = (in_a ? in_a[strlen(tname)] : 0);
d1107 3
a1109 2
	    if (in_a && (in_a == *arch || in_a[-1] == ':')
	        && end_ch == 0)
d1111 8
a1118 2
		def_target_arch = *arch;
		break;
a1119 1
	    arch++;
d1121 2
@


1.35
log
@PR binutils/55326
   * bucomm.c (list_supported_architectures): Free architecture list after use.
   * windres.c (set_endianess): Likewise.
   * windmc.c (set_endianess): Likewise.
@
text
@d160 1
a160 1
  return (void *) obstack_alloc (&res_obstack, (size_t) bytes);
d181 1
a181 1
  return (void *) obstack_alloc (&reswr_obstack, (size_t) bytes);
@


1.34
log
@
2007-10-08  Carlos O'Donell  <carlos@@codesourcery.com>

	* resrc.c (read_rc_file): Rename e to edit, and c to dir.
	Pass dir to windres_add_include_dir.  Add comments.
	(close_input_stream): Check pclose error, and call fatal if
	the preprocessor failed.
	* windres.c (windres_add_include_dir): Assert that p is non-NULL,
	and not an empty string.
@
text
@d1065 2
a1066 1
static void set_endianess (bfd *abfd, const char *target)
d1075 1
d1077 4
a1080 3
    const char *tname = target_vec->name;
    const char **arch = bfd_arch_list();
    if (arch && tname)
d1082 2
d1090 1
d1100 3
d1168 2
a1169 2
set_windres_bfd_content(windres_bfd *wrbfd, const void *data, rc_uint_type off,
			rc_uint_type length)
d1181 2
a1182 2
get_windres_bfd_content(windres_bfd *wrbfd, void *data, rc_uint_type off,
			rc_uint_type length)
@


1.33
log
@Change sources over to using GPLv3
@
text
@d768 6
@


1.32
log
@* resrc.c: (read_rc_file): Add include path of user passed rc input file.
* windres.c: (windres_add_include_dir): New.
  (main): Use of windres_add_include_dir.
* windres.h: (windres_add_include_dir): Add prototype.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
@


1.31
log
@* rclex.c: (cpp_line): Add code_page pragma support.
* windres.c: (usage, long_options, main): Add new option --codepage or -c.
* winduni.c: (wind_default_codepage, wind_current_codepage): New.
  (unicode_from_ascii, ascii_from_unicode): Use wind_current_codepage as codepage parameter.
  (unicode_print): Print 4 characters for hexadecimal values in unicode strings.
* winduni.h:  (wind_default_codepage, wind_current_codepage): Export.
* doc/binutils.texi: Document new option.
* NEWS: Mention new feature.
@
text
@d763 14
d943 1
a943 11
	  {
	    struct include_dir *n, **pp;

	    n = (struct include_dir *) xmalloc (sizeof *n);
	    n->next = NULL;
	    n->dir = optarg;

	    for (pp = &include_dirs; *pp != NULL; pp = &(*pp)->next)
	      ;
	    *pp = n;
	  }
@


1.30
log
@Updated windres tool
@
text
@d676 1
d753 1
d814 1
a814 1
  while ((c = getopt_long (argc, argv, "f:i:l:o:I:J:O:F:D:U:rhHvV", long_options,
d819 14
@


1.29
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d5 1
d43 1
a46 1
#include "bucomm.h"
d49 5
d58 5
d120 1
a120 1
static int extended_menuitems (const struct menuitem *);
d125 1
a125 1
static struct res_directory *sort_resources (struct res_directory *);
d129 8
d158 1
a158 1
res_alloc (size_t bytes)
d160 1
a160 1
  return (void *) obstack_alloc (&res_obstack, bytes);
d179 1
a179 1
reswr_alloc (size_t bytes)
d181 1
a181 1
  return (void *) obstack_alloc (&reswr_obstack, bytes);
d231 1
a231 1
res_id_cmp (struct res_id a, struct res_id b)
d279 1
a279 1
res_id_print (FILE *stream, struct res_id id, int quote)
d282 1
a282 1
    fprintf (stream, "%lu", id.u.id);
d286 2
a287 1
	putc ('"', stream);
a288 2
      if (quote)
	putc ('"', stream);
d295 1
a295 1
res_ids_print (FILE *stream, int cids, const struct res_id *ids)
d310 1
a310 1
res_string_to_id (struct res_id *res_id, const char *string)
d316 9
d327 1
a327 1
   This returns a newly allocated res_resource structure, which the
d333 3
a335 3
struct res_resource *
define_resource (struct res_directory **resources, int cids,
		 const struct res_id *ids, int dupok)
d337 1
a337 1
  struct res_entry *re = NULL;
d343 1
a343 1
      struct res_entry **pp;
d347 1
a347 1
	  static unsigned long timeval;
d354 2
a355 2
	  *resources = ((struct res_directory *)
			res_alloc (sizeof **resources));
d371 1
a371 1
	  re = (struct res_entry *) res_alloc (sizeof *re);
d420 3
a422 3
  re->u.res = ((struct res_resource *)
	       res_alloc (sizeof (struct res_resource)));
  memset (re->u.res, 0, sizeof (struct res_resource));
d431 3
a433 3
struct res_resource *
define_standard_resource (struct res_directory **resources, int type,
			  struct res_id name, int language, int dupok)
d435 1
a435 1
  struct res_id a[3];
d450 1
a450 1
  const struct res_entry **re1, **re2;
d452 2
a453 2
  re1 = (const struct res_entry **) p1;
  re2 = (const struct res_entry **) p2;
d459 2
a460 2
static struct res_directory *
sort_resources (struct res_directory *resdir)
d463 2
a464 2
  struct res_entry *re;
  struct res_entry **a;
d475 1
a475 1
  a = (struct res_entry **) xmalloc (c * sizeof (struct res_entry *));
d480 1
a480 1
  qsort (a, c, sizeof (struct res_entry *), cmp_res_entry);
d502 1
a502 1
extended_dialog (const struct dialog *dialog)
d504 1
a504 1
  const struct dialog_control *c;
d519 1
a519 1
extended_menu (const struct menu *menu)
d525 1
a525 1
extended_menuitems (const struct menuitem *menuitems)
d527 1
a527 1
  const struct menuitem *mi;
d586 1
a586 1
  unsigned char b1, b2, b3, b4, b5;
d713 1
a713 1
  if ((buflen < slen * 2 + 2) || !buf)
d780 1
a780 1
  struct res_directory *resources;
d890 2
a891 1
	      fprintf (stderr, _("Option -I is deprecated for setting the input format, please use -J instead.\n"));
d991 2
d1038 336
@


1.28
log
@top level:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.ac (TOPLEVEL_CONFIGURE_ARGUMENTS): Fix quoting.
	* configure: Regenerate.

bfd:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-pkgversion): New option.
	* configure: Regenerate.
	* Makefile.am (bfdver.h): Substitute for @@bfd_version_package@@.
	* Makefile.in: Regenerate.
	* version.h (BFD_VERSION_STRING): Define using
	@@bfd_version_package@@.

bfd/doc:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* Makefile.in: Regenerate.

binutils:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-bugurl): New option.
	* configure: Regenerate.
	* Makefile.am (REPORT_BUGS_TO): Define.
	(INCLUDES): Define REPORT_BUGS_TO.
	Regenerate dependencies.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* bucomm.h: Remove include of bin-bugs.h.
	* addr2line.c (usage): Don't print empty REPORT_BUGS_TO.
	* ar.c (usage): Pass s to list_supported_targets.  Don't print
	empty REPORT_BUGS_TO.
	* coffdump.c (show_usage): Don't print empty REPORT_BUGS_TO.
	* cxxfilt.c (usage): Print bug url when giving help.
	* dlltool.c (usage): Likewise.
	* dllwrap.c (usage): Likewise.
	* nlmconv.c (show_usage): Don't print empty REPORT_BUGS_TO.
	* nm.c (usage): Likewise.
	* objcopy.c (copy_usage, strip_usage): Likewise.
	* objdump.c (usage): Likewise.
	* readelf.c ((usage): Likewise. Add STREAM argument.  Adjust
	callers.
	* size.c (usage): Don't print empty REPORT_BUGS_TO.
	* srconv.c (show_usage): Likewise.
	* strings.c (usage): Likewise.
	* sysdymp.c (show_usage): Likewise.
	* windres.c (usage): Likewise.

gas:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-bugurl): New option.
	* configure: Regenerate.
	* dep-in.sed: Remove bin-bugs.h.
	* Makefile.am (REPORT_BUGS_TO): Define.
	(INCLUDES): Define REPORT_BUGS_TO.
	(DEP_INCLUDES): Likewise.
	($(OBJS)): No longer depend on bin-bugs.h.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* as.c (show_usage): Don't print empty REPORT_BUGS_TO.
	* as.h: Remove include of bin-bugs.h.

gprof:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-pkgversion, --with-bugurl): New options.
	* configure: Regenerate.
	* Makefile.am (PKGVERSION, REPORT_BUGS_TO): Define.
	(INCLUDES): Define PKGVERSION and REPORT_BUGS_TO.
	Regenerate dependencies.
	* Makefile.in: Regenerate.
	* gprof.c (usage): Don't print empty REPORT_BUGS_TO.
	(main): Include PKGVERSION in version output.
	* gprof.h: Remove include of bin-bugs.h.

include:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* bin-bugs.h: Remove.

ld:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-bugurl): New option.
	* configure: Regenerate.
	* Makefile.am (REPORT_BUGS_TO): Define.
	(INCLUDES): Define REPORT_BUGS_TO.
	Regenerate dependencies.
	* Makefile.in: Regenerate.
	* ld.h: Remove include of bin-bugs.h.
	* lexsup.c (help): Don't print empty REPORT_BUGS_TO.
@
text
@d37 1
a37 4
#include "config.h"
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
a41 1
#include "bucomm.h"
d45 1
@


1.27
log
@	* addr2line.c (usage): Document @@file.
	* ar.c (usage): Likewise.
	* coffdump (usage): Likewise.
	* cxxfilt.c (usage): Likewise.
	* dlltool.c (usage): Likewise.
	* dllwrap.c (usage): Likewise.
	* nlmconv.c (usage): Likewise.
	* nm.c (usage): Likewise.
	* objcopy.c (usage): Likewise.
	* objdump.c (usage): Likewise.
	* readelf.c (usage): Likewise.
	* size.c (usage): Likeise.
	* srconv.c (usage): Likewise.
	* strings.c (usage): Likewise.
	* windres.c (usage): Likewise.
	* doc/binutils.texi: Add section on common options.
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
d672 1
a672 1
  if (status == 0)
@


1.27.2.1
log
@	binutils/
	* Makefile.am: Rebuild dependencies.
	(REPORT_BUGS_TO): Always defined.
	(INCLUDES): Adjust.
	* Makefile.in: Rebuilt.
	* configure.in (REPORT_BUGS_TO): Provide default value.
	* configure: Rebuilt.
	* bucomm.h: Remove bin-bugs.h.
	* addr2line.c (usage): Don't print empty REPORT_BUGS_TO.
	* coffdump.c (show_usage): Likewise.
	* cxxfilt.c (usage): Likewise.
	* nlmconv.c (show_usage): Likewise.
	* nm.c (usage): Likewise.
	* objcopy.c (copy_usage, strip_usage): Likewise.
	* objdump.c (usage): Likewise.
	* size.c (usage): Likewise.
	* srconv.c (show_usage): Likewise.
	* string.c (usage): Likewise.
	* sysdymp.c (show_usage): Likewise.
	* windres.c (usage): Likewise.
	* readelf (usage): Likewise. Add STREAM argument.  Adjust callers.

	gas/
	* Makefile.am: Rebuild dependencies.
	(REPORT_BUGS_TO): Always defined.
	(INCLUDES): Adjust.
	* Makefile.in: Rebuilt.
	* configure.in (REPORT_BUGS_TO): Provide default value.
	* configure: Rebuilt.
	* as.c (show_usage): Don't print empty REPORT_BUGS_TO.
	* as.h: Remove bin-bugs.h.

	ld/
	* Makefile.am: Rebuild dependencies.
	(REPORT_BUGS_TO): Always defined.
	(INCLUDES): Adjust.
	* Makefile.in: Rebuilt.
	* configure.in (REPORT_BUGS_TO): Provide default value.
	* configure: Rebuilt.
	* ld.h: Remove bin-bugs.h
	* lexsup.c (help):  Don't print empty REPORT_BUGS_TO.

	gprof/
	* Makefile.am: Rebuild dependencies.
	(REPORT_BUGS_TO): Always defined.
	(PKGVERSION): Define.
	(INCLUDES): Adjust.
	* Makefile.in: Rebuilt.
	* configure.in (REPORT_BUGS_TO): Provide default value.
	* configure: Rebuilt.
	* gprof.c (usage): Don't print empty REPORT_BUGS_TO.
	* gprof.h: Remove bin-bugs.h

	include/
	* bin-bugs.h: Remove.
@
text
@d672 1
a672 1
  if (REPORT_BUGS_TO[0] && status == 0)
@


1.26
log
@	* dlltool.c (main): Fix typo.
	* windres.c (main): Likewise.
@
text
@d662 1
@


1.25
log
@	* addr2line.c (main): Likewise.
	* ar.c (main): Likewise.
	* coffdump.c (main): Likewise.
	* cxxfilt.c (main): Likewise.
	* dlltool.c (main): Likewise.
	* dllwrap.c (main): Likewise.
	* nlmconv.c (main): Likewise.
	* nm.c (main): Likewise.
	* objcopy.c (main): Likewise.
	* objdump.c (main): Likewise.
	* readelf.c (main): Likewise.
	* size.c (main): Likeiwse.
	* srcconv.c (main): Likewise.
	* strings.c (main): Likewise.
	* sysdump.c (main): Likewise.
	* sysinfo.c (main): Likewise.
	* windres.c (main): Likewise.

	* ldmain.c (main): Use expandargv.

	* gprof.c (main): Use expandargv.

	* as.c (main): Use expandargv.
@
text
@d770 1
a770 1
  expandargv (&ac, &av);
@


1.24
log
@Update FSF address
@
text
@d770 2
@


1.23
log
@update copyright dates
@
text
@d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.23.6.1
log
@	* ld/ldmain.c (main): Use expandargv.
	* binutils/addr2line.c (main): Likewise.
	* binutils/ar.c (main): Likewise.
	* binutils/coffdump.c (main): Likewise.
	* binutils/cxxfilt.c (main): Likewise.
	* binutils/dlltool.c (main): Likewise.
	* binutils/dllwrap.c (main): Likewise.
	* binutils/nlmconv.c (main): Likewise.
	* binutils/nm.c (main): Likewise.
	* binutils/objcopy.c (main): Likewise.
	* binutils/objdump.c (main): Likewise.
	* binutils/readelf.c (main): Likewise.
	* binutils/size.c (main): Likeiwse.
	* binutils/srcconv.c (main): Likewise.
	* binutils/strings.c (main): Likewise.
	* binutils/sysdump.c (main): Likewise.
	* binutils/sysinfo.c (main): Likewise.
	* binutils/windres.c (main): Likewise.

	* include/libiberty.h (expandargv): New function.
	* libiberty/argv.c (safe-ctype.h): Include it.
	(ISBLANK): Remove.
	(stdio.h): Include.
	(expandargv): New function.
	* libiberty/Makefile.in: Regenerated.
@
text
@a769 2
  expandargv (&ac, &av);

@


1.23.6.2
log
@	* binutils/dlltool.c (main): Fix typo.
	* binutils/windres.c (main): Likewise.
@
text
@d770 1
a770 1
  expandargv (&argc, &argv);
@


1.22
log
@	* deflex.l (YY_NO_UNPUT): Define.
	* rclex.l (YY_NO_UNPUT): Define.
	* rcparse.y (null_unichar): New static var.
	(res_null_text): Use it rather than attempting to init from wchar_t.
	* windres.c: Include assert.h and time.h before getopt.h.
	Include config.h and unistd.h too.
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003
@


1.21
log
@strings.c (usage): Place radix values for -t option into the correct order.

objcopy.c (add_redefine_syms_file): Change error messages to use
  <filename>:<linenumber>: format for easier parsing by automatic tools.

srconv.c (show_usage): Fix spelling typo.

windres.c (format_from_filename): Suggest the use of -J instead	of -I if the
  file type cannot be determined.
@
text
@d37 6
a49 2
#include <assert.h>
#include <time.h>
@


1.20
log
@	* ChangeLog: Fix typos.
	* ChangeLog-9197: Likewise.
	* ChangeLog-9899: Likewise.
	* NEWS: Likewise.
	* ar.c: Fix comment typos.
	* arsup.c: Likewise.
	* coffgrok.c: Likewise.
	* debug.c: Likewise.
	* debug.h: Likewise.
	* dlltool.c: Likewise.
	* ieee.c: Likewise.
	* nm.c: Likewise.
	* objdump.c: Likewise.
	* prdbg.c: Likewise.
	* readelf.c: Likewise.
	* resrc.c: Likewise.
	* sysinfo.y: Likewise.
	* windres.c: Likewise.
@
text
@d623 1
a623 1
  fatal (_("can not determine type of file `%s'; use the -I option"),
@


1.19
log
@	* addr2line.c: Convert to ISO C90 prototypes, change PTR, remove
	unneeded (void *) casts.
	* ar.c: Likewise.
	* arlex.l: Likewise.
	* arparse.y: Likewise.
	* arsup.c: Likewise.
	* binemul.c: Likewise.
	* binemul.h: Likewise.
	* bucomm.c: Likewise.
	* bucomm.h: Likewise.
	* budbg.h: Likewise.
	* budemang.c: Likewise.
	* budemang.h: Likewise.
	* coffdump.c: Likewise.
	* coffgrok.c: Likewise.
	* cxxfilt.c: Likewise.
	* debug.c: Likewise.
	* debug.h: Likewise.
	* deflex.l: Likewise.
	* dlltool.c: Likewise.
	* dlltool.h: Likewise.
	* dllwrap.c: Likewise.
	* emul_aix.c: Likewise.
	* filemode.c: Likewise.
	* ieee.c: Likewise.
	* nlmconv.c: Likewise.
	* nlmconv.h: Likewise.
	* nlmheader.y: Likewise.
	* nm.c: Likewise.
	* prdbg.c: Likewise.
	* rclex.l: Likewise.
	* rcparse.y: Likewise.
	* rdcoff.c: Likewise.
	* rddbg.c: Likewise.
	* rename.c: Likewise.
	* resbin.c: Likewise.
	* rescoff.c: Likewise.
	* resrc.c: Likewise.
	* size.c: Likewise.
	* srconv.c: Likewise.
	* stabs.c: Likewise.
	* strings.c: Likewise.
	* sysdump.c: Likewise.
	* sysinfo.y: Likewise.
	* syslex.l: Likewise.
	* unwind-ia64.c: Likewise.
	* unwind-ia64.h: Likewise.
	* version.c: Likewise.
	* windres.c: Likewise.
	* windres.h: Likewise.
	* winduni.c: Likewise.
	* wrstabs.c: Likewise.
@
text
@d791 1
a791 1
	  /* For compatability with rc we accept "-fo <name>" as being the
@


1.18
log
@Accept -fo as an alias for -o
@
text
@d107 9
a115 9
static void res_init PARAMS ((void));
static int extended_menuitems PARAMS ((const struct menuitem *));
static enum res_format format_from_name PARAMS ((const char *, int));
static enum res_format format_from_filename PARAMS ((const char *, int));
static void usage PARAMS ((FILE *, int));
static int cmp_res_entry PARAMS ((const PTR, const PTR));
static struct res_directory *sort_resources PARAMS ((struct res_directory *));
static void reswr_init PARAMS ((void));
static const char * quot PARAMS ((const char *));
d130 1
a130 1
res_init ()
d137 2
a138 3
PTR
res_alloc (bytes)
     size_t bytes;
d140 1
a140 1
  return (PTR) obstack_alloc (&res_obstack, bytes);
d151 1
a151 1
reswr_init ()
d158 2
a159 3
PTR
reswr_alloc (bytes)
     size_t bytes;
d161 1
a161 1
  return (PTR) obstack_alloc (&reswr_obstack, bytes);
d167 2
a168 5
open_file_search (filename, mode, errmsg, real_filename)
     const char *filename;
     const char *mode;
     const char *errmsg;
     char **real_filename;
d211 1
a211 3
res_id_cmp (a, b)
     struct res_id a;
     struct res_id b;
d259 1
a259 4
res_id_print (stream, id, quote)
     FILE *stream;
     struct res_id id;
     int quote;
d276 1
a276 4
res_ids_print (stream, cids, ids)
     FILE *stream;
     int cids;
     const struct res_id *ids;
d291 1
a291 3
res_string_to_id (res_id, string)
     struct res_id *res_id;
     const char *string;
d306 2
a307 5
define_resource (resources, cids, ids, dupok)
     struct res_directory **resources;
     int cids;
     const struct res_id *ids;
     int dupok;
d404 2
a405 6
define_standard_resource (resources, type, name, language, dupok)
     struct res_directory **resources;
     int type;
     struct res_id name;
     int language;
     int dupok;
d420 1
a420 3
cmp_res_entry (p1, p2)
     const PTR p1;
     const PTR p2;
d432 1
a432 2
sort_resources (resdir)
     struct res_directory *resdir;
d474 1
a474 2
extended_dialog (dialog)
     const struct dialog *dialog;
d491 1
a491 2
extended_menu (menu)
     const struct menu *menu;
d497 1
a497 2
extended_menuitems (menuitems)
     const struct menuitem *menuitems;
d529 1
a529 3
format_from_name (name, exit_on_error)
     const char *name;
     int exit_on_error;
d554 1
a554 3
format_from_filename (filename, input)
     const char *filename;
     int input;
d633 1
a633 3
usage (stream, status)
     FILE *stream;
     int status;
d676 1
a676 2
quot (string)
     const char *string;
d733 1
a733 1
int main PARAMS ((int, char **));
d738 1
a738 3
main (argc, argv)
     int argc;
     char **argv;
d801 1
a801 1
		fatal (_("No filename following the -fo option.\n"));	    
d863 1
a863 1
	  
a1003 1

@


1.17
log
@Rename -I to -J.   Deprecate old use of -I, but leave it enabled for now.
@
text
@a104 28
/* Long options.  */

/* 150 isn't special; it's just an arbitrary non-ASCII char value.  */

#define OPTION_PREPROCESSOR	150
#define OPTION_USE_TEMP_FILE	(OPTION_PREPROCESSOR + 1)
#define OPTION_NO_USE_TEMP_FILE	(OPTION_USE_TEMP_FILE + 1)
#define OPTION_YYDEBUG		(OPTION_NO_USE_TEMP_FILE + 1)

static const struct option long_options[] =
{
  {"define", required_argument, 0, 'D'},
  {"help", no_argument, 0, 'h'},
  {"include-dir", required_argument, 0, 'I'},
  {"input-format", required_argument, 0, 'J'},
  {"language", required_argument, 0, 'l'},
  {"output-format", required_argument, 0, 'O'},
  {"preprocessor", required_argument, 0, OPTION_PREPROCESSOR},
  {"target", required_argument, 0, 'F'},
  {"undefine", required_argument, 0, 'U'},
  {"use-temp-file", no_argument, 0, OPTION_USE_TEMP_FILE},
  {"no-use-temp-file", no_argument, 0, OPTION_NO_USE_TEMP_FILE},
  {"verbose", no_argument, 0, 'v'},
  {"version", no_argument, 0, 'V'},
  {"yydebug", no_argument, 0, OPTION_YYDEBUG},
  {0, no_argument, 0, 0}
};

d737 30
d818 1
a818 1
  while ((c = getopt_long (argc, argv, "i:l:o:I:J:O:F:D:U:rhHvV", long_options,
d826 16
@


1.16
log
@Add -l for compatibility with wrc, and rc.  Use the short option as a key for
long options that have a synonymous short option.
@
text
@d109 1
a109 2
#define OPTION_INCLUDE_DIR	150
#define OPTION_PREPROCESSOR	(OPTION_INCLUDE_DIR + 1)
d118 2
a119 2
  {"include-dir", required_argument, 0, OPTION_INCLUDE_DIR},
  {"input-format", required_argument, 0, 'I'},
d137 1
a137 1
static enum res_format format_from_name PARAMS ((const char *));
d585 1
a585 1
format_from_name (name)
d587 1
d595 1
a595 1
  if (m->name == NULL)
d702 1
a702 1
  -I --input-format=<format>   Specify input format\n\
d706 1
a706 1
     --include-dir=<dir>       Include directory when preprocessing rc file\n\
d710 1
a710 1
     --language=<val>          Set language when reading rc file\n\
d779 1
d816 1
a816 1
  while ((c = getopt_long (argc, argv, "i:l:o:I:O:F:D:U:rhHvV", long_options,
d829 2
a830 2
	case 'I':
	  input_format = format_from_name (optarg);
d834 1
a834 1
	  output_format = format_from_name (optarg);
d873 10
a882 1
	case OPTION_INCLUDE_DIR:
@


1.15
log
@Add -U for compatibility with wrc, rc, and cpp.  Just pass the -U option down
to the preprocessor.
@
text
@d109 2
a110 4
#define OPTION_HELP		150
#define OPTION_INCLUDE_DIR	(OPTION_HELP + 1)
#define OPTION_LANGUAGE		(OPTION_INCLUDE_DIR + 1)
#define OPTION_PREPROCESSOR	(OPTION_LANGUAGE + 1)
d113 1
a113 2
#define OPTION_VERSION		(OPTION_NO_USE_TEMP_FILE + 1)
#define OPTION_YYDEBUG		(OPTION_VERSION + 1)
d118 1
a118 1
  {"help", no_argument, 0, OPTION_HELP},
d121 1
a121 1
  {"language", required_argument, 0, OPTION_LANGUAGE},
d129 1
a129 1
  {"version", no_argument, 0, OPTION_VERSION},
d815 1
a815 1
  while ((c = getopt_long (argc, argv, "i:o:I:O:F:D:U:rhHvV", long_options,
d904 1
a904 1
	case OPTION_LANGUAGE:
a923 1
	case OPTION_HELP:
a927 1
	case OPTION_VERSION:
@


1.14
log
@* windres.c (usage): Report -r option.
(main): Ignore the -r option.
* doc/binutils.texi: Add -r to the list of options.
@
text
@d2 2
a3 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d35 1
a35 3
   * The res2coff program, written by Pedro A. Aranda <paag@@tid.es>.

   */
a43 1

d47 1
a47 1
/* used by resrc.c at least */
d109 8
a116 9
#define OPTION_DEFINE 150
#define OPTION_HELP (OPTION_DEFINE + 1)
#define OPTION_INCLUDE_DIR (OPTION_HELP + 1)
#define OPTION_LANGUAGE (OPTION_INCLUDE_DIR + 1)
#define OPTION_PREPROCESSOR (OPTION_LANGUAGE + 1)
#define OPTION_USE_TEMP_FILE (OPTION_PREPROCESSOR + 1)
#define OPTION_NO_USE_TEMP_FILE (OPTION_USE_TEMP_FILE + 1)
#define OPTION_VERSION (OPTION_NO_USE_TEMP_FILE + 1)
#define OPTION_YYDEBUG (OPTION_VERSION + 1)
d120 1
a120 1
  {"define", required_argument, 0, OPTION_DEFINE},
d128 1
d711 1
d818 1
a818 1
  while ((c = getopt_long (argc, argv, "i:o:I:O:F:D:rhHvV", long_options,
d848 1
a848 1
	case OPTION_DEFINE:
d853 1
a853 1
	      sprintf (preprocargs, "-D%s", quotedarg);
d861 1
a861 1
	      sprintf (n, "%s -D%s", preprocargs, quotedarg);
d868 1
a868 1
	  /* Ignored for compatibility with rc */
a973 1

a994 1

a997 1

@


1.13
log
@	* dlltool.c (process_def_file): Add missing prototype.
	(new_directive, assemble_file, main): Likewise.
	(process_def_file, new_directive): Make static.
	(inform): Rewrite using VA_FIXEDARG.
	* dllwrap.c (mybasename): Add missing prototype.
	(strhash, main): Likewise.
	(inform): Rewrite using VA_FIXEDARG.
	(warn): Likewise.
	(cleanup_and_exit): Use old style function definition.
	(strhash): Likewise.
	* windres.c (define_resource): Use one memset to clear all of
	struct res_resource.
@
text
@d723 1
d819 1
a819 1
  while ((c = getopt_long (argc, argv, "i:o:I:O:F:D:hHvV", long_options,
d866 4
@


1.12
log
@Set default LANGUAGE to english/us.
@
text
@d446 1
a448 3
  memset (&re->u.res->res_info, 0, sizeof (struct res_res_info));
  memset (&re->u.res->coff_info, 0, sizeof (struct res_coff_info));

@


1.11
log
@Tidy up formatting of --help output.
@
text
@d148 2
d770 3
d817 1
a817 1
  language = -1;
@


1.11.2.1
log
@Merge from mainline
@
text
@a147 2
static void reswr_init PARAMS ((void));
static const char * quot PARAMS ((const char *));
a443 1
  memset (re->u.res, 0, sizeof (struct res_resource));
d446 3
a767 3
/* This keeps gcc happy when using -Wmissing-prototypes -Wstrict-prototypes.  */
int main PARAMS ((int, char **));

d812 1
a812 1
  language = 0x409;   /* LANG_ENGLISH, SUBLANG_ENGLISH_US.  */
@


1.10
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
a640 1

a645 1

d702 1
a702 1
  fprintf (stream, _("Usage: %s [options] [input-file] [output-file]\n"),
d704 14
a717 18
  fprintf (stream, _("\
Options:\n\
  -i FILE, --input FILE       Name input file\n\
  -o FILE, --output FILE      Name output file\n\
  -I FORMAT, --input-format FORMAT\n\
                              Specify input format\n\
  -O FORMAT, --output-format FORMAT\n\
                              Specify output format\n\
  -F TARGET, --target TARGET  Specify COFF target\n\
  --preprocessor PROGRAM      Program to use to preprocess rc file\n\
  --include-dir DIR           Include directory when preprocessing rc file\n\
  -DSYM[=VAL], --define SYM[=VAL]\n\
                              Define SYM when preprocessing rc file\n\
  -v                          Verbose - tells you what it's doing\n\
  --language VAL              Set language when reading rc file\n\
  --use-temp-file             Use a temporary file instead of popen to read\n\
                              the preprocessor output\n\
  --no-use-temp-file          Use popen (default)\n"));
d720 1
a720 1
  --yydebug                   Turn on parser debugging\n"));
d723 2
a724 2
  --help                      Print this help message\n\
  --version                   Print version information\n"));
d729 1
d731 1
d734 1
d738 4
a741 2
/* Quote characters that will confuse the shell when we run the preprocessor */
static const char *quot (string)
d815 1
a815 1
  while ((c = getopt_long (argc, argv, "i:o:I:O:F:D:v", long_options,
d918 2
d924 1
@


1.9
log
@Fix typos in ChangeLogs and update copyright notices
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
d42 1
a46 1
#include <ctype.h>
d682 5
a686 5
  if ((isprint (b1) || isspace (b1))
      && (isprint (b2) || isspace (b2))
      && (isprint (b3) || isspace (b3))
      && (isprint (b4) || isspace (b4))
      && (isprint (b5) || isspace (b5)))
d791 3
@


1.8
log
@A mostly cosmetic tidy up of warnings and error message reporting.
@
text
@d2 1
a2 1
   Copyright 1997, 98, 99, 2000 Free Software Foundation, Inc.
@


1.8.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
@


1.7
log
@Move translated part of bug report string back into .c files so
xgettext can find it.  Regnerate .pot files.
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999 Free Software Foundation, Inc.
d602 1
a602 1
      fprintf (stderr, _("%s: unknown format type `%s'\n"), program_name, name);
@


1.6
log
@Move bug report string to one place.
@
text
@d737 1
a737 1
    fprintf (stream, REPORT_BUGS_TO);
@


1.5
log
@Apply Mumit Khan's patch to allow temporary file for process interconnection
@
text
@d737 1
a737 1
    fprintf (stream, _("Report bugs to bug-gnu-utils@@gnu.org\n"));
@


1.5.2.1
log
@This is a grab-bag of my stuff from the head branch.
Should have done it separately, I know.
- move bug report address to include file
- objcopy --redefine-sym
- update makefile dependencies (but use automake-000227)
- H.J. Lu's fix to readelf.c
@
text
@d737 1
a737 1
    fprintf (stream, _("Report bugs to %s\n"), REPORT_BUGS_TO);
@


1.5.2.2
log
@A mostly cosmetic tidy up of warnings and error message reporting.
@
text
@d2 1
a2 1
   Copyright 1997, 98, 99, 2000 Free Software Foundation, Inc.
d602 1
a602 1
      non_fatal (_("unknown format type `%s'"), name);
@


1.4
log
@	* windres.c (usage): Fix typo.
@
text
@d116 3
a118 1
#define OPTION_VERSION (OPTION_PREPROCESSOR + 1)
d131 2
d720 4
a723 1
  --language VAL              Set language when reading rc file\n"));
d787 1
d811 1
d902 8
d969 1
a969 1
				language);
@


1.3
log
@* windres.c: add verbose option
(main): process verbose option
* resrc.c (look_for_default): new.  Look for the default
preprocessor in a given location.
(read_rc_file): for foo/bar-windres, look for foo/bar-gcc,
foo/gcc (in case of foo/windres), and then gcc (the old default).
@
text
@d715 1
a715 1
  -v                          Verbose - tells you what it's doing\n\n
@


1.2
log
@1999-05-10  DJ Delorie  <dj@@cygnus.com>
	* windres.c (quot): Quote shell metacharacters in a string
	(main): quote parameters to cpp that might have metacharacters in
	them.  Allow -D as an alias for --define to allow for sharing make
	macros with gcc.
	* objdump.c (dump_reloc_set): don't core if howto->name is NULL
	* Makefile.am: Give rescoff.c a cpu-specific -D so it can set
	the correct BFD.
	* Makefile.in: ditto
	* rescoff.c (write_coff_file): Set the correct BFD
@
text
@d49 4
d129 1
d713 3
a715 1
  --define SYM[=VAL]          Define SYM when preprocessing rc file\n\
d804 1
a804 1
  while ((c = getopt_long (argc, argv, "i:o:I:O:F:D:", long_options,
d851 4
@


1.1
log
@Initial revision
@
text
@d727 28
d770 1
d797 1
a797 1
  while ((c = getopt_long (argc, argv, "i:o:I:O:F:", long_options,
d826 1
d830 3
a832 2
	      preprocargs = xmalloc (strlen (optarg) + 3);
	      sprintf (preprocargs, "-D%s", optarg);
d838 3
a840 2
	      n = xmalloc (strlen (preprocargs) + strlen (optarg) + 4);
	      sprintf (n, "%s -D%s", preprocargs, optarg);
d849 3
a851 2
	      preprocargs = xmalloc (strlen (optarg) + 3);
	      sprintf (preprocargs, "-I%s", optarg);
d857 3
a859 2
	      n = xmalloc (strlen (preprocargs) + strlen (optarg) + 4);
	      sprintf (n, "%s -I%s", preprocargs, optarg);
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

