head	1.142;
access;
symbols
	binutils-2_24-branch:1.138.0.2
	binutils-2_24-branchpoint:1.138
	binutils-2_21_1:1.77.2.1
	binutils-2_23_2:1.117
	binutils-2_23_1:1.117
	binutils-2_23:1.117
	binutils-2_23-branch:1.117.0.2
	binutils-2_23-branchpoint:1.117
	binutils-2_22_branch:1.100.0.4
	binutils-2_22:1.100
	binutils-2_22-branch:1.100.0.2
	binutils-2_22-branchpoint:1.100
	binutils-2_21:1.77
	binutils-2_21-branch:1.77.0.2
	binutils-2_21-branchpoint:1.77
	binutils-2_20_1:1.53.2.2
	binutils-2_20:1.53.2.2
	binutils-arc-20081103-branch:1.41.0.4
	binutils-arc-20081103-branchpoint:1.41
	binutils-2_20-branch:1.53.0.2
	binutils-2_20-branchpoint:1.53
	dje-cgen-play1-branch:1.47.0.2
	dje-cgen-play1-branchpoint:1.47
	arc-20081103-branch:1.41.0.2
	arc-20081103-branchpoint:1.41
	binutils-2_19_1:1.38.2.2
	binutils-2_19:1.38.2.2
	binutils-2_19-branch:1.38.0.2
	binutils-2_19-branchpoint:1.38
	binutils-2_18:1.15
	binutils-2_18-branch:1.15.0.2
	binutils-2_18-branchpoint:1.15
	binutils-csl-coldfire-4_1-32:1.4
	binutils-csl-sourcerygxx-4_1-32:1.4
	binutils-csl-innovasic-fido-3_4_4-33:1.4
	binutils-csl-coldfire-4_1-30:1.4
	binutils-csl-sourcerygxx-4_1-30:1.4
	binutils-csl-coldfire-4_1-28:1.4
	binutils-csl-sourcerygxx-4_1-29:1.4
	binutils-csl-sourcerygxx-4_1-28:1.4
	binutils-csl-arm-2006q3-27:1.4
	binutils-csl-sourcerygxx-4_1-27:1.4
	binutils-csl-arm-2006q3-26:1.4
	binutils-csl-sourcerygxx-4_1-26:1.4
	binutils-csl-sourcerygxx-4_1-25:1.4
	binutils-csl-sourcerygxx-4_1-24:1.4
	binutils-csl-sourcerygxx-4_1-23:1.4
	binutils-csl-sourcerygxx-4_1-21:1.4
	binutils-csl-arm-2006q3-21:1.4
	binutils-csl-sourcerygxx-4_1-22:1.4
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.4
	binutils-csl-sourcerygxx-4_1-20:1.4
	binutils-csl-arm-2006q3-19:1.4
	binutils-csl-sourcerygxx-4_1-19:1.4
	binutils-csl-sourcerygxx-4_1-18:1.4
	binutils-csl-renesas-4_1-9:1.4
	binutils-csl-renesas-4_1-8:1.4
	binutils-csl-renesas-4_1-7:1.4
	binutils-csl-renesas-4_1-6:1.4
	binutils-csl-sourcerygxx-4_1-17:1.4
	binutils-csl-sourcerygxx-4_1-14:1.4
	binutils-csl-sourcerygxx-4_1-15:1.4
	binutils-csl-sourcerygxx-4_1-13:1.4
	binutils-2_17:1.4
	binutils-csl-sourcerygxx-4_1-12:1.4
	binutils-csl-sourcerygxx-3_4_4-21:1.4
	binutils-csl-sourcerygxx-4_1-9:1.4
	binutils-csl-sourcerygxx-4_1-8:1.4
	binutils-csl-sourcerygxx-4_1-7:1.4
	binutils-csl-arm-2006q1-6:1.4
	binutils-csl-sourcerygxx-4_1-6:1.4
	binutils-csl-coldfire-4_1-11:1.4
	binutils-csl-sourcerygxx-3_4_4-19:1.4
	binutils-csl-coldfire-4_1-10:1.4
	binutils-csl-sourcerygxx-4_1-5:1.4
	binutils-csl-sourcerygxx-4_1-4:1.4
	binutils-csl-morpho-4_1-4:1.4
	binutils-csl-sourcerygxx-3_4_4-17:1.4
	binutils-2_17-branch:1.4.0.4
	binutils-2_17-branchpoint:1.4
	binutils-csl-2_17-branch:1.4.0.2
	binutils-csl-2_17-branchpoint:1.4
	binutils_latest_snapshot:1.142;
locks; strict;
comment	@ * @;


1.142
date	2013.10.09.16.37.44;	author nickc;	state Exp;
branches;
next	1.141;

1.141
date	2013.10.09.14.06.00;	author nickc;	state Exp;
branches;
next	1.140;

1.140
date	2013.10.01.10.32.54;	author jbglaw;	state Exp;
branches;
next	1.139;

1.139
date	2013.09.27.18.05.03;	author hjl;	state Exp;
branches;
next	1.138;

1.138
date	2013.09.12.09.14.46;	author nickc;	state Exp;
branches
	1.138.2.1;
next	1.137;

1.137
date	2013.09.10.16.19.08;	author nickc;	state Exp;
branches;
next	1.136;

1.136
date	2013.07.26.17.20.20;	author hjl;	state Exp;
branches;
next	1.135;

1.135
date	2013.05.29.00.39.32;	author ccoutant;	state Exp;
branches;
next	1.134;

1.134
date	2013.05.15.16.36.38;	author ccoutant;	state Exp;
branches;
next	1.133;

1.133
date	2013.05.02.10.18.38;	author nickc;	state Exp;
branches;
next	1.132;

1.132
date	2013.04.29.13.38.58;	author nickc;	state Exp;
branches;
next	1.131;

1.131
date	2013.04.08.14.59.04;	author tromey;	state Exp;
branches;
next	1.130;

1.130
date	2013.04.05.04.13.41;	author amodra;	state Exp;
branches;
next	1.129;

1.129
date	2013.03.29.20.42.48;	author hjl;	state Exp;
branches;
next	1.128;

1.128
date	2013.03.26.23.55.54;	author amodra;	state Exp;
branches;
next	1.127;

1.127
date	2013.03.26.22.51.12;	author nickc;	state Exp;
branches;
next	1.126;

1.126
date	2013.03.25.13.16.41;	author nickc;	state Exp;
branches;
next	1.125;

1.125
date	2013.03.01.19.24.07;	author ccoutant;	state Exp;
branches;
next	1.124;

1.124
date	2013.01.28.17.49.40;	author devans;	state Exp;
branches;
next	1.123;

1.123
date	2013.01.25.21.15.54;	author ccoutant;	state Exp;
branches;
next	1.122;

1.122
date	2013.01.24.20.24.44;	author devans;	state Exp;
branches;
next	1.121;

1.121
date	2012.10.24.01.59.39;	author ccoutant;	state Exp;
branches;
next	1.120;

1.120
date	2012.10.11.14.24.55;	author devans;	state Exp;
branches;
next	1.119;

1.119
date	2012.09.07.01.22.21;	author ccoutant;	state Exp;
branches;
next	1.118;

1.118
date	2012.08.02.13.42.55;	author hjl;	state Exp;
branches;
next	1.117;

1.117
date	2012.07.02.14.35.33;	author tromey;	state Exp;
branches;
next	1.116;

1.116
date	2012.06.08.19.07.33;	author jakub;	state Exp;
branches;
next	1.115;

1.115
date	2012.05.17.10.00.35;	author amodra;	state Exp;
branches;
next	1.114;

1.114
date	2012.05.17.07.19.35;	author amodra;	state Exp;
branches;
next	1.113;

1.113
date	2012.05.14.19.45.21;	author jwlemke;	state Exp;
branches;
next	1.112;

1.112
date	2012.05.11.18.18.34;	author ccoutant;	state Exp;
branches;
next	1.111;

1.111
date	2012.05.10.06.18.48;	author jakub;	state Exp;
branches;
next	1.110;

1.110
date	2012.05.07.15.04.59;	author tromey;	state Exp;
branches;
next	1.109;

1.109
date	2012.03.29.01.55.41;	author tromey;	state Exp;
branches;
next	1.108;

1.108
date	2012.02.15.18.32.30;	author ccoutant;	state Exp;
branches;
next	1.107;

1.107
date	2012.01.19.13.58.15;	author gingold;	state Exp;
branches;
next	1.106;

1.106
date	2012.01.19.11.34.44;	author gingold;	state Exp;
branches;
next	1.105;

1.105
date	2011.12.29.01.53.00;	author ian;	state Exp;
branches;
next	1.104;

1.104
date	2011.10.28.18.27.46;	author ian;	state Exp;
branches;
next	1.103;

1.103
date	2011.10.24.14.28.02;	author jkratoch;	state Exp;
branches;
next	1.102;

1.102
date	2011.10.13.15.33.32;	author nickc;	state Exp;
branches;
next	1.101;

1.101
date	2011.10.04.14.25.39;	author carlos;	state Exp;
branches;
next	1.100;

1.100
date	2011.09.18.16.50.17;	author hjl;	state Exp;
branches;
next	1.99;

1.99
date	2011.07.27.16.40.59;	author jkratoch;	state Exp;
branches;
next	1.98;

1.98
date	2011.07.26.21.31.37;	author jakub;	state Exp;
branches;
next	1.97;

1.97
date	2011.07.22.20.22.34;	author hjl;	state Exp;
branches;
next	1.96;

1.96
date	2011.06.22.15.03.18;	author jakub;	state Exp;
branches;
next	1.95;

1.95
date	2011.06.07.23.39.28;	author ccoutant;	state Exp;
branches;
next	1.94;

1.94
date	2011.05.25.15.10.56;	author jakub;	state Exp;
branches;
next	1.93;

1.93
date	2011.05.10.09.07.53;	author gingold;	state Exp;
branches;
next	1.92;

1.92
date	2011.05.03.08.43.14;	author jakub;	state Exp;
branches;
next	1.91;

1.91
date	2011.04.28.17.23.15;	author tromey;	state Exp;
branches;
next	1.90;

1.90
date	2011.04.28.07.27.30;	author jkratoch;	state Exp;
branches;
next	1.89;

1.89
date	2011.04.27.12.09.48;	author gingold;	state Exp;
branches;
next	1.88;

1.88
date	2011.03.25.18.01.58;	author nickc;	state Exp;
branches;
next	1.87;

1.87
date	2011.03.25.17.54.57;	author nickc;	state Exp;
branches;
next	1.86;

1.86
date	2011.03.25.15.15.52;	author nickc;	state Exp;
branches;
next	1.85;

1.85
date	2011.03.16.13.00.10;	author jakub;	state Exp;
branches;
next	1.84;

1.84
date	2011.02.23.08.52.33;	author ktietz;	state Exp;
branches;
next	1.83;

1.83
date	2011.01.26.10.27.46;	author jkratoch;	state Exp;
branches;
next	1.82;

1.82
date	2010.12.15.08.45.59;	author ktietz;	state Exp;
branches;
next	1.81;

1.81
date	2010.12.03.17.07.19;	author devans;	state Exp;
branches;
next	1.80;

1.80
date	2010.11.26.05.35.01;	author amodra;	state Exp;
branches;
next	1.79;

1.79
date	2010.11.21.21.27.15;	author hjl;	state Exp;
branches;
next	1.78;

1.78
date	2010.11.17.03.35.50;	author amodra;	state Exp;
branches;
next	1.77;

1.77
date	2010.10.09.05.52.28;	author hjl;	state Exp;
branches
	1.77.2.1;
next	1.76;

1.76
date	2010.09.09.12.08.59;	author jakub;	state Exp;
branches;
next	1.75;

1.75
date	2010.09.09.10.18.12;	author jakub;	state Exp;
branches;
next	1.74;

1.74
date	2010.09.03.15.54.30;	author jkratoch;	state Exp;
branches;
next	1.73;

1.73
date	2010.09.02.22.35.18;	author rth;	state Exp;
branches;
next	1.72;

1.72
date	2010.08.13.00.21.19;	author amodra;	state Exp;
branches;
next	1.71;

1.71
date	2010.08.03.10.24.18;	author gingold;	state Exp;
branches;
next	1.70;

1.70
date	2010.05.24.13.21.23;	author gingold;	state Exp;
branches;
next	1.69;

1.69
date	2010.05.06.21.32.04;	author hjl;	state Exp;
branches;
next	1.68;

1.68
date	2010.04.13.12.20.55;	author nickc;	state Exp;
branches;
next	1.67;

1.67
date	2010.04.09.14.40.13;	author nickc;	state Exp;
branches;
next	1.66;

1.66
date	2010.04.05.19.32.06;	author jakub;	state Exp;
branches;
next	1.65;

1.65
date	2010.04.05.19.29.43;	author jakub;	state Exp;
branches;
next	1.64;

1.64
date	2010.04.01.05.26.25;	author jakub;	state Exp;
branches;
next	1.63;

1.63
date	2010.03.02.16.44.34;	author drow;	state Exp;
branches;
next	1.62;

1.62
date	2010.02.08.19.27.34;	author jimb;	state Exp;
branches;
next	1.61;

1.61
date	2010.01.14.09.19.56;	author gingold;	state Exp;
branches;
next	1.60;

1.60
date	2009.12.11.13.42.05;	author nickc;	state Exp;
branches;
next	1.59;

1.59
date	2009.12.08.19.01.51;	author ccoutant;	state Exp;
branches;
next	1.58;

1.58
date	2009.12.03.12.28.36;	author nickc;	state Exp;
branches;
next	1.57;

1.57
date	2009.09.24.20.52.07;	author ccoutant;	state Exp;
branches;
next	1.56;

1.56
date	2009.09.10.13.40.44;	author nickc;	state Exp;
branches;
next	1.55;

1.55
date	2009.09.08.10.34.27;	author amodra;	state Exp;
branches;
next	1.54;

1.54
date	2009.09.07.18.07.02;	author jkratoch;	state Exp;
branches;
next	1.53;

1.53
date	2009.09.02.07.22.32;	author amodra;	state Exp;
branches
	1.53.2.1;
next	1.52;

1.52
date	2009.07.17.15.19.21;	author nickc;	state Exp;
branches;
next	1.51;

1.51
date	2009.07.14.16.57.18;	author jkratoch;	state Exp;
branches;
next	1.50;

1.50
date	2009.07.10.15.26.57;	author tromey;	state Exp;
branches;
next	1.49;

1.49
date	2009.07.06.14.45.56;	author gingold;	state Exp;
branches;
next	1.48;

1.48
date	2009.07.03.08.53.49;	author jakub;	state Exp;
branches;
next	1.47;

1.47
date	2009.06.24.10.37.34;	author nickc;	state Exp;
branches;
next	1.46;

1.46
date	2009.06.22.08.46.13;	author nickc;	state Exp;
branches;
next	1.45;

1.45
date	2009.04.24.18.28.59;	author ccoutant;	state Exp;
branches;
next	1.44;

1.44
date	2009.03.27.14.27.02;	author nickc;	state Exp;
branches;
next	1.43;

1.43
date	2009.03.20.00.05.37;	author hjl;	state Exp;
branches;
next	1.42;

1.42
date	2009.02.09.09.14.15;	author gingold;	state Exp;
branches;
next	1.41;

1.41
date	2008.10.06.16.27.33;	author nickc;	state Exp;
branches;
next	1.40;

1.40
date	2008.09.24.23.21.03;	author rth;	state Exp;
branches;
next	1.39;

1.39
date	2008.09.24.14.37.35;	author amodra;	state Exp;
branches;
next	1.38;

1.38
date	2008.08.01.14.21.29;	author hjl;	state Exp;
branches
	1.38.2.1;
next	1.37;

1.37
date	2008.07.30.04.34.56;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2008.07.10.01.32.23;	author csilvers;	state Exp;
branches;
next	1.35;

1.35
date	2008.04.11.09.04.17;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	2008.04.08.05.53.28;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2008.04.03.14.03.16;	author hjl;	state Exp;
branches;
next	1.32;

1.32
date	2008.03.03.10.19.01;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	2008.01.29.16.36.33;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	2008.01.29.15.45.00;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	2008.01.29.03.10.46;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2008.01.29.02.55.48;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2008.01.28.15.15.32;	author hjl;	state Exp;
branches;
next	1.26;

1.26
date	2008.01.25.16.18.40;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2008.01.14.14.53.47;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2008.01.14.12.26.57;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2008.01.04.09.53.41;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2007.11.21.17.50.41;	author hp;	state Exp;
branches;
next	1.21;

1.21
date	2007.11.21.11.58.00;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	2007.11.16.15.36.21;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2007.10.31.16.09.52;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2007.10.28.14.00.20;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2007.10.10.19.44.30;	author jimb;	state Exp;
branches;
next	1.16;

1.16
date	2007.10.10.19.43.43;	author jimb;	state Exp;
branches;
next	1.15;

1.15
date	2007.07.05.16.54.45;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2007.06.11.11.30.29;	author nathan;	state Exp;
branches;
next	1.13;

1.13
date	2007.04.26.14.46.59;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2007.04.09.14.36.59;	author drow;	state Exp;
branches;
next	1.11;

1.11
date	2007.02.06.16.47.47;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2007.02.06.15.15.13;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2007.01.31.08.42.45;	author nathan;	state Exp;
branches;
next	1.8;

1.8
date	2006.10.10.10.45.45;	author schwab;	state Exp;
branches;
next	1.7;

1.7
date	2006.08.08.09.43.10;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2006.06.30.13.38.57;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2006.05.15.14.50.38;	author hjl;	state Exp;
branches;
next	1.4;

1.4
date	2006.03.10.13.30.10;	author amodra;	state Exp;
branches;
next	1.3;

1.3
date	2006.03.03.18.29.40;	author jakub;	state Exp;
branches;
next	1.2;

1.2
date	2005.09.30.14.57.52;	author hjl;	state Exp;
branches;
next	1.1;

1.1
date	2005.09.30.14.55.05;	author hjl;	state Exp;
branches;
next	;

1.138.2.1
date	2013.10.09.16.37.28;	author nickc;	state Exp;
branches;
next	1.138.2.2;

1.138.2.2
date	2013.10.12.17.00.30;	author hjl;	state Exp;
branches;
next	;

1.77.2.1
date	2011.02.01.12.25.36;	author amodra;	state Exp;
branches;
next	;

1.53.2.1
date	2009.09.08.10.47.49;	author amodra;	state Exp;
branches;
next	1.53.2.2;

1.53.2.2
date	2009.09.10.13.42.08;	author nickc;	state Exp;
branches;
next	;

1.38.2.1
date	2008.09.24.14.39.47;	author amodra;	state Exp;
branches;
next	1.38.2.2;

1.38.2.2
date	2008.09.25.21.55.51;	author rth;	state Exp;
branches;
next	;


desc
@@


1.142
log
@Fix typo in previous delta.
@
text
@/* dwarf.c -- display DWARF contents of a BFD binary file
   Copyright 2005-2013 Free Software Foundation, Inc.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include "sysdep.h"
#include "libiberty.h"
#include "bfd.h"
#include "bfd_stdint.h"
#include "bucomm.h"
#include "elfcomm.h"
#include "elf/common.h"
#include "dwarf2.h"
#include "dwarf.h"
#include "gdb/gdb-index.h"

#if !HAVE_DECL_STRNLEN
size_t strnlen (const char *, size_t);
#endif

static const char *regname (unsigned int regno, int row);

static int have_frame_base;
static int need_base_address;

static unsigned int last_pointer_size = 0;
static int warned_about_missing_comp_units = FALSE;

static unsigned int num_debug_info_entries = 0;
static debug_info *debug_information = NULL;
/* Special value for num_debug_info_entries to indicate
   that the .debug_info section could not be loaded/parsed.  */
#define DEBUG_INFO_UNAVAILABLE  (unsigned int) -1

int eh_addr_size;

int do_debug_info;
int do_debug_abbrevs;
int do_debug_lines;
int do_debug_pubnames;
int do_debug_pubtypes;
int do_debug_aranges;
int do_debug_ranges;
int do_debug_frames;
int do_debug_frames_interp;
int do_debug_macinfo;
int do_debug_str;
int do_debug_loc;
int do_gdb_index;
int do_trace_info;
int do_trace_abbrevs;
int do_trace_aranges;
int do_debug_addr;
int do_debug_cu_index;
int do_wide;

int dwarf_cutoff_level = -1;
unsigned long dwarf_start_die;

int dwarf_check = 0;

/* Collection of CU/TU section sets from .debug_cu_index and .debug_tu_index
   sections.  For version 1 package files, each set is stored in SHNDX_POOL
   as a zero-terminated list of section indexes comprising one set of debug
   sections from a .dwo file.  */

static int cu_tu_indexes_read = 0;
static unsigned int *shndx_pool = NULL;
static unsigned int shndx_pool_size = 0;
static unsigned int shndx_pool_used = 0;

/* For version 2 package files, each set contains an array of section offsets
   and an array of section sizes, giving the offset and size of the
   contribution from a CU or TU within one of the debug sections.
   When displaying debug info from a package file, we need to use these
   tables to locate the corresponding contributions to each section.  */

struct cu_tu_set
{
  uint64_t signature;
  dwarf_vma section_offsets[DW_SECT_MAX];
  size_t section_sizes[DW_SECT_MAX];
};

static int cu_count = 0;
static int tu_count = 0;
static struct cu_tu_set *cu_sets = NULL;
static struct cu_tu_set *tu_sets = NULL;

static void load_cu_tu_indexes (void *file);

/* Values for do_debug_lines.  */
#define FLAG_DEBUG_LINES_RAW	 1
#define FLAG_DEBUG_LINES_DECODED 2

static int
size_of_encoded_value (int encoding)
{
  switch (encoding & 0x7)
    {
    default:	/* ??? */
    case 0:	return eh_addr_size;
    case 2:	return 2;
    case 3:	return 4;
    case 4:	return 8;
    }
}

static dwarf_vma
get_encoded_value (unsigned char *data,
		   int encoding,
		   struct dwarf_section *section)
{
  int size = size_of_encoded_value (encoding);
  dwarf_vma val;

  if (encoding & DW_EH_PE_signed)
    val = byte_get_signed (data, size);
  else
    val = byte_get (data, size);

  if ((encoding & 0x70) == DW_EH_PE_pcrel)
    val += section->address + (data - section->start);
  return val;
}

#if __STDC_VERSION__ >= 199901L || (defined(__GNUC__) && __GNUC__ >= 2)
#ifndef __MINGW32__
#define  DWARF_VMA_FMT       "ll"
#define  DWARF_VMA_FMT_LONG  "%16.16llx"
#else
#define  DWARF_VMA_FMT       "I64"
#define  DWARF_VMA_FMT_LONG  "%016I64x"
#endif
#else
#define  DWARF_VMA_FMT       "l"
#define  DWARF_VMA_FMT_LONG  "%16.16lx"
#endif

/* Convert a dwarf vma value into a string.  Returns a pointer to a static
   buffer containing the converted VALUE.  The value is converted according
   to the printf formating character FMTCH.  If NUM_BYTES is non-zero then
   it specifies the maximum number of bytes to be displayed in the converted
   value and FMTCH is ignored - hex is always used.  */

static const char *
dwarf_vmatoa_1 (const char *fmtch, dwarf_vma value, unsigned num_bytes)
{
  /* As dwarf_vmatoa is used more then once in a printf call
     for output, we are cycling through an fixed array of pointers
     for return address.  */
  static int buf_pos = 0;
  static struct dwarf_vmatoa_buf
  {
    char place[64];
  } buf[16];
  char *ret;

  ret = buf[buf_pos++].place;
  buf_pos %= ARRAY_SIZE (buf);

  if (num_bytes)
    {
      /* Printf does not have a way of specifiying a maximum field width for an
	 integer value, so we print the full value into a buffer and then select
	 the precision we need.  */
      snprintf (ret, sizeof (buf[0].place), DWARF_VMA_FMT_LONG, value);
      if (num_bytes > 8)
	num_bytes = 8;
      return ret + (16 - 2 * num_bytes);
    }
  else
    {
      char fmt[32];

      sprintf (fmt, "%%%s%s", DWARF_VMA_FMT, fmtch);
      snprintf (ret, sizeof (buf[0].place), fmt, value);
      return ret;
    }
}

static inline const char *
dwarf_vmatoa (const char * fmtch, dwarf_vma value)
{
  return dwarf_vmatoa_1 (fmtch, value, 0);
}

/* Print a dwarf_vma value (typically an address, offset or length) in
   hexadecimal format, followed by a space.  The length of the VALUE (and
   hence the precision displayed) is determined by the NUM_BYTES parameter.  */

static void
print_dwarf_vma (dwarf_vma value, unsigned num_bytes)
{
  printf ("%s ", dwarf_vmatoa_1 (NULL, value, num_bytes));
}

/* Format a 64-bit value, given as two 32-bit values, in hex.
   For reentrancy, this uses a buffer provided by the caller.  */

static const char *
dwarf_vmatoa64 (dwarf_vma hvalue, dwarf_vma lvalue, char *buf,
		unsigned int buf_len)
{
  int len = 0;

  if (hvalue == 0)
    snprintf (buf, buf_len, "%" DWARF_VMA_FMT "x", lvalue);
  else
    {
      len = snprintf (buf, buf_len, "%" DWARF_VMA_FMT "x", hvalue);
      snprintf (buf + len, buf_len - len,
		"%08" DWARF_VMA_FMT "x", lvalue);
    }

  return buf;
}

/* Read in a LEB128 encoded value starting at address DATA.
   If SIGN is true, return a signed LEB128 value.
   If LENGTH_RETURN is not NULL, return in it the number of bytes read.
   No bytes will be read at address END or beyond.  */

dwarf_vma
read_leb128 (unsigned char *data,
	     unsigned int *length_return,
	     bfd_boolean sign,
	     const unsigned char * const end)
{
  dwarf_vma result = 0;
  unsigned int num_read = 0;
  unsigned int shift = 0;
  unsigned char byte = 0;

  while (data < end)
    {
      byte = *data++;
      num_read++;

      result |= ((dwarf_vma) (byte & 0x7f)) << shift;

      shift += 7;
      if ((byte & 0x80) == 0)
	break;
    }

  if (length_return != NULL)
    *length_return = num_read;

  if (sign && (shift < 8 * sizeof (result)) && (byte & 0x40))
    result |= -1L << shift;

  return result;
}

/* Create a signed version to avoid painful typecasts.  */
static inline dwarf_signed_vma
read_sleb128 (unsigned char * data,
	      unsigned int *  length_return,
	      const unsigned char * const end)
{
  return (dwarf_signed_vma) read_leb128 (data, length_return, TRUE, end);
}

static inline dwarf_vma
read_uleb128 (unsigned char * data,
	      unsigned int *  length_return,
	      const unsigned char * const end)
{
  return read_leb128 (data, length_return, FALSE, end);
}

#define SAFE_BYTE_GET(VAL, PTR, AMOUNT, END)	\
  do						\
    {						\
      int dummy [sizeof (VAL) < (AMOUNT) ? -1 : 1] ATTRIBUTE_UNUSED ; \
      unsigned int amount = (AMOUNT);		\
      if (((PTR) + amount) >= (END))		\
	{					\
	  if ((PTR) < (END))			\
	    amount = (END) - (PTR);		\
	  else					\
	    amount = 0;				\
	}					\
      if (amount)				\
	VAL = byte_get ((PTR), amount);		\
      else					\
	VAL = 0;				\
    }						\
  while (0)

#define SAFE_BYTE_GET_AND_INC(VAL, PTR, AMOUNT, END)	\
  do							\
    {							\
      SAFE_BYTE_GET (VAL, PTR, AMOUNT, END);		\
      PTR += AMOUNT;					\
    }							\
  while (0)

#define SAFE_SIGNED_BYTE_GET(VAL, PTR, AMOUNT, END)	\
  do							\
    {							\
      unsigned int amount = (AMOUNT);			\
      if (((PTR) + amount) >= (END))			\
	{						\
	  if ((PTR) < (END))				\
	    amount = (END) - (PTR);			\
	  else						\
	    amount = 0;					\
	}						\
      if (amount)					\
	VAL = byte_get_signed ((PTR), amount);		\
      else						\
	VAL = 0;					\
    }							\
  while (0)

#define SAFE_SIGNED_BYTE_GET_AND_INC(VAL, PTR, AMOUNT, END)	\
  do								\
    {								\
      SAFE_SIGNED_BYTE_GET (VAL, PTR, AMOUNT, END);		\
      PTR += AMOUNT;						\
    }								\
  while (0)

#define SAFE_BYTE_GET64(PTR, HIGH, LOW, END)		\
  do							\
    {							\
      if (((PTR) + 8) <= (END))				\
	{						\
	  byte_get_64 ((PTR), (HIGH), (LOW));		\
	}						\
      else						\
	{						\
	  * (LOW) = * (HIGH) = 0;			\
	}						\
    }							\
  while (0)

typedef struct State_Machine_Registers
{
  dwarf_vma address;
  unsigned int file;
  unsigned int line;
  unsigned int column;
  int is_stmt;
  int basic_block;
  unsigned char op_index;
  unsigned char end_sequence;
/* This variable hold the number of the last entry seen
   in the File Table.  */
  unsigned int last_file_entry;
} SMR;

static SMR state_machine_regs;

static void
reset_state_machine (int is_stmt)
{
  state_machine_regs.address = 0;
  state_machine_regs.op_index = 0;
  state_machine_regs.file = 1;
  state_machine_regs.line = 1;
  state_machine_regs.column = 0;
  state_machine_regs.is_stmt = is_stmt;
  state_machine_regs.basic_block = 0;
  state_machine_regs.end_sequence = 0;
  state_machine_regs.last_file_entry = 0;
}

/* Handled an extend line op.
   Returns the number of bytes read.  */

static int
process_extended_line_op (unsigned char * data,
			  int is_stmt,
			  unsigned char * end)
{
  unsigned char op_code;
  unsigned int bytes_read;
  unsigned int len;
  unsigned char *name;
  unsigned char *orig_data = data;
  dwarf_vma adr;

  len = read_uleb128 (data, & bytes_read, end);
  data += bytes_read;

  if (len == 0 || data == end)
    {
      warn (_("badly formed extended line op encountered!\n"));
      return bytes_read;
    }

  len += bytes_read;
  op_code = *data++;

  printf (_("  Extended opcode %d: "), op_code);

  switch (op_code)
    {
    case DW_LNE_end_sequence:
      printf (_("End of Sequence\n\n"));
      reset_state_machine (is_stmt);
      break;

    case DW_LNE_set_address:
      SAFE_BYTE_GET (adr, data, len - bytes_read - 1, end);
      printf (_("set Address to 0x%s\n"), dwarf_vmatoa ("x", adr));
      state_machine_regs.address = adr;
      state_machine_regs.op_index = 0;
      break;

    case DW_LNE_define_file:
      printf (_("define new File Table entry\n"));
      printf (_("  Entry\tDir\tTime\tSize\tName\n"));
      printf ("   %d\t", ++state_machine_regs.last_file_entry);

      name = data;
      data += strnlen ((char *) data, end - data) + 1;
      printf ("%s\t", dwarf_vmatoa ("u", read_uleb128 (data, & bytes_read, end)));
      data += bytes_read;
      printf ("%s\t", dwarf_vmatoa ("u", read_uleb128 (data, & bytes_read, end)));
      data += bytes_read;
      printf ("%s\t", dwarf_vmatoa ("u", read_uleb128 (data, & bytes_read, end)));
      data += bytes_read;
      printf ("%s\n\n", name);

      if (((unsigned int) (data - orig_data) != len) || data == end)
        warn (_("DW_LNE_define_file: Bad opcode length\n"));
      break;

    case DW_LNE_set_discriminator:
      printf (_("set Discriminator to %s\n"),
	      dwarf_vmatoa ("u", read_uleb128 (data, & bytes_read, end)));
      break;

    /* HP extensions.  */
    case DW_LNE_HP_negate_is_UV_update:
      printf ("DW_LNE_HP_negate_is_UV_update\n");
      break;
    case DW_LNE_HP_push_context:
      printf ("DW_LNE_HP_push_context\n");
      break;
    case DW_LNE_HP_pop_context:
      printf ("DW_LNE_HP_pop_context\n");
      break;
    case DW_LNE_HP_set_file_line_column:
      printf ("DW_LNE_HP_set_file_line_column\n");
      break;
    case DW_LNE_HP_set_routine_name:
      printf ("DW_LNE_HP_set_routine_name\n");
      break;
    case DW_LNE_HP_set_sequence:
      printf ("DW_LNE_HP_set_sequence\n");
      break;
    case DW_LNE_HP_negate_post_semantics:
      printf ("DW_LNE_HP_negate_post_semantics\n");
      break;
    case DW_LNE_HP_negate_function_exit:
      printf ("DW_LNE_HP_negate_function_exit\n");
      break;
    case DW_LNE_HP_negate_front_end_logical:
      printf ("DW_LNE_HP_negate_front_end_logical\n");
      break;
    case DW_LNE_HP_define_proc:
      printf ("DW_LNE_HP_define_proc\n");
      break;
    case DW_LNE_HP_source_file_correlation:
      {
        unsigned char *edata = data + len - bytes_read - 1;

        printf ("DW_LNE_HP_source_file_correlation\n");

        while (data < edata)
          {
            unsigned int opc;

            opc = read_uleb128 (data, & bytes_read, edata);
            data += bytes_read;

            switch (opc)
              {
              case DW_LNE_HP_SFC_formfeed:
                printf ("    DW_LNE_HP_SFC_formfeed\n");
                break;
              case DW_LNE_HP_SFC_set_listing_line:
                printf ("    DW_LNE_HP_SFC_set_listing_line (%s)\n",
                        dwarf_vmatoa ("u",
                                      read_uleb128 (data, & bytes_read, edata)));
                data += bytes_read;
                break;
              case DW_LNE_HP_SFC_associate:
                printf ("    DW_LNE_HP_SFC_associate ");
                printf ("(%s",
                        dwarf_vmatoa ("u",
                                      read_uleb128 (data, & bytes_read, edata)));
                data += bytes_read;
                printf (",%s",
                        dwarf_vmatoa ("u",
                                      read_uleb128 (data, & bytes_read, edata)));
                data += bytes_read;
                printf (",%s)\n",
                        dwarf_vmatoa ("u",
                                      read_uleb128 (data, & bytes_read, edata)));
                data += bytes_read;
                break;
              default:
                printf (_("    UNKNOWN DW_LNE_HP_SFC opcode (%u)\n"), opc);
                data = edata;
                break;
              }
          }
      }
      break;

    default:
      {
        unsigned int rlen = len - bytes_read - 1;

        if (op_code >= DW_LNE_lo_user
            /* The test against DW_LNW_hi_user is redundant due to
               the limited range of the unsigned char data type used
               for op_code.  */
            /*&& op_code <= DW_LNE_hi_user*/)
          printf (_("user defined: "));
        else
          printf (_("UNKNOWN: "));
        printf (_("length %d ["), rlen);
        for (; rlen; rlen--)
          printf (" %02x", *data++);
        printf ("]\n");
      }
      break;
    }

  return len;
}

static const unsigned char *
fetch_indirect_string (dwarf_vma offset)
{
  struct dwarf_section *section = &debug_displays [str].section;

  if (section->start == NULL)
    return (const unsigned char *) _("<no .debug_str section>");

  /* DWARF sections under Mach-O have non-zero addresses.  */
  offset -= section->address;
  if (offset > section->size)
    {
      warn (_("DW_FORM_strp offset too big: %s\n"),
	    dwarf_vmatoa ("x", offset));
      return (const unsigned char *) _("<offset is too big>");
    }

  return (const unsigned char *) section->start + offset;
}

static const char *
fetch_indexed_string (dwarf_vma idx, struct cu_tu_set *this_set,
		      dwarf_vma offset_size, int dwo)
{
  enum dwarf_section_display_enum str_sec_idx = dwo ? str_dwo : str;
  enum dwarf_section_display_enum idx_sec_idx = dwo ? str_index_dwo : str_index;
  struct dwarf_section *index_section = &debug_displays [idx_sec_idx].section;
  struct dwarf_section *str_section = &debug_displays [str_sec_idx].section;
  dwarf_vma index_offset = idx * offset_size;
  dwarf_vma str_offset;

  if (index_section->start == NULL)
    return (dwo ? _("<no .debug_str_offsets.dwo section>")
		: _("<no .debug_str_offsets section>"));

  /* DWARF sections under Mach-O have non-zero addresses.  */
  index_offset -= index_section->address;
  if (this_set != NULL)
    index_offset += this_set->section_offsets [DW_SECT_STR_OFFSETS];
  if (index_offset > index_section->size)
    {
      warn (_("DW_FORM_GNU_str_index offset too big: %s\n"),
	    dwarf_vmatoa ("x", index_offset));
      return _("<index offset is too big>");
    }

  if (str_section->start == NULL)
    return (dwo ? _("<no .debug_str.dwo section>")
		: _("<no .debug_str section>"));

  str_offset = byte_get (index_section->start + index_offset, offset_size);
  str_offset -= str_section->address;
  if (str_offset > str_section->size)
    {
      warn (_("DW_FORM_GNU_str_index indirect offset too big: %s\n"),
	    dwarf_vmatoa ("x", str_offset));
      return _("<indirect index offset is too big>");
    }

  return (const char *) str_section->start + str_offset;
}

static const char *
fetch_indexed_value (dwarf_vma offset, dwarf_vma bytes)
{
  struct dwarf_section *section = &debug_displays [debug_addr].section;

  if (section->start == NULL)
    return (_("<no .debug_addr section>"));

  if (offset + bytes > section->size)
    {
      warn (_("Offset into section %s too big: %s\n"),
            section->name, dwarf_vmatoa ("x", offset));
      return "<offset too big>";
    }

  return dwarf_vmatoa ("x", byte_get (section->start + offset, bytes));
}


/* FIXME:  There are better and more efficient ways to handle
   these structures.  For now though, I just want something that
   is simple to implement.  */
typedef struct abbrev_attr
{
  unsigned long attribute;
  unsigned long form;
  struct abbrev_attr *next;
}
abbrev_attr;

typedef struct abbrev_entry
{
  unsigned long entry;
  unsigned long tag;
  int children;
  struct abbrev_attr *first_attr;
  struct abbrev_attr *last_attr;
  struct abbrev_entry *next;
}
abbrev_entry;

static abbrev_entry *first_abbrev = NULL;
static abbrev_entry *last_abbrev = NULL;

static void
free_abbrevs (void)
{
  abbrev_entry *abbrv;

  for (abbrv = first_abbrev; abbrv;)
    {
      abbrev_entry *next_abbrev = abbrv->next;
      abbrev_attr *attr;

      for (attr = abbrv->first_attr; attr;)
	{
	  abbrev_attr *next_attr = attr->next;

	  free (attr);
	  attr = next_attr;
	}

      free (abbrv);
      abbrv = next_abbrev;
    }

  last_abbrev = first_abbrev = NULL;
}

static void
add_abbrev (unsigned long number, unsigned long tag, int children)
{
  abbrev_entry *entry;

  entry = (abbrev_entry *) malloc (sizeof (*entry));
  if (entry == NULL)
    /* ugg */
    return;

  entry->entry      = number;
  entry->tag        = tag;
  entry->children   = children;
  entry->first_attr = NULL;
  entry->last_attr  = NULL;
  entry->next       = NULL;

  if (first_abbrev == NULL)
    first_abbrev = entry;
  else
    last_abbrev->next = entry;

  last_abbrev = entry;
}

static void
add_abbrev_attr (unsigned long attribute, unsigned long form)
{
  abbrev_attr *attr;

  attr = (abbrev_attr *) malloc (sizeof (*attr));
  if (attr == NULL)
    /* ugg */
    return;

  attr->attribute = attribute;
  attr->form      = form;
  attr->next      = NULL;

  if (last_abbrev->first_attr == NULL)
    last_abbrev->first_attr = attr;
  else
    last_abbrev->last_attr->next = attr;

  last_abbrev->last_attr = attr;
}

/* Processes the (partial) contents of a .debug_abbrev section.
   Returns NULL if the end of the section was encountered.
   Returns the address after the last byte read if the end of
   an abbreviation set was found.  */

static unsigned char *
process_abbrev_section (unsigned char *start, unsigned char *end)
{
  if (first_abbrev != NULL)
    return NULL;

  while (start < end)
    {
      unsigned int bytes_read;
      unsigned long entry;
      unsigned long tag;
      unsigned long attribute;
      int children;

      entry = read_uleb128 (start, & bytes_read, end);
      start += bytes_read;

      /* A single zero is supposed to end the section according
	 to the standard.  If there's more, then signal that to
	 the caller.  */
      if (start == end)
	return NULL;
      if (entry == 0)
	return start;

      tag = read_uleb128 (start, & bytes_read, end);
      start += bytes_read;
      if (start == end)
	return NULL;

      children = *start++;

      add_abbrev (entry, tag, children);

      do
	{
	  unsigned long form;

	  attribute = read_uleb128 (start, & bytes_read, end);
	  start += bytes_read;
	  if (start == end)
	    break;

	  form = read_uleb128 (start, & bytes_read, end);
	  start += bytes_read;
	  if (start == end)
	    break;

	  add_abbrev_attr (attribute, form);
	}
      while (attribute != 0);
    }

  /* Report the missing single zero which ends the section.  */
  error (_(".debug_abbrev section not zero terminated\n"));

  return NULL;
}

static const char *
get_TAG_name (unsigned long tag)
{
  const char *name = get_DW_TAG_name ((unsigned int)tag);

  if (name == NULL)
    {
      static char buffer[100];

      snprintf (buffer, sizeof (buffer), _("Unknown TAG value: %lx"), tag);
      return buffer;
    }

  return name;
}

static const char *
get_FORM_name (unsigned long form)
{
  const char *name;

  if (form == 0)
    return "DW_FORM value: 0";

  name = get_DW_FORM_name (form);
  if (name == NULL)
    {
      static char buffer[100];

      snprintf (buffer, sizeof (buffer), _("Unknown FORM value: %lx"), form);
      return buffer;
    }

  return name;
}

static unsigned char *
display_block (unsigned char *data,
	       dwarf_vma length,
	       const unsigned char * const end)
{
  dwarf_vma maxlen;

  printf (_(" %s byte block: "), dwarf_vmatoa ("u", length));

  maxlen = (dwarf_vma) (end - data);
  length = length > maxlen ? maxlen : length;

  while (length --)
    printf ("%lx ", (unsigned long) byte_get (data++, 1));

  return data;
}

static int
decode_location_expression (unsigned char * data,
			    unsigned int pointer_size,
			    unsigned int offset_size,
			    int dwarf_version,
			    dwarf_vma length,
			    dwarf_vma cu_offset,
			    struct dwarf_section * section)
{
  unsigned op;
  unsigned int bytes_read;
  dwarf_vma uvalue;
  dwarf_signed_vma svalue;
  unsigned char *end = data + length;
  int need_frame_base = 0;

  while (data < end)
    {
      op = *data++;

      switch (op)
	{
	case DW_OP_addr:
	  SAFE_BYTE_GET_AND_INC (uvalue, data, pointer_size, end);
	  printf ("DW_OP_addr: %s", dwarf_vmatoa ("x", uvalue));
	  break;
	case DW_OP_deref:
	  printf ("DW_OP_deref");
	  break;
	case DW_OP_const1u:
	  SAFE_BYTE_GET_AND_INC (uvalue, data, 1, end);
	  printf ("DW_OP_const1u: %lu", (unsigned long) uvalue);
	  break;
	case DW_OP_const1s:
	  SAFE_SIGNED_BYTE_GET_AND_INC (svalue, data, 1, end);
	  printf ("DW_OP_const1s: %ld", (long) svalue);
	  break;
	case DW_OP_const2u:
	  SAFE_BYTE_GET_AND_INC (uvalue, data, 2, end);
	  printf ("DW_OP_const2u: %lu", (unsigned long) uvalue);
	  break;
	case DW_OP_const2s:
	  SAFE_SIGNED_BYTE_GET_AND_INC (svalue, data, 2, end);
	  printf ("DW_OP_const2s: %ld", (long) svalue);
	  break;
	case DW_OP_const4u:
	  SAFE_BYTE_GET_AND_INC (uvalue, data, 4, end);
	  printf ("DW_OP_const4u: %lu", (unsigned long) uvalue);
	  break;
	case DW_OP_const4s:
	  SAFE_SIGNED_BYTE_GET_AND_INC (svalue, data, 4, end);
	  printf ("DW_OP_const4s: %ld", (long) svalue);
	  break;
	case DW_OP_const8u:
	  SAFE_BYTE_GET_AND_INC (uvalue, data, 4, end);
	  printf ("DW_OP_const8u: %lu ", (unsigned long) uvalue);
	  SAFE_BYTE_GET_AND_INC (uvalue, data, 4, end);
	  printf ("%lu", (unsigned long) uvalue);
	  break;
	case DW_OP_const8s:
	  SAFE_SIGNED_BYTE_GET_AND_INC (svalue, data, 4, end);
	  printf ("DW_OP_const8s: %ld ", (long) svalue);
	  SAFE_SIGNED_BYTE_GET_AND_INC (svalue, data, 4, end);
	  printf ("%ld", (long) svalue);
	  break;
	case DW_OP_constu:
	  printf ("DW_OP_constu: %s",
		  dwarf_vmatoa ("u", read_uleb128 (data, &bytes_read, end)));
	  data += bytes_read;
	  break;
	case DW_OP_consts:
	  printf ("DW_OP_consts: %s",
		  dwarf_vmatoa ("d", read_sleb128 (data, &bytes_read, end)));
	  data += bytes_read;
	  break;
	case DW_OP_dup:
	  printf ("DW_OP_dup");
	  break;
	case DW_OP_drop:
	  printf ("DW_OP_drop");
	  break;
	case DW_OP_over:
	  printf ("DW_OP_over");
	  break;
	case DW_OP_pick:
	  SAFE_BYTE_GET_AND_INC (uvalue, data, 1, end);
	  printf ("DW_OP_pick: %ld", (unsigned long) uvalue);
	  break;
	case DW_OP_swap:
	  printf ("DW_OP_swap");
	  break;
	case DW_OP_rot:
	  printf ("DW_OP_rot");
	  break;
	case DW_OP_xderef:
	  printf ("DW_OP_xderef");
	  break;
	case DW_OP_abs:
	  printf ("DW_OP_abs");
	  break;
	case DW_OP_and:
	  printf ("DW_OP_and");
	  break;
	case DW_OP_div:
	  printf ("DW_OP_div");
	  break;
	case DW_OP_minus:
	  printf ("DW_OP_minus");
	  break;
	case DW_OP_mod:
	  printf ("DW_OP_mod");
	  break;
	case DW_OP_mul:
	  printf ("DW_OP_mul");
	  break;
	case DW_OP_neg:
	  printf ("DW_OP_neg");
	  break;
	case DW_OP_not:
	  printf ("DW_OP_not");
	  break;
	case DW_OP_or:
	  printf ("DW_OP_or");
	  break;
	case DW_OP_plus:
	  printf ("DW_OP_plus");
	  break;
	case DW_OP_plus_uconst:
	  printf ("DW_OP_plus_uconst: %s",
		  dwarf_vmatoa ("u", read_uleb128 (data, &bytes_read, end)));
	  data += bytes_read;
	  break;
	case DW_OP_shl:
	  printf ("DW_OP_shl");
	  break;
	case DW_OP_shr:
	  printf ("DW_OP_shr");
	  break;
	case DW_OP_shra:
	  printf ("DW_OP_shra");
	  break;
	case DW_OP_xor:
	  printf ("DW_OP_xor");
	  break;
	case DW_OP_bra:
	  SAFE_SIGNED_BYTE_GET_AND_INC (svalue, data, 2, end);
	  printf ("DW_OP_bra: %ld", (long) svalue);
	  break;
	case DW_OP_eq:
	  printf ("DW_OP_eq");
	  break;
	case DW_OP_ge:
	  printf ("DW_OP_ge");
	  break;
	case DW_OP_gt:
	  printf ("DW_OP_gt");
	  break;
	case DW_OP_le:
	  printf ("DW_OP_le");
	  break;
	case DW_OP_lt:
	  printf ("DW_OP_lt");
	  break;
	case DW_OP_ne:
	  printf ("DW_OP_ne");
	  break;
	case DW_OP_skip:
	  SAFE_SIGNED_BYTE_GET_AND_INC (svalue, data, 2, end);
	  printf ("DW_OP_skip: %ld", (long) svalue);
	  break;

	case DW_OP_lit0:
	case DW_OP_lit1:
	case DW_OP_lit2:
	case DW_OP_lit3:
	case DW_OP_lit4:
	case DW_OP_lit5:
	case DW_OP_lit6:
	case DW_OP_lit7:
	case DW_OP_lit8:
	case DW_OP_lit9:
	case DW_OP_lit10:
	case DW_OP_lit11:
	case DW_OP_lit12:
	case DW_OP_lit13:
	case DW_OP_lit14:
	case DW_OP_lit15:
	case DW_OP_lit16:
	case DW_OP_lit17:
	case DW_OP_lit18:
	case DW_OP_lit19:
	case DW_OP_lit20:
	case DW_OP_lit21:
	case DW_OP_lit22:
	case DW_OP_lit23:
	case DW_OP_lit24:
	case DW_OP_lit25:
	case DW_OP_lit26:
	case DW_OP_lit27:
	case DW_OP_lit28:
	case DW_OP_lit29:
	case DW_OP_lit30:
	case DW_OP_lit31:
	  printf ("DW_OP_lit%d", op - DW_OP_lit0);
	  break;

	case DW_OP_reg0:
	case DW_OP_reg1:
	case DW_OP_reg2:
	case DW_OP_reg3:
	case DW_OP_reg4:
	case DW_OP_reg5:
	case DW_OP_reg6:
	case DW_OP_reg7:
	case DW_OP_reg8:
	case DW_OP_reg9:
	case DW_OP_reg10:
	case DW_OP_reg11:
	case DW_OP_reg12:
	case DW_OP_reg13:
	case DW_OP_reg14:
	case DW_OP_reg15:
	case DW_OP_reg16:
	case DW_OP_reg17:
	case DW_OP_reg18:
	case DW_OP_reg19:
	case DW_OP_reg20:
	case DW_OP_reg21:
	case DW_OP_reg22:
	case DW_OP_reg23:
	case DW_OP_reg24:
	case DW_OP_reg25:
	case DW_OP_reg26:
	case DW_OP_reg27:
	case DW_OP_reg28:
	case DW_OP_reg29:
	case DW_OP_reg30:
	case DW_OP_reg31:
	  printf ("DW_OP_reg%d (%s)", op - DW_OP_reg0,
		  regname (op - DW_OP_reg0, 1));
	  break;

	case DW_OP_breg0:
	case DW_OP_breg1:
	case DW_OP_breg2:
	case DW_OP_breg3:
	case DW_OP_breg4:
	case DW_OP_breg5:
	case DW_OP_breg6:
	case DW_OP_breg7:
	case DW_OP_breg8:
	case DW_OP_breg9:
	case DW_OP_breg10:
	case DW_OP_breg11:
	case DW_OP_breg12:
	case DW_OP_breg13:
	case DW_OP_breg14:
	case DW_OP_breg15:
	case DW_OP_breg16:
	case DW_OP_breg17:
	case DW_OP_breg18:
	case DW_OP_breg19:
	case DW_OP_breg20:
	case DW_OP_breg21:
	case DW_OP_breg22:
	case DW_OP_breg23:
	case DW_OP_breg24:
	case DW_OP_breg25:
	case DW_OP_breg26:
	case DW_OP_breg27:
	case DW_OP_breg28:
	case DW_OP_breg29:
	case DW_OP_breg30:
	case DW_OP_breg31:
	  printf ("DW_OP_breg%d (%s): %s",
		  op - DW_OP_breg0,
		  regname (op - DW_OP_breg0, 1),
		  dwarf_vmatoa ("d", read_sleb128 (data, &bytes_read, end)));
	  data += bytes_read;
	  break;

	case DW_OP_regx:
	  uvalue = read_uleb128 (data, &bytes_read, end);
	  data += bytes_read;
	  printf ("DW_OP_regx: %s (%s)",
		  dwarf_vmatoa ("u", uvalue), regname (uvalue, 1));
	  break;
	case DW_OP_fbreg:
	  need_frame_base = 1;
	  printf ("DW_OP_fbreg: %s",
		  dwarf_vmatoa ("d", read_sleb128 (data, &bytes_read, end)));
	  data += bytes_read;
	  break;
	case DW_OP_bregx:
	  uvalue = read_uleb128 (data, &bytes_read, end);
	  data += bytes_read;
	  printf ("DW_OP_bregx: %s (%s) %s",
		  dwarf_vmatoa ("u", uvalue), regname (uvalue, 1),
		  dwarf_vmatoa ("d", read_sleb128 (data, &bytes_read, end)));
	  data += bytes_read;
	  break;
	case DW_OP_piece:
	  printf ("DW_OP_piece: %s",
		  dwarf_vmatoa ("u", read_uleb128 (data, &bytes_read, end)));
	  data += bytes_read;
	  break;
	case DW_OP_deref_size:
	  SAFE_BYTE_GET_AND_INC (uvalue, data, 1, end);
	  printf ("DW_OP_deref_size: %ld", (long) uvalue);
	  break;
	case DW_OP_xderef_size:
	  SAFE_BYTE_GET_AND_INC (uvalue, data, 1, end);
	  printf ("DW_OP_xderef_size: %ld", (long) uvalue);
	  break;
	case DW_OP_nop:
	  printf ("DW_OP_nop");
	  break;

	  /* DWARF 3 extensions.  */
	case DW_OP_push_object_address:
	  printf ("DW_OP_push_object_address");
	  break;
	case DW_OP_call2:
	  /* XXX: Strictly speaking for 64-bit DWARF3 files
	     this ought to be an 8-byte wide computation.  */
	  SAFE_SIGNED_BYTE_GET_AND_INC (svalue, data, 2, end);
	  printf ("DW_OP_call2: <0x%s>",
		  dwarf_vmatoa ("x", svalue + cu_offset));
	  break;
	case DW_OP_call4:
	  /* XXX: Strictly speaking for 64-bit DWARF3 files
	     this ought to be an 8-byte wide computation.  */
	  SAFE_SIGNED_BYTE_GET_AND_INC (svalue, data, 4, end);
	  printf ("DW_OP_call4: <0x%s>",
		  dwarf_vmatoa ("x", svalue + cu_offset));
	  break;
	case DW_OP_call_ref:
	  /* XXX: Strictly speaking for 64-bit DWARF3 files
	     this ought to be an 8-byte wide computation.  */
	  if (dwarf_version == -1)
	    {
	      printf (_("(DW_OP_call_ref in frame info)"));
	      /* No way to tell where the next op is, so just bail.  */
	      return need_frame_base;
	    }
	  if (dwarf_version == 2)
	    {
	      SAFE_BYTE_GET_AND_INC (uvalue, data, pointer_size, end);
	    }
	  else
	    {
	      SAFE_BYTE_GET_AND_INC (uvalue, data, offset_size, end);
	    }
	  printf ("DW_OP_call_ref: <0x%s>", dwarf_vmatoa ("x", uvalue));
	  break;
	case DW_OP_form_tls_address:
	  printf ("DW_OP_form_tls_address");
	  break;
	case DW_OP_call_frame_cfa:
	  printf ("DW_OP_call_frame_cfa");
	  break;
	case DW_OP_bit_piece:
	  printf ("DW_OP_bit_piece: ");
	  printf (_("size: %s "),
		  dwarf_vmatoa ("u", read_uleb128 (data, &bytes_read, end)));
	  data += bytes_read;
	  printf (_("offset: %s "),
		  dwarf_vmatoa ("u", read_uleb128 (data, &bytes_read, end)));
	  data += bytes_read;
	  break;

	  /* DWARF 4 extensions.  */
	case DW_OP_stack_value:
	  printf ("DW_OP_stack_value");
	  break;

	case DW_OP_implicit_value:
	  printf ("DW_OP_implicit_value");
	  uvalue = read_uleb128 (data, &bytes_read, end);
	  data += bytes_read;
	  display_block (data, uvalue, end);
	  data += uvalue;
	  break;

	  /* GNU extensions.  */
	case DW_OP_GNU_push_tls_address:
	  printf (_("DW_OP_GNU_push_tls_address or DW_OP_HP_unknown"));
	  break;
	case DW_OP_GNU_uninit:
	  printf ("DW_OP_GNU_uninit");
	  /* FIXME: Is there data associated with this OP ?  */
	  break;
	case DW_OP_GNU_encoded_addr:
	  {
	    int encoding;
	    dwarf_vma addr;

	    encoding = *data++;
	    addr = get_encoded_value (data, encoding, section);
	    data += size_of_encoded_value (encoding);

	    printf ("DW_OP_GNU_encoded_addr: fmt:%02x addr:", encoding);
	    print_dwarf_vma (addr, pointer_size);
	  }
	  break;
	case DW_OP_GNU_implicit_pointer:
	  /* XXX: Strictly speaking for 64-bit DWARF3 files
	     this ought to be an 8-byte wide computation.  */
	  if (dwarf_version == -1)
	    {
	      printf (_("(DW_OP_GNU_implicit_pointer in frame info)"));
	      /* No way to tell where the next op is, so just bail.  */
	      return need_frame_base;
	    }
	  if (dwarf_version == 2)
	    {
	      SAFE_BYTE_GET_AND_INC (uvalue, data, pointer_size, end);
	    }
	  else
	    {
	      SAFE_BYTE_GET_AND_INC (uvalue, data, offset_size, end);
	    }
	  printf ("DW_OP_GNU_implicit_pointer: <0x%s> %s",
		  dwarf_vmatoa ("x", uvalue),
		  dwarf_vmatoa ("d", read_sleb128 (data,
						   &bytes_read, end)));
	  data += bytes_read;
	  break;
	case DW_OP_GNU_entry_value:
	  uvalue = read_uleb128 (data, &bytes_read, end);
	  data += bytes_read;
	  printf ("DW_OP_GNU_entry_value: (");
	  if (decode_location_expression (data, pointer_size, offset_size,
					  dwarf_version, uvalue,
					  cu_offset, section))
	    need_frame_base = 1;
	  putchar (')');
	  data += uvalue;
	  break;
	case DW_OP_GNU_const_type:
	  uvalue = read_uleb128 (data, &bytes_read, end);
	  data += bytes_read;
	  printf ("DW_OP_GNU_const_type: <0x%s> ",
		  dwarf_vmatoa ("x", cu_offset + uvalue));
	  SAFE_BYTE_GET_AND_INC (uvalue, data, 1, end);
	  display_block (data, uvalue, end);
	  data += uvalue;
	  break;
	case DW_OP_GNU_regval_type:
	  uvalue = read_uleb128 (data, &bytes_read, end);
	  data += bytes_read;
	  printf ("DW_OP_GNU_regval_type: %s (%s)",
		  dwarf_vmatoa ("u", uvalue), regname (uvalue, 1));
	  uvalue = read_uleb128 (data, &bytes_read, end);
	  data += bytes_read;
	  printf (" <0x%s>", dwarf_vmatoa ("x", cu_offset + uvalue));
	  break;
	case DW_OP_GNU_deref_type:
	  SAFE_BYTE_GET_AND_INC (uvalue, data, 1, end);
	  printf ("DW_OP_GNU_deref_type: %ld", (long) uvalue);
	  uvalue = read_uleb128 (data, &bytes_read, end);
	  data += bytes_read;
	  printf (" <0x%s>", dwarf_vmatoa ("x", cu_offset + uvalue));
	  break;
	case DW_OP_GNU_convert:
	  uvalue = read_uleb128 (data, &bytes_read, end);
	  data += bytes_read;
	  printf ("DW_OP_GNU_convert <0x%s>",
		  dwarf_vmatoa ("x", uvalue ? cu_offset + uvalue : 0));
	  break;
	case DW_OP_GNU_reinterpret:
	  uvalue = read_uleb128 (data, &bytes_read, end);
	  data += bytes_read;
	  printf ("DW_OP_GNU_reinterpret <0x%s>",
		  dwarf_vmatoa ("x", uvalue ? cu_offset + uvalue : 0));
	  break;
	case DW_OP_GNU_parameter_ref:
	  SAFE_BYTE_GET_AND_INC (uvalue, data, 4, end);
	  printf ("DW_OP_GNU_parameter_ref: <0x%s>",
		  dwarf_vmatoa ("x", cu_offset + uvalue));
	  break;
        case DW_OP_GNU_addr_index:
          uvalue = read_uleb128 (data, &bytes_read, end);
          data += bytes_read;
          printf ("DW_OP_GNU_addr_index <0x%s>", dwarf_vmatoa ("x", uvalue));
          break;
        case DW_OP_GNU_const_index:
          uvalue = read_uleb128 (data, &bytes_read, end);
          data += bytes_read;
          printf ("DW_OP_GNU_const_index <0x%s>", dwarf_vmatoa ("x", uvalue));
          break;

	  /* HP extensions.  */
	case DW_OP_HP_is_value:
	  printf ("DW_OP_HP_is_value");
	  /* FIXME: Is there data associated with this OP ?  */
	  break;
	case DW_OP_HP_fltconst4:
	  printf ("DW_OP_HP_fltconst4");
	  /* FIXME: Is there data associated with this OP ?  */
	  break;
	case DW_OP_HP_fltconst8:
	  printf ("DW_OP_HP_fltconst8");
	  /* FIXME: Is there data associated with this OP ?  */
	  break;
	case DW_OP_HP_mod_range:
	  printf ("DW_OP_HP_mod_range");
	  /* FIXME: Is there data associated with this OP ?  */
	  break;
	case DW_OP_HP_unmod_range:
	  printf ("DW_OP_HP_unmod_range");
	  /* FIXME: Is there data associated with this OP ?  */
	  break;
	case DW_OP_HP_tls:
	  printf ("DW_OP_HP_tls");
	  /* FIXME: Is there data associated with this OP ?  */
	  break;

	  /* PGI (STMicroelectronics) extensions.  */
	case DW_OP_PGI_omp_thread_num:
	  /* Pushes the thread number for the current thread as it would be
	     returned by the standard OpenMP library function:
	     omp_get_thread_num().  The "current thread" is the thread for
	     which the expression is being evaluated.  */
	  printf ("DW_OP_PGI_omp_thread_num");
	  break;

	default:
	  if (op >= DW_OP_lo_user
	      && op <= DW_OP_hi_user)
	    printf (_("(User defined location op)"));
	  else
	    printf (_("(Unknown location op)"));
	  /* No way to tell where the next op is, so just bail.  */
	  return need_frame_base;
	}

      /* Separate the ops.  */
      if (data < end)
	printf ("; ");
    }

  return need_frame_base;
}

/* Find the CU or TU set corresponding to the given CU_OFFSET.
   This is used for DWARF package files.  */

static struct cu_tu_set *
find_cu_tu_set_v2 (dwarf_vma cu_offset, int do_types)
{
  struct cu_tu_set *p;
  unsigned int nsets;
  unsigned int dw_sect;

  if (do_types)
    {
      p = tu_sets;
      nsets = tu_count;
      dw_sect = DW_SECT_TYPES;
    }
  else
    {
      p = cu_sets;
      nsets = cu_count;
      dw_sect = DW_SECT_INFO;
    }
  while (nsets > 0)
    {
      if (p->section_offsets [dw_sect] == cu_offset)
	return p;
      p++;
      nsets--;
    }
  return NULL;
}

/* Add INC to HIGH_BITS:LOW_BITS.  */
static void
add64 (dwarf_vma * high_bits, dwarf_vma * low_bits, dwarf_vma inc)
{
  dwarf_vma tmp = * low_bits;

  tmp += inc;

  /* FIXME: There is probably a better way of handling this:

     We need to cope with dwarf_vma being a 32-bit or 64-bit
     type.  Plus regardless of its size LOW_BITS is meant to
     only hold 32-bits, so if there is overflow or wrap around
     we must propagate into HIGH_BITS.  */
  if (tmp < * low_bits)
    {
      ++ * high_bits;
    }
  else if (sizeof (tmp) > 8
	   && (tmp >> 31) > 1)
    {
      ++ * high_bits;
      tmp &= 0xFFFFFFFF;
    }

  * low_bits = tmp;
}

static unsigned char *
read_and_display_attr_value (unsigned long attribute,
			     unsigned long form,
			     unsigned char * data,
			     unsigned char * end,
			     dwarf_vma cu_offset,
			     dwarf_vma pointer_size,
			     dwarf_vma offset_size,
			     int dwarf_version,
			     debug_info * debug_info_p,
			     int do_loc,
			     struct dwarf_section * section,
			     struct cu_tu_set * this_set)
{
  dwarf_vma uvalue = 0;
  unsigned char *block_start = NULL;
  unsigned char * orig_data = data;
  unsigned int bytes_read;

  if (data == end)
    {
      warn (_("corrupt attribute\n"));
      return data;
    }

  switch (form)
    {
    default:
      break;

    case DW_FORM_ref_addr:
      if (dwarf_version == 2)
	SAFE_BYTE_GET_AND_INC (uvalue, data, pointer_size, end);
      else if (dwarf_version == 3 || dwarf_version == 4)
	SAFE_BYTE_GET_AND_INC (uvalue, data, offset_size, end);
      else
	error (_("Internal error: DWARF version is not 2, 3 or 4.\n"));

      break;

    case DW_FORM_addr:
      SAFE_BYTE_GET_AND_INC (uvalue, data, pointer_size, end);
      break;

    case DW_FORM_strp:
    case DW_FORM_sec_offset:
    case DW_FORM_GNU_ref_alt:
    case DW_FORM_GNU_strp_alt:
      SAFE_BYTE_GET_AND_INC (uvalue, data, offset_size, end);
      break;

    case DW_FORM_flag_present:
      uvalue = 1;
      break;

    case DW_FORM_ref1:
    case DW_FORM_flag:
    case DW_FORM_data1:
      SAFE_BYTE_GET_AND_INC (uvalue, data, 1, end);
      break;

    case DW_FORM_ref2:
    case DW_FORM_data2:
      SAFE_BYTE_GET_AND_INC (uvalue, data, 2, end);
      break;

    case DW_FORM_ref4:
    case DW_FORM_data4:
      SAFE_BYTE_GET_AND_INC (uvalue, data, 4, end);
      break;

    case DW_FORM_sdata:
      uvalue = read_sleb128 (data, & bytes_read, end);
      data += bytes_read;
      break;

    case DW_FORM_GNU_str_index:
      uvalue = read_uleb128 (data, & bytes_read, end);
      data += bytes_read;
      break;

    case DW_FORM_ref_udata:
    case DW_FORM_udata:
      uvalue = read_uleb128 (data, & bytes_read, end);
      data += bytes_read;
      break;

    case DW_FORM_indirect:
      form = read_uleb128 (data, & bytes_read, end);
      data += bytes_read;
      if (!do_loc)
	printf (" %s", get_FORM_name (form));
      return read_and_display_attr_value (attribute, form, data, end,
					  cu_offset, pointer_size,
					  offset_size, dwarf_version,
					  debug_info_p, do_loc,
					  section, this_set);
    case DW_FORM_GNU_addr_index:
      uvalue = read_uleb128 (data, & bytes_read, end);
      data += bytes_read;
      break;
    }

  switch (form)
    {
    case DW_FORM_ref_addr:
      if (!do_loc)
	printf (" <0x%s>", dwarf_vmatoa ("x",uvalue));
      break;

    case DW_FORM_GNU_ref_alt:
      if (!do_loc)
	printf (" <alt 0x%s>", dwarf_vmatoa ("x",uvalue));
      break;

    case DW_FORM_ref1:
    case DW_FORM_ref2:
    case DW_FORM_ref4:
    case DW_FORM_ref_udata:
      if (!do_loc)
	printf (" <0x%s>", dwarf_vmatoa ("x", uvalue + cu_offset));
      break;

    case DW_FORM_data4:
    case DW_FORM_addr:
    case DW_FORM_sec_offset:
      if (!do_loc)
	printf (" 0x%s", dwarf_vmatoa ("x", uvalue));
      break;

    case DW_FORM_flag_present:
    case DW_FORM_flag:
    case DW_FORM_data1:
    case DW_FORM_data2:
    case DW_FORM_sdata:
    case DW_FORM_udata:
      if (!do_loc)
	printf (" %s", dwarf_vmatoa ("d", uvalue));
      break;

    case DW_FORM_ref8:
    case DW_FORM_data8:
      if (!do_loc)
	{
	  dwarf_vma high_bits;
	  dwarf_vma utmp;
	  char buf[64];

	  SAFE_BYTE_GET64 (data, &high_bits, &uvalue, end);
	  utmp = uvalue;
	  if (form == DW_FORM_ref8)
	    add64 (& high_bits, & utmp, cu_offset);
	  printf (" 0x%s",
		  dwarf_vmatoa64 (high_bits, utmp, buf, sizeof (buf)));
	}

      if ((do_loc || do_debug_loc || do_debug_ranges)
	  && num_debug_info_entries == 0)
	{
	  if (sizeof (uvalue) == 8)
	    SAFE_BYTE_GET (uvalue, data, 8, end);
	  else
	    error (_("DW_FORM_data8 is unsupported when sizeof (dwarf_vma) != 8\n"));
	}

      data += 8;
      break;

    case DW_FORM_string:
      if (!do_loc)
	printf (" %.*s", (int) (end - data), data);
      data += strnlen ((char *) data, end - data) + 1;
      break;

    case DW_FORM_block:
    case DW_FORM_exprloc:
      uvalue = read_uleb128 (data, & bytes_read, end);
      block_start = data + bytes_read;
      if (do_loc)
	data = block_start + uvalue;
      else
	data = display_block (block_start, uvalue, end);
      break;

    case DW_FORM_block1:
      SAFE_BYTE_GET (uvalue, data, 1, end);
      block_start = data + 1;
      if (do_loc)
	data = block_start + uvalue;
      else
	data = display_block (block_start, uvalue, end);
      break;

    case DW_FORM_block2:
      SAFE_BYTE_GET (uvalue, data, 2, end);
      block_start = data + 2;
      if (do_loc)
	data = block_start + uvalue;
      else
	data = display_block (block_start, uvalue, end);
      break;

    case DW_FORM_block4:
      SAFE_BYTE_GET (uvalue, data, 4, end);
      block_start = data + 4;
      if (do_loc)
	data = block_start + uvalue;
      else
	data = display_block (block_start, uvalue, end);
      break;

    case DW_FORM_strp:
      if (!do_loc)
	printf (_(" (indirect string, offset: 0x%s): %s"),
		dwarf_vmatoa ("x", uvalue),
		fetch_indirect_string (uvalue));
      break;

    case DW_FORM_GNU_str_index:
      if (!do_loc)
        {
          const char *suffix = strrchr (section->name, '.');
          int dwo = (suffix && strcmp (suffix, ".dwo") == 0) ? 1 : 0;

          printf (_(" (indexed string: 0x%s): %s"),
                  dwarf_vmatoa ("x", uvalue),
                  fetch_indexed_string (uvalue, this_set, offset_size, dwo));
        }
      break;

    case DW_FORM_GNU_strp_alt:
      if (!do_loc)
	printf (_(" (alt indirect string, offset: 0x%s)"),
		dwarf_vmatoa ("x", uvalue));
      break;

    case DW_FORM_indirect:
      /* Handled above.  */
      break;

    case DW_FORM_ref_sig8:
      if (!do_loc)
	{
	  dwarf_vma high_bits;
	  char buf[64];

	  SAFE_BYTE_GET64 (data, &high_bits, &uvalue, end);
	  printf (" signature: 0x%s",
		  dwarf_vmatoa64 (high_bits, uvalue, buf, sizeof (buf)));
	}
      data += 8;
      break;

    case DW_FORM_GNU_addr_index:
      if (!do_loc)
        printf (_(" (addr_index: 0x%s): %s"),
                dwarf_vmatoa ("x", uvalue),
                fetch_indexed_value (uvalue * pointer_size, pointer_size));
      break;

    default:
      warn (_("Unrecognized form: %lu\n"), form);
      break;
    }

  if ((do_loc || do_debug_loc || do_debug_ranges)
      && num_debug_info_entries == 0
      && debug_info_p != NULL)
    {
      switch (attribute)
	{
	case DW_AT_frame_base:
	  have_frame_base = 1;
	case DW_AT_location:
	case DW_AT_string_length:
	case DW_AT_return_addr:
	case DW_AT_data_member_location:
	case DW_AT_vtable_elem_location:
	case DW_AT_segment:
	case DW_AT_static_link:
	case DW_AT_use_location:
	case DW_AT_GNU_call_site_value:
	case DW_AT_GNU_call_site_data_value:
	case DW_AT_GNU_call_site_target:
	case DW_AT_GNU_call_site_target_clobbered:
    	  if ((dwarf_version < 4
	       && (form == DW_FORM_data4 || form == DW_FORM_data8))
	      || form == DW_FORM_sec_offset)
	    {
	      /* Process location list.  */
	      unsigned int lmax = debug_info_p->max_loc_offsets;
	      unsigned int num = debug_info_p->num_loc_offsets;

	      if (lmax == 0 || num >= lmax)
		{
		  lmax += 1024;
		  debug_info_p->loc_offsets = (dwarf_vma *)
                      xcrealloc (debug_info_p->loc_offsets,
				 lmax, sizeof (*debug_info_p->loc_offsets));
		  debug_info_p->have_frame_base = (int *)
                      xcrealloc (debug_info_p->have_frame_base,
				 lmax, sizeof (*debug_info_p->have_frame_base));
		  debug_info_p->max_loc_offsets = lmax;
		}
	      if (this_set != NULL)
	        uvalue += this_set->section_offsets [DW_SECT_LOC];
	      debug_info_p->loc_offsets [num] = uvalue;
	      debug_info_p->have_frame_base [num] = have_frame_base;
	      debug_info_p->num_loc_offsets++;
	    }
	  break;

	case DW_AT_low_pc:
	  if (need_base_address)
	    debug_info_p->base_address = uvalue;
	  break;

	case DW_AT_GNU_addr_base:
          debug_info_p->addr_base = uvalue;
	  break;

	case DW_AT_GNU_ranges_base:
          debug_info_p->ranges_base = uvalue;
	  break;

	case DW_AT_ranges:
    	  if ((dwarf_version < 4
	       && (form == DW_FORM_data4 || form == DW_FORM_data8))
	      || form == DW_FORM_sec_offset)
	    {
	      /* Process range list.  */
	      unsigned int lmax = debug_info_p->max_range_lists;
	      unsigned int num = debug_info_p->num_range_lists;

	      if (lmax == 0 || num >= lmax)
		{
		  lmax += 1024;
		  debug_info_p->range_lists = (dwarf_vma *)
                      xcrealloc (debug_info_p->range_lists,
				 lmax, sizeof (*debug_info_p->range_lists));
		  debug_info_p->max_range_lists = lmax;
		}
	      debug_info_p->range_lists [num] = uvalue;
	      debug_info_p->num_range_lists++;
	    }
	  break;

	default:
	  break;
	}
    }

  if (do_loc || attribute == 0)
    return data;

  /* For some attributes we can display further information.  */
  printf ("\t");

  switch (attribute)
    {
    case DW_AT_inline:
      switch (uvalue)
	{
	case DW_INL_not_inlined:
	  printf (_("(not inlined)"));
	  break;
	case DW_INL_inlined:
	  printf (_("(inlined)"));
	  break;
	case DW_INL_declared_not_inlined:
	  printf (_("(declared as inline but ignored)"));
	  break;
	case DW_INL_declared_inlined:
	  printf (_("(declared as inline and inlined)"));
	  break;
	default:
	  printf (_("  (Unknown inline attribute value: %s)"),
		  dwarf_vmatoa ("x", uvalue));
	  break;
	}
      break;

    case DW_AT_language:
      switch (uvalue)
	{
	  /* Ordered by the numeric value of these constants.  */
	case DW_LANG_C89:		printf ("(ANSI C)"); break;
	case DW_LANG_C:			printf ("(non-ANSI C)"); break;
	case DW_LANG_Ada83:		printf ("(Ada)"); break;
	case DW_LANG_C_plus_plus:	printf ("(C++)"); break;
	case DW_LANG_Cobol74:		printf ("(Cobol 74)"); break;
	case DW_LANG_Cobol85:		printf ("(Cobol 85)"); break;
	case DW_LANG_Fortran77:		printf ("(FORTRAN 77)"); break;
	case DW_LANG_Fortran90:		printf ("(Fortran 90)"); break;
	case DW_LANG_Pascal83:		printf ("(ANSI Pascal)"); break;
	case DW_LANG_Modula2:		printf ("(Modula 2)"); break;
	  /* DWARF 2.1 values.	*/
	case DW_LANG_Java:		printf ("(Java)"); break;
	case DW_LANG_C99:		printf ("(ANSI C99)"); break;
	case DW_LANG_Ada95:		printf ("(ADA 95)"); break;
	case DW_LANG_Fortran95:		printf ("(Fortran 95)"); break;
	  /* DWARF 3 values.  */
	case DW_LANG_PLI:		printf ("(PLI)"); break;
	case DW_LANG_ObjC:		printf ("(Objective C)"); break;
	case DW_LANG_ObjC_plus_plus:	printf ("(Objective C++)"); break;
	case DW_LANG_UPC:		printf ("(Unified Parallel C)"); break;
	case DW_LANG_D:			printf ("(D)"); break;
	  /* DWARF 4 values.  */
	case DW_LANG_Python:		printf ("(Python)"); break;
	  /* DWARF 5 values.  */
	case DW_LANG_Go:		printf ("(Go)"); break;
	  /* MIPS extension.  */
	case DW_LANG_Mips_Assembler:	printf ("(MIPS assembler)"); break;
	  /* UPC extension.  */
	case DW_LANG_Upc:		printf ("(Unified Parallel C)"); break;
	default:
	  if (uvalue >= DW_LANG_lo_user && uvalue <= DW_LANG_hi_user)
	    printf (_("(implementation defined: %s)"),
		    dwarf_vmatoa ("x", uvalue));
	  else
	    printf (_("(Unknown: %s)"), dwarf_vmatoa ("x", uvalue));
	  break;
	}
      break;

    case DW_AT_encoding:
      switch (uvalue)
	{
	case DW_ATE_void:		printf ("(void)"); break;
	case DW_ATE_address:		printf ("(machine address)"); break;
	case DW_ATE_boolean:		printf ("(boolean)"); break;
	case DW_ATE_complex_float:	printf ("(complex float)"); break;
	case DW_ATE_float:		printf ("(float)"); break;
	case DW_ATE_signed:		printf ("(signed)"); break;
	case DW_ATE_signed_char:	printf ("(signed char)"); break;
	case DW_ATE_unsigned:		printf ("(unsigned)"); break;
	case DW_ATE_unsigned_char:	printf ("(unsigned char)"); break;
	  /* DWARF 2.1 values:  */
	case DW_ATE_imaginary_float:	printf ("(imaginary float)"); break;
	case DW_ATE_decimal_float:	printf ("(decimal float)"); break;
	  /* DWARF 3 values:  */
	case DW_ATE_packed_decimal:	printf ("(packed_decimal)"); break;
	case DW_ATE_numeric_string:	printf ("(numeric_string)"); break;
	case DW_ATE_edited:		printf ("(edited)"); break;
	case DW_ATE_signed_fixed:	printf ("(signed_fixed)"); break;
	case DW_ATE_unsigned_fixed:	printf ("(unsigned_fixed)"); break;
	  /* HP extensions:  */
	case DW_ATE_HP_float80:		printf ("(HP_float80)"); break;
	case DW_ATE_HP_complex_float80:	printf ("(HP_complex_float80)"); break;
	case DW_ATE_HP_float128:	printf ("(HP_float128)"); break;
	case DW_ATE_HP_complex_float128:printf ("(HP_complex_float128)"); break;
	case DW_ATE_HP_floathpintel:	printf ("(HP_floathpintel)"); break;
	case DW_ATE_HP_imaginary_float80:	printf ("(HP_imaginary_float80)"); break;
	case DW_ATE_HP_imaginary_float128:	printf ("(HP_imaginary_float128)"); break;

	default:
	  if (uvalue >= DW_ATE_lo_user
	      && uvalue <= DW_ATE_hi_user)
	    printf (_("(user defined type)"));
	  else
	    printf (_("(unknown type)"));
	  break;
	}
      break;

    case DW_AT_accessibility:
      switch (uvalue)
	{
	case DW_ACCESS_public:		printf ("(public)"); break;
	case DW_ACCESS_protected:	printf ("(protected)"); break;
	case DW_ACCESS_private:		printf ("(private)"); break;
	default:
	  printf (_("(unknown accessibility)"));
	  break;
	}
      break;

    case DW_AT_visibility:
      switch (uvalue)
	{
	case DW_VIS_local:		printf ("(local)"); break;
	case DW_VIS_exported:		printf ("(exported)"); break;
	case DW_VIS_qualified:		printf ("(qualified)"); break;
	default:			printf (_("(unknown visibility)")); break;
	}
      break;

    case DW_AT_virtuality:
      switch (uvalue)
	{
	case DW_VIRTUALITY_none:	printf ("(none)"); break;
	case DW_VIRTUALITY_virtual:	printf ("(virtual)"); break;
	case DW_VIRTUALITY_pure_virtual:printf ("(pure_virtual)"); break;
	default:			printf (_("(unknown virtuality)")); break;
	}
      break;

    case DW_AT_identifier_case:
      switch (uvalue)
	{
	case DW_ID_case_sensitive:	printf ("(case_sensitive)"); break;
	case DW_ID_up_case:		printf ("(up_case)"); break;
	case DW_ID_down_case:		printf ("(down_case)"); break;
	case DW_ID_case_insensitive:	printf ("(case_insensitive)"); break;
	default:			printf (_("(unknown case)")); break;
	}
      break;

    case DW_AT_calling_convention:
      switch (uvalue)
	{
	case DW_CC_normal:	printf ("(normal)"); break;
	case DW_CC_program:	printf ("(program)"); break;
	case DW_CC_nocall:	printf ("(nocall)"); break;
	default:
	  if (uvalue >= DW_CC_lo_user
	      && uvalue <= DW_CC_hi_user)
	    printf (_("(user defined)"));
	  else
	    printf (_("(unknown convention)"));
	}
      break;

    case DW_AT_ordering:
      switch (uvalue)
	{
	case -1: printf (_("(undefined)")); break;
	case 0:  printf ("(row major)"); break;
	case 1:  printf ("(column major)"); break;
	}
      break;

    case DW_AT_frame_base:
      have_frame_base = 1;
    case DW_AT_location:
    case DW_AT_string_length:
    case DW_AT_return_addr:
    case DW_AT_data_member_location:
    case DW_AT_vtable_elem_location:
    case DW_AT_segment:
    case DW_AT_static_link:
    case DW_AT_use_location:
    case DW_AT_GNU_call_site_value:
    case DW_AT_GNU_call_site_data_value:
    case DW_AT_GNU_call_site_target:
    case DW_AT_GNU_call_site_target_clobbered:
      if ((dwarf_version < 4
           && (form == DW_FORM_data4 || form == DW_FORM_data8))
	  || form == DW_FORM_sec_offset)
	printf (_("(location list)"));
      /* Fall through.  */
    case DW_AT_allocated:
    case DW_AT_associated:
    case DW_AT_data_location:
    case DW_AT_stride:
    case DW_AT_upper_bound:
    case DW_AT_lower_bound:
      if (block_start)
	{
	  int need_frame_base;

	  printf ("(");
	  need_frame_base = decode_location_expression (block_start,
							pointer_size,
							offset_size,
							dwarf_version,
							uvalue,
							cu_offset, section);
	  printf (")");
	  if (need_frame_base && !have_frame_base)
	    printf (_(" [without DW_AT_frame_base]"));
	}
      break;

    case DW_AT_import:
      {
	if (form == DW_FORM_ref_sig8
	    || form == DW_FORM_GNU_ref_alt)
          break;

	if (form == DW_FORM_ref1
	    || form == DW_FORM_ref2
	    || form == DW_FORM_ref4
	    || form == DW_FORM_ref_udata)
	  uvalue += cu_offset;

	if (uvalue >= section->size)
	  warn (_("Offset %s used as value for DW_AT_import attribute of DIE at offset %lx is too big.\n"),
		dwarf_vmatoa ("x", uvalue),
		(unsigned long) (orig_data - section->start));
	else
	  {
	    unsigned long abbrev_number;
	    abbrev_entry * entry;

	    abbrev_number = read_uleb128 (section->start + uvalue, NULL, end);

	    printf (_("[Abbrev Number: %ld"), abbrev_number);
	    /* Don't look up abbrev for DW_FORM_ref_addr, as it very often will
	       use different abbrev table, and we don't track .debug_info chunks
	       yet.  */
	    if (form != DW_FORM_ref_addr)
	      {
		for (entry = first_abbrev; entry != NULL; entry = entry->next)
		  if (entry->entry == abbrev_number)
		    break;
		if (entry != NULL)
		  printf (" (%s)", get_TAG_name (entry->tag));
	      }
	    printf ("]");
	  }
      }
      break;

    default:
      break;
    }

  return data;
}

static const char *
get_AT_name (unsigned long attribute)
{
  const char *name;

  if (attribute == 0)
    return "DW_AT value: 0";

  /* One value is shared by the MIPS and HP extensions:  */
  if (attribute == DW_AT_MIPS_fde)
    return "DW_AT_MIPS_fde or DW_AT_HP_unmodifiable";

  name = get_DW_AT_name (attribute);

  if (name == NULL)
    {
      static char buffer[100];

      snprintf (buffer, sizeof (buffer), _("Unknown AT value: %lx"),
		attribute);
      return buffer;
    }

  return name;
}

static unsigned char *
read_and_display_attr (unsigned long attribute,
		       unsigned long form,
		       unsigned char * data,
		       unsigned char * end,
		       dwarf_vma cu_offset,
		       dwarf_vma pointer_size,
		       dwarf_vma offset_size,
		       int dwarf_version,
		       debug_info * debug_info_p,
		       int do_loc,
		       struct dwarf_section * section,
		       struct cu_tu_set * this_set)
{
  if (!do_loc)
    printf ("   %-18s:", get_AT_name (attribute));
  data = read_and_display_attr_value (attribute, form, data, end,
				      cu_offset, pointer_size, offset_size,
				      dwarf_version, debug_info_p,
				      do_loc, section, this_set);
  if (!do_loc)
    printf ("\n");
  return data;
}

/* Process the contents of a .debug_info section.  If do_loc is non-zero
   then we are scanning for location lists and we do not want to display
   anything to the user.  If do_types is non-zero, we are processing
   a .debug_types section instead of a .debug_info section.  */

static int
process_debug_info (struct dwarf_section *section,
		    void *file,
                    enum dwarf_section_display_enum abbrev_sec,
		    int do_loc,
		    int do_types)
{
  unsigned char *start = section->start;
  unsigned char *end = start + section->size;
  unsigned char *section_begin;
  unsigned int unit;
  unsigned int num_units = 0;

  if ((do_loc || do_debug_loc || do_debug_ranges)
      && num_debug_info_entries == 0
      && ! do_types)
    {
      dwarf_vma length;

      /* First scan the section to get the number of comp units.  */
      for (section_begin = start, num_units = 0; section_begin < end;
	   num_units ++)
	{
	  /* Read the first 4 bytes.  For a 32-bit DWARF section, this
	     will be the length.  For a 64-bit DWARF section, it'll be
	     the escape code 0xffffffff followed by an 8 byte length.  */
	  SAFE_BYTE_GET (length, section_begin, 4, end);

	  if (length == 0xffffffff)
	    {
	      SAFE_BYTE_GET (length, section_begin + 4, 8, end);
	      section_begin += length + 12;
	    }
	  else if (length >= 0xfffffff0 && length < 0xffffffff)
	    {
	      warn (_("Reserved length value (0x%s) found in section %s\n"),
		    dwarf_vmatoa ("x", length), section->name);
	      return 0;
	    }
	  else
	    section_begin += length + 4;

	  /* Negative values are illegal, they may even cause infinite
	     looping.  This can happen if we can't accurately apply
	     relocations to an object file.  */
	  if ((signed long) length <= 0)
	    {
	      warn (_("Corrupt unit length (0x%s) found in section %s\n"),
		    dwarf_vmatoa ("x", length), section->name);
	      return 0;
	    }
	}

      if (num_units == 0)
	{
	  error (_("No comp units in %s section ?"), section->name);
	  return 0;
	}

      /* Then allocate an array to hold the information.  */
      debug_information = (debug_info *) cmalloc (num_units,
                                                  sizeof (* debug_information));
      if (debug_information == NULL)
	{
	  error (_("Not enough memory for a debug info array of %u entries"),
		 num_units);
	  return 0;
	}
    }

  if (!do_loc)
    {
      if (dwarf_start_die == 0)
	printf (_("Contents of the %s section:\n\n"), section->name);

      load_debug_section (str, file);
      load_debug_section (str_dwo, file);
      load_debug_section (str_index, file);
      load_debug_section (str_index_dwo, file);
      load_debug_section (debug_addr, file);
    }

  load_debug_section (abbrev_sec, file);
  if (debug_displays [abbrev_sec].section.start == NULL)
    {
      warn (_("Unable to locate %s section!\n"),
	    debug_displays [abbrev_sec].section.name);
      return 0;
    }

  for (section_begin = start, unit = 0; start < end; unit++)
    {
      DWARF2_Internal_CompUnit compunit;
      unsigned char *hdrptr;
      unsigned char *tags;
      int level, last_level, saved_level;
      dwarf_vma cu_offset;
      unsigned int offset_size;
      int initial_length_size;
      dwarf_vma signature_high = 0;
      dwarf_vma signature_low = 0;
      dwarf_vma type_offset = 0;
      struct cu_tu_set *this_set;
      dwarf_vma abbrev_base;
      size_t abbrev_size;

      hdrptr = start;

      SAFE_BYTE_GET_AND_INC (compunit.cu_length, hdrptr, 4, end);

      if (compunit.cu_length == 0xffffffff)
	{
	  SAFE_BYTE_GET_AND_INC (compunit.cu_length, hdrptr, 8, end);
	  offset_size = 8;
	  initial_length_size = 12;
	}
      else
	{
	  offset_size = 4;
	  initial_length_size = 4;
	}

      SAFE_BYTE_GET_AND_INC (compunit.cu_version, hdrptr, 2, end);

      cu_offset = start - section_begin;

      this_set = find_cu_tu_set_v2 (cu_offset, do_types);

      SAFE_BYTE_GET_AND_INC (compunit.cu_abbrev_offset, hdrptr, offset_size, end);

      if (this_set == NULL)
	{
	  abbrev_base = 0;
	  abbrev_size = debug_displays [abbrev_sec].section.size;
	}
      else
	{
	  abbrev_base = this_set->section_offsets [DW_SECT_ABBREV];
	  abbrev_size = this_set->section_sizes [DW_SECT_ABBREV];
	}

      SAFE_BYTE_GET_AND_INC (compunit.cu_pointer_size, hdrptr, 1, end);

      if (do_types)
        {
	  SAFE_BYTE_GET64 (hdrptr, &signature_high, &signature_low, end);
	  hdrptr += 8;
	  SAFE_BYTE_GET_AND_INC (type_offset, hdrptr, offset_size, end);
        }

      if ((do_loc || do_debug_loc || do_debug_ranges)
	  && num_debug_info_entries == 0
	  && ! do_types)
	{
	  debug_information [unit].cu_offset = cu_offset;
	  debug_information [unit].pointer_size
	    = compunit.cu_pointer_size;
	  debug_information [unit].offset_size = offset_size;
	  debug_information [unit].dwarf_version = compunit.cu_version;
	  debug_information [unit].base_address = 0;
	  debug_information [unit].addr_base = DEBUG_INFO_UNAVAILABLE;
	  debug_information [unit].ranges_base = DEBUG_INFO_UNAVAILABLE;
	  debug_information [unit].loc_offsets = NULL;
	  debug_information [unit].have_frame_base = NULL;
	  debug_information [unit].max_loc_offsets = 0;
	  debug_information [unit].num_loc_offsets = 0;
	  debug_information [unit].range_lists = NULL;
	  debug_information [unit].max_range_lists= 0;
	  debug_information [unit].num_range_lists = 0;
	}

      if (!do_loc && dwarf_start_die == 0)
	{
	  printf (_("  Compilation Unit @@ offset 0x%s:\n"),
		  dwarf_vmatoa ("x", cu_offset));
	  printf (_("   Length:        0x%s (%s)\n"),
		  dwarf_vmatoa ("x", compunit.cu_length),
		  offset_size == 8 ? "64-bit" : "32-bit");
	  printf (_("   Version:       %d\n"), compunit.cu_version);
	  printf (_("   Abbrev Offset: 0x%s\n"),
		  dwarf_vmatoa ("x", compunit.cu_abbrev_offset));
	  printf (_("   Pointer Size:  %d\n"), compunit.cu_pointer_size);
	  if (do_types)
	    {
	      char buf[64];

	      printf (_("   Signature:     0x%s\n"),
		      dwarf_vmatoa64 (signature_high, signature_low,
				      buf, sizeof (buf)));
	      printf (_("   Type Offset:   0x%s\n"),
		      dwarf_vmatoa ("x", type_offset));
	    }
	  if (this_set != NULL)
	    {
	      dwarf_vma *offsets = this_set->section_offsets;
	      size_t *sizes = this_set->section_sizes;

	      printf (_("   Section contributions:\n"));
	      printf (_("    .debug_abbrev.dwo:       0x%s  0x%s\n"),
		      dwarf_vmatoa ("x", offsets [DW_SECT_ABBREV]),
		      dwarf_vmatoa ("x", sizes [DW_SECT_ABBREV]));
	      printf (_("    .debug_line.dwo:         0x%s  0x%s\n"),
		      dwarf_vmatoa ("x", offsets [DW_SECT_LINE]),
		      dwarf_vmatoa ("x", sizes [DW_SECT_LINE]));
	      printf (_("    .debug_loc.dwo:          0x%s  0x%s\n"),
		      dwarf_vmatoa ("x", offsets [DW_SECT_LOC]),
		      dwarf_vmatoa ("x", sizes [DW_SECT_LOC]));
	      printf (_("    .debug_str_offsets.dwo:  0x%s  0x%s\n"),
		      dwarf_vmatoa ("x", offsets [DW_SECT_STR_OFFSETS]),
		      dwarf_vmatoa ("x", sizes [DW_SECT_STR_OFFSETS]));
	    }
	}

      if (cu_offset + compunit.cu_length + initial_length_size
	  > section->size)
	{
	  warn (_("Debug info is corrupted, length of CU at %s"
	  	  " extends beyond end of section (length = %s)\n"),
		dwarf_vmatoa ("x", cu_offset),
		dwarf_vmatoa ("x", compunit.cu_length));
	  break;
	}
      tags = hdrptr;
      start += compunit.cu_length + initial_length_size;

      if (compunit.cu_version != 2
	  && compunit.cu_version != 3
	  && compunit.cu_version != 4)
	{
	  warn (_("CU at offset %s contains corrupt or "
		  "unsupported version number: %d.\n"),
		dwarf_vmatoa ("x", cu_offset), compunit.cu_version);
	  continue;
	}

      free_abbrevs ();

      /* Process the abbrevs used by this compilation unit. DWARF
	 sections under Mach-O have non-zero addresses.  */
      if (compunit.cu_abbrev_offset >= abbrev_size)
	warn (_("Debug info is corrupted, abbrev offset (%lx) is larger than abbrev section size (%lx)\n"),
	      (unsigned long) compunit.cu_abbrev_offset,
	      (unsigned long) abbrev_size);
      else
	process_abbrev_section
	  (((unsigned char *) debug_displays [abbrev_sec].section.start
	    + abbrev_base + compunit.cu_abbrev_offset),
	   ((unsigned char *) debug_displays [abbrev_sec].section.start
	    + abbrev_base + abbrev_size));

      level = 0;
      last_level = level;
      saved_level = -1;
      while (tags < start)
	{
	  unsigned int bytes_read;
	  unsigned long abbrev_number;
	  unsigned long die_offset;
	  abbrev_entry *entry;
	  abbrev_attr *attr;
	  int do_printing = 1;

	  die_offset = tags - section_begin;

	  abbrev_number = read_uleb128 (tags, & bytes_read, start);
	  tags += bytes_read;

	  /* A null DIE marks the end of a list of siblings or it may also be
	     a section padding.  */
	  if (abbrev_number == 0)
	    {
	      /* Check if it can be a section padding for the last CU.  */
	      if (level == 0 && start == end)
		{
		  unsigned char *chk;

		  for (chk = tags; chk < start; chk++)
		    if (*chk != 0)
		      break;
		  if (chk == start)
		    break;
		}

	      if (!do_loc && die_offset >= dwarf_start_die
		  && (dwarf_cutoff_level == -1
		      || level < dwarf_cutoff_level))
		printf (_(" <%d><%lx>: Abbrev Number: 0\n"),
			level, die_offset);

	      --level;
	      if (level < 0)
		{
		  static unsigned num_bogus_warns = 0;

		  if (num_bogus_warns < 3)
		    {
		      warn (_("Bogus end-of-siblings marker detected at offset %lx in %s section\n"),
			    die_offset, section->name);
		      num_bogus_warns ++;
		      if (num_bogus_warns == 3)
			warn (_("Further warnings about bogus end-of-sibling markers suppressed\n"));
		    }
		}
	      if (dwarf_start_die != 0 && level < saved_level)
		return 1;
	      continue;
	    }

	  if (!do_loc)
	    {
	      if (dwarf_start_die != 0 && die_offset < dwarf_start_die)
		do_printing = 0;
	      else
		{
		  if (dwarf_start_die != 0 && die_offset == dwarf_start_die)
		    saved_level = level;
		  do_printing = (dwarf_cutoff_level == -1
				 || level < dwarf_cutoff_level);
		  if (do_printing)
		    printf (_(" <%d><%lx>: Abbrev Number: %lu"),
			    level, die_offset, abbrev_number);
		  else if (dwarf_cutoff_level == -1
			   || last_level < dwarf_cutoff_level)
		    printf (_(" <%d><%lx>: ...\n"), level, die_offset);
		  last_level = level;
		}
	    }

	  /* Scan through the abbreviation list until we reach the
	     correct entry.  */
	  for (entry = first_abbrev;
	       entry && entry->entry != abbrev_number;
	       entry = entry->next)
	    continue;

	  if (entry == NULL)
	    {
	      if (!do_loc && do_printing)
		{
		  printf ("\n");
		  fflush (stdout);
		}
	      warn (_("DIE at offset %lx refers to abbreviation number %lu which does not exist\n"),
		    die_offset, abbrev_number);
	      return 0;
	    }

	  if (!do_loc && do_printing)
	    printf (" (%s)\n", get_TAG_name (entry->tag));

	  switch (entry->tag)
	    {
	    default:
	      need_base_address = 0;
	      break;
	    case DW_TAG_compile_unit:
	      need_base_address = 1;
	      break;
	    case DW_TAG_entry_point:
	    case DW_TAG_subprogram:
	      need_base_address = 0;
	      /* Assuming that there is no DW_AT_frame_base.  */
	      have_frame_base = 0;
	      break;
	    }

	  for (attr = entry->first_attr;
	       attr && attr->attribute;
	       attr = attr->next)
	    {
	      debug_info *arg;

	      if (! do_loc && do_printing)
		/* Show the offset from where the tag was extracted.  */
		printf ("    <%lx>", (unsigned long)(tags - section_begin));

	      arg = debug_information;
	      if (debug_information)
		arg += unit;

	      tags = read_and_display_attr (attr->attribute,
					    attr->form,
					    tags,
					    end,
					    cu_offset,
					    compunit.cu_pointer_size,
					    offset_size,
					    compunit.cu_version,
					    arg,
					    do_loc || ! do_printing,
					    section,
					    this_set);
	    }

 	  if (entry->children)
 	    ++level;
 	}
    }

  /* Set num_debug_info_entries here so that it can be used to check if
     we need to process .debug_loc and .debug_ranges sections.  */
  if ((do_loc || do_debug_loc || do_debug_ranges)
      && num_debug_info_entries == 0
      && ! do_types)
    num_debug_info_entries = num_units;

  if (!do_loc)
    printf ("\n");

  return 1;
}

/* Locate and scan the .debug_info section in the file and record the pointer
   sizes and offsets for the compilation units in it.  Usually an executable
   will have just one pointer size, but this is not guaranteed, and so we try
   not to make any assumptions.  Returns zero upon failure, or the number of
   compilation units upon success.  */

static unsigned int
load_debug_info (void * file)
{
  /* Reset the last pointer size so that we can issue correct error
     messages if we are displaying the contents of more than one section.  */
  last_pointer_size = 0;
  warned_about_missing_comp_units = FALSE;

  /* If we have already tried and failed to load the .debug_info
     section then do not bother to repeat the task.  */
  if (num_debug_info_entries == DEBUG_INFO_UNAVAILABLE)
    return 0;

  /* If we already have the information there is nothing else to do.  */
  if (num_debug_info_entries > 0)
    return num_debug_info_entries;

  /* If this is a DWARF package file, load the CU and TU indexes.  */
  load_cu_tu_indexes (file);

  if (load_debug_section (info, file)
      && process_debug_info (&debug_displays [info].section, file, abbrev, 1, 0))
    return num_debug_info_entries;
  else if (load_debug_section (info_dwo, file)
           && process_debug_info (&debug_displays [info_dwo].section, file,
                                  abbrev_dwo, 1, 0))
    return num_debug_info_entries;

  num_debug_info_entries = DEBUG_INFO_UNAVAILABLE;
  return 0;
}

/* Read a DWARF .debug_line section header starting at DATA.
   Upon success returns an updated DATA pointer and the LINFO
   structure and the END_OF_SEQUENCE pointer will be filled in.
   Otherwise returns NULL.  */

static unsigned char *
read_debug_line_header (struct dwarf_section * section,
			unsigned char * data,
			unsigned char * end,
			DWARF2_Internal_LineInfo * linfo,
			unsigned char ** end_of_sequence)
{
  unsigned char *hdrptr;
  unsigned int offset_size;
  unsigned int initial_length_size;

  /* Extract information from the Line Number Program Header.
     (section 6.2.4 in the Dwarf3 doc).  */
      hdrptr = data;

  /* Get and check the length of the block.  */
  SAFE_BYTE_GET_AND_INC (linfo->li_length, hdrptr, 4, end);

  if (linfo->li_length == 0xffffffff)
	{
	  /* This section is 64-bit DWARF 3.  */
      SAFE_BYTE_GET_AND_INC (linfo->li_length, hdrptr, 8, end);
	  offset_size = 8;
	  initial_length_size = 12;
	}
      else
	{
	  offset_size = 4;
	  initial_length_size = 4;
	}

  if (linfo->li_length + initial_length_size > section->size)
	{
      /* If the length is just a bias against the initial_length_size then
	 this means that the field has a relocation against it which has not
	 been applied.  (Ie we are dealing with an object file, not a linked
	 binary).  Do not complain but instead assume that the rest of the
	 section applies to this particular header.  */
      if (linfo->li_length == - initial_length_size)
	{
	  linfo->li_length = section->size - initial_length_size;
	}
      else
	{
	  warn (_("The line info appears to be corrupt - "
		  "the section is too small\n"));
	  return NULL;
	}
	}

  /* Get and check the version number.  */
  SAFE_BYTE_GET_AND_INC (linfo->li_version, hdrptr, 2, end);

  if (linfo->li_version != 2
      && linfo->li_version != 3
      && linfo->li_version != 4)
	{
	  warn (_("Only DWARF version 2, 3 and 4 line info is currently supported.\n"));
      return NULL;
	}

  SAFE_BYTE_GET_AND_INC (linfo->li_prologue_length, hdrptr, offset_size, end);
  SAFE_BYTE_GET_AND_INC (linfo->li_min_insn_length, hdrptr, 1, end);

  if (linfo->li_version >= 4)
	{
      SAFE_BYTE_GET_AND_INC (linfo->li_max_ops_per_insn, hdrptr, 1, end);

      if (linfo->li_max_ops_per_insn == 0)
	    {
	      warn (_("Invalid maximum operations per insn.\n"));
	  return NULL;
	    }
	}
      else
    linfo->li_max_ops_per_insn = 1;

  SAFE_BYTE_GET_AND_INC (linfo->li_default_is_stmt, hdrptr, 1, end);
  SAFE_BYTE_GET_AND_INC (linfo->li_line_base, hdrptr, 1, end);
  SAFE_BYTE_GET_AND_INC (linfo->li_line_range, hdrptr, 1, end);
  SAFE_BYTE_GET_AND_INC (linfo->li_opcode_base, hdrptr, 1, end);

      /* Sign extend the line base field.  */
  linfo->li_line_base <<= 24;
  linfo->li_line_base >>= 24;

  * end_of_sequence = data + linfo->li_length + initial_length_size;
  return hdrptr;
}

static int
display_debug_lines_raw (struct dwarf_section *section,
			 unsigned char *data,
                         unsigned char *end)
{
  unsigned char *start = section->start;

  printf (_("Raw dump of debug contents of section %s:\n\n"),
          section->name);

  while (data < end)
    {
      static DWARF2_Internal_LineInfo saved_linfo;
      DWARF2_Internal_LineInfo linfo;
      unsigned char *standard_opcodes;
      unsigned char *end_of_sequence;
      unsigned int last_dir_entry = 0;
      int i;

      if (const_strneq (section->name, ".debug_line.")
	  /* Note: the following does not apply to .debug_line.dwo sections.
	     These are full debug_line sections.  */
	  && strcmp (section->name, ".debug_line.dwo") != 0)
	{
	  /* Sections named .debug_line.<foo> are fragments of a .debug_line
	     section containing just the Line Number Statements.  They are
	     created by the assembler and intended to be used alongside gcc's
	     -ffunction-sections command line option.  When the linker's
	     garbage collection decides to discard a .text.<foo> section it
	     can then also discard the line number information in .debug_line.<foo>.

	     Since the section is a fragment it does not have the details
	     needed to fill out a LineInfo structure, so instead we use the
	     details from the last full debug_line section that we processed.  */
	  end_of_sequence = end;
	  standard_opcodes = NULL;
	  linfo = saved_linfo;
	  reset_state_machine (linfo.li_default_is_stmt);
	}
      else
	{
	  unsigned char * hdrptr;

	  if ((hdrptr = read_debug_line_header (section, data, end, & linfo,
						& end_of_sequence)) == NULL)
	    return 0;

	  printf (_("  Offset:                      0x%lx\n"), (long)(data - start));
	  printf (_("  Length:                      %ld\n"), (long) linfo.li_length);
	  printf (_("  DWARF Version:               %d\n"), linfo.li_version);
	  printf (_("  Prologue Length:             %d\n"), linfo.li_prologue_length);
	  printf (_("  Minimum Instruction Length:  %d\n"), linfo.li_min_insn_length);
	  if (linfo.li_version >= 4)
	    printf (_("  Maximum Ops per Instruction: %d\n"), linfo.li_max_ops_per_insn);
	  printf (_("  Initial value of 'is_stmt':  %d\n"), linfo.li_default_is_stmt);
	  printf (_("  Line Base:                   %d\n"), linfo.li_line_base);
	  printf (_("  Line Range:                  %d\n"), linfo.li_line_range);
	  printf (_("  Opcode Base:                 %d\n"), linfo.li_opcode_base);

	  reset_state_machine (linfo.li_default_is_stmt);

	  /* Display the contents of the Opcodes table.  */
	  standard_opcodes = hdrptr;

	  printf (_("\n Opcodes:\n"));

	  for (i = 1; i < linfo.li_opcode_base; i++)
	    printf (_("  Opcode %d has %d args\n"), i, standard_opcodes[i - 1]);

	  /* Display the contents of the Directory table.  */
	  data = standard_opcodes + linfo.li_opcode_base - 1;

	  if (*data == 0)
	    printf (_("\n The Directory Table is empty.\n"));
	  else
	    {
	      printf (_("\n The Directory Table (offset 0x%lx):\n"),
		      (long)(data - start));

	      while (*data != 0)
		{
		  printf ("  %d\t%s\n", ++last_dir_entry, data);

		  data += strnlen ((char *) data, end - data) + 1;
		}
	    }

	  /* Skip the NUL at the end of the table.  */
	  data++;

	  /* Display the contents of the File Name table.  */
	  if (*data == 0)
	    printf (_("\n The File Name Table is empty.\n"));
	  else
	    {
	      printf (_("\n The File Name Table (offset 0x%lx):\n"),
		      (long)(data - start));
	      printf (_("  Entry\tDir\tTime\tSize\tName\n"));

	      while (*data != 0)
		{
		  unsigned char *name;
		  unsigned int bytes_read;

		  printf ("  %d\t", ++state_machine_regs.last_file_entry);
		  name = data;
		  data += strnlen ((char *) data, end - data) + 1;

		  printf ("%s\t",
			  dwarf_vmatoa ("u", read_uleb128 (data, & bytes_read, end)));
		  data += bytes_read;
		  printf ("%s\t",
			  dwarf_vmatoa ("u", read_uleb128 (data, & bytes_read, end)));
		  data += bytes_read;
		  printf ("%s\t",
			  dwarf_vmatoa ("u", read_uleb128 (data, & bytes_read, end)));
		  data += bytes_read;
		  printf ("%s\n", name);

		  if (data == end)
		    {
		      warn (_("Corrupt file name table entry\n"));
		      break;
		    }
		}
	    }

	  /* Skip the NUL at the end of the table.  */
	  data++;
	  putchar ('\n');
	  saved_linfo = linfo;
	}

      /* Now display the statements.  */
      if (data >= end_of_sequence)
	printf (_(" No Line Number Statements.\n"));
      else
	{
	  printf (_(" Line Number Statements:\n"));

	  while (data < end_of_sequence)
	    {
	      unsigned char op_code;
	      dwarf_signed_vma adv;
	      dwarf_vma uladv;
	      unsigned int bytes_read;

	      printf ("  [0x%08lx]", (long)(data - start));

	      op_code = *data++;

	      if (op_code >= linfo.li_opcode_base)
		{
		  op_code -= linfo.li_opcode_base;
		  uladv = (op_code / linfo.li_line_range);
		  if (linfo.li_max_ops_per_insn == 1)
		    {
		      uladv *= linfo.li_min_insn_length;
		      state_machine_regs.address += uladv;
		      printf (_("  Special opcode %d: "
				"advance Address by %s to 0x%s"),
			      op_code, dwarf_vmatoa ("u", uladv),
			      dwarf_vmatoa ("x", state_machine_regs.address));
		    }
		  else
		    {
		      state_machine_regs.address
			+= ((state_machine_regs.op_index + uladv)
			    / linfo.li_max_ops_per_insn)
			* linfo.li_min_insn_length;
		      state_machine_regs.op_index
			= (state_machine_regs.op_index + uladv)
			% linfo.li_max_ops_per_insn;
		      printf (_("  Special opcode %d: "
				"advance Address by %s to 0x%s[%d]"),
			      op_code, dwarf_vmatoa ("u", uladv),
			      dwarf_vmatoa ("x", state_machine_regs.address),
			      state_machine_regs.op_index);
		    }
		  adv = (op_code % linfo.li_line_range) + linfo.li_line_base;
		  state_machine_regs.line += adv;
		  printf (_(" and Line by %s to %d\n"),
			  dwarf_vmatoa ("d", adv), state_machine_regs.line);
		}
	      else switch (op_code)
		     {
		     case DW_LNS_extended_op:
		       data += process_extended_line_op (data, linfo.li_default_is_stmt, end);
		       break;

		     case DW_LNS_copy:
		       printf (_("  Copy\n"));
		       break;

		     case DW_LNS_advance_pc:
		       uladv = read_uleb128 (data, & bytes_read, end);
		       data += bytes_read;
		       if (linfo.li_max_ops_per_insn == 1)
			 {
			   uladv *= linfo.li_min_insn_length;
			   state_machine_regs.address += uladv;
			   printf (_("  Advance PC by %s to 0x%s\n"),
				   dwarf_vmatoa ("u", uladv),
				   dwarf_vmatoa ("x", state_machine_regs.address));
			 }
		       else
			 {
			   state_machine_regs.address
			     += ((state_machine_regs.op_index + uladv)
				 / linfo.li_max_ops_per_insn)
			     * linfo.li_min_insn_length;
			   state_machine_regs.op_index
			     = (state_machine_regs.op_index + uladv)
			     % linfo.li_max_ops_per_insn;
			   printf (_("  Advance PC by %s to 0x%s[%d]\n"),
				   dwarf_vmatoa ("u", uladv),
				   dwarf_vmatoa ("x", state_machine_regs.address),
				   state_machine_regs.op_index);
			 }
		       break;

		     case DW_LNS_advance_line:
		       adv = read_sleb128 (data, & bytes_read, end);
		       data += bytes_read;
		       state_machine_regs.line += adv;
		       printf (_("  Advance Line by %s to %d\n"),
			       dwarf_vmatoa ("d", adv),
			       state_machine_regs.line);
		       break;

		     case DW_LNS_set_file:
		       adv = read_uleb128 (data, & bytes_read, end);
		       data += bytes_read;
		       printf (_("  Set File Name to entry %s in the File Name Table\n"),
			       dwarf_vmatoa ("d", adv));
		       state_machine_regs.file = adv;
		       break;

		     case DW_LNS_set_column:
		       uladv = read_uleb128 (data, & bytes_read, end);
		       data += bytes_read;
		       printf (_("  Set column to %s\n"),
			       dwarf_vmatoa ("u", uladv));
		       state_machine_regs.column = uladv;
		       break;

		     case DW_LNS_negate_stmt:
		       adv = state_machine_regs.is_stmt;
		       adv = ! adv;
		       printf (_("  Set is_stmt to %s\n"), dwarf_vmatoa ("d", adv));
		       state_machine_regs.is_stmt = adv;
		       break;

		     case DW_LNS_set_basic_block:
		       printf (_("  Set basic block\n"));
		       state_machine_regs.basic_block = 1;
		       break;

		     case DW_LNS_const_add_pc:
		       uladv = ((255 - linfo.li_opcode_base) / linfo.li_line_range);
		       if (linfo.li_max_ops_per_insn)
			 {
			   uladv *= linfo.li_min_insn_length;
			   state_machine_regs.address += uladv;
			   printf (_("  Advance PC by constant %s to 0x%s\n"),
				   dwarf_vmatoa ("u", uladv),
				   dwarf_vmatoa ("x", state_machine_regs.address));
			 }
		       else
			 {
			   state_machine_regs.address
			     += ((state_machine_regs.op_index + uladv)
				 / linfo.li_max_ops_per_insn)
			     * linfo.li_min_insn_length;
			   state_machine_regs.op_index
			     = (state_machine_regs.op_index + uladv)
			     % linfo.li_max_ops_per_insn;
			   printf (_("  Advance PC by constant %s to 0x%s[%d]\n"),
				   dwarf_vmatoa ("u", uladv),
				   dwarf_vmatoa ("x", state_machine_regs.address),
				   state_machine_regs.op_index);
			 }
		       break;

		     case DW_LNS_fixed_advance_pc:
		       SAFE_BYTE_GET_AND_INC (uladv, data, 2, end);
		       state_machine_regs.address += uladv;
		       state_machine_regs.op_index = 0;
		       printf (_("  Advance PC by fixed size amount %s to 0x%s\n"),
			       dwarf_vmatoa ("u", uladv),
			       dwarf_vmatoa ("x", state_machine_regs.address));
		       break;

		     case DW_LNS_set_prologue_end:
		       printf (_("  Set prologue_end to true\n"));
		       break;

		     case DW_LNS_set_epilogue_begin:
		       printf (_("  Set epilogue_begin to true\n"));
		       break;

		     case DW_LNS_set_isa:
		       uladv = read_uleb128 (data, & bytes_read, end);
		       data += bytes_read;
		       printf (_("  Set ISA to %s\n"), dwarf_vmatoa ("u", uladv));
		       break;

		     default:
		       printf (_("  Unknown opcode %d with operands: "), op_code);

		       if (standard_opcodes != NULL)
			 for (i = standard_opcodes[op_code - 1]; i > 0 ; --i)
			   {
			     printf ("0x%s%s", dwarf_vmatoa ("x", read_uleb128 (data,
										&bytes_read, end)),
				     i == 1 ? "" : ", ");
			     data += bytes_read;
			   }
		       putchar ('\n');
		       break;
		     }
	    }
	  putchar ('\n');
	}
    }

  return 1;
}

typedef struct
{
  unsigned char *name;
  unsigned int directory_index;
  unsigned int modification_date;
  unsigned int length;
} File_Entry;

/* Output a decoded representation of the .debug_line section.  */

static int
display_debug_lines_decoded (struct dwarf_section *section,
			     unsigned char *data,
			     unsigned char *end)
{
  static DWARF2_Internal_LineInfo saved_linfo;

  printf (_("Decoded dump of debug contents of section %s:\n\n"),
          section->name);

  while (data < end)
    {
      /* This loop amounts to one iteration per compilation unit.  */
      DWARF2_Internal_LineInfo linfo;
      unsigned char *standard_opcodes;
      unsigned char *end_of_sequence;
      int i;
      File_Entry *file_table = NULL;
      unsigned int n_files = 0;
      unsigned char **directory_table = NULL;
      unsigned int n_directories = 0;

      if (const_strneq (section->name, ".debug_line.")
	  /* Note: the following does not apply to .debug_line.dwo sections.
	     These are full debug_line sections.  */
	  && strcmp (section->name, ".debug_line.dwo") != 0)
        {
	  /* See comment in display_debug_lines_raw().  */
	  end_of_sequence = end;
	  standard_opcodes = NULL;
	  linfo = saved_linfo;
	  reset_state_machine (linfo.li_default_is_stmt);
        }
      else
        {
	  unsigned char *hdrptr;

	  if ((hdrptr = read_debug_line_header (section, data, end, & linfo,
						& end_of_sequence)) == NULL)
	      return 0;

	  reset_state_machine (linfo.li_default_is_stmt);

	  /* Save a pointer to the contents of the Opcodes table.  */
	  standard_opcodes = hdrptr;

	  /* Traverse the Directory table just to count entries.  */
	  data = standard_opcodes + linfo.li_opcode_base - 1;
	  if (*data != 0)
	    {
	      unsigned char *ptr_directory_table = data;

	      while (*data != 0)
		{
		  data += strnlen ((char *) data, end - data) + 1;
		  n_directories++;
		}

	      /* Go through the directory table again to save the directories.  */
	      directory_table = (unsigned char **)
		xmalloc (n_directories * sizeof (unsigned char *));

	      i = 0;
	      while (*ptr_directory_table != 0)
		{
		  directory_table[i] = ptr_directory_table;
		  ptr_directory_table += strnlen ((char *) ptr_directory_table,
						  ptr_directory_table - end) + 1;
		  i++;
		}
	    }
	  /* Skip the NUL at the end of the table.  */
	  data++;

	  /* Traverse the File Name table just to count the entries.  */
	  if (*data != 0)
	    {
	      unsigned char *ptr_file_name_table = data;

	      while (*data != 0)
		{
		  unsigned int bytes_read;

		  /* Skip Name, directory index, last modification time and length
		     of file.  */
		  data += strnlen ((char *) data, end - data) + 1;
		  read_uleb128 (data, & bytes_read, end);
		  data += bytes_read;
		  read_uleb128 (data, & bytes_read, end);
		  data += bytes_read;
		  read_uleb128 (data, & bytes_read, end);
		  data += bytes_read;

		  n_files++;
		}

	      /* Go through the file table again to save the strings.  */
	      file_table = (File_Entry *) xmalloc (n_files * sizeof (File_Entry));

	      i = 0;
	      while (*ptr_file_name_table != 0)
		{
		  unsigned int bytes_read;

		  file_table[i].name = ptr_file_name_table;
		  ptr_file_name_table += strnlen ((char *) ptr_file_name_table,
						  end - ptr_file_name_table) + 1;

		  /* We are not interested in directory, time or size.  */
		  file_table[i].directory_index = read_uleb128 (ptr_file_name_table,
								& bytes_read, end);
		  ptr_file_name_table += bytes_read;
		  file_table[i].modification_date = read_uleb128 (ptr_file_name_table,
								  & bytes_read, end);
		  ptr_file_name_table += bytes_read;
		  file_table[i].length = read_uleb128 (ptr_file_name_table, & bytes_read, end);
		  ptr_file_name_table += bytes_read;
		  i++;
		}
	      i = 0;

	      /* Print the Compilation Unit's name and a header.  */
	      if (directory_table == NULL)
		{
		  printf (_("CU: %s:\n"), file_table[0].name);
		  printf (_("File name                            Line number    Starting address\n"));
		}
	      else
		{
		  unsigned int ix = file_table[0].directory_index;
		  const char *directory = ix ? (char *)directory_table[ix - 1] : ".";

		  if (do_wide || strlen (directory) < 76)
		    printf (_("CU: %s/%s:\n"), directory, file_table[0].name);
		  else
		    printf ("%s:\n", file_table[0].name);

		  printf (_("File name                            Line number    Starting address\n"));
		}
	    }

	  /* Skip the NUL at the end of the table.  */
	  data++;

	  saved_linfo = linfo;
	}

      /* This loop iterates through the Dwarf Line Number Program.  */
      while (data < end_of_sequence)
        {
	  unsigned char op_code;
          int adv;
          unsigned long int uladv;
          unsigned int bytes_read;
          int is_special_opcode = 0;

          op_code = *data++;

          if (op_code >= linfo.li_opcode_base)
	    {
	      op_code -= linfo.li_opcode_base;
	      uladv = (op_code / linfo.li_line_range);
	      if (linfo.li_max_ops_per_insn == 1)
		{
		  uladv *= linfo.li_min_insn_length;
		  state_machine_regs.address += uladv;
		}
	      else
		{
		  state_machine_regs.address
		    += ((state_machine_regs.op_index + uladv)
			/ linfo.li_max_ops_per_insn)
		    * linfo.li_min_insn_length;
		  state_machine_regs.op_index
		    = (state_machine_regs.op_index + uladv)
		    % linfo.li_max_ops_per_insn;
		}

              adv = (op_code % linfo.li_line_range) + linfo.li_line_base;
              state_machine_regs.line += adv;
              is_special_opcode = 1;
            }
          else switch (op_code)
		 {
		 case DW_LNS_extended_op:
		   {
		     unsigned int ext_op_code_len;
		     unsigned char ext_op_code;
		     unsigned char *op_code_data = data;

		     ext_op_code_len = read_uleb128 (op_code_data, &bytes_read,
						     end_of_sequence);
		     op_code_data += bytes_read;

		     if (ext_op_code_len == 0)
		       {
			 warn (_("badly formed extended line op encountered!\n"));
			 break;
		       }
		     ext_op_code_len += bytes_read;
		     ext_op_code = *op_code_data++;

		     switch (ext_op_code)
		       {
		       case DW_LNE_end_sequence:
			 reset_state_machine (linfo.li_default_is_stmt);
			 break;
		       case DW_LNE_set_address:
			 SAFE_BYTE_GET_AND_INC (state_machine_regs.address,
						op_code_data,
						ext_op_code_len - bytes_read - 1,
						end);
			 state_machine_regs.op_index = 0;
			 break;
		       case DW_LNE_define_file:
			 {
			   file_table = (File_Entry *) xrealloc
			     (file_table, (n_files + 1) * sizeof (File_Entry));

			   ++state_machine_regs.last_file_entry;
			   /* Source file name.  */
			   file_table[n_files].name = op_code_data;
			   op_code_data += strlen ((char *) op_code_data) + 1;
			   /* Directory index.  */
			   file_table[n_files].directory_index =
			     read_uleb128 (op_code_data, & bytes_read,
					   end_of_sequence);
			   op_code_data += bytes_read;
			   /* Last modification time.  */
			   file_table[n_files].modification_date =
			     read_uleb128 (op_code_data, & bytes_read,
					   end_of_sequence);
			   op_code_data += bytes_read;
			   /* File length.  */
			   file_table[n_files].length =
			     read_uleb128 (op_code_data, & bytes_read,
					   end_of_sequence);

			   n_files++;
			   break;
			 }
		       case DW_LNE_set_discriminator:
		       case DW_LNE_HP_set_sequence:
			 /* Simply ignored.  */
			 break;

		       default:
			 printf (_("UNKNOWN (%u): length %d\n"),
				 ext_op_code, ext_op_code_len - bytes_read);
			 break;
		       }
		     data += ext_op_code_len;
		     break;
		   }
		 case DW_LNS_copy:
		   break;

		 case DW_LNS_advance_pc:
		   uladv = read_uleb128 (data, & bytes_read, end);
		   data += bytes_read;
		   if (linfo.li_max_ops_per_insn == 1)
		     {
		       uladv *= linfo.li_min_insn_length;
		       state_machine_regs.address += uladv;
		     }
		   else
		     {
		       state_machine_regs.address
			 += ((state_machine_regs.op_index + uladv)
			     / linfo.li_max_ops_per_insn)
			 * linfo.li_min_insn_length;
		       state_machine_regs.op_index
			 = (state_machine_regs.op_index + uladv)
			 % linfo.li_max_ops_per_insn;
		     }
		   break;

		 case DW_LNS_advance_line:
		   adv = read_sleb128 (data, & bytes_read, end);
		   data += bytes_read;
		   state_machine_regs.line += adv;
		   break;

		 case DW_LNS_set_file:
		   adv = read_uleb128 (data, & bytes_read, end);
		   data += bytes_read;
		   state_machine_regs.file = adv;

		   if (file_table == NULL)
		     printf (_("\n [Use file table entry %d]\n"), state_machine_regs.file - 1);
		   else if (file_table[state_machine_regs.file - 1].directory_index == 0)
		     /* If directory index is 0, that means current directory.  */
		     printf ("\n./%s:[++]\n",
			     file_table[state_machine_regs.file - 1].name);
		   else if (directory_table == NULL)
		     printf (_("\n [Use directory table entry %d]\n"),
			     file_table[state_machine_regs.file - 1].directory_index - 1);
		   else
		     /* The directory index starts counting at 1.  */
		     printf ("\n%s/%s:\n",
			     directory_table[file_table[state_machine_regs.file - 1].directory_index - 1],
			     file_table[state_machine_regs.file - 1].name);
		   break;

		 case DW_LNS_set_column:
		   uladv = read_uleb128 (data, & bytes_read, end);
		   data += bytes_read;
		   state_machine_regs.column = uladv;
		   break;

		 case DW_LNS_negate_stmt:
		   adv = state_machine_regs.is_stmt;
		   adv = ! adv;
		   state_machine_regs.is_stmt = adv;
		   break;

		 case DW_LNS_set_basic_block:
		   state_machine_regs.basic_block = 1;
		   break;

		 case DW_LNS_const_add_pc:
		   uladv = ((255 - linfo.li_opcode_base) / linfo.li_line_range);
		   if (linfo.li_max_ops_per_insn == 1)
		     {
		       uladv *= linfo.li_min_insn_length;
		       state_machine_regs.address += uladv;
		     }
		   else
		     {
		       state_machine_regs.address
			 += ((state_machine_regs.op_index + uladv)
			     / linfo.li_max_ops_per_insn)
			 * linfo.li_min_insn_length;
		       state_machine_regs.op_index
			 = (state_machine_regs.op_index + uladv)
			 % linfo.li_max_ops_per_insn;
		     }
		   break;

		 case DW_LNS_fixed_advance_pc:
		   SAFE_BYTE_GET_AND_INC (uladv, data, 2, end);
		   state_machine_regs.address += uladv;
		   state_machine_regs.op_index = 0;
		   break;

		 case DW_LNS_set_prologue_end:
		   break;

		 case DW_LNS_set_epilogue_begin:
		   break;

		 case DW_LNS_set_isa:
		   uladv = read_uleb128 (data, & bytes_read, end);
		   data += bytes_read;
		   printf (_("  Set ISA to %lu\n"), uladv);
		   break;

		 default:
		   printf (_("  Unknown opcode %d with operands: "), op_code);

		   if (standard_opcodes != NULL)
		     for (i = standard_opcodes[op_code - 1]; i > 0 ; --i)
		       {
			 printf ("0x%s%s", dwarf_vmatoa ("x", read_uleb128 (data,
									    &bytes_read, end)),
				 i == 1 ? "" : ", ");
			 data += bytes_read;
		       }
		   putchar ('\n');
		   break;
		 }

          /* Only Special opcodes, DW_LNS_copy and DW_LNE_end_sequence adds a row
             to the DWARF address/line matrix.  */
          if ((is_special_opcode) || (op_code == DW_LNE_end_sequence)
	      || (op_code == DW_LNS_copy))
            {
              const unsigned int MAX_FILENAME_LENGTH = 35;
              char *fileName;
              char *newFileName = NULL;
              size_t fileNameLength;

	      if (file_table)
		fileName = (char *) file_table[state_machine_regs.file - 1].name;
	      else
		fileName = "<unknown>";

	      fileNameLength = strlen (fileName);

              if ((fileNameLength > MAX_FILENAME_LENGTH) && (!do_wide))
                {
                  newFileName = (char *) xmalloc (MAX_FILENAME_LENGTH + 1);
                  /* Truncate file name */
                  strncpy (newFileName,
                           fileName + fileNameLength - MAX_FILENAME_LENGTH,
                           MAX_FILENAME_LENGTH + 1);
                }
              else
                {
                  newFileName = (char *) xmalloc (fileNameLength + 1);
                  strncpy (newFileName, fileName, fileNameLength + 1);
                }

              if (!do_wide || (fileNameLength <= MAX_FILENAME_LENGTH))
                {
		  if (linfo.li_max_ops_per_insn == 1)
		    printf ("%-35s  %11d  %#18" DWARF_VMA_FMT "x\n",
			    newFileName, state_machine_regs.line,
			    state_machine_regs.address);
		  else
		    printf ("%-35s  %11d  %#18" DWARF_VMA_FMT "x[%d]\n",
			    newFileName, state_machine_regs.line,
			    state_machine_regs.address,
			    state_machine_regs.op_index);
                }
              else
                {
		  if (linfo.li_max_ops_per_insn == 1)
		    printf ("%s  %11d  %#18" DWARF_VMA_FMT "x\n",
			    newFileName, state_machine_regs.line,
			    state_machine_regs.address);
		  else
		    printf ("%s  %11d  %#18" DWARF_VMA_FMT "x[%d]\n",
			    newFileName, state_machine_regs.line,
			    state_machine_regs.address,
			    state_machine_regs.op_index);
                }

              if (op_code == DW_LNE_end_sequence)
		printf ("\n");

              free (newFileName);
            }
        }

      if (file_table)
	{
	  free (file_table);
	  file_table = NULL;
	  n_files = 0;
	}

      if (directory_table)
	{
	  free (directory_table);
	  directory_table = NULL;
	  n_directories = 0;
	}

      putchar ('\n');
    }

  return 1;
}

static int
display_debug_lines (struct dwarf_section *section, void *file ATTRIBUTE_UNUSED)
{
  unsigned char *data = section->start;
  unsigned char *end = data + section->size;
  int retValRaw = 1;
  int retValDecoded = 1;

  if (do_debug_lines == 0)
    do_debug_lines |= FLAG_DEBUG_LINES_RAW;

  if (do_debug_lines & FLAG_DEBUG_LINES_RAW)
    retValRaw = display_debug_lines_raw (section, data, end);

  if (do_debug_lines & FLAG_DEBUG_LINES_DECODED)
    retValDecoded = display_debug_lines_decoded (section, data, end);

  if (!retValRaw || !retValDecoded)
    return 0;

  return 1;
}

static debug_info *
find_debug_info_for_offset (unsigned long offset)
{
  unsigned int i;

  if (num_debug_info_entries == DEBUG_INFO_UNAVAILABLE)
    return NULL;

  for (i = 0; i < num_debug_info_entries; i++)
    if (debug_information[i].cu_offset == offset)
      return debug_information + i;

  return NULL;
}

static int
display_debug_pubnames (struct dwarf_section *section,
			void *file ATTRIBUTE_UNUSED)
{
  DWARF2_Internal_PubNames names;
  unsigned char *start = section->start;
  unsigned char *end = start + section->size;

  /* It does not matter if this load fails,
     we test for that later on.  */
  load_debug_info (file);

  printf (_("Contents of the %s section:\n\n"), section->name);

  while (start < end)
    {
      unsigned char *data;
      unsigned long offset;
      unsigned int offset_size, initial_length_size;

      data = start;

      SAFE_BYTE_GET_AND_INC (names.pn_length, data, 4, end);
      if (names.pn_length == 0xffffffff)
	{
	  SAFE_BYTE_GET_AND_INC (names.pn_length, data, 8, end);
	  offset_size = 8;
	  initial_length_size = 12;
	}
      else
	{
	  offset_size = 4;
	  initial_length_size = 4;
	}

      SAFE_BYTE_GET_AND_INC (names.pn_version, data, 2, end);
      SAFE_BYTE_GET_AND_INC (names.pn_offset, data, offset_size, end);

      if (num_debug_info_entries != DEBUG_INFO_UNAVAILABLE
	  && num_debug_info_entries > 0
	  && find_debug_info_for_offset (names.pn_offset) == NULL)
	warn (_(".debug_info offset of 0x%lx in %s section does not point to a CU header.\n"),
	      (unsigned long) names.pn_offset, section->name);

      SAFE_BYTE_GET_AND_INC (names.pn_size, data, offset_size, end);

      start += names.pn_length + initial_length_size;

      if (names.pn_version != 2 && names.pn_version != 3)
	{
	  static int warned = 0;

	  if (! warned)
	    {
	      warn (_("Only DWARF 2 and 3 pubnames are currently supported\n"));
	      warned = 1;
	    }

	  continue;
	}

      printf (_("  Length:                              %ld\n"),
	      (long) names.pn_length);
      printf (_("  Version:                             %d\n"),
	      names.pn_version);
      printf (_("  Offset into .debug_info section:     0x%lx\n"),
	      (unsigned long) names.pn_offset);
      printf (_("  Size of area in .debug_info section: %ld\n"),
	      (long) names.pn_size);

      printf (_("\n    Offset\tName\n"));

      do
	{
	  SAFE_BYTE_GET (offset, data, offset_size, end);

	  if (offset != 0)
	    {
	      data += offset_size;
	      printf ("    %-6lx\t%s\n", offset, data);
	      data += strnlen ((char *) data, end - data) + 1;
	    }
	}
      while (offset != 0);
    }

  printf ("\n");
  return 1;
}

static int
display_debug_macinfo (struct dwarf_section *section,
		       void *file ATTRIBUTE_UNUSED)
{
  unsigned char *start = section->start;
  unsigned char *end = start + section->size;
  unsigned char *curr = start;
  unsigned int bytes_read;
  enum dwarf_macinfo_record_type op;

  printf (_("Contents of the %s section:\n\n"), section->name);

  while (curr < end)
    {
      unsigned int lineno;
      const unsigned char *string;

      op = (enum dwarf_macinfo_record_type) *curr;
      curr++;

      switch (op)
	{
	case DW_MACINFO_start_file:
	  {
	    unsigned int filenum;

	    lineno = read_uleb128 (curr, & bytes_read, end);
	    curr += bytes_read;
	    filenum = read_uleb128 (curr, & bytes_read, end);
	    curr += bytes_read;

	    printf (_(" DW_MACINFO_start_file - lineno: %d filenum: %d\n"),
		    lineno, filenum);
	  }
	  break;

	case DW_MACINFO_end_file:
	  printf (_(" DW_MACINFO_end_file\n"));
	  break;

	case DW_MACINFO_define:
	  lineno = read_uleb128 (curr, & bytes_read, end);
	  curr += bytes_read;
	  string = curr;
	  curr += strnlen ((char *) string, end - string) + 1;
	  printf (_(" DW_MACINFO_define - lineno : %d macro : %s\n"),
		  lineno, string);
	  break;

	case DW_MACINFO_undef:
	  lineno = read_uleb128 (curr, & bytes_read, end);
	  curr += bytes_read;
	  string = curr;
	  curr += strnlen ((char *) string, end - string) + 1;
	  printf (_(" DW_MACINFO_undef - lineno : %d macro : %s\n"),
		  lineno, string);
	  break;

	case DW_MACINFO_vendor_ext:
	  {
	    unsigned int constant;

	    constant = read_uleb128 (curr, & bytes_read, end);
	    curr += bytes_read;
	    string = curr;
	    curr += strnlen ((char *) string, end - string) + 1;
	    printf (_(" DW_MACINFO_vendor_ext - constant : %d string : %s\n"),
		    constant, string);
	  }
	  break;
	}
    }

  return 1;
}

/* Given LINE_OFFSET into the .debug_line section, attempt to return
   filename and dirname corresponding to file name table entry with index
   FILEIDX.  Return NULL on failure.  */

static unsigned char *
get_line_filename_and_dirname (dwarf_vma line_offset,
			       dwarf_vma fileidx,
			       unsigned char **dir_name)
{
  struct dwarf_section *section = &debug_displays [line].section;
  unsigned char *hdrptr, *dirtable, *file_name;
  unsigned int offset_size, initial_length_size;
  unsigned int version, opcode_base, bytes_read;
  dwarf_vma length, diridx;
  const unsigned char * end;

  *dir_name = NULL;
  if (section->start == NULL
      || line_offset >= section->size
      || fileidx == 0)
    return NULL;

  hdrptr = section->start + line_offset;
  end = section->start + section->size;

  SAFE_BYTE_GET_AND_INC (length, hdrptr, 4, end);
  if (length == 0xffffffff)
    {
      /* This section is 64-bit DWARF 3.  */
      SAFE_BYTE_GET_AND_INC (length, hdrptr, 8, end);
      offset_size = 8;
      initial_length_size = 12;
    }
  else
    {
      offset_size = 4;
      initial_length_size = 4;
    }
  if (length + initial_length_size > section->size)
    return NULL;

  SAFE_BYTE_GET_AND_INC (version, hdrptr, 2, end);
  if (version != 2 && version != 3 && version != 4)
    return NULL;
  hdrptr += offset_size + 1;/* Skip prologue_length and min_insn_length.  */
  if (version >= 4)
    hdrptr++;		    /* Skip max_ops_per_insn.  */
  hdrptr += 3;		    /* Skip default_is_stmt, line_base, line_range.  */

  SAFE_BYTE_GET_AND_INC (opcode_base, hdrptr, 1, end);
  if (opcode_base == 0)
    return NULL;

  hdrptr += opcode_base - 1;
  dirtable = hdrptr;
  /* Skip over dirname table.  */
  while (*hdrptr != '\0')
    hdrptr += strnlen ((char *) hdrptr, end - hdrptr) + 1;
  hdrptr++;		    /* Skip the NUL at the end of the table.  */
  /* Now skip over preceding filename table entries.  */
  for (; *hdrptr != '\0' && fileidx > 1; fileidx--)
    {
      hdrptr += strnlen ((char *) hdrptr, end - hdrptr) + 1;
      read_uleb128 (hdrptr, &bytes_read, end);
      hdrptr += bytes_read;
      read_uleb128 (hdrptr, &bytes_read, end);
      hdrptr += bytes_read;
      read_uleb128 (hdrptr, &bytes_read, end);
      hdrptr += bytes_read;
    }
  if (hdrptr == end || *hdrptr == '\0')
    return NULL;
  file_name = hdrptr;
  hdrptr += strnlen ((char *) hdrptr, end - hdrptr) + 1;
  diridx = read_uleb128 (hdrptr, &bytes_read, end);
  if (diridx == 0)
    return file_name;
  for (; *dirtable != '\0' && diridx > 1; diridx--)
    dirtable += strnlen ((char *) dirtable, end - dirtable) + 1;
  if (*dirtable == '\0')
    return NULL;
  *dir_name = dirtable;
  return file_name;
}

static int
display_debug_macro (struct dwarf_section *section,
		     void *file)
{
  unsigned char *start = section->start;
  unsigned char *end = start + section->size;
  unsigned char *curr = start;
  unsigned char *extended_op_buf[256];
  unsigned int bytes_read;

  load_debug_section (str, file);
  load_debug_section (line, file);

  printf (_("Contents of the %s section:\n\n"), section->name);

  while (curr < end)
    {
      unsigned int lineno, version, flags;
      unsigned int offset_size = 4;
      const unsigned char *string;
      dwarf_vma line_offset = 0, sec_offset = curr - start, offset;
      unsigned char **extended_ops = NULL;

      SAFE_BYTE_GET_AND_INC (version, curr, 2, end);
      if (version != 4)
	{
	  error (_("Only GNU extension to DWARF 4 of %s is currently supported.\n"),
		 section->name);
	  return 0;
	}

      SAFE_BYTE_GET_AND_INC (flags, curr, 1, end);
      if (flags & 1)
	offset_size = 8;
      printf (_("  Offset:                      0x%lx\n"),
	      (unsigned long) sec_offset);
      printf (_("  Version:                     %d\n"), version);
      printf (_("  Offset size:                 %d\n"), offset_size);
      if (flags & 2)
	{
	  SAFE_BYTE_GET_AND_INC (line_offset, curr, offset_size, end);
	  printf (_("  Offset into .debug_line:     0x%lx\n"),
		  (unsigned long) line_offset);
	}
      if (flags & 4)
	{
	  unsigned int i, count, op;
	  dwarf_vma nargs, n;

	  SAFE_BYTE_GET_AND_INC (count, curr, 1, end);

	  memset (extended_op_buf, 0, sizeof (extended_op_buf));
	  extended_ops = extended_op_buf;
	  if (count)
	    {
	      printf (_("  Extension opcode arguments:\n"));
	      for (i = 0; i < count; i++)
		{
		  SAFE_BYTE_GET_AND_INC (op, curr, 1, end);
		  extended_ops[op] = curr;
		  nargs = read_uleb128 (curr, &bytes_read, end);
		  curr += bytes_read;
		  if (nargs == 0)
		    printf (_("    DW_MACRO_GNU_%02x has no arguments\n"), op);
		  else
		    {
		      printf (_("    DW_MACRO_GNU_%02x arguments: "), op);
		      for (n = 0; n < nargs; n++)
			{
			  unsigned int form;

			  SAFE_BYTE_GET_AND_INC (form, curr, 1, end);
			  printf ("%s%s", get_FORM_name (form),
				  n == nargs - 1 ? "\n" : ", ");
			  switch (form)
			    {
			    case DW_FORM_data1:
			    case DW_FORM_data2:
			    case DW_FORM_data4:
			    case DW_FORM_data8:
			    case DW_FORM_sdata:
			    case DW_FORM_udata:
			    case DW_FORM_block:
			    case DW_FORM_block1:
			    case DW_FORM_block2:
			    case DW_FORM_block4:
			    case DW_FORM_flag:
			    case DW_FORM_string:
			    case DW_FORM_strp:
			    case DW_FORM_sec_offset:
			      break;
			    default:
			      error (_("Invalid extension opcode form %s\n"),
				     get_FORM_name (form));
			      return 0;
			    }
			}
		    }
		}
	    }
	}
      printf ("\n");

      while (1)
	{
	  unsigned int op;

	  if (curr >= end)
	    {
	      error (_(".debug_macro section not zero terminated\n"));
	      return 0;
	    }

	  SAFE_BYTE_GET_AND_INC (op, curr, 1, end);
	  if (op == 0)
	    break;

	  switch (op)
	    {
	    case DW_MACRO_GNU_start_file:
	      {
		unsigned int filenum;
		unsigned char *file_name = NULL, *dir_name = NULL;

		lineno = read_uleb128 (curr, &bytes_read, end);
		curr += bytes_read;
		filenum = read_uleb128 (curr, &bytes_read, end);
		curr += bytes_read;

		if ((flags & 2) == 0)
		  error (_("DW_MACRO_GNU_start_file used, but no .debug_line offset provided.\n"));
		else
		  file_name
		    = get_line_filename_and_dirname (line_offset, filenum,
						     &dir_name);
		if (file_name == NULL)
		  printf (_(" DW_MACRO_GNU_start_file - lineno: %d filenum: %d\n"),
			  lineno, filenum);
		else
		  printf (_(" DW_MACRO_GNU_start_file - lineno: %d filenum: %d filename: %s%s%s\n"),
			  lineno, filenum,
			  dir_name != NULL ? (const char *) dir_name : "",
			  dir_name != NULL ? "/" : "", file_name);
	      }
	      break;

	    case DW_MACRO_GNU_end_file:
	      printf (_(" DW_MACRO_GNU_end_file\n"));
	      break;

	    case DW_MACRO_GNU_define:
	      lineno = read_uleb128 (curr, &bytes_read, end);
	      curr += bytes_read;
	      string = curr;
	      curr += strnlen ((char *) string, end - string) + 1;
	      printf (_(" DW_MACRO_GNU_define - lineno : %d macro : %s\n"),
		      lineno, string);
	      break;

	    case DW_MACRO_GNU_undef:
	      lineno = read_uleb128 (curr, &bytes_read, end);
	      curr += bytes_read;
	      string = curr;
	      curr += strnlen ((char *) string, end - string) + 1;
	      printf (_(" DW_MACRO_GNU_undef - lineno : %d macro : %s\n"),
		      lineno, string);
	      break;

	    case DW_MACRO_GNU_define_indirect:
	      lineno = read_uleb128 (curr, &bytes_read, end);
	      curr += bytes_read;
	      SAFE_BYTE_GET_AND_INC (offset, curr, offset_size, end);
	      string = fetch_indirect_string (offset);
	      printf (_(" DW_MACRO_GNU_define_indirect - lineno : %d macro : %s\n"),
		      lineno, string);
	      break;

	    case DW_MACRO_GNU_undef_indirect:
	      lineno = read_uleb128 (curr, &bytes_read, end);
	      curr += bytes_read;
	      SAFE_BYTE_GET_AND_INC (offset, curr, offset_size, end);
	      string = fetch_indirect_string (offset);
	      printf (_(" DW_MACRO_GNU_undef_indirect - lineno : %d macro : %s\n"),
		      lineno, string);
	      break;

	    case DW_MACRO_GNU_transparent_include:
	      SAFE_BYTE_GET_AND_INC (offset, curr, offset_size, end);
	      printf (_(" DW_MACRO_GNU_transparent_include - offset : 0x%lx\n"),
		      (unsigned long) offset);
	      break;

	    case DW_MACRO_GNU_define_indirect_alt:
	      lineno = read_uleb128 (curr, &bytes_read, end);
	      curr += bytes_read;
	      SAFE_BYTE_GET_AND_INC (offset, curr, offset_size, end);
	      printf (_(" DW_MACRO_GNU_define_indirect_alt - lineno : %d macro offset : 0x%lx\n"),
		      lineno, (unsigned long) offset);
	      break;

	    case DW_MACRO_GNU_undef_indirect_alt:
	      lineno = read_uleb128 (curr, &bytes_read, end);
	      curr += bytes_read;
	      SAFE_BYTE_GET_AND_INC (offset, curr, offset_size, end);
	      printf (_(" DW_MACRO_GNU_undef_indirect_alt - lineno : %d macro offset : 0x%lx\n"),
		      lineno, (unsigned long) offset);
	      break;

	    case DW_MACRO_GNU_transparent_include_alt:
	      SAFE_BYTE_GET_AND_INC (offset, curr, offset_size, end);
	      printf (_(" DW_MACRO_GNU_transparent_include_alt - offset : 0x%lx\n"),
		      (unsigned long) offset);
	      break;

	    default:
	      if (extended_ops == NULL || extended_ops[op] == NULL)
		{
		  error (_(" Unknown macro opcode %02x seen\n"), op);
		  return 0;
		}
	      else
		{
		  /* Skip over unhandled opcodes.  */
		  dwarf_vma nargs, n;
		  unsigned char *desc = extended_ops[op];
		  nargs = read_uleb128 (desc, &bytes_read, end);
		  desc += bytes_read;
		  if (nargs == 0)
		    {
		      printf (_(" DW_MACRO_GNU_%02x\n"), op);
		      break;
		    }
		  printf (_(" DW_MACRO_GNU_%02x -"), op);
		  for (n = 0; n < nargs; n++)
		    {
		      int val;

		      SAFE_BYTE_GET_AND_INC (val, desc, 1, end);
		      curr
			= read_and_display_attr_value (0, val,
						       curr, end, 0, 0, offset_size,
						       version, NULL, 0, NULL,
						       NULL);
		      if (n != nargs - 1)
			printf (",");
		    }
		  printf ("\n");
		}
	      break;
	    }
	}

      printf ("\n");
    }	

  return 1;
}

static int
display_debug_abbrev (struct dwarf_section *section,
		      void *file ATTRIBUTE_UNUSED)
{
  abbrev_entry *entry;
  unsigned char *start = section->start;
  unsigned char *end = start + section->size;

  printf (_("Contents of the %s section:\n\n"), section->name);

  do
    {
      unsigned char *last;

      free_abbrevs ();

      last = start;
      start = process_abbrev_section (start, end);

      if (first_abbrev == NULL)
	continue;

      printf (_("  Number TAG (0x%lx)\n"), (long) (last - section->start));

      for (entry = first_abbrev; entry; entry = entry->next)
	{
	  abbrev_attr *attr;

	  printf ("   %ld      %s    [%s]\n",
		  entry->entry,
		  get_TAG_name (entry->tag),
		  entry->children ? _("has children") : _("no children"));

	  for (attr = entry->first_attr; attr; attr = attr->next)
	    printf ("    %-18s %s\n",
		    get_AT_name (attr->attribute),
		    get_FORM_name (attr->form));
	}
    }
  while (start);

  printf ("\n");

  return 1;
}

/* Display a location list from a normal (ie, non-dwo) .debug_loc section.  */

static void
display_loc_list (struct dwarf_section *section,
                  unsigned char **start_ptr,
                  int debug_info_entry,
                  unsigned long offset,
                  unsigned long base_address,
                  int has_frame_base)
{
  unsigned char *start = *start_ptr;
  unsigned char *section_end = section->start + section->size;
  unsigned long cu_offset = debug_information [debug_info_entry].cu_offset;
  unsigned int pointer_size = debug_information [debug_info_entry].pointer_size;
  unsigned int offset_size = debug_information [debug_info_entry].offset_size;
  int dwarf_version = debug_information [debug_info_entry].dwarf_version;

  dwarf_vma begin;
  dwarf_vma end;
  unsigned short length;
  int need_frame_base;

  while (1)
    {
      if (start + 2 * pointer_size > section_end)
        {
          warn (_("Location list starting at offset 0x%lx is not terminated.\n"),
                offset);
          break;
        }

      printf ("    %8.8lx ", offset + (start - *start_ptr));

      /* Note: we use sign extension here in order to be sure that we can detect
         the -1 escape value.  Sign extension into the top 32 bits of a 32-bit
         address will not affect the values that we display since we always show
         hex values, and always the bottom 32-bits.  */
      SAFE_BYTE_GET_AND_INC (begin, start, pointer_size, section_end);
      SAFE_BYTE_GET_AND_INC (end, start, pointer_size, section_end);

      if (begin == 0 && end == 0)
        {
          printf (_("<End of list>\n"));
          break;
        }

      /* Check base address specifiers.  */
      if (begin == (dwarf_vma) -1 && end != (dwarf_vma) -1)
        {
          base_address = end;
          print_dwarf_vma (begin, pointer_size);
          print_dwarf_vma (end, pointer_size);
          printf (_("(base address)\n"));
          continue;
        }

      if (start + 2 > section_end)
        {
          warn (_("Location list starting at offset 0x%lx is not terminated.\n"),
                offset);
          break;
        }

      SAFE_BYTE_GET_AND_INC (length, start, 2, section_end);

      if (start + length > section_end)
        {
          warn (_("Location list starting at offset 0x%lx is not terminated.\n"),
                offset);
          break;
        }

      print_dwarf_vma (begin + base_address, pointer_size);
      print_dwarf_vma (end + base_address, pointer_size);

      putchar ('(');
      need_frame_base = decode_location_expression (start,
                                                    pointer_size,
                                                    offset_size,
                                                    dwarf_version,
                                                    length,
                                                    cu_offset, section);
      putchar (')');

      if (need_frame_base && !has_frame_base)
        printf (_(" [without DW_AT_frame_base]"));

      if (begin == end)
        fputs (_(" (start == end)"), stdout);
      else if (begin > end)
        fputs (_(" (start > end)"), stdout);

      putchar ('\n');

      start += length;
    }

  *start_ptr = start;
}

/* Print a .debug_addr table index in decimal, surrounded by square brackets,
   right-adjusted in a field of length LEN, and followed by a space.  */

static void
print_addr_index (unsigned int idx, unsigned int len)
{
  static char buf[15];
  snprintf (buf, sizeof (buf), "[%d]", idx);
  printf ("%*s ", len, buf);
}

/* Display a location list from a .dwo section. It uses address indexes rather
   than embedded addresses.  This code closely follows display_loc_list, but the
   two are sufficiently different that combining things is very ugly.  */

static void
display_loc_list_dwo (struct dwarf_section *section,
                      unsigned char **start_ptr,
                      int debug_info_entry,
                      unsigned long offset,
                      int has_frame_base)
{
  unsigned char *start = *start_ptr;
  unsigned char *section_end = section->start + section->size;
  unsigned long cu_offset = debug_information [debug_info_entry].cu_offset;
  unsigned int pointer_size = debug_information [debug_info_entry].pointer_size;
  unsigned int offset_size = debug_information [debug_info_entry].offset_size;
  int dwarf_version = debug_information [debug_info_entry].dwarf_version;
  int entry_type;
  unsigned short length;
  int need_frame_base;
  unsigned int idx;
  unsigned int bytes_read;

  while (1)
    {
      printf ("    %8.8lx ", offset + (start - *start_ptr));

      if (start >= section_end)
        {
          warn (_("Location list starting at offset 0x%lx is not terminated.\n"),
                offset);
          break;
        }

      SAFE_BYTE_GET_AND_INC (entry_type, start, 1, section_end);
      switch (entry_type)
        {
          case 0: /* A terminating entry.  */
            *start_ptr = start;
	    printf (_("<End of list>\n"));
            return;
          case 1: /* A base-address entry.  */
            idx = read_uleb128 (start, &bytes_read, section_end);
            start += bytes_read;
            print_addr_index (idx, 8);
            printf ("         ");
            printf (_("(base address selection entry)\n"));
            continue;
          case 2: /* A start/end entry.  */
            idx = read_uleb128 (start, &bytes_read, section_end);
            start += bytes_read;
            print_addr_index (idx, 8);
            idx = read_uleb128 (start, &bytes_read, section_end);
            start += bytes_read;
            print_addr_index (idx, 8);
            break;
          case 3: /* A start/length entry.  */
            idx = read_uleb128 (start, &bytes_read, section_end);
            start += bytes_read;
            print_addr_index (idx, 8);
	    SAFE_BYTE_GET_AND_INC (idx, start, 4, section_end);
            printf ("%08x ", idx);
            break;
          case 4: /* An offset pair entry.  */
	    SAFE_BYTE_GET_AND_INC (idx, start, 4, section_end);
            printf ("%08x ", idx);
	    SAFE_BYTE_GET_AND_INC (idx, start, 4, section_end);
            printf ("%08x ", idx);
            break;
          default:
            warn (_("Unknown location list entry type 0x%x.\n"), entry_type);
            *start_ptr = start;
            return;
        }

      if (start + 2 > section_end)
        {
          warn (_("Location list starting at offset 0x%lx is not terminated.\n"),
                offset);
          break;
        }

      SAFE_BYTE_GET_AND_INC (length, start, 2, section_end);
      if (start + length > section_end)
        {
          warn (_("Location list starting at offset 0x%lx is not terminated.\n"),
                offset);
          break;
        }

      putchar ('(');
      need_frame_base = decode_location_expression (start,
                                                    pointer_size,
                                                    offset_size,
                                                    dwarf_version,
                                                    length,
                                                    cu_offset, section);
      putchar (')');

      if (need_frame_base && !has_frame_base)
        printf (_(" [without DW_AT_frame_base]"));

      putchar ('\n');

      start += length;
    }

  *start_ptr = start;
}

/* Sort array of indexes in ascending order of loc_offsets[idx].  */

static dwarf_vma *loc_offsets;

static int
loc_offsets_compar (const void *ap, const void *bp)
{
  dwarf_vma a = loc_offsets[*(const unsigned int *) ap];
  dwarf_vma b = loc_offsets[*(const unsigned int *) bp];

  return (a > b) - (b > a);
}

static int
display_debug_loc (struct dwarf_section *section, void *file)
{
  unsigned char *start = section->start;
  unsigned long bytes;
  unsigned char *section_begin = start;
  unsigned int num_loc_list = 0;
  unsigned long last_offset = 0;
  unsigned int first = 0;
  unsigned int i;
  unsigned int j;
  unsigned int k;
  int seen_first_offset = 0;
  int locs_sorted = 1;
  unsigned char *next;
  unsigned int *array = NULL;
  const char *suffix = strrchr (section->name, '.');
  int is_dwo = 0;

  if (suffix && strcmp (suffix, ".dwo") == 0)
    is_dwo = 1;

  bytes = section->size;

  if (bytes == 0)
    {
      printf (_("\nThe %s section is empty.\n"), section->name);
      return 0;
    }

  if (load_debug_info (file) == 0)
    {
      warn (_("Unable to load/parse the .debug_info section, so cannot interpret the %s section.\n"),
	    section->name);
      return 0;
    }

  /* Check the order of location list in .debug_info section. If
     offsets of location lists are in the ascending order, we can
     use `debug_information' directly.  */
  for (i = 0; i < num_debug_info_entries; i++)
    {
      unsigned int num;

      num = debug_information [i].num_loc_offsets;
      if (num > num_loc_list)
	num_loc_list = num;

      /* Check if we can use `debug_information' directly.  */
      if (locs_sorted && num != 0)
	{
	  if (!seen_first_offset)
	    {
	      /* This is the first location list.  */
	      last_offset = debug_information [i].loc_offsets [0];
	      first = i;
	      seen_first_offset = 1;
	      j = 1;
	    }
	  else
	    j = 0;

	  for (; j < num; j++)
	    {
	      if (last_offset >
		  debug_information [i].loc_offsets [j])
		{
		  locs_sorted = 0;
		  break;
		}
	      last_offset = debug_information [i].loc_offsets [j];
	    }
	}
    }

  if (!seen_first_offset)
    error (_("No location lists in .debug_info section!\n"));

  /* DWARF sections under Mach-O have non-zero addresses.  */
  if (debug_information [first].num_loc_offsets > 0
      && debug_information [first].loc_offsets [0] != section->address)
    warn (_("Location lists in %s section start at 0x%s\n"),
	  section->name,
	  dwarf_vmatoa ("x", debug_information [first].loc_offsets [0]));

  if (!locs_sorted)
    array = (unsigned int *) xcmalloc (num_loc_list, sizeof (unsigned int));
  printf (_("Contents of the %s section:\n\n"), section->name);
  printf (_("    Offset   Begin    End      Expression\n"));

  seen_first_offset = 0;
  for (i = first; i < num_debug_info_entries; i++)
    {
      unsigned long offset;
      unsigned long base_address;
      int has_frame_base;

      if (!locs_sorted)
	{
	  for (k = 0; k < debug_information [i].num_loc_offsets; k++)
	    array[k] = k;
	  loc_offsets = debug_information [i].loc_offsets;
	  qsort (array, debug_information [i].num_loc_offsets,
		 sizeof (*array), loc_offsets_compar);
	}

      for (k = 0; k < debug_information [i].num_loc_offsets; k++)
	{
	  j = locs_sorted ? k : array[k];
	  if (k
	      && debug_information [i].loc_offsets [locs_sorted
						    ? k - 1 : array [k - 1]]
		 == debug_information [i].loc_offsets [j])
	    continue;
	  has_frame_base = debug_information [i].have_frame_base [j];
	  /* DWARF sections under Mach-O have non-zero addresses.  */
	  offset = debug_information [i].loc_offsets [j] - section->address;
	  next = section_begin + offset;
	  base_address = debug_information [i].base_address;

	  if (!seen_first_offset)
	    seen_first_offset = 1;
	  else
	    {
	      if (start < next)
		warn (_("There is a hole [0x%lx - 0x%lx] in .debug_loc section.\n"),
		      (unsigned long) (start - section_begin),
		      (unsigned long) (next - section_begin));
	      else if (start > next)
		warn (_("There is an overlap [0x%lx - 0x%lx] in .debug_loc section.\n"),
		      (unsigned long) (start - section_begin),
		      (unsigned long) (next - section_begin));
	    }
	  start = next;

	  if (offset >= bytes)
	    {
	      warn (_("Offset 0x%lx is bigger than .debug_loc section size.\n"),
		    offset);
	      continue;
	    }

          if (is_dwo)
            display_loc_list_dwo (section, &start, i, offset, has_frame_base);
          else
            display_loc_list (section, &start, i, offset, base_address,
                              has_frame_base);
	}
    }

  if (start < section->start + section->size)
    warn (_("There are %ld unused bytes at the end of section %s\n"),
	  (long) (section->start + section->size - start), section->name);
  putchar ('\n');
  free (array);
  return 1;
}

static int
display_debug_str (struct dwarf_section *section,
		   void *file ATTRIBUTE_UNUSED)
{
  unsigned char *start = section->start;
  unsigned long bytes = section->size;
  dwarf_vma addr = section->address;

  if (bytes == 0)
    {
      printf (_("\nThe %s section is empty.\n"), section->name);
      return 0;
    }

  printf (_("Contents of the %s section:\n\n"), section->name);

  while (bytes)
    {
      int j;
      int k;
      int lbytes;

      lbytes = (bytes > 16 ? 16 : bytes);

      printf ("  0x%8.8lx ", (unsigned long) addr);

      for (j = 0; j < 16; j++)
	{
	  if (j < lbytes)
	    printf ("%2.2x", start[j]);
	  else
	    printf ("  ");

	  if ((j & 3) == 3)
	    printf (" ");
	}

      for (j = 0; j < lbytes; j++)
	{
	  k = start[j];
	  if (k >= ' ' && k < 0x80)
	    printf ("%c", k);
	  else
	    printf (".");
	}

      putchar ('\n');

      start += lbytes;
      addr  += lbytes;
      bytes -= lbytes;
    }

  putchar ('\n');

  return 1;
}

static int
display_debug_info (struct dwarf_section *section, void *file)
{
  return process_debug_info (section, file, section->abbrev_sec, 0, 0);
}

static int
display_debug_types (struct dwarf_section *section, void *file)
{
  return process_debug_info (section, file, section->abbrev_sec, 0, 1);
}

static int
display_trace_info (struct dwarf_section *section, void *file)
{
  return process_debug_info (section, file, section->abbrev_sec, 0, 0);
}

static int
display_debug_aranges (struct dwarf_section *section,
		       void *file ATTRIBUTE_UNUSED)
{
  unsigned char *start = section->start;
  unsigned char *end = start + section->size;

  printf (_("Contents of the %s section:\n\n"), section->name);

  /* It does not matter if this load fails,
     we test for that later on.  */
  load_debug_info (file);

  while (start < end)
    {
      unsigned char *hdrptr;
      DWARF2_Internal_ARange arange;
      unsigned char *addr_ranges;
      dwarf_vma length;
      dwarf_vma address;
      unsigned char address_size;
      int excess;
      unsigned int offset_size;
      unsigned int initial_length_size;

      hdrptr = start;

      SAFE_BYTE_GET_AND_INC (arange.ar_length, hdrptr, 4, end);
      if (arange.ar_length == 0xffffffff)
	{
	  SAFE_BYTE_GET_AND_INC (arange.ar_length, hdrptr, 8, end);
	  offset_size = 8;
	  initial_length_size = 12;
	}
      else
	{
	  offset_size = 4;
	  initial_length_size = 4;
	}

      SAFE_BYTE_GET_AND_INC (arange.ar_version, hdrptr, 2, end);
      SAFE_BYTE_GET_AND_INC (arange.ar_info_offset, hdrptr, offset_size, end);

      if (num_debug_info_entries != DEBUG_INFO_UNAVAILABLE
	  && num_debug_info_entries > 0
	  && find_debug_info_for_offset (arange.ar_info_offset) == NULL)
	warn (_(".debug_info offset of 0x%lx in %s section does not point to a CU header.\n"),
	      (unsigned long) arange.ar_info_offset, section->name);

      SAFE_BYTE_GET_AND_INC (arange.ar_pointer_size, hdrptr, 1, end);
      SAFE_BYTE_GET_AND_INC (arange.ar_segment_size, hdrptr, 1, end);

      if (arange.ar_version != 2 && arange.ar_version != 3)
	{
	  warn (_("Only DWARF 2 and 3 aranges are currently supported.\n"));
	  break;
	}

      printf (_("  Length:                   %ld\n"),
	      (long) arange.ar_length);
      printf (_("  Version:                  %d\n"), arange.ar_version);
      printf (_("  Offset into .debug_info:  0x%lx\n"),
	      (unsigned long) arange.ar_info_offset);
      printf (_("  Pointer Size:             %d\n"), arange.ar_pointer_size);
      printf (_("  Segment Size:             %d\n"), arange.ar_segment_size);

      address_size = arange.ar_pointer_size + arange.ar_segment_size;

      if (address_size == 0)
	{
	  error (_("Invalid address size in %s section!\n"),
		 section->name);
	  break;
	}

      /* The DWARF spec does not require that the address size be a power
	 of two, but we do.  This will have to change if we ever encounter
	 an uneven architecture.  */
      if ((address_size & (address_size - 1)) != 0)
	{
	  warn (_("Pointer size + Segment size is not a power of two.\n"));
	  break;
	}

      if (address_size > 4)
	printf (_("\n    Address            Length\n"));
      else
	printf (_("\n    Address    Length\n"));

      addr_ranges = hdrptr;

      /* Must pad to an alignment boundary that is twice the address size.  */
      excess = (hdrptr - start) % (2 * address_size);
      if (excess)
	addr_ranges += (2 * address_size) - excess;

      start += arange.ar_length + initial_length_size;

      while (addr_ranges + 2 * address_size <= start)
	{
	  SAFE_BYTE_GET_AND_INC (address, addr_ranges, address_size, end);
	  SAFE_BYTE_GET_AND_INC (length, addr_ranges, address_size, end);

	  printf ("    ");
	  print_dwarf_vma (address, address_size);
	  print_dwarf_vma (length, address_size);
	  putchar ('\n');
	}
    }

  printf ("\n");

  return 1;
}

/* Comparison function for qsort.  */
static int
comp_addr_base (const void * v0, const void * v1)
{
  debug_info * info0 = (debug_info *) v0;
  debug_info * info1 = (debug_info *) v1;
  return info0->addr_base - info1->addr_base;
}

/* Display the debug_addr section.  */
static int
display_debug_addr (struct dwarf_section *section,
                    void *file)
{
  debug_info **debug_addr_info;
  unsigned char *entry;
  unsigned char *end;
  unsigned int i;
  unsigned int count;

  if (section->size == 0)
    {
      printf (_("\nThe %s section is empty.\n"), section->name);
      return 0;
    }

  if (load_debug_info (file) == 0)
    {
      warn (_("Unable to load/parse the .debug_info section, so cannot interpret the %s section.\n"),
	    section->name);
      return 0;
    }

  printf (_("Contents of the %s section:\n\n"), section->name);

  debug_addr_info = (debug_info **) xmalloc ((num_debug_info_entries + 1)
                                             * sizeof (debug_info *));

  count = 0;
  for (i = 0; i < num_debug_info_entries; i++)
    {
      if (debug_information [i].addr_base != DEBUG_INFO_UNAVAILABLE)
        debug_addr_info [count++] = &debug_information [i];
    }

  /* Add a sentinel to make iteration convenient.  */
  debug_addr_info [count] = (debug_info *) xmalloc (sizeof (debug_info));
  debug_addr_info [count]->addr_base = section->size;

  qsort (debug_addr_info, count, sizeof (debug_info *), comp_addr_base);
  for (i = 0; i < count; i++)
    {
      unsigned int idx;
      unsigned int address_size = debug_addr_info [i]->pointer_size;

      printf (_("  For compilation unit at offset 0x%s:\n"),
              dwarf_vmatoa ("x", debug_addr_info [i]->cu_offset));

      printf (_("\tIndex\tAddress\n"));
      entry = section->start + debug_addr_info [i]->addr_base;
      end = section->start + debug_addr_info [i + 1]->addr_base;
      idx = 0;
      while (entry < end)
        {
          dwarf_vma base = byte_get (entry, address_size);
          printf (_("\t%d:\t"), idx);
          print_dwarf_vma (base, address_size);
          printf ("\n");
          entry += address_size;
          idx++;
        }
    }
  printf ("\n");

  free (debug_addr_info);
  return 1;
}

/* Display the .debug_str_offsets and .debug_str_offsets.dwo sections.  */
static int
display_debug_str_offsets (struct dwarf_section *section,
                           void *file ATTRIBUTE_UNUSED)
{
  if (section->size == 0)
    {
      printf (_("\nThe %s section is empty.\n"), section->name);
      return 0;
    }
  /* TODO: Dump the contents.  This is made somewhat difficult by not knowing
     what the offset size is for this section.  */
  return 1;
}

/* Each debug_information[x].range_lists[y] gets this representation for
   sorting purposes.  */

struct range_entry
{
  /* The debug_information[x].range_lists[y] value.  */
  unsigned long ranges_offset;

  /* Original debug_information to find parameters of the data.  */
  debug_info *debug_info_p;
};

/* Sort struct range_entry in ascending order of its RANGES_OFFSET.  */

static int
range_entry_compar (const void *ap, const void *bp)
{
  const struct range_entry *a_re = (const struct range_entry *) ap;
  const struct range_entry *b_re = (const struct range_entry *) bp;
  const unsigned long a = a_re->ranges_offset;
  const unsigned long b = b_re->ranges_offset;

  return (a > b) - (b > a);
}

static int
display_debug_ranges (struct dwarf_section *section,
		      void *file ATTRIBUTE_UNUSED)
{
  unsigned char *start = section->start;
  unsigned char *last_start = start;
  unsigned long bytes = section->size;
  unsigned char *section_begin = start;
  unsigned char *finish = start + bytes;
  unsigned int num_range_list, i;
  struct range_entry *range_entries, *range_entry_fill;

  if (bytes == 0)
    {
      printf (_("\nThe %s section is empty.\n"), section->name);
      return 0;
    }

  if (load_debug_info (file) == 0)
    {
      warn (_("Unable to load/parse the .debug_info section, so cannot interpret the %s section.\n"),
	    section->name);
      return 0;
    }

  num_range_list = 0;
  for (i = 0; i < num_debug_info_entries; i++)
    num_range_list += debug_information [i].num_range_lists;

  if (num_range_list == 0)
    {
      /* This can happen when the file was compiled with -gsplit-debug
         which removes references to range lists from the primary .o file.  */
      printf (_("No range lists in .debug_info section.\n"));
      return 1;
    }

  range_entries = (struct range_entry *)
      xmalloc (sizeof (*range_entries) * num_range_list);
  range_entry_fill = range_entries;

  for (i = 0; i < num_debug_info_entries; i++)
    {
      debug_info *debug_info_p = &debug_information[i];
      unsigned int j;

      for (j = 0; j < debug_info_p->num_range_lists; j++)
	{
	  range_entry_fill->ranges_offset = debug_info_p->range_lists[j];
	  range_entry_fill->debug_info_p = debug_info_p;
	  range_entry_fill++;
	}
    }

  qsort (range_entries, num_range_list, sizeof (*range_entries),
	 range_entry_compar);

  /* DWARF sections under Mach-O have non-zero addresses.  */
  if (dwarf_check != 0 && range_entries[0].ranges_offset != section->address)
    warn (_("Range lists in %s section start at 0x%lx\n"),
	  section->name, range_entries[0].ranges_offset);

  printf (_("Contents of the %s section:\n\n"), section->name);
  printf (_("    Offset   Begin    End\n"));

  for (i = 0; i < num_range_list; i++)
    {
      struct range_entry *range_entry = &range_entries[i];
      debug_info *debug_info_p = range_entry->debug_info_p;
      unsigned int pointer_size;
      unsigned long offset;
      unsigned char *next;
      unsigned long base_address;

      pointer_size = debug_info_p->pointer_size;

      /* DWARF sections under Mach-O have non-zero addresses.  */
      offset = range_entry->ranges_offset - section->address;
      next = section_begin + offset;
      base_address = debug_info_p->base_address;

      if (dwarf_check != 0 && i > 0)
	{
	  if (start < next)
	    warn (_("There is a hole [0x%lx - 0x%lx] in %s section.\n"),
		  (unsigned long) (start - section_begin),
		  (unsigned long) (next - section_begin), section->name);
	  else if (start > next)
	    {
	      if (next == last_start)
		continue;
	      warn (_("There is an overlap [0x%lx - 0x%lx] in %s section.\n"),
		    (unsigned long) (start - section_begin),
		    (unsigned long) (next - section_begin), section->name);
	    }
	}
      start = next;
      last_start = next;

      while (start < finish)
	{
	  dwarf_vma begin;
	  dwarf_vma end;

	  /* Note: we use sign extension here in order to be sure that
	     we can detect the -1 escape value.  Sign extension into the
	     top 32 bits of a 32-bit address will not affect the values
	     that we display since we always show hex values, and always
	     the bottom 32-bits.  */
	  SAFE_BYTE_GET_AND_INC (begin, start, pointer_size, finish);
	  if (start >= finish)
	    break;
	  SAFE_SIGNED_BYTE_GET_AND_INC (end, start, pointer_size, finish);

	  printf ("    %8.8lx ", offset);

	  if (begin == 0 && end == 0)
	    {
	      printf (_("<End of list>\n"));
	      break;
	    }

	  /* Check base address specifiers.  */
	  if (begin == (dwarf_vma) -1 && end != (dwarf_vma) -1)
	    {
	      base_address = end;
	      print_dwarf_vma (begin, pointer_size);
	      print_dwarf_vma (end, pointer_size);
	      printf ("(base address)\n");
	      continue;
	    }

	  print_dwarf_vma (begin + base_address, pointer_size);
	  print_dwarf_vma (end + base_address, pointer_size);

	  if (begin == end)
	    fputs (_("(start == end)"), stdout);
	  else if (begin > end)
	    fputs (_("(start > end)"), stdout);

	  putchar ('\n');
	}
    }
  putchar ('\n');

  free (range_entries);

  return 1;
}

typedef struct Frame_Chunk
{
  struct Frame_Chunk *next;
  unsigned char *chunk_start;
  int ncols;
  /* DW_CFA_{undefined,same_value,offset,register,unreferenced}  */
  short int *col_type;
  int *col_offset;
  char *augmentation;
  unsigned int code_factor;
  int data_factor;
  dwarf_vma pc_begin;
  dwarf_vma pc_range;
  int cfa_reg;
  int cfa_offset;
  int ra;
  unsigned char fde_encoding;
  unsigned char cfa_exp;
  unsigned char ptr_size;
  unsigned char segment_size;
}
Frame_Chunk;

static const char *const *dwarf_regnames;
static unsigned int dwarf_regnames_count;

/* A marker for a col_type that means this column was never referenced
   in the frame info.  */
#define DW_CFA_unreferenced (-1)

/* Return 0 if not more space is needed, 1 if more space is needed,
   -1 for invalid reg.  */

static int
frame_need_space (Frame_Chunk *fc, unsigned int reg)
{
  int prev = fc->ncols;

  if (reg < (unsigned int) fc->ncols)
    return 0;

  if (dwarf_regnames_count
      && reg > dwarf_regnames_count)
    return -1;

  fc->ncols = reg + 1;
  fc->col_type = (short int *) xcrealloc (fc->col_type, fc->ncols,
                                          sizeof (short int));
  fc->col_offset = (int *) xcrealloc (fc->col_offset, fc->ncols, sizeof (int));

  while (prev < fc->ncols)
    {
      fc->col_type[prev] = DW_CFA_unreferenced;
      fc->col_offset[prev] = 0;
      prev++;
    }
  return 1;
}

static const char *const dwarf_regnames_i386[] =
{
  "eax", "ecx", "edx", "ebx",			  /* 0 - 3  */
  "esp", "ebp", "esi", "edi",			  /* 4 - 7  */
  "eip", "eflags", NULL,			  /* 8 - 10  */
  "st0", "st1", "st2", "st3",			  /* 11 - 14  */
  "st4", "st5", "st6", "st7",			  /* 15 - 18  */
  NULL, NULL,					  /* 19 - 20  */
  "xmm0", "xmm1", "xmm2", "xmm3",		  /* 21 - 24  */
  "xmm4", "xmm5", "xmm6", "xmm7",		  /* 25 - 28  */
  "mm0", "mm1", "mm2", "mm3",			  /* 29 - 32  */
  "mm4", "mm5", "mm6", "mm7",			  /* 33 - 36  */
  "fcw", "fsw", "mxcsr",			  /* 37 - 39  */
  "es", "cs", "ss", "ds", "fs", "gs", NULL, NULL, /* 40 - 47  */
  "tr", "ldtr",					  /* 48 - 49  */
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, /* 50 - 57  */
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, /* 58 - 65  */
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, /* 66 - 73  */
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, /* 74 - 81  */
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, /* 82 - 89  */
  NULL, NULL, NULL,				  /* 90 - 92  */
  "k0", "k1", "k2", "k3", "k4", "k5", "k6", "k7"  /* 93 - 100  */
};

void
init_dwarf_regnames_i386 (void)
{
  dwarf_regnames = dwarf_regnames_i386;
  dwarf_regnames_count = ARRAY_SIZE (dwarf_regnames_i386);
}

static const char *const dwarf_regnames_x86_64[] =
{
  "rax", "rdx", "rcx", "rbx",
  "rsi", "rdi", "rbp", "rsp",
  "r8",  "r9",  "r10", "r11",
  "r12", "r13", "r14", "r15",
  "rip",
  "xmm0",  "xmm1",  "xmm2",  "xmm3",
  "xmm4",  "xmm5",  "xmm6",  "xmm7",
  "xmm8",  "xmm9",  "xmm10", "xmm11",
  "xmm12", "xmm13", "xmm14", "xmm15",
  "st0", "st1", "st2", "st3",
  "st4", "st5", "st6", "st7",
  "mm0", "mm1", "mm2", "mm3",
  "mm4", "mm5", "mm6", "mm7",
  "rflags",
  "es", "cs", "ss", "ds", "fs", "gs", NULL, NULL,
  "fs.base", "gs.base", NULL, NULL,
  "tr", "ldtr",
  "mxcsr", "fcw", "fsw",
  "xmm16",  "xmm17",  "xmm18",  "xmm19",
  "xmm20",  "xmm21",  "xmm22",  "xmm23",
  "xmm24",  "xmm25",  "xmm26",  "xmm27",
  "xmm28",  "xmm29",  "xmm30",  "xmm31",
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, /* 83 - 90  */
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, /* 91 - 98  */
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, /* 99 - 106  */
  NULL, NULL, NULL, NULL, NULL, NULL, NULL, NULL, /* 107 - 114  */
  NULL, NULL, NULL,				  /* 115 - 117  */
  "k0", "k1", "k2", "k3", "k4", "k5", "k6", "k7"
};

void
init_dwarf_regnames_x86_64 (void)
{
  dwarf_regnames = dwarf_regnames_x86_64;
  dwarf_regnames_count = ARRAY_SIZE (dwarf_regnames_x86_64);
}

void
init_dwarf_regnames (unsigned int e_machine)
{
  switch (e_machine)
    {
    case EM_386:
    case EM_486:
      init_dwarf_regnames_i386 ();
      break;

    case EM_X86_64:
    case EM_L1OM:
    case EM_K1OM:
      init_dwarf_regnames_x86_64 ();
      break;

    default:
      break;
    }
}

static const char *
regname (unsigned int regno, int row)
{
  static char reg[64];
  if (dwarf_regnames
      && regno < dwarf_regnames_count
      && dwarf_regnames [regno] != NULL)
    {
      if (row)
	return dwarf_regnames [regno];
      snprintf (reg, sizeof (reg), "r%d (%s)", regno,
		dwarf_regnames [regno]);
    }
  else
    snprintf (reg, sizeof (reg), "r%d", regno);
  return reg;
}

static void
frame_display_row (Frame_Chunk *fc, int *need_col_headers, int *max_regs)
{
  int r;
  char tmp[100];

  if (*max_regs < fc->ncols)
    *max_regs = fc->ncols;

  if (*need_col_headers)
    {
      static const char *sloc = "   LOC";

      *need_col_headers = 0;

      printf ("%-*s CFA      ", eh_addr_size * 2, sloc);

      for (r = 0; r < *max_regs; r++)
	if (fc->col_type[r] != DW_CFA_unreferenced)
	  {
	    if (r == fc->ra)
	      printf ("ra      ");
	    else
	      printf ("%-5s ", regname (r, 1));
	  }

      printf ("\n");
    }

  print_dwarf_vma (fc->pc_begin, eh_addr_size);
  if (fc->cfa_exp)
    strcpy (tmp, "exp");
  else
    sprintf (tmp, "%s%+d", regname (fc->cfa_reg, 1), fc->cfa_offset);
  printf ("%-8s ", tmp);

  for (r = 0; r < fc->ncols; r++)
    {
      if (fc->col_type[r] != DW_CFA_unreferenced)
	{
	  switch (fc->col_type[r])
	    {
	    case DW_CFA_undefined:
	      strcpy (tmp, "u");
	      break;
	    case DW_CFA_same_value:
	      strcpy (tmp, "s");
	      break;
	    case DW_CFA_offset:
	      sprintf (tmp, "c%+d", fc->col_offset[r]);
	      break;
	    case DW_CFA_val_offset:
	      sprintf (tmp, "v%+d", fc->col_offset[r]);
	      break;
	    case DW_CFA_register:
	      sprintf (tmp, "%s", regname (fc->col_offset[r], 0));
	      break;
	    case DW_CFA_expression:
	      strcpy (tmp, "exp");
	      break;
	    case DW_CFA_val_expression:
	      strcpy (tmp, "vexp");
	      break;
	    default:
	      strcpy (tmp, "n/a");
	      break;
	    }
	  printf ("%-5s ", tmp);
	}
    }
  printf ("\n");
}

#define GET(VAR, N)	SAFE_BYTE_GET_AND_INC (VAR, start, N, end);
#define LEB()	read_uleb128 (start, & length_return, end); start += length_return
#define SLEB()	read_sleb128 (start, & length_return, end); start += length_return

static int
display_debug_frames (struct dwarf_section *section,
		      void *file ATTRIBUTE_UNUSED)
{
  unsigned char *start = section->start;
  unsigned char *end = start + section->size;
  unsigned char *section_start = start;
  Frame_Chunk *chunks = 0;
  Frame_Chunk *remembered_state = 0;
  Frame_Chunk *rs;
  int is_eh = strcmp (section->name, ".eh_frame") == 0;
  unsigned int length_return;
  int max_regs = 0;
  const char *bad_reg = _("bad register: ");
  int saved_eh_addr_size = eh_addr_size;

  printf (_("Contents of the %s section:\n"), section->name);

  while (start < end)
    {
      unsigned char *saved_start;
      unsigned char *block_end;
      dwarf_vma length;
      dwarf_vma cie_id;
      Frame_Chunk *fc;
      Frame_Chunk *cie;
      int need_col_headers = 1;
      unsigned char *augmentation_data = NULL;
      unsigned long augmentation_data_len = 0;
      unsigned int encoded_ptr_size = saved_eh_addr_size;
      unsigned int offset_size;
      unsigned int initial_length_size;

      saved_start = start;

      SAFE_BYTE_GET_AND_INC (length, start, 4, end);
      if (length == 0)
	{
	  printf ("\n%08lx ZERO terminator\n\n",
		    (unsigned long)(saved_start - section_start));
	  continue;
	}

      if (length == 0xffffffff)
	{
	  SAFE_BYTE_GET_AND_INC (length, start, 8, end);
	  offset_size = 8;
	  initial_length_size = 12;
	}
      else
	{
	  offset_size = 4;
	  initial_length_size = 4;
	}

      block_end = saved_start + length + initial_length_size;
      if (block_end > end)
	{
	  warn ("Invalid length 0x%s in FDE at %#08lx\n",
		dwarf_vmatoa_1 (NULL, length, offset_size),
		(unsigned long) (saved_start - section_start));
	  block_end = end;
	}

      SAFE_BYTE_GET_AND_INC (cie_id, start, offset_size, end);

      if (is_eh ? (cie_id == 0) : ((offset_size == 4 && cie_id == DW_CIE_ID)
				   || (offset_size == 8 && cie_id == DW64_CIE_ID)))
	{
	  int version;

	  fc = (Frame_Chunk *) xmalloc (sizeof (Frame_Chunk));
	  memset (fc, 0, sizeof (Frame_Chunk));

	  fc->next = chunks;
	  chunks = fc;
	  fc->chunk_start = saved_start;
	  fc->ncols = 0;
	  fc->col_type = (short int *) xmalloc (sizeof (short int));
	  fc->col_offset = (int *) xmalloc (sizeof (int));
	  frame_need_space (fc, max_regs - 1);

	  version = *start++;

	  fc->augmentation = (char *) start;
	  start = (unsigned char *) strchr ((char *) start, '\0') + 1;

	  if (strcmp (fc->augmentation, "eh") == 0)
	    start += eh_addr_size;

	  if (version >= 4)
	    {
	      GET (fc->ptr_size, 1);
	      GET (fc->segment_size, 1);
	      eh_addr_size = fc->ptr_size;
	    }
	  else
	    {
	      fc->ptr_size = eh_addr_size;
	      fc->segment_size = 0;
	    }
	  fc->code_factor = LEB ();
	  fc->data_factor = SLEB ();
	  if (version == 1)
	    {
	      GET (fc->ra, 1);
	    }
	  else
	    {
	      fc->ra = LEB ();
	    }

	  if (fc->augmentation[0] == 'z')
	    {
	      augmentation_data_len = LEB ();
	      augmentation_data = start;
	      start += augmentation_data_len;
	    }
	  cie = fc;

	  printf ("\n%08lx ", (unsigned long) (saved_start - section_start));
	  print_dwarf_vma (length, fc->ptr_size);
	  print_dwarf_vma (cie_id, offset_size);

	  if (do_debug_frames_interp)
	    {
	      printf ("CIE \"%s\" cf=%d df=%d ra=%d\n", fc->augmentation,
		      fc->code_factor, fc->data_factor, fc->ra);
	    }
	  else
	    {
	      printf ("CIE\n");
	      printf ("  Version:               %d\n", version);
	      printf ("  Augmentation:          \"%s\"\n", fc->augmentation);
	      if (version >= 4)
		{
		  printf ("  Pointer Size:          %u\n", fc->ptr_size);
		  printf ("  Segment Size:          %u\n", fc->segment_size);
		}
	      printf ("  Code alignment factor: %u\n", fc->code_factor);
	      printf ("  Data alignment factor: %d\n", fc->data_factor);
	      printf ("  Return address column: %d\n", fc->ra);

	      if (augmentation_data_len)
		{
		  unsigned long i;
		  printf ("  Augmentation data:    ");
		  for (i = 0; i < augmentation_data_len; ++i)
		    printf (" %02x", augmentation_data[i]);
		  putchar ('\n');
		}
	      putchar ('\n');
	    }

	  if (augmentation_data_len)
	    {
	      unsigned char *p, *q;
	      p = (unsigned char *) fc->augmentation + 1;
	      q = augmentation_data;

	      while (1)
		{
		  if (*p == 'L')
		    q++;
		  else if (*p == 'P')
		    q += 1 + size_of_encoded_value (*q);
		  else if (*p == 'R')
		    fc->fde_encoding = *q++;
		  else if (*p == 'S')
		    ;
		  else
		    break;
		  p++;
		}

	      if (fc->fde_encoding)
		encoded_ptr_size = size_of_encoded_value (fc->fde_encoding);
	    }

	  frame_need_space (fc, fc->ra);
	}
      else
	{
	  unsigned char *look_for;
	  static Frame_Chunk fde_fc;
	  unsigned long segment_selector;

	  fc = & fde_fc;
	  memset (fc, 0, sizeof (Frame_Chunk));

	  look_for = is_eh ? start - 4 - cie_id : section_start + cie_id;

	  for (cie = chunks; cie ; cie = cie->next)
	    if (cie->chunk_start == look_for)
	      break;

	  if (!cie)
	    {
	      warn ("Invalid CIE pointer 0x%s in FDE at %#08lx\n",
		    dwarf_vmatoa_1 (NULL, cie_id, offset_size),
		    (unsigned long) (saved_start - section_start));
	      fc->ncols = 0;
	      fc->col_type = (short int *) xmalloc (sizeof (short int));
	      fc->col_offset = (int *) xmalloc (sizeof (int));
	      frame_need_space (fc, max_regs - 1);
	      cie = fc;
	      fc->augmentation = "";
	      fc->fde_encoding = 0;
	      fc->ptr_size = eh_addr_size;
	      fc->segment_size = 0;
	    }
	  else
	    {
	      fc->ncols = cie->ncols;
	      fc->col_type = (short int *) xcmalloc (fc->ncols, sizeof (short int));
	      fc->col_offset =  (int *) xcmalloc (fc->ncols, sizeof (int));
	      memcpy (fc->col_type, cie->col_type, fc->ncols * sizeof (short int));
	      memcpy (fc->col_offset, cie->col_offset, fc->ncols * sizeof (int));
	      fc->augmentation = cie->augmentation;
	      fc->ptr_size = cie->ptr_size;
	      eh_addr_size = cie->ptr_size;
	      fc->segment_size = cie->segment_size;
	      fc->code_factor = cie->code_factor;
	      fc->data_factor = cie->data_factor;
	      fc->cfa_reg = cie->cfa_reg;
	      fc->cfa_offset = cie->cfa_offset;
	      fc->ra = cie->ra;
	      frame_need_space (fc, max_regs - 1);
	      fc->fde_encoding = cie->fde_encoding;
	    }

	  if (fc->fde_encoding)
	    encoded_ptr_size = size_of_encoded_value (fc->fde_encoding);

	  segment_selector = 0;
	  if (fc->segment_size)
	    {
	      SAFE_BYTE_GET_AND_INC (segment_selector, start, fc->segment_size, end);
	    }
	  fc->pc_begin = get_encoded_value (start, fc->fde_encoding, section);
	  start += encoded_ptr_size;

	  /* FIXME: It appears that sometimes the final pc_range value is
	     encoded in less than encoded_ptr_size bytes.  See the x86_64
	     run of the "objcopy on compressed debug sections" test for an
	     example of this.  */
	  SAFE_BYTE_GET_AND_INC (fc->pc_range, start, encoded_ptr_size, end);

	  if (cie->augmentation[0] == 'z')
	    {
	      augmentation_data_len = LEB ();
	      augmentation_data = start;
	      start += augmentation_data_len;
	    }

	  printf ("\n%08lx %s %s FDE cie=%08lx pc=",
		  (unsigned long)(saved_start - section_start),
		  dwarf_vmatoa_1 (NULL, length, fc->ptr_size),
		  dwarf_vmatoa_1 (NULL, cie_id, offset_size),
		  (unsigned long)(cie->chunk_start - section_start));

	  if (fc->segment_size)
	    printf ("%04lx:", segment_selector);

	  printf ("%s..%s\n",
		  dwarf_vmatoa_1 (NULL, fc->pc_begin, fc->ptr_size),
		  dwarf_vmatoa_1 (NULL, fc->pc_begin + fc->pc_range, fc->ptr_size));

	  if (! do_debug_frames_interp && augmentation_data_len)
	    {
	      unsigned long i;

	      printf ("  Augmentation data:    ");
	      for (i = 0; i < augmentation_data_len; ++i)
		printf (" %02x", augmentation_data[i]);
	      putchar ('\n');
	      putchar ('\n');
	    }
	}

      /* At this point, fc is the current chunk, cie (if any) is set, and
	 we're about to interpret instructions for the chunk.  */
      /* ??? At present we need to do this always, since this sizes the
	 fc->col_type and fc->col_offset arrays, which we write into always.
	 We should probably split the interpreted and non-interpreted bits
	 into two different routines, since there's so much that doesn't
	 really overlap between them.  */
      if (1 || do_debug_frames_interp)
	{
	  /* Start by making a pass over the chunk, allocating storage
	     and taking note of what registers are used.  */
	  unsigned char *tmp = start;

	  while (start < block_end)
	    {
	      unsigned op, opa;
	      unsigned long reg, temp;

	      op = *start++;
	      opa = op & 0x3f;
	      if (op & 0xc0)
		op &= 0xc0;

	      /* Warning: if you add any more cases to this switch, be
		 sure to add them to the corresponding switch below.  */
	      switch (op)
		{
		case DW_CFA_advance_loc:
		  break;
		case DW_CFA_offset:
		  LEB ();
		  if (frame_need_space (fc, opa) >= 0)
		    fc->col_type[opa] = DW_CFA_undefined;
		  break;
		case DW_CFA_restore:
		  if (frame_need_space (fc, opa) >= 0)
		    fc->col_type[opa] = DW_CFA_undefined;
		  break;
		case DW_CFA_set_loc:
		  start += encoded_ptr_size;
		  break;
		case DW_CFA_advance_loc1:
		  start += 1;
		  break;
		case DW_CFA_advance_loc2:
		  start += 2;
		  break;
		case DW_CFA_advance_loc4:
		  start += 4;
		  break;
		case DW_CFA_offset_extended:
		case DW_CFA_val_offset:
		  reg = LEB (); LEB ();
		  if (frame_need_space (fc, reg) >= 0)
		    fc->col_type[reg] = DW_CFA_undefined;
		  break;
		case DW_CFA_restore_extended:
		  reg = LEB ();
		  frame_need_space (fc, reg);
		  if (frame_need_space (fc, reg) >= 0)
		    fc->col_type[reg] = DW_CFA_undefined;
		  break;
		case DW_CFA_undefined:
		  reg = LEB ();
		  if (frame_need_space (fc, reg) >= 0)
		    fc->col_type[reg] = DW_CFA_undefined;
		  break;
		case DW_CFA_same_value:
		  reg = LEB ();
		  if (frame_need_space (fc, reg) >= 0)
		    fc->col_type[reg] = DW_CFA_undefined;
		  break;
		case DW_CFA_register:
		  reg = LEB (); LEB ();
		  if (frame_need_space (fc, reg) >= 0)
		    fc->col_type[reg] = DW_CFA_undefined;
		  break;
		case DW_CFA_def_cfa:
		  LEB (); LEB ();
		  break;
		case DW_CFA_def_cfa_register:
		  LEB ();
		  break;
		case DW_CFA_def_cfa_offset:
		  LEB ();
		  break;
		case DW_CFA_def_cfa_expression:
		  temp = LEB ();
		  start += temp;
		  break;
		case DW_CFA_expression:
		case DW_CFA_val_expression:
		  reg = LEB ();
		  temp = LEB ();
		  start += temp;
		  if (frame_need_space (fc, reg) >= 0)
		    fc->col_type[reg] = DW_CFA_undefined;
		  break;
		case DW_CFA_offset_extended_sf:
		case DW_CFA_val_offset_sf:
		  reg = LEB (); SLEB ();
		  if (frame_need_space (fc, reg) >= 0)
		    fc->col_type[reg] = DW_CFA_undefined;
		  break;
		case DW_CFA_def_cfa_sf:
		  LEB (); SLEB ();
		  break;
		case DW_CFA_def_cfa_offset_sf:
		  SLEB ();
		  break;
		case DW_CFA_MIPS_advance_loc8:
		  start += 8;
		  break;
		case DW_CFA_GNU_args_size:
		  LEB ();
		  break;
		case DW_CFA_GNU_negative_offset_extended:
		  reg = LEB (); LEB ();
		  if (frame_need_space (fc, reg) >= 0)
		    fc->col_type[reg] = DW_CFA_undefined;
		  break;
		default:
		  break;
		}
	    }
	  start = tmp;
	}

      /* Now we know what registers are used, make a second pass over
	 the chunk, this time actually printing out the info.  */

      while (start < block_end)
	{
	  unsigned op, opa;
	  unsigned long ul, reg, roffs;
	  long l;
	  dwarf_vma ofs;
	  dwarf_vma vma;
	  const char *reg_prefix = "";

	  op = *start++;
	  opa = op & 0x3f;
	  if (op & 0xc0)
	    op &= 0xc0;

	  /* Warning: if you add any more cases to this switch, be
	     sure to add them to the corresponding switch above.  */
	  switch (op)
	    {
	    case DW_CFA_advance_loc:
	      if (do_debug_frames_interp)
		frame_display_row (fc, &need_col_headers, &max_regs);
	      else
		printf ("  DW_CFA_advance_loc: %d to %s\n",
			opa * fc->code_factor,
			dwarf_vmatoa_1 (NULL, 
					fc->pc_begin + opa * fc->code_factor,
					fc->ptr_size));
	      fc->pc_begin += opa * fc->code_factor;
	      break;

	    case DW_CFA_offset:
	      roffs = LEB ();
	      if (opa >= (unsigned int) fc->ncols)
		reg_prefix = bad_reg;
	      if (! do_debug_frames_interp || *reg_prefix != '\0')
		printf ("  DW_CFA_offset: %s%s at cfa%+ld\n",
			reg_prefix, regname (opa, 0),
			roffs * fc->data_factor);
	      if (*reg_prefix == '\0')
		{
		  fc->col_type[opa] = DW_CFA_offset;
		  fc->col_offset[opa] = roffs * fc->data_factor;
		}
	      break;

	    case DW_CFA_restore:
	      if (opa >= (unsigned int) cie->ncols
		  || opa >= (unsigned int) fc->ncols)
		reg_prefix = bad_reg;
	      if (! do_debug_frames_interp || *reg_prefix != '\0')
		printf ("  DW_CFA_restore: %s%s\n",
			reg_prefix, regname (opa, 0));
	      if (*reg_prefix == '\0')
		{
		  fc->col_type[opa] = cie->col_type[opa];
		  fc->col_offset[opa] = cie->col_offset[opa];
		  if (do_debug_frames_interp
		      && fc->col_type[opa] == DW_CFA_unreferenced)
		    fc->col_type[opa] = DW_CFA_undefined;
		}
	      break;

	    case DW_CFA_set_loc:
	      vma = get_encoded_value (start, fc->fde_encoding, section);
	      start += encoded_ptr_size;
	      if (do_debug_frames_interp)
		frame_display_row (fc, &need_col_headers, &max_regs);
	      else
		printf ("  DW_CFA_set_loc: %s\n",
			dwarf_vmatoa_1 (NULL, vma, fc->ptr_size));
	      fc->pc_begin = vma;
	      break;

	    case DW_CFA_advance_loc1:
	      SAFE_BYTE_GET_AND_INC (ofs, start, 1, end);
	      if (do_debug_frames_interp)
		frame_display_row (fc, &need_col_headers, &max_regs);
	      else
		printf ("  DW_CFA_advance_loc1: %ld to %s\n",
			(unsigned long) (ofs * fc->code_factor),
			dwarf_vmatoa_1 (NULL,
					fc->pc_begin + ofs * fc->code_factor,
					fc->ptr_size));
	      fc->pc_begin += ofs * fc->code_factor;
	      break;

	    case DW_CFA_advance_loc2:
	      SAFE_BYTE_GET_AND_INC (ofs, start, 2, end);
	      if (do_debug_frames_interp)
		frame_display_row (fc, &need_col_headers, &max_regs);
	      else
		printf ("  DW_CFA_advance_loc2: %ld to %s\n",
			(unsigned long) (ofs * fc->code_factor),
			dwarf_vmatoa_1 (NULL,
					fc->pc_begin + ofs * fc->code_factor,
					fc->ptr_size));
	      fc->pc_begin += ofs * fc->code_factor;
	      break;

	    case DW_CFA_advance_loc4:
	      SAFE_BYTE_GET_AND_INC (ofs, start, 4, end);
	      if (do_debug_frames_interp)
		frame_display_row (fc, &need_col_headers, &max_regs);
	      else
		printf ("  DW_CFA_advance_loc4: %ld to %s\n",
			(unsigned long) (ofs * fc->code_factor),
			dwarf_vmatoa_1 (NULL,
					fc->pc_begin + ofs * fc->code_factor,
					fc->ptr_size));
	      fc->pc_begin += ofs * fc->code_factor;
	      break;

	    case DW_CFA_offset_extended:
	      reg = LEB ();
	      roffs = LEB ();
	      if (reg >= (unsigned int) fc->ncols)
		reg_prefix = bad_reg;
	      if (! do_debug_frames_interp || *reg_prefix != '\0')
		printf ("  DW_CFA_offset_extended: %s%s at cfa%+ld\n",
			reg_prefix, regname (reg, 0),
			roffs * fc->data_factor);
	      if (*reg_prefix == '\0')
		{
		  fc->col_type[reg] = DW_CFA_offset;
		  fc->col_offset[reg] = roffs * fc->data_factor;
		}
	      break;

	    case DW_CFA_val_offset:
	      reg = LEB ();
	      roffs = LEB ();
	      if (reg >= (unsigned int) fc->ncols)
		reg_prefix = bad_reg;
	      if (! do_debug_frames_interp || *reg_prefix != '\0')
		printf ("  DW_CFA_val_offset: %s%s at cfa%+ld\n",
			reg_prefix, regname (reg, 0),
			roffs * fc->data_factor);
	      if (*reg_prefix == '\0')
		{
		  fc->col_type[reg] = DW_CFA_val_offset;
		  fc->col_offset[reg] = roffs * fc->data_factor;
		}
	      break;

	    case DW_CFA_restore_extended:
	      reg = LEB ();
	      if (reg >= (unsigned int) cie->ncols
		  || reg >= (unsigned int) fc->ncols)
		reg_prefix = bad_reg;
	      if (! do_debug_frames_interp || *reg_prefix != '\0')
		printf ("  DW_CFA_restore_extended: %s%s\n",
			reg_prefix, regname (reg, 0));
	      if (*reg_prefix == '\0')
		{
		  fc->col_type[reg] = cie->col_type[reg];
		  fc->col_offset[reg] = cie->col_offset[reg];
		}
	      break;

	    case DW_CFA_undefined:
	      reg = LEB ();
	      if (reg >= (unsigned int) fc->ncols)
		reg_prefix = bad_reg;
	      if (! do_debug_frames_interp || *reg_prefix != '\0')
		printf ("  DW_CFA_undefined: %s%s\n",
			reg_prefix, regname (reg, 0));
	      if (*reg_prefix == '\0')
		{
		  fc->col_type[reg] = DW_CFA_undefined;
		  fc->col_offset[reg] = 0;
		}
	      break;

	    case DW_CFA_same_value:
	      reg = LEB ();
	      if (reg >= (unsigned int) fc->ncols)
		reg_prefix = bad_reg;
	      if (! do_debug_frames_interp || *reg_prefix != '\0')
		printf ("  DW_CFA_same_value: %s%s\n",
			reg_prefix, regname (reg, 0));
	      if (*reg_prefix == '\0')
		{
		  fc->col_type[reg] = DW_CFA_same_value;
		  fc->col_offset[reg] = 0;
		}
	      break;

	    case DW_CFA_register:
	      reg = LEB ();
	      roffs = LEB ();
	      if (reg >= (unsigned int) fc->ncols)
		reg_prefix = bad_reg;
	      if (! do_debug_frames_interp || *reg_prefix != '\0')
		{
		  printf ("  DW_CFA_register: %s%s in ",
			  reg_prefix, regname (reg, 0));
		  puts (regname (roffs, 0));
		}
	      if (*reg_prefix == '\0')
		{
		  fc->col_type[reg] = DW_CFA_register;
		  fc->col_offset[reg] = roffs;
		}
	      break;

	    case DW_CFA_remember_state:
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_remember_state\n");
	      rs = (Frame_Chunk *) xmalloc (sizeof (Frame_Chunk));
	      rs->ncols = fc->ncols;
	      rs->col_type = (short int *) xcmalloc (rs->ncols,
                                                     sizeof (short int));
	      rs->col_offset = (int *) xcmalloc (rs->ncols, sizeof (int));
	      memcpy (rs->col_type, fc->col_type, rs->ncols);
	      memcpy (rs->col_offset, fc->col_offset, rs->ncols * sizeof (int));
	      rs->next = remembered_state;
	      remembered_state = rs;
	      break;

	    case DW_CFA_restore_state:
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_restore_state\n");
	      rs = remembered_state;
	      if (rs)
		{
		  remembered_state = rs->next;
		  frame_need_space (fc, rs->ncols - 1);
		  memcpy (fc->col_type, rs->col_type, rs->ncols);
		  memcpy (fc->col_offset, rs->col_offset,
			  rs->ncols * sizeof (int));
		  free (rs->col_type);
		  free (rs->col_offset);
		  free (rs);
		}
	      else if (do_debug_frames_interp)
		printf ("Mismatched DW_CFA_restore_state\n");
	      break;

	    case DW_CFA_def_cfa:
	      fc->cfa_reg = LEB ();
	      fc->cfa_offset = LEB ();
	      fc->cfa_exp = 0;
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_def_cfa: %s ofs %d\n",
			regname (fc->cfa_reg, 0), fc->cfa_offset);
	      break;

	    case DW_CFA_def_cfa_register:
	      fc->cfa_reg = LEB ();
	      fc->cfa_exp = 0;
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_def_cfa_register: %s\n",
			regname (fc->cfa_reg, 0));
	      break;

	    case DW_CFA_def_cfa_offset:
	      fc->cfa_offset = LEB ();
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_def_cfa_offset: %d\n", fc->cfa_offset);
	      break;

	    case DW_CFA_nop:
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_nop\n");
	      break;

	    case DW_CFA_def_cfa_expression:
	      ul = LEB ();
	      if (! do_debug_frames_interp)
		{
		  printf ("  DW_CFA_def_cfa_expression (");
		  decode_location_expression (start, eh_addr_size, 0, -1,
					      ul, 0, section);
		  printf (")\n");
		}
	      fc->cfa_exp = 1;
	      start += ul;
	      break;

	    case DW_CFA_expression:
	      reg = LEB ();
	      ul = LEB ();
	      if (reg >= (unsigned int) fc->ncols)
		reg_prefix = bad_reg;
	      if (! do_debug_frames_interp || *reg_prefix != '\0')
		{
		  printf ("  DW_CFA_expression: %s%s (",
			  reg_prefix, regname (reg, 0));
		  decode_location_expression (start, eh_addr_size, 0, -1,
					      ul, 0, section);
		  printf (")\n");
		}
	      if (*reg_prefix == '\0')
		fc->col_type[reg] = DW_CFA_expression;
	      start += ul;
	      break;

	    case DW_CFA_val_expression:
	      reg = LEB ();
	      ul = LEB ();
	      if (reg >= (unsigned int) fc->ncols)
		reg_prefix = bad_reg;
	      if (! do_debug_frames_interp || *reg_prefix != '\0')
		{
		  printf ("  DW_CFA_val_expression: %s%s (",
			  reg_prefix, regname (reg, 0));
		  decode_location_expression (start, eh_addr_size, 0, -1,
					      ul, 0, section);
		  printf (")\n");
		}
	      if (*reg_prefix == '\0')
		fc->col_type[reg] = DW_CFA_val_expression;
	      start += ul;
	      break;

	    case DW_CFA_offset_extended_sf:
	      reg = LEB ();
	      l = SLEB ();
	      if (frame_need_space (fc, reg) < 0)
		reg_prefix = bad_reg;
	      if (! do_debug_frames_interp || *reg_prefix != '\0')
		printf ("  DW_CFA_offset_extended_sf: %s%s at cfa%+ld\n",
			reg_prefix, regname (reg, 0),
			l * fc->data_factor);
	      if (*reg_prefix == '\0')
		{
		  fc->col_type[reg] = DW_CFA_offset;
		  fc->col_offset[reg] = l * fc->data_factor;
		}
	      break;

	    case DW_CFA_val_offset_sf:
	      reg = LEB ();
	      l = SLEB ();
	      if (frame_need_space (fc, reg) < 0)
		reg_prefix = bad_reg;
	      if (! do_debug_frames_interp || *reg_prefix != '\0')
		printf ("  DW_CFA_val_offset_sf: %s%s at cfa%+ld\n",
			reg_prefix, regname (reg, 0),
			l * fc->data_factor);
	      if (*reg_prefix == '\0')
		{
		  fc->col_type[reg] = DW_CFA_val_offset;
		  fc->col_offset[reg] = l * fc->data_factor;
		}
	      break;

	    case DW_CFA_def_cfa_sf:
	      fc->cfa_reg = LEB ();
	      fc->cfa_offset = SLEB ();
	      fc->cfa_offset = fc->cfa_offset * fc->data_factor;
	      fc->cfa_exp = 0;
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_def_cfa_sf: %s ofs %d\n",
			regname (fc->cfa_reg, 0), fc->cfa_offset);
	      break;

	    case DW_CFA_def_cfa_offset_sf:
	      fc->cfa_offset = SLEB ();
	      fc->cfa_offset = fc->cfa_offset * fc->data_factor;
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_def_cfa_offset_sf: %d\n", fc->cfa_offset);
	      break;

	    case DW_CFA_MIPS_advance_loc8:
	      SAFE_BYTE_GET_AND_INC (ofs, start, 8, end);
	      if (do_debug_frames_interp)
		frame_display_row (fc, &need_col_headers, &max_regs);
	      else
		printf ("  DW_CFA_MIPS_advance_loc8: %ld to %s\n",
			(unsigned long) (ofs * fc->code_factor),
			dwarf_vmatoa_1 (NULL,
					fc->pc_begin + ofs * fc->code_factor,
					fc->ptr_size));
	      fc->pc_begin += ofs * fc->code_factor;
	      break;

	    case DW_CFA_GNU_window_save:
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_GNU_window_save\n");
	      break;

	    case DW_CFA_GNU_args_size:
	      ul = LEB ();
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_GNU_args_size: %ld\n", ul);
	      break;

	    case DW_CFA_GNU_negative_offset_extended:
	      reg = LEB ();
	      l = - LEB ();
	      if (frame_need_space (fc, reg) < 0)
		reg_prefix = bad_reg;
	      if (! do_debug_frames_interp || *reg_prefix != '\0')
		printf ("  DW_CFA_GNU_negative_offset_extended: %s%s at cfa%+ld\n",
			reg_prefix, regname (reg, 0),
			l * fc->data_factor);
	      if (*reg_prefix == '\0')
		{
		  fc->col_type[reg] = DW_CFA_offset;
		  fc->col_offset[reg] = l * fc->data_factor;
		}
	      break;

	    default:
	      if (op >= DW_CFA_lo_user && op <= DW_CFA_hi_user)
		printf (_("  DW_CFA_??? (User defined call frame op: %#x)\n"), op);
	      else
		warn (_("unsupported or unknown Dwarf Call Frame Instruction number: %#x\n"), op);
	      start = block_end;
	    }
	}

      if (do_debug_frames_interp)
	frame_display_row (fc, &need_col_headers, &max_regs);

      start = block_end;
      eh_addr_size = saved_eh_addr_size;
    }

  printf ("\n");

  return 1;
}

#undef GET
#undef LEB
#undef SLEB

static int
display_gdb_index (struct dwarf_section *section,
		   void *file ATTRIBUTE_UNUSED)
{
  unsigned char *start = section->start;
  uint32_t version;
  uint32_t cu_list_offset, tu_list_offset;
  uint32_t address_table_offset, symbol_table_offset, constant_pool_offset;
  unsigned int cu_list_elements, tu_list_elements;
  unsigned int address_table_size, symbol_table_slots;
  unsigned char *cu_list, *tu_list;
  unsigned char *address_table, *symbol_table, *constant_pool;
  unsigned int i;

  /* The documentation for the format of this file is in gdb/dwarf2read.c.  */

  printf (_("Contents of the %s section:\n"), section->name);

  if (section->size < 6 * sizeof (uint32_t))
    {
      warn (_("Truncated header in the %s section.\n"), section->name);
      return 0;
    }

  version = byte_get_little_endian (start, 4);
  printf (_("Version %ld\n"), (long) version);

  /* Prior versions are obsolete, and future versions may not be
     backwards compatible.  */
  if (version < 3 || version > 8)
    {
      warn (_("Unsupported version %lu.\n"), (unsigned long) version);
      return 0;
    }
  if (version < 4)
    warn (_("The address table data in version 3 may be wrong.\n"));
  if (version < 5)
    warn (_("Version 4 does not support case insensitive lookups.\n"));
  if (version < 6)
    warn (_("Version 5 does not include inlined functions.\n"));
  if (version < 7)
      warn (_("Version 6 does not include symbol attributes.\n"));
  /* Version 7 indices generated by Gold have bad type unit references,
     PR binutils/15021.  But we don't know if the index was generated by
     Gold or not, so to avoid worrying users with gdb-generated indices
     we say nothing for version 7 here.  */

  cu_list_offset = byte_get_little_endian (start + 4, 4);
  tu_list_offset = byte_get_little_endian (start + 8, 4);
  address_table_offset = byte_get_little_endian (start + 12, 4);
  symbol_table_offset = byte_get_little_endian (start + 16, 4);
  constant_pool_offset = byte_get_little_endian (start + 20, 4);

  if (cu_list_offset > section->size
      || tu_list_offset > section->size
      || address_table_offset > section->size
      || symbol_table_offset > section->size
      || constant_pool_offset > section->size)
    {
      warn (_("Corrupt header in the %s section.\n"), section->name);
      return 0;
    }

  cu_list_elements = (tu_list_offset - cu_list_offset) / 8;
  tu_list_elements = (address_table_offset - tu_list_offset) / 8;
  address_table_size = symbol_table_offset - address_table_offset;
  symbol_table_slots = (constant_pool_offset - symbol_table_offset) / 8;

  cu_list = start + cu_list_offset;
  tu_list = start + tu_list_offset;
  address_table = start + address_table_offset;
  symbol_table = start + symbol_table_offset;
  constant_pool = start + constant_pool_offset;

  printf (_("\nCU table:\n"));
  for (i = 0; i < cu_list_elements; i += 2)
    {
      uint64_t cu_offset = byte_get_little_endian (cu_list + i * 8, 8);
      uint64_t cu_length = byte_get_little_endian (cu_list + i * 8 + 8, 8);

      printf (_("[%3u] 0x%lx - 0x%lx\n"), i / 2,
	      (unsigned long) cu_offset,
	      (unsigned long) (cu_offset + cu_length - 1));
    }

  printf (_("\nTU table:\n"));
  for (i = 0; i < tu_list_elements; i += 3)
    {
      uint64_t tu_offset = byte_get_little_endian (tu_list + i * 8, 8);
      uint64_t type_offset = byte_get_little_endian (tu_list + i * 8 + 8, 8);
      uint64_t signature = byte_get_little_endian (tu_list + i * 8 + 16, 8);

      printf (_("[%3u] 0x%lx 0x%lx "), i / 3,
	      (unsigned long) tu_offset,
	      (unsigned long) type_offset);
      print_dwarf_vma (signature, 8);
      printf ("\n");
    }

  printf (_("\nAddress table:\n"));
  for (i = 0; i < address_table_size; i += 2 * 8 + 4)
    {
      uint64_t low = byte_get_little_endian (address_table + i, 8);
      uint64_t high = byte_get_little_endian (address_table + i + 8, 8);
      uint32_t cu_index = byte_get_little_endian (address_table + i + 16, 4);

      print_dwarf_vma (low, 8);
      print_dwarf_vma (high, 8);
      printf (_("%lu\n"), (unsigned long) cu_index);
    }

  printf (_("\nSymbol table:\n"));
  for (i = 0; i < symbol_table_slots; ++i)
    {
      uint32_t name_offset = byte_get_little_endian (symbol_table + i * 8, 4);
      uint32_t cu_vector_offset = byte_get_little_endian (symbol_table + i * 8 + 4, 4);
      uint32_t num_cus, cu;

      if (name_offset != 0
	  || cu_vector_offset != 0)
	{
	  unsigned int j;

	  printf ("[%3u] %s:", i, constant_pool + name_offset);
	  num_cus = byte_get_little_endian (constant_pool + cu_vector_offset, 4);
	  if (num_cus > 1)
	    printf ("\n");
	  for (j = 0; j < num_cus; ++j)
	    {
	      int is_static;
	      gdb_index_symbol_kind kind;

	      cu = byte_get_little_endian (constant_pool + cu_vector_offset + 4 + j * 4, 4);
	      is_static = GDB_INDEX_SYMBOL_STATIC_VALUE (cu);
	      kind = GDB_INDEX_SYMBOL_KIND_VALUE (cu);
	      cu = GDB_INDEX_CU_VALUE (cu);
	      /* Convert to TU number if it's for a type unit.  */
	      if (cu >= cu_list_elements / 2)
		printf ("%cT%lu", num_cus > 1 ? '\t' : ' ',
			(unsigned long) (cu - cu_list_elements / 2));
	      else
		printf ("%c%lu", num_cus > 1 ? '\t' : ' ', (unsigned long) cu);

	      switch (kind)
		{
		case GDB_INDEX_SYMBOL_KIND_NONE:
		  printf (_(" [no symbol information]"));
		  break;
		case GDB_INDEX_SYMBOL_KIND_TYPE:
		  printf (is_static
			  ? _(" [static type]")
			  : _(" [global type]"));
		  break;
		case GDB_INDEX_SYMBOL_KIND_VARIABLE:
		  printf (is_static
			  ? _(" [static variable]")
			  : _(" [global variable]"));
		  break;
		case GDB_INDEX_SYMBOL_KIND_FUNCTION:
		  printf (is_static
			  ? _(" [static function]")
			  : _(" [global function]"));
		  break;
		case GDB_INDEX_SYMBOL_KIND_OTHER:
		  printf (is_static
			  ? _(" [static other]")
			  : _(" [global other]"));
		  break;
		default:
		  printf (is_static
			  ? _(" [static unknown: %d]")
			  : _(" [global unknown: %d]"),
			  kind);
		  break;
		}
	      if (num_cus > 1)
		printf ("\n");
	    }
	  if (num_cus <= 1)
	    printf ("\n");
	}
    }

  return 1;
}

/* Pre-allocate enough space for the CU/TU sets needed.  */

static void
prealloc_cu_tu_list (unsigned int nshndx)
{
  if (shndx_pool == NULL)
    {
      shndx_pool_size = nshndx;
      shndx_pool_used = 0;
      shndx_pool = (unsigned int *) xcmalloc (shndx_pool_size,
					      sizeof (unsigned int));
    }
  else
    {
      shndx_pool_size = shndx_pool_used + nshndx;
      shndx_pool = (unsigned int *) xcrealloc (shndx_pool, shndx_pool_size,
					       sizeof (unsigned int));
    }
}

static void
add_shndx_to_cu_tu_entry (unsigned int shndx)
{
  if (shndx_pool_used >= shndx_pool_size)
    {
      error (_("Internal error: out of space in the shndx pool.\n"));
      return;
    }
  shndx_pool [shndx_pool_used++] = shndx;
}

static void
end_cu_tu_entry (void)
{
  if (shndx_pool_used >= shndx_pool_size)
    {
      error (_("Internal error: out of space in the shndx pool.\n"));
      return;
    }
  shndx_pool [shndx_pool_used++] = 0;
}

/* Return the short name of a DWARF section given by a DW_SECT enumerator.  */

static const char *
get_DW_SECT_short_name (unsigned int dw_sect)
{
  static char buf[16];

  switch (dw_sect)
    {
      case DW_SECT_INFO:
	return "info";
      case DW_SECT_TYPES:
	return "types";
      case DW_SECT_ABBREV:
	return "abbrev";
      case DW_SECT_LINE:
	return "line";
      case DW_SECT_LOC:
	return "loc";
      case DW_SECT_STR_OFFSETS:
	return "str_off";
      case DW_SECT_MACINFO:
	return "macinfo";
      case DW_SECT_MACRO:
	return "macro";
      default:
        break;
    }

  snprintf (buf, sizeof (buf), "%d", dw_sect);
  return buf;
}

/* Process a CU or TU index.  If DO_DISPLAY is true, print the contents.
   These sections are extensions for Fission.
   See http://gcc.gnu.org/wiki/DebugFissionDWP.  */

static int
process_cu_tu_index (struct dwarf_section *section, int do_display)
{
  unsigned char *phdr = section->start;
  unsigned char *limit = phdr + section->size;
  unsigned char *phash;
  unsigned char *pindex;
  unsigned char *ppool;
  unsigned int version;
  unsigned int ncols = 0;
  unsigned int nused;
  unsigned int nslots;
  unsigned int i;
  unsigned int j;
  dwarf_vma signature_high;
  dwarf_vma signature_low;
  char buf[64];

  version = byte_get (phdr, 4);
  if (version >= 2)
    ncols = byte_get (phdr + 4, 4);
  nused = byte_get (phdr + 8, 4);
  nslots = byte_get (phdr + 12, 4);
  phash = phdr + 16;
  pindex = phash + nslots * 8;
  ppool = pindex + nslots * 4;

  if (do_display)
    {
      printf (_("Contents of the %s section:\n\n"), section->name);
      printf (_("  Version:                 %d\n"), version);
      if (version >= 2)
	printf (_("  Number of columns:       %d\n"), ncols);
      printf (_("  Number of used entries:  %d\n"), nused);
      printf (_("  Number of slots:         %d\n\n"), nslots);
    }

  if (ppool > limit)
    {
      warn (_("Section %s too small for %d hash table entries\n"),
	    section->name, nslots);
      return 0;
    }

  if (version == 1)
    {
      if (!do_display)
	prealloc_cu_tu_list ((limit - ppool) / 4);
      for (i = 0; i < nslots; i++)
	{
	  unsigned char *shndx_list;
	  unsigned int shndx;

	  byte_get_64 (phash, &signature_high, &signature_low);
	  if (signature_high != 0 || signature_low != 0)
	    {
	      j = byte_get (pindex, 4);
	      shndx_list = ppool + j * 4;
	      if (do_display)
		printf (_("  [%3d] Signature:  0x%s  Sections: "),
			i, dwarf_vmatoa64 (signature_high, signature_low,
					   buf, sizeof (buf)));
	      for (;;)
		{
		  if (shndx_list >= limit)
		    {
		      warn (_("Section %s too small for shndx pool\n"),
			    section->name);
		      return 0;
		    }
		  shndx = byte_get (shndx_list, 4);
		  if (shndx == 0)
		    break;
		  if (do_display)
		    printf (" %d", shndx);
		  else
		    add_shndx_to_cu_tu_entry (shndx);
		  shndx_list += 4;
		}
	      if (do_display)
		printf ("\n");
	      else
		end_cu_tu_entry ();
	    }
	  phash += 8;
	  pindex += 4;
	}
    }
  else if (version == 2)
    {
      unsigned int val;
      unsigned int dw_sect;
      unsigned char *ph = phash;
      unsigned char *pi = pindex;
      unsigned char *poffsets = ppool + ncols * 4;
      unsigned char *psizes = poffsets + nused * ncols * 4;
      unsigned char *pend = psizes + nused * ncols * 4;
      bfd_boolean is_tu_index;
      struct cu_tu_set *this_set = NULL;
      unsigned int row;
      unsigned char *prow;

      is_tu_index = strcmp (section->name, ".debug_tu_index") == 0;

      if (pend > limit)
	{
	  warn (_("Section %s too small for offset and size tables\n"),
		section->name);
	  return 0;
	}

      if (do_display)
	{
	  printf (_("  Offset table\n"));
	  printf ("  slot  %-16s  ",
		 is_tu_index ? _("signature") : _("dwo_id"));
	}
      else
	{
	  if (is_tu_index)
	    {
	      tu_count = nused;
	      tu_sets = xcmalloc (nused, sizeof (struct cu_tu_set));
	      this_set = tu_sets;
	    }
	  else
	    {
	      cu_count = nused;
	      cu_sets = xcmalloc (nused, sizeof (struct cu_tu_set));
	      this_set = cu_sets;
	    }
	}
      if (do_display)
	{
	  for (j = 0; j < ncols; j++)
	    {
	      dw_sect = byte_get (ppool + j * 4, 4);
	      printf (" %8s", get_DW_SECT_short_name (dw_sect));
	    }
	  printf ("\n");
	}
      for (i = 0; i < nslots; i++)
	{
	  byte_get_64 (ph, &signature_high, &signature_low);
	  row = byte_get (pi, 4);
	  if (row != 0)
	    {
	      if (!do_display)
		memcpy (&this_set[row - 1].signature, ph, sizeof (uint64_t));
	      prow = poffsets + (row - 1) * ncols * 4;
	      if (do_display)
		printf (_("  [%3d] 0x%s"),
			i, dwarf_vmatoa64 (signature_high, signature_low,
					   buf, sizeof (buf)));
	      for (j = 0; j < ncols; j++)
		{
		  val = byte_get (prow + j * 4, 4);
		  if (do_display)
		    printf (" %8d", val);
		  else
		    {
		      dw_sect = byte_get (ppool + j * 4, 4);
		      this_set [row - 1].section_offsets [dw_sect] = val;
		    }
		}
	      if (do_display)
		printf ("\n");
	    }
	  ph += 8;
	  pi += 4;
	}

      ph = phash;
      pi = pindex;
      if (do_display)
        {
	  printf ("\n");
	  printf (_("  Size table\n"));
	  printf ("  slot  %-16s  ",
		 is_tu_index ? _("signature") : _("dwo_id"));
        }
      for (j = 0; j < ncols; j++)
	{
	  val = byte_get (ppool + j * 4, 4);
	  if (do_display)
	    printf (" %8s", get_DW_SECT_short_name (val));
	}
      if (do_display)
	printf ("\n");
      for (i = 0; i < nslots; i++)
	{
	  byte_get_64 (ph, &signature_high, &signature_low);
	  row = byte_get (pi, 4);
	  if (row != 0)
	    {
	      prow = psizes + (row - 1) * ncols * 4;
	      if (do_display)
		printf (_("  [%3d] 0x%s"),
			i, dwarf_vmatoa64 (signature_high, signature_low,
					   buf, sizeof (buf)));
	      for (j = 0; j < ncols; j++)
		{
		  val = byte_get (prow + j * 4, 4);
		  if (do_display)
		    printf (" %8d", val);
		  else
		    {
		      dw_sect = byte_get (ppool + j * 4, 4);
		      this_set [row - 1].section_sizes [dw_sect] = val;
		    }
		}
	      if (do_display)
		printf ("\n");
	    }
	  ph += 8;
	  pi += 4;
	}
    }
  else if (do_display)
    printf (_("  Unsupported version\n"));

  if (do_display)
      printf ("\n");

  return 1;
}

/* Load the CU and TU indexes if present.  This will build a list of
   section sets that we can use to associate a .debug_info.dwo section
   with its associated .debug_abbrev.dwo section in a .dwp file.  */

static void
load_cu_tu_indexes (void *file)
{
  /* If we have already loaded (or tried to load) the CU and TU indexes
     then do not bother to repeat the task.  */
  if (cu_tu_indexes_read)
    return;

  if (load_debug_section (dwp_cu_index, file))
    process_cu_tu_index (&debug_displays [dwp_cu_index].section, 0);

  if (load_debug_section (dwp_tu_index, file))
    process_cu_tu_index (&debug_displays [dwp_tu_index].section, 0);

  cu_tu_indexes_read = 1;
}

/* Find the set of sections that includes section SHNDX.  */

unsigned int *
find_cu_tu_set (void *file, unsigned int shndx)
{
  unsigned int i;

  load_cu_tu_indexes (file);

  /* Find SHNDX in the shndx pool.  */
  for (i = 0; i < shndx_pool_used; i++)
    if (shndx_pool [i] == shndx)
      break;

  if (i >= shndx_pool_used)
    return NULL;

  /* Now backup to find the first entry in the set.  */
  while (i > 0 && shndx_pool [i - 1] != 0)
    i--;

  return shndx_pool + i;
}

/* Display a .debug_cu_index or .debug_tu_index section.  */

static int
display_cu_index (struct dwarf_section *section, void *file ATTRIBUTE_UNUSED)
{
  return process_cu_tu_index (section, 1);
}

static int
display_debug_not_supported (struct dwarf_section *section,
			     void *file ATTRIBUTE_UNUSED)
{
  printf (_("Displaying the debug contents of section %s is not yet supported.\n"),
	    section->name);

  return 1;
}

void *
cmalloc (size_t nmemb, size_t size)
{
  /* Check for overflow.  */
  if (nmemb >= ~(size_t) 0 / size)
    return NULL;
  else
    return malloc (nmemb * size);
}

void *
xcmalloc (size_t nmemb, size_t size)
{
  /* Check for overflow.  */
  if (nmemb >= ~(size_t) 0 / size)
    return NULL;
  else
    return xmalloc (nmemb * size);
}

void *
xcrealloc (void *ptr, size_t nmemb, size_t size)
{
  /* Check for overflow.  */
  if (nmemb >= ~(size_t) 0 / size)
    return NULL;
  else
    return xrealloc (ptr, nmemb * size);
}

void
free_debug_memory (void)
{
  unsigned int i;

  free_abbrevs ();

  for (i = 0; i < max; i++)
    free_debug_section ((enum dwarf_section_display_enum) i);

  if (debug_information != NULL)
    {
      if (num_debug_info_entries != DEBUG_INFO_UNAVAILABLE)
	{
	  for (i = 0; i < num_debug_info_entries; i++)
	    {
	      if (!debug_information [i].max_loc_offsets)
		{
		  free (debug_information [i].loc_offsets);
		  free (debug_information [i].have_frame_base);
		}
	      if (!debug_information [i].max_range_lists)
		free (debug_information [i].range_lists);
	    }
	}

      free (debug_information);
      debug_information = NULL;
      num_debug_info_entries = 0;
    }
}

void
dwarf_select_sections_by_names (const char *names)
{
  typedef struct
  {
    const char * option;
    int *        variable;
    int          val;
  }
  debug_dump_long_opts;

  static const debug_dump_long_opts opts_table [] =
    {
      /* Please keep this table alpha- sorted.  */
      { "Ranges", & do_debug_ranges, 1 },
      { "abbrev", & do_debug_abbrevs, 1 },
      { "addr", & do_debug_addr, 1 },
      { "aranges", & do_debug_aranges, 1 },
      { "cu_index", & do_debug_cu_index, 1 },
      { "decodedline", & do_debug_lines, FLAG_DEBUG_LINES_DECODED },
      { "frames", & do_debug_frames, 1 },
      { "frames-interp", & do_debug_frames_interp, 1 },
      /* The special .gdb_index section.  */
      { "gdb_index", & do_gdb_index, 1 },
      { "info", & do_debug_info, 1 },
      { "line", & do_debug_lines, FLAG_DEBUG_LINES_RAW }, /* For backwards compatibility.  */
      { "loc",  & do_debug_loc, 1 },
      { "macro", & do_debug_macinfo, 1 },
      { "pubnames", & do_debug_pubnames, 1 },
      { "pubtypes", & do_debug_pubtypes, 1 },
      /* This entry is for compatability
	 with earlier versions of readelf.  */
      { "ranges", & do_debug_aranges, 1 },
      { "rawline", & do_debug_lines, FLAG_DEBUG_LINES_RAW },
      { "str", & do_debug_str, 1 },
      /* These trace_* sections are used by Itanium VMS.  */
      { "trace_abbrev", & do_trace_abbrevs, 1 },
      { "trace_aranges", & do_trace_aranges, 1 },
      { "trace_info", & do_trace_info, 1 },
      { NULL, NULL, 0 }
    };

  const char *p;

  p = names;
  while (*p)
    {
      const debug_dump_long_opts * entry;

      for (entry = opts_table; entry->option; entry++)
	{
	  size_t len = strlen (entry->option);

	  if (strncmp (p, entry->option, len) == 0
	      && (p[len] == ',' || p[len] == '\0'))
	    {
	      * entry->variable |= entry->val;

	      /* The --debug-dump=frames-interp option also
		 enables the --debug-dump=frames option.  */
	      if (do_debug_frames_interp)
		do_debug_frames = 1;

	      p += len;
	      break;
	    }
	}

      if (entry->option == NULL)
	{
	  warn (_("Unrecognized debug option '%s'\n"), p);
	  p = strchr (p, ',');
	  if (p == NULL)
	    break;
	}

      if (*p == ',')
	p++;
    }
}

void
dwarf_select_sections_by_letters (const char *letters)
{
  unsigned int lindex = 0;

  while (letters[lindex])
    switch (letters[lindex++])
      {
      case 'i':
	do_debug_info = 1;
	break;

      case 'a':
	do_debug_abbrevs = 1;
	break;

      case 'l':
	do_debug_lines |= FLAG_DEBUG_LINES_RAW;
	break;

      case 'L':
	do_debug_lines |= FLAG_DEBUG_LINES_DECODED;
	break;

      case 'p':
	do_debug_pubnames = 1;
	break;

      case 't':
	do_debug_pubtypes = 1;
	break;

      case 'r':
	do_debug_aranges = 1;
	break;

      case 'R':
	do_debug_ranges = 1;
	break;

      case 'F':
	do_debug_frames_interp = 1;
      case 'f':
	do_debug_frames = 1;
	break;

      case 'm':
	do_debug_macinfo = 1;
	break;

      case 's':
	do_debug_str = 1;
	break;

      case 'o':
	do_debug_loc = 1;
	break;

      default:
	warn (_("Unrecognized debug option '%s'\n"), optarg);
	break;
      }
}

void
dwarf_select_sections_all (void)
{
  do_debug_info = 1;
  do_debug_abbrevs = 1;
  do_debug_lines = FLAG_DEBUG_LINES_RAW;
  do_debug_pubnames = 1;
  do_debug_pubtypes = 1;
  do_debug_aranges = 1;
  do_debug_ranges = 1;
  do_debug_frames = 1;
  do_debug_macinfo = 1;
  do_debug_str = 1;
  do_debug_loc = 1;
  do_gdb_index = 1;
  do_trace_info = 1;
  do_trace_abbrevs = 1;
  do_trace_aranges = 1;
  do_debug_addr = 1;
  do_debug_cu_index = 1;
}

struct dwarf_section_display debug_displays[] =
{
  { { ".debug_abbrev",	    ".zdebug_abbrev",	NULL, NULL, 0, 0, 0 },
    display_debug_abbrev,   &do_debug_abbrevs,	0 },
  { { ".debug_aranges",	    ".zdebug_aranges",	NULL, NULL, 0, 0, 0 },
    display_debug_aranges,  &do_debug_aranges,	1 },
  { { ".debug_frame",       ".zdebug_frame",	NULL, NULL, 0, 0, 0 },
    display_debug_frames,   &do_debug_frames,	1 },
  { { ".debug_info",	    ".zdebug_info",	NULL, NULL, 0, 0, abbrev },
    display_debug_info,	    &do_debug_info,	1 },
  { { ".debug_line",	    ".zdebug_line",	NULL, NULL, 0, 0, 0 },
    display_debug_lines,    &do_debug_lines,	1 },
  { { ".debug_pubnames",    ".zdebug_pubnames",	NULL, NULL, 0, 0, 0 },
    display_debug_pubnames, &do_debug_pubnames,	0 },
  { { ".eh_frame",	    "",			NULL, NULL, 0, 0, 0 },
    display_debug_frames,   &do_debug_frames,	1 },
  { { ".debug_macinfo",	    ".zdebug_macinfo",	NULL, NULL, 0, 0, 0 },
    display_debug_macinfo,  &do_debug_macinfo,	0 },
  { { ".debug_macro",	    ".zdebug_macro",	NULL, NULL, 0, 0, 0 },
    display_debug_macro,    &do_debug_macinfo,	1 },
  { { ".debug_str",	    ".zdebug_str",	NULL, NULL, 0, 0, 0 },
    display_debug_str,	    &do_debug_str,	0 },
  { { ".debug_loc",	    ".zdebug_loc",	NULL, NULL, 0, 0, 0 },
    display_debug_loc,	    &do_debug_loc,	1 },
  { { ".debug_pubtypes",    ".zdebug_pubtypes",	NULL, NULL, 0, 0, 0 },
    display_debug_pubnames, &do_debug_pubtypes,	0 },
  { { ".debug_ranges",	    ".zdebug_ranges",	NULL, NULL, 0, 0, 0 },
    display_debug_ranges,   &do_debug_ranges,	1 },
  { { ".debug_static_func", ".zdebug_static_func", NULL, NULL, 0, 0, 0 },
    display_debug_not_supported, NULL,		0 },
  { { ".debug_static_vars", ".zdebug_static_vars", NULL, NULL, 0, 0, 0 },
    display_debug_not_supported, NULL,		0 },
  { { ".debug_types",	    ".zdebug_types",	NULL, NULL, 0, 0, abbrev },
    display_debug_types,    &do_debug_info,	1 },
  { { ".debug_weaknames",   ".zdebug_weaknames", NULL, NULL, 0, 0, 0 },
    display_debug_not_supported, NULL,		0 },
  { { ".gdb_index",	    "",	                NULL, NULL, 0, 0, 0 },
    display_gdb_index,      &do_gdb_index,	0 },
  { { ".trace_info",	    "",			NULL, NULL, 0, 0, trace_abbrev },
    display_trace_info,	    &do_trace_info,	1 },
  { { ".trace_abbrev",	    "",			NULL, NULL, 0, 0, 0 },
    display_debug_abbrev,   &do_trace_abbrevs,	0 },
  { { ".trace_aranges",	    "",			NULL, NULL, 0, 0, 0 },
    display_debug_aranges,  &do_trace_aranges,	0 },
  { { ".debug_info.dwo",    ".zdebug_info.dwo",	NULL, NULL, 0, 0, abbrev_dwo },
    display_debug_info,	    &do_debug_info,	1 },
  { { ".debug_abbrev.dwo",  ".zdebug_abbrev.dwo", NULL, NULL, 0, 0, 0 },
    display_debug_abbrev,   &do_debug_abbrevs,	0 },
  { { ".debug_types.dwo",   ".zdebug_types.dwo", NULL, NULL, 0, 0, abbrev_dwo },
    display_debug_types,    &do_debug_info,	1 },
  { { ".debug_line.dwo",    ".zdebug_line.dwo", NULL, NULL, 0, 0, 0 },
    display_debug_lines,    &do_debug_lines,	1 },
  { { ".debug_loc.dwo",	    ".zdebug_loc.dwo",	NULL, NULL, 0, 0, 0 },
    display_debug_loc,	    &do_debug_loc,	1 },
  { { ".debug_macro.dwo",   ".zdebug_macro.dwo", NULL, NULL, 0, 0, 0 },
    display_debug_macro,    &do_debug_macinfo,	1 },
  { { ".debug_macinfo.dwo", ".zdebug_macinfo.dwo", NULL, NULL, 0, 0, 0 },
    display_debug_macinfo,  &do_debug_macinfo,	0 },
  { { ".debug_str.dwo",     ".zdebug_str.dwo",  NULL, NULL, 0, 0, 0 },
    display_debug_str,      &do_debug_str,	1 },
  { { ".debug_str_offsets", ".zdebug_str_offsets", NULL, NULL, 0, 0, 0 },
    display_debug_str_offsets, NULL,		0 },
  { { ".debug_str_offsets.dwo", ".zdebug_str_offsets.dwo", NULL, NULL, 0, 0, 0 },
    display_debug_str_offsets, NULL,		0 },
  { { ".debug_addr",	    ".zdebug_addr",     NULL, NULL, 0, 0, 0 },
    display_debug_addr,     &do_debug_addr,	1 },
  { { ".debug_cu_index",    "",			NULL, NULL, 0, 0, 0 },
    display_cu_index,       &do_debug_cu_index,	0 },
  { { ".debug_tu_index",    "",			NULL, NULL, 0, 0, 0 },
    display_cu_index,       &do_debug_cu_index,	0 },
};
@


1.141
log
@	* dwarf.c (add64): New function.
	(read_and_display_attr_value): Add CU offset in to the value
	displayed for a DW_AT_ref8 attribute.
@
text
@d1598 1
@


1.140
log
@2013-10-01  Jan-Benedict Glaw  <jbglaw@@lug-owl.de>

	* dwarf.c (SAFE_BYTE_GET): Fix argument check.
@
text
@d1428 28
a1597 1
      if (!do_loc)
d1600 1
d1604 3
a1606 1

d1608 1
a1608 1
		  dwarf_vmatoa64 (high_bits, uvalue, buf, sizeof (buf)));
@


1.139
log
@Pass offset_size to print_dwarf_vma for cie_id

binutils/

	* dwarf.c (display_debug_frames): Pass offset_size to
	print_dwarf_vma for cie_id.

binutils/testsuite/

	* binutils-all/x86-64/compressed-1a.d: Updated for 64-bit addresses.
@
text
@d291 1
a291 1
      int dummy [sizeof (VAL) < (AMOUNT) ? -1 : 0] ATTRIBUTE_UNUSED ; \
@


1.138
log
@	* dwarf.c (dwarf_vmatoa): Rename to dwarf_vmatoa_1 and add a
	precision parameter.
	(dwarf_vmatoa): New wrapper for dwarf_vmatoa_1.
	(print_dwarf_vma): Use dwarf_vmatoa_1.
	(SAFE_BYTE_GET): Add check that VAL is big enough to contain
	AMOUNT bytes.
	(process_debug_info): Use an unsigned int for the offset size.
	(process_debug_pubnames): Likewise.
	(display_debug_aranges): Likewise.
	(struct Frame_Chunk): Use dwarf_vma type for pc_begin and pc_range
	fields.
	(frame_display_row): Use print_dwarf_vma to display dwarf_vma
	values.
	(display_debug_frames): Likewise.

	* binutils-all/x86-64/compressed-1a.d: Update expected output to
	allow for 64-bit addresses.

	* ld-elf/eh1.d: Update expected output to allow for
	64-bit addresses.
	* ld-elf/eh2.d: Likewise.
	* ld-elf/eh3.d: Likewise.
	* ld-elf/eh4.d: Likewise.
	* ld-elf/eh5.d: Likewise.
	* ld-elf/eh6.d: Likewise.
	* ld-mips-elf/eh-frame1-n64.d: Likewise.
	* ld-mips-elf/eh-frame2-n64.d: Likewise.
	* ld-mips-elf/eh-frame3.d: Likewise.

	* gas/cfi/cfi-alpha-1.d: Update expected output to allow for
	64-bit addresses.
	* gas/cfi/cfi-alpha-3.d: Likewise.
	* gas/cfi/cfi-arm-1.d: Likewise.
	* gas/cfi/cfi-common-1.d: Likewise.
	* gas/cfi/cfi-common-2.d: Likewise.
	* gas/cfi/cfi-common-3.d: Likewise.
	* gas/cfi/cfi-common-4.d: Likewise.
	* gas/cfi/cfi-common-5.d: Likewise.
	* gas/cfi/cfi-common-6.d: Likewise.
	* gas/cfi/cfi-common-7.d: Likewise.
	* gas/cfi/cfi-hppa-1.d: Likewise.
	* gas/cfi/cfi-i386-2.d: Likewise.
	* gas/cfi/cfi-i386.d: Likewise.
	* gas/cfi/cfi-m68k.d: Likewise.
	* gas/cfi/cfi-mips-1.d: Likewise.
	* gas/cfi/cfi-ppc-1.d: Likewise.
	* gas/cfi/cfi-s390-1.d: Likewise.
	* gas/cfi/cfi-s390x-1.d: Likewise.
	* gas/cfi/cfi-sh-1.d: Likewise.
	* gas/cfi/cfi-sparc-1.d: Likewise.
	* gas/cfi/cfi-sparc64-1.d: Likewise.
	* gas/cfi/cfi-x86_64.d: Likewise.
@
text
@d5252 1
a5252 1
	  print_dwarf_vma (cie_id, fc->ptr_size);
d5388 1
a5388 1
		  dwarf_vmatoa_1 (NULL, cie_id, fc->ptr_size),
@


1.138.2.1
log
@	* dwarf.c (add64): New function.
	(read_and_display_attr_value): Add CU offset in to the value
	displayed for a DW_AT_ref8 attribute.
@
text
@d291 1
a291 1
      int dummy [sizeof (VAL) < (AMOUNT) ? -1 : 1] ATTRIBUTE_UNUSED ; \
a1427 28
/* Add INC to HIGH_BITS:LOW_BITS.  */
static void
add64 (dwarf_vma * high_bits, dwarf_vma * low_bits, dwarf_vma inc)
{
  dwarf_vma tmp = * low_bits;

  tmp += inc;

  /* FIXME: There is probably a better way of handling this:

     We need to cope with dwarf_vma being a 32-bit or 64-bit
     type.  Plus regardless of its size LOW_BITS is meant to
     only hold 32-bits, so if there is overflow or wrap around
     we must propagate into HIGH_BITS.  */
  if (tmp < * low_bits)
    {
      ++ * high_bits;
    }
  else if (sizeof (tmp) > 8
	   && (tmp >> 31) > 1)
    {
      ++ * high_bits;
      tmp &= 0xFFFFFFFF;
    }

  * low_bits = tmp;
}

a1572 1
	  dwarf_vma utmp;
d1576 1
a1576 3
	  utmp = uvalue;
	  if (form == DW_FORM_ref8)
	    add64 (& high_bits, & utmp, cu_offset);
d1578 1
a1578 1
		  dwarf_vmatoa64 (high_bits, utmp, buf, sizeof (buf)));
@


1.138.2.2
log
@Pass offset_size to print_dwarf_vma for cie_id

binutils/

	* dwarf.c (display_debug_frames): Pass offset_size to
	print_dwarf_vma for cie_id.

binutils/testsuite/

	* binutils-all/x86-64/compressed-1a.d: Updated for 64-bit addresses.
@
text
@d5283 1
a5283 1
	  print_dwarf_vma (cie_id, offset_size);
d5419 1
a5419 1
		  dwarf_vmatoa_1 (NULL, cie_id, offset_size),
@


1.137
log
@	* dwarf.c (display_debug_frames): Check for DW64_CIE_ID when
	parsing 64-bit frames.
@
text
@a141 13
/* Print a dwarf_vma value (typically an address, offset or length) in
   hexadecimal format, followed by a space.  The length of the value (and
   hence the precision displayed) is determined by the byte_size parameter.  */

static void
print_dwarf_vma (dwarf_vma val, unsigned byte_size)
{
  static char buff[18];
  int offset = 0;

  /* Printf does not have a way of specifiying a maximum field width for an
     integer value, so we print the full value into a buffer and then select
     the precision we need.  */
d144 2
a145 1
  snprintf (buff, sizeof (buff), "%16.16llx ", val);
d147 2
a148 1
  snprintf (buff, sizeof (buff), "%016I64x ", val);
d151 2
a152 1
  snprintf (buff, sizeof (buff), "%16.16lx ", val);
d155 5
a159 20
  if (byte_size != 0)
    {
      if (byte_size > 0 && byte_size <= 8)
	offset = 16 - 2 * byte_size;
      else
	error (_("Wrong size in print_dwarf_vma"));
    }

  fputs (buff + offset, stdout);
}

#if __STDC_VERSION__ >= 199901L || (defined(__GNUC__) && __GNUC__ >= 2)
#ifndef __MINGW32__
#define  DWARF_VMA_FMT "ll"
#else
#define  DWARF_VMA_FMT "I64"
#endif
#else
#define  DWARF_VMA_FMT "l"
#endif
d162 1
a162 1
dwarf_vmatoa (const char *fmtch, dwarf_vma value)
a171 1
  char fmt[32];
a173 2
  sprintf (fmt, "%%%s%s", DWARF_VMA_FMT, fmtch);

d177 19
a195 1
  snprintf (ret, sizeof (buf[0].place), fmt, value);
d197 14
a210 1
  return ret;
d291 1
d817 1
a817 1
  
d2199 1
a2199 1
      int offset_size;
d3497 1
a3497 1
      int offset_size, initial_length_size;
d3780 1
a3780 1
	  
d4524 2
a4525 2
      int offset_size;
      int initial_length_size;
d4896 2
a4897 2
  unsigned long pc_begin;
  unsigned long pc_range;
d5082 1
a5082 1
  printf ("%0*lx ", eh_addr_size * 2, fc->pc_begin);
d5152 2
a5153 2
      unsigned long length;
      unsigned long cie_id;
d5159 3
a5161 3
      int encoded_ptr_size = saved_eh_addr_size;
      int offset_size;
      int initial_length_size;
d5188 3
a5190 2
	  warn ("Invalid length %#08lx in FDE at %#08lx\n",
		length, (unsigned long)(saved_start - section_start));
d5250 4
d5255 4
a5258 4
	    printf ("\n%08lx %08lx %08lx CIE \"%s\" cf=%d df=%d ra=%d\n",
		    (unsigned long)(saved_start - section_start), length, cie_id,
		    fc->augmentation, fc->code_factor, fc->data_factor,
		    fc->ra);
d5261 1
a5261 2
	      printf ("\n%08lx %08lx %08lx CIE\n",
		      (unsigned long)(saved_start - section_start), length, cie_id);
d5328 3
a5330 2
	      warn ("Invalid CIE pointer %#08lx in FDE at %#08lx\n",
		    cie_id, (unsigned long)(saved_start - section_start));
d5377 1
a5377 1
	  
d5385 4
a5388 2
	  printf ("\n%08lx %08lx %08lx FDE cie=%08lx pc=",
		  (unsigned long)(saved_start - section_start), length, cie_id,
d5390 1
d5393 5
a5397 1
	  printf ("%08lx..%08lx\n", fc->pc_begin, fc->pc_begin + fc->pc_range);
d5545 2
a5546 1
	  long l, ofs;
d5563 1
a5563 1
		printf ("  DW_CFA_advance_loc: %d to %08lx\n",
d5565 3
a5567 1
			fc->pc_begin + opa * fc->code_factor);
d5609 2
a5610 1
		printf ("  DW_CFA_set_loc: %08lx\n", (unsigned long)vma);
d5619 5
a5623 3
		printf ("  DW_CFA_advance_loc1: %ld to %08lx\n",
			ofs * fc->code_factor,
			fc->pc_begin + ofs * fc->code_factor);
d5632 5
a5636 3
		printf ("  DW_CFA_advance_loc2: %ld to %08lx\n",
			ofs * fc->code_factor,
			fc->pc_begin + ofs * fc->code_factor);
d5645 5
a5649 3
		printf ("  DW_CFA_advance_loc4: %ld to %08lx\n",
			ofs * fc->code_factor,
			fc->pc_begin + ofs * fc->code_factor);
d5910 5
a5914 3
		printf ("  DW_CFA_MIPS_advance_loc8: %ld to %08lx\n",
			ofs * fc->code_factor,
			fc->pc_begin + ofs * fc->code_factor);
@


1.136
log
@Add Intel AVX-512 support

binutils/

2013-07-26  Sergey Guriev  <sergey.s.guriev@@intel.com>
	    Alexander Ivchenko  <alexander.ivchenko@@intel.com>
	    Maxim Kuznetsov  <maxim.kuznetsov@@intel.com>
	    Sergey Lega  <sergey.s.lega@@intel.com>
	    Anna Tikhonova  <anna.tikhonova@@intel.com>
	    Ilya Tocar  <ilya.tocar@@intel.com>
	    Andrey Turetskiy  <andrey.turetskiy@@intel.com>
	    Ilya Verbin  <ilya.verbin@@intel.com>
	    Kirill Yukhin  <kirill.yukhin@@intel.com>
	    Michael Zolotukhin  <michael.v.zolotukhin@@intel.com>

	* dwarf.c (dwarf_regnames_i386): Add k0-k7 registers and
	numeration in comments.
	(dwarf_regnames_x86_64): Add xmm16-31 and k0-k7 registers to
	dwarf table.

gas/

2013-07-26  Sergey Guriev  <sergey.s.guriev@@intel.com>
	    Alexander Ivchenko  <alexander.ivchenko@@intel.com>
	    Maxim Kuznetsov  <maxim.kuznetsov@@intel.com>
	    Sergey Lega  <sergey.s.lega@@intel.com>
	    Anna Tikhonova  <anna.tikhonova@@intel.com>
	    Ilya Tocar  <ilya.tocar@@intel.com>
	    Andrey Turetskiy  <andrey.turetskiy@@intel.com>
	    Ilya Verbin  <ilya.verbin@@intel.com>
	    Kirill Yukhin  <kirill.yukhin@@intel.com>
	    Michael Zolotukhin  <michael.v.zolotukhin@@intel.com>

	* config/tc-i386-intel.c (O_zmmword_ptr): New.
	(i386_types): Add zmmword.
	(i386_intel_simplify_register): Allow regzmm.
	(i386_intel_simplify): Handle zmmwords.
	(i386_intel_operand): Handle RC/SAE, vector operations and
	zmmwords.
	* config/tc-i386.c (ZMMWORD_MNEM_SUFFIX): New.
	(struct RC_Operation): New.
	(struct Mask_Operation): New.
	(struct Broadcast_Operation): New.
	(vex_prefix): Size of bytes increased to 4 to support EVEX
	encoding.
	(enum i386_error): Add new error codes: unsupported_broadcast,
	broadcast_not_on_src_operand, broadcast_needed,
	unsupported_masking, mask_not_on_destination, no_default_mask,
	unsupported_rc_sae, rc_sae_operand_not_last_imm,
	invalid_register_operand, try_vector_disp8.
	(struct _i386_insn): Add new fields vrex, need_vrex, mask,
	rounding, broadcast, memshift.
	(struct RC_name): New.
	(RC_NamesTable): New.
	(evexlig): New.
	(evexwig): New.
	(extra_symbol_chars): Add '{'.
	(cpu_arch): Add AVX512F, AVX512CD, AVX512ER and AVX512PF.
	(i386_operand_type): Add regzmm, regmask and vec_disp8.
	(match_mem_size): Handle zmmwords.
	(operand_type_match): Handle zmm-registers.
	(mode_from_disp_size): Handle vec_disp8.
	(fits_in_vec_disp8): New.
	(md_begin): Handle {} properly.
	(type_names): Add "rZMM", "Mask reg" and "Vector d8".
	(build_vex_prefix): Handle vrex.
	(build_evex_prefix): New.
	(process_immext): Adjust to properly handle EVEX.
	(md_assemble): Add EVEX encoding support.
	(swap_2_operands): Correctly handle operands with masking,
	broadcasting or RC/SAE.
	(check_VecOperands): Support EVEX features.
	(VEX_check_operands): Properly handle 16 upper [xyz]mm registers.
	(match_template): Support regzmm and handle new error codes.
	(process_suffix): Handle zmmwords and zmm-registers.
	(check_byte_reg): Extend to zmm-registers.
	(process_operands): Extend to zmm-registers.
	(build_modrm_byte): Handle EVEX.
	(output_insn): Adjust to properly handle EVEX case.
	(disp_size): Handle vec_disp8.
	(output_disp): Support compressed disp8*N evex feature.
	(output_imm): Handle RC/SAE immediates properly.
	(check_VecOperations): New.
	(i386_immediate): Handle EVEX features.
	(i386_index_check): Handle zmmwords and zmm-registers.
	(RC_SAE_immediate): New.
	(i386_att_operand): Handle EVEX features.
	(parse_real_register): Add a check for ZMM/Mask registers.
	(OPTION_MEVEXLIG): New.
	(OPTION_MEVEXWIG): New.
	(md_longopts): Add mevexlig and mevexwig.
	(md_parse_option): Handle mevexlig and mevexwig options.
	(md_show_usage): Add description for mevexlig and mevexwig.
	* doc/c-i386.texi: Document avx512f/.avx512f, avx512cd/.avx512cd,
	avx512er/.avx512er, avx512pf/.avx512pf, mevexlig and mevexwig.

gas/testsuite/

2013-07-26  Sergey Guriev  <sergey.s.guriev@@intel.com>
	    Alexander Ivchenko  <alexander.ivchenko@@intel.com>
	    Maxim Kuznetsov  <maxim.kuznetsov@@intel.com>
	    Sergey Lega  <sergey.s.lega@@intel.com>
	    Anna Tikhonova  <anna.tikhonova@@intel.com>
	    Ilya Tocar  <ilya.tocar@@intel.com>
	    Andrey Turetskiy  <andrey.turetskiy@@intel.com>
	    Ilya Verbin  <ilya.verbin@@intel.com>
	    Kirill Yukhin  <kirill.yukhin@@intel.com>
	    Michael Zolotukhin  <michael.v.zolotukhin@@intel.com>

	* gas/cfi/cfi-i386.s: Add tests for k0-k7.
	* gas/cfi/cfi-i386.d: Change to reflect above mentioned changes.
	* gas/cfi/cfi-x86_64.s: Add tests for xmm16-31, k0-7.
	* gas/cfi/cfi-x86_64.d: Change to reflect above mentioned changes.
	* gas/i386/ilp32/cfi/cfi-x86_64.d: Ditto.
	* gas/i386/intel-regs.s: Add tests for zmm0 and xmm16 registers.
	* gas/i386/intel-regs.d: Change correspondingly.
	* gas/i386/prefetch-intel.d: Reflect implementation of prefetchwt1.
	* gas/i386/prefetch.d: Ditto.
	* gas/i386/x86-64-prefetch-intel.d: Ditto.
	* gas/i386/x86-64-prefetch.d: Ditto.
	* gas/i386/avx512f-intel.d: New.
	* gas/i386/avx512f-nondef.d: New.
	* gas/i386/avx512f-nondef.s: New.
	* gas/i386/avx512f-opts-intel.d: New.
	* gas/i386/avx512f-opts.d: New.
	* gas/i386/avx512f-opts.s: New.
	* gas/i386/avx512f.d: New.
	* gas/i386/avx512f.s: New.
	* gas/i386/avx512cd-intel.d: New.
	* gas/i386/avx512cd.d: New.
	* gas/i386/avx512cd.s: New.
	* gas/i386/avx512er-intel.d: New.
	* gas/i386/avx512er.d: New.
	* gas/i386/avx512er.s: New.
	* gas/i386/avx512pf-intel.d: New.
	* gas/i386/avx512pf.d: New.
	* gas/i386/avx512pf.s: New.
	* gas/i386/evex-lig.s: New.
	* gas/i386/evex-lig256-intel.d: New.
	* gas/i386/evex-lig256.d: New.
	* gas/i386/evex-lig512-intel.d: New.
	* gas/i386/evex-lig512.d: New.
	* gas/i386/evex-wig.s: New.
	* gas/i386/evex-wig1-intel.d: New.
	* gas/i386/evex-wig1.d: New.
	* gas/i386/inval-avx512f.l: New.
	* gas/i386/inval-avx512f.s: New.
	* gas/i386/x86-64-avx512f-intel.d: New.
	* gas/i386/x86-64-avx512f-nondef.d: New.
	* gas/i386/x86-64-avx512f-nondef.s: New.
	* gas/i386/x86-64-avx512f-opts-intel.d: New.
	* gas/i386/x86-64-avx512f-opts.d: New.
	* gas/i386/x86-64-avx512f-opts.s: New.
	* gas/i386/x86-64-avx512f.d: New.
	* gas/i386/x86-64-avx512f.s: New.
	* gas/i386/x86-64-avx512cd-intel.d: New.
	* gas/i386/x86-64-avx512cd.d: New.
	* gas/i386/x86-64-avx512cd.s: New.
	* gas/i386/x86-64-avx512er-intel.d: New.
	* gas/i386/x86-64-avx512er.d: New.
	* gas/i386/x86-64-avx512er.s: New.
	* gas/i386/x86-64-avx512pf-intel.d: New.
	* gas/i386/x86-64-avx512pf.d: New.
	* gas/i386/x86-64-avx512pf.s: New.
	* gas/i386/x86-64-evex-lig.s: New.
	* gas/i386/x86-64-evex-lig256-intel.d: New.
	* gas/i386/x86-64-evex-lig256.d: New.
	* gas/i386/x86-64-evex-lig512-intel.d: New.
	* gas/i386/x86-64-evex-lig512.d: New.
	* gas/i386/x86-64-evex-wig.s: New.
	* gas/i386/x86-64-evex-wig1-intel.d: New.
	* gas/i386/x86-64-evex-wig1.d: New.
	* gas/i386/x86-64-inval-avx512f.l: New.
	* gas/i386/x86-64-inval-avx512f.s: New.
	* gas/i386/i386.exp: Run new AVX-512 tests.

opcodes/

2013-07-26  Sergey Guriev  <sergey.s.guriev@@intel.com>
	    Alexander Ivchenko  <alexander.ivchenko@@intel.com>
	    Maxim Kuznetsov  <maxim.kuznetsov@@intel.com>
	    Sergey Lega  <sergey.s.lega@@intel.com>
	    Anna Tikhonova  <anna.tikhonova@@intel.com>
	    Ilya Tocar  <ilya.tocar@@intel.com>
	    Andrey Turetskiy  <andrey.turetskiy@@intel.com>
	    Ilya Verbin  <ilya.verbin@@intel.com>
	    Kirill Yukhin  <kirill.yukhin@@intel.com>
	    Michael Zolotukhin  <michael.v.zolotukhin@@intel.com>

	* i386-dis-evex.h: New.
	* i386-dis.c (OP_Rounding): New.
	(VPCMP_Fixup): New.
	(OP_Mask): New.
	(Rdq): New.
	(XMxmmq): New.
	(EXdScalarS): New.
	(EXymm): New.
	(EXEvexHalfBcstXmmq): New.
	(EXxmm_mdq): New.
	(EXEvexXGscat): New.
	(EXEvexXNoBcst): New.
	(VPCMP): New.
	(EXxEVexR): New.
	(EXxEVexS): New.
	(XMask): New.
	(MaskG): New.
	(MaskE): New.
	(MaskR): New.
	(MaskVex): New.
	(modes enum): Add evex_x_gscat_mode, evex_x_nobcst_mode,
	evex_half_bcst_xmmq_mode, xmm_mdq_mode, ymm_mode,
	evex_rounding_mode, evex_sae_mode, mask_mode.
	(USE_EVEX_TABLE): New.
	(EVEX_TABLE): New.
	(EVEX enum): New.
	(REG enum): Add REG_EVEX_0F72, REG_EVEX_0F73, REG_EVEX_0F38C6,
	REG_EVEX_0F38C7.
	(MOD enum): Add MOD_EVEX_0F10_PREFIX_1, MOD_EVEX_0F10_PREFIX_3,
	MOD_EVEX_0F11_PREFIX_1, MOD_EVEX_0F11_PREFIX_3,
	MOD_EVEX_0F12_PREFIX_0, MOD_EVEX_0F16_PREFIX_0, MOD_EVEX_0F38C6_REG_1,
	MOD_EVEX_0F38C6_REG_2, MOD_EVEX_0F38C6_REG_5, MOD_EVEX_0F38C6_REG_6,
	MOD_EVEX_0F38C7_REG_1, MOD_EVEX_0F38C7_REG_2,  MOD_EVEX_0F38C7_REG_5,
	MOD_EVEX_0F38C7_REG_6.
	(PREFIX enum): Add PREFIX_VEX_0F41, PREFIX_VEX_0F42, PREFIX_VEX_0F44,
	PREFIX_VEX_0F45, PREFIX_VEX_0F46, PREFIX_VEX_0F47, PREFIX_VEX_0F4B,
	PREFIX_VEX_0F90, PREFIX_VEX_0F91, PREFIX_VEX_0F92, PREFIX_VEX_0F93,
	PREFIX_VEX_0F98, PREFIX_VEX_0F3A30, PREFIX_VEX_0F3A32,
	PREFIX_VEX_0F3AF0, PREFIX_EVEX_0F10, PREFIX_EVEX_0F11,
	PREFIX_EVEX_0F12, PREFIX_EVEX_0F13, PREFIX_EVEX_0F14,
	PREFIX_EVEX_0F15, PREFIX_EVEX_0F16, PREFIX_EVEX_0F17,
	PREFIX_EVEX_0F28, PREFIX_EVEX_0F29, PREFIX_EVEX_0F2A,
	PREFIX_EVEX_0F2B, PREFIX_EVEX_0F2C, PREFIX_EVEX_0F2D,
	PREFIX_EVEX_0F2E, PREFIX_EVEX_0F2F, PREFIX_EVEX_0F51,
	PREFIX_EVEX_0F58, PREFIX_EVEX_0F59, PREFIX_EVEX_0F5A,
	PREFIX_EVEX_0F5B, PREFIX_EVEX_0F5C, PREFIX_EVEX_0F5D,
	PREFIX_EVEX_0F5E, PREFIX_EVEX_0F5F, PREFIX_EVEX_0F62,
	PREFIX_EVEX_0F66, PREFIX_EVEX_0F6A, PREFIX_EVEX_0F6C,
	PREFIX_EVEX_0F6D, PREFIX_EVEX_0F6E, PREFIX_EVEX_0F6F,
	PREFIX_EVEX_0F70, PREFIX_EVEX_0F72_REG_0, PREFIX_EVEX_0F72_REG_1,
	PREFIX_EVEX_0F72_REG_2, PREFIX_EVEX_0F72_REG_4,
	PREFIX_EVEX_0F72_REG_6, PREFIX_EVEX_0F73_REG_2,
	PREFIX_EVEX_0F73_REG_6, PREFIX_EVEX_0F76, PREFIX_EVEX_0F78,
	PREFIX_EVEX_0F79, PREFIX_EVEX_0F7A, PREFIX_EVEX_0F7B,
	PREFIX_EVEX_0F7E, PREFIX_EVEX_0F7F, PREFIX_EVEX_0FC2,
	PREFIX_EVEX_0FC6, PREFIX_EVEX_0FD2, PREFIX_EVEX_0FD3,
	PREFIX_EVEX_0FD4, PREFIX_EVEX_0FD6, PREFIX_EVEX_0FDB,
	PREFIX_EVEX_0FDF, PREFIX_EVEX_0FE2, PREFIX_EVEX_0FE6 PREFIX_EVEX_0FE7,
	PREFIX_EVEX_0FEB, PREFIX_EVEX_0FEF, PREFIX_EVEX_0FF2,
	PREFIX_EVEX_0FF3, PREFIX_EVEX_0FF4, PREFIX_EVEX_0FFA, PREFIX_EVEX_0FFB,
	PREFIX_EVEX_0FFE, PREFIX_EVEX_0F380C, PREFIX_EVEX_0F380D,
	PREFIX_EVEX_0F3811, PREFIX_EVEX_0F3812, PREFIX_EVEX_0F3813,
	PREFIX_EVEX_0F3814, PREFIX_EVEX_0F3815, PREFIX_EVEX_0F3816,
	PREFIX_EVEX_0F3818, PREFIX_EVEX_0F3819, PREFIX_EVEX_0F381A,
	PREFIX_EVEX_0F381B, PREFIX_EVEX_0F381E, PREFIX_EVEX_0F381F,
	PREFIX_EVEX_0F3821, PREFIX_EVEX_0F3822, PREFIX_EVEX_0F3823,
	PREFIX_EVEX_0F3824, PREFIX_EVEX_0F3825, PREFIX_EVEX_0F3827,
	PREFIX_EVEX_0F3828, PREFIX_EVEX_0F3829, PREFIX_EVEX_0F382A,
	PREFIX_EVEX_0F382C, PREFIX_EVEX_0F382D, PREFIX_EVEX_0F3831,
	PREFIX_EVEX_0F3832, PREFIX_EVEX_0F3833, PREFIX_EVEX_0F3834,
	PREFIX_EVEX_0F3835, PREFIX_EVEX_0F3836, PREFIX_EVEX_0F3837,
	PREFIX_EVEX_0F3839, PREFIX_EVEX_0F383A, PREFIX_EVEX_0F383B,
	PREFIX_EVEX_0F383D, PREFIX_EVEX_0F383F, PREFIX_EVEX_0F3840,
	PREFIX_EVEX_0F3842, PREFIX_EVEX_0F3843, PREFIX_EVEX_0F3844,
	PREFIX_EVEX_0F3845, PREFIX_EVEX_0F3846, PREFIX_EVEX_0F3847,
	PREFIX_EVEX_0F384C, PREFIX_EVEX_0F384D, PREFIX_EVEX_0F384E,
	PREFIX_EVEX_0F384F, PREFIX_EVEX_0F3858, PREFIX_EVEX_0F3859,
	PREFIX_EVEX_0F385A, PREFIX_EVEX_0F385B, PREFIX_EVEX_0F3864,
	PREFIX_EVEX_0F3865, PREFIX_EVEX_0F3876, PREFIX_EVEX_0F3877,
	PREFIX_EVEX_0F387C, PREFIX_EVEX_0F387E, PREFIX_EVEX_0F387F,
	PREFIX_EVEX_0F3888, PREFIX_EVEX_0F3889, PREFIX_EVEX_0F388A,
	PREFIX_EVEX_0F388B, PREFIX_EVEX_0F3890, PREFIX_EVEX_0F3891,
	PREFIX_EVEX_0F3892, PREFIX_EVEX_0F3893, PREFIX_EVEX_0F3896,
	PREFIX_EVEX_0F3897, PREFIX_EVEX_0F3898, PREFIX_EVEX_0F3899,
	PREFIX_EVEX_0F389A, PREFIX_EVEX_0F389B, PREFIX_EVEX_0F389C,
	PREFIX_EVEX_0F389D, PREFIX_EVEX_0F389E, PREFIX_EVEX_0F389F,
	PREFIX_EVEX_0F38A0, PREFIX_EVEX_0F38A1, PREFIX_EVEX_0F38A2,
	PREFIX_EVEX_0F38A3, PREFIX_EVEX_0F38A6, PREFIX_EVEX_0F38A7,
	PREFIX_EVEX_0F38A8, PREFIX_EVEX_0F38A9, PREFIX_EVEX_0F38AA,
	PREFIX_EVEX_0F38AB, PREFIX_EVEX_0F38AC, PREFIX_EVEX_0F38AD,
	PREFIX_EVEX_0F38AE, PREFIX_EVEX_0F38AF, PREFIX_EVEX_0F38B6,
	PREFIX_EVEX_0F38B7, PREFIX_EVEX_0F38B8, PREFIX_EVEX_0F38B9,
	PREFIX_EVEX_0F38BA, PREFIX_EVEX_0F38BB, PREFIX_EVEX_0F38BC,
	PREFIX_EVEX_0F38BD, PREFIX_EVEX_0F38BE, PREFIX_EVEX_0F38BF,
	PREFIX_EVEX_0F38C4, PREFIX_EVEX_0F38C6_REG_1,
	PREFIX_EVEX_0F38C6_REG_2, PREFIX_EVEX_0F38C6_REG_5,
	PREFIX_EVEX_0F38C6_REG_6, PREFIX_EVEX_0F38C7_REG_1,
	PREFIX_EVEX_0F38C7_REG_2, PREFIX_EVEX_0F38C7_REG_5,
	PREFIX_EVEX_0F38C7_REG_6, PREFIX_EVEX_0F38C8, PREFIX_EVEX_0F38CA,
	PREFIX_EVEX_0F38CB, PREFIX_EVEX_0F38CC, PREFIX_EVEX_0F38CD,
	PREFIX_EVEX_0F3A00,  PREFIX_EVEX_0F3A01, PREFIX_EVEX_0F3A03,
	PREFIX_EVEX_0F3A04, PREFIX_EVEX_0F3A05, PREFIX_EVEX_0F3A08,
	PREFIX_EVEX_0F3A09, PREFIX_EVEX_0F3A0A, PREFIX_EVEX_0F3A0B,
	PREFIX_EVEX_0F3A17, PREFIX_EVEX_0F3A18, PREFIX_EVEX_0F3A19,
	PREFIX_EVEX_0F3A1A, PREFIX_EVEX_0F3A1B, PREFIX_EVEX_0F3A1D,
	PREFIX_EVEX_0F3A1E, PREFIX_EVEX_0F3A1F, PREFIX_EVEX_0F3A21,
	PREFIX_EVEX_0F3A23, PREFIX_EVEX_0F3A25, PREFIX_EVEX_0F3A26,
	PREFIX_EVEX_0F3A27, PREFIX_EVEX_0F3A38, PREFIX_EVEX_0F3A39,
	PREFIX_EVEX_0F3A3A, PREFIX_EVEX_0F3A3B, PREFIX_EVEX_0F3A3E,
	PREFIX_EVEX_0F3A3F, PREFIX_EVEX_0F3A43, PREFIX_EVEX_0F3A54,
	PREFIX_EVEX_0F3A55.
	(VEX_LEN enum): Add VEX_LEN_0F41_P_0, VEX_LEN_0F42_P_0, VEX_LEN_0F44_P_0,
	VEX_LEN_0F45_P_0, VEX_LEN_0F46_P_0, VEX_LEN_0F47_P_0,
	VEX_LEN_0F4B_P_2, VEX_LEN_0F90_P_0, VEX_LEN_0F91_P_0,
	VEX_LEN_0F92_P_0, VEX_LEN_0F93_P_0, VEX_LEN_0F98_P_0,
	VEX_LEN_0F3A30_P_2, VEX_LEN_0F3A32_P_2, VEX_W_0F41_P_0_LEN_1,
	VEX_W_0F42_P_0_LEN_1, VEX_W_0F44_P_0_LEN_0, VEX_W_0F45_P_0_LEN_1,
	VEX_W_0F46_P_0_LEN_1, VEX_W_0F47_P_0_LEN_1, VEX_W_0F4B_P_2_LEN_1,
	VEX_W_0F90_P_0_LEN_0, VEX_W_0F91_P_0_LEN_0, VEX_W_0F92_P_0_LEN_0,
	VEX_W_0F93_P_0_LEN_0, VEX_W_0F98_P_0_LEN_0, VEX_W_0F3A30_P_2_LEN_0,
	VEX_W_0F3A32_P_2_LEN_0.
	(VEX_W enum): Add EVEX_W_0F10_P_0, EVEX_W_0F10_P_1_M_0,
	EVEX_W_0F10_P_1_M_1, EVEX_W_0F10_P_2, EVEX_W_0F10_P_3_M_0,
	EVEX_W_0F10_P_3_M_1, EVEX_W_0F11_P_0, EVEX_W_0F11_P_1_M_0,
	EVEX_W_0F11_P_1_M_1, EVEX_W_0F11_P_2, EVEX_W_0F11_P_3_M_0,
	EVEX_W_0F11_P_3_M_1, EVEX_W_0F12_P_0_M_0, EVEX_W_0F12_P_0_M_1,
	EVEX_W_0F12_P_1, EVEX_W_0F12_P_2, EVEX_W_0F12_P_3, EVEX_W_0F13_P_0,
	EVEX_W_0F13_P_2, EVEX_W_0F14_P_0, EVEX_W_0F14_P_2, EVEX_W_0F15_P_0,
	EVEX_W_0F15_P_2, EVEX_W_0F16_P_0_M_0, EVEX_W_0F16_P_0_M_1,
	EVEX_W_0F16_P_1, EVEX_W_0F16_P_2, EVEX_W_0F17_P_0, EVEX_W_0F17_P_2,
	EVEX_W_0F28_P_0, EVEX_W_0F28_P_2, EVEX_W_0F29_P_0, EVEX_W_0F29_P_2,
	EVEX_W_0F2A_P_1, EVEX_W_0F2A_P_3, EVEX_W_0F2B_P_0, EVEX_W_0F2B_P_2,
	EVEX_W_0F2E_P_0, EVEX_W_0F2E_P_2, EVEX_W_0F2F_P_0, EVEX_W_0F2F_P_2,
	EVEX_W_0F51_P_0, EVEX_W_0F51_P_1, EVEX_W_0F51_P_2, EVEX_W_0F51_P_3,
	EVEX_W_0F58_P_0, EVEX_W_0F58_P_1, EVEX_W_0F58_P_2, EVEX_W_0F58_P_3,
	EVEX_W_0F59_P_0, EVEX_W_0F59_P_1, EVEX_W_0F59_P_2, EVEX_W_0F59_P_3,
	EVEX_W_0F5A_P_0, EVEX_W_0F5A_P_1, EVEX_W_0F5A_P_2, EVEX_W_0F5A_P_3,
	EVEX_W_0F5B_P_0, EVEX_W_0F5B_P_1, EVEX_W_0F5B_P_2, EVEX_W_0F5C_P_0,
	EVEX_W_0F5C_P_1, EVEX_W_0F5C_P_2, EVEX_W_0F5C_P_3, EVEX_W_0F5D_P_0,
	EVEX_W_0F5D_P_1, EVEX_W_0F5D_P_2, EVEX_W_0F5D_P_3, EVEX_W_0F5E_P_0,
	EVEX_W_0F5E_P_1, EVEX_W_0F5E_P_2, EVEX_W_0F5E_P_3, EVEX_W_0F5F_P_0,
	EVEX_W_0F5F_P_1, EVEX_W_0F5F_P_2, EVEX_W_0F5F_P_3, EVEX_W_0F62_P_2,
	EVEX_W_0F66_P_2, EVEX_W_0F6A_P_2, EVEX_W_0F6C_P_2, EVEX_W_0F6D_P_2,
	EVEX_W_0F6E_P_2, EVEX_W_0F6F_P_1, EVEX_W_0F6F_P_2, EVEX_W_0F70_P_2,
	EVEX_W_0F72_R_2_P_2, EVEX_W_0F72_R_6_P_2, EVEX_W_0F73_R_2_P_2,
	EVEX_W_0F73_R_6_P_2, EVEX_W_0F76_P_2, EVEX_W_0F78_P_0,
	EVEX_W_0F79_P_0, EVEX_W_0F7A_P_1, EVEX_W_0F7A_P_3, EVEX_W_0F7B_P_1,
	EVEX_W_0F7B_P_3, EVEX_W_0F7E_P_1, EVEX_W_0F7E_P_2, EVEX_W_0F7F_P_1,
	EVEX_W_0F7F_P_2, EVEX_W_0FC2_P_0, EVEX_W_0FC2_P_1, EVEX_W_0FC2_P_2,
	EVEX_W_0FC2_P_3, EVEX_W_0FC6_P_0, EVEX_W_0FC6_P_2, EVEX_W_0FD2_P_2,
	EVEX_W_0FD3_P_2, EVEX_W_0FD4_P_2, EVEX_W_0FD6_P_2, EVEX_W_0FE6_P_1,
	EVEX_W_0FE6_P_2, EVEX_W_0FE6_P_3, EVEX_W_0FE7_P_2, EVEX_W_0FF2_P_2,
	EVEX_W_0FF3_P_2, EVEX_W_0FF4_P_2, EVEX_W_0FFA_P_2, EVEX_W_0FFB_P_2,
	EVEX_W_0FFE_P_2, EVEX_W_0F380C_P_2, EVEX_W_0F380D_P_2,
	EVEX_W_0F3811_P_1, EVEX_W_0F3812_P_1, EVEX_W_0F3813_P_1,
	EVEX_W_0F3813_P_2, EVEX_W_0F3814_P_1, EVEX_W_0F3815_P_1,
	EVEX_W_0F3818_P_2, EVEX_W_0F3819_P_2, EVEX_W_0F381A_P_2,
	EVEX_W_0F381B_P_2, EVEX_W_0F381E_P_2, EVEX_W_0F381F_P_2,
	EVEX_W_0F3821_P_1, EVEX_W_0F3822_P_1, EVEX_W_0F3823_P_1,
	EVEX_W_0F3824_P_1, EVEX_W_0F3825_P_1, EVEX_W_0F3825_P_2,
	EVEX_W_0F3828_P_2, EVEX_W_0F3829_P_2, EVEX_W_0F382A_P_1,
	EVEX_W_0F382A_P_2, EVEX_W_0F3831_P_1, EVEX_W_0F3832_P_1,
	EVEX_W_0F3833_P_1, EVEX_W_0F3834_P_1, EVEX_W_0F3835_P_1,
	EVEX_W_0F3835_P_2, EVEX_W_0F3837_P_2, EVEX_W_0F383A_P_1,
	EVEX_W_0F3840_P_2, EVEX_W_0F3858_P_2, EVEX_W_0F3859_P_2,
	EVEX_W_0F385A_P_2, EVEX_W_0F385B_P_2, EVEX_W_0F3891_P_2,
	EVEX_W_0F3893_P_2, EVEX_W_0F38A1_P_2, EVEX_W_0F38A3_P_2,
	EVEX_W_0F38C7_R_1_P_2, EVEX_W_0F38C7_R_2_P_2, EVEX_W_0F38C7_R_5_P_2,
	EVEX_W_0F38C7_R_6_P_2, EVEX_W_0F3A00_P_2, EVEX_W_0F3A01_P_2,
	EVEX_W_0F3A04_P_2, EVEX_W_0F3A05_P_2, EVEX_W_0F3A08_P_2,
	EVEX_W_0F3A09_P_2, EVEX_W_0F3A0A_P_2, EVEX_W_0F3A0B_P_2,
	EVEX_W_0F3A18_P_2, EVEX_W_0F3A19_P_2, EVEX_W_0F3A1A_P_2,
	EVEX_W_0F3A1B_P_2, EVEX_W_0F3A1D_P_2, EVEX_W_0F3A21_P_2,
	EVEX_W_0F3A23_P_2, EVEX_W_0F3A38_P_2, EVEX_W_0F3A39_P_2,
	EVEX_W_0F3A3A_P_2, EVEX_W_0F3A3B_P_2, EVEX_W_0F3A43_P_2.
	(struct vex): Add fields evex, r, v, mask_register_specifier,
	zeroing, ll, b.
	(intel_names_xmm): Add upper 16 registers.
	(att_names_xmm): Ditto.
	(intel_names_ymm): Ditto.
	(att_names_ymm): Ditto.
	(names_zmm): New.
	(intel_names_zmm): Ditto.
	(att_names_zmm): Ditto.
	(names_mask): Ditto.
	(intel_names_mask): Ditto.
	(att_names_mask): Ditto.
	(names_rounding): Ditto.
	(names_broadcast): Ditto.
	(x86_64_table): Add escape to evex-table.
	(reg_table): Include reg_table evex-entries from
	i386-dis-evex.h.  Fix prefetchwt1 instruction.
	(prefix_table): Add entries for new instructions.
	(vex_table): Ditto.
	(vex_len_table): Ditto.
	(vex_w_table): Ditto.
	(mod_table): Ditto.
	(get_valid_dis386): Properly handle new instructions.
	(print_insn): Handle zmm and mask registers, print mask operand.
	(intel_operand_size): Support EVEX, new modes and sizes.
	(OP_E_register): Handle new modes.
	(OP_E_memory): Ditto.
	(OP_G): Ditto.
	(OP_XMM): Ditto.
	(OP_EX): Ditto.
	(OP_VEX): Ditto.
	* i386-gen.c (cpu_flag_init): Update CPU_ANY_SSE_FLAGS and
	CPU_ANY_AVX_FLAGS.  Add CPU_AVX512F_FLAGS, CPU_AVX512CD_FLAGS,
	CPU_AVX512ER_FLAGS and CPU_AVX512PF_FLAGS.
	(cpu_flags): Add CpuAVX512F, CpuAVX512CD, CpuAVX512ER,
	CpuAVX512PF and CpuVREX.
	(operand_type_init): Add OPERAND_TYPE_REGZMM,
	OPERAND_TYPE_REGMASK and OPERAND_TYPE_VEC_DISP8.
	(opcode_modifiers): Add EVex, Masking, VecESize, Broadcast,
	StaticRounding, SAE, Disp8MemShift, NoDefMask.
	(operand_types): Add RegZMM, RegMask, Vec_Disp8, Zmmword.
	* i386-init.h: Regenerate.
	* i386-opc.h (CpuAVX512F): New.
	(CpuAVX512CD): New.
	(CpuAVX512ER): New.
	(CpuAVX512PF): New.
	(CpuVREX): New.
	(i386_cpu_flags): Add cpuavx512f, cpuavx512cd, cpuavx512er,
	cpuavx512pf and cpuvrex fields.
	(VecSIB): Add VecSIB512.
	(EVex): New.
	(Masking): New.
	(VecESize): New.
	(Broadcast): New.
	(StaticRounding): New.
	(SAE): New.
	(Disp8MemShift): New.
	(NoDefMask): New.
	(i386_opcode_modifier): Add evex, masking, vecesize, broadcast,
	staticrounding, sae, disp8memshift and nodefmask.
	(RegZMM): New.
	(Zmmword): Ditto.
	(Vec_Disp8): Ditto.
	(i386_operand_type): Add regzmm, regmask, zmmword and vec_disp8
	fields.
	(RegVRex): New.
	* i386-opc.tbl: Add AVX512 instructions.
	* i386-reg.tbl: Add 16 upper XMM and YMM registers, 32 new ZMM
	registers, mask registers.
	* i386-tbl.h: Regenerate.
@
text
@d5191 2
a5192 1
      if (is_eh ? (cie_id == 0) : (cie_id == DW_CIE_ID))
@


1.135
log
@binutils/
	* dwarf.c (display_debug_lines_raw): Print section offsets.

binutils/testsuite/
	* binutils-all/dw2-1.W: Adjust expected output.
	* binutils-all/objdump.W: Likewise.
	* binutils-all/i386/compressed-1a.d: Likewise.
	* binutils-all/x86-64/compressed-1a.d: Likewise.

gas/testsuite/
	* gas/cris/rd-dw2-1.d: Adjust expected output.
	* gas/cris/rd-dw2-10.d: Likewise.
	* gas/cris/rd-dw2-11.d: Likewise.
	* gas/cris/rd-dw2-12.d: Likewise.
	* gas/cris/rd-dw2-13.d: Likewise.
	* gas/cris/rd-dw2-14.d: Likewise.
	* gas/cris/rd-dw2-15.d: Likewise.
	* gas/cris/rd-dw2-2.d: Likewise.
	* gas/cris/rd-dw2-3.d: Likewise.
	* gas/cris/rd-dw2-4.d: Likewise.
	* gas/cris/rd-dw2-5.d: Likewise.
	* gas/cris/rd-dw2-6.d: Likewise.
	* gas/cris/rd-dw2-7.d: Likewise.
	* gas/cris/rd-dw2-8.d: Likewise.
	* gas/cris/rd-dw2-9.d: Likewise.
	* gas/elf/dwarf2-1.d: Likewise.
	* gas/elf/dwarf2-2.d: Likewise.
	* gas/elf/dwarf2-3.d: Likewise.
	* gas/i386/debug1.d: Likewise.
	* gas/i386/dw2-compress-1.d: Likewise.
	* gas/i386/ilp32/lns/lns-common-1.d: Likewise.
	* gas/i386/ilp32/lns/lns-duplicate.d: Likewise.
	* gas/ia64/pr13167.d: Likewise.
	* gas/lns/lns-big-delta.d: Likewise.
	* gas/lns/lns-common-1-alt.d: Likewise.
	* gas/lns/lns-common-1.d: Likewise.
	* gas/lns/lns-duplicate.d: Likewise.
	* gas/mips/loc-swap-2.d: Likewise.
	* gas/mips/loc-swap.d: Likewise.
	* gas/mips/micromips@@loc-swap-2.d: Likewise.
	* gas/mips/micromips@@loc-swap.d: Likewise.
	* gas/mips/mips16-dwarf2-n32.d: Likewise.
	* gas/mips/mips16-dwarf2.d: Likewise.
	* gas/mips/mips16@@loc-swap-2.d: Likewise.
	* gas/mips/mips16@@loc-swap.d: Likewise.
@
text
@d4942 20
a4961 13
  "eax", "ecx", "edx", "ebx",
  "esp", "ebp", "esi", "edi",
  "eip", "eflags", NULL,
  "st0", "st1", "st2", "st3",
  "st4", "st5", "st6", "st7",
  NULL, NULL,
  "xmm0", "xmm1", "xmm2", "xmm3",
  "xmm4", "xmm5", "xmm6", "xmm7",
  "mm0", "mm1", "mm2", "mm3",
  "mm4", "mm5", "mm6", "mm7",
  "fcw", "fsw", "mxcsr",
  "es", "cs", "ss", "ds", "fs", "gs", NULL, NULL,
  "tr", "ldtr"
d4990 11
a5000 1
  "mxcsr", "fcw", "fsw"
@


1.134
log
@binutils/
	* dwarf.c (SAFE_BYTE_GET64): Correct end-of-buffer check;
	don't increment PTR.
	(decode_location_expression): DW_OP_const2u should read 2 bytes.
	(display_debug_lines_decoded): Adjust formatting.
	* elfcomm.c (byte_get_little_endian): Add cases for 5-, 6-, and
	7-byte reads.
	(byte_get_big_endian): Likewise.
	(byte_get_signed): Likewise.
@
text
@d2659 2
a2660 1
       int i;
d2719 2
a2720 1
	      printf (_("\n The Directory Table:\n"));
d2724 1
a2724 1
		  printf ("  %s\n", data);
d2738 2
a2739 1
	      printf (_("\n The File Name Table:\n"));
d2790 2
@


1.133
log
@	* dwarf.c (display_debug_lines_raw): Do not treat .debug_line.dwo
	sections as if they were fragmentary .debug_line sections.
	(display_debug_lines_decoded): Likewise.
@
text
@d340 1
a340 1
      if (((PTR) + 8) < (END))				\
a345 1
	  PTR = END;					\
d885 1
a885 1
	  SAFE_BYTE_GET_AND_INC (uvalue, data, 1, end);
d3186 2
a3187 1
						op_code_data, ext_op_code_len - bytes_read - 1,
@


1.132
log
@	* elflink.c (_bfd_elf_gc_mark_extra_sections): Remove mark from
	fragmented .debug_line sections associated with unmarked code
	sections.

	* dwarf.c (read_debug_line_header): New function.  Reads in a
	header in a .debug_line section.
	(display_debug_lines_raw): Use new function.  Handle fragmentary
	.debug_line sections.
	(display_debug_lines_decoded): Likewise.
	* readelf.c (process_section_headers): Handle fragmenatry
	.debug_line sections.
	(display_debug_section): Likewise.

	* as.c (Options): Add -gdwarf-sections.
	(parse_args): Likewise.
	* as.h (flag_dwarf_sections): Declare.
	* dwarf2dbg.c (emit_fixed_inc_line_addr): Skip section changes.
	(process_entries): When -gdwarf-sections is enabled generate
	fragmentary .debug_line sections.
	(out_debug_line): Set the section for the .debug_line section end
	symbol.
	* doc/as.texinfo: Document -gdwarf-sections.
	* NEWS: Mention -gdwarf-sections.

	* gas/elf/dwarf2-3.d: Fix expected readelf output.

	* scripttempl/DWARF.sc: Add support for .debug_line.* and
	.debug_line_end.
@
text
@d2662 4
a2665 1
      if (const_strneq (section->name, ".debug_line."))
d2674 1
a2674 1
	     Since the section is a fragmnent it does not have the details
d2676 1
a2676 1
	     details from the last one we processed.  */
d3000 4
a3003 1
      if (const_strneq (section->name, ".debug_line."))
d3005 1
a3005 10
	  /* Sections named .debug_line.<foo> are fragments of a .debug_line
	     section containing just the Line Number Statements.  They are
	     created by the assembler and intended to be used alongside gcc's
	     -ffunction-sections command line option.  When the linker's
	     garbage collection decides to discard a .text.<foo> section it
	     can then also discard the line number information in .debug_line.<foo>.

	     Since the section is a fragmnent it does not have the details
	     needed to fill out a LineInfo structure, so instead we use the
	     details from the last one we processed.  */
@


1.131
log
@	* dwarf.c (process_debug_info): Check dwarf_cutoff_level.
@
text
@d2549 4
a2552 6
static int
display_debug_lines_raw (struct dwarf_section *section,
			 unsigned char *data,
                         unsigned char *end)
{
  unsigned char *start = section->start;
d2554 10
a2563 13
  printf (_("Raw dump of debug contents of section %s:\n\n"),
          section->name);

  while (data < end)
    {
      DWARF2_Internal_LineInfo linfo;
      unsigned char *standard_opcodes;
      unsigned char *end_of_sequence;
      unsigned char *hdrptr;
      unsigned long hdroff;
      int initial_length_size;
      int offset_size;
      int i;
d2565 2
a2567 1
      hdroff = hdrptr - start;
d2569 2
a2570 2
      /* Check the length of the block.  */
      SAFE_BYTE_GET_AND_INC (linfo.li_length, hdrptr, 4, end);
d2572 1
a2572 1
      if (linfo.li_length == 0xffffffff)
d2575 1
a2575 1
	  SAFE_BYTE_GET_AND_INC (linfo.li_length, hdrptr, 8, end);
d2585 12
a2596 1
      if (linfo.li_length + initial_length_size > section->size)
d2598 4
a2601 4
	  warn
	    (_("The information in section %s appears to be corrupt - the section is too small\n"),
	     section->name);
	  return 0;
d2604 6
a2609 5
      /* Check its version number.  */
      SAFE_BYTE_GET_AND_INC (linfo.li_version, hdrptr, 2, end);
      if (linfo.li_version != 2
	  && linfo.li_version != 3
	  && linfo.li_version != 4)
d2612 1
a2612 1
	  return 0;
d2615 2
a2616 2
      SAFE_BYTE_GET_AND_INC (linfo.li_prologue_length, hdrptr, offset_size, end);
      SAFE_BYTE_GET_AND_INC (linfo.li_min_insn_length, hdrptr, 1, end);
d2618 1
a2618 1
      if (linfo.li_version >= 4)
d2620 1
a2620 1
	  SAFE_BYTE_GET_AND_INC (linfo.li_max_ops_per_insn, hdrptr, 1, end);
d2622 1
a2622 1
	  if (linfo.li_max_ops_per_insn == 0)
d2625 1
a2625 1
	      return 0;
d2629 1
a2629 1
	linfo.li_max_ops_per_insn = 1;
d2631 4
a2634 4
      SAFE_BYTE_GET_AND_INC (linfo.li_default_is_stmt, hdrptr, 1, end);
      SAFE_BYTE_GET_AND_INC (linfo.li_line_base, hdrptr, 1, end);
      SAFE_BYTE_GET_AND_INC (linfo.li_line_range, hdrptr, 1, end);
      SAFE_BYTE_GET_AND_INC (linfo.li_opcode_base, hdrptr, 1, end);
d2637 6
a2642 2
      linfo.li_line_base <<= 24;
      linfo.li_line_base >>= 24;
d2644 6
a2649 20
      printf (_("  Offset:                      0x%lx\n"), hdroff);
      printf (_("  Length:                      %ld\n"), (long) linfo.li_length);
      printf (_("  DWARF Version:               %d\n"), linfo.li_version);
      printf (_("  Prologue Length:             %d\n"), linfo.li_prologue_length);
      printf (_("  Minimum Instruction Length:  %d\n"), linfo.li_min_insn_length);
      if (linfo.li_version >= 4)
	printf (_("  Maximum Ops per Instruction: %d\n"), linfo.li_max_ops_per_insn);
      printf (_("  Initial value of 'is_stmt':  %d\n"), linfo.li_default_is_stmt);
      printf (_("  Line Base:                   %d\n"), linfo.li_line_base);
      printf (_("  Line Range:                  %d\n"), linfo.li_line_range);
      printf (_("  Opcode Base:                 %d\n"), linfo.li_opcode_base);

      end_of_sequence = data + linfo.li_length + initial_length_size;

      reset_state_machine (linfo.li_default_is_stmt);

      /* Display the contents of the Opcodes table.  */
      standard_opcodes = hdrptr;

      printf (_("\n Opcodes:\n"));
d2651 2
a2652 2
      for (i = 1; i < linfo.li_opcode_base; i++)
	printf (_("  Opcode %d has %d args\n"), i, standard_opcodes[i - 1]);
d2654 7
a2660 2
      /* Display the contents of the Directory table.  */
      data = standard_opcodes + linfo.li_opcode_base - 1;
d2662 17
a2678 2
      if (*data == 0)
	printf (_("\n The Directory Table is empty.\n"));
d2681 1
a2681 1
	  printf (_("\n The Directory Table:\n"));
d2683 22
a2704 3
	  while (*data != 0)
	    {
	      printf ("  %s\n", data);
d2706 2
a2707 3
	      data += strnlen ((char *) data, end - data) + 1;
	    }
	}
d2709 2
a2710 2
      /* Skip the NUL at the end of the table.  */
      data++;
d2712 3
a2714 9
      /* Display the contents of the File Name table.  */
      if (*data == 0)
	printf (_("\n The File Name Table is empty.\n"));
      else
	{
	  printf (_("\n The File Name Table:\n"));
	  printf (_("  Entry\tDir\tTime\tSize\tName\n"));

	  while (*data != 0)
d2716 1
a2716 2
	      unsigned char *name;
	      unsigned int bytes_read;
d2718 3
a2720 3
	      printf ("  %d\t", ++state_machine_regs.last_file_entry);
	      name = data;
	      data += strnlen ((char *) data, end - data) + 1;
d2722 1
a2722 15
	      printf ("%s\t",
		      dwarf_vmatoa ("u", read_uleb128 (data, & bytes_read, end)));
	      data += bytes_read;
	      printf ("%s\t",
		      dwarf_vmatoa ("u", read_uleb128 (data, & bytes_read, end)));
	      data += bytes_read;
	      printf ("%s\t",
		      dwarf_vmatoa ("u", read_uleb128 (data, & bytes_read, end)));
	      data += bytes_read;
	      printf ("%s\n", name);

	      if (data == end)
		{
		  warn (_("Corrupt file name table entry\n"));
		  break;
a2724 1
	}
d2726 2
a2727 2
      /* Skip the NUL at the end of the table.  */
      data++;
d2729 7
a2735 2
      /* Now display the statements.  */
      printf (_("\n Line Number Statements:\n"));
d2737 1
a2737 14
      while (data < end_of_sequence)
	{
	  unsigned char op_code;
	  dwarf_signed_vma adv;
	  dwarf_vma uladv;
	  unsigned int bytes_read;

	  op_code = *data++;

	  if (op_code >= linfo.li_opcode_base)
	    {
	      op_code -= linfo.li_opcode_base;
	      uladv = (op_code / linfo.li_line_range);
	      if (linfo.li_max_ops_per_insn == 1)
d2739 2
a2740 32
		  uladv *= linfo.li_min_insn_length;
		  state_machine_regs.address += uladv;
		  printf (_("  Special opcode %d: "
			    "advance Address by %s to 0x%s"),
			  op_code, dwarf_vmatoa ("u", uladv),
			  dwarf_vmatoa ("x", state_machine_regs.address));
		}
	      else
		{
		  state_machine_regs.address
		    += ((state_machine_regs.op_index + uladv)
			/ linfo.li_max_ops_per_insn)
		       * linfo.li_min_insn_length;
		  state_machine_regs.op_index
		    = (state_machine_regs.op_index + uladv)
		      % linfo.li_max_ops_per_insn;
		  printf (_("  Special opcode %d: "
			    "advance Address by %s to 0x%s[%d]"),
			  op_code, dwarf_vmatoa ("u", uladv),
			  dwarf_vmatoa ("x", state_machine_regs.address),
			  state_machine_regs.op_index);
		}
	      adv = (op_code % linfo.li_line_range) + linfo.li_line_base;
	      state_machine_regs.line += adv;
	      printf (_(" and Line by %s to %d\n"),
		      dwarf_vmatoa ("d", adv), state_machine_regs.line);
	    }
	  else switch (op_code)
	    {
	    case DW_LNS_extended_op:
	      data += process_extended_line_op (data, linfo.li_default_is_stmt, end);
	      break;
d2742 3
a2744 3
	    case DW_LNS_copy:
	      printf (_("  Copy\n"));
	      break;
d2746 10
a2755 26
	    case DW_LNS_advance_pc:
	      uladv = read_uleb128 (data, & bytes_read, end);
	      data += bytes_read;
	      if (linfo.li_max_ops_per_insn == 1)
		{
		  uladv *= linfo.li_min_insn_length;
		  state_machine_regs.address += uladv;
		  printf (_("  Advance PC by %s to 0x%s\n"),
			  dwarf_vmatoa ("u", uladv),
			  dwarf_vmatoa ("x", state_machine_regs.address));
		}
	      else
		{
		  state_machine_regs.address
		    += ((state_machine_regs.op_index + uladv)
			/ linfo.li_max_ops_per_insn)
		       * linfo.li_min_insn_length;
		  state_machine_regs.op_index
		    = (state_machine_regs.op_index + uladv)
		      % linfo.li_max_ops_per_insn;
		  printf (_("  Advance PC by %s to 0x%s[%d]\n"),
			  dwarf_vmatoa ("u", uladv),
			  dwarf_vmatoa ("x", state_machine_regs.address),
			  state_machine_regs.op_index);
		}
	      break;
d2757 5
a2761 46
	    case DW_LNS_advance_line:
	      adv = read_sleb128 (data, & bytes_read, end);
	      data += bytes_read;
	      state_machine_regs.line += adv;
	      printf (_("  Advance Line by %s to %d\n"),
		        dwarf_vmatoa ("d", adv),
			state_machine_regs.line);
	      break;

	    case DW_LNS_set_file:
	      adv = read_uleb128 (data, & bytes_read, end);
	      data += bytes_read;
	      printf (_("  Set File Name to entry %s in the File Name Table\n"),
		      dwarf_vmatoa ("d", adv));
	      state_machine_regs.file = adv;
	      break;

	    case DW_LNS_set_column:
	      uladv = read_uleb128 (data, & bytes_read, end);
	      data += bytes_read;
	      printf (_("  Set column to %s\n"),
		      dwarf_vmatoa ("u", uladv));
	      state_machine_regs.column = uladv;
	      break;

	    case DW_LNS_negate_stmt:
	      adv = state_machine_regs.is_stmt;
	      adv = ! adv;
	      printf (_("  Set is_stmt to %s\n"), dwarf_vmatoa ("d", adv));
	      state_machine_regs.is_stmt = adv;
	      break;

	    case DW_LNS_set_basic_block:
	      printf (_("  Set basic block\n"));
	      state_machine_regs.basic_block = 1;
	      break;

	    case DW_LNS_const_add_pc:
	      uladv = ((255 - linfo.li_opcode_base) / linfo.li_line_range);
	      if (linfo.li_max_ops_per_insn)
		{
		  uladv *= linfo.li_min_insn_length;
		  state_machine_regs.address += uladv;
		  printf (_("  Advance PC by constant %s to 0x%s\n"),
			  dwarf_vmatoa ("u", uladv),
			  dwarf_vmatoa ("x", state_machine_regs.address));
d2763 1
a2763 15
	      else
		{
		  state_machine_regs.address
		    += ((state_machine_regs.op_index + uladv)
			/ linfo.li_max_ops_per_insn)
		       * linfo.li_min_insn_length;
		  state_machine_regs.op_index
		    = (state_machine_regs.op_index + uladv)
		      % linfo.li_max_ops_per_insn;
		  printf (_("  Advance PC by constant %s to 0x%s[%d]\n"),
			  dwarf_vmatoa ("u", uladv),
			  dwarf_vmatoa ("x", state_machine_regs.address),
			  state_machine_regs.op_index);
		}
	      break;
d2765 5
a2769 8
	    case DW_LNS_fixed_advance_pc:
	      SAFE_BYTE_GET_AND_INC (uladv, data, 2, end);
	      state_machine_regs.address += uladv;
	      state_machine_regs.op_index = 0;
	      printf (_("  Advance PC by fixed size amount %s to 0x%s\n"),
		      dwarf_vmatoa ("u", uladv),
		      dwarf_vmatoa ("x", state_machine_regs.address));
	      break;
d2771 6
a2776 3
	    case DW_LNS_set_prologue_end:
	      printf (_("  Set prologue_end to true\n"));
	      break;
d2778 6
a2783 9
	    case DW_LNS_set_epilogue_begin:
	      printf (_("  Set epilogue_begin to true\n"));
	      break;

	    case DW_LNS_set_isa:
	      uladv = read_uleb128 (data, & bytes_read, end);
	      data += bytes_read;
	      printf (_("  Set ISA to %s\n"), dwarf_vmatoa ("u", uladv));
	      break;
d2785 1
a2785 2
	    default:
	      printf (_("  Unknown opcode %d with operands: "), op_code);
d2787 1
a2787 1
	      for (i = standard_opcodes[op_code - 1]; i > 0 ; --i)
d2789 168
a2956 7
		  printf ("0x%s%s", dwarf_vmatoa ("x", read_uleb128 (data,
								     &bytes_read, end)),
			  i == 1 ? "" : ", ");
		  data += bytes_read;
		}
	      putchar ('\n');
	      break;
d2958 1
a2959 1
      putchar ('\n');
d2980 2
a2990 3
      unsigned char *hdrptr;
      int initial_length_size;
      int offset_size;
d2997 1
a2997 9
      hdrptr = data;

      /* Extract information from the Line Number Program Header.
        (section 6.2.4 in the Dwarf3 doc).  */

      /* Get the length of this CU's line number information block.  */
      SAFE_BYTE_GET_AND_INC (linfo.li_length, hdrptr, 4, end);

      if (linfo.li_length == 0xffffffff)
d2999 14
a3012 4
          /* This section is 64-bit DWARF 3.  */
	  SAFE_BYTE_GET_AND_INC (linfo.li_length, hdrptr, 8, end);
          offset_size = 8;
          initial_length_size = 12;
d3016 1
a3016 3
          offset_size = 4;
          initial_length_size = 4;
        }
d3018 3
a3020 6
      if (linfo.li_length + initial_length_size > section->size)
        {
          warn (_("The line info appears to be corrupt - "
                  "the section is too small\n"));
          return 0;
        }
d3022 1
a3022 10
      /* Get this CU's Line Number Block version number.  */
      SAFE_BYTE_GET_AND_INC (linfo.li_version, hdrptr, 2, end);
      if (linfo.li_version != 2
	  && linfo.li_version != 3
	  && linfo.li_version != 4)
        {
          warn (_("Only DWARF version 2, 3 and 4 line info is currently "
                "supported.\n"));
          return 0;
        }
d3024 2
a3025 2
      SAFE_BYTE_GET_AND_INC (linfo.li_prologue_length, hdrptr, offset_size, end);
      SAFE_BYTE_GET_AND_INC (linfo.li_min_insn_length, hdrptr, 1, end);
d3027 3
a3029 4
      if (linfo.li_version >= 4)
	{
	  SAFE_BYTE_GET_AND_INC (linfo.li_max_ops_per_insn, hdrptr, 1, end);
	  if (linfo.li_max_ops_per_insn == 0)
d3031 1
a3031 6
	      warn (_("Invalid maximum operations per insn.\n"));
	      return 0;
	    }
	}
      else
	linfo.li_max_ops_per_insn = 1;
d3033 5
a3037 4
      SAFE_BYTE_GET_AND_INC (linfo.li_default_is_stmt, hdrptr, 1, end);
      SAFE_BYTE_GET_AND_INC (linfo.li_line_base, hdrptr, 1, end);
      SAFE_BYTE_GET_AND_INC (linfo.li_line_range, hdrptr, 1, end);
      SAFE_BYTE_GET_AND_INC (linfo.li_opcode_base, hdrptr, 1, end);
d3039 3
a3041 3
      /* Sign extend the line base field.  */
      linfo.li_line_base <<= 24;
      linfo.li_line_base >>= 24;
d3043 11
a3053 7
      /* Find the end of this CU's Line Number Information Block.  */
      end_of_sequence = data + linfo.li_length + initial_length_size;

      reset_state_machine (linfo.li_default_is_stmt);

      /* Save a pointer to the contents of the Opcodes table.  */
      standard_opcodes = hdrptr;
d3055 2
a3056 7
      /* Traverse the Directory table just to count entries.  */
      data = standard_opcodes + linfo.li_opcode_base - 1;
      if (*data != 0)
        {
          unsigned char *ptr_directory_table = data;

	  while (*data != 0)
d3058 1
a3058 3
	      data += strnlen ((char *) data, end - data) + 1;
	      n_directories++;
	    }
d3060 3
a3062 3
          /* Go through the directory table again to save the directories.  */
          directory_table = (unsigned char **)
              xmalloc (n_directories * sizeof (unsigned char *));
d3064 9
a3072 11
          i = 0;
          while (*ptr_directory_table != 0)
            {
              directory_table[i] = ptr_directory_table;
              ptr_directory_table += strnlen ((char *) ptr_directory_table,
					      ptr_directory_table - end) + 1;
              i++;
            }
        }
      /* Skip the NUL at the end of the table.  */
      data++;
d3074 2
a3075 4
      /* Traverse the File Name table just to count the entries.  */
      if (*data != 0)
        {
          unsigned char *ptr_file_name_table = data;
d3077 2
a3078 3
          while (*data != 0)
            {
	      unsigned int bytes_read;
d3080 4
a3083 9
              /* Skip Name, directory index, last modification time and length
                 of file.  */
              data += strnlen ((char *) data, end - data) + 1;
              read_uleb128 (data, & bytes_read, end);
              data += bytes_read;
              read_uleb128 (data, & bytes_read, end);
              data += bytes_read;
              read_uleb128 (data, & bytes_read, end);
              data += bytes_read;
d3085 3
a3087 2
              n_files++;
            }
d3089 12
a3100 2
          /* Go through the file table again to save the strings.  */
          file_table = (File_Entry *) xmalloc (n_files * sizeof (File_Entry));
d3102 10
a3111 4
          i = 0;
          while (*ptr_file_name_table != 0)
            {
              unsigned int bytes_read;
d3113 4
a3116 16
              file_table[i].name = ptr_file_name_table;
              ptr_file_name_table += strnlen ((char *) ptr_file_name_table,
					      end - ptr_file_name_table) + 1;

              /* We are not interested in directory, time or size.  */
              file_table[i].directory_index = read_uleb128 (ptr_file_name_table,
							    & bytes_read, end);
              ptr_file_name_table += bytes_read;
              file_table[i].modification_date = read_uleb128 (ptr_file_name_table,
							      & bytes_read, end);
              ptr_file_name_table += bytes_read;
              file_table[i].length = read_uleb128 (ptr_file_name_table, & bytes_read, end);
              ptr_file_name_table += bytes_read;
              i++;
            }
          i = 0;
d3118 3
a3120 10
          /* Print the Compilation Unit's name and a header.  */
          if (directory_table == NULL)
            {
              printf (_("CU: %s:\n"), file_table[0].name);
              printf (_("File name                            Line number    Starting address\n"));
            }
          else
            {
              unsigned int ix = file_table[0].directory_index;
              const char *directory = ix ? (char *)directory_table[ix - 1] : ".";
d3122 2
a3123 4
              if (do_wide || strlen (directory) < 76)
		printf (_("CU: %s/%s:\n"), directory, file_table[0].name);
              else
		printf ("%s:\n", file_table[0].name);
d3125 2
a3126 6
              printf (_("File name                            Line number    Starting address\n"));
            }
        }

      /* Skip the NUL at the end of the table.  */
      data++;
d3153 1
a3153 1
		       * linfo.li_min_insn_length;
d3156 1
a3156 1
		      % linfo.li_max_ops_per_insn;
d3164 187
a3350 184
            {
            case DW_LNS_extended_op:
              {
                unsigned int ext_op_code_len;
                unsigned char ext_op_code;
                unsigned char *op_code_data = data;

                ext_op_code_len = read_uleb128 (op_code_data, &bytes_read,
						end_of_sequence);
                op_code_data += bytes_read;

                if (ext_op_code_len == 0)
                  {
                    warn (_("badly formed extended line op encountered!\n"));
                    break;
                  }
                ext_op_code_len += bytes_read;
                ext_op_code = *op_code_data++;

                switch (ext_op_code)
                  {
                  case DW_LNE_end_sequence:
                    reset_state_machine (linfo.li_default_is_stmt);
                    break;
                  case DW_LNE_set_address:
		    SAFE_BYTE_GET_AND_INC (state_machine_regs.address,
					   op_code_data, ext_op_code_len - bytes_read - 1,
					   end);
		    state_machine_regs.op_index = 0;
                    break;
                  case DW_LNE_define_file:
                    {
                      file_table = (File_Entry *) xrealloc
                        (file_table, (n_files + 1) * sizeof (File_Entry));

                      ++state_machine_regs.last_file_entry;
                      /* Source file name.  */
                      file_table[n_files].name = op_code_data;
                      op_code_data += strlen ((char *) op_code_data) + 1;
                      /* Directory index.  */
                      file_table[n_files].directory_index =
                        read_uleb128 (op_code_data, & bytes_read,
				      end_of_sequence);
                      op_code_data += bytes_read;
                      /* Last modification time.  */
                      file_table[n_files].modification_date =
                        read_uleb128 (op_code_data, & bytes_read,
				      end_of_sequence);
                      op_code_data += bytes_read;
                      /* File length.  */
                      file_table[n_files].length =
                        read_uleb128 (op_code_data, & bytes_read,
				      end_of_sequence);

                      n_files++;
                      break;
                    }
                  case DW_LNE_set_discriminator:
                  case DW_LNE_HP_set_sequence:
                    /* Simply ignored.  */
                    break;

                  default:
                    printf (_("UNKNOWN (%u): length %d\n"),
                            ext_op_code, ext_op_code_len - bytes_read);
                    break;
                  }
                data += ext_op_code_len;
                break;
              }
            case DW_LNS_copy:
              break;

            case DW_LNS_advance_pc:
              uladv = read_uleb128 (data, & bytes_read, end);
              data += bytes_read;
	      if (linfo.li_max_ops_per_insn == 1)
		{
		  uladv *= linfo.li_min_insn_length;
		  state_machine_regs.address += uladv;
		}
	      else
		{
		  state_machine_regs.address
		    += ((state_machine_regs.op_index + uladv)
			/ linfo.li_max_ops_per_insn)
		       * linfo.li_min_insn_length;
		  state_machine_regs.op_index
		    = (state_machine_regs.op_index + uladv)
		      % linfo.li_max_ops_per_insn;
		}
              break;

            case DW_LNS_advance_line:
              adv = read_sleb128 (data, & bytes_read, end);
              data += bytes_read;
              state_machine_regs.line += adv;
              break;

            case DW_LNS_set_file:
              adv = read_uleb128 (data, & bytes_read, end);
              data += bytes_read;
              state_machine_regs.file = adv;
              if (file_table[state_machine_regs.file - 1].directory_index == 0)
                {
                  /* If directory index is 0, that means current directory.  */
                  printf ("\n./%s:[++]\n",
                          file_table[state_machine_regs.file - 1].name);
                }
              else
                {
                  /* The directory index starts counting at 1.  */
                  printf ("\n%s/%s:\n",
                          directory_table[file_table[state_machine_regs.file - 1].directory_index - 1],
                          file_table[state_machine_regs.file - 1].name);
                }
              break;

            case DW_LNS_set_column:
              uladv = read_uleb128 (data, & bytes_read, end);
              data += bytes_read;
              state_machine_regs.column = uladv;
              break;

            case DW_LNS_negate_stmt:
              adv = state_machine_regs.is_stmt;
              adv = ! adv;
              state_machine_regs.is_stmt = adv;
              break;

            case DW_LNS_set_basic_block:
              state_machine_regs.basic_block = 1;
              break;

            case DW_LNS_const_add_pc:
	      uladv = ((255 - linfo.li_opcode_base) / linfo.li_line_range);
	      if (linfo.li_max_ops_per_insn == 1)
		{
		  uladv *= linfo.li_min_insn_length;
		  state_machine_regs.address += uladv;
		}
	      else
		{
		  state_machine_regs.address
		    += ((state_machine_regs.op_index + uladv)
			/ linfo.li_max_ops_per_insn)
		       * linfo.li_min_insn_length;
		  state_machine_regs.op_index
		    = (state_machine_regs.op_index + uladv)
		      % linfo.li_max_ops_per_insn;
		}
              break;

            case DW_LNS_fixed_advance_pc:
	      SAFE_BYTE_GET_AND_INC (uladv, data, 2, end);
              state_machine_regs.address += uladv;
	      state_machine_regs.op_index = 0;
              break;

            case DW_LNS_set_prologue_end:
              break;

            case DW_LNS_set_epilogue_begin:
              break;

            case DW_LNS_set_isa:
              uladv = read_uleb128 (data, & bytes_read, end);
              data += bytes_read;
              printf (_("  Set ISA to %lu\n"), uladv);
              break;

            default:
              printf (_("  Unknown opcode %d with operands: "), op_code);

              for (i = standard_opcodes[op_code - 1]; i > 0 ; --i)
                {
                  printf ("0x%s%s", dwarf_vmatoa ("x", read_uleb128 (data,
								     &bytes_read, end)),
                          i == 1 ? "" : ", ");
                  data += bytes_read;
                }
              putchar ('\n');
              break;
            }
d3358 1
a3358 1
              char *fileName = (char *)file_table[state_machine_regs.file - 1].name;
d3360 8
a3367 1
              size_t fileNameLength = strlen (fileName);
d3414 15
a3428 4
      free (file_table);
      file_table = NULL;
      free (directory_table);
      directory_table = NULL;
@


1.130
log
@	PR binutils/15324
	* configure.in: Add strnlen to AC_CHECK_DECLS, sort.
	* dwarf.c (strnlen): Provide fallback decl.
	* config.in: Regnerate.
	* configure: Regenerate.
@
text
@d2382 3
a2384 1
	      if (!do_loc && die_offset >= dwarf_start_die)
@


1.129
log
@Increment hdrptr by 8 after SAFE_BYTE_GET64

	* dwarf.c (process_debug_info): Increment hdrptr by 8 after
	SAFE_BYTE_GET64.
@
text
@d32 4
@


1.128
log
@	PR binutils/15206
	* dwarf.c (read_and_display_attr_value): Cast format '*' arg to int.
@
text
@d2241 1
@


1.127
log
@	PR binutils/15205
	* dwarf.c (SAFE_BYTE_GET): New macro - checks remaining buffer
	space before calling byte_get.
	(SAFE_BYTE_GET_AND_INC): New macro.
	(SAFE_SIGNED_BYTE_GET): New macro.
	(SAFE_SIGNED_BYTE_GET_AND_INC): New macro.
	(SAFE_BYTE_GET64): New macro.
	(process_extened_line_op): Use new macros.  Use strnlen when
	appropriate.
	(fetch_indirect_string): Likewise.
	(get_FORM_name): Likewise.
	(decode_location_expression): Likewise.
	(read_and_display_attr_value): Likewise.
	(process_debug_info): Likewise.
	(display_debug_lines_raw): Likewise.
	(display_debug_lines_decoded): Likewise.
	(display_debug_pubnames): Likewise.
	(display_debug_macinfo): Likewise.
	(get_line_filename_and_dirname): Likewise.
	(display_debug_macro): Likewise.
	(display_loc_list): Likewise.
	(display_loc_list_dwo): Likewise.
	(display_debug_aranges): Likewise.
	(display_debug_ranges): Likewise.
	(frame_display_row): Likewise.
	(display_debug_frames): Likewise.
@
text
@d1588 1
a1588 1
	printf (" %.*s", end - data, data);
@


1.126
log
@	PR binutils/15202
	* dwarf.c (read_leb128): Add END parameter.  Do not read at or
	beyond end.
	(read_sleb128): Add END parameter.
	(read_uleb128): New function.
	(process_extended_line_op): Pass END to leb128 functions.
	(process_abbrev_section): Likewise.
	(decode_location_expression): Likewise.
	(read_and_display_attr_value): Likewise.
	(read_and_display_attr): Likewise.
	(process_debug_info): Likewise.
	(display_debug_lines_raw): Likewise.
	(display_debug_lines_decoded): Likewise.
	(display_debug_macinfo): Likewise.
	(get_line_filename_and_dirname): Likewise.
	(display_debug_macro): Likewise.
	(display_loc_list_dwo): Likewise.
	(display_debug_ranges): Likewise.
	* dwarf.h (read_leb128): Update prototype.
	* readelf.c (read_uleb128): Add END parameter.
	(decode_arm_unwind_bytecode): Pass END to read_uleb128.
	(decode_tic6x_unwind_bytecode): Likewise.
	(display_tag_value): New function.
	(display_arm_attribute): Add END parameter. Pass END to
	read_uleb128.  Use display_tag_value.
	(display_gnu_attribute): Likewise.
	(display_power_gnu_attribute): Likewise.
	(display_sparc_gnu_attribute): Likewise.
	(display_mips_gnu_attribute): Likewise.
	(display_tic6x_attribute): Likewise.
	(process_attributes): Likewise.
	(display_raw_attribute): New function.
@
text
@d281 67
d416 1
a416 1
      adr = byte_get (data, len - bytes_read - 1);
d428 1
a428 1
      data += strlen ((char *) data) + 1;
d548 1
a548 1
static const char *
d554 1
a554 1
    return _("<no .debug_str section>");
d562 1
a562 1
      return _("<offset is too big>");
d565 1
a565 1
  return (const char *) section->start + offset;
d827 3
a829 1
display_block (unsigned char *data, dwarf_vma length)
d831 2
d835 3
d856 1
d867 2
a868 3
         printf ("DW_OP_addr: %s",
                 dwarf_vmatoa ("x", byte_get (data, pointer_size)));
	  data += pointer_size;
d874 2
a875 1
	  printf ("DW_OP_const1u: %lu", (unsigned long) byte_get (data++, 1));
d878 2
a879 1
	  printf ("DW_OP_const1s: %ld", (long) byte_get_signed (data++, 1));
d882 2
a883 2
	  printf ("DW_OP_const2u: %lu", (unsigned long) byte_get (data, 2));
	  data += 2;
d886 2
a887 2
	  printf ("DW_OP_const2s: %ld", (long) byte_get_signed (data, 2));
	  data += 2;
d890 2
a891 2
	  printf ("DW_OP_const4u: %lu", (unsigned long) byte_get (data, 4));
	  data += 4;
d894 2
a895 2
	  printf ("DW_OP_const4s: %ld", (long) byte_get_signed (data, 4));
	  data += 4;
d898 4
a901 3
	  printf ("DW_OP_const8u: %lu %lu", (unsigned long) byte_get (data, 4),
		  (unsigned long) byte_get (data + 4, 4));
	  data += 8;
d904 4
a907 3
	  printf ("DW_OP_const8s: %ld %ld", (long) byte_get (data, 4),
		  (long) byte_get (data + 4, 4));
	  data += 8;
d929 2
a930 1
	  printf ("DW_OP_pick: %ld", (unsigned long) byte_get (data++, 1));
d989 2
a990 2
	  printf ("DW_OP_bra: %ld", (long) byte_get_signed (data, 2));
	  data += 2;
d1011 2
a1012 2
	  printf ("DW_OP_skip: %ld", (long) byte_get_signed (data, 2));
	  data += 2;
d1151 2
a1152 1
	  printf ("DW_OP_deref_size: %ld", (long) byte_get (data++, 1));
d1155 2
a1156 1
	  printf ("DW_OP_xderef_size: %ld", (long) byte_get (data++, 1));
d1169 1
d1171 1
a1171 3
		  dwarf_vmatoa ("x", (dwarf_signed_vma) byte_get (data, 2)
				     + cu_offset));
	  data += 2;
d1176 1
d1178 1
a1178 3
		  dwarf_vmatoa ("x", (dwarf_signed_vma) byte_get (data, 4)
				     + cu_offset));
	  data += 4;
d1191 1
a1191 3
	      printf ("DW_OP_call_ref: <0x%s>",
		      dwarf_vmatoa ("x", byte_get (data, pointer_size)));
	      data += pointer_size;
d1195 1
a1195 3
	      printf ("DW_OP_call_ref: <0x%s>",
		      dwarf_vmatoa ("x", byte_get (data, offset_size)));
	      data += offset_size;
d1197 1
d1224 1
a1224 1
	  display_block (data, uvalue);
d1260 1
a1260 5
	      printf ("DW_OP_GNU_implicit_pointer: <0x%s> %s",
		      dwarf_vmatoa ("x", byte_get (data, pointer_size)),
		      dwarf_vmatoa ("d", read_sleb128 (data + pointer_size,
						       &bytes_read, end)));
	      data += pointer_size + bytes_read;
d1264 1
a1264 5
	      printf ("DW_OP_GNU_implicit_pointer: <0x%s> %s",
		      dwarf_vmatoa ("x", byte_get (data, offset_size)),
		      dwarf_vmatoa ("d", read_sleb128 (data + offset_size,
						       &bytes_read, end)));
	      data += offset_size + bytes_read;
d1266 5
d1288 2
a1289 2
	  uvalue = byte_get (data++, 1);
	  display_block (data, uvalue);
d1302 2
a1303 1
	  printf ("DW_OP_GNU_deref_type: %ld", (long) byte_get (data++, 1));
d1321 1
d1323 1
a1323 2
		  dwarf_vmatoa ("x", cu_offset + byte_get (data, 4)));
	  data += 4;
d1440 6
d1453 1
a1453 4
	{
	  uvalue = byte_get (data, pointer_size);
	  data += pointer_size;
	}
d1455 1
a1455 4
	{
	  uvalue = byte_get (data, offset_size);
	  data += offset_size;
	}
d1462 1
a1462 2
      uvalue = byte_get (data, pointer_size);
      data += pointer_size;
d1469 1
a1469 2
      uvalue = byte_get (data, offset_size);
      data += offset_size;
d1479 1
a1479 1
      uvalue = byte_get (data++, 1);
d1484 1
a1484 2
      uvalue = byte_get (data, 2);
      data += 2;
d1489 1
a1489 2
      uvalue = byte_get (data, 4);
      data += 4;
d1568 2
a1569 1
	  byte_get_64 (data, &high_bits, &uvalue);
d1573 1
d1578 1
a1578 1
	    uvalue = byte_get (data, 8);
d1582 1
d1588 2
a1589 2
	printf (" %s", data);
      data += strlen ((char *) data) + 1;
d1599 1
a1599 1
	data = display_block (block_start, uvalue);
d1603 1
a1603 1
      uvalue = byte_get (data, 1);
d1608 1
a1608 1
	data = display_block (block_start, uvalue);
d1612 1
a1612 1
      uvalue = byte_get (data, 2);
d1617 1
a1617 1
	data = display_block (block_start, uvalue);
d1621 1
a1621 1
      uvalue = byte_get (data, 4);
d1626 1
a1626 1
	data = display_block (block_start, uvalue);
d1664 1
a1664 1
	  byte_get_64 (data, &high_bits, &uvalue);
d2121 1
a2121 1
	  length = byte_get (section_begin, 4);
d2125 1
a2125 1
	      length = byte_get (section_begin + 4, 8);
d2203 1
a2203 2
      compunit.cu_length = byte_get (hdrptr, 4);
      hdrptr += 4;
d2207 1
a2207 2
	  compunit.cu_length = byte_get (hdrptr, 8);
	  hdrptr += 8;
d2217 1
a2217 2
      compunit.cu_version = byte_get (hdrptr, 2);
      hdrptr += 2;
d2223 1
a2223 2
      compunit.cu_abbrev_offset = byte_get (hdrptr, offset_size);
      hdrptr += offset_size;
d2236 1
a2236 2
      compunit.cu_pointer_size = byte_get (hdrptr, 1);
      hdrptr += 1;
d2240 2
a2241 4
          byte_get_64 (hdrptr, &signature_high, &signature_low);
          hdrptr += 8;
          type_offset = byte_get (hdrptr, offset_size);
          hdrptr += offset_size;
d2567 1
a2567 2
      linfo.li_length = byte_get (hdrptr, 4);
      hdrptr += 4;
d2572 1
a2572 2
	  linfo.li_length = byte_get (hdrptr, 8);
	  hdrptr += 8;
d2591 1
a2591 2
      linfo.li_version = byte_get (hdrptr, 2);
      hdrptr += 2;
d2600 3
a2602 4
      linfo.li_prologue_length = byte_get (hdrptr, offset_size);
      hdrptr += offset_size;
      linfo.li_min_insn_length = byte_get (hdrptr, 1);
      hdrptr++;
d2605 2
a2606 2
	  linfo.li_max_ops_per_insn = byte_get (hdrptr, 1);
	  hdrptr++;
d2615 5
a2619 8
      linfo.li_default_is_stmt = byte_get (hdrptr, 1);
      hdrptr++;
      linfo.li_line_base = byte_get (hdrptr, 1);
      hdrptr++;
      linfo.li_line_range = byte_get (hdrptr, 1);
      hdrptr++;
      linfo.li_opcode_base = byte_get (hdrptr, 1);
      hdrptr++;
d2662 1
a2662 1
	      data += strlen ((char *) data) + 1;
d2684 1
a2684 1
	      data += strlen ((char *) data) + 1;
d2854 1
a2854 2
	      uladv = byte_get (data, 2);
	      data += 2;
d2935 1
a2935 2
      linfo.li_length = byte_get (hdrptr, 4);
      hdrptr += 4;
d2940 1
a2940 2
          linfo.li_length = byte_get (hdrptr, 8);
          hdrptr += 8;
d2958 1
a2958 2
      linfo.li_version = byte_get (hdrptr, 2);
      hdrptr += 2;
d2968 3
a2970 4
      linfo.li_prologue_length = byte_get (hdrptr, offset_size);
      hdrptr += offset_size;
      linfo.li_min_insn_length = byte_get (hdrptr, 1);
      hdrptr++;
d2973 1
a2973 2
	  linfo.li_max_ops_per_insn = byte_get (hdrptr, 1);
	  hdrptr++;
d2982 5
a2986 8
      linfo.li_default_is_stmt = byte_get (hdrptr, 1);
      hdrptr++;
      linfo.li_line_base = byte_get (hdrptr, 1);
      hdrptr++;
      linfo.li_line_range = byte_get (hdrptr, 1);
      hdrptr++;
      linfo.li_opcode_base = byte_get (hdrptr, 1);
      hdrptr++;
d3008 1
a3008 1
	      data += strlen ((char *) data) + 1;
d3020 2
a3021 1
              ptr_directory_table += strlen ((char *) ptr_directory_table) + 1;
d3039 1
a3039 1
              data += strlen ((char *) data) + 1;
d3059 2
a3060 1
              ptr_file_name_table += strlen ((char *) ptr_file_name_table) + 1;
d3085 1
d3159 3
a3161 2
                    state_machine_regs.address =
                    byte_get (op_code_data, ext_op_code_len - bytes_read - 1);
d3288 1
a3288 2
              uladv = byte_get (data, 2);
              data += 2;
d3444 1
a3444 2
      names.pn_length = byte_get (data, 4);
      data += 4;
d3447 1
a3447 2
	  names.pn_length = byte_get (data, 8);
	  data += 8;
d3457 2
a3458 5
      names.pn_version = byte_get (data, 2);
      data += 2;

      names.pn_offset = byte_get (data, offset_size);
      data += offset_size;
d3466 1
a3466 2
      names.pn_size = byte_get (data, offset_size);
      data += offset_size;
d3496 1
a3496 1
	  offset = byte_get (data, offset_size);
d3502 1
a3502 1
	      data += strlen ((char *) data) + 1;
d3527 1
a3527 1
      const char *string;
d3555 2
a3556 2
	  string = (char *) curr;
	  curr += strlen (string) + 1;
d3564 2
a3565 2
	  string = (char *) curr;
	  curr += strlen (string) + 1;
d3576 2
a3577 2
	    string = (char *) curr;
	    curr += strlen (string) + 1;
d3612 2
a3613 2
  length = byte_get (hdrptr, 4);
  hdrptr += 4;
d3617 1
a3617 2
      length = byte_get (hdrptr, 8);
      hdrptr += 8;
d3628 2
a3629 2
  version = byte_get (hdrptr, 2);
  hdrptr += 2;
d3636 2
a3637 1
  opcode_base = byte_get (hdrptr, 1);
d3640 1
a3640 1
  hdrptr++;
d3645 1
a3645 1
    hdrptr += strlen ((char *) hdrptr) + 1;
d3650 1
a3650 1
      hdrptr += strlen ((char *) hdrptr) + 1;
d3661 1
a3661 1
  hdrptr += strlen ((char *) hdrptr) + 1;
d3666 1
a3666 1
    dirtable += strlen ((char *) dirtable) + 1;
d3692 1
a3692 1
      const char *string;
d3696 1
a3696 3
      version = byte_get (curr, 2);
      curr += 2;

d3704 1
a3704 1
      flags = byte_get (curr++, 1);
d3713 1
a3713 2
	  line_offset = byte_get (curr, offset_size);
	  curr += offset_size;
d3719 1
a3719 1
	  unsigned int i, count = byte_get (curr++, 1), op;
d3721 3
d3731 1
a3731 1
		  op = byte_get (curr++, 1);
d3742 3
a3744 1
			  unsigned int form = byte_get (curr++, 1);
d3786 1
a3786 1
	  op = byte_get (curr++, 1);
d3826 2
a3827 2
	      string = (char *) curr;
	      curr += strlen (string) + 1;
d3835 2
a3836 2
	      string = (char *) curr;
	      curr += strlen (string) + 1;
d3844 1
a3844 2
	      offset = byte_get (curr, offset_size);
	      curr += offset_size;
d3853 1
a3853 2
	      offset = byte_get (curr, offset_size);
	      curr += offset_size;
d3860 1
a3860 2
	      offset = byte_get (curr, offset_size);
	      curr += offset_size;
d3868 1
a3868 2
	      offset = byte_get (curr, offset_size);
	      curr += offset_size;
d3876 1
a3876 2
	      offset = byte_get (curr, offset_size);
	      curr += offset_size;
d3882 1
a3882 2
	      offset = byte_get (curr, offset_size);
	      curr += offset_size;
d3908 3
d3912 1
a3912 1
			= read_and_display_attr_value (0, byte_get (desc++, 1),
d4014 2
a4015 4
      begin = byte_get_signed (start, pointer_size);
      start += pointer_size;
      end = byte_get_signed (start, pointer_size);
      start += pointer_size;
d4040 1
a4040 2
      length = byte_get (start, 2);
      start += 2;
d4122 1
a4122 2
      entry_type = byte_get (start, 1);
      start++;
d4148 1
a4148 2
            idx = byte_get (start, 4);
            start += 4;
d4152 1
a4152 2
            idx = byte_get (start, 4);
            start += 4;
d4154 1
a4154 2
            idx = byte_get (start, 4);
            start += 4;
d4170 1
a4170 3
      length = byte_get (start, 2);
      start += 2;

d4472 1
a4472 3
      arange.ar_length = byte_get (hdrptr, 4);
      hdrptr += 4;

d4475 1
a4475 2
	  arange.ar_length = byte_get (hdrptr, 8);
	  hdrptr += 8;
d4485 2
a4486 5
      arange.ar_version = byte_get (hdrptr, 2);
      hdrptr += 2;

      arange.ar_info_offset = byte_get (hdrptr, offset_size);
      hdrptr += offset_size;
d4494 2
a4495 5
      arange.ar_pointer_size = byte_get (hdrptr, 1);
      hdrptr += 1;

      arange.ar_segment_size = byte_get (hdrptr, 1);
      hdrptr += 1;
d4545 2
a4546 7
	  address = byte_get (addr_ranges, address_size);

	  addr_ranges += address_size;

	  length  = byte_get (addr_ranges, address_size);

	  addr_ranges += address_size;
d4787 1
a4787 2
	  begin = byte_get_signed (start, pointer_size);
	  start += pointer_size;
d4790 1
a4790 2
	  end = byte_get_signed (start, pointer_size);
	  start += pointer_size;
d5052 1
a5052 1
#define GET(N)	byte_get (start, N); start += N
a5089 1
      length = byte_get (start, 4); start += 4;
d5091 1
d5101 1
a5101 2
	  length = byte_get (start, 8);
	  start += 8;
d5118 2
a5119 1
      cie_id = byte_get (start, offset_size); start += offset_size;
d5146 2
a5147 2
	      fc->ptr_size = GET (1);
	      fc->segment_size = GET (1);
d5159 1
a5159 1
	      fc->ra = GET (1);
d5287 1
a5287 2
	      segment_selector = byte_get (start, fc->segment_size);
	      start += fc->segment_size;
a5290 2
	  fc->pc_range = byte_get (start, encoded_ptr_size);
	  start += encoded_ptr_size;
d5292 6
d5524 1
a5524 1
	      ofs = byte_get (start, 1); start += 1;
d5535 1
a5535 1
	      ofs = byte_get (start, 2); start += 2;
d5546 1
a5546 1
	      ofs = byte_get (start, 4); start += 4;
d5809 1
a5809 1
	      ofs = byte_get (start, 8); start += 8;
@


1.125
log
@binutils/
	* dwarf.c (cu_tu_indexes_read, shndx_pool, shndx_pool_size)
	(shndx_pool_used): Move to top of file.
	(struct cu_tu_set): New type.
	(cu_count, tu_count, cu_sets, tu_sets): New file scope variables.
	(fetch_indexed_string): Add "this_set" parameter.  Update all callers.
	(find_cu_tu_set_v2): New function.
	(read_and_display_attr_value): Add "this_set" parameter.
	(read_and_display_attr): Likewise.
	(process_debug_info): Track base offsets for DWARF package files.
	(load_debug_info): Call load_cu_tu_indexes.
	(get_DW_SECT_short_name): New function.
	(process_cu_tu_index): Add support for version 2 DWARF package files.
@
text
@d2 1
a2 2
   Copyright 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
   Free Software Foundation, Inc.
d227 5
d233 4
a236 1
read_leb128 (unsigned char *data, unsigned int *length_return, int sign)
d241 1
a241 1
  unsigned char byte;
d243 1
a243 1
  do
d251 2
a252 1

a253 1
  while (byte & 0x80);
d265 4
a268 2
static dwarf_signed_vma
read_sleb128 (unsigned char *data, unsigned int *length_return)
d270 9
a278 1
  return (dwarf_signed_vma) read_leb128 (data, length_return, 1);
d316 3
a318 1
process_extended_line_op (unsigned char *data, int is_stmt)
d324 1
a325 1
  unsigned char *orig_data = data;
d327 1
a327 1
  len = read_leb128 (data, & bytes_read, 0);
d330 1
a330 1
  if (len == 0)
d358 1
a359 1
      printf ("   %d\t", ++state_machine_regs.last_file_entry);
d362 1
a362 1
      printf ("%s\t", dwarf_vmatoa ("u", read_leb128 (data, & bytes_read, 0)));
d364 1
a364 1
      printf ("%s\t", dwarf_vmatoa ("u", read_leb128 (data, & bytes_read, 0)));
d366 1
a366 1
      printf ("%s\t", dwarf_vmatoa ("u", read_leb128 (data, & bytes_read, 0)));
d368 4
a371 4
      printf ("%s", name);
      if ((unsigned int) (data - orig_data) != len)
        printf (_(" [Bad opcode length]"));
      printf ("\n\n");
d376 1
a376 1
	      dwarf_vmatoa ("u", read_leb128 (data, & bytes_read, 0)));
d420 1
a420 1
            opc = read_leb128 (data, & bytes_read, 0);
d431 1
a431 1
                                      read_leb128 (data, & bytes_read, 0)));
d438 1
a438 1
                                      read_leb128 (data, & bytes_read, 0)));
d442 1
a442 1
                                      read_leb128 (data, & bytes_read, 0)));
d446 1
a446 1
                                      read_leb128 (data, & bytes_read, 0)));
d678 1
a678 1
      entry = read_leb128 (start, & bytes_read, 0);
d684 2
d687 1
a687 1
	return start == end ? NULL : start;
d689 1
a689 1
      tag = read_leb128 (start, & bytes_read, 0);
d691 2
d702 1
a702 1
	  attribute = read_leb128 (start, & bytes_read, 0);
d704 2
d707 1
a707 1
	  form = read_leb128 (start, & bytes_read, 0);
d709 2
d833 1
a833 1
		  dwarf_vmatoa ("u", read_leb128 (data, &bytes_read, 0)));
d838 1
a838 1
		  dwarf_vmatoa ("d", read_sleb128 (data, &bytes_read)));
d894 1
a894 1
		  dwarf_vmatoa ("u", read_leb128 (data, &bytes_read, 0)));
d1042 1
a1042 2
		  dwarf_vmatoa ("d", (dwarf_signed_vma)
		    read_leb128 (data, &bytes_read, 1)));
d1047 1
a1047 1
	  uvalue = read_leb128 (data, &bytes_read, 0);
d1055 1
a1055 1
		  dwarf_vmatoa ("d", read_sleb128 (data, &bytes_read)));
d1059 1
a1059 1
	  uvalue = read_leb128 (data, &bytes_read, 0);
d1063 1
a1063 1
		  dwarf_vmatoa ("d", read_sleb128 (data, &bytes_read)));
d1068 1
a1068 1
		  dwarf_vmatoa ("u", read_leb128 (data, &bytes_read, 0)));
d1132 1
a1132 1
		  dwarf_vmatoa ("u", read_leb128 (data, &bytes_read, 0)));
d1135 1
a1135 1
		  dwarf_vmatoa ("u", read_leb128 (data, &bytes_read, 0)));
d1146 1
a1146 1
	  uvalue = read_leb128 (data, &bytes_read, 0);
d1187 1
a1187 1
				     &bytes_read)));
d1195 1
a1195 1
				     &bytes_read)));
d1200 1
a1200 1
	  uvalue = read_leb128 (data, &bytes_read, 0);
d1211 1
a1211 1
	  uvalue = read_leb128 (data, &bytes_read, 0);
d1220 1
a1220 1
	  uvalue = read_leb128 (data, &bytes_read, 0);
d1224 1
a1224 1
	  uvalue = read_leb128 (data, &bytes_read, 0);
d1230 1
a1230 1
	  uvalue = read_leb128 (data, &bytes_read, 0);
d1235 1
a1235 1
	  uvalue = read_leb128 (data, &bytes_read, 0);
d1241 1
a1241 1
	  uvalue = read_leb128 (data, &bytes_read, 0);
d1252 1
a1252 1
          uvalue = read_leb128 (data, &bytes_read, 0);
d1257 1
a1257 1
          uvalue = read_leb128 (data, &bytes_read, 0);
d1351 1
d1423 1
a1423 1
      uvalue = read_leb128 (data, & bytes_read, 1);
d1428 1
a1428 1
      uvalue = read_leb128 (data, & bytes_read, 0);
d1434 1
a1434 1
      uvalue = read_leb128 (data, & bytes_read, 0);
d1439 1
a1439 1
      form = read_leb128 (data, & bytes_read, 0);
d1443 1
a1443 1
      return read_and_display_attr_value (attribute, form, data,
d1449 1
a1449 1
      uvalue = read_leb128 (data, & bytes_read, 0);
d1521 1
a1521 1
      uvalue = read_leb128 (data, & bytes_read, 0);
d1940 1
a1940 1
	    abbrev_number = read_leb128 (section->start + uvalue, NULL, 0);
d1996 1
d2008 2
a2009 2
  data = read_and_display_attr_value (attribute, form, data, cu_offset,
				      pointer_size, offset_size,
d2292 1
a2292 1
	  abbrev_number = read_leb128 (tags, & bytes_read, 0);
d2409 1
a2624 1

d2628 1
a2628 1
		      dwarf_vmatoa ("u", read_leb128 (data, & bytes_read, 0)));
d2631 1
a2631 1
		      dwarf_vmatoa ("u", read_leb128 (data, & bytes_read, 0)));
d2634 1
a2634 1
		      dwarf_vmatoa ("u", read_leb128 (data, & bytes_read, 0)));
d2637 6
d2697 1
a2697 1
	      data += process_extended_line_op (data, linfo.li_default_is_stmt);
d2705 1
a2705 1
	      uladv = read_leb128 (data, & bytes_read, 0);
d2732 1
a2732 1
	      adv = read_sleb128 (data, & bytes_read);
d2741 1
a2741 1
	      adv = read_leb128 (data, & bytes_read, 0);
d2749 1
a2749 1
	      uladv = read_leb128 (data, & bytes_read, 0);
d2813 1
a2813 1
	      uladv = read_leb128 (data, & bytes_read, 0);
d2823 2
a2824 2
		  printf ("0x%s%s", dwarf_vmatoa ("x", read_leb128 (data,
							 &bytes_read, 0)),
d2989 1
a2989 1
              read_leb128 (data, & bytes_read, 0);
d2991 1
a2991 1
              read_leb128 (data, & bytes_read, 0);
d2993 1
a2993 1
              read_leb128 (data, & bytes_read, 0);
d3011 2
a3012 2
              file_table[i].directory_index = read_leb128 (ptr_file_name_table,
                                                           & bytes_read, 0);
d3014 2
a3015 2
              file_table[i].modification_date = read_leb128 (ptr_file_name_table,
							     & bytes_read, 0);
d3017 1
a3017 1
              file_table[i].length = read_leb128 (ptr_file_name_table, & bytes_read, 0);
d3088 2
a3089 1
                ext_op_code_len = read_leb128 (op_code_data, &bytes_read, 0);
d3121 2
a3122 1
                        read_leb128 (op_code_data, & bytes_read, 0);
d3126 2
a3127 1
                        read_leb128 (op_code_data, & bytes_read, 0);
d3131 2
a3132 1
                        read_leb128 (op_code_data, & bytes_read, 0);
d3154 1
a3154 1
              uladv = read_leb128 (data, & bytes_read, 0);
d3174 1
a3174 1
              adv = read_sleb128 (data, & bytes_read);
d3180 1
a3180 1
              adv = read_leb128 (data, & bytes_read, 0);
d3199 1
a3199 1
              uladv = read_leb128 (data, & bytes_read, 0);
d3247 1
a3247 1
              uladv = read_leb128 (data, & bytes_read, 0);
d3257 2
a3258 2
                  printf ("0x%s%s", dwarf_vmatoa ("x", read_leb128 (data,
							 &bytes_read, 0)),
d3491 1
a3491 1
	    lineno = read_leb128 (curr, & bytes_read, 0);
d3493 1
a3493 1
	    filenum = read_leb128 (curr, & bytes_read, 0);
d3506 1
a3506 1
	  lineno = read_leb128 (curr, & bytes_read, 0);
d3515 1
a3515 1
	  lineno = read_leb128 (curr, & bytes_read, 0);
d3527 1
a3527 1
	    constant = read_leb128 (curr, & bytes_read, 0);
d3546 2
a3547 1
get_line_filename_and_dirname (dwarf_vma line_offset, dwarf_vma fileidx,
d3555 1
d3564 1
d3604 1
a3604 1
      read_leb128 (hdrptr, &bytes_read, 0);
d3606 1
a3606 1
      read_leb128 (hdrptr, &bytes_read, 0);
d3608 1
a3608 1
      read_leb128 (hdrptr, &bytes_read, 0);
d3611 1
a3611 1
  if (*hdrptr == '\0')
d3615 1
a3615 1
  diridx = read_leb128 (hdrptr, &bytes_read, 0);
d3686 1
a3686 1
		  nargs = read_leb128 (curr, &bytes_read, 0);
d3748 1
a3748 1
		lineno = read_leb128 (curr, &bytes_read, 0);
d3750 1
a3750 1
		filenum = read_leb128 (curr, &bytes_read, 0);
d3775 1
a3775 1
	      lineno = read_leb128 (curr, &bytes_read, 0);
d3784 1
a3784 1
	      lineno = read_leb128 (curr, &bytes_read, 0);
d3793 1
a3793 1
	      lineno = read_leb128 (curr, &bytes_read, 0);
d3803 1
a3803 1
	      lineno = read_leb128 (curr, &bytes_read, 0);
d3820 1
a3820 1
	      lineno = read_leb128 (curr, &bytes_read, 0);
d3829 1
a3829 1
	      lineno = read_leb128 (curr, &bytes_read, 0);
d3855 1
a3855 1
		  nargs = read_leb128 (desc, &bytes_read, 0);
d3867 1
a3867 1
						       curr, 0, 0, offset_size,
d4088 1
a4088 1
            idx = read_leb128 (start, &bytes_read, 0);
d4095 1
a4095 1
            idx = read_leb128 (start, &bytes_read, 0);
d4098 1
a4098 1
            idx = read_leb128 (start, &bytes_read, 0);
d4103 1
a4103 1
            idx = read_leb128 (start, &bytes_read, 0);
d4661 1
a4661 1
  unsigned long bytes;
d4663 1
a4666 2
  bytes = section->size;

d4754 1
a4754 1
      while (1)
d4766 2
d5032 2
a5033 2
#define LEB()	read_leb128 (start, & length_return, 0); start += length_return
#define SLEB()	read_sleb128 (start, & length_return); start += length_return
@


1.124
log
@	* dwarf.c (display_gdb_index): Handle .gdb_index version 8.
@
text
@d74 30
d483 2
a484 1
fetch_indexed_string (dwarf_vma idx, dwarf_vma offset_size, int dwo)
d499 2
d1289 32
d1331 2
a1332 1
			     struct dwarf_section * section)
d1420 1
a1420 1
					  section);
d1544 1
a1544 1
                  fetch_indexed_string (uvalue, offset_size, dwo));
d1622 2
d1975 2
a1976 1
		       struct dwarf_section * section)
d1983 1
a1983 1
				      do_loc, section);
a1988 1

d2096 3
d2123 2
d2128 11
d2192 19
d2239 1
a2239 1
      if (compunit.cu_abbrev_offset >= debug_displays [abbrev_sec].section.size)
d2242 1
a2242 1
	      (unsigned long) debug_displays [abbrev_sec].section.size);
d2245 4
a2248 4
	  ((unsigned char *) debug_displays [abbrev_sec].section.start
	   + compunit.cu_abbrev_offset,
	   (unsigned char *) debug_displays [abbrev_sec].section.start
	   + debug_displays [abbrev_sec].section.size);
d2380 2
a2381 1
					    tags, cu_offset,
d2386 3
a2388 1
					    do_loc || ! do_printing, section);
d2432 3
d3827 2
a3828 1
						       version, NULL, 0, NULL);
d4001 1
a4001 1
  printf("%*s ", len, buf);
a5990 9
/* Collection of CU/TU section sets from .debug_cu_index and .debug_tu_index
   sections.  Each set is stored in SHNDX_POOL as a zero-terminated list of
   section indexes comprising one set of debug sections from a .dwo file.  */

int cu_tu_indexes_read = 0;
unsigned int *shndx_pool = NULL;
unsigned int shndx_pool_size = 0;
unsigned int shndx_pool_used = 0;

d6033 36
a6068 1
/* Process a CU or TU index.  If DO_DISPLAY is true, print the contents.  */
d6079 1
d6083 4
d6089 2
a6096 3
  if (!do_display)
    prealloc_cu_tu_list((limit - ppool) / 4);

d6101 2
d6114 1
a6114 1
  for (i = 0; i < nslots; i++)
d6116 6
a6121 6
      dwarf_vma signature_high;
      dwarf_vma signature_low;
      unsigned int j;
      unsigned char *shndx_list;
      unsigned int shndx;
      char buf[64];
d6123 2
a6124 10
      byte_get_64 (phash, &signature_high, &signature_low);
      if (signature_high != 0 || signature_low != 0)
	{
	  j = byte_get (pindex, 4);
	  shndx_list = ppool + j * 4;
	  if (do_display)
	    printf (_("  [%3d] Signature:  0x%s  Sections: "),
		    i, dwarf_vmatoa64 (signature_high, signature_low,
				       buf, sizeof (buf)));
	  for (;;)
d6126 7
a6132 1
	      if (shndx_list >= limit)
d6134 14
a6147 3
		  warn (_("Section %s too small for shndx pool\n"),
			section->name);
		  return 0;
a6148 3
	      shndx = byte_get (shndx_list, 4);
	      if (shndx == 0)
		break;
d6150 1
a6150 1
		printf (" %d", shndx);
d6152 1
a6152 2
		add_shndx_to_cu_tu_entry (shndx);
	      shndx_list += 4;
d6154 100
d6255 31
a6285 3
	    printf ("\n");
	  else
	    end_cu_tu_entry ();
a6286 2
      phash += 8;
      pindex += 4;
d6288 2
@


1.123
log
@binutils/
    	* dwarf.c (display_loc_list): Update offset for each line
    	printed.
    	(print_addr_index): New function.
    	(display_loc_list_dwo): Update offset for each line printed.
    	Fix problems displaying loclists in .dwo files.  Add support
    	for type 4 entries.
    	(display_debug_loc): Remove custom header for .dwo files.
    	(display_debug_addr): Adjust formatting.
@
text
@d5724 1
a5724 1
  if (version < 3 || version > 7)
d5737 4
@


1.122
log
@	* dwarf.c (display_debug_addr): Add missing parentheses to expression.
@
text
@d3811 2
a3821 2
      printf ("    %8.8lx ", offset);

d3883 11
d3914 1
a3914 1
  dwarf_vma idx;
d3919 1
a3919 1
      printf ("    %8.8lx ", offset);
d3921 1
a3921 1
      if (start + 2 > section_end)
a3932 2
            idx = byte_get (start, 1);
            start++;
d3934 1
a3934 5
            if (idx == 0)
              printf (_("<End of list>\n"));
            else
              warn (_("Location list starting at offset 0x%lx is not terminated.\n"),
                    offset);
d3939 3
a3941 2
            print_dwarf_vma (idx, pointer_size);
            printf (_("(base address index)\n"));
d3943 4
a3946 1
          case 2: /* A normal entry.  */
d3949 3
a3951 1
            print_dwarf_vma (idx, pointer_size);
d3954 12
a3965 1
            print_dwarf_vma (idx, pointer_size);
d3968 1
a3968 1
            warn (_("Unknown location-list type 0x%x.\n"), entry_type);
d4111 1
a4111 4
  if (!is_dwo)
    printf (_("    Offset   Begin    End      Expression\n"));
  else
    printf (_("    Offset   Begin idx End idx  Expression\n"));
d4439 1
d4444 1
a4444 1
      printf (_("\tIndex\tOffset\n"));
d4450 5
a4454 3
          dwarf_vma base = byte_get (entry, debug_addr_info [i]->pointer_size);
          printf (_("\t%d:\t%s\n"), idx, dwarf_vmatoa ("x", base));
          entry += debug_addr_info [i]->pointer_size;
@


1.121
log
@binutils/
	* dwarf.c (do_debug_addr, do_debug_cu_index): New global flags.
	(load_debug_info): Fix typo.
	(cu_tu_indexes_read, shndx_pool, shndx_pool_size, shndx_pool_used):
	New global variables.
	(prealloc_cu_tu_list, add_shndx_to_cu_tu_entry, end_cu_tu_entry)
	(process_cu_tu_index, load_cu_tu_indexes, find_cu_tu_set)
	(display_cu_index): New functions.
	(dwarf_select_sections_by_names): Add "debug_addr", "cu_index".
	Sort entries alphabetically.
	(dwarf_select_sections_all): Set do_debug_addr, do_debug_cu_index.
	(debug_displays): Add .debug_cu_index, .debug_tu_index.
	Clean up formatting.
	* dwarf.h (dwarf_section_display_enum): Add dwp_cu_index,
	dwp_tu_index.
	(do_debug_addr, do_debug_cu_index): New global flags.
	(find_cu_tu_set): New function declaration.
	* objdump.c (usage): Add --dwarf=addr, --dwarf=cu_index.
	* readelf.c (find_section_in_set): New function.
	(usage): Add --debug-dump=addr, --debug_dump=cu_index.
	(process_section_headers): Check do_debug_addr and do_debug_cu_index.
	(section_subset): New global variable.
	(load_debug_section): Restrict search to section subset.
	(display_debug_section): Add section index as paramter.  Select subset
	of sections when dumping a .dwp file.  Update caller.
@
text
@d4402 1
a4402 1
  debug_addr_info = (debug_info **) xmalloc (num_debug_info_entries + 1
@


1.120
log
@	* dwarf.c (display_gdb_index): Include static/global information
	of each symbol.
@
text
@d65 2
d2318 1
a2318 1
     section then do not bother to repear the task.  */
d5855 194
d6137 1
d6139 2
d6143 2
a6146 2
      { "rawline", & do_debug_lines, FLAG_DEBUG_LINES_RAW },
      { "decodedline", & do_debug_lines, FLAG_DEBUG_LINES_DECODED },
d6154 1
a6155 2
      /* The special .gdb_index section.  */
      { "gdb_index", & do_gdb_index, 1 },
d6284 2
d6290 1
a6290 1
  { { ".debug_abbrev",	    ".zdebug_abbrev",	NULL, NULL, 0, 0, abbrev },
d6292 1
a6292 1
  { { ".debug_aranges",	    ".zdebug_aranges",	NULL, NULL, 0, 0, abbrev },
d6294 1
a6294 1
  { { ".debug_frame",       ".zdebug_frame",	NULL, NULL, 0, 0, abbrev },
d6298 1
a6298 1
  { { ".debug_line",	    ".zdebug_line",	NULL, NULL, 0, 0, abbrev },
d6300 1
a6300 1
  { { ".debug_pubnames",    ".zdebug_pubnames",	NULL, NULL, 0, 0, abbrev },
d6302 1
a6302 1
  { { ".eh_frame",	    "",			NULL, NULL, 0, 0, abbrev },
d6304 1
a6304 1
  { { ".debug_macinfo",	    ".zdebug_macinfo",	NULL, NULL, 0, 0, abbrev },
d6306 1
a6306 1
  { { ".debug_macro",	    ".zdebug_macro",	NULL, NULL, 0, 0, abbrev },
d6308 1
a6308 1
  { { ".debug_str",	    ".zdebug_str",	NULL, NULL, 0, 0, abbrev },
d6310 1
a6310 1
  { { ".debug_loc",	    ".zdebug_loc",	NULL, NULL, 0, 0, abbrev },
d6312 1
a6312 1
  { { ".debug_pubtypes",    ".zdebug_pubtypes",	NULL, NULL, 0, 0, abbrev },
d6314 1
a6314 1
  { { ".debug_ranges",	    ".zdebug_ranges",	NULL, NULL, 0, 0, abbrev },
d6316 1
a6316 1
  { { ".debug_static_func", ".zdebug_static_func", NULL, NULL, 0, 0, abbrev },
d6318 1
a6318 1
  { { ".debug_static_vars", ".zdebug_static_vars", NULL, NULL, 0, 0, abbrev },
d6322 1
a6322 1
  { { ".debug_weaknames",   ".zdebug_weaknames", NULL, NULL, 0, 0, abbrev },
d6324 2
a6325 2
  { { ".gdb_index",	    "",	                NULL, NULL, 0, 0, abbrev },
    display_gdb_index,			&do_gdb_index,		0 },
d6327 5
a6331 5
    display_trace_info,			&do_trace_info,		1 },
  { { ".trace_abbrev",	    "",			NULL, NULL, 0, 0, abbrev },
    display_debug_abbrev,		&do_trace_abbrevs,	0 },
  { { ".trace_aranges",	    "",			NULL, NULL, 0, 0, abbrev },
    display_debug_aranges,		&do_trace_aranges,	0 },
d6333 3
a6335 3
    display_debug_info,			&do_debug_info,		1 },
  { { ".debug_abbrev.dwo",  ".zdebug_abbrev.dwo", NULL, NULL, 0, 0, abbrev_dwo },
    display_debug_abbrev,		&do_debug_abbrevs,	0 },
d6337 4
a6340 4
    display_debug_types,		&do_debug_info,		1 },
  { { ".debug_line.dwo",   ".zdebug_line.dwo", NULL, NULL, 0, 0, abbrev_dwo },
    display_debug_lines,   &do_debug_lines,	1 },
  { { ".debug_loc.dwo",	    ".zdebug_loc.dwo",	NULL, NULL, 0, 0, abbrev_dwo },
d6342 1
a6342 1
  { { ".debug_macro.dwo",   ".zdebug_macro.dwo",NULL, NULL, 0, 0, abbrev },
d6344 1
a6344 1
  { { ".debug_macinfo.dwo", ".zdebug_macinfo.dwo",NULL, NULL, 0, 0, abbrev },
d6346 3
a6348 3
  { { ".debug_str.dwo",   ".zdebug_str.dwo", NULL, NULL, 0, 0, str_dwo },
    display_debug_str,     &do_debug_str,	        1 },
  { { ".debug_str_offsets",".zdebug_str_offsets", NULL, NULL, 0, 0, abbrev },
d6350 1
a6350 2
  { { ".debug_str_offsets.dwo",".zdebug_str_offsets.dwo", NULL, NULL, 0, 0,
      abbrev },
d6352 6
a6357 2
  { { ".debug_addr",".zdebug_addr",             NULL, NULL, 0, 0, debug_addr },
    display_debug_addr, NULL,		1 },
@


1.119
log
@2012-09-06  Cary Coutant  <ccoutant@@google.com>

binutils/
	* dwarf.c (decode_location_expression): Add
	DW_OP_GNU_const_index.
@
text
@d5796 1
d5800 1
d5816 3
a5818 1
		  printf (_(" [type]"));
d5821 3
a5823 1
		  printf (_(" [variable]"));
d5826 3
a5828 1
		  printf (_(" [function]"));
d5831 3
a5833 1
		  printf (_(" [other]"));
d5836 4
a5839 1
		  printf (_(" [unknown: %d]"), kind);
@


1.118
log
@Display null bytes in DWARF debug info

binutils/

	PR binutils/14420
	* dwarf.c (process_abbrev_section): Add attribute terminator.
	Warn missing section terminator.
	(get_FORM_name): Special check for 0 value.
	(get_AT_name): Likewise.
	(process_debug_info): Display zero abbrev number.  Check
	attribute terminator.

binutils/testsuite/

	PR binutils/14420
	* binutils-all/i386/compressed-1a.d: Updated.
	* binutils-all/objdump.W: Likewise.
	* binutils-all/readelf.wa: Likewise.
	* binutils-all/x86-64/compressed-1a.d: Likewise.

gas/testsuite/

	PR binutils/14420
	* gas/elf/dwarf2-1.d: Updated.
	* gas/elf/dwarf2-2.d: Likwise.
	* gas/i386/dw2-compress-1.d: Likwise.
@
text
@d1195 5
@


1.117
log
@	* dwarf.c: Include gdb-index.h.
	(display_gdb_index): Handle version 7.
@
text
@d650 1
a650 2
	  if (attribute != 0)
	    add_abbrev_attr (attribute, form);
d655 3
d680 4
a683 1
  const char *name = get_DW_FORM_name (form);
d685 1
d1869 3
d2173 4
d2254 3
a2256 1
	  for (attr = entry->first_attr; attr; attr = attr->next)
@


1.116
log
@	* dwarf.c (read_and_display_attr_value): Handle
	DW_FORM_GNU_ref_alt and DW_FORM_GNU_strp_alt.
	(display_debug_macro): Handle DW_MACRO_GNU_define_indirect_alt,
	DW_MACRO_GNU_undef_indirect_alt and
	DW_MACRO_GNU_transparent_include_alt.
@
text
@d31 1
d5680 1
a5680 1
  switch (version)
a5681 12
    case 3:
      warn (_("The address table data in version 3 may be wrong.\n"));
      break;
    case 4:
      warn (_("Version 4 does not support case insensitive lookups.\n"));
      break;
    case 5:
      warn (_("Version 5 does not include inlined functions.\n"));
      break;
    case 6:
      break;
    default:
d5685 8
d5772 2
d5776 2
d5779 2
d5783 2
a5784 1
		printf (" T%lu", (unsigned long) (cu - cu_list_elements / 2));
d5786 25
a5810 1
		printf (" %lu", (unsigned long) cu);
d5812 2
a5813 1
	  printf ("\n");
@


1.115
log
@binutils/
	* dwarf.c (process_debug_info): Display abbrev offset in hex.
	(display_debug_abbrev): Show offset of abbrev.

binutils/testsuite/
	* binutils-all/objdump.W: Update.
	* binutils-all/readelf.wa: Update.
	* binutils-all/i386/compressed-1a.d: Update.
	* binutils-all/x86-64/compressed-1a.d: Update.

gas/testsuite/
	* gas/elf/dwarf2-1.d: Update.
	* gas/elf/dwarf2-2.d: Update.
	* gas/i386/dw2-compress-1.d: Update.
@
text
@d1287 2
d1354 5
d1468 6
d1812 2
a1813 1
        if (form == DW_FORM_ref_sig8)
d3646 25
@


1.114
log
@	* dwarf.c (display_debug_ranges): Don't report more than one use
	of the same range set as an overlap.
@
text
@d2064 2
a2065 2
	  printf (_("   Abbrev Offset: %s\n"),
		  dwarf_vmatoa ("d", compunit.cu_abbrev_offset));
d3684 2
d3688 1
d3694 1
a3694 1
      printf (_("  Number TAG\n"));
@


1.113
log
@
Add support for PowerPC VLE.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	* NEWS:  Mention PowerPC VLE port.

2012-05-14  James Lemke <jwlemke@@codesourcery.com>
	    Catherine Moore  <clm@@codesourcery.com>

	bfd/
	* bfd.c (bfd_lookup_section_flags): Add section parm.
	* ecoff.c (bfd_debug_section): Remove flag_info initializer.
	* elf-bfd.h (bfd_elf_section_data): Move in section_flag_info.
	(bfd_elf_lookup_section_flags): Add section parm.
	* elf32-ppc.c (is_ppc_vle): New function.
	(ppc_elf_modify_segment_map): New function.
	(elf_backend_modify_segment_map): Define.
	(has_vle_insns): New define.
	* elf32-ppc.h (ppc_elf_modify_segment_map): Declare.
	* elflink.c (bfd_elf_lookup_section_flags): Add return value & parm.
	Move in logic to omit / include a section.
	* libbfd-in.h (bfd_link_info): Add section parm.
	(bfd_generic_lookup_section_flags): Likewise.
	* reloc.c (bfd_generic_lookup_section_flags): Likewise.
	* section.c (bfd_section): Move out section_flag_info.
	(BFD_FAKE_SECTION): Remove flag_info initializer.
	* targets.c (_bfd_lookup_section_flags): Add section parm.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	bfd/
	* archures.c (bfd_mach_ppc_vle): New.
	* bfd-in2.h: Regenerated.
	* cpu-powerpc.c (bfd_powerpc_archs): New entry for vle.
	* elf32-ppc.c (split16_format_type): New enumeration.
	(ppc_elf_vle_split16): New function.
	(HOWTO): Add entries for R_PPC_VLE relocations.
	(ppc_elf_reloc_type_lookup): Handle PPC_VLE relocations.
	(ppc_elf_section_flags): New function.
	(ppc_elf_lookup_section_flags): New function.
	(ppc_elf_section_processing): New function.
	(ppc_elf_check_relocs): Handle PPC_VLE relocations.
	(ppc_elf_relocation_section): Likewise.
	(elf_backend_lookup_section_flags_hook): Define.
	(elf_backend_section_flags): Define.
	(elf_backend_section_processing): Define.
	* elf32-ppc.h (ppc_elf_section_processing): Declare.
	* libbfd.h: Regenerated.
	* reloc.c (BFD_RELOC_PPC_VLE_REL8, BFD_RELOC_PPC_VLE_REL15,
	BFD_RELOC_PPC_VLE_REL24, BFD_RELOC_PPC_VLE_LO16A,
	BFD_RELOC_PPC_VLE_LO16D, BFD_RELOC_PPC_VLE_HI16A,
	BFD_RELOC_PPC_VLE_HI16D, BFD_RELOC_PPC_VLE_HA16A,
	BFD_RELOC_PPC_VLE_HA16D, BFD_RELOC_PPC_VLE_SDA21,
	BFD_RELOC_PPC_VLE_SDA21_LO, BFD_RELOC_PPC_VLE_SDAREL_LO16A,
	BFD_RELOC_PPC_VLE_SDAREL_LO16D, BFD_RELOC_PPC_VLE_SDAREL_HI16A,
	BFD_RELOC_PPC_VLE_SDAREL_HI16D, BFD_RELOC_PPC_VLE_SDAREL_HA16A,
	BFD_RELOC_PPC_VLE_SDAREL_HA16D): New bfd relocations.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	gas/
	* config/tc-ppc.c (insn_validate): New func of existing code to call..
	(ppc_setup_opcodes): ..from 2 places here.
	Revise for second (VLE) opcode table.
	Add #ifdef'd code to print opcode tables.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	gas/
	* config/tc-ppc.c (ppc_setup_opcodes): Allow out-of-order
	for the VLE conditional branches.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>

	gas/
	* config/tc-ppc.c (PPC_VLE_SPLIT16A): New macro.
	(PPC_VLE_SPLIT16D): New macro.
	(PPC_VLE_LO16A): New macro.
	(PPC_VLE_LO16D): New macro.
	(PPC_VLE_HI16A): New macro.
	(PPC_VLE_HI16D): New macro.
	(PPC_VLE_HA16A): New macro.
	(PPC_VLE_HA16D): New macro.
	(PPC_APUINFO_VLE): New definition.
	(md_chars_to_number): New function.
	(md_parse_option): Check for combinations of little
	endian and -mvle.
	(md_show_usage): Document -mvle.
	(ppc_arch): Recognize VLE.
	(ppc_mach): Recognize bfd_mach_ppc_vle.
	(ppc_setup_opcodes): Print the opcode table if
	* config/tc-ppc.h (ppc_frag_check): Declare.
	* doc/c-ppc.texi: Document -mvle.
	* NEWS:  Mention PowerPC VLE port.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	gas/
	* config/tc-ppc.h (ppc_dw2_line_min_insn_length): Declare.
	(DWARF2_LINE_MIN_INSN_LENGTH): Redefine.
	* config/tc-ppc.c (ppc_dw2_line_min_insn_length): New.
	* dwarf2dbg.c (scale_addr_delta): Handle values of 1
	for DWARF2_LINE_MIN_INSN_LENGTH.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>

	gas/testsuite/
	* gas/ppc/ppc.exp: Run new tests.
	* gas/ppc/vle-reloc.d: New test.
	* gas/ppc/vle-reloc.s: New test.
	* gas/ppc/vle-simple-1.d: New test.
	* gas/ppc/vle-simple-1.s: New test.
	* gas/ppc/vle-simple-2.d: New test.
	* gas/ppc/vle-simple-2.s: New test.
	* gas/ppc/vle-simple-3.d: New test.
	* gas/ppc/vle-simple-3.s: New test.
	* gas/ppc/vle-simple-4.d: New test.
	* gas/ppc/vle-simple-4.s: New test.
	* gas/ppc/vle-simple-5.d: New test.
	* gas/ppc/vle-simple-5.s: New test.
	* gas/ppc/vle-simple-6.d: New test.
	* gas/ppc/vle-simple-6.s: New test.
	* gas/ppc/vle.d: New test.
	* gas/ppc/vle.s: New test.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>
	include/elf/
	* ppc.h (SEC_PPC_VLE): Remove.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
	    James Lemke  <jwlemke@@codesourcery.com>

	include/elf/
	* ppc.h (R_PPC_VLE_REL8): New reloction.
	(R_PPC_VLE_REL15): Likewise.
	(R_PPC_VLE_REL24): Likewise.
	(R_PPC_VLE_LO16A): Likewise.
	(R_PPC_VLE_LO16D): Likewise.
	(R_PPC_VLE_HI16A): Likewise.
	(R_PPC_VLE_HI16D): Likewise.
	(R_PPC_VLE_HA16A): Likewise.
	(R_PPC_VLE_HA16D): Likewise.
	(R_PPC_VLE_SDA21): Likewise.
	(R_PPC_VLE_SDA21_LO): Likewise.
	(R_PPC_VLE_SDAREL_LO16A): Likewise.
	(R_PPC_VLE_SDAREL_LO16D): Likewise.
	(R_PPC_VLE_SDAREL_HI16A): Likewise.
	(R_PPC_VLE_SDAREL_HI16D): Likewise.
	(R_PPC_VLE_SDAREL_HA16A): Likewise.
	(R_PPC_VLE_SDAREL_HA16D): Likewise.
	(SEC_PPC_VLE): Remove.
	(PF_PPC_VLE): New program header flag.
	(SHF_PPC_VLE): New section header flag.
	(vle_opcodes, vle_num_opcodes): New.
	(VLE_OP): New macro.
	(VLE_OP_TO_SEG): New macro.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>

	include/opcode/
	* ppc.h (PPC_OPCODE_VLE): New definition.
	(PPC_OP_SA): New macro.
	(PPC_OP_SE_VLE): New macro.
	(PPC_OP): Use a variable shift amount.
	(powerpc_operand): Update comments.
	(PPC_OPSHIFT_INV): New macro.
	(PPC_OPERAND_CR): Replace with...
	(PPC_OPERAND_CR_BIT): ...this and
	(PPC_OPERAND_CR_REG): ...this.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	ld/
	* ldlang.c (walk_wild_consider_section): Don't copy section_flag_list.
	Pass it to callback.
	(walk_wild_section_general): Pass section_flag_list to callback.
	(lang_add_section): Add sflag_list parm.
	Move out logic to keep / omit a section & call bfd_lookup_section_flags.
	(output_section_callback_fast): Add sflag_list parm.
	Add new parm to lang_add_section calls.
	(output_section_callback): Likewise.
	(check_section_callback): Add sflag_list parm.
	(lang_place_orphans): Add new parm to lang_add_section calls.
	(gc_section_callback): Add sflag_list parm.
	(find_relro_section_callback): Likewise.
	* ldlang.h (callback_t): Add flag_info parm.
	(lang_add_section): Add sflag_list parm.
	* emultempl/armelf.em (elf32_arm_add_stub_section):
	Add lang_add_section parm.
	* emultempl/beos.em (gld*_place_orphan): Likewise.
	* emultempl/elf32.em (gld*_place_orphan): Likewise.
	* emultempl/hppaelf.em (hppaelf_add_stub_section): Likewise.
	* emultempl/m68hc1xelf.em (m68hc11elf_add_stub_section): Likewise.
	* emultempl/mipself.em (mips_add_stub_section): Likewise.
	* emultempl/mmo.em (mmo_place_orphan): Likewise.
	* emultempl/pe.em (gld_*_place_orphan): Likewise.
	* emultempl/pep.em (gld_*_place_orphan): Likewise.
	* emultempl/ppc64elf.em (ppc_add_stub_section): Likewise.
	* emultempl/spuelf.em (spu_place_special_section): Likewise.
	* emultempl/vms.em (vms_place_orphan): Likewise.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	ld/testsuite/
	* ld-powerpc/powerpc.exp: Create ppceabitests.
	* ld-powerpc/vle-multiseg.s: New.
	* ld-powerpc/vle-multiseg-1.d: New.
	* ld-powerpc/vle-multiseg-1.ld: New.
	* ld-powerpc/vle-multiseg-2.d: New.
	* ld-powerpc/vle-multiseg-2.ld: New.
	* ld-powerpc/vle-multiseg-3.d: New.
	* ld-powerpc/vle-multiseg-3.ld: New.
	* ld-powerpc/vle-multiseg-4.d: New.
	* ld-powerpc/vle-multiseg-4.ld: New.
	* ld-powerpc/vle-multiseg-5.d: New.
	* ld-powerpc/vle-multiseg-5.ld: New.
	* ld-powerpc/vle-multiseg-6.d: New.
	* ld-powerpc/vle-multiseg-6.ld: New.
	* ld-powerpc/vle-multiseg-6a.s: New.
	* ld-powerpc/vle-multiseg-6b.s: New.
	* ld-powerpc/vle-multiseg-6c.s: New.
	* ld-powerpc/vle-multiseg-6d.s: New.
	* ld-powerpc/powerpc.exp: Run new tests.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	ld/
	* NEWS:  Mention PowerPC VLE port.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>

	ld/testsuite/
	* ld-powerpc/apuinfo.rd: Update for VLE.
	* ld-powerpc/vle-reloc-1.d: New.
	* ld-powerpc/vle-reloc-1.s: New.
	* ld-powerpc/vle-reloc-2.d: New.
	* ld-powerpc/vle-reloc-2.s: New.
	* ld-powerpc/vle-reloc-3.d: New.
	* ld-powerpc/vle-reloc-3.s: New.
	* ld-powerpc/vle-reloc-def-1.s: New.
	* ld-powerpc/vle-reloc-def-2.s: New.
	* ld-powerpc/vle-reloc-def-3.s: New.

2012-05-14  James Lemke  <jwlemke@@codesourcery.com>

	opcodes/
	* ppc-dis.c (get_powerpc_dialect): Use is_ppc_vle.
	(PPC_OPCD_SEGS, VLE_OPCD_SEGS): New defines.
	(vle_opcd_indices): New array.
	(lookup_vle): New function.
	(disassemble_init_powerpc): Revise for second (VLE) opcode table.
	(print_insn_powerpc): Likewise.
	* ppc-opc.c: Likewise.

2012-05-14  Catherine Moore  <clm@@codesourcery.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
	    Rhonda Wittels  <rhonda@@codesourcery.com>
	    Nathan Froyd <froydnj@@codesourcery.com>

	opcodes/
	* ppc-opc.c (insert_arx, extract_arx): New functions.
	(insert_ary, extract_ary): New functions.
	(insert_li20, extract_li20): New functions.
	(insert_rx, extract_rx): New functions.
	(insert_ry, extract_ry): New functions.
	(insert_sci8, extract_sci8): New functions.
	(insert_sci8n, extract_sci8n): New functions.
	(insert_sd4h, extract_sd4h): New functions.
	(insert_sd4w, extract_sd4w): New functions.
	(insert_vlesi, extract_vlesi): New functions.
	(insert_vlensi, extract_vlensi): New functions.
	(insert_vleui, extract_vleui): New functions.
	(insert_vleil, extract_vleil): New functions.
 	(BI_MASK, BB_MASK, BT): Use PPC_OPERAND_CR_BIT.
 	(BI16, BI32, BO32, B8): New.
	(B15, B24, CRD32, CRS): New.
 	(CRD, OBF, BFA, CR, CRFS): Use PPC_OPERAND_CR_REG.
	(DB, IMM20, RD, Rx, ARX, RY, RZ): New.
	(ARY, SCLSCI8, SCLSCI8N, SE_SD, SE_SDH): New.
	(SH6_MASK): Use PPC_OPSHIFT_INV.
	(SI8, UI5, OIMM5, UI7, BO16): New.
	(VLESIMM, VLENSIMM, VLEUIMM, VLEUIMML): New.
	(XT6, XA6, XB6, XB6S, XC6): Use PPC_OPSHIFT_INV.
	(ALLOW8_SPRG): New.
	(insert_sprg, extract_sprg): Check ALLOW8_SPRG.
	(OPVUP, OPVUP_MASK OPVUP): New
	(BD8, BD8_MASK, BD8IO, BD8IO_MASK): New.
	(EBD8IO, EBD8IO1_MASK, EBD8IO2_MASK, EBD8IO3_MASK): New.
	(BD15, BD15_MASK, EBD15, EBD15_MASK, EBD15BI, EBD15BI_MASK): New.
	(BD24,BD24_MASK, C_LK, C_LK_MASK, C, C_MASK): New.
 	(IA16, IA16_MASK, I16A, I16A_MASK, I16L, I16L_MASK): New.
	(IM7, IM7_MASK, LI20, LI20_MASK, SCI8, SCI8_MASK): New.
	(SCI8BF, SCI8BF_MASK, SD4, SD4_MASK): New.
	(SE_IM5, SE_IM5_MASK): New.
	(SE_R, SE_R_MASK, SE_RR, SE_RR_MASK): New.
	(EX, EX_MASK, BO16F, BO16T, BO32F, BO32T): New.
	(BO32DNZ, BO32DZ): New.
	(NO371, PPCSPE, PPCISEL, PPCEFS, MULHW): Include PPC_OPCODE_VLE.
	(PPCVLE): New.
	(powerpc_opcodes): Add new VLE instructions.  Update existing
	instruction to include PPCVLE if supported.
	* ppc-dis.c (ppc_opts): Add vle entry.
	(get_powerpc_dialect): New function.
	(powerpc_init_dialect): VLE support.
	(print_insn_big_powerpc): Call get_powerpc_dialect.
	(print_insn_little_powerpc): Likewise.
	(operand_value_powerpc): Handle negative shift counts.
	(print_insn_powerpc): Handle 2-byte instruction lengths.
@
text
@d4422 1
d4506 7
a4512 3
	    warn (_("There is an overlap [0x%lx - 0x%lx] in %s section.\n"),
		  (unsigned long) (start - section_begin),
		  (unsigned long) (next - section_begin), section->name);
d4515 1
@


1.112
log
@	* doc/binutils.texi: Add --dwarf-check option.
	* dwarf.c (dwarf_check): New global flag.
	(fetch_indexed_string): New function.
	(fetch_indexed_value): New function.
	(get_FORM_name): Add DW_FORM_GNU_str_index and DW_FORM_GNU_addr_index.
	(decode_location_expression): Add DW_OP_GNU_addr_index.
	(read_and_display_attr_value): Add DW_FORM_GNU_str_index,
	DW_FORM_GNU_addr_index, DW_AT_GNU_addr_base, and DW_AT_GNU_ranges_base.
	(get_AT_name): Add new attributes for Fission.
	(process_debug_info): Load new debug sections for Fission.
	(load_debug_info): Check for .debug_info.dwo section.
	(display_loc_list, display_loc_list_dwo): New functions.
	(display_debug_loc): Move logic to above two functions.
	(display_debug_info): Choose abbrev section based on info section.
	(display_debug_types): Likewise.
	(display_trace_info): Likewise.
	(comp_addr_base): New function.
	(display_debug_addr): New function.
	(display_debug_str_offsets): New function.
	(display_debug_ranges): Allow missing range lists.  Suppress
	diagnostics if dwarf_check not set.
	(debug_displays): Add column to select abbrev section.
	* dwarf.h (enum dwarf_section_display_enum): Add new debug sections
	for Fission.
	(struct dwarf_section): Add abbrev_sec field.
	(struct dwarf_section_display): New type.
	(debug_info): Add addr_base, ranges_base fields.
	(dwarf_check): New global variable.
	* objdump.c (usage): Add --dwarf-check option.
	(enum option_values): Add OPTION_DWARF_CHECK.
	(long_options): Add --dwarf-check.
	(main): Likewise.
	* readelf.c (OPTION_DWARF_CHECK): New macro.
	(options): Add --dwarf-check.
	(parse_args): Likewise.
	(process_section_headers): Use const_strneq instead of
	streq.
@
text
@d661 1
a661 1
  const char *name = get_DW_TAG_name (tag);
@


1.111
log
@	* dwarf.c (read_and_display_attr_value): Don't look up tag from
	abbrev for DW_FORM_ref_addr.
@
text
@d69 2
d449 58
d1183 5
d1318 5
d1339 4
d1449 12
d1478 7
d1540 8
d1971 4
d2045 2
d2156 2
a2157 2
		      warn (_("Bogus end-of-siblings marker detected at offset %lx in .debug_info section\n"),
			    die_offset);
d2292 4
d3715 208
a3939 1
  unsigned char *section_end;
d3952 5
a3958 1
  section_end = start + bytes;
d4024 4
a4027 1
  printf (_("    Offset   Begin    End      Expression\n"));
a4031 3
      dwarf_vma begin;
      dwarf_vma end;
      unsigned short length;
a4032 4
      unsigned int pointer_size;
      unsigned int offset_size;
      int dwarf_version;
      unsigned long cu_offset;
a4033 1
      int need_frame_base;
a4035 4
      pointer_size = debug_information [i].pointer_size;
      cu_offset = debug_information [i].cu_offset;
      offset_size = debug_information [i].offset_size;
      dwarf_version = debug_information [i].dwarf_version;
d4081 5
a4085 78
	  while (1)
	    {
	      if (start + 2 * pointer_size > section_end)
		{
		  warn (_("Location list starting at offset 0x%lx is not terminated.\n"),
			offset);
		  break;
		}

	      /* Note: we use sign extension here in order to be sure that
		 we can detect the -1 escape value.  Sign extension into the
		 top 32 bits of a 32-bit address will not affect the values
		 that we display since we always show hex values, and always
		 the bottom 32-bits.  */
	      begin = byte_get_signed (start, pointer_size);
	      start += pointer_size;
	      end = byte_get_signed (start, pointer_size);
	      start += pointer_size;

	      printf ("    %8.8lx ", offset);

	      if (begin == 0 && end == 0)
		{
		  printf (_("<End of list>\n"));
		  break;
		}

	      /* Check base address specifiers.  */
	      if (begin == (dwarf_vma) -1 && end != (dwarf_vma) -1)
		{
		  base_address = end;
		  print_dwarf_vma (begin, pointer_size);
		  print_dwarf_vma (end, pointer_size);
		  printf (_("(base address)\n"));
		  continue;
		}

	      if (start + 2 > section_end)
		{
		  warn (_("Location list starting at offset 0x%lx is not terminated.\n"),
			offset);
		  break;
		}

	      length = byte_get (start, 2);
	      start += 2;

	      if (start + length > section_end)
		{
		  warn (_("Location list starting at offset 0x%lx is not terminated.\n"),
			offset);
		  break;
		}

	      print_dwarf_vma (begin + base_address, pointer_size);
	      print_dwarf_vma (end + base_address, pointer_size);

	      putchar ('(');
	      need_frame_base = decode_location_expression (start,
							    pointer_size,
							    offset_size,
							    dwarf_version,
							    length,
							    cu_offset, section);
	      putchar (')');

	      if (need_frame_base && !has_frame_base)
		printf (_(" [without DW_AT_frame_base]"));

	      if (begin == end)
		fputs (_(" (start == end)"), stdout);
	      else if (begin > end)
		fputs (_(" (start > end)"), stdout);

	      putchar ('\n');

	      start += length;
	    }
d4089 1
a4089 1
  if (start < section_end)
d4091 1
a4091 1
	  (long) (section_end - start), section->name);
d4158 1
a4158 1
  return process_debug_info (section, file, abbrev, 0, 0);
d4164 1
a4164 1
  return process_debug_info (section, file, abbrev, 0, 1);
d4170 1
a4170 1
  return process_debug_info (section, file, trace_abbrev, 0, 0);
d4302 90
d4447 6
a4452 1
    error (_("No range lists in .debug_info section!\n"));
d4475 1
a4475 1
  if (range_entries[0].ranges_offset != section->address)
d4498 1
a4498 1
      if (i > 0)
d5980 35
a6014 35
  { { ".debug_abbrev",		".zdebug_abbrev",	NULL, NULL, 0, 0 },
    display_debug_abbrev,		&do_debug_abbrevs,	0 },
  { { ".debug_aranges",		".zdebug_aranges",	NULL, NULL, 0, 0 },
    display_debug_aranges,		&do_debug_aranges,	1 },
  { { ".debug_frame",		".zdebug_frame",	NULL, NULL, 0, 0 },
    display_debug_frames,		&do_debug_frames,	1 },
  { { ".debug_info",		".zdebug_info",		NULL, NULL, 0, 0 },
    display_debug_info,			&do_debug_info,		1 },
  { { ".debug_line",		".zdebug_line",		NULL, NULL, 0, 0 },
    display_debug_lines,		&do_debug_lines,	1 },
  { { ".debug_pubnames",	".zdebug_pubnames",	NULL, NULL, 0, 0 },
    display_debug_pubnames,		&do_debug_pubnames,	0 },
  { { ".eh_frame",		"",			NULL, NULL, 0, 0 },
    display_debug_frames,		&do_debug_frames,	1 },
  { { ".debug_macinfo",		".zdebug_macinfo",	NULL, NULL, 0, 0 },
    display_debug_macinfo,		&do_debug_macinfo,	0 },
  { { ".debug_macro",		".zdebug_macro",	NULL, NULL, 0, 0 },
    display_debug_macro,		&do_debug_macinfo,	1 },
  { { ".debug_str",		".zdebug_str",		NULL, NULL, 0, 0 },
    display_debug_str,			&do_debug_str,		0 },
  { { ".debug_loc",		".zdebug_loc",		NULL, NULL, 0, 0 },
    display_debug_loc,			&do_debug_loc,		1 },
  { { ".debug_pubtypes",	".zdebug_pubtypes",	NULL, NULL, 0, 0 },
    display_debug_pubnames,		&do_debug_pubtypes,	0 },
  { { ".debug_ranges",		".zdebug_ranges",	NULL, NULL, 0, 0 },
    display_debug_ranges,		&do_debug_ranges,	1 },
  { { ".debug_static_func",	".zdebug_static_func",	NULL, NULL, 0, 0 },
    display_debug_not_supported,	NULL,			0 },
  { { ".debug_static_vars",	".zdebug_static_vars",	NULL, NULL, 0, 0 },
    display_debug_not_supported,	NULL,			0 },
  { { ".debug_types",		".zdebug_types",	NULL, NULL, 0, 0 },
    display_debug_types,		&do_debug_info,		1 },
  { { ".debug_weaknames",	".zdebug_weaknames",	NULL, NULL, 0, 0 },
    display_debug_not_supported,	NULL,			0 },
  { { ".gdb_index",		"",			NULL, NULL, 0, 0 },
d6016 1
a6016 1
  { { ".trace_info",		"",			NULL, NULL, 0, 0 },
d6018 1
a6018 1
  { { ".trace_abbrev",		"",			NULL, NULL, 0, 0 },
d6020 25
a6044 2
  { { ".trace_aranges",		"",			NULL, NULL, 0, 0 },
    display_debug_aranges,		&do_trace_aranges,	0 }
@


1.110
log
@	* dwarf.c (get_TAG_name): Use get_DW_TAG_name.
	(get_FORM_name): Use get_DW_FORM_name.
	(get_AT_name): Use get_DW_AT_name.
@
text
@d1719 11
a1729 5
	    for (entry = first_abbrev; entry != NULL; entry = entry->next)
	      if (entry->entry == abbrev_number)
		break;
	    if (entry != NULL)
	      printf (" (%s)", get_TAG_name (entry->tag));
@


1.109
log
@	* dwarf.c (display_gdb_index): Handle index version 6.
@
text
@d598 1
a598 1
static char *
d601 3
a603 1
  switch (tag)
d605 1
a605 77
    case DW_TAG_padding:		return "DW_TAG_padding";
    case DW_TAG_array_type:		return "DW_TAG_array_type";
    case DW_TAG_class_type:		return "DW_TAG_class_type";
    case DW_TAG_entry_point:		return "DW_TAG_entry_point";
    case DW_TAG_enumeration_type:	return "DW_TAG_enumeration_type";
    case DW_TAG_formal_parameter:	return "DW_TAG_formal_parameter";
    case DW_TAG_imported_declaration:	return "DW_TAG_imported_declaration";
    case DW_TAG_label:			return "DW_TAG_label";
    case DW_TAG_lexical_block:		return "DW_TAG_lexical_block";
    case DW_TAG_member:			return "DW_TAG_member";
    case DW_TAG_pointer_type:		return "DW_TAG_pointer_type";
    case DW_TAG_reference_type:		return "DW_TAG_reference_type";
    case DW_TAG_compile_unit:		return "DW_TAG_compile_unit";
    case DW_TAG_string_type:		return "DW_TAG_string_type";
    case DW_TAG_structure_type:		return "DW_TAG_structure_type";
    case DW_TAG_subroutine_type:	return "DW_TAG_subroutine_type";
    case DW_TAG_typedef:		return "DW_TAG_typedef";
    case DW_TAG_union_type:		return "DW_TAG_union_type";
    case DW_TAG_unspecified_parameters: return "DW_TAG_unspecified_parameters";
    case DW_TAG_variant:		return "DW_TAG_variant";
    case DW_TAG_common_block:		return "DW_TAG_common_block";
    case DW_TAG_common_inclusion:	return "DW_TAG_common_inclusion";
    case DW_TAG_inheritance:		return "DW_TAG_inheritance";
    case DW_TAG_inlined_subroutine:	return "DW_TAG_inlined_subroutine";
    case DW_TAG_module:			return "DW_TAG_module";
    case DW_TAG_ptr_to_member_type:	return "DW_TAG_ptr_to_member_type";
    case DW_TAG_set_type:		return "DW_TAG_set_type";
    case DW_TAG_subrange_type:		return "DW_TAG_subrange_type";
    case DW_TAG_with_stmt:		return "DW_TAG_with_stmt";
    case DW_TAG_access_declaration:	return "DW_TAG_access_declaration";
    case DW_TAG_base_type:		return "DW_TAG_base_type";
    case DW_TAG_catch_block:		return "DW_TAG_catch_block";
    case DW_TAG_const_type:		return "DW_TAG_const_type";
    case DW_TAG_constant:		return "DW_TAG_constant";
    case DW_TAG_enumerator:		return "DW_TAG_enumerator";
    case DW_TAG_file_type:		return "DW_TAG_file_type";
    case DW_TAG_friend:			return "DW_TAG_friend";
    case DW_TAG_namelist:		return "DW_TAG_namelist";
    case DW_TAG_namelist_item:		return "DW_TAG_namelist_item";
    case DW_TAG_packed_type:		return "DW_TAG_packed_type";
    case DW_TAG_subprogram:		return "DW_TAG_subprogram";
    case DW_TAG_template_type_param:	return "DW_TAG_template_type_param";
    case DW_TAG_template_value_param:	return "DW_TAG_template_value_param";
    case DW_TAG_thrown_type:		return "DW_TAG_thrown_type";
    case DW_TAG_try_block:		return "DW_TAG_try_block";
    case DW_TAG_variant_part:		return "DW_TAG_variant_part";
    case DW_TAG_variable:		return "DW_TAG_variable";
    case DW_TAG_volatile_type:		return "DW_TAG_volatile_type";
    case DW_TAG_MIPS_loop:		return "DW_TAG_MIPS_loop";
    case DW_TAG_format_label:		return "DW_TAG_format_label";
    case DW_TAG_function_template:	return "DW_TAG_function_template";
    case DW_TAG_class_template:		return "DW_TAG_class_template";
      /* DWARF 2.1 values.  */
    case DW_TAG_dwarf_procedure:	return "DW_TAG_dwarf_procedure";
    case DW_TAG_restrict_type:		return "DW_TAG_restrict_type";
    case DW_TAG_interface_type:		return "DW_TAG_interface_type";
    case DW_TAG_namespace:		return "DW_TAG_namespace";
    case DW_TAG_imported_module:	return "DW_TAG_imported_module";
    case DW_TAG_unspecified_type:	return "DW_TAG_unspecified_type";
    case DW_TAG_partial_unit:		return "DW_TAG_partial_unit";
    case DW_TAG_imported_unit:		return "DW_TAG_imported_unit";
    case DW_TAG_condition:		return "DW_TAG_condition";
    case DW_TAG_shared_type:		return "DW_TAG_shared_type";
      /* DWARF 4 values.  */
    case DW_TAG_type_unit:		return "DW_TAG_type_unit";
    case DW_TAG_rvalue_reference_type:	return "DW_TAG_rvalue_reference_type";
    case DW_TAG_template_alias:		return "DW_TAG_template_alias";
      /* UPC values.  */
    case DW_TAG_upc_shared_type:	return "DW_TAG_upc_shared_type";
    case DW_TAG_upc_strict_type:	return "DW_TAG_upc_strict_type";
    case DW_TAG_upc_relaxed_type:	return "DW_TAG_upc_relaxed_type";
      /* GNU values.  */
    case DW_TAG_GNU_call_site:		return "DW_TAG_GNU_call_site";
    case DW_TAG_GNU_call_site_parameter:return "DW_TAG_GNU_call_site_parameter";
    default:
      {
	static char buffer[100];
d607 2
a608 3
	snprintf (buffer, sizeof (buffer), _("Unknown TAG value: %lx"), tag);
	return buffer;
      }
d610 2
d614 1
a614 1
static char *
d617 3
a619 1
  switch (form)
d621 1
a621 29
    case DW_FORM_addr:		return "DW_FORM_addr";
    case DW_FORM_block2:	return "DW_FORM_block2";
    case DW_FORM_block4:	return "DW_FORM_block4";
    case DW_FORM_data2:		return "DW_FORM_data2";
    case DW_FORM_data4:		return "DW_FORM_data4";
    case DW_FORM_data8:		return "DW_FORM_data8";
    case DW_FORM_string:	return "DW_FORM_string";
    case DW_FORM_block:		return "DW_FORM_block";
    case DW_FORM_block1:	return "DW_FORM_block1";
    case DW_FORM_data1:		return "DW_FORM_data1";
    case DW_FORM_flag:		return "DW_FORM_flag";
    case DW_FORM_sdata:		return "DW_FORM_sdata";
    case DW_FORM_strp:		return "DW_FORM_strp";
    case DW_FORM_udata:		return "DW_FORM_udata";
    case DW_FORM_ref_addr:	return "DW_FORM_ref_addr";
    case DW_FORM_ref1:		return "DW_FORM_ref1";
    case DW_FORM_ref2:		return "DW_FORM_ref2";
    case DW_FORM_ref4:		return "DW_FORM_ref4";
    case DW_FORM_ref8:		return "DW_FORM_ref8";
    case DW_FORM_ref_udata:	return "DW_FORM_ref_udata";
    case DW_FORM_indirect:	return "DW_FORM_indirect";
      /* DWARF 4 values.  */
    case DW_FORM_sec_offset:	return "DW_FORM_sec_offset";
    case DW_FORM_exprloc:	return "DW_FORM_exprloc";
    case DW_FORM_flag_present:	return "DW_FORM_flag_present";
    case DW_FORM_ref_sig8:	return "DW_FORM_ref_sig8";
    default:
      {
	static char buffer[100];
d623 2
a624 3
	snprintf (buffer, sizeof (buffer), _("Unknown FORM value: %lx"), form);
	return buffer;
      }
d626 2
d1736 1
a1736 1
static char *
d1739 9
a1747 1
  switch (attribute)
d1749 1
a1749 163
    case DW_AT_sibling:			return "DW_AT_sibling";
    case DW_AT_location:		return "DW_AT_location";
    case DW_AT_name:			return "DW_AT_name";
    case DW_AT_ordering:		return "DW_AT_ordering";
    case DW_AT_subscr_data:		return "DW_AT_subscr_data";
    case DW_AT_byte_size:		return "DW_AT_byte_size";
    case DW_AT_bit_offset:		return "DW_AT_bit_offset";
    case DW_AT_bit_size:		return "DW_AT_bit_size";
    case DW_AT_element_list:		return "DW_AT_element_list";
    case DW_AT_stmt_list:		return "DW_AT_stmt_list";
    case DW_AT_low_pc:			return "DW_AT_low_pc";
    case DW_AT_high_pc:			return "DW_AT_high_pc";
    case DW_AT_language:		return "DW_AT_language";
    case DW_AT_member:			return "DW_AT_member";
    case DW_AT_discr:			return "DW_AT_discr";
    case DW_AT_discr_value:		return "DW_AT_discr_value";
    case DW_AT_visibility:		return "DW_AT_visibility";
    case DW_AT_import:			return "DW_AT_import";
    case DW_AT_string_length:		return "DW_AT_string_length";
    case DW_AT_common_reference:	return "DW_AT_common_reference";
    case DW_AT_comp_dir:		return "DW_AT_comp_dir";
    case DW_AT_const_value:		return "DW_AT_const_value";
    case DW_AT_containing_type:		return "DW_AT_containing_type";
    case DW_AT_default_value:		return "DW_AT_default_value";
    case DW_AT_inline:			return "DW_AT_inline";
    case DW_AT_is_optional:		return "DW_AT_is_optional";
    case DW_AT_lower_bound:		return "DW_AT_lower_bound";
    case DW_AT_producer:		return "DW_AT_producer";
    case DW_AT_prototyped:		return "DW_AT_prototyped";
    case DW_AT_return_addr:		return "DW_AT_return_addr";
    case DW_AT_start_scope:		return "DW_AT_start_scope";
    case DW_AT_stride_size:		return "DW_AT_stride_size";
    case DW_AT_upper_bound:		return "DW_AT_upper_bound";
    case DW_AT_abstract_origin:		return "DW_AT_abstract_origin";
    case DW_AT_accessibility:		return "DW_AT_accessibility";
    case DW_AT_address_class:		return "DW_AT_address_class";
    case DW_AT_artificial:		return "DW_AT_artificial";
    case DW_AT_base_types:		return "DW_AT_base_types";
    case DW_AT_calling_convention:	return "DW_AT_calling_convention";
    case DW_AT_count:			return "DW_AT_count";
    case DW_AT_data_member_location:	return "DW_AT_data_member_location";
    case DW_AT_decl_column:		return "DW_AT_decl_column";
    case DW_AT_decl_file:		return "DW_AT_decl_file";
    case DW_AT_decl_line:		return "DW_AT_decl_line";
    case DW_AT_declaration:		return "DW_AT_declaration";
    case DW_AT_discr_list:		return "DW_AT_discr_list";
    case DW_AT_encoding:		return "DW_AT_encoding";
    case DW_AT_external:		return "DW_AT_external";
    case DW_AT_frame_base:		return "DW_AT_frame_base";
    case DW_AT_friend:			return "DW_AT_friend";
    case DW_AT_identifier_case:		return "DW_AT_identifier_case";
    case DW_AT_macro_info:		return "DW_AT_macro_info";
    case DW_AT_namelist_items:		return "DW_AT_namelist_items";
    case DW_AT_priority:		return "DW_AT_priority";
    case DW_AT_segment:			return "DW_AT_segment";
    case DW_AT_specification:		return "DW_AT_specification";
    case DW_AT_static_link:		return "DW_AT_static_link";
    case DW_AT_type:			return "DW_AT_type";
    case DW_AT_use_location:		return "DW_AT_use_location";
    case DW_AT_variable_parameter:	return "DW_AT_variable_parameter";
    case DW_AT_virtuality:		return "DW_AT_virtuality";
    case DW_AT_vtable_elem_location:	return "DW_AT_vtable_elem_location";
      /* DWARF 2.1 values.  */
    case DW_AT_allocated:		return "DW_AT_allocated";
    case DW_AT_associated:		return "DW_AT_associated";
    case DW_AT_data_location:		return "DW_AT_data_location";
    case DW_AT_stride:			return "DW_AT_stride";
    case DW_AT_entry_pc:		return "DW_AT_entry_pc";
    case DW_AT_use_UTF8:		return "DW_AT_use_UTF8";
    case DW_AT_extension:		return "DW_AT_extension";
    case DW_AT_ranges:			return "DW_AT_ranges";
    case DW_AT_trampoline:		return "DW_AT_trampoline";
    case DW_AT_call_column:		return "DW_AT_call_column";
    case DW_AT_call_file:		return "DW_AT_call_file";
    case DW_AT_call_line:		return "DW_AT_call_line";
    case DW_AT_description:		return "DW_AT_description";
    case DW_AT_binary_scale:		return "DW_AT_binary_scale";
    case DW_AT_decimal_scale:		return "DW_AT_decimal_scale";
    case DW_AT_small:			return "DW_AT_small";
    case DW_AT_decimal_sign:		return "DW_AT_decimal_sign";
    case DW_AT_digit_count:		return "DW_AT_digit_count";
    case DW_AT_picture_string:		return "DW_AT_picture_string";
    case DW_AT_mutable:			return "DW_AT_mutable";
    case DW_AT_threads_scaled:		return "DW_AT_threads_scaled";
    case DW_AT_explicit:		return "DW_AT_explicit";
    case DW_AT_object_pointer:		return "DW_AT_object_pointer";
    case DW_AT_endianity:		return "DW_AT_endianity";
    case DW_AT_elemental:		return "DW_AT_elemental";
    case DW_AT_pure:			return "DW_AT_pure";
    case DW_AT_recursive:		return "DW_AT_recursive";
      /* DWARF 4 values.  */
    case DW_AT_signature:		return "DW_AT_signature";
    case DW_AT_main_subprogram:		return "DW_AT_main_subprogram";
    case DW_AT_data_bit_offset:		return "DW_AT_data_bit_offset";
    case DW_AT_const_expr:		return "DW_AT_const_expr";
    case DW_AT_enum_class:		return "DW_AT_enum_class";
    case DW_AT_linkage_name:		return "DW_AT_linkage_name";

      /* HP and SGI/MIPS extensions.  */
    case DW_AT_MIPS_loop_begin:			return "DW_AT_MIPS_loop_begin";
    case DW_AT_MIPS_tail_loop_begin:		return "DW_AT_MIPS_tail_loop_begin";
    case DW_AT_MIPS_epilog_begin:		return "DW_AT_MIPS_epilog_begin";
    case DW_AT_MIPS_loop_unroll_factor: 	return "DW_AT_MIPS_loop_unroll_factor";
    case DW_AT_MIPS_software_pipeline_depth: 	return "DW_AT_MIPS_software_pipeline_depth";
    case DW_AT_MIPS_linkage_name:		return "DW_AT_MIPS_linkage_name";
    case DW_AT_MIPS_stride:			return "DW_AT_MIPS_stride";
    case DW_AT_MIPS_abstract_name:		return "DW_AT_MIPS_abstract_name";
    case DW_AT_MIPS_clone_origin:		return "DW_AT_MIPS_clone_origin";
    case DW_AT_MIPS_has_inlines:		return "DW_AT_MIPS_has_inlines";

      /* HP Extensions.  */
    case DW_AT_HP_block_index:			return "DW_AT_HP_block_index";
    case DW_AT_HP_actuals_stmt_list:		return "DW_AT_HP_actuals_stmt_list";
    case DW_AT_HP_proc_per_section:		return "DW_AT_HP_proc_per_section";
    case DW_AT_HP_raw_data_ptr:			return "DW_AT_HP_raw_data_ptr";
    case DW_AT_HP_pass_by_reference:		return "DW_AT_HP_pass_by_reference";
    case DW_AT_HP_opt_level:			return "DW_AT_HP_opt_level";
    case DW_AT_HP_prof_version_id:		return "DW_AT_HP_prof_version_id";
    case DW_AT_HP_opt_flags:			return "DW_AT_HP_opt_flags";
    case DW_AT_HP_cold_region_low_pc:		return "DW_AT_HP_cold_region_low_pc";
    case DW_AT_HP_cold_region_high_pc:		return "DW_AT_HP_cold_region_high_pc";
    case DW_AT_HP_all_variables_modifiable:	return "DW_AT_HP_all_variables_modifiable";
    case DW_AT_HP_linkage_name:			return "DW_AT_HP_linkage_name";
    case DW_AT_HP_prof_flags:			return "DW_AT_HP_prof_flags";

      /* One value is shared by the MIPS and HP extensions:  */
    case DW_AT_MIPS_fde:			return "DW_AT_MIPS_fde or DW_AT_HP_unmodifiable";

      /* GNU extensions.  */
    case DW_AT_sf_names:			return "DW_AT_sf_names";
    case DW_AT_src_info:			return "DW_AT_src_info";
    case DW_AT_mac_info:			return "DW_AT_mac_info";
    case DW_AT_src_coords:			return "DW_AT_src_coords";
    case DW_AT_body_begin:			return "DW_AT_body_begin";
    case DW_AT_body_end:			return "DW_AT_body_end";
    case DW_AT_GNU_vector:			return "DW_AT_GNU_vector";
    case DW_AT_GNU_guarded_by:			return "DW_AT_GNU_guarded_by";
    case DW_AT_GNU_pt_guarded_by:		return "DW_AT_GNU_pt_guarded_by";
    case DW_AT_GNU_guarded:			return "DW_AT_GNU_guarded";
    case DW_AT_GNU_pt_guarded:			return "DW_AT_GNU_pt_guarded";
    case DW_AT_GNU_locks_excluded:		return "DW_AT_GNU_locks_excluded";
    case DW_AT_GNU_exclusive_locks_required:	return "DW_AT_GNU_exclusive_locks_required";
    case DW_AT_GNU_shared_locks_required:	return "DW_AT_GNU_shared_locks_required";
    case DW_AT_GNU_odr_signature:		return "DW_AT_GNU_odr_signature";
    case DW_AT_use_GNAT_descriptive_type:	return "DW_AT_use_GNAT_descriptive_type";
    case DW_AT_GNAT_descriptive_type:		return "DW_AT_GNAT_descriptive_type";
    case DW_AT_GNU_call_site_value:		return "DW_AT_GNU_call_site_value";
    case DW_AT_GNU_call_site_data_value:	return "DW_AT_GNU_call_site_data_value";
    case DW_AT_GNU_call_site_target:		return "DW_AT_GNU_call_site_target";
    case DW_AT_GNU_call_site_target_clobbered:	return "DW_AT_GNU_call_site_target_clobbered";
    case DW_AT_GNU_tail_call:			return "DW_AT_GNU_tail_call";
    case DW_AT_GNU_all_tail_call_sites:		return "DW_AT_GNU_all_tail_call_sites";
    case DW_AT_GNU_all_call_sites:		return "DW_AT_GNU_all_call_sites";
    case DW_AT_GNU_all_source_call_sites:	return "DW_AT_GNU_all_source_call_sites";
    case DW_AT_GNU_macros:			return "DW_AT_GNU_macros";

      /* UPC extension.  */
    case DW_AT_upc_threads_scaled:	return "DW_AT_upc_threads_scaled";

    /* PGI (STMicroelectronics) extensions.  */
    case DW_AT_PGI_lbase:		return "DW_AT_PGI_lbase";
    case DW_AT_PGI_soffset:		return "DW_AT_PGI_soffset";
    case DW_AT_PGI_lstride:		return "DW_AT_PGI_lstride";
d1751 4
a1754 3
    default:
      {
	static char buffer[100];
d1756 1
a1756 5
	snprintf (buffer, sizeof (buffer), _("Unknown AT value: %lx"),
		  attribute);
	return buffer;
      }
    }
@


1.108
log
@	* dwarf.c (dwarf_vmatoa64): New function.
	(read_and_display_attr_value): Print 8-byte forms as single hex
	numbers.
	(process_debug_info): Print type signatures as single hex numbers.
	* elfcomm.c (byte_get_64): New function.
	* elfcomm.h (byte_get_64): New function.
@
text
@d2 1
a2 1
   Copyright 2005, 2006, 2007, 2008, 2009, 2010, 2011
d5554 3
@


1.107
log
@2012-01-19  Tristan Gingold  <gingold@@adacore.com>

	* dwarf.c (process_extended_line_op): Add a cast to silent a
	warning.
@
text
@d172 21
d1405 6
a1410 3
	  uvalue = byte_get (data, 4);
	  printf (" 0x%s", dwarf_vmatoa ("x", uvalue));
	  printf (" 0x%lx", (unsigned long) byte_get (data + 4, 4));
d1480 6
a1485 7
	  int i;
	  printf (" signature: ");
	  for (i = 0; i < 8; i++)
	    {
	      printf ("%02x", (unsigned) byte_get (data, 1));
	      data += 1;
	    }
d1487 1
a1487 2
      else
        data += 8;
d2138 2
a2139 1
      unsigned char signature[8] = { 0 };
d2173 2
a2174 8
          int i;

          for (i = 0; i < 8; i++)
            {
              signature[i] = byte_get (hdrptr, 1);
              hdrptr += 1;
            }

d2211 7
a2217 7
	      int i;
	      printf (_("   Signature:     "));
	      for (i = 0; i < 8; i++)
	        printf ("%02x", signature[i]);
	      printf ("\n");
             printf (_("   Type Offset:   0x%s\n"),
                     dwarf_vmatoa ("x", type_offset));
@


1.106
log
@2012-01-19  Tristan Gingold  <gingold@@adacore.com>

	* dwarf.c (process_extended_line_op): Reindent define_file output.
	Detect define_file opcode length mismatch.
	(display_debug_lines_decoded): Add an entry in file_table for each
	define_file opcode.
	Ignore DW_LNE_set_discriminator and DW_LNE_HP_set_sequence.
	Display extended opcode for unhandle opcode.
@
text
@d294 1
a294 1
      if (data - orig_data != len)
@


1.105
log
@	* dwarf.c (read_and_display_attr_value): Handle DW_LANG_Go.
@
text
@d250 1
d281 1
a281 1
      printf (_("  define new File Table entry\n"));
d292 5
a296 1
      printf ("%s\n\n", name);
d2808 1
d2810 1
a2894 1
          unsigned int n_directories = 0;
a2920 1
          unsigned int n_files = 0;
d3052 2
a3053 1
                      unsigned int dir_index = 0;
d3056 2
d3059 3
a3061 1
                      dir_index = read_leb128 (op_code_data, & bytes_read, 0);
d3063 3
a3065 1
                      read_leb128 (op_code_data, & bytes_read, 0);
d3067 3
a3069 1
                      read_leb128 (op_code_data, & bytes_read, 0);
d3071 1
a3071 1
                      printf ("%s:\n", directory_table[dir_index]);
d3074 5
d3080 2
a3081 1
                    printf (_("UNKNOWN: length %d\n"), ext_op_code_len - bytes_read);
@


1.104
log
@	* dwarf.c (display_debug_frames): If do_debug_frames_interp,
	DW_CFA_restore goes to DW_CFA_undefined, not DW_CFA_unreferenced.
@
text
@d1602 2
@


1.103
log
@binutils/
	* dwarf.c (read_and_display_attr_value) <DW_AT_import>: Add CU_OFFSET
	also for DW_FORM_ref_udata.
@
text
@d5113 3
@


1.102
log
@2011-10-13  Nick Clifton  <nickc@@redhat.com>

	Fixes to aid translation:
	* addr2line.c (translate_address): Add comments describing context
	of a couple of printf statements.
	* ar.c (write_archive): Allow translation of error message.
	* bucomm.c (endian_string): Allow translation of strings.
	(display_target_list): Allow translation.
	* coffdump.c (dump_coff_type): Allow translation of output.
	(dump_coff_where): Likewise.
	(dump_coff_symbol): Likewise.
	(dump_coff_scope): Likewise.
	(dump_coff_sfile): Likewise.
	(dump_coff_section): Likewise.
	(coff_dump): Likewise.
	* dlltool (def_version): Allow translation of output.
	(run): Likewise.
	* dllwrap.c (run): Allow translation of output.
	* dwarf.c (print_dwarf_vma): Allow translation of output.
	(process_extended_line_op): Remove spurious translation.
	Add translation for strings that can be translated.
	(decode_location_exression): Allow translation of output.
	(read_and_display_attr_value): Allow translation of output.
	* readelf.c (slurp_rela_relocs): Add translation for error
	messages when failing to get data.
	(slurp_rel_relocs): Likewise.
	(get_32bit_elf_symbols): Likewise.
	(get_64bit_elf_symbols): Likewise.
	(dump_ia64_vms_dynamic_relocs): Replace abbreviation with full
	word.
	(process_relocs): Remove spurious translation.
	(decode_tic6x_unwind_bytecode): Likewise.
	(process_version_section): Improve error messages.
	(process_mips_specific): Likewise.
	(print_gnu_note): Remove spurious translation.
	(print_stapsdt_note): Likewise.
	(get_ia64_vms_note_type): Likewise.
	* sysdump.c (getCHARS): Allow translation.
	(fillup): Allow translation of output.
	(getone): Likewise.
	(must): Likewise.
	(derived_type): Likewise.
	* doc/binutils.doc (addr2line): Extend description of command line
	options.
	* po/binutils.pot: Regenerate.
@
text
@d1772 2
a1773 1
	    || form == DW_FORM_ref4)
@


1.101
log
@binutils/

2011-10-04  Paul Woegerer  <paul_woegerer@@mentor.com>
	    Carlos O'Donell  <carlos@@codesourcery.com>

	* dwarf.c (display_debug_lines_decoded): Index directory_table with
	directory_index from file_table entry.

binutils/testsuite/

2011-10-04  Carlos O'Donell  <carlos@@codesourcery.com>

	* binutils-all/dw2-decodedline.S: New file.
	* binutils-all/objdump.WL: New file.
	* binutils-all/objdump.exp: Update copyright year.
	New test case for -WL.
@
text
@d132 1
a132 1
	error ("Wrong size in print_dwarf_vma");
d356 1
a356 1
                printf (_("(%s"),
d360 1
a360 1
                printf (_(",%s"),
d364 1
a364 1
                printf (_(",%s)\n"),
d370 1
a370 1
                printf ("    UNKNOW DW_LNE_HP_SFC opcode (%u)\n", opc);
d1075 1
a1075 1
	  printf ("size: %s ",
d1078 1
a1078 1
	  printf ("offset: %s ",
d1098 1
a1098 1
	  printf ("DW_OP_GNU_push_tls_address or DW_OP_HP_unknown");
d1608 1
a1608 1
	    printf ("(implementation defined: %s)",
d1611 1
a1611 1
	    printf ("(Unknown: %s)", dwarf_vmatoa ("x", uvalue));
d1649 1
a1649 1
	    printf ("(user defined type)");
d1651 1
a1651 1
	    printf ("(unknown type)");
d1663 1
a1663 1
	  printf ("(unknown accessibility)");
d1674 1
a1674 1
	default:			printf ("(unknown visibility)"); break;
d1684 1
a1684 1
	default:			printf ("(unknown virtuality)"); break;
d1695 1
a1695 1
	default:			printf ("(unknown case)"); break;
d1708 1
a1708 1
	    printf ("(user defined)");
d1710 1
a1710 1
	    printf ("(unknown convention)");
d1717 1
a1717 1
	case -1: printf ("(undefined)"); break;
d1786 1
a1786 1
	    printf ("[Abbrev Number: %ld", abbrev_number);
@


1.100
log
@Check zero address size.

2011-09-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/13196
	* dwarf.c (display_debug_aranges): Check zero address size.
@
text
@d2964 4
a2967 3
              if (do_wide || strlen ((char *) directory_table[0]) < 76)
		printf (_("CU: %s/%s:\n"), directory_table[0],
			file_table[0].name);
@


1.99
log
@binutils/
	* dwarf.c (read_and_display_attr_value): Recognize DW_FORM_data4 and
	DW_FORM_data8 as location list pointers only for DWARF < 4.
@
text
@d4218 7
@


1.98
log
@	* dwarf2.c (dwarf_debug_sections): Add .debug_macro
	and .zdebug_macro entry.
	(dwarf_debug_section_enum): Add debug_macro.

	* NEWS: Mention .debug_macro support.
	* dwarf.c (read_and_display_attr_value): Don't print a tab
	if attribute is 0.
	(get_AT_name): Handle DW_AT_GNU_macros.
	(get_line_filename_and_dirname, display_debug_macro): New
	functions.
	(debug_displays): Add an entry for .debug_macro and .zdebug_macro.
	* readelf.c (process_section_headers): With do_debug_macinfo
	handle also .debug_macro sections.
	* dwarf.h (dwarf_section_display_enum): Add macro.
@
text
@d1488 2
a1489 2
    	  if (form == DW_FORM_data4
	      || form == DW_FORM_data8
d1519 2
a1520 2
	  if (form == DW_FORM_data4
	      || form == DW_FORM_data8
d1737 2
a1738 2
      if (form == DW_FORM_data4
	  || form == DW_FORM_data8
@


1.97
log
@Add initial Intel K1OM support.

bfd/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.am (ALL_MACHINES): Add cpu-k1om.lo.
	(ALL_MACHINES_CFILES): Add cpu-k1om.c.
	* Makefile.in: Regenerated.

	* archures.c (bfd_architecture): Add bfd_arch_k1om.
	(bfd_k1om_arch): New.
	(bfd_archures_list): Add &bfd_k1om_arch.
	* bfd-in2.h: Regenerated.

	* config.bfd (targ64_selvecs): Add bfd_elf64_k1om_vec if
	bfd_elf64_x86_64_vec is supported.  Add bfd_elf64_k1om_freebsd_vec
	if bfd_elf64_x86_64_freebsd_vec is supported.
	(targ_selvecs): Likewise.

	* configure.in: Support bfd_elf64_k1om_vec and
	bfd_elf64_k1om_freebsd_vec.
	* configure: Regenerated.

	* cpu-k1om.c: New.

	* elf64-x86-64.c (elf64_k1om_elf_object_p): New.
	(bfd_elf64_k1om_vec): Likewise.
	(bfd_elf64_k1om_freebsd_vec): Likewise.

	* targets.c (bfd_elf64_k1om_vec): New.
	(bfd_elf64_k1om_freebsd_vec): Likewise.
	(_bfd_target_vector): Add bfd_elf64_k1om_vec and
	bfd_elf64_k1om_freebsd_vec.

binutils/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* dwarf.c (init_dwarf_regnames): Handle EM_K1OM.

	* elfedit.c (elf_machine): Support EM_K1OM.
	(elf_class): Likewise.

	* readelf.c (guess_is_rela): Handle EM_K1OM.
	(dump_relocations): Likewise.
	(get_machine_name): Likewise.
	(get_section_type_name): Likewise.
	(get_elf_section_flags): Likewise.
	(process_section_headers): Likewise.
	(get_symbol_index_type): Likewise.
	(is_32bit_abs_reloc): Likewise.
	(is_32bit_pcrel_reloc): Likewise.
	(is_64bit_abs_reloc): Likewise.
	(is_64bit_pcrel_reloc): Likewise.
	(is_none_reloc): Likewise.

	* doc/binutils.texi: Mention K1OM for elfedit.

binutils/testsuite/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* binutils-all/elfedit.exp: Run elfedit-4.

	* binutils-all/elfedit-4.d: New.

gas/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (cpu_arch): Add k1om.
	(i386_align_code): Handle PROCESSOR_K1OM.
	(check_cpu_arch_compatible): Check EM_K1OM.
	(i386_arch): Handle Intel K1OM.
	(i386_mach): Return bfd_mach_k1om for Intel K1OM.
	(i386_target_format): Return ELF_TARGET_K1OM_FORMAT for Intel
	K1OM.

	* config/tc-i386.h (ELF_TARGET_K1OM_FORMAT): New.
	(processor_type): Add PROCESSOR_K1OM.

	* doc/c-i386.texi: Document k1om.

gas/testsuite/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/k1om.d: New.
	* gas/i386/k1om-inval.l: Likewise.
	* gas/i386/k1om-inval.s: Likewise.

	* gas/i386/i386.exp: Run k1om-inval and k1om.

include/elf/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* common.h (EM_K1OM): New.

ld/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.am (ALL_64_EMULATIONS): Add eelf_k1om.o and
	eelf_k1om_fbsd.o
	(eelf_k1om.c): New.
	(eelf_k1om_fbsd.c): Likewise.
	* Makefile.in: Regenerated.

	* configure.tgt (targ64_extra_emuls): Add elf_k1om if elf_x86_64
	is supported.  Add elf_k1om_fbsd if elf_x86_64_fbsd is supported.
	(targ_extra_emuls): Likewise.

	* emulparams/elf_k1om.sh: New.
	* emulparams/elf_k1om_fbsd.sh: Likewise.

ld/testsuite/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-x86-64/abs-k1om.d: New.
	* ld-x86-64/protected2-k1om.d: Likewise.
	* ld-x86-64/protected3-k1om.d: Likewise.

	* ld-x86-64/x86-64.exp: Run abs-k1om, protected2-k1om and
	protected3-k1om.

opcodes/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* configure.in: Handle bfd_k1om_arch.
	* configure: Regenerated.

	* disassemble.c (disassembler): Handle bfd_k1om_arch.

	* i386-dis.c (print_insn): Handle bfd_mach_k1om and
	bfd_mach_k1om_intel_syntax.

	* i386-gen.c (cpu_flag_init): Set CPU_UNKNOWN_FLAGS to
	~(CpuL1OM|CpuK1OM).  Add CPU_K1OM_FLAGS.
	(cpu_flags): Add CpuK1OM.

	* i386-opc.h (CpuK1OM): New.
	(i386_cpu_flags): Add cpuk1om.

	* i386-init.h: Regenerated.
	* i386-tbl.h: Likewise.
@
text
@d1545 1
a1545 1
  if (do_loc)
d1963 1
d3454 315
d5856 2
@


1.96
log
@	* dwarf2.h (enum dwarf_location_atom): Add DW_OP_GNU_parameter_ref.

	* dwarf.c (decode_location_expression): For DW_OP_GNU_convert and
	DW_OP_GNU_reinterpret, if uvalue is 0, don't add cu_offset.
	Handle DW_OP_GNU_parameter_ref.
@
text
@d4236 1
@


1.95
log
@	* dwarf.c: Fix conversion to TU number.
@
text
@d1182 1
a1182 1
		  dwarf_vmatoa ("x", cu_offset + uvalue));
d1188 6
a1193 1
		  dwarf_vmatoa ("x", cu_offset + uvalue));
@


1.94
log
@	* dwarf.c (loc_offsets): New variable.
	(loc_offsets_compar): New routine.
	(display_debug_loc): Handle loc_offsets not being in ascending order
	and also a single .debug_loc entry being used multiple times.
@
text
@d5269 2
a5270 2
	      if (cu >= cu_list_elements)
		printf (" T%lu", (unsigned long) (cu - cu_list_elements));
@


1.93
log
@2011-05-10  Tristan Gingold  <gingold@@adacore.com>

	* dwarf.c (process_extended_line_op): Dump unknown records.
@
text
@d3491 13
d3516 1
d3518 1
a3518 1
  int use_debug_info = 1;
d3520 1
d3546 2
a3547 1
      num_loc_list += num;
d3550 1
a3550 1
      if (use_debug_info && num != 0)
d3568 1
a3568 1
		  use_debug_info = 0;
a3575 4
  if (!use_debug_info)
    /* FIXME: Should we handle this case?  */
    error (_("Location lists in .debug_info section aren't in ascending order!\n"));

d3586 2
d3610 1
a3610 2

      for (j = 0; j < debug_information [i].num_loc_offsets; j++)
d3612 15
d3740 1
@


1.92
log
@	* dwarf.c (decode_location_expression): Handle DW_OP_GNU_const_type,
	DW_OP_GNU_regval_type, DW_OP_GNU_deref_type, DW_OP_GNU_convert
	and DW_OP_GNU_reinterpret.
@
text
@d379 16
a394 8
      if (op_code >= DW_LNE_lo_user
	  /* The test against DW_LNW_hi_user is redundant due to
	     the limited range of the unsigned char data type used
	     for op_code.  */
	  /*&& op_code <= DW_LNE_hi_user*/)
	printf (_("user defined: length %d\n"), len - bytes_read);
      else
	printf (_("UNKNOWN: length %d\n"), len - bytes_read);
@


1.91
log
@	* NEWS: Add note about --dwarf-depth, --dwarf-start, and
	dwarf-mode.el.
	* objdump.c (suppress_bfd_header): New global.
	(usage): Update.
	(OPTION_DWARF_DEPTH, OPTION_DWARF_START): New constants.
	(options): Add dwarf-depth and dwarf-start entries.
	(dump_bfd): Use suppress_bfd_header.
	(main): Handle OPTION_DWARF_START, OPTION_DWARF_DEPTH.
	* doc/binutils.texi (objcopy): Document --dwarf-depth and
	--dwarf-start.
	(readelf): Likewise.
	* dwarf-mode.el: New file.
	* dwarf.c (dwarf_cutoff_level, dwarf_start_die): New globals.
	(read_and_display_attr_value): Also check debug_info_p.
	(process_debug_info): Handle dwarf_start_die and
	dwarf_cutoff_level.
	* dwarf.h (dwarf_cutoff_level, dwarf_start_die): Declare.
	* readelf.c (usage): Update.
	(OPTION_DWARF_DEPTH): New macro.
	(OPTION_DWARF_START): Likewise.
	(options): Add dwarf-depth and dwarf-start entries.
	(parse_args): Handle OPTION_DWARF_START and OPTION_DWARF_DEPTH.
testsuite
	* binutils-all/objdump.W: Correct output.
@
text
@a1086 11
	case DW_OP_GNU_entry_value:
	  uvalue = read_leb128 (data, &bytes_read, 0);
	  data += bytes_read;
	  printf ("DW_OP_GNU_entry_value: (");
	  if (decode_location_expression (data, pointer_size, offset_size,
					  dwarf_version, uvalue,
					  cu_offset, section))
	    need_frame_base = 1;
	  putchar (')');
	  data += uvalue;
	  break;
d1135 47
@


1.90
log
@binutils/
	* dwarf.c (display_gdb_index): Support version 5, warn on version 4.
@
text
@d66 3
d1420 2
a1421 1
      && num_debug_info_entries == 0)
d2035 2
a2036 1
      printf (_("Contents of the %s section:\n\n"), section->name);
d2054 1
a2054 1
      int level;
d2123 1
a2123 1
      if (!do_loc)
d2184 2
d2193 1
d2230 2
d2236 18
a2253 2
	    printf (_(" <%d><%lx>: Abbrev Number: %lu"),
		    level, die_offset, abbrev_number);
d2264 1
a2264 1
	      if (!do_loc)
d2274 1
a2274 1
	  if (!do_loc)
d2295 3
a2297 1
	      if (! do_loc)
d2299 5
a2303 1
		printf ("    <%2lx>", (unsigned long)(tags - section_begin));
d2311 2
a2312 2
					    debug_information + unit,
					    do_loc, section);
@


1.89
log
@2011-04-27  Tristan Gingold  <gingold@@adacore.com>

        * dwarf.c (process_extended_line_op): Handle
        DW_LNE_HP_source_file_correlation.
@
text
@d5073 3
@


1.88
log
@	* dwarf.c (decode_location_expression): Use dwarf_vmatoa
	function to display DW_OP_addr OP.
	(process_debug_info): Use dwarf_vma type for local variables
	length and type_offset.
@
text
@d327 47
@


1.87
log
@	* dwarf.c (process_debug_info): Use offset_size to determine
	the bit-size of the computation unit's offset.
@
text
@d677 2
a678 2
	  printf ("DW_OP_addr: %lx",
		  (unsigned long) byte_get (data, pointer_size));
d1929 1
a1929 1
      unsigned long length;
d1947 2
a1948 1
	      warn (_("Reserved length value (%lx) found in section %s\n"), length, section->name);
d1959 2
a1960 1
	      warn (_("Corrupt unit length (%lx) found in section %s\n"), length, section->name);
d2007 1
a2007 1
      unsigned long type_offset = 0;
d2089 2
a2090 1
	      printf (_("   Type Offset:   0x%lx\n"), type_offset);
@


1.86
log
@	Replace bfd_vma type and analog types by dwarf_vma and analogs.
	Use dwarf specific print functions to display these type values.
	* dwarf.h (dwarf_signed_vma): New type;
	(DWARF2_External_LineInfo): Replace bfd_vma by dwarf_vma.
	(DWARF2_External_PubNames): Likewise.
	(DWARF2_External_CompUnit): Likewise.
	(DWARF2_External_ARange): Likewise.
	(read_leb128): Change return type to dwarf_vma.
	* dwarf.c (print_dwarf_vma): Use __MINGW32__ conditional and
	check byte_size values.
	(dwarf_vmatoa): Change parameter type to dwarf_vma.
	(dwarf_svmatoa): New static function.
	(read_leb128): Change return type to dwarf_vma.
	(read_sleb128): New static function.
	(struct State_Machine_Registers): Change address field type to
	dwarf_vma.
	(process_extended_line_op): Adapt to type changes.
	(fetch_indirect_string): Likewise.
	(idisplay_block): Likewise.
	(decode_location_expression): Likewise.
	(read_and_display_attr_value): Likewise.
	(process_debug_info): Likewise.
	(display_debug_lines_raw): Likewise.
	(display_debug_lines_decoded): Likewise.
	(SLEB macro): Use new read_sleb128 function.
@
text
@d2075 1
a2075 1
		  initial_length_size == 8 ? "64-bit" : "32-bit");
@


1.85
log
@	* dwarf.c (dw_TAG_name): Handle DW_TAG_GNU_call_site_parameter.
	(read_and_display_attr_value): Handle DW_AT_GNU_call_site_data_value,
	DW_AT_GNU_call_site_target and DW_AT_GNU_call_site_target_clobbered.
	(get_AT_name): Handle DW_AT_GNU_call_site_value,
	DW_AT_GNU_call_site_data_value, DW_AT_GNU_call_site_target,
	DW_AT_GNU_call_site_target_clobbered, DW_AT_GNU_tail_call,
	DW_AT_GNU_all_tail_call_sites, DW_AT_GNU_all_call_sites and
	DW_AT_GNU_all_source_call_sites.
	(decode_location_expression) <case DW_OP_GNU_entry_value>: Adjust
	handling.

	* dwarf.c (get_TAG_name): Handle DW_TAG_GNU_call_site.
	(decode_location_expression): Handle DW_OP_GNU_entry_value.
	(read_and_display_attr_value): Handle DW_AT_GNU_call_site_value.
	(get_AT_name): Likewise.
@
text
@d109 1
d115 1
a115 1
#ifndef __MSVCRT__
d124 9
a132 1
  fputs (buff + (byte_size == 4 ? 8 : 0), stdout);
d135 10
d146 1
a146 1
dwarf_vmatoa (const char *fmtch, bfd_vma value)
d152 2
a153 1
  static struct dwarf_vmatoa_buf {
d159 1
a159 1
  sprintf (fmt, "%%%s%s", BFD_VMA_FMT, fmtch);
d162 1
a162 1
  buf_pos %= ARRAY_SIZE(buf);
d169 1
a169 1
bfd_vma
d172 1
a172 1
  bfd_vma result = 0;
d182 1
a182 1
      result |= ((bfd_vma) (byte & 0x7f)) << shift;
d198 7
d207 1
a207 1
  unsigned long address;
d246 1
a246 1
  bfd_vma adr;
d283 1
a283 1
      printf ("%" BFD_VMA_FMT "u\t", read_leb128 (data, & bytes_read, 0));
d285 1
a285 2
      printf ("%" BFD_VMA_FMT "u\t",
	      read_leb128 (data, & bytes_read, 0));
d287 1
a287 1
      printf ("%" BFD_VMA_FMT "u\t", read_leb128 (data, & bytes_read, 0));
d293 1
a293 2
	      dwarf_vmatoa ("u",
			    read_leb128 (data, & bytes_read, 0)));
d344 1
a344 1
fetch_indirect_string (bfd_vma offset)
d355 2
a356 1
      warn (_("DW_FORM_strp offset too big: %lx\n"), (long) offset);
a418 1

a443 1

d645 1
a645 1
display_block (unsigned char *data, unsigned long length)
d647 1
a647 1
  printf (_(" %lu byte block: "), length);
d660 2
a661 2
			    bfd_vma length,
			    bfd_vma cu_offset,
d666 1
a666 1
  bfd_vma uvalue;
d717 2
a718 2
	  printf ("DW_OP_constu: %" BFD_VMA_FMT "u",
		  read_leb128 (data, &bytes_read, 0));
d722 2
a723 2
	  printf ("DW_OP_consts: %" BFD_VMA_FMT "d",
		  read_leb128 (data, &bytes_read, 1));
d778 2
a779 2
	  printf ("DW_OP_plus_uconst: %" BFD_VMA_FMT "u",
		  read_leb128 (data, &bytes_read, 0));
d924 1
a924 1
	  printf ("DW_OP_breg%d (%s): %" BFD_VMA_FMT "d",
d927 2
a928 1
		  read_leb128 (data, &bytes_read, 1));
d935 2
a936 2
	  printf ("DW_OP_regx: %" BFD_VMA_FMT "u (%s)",
		  uvalue, regname (uvalue, 1));
d940 2
a941 2
	  printf ("DW_OP_fbreg: %" BFD_VMA_FMT "d",
		  read_leb128 (data, &bytes_read, 1));
d947 3
a949 3
	  printf ("DW_OP_bregx: %" BFD_VMA_FMT "u (%s) %" BFD_VMA_FMT "d",
		  uvalue, regname (uvalue, 1),
		  read_leb128 (data, &bytes_read, 1));
d953 2
a954 2
	  printf ("DW_OP_piece: %" BFD_VMA_FMT "u",
		  read_leb128 (data, &bytes_read, 0));
d974 3
a976 2
	  printf ("DW_OP_call2: <0x%" BFD_VMA_FMT "x>",
		  (bfd_signed_vma) byte_get (data, 2) + cu_offset);
d982 3
a984 2
	  printf ("DW_OP_call4: <0x%" BFD_VMA_FMT "x>",
		  (bfd_signed_vma) byte_get (data, 4) + cu_offset);
d998 2
a999 2
	      printf ("DW_OP_call_ref: <0x%lx>",
		      (long) byte_get (data, pointer_size));
d1004 2
a1005 2
	      printf ("DW_OP_call_ref: <0x%lx>",
		      (long) byte_get (data, offset_size));
d1017 2
a1018 2
	  printf ("size: %" BFD_VMA_FMT "u ",
		  read_leb128 (data, &bytes_read, 0));
d1020 2
a1021 2
	  printf ("offset: %" BFD_VMA_FMT "u ",
		  read_leb128 (data, &bytes_read, 0));
d1061 1
a1061 1
	
d1081 4
a1084 5
	      printf ("DW_OP_GNU_implicit_pointer: "
		      "<0x%" BFD_VMA_FMT "x> %" BFD_VMA_FMT "d",
		      (bfd_vma) byte_get (data, pointer_size),
		      (bfd_signed_vma) read_leb128 (data + pointer_size,
						&bytes_read, 1));
d1089 4
a1092 5
	      printf ("DW_OP_GNU_implicit_pointer: "
		      "<0x%" BFD_VMA_FMT "x> %" BFD_VMA_FMT "d",
		      (bfd_vma) byte_get (data, offset_size),
		      (bfd_signed_vma) read_leb128 (data + offset_size,
						&bytes_read, 1));
d1154 3
a1156 3
			     bfd_vma cu_offset,
			     bfd_vma pointer_size,
			     bfd_vma offset_size,
d1162 1
a1162 1
  bfd_vma uvalue = 0;
d1184 2
a1185 3
	{
	  error (_("Internal error: DWARF version is not 2, 3 or 4.\n"));
	}
d1248 1
a1248 1
	printf (" <0x%" BFD_VMA_FMT "x>", uvalue);
d1256 1
a1256 1
	printf (" <0x%" BFD_VMA_FMT "x>", uvalue + cu_offset);
d1263 1
a1263 1
	printf (" 0x%" BFD_VMA_FMT "x", uvalue);
d1273 1
a1273 1
	printf (" %" BFD_VMA_FMT "d", uvalue);
d1281 1
a1281 1
	  printf (" 0x%" BFD_VMA_FMT "x", uvalue);
d1290 1
a1290 1
	    error (_("DW_FORM_data8 is unsupported when sizeof (bfd_vma) != 8\n"));
d1399 1
a1399 1
		  debug_info_p->loc_offsets = (bfd_vma *)
d1430 1
a1430 1
		  debug_info_p->range_lists = (bfd_vma *)
d1508 2
a1509 1
	    printf ("(implementation defined: %" BFD_VMA_FMT "x)", uvalue);
d1511 1
a1511 1
	    printf ("(Unknown: %" BFD_VMA_FMT "x)", uvalue);
d1887 3
a1889 3
		       bfd_vma cu_offset,
		       bfd_vma pointer_size,
		       bfd_vma offset_size,
d2001 1
a2001 1
      bfd_vma cu_offset;
d2246 1
a2246 3
    {
      printf ("\n");
    }
d2434 2
a2435 2
	      printf ("%" BFD_VMA_FMT "u\t",
		      read_leb128 (data, & bytes_read, 0));
d2437 2
a2438 2
	      printf ("%" BFD_VMA_FMT "u\t",
		      read_leb128 (data, & bytes_read, 0));
d2440 2
a2441 2
	      printf ("%" BFD_VMA_FMT "u\t",
		      read_leb128 (data, & bytes_read, 0));
d2456 2
a2457 2
	  int adv;
	  unsigned long int uladv;
d2470 4
a2473 2
		  printf (_("  Special opcode %d: advance Address by %lu to 0x%lx"),
			  op_code, uladv, state_machine_regs.address);
d2484 4
a2487 2
		  printf (_("  Special opcode %d: advance Address by %lu to 0x%lx[%d]"),
			  op_code, uladv, state_machine_regs.address,
d2492 2
a2493 2
	      printf (_(" and Line by %d to %d\n"),
		      adv, state_machine_regs.line);
d2512 3
a2514 2
		  printf (_("  Advance PC by %lu to 0x%lx\n"), uladv,
			  state_machine_regs.address);
d2525 3
a2527 2
		  printf (_("  Advance PC by %lu to 0x%lx[%d]\n"), uladv,
			  state_machine_regs.address,
d2533 1
a2533 1
	      adv = read_leb128 (data, & bytes_read, 1);
d2536 3
a2538 2
	      printf (_("  Advance Line by %d to %d\n"), adv,
		      state_machine_regs.line);
d2544 2
a2545 2
	      printf (_("  Set File Name to entry %d in the File Name Table\n"),
		      adv);
d2552 2
a2553 1
	      printf (_("  Set column to %lu\n"), uladv);
d2560 1
a2560 1
	      printf (_("  Set is_stmt to %d\n"), adv);
d2575 3
a2577 2
		  printf (_("  Advance PC by constant %lu to 0x%lx\n"), uladv,
			  state_machine_regs.address);
d2588 3
a2590 2
		  printf (_("  Advance PC by constant %lu to 0x%lx[%d]\n"),
			  uladv, state_machine_regs.address,
d2600 3
a2602 2
	      printf (_("  Advance PC by fixed size amount %lu to 0x%lx\n"),
		      uladv, state_machine_regs.address);
d2616 1
a2616 1
	      printf (_("  Set ISA to %lu\n"), uladv);
d2624 2
a2625 2
		  printf ("0x%" BFD_VMA_FMT "x%s",
			  read_leb128 (data, &bytes_read, 0),
d2641 4
a2644 4
    unsigned char *name;
    unsigned int directory_index;
    unsigned int modification_date;
    unsigned int length;
d2955 1
a2955 1
              adv = read_leb128 (data, & bytes_read, 1);
d3038 2
a3039 2
                  printf ("0x%" BFD_VMA_FMT "x%s",
			  read_leb128 (data, &bytes_read, 0),
d3074 2
a3075 2
		    printf ("%-35s  %11d  %#18lx\n", newFileName,
			    state_machine_regs.line,
d3078 2
a3079 2
		    printf ("%-35s  %11d  %#18lx[%d]\n", newFileName,
			    state_machine_regs.line,
d3086 2
a3087 2
		    printf ("%s  %11d  %#18lx\n", newFileName,
			    state_machine_regs.line,
d3090 2
a3091 2
		    printf ("%s  %11d  %#18lx[%d]\n", newFileName,
			    state_machine_regs.line,
d3791 3
a3793 3
  {
    /* The debug_information[x].range_lists[y] value.  */
    unsigned long ranges_offset;
d3795 3
a3797 3
    /* Original debug_information to find parameters of the data.  */
    debug_info *debug_info_p;
  };
d4177 1
a4177 1
#define SLEB()	read_leb128 (start, & length_return, 1); start += length_return
d5236 1
a5236 1
  
d5241 1
a5241 1
      
d5245 1
a5245 1
	  
d5250 1
a5250 1
	      
d5260 1
a5260 1
      
d5268 1
a5268 1
      
d5285 1
a5285 1
	
d5289 1
a5289 1
	
d5293 1
a5293 1
	
d5297 1
a5297 1
	
d5301 1
a5301 1
	
d5305 1
a5305 1
	
d5309 1
a5309 1
	
d5313 1
a5313 1
	
d5319 1
a5319 1
	
d5323 1
a5323 1
	
d5327 1
a5327 1
	
d5331 1
a5331 1
	
@


1.84
log
@ChangeLog include/

2011-02-23  Kai Tietz  <kai.tietz@@onevision.com>

	* dwarf2.h (_ELF_DWARF2_H): Renamed to
	_DWARF2_H.
	(DWARF2_External_LineInfo, DWARF2_Internal_LineInfo,
	DWARF2_External_PubNames, DWARF2_Internal_PubNames,
	DWARF2_External_CompUnit, DWARF2_Internal_CompUnit,
	DWARF2_External_ARange, DWARF2_Internal_ARange): Removed.


ChangeLog binutils/

2011-02-23  Kai Tietz  <kai.tietz@@onevision.com>

	* dwarf.c (read_leb128): Use bfd_vma instead of
	long type.
	(dwarf_vmatoa): New helper routine.
	(process_extended_line_op): Use for adr bfd_vma
	type and print those typed values via BFD_VMA_FMT
	or via dwarf_vmatoa for localized prints.
	(fetch_indirect_string): Adjust offset's type.
	(decode_location_expression): Adjust argument types
	and uvalue type.
	(read_and_display_attr_value): Likewise.
	(read_and_display_attr): Likewise.
	(decode_location_expression): Adjust printf format.
	(process_debug_info): Likewise.
	(display_debug_lines_raw): Likewise.
	(display_debug_lines_decoded): Likewise.
	(display_debug_pubnames): Likewise.
	(display_debug_loc): Likewise.
	(display_debug_aranges): Likewise.
	* dwarf.h (DWARF2_External_LineInfo,
	DWARF2_Internal_LineInfo, DWARF2_External_PubNames,
	DWARF2_Internal_PubNames, DWARF2_External_CompUnit,
	DWARF2_Internal_CompUnit, DWARF2_External_ARange,
	DWARF2_Internal_ARange): Added..
	(read_leb128): Adjust return type.
@
text
@d2 1
a2 1
   Copyright 2005, 2006, 2007, 2008, 2009, 2010
d566 3
d1010 11
d1360 4
d1608 4
d1830 8
@


1.83
log
@binutils/
	* dwarf.c (display_gdb_index): Support version 4, warn on version 3.
@
text
@d126 24
a149 1
unsigned long int
d152 1
a152 1
  unsigned long int result = 0;
d162 1
a162 1
      result |= ((unsigned long int) (byte & 0x7f)) << shift;
d219 1
a219 1
  unsigned long adr;
d244 1
a244 1
      printf (_("set Address to 0x%lx\n"), adr);
d256 1
a256 1
      printf ("%lu\t", read_leb128 (data, & bytes_read, 0));
d258 2
a259 1
      printf ("%lu\t", read_leb128 (data, & bytes_read, 0));
d261 1
a261 1
      printf ("%lu\t", read_leb128 (data, & bytes_read, 0));
d266 3
a268 2
      printf (_("set Discriminator to %lu\n"),
              read_leb128 (data, & bytes_read, 0));
d319 1
a319 1
fetch_indirect_string (unsigned long offset)
d330 1
a330 1
      warn (_("DW_FORM_strp offset too big: %lx\n"), offset);
d633 2
a634 2
			    unsigned long length,
			    unsigned long cu_offset,
d639 1
a639 1
  unsigned long uvalue;
d690 2
a691 1
	  printf ("DW_OP_constu: %lu", read_leb128 (data, &bytes_read, 0));
d695 2
a696 1
	  printf ("DW_OP_consts: %ld", read_leb128 (data, &bytes_read, 1));
d751 1
a751 1
	  printf ("DW_OP_plus_uconst: %lu",
d897 2
a898 1
	  printf ("DW_OP_breg%d (%s): %ld", op - DW_OP_breg0,
d907 2
a908 1
	  printf ("DW_OP_regx: %lu (%s)", uvalue, regname (uvalue, 1));
d912 2
a913 1
	  printf ("DW_OP_fbreg: %ld", read_leb128 (data, &bytes_read, 1));
d919 2
a920 1
	  printf ("DW_OP_bregx: %lu (%s) %ld", uvalue, regname (uvalue, 1),
d925 2
a926 1
	  printf ("DW_OP_piece: %lu", read_leb128 (data, &bytes_read, 0));
d946 2
a947 1
	  printf ("DW_OP_call2: <0x%lx>", (long) byte_get (data, 2) + cu_offset);
d953 2
a954 1
	  printf ("DW_OP_call4: <0x%lx>", (long) byte_get (data, 4) + cu_offset);
d987 2
a988 1
	  printf ("size: %lu ", read_leb128 (data, &bytes_read, 0));
d990 2
a991 1
	  printf ("offset: %lu ", read_leb128 (data, &bytes_read, 0));
d1040 5
a1044 3
	      printf ("DW_OP_GNU_implicit_pointer: <0x%lx> %ld",
		      (long) byte_get (data, pointer_size),
		      read_leb128 (data + pointer_size, &bytes_read, 1));
d1049 5
a1053 3
	      printf ("DW_OP_GNU_implicit_pointer: <0x%lx> %ld",
		      (long) byte_get (data, offset_size),
		      read_leb128 (data + offset_size, &bytes_read, 1));
d1115 3
a1117 3
			     unsigned long cu_offset,
			     unsigned long pointer_size,
			     unsigned long offset_size,
d1123 1
a1123 1
  unsigned long uvalue = 0;
d1210 1
a1210 1
	printf (" <0x%lx>", uvalue);
d1218 1
a1218 1
	printf (" <0x%lx>", uvalue + cu_offset);
d1225 1
a1225 1
	printf (" 0x%lx", uvalue);
d1235 1
a1235 1
	printf (" %ld", uvalue);
d1243 1
a1243 1
	  printf (" 0x%lx", uvalue);
d1252 1
a1252 1
	    error (_("DW_FORM_data8 is unsupported when sizeof (unsigned long) != 8\n"));
d1302 3
a1304 2
	printf (_(" (indirect string, offset: 0x%lx): %s"),
		uvalue, fetch_indirect_string (uvalue));
d1357 1
a1357 1
		  debug_info_p->loc_offsets = (long unsigned int *)
d1388 1
a1388 1
		  debug_info_p->range_lists = (long unsigned int *)
d1427 2
a1428 1
	  printf (_("  (Unknown inline attribute value: %lx)"), uvalue);
d1466 1
a1466 1
	    printf ("(implementation defined: %lx)", uvalue);
d1468 1
a1468 1
	    printf ("(Unknown: %lx)", uvalue);
d1629 3
a1631 2
	  warn (_("Offset %lx used as value for DW_AT_import attribute of DIE at offset %lx is too big.\n"),
		uvalue, (unsigned long) (orig_data - section->start));
d1832 3
a1834 3
		       unsigned long cu_offset,
		       unsigned long pointer_size,
		       unsigned long offset_size,
d1946 1
a1946 1
      unsigned long cu_offset;
d2016 4
a2019 2
	  printf (_("  Compilation Unit @@ offset 0x%lx:\n"), cu_offset);
	  printf (_("   Length:        0x%lx (%s)\n"), compunit.cu_length,
d2022 2
a2023 1
	  printf (_("   Abbrev Offset: %ld\n"), compunit.cu_abbrev_offset);
d2039 4
a2042 2
	  warn (_("Debug info is corrupted, length of CU at %lx extends beyond end of section (length = %lx)\n"),
		cu_offset, compunit.cu_length);
d2052 3
a2054 2
	  warn (_("CU at offset %lx contains corrupt or unsupported version number: %d.\n"),
		cu_offset, compunit.cu_version);
d2320 1
a2320 1
      printf (_("  Length:                      %ld\n"), linfo.li_length);
d2381 2
a2382 1
	      printf ("%lu\t", read_leb128 (data, & bytes_read, 0));
d2384 2
a2385 1
	      printf ("%lu\t", read_leb128 (data, & bytes_read, 0));
d2387 2
a2388 1
	      printf ("%lu\t", read_leb128 (data, & bytes_read, 0));
d2560 2
a2561 1
		  printf ("0x%lx%s", read_leb128 (data, &bytes_read, 0),
d2974 2
a2975 1
                  printf ("0x%lx%s", read_leb128 (data, &bytes_read, 0),
d3133 1
a3133 1
	      names.pn_offset, section->name);
d3154 1
a3154 1
	      names.pn_length);
d3158 1
a3158 1
	      names.pn_offset);
d3160 1
a3160 1
	      names.pn_size);
d3380 3
a3382 2
    warn (_("Location lists in %s section start at 0x%lx\n"),
	  section->name, debug_information [first].loc_offsets [0]);
d3654 1
a3654 1
	      arange.ar_info_offset, section->name);
d3668 2
a3669 1
      printf (_("  Length:                   %ld\n"), arange.ar_length);
d3671 2
a3672 1
      printf (_("  Offset into .debug_info:  0x%lx\n"), arange.ar_info_offset);
@


1.82
log
@2010-12-15  Kai Tietz  <kai.tietz@@onevision.com>

        * dwarf.c (display_gdb_index): Fix printf types for
        used formatters.
@
text
@d4896 1
a4896 1
  if (version != 3)
d4898 6
@


1.81
log
@	* dwarf.c: #include "bfd_stdint.h".
	(do_gdb_index): New global.
	(display_gdb_index): New function.
	(dwarf_select_sections_by_names) Add "gdb_index".
	(dwarf_select_sections_all): Set do_gdb_index.
	(debug_displays): Add .gdb_index.
	* dwarf.h (do_gdb_index): Declare.
	* objdump.c (usage): Add gdb_index.
	* readelf.c (usage): Add gdb_index.
	(process_section_headers): Process ".gdb_index".
	* doc/binutils.texi (readelf): Document gdb_index dump.
	(objdump): Ditto.
@
text
@d4892 1
a4892 1
  printf (_("Version %d\n"), version);
d4898 1
a4898 1
      warn (_("Unsupported version %u.\n"), version);
d4963 1
a4963 1
      printf (_("%u\n"), cu_index);
d4985 1
a4985 1
		printf (" T%u", cu - cu_list_elements);
d4987 1
a4987 1
		printf (" %u", cu);
@


1.80
log
@	* dwarf.c (decode_location_expression, display_debug_frames): Move
	code handling DW_EH_PE_pcrel into..
	(get_encoded_value): ..here.
@
text
@d25 1
d60 1
d4868 129
d5099 2
d5225 1
d5265 2
@


1.79
log
@Add and use elfcomm.c/elfcomm.h.

2010-11-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/12235
	* elfcomm.c: New.
	* elfcomm.h: Likewise.

	* Makefile.am (HFILES): Add elfcomm.h.
	(CFILES): Add elfcomm.c.
	(ELFLIBS): New.
	(readelf_SOURCES): Add $(ELFLIBS).
	(elfedit_SOURCES): Likewise.
	(objdump_SOURCES): Likewise.
	* Makefile.in: Regenerated.

	* dwarf.c: Include "elfcomm.h".
	(byte_get): Removed.
	(byte_get_little_endian): Likewise.
	(byte_get_big_endian): Likewise.
	(byte_get_signed): Likewise.
	(error): Likewise.
	(warn): Likewise.

	* dwarf.h (dwarf_vma): Defined with HOST_WIDEST_INT.
	(dwarf_size_type): Likewise.
	(byte_get): Removed.
	(byte_get_signed): Likewise.
	(byte_get_little_endian): Likewise.
	(byte_get_big_endian): Likewise.
	(error): Likewise.
	(warn): Likewise.

	* elfedit.c: Include "elfcomm.h".  Don't include "aout/ar.h".
	Call error () instead of non_fatal ().
	(streq): Removed.
	(strneq): Likewise.
	(const_strneq): Likewise.
	(non_fatal): Likewise.
	(BYTE_GET): Likewise.
	(BYTE_PUT): Likewise.
	(byte_get): Likewise.
	(byte_put): Likewise.
	(byte_get_little_endian): Likewise.
	(byte_get_big_endian): Likewise.
	(byte_put_little_endian): Likewise.
	(byte_put_big_endian): Likewise.
	(adjust_relative_path): Likewise.
	(archive_info): Likewise.
	(setup_archive): Likewise.
	(release_archive): Likewise.
	(setup_nested_archive): Likewise.
	(get_archive_member_name): Likewise.
	(get_archive_member_name_at): Likewise.
	(make_qualified_name): Likewise.

	* objdump.c: Include "elfcomm.h".

	* readelf.c: Include "elfcomm.h".  Don't include "aout/ar.h".
	(BYTE_GET): Removed.
	(BYTE_GET_SIGNED): Removed.
	(streq): Likewise.
	(strneq): Likewise.
	(const_strneq): Likewise.
	(byte_put): Likewise.
	(byte_put_little_endian): Likewise.
	(byte_put_big_endian): Likewise.
	(adjust_relative_path): Likewise.
	(archive_info): Likewise.
	(setup_archive): Likewise.
	(release_archive): Likewise.
	(setup_nested_archive): Likewise.
	(get_archive_member_name): Likewise.
	(get_archive_member_name_at): Likewise.
	(make_qualified_name): Likewise.
@
text
@d82 3
a84 1
get_encoded_value (unsigned char *data, int encoding)
d87 1
d90 1
a90 1
    return byte_get_signed (data, size);
d92 5
a96 1
    return byte_get (data, size);
d984 1
a984 3
	    addr = get_encoded_value (data, encoding);
	    if ((encoding & 0x70) == DW_EH_PE_pcrel)
	      addr += section->address + (data - section->start);
d4290 1
a4290 3
	  fc->pc_begin = get_encoded_value (start, fc->fde_encoding);
	  if ((fc->fde_encoding & 0x70) == DW_EH_PE_pcrel)
	    fc->pc_begin += section->address + (start - section_start);
d4508 1
a4508 3
	      vma = get_encoded_value (start, fc->fde_encoding);
	      if ((fc->fde_encoding & 0x70) == DW_EH_PE_pcrel)
		vma += section->address + (start - section_start);
@


1.78
log
@	* ar.c (print_contents): Don't internationalize strings without words.
	* dwarf.c (process_extended_line_op): Likewise.
	(process_debug_info): Likwise.
	(display_debug_lines_raw): Likewise.
	(display_debug_lines_decoded): Likewise.
	(display_debug_abbrev): Likewise.
	* readelf.c (process_file_header): Likewise.
	(GET_OP): Likewise.
	(decode_arm_unwind): Likewise.
	(process_mips_specific): Likewise.
	* resrc.c (run_cmd): Likewise.
	(rcparse_warning): Likewise.
	* objdump.c (dump_headers): Don't print "Pg".
@
text
@d26 1
a67 119
dwarf_vma (*byte_get) (unsigned char *, int);

dwarf_vma
byte_get_little_endian (unsigned char *field, int size)
{
  switch (size)
    {
    case 1:
      return *field;

    case 2:
      return  ((unsigned int) (field[0]))
	|    (((unsigned int) (field[1])) << 8);

    case 3:
      return  ((unsigned long) (field[0]))
	|    (((unsigned long) (field[1])) << 8)
	|    (((unsigned long) (field[2])) << 16);

    case 4:
      return  ((unsigned long) (field[0]))
	|    (((unsigned long) (field[1])) << 8)
	|    (((unsigned long) (field[2])) << 16)
	|    (((unsigned long) (field[3])) << 24);

    case 8:
      if (sizeof (dwarf_vma) == 8)
	return  ((dwarf_vma) (field[0]))
	  |    (((dwarf_vma) (field[1])) << 8)
	  |    (((dwarf_vma) (field[2])) << 16)
	  |    (((dwarf_vma) (field[3])) << 24)
	  |    (((dwarf_vma) (field[4])) << 32)
	  |    (((dwarf_vma) (field[5])) << 40)
	  |    (((dwarf_vma) (field[6])) << 48)
	  |    (((dwarf_vma) (field[7])) << 56);
      else if (sizeof (dwarf_vma) == 4)
	/* We want to extract data from an 8 byte wide field and
	   place it into a 4 byte wide field.  Since this is a little
	   endian source we can just use the 4 byte extraction code.  */
	return  ((unsigned long) (field[0]))
	  |    (((unsigned long) (field[1])) << 8)
	  |    (((unsigned long) (field[2])) << 16)
	  |    (((unsigned long) (field[3])) << 24);

    default:
      error (_("Unhandled data length: %d\n"), size);
      abort ();
    }
}

dwarf_vma
byte_get_big_endian (unsigned char *field, int size)
{
  switch (size)
    {
    case 1:
      return *field;

    case 2:
      return ((unsigned int) (field[1])) | (((int) (field[0])) << 8);

    case 3:
      return ((unsigned long) (field[2]))
	|   (((unsigned long) (field[1])) << 8)
	|   (((unsigned long) (field[0])) << 16);

    case 4:
      return ((unsigned long) (field[3]))
	|   (((unsigned long) (field[2])) << 8)
	|   (((unsigned long) (field[1])) << 16)
	|   (((unsigned long) (field[0])) << 24);

    case 8:
      if (sizeof (dwarf_vma) == 8)
	return ((dwarf_vma) (field[7]))
	  |   (((dwarf_vma) (field[6])) << 8)
	  |   (((dwarf_vma) (field[5])) << 16)
	  |   (((dwarf_vma) (field[4])) << 24)
	  |   (((dwarf_vma) (field[3])) << 32)
	  |   (((dwarf_vma) (field[2])) << 40)
	  |   (((dwarf_vma) (field[1])) << 48)
	  |   (((dwarf_vma) (field[0])) << 56);
      else if (sizeof (dwarf_vma) == 4)
	{
	  /* Although we are extracing data from an 8 byte wide field,
	     we are returning only 4 bytes of data.  */
	  field += 4;
	  return ((unsigned long) (field[3]))
	    |   (((unsigned long) (field[2])) << 8)
	    |   (((unsigned long) (field[1])) << 16)
	    |   (((unsigned long) (field[0])) << 24);
	}

    default:
      error (_("Unhandled data length: %d\n"), size);
      abort ();
    }
}

dwarf_vma
byte_get_signed (unsigned char *field, int size)
{
  dwarf_vma x = byte_get (field, size);

  switch (size)
    {
    case 1:
      return (x ^ 0x80) - 0x80;
    case 2:
      return (x ^ 0x8000) - 0x8000;
    case 4:
      return (x ^ 0x80000000) - 0x80000000;
    case 8:
      return x;
    default:
      abort ();
    }
}

a4904 22
error (const char *message, ...)
{
  va_list args;

  va_start (args, message);
  fprintf (stderr, _("%s: Error: "), program_name);
  vfprintf (stderr, message, args);
  va_end (args);
}

void
warn (const char *message, ...)
{
  va_list args;

  va_start (args, message);
  fprintf (stderr, _("%s: Warning: "), program_name);
  vfprintf (stderr, message, args);
  va_end (args);
}

void
@


1.77
log
@Use BYTE_GET_SIGNED on r_addend.

2010-10-08  H.J. Lu  <hongjiu.lu@@intel.com>

	* dwarf.c (byte_get_signed): Make it extern.

	* dwarf.h (byte_get_signed): New.

	* readelf.c (BYTE_GET_SIGNED): New.
	(slurp_rela_relocs): Use BYTE_GET_SIGNED on r_addend.
	(dump_relocations): Properly dump r_addend.
@
text
@d339 1
a339 1
      printf (_("   %d\t"), ++state_machine_regs.last_file_entry);
d342 1
a342 1
      printf (_("%lu\t"), read_leb128 (data, & bytes_read, 0));
d344 1
a344 1
      printf (_("%lu\t"), read_leb128 (data, & bytes_read, 0));
d346 2
a347 2
      printf (_("%lu\t"), read_leb128 (data, & bytes_read, 0));
      printf (_("%s\n\n"), name);
d2206 1
a2206 1
	    printf (_(" (%s)\n"), get_TAG_name (entry->tag));
d2416 1
a2416 1
	      printf (_("  %s\n"), data);
d2438 1
a2438 1
	      printf (_("  %d\t"), ++state_machine_regs.last_file_entry);
d2443 1
a2443 1
	      printf (_("%lu\t"), read_leb128 (data, & bytes_read, 0));
d2445 1
a2445 1
	      printf (_("%lu\t"), read_leb128 (data, & bytes_read, 0));
d2447 1
a2447 1
	      printf (_("%lu\t"), read_leb128 (data, & bytes_read, 0));
d2449 1
a2449 1
	      printf (_("%s\n"), name);
d2827 2
a2828 4
                {
                  printf (_("CU: %s/%s:\n"), directory_table[0],
                          file_table[0].name);
                }
d2830 2
a2831 3
                {
                  printf (_("%s:\n"), file_table[0].name);
                }
d2915 1
a2915 1
                      printf (_("%s:\n"), directory_table[dir_index]);
d2961 1
a2961 1
                  printf (_("\n./%s:[++]\n"),
d2967 1
a2967 1
                  printf (_("\n%s/%s:\n"),
d3067 1
a3067 1
		    printf (_("%-35s  %11d  %#18lx\n"), newFileName,
d3071 1
a3071 1
		    printf (_("%-35s  %11d  %#18lx[%d]\n"), newFileName,
d3079 1
a3079 1
		    printf (_("%s  %11d  %#18lx\n"), newFileName,
d3083 1
a3083 1
		    printf (_("%s  %11d  %#18lx[%d]\n"), newFileName,
d3340 1
a3340 1
	  printf (_("   %ld      %s    [%s]\n"),
d3346 1
a3346 1
	    printf (_("    %-18s %s\n"),
@


1.77.2.1
log
@backport from mainline
@
text
@a24 1
#include "bfd_stdint.h"
a25 1
#include "elfcomm.h"
a57 1
int do_gdb_index;
d67 119
d200 1
a200 3
get_encoded_value (unsigned char *data,
		   int encoding,
		   struct dwarf_section *section)
a202 1
  dwarf_vma val;
d205 1
a205 1
    val = byte_get_signed (data, size);
d207 1
a207 5
    val = byte_get (data, size);

  if ((encoding & 0x70) == DW_EH_PE_pcrel)
    val += section->address + (data - section->start);
  return val;
d339 1
a339 1
      printf ("   %d\t", ++state_machine_regs.last_file_entry);
d342 1
a342 1
      printf ("%lu\t", read_leb128 (data, & bytes_read, 0));
d344 1
a344 1
      printf ("%lu\t", read_leb128 (data, & bytes_read, 0));
d346 2
a347 2
      printf ("%lu\t", read_leb128 (data, & bytes_read, 0));
      printf ("%s\n\n", name);
d1095 3
a1097 1
	    addr = get_encoded_value (data, encoding, section);
d2206 1
a2206 1
	    printf (" (%s)\n", get_TAG_name (entry->tag));
d2416 1
a2416 1
	      printf ("  %s\n", data);
d2438 1
a2438 1
	      printf ("  %d\t", ++state_machine_regs.last_file_entry);
d2443 1
a2443 1
	      printf ("%lu\t", read_leb128 (data, & bytes_read, 0));
d2445 1
a2445 1
	      printf ("%lu\t", read_leb128 (data, & bytes_read, 0));
d2447 1
a2447 1
	      printf ("%lu\t", read_leb128 (data, & bytes_read, 0));
d2449 1
a2449 1
	      printf ("%s\n", name);
d2827 4
a2830 2
		printf (_("CU: %s/%s:\n"), directory_table[0],
			file_table[0].name);
d2832 3
a2834 2
		printf ("%s:\n", file_table[0].name);

d2918 1
a2918 1
                      printf ("%s:\n", directory_table[dir_index]);
d2964 1
a2964 1
                  printf ("\n./%s:[++]\n",
d2970 1
a2970 1
                  printf ("\n%s/%s:\n",
d3070 1
a3070 1
		    printf ("%-35s  %11d  %#18lx\n", newFileName,
d3074 1
a3074 1
		    printf ("%-35s  %11d  %#18lx[%d]\n", newFileName,
d3082 1
a3082 1
		    printf ("%s  %11d  %#18lx\n", newFileName,
d3086 1
a3086 1
		    printf ("%s  %11d  %#18lx[%d]\n", newFileName,
d3343 1
a3343 1
	  printf ("   %ld      %s    [%s]\n",
d3349 1
a3349 1
	    printf ("    %-18s %s\n",
d4406 3
a4408 1
	  fc->pc_begin = get_encoded_value (start, fc->fde_encoding, section);
d4626 3
a4628 1
	      vma = get_encoded_value (start, fc->fde_encoding, section);
a4985 129
display_gdb_index (struct dwarf_section *section,
		   void *file ATTRIBUTE_UNUSED)
{
  unsigned char *start = section->start;
  uint32_t version;
  uint32_t cu_list_offset, tu_list_offset;
  uint32_t address_table_offset, symbol_table_offset, constant_pool_offset;
  unsigned int cu_list_elements, tu_list_elements;
  unsigned int address_table_size, symbol_table_slots;
  unsigned char *cu_list, *tu_list;
  unsigned char *address_table, *symbol_table, *constant_pool;
  unsigned int i;

  /* The documentation for the format of this file is in gdb/dwarf2read.c.  */

  printf (_("Contents of the %s section:\n"), section->name);

  if (section->size < 6 * sizeof (uint32_t))
    {
      warn (_("Truncated header in the %s section.\n"), section->name);
      return 0;
    }

  version = byte_get_little_endian (start, 4);
  printf (_("Version %ld\n"), (long) version);

  /* Prior versions are obsolete, and future versions may not be
     backwards compatible.  */
  if (version != 3)
    {
      warn (_("Unsupported version %lu.\n"), (unsigned long) version);
      return 0;
    }

  cu_list_offset = byte_get_little_endian (start + 4, 4);
  tu_list_offset = byte_get_little_endian (start + 8, 4);
  address_table_offset = byte_get_little_endian (start + 12, 4);
  symbol_table_offset = byte_get_little_endian (start + 16, 4);
  constant_pool_offset = byte_get_little_endian (start + 20, 4);

  if (cu_list_offset > section->size
      || tu_list_offset > section->size
      || address_table_offset > section->size
      || symbol_table_offset > section->size
      || constant_pool_offset > section->size)
    {
      warn (_("Corrupt header in the %s section.\n"), section->name);
      return 0;
    }

  cu_list_elements = (tu_list_offset - cu_list_offset) / 8;
  tu_list_elements = (address_table_offset - tu_list_offset) / 8;
  address_table_size = symbol_table_offset - address_table_offset;
  symbol_table_slots = (constant_pool_offset - symbol_table_offset) / 8;

  cu_list = start + cu_list_offset;
  tu_list = start + tu_list_offset;
  address_table = start + address_table_offset;
  symbol_table = start + symbol_table_offset;
  constant_pool = start + constant_pool_offset;

  printf (_("\nCU table:\n"));
  for (i = 0; i < cu_list_elements; i += 2)
    {
      uint64_t cu_offset = byte_get_little_endian (cu_list + i * 8, 8);
      uint64_t cu_length = byte_get_little_endian (cu_list + i * 8 + 8, 8);

      printf (_("[%3u] 0x%lx - 0x%lx\n"), i / 2,
	      (unsigned long) cu_offset,
	      (unsigned long) (cu_offset + cu_length - 1));
    }

  printf (_("\nTU table:\n"));
  for (i = 0; i < tu_list_elements; i += 3)
    {
      uint64_t tu_offset = byte_get_little_endian (tu_list + i * 8, 8);
      uint64_t type_offset = byte_get_little_endian (tu_list + i * 8 + 8, 8);
      uint64_t signature = byte_get_little_endian (tu_list + i * 8 + 16, 8);

      printf (_("[%3u] 0x%lx 0x%lx "), i / 3,
	      (unsigned long) tu_offset,
	      (unsigned long) type_offset);
      print_dwarf_vma (signature, 8);
      printf ("\n");
    }

  printf (_("\nAddress table:\n"));
  for (i = 0; i < address_table_size; i += 2 * 8 + 4)
    {
      uint64_t low = byte_get_little_endian (address_table + i, 8);
      uint64_t high = byte_get_little_endian (address_table + i + 8, 8);
      uint32_t cu_index = byte_get_little_endian (address_table + i + 16, 4);

      print_dwarf_vma (low, 8);
      print_dwarf_vma (high, 8);
      printf (_("%lu\n"), (unsigned long) cu_index);
    }

  printf (_("\nSymbol table:\n"));
  for (i = 0; i < symbol_table_slots; ++i)
    {
      uint32_t name_offset = byte_get_little_endian (symbol_table + i * 8, 4);
      uint32_t cu_vector_offset = byte_get_little_endian (symbol_table + i * 8 + 4, 4);
      uint32_t num_cus, cu;

      if (name_offset != 0
	  || cu_vector_offset != 0)
	{
	  unsigned int j;

	  printf ("[%3u] %s:", i, constant_pool + name_offset);
	  num_cus = byte_get_little_endian (constant_pool + cu_vector_offset, 4);
	  for (j = 0; j < num_cus; ++j)
	    {
	      cu = byte_get_little_endian (constant_pool + cu_vector_offset + 4 + j * 4, 4);
	      /* Convert to TU number if it's for a type unit.  */
	      if (cu >= cu_list_elements)
		printf (" T%lu", (unsigned long) (cu - cu_list_elements));
	      else
		printf (" %lu", (unsigned long) cu);
	    }
	  printf ("\n");
	}
    }

  return 1;
}

static int
d5026 22
a5109 2
      /* The special .gdb_index section.  */
      { "gdb_index", & do_gdb_index, 1 },
a5233 1
  do_gdb_index = 1;
a5272 2
  { { ".gdb_index",		"",			NULL, NULL, 0, 0 },
    display_gdb_index,			&do_gdb_index,		0 },
@


1.76
log
@	* dwarf.c (decode_location_expression): Fix data adjustment
	for DW_OP_GNU_implicit_pointer in v3+.
@
text
@d166 1
a166 1
static dwarf_vma
@


1.75
log
@	* dwarf.h (debug_info): Add offset_info and dwarf_version fields.
	* dwarf.c (decode_location_expression): Add offset_size and
	dwarf_version arguments.  Prefix DIE offset with 0x for
	DW_OP_call{2,4,_ref}.  Fix up DW_OP_call_ref operand size,
	complain if in frame info section.  Handle
	DW_OP_GNU_implicit_pointer.
	(read_and_display_attr_value, display_debug_loc,
	display_debug_frames): Adjust decode_location_expression callers.
	(process_debug_info): Save offset_size and dwarf_version values
	into debug_information array.

	* dwarf2.h (DW_OP_GNU_implicit_pointer): New.
@
text
@d1125 1
a1125 1
	      data += offset_size;
@


1.74
log
@binutils/
	* dwarf.c (regname): New declaration.
	(decode_location_expression): Print for registers also regname output.

binutils/testsuite/
	* binutils-all/objdump.W: Update DW_OP_reg5 expected output.

gas/testsuite/
	* gas/elf/dwarf2-1.d: Update DW_OP_reg5 expected output.
	* gas/elf/dwarf2-2.d: Likewise.
	* gas/i386/dw2-compress-1.d: Likewise.
@
text
@d715 2
d1023 1
a1023 1
	  printf ("DW_OP_call2: <%lx>", (long) byte_get (data, 2) + cu_offset);
d1029 1
a1029 1
	  printf ("DW_OP_call4: <%lx>", (long) byte_get (data, 4) + cu_offset);
d1035 18
a1052 2
	  printf ("DW_OP_call_ref: <%lx>", (long) byte_get (data, 4) + cu_offset);
	  data += 4;
d1104 24
d1677 2
d2070 2
d3454 2
d3463 2
d3556 2
d4829 2
a4830 2
		  decode_location_expression (start, eh_addr_size, ul, 0,
					      section);
d4846 1
a4846 1
		  decode_location_expression (start, eh_addr_size,
d4864 2
a4865 2
		  decode_location_expression (start, eh_addr_size, ul, 0,
					      section);
@


1.73
log
@	* dwarf.c (init_dwarf_regnames_i386, init_dwarf_regnames_x86_64): New.
	(init_dwarf_regnames): Use them.
	* dwarf.h: Declare them.
	* objdump.c (dump_dwarf): Use bfd_get_arch + bfd_get_mach to set up
	the regnames, rather than using elf_machine_code.
@
text
@d30 2
d941 2
a942 1
	  printf ("DW_OP_reg%d", op - DW_OP_reg0);
d977 2
a978 1
	  printf ("DW_OP_breg%d: %ld", op - DW_OP_breg0,
d984 1
a984 1
	  printf ("DW_OP_regx: %lu", read_leb128 (data, &bytes_read, 0));
d986 1
d996 1
a996 1
	  printf ("DW_OP_bregx: %lu %ld", uvalue,
@


1.72
log
@	* dwarf.c (process_debug_info): Don't subtract section address
	when calculating location of cu abbrev within section.
@
text
@d3964 7
d3994 7
d4007 1
a4007 2
      dwarf_regnames = dwarf_regnames_i386;
      dwarf_regnames_count = ARRAY_SIZE (dwarf_regnames_i386);
d4012 1
a4012 2
      dwarf_regnames = dwarf_regnames_x86_64;
      dwarf_regnames_count = ARRAY_SIZE (dwarf_regnames_x86_64);
@


1.71
log
@2010-08-03  Tristan Gingold  <gingold@@adacore.com>

	* dwarf.c (display_debug_lines): Mark file argument unused.
	Do not try to load .debug_info section.
@
text
@d2080 1
a2080 2
	   + compunit.cu_abbrev_offset
           - debug_displays [abbrev_sec].section.address,
@


1.70
log
@2010-05-24  Tristan Gingold  <gingold@@adacore.com>

	* readelf.c (usage): Add new trace sections for --debug-dump.
	(process_section_headers): Handle dump of trace sections.
	* objdump.c (usage): Add new trace sections for --dwarf.
	* dwarf.h (do_trace_info, do_trace_abbrevs): New variables.
	(do_trace_aranges): Ditto.
	(enum dwarf_section_display_enum): Add trace_info, trace_abbrev
	and trace_aranges literals.
	* dwarf.c (do_trace_info, do_trace_abbrevs): New variables.
	(do_trace_aranges): Ditto.
	(process_debug_info): Add abbrev_sec argument and replace
	abbrev with abbrev_sec.
	(load_debug_info): Adjust call of process_debug_info.
	(display_debug_info): Ditto.
	(display_trace_info): New function.
	(dwarf_select_sections_by_names): Add trace_info, trace_abbrevs
	and trace_aranges sections name.
	(dwarf_select_sections_all): Also select trace sections.
	(debug_displays): Reindent.  Add entries for the trace sections.
	* doc/binutils.texi (readelf): Document new --dwarf parameters.
	(objdump): Ditto.
@
text
@d3059 1
a3059 1
display_debug_lines (struct dwarf_section *section, void *file)
a3065 7
  if (load_debug_info (file) == 0)
    {
      warn (_("Unable to load/parse the .debug_info section, so cannot interpret the %s section.\n"),
            section->name);
      return 0;
    }

@


1.69
log
@Handle EM_L1OM.

2010-05-06  H.J. Lu  <hongjiu.lu@@intel.com>

	* dwarf.c (init_dwarf_regnames): Handle EM_L1OM.
	* readelf.c (get_elf_section_flags): Likewise.
	(process_section_headers): Likewise.
@
text
@d56 3
d1879 1
d1951 2
a1952 2
  load_debug_section (abbrev, file);
  if (debug_displays [abbrev].section.start == NULL)
d1955 1
a1955 1
	    debug_displays [abbrev].section.name);
d2073 1
a2073 1
      if (compunit.cu_abbrev_offset >= debug_displays [abbrev].section.size)
d2076 1
a2076 1
	      (unsigned long) debug_displays [abbrev].section.size);
d2079 5
a2083 4
	  ((unsigned char *) debug_displays [abbrev].section.start
	   + compunit.cu_abbrev_offset - debug_displays [abbrev].section.address,
	   (unsigned char *) debug_displays [abbrev].section.start
	   + debug_displays [abbrev].section.size);
d2234 1
a2234 1
      && process_debug_info (&debug_displays [info].section, file, 1, 0))
d3596 1
a3596 1
  return process_debug_info (section, file, 0, 0);
d3602 7
a3608 1
  return process_debug_info (section, file, 0, 1);
d5049 4
d5173 3
d5180 1
a5180 1
  { { ".debug_abbrev",		".zdebug_abbrev",	NULL,	NULL,	0,	0 },
d5182 1
a5182 1
  { { ".debug_aranges",		".zdebug_aranges",	NULL,	NULL,	0,	0 },
d5184 1
a5184 1
  { { ".debug_frame",		".zdebug_frame",	NULL,	NULL,	0,	0 },
d5186 1
a5186 1
  { { ".debug_info",		".zdebug_info",		NULL,	NULL,	0,	0 },
d5188 1
a5188 1
  { { ".debug_line",		".zdebug_line",		NULL,	NULL,	0,	0 },
d5190 1
a5190 1
  { { ".debug_pubnames",	".zdebug_pubnames",	NULL,	NULL,	0,	0 },
d5192 1
a5192 1
  { { ".eh_frame",		"",			NULL,	NULL,	0,	0 },
d5194 1
a5194 1
  { { ".debug_macinfo",		".zdebug_macinfo",	NULL,	NULL,	0,	0 },
d5196 1
a5196 1
  { { ".debug_str",		".zdebug_str",		NULL,	NULL,	0,	0 },
d5198 1
a5198 1
  { { ".debug_loc",		".zdebug_loc",		NULL,	NULL,	0,	0 },
d5200 1
a5200 1
  { { ".debug_pubtypes",	".zdebug_pubtypes",	NULL,	NULL,	0,	0 },
d5202 1
a5202 1
  { { ".debug_ranges",		".zdebug_ranges",	NULL,	NULL,	0,	0 },
d5204 1
a5204 1
  { { ".debug_static_func",	".zdebug_static_func",	NULL,	NULL,	0,	0 },
d5206 1
a5206 1
  { { ".debug_static_vars",	".zdebug_static_vars",	NULL,	NULL,	0,	0 },
d5208 1
a5208 1
  { { ".debug_types",		".zdebug_types",	NULL,	NULL,	0,	0 },
d5210 8
a5217 2
  { { ".debug_weaknames",	".zdebug_weaknames",	NULL,	NULL,	0,	0 },
    display_debug_not_supported,	NULL,			0 }
@


1.68
log
@        PR binutils/11419
        * dwarf.c (process_debug_info): Initialise the signature array.
@
text
@d3995 1
@


1.67
log
@bfd/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * aoutx.h (aout_link_input_bfd): Remove unused variable sym_count.
        * elf-eh-frame.c (_bfd_elf_eh_frame_section_offset): Remove unused
        variables htab and hdr_info and mark info parameter as unused.
        * elf.c (prep_headers): Remove unused variable i_phdrp.
        (_bfd_elf_write_object_contents): Remove unused variable i_ehdrp.
        * elf32-i386.c (elf_i386_relocate_section): Mark variabled warned
        as unused.
        * peXXigen.c (pe_print_reloc): Remove unused variable datasize.
        * verilog.c (verilog_write_section): Remove unused variable
        address.

binutils/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * dwarf.c (process_debug_info): Remove unused variable
        cu_abbrev_offset_ptr.
        (display_debug_lines_decoded): Remove unused variable prev_line.
        * elfedit.c (process_archive): Remove unused variable
        file_name_size.
        * ieee.c (ieee_start_compilation_unit): Remove unused variable
        nindx.
        (ieee_set_type): Remove unused variables info, targetindx and
        baseindx.
        * objdump.c (disassmble_byte): Remove unused variable done_dot.
        * rddbg.c (read_section_stabs_debugging_info): Remove unused
        variable other.
        * readelf.c (dump_section_as_strings): Remove unused variable
        addr.
        (process_archive): Remove unused variable file_name_size.
        * stabs.c (parse_stab_string): Mark desc parameter as unused.
        Remove unused variable lineno.
        (parse_stab_struct_type): Remove unused variable orig.
        (stab_demangle_type): Remove unused variables constp, volatilep
        and hold.

gas/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * as.c (create_obj_attrs_section): Remove unused variable addr.
        * listing.c (listing_listing): Remove unused variable message.
        * read.c: Remove unnecessary register type qualifiers.
        (s_mri): Only define/use old_flag variable if MRI_MODE_CHANGE is
        defined.

ld/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * ldlang.c (wild_sort): Remove unused variable section_name.

opcodes/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * i386-dis.c (print_insn): Remove unused variable op.
        (OP_sI): Remove unused variable mask.
@
text
@d1964 1
a1964 1
      unsigned char signature[8];
@


1.66
log
@bfd/
	* elf-eh-frame.c (_bfd_elf_parse_eh_frame): Handle CIE version 4
	provided that it has the expected address size and zero segment
	length.
binutils/
	* dwarf.c (struct Frame_Chunk): Add ptr_size and segment_size
	fields.
	(display_debug_frames): Handle CIE version 4.
@
text
@a1958 1
      unsigned char *cu_abbrev_offset_ptr;
a1989 1
      cu_abbrev_offset_ptr = hdrptr;
a2607 1
      unsigned int prev_line = 0;
a2796 1
          prev_line = state_machine_regs.line;
a3749 1
  unsigned char *section_end;
a3755 1
  section_end = start + bytes;
@


1.65
log
@include/
	* dwarf2.h (DWARF2_Internal_LineInfo): Add li_max_ops_per_insn
	field.
bfd/
	* dwarf2.c (struct line_head): Add maximum_ops_per_insn field.
	(struct line_info): Add op_index field, change end_sequence type to
	unsigned char.
	(new_line_sorts_after): For the same address compare op_index.
	(add_line_info): Add op_index argument, store it into the structure.
	(decode_line_info): Complain about unknown versions of .debug_line.
	Initialize maximum_ops_per_insn.  Add op_index state register and
	track it.
binutils/
	* dwarf.c (struct State_Machine_Registers): Add op_index field,
	change end_sequence type to unsigned char.
	(reset_state_machine): Clear op_index.
	(process_extended_line_op): For DW_LNE_set_address clear op_index.
	(display_debug_lines_raw): Initialize li_max_ops_per_insn.
	Track op_index state machine register and print it if
	li_max_ops_per_insn is != 1.
	(display_debug_lines_decoded): Likewise.
@
text
@d3909 2
d4119 1
d4134 1
a4134 1
      int encoded_ptr_size = eh_addr_size;
d4190 10
a4199 1
	  if (fc->augmentation[0] == 'z')
d4201 2
a4202 13
	      fc->code_factor = LEB ();
	      fc->data_factor = SLEB ();
	      if (version == 1)
		{
		  fc->ra = GET (1);
		}
	      else
		{
		  fc->ra = LEB ();
		}
	      augmentation_data_len = LEB ();
	      augmentation_data = start;
	      start += augmentation_data_len;
d4204 3
a4206 1
	  else if (strcmp (fc->augmentation, "eh") == 0)
d4208 1
a4208 11
	      start += eh_addr_size;
	      fc->code_factor = LEB ();
	      fc->data_factor = SLEB ();
	      if (version == 1)
		{
		  fc->ra = GET (1);
		}
	      else
		{
		  fc->ra = LEB ();
		}
d4212 8
a4219 10
	      fc->code_factor = LEB ();
	      fc->data_factor = SLEB ();
	      if (version == 1)
		{
		  fc->ra = GET (1);
		}
	      else
		{
		  fc->ra = LEB ();
		}
d4234 5
d4285 1
d4307 2
d4318 3
d4333 6
d4353 1
a4353 1
	  printf ("\n%08lx %08lx %08lx FDE cie=%08lx pc=%08lx..%08lx\n",
d4355 4
a4358 2
		  (unsigned long)(cie->chunk_start - section_start),
		  fc->pc_begin, fc->pc_begin + fc->pc_range);
d4906 1
@


1.64
log
@	* dwarf.c (read_and_display_attr_value): Don't reject
	dwarf_version == 4.  Handle DW_FORM_sec_offset, DW_FORM_flag_present
	and DW_FORM_exprloc.
	(process_debug_info): Handle cu_version == 4.
	(display_debug_lines_raw, display_debug_lines_decoded): Handle
	li_version == 4.
@
text
@d267 2
a268 1
  int end_sequence;
d280 1
d327 1
d2303 12
d2333 2
d2418 21
a2438 4
	      uladv = (op_code / linfo.li_line_range) * linfo.li_min_insn_length;
	      state_machine_regs.address += uladv;
	      printf (_("  Special opcode %d: advance Address by %lu to 0x%lx"),
		      op_code, uladv, state_machine_regs.address);
a2455 1
	      uladv *= linfo.li_min_insn_length;
d2457 20
a2476 3
	      state_machine_regs.address += uladv;
	      printf (_("  Advance PC by %lu to 0x%lx\n"), uladv,
		      state_machine_regs.address);
d2515 21
a2535 5
	      uladv = (((255 - linfo.li_opcode_base) / linfo.li_line_range)
		      * linfo.li_min_insn_length);
	      state_machine_regs.address += uladv;
	      printf (_("  Advance PC by constant %lu to 0x%lx\n"), uladv,
		      state_machine_regs.address);
d2542 1
d2658 12
d2805 16
a2820 2
              uladv = (op_code / linfo.li_line_range) * linfo.li_min_insn_length;
              state_machine_regs.address += uladv;
d2853 1
a2881 1
              uladv *= linfo.li_min_insn_length;
d2883 15
a2897 1
              state_machine_regs.address += uladv;
d2942 16
a2957 3
              uladv = (((255 - linfo.li_opcode_base) / linfo.li_line_range)
                       * linfo.li_min_insn_length);
              state_machine_regs.address += uladv;
d2964 1
d3018 9
a3026 2
                  printf (_("%-35s  %11d  %#18lx\n"), newFileName,
                          state_machine_regs.line, state_machine_regs.address);
d3030 9
a3038 2
                  printf (_("%s  %11d  %#18lx\n"), newFileName,
                          state_machine_regs.line, state_machine_regs.address);
@


1.63
log
@	* NEWS: Document .ARM.exidx / .ARM.extab support.

	* dwarf.c (read_leb128): Make non-static.
	* dwarf.h (read_leb128): Declare.
	* readelf.c (REMOVE_ARCH_BITS): Define.
	(find_section_by_address): New.
	(read_uleb128): Move higher.  Use read_leb128 from dwarf.c.
	(find_symbol_for_address): Handle the Thumb bit for ARM, by
	using REMOVE_ARCH_BITS.
	(struct arm_section, struct arm_unw_aux_info, arm_print_vma_and_name)
	(arm_free_section, arm_section_get_word, decode_arm_unwind)
	(dump_arm_unwind, arm_process_unwind): New.
	(process_unwind): Handle ARM.
@
text
@d2 1
a2 1
   Copyright 2005, 2006, 2007, 2008, 2009
d1157 1
a1157 1
      else if (dwarf_version == 3)
d1164 1
a1164 1
	  error (_("Internal error: DWARF version is not 2 or 3.\n"));
d1174 1
d1179 4
d1241 1
d1246 1
d1282 1
d1363 3
a1365 1
    	  if (form == DW_FORM_data4 || form == DW_FORM_data8)
d1394 3
a1396 1
	  if (form == DW_FORM_data4 || form == DW_FORM_data8)
d1606 3
a1608 1
      if (form == DW_FORM_data4 || form == DW_FORM_data8)
d2055 3
a2057 1
      if (compunit.cu_version != 2 && compunit.cu_version != 3)
d2288 3
a2290 1
      if (linfo.li_version != 2 && linfo.li_version != 3)
d2292 1
a2292 1
	  warn (_("Only DWARF version 2 and 3 line info is currently supported.\n"));
d2578 3
a2580 1
      if (linfo.li_version != 2 && linfo.li_version != 3)
d2582 1
a2582 1
          warn (_("Only DWARF version 2 and 3 line info is currently "
@


1.62
log
@* dwarf.c (display_debug_frames): Skip the 'S' character in CFI
'z' augmentation strings.
@
text
@d230 1
a230 1
static unsigned long int
@


1.61
log
@2010-01-14  Tristan Gingold  <gingold@@adacore.com>

	* dwarf.c (get_AT_name): Handle DW_AT_use_GNAT_descriptive_type
	and DW_AT_GNAT_descriptive_type.
@
text
@d4117 2
@


1.60
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d1805 2
@


1.59
log
@	* dwarf.c (dwarf_select_sections_by_names): Handle pubtypes correctly.
	(debug_displays): Remove duplicate entry for debug_pubtypes.
@
text
@d441 1
a441 1
  abbrev_entry *abbrev;
d443 1
a443 1
  for (abbrev = first_abbrev; abbrev;)
d445 1
a445 1
      abbrev_entry *next = abbrev->next;
d448 1
a448 1
      for (attr = abbrev->first_attr; attr;)
d450 1
a450 1
	  abbrev_attr *next = attr->next;
d453 1
a453 1
	  attr = next;
d456 2
a457 2
      free (abbrev);
      abbrev = next;
d1358 1
a1358 1
	      unsigned int max = debug_info_p->max_loc_offsets;
d1361 1
a1361 1
	      if (max == 0 || num >= max)
d1363 1
a1363 1
		  max += 1024;
d1366 1
a1366 1
				 max, sizeof (*debug_info_p->loc_offsets));
d1369 2
a1370 2
				 max, sizeof (*debug_info_p->have_frame_base));
		  debug_info_p->max_loc_offsets = max;
d1387 1
a1387 1
	      unsigned int max = debug_info_p->max_range_lists;
d1390 1
a1390 1
	      if (max == 0 || num >= max)
d1392 1
a1392 1
		  max += 1024;
d1395 2
a1396 2
				 max, sizeof (*debug_info_p->range_lists));
		  debug_info_p->max_range_lists = max;
d2229 1
a2229 1
      DWARF2_Internal_LineInfo info;
d2242 1
a2242 1
      info.li_length = byte_get (hdrptr, 4);
d2245 1
a2245 1
      if (info.li_length == 0xffffffff)
d2248 1
a2248 1
	  info.li_length = byte_get (hdrptr, 8);
d2259 1
a2259 1
      if (info.li_length + initial_length_size > section->size)
d2268 1
a2268 1
      info.li_version = byte_get (hdrptr, 2);
d2270 1
a2270 1
      if (info.li_version != 2 && info.li_version != 3)
d2276 1
a2276 1
      info.li_prologue_length = byte_get (hdrptr, offset_size);
d2278 1
a2278 1
      info.li_min_insn_length = byte_get (hdrptr, 1);
d2280 1
a2280 1
      info.li_default_is_stmt = byte_get (hdrptr, 1);
d2282 1
a2282 1
      info.li_line_base = byte_get (hdrptr, 1);
d2284 1
a2284 1
      info.li_line_range = byte_get (hdrptr, 1);
d2286 1
a2286 1
      info.li_opcode_base = byte_get (hdrptr, 1);
d2290 2
a2291 2
      info.li_line_base <<= 24;
      info.li_line_base >>= 24;
d2294 8
a2301 8
      printf (_("  Length:                      %ld\n"), info.li_length);
      printf (_("  DWARF Version:               %d\n"), info.li_version);
      printf (_("  Prologue Length:             %d\n"), info.li_prologue_length);
      printf (_("  Minimum Instruction Length:  %d\n"), info.li_min_insn_length);
      printf (_("  Initial value of 'is_stmt':  %d\n"), info.li_default_is_stmt);
      printf (_("  Line Base:                   %d\n"), info.li_line_base);
      printf (_("  Line Range:                  %d\n"), info.li_line_range);
      printf (_("  Opcode Base:                 %d\n"), info.li_opcode_base);
d2303 1
a2303 1
      end_of_sequence = data + info.li_length + initial_length_size;
d2305 1
a2305 1
      reset_state_machine (info.li_default_is_stmt);
d2312 1
a2312 1
      for (i = 1; i < info.li_opcode_base; i++)
d2316 1
a2316 1
      data = standard_opcodes + info.li_opcode_base - 1;
d2378 1
a2378 1
	  if (op_code >= info.li_opcode_base)
d2380 2
a2381 2
	      op_code -= info.li_opcode_base;
	      uladv = (op_code / info.li_line_range) * info.li_min_insn_length;
d2385 1
a2385 1
	      adv = (op_code % info.li_line_range) + info.li_line_base;
d2393 1
a2393 1
	      data += process_extended_line_op (data, info.li_default_is_stmt);
d2402 1
a2402 1
	      uladv *= info.li_min_insn_length;
d2445 2
a2446 2
	      uladv = (((255 - info.li_opcode_base) / info.li_line_range)
		      * info.li_min_insn_length);
d2514 1
a2514 1
      DWARF2_Internal_LineInfo info;
d2531 1
a2531 1
      info.li_length = byte_get (hdrptr, 4);
d2534 1
a2534 1
      if (info.li_length == 0xffffffff)
d2537 1
a2537 1
          info.li_length = byte_get (hdrptr, 8);
d2548 1
a2548 1
      if (info.li_length + initial_length_size > section->size)
d2556 1
a2556 1
      info.li_version = byte_get (hdrptr, 2);
d2558 1
a2558 1
      if (info.li_version != 2 && info.li_version != 3)
d2565 1
a2565 1
      info.li_prologue_length = byte_get (hdrptr, offset_size);
d2567 1
a2567 1
      info.li_min_insn_length = byte_get (hdrptr, 1);
d2569 1
a2569 1
      info.li_default_is_stmt = byte_get (hdrptr, 1);
d2571 1
a2571 1
      info.li_line_base = byte_get (hdrptr, 1);
d2573 1
a2573 1
      info.li_line_range = byte_get (hdrptr, 1);
d2575 1
a2575 1
      info.li_opcode_base = byte_get (hdrptr, 1);
d2579 2
a2580 2
      info.li_line_base <<= 24;
      info.li_line_base >>= 24;
d2583 1
a2583 1
      end_of_sequence = data + info.li_length + initial_length_size;
d2585 1
a2585 1
      reset_state_machine (info.li_default_is_stmt);
d2591 1
a2591 1
      data = standard_opcodes + info.li_opcode_base - 1;
a2595 1
          int i;
a2622 1
          int i;
d2701 1
a2701 1
          if (op_code >= info.li_opcode_base)
d2703 2
a2704 2
	      op_code -= info.li_opcode_base;
              uladv = (op_code / info.li_line_range) * info.li_min_insn_length;
d2707 1
a2707 1
              adv = (op_code % info.li_line_range) + info.li_line_base;
a2715 1
                unsigned int bytes_read;
d2733 1
a2733 1
                    reset_state_machine (info.li_default_is_stmt);
d2766 1
a2766 1
              uladv *= info.li_min_insn_length;
d2813 2
a2814 2
              uladv = (((255 - info.li_opcode_base) / info.li_line_range)
                       * info.li_min_insn_length);
d2949 1
a2949 1
  DWARF2_Internal_PubNames pubnames;
d2967 1
a2967 1
      pubnames.pn_length = byte_get (data, 4);
d2969 1
a2969 1
      if (pubnames.pn_length == 0xffffffff)
d2971 1
a2971 1
	  pubnames.pn_length = byte_get (data, 8);
d2982 1
a2982 1
      pubnames.pn_version = byte_get (data, 2);
d2985 1
a2985 1
      pubnames.pn_offset = byte_get (data, offset_size);
d2990 1
a2990 1
	  && find_debug_info_for_offset (pubnames.pn_offset) == NULL)
d2992 1
a2992 1
	      pubnames.pn_offset, section->name);
d2994 1
a2994 1
      pubnames.pn_size = byte_get (data, offset_size);
d2997 1
a2997 1
      start += pubnames.pn_length + initial_length_size;
d2999 1
a2999 1
      if (pubnames.pn_version != 2 && pubnames.pn_version != 3)
d3013 1
a3013 1
	      pubnames.pn_length);
d3015 1
a3015 1
	      pubnames.pn_version);
d3017 1
a3017 1
	      pubnames.pn_offset);
d3019 1
a3019 1
	      pubnames.pn_size);
d3464 1
a3464 1
      unsigned char *ranges;
d3536 1
a3536 1
      ranges = hdrptr;
d3541 1
a3541 1
	ranges += (2 * address_size) - excess;
d3545 1
a3545 1
      while (ranges + 2 * address_size <= start)
d3547 1
a3547 1
	  address = byte_get (ranges, address_size);
d3549 1
a3549 1
	  ranges += address_size;
d3551 1
a3551 1
	  length  = byte_get (ranges, address_size);
d3553 1
a3553 1
	  ranges += address_size;
d3880 1
a3880 1
      static const char *loc = "   LOC";
d3884 1
a3884 1
      printf ("%-*s CFA      ", eh_addr_size * 2, loc);
d4218 1
a4218 1
	      unsigned long reg, tmp;
d4289 2
a4290 2
		  tmp = LEB ();
		  start += tmp;
d4295 2
a4296 2
		  tmp = LEB ();
		  start += tmp;
d4918 1
a4918 1
  unsigned int index = 0;
d4920 2
a4921 2
  while (letters[index])
    switch (letters[index++])
@


1.58
log
@        PR binutils/11045
        * dwarf.c (do_debug_pubtypes): New variable.
        (dwarf_select_sections_by_names): Handle .debug_pubtypes.
        (dwarf_select_sections_by_letters): Add 't' for .debug_pubtype.
        (dwarf_select_sections_all): Set do_debug_pubtypes.
        (debug_displays): Add support for .debug_pubtypes.
        * dwarf.h (do_debug_pubtypes): Export.
        * objdump.c (usage): Add -wt or --dwarf=pubtypes.
        * readelf.c (usage): Likewise.
        (process_section_headers): Enable debug display if
        do_debug_pubtypes is set.
        * doc/binutils.texi: Document -wt/--dwarf=pubtypes option.
@
text
@d4871 1
a4871 1
      { "pubtypes", & do_debug_pubnames, 1 },
a5011 2
  { { ".debug_pubtypes",	".zdebug_pubtypes",	NULL,	NULL,	0,	0 },
    display_debug_pubnames,		&do_debug_pubtypes,	0 },
@


1.57
log
@include/

	* dwarf2.h (DW_TAG_rvalue_reference_type, DW_TAG_template_alias):
	New tags.
	(DW_FORM_ref_sig8): New name for DW_FORM_sig8.
	(DW_AT_main_subprogram, DW_AT_data_bit_offset, DW_AT_const_expr,
	DW_AT_enum_class, DW_AT_linkage_name, DW_AT_GNU_guarded_by,
	DW_AT_GNU_pt_guarded_by, DW_AT_GNU_guarded, DW_AT_GNU_pt_guarded,
	DW_AT_GNU_locks_excluded, DW_AT_GNU_exclusive_locks_required,
	DW_AT_GNU_shared_locks_required, DW_AT_GNU_odr_signature): New
	attributes.
	(DW_LANG_Python): New language.

binutils/

	* dwarf.c (get_TAG_name): Add missing DWARF-3 and new DWARF-4 tags.
	(get_FORM_name): Add new DWARF-4 forms.
	(read_and_display_attr_value): Add DW_FORM_ref_sig8, DW_LANG_Python.
	(get_AT_name): Add new DWARF-4 and GNU-specific attributes.
	(process_debug_info): Add do_types parameter; change all callers.
	Add support for .debug_types sections.
	(display_debug_types): New function.
	(debug_displays): Add .debug_types section.
	* readelf.c (process_section_headers): Add .debug_types section.
	(display_debug_section): Simplify call to streq.
@
text
@d48 1
d4852 1
a4852 1
    int val;
d4871 1
d4946 4
d4989 1
d5012 2
d5023 1
a5023 1
    display_debug_pubnames,		&do_debug_pubnames,	0 },
@


1.56
log
@        Updated soruces in binutils/* to compile cleanly with -Wc++-compat.

        * binutils/addr2line.c (slurp_symtab): Fix casts. Introduce
        variable minisyms to avoid aliasing varning.
        * binutils/ar.c: Add casts. (normalize): Use name del instead of
        delete. (display_target_list,display_info_table): Change loop
        counter variable a to int.
        * binutils/bucomm.c: Add casts.
        * binutils/debug.c: Update function to use new names. (struct
        debug_baseclass): Rename member from virtual to
        is_virtual. (struct debug_type_s,struct debug_field_s,struct
        debug_baseclass_s,struct debug_method_s,struct
        debug_method_variant_s,struct debug_type_s): Rename struct from
        avoid name collision.
        * /binutils/debug.h: Use new struct names.
        * binutils/dwarf.c: Add casts. (free_debug_memory): Change loop
        counter variable a to int.
        * binutils/ieee.c: Add casts. (enum ieee_var_kind): Move to top
        level. (ieee_class_baseclass): Rename parameter virtual to
        is_virtual. (ieee_class_method_var): Rename variable virtual to
        is_virtual.
        * binutils/nm.c: Add casts.
        * binutils/objcopy.c: Add casts. (copy_archive): Rename variable
        delete to del.
        * binutils/objdump.c: Add casts. (dump_dwarf_section): Change loop
        counter variable i to int.
        * binutils/prdbg.c: Add
        casts. (pr_class_baseclass,tg_class_baseclass): Rename parameters
        virtual to is_virtual.
        * binutils/readelf.c: Add casts. (struct
        ia64_unw_table_entry,struct hppa_unw_table_entry): Move to top
        level.
        * binutils/size.c: Add casts.
        * binutils/stabs.c (parse_stab_type, parse_stab_range_type)
        (parse_stab_cpp_abbrev): Rename parameter from typename to
        type_name. (parse_stab_baseclasses): Rename variable virtual to
        is_virtual.
        * binutils/strings.c: Add casts.
        * binutils/wrstabs.c (stab_class_baseclass): Rename parameter
        virtual to is_virtual.
@
text
@d631 6
d677 5
d1319 15
d1461 2
d1619 3
d1750 7
d1789 15
a1803 7
    case DW_AT_sf_names:		return "DW_AT_sf_names";
    case DW_AT_src_info:		return "DW_AT_src_info";
    case DW_AT_mac_info:		return "DW_AT_mac_info";
    case DW_AT_src_coords:		return "DW_AT_src_coords";
    case DW_AT_body_begin:		return "DW_AT_body_begin";
    case DW_AT_body_end:		return "DW_AT_body_end";
    case DW_AT_GNU_vector:		return "DW_AT_GNU_vector";
d1850 2
a1851 1
   anything to the user.  */
d1856 2
a1857 1
		    int do_loc)
d1866 2
a1867 1
      && num_debug_info_entries == 0)
d1945 2
d1977 15
d1993 2
a1994 1
	  && num_debug_info_entries == 0)
d2017 9
d2173 2
a2174 1
      && num_debug_info_entries == 0)
d2209 1
a2209 1
      && process_debug_info (&debug_displays [info].section, file, 1))
d3440 1
a3440 1
  return process_debug_info (section, file, 0);
d3443 5
d5022 1
a5022 1
    display_debug_not_supported,	NULL,			0 },
@


1.55
log
@	* dwarf.c (byte_get_little_endian): Handle size of 3.
	(byte_get_big_endian): Likewise.
	* readelf.c (byte_put_little_endian): Likewise.
	(byte_put_big_endian): Likewise.
	(is_24bit_abs_reloc): New function.
	(is_none_reloc): Formatting.
	(apply_relocations): Use is_24bit_abs_reloc.  Handle pj and xtensa
	reloc peculiarity.
@
text
@d467 1
a467 1
  entry = malloc (sizeof (*entry));
d493 1
a493 1
  attr = malloc (sizeof (*attr));
d1337 2
a1338 2
		  debug_info_p->loc_offsets
		    = xcrealloc (debug_info_p->loc_offsets,
d1340 2
a1341 2
		  debug_info_p->have_frame_base
		    = xcrealloc (debug_info_p->have_frame_base,
d1366 2
a1367 2
		  debug_info_p->range_lists
		    = xcrealloc (debug_info_p->range_lists,
d1861 2
a1862 2
      debug_information = cmalloc (num_units,
				   sizeof (* debug_information));
d2527 2
a2528 1
          directory_table = xmalloc (n_directories * sizeof (unsigned char *));
d2566 1
a2566 1
          file_table = xmalloc (n_files * sizeof (File_Entry));
d2786 1
a2786 1
                  newFileName = xmalloc (MAX_FILENAME_LENGTH + 1);
d2794 1
a2794 1
                  newFileName = xmalloc (fileNameLength + 1);
d2983 1
a2983 1
      op = *curr;
d3504 2
a3505 2
  const struct range_entry *a_re = ap;
  const struct range_entry *b_re = bp;
d3546 2
a3547 1
  range_entries = xmalloc (sizeof (*range_entries) * num_range_list);
d3698 3
a3700 2
  fc->col_type = xcrealloc (fc->col_type, fc->ncols, sizeof (short int));
  fc->col_offset = xcrealloc (fc->col_offset, fc->ncols, sizeof (int));
d3934 1
a3934 1
	  fc = xmalloc (sizeof (Frame_Chunk));
d3941 2
a3942 2
	  fc->col_type = xmalloc (sizeof (short int));
	  fc->col_offset = xmalloc (sizeof (int));
d4065 2
a4066 2
	      fc->col_type = xmalloc (sizeof (short int));
	      fc->col_offset = xmalloc (sizeof (int));
d4075 2
a4076 2
	      fc->col_type = xcmalloc (fc->ncols, sizeof (short int));
	      fc->col_offset = xcmalloc (fc->ncols, sizeof (int));
d4450 1
a4450 1
	      rs = xmalloc (sizeof (Frame_Chunk));
d4452 3
a4454 2
	      rs->col_type = xcmalloc (rs->ncols, sizeof (short int));
	      rs->col_offset = xcmalloc (rs->ncols, sizeof (int));
d4733 1
a4733 1
  enum dwarf_section_display_enum i;
d4738 1
a4738 1
    free_debug_section (i);
@


1.54
log
@binutils/
	* dwarf.c (process_debug_info): Support section padding abbrev codes.

binutils/testsuite/
	* binutils-all/testranges.s (.debug_info): Pad the only CU.
@
text
@d75 5
d122 5
@


1.53
log
@update copyright dates
@
text
@d1988 2
a1989 1
	  /* A null DIE marks the end of a list of siblings.  */
d1992 12
@


1.53.2.1
log
@	* dwarf.c (byte_get_little_endian): Handle size of 3.
	(byte_get_big_endian): Likewise.
	* readelf.c (byte_put_little_endian): Likewise.
	(byte_put_big_endian): Likewise.
	(is_24bit_abs_reloc): New function.
	(is_none_reloc): Formatting.
	(apply_relocations): Use is_24bit_abs_reloc.  Handle pj and xtensa
	reloc peculiarity.

	2009-09-07  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	* readelf.c (is_none_reloc <EM_XTENSA_OLD>, is_none_reloc <EM_XTENSA>):
	New.

	2009-09-07  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	* dwarf.c (process_debug_info): Support section padding abbrev codes.
@
text
@a74 5
    case 3:
      return  ((unsigned long) (field[0]))
	|    (((unsigned long) (field[1])) << 8)
	|    (((unsigned long) (field[2])) << 16);

a116 5
    case 3:
      return ((unsigned long) (field[2]))
	|   (((unsigned long) (field[1])) << 8)
	|   (((unsigned long) (field[0])) << 16);

d1988 1
a1988 2
	  /* A null DIE marks the end of a list of siblings or it may also be
	     a section padding.  */
a1990 12
	      /* Check if it can be a section padding for the last CU.  */
	      if (level == 0 && start == end)
		{
		  unsigned char *chk;

		  for (chk = tags; chk < start; chk++)
		    if (*chk != 0)
		      break;
		  if (chk == start)
		    break;
		}

@


1.53.2.2
log
@        Update soruces to compile cleanly with -Wc++-compat:

        * addr2line.c (slurp_symtab): Fix casts. Introduce variable
        minisyms to avoid aliasing varning.
        * ar.c: Add casts.
        (normalize): Use name del instead of delete.
        (display_target_list,display_info_table): Change loop counter
        variable a to int.
        * bucomm.c: Add casts.
        * debug.c: Update function to use new names.
        (struct debug_baseclass): Rename member from virtual to
        is_virtual.
        (struct debug_type_s, struct debug_field_s, struct
        debug_baseclass_s, struct debug_method_s, struct
        debug_method_variant_s, struct debug_type_s): Rename struct from
        avoid name collision.
        * debug.h: Use new struct names.
        * dwarf.c: Add casts.
        (free_debug_memory): Change loop counter variable a to int.
        * ieee.c: Add casts.
        (enum ieee_var_kind): Move to top level.
        (ieee_class_baseclass): Rename parameter virtual to is_virtual.
        (ieee_class_method_var): Rename variable virtual to is_virtual.
        * nm.c: Add casts.
        * objcopy.c: Add casts.
        (copy_archive): Rename variable delete to del.
        * objdump.c: Add casts.
        (dump_dwarf_section): Change loop counter variable i to int.
        * prdbg.c: Add casts.
        (pr_class_baseclass,tg_class_baseclass): Rename parameters virtual
        to is_virtual.
        * readelf.c: Add casts.
        (struct ia64_unw_table_entry,struct hppa_unw_table_entry): Move to
        top level.
        * size.c: Add casts.
        * stabs.c (parse_stab_type, parse_stab_range_type,
        (parse_stab_cpp_abbrev): Rename parameter from typename to
        type_name.
        (parse_stab_baseclasses): Rename variable virtual to is_virtual.
        * strings.c: Add casts.
        * wrstabs.c (stab_class_baseclass): Rename parameter virtual to
        is_virtual.
@
text
@d467 1
a467 1
  entry = (abbrev_entry *) malloc (sizeof (*entry));
d493 1
a493 1
  attr = (abbrev_attr *) malloc (sizeof (*attr));
d1337 2
a1338 2
		  debug_info_p->loc_offsets = (long unsigned int *)
                      xcrealloc (debug_info_p->loc_offsets,
d1340 2
a1341 2
		  debug_info_p->have_frame_base = (int *)
                      xcrealloc (debug_info_p->have_frame_base,
d1366 2
a1367 2
		  debug_info_p->range_lists = (long unsigned int *)
                      xcrealloc (debug_info_p->range_lists,
d1861 2
a1862 2
      debug_information = (debug_info *) cmalloc (num_units,
                                                  sizeof (* debug_information));
d2527 1
a2527 2
          directory_table = (unsigned char **)
              xmalloc (n_directories * sizeof (unsigned char *));
d2565 1
a2565 1
          file_table = (File_Entry *) xmalloc (n_files * sizeof (File_Entry));
d2785 1
a2785 1
                  newFileName = (char *) xmalloc (MAX_FILENAME_LENGTH + 1);
d2793 1
a2793 1
                  newFileName = (char *) xmalloc (fileNameLength + 1);
d2982 1
a2982 1
      op = (enum dwarf_macinfo_record_type) *curr;
d3503 2
a3504 2
  const struct range_entry *a_re = (const struct range_entry *) ap;
  const struct range_entry *b_re = (const struct range_entry *) bp;
d3545 1
a3545 2
  range_entries = (struct range_entry *)
      xmalloc (sizeof (*range_entries) * num_range_list);
d3696 2
a3697 3
  fc->col_type = (short int *) xcrealloc (fc->col_type, fc->ncols,
                                          sizeof (short int));
  fc->col_offset = (int *) xcrealloc (fc->col_offset, fc->ncols, sizeof (int));
d3931 1
a3931 1
	  fc = (Frame_Chunk *) xmalloc (sizeof (Frame_Chunk));
d3938 2
a3939 2
	  fc->col_type = (short int *) xmalloc (sizeof (short int));
	  fc->col_offset = (int *) xmalloc (sizeof (int));
d4062 2
a4063 2
	      fc->col_type = (short int *) xmalloc (sizeof (short int));
	      fc->col_offset = (int *) xmalloc (sizeof (int));
d4072 2
a4073 2
	      fc->col_type = (short int *) xcmalloc (fc->ncols, sizeof (short int));
	      fc->col_offset =  (int *) xcmalloc (fc->ncols, sizeof (int));
d4447 1
a4447 1
	      rs = (Frame_Chunk *) xmalloc (sizeof (Frame_Chunk));
d4449 2
a4450 3
	      rs->col_type = (short int *) xcmalloc (rs->ncols,
                                                     sizeof (short int));
	      rs->col_offset = (int *) xcmalloc (rs->ncols, sizeof (int));
d4729 1
a4729 1
  unsigned int i;
d4734 1
a4734 1
    free_debug_section ((enum dwarf_section_display_enum) i);
@


1.52
log
@        * dwarf.c (display_debug_lines): If do_debug_lines has not been
        set then default to displaying raw .debug_line section contents.
@
text
@d2 1
a2 1
   Copyright 2005, 2006, 2007, 2008
@


1.51
log
@binutils/
	Support unordered .debug_info references to .debug_ranges.
	* dwarf.c (struct range_entry, range_entry_compar): New.
	(display_debug_ranges): Remove variables last_offset, first, j,
	seen_first_offset, use_debug_info and next.  New variables
	range_entries and range_entry_fill.  Create the sorted copy
	range_entries.  Remove the FIXME error on detected unordered references.
	* dwarf.h (debug_info <range_lists>): New comment.

binutils/testsuite/
	* binutils-all/objcopy.exp (testranges): New test.
	* binutils-all/testranges.d, binutils-all/testranges.s: New files.
@
text
@d2816 3
@


1.50
log
@bfd
	* Makefile.am (dwarf2.lo): Use dwarf2.h, not elf/dwarf2.h.
	(elf-eh-frame.lo): Likewise.
	(elf32-bfin.lo): Likewise.
	(elf32-frv.lo): Likewise.
	(elf32-xc16x.lo): Likewise.
	* Makefile.in: Rebuild.
	* dwarf2.c: Included dwarf.h, not elf/dwarf2.h.
	* elf-eh-frame.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-xc16x.c: Likewise.
binutils
	* Makefile.am (dwarf.o): Refer to dwarf2.h, not elf/dwarf2.h.
	* Makefile.in: Rebuild.
	* dwarf.c: Include dwarf2.h, not elf/dwarf2.h.
gas
	* Makefile.am (DEPTC_alpha_ecoff): Refer to dwarf2.h, not
	elf/dwarf2.h.
	(DEPTC_alpha_elf): Likewise.
	(DEPTC_alpha_evax): Likewise.
	(DEPTC_arm_elf): Likewise.
	(DEPTC_hppa_elf): Likewise.
	(DEPTC_i386_aout): Likewise.
	(DEPTC_i386_coff): Likewise.
	(DEPTC_i386_elf): Likewise.
	(DEPTC_m68k_aout): Likewise.
	(DEPTC_m68k_coff): Likewise.
	(DEPTC_m68k_elf): Likewise.
	(DEPTC_mips_coff): Likewise.
	(DEPTC_mips_ecoff): Likewise.
	(DEPTC_mips_elf): Likewise.
	(DEPTC_ppc_coff): Likewise.
	(DEPTC_ppc_elf): Likewise.
	(DEPTC_s390_elf): Likewise.
	(DEPTC_sh_coff): Likewise.
	(DEPTC_sh_elf): Likewise.
	(DEPTC_sh64_elf): Likewise.
	(DEPTC_sparc_aout): Likewise.
	(DEPTC_sparc_coff): Likewise.
	(DEPTC_sparc_elf): Likewise.
	(as.o): Likewise.
	(dwarf2dbg.o): Likewise.
	(dw2gencfi.o): Likewise.
	(ehopt.o): Likewise.
	(read.o): Likewise.
	* Makefile.in: Rebuild.
	* dw2gencfi.h: Include dwarf2.h, not elf/dwarf2.h.
	* dwarf2dbg.c: Likewise.
	* ehopt.c: Likewise.
gdb
	* dwarf2-frame.c: Include dwarf2.h, not elf/dwarf2.h.
	* dwarf2expr.c: Likewise.
	* dwarf2loc.c: Likewise.
	* dwarf2read.c: Likewise.
	* sh-tdep.c: Likewise.
	* xtensa-tdep.c: Likewise.
include
	* dwarf2.h: New file, moved from elf/.
include/elf

	* dwarf2.h: Move to `..'.
@
text
@d3460 25
d3493 2
a3494 8
  unsigned int num_range_list = 0;
  unsigned long last_offset = 0;
  unsigned int first = 0;
  unsigned int i;
  unsigned int j;
  int seen_first_offset = 0;
  int use_debug_info = 1;
  unsigned char *next;
d3512 10
a3521 3
  /* Check the order of range list in .debug_info section. If
     offsets of range lists are in the ascending order, we can
     use `debug_information' directly.  */
d3524 2
a3525 4
      unsigned int num;

      num = debug_information [i].num_range_lists;
      num_range_list += num;
d3527 1
a3527 2
      /* Check if we can use `debug_information' directly.  */
      if (use_debug_info && num != 0)
d3529 3
a3531 21
	  if (!seen_first_offset)
	    {
	      /* This is the first range list.  */
	      last_offset = debug_information [i].range_lists [0];
	      first = i;
	      seen_first_offset = 1;
	      j = 1;
	    }
	  else
	    j = 0;

	  for (; j < num; j++)
	    {
	      if (last_offset >
		  debug_information [i].range_lists [j])
		{
		  use_debug_info = 0;
		  break;
		}
	      last_offset = debug_information [i].range_lists [j];
	    }
d3535 2
a3536 6
  if (!use_debug_info)
    /* FIXME: Should we handle this case?  */
    error (_("Range lists in .debug_info section aren't in ascending order!\n"));

  if (!seen_first_offset)
    error (_("No range lists in .debug_info section!\n"));
d3539 1
a3539 2
  if (debug_information [first].num_range_lists > 0
      && debug_information [first].range_lists [0] != section->address)
d3541 1
a3541 1
	  section->name, debug_information [first].range_lists [0]);
d3546 1
a3546 2
  seen_first_offset = 0;
  for (i = first; i < num_debug_info_entries; i++)
d3548 3
a3550 2
      dwarf_vma begin;
      dwarf_vma end;
d3552 1
a3552 1
      unsigned int pointer_size;
d3555 1
a3555 1
      pointer_size = debug_information [i].pointer_size;
d3557 6
a3562 1
      for (j = 0; j < debug_information [i].num_range_lists; j++)
d3564 10
a3573 4
	  /* DWARF sections under Mach-O have non-zero addresses.  */
	  offset = debug_information [i].range_lists [j] - section->address;
	  next = section_begin + offset;
	  base_address = debug_information [i].base_address;
d3575 18
a3592 3
	  if (!seen_first_offset)
	    seen_first_offset = 1;
	  else
d3594 2
a3595 8
	      if (start < next)
		warn (_("There is a hole [0x%lx - 0x%lx] in %s section.\n"),
		      (unsigned long) (start - section_begin),
		      (unsigned long) (next - section_begin), section->name);
	      else if (start > next)
		warn (_("There is an overlap [0x%lx - 0x%lx] in %s section.\n"),
		      (unsigned long) (start - section_begin),
		      (unsigned long) (next - section_begin), section->name);
a3596 1
	  start = next;
d3598 2
a3599 1
	  while (1)
d3601 6
a3606 9
	      /* Note: we use sign extension here in order to be sure that
		 we can detect the -1 escape value.  Sign extension into the
		 top 32 bits of a 32-bit address will not affect the values
		 that we display since we always show hex values, and always
		 the bottom 32-bits.  */
	      begin = byte_get_signed (start, pointer_size);
	      start += pointer_size;
	      end = byte_get_signed (start, pointer_size);
	      start += pointer_size;
d3608 2
a3609 1
	      printf ("    %8.8lx ", offset);
d3611 4
a3614 15
	      if (begin == 0 && end == 0)
		{
		  printf (_("<End of list>\n"));
		  break;
		}

	      /* Check base address specifiers.  */
	      if (begin == (dwarf_vma) -1 && end != (dwarf_vma) -1)
		{
		  base_address = end;
		  print_dwarf_vma (begin, pointer_size);
		  print_dwarf_vma (end, pointer_size);
		  printf ("(base address)\n");
		  continue;
		}
d3616 1
a3616 10
	      print_dwarf_vma (begin + base_address, pointer_size);
	      print_dwarf_vma (end + base_address, pointer_size);

	      if (begin == end)
		fputs (_("(start == end)"), stdout);
	      else if (begin > end)
		fputs (_("(start > end)"), stdout);

	      putchar ('\n');
	    }
d3620 3
@


1.49
log
@2009-07-06  Tristan Gingold  <gingold@@adacore.com>

	* objdump.c (dump_dwarf_section): Handle .eh_frame like other dwarf
	sections.
	* dwarf.h (struct dwarf_section_display): Remove eh_frame field.
	* dwarf.c (debug_displays): Adjust for removed field.
@
text
@d27 1
a27 1
#include "elf/dwarf2.h"
@


1.48
log
@	* dwarf2.h (enum dwarf_location_atom): Add DW_OP_implicit_value
	and DW_OP_stack_value.

	* dwarf.c (decode_location_expression): Handle DW_OP_stack_value
	and DW_OP_implicit_value.
@
text
@d4881 1
a4881 1
    display_debug_abbrev,		&do_debug_abbrevs,	0,	0 },
d4883 1
a4883 1
    display_debug_aranges,		&do_debug_aranges,	1,	0 },
d4885 1
a4885 1
    display_debug_frames,		&do_debug_frames,	1,	0 },
d4887 1
a4887 1
    display_debug_info,			&do_debug_info,		1,	0 },
d4889 1
a4889 1
    display_debug_lines,		&do_debug_lines,	1,	0 },
d4891 1
a4891 1
    display_debug_pubnames,		&do_debug_pubnames,	0,	0 },
d4893 1
a4893 1
    display_debug_frames,		&do_debug_frames,	1,	1 },
d4895 1
a4895 1
    display_debug_macinfo,		&do_debug_macinfo,	0,	0 },
d4897 1
a4897 1
    display_debug_str,			&do_debug_str,		0,	0 },
d4899 1
a4899 1
    display_debug_loc,			&do_debug_loc,		1,	0 },
d4901 1
a4901 1
    display_debug_pubnames,		&do_debug_pubnames,	0,	0 },
d4903 1
a4903 1
    display_debug_ranges,		&do_debug_ranges,	1,	0 },
d4905 1
a4905 1
    display_debug_not_supported,	NULL,			0,	0 },
d4907 1
a4907 1
    display_debug_not_supported,	NULL,			0,	0 },
d4909 1
a4909 1
    display_debug_not_supported,	NULL,			0,	0 },
d4911 1
a4911 1
    display_debug_not_supported,	NULL,			0,	0 }
@


1.47
log
@        * dwarf.c (display_debug_lines_raw): Include the name of the
        section in warning message.
        (struct debug_display): Enable reloc processing for .debug_line
        and .debug_ranges sections.

        * readelf.c: Add --relocated-dump command line option to dump the
        relocated contents of a specified section.
        (request_dump): New function.
        (parse_args): Use it.
        (dump_section_as_bytes): Add parameter to indicate whether the
        contents should be relocated.
        (target_specific_reloc_handling): Add code for a R_MN10300_16
        reloc found after a R_MN10300_SYM_DIFF reloc.
        (debug_apply_relocations): Rename to apply_relocations.
        (get_section_contents): New function.  Replaces common code found
        in dump_section_as_strings and dump_section_as_bytes.
        * doc/binutils.texi: Document new command line option.
        * NEWS: Mention the new feature.
@
text
@d1017 13
@


1.46
log
@        * readelf.c (target_specific_reloc_handling): New function:
        Processes relocs in a target specific manner.
        (debug_apply_relocations): Use the new function.
        * dwarf.c (display_debug_loc): End the dump with a blank line.
        (struct debug_display): Enable reloc processing for .debug_aranges
        and .debug_loc sections.
@
text
@d2148 2
a2149 1
	    (_("The line info appears to be corrupt - the section is too small\n"));
d4876 1
a4876 1
    display_debug_lines,		&do_debug_lines,	0,	0 },
d4890 1
a4890 1
    display_debug_ranges,		&do_debug_ranges,	0,	0 },
@


1.45
log
@include/elf/

	 * dwarf2.h (DW_LNE_set_discriminator): New enum value.

binutils/

	* dwarf.c (process_extended_line_op): Add DW_LNE_set_discriminator.
	Add missing newlines to HP extensions.
@
text
@d3257 1
d4869 1
a4869 1
    display_debug_aranges,		&do_debug_aranges,	0,	0 },
d4885 1
a4885 1
    display_debug_loc,			&do_debug_loc,		0,	0 },
@


1.44
log
@        * dwarf.c (display_debug_ranges): Add the base address to the
        displayed values for 'Begin' and 'End'.
@
text
@d331 5
d338 1
a338 1
      printf ("DW_LNE_HP_negate_is_UV_update");
d341 1
a341 1
      printf ("DW_LNE_HP_push_context");
d344 1
a344 1
      printf ("DW_LNE_HP_pop_context");
d347 1
a347 1
      printf ("DW_LNE_HP_set_file_line_column");
d350 1
a350 1
      printf ("DW_LNE_HP_set_routine_name");
d353 1
a353 1
      printf ("DW_LNE_HP_set_sequence");
d356 1
a356 1
      printf ("DW_LNE_HP_negate_post_semantics");
d359 1
a359 1
      printf ("DW_LNE_HP_negate_function_exit");
d362 1
a362 1
      printf ("DW_LNE_HP_negate_front_end_logical");
d365 1
a365 1
      printf ("DW_LNE_HP_define_proc");
@


1.43
log
@2009-03-19  H.J. Lu  <hongjiu.lu@@intel.com>

	* dwarf.c (dwarf_regnames): Moved before frame_need_space.
	(dwarf_regnames_count): Likewise.
	(frame_need_space): Return int.
	(display_debug_frames): Check invalid registers.
@
text
@a3578 3
	      print_dwarf_vma (begin, pointer_size);
	      print_dwarf_vma (end, pointer_size);

d3583 2
d3589 3
@


1.42
log
@2009-02-09  Tristan Gingold  <gingold@@adacore.com>

	* NEWS: Mention feature match between objdump and readelf for dumping
	dwarf info.

	* doc/binutils.texi (objdump): Document -W/--dwarf improvments to
	objdump.

	* objdump.c (usage): Update documentation for -W/--dwarf.
	(enum option_values): Add OPTION_DWARF.
	(long_options): --dwarf can accept arguments.
	(dump_dwarf_section): Also check enabled field.
	(main): Option -W can accept arguments, code moved to
	dwarf.c and call dwarf_select_sections_all instead.
	* readelf.c (process_section_headers): Remove do_debug_lines_decoded.
	(parse_args): Move code to...
	* dwarf.c (dwarf_select_sections_by_letters,
	dwarf_select_sections_by_names): : ...here (new functions).
	(do_debug_lines_decoded): Remove and replaced by ...
	(FLAG_DEBUG_LINES_RAW, FLAG_DEBUG_LINES_DECODED): ... new macros.
	(display_debug_lines): Adjust for previous change.
	(dwarf_select_sections_all): New function.
	(debug_displays): Add initializer for enabled field.
	* dwarf.h (do_debug_lines_decoded): Remove.
	Add prototypes for the new functions.
	(struct dwarf_section_display): Add enabled field.
@
text
@d3624 3
d3631 5
a3635 2
static void
frame_need_space (Frame_Chunk *fc, int reg)
d3639 6
a3644 2
  if (reg < fc->ncols)
    return;
d3656 1
a3697 3
static const char *const *dwarf_regnames;
static unsigned int dwarf_regnames_count;

d3827 1
d4101 2
a4102 2
		  frame_need_space (fc, opa);
		  fc->col_type[opa] = DW_CFA_undefined;
d4105 2
a4106 2
		  frame_need_space (fc, opa);
		  fc->col_type[opa] = DW_CFA_undefined;
d4123 2
a4124 2
		  frame_need_space (fc, reg);
		  fc->col_type[reg] = DW_CFA_undefined;
d4129 2
a4130 1
		  fc->col_type[reg] = DW_CFA_undefined;
d4134 2
a4135 2
		  frame_need_space (fc, reg);
		  fc->col_type[reg] = DW_CFA_undefined;
d4139 2
a4140 2
		  frame_need_space (fc, reg);
		  fc->col_type[reg] = DW_CFA_undefined;
d4144 2
a4145 2
		  frame_need_space (fc, reg);
		  fc->col_type[reg] = DW_CFA_undefined;
d4165 2
a4166 2
		  frame_need_space (fc, reg);
		  fc->col_type[reg] = DW_CFA_undefined;
d4171 2
a4172 2
		  frame_need_space (fc, reg);
		  fc->col_type[reg] = DW_CFA_undefined;
d4188 3
a4190 3
		  frame_need_space (fc, reg);
		  fc->col_type[reg] = DW_CFA_undefined;

d4207 1
d4230 11
a4240 5
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_offset: %s at cfa%+ld\n",
			regname (opa, 0), roffs * fc->data_factor);
	      fc->col_type[opa] = DW_CFA_offset;
	      fc->col_offset[opa] = roffs * fc->data_factor;
d4244 11
a4254 4
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_restore: %s\n", regname (opa, 0));
	      fc->col_type[opa] = cie->col_type[opa];
	      fc->col_offset[opa] = cie->col_offset[opa];
d4305 11
a4315 5
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_offset_extended: %s at cfa%+ld\n",
			regname (reg, 0), roffs * fc->data_factor);
	      fc->col_type[reg] = DW_CFA_offset;
	      fc->col_offset[reg] = roffs * fc->data_factor;
d4321 11
a4331 5
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_val_offset: %s at cfa%+ld\n",
			regname (reg, 0), roffs * fc->data_factor);
	      fc->col_type[reg] = DW_CFA_val_offset;
	      fc->col_offset[reg] = roffs * fc->data_factor;
d4336 11
a4346 5
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_restore_extended: %s\n",
			regname (reg, 0));
	      fc->col_type[reg] = cie->col_type[reg];
	      fc->col_offset[reg] = cie->col_offset[reg];
d4351 10
a4360 4
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_undefined: %s\n", regname (reg, 0));
	      fc->col_type[reg] = DW_CFA_undefined;
	      fc->col_offset[reg] = 0;
d4365 10
a4374 4
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_same_value: %s\n", regname (reg, 0));
	      fc->col_type[reg] = DW_CFA_same_value;
	      fc->col_offset[reg] = 0;
d4380 3
a4382 1
	      if (! do_debug_frames_interp)
d4384 2
a4385 2
		  printf ("  DW_CFA_register: %s in ",
			  regname (reg, 0));
d4388 5
a4392 2
	      fc->col_type[reg] = DW_CFA_register;
	      fc->col_offset[reg] = roffs;
d4471 3
a4473 1
	      if (! do_debug_frames_interp)
d4475 2
a4476 2
		  printf ("  DW_CFA_expression: %s (",
			  regname (reg, 0));
d4481 2
a4482 1
	      fc->col_type[reg] = DW_CFA_expression;
d4489 3
a4491 1
	      if (! do_debug_frames_interp)
d4493 2
a4494 2
		  printf ("  DW_CFA_val_expression: %s (",
			  regname (reg, 0));
d4499 2
a4500 1
	      fc->col_type[reg] = DW_CFA_val_expression;
d4507 11
a4517 6
	      frame_need_space (fc, reg);
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_offset_extended_sf: %s at cfa%+ld\n",
			regname (reg, 0), l * fc->data_factor);
	      fc->col_type[reg] = DW_CFA_offset;
	      fc->col_offset[reg] = l * fc->data_factor;
d4523 11
a4533 6
	      frame_need_space (fc, reg);
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_val_offset_sf: %s at cfa%+ld\n",
			regname (reg, 0), l * fc->data_factor);
	      fc->col_type[reg] = DW_CFA_val_offset;
	      fc->col_offset[reg] = l * fc->data_factor;
d4578 11
a4588 6
	      frame_need_space (fc, reg);
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_GNU_negative_offset_extended: %s at cfa%+ld\n",
			regname (reg, 0), l * fc->data_factor);
	      fc->col_type[reg] = DW_CFA_offset;
	      fc->col_offset[reg] = l * fc->data_factor;
@


1.41
log
@            * dwarf.c (display_debug_frames): Change text for uniformity.
            (process_debug_info): Likewise.
            (display_debug_aranges): Likewise.  Indent address output.
            (display_debug_pubnames): Print offset in hex.

            * binutils-all/objdump.W: Update.

            * gas/cfi/cfi-alpha-1.d, gas/cfi/cfi-alpha-3.d,
            gas/cfi/cfi-arm-1.d, gas/cfi/cfi-common-1.d,
            gas/cfi/cfi-common-2.d, gas/cfi/cfi-common-3.d,
            gas/cfi/cfi-common-4.d, gas/cfi/cfi-common-5.d,
            gas/cfi/cfi-common-6.d, gas/cfi/cfi-hppa-1.d,
            gas/cfi/cfi-i386-2.d, gas/cfi/cfi-i386.d, gas/cfi/cfi-m68k.d,
            gas/cfi/cfi-mips-1.d, gas/cfi/cfi-ppc-1.d, gas/cfi/cfi-s390-1.d,
            gas/cfi/cfi-s390x-1.d, gas/cfi/cfi-sh-1.d, gas/cfi/cfi-sparc-1.d,
            gas/cfi/cfi-sparc64-1.d, gas/cfi/cfi-x86_64.d: Update for readelf
            change.

            * ld-elf/eh1.d, ld-elf/eh2.d, ld-elf/eh3.d, ld-elf/eh4.d,
            ld-elf/eh5.d, ld-elf/eh6.d, ld-mips-elf/eh-frame1-n32.d,
            ld-mips-elf/eh-frame1-n64.d, ld-mips-elf/eh-frame2-n32.d,
            ld-mips-elf/eh-frame2-n64.d, ld-mips-elf/eh-frame3.d,
            ld-mips-elf/eh-frame4.d: Update for readelf change.
@
text
@a46 1
int do_debug_lines_decoded;
d57 4
d2787 2
a2788 2
  int retValRaw = 0;
  int retValDecoded = 0;
d2797 1
a2797 1
  if (do_debug_lines)
d2800 1
a2800 1
  if (do_debug_lines_decoded)
d2803 1
a2803 2
  if ((do_debug_lines && !retValRaw)
      || (do_debug_lines_decoded && !retValDecoded))
d4629 147
d4779 1
a4779 1
    display_debug_abbrev,		0,	0 },
d4781 1
a4781 1
    display_debug_aranges,		0,	0 },
d4783 1
a4783 1
    display_debug_frames,		1,	0 },
d4785 1
a4785 1
    display_debug_info,			1,	0 },
d4787 1
a4787 1
    display_debug_lines,		0,	0 },
d4789 1
a4789 1
    display_debug_pubnames,		0,	0 },
d4791 1
a4791 1
    display_debug_frames,		1,	1 },
d4793 1
a4793 1
    display_debug_macinfo,		0,	0 },
d4795 1
a4795 1
    display_debug_str,			0,	0 },
d4797 1
a4797 1
    display_debug_loc,			0,	0 },
d4799 1
a4799 1
    display_debug_pubnames,		0,	0 },
d4801 1
a4801 1
    display_debug_ranges,		0,	0 },
d4803 1
a4803 1
    display_debug_not_supported,	0,	0 },
d4805 3
a4807 3
    display_debug_not_supported,	0,	0 },
  { { ".debug_types",	".zdebug_types",		NULL,	NULL,	0,	0 },
    display_debug_not_supported,	0,	0 },
d4809 1
a4809 1
    display_debug_not_supported,	0,	0 }
@


1.40
log
@include/
	* elf/dwarf2.h (DW_OP_GNU_encoded_addr): New.
binutils/
	* dwarf.c (size_of_encoded_value, get_encoded_value): Move up.
	(decode_location_expression): Add section parameter.  Handle
	DW_OP_GNU_encoded_addr.
	(read_and_display_attr_value): Update decode_location_expression call.
	(display_debug_loc, display_debug_frames): Likewise.
gas/
        * dw2gencfi.c (DWARF2_ADDR_SIZE): Provide default.
        (struct cfi_insn_data): Add ea member.
        (CFI_val_encoded_addr, dot_cfi_val_encoded_addr): New.
        (output_cfi_insn): Handle CFI_val_encoded_addr.
        (select_cie_for_fde): Don't match CFI_val_encoded_addr.
        * doc/as.texinfo (.cfi_val_encoded_addr): Document.
@
text
@d1842 1
a1842 1
      printf (_("The section %s contains:\n\n"), section->name);
d2907 1
a2907 1
	      printf ("    %-6ld\t\t%s\n", offset, data);
d3325 1
a3325 1
  printf (_("The section %s contains:\n\n"), section->name);
d3426 1
d3818 1
a3818 1
  printf (_("The section %s contains:\n"), section->name);
@


1.39
log
@	PR 6913
	* dwarf.c (print_dwarf_vma): Don't call printf without format string.
@
text
@d167 24
d678 2
a679 1
			    unsigned long cu_offset)
d1017 15
d1551 1
a1551 1
							cu_offset);
d3229 1
a3229 1
							    cu_offset);
a3798 24
static int
size_of_encoded_value (int encoding)
{
  switch (encoding & 0x7)
    {
    default:	/* ??? */
    case 0:	return eh_addr_size;
    case 2:	return 2;
    case 3:	return 4;
    case 4:	return 8;
    }
}

static dwarf_vma
get_encoded_value (unsigned char *data, int encoding)
{
  int size = size_of_encoded_value (encoding);

  if (encoding & DW_EH_PE_signed)
    return byte_get_signed (data, size);
  else
    return byte_get (data, size);
}

d4398 2
a4399 1
		  decode_location_expression (start, eh_addr_size, ul, 0);
d4414 1
a4414 1
					      ul, 0);
d4428 2
a4429 1
		  decode_location_expression (start, eh_addr_size, ul, 0);
@


1.38
log
@binutils/

2008-08-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* dwarf.c (dwarf_regnames_i386): Remove AVX registers.
	(dwarf_regnames_x86_64): Likewise.

gas/testsuite/

2008-08-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/cfi/cfi-i386.s: Remove tests for AVX register maps.
	* gas/cfi/cfi-x86_64.s: Likewise.

	* gas/cfi/cfi-i386.d: Updated.
	* gas/cfi/cfi-x86_64.d: Likewise.

opcodes/

2008-08-01  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-reg.tbl: Use Dw2Inval on AVX registers.
	* i386-tbl.h: Regenerated.
@
text
@d189 1
a189 1
  printf (buff + (byte_size == 4 ? 8 : 0));
@


1.38.2.1
log
@	PR 6913
	* dwarf.c (print_dwarf_vma): Don't call printf without format string.
@
text
@d189 1
a189 1
  fputs (buff + (byte_size == 4 ? 8 : 0), stdout);
@


1.38.2.2
log
@include/
        * elf/dwarf2.h (DW_OP_GNU_encoded_addr): New.
binutils/
        * dwarf.c (size_of_encoded_value, get_encoded_value): Move up.
        (decode_location_expression): Add section parameter.  Handle
        DW_OP_GNU_encoded_addr.
        (read_and_display_attr_value): Update decode_location_expression call.
        (display_debug_loc, display_debug_frames): Likewise.
gas/
        * dw2gencfi.c (DWARF2_ADDR_SIZE): Provide default.
        (struct cfi_insn_data): Add ea member.
        (CFI_val_encoded_addr, dot_cfi_val_encoded_addr): New.
        (output_cfi_insn): Handle CFI_val_encoded_addr.
        (select_cie_for_fde): Don't match CFI_val_encoded_addr.
        * doc/as.texinfo (.cfi_val_encoded_addr): Document.
@
text
@a166 24
static int
size_of_encoded_value (int encoding)
{
  switch (encoding & 0x7)
    {
    default:	/* ??? */
    case 0:	return eh_addr_size;
    case 2:	return 2;
    case 3:	return 4;
    case 4:	return 8;
    }
}

static dwarf_vma
get_encoded_value (unsigned char *data, int encoding)
{
  int size = size_of_encoded_value (encoding);

  if (encoding & DW_EH_PE_signed)
    return byte_get_signed (data, size);
  else
    return byte_get (data, size);
}

d654 1
a654 2
			    unsigned long cu_offset,
			    struct dwarf_section * section)
a991 15
	case DW_OP_GNU_encoded_addr:
	  {
	    int encoding;
	    dwarf_vma addr;
	
	    encoding = *data++;
	    addr = get_encoded_value (data, encoding);
	    if ((encoding & 0x70) == DW_EH_PE_pcrel)
	      addr += section->address + (data - section->start);
	    data += size_of_encoded_value (encoding);

	    printf ("DW_OP_GNU_encoded_addr: fmt:%02x addr:", encoding);
	    print_dwarf_vma (addr, pointer_size);
	  }
	  break;
d1511 1
a1511 1
							cu_offset, section);
d3189 1
a3189 1
							    cu_offset, section);
d3759 24
d4382 1
a4382 2
		  decode_location_expression (start, eh_addr_size, ul, 0,
					      section);
d4397 1
a4397 1
					      ul, 0, section);
d4411 1
a4411 2
		  decode_location_expression (start, eh_addr_size, ul, 0,
					      section);
@


1.37
log
@Silence gcc printf warnings
@
text
@d3619 1
a3619 4
  "tr", "ldtr",
  NULL, NULL, NULL,
  "ymm0", "ymm1", "ymm2", "ymm3",
  "ymm4", "ymm5", "ymm6", "ymm7"
d3641 1
a3641 6
  "mxcsr", "fcw", "fsw",
  NULL, NULL, NULL,
  "ymm0", "ymm1", "ymm2", "ymm3",
  "ymm4", "ymm5", "ymm6", "ymm7",
  "ymm8", "ymm9", "ymm10", "ymm11",
  "ymm12", "ymm13", "ymm14", "ymm15"
@


1.36
log
@bfd/
	* Makefile.am (BFD32_LIBS): Add compress.lo.
	(BFD32_LIBS_CFILES): Add compress.c.
	(BFD_H_FILES): Likewise.
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* config.in: Add HAVE_ZLIB_H
	* configure.in: Add test for libz and zlib.h
	* configure: Regenerate.
	* dwarf2.c (read_section): New function.
	(read_indirect_string): Call new function read_section.
	(read_abbrevs): Likewise.
	(decode_line_info): Likewise.
	(read_debug_ranges): Likewise.
	(find_line): Call new function read_section when just one
	.zdebug_info section is found, otherwise read and compress
	multiple sections.
	(_bfd_dwarf2_cleanup_debug_info): Free sec_info_ptr.
	* elf.c (_bfd_elf_make_section_from_shdr): Add zdebug prefix.
	(special_sections_z): New struct.
	(special_sections): Refer to special_sections_z.
	* elfxx-mips.c (_bfd_mips_elf_section_from_shdr): Recognize
	sections named .zdebug_*.
	(_bfd_mips_elf_fake_sections): Likewise.
	* compress.c: New file.
	(bfd_uncompress_section_contents): New function.
bfd/doc/
	* Makefile.am (BFD_H_DEP): Add ../compress.c.
	* Makefile.in: Regenerate.
binutils/
	* config.in: Add HAVE_ZLIB_H
	* configure.in: Add test for libz and zlib.h
	* configure: Regenerate.
	* dwarf.c (debug_displays): Add .zdebug_* strings.
	* dwarf.h (struct dwarf_section): Add fields uncompressed_namd
	and compressed_name.
	* objdump.c (load_debug_section): Call
	bfd_uncompress_section_contents when loading a compressed
	section.
	(dump_dwarf_section): Recognize compressed section name.
	(mach_o_dwarf_sections): Rename as
	mach_o_uncompressed_dwarf_sections.
	(mach_o_compressed_dwarf_sections): New variable.
	(generic_dwarf_section): Rename as
	generic_uncompressed_dwarf_sections.
	(generic_compressed_dwarf_sections): New variable.
	(check_mach_o_dwarf): Save and restore
	mach_o_compressed_dwarf_sections.
	* readelf.c: Add #include for config.h and zlib.h
	(process_section_headers): Recognize compressed section name.
	(uncompress_section_contents): New function.
	(load_debug_section): Call uncompress_section_contents when
	loading a compressed section.
	(display_debug_section): Recognize compressed section name.
binutils/testsuite:
	* binutils-all/objdump.exp: Add test for objdump -s on a file
	with a compressed debug section.  Add test for objdump -W on a
	file that contains a compressed debug section.
	* binutils-all/readelf.exp: Call readelf_compressed_wa_test.
	(readelf_compressed_wa_test): New function.
	* binutils-all/dw2-compressed.S: New file.
	* binutils-all/objdump.W: New file.
	* binutils-all/objdump.s: New file.
	* binutils-all/readelf.wa: New file.
@
text
@d1527 1
a1527 1
		uvalue, (long int)(orig_data - section->start));
d3112 2
a3113 1
		      (long)(start - section_begin), (long)(next - section_begin));
d3116 2
a3117 1
		      (long)(start - section_begin), (long)(next - section_begin));
d3507 2
a3508 2
		      (long)(start - section_begin),
		      (long)(next - section_begin), section->name);
d3511 2
a3512 2
		      (long)(start - section_begin),
		      (long)(next - section_begin), section->name);
@


1.35
log
@        * dwarf.c (display_debug_lines): Rename to
        display_debug_lines_raw.
        (display_debug_lines_decoded): New function.  Displays the
        interpreted contents of a .debug_line section.
        (display_debug_lines): New function: Selects either a raw dump or
        a decoded dump (or both) as requested by the user.
        * dwarf.h (do_debug_lines_decoded): New extern.
        * readelf.c: Add support for -wL or --debug-dump=decodedline
        option to display the decoded contents of a .debug_line section.
        * doc/binutils.texi: Document the new option.
        * NEWS: Mention the new feature.
@
text
@d4616 1
a4616 1
  { { ".debug_abbrev",		NULL,	0,	0 },
d4618 1
a4618 1
  { { ".debug_aranges",		NULL,	0,	0 },
d4620 1
a4620 1
  { { ".debug_frame",		NULL,	0,	0 },
d4622 1
a4622 1
  { { ".debug_info",		NULL,	0,	0 },
d4624 1
a4624 1
  { { ".debug_line",		NULL,	0,	0 },
d4626 1
a4626 1
  { { ".debug_pubnames",	NULL,	0,	0 },
d4628 1
a4628 1
  { { ".eh_frame",		NULL,	0,	0 },
d4630 1
a4630 1
  { { ".debug_macinfo",		NULL,	0,	0 },
d4632 1
a4632 1
  { { ".debug_str",		NULL,	0,	0 },
d4634 1
a4634 1
  { { ".debug_loc",		NULL,	0,	0 },
d4636 1
a4636 1
  { { ".debug_pubtypes",	NULL,	0,	0 },
d4638 1
a4638 1
  { { ".debug_ranges",		NULL,	0,	0 },
d4640 1
a4640 1
  { { ".debug_static_func",	NULL,	0,	0 },
d4642 1
a4642 1
  { { ".debug_static_vars",	NULL,	0,	0 },
d4644 1
a4644 1
  { { ".debug_types",		NULL,	0,	0 },
d4646 1
a4646 1
  { { ".debug_weaknames",	NULL,	0,	0 },
@


1.34
log
@	* dwarf.c: Remove trailing whitespace throughout file.
@
text
@d47 1
d56 1
d2056 3
a2058 1
display_debug_lines (struct dwarf_section *section, void *file)
a2060 2
  unsigned char *data = start;
  unsigned char *end = start + section->size;
d2062 2
a2063 9
  printf (_("\nDump of debug contents of section %s:\n\n"),
	  section->name);

  if (load_debug_info (file) == 0)
    {
      warn (_("Unable to load/parse the .debug_info section, so cannot interpret the %s section.\n"),
	    section->name);
      return 0;
    }
d2330 437
@


1.33
log
@binutils/

2008-04-03  H.J. Lu  <hongjiu.lu@@intel.com>

	* dwarf.c (dwarf_regnames_i386): Add AVX registers.
	(dwarf_regnames_x86_64): Likewise.

gas/

2008-04-03  H.J. Lu  <hongjiu.lu@@intel.com>

	* NEWS: Mention AES, CLMUL, AVX/FMA and -msse2avx.

	* doc/c-i386.texi: Add avx, aes, clmul and fma to -march=.
	Document -msse2avx, .avx, .aes, .clmul and .fma.

	* config/tc-i386.c (YMMWORD_MNEM_SUFFIX): New.
	(vex_prefix): Likewise.
	(sse2avx): Likewise.
	(CPU_FLAGS_ARCH_MATCH): Likewise.
	(CPU_FLAGS_64BIT_MATCH): Likewise.
	(CPU_FLAGS_32BIT_MATCH): Likewise.
	(CPU_FLAGS_PERFECT_MATCH): Likewise.
	(regymm): Likewise.
	(vex_imm4): Likewise.
	(fits_in_imm4): Likewise.
	(build_vex_prefix): Likewise.
	(VEX_check_operands): Likewise.
	(bad_implicit_operand): Likewise.
	(OPTION_MSSE2AVX): Likewise.
	(T_YMMWORD): Likewise.
	(_i386_insn): Add vex.
	(cpu_arch): Add .avx, .aes, .clmul and .fma.
	(cpu_flags_match): Changed to take a pointer to const template.
	Enable encoding SSE instructions with VEX prefix for -msse2avx.
	(match_mem_size): Also check ymmword.
	(operand_type_match): Clear ymmword.
	(md_begin): Allow '_' in mnemonic.
	(type_names): Add OPERAND_TYPE_VEX_IMM4.
	(process_immext): Update assert.
	(md_assemble): Don't call process_immext if sse2avx and immext
	are true.  Call build_vex_prefix if vex is true.
	(parse_insn): Updated for cpu_flags_match.
	(swap_operands): Handle 5 operands.
	(match_template): Handle 5 operands. Updated for cpu_flags_match.
	Check regymm.  Call VEX_check_operands. Handle YMMWORD_MNEM_SUFFIX.
	(process_suffix): Handle YMMWORD_MNEM_SUFFIX.
	(check_byte_reg): Check regymm.
	(process_operands): Duplicate the destination register for
	-msse2avx if needed.
	(build_modrm_byte): Updated for instructions with VEX encoding.
	(output_insn): Output VEX prefix if needed.
	(md_longopts): Add msse2avx.
	(md_parse_option): Handle OPTION_MSSE2AVX.
	(md_show_usage): Add avx, aes, clmul, fma and -msse2avx.
	(intel_e09): Support YMMWORD.
	(intel_e11): Likewise.
	(intel_get_token): Likewise.

gas/testsuite/

2008-04-03  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/i386.exp: Run aes, aes-intel, x86-64-aes,
	x86-64-aes-intel, avx, avx-intel, inval-avx, x86-64-avx,
	x86-64-avx-intel and x86-64-inval-avx.

	* gas/cfi/cfi-i386.s: Add tests for AVX register maps.
	* gas/cfi/cfi-x86_64.s: Likewise.

	* gas/i386/aes.d: New.
	* gas/i386/aes.s: Likewise.
	* gas/i386/aes-intel.d: Likewise.
	* gas/i386/avx.d: Likewise.
	* gas/i386/avx.s: Likewise.
	* gas/i386/avx-intel.d: Likewise.
	* gas/i386/clmul.d: Likewise.
	* gas/i386/clmul-intel.d: Likewise.
	* gas/i386/clmul.s: Likewise.
	* gas/i386/i386.exp: Likewise.
	* gas/i386/inval-avx.l: Likewise.
	* gas/i386/inval-avx.s: Likewise.
	* gas/i386/sse2avx.d: Likewise.
	* gas/i386/sse2avx.s: Likewise.
	* gas/i386/x86-64-aes.d: Likewise.
	* gas/i386/x86-64-aes.s: Likewise.
	* gas/i386/x86-64-aes-intel.d: Likewise.
	* gas/i386/x86-64-avx.d: Likewise.
	* gas/i386/x86-64-avx.s: Likewise.
	* gas/i386/x86-64-avx-intel.d: Likewise.
	* gas/i386/x86-64-clmul.d: Likewise.
	* gas/i386/x86-64-clmul-intel.d: Likewise.
	* gas/i386/x86-64-clmul.s: Likewise.
	* gas/i386/x86-64-inval-avx.l: Likewise.
	* gas/i386/x86-64-inval-avx.s: Likewise.
	* gas/i386/x86-64-sse2avx.d: Likewise.
	* gas/i386/x86-64-sse2avx.s: Likewise.

	* gas/i386/arch-10.s: Add tests for AVX, AES, CLMUL and FMA.
	* gas/i386/x86-64-arch-2.s: Likewise.

	* gas/i386/rexw.s: Add AVX tests.

	* gas/i386/x86-64-opcode-inval.s: Remove lds/les test.

	* gas/cfi/cfi-i386.d: Updated.
	* gas/cfi/cfi-x86_64.d: Likewise.
	* gas/i386/arch-10.d:  Likewise.
	* gas/i386/arch-10-1.l: Likewise.
	* gas/i386/arch-10-2.l: Likewise.
	* gas/i386/arch-10-3.l: Likewise.
	* gas/i386/arch-10-4.l: Likewise.
	* gas/i386/rexw.d: Likewise.
	* gas/i386/x86-64-arch-2.d: Likewise.
	* gas/i386/x86-64-opcode-inval.d: Likewise.
	* gas/i386/x86-64-opcode-inval-intel.d: Likewise.

include/opcode/

2008-04-03  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386.h (MAX_OPERANDS): Set to 5.
	(MAX_MNEM_SIZE): Changed to 20.

opcodes/

2008-04-03  H.J. Lu  <hongjiu.lu@@intel.com>

	* i386-dis.c (OP_E_register): New.
	(OP_E_memory): Likewise.
	(OP_VEX): Likewise.
	(OP_EX_Vex): Likewise.
	(OP_EX_VexW): Likewise.
	(OP_XMM_Vex): Likewise.
	(OP_XMM_VexW): Likewise.
	(OP_REG_VexI4): Likewise.
	(PCLMUL_Fixup): Likewise.
	(VEXI4_Fixup): Likewise.
	(VZERO_Fixup): Likewise.
	(VCMP_Fixup): Likewise.
	(VPERMIL2_Fixup): Likewise.
	(rex_original): Likewise.
	(rex_ignored): Likewise.
	(Mxmm): Likewise.
	(XMM): Likewise.
	(EXxmm): Likewise.
	(EXxmmq): Likewise.
	(EXymmq): Likewise.
	(Vex): Likewise.
	(Vex128): Likewise.
	(Vex256): Likewise.
	(VexI4): Likewise.
	(EXdVex): Likewise.
	(EXqVex): Likewise.
	(EXVexW): Likewise.
	(EXdVexW): Likewise.
	(EXqVexW): Likewise.
	(XMVex): Likewise.
	(XMVexW): Likewise.
	(XMVexI4): Likewise.
	(PCLMUL): Likewise.
	(VZERO): Likewise.
	(VCMP): Likewise.
	(VPERMIL2): Likewise.
	(xmm_mode): Likewise.
	(xmmq_mode): Likewise.
	(ymmq_mode): Likewise.
	(vex_mode): Likewise.
	(vex128_mode): Likewise.
	(vex256_mode): Likewise.
	(USE_VEX_C4_TABLE): Likewise.
	(USE_VEX_C5_TABLE): Likewise.
	(USE_VEX_LEN_TABLE): Likewise.
	(VEX_C4_TABLE): Likewise.
	(VEX_C5_TABLE): Likewise.
	(VEX_LEN_TABLE): Likewise.
	(REG_VEX_XX): Likewise.
	(MOD_VEX_XXX): Likewise.
	(PREFIX_0F38DB..PREFIX_0F38DF): Likewise.
	(PREFIX_0F3A44): Likewise.
	(PREFIX_0F3ADF): Likewise.
	(PREFIX_VEX_XXX): Likewise.
	(VEX_OF): Likewise.
	(VEX_OF38): Likewise.
	(VEX_OF3A): Likewise.
	(VEX_LEN_XXX): Likewise.
	(vex): Likewise.
	(need_vex): Likewise.
	(need_vex_reg): Likewise.
	(vex_i4_done): Likewise.
	(vex_table): Likewise.
	(vex_len_table): Likewise.
	(OP_REG_VexI4): Likewise.
	(vex_cmp_op): Likewise.
	(pclmul_op): Likewise.
	(vpermil2_op): Likewise.
	(m_mode): Updated.
	(es_reg): Likewise.
	(PREFIX_0F38F0): Likewise.
	(PREFIX_0F3A60): Likewise.
	(reg_table): Add REG_VEX_71...REG_VEX_73 and REG_VEX_AE.
	(prefix_table): Add PREFIX_0F38DB..PREFIX_0F38DF, PREFIX_0F3ADF
	and PREFIX_VEX_XXX entries.
	(x86_64_table): Use VEX_C4_TABLE and VEX_C5_TABLE.
	(three_byte_table): Use PREFIX_0F38DB..PREFIX_0F38DF and
	PREFIX_0F3ADF.
	(mod_table): Use VEX_C4_TABLE, VEX_C5_TABLE and VEX_LEN_TABLE.
	Add MOD_VEX_XXX entries.
	(ckprefix): Initialize rex_original and rex_ignored.  Store the
	REX byte in rex_original.
	(get_valid_dis386): Handle the implicit prefix in VEX prefix
	bytes and USE_VEX_LEN_TABLE/USE_VEX_C4_TABLE/USE_VEX_C5_TABLE.
	(print_insn): Set need_vex/need_vex_reg/vex_i4_done to 0 before
	calling get_valid_dis386.  Use rex_original and rex_ignored when
	printing out REX.
	(putop): Handle "XY".
	(intel_operand_size): Handle VEX, xmm_mode, xmmq_mode and
	ymmq_mode.
	(OP_E_extended): Updated to use OP_E_register and
	OP_E_memory.
	(OP_XMM): Handle VEX.
	(OP_EX): Likewise.
	(XMM_Fixup): Likewise.
	(CMP_Fixup): Use ARRAY_SIZE.

	* i386-gen.c (cpu_flag_init): Add CpuAES, CPU_CLMUL_FLAGS,
	CPU_FMA_FLAGS and CPU_AVX_FLAGS.
	(operand_type_init): Add OPERAND_TYPE_REGYMM and
	OPERAND_TYPE_VEX_IMM4.
	(cpu_flags): Add CpuAVX, CpuAES, CpuCLMUL and CpuFMA.
	(opcode_modifiers): Add Implicit1stXmm0, Vex, Vex256, VexNDD,
	VexNDS, VexW0, VexW1, Vex0F, Vex0F38, Vex0F3A, Vex3Sources,
	VexImmExt and SSE2AVX.
	(operand_types): Add RegYMM, Ymmword and Vex_Imm4.

	* i386-opc.h (CpuAVX): New.
	(CpuAES): Likewise.
	(CpuCLMUL): Likewise.
	(CpuFMA): Likewise.
	(Vex): Likewise.
	(Vex256): Likewise.
	(VexNDS): Likewise.
	(VexNDD): Likewise.
	(VexW0): Likewise.
	(VexW1): Likewise.
	(Vex0F): Likewise.
	(Vex0F38): Likewise.
	(Vex0F3A): Likewise.
	(Vex3Sources): Likewise.
	(VexImmExt): Likewise.
	(SSE2AVX): Likewise.
	(RegYMM): Likewise.
	(Ymmword): Likewise.
	(Vex_Imm4): Likewise.
	(Implicit1stXmm0): Likewise.
	(CpuXsave): Updated.
	(CpuLM): Likewise.
	(ByteOkIntel): Likewise.
	(OldGcc): Likewise.
	(Control): Likewise.
	(Unspecified): Likewise.
	(OTMax): Likewise.
	(i386_cpu_flags): Add cpuavx, cpuaes, cpuclmul and cpufma.
	(i386_opcode_modifier): Add implicit1stxmm0, vex, vex256,
	vexnds, vexndd, vexw0, vexw1, vex0f, vex0f38, vex0f3a,
	vex3sources, veximmext and sse2avx.
	(i386_operand_type): Add regymm, ymmword and vex_imm4.

	* i386-opc.tbl: Add AES, CLMUL, AVX and FMA new instructions.

	* i386-reg.tbl: Add AVX registers, ymm0..ymm15.

	* i386-init.h: Regenerated.
	* i386-tbl.h: Likewise.
@
text
@d168 1
a168 1
   
d333 1
a333 1
      
d1500 1
a1500 1
    case DW_AT_lower_bound:      
d1532 1
a1532 1
	
d1660 1
a1660 1
    case DW_AT_HP_block_index:			return "DW_AT_HP_block_index";      
d1676 1
a1676 1
      
d1948 1
a1948 1
 
d1970 1
a1970 1
 
d2002 1
a2002 1
 
d2007 1
a2007 1
 
d2013 1
a2013 1
      
d2018 1
a2018 1
 
d2398 1
a2398 1
      
d2670 1
a2670 1
	  offset = debug_information [i].loc_offsets [j] - section->address; 
d2707 1
a2707 1
		 the bottom 32-bits.  */		 
d2927 1
a2927 1
      
d3059 1
a3059 1
      
d3088 1
a3088 1
		 the bottom 32-bits.  */		 
d4068 1
a4068 1
		warn (_("unsupported or unknown Dwarf Call Frame Instruction number: %#x\n"), op);		
@


1.32
log
@* dwarf2.h: (enum dwarf_location_atom): Add new DW_OP,
  DW_OP_PGI_omp_thread_num.

* dwarf.c (decode_location_expression): Handle
  DW_OP_PGI_omp_thread_num.
@
text
@d3185 4
a3188 1
  "tr", "ldtr"
d3210 6
a3215 1
  "mxcsr", "fcw", "fsw"
@


1.31
log
@* dwarf.c (print_dwarf_vma): Use mingw field type specified if necessary.
@
text
@d1017 9
@


1.30
log
@* dwarf.c (print_dwarf_vma): New function.  Display the value of a
  dwarf_vma type at a specified precision.
  (display_debug_loc): Use dwarf_vma type for begin and end values.
  Use print_dwarf_vma to display their values.  Use byte_get_signed
  in order to correctly detect the -1 escape value.
  (display_debug_aranges): Likewise.
  (display_debug_ranges): Likewise.
@
text
@d178 1
d181 3
@


1.29
log
@update copyright date
@
text
@d165 21
d2640 2
a2641 3
      unsigned long begin;
      unsigned long end;
      unsigned long minus_one;
d2690 6
a2695 1
	      begin = byte_get (start, pointer_size);
d2697 1
a2697 1
	      end = byte_get (start, pointer_size);
d2700 2
d2704 1
a2704 1
		  printf (_("    %8.8lx <End of list>\n"), offset);
d2709 1
a2709 4
	      minus_one = -1;
	      if (pointer_size < sizeof (minus_one))
		minus_one = (1L << (pointer_size * 8)) - 1;
	      if (begin == minus_one && end != minus_one)
d2712 3
a2714 2
		  printf (_("    %8.8lx %8.8lx %8.8lx (base address)\n"),
			  offset, begin, end);
d2735 4
a2738 2
	      printf ("    %8.8lx %8.8lx %8.8lx (",
		      offset, begin + base_address, end + base_address);
d2849 2
a2850 2
      unsigned long length;
      unsigned long address;
d2939 3
a2941 4
	  if (address_size > 4)
	    printf ("    0x%16.16lx 0x%lx\n", address, length);
	  else
	    printf ("    0x%8.8lx 0x%lx\n", address, length);	    
d3039 2
a3040 2
      unsigned long begin;
      unsigned long end;
d3046 1
a3046 1

d3071 6
a3076 1
	      begin = byte_get (start, pointer_size);
d3078 1
a3078 1
	      end = byte_get (start, pointer_size);
d3081 2
d3085 1
a3085 1
		  printf (_("    %8.8lx <End of list>\n"), offset);
d3089 3
d3093 1
a3093 1
	      if (begin == -1UL && end != -1UL)
d3096 1
a3096 2
		  printf ("    %8.8lx %8.8lx %8.8lx (base address)\n",
			  offset, begin, end);
a3099 3
	      printf ("    %8.8lx %8.8lx %8.8lx",
		      offset, begin + base_address, end + base_address);

d3101 1
a3101 1
		fputs (_(" (start == end)"), stdout);
d3103 1
a3103 1
		fputs (_(" (start > end)"), stdout);
@


1.28
log
@	* dwarf.c (display_debug_loc): Correct test for base address
	entry when 64-bit host dumping 32-bit object.
@
text
@d2 1
a2 1
   Copyright 2005, 2006, 2007
@


1.27
log
@binutils/

2008-01-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* dwarf.c: Include "elf/common.h".
	(eh_addr_size): Changed to int.
	(dwarf_regnames_i386): New.
	(dwarf_regnames_x86_64): Likewise.
	(dwarf_regnames): Likewise.
	(dwarf_regnames_count): Likewise.
	(init_dwarf_regnames): Likewise.
	(regname): Likewise.
	(frame_display_row): Properly support different address size.
	Call regname to get register name.
	(display_debug_frames): Call regname to get register name.
	Display DW_CFA_def_cfa_register as DW_CFA_def_cfa_register
	instead of DW_CFA_def_cfa_reg.

	* dwarf.h (init_dwarf_regnames): New.

	* objdump.c: Include "elf-bfd.h".
	(dump_dwarf): Call init_dwarf_regnames on ELF input.

	* readelf.c (guess_is_rela): Change argument to int.
	(parse_args): Remove the undocumented upper case options for
	-wX.
	(process_file_header): Call init_dwarf_regnames if
	do_dwarf_register is true.

gas/testsuite/

2008-01-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/cfi/cfi-alpha-1.d: Replace DW_CFA_def_cfa_reg with
	DW_CFA_def_cfa_register.
	* gas/cfi/cfi-alpha-3.d: Likewise.
	* gas/cfi/cfi-hppa-1.d: Likewise.
	* gas/cfi/cfi-i386.d: Likewise.
	* gas/cfi/cfi-m68k.d: Likewise.
	* gas/cfi/cfi-mips-1.d: Likewise.
	* gas/cfi/cfi-sh-1.d: Likewise.
	* gas/cfi/cfi-sparc-1.d: Likewise.
	* gas/cfi/cfi-sparc64-1.d: Likewise.
	* gas/cfi/cfi-x86_64.d: Likewise.

	* gas/cfi/cfi-common-1.d: Updated for i386/x86-64 register
	names.
	* gas/cfi/cfi-common-2.d: Likewise.
	* gas/cfi/cfi-common-5.d: Likewise.
	* gas/cfi/cfi-i386.d: Likewise.
	* gas/cfi/cfi-x86_64.d: Likewise.

ld/testsuite/

2008-01-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-elf/eh1.d: Replace DW_CFA_def_cfa_reg with
	DW_CFA_def_cfa_register. Updated for i386/x86-64 register
	names.
	* ld-elf/eh2.d: Likewise.
	* ld-elf/eh3.d: Likewise.
	* ld-elf/eh4.d: Likewise.
	* ld-elf/eh5.d: Likewise.
@
text
@d2621 1
d2682 4
a2685 1
	      if (begin == -1UL && end != -1UL)
@


1.26
log
@Add mingw I64 support for printing long and long long values
@
text
@d26 1
d42 1
a42 1
dwarf_vma eh_addr_size;
d3122 81
d3214 2
d3218 1
a3218 1
      printf ("   LOC   CFA      ");
d3224 1
a3224 1
	      printf ("ra   ");
d3226 1
a3226 1
	      printf ("r%-4d", r);
d3232 1
a3232 1
  printf ("%08lx ", fc->pc_begin);
d3236 1
a3236 1
    sprintf (tmp, "r%d%+d", fc->cfa_reg, fc->cfa_offset);
d3258 1
a3258 1
	      sprintf (tmp, "r%d", fc->col_offset[r]);
d3270 1
a3270 1
	  printf ("%-5s", tmp);
d3718 2
a3719 2
		printf ("  DW_CFA_offset: r%d at cfa%+ld\n",
			opa, roffs * fc->data_factor);
d3726 1
a3726 1
		printf ("  DW_CFA_restore: r%d\n", opa);
d3780 2
a3781 2
		printf ("  DW_CFA_offset_extended: r%ld at cfa%+ld\n",
			reg, roffs * fc->data_factor);
d3790 2
a3791 2
		printf ("  DW_CFA_val_offset: r%ld at cfa%+ld\n",
			reg, roffs * fc->data_factor);
d3799 2
a3800 1
		printf ("  DW_CFA_restore_extended: r%ld\n", reg);
d3808 1
a3808 1
		printf ("  DW_CFA_undefined: r%ld\n", reg);
d3816 1
a3816 1
		printf ("  DW_CFA_same_value: r%ld\n", reg);
d3825 5
a3829 1
		printf ("  DW_CFA_register: r%ld in r%ld\n", reg, roffs);
d3871 2
a3872 2
		printf ("  DW_CFA_def_cfa: r%d ofs %d\n",
			fc->cfa_reg, fc->cfa_offset);
d3879 2
a3880 1
		printf ("  DW_CFA_def_cfa_reg: r%d\n", fc->cfa_reg);
d3911 4
a3914 2
		  printf ("  DW_CFA_expression: r%ld (", reg);
		  decode_location_expression (start, eh_addr_size, ul, 0);
d3926 2
a3927 1
		  printf ("  DW_CFA_val_expression: r%ld (", reg);
d3940 2
a3941 2
		printf ("  DW_CFA_offset_extended_sf: r%ld at cfa%+ld\n",
			reg, l * fc->data_factor);
d3951 2
a3952 2
		printf ("  DW_CFA_val_offset_sf: r%ld at cfa%+ld\n",
			reg, l * fc->data_factor);
d3963 2
a3964 2
		printf ("  DW_CFA_def_cfa_sf: r%d ofs %d\n",
			fc->cfa_reg, fc->cfa_offset);
d4001 2
a4002 2
		printf ("  DW_CFA_GNU_negative_offset_extended: r%ld at cfa%+ld\n",
			reg, l * fc->data_factor);
@


1.25
log
@        (DEBUG_INFO_UNAVAILABLE): Value stored in num_debug_info_entries
        when the .debug_info section could not be loaded/parsed.
        (process_debug_info): Display the length of the compilation unit
        in hex, so that it corresponds with the offsets that will follow.
        Tell the user if the length was 32-bit or 64-bit.
        If a DIE abbreviation could not be found, tell the user the offset
        of the DIE.
        (free_debug_memory): Do not attempt to free any entries in the
        debug_information array if num_debug_info_entries is set to
        DEBUG_INFO_UNAVAILABLE.
@
text
@d1010 2
a1011 2
read_and_display_attr_value (unsigned long   attribute,
			     unsigned long   form,
d1013 7
a1019 7
			     unsigned long   cu_offset,
			     unsigned long   pointer_size,
			     unsigned long   offset_size,
			     int             dwarf_version,
			     debug_info *    debug_info_p,
			     int             do_loc,
			     unsigned char * section_start)
d1023 1
d1096 1
a1096 1
					  section_start);
a1482 3
	unsigned long abbrev_number;
	abbrev_entry * entry;

d1488 9
a1496 1
	abbrev_number = read_leb128 (section_start + uvalue, NULL, 0);
d1498 8
a1505 7
	printf ("[Abbrev Number: %ld", abbrev_number);
	for (entry = first_abbrev; entry != NULL; entry = entry->next)
	  if (entry->entry == abbrev_number)
	    break;
	if (entry != NULL)
	  printf (" (%s)", get_TAG_name (entry->tag));
	printf ("]");
d1671 2
a1672 2
read_and_display_attr (unsigned long   attribute,
		       unsigned long   form,
d1674 7
a1680 7
		       unsigned long   cu_offset,
		       unsigned long   pointer_size,
		       unsigned long   offset_size,
		       int             dwarf_version,
		       debug_info *    debug_info_p,
		       int             do_loc,
		       unsigned char * section_start)
d1687 1
a1687 1
				      do_loc, section_start);
d1699 2
a1700 1
process_debug_info (struct dwarf_section *section, void *file,
d1965 1
a1965 1
					    do_loc, section->start);
d2300 15
d2323 4
d2354 1
d2357 7
d2386 1
a2386 1
      printf (_("  Offset into .debug_info section:     %ld\n"),
d2808 4
d2848 6
d2868 1
a2868 1
      printf (_("  Offset into .debug_info:  %lx\n"), arange.ar_info_offset);
@


1.24
log
@        * dwarf.c (process_debug_info): Include the CU offset and corrupt
        version value when reporting unrecognised DWARF version numbers.
        (load_debug_info): Remember a failed attempt to load and parse the
        .debug_info section and do not repeat such attempts.
        (display_debug_lines): Check the return value from load_debug_info
        and return whilst displaying a warning message if the load failed.
        (display_debug_loc): Likewise.
        (display_debug_ranges): Likewise.
@
text
@d37 3
d1829 2
a1830 1
	  printf (_("   Length:        %ld\n"), compunit.cu_length);
d1920 2
a1921 2
	      warn (_("Unable to locate entry %lu in the abbreviation table\n"),
		    abbrev_number);
d1995 1
a1995 1
  if (num_debug_info_entries == (unsigned) -1)
d2006 1
a2006 1
  num_debug_info_entries = (unsigned) -1;
d3251 1
a3251 1
	  frame_need_space (fc, max_regs-1);
d3393 1
a3393 1
	      frame_need_space (fc, max_regs-1);
d3720 1
a3720 1
		  frame_need_space (fc, rs->ncols-1);
d3965 1
a3965 1
  if (debug_information)
d3967 1
a3967 1
      for (i = 0; i < num_debug_info_entries; i++)
d3969 1
a3969 1
	  if (!debug_information [i].max_loc_offsets)
d3971 7
a3977 2
	      free (debug_information [i].loc_offsets);
	      free (debug_information [i].have_frame_base);
a3978 2
	  if (!debug_information [i].max_range_lists)
	    free (debug_information [i].range_lists);
d3980 1
a3984 1

@


1.23
log
@        * dwarf.c (read_and_display_attr_value): Prefix values that are
        displayed in hexadecimal with 0x.
        For the DW_AT_import attribute display the abbreviation number and
        tag of the imported DIE.
        (process_debug_info): Warn about lengths that reserved by the
        DWARF3 specification.
        Provide more information when corrupted DIEs are detected.
        Warn if DIE corruption makes the sibling level negative.
@
text
@d1844 2
a1845 1
	  warn (_("Only version 2 and 3 DWARF debug information is currently supported.\n"));
d1989 5
d2001 3
a2003 2
  else
    return 0;
d2016 6
a2021 1
  load_debug_info (file);
d2516 6
a2521 1
  load_debug_info (file);
d2896 6
a2901 1
  load_debug_info (file);
@


1.22
log
@	* dwarf.c (display_debug_loc): Cast section_end - start to long
	for output format.
@
text
@d1007 10
a1016 9
read_and_display_attr_value (unsigned long attribute,
			     unsigned long form,
			     unsigned char *data,
			     unsigned long cu_offset,
			     unsigned long pointer_size,
			     unsigned long offset_size,
			     int dwarf_version,
			     debug_info *debug_info_p,
			     int do_loc)
d1091 2
a1092 1
					  debug_info_p, do_loc);
d1099 1
a1099 1
	printf (" <#%lx>", uvalue);
d1107 1
a1107 1
	printf (" <%lx>", uvalue + cu_offset);
d1113 1
a1113 1
	printf (" %#lx", uvalue);
d1130 2
a1131 2
	  printf (" %lx", uvalue);
	  printf (" %lx", (unsigned long) byte_get (data + 4, 4));
a1200 1
  /* For some attributes we can display further information.  */
d1272 1
d1477 22
d1661 10
a1670 9
read_and_display_attr (unsigned long attribute,
		       unsigned long form,
		       unsigned char *data,
		       unsigned long cu_offset,
		       unsigned long pointer_size,
		       unsigned long offset_size,
		       int dwarf_version,
		       debug_info *debug_info_p,
		       int do_loc)
d1677 1
a1677 1
				      do_loc);
d1717 5
d1835 2
a1836 2
	  warn (_("Debug info is corrupted, length is invalid (section is %lu bytes)\n"),
		(unsigned long)section->size);
d1853 3
a1855 2
	warn (_("Debug info is corrupted, abbrev offset is invalid (section is %lu bytes)\n"),
	      (unsigned long)debug_displays [abbrev].section.size);
d1868 1
d1872 2
d1877 1
a1877 1
	  /* A null DIE marks the end of a list of children.  */
d1881 13
d1899 1
a1899 4
		    level,
		    (unsigned long) (tags - section_begin
				     - bytes_read),
		    abbrev_number);
d1951 2
a1952 2
					    &debug_information [unit],
					    do_loc);
@


1.21
log
@* dwarf.c (display_debug_loc): Issue a warning if there are bytes at the end
  of the .debug_loc section which are not referenced by any attribute in the
  .debug_info section.
@
text
@d2630 1
a2630 1
	  section_end - start, section->name);
@


1.20
log
@* dwarf2.h: Mention the location of the DWARF3 spec on the web.
  (DW_AT_stride_size): Rename to DW_AT_bit_stride.
  (DW_AT_stride): Rename to DW_AT_byte_stride.
* dwarf.c (process_extended_line_op): Add cases for HP extensions to the line ops.
  Mention if an unknown op code is in the user defined range.
  (decode_location_expression): Add cases for HP extensions, the DW_OP_GNU_uninit extension and the DW_OP_call_frame_cfa and DW_OP_bit_piece DWARF3 operators.
  (read_and_display_attr): Correct list of attributes which can reference a location list.
  (read_and_display_attr_value): Add cases for DWARF3 values and HP extensions.
  Correct list of attributes which can reference a location list.
  (get_AT_name): Add cases for DWARF3 values and HP and PGI extensions.
@
text
@d2627 4
@


1.19
log
@* dwarf.c (is_relocatable): Remove definition.
  (display_debug_frames): Remove check in is_relocatable.
* dwarf.h (is_relocatable): Remove declaration.
* objdump.c (is_relocatable): New static definition.
* readelf.c (dump_relocations): Make the function void.
  (is_32bit_abs_reloc): Add support for x86, Arc, Arm, D10V, Dlx, OR32 and Score.
  (is_32bit_pcrel_reloc): Add support for x86 and Arm.
  (is_16bit_abs_reloc): Add support for D10V.
  (debug_apply_rela_addends): Rename to debug_apply_relocations.
  Add code to support rel relocations.
  (load_debug_section): Fix call to debug_apply_relocations.
  (get_file_header): Remove setting of is_relocatable.
* gas/cfi/cfi-common-6.d: Allow for possible relocation of the .debug.eh_frame section.
@
text
@d273 32
d306 8
a313 1
      printf (_("UNKNOWN: length %d\n"), len - bytes_read);
d934 4
a937 1
	  printf ("DW_OP_call_ref");
d942 10
d955 31
a985 1
	  printf ("DW_OP_GNU_push_tls_address");
d1208 2
d1212 4
a1215 7
	case DW_AT_allocated:
	case DW_AT_associated:
	case DW_AT_data_location:
	case DW_AT_stride:
	case DW_AT_upper_bound:
	case DW_AT_lower_bound:
	  if (form == DW_FORM_data4 || form == DW_FORM_data8)
d1237 1
a1237 1
	
d1346 1
a1346 1
	  /* DWARF 2.1 value.  */
d1349 15
d1444 2
d1448 6
d1459 1
a1459 1
    case DW_AT_lower_bound:
a1472 3
      else if (form == DW_FORM_data4 || form == DW_FORM_data8)
	printf (_("(location list)"));

d1562 46
a1607 13
      /* SGI/MIPS extensions.  */
    case DW_AT_MIPS_fde:		return "DW_AT_MIPS_fde";
    case DW_AT_MIPS_loop_begin:		return "DW_AT_MIPS_loop_begin";
    case DW_AT_MIPS_tail_loop_begin:	return "DW_AT_MIPS_tail_loop_begin";
    case DW_AT_MIPS_epilog_begin:	return "DW_AT_MIPS_epilog_begin";
    case DW_AT_MIPS_loop_unroll_factor: return "DW_AT_MIPS_loop_unroll_factor";
    case DW_AT_MIPS_software_pipeline_depth:
      return "DW_AT_MIPS_software_pipeline_depth";
    case DW_AT_MIPS_linkage_name:	return "DW_AT_MIPS_linkage_name";
    case DW_AT_MIPS_stride:		return "DW_AT_MIPS_stride";
    case DW_AT_MIPS_abstract_name:	return "DW_AT_MIPS_abstract_name";
    case DW_AT_MIPS_clone_origin:	return "DW_AT_MIPS_clone_origin";
    case DW_AT_MIPS_has_inlines:	return "DW_AT_MIPS_has_inlines";
d1616 1
d1619 6
@


1.18
log
@* dwarf.c (process_debug_info): Check for corrupt lengths.
* readelf.c (get_reloc_type): New function.  Returns the reloc number extracted from the info field of a reloc.
  (get_reloc_symindex): New function.  Returns the symbol index
  (extracted from the info field of a reloc.
  (dump_relocations): Use the new functions.
  (slurp_ia64_unwind_table): Use the new functions.
  (slurp_hppa_unwind_table): Use the new functions.
  (dump_section_as_bytes): Use the new functions.
  (get_reloc_size): Delete function.
  (is_32bit_abs_reloc): New function.  Determines if a given reloc type is a 32-bit absolute relocation.
  (is_32bit_pcrel_reloc): New function.  Like is_32bit_abs_reloc but for pc-relative relocations.
  (is_64bit_abs_reloc): New function.  Like is_32bit_abs_reloc but for 64-bit absolute relocations.
  (is_16bit_abs_reloc): New function.  Like is_32bit_abs_reloc but for 32-bit absolute relocations.
  (debug_apply_rela_addends): Use the new functions.  Skip and warn about any unrecognised relocations.
@
text
@a38 1
int is_relocatable;
d3186 1
a3186 5
	  if ((fc->fde_encoding & 0x70) == DW_EH_PE_pcrel
	      /* Don't adjust for relocatable file since there's
		 invariably a pcrel reloc here, which we haven't
		 applied.  */
	      && !is_relocatable)
d3389 1
a3389 2
	      if ((fc->fde_encoding & 0x70) == DW_EH_PE_pcrel
		  && !is_relocatable)
@


1.17
log
@* dwarf.c (process_debug_info): Line up section offsets of
attribute values with those of dies.
(read_and_display_attr): Reduce spacing here.
@
text
@d1554 9
@


1.16
log
@* dwarf.c (display_debug_lines): Print the offset of each line
number program header.
@
text
@d1508 1
a1508 1
    printf ("     %-18s:", get_AT_name (attribute));
d1750 1
a1750 1
		printf ("  <%2lx>", (unsigned long)(tags - section_begin));
@


1.15
log
@Change sources over to using GPLv3
@
text
@d1824 1
d1830 1
d1883 1
@


1.14
log
@	* dwarf.c (decode_location_expression): Add DW_OP_form_tls_address.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
@


1.13
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d898 3
@


1.12
log
@	* dwarf.c (process_debug_info): Do not require DW_AT_frame_base for
	DW_TAG_inlined_subroutine.
@
text
@d22 5
a26 2
#include <stdio.h>

a28 3
#include "bucomm.h"
#include "libiberty.h"

@


1.11
log
@Add missing cast to (unsigned long)
@
text
@a1735 1
	    case DW_TAG_inlined_subroutine:
@


1.10
log
@PR gas/3800
* readelf.c: Include elf/h8.h twice.  The first time in order to get the reloc
  numbers, the second time in order to get the reloc decoder function.
  (dump_section): Tell the user if the section being displayed has unprocessed
  relocs associated with it.
  (get_reloc_size): New function - returns the size of a reloc.
  (debug_apply_rela_addends): Use get_reloc_size().
* dwarf.c (read_and_display_attr_value): Extend number of languages known for
  the DW_AT_language attribute.
  (process_debug_info): Display the attribute offset before decoding the
  attribute, in case there are problems.
@
text
@d1748 1
a1748 1
		printf ("  <%2lx>", tags - section_begin);
@


1.9
log
@	* dwarf.c (process_debug_info): Protect against bogus length and
	abbrev offsets.
@
text
@d2 1
a2 1
   Copyright 2005, 2006
d1216 2
d1219 1
a1219 1
	case DW_LANG_C89:		printf ("(ANSI C)"); break;
d1221 2
d1225 1
a1226 4
	case DW_LANG_Pascal83:		printf ("(ANSI Pascal)"); break;
	case DW_LANG_Ada83:		printf ("(Ada)"); break;
	case DW_LANG_Cobol74:		printf ("(Cobol 74)"); break;
	case DW_LANG_Cobol85:		printf ("(Cobol 85)"); break;
d1228 1
d1232 6
d1243 4
a1246 1
	  printf ("(Unknown: %lx)", uvalue);
d1698 7
d1714 5
d1725 1
a1725 6
	    printf (_(" <%d><%lx>: Abbrev Number: %lu (%s)\n"),
		    level,
		    (unsigned long) (tags - section_begin
				     - bytes_read),
		    abbrev_number,
		    get_TAG_name (entry->tag));
d1745 14
a1758 8
	    tags = read_and_display_attr (attr->attribute,
					  attr->form,
					  tags, cu_offset,
					  compunit.cu_pointer_size,
					  offset_size,
					  compunit.cu_version,
					  &debug_information [unit],
					  do_loc);
a2533 1

@


1.8
log
@	* dwarf.c (display_debug_loc): Don't dereference loc_offsets when
	there are no location lists.
	(display_debug_ranges): Similar for range_lists.
@
text
@a1606 1
      start += compunit.cu_length + initial_length_size;
a1629 2
      tags = hdrptr;

d1639 10
d1659 9
a1667 5
      process_abbrev_section
	((unsigned char *) debug_displays [abbrev].section.start
	 + compunit.cu_abbrev_offset - debug_displays [abbrev].section.address,
	 (unsigned char *) debug_displays [abbrev].section.start
	 + debug_displays [abbrev].section.size);
@


1.7
log
@PR binutils/2768
* dwarf.c (display_debug_aranges): When the address size is greater than 4
  display addresses and lengths as 16 hex digits, otherwise use 8 hex digits.
@
text
@d2318 2
a2319 1
  if (debug_information [first].loc_offsets [0] != section->address)
d2690 2
a2691 1
  if (debug_information [first].range_lists [0] != section->address)
@


1.6
log
@* dwarf.c (display_debug_frames): Catch a corrupt length field generating an
    end of block address that is beyond the end of the section.
  When encountering a corrupt CIE pointer do not reset the start pointer as
    more data still has to be read.
  Do not warn about user defined call frame instructions.
@
text
@d2580 4
a2583 1
      printf (_("\n    Address  Length\n"));
d2604 4
a2607 1
	  printf ("    %8.8lx %lu\n", address, length);
@


1.5
log
@2006-05-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* dwarf.c (display_debug_frames): Don't return on ZERO
	terminator.
@
text
@d2522 1
d2569 11
d2584 2
a2585 2
      /* Must pad to an alignment boundary that is twice the pointer size.  */
      excess = (hdrptr - start) % (2 * arange.ar_pointer_size);
d2587 1
a2587 1
	ranges += (2 * arange.ar_pointer_size) - excess;
d2591 1
a2591 1
      while (ranges + 2 * arange.ar_pointer_size <= start)
d2593 1
a2593 1
	  address = byte_get (ranges, arange.ar_pointer_size);
d2595 1
a2595 1
	  ranges += arange.ar_pointer_size;
d2597 1
a2597 1
	  length  = byte_get (ranges, arange.ar_pointer_size);
d2599 1
a2599 1
	  ranges += arange.ar_pointer_size;
d2894 1
d2960 6
d3100 1
a3100 1
	      warn ("Invalid CIE pointer %08lx in FDE at %08lx\n",
a3101 1
	      start = block_end;
d3605 4
a3608 1
	      warn (_("unsupported or unknown DW_CFA_%d\n"), op);
@


1.4
log
@	* dwarf.c (process_extended_line_op): Remove pointer_size param.
	Use length instead to determine address size.
	(get_pointer_size_and_offset_of_comp_unit): Delete.
	(display_debug_lines): Adjust for above.
	(display_debug_aranges): Don't stop on finding two zeros.
	(display_debug_frames): For warning, print offset not pointer.
@
text
@d2930 1
a2930 1
	  return 1;
@


1.3
log
@	* dwarf.c (frame_display_row, display_debug_frames): Handle
	DW_CFA_val_offset, DW_CFA_val_offset_sf and DW_CFA_val_expression.
@
text
@d224 1
a224 1
process_extended_line_op (unsigned char *data, int is_stmt, int pointer_size)
d254 1
a254 1
      adr = byte_get (data, pointer_size);
a1768 42
/* Retrieve the pointer size associated with the given compilation unit.
   Optionally the offset of this unit into the .debug_info section is
   also retutned.  If there is no .debug_info section then an error
   message is issued and 0 is returned.  If the requested comp unit has
   not been defined in the .debug_info section then a warning message
   is issued and the last know pointer size is returned.  This message
   is only issued once per section dumped per file dumped.  */

static unsigned int
get_pointer_size_and_offset_of_comp_unit (unsigned int comp_unit,
					  const char * section_name,
					  unsigned long * offset_return)
{
  unsigned long offset = 0;

  if (num_debug_info_entries == 0)
    error (_("%s section needs a populated .debug_info section\n"),
	   section_name);

  else if (comp_unit >= num_debug_info_entries)
    {
      if (!warned_about_missing_comp_units)
	{
	  warn (_("%s section has more comp units than .debug_info section\n"),
		section_name);
	  warn (_("assuming that the pointer size is %d, from the last comp unit in .debug_info\n\n"),
		last_pointer_size);
	  warned_about_missing_comp_units = TRUE;
	}
    }
  else
    {
      last_pointer_size = debug_information [comp_unit].pointer_size;
      offset = debug_information [comp_unit].cu_offset;
    }

  if (offset_return != NULL)
    * offset_return = offset;

  return last_pointer_size;
}

a1774 1
  unsigned int comp_unit = 0;
a1786 1
      unsigned int pointer_size;
a1843 6
      /* Get the pointer size from the comp unit associated
	 with this block of line number information.  */
      pointer_size = get_pointer_size_and_offset_of_comp_unit
	(comp_unit, ".debug_line", NULL);
      comp_unit ++;

a1851 3
      printf (_("  (Pointer size:               %u)%s\n"),
	      pointer_size,
	      warned_about_missing_comp_units ? " [assumed]" : "" );
d1943 1
a1943 8
	      if (pointer_size == 0)
		{
		  warn (_("Extend line ops need a valid pointer size, guessing at 4\n"));
		  pointer_size = 4;
		}

	      data += process_extended_line_op (data, info.li_default_is_stmt,
						pointer_size);
d2577 3
a2579 1
      for (;;)
a2588 4
	  /* A pair of zeros marks the end of the list.  */
	  if (address == 0 && length == 0)
	    break;

a2590 2

      start += arange.ar_length + initial_length_size;
d3081 2
a3082 2
	      warn ("Invalid CIE pointer %08lx in FDE at %p\n",
		    cie_id, saved_start);
@


1.2
log
@2005-09-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* dwarf.c (fetch_indirect_string): Adjust for section address.
	(process_debug_info): Likewise.
	(display_debug_loc): Likewise.
	(display_debug_ranges): Likewise.

	* objdump.c (mach_o_dwarf_sections): New.
	(generic_dwarf_sections): Likewise.
	(check_mach_o_dwarf): Likewise.
	(dump_dwarf): Call check_mach_o_dwarf.
@
text
@d2 1
a2 1
   Copyright 2005
d2907 3
d2916 3
d3261 1
d3300 1
d3308 1
d3438 10
d3565 13
d3589 11
@


1.1
log
@2005-09-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.am (CFILES): Add dwarf.c.
	(readelf_SOURCES): Likewise.
	* Makefile.in: Regenerated.

	* dwarf.c: New file.
	* dwarf.h. Likewise.

	* readelf.c: Include "dwarf.h" instead of "bfd.h".
	(do_debug_info): Remove the static definition.
	(do_debug_abbrevs): Likewise.
	(do_debug_lines): Likewise.
	(do_debug_pubnames): Likewise.
	(do_debug_aranges): Likewise.
	(do_debug_ranges): Likewise.
	(do_debug_frames): Likewise.
	(do_debug_frames_interp): Likewise.
	(do_debug_macinfo): Likewise.
	(do_debug_str): Likewise.
	(do_debug_loc): Likewise.
	(is_relocatable): Likewise.
	(have_frame_base): Likewise.
	(need_base_address): Likewise.
	(eh_addr_size): Likewise.
	(error): Likewise.
	(warn): Likewise.
	(cmalloc): Likewise.
	(xcmalloc): Likewise.
	(xcrealloc): Likewise.
	(dwarf_section): Removed.
	(byte_get_little_endian): Likewise.
	(byte_get_signed): Likewise.
	(byte_get_big_endian): Likewise.
	(read_leb128): Likewise.
	(State_Machine_Registers): Likewise.
	(state_machine_regs): Likewise.
	(reset_state_machine): Likewise.
	(process_extended_line_op): Likewise.
	(debug_str_section): Likewise.
	(fetch_indirect_string): Likewise.
	(debug_abbrev_section): Likewise.
	(abbrev_attr): Likewise.
	(first_abbrev): Likewise.
	(last_abbrev): Likewise.
	(free_abbrevs): Likewise.
	(add_abbrev_attr): Likewise.
	(process_abbrev_section): Likewise.
	(get_TAG_name): Likewise.
	(get_FORM_name): Likewise.
	(display_block): Likewise.
	(decode_location_expression): Likewise.
	(debug_info): Likewise.
	(debug_information): Likewise.
	(num_debug_info_entries): Likewise.
	(last_pointer_size): Likewise.
	(warned_about_missing_comp_units): Likewise.
	(read_and_display_attr_value): Likewise.
	(get_AT_name): Likewise.
	(read_and_display_attr): Likewise.
	(process_debug_info): Likewise.
	(get_pointer_size_and_offset_of_comp_unit): Likewise.
	(get_debug_info): Likewise.
	(display_debug_lines): Likewise.
	(display_debug_pubnames): Likewise.
	(display_debug_macinfo): Likewise.
	(display_debug_abbrev): Likewise.
	(display_debug_loc): Likewise.
	(display_debug_str): Likewise.
	(display_debug_aranges): Likewise.
	(display_debug_ranges): Likewise.
	(Frame_Chunk): Likewise.
	(DW_CFA_unreferenced): Likewise.
	(frame_need_space): Likewise.
	(frame_display_row): Likewise.
	(size_of_encoded_value): Likewise.
	(get_encoded_value): Likewise.
	(GET): Likewise.
	(LEB): Likewise.
	(SLEB): Likewise.
	(display_debug_frames): Likewise.
	(display_debug_not_supported): Likewise.
	(debug_displays): Likewise.
	(load_debug_section): Updated.
	(free_debug_section): Likewise.
	(display_debug_section): Likewise.
	(process_object): Call free_debug_memory to free debug memory.
@
text
@d290 2
d1650 2
a1651 1
      /* Process the abbrevs used by this compilation unit.  */
d1654 1
a1654 1
	 + compunit.cu_abbrev_offset,
d2377 2
a2378 1
  if (debug_information [first].loc_offsets [0] != 0)
d2404 2
a2405 1
	  offset = debug_information [i].loc_offsets [j];
d2734 2
a2735 1
  if (debug_information [first].range_lists [0] != 0)
d2755 2
a2756 1
	  offset = debug_information [i].range_lists [j];
@

