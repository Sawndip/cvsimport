head	1.108;
access;
symbols
	binutils-2_24-branch:1.108.0.2
	binutils-2_24-branchpoint:1.108
	binutils-2_21_1:1.101
	binutils-2_23_2:1.106
	binutils-2_23_1:1.106
	binutils-2_23:1.106
	binutils-2_23-branch:1.106.0.2
	binutils-2_23-branchpoint:1.106
	binutils-2_22_branch:1.102.0.4
	binutils-2_22:1.102
	binutils-2_22-branch:1.102.0.2
	binutils-2_22-branchpoint:1.102
	binutils-2_21:1.101
	binutils-2_21-branch:1.101.0.2
	binutils-2_21-branchpoint:1.101
	binutils-2_20_1:1.93.2.1
	binutils-2_20:1.93
	binutils-arc-20081103-branch:1.83.0.4
	binutils-arc-20081103-branchpoint:1.83
	binutils-2_20-branch:1.93.0.2
	binutils-2_20-branchpoint:1.93
	dje-cgen-play1-branch:1.92.0.2
	dje-cgen-play1-branchpoint:1.92
	arc-20081103-branch:1.83.0.2
	arc-20081103-branchpoint:1.83
	binutils-2_19_1:1.82.2.2
	binutils-2_19:1.82
	binutils-2_19-branch:1.82.0.2
	binutils-2_19-branchpoint:1.82
	binutils-2_18:1.78
	binutils-2_18-branch:1.78.0.2
	binutils-2_18-branchpoint:1.78
	binutils-csl-coldfire-4_1-32:1.69
	binutils-csl-sourcerygxx-4_1-32:1.69
	binutils-csl-innovasic-fido-3_4_4-33:1.69
	binutils-csl-sourcerygxx-3_4_4-32:1.59.6.2
	binutils-csl-coldfire-4_1-30:1.69
	binutils-csl-sourcerygxx-4_1-30:1.69
	binutils-csl-coldfire-4_1-28:1.69
	binutils-csl-sourcerygxx-4_1-29:1.69
	binutils-csl-sourcerygxx-4_1-28:1.69
	binutils-csl-arm-2006q3-27:1.69
	binutils-csl-sourcerygxx-4_1-27:1.69
	binutils-csl-arm-2006q3-26:1.69
	binutils-csl-sourcerygxx-4_1-26:1.69
	binutils-csl-sourcerygxx-4_1-25:1.69
	binutils-csl-sourcerygxx-4_1-24:1.69
	binutils-csl-sourcerygxx-4_1-23:1.69
	binutils-csl-sourcerygxx-4_1-21:1.69
	binutils-csl-arm-2006q3-21:1.69
	binutils-csl-sourcerygxx-4_1-22:1.69
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.69
	binutils-csl-sourcerygxx-4_1-20:1.69
	binutils-csl-arm-2006q3-19:1.69
	binutils-csl-sourcerygxx-4_1-19:1.69
	binutils-csl-sourcerygxx-4_1-18:1.69
	binutils-csl-renesas-4_1-9:1.69
	binutils-csl-sourcerygxx-3_4_4-25:1.59.6.2
	binutils-csl-renesas-4_1-8:1.69
	binutils-csl-renesas-4_1-7:1.69
	binutils-csl-renesas-4_1-6:1.69
	binutils-csl-sourcerygxx-4_1-17:1.69
	binutils-csl-sourcerygxx-4_1-14:1.69
	binutils-csl-sourcerygxx-4_1-15:1.69
	binutils-csl-sourcerygxx-4_1-13:1.69
	binutils-2_17:1.69
	binutils-csl-sourcerygxx-4_1-12:1.69
	binutils-csl-sourcerygxx-3_4_4-21:1.69
	binutils-csl-wrs-linux-3_4_4-24:1.59
	binutils-csl-wrs-linux-3_4_4-23:1.59
	binutils-csl-sourcerygxx-4_1-9:1.69
	binutils-csl-sourcerygxx-4_1-8:1.69
	binutils-csl-sourcerygxx-4_1-7:1.69
	binutils-csl-arm-2006q1-6:1.69
	binutils-csl-sourcerygxx-4_1-6:1.69
	binutils-csl-wrs-linux-3_4_4-22:1.59
	binutils-csl-coldfire-4_1-11:1.69
	binutils-csl-sourcerygxx-3_4_4-19:1.69
	binutils-csl-coldfire-4_1-10:1.69
	binutils-csl-sourcerygxx-4_1-5:1.69
	binutils-csl-sourcerygxx-4_1-4:1.69
	binutils-csl-wrs-linux-3_4_4-21:1.59
	binutils-csl-morpho-4_1-4:1.69
	binutils-csl-sourcerygxx-3_4_4-17:1.69
	binutils-csl-wrs-linux-3_4_4-20:1.59
	binutils-2_17-branch:1.69.0.4
	binutils-2_17-branchpoint:1.69
	binutils-csl-2_17-branch:1.69.0.2
	binutils-csl-2_17-branchpoint:1.69
	binutils-csl-gxxpro-3_4-branch:1.59.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.59
	binutils-2_16_1:1.59
	binutils-csl-arm-2005q1b:1.59
	binutils-2_16:1.59
	binutils-csl-arm-2005q1a:1.59
	binutils-csl-arm-2005q1-branch:1.59.0.4
	binutils-csl-arm-2005q1-branchpoint:1.59
	binutils-2_16-branch:1.59.0.2
	binutils-2_16-branchpoint:1.59
	csl-arm-2004-q3d:1.55
	csl-arm-2004-q3:1.53
	binutils-2_15:1.46.6.1
	binutils-2_15-branchpoint:1.46
	csl-arm-2004-q1a:1.48
	csl-arm-2004-q1:1.48
	binutils-2_15-branch:1.46.0.6
	cagney_bfdfile-20040213-branch:1.46.0.4
	cagney_bfdfile-20040213-branchpoint:1.46
	cagney_bigcore-20040122-branch:1.46.0.2
	cagney_bigcore-20040122-branchpoint:1.46
	csl-arm-2003-q4:1.46
	binutils-2_14:1.40
	binutils-2_14-branch:1.40.0.2
	binutils-2_14-branchpoint:1.40
	binutils-2_13_2_1:1.35
	binutils-2_13_2:1.35
	binutils-2_13_1:1.35
	binutils-2_13:1.35
	binutils-2_13-branchpoint:1.35
	binutils-2_13-branch:1.35.0.2
	binutils-2_12_1:1.32.2.2
	binutils-2_12:1.32
	binutils-2_12-branch:1.32.0.2
	binutils-2_12-branchpoint:1.32
	cygnus_cvs_20020108_pre:1.31
	binutils-2_11_2:1.26.2.1
	binutils-2_11_1:1.26.2.1
	binutils-2_11:1.26
	x86_64versiong3:1.26
	binutils-2_11-branch:1.26.0.2
	binutils-2_10_1:1.24.2.1
	binutils-2_10:1.24.2.1
	binutils-2_10-branch:1.24.0.2
	binutils-2_10-branchpoint:1.24
	binutils_latest_snapshot:1.108
	repo-unification-2000-02-06:1.23
	binu_ss_19990721:1.9
	binu_ss_19990602:1.5
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.108
date	2012.10.29.10.09.28;	author amodra;	state Exp;
branches;
next	1.107;

1.107
date	2012.08.03.16.33.04;	author tromey;	state Exp;
branches;
next	1.106;

1.106
date	2012.05.05.03.05.26;	author amodra;	state Exp;
branches;
next	1.105;

1.105
date	2012.02.21.16.10.12;	author ktietz;	state Exp;
branches;
next	1.104;

1.104
date	2012.02.09.04.51.44;	author amodra;	state Exp;
branches;
next	1.103;

1.103
date	2011.10.13.15.33.32;	author nickc;	state Exp;
branches;
next	1.102;

1.102
date	2010.12.01.14.15.06;	author ktietz;	state Exp;
branches;
next	1.101;

1.101
date	2010.10.30.17.14.02;	author ktietz;	state Exp;
branches;
next	1.100;

1.100
date	2010.04.27.17.28.14;	author ktietz;	state Exp;
branches;
next	1.99;

1.99
date	2009.12.11.13.42.05;	author nickc;	state Exp;
branches;
next	1.98;

1.98
date	2009.12.02.14.04.17;	author nickc;	state Exp;
branches;
next	1.97;

1.97
date	2009.10.28.17.21.36;	author ktietz;	state Exp;
branches;
next	1.96;

1.96
date	2009.10.23.14.53.56;	author ktietz;	state Exp;
branches;
next	1.95;

1.95
date	2009.10.18.23.11.35;	author amodra;	state Exp;
branches;
next	1.94;

1.94
date	2009.10.16.14.02.55;	author nickc;	state Exp;
branches;
next	1.93;

1.93
date	2009.09.04.01.22.18;	author davek;	state Exp;
branches
	1.93.2.1;
next	1.92;

1.92
date	2009.04.01.17.20.18;	author davek;	state Exp;
branches;
next	1.91;

1.91
date	2009.01.26.15.52.55;	author nickc;	state Exp;
branches;
next	1.90;

1.90
date	2009.01.14.11.55.43;	author nickc;	state Exp;
branches;
next	1.89;

1.89
date	2009.01.13.09.23.50;	author nickc;	state Exp;
branches;
next	1.88;

1.88
date	2009.01.12.10.14.13;	author ktietz;	state Exp;
branches;
next	1.87;

1.87
date	2009.01.08.13.29.14;	author ktietz;	state Exp;
branches;
next	1.86;

1.86
date	2008.11.25.08.48.49;	author nickc;	state Exp;
branches;
next	1.85;

1.85
date	2008.11.16.06.00.41;	author dannysmith;	state Exp;
branches;
next	1.84;

1.84
date	2008.11.15.18.15.18;	author cwilson;	state Exp;
branches;
next	1.83;

1.83
date	2008.10.09.09.00.08;	author ktietz;	state Exp;
branches;
next	1.82;

1.82
date	2008.07.30.04.34.56;	author amodra;	state Exp;
branches
	1.82.2.1;
next	1.81;

1.81
date	2008.03.28.06.49.44;	author nickc;	state Exp;
branches;
next	1.80;

1.80
date	2008.02.12.12.33.51;	author nickc;	state Exp;
branches;
next	1.79;

1.79
date	2007.10.04.13.38.09;	author nickc;	state Exp;
branches;
next	1.78;

1.78
date	2007.07.05.16.54.45;	author nickc;	state Exp;
branches;
next	1.77;

1.77
date	2007.06.27.11.54.09;	author amodra;	state Exp;
branches;
next	1.76;

1.76
date	2007.04.26.14.46.59;	author amodra;	state Exp;
branches;
next	1.75;

1.75
date	2007.03.16.15.13.21;	author nickc;	state Exp;
branches;
next	1.74;

1.74
date	2007.02.17.13.33.54;	author jsm28;	state Exp;
branches;
next	1.73;

1.73
date	2007.02.02.13.59.54;	author hjl;	state Exp;
branches;
next	1.72;

1.72
date	2006.09.20.11.35.11;	author nickc;	state Exp;
branches;
next	1.71;

1.71
date	2006.09.16.18.12.17;	author nickc;	state Exp;
branches;
next	1.70;

1.70
date	2006.08.21.08.12.45;	author nickc;	state Exp;
branches;
next	1.69;

1.69
date	2006.03.09.21.50.53;	author dannysmith;	state Exp;
branches;
next	1.68;

1.68
date	2006.03.09.20.28.49;	author dannysmith;	state Exp;
branches;
next	1.67;

1.67
date	2005.10.03.19.37.44;	author mmitchel;	state Exp;
branches;
next	1.66;

1.66
date	2005.09.30.20.04.21;	author mmitchel;	state Exp;
branches;
next	1.65;

1.65
date	2005.09.30.16.37.31;	author mmitchel;	state Exp;
branches;
next	1.64;

1.64
date	2005.08.01.16.54.07;	author nickc;	state Exp;
branches;
next	1.63;

1.63
date	2005.07.08.05.32.46;	author bje;	state Exp;
branches;
next	1.62;

1.62
date	2005.07.07.19.27.33;	author wilson;	state Exp;
branches;
next	1.61;

1.61
date	2005.05.08.14.17.38;	author nickc;	state Exp;
branches;
next	1.60;

1.60
date	2005.05.02.23.41.39;	author bje;	state Exp;
branches;
next	1.59;

1.59
date	2005.02.23.12.25.57;	author amodra;	state Exp;
branches
	1.59.6.1;
next	1.58;

1.58
date	2005.01.21.05.40.23;	author bje;	state Exp;
branches;
next	1.57;

1.57
date	2005.01.16.09.25.06;	author dannysmith;	state Exp;
branches;
next	1.56;

1.56
date	2004.12.06.05.45.27;	author bje;	state Exp;
branches;
next	1.55;

1.55
date	2004.10.23.17.26.35;	author nickc;	state Exp;
branches;
next	1.54;

1.54
date	2004.10.08.09.49.14;	author nickc;	state Exp;
branches;
next	1.53;

1.53
date	2004.09.04.10.08.11;	author dannysmith;	state Exp;
branches;
next	1.52;

1.52
date	2004.09.02.15.55.36;	author nickc;	state Exp;
branches;
next	1.51;

1.51
date	2004.07.12.17.07.54;	author nickc;	state Exp;
branches;
next	1.50;

1.50
date	2004.07.09.16.20.05;	author nickc;	state Exp;
branches;
next	1.49;

1.49
date	2004.06.15.01.19.13;	author amodra;	state Exp;
branches;
next	1.48;

1.48
date	2004.03.08.11.50.36;	author nickc;	state Exp;
branches;
next	1.47;

1.47
date	2004.02.21.21.28.22;	author cgf;	state Exp;
branches;
next	1.46;

1.46
date	2003.11.25.19.50.03;	author dannysmith;	state Exp;
branches
	1.46.6.1;
next	1.45;

1.45
date	2003.10.27.13.20.32;	author kazu;	state Exp;
branches;
next	1.44;

1.44
date	2003.09.15.14.40.44;	author green;	state Exp;
branches;
next	1.43;

1.43
date	2003.09.14.12.20.16;	author aj;	state Exp;
branches;
next	1.42;

1.42
date	2003.07.05.13.49.50;	author cgf;	state Exp;
branches;
next	1.41;

1.41
date	2003.07.05.02.58.29;	author cgf;	state Exp;
branches;
next	1.40;

1.40
date	2003.03.22.21.04.50;	author dannysmith;	state Exp;
branches;
next	1.39;

1.39
date	2003.02.20.03.31.42;	author cgf;	state Exp;
branches;
next	1.38;

1.38
date	2002.12.12.21.10.09;	author amodra;	state Exp;
branches;
next	1.37;

1.37
date	2002.11.30.08.39.41;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2002.11.06.19.36.17;	author nickc;	state Exp;
branches;
next	1.35;

1.35
date	2002.05.20.18.23.05;	author kazu;	state Exp;
branches;
next	1.34;

1.34
date	2002.05.05.23.25.27;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2002.03.01.15.34.32;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2002.01.23.16.12.55;	author nickc;	state Exp;
branches
	1.32.2.1;
next	1.31;

1.31
date	2001.09.19.05.33.15;	author hjl;	state Exp;
branches;
next	1.30;

1.30
date	2001.04.17.23.28.38;	author dj;	state Exp;
branches;
next	1.29;

1.29
date	2001.03.30.01.34.54;	author dj;	state Exp;
branches;
next	1.28;

1.28
date	2001.03.14.02.56.45;	author cgf;	state Exp;
branches;
next	1.27;

1.27
date	2001.03.13.06.43.57;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	2000.12.19.22.22.02;	author nickc;	state Exp;
branches
	1.26.2.1;
next	1.25;

1.25
date	2000.04.07.04.34.50;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2000.02.24.19.37.32;	author nickc;	state Exp;
branches
	1.24.2.1;
next	1.23;

1.23
date	2000.01.20.23.42.51;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2000.01.05.00.04.43;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2000.01.04.23.59.42;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	99.12.23.18.41.13;	author aph;	state Exp;
branches;
next	1.19;

1.19
date	99.12.17.18.40.42;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	99.12.17.18.38.37;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	99.12.09.17.42.25;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	99.11.03.18.16.52;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	99.11.03.10.56.31;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	99.10.26.10.10.51;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	99.10.22.15.50.28;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	99.09.28.20.08.37;	author dj;	state Exp;
branches;
next	1.11;

1.11
date	99.08.19.13.11.30;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	99.08.18.14.52.58;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	99.06.22.22.50.19;	author ian;	state Exp;
branches;
next	1.8;

1.8
date	99.06.22.20.39.43;	author ian;	state Exp;
branches;
next	1.7;

1.7
date	99.06.21.03.25.35;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	99.06.03.13.22.45;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	99.06.02.12.37.48;	author rth;	state Exp;
branches;
next	1.4;

1.4
date	99.05.16.14.12.20;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	99.05.15.15.25.22;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	99.05.05.19.02.14;	author clm;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.29.09;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.93.2.1
date	2009.10.18.23.12.50;	author amodra;	state Exp;
branches;
next	;

1.82.2.1
date	2008.12.01.10.05.34;	author nickc;	state Exp;
branches;
next	1.82.2.2;

1.82.2.2
date	2008.12.23.11.49.58;	author nickc;	state Exp;
branches;
next	;

1.59.6.1
date	2005.08.30.19.57.32;	author mmitchel;	state Exp;
branches;
next	1.59.6.2;

1.59.6.2
date	2005.11.29.03.45.00;	author mmitchel;	state Exp;
branches;
next	;

1.46.6.1
date	2004.04.09.18.28.06;	author drow;	state Exp;
branches;
next	;

1.32.2.1
date	2002.04.27.12.45.11;	author amodra;	state Exp;
branches;
next	1.32.2.2;

1.32.2.2
date	2002.05.09.11.53.25;	author amodra;	state Exp;
branches;
next	;

1.26.2.1
date	2001.06.07.03.12.27;	author amodra;	state Exp;
branches;
next	;

1.24.2.1
date	2000.04.07.04.39.24;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.09;	author rth;	state Exp;
branches;
next	;


desc
@@


1.108
log
@binutils/
	* dlltool.c (INIT_SEC_DATA): Move.
	(secdata <DLLTOOL_PPC>): Use here too.
binutils/testsuite/
	* binutils-all/copy-3.d: Exclude all cygwin and mingw targets,
	and rs6000.
gas/
	* config/tc-ppc.c (ppc_znop): Remove unused vars.
ld/
	* configure.tgt (powerpcle-pe,winnt,cygwin): Add deffilep.o
	and pe-dll.o.
@
text
@/* dlltool.c -- tool to generate stuff for PE style DLLs
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
   2005, 2006, 2007, 2008, 2009, 2011, 2012 Free Software Foundation, Inc.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */


/* This program allows you to build the files necessary to create
   DLLs to run on a system which understands PE format image files.
   (eg, Windows NT)

   See "Peering Inside the PE: A Tour of the Win32 Portable Executable
   File Format", MSJ 1994, Volume 9 for more information.
   Also see "Microsoft Portable Executable and Common Object File Format,
   Specification 4.1" for more information.

   A DLL contains an export table which contains the information
   which the runtime loader needs to tie up references from a
   referencing program.

   The export table is generated by this program by reading
   in a .DEF file or scanning the .a and .o files which will be in the
   DLL.  A .o file can contain information in special  ".drectve" sections
   with export information.

   A DEF file contains any number of the following commands:


   NAME <name> [ , <base> ]
   The result is going to be <name>.EXE

   LIBRARY <name> [ , <base> ]
   The result is going to be <name>.DLL

   EXPORTS  ( (  ( <name1> [ = <name2> ] )
               | ( <name1> = <module-name> . <external-name>))
            [ @@ <integer> ] [ NONAME ] [CONSTANT] [DATA] [PRIVATE] ) *
   Declares name1 as an exported symbol from the
   DLL, with optional ordinal number <integer>.
   Or declares name1 as an alias (forward) of the function <external-name>
   in the DLL <module-name>.

   IMPORTS  (  (   <internal-name> =   <module-name> . <integer> )
             | ( [ <internal-name> = ] <module-name> . <external-name> )) *
   Declares that <external-name> or the exported function whose ordinal number
   is <integer> is to be imported from the file <module-name>.  If
   <internal-name> is specified then this is the name that the imported
   function will be refereed to in the body of the DLL.

   DESCRIPTION <string>
   Puts <string> into output .exp file in the .rdata section

   [STACKSIZE|HEAPSIZE] <number-reserve> [ , <number-commit> ]
   Generates --stack|--heap <number-reserve>,<number-commit>
   in the output .drectve section.  The linker will
   see this and act upon it.

   [CODE|DATA] <attr>+
   SECTIONS ( <sectionname> <attr>+ )*
   <attr> = READ | WRITE | EXECUTE | SHARED
   Generates --attr <sectionname> <attr> in the output
   .drectve section.  The linker will see this and act
   upon it.


   A -export:<name> in a .drectve section in an input .o or .a
   file to this program is equivalent to a EXPORTS <name>
   in a .DEF file.



   The program generates output files with the prefix supplied
   on the command line, or in the def file, or taken from the first
   supplied argument.

   The .exp.s file contains the information necessary to export
   the routines in the DLL.  The .lib.s file contains the information
   necessary to use the DLL's routines from a referencing program.



   Example:

 file1.c:
   asm (".section .drectve");
   asm (".ascii \"-export:adef\"");

   void adef (char * s)
   {
     printf ("hello from the dll %s\n", s);
   }

   void bdef (char * s)
   {
     printf ("hello from the dll and the other entry point %s\n", s);
   }

 file2.c:
   asm (".section .drectve");
   asm (".ascii \"-export:cdef\"");
   asm (".ascii \"-export:ddef\"");

   void cdef (char * s)
   {
     printf ("hello from the dll %s\n", s);
   }

   void ddef (char * s)
   {
     printf ("hello from the dll and the other entry point %s\n", s);
   }

   int printf (void)
   {
     return 9;
   }

 themain.c:
   int main (void)
   {
     cdef ();
     return 0;
   }

 thedll.def

   LIBRARY thedll
   HEAPSIZE 0x40000, 0x2000
   EXPORTS bdef @@ 20
           cdef @@ 30 NONAME

   SECTIONS donkey READ WRITE
   aardvark EXECUTE

 # Compile up the parts of the dll and the program

   gcc -c file1.c file2.c themain.c

 # Optional: put the dll objects into a library
 # (you don't have to, you could name all the object
 # files on the dlltool line)

   ar  qcv thedll.in file1.o file2.o
   ranlib thedll.in

 # Run this tool over the DLL's .def file and generate an exports
 # file (thedll.o) and an imports file (thedll.a).
 # (You may have to use -S to tell dlltool where to find the assembler).

   dlltool --def thedll.def --output-exp thedll.o --output-lib thedll.a

 # Build the dll with the library and the export table

   ld -o thedll.dll thedll.o thedll.in

 # Link the executable with the import library

   gcc -o themain.exe themain.o thedll.a

 This example can be extended if relocations are needed in the DLL:

 # Compile up the parts of the dll and the program

   gcc -c file1.c file2.c themain.c

 # Run this tool over the DLL's .def file and generate an imports file.

   dlltool --def thedll.def --output-lib thedll.lib

 # Link the executable with the import library and generate a base file
 # at the same time

   gcc -o themain.exe themain.o thedll.lib -Wl,--base-file -Wl,themain.base

 # Run this tool over the DLL's .def file and generate an exports file
 # which includes the relocations from the base file.

   dlltool --def thedll.def --base-file themain.base --output-exp thedll.exp

 # Build the dll with file1.o, file2.o and the export table

   ld -o thedll.dll thedll.exp file1.o file2.o  */

/* .idata section description

   The .idata section is the import table.  It is a collection of several
   subsections used to keep the pieces for each dll together: .idata$[234567].
   IE: Each dll's .idata$2's are catenated together, each .idata$3's, etc.

   .idata$2 = Import Directory Table
   = array of IMAGE_IMPORT_DESCRIPTOR's.

	DWORD   Import Lookup Table;  - pointer to .idata$4
	DWORD   TimeDateStamp;        - currently always 0
	DWORD   ForwarderChain;       - currently always 0
	DWORD   Name;                 - pointer to dll's name
	PIMAGE_THUNK_DATA FirstThunk; - pointer to .idata$5

   .idata$3 = null terminating entry for .idata$2.

   .idata$4 = Import Lookup Table
   = array of array of pointers to hint name table.
   There is one for each dll being imported from, and each dll's set is
   terminated by a trailing NULL.

   .idata$5 = Import Address Table
   = array of array of pointers to hint name table.
   There is one for each dll being imported from, and each dll's set is
   terminated by a trailing NULL.
   Initially, this table is identical to the Import Lookup Table.  However,
   at load time, the loader overwrites the entries with the address of the
   function.

   .idata$6 = Hint Name Table
   = Array of { short, asciz } entries, one for each imported function.
   The `short' is the function's ordinal number.

   .idata$7 = dll name (eg: "kernel32.dll"). (.idata$6 for ppc).  */

#include "sysdep.h"
#include "bfd.h"
#include "libiberty.h"
#include "getopt.h"
#include "demangle.h"
#include "dyn-string.h"
#include "bucomm.h"
#include "dlltool.h"
#include "safe-ctype.h"

#include <time.h>
#include <assert.h>

#ifdef DLLTOOL_ARM
#include "coff/arm.h"
#include "coff/internal.h"
#endif
#ifdef DLLTOOL_DEFAULT_MX86_64
#include "coff/x86_64.h"
#endif
#ifdef DLLTOOL_DEFAULT_I386
#include "coff/i386.h"
#endif

#ifndef COFF_PAGE_SIZE
#define COFF_PAGE_SIZE ((bfd_vma) 4096)
#endif

#ifndef PAGE_MASK
#define PAGE_MASK ((bfd_vma) (- COFF_PAGE_SIZE))
#endif

/* Get current BFD error message.  */
#define bfd_get_errmsg() (bfd_errmsg (bfd_get_error ()))

/* Forward references.  */
static char *look_for_prog (const char *, const char *, int);
static char *deduce_name (const char *);

#ifdef DLLTOOL_MCORE_ELF
static void mcore_elf_cache_filename (const char *);
static void mcore_elf_gen_out_file (void);
#endif

#ifdef HAVE_SYS_WAIT_H
#include <sys/wait.h>
#else /* ! HAVE_SYS_WAIT_H */
#if ! defined (_WIN32) || defined (__CYGWIN32__)
#ifndef WIFEXITED
#define WIFEXITED(w)	(((w) & 0377) == 0)
#endif
#ifndef WIFSIGNALED
#define WIFSIGNALED(w)	(((w) & 0377) != 0177 && ((w) & ~0377) == 0)
#endif
#ifndef WTERMSIG
#define WTERMSIG(w)	((w) & 0177)
#endif
#ifndef WEXITSTATUS
#define WEXITSTATUS(w)	(((w) >> 8) & 0377)
#endif
#else /* defined (_WIN32) && ! defined (__CYGWIN32__) */
#ifndef WIFEXITED
#define WIFEXITED(w)	(((w) & 0xff) == 0)
#endif
#ifndef WIFSIGNALED
#define WIFSIGNALED(w)	(((w) & 0xff) != 0 && ((w) & 0xff) != 0x7f)
#endif
#ifndef WTERMSIG
#define WTERMSIG(w)	((w) & 0x7f)
#endif
#ifndef WEXITSTATUS
#define WEXITSTATUS(w)	(((w) & 0xff00) >> 8)
#endif
#endif /* defined (_WIN32) && ! defined (__CYGWIN32__) */
#endif /* ! HAVE_SYS_WAIT_H */

#define show_allnames 0

/* ifunc and ihead data structures: ttk@@cygnus.com 1997

   When IMPORT declarations are encountered in a .def file the
   function import information is stored in a structure referenced by
   the global variable IMPORT_LIST.  The structure is a linked list
   containing the names of the dll files each function is imported
   from and a linked list of functions being imported from that dll
   file.  This roughly parallels the structure of the .idata section
   in the PE object file.

   The contents of .def file are interpreted from within the
   process_def_file function.  Every time an IMPORT declaration is
   encountered, it is broken up into its component parts and passed to
   def_import.  IMPORT_LIST is initialized to NULL in function main.  */

typedef struct ifunct
{
  char *         name;   /* Name of function being imported.  */
  char *     its_name;	 /* Optional import table symbol name.  */
  int            ord;    /* Two-byte ordinal value associated with function.  */
  struct ifunct *next;
} ifunctype;

typedef struct iheadt
{
  char *         dllname;  /* Name of dll file imported from.  */
  long           nfuncs;   /* Number of functions in list.  */
  struct ifunct *funchead; /* First function in list.  */
  struct ifunct *functail; /* Last  function in list.  */
  struct iheadt *next;     /* Next dll file in list.  */
} iheadtype;

/* Structure containing all import information as defined in .def file
   (qv "ihead structure").  */

static iheadtype *import_list = NULL;
static char *as_name = NULL;
static char * as_flags = "";
static char *tmp_prefix;
static int no_idata4;
static int no_idata5;
static char *exp_name;
static char *imp_name;
static char *delayimp_name;
static char *identify_imp_name;
static bfd_boolean identify_strict;

/* Types used to implement a linked list of dllnames associated
   with the specified import lib. Used by the identify_* code.
   The head entry is acts as a sentinal node and is always empty
   (head->dllname is NULL).  */
typedef struct dll_name_list_node_t
{
  char *                        dllname;
  struct dll_name_list_node_t * next;
} dll_name_list_node_type;

typedef struct dll_name_list_t
{
  dll_name_list_node_type * head;
  dll_name_list_node_type * tail;
} dll_name_list_type; 

/* Types used to pass data to iterator functions.  */
typedef struct symname_search_data_t
{
  const char * symname;
  bfd_boolean  found;
} symname_search_data_type;

typedef struct identify_data_t
{
   dll_name_list_type * list;
   bfd_boolean          ms_style_implib;
} identify_data_type; 


static char *head_label;
static char *imp_name_lab;
static char *dll_name;
static int dll_name_set_by_exp_name;
static int add_indirect = 0;
static int add_underscore = 0;
static int add_stdcall_underscore = 0;
/* This variable can hold three different values. The value
   -1 (default) means that default underscoring should be used,
   zero means that no underscoring should be done, and one
   indicates that underscoring should be done.  */
static int leading_underscore = -1;
static int dontdeltemps = 0;

/* TRUE if we should export all symbols.  Otherwise, we only export
   symbols listed in .drectve sections or in the def file.  */
static bfd_boolean export_all_symbols;

/* TRUE if we should exclude the symbols in DEFAULT_EXCLUDES when
   exporting all symbols.  */
static bfd_boolean do_default_excludes = TRUE;

static bfd_boolean use_nul_prefixed_import_tables = FALSE;

/* Default symbols to exclude when exporting all the symbols.  */
static const char *default_excludes = "DllMain@@12,DllEntryPoint@@0,impure_ptr";

/* TRUE if we should add __imp_<SYMBOL> to import libraries for backward
   compatibility to old Cygwin releases.  */
static bfd_boolean create_compat_implib;

/* TRUE if we have to write PE+ import libraries.  */
static bfd_boolean create_for_pep;

static char *def_file;

extern char * program_name;

static int machine;
static int killat;
static int add_stdcall_alias;
static const char *ext_prefix_alias;
static int verbose;
static FILE *output_def;
static FILE *base_file;

#ifdef DLLTOOL_DEFAULT_ARM
static const char *mname = "arm";
#endif

#ifdef DLLTOOL_DEFAULT_ARM_EPOC
static const char *mname = "arm-epoc";
#endif

#ifdef DLLTOOL_DEFAULT_ARM_WINCE
static const char *mname = "arm-wince";
#endif

#ifdef DLLTOOL_DEFAULT_I386
static const char *mname = "i386";
#endif

#ifdef DLLTOOL_DEFAULT_MX86_64
static const char *mname = "i386:x86-64";
#endif

#ifdef DLLTOOL_DEFAULT_PPC
static const char *mname = "ppc";
#endif

#ifdef DLLTOOL_DEFAULT_SH
static const char *mname = "sh";
#endif

#ifdef DLLTOOL_DEFAULT_MIPS
static const char *mname = "mips";
#endif

#ifdef DLLTOOL_DEFAULT_MCORE
static const char * mname = "mcore-le";
#endif

#ifdef DLLTOOL_DEFAULT_MCORE_ELF
static const char * mname = "mcore-elf";
static char * mcore_elf_out_file = NULL;
static char * mcore_elf_linker   = NULL;
static char * mcore_elf_linker_flags = NULL;

#define DRECTVE_SECTION_NAME ((machine == MMCORE_ELF || machine == MMCORE_ELF_LE) ? ".exports" : ".drectve")
#endif

#ifndef DRECTVE_SECTION_NAME
#define DRECTVE_SECTION_NAME ".drectve"
#endif

/* What's the right name for this ?  */
#define PATHMAX 250		

/* External name alias numbering starts here.  */
#define PREFIX_ALIAS_BASE	20000

char *tmp_asm_buf;
char *tmp_head_s_buf;
char *tmp_head_o_buf;
char *tmp_tail_s_buf;
char *tmp_tail_o_buf;
char *tmp_stub_buf;

#define TMP_ASM		dlltmp (&tmp_asm_buf, "%sc.s")
#define TMP_HEAD_S	dlltmp (&tmp_head_s_buf, "%sh.s")
#define TMP_HEAD_O	dlltmp (&tmp_head_o_buf, "%sh.o")
#define TMP_TAIL_S	dlltmp (&tmp_tail_s_buf, "%st.s")
#define TMP_TAIL_O	dlltmp (&tmp_tail_o_buf, "%st.o")
#define TMP_STUB	dlltmp (&tmp_stub_buf, "%ss")

/* This bit of assembly does jmp * ....  */
static const unsigned char i386_jtab[] =
{
  0xff, 0x25, 0x00, 0x00, 0x00, 0x00, 0x90, 0x90
};

static const unsigned char i386_dljtab[] =
{
  0xFF, 0x25, 0x00, 0x00, 0x00, 0x00, /* jmp __imp__function             */
  0xB8, 0x00, 0x00, 0x00, 0x00,       /* mov eax, offset __imp__function */
  0xE9, 0x00, 0x00, 0x00, 0x00        /* jmp __tailMerge__dllname        */
};

static const unsigned char i386_x64_dljtab[] =
{
  0xFF, 0x25, 0x00, 0x00, 0x00, 0x00, /* jmp __imp__function             */
  0x48, 0x8d, 0x05,		      /* leaq rax, (__imp__function) */
        0x00, 0x00, 0x00, 0x00,
  0xE9, 0x00, 0x00, 0x00, 0x00        /* jmp __tailMerge__dllname        */
};

static const unsigned char arm_jtab[] =
{
  0x00, 0xc0, 0x9f, 0xe5,	/* ldr  ip, [pc] */
  0x00, 0xf0, 0x9c, 0xe5,	/* ldr  pc, [ip] */
  0,    0,    0,    0
};

static const unsigned char arm_interwork_jtab[] =
{
  0x04, 0xc0, 0x9f, 0xe5,	/* ldr  ip, [pc] */
  0x00, 0xc0, 0x9c, 0xe5,	/* ldr  ip, [ip] */
  0x1c, 0xff, 0x2f, 0xe1,	/* bx   ip       */
  0,    0,    0,    0
};

static const unsigned char thumb_jtab[] =
{
  0x40, 0xb4,           /* push {r6}         */
  0x02, 0x4e,           /* ldr  r6, [pc, #8] */
  0x36, 0x68,           /* ldr  r6, [r6]     */
  0xb4, 0x46,           /* mov  ip, r6       */
  0x40, 0xbc,           /* pop  {r6}         */
  0x60, 0x47,           /* bx   ip           */
  0,    0,    0,    0
};

static const unsigned char mcore_be_jtab[] =
{
  0x71, 0x02,            /* lrw r1,2       */
  0x81, 0x01,            /* ld.w r1,(r1,0) */
  0x00, 0xC1,            /* jmp r1         */
  0x12, 0x00,            /* nop            */
  0x00, 0x00, 0x00, 0x00 /* <address>      */
};

static const unsigned char mcore_le_jtab[] =
{
  0x02, 0x71,            /* lrw r1,2       */
  0x01, 0x81,            /* ld.w r1,(r1,0) */
  0xC1, 0x00,            /* jmp r1         */
  0x00, 0x12,            /* nop            */
  0x00, 0x00, 0x00, 0x00 /* <address>      */
};

/* This is the glue sequence for PowerPC PE. There is a
   tocrel16-tocdefn reloc against the first instruction.
   We also need a IMGLUE reloc against the glue function
   to restore the toc saved by the third instruction in
   the glue.  */
static const unsigned char ppc_jtab[] =
{
  0x00, 0x00, 0x62, 0x81, /* lwz r11,0(r2)               */
                          /*   Reloc TOCREL16 __imp_xxx  */
  0x00, 0x00, 0x8B, 0x81, /* lwz r12,0(r11)              */
  0x04, 0x00, 0x41, 0x90, /* stw r2,4(r1)                */
  0xA6, 0x03, 0x89, 0x7D, /* mtctr r12                   */
  0x04, 0x00, 0x4B, 0x80, /* lwz r2,4(r11)               */
  0x20, 0x04, 0x80, 0x4E  /* bctr                        */
};

#ifdef DLLTOOL_PPC
/* The glue instruction, picks up the toc from the stw in
   the above code: "lwz r2,4(r1)".  */
static bfd_vma ppc_glue_insn = 0x80410004;
#endif

static const char i386_trampoline[] =  
  "\tpushl %%ecx\n"
  "\tpushl %%edx\n"
  "\tpushl %%eax\n"
  "\tpushl $__DELAY_IMPORT_DESCRIPTOR_%s\n"
  "\tcall ___delayLoadHelper2@@8\n"
  "\tpopl %%edx\n"
  "\tpopl %%ecx\n"
  "\tjmp *%%eax\n";

static const char i386_x64_trampoline[] =  
  "\tpushq %%rcx\n"
  "\tpushq %%rdx\n"
  "\tpushq %%r8\n"
  "\tpushq %%r9\n"
  "\tsubq  $40, %%rsp\n"
  "\tmovq  %%rax, %%rdx\n"
  "\tleaq  __DELAY_IMPORT_DESCRIPTOR_%s(%%rip), %%rcx\n"
  "\tcall __delayLoadHelper2\n"
  "\taddq  $40, %%rsp\n"
  "\tpopq %%r9\n"
  "\tpopq %%r8\n"
  "\tpopq %%rdx\n"
  "\tpopq %%rcx\n"
  "\tjmp *%%rax\n";

struct mac
{
  const char *type;
  const char *how_byte;
  const char *how_short;
  const char *how_long;
  const char *how_asciz;
  const char *how_comment;
  const char *how_jump;
  const char *how_global;
  const char *how_space;
  const char *how_align_short;
  const char *how_align_long;
  const char *how_default_as_switches;
  const char *how_bfd_target;
  enum bfd_architecture how_bfd_arch;
  const unsigned char *how_jtab;
  int how_jtab_size; /* Size of the jtab entry.  */
  int how_jtab_roff; /* Offset into it for the ind 32 reloc into idata 5.  */
  const unsigned char *how_dljtab;
  int how_dljtab_size; /* Size of the dljtab entry.  */
  int how_dljtab_roff1; /* Offset for the ind 32 reloc into idata 5.  */
  int how_dljtab_roff2; /* Offset for the ind 32 reloc into idata 5.  */
  int how_dljtab_roff3; /* Offset for the ind 32 reloc into idata 5.  */
  const char *trampoline;
};

static const struct mac
mtable[] =
{
  {
#define MARM 0
    "arm", ".byte", ".short", ".long", ".asciz", "@@",
    "ldr\tip,[pc]\n\tldr\tpc,[ip]\n\t.long",
    ".global", ".space", ".align\t2",".align\t4", "-mapcs-32",
    "pe-arm-little", bfd_arch_arm,
    arm_jtab, sizeof (arm_jtab), 8,
    0, 0, 0, 0, 0, 0
  }
  ,
  {
#define M386 1
    "i386", ".byte", ".short", ".long", ".asciz", "#",
    "jmp *", ".global", ".space", ".align\t2",".align\t4", "",
    "pe-i386",bfd_arch_i386,
    i386_jtab, sizeof (i386_jtab), 2,
    i386_dljtab, sizeof (i386_dljtab), 2, 7, 12, i386_trampoline
  }
  ,
  {
#define MPPC 2
    "ppc", ".byte", ".short", ".long", ".asciz", "#",
    "jmp *", ".global", ".space", ".align\t2",".align\t4", "",
    "pe-powerpcle",bfd_arch_powerpc,
    ppc_jtab, sizeof (ppc_jtab), 0,
    0, 0, 0, 0, 0, 0
  }
  ,
  {
#define MTHUMB 3
    "thumb", ".byte", ".short", ".long", ".asciz", "@@",
    "push\t{r6}\n\tldr\tr6, [pc, #8]\n\tldr\tr6, [r6]\n\tmov\tip, r6\n\tpop\t{r6}\n\tbx\tip",
    ".global", ".space", ".align\t2",".align\t4", "-mthumb-interwork",
    "pe-arm-little", bfd_arch_arm,
    thumb_jtab, sizeof (thumb_jtab), 12,
    0, 0, 0, 0, 0, 0
  }
  ,
#define MARM_INTERWORK 4
  {
    "arm_interwork", ".byte", ".short", ".long", ".asciz", "@@",
    "ldr\tip,[pc]\n\tldr\tip,[ip]\n\tbx\tip\n\t.long",
    ".global", ".space", ".align\t2",".align\t4", "-mthumb-interwork",
    "pe-arm-little", bfd_arch_arm,
    arm_interwork_jtab, sizeof (arm_interwork_jtab), 12,
    0, 0, 0, 0, 0, 0
  }
  ,
  {
#define MMCORE_BE 5
    "mcore-be", ".byte", ".short", ".long", ".asciz", "//",
    "lrw r1,[1f]\n\tld.w r1,(r1,0)\n\tjmp r1\n\tnop\n1:.long",
    ".global", ".space", ".align\t2",".align\t4", "",
    "pe-mcore-big", bfd_arch_mcore,
    mcore_be_jtab, sizeof (mcore_be_jtab), 8,
    0, 0, 0, 0, 0, 0
  }
  ,
  {
#define MMCORE_LE 6
    "mcore-le", ".byte", ".short", ".long", ".asciz", "//",
    "lrw r1,[1f]\n\tld.w r1,(r1,0)\n\tjmp r1\n\tnop\n1:.long",
    ".global", ".space", ".align\t2",".align\t4", "-EL",
    "pe-mcore-little", bfd_arch_mcore,
    mcore_le_jtab, sizeof (mcore_le_jtab), 8,
    0, 0, 0, 0, 0, 0
  }
  ,
  {
#define MMCORE_ELF 7
    "mcore-elf-be", ".byte", ".short", ".long", ".asciz", "//",
    "lrw r1,[1f]\n\tld.w r1,(r1,0)\n\tjmp r1\n\tnop\n1:.long",
    ".global", ".space", ".align\t2",".align\t4", "",
    "elf32-mcore-big", bfd_arch_mcore,
    mcore_be_jtab, sizeof (mcore_be_jtab), 8,
    0, 0, 0, 0, 0, 0
  }
  ,
  {
#define MMCORE_ELF_LE 8
    "mcore-elf-le", ".byte", ".short", ".long", ".asciz", "//",
    "lrw r1,[1f]\n\tld.w r1,(r1,0)\n\tjmp r1\n\tnop\n1:.long",
    ".global", ".space", ".align\t2",".align\t4", "-EL",
    "elf32-mcore-little", bfd_arch_mcore,
    mcore_le_jtab, sizeof (mcore_le_jtab), 8,
    0, 0, 0, 0, 0, 0
  }
  ,
  {
#define MARM_EPOC 9
    "arm-epoc", ".byte", ".short", ".long", ".asciz", "@@",
    "ldr\tip,[pc]\n\tldr\tpc,[ip]\n\t.long",
    ".global", ".space", ".align\t2",".align\t4", "",
    "epoc-pe-arm-little", bfd_arch_arm,
    arm_jtab, sizeof (arm_jtab), 8,
    0, 0, 0, 0, 0, 0
  }
  ,
  {
#define MARM_WINCE 10
    "arm-wince", ".byte", ".short", ".long", ".asciz", "@@",
    "ldr\tip,[pc]\n\tldr\tpc,[ip]\n\t.long",
    ".global", ".space", ".align\t2",".align\t4", "-mapcs-32",
    "pe-arm-wince-little", bfd_arch_arm,
    arm_jtab, sizeof (arm_jtab), 8,
    0, 0, 0, 0, 0, 0
  }
  ,
  {
#define MX86 11
    "i386:x86-64", ".byte", ".short", ".long", ".asciz", "#",
    "jmp *", ".global", ".space", ".align\t2",".align\t4", "",
    "pe-x86-64",bfd_arch_i386,
    i386_jtab, sizeof (i386_jtab), 2,
    i386_x64_dljtab, sizeof (i386_x64_dljtab), 2, 9, 14, i386_x64_trampoline
  }
  ,
  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
};

typedef struct dlist
{
  char *text;
  struct dlist *next;
}
dlist_type;

typedef struct export
{
  const char *name;
  const char *internal_name;
  const char *import_name;
  const char *its_name;
  int ordinal;
  int constant;
  int noname;		/* Don't put name in image file.  */
  int private;	/* Don't put reference in import lib.  */
  int data;
  int hint;
  int forward;	/* Number of forward label, 0 means no forward.  */
  struct export *next;
}
export_type;

/* A list of symbols which we should not export.  */

struct string_list
{
  struct string_list *next;
  char *string;
};

static struct string_list *excludes;

static const char *rvaafter (int);
static const char *rvabefore (int);
static const char *asm_prefix (int, const char *);
static void process_def_file (const char *);
static void new_directive (char *);
static void append_import (const char *, const char *, int, const char *);
static void run (const char *, char *);
static void scan_drectve_symbols (bfd *);
static void scan_filtered_symbols (bfd *, void *, long, unsigned int);
static void add_excludes (const char *);
static bfd_boolean match_exclude (const char *);
static void set_default_excludes (void);
static long filter_symbols (bfd *, void *, long, unsigned int);
static void scan_all_symbols (bfd *);
static void scan_open_obj_file (bfd *);
static void scan_obj_file (const char *);
static void dump_def_info (FILE *);
static int sfunc (const void *, const void *);
static void flush_page (FILE *, bfd_vma *, bfd_vma, int);
static void gen_def_file (void);
static void generate_idata_ofile (FILE *);
static void assemble_file (const char *, const char *);
static void gen_exp_file (void);
static const char *xlate (const char *);
static char *make_label (const char *, const char *);
static char *make_imp_label (const char *, const char *);
static bfd *make_one_lib_file (export_type *, int, int);
static bfd *make_head (void);
static bfd *make_tail (void);
static bfd *make_delay_head (void);
static void gen_lib_file (int);
static void dll_name_list_append (dll_name_list_type *, bfd_byte *);
static int  dll_name_list_count (dll_name_list_type *);
static void dll_name_list_print (dll_name_list_type *);
static void dll_name_list_free_contents (dll_name_list_node_type *);
static void dll_name_list_free (dll_name_list_type *);
static dll_name_list_type * dll_name_list_create (void);
static void identify_dll_for_implib (void);
static void identify_search_archive
  (bfd *, void (*) (bfd *, bfd *, void *),  void *);
static void identify_search_member (bfd *, bfd *, void *);
static bfd_boolean identify_process_section_p (asection *, bfd_boolean);
static void identify_search_section (bfd *, asection *, void *);
static void identify_member_contains_symname (bfd *, bfd  *, void *);

static int pfunc (const void *, const void *);
static int nfunc (const void *, const void *);
static void remove_null_names (export_type **);
static void process_duplicates (export_type **);
static void fill_ordinals (export_type **);
static void mangle_defs (void);
static void usage (FILE *, int);
static void inform (const char *, ...) ATTRIBUTE_PRINTF_1;
static void set_dll_name_from_def (const char *name, char is_dll);

static char *
prefix_encode (char *start, unsigned code)
{
  static char alpha[26] = "abcdefghijklmnopqrstuvwxyz";
  static char buf[32];
  char *p;
  strcpy (buf, start);
  p = strchr (buf, '\0');
  do
    *p++ = alpha[code % sizeof (alpha)];
  while ((code /= sizeof (alpha)) != 0);
  *p = '\0';
  return buf;
}

static char *
dlltmp (char **buf, const char *fmt)
{
  if (!*buf)
    {
      *buf = malloc (strlen (tmp_prefix) + 64);
      sprintf (*buf, fmt, tmp_prefix);
    }
  return *buf;
}

static void
inform VPARAMS ((const char * message, ...))
{
  VA_OPEN (args, message);
  VA_FIXEDARG (args, const char *, message);

  if (!verbose)
    return;

  report (message, args);

  VA_CLOSE (args);
}

static const char *
rvaafter (int mach)
{
  switch (mach)
    {
    case MARM:
    case M386:
    case MX86:
    case MPPC:
    case MTHUMB:
    case MARM_INTERWORK:
    case MMCORE_BE:
    case MMCORE_LE:
    case MMCORE_ELF:
    case MMCORE_ELF_LE:
    case MARM_EPOC:
    case MARM_WINCE:
      break;
    default:
      /* xgettext:c-format */
      fatal (_("Internal error: Unknown machine type: %d"), mach);
      break;
    }
  return "";
}

static const char *
rvabefore (int mach)
{
  switch (mach)
    {
    case MARM:
    case M386:
    case MX86:
    case MPPC:
    case MTHUMB:
    case MARM_INTERWORK:
    case MMCORE_BE:
    case MMCORE_LE:
    case MMCORE_ELF:
    case MMCORE_ELF_LE:
    case MARM_EPOC:
    case MARM_WINCE:
      return ".rva\t";
    default:
      /* xgettext:c-format */
      fatal (_("Internal error: Unknown machine type: %d"), mach);
      break;
    }
  return "";
}

static const char *
asm_prefix (int mach, const char *name)
{
  switch (mach)
    {
    case MARM:
    case MPPC:
    case MTHUMB:
    case MARM_INTERWORK:
    case MMCORE_BE:
    case MMCORE_LE:
    case MMCORE_ELF:
    case MMCORE_ELF_LE:
    case MARM_EPOC:
    case MARM_WINCE:
      break;
    case M386:
    case MX86:
      /* Symbol names starting with ? do not have a leading underscore. */
      if ((name && *name == '?') || leading_underscore == 0)
        break;
      else
        return "_";
    default:
      /* xgettext:c-format */
      fatal (_("Internal error: Unknown machine type: %d"), mach);
      break;
    }
  return "";
}

#define ASM_BYTE		mtable[machine].how_byte
#define ASM_SHORT		mtable[machine].how_short
#define ASM_LONG		mtable[machine].how_long
#define ASM_TEXT		mtable[machine].how_asciz
#define ASM_C			mtable[machine].how_comment
#define ASM_JUMP		mtable[machine].how_jump
#define ASM_GLOBAL		mtable[machine].how_global
#define ASM_SPACE		mtable[machine].how_space
#define ASM_ALIGN_SHORT		mtable[machine].how_align_short
#define ASM_RVA_BEFORE		rvabefore (machine)
#define ASM_RVA_AFTER		rvaafter (machine)
#define ASM_PREFIX(NAME)	asm_prefix (machine, (NAME))
#define ASM_ALIGN_LONG  	mtable[machine].how_align_long
#define HOW_BFD_READ_TARGET	0  /* Always default.  */
#define HOW_BFD_WRITE_TARGET	mtable[machine].how_bfd_target
#define HOW_BFD_ARCH		mtable[machine].how_bfd_arch
#define HOW_JTAB		(delay ? mtable[machine].how_dljtab \
					: mtable[machine].how_jtab)
#define HOW_JTAB_SIZE		(delay ? mtable[machine].how_dljtab_size \
					: mtable[machine].how_jtab_size)
#define HOW_JTAB_ROFF		(delay ? mtable[machine].how_dljtab_roff1 \
					: mtable[machine].how_jtab_roff)
#define HOW_JTAB_ROFF2		(delay ? mtable[machine].how_dljtab_roff2 : 0)
#define HOW_JTAB_ROFF3		(delay ? mtable[machine].how_dljtab_roff3 : 0)
#define ASM_SWITCHES		mtable[machine].how_default_as_switches

static char **oav;

static void
process_def_file (const char *name)
{
  FILE *f = fopen (name, FOPEN_RT);

  if (!f)
    /* xgettext:c-format */
    fatal (_("Can't open def file: %s"), name);

  yyin = f;

  /* xgettext:c-format */
  inform (_("Processing def file: %s"), name);

  yyparse ();

  inform (_("Processed def file"));
}

/**********************************************************************/

/* Communications with the parser.  */

static int d_nfuncs;		/* Number of functions exported.  */
static int d_named_nfuncs;	/* Number of named functions exported.  */
static int d_low_ord;		/* Lowest ordinal index.  */
static int d_high_ord;		/* Highest ordinal index.  */
static export_type *d_exports;	/* List of exported functions.  */
static export_type **d_exports_lexically;  /* Vector of exported functions in alpha order.  */
static dlist_type *d_list;	/* Descriptions.  */
static dlist_type *a_list;	/* Stuff to go in directives.  */
static int d_nforwards = 0;	/* Number of forwarded exports.  */

static int d_is_dll;
static int d_is_exe;

int
yyerror (const char * err ATTRIBUTE_UNUSED)
{
  /* xgettext:c-format */
  non_fatal (_("Syntax error in def file %s:%d"), def_file, linenumber);

  return 0;
}

void
def_exports (const char *name, const char *internal_name, int ordinal,
	     int noname, int constant, int data, int private,
	     const char *its_name)
{
  struct export *p = (struct export *) xmalloc (sizeof (*p));

  p->name = name;
  p->internal_name = internal_name ? internal_name : name;
  p->its_name = its_name;
  p->import_name = name;
  p->ordinal = ordinal;
  p->constant = constant;
  p->noname = noname;
  p->private = private;
  p->data = data;
  p->next = d_exports;
  d_exports = p;
  d_nfuncs++;

  if ((internal_name != NULL)
      && (strchr (internal_name, '.') != NULL))
    p->forward = ++d_nforwards;
  else
    p->forward = 0; /* no forward */
}

static void
set_dll_name_from_def (const char *name, char is_dll)
{
  const char *image_basename = lbasename (name);
  if (image_basename != name)
    non_fatal (_("%s: Path components stripped from image name, '%s'."),
	      def_file, name);
  /* Append the default suffix, if none specified.  */ 
  if (strchr (image_basename, '.') == 0)
    {
      const char * suffix = is_dll ? ".dll" : ".exe";

      dll_name = xmalloc (strlen (image_basename) + strlen (suffix) + 1);
      sprintf (dll_name, "%s%s", image_basename, suffix);
    }
  else
    dll_name = xstrdup (image_basename);
}

void
def_name (const char *name, int base)
{
  /* xgettext:c-format */
  inform (_("NAME: %s base: %x"), name, base);

  if (d_is_dll)
    non_fatal (_("Can't have LIBRARY and NAME"));

  if (dll_name_set_by_exp_name && name && *name != 0)
    {
      dll_name = NULL;
      dll_name_set_by_exp_name = 0;
    }
  /* If --dllname not provided, use the one in the DEF file.
     FIXME: Is this appropriate for executables?  */
  if (!dll_name)
    set_dll_name_from_def (name, 0);
  d_is_exe = 1;
}

void
def_library (const char *name, int base)
{
  /* xgettext:c-format */
  inform (_("LIBRARY: %s base: %x"), name, base);

  if (d_is_exe)
    non_fatal (_("Can't have LIBRARY and NAME"));

  if (dll_name_set_by_exp_name && name && *name != 0)
    {
      dll_name = NULL;
      dll_name_set_by_exp_name = 0;
    }

  /* If --dllname not provided, use the one in the DEF file.  */
  if (!dll_name)
    set_dll_name_from_def (name, 1);
  d_is_dll = 1;
}

void
def_description (const char *desc)
{
  dlist_type *d = (dlist_type *) xmalloc (sizeof (dlist_type));
  d->text = xstrdup (desc);
  d->next = d_list;
  d_list = d;
}

static void
new_directive (char *dir)
{
  dlist_type *d = (dlist_type *) xmalloc (sizeof (dlist_type));
  d->text = xstrdup (dir);
  d->next = a_list;
  a_list = d;
}

void
def_heapsize (int reserve, int commit)
{
  char b[200];
  if (commit > 0)
    sprintf (b, "-heap 0x%x,0x%x ", reserve, commit);
  else
    sprintf (b, "-heap 0x%x ", reserve);
  new_directive (xstrdup (b));
}

void
def_stacksize (int reserve, int commit)
{
  char b[200];
  if (commit > 0)
    sprintf (b, "-stack 0x%x,0x%x ", reserve, commit);
  else
    sprintf (b, "-stack 0x%x ", reserve);
  new_directive (xstrdup (b));
}

/* append_import simply adds the given import definition to the global
   import_list.  It is used by def_import.  */

static void
append_import (const char *symbol_name, const char *dllname, int func_ordinal,
	       const char *its_name)
{
  iheadtype **pq;
  iheadtype *q;

  for (pq = &import_list; *pq != NULL; pq = &(*pq)->next)
    {
      if (strcmp ((*pq)->dllname, dllname) == 0)
	{
	  q = *pq;
	  q->functail->next = xmalloc (sizeof (ifunctype));
	  q->functail = q->functail->next;
	  q->functail->ord  = func_ordinal;
	  q->functail->name = xstrdup (symbol_name);
	  q->functail->its_name = (its_name ? xstrdup (its_name) : NULL);
	  q->functail->next = NULL;
	  q->nfuncs++;
	  return;
	}
    }

  q = xmalloc (sizeof (iheadtype));
  q->dllname = xstrdup (dllname);
  q->nfuncs = 1;
  q->funchead = xmalloc (sizeof (ifunctype));
  q->functail = q->funchead;
  q->next = NULL;
  q->functail->name = xstrdup (symbol_name);
  q->functail->its_name = (its_name ? xstrdup (its_name) : NULL);
  q->functail->ord  = func_ordinal;
  q->functail->next = NULL;

  *pq = q;
}

/* def_import is called from within defparse.y when an IMPORT
   declaration is encountered.  Depending on the form of the
   declaration, the module name may or may not need ".dll" to be
   appended to it, the name of the function may be stored in internal
   or entry, and there may or may not be an ordinal value associated
   with it.  */

/* A note regarding the parse modes:
   In defparse.y we have to accept import declarations which follow
   any one of the following forms:
     <func_name_in_app> = <dll_name>.<func_name_in_dll>
     <func_name_in_app> = <dll_name>.<number>
     <dll_name>.<func_name_in_dll>
     <dll_name>.<number>
   Furthermore, the dll's name may or may not end with ".dll", which
   complicates the parsing a little.  Normally the dll's name is
   passed to def_import() in the "module" parameter, but when it ends
   with ".dll" it gets passed in "module" sans ".dll" and that needs
   to be reappended.

  def_import gets five parameters:
  APP_NAME - the name of the function in the application, if
             present, or NULL if not present.
  MODULE   - the name of the dll, possibly sans extension (ie, '.dll').
  DLLEXT   - the extension of the dll, if present, NULL if not present.
  ENTRY    - the name of the function in the dll, if present, or NULL.
  ORD_VAL  - the numerical tag of the function in the dll, if present,
             or NULL.  Exactly one of <entry> or <ord_val> must be
             present (i.e., not NULL).  */

void
def_import (const char *app_name, const char *module, const char *dllext,
	    const char *entry, int ord_val, const char *its_name)
{
  const char *application_name;
  char *buf;

  if (entry != NULL)
    application_name = entry;
  else
    {
      if (app_name != NULL)
	application_name = app_name;
      else
	application_name = "";
    }

  if (dllext != NULL)
    {
      buf = (char *) alloca (strlen (module) + strlen (dllext) + 2);
      sprintf (buf, "%s.%s", module, dllext);
      module = buf;
    }

  append_import (application_name, module, ord_val, its_name);
}

void
def_version (int major, int minor)
{
  printf (_("VERSION %d.%d\n"), major, minor);
}

void
def_section (const char *name, int attr)
{
  char buf[200];
  char atts[5];
  char *d = atts;
  if (attr & 1)
    *d++ = 'R';

  if (attr & 2)
    *d++ = 'W';
  if (attr & 4)
    *d++ = 'X';
  if (attr & 8)
    *d++ = 'S';
  *d++ = 0;
  sprintf (buf, "-attr %s %s", name, atts);
  new_directive (xstrdup (buf));
}

void
def_code (int attr)
{

  def_section ("CODE", attr);
}

void
def_data (int attr)
{
  def_section ("DATA", attr);
}

/**********************************************************************/

static void
run (const char *what, char *args)
{
  char *s;
  int pid, wait_status;
  int i;
  const char **argv;
  char *errmsg_fmt, *errmsg_arg;
  char *temp_base = choose_temp_base ();

  inform (_("run: %s %s"), what, args);

  /* Count the args */
  i = 0;
  for (s = args; *s; s++)
    if (*s == ' ')
      i++;
  i++;
  argv = alloca (sizeof (char *) * (i + 3));
  i = 0;
  argv[i++] = what;
  s = args;
  while (1)
    {
      while (*s == ' ')
	++s;
      argv[i++] = s;
      while (*s != ' ' && *s != 0)
	s++;
      if (*s == 0)
	break;
      *s++ = 0;
    }
  argv[i++] = NULL;

  pid = pexecute (argv[0], (char * const *) argv, program_name, temp_base,
		  &errmsg_fmt, &errmsg_arg, PEXECUTE_ONE | PEXECUTE_SEARCH);

  if (pid == -1)
    {
      inform ("%s", strerror (errno));

      fatal (errmsg_fmt, errmsg_arg);
    }

  pid = pwait (pid, & wait_status, 0);

  if (pid == -1)
    {
      /* xgettext:c-format */
      fatal (_("wait: %s"), strerror (errno));
    }
  else if (WIFSIGNALED (wait_status))
    {
      /* xgettext:c-format */
      fatal (_("subprocess got fatal signal %d"), WTERMSIG (wait_status));
    }
  else if (WIFEXITED (wait_status))
    {
      if (WEXITSTATUS (wait_status) != 0)
	/* xgettext:c-format */
	non_fatal (_("%s exited with status %d"),
		   what, WEXITSTATUS (wait_status));
    }
  else
    abort ();
}

/* Look for a list of symbols to export in the .drectve section of
   ABFD.  Pass each one to def_exports.  */

static void
scan_drectve_symbols (bfd *abfd)
{
  asection * s;
  int        size;
  char *     buf;
  char *     p;
  char *     e;

  /* Look for .drectve's */
  s = bfd_get_section_by_name (abfd, DRECTVE_SECTION_NAME);

  if (s == NULL)
    return;

  size = bfd_get_section_size (s);
  buf  = xmalloc (size);

  bfd_get_section_contents (abfd, s, buf, 0, size);

  /* xgettext:c-format */
  inform (_("Sucking in info from %s section in %s"),
	  DRECTVE_SECTION_NAME, bfd_get_filename (abfd));

  /* Search for -export: strings. The exported symbols can optionally
     have type tags (eg., -export:foo,data), so handle those as well.
     Currently only data tag is supported.  */
  p = buf;
  e = buf + size;
  while (p < e)
    {
      if (p[0] == '-'
	  && CONST_STRNEQ (p, "-export:"))
	{
	  char * name;
	  char * c;
	  flagword flags = BSF_FUNCTION;

	  p += 8;
	  /* Do we have a quoted export?  */
	  if (*p == '"')
	    {
	      p++;
	      name = p;
	      while (p < e && *p != '"')
		++p;
	    }
	  else
	    {
	      name = p;
	      while (p < e && *p != ',' && *p != ' ' && *p != '-')
		p++;
	    }
	  c = xmalloc (p - name + 1);
	  memcpy (c, name, p - name);
	  c[p - name] = 0;
	  /* Advance over trailing quote.  */
	  if (p < e && *p == '"')
	    ++p;
	  if (p < e && *p == ',')       /* found type tag.  */
	    {
	      char *tag_start = ++p;
	      while (p < e && *p != ' ' && *p != '-')
		p++;
	      if (CONST_STRNEQ (tag_start, "data"))
		flags &= ~BSF_FUNCTION;
	    }

	  /* FIXME: The 5th arg is for the `constant' field.
	     What should it be?  Not that it matters since it's not
	     currently useful.  */
	  def_exports (c, 0, -1, 0, 0, ! (flags & BSF_FUNCTION), 0, NULL);

	  if (add_stdcall_alias && strchr (c, '@@'))
	    {
	      int lead_at = (*c == '@@') ;
	      char *exported_name = xstrdup (c + lead_at);
	      char *atsym = strchr (exported_name, '@@');
	      *atsym = '\0';
	      /* Note: stdcall alias symbols can never be data.  */
	      def_exports (exported_name, xstrdup (c), -1, 0, 0, 0, 0, NULL);
	    }
	}
      else
	p++;
    }
  free (buf);
}

/* Look through the symbols in MINISYMS, and add each one to list of
   symbols to export.  */

static void
scan_filtered_symbols (bfd *abfd, void *minisyms, long symcount,
		       unsigned int size)
{
  asymbol *store;
  bfd_byte *from, *fromend;

  store = bfd_make_empty_symbol (abfd);
  if (store == NULL)
    bfd_fatal (bfd_get_filename (abfd));

  from = (bfd_byte *) minisyms;
  fromend = from + symcount * size;
  for (; from < fromend; from += size)
    {
      asymbol *sym;
      const char *symbol_name;

      sym = bfd_minisymbol_to_symbol (abfd, FALSE, from, store);
      if (sym == NULL)
	bfd_fatal (bfd_get_filename (abfd));

      symbol_name = bfd_asymbol_name (sym);
      if (bfd_get_symbol_leading_char (abfd) == symbol_name[0])
	++symbol_name;

      def_exports (xstrdup (symbol_name) , 0, -1, 0, 0,
		   ! (sym->flags & BSF_FUNCTION), 0, NULL);

      if (add_stdcall_alias && strchr (symbol_name, '@@'))
        {
	  int lead_at = (*symbol_name == '@@');
	  char *exported_name = xstrdup (symbol_name + lead_at);
	  char *atsym = strchr (exported_name, '@@');
	  *atsym = '\0';
	  /* Note: stdcall alias symbols can never be data.  */
	  def_exports (exported_name, xstrdup (symbol_name), -1, 0, 0, 0, 0, NULL);
	}
    }
}

/* Add a list of symbols to exclude.  */

static void
add_excludes (const char *new_excludes)
{
  char *local_copy;
  char *exclude_string;

  local_copy = xstrdup (new_excludes);

  exclude_string = strtok (local_copy, ",:");
  for (; exclude_string; exclude_string = strtok (NULL, ",:"))
    {
      struct string_list *new_exclude;

      new_exclude = ((struct string_list *)
		     xmalloc (sizeof (struct string_list)));
      new_exclude->string = (char *) xmalloc (strlen (exclude_string) + 2);
      /* Don't add a leading underscore for fastcall symbols.  */
      if (*exclude_string == '@@')
	sprintf (new_exclude->string, "%s", exclude_string);
      else
	sprintf (new_exclude->string, "%s%s", (!leading_underscore ? "" : "_"),
		 exclude_string);
      new_exclude->next = excludes;
      excludes = new_exclude;

      /* xgettext:c-format */
      inform (_("Excluding symbol: %s"), exclude_string);
    }

  free (local_copy);
}

/* See if STRING is on the list of symbols to exclude.  */

static bfd_boolean
match_exclude (const char *string)
{
  struct string_list *excl_item;

  for (excl_item = excludes; excl_item; excl_item = excl_item->next)
    if (strcmp (string, excl_item->string) == 0)
      return TRUE;
  return FALSE;
}

/* Add the default list of symbols to exclude.  */

static void
set_default_excludes (void)
{
  add_excludes (default_excludes);
}

/* Choose which symbols to export.  */

static long
filter_symbols (bfd *abfd, void *minisyms, long symcount, unsigned int size)
{
  bfd_byte *from, *fromend, *to;
  asymbol *store;

  store = bfd_make_empty_symbol (abfd);
  if (store == NULL)
    bfd_fatal (bfd_get_filename (abfd));

  from = (bfd_byte *) minisyms;
  fromend = from + symcount * size;
  to = (bfd_byte *) minisyms;

  for (; from < fromend; from += size)
    {
      int keep = 0;
      asymbol *sym;

      sym = bfd_minisymbol_to_symbol (abfd, FALSE, (const void *) from, store);
      if (sym == NULL)
	bfd_fatal (bfd_get_filename (abfd));

      /* Check for external and defined only symbols.  */
      keep = (((sym->flags & BSF_GLOBAL) != 0
	       || (sym->flags & BSF_WEAK) != 0
	       || bfd_is_com_section (sym->section))
	      && ! bfd_is_und_section (sym->section));

      keep = keep && ! match_exclude (sym->name);

      if (keep)
	{
	  memcpy (to, from, size);
	  to += size;
	}
    }

  return (to - (bfd_byte *) minisyms) / size;
}

/* Export all symbols in ABFD, except for ones we were told not to
   export.  */

static void
scan_all_symbols (bfd *abfd)
{
  long symcount;
  void *minisyms;
  unsigned int size;

  /* Ignore bfds with an import descriptor table.  We assume that any
     such BFD contains symbols which are exported from another DLL,
     and we don't want to reexport them from here.  */
  if (bfd_get_section_by_name (abfd, ".idata$4"))
    return;

  if (! (bfd_get_file_flags (abfd) & HAS_SYMS))
    {
      /* xgettext:c-format */
      non_fatal (_("%s: no symbols"), bfd_get_filename (abfd));
      return;
    }

  symcount = bfd_read_minisymbols (abfd, FALSE, &minisyms, &size);
  if (symcount < 0)
    bfd_fatal (bfd_get_filename (abfd));

  if (symcount == 0)
    {
      /* xgettext:c-format */
      non_fatal (_("%s: no symbols"), bfd_get_filename (abfd));
      return;
    }

  /* Discard the symbols we don't want to export.  It's OK to do this
     in place; we'll free the storage anyway.  */

  symcount = filter_symbols (abfd, minisyms, symcount, size);
  scan_filtered_symbols (abfd, minisyms, symcount, size);

  free (minisyms);
}

/* Look at the object file to decide which symbols to export.  */

static void
scan_open_obj_file (bfd *abfd)
{
  if (export_all_symbols)
    scan_all_symbols (abfd);
  else
    scan_drectve_symbols (abfd);

  /* FIXME: we ought to read in and block out the base relocations.  */

  /* xgettext:c-format */
  inform (_("Done reading %s"), bfd_get_filename (abfd));
}

static void
scan_obj_file (const char *filename)
{
  bfd * f = bfd_openr (filename, 0);

  if (!f)
    /* xgettext:c-format */
    fatal (_("Unable to open object file: %s: %s"), filename, bfd_get_errmsg ());

  /* xgettext:c-format */
  inform (_("Scanning object file %s"), filename);

  if (bfd_check_format (f, bfd_archive))
    {
      bfd *arfile = bfd_openr_next_archived_file (f, 0);
      while (arfile)
	{
	  bfd *next;
	  if (bfd_check_format (arfile, bfd_object))
	    scan_open_obj_file (arfile);
	  next = bfd_openr_next_archived_file (f, arfile);
	  bfd_close (arfile);
	  arfile = next;
	}

#ifdef DLLTOOL_MCORE_ELF
      if (mcore_elf_out_file)
	inform (_("Cannot produce mcore-elf dll from archive file: %s"), filename);
#endif
    }
  else if (bfd_check_format (f, bfd_object))
    {
      scan_open_obj_file (f);

#ifdef DLLTOOL_MCORE_ELF
      if (mcore_elf_out_file)
	mcore_elf_cache_filename (filename);
#endif
    }

  bfd_close (f);
}



static void
dump_def_info (FILE *f)
{
  int i;
  export_type *exp;
  fprintf (f, "%s ", ASM_C);
  for (i = 0; oav[i]; i++)
    fprintf (f, "%s ", oav[i]);
  fprintf (f, "\n");
  for (i = 0, exp = d_exports; exp; i++, exp = exp->next)
    {
      fprintf (f, "%s  %d = %s %s @@ %d %s%s%s%s%s%s\n",
	       ASM_C,
	       i,
	       exp->name,
	       exp->internal_name,
	       exp->ordinal,
	       exp->noname ? "NONAME " : "",
	       exp->private ? "PRIVATE " : "",
	       exp->constant ? "CONSTANT" : "",
	       exp->data ? "DATA" : "",
	       exp->its_name ? " ==" : "",
	       exp->its_name ? exp->its_name : "");
    }
}

/* Generate the .exp file.  */

static int
sfunc (const void *a, const void *b)
{
  if (*(const bfd_vma *) a == *(const bfd_vma *) b)
    return 0;

  return ((*(const bfd_vma *) a > *(const bfd_vma *) b) ? 1 : -1);
}

static void
flush_page (FILE *f, bfd_vma *need, bfd_vma page_addr, int on_page)
{
  int i;

  /* Flush this page.  */
  fprintf (f, "\t%s\t0x%08x\t%s Starting RVA for chunk\n",
	   ASM_LONG,
	   (int) page_addr,
	   ASM_C);
  fprintf (f, "\t%s\t0x%x\t%s Size of block\n",
	   ASM_LONG,
	   (on_page * 2) + (on_page & 1) * 2 + 8,
	   ASM_C);

  for (i = 0; i < on_page; i++)
    {
      bfd_vma needed = need[i];

      if (needed)
        {
	  if (!create_for_pep)
	    {
	      /* Relocation via HIGHLOW.  */
	      needed = ((needed - page_addr) | 0x3000) & 0xffff;
	    }
	  else
	    {
	      /* Relocation via DIR64.  */
	      needed = ((needed - page_addr) | 0xa000) & 0xffff;
	    }
	}

      fprintf (f, "\t%s\t0x%lx\n", ASM_SHORT, (long) needed);
    }

  /* And padding */
  if (on_page & 1)
    fprintf (f, "\t%s\t0x%x\n", ASM_SHORT, 0 | 0x0000);
}

static void
gen_def_file (void)
{
  int i;
  export_type *exp;

  inform (_("Adding exports to output file"));

  fprintf (output_def, ";");
  for (i = 0; oav[i]; i++)
    fprintf (output_def, " %s", oav[i]);

  fprintf (output_def, "\nEXPORTS\n");

  for (i = 0, exp = d_exports; exp; i++, exp = exp->next)
    {
      char *quote = strchr (exp->name, '.') ? "\"" : "";
      char *res = cplus_demangle (exp->internal_name, DMGL_ANSI | DMGL_PARAMS);

      if (res)
	{
	  fprintf (output_def,";\t%s\n", res);
	  free (res);
	}

      if (strcmp (exp->name, exp->internal_name) == 0)
	{
	  fprintf (output_def, "\t%s%s%s @@ %d%s%s%s%s%s\n",
		   quote,
		   exp->name,
		   quote,
		   exp->ordinal,
		   exp->noname ? " NONAME" : "",
		   exp->private ? "PRIVATE " : "",
		   exp->data ? " DATA" : "",
		   exp->its_name ? " ==" : "",
		   exp->its_name ? exp->its_name : "");
	}
      else
	{
	  char * quote1 = strchr (exp->internal_name, '.') ? "\"" : "";
	  /* char *alias =  */
	  fprintf (output_def, "\t%s%s%s = %s%s%s @@ %d%s%s%s%s%s\n",
		   quote,
		   exp->name,
		   quote,
		   quote1,
		   exp->internal_name,
		   quote1,
		   exp->ordinal,
		   exp->noname ? " NONAME" : "",
		   exp->private ? "PRIVATE " : "",
		   exp->data ? " DATA" : "",
		   exp->its_name ? " ==" : "",
		   exp->its_name ? exp->its_name : "");
	}
    }

  inform (_("Added exports to output file"));
}

/* generate_idata_ofile generates the portable assembly source code
   for the idata sections.  It appends the source code to the end of
   the file.  */

static void
generate_idata_ofile (FILE *filvar)
{
  iheadtype *headptr;
  ifunctype *funcptr;
  int        headindex;
  int        funcindex;
  int	     nheads;

  if (import_list == NULL)
    return;

  fprintf (filvar, "%s Import data sections\n", ASM_C);
  fprintf (filvar, "\n\t.section\t.idata$2\n");
  fprintf (filvar, "\t%s\tdoi_idata\n", ASM_GLOBAL);
  fprintf (filvar, "doi_idata:\n");

  nheads = 0;
  for (headptr = import_list; headptr != NULL; headptr = headptr->next)
    {
      fprintf (filvar, "\t%slistone%d%s\t%s %s\n",
	       ASM_RVA_BEFORE, nheads, ASM_RVA_AFTER,
	       ASM_C, headptr->dllname);
      fprintf (filvar, "\t%s\t0\n", ASM_LONG);
      fprintf (filvar, "\t%s\t0\n", ASM_LONG);
      fprintf (filvar, "\t%sdllname%d%s\n",
	       ASM_RVA_BEFORE, nheads, ASM_RVA_AFTER);
      fprintf (filvar, "\t%slisttwo%d%s\n\n",
	       ASM_RVA_BEFORE, nheads, ASM_RVA_AFTER);
      nheads++;
    }

  fprintf (filvar, "\t%s\t0\n", ASM_LONG); /* NULL record at */
  fprintf (filvar, "\t%s\t0\n", ASM_LONG); /* end of idata$2 */
  fprintf (filvar, "\t%s\t0\n", ASM_LONG); /* section        */
  fprintf (filvar, "\t%s\t0\n", ASM_LONG);
  fprintf (filvar, "\t%s\t0\n", ASM_LONG);

  fprintf (filvar, "\n\t.section\t.idata$4\n");
  headindex = 0;
  for (headptr = import_list; headptr != NULL; headptr = headptr->next)
    {
      fprintf (filvar, "listone%d:\n", headindex);
      for (funcindex = 0; funcindex < headptr->nfuncs; funcindex++)
        {
	  if (create_for_pep)
	    fprintf (filvar, "\t%sfuncptr%d_%d%s\n%s\t0\n",
		     ASM_RVA_BEFORE, headindex, funcindex, ASM_RVA_AFTER,
		     ASM_LONG);
	  else
	    fprintf (filvar, "\t%sfuncptr%d_%d%s\n",
		     ASM_RVA_BEFORE, headindex, funcindex, ASM_RVA_AFTER);
        }
      if (create_for_pep)
	fprintf (filvar, "\t%s\t0\n\t%s\t0\n", ASM_LONG, ASM_LONG);
      else
	fprintf (filvar, "\t%s\t0\n", ASM_LONG); /* NULL terminating list.  */
      headindex++;
    }

  fprintf (filvar, "\n\t.section\t.idata$5\n");
  headindex = 0;
  for (headptr = import_list; headptr != NULL; headptr = headptr->next)
    {
      fprintf (filvar, "listtwo%d:\n", headindex);
      for (funcindex = 0; funcindex < headptr->nfuncs; funcindex++)
        {
	  if (create_for_pep)
	    fprintf (filvar, "\t%sfuncptr%d_%d%s\n%s\t0\n",
		     ASM_RVA_BEFORE, headindex, funcindex, ASM_RVA_AFTER,
		     ASM_LONG);
	  else
	    fprintf (filvar, "\t%sfuncptr%d_%d%s\n",
		     ASM_RVA_BEFORE, headindex, funcindex, ASM_RVA_AFTER);
        }
      if (create_for_pep)
	fprintf (filvar, "\t%s\t0\n\t%s\t0\n", ASM_LONG, ASM_LONG);
      else
	fprintf (filvar, "\t%s\t0\n", ASM_LONG); /* NULL terminating list.  */
      headindex++;
    }

  fprintf (filvar, "\n\t.section\t.idata$6\n");
  headindex = 0;
  for (headptr = import_list; headptr != NULL; headptr = headptr->next)
    {
      funcindex = 0;
      for (funcptr = headptr->funchead; funcptr != NULL;
	   funcptr = funcptr->next)
	{
	  fprintf (filvar,"funcptr%d_%d:\n", headindex, funcindex);
	  fprintf (filvar,"\t%s\t%d\n", ASM_SHORT,
		   ((funcptr->ord) & 0xFFFF));
	  fprintf (filvar,"\t%s\t\"%s\"\n", ASM_TEXT,
	    (funcptr->its_name ? funcptr->its_name : funcptr->name));
	  fprintf (filvar,"\t%s\t0\n", ASM_BYTE);
	  funcindex++;
	}
      headindex++;
    }

  fprintf (filvar, "\n\t.section\t.idata$7\n");
  headindex = 0;
  for (headptr = import_list; headptr != NULL; headptr = headptr->next)
    {
      fprintf (filvar,"dllname%d:\n", headindex);
      fprintf (filvar,"\t%s\t\"%s\"\n", ASM_TEXT, headptr->dllname);
      fprintf (filvar,"\t%s\t0\n", ASM_BYTE);
      headindex++;
    }
}

/* Assemble the specified file.  */
static void
assemble_file (const char * source, const char * dest)
{
  char * cmd;

  cmd = (char *) alloca (strlen (ASM_SWITCHES) + strlen (as_flags)
			 + strlen (source) + strlen (dest) + 50);

  sprintf (cmd, "%s %s -o %s %s", ASM_SWITCHES, as_flags, dest, source);

  run (as_name, cmd);
}

static void
gen_exp_file (void)
{
  FILE *f;
  int i;
  export_type *exp;
  dlist_type *dl;

  /* xgettext:c-format */
  inform (_("Generating export file: %s"), exp_name);

  f = fopen (TMP_ASM, FOPEN_WT);
  if (!f)
    /* xgettext:c-format */
    fatal (_("Unable to open temporary assembler file: %s"), TMP_ASM);

  /* xgettext:c-format */
  inform (_("Opened temporary file: %s"), TMP_ASM);

  dump_def_info (f);

  if (d_exports)
    {
      fprintf (f, "\t.section	.edata\n\n");
      fprintf (f, "\t%s	0	%s Allways 0\n", ASM_LONG, ASM_C);
      fprintf (f, "\t%s	0x%lx	%s Time and date\n", ASM_LONG,
	       (unsigned long) time(0), ASM_C);
      fprintf (f, "\t%s	0	%s Major and Minor version\n", ASM_LONG, ASM_C);
      fprintf (f, "\t%sname%s	%s Ptr to name of dll\n", ASM_RVA_BEFORE, ASM_RVA_AFTER, ASM_C);
      fprintf (f, "\t%s	%d	%s Starting ordinal of exports\n", ASM_LONG, d_low_ord, ASM_C);


      fprintf (f, "\t%s	%d	%s Number of functions\n", ASM_LONG, d_high_ord - d_low_ord + 1, ASM_C);
      fprintf(f,"\t%s named funcs %d, low ord %d, high ord %d\n",
	      ASM_C,
	      d_named_nfuncs, d_low_ord, d_high_ord);
      fprintf (f, "\t%s	%d	%s Number of names\n", ASM_LONG,
	       show_allnames ? d_high_ord - d_low_ord + 1 : d_named_nfuncs, ASM_C);
      fprintf (f, "\t%safuncs%s  %s Address of functions\n", ASM_RVA_BEFORE, ASM_RVA_AFTER, ASM_C);

      fprintf (f, "\t%sanames%s	%s Address of Name Pointer Table\n",
	       ASM_RVA_BEFORE, ASM_RVA_AFTER, ASM_C);

      fprintf (f, "\t%sanords%s	%s Address of ordinals\n", ASM_RVA_BEFORE, ASM_RVA_AFTER, ASM_C);

      fprintf (f, "name:	%s	\"%s\"\n", ASM_TEXT, dll_name);


      fprintf(f,"%s Export address Table\n", ASM_C);
      fprintf(f,"\t%s\n", ASM_ALIGN_LONG);
      fprintf (f, "afuncs:\n");
      i = d_low_ord;

      for (exp = d_exports; exp; exp = exp->next)
	{
	  if (exp->ordinal != i)
	    {
	      while (i < exp->ordinal)
		{
		  fprintf(f,"\t%s\t0\n", ASM_LONG);
		  i++;
		}
	    }

	  if (exp->forward == 0)
	    {
	      if (exp->internal_name[0] == '@@')
		fprintf (f, "\t%s%s%s\t%s %d\n", ASM_RVA_BEFORE,
			 exp->internal_name, ASM_RVA_AFTER, ASM_C, exp->ordinal);
	      else
		fprintf (f, "\t%s%s%s%s\t%s %d\n", ASM_RVA_BEFORE,
			 ASM_PREFIX (exp->internal_name),
			 exp->internal_name, ASM_RVA_AFTER, ASM_C, exp->ordinal);
	    }
	  else
	    fprintf (f, "\t%sf%d%s\t%s %d\n", ASM_RVA_BEFORE,
		     exp->forward, ASM_RVA_AFTER, ASM_C, exp->ordinal);
	  i++;
	}

      fprintf (f,"%s Export Name Pointer Table\n", ASM_C);
      fprintf (f, "anames:\n");

      for (i = 0; (exp = d_exports_lexically[i]); i++)
	{
	  if (!exp->noname || show_allnames)
	    fprintf (f, "\t%sn%d%s\n",
		     ASM_RVA_BEFORE, exp->ordinal, ASM_RVA_AFTER);
	}

      fprintf (f,"%s Export Ordinal Table\n", ASM_C);
      fprintf (f, "anords:\n");
      for (i = 0; (exp = d_exports_lexically[i]); i++)
	{
	  if (!exp->noname || show_allnames)
	    fprintf (f, "\t%s	%d\n", ASM_SHORT, exp->ordinal - d_low_ord);
	}

      fprintf(f,"%s Export Name Table\n", ASM_C);
      for (i = 0; (exp = d_exports_lexically[i]); i++)
	{
	  if (!exp->noname || show_allnames)
	    fprintf (f, "n%d:	%s	\"%s\"\n",
		     exp->ordinal, ASM_TEXT,
		     (exp->its_name ? exp->its_name : xlate (exp->name)));
	  if (exp->forward != 0)
	    fprintf (f, "f%d:	%s	\"%s\"\n",
		     exp->forward, ASM_TEXT, exp->internal_name);
	}

      if (a_list)
	{
	  fprintf (f, "\t.section %s\n", DRECTVE_SECTION_NAME);
	  for (dl = a_list; dl; dl = dl->next)
	    {
	      fprintf (f, "\t%s\t\"%s\"\n", ASM_TEXT, dl->text);
	    }
	}

      if (d_list)
	{
	  fprintf (f, "\t.section .rdata\n");
	  for (dl = d_list; dl; dl = dl->next)
	    {
	      char *p;
	      int l;

	      /* We don't output as ascii because there can
	         be quote characters in the string.  */
	      l = 0;
	      for (p = dl->text; *p; p++)
		{
		  if (l == 0)
		    fprintf (f, "\t%s\t", ASM_BYTE);
		  else
		    fprintf (f, ",");
		  fprintf (f, "%d", *p);
		  if (p[1] == 0)
		    {
		      fprintf (f, ",0\n");
		      break;
		    }
		  if (++l == 10)
		    {
		      fprintf (f, "\n");
		      l = 0;
		    }
		}
	    }
	}
    }


  /* Add to the output file a way of getting to the exported names
     without using the import library.  */
  if (add_indirect)
    {
      fprintf (f, "\t.section\t.rdata\n");
      for (i = 0, exp = d_exports; exp; i++, exp = exp->next)
	if (!exp->noname || show_allnames)
	  {
	    /* We use a single underscore for MS compatibility, and a
               double underscore for backward compatibility with old
               cygwin releases.  */
	    if (create_compat_implib)
	      fprintf (f, "\t%s\t__imp_%s\n", ASM_GLOBAL, exp->name);
	    fprintf (f, "\t%s\t_imp_%s%s\n", ASM_GLOBAL,
	    	     (!leading_underscore ? "" : "_"), exp->name);
	    if (create_compat_implib)
	      fprintf (f, "__imp_%s:\n", exp->name);
	    fprintf (f, "_imp_%s%s:\n", (!leading_underscore ? "" : "_"), exp->name);
	    fprintf (f, "\t%s\t%s\n", ASM_LONG, exp->name);
	  }
    }

  /* Dump the reloc section if a base file is provided.  */
  if (base_file)
    {
      bfd_vma addr;
      bfd_vma need[COFF_PAGE_SIZE];
      bfd_vma page_addr;
      bfd_size_type numbytes;
      int num_entries;
      bfd_vma *copy;
      int j;
      int on_page;
      fprintf (f, "\t.section\t.init\n");
      fprintf (f, "lab:\n");

      fseek (base_file, 0, SEEK_END);
      numbytes = ftell (base_file);
      fseek (base_file, 0, SEEK_SET);
      copy = xmalloc (numbytes);
      if (fread (copy, 1, numbytes, base_file) < numbytes)
	fatal (_("failed to read the number of entries from base file"));
      num_entries = numbytes / sizeof (bfd_vma);


      fprintf (f, "\t.section\t.reloc\n");
      if (num_entries)
	{
	  int src;
	  int dst = 0;
	  bfd_vma last = (bfd_vma) -1;
	  qsort (copy, num_entries, sizeof (bfd_vma), sfunc);
	  /* Delete duplicates */
	  for (src = 0; src < num_entries; src++)
	    {
	      if (last != copy[src])
		last = copy[dst++] = copy[src];
	    }
	  num_entries = dst;
	  addr = copy[0];
	  page_addr = addr & PAGE_MASK;		/* work out the page addr */
	  on_page = 0;
	  for (j = 0; j < num_entries; j++)
	    {
	      addr = copy[j];
	      if ((addr & PAGE_MASK) != page_addr)
		{
		  flush_page (f, need, page_addr, on_page);
		  on_page = 0;
		  page_addr = addr & PAGE_MASK;
		}
	      need[on_page++] = addr;
	    }
	  flush_page (f, need, page_addr, on_page);

/*	  fprintf (f, "\t%s\t0,0\t%s End\n", ASM_LONG, ASM_C);*/
	}
    }

  generate_idata_ofile (f);

  fclose (f);

  /* Assemble the file.  */
  assemble_file (TMP_ASM, exp_name);

  if (dontdeltemps == 0)
    unlink (TMP_ASM);

  inform (_("Generated exports file"));
}

static const char *
xlate (const char *name)
{
  int lead_at = (*name == '@@');
  int is_stdcall = (!lead_at && strchr (name, '@@') != NULL);

  if (!lead_at && (add_underscore
		   || (add_stdcall_underscore && is_stdcall)))
    {
      char *copy = xmalloc (strlen (name) + 2);

      copy[0] = '_';
      strcpy (copy + 1, name);
      name = copy;
    }

  if (killat)
    {
      char *p;

      name += lead_at;
      /* PR 9766: Look for the last @@ sign in the name.  */
      p = strrchr (name, '@@');
      if (p && ISDIGIT (p[1]))
	*p = 0;
    }
  return name;
}

typedef struct
{
  int id;
  const char *name;
  int flags;
  int align;
  asection *sec;
  asymbol *sym;
  asymbol **sympp;
  int size;
  unsigned char *data;
} sinfo;

#define INIT_SEC_DATA(id, name, flags, align) \
        { id, name, flags, align, NULL, NULL, NULL, 0, NULL }

#ifndef DLLTOOL_PPC

#define TEXT 0
#define DATA 1
#define BSS 2
#define IDATA7 3
#define IDATA5 4
#define IDATA4 5
#define IDATA6 6

#define NSECS 7

#define TEXT_SEC_FLAGS   \
        (SEC_ALLOC | SEC_LOAD | SEC_CODE | SEC_READONLY | SEC_HAS_CONTENTS)
#define DATA_SEC_FLAGS   (SEC_ALLOC | SEC_LOAD | SEC_DATA)
#define BSS_SEC_FLAGS     SEC_ALLOC

static sinfo secdata[NSECS] =
{
  INIT_SEC_DATA (TEXT,   ".text",    TEXT_SEC_FLAGS,   2),
  INIT_SEC_DATA (DATA,   ".data",    DATA_SEC_FLAGS,   2),
  INIT_SEC_DATA (BSS,    ".bss",     BSS_SEC_FLAGS,    2),
  INIT_SEC_DATA (IDATA7, ".idata$7", SEC_HAS_CONTENTS, 2),
  INIT_SEC_DATA (IDATA5, ".idata$5", SEC_HAS_CONTENTS, 2),
  INIT_SEC_DATA (IDATA4, ".idata$4", SEC_HAS_CONTENTS, 2),
  INIT_SEC_DATA (IDATA6, ".idata$6", SEC_HAS_CONTENTS, 1)
};

#else

/* Sections numbered to make the order the same as other PowerPC NT
   compilers. This also keeps funny alignment thingies from happening.  */
#define TEXT   0
#define PDATA  1
#define RDATA  2
#define IDATA5 3
#define IDATA4 4
#define IDATA6 5
#define IDATA7 6
#define DATA   7
#define BSS    8

#define NSECS 9

static sinfo secdata[NSECS] =
{
  INIT_SEC_DATA (TEXT,   ".text",    SEC_CODE | SEC_HAS_CONTENTS, 3),
  INIT_SEC_DATA (PDATA,  ".pdata",   SEC_HAS_CONTENTS,            2),
  INIT_SEC_DATA (RDATA,  ".reldata", SEC_HAS_CONTENTS,            2),
  INIT_SEC_DATA (IDATA5, ".idata$5", SEC_HAS_CONTENTS,            2),
  INIT_SEC_DATA (IDATA4, ".idata$4", SEC_HAS_CONTENTS,            2),
  INIT_SEC_DATA (IDATA6, ".idata$6", SEC_HAS_CONTENTS,            1),
  INIT_SEC_DATA (IDATA7, ".idata$7", SEC_HAS_CONTENTS,            2),
  INIT_SEC_DATA (DATA,   ".data",    SEC_DATA,                    2),
  INIT_SEC_DATA (BSS,    ".bss",     0,                           2)
};

#endif

/* This is what we're trying to make.  We generate the imp symbols with
   both single and double underscores, for compatibility.

	.text
	.global	_GetFileVersionInfoSizeW@@8
	.global	__imp_GetFileVersionInfoSizeW@@8
_GetFileVersionInfoSizeW@@8:
	jmp *	__imp_GetFileVersionInfoSizeW@@8
	.section	.idata$7	# To force loading of head
	.long	__version_a_head
# Import Address Table
	.section	.idata$5
__imp_GetFileVersionInfoSizeW@@8:
	.rva	ID2

# Import Lookup Table
	.section	.idata$4
	.rva	ID2
# Hint/Name table
	.section	.idata$6
ID2:	.short	2
	.asciz	"GetFileVersionInfoSizeW"


   For the PowerPC, here's the variation on the above scheme:

# Rather than a simple "jmp *", the code to get to the dll function
# looks like:
         .text
         lwz	r11,[tocv]__imp_function_name(r2)
#		   RELOC: 00000000 TOCREL16,TOCDEFN __imp_function_name
         lwz	r12,0(r11)
	 stw	r2,4(r1)
	 mtctr	r12
	 lwz	r2,4(r11)
	 bctr  */

static char *
make_label (const char *prefix, const char *name)
{
  int len = strlen (ASM_PREFIX (name)) + strlen (prefix) + strlen (name);
  char *copy = xmalloc (len + 1);

  strcpy (copy, ASM_PREFIX (name));
  strcat (copy, prefix);
  strcat (copy, name);
  return copy;
}

static char *
make_imp_label (const char *prefix, const char *name)
{
  int len;
  char *copy;

  if (name[0] == '@@')
    {
      len = strlen (prefix) + strlen (name);
      copy = xmalloc (len + 1);
      strcpy (copy, prefix);
      strcat (copy, name);
    }
  else
    {
      len = strlen (ASM_PREFIX (name)) + strlen (prefix) + strlen (name);
      copy = xmalloc (len + 1);
      strcpy (copy, prefix);
      strcat (copy, ASM_PREFIX (name));
      strcat (copy, name);
    }
  return copy;
}

static bfd *
make_one_lib_file (export_type *exp, int i, int delay)
{
  bfd *      abfd;
  asymbol *  exp_label;
  asymbol *  iname = 0;
  asymbol *  iname2;
  asymbol *  iname_lab;
  asymbol ** iname_lab_pp;
  asymbol ** iname_pp;
#ifdef DLLTOOL_PPC
  asymbol ** fn_pp;
  asymbol ** toc_pp;
#define EXTRA	 2
#endif
#ifndef EXTRA
#define EXTRA    0
#endif
  asymbol *  ptrs[NSECS + 4 + EXTRA + 1];
  flagword   applicable;
  char *     outname = xmalloc (strlen (TMP_STUB) + 10);
  int        oidx = 0;


  sprintf (outname, "%s%05d.o", TMP_STUB, i);

  abfd = bfd_openw (outname, HOW_BFD_WRITE_TARGET);

  if (!abfd)
    /* xgettext:c-format */
    fatal (_("bfd_open failed open stub file: %s: %s"),
	   outname, bfd_get_errmsg ());

  /* xgettext:c-format */
  inform (_("Creating stub file: %s"), outname);

  bfd_set_format (abfd, bfd_object);
  bfd_set_arch_mach (abfd, HOW_BFD_ARCH, 0);

#ifdef DLLTOOL_ARM
  if (machine == MARM_INTERWORK || machine == MTHUMB)
    bfd_set_private_flags (abfd, F_INTERWORK);
#endif

  applicable = bfd_applicable_section_flags (abfd);

  /* First make symbols for the sections.  */
  for (i = 0; i < NSECS; i++)
    {
      sinfo *si = secdata + i;

      if (si->id != i)
	abort ();
      si->sec = bfd_make_section_old_way (abfd, si->name);
      bfd_set_section_flags (abfd,
			     si->sec,
			     si->flags & applicable);

      bfd_set_section_alignment(abfd, si->sec, si->align);
      si->sec->output_section = si->sec;
      si->sym = bfd_make_empty_symbol(abfd);
      si->sym->name = si->sec->name;
      si->sym->section = si->sec;
      si->sym->flags = BSF_LOCAL;
      si->sym->value = 0;
      ptrs[oidx] = si->sym;
      si->sympp = ptrs + oidx;
      si->size = 0;
      si->data = NULL;

      oidx++;
    }

  if (! exp->data)
    {
      exp_label = bfd_make_empty_symbol (abfd);
      exp_label->name = make_imp_label ("", exp->name);

      /* On PowerPC, the function name points to a descriptor in
	 the rdata section, the first element of which is a
	 pointer to the code (..function_name), and the second
	 points to the .toc.  */
#ifdef DLLTOOL_PPC
      if (machine == MPPC)
	exp_label->section = secdata[RDATA].sec;
      else
#endif
	exp_label->section = secdata[TEXT].sec;

      exp_label->flags = BSF_GLOBAL;
      exp_label->value = 0;

#ifdef DLLTOOL_ARM
      if (machine == MTHUMB)
	bfd_coff_set_symbol_class (abfd, exp_label, C_THUMBEXTFUNC);
#endif
      ptrs[oidx++] = exp_label;
    }

  /* Generate imp symbols with one underscore for Microsoft
     compatibility, and with two underscores for backward
     compatibility with old versions of cygwin.  */
  if (create_compat_implib)
    {
      iname = bfd_make_empty_symbol (abfd);
      iname->name = make_imp_label ("___imp", exp->name);
      iname->section = secdata[IDATA5].sec;
      iname->flags = BSF_GLOBAL;
      iname->value = 0;
    }

  iname2 = bfd_make_empty_symbol (abfd);
  iname2->name = make_imp_label ("__imp_", exp->name);
  iname2->section = secdata[IDATA5].sec;
  iname2->flags = BSF_GLOBAL;
  iname2->value = 0;

  iname_lab = bfd_make_empty_symbol (abfd);

  iname_lab->name = head_label;
  iname_lab->section = bfd_und_section_ptr;
  iname_lab->flags = 0;
  iname_lab->value = 0;

  iname_pp = ptrs + oidx;
  if (create_compat_implib)
    ptrs[oidx++] = iname;
  ptrs[oidx++] = iname2;

  iname_lab_pp = ptrs + oidx;
  ptrs[oidx++] = iname_lab;

#ifdef DLLTOOL_PPC
  /* The symbol referring to the code (.text).  */
  {
    asymbol *function_name;

    function_name = bfd_make_empty_symbol(abfd);
    function_name->name = make_label ("..", exp->name);
    function_name->section = secdata[TEXT].sec;
    function_name->flags = BSF_GLOBAL;
    function_name->value = 0;

    fn_pp = ptrs + oidx;
    ptrs[oidx++] = function_name;
  }

  /* The .toc symbol.  */
  {
    asymbol *toc_symbol;

    toc_symbol = bfd_make_empty_symbol (abfd);
    toc_symbol->name = make_label (".", "toc");
    toc_symbol->section = bfd_und_section_ptr;
    toc_symbol->flags = BSF_GLOBAL;
    toc_symbol->value = 0;

    toc_pp = ptrs + oidx;
    ptrs[oidx++] = toc_symbol;
  }
#endif

  ptrs[oidx] = 0;

  for (i = 0; i < NSECS; i++)
    {
      sinfo *si = secdata + i;
      asection *sec = si->sec;
      arelent *rel, *rel2 = 0, *rel3 = 0;
      arelent **rpp;

      switch (i)
	{
	case TEXT:
	  if (! exp->data)
	    {
	      si->size = HOW_JTAB_SIZE;
	      si->data = xmalloc (HOW_JTAB_SIZE);
	      memcpy (si->data, HOW_JTAB, HOW_JTAB_SIZE);

	      /* Add the reloc into idata$5.  */
	      rel = xmalloc (sizeof (arelent));

	      rpp = xmalloc (sizeof (arelent *) * (delay ? 4 : 2));
	      rpp[0] = rel;
	      rpp[1] = 0;

	      rel->address = HOW_JTAB_ROFF;
	      rel->addend = 0;

	      if (delay)
	        {
	          rel2 = xmalloc (sizeof (arelent));
	          rpp[1] = rel2;
	          rel2->address = HOW_JTAB_ROFF2;
	          rel2->addend = 0;
	          rel3 = xmalloc (sizeof (arelent));
	          rpp[2] = rel3;
	          rel3->address = HOW_JTAB_ROFF3;
	          rel3->addend = 0;
	          rpp[3] = 0;
	        }

	      if (machine == MPPC)
		{
		  rel->howto = bfd_reloc_type_lookup (abfd,
						      BFD_RELOC_16_GOTOFF);
		  rel->sym_ptr_ptr = iname_pp;
		}
	      else if (machine == MX86)
		{
		  rel->howto = bfd_reloc_type_lookup (abfd,
						      BFD_RELOC_32_PCREL);
		  rel->sym_ptr_ptr = iname_pp;
		}
	      else
		{
		  rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);
		  rel->sym_ptr_ptr = secdata[IDATA5].sympp;
		}

	      if (delay)
	        {
		  if (machine == MX86)
		   rel2->howto = bfd_reloc_type_lookup (abfd,
							BFD_RELOC_32_PCREL);
	          else
	            rel2->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);
	          rel2->sym_ptr_ptr = rel->sym_ptr_ptr;
	          rel3->howto = bfd_reloc_type_lookup (abfd,
						       BFD_RELOC_32_PCREL);
	          rel3->sym_ptr_ptr = iname_lab_pp;
	        }

	      sec->orelocation = rpp;
	      sec->reloc_count = delay ? 3 : 1;
	    }
	  break;

	case IDATA5:
	  if (delay)
	    {
	      si->size = create_for_pep ? 8 : 4;
	      si->data = xmalloc (si->size);
	      sec->reloc_count = 1;
	      memset (si->data, 0, si->size);
	      /* Point after jmp [__imp_...] instruction.  */
	      si->data[0] = 6;
	      rel = xmalloc (sizeof (arelent));
	      rpp = xmalloc (sizeof (arelent *) * 2);
	      rpp[0] = rel;
	      rpp[1] = 0;
	      rel->address = 0;
	      rel->addend = 0;
	      if (create_for_pep)
	        rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_64);
	      else
	        rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);
	      rel->sym_ptr_ptr = secdata[TEXT].sympp;
	      sec->orelocation = rpp;
	      break;
	    }
	  /* else fall through */
	case IDATA4:
	  /* An idata$4 or idata$5 is one word long, and has an
	     rva to idata$6.  */

	  if (create_for_pep)
	    {
	      si->data = xmalloc (8);
	      si->size = 8;
	      if (exp->noname)
	        {
		  si->data[0] = exp->ordinal ;
		  si->data[1] = exp->ordinal >> 8;
		  si->data[2] = exp->ordinal >> 16;
		  si->data[3] = exp->ordinal >> 24;
		  si->data[4] = 0;
		  si->data[5] = 0;
		  si->data[6] = 0;
		  si->data[7] = 0x80;
	        }
	      else
	        {
		  sec->reloc_count = 1;
		  memset (si->data, 0, si->size);
		  rel = xmalloc (sizeof (arelent));
		  rpp = xmalloc (sizeof (arelent *) * 2);
		  rpp[0] = rel;
		  rpp[1] = 0;
		  rel->address = 0;
		  rel->addend = 0;
		  rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_RVA);
		  rel->sym_ptr_ptr = secdata[IDATA6].sympp;
		  sec->orelocation = rpp;
	        }
	    }
	  else
	    {
	      si->data = xmalloc (4);
	      si->size = 4;
	      
	      if (exp->noname)
	        {
		  si->data[0] = exp->ordinal ;
		  si->data[1] = exp->ordinal >> 8;
		  si->data[2] = exp->ordinal >> 16;
		  si->data[3] = 0x80;
	        }
	      else
	        {
		  sec->reloc_count = 1;
		  memset (si->data, 0, si->size);
		  rel = xmalloc (sizeof (arelent));
		  rpp = xmalloc (sizeof (arelent *) * 2);
		  rpp[0] = rel;
		  rpp[1] = 0;
		  rel->address = 0;
		  rel->addend = 0;
		  rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_RVA);
		  rel->sym_ptr_ptr = secdata[IDATA6].sympp;
		  sec->orelocation = rpp;
	      }
	    }
	  break;

	case IDATA6:
	  if (!exp->noname)
	    {
	      /* This used to add 1 to exp->hint.  I don't know
		 why it did that, and it does not match what I see
		 in programs compiled with the MS tools.  */
	      int idx = exp->hint;
	      if (exp->its_name)
	        si->size = strlen (exp->its_name) + 3;
	      else
	        si->size = strlen (xlate (exp->import_name)) + 3;
	      si->data = xmalloc (si->size);
	      si->data[0] = idx & 0xff;
	      si->data[1] = idx >> 8;
	      if (exp->its_name)
		strcpy ((char *) si->data + 2, exp->its_name);
	      else
		strcpy ((char *) si->data + 2, xlate (exp->import_name));
	    }
	  break;
	case IDATA7:
	  if (delay)
	    break;
	  si->size = 4;
	  si->data = xmalloc (4);
	  memset (si->data, 0, si->size);
	  rel = xmalloc (sizeof (arelent));
	  rpp = xmalloc (sizeof (arelent *) * 2);
	  rpp[0] = rel;
	  rel->address = 0;
	  rel->addend = 0;
	  rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_RVA);
	  rel->sym_ptr_ptr = iname_lab_pp;
	  sec->orelocation = rpp;
	  sec->reloc_count = 1;
	  break;

#ifdef DLLTOOL_PPC
	case PDATA:
	  {
	    /* The .pdata section is 5 words long.
	       Think of it as:
	       struct
	       {
	       bfd_vma BeginAddress,     [0x00]
	       EndAddress,       [0x04]
	       ExceptionHandler, [0x08]
	       HandlerData,      [0x0c]
	       PrologEndAddress; [0x10]
	       };  */

	    /* So this pdata section setups up this as a glue linkage to
	       a dll routine. There are a number of house keeping things
	       we need to do:

	       1. In the name of glue trickery, the ADDR32 relocs for 0,
	       4, and 0x10 are set to point to the same place:
	       "..function_name".
	       2. There is one more reloc needed in the pdata section.
	       The actual glue instruction to restore the toc on
	       return is saved as the offset in an IMGLUE reloc.
	       So we need a total of four relocs for this section.

	       3. Lastly, the HandlerData field is set to 0x03, to indicate
	       that this is a glue routine.  */
	    arelent *imglue, *ba_rel, *ea_rel, *pea_rel;

	    /* Alignment must be set to 2**2 or you get extra stuff.  */
	    bfd_set_section_alignment(abfd, sec, 2);

	    si->size = 4 * 5;
	    si->data = xmalloc (si->size);
	    memset (si->data, 0, si->size);
	    rpp = xmalloc (sizeof (arelent *) * 5);
	    rpp[0] = imglue  = xmalloc (sizeof (arelent));
	    rpp[1] = ba_rel  = xmalloc (sizeof (arelent));
	    rpp[2] = ea_rel  = xmalloc (sizeof (arelent));
	    rpp[3] = pea_rel = xmalloc (sizeof (arelent));
	    rpp[4] = 0;

	    /* Stick the toc reload instruction in the glue reloc.  */
	    bfd_put_32(abfd, ppc_glue_insn, (char *) &imglue->address);

	    imglue->addend = 0;
	    imglue->howto = bfd_reloc_type_lookup (abfd,
						   BFD_RELOC_32_GOTOFF);
	    imglue->sym_ptr_ptr = fn_pp;

	    ba_rel->address = 0;
	    ba_rel->addend = 0;
	    ba_rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);
	    ba_rel->sym_ptr_ptr = fn_pp;

	    bfd_put_32 (abfd, 0x18, si->data + 0x04);
	    ea_rel->address = 4;
	    ea_rel->addend = 0;
	    ea_rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);
	    ea_rel->sym_ptr_ptr = fn_pp;

	    /* Mark it as glue.  */
	    bfd_put_32 (abfd, 0x03, si->data + 0x0c);

	    /* Mark the prolog end address.  */
	    bfd_put_32 (abfd, 0x0D, si->data + 0x10);
	    pea_rel->address = 0x10;
	    pea_rel->addend = 0;
	    pea_rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);
	    pea_rel->sym_ptr_ptr = fn_pp;

	    sec->orelocation = rpp;
	    sec->reloc_count = 4;
	    break;
	  }
	case RDATA:
	  /* Each external function in a PowerPC PE file has a two word
	     descriptor consisting of:
	     1. The address of the code.
	     2. The address of the appropriate .toc
	     We use relocs to build this.  */
	  si->size = 8;
	  si->data = xmalloc (8);
	  memset (si->data, 0, si->size);

	  rpp = xmalloc (sizeof (arelent *) * 3);
	  rpp[0] = rel = xmalloc (sizeof (arelent));
	  rpp[1] = xmalloc (sizeof (arelent));
	  rpp[2] = 0;

	  rel->address = 0;
	  rel->addend = 0;
	  rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);
	  rel->sym_ptr_ptr = fn_pp;

	  rel = rpp[1];

	  rel->address = 4;
	  rel->addend = 0;
	  rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);
	  rel->sym_ptr_ptr = toc_pp;

	  sec->orelocation = rpp;
	  sec->reloc_count = 2;
	  break;
#endif /* DLLTOOL_PPC */
	}
    }

  {
    bfd_vma vma = 0;
    /* Size up all the sections.  */
    for (i = 0; i < NSECS; i++)
      {
	sinfo *si = secdata + i;

	bfd_set_section_size (abfd, si->sec, si->size);
	bfd_set_section_vma (abfd, si->sec, vma);
      }
  }
  /* Write them out.  */
  for (i = 0; i < NSECS; i++)
    {
      sinfo *si = secdata + i;

      if (i == IDATA5 && no_idata5)
	continue;

      if (i == IDATA4 && no_idata4)
	continue;

      bfd_set_section_contents (abfd, si->sec,
				si->data, 0,
				si->size);
    }

  bfd_set_symtab (abfd, ptrs, oidx);
  bfd_close (abfd);
  abfd = bfd_openr (outname, HOW_BFD_READ_TARGET);
  if (!abfd)
    /* xgettext:c-format */
    fatal (_("bfd_open failed reopen stub file: %s: %s"),
	   outname, bfd_get_errmsg ());
 
  return abfd;
}

static bfd *
make_head (void)
{
  FILE *f = fopen (TMP_HEAD_S, FOPEN_WT);
  bfd *abfd;

  if (f == NULL)
    {
      fatal (_("failed to open temporary head file: %s"), TMP_HEAD_S);
      return NULL;
    }

  fprintf (f, "%s IMAGE_IMPORT_DESCRIPTOR\n", ASM_C);
  fprintf (f, "\t.section\t.idata$2\n");

  fprintf (f,"\t%s\t%s\n", ASM_GLOBAL, head_label);

  fprintf (f, "%s:\n", head_label);

  fprintf (f, "\t%shname%s\t%sPtr to image import by name list\n",
	   ASM_RVA_BEFORE, ASM_RVA_AFTER, ASM_C);

  fprintf (f, "\t%sthis should be the timestamp, but NT sometimes\n", ASM_C);
  fprintf (f, "\t%sdoesn't load DLLs when this is set.\n", ASM_C);
  fprintf (f, "\t%s\t0\t%s loaded time\n", ASM_LONG, ASM_C);
  fprintf (f, "\t%s\t0\t%s Forwarder chain\n", ASM_LONG, ASM_C);
  fprintf (f, "\t%s__%s_iname%s\t%s imported dll's name\n",
	   ASM_RVA_BEFORE,
	   imp_name_lab,
	   ASM_RVA_AFTER,
	   ASM_C);
  fprintf (f, "\t%sfthunk%s\t%s pointer to firstthunk\n",
	   ASM_RVA_BEFORE,
	   ASM_RVA_AFTER, ASM_C);

  fprintf (f, "%sStuff for compatibility\n", ASM_C);

  if (!no_idata5)
    {
      fprintf (f, "\t.section\t.idata$5\n");
      if (use_nul_prefixed_import_tables)
        {
	  if (create_for_pep)
	    fprintf (f,"\t%s\t0\n\t%s\t0\n", ASM_LONG, ASM_LONG);
	  else
	    fprintf (f,"\t%s\t0\n", ASM_LONG);
        }
      fprintf (f, "fthunk:\n");
    }

  if (!no_idata4)
    {
      fprintf (f, "\t.section\t.idata$4\n");
      if (use_nul_prefixed_import_tables)
        {
	  if (create_for_pep)
	    fprintf (f,"\t%s\t0\n\t%s\t0\n", ASM_LONG, ASM_LONG);
	  else
	    fprintf (f,"\t%s\t0\n", ASM_LONG);
        }
      fprintf (f, "hname:\n");
    }

  fclose (f);

  assemble_file (TMP_HEAD_S, TMP_HEAD_O);

  abfd = bfd_openr (TMP_HEAD_O, HOW_BFD_READ_TARGET);
  if (abfd == NULL)
    /* xgettext:c-format */
    fatal (_("failed to open temporary head file: %s: %s"),
	   TMP_HEAD_O, bfd_get_errmsg ());

  return abfd;
}

bfd *
make_delay_head (void)
{
  FILE *f = fopen (TMP_HEAD_S, FOPEN_WT);
  bfd *abfd;

  if (f == NULL)
    {
      fatal (_("failed to open temporary head file: %s"), TMP_HEAD_S);
      return NULL;
    }

  /* Output the __tailMerge__xxx function */
  fprintf (f, "%s Import trampoline\n", ASM_C);
  fprintf (f, "\t.section\t.text\n");
  fprintf(f,"\t%s\t%s\n", ASM_GLOBAL, head_label);
  fprintf (f, "%s:\n", head_label);
  fprintf (f, mtable[machine].trampoline, imp_name_lab);

  /* Output the delay import descriptor */
  fprintf (f, "\n%s DELAY_IMPORT_DESCRIPTOR\n", ASM_C);
  fprintf (f, ".section\t.text$2\n");
  fprintf (f,"%s __DELAY_IMPORT_DESCRIPTOR_%s\n", ASM_GLOBAL,imp_name_lab);
  fprintf (f, "__DELAY_IMPORT_DESCRIPTOR_%s:\n", imp_name_lab);
  fprintf (f, "\t%s 1\t%s grAttrs\n", ASM_LONG, ASM_C);
  fprintf (f, "\t%s__%s_iname%s\t%s rvaDLLName\n",
	   ASM_RVA_BEFORE, imp_name_lab, ASM_RVA_AFTER, ASM_C);
  fprintf (f, "\t%s__DLL_HANDLE_%s%s\t%s rvaHmod\n",
	   ASM_RVA_BEFORE, imp_name_lab, ASM_RVA_AFTER, ASM_C);
  fprintf (f, "\t%s__IAT_%s%s\t%s rvaIAT\n",
	   ASM_RVA_BEFORE, imp_name_lab, ASM_RVA_AFTER, ASM_C);
  fprintf (f, "\t%s__INT_%s%s\t%s rvaINT\n",
	   ASM_RVA_BEFORE, imp_name_lab, ASM_RVA_AFTER, ASM_C);
  fprintf (f, "\t%s\t0\t%s rvaBoundIAT\n", ASM_LONG, ASM_C);
  fprintf (f, "\t%s\t0\t%s rvaUnloadIAT\n", ASM_LONG, ASM_C);
  fprintf (f, "\t%s\t0\t%s dwTimeStamp\n", ASM_LONG, ASM_C);

  /* Output the dll_handle */
  fprintf (f, "\n.section .data\n");
  fprintf (f, "__DLL_HANDLE_%s:\n", imp_name_lab);
  fprintf (f, "\t%s\t0\t%s Handle\n", ASM_LONG, ASM_C);
  if (create_for_pep)
    fprintf (f, "\t%s\t0\n", ASM_LONG);
  fprintf (f, "\n");

  fprintf (f, "%sStuff for compatibility\n", ASM_C);

  if (!no_idata5)
    {
      fprintf (f, "\t.section\t.idata$5\n");
      /* NULL terminating list.  */
      if (create_for_pep)
        fprintf (f,"\t%s\t0\n\t%s\t0\n", ASM_LONG, ASM_LONG);
      else
        fprintf (f,"\t%s\t0\n", ASM_LONG);
      fprintf (f, "__IAT_%s:\n", imp_name_lab);
    }

  if (!no_idata4)
    {
      fprintf (f, "\t.section\t.idata$4\n");
      fprintf (f, "\t%s\t0\n", ASM_LONG);
      if (create_for_pep)
        fprintf (f, "\t%s\t0\n", ASM_LONG);
      fprintf (f, "\t.section\t.idata$4\n");
      fprintf (f, "__INT_%s:\n", imp_name_lab);
    }

  fprintf (f, "\t.section\t.idata$2\n");

  fclose (f);

  assemble_file (TMP_HEAD_S, TMP_HEAD_O);

  abfd = bfd_openr (TMP_HEAD_O, HOW_BFD_READ_TARGET);
  if (abfd == NULL)
    /* xgettext:c-format */
    fatal (_("failed to open temporary head file: %s: %s"),
	   TMP_HEAD_O, bfd_get_errmsg ());

  return abfd;
}

static bfd *
make_tail (void)
{
  FILE *f = fopen (TMP_TAIL_S, FOPEN_WT);
  bfd *abfd;

  if (f == NULL)
    {
      fatal (_("failed to open temporary tail file: %s"), TMP_TAIL_S);
      return NULL;
    }

  if (!no_idata4)
    {
      fprintf (f, "\t.section\t.idata$4\n");
      if (create_for_pep)
	fprintf (f,"\t%s\t0\n\t%s\t0\n", ASM_LONG, ASM_LONG);
      else
	fprintf (f,"\t%s\t0\n", ASM_LONG); /* NULL terminating list.  */
    }

  if (!no_idata5)
    {
      fprintf (f, "\t.section\t.idata$5\n");
      if (create_for_pep)
	fprintf (f,"\t%s\t0\n\t%s\t0\n", ASM_LONG, ASM_LONG);
      else
	fprintf (f,"\t%s\t0\n", ASM_LONG); /* NULL terminating list.  */
    }

#ifdef DLLTOOL_PPC
  /* Normally, we need to see a null descriptor built in idata$3 to
     act as the terminator for the list. The ideal way, I suppose,
     would be to mark this section as a comdat type 2 section, so
     only one would appear in the final .exe (if our linker supported
     comdat, that is) or cause it to be inserted by something else (say
     crt0).  */

  fprintf (f, "\t.section\t.idata$3\n");
  fprintf (f, "\t%s\t0\n", ASM_LONG);
  fprintf (f, "\t%s\t0\n", ASM_LONG);
  fprintf (f, "\t%s\t0\n", ASM_LONG);
  fprintf (f, "\t%s\t0\n", ASM_LONG);
  fprintf (f, "\t%s\t0\n", ASM_LONG);
#endif

#ifdef DLLTOOL_PPC
  /* Other PowerPC NT compilers use idata$6 for the dllname, so I
     do too. Original, huh?  */
  fprintf (f, "\t.section\t.idata$6\n");
#else
  fprintf (f, "\t.section\t.idata$7\n");
#endif

  fprintf (f, "\t%s\t__%s_iname\n", ASM_GLOBAL, imp_name_lab);
  fprintf (f, "__%s_iname:\t%s\t\"%s\"\n",
	   imp_name_lab, ASM_TEXT, dll_name);

  fclose (f);

  assemble_file (TMP_TAIL_S, TMP_TAIL_O);

  abfd = bfd_openr (TMP_TAIL_O, HOW_BFD_READ_TARGET);
  if (abfd == NULL)
    /* xgettext:c-format */
    fatal (_("failed to open temporary tail file: %s: %s"),
	   TMP_TAIL_O, bfd_get_errmsg ());

  return abfd;
}

static void
gen_lib_file (int delay)
{
  int i;
  export_type *exp;
  bfd *ar_head;
  bfd *ar_tail;
  bfd *outarch;
  bfd * head  = 0;

  unlink (imp_name);

  outarch = bfd_openw (imp_name, HOW_BFD_WRITE_TARGET);

  if (!outarch)
    /* xgettext:c-format */
    fatal (_("Can't create .lib file: %s: %s"),
	   imp_name, bfd_get_errmsg ());

  /* xgettext:c-format */
  inform (_("Creating library file: %s"), imp_name);

  bfd_set_format (outarch, bfd_archive);
  outarch->has_armap = 1;
  outarch->is_thin_archive = 0;

  /* Work out a reasonable size of things to put onto one line.  */
  if (delay)
    {
      ar_head = make_delay_head ();
    }
  else
    {
      ar_head = make_head ();
    }
  ar_tail = make_tail();

  if (ar_head == NULL || ar_tail == NULL)
    return;

  for (i = 0; (exp = d_exports_lexically[i]); i++)
    {
      bfd *n;
      /* Don't add PRIVATE entries to import lib.  */
      if (exp->private)
	continue;
      n = make_one_lib_file (exp, i, delay);
      n->archive_next = head;
      head = n;
      if (ext_prefix_alias)
	{
	  export_type alias_exp;

	  assert (i < PREFIX_ALIAS_BASE);
	  alias_exp.name = make_imp_label (ext_prefix_alias, exp->name);
	  alias_exp.internal_name = exp->internal_name;
	  alias_exp.its_name = exp->its_name;
	  alias_exp.import_name = exp->name;
	  alias_exp.ordinal = exp->ordinal;
	  alias_exp.constant = exp->constant;
	  alias_exp.noname = exp->noname;
	  alias_exp.private = exp->private;
	  alias_exp.data = exp->data;
	  alias_exp.hint = exp->hint;
	  alias_exp.forward = exp->forward;
	  alias_exp.next = exp->next;
	  n = make_one_lib_file (&alias_exp, i + PREFIX_ALIAS_BASE, delay);
	  n->archive_next = head;
	  head = n;
	}
    }

  /* Now stick them all into the archive.  */
  ar_head->archive_next = head;
  ar_tail->archive_next = ar_head;
  head = ar_tail;

  if (! bfd_set_archive_head (outarch, head))
    bfd_fatal ("bfd_set_archive_head");

  if (! bfd_close (outarch))
    bfd_fatal (imp_name);

  while (head != NULL)
    {
      bfd *n = head->archive_next;
      bfd_close (head);
      head = n;
    }

  /* Delete all the temp files.  */
  if (dontdeltemps == 0)
    {
      unlink (TMP_HEAD_O);
      unlink (TMP_HEAD_S);
      unlink (TMP_TAIL_O);
      unlink (TMP_TAIL_S);
    }

  if (dontdeltemps < 2)
    {
      char *name;

      name = (char *) alloca (strlen (TMP_STUB) + 10);
      for (i = 0; (exp = d_exports_lexically[i]); i++)
	{
	  /* Don't delete non-existent stubs for PRIVATE entries.  */
          if (exp->private)
	    continue;
	  sprintf (name, "%s%05d.o", TMP_STUB, i);
	  if (unlink (name) < 0)
	    /* xgettext:c-format */
	    non_fatal (_("cannot delete %s: %s"), name, strerror (errno));
	  if (ext_prefix_alias)
	    {
	      sprintf (name, "%s%05d.o", TMP_STUB, i + PREFIX_ALIAS_BASE);
	      if (unlink (name) < 0)
		/* xgettext:c-format */
		non_fatal (_("cannot delete %s: %s"), name, strerror (errno));
	    }
	}
    }

  inform (_("Created lib file"));
}

/* Append a copy of data (cast to char *) to list.  */

static void
dll_name_list_append (dll_name_list_type * list, bfd_byte * data)
{
  dll_name_list_node_type * entry;

  /* Error checking.  */
  if (! list || ! list->tail)
    return;

  /* Allocate new node.  */
  entry = ((dll_name_list_node_type *)
	   xmalloc (sizeof (dll_name_list_node_type)));

  /* Initialize its values.  */
  entry->dllname = xstrdup ((char *) data);
  entry->next = NULL;

  /* Add to tail, and move tail.  */
  list->tail->next = entry;
  list->tail = entry;
}

/* Count the number of entries in list.  */

static int 
dll_name_list_count (dll_name_list_type * list)
{
  dll_name_list_node_type * p;
  int count = 0;

  /* Error checking.  */
  if (! list || ! list->head)
    return 0;

  p = list->head;

  while (p && p->next)
    {
      count++;
      p = p->next;
    }
  return count;
}

/* Print each entry in list to stdout.  */

static void 
dll_name_list_print (dll_name_list_type * list)
{
  dll_name_list_node_type * p;

  /* Error checking.  */
  if (! list || ! list->head)
    return;

  p = list->head;

  while (p && p->next && p->next->dllname && *(p->next->dllname))
    {
      printf ("%s\n", p->next->dllname);
      p = p->next;
    }
}

/* Free all entries in list, and list itself.  */

static void
dll_name_list_free (dll_name_list_type * list)
{
  if (list)
    {
      dll_name_list_free_contents (list->head);
      list->head = NULL;
      list->tail = NULL;
      free (list);
    }
}

/* Recursive function to free all nodes entry->next->next...
   as well as entry itself.  */

static void 
dll_name_list_free_contents (dll_name_list_node_type * entry)
{
  if (entry)
    {
      if (entry->next)
        {
          dll_name_list_free_contents (entry->next);
          entry->next = NULL;
        }
      if (entry->dllname)
        {
          free (entry->dllname);
          entry->dllname = NULL;
        }
      free (entry);
    }
}

/* Allocate and initialize a dll_name_list_type object,
   including its sentinel node.  Caller is responsible
   for calling dll_name_list_free when finished with 
   the list.  */

static dll_name_list_type *
dll_name_list_create (void)
{
  /* Allocate list.  */
  dll_name_list_type * list = xmalloc (sizeof (dll_name_list_type));

  /* Allocate and initialize sentinel node.  */
  list->head = xmalloc (sizeof (dll_name_list_node_type));
  list->head->dllname = NULL;
  list->head->next = NULL;

  /* Bookkeeping for empty list.  */
  list->tail = list->head;

  return list;
}

/* Search the symbol table of the suppled BFD for a symbol whose name matches
   OBJ (where obj is cast to const char *).  If found, set global variable
   identify_member_contains_symname_result TRUE.  It is the caller's
   responsibility to set the result variable FALSE before iterating with
   this function.  */   

static void 
identify_member_contains_symname (bfd  * abfd,
				  bfd  * archive_bfd ATTRIBUTE_UNUSED,
				  void * obj)
{
  long storage_needed;
  asymbol ** symbol_table;
  long number_of_symbols;
  long i;
  symname_search_data_type * search_data = (symname_search_data_type *) obj;

  /* If we already found the symbol in a different member,
     short circuit.  */
  if (search_data->found)
    return;

  storage_needed = bfd_get_symtab_upper_bound (abfd);
  if (storage_needed <= 0)
    return;

  symbol_table = xmalloc (storage_needed);
  number_of_symbols = bfd_canonicalize_symtab (abfd, symbol_table);
  if (number_of_symbols < 0)
    {
      free (symbol_table);
      return;
    }

  for (i = 0; i < number_of_symbols; i++)
    {
      if (strncmp (symbol_table[i]->name,
                   search_data->symname,
                   strlen (search_data->symname)) == 0)
	{
	  search_data->found = TRUE;
	  break;
	}
    }
  free (symbol_table);
}

/* This is the main implementation for the --identify option.
   Given the name of an import library in identify_imp_name, first determine
   if the import library is a GNU binutils-style one (where the DLL name is
   stored in an .idata$7 (.idata$6 on PPC) section, or if it is a MS-style
   one (where the DLL name, along with much other data, is stored in the
   .idata$6 section). We determine the style of import library by searching
   for the DLL-structure symbol inserted by MS tools:
   __NULL_IMPORT_DESCRIPTOR.

   Once we know which section to search, evaluate each section for the
   appropriate properties that indicate it may contain the name of the
   associated DLL (this differs depending on the style).  Add the contents
   of all sections which meet the criteria to a linked list of dll names.

   Finally, print them all to stdout. (If --identify-strict, an error is
   reported if more than one match was found).  */   

static void 
identify_dll_for_implib (void)
{
  bfd * abfd = NULL;
  int count = 0;
  identify_data_type identify_data;
  symname_search_data_type search_data;

  /* Initialize identify_data.  */
  identify_data.list = dll_name_list_create ();
  identify_data.ms_style_implib = FALSE;

  /* Initialize search_data.  */
  search_data.symname = "__NULL_IMPORT_DESCRIPTOR";
  search_data.found = FALSE;

  bfd_init ();

  abfd = bfd_openr (identify_imp_name, 0);
  if (abfd == NULL)
    /* xgettext:c-format */
    fatal (_("Can't open .lib file: %s: %s"),
	   identify_imp_name, bfd_get_errmsg ());

  if (! bfd_check_format (abfd, bfd_archive))
    {
      if (! bfd_close (abfd))
        bfd_fatal (identify_imp_name);

      fatal (_("%s is not a library"), identify_imp_name);
    }

  /* Detect if this a Microsoft import library.  */
  identify_search_archive (abfd,
			   identify_member_contains_symname,
			   (void *)(& search_data));
  if (search_data.found)
    identify_data.ms_style_implib = TRUE;
  
  /* Rewind the bfd.  */
  if (! bfd_close (abfd))
    bfd_fatal (identify_imp_name);
  abfd = bfd_openr (identify_imp_name, 0);
  if (abfd == NULL)
    bfd_fatal (identify_imp_name);

  if (!bfd_check_format (abfd, bfd_archive))
    {
      if (!bfd_close (abfd))
        bfd_fatal (identify_imp_name);

      fatal (_("%s is not a library"), identify_imp_name);
    }
 
  /* Now search for the dll name.  */
  identify_search_archive (abfd,
			   identify_search_member,
			   (void *)(& identify_data));

  if (! bfd_close (abfd))
    bfd_fatal (identify_imp_name);

  count = dll_name_list_count (identify_data.list);
  if (count > 0)
    {
      if (identify_strict && count > 1)
        {
          dll_name_list_free (identify_data.list);
          identify_data.list = NULL;
          fatal (_("Import library `%s' specifies two or more dlls"),
		 identify_imp_name);
        }
      dll_name_list_print (identify_data.list);
      dll_name_list_free (identify_data.list);
      identify_data.list = NULL;
    }
  else
    {
      dll_name_list_free (identify_data.list);
      identify_data.list = NULL;
      fatal (_("Unable to determine dll name for `%s' (not an import library?)"),
	     identify_imp_name);
    }
}

/* Loop over all members of the archive, applying the supplied function to
   each member that is a bfd_object.  The function will be called as if:
      func (member_bfd, abfd, user_storage)  */   

static void
identify_search_archive (bfd * abfd, 
			 void (* operation) (bfd *, bfd *, void *),
			 void * user_storage)
{
  bfd *   arfile = NULL;
  bfd *   last_arfile = NULL;
  char ** matching;

  while (1)
    {
      arfile = bfd_openr_next_archived_file (abfd, arfile);

      if (arfile == NULL)
        {
          if (bfd_get_error () != bfd_error_no_more_archived_files)
            bfd_fatal (bfd_get_filename (abfd));
          break;
        }

      if (bfd_check_format_matches (arfile, bfd_object, &matching))
	(*operation) (arfile, abfd, user_storage);
      else
        {
          bfd_nonfatal (bfd_get_filename (arfile));
          free (matching);
        }

      if (last_arfile != NULL)
	bfd_close (last_arfile);

      last_arfile = arfile;
    }

  if (last_arfile != NULL)
    {
      bfd_close (last_arfile);
    }
}

/* Call the identify_search_section() function for each section of this
   archive member.  */   

static void
identify_search_member (bfd  *abfd,
			bfd  *archive_bfd ATTRIBUTE_UNUSED,
			void *obj)
{
  bfd_map_over_sections (abfd, identify_search_section, obj);
}

/* This predicate returns true if section->name matches the desired value.
   By default, this is .idata$7 (.idata$6 on PPC, or if the import
   library is ms-style).  */   

static bfd_boolean
identify_process_section_p (asection * section, bfd_boolean ms_style_implib)
{
  static const char * SECTION_NAME =
#ifdef DLLTOOL_PPC
  /* dllname is stored in idata$6 on PPC */
  ".idata$6";
#else
  ".idata$7";
#endif
  static const char * MS_SECTION_NAME = ".idata$6";
  
  const char * section_name =
    (ms_style_implib ? MS_SECTION_NAME : SECTION_NAME);
  
  if (strcmp (section_name, section->name) == 0)
    return TRUE;
  return FALSE;
}

/* If *section has contents and its name is .idata$7 (.data$6 on PPC or if
   import lib ms-generated) -- and it satisfies several other constraints
   -- then add the contents of the section to obj->list.  */

static void
identify_search_section (bfd * abfd, asection * section, void * obj)
{
  bfd_byte *data = 0;
  bfd_size_type datasize;
  identify_data_type * identify_data = (identify_data_type *)obj;
  bfd_boolean ms_style = identify_data->ms_style_implib;

  if ((section->flags & SEC_HAS_CONTENTS) == 0)
    return;

  if (! identify_process_section_p (section, ms_style))
    return;

  /* Binutils import libs seem distinguish the .idata$7 section that contains
     the DLL name from other .idata$7 sections by the absence of the
     SEC_RELOC flag.  */
  if (!ms_style && ((section->flags & SEC_RELOC) == SEC_RELOC))
    return;

  /* MS import libs seem to distinguish the .idata$6 section
     that contains the DLL name from other .idata$6 sections
     by the presence of the SEC_DATA flag.  */
  if (ms_style && ((section->flags & SEC_DATA) == 0))
    return;

  if ((datasize = bfd_section_size (abfd, section)) == 0)
    return;

  data = (bfd_byte *) xmalloc (datasize + 1);
  data[0] = '\0';

  bfd_get_section_contents (abfd, section, data, 0, datasize);
  data[datasize] = '\0';

  /* Use a heuristic to determine if data is a dll name.
     Possible to defeat this if (a) the library has MANY
     (more than 0x302f) imports, (b) it is an ms-style 
     import library, but (c) it is buggy, in that the SEC_DATA
     flag is set on the "wrong" sections.  This heuristic might
     also fail to record a valid dll name if the dllname uses
     a multibyte or unicode character set (is that valid?).

     This heuristic is based on the fact that symbols names in
     the chosen section -- as opposed to the dll name -- begin
     at offset 2 in the data. The first two bytes are a 16bit
     little-endian count, and start at 0x0000. However, the dll
     name begins at offset 0 in the data. We assume that the
     dll name does not contain unprintable characters.   */
  if (data[0] != '\0' && ISPRINT (data[0])
      && ((datasize < 2) || ISPRINT (data[1])))
    dll_name_list_append (identify_data->list, data);

  free (data);
}

/* Run through the information gathered from the .o files and the
   .def file and work out the best stuff.  */

static int
pfunc (const void *a, const void *b)
{
  export_type *ap = *(export_type **) a;
  export_type *bp = *(export_type **) b;

  if (ap->ordinal == bp->ordinal)
    return 0;

  /* Unset ordinals go to the bottom.  */
  if (ap->ordinal == -1)
    return 1;
  if (bp->ordinal == -1)
    return -1;
  return (ap->ordinal - bp->ordinal);
}

static int
nfunc (const void *a, const void *b)
{
  export_type *ap = *(export_type **) a;
  export_type *bp = *(export_type **) b;
  const char *an = ap->name;
  const char *bn = bp->name;
  if (ap->its_name)
    an = ap->its_name;
  if (bp->its_name)
    an = bp->its_name;
  if (killat)
    {
      an = (an[0] == '@@') ? an + 1 : an;
      bn = (bn[0] == '@@') ? bn + 1 : bn;
    }

  return (strcmp (an, bn));
}

static void
remove_null_names (export_type **ptr)
{
  int src;
  int dst;

  for (dst = src = 0; src < d_nfuncs; src++)
    {
      if (ptr[src])
	{
	  ptr[dst] = ptr[src];
	  dst++;
	}
    }
  d_nfuncs = dst;
}

static void
process_duplicates (export_type **d_export_vec)
{
  int more = 1;
  int i;

  while (more)
    {
      more = 0;
      /* Remove duplicates.  */
      qsort (d_export_vec, d_nfuncs, sizeof (export_type *), nfunc);

      for (i = 0; i < d_nfuncs - 1; i++)
	{
	  if (strcmp (d_export_vec[i]->name,
		      d_export_vec[i + 1]->name) == 0)
	    {
	      export_type *a = d_export_vec[i];
	      export_type *b = d_export_vec[i + 1];

	      more = 1;

	      /* xgettext:c-format */
	      inform (_("Warning, ignoring duplicate EXPORT %s %d,%d"),
		      a->name, a->ordinal, b->ordinal);

	      if (a->ordinal != -1
		  && b->ordinal != -1)
		/* xgettext:c-format */
		fatal (_("Error, duplicate EXPORT with ordinals: %s"),
		      a->name);

	      /* Merge attributes.  */
	      b->ordinal = a->ordinal > 0 ? a->ordinal : b->ordinal;
	      b->constant |= a->constant;
	      b->noname |= a->noname;
	      b->data |= a->data;
	      d_export_vec[i] = 0;
	    }

	  remove_null_names (d_export_vec);
	}
    }

  /* Count the names.  */
  for (i = 0; i < d_nfuncs; i++)
    if (!d_export_vec[i]->noname)
      d_named_nfuncs++;
}

static void
fill_ordinals (export_type **d_export_vec)
{
  int lowest = -1;
  int i;
  char *ptr;
  int size = 65536;

  qsort (d_export_vec, d_nfuncs, sizeof (export_type *), pfunc);

  /* Fill in the unset ordinals with ones from our range.  */
  ptr = (char *) xmalloc (size);

  memset (ptr, 0, size);

  /* Mark in our large vector all the numbers that are taken.  */
  for (i = 0; i < d_nfuncs; i++)
    {
      if (d_export_vec[i]->ordinal != -1)
	{
	  ptr[d_export_vec[i]->ordinal] = 1;

	  if (lowest == -1 || d_export_vec[i]->ordinal < lowest)
	    lowest = d_export_vec[i]->ordinal;
	}
    }

  /* Start at 1 for compatibility with MS toolchain.  */
  if (lowest == -1)
    lowest = 1;

  /* Now fill in ordinals where the user wants us to choose.  */
  for (i = 0; i < d_nfuncs; i++)
    {
      if (d_export_vec[i]->ordinal == -1)
	{
	  int j;

	  /* First try within or after any user supplied range.  */
	  for (j = lowest; j < size; j++)
	    if (ptr[j] == 0)
	      {
		ptr[j] = 1;
		d_export_vec[i]->ordinal = j;
		goto done;
	      }

	  /* Then try before the range.  */
	  for (j = lowest; j >0; j--)
	    if (ptr[j] == 0)
	      {
		ptr[j] = 1;
		d_export_vec[i]->ordinal = j;
		goto done;
	      }
	done:;
	}
    }

  free (ptr);

  /* And resort.  */
  qsort (d_export_vec, d_nfuncs, sizeof (export_type *), pfunc);

  /* Work out the lowest and highest ordinal numbers.  */
  if (d_nfuncs)
    {
      if (d_export_vec[0])
	d_low_ord = d_export_vec[0]->ordinal;
      if (d_export_vec[d_nfuncs-1])
	d_high_ord = d_export_vec[d_nfuncs-1]->ordinal;
    }
}

static void
mangle_defs (void)
{
  /* First work out the minimum ordinal chosen.  */
  export_type *exp;

  int i;
  int hint = 0;
  export_type **d_export_vec = xmalloc (sizeof (export_type *) * d_nfuncs);

  inform (_("Processing definitions"));

  for (i = 0, exp = d_exports; exp; i++, exp = exp->next)
    d_export_vec[i] = exp;

  process_duplicates (d_export_vec);
  fill_ordinals (d_export_vec);

  /* Put back the list in the new order.  */
  d_exports = 0;
  for (i = d_nfuncs - 1; i >= 0; i--)
    {
      d_export_vec[i]->next = d_exports;
      d_exports = d_export_vec[i];
    }

  /* Build list in alpha order.  */
  d_exports_lexically = (export_type **)
    xmalloc (sizeof (export_type *) * (d_nfuncs + 1));

  for (i = 0, exp = d_exports; exp; i++, exp = exp->next)
    d_exports_lexically[i] = exp;

  d_exports_lexically[i] = 0;

  qsort (d_exports_lexically, i, sizeof (export_type *), nfunc);

  /* Fill exp entries with their hint values.  */
  for (i = 0; i < d_nfuncs; i++)
    if (!d_exports_lexically[i]->noname || show_allnames)
      d_exports_lexically[i]->hint = hint++;

  inform (_("Processed definitions"));
}

static void
usage (FILE *file, int status)
{
  /* xgetext:c-format */
  fprintf (file, _("Usage %s <option(s)> <object-file(s)>\n"), program_name);
  /* xgetext:c-format */
  fprintf (file, _("   -m --machine <machine>    Create as DLL for <machine>.  [default: %s]\n"), mname);
  fprintf (file, _("        possible <machine>: arm[_interwork], i386, mcore[-elf]{-le|-be}, ppc, thumb\n"));
  fprintf (file, _("   -e --output-exp <outname> Generate an export file.\n"));
  fprintf (file, _("   -l --output-lib <outname> Generate an interface library.\n"));
  fprintf (file, _("   -y --output-delaylib <outname> Create a delay-import library.\n"));
  fprintf (file, _("   -a --add-indirect         Add dll indirects to export file.\n"));
  fprintf (file, _("   -D --dllname <name>       Name of input dll to put into interface lib.\n"));
  fprintf (file, _("   -d --input-def <deffile>  Name of .def file to be read in.\n"));
  fprintf (file, _("   -z --output-def <deffile> Name of .def file to be created.\n"));
  fprintf (file, _("      --export-all-symbols   Export all symbols to .def\n"));
  fprintf (file, _("      --no-export-all-symbols  Only export listed symbols\n"));
  fprintf (file, _("      --exclude-symbols <list> Don't export <list>\n"));
  fprintf (file, _("      --no-default-excludes  Clear default exclude symbols\n"));
  fprintf (file, _("   -b --base-file <basefile> Read linker generated base file.\n"));
  fprintf (file, _("   -x --no-idata4            Don't generate idata$4 section.\n"));
  fprintf (file, _("   -c --no-idata5            Don't generate idata$5 section.\n"));
  fprintf (file, _("      --use-nul-prefixed-import-tables Use zero prefixed idata$4 and idata$5.\n"));
  fprintf (file, _("   -U --add-underscore       Add underscores to all symbols in interface library.\n"));
  fprintf (file, _("      --add-stdcall-underscore Add underscores to stdcall symbols in interface library.\n"));
  fprintf (file, _("      --no-leading-underscore All symbols shouldn't be prefixed by an underscore.\n"));
  fprintf (file, _("      --leading-underscore   All symbols should be prefixed by an underscore.\n"));
  fprintf (file, _("   -k --kill-at              Kill @@<n> from exported names.\n"));
  fprintf (file, _("   -A --add-stdcall-alias    Add aliases without @@<n>.\n"));
  fprintf (file, _("   -p --ext-prefix-alias <prefix> Add aliases with <prefix>.\n"));
  fprintf (file, _("   -S --as <name>            Use <name> for assembler.\n"));
  fprintf (file, _("   -f --as-flags <flags>     Pass <flags> to the assembler.\n"));
  fprintf (file, _("   -C --compat-implib        Create backward compatible import library.\n"));
  fprintf (file, _("   -n --no-delete            Keep temp files (repeat for extra preservation).\n"));
  fprintf (file, _("   -t --temp-prefix <prefix> Use <prefix> to construct temp file names.\n"));
  fprintf (file, _("   -I --identify <implib>    Report the name of the DLL associated with <implib>.\n"));
  fprintf (file, _("      --identify-strict      Causes --identify to report error when multiple DLLs.\n"));
  fprintf (file, _("   -v --verbose              Be verbose.\n"));
  fprintf (file, _("   -V --version              Display the program version.\n"));
  fprintf (file, _("   -h --help                 Display this information.\n"));
  fprintf (file, _("   @@<file>                   Read options from <file>.\n"));
#ifdef DLLTOOL_MCORE_ELF
  fprintf (file, _("   -M --mcore-elf <outname>  Process mcore-elf object files into <outname>.\n"));
  fprintf (file, _("   -L --linker <name>        Use <name> as the linker.\n"));
  fprintf (file, _("   -F --linker-flags <flags> Pass <flags> to the linker.\n"));
#endif
  if (REPORT_BUGS_TO[0] && status == 0)
    fprintf (file, _("Report bugs to %s\n"), REPORT_BUGS_TO);
  exit (status);
}

#define OPTION_EXPORT_ALL_SYMS		150
#define OPTION_NO_EXPORT_ALL_SYMS	(OPTION_EXPORT_ALL_SYMS + 1)
#define OPTION_EXCLUDE_SYMS		(OPTION_NO_EXPORT_ALL_SYMS + 1)
#define OPTION_NO_DEFAULT_EXCLUDES	(OPTION_EXCLUDE_SYMS + 1)
#define OPTION_ADD_STDCALL_UNDERSCORE	(OPTION_NO_DEFAULT_EXCLUDES + 1)
#define OPTION_USE_NUL_PREFIXED_IMPORT_TABLES \
  (OPTION_ADD_STDCALL_UNDERSCORE + 1)
#define OPTION_IDENTIFY_STRICT		(OPTION_USE_NUL_PREFIXED_IMPORT_TABLES + 1)
#define OPTION_NO_LEADING_UNDERSCORE	(OPTION_IDENTIFY_STRICT + 1)
#define OPTION_LEADING_UNDERSCORE	(OPTION_NO_LEADING_UNDERSCORE + 1)

static const struct option long_options[] =
{
  {"no-delete", no_argument, NULL, 'n'},
  {"dllname", required_argument, NULL, 'D'},
  {"no-idata4", no_argument, NULL, 'x'},
  {"no-idata5", no_argument, NULL, 'c'},
  {"use-nul-prefixed-import-tables", no_argument, NULL,
   OPTION_USE_NUL_PREFIXED_IMPORT_TABLES},
  {"output-exp", required_argument, NULL, 'e'},
  {"output-def", required_argument, NULL, 'z'},
  {"export-all-symbols", no_argument, NULL, OPTION_EXPORT_ALL_SYMS},
  {"no-export-all-symbols", no_argument, NULL, OPTION_NO_EXPORT_ALL_SYMS},
  {"exclude-symbols", required_argument, NULL, OPTION_EXCLUDE_SYMS},
  {"no-default-excludes", no_argument, NULL, OPTION_NO_DEFAULT_EXCLUDES},
  {"output-lib", required_argument, NULL, 'l'},
  {"def", required_argument, NULL, 'd'}, /* for compatibility with older versions */
  {"input-def", required_argument, NULL, 'd'},
  {"add-underscore", no_argument, NULL, 'U'},
  {"add-stdcall-underscore", no_argument, NULL, OPTION_ADD_STDCALL_UNDERSCORE},
  {"no-leading-underscore", no_argument, NULL, OPTION_NO_LEADING_UNDERSCORE},
  {"leading-underscore", no_argument, NULL, OPTION_LEADING_UNDERSCORE},
  {"kill-at", no_argument, NULL, 'k'},
  {"add-stdcall-alias", no_argument, NULL, 'A'},
  {"ext-prefix-alias", required_argument, NULL, 'p'},
  {"identify", required_argument, NULL, 'I'},
  {"identify-strict", no_argument, NULL, OPTION_IDENTIFY_STRICT},
  {"verbose", no_argument, NULL, 'v'},
  {"version", no_argument, NULL, 'V'},
  {"help", no_argument, NULL, 'h'},
  {"machine", required_argument, NULL, 'm'},
  {"add-indirect", no_argument, NULL, 'a'},
  {"base-file", required_argument, NULL, 'b'},
  {"as", required_argument, NULL, 'S'},
  {"as-flags", required_argument, NULL, 'f'},
  {"mcore-elf", required_argument, NULL, 'M'},
  {"compat-implib", no_argument, NULL, 'C'},
  {"temp-prefix", required_argument, NULL, 't'},
  {"output-delaylib", required_argument, NULL, 'y'},
  {NULL,0,NULL,0}
};

int main (int, char **);

int
main (int ac, char **av)
{
  int c;
  int i;
  char *firstarg = 0;
  program_name = av[0];
  oav = av;

#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

  expandargv (&ac, &av);

  while ((c = getopt_long (ac, av,
#ifdef DLLTOOL_MCORE_ELF
			   "m:e:l:aD:d:z:b:xp:cCuUkAS:f:nI:vVHhM:L:F:",
#else
			   "m:e:l:y:aD:d:z:b:xp:cCuUkAS:f:nI:vVHh",
#endif
			   long_options, 0))
	 != EOF)
    {
      switch (c)
	{
	case OPTION_EXPORT_ALL_SYMS:
	  export_all_symbols = TRUE;
	  break;
	case OPTION_NO_EXPORT_ALL_SYMS:
	  export_all_symbols = FALSE;
	  break;
	case OPTION_EXCLUDE_SYMS:
	  add_excludes (optarg);
	  break;
	case OPTION_NO_DEFAULT_EXCLUDES:
	  do_default_excludes = FALSE;
	  break;
	case OPTION_USE_NUL_PREFIXED_IMPORT_TABLES:
	  use_nul_prefixed_import_tables = TRUE;
	  break;
	case OPTION_ADD_STDCALL_UNDERSCORE:
	  add_stdcall_underscore = 1;
	  break;
	case OPTION_NO_LEADING_UNDERSCORE:
	  leading_underscore = 0;
	  break;
	case OPTION_LEADING_UNDERSCORE:
	  leading_underscore = 1;
	  break;
	case OPTION_IDENTIFY_STRICT:
	  identify_strict = 1;
	  break;
	case 'x':
	  no_idata4 = 1;
	  break;
	case 'c':
	  no_idata5 = 1;
	  break;
	case 'S':
	  as_name = optarg;
	  break;
	case 't':
	  tmp_prefix = optarg;
	  break;
	case 'f':
	  as_flags = optarg;
	  break;

	  /* Ignored for compatibility.  */
	case 'u':
	  break;
	case 'a':
	  add_indirect = 1;
	  break;
	case 'z':
	  output_def = fopen (optarg, FOPEN_WT);
	  break;
	case 'D':
	  dll_name = (char*) lbasename (optarg);
	  if (dll_name != optarg)
	    non_fatal (_("Path components stripped from dllname, '%s'."),
	      		 optarg);
	  break;
	case 'l':
	  imp_name = optarg;
	  break;
	case 'e':
	  exp_name = optarg;
	  break;
	case 'H':
	case 'h':
	  usage (stdout, 0);
	  break;
	case 'm':
	  mname = optarg;
	  break;
	case 'I':
	  identify_imp_name = optarg;
	  break;
	case 'v':
	  verbose = 1;
	  break;
	case 'V':
	  print_version (program_name);
	  break;
	case 'U':
	  add_underscore = 1;
	  break;
	case 'k':
	  killat = 1;
	  break;
	case 'A':
	  add_stdcall_alias = 1;
	  break;
	case 'p':
	  ext_prefix_alias = optarg;
	  break;
	case 'd':
	  def_file = optarg;
	  break;
	case 'n':
	  dontdeltemps++;
	  break;
	case 'b':
	  base_file = fopen (optarg, FOPEN_RB);

	  if (!base_file)
	    /* xgettext:c-format */
	    fatal (_("Unable to open base-file: %s"), optarg);

	  break;
#ifdef DLLTOOL_MCORE_ELF
	case 'M':
	  mcore_elf_out_file = optarg;
	  break;
	case 'L':
	  mcore_elf_linker = optarg;
	  break;
	case 'F':
	  mcore_elf_linker_flags = optarg;
	  break;
#endif
	case 'C':
	  create_compat_implib = 1;
	  break;
	case 'y':
	  delayimp_name = optarg;
	  break;
	default:
	  usage (stderr, 1);
	  break;
	}
    }

  if (!tmp_prefix)
    tmp_prefix = prefix_encode ("d", getpid ());

  for (i = 0; mtable[i].type; i++)
    if (strcmp (mtable[i].type, mname) == 0)
      break;

  if (!mtable[i].type)
    /* xgettext:c-format */
    fatal (_("Machine '%s' not supported"), mname);

  machine = i;

  /* Check if we generated PE+.  */
  create_for_pep = strcmp (mname, "i386:x86-64") == 0;

  {
    /* Check the default underscore */
    int u = leading_underscore; /* Underscoring mode. -1 for use default.  */
    if (u == -1)
      bfd_get_target_info (mtable[machine].how_bfd_target, NULL,
                           NULL, &u, NULL);
    if (u != -1)
      leading_underscore = (u != 0 ? TRUE : FALSE);
  }

  if (!dll_name && exp_name)
    {
      /* If we are inferring dll_name from exp_name,
         strip off any path components, without emitting
         a warning.  */  
      const char* exp_basename = lbasename (exp_name); 
      const int len = strlen (exp_basename) + 5;
      dll_name = xmalloc (len);
      strcpy (dll_name, exp_basename);
      strcat (dll_name, ".dll");
      dll_name_set_by_exp_name = 1;
    }

  if (as_name == NULL)
    as_name = deduce_name ("as");

  /* Don't use the default exclude list if we're reading only the
     symbols in the .drectve section.  The default excludes are meant
     to avoid exporting DLL entry point and Cygwin32 impure_ptr.  */
  if (! export_all_symbols)
    do_default_excludes = FALSE;

  if (do_default_excludes)
    set_default_excludes ();

  if (def_file)
    process_def_file (def_file);

  while (optind < ac)
    {
      if (!firstarg)
	firstarg = av[optind];
      scan_obj_file (av[optind]);
      optind++;
    }

  mangle_defs ();

  if (exp_name)
    gen_exp_file ();

  if (imp_name)
    {
      /* Make imp_name safe for use as a label.  */
      char *p;

      imp_name_lab = xstrdup (imp_name);
      for (p = imp_name_lab; *p; p++)
	{
	  if (!ISALNUM (*p))
	    *p = '_';
	}
      head_label = make_label("_head_", imp_name_lab);
      gen_lib_file (0);
    }

  if (delayimp_name)
    {
      /* Make delayimp_name safe for use as a label.  */
      char *p;

      if (mtable[machine].how_dljtab == 0)
        {
          inform (_("Warning, machine type (%d) not supported for "
			"delayimport."), machine);
        }
      else
        {
          killat = 1;
          imp_name = delayimp_name;
          imp_name_lab = xstrdup (imp_name);
          for (p = imp_name_lab; *p; p++)
            {
              if (!ISALNUM (*p))
                *p = '_';
            }
          head_label = make_label("__tailMerge_", imp_name_lab);
          gen_lib_file (1);
        }
    }

  if (output_def)
    gen_def_file ();

  if (identify_imp_name)
    {
      identify_dll_for_implib ();
    }

#ifdef DLLTOOL_MCORE_ELF
  if (mcore_elf_out_file)
    mcore_elf_gen_out_file ();
#endif

  return 0;
}

/* Look for the program formed by concatenating PROG_NAME and the
   string running from PREFIX to END_PREFIX.  If the concatenated
   string contains a '/', try appending EXECUTABLE_SUFFIX if it is
   appropriate.  */

static char *
look_for_prog (const char *prog_name, const char *prefix, int end_prefix)
{
  struct stat s;
  char *cmd;

  cmd = xmalloc (strlen (prefix)
		 + strlen (prog_name)
#ifdef HAVE_EXECUTABLE_SUFFIX
		 + strlen (EXECUTABLE_SUFFIX)
#endif
		 + 10);
  strcpy (cmd, prefix);

  sprintf (cmd + end_prefix, "%s", prog_name);

  if (strchr (cmd, '/') != NULL)
    {
      int found;

      found = (stat (cmd, &s) == 0
#ifdef HAVE_EXECUTABLE_SUFFIX
	       || stat (strcat (cmd, EXECUTABLE_SUFFIX), &s) == 0
#endif
	       );

      if (! found)
	{
	  /* xgettext:c-format */
	  inform (_("Tried file: %s"), cmd);
	  free (cmd);
	  return NULL;
	}
    }

  /* xgettext:c-format */
  inform (_("Using file: %s"), cmd);

  return cmd;
}

/* Deduce the name of the program we are want to invoke.
   PROG_NAME is the basic name of the program we want to run,
   eg "as" or "ld".  The catch is that we might want actually
   run "i386-pe-as" or "ppc-pe-ld".

   If argv[0] contains the full path, then try to find the program
   in the same place, with and then without a target-like prefix.

   Given, argv[0] = /usr/local/bin/i586-cygwin32-dlltool,
   deduce_name("as") uses the following search order:

     /usr/local/bin/i586-cygwin32-as
     /usr/local/bin/as
     as

   If there's an EXECUTABLE_SUFFIX, it'll use that as well; for each
   name, it'll try without and then with EXECUTABLE_SUFFIX.

   Given, argv[0] = i586-cygwin32-dlltool, it will not even try "as"
   as the fallback, but rather return i586-cygwin32-as.

   Oh, and given, argv[0] = dlltool, it'll return "as".

   Returns a dynamically allocated string.  */

static char *
deduce_name (const char *prog_name)
{
  char *cmd;
  char *dash, *slash, *cp;

  dash = NULL;
  slash = NULL;
  for (cp = program_name; *cp != '\0'; ++cp)
    {
      if (*cp == '-')
	dash = cp;
      if (
#if defined(__DJGPP__) || defined (__CYGWIN__) || defined(__WIN32__)
	  *cp == ':' || *cp == '\\' ||
#endif
	  *cp == '/')
	{
	  slash = cp;
	  dash = NULL;
	}
    }

  cmd = NULL;

  if (dash != NULL)
    {
      /* First, try looking for a prefixed PROG_NAME in the
         PROGRAM_NAME directory, with the same prefix as PROGRAM_NAME.  */
      cmd = look_for_prog (prog_name, program_name, dash - program_name + 1);
    }

  if (slash != NULL && cmd == NULL)
    {
      /* Next, try looking for a PROG_NAME in the same directory as
         that of this program.  */
      cmd = look_for_prog (prog_name, program_name, slash - program_name + 1);
    }

  if (cmd == NULL)
    {
      /* Just return PROG_NAME as is.  */
      cmd = xstrdup (prog_name);
    }

  return cmd;
}

#ifdef DLLTOOL_MCORE_ELF
typedef struct fname_cache
{
  const char *         filename;
  struct fname_cache * next;
}
fname_cache;

static fname_cache fnames;

static void
mcore_elf_cache_filename (const char * filename)
{
  fname_cache * ptr;

  ptr = & fnames;

  while (ptr->next != NULL)
    ptr = ptr->next;

  ptr->filename = filename;
  ptr->next     = (fname_cache *) malloc (sizeof (fname_cache));
  if (ptr->next != NULL)
    ptr->next->next = NULL;
}

#define MCORE_ELF_TMP_OBJ "mcoreelf.o"
#define MCORE_ELF_TMP_EXP "mcoreelf.exp"
#define MCORE_ELF_TMP_LIB "mcoreelf.lib"

static void
mcore_elf_gen_out_file (void)
{
  fname_cache * ptr;
  dyn_string_t ds;

  /* Step one.  Run 'ld -r' on the input object files in order to resolve
     any internal references and to generate a single .exports section.  */
  ptr = & fnames;

  ds = dyn_string_new (100);
  dyn_string_append_cstr (ds, "-r ");

  if (mcore_elf_linker_flags != NULL)
    dyn_string_append_cstr (ds, mcore_elf_linker_flags);

  while (ptr->next != NULL)
    {
      dyn_string_append_cstr (ds, ptr->filename);
      dyn_string_append_cstr (ds, " ");

      ptr = ptr->next;
    }

  dyn_string_append_cstr (ds, "-o ");
  dyn_string_append_cstr (ds, MCORE_ELF_TMP_OBJ);

  if (mcore_elf_linker == NULL)
    mcore_elf_linker = deduce_name ("ld");

  run (mcore_elf_linker, ds->s);

  dyn_string_delete (ds);

  /* Step two. Create a .exp file and a .lib file from the temporary file.
     Do this by recursively invoking dlltool...  */
  ds = dyn_string_new (100);

  dyn_string_append_cstr (ds, "-S ");
  dyn_string_append_cstr (ds, as_name);

  dyn_string_append_cstr (ds, " -e ");
  dyn_string_append_cstr (ds, MCORE_ELF_TMP_EXP);
  dyn_string_append_cstr (ds, " -l ");
  dyn_string_append_cstr (ds, MCORE_ELF_TMP_LIB);
  dyn_string_append_cstr (ds, " " );
  dyn_string_append_cstr (ds, MCORE_ELF_TMP_OBJ);

  if (verbose)
    dyn_string_append_cstr (ds, " -v");

  if (dontdeltemps)
    {
      dyn_string_append_cstr (ds, " -n");

      if (dontdeltemps > 1)
	dyn_string_append_cstr (ds, " -n");
    }

  /* XXX - FIME: ought to check/copy other command line options as well.  */
  run (program_name, ds->s);

  dyn_string_delete (ds);

  /* Step four. Feed the .exp and object files to ld -shared to create the dll.  */
  ds = dyn_string_new (100);

  dyn_string_append_cstr (ds, "-shared ");

  if (mcore_elf_linker_flags)
    dyn_string_append_cstr (ds, mcore_elf_linker_flags);

  dyn_string_append_cstr (ds, " ");
  dyn_string_append_cstr (ds, MCORE_ELF_TMP_EXP);
  dyn_string_append_cstr (ds, " ");
  dyn_string_append_cstr (ds, MCORE_ELF_TMP_OBJ);
  dyn_string_append_cstr (ds, " -o ");
  dyn_string_append_cstr (ds, mcore_elf_out_file);

  run (mcore_elf_linker, ds->s);

  dyn_string_delete (ds);

  if (dontdeltemps == 0)
    unlink (MCORE_ELF_TMP_EXP);

  if (dontdeltemps < 2)
    unlink (MCORE_ELF_TMP_OBJ);
}
#endif /* DLLTOOL_MCORE_ELF */
@


1.107
log
@	* dlltool.c (scan_obj_file): Close arfile after calling
	bfd_openr_next_archived_file.
@
text
@d2281 3
a2300 2
#define INIT_SEC_DATA(id, name, flags, align) \
        { id, name, flags, align, NULL, NULL, NULL, 0, NULL }
d2330 9
a2338 9
  { TEXT,   ".text",    SEC_CODE | SEC_HAS_CONTENTS, 3},
  { PDATA,  ".pdata",   SEC_HAS_CONTENTS,            2},
  { RDATA,  ".reldata", SEC_HAS_CONTENTS,            2},
  { IDATA5, ".idata$5", SEC_HAS_CONTENTS,            2},
  { IDATA4, ".idata$4", SEC_HAS_CONTENTS,            2},
  { IDATA6, ".idata$6", SEC_HAS_CONTENTS,            1},
  { IDATA7, ".idata$7", SEC_HAS_CONTENTS,            2},
  { DATA,   ".data",    SEC_DATA,                    2},
  { BSS,    ".bss",     0,                           2}
@


1.106
log
@Replace all uses of bfd_abs_section, bfd_com_section, bfd_und_section
and bfd_ind_section with their _ptr variants, or use corresponding
bfd_is_* macros.
@
text
@d1697 1
d1700 1
d1702 1
a1702 1
	  arfile = bfd_openr_next_archived_file (f, arfile);
@


1.105
log
@	PR binutils/13682
	* NEWS: Mention new feature.
	* dlltool.c (i386_x64_dljtab): New stub-code for x64
	delayed-load feature.
	(i386_x64_trampoline): New trampoline-code for x64
	delayed-load feature.
	(make_one_lib_file): Add support for x64 delayed-load
	feature.
	(make_delay_head): Likewis
@
text
@d2533 1
a2533 1
  iname_lab->section = (asection *) &bfd_und_section;
d2566 1
a2566 1
    toc_symbol->section = (asection *)&bfd_und_section;
@


1.104
log
@	* sysdep.h: Include sys/stat.h here.
	* ar.c: Don't include headers already included by sysdep.h.
	* bucomm.c: Likewise.
	* budbg.h: Likewise.
	* dlltool.h: Likewise.
	* elfedit.c: Likewise.
	* nlmconv.c: Likewise.
	* objcopy.c: Likewise.
	* objdump.c: Likewise.
	* objdump.h: Likewise.
	* readelf.c: Likewise.
	* rename.c: Likewise.
	* resrc.c: Likewise.
	* strings.c: Likewise.
	* windres.c: Likewise.
	* od-macho.c: Ensure #include sysdep.h is first.
	* od-xcoff.c: Likewise.
	* dllwrap.c: Remove alloca pragma handled by sysdep.h, and
	remove duplicate headers.
	* dlltool.c: Likewise and ensure #include sysdep.h is first.
@
text
@d518 8
d602 16
d762 1
a762 1
    i386_dljtab, sizeof (i386_dljtab), 2, 7, 12, i386_trampoline
d2636 5
a2640 1
	          rel2->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);
d2642 2
a2643 1
	          rel3->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32_PCREL);
d2655 2
a2656 2
	      si->data = xmalloc (4);
	      si->size = 4;
d2659 1
d2667 4
a2670 1
	      rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);
d3041 2
d3051 4
a3054 5
#ifdef DLLTOOL_MX86_64
      fprintf (f,"\t%s\t0\n\t%s\t0\n", ASM_LONG, ASM_LONG);
#else
      fprintf (f,"\t%s\t0\n", ASM_LONG);
#endif
d3062 2
@


1.103
log
@2011-10-13  Nick Clifton  <nickc@@redhat.com>

	Fixes to aid translation:
	* addr2line.c (translate_address): Add comments describing context
	of a couple of printf statements.
	* ar.c (write_archive): Allow translation of error message.
	* bucomm.c (endian_string): Allow translation of strings.
	(display_target_list): Allow translation.
	* coffdump.c (dump_coff_type): Allow translation of output.
	(dump_coff_where): Likewise.
	(dump_coff_symbol): Likewise.
	(dump_coff_scope): Likewise.
	(dump_coff_sfile): Likewise.
	(dump_coff_section): Likewise.
	(coff_dump): Likewise.
	* dlltool (def_version): Allow translation of output.
	(run): Likewise.
	* dllwrap.c (run): Allow translation of output.
	* dwarf.c (print_dwarf_vma): Allow translation of output.
	(process_extended_line_op): Remove spurious translation.
	Add translation for strings that can be translated.
	(decode_location_exression): Allow translation of output.
	(read_and_display_attr_value): Allow translation of output.
	* readelf.c (slurp_rela_relocs): Add translation for error
	messages when failing to get data.
	(slurp_rel_relocs): Likewise.
	(get_32bit_elf_symbols): Likewise.
	(get_64bit_elf_symbols): Likewise.
	(dump_ia64_vms_dynamic_relocs): Replace abbreviation with full
	word.
	(process_relocs): Remove spurious translation.
	(decode_tic6x_unwind_bytecode): Likewise.
	(process_version_section): Improve error messages.
	(process_mips_specific): Likewise.
	(print_gnu_note): Remove spurious translation.
	(print_stapsdt_note): Likewise.
	(get_ia64_vms_note_type): Likewise.
	* sysdump.c (getCHARS): Allow translation.
	(fillup): Allow translation of output.
	(getone): Likewise.
	(must): Likewise.
	(derived_type): Likewise.
	* doc/binutils.doc (addr2line): Extend description of command line
	options.
	* po/binutils.pot: Regenerate.
@
text
@d3 1
a3 1
   2005, 2006, 2007, 2008, 2009, 2011  Free Software Foundation, Inc.
a234 9
/* AIX requires this to be the first thing in the file.  */
#ifndef __GNUC__
# ifdef _AIX
 #pragma alloca
#endif
#endif

#define show_allnames 0

a245 2
#include <sys/stat.h>
#include <stdarg.h>
d311 2
@


1.102
log
@2010-12-01  Kai Tietz  <kai.tietz@@onevision.com>

       PR binutils/11065
       * dlltool.c (dll_name_set_by_exp_name): New variable.
       (def_name): Allow setting of dll_name by .def file.
       (def_library): Likewise.
       (main): Set dll_name_set_by_exp_name, if dll_name is
       set indirect by exp_name.
@
text
@d3 1
a3 1
   2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
d1266 1
a1266 1
  printf ("VERSION %d.%d\n", major, minor);
d1314 1
a1314 1
  inform ("run: %s %s", what, args);
@


1.101
log
@2010-10-30  Kai Tietz  <kai.tietz@@onevision.com>

        * dlltool.c (scan_drectve_symbols): Allow quoted strings for -export
        directives.
@
text
@d402 1
d1093 5
d1114 6
d4192 1
@


1.100
log
@2010-04-27  Kai Tietz  <kai.tietz@@onevision.com>

	* dlltool.c (main): Query for bfd's underscoring default for
	default target case.

2010-04-27  Kai Tietz  <kai.tietz@@onevision.com>

	* binutils-all/dlltool.exp: Allow test for
	arm-wince-pe target.
@
text
@d1402 14
a1415 3
	  name = p;
	  while (p < e && *p != ',' && *p != ' ' && *p != '-')
	    p++;
d1419 3
@


1.99
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d4146 10
@


1.98
log
@        PR binutils/11017
        * dlltool.c (PAGE_SIZE): Delete.
        (PAGE_MASK): Provide default definition based on COFF_PAGE_SIZE.
        Check for DLLTOOL_DEFAULT_MX86_64 and DLLTOOL_DEFAULT_I386.

        * coff-i386.h (COFF_PAGE_SIZE): Definition moved to coff/i386.h

        * i386lh (COFF_PAGE_SIZE): Define.
        * x86_64.h (COFF_PAGE_SIZE): Define.
@
text
@d882 1
a882 1
rvaafter (int machine)
d884 1
a884 1
  switch (machine)
d901 1
a901 1
      fatal (_("Internal error: Unknown machine type: %d"), machine);
d908 1
a908 1
rvabefore (int machine)
d910 1
a910 1
  switch (machine)
d927 1
a927 1
      fatal (_("Internal error: Unknown machine type: %d"), machine);
d934 1
a934 1
asm_prefix (int machine, const char *name)
d936 1
a936 1
  switch (machine)
d958 1
a958 1
      fatal (_("Internal error: Unknown machine type: %d"), machine);
d1158 1
a1158 1
append_import (const char *symbol_name, const char *dll_name, int func_ordinal,
d1166 1
a1166 1
      if (strcmp ((*pq)->dllname, dll_name) == 0)
d1181 1
a1181 1
  q->dllname = xstrdup (dll_name);
@


1.97
log
@2009-10-28  Kai Tietz <kai.tietz@@onevision.com>

	* dlltool.c (leading_underscore): New local variable.
	(asm_prefix): Interpret leading_underscore.
	(xlate): Likewise.
	(add_excludes): Use leading_underscore for making
	symbol name.
	(gen_exp_file): Use leading_underscore for internal
	_imp_ symbols.
	(usage): Add display of --no-leading-underscore and
	--leading-underscore option.
	(OPTION_NO_LEADING_UNDERSCORE): New.
	(OPTION_LEADING_UNDERSCORE): New.
	(long_options): Add --no-leading-underscore and
	--leading-underscore option.
	(main): Handle new options.
	* doc/binutils.text: Add documentation of the options
	--no-leading-underscore and --leading-underscore.
@
text
@a243 3
#define PAGE_SIZE ((bfd_vma) 4096)
#define PAGE_MASK ((bfd_vma) (-4096))

d263 1
a263 1
#ifdef DLLTOOL_MX86_64
d266 11
d278 1
a278 1
/* get current BFD error message */
d2130 1
a2130 1
      bfd_vma need[PAGE_SIZE];
@


1.96
log
@2009-10-23  Kai Tietz  <kai.tietz@@onevision.com>

	* deflex.l: Allow '<' and '>' in ID names.

	* defparse.y (EQUAL): New token constant.
	(opt_import_name): New rule for emptry or '==' ID.
	(expline): Add opt_import_name as last line element.
	(impline): Likewise.
	* dlltool.c (ifunct): New member its_name.
	(export): Likewise.
	(append_import): Add its_name argument.
	(defexports): Likewise.
	(defimport): Likewise.
	(scan_drectve_symbols): Adjust calls to def_exports.
	(dump_def_info): Print new optinal import/export table
	symbol name.
	(generate_idata_ofile): Use its_name member.
	(make_one_lib_file): Likewise.
	(nfunc): Take its_name in account on sort.
	* dlltool.h (def_exports): Add its_name as argument.
	(def_import): Likewise.
	* doc/binutils.texi: Add new def file syntax extension.
	* deflex.l (EQUAL): Add rule for '=='.
	* NEWS: Mention new feature.

2009-10-23  Kai Tietz  <kai.tietz@@onevision.com>

	* binutils-all/dlltool.exp: Add new test.
	* binutils-all/alias-2.def: New file.
@
text
@d397 5
d944 1
a944 1
      if (name && *name == '?')
d1496 2
a1497 1
	sprintf (new_exclude->string, "_%s", exclude_string);
d2109 2
a2110 1
	    fprintf (f, "\t%s\t_imp__%s\n", ASM_GLOBAL, exp->name);
d2113 1
a2113 1
	    fprintf (f, "_imp__%s:\n", exp->name);
d2192 1
d2195 1
a2195 2
		   || (add_stdcall_underscore
		       && strchr (name, '@@'))))
d3882 2
d3916 2
d3938 2
d4011 6
@


1.95
log
@	PR binutils/10792
	* dlltool.c (dll_name_list_append): Declare variable at start
	of block.
	(dll_name_list_count, dll_name-list_print): Likewise.
@
text
@d332 1
d751 1
d778 1
a778 1
static void append_import (const char *, const char *, int);
d1026 2
a1027 1
	     int noname, int constant, int data, int private)
d1033 1
d1145 2
a1146 1
append_import (const char *symbol_name, const char *dll_name, int func_ordinal)
d1160 1
d1174 1
d1213 1
a1213 1
	    const char *entry, int ord_val)
d1235 1
a1235 1
  append_import (application_name, module, ord_val);
d1407 1
a1407 1
	  def_exports (c, 0, -1, 0, 0, ! (flags & BSF_FUNCTION), 0);
d1416 1
a1416 1
	      def_exports (exported_name, xstrdup (c), -1, 0, 0, 0, 0);
d1455 1
a1455 1
		   ! (sym->flags & BSF_FUNCTION), 0);
d1464 1
a1464 1
	  def_exports (exported_name, xstrdup (symbol_name), -1, 0, 0, 0, 0);
d1679 1
a1679 1
      fprintf (f, "%s  %d = %s %s @@ %d %s%s%s%s\n",
d1688 3
a1690 1
	       exp->data ? "DATA" : "");
d1773 1
a1773 1
	  fprintf (output_def, "\t%s%s%s @@ %d%s%s%s\n",
d1780 3
a1782 1
		   exp->data ? " DATA" : "");
d1788 1
a1788 1
	  fprintf (output_def, "\t%s%s%s = %s%s%s @@ %d%s%s%s\n",
d1798 3
a1800 1
		   exp->data ? " DATA" : "");
d1904 2
a1905 1
	  fprintf (filvar,"\t%s\t\"%s\"\n", ASM_TEXT, funcptr->name);
d2040 2
a2041 1
		     exp->ordinal, ASM_TEXT, xlate (exp->name));
d2681 4
a2684 1
	      si->size = strlen (xlate (exp->import_name)) + 3;
d2688 4
a2691 1
	      strcpy ((char *) si->data + 2, xlate (exp->import_name));
d2982 1
a2982 1
      fprintf (f, "\t.section\t.idata$5\n");
d3142 1
d3651 4
a3654 1

d4181 1
a4181 1
          inform (_("Warning, machine type (%d) not supported for "
@


1.94
log
@        PR 10768
        * dlltool.c (bfd_get_errmsg): New macro.
        (scan_obj_file): Use it.
        (make_one_lib_file): Use it.
        (make_head): Use it.
        (make_delay_head): Use it.
        (make_tail): Use it.
        (gen_lib_file): Use it.
        (identify_dll_for_implib): Use it.
        (identify_search_archive):  Use it.
@
text
@d3195 2
d3202 2
a3203 2
  dll_name_list_node_type * entry =
    (dll_name_list_node_type *) xmalloc (sizeof (dll_name_list_node_type));
d3219 3
d3226 1
a3226 2
  int count = 0;
  dll_name_list_node_type * p = list->head;
d3241 2
d3247 1
a3247 1
  dll_name_list_node_type * p = list->head;
@


1.93
log
@2009-09-04  Timo Kreuzer  <timo.kreuzer@@web.de>

	* dlltool.c (delayimp_name): Add new global variable
	(usage, long_options, main): Add new option "-y" / "--output-delaylib"
	(struct mac): Add fields how_dljtab_size, how_dljtab_roff1,
	how_dljtab_roff2, how_dljtab, trampoline.
	(i386_dljtab): Add binary stub for x86 delay import.
	(i386_trampoline): Add text assembly stub for x86 delay import.
	(mtable): Add delay import data for M386 and MX86 only.
	(make_delay_head): New function.
	(make_one_lib_file): New arg delay creates delay-load import stub.
	(gen_lib_file): New arg delay likewise.
	(HOW_JTAB, HOW_JTAB_SIZE, HOW_JTAB_ROFF): New arg delay likewise.
	(HOW_JTAB_ROFF2, HOW_JTAB_ROFF3): New macros for delay import.
	(make_tail): Convert hard TABS embedded in strings to "\t" escapes.
	* NEWS: Mention new feature.  Also fix whitespace.
	* doc/binutils.texi: Updated dlltool documentation.
@
text
@d246 1
d270 3
d338 1
a338 1
  char          *dllname;  /* Name of dll file imported from.  */
a348 1

a350 1

a351 1

d369 1
d382 1
a392 1

d589 25
a613 25
  {
    const char *type;
    const char *how_byte;
    const char *how_short;
    const char *how_long;
    const char *how_asciz;
    const char *how_comment;
    const char *how_jump;
    const char *how_global;
    const char *how_space;
    const char *how_align_short;
    const char *how_align_long;
    const char *how_default_as_switches;
    const char *how_bfd_target;
    enum bfd_architecture how_bfd_arch;
    const unsigned char *how_jtab;
    int how_jtab_size; /* Size of the jtab entry.  */
    int how_jtab_roff; /* Offset into it for the ind 32 reloc into idata 5.  */
    const unsigned char *how_dljtab;
    int how_dljtab_size; /* Size of the dljtab entry.  */
    int how_dljtab_roff1; /* Offset for the ind 32 reloc into idata 5.  */
    int how_dljtab_roff2; /* Offset for the ind 32 reloc into idata 5.  */
    int how_dljtab_roff3; /* Offset for the ind 32 reloc into idata 5.  */
    const char *trampoline;
  };
d746 13
a758 13
  {
    const char *name;
    const char *internal_name;
    const char *import_name;
    int ordinal;
    int constant;
    int noname;		/* Don't put name in image file.  */
    int private;	/* Don't put reference in import lib.  */
    int data;
    int hint;
    int forward;	/* Number of forward label, 0 means no forward.  */
    struct export *next;
  }
d1625 1
a1625 1
    fatal (_("Unable to open object file: %s"), filename);
d1659 1
a1659 1
/**********************************************************************/
d2372 2
a2373 1
    fatal (_("bfd_open failed open stub file: %s"), outname);
d2394 1
a2394 1
	abort();
d2830 5
d2842 1
d2905 7
a2911 1
  return bfd_openr (TMP_HEAD_O, HOW_BFD_READ_TARGET);
d2918 1
d2985 7
a2991 1
  return bfd_openr (TMP_HEAD_O, HOW_BFD_READ_TARGET);
d2998 1
d3056 7
a3062 1
  return bfd_openr (TMP_TAIL_O, HOW_BFD_READ_TARGET);
d3081 2
a3082 1
    fatal (_("Can't open .lib file: %s"), imp_name);
d3392 3
a3394 1
    bfd_fatal (identify_imp_name);
@


1.93.2.1
log
@	PR binutils/10792
	* dlltool.c (dll_name_list_append): Declare variable at start
	of block.
	(dll_name_list_count, dll_name-list_print): Likewise.
@
text
@a3164 2
  dll_name_list_node_type * entry;

d3170 2
a3171 2
  entry = ((dll_name_list_node_type *)
	   xmalloc (sizeof (dll_name_list_node_type)));
a3186 3
  dll_name_list_node_type * p;
  int count = 0;

d3191 2
a3192 1
  p = list->head;
a3206 2
  dll_name_list_node_type * p;

d3211 1
a3211 1
  p = list->head;
@


1.92
log
@binutils/ChangeLog

	* dlltool.c (set_dll_name_from_def):  Accept new second arg that
	indicates if we are building DLL or EXE, and use it to add a
	default suffix to the output filename when none is already present.
	(def_name):  Indicate we are building an EXE when calling it.
	(def_library):  Indicate we are building a DLL when calling it.

ld/testsuite/ChangeLog

	* ld-cygwin/exe-export.exp:  Add "-lkernel32" when linking test exe.
	* ld-cygwin/testexe.c (testexe_main):  Indicate whether global_a
	was set to correct final value using error return status.
	(testexe_dummy):  Dummy function calls an import from kernel32.dll
	to ensure it is mapped into the process space at runtime.
@
text
@d355 1
d503 7
d576 10
d605 6
d622 2
a623 1
    arm_jtab, sizeof (arm_jtab), 8
d631 2
a632 1
    i386_jtab, sizeof (i386_jtab), 2
d640 2
a641 1
    ppc_jtab, sizeof (ppc_jtab), 0
d650 2
a651 1
    thumb_jtab, sizeof (thumb_jtab), 12
d660 2
a661 1
    arm_interwork_jtab, sizeof (arm_interwork_jtab), 12
d670 2
a671 1
    mcore_be_jtab, sizeof (mcore_be_jtab), 8
d680 2
a681 1
    mcore_le_jtab, sizeof (mcore_le_jtab), 8
d690 2
a691 1
    mcore_be_jtab, sizeof (mcore_be_jtab), 8
d700 2
a701 1
    mcore_le_jtab, sizeof (mcore_le_jtab), 8
d710 2
a711 1
    arm_jtab, sizeof (arm_jtab), 8
d720 2
a721 1
    arm_jtab, sizeof (arm_jtab), 8
d729 2
a730 1
    i386_jtab, sizeof (i386_jtab), 2
d733 1
a733 1
  { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0 }
d795 1
a795 1
static bfd *make_one_lib_file (export_type *, int);
d798 2
a799 1
static void gen_lib_file (void);
d963 8
a970 3
#define HOW_JTAB		mtable[machine].how_jtab
#define HOW_JTAB_SIZE		mtable[machine].how_jtab_size
#define HOW_JTAB_ROFF		mtable[machine].how_jtab_roff
d2341 1
a2341 1
make_one_lib_file (export_type *exp, int i)
d2507 1
a2507 1
      arelent *rel;
d2522 1
a2522 1
	      rpp = xmalloc (sizeof (arelent *) * 2);
d2529 13
d2559 9
d2569 9
d2579 12
d2592 1
a2592 1
	  break;
a2593 1
	case IDATA5:
d2671 2
d2842 1
a2842 1
  fprintf (f, "\t.section	.idata$2\n");
d2844 1
a2844 1
  fprintf(f,"\t%s\t%s\n", ASM_GLOBAL,head_label);
d2899 73
d2985 1
a2985 1
      fprintf (f, "\t.section	.idata$4\n");
d2994 1
a2994 1
      fprintf (f, "\t.section	.idata$5\n");
d3009 1
a3009 1
  fprintf (f, "\t.section	.idata$3\n");
d3020 1
a3020 1
  fprintf (f, "\t.section	.idata$6\n");
d3022 1
a3022 1
  fprintf (f, "\t.section	.idata$7\n");
d3037 1
a3037 1
gen_lib_file (void)
d3062 8
a3069 1
  ar_head = make_head ();
d3081 1
a3081 1
      n = make_one_lib_file (exp, i);
d3100 1
a3100 1
	  n = make_one_lib_file (&alias_exp, i + PREFIX_ALIAS_BASE);
d3797 1
d3880 1
d3910 1
a3910 1
			   "m:e:l:aD:d:z:b:xp:cCuUkAS:f:nI:vVHh",
d4031 3
d4108 26
a4133 1
      gen_lib_file ();
@


1.91
log
@        PR 9766
        * dlltool.c (xlate): When strip text after the @@ sign, look for
        the last one not the first one.
@
text
@d785 1
a785 1
static void set_dll_name_from_def (const char *);
d1004 1
a1004 1
set_dll_name_from_def (const char * name)
d1006 1
a1006 1
  const char* image_basename = lbasename (name);
d1010 10
a1019 1
  dll_name = xstrdup (image_basename);
d1033 2
a1034 2
  if (! dll_name)
    set_dll_name_from_def (name);
d1048 2
a1049 2
  if (! dll_name)
    set_dll_name_from_def (name);
@


1.90
log
@Cleanup code related to --identify option.

        * binutils/dlltool.c (file scope): Removed globals identify_ms,
        identify_member_contains_symname_result,
        identify_dll_name_list_head, and identify_dll_name_list_tail.
        Renamed existing typedef dll_name_list_type to
        dll_name_list_node_type.
        Added new typedefs dll_name_list_type, symname_search_data_type,
        and identify_data_type.
        (identify_append_dll_name_to_list): Renamed to...
        (dll_name_list_append): ...here.  Changed signature to accept list
        argument rather than use global.
        (identify_count_dll_name_list): Renamed to...
        (dll_name_list_count): ...here.  Changed signature to accept list
        argument rather than use global.
        (identify_print_dll_name_list): Renamed to...
        (dll_name_list_print): ...here.  Changed signature to accept list
        argument rather than use global.
        (identify_free_dll_name_list): Renamed to...
        (dll_name_list_free_contents): ...here.
        (dll_name_list_free): New function.
        (dll_name_list_create): New function.
        (identify_process_section_p): Changed signature to accept
        ms_style_implib argument rather than use global.
        (identify_member_contains_symname): Expect incoming void * data to
        be symname_search_data_type.
        (identify_dll_for_implib): Use new functions dll_name_list_create
        and dll_name_list_free.  Use new types symname_search_data_type
        and identify_data_type to communicate with search routines.
        (identify_search_section): Expect incoming void * data to be
        identify_data_type. Use its contents rather than global
        variables.
@
text
@d2134 3
a2136 2
      p = strchr (name, '@@');
      if (p)
@


1.89
log
@Add --identify-strict option.  Handle ms-style implibs:

        * dlltool.c (file scope): Added new globals identify_ms and
        identify_strict. New typedef dll_name_list_type, and globals
        identify_dll_name_list_head and identify_dll_name_list_tail. Added
        new global identify_member_contains_symname_result.
        (identify_append_dll_name_to_list): New function.
        (identify_count_dll_name_list): New function.
        (identify_print_dll_name_list): New function.
        (identify_free_dll_name_list): New function.
        (identify_search_archive): Changed signature to take function
        pointer to operation to apply to each member, and data to pass on
        to that function.
        (identify_search_member): Changed signature to accept user data
        from caller.
        (identify_member_contains_symname): New function.
        (identify_dll_for_implib): Rewrite. Now determines whether implib
        is ms- or binutils- style, before searching sections for
        dllname. Allows multiple dllnames.
        (identify_process_section_p): Search alternate section for dllname
        when implib is ms-style.
        (identify_search_section): Add additional conditions to excludes
        candidate sections from consideration.
        (usage): Added --identify-strict.
        (long_options): Added --identify-strict.
        (main): Handle --identify-strict option.
        * doc/binutils.texi: Document --identify-strict option.
        * NEWS: Document --identify and --identify-strict options.
@
text
@a355 1
static bfd_boolean identify_ms;
d358 9
a366 4
/* Holds a linked list of dllnames associated with the
   specified import lib. Used by the identify_* code.
   The _head entry is always empty (_head->dllname is
   NULL).  */
d369 16
a384 12
  char *                   dllname;
  struct dll_name_list_t * next;
} dll_name_list_type;

static dll_name_list_type * identify_dll_name_list_head;
static dll_name_list_type * identify_dll_name_list_tail;
/* dll_name_list management functions.  */
static void identify_append_dll_name_to_list (bfd_byte *);
static int  identify_count_dll_name_list (void);
static void identify_print_dll_name_list (void);
static void identify_free_dll_name_list (dll_name_list_type *);
static bfd_boolean identify_member_contains_symname_result = FALSE;
d763 6
d773 1
a773 1
static bfd_boolean identify_process_section_p (asection *);
d2984 1
a2984 1
/* Management of the identify_dll_name_list.  */
d2987 1
a2987 1
identify_append_dll_name_to_list (bfd_byte * data)
d2989 4
d2994 2
a2995 2
  dll_name_list_type * entry =
    (dll_name_list_type *) xmalloc (sizeof (dll_name_list_type));
d3002 2
a3003 2
  identify_dll_name_list_tail->next = entry;
  identify_dll_name_list_tail = entry;
d3006 2
d3009 1
a3009 1
identify_count_dll_name_list (void)
d3011 4
d3016 1
a3016 1
  dll_name_list_type * p = identify_dll_name_list_head;
d3026 2
d3029 1
a3029 1
identify_print_dll_name_list (void)
d3031 5
a3035 1
  dll_name_list_type * p = identify_dll_name_list_head;
d3044 17
d3062 1
a3062 1
identify_free_dll_name_list (dll_name_list_type * entry)
d3068 1
a3068 1
          identify_free_dll_name_list (entry->next);
d3080 22
d3117 1
a3117 1
  const char * name = (const char *) obj;
d3121 1
a3121 1
  if (identify_member_contains_symname_result)
d3138 3
a3140 1
      if (strncmp (symbol_table[i]->name, name, strlen (name)) == 0)
d3142 1
a3142 1
	  identify_member_contains_symname_result = TRUE;
d3171 2
d3174 7
a3180 5
  /* Initialize identify_dll_name_list.  */
  identify_dll_name_list_head = xmalloc (sizeof (dll_name_list_type));
  identify_dll_name_list_head->dllname = NULL;
  identify_dll_name_list_head->next = NULL;
  identify_dll_name_list_tail = identify_dll_name_list_head;
d3197 5
a3201 5
  identify_member_contains_symname_result = FALSE;
  identify_search_archive (abfd, identify_member_contains_symname,
			   "__NULL_IMPORT_DESCRIPTOR");
  if (identify_member_contains_symname_result)
    identify_ms = TRUE;
d3219 3
a3221 1
  identify_search_archive (abfd, identify_search_member, NULL);
d3226 1
a3226 1
  count = identify_count_dll_name_list();
d3231 2
a3232 2
          identify_free_dll_name_list (identify_dll_name_list_head);
          identify_dll_name_list_head = NULL;
d3236 3
a3238 3
      identify_print_dll_name_list();
      identify_free_dll_name_list (identify_dll_name_list_head);
      identify_dll_name_list_head = NULL;
d3242 2
a3243 2
      identify_free_dll_name_list (identify_dll_name_list_head);
      identify_dll_name_list_head = NULL;
d3305 2
a3306 1
   By default, this is .idata$7 (.idata$6 on PPC, or when --identify-ms).  */   
d3309 1
a3309 1
identify_process_section_p (asection * section)
d3319 1
a3319 1

d3321 1
a3321 1
    (identify_ms ? MS_SECTION_NAME : SECTION_NAME);
d3330 1
a3330 2
   -- then store the contents in the list pointed to by
   identify_dll_name_list_head.  */   
d3333 1
a3333 1
identify_search_section (bfd * abfd, asection * section, void * dummy ATTRIBUTE_UNUSED)
d3337 2
d3343 1
a3343 1
  if (! identify_process_section_p (section))
d3349 1
a3349 1
  if (!identify_ms && ((section->flags & SEC_RELOC) == SEC_RELOC))
d3355 1
a3355 1
  if (identify_ms && ((section->flags & SEC_DATA) == 0))
d3372 2
a3373 2
     also fail to record a valid dll name if the dllname is
     uses a multibyte or unicode character set (is that valid?).
d3383 1
a3383 1
    identify_append_dll_name_to_list (data);
@


1.88
log
@2009-01-12  Kai Tietz  <kai.tietz@@onevision.com>

        * dlltool.c (create_for_pep): New.
        (flush_page): Use create_for_pep instead of using
        macro DLLTOOL_MX86_64 clause.
        (generate_idata_ofile): Likewise.
        (make_one_lib_file): Likewise.
        (make_head): Likewise.
        (make_tail): Likewise.
        (main): Initialize create_for_pep.
@
text
@d3 1
a3 1
   2005, 2006, 2007, 2008 Free Software Foundation, Inc.
d356 22
a377 1
static char *identify_dll_name;
d756 3
a758 2
static void identify_search_archive (bfd*);
static void identify_search_member (bfd*, bfd*);
d761 2
d2970 124
a3093 1
/* identify_dll_for_implib
a3094 12
   This is the main implementation for the --identify option.
   Given the name of an import library in identify_imp_name,
   search all archive members for an .idata$7 section
   (.idata$6 on PPC). This section will consist of a single
   char* constant, indicating the name of the DLL represented
   by the import library.

   It is possible to construct an import library that has
   two members with a non-empty .idata$7 section, but these
   are not often seen in normal operation.  In this case,
   an error is flagged.
*/   
d3098 8
a3105 1
  bfd* abfd = NULL;
d3111 3
d3115 4
a3118 1
      bfd_fatal (identify_imp_name);
d3120 15
d3140 1
a3140 1
      fatal ("%s is not a library", identify_imp_name);
d3142 3
d3146 1
a3146 3
  identify_search_archive (abfd);

  if (!bfd_close (abfd))
d3149 2
a3150 1
  if (identify_dll_name && *identify_dll_name)
d3152 10
a3161 3
      printf ("%s\n",identify_dll_name);
      free (identify_dll_name);
      identify_dll_name = NULL;
d3165 4
a3168 1
      fatal ("Unable to determine dll name for %s (not an import library?)", identify_imp_name);
d3172 3
a3174 1
/* identify_search_archive
a3175 4
   Loop over all members of the archive, inspecting 
   each for the presence of an .idata$7 (.idata$6 on PPC)
   section with non-empty contents.
*/   
d3177 7
a3183 5
identify_search_archive (bfd* abfd)
{
  bfd *arfile = NULL;
  bfd *last_arfile = NULL;
  char **matching;
d3195 1
d3197 1
a3197 3
        {
          identify_search_member (arfile, abfd);
        }
d3203 1
d3205 2
a3206 3
        {
          bfd_close (last_arfile);
        }
d3216 2
a3217 1
/* identify_search_member
a3218 4
   Search all sections of an archive member for the 
   one with section name of .idata$7 (.idata$6 on PPC)
   and non-empty contents.
*/   
d3220 3
a3222 1
identify_search_member (bfd* abfd, bfd* archive_bfd ATTRIBUTE_UNUSED)
d3224 1
a3224 1
  bfd_map_over_sections (abfd, identify_search_section, NULL);
d3227 2
a3228 1
/* identify_process_section_p
a3229 3
   This predicate returns true if section->name
   is .idata$7 (.idata$6 on PPC).
*/   
d3240 1
d3242 4
a3245 1
  if (strcmp (SECTION_NAME, section->name) == 0)
d3250 4
a3253 1
/* identify_search_section
a3254 11
   If *section has contents and its name is .idata$7
   (.data$6 on PPC) then store the contents in 
   identify_dll_name as an xmalloc'ed array.

   However, if identify_dll_name already has
   a value, flag an error. We don't know how to handle
   import libraries that directly reference more than
   one DLL. (This is different than forwarded symbols.
   Such import libraries are not seen in normal operation,
   and must be specifically constructed.)
*/   
d3256 1
a3256 1
identify_search_section (bfd *abfd, asection *section, void *dummy ATTRIBUTE_UNUSED)
d3267 12
d3282 1
a3282 1
  data = (bfd_byte*) xmalloc (datasize + 1);
d3288 17
a3304 20
  if (data[0] != '\0')
    {
      if (identify_dll_name != NULL)
        {
          if (*identify_dll_name != '\0')
            {
              /* The import library specifies two different DLLs.
                 Treat this as an error. */
              fatal ("Import library `%s' specifies two or more dlls: `%s' and `%s'",
                     identify_imp_name, identify_dll_name, data);
            }
          else
            {
              /* For some reason memory was allocated, but the
                 contents were empty. Free the memory and continue. */
              free (identify_dll_name);
            }
        }
      identify_dll_name = xstrdup ((char*) data);
    }
d3317 1
d3565 1
d3587 1
d3612 1
d3678 3
@


1.87
log
@2009-01-08  Kai Tietz  <kai.tietz@@onevision.com>

	* dlltool.c (use_nul_prefixed_import_tables): New.
	(make_head): Make prefix leading zero prefix element for
	idata$4 and idata$5 dependent to new flag.
	(usage): Add new option  --use-nul-prefixed-import-tables.
	(OPTION_USE_NUL_PREFIXED_IMPORT_TABLES): New.
	(long_options): Add --use-nul-prefixed-import-tables.
	(main): Likewise.
	* doc/binutils.texi: Add new option documentation for
	--use-nul-prefixed-import-tables.
	* NEWS: Add new option.
@
text
@d383 3
d1626 10
a1635 7
#ifndef DLLTOOL_MX86_64
	  /* Relocation via HIGHLOW.  */
          needed = ((needed - page_addr) | 0x3000) & 0xffff;
#else
	  /* Relocation via DIR64.  */
	  needed = ((needed - page_addr) | 0xa000) & 0xffff;
#endif
d1751 13
a1763 12
#ifdef DLLTOOL_MX86_64
	fprintf (filvar, "\t%sfuncptr%d_%d%s\n%s\t0\n",
		 ASM_RVA_BEFORE, headindex, funcindex, ASM_RVA_AFTER,ASM_LONG);
#else
	fprintf (filvar, "\t%sfuncptr%d_%d%s\n",
		 ASM_RVA_BEFORE, headindex, funcindex, ASM_RVA_AFTER);
#endif
#ifdef DLLTOOL_MX86_64
      fprintf (filvar, "\t%s\t0\n\t%s\t0\n", ASM_LONG, ASM_LONG); /* NULL terminating list.  */
#else
      fprintf (filvar, "\t%s\t0\n", ASM_LONG); /* NULL terminating list.  */
#endif
d1773 13
a1785 12
#ifdef DLLTOOL_MX86_64
	fprintf (filvar, "\t%sfuncptr%d_%d%s\n%s\t0\n",
		 ASM_RVA_BEFORE, headindex, funcindex, ASM_RVA_AFTER,ASM_LONG);
#else
	fprintf (filvar, "\t%sfuncptr%d_%d%s\n",
		 ASM_RVA_BEFORE, headindex, funcindex, ASM_RVA_AFTER);
#endif
#ifdef DLLTOOL_MX86_64
      fprintf (filvar, "\t%s\t0\n\t%s\t0\n", ASM_LONG, ASM_LONG); /* NULL terminating list.  */
#else
      fprintf (filvar, "\t%s\t0\n", ASM_LONG); /* NULL terminating list.  */
#endif
d2465 1
a2465 5
#ifdef DLLTOOL_MX86_64
	  si->data = xmalloc (8);
	  si->size = 8;

	  if (exp->noname)
d2467 27
a2493 8
	      si->data[0] = exp->ordinal ;
	      si->data[1] = exp->ordinal >> 8;
	      si->data[2] = exp->ordinal >> 16;
	      si->data[3] = exp->ordinal >> 24;
	      si->data[4] = 0;
	      si->data[5] = 0;
	      si->data[6] = 0;
	      si->data[7] = 0x80;
d2497 24
a2520 22
	      sec->reloc_count = 1;
	      memset (si->data, 0, si->size);
	      rel = xmalloc (sizeof (arelent));
	      rpp = xmalloc (sizeof (arelent *) * 2);
	      rpp[0] = rel;
	      rpp[1] = 0;
	      rel->address = 0;
	      rel->addend = 0;
	      rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_RVA);
	      rel->sym_ptr_ptr = secdata[IDATA6].sympp;
	      sec->orelocation = rpp;
	    }
#else
	  si->data = xmalloc (4);
	  si->size = 4;

	  if (exp->noname)
	    {
	      si->data[0] = exp->ordinal ;
	      si->data[1] = exp->ordinal >> 8;
	      si->data[2] = exp->ordinal >> 16;
	      si->data[3] = 0x80;
a2521 15
	  else
	    {
	      sec->reloc_count = 1;
	      memset (si->data, 0, si->size);
	      rel = xmalloc (sizeof (arelent));
	      rpp = xmalloc (sizeof (arelent *) * 2);
	      rpp[0] = rel;
	      rpp[1] = 0;
	      rel->address = 0;
	      rel->addend = 0;
	      rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_RVA);
	      rel->sym_ptr_ptr = secdata[IDATA6].sympp;
	      sec->orelocation = rpp;
	    }
#endif
d2737 4
a2740 5
#ifdef DLLTOOL_MX86_64
          fprintf (f,"\t%s\t0\n\t%s\t0\n", ASM_LONG, ASM_LONG);
#else
          fprintf (f,"\t%s\t0\n", ASM_LONG);
#endif
d2750 4
a2753 5
#ifdef DLLTOOL_MX86_64
          fprintf (f,"\t%s\t0\n\t%s\t0\n", ASM_LONG, ASM_LONG);
#else
          fprintf (f,"\t%s\t0\n", ASM_LONG);
#endif
d2779 4
a2782 5
#ifdef DLLTOOL_MX86_64
      fprintf (f,"\t%s\t0\n\t%s\t0\n", ASM_LONG, ASM_LONG); /* NULL terminating list.  */
#else
      fprintf (f,"\t%s\t0\n", ASM_LONG); /* NULL terminating list.  */
#endif
d2788 4
a2791 5
#ifdef DLLTOOL_MX86_64
      fprintf (f,"\t%s\t0\n\t%s\t0\n", ASM_LONG, ASM_LONG); /* NULL terminating list.  */
#else
      fprintf (f,"\t%s\t0\n", ASM_LONG); /* NULL terminating list.  */
#endif
d3610 3
@


1.86
log
@        PR7044
        * dlltool.c (run): Use formatting string to avoid compile time
        warning.
        (gen_exp_file): Check return value from fread.
        * windmc.c (main): Check return value from fread.
@
text
@d374 2
d2725 2
d2728 1
a2728 1
      fprintf (f,"\t%s\t0\n\t%s\t0\n", ASM_LONG, ASM_LONG); /* NULL terminating list.  */
d2730 1
a2730 1
      fprintf (f,"\t%s\t0\n", ASM_LONG); /* NULL terminating list.  */
d2732 1
d2739 8
a2746 2
      fprintf (f, "\t%s\t0\n", ASM_LONG);
      fprintf (f, "\t.section	.idata$4\n");
d3370 1
d3401 2
d3410 2
d3486 3
@


1.85
log
@	* dlltool.c (identify_search_section): Cast argument, not return
	value, of xstrdup to 'char*'.
@
text
@d1216 1
a1216 1
      inform (strerror (errno));
d2001 1
a2001 1
      int numbytes;
d2013 2
a2014 1
      fread (copy, 1, numbytes, base_file);
@


1.84
log
@Added --identify option to dlltool.
@
text
@d3109 1
a3109 1
      identify_dll_name = (char*) xstrdup (data);
@


1.83
log
@binutils/
2008-10-09  Kai Tietz  <kai.tietz@@onevision.com>

	* dlltool.c (PAGE_SIZE): Make sure it has bfd_vma type.
	(PAGE_MASK): Likewise.
	(sfunc): Change to address size of bfd_vma for base-file.
	(flush_page): Likewise.
	(gen_exp_file): Likewise.
bfd/
2008-10-09  Kai Tietz  <kai.tietz@@onevision.com>

	* cofflink.c (_bfd_coff_generic_relocate_section): Dump bfd_vma sized addresses instead of long sized.
@
text
@d355 2
d729 5
d2928 187
d3368 1
d3409 1
d3448 1
a3448 1
			   "m:e:l:aD:d:z:b:xp:cCuUkAS:f:nvVHhM:L:F:",
d3450 1
a3450 1
			   "m:e:l:aD:d:z:b:xp:cCuUkAS:f:nvVHh",
d3516 3
d3642 5
@


1.82
log
@Silence gcc printf warnings
@
text
@d244 2
a245 2
#define PAGE_SIZE 4096
#define PAGE_MASK (-PAGE_SIZE)
d715 1
a715 1
static void flush_page (FILE *, long *, int, int);
d1587 4
a1590 1
  return *(const long *) a - *(const long *) b;
d1594 1
a1594 1
flush_page (FILE *f, long *need, int page_addr, int on_page)
d1601 1
a1601 1
	   page_addr,
d1610 1
a1610 1
      unsigned long needed = need[i];
d1613 9
a1621 1
	needed = ((needed - page_addr) | 0x3000) & 0xffff;
d1623 1
a1623 1
      fprintf (f, "\t%s\t0x%lx\n", ASM_SHORT, needed);
d1991 3
a1993 3
      int addr;
      long need[PAGE_SIZE];
      long page_addr;
d1996 1
a1996 1
      long *copy;
d2007 1
a2007 1
      num_entries = numbytes / sizeof (long);
d2015 2
a2016 2
	  int last = -1;
	  qsort (copy, num_entries, sizeof (long), sfunc);
@


1.82.2.1
log
@        PR 7044
        * dlltool.c (run): Use formatting string to avoid compile time
        warning.
        (gen_exp_file): Check return value from fread.
        * windmc.c (main): Check return value from fread.
@
text
@d1209 1
a1209 1
      inform ("%s", strerror (errno));
d1995 1
a1995 2
      if (fread (copy, 1, numbytes, base_file) < numbytes)
	fatal (_("failed to read the number of entries from base file"));
d1998 1
@


1.82.2.2
log
@        * windmc.c (main): Use correct type for file length.
        * dlltool.c (gen_exp_file): Likewise.
@
text
@d1983 1
a1983 1
      bfd_size_type numbytes;
@


1.81
log
@Add support for thin archives.
    * bfd/archive.c (_bfd_find_nested_archive): New function.
    (get_extended_arelt_filename): Add origin parameter.
    (_bfd_generic_read_ar_hdr_mag): Deal with extended name
    combined with a file offset.
    (append_relative_path): New function.
    (_bfd_get_elt_at_filepos): Deal with external members and
    nested archives.
    (bfd_generic_openr_next_archived_file): Thin archives.
    (bfd_generic_archive_p): Recognize new magic string.
    (adjust_relative_path): New function.
    (_bfd_construct_extended_name_table): Construct extended
    names for thin archive members.
    (_bfd_write_archive_contents): Emit new magic string, skip
    copying files for thin archives.
    * bfd/bfd-in.h (bfd_is_thin_archive): New macro.
    * bfd/bfd.c (struct bfd): New fields for thin archives.
    * bfd/libbfd-in.h (struct areltdata): New field for thin archives.
    * bfd/opncls.c (bfd_close): Delete BFDs for nested archives.
    * binutils/ar.c (make_thin_archive): New global flag.
    (map_over_members): Deal with full pathnames in thin archives.
    (usage, main): Add 'T' option for building thin archives.
    (replace_members): Pass thin archive flag to ar_emul_append.
    * binutils/arsup.c (ar_open): Initialize new flag.
    * binutils/binemul.c (ar_emul_append): Add new parameter for
    flattening nested archives.
    (do_ar_emul_default_append): New function.
    (ar_emul_default_append): Factored out recursive code.
    * binutils/binemul.h (ar_emul_default_append): Add new parameter.
    (struct bin_emulation_xfer_struct): New parameter for ar_append.
    * binutils/dlltool.c (gen_lib_file): Initialize thin archive flag.
    * binutils/emul_aix.c (ar_emul_aix_internal): Add new flatten
    parameter, currently unimplemented.
    All callers changed.
    * binutils/objcopy.c (copy_archive): Preserve thin archive flag.
    * binutils/doc/binutils.texi: Update ar documentation.
    * binutils/testsuite/binutils-all/ar.exp: Add thin archive tests.
    * include/aout/ar.h (ARMAGT): New magic string for thin archives.
@
text
@d1607 1
a1607 1
      long needed = need[i];
d1829 2
a1830 2
      fprintf (f, "\t%s	0x%lx	%s Time and date\n", ASM_LONG, (long) time(0),
	       ASM_C);
@


1.80
log
@* dlltool.c (mcore_elf_cache_filename): Add a const qualifier to
  the argument.
  (scan_obj_filename): Do not drop the const qualifier when calling
  mcore_elf_cache_filename.
  (struct fname_cache): Add const qualifier to filename field.
@
text
@d2816 1
@


1.79
log
@Fix spelling typos.
@
text
@d3 1
a3 1
   2005, 2006, 2007 Free Software Foundation, Inc.
d274 1
a274 1
static void mcore_elf_cache_filename (char *);
d1549 1
a1549 1
	mcore_elf_cache_filename ((char *) filename);
d3561 1
a3561 1
  char *               filename;
d3569 1
a3569 1
mcore_elf_cache_filename (char * filename)
@


1.78
log
@Change sources over to using GPLv3
@
text
@d1894 1
a1894 1
      fprintf (f,"%s Export Oridinal Table\n", ASM_C);
d2991 1
a2991 1
		fatal (_("Error, duplicate EXPORT with oridinals: %s"),
@


1.77
log
@bfd/
	* bfd.c (struct bfd): Rename "next" to "archive_next".
	* archive.c: Rename uses throughout file.
	* archive64.c: Likewise.
	* coff-rs6000.c: Likewise.
	* ecoff.c: Likewise.
	* som.c: Likewise.
	* bfd-in2.h: Regenerate.
binutils/
	* ar.c: Rename uses of bfd.next to bfd.archive_next throughout.
	* arsup.c: Likewise.
	* binemul.c: Likewise.
	* objcopy.c: Likewise.
	* dlltool.c: Likewise.
ld/
	* pe-dll.c: Rename uses of bfd.next to bfd.archive_next throughout.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
@


1.76
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d2831 1
a2831 1
      n->next = head;
d2850 1
a2850 1
	  n->next = head;
d2856 2
a2857 2
  ar_head->next = head;
  ar_tail->next = ar_head;
d2868 1
a2868 1
      bfd *n = head->next;
@


1.75
log
@Use pc-relative relocation instead of an absolute relocation for x86_64-pc-mingw32 target.
@
text
@d246 1
a248 1
#include "bucomm.h"
d252 1
@


1.74
log
@top level:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.ac (TOPLEVEL_CONFIGURE_ARGUMENTS): Fix quoting.
	* configure: Regenerate.

bfd:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-pkgversion): New option.
	* configure: Regenerate.
	* Makefile.am (bfdver.h): Substitute for @@bfd_version_package@@.
	* Makefile.in: Regenerate.
	* version.h (BFD_VERSION_STRING): Define using
	@@bfd_version_package@@.

bfd/doc:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* Makefile.in: Regenerate.

binutils:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-bugurl): New option.
	* configure: Regenerate.
	* Makefile.am (REPORT_BUGS_TO): Define.
	(INCLUDES): Define REPORT_BUGS_TO.
	Regenerate dependencies.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* bucomm.h: Remove include of bin-bugs.h.
	* addr2line.c (usage): Don't print empty REPORT_BUGS_TO.
	* ar.c (usage): Pass s to list_supported_targets.  Don't print
	empty REPORT_BUGS_TO.
	* coffdump.c (show_usage): Don't print empty REPORT_BUGS_TO.
	* cxxfilt.c (usage): Print bug url when giving help.
	* dlltool.c (usage): Likewise.
	* dllwrap.c (usage): Likewise.
	* nlmconv.c (show_usage): Don't print empty REPORT_BUGS_TO.
	* nm.c (usage): Likewise.
	* objcopy.c (copy_usage, strip_usage): Likewise.
	* objdump.c (usage): Likewise.
	* readelf.c ((usage): Likewise. Add STREAM argument.  Adjust
	callers.
	* size.c (usage): Don't print empty REPORT_BUGS_TO.
	* srconv.c (show_usage): Likewise.
	* strings.c (usage): Likewise.
	* sysdymp.c (show_usage): Likewise.
	* windres.c (usage): Likewise.

gas:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-bugurl): New option.
	* configure: Regenerate.
	* dep-in.sed: Remove bin-bugs.h.
	* Makefile.am (REPORT_BUGS_TO): Define.
	(INCLUDES): Define REPORT_BUGS_TO.
	(DEP_INCLUDES): Likewise.
	($(OBJS)): No longer depend on bin-bugs.h.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* as.c (show_usage): Don't print empty REPORT_BUGS_TO.
	* as.h: Remove include of bin-bugs.h.

gprof:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-pkgversion, --with-bugurl): New options.
	* configure: Regenerate.
	* Makefile.am (PKGVERSION, REPORT_BUGS_TO): Define.
	(INCLUDES): Define PKGVERSION and REPORT_BUGS_TO.
	Regenerate dependencies.
	* Makefile.in: Regenerate.
	* gprof.c (usage): Don't print empty REPORT_BUGS_TO.
	(main): Include PKGVERSION in version output.
	* gprof.h: Remove include of bin-bugs.h.

include:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* bin-bugs.h: Remove.

ld:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-bugurl): New option.
	* configure: Regenerate.
	* Makefile.am (REPORT_BUGS_TO): Define.
	(INCLUDES): Define REPORT_BUGS_TO.
	Regenerate dependencies.
	* Makefile.in: Regenerate.
	* ld.h: Remove include of bin-bugs.h.
	* lexsup.c (help): Don't print empty REPORT_BUGS_TO.
@
text
@d2415 6
@


1.73
log
@2076-02-02  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/3945
	* configure.in (DLLTOOL_DEFAULT): New. Defined for the first PE
	target.
	(DLLTOOL_DEFS): Add $DLLTOOL_DEFAULT.
	* configure: Regenerated.

	* dlltool.c (mname): Defined with DLLTOOL_DEFAULT_XXX.
@
text
@d3 1
a3 1
   2005, 2006 Free Software Foundation, Inc.
d3164 2
@


1.72
log
@Add x86_64-mingw64 target
@
text
@d390 5
a394 2
#ifdef DLLTOOL_ARM
#if defined(DLLTOOL_ARM_EPOC)
d396 3
a398 1
#elif defined(DLLTOOL_ARM_WINCE)
a399 3
#else
static const char *mname = "arm";
#endif
d402 1
a402 1
#ifdef DLLTOOL_I386
d406 1
a406 1
#ifdef DLLTOOL_MX86_64
d410 1
a410 1
#ifdef DLLTOOL_PPC
d414 1
a414 1
#ifdef DLLTOOL_SH
d418 1
a418 1
#ifdef DLLTOOL_MIPS
d422 1
a422 1
#ifdef DLLTOOL_MCORE
d426 1
a426 1
#ifdef DLLTOOL_MCORE_ELF
@


1.71
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d264 3
d404 4
d650 8
d781 1
d807 1
d843 1
d1721 5
a1725 1
      for ( funcindex = 0; funcindex < headptr->nfuncs; funcindex++ )
d1728 6
a1733 1
      fprintf (filvar,"\t%s\t0\n", ASM_LONG); /* NULL terminating list */
d1742 5
a1746 1
      for ( funcindex = 0; funcindex < headptr->nfuncs; funcindex++ )
d1749 6
a1754 1
      fprintf (filvar, "\t%s\t0\n", ASM_LONG); /* NULL terminating list */
d2397 1
a2397 1
	      /* add the reloc into idata$5 */
d2427 30
d2481 1
a2481 1

d2695 5
a2699 1
      fprintf (f, "\t%s\t0\n", ASM_LONG);
a2705 1

d2732 5
a2736 1
      fprintf (f, "\t%s\t0\n", ASM_LONG);
d2742 5
a2746 1
      fprintf (f, "\t%s\t0\n", ASM_LONG);
@


1.70
log
@bfd
* Makefile.am: Add rules to build pe-arm-wince.lo and pei-arm-wince.lo objects.
* Makefile.in: Regenerate.
* pe-arm-wince.c: New file.
* pei-arm-wince.c: New file.
* pei-arm.c: Remove ARM_WINCE block.
* pe-arm.c: Remove ARM_WINCE block. Rename
bfd_arm_pe_allocate_interworking_sections,
bfd_arm_pe_get_bfd_for_interworking, and
bfd_arm_pe_process_before_allocation to
bfd_armpe_allocate_interworking_sections,
bfd_armpe_get_bfd_for_interworking, and
bfd_armpe_process_before_allocation. Move them before including bfd.h.
* bfd.c: ARM wince bfd format names were renamed. Adjust.
* coff-arm.c [ARM_WINCE]: Adjust so Windows CE doesn't end up with unexpected/conflicting relocs.
* targets.c: The arm-wince-pe target got its own new vector.  Adjust.
* config.bfd: Likewise.
* configure.in: Likewise.
* configure: Regenerate.

binutils
* configure.in: Split arm-pe and arm-wince-pe. Build dlltool with -DDLLTOOL_ARM_WINCE for Windows CE case.
* configure: Regenerate.
* dlltool.c: Add support for arm-wince.

gas
* Makefile.am (TARG_ENV_HFILES): Add te-wince-pe.h.
* Makefile.in: Regenerate.
* config/tc-arm.h [TARGET_FORMAT]: ARM wince bfd names were  renamed. Adjust.

ld
* Makefile.am: Split arm-wince into its own emulation.
* Makefile.in: Regenerate.
* configure.tgt: Set targ_emul to arm_wince_pe for ARM Windows CE targets.
* pe-dll.c : Define PE_ARCH_arm_wince.
  (pe_detail_list): Add PE_ARCH_arm_wince case.
  (make_one): Handle PE_ARCH_arm_epoc and PE_ARCH_arm_wince cases.
* emulparams/arm_wince_pe.sh: New file.
* emultempl/pe.em: Handle new TARGET_IS_arm_wince_pe define.
  Remap bfd_arm_allocate_interworking_sections, bfd_arm_get_bfd_for_interworking and
  bfd_arm_process_before_allocation for arm-pe and arm-wince-pe targets too.
  (gld_${EMULATION_NAME}_recognized_file): Handle arm-wince and arm-epoc bfd format names.
@
text
@d1251 1
a1251 1
	  && strncmp (p, "-export:", 8) == 0)
d1269 1
a1269 1
	      if (strncmp (tag_start, "data", 4) == 0)
@


1.69
log
@	* dlltool.c: Update copyright year.
	* doc/binutils.texi: Likewise.
@
text
@d388 1
a388 1
#ifdef DLLTOOL_ARM_EPOC
d390 2
d634 9
d774 1
d799 1
d823 1
@


1.68
log
@	* dlltool.c (add_stdcall_underscore): New flag.
	(xlate): Also add underscore to stdcall symbol if
	add_stdcall_underscore set.
	(usage): Document --add-stdcall-underscore option.
	(OPTION_ADD_STDCALL_UNDERSCORE): New define.
	(long_options): Use it for --add-stdcall-underscore option.
	(main): Handle it.
	* doc/binutils.texi: Document --add-stdcall-underscore option
	and differentiate from --add-underscore.
@
text
@d3 1
a3 1
   2005 Free Software Foundation, Inc.
@


1.67
log
@	* addr2line.c (usage): Document @@file.
	* ar.c (usage): Likewise.
	* coffdump (usage): Likewise.
	* cxxfilt.c (usage): Likewise.
	* dlltool.c (usage): Likewise.
	* dllwrap.c (usage): Likewise.
	* nlmconv.c (usage): Likewise.
	* nm.c (usage): Likewise.
	* objcopy.c (usage): Likewise.
	* objdump.c (usage): Likewise.
	* readelf.c (usage): Likewise.
	* size.c (usage): Likeise.
	* srconv.c (usage): Likewise.
	* strings.c (usage): Likewise.
	* windres.c (usage): Likewise.
	* doc/binutils.texi: Add section on common options.
@
text
@d357 1
d1998 3
a2000 1
  if (add_underscore &&  !lead_at)
d3052 2
a3053 1
  fprintf (file, _("   -U --add-underscore       Add underscores to symbols in interface library.\n"));
d3078 1
d3096 1
d3159 3
@


1.66
log
@	* dlltool.c (main): Fix typo.
	* windres.c (main): Likewise.
@
text
@d3061 1
@


1.65
log
@	* addr2line.c (main): Likewise.
	* ar.c (main): Likewise.
	* coffdump.c (main): Likewise.
	* cxxfilt.c (main): Likewise.
	* dlltool.c (main): Likewise.
	* dllwrap.c (main): Likewise.
	* nlmconv.c (main): Likewise.
	* nm.c (main): Likewise.
	* objcopy.c (main): Likewise.
	* objdump.c (main): Likewise.
	* readelf.c (main): Likewise.
	* size.c (main): Likeiwse.
	* srcconv.c (main): Likewise.
	* strings.c (main): Likewise.
	* sysdump.c (main): Likewise.
	* sysinfo.c (main): Likewise.
	* windres.c (main): Likewise.

	* ldmain.c (main): Use expandargv.

	* gprof.c (main): Use expandargv.

	* as.c (main): Use expandargv.
@
text
@d3127 1
a3127 1
  expandargv (&argc, &argv);
@


1.64
log
@(alphafunc): Remove and replace usage with nfunc.
(nfunc): Fix sorting of fastcall symbols when --kill-at is used.
@
text
@d3127 2
@


1.63
log
@	* bucomm.h: Include <stdarg.h> unconditionally, not only when
	ANSI_PROTOTYPES is defined.  Remove #ifdef logic.
	* dlltool.c: Likewise.
	* dllwrap.c: Likewise.
@
text
@a701 1
static int alphafunc (const void *, const void *);
d2830 2
d2833 7
a2839 1
  return (strcmp (ap->name, bp->name));
a2982 9
static int
alphafunc (const void *av, const void *bv)
{
  const export_type **a = (const export_type **) av;
  const export_type **b = (const export_type **) bv;

  return strcmp ((*a)->name, (*b)->name);
}

d3018 1
a3018 1
  qsort (d_exports_lexically, i, sizeof (export_type *), alphafunc);
@


1.62
log
@Kaveh Ghazi's printf format attribute checking patch.
bfd:
	* elf32-xtensa.c (vsprint_msg): Add format attribute.  Fix
	format bugs.
	* vms.h (_bfd_vms_debug): Add format attribute.
	(_bfd_vms_debug, _bfd_hexdump): Fix typos.

binutils:
	* bucomm.h (report): Add format attribute.
	* dlltool.c (inform): Likewise.
	* dllwrap.c (display, inform, warn): Likewise.
	* objdump.c (objdump_sprintf): Likewise.
	* readelf.c (error, warn): Likewise.  Fix format bugs.

gas:
	* config/tc-tic30.c (debug): Add format attribute.  Fix format
	bugs.

include:
	* dis-asm.h (fprintf_ftype): Add format attribute.

opcodes:
	* arc-dis.c, arm-dis.c, cris-dis.c, crx-dis.c, d10v-dis.c,
	d30v-dis.c, fr30-dis.c, h8300-dis.c, h8500-dis.c, i860-dis.c,
	ia64-dis.c, ip2k-dis.c, m10200-dis.c, m10300-dis.c,
	m88k-dis.c, mcore-dis.c, mips-dis.c, ms1-dis.c, or32-dis.c,
	ppc-dis.c, sh64-dis.c, sparc-dis.c, tic4x-dis.c, tic80-dis.c,
	v850-dis.c: Fix format bugs.
	* ia64-gen.c (fail, warn): Add format attribute.
	* or32-opc.c (debug): Likewise.
@
text
@a256 2

#ifdef ANSI_PROTOTYPES
a257 4
#else
#include <varargs.h>
#endif

@


1.61
log
@Update FSF address
@
text
@d711 1
a711 1
static void inform (const char *, ...);
@


1.60
log
@	* dlltool.c (dtab): Remove empty function.
	(process_duplicates): Remove calls to dtab().
@
text
@d19 2
a20 2
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.59
log
@	* dlltool.c: Warning fixes.
	* objdump.c: Likewise.
@
text
@a705 1
static void dtab (export_type **);
a2858 21
dtab (export_type **ptr ATTRIBUTE_UNUSED)
{
#ifdef SACDEBUG
  int i;
  for (i = 0; i < d_nfuncs; i++)
    {
      if (ptr[i])
	{
	  printf ("%d %s @@ %d %s%s%s\n",
		  i, ptr[i]->name, ptr[i]->ordinal,
		  ptr[i]->noname ? "NONAME " : "",
		  ptr[i]->constant ? "CONSTANT" : "",
		  ptr[i]->data ? "DATA" : "");
	}
      else
	printf ("empty\n");
    }
#endif
}

static void
a2869 1
      dtab (d_export_vec);
a2897 1
	  dtab (d_export_vec);
a2898 1
	  dtab (d_export_vec);
@


1.59.6.1
log
@	* ld/ldmain.c (main): Use expandargv.
	* binutils/addr2line.c (main): Likewise.
	* binutils/ar.c (main): Likewise.
	* binutils/coffdump.c (main): Likewise.
	* binutils/cxxfilt.c (main): Likewise.
	* binutils/dlltool.c (main): Likewise.
	* binutils/dllwrap.c (main): Likewise.
	* binutils/nlmconv.c (main): Likewise.
	* binutils/nm.c (main): Likewise.
	* binutils/objcopy.c (main): Likewise.
	* binutils/objdump.c (main): Likewise.
	* binutils/readelf.c (main): Likewise.
	* binutils/size.c (main): Likeiwse.
	* binutils/srcconv.c (main): Likewise.
	* binutils/strings.c (main): Likewise.
	* binutils/sysdump.c (main): Likewise.
	* binutils/sysinfo.c (main): Likewise.
	* binutils/windres.c (main): Likewise.

	* include/libiberty.h (expandargv): New function.
	* libiberty/argv.c (safe-ctype.h): Include it.
	(ISBLANK): Remove.
	(stdio.h): Include.
	(expandargv): New function.
	* libiberty/Makefile.in: Regenerated.
@
text
@a3159 2
  expandargv (&argc, &argv);

@


1.59.6.2
log
@	* binutils/dlltool.c (main): Fix typo.
	* binutils/windres.c (main): Likewise.
@
text
@d3160 1
a3160 1
  expandargv (&ac, &av);
@


1.58
log
@	* dlltool.c (dump_iat): Remove unused function.
	(gen_exp_file): Remove #if 0'd code.
	(make_one_lib_file): Likewise.
	* srconv.c: Remove #if 0'd code throughout.
	* size.c (lprint_number): Remove.
	(print_berkeley_format): Remove #if 0'd code.
	* ar.c (do_quick_append): Remove declaration and definiton.
	(main): Remove #if 0'd code.
	* filemode.c (filemodestring): Remove #if 0'd function.
	* sysdump.c (unit_info_list): Remove function.
	(object_body_list): Likewise.
	(program_structure): Likewise.
	(debug_list): Likewise.
	(module): Remove #if 0'd code.
@
text
@d2 2
a3 2
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
d2420 1
a2420 1
	      strcpy (si->data + 2, xlate (exp->import_name));
@


1.57
log
@	* dlltool.c (set_dll_name_from_def): New function.  Strip name
	to basename, with warning.
	(def_name): Use it.
	(def_library): Likwise.
	(main): Strip arg of --dllname to basename, with warning.
	Only use basename of exp_name when inferring dll_name.
@
text
@a696 3
#if 0
static void dump_iat (FILE *, export_type *);
#endif
a1814 8
#if 0
	      fprintf (f, "\t%s\t%d\t%s %d..%d missing\n",
		       ASM_SPACE,
		       (exp->ordinal - i) * 4,
		       ASM_C,
		       i, exp->ordinal - 1);
	      i = exp->ordinal;
#endif
a2025 23
/**********************************************************************/

#if 0

static void
dump_iat (FILE *f, export_type *exp)
{
  if (exp->noname && !show_allnames )
    {
      fprintf (f, "\t%s\t0x%08x\n",
	       ASM_LONG,
	       exp->ordinal | 0x80000000); /* hint or orindal ?? */
    }
  else
    {
      fprintf (f, "\t%sID%d%s\n", ASM_RVA_BEFORE,
	       exp->ordinal,
	       ASM_RVA_AFTER);
    }
}

#endif

d2176 7
a2182 60
#if 0
    {
      char *name;
      FILE *f;
      const char *prefix = "d";
      char *dest;

      name = (char *) alloca (strlen (prefix) + 10);
      sprintf (name, "%ss%05d.s", prefix, i);
      f = fopen (name, FOPEN_WT);
      fprintf (f, "\t.text\n");
      fprintf (f, "\t%s\t%s%s\n", ASM_GLOBAL, ASM_PREFIX (exp->name), exp->name);
      if (create_compat_implib)
	fprintf (f, "\t%s\t__imp_%s\n", ASM_GLOBAL, exp->name);
      fprintf (f, "\t%s\t_imp__%s\n", ASM_GLOBAL, exp->name);
      if (create_compat_implib)
	fprintf (f, "%s%s:\n\t%s\t__imp_%s\n", ASM_PREFIX (exp->name),
		 exp->name, ASM_JUMP, exp->name);

      fprintf (f, "\t.section\t.idata$7\t%s To force loading of head\n", ASM_C);
      fprintf (f, "\t%s\t%s\n", ASM_LONG, head_label);


      fprintf (f,"%s Import Address Table\n", ASM_C);

      fprintf (f, "\t.section	.idata$5\n");
      if (create_compat_implib)
	fprintf (f, "__imp_%s:\n", exp->name);
      fprintf (f, "_imp__%s:\n", exp->name);

      dump_iat (f, exp);

      fprintf (f, "\n%s Import Lookup Table\n", ASM_C);
      fprintf (f, "\t.section	.idata$4\n");

      dump_iat (f, exp);

      if(!exp->noname || show_allnames)
	{
	  fprintf (f, "%s Hint/Name table\n", ASM_C);
	  fprintf (f, "\t.section	.idata$6\n");
	  fprintf (f, "ID%d:\t%s\t%d\n", exp->ordinal, ASM_SHORT, exp->hint);
	  fprintf (f, "\t%s\t\"%s\"\n", ASM_TEXT, xlate (exp->name));
	}

      fclose (f);

      dest = (char *) alloca (strlen (prefix) + 10);
      sprintf (dest, "%ss%05d.o", prefix, i);
      assemble_file (name, dest);
    }
#else /* if 0 */
    {
      bfd *      abfd;
      asymbol *  exp_label;
      asymbol *  iname = 0;
      asymbol *  iname2;
      asymbol *  iname_lab;
      asymbol ** iname_lab_pp;
      asymbol ** iname_pp;
d2184 2
a2185 2
      asymbol ** fn_pp;
      asymbol ** toc_pp;
d2191 4
a2194 4
      asymbol *  ptrs[NSECS + 4 + EXTRA + 1];
      flagword   applicable;
      char *     outname = xmalloc (strlen (TMP_STUB) + 10);
      int        oidx = 0;
d2197 1
a2197 1
      sprintf (outname, "%s%05d.o", TMP_STUB, i);
d2199 1
a2199 1
      abfd = bfd_openw (outname, HOW_BFD_WRITE_TARGET);
d2201 3
a2203 3
      if (!abfd)
	/* xgettext:c-format */
	fatal (_("bfd_open failed open stub file: %s"), outname);
d2205 2
a2206 2
      /* xgettext:c-format */
      inform (_("Creating stub file: %s"), outname);
d2208 2
a2209 2
      bfd_set_format (abfd, bfd_object);
      bfd_set_arch_mach (abfd, HOW_BFD_ARCH, 0);
d2212 2
a2213 2
      if (machine == MARM_INTERWORK || machine == MTHUMB)
	bfd_set_private_flags (abfd, F_INTERWORK);
d2216 1
a2216 1
      applicable = bfd_applicable_section_flags (abfd);
d2218 4
a2221 4
      /* First make symbols for the sections.  */
      for (i = 0; i < NSECS; i++)
	{
	  sinfo *si = secdata + i;
d2223 6
a2228 6
	  if (si->id != i)
	    abort();
	  si->sec = bfd_make_section_old_way (abfd, si->name);
	  bfd_set_section_flags (abfd,
				 si->sec,
				 si->flags & applicable);
d2230 11
a2240 11
	  bfd_set_section_alignment(abfd, si->sec, si->align);
	  si->sec->output_section = si->sec;
	  si->sym = bfd_make_empty_symbol(abfd);
	  si->sym->name = si->sec->name;
	  si->sym->section = si->sec;
	  si->sym->flags = BSF_LOCAL;
	  si->sym->value = 0;
	  ptrs[oidx] = si->sym;
	  si->sympp = ptrs + oidx;
	  si->size = 0;
	  si->data = NULL;
d2242 2
a2243 2
	  oidx++;
	}
d2245 4
a2248 4
      if (! exp->data)
	{
	  exp_label = bfd_make_empty_symbol (abfd);
	  exp_label->name = make_imp_label ("", exp->name);
d2250 4
a2253 4
	  /* On PowerPC, the function name points to a descriptor in
	     the rdata section, the first element of which is a
	     pointer to the code (..function_name), and the second
	     points to the .toc.  */
d2255 3
a2257 3
	  if (machine == MPPC)
	    exp_label->section = secdata[RDATA].sec;
	  else
d2259 1
a2259 1
	    exp_label->section = secdata[TEXT].sec;
d2261 2
a2262 2
	  exp_label->flags = BSF_GLOBAL;
	  exp_label->value = 0;
d2265 2
a2266 2
	  if (machine == MTHUMB)
	    bfd_coff_set_symbol_class (abfd, exp_label, C_THUMBEXTFUNC);
d2268 2
a2269 2
	  ptrs[oidx++] = exp_label;
	}
d2271 11
a2281 11
      /* Generate imp symbols with one underscore for Microsoft
         compatibility, and with two underscores for backward
         compatibility with old versions of cygwin.  */
      if (create_compat_implib)
	{
	  iname = bfd_make_empty_symbol (abfd);
	  iname->name = make_imp_label ("___imp", exp->name);
	  iname->section = secdata[IDATA5].sec;
	  iname->flags = BSF_GLOBAL;
	  iname->value = 0;
	}
d2283 5
a2287 5
      iname2 = bfd_make_empty_symbol (abfd);
      iname2->name = make_imp_label ("__imp_", exp->name);
      iname2->section = secdata[IDATA5].sec;
      iname2->flags = BSF_GLOBAL;
      iname2->value = 0;
d2289 1
a2289 1
      iname_lab = bfd_make_empty_symbol (abfd);
d2291 4
a2294 4
      iname_lab->name = head_label;
      iname_lab->section = (asection *) &bfd_und_section;
      iname_lab->flags = 0;
      iname_lab->value = 0;
d2296 4
a2299 4
      iname_pp = ptrs + oidx;
      if (create_compat_implib)
	ptrs[oidx++] = iname;
      ptrs[oidx++] = iname2;
d2301 2
a2302 2
      iname_lab_pp = ptrs + oidx;
      ptrs[oidx++] = iname_lab;
d2305 3
a2307 3
      /* The symbol referring to the code (.text).  */
      {
	asymbol *function_name;
d2309 5
a2313 5
	function_name = bfd_make_empty_symbol(abfd);
	function_name->name = make_label ("..", exp->name);
	function_name->section = secdata[TEXT].sec;
	function_name->flags = BSF_GLOBAL;
	function_name->value = 0;
d2315 3
a2317 3
	fn_pp = ptrs + oidx;
	ptrs[oidx++] = function_name;
      }
d2319 3
a2321 3
      /* The .toc symbol.  */
      {
	asymbol *toc_symbol;
d2323 5
a2327 5
	toc_symbol = bfd_make_empty_symbol (abfd);
	toc_symbol->name = make_label (".", "toc");
	toc_symbol->section = (asection *)&bfd_und_section;
	toc_symbol->flags = BSF_GLOBAL;
	toc_symbol->value = 0;
d2329 3
a2331 3
	toc_pp = ptrs + oidx;
	ptrs[oidx++] = toc_symbol;
      }
d2334 1
a2334 1
      ptrs[oidx] = 0;
d2336 8
a2343 1
      for (i = 0; i < NSECS; i++)
d2345 2
a2346 6
	  sinfo *si = secdata + i;
	  asection *sec = si->sec;
	  arelent *rel;
	  arelent **rpp;

	  switch (i)
d2348 3
a2350 6
	    case TEXT:
	      if (! exp->data)
		{
		  si->size = HOW_JTAB_SIZE;
		  si->data = xmalloc (HOW_JTAB_SIZE);
		  memcpy (si->data, HOW_JTAB, HOW_JTAB_SIZE);
d2352 2
a2353 2
		  /* add the reloc into idata$5 */
		  rel = xmalloc (sizeof (arelent));
d2355 3
a2357 3
		  rpp = xmalloc (sizeof (arelent *) * 2);
		  rpp[0] = rel;
		  rpp[1] = 0;
d2359 2
a2360 2
		  rel->address = HOW_JTAB_ROFF;
		  rel->addend = 0;
d2362 1
a2362 24
		  if (machine == MPPC)
		    {
		      rel->howto = bfd_reloc_type_lookup (abfd,
							  BFD_RELOC_16_GOTOFF);
		      rel->sym_ptr_ptr = iname_pp;
		    }
		  else
		    {
		      rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);
		      rel->sym_ptr_ptr = secdata[IDATA5].sympp;
		    }
		  sec->orelocation = rpp;
		  sec->reloc_count = 1;
		}
	      break;
	    case IDATA4:
	    case IDATA5:
	      /* An idata$4 or idata$5 is one word long, and has an
		 rva to idata$6.  */

	      si->data = xmalloc (4);
	      si->size = 4;

	      if (exp->noname)
d2364 3
a2366 4
		  si->data[0] = exp->ordinal ;
		  si->data[1] = exp->ordinal >> 8;
		  si->data[2] = exp->ordinal >> 16;
		  si->data[3] = 0x80;
d2370 2
a2371 11
		  sec->reloc_count = 1;
		  memset (si->data, 0, si->size);
		  rel = xmalloc (sizeof (arelent));
		  rpp = xmalloc (sizeof (arelent *) * 2);
		  rpp[0] = rel;
		  rpp[1] = 0;
		  rel->address = 0;
		  rel->addend = 0;
		  rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_RVA);
		  rel->sym_ptr_ptr = secdata[IDATA6].sympp;
		  sec->orelocation = rpp;
d2373 8
d2382 2
a2383 1
	      break;
d2385 10
a2394 17
	    case IDATA6:
	      if (!exp->noname)
		{
		  /* This used to add 1 to exp->hint.  I don't know
                     why it did that, and it does not match what I see
                     in programs compiled with the MS tools.  */
		  int idx = exp->hint;
		  si->size = strlen (xlate (exp->import_name)) + 3;
		  si->data = xmalloc (si->size);
		  si->data[0] = idx & 0xff;
		  si->data[1] = idx >> 8;
		  strcpy (si->data + 2, xlate (exp->import_name));
		}
	      break;
	    case IDATA7:
	      si->size = 4;
	      si->data = xmalloc (4);
d2399 1
d2403 1
a2403 1
	      rel->sym_ptr_ptr = iname_lab_pp;
d2405 1
a2405 2
	      sec->reloc_count = 1;
	      break;
d2407 1
a2407 85
#ifdef DLLTOOL_PPC
	    case PDATA:
	      {
		/* The .pdata section is 5 words long.
		   Think of it as:
		   struct
		   {
		     bfd_vma BeginAddress,     [0x00]
		             EndAddress,       [0x04]
			     ExceptionHandler, [0x08]
			     HandlerData,      [0x0c]
			     PrologEndAddress; [0x10]
		   };  */

		/* So this pdata section setups up this as a glue linkage to
		   a dll routine. There are a number of house keeping things
		   we need to do:

		   1. In the name of glue trickery, the ADDR32 relocs for 0,
		      4, and 0x10 are set to point to the same place:
		      "..function_name".
		   2. There is one more reloc needed in the pdata section.
		      The actual glue instruction to restore the toc on
		      return is saved as the offset in an IMGLUE reloc.
		      So we need a total of four relocs for this section.

		   3. Lastly, the HandlerData field is set to 0x03, to indicate
		      that this is a glue routine.  */
		arelent *imglue, *ba_rel, *ea_rel, *pea_rel;

		/* Alignment must be set to 2**2 or you get extra stuff.  */
		bfd_set_section_alignment(abfd, sec, 2);

		si->size = 4 * 5;
		si->data = xmalloc (si->size);
		memset (si->data, 0, si->size);
		rpp = xmalloc (sizeof (arelent *) * 5);
		rpp[0] = imglue  = xmalloc (sizeof (arelent));
		rpp[1] = ba_rel  = xmalloc (sizeof (arelent));
		rpp[2] = ea_rel  = xmalloc (sizeof (arelent));
		rpp[3] = pea_rel = xmalloc (sizeof (arelent));
		rpp[4] = 0;

		/* Stick the toc reload instruction in the glue reloc.  */
		bfd_put_32(abfd, ppc_glue_insn, (char *) &imglue->address);

		imglue->addend = 0;
		imglue->howto = bfd_reloc_type_lookup (abfd,
						       BFD_RELOC_32_GOTOFF);
		imglue->sym_ptr_ptr = fn_pp;

		ba_rel->address = 0;
		ba_rel->addend = 0;
		ba_rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);
		ba_rel->sym_ptr_ptr = fn_pp;

		bfd_put_32 (abfd, 0x18, si->data + 0x04);
		ea_rel->address = 4;
		ea_rel->addend = 0;
		ea_rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);
		ea_rel->sym_ptr_ptr = fn_pp;

		/* Mark it as glue.  */
		bfd_put_32 (abfd, 0x03, si->data + 0x0c);

		/* Mark the prolog end address.  */
		bfd_put_32 (abfd, 0x0D, si->data + 0x10);
		pea_rel->address = 0x10;
		pea_rel->addend = 0;
		pea_rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);
		pea_rel->sym_ptr_ptr = fn_pp;

		sec->orelocation = rpp;
		sec->reloc_count = 4;
		break;
	      }
	    case RDATA:
	      /* Each external function in a PowerPC PE file has a two word
		 descriptor consisting of:
		 1. The address of the code.
		 2. The address of the appropriate .toc
	         We use relocs to build this.  */
	      si->size = 8;
	      si->data = xmalloc (8);
	      memset (si->data, 0, si->size);
d2409 28
a2436 4
	      rpp = xmalloc (sizeof (arelent *) * 3);
	      rpp[0] = rel = xmalloc (sizeof (arelent));
	      rpp[1] = xmalloc (sizeof (arelent));
	      rpp[2] = 0;
d2438 102
a2539 4
	      rel->address = 0;
	      rel->addend = 0;
	      rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);
	      rel->sym_ptr_ptr = fn_pp;
d2541 3
a2543 10
	      rel = rpp[1];

	      rel->address = 4;
	      rel->addend = 0;
	      rel->howto = bfd_reloc_type_lookup (abfd, BFD_RELOC_32);
	      rel->sym_ptr_ptr = toc_pp;

	      sec->orelocation = rpp;
	      sec->reloc_count = 2;
	      break;
a2544 1
	    }
d2546 1
d2548 4
d2553 1
a2553 8
	bfd_vma vma = 0;
	/* Size up all the sections.  */
	for (i = 0; i < NSECS; i++)
	  {
	    sinfo *si = secdata + i;

	    bfd_set_section_size (abfd, si->sec, si->size);
	    bfd_set_section_vma (abfd, si->sec, vma);
d2555 2
a2556 2
/*	    vma += si->size;*/
	  }
d2558 5
a2562 4
      /* Write them out.  */
      for (i = 0; i < NSECS; i++)
	{
	  sinfo *si = secdata + i;
d2564 2
a2565 2
	  if (i == IDATA5 && no_idata5)
	    continue;
d2567 2
a2568 2
	  if (i == IDATA4 && no_idata4)
	    continue;
d2570 4
a2573 4
	  bfd_set_section_contents (abfd, si->sec,
				    si->data, 0,
				    si->size);
	}
d2575 4
a2578 6
      bfd_set_symtab (abfd, ptrs, oidx);
      bfd_close (abfd);
      abfd = bfd_openr (outname, HOW_BFD_READ_TARGET);
      return abfd;
    }
#endif
@


1.56
log
@	* dlltool.c: Comment fix.
@
text
@d716 1
a880 1
static const char *d_name;	/* Arg to NAME or LIBRARY.  */
d928 10
a946 1
  d_name = name;
d950 1
a950 1
    dll_name = xstrdup (name);
a962 1
  d_name = name;
d965 1
a965 1
    dll_name = xstrdup (name);
d3300 4
a3303 1
	  dll_name = optarg;
d3385 5
a3389 1
      int len = strlen (exp_name) + 5;
d3391 1
a3391 1
      strcpy (dll_name, exp_name);
@


1.55
log
@* dlltool.c: Include <assert.h>.
(PREFIX_ALIAS_BASE): Define.
(struct export): Add member import_name;
(def_exports): Set import_name.
(make_one_lib_file): Remove prefix alias code, use import_name in .idata$6.
(gen_lib_file): Create and delete aliases.

* binutils-all/alias.def: New file.
* binutils-all/dlltool.exp: Two new -p tests.
* config/default.exp (dlltool_gas_flag): New variable.
Copy gas and lds executables into tmpdir/gas directory rather than making
symlinks which might not be supported by the host OS.
Attempt to handle the case where the host OS does not use the .exe extension
but the target OS does.
* lib/utils-lib.exp (exe_ext): New procedure.
@
text
@d60 1
a60 1
   Declares that <external-name> or the exported function whoes ordinal number
@


1.54
log
@dlltool.c (make_one_lib_file): Revert 2004-09-02 and 2004-09-04 patches.
doc/binutils.texi (dlltool): Revert 2004-09-06 patch.
@
text
@d264 2
d433 5
a437 1
#define PATHMAX 250		/* What's the right name for this ?  */
d651 1
d911 1
a2258 1
      asymbol *  iname2_pre = 0;
a2347 17

	  if (ext_prefix_alias)
	    {
	      asymbol *  exp_label_pre;

	      exp_label_pre = bfd_make_empty_symbol (abfd);
	      exp_label_pre->name
		= make_imp_label (ext_prefix_alias, exp->name);
	      exp_label_pre->section = exp_label->section;
	      exp_label_pre->flags = exp_label->flags;
	      exp_label_pre->value = exp_label->value;
#ifdef DLLTOOL_ARM
	      if (machine == MTHUMB)
		bfd_coff_set_symbol_class (abfd, exp_label, C_THUMBEXTFUNC);
#endif
	      ptrs[oidx++] = exp_label_pre;
	    }
a2367 13
      if (ext_prefix_alias)
	{
	  char *pre_name;

	  iname2_pre = bfd_make_empty_symbol (abfd);
	  pre_name = xmalloc (strlen (ext_prefix_alias) + 7);
	  sprintf(pre_name, "__imp_%s", ext_prefix_alias);
	  iname2_pre->name = make_imp_label (pre_name, exp->name);
	  iname2_pre->section = iname2->section;
	  iname2_pre->flags = iname2->flags;
	  iname2_pre->value = iname2->value;
	}

a2378 2
      if (ext_prefix_alias)
	ptrs[oidx++] = iname2_pre;
d2495 1
a2495 1
		  si->size = strlen (xlate (exp->name)) + 3;
d2499 1
a2499 1
		  strcpy (si->data + 2, xlate (exp->name));
d2821 20
d2884 7
@


1.53
log
@	* dlltool.c (make_one_lib): Test if internal_name was specified
	by user before using it.
@
text
@d2520 1
a2520 7
		  /* If the user has specified an internal name, use it.
		     Ignore command line name translation options.  */	 
		  char const * internal_name
		    = exp->internal_name != exp->name
		      ? exp->internal_name : xlate (exp->name);

		  si->size = strlen (internal_name) + 3;
d2524 1
a2524 1
		  strcpy (si->data + 2, internal_name);
@


1.52
log
@(make_one_lib_file): For IDATA6 take the name from exp->internal_name if it
is present.
@
text
@d2520 5
a2524 2
		  char const * internal_name =
		    exp->internal_name ? exp->internal_name : xlate (exp->name);
@


1.51
log
@dlltool.c (ext_prefix_alias): New global variable.
 (make_one_lib_file): Add aliases with prefixes for external and import
 definitions.
 (usage): Document -p option.
 (long_options): Add --ext-prefix-alias option.
 (main): Handle -p.
* doc/binutils.texi: Document new switch.
* NEWS: Mention new switch.
@
text
@d2520 4
a2523 1
		  si->size = strlen (xlate (exp->name)) + 3;
d2527 1
a2527 1
		  strcpy (si->data + 2, xlate (exp->name));
d2532 1
a2532 1
	      si->data =xmalloc (4);
@


1.50
log
@ (asm_prefix): Add parameter: name. No underscore for symbols beginning with ?.
(ASM_PREFIX): Add parameter: NAME.
(gen_exp_file): Use new parameter.
(make_label): Likewise.
(make_imp_label): Likewise.
(make_one_lib_file): Likewise.
@
text
@d385 1
d2251 1
a2264 1

d2294 1
d2341 17
d2378 14
a2391 1
      iname_lab = bfd_make_empty_symbol(abfd);
d2394 1
a2394 1
      iname_lab->section = (asection *)&bfd_und_section;
d2402 2
d3166 1
d3206 1
d3243 1
a3243 1
			   "m:e:l:aD:d:z:b:xcCuUkAS:f:nvVHhM:L:F:",
d3245 1
a3245 1
			   "m:e:l:aD:d:z:b:xcCuUkAS:f:nvVHh",
d3320 3
@


1.49
log
@	* objcopy.c (copy_section): Use bfd_get_section_size instead of
	_raw_size or bfd_get_section_size_before_reloc.  Don't set reloc_done.
	(compare_section_lma): Likewise.
	* addr2line.c (find_address_in_section): Likewise.
	* coffgrok.c (do_sections_p1): Likewise.
	* dlltool.c (scan_drectve_symbols): Likewise.
	* nlmconv.c (main): Likewise.
	(copy_sections): Likewise.
	(powerpc_mangle_relocs): Likewise.
	* objdump.c (disassemble_section): Likewise.
	* prdbg.c (find_address_in_section): Likewise.
	* size.c (berkeley_sum): Likewise.
	* srconv.c (wr_ob): Likewise.
	* strings.c (strings_a_section): Likewise.
@
text
@d667 1
a667 1
static const char *asm_prefix (int);
d798 1
a798 1
asm_prefix (int machine)
d813 5
a817 1
      return "_";
d826 20
a845 20
#define ASM_BYTE	mtable[machine].how_byte
#define ASM_SHORT	mtable[machine].how_short
#define ASM_LONG	mtable[machine].how_long
#define ASM_TEXT	mtable[machine].how_asciz
#define ASM_C		mtable[machine].how_comment
#define ASM_JUMP	mtable[machine].how_jump
#define ASM_GLOBAL	mtable[machine].how_global
#define ASM_SPACE	mtable[machine].how_space
#define ASM_ALIGN_SHORT mtable[machine].how_align_short
#define ASM_RVA_BEFORE	rvabefore(machine)
#define ASM_RVA_AFTER	rvaafter(machine)
#define ASM_PREFIX	asm_prefix(machine)
#define ASM_ALIGN_LONG  mtable[machine].how_align_long
#define HOW_BFD_READ_TARGET  0  /* always default*/
#define HOW_BFD_WRITE_TARGET mtable[machine].how_bfd_target
#define HOW_BFD_ARCH    mtable[machine].how_bfd_arch
#define HOW_JTAB        mtable[machine].how_jtab
#define HOW_JTAB_SIZE   mtable[machine].how_jtab_size
#define HOW_JTAB_ROFF   mtable[machine].how_jtab_roff
#define ASM_SWITCHES    mtable[machine].how_default_as_switches
d1823 1
a1823 1
			 ASM_PREFIX,
d2157 2
a2158 2
  int len = strlen (ASM_PREFIX) + strlen (prefix) + strlen (name);
  char *copy = xmalloc (len +1 );
d2160 1
a2160 1
  strcpy (copy, ASM_PREFIX);
d2181 1
a2181 1
      len = strlen (ASM_PREFIX) + strlen (prefix) + strlen (name);
d2184 1
a2184 1
      strcat (copy, ASM_PREFIX);
d2204 1
a2204 1
      fprintf (f, "\t%s\t%s%s\n", ASM_GLOBAL, ASM_PREFIX, exp->name);
d2209 1
a2209 1
	fprintf (f, "%s%s:\n\t%s\t__imp_%s\n", ASM_PREFIX,
@


1.48
log
@Honour the PRIVATE keyword
@
text
@d1209 1
a1209 1
  size = bfd_get_section_size_before_reloc (s);
@


1.47
log
@* dlltool.c (gen_exp_file): Always output names for forwarded symbols.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d52 1
a52 1
            [ @@ <integer> ] [ NONAME ] [CONSTANT] [DATA] ) *
d646 2
a647 1
    int noname;
d893 1
a893 1
	     int noname, int constant, int data)
d902 1
d1251 1
a1251 1
	  def_exports (c, 0, -1, 0, 0, ! (flags & BSF_FUNCTION));
d1260 1
a1260 1
	      def_exports (exported_name, xstrdup (c), -1, 0, 0, 0);
d1299 1
a1299 1
		   ! (sym->flags & BSF_FUNCTION));
d1308 1
a1308 1
	  def_exports (exported_name, xstrdup (symbol_name), -1, 0, 0, 0);
d1523 1
a1523 1
      fprintf (f, "%s  %d = %s %s @@ %d %s%s%s\n",
d1530 1
d1601 1
a1601 2

	  fprintf (output_def, "\t%s%s%s @@ %d%s%s\n",
d1607 1
d1612 1
a1612 1
	  char *quote1 = strchr (exp->internal_name, '.') ? "\"" : "";
d1614 1
a1614 1
	  fprintf (output_def, "\t%s%s%s = %s%s%s @@ %d%s%s\n",
d1623 1
d2801 5
a2805 1
      bfd *n = make_one_lib_file (exp, i);
d2842 1
a2842 1
      for (i = 0, exp = d_exports; exp; i++, exp = exp->next)
d2844 3
a2856 2
/**********************************************************************/

d2859 1
d2903 1
a2903 5
dtab (export_type **ptr
#ifndef SACDEBUG
ATTRIBUTE_UNUSED
#endif
      )
a2930 1

a2940 1

a2969 1

d2972 2
a2973 4
    {
      if (!d_export_vec[i]->noname)
	d_named_nfuncs++;
    }
d3012 1
a3012 1
	  register int j;
d3067 1
a3067 2
  export_type **d_export_vec
  = (export_type **) xmalloc (sizeof (export_type *) * d_nfuncs);
a3103 2
/**********************************************************************/

d3240 1
a3240 1
	  /* ignored for compatibility */
@


1.46
log
@	* doc/binutils.texi (dlltool): Document dlltool --temp-prefix
	option.
	* dlltool.c (usage): Likewise.
@
text
@d1844 2
a1845 2
	if (!exp->noname || show_allnames)
	  {
d1848 4
a1851 4
	    if (exp->forward != 0)
	      fprintf (f, "f%d:	%s	\"%s\"\n",
		       exp->forward, ASM_TEXT, exp->internal_name);
	  }
@


1.46.6.1
log
@Merge to 2.15 branch.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2004
d52 1
a52 1
            [ @@ <integer> ] [ NONAME ] [CONSTANT] [DATA] [PRIVATE] ) *
d646 1
a646 2
    int noname;		/* Don't put name in image file.  */
    int private;	/* Don't put reference in import lib.  */
d892 1
a892 1
	     int noname, int constant, int data, int private)
a900 1
  p->private = private;
d1249 1
a1249 1
	  def_exports (c, 0, -1, 0, 0, ! (flags & BSF_FUNCTION), 0);
d1258 1
a1258 1
	      def_exports (exported_name, xstrdup (c), -1, 0, 0, 0, 0);
d1297 1
a1297 1
		   ! (sym->flags & BSF_FUNCTION), 0);
d1306 1
a1306 1
	  def_exports (exported_name, xstrdup (symbol_name), -1, 0, 0, 0, 0);
d1521 1
a1521 1
      fprintf (f, "%s  %d = %s %s @@ %d %s%s%s%s\n",
a1527 1
	       exp->private ? "PRIVATE " : "",
d1598 2
a1599 1
	  fprintf (output_def, "\t%s%s%s @@ %d%s%s%s\n",
a1604 1
		   exp->private ? "PRIVATE " : "",
d1609 1
a1609 1
	  char * quote1 = strchr (exp->internal_name, '.') ? "\"" : "";
d1611 1
a1611 1
	  fprintf (output_def, "\t%s%s%s = %s%s%s @@ %d%s%s%s\n",
a1619 1
		   exp->private ? "PRIVATE " : "",
d1844 2
a1845 2
	{
	  if (!exp->noname || show_allnames)
d1848 4
a1851 4
	  if (exp->forward != 0)
	    fprintf (f, "f%d:	%s	\"%s\"\n",
		     exp->forward, ASM_TEXT, exp->internal_name);
	}
d2797 1
a2797 5
      bfd *n;
      /* Don't add PRIVATE entries to import lib.  */
      if (exp->private)
	continue;
      n = make_one_lib_file (exp, i);
d2834 1
a2834 1
      for (i = 0; (exp = d_exports_lexically[i]); i++)
a2835 3
	  /* Don't delete non-existent stubs for PRIVATE entries.  */
          if (exp->private)
	    continue;
d2846 2
a2849 1

d2893 5
a2897 1
dtab (export_type **ptr ATTRIBUTE_UNUSED)
d2925 1
d2936 1
d2966 1
d2969 4
a2972 2
    if (!d_export_vec[i]->noname)
      d_named_nfuncs++;
d3011 1
a3011 1
	  int j;
d3066 2
a3067 1
  export_type **d_export_vec = xmalloc (sizeof (export_type *) * d_nfuncs);
d3104 2
d3242 1
a3242 1
	  /* Ignored for compatibility.  */
@


1.45
log
@	* ChangeLog: Fix typos.
	* ChangeLog-9197: Likewise.
	* ChangeLog-9899: Likewise.
	* NEWS: Likewise.
	* ar.c: Fix comment typos.
	* arsup.c: Likewise.
	* coffgrok.c: Likewise.
	* debug.c: Likewise.
	* debug.h: Likewise.
	* dlltool.c: Likewise.
	* ieee.c: Likewise.
	* nm.c: Likewise.
	* objdump.c: Likewise.
	* prdbg.c: Likewise.
	* readelf.c: Likewise.
	* resrc.c: Likewise.
	* sysinfo.y: Likewise.
	* windres.c: Likewise.
@
text
@d3134 1
@


1.44
log
@Fix C90 conversion
@
text
@d63 1
a63 1
   function will be refered to in the body of the DLL.
d446 1
a446 1
/* This bit of assemly does jmp * ....  */
d1946 1
a1946 1
	  /* Delete duplcates */
d2367 1
a2367 1
      /* The symbol refering to the code (.text).  */
d3163 1
a3163 1
  {"def", required_argument, NULL, 'd'}, /* for compatiblity with older versions */
@


1.43
log
@	* addr2line.c: Convert to ISO C90 prototypes, change PTR, remove
	unneeded (void *) casts.
	* ar.c: Likewise.
	* arlex.l: Likewise.
	* arparse.y: Likewise.
	* arsup.c: Likewise.
	* binemul.c: Likewise.
	* binemul.h: Likewise.
	* bucomm.c: Likewise.
	* bucomm.h: Likewise.
	* budbg.h: Likewise.
	* budemang.c: Likewise.
	* budemang.h: Likewise.
	* coffdump.c: Likewise.
	* coffgrok.c: Likewise.
	* cxxfilt.c: Likewise.
	* debug.c: Likewise.
	* debug.h: Likewise.
	* deflex.l: Likewise.
	* dlltool.c: Likewise.
	* dlltool.h: Likewise.
	* dllwrap.c: Likewise.
	* emul_aix.c: Likewise.
	* filemode.c: Likewise.
	* ieee.c: Likewise.
	* nlmconv.c: Likewise.
	* nlmconv.h: Likewise.
	* nlmheader.y: Likewise.
	* nm.c: Likewise.
	* prdbg.c: Likewise.
	* rclex.l: Likewise.
	* rcparse.y: Likewise.
	* rdcoff.c: Likewise.
	* rddbg.c: Likewise.
	* rename.c: Likewise.
	* resbin.c: Likewise.
	* rescoff.c: Likewise.
	* resrc.c: Likewise.
	* size.c: Likewise.
	* srconv.c: Likewise.
	* stabs.c: Likewise.
	* strings.c: Likewise.
	* sysdump.c: Likewise.
	* sysinfo.y: Likewise.
	* syslex.l: Likewise.
	* unwind-ia64.c: Likewise.
	* unwind-ia64.h: Likewise.
	* version.c: Likewise.
	* windres.c: Likewise.
	* windres.h: Likewise.
	* winduni.c: Likewise.
	* wrstabs.c: Likewise.
@
text
@d709 1
a709 1
prefix_encode (char *start, unsigned code))
d714 1
a714 1
  strcpy (buf, start;
d724 1
a724 1
dlltmp (char **buf, const char *fmt))
d728 1
a728 1
      *buf = malloc (strlen (tmp_prefix) + 64;
d2893 1
a2893 1
dtab (export **ptr
@


1.42
log
@* dlltool.c (prefix_encode): Use a fixed length for alpha.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d270 2
a271 4
static char *look_for_prog
  PARAMS ((const char *, const char *, int));
static char *deduce_name
  PARAMS ((const char *));
d274 2
a275 4
static void mcore_elf_cache_filename
  PARAMS ((char *));
static void mcore_elf_gen_out_file
  PARAMS ((void));
d664 24
a687 48
static const char *rvaafter
  PARAMS ((int));
static const char *rvabefore
  PARAMS ((int));
static const char *asm_prefix
  PARAMS ((int));
static void process_def_file
  PARAMS ((const char *));
static void new_directive
  PARAMS ((char *));
static void append_import
  PARAMS ((const char *, const char *, int));
static void run
  PARAMS ((const char *, char *));
static void scan_drectve_symbols
  PARAMS ((bfd *));
static void scan_filtered_symbols
  PARAMS ((bfd *, PTR, long, unsigned int));
static void add_excludes
  PARAMS ((const char *));
static bfd_boolean match_exclude
  PARAMS ((const char *));
static void set_default_excludes
  PARAMS ((void));
static long filter_symbols
  PARAMS ((bfd *, PTR, long, unsigned int));
static void scan_all_symbols
  PARAMS ((bfd *));
static void scan_open_obj_file
  PARAMS ((bfd *));
static void scan_obj_file
  PARAMS ((const char *));
static void dump_def_info
  PARAMS ((FILE *));
static int sfunc
  PARAMS ((const void *, const void *));
static void flush_page
  PARAMS ((FILE *, long *, int, int));
static void gen_def_file
  PARAMS ((void));
static void generate_idata_ofile
  PARAMS ((FILE *));
static void assemble_file
  PARAMS ((const char *, const char *));
static void gen_exp_file
  PARAMS ((void));
static const char *xlate
  PARAMS ((const char *));
d689 1
a689 2
static void dump_iat
  PARAMS ((FILE *, export_type *));
d691 16
a706 32
static char *make_label
  PARAMS ((const char *, const char *));
static char *make_imp_label
  PARAMS ((const char *, const char *));
static bfd *make_one_lib_file
  PARAMS ((export_type *, int));
static bfd *make_head
  PARAMS ((void));
static bfd *make_tail
  PARAMS ((void));
static void gen_lib_file
  PARAMS ((void));
static int pfunc
  PARAMS ((const void *, const void *));
static int nfunc
  PARAMS ((const void *, const void *));
static void remove_null_names
  PARAMS ((export_type **));
static void dtab
  PARAMS ((export_type **));
static void process_duplicates
  PARAMS ((export_type **));
static void fill_ordinals
  PARAMS ((export_type **));
static int alphafunc
  PARAMS ((const void *, const void *));
static void mangle_defs
  PARAMS ((void));
static void usage
  PARAMS ((FILE *, int));
static void inform
  PARAMS ((const char *, ...));
d709 1
a709 1
prefix_encode PARAMS ((char *start, unsigned code))
d714 1
a714 1
  strcpy (buf, start);
d724 1
a724 1
dlltmp PARAMS ((char **buf, const char *fmt))
d728 1
a728 1
      *buf = malloc (strlen (tmp_prefix) + 64);
d749 1
a749 2
rvaafter (machine)
     int machine;
d773 1
a773 2
rvabefore (machine)
     int machine;
d797 1
a797 2
asm_prefix (machine)
     int machine;
d821 2
a822 2
#define ASM_BYTE 	mtable[machine].how_byte
#define ASM_SHORT 	mtable[machine].how_short
d825 2
a826 2
#define ASM_C 		mtable[machine].how_comment
#define ASM_JUMP 	mtable[machine].how_jump
d830 2
a831 2
#define ASM_RVA_BEFORE 	rvabefore(machine)
#define ASM_RVA_AFTER  	rvaafter(machine)
d845 1
a845 2
process_def_file (name)
     const char *name;
d882 1
a882 2
yyerror (err)
     const char * err ATTRIBUTE_UNUSED;
d891 2
a892 7
def_exports (name, internal_name, ordinal, noname, constant, data)
     const char *name;
     const char *internal_name;
     int ordinal;
     int noname;
     int constant;
     int data;
d914 1
a914 3
def_name (name, base)
     const char *name;
     int base;
d931 1
a931 3
def_library (name, base)
     const char *name;
     int base;
d947 1
a947 2
def_description (desc)
     const char *desc;
d956 1
a956 2
new_directive (dir)
     char *dir;
d965 1
a965 3
def_heapsize (reserve, commit)
     int reserve;
     int commit;
d976 1
a976 3
def_stacksize (reserve, commit)
     int reserve;
     int commit;
d990 1
a990 4
append_import (symbol_name, dll_name, func_ordinal)
     const char *symbol_name;
     const char *dll_name;
     int func_ordinal;
d1054 2
a1055 6
def_import (app_name, module, dllext, entry, ord_val)
     const char *app_name;
     const char *module;
     const char *dllext;
     const char *entry;
     int ord_val;
d1081 1
a1081 3
def_version (major, minor)
     int major;
     int minor;
d1087 1
a1087 3
def_section (name, attr)
     const char *name;
     int attr;
d1107 1
a1107 2
def_code (attr)
     int attr;
d1114 1
a1114 2
def_data (attr)
     int attr;
d1122 1
a1122 3
run (what, args)
     const char *what;
     char *args;
d1193 1
a1193 2
scan_drectve_symbols (abfd)
     bfd *abfd;
d1271 2
a1272 5
scan_filtered_symbols (abfd, minisyms, symcount, size)
     bfd *abfd;
     PTR minisyms;
     long symcount;
     unsigned int size;
d1314 1
a1314 2
add_excludes (new_excludes)
     const char *new_excludes;
d1347 1
a1347 2
match_exclude (string)
     const char *string;
d1368 1
a1368 5
filter_symbols (abfd, minisyms, symcount, size)
     bfd *abfd;
     PTR minisyms;
     long symcount;
     unsigned int size;
d1386 1
a1386 1
      sym = bfd_minisymbol_to_symbol (abfd, FALSE, (const PTR) from, store);
d1412 1
a1412 2
scan_all_symbols (abfd)
     bfd *abfd;
d1415 1
a1415 1
  PTR minisyms;
d1454 1
a1454 2
scan_open_obj_file (abfd)
     bfd *abfd;
d1468 1
a1468 2
scan_obj_file (filename)
     const char *filename;
d1511 1
a1511 2
dump_def_info (f)
     FILE *f;
d1536 1
a1536 3
sfunc (a, b)
     const void *a;
     const void *b;
d1542 1
a1542 5
flush_page (f, need, page_addr, on_page)
     FILE *f;
     long *need;
     int page_addr;
     int on_page;
d1572 1
a1572 1
gen_def_file ()
d1592 1
a1592 1
 	  fprintf (output_def,";\t%s\n", res);
d1632 1
a1632 2
generate_idata_ofile (filvar)
     FILE *filvar;
d1724 1
a1724 3
assemble_file (source, dest)
     const char * source;
     const char * dest;
d1737 1
a1737 1
gen_exp_file ()
d1987 1
a1987 2
xlate (name)
     const char *name;
d2017 1
a2017 3
dump_iat (f, exp)
     FILE *f;
     export_type *exp;
d2147 1
a2147 3
make_label (prefix, name)
     const char *prefix;
     const char *name;
d2159 1
a2159 3
make_imp_label (prefix, name)
     const char *prefix;
     const char *name;
d2183 1
a2183 3
make_one_lib_file (exp, i)
     export_type *exp;
     int i;
d2648 1
a2648 1
make_head ()
d2707 1
a2707 1
make_tail ()
d2765 1
a2765 1
gen_lib_file ()
d2851 1
a2851 3
pfunc (a, b)
     const void *a;
     const void *b;
d2867 1
a2867 3
nfunc (a, b)
     const void *a;
     const void *b;
d2876 1
a2876 2
remove_null_names (ptr)
     export_type **ptr;
d2893 1
a2893 2
dtab (ptr)
     export_type ** ptr
d2897 1
a2897 1
     ;
d2918 1
a2918 2
process_duplicates (d_export_vec)
     export_type **d_export_vec;
d2976 1
a2976 2
fill_ordinals (d_export_vec)
     export_type **d_export_vec;
d3050 1
a3050 3
alphafunc (av,bv)
     const void *av;
     const void *bv;
d3059 1
a3059 1
mangle_defs ()
d3107 1
a3107 3
usage (file, status)
     FILE *file;
     int status;
d3182 1
a3182 1
int main PARAMS ((int, char **));
d3185 1
a3185 3
main (ac, av)
     int ac;
     char **av;
d3396 1
a3396 4
look_for_prog (prog_name, prefix, end_prefix)
     const char *prog_name;
     const char *prefix;
     int end_prefix;
d3462 1
a3462 2
deduce_name (prog_name)
     const char *prog_name;
@


1.41
log
@* dlltool.c (prefix_encode): New function.  Encode temp file prefix from pid.
(dlltmp): Pass address of pointer being alloced or suffer neverending mallocs.
(make_one_lib_file): Allocate enough space for new longer stub names.
(gen_lib_file): Ditto.
(main): Generate the temp file prefix from the pid if prefix was not specified
on the command line.
@
text
@d756 1
a756 1
  static char alpha[] = "abcdefghijklmnopqrstuvwxyz";
@


1.40
log
@	* dlltool.c (gen_def_file): Put demangled name comments on
	own line preceding export name.
@
text
@d353 1
a353 1
static char *tmp_prefix = "d";
d443 6
a448 6
#define TMP_ASM		dlltmp (tmp_asm_buf, "%sc.s")
#define TMP_HEAD_S	dlltmp (tmp_head_s_buf, "%sh.s")
#define TMP_HEAD_O	dlltmp (tmp_head_o_buf, "%sh.o")
#define TMP_TAIL_S	dlltmp (tmp_tail_s_buf, "%st.s")
#define TMP_TAIL_O	dlltmp (tmp_tail_o_buf, "%st.o")
#define TMP_STUB	dlltmp (tmp_stub_buf, "%ss")
d754 1
a754 1
dlltmp PARAMS ((char *buf, const char *fmt))
d756 9
a764 3
  if (!buf)
    buf = malloc (strlen (tmp_prefix) + 17);
  sprintf (buf, fmt, tmp_prefix);
d768 11
d2368 1
a2368 1
      char *     outname = xmalloc (10);
d2945 1
a2945 1
      name = (char *) alloca (sizeof TMP_STUB + 10);
d3440 3
@


1.39
log
@* rclex.l (handle_quotes): Fix minor formatting problems introduced in previous
change.
@
text
@d1673 6
d1682 1
a1682 1
	  fprintf (output_def, "\t%s%s%s @@ %d%s%s ; %s\n",
d1688 1
a1688 2
		   exp->data ? " DATA" : "",
		   res ? res : "");
d1694 1
a1694 1
	  fprintf (output_def, "\t%s%s%s = %s%s%s @@ %d%s%s ; %s\n",
d1703 1
a1703 2
		   exp->data ? " DATA" : "",
		   res ? res : "");
a1704 2
      if (res)
	free (res);
@


1.38
log
@	* dlltool.c (mcore_elf_gen_out_file): Replace all occurrences of
	dyn_string_append with dyn_string_append_cstr.

	* emul_aix.c (ar_emul_aix_create): Remove unused function.
@
text
@d353 2
d436 13
a448 6
#define TMP_ASM		"dc.s"
#define TMP_HEAD_S	"dh.s"
#define TMP_HEAD_O	"dh.o"
#define TMP_TAIL_S	"dt.s"
#define TMP_TAIL_O	"dt.o"
#define TMP_STUB	"ds"
d753 8
d3283 1
d3340 3
@


1.37
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d3637 1
a3637 1
  dyn_string_append (ds, "-r ");
d3640 1
a3640 1
    dyn_string_append (ds, mcore_elf_linker_flags);
d3644 2
a3645 2
      dyn_string_append (ds, ptr->filename);
      dyn_string_append (ds, " ");
d3650 2
a3651 2
  dyn_string_append (ds, "-o ");
  dyn_string_append (ds, MCORE_ELF_TMP_OBJ);
d3664 2
a3665 2
  dyn_string_append (ds, "-S ");
  dyn_string_append (ds, as_name);
d3667 6
a3672 6
  dyn_string_append (ds, " -e ");
  dyn_string_append (ds, MCORE_ELF_TMP_EXP);
  dyn_string_append (ds, " -l ");
  dyn_string_append (ds, MCORE_ELF_TMP_LIB);
  dyn_string_append (ds, " " );
  dyn_string_append (ds, MCORE_ELF_TMP_OBJ);
d3675 1
a3675 1
    dyn_string_append (ds, " -v");
d3679 1
a3679 1
      dyn_string_append (ds, " -n");
d3682 1
a3682 1
	dyn_string_append (ds, " -n");
d3693 1
a3693 1
  dyn_string_append (ds, "-shared ");
d3696 1
a3696 1
    dyn_string_append (ds, mcore_elf_linker_flags);
d3698 6
a3703 6
  dyn_string_append (ds, " ");
  dyn_string_append (ds, MCORE_ELF_TMP_EXP);
  dyn_string_append (ds, " ");
  dyn_string_append (ds, MCORE_ELF_TMP_OBJ);
  dyn_string_append (ds, " -o ");
  dyn_string_append (ds, mcore_elf_out_file);
@


1.36
log
@Adds support for fastcall symbols as used on Microsoft Windows platforms
(i386)
@
text
@d270 4
a273 2
static char *look_for_prog PARAMS ((const char *, const char *, int));
static char *deduce_name PARAMS ((const char *));
d276 4
a279 2
static void mcore_elf_cache_filename PARAMS ((char *));
static void mcore_elf_gen_out_file PARAMS ((void));
d365 1
a365 1
/* True if we should export all symbols.  Otherwise, we only export
d367 1
a367 1
static boolean export_all_symbols;
d369 1
a369 1
/* True if we should exclude the symbols in DEFAULT_EXCLUDES when
d371 1
a371 1
static boolean do_default_excludes=true;
d376 1
a376 1
/* True if we should add __imp_<SYMBOL> to import libraries for backward
d378 1
a378 1
static boolean create_compat_implib;
d659 48
a706 24
static const char *rvaafter PARAMS ((int));
static const char *rvabefore PARAMS ((int));
static const char *asm_prefix PARAMS ((int));
static void process_def_file PARAMS ((const char *));
static void new_directive PARAMS ((char *));
static void append_import PARAMS ((const char *, const char *, int));
static void run PARAMS ((const char *, char *));
static void scan_drectve_symbols PARAMS ((bfd *));
static void scan_filtered_symbols PARAMS ((bfd *, PTR, long, unsigned int));
static void add_excludes PARAMS ((const char *));
static boolean match_exclude PARAMS ((const char *));
static void set_default_excludes PARAMS ((void));
static long filter_symbols PARAMS ((bfd *, PTR, long, unsigned int));
static void scan_all_symbols PARAMS ((bfd *));
static void scan_open_obj_file PARAMS ((bfd *));
static void scan_obj_file PARAMS ((const char *));
static void dump_def_info PARAMS ((FILE *));
static int sfunc PARAMS ((const void *, const void *));
static void flush_page PARAMS ((FILE *, long *, int, int));
static void gen_def_file PARAMS ((void));
static void generate_idata_ofile PARAMS ((FILE *));
static void assemble_file PARAMS ((const char *, const char *));
static void gen_exp_file PARAMS ((void));
static const char *xlate PARAMS ((const char *));
d708 2
a709 1
static void dump_iat PARAMS ((FILE *, export_type *));
d711 32
a742 16
static char *make_label PARAMS ((const char *, const char *));
static char *make_imp_label PARAMS ((const char *, const char *));
static bfd *make_one_lib_file PARAMS ((export_type *, int));
static bfd *make_head PARAMS ((void));
static bfd *make_tail PARAMS ((void));
static void gen_lib_file PARAMS ((void));
static int pfunc PARAMS ((const void *, const void *));
static int nfunc PARAMS ((const void *, const void *));
static void remove_null_names PARAMS ((export_type **));
static void dtab PARAMS ((export_type **));
static void process_duplicates PARAMS ((export_type **));
static void fill_ordinals PARAMS ((export_type **));
static int alphafunc PARAMS ((const void *, const void *));
static void mangle_defs PARAMS ((void));
static void usage PARAMS ((FILE *, int));
static void inform PARAMS ((const char *, ...));
d1300 1
a1300 1
	      int lead_at = (*c == '@@') ;	
d1338 1
a1338 1
      sym = bfd_minisymbol_to_symbol (abfd, false, from, store);
d1397 1
a1397 1
static boolean
d1405 2
a1406 2
      return true;
  return false;
d1442 1
a1442 1
      sym = bfd_minisymbol_to_symbol (abfd, false, (const PTR) from, store);
d1488 1
a1488 1
  symcount = bfd_read_minisymbols (abfd, false, &minisyms, &size);
d2580 8
a2587 8
		   Think of it as:                    
		   struct                             
		   {                                  
		     bfd_vma BeginAddress,     [0x00] 
		             EndAddress,       [0x04] 
			     ExceptionHandler, [0x08] 
			     HandlerData,      [0x0c] 
			     PrologEndAddress; [0x10] 
d3303 1
a3303 1
	  export_all_symbols = true;
d3306 1
a3306 1
	  export_all_symbols = false;
d3312 1
a3312 1
	  do_default_excludes = false;
d3426 1
a3426 1
    do_default_excludes = false;
@


1.35
log
@	* debug.c: Fix formatting.
	* debug.h: Likewise.
	* dlltool.c: Likewise.
	* dllwrap.c: Likewise.
	* emul_aix.c: Likewise.
	* emul_vanilla.c: Likewise.
@
text
@d23 1
a23 2
/*
   This program allows you to build the files necessary to create
d197 1
a197 2
   ld -o thedll.dll thedll.exp file1.o file2.o
 */
d233 1
a233 2
   .idata$7 = dll name (eg: "kernel32.dll"). (.idata$6 for ppc)
*/
d274 2
a275 2
static void mcore_elf_cache_filename (char *);
static void mcore_elf_gen_out_file (void);
d283 1
a283 1
#define WIFEXITED(w)	(((w)&0377) == 0)
d286 1
a286 1
#define WIFSIGNALED(w)	(((w)&0377) != 0177 && ((w)&~0377) == 0)
d327 2
a328 2
  char          *name;   /* name of function being imported */
  int            ord;    /* two-byte ordinal value associated with function */
d334 5
a338 5
  char          *dllname;  /* name of dll file imported from */
  long           nfuncs;   /* number of functions in list */
  struct ifunct *funchead; /* first function in list */
  struct ifunct *functail; /* last  function in list */
  struct iheadt *next;     /* next dll file in list */
d428 1
a428 1
#define PATHMAX 250		/* What's the right name for this ? */
d487 5
a491 5
/* This is the glue sequence for PowerPC PE. There is a  */
/* tocrel16-tocdefn reloc against the first instruction.  */
/* We also need a IMGLUE reloc against the glue function */
/* to restore the toc saved by the third instruction in  */
/* the glue.  */
d504 2
a505 2
/* the glue instruction, picks up the toc from the stw in */
/* the above code: "lwz r2,4(r1)"                         */
d526 2
a527 2
    int how_jtab_size; /* size of the jtab entry */
    int how_jtab_roff; /* offset into it for the ind 32 reloc into idata 5 */
d640 1
a640 1
    int forward;	/* number of forward label, 0 means no forward */
d683 1
d701 1
a701 1
inform VPARAMS ((const char *message, ...))
d835 1
a835 1
/* Communications with the parser */
d837 10
a846 10
static const char *d_name;	/* Arg to NAME or LIBRARY */
static int d_nfuncs;		/* Number of functions exported */
static int d_named_nfuncs;	/* Number of named functions exported */
static int d_low_ord;		/* Lowest ordinal index */
static int d_high_ord;		/* Highest ordinal index */
static export_type *d_exports;	/*list of exported functions */
static export_type **d_exports_lexically;	/* vector of exported functions in alpha order */
static dlist_type *d_list;	/* Descriptions */
static dlist_type *a_list;	/* Stuff to go in directives */
static int d_nforwards = 0;	/* Number of forwarded exports */
d901 2
a902 2
  /* if --dllname not provided, use the one in the DEF file.
     FIXME: Is this appropriate for executables? */
d920 1
a920 1
  /* if --dllname not provided, use the one in the DEF file.  */
d1255 2
a1256 1
	      char *exported_name = xstrdup (c);
d1306 2
a1307 1
	  char *exported_name = xstrdup (symbol_name);
d1335 5
a1339 2
      /* FIXME: Is it always right to add a leading underscore?  */
      sprintf (new_exclude->string, "_%s", exclude_string);
d1474 1
a1474 1
  /* FIXME: we ought to read in and block out the base relocations */
d1548 1
a1548 1
/* Generate the .exp file */
d1567 1
a1567 1
  /* Flush this page */
d1831 9
a1839 3
	    fprintf (f, "\t%s%s%s%s\t%s %d\n", ASM_RVA_BEFORE,
		     ASM_PREFIX,
		     exp->internal_name, ASM_RVA_AFTER, ASM_C, exp->ordinal);
d1939 1
a1939 1
  /* Dump the reloc section if a base file is provided */
d1999 1
a1999 1
  /* assemble the file */
d2012 3
a2014 1
  if (add_underscore)
d2017 1
d2026 2
d2070 1
a2070 1
  unsigned   char *data;
d2105 2
a2106 2
/* Sections numbered to make the order the same as other PowerPC NT    */
/* compilers. This also keeps funny alignment thingies from happening.  */
d2134 2
a2135 3
/*
This is what we're trying to make.  We generate the imp symbols with
both single and double underscores, for compatibility.
d2158 1
a2158 1
For the PowerPC, here's the variation on the above scheme:
d2169 1
a2169 2
	 bctr
*/
d2178 1
d2185 26
d2312 1
a2312 1
      /* First make symbols for the sections */
d2341 1
a2341 1
	  exp_label->name = make_label ("", exp->name);
d2346 1
a2346 1
	     points to the .toc */
d2370 1
a2370 1
	  iname->name = make_label ("__imp_", exp->name);
d2377 1
a2377 1
      iname2->name = make_label ("_imp__", exp->name);
a2388 1

d2398 1
a2398 1
      /* The symbol refering to the code (.text) */
d2412 1
a2412 1
      /* The .toc symbol */
d2414 1
a2414 1
	asymbol *toc_symbol;    /* The .toc symbol */
d2473 1
a2473 1
		 rva to idata$6 */
d2518 1
a2518 1
	      si->data =xmalloc(4);
d2534 10
a2543 10
		/* The .pdata section is 5 words long.  */
		/* Think of it as:                     */
		/* struct                              */
		/* {                                   */
		/*   bfd_vma BeginAddress,     [0x00]  */
		/*           EndAddress,       [0x04]  */
		/*	     ExceptionHandler, [0x08]  */
		/*	     HandlerData,      [0x0c]  */
		/*	     PrologEndAddress; [0x10]  */
		/* };                                  */
d2558 1
a2558 2
		      that this is a glue routine.
		*/
d2561 1
a2561 1
		/* alignment must be set to 2**2 or you get extra stuff */
d2565 1
a2565 1
		si->data =xmalloc(4 * 5);
d2574 1
a2574 1
		/* stick the toc reload instruction in the glue reloc */
d2587 1
a2587 1
		bfd_put_32(abfd, 0x18, si->data + 0x04);
d2593 2
a2594 2
		/* mark it as glue */
		bfd_put_32(abfd, 0x03, si->data + 0x0c);
d2596 2
a2597 2
		/* mark the prolog end address */
		bfd_put_32(abfd, 0x0D, si->data + 0x10);
d2612 1
a2612 3
	         We use relocs to build this.
	      */

d2643 1
a2643 1
	/* Size up all the sections */
d2654 1
a2654 1
      /* Write them out */
d2766 1
a2766 2
     crt0)
  */
d2778 1
a2778 1
     do too. Original, huh? */
d2792 1
a2792 1
  return  bfd_openr (TMP_TAIL_O, HOW_BFD_READ_TARGET);
a2819 1

d2833 1
a2833 2
  /* Now stick them all into the archive */

d2851 1
a2851 2
  /* Delete all the temp files */

d2880 1
a2880 1
   .def file and work out the best stuff */
d2891 1
a2891 1
  /* unset ordinals go to the bottom */
d2916 1
d2960 1
d2965 1
a2965 1
      /* Remove duplicates */
d2990 1
a2990 1
	      /* Merge attributes */
d3005 1
a3005 1
  /* Count the names */
d3024 1
a3024 2
  /* fill in the unset ordinals with ones from our range */

d3029 1
a3029 1
  /* Mark in our large vector all the numbers that are taken */
d3035 1
d3037 1
a3037 3
	    {
	      lowest = d_export_vec[i]->ordinal;
	    }
d3075 1
a3075 2
  /* And resort */

d3102 1
a3102 2
  /* First work out the minimum ordinal chosen */

d3113 1
a3113 3
    {
      d_export_vec[i] = exp;
    }
d3118 1
a3118 1
  /* Put back the list in the new order */
d3126 1
a3126 1
  /* Build list in alpha order */
d3131 2
a3132 3
    {
      d_exports_lexically[i] = exp;
    }
d3137 1
a3137 2
  /* Fill exp entries with their hint values */

d3139 2
a3140 4
    {
      if (!d_exports_lexically[i]->noname || show_allnames)
	d_exports_lexically[i]->hint = hint++;
    }
d3616 1
a3616 1
     Do this by recursively invoking dlltool....*/
a3640 1

@


1.34
log
@	* dlltool.c (process_def_file): Add missing prototype.
	(new_directive, assemble_file, main): Likewise.
	(process_def_file, new_directive): Make static.
	(inform): Rewrite using VA_FIXEDARG.
	* dllwrap.c (mybasename): Add missing prototype.
	(strhash, main): Likewise.
	(inform): Rewrite using VA_FIXEDARG.
	(warn): Likewise.
	(cleanup_and_exit): Use old style function definition.
	(strhash): Likewise.
	* windres.c (define_resource): Use one memset to clear all of
	struct res_resource.
@
text
@d118 1
a118 1
   
d165 1
a165 1
 
d169 1
a169 1
 
d173 1
a173 1
 
d183 1
a183 1
 
d188 1
a188 1
 
d193 1
a193 1
 
d197 1
a197 1
 
d280 1
a280 1
     
d375 1
a375 1
/* True if we should add __imp_<SYMBOL> to import libraries for backward 
d440 1
a440 1
/* This bit of assemly does jmp * .... */
d475 1
a475 1
  0x81, 0x01,            /* ld.w r1,(r1,0) */  
d478 1
a478 1
  0x00, 0x00, 0x00, 0x00 /* <address>      */  
d484 1
a484 1
  0x01, 0x81,            /* ld.w r1,(r1,0) */  
d487 1
a487 1
  0x00, 0x00, 0x00, 0x00 /* <address>      */  
d491 1
a491 1
/* tocrel16-tocdefn reloc against the first instruction. */
d494 1
a494 1
/* the glue. */
d649 1
a649 1
 
d820 1
a820 1
  
d829 1
a829 1
  
d859 1
a859 1
  
d883 2
a884 2
  
  if ((internal_name != NULL) 
d898 1
a898 1
  
d901 1
a901 1
  
d917 1
a917 1
  
d920 1
a920 1
  
d922 1
a922 1
  /* if --dllname not provided, use the one in the DEF file. */
d1064 1
a1064 1
  
d1165 1
a1165 1
      
d1170 1
a1170 1
  
d1207 1
a1207 1
  
d1210 1
a1210 1
      
d1215 1
a1215 1
      
d1233 1
a1233 1
	  
d1241 1
a1241 1
	  if (p < e && *p == ',')       /* found type tag. */
d1310 1
a1310 1
	  /* Note: stdcall alias symbols can never be data. */
d1331 1
a1331 1
      
d1403 1
a1403 1
      
d1470 1
a1470 1
 
d1489 1
a1489 1
  
d1500 1
a1500 1
      
d1573 1
a1573 1
  
d1577 1
a1577 1
      
d1580 1
a1580 1
  
d1583 1
a1583 1
  
d1596 1
a1596 1
  
d1609 1
a1609 1
        {
d1620 3
a1622 3
      else 
        {
          char *quote1 = strchr (exp->internal_name, '.') ? "\"" : "";
d1637 1
a1637 1
        free (res);
d1639 1
a1639 1
  
d1739 1
a1739 1
/* Assemble the specified file. */
d1746 1
a1746 1
  
d1765 1
a1765 1
  
d1770 1
a1770 1
  
d1775 1
a1775 1
  
d1874 1
a1874 1
      
d1882 1
a1882 1
	      
d1995 1
a1995 1
  
d2092 1
a2092 1
/* compilers. This also keeps funny alignment thingies from happening. */
d2251 1
a2251 1
      
d2253 1
a2253 1
      
d2255 1
a2255 1
      
d2262 1
a2262 1
      
d2270 1
a2270 1
      
d2272 1
a2272 1
 
d2388 1
a2388 1
      
d2409 1
a2409 1
		  
d2413 1
a2413 1
		  
d2496 1
a2496 1
		/* The .pdata section is 5 words long. */
d2653 1
a2653 1
  
d2685 1
a2685 1
  
d2694 1
a2694 1
  
d2712 1
a2712 1
  
d2718 1
a2718 1
  
d2757 1
a2757 1
  
d2781 1
a2781 1
  
d2785 1
a2785 1
  /* Work out a reasonable size of things to put onto one line. */
d2792 1
a2792 1
  
d2808 1
a2808 1
  
d2842 1
a2842 1
  
d2946 1
a2946 1
	      
d2950 1
a2950 1
	      
d3014 1
a3014 1
  /* Now fill in ordinals where the user wants us to choose. */
d3021 1
a3021 1
	  /* First try within or after any user supplied range. */
d3030 1
a3030 1
	  /* Then try before the range. */
d3082 1
a3082 1
  
d3118 1
a3118 1
  
d3224 1
a3224 1
#ifdef DLLTOOL_MCORE_ELF			   
d3307 1
a3307 1
	  
d3353 1
a3353 1
  
d3359 1
a3359 1
  
d3378 1
a3378 1
  
d3381 1
a3381 1
      /* Make imp_name safe for use as a label. */
d3393 1
a3393 1
  
d3396 1
a3396 1
  
d3401 1
a3401 1
  
d3419 2
a3420 2
  cmd = xmalloc (strlen (prefix) 
                 + strlen (prog_name) 
d3422 1
a3422 1
                 + strlen (EXECUTABLE_SUFFIX) 
d3435 1
a3435 1
               || stat (strcat (cmd, EXECUTABLE_SUFFIX), &s) == 0
d3440 1
a3440 1
        {
d3457 1
a3457 1
   run "i386-pe-as" or "ppc-pe-ld".  
d3463 1
a3463 1
   deduce_name("as") uses the following search order: 
d3468 1
a3468 1
   
d3474 1
a3474 1
     
d3573 1
a3573 1
  
d3587 1
a3587 1
  
d3592 1
a3592 1
  /* Step two. Create a .exp file and a .lib file from the temporary file. 
d3598 1
a3598 1
  
d3608 1
a3608 1
  
d3612 1
a3612 1
  
d3618 1
a3618 1
  
@


1.33
log
@Take into account --kill-at (-k) while generating .exp file.
@
text
@d661 2
d679 1
d703 1
a703 7
#ifdef __STDC__
inform (const char * message, ...)
#else
inform (message, va_alist)
     const char * message;
     va_dcl
#endif
d705 3
a707 2
  va_list args;
  
d711 1
a711 5
#ifdef __STDC__
  va_start (args, message);
#else
  va_start (args);
#endif
d713 1
a713 3
  report (message, args);
  
  va_end (args);
d815 1
a815 1
void
d938 1
a938 1
void
d3200 2
@


1.32
log
@Tidy up formatting of --help output.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001
d1868 1
a1868 1
		     exp->ordinal, ASM_TEXT, exp->name);
@


1.32.2.1
log
@	Merge from mainline
	2002-04-25  Elena Zannoni <ezannoni@@redhat.com>
        * readelf.c (get_AT_name): Handle DW_AT_GNU_vector.

	2002-04-16  Nick Clifton  <nickc@@cambridge.redhat.com>
	* readelf.c (fetch_location_list): Remove unused function.
	* readelf.c (process_corefile_note_segment): Catch corrupt notes
	and display a warning message, then exit the loop.

	2002-04-24  Christian Groessler <chris@@groessler.org>
	* MAINTAINERS: Changed my email address.

	2002-04-09  J"orn Rennecke <joern.rennecke@@superh.com>
	* MAINTAINERS: Update my email address.

	2002-03-27  Peter Targett  <peter.targett@@arc.com>
	* MAINTAINERS: Update my email address.

	2002-03-20  Daniel Berlin  <dan@@dberlin.org>
	* readelf.c: Add support for displaying dwarf2 location lists.
	(do_debug_loc, debug_loc_section, debug_loc_size): New.
	(parse_args): Use 'O' as shorthand for displaying location list
	section.
	(process_section_headers): Handle debug_loc as well.
	(load_debug_loc): New.
	(free_debug_loc): New.
	(fetch_location_list): New.
	(display_debug_loc): New.
	(display_debug_info): Call load_debug_loc and free_debug_loc.
	(debug_displays): We can display .debug_loc now, too.
	(usage): Update usage string.
	(read_and_display_attr_value): Note location lists, but don't
	display them inline.

	2002-03-01  Dmitry Timoshkov <dmitry@@baikal.ru>
	* dlltool.c (gen_exp_file): Take into account --kill-at (-k) while
	generating .exp file.

	2002-02-21  Nick Clifton  <nickc@@cambridge.redhat.com>
	* readelf.c (dump_relocations): Fix typo.

	2002-02-18  Timothy Daly  <remote_bob@@yahoo.com>
	* readelf.c (dump_relocations): Display 2nd and 3rd reloc
	types for 64-bit MIPS.  Narrow some fields for 80-char
	output.
	(dump_relocations): Change spelling from 'unrecognised'
	to 'unrecognized'.
	(decode_ARM_machine_flags): Likewise.
	(parse_args): Likewise.
	(read_and_display_attr_value): Likewise.
	(display_debug_section): Likewise.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d1868 1
a1868 1
		     exp->ordinal, ASM_TEXT, xlate (exp->name));
@


1.32.2.2
log
@Merge from mainline
@
text
@a660 2
static void process_def_file PARAMS ((const char *));
static void new_directive PARAMS ((char *));
a676 1
static void assemble_file PARAMS ((const char *, const char *));
d700 7
a706 1
inform VPARAMS ((const char *message, ...))
d708 2
a709 3
  VA_OPEN (args, message);
  VA_FIXEDARG (args, const char *, message);

d713 6
d720 2
a721 2

  VA_CLOSE (args);
d823 1
a823 1
static void
d946 1
a946 1
static void
a3207 2

int main PARAMS ((int, char **));
@


1.31
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d3138 1
a3138 1
  fprintf (file, _("Usage %s <options> <object-files>\n"), program_name);
d3231 1
a3231 1
			   "m:e:l:aD:d:z:b:xcCuUkAS:f:nvVhM:L:F:",
d3233 1
a3233 1
			   "m:e:l:aD:d:z:b:xcCuUkAS:f:nvVh",
d3283 1
@


1.30
log
@* dlltool.c (do_default_excludes): Initialise to true.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1997, 1998, 1999, 2000
d256 1
a257 1
#include <ctype.h>
d3223 3
d3392 1
a3392 1
	  if (!isalpha ((unsigned char) *p) && !isdigit ((unsigned char) *p))
@


1.29
log
@* dlltool.c (make_one_lib_file): Fix section flags for
.text, .data and .bss in stub ds*.o files to match those
generated by gas.
@
text
@d370 1
a370 1
static boolean do_default_excludes;
@


1.28
log
@* defparse.y (opt_equal_name): allow "." in name.
* dlltool.c (def_exports): Added ability to generate forwarded exports.
(gen_exp_file): Likewise.
@
text
@d2079 7
a2085 1
#define INIT_SEC_DATA(id, name, flags, align) { id, name, flags, align, NULL, NULL, NULL, 0, NULL }
d2088 7
a2094 7
  INIT_SEC_DATA (TEXT,   ".text",    SEC_CODE | SEC_HAS_CONTENTS, 2),
  INIT_SEC_DATA (DATA,   ".data",    SEC_DATA,                    2),
  INIT_SEC_DATA (BSS,    ".bss",     0,                           2),
  INIT_SEC_DATA (IDATA7, ".idata$7", SEC_HAS_CONTENTS,            2),
  INIT_SEC_DATA (IDATA5, ".idata$5", SEC_HAS_CONTENTS,            2),
  INIT_SEC_DATA (IDATA4, ".idata$4", SEC_HAS_CONTENTS,            2),
  INIT_SEC_DATA (IDATA6, ".idata$6", SEC_HAS_CONTENTS,            1)
d2240 1
a2240 1
      asymbol *  iname;
d2254 1
d2279 2
d2290 1
a2290 1
				 si->flags);
@


1.27
log
@Fix typos in ChangeLogs and update copyright notices
@
text
@d51 3
a53 1
   EXPORTS  ( <name1> [ = <name2> ] [ @@ <integer> ] [ NONAME ] [CONSTANT] [DATA] ) *
d55 3
a57 1
   DLL, with optional ordinal number <integer>
d643 1
d856 1
d891 6
d1834 8
a1841 3
	  fprintf (f, "\t%s%s%s%s\t%s %d\n", ASM_RVA_BEFORE,
                   ASM_PREFIX,
                   exp->internal_name, ASM_RVA_AFTER, ASM_C, exp->ordinal);
d1866 7
a1872 2
	  fprintf (f, "n%d:	%s	\"%s\"\n",
		   exp->ordinal, ASM_TEXT, exp->name);
@


1.26
log
@Add missing support for arm-epoc-pe.
@
text
@d2 2
a3 1
   Copyright (C) 1995, 96, 97, 98, 99, 2000 Free Software Foundation, Inc.
@


1.26.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1995, 1996, 1997, 1998, 1999, 2000
   Free Software Foundation, Inc.
@


1.25
log
@A mostly cosmetic tidy up of warnings and error message reporting.
@
text
@d386 3
d391 1
d612 1
a612 1
    "arm", ".byte", ".short", ".long", ".asciz", "@@",
d733 1
d758 1
d782 1
@


1.24
log
@Add support for WinCE targeted toolchains.
@
text
@a685 1
static void display PARAMS ((const char *, va_list));
a686 15
static void warn PARAMS ((const char *, ...));

static void
display (message, args)
     const char * message;
     va_list      args;
{
  if (program_name != NULL)
    fprintf (stderr, "%s: ", program_name);

  vfprintf (stderr, message, args);

  if (message [strlen (message) - 1] != '\n')
    fputc ('\n', stderr);
}  
d709 1
a709 1
  display (message, args);
a713 22
static void
#ifdef __STDC__
warn (const char * message, ...)
#else
warn (message, va_alist)
     const char * message;
     va_dcl
#endif
{
  va_list args;
  
#ifdef __STDC__
  va_start (args, message);
#else
  va_start (args);
#endif
  
  display (message, args);

  va_end (args);
}

d732 1
a732 1
      fatal (_("Internal error: Unknown machine type: %d\n"), machine);
d756 1
a756 1
      fatal (_("Internal error: Unknown machine type: %d\n"), machine);
d781 1
a781 1
      fatal (_("Internal error: Unknown machine type: %d\n"), machine);
d852 1
a852 1
  warn (_("Syntax error in def file %s:%d\n"), def_file, linenumber);
d888 1
a888 1
    warn (_("Can't have LIBRARY and NAME\n"));
d907 1
a907 1
    warn (_("%s: Can't have LIBRARY and NAME\n"), program_name);
d1122 1
a1122 1
  inform ("run: %s %s\n", what, args);
d1173 2
a1174 2
	warn (_("%s exited with status %d\n"),
	      what, WEXITSTATUS (wait_status));
d1205 1
a1205 1
  inform (_("Sucking in info from %s section in %s\n"),
d1329 1
a1329 1
      inform (_("Excluding symbol: %s\n"), exclude_string);
d1424 1
a1424 1
      warn (_("%s: no symbols\n"), bfd_get_filename (abfd));
d1435 1
a1435 1
      warn (_("%s: no symbols\n"), bfd_get_filename (abfd));
d1462 1
a1462 1
  inform (_("Done reading %s\n"), bfd_get_filename (abfd));
d1752 1
a1752 1
  inform (_("Generating export file: %s\n"), exp_name);
d2749 1
a2749 1
  inform (_("Creating library file: %s\n"), imp_name);
d2808 1
a2808 1
	    warn (_("cannot delete %s: %s\n"), name, strerror (errno));
d2917 1
a2917 1
	      inform (_("Warning, ignoring duplicate EXPORT %s %d,%d\n"),
@


1.24.2.1
log
@A mostly cosmetic tidy up of warnings and error message reporting.
@
text
@d686 1
d688 15
d725 1
a725 1
  report (message, args);
d730 22
d770 1
a770 1
      fatal (_("Internal error: Unknown machine type: %d"), machine);
d794 1
a794 1
      fatal (_("Internal error: Unknown machine type: %d"), machine);
d819 1
a819 1
      fatal (_("Internal error: Unknown machine type: %d"), machine);
d890 1
a890 1
  non_fatal (_("Syntax error in def file %s:%d"), def_file, linenumber);
d926 1
a926 1
    non_fatal (_("Can't have LIBRARY and NAME"));
d945 1
a945 1
    non_fatal (_("Can't have LIBRARY and NAME"));
d1160 1
a1160 1
  inform ("run: %s %s", what, args);
d1211 2
a1212 2
	non_fatal (_("%s exited with status %d"),
		   what, WEXITSTATUS (wait_status));
d1243 1
a1243 1
  inform (_("Sucking in info from %s section in %s"),
d1367 1
a1367 1
      inform (_("Excluding symbol: %s"), exclude_string);
d1462 1
a1462 1
      non_fatal (_("%s: no symbols"), bfd_get_filename (abfd));
d1473 1
a1473 1
      non_fatal (_("%s: no symbols"), bfd_get_filename (abfd));
d1500 1
a1500 1
  inform (_("Done reading %s"), bfd_get_filename (abfd));
d1790 1
a1790 1
  inform (_("Generating export file: %s"), exp_name);
d2787 1
a2787 1
  inform (_("Creating library file: %s"), imp_name);
d2846 1
a2846 1
	    non_fatal (_("cannot delete %s: %s"), name, strerror (errno));
d2955 1
a2955 1
	      inform (_("Warning, ignoring duplicate EXPORT %s %d,%d"),
@


1.23
log
@fix dll table lookup code for Motorola
@
text
@d397 8
@


1.22
log
@add year 2000 copyright notice
@
text
@d457 5
a461 3
  0x70, 0x01,            /* jmpi 1     */
  0x12, 0x11,            /* nop */
  0x00, 0x00, 0x00, 0x00 /* <address>  */  
d466 5
a470 3
  0x01, 0x70,            /* jmpi 1     */
  0x11, 0x12,            /* nop */
  0x00, 0x00, 0x00, 0x00 /* <address>  */  
d565 1
a565 1
    "jmpi\t1\n\tnop\n\t.long",
d568 1
a568 1
    mcore_be_jtab, sizeof (mcore_be_jtab), 4
d574 1
a574 1
    "jmpi\t1\n\tnop\n\t.long",
d577 1
a577 1
    mcore_le_jtab, sizeof (mcore_le_jtab), 4
d583 1
a583 1
    "jmpi\t1\n\tnop\n\t.long",
d586 1
a586 1
    mcore_be_jtab, sizeof (mcore_be_jtab), 4
d592 1
a592 1
    "jmpi\t1\n\tnop\n\t.long",
d595 1
a595 1
    mcore_le_jtab, sizeof (mcore_le_jtab), 4
@


1.21
log
@Apply Mumit Khan's patch to implement --compat-implib command line switch
@
text
@d2 1
a2 1
   Copyright (C) 1995, 96, 97, 98, 1999 Free Software Foundation, Inc.
@


1.20
log
@1999-12-23  Andrew Haley  <aph@@cygnus.com>

	* dlltool.c (mtable): mcore how_jtab_roff is 4 bytes into the
	jtab; was 8.
@
text
@d370 4
d1236 1
a1236 1
     Currently only data tag is supported. */
d1274 1
a1274 1
	      /* Note: stdcall alias symbols can never be data. */
d1886 3
a1888 3
	      /* We dont output as ascii 'cause there can
	         be quote characters in the string */

d1914 1
a1914 1
     without using the import library. */
d1924 2
a1925 1
	    fprintf (f, "\t%s\t__imp_%s\n", ASM_GLOBAL, exp->name);
d1927 2
a1928 1
	    fprintf (f, "__imp_%s:\n", exp->name);
d2187 2
a2188 1
      fprintf (f, "\t%s\t__imp_%s\n", ASM_GLOBAL, exp->name);
d2190 3
a2192 2
      fprintf (f, "%s%s:\n\t%s\t__imp_%s\n", ASM_PREFIX,
	       exp->name, ASM_JUMP, exp->name);
d2201 2
a2202 1
      fprintf (f, "__imp_%s:\n", exp->name);
d2323 8
a2330 5
      iname = bfd_make_empty_symbol(abfd);
      iname->name = make_label ("__imp_", exp->name);
      iname->section = secdata[IDATA5].sec;
      iname->flags = BSF_GLOBAL;
      iname->value = 0;
d2332 1
a2332 1
      iname2 = bfd_make_empty_symbol(abfd);
d2347 2
a2348 1
      ptrs[oidx++] = iname;
d3147 1
d3192 1
d3215 1
a3215 1
			   "m:e:l:aD:d:z:b:xcuUkAS:f:nvVhM:L:F:",
d3217 1
a3217 1
			   "m:e:l:aD:d:z:b:xcuUkAS:f:nvVh",
d3313 3
@


1.19
log
@change default arm gas abi selection to 32
@
text
@d560 1
a560 1
    mcore_be_jtab, sizeof (mcore_be_jtab), 8
d569 1
a569 1
    mcore_le_jtab, sizeof (mcore_le_jtab), 8
d578 1
a578 1
    mcore_be_jtab, sizeof (mcore_be_jtab), 8
d587 1
a587 1
    mcore_le_jtab, sizeof (mcore_le_jtab), 8
@


1.18
log
@Fix compile time warnings
@
text
@d515 1
a515 1
    ".global", ".space", ".align\t2",".align\t4", "-mapcs-26",
@


1.17
log
@Pass -mpacs-26 by default to arm assembler.
Add arm-epoc target support.
Do no mangle null page entries.
@
text
@d599 1
a599 1
  { 0 }
d871 1
a871 1
     const char *err;
d2069 1
d2072 7
a2078 7
  { TEXT,   ".text",    SEC_CODE | SEC_HAS_CONTENTS, 2},
  { DATA,   ".data",    SEC_DATA,                    2},
  { BSS,    ".bss",     0,                           2},
  { IDATA7, ".idata$7", SEC_HAS_CONTENTS,            2},
  { IDATA5, ".idata$5", SEC_HAS_CONTENTS,            2},
  { IDATA4, ".idata$4", SEC_HAS_CONTENTS,            2},
  { IDATA6, ".idata$6", SEC_HAS_CONTENTS,            1}
d2880 5
a2884 1
     export_type **ptr;
d3178 1
a3178 1
  {0}
@


1.16
log
@Chnage the default endianness for mcore to little
@
text
@d515 1
a515 1
    ".global", ".space", ".align\t2",".align\t4", "",
d540 1
a540 1
    ".global", ".space", ".align\t2",".align\t4", "=mthumb-interwork",
d590 9
a1259 1

d1313 1
a1313 1
                   ! (sym->flags & BSF_FUNCTION));
d1585 9
a1593 3
    fprintf (f, "\t%s\t0x%lx\n", ASM_SHORT,
	     ((need[i] - page_addr) | 0x3000) & 0xffff);

@


1.15
log
@clip shorts to prevent assembler warnings
@
text
@d394 1
a394 1
static const char * mname = "mcore";
d556 1
a556 1
    "mcore", ".byte", ".short", ".long", ".asciz", "//",
d574 1
a574 1
    "mcore-elf", ".byte", ".short", ".long", ".asciz", "//",
d3096 1
a3096 1
  fprintf (file, _("        possible <machine>: arm[_interwork], i386, mcore[-elf][-le], ppc, thumb\n"));
@


1.14
log
@Remove spurious test of exp_name
@
text
@d1575 1
d1577 3
a1579 3
    {
      fprintf (f, "\t%s\t0x%lx\n", ASM_SHORT, (need[i] - page_addr) | 0x3000);
    }
@


1.13
log
@Add default assembler switchhes on a per machine basis.
Use machine target type when opening output bfd files.
@
text
@d1743 1
a1743 2
			 + strlen (exp_name) + strlen (source)
			 + strlen (dest) + 50);
@


1.12
log
@* dlltool.c (scan_drectve_symbols): Handle type tags in exported
symbols.
(scan_filtered_symbols): Likewise.
@
text
@d500 1
d515 2
a516 1
    ".global", ".space", ".align\t2",".align\t4","pe-arm-little", bfd_arch_arm,
d522 4
a525 2
    "i386", ".byte", ".short", ".long", ".asciz", "#", "jmp *", ".global", ".space", ".align\t2",".align\t4","pe-i386",bfd_arch_i386,
   i386_jtab, sizeof (i386_jtab), 2
d530 4
a533 2
    "ppc", ".byte", ".short", ".long", ".asciz", "#", "jmp *", ".global", ".space", ".align\t2",".align\t4","pe-powerpcle",bfd_arch_powerpc,
   ppc_jtab, sizeof (ppc_jtab), 0
d540 2
a541 1
    ".global", ".space", ".align\t2",".align\t4","pe-arm-little", bfd_arch_arm,
d549 2
a550 1
    ".global", ".space", ".align\t2",".align\t4","pe-arm-little", bfd_arch_arm,
d558 2
a559 1
    ".global", ".space", ".align\t2",".align\t4","pe-mcore-big", bfd_arch_mcore,
d567 2
a568 1
    ".global", ".space", ".align\t2",".align\t4","pe-mcore-little", bfd_arch_mcore,
d576 2
a577 1
    ".global", ".space", ".align\t2",".align\t4","elf32-mcore-big", bfd_arch_mcore,
d585 2
a586 1
    ".global", ".space", ".align\t2",".align\t4","elf32-mcore-little", bfd_arch_mcore,
d590 1
a590 1
 {    0}
d813 2
a814 1
#define HOW_BFD_TARGET  0  /* always default*/
d819 2
d1734 17
a1757 1
  char *cmd;
d1975 1
a1975 10
  cmd = (char *) alloca (strlen (as_flags) + strlen (exp_name)
			 + sizeof TMP_ASM + 50);
  sprintf (cmd, "%s -o %s %s", as_flags, exp_name, TMP_ASM);

#ifdef DLLTOOL_ARM
  if (machine == MARM_INTERWORK || machine == MTHUMB)
    strcat (cmd, " -mthumb-interwork");
#endif

  run (as_name, cmd);
d2159 1
a2159 1
      char *cmd;
d2198 3
a2200 10
      cmd = (char *) alloca (strlen (as_flags) + 2 * strlen (prefix) + 50);
      sprintf (cmd, "%s -o %ss%05d.o %ss%d.s",
	       as_flags, prefix, i, prefix, i);

#ifdef DLLTOOL_ARM
      if (machine == MARM_INTERWORK || machine == MTHUMB)
	strcat (cmd, " -mthumb-interwork");
#endif
  
      run (as_name, cmd);
d2227 1
a2227 1
      abfd = bfd_openw (outname, HOW_BFD_TARGET);
d2604 1
a2604 1
      abfd = bfd_openr (outname, HOW_BFD_TARGET);
a2613 1
  char *cmd;
d2664 1
a2664 10
  cmd = (char *) alloca (strlen (as_flags) + sizeof TMP_HEAD_O
			 + sizeof TMP_HEAD_S + 50);
  sprintf (cmd, "%s -o %s %s", as_flags, TMP_HEAD_O, TMP_HEAD_S);
  
#ifdef DLLTOOL_ARM
  if (machine == MARM_INTERWORK || machine == MTHUMB)
    strcat (cmd, " -mthumb-interwork");
#endif
  
  run (as_name, cmd);
d2666 1
a2666 1
  return bfd_openr (TMP_HEAD_O, HOW_BFD_TARGET);
a2672 1
  char *cmd;
d2723 1
a2723 10
  cmd = (char *) alloca (strlen (as_flags) + sizeof TMP_TAIL_O
			 + sizeof TMP_TAIL_S + 50);
  sprintf (cmd, "%s -o %s %s", as_flags, TMP_TAIL_O, TMP_TAIL_S);
  
#ifdef DLLTOOL_ARM
  if (machine == MARM_INTERWORK || machine == MTHUMB)
    strcat (cmd, " -mthumb-interwork");
#endif
  
  run (as_name, cmd);
d2725 1
a2725 1
  return  bfd_openr (TMP_TAIL_O, HOW_BFD_TARGET);
d2740 1
a2740 1
  outarch = bfd_openw (imp_name, HOW_BFD_TARGET);
@


1.11
log
@extend comment.
@
text
@d1206 3
a1208 1
  /* Search for -export: strings */
d1218 1
d1222 1
a1222 1
	  while (p < e && *p != ' ' && *p != '-')
d1227 9
d1240 1
a1240 1
	  def_exports (c, 0, -1, 0, 0, 0);
d1247 1
d1289 2
a1290 1
      def_exports (xstrdup (symbol_name) , 0, -1, 0, 0, 0);
d1297 1
@


1.10
log
@only emit -mthumb-interowrk directive if really necessary.
@
text
@d161 1
a161 1
   ./dlltool --def thedll.def --output-exp thedll.o --output-lib thedll.a
d163 2
a164 1
 # Build the dll with the library with file1.o, file2.o and the export table
d168 1
d171 23
@


1.9
log
@1999-06-23  Mumit Khan  <khan@@xraylith.wisc.edu>
	* configure.in (HAVE_EXECUTABLE_SUFFIX): Define.
	* dlltool.c (look_for_prog): Use HAVE_EXECUTABLE_SUFFIX.
	* dllwrap.c (look_for_prog): Likewise.
	* resrc.c (look_for_default): Likewise.
	* configure, config.in: Rebuild.
@
text
@d146 1
a146 1
 # compile up the parts of the dll
d148 1
a148 2
   gcc -c file1.c
   gcc -c file2.c
d150 3
a152 2
 # put them in a library (you don't have to, you
 # could name all the .os on the dlltool line)
d157 4
a160 1
 # run this tool over the library and the def file
d163 1
a163 1
 # build the dll with the library with file1.o, file2.o and the export table
d166 1
a166 4
 # build the mainline
   gcc -c themain.c

 # link the executable with the import library
d2684 1
a2684 1
  if (machine == MARM_INTERWORK || MTHUMB)
@


1.8
log
@	Based on patches from Mumit Khan <khan@@xraylith.wisc.EDU>:
	* configure.in: Define EXECUTABLE_SUFFIX.
	* dlltool.c: Include "dyn-string.h".  Include <stdarg.h> based on
	ANSI_PROTOTYPES, not __STDC__.
	(outfile): Remove.
	(gen_exp_file): Change uses of outfile to use alloca.
	(make_one_lib_file, make_head, make_tail): Likewise.
	(gen_lib_file): Likewise.
	(look_for_prog): New static function.
	(deduce_name): Rewrite to use look_for_prog.
	(mcore_elf_gen_out_file): Use dyn_string_t rather than outfile.
	* dllwrap.c: Don't include <stdio.h>, <errno.h>, <string.h>,
	<stdlib.h>, or <unistd.h>.  Include <sys/stat.h> and either
	<stdarg.h> or <varargs.h>.
	(driver_name): Initialize to NULL, not "gcc".
	(dlltool_name): Initialize to NULL, not "dlltool".
	(display, inform, look_for_prog, deduce_name): New static
	functions.
	(usage): Mention -mno-cygwin.
	(OPTION_MNO_CYGWIN): Define.
	(main): Handle -mno-cygwin.  Deduce driver_name and dlltool_name.
	* resrc.c (look_for_default): Make static.  Remove unused local
	path.  Check using EXECUTABLE_SUFFIX.
	(read_rc_file): Allocate enough space to hold EXECUTABLE_SUFFIX.
	* Makefile.am: Rebuild dependencies.
	(dllwrap_LDADD): Add $(INTLLIBS).
	* configure, Makefile.in, config.in: Rebuild.
@
text
@d3325 1
a3325 1
   defined.  */
d3338 1
a3338 1
#ifdef EXECUTABLE_SUFFIX
d3351 1
a3351 1
#ifdef EXECUTABLE_SUFFIX
@


1.7
log
@Link object files with the .exp file, not the .lib file
@
text
@d224 1
d229 3
a231 1
#ifdef __STDC__
a241 1

d243 2
a244 1
static char * deduce_name (char *);
a461 6
/* The outfile array must be big enough to contain a fully
   qualified path name, plus an arbitary series of command
   line switches.  We hope that PATH_MAX times two will be
   enough.  */
static char outfile [PATHMAX * 2];

d1686 1
d1904 3
a1906 1
  sprintf (outfile, "%s -o %s %s", as_flags, exp_name, TMP_ASM);
d1910 1
a1910 1
    strcat (outfile, " -mthumb-interwork");
d1912 3
a1914 3
  
  run (as_name, outfile);
  
d2094 1
d2096 6
a2101 3
      char *prefix="d";
      sprintf (outfile, "%ss%05d.s", prefix, i);
      f = fopen (outfile, FOPEN_WT);
d2136 2
a2137 1
      sprintf (outfile, "%s -o %ss%05d.o %ss%d.s",
d2142 1
a2142 1
	strcat (outfile, " -mthumb-interwork");
d2145 1
a2145 1
      run (as_name, outfile);
d2558 2
a2559 1
  FILE *  f = fopen (TMP_HEAD_S, FOPEN_WT);
d2610 3
a2612 1
  sprintf (outfile, "%s -o %s %s", as_flags, TMP_HEAD_O, TMP_HEAD_S);
d2616 1
a2616 1
    strcat (outfile, " -mthumb-interwork");
d2619 1
a2619 1
  run (as_name, outfile);
d2621 1
a2621 1
  return  bfd_openr (TMP_HEAD_O, HOW_BFD_TARGET);
d2627 2
a2628 1
  FILE *  f = fopen (TMP_TAIL_S, FOPEN_WT);
d2679 3
a2681 1
  sprintf (outfile, "%s -o %s %s", as_flags, TMP_TAIL_O, TMP_TAIL_S);
d2685 1
a2685 1
    strcat (outfile, " -mthumb-interwork");
d2688 1
a2688 1
  run (as_name, outfile);
d2763 3
d2768 2
a2769 2
	  sprintf (outfile, "%s%05d.o", TMP_STUB, i);
	  if (unlink (outfile) < 0)
d2771 1
a2771 1
	    warn (_("cannot delete %s: %s\n"), outfile, strerror (errno));
d3322 49
d3374 22
a3395 4
   run "i386-pe-as" or "ppc-pe-ld".  We detect this case by
   examining the name used to invoke dlltool itself.  If
   dlltool is actually called <foo>-<bar>-dlltool then we
   prepend <foo>-<bar> to the default name.  */
d3397 2
a3398 1
deduce_name (char * prog_name)
d3400 19
a3418 5
  /* Use our own static array to hold the constructed name
     rather than the outfile[] array, as that array may
     already be in use.  */
  static char new_name[32];
  char * p;
d3420 8
a3427 4
  p = strrchr (program_name, '-');
  
  if (p == NULL)
    return prog_name;
d3429 6
a3434 5
  /* assert (strlen (program_name) < 32); */
  
  strcpy (new_name, program_name);
  
  new_name [(p - program_name) + 1] = 0;
d3436 5
a3440 1
  strcat (new_name, prog_name);
d3442 1
a3442 1
  return new_name;
d3479 1
d3485 2
a3486 1
  strcpy (outfile, "-r ");
d3489 1
a3489 1
    strcat (outfile, mcore_elf_linker_flags);
d3493 2
a3494 9
      /* Check for overrun: what the hell, it's only cpu cycles... */
      if (strlen (outfile) + strlen (ptr->filename) + 2 >= sizeof (outfile))
	{
	  fatal (_("buffer overflow\n"));
	  return;
	}
      
      strcat (outfile, ptr->filename);
      strcat (outfile, " ");
d3499 2
a3500 2
  strcat (outfile, "-o ");
  strcat (outfile, MCORE_ELF_TMP_OBJ);
d3505 3
a3507 1
  run (mcore_elf_linker, outfile);
d3511 4
a3514 1
  sprintf (outfile, "-S %s", as_name);
d3516 6
a3521 6
  strcat (outfile, " -e ");
  strcat (outfile, MCORE_ELF_TMP_EXP);
  strcat (outfile, " -l ");
  strcat (outfile, MCORE_ELF_TMP_LIB);
  strcat (outfile, " " );
  strcat (outfile, MCORE_ELF_TMP_OBJ);
d3524 1
a3524 1
    strcat (outfile, " -v");
d3528 1
a3528 1
      strcat (outfile, " -n");
d3531 1
a3531 1
	strcat (outfile, " -n");
d3536 3
a3538 1
  run (program_name, outfile);
d3541 3
a3543 1
  strcpy (outfile, "-shared ");
d3546 8
a3553 1
    strcat (outfile, mcore_elf_linker_flags);
d3555 1
a3555 6
  strcat (outfile, " ");
  strcat (outfile, MCORE_ELF_TMP_EXP);
  strcat (outfile, " ");
  strcat (outfile, MCORE_ELF_TMP_OBJ);
  strcat (outfile, " -o ");
  strcat (outfile, mcore_elf_out_file);
d3557 1
a3557 1
  run (mcore_elf_linker, outfile);
@


1.6
log
@Use macros to hold names of temporary files.
@
text
@d3433 1
a3433 1
  /* Step four. Feed the .exp and .lib files to ld -shared to create the dll.  */
d3442 1
a3442 1
  strcat (outfile, MCORE_ELF_TMP_LIB);
d3449 1
a3449 4
    {
      unlink (MCORE_ELF_TMP_EXP);
      unlink (MCORE_ELF_TMP_LIB);
    }
@


1.5
log
@* dlltool.c (gen_exp_file): Revert 19990411 change.
@
text
@d3237 2
a3238 2
      if (strcmp (mtable[i].type, mname) == 0)
	break;
d3299 1
a3299 1

d3366 4
d3399 2
a3400 1
  strcat (outfile, "-o mcoreelf.tmp");
d3411 6
a3416 1
  strcat (outfile, " -e mcoreelf.exp -l mcoreelf.lib mcoreelf.tmp");
d3422 2
a3423 1
    strcat (outfile, " -n");
d3425 3
a3427 2
  if (dontdeltemps > 1)
    strcat (outfile, " -n");
d3433 1
a3433 1
  /* Step four. Feed the two new files to ld -shared.  */
d3439 5
a3443 1
  strcat (outfile, " mcoreelf.exp mcoreelf.lib -o ");
d3447 9
@


1.4
log
@Add support for generating an mcore-elf dll.
@
text
@a352 4
#ifdef DLLTOOL_BEOS
static const char *mname = "beos";
#endif

a1872 2
	  int totsize = 0;

a1885 1
	      totsize += 2;
a1888 1
		  totsize += 8 + (on_page & 1)*2;
a1894 11

	  /* Pad the section to an even 32-byte boundary.  This will make
	     the BeOS loader much happier, and shouldn't matter for other
	     OSes. */
	  while ((totsize + 8 + (on_page & 1)*2) % 32 != 0)
	    {
	      /* 0x0000 is an absolute relocation that should be ignored.  */
	      need[on_page++] = 0x0000;
	      totsize += 2;
	    }

d1897 1
a1897 1
	  /* fprintf (f, "\t%s\t0,0\t%s End\n", ASM_LONG, ASM_C);*/
@


1.3
log
@Add support for mcore to dlltool.
@
text
@d239 9
d316 1
a316 1
static char *as_name = "as";
d375 4
d1428 1
a1428 1
  inform (_("%s: Done reading %s\n"), bfd_get_filename (abfd));
d1454 5
d1463 5
d3089 5
a3093 1
  
a3100 2
#define OPTION_NO_IDATA4		'x'
#define OPTION_NO_IDATA5		'c'
d3106 2
a3107 2
  {"no-idata4", no_argument, NULL, OPTION_NO_IDATA4},
  {"no-idata5", no_argument, NULL, OPTION_NO_IDATA5},
d3128 1
d3149 6
a3154 1
  while ((c = getopt_long (ac, av, "xcz:S:aD:l:e:nkAvVb:Uh?m:d:f:i",
a3159 6
	case OPTION_NO_IDATA4:
	  no_idata4 = 1;
	  break;
	case OPTION_NO_IDATA5:
	  no_idata5 = 1;
	  break;
d3172 6
a3214 7
	case 'y':
#if 0
	  /* We don't currently define YYDEBUG when building
             defparse.y.  */
	  yydebug = 1;
#endif
	  break;
d3238 11
a3255 1
    {
a3257 1
    }
d3273 3
d3319 5
d3326 126
@


1.2
log
@        * dlltool.c (interwork): Remove.
        (arm_interwork_jtab): Use bx insn.
        (thumb_jtab): Likewise.
        (MARM_INTERWORK): New machine type.
        (rvaafter): Handle it.
        (rvabefore) Likewise.
        (asm_prefix): Likewise.
        (gen_exp_type): Check machine type instead of
        interwork flag.
        (make_one_lib_file): Likewise.
        (make_head): Likewise.
        (make_tail): Likewise.
        (usage): Update machine types.
        (main): Remove -interwork support.
@
text
@d124 1
a124 1
   printf()
d129 2
a130 3
 main.c

   void main()
d132 2
a133 1
     cdef();
d167 1
a167 1
   ld -e main -Tthemain.ld -o themain.exe themain.o thedll.a
d360 13
d382 1
a382 2
/* This bit of assemly does jmp * ....
s set how_jtab_roff to mark where the 32bit abs branch should go */
d414 14
d515 33
a547 1
{    0}
d695 4
d719 4
d742 4
d769 1
a769 1
#define ASM_ALIGN_LONG mtable[machine].how_align_long
d771 4
a774 4
#define HOW_BFD_ARCH   mtable[machine].how_bfd_arch
#define HOW_JTAB       mtable[machine].how_jtab
#define HOW_JTAB_SIZE      mtable[machine].how_jtab_size
#define HOW_JTAB_ROFF      mtable[machine].how_jtab_roff
d1159 1
a1159 1
  
d1161 1
a1161 1
  s = bfd_get_section_by_name (abfd, ".drectve");
d1172 2
a1173 2
  inform (_("Sucking in info from .drective section in %s\n"),
	  bfd_get_filename (abfd));
d1766 1
a1766 1
	  fprintf (f, "\t.section .drectve\n");
d1772 1
d2551 6
d2588 1
d2597 1
d2617 6
d2628 1
d3042 2
a3043 1
  fprintf (file, _("   -m --machine <machine>    Create {arm, arm_interwork, i386, ppc, thumb} DLL. [default: %s]\n"), mname);
d3050 4
a3053 4
  fprintf (file, _("   --export-all-symbols      Export all symbols to .def\n"));
  fprintf (file, _("   --no-export-all-symbols   Only export listed symbols\n"));
  fprintf (file, _("   --exclude-symbols <list>  Don't export <list>\n"));
  fprintf (file, _("   --no-default-excludes     Clear default exclude symbols\n"));
@


1.1
log
@Initial revision
@
text
@a321 4
#ifdef DLLTOOL_ARM
static int interwork = 0;
#endif 

d378 10
a387 2
  0x00, 0xc0, 0x9f, 0xe5,
  0x00, 0xf0, 0x9c, 0xe5,
d393 6
a398 6
  0xc0, 0xb4,
  0x02, 0x4e,
  0x36, 0x68,
  0x01, 0x96,
  0x40, 0xbd,
  0xc0, 0x46,
d476 1
a476 1
    "push\t{r6, r7}\n\tldr\tr6, [pc, #8]\n\tldr\tr6, [r6]\n\tstr\tr6, [sp, #4]\n\tpop\t{r6, pc}\n\tnop",
d481 8
d636 1
d656 1
d675 1
d1665 2
a1666 2
		   ASM_PREFIX,
		   exp->internal_name, ASM_RVA_AFTER, ASM_C, exp->ordinal);
d1834 1
a1834 1
  if (interwork)
d2061 1
a2061 1
      if (interwork)
d2105 1
a2105 1
      if (interwork)
d2524 1
a2524 1
  if (interwork)
d2583 1
a2583 1
  if (interwork)
d2956 1
a2956 1
  fprintf (file, _("   -m --machine <machine>    Create {arm, i386, ppc, thumb} DLL. [default: %s]\n"), mname);
a2974 3
#ifdef DLLTOOL_ARM
  fprintf (file, _("   -i --interwork            Support ARM/Thumb interworking.\n"));
#endif
a3015 3
#ifdef DLLTOOL_ARM
  {"interwork", no_argument, NULL, 'i'},
#endif
a3096 5
#ifdef DLLTOOL_ARM
	case 'i':
	  interwork = 1;
	  break;
#endif
a3144 6
#ifdef DLLTOOL_ARM
  /* Always enable interworking for Thumb targets.  */
  if (machine == MTHUMB && (! interwork))
    interwork = 1;
#endif
  
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

