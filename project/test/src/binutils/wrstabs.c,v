head	1.21;
access;
symbols
	binutils-2_24-branch:1.21.0.8
	binutils-2_24-branchpoint:1.21
	binutils-2_21_1:1.19
	binutils-2_23_2:1.21
	binutils-2_23_1:1.21
	binutils-2_23:1.21
	binutils-2_23-branch:1.21.0.6
	binutils-2_23-branchpoint:1.21
	binutils-2_22_branch:1.21.0.4
	binutils-2_22:1.21
	binutils-2_22-branch:1.21.0.2
	binutils-2_22-branchpoint:1.21
	binutils-2_21:1.19
	binutils-2_21-branch:1.19.0.2
	binutils-2_21-branchpoint:1.19
	binutils-2_20_1:1.17.2.1
	binutils-2_20:1.17.2.1
	binutils-arc-20081103-branch:1.16.0.10
	binutils-arc-20081103-branchpoint:1.16
	binutils-2_20-branch:1.17.0.2
	binutils-2_20-branchpoint:1.17
	dje-cgen-play1-branch:1.16.0.8
	dje-cgen-play1-branchpoint:1.16
	arc-20081103-branch:1.16.0.6
	arc-20081103-branchpoint:1.16
	binutils-2_19_1:1.16
	binutils-2_19:1.16
	binutils-2_19-branch:1.16.0.4
	binutils-2_19-branchpoint:1.16
	binutils-2_18:1.16
	binutils-2_18-branch:1.16.0.2
	binutils-2_18-branchpoint:1.16
	binutils-csl-coldfire-4_1-32:1.13
	binutils-csl-sourcerygxx-4_1-32:1.13
	binutils-csl-innovasic-fido-3_4_4-33:1.13
	binutils-csl-sourcerygxx-3_4_4-32:1.11
	binutils-csl-coldfire-4_1-30:1.13
	binutils-csl-sourcerygxx-4_1-30:1.13
	binutils-csl-coldfire-4_1-28:1.13
	binutils-csl-sourcerygxx-4_1-29:1.13
	binutils-csl-sourcerygxx-4_1-28:1.13
	binutils-csl-arm-2006q3-27:1.13
	binutils-csl-sourcerygxx-4_1-27:1.13
	binutils-csl-arm-2006q3-26:1.13
	binutils-csl-sourcerygxx-4_1-26:1.13
	binutils-csl-sourcerygxx-4_1-25:1.13
	binutils-csl-sourcerygxx-4_1-24:1.13
	binutils-csl-sourcerygxx-4_1-23:1.13
	binutils-csl-sourcerygxx-4_1-21:1.13
	binutils-csl-arm-2006q3-21:1.13
	binutils-csl-sourcerygxx-4_1-22:1.13
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.13
	binutils-csl-sourcerygxx-4_1-20:1.13
	binutils-csl-arm-2006q3-19:1.13
	binutils-csl-sourcerygxx-4_1-19:1.13
	binutils-csl-sourcerygxx-4_1-18:1.13
	binutils-csl-renesas-4_1-9:1.13
	binutils-csl-sourcerygxx-3_4_4-25:1.11
	binutils-csl-renesas-4_1-8:1.13
	binutils-csl-renesas-4_1-7:1.13
	binutils-csl-renesas-4_1-6:1.13
	binutils-csl-sourcerygxx-4_1-17:1.13
	binutils-csl-sourcerygxx-4_1-14:1.13
	binutils-csl-sourcerygxx-4_1-15:1.13
	binutils-csl-sourcerygxx-4_1-13:1.13
	binutils-2_17:1.13
	binutils-csl-sourcerygxx-4_1-12:1.13
	binutils-csl-sourcerygxx-3_4_4-21:1.13
	binutils-csl-wrs-linux-3_4_4-24:1.11
	binutils-csl-wrs-linux-3_4_4-23:1.11
	binutils-csl-sourcerygxx-4_1-9:1.13
	binutils-csl-sourcerygxx-4_1-8:1.13
	binutils-csl-sourcerygxx-4_1-7:1.13
	binutils-csl-arm-2006q1-6:1.13
	binutils-csl-sourcerygxx-4_1-6:1.13
	binutils-csl-wrs-linux-3_4_4-22:1.11
	binutils-csl-coldfire-4_1-11:1.13
	binutils-csl-sourcerygxx-3_4_4-19:1.13
	binutils-csl-coldfire-4_1-10:1.13
	binutils-csl-sourcerygxx-4_1-5:1.13
	binutils-csl-sourcerygxx-4_1-4:1.13
	binutils-csl-wrs-linux-3_4_4-21:1.11
	binutils-csl-morpho-4_1-4:1.13
	binutils-csl-sourcerygxx-3_4_4-17:1.13
	binutils-csl-wrs-linux-3_4_4-20:1.11
	binutils-2_17-branch:1.13.0.4
	binutils-2_17-branchpoint:1.13
	binutils-csl-2_17-branch:1.13.0.2
	binutils-csl-2_17-branchpoint:1.13
	binutils-csl-gxxpro-3_4-branch:1.11.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.11
	binutils-2_16_1:1.11
	binutils-csl-arm-2005q1b:1.11
	binutils-2_16:1.11
	binutils-csl-arm-2005q1a:1.11
	binutils-csl-arm-2005q1-branch:1.11.0.4
	binutils-csl-arm-2005q1-branchpoint:1.11
	binutils-2_16-branch:1.11.0.2
	binutils-2_16-branchpoint:1.11
	csl-arm-2004-q3d:1.10
	csl-arm-2004-q3:1.10
	binutils-2_15:1.10
	binutils-2_15-branchpoint:1.10
	csl-arm-2004-q1a:1.10
	csl-arm-2004-q1:1.10
	binutils-2_15-branch:1.10.0.6
	cagney_bfdfile-20040213-branch:1.10.0.4
	cagney_bfdfile-20040213-branchpoint:1.10
	cagney_bigcore-20040122-branch:1.10.0.2
	cagney_bigcore-20040122-branchpoint:1.10
	csl-arm-2003-q4:1.10
	binutils-2_14:1.9
	binutils-2_14-branch:1.9.0.2
	binutils-2_14-branchpoint:1.9
	binutils-2_13_2_1:1.7
	binutils-2_13_2:1.7
	binutils-2_13_1:1.7
	binutils-2_13:1.7
	binutils-2_13-branchpoint:1.7
	binutils-2_13-branch:1.7.0.2
	binutils-2_12_1:1.5
	binutils-2_12:1.5
	binutils-2_12-branch:1.5.0.2
	binutils-2_12-branchpoint:1.5
	cygnus_cvs_20020108_pre:1.5
	binutils-2_11_2:1.3.2.1
	binutils-2_11_1:1.3.2.1
	binutils-2_11:1.3
	x86_64versiong3:1.3
	binutils-2_11-branch:1.3.0.2
	binutils-2_10_1:1.2.2.1
	binutils-2_10:1.2.2.1
	binutils-2_10-branch:1.2.0.2
	binutils-2_10-branchpoint:1.2
	binutils_latest_snapshot:1.21
	repo-unification-2000-02-06:1.2
	binu_ss_19990721:1.2
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.21
date	2011.03.14.19.05.39;	author msnyder;	state Exp;
branches;
next	1.20;

1.20
date	2011.02.28.18.32.51;	author ktietz;	state Exp;
branches;
next	1.19;

1.19
date	2009.12.11.13.42.06;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2009.09.10.13.40.44;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2009.09.02.07.22.32;	author amodra;	state Exp;
branches
	1.17.2.1;
next	1.16;

1.16
date	2007.07.05.16.54.45;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2007.04.26.14.46.59;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2006.08.15.12.01.43;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2006.03.16.12.20.16;	author amodra;	state Exp;
branches
	1.13.4.1;
next	1.12;

1.12
date	2005.05.08.14.17.39;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2005.03.03.11.46.12;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2003.09.14.12.20.17;	author aj;	state Exp;
branches;
next	1.9;

1.9
date	2003.03.06.16.45.42;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2002.11.30.08.39.41;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.26.14.55.04;	author kazu;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.24.00.33.36;	author kazu;	state Exp;
branches;
next	1.5;

1.5
date	2001.09.19.05.33.17;	author hjl;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.13.06.43.58;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.07.04.34.50;	author amodra;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	99.07.11.20.02.30;	author ian;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	99.05.03.07.29.10;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.17.2.1
date	2009.09.10.13.42.10;	author nickc;	state Exp;
branches;
next	;

1.13.4.1
date	2006.08.15.12.01.21;	author nickc;	state Exp;
branches;
next	;

1.3.2.1
date	2001.06.07.03.12.28;	author amodra;	state Exp;
branches;
next	;

1.2.2.1
date	2000.04.07.04.39.25;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.10;	author rth;	state Exp;
branches;
next	;


desc
@@


1.21
log
@2011-03-08  Michael Snyder  <msnyder@@vmware.com>

	* wrstabs.c (stab_start_struct_type): Close memory leak.
@
text
@/* wrstabs.c -- Output stabs debugging information
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2006,
   2007, 2009   Free Software Foundation, Inc.
   Written by Ian Lance Taylor <ian@@cygnus.com>.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* This file contains code which writes out stabs debugging
   information.  */

#include "sysdep.h"
#include <assert.h>
#include "bfd.h"
#include "libiberty.h"
#include "filenames.h"
#include "safe-ctype.h"
#include "bucomm.h"
#include "debug.h"
#include "budbg.h"
#include "aout/aout64.h"
#include "aout/stab_gnu.h"

/* The size of a stabs symbol.  This presumes 32 bit values.  */

#define STAB_SYMBOL_SIZE (12)

/* An entry in a string hash table.  */

struct string_hash_entry
{
  struct bfd_hash_entry root;
  /* Next string in this table.  */
  struct string_hash_entry *next;
  /* Index in string table.  */
  long index;
  /* Size of type if this is a typedef.  */
  unsigned int size;
};

/* A string hash table.  */

struct string_hash_table
{
  struct bfd_hash_table table;
};

/* The type stack.  Each element on the stack is a string.  */

struct stab_type_stack
{
  /* The next element on the stack.  */
  struct stab_type_stack *next;
  /* This element as a string.  */
  char *string;
  /* The type index of this element.  */
  long index;
  /* The size of the type.  */
  unsigned int size;
  /* Whether type string defines a new type.  */
  bfd_boolean definition;
  /* String defining struct fields.  */
  char *fields;
  /* NULL terminated array of strings defining base classes for a
     class.  */
  char **baseclasses;
  /* String defining class methods.  */
  char *methods;
  /* String defining vtable pointer for a class.  */
  char *vtable;
};

/* This structure is used to keep track of type indices for tagged
   types.  */

struct stab_tag
{
  /* The type index.  */
  long index;
  /* The tag name.  */
  const char *tag;
  /* The kind of type.  This is set to DEBUG_KIND_ILLEGAL when the
     type is defined.  */
  enum debug_type_kind kind;
  /* The size of the struct.  */
  unsigned int size;
};

/* We remember various sorts of type indices.  They are not related,
   but, for convenience, we keep all the information in this
   structure.  */

struct stab_type_cache
{
  /* The void type index.  */
  long void_type;
  /* Signed integer type indices, indexed by size - 1.  */
  long signed_integer_types[8];
  /* Unsigned integer type indices, indexed by size - 1.  */
  long unsigned_integer_types[8];
  /* Floating point types, indexed by size - 1.  */
  long float_types[16];
  /* Pointers to types, indexed by the type index.  */
  long *pointer_types;
  size_t pointer_types_alloc;
  /* Functions returning types, indexed by the type index.  */
  long *function_types;
  size_t function_types_alloc;
  /* References to types, indexed by the type index.  */
  long *reference_types;
  size_t reference_types_alloc;
  /* Struct/union/class type indices, indexed by the struct id.  */
  struct stab_tag *struct_types;
  size_t struct_types_alloc;
};

/* This is the handle passed through debug_write.  */

struct stab_write_handle
{
  /* The BFD.  */
  bfd *abfd;
  /* This buffer holds the symbols.  */
  bfd_byte *symbols;
  size_t symbols_size;
  size_t symbols_alloc;
  /* This is a list of hash table entries for the strings.  */
  struct string_hash_entry *strings;
  /* The last string hash table entry.  */
  struct string_hash_entry *last_string;
  /* The size of the strings.  */
  size_t strings_size;
  /* This hash table eliminates duplicate strings.  */
  struct string_hash_table strhash;
  /* The type stack.  */
  struct stab_type_stack *type_stack;
  /* The next type index.  */
  long type_index;
  /* The type cache.  */
  struct stab_type_cache type_cache;
  /* A mapping from typedef names to type indices.  */
  struct string_hash_table typedef_hash;
  /* If this is not -1, it is the offset to the most recent N_SO
     symbol, and the value of that symbol needs to be set.  */
  long so_offset;
  /* If this is not -1, it is the offset to the most recent N_FUN
     symbol, and the value of that symbol needs to be set.  */
  long fun_offset;
  /* The last text section address seen.  */
  bfd_vma last_text_address;
  /* The block nesting depth.  */
  unsigned int nesting;
  /* The function address.  */
  bfd_vma fnaddr;
  /* A pending LBRAC symbol.  */
  bfd_vma pending_lbrac;
  /* The current line number file name.  */
  const char *lineno_filename;
};

static struct bfd_hash_entry *string_hash_newfunc
  (struct bfd_hash_entry *, struct bfd_hash_table *, const char *);
static bfd_boolean stab_write_symbol
  (struct stab_write_handle *, int, int, bfd_vma, const char *);
static bfd_boolean stab_push_string
  (struct stab_write_handle *, const char *, long, bfd_boolean, unsigned int);
static bfd_boolean stab_push_defined_type
  (struct stab_write_handle *, long, unsigned int);
static char *stab_pop_type (struct stab_write_handle *);
static bfd_boolean stab_modify_type
  (struct stab_write_handle *, int, unsigned int, long **, size_t *);
static long stab_get_struct_index
  (struct stab_write_handle *, const char *, unsigned int,
   enum debug_type_kind, unsigned int *);
static bfd_boolean stab_class_method_var
  (struct stab_write_handle *, const char *, enum debug_visibility,
   bfd_boolean, bfd_boolean, bfd_boolean, bfd_vma, bfd_boolean);
static bfd_boolean stab_start_compilation_unit (void *, const char *);
static bfd_boolean stab_start_source (void *, const char *);
static bfd_boolean stab_empty_type (void *);
static bfd_boolean stab_void_type (void *);
static bfd_boolean stab_int_type (void *, unsigned int, bfd_boolean);
static bfd_boolean stab_float_type (void *, unsigned int);
static bfd_boolean stab_complex_type (void *, unsigned int);
static bfd_boolean stab_bool_type (void *, unsigned int);
static bfd_boolean stab_enum_type
  (void *, const char *, const char **, bfd_signed_vma *);
static bfd_boolean stab_pointer_type (void *);
static bfd_boolean stab_function_type (void *, int, bfd_boolean);
static bfd_boolean stab_reference_type (void *);
static bfd_boolean stab_range_type (void *, bfd_signed_vma, bfd_signed_vma);
static bfd_boolean stab_array_type
  (void *, bfd_signed_vma, bfd_signed_vma, bfd_boolean);
static bfd_boolean stab_set_type (void *, bfd_boolean);
static bfd_boolean stab_offset_type (void *);
static bfd_boolean stab_method_type (void *, bfd_boolean, int, bfd_boolean);
static bfd_boolean stab_const_type (void *);
static bfd_boolean stab_volatile_type (void *);
static bfd_boolean stab_start_struct_type
  (void *, const char *, unsigned int, bfd_boolean, unsigned int);
static bfd_boolean stab_struct_field
  (void *, const char *, bfd_vma, bfd_vma, enum debug_visibility);
static bfd_boolean stab_end_struct_type (void *);
static bfd_boolean stab_start_class_type
  (void *, const char *, unsigned int, bfd_boolean, unsigned int,
   bfd_boolean, bfd_boolean);
static bfd_boolean stab_class_static_member
  (void *, const char *, const char *, enum debug_visibility);
static bfd_boolean stab_class_baseclass
  (void *, bfd_vma, bfd_boolean, enum debug_visibility);
static bfd_boolean stab_class_start_method (void *, const char *);
static bfd_boolean stab_class_method_variant
  (void *, const char *, enum debug_visibility, bfd_boolean, bfd_boolean,
   bfd_vma, bfd_boolean);
static bfd_boolean stab_class_static_method_variant
  (void *, const char *, enum debug_visibility, bfd_boolean, bfd_boolean);
static bfd_boolean stab_class_end_method (void *);
static bfd_boolean stab_end_class_type (void *);
static bfd_boolean stab_typedef_type (void *, const char *);
static bfd_boolean stab_tag_type
  (void *, const char *, unsigned int, enum debug_type_kind);
static bfd_boolean stab_typdef (void *, const char *);
static bfd_boolean stab_tag (void *, const char *);
static bfd_boolean stab_int_constant (void *, const char *, bfd_vma);
static bfd_boolean stab_float_constant (void *, const char *, double);
static bfd_boolean stab_typed_constant (void *, const char *, bfd_vma);
static bfd_boolean stab_variable
  (void *, const char *, enum debug_var_kind, bfd_vma);
static bfd_boolean stab_start_function (void *, const char *, bfd_boolean);
static bfd_boolean stab_function_parameter
  (void *, const char *, enum debug_parm_kind, bfd_vma);
static bfd_boolean stab_start_block (void *, bfd_vma);
static bfd_boolean stab_end_block (void *, bfd_vma);
static bfd_boolean stab_end_function (void *);
static bfd_boolean stab_lineno (void *, const char *, unsigned long, bfd_vma);

static const struct debug_write_fns stab_fns =
{
  stab_start_compilation_unit,
  stab_start_source,
  stab_empty_type,
  stab_void_type,
  stab_int_type,
  stab_float_type,
  stab_complex_type,
  stab_bool_type,
  stab_enum_type,
  stab_pointer_type,
  stab_function_type,
  stab_reference_type,
  stab_range_type,
  stab_array_type,
  stab_set_type,
  stab_offset_type,
  stab_method_type,
  stab_const_type,
  stab_volatile_type,
  stab_start_struct_type,
  stab_struct_field,
  stab_end_struct_type,
  stab_start_class_type,
  stab_class_static_member,
  stab_class_baseclass,
  stab_class_start_method,
  stab_class_method_variant,
  stab_class_static_method_variant,
  stab_class_end_method,
  stab_end_class_type,
  stab_typedef_type,
  stab_tag_type,
  stab_typdef,
  stab_tag,
  stab_int_constant,
  stab_float_constant,
  stab_typed_constant,
  stab_variable,
  stab_start_function,
  stab_function_parameter,
  stab_start_block,
  stab_end_block,
  stab_end_function,
  stab_lineno
};

/* Routine to create an entry in a string hash table.  */

static struct bfd_hash_entry *
string_hash_newfunc (struct bfd_hash_entry *entry,
		     struct bfd_hash_table *table, const char *string)
{
  struct string_hash_entry *ret = (struct string_hash_entry *) entry;

  /* Allocate the structure if it has not already been allocated by a
     subclass.  */
  if (ret == (struct string_hash_entry *) NULL)
    ret = ((struct string_hash_entry *)
	   bfd_hash_allocate (table, sizeof (struct string_hash_entry)));
  if (ret == (struct string_hash_entry *) NULL)
    return NULL;

  /* Call the allocation method of the superclass.  */
  ret = ((struct string_hash_entry *)
	 bfd_hash_newfunc ((struct bfd_hash_entry *) ret, table, string));

  if (ret)
    {
      /* Initialize the local fields.  */
      ret->next = NULL;
      ret->index = -1;
      ret->size = 0;
    }

  return (struct bfd_hash_entry *) ret;
}

/* Look up an entry in a string hash table.  */

#define string_hash_lookup(t, string, create, copy) \
  ((struct string_hash_entry *) \
   bfd_hash_lookup (&(t)->table, (string), (create), (copy)))

/* Add a symbol to the stabs debugging information we are building.  */

static bfd_boolean
stab_write_symbol (struct stab_write_handle *info, int type, int desc,
		   bfd_vma value, const char *string)
{
  bfd_size_type strx;
  bfd_byte sym[STAB_SYMBOL_SIZE];

  if (string == NULL)
    strx = 0;
  else
    {
      struct string_hash_entry *h;

      h = string_hash_lookup (&info->strhash, string, TRUE, TRUE);
      if (h == NULL)
	{
	  non_fatal (_("string_hash_lookup failed: %s"),
		     bfd_errmsg (bfd_get_error ()));
	  return FALSE;
	}
      if (h->index != -1)
	strx = h->index;
      else
	{
	  strx = info->strings_size;
	  h->index = strx;
	  if (info->last_string == NULL)
	    info->strings = h;
	  else
	    info->last_string->next = h;
	  info->last_string = h;
	  info->strings_size += strlen (string) + 1;
	}
    }

  /* This presumes 32 bit values.  */
  bfd_put_32 (info->abfd, strx, sym);
  bfd_put_8 (info->abfd, type, sym + 4);
  bfd_put_8 (info->abfd, 0, sym + 5);
  bfd_put_16 (info->abfd, desc, sym + 6);
  bfd_put_32 (info->abfd, value, sym + 8);

  if (info->symbols_size + STAB_SYMBOL_SIZE > info->symbols_alloc)
    {
      info->symbols_alloc *= 2;
      info->symbols = (bfd_byte *) xrealloc (info->symbols,
					     info->symbols_alloc);
    }

  memcpy (info->symbols + info->symbols_size, sym, STAB_SYMBOL_SIZE);

  info->symbols_size += STAB_SYMBOL_SIZE;

  return TRUE;
}

/* Push a string on to the type stack.  */

static bfd_boolean
stab_push_string (struct stab_write_handle *info, const char *string,
		  long tindex, bfd_boolean definition, unsigned int size)
{
  struct stab_type_stack *s;

  s = (struct stab_type_stack *) xmalloc (sizeof *s);
  s->string = xstrdup (string);
  s->index = tindex;
  s->definition = definition;
  s->size = size;

  s->fields = NULL;
  s->baseclasses = NULL;
  s->methods = NULL;
  s->vtable = NULL;

  s->next = info->type_stack;
  info->type_stack = s;

  return TRUE;
}

/* Push a type index which has already been defined.  */

static bfd_boolean
stab_push_defined_type (struct stab_write_handle *info, long tindex,
			unsigned int size)
{
  char buf[20];

  sprintf (buf, "%ld", tindex);
  return stab_push_string (info, buf, tindex, FALSE, size);
}

/* Pop a type off the type stack.  The caller is responsible for
   freeing the string.  */

static char *
stab_pop_type (struct stab_write_handle *info)
{
  struct stab_type_stack *s;
  char *ret;

  s = info->type_stack;
  assert (s != NULL);

  info->type_stack = s->next;

  ret = s->string;

  free (s);

  return ret;
}

/* The general routine to write out stabs in sections debugging
   information.  This accumulates the stabs symbols and the strings in
   two obstacks.  We can't easily write out the information as we go
   along, because we need to know the section sizes before we can
   write out the section contents.  ABFD is the BFD and DHANDLE is the
   handle for the debugging information.  This sets *PSYMS to point to
   the symbols, *PSYMSIZE the size of the symbols, *PSTRINGS to the
   strings, and *PSTRINGSIZE to the size of the strings.  */

bfd_boolean
write_stabs_in_sections_debugging_info (bfd *abfd, void *dhandle,
					bfd_byte **psyms,
					bfd_size_type *psymsize,
					bfd_byte **pstrings,
					bfd_size_type *pstringsize)
{
  struct stab_write_handle info;
  struct string_hash_entry *h;
  bfd_byte *p;

  info.abfd = abfd;

  info.symbols_size = 0;
  info.symbols_alloc = 500;
  info.symbols = (bfd_byte *) xmalloc (info.symbols_alloc);

  info.strings = NULL;
  info.last_string = NULL;
  /* Reserve 1 byte for a null byte.  */
  info.strings_size = 1;

  if (!bfd_hash_table_init (&info.strhash.table, string_hash_newfunc,
			    sizeof (struct string_hash_entry))
      || !bfd_hash_table_init (&info.typedef_hash.table, string_hash_newfunc,
			       sizeof (struct string_hash_entry)))
    {
      non_fatal ("bfd_hash_table_init_failed: %s",
		 bfd_errmsg (bfd_get_error ()));
      return FALSE;
    }

  info.type_stack = NULL;
  info.type_index = 1;
  memset (&info.type_cache, 0, sizeof info.type_cache);
  info.so_offset = -1;
  info.fun_offset = -1;
  info.last_text_address = 0;
  info.nesting = 0;
  info.fnaddr = 0;
  info.pending_lbrac = (bfd_vma) -1;

  /* The initial symbol holds the string size.  */
  if (! stab_write_symbol (&info, 0, 0, 0, (const char *) NULL))
    return FALSE;

  /* Output an initial N_SO symbol.  */
  info.so_offset = info.symbols_size;
  if (! stab_write_symbol (&info, N_SO, 0, 0, bfd_get_filename (abfd)))
    return FALSE;

  if (! debug_write (dhandle, &stab_fns, (void *) &info))
    return FALSE;

  assert (info.pending_lbrac == (bfd_vma) -1);

  /* Output a trailing N_SO.  */
  if (! stab_write_symbol (&info, N_SO, 0, info.last_text_address,
			   (const char *) NULL))
    return FALSE;

  /* Put the string size in the initial symbol.  */
  bfd_put_32 (abfd, info.strings_size, info.symbols + 8);

  *psyms = info.symbols;
  *psymsize = info.symbols_size;

  *pstringsize = info.strings_size;
  *pstrings = (bfd_byte *) xmalloc (info.strings_size);

  p = *pstrings;
  *p++ = '\0';
  for (h = info.strings; h != NULL; h = h->next)
    {
      strcpy ((char *) p, h->root.string);
      p += strlen ((char *) p) + 1;
    }

  return TRUE;
}

/* Start writing out information for a compilation unit.  */

static bfd_boolean
stab_start_compilation_unit (void *p, const char *filename)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;

  /* We would normally output an N_SO symbol here.  However, that
     would force us to reset all of our type information.  I think we
     will be better off just outputting an N_SOL symbol, and not
     worrying about splitting information between files.  */

  info->lineno_filename = filename;

  return stab_write_symbol (info, N_SOL, 0, 0, filename);
}

/* Start writing out information for a particular source file.  */

static bfd_boolean
stab_start_source (void *p, const char *filename)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;

  /* FIXME: The symbol's value is supposed to be the text section
     address.  However, we would have to fill it in later, and gdb
     doesn't care, so we don't bother with it.  */

  info->lineno_filename = filename;

  return stab_write_symbol (info, N_SOL, 0, 0, filename);
}

/* Push an empty type.  This shouldn't normally happen.  We just use a
   void type.  */

static bfd_boolean
stab_empty_type (void *p)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;

  /* We don't call stab_void_type if the type is not yet defined,
     because that might screw up the typedef.  */

  if (info->type_cache.void_type != 0)
    return stab_push_defined_type (info, info->type_cache.void_type, 0);
  else
    {
      long tindex;
      char buf[40];

      tindex = info->type_index;
      ++info->type_index;

      sprintf (buf, "%ld=%ld", tindex, tindex);

      return stab_push_string (info, buf, tindex, FALSE, 0);
    }
}

/* Push a void type.  */

static bfd_boolean
stab_void_type (void *p)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;

  if (info->type_cache.void_type != 0)
    return stab_push_defined_type (info, info->type_cache.void_type, 0);
  else
    {
      long tindex;
      char buf[40];

      tindex = info->type_index;
      ++info->type_index;

      info->type_cache.void_type = tindex;

      sprintf (buf, "%ld=%ld", tindex, tindex);

      return stab_push_string (info, buf, tindex, TRUE, 0);
    }
}

/* Push an integer type.  */

static bfd_boolean
stab_int_type (void *p, unsigned int size, bfd_boolean unsignedp)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  long *cache;

  if (size <= 0 || (size > sizeof (long) && size != 8))
    {
      non_fatal (_("stab_int_type: bad size %u"), size);
      return FALSE;
    }

  if (unsignedp)
    cache = info->type_cache.signed_integer_types;
  else
    cache = info->type_cache.unsigned_integer_types;

  if (cache[size - 1] != 0)
    return stab_push_defined_type (info, cache[size - 1], size);
  else
    {
      long tindex;
      char buf[100];

      tindex = info->type_index;
      ++info->type_index;

      cache[size - 1] = tindex;

      sprintf (buf, "%ld=r%ld;", tindex, tindex);
      if (unsignedp)
	{
	  strcat (buf, "0;");
	  if (size < sizeof (long))
	    sprintf (buf + strlen (buf), "%ld;", ((long) 1 << (size * 8)) - 1);
	  else if (size == sizeof (long))
	    strcat (buf, "-1;");
	  else if (size == 8)
	    strcat (buf, "01777777777777777777777;");
	  else
	    abort ();
	}
      else
	{
	  if (size <= sizeof (long))
	    sprintf (buf + strlen (buf), "%ld;%ld;",
		     (long) - ((unsigned long) 1 << (size * 8 - 1)),
		     (long) (((unsigned long) 1 << (size * 8 - 1)) - 1));
	  else if (size == 8)
	    strcat (buf, "01000000000000000000000;0777777777777777777777;");
	  else
	    abort ();
	}

      return stab_push_string (info, buf, tindex, TRUE, size);
    }
}

/* Push a floating point type.  */

static bfd_boolean
stab_float_type (void *p, unsigned int size)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;

  if (size > 0
      && size - 1 < (sizeof info->type_cache.float_types
		     / sizeof info->type_cache.float_types[0])
      && info->type_cache.float_types[size - 1] != 0)
    return stab_push_defined_type (info,
				   info->type_cache.float_types[size - 1],
				   size);
  else
    {
      long tindex;
      char *int_type;
      char buf[50];

      /* Floats are defined as a subrange of int.  */
      if (! stab_int_type (info, 4, FALSE))
	return FALSE;
      int_type = stab_pop_type (info);

      tindex = info->type_index;
      ++info->type_index;

      if (size > 0
	  && size - 1 < (sizeof info->type_cache.float_types
			 / sizeof info->type_cache.float_types[0]))
	info->type_cache.float_types[size - 1] = tindex;

      sprintf (buf, "%ld=r%s;%u;0;", tindex, int_type, size);

      free (int_type);

      return stab_push_string (info, buf, tindex, TRUE, size);
    }
}

/* Push a complex type.  */

static bfd_boolean
stab_complex_type (void *p, unsigned int size)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  char buf[50];
  long tindex;

  tindex = info->type_index;
  ++info->type_index;

  sprintf (buf, "%ld=r%ld;%u;0;", tindex, tindex, size);

  return stab_push_string (info, buf, tindex, TRUE, size * 2);
}

/* Push a bfd_boolean type.  We use an XCOFF predefined type, since gdb
   always recognizes them.  */

static bfd_boolean
stab_bool_type (void *p, unsigned int size)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  long tindex;

  switch (size)
    {
    case 1:
      tindex = -21;
      break;

    case 2:
      tindex = -22;
      break;

    default:
    case 4:
      tindex = -16;
      break;

    case 8:
      tindex = -33;
      break;
    }

  return stab_push_defined_type (info, tindex, size);
}

/* Push an enum type.  */

static bfd_boolean
stab_enum_type (void *p, const char *tag, const char **names,
		bfd_signed_vma *vals)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  size_t len;
  const char **pn;
  char *buf;
  long tindex = 0;
  bfd_signed_vma *pv;

  if (names == NULL)
    {
      assert (tag != NULL);

      buf = (char *) xmalloc (10 + strlen (tag));
      sprintf (buf, "xe%s:", tag);
      /* FIXME: The size is just a guess.  */
      if (! stab_push_string (info, buf, 0, FALSE, 4))
	return FALSE;
      free (buf);
      return TRUE;
    }

  len = 10;
  if (tag != NULL)
    len += strlen (tag);
  for (pn = names; *pn != NULL; pn++)
    len += strlen (*pn) + 20;

  buf = (char *) xmalloc (len);

  if (tag == NULL)
    strcpy (buf, "e");
  else
    {
      tindex = info->type_index;
      ++info->type_index;
      sprintf (buf, "%s:T%ld=e", tag, tindex);
    }

  for (pn = names, pv = vals; *pn != NULL; pn++, pv++)
    sprintf (buf + strlen (buf), "%s:%ld,", *pn, (long) *pv);
  strcat (buf, ";");

  if (tag == NULL)
    {
      /* FIXME: The size is just a guess.  */
      if (! stab_push_string (info, buf, 0, FALSE, 4))
	return FALSE;
    }
  else
    {
      /* FIXME: The size is just a guess.  */
      if (! stab_write_symbol (info, N_LSYM, 0, 0, buf)
	  || ! stab_push_defined_type (info, tindex, 4))
	return FALSE;
    }

  free (buf);

  return TRUE;
}

/* Push a modification of the top type on the stack.  Cache the
   results in CACHE and CACHE_ALLOC.  */

static bfd_boolean
stab_modify_type (struct stab_write_handle *info, int mod,
		  unsigned int size, long **cache, size_t *cache_alloc)
{
  long targindex;
  long tindex;
  char *s, *buf;

  assert (info->type_stack != NULL);
  targindex = info->type_stack->index;

  if (targindex <= 0
      || cache == NULL)
    {
      bfd_boolean definition;

      /* Either the target type has no index, or we aren't caching
         this modifier.  Either way we have no way of recording the
         new type, so we don't bother to define one.  */
      definition = info->type_stack->definition;
      s = stab_pop_type (info);
      buf = (char *) xmalloc (strlen (s) + 2);
      sprintf (buf, "%c%s", mod, s);
      free (s);
      if (! stab_push_string (info, buf, 0, definition, size))
	return FALSE;
      free (buf);
    }
  else
    {
      if ((size_t) targindex >= *cache_alloc)
	{
	  size_t alloc;

	  alloc = *cache_alloc;
	  if (alloc == 0)
	    alloc = 10;
	  while ((size_t) targindex >= alloc)
	    alloc *= 2;
	  *cache = (long *) xrealloc (*cache, alloc * sizeof (long));
	  memset (*cache + *cache_alloc, 0,
		  (alloc - *cache_alloc) * sizeof (long));
	  *cache_alloc = alloc;
	}

      tindex = (*cache)[targindex];
      if (tindex != 0 && ! info->type_stack->definition)
	{
	  /* We have already defined a modification of this type, and
             the entry on the type stack is not a definition, so we
             can safely discard it (we may have a definition on the
             stack, even if we already defined a modification, if it
             is a struct which we did not define at the time it was
             referenced).  */
	  free (stab_pop_type (info));
	  if (! stab_push_defined_type (info, tindex, size))
	    return FALSE;
	}
      else
	{
	  tindex = info->type_index;
	  ++info->type_index;

	  s = stab_pop_type (info);
	  buf = (char *) xmalloc (strlen (s) + 20);
	  sprintf (buf, "%ld=%c%s", tindex, mod, s);
	  free (s);

	  (*cache)[targindex] = tindex;

	  if (! stab_push_string (info, buf, tindex, TRUE, size))
	    return FALSE;

	  free (buf);
	}
    }

  return TRUE;
}

/* Push a pointer type.  */

static bfd_boolean
stab_pointer_type (void *p)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;

  /* FIXME: The size should depend upon the architecture.  */
  return stab_modify_type (info, '*', 4, &info->type_cache.pointer_types,
			   &info->type_cache.pointer_types_alloc);
}

/* Push a function type.  */

static bfd_boolean
stab_function_type (void *p, int argcount,
		    bfd_boolean varargs ATTRIBUTE_UNUSED)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  int i;

  /* We have no way to represent the argument types, so we just
     discard them.  However, if they define new types, we must output
     them.  We do this by producing empty typedefs.  */
  for (i = 0; i < argcount; i++)
    {
      if (! info->type_stack->definition)
	free (stab_pop_type (info));
      else
	{
	  char *s, *buf;

	  s = stab_pop_type (info);

	  buf = (char *) xmalloc (strlen (s) + 3);
	  sprintf (buf, ":t%s", s);
	  free (s);

	  if (! stab_write_symbol (info, N_LSYM, 0, 0, buf))
	    return FALSE;

	  free (buf);
	}
    }

  return stab_modify_type (info, 'f', 0, &info->type_cache.function_types,
			   &info->type_cache.function_types_alloc);
}

/* Push a reference type.  */

static bfd_boolean
stab_reference_type (void *p)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;

  /* FIXME: The size should depend upon the architecture.  */
  return stab_modify_type (info, '&', 4, &info->type_cache.reference_types,
			   &info->type_cache.reference_types_alloc);
}

/* Push a range type.  */

static bfd_boolean
stab_range_type (void *p, bfd_signed_vma low, bfd_signed_vma high)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  bfd_boolean definition;
  unsigned int size;
  char *s, *buf;

  definition = info->type_stack->definition;
  size = info->type_stack->size;

  s = stab_pop_type (info);
  buf = (char *) xmalloc (strlen (s) + 100);
  sprintf (buf, "r%s;%ld;%ld;", s, (long) low, (long) high);
  free (s);

  if (! stab_push_string (info, buf, 0, definition, size))
    return FALSE;

  free (buf);

  return TRUE;
}

/* Push an array type.  */

static bfd_boolean
stab_array_type (void *p, bfd_signed_vma low, bfd_signed_vma high,
		 bfd_boolean stringp)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  bfd_boolean definition;
  unsigned int element_size;
  char *range, *element, *buf;
  long tindex;
  unsigned int size;

  definition = info->type_stack->definition;
  range = stab_pop_type (info);

  definition = definition || info->type_stack->definition;
  element_size = info->type_stack->size;
  element = stab_pop_type (info);

  buf = (char *) xmalloc (strlen (range) + strlen (element) + 100);

  if (! stringp)
    {
      tindex = 0;
      *buf = '\0';
    }
  else
    {
      /* We need to define a type in order to include the string
         attribute.  */
      tindex = info->type_index;
      ++info->type_index;
      definition = TRUE;
      sprintf (buf, "%ld=@@S;", tindex);
    }

  sprintf (buf + strlen (buf), "ar%s;%ld;%ld;%s",
	   range, (long) low, (long) high, element);
  free (range);
  free (element);

  if (high < low)
    size = 0;
  else
    size = element_size * ((high - low) + 1);
  if (! stab_push_string (info, buf, tindex, definition, size))
    return FALSE;

  free (buf);

  return TRUE;
}

/* Push a set type.  */

static bfd_boolean
stab_set_type (void *p, bfd_boolean bitstringp)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  bfd_boolean definition;
  char *s, *buf;
  long tindex;

  definition = info->type_stack->definition;

  s = stab_pop_type (info);
  buf = (char *) xmalloc (strlen (s) + 30);

  if (! bitstringp)
    {
      *buf = '\0';
      tindex = 0;
    }
  else
    {
      /* We need to define a type in order to include the string
         attribute.  */
      tindex = info->type_index;
      ++info->type_index;
      definition = TRUE;
      sprintf (buf, "%ld=@@S;", tindex);
    }

  sprintf (buf + strlen (buf), "S%s", s);
  free (s);

  if (! stab_push_string (info, buf, tindex, definition, 0))
    return FALSE;

  free (buf);

  return TRUE;
}

/* Push an offset type.  */

static bfd_boolean
stab_offset_type (void *p)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  bfd_boolean definition;
  char *target, *base, *buf;

  definition = info->type_stack->definition;
  target = stab_pop_type (info);

  definition = definition || info->type_stack->definition;
  base = stab_pop_type (info);

  buf = (char *) xmalloc (strlen (target) + strlen (base) + 3);
  sprintf (buf, "@@%s,%s", base, target);
  free (base);
  free (target);

  if (! stab_push_string (info, buf, 0, definition, 0))
    return FALSE;

  free (buf);

  return TRUE;
}

/* Push a method type.  */

static bfd_boolean
stab_method_type (void *p, bfd_boolean domainp, int argcount,
		  bfd_boolean varargs)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  bfd_boolean definition;
  char *domain, *return_type, *buf;
  char **args;
  int i;
  size_t len;

  /* We don't bother with stub method types, because that would
     require a mangler for C++ argument types.  This will waste space
     in the debugging output.  */

  /* We need a domain.  I'm not sure DOMAINP can ever be false,
     anyhow.  */
  if (! domainp)
    {
      if (! stab_empty_type (p))
	return FALSE;
    }

  definition = info->type_stack->definition;
  domain = stab_pop_type (info);

  /* A non-varargs function is indicated by making the last parameter
     type be void.  */

  if (argcount < 0)
    {
      args = NULL;
      argcount = 0;
    }
  else if (argcount == 0)
    {
      if (varargs)
	args = NULL;
      else
	{
	  args = (char **) xmalloc (1 * sizeof (*args));
	  if (! stab_empty_type (p))
	    return FALSE;
	  definition = definition || info->type_stack->definition;
	  args[0] = stab_pop_type (info);
	  argcount = 1;
	}
    }
  else
    {
      args = (char **) xmalloc ((argcount + 1) * sizeof (*args));
      for (i = argcount - 1; i >= 0; i--)
	{
	  definition = definition || info->type_stack->definition;
	  args[i] = stab_pop_type (info);
	}
      if (! varargs)
	{
	  if (! stab_empty_type (p))
	    return FALSE;
	  definition = definition || info->type_stack->definition;
	  args[argcount] = stab_pop_type (info);
	  ++argcount;
	}
    }

  definition = definition || info->type_stack->definition;
  return_type = stab_pop_type (info);

  len = strlen (domain) + strlen (return_type) + 10;
  for (i = 0; i < argcount; i++)
    len += strlen (args[i]);

  buf = (char *) xmalloc (len);

  sprintf (buf, "#%s,%s", domain, return_type);
  free (domain);
  free (return_type);
  for (i = 0; i < argcount; i++)
    {
      strcat (buf, ",");
      strcat (buf, args[i]);
      free (args[i]);
    }
  strcat (buf, ";");

  if (args != NULL)
    free (args);

  if (! stab_push_string (info, buf, 0, definition, 0))
    return FALSE;

  free (buf);

  return TRUE;
}

/* Push a const version of a type.  */

static bfd_boolean
stab_const_type (void *p)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;

  return stab_modify_type (info, 'k', info->type_stack->size,
			   (long **) NULL, (size_t *) NULL);
}

/* Push a volatile version of a type.  */

static bfd_boolean
stab_volatile_type (void *p)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;

  return stab_modify_type (info, 'B', info->type_stack->size,
			   (long **) NULL, (size_t *) NULL);
}

/* Get the type index to use for a struct/union/class ID.  This should
   return -1 if it fails.  */

static long
stab_get_struct_index (struct stab_write_handle *info, const char *tag,
		       unsigned int id, enum debug_type_kind kind,
		       unsigned int *psize)
{
  if (id >= info->type_cache.struct_types_alloc)
    {
      size_t alloc;

      alloc = info->type_cache.struct_types_alloc;
      if (alloc == 0)
	alloc = 10;
      while (id >= alloc)
	alloc *= 2;
      info->type_cache.struct_types =
	(struct stab_tag *) xrealloc (info->type_cache.struct_types,
				      alloc * sizeof (struct stab_tag));
      memset ((info->type_cache.struct_types
	       + info->type_cache.struct_types_alloc),
	      0,
	      ((alloc - info->type_cache.struct_types_alloc)
	       * sizeof (struct stab_tag)));
      info->type_cache.struct_types_alloc = alloc;
    }

  if (info->type_cache.struct_types[id].index == 0)
    {
      info->type_cache.struct_types[id].index = info->type_index;
      ++info->type_index;
      info->type_cache.struct_types[id].tag = tag;
      info->type_cache.struct_types[id].kind = kind;
    }

  if (kind == DEBUG_KIND_ILLEGAL)
    {
      /* This is a definition of the struct.  */
      info->type_cache.struct_types[id].kind = kind;
      info->type_cache.struct_types[id].size = *psize;
    }
  else
    *psize = info->type_cache.struct_types[id].size;

  return info->type_cache.struct_types[id].index;
}

/* Start outputting a struct.  We ignore the tag, and handle it in
   stab_tag.  */

static bfd_boolean
stab_start_struct_type (void *p, const char *tag, unsigned int id,
			bfd_boolean structp, unsigned int size)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  long tindex;
  bfd_boolean definition;
  char buf[40];

  if (id == 0)
    {
      tindex = 0;
      *buf = '\0';
      definition = FALSE;
    }
  else
    {
      tindex = stab_get_struct_index (info, tag, id, DEBUG_KIND_ILLEGAL,
				     &size);
      if (tindex < 0)
	return FALSE;
      sprintf (buf, "%ld=", tindex);
      definition = TRUE;
    }

  sprintf (buf + strlen (buf), "%c%u",
	   structp ? 's' : 'u',
	   size);

  if (! stab_push_string (info, buf, tindex, definition, size))
    return FALSE;

  info->type_stack->fields = (char *) xmalloc (1);
  info->type_stack->fields[0] = '\0';

  return TRUE;
}

/* Add a field to a struct.  */

static bfd_boolean
stab_struct_field (void *p, const char *name, bfd_vma bitpos,
		   bfd_vma bitsize, enum debug_visibility visibility)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  bfd_boolean definition;
  unsigned int size;
  char *s, *n;
  const char *vis;

  definition = info->type_stack->definition;
  size = info->type_stack->size;
  s = stab_pop_type (info);

  /* Add this field to the end of the current struct fields, which is
     currently on the top of the stack.  */

  assert (info->type_stack->fields != NULL);
  n = (char *) xmalloc (strlen (info->type_stack->fields)
			+ strlen (name)
			+ strlen (s)
			+ 50);

  switch (visibility)
    {
    default:
      abort ();

    case DEBUG_VISIBILITY_PUBLIC:
      vis = "";
      break;

    case DEBUG_VISIBILITY_PRIVATE:
      vis = "/0";
      break;

    case DEBUG_VISIBILITY_PROTECTED:
      vis = "/1";
      break;
    }

  if (bitsize == 0)
    {
      bitsize = size * 8;
      if (bitsize == 0)
	non_fatal (_("%s: warning: unknown size for field `%s' in struct"),
		   bfd_get_filename (info->abfd), name);
    }

  sprintf (n, "%s%s:%s%s,%ld,%ld;", info->type_stack->fields, name, vis, s,
	   (long) bitpos, (long) bitsize);

  free (info->type_stack->fields);
  info->type_stack->fields = n;

  if (definition)
    info->type_stack->definition = TRUE;

  return TRUE;
}

/* Finish up a struct.  */

static bfd_boolean
stab_end_struct_type (void *p)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  bfd_boolean definition;
  long tindex;
  unsigned int size;
  char *fields, *first, *buf;

  assert (info->type_stack != NULL && info->type_stack->fields != NULL);

  definition = info->type_stack->definition;
  tindex = info->type_stack->index;
  size = info->type_stack->size;
  fields = info->type_stack->fields;
  first = stab_pop_type (info);

  buf = (char *) xmalloc (strlen (first) + strlen (fields) + 2);
  sprintf (buf, "%s%s;", first, fields);
  free (first);
  free (fields);

  if (! stab_push_string (info, buf, tindex, definition, size))
    return FALSE;

  free (buf);

  return TRUE;
}

/* Start outputting a class.  */

static bfd_boolean
stab_start_class_type (void *p, const char *tag, unsigned int id, bfd_boolean structp, unsigned int size, bfd_boolean vptr, bfd_boolean ownvptr)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  bfd_boolean definition;
  char *vstring;

  if (! vptr || ownvptr)
    {
      definition = FALSE;
      vstring = NULL;
    }
  else
    {
      definition = info->type_stack->definition;
      vstring = stab_pop_type (info);
    }

  if (! stab_start_struct_type (p, tag, id, structp, size))
    return FALSE;

  if (vptr)
    {
      char *vtable;

      if (ownvptr)
	{
	  assert (info->type_stack->index > 0);
	  vtable = (char *) xmalloc (20);
	  sprintf (vtable, "~%%%ld", info->type_stack->index);
	}
      else
	{
	  vtable = (char *) xmalloc (strlen (vstring) + 3);
	  sprintf (vtable, "~%%%s", vstring);
	  free (vstring);
	}

      info->type_stack->vtable = vtable;
    }

  if (definition)
    info->type_stack->definition = TRUE;

  return TRUE;
}

/* Add a static member to the class on the type stack.  */

static bfd_boolean
stab_class_static_member (void *p, const char *name, const char *physname,
			  enum debug_visibility visibility)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  bfd_boolean definition;
  char *s, *n;
  const char *vis;

  definition = info->type_stack->definition;
  s = stab_pop_type (info);

  /* Add this field to the end of the current struct fields, which is
     currently on the top of the stack.  */

  assert (info->type_stack->fields != NULL);
  n = (char *) xmalloc (strlen (info->type_stack->fields)
			+ strlen (name)
			+ strlen (s)
			+ strlen (physname)
			+ 10);

  switch (visibility)
    {
    default:
      abort ();

    case DEBUG_VISIBILITY_PUBLIC:
      vis = "";
      break;

    case DEBUG_VISIBILITY_PRIVATE:
      vis = "/0";
      break;

    case DEBUG_VISIBILITY_PROTECTED:
      vis = "/1";
      break;
    }

  sprintf (n, "%s%s:%s%s:%s;", info->type_stack->fields, name, vis, s,
	   physname);

  free (info->type_stack->fields);
  info->type_stack->fields = n;

  if (definition)
    info->type_stack->definition = TRUE;

  return TRUE;
}

/* Add a base class to the class on the type stack.  */

static bfd_boolean
stab_class_baseclass (void *p, bfd_vma bitpos, bfd_boolean is_virtual,
		      enum debug_visibility visibility)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  bfd_boolean definition;
  char *s;
  char *buf;
  unsigned int c;
  char **baseclasses;

  definition = info->type_stack->definition;
  s = stab_pop_type (info);

  /* Build the base class specifier.  */

  buf = (char *) xmalloc (strlen (s) + 25);
  buf[0] = is_virtual ? '1' : '0';
  switch (visibility)
    {
    default:
      abort ();

    case DEBUG_VISIBILITY_PRIVATE:
      buf[1] = '0';
      break;

    case DEBUG_VISIBILITY_PROTECTED:
      buf[1] = '1';
      break;

    case DEBUG_VISIBILITY_PUBLIC:
      buf[1] = '2';
      break;
    }

  sprintf (buf + 2, "%ld,%s;", (long) bitpos, s);
  free (s);

  /* Add the new baseclass to the existing ones.  */

  assert (info->type_stack != NULL && info->type_stack->fields != NULL);

  if (info->type_stack->baseclasses == NULL)
    c = 0;
  else
    {
      c = 0;
      while (info->type_stack->baseclasses[c] != NULL)
	++c;
    }

  baseclasses = (char **) xrealloc (info->type_stack->baseclasses,
				    (c + 2) * sizeof (*baseclasses));
  baseclasses[c] = buf;
  baseclasses[c + 1] = NULL;

  info->type_stack->baseclasses = baseclasses;

  if (definition)
    info->type_stack->definition = TRUE;

  return TRUE;
}

/* Start adding a method to the class on the type stack.  */

static bfd_boolean
stab_class_start_method (void *p, const char *name)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  char *m;

  assert (info->type_stack != NULL && info->type_stack->fields != NULL);

  if (info->type_stack->methods == NULL)
    {
      m = (char *) xmalloc (strlen (name) + 3);
      *m = '\0';
    }
  else
    {
      m = (char *) xrealloc (info->type_stack->methods,
			     (strlen (info->type_stack->methods)
			      + strlen (name)
			      + 4));
    }

  sprintf (m + strlen (m), "%s::", name);

  info->type_stack->methods = m;

  return TRUE;
}

/* Add a variant, either static or not, to the current method.  */

static bfd_boolean
stab_class_method_var (struct stab_write_handle *info, const char *physname,
		       enum debug_visibility visibility,
		       bfd_boolean staticp, bfd_boolean constp,
		       bfd_boolean volatilep, bfd_vma voffset,
		       bfd_boolean contextp)
{
  bfd_boolean definition;
  char *type;
  char *context = NULL;
  char visc, qualc, typec;

  definition = info->type_stack->definition;
  type = stab_pop_type (info);

  if (contextp)
    {
      definition = definition || info->type_stack->definition;
      context = stab_pop_type (info);
    }

  assert (info->type_stack != NULL && info->type_stack->methods != NULL);

  switch (visibility)
    {
    default:
      abort ();

    case DEBUG_VISIBILITY_PRIVATE:
      visc = '0';
      break;

    case DEBUG_VISIBILITY_PROTECTED:
      visc = '1';
      break;

    case DEBUG_VISIBILITY_PUBLIC:
      visc = '2';
      break;
    }

  if (constp)
    {
      if (volatilep)
	qualc = 'D';
      else
	qualc = 'B';
    }
  else
    {
      if (volatilep)
	qualc = 'C';
      else
	qualc = 'A';
    }

  if (staticp)
    typec = '?';
  else if (! contextp)
    typec = '.';
  else
    typec = '*';

  info->type_stack->methods =
    (char *) xrealloc (info->type_stack->methods,
		       (strlen (info->type_stack->methods)
			+ strlen (type)
			+ strlen (physname)
			+ (contextp ? strlen (context) : 0)
			+ 40));

  sprintf (info->type_stack->methods + strlen (info->type_stack->methods),
	   "%s:%s;%c%c%c", type, physname, visc, qualc, typec);
  free (type);

  if (contextp)
    {
      sprintf (info->type_stack->methods + strlen (info->type_stack->methods),
	       "%ld;%s;", (long) voffset, context);
      free (context);
    }

  if (definition)
    info->type_stack->definition = TRUE;

  return TRUE;
}

/* Add a variant to the current method.  */

static bfd_boolean
stab_class_method_variant (void *p, const char *physname,
			   enum debug_visibility visibility,
			   bfd_boolean constp, bfd_boolean volatilep,
			   bfd_vma voffset, bfd_boolean contextp)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;

  return stab_class_method_var (info, physname, visibility, FALSE, constp,
				volatilep, voffset, contextp);
}

/* Add a static variant to the current method.  */

static bfd_boolean
stab_class_static_method_variant (void *p, const char *physname,
				  enum debug_visibility visibility,
				  bfd_boolean constp, bfd_boolean volatilep)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;

  return stab_class_method_var (info, physname, visibility, TRUE, constp,
				volatilep, 0, FALSE);
}

/* Finish up a method.  */

static bfd_boolean
stab_class_end_method (void *p)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;

  assert (info->type_stack != NULL && info->type_stack->methods != NULL);

  /* We allocated enough room on info->type_stack->methods to add the
     trailing semicolon.  */
  strcat (info->type_stack->methods, ";");

  return TRUE;
}

/* Finish up a class.  */

static bfd_boolean
stab_end_class_type (void *p)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  size_t len;
  unsigned int i = 0;
  char *buf;

  assert (info->type_stack != NULL && info->type_stack->fields != NULL);

  /* Work out the size we need to allocate for the class definition.  */

  len = (strlen (info->type_stack->string)
	 + strlen (info->type_stack->fields)
	 + 10);
  if (info->type_stack->baseclasses != NULL)
    {
      len += 20;
      for (i = 0; info->type_stack->baseclasses[i] != NULL; i++)
	len += strlen (info->type_stack->baseclasses[i]);
    }
  if (info->type_stack->methods != NULL)
    len += strlen (info->type_stack->methods);
  if (info->type_stack->vtable != NULL)
    len += strlen (info->type_stack->vtable);

  /* Build the class definition.  */

  buf = (char *) xmalloc (len);

  strcpy (buf, info->type_stack->string);

  if (info->type_stack->baseclasses != NULL)
    {
      sprintf (buf + strlen (buf), "!%u,", i);
      for (i = 0; info->type_stack->baseclasses[i] != NULL; i++)
	{
	  strcat (buf, info->type_stack->baseclasses[i]);
	  free (info->type_stack->baseclasses[i]);
	}
      free (info->type_stack->baseclasses);
      info->type_stack->baseclasses = NULL;
    }

  strcat (buf, info->type_stack->fields);
  free (info->type_stack->fields);
  info->type_stack->fields = NULL;

  if (info->type_stack->methods != NULL)
    {
      strcat (buf, info->type_stack->methods);
      free (info->type_stack->methods);
      info->type_stack->methods = NULL;
    }

  strcat (buf, ";");

  if (info->type_stack->vtable != NULL)
    {
      strcat (buf, info->type_stack->vtable);
      free (info->type_stack->vtable);
      info->type_stack->vtable = NULL;
    }

  /* Replace the string on the top of the stack with the complete
     class definition.  */
  free (info->type_stack->string);
  info->type_stack->string = buf;

  return TRUE;
}

/* Push a typedef which was previously defined.  */

static bfd_boolean
stab_typedef_type (void *p, const char *name)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  struct string_hash_entry *h;

  h = string_hash_lookup (&info->typedef_hash, name, FALSE, FALSE);
  assert (h != NULL && h->index > 0);

  return stab_push_defined_type (info, h->index, h->size);
}

/* Push a struct, union or class tag.  */

static bfd_boolean
stab_tag_type (void *p, const char *name, unsigned int id,
	       enum debug_type_kind kind)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  long tindex;
  unsigned int size = 0;

  tindex = stab_get_struct_index (info, name, id, kind, &size);
  if (tindex < 0)
    return FALSE;

  return stab_push_defined_type (info, tindex, size);
}

/* Define a typedef.  */

static bfd_boolean
stab_typdef (void *p, const char *name)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  long tindex;
  unsigned int size;
  char *s, *buf;
  struct string_hash_entry *h;

  tindex = info->type_stack->index;
  size = info->type_stack->size;
  s = stab_pop_type (info);

  buf = (char *) xmalloc (strlen (name) + strlen (s) + 20);

  if (tindex > 0)
    sprintf (buf, "%s:t%s", name, s);
  else
    {
      tindex = info->type_index;
      ++info->type_index;
      sprintf (buf, "%s:t%ld=%s", name, tindex, s);
    }

  free (s);

  if (! stab_write_symbol (info, N_LSYM, 0, 0, buf))
    return FALSE;

  free (buf);

  h = string_hash_lookup (&info->typedef_hash, name, TRUE, FALSE);
  if (h == NULL)
    {
      non_fatal (_("string_hash_lookup failed: %s"),
		 bfd_errmsg (bfd_get_error ()));
      return FALSE;
    }

  /* I don't think we care about redefinitions.  */

  h->index = tindex;
  h->size = size;

  return TRUE;
}

/* Define a tag.  */

static bfd_boolean
stab_tag (void *p, const char *tag)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  char *s, *buf;

  s = stab_pop_type (info);

  buf = (char *) xmalloc (strlen (tag) + strlen (s) + 3);

  sprintf (buf, "%s:T%s", tag, s);
  free (s);

  if (! stab_write_symbol (info, N_LSYM, 0, 0, buf))
    return FALSE;

  free (buf);

  return TRUE;
}

/* Define an integer constant.  */

static bfd_boolean
stab_int_constant (void *p, const char *name, bfd_vma val)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  char *buf;

  buf = (char *) xmalloc (strlen (name) + 20);
  sprintf (buf, "%s:c=i%ld", name, (long) val);

  if (! stab_write_symbol (info, N_LSYM, 0, 0, buf))
    return FALSE;

  free (buf);

  return TRUE;
}

/* Define a floating point constant.  */

static bfd_boolean
stab_float_constant (void *p, const char *name, double val)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  char *buf;

  buf = (char *) xmalloc (strlen (name) + 20);
  sprintf (buf, "%s:c=f%g", name, val);

  if (! stab_write_symbol (info, N_LSYM, 0, 0, buf))
    return FALSE;

  free (buf);

  return TRUE;
}

/* Define a typed constant.  */

static bfd_boolean
stab_typed_constant (void *p, const char *name, bfd_vma val)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  char *s, *buf;

  s = stab_pop_type (info);

  buf = (char *) xmalloc (strlen (name) + strlen (s) + 20);
  sprintf (buf, "%s:c=e%s,%ld", name, s, (long) val);
  free (s);

  if (! stab_write_symbol (info, N_LSYM, 0, 0, buf))
    return FALSE;

  free (buf);

  return TRUE;
}

/* Record a variable.  */

static bfd_boolean
stab_variable (void *p, const char *name, enum debug_var_kind kind,
	       bfd_vma val)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  char *s, *buf;
  int stab_type;
  const char *kindstr;

  s = stab_pop_type (info);

  switch (kind)
    {
    default:
      abort ();

    case DEBUG_GLOBAL:
      stab_type = N_GSYM;
      kindstr = "G";
      break;

    case DEBUG_STATIC:
      stab_type = N_STSYM;
      kindstr = "S";
      break;

    case DEBUG_LOCAL_STATIC:
      stab_type = N_STSYM;
      kindstr = "V";
      break;

    case DEBUG_LOCAL:
      stab_type = N_LSYM;
      kindstr = "";

      /* Make sure that this is a type reference or definition.  */
      if (! ISDIGIT (*s))
	{
	  char *n;
	  long tindex;

	  tindex = info->type_index;
	  ++info->type_index;
	  n = (char *) xmalloc (strlen (s) + 20);
	  sprintf (n, "%ld=%s", tindex, s);
	  free (s);
	  s = n;
	}
      break;

    case DEBUG_REGISTER:
      stab_type = N_RSYM;
      kindstr = "r";
      break;
    }

  buf = (char *) xmalloc (strlen (name) + strlen (s) + 3);
  sprintf (buf, "%s:%s%s", name, kindstr, s);
  free (s);

  if (! stab_write_symbol (info, stab_type, 0, val, buf))
    return FALSE;

  free (buf);

  return TRUE;
}

/* Start outputting a function.  */

static bfd_boolean
stab_start_function (void *p, const char *name, bfd_boolean globalp)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  char *rettype, *buf;

  assert (info->nesting == 0 && info->fun_offset == -1);

  rettype = stab_pop_type (info);

  buf = (char *) xmalloc (strlen (name) + strlen (rettype) + 3);
  sprintf (buf, "%s:%c%s", name,
	   globalp ? 'F' : 'f',
	   rettype);

  /* We don't know the value now, so we set it in start_block.  */
  info->fun_offset = info->symbols_size;

  if (! stab_write_symbol (info, N_FUN, 0, 0, buf))
    return FALSE;

  free (buf);

  return TRUE;
}

/* Output a function parameter.  */

static bfd_boolean
stab_function_parameter (void *p, const char *name, enum debug_parm_kind kind, bfd_vma val)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;
  char *s, *buf;
  int stab_type;
  char kindc;

  s = stab_pop_type (info);

  switch (kind)
    {
    default:
      abort ();

    case DEBUG_PARM_STACK:
      stab_type = N_PSYM;
      kindc = 'p';
      break;

    case DEBUG_PARM_REG:
      stab_type = N_RSYM;
      kindc = 'P';
      break;

    case DEBUG_PARM_REFERENCE:
      stab_type = N_PSYM;
      kindc = 'v';
      break;

    case DEBUG_PARM_REF_REG:
      stab_type = N_RSYM;
      kindc = 'a';
      break;
    }

  buf = (char *) xmalloc (strlen (name) + strlen (s) + 3);
  sprintf (buf, "%s:%c%s", name, kindc, s);
  free (s);

  if (! stab_write_symbol (info, stab_type, 0, val, buf))
    return FALSE;

  free (buf);

  return TRUE;
}

/* Start a block.  */

static bfd_boolean
stab_start_block (void *p, bfd_vma addr)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;

  /* Fill in any slots which have been waiting for the first known
     text address.  */

  if (info->so_offset != -1)
    {
      bfd_put_32 (info->abfd, addr, info->symbols + info->so_offset + 8);
      info->so_offset = -1;
    }

  if (info->fun_offset != -1)
    {
      bfd_put_32 (info->abfd, addr, info->symbols + info->fun_offset + 8);
      info->fun_offset = -1;
    }

  ++info->nesting;

  /* We will be called with a top level block surrounding the
     function, but stabs information does not output that block, so we
     ignore it.  */

  if (info->nesting == 1)
    {
      info->fnaddr = addr;
      return TRUE;
    }

  /* We have to output the LBRAC symbol after any variables which are
     declared inside the block.  We postpone the LBRAC until the next
     start_block or end_block.  */

  /* If we have postponed an LBRAC, output it now.  */
  if (info->pending_lbrac != (bfd_vma) -1)
    {
      if (! stab_write_symbol (info, N_LBRAC, 0, info->pending_lbrac,
			       (const char *) NULL))
	return FALSE;
    }

  /* Remember the address and output it later.  */

  info->pending_lbrac = addr - info->fnaddr;

  return TRUE;
}

/* End a block.  */

static bfd_boolean
stab_end_block (void *p, bfd_vma addr)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;

  if (addr > info->last_text_address)
    info->last_text_address = addr;

  /* If we have postponed an LBRAC, output it now.  */
  if (info->pending_lbrac != (bfd_vma) -1)
    {
      if (! stab_write_symbol (info, N_LBRAC, 0, info->pending_lbrac,
			       (const char *) NULL))
	return FALSE;
      info->pending_lbrac = (bfd_vma) -1;
    }

  assert (info->nesting > 0);

  --info->nesting;

  /* We ignore the outermost block.  */
  if (info->nesting == 0)
    return TRUE;

  return stab_write_symbol (info, N_RBRAC, 0, addr - info->fnaddr,
			    (const char *) NULL);
}

/* End a function.  */

static bfd_boolean
stab_end_function (void *p ATTRIBUTE_UNUSED)
{
  return TRUE;
}

/* Output a line number.  */

static bfd_boolean
stab_lineno (void *p, const char *file, unsigned long lineno, bfd_vma addr)
{
  struct stab_write_handle *info = (struct stab_write_handle *) p;

  assert (info->lineno_filename != NULL);

  if (addr > info->last_text_address)
    info->last_text_address = addr;

  if (filename_cmp (file, info->lineno_filename) != 0)
    {
      if (! stab_write_symbol (info, N_SOL, 0, addr, file))
	return FALSE;
      info->lineno_filename = file;
    }

  return stab_write_symbol (info, N_SLINE, lineno, addr - info->fnaddr,
			    (const char *) NULL);
}
@


1.20
log
@ChangeLog binutils/
2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* debug.c (debug_start_source): Use filename_(n)cmp.
	* ieee.c (ieee_finish_compilation_unit): Likewise.
	(ieee_lineno): Likewise.
	* nlmconv.c (main): Likewise.
	* objcopy.c (strip_main): Likewise.
	(copy_main): Likewise.
	* objdump.c (show_line): Likewise.
	(dump_reloc_set): Likewise.
	* srconv.c (main): Likewise.
	* wrstabs.c (stab_lineno): Likewise.

ChangeLog gas/
2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* depend.c (register_dependency): Use filename_(n)cmp.
	* dwarf2dbg.c (get_filenum): Likewise.
	* ecoff.c (add_file): Likewise.
	(ecoff_generate_asm_lineno): Likewise.
	* input-scrub.c (new_logical_line_flags): Likewise.
	* listing.c (file_info): Likewise.
	(listing_newline): Likewise.
	* remap.c (remap_debug_filename): Likewise.
	* stabs.c (generate_asm_file): Likewise.
	(stabs_generate_asm_lineno): Likewise.
@
text
@d1315 1
a1315 3
  char *buf;

  buf = (char *) xmalloc (40);
@


1.19
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d30 1
d2265 1
a2265 1
  if (strcmp (file, info->lineno_filename) != 0)
@


1.18
log
@        Updated soruces in binutils/* to compile cleanly with -Wc++-compat.

        * binutils/addr2line.c (slurp_symtab): Fix casts. Introduce
        variable minisyms to avoid aliasing varning.
        * binutils/ar.c: Add casts. (normalize): Use name del instead of
        delete. (display_target_list,display_info_table): Change loop
        counter variable a to int.
        * binutils/bucomm.c: Add casts.
        * binutils/debug.c: Update function to use new names. (struct
        debug_baseclass): Rename member from virtual to
        is_virtual. (struct debug_type_s,struct debug_field_s,struct
        debug_baseclass_s,struct debug_method_s,struct
        debug_method_variant_s,struct debug_type_s): Rename struct from
        avoid name collision.
        * /binutils/debug.h: Use new struct names.
        * binutils/dwarf.c: Add casts. (free_debug_memory): Change loop
        counter variable a to int.
        * binutils/ieee.c: Add casts. (enum ieee_var_kind): Move to top
        level. (ieee_class_baseclass): Rename parameter virtual to
        is_virtual. (ieee_class_method_var): Rename variable virtual to
        is_virtual.
        * binutils/nm.c: Add casts.
        * binutils/objcopy.c: Add casts. (copy_archive): Rename variable
        delete to del.
        * binutils/objdump.c: Add casts. (dump_dwarf_section): Change loop
        counter variable i to int.
        * binutils/prdbg.c: Add
        casts. (pr_class_baseclass,tg_class_baseclass): Rename parameters
        virtual to is_virtual.
        * binutils/readelf.c: Add casts. (struct
        ia64_unw_table_entry,struct hppa_unw_table_entry): Move to top
        level.
        * binutils/size.c: Add casts.
        * binutils/stabs.c (parse_stab_type, parse_stab_range_type)
        (parse_stab_cpp_abbrev): Rename parameter from typename to
        type_name. (parse_stab_baseclasses): Rename variable virtual to
        is_virtual.
        * binutils/strings.c: Add casts.
        * binutils/wrstabs.c (stab_class_baseclass): Rename parameter
        virtual to is_virtual.
@
text
@d397 1
a397 1
		  long index, bfd_boolean definition, unsigned int size)
d403 1
a403 1
  s->index = index;
d421 1
a421 1
stab_push_defined_type (struct stab_write_handle *info, long index,
d426 2
a427 2
  sprintf (buf, "%ld", index);
  return stab_push_string (info, buf, index, FALSE, size);
d589 1
a589 1
      long index;
d592 1
a592 1
      index = info->type_index;
d595 1
a595 1
      sprintf (buf, "%ld=%ld", index, index);
d597 1
a597 1
      return stab_push_string (info, buf, index, FALSE, 0);
d612 1
a612 1
      long index;
d615 1
a615 1
      index = info->type_index;
d618 1
a618 1
      info->type_cache.void_type = index;
d620 1
a620 1
      sprintf (buf, "%ld=%ld", index, index);
d622 1
a622 1
      return stab_push_string (info, buf, index, TRUE, 0);
d649 1
a649 1
      long index;
d652 1
a652 1
      index = info->type_index;
d655 1
a655 1
      cache[size - 1] = index;
d657 1
a657 1
      sprintf (buf, "%ld=r%ld;", index, index);
d682 1
a682 1
      return stab_push_string (info, buf, index, TRUE, size);
d702 1
a702 1
      long index;
d711 1
a711 1
      index = info->type_index;
d717 1
a717 1
	info->type_cache.float_types[size - 1] = index;
d719 1
a719 1
      sprintf (buf, "%ld=r%s;%u;0;", index, int_type, size);
d723 1
a723 1
      return stab_push_string (info, buf, index, TRUE, size);
d734 1
a734 1
  long index;
d736 1
a736 1
  index = info->type_index;
d739 1
a739 1
  sprintf (buf, "%ld=r%ld;%u;0;", index, index, size);
d741 1
a741 1
  return stab_push_string (info, buf, index, TRUE, size * 2);
d751 1
a751 1
  long index;
d756 1
a756 1
      index = -21;
d760 1
a760 1
      index = -22;
d765 1
a765 1
      index = -16;
d769 1
a769 1
      index = -33;
d773 1
a773 1
  return stab_push_defined_type (info, index, size);
d786 1
a786 1
  long index = 0;
d814 1
a814 1
      index = info->type_index;
d816 1
a816 1
      sprintf (buf, "%s:T%ld=e", tag, index);
d833 1
a833 1
	  || ! stab_push_defined_type (info, index, 4))
d850 1
a850 1
  long index;
d890 2
a891 2
      index = (*cache)[targindex];
      if (index != 0 && ! info->type_stack->definition)
d900 1
a900 1
	  if (! stab_push_defined_type (info, index, size))
d905 1
a905 1
	  index = info->type_index;
d910 1
a910 1
	  sprintf (buf, "%ld=%c%s", index, mod, s);
d913 1
a913 1
	  (*cache)[targindex] = index;
d915 1
a915 1
	  if (! stab_push_string (info, buf, index, TRUE, size))
d1022 1
a1022 1
  long index;
d1036 1
a1036 1
      index = 0;
d1043 1
a1043 1
      index = info->type_index;
d1046 1
a1046 1
      sprintf (buf, "%ld=@@S;", index);
d1058 1
a1058 1
  if (! stab_push_string (info, buf, index, definition, size))
d1074 1
a1074 1
  long index;
d1084 1
a1084 1
      index = 0;
d1090 1
a1090 1
      index = info->type_index;
d1093 1
a1093 1
      sprintf (buf, "%ld=@@S;", index);
d1099 1
a1099 1
  if (! stab_push_string (info, buf, index, definition, 0))
d1312 1
a1312 1
  long index;
d1320 1
a1320 1
      index = 0;
d1326 1
a1326 1
      index = stab_get_struct_index (info, tag, id, DEBUG_KIND_ILLEGAL,
d1328 1
a1328 1
      if (index < 0)
d1330 1
a1330 1
      sprintf (buf, "%ld=", index);
d1338 1
a1338 1
  if (! stab_push_string (info, buf, index, definition, size))
d1417 1
a1417 1
  long index;
d1424 1
a1424 1
  index = info->type_stack->index;
d1434 1
a1434 1
  if (! stab_push_string (info, buf, index, definition, size))
d1870 1
a1870 1
  long index;
d1873 2
a1874 2
  index = stab_get_struct_index (info, name, id, kind, &size);
  if (index < 0)
d1877 1
a1877 1
  return stab_push_defined_type (info, index, size);
d1886 1
a1886 1
  long index;
d1891 1
a1891 1
  index = info->type_stack->index;
d1897 1
a1897 1
  if (index > 0)
d1901 1
a1901 1
      index = info->type_index;
d1903 1
a1903 1
      sprintf (buf, "%s:t%ld=%s", name, index, s);
d1923 1
a1923 1
  h->index = index;
d2053 1
a2053 1
	  long index;
d2055 1
a2055 1
	  index = info->type_index;
d2058 1
a2058 1
	  sprintf (n, "%ld=%s", index, s);
@


1.17
log
@update copyright dates
@
text
@d2 2
a3 2
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2006, 2007
   Free Software Foundation, Inc.
d1548 1
a1548 1
stab_class_baseclass (void *p, bfd_vma bitpos, bfd_boolean virtual,
d1564 1
a1564 1
  buf[0] = virtual ? '1' : '0';
@


1.17.2.1
log
@        Update soruces to compile cleanly with -Wc++-compat:

        * addr2line.c (slurp_symtab): Fix casts. Introduce variable
        minisyms to avoid aliasing varning.
        * ar.c: Add casts.
        (normalize): Use name del instead of delete.
        (display_target_list,display_info_table): Change loop counter
        variable a to int.
        * bucomm.c: Add casts.
        * debug.c: Update function to use new names.
        (struct debug_baseclass): Rename member from virtual to
        is_virtual.
        (struct debug_type_s, struct debug_field_s, struct
        debug_baseclass_s, struct debug_method_s, struct
        debug_method_variant_s, struct debug_type_s): Rename struct from
        avoid name collision.
        * debug.h: Use new struct names.
        * dwarf.c: Add casts.
        (free_debug_memory): Change loop counter variable a to int.
        * ieee.c: Add casts.
        (enum ieee_var_kind): Move to top level.
        (ieee_class_baseclass): Rename parameter virtual to is_virtual.
        (ieee_class_method_var): Rename variable virtual to is_virtual.
        * nm.c: Add casts.
        * objcopy.c: Add casts.
        (copy_archive): Rename variable delete to del.
        * objdump.c: Add casts.
        (dump_dwarf_section): Change loop counter variable i to int.
        * prdbg.c: Add casts.
        (pr_class_baseclass,tg_class_baseclass): Rename parameters virtual
        to is_virtual.
        * readelf.c: Add casts.
        (struct ia64_unw_table_entry,struct hppa_unw_table_entry): Move to
        top level.
        * size.c: Add casts.
        * stabs.c (parse_stab_type, parse_stab_range_type,
        (parse_stab_cpp_abbrev): Rename parameter from typename to
        type_name.
        (parse_stab_baseclasses): Rename variable virtual to is_virtual.
        * strings.c: Add casts.
        * wrstabs.c (stab_class_baseclass): Rename parameter virtual to
        is_virtual.
@
text
@d1548 1
a1548 1
stab_class_baseclass (void *p, bfd_vma bitpos, bfd_boolean is_virtual,
d1564 1
a1564 1
  buf[0] = is_virtual ? '1' : '0';
@


1.16
log
@Change sources over to using GPLv3
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2006, 2007
@


1.15
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
@


1.14
log
@PR binutils/3039
* wrstabs.c (stab_tag_type): Initialize 'size'.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2006
d26 1
a26 1
#include <stdio.h>
a27 1

a28 1
#include "bucomm.h"
d31 1
@


1.13
log
@	PR 2434
bfd/
	* elflink.c (struct elf_smash_syms_data, elf_smash_syms): Delete.
	(elf_link_add_object_symbols): Delete unnecessary locals.  Rename
	hash_table -> htab.  Formatting.  Save entire symbol table
	before loading as-needed syms, and restore afterwards if lib not
	needed.  Use bfd_hash_allocate rather than bfd_alloc for sym
	name.  Free some buffers earlier.
	* bfd-in.h (struct bfd_hash_table): Add entsize.
	(bfd_hash_table_init, bfd_hash_table_init_n): Adjust prototype.
	* elf-bfd.h (_bfd_elf_link_hash_table_init): Likewise
	* hash.c (bfd_hash_table_init_n): Add entsize param, save to
	hash table.
	(bfd_hash_table_init): Add param, adjust calls.
	* aoutx.h: Adjust all hash_table_init functions and calls.
	* bfd.c: Likewise.
	* coff-arm.c: Likewise.
	* coff-h8300.c: Likewise.
	* coff-ppc.c: Likewise.
	* cofflink.c: Likewise.
	* ecoff.c: Likewise.
	* ecofflink.c: Likewise.
	* elf-m10300.c: Likewise.
	* elf-strtab.c: Likewise.
	* elf.c: Likewise.
	* elf32-arm.c: Likewise.
	* elf32-bfin.c: Likewise.
	* elf32-cris.c: Likewise.
	* elf32-frv.c: Likewise.
	* elf32-hppa.c: Likewise.
	* elf32-i386.c: Likewise.
	* elf32-m32r.c: Likewise.
	* elf32-m68hc1x.c: Likewise.
	* elf32-m68k.c: Likewise.
	* elf32-ppc.c: Likewise.
	* elf32-s390.c: Likewise.
	* elf32-sh.c: Likewise.
	* elf32-vax.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-s390.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elf64-x86-64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elfxx-sparc.c: Likewise.
	* i386linux.c: Likewise.
	* libaout.h: Likewise.
	* libbfd-in.h: Likewise.
	* libcoff-in.h: Likewise.
	* linker.c: Likewise.
	* m68klinux.c: Likewise.
	* merge.c: Likewise.
	* opncls.c: Likewise.
	* pdp11.c: Likewise.
	* sparclinux.c: Likewise.
	* stabs.c: Likewise.
	* sunos.c: Likewise.
	* vms.c: Likewise.
	* xcofflink.c: Likewise.
	* section.c (struct section_hash_entry): Move to..
	* libbfd-in.h: ..here.
	* Makefile.am: Run "make dep-am"
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
	* libcoff.h: Regenerate.
binutils/
	* ieee.c (write_ieee_debugging_info): Adjust bfd_hash_table_init calls.
	* wrstabs.c (write_stabs_in_sections_debugging_info): Likewise.
ld/
	* ldcref.c (add_cref): Adjust bfd_hash_table_init calls.
	* ldlang.c (output_statement_table_init, lang_init): Likewise.
	* ldmain.c (add_ysym, add_wrap, add_keepsyms_file): Likewise.
	(undefined_symbol): Likewise.
@
text
@d1872 1
a1872 1
  unsigned int size;
@


1.13.4.1
log
@PR binutils/3039
* wrstabs.c (stab_tag_type): Initialize 'size'.
@
text
@d1872 1
a1872 1
  unsigned int size = 0;
@


1.12
log
@Update FSF address
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
d483 4
a486 2
  if (! bfd_hash_table_init (&info.strhash.table, string_hash_newfunc)
      || ! bfd_hash_table_init (&info.typedef_hash.table, string_hash_newfunc))
@


1.11
log
@update copyright dates
@
text
@d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.10
log
@	* addr2line.c: Convert to ISO C90 prototypes, change PTR, remove
	unneeded (void *) casts.
	* ar.c: Likewise.
	* arlex.l: Likewise.
	* arparse.y: Likewise.
	* arsup.c: Likewise.
	* binemul.c: Likewise.
	* binemul.h: Likewise.
	* bucomm.c: Likewise.
	* bucomm.h: Likewise.
	* budbg.h: Likewise.
	* budemang.c: Likewise.
	* budemang.h: Likewise.
	* coffdump.c: Likewise.
	* coffgrok.c: Likewise.
	* cxxfilt.c: Likewise.
	* debug.c: Likewise.
	* debug.h: Likewise.
	* deflex.l: Likewise.
	* dlltool.c: Likewise.
	* dlltool.h: Likewise.
	* dllwrap.c: Likewise.
	* emul_aix.c: Likewise.
	* filemode.c: Likewise.
	* ieee.c: Likewise.
	* nlmconv.c: Likewise.
	* nlmconv.h: Likewise.
	* nlmheader.y: Likewise.
	* nm.c: Likewise.
	* prdbg.c: Likewise.
	* rclex.l: Likewise.
	* rcparse.y: Likewise.
	* rdcoff.c: Likewise.
	* rddbg.c: Likewise.
	* rename.c: Likewise.
	* resbin.c: Likewise.
	* rescoff.c: Likewise.
	* resrc.c: Likewise.
	* size.c: Likewise.
	* srconv.c: Likewise.
	* stabs.c: Likewise.
	* strings.c: Likewise.
	* sysdump.c: Likewise.
	* sysinfo.y: Likewise.
	* syslex.l: Likewise.
	* unwind-ia64.c: Likewise.
	* unwind-ia64.h: Likewise.
	* version.c: Likewise.
	* windres.c: Likewise.
	* windres.h: Likewise.
	* winduni.c: Likewise.
	* wrstabs.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 2000, 2001, 2002, 2003
@


1.9
log
@Remove redundant defintions of BYTES_IN_WORD and add conditional defintion in
aout64.h.
@
text
@d176 1
a176 1
  PARAMS ((struct bfd_hash_entry *, struct bfd_hash_table *, const char *));
d178 1
a178 1
  PARAMS ((struct stab_write_handle *, int, int, bfd_vma, const char *));
d180 1
a180 2
  PARAMS ((struct stab_write_handle *, const char *, long, bfd_boolean,
	   unsigned int));
d182 2
a183 3
  PARAMS ((struct stab_write_handle *, long, unsigned int));
static char *stab_pop_type
  PARAMS ((struct stab_write_handle *));
d185 1
a185 1
  PARAMS ((struct stab_write_handle *, int, unsigned int, long **, size_t *));
d187 2
a188 2
  PARAMS ((struct stab_write_handle *, const char *, unsigned int,
	   enum debug_type_kind, unsigned int *));
d190 10
a199 18
  PARAMS ((struct stab_write_handle *, const char *, enum debug_visibility,
	   bfd_boolean, bfd_boolean, bfd_boolean, bfd_vma, bfd_boolean));
static bfd_boolean stab_start_compilation_unit
  PARAMS ((PTR, const char *));
static bfd_boolean stab_start_source
  PARAMS ((PTR, const char *));
static bfd_boolean stab_empty_type
  PARAMS ((PTR));
static bfd_boolean stab_void_type
  PARAMS ((PTR));
static bfd_boolean stab_int_type
  PARAMS ((PTR, unsigned int, bfd_boolean));
static bfd_boolean stab_float_type
  PARAMS ((PTR, unsigned int));
static bfd_boolean stab_complex_type
  PARAMS ((PTR, unsigned int));
static bfd_boolean stab_bool_type
  PARAMS ((PTR, unsigned int));
d201 5
a205 9
  PARAMS ((PTR, const char *, const char **, bfd_signed_vma *));
static bfd_boolean stab_pointer_type
  PARAMS ((PTR));
static bfd_boolean stab_function_type
  PARAMS ((PTR, int, bfd_boolean));
static bfd_boolean stab_reference_type
  PARAMS ((PTR));
static bfd_boolean stab_range_type
  PARAMS ((PTR, bfd_signed_vma, bfd_signed_vma));
d207 6
a212 11
  PARAMS ((PTR, bfd_signed_vma, bfd_signed_vma, bfd_boolean));
static bfd_boolean stab_set_type
  PARAMS ((PTR, bfd_boolean));
static bfd_boolean stab_offset_type
  PARAMS ((PTR));
static bfd_boolean stab_method_type
  PARAMS ((PTR, bfd_boolean, int, bfd_boolean));
static bfd_boolean stab_const_type
  PARAMS ((PTR));
static bfd_boolean stab_volatile_type
  PARAMS ((PTR));
d214 1
a214 1
  PARAMS ((PTR, const char *, unsigned int, bfd_boolean, unsigned int));
d216 2
a217 3
  PARAMS ((PTR, const char *, bfd_vma, bfd_vma, enum debug_visibility));
static bfd_boolean stab_end_struct_type
  PARAMS ((PTR));
d219 2
a220 2
  PARAMS ((PTR, const char *, unsigned int, bfd_boolean, unsigned int,
	   bfd_boolean, bfd_boolean));
d222 1
a222 1
  PARAMS ((PTR, const char *, const char *, enum debug_visibility));
d224 2
a225 3
  PARAMS ((PTR, bfd_vma, bfd_boolean, enum debug_visibility));
static bfd_boolean stab_class_start_method
  PARAMS ((PTR, const char *));
d227 2
a228 2
  PARAMS ((PTR, const char *, enum debug_visibility, bfd_boolean, bfd_boolean,
	   bfd_vma, bfd_boolean));
d230 4
a233 8
  PARAMS ((PTR, const char *, enum debug_visibility, bfd_boolean,
	   bfd_boolean));
static bfd_boolean stab_class_end_method
  PARAMS ((PTR));
static bfd_boolean stab_end_class_type
  PARAMS ((PTR));
static bfd_boolean stab_typedef_type
  PARAMS ((PTR, const char *));
d235 6
a240 11
  PARAMS ((PTR, const char *, unsigned int, enum debug_type_kind));
static bfd_boolean stab_typdef
  PARAMS ((PTR, const char *));
static bfd_boolean stab_tag
  PARAMS ((PTR, const char *));
static bfd_boolean stab_int_constant
  PARAMS ((PTR, const char *, bfd_vma));
static bfd_boolean stab_float_constant
  PARAMS ((PTR, const char *, double));
static bfd_boolean stab_typed_constant
  PARAMS ((PTR, const char *, bfd_vma));
d242 2
a243 3
  PARAMS ((PTR, const char *, enum debug_var_kind, bfd_vma));
static bfd_boolean stab_start_function
  PARAMS ((PTR, const char *, bfd_boolean));
d245 5
a249 9
  PARAMS ((PTR, const char *, enum debug_parm_kind, bfd_vma));
static bfd_boolean stab_start_block
  PARAMS ((PTR, bfd_vma));
static bfd_boolean stab_end_block
  PARAMS ((PTR, bfd_vma));
static bfd_boolean stab_end_function
  PARAMS ((PTR));
static bfd_boolean stab_lineno
  PARAMS ((PTR, const char *, unsigned long, bfd_vma));
d302 2
a303 4
string_hash_newfunc (entry, table, string)
     struct bfd_hash_entry *entry;
     struct bfd_hash_table *table;
     const char *string;
d339 2
a340 6
stab_write_symbol (info, type, desc, value, string)
     struct stab_write_handle *info;
     int type;
     int desc;
     bfd_vma value;
     const char *string;
d397 2
a398 6
stab_push_string (info, string, index, definition, size)
     struct stab_write_handle *info;
     const char *string;
     long index;
     bfd_boolean definition;
     unsigned int size;
d422 2
a423 4
stab_push_defined_type (info, index, size)
     struct stab_write_handle *info;
     long index;
     unsigned int size;
d435 1
a435 2
stab_pop_type (info)
     struct stab_write_handle *info;
d462 5
a466 8
write_stabs_in_sections_debugging_info (abfd, dhandle, psyms, psymsize,
					pstrings, pstringsize)
     bfd *abfd;
     PTR dhandle;
     bfd_byte **psyms;
     bfd_size_type *psymsize;
     bfd_byte **pstrings;
     bfd_size_type *pstringsize;
d510 1
a510 1
  if (! debug_write (dhandle, &stab_fns, (PTR) &info))
d543 1
a543 3
stab_start_compilation_unit (p, filename)
     PTR p;
     const char *filename;
d560 1
a560 3
stab_start_source (p, filename)
     PTR p;
     const char *filename;
d577 1
a577 2
stab_empty_type (p)
     PTR p;
d603 1
a603 2
stab_void_type (p)
     PTR p;
d628 1
a628 4
stab_int_type (p, size, unsignedp)
     PTR p;
     unsigned int size;
     bfd_boolean unsignedp;
d688 1
a688 3
stab_float_type (p, size)
     PTR p;
     unsigned int size;
d729 1
a729 3
stab_complex_type (p, size)
     PTR p;
     unsigned int size;
d747 1
a747 3
stab_bool_type (p, size)
     PTR p;
     unsigned int size;
d778 2
a779 5
stab_enum_type (p, tag, names, vals)
     PTR p;
     const char *tag;
     const char **names;
     bfd_signed_vma *vals;
d845 2
a846 6
stab_modify_type (info, mod, size, cache, cache_alloc)
     struct stab_write_handle *info;
     int mod;
     unsigned int size;
     long **cache;
     size_t *cache_alloc;
d927 1
a927 2
stab_pointer_type (p)
     PTR p;
d939 2
a940 4
stab_function_type (p, argcount, varargs)
     PTR p;
     int argcount;
     bfd_boolean varargs ATTRIBUTE_UNUSED;
d976 1
a976 2
stab_reference_type (p)
     PTR p;
d988 1
a988 4
stab_range_type (p, low, high)
     PTR p;
     bfd_signed_vma low;
     bfd_signed_vma high;
d1014 2
a1015 5
stab_array_type (p, low, high, stringp)
     PTR p;
     bfd_signed_vma low;
     bfd_signed_vma high;
     bfd_boolean stringp;
d1068 1
a1068 3
stab_set_type (p, bitstringp)
     PTR p;
     bfd_boolean bitstringp;
d1109 1
a1109 2
stab_offset_type (p)
     PTR p;
d1137 2
a1138 5
stab_method_type (p, domainp, argcount, varargs)
     PTR p;
     bfd_boolean domainp;
     int argcount;
     bfd_boolean varargs;
d1236 1
a1236 2
stab_const_type (p)
     PTR p;
d1247 1
a1247 2
stab_volatile_type (p)
     PTR p;
d1259 3
a1261 6
stab_get_struct_index (info, tag, id, kind, psize)
     struct stab_write_handle *info;
     const char *tag;
     unsigned int id;
     enum debug_type_kind kind;
     unsigned int *psize;
d1307 2
a1308 6
stab_start_struct_type (p, tag, id, structp, size)
     PTR p;
     const char *tag;
     unsigned int id;
     bfd_boolean structp;
     unsigned int size;
d1349 2
a1350 6
stab_struct_field (p, name, bitpos, bitsize, visibility)
     PTR p;
     const char *name;
     bfd_vma bitpos;
     bfd_vma bitsize;
     enum debug_visibility visibility;
d1412 1
a1412 2
stab_end_struct_type (p)
     PTR p;
d1444 1
a1444 8
stab_start_class_type (p, tag, id, structp, size, vptr, ownvptr)
     PTR p;
     const char *tag;
     unsigned int id;
     bfd_boolean structp;
     unsigned int size;
     bfd_boolean vptr;
     bfd_boolean ownvptr;
d1493 2
a1494 5
stab_class_static_member (p, name, physname, visibility)
     PTR p;
     const char *name;
     const char *physname;
     enum debug_visibility visibility;
d1547 2
a1548 5
stab_class_baseclass (p, bitpos, virtual, visibility)
     PTR p;
     bfd_vma bitpos;
     bfd_boolean virtual;
     enum debug_visibility visibility;
d1614 1
a1614 3
stab_class_start_method (p, name)
     PTR p;
     const char *name;
d1644 5
a1648 10
stab_class_method_var (info, physname, visibility, staticp, constp, volatilep,
		       voffset, contextp)
     struct stab_write_handle *info;
     const char *physname;
     enum debug_visibility visibility;
     bfd_boolean staticp;
     bfd_boolean constp;
     bfd_boolean volatilep;
     bfd_vma voffset;
     bfd_boolean contextp;
d1734 4
a1737 9
stab_class_method_variant (p, physname, visibility, constp, volatilep,
			   voffset, contextp)
     PTR p;
     const char *physname;
     enum debug_visibility visibility;
     bfd_boolean constp;
     bfd_boolean volatilep;
     bfd_vma voffset;
     bfd_boolean contextp;
d1748 3
a1750 6
stab_class_static_method_variant (p, physname, visibility, constp, volatilep)
     PTR p;
     const char *physname;
     enum debug_visibility visibility;
     bfd_boolean constp;
     bfd_boolean volatilep;
d1761 1
a1761 2
stab_class_end_method (p)
     PTR p;
d1777 1
a1777 2
stab_end_class_type (p)
     PTR p;
d1851 1
a1851 3
stab_typedef_type (p, name)
     PTR p;
     const char *name;
d1865 2
a1866 5
stab_tag_type (p, name, id, kind)
     PTR p;
     const char *name;
     unsigned int id;
     enum debug_type_kind kind;
d1882 1
a1882 3
stab_typdef (p, name)
     PTR p;
     const char *name;
d1931 1
a1931 3
stab_tag (p, tag)
     PTR p;
     const char *tag;
d1954 1
a1954 4
stab_int_constant (p, name, val)
     PTR p;
     const char *name;
     bfd_vma val;
d1973 1
a1973 4
stab_float_constant (p, name, val)
     PTR p;
     const char *name;
     double val;
d1992 1
a1992 4
stab_typed_constant (p, name, val)
     PTR p;
     const char *name;
     bfd_vma val;
d2014 2
a2015 5
stab_variable (p, name, kind, val)
     PTR p;
     const char *name;
     enum debug_var_kind kind;
     bfd_vma val;
d2084 1
a2084 4
stab_start_function (p, name, globalp)
     PTR p;
     const char *name;
     bfd_boolean globalp;
d2112 1
a2112 5
stab_function_parameter (p, name, kind, val)
     PTR p;
     const char *name;
     enum debug_parm_kind kind;
     bfd_vma val;
d2162 1
a2162 3
stab_start_block (p, addr)
     PTR p;
     bfd_vma addr;
d2215 1
a2215 3
stab_end_block (p, addr)
     PTR p;
     bfd_vma addr;
d2246 1
a2246 2
stab_end_function (p)
     PTR p ATTRIBUTE_UNUSED;
d2254 1
a2254 5
stab_lineno (p, file, lineno, addr)
     PTR p;
     const char *file;
     unsigned long lineno;
     bfd_vma addr;
@


1.8
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 2000, 2001, 2002
a34 4

/* Meaningless definition needs by aout64.h.  FIXME.  */
#define BYTES_IN_WORD 4

@


1.7
log
@	* arsup.c: Remove ARGSUSED.
	* debug.c: Likewise.
	* ieee.c: Likewise.
	* nlmconv.c: Likewise.
	* prdbg.c: Likewise.
	* stabs.c: Likewise.
	* wrstabs.c: Likewise.
@
text
@d2 2
a3 1
   Copyright 1996, 1997, 1998, 2000, 2001 Free Software Foundation, Inc.
d79 1
a79 1
  boolean definition;
d181 1
a181 1
static boolean stab_write_symbol
d183 2
a184 2
static boolean stab_push_string
  PARAMS ((struct stab_write_handle *, const char *, long, boolean,
d186 1
a186 1
static boolean stab_push_defined_type
d188 3
a190 2
static char *stab_pop_type PARAMS ((struct stab_write_handle *));
static boolean stab_modify_type
d195 1
a195 1
static boolean stab_class_method_var
d197 18
a214 11
	   boolean, boolean, boolean, bfd_vma, boolean));

static boolean stab_start_compilation_unit PARAMS ((PTR, const char *));
static boolean stab_start_source PARAMS ((PTR, const char *));
static boolean stab_empty_type PARAMS ((PTR));
static boolean stab_void_type PARAMS ((PTR));
static boolean stab_int_type PARAMS ((PTR, unsigned int, boolean));
static boolean stab_float_type PARAMS ((PTR, unsigned int));
static boolean stab_complex_type PARAMS ((PTR, unsigned int));
static boolean stab_bool_type PARAMS ((PTR, unsigned int));
static boolean stab_enum_type
d216 23
a238 14
static boolean stab_pointer_type PARAMS ((PTR));
static boolean stab_function_type PARAMS ((PTR, int, boolean));
static boolean stab_reference_type PARAMS ((PTR));
static boolean stab_range_type PARAMS ((PTR, bfd_signed_vma, bfd_signed_vma));
static boolean stab_array_type
  PARAMS ((PTR, bfd_signed_vma, bfd_signed_vma, boolean));
static boolean stab_set_type PARAMS ((PTR, boolean));
static boolean stab_offset_type PARAMS ((PTR));
static boolean stab_method_type PARAMS ((PTR, boolean, int, boolean));
static boolean stab_const_type PARAMS ((PTR));
static boolean stab_volatile_type PARAMS ((PTR));
static boolean stab_start_struct_type
  PARAMS ((PTR, const char *, unsigned int, boolean, unsigned int));
static boolean stab_struct_field
d240 6
a245 5
static boolean stab_end_struct_type PARAMS ((PTR));
static boolean stab_start_class_type
  PARAMS ((PTR, const char *, unsigned int, boolean, unsigned int, boolean,
	   boolean));
static boolean stab_class_static_member
d247 17
a263 12
static boolean stab_class_baseclass
  PARAMS ((PTR, bfd_vma, boolean, enum debug_visibility));
static boolean stab_class_start_method PARAMS ((PTR, const char *));
static boolean stab_class_method_variant
  PARAMS ((PTR, const char *, enum debug_visibility, boolean, boolean,
	   bfd_vma, boolean));
static boolean stab_class_static_method_variant
  PARAMS ((PTR, const char *, enum debug_visibility, boolean, boolean));
static boolean stab_class_end_method PARAMS ((PTR));
static boolean stab_end_class_type PARAMS ((PTR));
static boolean stab_typedef_type PARAMS ((PTR, const char *));
static boolean stab_tag_type
d265 11
a275 6
static boolean stab_typdef PARAMS ((PTR, const char *));
static boolean stab_tag PARAMS ((PTR, const char *));
static boolean stab_int_constant PARAMS ((PTR, const char *, bfd_vma));
static boolean stab_float_constant PARAMS ((PTR, const char *, double));
static boolean stab_typed_constant PARAMS ((PTR, const char *, bfd_vma));
static boolean stab_variable
d277 3
a279 2
static boolean stab_start_function PARAMS ((PTR, const char *, boolean));
static boolean stab_function_parameter
d281 7
a287 4
static boolean stab_start_block PARAMS ((PTR, bfd_vma));
static boolean stab_end_block PARAMS ((PTR, bfd_vma));
static boolean stab_end_function PARAMS ((PTR));
static boolean stab_lineno
d379 1
a379 1
static boolean
d396 1
a396 1
      h = string_hash_lookup (&info->strhash, string, true, true);
d401 1
a401 1
	  return false;
d436 1
a436 1
  return true;
d441 1
a441 1
static boolean
d446 1
a446 1
     boolean definition;
d465 1
a465 1
  return true;
d470 1
a470 1
static boolean
d479 1
a479 1
  return stab_push_string (info, buf, index, false, size);
d513 1
a513 1
boolean
d543 1
a543 1
      return false;
d558 1
a558 1
    return false;
d563 1
a563 1
    return false;
d566 1
a566 1
    return false;
d573 1
a573 1
    return false;
d592 1
a592 1
  return true;
d597 1
a597 1
static boolean
d616 1
a616 1
static boolean
d635 1
a635 1
static boolean
d656 1
a656 1
      return stab_push_string (info, buf, index, false, 0);
d662 1
a662 1
static boolean
d682 1
a682 1
      return stab_push_string (info, buf, index, true, 0);
d688 1
a688 1
static boolean
d692 1
a692 1
     boolean unsignedp;
d700 1
a700 1
      return false;
d745 1
a745 1
      return stab_push_string (info, buf, index, true, size);
d751 1
a751 1
static boolean
d772 2
a773 2
      if (! stab_int_type (info, 4, false))
	return false;
d788 1
a788 1
      return stab_push_string (info, buf, index, true, size);
d794 1
a794 1
static boolean
d808 1
a808 1
  return stab_push_string (info, buf, index, true, size * 2);
d811 1
a811 1
/* Push a boolean type.  We use an XCOFF predefined type, since gdb
d814 1
a814 1
static boolean
d847 1
a847 1
static boolean
d868 2
a869 2
      if (! stab_push_string (info, buf, 0, false, 4))
	return false;
d871 1
a871 1
      return true;
d898 2
a899 2
      if (! stab_push_string (info, buf, 0, false, 4))
	return false;
d906 1
a906 1
	return false;
d911 1
a911 1
  return true;
d917 1
a917 1
static boolean
d935 1
a935 1
      boolean definition;
d946 1
a946 1
	return false;
d977 1
a977 1
	    return false;
d991 2
a992 2
	  if (! stab_push_string (info, buf, index, true, size))
	    return false;
d998 1
a998 1
  return true;
d1003 1
a1003 1
static boolean
d1016 1
a1016 1
static boolean
d1020 1
a1020 1
     boolean varargs ATTRIBUTE_UNUSED;
d1043 1
a1043 1
	    return false;
d1055 1
a1055 1
static boolean
d1068 1
a1068 1
static boolean
d1075 1
a1075 1
  boolean definition;
d1088 1
a1088 1
    return false;
d1092 1
a1092 1
  return true;
d1097 1
a1097 1
static boolean
d1102 1
a1102 1
     boolean stringp;
d1105 1
a1105 1
  boolean definition;
d1131 1
a1131 1
      definition = true;
d1145 1
a1145 1
    return false;
d1149 1
a1149 1
  return true;
d1154 1
a1154 1
static boolean
d1157 1
a1157 1
     boolean bitstringp;
d1160 1
a1160 1
  boolean definition;
d1180 1
a1180 1
      definition = true;
d1188 1
a1188 1
    return false;
d1192 1
a1192 1
  return true;
d1197 1
a1197 1
static boolean
d1202 1
a1202 1
  boolean definition;
d1217 1
a1217 1
    return false;
d1221 1
a1221 1
  return true;
d1226 1
a1226 1
static boolean
d1229 1
a1229 1
     boolean domainp;
d1231 1
a1231 1
     boolean varargs;
d1234 1
a1234 1
  boolean definition;
d1249 1
a1249 1
	return false;
d1271 1
a1271 1
	    return false;
d1288 1
a1288 1
	    return false;
d1319 1
a1319 1
    return false;
d1323 1
a1323 1
  return true;
d1328 1
a1328 1
static boolean
d1340 1
a1340 1
static boolean
d1404 1
a1404 1
static boolean
d1409 1
a1409 1
     boolean structp;
d1414 1
a1414 1
  boolean definition;
d1423 1
a1423 1
      definition = false;
d1430 1
a1430 1
	return false;
d1432 1
a1432 1
      definition = true;
d1440 1
a1440 1
    return false;
d1445 1
a1445 1
  return true;
d1450 1
a1450 1
static boolean
d1459 1
a1459 1
  boolean definition;
d1510 1
a1510 1
    info->type_stack->definition = true;
d1512 1
a1512 1
  return true;
d1517 1
a1517 1
static boolean
d1522 1
a1522 1
  boolean definition;
d1541 1
a1541 1
    return false;
d1545 1
a1545 1
  return true;
d1550 1
a1550 1
static boolean
d1555 1
a1555 1
     boolean structp;
d1557 2
a1558 2
     boolean vptr;
     boolean ownvptr;
d1561 1
a1561 1
  boolean definition;
d1566 1
a1566 1
      definition = false;
d1576 1
a1576 1
    return false;
d1599 1
a1599 1
    info->type_stack->definition = true;
d1601 1
a1601 1
  return true;
d1606 1
a1606 1
static boolean
d1614 1
a1614 1
  boolean definition;
d1656 1
a1656 1
    info->type_stack->definition = true;
d1658 1
a1658 1
  return true;
d1663 1
a1663 1
static boolean
d1667 1
a1667 1
     boolean virtual;
d1671 1
a1671 1
  boolean definition;
d1726 1
a1726 1
    info->type_stack->definition = true;
d1728 1
a1728 1
  return true;
d1733 1
a1733 1
static boolean
d1760 1
a1760 1
  return true;
d1765 1
a1765 1
static boolean
d1771 3
a1773 3
     boolean staticp;
     boolean constp;
     boolean volatilep;
d1775 1
a1775 1
     boolean contextp;
d1777 1
a1777 1
  boolean definition;
d1853 1
a1853 1
    info->type_stack->definition = true;
d1855 1
a1855 1
  return true;
d1860 1
a1860 1
static boolean
d1866 2
a1867 2
     boolean constp;
     boolean volatilep;
d1869 1
a1869 1
     boolean contextp;
d1873 1
a1873 1
  return stab_class_method_var (info, physname, visibility, false, constp,
d1879 1
a1879 1
static boolean
d1884 2
a1885 2
     boolean constp;
     boolean volatilep;
d1889 2
a1890 2
  return stab_class_method_var (info, physname, visibility, true, constp,
				volatilep, 0, false);
d1895 1
a1895 1
static boolean
d1907 1
a1907 1
  return true;
d1912 1
a1912 1
static boolean
d1982 1
a1982 1
  return true;
d1987 1
a1987 1
static boolean
d1995 1
a1995 1
  h = string_hash_lookup (&info->typedef_hash, name, false, false);
d2003 1
a2003 1
static boolean
d2016 1
a2016 1
    return false;
d2023 1
a2023 1
static boolean
d2052 1
a2052 1
    return false;
d2056 1
a2056 1
  h = string_hash_lookup (&info->typedef_hash, name, true, false);
d2061 1
a2061 1
      return false;
d2069 1
a2069 1
  return true;
d2074 1
a2074 1
static boolean
d2090 1
a2090 1
    return false;
d2094 1
a2094 1
  return true;
d2099 1
a2099 1
static boolean
d2112 1
a2112 1
    return false;
d2116 1
a2116 1
  return true;
d2121 1
a2121 1
static boolean
d2134 1
a2134 1
    return false;
d2138 1
a2138 1
  return true;
d2143 1
a2143 1
static boolean
d2159 1
a2159 1
    return false;
d2163 1
a2163 1
  return true;
d2168 1
a2168 1
static boolean
d2232 1
a2232 1
    return false;
d2236 1
a2236 1
  return true;
d2241 1
a2241 1
static boolean
d2245 1
a2245 1
     boolean globalp;
d2263 1
a2263 1
    return false;
d2267 1
a2267 1
  return true;
d2272 1
a2272 1
static boolean
d2317 1
a2317 1
    return false;
d2321 1
a2321 1
  return true;
d2326 1
a2326 1
static boolean
d2357 1
a2357 1
      return true;
d2369 1
a2369 1
	return false;
d2376 1
a2376 1
  return true;
d2381 1
a2381 1
static boolean
d2396 1
a2396 1
	return false;
d2406 1
a2406 1
    return true;
d2414 1
a2414 1
static boolean
d2418 1
a2418 1
  return true;
d2423 1
a2423 1
static boolean
d2440 1
a2440 1
	return false;
@


1.6
log
@	* size.c: Fix formatting.
	* srconv.c: Likewise.
	* stabs.c: Likewise.
	* sysdump.c: Likewise.
	* unwind-ia64.c: Likewise.
	* wrstabs.c: Likewise.
@
text
@a1370 1
/*ARGSUSED*/
a2380 1
/*ARGSUSED*/
@


1.5
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d798 1
a798 1
      
d966 1
a966 1
}  
@


1.4
log
@Fix typos in ChangeLogs and update copyright notices
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 2000 Free Software Foundation, Inc.
a25 1
#include <ctype.h>
d31 1
d2175 1
a2175 1
      if (! isdigit ((unsigned char) *s))
@


1.3
log
@A mostly cosmetic tidy up of warnings and error message reporting.
@
text
@d2 1
a2 1
   Copyright (C) 1996, 97, 98, 99, 2000 Free Software Foundation, Inc.
@


1.3.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1996, 1997, 1998, 2000 Free Software Foundation, Inc.
@


1.2
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Add variable initializations.  Add casts.
	* objdump.c (disassemble_bytes): Change j to bfd_vma.
	* readelf.c (process_syminfo): Change i to unsigned int.
	(display_debug_info): Change abbrev_number to unsigned long.
	(process_mips_specific): Change fcnt to size_t.
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
d366 2
a367 2
	  fprintf (stderr, _("string_hash_lookup failed: %s\n"),
		   bfd_errmsg (bfd_get_error ()));
d508 2
a509 2
      fprintf (stderr, "bfd_hash_table_init_failed: %s\n",
	       bfd_errmsg (bfd_get_error ()));
d666 1
a666 1
      fprintf (stderr, _("stab_int_type: bad size %u\n"), size);
d1467 2
a1468 3
	fprintf (stderr,
		 _("%s: warning: unknown size for field `%s' in struct\n"),
		 bfd_get_filename (info->abfd), name);
d2027 2
a2028 2
      fprintf (stderr, _("string_hash_lookup failed: %s\n"),
	       bfd_errmsg (bfd_get_error ()));
@


1.2.2.1
log
@A mostly cosmetic tidy up of warnings and error message reporting.
@
text
@d2 1
a2 1
   Copyright (C) 1996, 97, 98, 99, 2000 Free Software Foundation, Inc.
d366 2
a367 2
	  non_fatal (_("string_hash_lookup failed: %s"),
		     bfd_errmsg (bfd_get_error ()));
d508 2
a509 2
      non_fatal ("bfd_hash_table_init_failed: %s",
		 bfd_errmsg (bfd_get_error ()));
d666 1
a666 1
      non_fatal (_("stab_int_type: bad size %u"), size);
d1467 3
a1469 2
	non_fatal (_("%s: warning: unknown size for field `%s' in struct"),
		   bfd_get_filename (info->abfd), name);
d2028 2
a2029 2
      non_fatal (_("string_hash_lookup failed: %s"),
		 bfd_errmsg (bfd_get_error ()));
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.
d987 1
a987 1
     boolean varargs;
d2386 1
a2386 1
     PTR p;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

