head	1.18;
access;
symbols
	binutils-2_24-branch:1.18.0.4
	binutils-2_24-branchpoint:1.18
	binutils-2_21_1:1.17
	binutils-2_23_2:1.18
	binutils-2_23_1:1.18
	binutils-2_23:1.18
	binutils-2_23-branch:1.18.0.2
	binutils-2_23-branchpoint:1.18
	binutils-2_22_branch:1.17.0.6
	binutils-2_22:1.17
	binutils-2_22-branch:1.17.0.4
	binutils-2_22-branchpoint:1.17
	binutils-2_21:1.17
	binutils-2_21-branch:1.17.0.2
	binutils-2_21-branchpoint:1.17
	binutils-2_20_1:1.16
	binutils-2_20:1.16
	binutils-arc-20081103-branch:1.15.0.10
	binutils-arc-20081103-branchpoint:1.15
	binutils-2_20-branch:1.16.0.2
	binutils-2_20-branchpoint:1.16
	dje-cgen-play1-branch:1.15.0.8
	dje-cgen-play1-branchpoint:1.15
	arc-20081103-branch:1.15.0.6
	arc-20081103-branchpoint:1.15
	binutils-2_19_1:1.15
	binutils-2_19:1.15
	binutils-2_19-branch:1.15.0.4
	binutils-2_19-branchpoint:1.15
	binutils-2_18:1.15
	binutils-2_18-branch:1.15.0.2
	binutils-2_18-branchpoint:1.15
	binutils-csl-coldfire-4_1-32:1.14
	binutils-csl-sourcerygxx-4_1-32:1.14
	binutils-csl-innovasic-fido-3_4_4-33:1.14
	binutils-csl-sourcerygxx-3_4_4-32:1.12
	binutils-csl-coldfire-4_1-30:1.14
	binutils-csl-sourcerygxx-4_1-30:1.14
	binutils-csl-coldfire-4_1-28:1.14
	binutils-csl-sourcerygxx-4_1-29:1.14
	binutils-csl-sourcerygxx-4_1-28:1.14
	binutils-csl-arm-2006q3-27:1.14
	binutils-csl-sourcerygxx-4_1-27:1.14
	binutils-csl-arm-2006q3-26:1.14
	binutils-csl-sourcerygxx-4_1-26:1.14
	binutils-csl-sourcerygxx-4_1-25:1.14
	binutils-csl-sourcerygxx-4_1-24:1.14
	binutils-csl-sourcerygxx-4_1-23:1.14
	binutils-csl-sourcerygxx-4_1-21:1.14
	binutils-csl-arm-2006q3-21:1.14
	binutils-csl-sourcerygxx-4_1-22:1.14
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.14
	binutils-csl-sourcerygxx-4_1-20:1.14
	binutils-csl-arm-2006q3-19:1.14
	binutils-csl-sourcerygxx-4_1-19:1.14
	binutils-csl-sourcerygxx-4_1-18:1.14
	binutils-csl-renesas-4_1-9:1.14
	binutils-csl-sourcerygxx-3_4_4-25:1.12
	binutils-csl-renesas-4_1-8:1.14
	binutils-csl-renesas-4_1-7:1.14
	binutils-csl-renesas-4_1-6:1.14
	binutils-csl-sourcerygxx-4_1-17:1.14
	binutils-csl-sourcerygxx-4_1-14:1.14
	binutils-csl-sourcerygxx-4_1-15:1.14
	binutils-csl-sourcerygxx-4_1-13:1.14
	binutils-2_17:1.14
	binutils-csl-sourcerygxx-4_1-12:1.14
	binutils-csl-sourcerygxx-3_4_4-21:1.14
	binutils-csl-wrs-linux-3_4_4-24:1.12
	binutils-csl-wrs-linux-3_4_4-23:1.12
	binutils-csl-sourcerygxx-4_1-9:1.14
	binutils-csl-sourcerygxx-4_1-8:1.14
	binutils-csl-sourcerygxx-4_1-7:1.14
	binutils-csl-arm-2006q1-6:1.14
	binutils-csl-sourcerygxx-4_1-6:1.14
	binutils-csl-wrs-linux-3_4_4-22:1.12
	binutils-csl-coldfire-4_1-11:1.14
	binutils-csl-sourcerygxx-3_4_4-19:1.14
	binutils-csl-coldfire-4_1-10:1.14
	binutils-csl-sourcerygxx-4_1-5:1.14
	binutils-csl-sourcerygxx-4_1-4:1.14
	binutils-csl-wrs-linux-3_4_4-21:1.12
	binutils-csl-morpho-4_1-4:1.14
	binutils-csl-sourcerygxx-3_4_4-17:1.14
	binutils-csl-wrs-linux-3_4_4-20:1.12
	binutils-2_17-branch:1.14.0.4
	binutils-2_17-branchpoint:1.14
	binutils-csl-2_17-branch:1.14.0.2
	binutils-csl-2_17-branchpoint:1.14
	binutils-csl-gxxpro-3_4-branch:1.12.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.12
	binutils-2_16_1:1.12
	binutils-csl-arm-2005q1b:1.12
	binutils-2_16:1.12
	binutils-csl-arm-2005q1a:1.12
	binutils-csl-arm-2005q1-branch:1.12.0.4
	binutils-csl-arm-2005q1-branchpoint:1.12
	binutils-2_16-branch:1.12.0.2
	binutils-2_16-branchpoint:1.12
	csl-arm-2004-q3d:1.11
	csl-arm-2004-q3:1.11
	binutils-2_15:1.11
	binutils-2_15-branchpoint:1.11
	csl-arm-2004-q1a:1.11
	csl-arm-2004-q1:1.11
	binutils-2_15-branch:1.11.0.6
	cagney_bfdfile-20040213-branch:1.11.0.4
	cagney_bfdfile-20040213-branchpoint:1.11
	cagney_bigcore-20040122-branch:1.11.0.2
	cagney_bigcore-20040122-branchpoint:1.11
	csl-arm-2003-q4:1.11
	binutils-2_14:1.9
	binutils-2_14-branch:1.9.0.4
	binutils-2_14-branchpoint:1.9
	binutils-2_13_2_1:1.9
	binutils-2_13_2:1.9
	binutils-2_13_1:1.9
	binutils-2_13:1.9
	binutils-2_13-branchpoint:1.9
	binutils-2_13-branch:1.9.0.2
	binutils-2_12_1:1.7
	binutils-2_12:1.7
	binutils-2_12-branch:1.7.0.2
	binutils-2_12-branchpoint:1.7
	cygnus_cvs_20020108_pre:1.6
	binutils-2_11_2:1.3.2.1
	binutils-2_11_1:1.3.2.1
	binutils-2_11-branch:1.3.0.2
	x86_64versiong3:1.2
	binutils_latest_snapshot:1.18;
locks; strict;
comment	@ * @;


1.18
date	2012.05.17.15.13.28;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2010.06.11.09.04.39;	author gingold;	state Exp;
branches;
next	1.16;

1.16
date	2009.09.02.07.22.32;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2007.07.05.16.54.45;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2005.08.16.09.25.22;	author jakub;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.08.14.17.39;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.03.11.46.12;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2003.12.06.00.06.12;	author kazu;	state Exp;
branches;
next	1.10;

1.10
date	2003.09.14.12.20.17;	author aj;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.27.08.40.35;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.24.00.33.36;	author kazu;	state Exp;
branches;
next	1.7;

1.7
date	2002.01.29.16.54.04;	author drow;	state Exp;
branches;
next	1.6;

1.6
date	2001.11.10.01.04.39;	author law;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.21.10.02.26;	author aj;	state Exp;
branches;
next	1.4;

1.4
date	2001.06.23.16.06.51;	author aj;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.13.06.43.58;	author nickc;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2001.02.11.23.13.38;	author msokolov;	state Exp;
branches;
next	1.1;

1.1
date	2001.02.07.19.41.02;	author nickc;	state Exp;
branches;
next	;

1.3.2.1
date	2001.05.28.18.34.46;	author pb;	state Exp;
branches;
next	;


desc
@@


1.18
log
@	PR 14072
	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.
	* alpha-opc.c: Include sysdep.h before any other header file.
	* alpha-dis.c: Likewise.
	* avr-dis.c: Likewise.
	* cgen-opc.c: Likewise.
	* cr16-dis.c: Likewise.
	* cris-dis.c: Likewise.
	* crx-dis.c: Likewise.
	* d10v-dis.c: Likewise.
	* d10v-opc.c: Likewise.
	* d30v-dis.c: Likewise.
	* d30v-opc.c: Likewise.
	* h8500-dis.c: Likewise.
	* i370-dis.c: Likewise.
	* i370-opc.c: Likewise.
	* m10200-dis.c: Likewise.
	* m10300-dis.c: Likewise.
	* micromips-opc.c: Likewise.
	* mips-opc.c: Likewise.
	* mips61-opc.c: Likewise.
	* moxie-dis.c: Likewise.
	* or32-opc.c: Likewise.
	* pj-dis.c: Likewise.
	* ppc-dis.c: Likewise.
	* ppc-opc.c: Likewise.
	* s390-dis.c: Likewise.
	* sh-dis.c: Likewise.
	* sh64-dis.c: Likewise.
	* sparc-dis.c: Likewise.
	* sparc-opc.c: Likewise.
	* spu-dis.c: Likewise.
	* tic30-dis.c: Likewise.
	* tic54x-dis.c: Likewise.
	* tic80-dis.c: Likewise.
	* tic80-opc.c: Likewise.
	* tilegx-dis.c: Likewise.
	* tilepro-dis.c: Likewise.
	* v850-dis.c: Likewise.
	* v850-opc.c: Likewise.
	* vax-dis.c: Likewise.
	* w65-dis.c: Likewise.
	* xgate-dis.c: Likewise.
	* xtensa-dis.c: Likewise.
	* rl78-decode.opc: Likewise.
	* rl78-decode.c: Regenerate.
	* rx-decode.opc: Likewise.
	* rx-decode.c: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* sysdep.h: Generate an error if included before config.h.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* bfd-in.h: Generate an error if included before config.h.
	* sysdep.h: Likewise.
	* bfd-in2.h: Regenerate.
	* compress.c: Remove #include "config.h".
	* plugin.c: Likewise.
	* elf32-m68hc1x.c: Include sysdep.h before alloca-conf.h.
	* elf64-hppa.c: Likewise.
	* som.c: Likewise.
	* xsymc.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* aclocal.m4: Regenerate.
	* Makefile.am: Use wrappers around C files generated by flex.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* itbl-lex-wrapper.c: New file.
	* config/bfin-lex-wrapper.c: New file.
	* cgen.c: Include as.h before setjmp.h.
	* config/tc-dlx.c: Include as.h before any other header.
	* config/tc-h8300.c: Likewise.
	* config/tc-lm32.c: Likewise.
	* config/tc-mep.c: Likewise.
	* config/tc-microblaze.c: Likewise.
	* config/tc-mmix.c: Likewise.
	* config/tc-msp430.c: Likewise.
	* config/tc-or32.c: Likewise.
	* config/tc-tic4x.c: Likewise.
	* config/tc-tic54x.c: Likewise.
	* config/tc-xtensa.c: Likewise.

	* configure.in: Add check that sysdep.h has been included before
	any system header files.
	* configure: Regenerate.
	* config.in: Regenerate.
	* unwind-ia64.h: Include config.h.
@
text
@/* unwind-ia64.c -- utility routines to dump IA-64 unwind info for readelf.
   Copyright 2000, 2001, 2002, 2003, 2005, 2007, 2012
   Free Software Foundation, Inc.

   Contributed by David Mosberger-Tang <davidm@@hpl.hp.com>

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

#include "config.h"
#include "unwind-ia64.h"
#include <stdio.h>
#include <string.h>

#if __GNUC__ >= 2
/* Define BFD64 here, even if our default architecture is 32 bit ELF
   as this will allow us to read in and parse 64bit and 32bit ELF files.
   Only do this if we believe that the compiler can support a 64 bit
   data type.  For now we only rely on GCC being able to do this.  */
#define BFD64
#endif
#include "bfd.h"

static bfd_vma unw_rlen = 0;

static void unw_print_brmask (char *, unsigned int);
static void unw_print_grmask (char *, unsigned int);
static void unw_print_frmask (char *, unsigned int);
static void unw_print_abreg (char *, unsigned int);
static void unw_print_xyreg (char *, unsigned int, unsigned int);

static void
unw_print_brmask (char *cp, unsigned int mask)
{
  int sep = 0;
  int i;

  for (i = 0; mask && (i < 5); ++i)
    {
      if (mask & 1)
	{
	  if (sep)
	    *cp++ = ',';
	  *cp++ = 'b';
	  *cp++ = i + 1 + '0';
	  sep = 1;
	}
      mask >>= 1;
    }
  *cp = '\0';
}

static void
unw_print_grmask (char *cp, unsigned int mask)
{
  int sep = 0;
  int i;

  for (i = 0; i < 4; ++i)
    {
      if (mask & 1)
	{
	  if (sep)
	    *cp++ = ',';
	  *cp++ = 'r';
	  *cp++ = i + 4 + '0';
	  sep = 1;
	}
      mask >>= 1;
    }
  *cp = '\0';
}

static void
unw_print_frmask (char *cp, unsigned int mask)
{
  int sep = 0;
  int i;

  for (i = 0; i < 20; ++i)
    {
      if (mask & 1)
	{
	  if (sep)
	    *cp++ = ',';
	  *cp++ = 'f';
	  if (i < 4)
	    *cp++ = i + 2 + '0';
	  else
	    {
	      *cp++ = (i + 2) / 10 + 1 + '0';
	      *cp++ = (i + 2) % 10 + '0';
	    }
	  sep = 1;
	}
      mask >>= 1;
    }
  *cp = '\0';
}

static void
unw_print_abreg (char *cp, unsigned int abreg)
{
  static const char * const special_reg[16] =
  {
    "pr", "psp", "@@priunat", "rp", "ar.bsp", "ar.bspstore", "ar.rnat",
    "ar.unat", "ar.fpsr", "ar.pfs", "ar.lc",
    "Unknown11", "Unknown12", "Unknown13", "Unknown14", "Unknown15"
  };

  switch ((abreg >> 5) & 0x3)
    {
    case 0: /* gr */
      sprintf (cp, "r%u", (abreg & 0x1f));
      break;

    case 1: /* fr */
      sprintf (cp, "f%u", (abreg & 0x1f));
      break;

    case 2: /* br */
      sprintf (cp, "b%u", (abreg & 0x1f));
      break;

    case 3: /* special */
      strcpy (cp, special_reg[abreg & 0xf]);
      break;
    }
}

static void
unw_print_xyreg (char *cp, unsigned int x, unsigned int ytreg)
{
  switch ((x << 1) | ((ytreg >> 7) & 1))
    {
    case 0: /* gr */
      sprintf (cp, "r%u", (ytreg & 0x1f));
      break;

    case 1: /* fr */
      sprintf (cp, "f%u", (ytreg & 0x1f));
      break;

    case 2: /* br */
      sprintf (cp, "b%u", (ytreg & 0x1f));
      break;
    }
}

#define UNW_REG_BSP		"bsp"
#define UNW_REG_BSPSTORE	"bspstore"
#define UNW_REG_FPSR		"fpsr"
#define UNW_REG_LC		"lc"
#define UNW_REG_PFS		"pfs"
#define UNW_REG_PR		"pr"
#define UNW_REG_PSP		"psp"
#define UNW_REG_RNAT		"rnat"
#define UNW_REG_RP		"rp"
#define UNW_REG_UNAT		"unat"

typedef bfd_vma unw_word;

#define UNW_DEC_BAD_CODE(code)			\
    printf ("Unknown code 0x%02x\n", code)

#define UNW_DEC_PROLOGUE(fmt, body, rlen, arg)					\
  do										\
    {										\
      unw_rlen = rlen;								\
      *(int *)arg = body;							\
      printf ("    %s:%s(rlen=%lu)\n",						\
	      fmt, body ? "body" : "prologue", (unsigned long) rlen);		\
    }										\
  while (0)

#define UNW_DEC_PROLOGUE_GR(fmt, rlen, mask, grsave, arg)			\
  do										\
    {										\
      char regname[16], maskstr[64], *sep;					\
										\
      unw_rlen = rlen;								\
      *(int *)arg = 0;								\
										\
      maskstr[0] = '\0';							\
      sep = "";									\
      if (mask & 0x8)								\
	{									\
	  strcat (maskstr, "rp");						\
	  sep = ",";								\
	}									\
      if (mask & 0x4)								\
	{									\
	  strcat (maskstr, sep);						\
	  strcat (maskstr, "ar.pfs");						\
	  sep = ",";								\
	}									\
      if (mask & 0x2)								\
	{									\
	  strcat (maskstr, sep);						\
	  strcat (maskstr, "psp");						\
	  sep = ",";								\
	}									\
      if (mask & 0x1)								\
	{									\
	  strcat (maskstr, sep);						\
	  strcat (maskstr, "pr");						\
	}									\
      sprintf (regname, "r%u", grsave);						\
      printf ("    %s:prologue_gr(mask=[%s],grsave=%s,rlen=%lu)\n",		\
	      fmt, maskstr, regname, (unsigned long) rlen);			\
    }										\
  while (0)

#define UNW_DEC_FR_MEM(fmt, frmask, arg)			\
  do								\
    {								\
      char frstr[200];						\
								\
      unw_print_frmask (frstr, frmask);				\
      printf ("\t%s:fr_mem(frmask=[%s])\n", fmt, frstr);	\
    }								\
  while (0)

#define UNW_DEC_GR_MEM(fmt, grmask, arg)			\
  do								\
    {								\
      char grstr[200];						\
								\
      unw_print_grmask (grstr, grmask);				\
      printf ("\t%s:gr_mem(grmask=[%s])\n", fmt, grstr);	\
    }								\
  while (0)

#define UNW_DEC_FRGR_MEM(fmt, grmask, frmask, arg)				\
  do										\
    {										\
      char frstr[200], grstr[20];						\
										\
      unw_print_grmask (grstr, grmask);						\
      unw_print_frmask (frstr, frmask);						\
      printf ("\t%s:frgr_mem(grmask=[%s],frmask=[%s])\n", fmt, grstr, frstr);	\
    }										\
  while (0)

#define UNW_DEC_BR_MEM(fmt, brmask, arg)				\
  do									\
    {									\
      char brstr[20];							\
									\
      unw_print_brmask (brstr, brmask);					\
      printf ("\t%s:br_mem(brmask=[%s])\n", fmt, brstr);		\
    }									\
  while (0)

#define UNW_DEC_BR_GR(fmt, brmask, gr, arg)				\
  do									\
    {									\
      char brstr[20];							\
									\
      unw_print_brmask (brstr, brmask);					\
      printf ("\t%s:br_gr(brmask=[%s],gr=r%u)\n", fmt, brstr, gr);	\
    }									\
  while (0)

#define UNW_DEC_REG_GR(fmt, src, dst, arg)		\
  printf ("\t%s:%s_gr(reg=r%u)\n", fmt, src, dst)

#define UNW_DEC_RP_BR(fmt, dst, arg)		\
  printf ("\t%s:rp_br(reg=b%u)\n", fmt, dst)

#define UNW_DEC_REG_WHEN(fmt, reg, t, arg)				\
  printf ("\t%s:%s_when(t=%lu)\n", fmt, reg, (unsigned long) t)

#define UNW_DEC_REG_SPREL(fmt, reg, spoff, arg)		\
  printf ("\t%s:%s_sprel(spoff=0x%lx)\n",		\
	  fmt, reg, 4*(unsigned long)spoff)

#define UNW_DEC_REG_PSPREL(fmt, reg, pspoff, arg)		\
  printf ("\t%s:%s_psprel(pspoff=0x10-0x%lx)\n",		\
	  fmt, reg, 4*(unsigned long)pspoff)

#define UNW_DEC_GR_GR(fmt, grmask, gr, arg)				\
  do									\
    {									\
      char grstr[20];							\
									\
      unw_print_grmask (grstr, grmask);					\
      printf ("\t%s:gr_gr(grmask=[%s],r%u)\n", fmt, grstr, gr);		\
    }									\
  while (0)

#define UNW_DEC_ABI(fmt, abi, context, arg)			\
  do								\
    {								\
      static const char * const abiname[] =			\
      {								\
	"@@svr4", "@@hpux", "@@nt"					\
      };							\
      char buf[20];						\
      const char *abistr = buf;					\
								\
      if (abi < 3)						\
	abistr = abiname[abi];					\
      else							\
	sprintf (buf, "0x%x", abi);				\
      printf ("\t%s:unwabi(abi=%s,context=0x%02x)\n",		\
	      fmt, abistr, context);				\
    }								\
  while (0)

#define UNW_DEC_PRIUNAT_GR(fmt, r, arg)		\
  printf ("\t%s:priunat_gr(reg=r%u)\n", fmt, r)

#define UNW_DEC_PRIUNAT_WHEN_GR(fmt, t, arg)				\
  printf ("\t%s:priunat_when_gr(t=%lu)\n", fmt, (unsigned long) t)

#define UNW_DEC_PRIUNAT_WHEN_MEM(fmt, t, arg)				\
  printf ("\t%s:priunat_when_mem(t=%lu)\n", fmt, (unsigned long) t)

#define UNW_DEC_PRIUNAT_PSPREL(fmt, pspoff, arg)		\
  printf ("\t%s:priunat_psprel(pspoff=0x10-0x%lx)\n",		\
	  fmt, 4*(unsigned long)pspoff)

#define UNW_DEC_PRIUNAT_SPREL(fmt, spoff, arg)		\
  printf ("\t%s:priunat_sprel(spoff=0x%lx)\n",		\
	  fmt, 4*(unsigned long)spoff)

#define UNW_DEC_MEM_STACK_F(fmt, t, size, arg)		\
  printf ("\t%s:mem_stack_f(t=%lu,size=%lu)\n",		\
	  fmt, (unsigned long) t, 16*(unsigned long)size)

#define UNW_DEC_MEM_STACK_V(fmt, t, arg)				\
  printf ("\t%s:mem_stack_v(t=%lu)\n", fmt, (unsigned long) t)

#define UNW_DEC_SPILL_BASE(fmt, pspoff, arg)			\
  printf ("\t%s:spill_base(pspoff=0x10-0x%lx)\n",		\
	  fmt, 4*(unsigned long)pspoff)

#define UNW_DEC_SPILL_MASK(fmt, dp, arg)					\
  do										\
    {										\
      static const char *spill_type = "-frb";					\
      unsigned const char *imaskp = dp;					\
      unsigned char mask = 0;							\
      bfd_vma insn = 0;								\
										\
      printf ("\t%s:spill_mask(imask=[", fmt);					\
      for (insn = 0; insn < unw_rlen; ++insn)					\
	{									\
	  if ((insn % 4) == 0)							\
	    mask = *imaskp++;							\
	  if (insn > 0 && (insn % 3) == 0)					\
	    putchar (',');							\
	  putchar (spill_type[(mask >> (2 * (3 - (insn & 0x3)))) & 0x3]);	\
	}									\
      printf ("])\n");								\
      dp = imaskp;								\
    }										\
  while (0)

#define UNW_DEC_SPILL_SPREL(fmt, t, abreg, spoff, arg)				\
  do										\
    {										\
      char regname[20];								\
										\
      unw_print_abreg (regname, abreg);						\
      printf ("\t%s:spill_sprel(reg=%s,t=%lu,spoff=0x%lx)\n",			\
	      fmt, regname, (unsigned long) t, 4*(unsigned long)off);		\
    }										\
  while (0)

#define UNW_DEC_SPILL_PSPREL(fmt, t, abreg, pspoff, arg)			\
  do										\
    {										\
      char regname[20];								\
										\
      unw_print_abreg (regname, abreg);						\
      printf ("\t%s:spill_psprel(reg=%s,t=%lu,pspoff=0x10-0x%lx)\n",		\
	      fmt, regname, (unsigned long) t, 4*(unsigned long)pspoff);	\
    }										\
  while (0)

#define UNW_DEC_RESTORE(fmt, t, abreg, arg)			\
  do								\
    {								\
      char regname[20];						\
								\
      unw_print_abreg (regname, abreg);				\
      printf ("\t%s:restore(t=%lu,reg=%s)\n",			\
	      fmt, (unsigned long) t, regname);			\
    }								\
  while (0)

#define UNW_DEC_SPILL_REG(fmt, t, abreg, x, ytreg, arg)		\
  do								\
    {								\
      char abregname[20], tregname[20];				\
								\
      unw_print_abreg (abregname, abreg);			\
      unw_print_xyreg (tregname, x, ytreg);			\
      printf ("\t%s:spill_reg(t=%lu,reg=%s,treg=%s)\n",		\
	      fmt, (unsigned long) t, abregname, tregname);	\
    }								\
  while (0)

#define UNW_DEC_SPILL_SPREL_P(fmt, qp, t, abreg, spoff, arg)			    \
  do										    \
    {										    \
      char regname[20];								    \
										    \
      unw_print_abreg (regname, abreg);						    \
      printf ("\t%s:spill_sprel_p(qp=p%u,t=%lu,reg=%s,spoff=0x%lx)\n",		    \
	      fmt, qp, (unsigned long) t, regname, 4 * (unsigned long)spoff);	    \
    }										    \
  while (0)

#define UNW_DEC_SPILL_PSPREL_P(fmt, qp, t, abreg, pspoff, arg)		\
  do									\
    {									\
      char regname[20];							\
									\
      unw_print_abreg (regname, abreg);					\
      printf ("\t%s:spill_psprel_p(qp=p%u,t=%lu,reg=%s,pspoff=0x10-0x%lx)\n",\
	      fmt, qp, (unsigned long) t, regname, 4*(unsigned long)pspoff);\
    }									\
  while (0)

#define UNW_DEC_RESTORE_P(fmt, qp, t, abreg, arg)			\
  do									\
    {									\
      char regname[20];							\
									\
      unw_print_abreg (regname, abreg);					\
      printf ("\t%s:restore_p(qp=p%u,t=%lu,reg=%s)\n",			\
	      fmt, qp, (unsigned long) t, regname);			\
    }									\
  while (0)

#define UNW_DEC_SPILL_REG_P(fmt, qp, t, abreg, x, ytreg, arg)		\
  do									\
    {									\
      char regname[20], tregname[20];					\
									\
      unw_print_abreg (regname, abreg);					\
      unw_print_xyreg (tregname, x, ytreg);				\
      printf ("\t%s:spill_reg_p(qp=p%u,t=%lu,reg=%s,treg=%s)\n",	\
	      fmt, qp, (unsigned long) t, regname, tregname);		\
    }									\
  while (0)

#define UNW_DEC_LABEL_STATE(fmt, label, arg)				\
  printf ("\t%s:label_state(label=%lu)\n", fmt, (unsigned long) label)

#define UNW_DEC_COPY_STATE(fmt, label, arg)				\
  printf ("\t%s:copy_state(label=%lu)\n", fmt, (unsigned long) label)

#define UNW_DEC_EPILOGUE(fmt, t, ecount, arg)		\
  printf ("\t%s:epilogue(t=%lu,ecount=%lu)\n",		\
	  fmt, (unsigned long) t, (unsigned long) ecount)

/*
 * Generic IA-64 unwind info decoder.
 *
 * This file is used both by the Linux kernel and objdump.  Please
 * keep the two copies of this file in sync (modulo differences in the
 * prototypes...).
 *
 * You need to customize the decoder by defining the following
 * macros/constants before including this file:
 *
 *  Types:
 *	unw_word	Unsigned integer type with at least 64 bits
 *
 *  Register names:
 *	UNW_REG_BSP
 *	UNW_REG_BSPSTORE
 *	UNW_REG_FPSR
 *	UNW_REG_LC
 *	UNW_REG_PFS
 *	UNW_REG_PR
 *	UNW_REG_RNAT
 *	UNW_REG_PSP
 *	UNW_REG_RP
 *	UNW_REG_UNAT
 *
 *  Decoder action macros:
 *	UNW_DEC_BAD_CODE(code)
 *	UNW_DEC_ABI(fmt,abi,context,arg)
 *	UNW_DEC_BR_GR(fmt,brmask,gr,arg)
 *	UNW_DEC_BR_MEM(fmt,brmask,arg)
 *	UNW_DEC_COPY_STATE(fmt,label,arg)
 *	UNW_DEC_EPILOGUE(fmt,t,ecount,arg)
 *	UNW_DEC_FRGR_MEM(fmt,grmask,frmask,arg)
 *	UNW_DEC_FR_MEM(fmt,frmask,arg)
 *	UNW_DEC_GR_GR(fmt,grmask,gr,arg)
 *	UNW_DEC_GR_MEM(fmt,grmask,arg)
 *	UNW_DEC_LABEL_STATE(fmt,label,arg)
 *	UNW_DEC_MEM_STACK_F(fmt,t,size,arg)
 *	UNW_DEC_MEM_STACK_V(fmt,t,arg)
 *	UNW_DEC_PRIUNAT_GR(fmt,r,arg)
 *	UNW_DEC_PRIUNAT_WHEN_GR(fmt,t,arg)
 *	UNW_DEC_PRIUNAT_WHEN_MEM(fmt,t,arg)
 *	UNW_DEC_PRIUNAT_WHEN_PSPREL(fmt,pspoff,arg)
 *	UNW_DEC_PRIUNAT_WHEN_SPREL(fmt,spoff,arg)
 *	UNW_DEC_PROLOGUE(fmt,body,rlen,arg)
 *	UNW_DEC_PROLOGUE_GR(fmt,rlen,mask,grsave,arg)
 *	UNW_DEC_REG_PSPREL(fmt,reg,pspoff,arg)
 *	UNW_DEC_REG_REG(fmt,src,dst,arg)
 *	UNW_DEC_REG_SPREL(fmt,reg,spoff,arg)
 *	UNW_DEC_REG_WHEN(fmt,reg,t,arg)
 *	UNW_DEC_RESTORE(fmt,t,abreg,arg)
 *	UNW_DEC_RESTORE_P(fmt,qp,t,abreg,arg)
 *	UNW_DEC_SPILL_BASE(fmt,pspoff,arg)
 *	UNW_DEC_SPILL_MASK(fmt,imaskp,arg)
 *	UNW_DEC_SPILL_PSPREL(fmt,t,abreg,pspoff,arg)
 *	UNW_DEC_SPILL_PSPREL_P(fmt,qp,t,abreg,pspoff,arg)
 *	UNW_DEC_SPILL_REG(fmt,t,abreg,x,ytreg,arg)
 *	UNW_DEC_SPILL_REG_P(fmt,qp,t,abreg,x,ytreg,arg)
 *	UNW_DEC_SPILL_SPREL(fmt,t,abreg,spoff,arg)
 *	UNW_DEC_SPILL_SPREL_P(fmt,qp,t,abreg,pspoff,arg)
 */

static unw_word unw_decode_uleb128 (const unsigned char **);
static const unsigned char *unw_decode_x1
  (const unsigned char *, unsigned int, void *);
static const unsigned char *unw_decode_x2
  (const unsigned char *, unsigned int, void *);
static const unsigned char *unw_decode_x3
  (const unsigned char *, unsigned int, void *);
static const unsigned char *unw_decode_x4
  (const unsigned char *, unsigned int, void *);
static const unsigned char *unw_decode_r1
  (const unsigned char *, unsigned int, void *);
static const unsigned char *unw_decode_r2
  (const unsigned char *, unsigned int, void *);
static const unsigned char *unw_decode_r3
  (const unsigned char *, unsigned int, void *);
static const unsigned char *unw_decode_p1
  (const unsigned char *, unsigned int, void *);
static const unsigned char *unw_decode_p2_p5
  (const unsigned char *, unsigned int, void *);
static const unsigned char *unw_decode_p6
  (const unsigned char *, unsigned int, void *);
static const unsigned char *unw_decode_p7_p10
  (const unsigned char *, unsigned int, void *);
static const unsigned char *unw_decode_b1
  (const unsigned char *, unsigned int, void *);
static const unsigned char *unw_decode_b2
  (const unsigned char *, unsigned int, void *);
static const unsigned char *unw_decode_b3_x4
  (const unsigned char *, unsigned int, void *);

static unw_word
unw_decode_uleb128 (const unsigned char **dpp)
{
  unsigned shift = 0;
  unw_word byte, result = 0;
  const unsigned char *bp = *dpp;

  while (1)
    {
      byte = *bp++;
      result |= (byte & 0x7f) << shift;

      if ((byte & 0x80) == 0)
	break;

      shift += 7;
    }

  *dpp = bp;

  return result;
}

static const unsigned char *
unw_decode_x1 (const unsigned char *dp, unsigned int code ATTRIBUTE_UNUSED,
	       void *arg ATTRIBUTE_UNUSED)
{
  unsigned char byte1, abreg;
  unw_word t, off;

  byte1 = *dp++;
  t = unw_decode_uleb128 (&dp);
  off = unw_decode_uleb128 (&dp);
  abreg = (byte1 & 0x7f);
  if (byte1 & 0x80)
    UNW_DEC_SPILL_SPREL ("X1", t, abreg, off, arg);
  else
    UNW_DEC_SPILL_PSPREL ("X1", t, abreg, off, arg);
  return dp;
}

static const unsigned char *
unw_decode_x2 (const unsigned char *dp, unsigned int code ATTRIBUTE_UNUSED,
	       void *arg ATTRIBUTE_UNUSED)
{
  unsigned char byte1, byte2, abreg, x, ytreg;
  unw_word t;

  byte1 = *dp++;
  byte2 = *dp++;
  t = unw_decode_uleb128 (&dp);
  abreg = (byte1 & 0x7f);
  ytreg = byte2;
  x = (byte1 >> 7) & 1;
  if ((byte1 & 0x80) == 0 && ytreg == 0)
    UNW_DEC_RESTORE ("X2", t, abreg, arg);
  else
    UNW_DEC_SPILL_REG ("X2", t, abreg, x, ytreg, arg);
  return dp;
}

static const unsigned char *
unw_decode_x3 (const unsigned char *dp, unsigned int code ATTRIBUTE_UNUSED,
	       void *arg ATTRIBUTE_UNUSED)
{
  unsigned char byte1, byte2, abreg, qp;
  unw_word t, off;

  byte1 = *dp++;
  byte2 = *dp++;
  t = unw_decode_uleb128 (&dp);
  off = unw_decode_uleb128 (&dp);

  qp = (byte1 & 0x3f);
  abreg = (byte2 & 0x7f);

  if (byte1 & 0x80)
    UNW_DEC_SPILL_SPREL_P ("X3", qp, t, abreg, off, arg);
  else
    UNW_DEC_SPILL_PSPREL_P ("X3", qp, t, abreg, off, arg);
  return dp;
}

static const unsigned char *
unw_decode_x4 (const unsigned char *dp, unsigned int code ATTRIBUTE_UNUSED,
	       void *arg ATTRIBUTE_UNUSED)
{
  unsigned char byte1, byte2, byte3, qp, abreg, x, ytreg;
  unw_word t;

  byte1 = *dp++;
  byte2 = *dp++;
  byte3 = *dp++;
  t = unw_decode_uleb128 (&dp);

  qp = (byte1 & 0x3f);
  abreg = (byte2 & 0x7f);
  x = (byte2 >> 7) & 1;
  ytreg = byte3;

  if ((byte2 & 0x80) == 0 && byte3 == 0)
    UNW_DEC_RESTORE_P ("X4", qp, t, abreg, arg);
  else
    UNW_DEC_SPILL_REG_P ("X4", qp, t, abreg, x, ytreg, arg);
  return dp;
}

static const unsigned char *
unw_decode_r1 (const unsigned char *dp, unsigned int code, void *arg)
{
  int body = (code & 0x20) != 0;
  unw_word rlen;

  rlen = (code & 0x1f);
  UNW_DEC_PROLOGUE ("R1", body, rlen, arg);
  return dp;
}

static const unsigned char *
unw_decode_r2 (const unsigned char *dp, unsigned int code, void *arg)
{
  unsigned char byte1, mask, grsave;
  unw_word rlen;

  byte1 = *dp++;

  mask = ((code & 0x7) << 1) | ((byte1 >> 7) & 1);
  grsave = (byte1 & 0x7f);
  rlen = unw_decode_uleb128 (& dp);
  UNW_DEC_PROLOGUE_GR ("R2", rlen, mask, grsave, arg);
  return dp;
}

static const unsigned char *
unw_decode_r3 (const unsigned char *dp, unsigned int code, void *arg)
{
  unw_word rlen;

  rlen = unw_decode_uleb128 (& dp);
  UNW_DEC_PROLOGUE ("R3", ((code & 0x3) == 1), rlen, arg);
  return dp;
}

static const unsigned char *
unw_decode_p1 (const unsigned char *dp, unsigned int code,
	       void *arg ATTRIBUTE_UNUSED)
{
  unsigned char brmask = (code & 0x1f);

  UNW_DEC_BR_MEM ("P1", brmask, arg);
  return dp;
}

static const unsigned char *
unw_decode_p2_p5 (const unsigned char *dp, unsigned int code,
		  void *arg ATTRIBUTE_UNUSED)
{
  if ((code & 0x10) == 0)
    {
      unsigned char byte1 = *dp++;

      UNW_DEC_BR_GR ("P2", ((code & 0xf) << 1) | ((byte1 >> 7) & 1),
		     (byte1 & 0x7f), arg);
    }
  else if ((code & 0x08) == 0)
    {
      unsigned char byte1 = *dp++, r, dst;

      r = ((code & 0x7) << 1) | ((byte1 >> 7) & 1);
      dst = (byte1 & 0x7f);
      switch (r)
	{
	case 0:
	  UNW_DEC_REG_GR ("P3", UNW_REG_PSP, dst, arg);
	  break;
	case 1:
	  UNW_DEC_REG_GR ("P3", UNW_REG_RP, dst, arg);
	  break;
	case 2:
	  UNW_DEC_REG_GR ("P3", UNW_REG_PFS, dst, arg);
	  break;
	case 3:
	  UNW_DEC_REG_GR ("P3", UNW_REG_PR, dst, arg);
	  break;
	case 4:
	  UNW_DEC_REG_GR ("P3", UNW_REG_UNAT, dst, arg);
	  break;
	case 5:
	  UNW_DEC_REG_GR ("P3", UNW_REG_LC, dst, arg);
	  break;
	case 6:
	  UNW_DEC_RP_BR ("P3", dst, arg);
	  break;
	case 7:
	  UNW_DEC_REG_GR ("P3", UNW_REG_RNAT, dst, arg);
	  break;
	case 8:
	  UNW_DEC_REG_GR ("P3", UNW_REG_BSP, dst, arg);
	  break;
	case 9:
	  UNW_DEC_REG_GR ("P3", UNW_REG_BSPSTORE, dst, arg);
	  break;
	case 10:
	  UNW_DEC_REG_GR ("P3", UNW_REG_FPSR, dst, arg);
	  break;
	case 11:
	  UNW_DEC_PRIUNAT_GR ("P3", dst, arg);
	  break;
	default:
	  UNW_DEC_BAD_CODE (r);
	  break;
	}
    }
  else if ((code & 0x7) == 0)
    UNW_DEC_SPILL_MASK ("P4", dp, arg);
  else if ((code & 0x7) == 1)
    {
      unw_word grmask, frmask, byte1, byte2, byte3;

      byte1 = *dp++;
      byte2 = *dp++;
      byte3 = *dp++;
      grmask = ((byte1 >> 4) & 0xf);
      frmask = ((byte1 & 0xf) << 16) | (byte2 << 8) | byte3;
      UNW_DEC_FRGR_MEM ("P5", grmask, frmask, arg);
    }
  else
    UNW_DEC_BAD_CODE (code);

  return dp;
}

static const unsigned char *
unw_decode_p6 (const unsigned char *dp, unsigned int code,
	       void *arg ATTRIBUTE_UNUSED)
{
  int gregs = (code & 0x10) != 0;
  unsigned char mask = (code & 0x0f);

  if (gregs)
    UNW_DEC_GR_MEM ("P6", mask, arg);
  else
    UNW_DEC_FR_MEM ("P6", mask, arg);
  return dp;
}

static const unsigned char *
unw_decode_p7_p10 (const unsigned char *dp, unsigned int code, void *arg)
{
  unsigned char r, byte1, byte2;
  unw_word t, size;

  if ((code & 0x10) == 0)
    {
      r = (code & 0xf);
      t = unw_decode_uleb128 (&dp);
      switch (r)
	{
	case 0:
	  size = unw_decode_uleb128 (&dp);
	  UNW_DEC_MEM_STACK_F ("P7", t, size, arg);
	  break;

	case 1:
	  UNW_DEC_MEM_STACK_V ("P7", t, arg);
	  break;
	case 2:
	  UNW_DEC_SPILL_BASE ("P7", t, arg);
	  break;
	case 3:
	  UNW_DEC_REG_SPREL ("P7", UNW_REG_PSP, t, arg);
	  break;
	case 4:
	  UNW_DEC_REG_WHEN ("P7", UNW_REG_RP, t, arg);
	  break;
	case 5:
	  UNW_DEC_REG_PSPREL ("P7", UNW_REG_RP, t, arg);
	  break;
	case 6:
	  UNW_DEC_REG_WHEN ("P7", UNW_REG_PFS, t, arg);
	  break;
	case 7:
	  UNW_DEC_REG_PSPREL ("P7", UNW_REG_PFS, t, arg);
	  break;
	case 8:
	  UNW_DEC_REG_WHEN ("P7", UNW_REG_PR, t, arg);
	  break;
	case 9:
	  UNW_DEC_REG_PSPREL ("P7", UNW_REG_PR, t, arg);
	  break;
	case 10:
	  UNW_DEC_REG_WHEN ("P7", UNW_REG_LC, t, arg);
	  break;
	case 11:
	  UNW_DEC_REG_PSPREL ("P7", UNW_REG_LC, t, arg);
	  break;
	case 12:
	  UNW_DEC_REG_WHEN ("P7", UNW_REG_UNAT, t, arg);
	  break;
	case 13:
	  UNW_DEC_REG_PSPREL ("P7", UNW_REG_UNAT, t, arg);
	  break;
	case 14:
	  UNW_DEC_REG_WHEN ("P7", UNW_REG_FPSR, t, arg);
	  break;
	case 15:
	  UNW_DEC_REG_PSPREL ("P7", UNW_REG_FPSR, t, arg);
	  break;
	default:
	  UNW_DEC_BAD_CODE (r);
	  break;
	}
    }
  else
    {
      switch (code & 0xf)
	{
	case 0x0:		/* p8 */
	  {
	    r = *dp++;
	    t = unw_decode_uleb128 (&dp);
	    switch (r)
	      {
	      case 1:
		UNW_DEC_REG_SPREL ("P8", UNW_REG_RP, t, arg);
		break;
	      case 2:
		UNW_DEC_REG_SPREL ("P8", UNW_REG_PFS, t, arg);
		break;
	      case 3:
		UNW_DEC_REG_SPREL ("P8", UNW_REG_PR, t, arg);
		break;
	      case 4:
		UNW_DEC_REG_SPREL ("P8", UNW_REG_LC, t, arg);
		break;
	      case 5:
		UNW_DEC_REG_SPREL ("P8", UNW_REG_UNAT, t, arg);
		break;
	      case 6:
		UNW_DEC_REG_SPREL ("P8", UNW_REG_FPSR, t, arg);
		break;
	      case 7:
		UNW_DEC_REG_WHEN ("P8", UNW_REG_BSP, t, arg);
		break;
	      case 8:
		UNW_DEC_REG_PSPREL ("P8", UNW_REG_BSP, t, arg);
		break;
	      case 9:
		UNW_DEC_REG_SPREL ("P8", UNW_REG_BSP, t, arg);
		break;
	      case 10:
		UNW_DEC_REG_WHEN ("P8", UNW_REG_BSPSTORE, t, arg);
		break;
	      case 11:
		UNW_DEC_REG_PSPREL ("P8", UNW_REG_BSPSTORE, t, arg);
		break;
	      case 12:
		UNW_DEC_REG_SPREL ("P8", UNW_REG_BSPSTORE, t, arg);
		break;
	      case 13:
		UNW_DEC_REG_WHEN ("P8", UNW_REG_RNAT, t, arg);
		break;
	      case 14:
		UNW_DEC_REG_PSPREL ("P8", UNW_REG_RNAT, t, arg);
		break;
	      case 15:
		UNW_DEC_REG_SPREL ("P8", UNW_REG_RNAT, t, arg);
		break;
	      case 16:
		UNW_DEC_PRIUNAT_WHEN_GR ("P8", t, arg);
		break;
	      case 17:
		UNW_DEC_PRIUNAT_PSPREL ("P8", t, arg);
		break;
	      case 18:
		UNW_DEC_PRIUNAT_SPREL ("P8", t, arg);
		break;
	      case 19:
		UNW_DEC_PRIUNAT_WHEN_MEM ("P8", t, arg);
		break;
	      default:
		UNW_DEC_BAD_CODE (r);
		break;
	      }
	  }
	  break;

	case 0x1:
	  byte1 = *dp++;
	  byte2 = *dp++;
	  UNW_DEC_GR_GR ("P9", (byte1 & 0xf), (byte2 & 0x7f), arg);
	  break;

	case 0xf:		/* p10 */
	  byte1 = *dp++;
	  byte2 = *dp++;
	  UNW_DEC_ABI ("P10", byte1, byte2, arg);
	  break;

	case 0x9:
	  return unw_decode_x1 (dp, code, arg);

	case 0xa:
	  return unw_decode_x2 (dp, code, arg);

	case 0xb:
	  return unw_decode_x3 (dp, code, arg);

	case 0xc:
	  return unw_decode_x4 (dp, code, arg);

	default:
	  UNW_DEC_BAD_CODE (code);
	  break;
	}
    }
  return dp;
}

static const unsigned char *
unw_decode_b1 (const unsigned char *dp, unsigned int code,
	       void *arg ATTRIBUTE_UNUSED)
{
  unw_word label = (code & 0x1f);

  if ((code & 0x20) != 0)
    UNW_DEC_COPY_STATE ("B1", label, arg);
  else
    UNW_DEC_LABEL_STATE ("B1", label, arg);
  return dp;
}

static const unsigned char *
unw_decode_b2 (const unsigned char *dp, unsigned int code,
	       void *arg ATTRIBUTE_UNUSED)
{
  unw_word t;

  t = unw_decode_uleb128 (& dp);
  UNW_DEC_EPILOGUE ("B2", t, (code & 0x1f), arg);
  return dp;
}

static const unsigned char *
unw_decode_b3_x4 (const unsigned char *dp, unsigned int code, void *arg)
{
  unw_word t, ecount, label;

  if ((code & 0x10) == 0)
    {
      t = unw_decode_uleb128 (&dp);
      ecount = unw_decode_uleb128 (&dp);
      UNW_DEC_EPILOGUE ("B3", t, ecount, arg);
    }
  else if ((code & 0x07) == 0)
    {
      label = unw_decode_uleb128 (&dp);
      if ((code & 0x08) != 0)
	UNW_DEC_COPY_STATE ("B4", label, arg);
      else
	UNW_DEC_LABEL_STATE ("B4", label, arg);
    }
  else
    switch (code & 0x7)
      {
      case 1:
	return unw_decode_x1 (dp, code, arg);
      case 2:
	return unw_decode_x2 (dp, code, arg);
      case 3:
	return unw_decode_x3 (dp, code, arg);
      case 4:
	return unw_decode_x4 (dp, code, arg);
      default:
	UNW_DEC_BAD_CODE (code);
	break;
      }
  return dp;
}

typedef const unsigned char *(*unw_decoder)
     (const unsigned char *, unsigned int, void *);

static const unw_decoder unw_decode_table[2][8] =
  {
    /* prologue table: */
    {
      unw_decode_r1,		/* 0 */
      unw_decode_r1,
      unw_decode_r2,
      unw_decode_r3,
      unw_decode_p1,		/* 4 */
      unw_decode_p2_p5,
      unw_decode_p6,
      unw_decode_p7_p10
    },
    {
      unw_decode_r1,		/* 0 */
      unw_decode_r1,
      unw_decode_r2,
      unw_decode_r3,
      unw_decode_b1,		/* 4 */
      unw_decode_b1,
      unw_decode_b2,
      unw_decode_b3_x4
    }
  };

/* Decode one descriptor and return address of next descriptor.  */
const unsigned char *
unw_decode (const unsigned char *dp, int inside_body,
	    void *ptr_inside_body)
{
  unw_decoder decoder;
  unsigned char code;

  code = *dp++;
  decoder = unw_decode_table[inside_body][code >> 5];
  return (*decoder) (dp, code, ptr_inside_body);
}
@


1.17
log
@2010-06-11  Tristan Gingold  <gingold@@adacore.com>

	* unwind-ia64.c (unw_print_abreg): Add const to special_reg.
	(UNW_DEC_ABI): Ditto for abiname.
	(unw_decode_table): Make it const.
@
text
@d2 4
a5 2
   Copyright 2000, 2001, 2002, 2003, 2005, 2007 Free Software Foundation, Inc.
	Contributed by David Mosberger-Tang <davidm@@hpl.hp.com>
d24 1
@


1.16
log
@update copyright dates
@
text
@d115 1
a115 1
  static const char *special_reg[16] =
d306 1
a306 1
      static const char *abiname[] =				\
d1047 1
a1047 1
static unw_decoder unw_decode_table[2][8] =
@


1.15
log
@Change sources over to using GPLv3
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003, 2007 Free Software Foundation, Inc.
@


1.14
log
@	* unwind-ia64.c (UNW_DEC_SPILL_SPREL, UNW_DEC_SPILL_PSPREL,
	UNW_DEC_RESTORE, UNW_DEC_SPILL_REG): Increase {,ab,t}regname
	buffer sizes.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d5 1
a5 1
This file is part of GNU Binutils.
d7 14
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.13
log
@Update FSF address
@
text
@d374 1
a374 1
      char regname[10];								\
d385 1
a385 1
      char regname[10];								\
d396 1
a396 1
      char regname[10];						\
d407 1
a407 1
      char abregname[10], tregname[10];				\
@


1.12
log
@update copyright dates
@
text
@d19 1
a19 1
Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.11
log
@	* ChangeLog-9197: Fix comment typos.
	* coffgrok.c: Likewise.
	* filemode.c: Likewise.
	* objcopy.c: Likewise.
	* objdump.c: Likewise.
	* prdbg.c: Likewise.
	* stabs.c: Likewise.
	* unwind-ia64.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 2000, 2001, 2003 Free Software Foundation, Inc.
@


1.10
log
@	* addr2line.c: Convert to ISO C90 prototypes, change PTR, remove
	unneeded (void *) casts.
	* ar.c: Likewise.
	* arlex.l: Likewise.
	* arparse.y: Likewise.
	* arsup.c: Likewise.
	* binemul.c: Likewise.
	* binemul.h: Likewise.
	* bucomm.c: Likewise.
	* bucomm.h: Likewise.
	* budbg.h: Likewise.
	* budemang.c: Likewise.
	* budemang.h: Likewise.
	* coffdump.c: Likewise.
	* coffgrok.c: Likewise.
	* cxxfilt.c: Likewise.
	* debug.c: Likewise.
	* debug.h: Likewise.
	* deflex.l: Likewise.
	* dlltool.c: Likewise.
	* dlltool.h: Likewise.
	* dllwrap.c: Likewise.
	* emul_aix.c: Likewise.
	* filemode.c: Likewise.
	* ieee.c: Likewise.
	* nlmconv.c: Likewise.
	* nlmconv.h: Likewise.
	* nlmheader.y: Likewise.
	* nm.c: Likewise.
	* prdbg.c: Likewise.
	* rclex.l: Likewise.
	* rcparse.y: Likewise.
	* rdcoff.c: Likewise.
	* rddbg.c: Likewise.
	* rename.c: Likewise.
	* resbin.c: Likewise.
	* rescoff.c: Likewise.
	* resrc.c: Likewise.
	* size.c: Likewise.
	* srconv.c: Likewise.
	* stabs.c: Likewise.
	* strings.c: Likewise.
	* sysdump.c: Likewise.
	* sysinfo.y: Likewise.
	* syslex.l: Likewise.
	* unwind-ia64.c: Likewise.
	* unwind-ia64.h: Likewise.
	* version.c: Likewise.
	* windres.c: Likewise.
	* windres.h: Likewise.
	* winduni.c: Likewise.
	* wrstabs.c: Likewise.
@
text
@d28 1
a28 1
   Only do this if we belive that the compiler can support a 64 bit
@


1.9
log
@	* unwind-ia64.c (unw_print_brmask): Don't use sprintf.
	(unw_print_grmask): Likewise.
	(unw_print_frmask): Likewise.
@
text
@d2 1
a2 1
   Copyright 2000, 2001 Free Software Foundation, Inc.
d36 5
a40 5
static void unw_print_brmask PARAMS ((char *, unsigned int));
static void unw_print_grmask PARAMS ((char *, unsigned int));
static void unw_print_frmask PARAMS ((char *, unsigned int));
static void unw_print_abreg PARAMS ((char *, unsigned int));
static void unw_print_xyreg PARAMS ((char *, unsigned int, unsigned int));
d43 1
a43 3
unw_print_brmask (cp, mask)
     char * cp;
     unsigned int mask;
d64 1
a64 3
unw_print_grmask (cp, mask)
     char * cp;
     unsigned int mask;
d85 1
a85 3
unw_print_frmask (cp, mask)
     char * cp;
     unsigned int mask;
d112 1
a112 3
unw_print_abreg (cp, abreg)
     char * cp;
     unsigned int abreg;
d142 1
a142 4
unw_print_xyreg (cp, x, ytreg)
     char *        cp;
     unsigned int x;
     unsigned int ytreg;
d244 1
a244 1
#define UNW_DEC_FRGR_MEM(fmt, grmask, frmask, arg)			     	\
d246 1
a246 1
    {									     	\
d248 3
a250 3
									     	\
      unw_print_grmask (grstr, grmask);					     	\
      unw_print_frmask (frstr, frmask);					     	\
d352 2
a353 2
      static const char * spill_type = "-frb";					\
      unsigned const char * imaskp = dp;					\
d382 1
a382 1
#define UNW_DEC_SPILL_PSPREL(fmt, t, abreg, pspoff, arg)		 	\
d384 5
a388 5
    {									 	\
      char regname[10];							 	\
									 	\
      unw_print_abreg (regname, abreg);					 	\
      printf ("\t%s:spill_psprel(reg=%s,t=%lu,pspoff=0x10-0x%lx)\n", 		\
d416 1
a416 1
#define UNW_DEC_SPILL_SPREL_P(fmt, qp, t, abreg, spoff, arg)		   	    \
d418 4
a421 4
    {									   	    \
      char regname[20];							   	    \
									   	    \
      unw_print_abreg (regname, abreg);					   	    \
d533 29
a561 29
static unw_word unw_decode_uleb128 PARAMS ((const unsigned char **));
static const unsigned char *unw_decode_x1 PARAMS ((const unsigned char *,
						   unsigned int, void *));
static const unsigned char *unw_decode_x2 PARAMS ((const unsigned char *,
						   unsigned int, void *));
static const unsigned char *unw_decode_x3 PARAMS ((const unsigned char *,
						   unsigned int, void *));
static const unsigned char *unw_decode_x4 PARAMS ((const unsigned char *,
						   unsigned int, void *));
static const unsigned char *unw_decode_r1 PARAMS ((const unsigned char *,
						   unsigned int, void *));
static const unsigned char *unw_decode_r2 PARAMS ((const unsigned char *,
						   unsigned int, void *));
static const unsigned char *unw_decode_r3 PARAMS ((const unsigned char *,
						   unsigned int, void *));
static const unsigned char *unw_decode_p1 PARAMS ((const unsigned char *,
						   unsigned int, void *));
static const unsigned char *unw_decode_p2_p5 PARAMS ((const unsigned char *,
						      unsigned int, void *));
static const unsigned char *unw_decode_p6 PARAMS ((const unsigned char *,
						   unsigned int, void *));
static const unsigned char *unw_decode_p7_p10 PARAMS ((const unsigned char *,
						       unsigned int, void *));
static const unsigned char *unw_decode_b1 PARAMS ((const unsigned char *,
						   unsigned int, void *));
static const unsigned char *unw_decode_b2 PARAMS ((const unsigned char *,
						   unsigned int, void *));
static const unsigned char *unw_decode_b3_x4 PARAMS ((const unsigned char *,
						      unsigned int, void *));
d564 1
a564 2
unw_decode_uleb128 (dpp)
     const unsigned char **dpp;
d587 2
a588 4
unw_decode_x1 (dp, code, arg)
     const unsigned char * dp;
     unsigned int         code ATTRIBUTE_UNUSED;
     void *                arg ATTRIBUTE_UNUSED;
d605 2
a606 4
unw_decode_x2 (dp, code, arg)
     const unsigned char * dp;
     unsigned int         code ATTRIBUTE_UNUSED;
     void *                arg ATTRIBUTE_UNUSED;
d625 2
a626 4
unw_decode_x3 (dp, code, arg)
     const unsigned char * dp;
     unsigned int         code ATTRIBUTE_UNUSED;
     void *                arg ATTRIBUTE_UNUSED;
d647 2
a648 4
unw_decode_x4 (dp, code, arg)
     const unsigned char * dp;
     unsigned int         code ATTRIBUTE_UNUSED;
     void *                arg ATTRIBUTE_UNUSED;
d671 1
a671 4
unw_decode_r1 (dp, code, arg)
     const unsigned char *dp;
     unsigned int code;
     void *arg;
d682 1
a682 4
unw_decode_r2 (dp, code, arg)
     const unsigned char *dp;
     unsigned int code;
     void *arg;
d697 1
a697 4
unw_decode_r3 (dp, code, arg)
     const unsigned char *dp;
     unsigned int code;
     void *arg;
d707 2
a708 4
unw_decode_p1 (dp, code, arg)
     const unsigned char * dp;
     unsigned int         code;
     void *                arg ATTRIBUTE_UNUSED;
d717 2
a718 4
unw_decode_p2_p5 (dp, code, arg)
     const unsigned char * dp;
     unsigned int         code;
     void *                arg ATTRIBUTE_UNUSED;
d796 2
a797 4
unw_decode_p6 (dp, code, arg)
     const unsigned char * dp;
     unsigned int         code;
     void *                arg ATTRIBUTE_UNUSED;
d810 1
a810 4
unw_decode_p7_p10 (dp, code, arg)
     const unsigned char *dp;
     unsigned int code;
     void *arg;
d983 2
a984 4
unw_decode_b1 (dp, code, arg)
     const unsigned char * dp;
     unsigned int         code;
     void *                arg ATTRIBUTE_UNUSED;
d996 2
a997 4
unw_decode_b2 (dp, code, arg)
     const unsigned char * dp;
     unsigned int         code;
     void *                arg ATTRIBUTE_UNUSED;
d1007 1
a1007 4
unw_decode_b3_x4 (dp, code, arg)
     const unsigned char *dp;
     unsigned int code;
     void *arg;
d1044 1
a1044 1
     PARAMS ((const unsigned char *, unsigned int, void *));
d1073 2
a1074 4
unw_decode (dp, inside_body, ptr_inside_body)
     const unsigned char * dp;
     int                   inside_body;
     void *                ptr_inside_body;
@


1.8
log
@	* size.c: Fix formatting.
	* srconv.c: Likewise.
	* stabs.c: Likewise.
	* sysdump.c: Likewise.
	* unwind-ia64.c: Likewise.
	* wrstabs.c: Likewise.
@
text
@d47 1
a47 1
  char *sep = "";
d54 5
a58 2
	  cp += sprintf (cp, "%sb%u", sep, i + 1);
	  sep = ",";
d70 1
a70 1
  char *sep = "";
a72 1
  *cp = '\0';
d77 5
a81 2
	  cp += sprintf (cp, "%sr%u", sep, i + 4);
	  sep = ",";
d85 1
d93 1
a93 1
  char *sep = "";
a95 1
  *cp = '\0';
d100 11
a110 2
	  cp += sprintf (cp, "%sf%u", sep, (i < 4) ? (i + 2) : (i + 12));
	  sep = ",";
d114 1
@


1.7
log
@2002-01-29  Daniel Jacobowitz  <drow@@mvista.com>

        * unwind-ia64.c (unw_decoder): Change second argument
        to unsigned int, to match function prototypes.
@
text
@d478 1
a478 1
 *	unw_word	Unsigned integer type with at least 64 bits 
@


1.6
log
@        * unwind-ia64.c (unw_print_brmask): Fix ISO C portability glitch.
        (unw_print_grmask, unw_print_frmask, unw_print_abreg): Likewise.
        (unw_print_xyreg, unw_decode_x1, unw_decode_x2): Likewise.
        (unw_decode_x3, unw_decode_r1, unw_decode_r2): Likewise.
        (unw_decode_r3, unw_decode_p1, unw_decode_p2_p5): Likewise.
        (unw_decode_p6, unw_decode_p7_p10, unw_decode_b1): Likewise.
        (unw_decode_b2, unw_decode_b3_b4): Likewise.
@
text
@d1074 1
a1074 1
     PARAMS ((const unsigned char *, unsigned char, void *));
@


1.5
log
@	* coffgrok.h: Add missing parameter for prototype of coff_grok.

	* sysdump.c: Add missing prototypes.
	* srconv.c: Likewise.
	* unwind-ia64.c: Likewise.
	* coffdump.c: Likewise.

	* sysinfo.y: Print prototypes, include <ansidecl.h>.

	* coffgrok.c: Add missing prototypes, include libiberty.h instead
	of declaring xcalloc.
@
text
@d36 5
a40 5
static void unw_print_brmask PARAMS ((char *, unsigned char));
static void unw_print_grmask PARAMS ((char *, unsigned char));
static void unw_print_frmask PARAMS ((char *, long unsigned int));
static void unw_print_abreg PARAMS ((char *, unsigned char));
static void unw_print_xyreg PARAMS ((char *, unsigned char, unsigned char));
d45 1
a45 1
     unsigned char mask;
d65 1
a65 1
     unsigned char mask;
d85 1
a85 1
     unsigned long mask;
d105 1
a105 1
     unsigned char abreg;
d137 2
a138 2
     unsigned char x;
     unsigned char ytreg;
d531 1
a531 1
						   unsigned char, void *));
d533 1
a533 1
						   unsigned char, void *));
d535 1
a535 1
						   unsigned char, void *));
d537 1
a537 1
						   unsigned char, void *));
d539 1
a539 1
						   unsigned char, void *));
d541 1
a541 1
						   unsigned char, void *));
d543 1
a543 1
						   unsigned char, void *));
d545 1
a545 1
						   unsigned char, void *));
d547 1
a547 1
						      unsigned char, void *));
d549 1
a549 1
						   unsigned char, void *));
d551 1
a551 1
						       unsigned char, void *));
d553 1
a553 1
						   unsigned char, void *));
d555 1
a555 1
						   unsigned char, void *));
d557 1
a557 1
						      unsigned char, void *));
d586 1
a586 1
     unsigned char         code ATTRIBUTE_UNUSED;
d606 1
a606 1
     unsigned char         code ATTRIBUTE_UNUSED;
d628 1
a628 1
     unsigned char         code ATTRIBUTE_UNUSED;
d652 1
a652 1
     unsigned char         code ATTRIBUTE_UNUSED;
d678 1
a678 1
     unsigned char code;
d692 1
a692 1
     unsigned char code;
d710 1
a710 1
     unsigned char code;
d723 1
a723 1
     unsigned char         code;
d735 1
a735 1
     unsigned char         code;
d816 1
a816 1
     unsigned char         code;
d832 1
a832 1
     unsigned char code;
d1008 1
a1008 1
     unsigned char         code;
d1023 1
a1023 1
     unsigned char         code;
d1036 1
a1036 1
     unsigned char code;
@


1.4
log
@	* unwind-ia64.c (unw_decode_x1): Add unused attribute for
	parameter 'code'.
	(unw_decode_x2): Likewise.
	(unw_decode_x3): Likewise.
	(unw_decode_x4): Likewise.
@
text
@d36 6
@


1.3
log
@Fix typos in ChangeLogs and update copyright notices
@
text
@d580 1
a580 1
     unsigned char         code;
d600 1
a600 1
     unsigned char         code;
d622 1
a622 1
     unsigned char         code;
d646 1
a646 1
     unsigned char         code;
@


1.3.2.1
log
@	From 2001-02-07  David Mosberger  <davidm@@hpl.hp.com>
	* readelf.c (process_unwind): New function.
	(slurp_ia64_unwind_table): Ditto.
	(dump_ia64_unwind): Ditto.
	(find_symbol_for_address): Ditto.
	(slurp_rela_relocs): New function (split off from dump_relocations()).
	(slurp_rel_relocs): Ditto.
	(parse_args): Handle '-u' option.
	* unwind-ia64.c: New file.
	* unwind-ia64.h: New file.
	* Makefile.am: Include unwind-ia64.c in readelf build.
	* Makefile.in: Regenerate.
	* po/binutils.pot: Regenerate.
@
text
@@


1.2
log
@	* unwind-ia64.c: Don't use ANSI C preprocessor stringisation and string
	literal concatenation.
@
text
@d2 1
a2 1
   Copyright (c) 2000, 2001 Free Software Foundation, Inc.
@


1.1
log
@Add -u option toi readelf to display unwind info.
Add support to display unwind info for IA64 binaries.
@
text
@a162 2
#define STR(x)	#x

d171 2
a172 2
      printf ("    "STR(fmt)":%s(rlen=%lu)\n",					\
	      body ? "body" : "prologue", (unsigned long) rlen);		\
d209 2
a210 2
      printf ("    "STR(fmt)":prologue_gr(mask=[%s],grsave=%s,rlen=%lu)\n",	\
	      maskstr, regname, (unsigned long) rlen);				\
d220 1
a220 1
      printf ("\t"STR(fmt)":fr_mem(frmask=[%s])\n", frstr);	\
d230 1
a230 1
      printf ("\t"STR(fmt)":gr_mem(grmask=[%s])\n", grstr);	\
d241 1
a241 1
      printf ("\t"STR(fmt)":frgr_mem(grmask=[%s],frmask=[%s])\n", grstr, frstr);\
d251 1
a251 1
      printf ("\t"STR(fmt)":br_mem(brmask=[%s])\n", brstr);		\
d261 1
a261 1
      printf ("\t"STR(fmt)":br_gr(brmask=[%s],gr=r%u)\n", brstr, gr);	\
d266 1
a266 1
  printf ("\t"STR(fmt)":%s_gr(reg=r%u)\n", src, dst)
d269 1
a269 1
  printf ("\t"STR(fmt)":rp_br(reg=b%u)\n", dst)
d272 1
a272 1
  printf ("\t"STR(fmt)":%s_when(t=%lu)\n", reg, (unsigned long) t)
d275 2
a276 2
  printf ("\t"STR(fmt)":%s_sprel(spoff=0x%lx)\n",	\
	  reg, 4*(unsigned long)spoff)
d279 2
a280 2
  printf ("\t"STR(fmt)":%s_psprel(pspoff=0x10-0x%lx)\n",	\
	  reg, 4*(unsigned long)pspoff)
d288 1
a288 1
      printf ("\t"STR(fmt)":gr_gr(grmask=[%s],r%u)\n", grstr, gr);	\
d306 2
a307 2
      printf ("\t"STR(fmt)":unwabi(abi=%s,context=0x%02x)\n",	\
	      abistr, context);					\
d312 1
a312 1
  printf ("\t"STR(fmt)":priunat_gr(reg=r%u)\n", r)
d315 1
a315 1
  printf ("\t"STR(fmt)":priunat_when_gr(t=%lu)\n", (unsigned long) t)
d318 1
a318 1
  printf ("\t"STR(fmt)":priunat_when_mem(t=%lu)\n", (unsigned long) t)
d321 2
a322 2
  printf ("\t"STR(fmt)":priunat_psprel(pspoff=0x10-0x%lx)\n",	\
	  4*(unsigned long)pspoff)
d325 2
a326 2
  printf ("\t"STR(fmt)":priunat_sprel(spoff=0x%lx)\n",	\
	  4*(unsigned long)spoff)
d329 2
a330 2
  printf ("\t"STR(fmt)":mem_stack_f(t=%lu,size=%lu)\n",	\
	  (unsigned long) t, 16*(unsigned long)size)
d333 1
a333 1
  printf ("\t"STR(fmt)":mem_stack_v(t=%lu)\n", (unsigned long) t)
d336 2
a337 2
  printf ("\t"STR(fmt)":spill_base(pspoff=0x10-0x%lx)\n",	\
	  4*(unsigned long)pspoff)
d347 1
a347 1
      printf ("\t"STR (fmt)":spill_mask(imask=[");				\
d367 2
a368 2
      printf ("\t"STR(fmt)":spill_sprel(reg=%s,t=%lu,spoff=0x%lx)\n",		\
	      regname, (unsigned long) t, 4*(unsigned long)off);		\
d378 2
a379 2
      printf ("\t"STR(fmt)":spill_psprel(reg=%s,t=%lu,pspoff=0x10-0x%lx)\n", 	\
	      regname, (unsigned long) t, 4*(unsigned long)pspoff);		\
d389 2
a390 2
      printf ("\t"STR(fmt)":restore(t=%lu,reg=%s)\n",		\
	      (unsigned long) t, regname);			\
d401 2
a402 2
      printf ("\t"STR(fmt)":spill_reg(t=%lu,reg=%s,treg=%s)\n",	\
	      (unsigned long) t, abregname, tregname);		\
d412 2
a413 2
      printf ("\t"STR(fmt)":spill_sprel_p(qp=p%u,t=%lu,reg=%s,spoff=0x%lx)\n", 	    \
	      qp, (unsigned long) t, regname, 4 * (unsigned long)spoff);	    \
d423 2
a424 3
      printf ("\t"STR (fmt)						\
	      ":spill_psprel_p(qp=p%u,t=%lu,reg=%s,pspoff=0x10-0x%lx)\n",\
	      qp, (unsigned long) t, regname, 4*(unsigned long)pspoff);	\
d434 2
a435 2
      printf ("\t"STR(fmt)":restore_p(qp=p%u,t=%lu,reg=%s)\n",		\
	      qp, (unsigned long) t, regname);				\
d446 2
a447 2
      printf ("\t"STR(fmt)":spill_reg_p(qp=p%u,t=%lu,reg=%s,treg=%s)\n",\
	      qp, (unsigned long) t, regname, tregname);		\
d452 1
a452 1
  printf ("\t"STR(fmt)":label_state(label=%lu)\n", (unsigned long) label)
d455 1
a455 1
  printf ("\t"STR(fmt)":copy_state(label=%lu)\n", (unsigned long) label)
d458 2
a459 2
  printf ("\t"STR(fmt)":epilogue(t=%lu,ecount=%lu)\n",	\
	  (unsigned long) t, (unsigned long) ecount)
d591 1
a591 1
    UNW_DEC_SPILL_SPREL (X1, t, abreg, off, arg);
d593 1
a593 1
    UNW_DEC_SPILL_PSPREL (X1, t, abreg, off, arg);
d613 1
a613 1
    UNW_DEC_RESTORE (X2, t, abreg, arg);
d615 1
a615 1
    UNW_DEC_SPILL_REG (X2, t, abreg, x, ytreg, arg);
d637 1
a637 1
    UNW_DEC_SPILL_SPREL_P (X3, qp, t, abreg, off, arg);
d639 1
a639 1
    UNW_DEC_SPILL_PSPREL_P (X3, qp, t, abreg, off, arg);
d663 1
a663 1
    UNW_DEC_RESTORE_P (X4, qp, t, abreg, arg);
d665 1
a665 1
    UNW_DEC_SPILL_REG_P (X4, qp, t, abreg, x, ytreg, arg);
d679 1
a679 1
  UNW_DEC_PROLOGUE (R1, body, rlen, arg);
d697 1
a697 1
  UNW_DEC_PROLOGUE_GR (R2, rlen, mask, grsave, arg);
d710 1
a710 1
  UNW_DEC_PROLOGUE (R3, ((code & 0x3) == 1), rlen, arg);
d722 1
a722 1
  UNW_DEC_BR_MEM (P1, brmask, arg);
d736 1
a736 1
      UNW_DEC_BR_GR (P2, ((code & 0xf) << 1) | ((byte1 >> 7) & 1),
d748 1
a748 1
	  UNW_DEC_REG_GR (P3, UNW_REG_PSP, dst, arg);
d751 1
a751 1
	  UNW_DEC_REG_GR (P3, UNW_REG_RP, dst, arg);
d754 1
a754 1
	  UNW_DEC_REG_GR (P3, UNW_REG_PFS, dst, arg);
d757 1
a757 1
	  UNW_DEC_REG_GR (P3, UNW_REG_PR, dst, arg);
d760 1
a760 1
	  UNW_DEC_REG_GR (P3, UNW_REG_UNAT, dst, arg);
d763 1
a763 1
	  UNW_DEC_REG_GR (P3, UNW_REG_LC, dst, arg);
d766 1
a766 1
	  UNW_DEC_RP_BR (P3, dst, arg);
d769 1
a769 1
	  UNW_DEC_REG_GR (P3, UNW_REG_RNAT, dst, arg);
d772 1
a772 1
	  UNW_DEC_REG_GR (P3, UNW_REG_BSP, dst, arg);
d775 1
a775 1
	  UNW_DEC_REG_GR (P3, UNW_REG_BSPSTORE, dst, arg);
d778 1
a778 1
	  UNW_DEC_REG_GR (P3, UNW_REG_FPSR, dst, arg);
d781 1
a781 1
	  UNW_DEC_PRIUNAT_GR (P3, dst, arg);
d789 1
a789 1
    UNW_DEC_SPILL_MASK (P4, dp, arg);
d799 1
a799 1
      UNW_DEC_FRGR_MEM (P5, grmask, frmask, arg);
d817 1
a817 1
    UNW_DEC_GR_MEM (P6, mask, arg);
d819 1
a819 1
    UNW_DEC_FR_MEM (P6, mask, arg);
d840 1
a840 1
	  UNW_DEC_MEM_STACK_F (P7, t, size, arg);
d844 1
a844 1
	  UNW_DEC_MEM_STACK_V (P7, t, arg);
d847 1
a847 1
	  UNW_DEC_SPILL_BASE (P7, t, arg);
d850 1
a850 1
	  UNW_DEC_REG_SPREL (P7, UNW_REG_PSP, t, arg);
d853 1
a853 1
	  UNW_DEC_REG_WHEN (P7, UNW_REG_RP, t, arg);
d856 1
a856 1
	  UNW_DEC_REG_PSPREL (P7, UNW_REG_RP, t, arg);
d859 1
a859 1
	  UNW_DEC_REG_WHEN (P7, UNW_REG_PFS, t, arg);
d862 1
a862 1
	  UNW_DEC_REG_PSPREL (P7, UNW_REG_PFS, t, arg);
d865 1
a865 1
	  UNW_DEC_REG_WHEN (P7, UNW_REG_PR, t, arg);
d868 1
a868 1
	  UNW_DEC_REG_PSPREL (P7, UNW_REG_PR, t, arg);
d871 1
a871 1
	  UNW_DEC_REG_WHEN (P7, UNW_REG_LC, t, arg);
d874 1
a874 1
	  UNW_DEC_REG_PSPREL (P7, UNW_REG_LC, t, arg);
d877 1
a877 1
	  UNW_DEC_REG_WHEN (P7, UNW_REG_UNAT, t, arg);
d880 1
a880 1
	  UNW_DEC_REG_PSPREL (P7, UNW_REG_UNAT, t, arg);
d883 1
a883 1
	  UNW_DEC_REG_WHEN (P7, UNW_REG_FPSR, t, arg);
d886 1
a886 1
	  UNW_DEC_REG_PSPREL (P7, UNW_REG_FPSR, t, arg);
d904 1
a904 1
		UNW_DEC_REG_SPREL (P8, UNW_REG_RP, t, arg);
d907 1
a907 1
		UNW_DEC_REG_SPREL (P8, UNW_REG_PFS, t, arg);
d910 1
a910 1
		UNW_DEC_REG_SPREL (P8, UNW_REG_PR, t, arg);
d913 1
a913 1
		UNW_DEC_REG_SPREL (P8, UNW_REG_LC, t, arg);
d916 1
a916 1
		UNW_DEC_REG_SPREL (P8, UNW_REG_UNAT, t, arg);
d919 1
a919 1
		UNW_DEC_REG_SPREL (P8, UNW_REG_FPSR, t, arg);
d922 1
a922 1
		UNW_DEC_REG_WHEN (P8, UNW_REG_BSP, t, arg);
d925 1
a925 1
		UNW_DEC_REG_PSPREL (P8, UNW_REG_BSP, t, arg);
d928 1
a928 1
		UNW_DEC_REG_SPREL (P8, UNW_REG_BSP, t, arg);
d931 1
a931 1
		UNW_DEC_REG_WHEN (P8, UNW_REG_BSPSTORE, t, arg);
d934 1
a934 1
		UNW_DEC_REG_PSPREL (P8, UNW_REG_BSPSTORE, t, arg);
d937 1
a937 1
		UNW_DEC_REG_SPREL (P8, UNW_REG_BSPSTORE, t, arg);
d940 1
a940 1
		UNW_DEC_REG_WHEN (P8, UNW_REG_RNAT, t, arg);
d943 1
a943 1
		UNW_DEC_REG_PSPREL (P8, UNW_REG_RNAT, t, arg);
d946 1
a946 1
		UNW_DEC_REG_SPREL (P8, UNW_REG_RNAT, t, arg);
d949 1
a949 1
		UNW_DEC_PRIUNAT_WHEN_GR (P8, t, arg);
d952 1
a952 1
		UNW_DEC_PRIUNAT_PSPREL (P8, t, arg);
d955 1
a955 1
		UNW_DEC_PRIUNAT_SPREL (P8, t, arg);
d958 1
a958 1
		UNW_DEC_PRIUNAT_WHEN_MEM (P8, t, arg);
d970 1
a970 1
	  UNW_DEC_GR_GR (P9, (byte1 & 0xf), (byte2 & 0x7f), arg);
d976 1
a976 1
	  UNW_DEC_ABI (P10, byte1, byte2, arg);
d1008 1
a1008 1
    UNW_DEC_COPY_STATE (B1, label, arg);
d1010 1
a1010 1
    UNW_DEC_LABEL_STATE (B1, label, arg);
d1023 1
a1023 1
  UNW_DEC_EPILOGUE (B2, t, (code & 0x1f), arg);
d1039 1
a1039 1
      UNW_DEC_EPILOGUE (B3, t, ecount, arg);
d1045 1
a1045 1
	UNW_DEC_COPY_STATE (B4, label, arg);
d1047 1
a1047 1
	UNW_DEC_LABEL_STATE (B4, label, arg);
@

