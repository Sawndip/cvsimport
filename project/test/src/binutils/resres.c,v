head	1.16;
access;
symbols
	binutils-2_24-branch:1.16.0.8
	binutils-2_24-branchpoint:1.16
	binutils-2_21_1:1.15
	binutils-2_23_2:1.16
	binutils-2_23_1:1.16
	binutils-2_23:1.16
	binutils-2_23-branch:1.16.0.6
	binutils-2_23-branchpoint:1.16
	binutils-2_22_branch:1.16.0.4
	binutils-2_22:1.16
	binutils-2_22-branch:1.16.0.2
	binutils-2_22-branchpoint:1.16
	binutils-2_21:1.15
	binutils-2_21-branch:1.15.0.2
	binutils-2_21-branchpoint:1.15
	binutils-2_20_1:1.14
	binutils-2_20:1.14
	binutils-arc-20081103-branch:1.13.0.8
	binutils-arc-20081103-branchpoint:1.13
	binutils-2_20-branch:1.14.0.2
	binutils-2_20-branchpoint:1.14
	dje-cgen-play1-branch:1.13.0.6
	dje-cgen-play1-branchpoint:1.13
	arc-20081103-branch:1.13.0.4
	arc-20081103-branchpoint:1.13
	binutils-2_19_1:1.13
	binutils-2_19:1.13
	binutils-2_19-branch:1.13.0.2
	binutils-2_19-branchpoint:1.13
	binutils-2_18:1.11
	binutils-2_18-branch:1.11.0.2
	binutils-2_18-branchpoint:1.11
	binutils-csl-coldfire-4_1-32:1.7
	binutils-csl-sourcerygxx-4_1-32:1.7
	binutils-csl-innovasic-fido-3_4_4-33:1.7
	binutils-csl-sourcerygxx-3_4_4-32:1.5
	binutils-csl-coldfire-4_1-30:1.7
	binutils-csl-sourcerygxx-4_1-30:1.7
	binutils-csl-coldfire-4_1-28:1.7
	binutils-csl-sourcerygxx-4_1-29:1.7
	binutils-csl-sourcerygxx-4_1-28:1.7
	binutils-csl-arm-2006q3-27:1.7
	binutils-csl-sourcerygxx-4_1-27:1.7
	binutils-csl-arm-2006q3-26:1.7
	binutils-csl-sourcerygxx-4_1-26:1.7
	binutils-csl-sourcerygxx-4_1-25:1.7
	binutils-csl-sourcerygxx-4_1-24:1.7
	binutils-csl-sourcerygxx-4_1-23:1.7
	binutils-csl-sourcerygxx-4_1-21:1.7
	binutils-csl-arm-2006q3-21:1.7
	binutils-csl-sourcerygxx-4_1-22:1.7
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.7
	binutils-csl-sourcerygxx-4_1-20:1.7
	binutils-csl-arm-2006q3-19:1.7
	binutils-csl-sourcerygxx-4_1-19:1.7
	binutils-csl-sourcerygxx-4_1-18:1.7
	binutils-csl-renesas-4_1-9:1.7
	binutils-csl-sourcerygxx-3_4_4-25:1.5
	binutils-csl-renesas-4_1-8:1.7
	binutils-csl-renesas-4_1-7:1.7
	binutils-csl-renesas-4_1-6:1.7
	binutils-csl-sourcerygxx-4_1-17:1.7
	binutils-csl-sourcerygxx-4_1-14:1.7
	binutils-csl-sourcerygxx-4_1-15:1.7
	binutils-csl-sourcerygxx-4_1-13:1.7
	binutils-2_17:1.7
	binutils-csl-sourcerygxx-4_1-12:1.7
	binutils-csl-sourcerygxx-3_4_4-21:1.7
	binutils-csl-wrs-linux-3_4_4-24:1.5
	binutils-csl-wrs-linux-3_4_4-23:1.5
	binutils-csl-sourcerygxx-4_1-9:1.7
	binutils-csl-sourcerygxx-4_1-8:1.7
	binutils-csl-sourcerygxx-4_1-7:1.7
	binutils-csl-arm-2006q1-6:1.7
	binutils-csl-sourcerygxx-4_1-6:1.7
	binutils-csl-wrs-linux-3_4_4-22:1.5
	binutils-csl-coldfire-4_1-11:1.7
	binutils-csl-sourcerygxx-3_4_4-19:1.7
	binutils-csl-coldfire-4_1-10:1.7
	binutils-csl-sourcerygxx-4_1-5:1.7
	binutils-csl-sourcerygxx-4_1-4:1.7
	binutils-csl-wrs-linux-3_4_4-21:1.5
	binutils-csl-morpho-4_1-4:1.7
	binutils-csl-sourcerygxx-3_4_4-17:1.7
	binutils-csl-wrs-linux-3_4_4-20:1.5
	binutils-2_17-branch:1.7.0.4
	binutils-2_17-branchpoint:1.7
	binutils-csl-2_17-branch:1.7.0.2
	binutils-csl-2_17-branchpoint:1.7
	binutils-csl-gxxpro-3_4-branch:1.5.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.5
	binutils-2_16_1:1.5
	binutils-csl-arm-2005q1b:1.5
	binutils-2_16:1.5
	binutils-csl-arm-2005q1a:1.5
	binutils-csl-arm-2005q1-branch:1.5.0.4
	binutils-csl-arm-2005q1-branchpoint:1.5
	binutils-2_16-branch:1.5.0.2
	binutils-2_16-branchpoint:1.5
	csl-arm-2004-q3d:1.4
	csl-arm-2004-q3:1.4
	binutils-2_15:1.4
	binutils-2_15-branchpoint:1.4
	csl-arm-2004-q1a:1.4
	csl-arm-2004-q1:1.4
	binutils-2_15-branch:1.4.0.10
	cagney_bfdfile-20040213-branch:1.4.0.8
	cagney_bfdfile-20040213-branchpoint:1.4
	cagney_bigcore-20040122-branch:1.4.0.6
	cagney_bigcore-20040122-branchpoint:1.4
	csl-arm-2003-q4:1.4
	binutils-2_14:1.4
	binutils-2_14-branch:1.4.0.4
	binutils-2_14-branchpoint:1.4
	binutils-2_13_2_1:1.4
	binutils-2_13_2:1.4
	binutils-2_13_1:1.4
	binutils-2_13:1.4
	binutils-2_13-branchpoint:1.4
	binutils-2_13-branch:1.4.0.2
	binutils-2_12_1:1.3
	binutils-2_12:1.3
	binutils-2_12-branch:1.3.0.2
	binutils-2_12-branchpoint:1.3
	cygnus_cvs_20020108_pre:1.3
	binutils-2_11_2:1.2
	binutils-2_11_1:1.2
	binutils-2_11:1.2
	x86_64versiong3:1.2
	binutils-2_11-branch:1.2.0.4
	binutils-2_10_1:1.2
	binutils-2_10:1.2
	binutils-2_10-branch:1.2.0.2
	binutils-2_10-branchpoint:1.2
	binutils_latest_snapshot:1.16
	repo-unification-2000-02-06:1.2
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.16
date	2011.06.02.13.43.18;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2009.12.11.13.42.06;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2009.09.02.07.22.32;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2008.07.30.04.34.56;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2008.07.07.00.44.41;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2007.07.05.16.54.45;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2007.06.18.16.02.45;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2007.05.23.08.48.29;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2007.04.26.14.46.59;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2005.06.16.09.18.19;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2005.05.08.14.17.39;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2005.03.03.11.46.12;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.23.04.11.57;	author kazu;	state Exp;
branches;
next	1.3;

1.3
date	2001.07.17.03.14.49;	author dj;	state Exp;
branches;
next	1.2;

1.2
date	99.09.19.23.59.35;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.29.10;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.05.03.07.29.10;	author rth;	state Exp;
branches;
next	;


desc
@@


1.16
log
@Fix spelling mistakes.
@
text
@/* resres.c: read_res_file and write_res_file implementation for windres.
   Copyright 1998, 1999, 2001, 2002, 2005, 2007, 2008, 2011
   Free Software Foundation, Inc.
   Written by Anders Norlander <anorland@@hem2.passagen.se>.
   Rewritten by Kai Tietz, Onevision.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* FIXME: This file does not work correctly in a cross configuration.
   It assumes that it can use fread and fwrite to read and write
   integers.  It does no swapping.  */

#include "sysdep.h"
#include "bfd.h"
#include "bucomm.h"
#include "libiberty.h"
#include "windres.h"

#include <assert.h>
#include <time.h>

static rc_uint_type write_res_directory (windres_bfd *, rc_uint_type,
				    	 const rc_res_directory *, const rc_res_id *,
				    	 const rc_res_id *, rc_uint_type *, int);
static rc_uint_type write_res_resource (windres_bfd *, rc_uint_type,const rc_res_id *,
				   	const rc_res_id *, const rc_res_resource *,
				   	rc_uint_type *);
static rc_uint_type write_res_bin (windres_bfd *, rc_uint_type, const rc_res_resource *,
				   const rc_res_id *, const rc_res_id *,
				   const rc_res_res_info *);

static rc_uint_type write_res_id (windres_bfd *, rc_uint_type, const rc_res_id *);
static rc_uint_type write_res_info (windres_bfd *, rc_uint_type, const rc_res_res_info *);
static rc_uint_type write_res_data_hdr (windres_bfd *, rc_uint_type, res_hdr *);

static rc_uint_type write_res_header (windres_bfd *, rc_uint_type, rc_uint_type,
				      const rc_res_id *, const rc_res_id *,
				      const rc_res_res_info *);

static int read_resource_entry (windres_bfd *, rc_uint_type *, rc_uint_type);
static void read_res_data (windres_bfd *, rc_uint_type *, rc_uint_type, void *,
			   rc_uint_type);
static void read_res_data_hdr (windres_bfd *, rc_uint_type *, rc_uint_type, res_hdr *);
static void read_res_id (windres_bfd *, rc_uint_type *, rc_uint_type, rc_res_id *);
static unichar *read_unistring (windres_bfd *, rc_uint_type *, rc_uint_type, rc_uint_type *);
static void skip_null_resource (windres_bfd *, rc_uint_type *, rc_uint_type);
static int probe_binary (windres_bfd *wrbfd, rc_uint_type);

static unsigned long get_id_size (const rc_res_id *);

static void res_add_resource (rc_res_resource *, const rc_res_id *,
			      const rc_res_id *, rc_uint_type, int);

static void res_append_resource (rc_res_directory **, rc_res_resource *,
				 int, const rc_res_id *, int);

static rc_res_directory *resources = NULL;

static const char *filename;

extern char *program_name;

/* Read resource file */
rc_res_directory *
read_res_file (const char *fn)
{
  rc_uint_type off, flen;
  windres_bfd wrbfd;
  bfd *abfd;
  asection *sec;
  filename = fn;

  flen = (rc_uint_type) get_file_size (filename);
  if (! flen)
    fatal ("can't open '%s' for input.", filename);
  abfd = windres_open_as_binary (filename, 1);
  sec = bfd_get_section_by_name (abfd, ".data");
  if (sec == NULL)
    bfd_fatal ("bfd_get_section_by_name");
  set_windres_bfd (&wrbfd, abfd, sec,
		   (target_is_bigendian ? WR_KIND_BFD_BIN_B
					: WR_KIND_BFD_BIN_L));
  off = 0;

  if (! probe_binary (&wrbfd, flen))
    set_windres_bfd_endianness (&wrbfd, ! target_is_bigendian);

  skip_null_resource (&wrbfd, &off, flen);

  while (read_resource_entry (&wrbfd, &off, flen))
    ;

  bfd_close (abfd);

  return resources;
}

/* Write resource file */
void
write_res_file (const char *fn,const rc_res_directory *resdir)
{
  asection *sec;
  rc_uint_type language;
  bfd *abfd;
  windres_bfd wrbfd;
  unsigned long sec_length = 0,sec_length_wrote;
  static const bfd_byte sign[] =
  {0x00, 0x00, 0x00, 0x00, 0x20, 0x00, 0x00, 0x00,
   0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00};

  filename = fn;

  abfd = windres_open_as_binary (filename, 0);
  sec = bfd_make_section_with_flags (abfd, ".data",
				     (SEC_HAS_CONTENTS | SEC_ALLOC
				      | SEC_LOAD | SEC_DATA));
  if (sec == NULL)
    bfd_fatal ("bfd_make_section");
  /* Requiring this is probably a bug in BFD.  */
  sec->output_section = sec;

  set_windres_bfd (&wrbfd, abfd, sec,
		   (target_is_bigendian ? WR_KIND_BFD_BIN_B
					: WR_KIND_BFD_BIN_L));

  language = -1;
  sec_length = write_res_directory ((windres_bfd *) NULL, 0x20UL, resdir,
				    (const rc_res_id *) NULL,
				    (const rc_res_id *) NULL, &language, 1);
  if (! bfd_set_section_size (abfd, sec, (sec_length + 3) & ~3))
    bfd_fatal ("bfd_set_section_size");
  if ((sec_length & 3) != 0)
    set_windres_bfd_content (&wrbfd, sign, sec_length, 4-(sec_length & 3));
  set_windres_bfd_content (&wrbfd, sign, 0, sizeof (sign));
  language = -1;
  sec_length_wrote = write_res_directory (&wrbfd, 0x20UL, resdir,
					  (const rc_res_id *) NULL,
					  (const rc_res_id *) NULL,
					  &language, 1);
  if (sec_length != sec_length_wrote)
    fatal ("res write failed with different sizes (%lu/%lu).",
	   (unsigned long) sec_length, (unsigned long) sec_length_wrote);

  bfd_close (abfd);
  return;
}

/* Read a resource entry, returns 0 when all resources are read */
static int
read_resource_entry (windres_bfd *wrbfd, rc_uint_type *off, rc_uint_type omax)
{
  rc_res_id type;
  rc_res_id name;
  rc_res_res_info resinfo;
  res_hdr reshdr;
  void *buff;

  rc_res_resource *r;
  struct bin_res_info l;

  off[0] = (off[0] + 3) & ~3;

  /* Read header */
  if ((off[0] + 8) > omax)
    return 0;
  read_res_data_hdr (wrbfd, off, omax, &reshdr);

  /* read resource type */
  read_res_id (wrbfd, off, omax, &type);
  /* read resource id */
  read_res_id (wrbfd, off, omax, &name);

  off[0] = (off[0] + 3) & ~3;

  /* Read additional resource header */
  read_res_data (wrbfd, off, omax, &l, BIN_RES_INFO_SIZE);
  resinfo.version = windres_get_32 (wrbfd, l.version, 4);
  resinfo.memflags = windres_get_16 (wrbfd, l.memflags, 2);
  resinfo.language = windres_get_16 (wrbfd, l.language, 2);
  /* resinfo.version2 = windres_get_32 (wrbfd, l.version2, 4); */
  resinfo.characteristics = windres_get_32 (wrbfd, l.characteristics, 4);

  off[0] = (off[0] + 3) & ~3;

  /* Allocate buffer for data */
  buff = res_alloc (reshdr.data_size);
  /* Read data */
  read_res_data (wrbfd, off, omax, buff, reshdr.data_size);
  /* Convert binary data to resource */
  r = bin_to_res (wrbfd, type, buff, reshdr.data_size);
  r->res_info = resinfo;
  /* Add resource to resource directory */
  res_add_resource (r, &type, &name, resinfo.language, 0);

  return 1;
}

/* write resource directory to binary resource file */
static rc_uint_type
write_res_directory (windres_bfd *wrbfd, rc_uint_type off, const rc_res_directory *rd,
		     const rc_res_id *type, const rc_res_id *name, rc_uint_type *language,
		     int level)
{
  const rc_res_entry *re;

  for (re = rd->entries; re != NULL; re = re->next)
    {
      switch (level)
	{
	case 1:
	  /* If we're at level 1, the key of this resource is the
	     type.  This normally duplicates the information we have
	     stored with the resource itself, but we need to remember
	     the type if this is a user define resource type.  */
	  type = &re->id;
	  break;

	case 2:
	  /* If we're at level 2, the key of this resource is the name
	     we are going to use in the rc printout.  */
	  name = &re->id;
	  break;

	case 3:
	  /* If we're at level 3, then this key represents a language.
	     Use it to update the current language.  */
	  if (! re->id.named
	      && re->id.u.id != (unsigned long) *language
	      && (re->id.u.id & 0xffff) == re->id.u.id)
	    {
	      *language = re->id.u.id;
	    }
	  break;

	default:
	  break;
	}

      if (re->subdir)
	off = write_res_directory (wrbfd, off, re->u.dir, type, name, language,
				   level + 1);
      else
	{
	  if (level == 3)
	    {
	      /* This is the normal case: the three levels are
	         TYPE/NAME/LANGUAGE.  NAME will have been set at level
	         2, and represents the name to use.  We probably just
	         set LANGUAGE, and it will probably match what the
	         resource itself records if anything.  */
	      off = write_res_resource (wrbfd, off, type, name, re->u.res,
	      				language);
	    }
	  else
	    {
	      fprintf (stderr, "// Resource at unexpected level %d\n", level);
	      off = write_res_resource (wrbfd, off, type, (rc_res_id *) NULL,
	      				re->u.res, language);
	    }
	}
    }

  return off;
}

static rc_uint_type
write_res_resource (windres_bfd *wrbfd, rc_uint_type off, const rc_res_id *type,
		    const rc_res_id *name, const rc_res_resource *res,
		    rc_uint_type *language ATTRIBUTE_UNUSED)
{
  int rt;

  switch (res->type)
    {
    default:
      abort ();

    case RES_TYPE_ACCELERATOR:
      rt = RT_ACCELERATOR;
      break;

    case RES_TYPE_BITMAP:
      rt = RT_BITMAP;
      break;

    case RES_TYPE_CURSOR:
      rt = RT_CURSOR;
      break;

    case RES_TYPE_GROUP_CURSOR:
      rt = RT_GROUP_CURSOR;
      break;

    case RES_TYPE_DIALOG:
      rt = RT_DIALOG;
      break;

    case RES_TYPE_FONT:
      rt = RT_FONT;
      break;

    case RES_TYPE_FONTDIR:
      rt = RT_FONTDIR;
      break;

    case RES_TYPE_ICON:
      rt = RT_ICON;
      break;

    case RES_TYPE_GROUP_ICON:
      rt = RT_GROUP_ICON;
      break;

    case RES_TYPE_MENU:
      rt = RT_MENU;
      break;

    case RES_TYPE_MESSAGETABLE:
      rt = RT_MESSAGETABLE;
      break;

    case RES_TYPE_RCDATA:
      rt = RT_RCDATA;
      break;

    case RES_TYPE_STRINGTABLE:
      rt = RT_STRING;
      break;

    case RES_TYPE_USERDATA:
      rt = 0;
      break;

    case RES_TYPE_VERSIONINFO:
      rt = RT_VERSION;
      break;

    case RES_TYPE_TOOLBAR:
      rt = RT_TOOLBAR;
      break;
    }

  if (rt != 0
      && type != NULL
      && (type->named || type->u.id != (unsigned long) rt))
    {
      fprintf (stderr, "// Unexpected resource type mismatch: ");
      res_id_print (stderr, *type, 1);
      fprintf (stderr, " != %d", rt);
      abort ();
    }

  return write_res_bin (wrbfd, off, res, type, name, &res->res_info);
}

/* Write a resource in binary resource format */
static rc_uint_type
write_res_bin (windres_bfd *wrbfd, rc_uint_type off, const rc_res_resource *res,
	       const rc_res_id *type, const rc_res_id *name,
	       const rc_res_res_info *resinfo)
{
  rc_uint_type noff;
  rc_uint_type datasize = 0;

  noff = res_to_bin ((windres_bfd *) NULL, off, res);
  datasize = noff - off;

  off = write_res_header (wrbfd, off, datasize, type, name, resinfo);
  return res_to_bin (wrbfd, off, res);
}

/* Get number of bytes needed to store an id in binary format */
static unsigned long
get_id_size (id)
     const rc_res_id *id;
{
  if (id->named)
    return sizeof (unichar) * (id->u.n.length + 1);
  else
    return sizeof (unichar) * 2;
}

/* Write a resource header */
static rc_uint_type
write_res_header (windres_bfd *wrbfd, rc_uint_type off, rc_uint_type datasize,
		  const rc_res_id *type, const rc_res_id *name,
		  const rc_res_res_info *resinfo)
{
  res_hdr reshdr;
  reshdr.data_size = datasize;
  reshdr.header_size = 24 + get_id_size (type) + get_id_size (name);

  reshdr.header_size = (reshdr.header_size + 3) & ~3;

  off = (off + 3) & ~3;

  off = write_res_data_hdr (wrbfd, off, &reshdr);
  off = write_res_id (wrbfd, off, type);
  off = write_res_id (wrbfd, off, name);

  off = (off + 3) & ~3;

  off = write_res_info (wrbfd, off, resinfo);
  off = (off + 3) & ~3;
  return off;
}

static rc_uint_type
write_res_data_hdr (windres_bfd *wrbfd, rc_uint_type off, res_hdr *hdr)
{
  if (wrbfd)
    {
      struct bin_res_hdr brh;
      windres_put_32 (wrbfd, brh.data_size, hdr->data_size);
      windres_put_32 (wrbfd, brh.header_size, hdr->header_size);
      set_windres_bfd_content (wrbfd, &brh, off, BIN_RES_HDR_SIZE);
    }
  return off + BIN_RES_HDR_SIZE;
}

static void
read_res_data_hdr (windres_bfd *wrbfd, rc_uint_type *off, rc_uint_type omax,
		   res_hdr *reshdr)
{
  struct bin_res_hdr brh;

  if ((off[0] + BIN_RES_HDR_SIZE) > omax)
    fatal ("%s: unexpected end of file %ld/%ld", filename,(long) off[0], (long) omax);

  get_windres_bfd_content (wrbfd, &brh, off[0], BIN_RES_HDR_SIZE);
  reshdr->data_size = windres_get_32 (wrbfd, brh.data_size, 4);
  reshdr->header_size = windres_get_32 (wrbfd, brh.header_size, 4);
  off[0] += BIN_RES_HDR_SIZE;
}

/* Read data from file, abort on failure */
static void
read_res_data (windres_bfd *wrbfd, rc_uint_type *off, rc_uint_type omax, void *data,
	       rc_uint_type size)
{
  if ((off[0] + size) > omax)
    fatal ("%s: unexpected end of file %ld/%ld %ld", filename,(long) off[0],
    	   (long) omax, (long) size);
  get_windres_bfd_content (wrbfd, data, off[0], size);
  off[0] += size;
}

/* Write a resource id */
static rc_uint_type
write_res_id (windres_bfd *wrbfd, rc_uint_type off, const rc_res_id *id)
{
  if (id->named)
    {
      rc_uint_type len = (((bfd_signed_vma) id->u.n.length < 0 ? 0 : id->u.n.length) + 1);
      if (wrbfd)
	{
	  rc_uint_type i;
	  bfd_byte *d = (bfd_byte *) xmalloc (len * sizeof (unichar));
	  for (i = 0; i < (len - 1); i++)
	    windres_put_16 (wrbfd, d + (i * sizeof (unichar)), id->u.n.name[i]);
	  windres_put_16 (wrbfd, d + (i * sizeof (unichar)), 0);
	  set_windres_bfd_content (wrbfd, d, off, (len * sizeof (unichar)));
	}
      off += (len * sizeof (unichar));
    }
  else
    {
      if (wrbfd)
	{
	  struct bin_res_id bid;
	  windres_put_16 (wrbfd, bid.sig, 0xffff);
	  windres_put_16 (wrbfd, bid.id, id->u.id);
	  set_windres_bfd_content (wrbfd, &bid, off, BIN_RES_ID);
	}
      off += BIN_RES_ID;
    }
  return off;
}

/* Write resource info */
static rc_uint_type
write_res_info (windres_bfd *wrbfd, rc_uint_type off, const rc_res_res_info *info)
{
  if (wrbfd)
    {
      struct bin_res_info l;
      
      windres_put_32 (wrbfd, l.version, info->version);
      windres_put_16 (wrbfd, l.memflags, info->memflags);
      windres_put_16 (wrbfd, l.language, info->language);
      windres_put_32 (wrbfd, l.version2, info->version);
      windres_put_32 (wrbfd, l.characteristics, info->characteristics);
      set_windres_bfd_content (wrbfd, &l, off, BIN_RES_INFO_SIZE);
    }
  return off + BIN_RES_INFO_SIZE;
}

/* read a resource identifier */
static void
read_res_id (windres_bfd *wrbfd, rc_uint_type *off, rc_uint_type omax, rc_res_id *id)
{
  struct bin_res_id bid;
  unsigned short ord;
  unichar *id_s = NULL;
  rc_uint_type len;

  read_res_data (wrbfd, off, omax, &bid, BIN_RES_ID - 2);
  ord = (unsigned short) windres_get_16 (wrbfd, bid.sig, 2);
  if (ord == 0xFFFF)		/* an ordinal id */
    {
      read_res_data (wrbfd, off, omax, bid.id, BIN_RES_ID - 2);
      id->named = 0;
      id->u.id = windres_get_16 (wrbfd, bid.id, 2);
    }
  else
    /* named id */
    {
      off[0] -= 2;
      id_s = read_unistring (wrbfd, off, omax, &len);
      id->named = 1;
      id->u.n.length = len;
      id->u.n.name = id_s;
    }
}

/* Read a null terminated UNICODE string */
static unichar *
read_unistring (windres_bfd *wrbfd, rc_uint_type *off, rc_uint_type omax,
		rc_uint_type *len)
{
  unichar *s;
  bfd_byte d[2];
  unichar c;
  unichar *p;
  rc_uint_type l;
  rc_uint_type soff = off[0];

  do
    {
      read_res_data (wrbfd, &soff, omax, d, sizeof (unichar));
      c = windres_get_16 (wrbfd, d, 2);
    }
  while (c != 0);
  l = ((soff - off[0]) / sizeof (unichar));

  /* there are hardly any names longer than 256 characters, but anyway. */
  p = s = (unichar *) xmalloc (sizeof (unichar) * l);
  do
    {
      read_res_data (wrbfd, off, omax, d, sizeof (unichar));
      c = windres_get_16 (wrbfd, d, 2);
      *p++ = c;
    }
  while (c != 0);
  *len = l - 1;
  return s;
}

static int
probe_binary (windres_bfd *wrbfd, rc_uint_type omax)
{
  rc_uint_type off;
  res_hdr reshdr;

  off = 0;
  read_res_data_hdr (wrbfd, &off, omax, &reshdr);
  if (reshdr.data_size != 0)
    return 1;
  if ((reshdr.header_size != 0x20 && ! target_is_bigendian)
      || (reshdr.header_size != 0x20000000 && target_is_bigendian))
    return 1;

  /* Subtract size of HeaderSize. DataSize has to be zero. */
  off += 0x20 - BIN_RES_HDR_SIZE;
  if ((off + BIN_RES_HDR_SIZE) >= omax)
    return 1;
  read_res_data_hdr (wrbfd, &off, omax, &reshdr);
  /* off is advanced by BIN_RES_HDR_SIZE in read_res_data_hdr()
     which is part of reshdr.header_size. We shouldn't take it
     into account twice.  */
  if ((off - BIN_RES_HDR_SIZE + reshdr.data_size + reshdr.header_size) > omax)
    return 0;
  return 1;
}

/* Check if file is a win32 binary resource file, if so
   skip past the null resource. Returns 0 if successful, -1 on
   error.
 */
static void
skip_null_resource (windres_bfd *wrbfd, rc_uint_type *off, rc_uint_type omax)
{
  res_hdr reshdr;
  read_res_data_hdr (wrbfd, off, omax, &reshdr);
  if (reshdr.data_size != 0)
    goto skip_err;
  if ((reshdr.header_size != 0x20 && ! target_is_bigendian)
    || (reshdr.header_size != 0x20000000 && target_is_bigendian))
    goto skip_err;

  /* Subtract size of HeaderSize. DataSize has to be zero. */
  off[0] += 0x20 - BIN_RES_HDR_SIZE;
  if (off[0] >= omax)
    goto skip_err;

  return;

skip_err:
  fprintf (stderr, "%s: %s: Not a valid WIN32 resource file\n", program_name,
	   filename);
  xexit (1);
}

/* Add a resource to resource directory */
static void
res_add_resource (rc_res_resource *r, const rc_res_id *type, const rc_res_id *id,
		  rc_uint_type language, int dupok)
{
  rc_res_id a[3];

  a[0] = *type;
  a[1] = *id;
  a[2].named = 0;
  a[2].u.id = language;
  res_append_resource (&resources, r, 3, a, dupok);
}

/* Append a resource to resource directory.
   This is just copied from define_resource
   and modified to add an existing resource.
 */
static void
res_append_resource (rc_res_directory **res_dirs, rc_res_resource *resource,
		     int cids, const rc_res_id *ids, int dupok)
{
  rc_res_entry *re = NULL;
  int i;

  assert (cids > 0);
  for (i = 0; i < cids; i++)
    {
      rc_res_entry **pp;

      if (*res_dirs == NULL)
	{
	  static unsigned long timeval;

	  /* Use the same timestamp for every resource created in a
	     single run.  */
	  if (timeval == 0)
	    timeval = time (NULL);

	  *res_dirs = ((rc_res_directory *)
			res_alloc (sizeof (rc_res_directory)));
	  (*res_dirs)->characteristics = 0;
	  (*res_dirs)->time = timeval;
	  (*res_dirs)->major = 0;
	  (*res_dirs)->minor = 0;
	  (*res_dirs)->entries = NULL;
	}

      for (pp = &(*res_dirs)->entries; *pp != NULL; pp = &(*pp)->next)
	if (res_id_cmp ((*pp)->id, ids[i]) == 0)
	  break;

      if (*pp != NULL)
	re = *pp;
      else
	{
	  re = (rc_res_entry *) res_alloc (sizeof (rc_res_entry));
	  re->next = NULL;
	  re->id = ids[i];
	  if ((i + 1) < cids)
	    {
	      re->subdir = 1;
	      re->u.dir = NULL;
	    }
	  else
	    {
	      re->subdir = 0;
	      re->u.res = NULL;
	    }

	  *pp = re;
	}

      if ((i + 1) < cids)
	{
	  if (! re->subdir)
	    {
	      fprintf (stderr, "%s: ", program_name);
	      res_ids_print (stderr, i, ids);
	      fprintf (stderr, ": expected to be a directory\n");
	      xexit (1);
	    }

	  res_dirs = &re->u.dir;
	}
    }

  if (re->subdir)
    {
      fprintf (stderr, "%s: ", program_name);
      res_ids_print (stderr, cids, ids);
      fprintf (stderr, ": expected to be a leaf\n");
      xexit (1);
    }

  if (re->u.res != NULL)
    {
      if (dupok)
	return;

      fprintf (stderr, "%s: warning: ", program_name);
      res_ids_print (stderr, cids, ids);
      fprintf (stderr, ": duplicate value\n");
    }

  re->u.res = resource;
}
@


1.15
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2001, 2002, 2005, 2007, 2008
d101 1
a101 1
    set_windres_bfd_endianess (&wrbfd, ! target_is_bigendian);
@


1.14
log
@update copyright dates
@
text
@d650 1
a650 1
res_append_resource (rc_res_directory **resources, rc_res_resource *resource,
d661 1
a661 1
      if (*resources == NULL)
d670 1
a670 1
	  *resources = ((rc_res_directory *)
d672 5
a676 5
	  (*resources)->characteristics = 0;
	  (*resources)->time = timeval;
	  (*resources)->major = 0;
	  (*resources)->minor = 0;
	  (*resources)->entries = NULL;
d679 1
a679 1
      for (pp = &(*resources)->entries; *pp != NULL; pp = &(*pp)->next)
d714 1
a714 1
	  resources = &re->u.dir;
@


1.13
log
@Silence gcc printf warnings
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2001, 2002, 2007, 2008
@


1.12
log
@	* ieee.c (write_ieee_debugging_info): Use bfd_make_section_with_flags.
	* nlmconv.c (main, powerpc_build_stubs): Likewise.
	* rescoff.c (write_coff_file): Likewise.
	* resres.c (write_res_file): Likewise.
	* windmc.c (windmc_write_bin): Likewise.
@
text
@d158 2
a159 2
    fatal ("res write failed with different sizes (%lu/%lu).", (long) sec_length,
    	   (long) sec_length_wrote);
@


1.11
log
@Change sources over to using GPLv3
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2001, 2002, 2007
d131 3
a133 1
  sec = bfd_make_section (abfd, ".data");
a135 4
  if (! bfd_set_section_flags (abfd, sec,
			       (SEC_HAS_CONTENTS | SEC_ALLOC
			        | SEC_LOAD | SEC_DATA)))
    bfd_fatal ("bfd_set_section_flags");
@


1.10
log
@* resres.c (probe_binary): Fix test for badly formatted headers.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
@


1.9
log
@Updated windres tool
@
text
@d557 6
a562 4
  do {
    read_res_data (wrbfd, &soff, omax, d, sizeof (unichar));
    c = windres_get_16 (wrbfd, d, 2);
  } while (c != 0);
d597 5
a601 2
  if ((off + reshdr.data_size + reshdr.header_size) > omax)
      return 0;
@


1.8
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d2 2
a3 1
   Copyright 1998, 1999, 2001, 2002, 2007 Free Software Foundation, Inc.
d5 1
d30 1
a31 1
#include "bucomm.h"
d37 28
a64 32
struct res_hdr
  {
    unsigned long data_size;
    unsigned long header_size;
  };

static void write_res_directory
  PARAMS ((const struct res_directory *,
	   const struct res_id *, const struct res_id *,
	   int *, int));
static void write_res_resource
  PARAMS ((const struct res_id *, const struct res_id *,
	   const struct res_resource *, int *));
static void write_res_bin
  PARAMS ((const struct res_resource *, const struct res_id *,
	   const struct res_id *, const struct res_res_info *));

static void write_res_id PARAMS ((const struct res_id *));
static void write_res_info PARAMS ((const struct res_res_info *));
static void write_res_data PARAMS ((const void *, size_t, int));
static void write_res_header
  PARAMS ((unsigned long, const struct res_id *, const struct res_id *,
	   const struct res_res_info *));

static int read_resource_entry PARAMS ((void));
static void read_res_data PARAMS ((void *, size_t, int));
static void read_res_id PARAMS ((struct res_id *));
static unichar *read_unistring PARAMS ((int *));
static void skip_null_resource PARAMS ((void));

static unsigned long get_id_size PARAMS ((const struct res_id *));
static void res_align_file PARAMS ((void));
d66 2
a67 4
static void
  res_add_resource
  PARAMS ((struct res_resource *, const struct res_id *,
	   const struct res_id *, int, int));
d69 2
a70 4
void
  res_append_resource
  PARAMS ((struct res_directory **, struct res_resource *,
	   int, const struct res_id *, int));
d72 1
a72 1
static struct res_directory *resources = NULL;
a73 1
static FILE *fres;
d79 2
a80 3
struct res_directory *
read_res_file (fn)
     const char *fn;
d82 4
a86 3
  fres = fopen (filename, "rb");
  if (fres == NULL)
    fatal ("can't open `%s' for output: %s", filename, strerror (errno));
d88 14
a101 1
  skip_null_resource ();
d103 3
a105 1
  while (read_resource_entry ())
d108 1
a108 1
  fclose (fres);
d115 1
a115 3
write_res_file (fn, resdir)
     const char *fn;
     const struct res_directory *resdir;
d117 6
a122 2
  int language;
  static const unsigned char sign[] =
a126 1
  long fpos;
d130 14
a143 8
  fres = fopen (filename, "wb");
  if (fres == NULL)
    fatal ("can't open `%s' for output: %s", filename, strerror (errno));

  /* Write 32 bit resource signature */
  write_res_data (sign, sizeof (sign), 1);

  /* write resources */
d146 16
a161 2
  write_res_directory (resdir, (const struct res_id *) NULL,
		       (const struct res_id *) NULL, &language, 1);
d163 2
a164 6
  /* end file on DWORD boundary */
  fpos = ftell (fres);
  if (fpos % 4)
    write_res_data (sign, fpos % 4, 1);

  fclose (fres);
d169 1
a169 1
read_resource_entry (void)
d171 4
a174 5
  struct res_id type;
  struct res_id name;
  struct res_res_info resinfo;
  struct res_hdr reshdr;
  long version;
d177 2
a178 1
  struct res_resource *r;
d180 1
a180 1
  res_align_file ();
d183 1
a183 1
  if (fread (&reshdr, sizeof (reshdr), 1, fres) != 1)
d185 1
d188 1
a188 1
  read_res_id (&type);
d190 1
a190 1
  read_res_id (&name);
d192 1
a192 1
  res_align_file ();
d195 6
a200 5
  read_res_data (&resinfo.version, sizeof (resinfo.version), 1);
  read_res_data (&resinfo.memflags, sizeof (resinfo.memflags), 1);
  read_res_data (&resinfo.language, sizeof (resinfo.language), 1);
  read_res_data (&version, sizeof (version), 1);
  read_res_data (&resinfo.characteristics, sizeof (resinfo.characteristics), 1);
d202 1
a202 1
  res_align_file ();
d207 1
a207 1
  read_res_data (buff, reshdr.data_size, 1);
d209 1
a209 1
  r = bin_to_res (type, buff, reshdr.data_size, 0);
d218 4
a221 7
static void
write_res_directory (rd, type, name, language, level)
     const struct res_directory *rd;
     const struct res_id *type;
     const struct res_id *name;
     int *language;
     int level;
d223 1
a223 1
  const struct res_entry *re;
d246 1
a246 1
	  if (!re->id.named
d259 2
a260 1
	write_res_directory (re->u.dir, type, name, language, level + 1);
d270 2
a271 1
	      write_res_resource (type, name, re->u.res, language);
d276 2
a277 2
	      write_res_resource (type, (struct res_id *) NULL, re->u.res,
				  language);
d282 1
d285 4
a288 6
static void
write_res_resource (type, name, res, language)
     const struct res_id *type;
     const struct res_id *name;
     const struct res_resource *res;
     int *language ATTRIBUTE_UNUSED;
d356 4
d372 1
a372 2
  write_res_bin (res, type, name, &res->res_info);
  return;
d376 7
a382 13
static void
write_res_bin (res, type, name, resinfo)
     const struct res_resource *res;
     const struct res_id *type;
     const struct res_id *name;
     const struct res_res_info *resinfo;
{
  unsigned long datasize = 0;
  const struct bindata *bin_rep, *data;

  bin_rep = res_to_bin (res, 0);
  for (data = bin_rep; data != NULL; data = data->next)
    datasize += data->length;
d384 2
a385 1
  write_res_header (datasize, type, name, resinfo);
d387 2
a388 2
  for (data = bin_rep; data != NULL; data = data->next)
    write_res_data (data->data, data->length, 1);
d394 1
a394 1
     const struct res_id *id;
d403 4
a406 6
static void
write_res_header (datasize, type, name, resinfo)
     unsigned long datasize;
     const struct res_id *type;
     const struct res_id *name;
     const struct res_res_info *resinfo;
d408 1
a408 1
  struct res_hdr reshdr;
d414 5
a418 4
  res_align_file ();
  write_res_data (&reshdr, sizeof (reshdr), 1);
  write_res_id (type);
  write_res_id (name);
d420 1
a420 1
  res_align_file ();
d422 3
a424 2
  write_res_info (resinfo);
  res_align_file ();
d427 12
a439 1
/* Write data to file, abort on failure */
d441 2
a442 4
write_res_data (data, size, count)
     const void *data;
     size_t size;
     int count;
d444 9
a452 2
  if ((size_t) fwrite (data, size, count, fres) != (size_t) count)
    fatal ("%s: could not write to file", filename);
d457 2
a458 4
read_res_data (data, size, count)
     void *data;
     size_t size;
     int count;
d460 5
a464 2
  if (fread (data, size, count, fres) != (size_t) count)
    fatal ("%s: unexpected end of file", filename);
d468 2
a469 3
static void
write_res_id (id)
     const struct res_id *id;
d473 11
a483 4
      unsigned long len = id->u.n.length;
      unichar null_term = 0;
      write_res_data (id->u.n.name, len * sizeof (unichar), 1);
      write_res_data (&null_term, sizeof (null_term), 1);
d487 8
a494 4
      unsigned short i = 0xFFFF;
      write_res_data (&i, sizeof (i), 1);
      i = id->u.id;
      write_res_data (&i, sizeof (i), 1);
d496 1
d500 2
a501 3
static void
write_res_info (info)
     const struct res_res_info *info;
d503 12
a514 5
  write_res_data (&info->version, sizeof (info->version), 1);
  write_res_data (&info->memflags, sizeof (info->memflags), 1);
  write_res_data (&info->language, sizeof (info->language), 1);
  write_res_data (&info->version, sizeof (info->version), 1);
  write_res_data (&info->characteristics, sizeof (info->characteristics), 1);
d518 2
a519 3
void
read_res_id (id)
     struct res_id *id;
d521 1
d524 1
a524 1
  int len;
d526 2
a527 1
  read_res_data (&ord, sizeof (ord), 1);
d530 1
a530 1
      read_res_data (&ord, sizeof (ord), 1);
d532 1
a532 1
      id->u.id = ord;
d537 2
a538 3
      if (fseek (fres, -sizeof (ord), SEEK_CUR) != 0)
	fatal ("%s: %s: could not seek in file", program_name, filename);
      id_s = read_unistring (&len);
d547 2
a548 2
read_unistring (len)
     int *len;
d551 1
d554 2
a555 1
  int l;
d557 5
a561 2
  *len = 0;
  l = 0;
d563 2
a564 2
  /* there are hardly any names longer than 256 characters */
  p = s = (unichar *) xmalloc (sizeof (unichar) * 256);
d567 2
a568 1
      read_res_data (&c, sizeof (c), 1);
a569 2
      if (c != 0)
	l++;
d572 1
a572 1
  *len = l;
d576 2
a577 3
/* align file on DWORD boundary */
static void
res_align_file (void)
d579 19
a597 4
  int pos = ftell (fres);
  int skip = ((pos + 3) & ~3) - pos;
  if (fseek (fres, skip, SEEK_CUR) != 0)
    fatal ("%s: %s: unable to align file", program_name, filename);
d605 1
a605 1
skip_null_resource (void)
d607 6
a612 4
  struct res_hdr reshdr =
  {0, 0};
  read_res_data (&reshdr, sizeof (reshdr), 1);
  if ((reshdr.data_size != 0) || (reshdr.header_size != 0x20))
d615 3
a617 2
  /* Subtract size of HeaderSize and DataSize */
  if (fseek (fres, reshdr.header_size - 8, SEEK_CUR) != 0)
d629 3
a631 7
void
res_add_resource (r, type, id, language, dupok)
     struct res_resource *r;
     const struct res_id *type;
     const struct res_id *id;
     int language;
     int dupok;
d633 1
a633 1
  struct res_id a[3];
d646 3
a648 7
void
res_append_resource (resources, resource, cids, ids, dupok)
     struct res_directory **resources;
     struct res_resource *resource;
     int cids;
     const struct res_id *ids;
     int dupok;
d650 1
a650 1
  struct res_entry *re = NULL;
d656 1
a656 1
      struct res_entry **pp;
d667 2
a668 2
	  *resources = ((struct res_directory *)
			res_alloc (sizeof **resources));
d684 1
a684 1
	  re = (struct res_entry *) res_alloc (sizeof *re);
d703 1
a703 1
	  if (!re->subdir)
@


1.7
log
@rename.c (simple_copy): Only define if it is going to be used.
  (smart_rename): Mark the preserve_dates parameter as possibly	being unused.

resres.c (write_res_data): Prevent a potential compile time warning by casting
  the return value from fwrite.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2001, 2002 Free Software Foundation, Inc.
d26 1
d28 1
a29 1
#include "libiberty.h"
@


1.6
log
@Update FSF address
@
text
@d411 1
a411 1
  if (fwrite (data, size, count, fres) != (size_t) count)
@


1.5
log
@update copyright dates
@
text
@d19 2
a20 2
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.4
log
@	* rdcoff.c: Fix formatting.
	* rddbg.c: Likewise.
	* readelf.c: Likewise.
	* rename.c: Likewise.
	* resbin.c: Likewise.
	* resrc.c: Likewise.
	* resres.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 1998, 1999 Free Software Foundation, Inc.
@


1.3
log
@* resres.c (write_res_header): Align header size.
(res_align_file): Calculate alignment correctly.
@
text
@d214 1
a214 1
	     we are going to use in the rc printout. */
d460 1
a460 1
void 
@


1.2
log
@	* resrc.c (write_rc_rcdata): Fix local variable shadowing
	problem.  If RCDATA_BUFFER data can be read as strings, modify
	code to print the strings as comments.
	* resres.c: Add casts to avoid warnings.
	(write_res_data, read_res_data): Don't put the program name in the
	error message; fatal already puts it there.
@
text
@d390 2
d518 3
a520 1
  if (fseek (fres, ftell (fres) % 4, SEEK_CUR) != 0)
@


1.1
log
@Initial revision
@
text
@a1 1

d22 4
d222 1
a222 1
	      && re->id.u.id != *language
d262 1
a262 1
     int *language;
d334 1
a334 1
      && (type->named || type->u.id != rt))
d409 2
a410 2
  if (fwrite (data, size, count, fres) != count)
    fatal ("%s: %s: could not write to file", program_name, filename);
d420 2
a421 2
  if (fread (data, size, count, fres) != count)
    fatal ("%s: %s: unexpected end of file", program_name, filename);
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

