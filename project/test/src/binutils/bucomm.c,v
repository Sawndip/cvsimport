head	1.46;
access;
symbols
	binutils-2_24-branch:1.46.0.4
	binutils-2_24-branchpoint:1.46
	binutils-2_21_1:1.41.2.1
	binutils-2_23_2:1.46
	binutils-2_23_1:1.46
	binutils-2_23:1.46
	binutils-2_23-branch:1.46.0.2
	binutils-2_23-branchpoint:1.46
	binutils-2_22_branch:1.43.0.4
	binutils-2_22:1.43
	binutils-2_22-branch:1.43.0.2
	binutils-2_22-branchpoint:1.43
	binutils-2_21:1.41
	binutils-2_21-branch:1.41.0.2
	binutils-2_21-branchpoint:1.41
	binutils-2_20_1:1.36.2.1
	binutils-2_20:1.36.2.1
	binutils-arc-20081103-branch:1.33.0.6
	binutils-arc-20081103-branchpoint:1.33
	binutils-2_20-branch:1.36.0.2
	binutils-2_20-branchpoint:1.36
	dje-cgen-play1-branch:1.35.0.2
	dje-cgen-play1-branchpoint:1.35
	arc-20081103-branch:1.33.0.4
	arc-20081103-branchpoint:1.33
	binutils-2_19_1:1.33
	binutils-2_19:1.33
	binutils-2_19-branch:1.33.0.2
	binutils-2_19-branchpoint:1.33
	binutils-2_18:1.31
	binutils-2_18-branch:1.31.0.2
	binutils-2_18-branchpoint:1.31
	binutils-csl-coldfire-4_1-32:1.25
	binutils-csl-sourcerygxx-4_1-32:1.25
	binutils-csl-innovasic-fido-3_4_4-33:1.25
	binutils-csl-sourcerygxx-3_4_4-32:1.20
	binutils-csl-coldfire-4_1-30:1.25
	binutils-csl-sourcerygxx-4_1-30:1.25
	binutils-csl-coldfire-4_1-28:1.25
	binutils-csl-sourcerygxx-4_1-29:1.25
	binutils-csl-sourcerygxx-4_1-28:1.25
	binutils-csl-arm-2006q3-27:1.25
	binutils-csl-sourcerygxx-4_1-27:1.25
	binutils-csl-arm-2006q3-26:1.25
	binutils-csl-sourcerygxx-4_1-26:1.25
	binutils-csl-sourcerygxx-4_1-25:1.25
	binutils-csl-sourcerygxx-4_1-24:1.25
	binutils-csl-sourcerygxx-4_1-23:1.25
	binutils-csl-sourcerygxx-4_1-21:1.25
	binutils-csl-arm-2006q3-21:1.25
	binutils-csl-sourcerygxx-4_1-22:1.25
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.25
	binutils-csl-sourcerygxx-4_1-20:1.25
	binutils-csl-arm-2006q3-19:1.25
	binutils-csl-sourcerygxx-4_1-19:1.25
	binutils-csl-sourcerygxx-4_1-18:1.25
	binutils-csl-renesas-4_1-9:1.25
	binutils-csl-sourcerygxx-3_4_4-25:1.20
	binutils-csl-renesas-4_1-8:1.25
	binutils-csl-renesas-4_1-7:1.25
	binutils-csl-renesas-4_1-6:1.25
	binutils-csl-sourcerygxx-4_1-17:1.25
	binutils-csl-sourcerygxx-4_1-14:1.25
	binutils-csl-sourcerygxx-4_1-15:1.25
	binutils-csl-sourcerygxx-4_1-13:1.25
	binutils-2_17:1.25
	binutils-csl-sourcerygxx-4_1-12:1.25
	binutils-csl-sourcerygxx-3_4_4-21:1.25
	binutils-csl-wrs-linux-3_4_4-24:1.20
	binutils-csl-wrs-linux-3_4_4-23:1.20
	binutils-csl-sourcerygxx-4_1-9:1.25
	binutils-csl-sourcerygxx-4_1-8:1.25
	binutils-csl-sourcerygxx-4_1-7:1.25
	binutils-csl-arm-2006q1-6:1.25
	binutils-csl-sourcerygxx-4_1-6:1.25
	binutils-csl-wrs-linux-3_4_4-22:1.20
	binutils-csl-coldfire-4_1-11:1.25
	binutils-csl-sourcerygxx-3_4_4-19:1.25
	binutils-csl-coldfire-4_1-10:1.25
	binutils-csl-sourcerygxx-4_1-5:1.25
	binutils-csl-sourcerygxx-4_1-4:1.25
	binutils-csl-wrs-linux-3_4_4-21:1.20
	binutils-csl-morpho-4_1-4:1.25
	binutils-csl-sourcerygxx-3_4_4-17:1.25
	binutils-csl-wrs-linux-3_4_4-20:1.20
	binutils-2_17-branch:1.25.0.4
	binutils-2_17-branchpoint:1.25
	binutils-csl-2_17-branch:1.25.0.2
	binutils-csl-2_17-branchpoint:1.25
	binutils-csl-gxxpro-3_4-branch:1.20.0.12
	binutils-csl-gxxpro-3_4-branchpoint:1.20
	binutils-2_16_1:1.20
	binutils-csl-arm-2005q1b:1.20
	binutils-2_16:1.20
	binutils-csl-arm-2005q1a:1.20
	binutils-csl-arm-2005q1-branch:1.20.0.10
	binutils-csl-arm-2005q1-branchpoint:1.20
	binutils-2_16-branch:1.20.0.8
	binutils-2_16-branchpoint:1.20
	csl-arm-2004-q3d:1.20
	csl-arm-2004-q3:1.20
	binutils-2_15:1.20
	binutils-2_15-branchpoint:1.20
	csl-arm-2004-q1a:1.20
	csl-arm-2004-q1:1.20
	binutils-2_15-branch:1.20.0.6
	cagney_bfdfile-20040213-branch:1.20.0.4
	cagney_bfdfile-20040213-branchpoint:1.20
	cagney_bigcore-20040122-branch:1.20.0.2
	cagney_bigcore-20040122-branchpoint:1.20
	csl-arm-2003-q4:1.20
	binutils-2_14:1.18
	binutils-2_14-branch:1.18.0.2
	binutils-2_14-branchpoint:1.18
	binutils-2_13_2_1:1.15.2.1
	binutils-2_13_2:1.15.2.1
	binutils-2_13_1:1.15.2.1
	binutils-2_13:1.15
	binutils-2_13-branchpoint:1.15
	binutils-2_13-branch:1.15.0.2
	binutils-2_12_1:1.13
	binutils-2_12:1.13
	binutils-2_12-branch:1.13.0.2
	binutils-2_12-branchpoint:1.13
	cygnus_cvs_20020108_pre:1.13
	binutils-2_11_2:1.6.2.2
	binutils-2_11_1:1.6.2.2
	binutils-2_11:1.6
	x86_64versiong3:1.7
	binutils-2_11-branch:1.6.0.2
	binutils-2_10_1:1.1.1.1.2.2
	binutils-2_10:1.1.1.1.2.2
	binutils-2_10-branch:1.1.1.1.0.2
	binutils-2_10-branchpoint:1.1.1.1
	binutils_latest_snapshot:1.46
	repo-unification-2000-02-06:1.1.1.1
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.46
date	2012.06.29.12.59.49;	author nickc;	state Exp;
branches;
next	1.45;

1.45
date	2012.02.09.04.51.43;	author amodra;	state Exp;
branches;
next	1.44;

1.44
date	2011.10.13.15.33.32;	author nickc;	state Exp;
branches;
next	1.43;

1.43
date	2011.03.25.17.51.10;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	2011.01.06.11.34.28;	author nickc;	state Exp;
branches;
next	1.41;

1.41
date	2010.10.05.22.48.34;	author amodra;	state Exp;
branches
	1.41.2.1;
next	1.40;

1.40
date	2010.10.05.05.48.10;	author amodra;	state Exp;
branches;
next	1.39;

1.39
date	2009.12.11.13.42.05;	author nickc;	state Exp;
branches;
next	1.38;

1.38
date	2009.11.08.23.01.57;	author jkratoch;	state Exp;
branches;
next	1.37;

1.37
date	2009.09.10.13.40.44;	author nickc;	state Exp;
branches;
next	1.36;

1.36
date	2009.09.02.07.22.31;	author amodra;	state Exp;
branches
	1.36.2.1;
next	1.35;

1.35
date	2009.06.27.17.19.02;	author hjl;	state Exp;
branches;
next	1.34;

1.34
date	2009.01.29.13.03.21;	author amodra;	state Exp;
branches;
next	1.33;

1.33
date	2008.01.09.10.40.32;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2007.08.30.10.19.03;	author nathan;	state Exp;
branches;
next	1.31;

1.31
date	2007.07.05.16.54.45;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	2007.04.26.14.46.59;	author amodra;	state Exp;
branches;
next	1.29;

1.29
date	2007.03.15.14.17.16;	author hjl;	state Exp;
branches;
next	1.28;

1.28
date	2007.01.11.23.13.10;	author hjl;	state Exp;
branches;
next	1.27;

1.27
date	2007.01.10.13.36.34;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2006.10.13.09.43.28;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2006.03.13.22.27.22;	author bje;	state Exp;
branches;
next	1.24;

1.24
date	2005.06.14.13.26.42;	author hjl;	state Exp;
branches;
next	1.23;

1.23
date	2005.05.08.14.17.38;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2005.04.29.16.49.20;	author hjl;	state Exp;
branches;
next	1.21;

1.21
date	2005.04.29.00.03.32;	author bje;	state Exp;
branches;
next	1.20;

1.20
date	2003.11.07.12.19.34;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2003.09.14.12.20.16;	author aj;	state Exp;
branches;
next	1.18;

1.18
date	2003.03.24.11.28.35;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2002.11.30.08.39.41;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2002.10.15.11.34.01;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2002.06.08.07.38.30;	author amodra;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2002.05.19.16.17.54;	author kazu;	state Exp;
branches;
next	1.13;

1.13
date	2001.11.29.18.51.21;	author hjl;	state Exp;
branches;
next	1.12;

1.12
date	2001.11.14.11.56.41;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2001.11.12.16.17.39;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2001.09.26.01.55.19;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2001.07.29.05.31.43;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2001.03.13.06.43.57;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2001.02.07.23.16.22;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2000.06.26.23.15.58;	author amodra;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2000.06.25.16.30.27;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2000.06.20.12.33.20;	author amodra;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.26.13.11.56;	author amodra;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.07.04.34.50;	author amodra;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.29.09;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.41.2.1
date	2011.02.01.12.25.36;	author amodra;	state Exp;
branches;
next	;

1.36.2.1
date	2009.09.10.13.42.08;	author nickc;	state Exp;
branches;
next	;

1.15.2.1
date	2002.10.28.18.45.47;	author drow;	state Exp;
branches;
next	;

1.6.2.1
date	2001.06.07.03.12.27;	author amodra;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2001.06.11.10.04.27;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.09;	author rth;	state Exp;
branches
	1.1.1.1.2.1;
next	;

1.1.1.1.2.1
date	2000.04.07.04.39.24;	author amodra;	state Exp;
branches;
next	1.1.1.1.2.2;

1.1.1.1.2.2
date	2000.05.28.10.57.50;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.46
log
@	PR binutils/14302
	* bucomm.c (print_arelt_descr): Correctly report the archive size
	field (for 'ar tv').
	* ar.c (print_contents): Use correct types for archive element
	sizes (for 'ar p').
	(extract_file): Likewise (for 'ar x').
@
text
@/* bucomm.c -- Bin Utils COMmon code.
   Copyright 1991, 1992, 1993, 1994, 1995, 1997, 1998, 2000, 2001, 2002,
   2003, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
   Free Software Foundation, Inc.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* We might put this in a library someday so it could be dynamically
   loaded, but for now it's not necessary.  */

#include "sysdep.h"
#include "bfd.h"
#include "libiberty.h"
#include "filenames.h"
#include "libbfd.h"

#include <time.h>		/* ctime, maybe time_t */
#include <assert.h>
#include "bucomm.h"

#ifndef HAVE_TIME_T_IN_TIME_H
#ifndef HAVE_TIME_T_IN_TYPES_H
typedef long time_t;
#endif
#endif

static const char * endian_string (enum bfd_endian);
static int display_target_list (void);
static int display_info_table (int, int);
static int display_target_tables (void);

/* Error reporting.  */

char *program_name;

void
bfd_nonfatal (const char *string)
{
  const char *errmsg;

  errmsg = bfd_errmsg (bfd_get_error ());
  fflush (stdout);
  if (string)
    fprintf (stderr, "%s: %s: %s\n", program_name, string, errmsg);
  else
    fprintf (stderr, "%s: %s\n", program_name, errmsg);
}

/* Issue a non fatal error message.  FILENAME, or if NULL then BFD,
   are used to indicate the problematic file.  SECTION, if non NULL,
   is used to provide a section name.  If FORMAT is non-null, then it
   is used to print additional information via vfprintf.  Finally the
   bfd error message is printed.  In summary, error messages are of
   one of the following forms:

   PROGRAM:file: bfd-error-message
   PROGRAM:file[section]: bfd-error-message
   PROGRAM:file: printf-message: bfd-error-message
   PROGRAM:file[section]: printf-message: bfd-error-message.  */

void
bfd_nonfatal_message (const char *filename,
		      const bfd *abfd,
		      const asection *section,
		      const char *format, ...)
{
  const char *errmsg;
  const char *section_name;
  va_list args;

  errmsg = bfd_errmsg (bfd_get_error ());
  fflush (stdout);
  section_name = NULL;
  va_start (args, format);
  fprintf (stderr, "%s", program_name);
  
  if (abfd)
    {
      if (!filename)
	filename = bfd_get_archive_filename (abfd);
      if (section)
	section_name = bfd_get_section_name (abfd, section);
    }
  if (section_name)
    fprintf (stderr, ":%s[%s]", filename, section_name);
  else
    fprintf (stderr, ":%s", filename);

  if (format)
    {
      fprintf (stderr, ": ");
      vfprintf (stderr, format, args);
    }
  fprintf (stderr, ": %s\n", errmsg);
  va_end (args);
}

void
bfd_fatal (const char *string)
{
  bfd_nonfatal (string);
  xexit (1);
}

void
report (const char * format, va_list args)
{
  fflush (stdout);
  fprintf (stderr, "%s: ", program_name);
  vfprintf (stderr, format, args);
  putc ('\n', stderr);
}

void
fatal VPARAMS ((const char *format, ...))
{
  VA_OPEN (args, format);
  VA_FIXEDARG (args, const char *, format);

  report (format, args);
  VA_CLOSE (args);
  xexit (1);
}

void
non_fatal VPARAMS ((const char *format, ...))
{
  VA_OPEN (args, format);
  VA_FIXEDARG (args, const char *, format);

  report (format, args);
  VA_CLOSE (args);
}

/* Set the default BFD target based on the configured target.  Doing
   this permits the binutils to be configured for a particular target,
   and linked against a shared BFD library which was configured for a
   different target.  */

void
set_default_bfd_target (void)
{
  /* The macro TARGET is defined by Makefile.  */
  const char *target = TARGET;

  if (! bfd_set_default_target (target))
    fatal (_("can't set BFD default target to `%s': %s"),
	   target, bfd_errmsg (bfd_get_error ()));
}

/* After a FALSE return from bfd_check_format_matches with
   bfd_get_error () == bfd_error_file_ambiguously_recognized, print
   the possible matching targets.  */

void
list_matching_formats (char **p)
{
  fflush (stdout);
  fprintf (stderr, _("%s: Matching formats:"), program_name);
  while (*p)
    fprintf (stderr, " %s", *p++);
  fputc ('\n', stderr);
}

/* List the supported targets.  */

void
list_supported_targets (const char *name, FILE *f)
{
  int t;
  const char **targ_names;

  if (name == NULL)
    fprintf (f, _("Supported targets:"));
  else
    fprintf (f, _("%s: supported targets:"), name);

  targ_names = bfd_target_list ();
  for (t = 0; targ_names[t] != NULL; t++)
    fprintf (f, " %s", targ_names[t]);
  fprintf (f, "\n");
  free (targ_names);
}

/* List the supported architectures.  */

void
list_supported_architectures (const char *name, FILE *f)
{
  const char ** arch;
  const char ** arches;

  if (name == NULL)
    fprintf (f, _("Supported architectures:"));
  else
    fprintf (f, _("%s: supported architectures:"), name);

  for (arch = arches = bfd_arch_list (); *arch; arch++)
    fprintf (f, " %s", *arch);
  fprintf (f, "\n");
  free (arches);
}

/* The length of the longest architecture name + 1.  */
#define LONGEST_ARCH sizeof ("powerpc:common")

static const char *
endian_string (enum bfd_endian endian)
{
  switch (endian)
    {
    case BFD_ENDIAN_BIG: return _("big endian");
    case BFD_ENDIAN_LITTLE: return _("little endian");
    default: return _("endianness unknown");
    }
}

/* List the targets that BFD is configured to support, each followed
   by its endianness and the architectures it supports.  */

static int
display_target_list (void)
{
  char *dummy_name;
  int t;
  int ret = 1;

  dummy_name = make_temp_file (NULL);
  for (t = 0; bfd_target_vector[t]; t++)
    {
      const bfd_target *p = bfd_target_vector[t];
      bfd *abfd = bfd_openw (dummy_name, p->name);
      int a;

      printf (_("%s\n (header %s, data %s)\n"), p->name,
	      endian_string (p->header_byteorder),
	      endian_string (p->byteorder));

      if (abfd == NULL)
	{
          bfd_nonfatal (dummy_name);
          ret = 0;
	  continue;
	}

      if (! bfd_set_format (abfd, bfd_object))
	{
	  if (bfd_get_error () != bfd_error_invalid_operation)
            {
	      bfd_nonfatal (p->name);
              ret = 0;
            }
	  bfd_close_all_done (abfd);
	  continue;
	}

      for (a = bfd_arch_obscure + 1; a < bfd_arch_last; a++)
	if (bfd_set_arch_mach (abfd, (enum bfd_architecture) a, 0))
	  printf ("  %s\n",
		  bfd_printable_arch_mach ((enum bfd_architecture) a, 0));
      bfd_close_all_done (abfd);
    }
  unlink (dummy_name);
  free (dummy_name);

  return ret;
}

/* Print a table showing which architectures are supported for entries
   FIRST through LAST-1 of bfd_target_vector (targets across,
   architectures down).  */

static int
display_info_table (int first, int last)
{
  int t;
  int ret = 1;
  char *dummy_name;
  int a;

  /* Print heading of target names.  */
  printf ("\n%*s", (int) LONGEST_ARCH, " ");
  for (t = first; t < last && bfd_target_vector[t]; t++)
    printf ("%s ", bfd_target_vector[t]->name);
  putchar ('\n');

  dummy_name = make_temp_file (NULL);
  for (a = bfd_arch_obscure + 1; a < bfd_arch_last; a++)
    if (strcmp (bfd_printable_arch_mach ((enum bfd_architecture) a, 0),
                "UNKNOWN!") != 0)
      {
	printf ("%*s ", (int) LONGEST_ARCH - 1,
		bfd_printable_arch_mach ((enum bfd_architecture) a, 0));
	for (t = first; t < last && bfd_target_vector[t]; t++)
	  {
	    const bfd_target *p = bfd_target_vector[t];
	    bfd_boolean ok = TRUE;
	    bfd *abfd = bfd_openw (dummy_name, p->name);

	    if (abfd == NULL)
	      {
		bfd_nonfatal (p->name);
                ret = 0;
		ok = FALSE;
	      }

	    if (ok)
	      {
		if (! bfd_set_format (abfd, bfd_object))
		  {
		    if (bfd_get_error () != bfd_error_invalid_operation)
                      {
		        bfd_nonfatal (p->name);
                        ret = 0;
                      }
		    ok = FALSE;
		  }
	      }

	    if (ok)
	      {
		if (! bfd_set_arch_mach (abfd, (enum bfd_architecture) a, 0))
		  ok = FALSE;
	      }

	    if (ok)
	      printf ("%s ", p->name);
	    else
	      {
		int l = strlen (p->name);
		while (l--)
		  putchar ('-');
		putchar (' ');
	      }
	    if (abfd != NULL)
	      bfd_close_all_done (abfd);
	  }
	putchar ('\n');
      }
  unlink (dummy_name);
  free (dummy_name);

  return ret;
}

/* Print tables of all the target-architecture combinations that
   BFD has been configured to support.  */

static int
display_target_tables (void)
{
  int t;
  int columns;
  int ret = 1;
  char *colum;

  columns = 0;
  colum = getenv ("COLUMNS");
  if (colum != NULL)
    columns = atoi (colum);
  if (columns == 0)
    columns = 80;

  t = 0;
  while (bfd_target_vector[t] != NULL)
    {
      int oldt = t, wid;

      wid = LONGEST_ARCH + strlen (bfd_target_vector[t]->name) + 1;
      ++t;
      while (wid < columns && bfd_target_vector[t] != NULL)
	{
	  int newwid;

	  newwid = wid + strlen (bfd_target_vector[t]->name) + 1;
	  if (newwid >= columns)
	    break;
	  wid = newwid;
	  ++t;
	}
      if (! display_info_table (oldt, t))
        ret = 0;
    }

  return ret;
}

int
display_info (void)
{
  printf (_("BFD header file version %s\n"), BFD_VERSION_STRING);
  if (! display_target_list () || ! display_target_tables ())
    return 1;
  else
    return 0;
}

/* Display the archive header for an element as if it were an ls -l listing:

   Mode       User\tGroup\tSize\tDate               Name */

void
print_arelt_descr (FILE *file, bfd *abfd, bfd_boolean verbose)
{
  struct stat buf;

  if (verbose)
    {
      if (bfd_stat_arch_elt (abfd, &buf) == 0)
	{
	  char modebuf[11];
	  char timebuf[40];
	  time_t when = buf.st_mtime;
	  const char *ctime_result = (const char *) ctime (&when);
	  bfd_size_type size;

	  /* POSIX format:  skip weekday and seconds from ctime output.  */
	  sprintf (timebuf, "%.12s %.4s", ctime_result + 4, ctime_result + 20);

	  mode_string (buf.st_mode, modebuf);
	  modebuf[10] = '\0';
	  size = buf.st_size;
	  /* POSIX 1003.2/D11 says to skip first character (entry type).  */
	  fprintf (file, "%s %ld/%ld %6" BFD_VMA_FMT "u %s ", modebuf + 1,
		   (long) buf.st_uid, (long) buf.st_gid,
		   size, timebuf);
	}
    }

  fprintf (file, "%s\n", bfd_get_filename (abfd));
}

/* Return a path for a new temporary file in the same directory
   as file PATH.  */

static char *
template_in_dir (const char *path)
{
#define template "stXXXXXX"
  const char *slash = strrchr (path, '/');
  char *tmpname;
  size_t len;

#ifdef HAVE_DOS_BASED_FILE_SYSTEM
  {
    /* We could have foo/bar\\baz, or foo\\bar, or d:bar.  */
    char *bslash = strrchr (path, '\\');

    if (slash == NULL || (bslash != NULL && bslash > slash))
      slash = bslash;
    if (slash == NULL && path[0] != '\0' && path[1] == ':')
      slash = path + 1;
  }
#endif

  if (slash != (char *) NULL)
    {
      len = slash - path;
      tmpname = (char *) xmalloc (len + sizeof (template) + 2);
      memcpy (tmpname, path, len);

#ifdef HAVE_DOS_BASED_FILE_SYSTEM
      /* If tmpname is "X:", appending a slash will make it a root
	 directory on drive X, which is NOT the same as the current
	 directory on drive X.  */
      if (len == 2 && tmpname[1] == ':')
	tmpname[len++] = '.';
#endif
      tmpname[len++] = '/';
    }
  else
    {
      tmpname = (char *) xmalloc (sizeof (template));
      len = 0;
    }

  memcpy (tmpname + len, template, sizeof (template));
  return tmpname;
#undef template
}

/* Return the name of a created temporary file in the same directory
   as FILENAME.  */

char *
make_tempname (char *filename)
{
  char *tmpname = template_in_dir (filename);
  int fd;

#ifdef HAVE_MKSTEMP
  fd = mkstemp (tmpname);
#else
  tmpname = mktemp (tmpname);
  if (tmpname == NULL)
    return NULL;
  fd = open (tmpname, O_RDWR | O_CREAT | O_EXCL, 0600);
#endif
  if (fd == -1)
    {
      free (tmpname);
      return NULL;
    }
  close (fd);
  return tmpname;
}

/* Return the name of a created temporary directory inside the
   directory containing FILENAME.  */

char *
make_tempdir (char *filename)
{
  char *tmpname = template_in_dir (filename);

#ifdef HAVE_MKDTEMP
  return mkdtemp (tmpname);
#else
  tmpname = mktemp (tmpname);
  if (tmpname == NULL)
    return NULL;
#if defined (_WIN32) && !defined (__CYGWIN32__)
  if (mkdir (tmpname) != 0)
    return NULL;
#else
  if (mkdir (tmpname, 0700) != 0)
    return NULL;
#endif
  return tmpname;
#endif
}

/* Parse a string into a VMA, with a fatal error if it can't be
   parsed.  */

bfd_vma
parse_vma (const char *s, const char *arg)
{
  bfd_vma ret;
  const char *end;

  ret = bfd_scan_vma (s, &end, 0);

  if (*end != '\0')
    fatal (_("%s: bad number: %s"), arg, s);

  return ret;
}

/* Returns the size of the named file.  If the file does not
   exist, or if it is not a real file, then a suitable non-fatal
   error message is printed and (off_t) -1 is returned.  */

off_t
get_file_size (const char * file_name)
{
  struct stat statbuf;
  
  if (stat (file_name, &statbuf) < 0)
    {
      if (errno == ENOENT)
	non_fatal (_("'%s': No such file"), file_name);
      else
	non_fatal (_("Warning: could not locate '%s'.  reason: %s"),
		   file_name, strerror (errno));
    }  
  else if (! S_ISREG (statbuf.st_mode))
    non_fatal (_("Warning: '%s' is not an ordinary file"), file_name);
  else if (statbuf.st_size < 0)
    non_fatal (_("Warning: '%s' has negative size, probably it is too large"),
               file_name);
  else
    return statbuf.st_size;

  return (off_t) -1;
}

/* Return the filename in a static buffer.  */

const char *
bfd_get_archive_filename (const bfd *abfd)
{
  static size_t curr = 0;
  static char *buf;
  size_t needed;

  assert (abfd != NULL);
  
  if (!abfd->my_archive)
    return bfd_get_filename (abfd);

  needed = (strlen (bfd_get_filename (abfd->my_archive))
	    + strlen (bfd_get_filename (abfd)) + 3);
  if (needed > curr)
    {
      if (curr)
	free (buf);
      curr = needed + (needed >> 1);
      buf = (char *) bfd_malloc (curr);
      /* If we can't malloc, fail safe by returning just the file name.
	 This function is only used when building error messages.  */
      if (!buf)
	{
	  curr = 0;
	  return bfd_get_filename (abfd);
	}
    }
  sprintf (buf, "%s(%s)", bfd_get_filename (abfd->my_archive),
	   bfd_get_filename (abfd));
  return buf;
}
@


1.45
log
@	* sysdep.h: Include sys/stat.h here.
	* ar.c: Don't include headers already included by sysdep.h.
	* bucomm.c: Likewise.
	* budbg.h: Likewise.
	* dlltool.h: Likewise.
	* elfedit.c: Likewise.
	* nlmconv.c: Likewise.
	* objcopy.c: Likewise.
	* objdump.c: Likewise.
	* objdump.h: Likewise.
	* readelf.c: Likewise.
	* rename.c: Likewise.
	* resrc.c: Likewise.
	* strings.c: Likewise.
	* windres.c: Likewise.
	* od-macho.c: Ensure #include sysdep.h is first.
	* od-xcoff.c: Likewise.
	* dllwrap.c: Remove alloca pragma handled by sysdep.h, and
	remove duplicate headers.
	* dlltool.c: Likewise and ensure #include sysdep.h is first.
@
text
@d430 1
d437 1
d439 1
a439 1
	  fprintf (file, "%s %ld/%ld %6ld %s ", modebuf + 1,
d441 1
a441 1
		   (long) buf.st_size, timebuf);
@


1.44
log
@2011-10-13  Nick Clifton  <nickc@@redhat.com>

	Fixes to aid translation:
	* addr2line.c (translate_address): Add comments describing context
	of a couple of printf statements.
	* ar.c (write_archive): Allow translation of error message.
	* bucomm.c (endian_string): Allow translation of strings.
	(display_target_list): Allow translation.
	* coffdump.c (dump_coff_type): Allow translation of output.
	(dump_coff_where): Likewise.
	(dump_coff_symbol): Likewise.
	(dump_coff_scope): Likewise.
	(dump_coff_sfile): Likewise.
	(dump_coff_section): Likewise.
	(coff_dump): Likewise.
	* dlltool (def_version): Allow translation of output.
	(run): Likewise.
	* dllwrap.c (run): Allow translation of output.
	* dwarf.c (print_dwarf_vma): Allow translation of output.
	(process_extended_line_op): Remove spurious translation.
	Add translation for strings that can be translated.
	(decode_location_exression): Allow translation of output.
	(read_and_display_attr_value): Allow translation of output.
	* readelf.c (slurp_rela_relocs): Add translation for error
	messages when failing to get data.
	(slurp_rel_relocs): Likewise.
	(get_32bit_elf_symbols): Likewise.
	(get_64bit_elf_symbols): Likewise.
	(dump_ia64_vms_dynamic_relocs): Replace abbreviation with full
	word.
	(process_relocs): Remove spurious translation.
	(decode_tic6x_unwind_bytecode): Likewise.
	(process_version_section): Improve error messages.
	(process_mips_specific): Likewise.
	(print_gnu_note): Remove spurious translation.
	(print_stapsdt_note): Likewise.
	(get_ia64_vms_note_type): Likewise.
	* sysdump.c (getCHARS): Allow translation.
	(fillup): Allow translation of output.
	(getone): Likewise.
	(must): Likewise.
	(derived_type): Likewise.
	* doc/binutils.doc (addr2line): Extend description of command line
	options.
	* po/binutils.pot: Regenerate.
@
text
@d3 1
a3 1
   2003, 2005, 2006, 2007, 2008, 2009, 2010, 2011
a31 1
#include <sys/stat.h>
@


1.43
log
@	* bucomm.c (make_tempname): Stop memory leak.
ICVS: ----------------------------------------------------------------------
@
text
@d228 3
a230 3
    case BFD_ENDIAN_BIG: return "big endian";
    case BFD_ENDIAN_LITTLE: return "little endian";
    default: return "endianness unknown";
d251 1
a251 1
      printf ("%s\n (header %s, data %s)\n", p->name,
@


1.42
log
@	* bucomm.c (get_file_size): Check for negative sizes and issue a
	warning message if encountered.
@
text
@d514 4
a517 1
    return NULL;
@


1.41
log
@	* bucomm.c (bfd_nonfatal, bfd_nonfatal_message): Don't clobber errno.
@
text
@d3 1
a3 1
   2003, 2005, 2006, 2007, 2008, 2009, 2010
d580 3
@


1.41.2.1
log
@backport from mainline
@
text
@d3 1
a3 1
   2003, 2005, 2006, 2007, 2008, 2009, 2010, 2011
a579 3
  else if (statbuf.st_size < 0)
    non_fatal (_("Warning: '%s' has negative size, probably it is too large"),
               file_name);
@


1.40
log
@	* bucomm.c (bfd_nonfatal): Flush stdout before output to stderr.
	(bfd_nonfatal_message, report, list_matching_formats): Likewise.
	(list_supported_targets): Tidy.
	* objdump.c (free_only_list): Formatting.
	(slurp_dynamic_symtab): Non-zero exit status for "not a dynamic
	object".
	(update_source_path): Delete redundant check for NULL filename.
	(disassemble_bytes): Error if disassemble_fn returns a value
	that won't increment address.
	(disassemble_data): Don't capitalize error message.
	(read_section_stabs): Likewise.
	(main): Return non-zero exit status on bad options.
@
text
@d57 1
a58 1
  errmsg = bfd_errmsg (bfd_get_error ());
d87 1
a88 1
  errmsg = bfd_errmsg (bfd_get_error ());
@


1.39
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d3 1
a3 1
   2003, 2005, 2006, 2007, 2008, 2009
d55 1
a55 1
  const char *errmsg = bfd_errmsg (bfd_get_error ());
d57 2
d83 2
a84 2
  const char *errmsg = bfd_errmsg (bfd_get_error ());
  const char *section_name = NULL;
d87 3
d124 1
d174 1
d187 1
a187 1
  const char **targ_names = bfd_target_list ();
d194 1
@


1.38
log
@binutils/
	* bucomm.c (get_file_size): Update comment for the error return value.
@
text
@d73 1
a73 2
   PROGRAM:file[section]: printf-message: bfd-error-message
*/
d77 2
a78 1
		      const bfd *bfd, const asection *section,
d88 1
a88 1
  if (bfd)
d91 1
a91 1
	filename = bfd_get_archive_filename (bfd);
d93 1
a93 1
	section_name = bfd_get_section_name (bfd, section);
@


1.37
log
@        Updated soruces in binutils/* to compile cleanly with -Wc++-compat.

        * binutils/addr2line.c (slurp_symtab): Fix casts. Introduce
        variable minisyms to avoid aliasing varning.
        * binutils/ar.c: Add casts. (normalize): Use name del instead of
        delete. (display_target_list,display_info_table): Change loop
        counter variable a to int.
        * binutils/bucomm.c: Add casts.
        * binutils/debug.c: Update function to use new names. (struct
        debug_baseclass): Rename member from virtual to
        is_virtual. (struct debug_type_s,struct debug_field_s,struct
        debug_baseclass_s,struct debug_method_s,struct
        debug_method_variant_s,struct debug_type_s): Rename struct from
        avoid name collision.
        * /binutils/debug.h: Use new struct names.
        * binutils/dwarf.c: Add casts. (free_debug_memory): Change loop
        counter variable a to int.
        * binutils/ieee.c: Add casts. (enum ieee_var_kind): Move to top
        level. (ieee_class_baseclass): Rename parameter virtual to
        is_virtual. (ieee_class_method_var): Rename variable virtual to
        is_virtual.
        * binutils/nm.c: Add casts.
        * binutils/objcopy.c: Add casts. (copy_archive): Rename variable
        delete to del.
        * binutils/objdump.c: Add casts. (dump_dwarf_section): Change loop
        counter variable i to int.
        * binutils/prdbg.c: Add
        casts. (pr_class_baseclass,tg_class_baseclass): Rename parameters
        virtual to is_virtual.
        * binutils/readelf.c: Add casts. (struct
        ia64_unw_table_entry,struct hppa_unw_table_entry): Move to top
        level.
        * binutils/size.c: Add casts.
        * binutils/stabs.c (parse_stab_type, parse_stab_range_type)
        (parse_stab_cpp_abbrev): Rename parameter from typename to
        type_name. (parse_stab_baseclasses): Rename variable virtual to
        is_virtual.
        * binutils/strings.c: Add casts.
        * binutils/wrstabs.c (stab_class_baseclass): Rename parameter
        virtual to is_virtual.
@
text
@d555 1
a555 1
   error message is printed and zero is returned.  */
@


1.36
log
@update copyright dates
@
text
@d241 1
a241 1
      enum bfd_architecture a;
d287 1
a287 1
  enum bfd_architecture a;
d297 2
a298 1
    if (strcmp (bfd_printable_arch_mach (a, 0), "UNKNOWN!") != 0)
d301 1
a301 1
		bfd_printable_arch_mach (a, 0));
d330 1
a330 1
		if (! bfd_set_arch_mach (abfd, a, 0))
d465 1
a465 1
      tmpname = xmalloc (len + sizeof (template) + 2);
d479 1
a479 1
      tmpname = xmalloc (sizeof (template));
d599 1
a599 1
      buf = bfd_malloc (curr);
@


1.36.2.1
log
@        Update soruces to compile cleanly with -Wc++-compat:

        * addr2line.c (slurp_symtab): Fix casts. Introduce variable
        minisyms to avoid aliasing varning.
        * ar.c: Add casts.
        (normalize): Use name del instead of delete.
        (display_target_list,display_info_table): Change loop counter
        variable a to int.
        * bucomm.c: Add casts.
        * debug.c: Update function to use new names.
        (struct debug_baseclass): Rename member from virtual to
        is_virtual.
        (struct debug_type_s, struct debug_field_s, struct
        debug_baseclass_s, struct debug_method_s, struct
        debug_method_variant_s, struct debug_type_s): Rename struct from
        avoid name collision.
        * debug.h: Use new struct names.
        * dwarf.c: Add casts.
        (free_debug_memory): Change loop counter variable a to int.
        * ieee.c: Add casts.
        (enum ieee_var_kind): Move to top level.
        (ieee_class_baseclass): Rename parameter virtual to is_virtual.
        (ieee_class_method_var): Rename variable virtual to is_virtual.
        * nm.c: Add casts.
        * objcopy.c: Add casts.
        (copy_archive): Rename variable delete to del.
        * objdump.c: Add casts.
        (dump_dwarf_section): Change loop counter variable i to int.
        * prdbg.c: Add casts.
        (pr_class_baseclass,tg_class_baseclass): Rename parameters virtual
        to is_virtual.
        * readelf.c: Add casts.
        (struct ia64_unw_table_entry,struct hppa_unw_table_entry): Move to
        top level.
        * size.c: Add casts.
        * stabs.c (parse_stab_type, parse_stab_range_type,
        (parse_stab_cpp_abbrev): Rename parameter from typename to
        type_name.
        (parse_stab_baseclasses): Rename variable virtual to is_virtual.
        * strings.c: Add casts.
        * wrstabs.c (stab_class_baseclass): Rename parameter virtual to
        is_virtual.
@
text
@d241 1
a241 1
      int a;
d287 1
a287 1
  int a;
d297 1
a297 2
    if (strcmp (bfd_printable_arch_mach ((enum bfd_architecture) a, 0),
                "UNKNOWN!") != 0)
d300 1
a300 1
		bfd_printable_arch_mach ((enum bfd_architecture) a, 0));
d329 1
a329 1
		if (! bfd_set_arch_mach (abfd, (enum bfd_architecture) a, 0))
d464 1
a464 1
      tmpname = (char *) xmalloc (len + sizeof (template) + 2);
d478 1
a478 1
      tmpname = (char *) xmalloc (sizeof (template));
d598 1
a598 1
      buf = (char *) bfd_malloc (curr);
@


1.35
log
@2009-06-27  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/10321
	* bucomm.c (get_file_size): Return -1 on error.

	* objcopy.c (copy_file): Report empty file.
@
text
@d3 1
a3 1
   2003, 2006, 2007, 2008, 2009
@


1.34
log
@	PR 9798
	* bucomm.c (bfd_nonfatal_message): Use bfd_get_archive_filename.
	(bfd_get_archive_filename): Constify param.
	* bucomm.h (bfd_get_archive_filename): Update prototype.
	* objcopy.c (RETURN_NONFATAL): Delete.
	(copy_unknown_object): Don't call bfd_get_archive_filename for
	bfd_nonfatal_message filename, instead just pass bfd.
	(copy_object): Likewise.
	(copy_archive, copy_file): Likewise.  Expand RETURN_NONFATAL.  On
	bfd_close errors, do not pass the bfd to bfd_nonfatal_message.
	(setup_bfd_headers): Fix error message.
@
text
@d574 1
a574 1
  return 0;
@


1.33
log
@PR binutils/55326
   * bucomm.c (list_supported_architectures): Free architecture list after use.
   * windres.c (set_endianess): Likewise.
   * windmc.c (set_endianess): Likewise.
@
text
@d3 1
a3 1
   2003, 2006, 2007
d91 1
a91 1
	filename = bfd_get_filename (bfd);
d580 1
a580 1
bfd_get_archive_filename (bfd *abfd)
@


1.32
log
@	* bucomm.c (bfd_nonfatal_message): New.
	* bucomm.h (bfd_nonfatal_message): Declare.
	* objcopy.c (RETURN_NONFATAL): Take BFD not NAME, use
	bfd_nonfatal_message.
	(copy_unknown_object): Adjust bfd_nonfatal and RETURN_NONFATAL
	calls, or replace with bfd_nonfatal_message calls as appropriate.
	(copy_object, copy_archive, copy_file, setup_section,
	copy_section, write_debugging_info): Likewise.
@
text
@d198 2
a199 1
  const char **arch;
d206 1
a206 1
  for (arch = bfd_arch_list (); *arch; arch++)
d209 1
@


1.31
log
@Change sources over to using GPLv3
@
text
@d63 46
@


1.30
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
@


1.29
log
@bfd/

2007-03-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.am (bfdver.h): Substitute report_bugs_to.  Also
	create doc/bfdver.texi.
	* Makefile.in: Regenerated.

	* configure.in (--with-bugurl): New option.
	* configure: Regenerated.

	* version.h (REPORT_BUGS_TO): New.

binutils/

2007-03-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.am (REPORT_BUGS_TO): Removed.
	(INCLUDES): Remove -DREPORT_BUGS_TO.
	* Makefile.in: Regenerated.

	* bucomm.c: Don't include bfdver.h.
	* objdump.c: Likewise.
	* version.c: Likewise.

	* bucomm.h: Include bfdver.h.

	* configure.in (--with-bugurl): Removed.
	* configure: Regenerated.

	* doc/Makefile.am (binutils_TEXINFOS): Removed.
	(AM_MAKEINFOFLAGS): Add -I ../../bfd/doc.
	(TEXI2DVI): Likewise.
	(config.texi): Removed.
	(MOSTLYCLEANFILES): Remove config.texi.
	* doc/Makefile.in: Regenerated.

	* doc/binutils.texi: Include bfdver.texi instead of
	config.texi.

gas/

2007-03-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.am (REPORT_BUGS_TO): Removed.
	(INCLUDES): Remove -DREPORT_BUGS_TO.
	* Makefile.in: Regenerated.

	* configure.in (--with-bugurl): Removed.
	* configure: Regenerated.

	* doc/Makefile.am (as_TEXINFOS): Remove gasver.texi.
	(AM_MAKEINFOFLAGS): Add -I ../../bfd/doc.
	(TEXI2DVI): Likewise.
	(gasver.texi): Removed.
	(MOSTLYCLEANFILES): Remove gasver.texi.
	(as.1): Don't depend on gasver.texi.
	* doc/Makefile.in: Regenerated.

	* doc/as.texi: Include bfdver.texi instead of gasver.texi.

gprof/

2007-03-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.am (REPORT_BUGS_TO): Removed.
	(INCLUDES): Remove -DREPORT_BUGS_TO.
	* Makefile.in: Regenerated.

	* configure.in (--with-bugurl): Removed.
	* configure: Regenerated.

ld/

2007-03-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.am (ld_TEXINFOS): Remove ldver.texi.
	(AM_MAKEINFOFLAGS): Add -I ../../bfd/doc.
	(TEXI2DVI): Likewise.
	(REPORT_BUGS_TO): Removed.
	(INCLUDES): Remove -DREPORT_BUGS_TO.
	(ldver.texi): Likewise.
	(ld.1): Don't depend on ldver.texi.
	(MOSTLYCLEANFILES): Remove ldver.texi.
	* Makefile.in: Regenerated.

	* configure.in (--with-bugurl): Removed.
	* configure: Regenerated.

	* lexsup.c: Include bfdver.h.

	* ld.texinfo: Include bfdver.texi instead of ldver.texi.
@
text
@d3 1
a3 1
   2003, 2006
d26 1
a28 1
#include "bucomm.h"
d35 1
@


1.28
log
@2007-01-11  H.J. Lu  <hongjiu.lu@@intel.com>

	* bucomm.c (template_in_dir): Fix typo.
@
text
@a26 1
#include "bfdver.h"
@


1.27
log
@	* bucomm.h (make_tempdir): Declare independently of HAVE_MKDTEMP.
	* bucomm.c (template_in_dir): New function, split out from..
	(make_tempname): ..here.  Open the file with O_EXCL if !HAVE_MKSTEMP.
	(make_tempdir): Use template_in_dir.  Handle directory creation
	when !HAVE_MKDTEMP.
	* objcopy.c (MKDIR): Don't define.
	(copy_archive): Use make_tempdir when !HAVE_MKDTEMP too.  Fix
	error message.
@
text
@d397 1
a397 1
  char *slash = strrchr (path, '/');
d409 1
a409 1
      slash = filename + 1;
@


1.26
log
@PR binutils/2876
* configure.in: Check for the mkstemp and mkdtemp functions.
* configure: Regenerate.
* config.in (HAVE_MKDTEMP): New potential define.
(MAKE_MKSTEMP): Likewise.
* bucomm.c (make_tempname): Use mkstemp if it is available.
* make_tempdir): New function: Create a temporary directory using mkdtemp, if
it is available.
* bucomm.h (make_tempdir): New prototype.
* objcopy.c (copy_archive): Use make_tempdir if it is available.
  (strip_main): Produce an warning message if a temporary file could not be
  (copy_main): Likewise.
* ar.c (write_archive): Likewise.
@
text
@d2 2
a3 1
   Copyright 1991, 1992, 1993, 1994, 1995, 1997, 1998, 2000, 2001, 2002, 2003, 2006
d390 2
a391 1
/* Return the name of a created temporary file in the same directory as FILENAME.  */
d393 2
a394 2
char *
make_tempname (char *filename)
d396 2
a397 6
#if defined(HAVE_MKSTEMP)
  static char template[] = "stXXXXXXXXXX";
  int fd;
#else
  static char template[] = "stXXXXXX";
#endif
d399 1
a399 1
  char *slash = strrchr (filename, '/');
d404 1
a404 1
    char *bslash = strrchr (filename, '\\');
d408 1
a408 1
    if (slash == NULL && filename[0] != '\0' && filename[1] == ':')
d415 3
a417 1
      char c;
a418 4
      c = *slash;
      *slash = 0;
      tmpname = xmalloc (strlen (filename) + sizeof (template) + 2);
      strcpy (tmpname, filename);
d423 2
a424 2
      if (tmpname[1] == ':' && tmpname[2] == '\0')
	strcat (tmpname, ".");
d426 1
a426 8
      strcat (tmpname, "/");
      strcat (tmpname, template);
#if defined(HAVE_MKSTEMP)
      fd = mkstemp (tmpname);
#else
      mktemp (tmpname);
#endif
      *slash = c;
d431 24
a454 3
      strcpy (tmpname, template);
#if defined(HAVE_MKSTEMP)
      fd = mkstemp (tmpname);
a455 2
    }
#if defined(HAVE_MKSTEMP)
d458 1
a458 2
  close(fd);
#endif
d462 2
a463 2
#if defined(HAVE_MKDTEMP)
/* Return the name of a created temporary directory inside the directory containing FILENAME.  */
d468 1
a468 3
  static char template[] = "stXXXXXXXXXX";
  char *tmpname;
  char *slash = strrchr (filename, '/');
d470 12
a481 14
  if (slash != (char *) NULL)
    {
      char c;

      c = *slash;
      *slash = 0;
      tmpname = xmalloc (strlen (filename) + sizeof (template) + 1);
      strcpy (tmpname, filename);
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
      /* If tmpname is "X:", appending a slash will make it a root
         directory on drive X, which is NOT the same as the current
         directory on drive X.  */
      if (tmpname[1] == ':' && tmpname[2] == '\0')
        strcat (tmpname, ".");
a482 11
      strcat (tmpname, "/");
      strcat (tmpname, template);
      mkdtemp (tmpname);
      *slash = c;
   }
  else
    {
      tmpname = xmalloc (sizeof (template));
      strcpy (tmpname, template);
      mkdtemp (tmpname);
    }
d484 1
a485 1
#endif /* HAVE_MKDTEMP */
@


1.25
log
@	* bucomm.c (display_target_list): Make local variable `a' to be of
	type enum bfd_architecture.  Thus no need to cast enums to int.
	(display_info_table): Likewise.
@
text
@d2 1
a2 1
   Copyright 1991, 1992, 1993, 1994, 1995, 1997, 1998, 2000, 2001, 2002, 2003
d389 1
a389 1
/* Return the name of a temporary file in the same directory as FILENAME.  */
d394 4
d399 1
d407 1
d432 3
d436 1
d443 47
a489 1
      mktemp (tmpname);
d493 1
@


1.24
log
@2005-06-14  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 995
	* ar.c (BUFSIZE): Moved to ...
	* bucomm.h (BUFSIZE): Here.

	* bucomm.c: Include <assert.h>.
	(bfd_get_archive_filename): New.
	* bucomm.h (bfd_get_archive_filename): New.

	* objcopy.c (copy_unknown_object): New.
	(copy_object): Use bfd_get_archive_filename when reporting input
	error. Don't call fatal on unknown arch.
	(copy_archive): Call copy_unknown_object on unknown format or
	arch.
@
text
@d192 1
a192 1
      int a;
d216 1
a216 1
      for (a = (int) bfd_arch_obscure + 1; a < (int) bfd_arch_last; a++)
a235 1
  int a;
d238 1
d247 1
a247 1
  for (a = (int) bfd_arch_obscure + 1; a < (int) bfd_arch_last; a++)
@


1.23
log
@Update FSF address
@
text
@d34 1
d479 35
@


1.22
log
@2005-04-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* bucomm.c: Undo the last change.
	* bucomm.h: Likewise.
@
text
@d19 2
a20 2
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.21
log
@	* ar.c (mri_mode): Make static.
	* arsup.c (obfd, real_name, outfile): Likewise.
	* binemul.c (ar_emul_create): Remove unused function.
	(ar_emul_default_create): Likewise.
	* binemul.h (ar_emul_create): Remove declaration.
	(ar_emul_default_create): Likewise.
	(struct bin_emulation_xfer_struct): Remove ar_create member.
	* bucomm.c (report): Make static.
	* bucomm.h (report): Remove declaration.
	* cxxfilt.c (mbuffer): Make static.
	(main): Use unsigned ints for some loop control variables.
	* readelf.c: Make many global variables static.
	* size.c (berkeley_format): Make static.
	(long_options): Likewise.
	* emul_aix.c (bin_aix_emulation): Remove ar_emul_default_create
	structure initialiser.
	(bin_aix5_emulation): Likewise.
	* emul_vanilla.c (bin_vanilla_emulation): Likewise.
@
text
@d68 1
a68 1
static void
@


1.20
log
@Use consistent error messages for missing files.
Detect directories where an ordinary file is expected.
@
text
@d68 1
a68 1
void
@


1.19
log
@	* addr2line.c: Convert to ISO C90 prototypes, change PTR, remove
	unneeded (void *) casts.
	* ar.c: Likewise.
	* arlex.l: Likewise.
	* arparse.y: Likewise.
	* arsup.c: Likewise.
	* binemul.c: Likewise.
	* binemul.h: Likewise.
	* bucomm.c: Likewise.
	* bucomm.h: Likewise.
	* budbg.h: Likewise.
	* budemang.c: Likewise.
	* budemang.h: Likewise.
	* coffdump.c: Likewise.
	* coffgrok.c: Likewise.
	* cxxfilt.c: Likewise.
	* debug.c: Likewise.
	* debug.h: Likewise.
	* deflex.l: Likewise.
	* dlltool.c: Likewise.
	* dlltool.h: Likewise.
	* dllwrap.c: Likewise.
	* emul_aix.c: Likewise.
	* filemode.c: Likewise.
	* ieee.c: Likewise.
	* nlmconv.c: Likewise.
	* nlmconv.h: Likewise.
	* nlmheader.y: Likewise.
	* nm.c: Likewise.
	* prdbg.c: Likewise.
	* rclex.l: Likewise.
	* rcparse.y: Likewise.
	* rdcoff.c: Likewise.
	* rddbg.c: Likewise.
	* rename.c: Likewise.
	* resbin.c: Likewise.
	* rescoff.c: Likewise.
	* resrc.c: Likewise.
	* size.c: Likewise.
	* srconv.c: Likewise.
	* stabs.c: Likewise.
	* strings.c: Likewise.
	* sysdump.c: Likewise.
	* sysinfo.y: Likewise.
	* syslex.l: Likewise.
	* unwind-ia64.c: Likewise.
	* unwind-ia64.h: Likewise.
	* version.c: Likewise.
	* windres.c: Likewise.
	* windres.h: Likewise.
	* winduni.c: Likewise.
	* wrstabs.c: Likewise.
@
text
@d453 25
@


1.18
log
@Move display_info() function into bucomm.c
@
text
@d41 4
a44 4
static const char * endian_string PARAMS ((enum bfd_endian));
static int display_target_list PARAMS ((void));
static int display_info_table PARAMS ((int, int));
static int display_target_tables PARAMS ((void));
d51 1
a51 2
bfd_nonfatal (string)
     const char *string;
d62 1
a62 2
bfd_fatal (string)
     const char *string;
d69 1
a69 3
report (format, args)
     const char * format;
     va_list args;
d103 1
a103 1
set_default_bfd_target ()
d118 1
a118 2
list_matching_formats (p)
     char **p;
d129 1
a129 3
list_supported_targets (name, f)
     const char *name;
     FILE *f;
d148 1
a148 3
list_supported_architectures (name, f)
     const char *name;
     FILE *f;
d166 1
a166 2
endian_string (endian)
     enum bfd_endian endian;
d180 1
a180 1
display_target_list ()
d232 1
a232 3
display_info_table (first, last)
     int first;
     int last;
d307 1
a307 1
display_target_tables ()
d346 1
a346 1
display_info ()
d360 1
a360 4
print_arelt_descr (file, abfd, verbose)
     FILE *file;
     bfd *abfd;
     bfd_boolean verbose;
d391 1
a391 2
make_tempname (filename)
     char *filename;
d441 1
a441 3
parse_vma (s, arg)
     const char *s;
     const char *arg;
@


1.17
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2 1
a2 1
   Copyright 1991, 1992, 1993, 1994, 1995, 1997, 1998, 2000, 2001, 2002
d26 1
d30 1
d40 5
d46 1
a46 1
/* Error reporting */
d169 196
@


1.16
log
@	* bucomm.c (list_supported_targets): Use bfd_target_list.
@
text
@d110 1
a110 1
/* After a false return from bfd_check_format_matches with
d172 1
a172 1
     boolean verbose;
@


1.15
log
@	* bucomm.c: Replace CONST with const.
	* nm.c: Likewise.
	* objdump.c: Likewise.
@
text
@a130 1
  extern const bfd_target *const *bfd_target_vector;
d132 1
d138 3
a140 2
  for (t = 0; bfd_target_vector[t] != NULL; t++)
    fprintf (f, " %s", bfd_target_vector[t]->name);
d142 1
d152 1
a152 1
  const char** arch;
@


1.15.2.1
log
@Merge from mainline.
@
text
@d131 1
a132 1
  const char **targ_names = bfd_target_list ();
d138 2
a139 3

  for (t = 0; targ_names[t] != NULL; t++)
    fprintf (f, " %s", targ_names[t]);
a140 1
  free (targ_names);
@


1.14
log
@	* addr2line.c: Fix formatting.
	* ar.c: Likewise.
	* arsup.c: Likewise.
	* arsup.h: Likewise.
	* binemul.c: Likewise.
	* binemul.h: Likewise.
	* bucomm.c: Likewise.
	* coffdump.c: Likewise.
	* coffgrok.c: Likewise.
	* coffgrok.h: Likewise.
@
text
@d2 1
a2 1
   Copyright 1991, 1992, 1993, 1994, 1995, 1997, 1998, 2000, 2001
d45 1
a45 1
     CONST char *string;
d47 1
a47 1
  CONST char *errmsg = bfd_errmsg (bfd_get_error ());
d57 1
a57 1
     CONST char *string;
d181 1
a181 1
	  CONST char *ctime_result = (CONST char *) ctime (&when);
@


1.13
log
@2001-11-29  H.J. Lu <hjl@@gnu.org>

	* bucomm.c (make_tempname): Revert the changes made on
	2001-11-14 and 2001-11-12. They won't work with directories.
@
text
@d260 1
a260 1
  
@


1.12
log
@Replace use of mkstemp with mkstemps, provided by libiberty.
@
text
@a37 3

/* Ought to be defined in libiberty.h...  */
extern int mkstemps PARAMS ((char *, int));
d236 1
a236 1
      close (mkstemps (tmpname, 0));
d243 1
a243 1
      close (mkstemps (tmpname, 0));
@


1.11
log
@Use mkstemp in place of mktemp.
@
text
@d38 3
d239 1
a239 1
      close (mkstemp (tmpname));
d246 1
a246 1
      close (mkstemp (tmpname));
@


1.10
log
@	* bucomm.c (fatal): Define using VPARAMS, VA_OPEN, VA_FIXEDARG,
	VA_CLOSE.
	(non_fatal): Likewise.
	* objdump.c (objdump_sprintf): Likewise.
	* readelf.c (error): Likewise.
	(warn): Likewise.
@
text
@d236 1
a236 1
      mktemp (tmpname);
d243 1
a243 1
      mktemp (tmpname);
@


1.9
log
@	* bucomm.c (list_supported_architectures): New function.
	* bucomm.h (list_supported_architectures): Declare.
	* objdump.c (usage): Call the above.
@
text
@a72 1
#ifdef ANSI_PROTOTYPES
d74 1
a74 1
fatal (const char *format, ...)
d76 2
a77 1
  va_list args;
a78 1
  va_start (args, format);
d80 1
a80 1
  va_end (args);
d85 1
a85 1
non_fatal (const char *format, ...)
d87 2
a88 1
  va_list args;
a89 1
  va_start (args, format);
d91 1
a91 1
  va_end (args);
a92 28
#else
void 
fatal (va_alist)
     va_dcl
{
  char *Format;
  va_list args;

  va_start (args);
  Format = va_arg (args, char *);
  report (Format, args);
  va_end (args);
  xexit (1);
}

void 
non_fatal (va_alist)
     va_dcl
{
  char *Format;
  va_list args;

  va_start (args);
  Format = va_arg (args, char *);
  report (Format, args);
  va_end (args);
}
#endif
@


1.8
log
@Fix typos in ChangeLogs and update copyright notices
@
text
@d171 19
@


1.7
log
@Change bfd_target_vector from an array to a pointer
@
text
@d2 1
a2 1
   Copyright (C) 1991, 92, 93, 94, 95, 97, 98, 2000
@


1.6
log
@Revert incorrect 2000-06-25 patch.
@
text
@d160 1
a160 1
  extern bfd_target *bfd_target_vector[];
@


1.6.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1991, 1992, 1993, 1994, 1995, 1997, 1998, 2000, 2001
@


1.6.2.2
log
@Merge from mainline.
@
text
@d160 1
a160 1
  extern const bfd_target *const *bfd_target_vector;
@


1.5
log
@Advance past both parts of dos based <letter>: filepath prefix.
@
text
@d225 1
a225 1
      slash = filename + 2;
@


1.4
log
@Correct pointer comparisons relying on NULL less than any other pointer.
Alexander Aganichev's fix for ieee.c
@
text
@d225 1
a225 1
      slash = filename + 1;
@


1.3
log
@Eli Zaretskii's DOSish file name patches.
@
text
@d222 1
a222 1
    if (bslash > slash)
@


1.2
log
@A mostly cosmetic tidy up of warnings and error message reporting.
@
text
@d28 1
d218 9
a226 3
#if defined (__DJGPP__) || defined (__GO32__) || defined (_WIN32)
  if (slash == NULL)
    slash = strrchr (filename, '\\');
d235 1
a235 1
      tmpname = xmalloc (strlen (filename) + sizeof (template) + 1);
d237 7
@


1.1
log
@Initial revision
@
text
@d2 2
a3 1
   Copyright (C) 1991, 92, 93, 94, 95, 1997, 1998 Free Software Foundation, Inc.
a36 6

#ifdef ANSI_PROTOTYPES
#include <stdarg.h>
#else
#include <varargs.h>
#endif
d62 1
a62 1
static void
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@


1.1.1.1.2.1
log
@A mostly cosmetic tidy up of warnings and error message reporting.
@
text
@d2 1
a2 2
   Copyright (C) 1991, 92, 93, 94, 95, 97, 98, 2000
   Free Software Foundation, Inc.
d36 6
d67 1
a67 1
void
@


1.1.1.1.2.2
log
@Eli Zaretskii's DOSish file name patches.
@
text
@a27 1
#include "filenames.h"
d217 3
a219 9
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
  {
    /* We could have foo/bar\\baz, or foo\\bar, or d:bar.  */
    char *bslash = strrchr (filename, '\\');
    if (bslash > slash)
      slash = bslash;
    if (slash == NULL && filename[0] != '\0' && filename[1] == ':')
      slash = filename + 1;
  }
d228 1
a228 1
      tmpname = xmalloc (strlen (filename) + sizeof (template) + 2);
a229 7
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
      /* If tmpname is "X:", appending a slash will make it a root
	 directory on drive X, which is NOT the same as the current
	 directory on drive X.  */
      if (tmpname[1] == ':' && tmpname[2] == '\0')
	strcat (tmpname, ".");
#endif
@


