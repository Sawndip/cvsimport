head	1.38;
access;
symbols
	binutils-2_24-branch:1.38.0.4
	binutils-2_24-branchpoint:1.38
	binutils-2_21_1:1.36
	binutils-2_23_2:1.38
	binutils-2_23_1:1.38
	binutils-2_23:1.38
	binutils-2_23-branch:1.38.0.2
	binutils-2_23-branchpoint:1.38
	binutils-2_22_branch:1.37.0.4
	binutils-2_22:1.37
	binutils-2_22-branch:1.37.0.2
	binutils-2_22-branchpoint:1.37
	binutils-2_21:1.36
	binutils-2_21-branch:1.36.0.2
	binutils-2_21-branchpoint:1.36
	binutils-2_20_1:1.35
	binutils-2_20:1.35
	binutils-arc-20081103-branch:1.33.0.8
	binutils-arc-20081103-branchpoint:1.33
	binutils-2_20-branch:1.35.0.2
	binutils-2_20-branchpoint:1.35
	dje-cgen-play1-branch:1.33.0.6
	dje-cgen-play1-branchpoint:1.33
	arc-20081103-branch:1.33.0.4
	arc-20081103-branchpoint:1.33
	binutils-2_19_1:1.33
	binutils-2_19:1.33
	binutils-2_19-branch:1.33.0.2
	binutils-2_19-branchpoint:1.33
	binutils-2_18:1.32
	binutils-2_18-branch:1.32.0.2
	binutils-2_18-branchpoint:1.32
	binutils-csl-coldfire-4_1-32:1.27.2.1
	binutils-csl-sourcerygxx-4_1-32:1.27.2.1
	binutils-csl-innovasic-fido-3_4_4-33:1.27.2.1
	binutils-csl-sourcerygxx-3_4_4-32:1.24.6.1
	binutils-csl-coldfire-4_1-30:1.27.2.1
	binutils-csl-sourcerygxx-4_1-30:1.27.2.1
	binutils-csl-coldfire-4_1-28:1.27.2.1
	binutils-csl-sourcerygxx-4_1-29:1.27.2.1
	binutils-csl-sourcerygxx-4_1-28:1.27.2.1
	binutils-csl-arm-2006q3-27:1.27.2.1
	binutils-csl-sourcerygxx-4_1-27:1.27.2.1
	binutils-csl-arm-2006q3-26:1.27.2.1
	binutils-csl-sourcerygxx-4_1-26:1.27.2.1
	binutils-csl-sourcerygxx-4_1-25:1.27.2.1
	binutils-csl-sourcerygxx-4_1-24:1.27
	binutils-csl-sourcerygxx-4_1-23:1.27
	binutils-csl-sourcerygxx-4_1-21:1.27
	binutils-csl-arm-2006q3-21:1.27
	binutils-csl-sourcerygxx-4_1-22:1.27
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.27
	binutils-csl-sourcerygxx-4_1-20:1.27
	binutils-csl-arm-2006q3-19:1.27
	binutils-csl-sourcerygxx-4_1-19:1.27
	binutils-csl-sourcerygxx-4_1-18:1.27
	binutils-csl-renesas-4_1-9:1.27
	binutils-csl-sourcerygxx-3_4_4-25:1.24.6.1
	binutils-csl-renesas-4_1-8:1.27
	binutils-csl-renesas-4_1-7:1.27
	binutils-csl-renesas-4_1-6:1.27
	binutils-csl-sourcerygxx-4_1-17:1.27
	binutils-csl-sourcerygxx-4_1-14:1.27
	binutils-csl-sourcerygxx-4_1-15:1.27
	binutils-csl-sourcerygxx-4_1-13:1.27
	binutils-2_17:1.27
	binutils-csl-sourcerygxx-4_1-12:1.27
	binutils-csl-sourcerygxx-3_4_4-21:1.27
	binutils-csl-wrs-linux-3_4_4-24:1.24
	binutils-csl-wrs-linux-3_4_4-23:1.24
	binutils-csl-sourcerygxx-4_1-9:1.27
	binutils-csl-sourcerygxx-4_1-8:1.27
	binutils-csl-sourcerygxx-4_1-7:1.27
	binutils-csl-arm-2006q1-6:1.27
	binutils-csl-sourcerygxx-4_1-6:1.27
	binutils-csl-wrs-linux-3_4_4-22:1.24
	binutils-csl-coldfire-4_1-11:1.27
	binutils-csl-sourcerygxx-3_4_4-19:1.27
	binutils-csl-coldfire-4_1-10:1.27
	binutils-csl-sourcerygxx-4_1-5:1.27
	binutils-csl-sourcerygxx-4_1-4:1.27
	binutils-csl-wrs-linux-3_4_4-21:1.24
	binutils-csl-morpho-4_1-4:1.27
	binutils-csl-sourcerygxx-3_4_4-17:1.27
	binutils-csl-wrs-linux-3_4_4-20:1.24
	binutils-2_17-branch:1.27.0.4
	binutils-2_17-branchpoint:1.27
	binutils-csl-2_17-branch:1.27.0.2
	binutils-csl-2_17-branchpoint:1.27
	binutils-csl-gxxpro-3_4-branch:1.24.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.24
	binutils-2_16_1:1.24
	binutils-csl-arm-2005q1b:1.24
	binutils-2_16:1.24
	binutils-csl-arm-2005q1a:1.24
	binutils-csl-arm-2005q1-branch:1.24.0.4
	binutils-csl-arm-2005q1-branchpoint:1.24
	binutils-2_16-branch:1.24.0.2
	binutils-2_16-branchpoint:1.24
	csl-arm-2004-q3d:1.19
	csl-arm-2004-q3:1.19
	binutils-2_15:1.17
	binutils-2_15-branchpoint:1.17
	csl-arm-2004-q1a:1.17
	csl-arm-2004-q1:1.17
	binutils-2_15-branch:1.17.0.6
	cagney_bfdfile-20040213-branch:1.17.0.4
	cagney_bfdfile-20040213-branchpoint:1.17
	cagney_bigcore-20040122-branch:1.17.0.2
	cagney_bigcore-20040122-branchpoint:1.17
	csl-arm-2003-q4:1.17
	binutils-2_14:1.16
	binutils-2_14-branch:1.16.0.2
	binutils-2_14-branchpoint:1.16
	binutils-2_13_2_1:1.14
	binutils-2_13_2:1.14
	binutils-2_13_1:1.14
	binutils-2_13:1.14
	binutils-2_13-branchpoint:1.14
	binutils-2_13-branch:1.14.0.2
	binutils-2_12_1:1.9.2.2
	binutils-2_12:1.9.2.2
	binutils-2_12-branch:1.9.0.2
	binutils-2_12-branchpoint:1.9
	cygnus_cvs_20020108_pre:1.8
	binutils-2_11_2:1.5.2.1
	binutils-2_11_1:1.5.2.1
	binutils-2_11:1.5
	x86_64versiong3:1.5
	binutils-2_11-branch:1.5.0.2
	binutils-2_10_1:1.1.1.1.2.2
	binutils-2_10:1.1.1.1.2.2
	binutils-2_10-branch:1.1.1.1.0.2
	binutils-2_10-branchpoint:1.1.1.1
	binutils_latest_snapshot:1.38
	repo-unification-2000-02-06:1.1.1.1
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.38
date	2012.02.09.04.51.43;	author amodra;	state Exp;
branches;
next	1.37;

1.37
date	2011.02.28.18.32.51;	author ktietz;	state Exp;
branches;
next	1.36;

1.36
date	2009.12.11.13.42.06;	author nickc;	state Exp;
branches;
next	1.35;

1.35
date	2009.09.02.07.22.32;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2009.08.29.22.10.59;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	2008.07.07.00.44.41;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2007.07.05.16.54.45;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	2007.04.26.14.46.59;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2007.02.17.13.33.54;	author jsm28;	state Exp;
branches;
next	1.29;

1.29
date	2006.09.28.12.59.25;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2006.09.16.18.12.17;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	2005.10.03.19.37.44;	author mmitchel;	state Exp;
branches
	1.27.2.1;
next	1.26;

1.26
date	2005.09.30.16.37.31;	author mmitchel;	state Exp;
branches;
next	1.25;

1.25
date	2005.05.08.14.17.38;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2005.02.22.12.57.26;	author amodra;	state Exp;
branches
	1.24.6.1;
next	1.23;

1.23
date	2005.02.16.12.55.43;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2005.02.15.14.31.13;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2005.01.04.15.51.47;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	2005.01.04.15.47.38;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2004.07.15.15.11.56;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2004.06.15.01.19.13;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2003.09.14.12.20.16;	author aj;	state Exp;
branches;
next	1.16;

1.16
date	2002.12.23.10.45.03;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2002.11.30.08.39.41;	author amodra;	state Exp;
branches;
next	1.14;

1.14
date	2002.05.26.14.55.04;	author kazu;	state Exp;
branches;
next	1.13;

1.13
date	2002.05.25.12.51.38;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2002.05.21.19.34.58;	author kazu;	state Exp;
branches;
next	1.11;

1.11
date	2002.02.11.02.41.16;	author drow;	state Exp;
branches;
next	1.10;

1.10
date	2002.02.10.18.47.48;	author drow;	state Exp;
branches;
next	1.9;

1.9
date	2002.01.23.16.12.55;	author nickc;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2001.09.24.06.07.52;	author aj;	state Exp;
branches;
next	1.7;

1.7
date	2001.09.19.05.33.15;	author hjl;	state Exp;
branches;
next	1.6;

1.6
date	2001.03.13.06.43.57;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2000.05.13.06.38.34;	author hjl;	state Exp;
branches
	1.5.2.1;
next	1.4;

1.4
date	2000.04.07.04.34.50;	author amodra;	state Exp;
branches;
next	1.3;

1.3
date	2000.04.04.14.32.29;	author amodra;	state Exp;
branches;
next	1.2;

1.2
date	2000.04.03.14.10.03;	author amodra;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.29.10;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.27.2.1
date	2006.10.16.20.21.23;	author nathan;	state Exp;
branches;
next	;

1.24.6.1
date	2005.08.30.19.57.32;	author mmitchel;	state Exp;
branches;
next	;

1.9.2.1
date	2002.02.10.18.46.59;	author drow;	state Exp;
branches;
next	1.9.2.2;

1.9.2.2
date	2002.02.11.02.40.31;	author drow;	state Exp;
branches;
next	;

1.5.2.1
date	2001.06.07.03.12.27;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.10;	author rth;	state Exp;
branches
	1.1.1.1.2.1;
next	;

1.1.1.1.2.1
date	2000.04.05.05.36.40;	author amodra;	state Exp;
branches;
next	1.1.1.1.2.2;

1.1.1.1.2.2
date	2000.04.07.04.39.24;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.38
log
@	* sysdep.h: Include sys/stat.h here.
	* ar.c: Don't include headers already included by sysdep.h.
	* bucomm.c: Likewise.
	* budbg.h: Likewise.
	* dlltool.h: Likewise.
	* elfedit.c: Likewise.
	* nlmconv.c: Likewise.
	* objcopy.c: Likewise.
	* objdump.c: Likewise.
	* objdump.h: Likewise.
	* readelf.c: Likewise.
	* rename.c: Likewise.
	* resrc.c: Likewise.
	* strings.c: Likewise.
	* windres.c: Likewise.
	* od-macho.c: Ensure #include sysdep.h is first.
	* od-xcoff.c: Likewise.
	* dllwrap.c: Remove alloca pragma handled by sysdep.h, and
	remove duplicate headers.
	* dlltool.c: Likewise and ensure #include sysdep.h is first.
@
text
@/* nlmconv.c -- NLM conversion program
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002,
   2003, 2004, 2005, 2006, 2007, 2008, 2009, 2011, 2012
   Free Software Foundation, Inc.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */


/* Written by Ian Lance Taylor <ian@@cygnus.com>.

   This program can be used to convert any appropriate object file
   into a NetWare Loadable Module (an NLM).  It will accept a linker
   specification file which is identical to that accepted by the
   NetWare linker, NLMLINK.  */

/* AIX requires this to be the first thing in the file.  */
#ifndef __GNUC__
# ifdef _AIX
 #pragma alloca
#endif
#endif

#include "sysdep.h"
#include "bfd.h"
#include "libiberty.h"
#include "filenames.h"
#include "safe-ctype.h"

#include "ansidecl.h"
#include <time.h>
#include <assert.h>
#include "getopt.h"

/* Internal BFD NLM header.  */
#include "libnlm.h"
#include "nlmconv.h"

#ifdef NLMCONV_ALPHA
#include "coff/sym.h"
#include "coff/ecoff.h"
#endif

#include "bucomm.h"

/* If strerror is just a macro, we want to use the one from libiberty
   since it will handle undefined values.  */
#undef strerror
extern char *strerror (int);

#ifndef SEEK_SET
#define SEEK_SET 0
#endif

#ifndef R_OK
#define R_OK 4
#define W_OK 2
#define X_OK 1
#endif

/* Global variables.  */

/* The name used to invoke the program.  */
char *program_name;

/* Local variables.  */

/* Whether to print out debugging information (currently just controls
   whether it prints the linker command if there is one).  */
static int debug;

/* The symbol table.  */
static asymbol **symbols;

/* A section we create in the output file to hold pointers to where
   the sections of the input file end up.  We will put a pointer to
   this section in the NLM header.  These is an entry for each input
   section.  The format is
       null terminated section name
       zeroes to adjust to 4 byte boundary
       4 byte section data file pointer
       4 byte section size
   We don't need a version number.  The way we find this information
   is by finding a stamp in the NLM header information.  If we need to
   change the format of this information, we can simply change the
   stamp.  */
static asection *secsec;

/* A temporary file name to be unlinked on exit.  Actually, for most
   errors, we leave it around.  It's not clear whether that is helpful
   or not.  */
static char *unlink_on_exit;

/* The list of long options.  */
static struct option long_options[] =
{
  { "debug", no_argument, 0, 'd' },
  { "header-file", required_argument, 0, 'T' },
  { "help", no_argument, 0, 'h' },
  { "input-target", required_argument, 0, 'I' },
  { "input-format", required_argument, 0, 'I' }, /* Obsolete */
  { "linker", required_argument, 0, 'l' },
  { "output-target", required_argument, 0, 'O' },
  { "output-format", required_argument, 0, 'O' }, /* Obsolete */
  { "version", no_argument, 0, 'V' },
  { NULL, no_argument, 0, 0 }
};

/* Local routines.  */

int main (int, char **);

static void show_usage (FILE *, int);
static const char *select_output_format
  (enum bfd_architecture, unsigned long, bfd_boolean);
static void setup_sections (bfd *, asection *, void *);
static void copy_sections (bfd *, asection *, void *);
static void mangle_relocs
  (bfd *, asection *, arelent ***, long *, char *, bfd_size_type);
static void default_mangle_relocs
  (bfd *, asection *, arelent ***, long *, char *, bfd_size_type);
static char *link_inputs (struct string_list *, char *, char *);

#ifdef NLMCONV_I386
static void i386_mangle_relocs (bfd *, asection *, arelent ***, long *, char *, bfd_size_type);
#endif

#ifdef NLMCONV_ALPHA
static void alpha_mangle_relocs (bfd *, asection *, arelent ***, long *, char *, bfd_size_type);
#endif

#ifdef NLMCONV_POWERPC
static void powerpc_build_stubs (bfd *, bfd *, asymbol ***, long *);
static void powerpc_resolve_stubs (bfd *, bfd *);
static void powerpc_mangle_relocs (bfd *, asection *, arelent ***, long *, char *, bfd_size_type);
#endif

/* The main routine.  */

int
main (int argc, char **argv)
{
  int opt;
  char *input_file = NULL;
  const char *input_format = NULL;
  const char *output_format = NULL;
  const char *header_file = NULL;
  char *ld_arg = NULL;
  Nlm_Internal_Fixed_Header fixed_hdr_struct;
  Nlm_Internal_Variable_Header var_hdr_struct;
  Nlm_Internal_Version_Header version_hdr_struct;
  Nlm_Internal_Copyright_Header copyright_hdr_struct;
  Nlm_Internal_Extended_Header extended_hdr_struct;
  bfd *inbfd;
  bfd *outbfd;
  asymbol **newsyms, **outsyms;
  long symcount, newsymalloc, newsymcount;
  long symsize;
  asection *text_sec, *bss_sec, *data_sec;
  bfd_vma vma;
  bfd_size_type align;
  asymbol *endsym;
  long i;
  char inlead, outlead;
  bfd_boolean gotstart, gotexit, gotcheck;
  struct stat st;
  FILE *custom_data = NULL;
  FILE *help_data = NULL;
  FILE *message_data = NULL;
  FILE *rpc_data = NULL;
  FILE *shared_data = NULL;
  size_t custom_size = 0;
  size_t help_size = 0;
  size_t message_size = 0;
  size_t module_size = 0;
  size_t rpc_size = 0;
  asection *custom_section = NULL;
  asection *help_section = NULL;
  asection *message_section = NULL;
  asection *module_section = NULL;
  asection *rpc_section = NULL;
  asection *shared_section = NULL;
  bfd *sharedbfd;
  size_t shared_offset = 0;
  size_t shared_size = 0;
  static Nlm_Internal_Fixed_Header sharedhdr;
  int len;
  char *modname;
  char **matching;

#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

  program_name = argv[0];
  xmalloc_set_program_name (program_name);

  expandargv (&argc, &argv);

  bfd_init ();
  set_default_bfd_target ();

  while ((opt = getopt_long (argc, argv, "dHhI:l:O:T:Vv", long_options,
			     (int *) NULL))
	 != EOF)
    {
      switch (opt)
	{
	case 'd':
	  debug = 1;
	  break;
	case 'H':
	case 'h':
	  show_usage (stdout, 0);
	  break;
	case 'I':
	  input_format = optarg;
	  break;
	case 'l':
	  ld_arg = optarg;
	  break;
	case 'O':
	  output_format = optarg;
	  break;
	case 'T':
	  header_file = optarg;
	  break;
	case 'v':
	case 'V':
	  print_version ("nlmconv");
	  break;
	case 0:
	  break;
	default:
	  show_usage (stderr, 1);
	  break;
	}
    }

  /* The input and output files may be named on the command line.  */
  output_file = NULL;
  if (optind < argc)
    {
      input_file = argv[optind];
      ++optind;
      if (optind < argc)
	{
	  output_file = argv[optind];
	  ++optind;
	  if (optind < argc)
	    show_usage (stderr, 1);
	  if (filename_cmp (input_file, output_file) == 0)
	    {
	      fatal (_("input and output files must be different"));
	    }
	}
    }

  /* Initialize the header information to default values.  */
  fixed_hdr = &fixed_hdr_struct;
  memset ((void *) &fixed_hdr_struct, 0, sizeof fixed_hdr_struct);
  var_hdr = &var_hdr_struct;
  memset ((void *) &var_hdr_struct, 0, sizeof var_hdr_struct);
  version_hdr = &version_hdr_struct;
  memset ((void *) &version_hdr_struct, 0, sizeof version_hdr_struct);
  copyright_hdr = &copyright_hdr_struct;
  memset ((void *) &copyright_hdr_struct, 0, sizeof copyright_hdr_struct);
  extended_hdr = &extended_hdr_struct;
  memset ((void *) &extended_hdr_struct, 0, sizeof extended_hdr_struct);
  check_procedure = NULL;
  custom_file = NULL;
  debug_info = FALSE;
  exit_procedure = "_Stop";
  export_symbols = NULL;
  map_file = NULL;
  full_map = FALSE;
  help_file = NULL;
  import_symbols = NULL;
  message_file = NULL;
  modules = NULL;
  sharelib_file = NULL;
  start_procedure = "_Prelude";
  verbose = FALSE;
  rpc_file = NULL;

  parse_errors = 0;

  /* Parse the header file (if there is one).  */
  if (header_file != NULL)
    {
      if (! nlmlex_file (header_file)
	  || yyparse () != 0
	  || parse_errors != 0)
	exit (1);
    }

  if (input_files != NULL)
    {
      if (input_file != NULL)
	{
	  fatal (_("input file named both on command line and with INPUT"));
	}
      if (input_files->next == NULL)
	input_file = input_files->string;
      else
	input_file = link_inputs (input_files, ld_arg, map_file);
    }
  else if (input_file == NULL)
    {
      non_fatal (_("no input file"));
      show_usage (stderr, 1);
    }

  inbfd = bfd_openr (input_file, input_format);
  if (inbfd == NULL)
    bfd_fatal (input_file);

  if (! bfd_check_format_matches (inbfd, bfd_object, &matching))
    {
      bfd_nonfatal (input_file);
      if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
	{
	  list_matching_formats (matching);
	  free (matching);
	}
      exit (1);
    }

  if (output_format == NULL)
    output_format = select_output_format (bfd_get_arch (inbfd),
					  bfd_get_mach (inbfd),
					  bfd_big_endian (inbfd));

  assert (output_format != NULL);

  /* Use the output file named on the command line if it exists.
     Otherwise use the file named in the OUTPUT statement.  */
  if (output_file == NULL)
    {
      non_fatal (_("no name for output file"));
      show_usage (stderr, 1);
    }

  outbfd = bfd_openw (output_file, output_format);
  if (outbfd == NULL)
    bfd_fatal (output_file);
  if (! bfd_set_format (outbfd, bfd_object))
    bfd_fatal (output_file);

  assert (bfd_get_flavour (outbfd) == bfd_target_nlm_flavour);

  /* XXX: Should we accept the unknown bfd format here ?  */
  if (bfd_arch_get_compatible (inbfd, outbfd, TRUE) == NULL)
    non_fatal (_("warning: input and output formats are not compatible"));

  /* Move the values read from the command file into outbfd.  */
  *nlm_fixed_header (outbfd) = fixed_hdr_struct;
  *nlm_variable_header (outbfd) = var_hdr_struct;
  *nlm_version_header (outbfd) = version_hdr_struct;
  *nlm_copyright_header (outbfd) = copyright_hdr_struct;
  *nlm_extended_header (outbfd) = extended_hdr_struct;

  /* Start copying the input BFD to the output BFD.  */
  if (! bfd_set_file_flags (outbfd, bfd_get_file_flags (inbfd)))
    bfd_fatal (bfd_get_filename (outbfd));

  symsize = bfd_get_symtab_upper_bound (inbfd);
  if (symsize < 0)
    bfd_fatal (input_file);
  symbols = (asymbol **) xmalloc (symsize);
  symcount = bfd_canonicalize_symtab (inbfd, symbols);
  if (symcount < 0)
    bfd_fatal (input_file);

  /* Make sure we have a .bss section.  */
  bss_sec = bfd_get_section_by_name (outbfd, NLM_UNINITIALIZED_DATA_NAME);
  if (bss_sec == NULL)
    {
      bss_sec = bfd_make_section_with_flags (outbfd,
					     NLM_UNINITIALIZED_DATA_NAME,
					     SEC_ALLOC);
      if (bss_sec == NULL
	  || ! bfd_set_section_alignment (outbfd, bss_sec, 1))
	bfd_fatal (_("make .bss section"));
    }

  /* We store the original section names in the .nlmsections section,
     so that programs which understand it can resurrect the original
     sections from the NLM.  We will put a pointer to .nlmsections in
     the NLM header area.  */
  secsec = bfd_make_section_with_flags (outbfd, ".nlmsections",
					SEC_HAS_CONTENTS);
  if (secsec == NULL)
    bfd_fatal (_("make .nlmsections section"));

#ifdef NLMCONV_POWERPC
  /* For PowerPC NetWare we need to build stubs for calls to undefined
     symbols.  Because each stub requires an entry in the TOC section
     which must be at the same location as other entries in the TOC
     section, we must do this before determining where the TOC section
     goes in setup_sections.  */
  if (bfd_get_arch (inbfd) == bfd_arch_powerpc)
    powerpc_build_stubs (inbfd, outbfd, &symbols, &symcount);
#endif

  /* Set up the sections.  */
  bfd_map_over_sections (inbfd, setup_sections, (void *) outbfd);

  text_sec = bfd_get_section_by_name (outbfd, NLM_CODE_NAME);

  /* The .bss section immediately follows the .data section.  */
  data_sec = bfd_get_section_by_name (outbfd, NLM_INITIALIZED_DATA_NAME);
  if (data_sec != NULL)
    {
      bfd_size_type add;

      vma = bfd_get_section_size (data_sec);
      align = 1 << bss_sec->alignment_power;
      add = ((vma + align - 1) &~ (align - 1)) - vma;
      vma += add;
      if (! bfd_set_section_vma (outbfd, bss_sec, vma))
	bfd_fatal (_("set .bss vma"));
      if (add != 0)
	{
	  bfd_size_type data_size;

	  data_size = bfd_get_section_size (data_sec);
	  if (! bfd_set_section_size (outbfd, data_sec, data_size + add))
	    bfd_fatal (_("set .data size"));
	}
    }

  /* Adjust symbol information.  */
  inlead = bfd_get_symbol_leading_char (inbfd);
  outlead = bfd_get_symbol_leading_char (outbfd);
  gotstart = FALSE;
  gotexit = FALSE;
  gotcheck = FALSE;
  newsymalloc = 10;
  newsyms = (asymbol **) xmalloc (newsymalloc * sizeof (asymbol *));
  newsymcount = 0;
  endsym = NULL;
  for (i = 0; i < symcount; i++)
    {
      asymbol *sym;

      sym = symbols[i];

      /* Add or remove a leading underscore.  */
      if (inlead != outlead)
	{
	  if (inlead != '\0')
	    {
	      if (bfd_asymbol_name (sym)[0] == inlead)
		{
		  if (outlead == '\0')
		    ++sym->name;
		  else
		    {
		      char *new_name;

		      new_name = xmalloc (strlen (bfd_asymbol_name (sym)) + 1);
		      new_name[0] = outlead;
		      strcpy (new_name + 1, bfd_asymbol_name (sym) + 1);
		      sym->name = new_name;
		    }
		}
	    }
	  else
	    {
	      char *new_name;

	      new_name = xmalloc (strlen (bfd_asymbol_name (sym)) + 2);
	      new_name[0] = outlead;
	      strcpy (new_name + 1, bfd_asymbol_name (sym));
	      sym->name = new_name;
	    }
	}

      /* NLM's have an uninitialized data section, but they do not
	 have a common section in the Unix sense.  Move all common
	 symbols into the .bss section, and mark them as exported.  */
      if (bfd_is_com_section (bfd_get_section (sym)))
	{
	  bfd_vma size = sym->value;

	  sym->section = bss_sec;
	  sym->value = bfd_get_section_size (bss_sec);
	  size += sym->value;
	  align = 1 << bss_sec->alignment_power;
	  size = (size + align - 1) & ~(align - 1);
	  bfd_set_section_size (outbfd, bss_sec, size);
	  sym->flags |= BSF_EXPORT | BSF_GLOBAL;
	}
      else if (bfd_get_section (sym)->output_section != NULL)
	{
	  /* Move the symbol into the output section.  */
	  sym->value += bfd_get_section (sym)->output_offset;
	  sym->section = bfd_get_section (sym)->output_section;
	  /* This is no longer a section symbol.  */
	  sym->flags &=~ BSF_SECTION_SYM;
	}

      /* Force _edata and _end to be defined.  This would normally be
	 done by the linker, but the manipulation of the common
	 symbols will confuse it.  */
      if ((sym->flags & BSF_DEBUGGING) == 0
	  && bfd_asymbol_name (sym)[0] == '_'
	  && bfd_is_und_section (bfd_get_section (sym)))
	{
	  if (strcmp (bfd_asymbol_name (sym), "_edata") == 0)
	    {
	      sym->section = bss_sec;
	      sym->value = 0;
	    }
	  if (strcmp (bfd_asymbol_name (sym), "_end") == 0)
	    {
	      sym->section = bss_sec;
	      endsym = sym;
	    }

#ifdef NLMCONV_POWERPC
	  /* For PowerPC NetWare, we define __GOT0.  This is the start
	     of the .got section.  */
	  if (bfd_get_arch (inbfd) == bfd_arch_powerpc
	      && strcmp (bfd_asymbol_name (sym), "__GOT0") == 0)
	    {
	      asection *got_sec;

	      got_sec = bfd_get_section_by_name (inbfd, ".got");
	      assert (got_sec != (asection *) NULL);
	      sym->value = got_sec->output_offset;
	      sym->section = got_sec->output_section;
	    }
#endif
	}

      /* If this is a global symbol, check the export list.  */
      if ((sym->flags & (BSF_EXPORT | BSF_GLOBAL)) != 0)
	{
	  struct string_list *l;
	  int found_simple;

	  /* Unfortunately, a symbol can appear multiple times on the
	     export list, with and without prefixes.  */
	  found_simple = 0;
	  for (l = export_symbols; l != NULL; l = l->next)
	    {
	      if (strcmp (l->string, bfd_asymbol_name (sym)) == 0)
		found_simple = 1;
	      else
		{
		  char *zbase;

		  zbase = strchr (l->string, '@@');
		  if (zbase != NULL
		      && strcmp (zbase + 1, bfd_asymbol_name (sym)) == 0)
		    {
		      /* We must add a symbol with this prefix.  */
		      if (newsymcount >= newsymalloc)
			{
			  newsymalloc += 10;
			  newsyms = ((asymbol **)
				     xrealloc ((void *) newsyms,
					       (newsymalloc
						* sizeof (asymbol *))));
			}
		      newsyms[newsymcount] =
			(asymbol *) xmalloc (sizeof (asymbol));
		      *newsyms[newsymcount] = *sym;
		      newsyms[newsymcount]->name = l->string;
		      ++newsymcount;
		    }
		}
	    }
	  if (! found_simple)
	    {
	      /* The unmodified symbol is actually not exported at
		 all.  */
	      sym->flags &=~ (BSF_GLOBAL | BSF_EXPORT);
	      sym->flags |= BSF_LOCAL;
	    }
	}

      /* If it's an undefined symbol, see if it's on the import list.
	 Change the prefix if necessary.  */
      if (bfd_is_und_section (bfd_get_section (sym)))
	{
	  struct string_list *l;

	  for (l = import_symbols; l != NULL; l = l->next)
	    {
	      if (strcmp (l->string, bfd_asymbol_name (sym)) == 0)
		break;
	      else
		{
		  char *zbase;

		  zbase = strchr (l->string, '@@');
		  if (zbase != NULL
		      && strcmp (zbase + 1, bfd_asymbol_name (sym)) == 0)
		    {
		      sym->name = l->string;
		      break;
		    }
		}
	    }
	  if (l == NULL)
	    non_fatal (_("warning: symbol %s imported but not in import list"),
		       bfd_asymbol_name (sym));
	}

      /* See if it's one of the special named symbols.  */
      if ((sym->flags & BSF_DEBUGGING) == 0)
	{
	  bfd_vma val;

	  /* FIXME: If these symbols are not in the .text section, we
	     add the .text section size to the value.  This may not be
	     correct for all targets.  I'm not sure how this should
	     really be handled.  */
	  if (strcmp (bfd_asymbol_name (sym), start_procedure) == 0)
	    {
	      val = bfd_asymbol_value (sym);
	      if (bfd_get_section (sym) == data_sec
		  && text_sec != (asection *) NULL)
		val += bfd_section_size (outbfd, text_sec);
	      if (! bfd_set_start_address (outbfd, val))
		bfd_fatal (_("set start address"));
	      gotstart = TRUE;
	    }
	  if (strcmp (bfd_asymbol_name (sym), exit_procedure) == 0)
	    {
	      val = bfd_asymbol_value (sym);
	      if (bfd_get_section (sym) == data_sec
		  && text_sec != (asection *) NULL)
		val += bfd_section_size (outbfd, text_sec);
	      nlm_fixed_header (outbfd)->exitProcedureOffset = val;
	      gotexit = TRUE;
	    }
	  if (check_procedure != NULL
	      && strcmp (bfd_asymbol_name (sym), check_procedure) == 0)
	    {
	      val = bfd_asymbol_value (sym);
	      if (bfd_get_section (sym) == data_sec
		  && text_sec != (asection *) NULL)
		val += bfd_section_size (outbfd, text_sec);
	      nlm_fixed_header (outbfd)->checkUnloadProcedureOffset = val;
	      gotcheck = TRUE;
	    }
	}
    }

  if (endsym != NULL)
    {
      endsym->value = bfd_get_section_size (bss_sec);

      /* FIXME: If any relocs referring to _end use inplace addends,
	 then I think they need to be updated.  This is handled by
	 i386_mangle_relocs.  Is it needed for any other object
	 formats?  */
    }

  if (newsymcount == 0)
    outsyms = symbols;
  else
    {
      outsyms = (asymbol **) xmalloc ((symcount + newsymcount + 1)
				      * sizeof (asymbol *));
      memcpy (outsyms, symbols, symcount * sizeof (asymbol *));
      memcpy (outsyms + symcount, newsyms, newsymcount * sizeof (asymbol *));
      outsyms[symcount + newsymcount] = NULL;
    }

  bfd_set_symtab (outbfd, outsyms, symcount + newsymcount);

  if (! gotstart)
    non_fatal (_("warning: START procedure %s not defined"), start_procedure);
  if (! gotexit)
    non_fatal (_("warning: EXIT procedure %s not defined"), exit_procedure);
  if (check_procedure != NULL && ! gotcheck)
    non_fatal (_("warning: CHECK procedure %s not defined"), check_procedure);

  /* Add additional sections required for the header information.  */
  if (custom_file != NULL)
    {
      custom_data = fopen (custom_file, "r");
      if (custom_data == NULL
	  || fstat (fileno (custom_data), &st) < 0)
	{
	  fprintf (stderr, "%s:%s: %s\n", program_name, custom_file,
		   strerror (errno));
	  custom_file = NULL;
	}
      else
	{
	  custom_size = st.st_size;
	  custom_section = bfd_make_section_with_flags (outbfd, ".nlmcustom",
							SEC_HAS_CONTENTS);
	  if (custom_section == NULL
	      || ! bfd_set_section_size (outbfd, custom_section, custom_size))
	    bfd_fatal (_("custom section"));
	}
    }
  if (help_file != NULL)
    {
      help_data = fopen (help_file, "r");
      if (help_data == NULL
	  || fstat (fileno (help_data), &st) < 0)
	{
	  fprintf (stderr, "%s:%s: %s\n", program_name, help_file,
		   strerror (errno));
	  help_file = NULL;
	}
      else
	{
	  help_size = st.st_size;
	  help_section = bfd_make_section_with_flags (outbfd, ".nlmhelp",
						      SEC_HAS_CONTENTS);
	  if (help_section == NULL
	      || ! bfd_set_section_size (outbfd, help_section, help_size))
	    bfd_fatal (_("help section"));
	  LITMEMCPY (nlm_extended_header (outbfd)->stamp, "MeSsAgEs");
	}
    }
  if (message_file != NULL)
    {
      message_data = fopen (message_file, "r");
      if (message_data == NULL
	  || fstat (fileno (message_data), &st) < 0)
	{
	  fprintf (stderr, "%s:%s: %s\n", program_name, message_file,
		   strerror (errno));
	  message_file = NULL;
	}
      else
	{
	  message_size = st.st_size;
	  message_section = bfd_make_section_with_flags (outbfd,
							 ".nlmmessages",
							 SEC_HAS_CONTENTS);
	  if (message_section == NULL
	      || ! bfd_set_section_size (outbfd, message_section, message_size))
	    bfd_fatal (_("message section"));
	  LITMEMCPY (nlm_extended_header (outbfd)->stamp, "MeSsAgEs");
	}
    }
  if (modules != NULL)
    {
      struct string_list *l;

      module_size = 0;
      for (l = modules; l != NULL; l = l->next)
	module_size += strlen (l->string) + 1;
      module_section = bfd_make_section_with_flags (outbfd, ".nlmmodules",
						    SEC_HAS_CONTENTS);
      if (module_section == NULL
	  || ! bfd_set_section_size (outbfd, module_section, module_size))
	bfd_fatal (_("module section"));
    }
  if (rpc_file != NULL)
    {
      rpc_data = fopen (rpc_file, "r");
      if (rpc_data == NULL
	  || fstat (fileno (rpc_data), &st) < 0)
	{
	  fprintf (stderr, "%s:%s: %s\n", program_name, rpc_file,
		   strerror (errno));
	  rpc_file = NULL;
	}
      else
	{
	  rpc_size = st.st_size;
	  rpc_section = bfd_make_section_with_flags (outbfd, ".nlmrpc",
						     SEC_HAS_CONTENTS);
	  if (rpc_section == NULL
	      || ! bfd_set_section_size (outbfd, rpc_section, rpc_size))
	    bfd_fatal (_("rpc section"));
	  LITMEMCPY (nlm_extended_header (outbfd)->stamp, "MeSsAgEs");
	}
    }
  if (sharelib_file != NULL)
    {
      sharedbfd = bfd_openr (sharelib_file, output_format);
      if (sharedbfd == NULL
	  || ! bfd_check_format (sharedbfd, bfd_object))
	{
	  fprintf (stderr, "%s:%s: %s\n", program_name, sharelib_file,
		   bfd_errmsg (bfd_get_error ()));
	  sharelib_file = NULL;
	}
      else
	{
	  sharedhdr = *nlm_fixed_header (sharedbfd);
	  bfd_close (sharedbfd);
	  shared_data = fopen (sharelib_file, "r");
	  if (shared_data == NULL
	      || (fstat (fileno (shared_data), &st) < 0))
	    {
	      fprintf (stderr, "%s:%s: %s\n", program_name, sharelib_file,
		       strerror (errno));
	      sharelib_file = NULL;
	    }
	  else
	    {
	      /* If we were clever, we could just copy out the
		 sections of the shared library which we actually
		 need.  However, we would have to figure out the sizes
		 of the external and public information, and that can
		 not be done without reading through them.  */
	      if (sharedhdr.uninitializedDataSize > 0)
		{
		  /* There is no place to record this information.  */
		  non_fatal (_("%s: warning: shared libraries can not have uninitialized data"),
			     sharelib_file);
		}
	      shared_offset = st.st_size;
	      if (shared_offset > (size_t) sharedhdr.codeImageOffset)
		shared_offset = sharedhdr.codeImageOffset;
	      if (shared_offset > (size_t) sharedhdr.dataImageOffset)
		shared_offset = sharedhdr.dataImageOffset;
	      if (shared_offset > (size_t) sharedhdr.relocationFixupOffset)
		shared_offset = sharedhdr.relocationFixupOffset;
	      if (shared_offset > (size_t) sharedhdr.externalReferencesOffset)
		shared_offset = sharedhdr.externalReferencesOffset;
	      if (shared_offset > (size_t) sharedhdr.publicsOffset)
		shared_offset = sharedhdr.publicsOffset;
	      shared_size = st.st_size - shared_offset;
	      shared_section = bfd_make_section_with_flags (outbfd,
							    ".nlmshared",
							    SEC_HAS_CONTENTS);
	      if (shared_section == NULL
		  || ! bfd_set_section_size (outbfd, shared_section,
					     shared_size))
		bfd_fatal (_("shared section"));
	      LITMEMCPY (nlm_extended_header (outbfd)->stamp, "MeSsAgEs");
	    }
	}
    }

  /* Check whether a version was given.  */
  if (!CONST_STRNEQ (version_hdr->stamp, "VeRsIoN#"))
    non_fatal (_("warning: No version number given"));

  /* At least for now, always create an extended header, because that
     is what NLMLINK does.  */
  LITMEMCPY (nlm_extended_header (outbfd)->stamp, "MeSsAgEs");

  LITMEMCPY (nlm_cygnus_ext_header (outbfd)->stamp, "CyGnUsEx");

  /* If the date was not given, force it in.  */
  if (nlm_version_header (outbfd)->month == 0
      && nlm_version_header (outbfd)->day == 0
      && nlm_version_header (outbfd)->year == 0)
    {
      time_t now;
      struct tm *ptm;

      time (&now);
      ptm = localtime (&now);
      nlm_version_header (outbfd)->month = ptm->tm_mon + 1;
      nlm_version_header (outbfd)->day = ptm->tm_mday;
      nlm_version_header (outbfd)->year = ptm->tm_year + 1900;
      LITMEMCPY (version_hdr->stamp, "VeRsIoN#");
    }

#ifdef NLMCONV_POWERPC
  /* Resolve the stubs we build for PowerPC NetWare.  */
  if (bfd_get_arch (inbfd) == bfd_arch_powerpc)
    powerpc_resolve_stubs (inbfd, outbfd);
#endif

  /* Copy over the sections.  */
  bfd_map_over_sections (inbfd, copy_sections, (void *) outbfd);

  /* Finish up the header information.  */
  if (custom_file != NULL)
    {
      void *data;

      data = xmalloc (custom_size);
      if (fread (data, 1, custom_size, custom_data) != custom_size)
	non_fatal (_("%s: read: %s"), custom_file, strerror (errno));
      else
	{
	  if (! bfd_set_section_contents (outbfd, custom_section, data,
					  (file_ptr) 0, custom_size))
	    bfd_fatal (_("custom section"));
	  nlm_fixed_header (outbfd)->customDataOffset =
	    custom_section->filepos;
	  nlm_fixed_header (outbfd)->customDataSize = custom_size;
	}
      free (data);
    }
  if (! debug_info)
    {
      /* As a special hack, the backend recognizes a debugInfoOffset
	 of -1 to mean that it should not output any debugging
	 information.  This can not be handling by fiddling with the
	 symbol table because exported symbols appear in both the
	 export information and the debugging information.  */
      nlm_fixed_header (outbfd)->debugInfoOffset = (file_ptr) -1;
    }
  if (full_map)
    non_fatal (_("warning: FULLMAP is not supported; try ld -M"));
  if (help_file != NULL)
    {
      void *data;

      data = xmalloc (help_size);
      if (fread (data, 1, help_size, help_data) != help_size)
	non_fatal (_("%s: read: %s"), help_file, strerror (errno));
      else
	{
	  if (! bfd_set_section_contents (outbfd, help_section, data,
					  (file_ptr) 0, help_size))
	    bfd_fatal (_("help section"));
	  nlm_extended_header (outbfd)->helpFileOffset =
	    help_section->filepos;
	  nlm_extended_header (outbfd)->helpFileLength = help_size;
	}
      free (data);
    }
  if (message_file != NULL)
    {
      void *data;

      data = xmalloc (message_size);
      if (fread (data, 1, message_size, message_data) != message_size)
	non_fatal (_("%s: read: %s"), message_file, strerror (errno));
      else
	{
	  if (! bfd_set_section_contents (outbfd, message_section, data,
					  (file_ptr) 0, message_size))
	    bfd_fatal (_("message section"));
	  nlm_extended_header (outbfd)->messageFileOffset =
	    message_section->filepos;
	  nlm_extended_header (outbfd)->messageFileLength = message_size;

	  /* FIXME: Are these offsets correct on all platforms?  Are
	     they 32 bits on all platforms?  What endianness?  */
	  nlm_extended_header (outbfd)->languageID =
	    bfd_h_get_32 (outbfd, (bfd_byte *) data + 106);
	  nlm_extended_header (outbfd)->messageCount =
	    bfd_h_get_32 (outbfd, (bfd_byte *) data + 110);
	}
      free (data);
    }
  if (modules != NULL)
    {
      void *data;
      unsigned char *set;
      struct string_list *l;
      bfd_size_type c;

      data = xmalloc (module_size);
      c = 0;
      set = (unsigned char *) data;
      for (l = modules; l != NULL; l = l->next)
	{
	  *set = strlen (l->string);
	  strncpy ((char *) set + 1, l->string, *set);
	  set += *set + 1;
	  ++c;
	}
      if (! bfd_set_section_contents (outbfd, module_section, data,
				      (file_ptr) 0, module_size))
	bfd_fatal (_("module section"));
      nlm_fixed_header (outbfd)->moduleDependencyOffset =
	module_section->filepos;
      nlm_fixed_header (outbfd)->numberOfModuleDependencies = c;
    }
  if (rpc_file != NULL)
    {
      void *data;

      data = xmalloc (rpc_size);
      if (fread (data, 1, rpc_size, rpc_data) != rpc_size)
	non_fatal (_("%s: read: %s"), rpc_file, strerror (errno));
      else
	{
	  if (! bfd_set_section_contents (outbfd, rpc_section, data,
					  (file_ptr) 0, rpc_size))
	    bfd_fatal (_("rpc section"));
	  nlm_extended_header (outbfd)->RPCDataOffset =
	    rpc_section->filepos;
	  nlm_extended_header (outbfd)->RPCDataLength = rpc_size;
	}
      free (data);
    }
  if (sharelib_file != NULL)
    {
      void *data;

      data = xmalloc (shared_size);
      if (fseek (shared_data, shared_offset, SEEK_SET) != 0
	  || fread (data, 1, shared_size, shared_data) != shared_size)
	non_fatal (_("%s: read: %s"), sharelib_file, strerror (errno));
      else
	{
	  if (! bfd_set_section_contents (outbfd, shared_section, data,
					  (file_ptr) 0, shared_size))
	    bfd_fatal (_("shared section"));
	}
      nlm_extended_header (outbfd)->sharedCodeOffset =
	sharedhdr.codeImageOffset - shared_offset + shared_section->filepos;
      nlm_extended_header (outbfd)->sharedCodeLength =
	sharedhdr.codeImageSize;
      nlm_extended_header (outbfd)->sharedDataOffset =
	sharedhdr.dataImageOffset - shared_offset + shared_section->filepos;
      nlm_extended_header (outbfd)->sharedDataLength =
	sharedhdr.dataImageSize;
      nlm_extended_header (outbfd)->sharedRelocationFixupOffset =
	(sharedhdr.relocationFixupOffset
	 - shared_offset
	 + shared_section->filepos);
      nlm_extended_header (outbfd)->sharedRelocationFixupCount =
	sharedhdr.numberOfRelocationFixups;
      nlm_extended_header (outbfd)->sharedExternalReferenceOffset =
	(sharedhdr.externalReferencesOffset
	 - shared_offset
	 + shared_section->filepos);
      nlm_extended_header (outbfd)->sharedExternalReferenceCount =
	sharedhdr.numberOfExternalReferences;
      nlm_extended_header (outbfd)->sharedPublicsOffset =
	sharedhdr.publicsOffset - shared_offset + shared_section->filepos;
      nlm_extended_header (outbfd)->sharedPublicsCount =
	sharedhdr.numberOfPublics;
      nlm_extended_header (outbfd)->sharedDebugRecordOffset =
	sharedhdr.debugInfoOffset - shared_offset + shared_section->filepos;
      nlm_extended_header (outbfd)->sharedDebugRecordCount =
	sharedhdr.numberOfDebugRecords;
      nlm_extended_header (outbfd)->SharedInitializationOffset =
	sharedhdr.codeStartOffset;
      nlm_extended_header (outbfd)->SharedExitProcedureOffset =
	sharedhdr.exitProcedureOffset;
      free (data);
    }

  {
    const int    max_len  = NLM_MODULE_NAME_SIZE - 2;
    const char * filename = lbasename (output_file);
    
    len = strlen (filename);
    if (len > max_len)
      len = max_len;
    nlm_fixed_header (outbfd)->moduleName[0] = len;

    strncpy (nlm_fixed_header (outbfd)->moduleName + 1, filename, max_len);
    nlm_fixed_header (outbfd)->moduleName[max_len + 1] = '\0';

    for (modname = nlm_fixed_header (outbfd)->moduleName;
	 *modname != '\0';
	 modname++)
      *modname = TOUPPER (*modname);
  }

  strncpy (nlm_variable_header (outbfd)->oldThreadName, " LONG",
	   NLM_OLD_THREAD_NAME_LENGTH);

  nlm_cygnus_ext_header (outbfd)->offset = secsec->filepos;
  nlm_cygnus_ext_header (outbfd)->length = bfd_section_size (outbfd, secsec);

  if (! bfd_close (outbfd))
    bfd_fatal (output_file);
  if (! bfd_close (inbfd))
    bfd_fatal (input_file);

  if (unlink_on_exit != NULL)
    unlink (unlink_on_exit);

  return 0;
}


/* Show a usage message and exit.  */

static void
show_usage (FILE *file, int status)
{
  fprintf (file, _("Usage: %s [option(s)] [in-file [out-file]]\n"), program_name);
  fprintf (file, _(" Convert an object file into a NetWare Loadable Module\n"));
  fprintf (file, _(" The options are:\n\
  -I --input-target=<bfdname>   Set the input binary file format\n\
  -O --output-target=<bfdname>  Set the output binary file format\n\
  -T --header-file=<file>       Read <file> for NLM header information\n\
  -l --linker=<linker>          Use <linker> for any linking\n\
  -d --debug                    Display on stderr the linker command line\n\
  @@<file>                       Read options from <file>.\n\
  -h --help                     Display this information\n\
  -v --version                  Display the program's version\n\
"));
  if (REPORT_BUGS_TO[0] && status == 0)
    fprintf (file, _("Report bugs to %s\n"), REPORT_BUGS_TO);
  exit (status);
}

/* Select the output format based on the input architecture, machine,
   and endianness.  This chooses the appropriate NLM target.  */

static const char *
select_output_format (enum bfd_architecture arch, unsigned long mach,
		      bfd_boolean bigendian ATTRIBUTE_UNUSED)
{
  switch (arch)
    {
#ifdef NLMCONV_I386
    case bfd_arch_i386:
      return "nlm32-i386";
#endif
#ifdef NLMCONV_SPARC
    case bfd_arch_sparc:
      return "nlm32-sparc";
#endif
#ifdef NLMCONV_ALPHA
    case bfd_arch_alpha:
      return "nlm32-alpha";
#endif
#ifdef NLMCONV_POWERPC
    case bfd_arch_powerpc:
      return "nlm32-powerpc";
#endif
    default:
      fatal (_("support not compiled in for %s"),
	     bfd_printable_arch_mach (arch, mach));
    }
  /*NOTREACHED*/
}

/* The BFD sections are copied in two passes.  This function selects
   the output section for each input section, and sets up the section
   name, size, etc.  */

static void
setup_sections (bfd *inbfd ATTRIBUTE_UNUSED, asection *insec, void *data_ptr)
{
  bfd *outbfd = (bfd *) data_ptr;
  flagword f;
  const char *outname;
  asection *outsec;
  bfd_vma offset;
  bfd_size_type align;
  bfd_size_type add;
  bfd_size_type secsecsize;

  f = bfd_get_section_flags (inbfd, insec);
  if (f & SEC_CODE)
    outname = NLM_CODE_NAME;
  else if ((f & SEC_LOAD) && (f & SEC_HAS_CONTENTS))
    outname = NLM_INITIALIZED_DATA_NAME;
  else if (f & SEC_ALLOC)
    outname = NLM_UNINITIALIZED_DATA_NAME;
  else
    outname = bfd_section_name (inbfd, insec);

  outsec = bfd_get_section_by_name (outbfd, outname);
  if (outsec == NULL)
    {
      outsec = bfd_make_section (outbfd, outname);
      if (outsec == NULL)
	bfd_fatal (_("make section"));
    }

  insec->output_section = outsec;

  offset = bfd_section_size (outbfd, outsec);
  align = 1 << bfd_section_alignment (inbfd, insec);
  add = ((offset + align - 1) &~ (align - 1)) - offset;
  insec->output_offset = offset + add;

  if (! bfd_set_section_size (outbfd, outsec,
			      (bfd_section_size (outbfd, outsec)
			       + bfd_section_size (inbfd, insec)
			       + add)))
    bfd_fatal (_("set section size"));

  if ((bfd_section_alignment (inbfd, insec)
       > bfd_section_alignment (outbfd, outsec))
      && ! bfd_set_section_alignment (outbfd, outsec,
				      bfd_section_alignment (inbfd, insec)))
    bfd_fatal (_("set section alignment"));

  if (! bfd_set_section_flags (outbfd, outsec,
			       f | bfd_get_section_flags (outbfd, outsec)))
    bfd_fatal (_("set section flags"));

  bfd_set_reloc (outbfd, outsec, (arelent **) NULL, 0);

  /* For each input section we allocate space for an entry in
     .nlmsections.  */
  secsecsize = bfd_section_size (outbfd, secsec);
  secsecsize += strlen (bfd_section_name (inbfd, insec)) + 1;
  secsecsize = (secsecsize + 3) &~ 3;
  secsecsize += 8;
  if (! bfd_set_section_size (outbfd, secsec, secsecsize))
    bfd_fatal (_("set .nlmsections size"));
}

/* Copy the section contents.  */

static void
copy_sections (bfd *inbfd, asection *insec, void *data_ptr)
{
  static bfd_size_type secsecoff = 0;
  bfd *outbfd = (bfd *) data_ptr;
  const char *inname;
  asection *outsec;
  bfd_size_type size;
  void *contents;
  long reloc_size;
  bfd_byte buf[4];
  bfd_size_type add;

  inname = bfd_section_name (inbfd, insec);

  outsec = insec->output_section;
  assert (outsec != NULL);

  size = bfd_get_section_size (insec);

  if ((bfd_get_section_flags (inbfd, insec) & SEC_HAS_CONTENTS) == 0)
    contents = NULL;
  else
    {
      contents = xmalloc (size);
      if (! bfd_get_section_contents (inbfd, insec, contents,
				      (file_ptr) 0, size))
	bfd_fatal (bfd_get_filename (inbfd));
    }

  reloc_size = bfd_get_reloc_upper_bound (inbfd, insec);
  if (reloc_size < 0)
    bfd_fatal (bfd_get_filename (inbfd));
  if (reloc_size != 0)
    {
      arelent **relocs;
      long reloc_count;

      relocs = (arelent **) xmalloc (reloc_size);
      reloc_count = bfd_canonicalize_reloc (inbfd, insec, relocs, symbols);
      if (reloc_count < 0)
	bfd_fatal (bfd_get_filename (inbfd));
      mangle_relocs (outbfd, insec, &relocs, &reloc_count, (char *) contents,
		     size);

      /* FIXME: refers to internal BFD fields.  */
      if (outsec->orelocation != (arelent **) NULL)
	{
	  bfd_size_type total_count;
	  arelent **combined;

	  total_count = reloc_count + outsec->reloc_count;
	  combined = (arelent **) xmalloc (total_count * sizeof (arelent *));
	  memcpy (combined, outsec->orelocation,
		  outsec->reloc_count * sizeof (arelent *));
	  memcpy (combined + outsec->reloc_count, relocs,
		  (size_t) (reloc_count * sizeof (arelent *)));
	  free (outsec->orelocation);
	  reloc_count = total_count;
	  relocs = combined;
	}

      bfd_set_reloc (outbfd, outsec, relocs, reloc_count);
    }

  if (contents != NULL)
    {
      if (! bfd_set_section_contents (outbfd, outsec, contents,
				      insec->output_offset, size))
	bfd_fatal (bfd_get_filename (outbfd));
      free (contents);
    }

  /* Add this section to .nlmsections.  */
  if (! bfd_set_section_contents (outbfd, secsec, (void *) inname, secsecoff,
				  strlen (inname) + 1))
    bfd_fatal (_("set .nlmsection contents"));
  secsecoff += strlen (inname) + 1;

  add = ((secsecoff + 3) &~ 3) - secsecoff;
  if (add != 0)
    {
      bfd_h_put_32 (outbfd, (bfd_vma) 0, buf);
      if (! bfd_set_section_contents (outbfd, secsec, buf, secsecoff, add))
	bfd_fatal (_("set .nlmsection contents"));
      secsecoff += add;
    }

  if (contents != NULL)
    bfd_h_put_32 (outbfd, (bfd_vma) outsec->filepos, buf);
  else
    bfd_h_put_32 (outbfd, (bfd_vma) 0, buf);
  if (! bfd_set_section_contents (outbfd, secsec, buf, secsecoff, 4))
    bfd_fatal (_("set .nlmsection contents"));
  secsecoff += 4;

  bfd_h_put_32 (outbfd, (bfd_vma) size, buf);
  if (! bfd_set_section_contents (outbfd, secsec, buf, secsecoff, 4))
    bfd_fatal (_("set .nlmsection contents"));
  secsecoff += 4;
}

/* Some, perhaps all, NetWare targets require changing the relocs used
   by the input formats.  */

static void
mangle_relocs (bfd *outbfd, asection *insec, arelent ***relocs_ptr,
	       long *reloc_count_ptr, char *contents,
	       bfd_size_type contents_size)
{
  switch (bfd_get_arch (outbfd))
    {
#ifdef NLMCONV_I386
    case bfd_arch_i386:
      i386_mangle_relocs (outbfd, insec, relocs_ptr, reloc_count_ptr,
			  contents, contents_size);
      break;
#endif
#ifdef NLMCONV_ALPHA
    case bfd_arch_alpha:
      alpha_mangle_relocs (outbfd, insec, relocs_ptr, reloc_count_ptr,
			   contents, contents_size);
      break;
#endif
#ifdef NLMCONV_POWERPC
    case bfd_arch_powerpc:
      powerpc_mangle_relocs (outbfd, insec, relocs_ptr, reloc_count_ptr,
			     contents, contents_size);
      break;
#endif
    default:
      default_mangle_relocs (outbfd, insec, relocs_ptr, reloc_count_ptr,
			     contents, contents_size);
      break;
    }
}

/* By default all we need to do for relocs is change the address by
   the output_offset.  */

static void
default_mangle_relocs (bfd *outbfd ATTRIBUTE_UNUSED, asection *insec,
		       arelent ***relocs_ptr, long *reloc_count_ptr,
		       char *contents ATTRIBUTE_UNUSED,
		       bfd_size_type contents_size ATTRIBUTE_UNUSED)
{
  if (insec->output_offset != 0)
    {
      long reloc_count;
      arelent **relocs;
      long i;

      reloc_count = *reloc_count_ptr;
      relocs = *relocs_ptr;
      for (i = 0; i < reloc_count; i++, relocs++)
	(*relocs)->address += insec->output_offset;
    }
}

#ifdef NLMCONV_I386

/* NetWare on the i386 supports a restricted set of relocs, which are
   different from those used on other i386 targets.  This routine
   converts the relocs.  It is, obviously, very target dependent.  At
   the moment, the nlm32-i386 backend performs similar translations;
   however, it is more reliable and efficient to do them here.  */

static reloc_howto_type nlm_i386_pcrel_howto =
  HOWTO (1,			/* type */
	 0,			/* rightshift */
	 2,			/* size (0 = byte, 1 = short, 2 = long) */
	 32,			/* bitsize */
	 TRUE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_signed, /* complain_on_overflow */
	 0,			/* special_function */
	 "DISP32",		/* name */
	 TRUE,			/* partial_inplace */
	 0xffffffff,		/* src_mask */
	 0xffffffff,		/* dst_mask */
	 TRUE);			/* pcrel_offset */

static void
i386_mangle_relocs (bfd *outbfd, asection *insec, arelent ***relocs_ptr,
		    long *reloc_count_ptr, char *contents,
		    bfd_size_type contents_size)
{
  long reloc_count, i;
  arelent **relocs;

  reloc_count = *reloc_count_ptr;
  relocs = *relocs_ptr;
  for (i = 0; i < reloc_count; i++)
    {
      arelent *rel;
      asymbol *sym;
      bfd_size_type address;
      bfd_vma addend;

      rel = *relocs++;
      sym = *rel->sym_ptr_ptr;

      /* We're moving the relocs from the input section to the output
	 section, so we must adjust the address accordingly.  */
      address = rel->address;
      rel->address += insec->output_offset;

      /* Note that no serious harm will ensue if we fail to change a
	 reloc.  The backend will fail when writing out the reloc.  */

      /* Make sure this reloc is within the data we have.  We use only
	 4 byte relocs here, so we insist on having 4 bytes.  */
      if (address + 4 > contents_size)
	continue;

      /* A PC relative reloc entirely within a single section is
	 completely unnecessary.  This can be generated by ld -r.  */
      if (sym == insec->symbol
	  && rel->howto != NULL
	  && rel->howto->pc_relative
	  && ! rel->howto->pcrel_offset)
	{
	  --*reloc_count_ptr;
	  --relocs;
	  memmove (relocs, relocs + 1,
		   (size_t) ((reloc_count - i) * sizeof (arelent *)));
	  continue;
	}

      /* Get the amount the relocation will add in.  */
      addend = rel->addend + sym->value;

      /* NetWare doesn't support PC relative relocs against defined
	 symbols, so we have to eliminate them by doing the relocation
	 now.  We can only do this if the reloc is within a single
	 section.  */
      if (rel->howto != NULL
	  && rel->howto->pc_relative
	  && bfd_get_section (sym) == insec->output_section)
	{
	  bfd_vma val;

	  if (rel->howto->pcrel_offset)
	    addend -= address;

	  val = bfd_get_32 (outbfd, (bfd_byte *) contents + address);
	  val += addend;
	  bfd_put_32 (outbfd, val, (bfd_byte *) contents + address);

	  --*reloc_count_ptr;
	  --relocs;
	  memmove (relocs, relocs + 1,
		   (size_t) ((reloc_count - i) * sizeof (arelent *)));
	  continue;
	}

      /* NetWare doesn't support reloc addends, so we get rid of them
	 here by simply adding them into the object data.  We handle
	 the symbol value, if any, the same way.  */
      if (addend != 0
	  && rel->howto != NULL
	  && rel->howto->rightshift == 0
	  && rel->howto->size == 2
	  && rel->howto->bitsize == 32
	  && rel->howto->bitpos == 0
	  && rel->howto->src_mask == 0xffffffff
	  && rel->howto->dst_mask == 0xffffffff)
	{
	  bfd_vma val;

	  val = bfd_get_32 (outbfd, (bfd_byte *) contents + address);
	  val += addend;
	  bfd_put_32 (outbfd, val, (bfd_byte *) contents + address);

	  /* Adjust the reloc for the changes we just made.  */
	  rel->addend = 0;
	  if (! bfd_is_und_section (bfd_get_section (sym)))
	    rel->sym_ptr_ptr = bfd_get_section (sym)->symbol_ptr_ptr;
	}

      /* NetWare uses a reloc with pcrel_offset set.  We adjust
	 pc_relative relocs accordingly.  We are going to change the
	 howto field, so we can only do this if the current one is
	 compatible.  We should check that special_function is NULL
	 here, but at the moment coff-i386 uses a special_function
	 which does not affect what we are doing here.  */
      if (rel->howto != NULL
	  && rel->howto->pc_relative
	  && ! rel->howto->pcrel_offset
	  && rel->howto->rightshift == 0
	  && rel->howto->size == 2
	  && rel->howto->bitsize == 32
	  && rel->howto->bitpos == 0
	  && rel->howto->src_mask == 0xffffffff
	  && rel->howto->dst_mask == 0xffffffff)
	{
	  bfd_vma val;

	  /* When pcrel_offset is not set, it means that the negative
	     of the address of the memory location is stored in the
	     memory location.  We must add it back in.  */
	  val = bfd_get_32 (outbfd, (bfd_byte *) contents + address);
	  val += address;
	  bfd_put_32 (outbfd, val, (bfd_byte *) contents + address);

	  /* We must change to a new howto.  */
	  rel->howto = &nlm_i386_pcrel_howto;
	}
    }
}

#endif /* NLMCONV_I386 */

#ifdef NLMCONV_ALPHA

/* On the Alpha the first reloc for every section must be a special
   relocs which hold the GP address.  Also, the first reloc in the
   file must be a special reloc which holds the address of the .lita
   section.  */

static reloc_howto_type nlm32_alpha_nw_howto =
  HOWTO (ALPHA_R_NW_RELOC,	/* type */
	 0,			/* rightshift */
	 0,			/* size (0 = byte, 1 = short, 2 = long) */
	 0,			/* bitsize */
	 FALSE,			/* pc_relative */
	 0,			/* bitpos */
	 complain_overflow_dont, /* complain_on_overflow */
	 0,			/* special_function */
	 "NW_RELOC",		/* name */
	 FALSE,			/* partial_inplace */
	 0,			/* src_mask */
	 0,			/* dst_mask */
	 FALSE);		/* pcrel_offset */

static void
alpha_mangle_relocs (bfd *outbfd, asection *insec,
		     arelent ***relocs_ptr, long *reloc_count_ptr,
		     char *contents ATTRIBUTE_UNUSED,
		     bfd_size_type contents_size ATTRIBUTE_UNUSED)
{
  long old_reloc_count;
  arelent **old_relocs;
  arelent **relocs;

  old_reloc_count = *reloc_count_ptr;
  old_relocs = *relocs_ptr;
  relocs = (arelent **) xmalloc ((old_reloc_count + 3) * sizeof (arelent *));
  *relocs_ptr = relocs;

  if (nlm_alpha_backend_data (outbfd)->lita_address == 0)
    {
      bfd *inbfd;
      asection *lita_section;

      inbfd = insec->owner;
      lita_section = bfd_get_section_by_name (inbfd, _LITA);
      if (lita_section != (asection *) NULL)
	{
	  nlm_alpha_backend_data (outbfd)->lita_address =
	    bfd_get_section_vma (inbfd, lita_section);
	  nlm_alpha_backend_data (outbfd)->lita_size =
	    bfd_section_size (inbfd, lita_section);
	}
      else
	{
	  /* Avoid outputting this reloc again.  */
	  nlm_alpha_backend_data (outbfd)->lita_address = 4;
	}

      *relocs = (arelent *) xmalloc (sizeof (arelent));
      (*relocs)->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
      (*relocs)->address = nlm_alpha_backend_data (outbfd)->lita_address;
      (*relocs)->addend = nlm_alpha_backend_data (outbfd)->lita_size + 1;
      (*relocs)->howto = &nlm32_alpha_nw_howto;
      ++relocs;
      ++(*reloc_count_ptr);
    }

  /* Get the GP value from bfd.  */
  if (nlm_alpha_backend_data (outbfd)->gp == 0)
    nlm_alpha_backend_data (outbfd)->gp =
      bfd_ecoff_get_gp_value (insec->owner);

  *relocs = (arelent *) xmalloc (sizeof (arelent));
  (*relocs)->sym_ptr_ptr = bfd_abs_section_ptr->symbol_ptr_ptr;
  (*relocs)->address = nlm_alpha_backend_data (outbfd)->gp;
  (*relocs)->addend = 0;
  (*relocs)->howto = &nlm32_alpha_nw_howto;
  ++relocs;
  ++(*reloc_count_ptr);

  memcpy (relocs, old_relocs, (size_t) old_reloc_count * sizeof (arelent *));
  relocs[old_reloc_count] = (arelent *) NULL;

  free (old_relocs);

  if (insec->output_offset != 0)
    {
      bfd_size_type i;

      for (i = 0; i < (bfd_size_type) old_reloc_count; i++, relocs++)
	(*relocs)->address += insec->output_offset;
    }
}

#endif /* NLMCONV_ALPHA */

#ifdef NLMCONV_POWERPC

/* We keep a linked list of stubs which we must build.  Because BFD
   requires us to know the sizes of all sections before we can set the
   contents of any, we must figure out which stubs we want to build
   before we can actually build any of them.  */

struct powerpc_stub
{
  /* Next stub in linked list.  */
  struct powerpc_stub *next;

  /* Symbol whose value is the start of the stub.  This is a symbol
     whose name begins with `.'.  */
  asymbol *start;

  /* Symbol we are going to create a reloc against.  This is a symbol
     with the same name as START but without the leading `.'.  */
  asymbol *reloc;

  /* The TOC index for this stub.  This is the index into the TOC
     section at which the reloc is created.  */
  unsigned int toc_index;
};

/* The linked list of stubs.  */

static struct powerpc_stub *powerpc_stubs;

/* This is what a stub looks like.  The first instruction will get
   adjusted with the correct TOC index.  */

static unsigned long powerpc_stub_insns[] =
{
  0x81820000,		/* lwz	 r12,0(r2) */
  0x90410014,		/* stw	 r2,20(r1) */
  0x800c0000,		/* lwz	 r0,0(r12) */
  0x804c0004,		/* lwz	 r2,r(r12) */
  0x7c0903a6,		/* mtctr r0 */
  0x4e800420,		/* bctr */
  0,			/* Traceback table.  */
  0xc8000,
  0
};

#define POWERPC_STUB_INSN_COUNT \
  (sizeof powerpc_stub_insns / sizeof powerpc_stub_insns[0])

#define POWERPC_STUB_SIZE (4 * POWERPC_STUB_INSN_COUNT)

/* Each stub uses a four byte TOC entry.  */
#define POWERPC_STUB_TOC_ENTRY_SIZE (4)

/* The original size of the .got section.  */
static bfd_size_type powerpc_initial_got_size;

/* Look for all undefined symbols beginning with `.', and prepare to
   build a stub for each one.  */

static void
powerpc_build_stubs (bfd *inbfd, bfd *outbfd ATTRIBUTE_UNUSED,
		     asymbol ***symbols_ptr, long *symcount_ptr)
{
  asection *stub_sec;
  asection *got_sec;
  unsigned int got_base;
  long i;
  long symcount;
  long stubcount;

  /* Make a section to hold stubs.  We don't set SEC_HAS_CONTENTS for
     the section to prevent copy_sections from reading from it.  */
  stub_sec = bfd_make_section_with_flags (inbfd, ".stubs",
					  (SEC_CODE
					   | SEC_RELOC
					   | SEC_ALLOC
					   | SEC_LOAD));
  if (stub_sec == (asection *) NULL
      || ! bfd_set_section_alignment (inbfd, stub_sec, 2))
    bfd_fatal (".stubs");

  /* Get the TOC section, which is named .got.  */
  got_sec = bfd_get_section_by_name (inbfd, ".got");
  if (got_sec == (asection *) NULL)
    {
      got_sec = bfd_make_section_with_flags (inbfd, ".got",
					     (SEC_DATA
					      | SEC_RELOC
					      | SEC_ALLOC
					      | SEC_LOAD
					      | SEC_HAS_CONTENTS));
      if (got_sec == (asection *) NULL
	  || ! bfd_set_section_alignment (inbfd, got_sec, 2))
	bfd_fatal (".got");
    }

  powerpc_initial_got_size = bfd_section_size (inbfd, got_sec);
  got_base = powerpc_initial_got_size;
  got_base = (got_base + 3) &~ 3;

  stubcount = 0;

  symcount = *symcount_ptr;
  for (i = 0; i < symcount; i++)
    {
      asymbol *sym;
      asymbol *newsym;
      char *newname;
      struct powerpc_stub *item;

      sym = (*symbols_ptr)[i];

      /* We must make a stub for every undefined symbol whose name
	 starts with '.'.  */
      if (bfd_asymbol_name (sym)[0] != '.'
	  || ! bfd_is_und_section (bfd_get_section (sym)))
	continue;

      /* Make a new undefined symbol with the same name but without
	 the leading `.'.  */
      newsym = xmalloc (sizeof (asymbol));
      *newsym = *sym;
      newname = xmalloc (strlen (bfd_asymbol_name (sym)));
      strcpy (newname, bfd_asymbol_name (sym) + 1);
      newsym->name = newname;

      /* Define the `.' symbol to be in the stub section.  */
      sym->section = stub_sec;
      sym->value = stubcount * POWERPC_STUB_SIZE;
      /* We set the BSF_DYNAMIC flag here so that we can check it when
	 we are mangling relocs.  FIXME: This is a hack.  */
      sym->flags = BSF_LOCAL | BSF_DYNAMIC;

      /* Add this stub to the linked list.  */
      item = (struct powerpc_stub *) xmalloc (sizeof (struct powerpc_stub));
      item->start = sym;
      item->reloc = newsym;
      item->toc_index = got_base + stubcount * POWERPC_STUB_TOC_ENTRY_SIZE;

      item->next = powerpc_stubs;
      powerpc_stubs = item;

      ++stubcount;
    }

  if (stubcount > 0)
    {
      asymbol **s;
      struct powerpc_stub *l;

      /* Add the new symbols we just created to the symbol table.  */
      *symbols_ptr = (asymbol **) xrealloc ((char *) *symbols_ptr,
					    ((symcount + stubcount)
					     * sizeof (asymbol)));
      *symcount_ptr += stubcount;
      s = &(*symbols_ptr)[symcount];
      for (l = powerpc_stubs; l != (struct powerpc_stub *) NULL; l = l->next)
	*s++ = l->reloc;

      /* Set the size of the .stubs section and increase the size of
	 the .got section.  */
      if (! bfd_set_section_size (inbfd, stub_sec,
				  stubcount * POWERPC_STUB_SIZE)
	  || ! bfd_set_section_size (inbfd, got_sec,
				     (got_base
				      + (stubcount
					 * POWERPC_STUB_TOC_ENTRY_SIZE))))
	bfd_fatal (_("stub section sizes"));
    }
}

/* Resolve all the stubs for PowerPC NetWare.  We fill in the contents
   of the output section, and create new relocs in the TOC.  */

static void
powerpc_resolve_stubs (bfd *inbfd, bfd *outbfd)
{
  bfd_byte buf[POWERPC_STUB_SIZE];
  unsigned int i;
  unsigned int stubcount;
  arelent **relocs;
  asection *got_sec;
  arelent **r;
  struct powerpc_stub *l;

  if (powerpc_stubs == (struct powerpc_stub *) NULL)
    return;

  for (i = 0; i < POWERPC_STUB_INSN_COUNT; i++)
    bfd_put_32 (outbfd, (bfd_vma) powerpc_stub_insns[i], buf + i * 4);

  got_sec = bfd_get_section_by_name (inbfd, ".got");
  assert (got_sec != (asection *) NULL);
  assert (got_sec->output_section->orelocation == (arelent **) NULL);

  stubcount = 0;
  for (l = powerpc_stubs; l != (struct powerpc_stub *) NULL; l = l->next)
    ++stubcount;
  relocs = (arelent **) xmalloc (stubcount * sizeof (arelent *));

  r = relocs;
  for (l = powerpc_stubs; l != (struct powerpc_stub *) NULL; l = l->next)
    {
      arelent *reloc;

      /* Adjust the first instruction to use the right TOC index.  */
      bfd_put_32 (outbfd, (bfd_vma) powerpc_stub_insns[0] + l->toc_index, buf);

      /* Write this stub out.  */
      if (! bfd_set_section_contents (outbfd,
				      bfd_get_section (l->start),
				      buf,
				      l->start->value,
				      POWERPC_STUB_SIZE))
	bfd_fatal (_("writing stub"));

      /* Create a new reloc for the TOC entry.  */
      reloc = (arelent *) xmalloc (sizeof (arelent));
      reloc->sym_ptr_ptr = &l->reloc;
      reloc->address = l->toc_index + got_sec->output_offset;
      reloc->addend = 0;
      reloc->howto = bfd_reloc_type_lookup (inbfd, BFD_RELOC_32);

      *r++ = reloc;
    }

  bfd_set_reloc (outbfd, got_sec->output_section, relocs, stubcount);
}

/* Adjust relocation entries for PowerPC NetWare.  We do not output
   TOC relocations.  The object code already contains the offset from
   the TOC pointer.  When the function is called, the TOC register,
   r2, will be set to the correct TOC value, so there is no need for
   any further reloc.  */

static void
powerpc_mangle_relocs (bfd *outbfd, asection *insec,
		       arelent ***relocs_ptr,
		       long *reloc_count_ptr, char *contents,
		       bfd_size_type contents_size ATTRIBUTE_UNUSED)
{
  reloc_howto_type *toc_howto;
  long reloc_count;
  arelent **relocs;
  long i;

  toc_howto = bfd_reloc_type_lookup (insec->owner, BFD_RELOC_PPC_TOC16);
  if (toc_howto == (reloc_howto_type *) NULL)
    abort ();

  /* If this is the .got section, clear out all the contents beyond
     the initial size.  We must do this here because copy_sections is
     going to write out whatever we return in the contents field.  */
  if (strcmp (bfd_get_section_name (insec->owner, insec), ".got") == 0)
    memset (contents + powerpc_initial_got_size, 0,
	    (size_t) (bfd_get_section_size (insec) - powerpc_initial_got_size));

  reloc_count = *reloc_count_ptr;
  relocs = *relocs_ptr;
  for (i = 0; i < reloc_count; i++)
    {
      arelent *rel;
      asymbol *sym;
      bfd_vma sym_value;

      rel = *relocs++;
      sym = *rel->sym_ptr_ptr;

      /* Convert any relocs against the .bss section into relocs
         against the .data section.  */
      if (strcmp (bfd_get_section_name (outbfd, bfd_get_section (sym)),
		  NLM_UNINITIALIZED_DATA_NAME) == 0)
	{
	  asection *datasec;

	  datasec = bfd_get_section_by_name (outbfd,
					     NLM_INITIALIZED_DATA_NAME);
	  if (datasec != NULL)
	    {
	      rel->addend += (bfd_get_section_vma (outbfd,
						   bfd_get_section (sym))
			      + sym->value);
	      rel->sym_ptr_ptr = datasec->symbol_ptr_ptr;
	      sym = *rel->sym_ptr_ptr;
	    }
	}

      /* We must be able to resolve all PC relative relocs at this
	 point.  If we get a branch to an undefined symbol we build a
	 stub, since NetWare will resolve undefined symbols into a
	 pointer to a function descriptor.  */
      if (rel->howto->pc_relative)
	{
	  /* This check for whether a symbol is in the same section as
	     the reloc will be wrong if there is a PC relative reloc
	     between two sections both of which were placed in the
	     same output section.  This should not happen.  */
	  if (bfd_get_section (sym) != insec->output_section)
	    non_fatal (_("unresolved PC relative reloc against %s"),
		       bfd_asymbol_name (sym));
	  else
	    {
	      bfd_vma val;

	      assert (rel->howto->size == 2 && rel->howto->pcrel_offset);
	      val = bfd_get_32 (outbfd, (bfd_byte *) contents + rel->address);
	      val = ((val &~ rel->howto->dst_mask)
		     | (((val & rel->howto->src_mask)
			 + (sym->value - rel->address)
			 + rel->addend)
			& rel->howto->dst_mask));
	      bfd_put_32 (outbfd, val, (bfd_byte *) contents + rel->address);

	      /* If this reloc is against an stubbed symbol and the
		 next instruction is
		     cror 31,31,31
		 then we replace the next instruction with
		     lwz  r2,20(r1)
		 This reloads the TOC pointer after a stub call.  */
	      if (bfd_asymbol_name (sym)[0] == '.'
		  && (sym->flags & BSF_DYNAMIC) != 0
		  && (bfd_get_32 (outbfd,
				  (bfd_byte *) contents + rel->address + 4)
		      == 0x4ffffb82)) /* cror 31,31,31 */
		bfd_put_32 (outbfd, (bfd_vma) 0x80410014, /* lwz r2,20(r1) */
			    (bfd_byte *) contents + rel->address + 4);

	      --*reloc_count_ptr;
	      --relocs;
	      memmove (relocs, relocs + 1,
		       (size_t) ((reloc_count - 1) * sizeof (arelent *)));
	      continue;
	    }
	}

      /* When considering a TOC reloc, we do not want to include the
	 symbol value.  The symbol will be start of the TOC section
	 (which is named .got).  We do want to include the addend.  */
      if (rel->howto == toc_howto)
	sym_value = 0;
      else
	sym_value = sym->value;

      /* If this is a relocation against a symbol with a value, or
	 there is a reloc addend, we need to update the addend in the
	 object file.  */
      if (sym_value + rel->addend != 0)
	{
	  bfd_vma val;

	  switch (rel->howto->size)
	    {
	    case 1:
	      val = bfd_get_16 (outbfd,
				(bfd_byte *) contents + rel->address);
	      val = ((val &~ rel->howto->dst_mask)
		     | (((val & rel->howto->src_mask)
			 + sym_value
			 + rel->addend)
			& rel->howto->dst_mask));
	      if ((bfd_signed_vma) val < - 0x8000
		  || (bfd_signed_vma) val >= 0x8000)
		non_fatal (_("overflow when adjusting relocation against %s"),
			   bfd_asymbol_name (sym));
	      bfd_put_16 (outbfd, val, (bfd_byte *) contents + rel->address);
	      break;

	    case 2:
	      val = bfd_get_32 (outbfd,
				(bfd_byte *) contents + rel->address);
	      val = ((val &~ rel->howto->dst_mask)
		     | (((val & rel->howto->src_mask)
			 + sym_value
			 + rel->addend)
			& rel->howto->dst_mask));
	      bfd_put_32 (outbfd, val, (bfd_byte *) contents + rel->address);
	      break;

	    default:
	      abort ();
	    }

	  if (! bfd_is_und_section (bfd_get_section (sym)))
	    rel->sym_ptr_ptr = bfd_get_section (sym)->symbol_ptr_ptr;
	  rel->addend = 0;
	}

      /* Now that we have incorporated the addend, remove any TOC
	 relocs.  */
      if (rel->howto == toc_howto)
	{
	  --*reloc_count_ptr;
	  --relocs;
	  memmove (relocs, relocs + 1,
		   (size_t) ((reloc_count - i) * sizeof (arelent *)));
	  continue;
	}

      rel->address += insec->output_offset;
    }
}

#endif /* NLMCONV_POWERPC */

/* Name of linker.  */
#ifndef LD_NAME
#define LD_NAME "ld"
#endif

/* The user has specified several input files.  Invoke the linker to
   link them all together, and convert and delete the resulting output
   file.  */

static char *
link_inputs (struct string_list *inputs, char *ld, char * mfile)
{
  size_t c;
  struct string_list *q;
  char **argv;
  size_t i;
  int pid;
  int status;
  char *errfmt;
  char *errarg;

  c = 0;
  for (q = inputs; q != NULL; q = q->next)
    ++c;

  argv = (char **) alloca ((c + 7) * sizeof (char *));

#ifndef __MSDOS__
  if (ld == NULL)
    {
      char *p;

      /* Find the linker to invoke based on how nlmconv was run.  */
      p = program_name + strlen (program_name);
      while (p != program_name)
	{
	  if (p[-1] == '/')
	    {
	      ld = (char *) xmalloc (p - program_name + strlen (LD_NAME) + 1);
	      memcpy (ld, program_name, p - program_name);
	      strcpy (ld + (p - program_name), LD_NAME);
	      break;
	    }
	  --p;
	}
    }
#endif

  if (ld == NULL)
    ld = (char *) LD_NAME;

  unlink_on_exit = make_temp_file (".O");

  argv[0] = ld;
  argv[1] = (char *) "-Ur";
  argv[2] = (char *) "-o";
  argv[3] = unlink_on_exit;
  /* If we have been given the name of a mapfile and that
     name is not 'stderr' then pass it on to the linker.  */
  if (mfile
      && * mfile
      && strcmp (mfile, "stderr") == 0)
    {
      argv[4] = (char *) "-Map";
      argv[5] = mfile;
      i = 6;
    }
  else
    i = 4;

  for (q = inputs; q != NULL; q = q->next, i++)
    argv[i] = q->string;
  argv[i] = NULL;

  if (debug)
    {
      for (i = 0; argv[i] != NULL; i++)
	fprintf (stderr, " %s", argv[i]);
      fprintf (stderr, "\n");
    }

  pid = pexecute (ld, argv, program_name, (char *) NULL, &errfmt, &errarg,
		  PEXECUTE_SEARCH | PEXECUTE_ONE);
  if (pid == -1)
    {
      fprintf (stderr, _("%s: execution of %s failed: "), program_name, ld);
      fprintf (stderr, errfmt, errarg);
      unlink (unlink_on_exit);
      exit (1);
    }

  if (pwait (pid, &status, 0) < 0)
    {
      perror ("pwait");
      unlink (unlink_on_exit);
      exit (1);
    }

  if (status != 0)
    {
      non_fatal (_("Execution of %s failed"), ld);
      unlink (unlink_on_exit);
      exit (1);
    }

  return unlink_on_exit;
}
@


1.37
log
@ChangeLog binutils/
2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* debug.c (debug_start_source): Use filename_(n)cmp.
	* ieee.c (ieee_finish_compilation_unit): Likewise.
	(ieee_lineno): Likewise.
	* nlmconv.c (main): Likewise.
	* objcopy.c (strip_main): Likewise.
	(copy_main): Likewise.
	* objdump.c (show_line): Likewise.
	(dump_reloc_set): Likewise.
	* srconv.c (main): Likewise.
	* wrstabs.c (stab_lineno): Likewise.

ChangeLog gas/
2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* depend.c (register_dependency): Use filename_(n)cmp.
	* dwarf2dbg.c (get_filenum): Likewise.
	* ecoff.c (add_file): Likewise.
	(ecoff_generate_asm_lineno): Likewise.
	* input-scrub.c (new_logical_line_flags): Likewise.
	* listing.c (file_info): Likewise.
	(listing_newline): Likewise.
	* remap.c (remap_debug_filename): Likewise.
	* stabs.c (generate_asm_file): Likewise.
	(stabs_generate_asm_lineno): Likewise.
@
text
@d3 2
a4 1
   2003, 2004, 2005, 2006, 2007, 2008, 2009 Free Software Foundation, Inc.
a45 2
#include <sys/stat.h>
#include <sys/file.h>
@


1.36
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d40 1
d272 1
a272 1
	  if (strcmp (input_file, output_file) == 0)
@


1.35
log
@update copyright dates
@
text
@d2042 1
a2042 1
link_inputs (struct string_list *inputs, char *ld, char * map_file)
d2091 3
a2093 3
  if (map_file
      && * map_file
      && strcmp (map_file, "stderr") == 0)
d2096 1
a2096 1
      argv[5] = map_file;
@


1.34
log
@        Updated sources to avoid using the identifier name "new", which is a
        keyword in c++.

        * bfd/aoutx.h (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol.
        * bfd/coffgen.c (coff_make_empty_symbol)
        (coff_bfd_make_debug_symbol): Rename variable new to new_symbol.
        * bfd/cpu-ia64-opc.c (ext_reg, ins_imms_scaled): Rename variable
        new to new_insn.
        * bfd/doc/chew.c (newentry, add_intrinsic): Rename variable new to
        new_d.
        * bfd/ecoff.c (_bfd_ecoff_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/elf32-m68k.c (elf_m68k_get_got_entry_type): Rename argument
        new to new_reloc.
        * bfd/hash.c (bfd_hash_lookup): Rename variable new to new_string.
        * bfd/ieee.c (ieee_make_empty_symbol): Rename variable new to
        new_symbol.
        * bfd/linker.c (bfd_new_link_order): Rename variable new to
        new_lo.
        * bfd/mach-o.c (bfd_mach_o_sizeof_headers): Rename variable new to
        symbol.
        * bfd/oasys.c (oasys_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/pdp11.c (NAME (aout, make_empty_symbol)): Rename variable
        new to new_symbol_type.
        * bfd/plugin.c (bfd_plugin_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/rs6000-core.c (CoreHdr, VmInfo): Rename union member new to
        new_dump.
        (read_hdr, rs6000coff_core_p)
        (rs6000coff_core_file_matches_executable_p)
        (rs6000coff_core_file_failing_command)
        (rs6000coff_core_file_failing_signal): Updated function to use new
        union member name.
        * bfd/som.c (som_make_empty_symbol): Rename variable new to
        new_symbol_type.
        * bfd/syms.c (_bfd_generic_make_empty_symbol): Rename variable new
        to new_symbol.
        * bfd/tekhex.c (first_phase, tekhex_make_empty_symbol): Rename
        variable new to new_symbol.
        * binutils/nlmconv.c (main): Rename variable new to new_name.
        * gas/config/tc-arm.c (insert_reg_alias): Rename variable new to
        new_reg.
        * gas/config/tc-dlx.c (parse_operand): Rename variable new to
        new_pos.
        * gas/config/tc-ia64.c (ia64_gen_real_reloc_type): Rename variable
        new to newr.
        * gas/config/tc-mcore.c (parse_exp, parse_imm): Rename variable
        new to new_pointer.
        * gas/config/tc-microblaze.c (parse_exp, parse_imm, check_got):
        Change name from new to new_pointer.
        * gas/config/tc-or32.c (parse_operand): Rename variable new to
        new_pointer.
        * gas/config/tc-pdp11.c (md_assemble): Rename variable new to
        new_pointer.
        * gas/config/tc-pj.c (alias): Change argument new to new_name.
        * gas/config/tc-score.c (s3_build_score_ops_hsh): Rename variable
        new to new_opcode. (s3_build_dependency_insn_hsh) Rename variable
        new to new_i2n. (s3_convert): Rename variables old and new to
        r_old and r_new.
        * gas/config/tc-score7.c (s7_build_score_ops_hsh): Rename variable
        new to new_opcode. (s7_build_dependency_insn_hsh): Rename variable
        new to new_i2d. (s7_b32_relax_to_b16, s7_convert_frag): Rename
        variables old and new to r_old and r_new.
        * gas/config/tc-sh.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-sh64.c (shmedia_parse_exp): Rename variable new to
        new_pointer.
        * gas/config/tc-tic4x.c (tic4x_operand_parse): Rename variable new
        to new_pointer.
        * gas/config/tc-z8k.c (parse_exp): Rename variable new to
        new_pointer.
        * gas/listing.c (listing_newline): Rename variable new to new_i.
        * ld/ldexp.c (exp_intop, exp_bigintop, exp_relop, exp_binop)
        (exp_trinop, exp_unop, exp_nameop, exp_assop): Rename variable new
        to new_e.
        * ld/ldfile.c (ldfile_add_library_path): Rename variable new to
        new_dirs. (ldfile_add_arch): Rename variable new to new_arch.
        * ld/ldlang.c (new_statement, lang_final, lang_add_wild)
        (lang_target, lang_add_fill, lang_add_data, lang_add_assignment)
        (lang_add_insert): Rename variable new to new_stmt. (new_afile):
        Added missing cast. (lang_memory_region_lookup): Rename variable
        new to new_region. (init_os): Rename variable new to
        new_userdata. (lang_add_section): Rename variable new to
        new_section. (ldlang_add_undef): Rename variable new to
        new_undef. (realsymbol): Rename variable new to new_name.
        * opcodes/z8kgen.c (internal, gas): Rename variable new to new_op.

        Updated sources to avoid using the identifier name "template",
        which is a keyword in c++.

        * bfd/elf32-arm.c (struct stub_def): Rename member template to
        template_sequence. (arm_build_one_stub,
        find_stub_size_and_template, arm_size_one_stub, arm_map_one_stub):
        Rename variable template to template_sequence.
        * bfd/elfxx-ia64.c (elfNN_ia64_relax_br, elfNN_ia64_relax_brl):
        Rename variable template to template_val.
        * gas/config/tc-arm.c (struct asm_cond, struct asm_psr, struct
        asm_barrier_opt): Change member template to
        template_name. (md_begin): Update code to reflect new member
        names.
        * gas/config/tc-i386.c (struct templates, struct _i386_insn)
        (match_template, cpu_flags_match, match_reg_size, match_mem_size)
        (operand_size_match, md_begin, i386_print_statistics, pi)
        (build_vex_prefix, md_assemble, parse_insn, optimize_imm)
        (optimize_disp): Updated code to use new names. (parse_insn):
        Added casts.
        * gas/config/tc-ia64.c (dot_template, emit_one_bundle): Updated
        code to use new names.
        * gas/config/tc-score.c (struct s3_asm_opcode): Renamed member
        template to template_name. (s3_parse_16_32_inst, s3_parse_48_inst,
        s3_do_macro_ldst_label, s3_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-score7.c (struct s7_asm_opcode): Renamed member
        template to template_name. (s7_parse_16_32_inst,
        s7_do_macro_ldst_label, s7_build_score_ops_hsh): Update code to
        use new names.
        * gas/config/tc-tic30.c (md_begin, struct tic30_insn)
        (md_assemble): Update code to use new names.
        * gas/config/tc-tic54x.c (struct _tic54x_insn, md_begin)
        (optimize_insn, tic54x_parse_insn, next_line_shows_parallel):
        Update code to use new names.
        * include/opcode/tic30.h (template): Rename type template to
        insn_template. Updated code to use new name.
        * include/opcode/tic54x.h (template): Rename type template to
        insn_template.
        * opcodes/cris-dis.c (bytes_to_skip): Update code to use new name.
        * opcodes/i386-dis.c (putop): Update code to use new name.
        * opcodes/i386-gen.c (process_i386_opcodes): Update code to use
        new name.
        * opcodes/i386-opc.h (struct template): Rename struct template to
        insn_template. Update code accordingly.
        * opcodes/i386-tbl.h (i386_optab): Update type to use new name.
        * opcodes/ia64-dis.c (print_insn_ia64): Rename variable template
        to template_val.
        * opcodes/tic30-dis.c (struct instruction, get_tic30_instruction):
        Update code to use new name.
        * opcodes/tic54x-dis.c (has_lkaddr, get_insn_size)
        (print_parallel_instruction, print_insn_tic54x, tic54x_get_insn):
        Update code to use new name.
        * opcodes/tic54x-opc.c (tic54x_unknown_opcode, tic54x_optab):
        Update type to new name.
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2006, 2007, 2008 Free Software Foundation, Inc.
@


1.33
log
@	* ieee.c (write_ieee_debugging_info): Use bfd_make_section_with_flags.
	* nlmconv.c (main, powerpc_build_stubs): Likewise.
	* rescoff.c (write_coff_file): Likewise.
	* resres.c (write_res_file): Likewise.
	* windmc.c (windmc_write_bin): Likewise.
@
text
@d479 1
a479 1
		      char *new;
d481 4
a484 4
		      new = xmalloc (strlen (bfd_asymbol_name (sym)) + 1);
		      new[0] = outlead;
		      strcpy (new + 1, bfd_asymbol_name (sym) + 1);
		      sym->name = new;
d490 1
a490 1
	      char *new;
d492 4
a495 4
	      new = xmalloc (strlen (bfd_asymbol_name (sym)) + 2);
	      new[0] = outlead;
	      strcpy (new + 1, bfd_asymbol_name (sym));
	      sym->name = new;
@


1.32
log
@Change sources over to using GPLv3
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2006, 2007 Free Software Foundation, Inc.
d398 3
a400 1
      bss_sec = bfd_make_section (outbfd, NLM_UNINITIALIZED_DATA_NAME);
a401 1
	  || ! bfd_set_section_flags (outbfd, bss_sec, SEC_ALLOC)
d410 2
a411 1
  secsec = bfd_make_section (outbfd, ".nlmsections");
a413 2
  if (! bfd_set_section_flags (outbfd, secsec, SEC_HAS_CONTENTS))
    bfd_fatal (_("set .nlmsections flags"));
d717 2
a718 1
	  custom_section = bfd_make_section (outbfd, ".nlmcustom");
d720 1
a720 3
	      || ! bfd_set_section_size (outbfd, custom_section, custom_size)
	      || ! bfd_set_section_flags (outbfd, custom_section,
					  SEC_HAS_CONTENTS))
d737 2
a738 1
	  help_section = bfd_make_section (outbfd, ".nlmhelp");
d740 1
a740 3
	      || ! bfd_set_section_size (outbfd, help_section, help_size)
	      || ! bfd_set_section_flags (outbfd, help_section,
					  SEC_HAS_CONTENTS))
d758 3
a760 1
	  message_section = bfd_make_section (outbfd, ".nlmmessages");
d762 1
a762 3
	      || ! bfd_set_section_size (outbfd, message_section, message_size)
	      || ! bfd_set_section_flags (outbfd, message_section,
					  SEC_HAS_CONTENTS))
d774 2
a775 1
      module_section = bfd_make_section (outbfd, ".nlmmodules");
d777 1
a777 3
	  || ! bfd_set_section_size (outbfd, module_section, module_size)
	  || ! bfd_set_section_flags (outbfd, module_section,
				      SEC_HAS_CONTENTS))
d793 2
a794 1
	  rpc_section = bfd_make_section (outbfd, ".nlmrpc");
d796 1
a796 3
	      || ! bfd_set_section_size (outbfd, rpc_section, rpc_size)
	      || ! bfd_set_section_flags (outbfd, rpc_section,
					  SEC_HAS_CONTENTS))
d848 3
a850 1
	      shared_section = bfd_make_section (outbfd, ".nlmshared");
d853 1
a853 3
					     shared_size)
		  || ! bfd_set_section_flags (outbfd, shared_section,
					      SEC_HAS_CONTENTS))
d1700 5
a1704 1
  stub_sec = bfd_make_section (inbfd, ".stubs");
a1705 5
      || ! bfd_set_section_flags (inbfd, stub_sec,
				  (SEC_CODE
				   | SEC_RELOC
				   | SEC_ALLOC
				   | SEC_LOAD))
d1713 6
a1718 1
      got_sec = bfd_make_section (inbfd, ".got");
a1719 6
	  || ! bfd_set_section_flags (inbfd, got_sec,
				      (SEC_DATA
				       | SEC_RELOC
				       | SEC_ALLOC
				       | SEC_LOAD
				       | SEC_HAS_CONTENTS))
@


1.31
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
d19 3
a21 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.30
log
@top level:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.ac (TOPLEVEL_CONFIGURE_ARGUMENTS): Fix quoting.
	* configure: Regenerate.

bfd:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-pkgversion): New option.
	* configure: Regenerate.
	* Makefile.am (bfdver.h): Substitute for @@bfd_version_package@@.
	* Makefile.in: Regenerate.
	* version.h (BFD_VERSION_STRING): Define using
	@@bfd_version_package@@.

bfd/doc:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* Makefile.in: Regenerate.

binutils:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-bugurl): New option.
	* configure: Regenerate.
	* Makefile.am (REPORT_BUGS_TO): Define.
	(INCLUDES): Define REPORT_BUGS_TO.
	Regenerate dependencies.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* bucomm.h: Remove include of bin-bugs.h.
	* addr2line.c (usage): Don't print empty REPORT_BUGS_TO.
	* ar.c (usage): Pass s to list_supported_targets.  Don't print
	empty REPORT_BUGS_TO.
	* coffdump.c (show_usage): Don't print empty REPORT_BUGS_TO.
	* cxxfilt.c (usage): Print bug url when giving help.
	* dlltool.c (usage): Likewise.
	* dllwrap.c (usage): Likewise.
	* nlmconv.c (show_usage): Don't print empty REPORT_BUGS_TO.
	* nm.c (usage): Likewise.
	* objcopy.c (copy_usage, strip_usage): Likewise.
	* objdump.c (usage): Likewise.
	* readelf.c ((usage): Likewise. Add STREAM argument.  Adjust
	callers.
	* size.c (usage): Don't print empty REPORT_BUGS_TO.
	* srconv.c (show_usage): Likewise.
	* strings.c (usage): Likewise.
	* sysdymp.c (show_usage): Likewise.
	* windres.c (usage): Likewise.

gas:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-bugurl): New option.
	* configure: Regenerate.
	* dep-in.sed: Remove bin-bugs.h.
	* Makefile.am (REPORT_BUGS_TO): Define.
	(INCLUDES): Define REPORT_BUGS_TO.
	(DEP_INCLUDES): Likewise.
	($(OBJS)): No longer depend on bin-bugs.h.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* as.c (show_usage): Don't print empty REPORT_BUGS_TO.
	* as.h: Remove include of bin-bugs.h.

gprof:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-pkgversion, --with-bugurl): New options.
	* configure: Regenerate.
	* Makefile.am (PKGVERSION, REPORT_BUGS_TO): Define.
	(INCLUDES): Define PKGVERSION and REPORT_BUGS_TO.
	Regenerate dependencies.
	* Makefile.in: Regenerate.
	* gprof.c (usage): Don't print empty REPORT_BUGS_TO.
	(main): Include PKGVERSION in version output.
	* gprof.h: Remove include of bin-bugs.h.

include:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* bin-bugs.h: Remove.

ld:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-bugurl): New option.
	* configure: Regenerate.
	* Makefile.am (REPORT_BUGS_TO): Define.
	(INCLUDES): Define REPORT_BUGS_TO.
	Regenerate dependencies.
	* Makefile.in: Regenerate.
	* ld.h: Remove include of bin-bugs.h.
	* lexsup.c (help): Don't print empty REPORT_BUGS_TO.
@
text
@d35 1
a37 1
#include "bucomm.h"
d56 2
@


1.29
log
@* bfd-in.h (CONST_STRNCPY) : Delete.
  (LITSTRCPY) : New.
  (LITMEMCPY) : New.
* bfd-in2.h : Regenerate.
* elflink.c  (bfd_elf_gc_sections) : Use LITMEMCPY. Don't manually calculate string lengths.
* nlmcode.h (nlm_swap_auxiliary_headers_in) : Use LITMEMCPY.
* nlmconv.c (main) : Use LITMEMCPY.
* prdbg.c (tg_class_static_member) : Use LITSTRCPY.
@
text
@d3 1
a3 1
   2003, 2004, 2005, 2006 Free Software Foundation, Inc.
d1112 1
a1112 1
  if (status == 0)
@


1.28
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d740 1
a740 1
	  CONST_STRNCPY (nlm_extended_header (outbfd)->stamp, "MeSsAgEs");
d762 1
a762 1
	  CONST_STRNCPY (nlm_extended_header (outbfd)->stamp, "MeSsAgEs");
d798 1
a798 1
	  CONST_STRNCPY (nlm_extended_header (outbfd)->stamp, "MeSsAgEs");
d855 1
a855 1
	      CONST_STRNCPY (nlm_extended_header (outbfd)->stamp, "MeSsAgEs");
d866 1
a866 1
  CONST_STRNCPY (nlm_extended_header (outbfd)->stamp, "MeSsAgEs");
d868 1
a868 1
  CONST_STRNCPY (nlm_cygnus_ext_header (outbfd)->stamp, "CyGnUsEx");
d883 1
a883 1
      CONST_STRNCPY (version_hdr->stamp, "VeRsIoN#");
d1750 1
a1750 1
      newsym = (asymbol *) xmalloc (sizeof (asymbol));
d1752 1
a1752 1
      newname = (char *) xmalloc (strlen (bfd_asymbol_name (sym)));
@


1.27
log
@	* addr2line.c (usage): Document @@file.
	* ar.c (usage): Likewise.
	* coffdump (usage): Likewise.
	* cxxfilt.c (usage): Likewise.
	* dlltool.c (usage): Likewise.
	* dllwrap.c (usage): Likewise.
	* nlmconv.c (usage): Likewise.
	* nm.c (usage): Likewise.
	* objcopy.c (usage): Likewise.
	* objdump.c (usage): Likewise.
	* readelf.c (usage): Likewise.
	* size.c (usage): Likeise.
	* srconv.c (usage): Likewise.
	* strings.c (usage): Likewise.
	* windres.c (usage): Likewise.
	* doc/binutils.texi: Add section on common options.
@
text
@d3 1
a3 1
   2003, 2004, 2005 Free Software Foundation, Inc.
d740 1
a740 1
	  strncpy (nlm_extended_header (outbfd)->stamp, "MeSsAgEs", 8);
d762 1
a762 1
	  strncpy (nlm_extended_header (outbfd)->stamp, "MeSsAgEs", 8);
d798 1
a798 1
	  strncpy (nlm_extended_header (outbfd)->stamp, "MeSsAgEs", 8);
d855 1
a855 1
	      strncpy (nlm_extended_header (outbfd)->stamp, "MeSsAgEs", 8);
d861 1
a861 1
  if (strncmp (version_hdr->stamp, "VeRsIoN#", 8) != 0)
d866 1
a866 1
  strncpy (nlm_extended_header (outbfd)->stamp, "MeSsAgEs", 8);
d868 1
a868 1
  strncpy (nlm_cygnus_ext_header (outbfd)->stamp, "CyGnUsEx", 8);
d883 1
a883 1
      strncpy (version_hdr->stamp, "VeRsIoN#", 8);
@


1.27.2.1
log
@	binutils/
	* Makefile.am: Rebuild dependencies.
	(REPORT_BUGS_TO): Always defined.
	(INCLUDES): Adjust.
	* Makefile.in: Rebuilt.
	* configure.in (REPORT_BUGS_TO): Provide default value.
	* configure: Rebuilt.
	* bucomm.h: Remove bin-bugs.h.
	* addr2line.c (usage): Don't print empty REPORT_BUGS_TO.
	* coffdump.c (show_usage): Likewise.
	* cxxfilt.c (usage): Likewise.
	* nlmconv.c (show_usage): Likewise.
	* nm.c (usage): Likewise.
	* objcopy.c (copy_usage, strip_usage): Likewise.
	* objdump.c (usage): Likewise.
	* size.c (usage): Likewise.
	* srconv.c (show_usage): Likewise.
	* string.c (usage): Likewise.
	* sysdymp.c (show_usage): Likewise.
	* windres.c (usage): Likewise.
	* readelf (usage): Likewise. Add STREAM argument.  Adjust callers.

	gas/
	* Makefile.am: Rebuild dependencies.
	(REPORT_BUGS_TO): Always defined.
	(INCLUDES): Adjust.
	* Makefile.in: Rebuilt.
	* configure.in (REPORT_BUGS_TO): Provide default value.
	* configure: Rebuilt.
	* as.c (show_usage): Don't print empty REPORT_BUGS_TO.
	* as.h: Remove bin-bugs.h.

	ld/
	* Makefile.am: Rebuild dependencies.
	(REPORT_BUGS_TO): Always defined.
	(INCLUDES): Adjust.
	* Makefile.in: Rebuilt.
	* configure.in (REPORT_BUGS_TO): Provide default value.
	* configure: Rebuilt.
	* ld.h: Remove bin-bugs.h
	* lexsup.c (help):  Don't print empty REPORT_BUGS_TO.

	gprof/
	* Makefile.am: Rebuild dependencies.
	(REPORT_BUGS_TO): Always defined.
	(PKGVERSION): Define.
	(INCLUDES): Adjust.
	* Makefile.in: Rebuilt.
	* configure.in (REPORT_BUGS_TO): Provide default value.
	* configure: Rebuilt.
	* gprof.c (usage): Don't print empty REPORT_BUGS_TO.
	* gprof.h: Remove bin-bugs.h

	include/
	* bin-bugs.h: Remove.
@
text
@d1112 1
a1112 1
  if (REPORT_BUGS_TO[0] && status == 0)
@


1.26
log
@	* addr2line.c (main): Likewise.
	* ar.c (main): Likewise.
	* coffdump.c (main): Likewise.
	* cxxfilt.c (main): Likewise.
	* dlltool.c (main): Likewise.
	* dllwrap.c (main): Likewise.
	* nlmconv.c (main): Likewise.
	* nm.c (main): Likewise.
	* objcopy.c (main): Likewise.
	* objdump.c (main): Likewise.
	* readelf.c (main): Likewise.
	* size.c (main): Likeiwse.
	* srcconv.c (main): Likewise.
	* strings.c (main): Likewise.
	* sysdump.c (main): Likewise.
	* sysinfo.c (main): Likewise.
	* windres.c (main): Likewise.

	* ldmain.c (main): Use expandargv.

	* gprof.c (main): Use expandargv.

	* as.c (main): Use expandargv.
@
text
@d1108 1
@


1.25
log
@Update FSF address
@
text
@d213 2
@


1.24
log
@	* Makefile.am (syslex.o, sysinfo.o): Pass AM_CFLAGS to compiler.
	(syslex.o, sysinfo.o, dlltool.o, rescoff.o): Remove duplicate
	dependencies.  Run "make dep-am".
	* nlmconv.c: Warning fixes.
	* readelf.c: Likewise.
	* srconv.c: Likewise.
	* sysdump.c: Likewise.
	* sysinfo.y: Likewise.
	* syslex.l: Likewise.  Use yyleng instead of strlen, memcpy instead
	of strcpy.
	* Makefile.in: Regenerate.
@
text
@d19 1
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.24.6.1
log
@	* ld/ldmain.c (main): Use expandargv.
	* binutils/addr2line.c (main): Likewise.
	* binutils/ar.c (main): Likewise.
	* binutils/coffdump.c (main): Likewise.
	* binutils/cxxfilt.c (main): Likewise.
	* binutils/dlltool.c (main): Likewise.
	* binutils/dllwrap.c (main): Likewise.
	* binutils/nlmconv.c (main): Likewise.
	* binutils/nm.c (main): Likewise.
	* binutils/objcopy.c (main): Likewise.
	* binutils/objdump.c (main): Likewise.
	* binutils/readelf.c (main): Likewise.
	* binutils/size.c (main): Likeiwse.
	* binutils/srcconv.c (main): Likewise.
	* binutils/strings.c (main): Likewise.
	* binutils/sysdump.c (main): Likewise.
	* binutils/sysinfo.c (main): Likewise.
	* binutils/windres.c (main): Likewise.

	* include/libiberty.h (expandargv): New function.
	* libiberty/argv.c (safe-ctype.h): Include it.
	(ISBLANK): Remove.
	(stdio.h): Include.
	(expandargv): New function.
	* libiberty/Makefile.in: Regenerated.
@
text
@a212 2
  expandargv (&argc, &argv);

@


1.23
log
@Remove prototype for localetime altogether.  It	should not be needed on modern
systems and older systems can live with the warning.
@
text
@d196 1
a196 1
  Nlm_Internal_Fixed_Header sharedhdr;
d979 1
a979 1
	  strncpy (set + 1, l->string, *set);
@


1.22
log
@Provide a full prototype for the localtime() function in order to avoid a
compile time warning.
@
text
@a60 4
#ifndef localtime
extern struct tm *localtime (const time_t *);
#endif

@


1.21
log
@(oops - forogot to update the year in the copyright notice)
@
text
@d62 1
a62 1
extern struct tm *localtime ();
@


1.20
log
@PR binutils/630
* nlmconv.c (main): Only store the basename of the output filename in the
module table.
@
text
@d3 1
a3 1
   2003, 2004 Free Software Foundation, Inc.
@


1.19
log
@Support MAP directive
@
text
@d1060 18
a1077 12
  len = strlen (output_file);
  if (len > NLM_MODULE_NAME_SIZE - 2)
    len = NLM_MODULE_NAME_SIZE - 2;
  nlm_fixed_header (outbfd)->moduleName[0] = len;

  strncpy (nlm_fixed_header (outbfd)->moduleName + 1, output_file,
	   NLM_MODULE_NAME_SIZE - 2);
  nlm_fixed_header (outbfd)->moduleName[NLM_MODULE_NAME_SIZE - 1] = '\0';
  for (modname = nlm_fixed_header (outbfd)->moduleName;
       *modname != '\0';
       modname++)
    *modname = TOUPPER (*modname);
@


1.18
log
@	* objcopy.c (copy_section): Use bfd_get_section_size instead of
	_raw_size or bfd_get_section_size_before_reloc.  Don't set reloc_done.
	(compare_section_lma): Likewise.
	* addr2line.c (find_address_in_section): Likewise.
	* coffgrok.c (do_sections_p1): Likewise.
	* dlltool.c (scan_drectve_symbols): Likewise.
	* nlmconv.c (main): Likewise.
	(copy_sections): Likewise.
	(powerpc_mangle_relocs): Likewise.
	* objdump.c (disassemble_section): Likewise.
	* prdbg.c (find_address_in_section): Likewise.
	* size.c (berkeley_sum): Likewise.
	* srconv.c (wr_ob): Likewise.
	* strings.c (strings_a_section): Likewise.
@
text
@d136 1
a136 1
static char *link_inputs (struct string_list *, char *);
d323 1
a323 1
	input_file = link_inputs (input_files, ld_arg);
d462 1
a462 1
      register asymbol *sym;
d558 1
a558 1
	  register struct string_list *l;
d606 1
a606 1
	  register struct string_list *l;
d925 2
a926 2
  if (map_file != NULL)
    non_fatal (_("warning: MAP and FULLMAP are not supported; try ld -M"));
d1364 2
a1365 2
      register arelent **relocs;
      register long i;
d1552 1
a1552 1
		     register arelent ***relocs_ptr, long *reloc_count_ptr,
d1558 1
a1558 1
  register arelent **relocs;
d1614 1
a1614 1
      register bfd_size_type i;
d1862 1
a1862 1
		       register arelent ***relocs_ptr,
d1868 2
a1869 2
  register arelent **relocs;
  register long i;
d2039 1
a2039 1
link_inputs (struct string_list *inputs, char *ld)
d2054 1
a2054 1
  argv = (char **) alloca ((c + 5) * sizeof(char *));
d2086 13
a2098 1
  i = 4;
@


1.17
log
@	* addr2line.c: Convert to ISO C90 prototypes, change PTR, remove
	unneeded (void *) casts.
	* ar.c: Likewise.
	* arlex.l: Likewise.
	* arparse.y: Likewise.
	* arsup.c: Likewise.
	* binemul.c: Likewise.
	* binemul.h: Likewise.
	* bucomm.c: Likewise.
	* bucomm.h: Likewise.
	* budbg.h: Likewise.
	* budemang.c: Likewise.
	* budemang.h: Likewise.
	* coffdump.c: Likewise.
	* coffgrok.c: Likewise.
	* cxxfilt.c: Likewise.
	* debug.c: Likewise.
	* debug.h: Likewise.
	* deflex.l: Likewise.
	* dlltool.c: Likewise.
	* dlltool.h: Likewise.
	* dllwrap.c: Likewise.
	* emul_aix.c: Likewise.
	* filemode.c: Likewise.
	* ieee.c: Likewise.
	* nlmconv.c: Likewise.
	* nlmconv.h: Likewise.
	* nlmheader.y: Likewise.
	* nm.c: Likewise.
	* prdbg.c: Likewise.
	* rclex.l: Likewise.
	* rcparse.y: Likewise.
	* rdcoff.c: Likewise.
	* rddbg.c: Likewise.
	* rename.c: Likewise.
	* resbin.c: Likewise.
	* rescoff.c: Likewise.
	* resrc.c: Likewise.
	* size.c: Likewise.
	* srconv.c: Likewise.
	* stabs.c: Likewise.
	* strings.c: Likewise.
	* sysdump.c: Likewise.
	* sysinfo.y: Likewise.
	* syslex.l: Likewise.
	* unwind-ia64.c: Likewise.
	* unwind-ia64.h: Likewise.
	* version.c: Likewise.
	* windres.c: Likewise.
	* windres.h: Likewise.
	* winduni.c: Likewise.
	* wrstabs.c: Likewise.
@
text
@d2 2
a3 2
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003
   Free Software Foundation, Inc.
d434 1
a434 1
      vma = bfd_get_section_size_before_reloc (data_sec);
d444 1
a444 1
	  data_size = bfd_get_section_size_before_reloc (data_sec);
d502 1
a502 1
	  bfd_vma size;
d505 2
a506 3
	  size = sym->value;
	  sym->value = bss_sec->_raw_size;
	  bss_sec->_raw_size += size;
d508 2
a509 1
	  bss_sec->_raw_size = (bss_sec->_raw_size + align - 1) &~ (align - 1);
d673 1
a673 1
      endsym->value = bfd_get_section_size_before_reloc (bss_sec);
d1233 1
a1233 5
  size = bfd_get_section_size_before_reloc (insec);

  /* FIXME: Why are these necessary?  */
  insec->_cooked_size = insec->_raw_size;
  insec->reloc_done = TRUE;
d1880 1
a1880 2
	    (size_t) (bfd_get_section_size_after_reloc (insec)
		      - powerpc_initial_got_size));
@


1.16
log
@Change linker's default behaviour - it will now reject binary files whoes
architecture it does not recognise, unless it has explicitly told to accept
them.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001, 2002
d59 1
a59 1
extern char *strerror PARAMS ((int));
d125 1
a125 1
int main PARAMS ((int, char **));
d127 1
a127 2
static void show_usage
  PARAMS ((FILE *, int));
d129 3
a131 5
  PARAMS ((enum bfd_architecture, unsigned long, bfd_boolean));
static void setup_sections
  PARAMS ((bfd *, asection *, PTR));
static void copy_sections
  PARAMS ((bfd *, asection *, PTR));
d133 1
a133 1
  PARAMS ((bfd *, asection *, arelent ***, long *, char *, bfd_size_type));
d135 2
a136 3
  PARAMS ((bfd *, asection *, arelent ***, long *, char *, bfd_size_type));
static char *link_inputs
  PARAMS ((struct string_list *, char *));
d139 1
a139 2
static void i386_mangle_relocs
  PARAMS ((bfd *, asection *, arelent ***, long *, char *, bfd_size_type));
d143 1
a143 2
static void alpha_mangle_relocs
  PARAMS ((bfd *, asection *, arelent ***, long *, char *, bfd_size_type));
d147 3
a149 6
static void powerpc_build_stubs
  PARAMS ((bfd *, bfd *, asymbol ***, long *));
static void powerpc_resolve_stubs
  PARAMS ((bfd *, bfd *));
static void powerpc_mangle_relocs
  PARAMS ((bfd *, asection *, arelent ***, long *, char *, bfd_size_type));
d155 1
a155 3
main (argc, argv)
     int argc;
     char **argv;
d278 1
a278 1
  memset ((PTR) &fixed_hdr_struct, 0, sizeof fixed_hdr_struct);
d280 1
a280 1
  memset ((PTR) &var_hdr_struct, 0, sizeof var_hdr_struct);
d282 1
a282 1
  memset ((PTR) &version_hdr_struct, 0, sizeof version_hdr_struct);
d284 1
a284 1
  memset ((PTR) &copyright_hdr_struct, 0, sizeof copyright_hdr_struct);
d286 1
a286 1
  memset ((PTR) &extended_hdr_struct, 0, sizeof extended_hdr_struct);
d424 1
a424 1
  bfd_map_over_sections (inbfd, setup_sections, (PTR) outbfd);
d581 1
a581 1
				     xrealloc ((PTR) newsyms,
d895 1
a895 1
  bfd_map_over_sections (inbfd, copy_sections, (PTR) outbfd);
d900 1
a900 1
      PTR data;
d929 1
a929 1
      PTR data;
d947 1
a947 1
      PTR data;
d972 1
a972 1
      PTR data;
d996 1
a996 1
      PTR data;
d1014 1
a1014 1
      PTR data;
d1094 1
a1094 3
show_usage (file, status)
     FILE *file;
     int status;
d1116 2
a1117 4
select_output_format (arch, mach, bigendian)
     enum bfd_architecture arch;
     unsigned long mach;
     bfd_boolean bigendian ATTRIBUTE_UNUSED;
d1149 1
a1149 4
setup_sections (inbfd, insec, data_ptr)
     bfd *inbfd ATTRIBUTE_UNUSED;
     asection *insec;
     PTR data_ptr;
d1216 1
a1216 4
copy_sections (inbfd, insec, data_ptr)
     bfd *inbfd;
     asection *insec;
     PTR data_ptr;
d1223 1
a1223 1
  PTR contents;
d1293 1
a1293 1
  if (! bfd_set_section_contents (outbfd, secsec, (PTR) inname, secsecoff,
d1325 3
a1327 8
mangle_relocs (outbfd, insec, relocs_ptr, reloc_count_ptr, contents,
	       contents_size)
     bfd *outbfd;
     asection *insec;
     arelent ***relocs_ptr;
     long *reloc_count_ptr;
     char *contents;
     bfd_size_type contents_size;
d1360 4
a1363 8
default_mangle_relocs (outbfd, insec, relocs_ptr, reloc_count_ptr, contents,
		       contents_size)
     bfd *outbfd ATTRIBUTE_UNUSED;
     asection *insec;
     arelent ***relocs_ptr;
     long *reloc_count_ptr;
     char *contents ATTRIBUTE_UNUSED;
     bfd_size_type contents_size ATTRIBUTE_UNUSED;
d1402 3
a1404 8
i386_mangle_relocs (outbfd, insec, relocs_ptr, reloc_count_ptr, contents,
		    contents_size)
     bfd *outbfd;
     asection *insec;
     arelent ***relocs_ptr;
     long *reloc_count_ptr;
     char *contents;
     bfd_size_type contents_size;
d1555 4
a1558 8
alpha_mangle_relocs (outbfd, insec, relocs_ptr, reloc_count_ptr, contents,
		     contents_size)
     bfd *outbfd;
     asection *insec;
     register arelent ***relocs_ptr;
     long *reloc_count_ptr;
     char *contents ATTRIBUTE_UNUSED;
     bfd_size_type contents_size ATTRIBUTE_UNUSED;
d1611 1
a1611 2
  memcpy ((PTR) relocs, (PTR) old_relocs,
	  (size_t) old_reloc_count * sizeof (arelent *));
d1687 2
a1688 5
powerpc_build_stubs (inbfd, outbfd, symbols_ptr, symcount_ptr)
     bfd *inbfd;
     bfd *outbfd ATTRIBUTE_UNUSED;
     asymbol ***symbols_ptr;
     long *symcount_ptr;
d1804 1
a1804 3
powerpc_resolve_stubs (inbfd, outbfd)
     bfd *inbfd;
     bfd *outbfd;
d1865 4
a1868 8
powerpc_mangle_relocs (outbfd, insec, relocs_ptr, reloc_count_ptr, contents,
		       contents_size)
     bfd *outbfd;
     asection *insec;
     register arelent ***relocs_ptr;
     long *reloc_count_ptr;
     char *contents;
     bfd_size_type contents_size ATTRIBUTE_UNUSED;
d2044 1
a2044 3
link_inputs (inputs, ld)
     struct string_list *inputs;
     char *ld;
@


1.15
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d380 2
a381 1
  if (bfd_arch_get_compatible (inbfd, outbfd) == NULL)
@


1.14
log
@	* arsup.c: Remove ARGSUSED.
	* debug.c: Likewise.
	* ieee.c: Likewise.
	* nlmconv.c: Likewise.
	* prdbg.c: Likewise.
	* stabs.c: Likewise.
	* wrstabs.c: Likewise.
@
text
@d127 14
a140 12
static void show_usage PARAMS ((FILE *, int));
static const char *select_output_format PARAMS ((enum bfd_architecture,
						 unsigned long, boolean));
static void setup_sections PARAMS ((bfd *, asection *, PTR));
static void copy_sections PARAMS ((bfd *, asection *, PTR));
static void mangle_relocs PARAMS ((bfd *, asection *, arelent ***,
				   long *, char *,
				   bfd_size_type));
static void default_mangle_relocs PARAMS ((bfd *, asection *, arelent ***,
					   long *, char *,
					   bfd_size_type));
static char *link_inputs PARAMS ((struct string_list *, char *));
d143 2
a144 3
static void i386_mangle_relocs PARAMS ((bfd *, asection *, arelent ***,
					long *, char *,
					bfd_size_type));
d148 2
a149 3
static void alpha_mangle_relocs PARAMS ((bfd *, asection *, arelent ***,
					 long *, char *,
					 bfd_size_type));
d153 6
a158 5
static void powerpc_build_stubs PARAMS ((bfd *, bfd *, asymbol ***, long *));
static void powerpc_resolve_stubs PARAMS ((bfd *, bfd *));
static void powerpc_mangle_relocs PARAMS ((bfd *, asection *, arelent ***,
					   long *, char *,
					   bfd_size_type));
d190 1
a190 1
  boolean gotstart, gotexit, gotcheck;
d300 1
a300 1
  debug_info = false;
d304 1
a304 1
  full_map = false;
d311 1
a311 1
  verbose = false;
d463 3
a465 3
  gotstart = false;
  gotexit = false;
  gotcheck = false;
d657 1
a657 1
	      gotstart = true;
d666 1
a666 1
	      gotexit = true;
d676 1
a676 1
	      gotcheck = true;
d1131 1
a1131 1
     boolean bigendian ATTRIBUTE_UNUSED;
d1257 1
a1257 1
  insec->reloc_done = true;
d1420 1
a1420 1
	 true,			/* pc_relative */
d1425 1
a1425 1
	 true,			/* partial_inplace */
d1428 1
a1428 1
	 true);			/* pcrel_offset */
d1578 1
a1578 1
	 false,			/* pc_relative */
d1583 1
a1583 1
	 false,			/* partial_inplace */
d1586 1
a1586 1
	 false);		/* pcrel_offset */
@


1.13
log
@	* arlex.l: Use #include "" instead of <> for local header files.
	* coffdump.c: Likewise.
	* coffgrok.c: Likewise.
	* nlmconv.c: Likewise.
	* nlmheader.y: Likewise.
	* srconv.c: Likewise.
	* strings.c: Likewise.
	* sysdump.c: Likewise.
	* unwind-ia64.h: Likewise.
	* windres.h: Likewise.
	* winduni.h: Likewise.
@
text
@a1382 1
/*ARGSUSED*/
a1586 1
/*ARGSUSED*/
a1906 1
/*ARGSUSED*/
@


1.12
log
@	* filemode.c: Fix formatting.
	* ieee.c: Likewise.
	* is-ranlib.c: Likewise.
	* is-strip.c: Likewise.
	* maybe-ranlib.c: Likewise.
	* maybe-strip.c: Likewise.
	* nlmconv.c: Likewise.
	* nm.c: Likewise.
	* not-ranlib.c: Likewise.
	* not-strip.c: Likewise.
	* objcopy.c: Likewise.
	* objdump.c: Likewise.
@
text
@d40 1
a40 1
#include <ansidecl.h>
d45 1
a45 1
#include <getopt.h>
@


1.11
log
@2002-02-10  Daniel Jacobowitz  <drow@@mvista.com>

        * nlmconv.c: Back out localtime PARAMS change.
@
text
@d562 1
a562 1
 	}
d638 1
a638 1
	
d702 1
a702 1
    
d1813 1
a1813 1
      
d1896 1
a1896 1
				      
@


1.10
log
@2002-02-10  Daniel Jacobowitz  <drow@@mvista.com>

	* coffdump.c: Include "getopt.h" after "bucomm.h"
	so that macros are defined correctly.
	* nlmconv.c: Add PARAMS ((const time_t *)) to localtime
	prototype.  Prototype main.
	* nlmheader.y: Add PARAMS ((int)) to strerror prototype.
@
text
@d62 1
a62 1
extern struct tm *localtime PARAMS ((const time_t *));
@


1.9
log
@Tidy up formatting of --help output.
@
text
@d62 1
a62 1
extern struct tm *localtime ();
d124 2
@


1.9.2.1
log
@2002-02-10  Daniel Jacobowitz  <drow@@mvista.com>

	* coffdump.c: Include "getopt.h" after "bucomm.h"
	so that macros are defined correctly.
	* nlmconv.c: Add PARAMS ((const time_t *)) to localtime
	prototype.  Prototype main.
	* nlmheader.y: Add PARAMS ((int)) to strerror prototype.
@
text
@d62 1
a62 1
extern struct tm *localtime PARAMS ((const time_t *));
a123 2

int main PARAMS ((int, char **));
@


1.9.2.2
log
@2002-02-10  Daniel Jacobowitz  <drow@@mvista.com>

        * nlmconv.c: Back out localtime PARAMS change.
@
text
@d62 1
a62 1
extern struct tm *localtime ();
@


1.8
log
@	* nlmconv.c: Fix warnings about unused attributes and function
	prototypes.

	* strings.c: Add prototype for get_char.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000, 2001
d5 1
a5 1
This file is part of GNU Binutils.
d7 13
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
a124 1
static void show_help PARAMS ((void));
d228 1
a228 1
  while ((opt = getopt_long (argc, argv, "dhI:l:O:T:V", long_options,
d237 1
d239 2
a240 2
	  show_help ();
	  /*NOTREACHED*/
d253 1
d256 1
a256 1
	  /*NOTREACHED*/
d261 1
a261 1
	  /*NOTREACHED*/
a1096 9
/* Display a help message and exit.  */

static void
show_help ()
{
  printf (_("%s: Convert an object file into a NetWare Loadable Module\n"),
	  program_name);
  show_usage (stdout, 0);
}
d1105 11
a1115 7
  fprintf (file, _("\
Usage: %s [-dhV] [-I bfdname] [-O bfdname] [-T header-file] [-l linker]\n\
       [--input-target=bfdname] [--output-target=bfdname]\n\
       [--header-file=file] [--linker=linker] [--debug]\n\
       [--help] [--version]\n\
       [in-file [out-file]]\n"),
	   program_name);
@


1.7
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d59 1
a59 1
extern char *strerror ();
d1132 1
a1132 1
     boolean bigendian;
d1165 1
a1165 1
     bfd *inbfd;
d1389 1
a1389 1
     bfd *outbfd;
d1393 2
a1394 2
     char *contents;
     bfd_size_type contents_size;
d1598 2
a1599 2
     char *contents;
     bfd_size_type contents_size;
d1731 1
a1731 1
     bfd *outbfd;
d1920 1
a1920 1
     bfd_size_type contents_size;
@


1.6
log
@Fix typos in ChangeLogs and update copyright notices
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
d38 1
a41 1
#include <ctype.h>
d217 3
d1077 1
a1077 2
    if (islower ((unsigned char) *modname))
      *modname = toupper (*modname);
@


1.5
log
@2000-05-12  H.J. Lu  <hjl@@gnu.org>

	* nlmconv.c (temp_filename): Removed.

	* nlmconv.c (link_inputs): Use make_temp_file () instead of
	choose_temp_base ().
	* objdump.c (display_target_list): Likewise.
	(display_info_table): Likewise.
@
text
@d2 1
a2 1
   Copyright (C) 1993, 94, 95, 96, 97, 98, 99, 2000
@


1.5.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
@


1.4
log
@A mostly cosmetic tidy up of warnings and error message reporting.
@
text
@a2088 3
/* Temporary file name base.  */
static char *temp_filename;

d2137 1
a2137 4
  temp_filename = choose_temp_base ();

  unlink_on_exit = xmalloc (strlen (temp_filename) + 3);
  sprintf (unlink_on_exit, "%s.O", temp_filename);
@


1.3
log
@Move translated part of bug report string back into .c files so
xgettext can find it.  Regnerate .pot files.
@
text
@d2 2
a3 1
   Copyright (C) 1993, 94, 95, 96, 97, 98, 1999 Free Software Foundation, Inc.
d275 1
a275 4
	      fprintf (stderr,
		       _("%s: input and output files must be different\n"),
		       program_name);
	      exit (1);
d322 1
a322 4
	  fprintf (stderr,
		   _("%s: input file named both on command line and with INPUT\n"),
		   program_name);
	  exit (1);
d331 1
a331 1
      fprintf (stderr, _("%s: no input file\n"), program_name);
d361 1
a361 2
      fprintf (stderr, _("%s: no name for output file\n"),
	       program_name);
d374 1
a374 3
    fprintf (stderr,
	     _("%s: warning:input and output formats are not compatible\n"),
	     program_name);
d629 2
a630 3
	    fprintf (stderr,
		     _("%s: warning: symbol %s imported but not in import list\n"),
		     program_name, bfd_asymbol_name (sym));
d698 1
a698 2
    fprintf (stderr, _("%s: warning: START procedure %s not defined\n"),
	     program_name, start_procedure);
d700 3
a702 6
    fprintf (stderr, _("%s: warning: EXIT procedure %s not defined\n"),
	     program_name, exit_procedure);
  if (check_procedure != NULL
      && ! gotcheck)
    fprintf (stderr, _("%s: warning: CHECK procedure %s not defined\n"),
	     program_name, check_procedure);
d838 2
a839 3
		  fprintf (stderr,
			   _("%s:%s: warning: shared libraries can not have uninitialized data\n"),
			   program_name, sharelib_file);
d867 1
a867 2
    fprintf (stderr, _("%s: warning: No version number given\n"),
	     program_name);
d907 1
a907 2
	fprintf (stderr, _("%s:%s: read: %s\n"), program_name, custom_file,
		 strerror (errno));
d929 1
a929 3
    fprintf (stderr,
	     _("%s: warning: MAP and FULLMAP are not supported; try ld -M\n"),
	     program_name);
d936 1
a936 2
	fprintf (stderr, _("%s:%s: read: %s\n"), program_name, help_file,
		 strerror (errno));
d954 1
a954 2
	fprintf (stderr, _("%s:%s: read: %s\n"), program_name, message_file,
		 strerror (errno));
d1003 1
a1003 2
	fprintf (stderr, _("%s:%s: read: %s\n"), program_name, rpc_file,
		 strerror (errno));
d1022 1
a1022 2
	fprintf (stderr, _("%s:%s: read: %s\n"), program_name, sharelib_file,
		 strerror (errno));
d1151 2
a1152 5
      fprintf (stderr, _("%s: support not compiled in for %s\n"),
	       program_name, bfd_printable_arch_mach (arch, mach));
      exit (1);
      /* Avoid warning.  */
      return NULL;
d1978 2
a1979 2
	    fprintf (stderr, _("%s: unresolved PC relative reloc against %s\n"),
		     program_name, bfd_asymbol_name (sym));
d2042 2
a2043 3
		fprintf (stderr,
			 _("%s: overflow when adjusting relocation against %s\n"),
			 program_name, bfd_asymbol_name (sym));
d2180 1
a2180 1
      fprintf (stderr, _("%s: Execution of %s failed\n"), program_name, ld);
@


1.2
log
@Move bug report string to one place.
@
text
@d1141 1
a1141 1
    fprintf (file, REPORT_BUGS_TO);
@


1.1
log
@Initial revision
@
text
@d1141 1
a1141 1
    fprintf (file, _("Report bugs to bug-gnu-utils@@gnu.org\n"));
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@


1.1.1.1.2.1
log
@This is a grab-bag of my stuff from the head branch.
Should have done it separately, I know.
- move bug report address to include file
- objcopy --redefine-sym
- update makefile dependencies (but use automake-000227)
- H.J. Lu's fix to readelf.c
@
text
@d1141 1
a1141 1
    fprintf (file, _("Report bugs to %s\n"), REPORT_BUGS_TO);
@


1.1.1.1.2.2
log
@A mostly cosmetic tidy up of warnings and error message reporting.
@
text
@d2 1
a2 2
   Copyright (C) 1993, 94, 95, 96, 97, 98, 99, 2000
   Free Software Foundation, Inc.
d274 4
a277 1
	      fatal (_("input and output files must be different"));
d324 4
a327 1
	  fatal (_("input file named both on command line and with INPUT"));
d336 1
a336 1
      non_fatal (_("no input file"));
d366 2
a367 1
      non_fatal (_("no name for output file"));
d380 3
a382 1
    non_fatal (_("warning: input and output formats are not compatible"));
d637 3
a639 2
	    non_fatal (_("warning: symbol %s imported but not in import list"),
		       bfd_asymbol_name (sym));
d707 2
a708 1
    non_fatal (_("warning: START procedure %s not defined"), start_procedure);
d710 6
a715 3
    non_fatal (_("warning: EXIT procedure %s not defined"), exit_procedure);
  if (check_procedure != NULL && ! gotcheck)
    non_fatal (_("warning: CHECK procedure %s not defined"), check_procedure);
d851 3
a853 2
		  non_fatal (_("%s: warning: shared libraries can not have uninitialized data"),
			     sharelib_file);
d881 2
a882 1
    non_fatal (_("warning: No version number given"));
d922 2
a923 1
	non_fatal (_("%s: read: %s"), custom_file, strerror (errno));
d945 3
a947 1
    non_fatal (_("warning: MAP and FULLMAP are not supported; try ld -M"));
d954 2
a955 1
	non_fatal (_("%s: read: %s"), help_file, strerror (errno));
d973 2
a974 1
	non_fatal (_("%s: read: %s"), message_file, strerror (errno));
d1023 2
a1024 1
	non_fatal (_("%s: read: %s"), rpc_file, strerror (errno));
d1043 2
a1044 1
	non_fatal (_("%s: read: %s"), sharelib_file, strerror (errno));
d1173 5
a1177 2
      fatal (_("support not compiled in for %s"),
	     bfd_printable_arch_mach (arch, mach));
d2003 2
a2004 2
	    non_fatal (_("unresolved PC relative reloc against %s"),
		       bfd_asymbol_name (sym));
d2067 3
a2069 2
		non_fatal (_("overflow when adjusting relocation against %s"),
			   bfd_asymbol_name (sym));
d2206 1
a2206 1
      non_fatal (_("Execution of %s failed"), ld);
@


