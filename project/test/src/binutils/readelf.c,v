head	1.612;
access;
symbols
	binutils-2_24-branch:1.608.0.2
	binutils-2_24-branchpoint:1.608
	binutils-2_21_1:1.522.2.2
	binutils-2_23_2:1.578.2.4
	binutils-2_23_1:1.578.2.3
	binutils-2_23:1.578.2.2
	binutils-2_23-branch:1.578.0.2
	binutils-2_23-branchpoint:1.578
	binutils-2_22_branch:1.554.0.4
	binutils-2_22:1.554
	binutils-2_22-branch:1.554.0.2
	binutils-2_22-branchpoint:1.554
	binutils-2_21:1.522
	binutils-2_21-branch:1.522.0.2
	binutils-2_21-branchpoint:1.522
	binutils-2_20_1:1.454.2.5
	binutils-2_20:1.454.2.4
	binutils-arc-20081103-branch:1.429.0.4
	binutils-arc-20081103-branchpoint:1.429
	binutils-2_20-branch:1.454.0.2
	binutils-2_20-branchpoint:1.454
	dje-cgen-play1-branch:1.449.0.2
	dje-cgen-play1-branchpoint:1.449
	arc-20081103-branch:1.429.0.2
	arc-20081103-branchpoint:1.429
	binutils-2_19_1:1.425.2.1
	binutils-2_19:1.425.2.1
	binutils-2_19-branch:1.425.0.2
	binutils-2_19-branchpoint:1.425
	binutils-2_18:1.372.2.1
	binutils-2_18-branch:1.372.0.2
	binutils-2_18-branchpoint:1.372
	binutils-csl-coldfire-4_1-32:1.340.2.7
	binutils-csl-sourcerygxx-4_1-32:1.340.2.7
	binutils-csl-innovasic-fido-3_4_4-33:1.340.2.7
	binutils-csl-sourcerygxx-3_4_4-32:1.281.2.3.2.1
	binutils-csl-coldfire-4_1-30:1.340.2.3
	binutils-csl-sourcerygxx-4_1-30:1.340.2.3
	binutils-csl-coldfire-4_1-28:1.340.2.3
	binutils-csl-sourcerygxx-4_1-29:1.340.2.7
	binutils-csl-sourcerygxx-4_1-28:1.340.2.3
	binutils-csl-arm-2006q3-27:1.340.2.2
	binutils-csl-sourcerygxx-4_1-27:1.340.2.2
	binutils-csl-arm-2006q3-26:1.340.2.2
	binutils-csl-sourcerygxx-4_1-26:1.340.2.2
	binutils-csl-sourcerygxx-4_1-25:1.340.2.2
	binutils-csl-sourcerygxx-4_1-24:1.340.2.1
	binutils-csl-sourcerygxx-4_1-23:1.340.2.1
	binutils-csl-sourcerygxx-4_1-21:1.340.2.1
	binutils-csl-arm-2006q3-21:1.340.2.1
	binutils-csl-sourcerygxx-4_1-22:1.340.2.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.340.2.1
	binutils-csl-sourcerygxx-4_1-20:1.340.2.1
	binutils-csl-arm-2006q3-19:1.340.2.1
	binutils-csl-sourcerygxx-4_1-19:1.340.2.1
	binutils-csl-sourcerygxx-4_1-18:1.340.2.1
	binutils-csl-renesas-4_1-9:1.340.2.1
	binutils-csl-sourcerygxx-3_4_4-25:1.281.2.3.2.1
	binutils-csl-renesas-4_1-8:1.340.2.1
	binutils-csl-renesas-4_1-7:1.340.2.1
	binutils-csl-renesas-4_1-6:1.340.2.1
	binutils-csl-sourcerygxx-4_1-17:1.340.2.1
	binutils-csl-sourcerygxx-4_1-14:1.340.2.1
	binutils-csl-sourcerygxx-4_1-15:1.340.2.1
	binutils-csl-sourcerygxx-4_1-13:1.340.2.1
	binutils-2_17:1.340
	binutils-csl-sourcerygxx-4_1-12:1.340.2.1
	binutils-csl-sourcerygxx-3_4_4-21:1.340.2.1
	binutils-csl-wrs-linux-3_4_4-24:1.281.2.1
	binutils-csl-wrs-linux-3_4_4-23:1.281.2.1
	binutils-csl-sourcerygxx-4_1-9:1.340.2.1
	binutils-csl-sourcerygxx-4_1-8:1.340.2.1
	binutils-csl-sourcerygxx-4_1-7:1.340.2.1
	binutils-csl-arm-2006q1-6:1.340.2.1
	binutils-csl-sourcerygxx-4_1-6:1.340.2.1
	binutils-csl-wrs-linux-3_4_4-22:1.281.2.1
	binutils-csl-coldfire-4_1-11:1.340.2.1
	binutils-csl-sourcerygxx-3_4_4-19:1.340.2.1
	binutils-csl-coldfire-4_1-10:1.340.2.1
	binutils-csl-sourcerygxx-4_1-5:1.340.2.1
	binutils-csl-sourcerygxx-4_1-4:1.340.2.1
	binutils-csl-wrs-linux-3_4_4-21:1.281.2.1
	binutils-csl-morpho-4_1-4:1.340.2.1
	binutils-csl-sourcerygxx-3_4_4-17:1.340.2.1
	binutils-csl-wrs-linux-3_4_4-20:1.281.2.1
	binutils-2_17-branch:1.340.0.4
	binutils-2_17-branchpoint:1.340
	binutils-csl-2_17-branch:1.340.0.2
	binutils-csl-2_17-branchpoint:1.340
	binutils-csl-gxxpro-3_4-branch:1.281.2.3.0.2
	binutils-csl-gxxpro-3_4-branchpoint:1.281.2.3
	binutils-2_16_1:1.281.2.3
	binutils-csl-arm-2005q1b:1.281.2.1
	binutils-2_16:1.281.2.3
	binutils-csl-arm-2005q1a:1.281.2.1
	binutils-csl-arm-2005q1-branch:1.281.2.1.0.2
	binutils-csl-arm-2005q1-branchpoint:1.281.2.1
	binutils-2_16-branch:1.281.0.2
	binutils-2_16-branchpoint:1.281
	csl-arm-2004-q3d:1.264
	csl-arm-2004-q3:1.253
	binutils-2_15:1.230.4.1
	binutils-2_15-branchpoint:1.230
	csl-arm-2004-q1a:1.236
	csl-arm-2004-q1:1.234
	binutils-2_15-branch:1.230.0.4
	cagney_bfdfile-20040213-branch:1.230.0.2
	cagney_bfdfile-20040213-branchpoint:1.230
	cagney_bigcore-20040122-branch:1.229.0.2
	cagney_bigcore-20040122-branchpoint:1.229
	csl-arm-2003-q4:1.228
	binutils-2_14:1.204.2.2
	binutils-2_14-branch:1.204.0.2
	binutils-2_14-branchpoint:1.204
	binutils-2_13_2_1:1.166.2.2
	binutils-2_13_2:1.166.2.2
	binutils-2_13_1:1.166.2.2
	binutils-2_13:1.166.2.1
	binutils-2_13-branchpoint:1.166
	binutils-2_13-branch:1.166.0.2
	binutils-2_12_1:1.149.2.3
	binutils-2_12:1.149.2.2
	binutils-2_12-branch:1.149.0.2
	binutils-2_12-branchpoint:1.149
	cygnus_cvs_20020108_pre:1.143
	binutils-2_11_2:1.86.2.2
	binutils-2_11_1:1.86.2.2
	binutils-2_11:1.86
	x86_64versiong3:1.92
	binutils-2_11-branch:1.86.0.2
	binutils-2_10_1:1.46.2.5
	binutils-2_10:1.46.2.4
	binutils-2_10-branch:1.46.0.2
	binutils-2_10-branchpoint:1.46
	binutils_latest_snapshot:1.612
	repo-unification-2000-02-06:1.40
	binu_ss_19990721:1.19
	binu_ss_19990602:1.9
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.612
date	2013.10.14.18.45.46;	author chaoyingfu;	state Exp;
branches;
next	1.611;

1.611
date	2013.10.14.12.53.40;	author jbglaw;	state Exp;
branches;
next	1.610;

1.610
date	2013.10.14.09.15.09;	author nickc;	state Exp;
branches;
next	1.609;

1.609
date	2013.10.11.17.10.58;	author roland;	state Exp;
branches;
next	1.608;

1.608
date	2013.09.17.21.09.27;	author sje;	state Exp;
branches
	1.608.2.1;
next	1.607;

1.607
date	2013.08.09.10.40.03;	author nickc;	state Exp;
branches;
next	1.606;

1.606
date	2013.07.19.10.44.01;	author nickc;	state Exp;
branches;
next	1.605;

1.605
date	2013.07.18.10.57.23;	author nickc;	state Exp;
branches;
next	1.604;

1.604
date	2013.07.15.15.07.29;	author macro;	state Exp;
branches;
next	1.603;

1.603
date	2013.07.12.15.58.13;	author macro;	state Exp;
branches;
next	1.602;

1.602
date	2013.05.02.21.06.13;	author nickc;	state Exp;
branches;
next	1.601;

1.601
date	2013.04.29.13.38.58;	author nickc;	state Exp;
branches;
next	1.600;

1.600
date	2013.03.25.13.16.41;	author nickc;	state Exp;
branches;
next	1.599;

1.599
date	2013.03.22.16.04.55;	author nickc;	state Exp;
branches;
next	1.598;

1.598
date	2013.03.08.17.13.27;	author nickc;	state Exp;
branches;
next	1.597;

1.597
date	2013.02.27.12.40.15;	author amodra;	state Exp;
branches;
next	1.596;

1.596
date	2013.02.26.16.59.51;	author nickc;	state Exp;
branches;
next	1.595;

1.595
date	2013.02.15.14.37.35;	author nickc;	state Exp;
branches;
next	1.594;

1.594
date	2013.02.06.23.22.11;	author sandra;	state Exp;
branches;
next	1.593;

1.593
date	2013.01.29.08.55.09;	author nickc;	state Exp;
branches;
next	1.592;

1.592
date	2013.01.24.11.13.59;	author nickc;	state Exp;
branches;
next	1.591;

1.591
date	2013.01.23.08.45.19;	author krebbel;	state Exp;
branches;
next	1.590;

1.590
date	2013.01.10.09.49.13;	author nickc;	state Exp;
branches;
next	1.589;

1.589
date	2013.01.08.18.09.12;	author yufeng;	state Exp;
branches;
next	1.588;

1.588
date	2012.11.16.12.49.20;	author hjl;	state Exp;
branches;
next	1.587;

1.587
date	2012.11.13.00.54.56;	author macro;	state Exp;
branches;
next	1.586;

1.586
date	2012.11.09.17.00.41;	author nickc;	state Exp;
branches;
next	1.585;

1.585
date	2012.11.01.14.57.22;	author tromey;	state Exp;
branches;
next	1.584;

1.584
date	2012.10.30.12.44.54;	author nickc;	state Exp;
branches;
next	1.583;

1.583
date	2012.10.24.01.59.39;	author ccoutant;	state Exp;
branches;
next	1.582;

1.582
date	2012.10.23.17.46.44;	author tromey;	state Exp;
branches;
next	1.581;

1.581
date	2012.09.04.12.35.35;	author hjl;	state Exp;
branches;
next	1.580;

1.580
date	2012.08.24.07.50.29;	author mgretton;	state Exp;
branches;
next	1.579;

1.579
date	2012.08.13.14.52.42;	author nickc;	state Exp;
branches;
next	1.578;

1.578
date	2012.07.17.16.29.36;	author nickc;	state Exp;
branches
	1.578.2.1;
next	1.577;

1.577
date	2012.07.03.16.25.17;	author nickc;	state Exp;
branches;
next	1.576;

1.576
date	2012.06.29.07.02.36;	author amodra;	state Exp;
branches;
next	1.575;

1.575
date	2012.05.30.14.33.11;	author nickc;	state Exp;
branches;
next	1.574;

1.574
date	2012.05.28.14.20.16;	author nickc;	state Exp;
branches;
next	1.573;

1.573
date	2012.05.15.12.55.49;	author nickc;	state Exp;
branches;
next	1.572;

1.572
date	2012.05.11.18.18.34;	author ccoutant;	state Exp;
branches;
next	1.571;

1.571
date	2012.05.11.15.48.14;	author hjl;	state Exp;
branches;
next	1.570;

1.570
date	2012.05.03.13.12.07;	author nickc;	state Exp;
branches;
next	1.569;

1.569
date	2012.03.07.17.52.00;	author nickc;	state Exp;
branches;
next	1.568;

1.568
date	2012.02.09.04.51.44;	author amodra;	state Exp;
branches;
next	1.567;

1.567
date	2012.02.01.15.44.30;	author nickc;	state Exp;
branches;
next	1.566;

1.566
date	2012.01.26.09.59.30;	author nickc;	state Exp;
branches;
next	1.565;

1.565
date	2011.12.15.11.37.02;	author nickc;	state Exp;
branches;
next	1.564;

1.564
date	2011.12.07.03.50.10;	author daney;	state Exp;
branches;
next	1.563;

1.563
date	2011.12.02.17.04.33;	author nickc;	state Exp;
branches;
next	1.562;

1.562
date	2011.11.28.16.51.09;	author nickc;	state Exp;
branches;
next	1.561;

1.561
date	2011.11.11.20.50.38;	author schwab;	state Exp;
branches;
next	1.560;

1.560
date	2011.11.02.03.09.01;	author dj;	state Exp;
branches;
next	1.559;

1.559
date	2011.10.25.11.18.03;	author nickc;	state Exp;
branches;
next	1.558;

1.558
date	2011.10.13.15.33.32;	author nickc;	state Exp;
branches;
next	1.557;

1.557
date	2011.10.13.09.33.02;	author nickc;	state Exp;
branches;
next	1.556;

1.556
date	2011.10.05.14.13.30;	author nickc;	state Exp;
branches;
next	1.555;

1.555
date	2011.09.27.12.05.33;	author gingold;	state Exp;
branches;
next	1.554;

1.554
date	2011.09.21.20.49.13;	author davem;	state Exp;
branches
	1.554.2.1;
next	1.553;

1.553
date	2011.07.26.21.31.37;	author jakub;	state Exp;
branches;
next	1.552;

1.552
date	2011.07.24.14.20.07;	author rsandifo;	state Exp;
branches;
next	1.551;

1.551
date	2011.07.22.20.22.34;	author hjl;	state Exp;
branches;
next	1.550;

1.550
date	2011.07.03.13.37.07;	author tschwinge;	state Exp;
branches;
next	1.549;

1.549
date	2011.06.29.16.51.37;	author nickc;	state Exp;
branches;
next	1.548;

1.548
date	2011.06.15.16.36.57;	author uweigand;	state Exp;
branches;
next	1.547;

1.547
date	2011.06.13.15.18.53;	author nickc;	state Exp;
branches;
next	1.546;

1.546
date	2011.06.08.15.59.07;	author nickc;	state Exp;
branches;
next	1.545;

1.545
date	2011.04.28.17.23.16;	author tromey;	state Exp;
branches;
next	1.544;

1.544
date	2011.04.26.13.17.20;	author tromey;	state Exp;
branches;
next	1.543;

1.543
date	2011.04.26.13.09.10;	author tromey;	state Exp;
branches;
next	1.542;

1.542
date	2011.04.26.13.07.47;	author tromey;	state Exp;
branches;
next	1.541;

1.541
date	2011.04.25.14.53.27;	author tromey;	state Exp;
branches;
next	1.540;

1.540
date	2011.04.07.11.40.12;	author pbrook;	state Exp;
branches;
next	1.539;

1.539
date	2011.03.31.08.58.20;	author bernds;	state Exp;
branches;
next	1.538;

1.538
date	2011.03.31.07.49.44;	author gingold;	state Exp;
branches;
next	1.537;

1.537
date	2011.03.30.15.37.48;	author nickc;	state Exp;
branches;
next	1.536;

1.536
date	2011.03.14.17.48.31;	author msnyder;	state Exp;
branches;
next	1.535;

1.535
date	2011.03.10.10.23.36;	author nickc;	state Exp;
branches;
next	1.534;

1.534
date	2011.03.01.00.02.32;	author amodra;	state Exp;
branches;
next	1.533;

1.533
date	2011.02.24.11.57.26;	author nickc;	state Exp;
branches;
next	1.532;

1.532
date	2011.02.08.09.40.03;	author nickc;	state Exp;
branches;
next	1.531;

1.531
date	2011.01.19.18.19.54;	author macro;	state Exp;
branches;
next	1.530;

1.530
date	2011.01.18.17.43.56;	author hjl;	state Exp;
branches;
next	1.529;

1.529
date	2011.01.11.10.46.55;	author schwab;	state Exp;
branches;
next	1.528;

1.528
date	2010.12.03.17.07.19;	author devans;	state Exp;
branches;
next	1.527;

1.527
date	2010.11.21.21.27.15;	author hjl;	state Exp;
branches;
next	1.526;

1.526
date	2010.11.18.07.54.07;	author amodra;	state Exp;
branches;
next	1.525;

1.525
date	2010.11.17.03.35.50;	author amodra;	state Exp;
branches;
next	1.524;

1.524
date	2010.11.15.22.30.46;	author vapier;	state Exp;
branches;
next	1.523;

1.523
date	2010.11.11.10.23.37;	author nickc;	state Exp;
branches;
next	1.522;

1.522
date	2010.11.02.14.36.35;	author jsm28;	state Exp;
branches
	1.522.2.1;
next	1.521;

1.521
date	2010.10.29.16.47.52;	author jsm28;	state Exp;
branches;
next	1.520;

1.520
date	2010.10.29.12.10.31;	author hjl;	state Exp;
branches;
next	1.519;

1.519
date	2010.10.29.00.15.51;	author jsm28;	state Exp;
branches;
next	1.518;

1.518
date	2010.10.28.06.00.13;	author amodra;	state Exp;
branches;
next	1.517;

1.517
date	2010.10.21.21.16.50;	author jsm28;	state Exp;
branches;
next	1.516;

1.516
date	2010.10.09.05.52.29;	author hjl;	state Exp;
branches;
next	1.515;

1.515
date	2010.09.07.15.02.17;	author nickc;	state Exp;
branches;
next	1.514;

1.514
date	2010.08.23.13.51.39;	author macro;	state Exp;
branches;
next	1.513;

1.513
date	2010.08.13.16.02.16;	author nickc;	state Exp;
branches;
next	1.512;

1.512
date	2010.08.13.13.03.46;	author nathan;	state Exp;
branches;
next	1.511;

1.511
date	2010.08.12.13.11.11;	author nickc;	state Exp;
branches;
next	1.510;

1.510
date	2010.08.02.13.52.49;	author amodra;	state Exp;
branches;
next	1.509;

1.509
date	2010.07.23.14.52.48;	author nickc;	state Exp;
branches;
next	1.508;

1.508
date	2010.07.22.04.54.10;	author amodra;	state Exp;
branches;
next	1.507;

1.507
date	2010.07.20.14.08.31;	author amodra;	state Exp;
branches;
next	1.506;

1.506
date	2010.07.19.12.46.01;	author schwab;	state Exp;
branches;
next	1.505;

1.505
date	2010.07.06.09.24.05;	author amodra;	state Exp;
branches;
next	1.504;

1.504
date	2010.07.03.20.52.23;	author ccoutant;	state Exp;
branches;
next	1.503;

1.503
date	2010.06.16.00.36.01;	author jsm28;	state Exp;
branches;
next	1.502;

1.502
date	2010.06.11.18.52.30;	author hjl;	state Exp;
branches;
next	1.501;

1.501
date	2010.06.11.15.57.45;	author gingold;	state Exp;
branches;
next	1.500;

1.500
date	2010.06.10.11.50.38;	author gingold;	state Exp;
branches;
next	1.499;

1.499
date	2010.05.25.14.12.39;	author nickc;	state Exp;
branches;
next	1.498;

1.498
date	2010.05.24.13.21.25;	author gingold;	state Exp;
branches;
next	1.497;

1.497
date	2010.05.18.03.31.06;	author hjl;	state Exp;
branches;
next	1.496;

1.496
date	2010.05.06.21.32.04;	author hjl;	state Exp;
branches;
next	1.495;

1.495
date	2010.04.24.01.05.25;	author amodra;	state Exp;
branches;
next	1.494;

1.494
date	2010.04.20.08.21.54;	author nickc;	state Exp;
branches;
next	1.493;

1.493
date	2010.04.15.10.56.36;	author mgretton;	state Exp;
branches;
next	1.492;

1.492
date	2010.04.09.14.40.13;	author nickc;	state Exp;
branches;
next	1.491;

1.491
date	2010.03.25.21.12.27;	author jsm28;	state Exp;
branches;
next	1.490;

1.490
date	2010.03.18.17.46.19;	author hjl;	state Exp;
branches;
next	1.489;

1.489
date	2010.03.17.07.57.06;	author amodra;	state Exp;
branches;
next	1.488;

1.488
date	2010.03.05.21.04.57;	author ro;	state Exp;
branches;
next	1.487;

1.487
date	2010.03.02.16.44.34;	author drow;	state Exp;
branches;
next	1.486;

1.486
date	2010.02.19.01.36.39;	author amodra;	state Exp;
branches;
next	1.485;

1.485
date	2010.02.18.10.56.26;	author mgretton;	state Exp;
branches;
next	1.484;

1.484
date	2010.02.09.12.14.43;	author sky;	state Exp;
branches;
next	1.483;

1.483
date	2010.02.02.12.37.39;	author hjl;	state Exp;
branches;
next	1.482;

1.482
date	2010.01.21.11.40.27;	author krebbel;	state Exp;
branches;
next	1.481;

1.481
date	2010.01.19.13.51.29;	author amodra;	state Exp;
branches;
next	1.480;

1.480
date	2010.01.11.14.45.41;	author hjl;	state Exp;
branches;
next	1.479;

1.479
date	2010.01.07.19.14.33;	author hjl;	state Exp;
branches;
next	1.478;

1.478
date	2010.01.05.00.41.54;	author hjl;	state Exp;
branches;
next	1.477;

1.477
date	2010.01.04.13.39.58;	author nickc;	state Exp;
branches;
next	1.476;

1.476
date	2009.12.18.16.21.50;	author uweigand;	state Exp;
branches;
next	1.475;

1.475
date	2009.12.11.13.42.06;	author nickc;	state Exp;
branches;
next	1.474;

1.474
date	2009.12.03.17.01.45;	author daney;	state Exp;
branches;
next	1.473;

1.473
date	2009.12.03.12.28.36;	author nickc;	state Exp;
branches;
next	1.472;

1.472
date	2009.12.01.16.37.32;	author jsm28;	state Exp;
branches;
next	1.471;

1.471
date	2009.11.20.15.13.17;	author nickc;	state Exp;
branches;
next	1.470;

1.470
date	2009.11.17.16.31.48;	author pbrook;	state Exp;
branches;
next	1.469;

1.469
date	2009.11.08.21.36.46;	author danglin;	state Exp;
branches;
next	1.468;

1.468
date	2009.11.02.13.44.01;	author pbrook;	state Exp;
branches;
next	1.467;

1.467
date	2009.10.23.00.15.07;	author amodra;	state Exp;
branches;
next	1.466;

1.466
date	2009.10.16.10.05.06;	author nickc;	state Exp;
branches;
next	1.465;

1.465
date	2009.09.29.14.17.04;	author nickc;	state Exp;
branches;
next	1.464;

1.464
date	2009.09.28.09.45.33;	author nickc;	state Exp;
branches;
next	1.463;

1.463
date	2009.09.25.09.57.50;	author nickc;	state Exp;
branches;
next	1.462;

1.462
date	2009.09.24.20.52.07;	author ccoutant;	state Exp;
branches;
next	1.461;

1.461
date	2009.09.24.15.13.16;	author amodra;	state Exp;
branches;
next	1.460;

1.460
date	2009.09.21.11.51.01;	author amodra;	state Exp;
branches;
next	1.459;

1.459
date	2009.09.14.12.29.50;	author nickc;	state Exp;
branches;
next	1.458;

1.458
date	2009.09.10.13.40.44;	author nickc;	state Exp;
branches;
next	1.457;

1.457
date	2009.09.09.15.03.54;	author nickc;	state Exp;
branches;
next	1.456;

1.456
date	2009.09.08.10.34.27;	author amodra;	state Exp;
branches;
next	1.455;

1.455
date	2009.09.07.18.08.52;	author jkratoch;	state Exp;
branches;
next	1.454;

1.454
date	2009.08.17.08.34.37;	author nickc;	state Exp;
branches
	1.454.2.1;
next	1.453;

1.453
date	2009.08.10.14.56.34;	author nickc;	state Exp;
branches;
next	1.452;

1.452
date	2009.08.06.17.38.00;	author nickc;	state Exp;
branches;
next	1.451;

1.451
date	2009.07.25.14.58.53;	author hjl;	state Exp;
branches;
next	1.450;

1.450
date	2009.07.23.13.00.21;	author nickc;	state Exp;
branches;
next	1.449;

1.449
date	2009.06.24.10.37.34;	author nickc;	state Exp;
branches;
next	1.448;

1.448
date	2009.06.22.08.46.13;	author nickc;	state Exp;
branches;
next	1.447;

1.447
date	2009.06.12.13.54.44;	author nickc;	state Exp;
branches;
next	1.446;

1.446
date	2009.06.12.10.19.54;	author jakub;	state Exp;
branches;
next	1.445;

1.445
date	2009.05.28.11.02.22;	author nickc;	state Exp;
branches;
next	1.444;

1.444
date	2009.04.30.15.47.13;	author nickc;	state Exp;
branches;
next	1.443;

1.443
date	2009.04.29.14.21.50;	author amodra;	state Exp;
branches;
next	1.442;

1.442
date	2009.03.25.01.37.18;	author amodra;	state Exp;
branches;
next	1.441;

1.441
date	2009.03.19.14.42.52;	author hjl;	state Exp;
branches;
next	1.440;

1.440
date	2009.03.19.02.38.53;	author hjl;	state Exp;
branches;
next	1.439;

1.439
date	2009.03.02.16.06.50;	author nickc;	state Exp;
branches;
next	1.438;

1.438
date	2009.02.23.19.01.47;	author ccoutant;	state Exp;
branches;
next	1.437;

1.437
date	2009.02.09.09.14.15;	author gingold;	state Exp;
branches;
next	1.436;

1.436
date	2009.02.03.18.16.03;	author jsm28;	state Exp;
branches;
next	1.435;

1.435
date	2009.02.03.15.48.49;	author hjl;	state Exp;
branches;
next	1.434;

1.434
date	2008.12.23.19.10.19;	author nickc;	state Exp;
branches;
next	1.433;

1.433
date	2008.12.23.09.01.46;	author nickc;	state Exp;
branches;
next	1.432;

1.432
date	2008.12.09.08.34.29;	author ams;	state Exp;
branches;
next	1.431;

1.431
date	2008.12.04.08.04.47;	author nickc;	state Exp;
branches;
next	1.430;

1.430
date	2008.11.18.15.45.03;	author clm;	state Exp;
branches;
next	1.429;

1.429
date	2008.10.20.12.40.58;	author nickc;	state Exp;
branches;
next	1.428;

1.428
date	2008.10.10.20.55.36;	author froydnj;	state Exp;
branches;
next	1.427;

1.427
date	2008.10.07.12.03.18;	author nickc;	state Exp;
branches;
next	1.426;

1.426
date	2008.09.17.07.50.28;	author jkratoch;	state Exp;
branches;
next	1.425;

1.425
date	2008.09.05.14.49.05;	author drow;	state Exp;
branches
	1.425.2.1;
next	1.424;

1.424
date	2008.08.21.19.38.58;	author rth;	state Exp;
branches;
next	1.423;

1.423
date	2008.08.08.19.24.48;	author drow;	state Exp;
branches;
next	1.422;

1.422
date	2008.08.08.08.08.33;	author amodra;	state Exp;
branches;
next	1.421;

1.421
date	2008.08.03.23.23.26;	author amodra;	state Exp;
branches;
next	1.420;

1.420
date	2008.07.30.04.34.56;	author amodra;	state Exp;
branches;
next	1.419;

1.419
date	2008.07.28.04.14.40;	author amodra;	state Exp;
branches;
next	1.418;

1.418
date	2008.07.28.04.07.32;	author amodra;	state Exp;
branches;
next	1.417;

1.417
date	2008.07.26.13.10.47;	author amodra;	state Exp;
branches;
next	1.416;

1.416
date	2008.07.21.05.33.37;	author luisgpm;	state Exp;
branches;
next	1.415;

1.415
date	2008.07.15.18.48.34;	author hjl;	state Exp;
branches;
next	1.414;

1.414
date	2008.07.12.08.54.12;	author jiez;	state Exp;
branches;
next	1.413;

1.413
date	2008.07.11.19.24.38;	author jiez;	state Exp;
branches;
next	1.412;

1.412
date	2008.07.10.01.32.23;	author csilvers;	state Exp;
branches;
next	1.411;

1.411
date	2008.06.18.10.49.50;	author swami;	state Exp;
branches;
next	1.410;

1.410
date	2008.06.12.19.49.48;	author dj;	state Exp;
branches;
next	1.409;

1.409
date	2008.05.01.14.34.51;	author nickc;	state Exp;
branches;
next	1.408;

1.408
date	2008.04.30.02.09.48;	author amodra;	state Exp;
branches;
next	1.407;

1.407
date	2008.04.15.04.11.45;	author davem;	state Exp;
branches;
next	1.406;

1.406
date	2008.04.11.09.04.17;	author nickc;	state Exp;
branches;
next	1.405;

1.405
date	2008.03.21.03.27.57;	author hjl;	state Exp;
branches;
next	1.404;

1.404
date	2008.03.20.10.53.11;	author rsandifo;	state Exp;
branches;
next	1.403;

1.403
date	2008.03.13.05.27.42;	author amodra;	state Exp;
branches;
next	1.402;

1.402
date	2008.03.12.08.36.59;	author amodra;	state Exp;
branches;
next	1.401;

1.401
date	2008.03.09.13.23.28;	author pbrook;	state Exp;
branches;
next	1.400;

1.400
date	2008.02.04.19.16.53;	author nemet;	state Exp;
branches;
next	1.399;

1.399
date	2008.01.30.10.37.42;	author nickc;	state Exp;
branches;
next	1.398;

1.398
date	2008.01.28.15.15.32;	author hjl;	state Exp;
branches;
next	1.397;

1.397
date	2008.01.25.21.08.17;	author dj;	state Exp;
branches;
next	1.396;

1.396
date	2008.01.25.16.18.41;	author nickc;	state Exp;
branches;
next	1.395;

1.395
date	2008.01.10.13.09.36;	author schwab;	state Exp;
branches;
next	1.394;

1.394
date	2007.12.08.01.04.59;	author bwilson;	state Exp;
branches;
next	1.393;

1.393
date	2007.12.03.23.19.25;	author amodra;	state Exp;
branches;
next	1.392;

1.392
date	2007.11.29.12.23.43;	author shinwell;	state Exp;
branches;
next	1.391;

1.391
date	2007.11.19.12.01.42;	author nickc;	state Exp;
branches;
next	1.390;

1.390
date	2007.11.17.13.38.56;	author ths;	state Exp;
branches;
next	1.389;

1.389
date	2007.10.31.17.13.53;	author nickc;	state Exp;
branches;
next	1.388;

1.388
date	2007.10.31.16.09.52;	author nickc;	state Exp;
branches;
next	1.387;

1.387
date	2007.10.31.07.40.11;	author amodra;	state Exp;
branches;
next	1.386;

1.386
date	2007.10.29.14.44.58;	author nickc;	state Exp;
branches;
next	1.385;

1.385
date	2007.10.28.14.00.20;	author nickc;	state Exp;
branches;
next	1.384;

1.384
date	2007.10.25.15.20.23;	author drow;	state Exp;
branches;
next	1.383;

1.383
date	2007.10.25.00.41.16;	author amodra;	state Exp;
branches;
next	1.382;

1.382
date	2007.10.24.02.27.15;	author amodra;	state Exp;
branches;
next	1.381;

1.381
date	2007.10.09.13.32.50;	author hjl;	state Exp;
branches;
next	1.380;

1.380
date	2007.10.03.04.24.08;	author amodra;	state Exp;
branches;
next	1.379;

1.379
date	2007.09.17.16.09.24;	author nickc;	state Exp;
branches;
next	1.378;

1.378
date	2007.09.13.14.32.11;	author amodra;	state Exp;
branches;
next	1.377;

1.377
date	2007.09.10.09.05.23;	author amodra;	state Exp;
branches;
next	1.376;

1.376
date	2007.08.30.13.47.35;	author nickc;	state Exp;
branches;
next	1.375;

1.375
date	2007.08.25.13.20.41;	author amodra;	state Exp;
branches;
next	1.374;

1.374
date	2007.08.16.18.49.42;	author hjl;	state Exp;
branches;
next	1.373;

1.373
date	2007.08.16.13.38.09;	author hjl;	state Exp;
branches;
next	1.372;

1.372
date	2007.07.27.00.48.30;	author nemet;	state Exp;
branches
	1.372.2.1;
next	1.371;

1.371
date	2007.07.24.12.32.49;	author nickc;	state Exp;
branches;
next	1.370;

1.370
date	2007.07.09.21.19.51;	author roland;	state Exp;
branches;
next	1.369;

1.369
date	2007.07.05.16.54.45;	author nickc;	state Exp;
branches;
next	1.368;

1.368
date	2007.06.30.00.03.40;	author jsm28;	state Exp;
branches;
next	1.367;

1.367
date	2007.06.29.16.41.32;	author jsm28;	state Exp;
branches;
next	1.366;

1.366
date	2007.06.29.16.29.16;	author jsm28;	state Exp;
branches;
next	1.365;

1.365
date	2007.05.30.14.29.27;	author amodra;	state Exp;
branches;
next	1.364;

1.364
date	2007.04.26.14.46.59;	author amodra;	state Exp;
branches;
next	1.363;

1.363
date	2007.03.23.21.26.23;	author kkojima;	state Exp;
branches;
next	1.362;

1.362
date	2007.03.16.15.13.21;	author nickc;	state Exp;
branches;
next	1.361;

1.361
date	2007.03.13.17.17.15;	author nickc;	state Exp;
branches;
next	1.360;

1.360
date	2007.02.17.13.33.54;	author jsm28;	state Exp;
branches;
next	1.359;

1.359
date	2007.02.06.15.15.13;	author nickc;	state Exp;
branches;
next	1.358;

1.358
date	2007.02.05.19.56.32;	author brolley;	state Exp;
branches;
next	1.357;

1.357
date	2007.01.12.03.12.56;	author amodra;	state Exp;
branches;
next	1.356;

1.356
date	2007.01.08.18.42.36;	author kazu;	state Exp;
branches;
next	1.355;

1.355
date	2007.01.05.01.25.06;	author amodra;	state Exp;
branches;
next	1.354;

1.354
date	2006.12.25.22.39.21;	author kazu;	state Exp;
branches;
next	1.353;

1.353
date	2006.12.19.13.24.56;	author kazu;	state Exp;
branches;
next	1.352;

1.352
date	2006.12.07.15.39.01;	author kazu;	state Exp;
branches;
next	1.351;

1.351
date	2006.10.29.19.07.54;	author hjl;	state Exp;
branches;
next	1.350;

1.350
date	2006.10.25.06.49.20;	author amodra;	state Exp;
branches;
next	1.349;

1.349
date	2006.10.04.11.50.43;	author hjl;	state Exp;
branches;
next	1.348;

1.348
date	2006.09.16.23.51.50;	author nickc;	state Exp;
branches;
next	1.347;

1.347
date	2006.09.16.18.12.17;	author nickc;	state Exp;
branches;
next	1.346;

1.346
date	2006.09.01.11.38.20;	author nickc;	state Exp;
branches;
next	1.345;

1.345
date	2006.08.02.09.45.12;	author ths;	state Exp;
branches;
next	1.344;

1.344
date	2006.07.10.21.40.24;	author jakub;	state Exp;
branches;
next	1.343;

1.343
date	2006.06.29.18.32.05;	author dj;	state Exp;
branches;
next	1.342;

1.342
date	2006.04.26.15.43.17;	author jules;	state Exp;
branches;
next	1.341;

1.341
date	2006.04.18.09.41.36;	author nickc;	state Exp;
branches;
next	1.340;

1.340
date	2006.03.10.17.20.28;	author pbrook;	state Exp;
branches
	1.340.2.1;
next	1.339;

1.339
date	2006.03.06.13.42.04;	author nathan;	state Exp;
branches;
next	1.338;

1.338
date	2006.02.17.14.36.21;	author nickc;	state Exp;
branches;
next	1.337;

1.337
date	2006.02.17.12.58.46;	author skrll;	state Exp;
branches;
next	1.336;

1.336
date	2006.02.10.15.04.18;	author hjl;	state Exp;
branches;
next	1.335;

1.335
date	2006.02.08.16.47.14;	author hjl;	state Exp;
branches;
next	1.334;

1.334
date	2006.02.07.19.01.09;	author nathan;	state Exp;
branches;
next	1.333;

1.333
date	2006.02.02.22.53.46;	author hjl;	state Exp;
branches;
next	1.332;

1.332
date	2006.02.02.22.05.55;	author hjl;	state Exp;
branches;
next	1.331;

1.331
date	2006.01.18.21.07.48;	author aoliva;	state Exp;
branches;
next	1.330;

1.330
date	2006.01.09.17.21.17;	author nickc;	state Exp;
branches;
next	1.329;

1.329
date	2005.12.30.08.27.16;	author jiez;	state Exp;
branches;
next	1.328;

1.328
date	2005.12.16.10.23.07;	author nathan;	state Exp;
branches;
next	1.327;

1.327
date	2005.12.12.11.25.02;	author nathan;	state Exp;
branches;
next	1.326;

1.326
date	2005.11.14.15.00.30;	author drow;	state Exp;
branches;
next	1.325;

1.325
date	2005.11.11.11.06.34;	author nickc;	state Exp;
branches;
next	1.324;

1.324
date	2005.10.10.18.42.11;	author hjl;	state Exp;
branches;
next	1.323;

1.323
date	2005.10.03.19.37.44;	author mmitchel;	state Exp;
branches;
next	1.322;

1.322
date	2005.10.01.02.25.16;	author pbrook;	state Exp;
branches;
next	1.321;

1.321
date	2005.09.30.16.37.31;	author mmitchel;	state Exp;
branches;
next	1.320;

1.320
date	2005.09.30.15.19.53;	author clm;	state Exp;
branches;
next	1.319;

1.319
date	2005.09.30.14.55.05;	author hjl;	state Exp;
branches;
next	1.318;

1.318
date	2005.09.30.14.53.24;	author hjl;	state Exp;
branches;
next	1.317;

1.317
date	2005.09.30.14.52.18;	author hjl;	state Exp;
branches;
next	1.316;

1.316
date	2005.09.20.17.55.13;	author rth;	state Exp;
branches;
next	1.315;

1.315
date	2005.09.09.13.12.21;	author rearnsha;	state Exp;
branches;
next	1.314;

1.314
date	2005.09.07.16.25.35;	author hjl;	state Exp;
branches;
next	1.313;

1.313
date	2005.09.02.13.36.33;	author hjl;	state Exp;
branches;
next	1.312;

1.312
date	2005.08.14.22.34.11;	author danglin;	state Exp;
branches;
next	1.311;

1.311
date	2005.08.13.23.59.43;	author danglin;	state Exp;
branches;
next	1.310;

1.310
date	2005.08.11.13.14.26;	author hjl;	state Exp;
branches;
next	1.309;

1.309
date	2005.08.04.20.01.53;	author danglin;	state Exp;
branches;
next	1.308;

1.308
date	2005.07.25.15.41.04;	author hjl;	state Exp;
branches;
next	1.307;

1.307
date	2005.07.19.00.58.52;	author bje;	state Exp;
branches;
next	1.306;

1.306
date	2005.07.18.04.13.04;	author bje;	state Exp;
branches;
next	1.305;

1.305
date	2005.07.14.22.51.58;	author jimb;	state Exp;
branches;
next	1.304;

1.304
date	2005.07.07.19.27.34;	author wilson;	state Exp;
branches;
next	1.303;

1.303
date	2005.06.17.13.37.26;	author jakub;	state Exp;
branches;
next	1.302;

1.302
date	2005.06.14.11.06.28;	author jakub;	state Exp;
branches;
next	1.301;

1.301
date	2005.06.07.23.56.48;	author echristo;	state Exp;
branches;
next	1.300;

1.300
date	2005.06.07.21.14.09;	author aldyh;	state Exp;
branches;
next	1.299;

1.299
date	2005.05.31.22.52.50;	author rth;	state Exp;
branches;
next	1.298;

1.298
date	2005.05.29.23.18.51;	author rth;	state Exp;
branches;
next	1.297;

1.297
date	2005.05.24.13.53.30;	author hjl;	state Exp;
branches;
next	1.296;

1.296
date	2005.05.23.12.12.00;	author nickc;	state Exp;
branches;
next	1.295;

1.295
date	2005.05.18.22.42.08;	author bje;	state Exp;
branches;
next	1.294;

1.294
date	2005.05.14.05.07.20;	author amodra;	state Exp;
branches;
next	1.293;

1.293
date	2005.05.14.01.38.14;	author fnf;	state Exp;
branches;
next	1.292;

1.292
date	2005.05.13.18.35.55;	author hjl;	state Exp;
branches;
next	1.291;

1.291
date	2005.05.12.14.09.23;	author nickc;	state Exp;
branches;
next	1.290;

1.290
date	2005.05.12.09.05.36;	author nickc;	state Exp;
branches;
next	1.289;

1.289
date	2005.05.11.14.10.59;	author amodra;	state Exp;
branches;
next	1.288;

1.288
date	2005.05.08.14.17.39;	author nickc;	state Exp;
branches;
next	1.287;

1.287
date	2005.04.29.00.03.32;	author bje;	state Exp;
branches;
next	1.286;

1.286
date	2005.04.20.18.43.16;	author drow;	state Exp;
branches;
next	1.285;

1.285
date	2005.04.16.07.43.56;	author nickc;	state Exp;
branches;
next	1.284;

1.284
date	2005.04.04.15.07.18;	author macro;	state Exp;
branches;
next	1.283;

1.283
date	2005.04.01.00.03.17;	author hjl;	state Exp;
branches;
next	1.282;

1.282
date	2005.03.18.17.06.14;	author mmitchel;	state Exp;
branches;
next	1.281;

1.281
date	2005.02.28.15.27.16;	author jakub;	state Exp;
branches
	1.281.2.1;
next	1.280;

1.280
date	2005.02.25.22.12.12;	author hjl;	state Exp;
branches;
next	1.279;

1.279
date	2005.02.22.12.57.26;	author amodra;	state Exp;
branches;
next	1.278;

1.278
date	2005.02.21.02.55.56;	author amodra;	state Exp;
branches;
next	1.277;

1.277
date	2005.02.18.15.58.45;	author hjl;	state Exp;
branches;
next	1.276;

1.276
date	2005.02.11.15.48.11;	author hjl;	state Exp;
branches;
next	1.275;

1.275
date	2005.01.31.20.35.25;	author rsandifo;	state Exp;
branches;
next	1.274;

1.274
date	2005.01.10.17.28.37;	author hjl;	state Exp;
branches;
next	1.273;

1.273
date	2005.01.05.17.29.41;	author hjl;	state Exp;
branches;
next	1.272;

1.272
date	2005.01.05.16.15.47;	author hjl;	state Exp;
branches;
next	1.271;

1.271
date	2005.01.04.23.37.18;	author hjl;	state Exp;
branches;
next	1.270;

1.270
date	2005.01.04.11.20.45;	author nickc;	state Exp;
branches;
next	1.269;

1.269
date	2004.12.27.19.08.31;	author hjl;	state Exp;
branches;
next	1.268;

1.268
date	2004.12.22.11.04.44;	author nickc;	state Exp;
branches;
next	1.267;

1.267
date	2004.12.09.06.19.12;	author ian;	state Exp;
branches;
next	1.266;

1.266
date	2004.11.08.12.59.37;	author nickc;	state Exp;
branches;
next	1.265;

1.265
date	2004.11.08.12.55.40;	author nickc;	state Exp;
branches;
next	1.264;

1.264
date	2004.11.03.10.44.43;	author nickc;	state Exp;
branches;
next	1.263;

1.263
date	2004.11.03.02.21.57;	author amodra;	state Exp;
branches;
next	1.262;

1.262
date	2004.11.02.09.54.12;	author nickc;	state Exp;
branches;
next	1.261;

1.261
date	2004.10.26.16.05.40;	author nickc;	state Exp;
branches;
next	1.260;

1.260
date	2004.10.25.15.24.25;	author hjl;	state Exp;
branches;
next	1.259;

1.259
date	2004.10.25.09.59.01;	author nickc;	state Exp;
branches;
next	1.258;

1.258
date	2004.10.19.19.30.33;	author hjl;	state Exp;
branches;
next	1.257;

1.257
date	2004.10.12.14.17.02;	author pbrook;	state Exp;
branches;
next	1.256;

1.256
date	2004.10.08.13.54.59;	author drow;	state Exp;
branches;
next	1.255;

1.255
date	2004.10.07.21.01.43;	author aoliva;	state Exp;
branches;
next	1.254;

1.254
date	2004.10.01.12.59.42;	author nickc;	state Exp;
branches;
next	1.253;

1.253
date	2004.09.22.07.24.12;	author amodra;	state Exp;
branches;
next	1.252;

1.252
date	2004.09.12.05.52.44;	author amodra;	state Exp;
branches;
next	1.251;

1.251
date	2004.09.02.08.25.06;	author aoliva;	state Exp;
branches;
next	1.250;

1.250
date	2004.08.16.00.09.19;	author amodra;	state Exp;
branches;
next	1.249;

1.249
date	2004.08.06.13.13.30;	author schwab;	state Exp;
branches;
next	1.248;

1.248
date	2004.07.29.05.17.39;	author aoliva;	state Exp;
branches;
next	1.247;

1.247
date	2004.07.28.08.55.41;	author aoliva;	state Exp;
branches;
next	1.246;

1.246
date	2004.07.07.17.28.48;	author nickc;	state Exp;
branches;
next	1.245;

1.245
date	2004.06.24.06.25.35;	author bje;	state Exp;
branches;
next	1.244;

1.244
date	2004.06.22.10.36.15;	author amodra;	state Exp;
branches;
next	1.243;

1.243
date	2004.06.22.07.58.53;	author amodra;	state Exp;
branches;
next	1.242;

1.242
date	2004.06.22.05.17.55;	author amodra;	state Exp;
branches;
next	1.241;

1.241
date	2004.06.18.17.18.59;	author nickc;	state Exp;
branches;
next	1.240;

1.240
date	2004.05.29.00.12.03;	author ian;	state Exp;
branches;
next	1.239;

1.239
date	2004.05.13.14.41.17;	author nickc;	state Exp;
branches;
next	1.238;

1.238
date	2004.05.11.17.08.38;	author jakub;	state Exp;
branches;
next	1.237;

1.237
date	2004.05.07.15.33.36;	author hjl;	state Exp;
branches;
next	1.236;

1.236
date	2004.04.30.14.56.03;	author hjl;	state Exp;
branches;
next	1.235;

1.235
date	2004.04.27.03.59.09;	author hjl;	state Exp;
branches;
next	1.234;

1.234
date	2004.04.01.10.07.44;	author nickc;	state Exp;
branches;
next	1.233;

1.233
date	2004.03.23.23.05.50;	author pbrook;	state Exp;
branches;
next	1.232;

1.232
date	2004.03.22.03.55.50;	author rth;	state Exp;
branches;
next	1.231;

1.231
date	2004.02.23.08.45.05;	author nickc;	state Exp;
branches;
next	1.230;

1.230
date	2004.01.29.00.27.30;	author roland;	state Exp;
branches
	1.230.4.1;
next	1.229;

1.229
date	2004.01.07.18.50.51;	author nickc;	state Exp;
branches;
next	1.228;

1.228
date	2003.12.29.14.22.07;	author nickc;	state Exp;
branches;
next	1.227;

1.227
date	2003.12.19.11.43.47;	author nickc;	state Exp;
branches;
next	1.226;

1.226
date	2003.11.26.11.49.10;	author nickc;	state Exp;
branches;
next	1.225;

1.225
date	2003.11.07.12.19.34;	author nickc;	state Exp;
branches;
next	1.224;

1.224
date	2003.10.30.14.24.02;	author nickc;	state Exp;
branches;
next	1.223;

1.223
date	2003.10.27.14.06.45;	author amodra;	state Exp;
branches;
next	1.222;

1.222
date	2003.10.27.13.20.32;	author kazu;	state Exp;
branches;
next	1.221;

1.221
date	2003.09.30.16.17.11;	author cgd;	state Exp;
branches;
next	1.220;

1.220
date	2003.09.30.00.15.53;	author hjl;	state Exp;
branches;
next	1.219;

1.219
date	2003.09.25.19.07.28;	author hjl;	state Exp;
branches;
next	1.218;

1.218
date	2003.09.04.11.04.35;	author nickc;	state Exp;
branches;
next	1.217;

1.217
date	2003.08.11.16.34.18;	author ian;	state Exp;
branches;
next	1.216;

1.216
date	2003.08.11.09.15.55;	author nickc;	state Exp;
branches;
next	1.215;

1.215
date	2003.08.05.14.40.54;	author amodra;	state Exp;
branches;
next	1.214;

1.214
date	2003.07.04.10.42.26;	author nickc;	state Exp;
branches;
next	1.213;

1.213
date	2003.07.01.15.54.15;	author jakub;	state Exp;
branches;
next	1.212;

1.212
date	2003.06.26.12.46.17;	author nickc;	state Exp;
branches;
next	1.211;

1.211
date	2003.06.19.10.24.52;	author nickc;	state Exp;
branches;
next	1.210;

1.210
date	2003.06.19.10.23.39;	author nickc;	state Exp;
branches;
next	1.209;

1.209
date	2003.06.03.22.27.22;	author jakub;	state Exp;
branches;
next	1.208;

1.208
date	2003.05.31.19.29.19;	author rth;	state Exp;
branches;
next	1.207;

1.207
date	2003.05.20.14.37.46;	author mludvig;	state Exp;
branches;
next	1.206;

1.206
date	2003.05.07.14.30.13;	author hjl;	state Exp;
branches;
next	1.205;

1.205
date	2003.05.04.00.20.43;	author rth;	state Exp;
branches;
next	1.204;

1.204
date	2003.04.23.21.09.03;	author amylaar;	state Exp;
branches
	1.204.2.1;
next	1.203;

1.203
date	2003.04.23.17.36.08;	author nickc;	state Exp;
branches;
next	1.202;

1.202
date	2003.04.22.16.22.26;	author nickc;	state Exp;
branches;
next	1.201;

1.201
date	2003.04.15.08.51.51;	author nickc;	state Exp;
branches;
next	1.200;

1.200
date	2003.04.09.04.07.56;	author aoliva;	state Exp;
branches;
next	1.199;

1.199
date	2003.04.01.15.53.47;	author nickc;	state Exp;
branches;
next	1.198;

1.198
date	2003.03.31.19.29.45;	author hjl;	state Exp;
branches;
next	1.197;

1.197
date	2003.03.31.13.06.01;	author nickc;	state Exp;
branches;
next	1.196;

1.196
date	2003.02.21.12.17.51;	author nickc;	state Exp;
branches;
next	1.195;

1.195
date	2003.02.13.09.56.51;	author nickc;	state Exp;
branches;
next	1.194;

1.194
date	2003.02.10.10.44.48;	author nickc;	state Exp;
branches;
next	1.193;

1.193
date	2003.01.28.12.51.07;	author rsandifo;	state Exp;
branches;
next	1.192;

1.192
date	2003.01.21.15.41.10;	author nickc;	state Exp;
branches;
next	1.191;

1.191
date	2003.01.17.01.34.01;	author amodra;	state Exp;
branches;
next	1.190;

1.190
date	2003.01.16.04.10.23;	author amodra;	state Exp;
branches;
next	1.189;

1.189
date	2003.01.04.02.13.46;	author scox;	state Exp;
branches;
next	1.188;

1.188
date	2003.01.02.21.17.59;	author rsandifo;	state Exp;
branches;
next	1.187;

1.187
date	2002.12.30.19.25.11;	author nickc;	state Exp;
branches;
next	1.186;

1.186
date	2002.12.23.13.18.02;	author schwab;	state Exp;
branches;
next	1.185;

1.185
date	2002.12.10.17.48.25;	author nickc;	state Exp;
branches;
next	1.184;

1.184
date	2002.12.07.12.49.55;	author amodra;	state Exp;
branches;
next	1.183;

1.183
date	2002.11.30.08.39.41;	author amodra;	state Exp;
branches;
next	1.182;

1.182
date	2002.11.29.00.03.30;	author jakub;	state Exp;
branches;
next	1.181;

1.181
date	2002.11.14.14.38.39;	author nickc;	state Exp;
branches;
next	1.180;

1.180
date	2002.11.07.08.33.15;	author nickc;	state Exp;
branches;
next	1.179;

1.179
date	2002.11.06.17.02.36;	author nickc;	state Exp;
branches;
next	1.178;

1.178
date	2002.11.06.17.00.57;	author nickc;	state Exp;
branches;
next	1.177;

1.177
date	2002.11.04.03.18.41;	author amodra;	state Exp;
branches;
next	1.176;

1.176
date	2002.10.09.13.44.27;	author drow;	state Exp;
branches;
next	1.175;

1.175
date	2002.10.01.03.27.56;	author hjl;	state Exp;
branches;
next	1.174;

1.174
date	2002.09.12.10.35.54;	author nickc;	state Exp;
branches;
next	1.173;

1.173
date	2002.08.29.15.43.47;	author nickc;	state Exp;
branches;
next	1.172;

1.172
date	2002.08.20.23.46.41;	author amodra;	state Exp;
branches;
next	1.171;

1.171
date	2002.08.17.09.59.34;	author nickc;	state Exp;
branches;
next	1.170;

1.170
date	2002.08.16.14.41.15;	author nickc;	state Exp;
branches;
next	1.169;

1.169
date	2002.08.15.12.22.39;	author amodra;	state Exp;
branches;
next	1.168;

1.168
date	2002.07.30.14.33.38;	author jakub;	state Exp;
branches;
next	1.167;

1.167
date	2002.07.18.11.11.13;	author nickc;	state Exp;
branches;
next	1.166;

1.166
date	2002.07.10.15.28.34;	author jakub;	state Exp;
branches
	1.166.2.1;
next	1.165;

1.165
date	2002.07.01.16.43.37;	author thorpej;	state Exp;
branches;
next	1.164;

1.164
date	2002.06.30.18.43.33;	author ciceron;	state Exp;
branches;
next	1.163;

1.163
date	2002.06.18.21.11.47;	author brolley;	state Exp;
branches;
next	1.162;

1.162
date	2002.06.18.14.09.03;	author jakub;	state Exp;
branches;
next	1.161;

1.161
date	2002.06.07.16.42.31;	author hjl;	state Exp;
branches;
next	1.160;

1.160
date	2002.05.28.14.07.28;	author nickc;	state Exp;
branches;
next	1.159;

1.159
date	2002.05.27.15.46.10;	author nickc;	state Exp;
branches;
next	1.158;

1.158
date	2002.05.23.13.12.41;	author jakub;	state Exp;
branches;
next	1.157;

1.157
date	2002.05.23.04.11.56;	author kazu;	state Exp;
branches;
next	1.156;

1.156
date	2002.04.25.12.48.04;	author ezannoni;	state Exp;
branches;
next	1.155;

1.155
date	2002.04.16.15.03.02;	author nickc;	state Exp;
branches;
next	1.154;

1.154
date	2002.03.21.05.00.58;	author dberlin;	state Exp;
branches;
next	1.153;

1.153
date	2002.02.21.22.39.19;	author nickc;	state Exp;
branches;
next	1.152;

1.152
date	2002.02.20.10.32.43;	author nickc;	state Exp;
branches;
next	1.151;

1.151
date	2002.02.13.18.14.42;	author thorpej;	state Exp;
branches;
next	1.150;

1.150
date	2002.02.12.06.31.26;	author amodra;	state Exp;
branches;
next	1.149;

1.149
date	2002.01.31.17.32.57;	author nickc;	state Exp;
branches
	1.149.2.1;
next	1.148;

1.148
date	2002.01.23.16.12.56;	author nickc;	state Exp;
branches;
next	1.147;

1.147
date	2002.01.17.23.36.03;	author amodra;	state Exp;
branches;
next	1.146;

1.146
date	2002.01.16.05.53.08;	author amodra;	state Exp;
branches;
next	1.145;

1.145
date	2002.01.09.18.59.11;	author thorpej;	state Exp;
branches;
next	1.144;

1.144
date	2002.01.09.18.05.49;	author thorpej;	state Exp;
branches;
next	1.143;

1.143
date	2002.01.06.11.13.31;	author amodra;	state Exp;
branches;
next	1.142;

1.142
date	2001.12.20.11.20.15;	author nickc;	state Exp;
branches;
next	1.141;

1.141
date	2001.12.18.15.08.05;	author ths;	state Exp;
branches;
next	1.140;

1.140
date	2001.12.17.00.52.35;	author amodra;	state Exp;
branches;
next	1.139;

1.139
date	2001.12.13.11.09.29;	author jakub;	state Exp;
branches;
next	1.138;

1.138
date	2001.12.11.05.38.49;	author amodra;	state Exp;
branches;
next	1.137;

1.137
date	2001.12.08.03.45.51;	author geoffk;	state Exp;
branches;
next	1.136;

1.136
date	2001.12.06.10.22.36;	author nickc;	state Exp;
branches;
next	1.135;

1.135
date	2001.11.19.14.35.57;	author nickc;	state Exp;
branches;
next	1.134;

1.134
date	2001.11.15.13.14.09;	author schwab;	state Exp;
branches;
next	1.133;

1.133
date	2001.11.13.23.36.38;	author rth;	state Exp;
branches;
next	1.132;

1.132
date	2001.11.13.20.13.29;	author geoffk;	state Exp;
branches;
next	1.131;

1.131
date	2001.11.10.00.55.48;	author law;	state Exp;
branches;
next	1.130;

1.130
date	2001.11.07.16.14.09;	author jakub;	state Exp;
branches;
next	1.129;

1.129
date	2001.10.30.15.20.04;	author nickc;	state Exp;
branches;
next	1.128;

1.128
date	2001.10.13.10.00.30;	author nickc;	state Exp;
branches;
next	1.127;

1.127
date	2001.10.12.09.23.29;	author jakub;	state Exp;
branches;
next	1.126;

1.126
date	2001.10.02.09.08.44;	author nickc;	state Exp;
branches;
next	1.125;

1.125
date	2001.10.01.16.15.50;	author nickc;	state Exp;
branches;
next	1.124;

1.124
date	2001.09.26.01.55.19;	author amodra;	state Exp;
branches;
next	1.123;

1.123
date	2001.09.25.16.44.19;	author jakub;	state Exp;
branches;
next	1.122;

1.122
date	2001.09.25.12.49.38;	author amodra;	state Exp;
branches;
next	1.121;

1.121
date	2001.09.19.05.33.16;	author hjl;	state Exp;
branches;
next	1.120;

1.120
date	2001.09.18.10.05.55;	author amodra;	state Exp;
branches;
next	1.119;

1.119
date	2001.09.12.23.53.45;	author aoliva;	state Exp;
branches;
next	1.118;

1.118
date	2001.09.05.02.26.03;	author law;	state Exp;
branches;
next	1.117;

1.117
date	2001.08.31.21.15.00;	author echristo;	state Exp;
branches;
next	1.116;

1.116
date	2001.08.27.10.33.19;	author amodra;	state Exp;
branches;
next	1.115;

1.115
date	2001.08.26.13.04.34;	author ths;	state Exp;
branches;
next	1.114;

1.114
date	2001.08.22.18.42.07;	author ths;	state Exp;
branches;
next	1.113;

1.113
date	2001.08.21.15.08.38;	author hjl;	state Exp;
branches;
next	1.112;

1.112
date	2001.08.09.14.46.50;	author amodra;	state Exp;
branches;
next	1.111;

1.111
date	2001.08.08.11.17.46;	author aoliva;	state Exp;
branches;
next	1.110;

1.110
date	2001.08.07.20.15.00;	author hjl;	state Exp;
branches;
next	1.109;

1.109
date	2001.07.05.07.49.05;	author nickc;	state Exp;
branches;
next	1.108;

1.108
date	2001.07.01.08.53.15;	author nickc;	state Exp;
branches;
next	1.107;

1.107
date	2001.06.29.14.17.31;	author nickc;	state Exp;
branches;
next	1.106;

1.106
date	2001.06.28.13.58.36;	author amodra;	state Exp;
branches;
next	1.105;

1.105
date	2001.06.25.03.30.26;	author amodra;	state Exp;
branches;
next	1.104;

1.104
date	2001.06.19.11.57.28;	author nickc;	state Exp;
branches;
next	1.103;

1.103
date	2001.05.28.15.41.34;	author aj;	state Exp;
branches;
next	1.102;

1.102
date	2001.05.16.16.20.26;	author rth;	state Exp;
branches;
next	1.101;

1.101
date	2001.05.15.12.24.29;	author nickc;	state Exp;
branches;
next	1.100;

1.100
date	2001.05.11.12.36.46;	author jakub;	state Exp;
branches;
next	1.99;

1.99
date	2001.05.07.09.17.34;	author amodra;	state Exp;
branches;
next	1.98;

1.98
date	2001.04.05.17.44.15;	author hp;	state Exp;
branches;
next	1.97;

1.97
date	2001.03.31.06.36.17;	author hjl;	state Exp;
branches;
next	1.96;

1.96
date	2001.03.30.01.26.43;	author hjl;	state Exp;
branches;
next	1.95;

1.95
date	2001.03.13.06.43.57;	author nickc;	state Exp;
branches;
next	1.94;

1.94
date	2001.03.12.23.35.23;	author nickc;	state Exp;
branches;
next	1.93;

1.93
date	2001.02.28.19.40.12;	author nickc;	state Exp;
branches;
next	1.92;

1.92
date	2001.02.28.10.15.57;	author pb;	state Exp;
branches;
next	1.91;

1.91
date	2001.02.11.23.11.39;	author msokolov;	state Exp;
branches;
next	1.90;

1.90
date	2001.02.11.22.14.01;	author nickc;	state Exp;
branches;
next	1.89;

1.89
date	2001.02.10.22.20.55;	author nickc;	state Exp;
branches;
next	1.88;

1.88
date	2001.02.10.00.55.53;	author nickc;	state Exp;
branches;
next	1.87;

1.87
date	2001.02.07.19.41.02;	author nickc;	state Exp;
branches;
next	1.86;

1.86
date	2001.01.23.13.49.37;	author jakub;	state Exp;
branches
	1.86.2.1;
next	1.85;

1.85
date	2001.01.16.23.22.44;	author nickc;	state Exp;
branches;
next	1.84;

1.84
date	2000.12.12.20.58.46;	author nickc;	state Exp;
branches;
next	1.83;

1.83
date	2000.12.12.19.34.38;	author nickc;	state Exp;
branches;
next	1.82;

1.82
date	2000.12.08.17.25.47;	author aph;	state Exp;
branches;
next	1.81;

1.81
date	2000.12.04.16.34.44;	author jason;	state Exp;
branches;
next	1.80;

1.80
date	2000.12.02.01.10.32;	author nickc;	state Exp;
branches;
next	1.79;

1.79
date	2000.12.02.00.52.55;	author nickc;	state Exp;
branches;
next	1.78;

1.78
date	2000.12.01.21.35.35;	author nickc;	state Exp;
branches;
next	1.77;

1.77
date	2000.11.30.15.35.54;	author dj;	state Exp;
branches;
next	1.76;

1.76
date	2000.11.27.21.10.31;	author dj;	state Exp;
branches;
next	1.75;

1.75
date	2000.11.27.21.07.47;	author dj;	state Exp;
branches;
next	1.74;

1.74
date	2000.11.22.23.49.39;	author nickc;	state Exp;
branches;
next	1.73;

1.73
date	2000.11.20.23.47.41;	author hjl;	state Exp;
branches;
next	1.72;

1.72
date	2000.11.19.20.57.42;	author rth;	state Exp;
branches;
next	1.71;

1.71
date	2000.11.17.08.28.59;	author rth;	state Exp;
branches;
next	1.70;

1.70
date	2000.11.05.19.18.34;	author nickc;	state Exp;
branches;
next	1.69;

1.69
date	2000.09.14.01.47.33;	author nickc;	state Exp;
branches;
next	1.68;

1.68
date	2000.08.17.23.00.38;	author nickc;	state Exp;
branches;
next	1.67;

1.67
date	2000.08.08.00.47.04;	author jle;	state Exp;
branches;
next	1.66;

1.66
date	2000.07.20.17.28.56;	author hp;	state Exp;
branches;
next	1.65;

1.65
date	2000.07.20.02.45.36;	author hjl;	state Exp;
branches;
next	1.64;

1.64
date	2000.07.19.18.45.46;	author hjl;	state Exp;
branches;
next	1.63;

1.63
date	2000.07.19.18.24.32;	author hjl;	state Exp;
branches;
next	1.62;

1.62
date	2000.07.19.18.03.18;	author hjl;	state Exp;
branches;
next	1.61;

1.61
date	2000.07.10.14.51.04;	author amodra;	state Exp;
branches;
next	1.60;

1.60
date	2000.06.19.01.22.37;	author nickc;	state Exp;
branches;
next	1.59;

1.59
date	2000.05.02.17.54.32;	author hjl;	state Exp;
branches;
next	1.58;

1.58
date	2000.05.01.06.53.41;	author denisc;	state Exp;
branches;
next	1.57;

1.57
date	2000.04.21.20.22.21;	author wilson;	state Exp;
branches;
next	1.56;

1.56
date	2000.04.14.04.14.24;	author amodra;	state Exp;
branches;
next	1.55;

1.55
date	2000.04.10.17.13.07;	author nickc;	state Exp;
branches;
next	1.54;

1.54
date	2000.04.07.00.16.45;	author jason;	state Exp;
branches;
next	1.53;

1.53
date	2000.04.07.00.15.00;	author jason;	state Exp;
branches;
next	1.52;

1.52
date	2000.04.06.23.43.31;	author nickc;	state Exp;
branches;
next	1.51;

1.51
date	2000.04.06.23.21.50;	author nickc;	state Exp;
branches;
next	1.50;

1.50
date	2000.04.06.23.21.09;	author nickc;	state Exp;
branches;
next	1.49;

1.49
date	2000.04.04.23.05.32;	author hjl;	state Exp;
branches;
next	1.48;

1.48
date	2000.04.04.14.32.29;	author amodra;	state Exp;
branches;
next	1.47;

1.47
date	2000.04.03.14.10.03;	author amodra;	state Exp;
branches;
next	1.46;

1.46
date	2000.03.30.23.37.22;	author amodra;	state Exp;
branches
	1.46.2.1;
next	1.45;

1.45
date	2000.03.27.08.39.12;	author amodra;	state Exp;
branches;
next	1.44;

1.44
date	2000.02.28.03.31.50;	author ian;	state Exp;
branches;
next	1.43;

1.43
date	2000.02.23.23.19.46;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2000.02.22.19.56.41;	author nickc;	state Exp;
branches;
next	1.41;

1.41
date	2000.02.22.07.18.10;	author ian;	state Exp;
branches;
next	1.40;

1.40
date	2000.01.26.23.11.48;	author amodra;	state Exp;
branches;
next	1.39;

1.39
date	2000.01.17.18.09.34;	author nickc;	state Exp;
branches;
next	1.38;

1.38
date	2000.01.13.20.13.35;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	2000.01.11.17.53.33;	author nickc;	state Exp;
branches;
next	1.36;

1.36
date	2000.01.10.18.52.23;	author nickc;	state Exp;
branches;
next	1.35;

1.35
date	99.12.28.20.23.39;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	99.12.10.18.32.57;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	99.12.07.21.41.54;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	99.12.07.21.40.04;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	99.12.07.21.26.51;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	99.12.07.21.14.08;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	99.11.25.11.08.25;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	99.10.04.18.59.13;	author drepper;	state Exp;
branches;
next	1.27;

1.27
date	99.09.04.17.40.18;	author ian;	state Exp;
branches;
next	1.26;

1.26
date	99.08.31.16.54.56;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	99.08.28.08.13.43;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	99.08.27.10.34.58;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	99.08.27.08.45.02;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	99.08.26.18.25.20;	author rth;	state Exp;
branches;
next	1.21;

1.21
date	99.08.26.10.53.40;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	99.08.09.17.16.23;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	99.07.16.21.38.16;	author rth;	state Exp;
branches;
next	1.18;

1.18
date	99.07.11.20.02.26;	author ian;	state Exp;
branches;
next	1.17;

1.17
date	99.07.09.03.14.15;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	99.07.08.15.49.41;	author rth;	state Exp;
branches;
next	1.15;

1.15
date	99.06.21.15.55.49;	author law;	state Exp;
branches;
next	1.14;

1.14
date	99.06.16.10.03.59;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	99.06.12.13.30.24;	author ian;	state Exp;
branches;
next	1.12;

1.12
date	99.06.09.02.44.15;	author schwab;	state Exp;
branches;
next	1.11;

1.11
date	99.06.04.11.33.32;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	99.06.04.08.13.04;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	99.05.31.00.58.59;	author schwab;	state Exp;
branches;
next	1.8;

1.8
date	99.05.29.10.51.13;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	99.05.29.09.09.37;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	99.05.28.17.24.21;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	99.05.28.10.14.11;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	99.05.27.22.04.40;	author ian;	state Exp;
branches;
next	1.3;

1.3
date	99.05.27.03.02.23;	author schwab;	state Exp;
branches;
next	1.2;

1.2
date	99.05.05.11.00.55;	author clm;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.29.09;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.608.2.1
date	2013.10.11.17.11.33;	author roland;	state Exp;
branches;
next	;

1.578.2.1
date	2012.08.16.09.21.37;	author nickc;	state Exp;
branches;
next	1.578.2.2;

1.578.2.2
date	2012.08.28.10.50.40;	author mgretton;	state Exp;
branches;
next	1.578.2.3;

1.578.2.3
date	2012.10.31.11.45.12;	author nickc;	state Exp;
branches;
next	1.578.2.4;

1.578.2.4
date	2013.01.21.13.48.42;	author amodra;	state Exp;
branches;
next	;

1.554.2.1
date	2012.01.30.11.35.38;	author nickc;	state Exp;
branches;
next	;

1.522.2.1
date	2011.02.01.12.25.36;	author amodra;	state Exp;
branches;
next	1.522.2.2;

1.522.2.2
date	2011.03.01.00.02.38;	author amodra;	state Exp;
branches;
next	;

1.454.2.1
date	2009.09.08.10.47.49;	author amodra;	state Exp;
branches;
next	1.454.2.2;

1.454.2.2
date	2009.09.09.15.05.51;	author nickc;	state Exp;
branches;
next	1.454.2.3;

1.454.2.3
date	2009.09.10.13.42.09;	author nickc;	state Exp;
branches;
next	1.454.2.4;

1.454.2.4
date	2009.09.21.11.55.17;	author amodra;	state Exp;
branches;
next	1.454.2.5;

1.454.2.5
date	2009.10.23.00.15.41;	author amodra;	state Exp;
branches;
next	;

1.425.2.1
date	2008.09.17.08.18.20;	author jkratoch;	state Exp;
branches;
next	1.425.2.2;

1.425.2.2
date	2009.03.02.13.35.24;	author amodra;	state Exp;
branches;
next	;

1.372.2.1
date	2007.08.25.23.00.14;	author amodra;	state Exp;
branches;
next	;

1.340.2.1
date	2006.04.03.00.03.33;	author jules;	state Exp;
branches;
next	1.340.2.2;

1.340.2.2
date	2006.10.16.20.21.23;	author nathan;	state Exp;
branches;
next	1.340.2.3;

1.340.2.3
date	2006.11.17.14.21.49;	author kazu;	state Exp;
branches;
next	1.340.2.4;

1.340.2.4
date	2006.11.28.14.09.49;	author kazu;	state Exp;
branches;
next	1.340.2.5;

1.340.2.5
date	2006.11.29.10.32.51;	author kazu;	state Exp;
branches;
next	1.340.2.6;

1.340.2.6
date	2006.11.29.16.31.07;	author shinwell;	state Exp;
branches;
next	1.340.2.7;

1.340.2.7
date	2006.11.30.14.49.43;	author kazu;	state Exp;
branches;
next	;

1.281.2.1
date	2005.03.20.19.16.22;	author mmitchel;	state Exp;
branches;
next	1.281.2.2;

1.281.2.2
date	2005.04.04.15.07.34;	author macro;	state Exp;
branches;
next	1.281.2.3;

1.281.2.3
date	2005.04.20.18.44.06;	author drow;	state Exp;
branches
	1.281.2.3.2.1;
next	;

1.281.2.3.2.1
date	2005.08.30.19.57.32;	author mmitchel;	state Exp;
branches;
next	;

1.230.4.1
date	2004.04.09.18.28.06;	author drow;	state Exp;
branches;
next	;

1.204.2.1
date	2003.05.06.01.17.01;	author drow;	state Exp;
branches;
next	1.204.2.2;

1.204.2.2
date	2003.05.15.19.20.38;	author drow;	state Exp;
branches;
next	;

1.166.2.1
date	2002.07.30.18.18.08;	author drow;	state Exp;
branches;
next	1.166.2.2;

1.166.2.2
date	2002.10.28.18.45.47;	author drow;	state Exp;
branches;
next	;

1.149.2.1
date	2002.02.12.06.45.41;	author amodra;	state Exp;
branches;
next	1.149.2.2;

1.149.2.2
date	2002.02.13.19.16.42;	author thorpej;	state Exp;
branches;
next	1.149.2.3;

1.149.2.3
date	2002.04.27.12.45.12;	author amodra;	state Exp;
branches;
next	;

1.86.2.1
date	2001.04.06.11.04.45;	author hp;	state Exp;
branches;
next	1.86.2.2;

1.86.2.2
date	2001.05.28.18.34.24;	author pb;	state Exp;
branches;
next	1.86.2.3;

1.86.2.3
date	2001.06.29.14.35.09;	author nickc;	state Exp;
branches;
next	1.86.2.4;

1.86.2.4
date	2001.10.01.16.17.07;	author nickc;	state Exp;
branches;
next	1.86.2.5;

1.86.2.5
date	2001.10.02.09.12.11;	author nickc;	state Exp;
branches;
next	;

1.46.2.1
date	2000.04.05.05.36.40;	author amodra;	state Exp;
branches;
next	1.46.2.2;

1.46.2.2
date	2000.04.10.18.01.16;	author nickc;	state Exp;
branches;
next	1.46.2.3;

1.46.2.3
date	2000.05.23.07.57.58;	author pb;	state Exp;
branches;
next	1.46.2.4;

1.46.2.4
date	2000.05.23.08.39.06;	author amodra;	state Exp;
branches;
next	1.46.2.5;

1.46.2.5
date	2000.10.14.20.43.13;	author pb;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.09;	author rth;	state Exp;
branches;
next	;


desc
@@


1.612
log
@2013-10-14  Chao-ying Fu  <Chao-ying.Fu@@imgtec.com>

	* readelf.c (display_mips_gnu_attribute): Support Tag_GNU_MIPS_ABI_MSA.
	* doc/binutils.texi: Document -Mmsa disassembler option.
@
text
@/* readelf.c -- display contents of an ELF format file
   Copyright 1998-2013 Free Software Foundation, Inc.

   Originally developed by Eric Youngdale <eric@@andante.jic.com>
   Modifications by Nick Clifton <nickc@@redhat.com>

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* The difference between readelf and objdump:

  Both programs are capable of displaying the contents of ELF format files,
  so why does the binutils project have two file dumpers ?

  The reason is that objdump sees an ELF file through a BFD filter of the
  world; if BFD has a bug where, say, it disagrees about a machine constant
  in e_flags, then the odds are good that it will remain internally
  consistent.  The linker sees it the BFD way, objdump sees it the BFD way,
  GAS sees it the BFD way.  There was need for a tool to go find out what
  the file actually says.

  This is why the readelf program does not link against the BFD library - it
  exists as an independent program to help verify the correct working of BFD.

  There is also the case that readelf can provide more information about an
  ELF file than is provided by objdump.  In particular it can display DWARF
  debugging information which (at the moment) objdump cannot.  */

#include "sysdep.h"
#include <assert.h>
#include <time.h>
#ifdef HAVE_ZLIB_H
#include <zlib.h>
#endif
#ifdef HAVE_WCHAR_H
#include <wchar.h>
#endif

#if __GNUC__ >= 2
/* Define BFD64 here, even if our default architecture is 32 bit ELF
   as this will allow us to read in and parse 64bit and 32bit ELF files.
   Only do this if we believe that the compiler can support a 64 bit
   data type.  For now we only rely on GCC being able to do this.  */
#define BFD64
#endif

#include "bfd.h"
#include "bucomm.h"
#include "elfcomm.h"
#include "dwarf.h"

#include "elf/common.h"
#include "elf/external.h"
#include "elf/internal.h"


/* Included here, before RELOC_MACROS_GEN_FUNC is defined, so that
   we can obtain the H8 reloc numbers.  We need these for the
   get_reloc_size() function.  We include h8.h again after defining
   RELOC_MACROS_GEN_FUNC so that we get the naming function as well.  */

#include "elf/h8.h"
#undef _ELF_H8_H

/* Undo the effects of #including reloc-macros.h.  */

#undef START_RELOC_NUMBERS
#undef RELOC_NUMBER
#undef FAKE_RELOC
#undef EMPTY_RELOC
#undef END_RELOC_NUMBERS
#undef _RELOC_MACROS_H

/* The following headers use the elf/reloc-macros.h file to
   automatically generate relocation recognition functions
   such as elf_mips_reloc_type()  */

#define RELOC_MACROS_GEN_FUNC

#include "elf/aarch64.h"
#include "elf/alpha.h"
#include "elf/arc.h"
#include "elf/arm.h"
#include "elf/avr.h"
#include "elf/bfin.h"
#include "elf/cr16.h"
#include "elf/cris.h"
#include "elf/crx.h"
#include "elf/d10v.h"
#include "elf/d30v.h"
#include "elf/dlx.h"
#include "elf/epiphany.h"
#include "elf/fr30.h"
#include "elf/frv.h"
#include "elf/h8.h"
#include "elf/hppa.h"
#include "elf/i386.h"
#include "elf/i370.h"
#include "elf/i860.h"
#include "elf/i960.h"
#include "elf/ia64.h"
#include "elf/ip2k.h"
#include "elf/lm32.h"
#include "elf/iq2000.h"
#include "elf/m32c.h"
#include "elf/m32r.h"
#include "elf/m68k.h"
#include "elf/m68hc11.h"
#include "elf/mcore.h"
#include "elf/mep.h"
#include "elf/metag.h"
#include "elf/microblaze.h"
#include "elf/mips.h"
#include "elf/mmix.h"
#include "elf/mn10200.h"
#include "elf/mn10300.h"
#include "elf/moxie.h"
#include "elf/mt.h"
#include "elf/msp430.h"
#include "elf/nios2.h"
#include "elf/or32.h"
#include "elf/pj.h"
#include "elf/ppc.h"
#include "elf/ppc64.h"
#include "elf/rl78.h"
#include "elf/rx.h"
#include "elf/s390.h"
#include "elf/score.h"
#include "elf/sh.h"
#include "elf/sparc.h"
#include "elf/spu.h"
#include "elf/tic6x.h"
#include "elf/tilegx.h"
#include "elf/tilepro.h"
#include "elf/v850.h"
#include "elf/vax.h"
#include "elf/x86-64.h"
#include "elf/xc16x.h"
#include "elf/xgate.h"
#include "elf/xstormy16.h"
#include "elf/xtensa.h"

#include "getopt.h"
#include "libiberty.h"
#include "safe-ctype.h"
#include "filenames.h"

#ifndef offsetof
#define offsetof(TYPE, MEMBER) ((size_t) &(((TYPE *) 0)->MEMBER))
#endif

char * program_name = "readelf";
static long archive_file_offset;
static unsigned long archive_file_size;
static unsigned long dynamic_addr;
static bfd_size_type dynamic_size;
static unsigned int dynamic_nent;
static char * dynamic_strings;
static unsigned long dynamic_strings_length;
static char * string_table;
static unsigned long string_table_length;
static unsigned long num_dynamic_syms;
static Elf_Internal_Sym * dynamic_symbols;
static Elf_Internal_Syminfo * dynamic_syminfo;
static unsigned long dynamic_syminfo_offset;
static unsigned int dynamic_syminfo_nent;
static char program_interpreter[PATH_MAX];
static bfd_vma dynamic_info[DT_ENCODING];
static bfd_vma dynamic_info_DT_GNU_HASH;
static bfd_vma version_info[16];
static Elf_Internal_Ehdr elf_header;
static Elf_Internal_Shdr * section_headers;
static Elf_Internal_Phdr * program_headers;
static Elf_Internal_Dyn *  dynamic_section;
static Elf_Internal_Shdr * symtab_shndx_hdr;
static int show_name;
static int do_dynamic;
static int do_syms;
static int do_dyn_syms;
static int do_reloc;
static int do_sections;
static int do_section_groups;
static int do_section_details;
static int do_segments;
static int do_unwind;
static int do_using_dynamic;
static int do_header;
static int do_dump;
static int do_version;
static int do_histogram;
static int do_debugging;
static int do_arch;
static int do_notes;
static int do_archive_index;
static int is_32bit_elf;

struct group_list
{
  struct group_list * next;
  unsigned int section_index;
};

struct group
{
  struct group_list * root;
  unsigned int group_index;
};

static size_t group_count;
static struct group * section_groups;
static struct group ** section_headers_groups;


/* Flag bits indicating particular types of dump.  */
#define HEX_DUMP	(1 << 0)	/* The -x command line switch.  */
#define DISASS_DUMP	(1 << 1)	/* The -i command line switch.  */
#define DEBUG_DUMP	(1 << 2)	/* The -w command line switch.  */
#define STRING_DUMP     (1 << 3)	/* The -p command line switch.  */
#define RELOC_DUMP      (1 << 4)	/* The -R command line switch.  */

typedef unsigned char dump_type;

/* A linked list of the section names for which dumps were requested.  */
struct dump_list_entry
{
  char * name;
  dump_type type;
  struct dump_list_entry * next;
};
static struct dump_list_entry * dump_sects_byname;

/* A dynamic array of flags indicating for which sections a dump
   has been requested via command line switches.  */
static dump_type *   cmdline_dump_sects = NULL;
static unsigned int  num_cmdline_dump_sects = 0;

/* A dynamic array of flags indicating for which sections a dump of
   some kind has been requested.  It is reset on a per-object file
   basis and then initialised from the cmdline_dump_sects array,
   the results of interpreting the -w switch, and the
   dump_sects_byname list.  */
static dump_type *   dump_sects = NULL;
static unsigned int  num_dump_sects = 0;


/* How to print a vma value.  */
typedef enum print_mode
{
  HEX,
  DEC,
  DEC_5,
  UNSIGNED,
  PREFIX_HEX,
  FULL_HEX,
  LONG_HEX
}
print_mode;

#define UNKNOWN -1

#define SECTION_NAME(X)						\
  ((X) == NULL ? _("<none>")					\
   : string_table == NULL ? _("<no-name>")			\
   : ((X)->sh_name >= string_table_length ? _("<corrupt>")	\
  : string_table + (X)->sh_name))

#define DT_VERSIONTAGIDX(tag)	(DT_VERNEEDNUM - (tag))	/* Reverse order!  */

#define GET_ELF_SYMBOLS(file, section, sym_count)			\
  (is_32bit_elf ? get_32bit_elf_symbols (file, section, sym_count)	\
   : get_64bit_elf_symbols (file, section, sym_count))

#define VALID_DYNAMIC_NAME(offset)	((dynamic_strings != NULL) && (offset < dynamic_strings_length))
/* GET_DYNAMIC_NAME asssumes that VALID_DYNAMIC_NAME has
   already been called and verified that the string exists.  */
#define GET_DYNAMIC_NAME(offset)	(dynamic_strings + offset)

#define REMOVE_ARCH_BITS(ADDR)			\
  do						\
    {						\
      if (elf_header.e_machine == EM_ARM)	\
	(ADDR) &= ~1;				\
    }						\
  while (0)

/* Retrieve NMEMB structures, each SIZE bytes long from FILE starting at OFFSET.
   Put the retrieved data into VAR, if it is not NULL.  Otherwise allocate a buffer
   using malloc and fill that.  In either case return the pointer to the start of
   the retrieved data or NULL if something went wrong.  If something does go wrong
   emit an error message using REASON as part of the context.  */

static void *
get_data (void * var, FILE * file, long offset, size_t size, size_t nmemb,
	  const char * reason)
{
  void * mvar;

  if (size == 0 || nmemb == 0)
    return NULL;

  if (fseek (file, archive_file_offset + offset, SEEK_SET))
    {
      error (_("Unable to seek to 0x%lx for %s\n"),
	     (unsigned long) archive_file_offset + offset, reason);
      return NULL;
    }

  mvar = var;
  if (mvar == NULL)
    {
      /* Check for overflow.  */
      if (nmemb < (~(size_t) 0 - 1) / size)
	/* + 1 so that we can '\0' terminate invalid string table sections.  */
	mvar = malloc (size * nmemb + 1);

      if (mvar == NULL)
	{
	  error (_("Out of memory allocating 0x%lx bytes for %s\n"),
		 (unsigned long)(size * nmemb), reason);
	  return NULL;
	}

      ((char *) mvar)[size * nmemb] = '\0';
    }

  if (fread (mvar, size, nmemb, file) != nmemb)
    {
      error (_("Unable to read in 0x%lx bytes of %s\n"),
	     (unsigned long)(size * nmemb), reason);
      if (mvar != var)
	free (mvar);
      return NULL;
    }

  return mvar;
}

/* Print a VMA value.  */

static int
print_vma (bfd_vma vma, print_mode mode)
{
  int nc = 0;

  switch (mode)
    {
    case FULL_HEX:
      nc = printf ("0x");
      /* Drop through.  */

    case LONG_HEX:
#ifdef BFD64
      if (is_32bit_elf)
	return nc + printf ("%8.8" BFD_VMA_FMT "x", vma);
#endif
      printf_vma (vma);
      return nc + 16;

    case DEC_5:
      if (vma <= 99999)
	return printf ("%5" BFD_VMA_FMT "d", vma);
      /* Drop through.  */

    case PREFIX_HEX:
      nc = printf ("0x");
      /* Drop through.  */

    case HEX:
      return nc + printf ("%" BFD_VMA_FMT "x", vma);

    case DEC:
      return printf ("%" BFD_VMA_FMT "d", vma);

    case UNSIGNED:
      return printf ("%" BFD_VMA_FMT "u", vma);
    }
  return 0;
}

/* Display a symbol on stdout.  Handles the display of control characters and
   multibye characters (assuming the host environment supports them).

   Display at most abs(WIDTH) characters, truncating as necessary, unless do_wide is true.

   If WIDTH is negative then ensure that the output is at least (- WIDTH) characters,
   padding as necessary.

   Returns the number of emitted characters.  */

static unsigned int
print_symbol (int width, const char *symbol)
{
  bfd_boolean extra_padding = FALSE;
  int num_printed = 0;
#ifdef HAVE_MBSTATE_T
  mbstate_t state;
#endif
  int width_remaining;

  if (width < 0)
    {
      /* Keep the width positive.  This also helps.  */
      width = - width;
      extra_padding = TRUE;
    }

  if (do_wide)
    /* Set the remaining width to a very large value.
       This simplifies the code below.  */
    width_remaining = INT_MAX;
  else
    width_remaining = width;

#ifdef HAVE_MBSTATE_T
  /* Initialise the multibyte conversion state.  */
  memset (& state, 0, sizeof (state));
#endif

  while (width_remaining)
    {
      size_t  n;
      const char c = *symbol++;

      if (c == 0)
	break;

      /* Do not print control characters directly as they can affect terminal
	 settings.  Such characters usually appear in the names generated
	 by the assembler for local labels.  */
      if (ISCNTRL (c))
	{
	  if (width_remaining < 2)
	    break;

	  printf ("^%c", c + 0x40);
	  width_remaining -= 2;
	  num_printed += 2;
	}
      else if (ISPRINT (c))
	{
	  putchar (c);
	  width_remaining --;
	  num_printed ++;
	}
      else
	{
#ifdef HAVE_MBSTATE_T
	  wchar_t w;
#endif
	  /* Let printf do the hard work of displaying multibyte characters.  */
	  printf ("%.1s", symbol - 1);
	  width_remaining --;
	  num_printed ++;

#ifdef HAVE_MBSTATE_T
	  /* Try to find out how many bytes made up the character that was
	     just printed.  Advance the symbol pointer past the bytes that
	     were displayed.  */
	  n = mbrtowc (& w, symbol - 1, MB_CUR_MAX, & state);
#else
	  n = 1;
#endif
	  if (n != (size_t) -1 && n != (size_t) -2 && n > 0)
	    symbol += (n - 1);
	}
    }

  if (extra_padding && num_printed < width)
    {
      /* Fill in the remaining spaces.  */
      printf ("%-*s", width - num_printed, " ");
      num_printed = width;
    }

  return num_printed;
}

/* Return a pointer to section NAME, or NULL if no such section exists.  */

static Elf_Internal_Shdr *
find_section (const char * name)
{
  unsigned int i;

  for (i = 0; i < elf_header.e_shnum; i++)
    if (streq (SECTION_NAME (section_headers + i), name))
      return section_headers + i;

  return NULL;
}

/* Return a pointer to a section containing ADDR, or NULL if no such
   section exists.  */

static Elf_Internal_Shdr *
find_section_by_address (bfd_vma addr)
{
  unsigned int i;

  for (i = 0; i < elf_header.e_shnum; i++)
    {
      Elf_Internal_Shdr *sec = section_headers + i;
      if (addr >= sec->sh_addr && addr < sec->sh_addr + sec->sh_size)
	return sec;
    }

  return NULL;
}

/* Return a pointer to section NAME, or NULL if no such section exists,
   restricted to the list of sections given in SET.  */

static Elf_Internal_Shdr *
find_section_in_set (const char * name, unsigned int * set)
{
  unsigned int i;

  if (set != NULL)
    {
      while ((i = *set++) > 0)
	if (streq (SECTION_NAME (section_headers + i), name))
	  return section_headers + i;
    }

  return find_section (name);
}

/* Read an unsigned LEB128 encoded value from p.  Set *PLEN to the number of
   bytes read.  */

static inline unsigned long
read_uleb128 (unsigned char *data,
	      unsigned int *length_return,
	      const unsigned char * const end)
{
  return read_leb128 (data, length_return, FALSE, end);
}

/* Return true if the current file is for IA-64 machine and OpenVMS ABI.
   This OS has so many departures from the ELF standard that we test it at
   many places.  */

static inline int
is_ia64_vms (void)
{
  return elf_header.e_machine == EM_IA_64
    && elf_header.e_ident[EI_OSABI] == ELFOSABI_OPENVMS;
}

/* Guess the relocation size commonly used by the specific machines.  */

static int
guess_is_rela (unsigned int e_machine)
{
  switch (e_machine)
    {
      /* Targets that use REL relocations.  */
    case EM_386:
    case EM_486:
    case EM_960:
    case EM_ARM:
    case EM_D10V:
    case EM_CYGNUS_D10V:
    case EM_DLX:
    case EM_MIPS:
    case EM_MIPS_RS3_LE:
    case EM_CYGNUS_M32R:
    case EM_OPENRISC:
    case EM_OR32:
    case EM_SCORE:
    case EM_XGATE:
      return FALSE;

      /* Targets that use RELA relocations.  */
    case EM_68K:
    case EM_860:
    case EM_AARCH64:
    case EM_ADAPTEVA_EPIPHANY:
    case EM_ALPHA:
    case EM_ALTERA_NIOS2:
    case EM_AVR:
    case EM_AVR_OLD:
    case EM_BLACKFIN:
    case EM_CR16:
    case EM_CRIS:
    case EM_CRX:
    case EM_D30V:
    case EM_CYGNUS_D30V:
    case EM_FR30:
    case EM_CYGNUS_FR30:
    case EM_CYGNUS_FRV:
    case EM_H8S:
    case EM_H8_300:
    case EM_H8_300H:
    case EM_IA_64:
    case EM_IP2K:
    case EM_IP2K_OLD:
    case EM_IQ2000:
    case EM_LATTICEMICO32:
    case EM_M32C_OLD:
    case EM_M32C:
    case EM_M32R:
    case EM_MCORE:
    case EM_CYGNUS_MEP:
    case EM_METAG:
    case EM_MMIX:
    case EM_MN10200:
    case EM_CYGNUS_MN10200:
    case EM_MN10300:
    case EM_CYGNUS_MN10300:
    case EM_MOXIE:
    case EM_MSP430:
    case EM_MSP430_OLD:
    case EM_MT:
    case EM_NIOS32:
    case EM_PPC64:
    case EM_PPC:
    case EM_RL78:
    case EM_RX:
    case EM_S390:
    case EM_S390_OLD:
    case EM_SH:
    case EM_SPARC:
    case EM_SPARC32PLUS:
    case EM_SPARCV9:
    case EM_SPU:
    case EM_TI_C6000:
    case EM_TILEGX:
    case EM_TILEPRO:
    case EM_V800:
    case EM_V850:
    case EM_CYGNUS_V850:
    case EM_VAX:
    case EM_X86_64:
    case EM_L1OM:
    case EM_K1OM:
    case EM_XSTORMY16:
    case EM_XTENSA:
    case EM_XTENSA_OLD:
    case EM_MICROBLAZE:
    case EM_MICROBLAZE_OLD:
      return TRUE;

    case EM_68HC05:
    case EM_68HC08:
    case EM_68HC11:
    case EM_68HC16:
    case EM_FX66:
    case EM_ME16:
    case EM_MMA:
    case EM_NCPU:
    case EM_NDR1:
    case EM_PCP:
    case EM_ST100:
    case EM_ST19:
    case EM_ST7:
    case EM_ST9PLUS:
    case EM_STARCORE:
    case EM_SVX:
    case EM_TINYJ:
    default:
      warn (_("Don't know about relocations on this machine architecture\n"));
      return FALSE;
    }
}

static int
slurp_rela_relocs (FILE * file,
		   unsigned long rel_offset,
		   unsigned long rel_size,
		   Elf_Internal_Rela ** relasp,
		   unsigned long * nrelasp)
{
  Elf_Internal_Rela * relas;
  unsigned long nrelas;
  unsigned int i;

  if (is_32bit_elf)
    {
      Elf32_External_Rela * erelas;

      erelas = (Elf32_External_Rela *) get_data (NULL, file, rel_offset, 1,
                                                 rel_size, _("32-bit relocation data"));
      if (!erelas)
	return 0;

      nrelas = rel_size / sizeof (Elf32_External_Rela);

      relas = (Elf_Internal_Rela *) cmalloc (nrelas,
                                             sizeof (Elf_Internal_Rela));

      if (relas == NULL)
	{
	  free (erelas);
	  error (_("out of memory parsing relocs\n"));
	  return 0;
	}

      for (i = 0; i < nrelas; i++)
	{
	  relas[i].r_offset = BYTE_GET (erelas[i].r_offset);
	  relas[i].r_info   = BYTE_GET (erelas[i].r_info);
	  relas[i].r_addend = BYTE_GET_SIGNED (erelas[i].r_addend);
	}

      free (erelas);
    }
  else
    {
      Elf64_External_Rela * erelas;

      erelas = (Elf64_External_Rela *) get_data (NULL, file, rel_offset, 1,
                                                 rel_size, _("64-bit relocation data"));
      if (!erelas)
	return 0;

      nrelas = rel_size / sizeof (Elf64_External_Rela);

      relas = (Elf_Internal_Rela *) cmalloc (nrelas,
                                             sizeof (Elf_Internal_Rela));

      if (relas == NULL)
	{
	  free (erelas);
	  error (_("out of memory parsing relocs\n"));
	  return 0;
	}

      for (i = 0; i < nrelas; i++)
	{
	  relas[i].r_offset = BYTE_GET (erelas[i].r_offset);
	  relas[i].r_info   = BYTE_GET (erelas[i].r_info);
	  relas[i].r_addend = BYTE_GET_SIGNED (erelas[i].r_addend);

	  /* The #ifdef BFD64 below is to prevent a compile time
	     warning.  We know that if we do not have a 64 bit data
	     type that we will never execute this code anyway.  */
#ifdef BFD64
	  if (elf_header.e_machine == EM_MIPS
	      && elf_header.e_ident[EI_DATA] != ELFDATA2MSB)
	    {
	      /* In little-endian objects, r_info isn't really a
		 64-bit little-endian value: it has a 32-bit
		 little-endian symbol index followed by four
		 individual byte fields.  Reorder INFO
		 accordingly.  */
	      bfd_vma inf = relas[i].r_info;
	      inf = (((inf & 0xffffffff) << 32)
		      | ((inf >> 56) & 0xff)
		      | ((inf >> 40) & 0xff00)
		      | ((inf >> 24) & 0xff0000)
		      | ((inf >> 8) & 0xff000000));
	      relas[i].r_info = inf;
	    }
#endif /* BFD64 */
	}

      free (erelas);
    }
  *relasp = relas;
  *nrelasp = nrelas;
  return 1;
}

static int
slurp_rel_relocs (FILE * file,
		  unsigned long rel_offset,
		  unsigned long rel_size,
		  Elf_Internal_Rela ** relsp,
		  unsigned long * nrelsp)
{
  Elf_Internal_Rela * rels;
  unsigned long nrels;
  unsigned int i;

  if (is_32bit_elf)
    {
      Elf32_External_Rel * erels;

      erels = (Elf32_External_Rel *) get_data (NULL, file, rel_offset, 1,
                                               rel_size, _("32-bit relocation data"));
      if (!erels)
	return 0;

      nrels = rel_size / sizeof (Elf32_External_Rel);

      rels = (Elf_Internal_Rela *) cmalloc (nrels, sizeof (Elf_Internal_Rela));

      if (rels == NULL)
	{
	  free (erels);
	  error (_("out of memory parsing relocs\n"));
	  return 0;
	}

      for (i = 0; i < nrels; i++)
	{
	  rels[i].r_offset = BYTE_GET (erels[i].r_offset);
	  rels[i].r_info   = BYTE_GET (erels[i].r_info);
	  rels[i].r_addend = 0;
	}

      free (erels);
    }
  else
    {
      Elf64_External_Rel * erels;

      erels = (Elf64_External_Rel *) get_data (NULL, file, rel_offset, 1,
                                               rel_size, _("64-bit relocation data"));
      if (!erels)
	return 0;

      nrels = rel_size / sizeof (Elf64_External_Rel);

      rels = (Elf_Internal_Rela *) cmalloc (nrels, sizeof (Elf_Internal_Rela));

      if (rels == NULL)
	{
	  free (erels);
	  error (_("out of memory parsing relocs\n"));
	  return 0;
	}

      for (i = 0; i < nrels; i++)
	{
	  rels[i].r_offset = BYTE_GET (erels[i].r_offset);
	  rels[i].r_info   = BYTE_GET (erels[i].r_info);
	  rels[i].r_addend = 0;

	  /* The #ifdef BFD64 below is to prevent a compile time
	     warning.  We know that if we do not have a 64 bit data
	     type that we will never execute this code anyway.  */
#ifdef BFD64
	  if (elf_header.e_machine == EM_MIPS
	      && elf_header.e_ident[EI_DATA] != ELFDATA2MSB)
	    {
	      /* In little-endian objects, r_info isn't really a
		 64-bit little-endian value: it has a 32-bit
		 little-endian symbol index followed by four
		 individual byte fields.  Reorder INFO
		 accordingly.  */
	      bfd_vma inf = rels[i].r_info;
	      inf = (((inf & 0xffffffff) << 32)
		     | ((inf >> 56) & 0xff)
		     | ((inf >> 40) & 0xff00)
		     | ((inf >> 24) & 0xff0000)
		     | ((inf >> 8) & 0xff000000));
	      rels[i].r_info = inf;
	    }
#endif /* BFD64 */
	}

      free (erels);
    }
  *relsp = rels;
  *nrelsp = nrels;
  return 1;
}

/* Returns the reloc type extracted from the reloc info field.  */

static unsigned int
get_reloc_type (bfd_vma reloc_info)
{
  if (is_32bit_elf)
    return ELF32_R_TYPE (reloc_info);

  switch (elf_header.e_machine)
    {
    case EM_MIPS:
      /* Note: We assume that reloc_info has already been adjusted for us.  */
      return ELF64_MIPS_R_TYPE (reloc_info);

    case EM_SPARCV9:
      return ELF64_R_TYPE_ID (reloc_info);

    default:
      return ELF64_R_TYPE (reloc_info);
    }
}

/* Return the symbol index extracted from the reloc info field.  */

static bfd_vma
get_reloc_symindex (bfd_vma reloc_info)
{
  return is_32bit_elf ? ELF32_R_SYM (reloc_info) : ELF64_R_SYM (reloc_info);
}

static inline bfd_boolean
uses_msp430x_relocs (void)
{
  return
    elf_header.e_machine == EM_MSP430 /* Paranoia.  */
    /* GCC uses osabi == ELFOSBI_STANDALONE.  */
    && (((elf_header.e_flags & EF_MSP430_MACH) == E_MSP430_MACH_MSP430X)
	/* TI compiler uses ELFOSABI_NONE.  */
	|| (elf_header.e_ident[EI_OSABI] == ELFOSABI_NONE));
}

/* Display the contents of the relocation data found at the specified
   offset.  */

static void
dump_relocations (FILE * file,
		  unsigned long rel_offset,
		  unsigned long rel_size,
		  Elf_Internal_Sym * symtab,
		  unsigned long nsyms,
		  char * strtab,
		  unsigned long strtablen,
		  int is_rela)
{
  unsigned int i;
  Elf_Internal_Rela * rels;

  if (is_rela == UNKNOWN)
    is_rela = guess_is_rela (elf_header.e_machine);

  if (is_rela)
    {
      if (!slurp_rela_relocs (file, rel_offset, rel_size, &rels, &rel_size))
	return;
    }
  else
    {
      if (!slurp_rel_relocs (file, rel_offset, rel_size, &rels, &rel_size))
	return;
    }

  if (is_32bit_elf)
    {
      if (is_rela)
	{
	  if (do_wide)
	    printf (_(" Offset     Info    Type                Sym. Value  Symbol's Name + Addend\n"));
	  else
	    printf (_(" Offset     Info    Type            Sym.Value  Sym. Name + Addend\n"));
	}
      else
	{
	  if (do_wide)
	    printf (_(" Offset     Info    Type                Sym. Value  Symbol's Name\n"));
	  else
	    printf (_(" Offset     Info    Type            Sym.Value  Sym. Name\n"));
	}
    }
  else
    {
      if (is_rela)
	{
	  if (do_wide)
	    printf (_("    Offset             Info             Type               Symbol's Value  Symbol's Name + Addend\n"));
	  else
	    printf (_("  Offset          Info           Type           Sym. Value    Sym. Name + Addend\n"));
	}
      else
	{
	  if (do_wide)
	    printf (_("    Offset             Info             Type               Symbol's Value  Symbol's Name\n"));
	  else
	    printf (_("  Offset          Info           Type           Sym. Value    Sym. Name\n"));
	}
    }

  for (i = 0; i < rel_size; i++)
    {
      const char * rtype;
      bfd_vma offset;
      bfd_vma inf;
      bfd_vma symtab_index;
      bfd_vma type;

      offset = rels[i].r_offset;
      inf    = rels[i].r_info;

      type = get_reloc_type (inf);
      symtab_index = get_reloc_symindex  (inf);

      if (is_32bit_elf)
	{
	  printf ("%8.8lx  %8.8lx ",
		  (unsigned long) offset & 0xffffffff,
		  (unsigned long) inf & 0xffffffff);
	}
      else
	{
#if BFD_HOST_64BIT_LONG
	  printf (do_wide
		  ? "%16.16lx  %16.16lx "
		  : "%12.12lx  %12.12lx ",
		  offset, inf);
#elif BFD_HOST_64BIT_LONG_LONG
#ifndef __MSVCRT__
	  printf (do_wide
		  ? "%16.16llx  %16.16llx "
		  : "%12.12llx  %12.12llx ",
		  offset, inf);
#else
	  printf (do_wide
		  ? "%16.16I64x  %16.16I64x "
		  : "%12.12I64x  %12.12I64x ",
		  offset, inf);
#endif
#else
	  printf (do_wide
		  ? "%8.8lx%8.8lx  %8.8lx%8.8lx "
		  : "%4.4lx%8.8lx  %4.4lx%8.8lx ",
		  _bfd_int64_high (offset),
		  _bfd_int64_low (offset),
		  _bfd_int64_high (inf),
		  _bfd_int64_low (inf));
#endif
	}

      switch (elf_header.e_machine)
	{
	default:
	  rtype = NULL;
	  break;

	case EM_AARCH64:
	  rtype = elf_aarch64_reloc_type (type);
	  break;

	case EM_M32R:
	case EM_CYGNUS_M32R:
	  rtype = elf_m32r_reloc_type (type);
	  break;

	case EM_386:
	case EM_486:
	  rtype = elf_i386_reloc_type (type);
	  break;

	case EM_68HC11:
	case EM_68HC12:
	  rtype = elf_m68hc11_reloc_type (type);
	  break;

	case EM_68K:
	  rtype = elf_m68k_reloc_type (type);
	  break;

	case EM_960:
	  rtype = elf_i960_reloc_type (type);
	  break;

	case EM_AVR:
	case EM_AVR_OLD:
	  rtype = elf_avr_reloc_type (type);
	  break;

	case EM_OLD_SPARCV9:
	case EM_SPARC32PLUS:
	case EM_SPARCV9:
	case EM_SPARC:
	  rtype = elf_sparc_reloc_type (type);
	  break;

	case EM_SPU:
	  rtype = elf_spu_reloc_type (type);
	  break;

	case EM_V800:
	  rtype = v800_reloc_type (type);
	  break;
	case EM_V850:
	case EM_CYGNUS_V850:
	  rtype = v850_reloc_type (type);
	  break;

	case EM_D10V:
	case EM_CYGNUS_D10V:
	  rtype = elf_d10v_reloc_type (type);
	  break;

	case EM_D30V:
	case EM_CYGNUS_D30V:
	  rtype = elf_d30v_reloc_type (type);
	  break;

	case EM_DLX:
	  rtype = elf_dlx_reloc_type (type);
	  break;

	case EM_SH:
	  rtype = elf_sh_reloc_type (type);
	  break;

	case EM_MN10300:
	case EM_CYGNUS_MN10300:
	  rtype = elf_mn10300_reloc_type (type);
	  break;

	case EM_MN10200:
	case EM_CYGNUS_MN10200:
	  rtype = elf_mn10200_reloc_type (type);
	  break;

	case EM_FR30:
	case EM_CYGNUS_FR30:
	  rtype = elf_fr30_reloc_type (type);
	  break;

	case EM_CYGNUS_FRV:
	  rtype = elf_frv_reloc_type (type);
	  break;

	case EM_MCORE:
	  rtype = elf_mcore_reloc_type (type);
	  break;

	case EM_MMIX:
	  rtype = elf_mmix_reloc_type (type);
	  break;

	case EM_MOXIE:
	  rtype = elf_moxie_reloc_type (type);
	  break;

	case EM_MSP430:
	  if (uses_msp430x_relocs ())
	    {
	      rtype = elf_msp430x_reloc_type (type);
	      break;
	    }
	case EM_MSP430_OLD:
	  rtype = elf_msp430_reloc_type (type);
	  break;

	case EM_PPC:
	  rtype = elf_ppc_reloc_type (type);
	  break;

	case EM_PPC64:
	  rtype = elf_ppc64_reloc_type (type);
	  break;

	case EM_MIPS:
	case EM_MIPS_RS3_LE:
	  rtype = elf_mips_reloc_type (type);
	  break;

	case EM_ALPHA:
	  rtype = elf_alpha_reloc_type (type);
	  break;

	case EM_ARM:
	  rtype = elf_arm_reloc_type (type);
	  break;

	case EM_ARC:
	  rtype = elf_arc_reloc_type (type);
	  break;

	case EM_PARISC:
	  rtype = elf_hppa_reloc_type (type);
	  break;

	case EM_H8_300:
	case EM_H8_300H:
	case EM_H8S:
	  rtype = elf_h8_reloc_type (type);
	  break;

	case EM_OPENRISC:
	case EM_OR32:
	  rtype = elf_or32_reloc_type (type);
	  break;

	case EM_PJ:
	case EM_PJ_OLD:
	  rtype = elf_pj_reloc_type (type);
	  break;
	case EM_IA_64:
	  rtype = elf_ia64_reloc_type (type);
	  break;

	case EM_CRIS:
	  rtype = elf_cris_reloc_type (type);
	  break;

	case EM_860:
	  rtype = elf_i860_reloc_type (type);
	  break;

	case EM_X86_64:
	case EM_L1OM:
	case EM_K1OM:
	  rtype = elf_x86_64_reloc_type (type);
	  break;

	case EM_S370:
	  rtype = i370_reloc_type (type);
	  break;

	case EM_S390_OLD:
	case EM_S390:
	  rtype = elf_s390_reloc_type (type);
	  break;

	case EM_SCORE:
	  rtype = elf_score_reloc_type (type);
	  break;

	case EM_XSTORMY16:
	  rtype = elf_xstormy16_reloc_type (type);
	  break;

	case EM_CRX:
	  rtype = elf_crx_reloc_type (type);
	  break;

	case EM_VAX:
	  rtype = elf_vax_reloc_type (type);
	  break;

	case EM_ADAPTEVA_EPIPHANY:
	  rtype = elf_epiphany_reloc_type (type);
	  break;

	case EM_IP2K:
	case EM_IP2K_OLD:
	  rtype = elf_ip2k_reloc_type (type);
	  break;

	case EM_IQ2000:
	  rtype = elf_iq2000_reloc_type (type);
	  break;

	case EM_XTENSA_OLD:
	case EM_XTENSA:
	  rtype = elf_xtensa_reloc_type (type);
	  break;

	case EM_LATTICEMICO32:
	  rtype = elf_lm32_reloc_type (type);
	  break;

	case EM_M32C_OLD:
	case EM_M32C:
	  rtype = elf_m32c_reloc_type (type);
	  break;

	case EM_MT:
	  rtype = elf_mt_reloc_type (type);
	  break;

	case EM_BLACKFIN:
	  rtype = elf_bfin_reloc_type (type);
	  break;

	case EM_CYGNUS_MEP:
	  rtype = elf_mep_reloc_type (type);
	  break;

	case EM_CR16:
	  rtype = elf_cr16_reloc_type (type);
	  break;

	case EM_MICROBLAZE:
	case EM_MICROBLAZE_OLD:
	  rtype = elf_microblaze_reloc_type (type);
	  break;

	case EM_RL78:
	  rtype = elf_rl78_reloc_type (type);
	  break;

	case EM_RX:
	  rtype = elf_rx_reloc_type (type);
	  break;

	case EM_METAG:
	  rtype = elf_metag_reloc_type (type);
	  break;

	case EM_XC16X:
	case EM_C166:
	  rtype = elf_xc16x_reloc_type (type);
	  break;

	case EM_TI_C6000:
	  rtype = elf_tic6x_reloc_type (type);
	  break;

	case EM_TILEGX:
	  rtype = elf_tilegx_reloc_type (type);
	  break;

	case EM_TILEPRO:
	  rtype = elf_tilepro_reloc_type (type);
	  break;

	case EM_XGATE:
	  rtype = elf_xgate_reloc_type (type);
	  break;

	case EM_ALTERA_NIOS2:
	  rtype = elf_nios2_reloc_type (type);
	  break;
	}

      if (rtype == NULL)
	printf (_("unrecognized: %-7lx"), (unsigned long) type & 0xffffffff);
      else
	printf (do_wide ? "%-22.22s" : "%-17.17s", rtype);

      if (elf_header.e_machine == EM_ALPHA
	  && rtype != NULL
	  && streq (rtype, "R_ALPHA_LITUSE")
	  && is_rela)
	{
	  switch (rels[i].r_addend)
	    {
	    case LITUSE_ALPHA_ADDR:   rtype = "ADDR";   break;
	    case LITUSE_ALPHA_BASE:   rtype = "BASE";   break;
	    case LITUSE_ALPHA_BYTOFF: rtype = "BYTOFF"; break;
	    case LITUSE_ALPHA_JSR:    rtype = "JSR";    break;
	    case LITUSE_ALPHA_TLSGD:  rtype = "TLSGD";  break;
	    case LITUSE_ALPHA_TLSLDM: rtype = "TLSLDM"; break;
	    case LITUSE_ALPHA_JSRDIRECT: rtype = "JSRDIRECT"; break;
	    default: rtype = NULL;
	    }
	  if (rtype)
	    printf (" (%s)", rtype);
	  else
	    {
	      putchar (' ');
	      printf (_("<unknown addend: %lx>"),
		      (unsigned long) rels[i].r_addend);
	    }
	}
      else if (symtab_index)
	{
	  if (symtab == NULL || symtab_index >= nsyms)
	    printf (_(" bad symbol index: %08lx"), (unsigned long) symtab_index);
	  else
	    {
	      Elf_Internal_Sym * psym;

	      psym = symtab + symtab_index;

	      printf (" ");

	      if (ELF_ST_TYPE (psym->st_info) == STT_GNU_IFUNC)
		{
		  const char * name;
		  unsigned int len;
		  unsigned int width = is_32bit_elf ? 8 : 14;

		  /* Relocations against GNU_IFUNC symbols do not use the value
		     of the symbol as the address to relocate against.  Instead
		     they invoke the function named by the symbol and use its
		     result as the address for relocation.

		     To indicate this to the user, do not display the value of
		     the symbol in the "Symbols's Value" field.  Instead show
		     its name followed by () as a hint that the symbol is
		     invoked.  */

		  if (strtab == NULL
		      || psym->st_name == 0
		      || psym->st_name >= strtablen)
		    name = "??";
		  else
		    name = strtab + psym->st_name;

		  len = print_symbol (width, name);
		  printf ("()%-*s", len <= width ? (width + 1) - len : 1, " ");
		}
	      else
		{
		  print_vma (psym->st_value, LONG_HEX);

		  printf (is_32bit_elf ? "   " : " ");
		}

	      if (psym->st_name == 0)
		{
		  const char * sec_name = "<null>";
		  char name_buf[40];

		  if (ELF_ST_TYPE (psym->st_info) == STT_SECTION)
		    {
		      if (psym->st_shndx < elf_header.e_shnum)
			sec_name
			  = SECTION_NAME (section_headers + psym->st_shndx);
		      else if (psym->st_shndx == SHN_ABS)
			sec_name = "ABS";
		      else if (psym->st_shndx == SHN_COMMON)
			sec_name = "COMMON";
		      else if ((elf_header.e_machine == EM_MIPS
				&& psym->st_shndx == SHN_MIPS_SCOMMON)
			       || (elf_header.e_machine == EM_TI_C6000
				   && psym->st_shndx == SHN_TIC6X_SCOMMON))
			sec_name = "SCOMMON";
		      else if (elf_header.e_machine == EM_MIPS
			       && psym->st_shndx == SHN_MIPS_SUNDEFINED)
			sec_name = "SUNDEF";
		      else if ((elf_header.e_machine == EM_X86_64
				|| elf_header.e_machine == EM_L1OM
				|| elf_header.e_machine == EM_K1OM)
			       && psym->st_shndx == SHN_X86_64_LCOMMON)
			sec_name = "LARGE_COMMON";
		      else if (elf_header.e_machine == EM_IA_64
			       && elf_header.e_ident[EI_OSABI] == ELFOSABI_HPUX
			       && psym->st_shndx == SHN_IA_64_ANSI_COMMON)
			sec_name = "ANSI_COM";
		      else if (is_ia64_vms ()
			       && psym->st_shndx == SHN_IA_64_VMS_SYMVEC)
			sec_name = "VMS_SYMVEC";
		      else
			{
			  sprintf (name_buf, "<section 0x%x>",
				   (unsigned int) psym->st_shndx);
			  sec_name = name_buf;
			}
		    }
		  print_symbol (22, sec_name);
		}
	      else if (strtab == NULL)
		printf (_("<string table index: %3ld>"), psym->st_name);
	      else if (psym->st_name >= strtablen)
		printf (_("<corrupt string table index: %3ld>"), psym->st_name);
	      else
		print_symbol (22, strtab + psym->st_name);

	      if (is_rela)
		{
		  bfd_signed_vma off = rels[i].r_addend;

		  if (off < 0)
		    printf (" - %" BFD_VMA_FMT "x", - off);
		  else
		    printf (" + %" BFD_VMA_FMT "x", off);
		}
	    }
	}
      else if (is_rela)
	{
	  bfd_signed_vma off = rels[i].r_addend;

	  printf ("%*c", is_32bit_elf ? 12 : 20, ' ');
	  if (off < 0)
	    printf ("-%" BFD_VMA_FMT "x", - off);
	  else
	    printf ("%" BFD_VMA_FMT "x", off);
	}

      if (elf_header.e_machine == EM_SPARCV9
	  && rtype != NULL
	  && streq (rtype, "R_SPARC_OLO10"))
	printf (" + %lx", (unsigned long) ELF64_R_TYPE_DATA (inf));

      putchar ('\n');

#ifdef BFD64
      if (! is_32bit_elf && elf_header.e_machine == EM_MIPS)
	{
	  bfd_vma type2 = ELF64_MIPS_R_TYPE2 (inf);
	  bfd_vma type3 = ELF64_MIPS_R_TYPE3 (inf);
	  const char * rtype2 = elf_mips_reloc_type (type2);
	  const char * rtype3 = elf_mips_reloc_type (type3);

	  printf ("                    Type2: ");

	  if (rtype2 == NULL)
	    printf (_("unrecognized: %-7lx"),
		    (unsigned long) type2 & 0xffffffff);
	  else
	    printf ("%-17.17s", rtype2);

	  printf ("\n                    Type3: ");

	  if (rtype3 == NULL)
	    printf (_("unrecognized: %-7lx"),
		    (unsigned long) type3 & 0xffffffff);
	  else
	    printf ("%-17.17s", rtype3);

	  putchar ('\n');
	}
#endif /* BFD64 */
    }

  free (rels);
}

static const char *
get_mips_dynamic_type (unsigned long type)
{
  switch (type)
    {
    case DT_MIPS_RLD_VERSION: return "MIPS_RLD_VERSION";
    case DT_MIPS_TIME_STAMP: return "MIPS_TIME_STAMP";
    case DT_MIPS_ICHECKSUM: return "MIPS_ICHECKSUM";
    case DT_MIPS_IVERSION: return "MIPS_IVERSION";
    case DT_MIPS_FLAGS: return "MIPS_FLAGS";
    case DT_MIPS_BASE_ADDRESS: return "MIPS_BASE_ADDRESS";
    case DT_MIPS_MSYM: return "MIPS_MSYM";
    case DT_MIPS_CONFLICT: return "MIPS_CONFLICT";
    case DT_MIPS_LIBLIST: return "MIPS_LIBLIST";
    case DT_MIPS_LOCAL_GOTNO: return "MIPS_LOCAL_GOTNO";
    case DT_MIPS_CONFLICTNO: return "MIPS_CONFLICTNO";
    case DT_MIPS_LIBLISTNO: return "MIPS_LIBLISTNO";
    case DT_MIPS_SYMTABNO: return "MIPS_SYMTABNO";
    case DT_MIPS_UNREFEXTNO: return "MIPS_UNREFEXTNO";
    case DT_MIPS_GOTSYM: return "MIPS_GOTSYM";
    case DT_MIPS_HIPAGENO: return "MIPS_HIPAGENO";
    case DT_MIPS_RLD_MAP: return "MIPS_RLD_MAP";
    case DT_MIPS_DELTA_CLASS: return "MIPS_DELTA_CLASS";
    case DT_MIPS_DELTA_CLASS_NO: return "MIPS_DELTA_CLASS_NO";
    case DT_MIPS_DELTA_INSTANCE: return "MIPS_DELTA_INSTANCE";
    case DT_MIPS_DELTA_INSTANCE_NO: return "MIPS_DELTA_INSTANCE_NO";
    case DT_MIPS_DELTA_RELOC: return "MIPS_DELTA_RELOC";
    case DT_MIPS_DELTA_RELOC_NO: return "MIPS_DELTA_RELOC_NO";
    case DT_MIPS_DELTA_SYM: return "MIPS_DELTA_SYM";
    case DT_MIPS_DELTA_SYM_NO: return "MIPS_DELTA_SYM_NO";
    case DT_MIPS_DELTA_CLASSSYM: return "MIPS_DELTA_CLASSSYM";
    case DT_MIPS_DELTA_CLASSSYM_NO: return "MIPS_DELTA_CLASSSYM_NO";
    case DT_MIPS_CXX_FLAGS: return "MIPS_CXX_FLAGS";
    case DT_MIPS_PIXIE_INIT: return "MIPS_PIXIE_INIT";
    case DT_MIPS_SYMBOL_LIB: return "MIPS_SYMBOL_LIB";
    case DT_MIPS_LOCALPAGE_GOTIDX: return "MIPS_LOCALPAGE_GOTIDX";
    case DT_MIPS_LOCAL_GOTIDX: return "MIPS_LOCAL_GOTIDX";
    case DT_MIPS_HIDDEN_GOTIDX: return "MIPS_HIDDEN_GOTIDX";
    case DT_MIPS_PROTECTED_GOTIDX: return "MIPS_PROTECTED_GOTIDX";
    case DT_MIPS_OPTIONS: return "MIPS_OPTIONS";
    case DT_MIPS_INTERFACE: return "MIPS_INTERFACE";
    case DT_MIPS_DYNSTR_ALIGN: return "MIPS_DYNSTR_ALIGN";
    case DT_MIPS_INTERFACE_SIZE: return "MIPS_INTERFACE_SIZE";
    case DT_MIPS_RLD_TEXT_RESOLVE_ADDR: return "MIPS_RLD_TEXT_RESOLVE_ADDR";
    case DT_MIPS_PERF_SUFFIX: return "MIPS_PERF_SUFFIX";
    case DT_MIPS_COMPACT_SIZE: return "MIPS_COMPACT_SIZE";
    case DT_MIPS_GP_VALUE: return "MIPS_GP_VALUE";
    case DT_MIPS_AUX_DYNAMIC: return "MIPS_AUX_DYNAMIC";
    case DT_MIPS_PLTGOT: return "MIPS_PLTGOT";
    case DT_MIPS_RWPLT: return "MIPS_RWPLT";
    default:
      return NULL;
    }
}

static const char *
get_sparc64_dynamic_type (unsigned long type)
{
  switch (type)
    {
    case DT_SPARC_REGISTER: return "SPARC_REGISTER";
    default:
      return NULL;
    }
}

static const char *
get_ppc_dynamic_type (unsigned long type)
{
  switch (type)
    {
    case DT_PPC_GOT:    return "PPC_GOT";
    case DT_PPC_TLSOPT: return "PPC_TLSOPT";
    default:
      return NULL;
    }
}

static const char *
get_ppc64_dynamic_type (unsigned long type)
{
  switch (type)
    {
    case DT_PPC64_GLINK:  return "PPC64_GLINK";
    case DT_PPC64_OPD:    return "PPC64_OPD";
    case DT_PPC64_OPDSZ:  return "PPC64_OPDSZ";
    case DT_PPC64_TLSOPT: return "PPC64_TLSOPT";
    default:
      return NULL;
    }
}

static const char *
get_parisc_dynamic_type (unsigned long type)
{
  switch (type)
    {
    case DT_HP_LOAD_MAP:	return "HP_LOAD_MAP";
    case DT_HP_DLD_FLAGS:	return "HP_DLD_FLAGS";
    case DT_HP_DLD_HOOK:	return "HP_DLD_HOOK";
    case DT_HP_UX10_INIT:	return "HP_UX10_INIT";
    case DT_HP_UX10_INITSZ:	return "HP_UX10_INITSZ";
    case DT_HP_PREINIT:		return "HP_PREINIT";
    case DT_HP_PREINITSZ:	return "HP_PREINITSZ";
    case DT_HP_NEEDED:		return "HP_NEEDED";
    case DT_HP_TIME_STAMP:	return "HP_TIME_STAMP";
    case DT_HP_CHECKSUM:	return "HP_CHECKSUM";
    case DT_HP_GST_SIZE:	return "HP_GST_SIZE";
    case DT_HP_GST_VERSION:	return "HP_GST_VERSION";
    case DT_HP_GST_HASHVAL:	return "HP_GST_HASHVAL";
    case DT_HP_EPLTREL:		return "HP_GST_EPLTREL";
    case DT_HP_EPLTRELSZ:	return "HP_GST_EPLTRELSZ";
    case DT_HP_FILTERED:	return "HP_FILTERED";
    case DT_HP_FILTER_TLS:	return "HP_FILTER_TLS";
    case DT_HP_COMPAT_FILTERED:	return "HP_COMPAT_FILTERED";
    case DT_HP_LAZYLOAD:	return "HP_LAZYLOAD";
    case DT_HP_BIND_NOW_COUNT:	return "HP_BIND_NOW_COUNT";
    case DT_PLT:		return "PLT";
    case DT_PLT_SIZE:		return "PLT_SIZE";
    case DT_DLT:		return "DLT";
    case DT_DLT_SIZE:		return "DLT_SIZE";
    default:
      return NULL;
    }
}

static const char *
get_ia64_dynamic_type (unsigned long type)
{
  switch (type)
    {
    case DT_IA_64_PLT_RESERVE:         return "IA_64_PLT_RESERVE";
    case DT_IA_64_VMS_SUBTYPE:         return "VMS_SUBTYPE";
    case DT_IA_64_VMS_IMGIOCNT:        return "VMS_IMGIOCNT";
    case DT_IA_64_VMS_LNKFLAGS:        return "VMS_LNKFLAGS";
    case DT_IA_64_VMS_VIR_MEM_BLK_SIZ: return "VMS_VIR_MEM_BLK_SIZ";
    case DT_IA_64_VMS_IDENT:           return "VMS_IDENT";
    case DT_IA_64_VMS_NEEDED_IDENT:    return "VMS_NEEDED_IDENT";
    case DT_IA_64_VMS_IMG_RELA_CNT:    return "VMS_IMG_RELA_CNT";
    case DT_IA_64_VMS_SEG_RELA_CNT:    return "VMS_SEG_RELA_CNT";
    case DT_IA_64_VMS_FIXUP_RELA_CNT:  return "VMS_FIXUP_RELA_CNT";
    case DT_IA_64_VMS_FIXUP_NEEDED:    return "VMS_FIXUP_NEEDED";
    case DT_IA_64_VMS_SYMVEC_CNT:      return "VMS_SYMVEC_CNT";
    case DT_IA_64_VMS_XLATED:          return "VMS_XLATED";
    case DT_IA_64_VMS_STACKSIZE:       return "VMS_STACKSIZE";
    case DT_IA_64_VMS_UNWINDSZ:        return "VMS_UNWINDSZ";
    case DT_IA_64_VMS_UNWIND_CODSEG:   return "VMS_UNWIND_CODSEG";
    case DT_IA_64_VMS_UNWIND_INFOSEG:  return "VMS_UNWIND_INFOSEG";
    case DT_IA_64_VMS_LINKTIME:        return "VMS_LINKTIME";
    case DT_IA_64_VMS_SEG_NO:          return "VMS_SEG_NO";
    case DT_IA_64_VMS_SYMVEC_OFFSET:   return "VMS_SYMVEC_OFFSET";
    case DT_IA_64_VMS_SYMVEC_SEG:      return "VMS_SYMVEC_SEG";
    case DT_IA_64_VMS_UNWIND_OFFSET:   return "VMS_UNWIND_OFFSET";
    case DT_IA_64_VMS_UNWIND_SEG:      return "VMS_UNWIND_SEG";
    case DT_IA_64_VMS_STRTAB_OFFSET:   return "VMS_STRTAB_OFFSET";
    case DT_IA_64_VMS_SYSVER_OFFSET:   return "VMS_SYSVER_OFFSET";
    case DT_IA_64_VMS_IMG_RELA_OFF:    return "VMS_IMG_RELA_OFF";
    case DT_IA_64_VMS_SEG_RELA_OFF:    return "VMS_SEG_RELA_OFF";
    case DT_IA_64_VMS_FIXUP_RELA_OFF:  return "VMS_FIXUP_RELA_OFF";
    case DT_IA_64_VMS_PLTGOT_OFFSET:   return "VMS_PLTGOT_OFFSET";
    case DT_IA_64_VMS_PLTGOT_SEG:      return "VMS_PLTGOT_SEG";
    case DT_IA_64_VMS_FPMODE:          return "VMS_FPMODE";
    default:
      return NULL;
    }
}

static const char *
get_alpha_dynamic_type (unsigned long type)
{
  switch (type)
    {
    case DT_ALPHA_PLTRO: return "ALPHA_PLTRO";
    default:
      return NULL;
    }
}

static const char *
get_score_dynamic_type (unsigned long type)
{
  switch (type)
    {
    case DT_SCORE_BASE_ADDRESS: return "SCORE_BASE_ADDRESS";
    case DT_SCORE_LOCAL_GOTNO:  return "SCORE_LOCAL_GOTNO";
    case DT_SCORE_SYMTABNO:     return "SCORE_SYMTABNO";
    case DT_SCORE_GOTSYM:       return "SCORE_GOTSYM";
    case DT_SCORE_UNREFEXTNO:   return "SCORE_UNREFEXTNO";
    case DT_SCORE_HIPAGENO:     return "SCORE_HIPAGENO";
    default:
      return NULL;
    }
}

static const char *
get_tic6x_dynamic_type (unsigned long type)
{
  switch (type)
    {
    case DT_C6000_GSYM_OFFSET: return "C6000_GSYM_OFFSET";
    case DT_C6000_GSTR_OFFSET: return "C6000_GSTR_OFFSET";
    case DT_C6000_DSBT_BASE:   return "C6000_DSBT_BASE";
    case DT_C6000_DSBT_SIZE:   return "C6000_DSBT_SIZE";
    case DT_C6000_PREEMPTMAP:  return "C6000_PREEMPTMAP";
    case DT_C6000_DSBT_INDEX:  return "C6000_DSBT_INDEX";
    default:
      return NULL;
    }
}

static const char *
get_nios2_dynamic_type (unsigned long type)
{
  switch (type)
    {
    case DT_NIOS2_GP: return "NIOS2_GP";
    default:
      return NULL;
    }
}

static const char *
get_dynamic_type (unsigned long type)
{
  static char buff[64];

  switch (type)
    {
    case DT_NULL:	return "NULL";
    case DT_NEEDED:	return "NEEDED";
    case DT_PLTRELSZ:	return "PLTRELSZ";
    case DT_PLTGOT:	return "PLTGOT";
    case DT_HASH:	return "HASH";
    case DT_STRTAB:	return "STRTAB";
    case DT_SYMTAB:	return "SYMTAB";
    case DT_RELA:	return "RELA";
    case DT_RELASZ:	return "RELASZ";
    case DT_RELAENT:	return "RELAENT";
    case DT_STRSZ:	return "STRSZ";
    case DT_SYMENT:	return "SYMENT";
    case DT_INIT:	return "INIT";
    case DT_FINI:	return "FINI";
    case DT_SONAME:	return "SONAME";
    case DT_RPATH:	return "RPATH";
    case DT_SYMBOLIC:	return "SYMBOLIC";
    case DT_REL:	return "REL";
    case DT_RELSZ:	return "RELSZ";
    case DT_RELENT:	return "RELENT";
    case DT_PLTREL:	return "PLTREL";
    case DT_DEBUG:	return "DEBUG";
    case DT_TEXTREL:	return "TEXTREL";
    case DT_JMPREL:	return "JMPREL";
    case DT_BIND_NOW:   return "BIND_NOW";
    case DT_INIT_ARRAY: return "INIT_ARRAY";
    case DT_FINI_ARRAY: return "FINI_ARRAY";
    case DT_INIT_ARRAYSZ: return "INIT_ARRAYSZ";
    case DT_FINI_ARRAYSZ: return "FINI_ARRAYSZ";
    case DT_RUNPATH:    return "RUNPATH";
    case DT_FLAGS:      return "FLAGS";

    case DT_PREINIT_ARRAY: return "PREINIT_ARRAY";
    case DT_PREINIT_ARRAYSZ: return "PREINIT_ARRAYSZ";

    case DT_CHECKSUM:	return "CHECKSUM";
    case DT_PLTPADSZ:	return "PLTPADSZ";
    case DT_MOVEENT:	return "MOVEENT";
    case DT_MOVESZ:	return "MOVESZ";
    case DT_FEATURE:	return "FEATURE";
    case DT_POSFLAG_1:	return "POSFLAG_1";
    case DT_SYMINSZ:	return "SYMINSZ";
    case DT_SYMINENT:	return "SYMINENT"; /* aka VALRNGHI */

    case DT_ADDRRNGLO:  return "ADDRRNGLO";
    case DT_CONFIG:	return "CONFIG";
    case DT_DEPAUDIT:	return "DEPAUDIT";
    case DT_AUDIT:	return "AUDIT";
    case DT_PLTPAD:	return "PLTPAD";
    case DT_MOVETAB:	return "MOVETAB";
    case DT_SYMINFO:	return "SYMINFO"; /* aka ADDRRNGHI */

    case DT_VERSYM:	return "VERSYM";

    case DT_TLSDESC_GOT: return "TLSDESC_GOT";
    case DT_TLSDESC_PLT: return "TLSDESC_PLT";
    case DT_RELACOUNT:	return "RELACOUNT";
    case DT_RELCOUNT:	return "RELCOUNT";
    case DT_FLAGS_1:	return "FLAGS_1";
    case DT_VERDEF:	return "VERDEF";
    case DT_VERDEFNUM:	return "VERDEFNUM";
    case DT_VERNEED:	return "VERNEED";
    case DT_VERNEEDNUM:	return "VERNEEDNUM";

    case DT_AUXILIARY:	return "AUXILIARY";
    case DT_USED:	return "USED";
    case DT_FILTER:	return "FILTER";

    case DT_GNU_PRELINKED: return "GNU_PRELINKED";
    case DT_GNU_CONFLICT: return "GNU_CONFLICT";
    case DT_GNU_CONFLICTSZ: return "GNU_CONFLICTSZ";
    case DT_GNU_LIBLIST: return "GNU_LIBLIST";
    case DT_GNU_LIBLISTSZ: return "GNU_LIBLISTSZ";
    case DT_GNU_HASH:	return "GNU_HASH";

    default:
      if ((type >= DT_LOPROC) && (type <= DT_HIPROC))
	{
	  const char * result;

	  switch (elf_header.e_machine)
	    {
	    case EM_MIPS:
	    case EM_MIPS_RS3_LE:
	      result = get_mips_dynamic_type (type);
	      break;
	    case EM_SPARCV9:
	      result = get_sparc64_dynamic_type (type);
	      break;
	    case EM_PPC:
	      result = get_ppc_dynamic_type (type);
	      break;
	    case EM_PPC64:
	      result = get_ppc64_dynamic_type (type);
	      break;
	    case EM_IA_64:
	      result = get_ia64_dynamic_type (type);
	      break;
	    case EM_ALPHA:
	      result = get_alpha_dynamic_type (type);
	      break;
	    case EM_SCORE:
	      result = get_score_dynamic_type (type);
	      break;
	    case EM_TI_C6000:
	      result = get_tic6x_dynamic_type (type);
	      break;
	    case EM_ALTERA_NIOS2:
	      result = get_nios2_dynamic_type (type);
	      break;
	    default:
	      result = NULL;
	      break;
	    }

	  if (result != NULL)
	    return result;

	  snprintf (buff, sizeof (buff), _("Processor Specific: %lx"), type);
	}
      else if (((type >= DT_LOOS) && (type <= DT_HIOS))
	       || (elf_header.e_machine == EM_PARISC
		   && (type >= OLD_DT_LOOS) && (type <= OLD_DT_HIOS)))
	{
	  const char * result;

	  switch (elf_header.e_machine)
	    {
	    case EM_PARISC:
	      result = get_parisc_dynamic_type (type);
	      break;
	    case EM_IA_64:
	      result = get_ia64_dynamic_type (type);
	      break;
	    default:
	      result = NULL;
	      break;
	    }

	  if (result != NULL)
	    return result;

	  snprintf (buff, sizeof (buff), _("Operating System specific: %lx"),
		    type);
	}
      else
	snprintf (buff, sizeof (buff), _("<unknown>: %lx"), type);

      return buff;
    }
}

static char *
get_file_type (unsigned e_type)
{
  static char buff[32];

  switch (e_type)
    {
    case ET_NONE:	return _("NONE (None)");
    case ET_REL:	return _("REL (Relocatable file)");
    case ET_EXEC:	return _("EXEC (Executable file)");
    case ET_DYN:	return _("DYN (Shared object file)");
    case ET_CORE:	return _("CORE (Core file)");

    default:
      if ((e_type >= ET_LOPROC) && (e_type <= ET_HIPROC))
	snprintf (buff, sizeof (buff), _("Processor Specific: (%x)"), e_type);
      else if ((e_type >= ET_LOOS) && (e_type <= ET_HIOS))
	snprintf (buff, sizeof (buff), _("OS Specific: (%x)"), e_type);
      else
	snprintf (buff, sizeof (buff), _("<unknown>: %x"), e_type);
      return buff;
    }
}

static char *
get_machine_name (unsigned e_machine)
{
  static char buff[64]; /* XXX */

  switch (e_machine)
    {
    case EM_NONE:		return _("None");
    case EM_AARCH64:		return "AArch64";
    case EM_M32:		return "WE32100";
    case EM_SPARC:		return "Sparc";
    case EM_SPU:		return "SPU";
    case EM_386:		return "Intel 80386";
    case EM_68K:		return "MC68000";
    case EM_88K:		return "MC88000";
    case EM_486:		return "Intel 80486";
    case EM_860:		return "Intel 80860";
    case EM_MIPS:		return "MIPS R3000";
    case EM_S370:		return "IBM System/370";
    case EM_MIPS_RS3_LE:	return "MIPS R4000 big-endian";
    case EM_OLD_SPARCV9:	return "Sparc v9 (old)";
    case EM_PARISC:		return "HPPA";
    case EM_PPC_OLD:		return "Power PC (old)";
    case EM_SPARC32PLUS:	return "Sparc v8+" ;
    case EM_960:		return "Intel 90860";
    case EM_PPC:		return "PowerPC";
    case EM_PPC64:		return "PowerPC64";
    case EM_FR20:		return "Fujitsu FR20";
    case EM_RH32:		return "TRW RH32";
    case EM_MCORE:		return "MCORE";
    case EM_ARM:		return "ARM";
    case EM_OLD_ALPHA:		return "Digital Alpha (old)";
    case EM_SH:			return "Renesas / SuperH SH";
    case EM_SPARCV9:		return "Sparc v9";
    case EM_TRICORE:		return "Siemens Tricore";
    case EM_ARC:		return "ARC";
    case EM_H8_300:		return "Renesas H8/300";
    case EM_H8_300H:		return "Renesas H8/300H";
    case EM_H8S:		return "Renesas H8S";
    case EM_H8_500:		return "Renesas H8/500";
    case EM_IA_64:		return "Intel IA-64";
    case EM_MIPS_X:		return "Stanford MIPS-X";
    case EM_COLDFIRE:		return "Motorola Coldfire";
    case EM_ALPHA:		return "Alpha";
    case EM_CYGNUS_D10V:
    case EM_D10V:		return "d10v";
    case EM_CYGNUS_D30V:
    case EM_D30V:		return "d30v";
    case EM_CYGNUS_M32R:
    case EM_M32R:		return "Renesas M32R (formerly Mitsubishi M32r)";
    case EM_CYGNUS_V850:
    case EM_V800:		return "Renesas V850 (using RH850 ABI)";
    case EM_V850:		return "Renesas V850";
    case EM_CYGNUS_MN10300:
    case EM_MN10300:		return "mn10300";
    case EM_CYGNUS_MN10200:
    case EM_MN10200:		return "mn10200";
    case EM_MOXIE:		return "Moxie";
    case EM_CYGNUS_FR30:
    case EM_FR30:		return "Fujitsu FR30";
    case EM_CYGNUS_FRV:		return "Fujitsu FR-V";
    case EM_PJ_OLD:
    case EM_PJ:			return "picoJava";
    case EM_MMA:		return "Fujitsu Multimedia Accelerator";
    case EM_PCP:		return "Siemens PCP";
    case EM_NCPU:		return "Sony nCPU embedded RISC processor";
    case EM_NDR1:		return "Denso NDR1 microprocesspr";
    case EM_STARCORE:		return "Motorola Star*Core processor";
    case EM_ME16:		return "Toyota ME16 processor";
    case EM_ST100:		return "STMicroelectronics ST100 processor";
    case EM_TINYJ:		return "Advanced Logic Corp. TinyJ embedded processor";
    case EM_PDSP:		return "Sony DSP processor";
    case EM_PDP10:		return "Digital Equipment Corp. PDP-10";
    case EM_PDP11:		return "Digital Equipment Corp. PDP-11";
    case EM_FX66:		return "Siemens FX66 microcontroller";
    case EM_ST9PLUS:		return "STMicroelectronics ST9+ 8/16 bit microcontroller";
    case EM_ST7:		return "STMicroelectronics ST7 8-bit microcontroller";
    case EM_68HC16:		return "Motorola MC68HC16 Microcontroller";
    case EM_68HC12:		return "Motorola MC68HC12 Microcontroller";
    case EM_68HC11:		return "Motorola MC68HC11 Microcontroller";
    case EM_68HC08:		return "Motorola MC68HC08 Microcontroller";
    case EM_68HC05:		return "Motorola MC68HC05 Microcontroller";
    case EM_SVX:		return "Silicon Graphics SVx";
    case EM_ST19:		return "STMicroelectronics ST19 8-bit microcontroller";
    case EM_VAX:		return "Digital VAX";
    case EM_AVR_OLD:
    case EM_AVR:		return "Atmel AVR 8-bit microcontroller";
    case EM_CRIS:		return "Axis Communications 32-bit embedded processor";
    case EM_JAVELIN:		return "Infineon Technologies 32-bit embedded cpu";
    case EM_FIREPATH:		return "Element 14 64-bit DSP processor";
    case EM_ZSP:		return "LSI Logic's 16-bit DSP processor";
    case EM_MMIX:		return "Donald Knuth's educational 64-bit processor";
    case EM_HUANY:		return "Harvard Universitys's machine-independent object format";
    case EM_PRISM:		return "Vitesse Prism";
    case EM_X86_64:		return "Advanced Micro Devices X86-64";
    case EM_L1OM:		return "Intel L1OM";
    case EM_K1OM:		return "Intel K1OM";
    case EM_S390_OLD:
    case EM_S390:		return "IBM S/390";
    case EM_SCORE:		return "SUNPLUS S+Core";
    case EM_XSTORMY16:		return "Sanyo XStormy16 CPU core";
    case EM_OPENRISC:
    case EM_OR32:		return "OpenRISC";
    case EM_ARC_A5:		return "ARC International ARCompact processor";
    case EM_CRX:		return "National Semiconductor CRX microprocessor";
    case EM_ADAPTEVA_EPIPHANY:	return "Adapteva EPIPHANY";
    case EM_DLX:		return "OpenDLX";
    case EM_IP2K_OLD:
    case EM_IP2K:		return "Ubicom IP2xxx 8-bit microcontrollers";
    case EM_IQ2000:       	return "Vitesse IQ2000";
    case EM_XTENSA_OLD:
    case EM_XTENSA:		return "Tensilica Xtensa Processor";
    case EM_VIDEOCORE:		return "Alphamosaic VideoCore processor";
    case EM_TMM_GPP:		return "Thompson Multimedia General Purpose Processor";
    case EM_NS32K:		return "National Semiconductor 32000 series";
    case EM_TPC:		return "Tenor Network TPC processor";
    case EM_ST200:		return "STMicroelectronics ST200 microcontroller";
    case EM_MAX:		return "MAX Processor";
    case EM_CR:			return "National Semiconductor CompactRISC";
    case EM_F2MC16:		return "Fujitsu F2MC16";
    case EM_MSP430:		return "Texas Instruments msp430 microcontroller";
    case EM_LATTICEMICO32:	return "Lattice Mico32";
    case EM_M32C_OLD:
    case EM_M32C:	        return "Renesas M32c";
    case EM_MT:                 return "Morpho Techologies MT processor";
    case EM_BLACKFIN:		return "Analog Devices Blackfin";
    case EM_SE_C33:		return "S1C33 Family of Seiko Epson processors";
    case EM_SEP:		return "Sharp embedded microprocessor";
    case EM_ARCA:		return "Arca RISC microprocessor";
    case EM_UNICORE:		return "Unicore";
    case EM_EXCESS:		return "eXcess 16/32/64-bit configurable embedded CPU";
    case EM_DXP:		return "Icera Semiconductor Inc. Deep Execution Processor";
    case EM_NIOS32:		return "Altera Nios";
    case EM_ALTERA_NIOS2:	return "Altera Nios II";
    case EM_C166:
    case EM_XC16X:		return "Infineon Technologies xc16x";
    case EM_M16C:		return "Renesas M16C series microprocessors";
    case EM_DSPIC30F:		return "Microchip Technology dsPIC30F Digital Signal Controller";
    case EM_CE:			return "Freescale Communication Engine RISC core";
    case EM_TSK3000:		return "Altium TSK3000 core";
    case EM_RS08:		return "Freescale RS08 embedded processor";
    case EM_ECOG2:		return "Cyan Technology eCOG2 microprocessor";
    case EM_DSP24:		return "New Japan Radio (NJR) 24-bit DSP Processor";
    case EM_VIDEOCORE3:		return "Broadcom VideoCore III processor";
    case EM_SE_C17:		return "Seiko Epson C17 family";
    case EM_TI_C6000:		return "Texas Instruments TMS320C6000 DSP family";
    case EM_TI_C2000:		return "Texas Instruments TMS320C2000 DSP family";
    case EM_TI_C5500:		return "Texas Instruments TMS320C55x DSP family";
    case EM_MMDSP_PLUS:		return "STMicroelectronics 64bit VLIW Data Signal Processor";
    case EM_CYPRESS_M8C:	return "Cypress M8C microprocessor";
    case EM_R32C:		return "Renesas R32C series microprocessors";
    case EM_TRIMEDIA:		return "NXP Semiconductors TriMedia architecture family";
    case EM_QDSP6:		return "QUALCOMM DSP6 Processor";
    case EM_8051:		return "Intel 8051 and variants";
    case EM_STXP7X:		return "STMicroelectronics STxP7x family";
    case EM_NDS32:		return "Andes Technology compact code size embedded RISC processor family";
    case EM_ECOG1X:		return "Cyan Technology eCOG1X family";
    case EM_MAXQ30:		return "Dallas Semiconductor MAXQ30 Core microcontrollers";
    case EM_XIMO16:		return "New Japan Radio (NJR) 16-bit DSP Processor";
    case EM_MANIK:		return "M2000 Reconfigurable RISC Microprocessor";
    case EM_CRAYNV2:		return "Cray Inc. NV2 vector architecture";
    case EM_CYGNUS_MEP:         return "Toshiba MeP Media Engine";
    case EM_CR16:
    case EM_MICROBLAZE:
    case EM_MICROBLAZE_OLD:	return "Xilinx MicroBlaze";
    case EM_RL78:		return "Renesas RL78";
    case EM_RX:			return "Renesas RX";
    case EM_METAG:		return "Imagination Technologies Meta processor architecture";
    case EM_MCST_ELBRUS:	return "MCST Elbrus general purpose hardware architecture";
    case EM_ECOG16:		return "Cyan Technology eCOG16 family";
    case EM_ETPU:		return "Freescale Extended Time Processing Unit";
    case EM_SLE9X:		return "Infineon Technologies SLE9X core";
    case EM_AVR32:		return "Atmel Corporation 32-bit microprocessor family";
    case EM_STM8:		return "STMicroeletronics STM8 8-bit microcontroller";
    case EM_TILE64:		return "Tilera TILE64 multicore architecture family";
    case EM_TILEPRO:		return "Tilera TILEPro multicore architecture family";
    case EM_TILEGX:		return "Tilera TILE-Gx multicore architecture family";
    case EM_CUDA:		return "NVIDIA CUDA architecture";
    case EM_XGATE:		return "Motorola XGATE embedded processor";
    default:
      snprintf (buff, sizeof (buff), _("<unknown>: 0x%x"), e_machine);
      return buff;
    }
}

static void
decode_ARM_machine_flags (unsigned e_flags, char buf[])
{
  unsigned eabi;
  int unknown = 0;

  eabi = EF_ARM_EABI_VERSION (e_flags);
  e_flags &= ~ EF_ARM_EABIMASK;

  /* Handle "generic" ARM flags.  */
  if (e_flags & EF_ARM_RELEXEC)
    {
      strcat (buf, ", relocatable executable");
      e_flags &= ~ EF_ARM_RELEXEC;
    }

  if (e_flags & EF_ARM_HASENTRY)
    {
      strcat (buf, ", has entry point");
      e_flags &= ~ EF_ARM_HASENTRY;
    }

  /* Now handle EABI specific flags.  */
  switch (eabi)
    {
    default:
      strcat (buf, ", <unrecognized EABI>");
      if (e_flags)
	unknown = 1;
      break;

    case EF_ARM_EABI_VER1:
      strcat (buf, ", Version1 EABI");
      while (e_flags)
	{
	  unsigned flag;

	  /* Process flags one bit at a time.  */
	  flag = e_flags & - e_flags;
	  e_flags &= ~ flag;

	  switch (flag)
	    {
	    case EF_ARM_SYMSARESORTED: /* Conflicts with EF_ARM_INTERWORK.  */
	      strcat (buf, ", sorted symbol tables");
	      break;

	    default:
	      unknown = 1;
	      break;
	    }
	}
      break;

    case EF_ARM_EABI_VER2:
      strcat (buf, ", Version2 EABI");
      while (e_flags)
	{
	  unsigned flag;

	  /* Process flags one bit at a time.  */
	  flag = e_flags & - e_flags;
	  e_flags &= ~ flag;

	  switch (flag)
	    {
	    case EF_ARM_SYMSARESORTED: /* Conflicts with EF_ARM_INTERWORK.  */
	      strcat (buf, ", sorted symbol tables");
	      break;

	    case EF_ARM_DYNSYMSUSESEGIDX:
	      strcat (buf, ", dynamic symbols use segment index");
	      break;

	    case EF_ARM_MAPSYMSFIRST:
	      strcat (buf, ", mapping symbols precede others");
	      break;

	    default:
	      unknown = 1;
	      break;
	    }
	}
      break;

    case EF_ARM_EABI_VER3:
      strcat (buf, ", Version3 EABI");
      break;

    case EF_ARM_EABI_VER4:
      strcat (buf, ", Version4 EABI");
      while (e_flags)
	{
	  unsigned flag;

	  /* Process flags one bit at a time.  */
	  flag = e_flags & - e_flags;
	  e_flags &= ~ flag;

	  switch (flag)
	    {
	    case EF_ARM_BE8:
	      strcat (buf, ", BE8");
	      break;

	    case EF_ARM_LE8:
	      strcat (buf, ", LE8");
	      break;

	    default:
	      unknown = 1;
	      break;
	    }
      break;
	}
      break;

    case EF_ARM_EABI_VER5:
      strcat (buf, ", Version5 EABI");
      while (e_flags)
	{
	  unsigned flag;

	  /* Process flags one bit at a time.  */
	  flag = e_flags & - e_flags;
	  e_flags &= ~ flag;

	  switch (flag)
	    {
	    case EF_ARM_BE8:
	      strcat (buf, ", BE8");
	      break;

	    case EF_ARM_LE8:
	      strcat (buf, ", LE8");
	      break;

	    case EF_ARM_ABI_FLOAT_SOFT: /* Conflicts with EF_ARM_SOFT_FLOAT.  */
	      strcat (buf, ", soft-float ABI");
	      break;

	    case EF_ARM_ABI_FLOAT_HARD: /* Conflicts with EF_ARM_VFP_FLOAT.  */
	      strcat (buf, ", hard-float ABI");
	      break;

	    default:
	      unknown = 1;
	      break;
	    }
	}
      break;

    case EF_ARM_EABI_UNKNOWN:
      strcat (buf, ", GNU EABI");
      while (e_flags)
	{
	  unsigned flag;

	  /* Process flags one bit at a time.  */
	  flag = e_flags & - e_flags;
	  e_flags &= ~ flag;

	  switch (flag)
	    {
	    case EF_ARM_INTERWORK:
	      strcat (buf, ", interworking enabled");
	      break;

	    case EF_ARM_APCS_26:
	      strcat (buf, ", uses APCS/26");
	      break;

	    case EF_ARM_APCS_FLOAT:
	      strcat (buf, ", uses APCS/float");
	      break;

	    case EF_ARM_PIC:
	      strcat (buf, ", position independent");
	      break;

	    case EF_ARM_ALIGN8:
	      strcat (buf, ", 8 bit structure alignment");
	      break;

	    case EF_ARM_NEW_ABI:
	      strcat (buf, ", uses new ABI");
	      break;

	    case EF_ARM_OLD_ABI:
	      strcat (buf, ", uses old ABI");
	      break;

	    case EF_ARM_SOFT_FLOAT:
	      strcat (buf, ", software FP");
	      break;

	    case EF_ARM_VFP_FLOAT:
	      strcat (buf, ", VFP");
	      break;

	    case EF_ARM_MAVERICK_FLOAT:
	      strcat (buf, ", Maverick FP");
	      break;

	    default:
	      unknown = 1;
	      break;
	    }
	}
    }

  if (unknown)
    strcat (buf,_(", <unknown>"));
}

static char *
get_machine_flags (unsigned e_flags, unsigned e_machine)
{
  static char buf[1024];

  buf[0] = '\0';

  if (e_flags)
    {
      switch (e_machine)
	{
	default:
	  break;

	case EM_ARM:
	  decode_ARM_machine_flags (e_flags, buf);
	  break;

	case EM_BLACKFIN:
	  if (e_flags & EF_BFIN_PIC)
	    strcat (buf, ", PIC");

	  if (e_flags & EF_BFIN_FDPIC)
	    strcat (buf, ", FDPIC");

	  if (e_flags & EF_BFIN_CODE_IN_L1)
	    strcat (buf, ", code in L1");

	  if (e_flags & EF_BFIN_DATA_IN_L1)
	    strcat (buf, ", data in L1");

	  break;

	case EM_CYGNUS_FRV:
	  switch (e_flags & EF_FRV_CPU_MASK)
	    {
	    case EF_FRV_CPU_GENERIC:
	      break;

	    default:
	      strcat (buf, ", fr???");
	      break;

	    case EF_FRV_CPU_FR300:
	      strcat (buf, ", fr300");
	      break;

	    case EF_FRV_CPU_FR400:
	      strcat (buf, ", fr400");
	      break;
	    case EF_FRV_CPU_FR405:
	      strcat (buf, ", fr405");
	      break;

	    case EF_FRV_CPU_FR450:
	      strcat (buf, ", fr450");
	      break;

	    case EF_FRV_CPU_FR500:
	      strcat (buf, ", fr500");
	      break;
	    case EF_FRV_CPU_FR550:
	      strcat (buf, ", fr550");
	      break;

	    case EF_FRV_CPU_SIMPLE:
	      strcat (buf, ", simple");
	      break;
	    case EF_FRV_CPU_TOMCAT:
	      strcat (buf, ", tomcat");
	      break;
	    }
	  break;

	case EM_68K:
	  if ((e_flags & EF_M68K_ARCH_MASK) == EF_M68K_M68000)
	    strcat (buf, ", m68000");
	  else if ((e_flags & EF_M68K_ARCH_MASK) == EF_M68K_CPU32)
	    strcat (buf, ", cpu32");
	  else if ((e_flags & EF_M68K_ARCH_MASK) == EF_M68K_FIDO)
	    strcat (buf, ", fido_a");
	  else
	    {
	      char const * isa = _("unknown");
	      char const * mac = _("unknown mac");
	      char const * additional = NULL;

	      switch (e_flags & EF_M68K_CF_ISA_MASK)
		{
		case EF_M68K_CF_ISA_A_NODIV:
		  isa = "A";
		  additional = ", nodiv";
		  break;
		case EF_M68K_CF_ISA_A:
		  isa = "A";
		  break;
		case EF_M68K_CF_ISA_A_PLUS:
		  isa = "A+";
		  break;
		case EF_M68K_CF_ISA_B_NOUSP:
		  isa = "B";
		  additional = ", nousp";
		  break;
		case EF_M68K_CF_ISA_B:
		  isa = "B";
		  break;
		case EF_M68K_CF_ISA_C:
		  isa = "C";
		  break;
		case EF_M68K_CF_ISA_C_NODIV:
		  isa = "C";
		  additional = ", nodiv";
		  break;
		}
	      strcat (buf, ", cf, isa ");
	      strcat (buf, isa);
	      if (additional)
		strcat (buf, additional);
	      if (e_flags & EF_M68K_CF_FLOAT)
		strcat (buf, ", float");
	      switch (e_flags & EF_M68K_CF_MAC_MASK)
		{
		case 0:
		  mac = NULL;
		  break;
		case EF_M68K_CF_MAC:
		  mac = "mac";
		  break;
		case EF_M68K_CF_EMAC:
		  mac = "emac";
		  break;
		case EF_M68K_CF_EMAC_B:
		  mac = "emac_b";
		  break;
		}
	      if (mac)
		{
		  strcat (buf, ", ");
		  strcat (buf, mac);
		}
	    }
	  break;

	case EM_PPC:
	  if (e_flags & EF_PPC_EMB)
	    strcat (buf, ", emb");

	  if (e_flags & EF_PPC_RELOCATABLE)
	    strcat (buf, _(", relocatable"));

	  if (e_flags & EF_PPC_RELOCATABLE_LIB)
	    strcat (buf, _(", relocatable-lib"));
	  break;

	case EM_V800:
	  if ((e_flags & EF_RH850_ABI) == EF_RH850_ABI)
	    strcat (buf, ", RH850 ABI");

	  if (e_flags & EF_V800_850E3)
	    strcat (buf, ", V3 architecture");

	  if ((e_flags & (EF_RH850_FPU_DOUBLE | EF_RH850_FPU_SINGLE)) == 0)
	    strcat (buf, ", FPU not used");

	  if ((e_flags & (EF_RH850_REGMODE22 | EF_RH850_REGMODE32)) == 0)
	    strcat (buf, ", regmode: COMMON");

	  if ((e_flags & (EF_RH850_GP_FIX | EF_RH850_GP_NOFIX)) == 0)
	    strcat (buf, ", r4 not used");

	  if ((e_flags & (EF_RH850_EP_FIX | EF_RH850_EP_NOFIX)) == 0)
	    strcat (buf, ", r30 not used");

	  if ((e_flags & (EF_RH850_TP_FIX | EF_RH850_TP_NOFIX)) == 0)
	    strcat (buf, ", r5 not used");

	  if ((e_flags & (EF_RH850_REG2_RESERVE | EF_RH850_REG2_NORESERVE)) == 0)
	    strcat (buf, ", r2 not used");

	  for (e_flags &= 0xFFFF; e_flags; e_flags &= ~ (e_flags & - e_flags))
	    {
	      switch (e_flags & - e_flags)
		{
		case EF_RH850_FPU_DOUBLE: strcat (buf, ", double precision FPU"); break;
		case EF_RH850_FPU_SINGLE: strcat (buf, ", single precision FPU"); break;
		case EF_RH850_SIMD: strcat (buf, ", SIMD"); break;
		case EF_RH850_CACHE: strcat (buf, ", CACHE"); break;
		case EF_RH850_MMU: strcat (buf, ", MMU"); break;
		case EF_RH850_REGMODE22: strcat (buf, ", regmode:22"); break;
		case EF_RH850_REGMODE32: strcat (buf, ", regmode:23"); break;
		case EF_RH850_DATA_ALIGN8: strcat (buf, ", 8-byte alignment"); break;
		case EF_RH850_GP_FIX: strcat (buf, ", r4 fixed"); break;
		case EF_RH850_GP_NOFIX: strcat (buf, ", r4 free"); break;
		case EF_RH850_EP_FIX: strcat (buf, ", r30 fixed"); break;
		case EF_RH850_EP_NOFIX: strcat (buf, ", r30 free"); break;
		case EF_RH850_TP_FIX: strcat (buf, ", r5 fixed"); break;
		case EF_RH850_TP_NOFIX: strcat (buf, ", r5 free"); break;
		case EF_RH850_REG2_RESERVE: strcat (buf, ", r2 fixed"); break;
		case EF_RH850_REG2_NORESERVE: strcat (buf, ", r2 free"); break;
		default: break;
		}
	    }
	  break;

	case EM_V850:
	case EM_CYGNUS_V850:
	  switch (e_flags & EF_V850_ARCH)
	    {
	    case E_V850E3V5_ARCH:
	      strcat (buf, ", v850e3v5");
	      break;
	    case E_V850E2V3_ARCH:
	      strcat (buf, ", v850e2v3");
	      break;
	    case E_V850E2_ARCH:
	      strcat (buf, ", v850e2");
	      break;
            case E_V850E1_ARCH:
              strcat (buf, ", v850e1");
	      break;
	    case E_V850E_ARCH:
	      strcat (buf, ", v850e");
	      break;
	    case E_V850_ARCH:
	      strcat (buf, ", v850");
	      break;
	    default:
	      strcat (buf, _(", unknown v850 architecture variant"));
	      break;
	    }
	  break;

	case EM_M32R:
	case EM_CYGNUS_M32R:
	  if ((e_flags & EF_M32R_ARCH) == E_M32R_ARCH)
	    strcat (buf, ", m32r");
	  break;

	case EM_MIPS:
	case EM_MIPS_RS3_LE:
	  if (e_flags & EF_MIPS_NOREORDER)
	    strcat (buf, ", noreorder");

	  if (e_flags & EF_MIPS_PIC)
	    strcat (buf, ", pic");

	  if (e_flags & EF_MIPS_CPIC)
	    strcat (buf, ", cpic");

	  if (e_flags & EF_MIPS_UCODE)
	    strcat (buf, ", ugen_reserved");

	  if (e_flags & EF_MIPS_ABI2)
	    strcat (buf, ", abi2");

	  if (e_flags & EF_MIPS_OPTIONS_FIRST)
	    strcat (buf, ", odk first");

	  if (e_flags & EF_MIPS_32BITMODE)
	    strcat (buf, ", 32bitmode");

	  if (e_flags & EF_MIPS_NAN2008)
	    strcat (buf, ", nan2008");

	  if (e_flags & EF_MIPS_FP64)
	    strcat (buf, ", fp64");

	  switch ((e_flags & EF_MIPS_MACH))
	    {
	    case E_MIPS_MACH_3900: strcat (buf, ", 3900"); break;
	    case E_MIPS_MACH_4010: strcat (buf, ", 4010"); break;
	    case E_MIPS_MACH_4100: strcat (buf, ", 4100"); break;
	    case E_MIPS_MACH_4111: strcat (buf, ", 4111"); break;
	    case E_MIPS_MACH_4120: strcat (buf, ", 4120"); break;
	    case E_MIPS_MACH_4650: strcat (buf, ", 4650"); break;
	    case E_MIPS_MACH_5400: strcat (buf, ", 5400"); break;
	    case E_MIPS_MACH_5500: strcat (buf, ", 5500"); break;
	    case E_MIPS_MACH_SB1:  strcat (buf, ", sb1");  break;
	    case E_MIPS_MACH_9000: strcat (buf, ", 9000"); break;
  	    case E_MIPS_MACH_LS2E: strcat (buf, ", loongson-2e"); break;
  	    case E_MIPS_MACH_LS2F: strcat (buf, ", loongson-2f"); break;
  	    case E_MIPS_MACH_LS3A: strcat (buf, ", loongson-3a"); break;
	    case E_MIPS_MACH_OCTEON: strcat (buf, ", octeon"); break;
	    case E_MIPS_MACH_OCTEON2: strcat (buf, ", octeon2"); break;
	    case E_MIPS_MACH_XLR:  strcat (buf, ", xlr"); break;
	    case 0:
	    /* We simply ignore the field in this case to avoid confusion:
	       MIPS ELF does not specify EF_MIPS_MACH, it is a GNU
	       extension.  */
	      break;
	    default: strcat (buf, _(", unknown CPU")); break;
	    }

	  switch ((e_flags & EF_MIPS_ABI))
	    {
	    case E_MIPS_ABI_O32: strcat (buf, ", o32"); break;
	    case E_MIPS_ABI_O64: strcat (buf, ", o64"); break;
	    case E_MIPS_ABI_EABI32: strcat (buf, ", eabi32"); break;
	    case E_MIPS_ABI_EABI64: strcat (buf, ", eabi64"); break;
	    case 0:
	    /* We simply ignore the field in this case to avoid confusion:
	       MIPS ELF does not specify EF_MIPS_ABI, it is a GNU extension.
	       This means it is likely to be an o32 file, but not for
	       sure.  */
	      break;
	    default: strcat (buf, _(", unknown ABI")); break;
	    }

	  if (e_flags & EF_MIPS_ARCH_ASE_MDMX)
	    strcat (buf, ", mdmx");

	  if (e_flags & EF_MIPS_ARCH_ASE_M16)
	    strcat (buf, ", mips16");

	  if (e_flags & EF_MIPS_ARCH_ASE_MICROMIPS)
	    strcat (buf, ", micromips");

	  switch ((e_flags & EF_MIPS_ARCH))
	    {
	    case E_MIPS_ARCH_1: strcat (buf, ", mips1"); break;
	    case E_MIPS_ARCH_2: strcat (buf, ", mips2"); break;
	    case E_MIPS_ARCH_3: strcat (buf, ", mips3"); break;
	    case E_MIPS_ARCH_4: strcat (buf, ", mips4"); break;
	    case E_MIPS_ARCH_5: strcat (buf, ", mips5"); break;
	    case E_MIPS_ARCH_32: strcat (buf, ", mips32"); break;
	    case E_MIPS_ARCH_32R2: strcat (buf, ", mips32r2"); break;
	    case E_MIPS_ARCH_64: strcat (buf, ", mips64"); break;
	    case E_MIPS_ARCH_64R2: strcat (buf, ", mips64r2"); break;
	    default: strcat (buf, _(", unknown ISA")); break;
	    }
	  break;

	case EM_SH:
	  switch ((e_flags & EF_SH_MACH_MASK))
	    {
	    case EF_SH1: strcat (buf, ", sh1"); break;
	    case EF_SH2: strcat (buf, ", sh2"); break;
	    case EF_SH3: strcat (buf, ", sh3"); break;
	    case EF_SH_DSP: strcat (buf, ", sh-dsp"); break;
	    case EF_SH3_DSP: strcat (buf, ", sh3-dsp"); break;
	    case EF_SH4AL_DSP: strcat (buf, ", sh4al-dsp"); break;
	    case EF_SH3E: strcat (buf, ", sh3e"); break;
	    case EF_SH4: strcat (buf, ", sh4"); break;
	    case EF_SH5: strcat (buf, ", sh5"); break;
	    case EF_SH2E: strcat (buf, ", sh2e"); break;
	    case EF_SH4A: strcat (buf, ", sh4a"); break;
	    case EF_SH2A: strcat (buf, ", sh2a"); break;
	    case EF_SH4_NOFPU: strcat (buf, ", sh4-nofpu"); break;
	    case EF_SH4A_NOFPU: strcat (buf, ", sh4a-nofpu"); break;
	    case EF_SH2A_NOFPU: strcat (buf, ", sh2a-nofpu"); break;
	    case EF_SH3_NOMMU: strcat (buf, ", sh3-nommu"); break;
	    case EF_SH4_NOMMU_NOFPU: strcat (buf, ", sh4-nommu-nofpu"); break;
	    case EF_SH2A_SH4_NOFPU: strcat (buf, ", sh2a-nofpu-or-sh4-nommu-nofpu"); break;
	    case EF_SH2A_SH3_NOFPU: strcat (buf, ", sh2a-nofpu-or-sh3-nommu"); break;
	    case EF_SH2A_SH4: strcat (buf, ", sh2a-or-sh4"); break;
	    case EF_SH2A_SH3E: strcat (buf, ", sh2a-or-sh3e"); break;
	    default: strcat (buf, _(", unknown ISA")); break;
	    }

	  if (e_flags & EF_SH_PIC)
	    strcat (buf, ", pic");

	  if (e_flags & EF_SH_FDPIC)
	    strcat (buf, ", fdpic");
	  break;

	case EM_SPARCV9:
	  if (e_flags & EF_SPARC_32PLUS)
	    strcat (buf, ", v8+");

	  if (e_flags & EF_SPARC_SUN_US1)
	    strcat (buf, ", ultrasparcI");

	  if (e_flags & EF_SPARC_SUN_US3)
	    strcat (buf, ", ultrasparcIII");

	  if (e_flags & EF_SPARC_HAL_R1)
	    strcat (buf, ", halr1");

	  if (e_flags & EF_SPARC_LEDATA)
	    strcat (buf, ", ledata");

	  if ((e_flags & EF_SPARCV9_MM) == EF_SPARCV9_TSO)
	    strcat (buf, ", tso");

	  if ((e_flags & EF_SPARCV9_MM) == EF_SPARCV9_PSO)
	    strcat (buf, ", pso");

	  if ((e_flags & EF_SPARCV9_MM) == EF_SPARCV9_RMO)
	    strcat (buf, ", rmo");
	  break;

	case EM_PARISC:
	  switch (e_flags & EF_PARISC_ARCH)
	    {
	    case EFA_PARISC_1_0:
	      strcpy (buf, ", PA-RISC 1.0");
	      break;
	    case EFA_PARISC_1_1:
	      strcpy (buf, ", PA-RISC 1.1");
	      break;
	    case EFA_PARISC_2_0:
	      strcpy (buf, ", PA-RISC 2.0");
	      break;
	    default:
	      break;
	    }
	  if (e_flags & EF_PARISC_TRAPNIL)
	    strcat (buf, ", trapnil");
	  if (e_flags & EF_PARISC_EXT)
	    strcat (buf, ", ext");
	  if (e_flags & EF_PARISC_LSB)
	    strcat (buf, ", lsb");
	  if (e_flags & EF_PARISC_WIDE)
	    strcat (buf, ", wide");
	  if (e_flags & EF_PARISC_NO_KABP)
	    strcat (buf, ", no kabp");
	  if (e_flags & EF_PARISC_LAZYSWAP)
	    strcat (buf, ", lazyswap");
	  break;

	case EM_PJ:
	case EM_PJ_OLD:
	  if ((e_flags & EF_PICOJAVA_NEWCALLS) == EF_PICOJAVA_NEWCALLS)
	    strcat (buf, ", new calling convention");

	  if ((e_flags & EF_PICOJAVA_GNUCALLS) == EF_PICOJAVA_GNUCALLS)
	    strcat (buf, ", gnu calling convention");
	  break;

	case EM_IA_64:
	  if ((e_flags & EF_IA_64_ABI64))
	    strcat (buf, ", 64-bit");
	  else
	    strcat (buf, ", 32-bit");
	  if ((e_flags & EF_IA_64_REDUCEDFP))
	    strcat (buf, ", reduced fp model");
	  if ((e_flags & EF_IA_64_NOFUNCDESC_CONS_GP))
	    strcat (buf, ", no function descriptors, constant gp");
	  else if ((e_flags & EF_IA_64_CONS_GP))
	    strcat (buf, ", constant gp");
	  if ((e_flags & EF_IA_64_ABSOLUTE))
	    strcat (buf, ", absolute");
          if (elf_header.e_ident[EI_OSABI] == ELFOSABI_OPENVMS)
            {
              if ((e_flags & EF_IA_64_VMS_LINKAGES))
                strcat (buf, ", vms_linkages");
              switch ((e_flags & EF_IA_64_VMS_COMCOD))
                {
                case EF_IA_64_VMS_COMCOD_SUCCESS:
                  break;
                case EF_IA_64_VMS_COMCOD_WARNING:
                  strcat (buf, ", warning");
                  break;
                case EF_IA_64_VMS_COMCOD_ERROR:
                  strcat (buf, ", error");
                  break;
                case EF_IA_64_VMS_COMCOD_ABORT:
                  strcat (buf, ", abort");
                  break;
                default:
                  abort ();
                }
            }
	  break;

	case EM_VAX:
	  if ((e_flags & EF_VAX_NONPIC))
	    strcat (buf, ", non-PIC");
	  if ((e_flags & EF_VAX_DFLOAT))
	    strcat (buf, ", D-Float");
	  if ((e_flags & EF_VAX_GFLOAT))
	    strcat (buf, ", G-Float");
	  break;

	case EM_RL78:
	  if (e_flags & E_FLAG_RL78_G10)
	    strcat (buf, ", G10");
	  break;

	case EM_RX:
	  if (e_flags & E_FLAG_RX_64BIT_DOUBLES)
	    strcat (buf, ", 64-bit doubles");
	  if (e_flags & E_FLAG_RX_DSP)
	    strcat (buf, ", dsp");
	  if (e_flags & E_FLAG_RX_PID)
	    strcat (buf, ", pid");
	  if (e_flags & E_FLAG_RX_ABI)
	    strcat (buf, ", RX ABI");
	  break;

	case EM_S390:
	  if (e_flags & EF_S390_HIGH_GPRS)
	    strcat (buf, ", highgprs");
	  break;

	case EM_TI_C6000:
	  if ((e_flags & EF_C6000_REL))
	    strcat (buf, ", relocatable module");
	  break;

	case EM_MSP430:
	  strcat (buf, _(": architecture variant: "));
	  switch (e_flags & EF_MSP430_MACH)
	    {
	    case E_MSP430_MACH_MSP430x11: strcat (buf, "MSP430x11"); break;
	    case E_MSP430_MACH_MSP430x11x1 : strcat (buf, "MSP430x11x1 "); break;
	    case E_MSP430_MACH_MSP430x12: strcat (buf, "MSP430x12"); break;
	    case E_MSP430_MACH_MSP430x13: strcat (buf, "MSP430x13"); break;
	    case E_MSP430_MACH_MSP430x14: strcat (buf, "MSP430x14"); break;
	    case E_MSP430_MACH_MSP430x15: strcat (buf, "MSP430x15"); break;
	    case E_MSP430_MACH_MSP430x16: strcat (buf, "MSP430x16"); break;
	    case E_MSP430_MACH_MSP430x31: strcat (buf, "MSP430x31"); break;
	    case E_MSP430_MACH_MSP430x32: strcat (buf, "MSP430x32"); break;
	    case E_MSP430_MACH_MSP430x33: strcat (buf, "MSP430x33"); break;
	    case E_MSP430_MACH_MSP430x41: strcat (buf, "MSP430x41"); break;
	    case E_MSP430_MACH_MSP430x42: strcat (buf, "MSP430x42"); break;
	    case E_MSP430_MACH_MSP430x43: strcat (buf, "MSP430x43"); break;
	    case E_MSP430_MACH_MSP430x44: strcat (buf, "MSP430x44"); break;
	    case E_MSP430_MACH_MSP430X  : strcat (buf, "MSP430X"); break;
	    default:
	      strcat (buf, _(": unknown")); break;
	    }

	  if (e_flags & ~ EF_MSP430_MACH)
	    strcat (buf, _(": unknown extra flag bits also present"));
	}
    }

  return buf;
}

static const char *
get_osabi_name (unsigned int osabi)
{
  static char buff[32];

  switch (osabi)
    {
    case ELFOSABI_NONE:		return "UNIX - System V";
    case ELFOSABI_HPUX:		return "UNIX - HP-UX";
    case ELFOSABI_NETBSD:	return "UNIX - NetBSD";
    case ELFOSABI_GNU:		return "UNIX - GNU";
    case ELFOSABI_SOLARIS:	return "UNIX - Solaris";
    case ELFOSABI_AIX:		return "UNIX - AIX";
    case ELFOSABI_IRIX:		return "UNIX - IRIX";
    case ELFOSABI_FREEBSD:	return "UNIX - FreeBSD";
    case ELFOSABI_TRU64:	return "UNIX - TRU64";
    case ELFOSABI_MODESTO:	return "Novell - Modesto";
    case ELFOSABI_OPENBSD:	return "UNIX - OpenBSD";
    case ELFOSABI_OPENVMS:	return "VMS - OpenVMS";
    case ELFOSABI_NSK:		return "HP - Non-Stop Kernel";
    case ELFOSABI_AROS:		return "AROS";
    case ELFOSABI_FENIXOS:	return "FenixOS";
    default:
      if (osabi >= 64)
	switch (elf_header.e_machine)
	  {
	  case EM_ARM:
	    switch (osabi)
	      {
	      case ELFOSABI_ARM:	return "ARM";
	      default:
		break;
	      }
	    break;

	  case EM_MSP430:
	  case EM_MSP430_OLD:
	    switch (osabi)
	      {
	      case ELFOSABI_STANDALONE:	return _("Standalone App");
	      default:
		break;
	      }
	    break;

	  case EM_TI_C6000:
	    switch (osabi)
	      {
	      case ELFOSABI_C6000_ELFABI:	return _("Bare-metal C6000");
	      case ELFOSABI_C6000_LINUX:	return "Linux C6000";
	      default:
		break;
	      }
	    break;

	  default:
	    break;
	  }
      snprintf (buff, sizeof (buff), _("<unknown: %x>"), osabi);
      return buff;
    }
}

static const char *
get_aarch64_segment_type (unsigned long type)
{
  switch (type)
    {
    case PT_AARCH64_ARCHEXT:
      return "AARCH64_ARCHEXT";
    default:
      break;
    }

  return NULL;
}

static const char *
get_arm_segment_type (unsigned long type)
{
  switch (type)
    {
    case PT_ARM_EXIDX:
      return "EXIDX";
    default:
      break;
    }

  return NULL;
}

static const char *
get_mips_segment_type (unsigned long type)
{
  switch (type)
    {
    case PT_MIPS_REGINFO:
      return "REGINFO";
    case PT_MIPS_RTPROC:
      return "RTPROC";
    case PT_MIPS_OPTIONS:
      return "OPTIONS";
    default:
      break;
    }

  return NULL;
}

static const char *
get_parisc_segment_type (unsigned long type)
{
  switch (type)
    {
    case PT_HP_TLS:		return "HP_TLS";
    case PT_HP_CORE_NONE:	return "HP_CORE_NONE";
    case PT_HP_CORE_VERSION:	return "HP_CORE_VERSION";
    case PT_HP_CORE_KERNEL:	return "HP_CORE_KERNEL";
    case PT_HP_CORE_COMM:	return "HP_CORE_COMM";
    case PT_HP_CORE_PROC:	return "HP_CORE_PROC";
    case PT_HP_CORE_LOADABLE:	return "HP_CORE_LOADABLE";
    case PT_HP_CORE_STACK:	return "HP_CORE_STACK";
    case PT_HP_CORE_SHM:	return "HP_CORE_SHM";
    case PT_HP_CORE_MMF:	return "HP_CORE_MMF";
    case PT_HP_PARALLEL:	return "HP_PARALLEL";
    case PT_HP_FASTBIND:	return "HP_FASTBIND";
    case PT_HP_OPT_ANNOT:	return "HP_OPT_ANNOT";
    case PT_HP_HSL_ANNOT:	return "HP_HSL_ANNOT";
    case PT_HP_STACK:		return "HP_STACK";
    case PT_HP_CORE_UTSNAME:	return "HP_CORE_UTSNAME";
    case PT_PARISC_ARCHEXT:	return "PARISC_ARCHEXT";
    case PT_PARISC_UNWIND:	return "PARISC_UNWIND";
    case PT_PARISC_WEAKORDER:	return "PARISC_WEAKORDER";
    default:
      break;
    }

  return NULL;
}

static const char *
get_ia64_segment_type (unsigned long type)
{
  switch (type)
    {
    case PT_IA_64_ARCHEXT:	return "IA_64_ARCHEXT";
    case PT_IA_64_UNWIND:	return "IA_64_UNWIND";
    case PT_HP_TLS:		return "HP_TLS";
    case PT_IA_64_HP_OPT_ANOT:	return "HP_OPT_ANNOT";
    case PT_IA_64_HP_HSL_ANOT:	return "HP_HSL_ANNOT";
    case PT_IA_64_HP_STACK:	return "HP_STACK";
    default:
      break;
    }

  return NULL;
}

static const char *
get_tic6x_segment_type (unsigned long type)
{
  switch (type)
    {
    case PT_C6000_PHATTR:	return "C6000_PHATTR";
    default:
      break;
    }

  return NULL;
}

static const char *
get_segment_type (unsigned long p_type)
{
  static char buff[32];

  switch (p_type)
    {
    case PT_NULL:	return "NULL";
    case PT_LOAD:	return "LOAD";
    case PT_DYNAMIC:	return "DYNAMIC";
    case PT_INTERP:	return "INTERP";
    case PT_NOTE:	return "NOTE";
    case PT_SHLIB:	return "SHLIB";
    case PT_PHDR:	return "PHDR";
    case PT_TLS:	return "TLS";

    case PT_GNU_EH_FRAME:
			return "GNU_EH_FRAME";
    case PT_GNU_STACK:	return "GNU_STACK";
    case PT_GNU_RELRO:  return "GNU_RELRO";

    default:
      if ((p_type >= PT_LOPROC) && (p_type <= PT_HIPROC))
	{
	  const char * result;

	  switch (elf_header.e_machine)
	    {
	    case EM_AARCH64:
	      result = get_aarch64_segment_type (p_type);
	      break;
	    case EM_ARM:
	      result = get_arm_segment_type (p_type);
	      break;
	    case EM_MIPS:
	    case EM_MIPS_RS3_LE:
	      result = get_mips_segment_type (p_type);
	      break;
	    case EM_PARISC:
	      result = get_parisc_segment_type (p_type);
	      break;
	    case EM_IA_64:
	      result = get_ia64_segment_type (p_type);
	      break;
	    case EM_TI_C6000:
	      result = get_tic6x_segment_type (p_type);
	      break;
	    default:
	      result = NULL;
	      break;
	    }

	  if (result != NULL)
	    return result;

	  sprintf (buff, "LOPROC+%lx", p_type - PT_LOPROC);
	}
      else if ((p_type >= PT_LOOS) && (p_type <= PT_HIOS))
	{
	  const char * result;

	  switch (elf_header.e_machine)
	    {
	    case EM_PARISC:
	      result = get_parisc_segment_type (p_type);
	      break;
	    case EM_IA_64:
	      result = get_ia64_segment_type (p_type);
	      break;
	    default:
	      result = NULL;
	      break;
	    }

	  if (result != NULL)
	    return result;

	  sprintf (buff, "LOOS+%lx", p_type - PT_LOOS);
	}
      else
	snprintf (buff, sizeof (buff), _("<unknown>: %lx"), p_type);

      return buff;
    }
}

static const char *
get_mips_section_type_name (unsigned int sh_type)
{
  switch (sh_type)
    {
    case SHT_MIPS_LIBLIST:	 return "MIPS_LIBLIST";
    case SHT_MIPS_MSYM:		 return "MIPS_MSYM";
    case SHT_MIPS_CONFLICT:	 return "MIPS_CONFLICT";
    case SHT_MIPS_GPTAB:	 return "MIPS_GPTAB";
    case SHT_MIPS_UCODE:	 return "MIPS_UCODE";
    case SHT_MIPS_DEBUG:	 return "MIPS_DEBUG";
    case SHT_MIPS_REGINFO:	 return "MIPS_REGINFO";
    case SHT_MIPS_PACKAGE:	 return "MIPS_PACKAGE";
    case SHT_MIPS_PACKSYM:	 return "MIPS_PACKSYM";
    case SHT_MIPS_RELD:		 return "MIPS_RELD";
    case SHT_MIPS_IFACE:	 return "MIPS_IFACE";
    case SHT_MIPS_CONTENT:	 return "MIPS_CONTENT";
    case SHT_MIPS_OPTIONS:	 return "MIPS_OPTIONS";
    case SHT_MIPS_SHDR:		 return "MIPS_SHDR";
    case SHT_MIPS_FDESC:	 return "MIPS_FDESC";
    case SHT_MIPS_EXTSYM:	 return "MIPS_EXTSYM";
    case SHT_MIPS_DENSE:	 return "MIPS_DENSE";
    case SHT_MIPS_PDESC:	 return "MIPS_PDESC";
    case SHT_MIPS_LOCSYM:	 return "MIPS_LOCSYM";
    case SHT_MIPS_AUXSYM:	 return "MIPS_AUXSYM";
    case SHT_MIPS_OPTSYM:	 return "MIPS_OPTSYM";
    case SHT_MIPS_LOCSTR:	 return "MIPS_LOCSTR";
    case SHT_MIPS_LINE:		 return "MIPS_LINE";
    case SHT_MIPS_RFDESC:	 return "MIPS_RFDESC";
    case SHT_MIPS_DELTASYM:	 return "MIPS_DELTASYM";
    case SHT_MIPS_DELTAINST:	 return "MIPS_DELTAINST";
    case SHT_MIPS_DELTACLASS:	 return "MIPS_DELTACLASS";
    case SHT_MIPS_DWARF:	 return "MIPS_DWARF";
    case SHT_MIPS_DELTADECL:	 return "MIPS_DELTADECL";
    case SHT_MIPS_SYMBOL_LIB:	 return "MIPS_SYMBOL_LIB";
    case SHT_MIPS_EVENTS:	 return "MIPS_EVENTS";
    case SHT_MIPS_TRANSLATE:	 return "MIPS_TRANSLATE";
    case SHT_MIPS_PIXIE:	 return "MIPS_PIXIE";
    case SHT_MIPS_XLATE:	 return "MIPS_XLATE";
    case SHT_MIPS_XLATE_DEBUG:	 return "MIPS_XLATE_DEBUG";
    case SHT_MIPS_WHIRL:	 return "MIPS_WHIRL";
    case SHT_MIPS_EH_REGION:	 return "MIPS_EH_REGION";
    case SHT_MIPS_XLATE_OLD:	 return "MIPS_XLATE_OLD";
    case SHT_MIPS_PDR_EXCEPTION: return "MIPS_PDR_EXCEPTION";
    default:
      break;
    }
  return NULL;
}

static const char *
get_parisc_section_type_name (unsigned int sh_type)
{
  switch (sh_type)
    {
    case SHT_PARISC_EXT:	return "PARISC_EXT";
    case SHT_PARISC_UNWIND:	return "PARISC_UNWIND";
    case SHT_PARISC_DOC:	return "PARISC_DOC";
    case SHT_PARISC_ANNOT:	return "PARISC_ANNOT";
    case SHT_PARISC_SYMEXTN:	return "PARISC_SYMEXTN";
    case SHT_PARISC_STUBS:	return "PARISC_STUBS";
    case SHT_PARISC_DLKM:	return "PARISC_DLKM";
    default:
      break;
    }
  return NULL;
}

static const char *
get_ia64_section_type_name (unsigned int sh_type)
{
  /* If the top 8 bits are 0x78 the next 8 are the os/abi ID.  */
  if ((sh_type & 0xFF000000) == SHT_IA_64_LOPSREG)
    return get_osabi_name ((sh_type & 0x00FF0000) >> 16);

  switch (sh_type)
    {
    case SHT_IA_64_EXT:		       return "IA_64_EXT";
    case SHT_IA_64_UNWIND:	       return "IA_64_UNWIND";
    case SHT_IA_64_PRIORITY_INIT:      return "IA_64_PRIORITY_INIT";
    case SHT_IA_64_VMS_TRACE:          return "VMS_TRACE";
    case SHT_IA_64_VMS_TIE_SIGNATURES: return "VMS_TIE_SIGNATURES";
    case SHT_IA_64_VMS_DEBUG:          return "VMS_DEBUG";
    case SHT_IA_64_VMS_DEBUG_STR:      return "VMS_DEBUG_STR";
    case SHT_IA_64_VMS_LINKAGES:       return "VMS_LINKAGES";
    case SHT_IA_64_VMS_SYMBOL_VECTOR:  return "VMS_SYMBOL_VECTOR";
    case SHT_IA_64_VMS_FIXUP:          return "VMS_FIXUP";
    default:
      break;
    }
  return NULL;
}

static const char *
get_x86_64_section_type_name (unsigned int sh_type)
{
  switch (sh_type)
    {
    case SHT_X86_64_UNWIND:	return "X86_64_UNWIND";
    default:
      break;
    }
  return NULL;
}

static const char *
get_aarch64_section_type_name (unsigned int sh_type)
{
  switch (sh_type)
    {
    case SHT_AARCH64_ATTRIBUTES:
      return "AARCH64_ATTRIBUTES";
    default:
      break;
    }
  return NULL;
}

static const char *
get_arm_section_type_name (unsigned int sh_type)
{
  switch (sh_type)
    {
    case SHT_ARM_EXIDX:           return "ARM_EXIDX";
    case SHT_ARM_PREEMPTMAP:      return "ARM_PREEMPTMAP";
    case SHT_ARM_ATTRIBUTES:      return "ARM_ATTRIBUTES";
    case SHT_ARM_DEBUGOVERLAY:    return "ARM_DEBUGOVERLAY";
    case SHT_ARM_OVERLAYSECTION:  return "ARM_OVERLAYSECTION";
    default:
      break;
    }
  return NULL;
}

static const char *
get_tic6x_section_type_name (unsigned int sh_type)
{
  switch (sh_type)
    {
    case SHT_C6000_UNWIND:
      return "C6000_UNWIND";
    case SHT_C6000_PREEMPTMAP:
      return "C6000_PREEMPTMAP";
    case SHT_C6000_ATTRIBUTES:
      return "C6000_ATTRIBUTES";
    case SHT_TI_ICODE:
      return "TI_ICODE";
    case SHT_TI_XREF:
      return "TI_XREF";
    case SHT_TI_HANDLER:
      return "TI_HANDLER";
    case SHT_TI_INITINFO:
      return "TI_INITINFO";
    case SHT_TI_PHATTRS:
      return "TI_PHATTRS";
    default:
      break;
    }
  return NULL;
}

static const char *
get_msp430x_section_type_name (unsigned int sh_type)
{
  switch (sh_type)
    {
    case SHT_MSP430_SEC_FLAGS:   return "MSP430_SEC_FLAGS";
    case SHT_MSP430_SYM_ALIASES: return "MSP430_SYM_ALIASES";
    case SHT_MSP430_ATTRIBUTES:  return "MSP430_ATTRIBUTES";
    default: return NULL;
    }
}

static const char *
get_section_type_name (unsigned int sh_type)
{
  static char buff[32];

  switch (sh_type)
    {
    case SHT_NULL:		return "NULL";
    case SHT_PROGBITS:		return "PROGBITS";
    case SHT_SYMTAB:		return "SYMTAB";
    case SHT_STRTAB:		return "STRTAB";
    case SHT_RELA:		return "RELA";
    case SHT_HASH:		return "HASH";
    case SHT_DYNAMIC:		return "DYNAMIC";
    case SHT_NOTE:		return "NOTE";
    case SHT_NOBITS:		return "NOBITS";
    case SHT_REL:		return "REL";
    case SHT_SHLIB:		return "SHLIB";
    case SHT_DYNSYM:		return "DYNSYM";
    case SHT_INIT_ARRAY:	return "INIT_ARRAY";
    case SHT_FINI_ARRAY:	return "FINI_ARRAY";
    case SHT_PREINIT_ARRAY:	return "PREINIT_ARRAY";
    case SHT_GNU_HASH:		return "GNU_HASH";
    case SHT_GROUP:		return "GROUP";
    case SHT_SYMTAB_SHNDX:	return "SYMTAB SECTION INDICIES";
    case SHT_GNU_verdef:	return "VERDEF";
    case SHT_GNU_verneed:	return "VERNEED";
    case SHT_GNU_versym:	return "VERSYM";
    case 0x6ffffff0:		return "VERSYM";
    case 0x6ffffffc:		return "VERDEF";
    case 0x7ffffffd:		return "AUXILIARY";
    case 0x7fffffff:		return "FILTER";
    case SHT_GNU_LIBLIST:	return "GNU_LIBLIST";

    default:
      if ((sh_type >= SHT_LOPROC) && (sh_type <= SHT_HIPROC))
	{
	  const char * result;

	  switch (elf_header.e_machine)
	    {
	    case EM_MIPS:
	    case EM_MIPS_RS3_LE:
	      result = get_mips_section_type_name (sh_type);
	      break;
	    case EM_PARISC:
	      result = get_parisc_section_type_name (sh_type);
	      break;
	    case EM_IA_64:
	      result = get_ia64_section_type_name (sh_type);
	      break;
	    case EM_X86_64:
	    case EM_L1OM:
	    case EM_K1OM:
	      result = get_x86_64_section_type_name (sh_type);
	      break;
	    case EM_AARCH64:
	      result = get_aarch64_section_type_name (sh_type);
	      break;
	    case EM_ARM:
	      result = get_arm_section_type_name (sh_type);
	      break;
	    case EM_TI_C6000:
	      result = get_tic6x_section_type_name (sh_type);
	      break;
	    case EM_MSP430:
	      result = get_msp430x_section_type_name (sh_type);
	      break;
	    default:
	      result = NULL;
	      break;
	    }

	  if (result != NULL)
	    return result;

	  sprintf (buff, "LOPROC+%x", sh_type - SHT_LOPROC);
	}
      else if ((sh_type >= SHT_LOOS) && (sh_type <= SHT_HIOS))
	{
	  const char * result;

	  switch (elf_header.e_machine)
	    {
	    case EM_IA_64:
	      result = get_ia64_section_type_name (sh_type);
	      break;
	    default:
	      result = NULL;
	      break;
	    }

	  if (result != NULL)
	    return result;

	  sprintf (buff, "LOOS+%x", sh_type - SHT_LOOS);
	}
      else if ((sh_type >= SHT_LOUSER) && (sh_type <= SHT_HIUSER))
	sprintf (buff, "LOUSER+%x", sh_type - SHT_LOUSER);
      else
	/* This message is probably going to be displayed in a 15
	   character wide field, so put the hex value first.  */
	snprintf (buff, sizeof (buff), _("%08x: <unknown>"), sh_type);

      return buff;
    }
}

#define OPTION_DEBUG_DUMP	512
#define OPTION_DYN_SYMS		513
#define OPTION_DWARF_DEPTH	514
#define OPTION_DWARF_START	515
#define OPTION_DWARF_CHECK	516

static struct option options[] =
{
  {"all",	       no_argument, 0, 'a'},
  {"file-header",      no_argument, 0, 'h'},
  {"program-headers",  no_argument, 0, 'l'},
  {"headers",	       no_argument, 0, 'e'},
  {"histogram",	       no_argument, 0, 'I'},
  {"segments",	       no_argument, 0, 'l'},
  {"sections",	       no_argument, 0, 'S'},
  {"section-headers",  no_argument, 0, 'S'},
  {"section-groups",   no_argument, 0, 'g'},
  {"section-details",  no_argument, 0, 't'},
  {"full-section-name",no_argument, 0, 'N'},
  {"symbols",	       no_argument, 0, 's'},
  {"syms",	       no_argument, 0, 's'},
  {"dyn-syms",	       no_argument, 0, OPTION_DYN_SYMS},
  {"relocs",	       no_argument, 0, 'r'},
  {"notes",	       no_argument, 0, 'n'},
  {"dynamic",	       no_argument, 0, 'd'},
  {"arch-specific",    no_argument, 0, 'A'},
  {"version-info",     no_argument, 0, 'V'},
  {"use-dynamic",      no_argument, 0, 'D'},
  {"unwind",	       no_argument, 0, 'u'},
  {"archive-index",    no_argument, 0, 'c'},
  {"hex-dump",	       required_argument, 0, 'x'},
  {"relocated-dump",   required_argument, 0, 'R'},
  {"string-dump",      required_argument, 0, 'p'},
#ifdef SUPPORT_DISASSEMBLY
  {"instruction-dump", required_argument, 0, 'i'},
#endif
  {"debug-dump",       optional_argument, 0, OPTION_DEBUG_DUMP},

  {"dwarf-depth",      required_argument, 0, OPTION_DWARF_DEPTH},
  {"dwarf-start",      required_argument, 0, OPTION_DWARF_START},
  {"dwarf-check",      no_argument, 0, OPTION_DWARF_CHECK},

  {"version",	       no_argument, 0, 'v'},
  {"wide",	       no_argument, 0, 'W'},
  {"help",	       no_argument, 0, 'H'},
  {0,		       no_argument, 0, 0}
};

static void
usage (FILE * stream)
{
  fprintf (stream, _("Usage: readelf <option(s)> elf-file(s)\n"));
  fprintf (stream, _(" Display information about the contents of ELF format files\n"));
  fprintf (stream, _(" Options are:\n\
  -a --all               Equivalent to: -h -l -S -s -r -d -V -A -I\n\
  -h --file-header       Display the ELF file header\n\
  -l --program-headers   Display the program headers\n\
     --segments          An alias for --program-headers\n\
  -S --section-headers   Display the sections' header\n\
     --sections          An alias for --section-headers\n\
  -g --section-groups    Display the section groups\n\
  -t --section-details   Display the section details\n\
  -e --headers           Equivalent to: -h -l -S\n\
  -s --syms              Display the symbol table\n\
     --symbols           An alias for --syms\n\
  --dyn-syms             Display the dynamic symbol table\n\
  -n --notes             Display the core notes (if present)\n\
  -r --relocs            Display the relocations (if present)\n\
  -u --unwind            Display the unwind info (if present)\n\
  -d --dynamic           Display the dynamic section (if present)\n\
  -V --version-info      Display the version sections (if present)\n\
  -A --arch-specific     Display architecture specific information (if any)\n\
  -c --archive-index     Display the symbol/file index in an archive\n\
  -D --use-dynamic       Use the dynamic section info when displaying symbols\n\
  -x --hex-dump=<number|name>\n\
                         Dump the contents of section <number|name> as bytes\n\
  -p --string-dump=<number|name>\n\
                         Dump the contents of section <number|name> as strings\n\
  -R --relocated-dump=<number|name>\n\
                         Dump the contents of section <number|name> as relocated bytes\n\
  -w[lLiaprmfFsoRt] or\n\
  --debug-dump[=rawline,=decodedline,=info,=abbrev,=pubnames,=aranges,=macro,=frames,\n\
               =frames-interp,=str,=loc,=Ranges,=pubtypes,\n\
               =gdb_index,=trace_info,=trace_abbrev,=trace_aranges,\n\
               =addr,=cu_index]\n\
                         Display the contents of DWARF2 debug sections\n"));
  fprintf (stream, _("\
  --dwarf-depth=N        Do not display DIEs at depth N or greater\n\
  --dwarf-start=N        Display DIEs starting with N, at the same depth\n\
                         or deeper\n"));
#ifdef SUPPORT_DISASSEMBLY
  fprintf (stream, _("\
  -i --instruction-dump=<number|name>\n\
                         Disassemble the contents of section <number|name>\n"));
#endif
  fprintf (stream, _("\
  -I --histogram         Display histogram of bucket list lengths\n\
  -W --wide              Allow output width to exceed 80 characters\n\
  @@<file>                Read options from <file>\n\
  -H --help              Display this information\n\
  -v --version           Display the version number of readelf\n"));

  if (REPORT_BUGS_TO[0] && stream == stdout)
    fprintf (stdout, _("Report bugs to %s\n"), REPORT_BUGS_TO);

  exit (stream == stdout ? 0 : 1);
}

/* Record the fact that the user wants the contents of section number
   SECTION to be displayed using the method(s) encoded as flags bits
   in TYPE.  Note, TYPE can be zero if we are creating the array for
   the first time.  */

static void
request_dump_bynumber (unsigned int section, dump_type type)
{
  if (section >= num_dump_sects)
    {
      dump_type * new_dump_sects;

      new_dump_sects = (dump_type *) calloc (section + 1,
                                             sizeof (* dump_sects));

      if (new_dump_sects == NULL)
	error (_("Out of memory allocating dump request table.\n"));
      else
	{
	  /* Copy current flag settings.  */
	  memcpy (new_dump_sects, dump_sects, num_dump_sects * sizeof (* dump_sects));

	  free (dump_sects);

	  dump_sects = new_dump_sects;
	  num_dump_sects = section + 1;
	}
    }

  if (dump_sects)
    dump_sects[section] |= type;

  return;
}

/* Request a dump by section name.  */

static void
request_dump_byname (const char * section, dump_type type)
{
  struct dump_list_entry * new_request;

  new_request = (struct dump_list_entry *)
      malloc (sizeof (struct dump_list_entry));
  if (!new_request)
    error (_("Out of memory allocating dump request table.\n"));

  new_request->name = strdup (section);
  if (!new_request->name)
    error (_("Out of memory allocating dump request table.\n"));

  new_request->type = type;

  new_request->next = dump_sects_byname;
  dump_sects_byname = new_request;
}

static inline void
request_dump (dump_type type)
{
  int section;
  char * cp;

  do_dump++;
  section = strtoul (optarg, & cp, 0);

  if (! *cp && section >= 0)
    request_dump_bynumber (section, type);
  else
    request_dump_byname (optarg, type);
}


static void
parse_args (int argc, char ** argv)
{
  int c;

  if (argc < 2)
    usage (stderr);

  while ((c = getopt_long
	  (argc, argv, "ADHINR:SVWacdeghi:lnp:rstuvw::x:", options, NULL)) != EOF)
    {
      switch (c)
	{
	case 0:
	  /* Long options.  */
	  break;
	case 'H':
	  usage (stdout);
	  break;

	case 'a':
	  do_syms++;
	  do_reloc++;
	  do_unwind++;
	  do_dynamic++;
	  do_header++;
	  do_sections++;
	  do_section_groups++;
	  do_segments++;
	  do_version++;
	  do_histogram++;
	  do_arch++;
	  do_notes++;
	  break;
	case 'g':
	  do_section_groups++;
	  break;
	case 't':
	case 'N':
	  do_sections++;
	  do_section_details++;
	  break;
	case 'e':
	  do_header++;
	  do_sections++;
	  do_segments++;
	  break;
	case 'A':
	  do_arch++;
	  break;
	case 'D':
	  do_using_dynamic++;
	  break;
	case 'r':
	  do_reloc++;
	  break;
	case 'u':
	  do_unwind++;
	  break;
	case 'h':
	  do_header++;
	  break;
	case 'l':
	  do_segments++;
	  break;
	case 's':
	  do_syms++;
	  break;
	case 'S':
	  do_sections++;
	  break;
	case 'd':
	  do_dynamic++;
	  break;
	case 'I':
	  do_histogram++;
	  break;
	case 'n':
	  do_notes++;
	  break;
	case 'c':
	  do_archive_index++;
	  break;
	case 'x':
	  request_dump (HEX_DUMP);
	  break;
	case 'p':
	  request_dump (STRING_DUMP);
	  break;
	case 'R':
	  request_dump (RELOC_DUMP);
	  break;
	case 'w':
	  do_dump++;
	  if (optarg == 0)
	    {
	      do_debugging = 1;
	      dwarf_select_sections_all ();
	    }
	  else
	    {
	      do_debugging = 0;
	      dwarf_select_sections_by_letters (optarg);
	    }
	  break;
	case OPTION_DEBUG_DUMP:
	  do_dump++;
	  if (optarg == 0)
	    do_debugging = 1;
	  else
	    {
	      do_debugging = 0;
	      dwarf_select_sections_by_names (optarg);
	    }
	  break;
	case OPTION_DWARF_DEPTH:
	  {
	    char *cp;

	    dwarf_cutoff_level = strtoul (optarg, & cp, 0);
	  }
	  break;
	case OPTION_DWARF_START:
	  {
	    char *cp;

	    dwarf_start_die = strtoul (optarg, & cp, 0);
	  }
	  break;
	case OPTION_DWARF_CHECK:
	  dwarf_check = 1;
	  break;
	case OPTION_DYN_SYMS:
	  do_dyn_syms++;
	  break;
#ifdef SUPPORT_DISASSEMBLY
	case 'i':
	  request_dump (DISASS_DUMP);
	  break;
#endif
	case 'v':
	  print_version (program_name);
	  break;
	case 'V':
	  do_version++;
	  break;
	case 'W':
	  do_wide++;
	  break;
	default:
	  /* xgettext:c-format */
	  error (_("Invalid option '-%c'\n"), c);
	  /* Drop through.  */
	case '?':
	  usage (stderr);
	}
    }

  if (!do_dynamic && !do_syms && !do_reloc && !do_unwind && !do_sections
      && !do_segments && !do_header && !do_dump && !do_version
      && !do_histogram && !do_debugging && !do_arch && !do_notes
      && !do_section_groups && !do_archive_index
      && !do_dyn_syms)
    usage (stderr);
  else if (argc < 3)
    {
      warn (_("Nothing to do.\n"));
      usage (stderr);
    }
}

static const char *
get_elf_class (unsigned int elf_class)
{
  static char buff[32];

  switch (elf_class)
    {
    case ELFCLASSNONE: return _("none");
    case ELFCLASS32:   return "ELF32";
    case ELFCLASS64:   return "ELF64";
    default:
      snprintf (buff, sizeof (buff), _("<unknown: %x>"), elf_class);
      return buff;
    }
}

static const char *
get_data_encoding (unsigned int encoding)
{
  static char buff[32];

  switch (encoding)
    {
    case ELFDATANONE: return _("none");
    case ELFDATA2LSB: return _("2's complement, little endian");
    case ELFDATA2MSB: return _("2's complement, big endian");
    default:
      snprintf (buff, sizeof (buff), _("<unknown: %x>"), encoding);
      return buff;
    }
}

/* Decode the data held in 'elf_header'.  */

static int
process_file_header (void)
{
  if (   elf_header.e_ident[EI_MAG0] != ELFMAG0
      || elf_header.e_ident[EI_MAG1] != ELFMAG1
      || elf_header.e_ident[EI_MAG2] != ELFMAG2
      || elf_header.e_ident[EI_MAG3] != ELFMAG3)
    {
      error
	(_("Not an ELF file - it has the wrong magic bytes at the start\n"));
      return 0;
    }

  init_dwarf_regnames (elf_header.e_machine);

  if (do_header)
    {
      int i;

      printf (_("ELF Header:\n"));
      printf (_("  Magic:   "));
      for (i = 0; i < EI_NIDENT; i++)
	printf ("%2.2x ", elf_header.e_ident[i]);
      printf ("\n");
      printf (_("  Class:                             %s\n"),
	      get_elf_class (elf_header.e_ident[EI_CLASS]));
      printf (_("  Data:                              %s\n"),
	      get_data_encoding (elf_header.e_ident[EI_DATA]));
      printf (_("  Version:                           %d %s\n"),
	      elf_header.e_ident[EI_VERSION],
	      (elf_header.e_ident[EI_VERSION] == EV_CURRENT
	       ? "(current)"
	       : (elf_header.e_ident[EI_VERSION] != EV_NONE
		  ? _("<unknown: %lx>")
		  : "")));
      printf (_("  OS/ABI:                            %s\n"),
	      get_osabi_name (elf_header.e_ident[EI_OSABI]));
      printf (_("  ABI Version:                       %d\n"),
	      elf_header.e_ident[EI_ABIVERSION]);
      printf (_("  Type:                              %s\n"),
	      get_file_type (elf_header.e_type));
      printf (_("  Machine:                           %s\n"),
	      get_machine_name (elf_header.e_machine));
      printf (_("  Version:                           0x%lx\n"),
	      (unsigned long) elf_header.e_version);

      printf (_("  Entry point address:               "));
      print_vma ((bfd_vma) elf_header.e_entry, PREFIX_HEX);
      printf (_("\n  Start of program headers:          "));
      print_vma ((bfd_vma) elf_header.e_phoff, DEC);
      printf (_(" (bytes into file)\n  Start of section headers:          "));
      print_vma ((bfd_vma) elf_header.e_shoff, DEC);
      printf (_(" (bytes into file)\n"));

      printf (_("  Flags:                             0x%lx%s\n"),
	      (unsigned long) elf_header.e_flags,
	      get_machine_flags (elf_header.e_flags, elf_header.e_machine));
      printf (_("  Size of this header:               %ld (bytes)\n"),
	      (long) elf_header.e_ehsize);
      printf (_("  Size of program headers:           %ld (bytes)\n"),
	      (long) elf_header.e_phentsize);
      printf (_("  Number of program headers:         %ld"),
	      (long) elf_header.e_phnum);
      if (section_headers != NULL
	  && elf_header.e_phnum == PN_XNUM
	  && section_headers[0].sh_info != 0)
	printf (" (%ld)", (long) section_headers[0].sh_info);
      putc ('\n', stdout);
      printf (_("  Size of section headers:           %ld (bytes)\n"),
	      (long) elf_header.e_shentsize);
      printf (_("  Number of section headers:         %ld"),
	      (long) elf_header.e_shnum);
      if (section_headers != NULL && elf_header.e_shnum == SHN_UNDEF)
	printf (" (%ld)", (long) section_headers[0].sh_size);
      putc ('\n', stdout);
      printf (_("  Section header string table index: %ld"),
	      (long) elf_header.e_shstrndx);
      if (section_headers != NULL
	  && elf_header.e_shstrndx == (SHN_XINDEX & 0xffff))
	printf (" (%u)", section_headers[0].sh_link);
      else if (elf_header.e_shstrndx != SHN_UNDEF
	       && elf_header.e_shstrndx >= elf_header.e_shnum)
	printf (_(" <corrupt: out of range>"));
      putc ('\n', stdout);
    }

  if (section_headers != NULL)
    {
      if (elf_header.e_phnum == PN_XNUM
	  && section_headers[0].sh_info != 0)
	elf_header.e_phnum = section_headers[0].sh_info;
      if (elf_header.e_shnum == SHN_UNDEF)
	elf_header.e_shnum = section_headers[0].sh_size;
      if (elf_header.e_shstrndx == (SHN_XINDEX & 0xffff))
	elf_header.e_shstrndx = section_headers[0].sh_link;
      else if (elf_header.e_shstrndx >= elf_header.e_shnum)
	elf_header.e_shstrndx = SHN_UNDEF;
      free (section_headers);
      section_headers = NULL;
    }

  return 1;
}


static int
get_32bit_program_headers (FILE * file, Elf_Internal_Phdr * pheaders)
{
  Elf32_External_Phdr * phdrs;
  Elf32_External_Phdr * external;
  Elf_Internal_Phdr *   internal;
  unsigned int i;

  phdrs = (Elf32_External_Phdr *) get_data (NULL, file, elf_header.e_phoff,
                                            elf_header.e_phentsize,
                                            elf_header.e_phnum,
                                            _("program headers"));
  if (!phdrs)
    return 0;

  for (i = 0, internal = pheaders, external = phdrs;
       i < elf_header.e_phnum;
       i++, internal++, external++)
    {
      internal->p_type   = BYTE_GET (external->p_type);
      internal->p_offset = BYTE_GET (external->p_offset);
      internal->p_vaddr  = BYTE_GET (external->p_vaddr);
      internal->p_paddr  = BYTE_GET (external->p_paddr);
      internal->p_filesz = BYTE_GET (external->p_filesz);
      internal->p_memsz  = BYTE_GET (external->p_memsz);
      internal->p_flags  = BYTE_GET (external->p_flags);
      internal->p_align  = BYTE_GET (external->p_align);
    }

  free (phdrs);

  return 1;
}

static int
get_64bit_program_headers (FILE * file, Elf_Internal_Phdr * pheaders)
{
  Elf64_External_Phdr * phdrs;
  Elf64_External_Phdr * external;
  Elf_Internal_Phdr *   internal;
  unsigned int i;

  phdrs = (Elf64_External_Phdr *) get_data (NULL, file, elf_header.e_phoff,
                                            elf_header.e_phentsize,
                                            elf_header.e_phnum,
                                            _("program headers"));
  if (!phdrs)
    return 0;

  for (i = 0, internal = pheaders, external = phdrs;
       i < elf_header.e_phnum;
       i++, internal++, external++)
    {
      internal->p_type   = BYTE_GET (external->p_type);
      internal->p_flags  = BYTE_GET (external->p_flags);
      internal->p_offset = BYTE_GET (external->p_offset);
      internal->p_vaddr  = BYTE_GET (external->p_vaddr);
      internal->p_paddr  = BYTE_GET (external->p_paddr);
      internal->p_filesz = BYTE_GET (external->p_filesz);
      internal->p_memsz  = BYTE_GET (external->p_memsz);
      internal->p_align  = BYTE_GET (external->p_align);
    }

  free (phdrs);

  return 1;
}

/* Returns 1 if the program headers were read into `program_headers'.  */

static int
get_program_headers (FILE * file)
{
  Elf_Internal_Phdr * phdrs;

  /* Check cache of prior read.  */
  if (program_headers != NULL)
    return 1;

  phdrs = (Elf_Internal_Phdr *) cmalloc (elf_header.e_phnum,
                                         sizeof (Elf_Internal_Phdr));

  if (phdrs == NULL)
    {
      error (_("Out of memory\n"));
      return 0;
    }

  if (is_32bit_elf
      ? get_32bit_program_headers (file, phdrs)
      : get_64bit_program_headers (file, phdrs))
    {
      program_headers = phdrs;
      return 1;
    }

  free (phdrs);
  return 0;
}

/* Returns 1 if the program headers were loaded.  */

static int
process_program_headers (FILE * file)
{
  Elf_Internal_Phdr * segment;
  unsigned int i;

  if (elf_header.e_phnum == 0)
    {
      /* PR binutils/12467.  */
      if (elf_header.e_phoff != 0)
	warn (_("possibly corrupt ELF header - it has a non-zero program"
		" header offset, but no program headers"));
      else if (do_segments)
	printf (_("\nThere are no program headers in this file.\n"));
      return 0;
    }

  if (do_segments && !do_header)
    {
      printf (_("\nElf file type is %s\n"), get_file_type (elf_header.e_type));
      printf (_("Entry point "));
      print_vma ((bfd_vma) elf_header.e_entry, PREFIX_HEX);
      printf (_("\nThere are %d program headers, starting at offset "),
	      elf_header.e_phnum);
      print_vma ((bfd_vma) elf_header.e_phoff, DEC);
      printf ("\n");
    }

  if (! get_program_headers (file))
      return 0;

  if (do_segments)
    {
      if (elf_header.e_phnum > 1)
	printf (_("\nProgram Headers:\n"));
      else
	printf (_("\nProgram Headers:\n"));

      if (is_32bit_elf)
	printf
	  (_("  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align\n"));
      else if (do_wide)
	printf
	  (_("  Type           Offset   VirtAddr           PhysAddr           FileSiz  MemSiz   Flg Align\n"));
      else
	{
	  printf
	    (_("  Type           Offset             VirtAddr           PhysAddr\n"));
	  printf
	    (_("                 FileSiz            MemSiz              Flags  Align\n"));
	}
    }

  dynamic_addr = 0;
  dynamic_size = 0;

  for (i = 0, segment = program_headers;
       i < elf_header.e_phnum;
       i++, segment++)
    {
      if (do_segments)
	{
	  printf ("  %-14.14s ", get_segment_type (segment->p_type));

	  if (is_32bit_elf)
	    {
	      printf ("0x%6.6lx ", (unsigned long) segment->p_offset);
	      printf ("0x%8.8lx ", (unsigned long) segment->p_vaddr);
	      printf ("0x%8.8lx ", (unsigned long) segment->p_paddr);
	      printf ("0x%5.5lx ", (unsigned long) segment->p_filesz);
	      printf ("0x%5.5lx ", (unsigned long) segment->p_memsz);
	      printf ("%c%c%c ",
		      (segment->p_flags & PF_R ? 'R' : ' '),
		      (segment->p_flags & PF_W ? 'W' : ' '),
		      (segment->p_flags & PF_X ? 'E' : ' '));
	      printf ("%#lx", (unsigned long) segment->p_align);
	    }
	  else if (do_wide)
	    {
	      if ((unsigned long) segment->p_offset == segment->p_offset)
		printf ("0x%6.6lx ", (unsigned long) segment->p_offset);
	      else
		{
		  print_vma (segment->p_offset, FULL_HEX);
		  putchar (' ');
		}

	      print_vma (segment->p_vaddr, FULL_HEX);
	      putchar (' ');
	      print_vma (segment->p_paddr, FULL_HEX);
	      putchar (' ');

	      if ((unsigned long) segment->p_filesz == segment->p_filesz)
		printf ("0x%6.6lx ", (unsigned long) segment->p_filesz);
	      else
		{
		  print_vma (segment->p_filesz, FULL_HEX);
		  putchar (' ');
		}

	      if ((unsigned long) segment->p_memsz == segment->p_memsz)
		printf ("0x%6.6lx", (unsigned long) segment->p_memsz);
	      else
		{
		  print_vma (segment->p_memsz, FULL_HEX);
		}

	      printf (" %c%c%c ",
		      (segment->p_flags & PF_R ? 'R' : ' '),
		      (segment->p_flags & PF_W ? 'W' : ' '),
		      (segment->p_flags & PF_X ? 'E' : ' '));

	      if ((unsigned long) segment->p_align == segment->p_align)
		printf ("%#lx", (unsigned long) segment->p_align);
	      else
		{
		  print_vma (segment->p_align, PREFIX_HEX);
		}
	    }
	  else
	    {
	      print_vma (segment->p_offset, FULL_HEX);
	      putchar (' ');
	      print_vma (segment->p_vaddr, FULL_HEX);
	      putchar (' ');
	      print_vma (segment->p_paddr, FULL_HEX);
	      printf ("\n                 ");
	      print_vma (segment->p_filesz, FULL_HEX);
	      putchar (' ');
	      print_vma (segment->p_memsz, FULL_HEX);
	      printf ("  %c%c%c    ",
		      (segment->p_flags & PF_R ? 'R' : ' '),
		      (segment->p_flags & PF_W ? 'W' : ' '),
		      (segment->p_flags & PF_X ? 'E' : ' '));
	      print_vma (segment->p_align, HEX);
	    }
	}

      switch (segment->p_type)
	{
	case PT_DYNAMIC:
	  if (dynamic_addr)
	    error (_("more than one dynamic segment\n"));

	  /* By default, assume that the .dynamic section is the first
	     section in the DYNAMIC segment.  */
	  dynamic_addr = segment->p_offset;
	  dynamic_size = segment->p_filesz;

	  /* Try to locate the .dynamic section. If there is
	     a section header table, we can easily locate it.  */
	  if (section_headers != NULL)
	    {
	      Elf_Internal_Shdr * sec;

	      sec = find_section (".dynamic");
	      if (sec == NULL || sec->sh_size == 0)
		{
                  /* A corresponding .dynamic section is expected, but on
                     IA-64/OpenVMS it is OK for it to be missing.  */
                  if (!is_ia64_vms ())
                    error (_("no .dynamic section in the dynamic segment\n"));
		  break;
		}

	      if (sec->sh_type == SHT_NOBITS)
		{
		  dynamic_size = 0;
		  break;
		}

	      dynamic_addr = sec->sh_offset;
	      dynamic_size = sec->sh_size;

	      if (dynamic_addr < segment->p_offset
		  || dynamic_addr > segment->p_offset + segment->p_filesz)
		warn (_("the .dynamic section is not contained"
			" within the dynamic segment\n"));
	      else if (dynamic_addr > segment->p_offset)
		warn (_("the .dynamic section is not the first section"
			" in the dynamic segment.\n"));
	    }
	  break;

	case PT_INTERP:
	  if (fseek (file, archive_file_offset + (long) segment->p_offset,
		     SEEK_SET))
	    error (_("Unable to find program interpreter name\n"));
	  else
	    {
	      char fmt [32];
	      int ret = snprintf (fmt, sizeof (fmt), "%%%ds", PATH_MAX);

	      if (ret >= (int) sizeof (fmt) || ret < 0)
		error (_("Internal error: failed to create format string to display program interpreter\n"));

	      program_interpreter[0] = 0;
	      if (fscanf (file, fmt, program_interpreter) <= 0)
		error (_("Unable to read program interpreter name\n"));

	      if (do_segments)
		printf (_("\n      [Requesting program interpreter: %s]"),
		    program_interpreter);
	    }
	  break;
	}

      if (do_segments)
	putc ('\n', stdout);
    }

  if (do_segments && section_headers != NULL && string_table != NULL)
    {
      printf (_("\n Section to Segment mapping:\n"));
      printf (_("  Segment Sections...\n"));

      for (i = 0; i < elf_header.e_phnum; i++)
	{
	  unsigned int j;
	  Elf_Internal_Shdr * section;

	  segment = program_headers + i;
	  section = section_headers + 1;

	  printf ("   %2.2d     ", i);

	  for (j = 1; j < elf_header.e_shnum; j++, section++)
	    {
	      if (!ELF_TBSS_SPECIAL (section, segment)
		  && ELF_SECTION_IN_SEGMENT_STRICT (section, segment))
		printf ("%s ", SECTION_NAME (section));
	    }

	  putc ('\n',stdout);
	}
    }

  return 1;
}


/* Find the file offset corresponding to VMA by using the program headers.  */

static long
offset_from_vma (FILE * file, bfd_vma vma, bfd_size_type size)
{
  Elf_Internal_Phdr * seg;

  if (! get_program_headers (file))
    {
      warn (_("Cannot interpret virtual addresses without program headers.\n"));
      return (long) vma;
    }

  for (seg = program_headers;
       seg < program_headers + elf_header.e_phnum;
       ++seg)
    {
      if (seg->p_type != PT_LOAD)
	continue;

      if (vma >= (seg->p_vaddr & -seg->p_align)
	  && vma + size <= seg->p_vaddr + seg->p_filesz)
	return vma - seg->p_vaddr + seg->p_offset;
    }

  warn (_("Virtual address 0x%lx not located in any PT_LOAD segment.\n"),
	(unsigned long) vma);
  return (long) vma;
}


static int
get_32bit_section_headers (FILE * file, unsigned int num)
{
  Elf32_External_Shdr * shdrs;
  Elf_Internal_Shdr *   internal;
  unsigned int i;

  shdrs = (Elf32_External_Shdr *) get_data (NULL, file, elf_header.e_shoff,
                                            elf_header.e_shentsize, num,
                                            _("section headers"));
  if (!shdrs)
    return 0;

  section_headers = (Elf_Internal_Shdr *) cmalloc (num,
                                                   sizeof (Elf_Internal_Shdr));

  if (section_headers == NULL)
    {
      error (_("Out of memory\n"));
      return 0;
    }

  for (i = 0, internal = section_headers;
       i < num;
       i++, internal++)
    {
      internal->sh_name      = BYTE_GET (shdrs[i].sh_name);
      internal->sh_type      = BYTE_GET (shdrs[i].sh_type);
      internal->sh_flags     = BYTE_GET (shdrs[i].sh_flags);
      internal->sh_addr      = BYTE_GET (shdrs[i].sh_addr);
      internal->sh_offset    = BYTE_GET (shdrs[i].sh_offset);
      internal->sh_size      = BYTE_GET (shdrs[i].sh_size);
      internal->sh_link      = BYTE_GET (shdrs[i].sh_link);
      internal->sh_info      = BYTE_GET (shdrs[i].sh_info);
      internal->sh_addralign = BYTE_GET (shdrs[i].sh_addralign);
      internal->sh_entsize   = BYTE_GET (shdrs[i].sh_entsize);
    }

  free (shdrs);

  return 1;
}

static int
get_64bit_section_headers (FILE * file, unsigned int num)
{
  Elf64_External_Shdr * shdrs;
  Elf_Internal_Shdr *   internal;
  unsigned int i;

  shdrs = (Elf64_External_Shdr *) get_data (NULL, file, elf_header.e_shoff,
                                            elf_header.e_shentsize, num,
                                            _("section headers"));
  if (!shdrs)
    return 0;

  section_headers = (Elf_Internal_Shdr *) cmalloc (num,
                                                   sizeof (Elf_Internal_Shdr));

  if (section_headers == NULL)
    {
      error (_("Out of memory\n"));
      return 0;
    }

  for (i = 0, internal = section_headers;
       i < num;
       i++, internal++)
    {
      internal->sh_name      = BYTE_GET (shdrs[i].sh_name);
      internal->sh_type      = BYTE_GET (shdrs[i].sh_type);
      internal->sh_flags     = BYTE_GET (shdrs[i].sh_flags);
      internal->sh_addr      = BYTE_GET (shdrs[i].sh_addr);
      internal->sh_size      = BYTE_GET (shdrs[i].sh_size);
      internal->sh_entsize   = BYTE_GET (shdrs[i].sh_entsize);
      internal->sh_link      = BYTE_GET (shdrs[i].sh_link);
      internal->sh_info      = BYTE_GET (shdrs[i].sh_info);
      internal->sh_offset    = BYTE_GET (shdrs[i].sh_offset);
      internal->sh_addralign = BYTE_GET (shdrs[i].sh_addralign);
    }

  free (shdrs);

  return 1;
}

static Elf_Internal_Sym *
get_32bit_elf_symbols (FILE * file,
		       Elf_Internal_Shdr * section,
		       unsigned long * num_syms_return)
{
  unsigned long number = 0;
  Elf32_External_Sym * esyms = NULL;
  Elf_External_Sym_Shndx * shndx = NULL;
  Elf_Internal_Sym * isyms = NULL;
  Elf_Internal_Sym * psym;
  unsigned int j;

  /* Run some sanity checks first.  */
  if (section->sh_entsize == 0)
    {
      error (_("sh_entsize is zero\n"));
      goto exit_point;
    }

  number = section->sh_size / section->sh_entsize;

  if (number * sizeof (Elf32_External_Sym) > section->sh_size + 1)
    {
      error (_("Invalid sh_entsize\n"));
      goto exit_point;
    }

  esyms = (Elf32_External_Sym *) get_data (NULL, file, section->sh_offset, 1,
                                           section->sh_size, _("symbols"));
  if (esyms == NULL)
    goto exit_point;

  shndx = NULL;
  if (symtab_shndx_hdr != NULL
      && (symtab_shndx_hdr->sh_link
	  == (unsigned long) (section - section_headers)))
    {
      shndx = (Elf_External_Sym_Shndx *) get_data (NULL, file,
                                                   symtab_shndx_hdr->sh_offset,
                                                   1, symtab_shndx_hdr->sh_size,
                                                   _("symbol table section indicies"));
      if (shndx == NULL)
	goto exit_point;
    }

  isyms = (Elf_Internal_Sym *) cmalloc (number, sizeof (Elf_Internal_Sym));

  if (isyms == NULL)
    {
      error (_("Out of memory\n"));
      goto exit_point;
    }

  for (j = 0, psym = isyms; j < number; j++, psym++)
    {
      psym->st_name  = BYTE_GET (esyms[j].st_name);
      psym->st_value = BYTE_GET (esyms[j].st_value);
      psym->st_size  = BYTE_GET (esyms[j].st_size);
      psym->st_shndx = BYTE_GET (esyms[j].st_shndx);
      if (psym->st_shndx == (SHN_XINDEX & 0xffff) && shndx != NULL)
	psym->st_shndx
	  = byte_get ((unsigned char *) &shndx[j], sizeof (shndx[j]));
      else if (psym->st_shndx >= (SHN_LORESERVE & 0xffff))
	psym->st_shndx += SHN_LORESERVE - (SHN_LORESERVE & 0xffff);
      psym->st_info  = BYTE_GET (esyms[j].st_info);
      psym->st_other = BYTE_GET (esyms[j].st_other);
    }

 exit_point:
  if (shndx != NULL)
    free (shndx);
  if (esyms != NULL)
    free (esyms);

  if (num_syms_return != NULL)
    * num_syms_return = isyms == NULL ? 0 : number;

  return isyms;
}

static Elf_Internal_Sym *
get_64bit_elf_symbols (FILE * file,
		       Elf_Internal_Shdr * section,
		       unsigned long * num_syms_return)
{
  unsigned long number = 0;
  Elf64_External_Sym * esyms = NULL;
  Elf_External_Sym_Shndx * shndx = NULL;
  Elf_Internal_Sym * isyms = NULL;
  Elf_Internal_Sym * psym;
  unsigned int j;

  /* Run some sanity checks first.  */
  if (section->sh_entsize == 0)
    {
      error (_("sh_entsize is zero\n"));
      goto exit_point;
    }

  number = section->sh_size / section->sh_entsize;

  if (number * sizeof (Elf64_External_Sym) > section->sh_size + 1)
    {
      error (_("Invalid sh_entsize\n"));
      goto exit_point;
    }

  esyms = (Elf64_External_Sym *) get_data (NULL, file, section->sh_offset, 1,
                                           section->sh_size, _("symbols"));
  if (!esyms)
    goto exit_point;

  if (symtab_shndx_hdr != NULL
      && (symtab_shndx_hdr->sh_link
	  == (unsigned long) (section - section_headers)))
    {
      shndx = (Elf_External_Sym_Shndx *) get_data (NULL, file,
                                                   symtab_shndx_hdr->sh_offset,
                                                   1, symtab_shndx_hdr->sh_size,
                                                   _("symbol table section indicies"));
      if (shndx == NULL)
	goto exit_point;
    }

  isyms = (Elf_Internal_Sym *) cmalloc (number, sizeof (Elf_Internal_Sym));

  if (isyms == NULL)
    {
      error (_("Out of memory\n"));
      goto exit_point;
    }

  for (j = 0, psym = isyms; j < number; j++, psym++)
    {
      psym->st_name  = BYTE_GET (esyms[j].st_name);
      psym->st_info  = BYTE_GET (esyms[j].st_info);
      psym->st_other = BYTE_GET (esyms[j].st_other);
      psym->st_shndx = BYTE_GET (esyms[j].st_shndx);

      if (psym->st_shndx == (SHN_XINDEX & 0xffff) && shndx != NULL)
	psym->st_shndx
	  = byte_get ((unsigned char *) &shndx[j], sizeof (shndx[j]));
      else if (psym->st_shndx >= (SHN_LORESERVE & 0xffff))
	psym->st_shndx += SHN_LORESERVE - (SHN_LORESERVE & 0xffff);

      psym->st_value = BYTE_GET (esyms[j].st_value);
      psym->st_size  = BYTE_GET (esyms[j].st_size);
    }

 exit_point:
  if (shndx != NULL)
    free (shndx);
  if (esyms != NULL)
    free (esyms);

  if (num_syms_return != NULL)
    * num_syms_return = isyms == NULL ? 0 : number;

  return isyms;
}

static const char *
get_elf_section_flags (bfd_vma sh_flags)
{
  static char buff[1024];
  char * p = buff;
  int field_size = is_32bit_elf ? 8 : 16;
  int sindex;
  int size = sizeof (buff) - (field_size + 4 + 1);
  bfd_vma os_flags = 0;
  bfd_vma proc_flags = 0;
  bfd_vma unknown_flags = 0;
  static const struct
    {
      const char * str;
      int len;
    }
  flags [] =
    {
      /*  0 */ { STRING_COMMA_LEN ("WRITE") },
      /*  1 */ { STRING_COMMA_LEN ("ALLOC") },
      /*  2 */ { STRING_COMMA_LEN ("EXEC") },
      /*  3 */ { STRING_COMMA_LEN ("MERGE") },
      /*  4 */ { STRING_COMMA_LEN ("STRINGS") },
      /*  5 */ { STRING_COMMA_LEN ("INFO LINK") },
      /*  6 */ { STRING_COMMA_LEN ("LINK ORDER") },
      /*  7 */ { STRING_COMMA_LEN ("OS NONCONF") },
      /*  8 */ { STRING_COMMA_LEN ("GROUP") },
      /*  9 */ { STRING_COMMA_LEN ("TLS") },
      /* IA-64 specific.  */
      /* 10 */ { STRING_COMMA_LEN ("SHORT") },
      /* 11 */ { STRING_COMMA_LEN ("NORECOV") },
      /* IA-64 OpenVMS specific.  */
      /* 12 */ { STRING_COMMA_LEN ("VMS_GLOBAL") },
      /* 13 */ { STRING_COMMA_LEN ("VMS_OVERLAID") },
      /* 14 */ { STRING_COMMA_LEN ("VMS_SHARED") },
      /* 15 */ { STRING_COMMA_LEN ("VMS_VECTOR") },
      /* 16 */ { STRING_COMMA_LEN ("VMS_ALLOC_64BIT") },
      /* 17 */ { STRING_COMMA_LEN ("VMS_PROTECTED") },
      /* Generic.  */
      /* 18 */ { STRING_COMMA_LEN ("EXCLUDE") },
      /* SPARC specific.  */
      /* 19 */ { STRING_COMMA_LEN ("ORDERED") }
    };

  if (do_section_details)
    {
      sprintf (buff, "[%*.*lx]: ",
	       field_size, field_size, (unsigned long) sh_flags);
      p += field_size + 4;
    }

  while (sh_flags)
    {
      bfd_vma flag;

      flag = sh_flags & - sh_flags;
      sh_flags &= ~ flag;

      if (do_section_details)
	{
	  switch (flag)
	    {
	    case SHF_WRITE:		sindex = 0; break;
	    case SHF_ALLOC:		sindex = 1; break;
	    case SHF_EXECINSTR:		sindex = 2; break;
	    case SHF_MERGE:		sindex = 3; break;
	    case SHF_STRINGS:		sindex = 4; break;
	    case SHF_INFO_LINK:		sindex = 5; break;
	    case SHF_LINK_ORDER:	sindex = 6; break;
	    case SHF_OS_NONCONFORMING:	sindex = 7; break;
	    case SHF_GROUP:		sindex = 8; break;
	    case SHF_TLS:		sindex = 9; break;
	    case SHF_EXCLUDE:		sindex = 18; break;

	    default:
	      sindex = -1;
	      switch (elf_header.e_machine)
		{
		case EM_IA_64:
		  if (flag == SHF_IA_64_SHORT)
		    sindex = 10;
		  else if (flag == SHF_IA_64_NORECOV)
		    sindex = 11;
#ifdef BFD64
		  else if (elf_header.e_ident[EI_OSABI] == ELFOSABI_OPENVMS)
		    switch (flag)
		      {
		      case SHF_IA_64_VMS_GLOBAL:      sindex = 12; break;
		      case SHF_IA_64_VMS_OVERLAID:    sindex = 13; break;
		      case SHF_IA_64_VMS_SHARED:      sindex = 14; break;
		      case SHF_IA_64_VMS_VECTOR:      sindex = 15; break;
		      case SHF_IA_64_VMS_ALLOC_64BIT: sindex = 16; break;
		      case SHF_IA_64_VMS_PROTECTED:   sindex = 17; break;
		      default:                        break;
		      }
#endif
		  break;

		case EM_386:
		case EM_486:
		case EM_X86_64:
		case EM_L1OM:
		case EM_K1OM:
		case EM_OLD_SPARCV9:
		case EM_SPARC32PLUS:
		case EM_SPARCV9:
		case EM_SPARC:
		  if (flag == SHF_ORDERED)
		    sindex = 19;
		  break;
		default:
		  break;
		}
	    }

	  if (sindex != -1)
	    {
	      if (p != buff + field_size + 4)
		{
		  if (size < (10 + 2))
		    abort ();
		  size -= 2;
		  *p++ = ',';
		  *p++ = ' ';
		}

	      size -= flags [sindex].len;
	      p = stpcpy (p, flags [sindex].str);
	    }
	  else if (flag & SHF_MASKOS)
	    os_flags |= flag;
	  else if (flag & SHF_MASKPROC)
	    proc_flags |= flag;
	  else
	    unknown_flags |= flag;
	}
      else
	{
	  switch (flag)
	    {
	    case SHF_WRITE:		*p = 'W'; break;
	    case SHF_ALLOC:		*p = 'A'; break;
	    case SHF_EXECINSTR:		*p = 'X'; break;
	    case SHF_MERGE:		*p = 'M'; break;
	    case SHF_STRINGS:		*p = 'S'; break;
	    case SHF_INFO_LINK:		*p = 'I'; break;
	    case SHF_LINK_ORDER:	*p = 'L'; break;
	    case SHF_OS_NONCONFORMING:	*p = 'O'; break;
	    case SHF_GROUP:		*p = 'G'; break;
	    case SHF_TLS:		*p = 'T'; break;
	    case SHF_EXCLUDE:		*p = 'E'; break;

	    default:
	      if ((elf_header.e_machine == EM_X86_64
		   || elf_header.e_machine == EM_L1OM
		   || elf_header.e_machine == EM_K1OM)
		  && flag == SHF_X86_64_LARGE)
		*p = 'l';
	      else if (flag & SHF_MASKOS)
		{
		  *p = 'o';
		  sh_flags &= ~ SHF_MASKOS;
		}
	      else if (flag & SHF_MASKPROC)
		{
		  *p = 'p';
		  sh_flags &= ~ SHF_MASKPROC;
		}
	      else
		*p = 'x';
	      break;
	    }
	  p++;
	}
    }

  if (do_section_details)
    {
      if (os_flags)
	{
	  size -= 5 + field_size;
	  if (p != buff + field_size + 4)
	    {
	      if (size < (2 + 1))
		abort ();
	      size -= 2;
	      *p++ = ',';
	      *p++ = ' ';
	    }
	  sprintf (p, "OS (%*.*lx)", field_size, field_size,
		   (unsigned long) os_flags);
	  p += 5 + field_size;
	}
      if (proc_flags)
	{
	  size -= 7 + field_size;
	  if (p != buff + field_size + 4)
	    {
	      if (size < (2 + 1))
		abort ();
	      size -= 2;
	      *p++ = ',';
	      *p++ = ' ';
	    }
	  sprintf (p, "PROC (%*.*lx)", field_size, field_size,
		   (unsigned long) proc_flags);
	  p += 7 + field_size;
	}
      if (unknown_flags)
	{
	  size -= 10 + field_size;
	  if (p != buff + field_size + 4)
	    {
	      if (size < (2 + 1))
		abort ();
	      size -= 2;
	      *p++ = ',';
	      *p++ = ' ';
	    }
	  sprintf (p, _("UNKNOWN (%*.*lx)"), field_size, field_size,
		   (unsigned long) unknown_flags);
	  p += 10 + field_size;
	}
    }

  *p = '\0';
  return buff;
}

static int
process_section_headers (FILE * file)
{
  Elf_Internal_Shdr * section;
  unsigned int i;

  section_headers = NULL;

  if (elf_header.e_shnum == 0)
    {
      /* PR binutils/12467.  */
      if (elf_header.e_shoff != 0)
	warn (_("possibly corrupt ELF file header - it has a non-zero"
		" section header offset, but no section headers\n"));
      else if (do_sections)
	printf (_("\nThere are no sections in this file.\n"));

      return 1;
    }

  if (do_sections && !do_header)
    printf (_("There are %d section headers, starting at offset 0x%lx:\n"),
	    elf_header.e_shnum, (unsigned long) elf_header.e_shoff);

  if (is_32bit_elf)
    {
      if (! get_32bit_section_headers (file, elf_header.e_shnum))
	return 0;
    }
  else if (! get_64bit_section_headers (file, elf_header.e_shnum))
    return 0;

  /* Read in the string table, so that we have names to display.  */
  if (elf_header.e_shstrndx != SHN_UNDEF
       && elf_header.e_shstrndx < elf_header.e_shnum)
    {
      section = section_headers + elf_header.e_shstrndx;

      if (section->sh_size != 0)
	{
	  string_table = (char *) get_data (NULL, file, section->sh_offset,
                                            1, section->sh_size,
                                            _("string table"));

	  string_table_length = string_table != NULL ? section->sh_size : 0;
	}
    }

  /* Scan the sections for the dynamic symbol table
     and dynamic string table and debug sections.  */
  dynamic_symbols = NULL;
  dynamic_strings = NULL;
  dynamic_syminfo = NULL;
  symtab_shndx_hdr = NULL;

  eh_addr_size = is_32bit_elf ? 4 : 8;
  switch (elf_header.e_machine)
    {
    case EM_MIPS:
    case EM_MIPS_RS3_LE:
      /* The 64-bit MIPS EABI uses a combination of 32-bit ELF and 64-bit
	 FDE addresses.  However, the ABI also has a semi-official ILP32
	 variant for which the normal FDE address size rules apply.

	 GCC 4.0 marks EABI64 objects with a dummy .gcc_compiled_longXX
	 section, where XX is the size of longs in bits.  Unfortunately,
	 earlier compilers provided no way of distinguishing ILP32 objects
	 from LP64 objects, so if there's any doubt, we should assume that
	 the official LP64 form is being used.  */
      if ((elf_header.e_flags & EF_MIPS_ABI) == E_MIPS_ABI_EABI64
	  && find_section (".gcc_compiled_long32") == NULL)
	eh_addr_size = 8;
      break;

    case EM_H8_300:
    case EM_H8_300H:
      switch (elf_header.e_flags & EF_H8_MACH)
	{
	case E_H8_MACH_H8300:
	case E_H8_MACH_H8300HN:
	case E_H8_MACH_H8300SN:
	case E_H8_MACH_H8300SXN:
	  eh_addr_size = 2;
	  break;
	case E_H8_MACH_H8300H:
	case E_H8_MACH_H8300S:
	case E_H8_MACH_H8300SX:
	  eh_addr_size = 4;
	  break;
	}
      break;

    case EM_M32C_OLD:
    case EM_M32C:
      switch (elf_header.e_flags & EF_M32C_CPU_MASK)
	{
	case EF_M32C_CPU_M16C:
	  eh_addr_size = 2;
	  break;
	}
      break;
    }

#define CHECK_ENTSIZE_VALUES(section, i, size32, size64) \
  do									    \
    {									    \
      bfd_size_type expected_entsize = is_32bit_elf ? size32 : size64;	    \
      if (section->sh_entsize != expected_entsize)			    \
	{								\
	  error (_("Section %d has invalid sh_entsize of %" BFD_VMA_FMT "x\n"), \
		 i, section->sh_entsize);	\
	  error (_("(Using the expected size of %d for the rest of this dump)\n"), \
		   (int) expected_entsize); \
	  section->sh_entsize = expected_entsize;			\
	} \
    }									    \
  while (0)

#define CHECK_ENTSIZE(section, i, type)					\
  CHECK_ENTSIZE_VALUES (section, i, sizeof (Elf32_External_##type),	    \
			sizeof (Elf64_External_##type))

  for (i = 0, section = section_headers;
       i < elf_header.e_shnum;
       i++, section++)
    {
      char * name = SECTION_NAME (section);

      if (section->sh_type == SHT_DYNSYM)
	{
	  if (dynamic_symbols != NULL)
	    {
	      error (_("File contains multiple dynamic symbol tables\n"));
	      continue;
	    }

	  CHECK_ENTSIZE (section, i, Sym);
	  dynamic_symbols = GET_ELF_SYMBOLS (file, section, & num_dynamic_syms);
	}
      else if (section->sh_type == SHT_STRTAB
	       && streq (name, ".dynstr"))
	{
	  if (dynamic_strings != NULL)
	    {
	      error (_("File contains multiple dynamic string tables\n"));
	      continue;
	    }

	  dynamic_strings = (char *) get_data (NULL, file, section->sh_offset,
                                               1, section->sh_size,
                                               _("dynamic strings"));
	  dynamic_strings_length = dynamic_strings == NULL ? 0 : section->sh_size;
	}
      else if (section->sh_type == SHT_SYMTAB_SHNDX)
	{
	  if (symtab_shndx_hdr != NULL)
	    {
	      error (_("File contains multiple symtab shndx tables\n"));
	      continue;
	    }
	  symtab_shndx_hdr = section;
	}
      else if (section->sh_type == SHT_SYMTAB)
	CHECK_ENTSIZE (section, i, Sym);
      else if (section->sh_type == SHT_GROUP)
	CHECK_ENTSIZE_VALUES (section, i, GRP_ENTRY_SIZE, GRP_ENTRY_SIZE);
      else if (section->sh_type == SHT_REL)
	CHECK_ENTSIZE (section, i, Rel);
      else if (section->sh_type == SHT_RELA)
	CHECK_ENTSIZE (section, i, Rela);
      else if ((do_debugging || do_debug_info || do_debug_abbrevs
		|| do_debug_lines || do_debug_pubnames || do_debug_pubtypes
		|| do_debug_aranges || do_debug_frames || do_debug_macinfo
		|| do_debug_str || do_debug_loc || do_debug_ranges
		|| do_debug_addr || do_debug_cu_index)
	       && (const_strneq (name, ".debug_")
                   || const_strneq (name, ".zdebug_")))
	{
          if (name[1] == 'z')
            name += sizeof (".zdebug_") - 1;
          else
            name += sizeof (".debug_") - 1;

	  if (do_debugging
	      || (do_debug_info     && const_strneq (name, "info"))
	      || (do_debug_info     && const_strneq (name, "types"))
	      || (do_debug_abbrevs  && const_strneq (name, "abbrev"))
	      || (do_debug_lines    && strcmp (name, "line") == 0)
	      || (do_debug_lines    && const_strneq (name, "line."))
	      || (do_debug_pubnames && const_strneq (name, "pubnames"))
	      || (do_debug_pubtypes && const_strneq (name, "pubtypes"))
	      || (do_debug_aranges  && const_strneq (name, "aranges"))
	      || (do_debug_ranges   && const_strneq (name, "ranges"))
	      || (do_debug_frames   && const_strneq (name, "frame"))
	      || (do_debug_macinfo  && const_strneq (name, "macinfo"))
	      || (do_debug_macinfo  && const_strneq (name, "macro"))
	      || (do_debug_str      && const_strneq (name, "str"))
	      || (do_debug_loc      && const_strneq (name, "loc"))
	      || (do_debug_addr     && const_strneq (name, "addr"))
	      || (do_debug_cu_index && const_strneq (name, "cu_index"))
	      || (do_debug_cu_index && const_strneq (name, "tu_index"))
	      )
	    request_dump_bynumber (i, DEBUG_DUMP);
	}
      /* Linkonce section to be combined with .debug_info at link time.  */
      else if ((do_debugging || do_debug_info)
	       && const_strneq (name, ".gnu.linkonce.wi."))
	request_dump_bynumber (i, DEBUG_DUMP);
      else if (do_debug_frames && streq (name, ".eh_frame"))
	request_dump_bynumber (i, DEBUG_DUMP);
      else if (do_gdb_index && streq (name, ".gdb_index"))
	request_dump_bynumber (i, DEBUG_DUMP);
      /* Trace sections for Itanium VMS.  */
      else if ((do_debugging || do_trace_info || do_trace_abbrevs
                || do_trace_aranges)
	       && const_strneq (name, ".trace_"))
	{
          name += sizeof (".trace_") - 1;

	  if (do_debugging
	      || (do_trace_info     && streq (name, "info"))
	      || (do_trace_abbrevs  && streq (name, "abbrev"))
	      || (do_trace_aranges  && streq (name, "aranges"))
	      )
	    request_dump_bynumber (i, DEBUG_DUMP);
	}

    }

  if (! do_sections)
    return 1;

  if (elf_header.e_shnum > 1)
    printf (_("\nSection Headers:\n"));
  else
    printf (_("\nSection Header:\n"));

  if (is_32bit_elf)
    {
      if (do_section_details)
	{
	  printf (_("  [Nr] Name\n"));
	  printf (_("       Type            Addr     Off    Size   ES   Lk Inf Al\n"));
	}
      else
	printf
	  (_("  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al\n"));
    }
  else if (do_wide)
    {
      if (do_section_details)
	{
	  printf (_("  [Nr] Name\n"));
	  printf (_("       Type            Address          Off    Size   ES   Lk Inf Al\n"));
	}
      else
	printf
	  (_("  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al\n"));
    }
  else
    {
      if (do_section_details)
	{
	  printf (_("  [Nr] Name\n"));
	  printf (_("       Type              Address          Offset            Link\n"));
	  printf (_("       Size              EntSize          Info              Align\n"));
	}
      else
	{
	  printf (_("  [Nr] Name              Type             Address           Offset\n"));
	  printf (_("       Size              EntSize          Flags  Link  Info  Align\n"));
	}
    }

  if (do_section_details)
    printf (_("       Flags\n"));

  for (i = 0, section = section_headers;
       i < elf_header.e_shnum;
       i++, section++)
    {
      printf ("  [%2u] ", i);
      if (do_section_details)
	{
	  print_symbol (INT_MAX, SECTION_NAME (section));
	  printf ("\n      ");
	}
      else
	{
	  print_symbol (-17, SECTION_NAME (section));
	}

      printf (do_wide ? " %-15s " : " %-15.15s ",
	      get_section_type_name (section->sh_type));

      if (is_32bit_elf)
	{
	  const char * link_too_big = NULL;

	  print_vma (section->sh_addr, LONG_HEX);

	  printf ( " %6.6lx %6.6lx %2.2lx",
		   (unsigned long) section->sh_offset,
		   (unsigned long) section->sh_size,
		   (unsigned long) section->sh_entsize);

	  if (do_section_details)
	    fputs ("  ", stdout);
	  else
	    printf (" %3s ", get_elf_section_flags (section->sh_flags));

	  if (section->sh_link >= elf_header.e_shnum)
	    {
	      link_too_big = "";
	      /* The sh_link value is out of range.  Normally this indicates
		 an error but it can have special values in Solaris binaries.  */
	      switch (elf_header.e_machine)
		{
		case EM_386:
		case EM_486:
		case EM_X86_64:
		case EM_L1OM:
		case EM_K1OM:
		case EM_OLD_SPARCV9:
		case EM_SPARC32PLUS:
		case EM_SPARCV9:
		case EM_SPARC:
		  if (section->sh_link == (SHN_BEFORE & 0xffff))
		    link_too_big = "BEFORE";
		  else if (section->sh_link == (SHN_AFTER & 0xffff))
		    link_too_big = "AFTER";
		  break;
		default:
		  break;
		}
	    }

	  if (do_section_details)
	    {
	      if (link_too_big != NULL && * link_too_big)
		printf ("<%s> ", link_too_big);
	      else
		printf ("%2u ", section->sh_link);
	      printf ("%3u %2lu\n", section->sh_info,
		      (unsigned long) section->sh_addralign);
	    }
	  else
	    printf ("%2u %3u %2lu\n",
		    section->sh_link,
		    section->sh_info,
		    (unsigned long) section->sh_addralign);

	  if (link_too_big && ! * link_too_big)
	    warn (_("section %u: sh_link value of %u is larger than the number of sections\n"),
		  i, section->sh_link);
	}
      else if (do_wide)
	{
	  print_vma (section->sh_addr, LONG_HEX);

	  if ((long) section->sh_offset == section->sh_offset)
	    printf (" %6.6lx", (unsigned long) section->sh_offset);
	  else
	    {
	      putchar (' ');
	      print_vma (section->sh_offset, LONG_HEX);
	    }

	  if ((unsigned long) section->sh_size == section->sh_size)
	    printf (" %6.6lx", (unsigned long) section->sh_size);
	  else
	    {
	      putchar (' ');
	      print_vma (section->sh_size, LONG_HEX);
	    }

	  if ((unsigned long) section->sh_entsize == section->sh_entsize)
	    printf (" %2.2lx", (unsigned long) section->sh_entsize);
	  else
	    {
	      putchar (' ');
	      print_vma (section->sh_entsize, LONG_HEX);
	    }

	  if (do_section_details)
	    fputs ("  ", stdout);
	  else
	    printf (" %3s ", get_elf_section_flags (section->sh_flags));

	  printf ("%2u %3u ", section->sh_link, section->sh_info);

	  if ((unsigned long) section->sh_addralign == section->sh_addralign)
	    printf ("%2lu\n", (unsigned long) section->sh_addralign);
	  else
	    {
	      print_vma (section->sh_addralign, DEC);
	      putchar ('\n');
	    }
	}
      else if (do_section_details)
	{
	  printf ("       %-15.15s  ",
		  get_section_type_name (section->sh_type));
	  print_vma (section->sh_addr, LONG_HEX);
	  if ((long) section->sh_offset == section->sh_offset)
	    printf ("  %16.16lx", (unsigned long) section->sh_offset);
	  else
	    {
	      printf ("  ");
	      print_vma (section->sh_offset, LONG_HEX);
	    }
	  printf ("  %u\n       ", section->sh_link);
	  print_vma (section->sh_size, LONG_HEX);
	  putchar (' ');
	  print_vma (section->sh_entsize, LONG_HEX);

	  printf ("  %-16u  %lu\n",
		  section->sh_info,
		  (unsigned long) section->sh_addralign);
	}
      else
	{
	  putchar (' ');
	  print_vma (section->sh_addr, LONG_HEX);
	  if ((long) section->sh_offset == section->sh_offset)
	    printf ("  %8.8lx", (unsigned long) section->sh_offset);
	  else
	    {
	      printf ("  ");
	      print_vma (section->sh_offset, LONG_HEX);
	    }
	  printf ("\n       ");
	  print_vma (section->sh_size, LONG_HEX);
	  printf ("  ");
	  print_vma (section->sh_entsize, LONG_HEX);

	  printf (" %3s ", get_elf_section_flags (section->sh_flags));

	  printf ("     %2u   %3u     %lu\n",
		  section->sh_link,
		  section->sh_info,
		  (unsigned long) section->sh_addralign);
	}

      if (do_section_details)
	printf ("       %s\n", get_elf_section_flags (section->sh_flags));
    }

  if (!do_section_details)
    {
      if (elf_header.e_machine == EM_X86_64
	  || elf_header.e_machine == EM_L1OM
	  || elf_header.e_machine == EM_K1OM)
	printf (_("Key to Flags:\n\
  W (write), A (alloc), X (execute), M (merge), S (strings), l (large)\n\
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)\n\
  O (extra OS processing required) o (OS specific), p (processor specific)\n"));
      else
	printf (_("Key to Flags:\n\
  W (write), A (alloc), X (execute), M (merge), S (strings)\n\
  I (info), L (link order), G (group), T (TLS), E (exclude), x (unknown)\n\
  O (extra OS processing required) o (OS specific), p (processor specific)\n"));
    }

  return 1;
}

static const char *
get_group_flags (unsigned int flags)
{
  static char buff[32];
  switch (flags)
    {
    case 0:
      return "";

    case GRP_COMDAT:
      return "COMDAT ";

   default:
      snprintf (buff, sizeof (buff), _("[<unknown>: 0x%x] "), flags);
      break;
    }
  return buff;
}

static int
process_section_groups (FILE * file)
{
  Elf_Internal_Shdr * section;
  unsigned int i;
  struct group * group;
  Elf_Internal_Shdr * symtab_sec;
  Elf_Internal_Shdr * strtab_sec;
  Elf_Internal_Sym * symtab;
  unsigned long num_syms;
  char * strtab;
  size_t strtab_size;

  /* Don't process section groups unless needed.  */
  if (!do_unwind && !do_section_groups)
    return 1;

  if (elf_header.e_shnum == 0)
    {
      if (do_section_groups)
	printf (_("\nThere are no sections to group in this file.\n"));

      return 1;
    }

  if (section_headers == NULL)
    {
      error (_("Section headers are not available!\n"));
      /* PR 13622: This can happen with a corrupt ELF header.  */
      return 0;
    }

  section_headers_groups = (struct group **) calloc (elf_header.e_shnum,
                                                     sizeof (struct group *));

  if (section_headers_groups == NULL)
    {
      error (_("Out of memory\n"));
      return 0;
    }

  /* Scan the sections for the group section.  */
  group_count = 0;
  for (i = 0, section = section_headers;
       i < elf_header.e_shnum;
       i++, section++)
    if (section->sh_type == SHT_GROUP)
      group_count++;

  if (group_count == 0)
    {
      if (do_section_groups)
	printf (_("\nThere are no section groups in this file.\n"));

      return 1;
    }

  section_groups = (struct group *) calloc (group_count, sizeof (struct group));

  if (section_groups == NULL)
    {
      error (_("Out of memory\n"));
      return 0;
    }

  symtab_sec = NULL;
  strtab_sec = NULL;
  symtab = NULL;
  num_syms = 0;
  strtab = NULL;
  strtab_size = 0;
  for (i = 0, section = section_headers, group = section_groups;
       i < elf_header.e_shnum;
       i++, section++)
    {
      if (section->sh_type == SHT_GROUP)
	{
	  char * name = SECTION_NAME (section);
	  char * group_name;
	  unsigned char * start;
	  unsigned char * indices;
	  unsigned int entry, j, size;
	  Elf_Internal_Shdr * sec;
	  Elf_Internal_Sym * sym;

	  /* Get the symbol table.  */
	  if (section->sh_link >= elf_header.e_shnum
	      || ((sec = section_headers + section->sh_link)->sh_type
		  != SHT_SYMTAB))
	    {
	      error (_("Bad sh_link in group section `%s'\n"), name);
	      continue;
	    }

	  if (symtab_sec != sec)
	    {
	      symtab_sec = sec;
	      if (symtab)
		free (symtab);
	      symtab = GET_ELF_SYMBOLS (file, symtab_sec, & num_syms);
	    }

	  if (symtab == NULL)
	    {
	      error (_("Corrupt header in group section `%s'\n"), name);
	      continue;
	    }

	  if (section->sh_info >= num_syms)
	    {
	      error (_("Bad sh_info in group section `%s'\n"), name);
	      continue;
	    }

	  sym = symtab + section->sh_info;

	  if (ELF_ST_TYPE (sym->st_info) == STT_SECTION)
	    {
	      if (sym->st_shndx == 0
		  || sym->st_shndx >= elf_header.e_shnum)
		{
		  error (_("Bad sh_info in group section `%s'\n"), name);
		  continue;
		}

	      group_name = SECTION_NAME (section_headers + sym->st_shndx);
	      strtab_sec = NULL;
	      if (strtab)
		free (strtab);
	      strtab = NULL;
	      strtab_size = 0;
	    }
	  else
	    {
	      /* Get the string table.  */
	      if (symtab_sec->sh_link >= elf_header.e_shnum)
		{
		  strtab_sec = NULL;
		  if (strtab)
		    free (strtab);
		  strtab = NULL;
		  strtab_size = 0;
		}
	      else if (strtab_sec
		       != (sec = section_headers + symtab_sec->sh_link))
		{
		  strtab_sec = sec;
		  if (strtab)
		    free (strtab);
		  strtab = (char *) get_data (NULL, file, strtab_sec->sh_offset,
                                              1, strtab_sec->sh_size,
                                              _("string table"));
		  strtab_size = strtab != NULL ? strtab_sec->sh_size : 0;
		}
	      group_name = sym->st_name < strtab_size
		? strtab + sym->st_name : _("<corrupt>");
	    }

	  start = (unsigned char *) get_data (NULL, file, section->sh_offset,
                                              1, section->sh_size,
                                              _("section data"));
	  if (start == NULL)
	    continue;

	  indices = start;
	  size = (section->sh_size / section->sh_entsize) - 1;
	  entry = byte_get (indices, 4);
	  indices += 4;

	  if (do_section_groups)
	    {
	      printf (_("\n%sgroup section [%5u] `%s' [%s] contains %u sections:\n"),
		      get_group_flags (entry), i, name, group_name, size);

	      printf (_("   [Index]    Name\n"));
	    }

	  group->group_index = i;

	  for (j = 0; j < size; j++)
	    {
	      struct group_list * g;

	      entry = byte_get (indices, 4);
	      indices += 4;

	      if (entry >= elf_header.e_shnum)
		{
		  error (_("section [%5u] in group section [%5u] > maximum section [%5u]\n"),
			 entry, i, elf_header.e_shnum - 1);
		  continue;
		}

	      if (section_headers_groups [entry] != NULL)
		{
		  if (entry)
		    {
		      error (_("section [%5u] in group section [%5u] already in group section [%5u]\n"),
			     entry, i,
			     section_headers_groups [entry]->group_index);
		      continue;
		    }
		  else
		    {
		      /* Intel C/C++ compiler may put section 0 in a
			 section group. We just warn it the first time
			 and ignore it afterwards.  */
		      static int warned = 0;
		      if (!warned)
			{
			  error (_("section 0 in group section [%5u]\n"),
				 section_headers_groups [entry]->group_index);
			  warned++;
			}
		    }
		}

	      section_headers_groups [entry] = group;

	      if (do_section_groups)
		{
		  sec = section_headers + entry;
		  printf ("   [%5u]   %s\n", entry, SECTION_NAME (sec));
		}

	      g = (struct group_list *) xmalloc (sizeof (struct group_list));
	      g->section_index = entry;
	      g->next = group->root;
	      group->root = g;
	    }

	  if (start)
	    free (start);

	  group++;
	}
    }

  if (symtab)
    free (symtab);
  if (strtab)
    free (strtab);
  return 1;
}

/* Data used to display dynamic fixups.  */

struct ia64_vms_dynfixup
{
  bfd_vma needed_ident;		/* Library ident number.  */
  bfd_vma needed;		/* Index in the dstrtab of the library name.  */
  bfd_vma fixup_needed;		/* Index of the library.  */
  bfd_vma fixup_rela_cnt;	/* Number of fixups.  */
  bfd_vma fixup_rela_off;	/* Fixups offset in the dynamic segment.  */
};

/* Data used to display dynamic relocations.  */

struct ia64_vms_dynimgrela
{
  bfd_vma img_rela_cnt;		/* Number of relocations.  */
  bfd_vma img_rela_off;		/* Reloc offset in the dynamic segment.  */
};

/* Display IA-64 OpenVMS dynamic fixups (used to dynamically link a shared
   library).  */

static void
dump_ia64_vms_dynamic_fixups (FILE *file, struct ia64_vms_dynfixup *fixup,
                              const char *strtab, unsigned int strtab_sz)
{
  Elf64_External_VMS_IMAGE_FIXUP *imfs;
  long i;
  const char *lib_name;

  imfs = get_data (NULL, file, dynamic_addr + fixup->fixup_rela_off,
		   1, fixup->fixup_rela_cnt * sizeof (*imfs),
		   _("dynamic section image fixups"));
  if (!imfs)
    return;

  if (fixup->needed < strtab_sz)
    lib_name = strtab + fixup->needed;
  else
    {
      warn ("corrupt library name index of 0x%lx found in dynamic entry",
            (unsigned long) fixup->needed);
      lib_name = "???";
    }
  printf (_("\nImage fixups for needed library #%d: %s - ident: %lx\n"),
	  (int) fixup->fixup_needed, lib_name, (long) fixup->needed_ident);
  printf
    (_("Seg Offset           Type                             SymVec DataType\n"));

  for (i = 0; i < (long) fixup->fixup_rela_cnt; i++)
    {
      unsigned int type;
      const char *rtype;

      printf ("%3u ", (unsigned) BYTE_GET (imfs [i].fixup_seg));
      printf_vma ((bfd_vma) BYTE_GET (imfs [i].fixup_offset));
      type = BYTE_GET (imfs [i].type);
      rtype = elf_ia64_reloc_type (type);
      if (rtype == NULL)
        printf (" 0x%08x                       ", type);
      else
        printf (" %-32s ", rtype);
      printf ("%6u ", (unsigned) BYTE_GET (imfs [i].symvec_index));
      printf ("0x%08x\n", (unsigned) BYTE_GET (imfs [i].data_type));
    }

  free (imfs);
}

/* Display IA-64 OpenVMS dynamic relocations (used to relocate an image).  */

static void
dump_ia64_vms_dynamic_relocs (FILE *file, struct ia64_vms_dynimgrela *imgrela)
{
  Elf64_External_VMS_IMAGE_RELA *imrs;
  long i;

  imrs = get_data (NULL, file, dynamic_addr + imgrela->img_rela_off,
		   1, imgrela->img_rela_cnt * sizeof (*imrs),
		   _("dynamic section image relocations"));
  if (!imrs)
    return;

  printf (_("\nImage relocs\n"));
  printf
    (_("Seg Offset   Type                            Addend            Seg Sym Off\n"));

  for (i = 0; i < (long) imgrela->img_rela_cnt; i++)
    {
      unsigned int type;
      const char *rtype;

      printf ("%3u ", (unsigned) BYTE_GET (imrs [i].rela_seg));
      printf ("%08" BFD_VMA_FMT "x ",
              (bfd_vma) BYTE_GET (imrs [i].rela_offset));
      type = BYTE_GET (imrs [i].type);
      rtype = elf_ia64_reloc_type (type);
      if (rtype == NULL)
        printf ("0x%08x                      ", type);
      else
        printf ("%-31s ", rtype);
      print_vma (BYTE_GET (imrs [i].addend), FULL_HEX);
      printf ("%3u ", (unsigned) BYTE_GET (imrs [i].sym_seg));
      printf ("%08" BFD_VMA_FMT "x\n",
              (bfd_vma) BYTE_GET (imrs [i].sym_offset));
    }

  free (imrs);
}

/* Display IA-64 OpenVMS dynamic relocations and fixups.  */

static int
process_ia64_vms_dynamic_relocs (FILE *file)
{
  struct ia64_vms_dynfixup fixup;
  struct ia64_vms_dynimgrela imgrela;
  Elf_Internal_Dyn *entry;
  int res = 0;
  bfd_vma strtab_off = 0;
  bfd_vma strtab_sz = 0;
  char *strtab = NULL;

  memset (&fixup, 0, sizeof (fixup));
  memset (&imgrela, 0, sizeof (imgrela));

  /* Note: the order of the entries is specified by the OpenVMS specs.  */
  for (entry = dynamic_section;
       entry < dynamic_section + dynamic_nent;
       entry++)
    {
      switch (entry->d_tag)
        {
        case DT_IA_64_VMS_STRTAB_OFFSET:
          strtab_off = entry->d_un.d_val;
          break;
        case DT_STRSZ:
          strtab_sz = entry->d_un.d_val;
          if (strtab == NULL)
            strtab = get_data (NULL, file, dynamic_addr + strtab_off,
                               1, strtab_sz, _("dynamic string section"));
          break;

        case DT_IA_64_VMS_NEEDED_IDENT:
          fixup.needed_ident = entry->d_un.d_val;
          break;
        case DT_NEEDED:
          fixup.needed = entry->d_un.d_val;
          break;
        case DT_IA_64_VMS_FIXUP_NEEDED:
          fixup.fixup_needed = entry->d_un.d_val;
          break;
        case DT_IA_64_VMS_FIXUP_RELA_CNT:
          fixup.fixup_rela_cnt = entry->d_un.d_val;
          break;
        case DT_IA_64_VMS_FIXUP_RELA_OFF:
          fixup.fixup_rela_off = entry->d_un.d_val;
          res++;
          dump_ia64_vms_dynamic_fixups (file, &fixup, strtab, strtab_sz);
          break;

        case DT_IA_64_VMS_IMG_RELA_CNT:
	  imgrela.img_rela_cnt = entry->d_un.d_val;
          break;
        case DT_IA_64_VMS_IMG_RELA_OFF:
	  imgrela.img_rela_off = entry->d_un.d_val;
          res++;
          dump_ia64_vms_dynamic_relocs (file, &imgrela);
          break;

        default:
          break;
	}
    }

  if (strtab != NULL)
    free (strtab);

  return res;
}

static struct
{
  const char * name;
  int reloc;
  int size;
  int rela;
} dynamic_relocations [] =
{
    { "REL", DT_REL, DT_RELSZ, FALSE },
    { "RELA", DT_RELA, DT_RELASZ, TRUE },
    { "PLT", DT_JMPREL, DT_PLTRELSZ, UNKNOWN }
};

/* Process the reloc section.  */

static int
process_relocs (FILE * file)
{
  unsigned long rel_size;
  unsigned long rel_offset;


  if (!do_reloc)
    return 1;

  if (do_using_dynamic)
    {
      int is_rela;
      const char * name;
      int has_dynamic_reloc;
      unsigned int i;

      has_dynamic_reloc = 0;

      for (i = 0; i < ARRAY_SIZE (dynamic_relocations); i++)
	{
	  is_rela = dynamic_relocations [i].rela;
	  name = dynamic_relocations [i].name;
	  rel_size = dynamic_info [dynamic_relocations [i].size];
	  rel_offset = dynamic_info [dynamic_relocations [i].reloc];

	  has_dynamic_reloc |= rel_size;

	  if (is_rela == UNKNOWN)
	    {
	      if (dynamic_relocations [i].reloc == DT_JMPREL)
		switch (dynamic_info[DT_PLTREL])
		  {
		  case DT_REL:
		    is_rela = FALSE;
		    break;
		  case DT_RELA:
		    is_rela = TRUE;
		    break;
		  }
	    }

	  if (rel_size)
	    {
	      printf
		(_("\n'%s' relocation section at offset 0x%lx contains %ld bytes:\n"),
		 name, rel_offset, rel_size);

	      dump_relocations (file,
				offset_from_vma (file, rel_offset, rel_size),
				rel_size,
				dynamic_symbols, num_dynamic_syms,
				dynamic_strings, dynamic_strings_length, is_rela);
	    }
	}

      if (is_ia64_vms ())
        has_dynamic_reloc |= process_ia64_vms_dynamic_relocs (file);

      if (! has_dynamic_reloc)
	printf (_("\nThere are no dynamic relocations in this file.\n"));
    }
  else
    {
      Elf_Internal_Shdr * section;
      unsigned long i;
      int found = 0;

      for (i = 0, section = section_headers;
	   i < elf_header.e_shnum;
	   i++, section++)
	{
	  if (   section->sh_type != SHT_RELA
	      && section->sh_type != SHT_REL)
	    continue;

	  rel_offset = section->sh_offset;
	  rel_size   = section->sh_size;

	  if (rel_size)
	    {
	      Elf_Internal_Shdr * strsec;
	      int is_rela;

	      printf (_("\nRelocation section "));

	      if (string_table == NULL)
		printf ("%d", section->sh_name);
	      else
		printf ("'%s'", SECTION_NAME (section));

	      printf (_(" at offset 0x%lx contains %lu entries:\n"),
		 rel_offset, (unsigned long) (rel_size / section->sh_entsize));

	      is_rela = section->sh_type == SHT_RELA;

	      if (section->sh_link != 0
		  && section->sh_link < elf_header.e_shnum)
		{
		  Elf_Internal_Shdr * symsec;
		  Elf_Internal_Sym *  symtab;
		  unsigned long nsyms;
		  unsigned long strtablen = 0;
		  char * strtab = NULL;

		  symsec = section_headers + section->sh_link;
		  if (symsec->sh_type != SHT_SYMTAB
		      && symsec->sh_type != SHT_DYNSYM)
                    continue;

		  symtab = GET_ELF_SYMBOLS (file, symsec, & nsyms);

		  if (symtab == NULL)
		    continue;

		  if (symsec->sh_link != 0
		      && symsec->sh_link < elf_header.e_shnum)
		    {
		      strsec = section_headers + symsec->sh_link;

		      strtab = (char *) get_data (NULL, file, strsec->sh_offset,
                                                  1, strsec->sh_size,
                                                  _("string table"));
		      strtablen = strtab == NULL ? 0 : strsec->sh_size;
		    }

		  dump_relocations (file, rel_offset, rel_size,
				    symtab, nsyms, strtab, strtablen, is_rela);
		  if (strtab)
		    free (strtab);
		  free (symtab);
		}
	      else
		dump_relocations (file, rel_offset, rel_size,
				  NULL, 0, NULL, 0, is_rela);

	      found = 1;
	    }
	}

      if (! found)
	printf (_("\nThere are no relocations in this file.\n"));
    }

  return 1;
}

/* Process the unwind section.  */

#include "unwind-ia64.h"

/* An absolute address consists of a section and an offset.  If the
   section is NULL, the offset itself is the address, otherwise, the
   address equals to LOAD_ADDRESS(section) + offset.  */

struct absaddr
  {
    unsigned short section;
    bfd_vma offset;
  };

#define ABSADDR(a) \
  ((a).section \
   ? section_headers [(a).section].sh_addr + (a).offset \
   : (a).offset)

struct ia64_unw_table_entry
  {
    struct absaddr start;
    struct absaddr end;
    struct absaddr info;
  };

struct ia64_unw_aux_info
  {

    struct ia64_unw_table_entry *table;	/* Unwind table.  */
    unsigned long table_len;	/* Length of unwind table.  */
    unsigned char * info;	/* Unwind info.  */
    unsigned long info_size;	/* Size of unwind info.  */
    bfd_vma info_addr;		/* starting address of unwind info.  */
    bfd_vma seg_base;		/* Starting address of segment.  */
    Elf_Internal_Sym * symtab;	/* The symbol table.  */
    unsigned long nsyms;	/* Number of symbols.  */
    char * strtab;		/* The string table.  */
    unsigned long strtab_size;	/* Size of string table.  */
  };

static void
find_symbol_for_address (Elf_Internal_Sym * symtab,
			 unsigned long nsyms,
			 const char * strtab,
			 unsigned long strtab_size,
			 struct absaddr addr,
			 const char ** symname,
			 bfd_vma * offset)
{
  bfd_vma dist = 0x100000;
  Elf_Internal_Sym * sym;
  Elf_Internal_Sym * best = NULL;
  unsigned long i;

  REMOVE_ARCH_BITS (addr.offset);

  for (i = 0, sym = symtab; i < nsyms; ++i, ++sym)
    {
      bfd_vma value = sym->st_value;

      REMOVE_ARCH_BITS (value);

      if (ELF_ST_TYPE (sym->st_info) == STT_FUNC
	  && sym->st_name != 0
	  && (addr.section == SHN_UNDEF || addr.section == sym->st_shndx)
	  && addr.offset >= value
	  && addr.offset - value < dist)
	{
	  best = sym;
	  dist = addr.offset - value;
	  if (!dist)
	    break;
	}
    }

  if (best)
    {
      *symname = (best->st_name >= strtab_size
		  ? _("<corrupt>") : strtab + best->st_name);
      *offset = dist;
      return;
    }

  *symname = NULL;
  *offset = addr.offset;
}

static void
dump_ia64_unwind (struct ia64_unw_aux_info * aux)
{
  struct ia64_unw_table_entry * tp;
  int in_body;

  for (tp = aux->table; tp < aux->table + aux->table_len; ++tp)
    {
      bfd_vma stamp;
      bfd_vma offset;
      const unsigned char * dp;
      const unsigned char * head;
      const char * procname;

      find_symbol_for_address (aux->symtab, aux->nsyms, aux->strtab,
			       aux->strtab_size, tp->start, &procname, &offset);

      fputs ("\n<", stdout);

      if (procname)
	{
	  fputs (procname, stdout);

	  if (offset)
	    printf ("+%lx", (unsigned long) offset);
	}

      fputs (">: [", stdout);
      print_vma (tp->start.offset, PREFIX_HEX);
      fputc ('-', stdout);
      print_vma (tp->end.offset, PREFIX_HEX);
      printf ("], info at +0x%lx\n",
	      (unsigned long) (tp->info.offset - aux->seg_base));

      head = aux->info + (ABSADDR (tp->info) - aux->info_addr);
      stamp = byte_get ((unsigned char *) head, sizeof (stamp));

      printf ("  v%u, flags=0x%lx (%s%s), len=%lu bytes\n",
	      (unsigned) UNW_VER (stamp),
	      (unsigned long) ((stamp & UNW_FLAG_MASK) >> 32),
	      UNW_FLAG_EHANDLER (stamp) ? " ehandler" : "",
	      UNW_FLAG_UHANDLER (stamp) ? " uhandler" : "",
	      (unsigned long) (eh_addr_size * UNW_LENGTH (stamp)));

      if (UNW_VER (stamp) != 1)
	{
	  printf (_("\tUnknown version.\n"));
	  continue;
	}

      in_body = 0;
      for (dp = head + 8; dp < head + 8 + eh_addr_size * UNW_LENGTH (stamp);)
	dp = unw_decode (dp, in_body, & in_body);
    }
}

static int
slurp_ia64_unwind_table (FILE * file,
			 struct ia64_unw_aux_info * aux,
			 Elf_Internal_Shdr * sec)
{
  unsigned long size, nrelas, i;
  Elf_Internal_Phdr * seg;
  struct ia64_unw_table_entry * tep;
  Elf_Internal_Shdr * relsec;
  Elf_Internal_Rela * rela;
  Elf_Internal_Rela * rp;
  unsigned char * table;
  unsigned char * tp;
  Elf_Internal_Sym * sym;
  const char * relname;

  /* First, find the starting address of the segment that includes
     this section: */

  if (elf_header.e_phnum)
    {
      if (! get_program_headers (file))
	  return 0;

      for (seg = program_headers;
	   seg < program_headers + elf_header.e_phnum;
	   ++seg)
	{
	  if (seg->p_type != PT_LOAD)
	    continue;

	  if (sec->sh_addr >= seg->p_vaddr
	      && (sec->sh_addr + sec->sh_size <= seg->p_vaddr + seg->p_memsz))
	    {
	      aux->seg_base = seg->p_vaddr;
	      break;
	    }
	}
    }

  /* Second, build the unwind table from the contents of the unwind section:  */
  size = sec->sh_size;
  table = (unsigned char *) get_data (NULL, file, sec->sh_offset, 1, size,
                                      _("unwind table"));
  if (!table)
    return 0;

  aux->table = (struct ia64_unw_table_entry *)
      xcmalloc (size / (3 * eh_addr_size), sizeof (aux->table[0]));
  tep = aux->table;
  for (tp = table; tp < table + size; ++tep)
    {
      tep->start.section = SHN_UNDEF;
      tep->end.section   = SHN_UNDEF;
      tep->info.section  = SHN_UNDEF;
      tep->start.offset = byte_get (tp, eh_addr_size); tp += eh_addr_size;
      tep->end.offset   = byte_get (tp, eh_addr_size); tp += eh_addr_size;
      tep->info.offset  = byte_get (tp, eh_addr_size); tp += eh_addr_size;
      tep->start.offset += aux->seg_base;
      tep->end.offset   += aux->seg_base;
      tep->info.offset  += aux->seg_base;
    }
  free (table);

  /* Third, apply any relocations to the unwind table:  */
  for (relsec = section_headers;
       relsec < section_headers + elf_header.e_shnum;
       ++relsec)
    {
      if (relsec->sh_type != SHT_RELA
	  || relsec->sh_info >= elf_header.e_shnum
	  || section_headers + relsec->sh_info != sec)
	continue;

      if (!slurp_rela_relocs (file, relsec->sh_offset, relsec->sh_size,
			      & rela, & nrelas))
	return 0;

      for (rp = rela; rp < rela + nrelas; ++rp)
	{
	  relname = elf_ia64_reloc_type (get_reloc_type (rp->r_info));
	  sym = aux->symtab + get_reloc_symindex (rp->r_info);

	  if (! const_strneq (relname, "R_IA64_SEGREL"))
	    {
	      warn (_("Skipping unexpected relocation type %s\n"), relname);
	      continue;
	    }

	  i = rp->r_offset / (3 * eh_addr_size);

	  switch (rp->r_offset/eh_addr_size % 3)
	    {
	    case 0:
	      aux->table[i].start.section = sym->st_shndx;
	      aux->table[i].start.offset  = rp->r_addend + sym->st_value;
	      break;
	    case 1:
	      aux->table[i].end.section   = sym->st_shndx;
	      aux->table[i].end.offset    = rp->r_addend + sym->st_value;
	      break;
	    case 2:
	      aux->table[i].info.section  = sym->st_shndx;
	      aux->table[i].info.offset   = rp->r_addend + sym->st_value;
	      break;
	    default:
	      break;
	    }
	}

      free (rela);
    }

  aux->table_len = size / (3 * eh_addr_size);
  return 1;
}

static void
ia64_process_unwind (FILE * file)
{
  Elf_Internal_Shdr * sec;
  Elf_Internal_Shdr * unwsec = NULL;
  Elf_Internal_Shdr * strsec;
  unsigned long i, unwcount = 0, unwstart = 0;
  struct ia64_unw_aux_info aux;

  memset (& aux, 0, sizeof (aux));

  for (i = 0, sec = section_headers; i < elf_header.e_shnum; ++i, ++sec)
    {
      if (sec->sh_type == SHT_SYMTAB
	  && sec->sh_link < elf_header.e_shnum)
	{
	  aux.symtab = GET_ELF_SYMBOLS (file, sec, & aux.nsyms);

	  strsec = section_headers + sec->sh_link;
	  assert (aux.strtab == NULL);
	  aux.strtab = (char *) get_data (NULL, file, strsec->sh_offset,
                                          1, strsec->sh_size,
                                          _("string table"));
	  aux.strtab_size = aux.strtab != NULL ? strsec->sh_size : 0;
	}
      else if (sec->sh_type == SHT_IA_64_UNWIND)
	unwcount++;
    }

  if (!unwcount)
    printf (_("\nThere are no unwind sections in this file.\n"));

  while (unwcount-- > 0)
    {
      char * suffix;
      size_t len, len2;

      for (i = unwstart, sec = section_headers + unwstart;
	   i < elf_header.e_shnum; ++i, ++sec)
	if (sec->sh_type == SHT_IA_64_UNWIND)
	  {
	    unwsec = sec;
	    break;
	  }

      unwstart = i + 1;
      len = sizeof (ELF_STRING_ia64_unwind_once) - 1;

      if ((unwsec->sh_flags & SHF_GROUP) != 0)
	{
	  /* We need to find which section group it is in.  */
	  struct group_list * g = section_headers_groups [i]->root;

	  for (; g != NULL; g = g->next)
	    {
	      sec = section_headers + g->section_index;

	      if (streq (SECTION_NAME (sec), ELF_STRING_ia64_unwind_info))
		break;
	    }

	  if (g == NULL)
	    i = elf_header.e_shnum;
	}
      else if (strneq (SECTION_NAME (unwsec), ELF_STRING_ia64_unwind_once, len))
	{
	  /* .gnu.linkonce.ia64unw.FOO -> .gnu.linkonce.ia64unwi.FOO.  */
	  len2 = sizeof (ELF_STRING_ia64_unwind_info_once) - 1;
	  suffix = SECTION_NAME (unwsec) + len;
	  for (i = 0, sec = section_headers; i < elf_header.e_shnum;
	       ++i, ++sec)
	    if (strneq (SECTION_NAME (sec), ELF_STRING_ia64_unwind_info_once, len2)
		&& streq (SECTION_NAME (sec) + len2, suffix))
	      break;
	}
      else
	{
	  /* .IA_64.unwindFOO -> .IA_64.unwind_infoFOO
	     .IA_64.unwind or BAR -> .IA_64.unwind_info.  */
	  len = sizeof (ELF_STRING_ia64_unwind) - 1;
	  len2 = sizeof (ELF_STRING_ia64_unwind_info) - 1;
	  suffix = "";
	  if (strneq (SECTION_NAME (unwsec), ELF_STRING_ia64_unwind, len))
	    suffix = SECTION_NAME (unwsec) + len;
	  for (i = 0, sec = section_headers; i < elf_header.e_shnum;
	       ++i, ++sec)
	    if (strneq (SECTION_NAME (sec), ELF_STRING_ia64_unwind_info, len2)
		&& streq (SECTION_NAME (sec) + len2, suffix))
	      break;
	}

      if (i == elf_header.e_shnum)
	{
	  printf (_("\nCould not find unwind info section for "));

	  if (string_table == NULL)
	    printf ("%d", unwsec->sh_name);
	  else
	    printf (_("'%s'"), SECTION_NAME (unwsec));
	}
      else
	{
	  aux.info_addr = sec->sh_addr;
	  aux.info = (unsigned char *) get_data (NULL, file, sec->sh_offset, 1,
                                                 sec->sh_size,
                                                 _("unwind info"));
	  aux.info_size = aux.info == NULL ? 0 : sec->sh_size;

	  printf (_("\nUnwind section "));

	  if (string_table == NULL)
	    printf ("%d", unwsec->sh_name);
	  else
	    printf (_("'%s'"), SECTION_NAME (unwsec));

	  printf (_(" at offset 0x%lx contains %lu entries:\n"),
		  (unsigned long) unwsec->sh_offset,
		  (unsigned long) (unwsec->sh_size / (3 * eh_addr_size)));

	  (void) slurp_ia64_unwind_table (file, & aux, unwsec);

	  if (aux.table_len > 0)
	    dump_ia64_unwind (& aux);

	  if (aux.table)
	    free ((char *) aux.table);
	  if (aux.info)
	    free ((char *) aux.info);
	  aux.table = NULL;
	  aux.info = NULL;
	}
    }

  if (aux.symtab)
    free (aux.symtab);
  if (aux.strtab)
    free ((char *) aux.strtab);
}

struct hppa_unw_table_entry
  {
    struct absaddr start;
    struct absaddr end;
    unsigned int Cannot_unwind:1;			/* 0 */
    unsigned int Millicode:1;			/* 1 */
    unsigned int Millicode_save_sr0:1;		/* 2 */
    unsigned int Region_description:2;		/* 3..4 */
    unsigned int reserved1:1;			/* 5 */
    unsigned int Entry_SR:1;			/* 6 */
    unsigned int Entry_FR:4;     /* number saved */	/* 7..10 */
    unsigned int Entry_GR:5;     /* number saved */	/* 11..15 */
    unsigned int Args_stored:1;			/* 16 */
    unsigned int Variable_Frame:1;			/* 17 */
    unsigned int Separate_Package_Body:1;		/* 18 */
    unsigned int Frame_Extension_Millicode:1;	/* 19 */
    unsigned int Stack_Overflow_Check:1;		/* 20 */
    unsigned int Two_Instruction_SP_Increment:1;	/* 21 */
    unsigned int Ada_Region:1;			/* 22 */
    unsigned int cxx_info:1;			/* 23 */
    unsigned int cxx_try_catch:1;			/* 24 */
    unsigned int sched_entry_seq:1;			/* 25 */
    unsigned int reserved2:1;			/* 26 */
    unsigned int Save_SP:1;				/* 27 */
    unsigned int Save_RP:1;				/* 28 */
    unsigned int Save_MRP_in_frame:1;		/* 29 */
    unsigned int extn_ptr_defined:1;		/* 30 */
    unsigned int Cleanup_defined:1;			/* 31 */

    unsigned int MPE_XL_interrupt_marker:1;		/* 0 */
    unsigned int HP_UX_interrupt_marker:1;		/* 1 */
    unsigned int Large_frame:1;			/* 2 */
    unsigned int Pseudo_SP_Set:1;			/* 3 */
    unsigned int reserved4:1;			/* 4 */
    unsigned int Total_frame_size:27;		/* 5..31 */
  };

struct hppa_unw_aux_info
  {
    struct hppa_unw_table_entry *table;	/* Unwind table.  */
    unsigned long table_len;	/* Length of unwind table.  */
    bfd_vma seg_base;		/* Starting address of segment.  */
    Elf_Internal_Sym * symtab;	/* The symbol table.  */
    unsigned long nsyms;	/* Number of symbols.  */
    char * strtab;		/* The string table.  */
    unsigned long strtab_size;	/* Size of string table.  */
  };

static void
dump_hppa_unwind (struct hppa_unw_aux_info * aux)
{
  struct hppa_unw_table_entry * tp;

  for (tp = aux->table; tp < aux->table + aux->table_len; ++tp)
    {
      bfd_vma offset;
      const char * procname;

      find_symbol_for_address (aux->symtab, aux->nsyms, aux->strtab,
			       aux->strtab_size, tp->start, &procname,
			       &offset);

      fputs ("\n<", stdout);

      if (procname)
	{
	  fputs (procname, stdout);

	  if (offset)
	    printf ("+%lx", (unsigned long) offset);
	}

      fputs (">: [", stdout);
      print_vma (tp->start.offset, PREFIX_HEX);
      fputc ('-', stdout);
      print_vma (tp->end.offset, PREFIX_HEX);
      printf ("]\n\t");

#define PF(_m) if (tp->_m) printf (#_m " ");
#define PV(_m) if (tp->_m) printf (#_m "=%d ", tp->_m);
      PF(Cannot_unwind);
      PF(Millicode);
      PF(Millicode_save_sr0);
      /* PV(Region_description);  */
      PF(Entry_SR);
      PV(Entry_FR);
      PV(Entry_GR);
      PF(Args_stored);
      PF(Variable_Frame);
      PF(Separate_Package_Body);
      PF(Frame_Extension_Millicode);
      PF(Stack_Overflow_Check);
      PF(Two_Instruction_SP_Increment);
      PF(Ada_Region);
      PF(cxx_info);
      PF(cxx_try_catch);
      PF(sched_entry_seq);
      PF(Save_SP);
      PF(Save_RP);
      PF(Save_MRP_in_frame);
      PF(extn_ptr_defined);
      PF(Cleanup_defined);
      PF(MPE_XL_interrupt_marker);
      PF(HP_UX_interrupt_marker);
      PF(Large_frame);
      PF(Pseudo_SP_Set);
      PV(Total_frame_size);
#undef PF
#undef PV
    }

  printf ("\n");
}

static int
slurp_hppa_unwind_table (FILE * file,
			 struct hppa_unw_aux_info * aux,
			 Elf_Internal_Shdr * sec)
{
  unsigned long size, unw_ent_size, nentries, nrelas, i;
  Elf_Internal_Phdr * seg;
  struct hppa_unw_table_entry * tep;
  Elf_Internal_Shdr * relsec;
  Elf_Internal_Rela * rela;
  Elf_Internal_Rela * rp;
  unsigned char * table;
  unsigned char * tp;
  Elf_Internal_Sym * sym;
  const char * relname;

  /* First, find the starting address of the segment that includes
     this section.  */

  if (elf_header.e_phnum)
    {
      if (! get_program_headers (file))
	return 0;

      for (seg = program_headers;
	   seg < program_headers + elf_header.e_phnum;
	   ++seg)
	{
	  if (seg->p_type != PT_LOAD)
	    continue;

	  if (sec->sh_addr >= seg->p_vaddr
	      && (sec->sh_addr + sec->sh_size <= seg->p_vaddr + seg->p_memsz))
	    {
	      aux->seg_base = seg->p_vaddr;
	      break;
	    }
	}
    }

  /* Second, build the unwind table from the contents of the unwind
     section.  */
  size = sec->sh_size;
  table = (unsigned char *) get_data (NULL, file, sec->sh_offset, 1, size,
                                      _("unwind table"));
  if (!table)
    return 0;

  unw_ent_size = 16;
  nentries = size / unw_ent_size;
  size = unw_ent_size * nentries;

  tep = aux->table = (struct hppa_unw_table_entry *)
      xcmalloc (nentries, sizeof (aux->table[0]));

  for (tp = table; tp < table + size; tp += unw_ent_size, ++tep)
    {
      unsigned int tmp1, tmp2;

      tep->start.section = SHN_UNDEF;
      tep->end.section   = SHN_UNDEF;

      tep->start.offset = byte_get ((unsigned char *) tp + 0, 4);
      tep->end.offset = byte_get ((unsigned char *) tp + 4, 4);
      tmp1 = byte_get ((unsigned char *) tp + 8, 4);
      tmp2 = byte_get ((unsigned char *) tp + 12, 4);

      tep->start.offset += aux->seg_base;
      tep->end.offset   += aux->seg_base;

      tep->Cannot_unwind = (tmp1 >> 31) & 0x1;
      tep->Millicode = (tmp1 >> 30) & 0x1;
      tep->Millicode_save_sr0 = (tmp1 >> 29) & 0x1;
      tep->Region_description = (tmp1 >> 27) & 0x3;
      tep->reserved1 = (tmp1 >> 26) & 0x1;
      tep->Entry_SR = (tmp1 >> 25) & 0x1;
      tep->Entry_FR = (tmp1 >> 21) & 0xf;
      tep->Entry_GR = (tmp1 >> 16) & 0x1f;
      tep->Args_stored = (tmp1 >> 15) & 0x1;
      tep->Variable_Frame = (tmp1 >> 14) & 0x1;
      tep->Separate_Package_Body = (tmp1 >> 13) & 0x1;
      tep->Frame_Extension_Millicode = (tmp1 >> 12) & 0x1;
      tep->Stack_Overflow_Check = (tmp1 >> 11) & 0x1;
      tep->Two_Instruction_SP_Increment = (tmp1 >> 10) & 0x1;
      tep->Ada_Region = (tmp1 >> 9) & 0x1;
      tep->cxx_info = (tmp1 >> 8) & 0x1;
      tep->cxx_try_catch = (tmp1 >> 7) & 0x1;
      tep->sched_entry_seq = (tmp1 >> 6) & 0x1;
      tep->reserved2 = (tmp1 >> 5) & 0x1;
      tep->Save_SP = (tmp1 >> 4) & 0x1;
      tep->Save_RP = (tmp1 >> 3) & 0x1;
      tep->Save_MRP_in_frame = (tmp1 >> 2) & 0x1;
      tep->extn_ptr_defined = (tmp1 >> 1) & 0x1;
      tep->Cleanup_defined = tmp1 & 0x1;

      tep->MPE_XL_interrupt_marker = (tmp2 >> 31) & 0x1;
      tep->HP_UX_interrupt_marker = (tmp2 >> 30) & 0x1;
      tep->Large_frame = (tmp2 >> 29) & 0x1;
      tep->Pseudo_SP_Set = (tmp2 >> 28) & 0x1;
      tep->reserved4 = (tmp2 >> 27) & 0x1;
      tep->Total_frame_size = tmp2 & 0x7ffffff;
    }
  free (table);

  /* Third, apply any relocations to the unwind table.  */
  for (relsec = section_headers;
       relsec < section_headers + elf_header.e_shnum;
       ++relsec)
    {
      if (relsec->sh_type != SHT_RELA
	  || relsec->sh_info >= elf_header.e_shnum
	  || section_headers + relsec->sh_info != sec)
	continue;

      if (!slurp_rela_relocs (file, relsec->sh_offset, relsec->sh_size,
			      & rela, & nrelas))
	return 0;

      for (rp = rela; rp < rela + nrelas; ++rp)
	{
	  relname = elf_hppa_reloc_type (get_reloc_type (rp->r_info));
	  sym = aux->symtab + get_reloc_symindex (rp->r_info);

	  /* R_PARISC_SEGREL32 or R_PARISC_SEGREL64.  */
	  if (! const_strneq (relname, "R_PARISC_SEGREL"))
	    {
	      warn (_("Skipping unexpected relocation type %s\n"), relname);
	      continue;
	    }

	  i = rp->r_offset / unw_ent_size;

	  switch ((rp->r_offset % unw_ent_size) / eh_addr_size)
	    {
	    case 0:
	      aux->table[i].start.section = sym->st_shndx;
	      aux->table[i].start.offset  = sym->st_value + rp->r_addend;
	      break;
	    case 1:
	      aux->table[i].end.section   = sym->st_shndx;
	      aux->table[i].end.offset    = sym->st_value + rp->r_addend;
	      break;
	    default:
	      break;
	    }
	}

      free (rela);
    }

  aux->table_len = nentries;

  return 1;
}

static void
hppa_process_unwind (FILE * file)
{
  struct hppa_unw_aux_info aux;
  Elf_Internal_Shdr * unwsec = NULL;
  Elf_Internal_Shdr * strsec;
  Elf_Internal_Shdr * sec;
  unsigned long i;

  if (string_table == NULL)
    return;

  memset (& aux, 0, sizeof (aux));

  for (i = 0, sec = section_headers; i < elf_header.e_shnum; ++i, ++sec)
    {
      if (sec->sh_type == SHT_SYMTAB
	  && sec->sh_link < elf_header.e_shnum)
	{
	  aux.symtab = GET_ELF_SYMBOLS (file, sec, & aux.nsyms);

	  strsec = section_headers + sec->sh_link;
	  assert (aux.strtab == NULL);
	  aux.strtab = (char *) get_data (NULL, file, strsec->sh_offset,
                                          1, strsec->sh_size,
                                          _("string table"));
	  aux.strtab_size = aux.strtab != NULL ? strsec->sh_size : 0;
	}
      else if (streq (SECTION_NAME (sec), ".PARISC.unwind"))
	unwsec = sec;
    }

  if (!unwsec)
    printf (_("\nThere are no unwind sections in this file.\n"));

  for (i = 0, sec = section_headers; i < elf_header.e_shnum; ++i, ++sec)
    {
      if (streq (SECTION_NAME (sec), ".PARISC.unwind"))
	{
	  printf (_("\nUnwind section "));
	  printf (_("'%s'"), SECTION_NAME (sec));

	  printf (_(" at offset 0x%lx contains %lu entries:\n"),
		  (unsigned long) sec->sh_offset,
		  (unsigned long) (sec->sh_size / (2 * eh_addr_size + 8)));

          slurp_hppa_unwind_table (file, &aux, sec);
	  if (aux.table_len > 0)
	    dump_hppa_unwind (&aux);

	  if (aux.table)
	    free ((char *) aux.table);
	  aux.table = NULL;
	}
    }

  if (aux.symtab)
    free (aux.symtab);
  if (aux.strtab)
    free ((char *) aux.strtab);
}

struct arm_section
{
  unsigned char *      data;		/* The unwind data.  */
  Elf_Internal_Shdr *  sec;		/* The cached unwind section header.  */
  Elf_Internal_Rela *  rela;		/* The cached relocations for this section.  */
  unsigned long        nrelas;		/* The number of relocations.  */
  unsigned int         rel_type;	/* REL or RELA ?  */
  Elf_Internal_Rela *  next_rela;	/* Cyclic pointer to the next reloc to process.  */
};

struct arm_unw_aux_info
{
  FILE *              file;		/* The file containing the unwind sections.  */
  Elf_Internal_Sym *  symtab;		/* The file's symbol table.  */
  unsigned long       nsyms;		/* Number of symbols.  */
  char *              strtab;		/* The file's string table.  */
  unsigned long       strtab_size;	/* Size of string table.  */
};

static const char *
arm_print_vma_and_name (struct arm_unw_aux_info *aux,
			bfd_vma fn, struct absaddr addr)
{
  const char *procname;
  bfd_vma sym_offset;

  if (addr.section == SHN_UNDEF)
    addr.offset = fn;

  find_symbol_for_address (aux->symtab, aux->nsyms, aux->strtab,
			   aux->strtab_size, addr, &procname,
			   &sym_offset);

  print_vma (fn, PREFIX_HEX);

  if (procname)
    {
      fputs (" <", stdout);
      fputs (procname, stdout);

      if (sym_offset)
	printf ("+0x%lx", (unsigned long) sym_offset);
      fputc ('>', stdout);
    }

  return procname;
}

static void
arm_free_section (struct arm_section *arm_sec)
{
  if (arm_sec->data != NULL)
    free (arm_sec->data);

  if (arm_sec->rela != NULL)
    free (arm_sec->rela);
}

/* 1) If SEC does not match the one cached in ARM_SEC, then free the current
      cached section and install SEC instead.
   2) Locate the 32-bit word at WORD_OFFSET in unwind section SEC
      and return its valued in * WORDP, relocating if necessary.
   3) Update the NEXT_RELA field in ARM_SEC and store the section index and
      relocation's offset in ADDR.
   4) If SYM_NAME is non-NULL and a relocation was applied, record the offset
      into the string table of the symbol associated with the reloc.  If no
      reloc was applied store -1 there.
   5) Return TRUE upon success, FALSE otherwise.  */

static bfd_boolean
get_unwind_section_word (struct arm_unw_aux_info *  aux,
			 struct arm_section *       arm_sec,
			 Elf_Internal_Shdr *        sec,
			 bfd_vma 		    word_offset,
			 unsigned int *             wordp,
			 struct absaddr *           addr,
			 bfd_vma *		    sym_name)
{
  Elf_Internal_Rela *rp;
  Elf_Internal_Sym *sym;
  const char * relname;
  unsigned int word;
  bfd_boolean wrapped;

  addr->section = SHN_UNDEF;
  addr->offset = 0;

  if (sym_name != NULL)
    *sym_name = (bfd_vma) -1;

  /* If necessary, update the section cache.  */
  if (sec != arm_sec->sec)
    {
      Elf_Internal_Shdr *relsec;

      arm_free_section (arm_sec);

      arm_sec->sec = sec;
      arm_sec->data = get_data (NULL, aux->file, sec->sh_offset, 1,
				sec->sh_size, _("unwind data"));
      arm_sec->rela = NULL;
      arm_sec->nrelas = 0;

      for (relsec = section_headers;
	   relsec < section_headers + elf_header.e_shnum;
	   ++relsec)
	{
	  if (relsec->sh_info >= elf_header.e_shnum
	      || section_headers + relsec->sh_info != sec
	      /* PR 15745: Check the section type as well.  */
	      || (relsec->sh_type != SHT_REL
		  && relsec->sh_type != SHT_RELA))
	    continue;

	  arm_sec->rel_type = relsec->sh_type;
	  if (relsec->sh_type == SHT_REL)
	    {
	      if (!slurp_rel_relocs (aux->file, relsec->sh_offset,
				     relsec->sh_size,
				     & arm_sec->rela, & arm_sec->nrelas))
		return FALSE;
	    }
	  else /* relsec->sh_type == SHT_RELA */
	    {
	      if (!slurp_rela_relocs (aux->file, relsec->sh_offset,
				      relsec->sh_size,
				      & arm_sec->rela, & arm_sec->nrelas))
		return FALSE;
	    }
	  break;
	}

      arm_sec->next_rela = arm_sec->rela;
    }

  /* If there is no unwind data we can do nothing.  */
  if (arm_sec->data == NULL)
    return FALSE;

  /* Get the word at the required offset.  */
  word = byte_get (arm_sec->data + word_offset, 4);

  /* Look through the relocs to find the one that applies to the provided offset.  */
  wrapped = FALSE;
  for (rp = arm_sec->next_rela; rp != arm_sec->rela + arm_sec->nrelas; rp++)
    {
      bfd_vma prelval, offset;

      if (rp->r_offset > word_offset && !wrapped)
	{
	  rp = arm_sec->rela;
	  wrapped = TRUE;
	}
      if (rp->r_offset > word_offset)
	break;

      if (rp->r_offset & 3)
	{
	  warn (_("Skipping unexpected relocation at offset 0x%lx\n"),
		(unsigned long) rp->r_offset);
	  continue;
	}

      if (rp->r_offset < word_offset)
	continue;

      sym = aux->symtab + ELF32_R_SYM (rp->r_info);

      if (arm_sec->rel_type == SHT_REL)
	{
	  offset = word & 0x7fffffff;
	  if (offset & 0x40000000)
	    offset |= ~ (bfd_vma) 0x7fffffff;
	}
      else if (arm_sec->rel_type == SHT_RELA)
	offset = rp->r_addend;
      else
	abort ();

      offset += sym->st_value;
      prelval = offset - (arm_sec->sec->sh_addr + rp->r_offset);

      /* Check that we are processing the expected reloc type.  */
      if (elf_header.e_machine == EM_ARM)
	{
	  relname = elf_arm_reloc_type (ELF32_R_TYPE (rp->r_info));

	  if (streq (relname, "R_ARM_NONE"))
	      continue;

	  if (! streq (relname, "R_ARM_PREL31"))
	    {
	      warn (_("Skipping unexpected relocation type %s\n"), relname);
	      continue;
	    }
	}
      else if (elf_header.e_machine == EM_TI_C6000)
	{
	  relname = elf_tic6x_reloc_type (ELF32_R_TYPE (rp->r_info));

	  if (streq (relname, "R_C6000_NONE"))
	    continue;

	  if (! streq (relname, "R_C6000_PREL31"))
	    {
	      warn (_("Skipping unexpected relocation type %s\n"), relname);
	      continue;
	    }

	  prelval >>= 1;
	}
      else
	/* This function currently only supports ARM and TI unwinders.  */
	abort ();

      word = (word & ~ (bfd_vma) 0x7fffffff) | (prelval & 0x7fffffff);
      addr->section = sym->st_shndx;
      addr->offset = offset;
      if (sym_name)
	* sym_name = sym->st_name;
      break;
    }

  *wordp = word;
  arm_sec->next_rela = rp;

  return TRUE;
}

static const char *tic6x_unwind_regnames[16] =
{
  "A15", "B15", "B14", "B13", "B12", "B11", "B10", "B3",
  "A14", "A13", "A12", "A11", "A10",
  "[invalid reg 13]", "[invalid reg 14]", "[invalid reg 15]"
};

static void
decode_tic6x_unwind_regmask (unsigned int mask)
{
  int i;

  for (i = 12; mask; mask >>= 1, i--)
    {
      if (mask & 1)
	{
	  fputs (tic6x_unwind_regnames[i], stdout);
	  if (mask > 1)
	    fputs (", ", stdout);
	}
    }
}

#define ADVANCE							\
  if (remaining == 0 && more_words)				\
    {								\
      data_offset += 4;						\
      if (! get_unwind_section_word (aux, data_arm_sec, data_sec,	\
				     data_offset, & word, & addr, NULL))	\
	return;							\
      remaining = 4;						\
      more_words--;						\
    }								\

#define GET_OP(OP)			\
  ADVANCE;				\
  if (remaining)			\
    {					\
      remaining--;			\
      (OP) = word >> 24;		\
      word <<= 8;			\
    }					\
  else					\
    {					\
      printf (_("[Truncated opcode]\n"));	\
      return;				\
    }					\
  printf ("0x%02x ", OP)

static void
decode_arm_unwind_bytecode (struct arm_unw_aux_info *aux,
			    unsigned int word, unsigned int remaining,
			    unsigned int more_words,
			    bfd_vma data_offset, Elf_Internal_Shdr *data_sec,
			    struct arm_section *data_arm_sec)
{
  struct absaddr addr;

  /* Decode the unwinding instructions.  */
  while (1)
    {
      unsigned int op, op2;

      ADVANCE;
      if (remaining == 0)
	break;
      remaining--;
      op = word >> 24;
      word <<= 8;

      printf ("  0x%02x ", op);

      if ((op & 0xc0) == 0x00)
	{
	  int offset = ((op & 0x3f) << 2) + 4;

	  printf ("     vsp = vsp + %d", offset);
	}
      else if ((op & 0xc0) == 0x40)
	{
	  int offset = ((op & 0x3f) << 2) + 4;

	  printf ("     vsp = vsp - %d", offset);
	}
      else if ((op & 0xf0) == 0x80)
	{
	  GET_OP (op2);
	  if (op == 0x80 && op2 == 0)
	    printf (_("Refuse to unwind"));
	  else
	    {
	      unsigned int mask = ((op & 0x0f) << 8) | op2;
	      int first = 1;
	      int i;

	      printf ("pop {");
	      for (i = 0; i < 12; i++)
		if (mask & (1 << i))
		  {
		    if (first)
		      first = 0;
		    else
		      printf (", ");
		    printf ("r%d", 4 + i);
		  }
	      printf ("}");
	    }
	}
      else if ((op & 0xf0) == 0x90)
	{
	  if (op == 0x9d || op == 0x9f)
	    printf (_("     [Reserved]"));
	  else
	    printf ("     vsp = r%d", op & 0x0f);
	}
      else if ((op & 0xf0) == 0xa0)
	{
	  int end = 4 + (op & 0x07);
	  int first = 1;
	  int i;

	  printf ("     pop {");
	  for (i = 4; i <= end; i++)
	    {
	      if (first)
		first = 0;
	      else
		printf (", ");
	      printf ("r%d", i);
	    }
	  if (op & 0x08)
	    {
	      if (!first)
		printf (", ");
	      printf ("r14");
	    }
	  printf ("}");
	}
      else if (op == 0xb0)
	printf (_("     finish"));
      else if (op == 0xb1)
	{
	  GET_OP (op2);
	  if (op2 == 0 || (op2 & 0xf0) != 0)
	    printf (_("[Spare]"));
	  else
	    {
	      unsigned int mask = op2 & 0x0f;
	      int first = 1;
	      int i;

	      printf ("pop {");
	      for (i = 0; i < 12; i++)
		if (mask & (1 << i))
		  {
		    if (first)
		      first = 0;
		    else
		      printf (", ");
		    printf ("r%d", i);
		  }
	      printf ("}");
	    }
	}
      else if (op == 0xb2)
	{
	  unsigned char buf[9];
	  unsigned int i, len;
	  unsigned long offset;

	  for (i = 0; i < sizeof (buf); i++)
	    {
	      GET_OP (buf[i]);
	      if ((buf[i] & 0x80) == 0)
		break;
	    }
	  assert (i < sizeof (buf));
	  offset = read_uleb128 (buf, &len, buf + i + 1);
	  assert (len == i + 1);
	  offset = offset * 4 + 0x204;
	  printf ("vsp = vsp + %ld", offset);
	}
      else if (op == 0xb3 || op == 0xc8 || op == 0xc9)
	{
	  unsigned int first, last;

	  GET_OP (op2);
	  first = op2 >> 4;
	  last = op2 & 0x0f;
	  if (op == 0xc8)
	    first = first + 16;
	  printf ("pop {D%d", first);
	  if (last)
	    printf ("-D%d", first + last);
	  printf ("}");
	}
      else if ((op & 0xf8) == 0xb8 || (op & 0xf8) == 0xd0)
	{
	  unsigned int count = op & 0x07;

	  printf ("pop {D8");
	  if (count)
	    printf ("-D%d", 8 + count);
	  printf ("}");
	}
      else if (op >= 0xc0 && op <= 0xc5)
	{
	  unsigned int count = op & 0x07;

	  printf ("     pop {wR10");
	  if (count)
	    printf ("-wR%d", 10 + count);
	  printf ("}");
	}
      else if (op == 0xc6)
	{
	  unsigned int first, last;

	  GET_OP (op2);
	  first = op2 >> 4;
	  last = op2 & 0x0f;
	  printf ("pop {wR%d", first);
	  if (last)
	    printf ("-wR%d", first + last);
	  printf ("}");
	}
      else if (op == 0xc7)
	{
	  GET_OP (op2);
	  if (op2 == 0 || (op2 & 0xf0) != 0)
	    printf (_("[Spare]"));
	  else
	    {
	      unsigned int mask = op2 & 0x0f;
	      int first = 1;
	      int i;

	      printf ("pop {");
	      for (i = 0; i < 4; i++)
		if (mask & (1 << i))
		  {
		    if (first)
		      first = 0;
		    else
		      printf (", ");
		    printf ("wCGR%d", i);
		  }
	      printf ("}");
	    }
	}
      else
	printf (_("     [unsupported opcode]"));
      printf ("\n");
    }
}

static void
decode_tic6x_unwind_bytecode (struct arm_unw_aux_info *aux,
			    unsigned int word, unsigned int remaining,
			    unsigned int more_words,
			    bfd_vma data_offset, Elf_Internal_Shdr *data_sec,
			    struct arm_section *data_arm_sec)
{
  struct absaddr addr;

  /* Decode the unwinding instructions.  */
  while (1)
    {
      unsigned int op, op2;

      ADVANCE;
      if (remaining == 0)
	break;
      remaining--;
      op = word >> 24;
      word <<= 8;

      printf ("  0x%02x ", op);

      if ((op & 0xc0) == 0x00)
	{
	  int offset = ((op & 0x3f) << 3) + 8;
	  printf ("     sp = sp + %d", offset);
	}
      else if ((op & 0xc0) == 0x80)
	{
	  GET_OP (op2);
	  if (op == 0x80 && op2 == 0)
	    printf (_("Refuse to unwind"));
	  else
	    {
	      unsigned int mask = ((op & 0x1f) << 8) | op2;
	      if (op & 0x20)
		printf ("pop compact {");
	      else
		printf ("pop {");

	      decode_tic6x_unwind_regmask (mask);
	      printf("}");
	    }
	}
      else if ((op & 0xf0) == 0xc0)
	{
	  unsigned int reg;
	  unsigned int nregs;
	  unsigned int i;
	  const char *name;
	  struct
	  {
	      unsigned int offset;
	      unsigned int reg;
	  } regpos[16];

	  /* Scan entire instruction first so that GET_OP output is not
	     interleaved with disassembly.  */
	  nregs = 0;
	  for (i = 0; nregs < (op & 0xf); i++)
	    {
	      GET_OP (op2);
	      reg = op2 >> 4;
	      if (reg != 0xf)
		{
		  regpos[nregs].offset = i * 2;
		  regpos[nregs].reg = reg;
		  nregs++;
		}

	      reg = op2 & 0xf;
	      if (reg != 0xf)
		{
		  regpos[nregs].offset = i * 2 + 1;
		  regpos[nregs].reg = reg;
		  nregs++;
		}
	    }

	  printf (_("pop frame {"));
	  reg = nregs - 1;
	  for (i = i * 2; i > 0; i--)
	    {
	      if (regpos[reg].offset == i - 1)
		{
		  name = tic6x_unwind_regnames[regpos[reg].reg];
		  if (reg > 0)
		    reg--;
		}
	      else
		name = _("[pad]");

	      fputs (name, stdout);
	      if (i > 1)
		printf (", ");
	    }

	  printf ("}");
	}
      else if (op == 0xd0)
	printf ("     MOV FP, SP");
      else if (op == 0xd1)
	printf ("     __c6xabi_pop_rts");
      else if (op == 0xd2)
	{
	  unsigned char buf[9];
	  unsigned int i, len;
	  unsigned long offset;

	  for (i = 0; i < sizeof (buf); i++)
	    {
	      GET_OP (buf[i]);
	      if ((buf[i] & 0x80) == 0)
		break;
	    }
	  assert (i < sizeof (buf));
	  offset = read_uleb128 (buf, &len, buf + i + 1);
	  assert (len == i + 1);
	  offset = offset * 8 + 0x408;
	  printf (_("sp = sp + %ld"), offset);
	}
      else if ((op & 0xf0) == 0xe0)
	{
	  if ((op & 0x0f) == 7)
	    printf ("     RETURN");
	  else
	    printf ("     MV %s, B3", tic6x_unwind_regnames[op & 0x0f]);
	}
      else
	{
	  printf (_("     [unsupported opcode]"));
	}
      putchar ('\n');
    }
}

static bfd_vma
arm_expand_prel31 (bfd_vma word, bfd_vma where)
{
  bfd_vma offset;

  offset = word & 0x7fffffff;
  if (offset & 0x40000000)
    offset |= ~ (bfd_vma) 0x7fffffff;

  if (elf_header.e_machine == EM_TI_C6000)
    offset <<= 1;

  return offset + where;
}

static void
decode_arm_unwind (struct arm_unw_aux_info *  aux,
		   unsigned int               word,
		   unsigned int               remaining,
		   bfd_vma                    data_offset,
		   Elf_Internal_Shdr *        data_sec,
		   struct arm_section *       data_arm_sec)
{
  int per_index;
  unsigned int more_words = 0;
  struct absaddr addr;
  bfd_vma sym_name = (bfd_vma) -1;

  if (remaining == 0)
    {
      /* Fetch the first word.
	 Note - when decoding an object file the address extracted
	 here will always be 0.  So we also pass in the sym_name
	 parameter so that we can find the symbol associated with
	 the personality routine.  */
      if (! get_unwind_section_word (aux, data_arm_sec, data_sec, data_offset,
				     & word, & addr, & sym_name))
	return;

      remaining = 4;
    }

  if ((word & 0x80000000) == 0)
    {
      /* Expand prel31 for personality routine.  */
      bfd_vma fn;
      const char *procname;

      fn = arm_expand_prel31 (word, data_sec->sh_addr + data_offset);
      printf (_("  Personality routine: "));
      if (fn == 0
	  && addr.section == SHN_UNDEF && addr.offset == 0
	  && sym_name != (bfd_vma) -1 && sym_name < aux->strtab_size)
	{
	  procname = aux->strtab + sym_name;
	  print_vma (fn, PREFIX_HEX);
	  if (procname)
	    {
	      fputs (" <", stdout);
	      fputs (procname, stdout);
	      fputc ('>', stdout);
	    }
	}
      else
	procname = arm_print_vma_and_name (aux, fn, addr);
      fputc ('\n', stdout);

      /* The GCC personality routines use the standard compact
	 encoding, starting with one byte giving the number of
	 words.  */
      if (procname != NULL
	  && (const_strneq (procname, "__gcc_personality_v0")
	      || const_strneq (procname, "__gxx_personality_v0")
	      || const_strneq (procname, "__gcj_personality_v0")
	      || const_strneq (procname, "__gnu_objc_personality_v0")))
	{
	  remaining = 0;
	  more_words = 1;
	  ADVANCE;
	  if (!remaining)
	    {
	      printf (_("  [Truncated data]\n"));
	      return;
	    }
	  more_words = word >> 24;
	  word <<= 8;
	  remaining--;
	  per_index = -1;
	}
      else
	return;
    }
  else
    {
      /* ARM EHABI Section 6.3:

	 An exception-handling table entry for the compact model looks like:

           31 30-28 27-24 23-0
	   -- ----- ----- ----
            1   0   index Data for personalityRoutine[index]    */

      if (elf_header.e_machine == EM_ARM
	  && (word & 0x70000000))
	warn (_("Corrupt ARM compact model table entry: %x \n"), word);

      per_index = (word >> 24) & 0x7f;
      printf (_("  Compact model index: %d\n"), per_index);
      if (per_index == 0)
	{
	  more_words = 0;
	  word <<= 8;
	  remaining--;
	}
      else if (per_index < 3)
	{
	  more_words = (word >> 16) & 0xff;
	  word <<= 16;
	  remaining -= 2;
	}
    }

  switch (elf_header.e_machine)
    {
    case EM_ARM:
      if (per_index < 3)
	{
	  decode_arm_unwind_bytecode (aux, word, remaining, more_words,
				      data_offset, data_sec, data_arm_sec);
	}
      else
	{
	  warn (_("Unknown ARM compact model index encountered\n"));
	  printf (_("  [reserved]\n"));
	}
      break;

    case EM_TI_C6000:
      if (per_index < 3)
	{
	  decode_tic6x_unwind_bytecode (aux, word, remaining, more_words,
					data_offset, data_sec, data_arm_sec);
	}
      else if (per_index < 5)
	{
	  if (((word >> 17) & 0x7f) == 0x7f)
	    printf (_("  Restore stack from frame pointer\n"));
	  else
	    printf (_("  Stack increment %d\n"), (word >> 14) & 0x1fc);
	  printf (_("  Registers restored: "));
	  if (per_index == 4)
	    printf (" (compact) ");
	  decode_tic6x_unwind_regmask ((word >> 4) & 0x1fff);
	  putchar ('\n');
	  printf (_("  Return register: %s\n"),
		  tic6x_unwind_regnames[word & 0xf]);
	}
      else
	printf (_("  [reserved (%d)]\n"), per_index);
      break;

    default:
      error (_("Unsupported architecture type %d encountered when decoding unwind table"),
	     elf_header.e_machine);
    }

  /* Decode the descriptors.  Not implemented.  */
}

static void
dump_arm_unwind (struct arm_unw_aux_info *aux, Elf_Internal_Shdr *exidx_sec)
{
  struct arm_section exidx_arm_sec, extab_arm_sec;
  unsigned int i, exidx_len;

  memset (&exidx_arm_sec, 0, sizeof (exidx_arm_sec));
  memset (&extab_arm_sec, 0, sizeof (extab_arm_sec));
  exidx_len = exidx_sec->sh_size / 8;

  for (i = 0; i < exidx_len; i++)
    {
      unsigned int exidx_fn, exidx_entry;
      struct absaddr fn_addr, entry_addr;
      bfd_vma fn;

      fputc ('\n', stdout);

      if (! get_unwind_section_word (aux, & exidx_arm_sec, exidx_sec,
				     8 * i, & exidx_fn, & fn_addr, NULL)
	  || ! get_unwind_section_word (aux, & exidx_arm_sec, exidx_sec,
					8 * i + 4, & exidx_entry, & entry_addr, NULL))
	{
	  arm_free_section (& exidx_arm_sec);
	  arm_free_section (& extab_arm_sec);
	  return;
	}

      /* ARM EHABI, Section 5:
	 An index table entry consists of 2 words.
         The first word contains a prel31 offset to the start of a function, with bit 31 clear.  */
      if (exidx_fn & 0x80000000)
	warn (_("corrupt index table entry: %x\n"), exidx_fn);

      fn = arm_expand_prel31 (exidx_fn, exidx_sec->sh_addr + 8 * i);

      arm_print_vma_and_name (aux, fn, fn_addr);
      fputs (": ", stdout);

      if (exidx_entry == 1)
	{
	  print_vma (exidx_entry, PREFIX_HEX);
	  fputs (" [cantunwind]\n", stdout);
	}
      else if (exidx_entry & 0x80000000)
	{
	  print_vma (exidx_entry, PREFIX_HEX);
	  fputc ('\n', stdout);
	  decode_arm_unwind (aux, exidx_entry, 4, 0, NULL, NULL);
	}
      else
	{
	  bfd_vma table, table_offset = 0;
	  Elf_Internal_Shdr *table_sec;

	  fputs ("@@", stdout);
	  table = arm_expand_prel31 (exidx_entry, exidx_sec->sh_addr + 8 * i + 4);
	  print_vma (table, PREFIX_HEX);
	  printf ("\n");

	  /* Locate the matching .ARM.extab.  */
	  if (entry_addr.section != SHN_UNDEF
	      && entry_addr.section < elf_header.e_shnum)
	    {
	      table_sec = section_headers + entry_addr.section;
	      table_offset = entry_addr.offset;
	    }
	  else
	    {
	      table_sec = find_section_by_address (table);
	      if (table_sec != NULL)
		table_offset = table - table_sec->sh_addr;
	    }
	  if (table_sec == NULL)
	    {
	      warn (_("Could not locate .ARM.extab section containing 0x%lx.\n"),
		    (unsigned long) table);
	      continue;
	    }
	  decode_arm_unwind (aux, 0, 0, table_offset, table_sec,
			     &extab_arm_sec);
	}
    }

  printf ("\n");

  arm_free_section (&exidx_arm_sec);
  arm_free_section (&extab_arm_sec);
}

/* Used for both ARM and C6X unwinding tables.  */

static void
arm_process_unwind (FILE *file)
{
  struct arm_unw_aux_info aux;
  Elf_Internal_Shdr *unwsec = NULL;
  Elf_Internal_Shdr *strsec;
  Elf_Internal_Shdr *sec;
  unsigned long i;
  unsigned int sec_type;

  switch (elf_header.e_machine)
    {
    case EM_ARM:
      sec_type = SHT_ARM_EXIDX;
      break;

    case EM_TI_C6000:
      sec_type = SHT_C6000_UNWIND;
      break;

    default:
      error (_("Unsupported architecture type %d encountered when processing unwind table"),
	     elf_header.e_machine);
      return;
    }

  if (string_table == NULL)
    return;

  memset (& aux, 0, sizeof (aux));
  aux.file = file;

  for (i = 0, sec = section_headers; i < elf_header.e_shnum; ++i, ++sec)
    {
      if (sec->sh_type == SHT_SYMTAB && sec->sh_link < elf_header.e_shnum)
	{
	  aux.symtab = GET_ELF_SYMBOLS (file, sec, & aux.nsyms);

	  strsec = section_headers + sec->sh_link;
	  assert (aux.strtab == NULL);
	  aux.strtab = get_data (NULL, file, strsec->sh_offset,
				 1, strsec->sh_size, _("string table"));
	  aux.strtab_size = aux.strtab != NULL ? strsec->sh_size : 0;
	}
      else if (sec->sh_type == sec_type)
	unwsec = sec;
    }

  if (unwsec == NULL)
    printf (_("\nThere are no unwind sections in this file.\n"));
  else
    for (i = 0, sec = section_headers; i < elf_header.e_shnum; ++i, ++sec)
      {
	if (sec->sh_type == sec_type)
	  {
	    printf (_("\nUnwind table index '%s' at offset 0x%lx contains %lu entries:\n"),
		    SECTION_NAME (sec),
		    (unsigned long) sec->sh_offset,
		    (unsigned long) (sec->sh_size / (2 * eh_addr_size)));

	    dump_arm_unwind (&aux, sec);
	  }
      }

  if (aux.symtab)
    free (aux.symtab);
  if (aux.strtab)
    free ((char *) aux.strtab);
}

static void
process_unwind (FILE * file)
{
  struct unwind_handler
  {
    int machtype;
    void (* handler)(FILE *);
  } handlers[] =
  {
    { EM_ARM, arm_process_unwind },
    { EM_IA_64, ia64_process_unwind },
    { EM_PARISC, hppa_process_unwind },
    { EM_TI_C6000, arm_process_unwind },
    { 0, 0 }
  };
  int i;

  if (!do_unwind)
    return;

  for (i = 0; handlers[i].handler != NULL; i++)
    if (elf_header.e_machine == handlers[i].machtype)
      {
	handlers[i].handler (file);
	return;
      }

  printf (_("\nThe decoding of unwind sections for machine type %s is not currently supported.\n"),
	  get_machine_name (elf_header.e_machine));
}

static void
dynamic_section_mips_val (Elf_Internal_Dyn * entry)
{
  switch (entry->d_tag)
    {
    case DT_MIPS_FLAGS:
      if (entry->d_un.d_val == 0)
	printf (_("NONE"));
      else
	{
	  static const char * opts[] =
	  {
	    "QUICKSTART", "NOTPOT", "NO_LIBRARY_REPLACEMENT",
	    "NO_MOVE", "SGI_ONLY", "GUARANTEE_INIT", "DELTA_C_PLUS_PLUS",
	    "GUARANTEE_START_INIT", "PIXIE", "DEFAULT_DELAY_LOAD",
	    "REQUICKSTART", "REQUICKSTARTED", "CORD", "NO_UNRES_UNDEF",
	    "RLD_ORDER_SAFE"
	  };
	  unsigned int cnt;
	  int first = 1;

	  for (cnt = 0; cnt < ARRAY_SIZE (opts); ++cnt)
	    if (entry->d_un.d_val & (1 << cnt))
	      {
		printf ("%s%s", first ? "" : " ", opts[cnt]);
		first = 0;
	      }
	}
      break;

    case DT_MIPS_IVERSION:
      if (VALID_DYNAMIC_NAME (entry->d_un.d_val))
	printf (_("Interface Version: %s"), GET_DYNAMIC_NAME (entry->d_un.d_val));
      else
	printf (_("<corrupt: %" BFD_VMA_FMT "d>"), entry->d_un.d_ptr);
      break;

    case DT_MIPS_TIME_STAMP:
      {
	char timebuf[20];
	struct tm * tmp;

	time_t atime = entry->d_un.d_val;
	tmp = gmtime (&atime);
	snprintf (timebuf, sizeof (timebuf), "%04u-%02u-%02uT%02u:%02u:%02u",
		  tmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,
		  tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
	printf (_("Time Stamp: %s"), timebuf);
      }
      break;

    case DT_MIPS_RLD_VERSION:
    case DT_MIPS_LOCAL_GOTNO:
    case DT_MIPS_CONFLICTNO:
    case DT_MIPS_LIBLISTNO:
    case DT_MIPS_SYMTABNO:
    case DT_MIPS_UNREFEXTNO:
    case DT_MIPS_HIPAGENO:
    case DT_MIPS_DELTA_CLASS_NO:
    case DT_MIPS_DELTA_INSTANCE_NO:
    case DT_MIPS_DELTA_RELOC_NO:
    case DT_MIPS_DELTA_SYM_NO:
    case DT_MIPS_DELTA_CLASSSYM_NO:
    case DT_MIPS_COMPACT_SIZE:
      print_vma (entry->d_un.d_ptr, DEC);
      break;

    default:
      print_vma (entry->d_un.d_ptr, PREFIX_HEX);
    }
    putchar ('\n');
}

static void
dynamic_section_parisc_val (Elf_Internal_Dyn * entry)
{
  switch (entry->d_tag)
    {
    case DT_HP_DLD_FLAGS:
      {
	static struct
	{
	  long int bit;
	  const char * str;
	}
	flags[] =
	{
	  { DT_HP_DEBUG_PRIVATE, "HP_DEBUG_PRIVATE" },
	  { DT_HP_DEBUG_CALLBACK, "HP_DEBUG_CALLBACK" },
	  { DT_HP_DEBUG_CALLBACK_BOR, "HP_DEBUG_CALLBACK_BOR" },
	  { DT_HP_NO_ENVVAR, "HP_NO_ENVVAR" },
	  { DT_HP_BIND_NOW, "HP_BIND_NOW" },
	  { DT_HP_BIND_NONFATAL, "HP_BIND_NONFATAL" },
	  { DT_HP_BIND_VERBOSE, "HP_BIND_VERBOSE" },
	  { DT_HP_BIND_RESTRICTED, "HP_BIND_RESTRICTED" },
	  { DT_HP_BIND_SYMBOLIC, "HP_BIND_SYMBOLIC" },
	  { DT_HP_RPATH_FIRST, "HP_RPATH_FIRST" },
	  { DT_HP_BIND_DEPTH_FIRST, "HP_BIND_DEPTH_FIRST" },
	  { DT_HP_GST, "HP_GST" },
	  { DT_HP_SHLIB_FIXED, "HP_SHLIB_FIXED" },
	  { DT_HP_MERGE_SHLIB_SEG, "HP_MERGE_SHLIB_SEG" },
	  { DT_HP_NODELETE, "HP_NODELETE" },
	  { DT_HP_GROUP, "HP_GROUP" },
	  { DT_HP_PROTECT_LINKAGE_TABLE, "HP_PROTECT_LINKAGE_TABLE" }
	};
	int first = 1;
	size_t cnt;
	bfd_vma val = entry->d_un.d_val;

	for (cnt = 0; cnt < ARRAY_SIZE (flags); ++cnt)
	  if (val & flags[cnt].bit)
	    {
	      if (! first)
		putchar (' ');
	      fputs (flags[cnt].str, stdout);
	      first = 0;
	      val ^= flags[cnt].bit;
	    }

	if (val != 0 || first)
	  {
	    if (! first)
	      putchar (' ');
	    print_vma (val, HEX);
	  }
      }
      break;

    default:
      print_vma (entry->d_un.d_ptr, PREFIX_HEX);
      break;
    }
  putchar ('\n');
}

#ifdef BFD64

/* VMS vs Unix time offset and factor.  */

#define VMS_EPOCH_OFFSET 35067168000000000LL
#define VMS_GRANULARITY_FACTOR 10000000

/* Display a VMS time in a human readable format.  */

static void
print_vms_time (bfd_int64_t vmstime)
{
  struct tm *tm;
  time_t unxtime;

  unxtime = (vmstime - VMS_EPOCH_OFFSET) / VMS_GRANULARITY_FACTOR;
  tm = gmtime (&unxtime);
  printf ("%04u-%02u-%02uT%02u:%02u:%02u",
          tm->tm_year + 1900, tm->tm_mon + 1, tm->tm_mday,
          tm->tm_hour, tm->tm_min, tm->tm_sec);
}
#endif /* BFD64 */

static void
dynamic_section_ia64_val (Elf_Internal_Dyn * entry)
{
  switch (entry->d_tag)
    {
    case DT_IA_64_PLT_RESERVE:
      /* First 3 slots reserved.  */
      print_vma (entry->d_un.d_ptr, PREFIX_HEX);
      printf (" -- ");
      print_vma (entry->d_un.d_ptr + (3 * 8), PREFIX_HEX);
      break;

    case DT_IA_64_VMS_LINKTIME:
#ifdef BFD64
      print_vms_time (entry->d_un.d_val);
#endif
      break;

    case DT_IA_64_VMS_LNKFLAGS:
      print_vma (entry->d_un.d_ptr, PREFIX_HEX);
      if (entry->d_un.d_val & VMS_LF_CALL_DEBUG)
        printf (" CALL_DEBUG");
      if (entry->d_un.d_val & VMS_LF_NOP0BUFS)
        printf (" NOP0BUFS");
      if (entry->d_un.d_val & VMS_LF_P0IMAGE)
        printf (" P0IMAGE");
      if (entry->d_un.d_val & VMS_LF_MKTHREADS)
        printf (" MKTHREADS");
      if (entry->d_un.d_val & VMS_LF_UPCALLS)
        printf (" UPCALLS");
      if (entry->d_un.d_val & VMS_LF_IMGSTA)
        printf (" IMGSTA");
      if (entry->d_un.d_val & VMS_LF_INITIALIZE)
        printf (" INITIALIZE");
      if (entry->d_un.d_val & VMS_LF_MAIN)
        printf (" MAIN");
      if (entry->d_un.d_val & VMS_LF_EXE_INIT)
        printf (" EXE_INIT");
      if (entry->d_un.d_val & VMS_LF_TBK_IN_IMG)
        printf (" TBK_IN_IMG");
      if (entry->d_un.d_val & VMS_LF_DBG_IN_IMG)
        printf (" DBG_IN_IMG");
      if (entry->d_un.d_val & VMS_LF_TBK_IN_DSF)
        printf (" TBK_IN_DSF");
      if (entry->d_un.d_val & VMS_LF_DBG_IN_DSF)
        printf (" DBG_IN_DSF");
      if (entry->d_un.d_val & VMS_LF_SIGNATURES)
        printf (" SIGNATURES");
      if (entry->d_un.d_val & VMS_LF_REL_SEG_OFF)
        printf (" REL_SEG_OFF");
      break;

    default:
      print_vma (entry->d_un.d_ptr, PREFIX_HEX);
      break;
    }
  putchar ('\n');
}

static int
get_32bit_dynamic_section (FILE * file)
{
  Elf32_External_Dyn * edyn;
  Elf32_External_Dyn * ext;
  Elf_Internal_Dyn * entry;

  edyn = (Elf32_External_Dyn *) get_data (NULL, file, dynamic_addr, 1,
                                          dynamic_size, _("dynamic section"));
  if (!edyn)
    return 0;

/* SGI's ELF has more than one section in the DYNAMIC segment, and we
   might not have the luxury of section headers.  Look for the DT_NULL
   terminator to determine the number of entries.  */
  for (ext = edyn, dynamic_nent = 0;
       (char *) ext < (char *) edyn + dynamic_size;
       ext++)
    {
      dynamic_nent++;
      if (BYTE_GET (ext->d_tag) == DT_NULL)
	break;
    }

  dynamic_section = (Elf_Internal_Dyn *) cmalloc (dynamic_nent,
                                                  sizeof (* entry));
  if (dynamic_section == NULL)
    {
      error (_("Out of memory\n"));
      free (edyn);
      return 0;
    }

  for (ext = edyn, entry = dynamic_section;
       entry < dynamic_section + dynamic_nent;
       ext++, entry++)
    {
      entry->d_tag      = BYTE_GET (ext->d_tag);
      entry->d_un.d_val = BYTE_GET (ext->d_un.d_val);
    }

  free (edyn);

  return 1;
}

static int
get_64bit_dynamic_section (FILE * file)
{
  Elf64_External_Dyn * edyn;
  Elf64_External_Dyn * ext;
  Elf_Internal_Dyn * entry;

  edyn = (Elf64_External_Dyn *) get_data (NULL, file, dynamic_addr, 1,
                                          dynamic_size, _("dynamic section"));
  if (!edyn)
    return 0;

/* SGI's ELF has more than one section in the DYNAMIC segment, and we
   might not have the luxury of section headers.  Look for the DT_NULL
   terminator to determine the number of entries.  */
  for (ext = edyn, dynamic_nent = 0;
       (char *) ext < (char *) edyn + dynamic_size;
       ext++)
    {
      dynamic_nent++;
      if (BYTE_GET (ext->d_tag) == DT_NULL)
	break;
    }

  dynamic_section = (Elf_Internal_Dyn *) cmalloc (dynamic_nent,
                                                  sizeof (* entry));
  if (dynamic_section == NULL)
    {
      error (_("Out of memory\n"));
      free (edyn);
      return 0;
    }

  for (ext = edyn, entry = dynamic_section;
       entry < dynamic_section + dynamic_nent;
       ext++, entry++)
    {
      entry->d_tag      = BYTE_GET (ext->d_tag);
      entry->d_un.d_val = BYTE_GET (ext->d_un.d_val);
    }

  free (edyn);

  return 1;
}

static void
print_dynamic_flags (bfd_vma flags)
{
  int first = 1;

  while (flags)
    {
      bfd_vma flag;

      flag = flags & - flags;
      flags &= ~ flag;

      if (first)
	first = 0;
      else
	putc (' ', stdout);

      switch (flag)
	{
	case DF_ORIGIN:		fputs ("ORIGIN", stdout); break;
	case DF_SYMBOLIC:	fputs ("SYMBOLIC", stdout); break;
	case DF_TEXTREL:	fputs ("TEXTREL", stdout); break;
	case DF_BIND_NOW:	fputs ("BIND_NOW", stdout); break;
	case DF_STATIC_TLS:	fputs ("STATIC_TLS", stdout); break;
	default:		fputs (_("unknown"), stdout); break;
	}
    }
  puts ("");
}

/* Parse and display the contents of the dynamic section.  */

static int
process_dynamic_section (FILE * file)
{
  Elf_Internal_Dyn * entry;

  if (dynamic_size == 0)
    {
      if (do_dynamic)
	printf (_("\nThere is no dynamic section in this file.\n"));

      return 1;
    }

  if (is_32bit_elf)
    {
      if (! get_32bit_dynamic_section (file))
	return 0;
    }
  else if (! get_64bit_dynamic_section (file))
    return 0;

  /* Find the appropriate symbol table.  */
  if (dynamic_symbols == NULL)
    {
      for (entry = dynamic_section;
	   entry < dynamic_section + dynamic_nent;
	   ++entry)
	{
	  Elf_Internal_Shdr section;

	  if (entry->d_tag != DT_SYMTAB)
	    continue;

	  dynamic_info[DT_SYMTAB] = entry->d_un.d_val;

	  /* Since we do not know how big the symbol table is,
	     we default to reading in the entire file (!) and
	     processing that.  This is overkill, I know, but it
	     should work.  */
	  section.sh_offset = offset_from_vma (file, entry->d_un.d_val, 0);

	  if (archive_file_offset != 0)
	    section.sh_size = archive_file_size - section.sh_offset;
	  else
	    {
	      if (fseek (file, 0, SEEK_END))
		error (_("Unable to seek to end of file!\n"));

	      section.sh_size = ftell (file) - section.sh_offset;
	    }

	  if (is_32bit_elf)
	    section.sh_entsize = sizeof (Elf32_External_Sym);
	  else
	    section.sh_entsize = sizeof (Elf64_External_Sym);

	  dynamic_symbols = GET_ELF_SYMBOLS (file, &section, & num_dynamic_syms);
	  if (num_dynamic_syms < 1)
	    {
	      error (_("Unable to determine the number of symbols to load\n"));
	      continue;
	    }
	}
    }

  /* Similarly find a string table.  */
  if (dynamic_strings == NULL)
    {
      for (entry = dynamic_section;
	   entry < dynamic_section + dynamic_nent;
	   ++entry)
	{
	  unsigned long offset;
	  long str_tab_len;

	  if (entry->d_tag != DT_STRTAB)
	    continue;

	  dynamic_info[DT_STRTAB] = entry->d_un.d_val;

	  /* Since we do not know how big the string table is,
	     we default to reading in the entire file (!) and
	     processing that.  This is overkill, I know, but it
	     should work.  */

	  offset = offset_from_vma (file, entry->d_un.d_val, 0);

	  if (archive_file_offset != 0)
	    str_tab_len = archive_file_size - offset;
	  else
	    {
	      if (fseek (file, 0, SEEK_END))
		error (_("Unable to seek to end of file\n"));
	      str_tab_len = ftell (file) - offset;
	    }

	  if (str_tab_len < 1)
	    {
	      error
		(_("Unable to determine the length of the dynamic string table\n"));
	      continue;
	    }

	  dynamic_strings = (char *) get_data (NULL, file, offset, 1,
                                               str_tab_len,
                                               _("dynamic string table"));
	  dynamic_strings_length = dynamic_strings == NULL ? 0 : str_tab_len;
	  break;
	}
    }

  /* And find the syminfo section if available.  */
  if (dynamic_syminfo == NULL)
    {
      unsigned long syminsz = 0;

      for (entry = dynamic_section;
	   entry < dynamic_section + dynamic_nent;
	   ++entry)
	{
	  if (entry->d_tag == DT_SYMINENT)
	    {
	      /* Note: these braces are necessary to avoid a syntax
		 error from the SunOS4 C compiler.  */
	      assert (sizeof (Elf_External_Syminfo) == entry->d_un.d_val);
	    }
	  else if (entry->d_tag == DT_SYMINSZ)
	    syminsz = entry->d_un.d_val;
	  else if (entry->d_tag == DT_SYMINFO)
	    dynamic_syminfo_offset = offset_from_vma (file, entry->d_un.d_val,
						      syminsz);
	}

      if (dynamic_syminfo_offset != 0 && syminsz != 0)
	{
	  Elf_External_Syminfo * extsyminfo;
	  Elf_External_Syminfo * extsym;
	  Elf_Internal_Syminfo * syminfo;

	  /* There is a syminfo section.  Read the data.  */
	  extsyminfo = (Elf_External_Syminfo *)
              get_data (NULL, file, dynamic_syminfo_offset, 1, syminsz,
                        _("symbol information"));
	  if (!extsyminfo)
	    return 0;

	  dynamic_syminfo = (Elf_Internal_Syminfo *) malloc (syminsz);
	  if (dynamic_syminfo == NULL)
	    {
	      error (_("Out of memory\n"));
	      return 0;
	    }

	  dynamic_syminfo_nent = syminsz / sizeof (Elf_External_Syminfo);
	  for (syminfo = dynamic_syminfo, extsym = extsyminfo;
	       syminfo < dynamic_syminfo + dynamic_syminfo_nent;
	       ++syminfo, ++extsym)
	    {
	      syminfo->si_boundto = BYTE_GET (extsym->si_boundto);
	      syminfo->si_flags = BYTE_GET (extsym->si_flags);
	    }

	  free (extsyminfo);
	}
    }

  if (do_dynamic && dynamic_addr)
    printf (_("\nDynamic section at offset 0x%lx contains %u entries:\n"),
	    dynamic_addr, dynamic_nent);
  if (do_dynamic)
    printf (_("  Tag        Type                         Name/Value\n"));

  for (entry = dynamic_section;
       entry < dynamic_section + dynamic_nent;
       entry++)
    {
      if (do_dynamic)
	{
	  const char * dtype;

	  putchar (' ');
	  print_vma (entry->d_tag, FULL_HEX);
	  dtype = get_dynamic_type (entry->d_tag);
	  printf (" (%s)%*s", dtype,
		  ((is_32bit_elf ? 27 : 19)
		   - (int) strlen (dtype)),
		  " ");
	}

      switch (entry->d_tag)
	{
	case DT_FLAGS:
	  if (do_dynamic)
	    print_dynamic_flags (entry->d_un.d_val);
	  break;

	case DT_AUXILIARY:
	case DT_FILTER:
	case DT_CONFIG:
	case DT_DEPAUDIT:
	case DT_AUDIT:
	  if (do_dynamic)
	    {
	      switch (entry->d_tag)
		{
		case DT_AUXILIARY:
		  printf (_("Auxiliary library"));
		  break;

		case DT_FILTER:
		  printf (_("Filter library"));
		  break;

		case DT_CONFIG:
		  printf (_("Configuration file"));
		  break;

		case DT_DEPAUDIT:
		  printf (_("Dependency audit library"));
		  break;

		case DT_AUDIT:
		  printf (_("Audit library"));
		  break;
		}

	      if (VALID_DYNAMIC_NAME (entry->d_un.d_val))
		printf (": [%s]\n", GET_DYNAMIC_NAME (entry->d_un.d_val));
	      else
		{
		  printf (": ");
		  print_vma (entry->d_un.d_val, PREFIX_HEX);
		  putchar ('\n');
		}
	    }
	  break;

	case DT_FEATURE:
	  if (do_dynamic)
	    {
	      printf (_("Flags:"));

	      if (entry->d_un.d_val == 0)
		printf (_(" None\n"));
	      else
		{
		  unsigned long int val = entry->d_un.d_val;

		  if (val & DTF_1_PARINIT)
		    {
		      printf (" PARINIT");
		      val ^= DTF_1_PARINIT;
		    }
		  if (val & DTF_1_CONFEXP)
		    {
		      printf (" CONFEXP");
		      val ^= DTF_1_CONFEXP;
		    }
		  if (val != 0)
		    printf (" %lx", val);
		  puts ("");
		}
	    }
	  break;

	case DT_POSFLAG_1:
	  if (do_dynamic)
	    {
	      printf (_("Flags:"));

	      if (entry->d_un.d_val == 0)
		printf (_(" None\n"));
	      else
		{
		  unsigned long int val = entry->d_un.d_val;

		  if (val & DF_P1_LAZYLOAD)
		    {
		      printf (" LAZYLOAD");
		      val ^= DF_P1_LAZYLOAD;
		    }
		  if (val & DF_P1_GROUPPERM)
		    {
		      printf (" GROUPPERM");
		      val ^= DF_P1_GROUPPERM;
		    }
		  if (val != 0)
		    printf (" %lx", val);
		  puts ("");
		}
	    }
	  break;

	case DT_FLAGS_1:
	  if (do_dynamic)
	    {
	      printf (_("Flags:"));
	      if (entry->d_un.d_val == 0)
		printf (_(" None\n"));
	      else
		{
		  unsigned long int val = entry->d_un.d_val;

		  if (val & DF_1_NOW)
		    {
		      printf (" NOW");
		      val ^= DF_1_NOW;
		    }
		  if (val & DF_1_GLOBAL)
		    {
		      printf (" GLOBAL");
		      val ^= DF_1_GLOBAL;
		    }
		  if (val & DF_1_GROUP)
		    {
		      printf (" GROUP");
		      val ^= DF_1_GROUP;
		    }
		  if (val & DF_1_NODELETE)
		    {
		      printf (" NODELETE");
		      val ^= DF_1_NODELETE;
		    }
		  if (val & DF_1_LOADFLTR)
		    {
		      printf (" LOADFLTR");
		      val ^= DF_1_LOADFLTR;
		    }
		  if (val & DF_1_INITFIRST)
		    {
		      printf (" INITFIRST");
		      val ^= DF_1_INITFIRST;
		    }
		  if (val & DF_1_NOOPEN)
		    {
		      printf (" NOOPEN");
		      val ^= DF_1_NOOPEN;
		    }
		  if (val & DF_1_ORIGIN)
		    {
		      printf (" ORIGIN");
		      val ^= DF_1_ORIGIN;
		    }
		  if (val & DF_1_DIRECT)
		    {
		      printf (" DIRECT");
		      val ^= DF_1_DIRECT;
		    }
		  if (val & DF_1_TRANS)
		    {
		      printf (" TRANS");
		      val ^= DF_1_TRANS;
		    }
		  if (val & DF_1_INTERPOSE)
		    {
		      printf (" INTERPOSE");
		      val ^= DF_1_INTERPOSE;
		    }
		  if (val & DF_1_NODEFLIB)
		    {
		      printf (" NODEFLIB");
		      val ^= DF_1_NODEFLIB;
		    }
		  if (val & DF_1_NODUMP)
		    {
		      printf (" NODUMP");
		      val ^= DF_1_NODUMP;
		    }
		  if (val & DF_1_CONFALT)
		    {
		      printf (" CONFALT");
		      val ^= DF_1_CONFALT;
		    }
		  if (val & DF_1_ENDFILTEE)
		    {
		      printf (" ENDFILTEE");
		      val ^= DF_1_ENDFILTEE;
		    }
		  if (val & DF_1_DISPRELDNE)
		    {
		      printf (" DISPRELDNE");
		      val ^= DF_1_DISPRELDNE;
		    }
		  if (val & DF_1_DISPRELPND)
		    {
		      printf (" DISPRELPND");
		      val ^= DF_1_DISPRELPND;
		    }
		  if (val & DF_1_NODIRECT)
		    {
		      printf (" NODIRECT");
		      val ^= DF_1_NODIRECT;
		    }
		  if (val & DF_1_IGNMULDEF)
		    {
		      printf (" IGNMULDEF");
		      val ^= DF_1_IGNMULDEF;
		    }
		  if (val & DF_1_NOKSYMS)
		    {
		      printf (" NOKSYMS");
		      val ^= DF_1_NOKSYMS;
		    }
		  if (val & DF_1_NOHDR)
		    {
		      printf (" NOHDR");
		      val ^= DF_1_NOHDR;
		    }
		  if (val & DF_1_EDITED)
		    {
		      printf (" EDITED");
		      val ^= DF_1_EDITED;
		    }
		  if (val & DF_1_NORELOC)
		    {
		      printf (" NORELOC");
		      val ^= DF_1_NORELOC;
		    }
		  if (val & DF_1_SYMINTPOSE)
		    {
		      printf (" SYMINTPOSE");
		      val ^= DF_1_SYMINTPOSE;
		    }
		  if (val & DF_1_GLOBAUDIT)
		    {
		      printf (" GLOBAUDIT");
		      val ^= DF_1_GLOBAUDIT;
		    }
		  if (val & DF_1_SINGLETON)
		    {
		      printf (" SINGLETON");
		      val ^= DF_1_SINGLETON;
		    }
		  if (val != 0)
		    printf (" %lx", val);
		  puts ("");
		}
	    }
	  break;

	case DT_PLTREL:
	  dynamic_info[entry->d_tag] = entry->d_un.d_val;
	  if (do_dynamic)
	    puts (get_dynamic_type (entry->d_un.d_val));
	  break;

	case DT_NULL	:
	case DT_NEEDED	:
	case DT_PLTGOT	:
	case DT_HASH	:
	case DT_STRTAB	:
	case DT_SYMTAB	:
	case DT_RELA	:
	case DT_INIT	:
	case DT_FINI	:
	case DT_SONAME	:
	case DT_RPATH	:
	case DT_SYMBOLIC:
	case DT_REL	:
	case DT_DEBUG	:
	case DT_TEXTREL	:
	case DT_JMPREL	:
	case DT_RUNPATH	:
	  dynamic_info[entry->d_tag] = entry->d_un.d_val;

	  if (do_dynamic)
	    {
	      char * name;

	      if (VALID_DYNAMIC_NAME (entry->d_un.d_val))
		name = GET_DYNAMIC_NAME (entry->d_un.d_val);
	      else
		name = NULL;

	      if (name)
		{
		  switch (entry->d_tag)
		    {
		    case DT_NEEDED:
		      printf (_("Shared library: [%s]"), name);

		      if (streq (name, program_interpreter))
			printf (_(" program interpreter"));
		      break;

		    case DT_SONAME:
		      printf (_("Library soname: [%s]"), name);
		      break;

		    case DT_RPATH:
		      printf (_("Library rpath: [%s]"), name);
		      break;

		    case DT_RUNPATH:
		      printf (_("Library runpath: [%s]"), name);
		      break;

		    default:
		      print_vma (entry->d_un.d_val, PREFIX_HEX);
		      break;
		    }
		}
	      else
		print_vma (entry->d_un.d_val, PREFIX_HEX);

	      putchar ('\n');
	    }
	  break;

	case DT_PLTRELSZ:
	case DT_RELASZ	:
	case DT_STRSZ	:
	case DT_RELSZ	:
	case DT_RELAENT	:
	case DT_SYMENT	:
	case DT_RELENT	:
	  dynamic_info[entry->d_tag] = entry->d_un.d_val;
	case DT_PLTPADSZ:
	case DT_MOVEENT	:
	case DT_MOVESZ	:
	case DT_INIT_ARRAYSZ:
	case DT_FINI_ARRAYSZ:
	case DT_GNU_CONFLICTSZ:
	case DT_GNU_LIBLISTSZ:
	  if (do_dynamic)
	    {
	      print_vma (entry->d_un.d_val, UNSIGNED);
	      printf (_(" (bytes)\n"));
	    }
	  break;

	case DT_VERDEFNUM:
	case DT_VERNEEDNUM:
	case DT_RELACOUNT:
	case DT_RELCOUNT:
	  if (do_dynamic)
	    {
	      print_vma (entry->d_un.d_val, UNSIGNED);
	      putchar ('\n');
	    }
	  break;

	case DT_SYMINSZ:
	case DT_SYMINENT:
	case DT_SYMINFO:
	case DT_USED:
	case DT_INIT_ARRAY:
	case DT_FINI_ARRAY:
	  if (do_dynamic)
	    {
	      if (entry->d_tag == DT_USED
		  && VALID_DYNAMIC_NAME (entry->d_un.d_val))
		{
		  char * name = GET_DYNAMIC_NAME (entry->d_un.d_val);

		  if (*name)
		    {
		      printf (_("Not needed object: [%s]\n"), name);
		      break;
		    }
		}

	      print_vma (entry->d_un.d_val, PREFIX_HEX);
	      putchar ('\n');
	    }
	  break;

	case DT_BIND_NOW:
	  /* The value of this entry is ignored.  */
	  if (do_dynamic)
	    putchar ('\n');
	  break;

	case DT_GNU_PRELINKED:
	  if (do_dynamic)
	    {
	      struct tm * tmp;
	      time_t atime = entry->d_un.d_val;

	      tmp = gmtime (&atime);
	      printf ("%04u-%02u-%02uT%02u:%02u:%02u\n",
		      tmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,
		      tmp->tm_hour, tmp->tm_min, tmp->tm_sec);

	    }
	  break;

	case DT_GNU_HASH:
	  dynamic_info_DT_GNU_HASH = entry->d_un.d_val;
	  if (do_dynamic)
	    {
	      print_vma (entry->d_un.d_val, PREFIX_HEX);
	      putchar ('\n');
	    }
	  break;

	default:
	  if ((entry->d_tag >= DT_VERSYM) && (entry->d_tag <= DT_VERNEEDNUM))
	    version_info[DT_VERSIONTAGIDX (entry->d_tag)] =
	      entry->d_un.d_val;

	  if (do_dynamic)
	    {
	      switch (elf_header.e_machine)
		{
		case EM_MIPS:
		case EM_MIPS_RS3_LE:
		  dynamic_section_mips_val (entry);
		  break;
		case EM_PARISC:
		  dynamic_section_parisc_val (entry);
		  break;
		case EM_IA_64:
		  dynamic_section_ia64_val (entry);
		  break;
		default:
		  print_vma (entry->d_un.d_val, PREFIX_HEX);
		  putchar ('\n');
		}
	    }
	  break;
	}
    }

  return 1;
}

static char *
get_ver_flags (unsigned int flags)
{
  static char buff[32];

  buff[0] = 0;

  if (flags == 0)
    return _("none");

  if (flags & VER_FLG_BASE)
    strcat (buff, "BASE ");

  if (flags & VER_FLG_WEAK)
    {
      if (flags & VER_FLG_BASE)
	strcat (buff, "| ");

      strcat (buff, "WEAK ");
    }

  if (flags & VER_FLG_INFO)
    {
      if (flags & (VER_FLG_BASE|VER_FLG_WEAK))
	strcat (buff, "| ");

      strcat (buff, "INFO ");
    }

  if (flags & ~(VER_FLG_BASE | VER_FLG_WEAK | VER_FLG_INFO))
    strcat (buff, _("| <unknown>"));

  return buff;
}

/* Display the contents of the version sections.  */

static int
process_version_sections (FILE * file)
{
  Elf_Internal_Shdr * section;
  unsigned i;
  int found = 0;

  if (! do_version)
    return 1;

  for (i = 0, section = section_headers;
       i < elf_header.e_shnum;
       i++, section++)
    {
      switch (section->sh_type)
	{
	case SHT_GNU_verdef:
	  {
	    Elf_External_Verdef * edefs;
	    unsigned int idx;
	    unsigned int cnt;
	    char * endbuf;

	    found = 1;

	    printf
	      (_("\nVersion definition section '%s' contains %u entries:\n"),
	       SECTION_NAME (section), section->sh_info);

	    printf (_("  Addr: 0x"));
	    printf_vma (section->sh_addr);
	    printf (_("  Offset: %#08lx  Link: %u (%s)\n"),
		    (unsigned long) section->sh_offset, section->sh_link,
		    section->sh_link < elf_header.e_shnum
		    ? SECTION_NAME (section_headers + section->sh_link)
		    : _("<corrupt>"));

	    edefs = (Elf_External_Verdef *)
                get_data (NULL, file, section->sh_offset, 1,section->sh_size,
                          _("version definition section"));
	    if (!edefs)
	      break;
	    endbuf = (char *) edefs + section->sh_size;

	    for (idx = cnt = 0; cnt < section->sh_info; ++cnt)
	      {
		char * vstart;
		Elf_External_Verdef * edef;
		Elf_Internal_Verdef ent;
		Elf_External_Verdaux * eaux;
		Elf_Internal_Verdaux aux;
		int j;
		int isum;

		/* Check for very large indicies.  */
		if (idx > (size_t) (endbuf - (char *) edefs))
		  break;

		vstart = ((char *) edefs) + idx;
		if (vstart + sizeof (*edef) > endbuf)
		  break;

		edef = (Elf_External_Verdef *) vstart;

		ent.vd_version = BYTE_GET (edef->vd_version);
		ent.vd_flags   = BYTE_GET (edef->vd_flags);
		ent.vd_ndx     = BYTE_GET (edef->vd_ndx);
		ent.vd_cnt     = BYTE_GET (edef->vd_cnt);
		ent.vd_hash    = BYTE_GET (edef->vd_hash);
		ent.vd_aux     = BYTE_GET (edef->vd_aux);
		ent.vd_next    = BYTE_GET (edef->vd_next);

		printf (_("  %#06x: Rev: %d  Flags: %s"),
			idx, ent.vd_version, get_ver_flags (ent.vd_flags));

		printf (_("  Index: %d  Cnt: %d  "),
			ent.vd_ndx, ent.vd_cnt);

		/* Check for overflow.  */
		if (ent.vd_aux > (size_t) (endbuf - vstart))
		  break;

		vstart += ent.vd_aux;

		eaux = (Elf_External_Verdaux *) vstart;

		aux.vda_name = BYTE_GET (eaux->vda_name);
		aux.vda_next = BYTE_GET (eaux->vda_next);

		if (VALID_DYNAMIC_NAME (aux.vda_name))
		  printf (_("Name: %s\n"), GET_DYNAMIC_NAME (aux.vda_name));
		else
		  printf (_("Name index: %ld\n"), aux.vda_name);

		isum = idx + ent.vd_aux;

		for (j = 1; j < ent.vd_cnt; j++)
		  {
		    /* Check for overflow.  */
		    if (aux.vda_next > (size_t) (endbuf - vstart))
		      break;

		    isum   += aux.vda_next;
		    vstart += aux.vda_next;

		    eaux = (Elf_External_Verdaux *) vstart;
		    if (vstart + sizeof (*eaux) > endbuf)
		      break;

		    aux.vda_name = BYTE_GET (eaux->vda_name);
		    aux.vda_next = BYTE_GET (eaux->vda_next);

		    if (VALID_DYNAMIC_NAME (aux.vda_name))
		      printf (_("  %#06x: Parent %d: %s\n"),
			      isum, j, GET_DYNAMIC_NAME (aux.vda_name));
		    else
		      printf (_("  %#06x: Parent %d, name index: %ld\n"),
			      isum, j, aux.vda_name);
		  }

		if (j < ent.vd_cnt)
		  printf (_("  Version def aux past end of section\n"));

		idx += ent.vd_next;
	      }

	    if (cnt < section->sh_info)
	      printf (_("  Version definition past end of section\n"));

	    free (edefs);
	  }
	  break;

	case SHT_GNU_verneed:
	  {
	    Elf_External_Verneed * eneed;
	    unsigned int idx;
	    unsigned int cnt;
	    char * endbuf;

	    found = 1;

	    printf (_("\nVersion needs section '%s' contains %u entries:\n"),
		    SECTION_NAME (section), section->sh_info);

	    printf (_(" Addr: 0x"));
	    printf_vma (section->sh_addr);
	    printf (_("  Offset: %#08lx  Link: %u (%s)\n"),
		    (unsigned long) section->sh_offset, section->sh_link,
		    section->sh_link < elf_header.e_shnum
		    ? SECTION_NAME (section_headers + section->sh_link)
		    : _("<corrupt>"));

	    eneed = (Elf_External_Verneed *) get_data (NULL, file,
                                                       section->sh_offset, 1,
                                                       section->sh_size,
                                                       _("Version Needs section"));
	    if (!eneed)
	      break;
	    endbuf = (char *) eneed + section->sh_size;

	    for (idx = cnt = 0; cnt < section->sh_info; ++cnt)
	      {
		Elf_External_Verneed * entry;
		Elf_Internal_Verneed ent;
		int j;
		int isum;
		char * vstart;

		if (idx > (size_t) (endbuf - (char *) eneed))
		  break;

		vstart = ((char *) eneed) + idx;
		if (vstart + sizeof (*entry) > endbuf)
		  break;

		entry = (Elf_External_Verneed *) vstart;

		ent.vn_version = BYTE_GET (entry->vn_version);
		ent.vn_cnt     = BYTE_GET (entry->vn_cnt);
		ent.vn_file    = BYTE_GET (entry->vn_file);
		ent.vn_aux     = BYTE_GET (entry->vn_aux);
		ent.vn_next    = BYTE_GET (entry->vn_next);

		printf (_("  %#06x: Version: %d"), idx, ent.vn_version);

		if (VALID_DYNAMIC_NAME (ent.vn_file))
		  printf (_("  File: %s"), GET_DYNAMIC_NAME (ent.vn_file));
		else
		  printf (_("  File: %lx"), ent.vn_file);

		printf (_("  Cnt: %d\n"), ent.vn_cnt);

		/* Check for overflow.  */
		if (ent.vn_aux > (size_t) (endbuf - vstart))
		  break;

		vstart += ent.vn_aux;

		for (j = 0, isum = idx + ent.vn_aux; j < ent.vn_cnt; ++j)
		  {
		    Elf_External_Vernaux * eaux;
		    Elf_Internal_Vernaux aux;

		    if (vstart + sizeof (*eaux) > endbuf)
		      break;
		    eaux = (Elf_External_Vernaux *) vstart;

		    aux.vna_hash  = BYTE_GET (eaux->vna_hash);
		    aux.vna_flags = BYTE_GET (eaux->vna_flags);
		    aux.vna_other = BYTE_GET (eaux->vna_other);
		    aux.vna_name  = BYTE_GET (eaux->vna_name);
		    aux.vna_next  = BYTE_GET (eaux->vna_next);

		    if (VALID_DYNAMIC_NAME (aux.vna_name))
		      printf (_("  %#06x:   Name: %s"),
			      isum, GET_DYNAMIC_NAME (aux.vna_name));
		    else
		      printf (_("  %#06x:   Name index: %lx"),
			      isum, aux.vna_name);

		    printf (_("  Flags: %s  Version: %d\n"),
			    get_ver_flags (aux.vna_flags), aux.vna_other);

		    /* Check for overflow.  */
		    if (aux.vna_next > (size_t) (endbuf - vstart))
		      break;

		    isum   += aux.vna_next;
		    vstart += aux.vna_next;
		  }

		if (j < ent.vn_cnt)
		  warn (_("Missing Version Needs auxillary information\n"));

		idx += ent.vn_next;
	      }

	    if (cnt < section->sh_info)
	      warn (_("Missing Version Needs information\n"));

	    free (eneed);
	  }
	  break;

	case SHT_GNU_versym:
	  {
	    Elf_Internal_Shdr * link_section;
	    int total;
	    int cnt;
	    unsigned char * edata;
	    unsigned short * data;
	    char * strtab;
	    Elf_Internal_Sym * symbols;
	    Elf_Internal_Shdr * string_sec;
	    unsigned long num_syms;
	    long off;

	    if (section->sh_link >= elf_header.e_shnum)
	      break;

	    link_section = section_headers + section->sh_link;
	    total = section->sh_size / sizeof (Elf_External_Versym);

	    if (link_section->sh_link >= elf_header.e_shnum)
	      break;

	    found = 1;

	    symbols = GET_ELF_SYMBOLS (file, link_section, & num_syms);
	    if (symbols == NULL)
	      break;

	    string_sec = section_headers + link_section->sh_link;

	    strtab = (char *) get_data (NULL, file, string_sec->sh_offset, 1,
                                        string_sec->sh_size,
                                        _("version string table"));
	    if (!strtab)
	      {
		free (symbols);
		break;
	      }

	    printf (_("\nVersion symbols section '%s' contains %d entries:\n"),
		    SECTION_NAME (section), total);

	    printf (_(" Addr: "));
	    printf_vma (section->sh_addr);
	    printf (_("  Offset: %#08lx  Link: %u (%s)\n"),
		    (unsigned long) section->sh_offset, section->sh_link,
		    SECTION_NAME (link_section));

	    off = offset_from_vma (file,
				   version_info[DT_VERSIONTAGIDX (DT_VERSYM)],
				   total * sizeof (short));
	    edata = (unsigned char *) get_data (NULL, file, off, total,
                                                sizeof (short),
                                                _("version symbol data"));
	    if (!edata)
	      {
		free (strtab);
		free (symbols);
		break;
	      }

	    data = (short unsigned int *) cmalloc (total, sizeof (short));

	    for (cnt = total; cnt --;)
	      data[cnt] = byte_get (edata + cnt * sizeof (short),
				    sizeof (short));

	    free (edata);

	    for (cnt = 0; cnt < total; cnt += 4)
	      {
		int j, nn;
		int check_def, check_need;
		char * name;

		printf ("  %03x:", cnt);

		for (j = 0; (j < 4) && (cnt + j) < total; ++j)
		  switch (data[cnt + j])
		    {
		    case 0:
		      fputs (_("   0 (*local*)    "), stdout);
		      break;

		    case 1:
		      fputs (_("   1 (*global*)   "), stdout);
		      break;

		    default:
		      nn = printf ("%4x%c", data[cnt + j] & VERSYM_VERSION,
				   data[cnt + j] & VERSYM_HIDDEN ? 'h' : ' ');

		      /* If this index value is greater than the size of the symbols
		         array, break to avoid an out-of-bounds read.  */
		      if ((unsigned long)(cnt + j) >= num_syms)
		        {
		          warn (_("invalid index into symbol array\n"));
		          break;
			}

		      check_def = 1;
		      check_need = 1;
		      if (symbols[cnt + j].st_shndx >= elf_header.e_shnum
			  || section_headers[symbols[cnt + j].st_shndx].sh_type
			     != SHT_NOBITS)
			{
			  if (symbols[cnt + j].st_shndx == SHN_UNDEF)
			    check_def = 0;
			  else
			    check_need = 0;
			}

		      if (check_need
			  && version_info[DT_VERSIONTAGIDX (DT_VERNEED)])
			{
			  Elf_Internal_Verneed ivn;
			  unsigned long offset;

			  offset = offset_from_vma
			    (file, version_info[DT_VERSIONTAGIDX (DT_VERNEED)],
			     sizeof (Elf_External_Verneed));

			  do
			    {
			      Elf_Internal_Vernaux ivna;
			      Elf_External_Verneed evn;
			      Elf_External_Vernaux evna;
			      unsigned long a_off;

			      if (get_data (&evn, file, offset, sizeof (evn), 1,
					    _("version need")) == NULL)
				break;

			      ivn.vn_aux  = BYTE_GET (evn.vn_aux);
			      ivn.vn_next = BYTE_GET (evn.vn_next);

			      a_off = offset + ivn.vn_aux;

			      do
				{
				  if (get_data (&evna, file, a_off, sizeof (evna),
						1, _("version need aux (2)")) == NULL)
				    {
				      ivna.vna_next  = 0;
				      ivna.vna_other = 0;
				    }
				  else
				    {
				      ivna.vna_next  = BYTE_GET (evna.vna_next);
				      ivna.vna_other = BYTE_GET (evna.vna_other);
				    }

				  a_off += ivna.vna_next;
				}
			      while (ivna.vna_other != data[cnt + j]
				     && ivna.vna_next != 0);

			      if (ivna.vna_other == data[cnt + j])
				{
				  ivna.vna_name = BYTE_GET (evna.vna_name);

				  if (ivna.vna_name >= string_sec->sh_size)
				    name = _("*invalid*");
				  else
				    name = strtab + ivna.vna_name;
				  nn += printf ("(%s%-*s",
						name,
						12 - (int) strlen (name),
						")");
				  check_def = 0;
				  break;
				}

			      offset += ivn.vn_next;
			    }
			  while (ivn.vn_next);
			}

		      if (check_def && data[cnt + j] != 0x8001
			  && version_info[DT_VERSIONTAGIDX (DT_VERDEF)])
			{
			  Elf_Internal_Verdef ivd;
			  Elf_External_Verdef evd;
			  unsigned long offset;

			  offset = offset_from_vma
			    (file, version_info[DT_VERSIONTAGIDX (DT_VERDEF)],
			     sizeof evd);

			  do
			    {
			      if (get_data (&evd, file, offset, sizeof (evd), 1,
					    _("version def")) == NULL)
				{
				  ivd.vd_next = 0;
				  ivd.vd_ndx  = 0;
				}
			      else
				{
				  ivd.vd_next = BYTE_GET (evd.vd_next);
				  ivd.vd_ndx  = BYTE_GET (evd.vd_ndx);
				}

			      offset += ivd.vd_next;
			    }
			  while (ivd.vd_ndx != (data[cnt + j] & VERSYM_VERSION)
				 && ivd.vd_next != 0);

			  if (ivd.vd_ndx == (data[cnt + j] & VERSYM_VERSION))
			    {
			      Elf_External_Verdaux evda;
			      Elf_Internal_Verdaux ivda;

			      ivd.vd_aux = BYTE_GET (evd.vd_aux);

			      if (get_data (&evda, file,
					    offset - ivd.vd_next + ivd.vd_aux,
					    sizeof (evda), 1,
					    _("version def aux")) == NULL)
				break;

			      ivda.vda_name = BYTE_GET (evda.vda_name);

			      if (ivda.vda_name >= string_sec->sh_size)
				name = _("*invalid*");
			      else
				name = strtab + ivda.vda_name;
			      nn += printf ("(%s%-*s",
					    name,
					    12 - (int) strlen (name),
					    ")");
			    }
			}

		      if (nn < 18)
			printf ("%*c", 18 - nn, ' ');
		    }

		putchar ('\n');
	      }

	    free (data);
	    free (strtab);
	    free (symbols);
	  }
	  break;

	default:
	  break;
	}
    }

  if (! found)
    printf (_("\nNo version information found in this file.\n"));

  return 1;
}

static const char *
get_symbol_binding (unsigned int binding)
{
  static char buff[32];

  switch (binding)
    {
    case STB_LOCAL:	return "LOCAL";
    case STB_GLOBAL:	return "GLOBAL";
    case STB_WEAK:	return "WEAK";
    default:
      if (binding >= STB_LOPROC && binding <= STB_HIPROC)
	snprintf (buff, sizeof (buff), _("<processor specific>: %d"),
		  binding);
      else if (binding >= STB_LOOS && binding <= STB_HIOS)
	{
	  if (binding == STB_GNU_UNIQUE
	      && (elf_header.e_ident[EI_OSABI] == ELFOSABI_GNU
		  /* GNU is still using the default value 0.  */
		  || elf_header.e_ident[EI_OSABI] == ELFOSABI_NONE))
	    return "UNIQUE";
	  snprintf (buff, sizeof (buff), _("<OS specific>: %d"), binding);
	}
      else
	snprintf (buff, sizeof (buff), _("<unknown>: %d"), binding);
      return buff;
    }
}

static const char *
get_symbol_type (unsigned int type)
{
  static char buff[32];

  switch (type)
    {
    case STT_NOTYPE:	return "NOTYPE";
    case STT_OBJECT:	return "OBJECT";
    case STT_FUNC:	return "FUNC";
    case STT_SECTION:	return "SECTION";
    case STT_FILE:	return "FILE";
    case STT_COMMON:	return "COMMON";
    case STT_TLS:	return "TLS";
    case STT_RELC:      return "RELC";
    case STT_SRELC:     return "SRELC";
    default:
      if (type >= STT_LOPROC && type <= STT_HIPROC)
	{
	  if (elf_header.e_machine == EM_ARM)
	    {
	      if (type == STT_ARM_TFUNC)
		return "THUMB_FUNC";
	      if (type == STT_ARM_16BIT)
		return "THUMB_LABEL";
	    }

	  if (elf_header.e_machine == EM_SPARCV9 && type == STT_REGISTER)
	    return "REGISTER";

	  if (elf_header.e_machine == EM_PARISC && type == STT_PARISC_MILLI)
	    return "PARISC_MILLI";

	  snprintf (buff, sizeof (buff), _("<processor specific>: %d"), type);
	}
      else if (type >= STT_LOOS && type <= STT_HIOS)
	{
	  if (elf_header.e_machine == EM_PARISC)
	    {
	      if (type == STT_HP_OPAQUE)
		return "HP_OPAQUE";
	      if (type == STT_HP_STUB)
		return "HP_STUB";
	    }

	  if (type == STT_GNU_IFUNC
	      && (elf_header.e_ident[EI_OSABI] == ELFOSABI_GNU
		  || elf_header.e_ident[EI_OSABI] == ELFOSABI_FREEBSD
		  /* GNU is still using the default value 0.  */
		  || elf_header.e_ident[EI_OSABI] == ELFOSABI_NONE))
	    return "IFUNC";

	  snprintf (buff, sizeof (buff), _("<OS specific>: %d"), type);
	}
      else
	snprintf (buff, sizeof (buff), _("<unknown>: %d"), type);
      return buff;
    }
}

static const char *
get_symbol_visibility (unsigned int visibility)
{
  switch (visibility)
    {
    case STV_DEFAULT:	return "DEFAULT";
    case STV_INTERNAL:	return "INTERNAL";
    case STV_HIDDEN:	return "HIDDEN";
    case STV_PROTECTED: return "PROTECTED";
    default: abort ();
    }
}

static const char *
get_mips_symbol_other (unsigned int other)
{
  switch (other)
    {
    case STO_OPTIONAL:
      return "OPTIONAL";
    case STO_MIPS_PLT:
      return "MIPS PLT";
    case STO_MIPS_PIC:
      return "MIPS PIC";
    case STO_MICROMIPS:
      return "MICROMIPS";
    case STO_MICROMIPS | STO_MIPS_PIC:
      return "MICROMIPS, MIPS PIC";
    case STO_MIPS16:
      return "MIPS16";
    default:
      return NULL;
    }
}

static const char *
get_ia64_symbol_other (unsigned int other)
{
  if (is_ia64_vms ())
    {
      static char res[32];

      res[0] = 0;

      /* Function types is for images and .STB files only.  */
      switch (elf_header.e_type)
        {
        case ET_DYN:
        case ET_EXEC:
          switch (VMS_ST_FUNC_TYPE (other))
            {
            case VMS_SFT_CODE_ADDR:
              strcat (res, " CA");
              break;
            case VMS_SFT_SYMV_IDX:
              strcat (res, " VEC");
              break;
            case VMS_SFT_FD:
              strcat (res, " FD");
              break;
            case VMS_SFT_RESERVE:
              strcat (res, " RSV");
              break;
            default:
              abort ();
            }
          break;
        default:
          break;
        }
      switch (VMS_ST_LINKAGE (other))
        {
        case VMS_STL_IGNORE:
          strcat (res, " IGN");
          break;
        case VMS_STL_RESERVE:
          strcat (res, " RSV");
          break;
        case VMS_STL_STD:
          strcat (res, " STD");
          break;
        case VMS_STL_LNK:
          strcat (res, " LNK");
          break;
        default:
          abort ();
        }

      if (res[0] != 0)
        return res + 1;
      else
        return res;
    }
  return NULL;
}

static const char *
get_symbol_other (unsigned int other)
{
  const char * result = NULL;
  static char buff [32];

  if (other == 0)
    return "";

  switch (elf_header.e_machine)
    {
    case EM_MIPS:
      result = get_mips_symbol_other (other);
      break;
    case EM_IA_64:
      result = get_ia64_symbol_other (other);
      break;
    default:
      break;
    }

  if (result)
    return result;

  snprintf (buff, sizeof buff, _("<other>: %x"), other);
  return buff;
}

static const char *
get_symbol_index_type (unsigned int type)
{
  static char buff[32];

  switch (type)
    {
    case SHN_UNDEF:	return "UND";
    case SHN_ABS:	return "ABS";
    case SHN_COMMON:	return "COM";
    default:
      if (type == SHN_IA_64_ANSI_COMMON
	  && elf_header.e_machine == EM_IA_64
	  && elf_header.e_ident[EI_OSABI] == ELFOSABI_HPUX)
	return "ANSI_COM";
      else if ((elf_header.e_machine == EM_X86_64
		|| elf_header.e_machine == EM_L1OM
		|| elf_header.e_machine == EM_K1OM)
	       && type == SHN_X86_64_LCOMMON)
	return "LARGE_COM";
      else if ((type == SHN_MIPS_SCOMMON
		&& elf_header.e_machine == EM_MIPS)
	       || (type == SHN_TIC6X_SCOMMON
		   && elf_header.e_machine == EM_TI_C6000))
	return "SCOM";
      else if (type == SHN_MIPS_SUNDEFINED
	       && elf_header.e_machine == EM_MIPS)
	return "SUND";
      else if (type >= SHN_LOPROC && type <= SHN_HIPROC)
	sprintf (buff, "PRC[0x%04x]", type & 0xffff);
      else if (type >= SHN_LOOS && type <= SHN_HIOS)
	sprintf (buff, "OS [0x%04x]", type & 0xffff);
      else if (type >= SHN_LORESERVE)
	sprintf (buff, "RSV[0x%04x]", type & 0xffff);
      else if (type >= elf_header.e_shnum)
	sprintf (buff, "bad section index[%3d]", type);
      else
	sprintf (buff, "%3d", type);
      break;
    }

  return buff;
}

static bfd_vma *
get_dynamic_data (FILE * file, unsigned int number, unsigned int ent_size)
{
  unsigned char * e_data;
  bfd_vma * i_data;

  e_data = (unsigned char *) cmalloc (number, ent_size);

  if (e_data == NULL)
    {
      error (_("Out of memory\n"));
      return NULL;
    }

  if (fread (e_data, ent_size, number, file) != number)
    {
      error (_("Unable to read in dynamic data\n"));
      return NULL;
    }

  i_data = (bfd_vma *) cmalloc (number, sizeof (*i_data));

  if (i_data == NULL)
    {
      error (_("Out of memory\n"));
      free (e_data);
      return NULL;
    }

  while (number--)
    i_data[number] = byte_get (e_data + number * ent_size, ent_size);

  free (e_data);

  return i_data;
}

static void
print_dynamic_symbol (bfd_vma si, unsigned long hn)
{
  Elf_Internal_Sym * psym;
  int n;

  psym = dynamic_symbols + si;

  n = print_vma (si, DEC_5);
  if (n < 5)
    fputs (&"     "[n], stdout);
  printf (" %3lu: ", hn);
  print_vma (psym->st_value, LONG_HEX);
  putchar (' ');
  print_vma (psym->st_size, DEC_5);

  printf (" %-7s", get_symbol_type (ELF_ST_TYPE (psym->st_info)));
  printf (" %-6s",  get_symbol_binding (ELF_ST_BIND (psym->st_info)));
  printf (" %-7s",  get_symbol_visibility (ELF_ST_VISIBILITY (psym->st_other)));
  /* Check to see if any other bits in the st_other field are set.
     Note - displaying this information disrupts the layout of the
     table being generated, but for the moment this case is very
     rare.  */
  if (psym->st_other ^ ELF_ST_VISIBILITY (psym->st_other))
    printf (" [%s] ", get_symbol_other (psym->st_other ^ ELF_ST_VISIBILITY (psym->st_other)));
  printf (" %3.3s ", get_symbol_index_type (psym->st_shndx));
  if (VALID_DYNAMIC_NAME (psym->st_name))
    print_symbol (25, GET_DYNAMIC_NAME (psym->st_name));
  else
    printf (_(" <corrupt: %14ld>"), psym->st_name);
  putchar ('\n');
}

/* Dump the symbol table.  */
static int
process_symbol_table (FILE * file)
{
  Elf_Internal_Shdr * section;
  bfd_vma nbuckets = 0;
  bfd_vma nchains = 0;
  bfd_vma * buckets = NULL;
  bfd_vma * chains = NULL;
  bfd_vma ngnubuckets = 0;
  bfd_vma * gnubuckets = NULL;
  bfd_vma * gnuchains = NULL;
  bfd_vma gnusymidx = 0;

  if (!do_syms && !do_dyn_syms && !do_histogram)
    return 1;

  if (dynamic_info[DT_HASH]
      && (do_histogram
	  || (do_using_dynamic
	      && !do_dyn_syms
	      && dynamic_strings != NULL)))
    {
      unsigned char nb[8];
      unsigned char nc[8];
      int hash_ent_size = 4;

      if ((elf_header.e_machine == EM_ALPHA
	   || elf_header.e_machine == EM_S390
	   || elf_header.e_machine == EM_S390_OLD)
	  && elf_header.e_ident[EI_CLASS] == ELFCLASS64)
	hash_ent_size = 8;

      if (fseek (file,
		 (archive_file_offset
		  + offset_from_vma (file, dynamic_info[DT_HASH],
				     sizeof nb + sizeof nc)),
		 SEEK_SET))
	{
	  error (_("Unable to seek to start of dynamic information\n"));
	  goto no_hash;
	}

      if (fread (nb, hash_ent_size, 1, file) != 1)
	{
	  error (_("Failed to read in number of buckets\n"));
	  goto no_hash;
	}

      if (fread (nc, hash_ent_size, 1, file) != 1)
	{
	  error (_("Failed to read in number of chains\n"));
	  goto no_hash;
	}

      nbuckets = byte_get (nb, hash_ent_size);
      nchains  = byte_get (nc, hash_ent_size);

      buckets = get_dynamic_data (file, nbuckets, hash_ent_size);
      chains  = get_dynamic_data (file, nchains, hash_ent_size);

    no_hash:
      if (buckets == NULL || chains == NULL)
	{
	  if (do_using_dynamic)
	    return 0;
	  free (buckets);
	  free (chains);
	  buckets = NULL;
	  chains = NULL;
	  nbuckets = 0;
	  nchains = 0;
	}
    }

  if (dynamic_info_DT_GNU_HASH
      && (do_histogram
	  || (do_using_dynamic
	      && !do_dyn_syms
	      && dynamic_strings != NULL)))
    {
      unsigned char nb[16];
      bfd_vma i, maxchain = 0xffffffff, bitmaskwords;
      bfd_vma buckets_vma;

      if (fseek (file,
		 (archive_file_offset
		  + offset_from_vma (file, dynamic_info_DT_GNU_HASH,
				     sizeof nb)),
		 SEEK_SET))
	{
	  error (_("Unable to seek to start of dynamic information\n"));
	  goto no_gnu_hash;
	}

      if (fread (nb, 16, 1, file) != 1)
	{
	  error (_("Failed to read in number of buckets\n"));
	  goto no_gnu_hash;
	}

      ngnubuckets = byte_get (nb, 4);
      gnusymidx = byte_get (nb + 4, 4);
      bitmaskwords = byte_get (nb + 8, 4);
      buckets_vma = dynamic_info_DT_GNU_HASH + 16;
      if (is_32bit_elf)
	buckets_vma += bitmaskwords * 4;
      else
	buckets_vma += bitmaskwords * 8;

      if (fseek (file,
		 (archive_file_offset
		  + offset_from_vma (file, buckets_vma, 4)),
		 SEEK_SET))
	{
	  error (_("Unable to seek to start of dynamic information\n"));
	  goto no_gnu_hash;
	}

      gnubuckets = get_dynamic_data (file, ngnubuckets, 4);

      if (gnubuckets == NULL)
	goto no_gnu_hash;

      for (i = 0; i < ngnubuckets; i++)
	if (gnubuckets[i] != 0)
	  {
	    if (gnubuckets[i] < gnusymidx)
	      return 0;

	    if (maxchain == 0xffffffff || gnubuckets[i] > maxchain)
	      maxchain = gnubuckets[i];
	  }

      if (maxchain == 0xffffffff)
	goto no_gnu_hash;

      maxchain -= gnusymidx;

      if (fseek (file,
		 (archive_file_offset
		  + offset_from_vma (file, buckets_vma
					   + 4 * (ngnubuckets + maxchain), 4)),
		 SEEK_SET))
	{
	  error (_("Unable to seek to start of dynamic information\n"));
	  goto no_gnu_hash;
	}

      do
	{
	  if (fread (nb, 4, 1, file) != 1)
	    {
	      error (_("Failed to determine last chain length\n"));
	      goto no_gnu_hash;
	    }

	  if (maxchain + 1 == 0)
	    goto no_gnu_hash;

	  ++maxchain;
	}
      while ((byte_get (nb, 4) & 1) == 0);

      if (fseek (file,
		 (archive_file_offset
		  + offset_from_vma (file, buckets_vma + 4 * ngnubuckets, 4)),
		 SEEK_SET))
	{
	  error (_("Unable to seek to start of dynamic information\n"));
	  goto no_gnu_hash;
	}

      gnuchains = get_dynamic_data (file, maxchain, 4);

    no_gnu_hash:
      if (gnuchains == NULL)
	{
	  free (gnubuckets);
	  gnubuckets = NULL;
	  ngnubuckets = 0;
	  if (do_using_dynamic)
	    return 0;
	}
    }

  if ((dynamic_info[DT_HASH] || dynamic_info_DT_GNU_HASH)
      && do_syms
      && do_using_dynamic
      && dynamic_strings != NULL)
    {
      unsigned long hn;

      if (dynamic_info[DT_HASH])
	{
	  bfd_vma si;

	  printf (_("\nSymbol table for image:\n"));
	  if (is_32bit_elf)
	    printf (_("  Num Buc:    Value  Size   Type   Bind Vis      Ndx Name\n"));
	  else
	    printf (_("  Num Buc:    Value          Size   Type   Bind Vis      Ndx Name\n"));

	  for (hn = 0; hn < nbuckets; hn++)
	    {
	      if (! buckets[hn])
		continue;

	      for (si = buckets[hn]; si < nchains && si > 0; si = chains[si])
		print_dynamic_symbol (si, hn);
	    }
	}

      if (dynamic_info_DT_GNU_HASH)
	{
	  printf (_("\nSymbol table of `.gnu.hash' for image:\n"));
	  if (is_32bit_elf)
	    printf (_("  Num Buc:    Value  Size   Type   Bind Vis      Ndx Name\n"));
	  else
	    printf (_("  Num Buc:    Value          Size   Type   Bind Vis      Ndx Name\n"));

	  for (hn = 0; hn < ngnubuckets; ++hn)
	    if (gnubuckets[hn] != 0)
	      {
		bfd_vma si = gnubuckets[hn];
		bfd_vma off = si - gnusymidx;

		do
		  {
		    print_dynamic_symbol (si, hn);
		    si++;
		  }
		while ((gnuchains[off++] & 1) == 0);
	      }
	}
    }
  else if (do_dyn_syms || (do_syms && !do_using_dynamic))
    {
      unsigned int i;

      for (i = 0, section = section_headers;
	   i < elf_header.e_shnum;
	   i++, section++)
	{
	  unsigned int si;
	  char * strtab = NULL;
	  unsigned long int strtab_size = 0;
	  Elf_Internal_Sym * symtab;
	  Elf_Internal_Sym * psym;
	  unsigned long num_syms;

	  if ((section->sh_type != SHT_SYMTAB
	       && section->sh_type != SHT_DYNSYM)
	      || (!do_syms
		  && section->sh_type == SHT_SYMTAB))
	    continue;

	  if (section->sh_entsize == 0)
	    {
	      printf (_("\nSymbol table '%s' has a sh_entsize of zero!\n"),
		      SECTION_NAME (section));
	      continue;
	    }

	  printf (_("\nSymbol table '%s' contains %lu entries:\n"),
		  SECTION_NAME (section),
		  (unsigned long) (section->sh_size / section->sh_entsize));

	  if (is_32bit_elf)
	    printf (_("   Num:    Value  Size Type    Bind   Vis      Ndx Name\n"));
	  else
	    printf (_("   Num:    Value          Size Type    Bind   Vis      Ndx Name\n"));

	  symtab = GET_ELF_SYMBOLS (file, section, & num_syms);
	  if (symtab == NULL)
	    continue;

	  if (section->sh_link == elf_header.e_shstrndx)
	    {
	      strtab = string_table;
	      strtab_size = string_table_length;
	    }
	  else if (section->sh_link < elf_header.e_shnum)
	    {
	      Elf_Internal_Shdr * string_sec;

	      string_sec = section_headers + section->sh_link;

	      strtab = (char *) get_data (NULL, file, string_sec->sh_offset,
                                          1, string_sec->sh_size,
                                          _("string table"));
	      strtab_size = strtab != NULL ? string_sec->sh_size : 0;
	    }

	  for (si = 0, psym = symtab; si < num_syms; si++, psym++)
	    {
	      printf ("%6d: ", si);
	      print_vma (psym->st_value, LONG_HEX);
	      putchar (' ');
	      print_vma (psym->st_size, DEC_5);
	      printf (" %-7s", get_symbol_type (ELF_ST_TYPE (psym->st_info)));
	      printf (" %-6s", get_symbol_binding (ELF_ST_BIND (psym->st_info)));
	      printf (" %-7s", get_symbol_visibility (ELF_ST_VISIBILITY (psym->st_other)));
	      /* Check to see if any other bits in the st_other field are set.
	         Note - displaying this information disrupts the layout of the
	         table being generated, but for the moment this case is very rare.  */
	      if (psym->st_other ^ ELF_ST_VISIBILITY (psym->st_other))
		printf (" [%s] ", get_symbol_other (psym->st_other ^ ELF_ST_VISIBILITY (psym->st_other)));
	      printf (" %4s ", get_symbol_index_type (psym->st_shndx));
	      print_symbol (25, psym->st_name < strtab_size
			    ? strtab + psym->st_name : _("<corrupt>"));

	      if (section->sh_type == SHT_DYNSYM
		  && version_info[DT_VERSIONTAGIDX (DT_VERSYM)] != 0)
		{
		  unsigned char data[2];
		  unsigned short vers_data;
		  unsigned long offset;
		  int is_nobits;
		  int check_def;

		  offset = offset_from_vma
		    (file, version_info[DT_VERSIONTAGIDX (DT_VERSYM)],
		     sizeof data + si * sizeof (vers_data));

		  if (get_data (&data, file, offset + si * sizeof (vers_data),
				sizeof (data), 1, _("version data")) == NULL)
		    break;

		  vers_data = byte_get (data, 2);

		  is_nobits = (psym->st_shndx < elf_header.e_shnum
			       && section_headers[psym->st_shndx].sh_type
				  == SHT_NOBITS);

		  check_def = (psym->st_shndx != SHN_UNDEF);

		  if ((vers_data & VERSYM_HIDDEN) || vers_data > 1)
		    {
		      if (version_info[DT_VERSIONTAGIDX (DT_VERNEED)]
			  && (is_nobits || ! check_def))
			{
			  Elf_External_Verneed evn;
			  Elf_Internal_Verneed ivn;
			  Elf_Internal_Vernaux ivna;

			  /* We must test both.  */
			  offset = offset_from_vma
			    (file, version_info[DT_VERSIONTAGIDX (DT_VERNEED)],
			     sizeof evn);

			  do
			    {
			      unsigned long vna_off;

			      if (get_data (&evn, file, offset, sizeof (evn), 1,
					    _("version need")) == NULL)
				{
				  ivna.vna_next = 0;
				  ivna.vna_other = 0;
				  ivna.vna_name = 0;
				  break;
				}

			      ivn.vn_aux  = BYTE_GET (evn.vn_aux);
			      ivn.vn_next = BYTE_GET (evn.vn_next);

			      vna_off = offset + ivn.vn_aux;

			      do
				{
				  Elf_External_Vernaux evna;

				  if (get_data (&evna, file, vna_off,
						sizeof (evna), 1,
						_("version need aux (3)")) == NULL)
				    {
				      ivna.vna_next = 0;
				      ivna.vna_other = 0;
				      ivna.vna_name = 0;
				    }
				  else
				    {
				      ivna.vna_other = BYTE_GET (evna.vna_other);
				      ivna.vna_next  = BYTE_GET (evna.vna_next);
				      ivna.vna_name  = BYTE_GET (evna.vna_name);
				    }

				  vna_off += ivna.vna_next;
				}
			      while (ivna.vna_other != vers_data
				     && ivna.vna_next != 0);

			      if (ivna.vna_other == vers_data)
				break;

			      offset += ivn.vn_next;
			    }
			  while (ivn.vn_next != 0);

			  if (ivna.vna_other == vers_data)
			    {
			      printf ("@@%s (%d)",
				      ivna.vna_name < strtab_size
				      ? strtab + ivna.vna_name : _("<corrupt>"),
				      ivna.vna_other);
			      check_def = 0;
			    }
			  else if (! is_nobits)
			    error (_("bad dynamic symbol\n"));
			  else
			    check_def = 1;
			}

		      if (check_def)
			{
			  if (vers_data != 0x8001
			      && version_info[DT_VERSIONTAGIDX (DT_VERDEF)])
			    {
			      Elf_Internal_Verdef ivd;
			      Elf_Internal_Verdaux ivda;
			      Elf_External_Verdaux evda;
			      unsigned long off;

			      off = offset_from_vma
				(file,
				 version_info[DT_VERSIONTAGIDX (DT_VERDEF)],
				 sizeof (Elf_External_Verdef));

			      do
				{
				  Elf_External_Verdef evd;

				  if (get_data (&evd, file, off, sizeof (evd),
						1, _("version def")) == NULL)
				    {
				      ivd.vd_ndx = 0;
				      ivd.vd_aux = 0;
				      ivd.vd_next = 0;
				    }
				  else
				    {
				      ivd.vd_ndx = BYTE_GET (evd.vd_ndx);
				      ivd.vd_aux = BYTE_GET (evd.vd_aux);
				      ivd.vd_next = BYTE_GET (evd.vd_next);
				    }

				  off += ivd.vd_next;
				}
			      while (ivd.vd_ndx != (vers_data & VERSYM_VERSION)
				     && ivd.vd_next != 0);

			      off -= ivd.vd_next;
			      off += ivd.vd_aux;

			      if (get_data (&evda, file, off, sizeof (evda),
					    1, _("version def aux")) == NULL)
				break;

			      ivda.vda_name = BYTE_GET (evda.vda_name);

			      if (psym->st_name != ivda.vda_name)
				printf ((vers_data & VERSYM_HIDDEN)
					? "@@%s" : "@@@@%s",
					ivda.vda_name < strtab_size
					? strtab + ivda.vda_name : _("<corrupt>"));
			    }
			}
		    }
		}

	      putchar ('\n');
	    }

	  free (symtab);
	  if (strtab != string_table)
	    free (strtab);
	}
    }
  else if (do_syms)
    printf
      (_("\nDynamic symbol information is not available for displaying symbols.\n"));

  if (do_histogram && buckets != NULL)
    {
      unsigned long * lengths;
      unsigned long * counts;
      unsigned long hn;
      bfd_vma si;
      unsigned long maxlength = 0;
      unsigned long nzero_counts = 0;
      unsigned long nsyms = 0;

      printf (_("\nHistogram for bucket list length (total of %lu buckets):\n"),
	      (unsigned long) nbuckets);
      printf (_(" Length  Number     %% of total  Coverage\n"));

      lengths = (unsigned long *) calloc (nbuckets, sizeof (*lengths));
      if (lengths == NULL)
	{
	  error (_("Out of memory\n"));
	  return 0;
	}
      for (hn = 0; hn < nbuckets; ++hn)
	{
	  for (si = buckets[hn]; si > 0 && si < nchains; si = chains[si])
	    {
	      ++nsyms;
	      if (maxlength < ++lengths[hn])
		++maxlength;
	    }
	}

      counts = (unsigned long *) calloc (maxlength + 1, sizeof (*counts));
      if (counts == NULL)
	{
	  free (lengths);
	  error (_("Out of memory\n"));
	  return 0;
	}

      for (hn = 0; hn < nbuckets; ++hn)
	++counts[lengths[hn]];

      if (nbuckets > 0)
	{
	  unsigned long i;
	  printf ("      0  %-10lu (%5.1f%%)\n",
		  counts[0], (counts[0] * 100.0) / nbuckets);
	  for (i = 1; i <= maxlength; ++i)
	    {
	      nzero_counts += counts[i] * i;
	      printf ("%7lu  %-10lu (%5.1f%%)    %5.1f%%\n",
		      i, counts[i], (counts[i] * 100.0) / nbuckets,
		      (nzero_counts * 100.0) / nsyms);
	    }
	}

      free (counts);
      free (lengths);
    }

  if (buckets != NULL)
    {
      free (buckets);
      free (chains);
    }

  if (do_histogram && gnubuckets != NULL)
    {
      unsigned long * lengths;
      unsigned long * counts;
      unsigned long hn;
      unsigned long maxlength = 0;
      unsigned long nzero_counts = 0;
      unsigned long nsyms = 0;

      lengths = (unsigned long *) calloc (ngnubuckets, sizeof (*lengths));
      if (lengths == NULL)
	{
	  error (_("Out of memory\n"));
	  return 0;
	}

      printf (_("\nHistogram for `.gnu.hash' bucket list length (total of %lu buckets):\n"),
	      (unsigned long) ngnubuckets);
      printf (_(" Length  Number     %% of total  Coverage\n"));

      for (hn = 0; hn < ngnubuckets; ++hn)
	if (gnubuckets[hn] != 0)
	  {
	    bfd_vma off, length = 1;

	    for (off = gnubuckets[hn] - gnusymidx;
		 (gnuchains[off] & 1) == 0; ++off)
	      ++length;
	    lengths[hn] = length;
	    if (length > maxlength)
	      maxlength = length;
	    nsyms += length;
	  }

      counts = (unsigned long *) calloc (maxlength + 1, sizeof (*counts));
      if (counts == NULL)
	{
	  free (lengths);
	  error (_("Out of memory\n"));
	  return 0;
	}

      for (hn = 0; hn < ngnubuckets; ++hn)
	++counts[lengths[hn]];

      if (ngnubuckets > 0)
	{
	  unsigned long j;
	  printf ("      0  %-10lu (%5.1f%%)\n",
		  counts[0], (counts[0] * 100.0) / ngnubuckets);
	  for (j = 1; j <= maxlength; ++j)
	    {
	      nzero_counts += counts[j] * j;
	      printf ("%7lu  %-10lu (%5.1f%%)    %5.1f%%\n",
		      j, counts[j], (counts[j] * 100.0) / ngnubuckets,
		      (nzero_counts * 100.0) / nsyms);
	    }
	}

      free (counts);
      free (lengths);
      free (gnubuckets);
      free (gnuchains);
    }

  return 1;
}

static int
process_syminfo (FILE * file ATTRIBUTE_UNUSED)
{
  unsigned int i;

  if (dynamic_syminfo == NULL
      || !do_dynamic)
    /* No syminfo, this is ok.  */
    return 1;

  /* There better should be a dynamic symbol section.  */
  if (dynamic_symbols == NULL || dynamic_strings == NULL)
    return 0;

  if (dynamic_addr)
    printf (_("\nDynamic info segment at offset 0x%lx contains %d entries:\n"),
	    dynamic_syminfo_offset, dynamic_syminfo_nent);

  printf (_(" Num: Name                           BoundTo     Flags\n"));
  for (i = 0; i < dynamic_syminfo_nent; ++i)
    {
      unsigned short int flags = dynamic_syminfo[i].si_flags;

      printf ("%4d: ", i);
      if (VALID_DYNAMIC_NAME (dynamic_symbols[i].st_name))
	print_symbol (30, GET_DYNAMIC_NAME (dynamic_symbols[i].st_name));
      else
	printf (_("<corrupt: %19ld>"), dynamic_symbols[i].st_name);
      putchar (' ');

      switch (dynamic_syminfo[i].si_boundto)
	{
	case SYMINFO_BT_SELF:
	  fputs ("SELF       ", stdout);
	  break;
	case SYMINFO_BT_PARENT:
	  fputs ("PARENT     ", stdout);
	  break;
	default:
	  if (dynamic_syminfo[i].si_boundto > 0
	      && dynamic_syminfo[i].si_boundto < dynamic_nent
	      && VALID_DYNAMIC_NAME (dynamic_section[dynamic_syminfo[i].si_boundto].d_un.d_val))
	    {
	      print_symbol (10, GET_DYNAMIC_NAME (dynamic_section[dynamic_syminfo[i].si_boundto].d_un.d_val));
	      putchar (' ' );
	    }
	  else
	    printf ("%-10d ", dynamic_syminfo[i].si_boundto);
	  break;
	}

      if (flags & SYMINFO_FLG_DIRECT)
	printf (" DIRECT");
      if (flags & SYMINFO_FLG_PASSTHRU)
	printf (" PASSTHRU");
      if (flags & SYMINFO_FLG_COPY)
	printf (" COPY");
      if (flags & SYMINFO_FLG_LAZYLOAD)
	printf (" LAZYLOAD");

      puts ("");
    }

  return 1;
}

/* Check to see if the given reloc needs to be handled in a target specific
   manner.  If so then process the reloc and return TRUE otherwise return
   FALSE.  */

static bfd_boolean
target_specific_reloc_handling (Elf_Internal_Rela * reloc,
				unsigned char *     start,
				Elf_Internal_Sym *  symtab)
{
  unsigned int reloc_type = get_reloc_type (reloc->r_info);

  switch (elf_header.e_machine)
    {
    case EM_MSP430:
    case EM_MSP430_OLD:
      {
	static Elf_Internal_Sym * saved_sym = NULL;

	switch (reloc_type)
	  {
	  case 10: /* R_MSP430_SYM_DIFF */
	    if (uses_msp430x_relocs ())
	      break;
	  case 21: /* R_MSP430X_SYM_DIFF */
	    saved_sym = symtab + get_reloc_symindex (reloc->r_info);
	    return TRUE;

	  case 1: /* R_MSP430_32 or R_MSP430_ABS32 */
	  case 3: /* R_MSP430_16 or R_MSP430_ABS8 */
	    goto handle_sym_diff;

	  case 5: /* R_MSP430_16_BYTE */
	  case 9: /* R_MSP430_8 */
	    if (uses_msp430x_relocs ())
	      break;
	    goto handle_sym_diff;

	  case 2: /* R_MSP430_ABS16 */
	  case 15: /* R_MSP430X_ABS16 */
	    if (! uses_msp430x_relocs ())
	      break;
	    goto handle_sym_diff;

	  handle_sym_diff:
	    if (saved_sym != NULL)
	      {
		bfd_vma value;

		value = reloc->r_addend
		  + (symtab[get_reloc_symindex (reloc->r_info)].st_value
		     - saved_sym->st_value);

		byte_put (start + reloc->r_offset, value, reloc_type == 1 ? 4 : 2);

		saved_sym = NULL;
		return TRUE;
	      }
	    break;

	  default:
	    if (saved_sym != NULL)
	      error (_("Unhandled MSP430 reloc type found after SYM_DIFF reloc"));
	    break;
	  }
	break;
      }

    case EM_MN10300:
    case EM_CYGNUS_MN10300:
      {
	static Elf_Internal_Sym * saved_sym = NULL;

	switch (reloc_type)
	  {
	  case 34: /* R_MN10300_ALIGN */
	    return TRUE;
	  case 33: /* R_MN10300_SYM_DIFF */
	    saved_sym = symtab + get_reloc_symindex (reloc->r_info);
	    return TRUE;
	  case 1: /* R_MN10300_32 */
	  case 2: /* R_MN10300_16 */
	    if (saved_sym != NULL)
	      {
		bfd_vma value;

		value = reloc->r_addend
		  + (symtab[get_reloc_symindex (reloc->r_info)].st_value
		     - saved_sym->st_value);

		byte_put (start + reloc->r_offset, value, reloc_type == 1 ? 4 : 2);

		saved_sym = NULL;
		return TRUE;
	      }
	    break;
	  default:
	    if (saved_sym != NULL)
	      error (_("Unhandled MN10300 reloc type found after SYM_DIFF reloc"));
	    break;
	  }
	break;
      }
    }

  return FALSE;
}

/* Returns TRUE iff RELOC_TYPE is a 32-bit absolute RELA relocation used in
   DWARF debug sections.  This is a target specific test.  Note - we do not
   go through the whole including-target-headers-multiple-times route, (as
   we have already done with <elf/h8.h>) because this would become very
   messy and even then this function would have to contain target specific
   information (the names of the relocs instead of their numeric values).
   FIXME: This is not the correct way to solve this problem.  The proper way
   is to have target specific reloc sizing and typing functions created by
   the reloc-macros.h header, in the same way that it already creates the
   reloc naming functions.  */

static bfd_boolean
is_32bit_abs_reloc (unsigned int reloc_type)
{
  switch (elf_header.e_machine)
    {
    case EM_386:
    case EM_486:
      return reloc_type == 1; /* R_386_32.  */
    case EM_68K:
      return reloc_type == 1; /* R_68K_32.  */
    case EM_860:
      return reloc_type == 1; /* R_860_32.  */
    case EM_960:
      return reloc_type == 2; /* R_960_32.  */
    case EM_AARCH64:
      return reloc_type == 258; /* R_AARCH64_ABS32 */
    case EM_ALPHA:
      return reloc_type == 1; /* R_ALPHA_REFLONG.  */
    case EM_ARC:
      return reloc_type == 1; /* R_ARC_32.  */
    case EM_ARM:
      return reloc_type == 2; /* R_ARM_ABS32 */
    case EM_AVR_OLD:
    case EM_AVR:
      return reloc_type == 1;
    case EM_ADAPTEVA_EPIPHANY:
      return reloc_type == 3;
    case EM_BLACKFIN:
      return reloc_type == 0x12; /* R_byte4_data.  */
    case EM_CRIS:
      return reloc_type == 3; /* R_CRIS_32.  */
    case EM_CR16:
      return reloc_type == 3; /* R_CR16_NUM32.  */
    case EM_CRX:
      return reloc_type == 15; /* R_CRX_NUM32.  */
    case EM_CYGNUS_FRV:
      return reloc_type == 1;
    case EM_CYGNUS_D10V:
    case EM_D10V:
      return reloc_type == 6; /* R_D10V_32.  */
    case EM_CYGNUS_D30V:
    case EM_D30V:
      return reloc_type == 12; /* R_D30V_32_NORMAL.  */
    case EM_DLX:
      return reloc_type == 3; /* R_DLX_RELOC_32.  */
    case EM_CYGNUS_FR30:
    case EM_FR30:
      return reloc_type == 3; /* R_FR30_32.  */
    case EM_H8S:
    case EM_H8_300:
    case EM_H8_300H:
      return reloc_type == 1; /* R_H8_DIR32.  */
    case EM_IA_64:
      return reloc_type == 0x65; /* R_IA64_SECREL32LSB.  */
    case EM_IP2K_OLD:
    case EM_IP2K:
      return reloc_type == 2; /* R_IP2K_32.  */
    case EM_IQ2000:
      return reloc_type == 2; /* R_IQ2000_32.  */
    case EM_LATTICEMICO32:
      return reloc_type == 3; /* R_LM32_32.  */
    case EM_M32C_OLD:
    case EM_M32C:
      return reloc_type == 3; /* R_M32C_32.  */
    case EM_M32R:
      return reloc_type == 34; /* R_M32R_32_RELA.  */
    case EM_MCORE:
      return reloc_type == 1; /* R_MCORE_ADDR32.  */
    case EM_CYGNUS_MEP:
      return reloc_type == 4; /* R_MEP_32.  */
    case EM_METAG:
      return reloc_type == 2; /* R_METAG_ADDR32.  */
    case EM_MICROBLAZE:
      return reloc_type == 1; /* R_MICROBLAZE_32.  */
    case EM_MIPS:
      return reloc_type == 2; /* R_MIPS_32.  */
    case EM_MMIX:
      return reloc_type == 4; /* R_MMIX_32.  */
    case EM_CYGNUS_MN10200:
    case EM_MN10200:
      return reloc_type == 1; /* R_MN10200_32.  */
    case EM_CYGNUS_MN10300:
    case EM_MN10300:
      return reloc_type == 1; /* R_MN10300_32.  */
    case EM_MOXIE:
      return reloc_type == 1; /* R_MOXIE_32.  */
    case EM_MSP430_OLD:
    case EM_MSP430:
      return reloc_type == 1; /* R_MSP430_32 or R_MSP320_ABS32.  */
    case EM_MT:
      return reloc_type == 2; /* R_MT_32.  */
    case EM_ALTERA_NIOS2:
      return reloc_type == 12; /* R_NIOS2_BFD_RELOC_32.  */
    case EM_NIOS32:
      return reloc_type == 1; /* R_NIOS_32.  */
    case EM_OPENRISC:
    case EM_OR32:
      return reloc_type == 1; /* R_OR32_32.  */
    case EM_PARISC:
      return (reloc_type == 1 /* R_PARISC_DIR32.  */
	      || reloc_type == 41); /* R_PARISC_SECREL32.  */
    case EM_PJ:
    case EM_PJ_OLD:
      return reloc_type == 1; /* R_PJ_DATA_DIR32.  */
    case EM_PPC64:
      return reloc_type == 1; /* R_PPC64_ADDR32.  */
    case EM_PPC:
      return reloc_type == 1; /* R_PPC_ADDR32.  */
    case EM_RL78:
      return reloc_type == 1; /* R_RL78_DIR32.  */
    case EM_RX:
      return reloc_type == 1; /* R_RX_DIR32.  */
    case EM_S370:
      return reloc_type == 1; /* R_I370_ADDR31.  */
    case EM_S390_OLD:
    case EM_S390:
      return reloc_type == 4; /* R_S390_32.  */
    case EM_SCORE:
      return reloc_type == 8; /* R_SCORE_ABS32.  */
    case EM_SH:
      return reloc_type == 1; /* R_SH_DIR32.  */
    case EM_SPARC32PLUS:
    case EM_SPARCV9:
    case EM_SPARC:
      return reloc_type == 3 /* R_SPARC_32.  */
	|| reloc_type == 23; /* R_SPARC_UA32.  */
    case EM_SPU:
      return reloc_type == 6; /* R_SPU_ADDR32 */
    case EM_TI_C6000:
      return reloc_type == 1; /* R_C6000_ABS32.  */
    case EM_TILEGX:
      return reloc_type == 2; /* R_TILEGX_32.  */
    case EM_TILEPRO:
      return reloc_type == 1; /* R_TILEPRO_32.  */
    case EM_CYGNUS_V850:
    case EM_V850:
      return reloc_type == 6; /* R_V850_ABS32.  */
    case EM_V800:
      return reloc_type == 0x33; /* R_V810_WORD.  */
    case EM_VAX:
      return reloc_type == 1; /* R_VAX_32.  */
    case EM_X86_64:
    case EM_L1OM:
    case EM_K1OM:
      return reloc_type == 10; /* R_X86_64_32.  */
    case EM_XC16X:
    case EM_C166:
      return reloc_type == 3; /* R_XC16C_ABS_32.  */
    case EM_XGATE:
      return reloc_type == 4; /* R_XGATE_32.  */
    case EM_XSTORMY16:
      return reloc_type == 1; /* R_XSTROMY16_32.  */
    case EM_XTENSA_OLD:
    case EM_XTENSA:
      return reloc_type == 1; /* R_XTENSA_32.  */
    default:
      error (_("Missing knowledge of 32-bit reloc types used in DWARF sections of machine number %d\n"),
	     elf_header.e_machine);
      abort ();
    }
}

/* Like is_32bit_abs_reloc except that it returns TRUE iff RELOC_TYPE is
   a 32-bit pc-relative RELA relocation used in DWARF debug sections.  */

static bfd_boolean
is_32bit_pcrel_reloc (unsigned int reloc_type)
{
  switch (elf_header.e_machine)
    {
    case EM_386:
    case EM_486:
      return reloc_type == 2;  /* R_386_PC32.  */
    case EM_68K:
      return reloc_type == 4;  /* R_68K_PC32.  */
    case EM_AARCH64:
      return reloc_type == 261; /* R_AARCH64_PREL32 */
    case EM_ADAPTEVA_EPIPHANY:
      return reloc_type == 6;
    case EM_ALPHA:
      return reloc_type == 10; /* R_ALPHA_SREL32.  */
    case EM_ARM:
      return reloc_type == 3;  /* R_ARM_REL32 */
    case EM_MICROBLAZE:
      return reloc_type == 2;  /* R_MICROBLAZE_32_PCREL.  */
    case EM_PARISC:
      return reloc_type == 9;  /* R_PARISC_PCREL32.  */
    case EM_PPC:
      return reloc_type == 26; /* R_PPC_REL32.  */
    case EM_PPC64:
      return reloc_type == 26; /* R_PPC64_REL32.  */
    case EM_S390_OLD:
    case EM_S390:
      return reloc_type == 5;  /* R_390_PC32.  */
    case EM_SH:
      return reloc_type == 2;  /* R_SH_REL32.  */
    case EM_SPARC32PLUS:
    case EM_SPARCV9:
    case EM_SPARC:
      return reloc_type == 6;  /* R_SPARC_DISP32.  */
    case EM_SPU:
      return reloc_type == 13; /* R_SPU_REL32.  */
    case EM_TILEGX:
      return reloc_type == 6; /* R_TILEGX_32_PCREL.  */
    case EM_TILEPRO:
      return reloc_type == 4; /* R_TILEPRO_32_PCREL.  */
    case EM_X86_64:
    case EM_L1OM:
    case EM_K1OM:
      return reloc_type == 2;  /* R_X86_64_PC32.  */
    case EM_XTENSA_OLD:
    case EM_XTENSA:
      return reloc_type == 14; /* R_XTENSA_32_PCREL.  */
    default:
      /* Do not abort or issue an error message here.  Not all targets use
	 pc-relative 32-bit relocs in their DWARF debug information and we
	 have already tested for target coverage in is_32bit_abs_reloc.  A
	 more helpful warning message will be generated by apply_relocations
	 anyway, so just return.  */
      return FALSE;
    }
}

/* Like is_32bit_abs_reloc except that it returns TRUE iff RELOC_TYPE is
   a 64-bit absolute RELA relocation used in DWARF debug sections.  */

static bfd_boolean
is_64bit_abs_reloc (unsigned int reloc_type)
{
  switch (elf_header.e_machine)
    {
    case EM_AARCH64:
      return reloc_type == 257;	/* R_AARCH64_ABS64.  */
    case EM_ALPHA:
      return reloc_type == 2; /* R_ALPHA_REFQUAD.  */
    case EM_IA_64:
      return reloc_type == 0x27; /* R_IA64_DIR64LSB.  */
    case EM_PARISC:
      return reloc_type == 80; /* R_PARISC_DIR64.  */
    case EM_PPC64:
      return reloc_type == 38; /* R_PPC64_ADDR64.  */
    case EM_SPARC32PLUS:
    case EM_SPARCV9:
    case EM_SPARC:
      return reloc_type == 54; /* R_SPARC_UA64.  */
    case EM_X86_64:
    case EM_L1OM:
    case EM_K1OM:
      return reloc_type == 1; /* R_X86_64_64.  */
    case EM_S390_OLD:
    case EM_S390:
      return reloc_type == 22;	/* R_S390_64.  */
    case EM_TILEGX:
      return reloc_type == 1; /* R_TILEGX_64.  */
    case EM_MIPS:
      return reloc_type == 18;	/* R_MIPS_64.  */
    default:
      return FALSE;
    }
}

/* Like is_32bit_pcrel_reloc except that it returns TRUE iff RELOC_TYPE is
   a 64-bit pc-relative RELA relocation used in DWARF debug sections.  */

static bfd_boolean
is_64bit_pcrel_reloc (unsigned int reloc_type)
{
  switch (elf_header.e_machine)
    {
    case EM_AARCH64:
      return reloc_type == 260;	/* R_AARCH64_PREL64.  */
    case EM_ALPHA:
      return reloc_type == 11; /* R_ALPHA_SREL64.  */
    case EM_IA_64:
      return reloc_type == 0x4f; /* R_IA64_PCREL64LSB.  */
    case EM_PARISC:
      return reloc_type == 72; /* R_PARISC_PCREL64.  */
    case EM_PPC64:
      return reloc_type == 44; /* R_PPC64_REL64.  */
    case EM_SPARC32PLUS:
    case EM_SPARCV9:
    case EM_SPARC:
      return reloc_type == 46; /* R_SPARC_DISP64.  */
    case EM_X86_64:
    case EM_L1OM:
    case EM_K1OM:
      return reloc_type == 24; /* R_X86_64_PC64.  */
    case EM_S390_OLD:
    case EM_S390:
      return reloc_type == 23;	/* R_S390_PC64.  */
    case EM_TILEGX:
      return reloc_type == 5;  /* R_TILEGX_64_PCREL.  */
    default:
      return FALSE;
    }
}

/* Like is_32bit_abs_reloc except that it returns TRUE iff RELOC_TYPE is
   a 24-bit absolute RELA relocation used in DWARF debug sections.  */

static bfd_boolean
is_24bit_abs_reloc (unsigned int reloc_type)
{
  switch (elf_header.e_machine)
    {
    case EM_CYGNUS_MN10200:
    case EM_MN10200:
      return reloc_type == 4; /* R_MN10200_24.  */
    default:
      return FALSE;
    }
}

/* Like is_32bit_abs_reloc except that it returns TRUE iff RELOC_TYPE is
   a 16-bit absolute RELA relocation used in DWARF debug sections.  */

static bfd_boolean
is_16bit_abs_reloc (unsigned int reloc_type)
{
  switch (elf_header.e_machine)
    {
    case EM_AVR_OLD:
    case EM_AVR:
      return reloc_type == 4; /* R_AVR_16.  */
    case EM_ADAPTEVA_EPIPHANY:
      return reloc_type == 5;
    case EM_CYGNUS_D10V:
    case EM_D10V:
      return reloc_type == 3; /* R_D10V_16.  */
    case EM_H8S:
    case EM_H8_300:
    case EM_H8_300H:
      return reloc_type == R_H8_DIR16;
    case EM_IP2K_OLD:
    case EM_IP2K:
      return reloc_type == 1; /* R_IP2K_16.  */
    case EM_M32C_OLD:
    case EM_M32C:
      return reloc_type == 1; /* R_M32C_16 */
    case EM_MSP430:
      if (uses_msp430x_relocs ())
	return reloc_type == 2; /* R_MSP430_ABS16.  */
    case EM_MSP430_OLD:
      return reloc_type == 5; /* R_MSP430_16_BYTE.  */
    case EM_ALTERA_NIOS2:
      return reloc_type == 13; /* R_NIOS2_BFD_RELOC_16.  */
    case EM_NIOS32:
      return reloc_type == 9; /* R_NIOS_16.  */
    case EM_TI_C6000:
      return reloc_type == 2; /* R_C6000_ABS16.  */
    case EM_XC16X:
    case EM_C166:
      return reloc_type == 2; /* R_XC16C_ABS_16.  */
    case EM_CYGNUS_MN10200:
    case EM_MN10200:
      return reloc_type == 2; /* R_MN10200_16.  */
    case EM_CYGNUS_MN10300:
    case EM_MN10300:
      return reloc_type == 2; /* R_MN10300_16.  */
    case EM_XGATE:
      return reloc_type == 3; /* R_XGATE_16.  */
    default:
      return FALSE;
    }
}

/* Returns TRUE iff RELOC_TYPE is a NONE relocation used for discarded
   relocation entries (possibly formerly used for SHT_GROUP sections).  */

static bfd_boolean
is_none_reloc (unsigned int reloc_type)
{
  switch (elf_header.e_machine)
    {
    case EM_68K:     /* R_68K_NONE.  */
    case EM_386:     /* R_386_NONE.  */
    case EM_SPARC32PLUS:
    case EM_SPARCV9:
    case EM_SPARC:   /* R_SPARC_NONE.  */
    case EM_MIPS:    /* R_MIPS_NONE.  */
    case EM_PARISC:  /* R_PARISC_NONE.  */
    case EM_ALPHA:   /* R_ALPHA_NONE.  */
    case EM_ADAPTEVA_EPIPHANY:
    case EM_PPC:     /* R_PPC_NONE.  */
    case EM_PPC64:   /* R_PPC64_NONE.  */
    case EM_ARM:     /* R_ARM_NONE.  */
    case EM_IA_64:   /* R_IA64_NONE.  */
    case EM_SH:      /* R_SH_NONE.  */
    case EM_S390_OLD:
    case EM_S390:    /* R_390_NONE.  */
    case EM_CRIS:    /* R_CRIS_NONE.  */
    case EM_X86_64:  /* R_X86_64_NONE.  */
    case EM_L1OM:    /* R_X86_64_NONE.  */
    case EM_K1OM:    /* R_X86_64_NONE.  */
    case EM_MN10300: /* R_MN10300_NONE.  */
    case EM_MOXIE:   /* R_MOXIE_NONE.  */
    case EM_M32R:    /* R_M32R_NONE.  */
    case EM_TI_C6000:/* R_C6000_NONE.  */
    case EM_TILEGX:  /* R_TILEGX_NONE.  */
    case EM_TILEPRO: /* R_TILEPRO_NONE.  */
    case EM_XC16X:
    case EM_C166:    /* R_XC16X_NONE.  */
    case EM_ALTERA_NIOS2: /* R_NIOS2_NONE.  */
    case EM_NIOS32:  /* R_NIOS_NONE.  */
      return reloc_type == 0;
    case EM_AARCH64:
      return reloc_type == 0 || reloc_type == 256;
    case EM_XTENSA_OLD:
    case EM_XTENSA:
      return (reloc_type == 0      /* R_XTENSA_NONE.  */
	      || reloc_type == 17  /* R_XTENSA_DIFF8.  */
	      || reloc_type == 18  /* R_XTENSA_DIFF16.  */
	      || reloc_type == 19  /* R_XTENSA_DIFF32.  */);
    case EM_METAG:
      return reloc_type == 3; /* R_METAG_NONE.  */
    }
  return FALSE;
}

/* Apply relocations to a section.
   Note: So far support has been added only for those relocations
   which can be found in debug sections.
   FIXME: Add support for more relocations ?  */

static void
apply_relocations (void * file,
		   Elf_Internal_Shdr * section,
		   unsigned char * start)
{
  Elf_Internal_Shdr * relsec;
  unsigned char * end = start + section->sh_size;

  if (elf_header.e_type != ET_REL)
    return;

  /* Find the reloc section associated with the section.  */
  for (relsec = section_headers;
       relsec < section_headers + elf_header.e_shnum;
       ++relsec)
    {
      bfd_boolean is_rela;
      unsigned long num_relocs;
      Elf_Internal_Rela * relocs;
      Elf_Internal_Rela * rp;
      Elf_Internal_Shdr * symsec;
      Elf_Internal_Sym * symtab;
      unsigned long num_syms;
      Elf_Internal_Sym * sym;

      if ((relsec->sh_type != SHT_RELA && relsec->sh_type != SHT_REL)
	  || relsec->sh_info >= elf_header.e_shnum
	  || section_headers + relsec->sh_info != section
	  || relsec->sh_size == 0
	  || relsec->sh_link >= elf_header.e_shnum)
	continue;

      is_rela = relsec->sh_type == SHT_RELA;

      if (is_rela)
	{
	  if (!slurp_rela_relocs ((FILE *) file, relsec->sh_offset,
                                  relsec->sh_size, & relocs, & num_relocs))
	    return;
	}
      else
	{
	  if (!slurp_rel_relocs ((FILE *) file, relsec->sh_offset,
                                 relsec->sh_size, & relocs, & num_relocs))
	    return;
	}

      /* SH uses RELA but uses in place value instead of the addend field.  */
      if (elf_header.e_machine == EM_SH)
	is_rela = FALSE;

      symsec = section_headers + relsec->sh_link;
      symtab = GET_ELF_SYMBOLS ((FILE *) file, symsec, & num_syms);

      for (rp = relocs; rp < relocs + num_relocs; ++rp)
	{
	  bfd_vma         addend;
	  unsigned int    reloc_type;
	  unsigned int    reloc_size;
	  unsigned char * rloc;
	  unsigned long   sym_index;

	  reloc_type = get_reloc_type (rp->r_info);

	  if (target_specific_reloc_handling (rp, start, symtab))
	    continue;
	  else if (is_none_reloc (reloc_type))
	    continue;
	  else if (is_32bit_abs_reloc (reloc_type)
		   || is_32bit_pcrel_reloc (reloc_type))
	    reloc_size = 4;
	  else if (is_64bit_abs_reloc (reloc_type)
		   || is_64bit_pcrel_reloc (reloc_type))
	    reloc_size = 8;
	  else if (is_24bit_abs_reloc (reloc_type))
	    reloc_size = 3;
	  else if (is_16bit_abs_reloc (reloc_type))
	    reloc_size = 2;
	  else
	    {
	      warn (_("unable to apply unsupported reloc type %d to section %s\n"),
		    reloc_type, SECTION_NAME (section));
	      continue;
	    }

	  rloc = start + rp->r_offset;
	  if ((rloc + reloc_size) > end || (rloc < start))
	    {
	      warn (_("skipping invalid relocation offset 0x%lx in section %s\n"),
		    (unsigned long) rp->r_offset,
		    SECTION_NAME (section));
	      continue;
	    }

	  sym_index = (unsigned long) get_reloc_symindex (rp->r_info);
	  if (sym_index >= num_syms)
	    {
	      warn (_("skipping invalid relocation symbol index 0x%lx in section %s\n"),
		    sym_index, SECTION_NAME (section));
	      continue;
	    }
	  sym = symtab + sym_index;

	  /* If the reloc has a symbol associated with it,
	     make sure that it is of an appropriate type.

	     Relocations against symbols without type can happen.
	     Gcc -feliminate-dwarf2-dups may generate symbols
	     without type for debug info.

	     Icc generates relocations against function symbols
	     instead of local labels.

	     Relocations against object symbols can happen, eg when
	     referencing a global array.  For an example of this see
	     the _clz.o binary in libgcc.a.  */
	  if (sym != symtab
	      && ELF_ST_TYPE (sym->st_info) > STT_SECTION)
	    {
	      warn (_("skipping unexpected symbol type %s in %ld'th relocation in section %s\n"),
		    get_symbol_type (ELF_ST_TYPE (sym->st_info)),
		    (long int)(rp - relocs),
		    SECTION_NAME (relsec));
	      continue;
	    }

	  addend = 0;
	  if (is_rela)
	    addend += rp->r_addend;
	  /* R_XTENSA_32, R_PJ_DATA_DIR32 and R_D30V_32_NORMAL are
	     partial_inplace.  */
	  if (!is_rela
	      || (elf_header.e_machine == EM_XTENSA
		  && reloc_type == 1)
	      || ((elf_header.e_machine == EM_PJ
		   || elf_header.e_machine == EM_PJ_OLD)
		  && reloc_type == 1)
	      || ((elf_header.e_machine == EM_D30V
		   || elf_header.e_machine == EM_CYGNUS_D30V)
		  && reloc_type == 12))
	    addend += byte_get (rloc, reloc_size);

	  if (is_32bit_pcrel_reloc (reloc_type)
	      || is_64bit_pcrel_reloc (reloc_type))
	    {
	      /* On HPPA, all pc-relative relocations are biased by 8.  */
	      if (elf_header.e_machine == EM_PARISC)
		addend -= 8;
	      byte_put (rloc, (addend + sym->st_value) - rp->r_offset,
		        reloc_size);
	    }
	  else
	    byte_put (rloc, addend + sym->st_value, reloc_size);
	}

      free (symtab);
      free (relocs);
      break;
    }
}

#ifdef SUPPORT_DISASSEMBLY
static int
disassemble_section (Elf_Internal_Shdr * section, FILE * file)
{
  printf (_("\nAssembly dump of section %s\n"),
	  SECTION_NAME (section));

  /* XXX -- to be done --- XXX */

  return 1;
}
#endif

/* Reads in the contents of SECTION from FILE, returning a pointer
   to a malloc'ed buffer or NULL if something went wrong.  */

static char *
get_section_contents (Elf_Internal_Shdr * section, FILE * file)
{
  bfd_size_type num_bytes;

  num_bytes = section->sh_size;

  if (num_bytes == 0 || section->sh_type == SHT_NOBITS)
    {
      printf (_("\nSection '%s' has no data to dump.\n"),
	      SECTION_NAME (section));
      return NULL;
    }

  return  (char *) get_data (NULL, file, section->sh_offset, 1, num_bytes,
                             _("section contents"));
}


static void
dump_section_as_strings (Elf_Internal_Shdr * section, FILE * file)
{
  Elf_Internal_Shdr * relsec;
  bfd_size_type num_bytes;
  char * data;
  char * end;
  char * start;
  char * name = SECTION_NAME (section);
  bfd_boolean some_strings_shown;

  start = get_section_contents (section, file);
  if (start == NULL)
    return;

  printf (_("\nString dump of section '%s':\n"), name);

  /* If the section being dumped has relocations against it the user might
     be expecting these relocations to have been applied.  Check for this
     case and issue a warning message in order to avoid confusion.
     FIXME: Maybe we ought to have an option that dumps a section with
     relocs applied ?  */
  for (relsec = section_headers;
       relsec < section_headers + elf_header.e_shnum;
       ++relsec)
    {
      if ((relsec->sh_type != SHT_RELA && relsec->sh_type != SHT_REL)
	  || relsec->sh_info >= elf_header.e_shnum
	  || section_headers + relsec->sh_info != section
	  || relsec->sh_size == 0
	  || relsec->sh_link >= elf_header.e_shnum)
	continue;

      printf (_("  Note: This section has relocations against it, but these have NOT been applied to this dump.\n"));
      break;
    }

  num_bytes = section->sh_size;
  data = start;
  end  = start + num_bytes;
  some_strings_shown = FALSE;

  while (data < end)
    {
      while (!ISPRINT (* data))
	if (++ data >= end)
	  break;

      if (data < end)
	{
#ifndef __MSVCRT__
	  /* PR 11128: Use two separate invocations in order to work
             around bugs in the Solaris 8 implementation of printf.  */
	  printf ("  [%6tx]  ", data - start);
	  printf ("%s\n", data);
#else
	  printf ("  [%6Ix]  %s\n", (size_t) (data - start), data);
#endif
	  data += strlen (data);
	  some_strings_shown = TRUE;
	}
    }

  if (! some_strings_shown)
    printf (_("  No strings found in this section."));

  free (start);

  putchar ('\n');
}

static void
dump_section_as_bytes (Elf_Internal_Shdr * section,
		       FILE * file,
		       bfd_boolean relocate)
{
  Elf_Internal_Shdr * relsec;
  bfd_size_type bytes;
  bfd_vma addr;
  unsigned char * data;
  unsigned char * start;

  start = (unsigned char *) get_section_contents (section, file);
  if (start == NULL)
    return;

  printf (_("\nHex dump of section '%s':\n"), SECTION_NAME (section));

  if (relocate)
    {
      apply_relocations (file, section, start);
    }
  else
    {
      /* If the section being dumped has relocations against it the user might
	 be expecting these relocations to have been applied.  Check for this
	 case and issue a warning message in order to avoid confusion.
	 FIXME: Maybe we ought to have an option that dumps a section with
	 relocs applied ?  */
      for (relsec = section_headers;
	   relsec < section_headers + elf_header.e_shnum;
	   ++relsec)
	{
	  if ((relsec->sh_type != SHT_RELA && relsec->sh_type != SHT_REL)
	      || relsec->sh_info >= elf_header.e_shnum
	      || section_headers + relsec->sh_info != section
	      || relsec->sh_size == 0
	      || relsec->sh_link >= elf_header.e_shnum)
	    continue;

	  printf (_(" NOTE: This section has relocations against it, but these have NOT been applied to this dump.\n"));
	  break;
	}
    }

  addr = section->sh_addr;
  bytes = section->sh_size;
  data = start;

  while (bytes)
    {
      int j;
      int k;
      int lbytes;

      lbytes = (bytes > 16 ? 16 : bytes);

      printf ("  0x%8.8lx ", (unsigned long) addr);

      for (j = 0; j < 16; j++)
	{
	  if (j < lbytes)
	    printf ("%2.2x", data[j]);
	  else
	    printf ("  ");

	  if ((j & 3) == 3)
	    printf (" ");
	}

      for (j = 0; j < lbytes; j++)
	{
	  k = data[j];
	  if (k >= ' ' && k < 0x7f)
	    printf ("%c", k);
	  else
	    printf (".");
	}

      putchar ('\n');

      data  += lbytes;
      addr  += lbytes;
      bytes -= lbytes;
    }

  free (start);

  putchar ('\n');
}

/* Uncompresses a section that was compressed using zlib, in place.  */

static int
uncompress_section_contents (unsigned char **buffer ATTRIBUTE_UNUSED,
			     dwarf_size_type *size ATTRIBUTE_UNUSED)
{
#ifndef HAVE_ZLIB_H
  return FALSE;
#else
  dwarf_size_type compressed_size = *size;
  unsigned char * compressed_buffer = *buffer;
  dwarf_size_type uncompressed_size;
  unsigned char * uncompressed_buffer;
  z_stream strm;
  int rc;
  dwarf_size_type header_size = 12;

  /* Read the zlib header.  In this case, it should be "ZLIB" followed
     by the uncompressed section size, 8 bytes in big-endian order.  */
  if (compressed_size < header_size
      || ! streq ((char *) compressed_buffer, "ZLIB"))
    return 0;

  uncompressed_size = compressed_buffer[4]; uncompressed_size <<= 8;
  uncompressed_size += compressed_buffer[5]; uncompressed_size <<= 8;
  uncompressed_size += compressed_buffer[6]; uncompressed_size <<= 8;
  uncompressed_size += compressed_buffer[7]; uncompressed_size <<= 8;
  uncompressed_size += compressed_buffer[8]; uncompressed_size <<= 8;
  uncompressed_size += compressed_buffer[9]; uncompressed_size <<= 8;
  uncompressed_size += compressed_buffer[10]; uncompressed_size <<= 8;
  uncompressed_size += compressed_buffer[11];

  /* It is possible the section consists of several compressed
     buffers concatenated together, so we uncompress in a loop.  */
  strm.zalloc = NULL;
  strm.zfree = NULL;
  strm.opaque = NULL;
  strm.avail_in = compressed_size - header_size;
  strm.next_in = (Bytef *) compressed_buffer + header_size;
  strm.avail_out = uncompressed_size;
  uncompressed_buffer = (unsigned char *) xmalloc (uncompressed_size);

  rc = inflateInit (& strm);
  while (strm.avail_in > 0)
    {
      if (rc != Z_OK)
        goto fail;
      strm.next_out = ((Bytef *) uncompressed_buffer
                       + (uncompressed_size - strm.avail_out));
      rc = inflate (&strm, Z_FINISH);
      if (rc != Z_STREAM_END)
        goto fail;
      rc = inflateReset (& strm);
    }
  rc = inflateEnd (& strm);
  if (rc != Z_OK
      || strm.avail_out != 0)
    goto fail;

  free (compressed_buffer);
  *buffer = uncompressed_buffer;
  *size = uncompressed_size;
  return 1;

 fail:
  free (uncompressed_buffer);
  /* Indicate decompression failure.  */
  *buffer = NULL;
  return 0;
#endif  /* HAVE_ZLIB_H */
}

static int
load_specific_debug_section (enum dwarf_section_display_enum debug,
			     Elf_Internal_Shdr * sec, void * file)
{
  struct dwarf_section * section = &debug_displays [debug].section;
  char buf [64];

  /* If it is already loaded, do nothing.  */
  if (section->start != NULL)
    return 1;

  snprintf (buf, sizeof (buf), _("%s section data"), section->name);
  section->address = sec->sh_addr;
  section->start = (unsigned char *) get_data (NULL, (FILE *) file,
                                               sec->sh_offset, 1,
                                               sec->sh_size, buf);
  if (section->start == NULL)
    section->size = 0;
  else
    {
      section->size = sec->sh_size;
      if (uncompress_section_contents (&section->start, &section->size))
	sec->sh_size = section->size;
    }

  if (section->start == NULL)
    return 0;

  if (debug_displays [debug].relocate)
    apply_relocations ((FILE *) file, sec, section->start);

  return 1;
}

/* If this is not NULL, load_debug_section will only look for sections
   within the list of sections given here.  */
unsigned int *section_subset = NULL;

int
load_debug_section (enum dwarf_section_display_enum debug, void * file)
{
  struct dwarf_section * section = &debug_displays [debug].section;
  Elf_Internal_Shdr * sec;

  /* Locate the debug section.  */
  sec = find_section_in_set (section->uncompressed_name, section_subset);
  if (sec != NULL)
    section->name = section->uncompressed_name;
  else
    {
      sec = find_section_in_set (section->compressed_name, section_subset);
      if (sec != NULL)
	section->name = section->compressed_name;
    }
  if (sec == NULL)
    return 0;

  /* If we're loading from a subset of sections, and we've loaded
     a section matching this name before, it's likely that it's a
     different one.  */
  if (section_subset != NULL)
    free_debug_section (debug);

  return load_specific_debug_section (debug, sec, (FILE *) file);
}

void
free_debug_section (enum dwarf_section_display_enum debug)
{
  struct dwarf_section * section = &debug_displays [debug].section;

  if (section->start == NULL)
    return;

  free ((char *) section->start);
  section->start = NULL;
  section->address = 0;
  section->size = 0;
}

static int
display_debug_section (int shndx, Elf_Internal_Shdr * section, FILE * file)
{
  char * name = SECTION_NAME (section);
  bfd_size_type length;
  int result = 1;
  int i;

  length = section->sh_size;
  if (length == 0)
    {
      printf (_("\nSection '%s' has no debugging data.\n"), name);
      return 0;
    }
  if (section->sh_type == SHT_NOBITS)
    {
      /* There is no point in dumping the contents of a debugging section
	 which has the NOBITS type - the bits in the file will be random.
	 This can happen when a file containing a .eh_frame section is
	 stripped with the --only-keep-debug command line option.  */
      printf (_("section '%s' has the NOBITS type - its contents are unreliable.\n"), name);
      return 0;
    }

  if (const_strneq (name, ".gnu.linkonce.wi."))
    name = ".debug_info";

  /* See if we know how to display the contents of this section.  */
  for (i = 0; i < max; i++)
    if (streq (debug_displays[i].section.uncompressed_name, name)
	|| (i == line && const_strneq (name, ".debug_line."))
        || streq (debug_displays[i].section.compressed_name, name))
      {
	struct dwarf_section * sec = &debug_displays [i].section;
	int secondary = (section != find_section (name));

	if (secondary)
	  free_debug_section ((enum dwarf_section_display_enum) i);

	if (i == line && const_strneq (name, ".debug_line."))
	  sec->name = name;
	else if (streq (sec->uncompressed_name, name))
	  sec->name = sec->uncompressed_name;
	else
	  sec->name = sec->compressed_name;
	if (load_specific_debug_section ((enum dwarf_section_display_enum) i,
                                         section, file))
	  {
	    /* If this debug section is part of a CU/TU set in a .dwp file,
	       restrict load_debug_section to the sections in that set.  */
	    section_subset = find_cu_tu_set (file, shndx);

	    result &= debug_displays[i].display (sec, file);

	    section_subset = NULL;

	    if (secondary || (i != info && i != abbrev))
	      free_debug_section ((enum dwarf_section_display_enum) i);
	  }

	break;
      }

  if (i == max)
    {
      printf (_("Unrecognized debug section: %s\n"), name);
      result = 0;
    }

  return result;
}

/* Set DUMP_SECTS for all sections where dumps were requested
   based on section name.  */

static void
initialise_dumps_byname (void)
{
  struct dump_list_entry * cur;

  for (cur = dump_sects_byname; cur; cur = cur->next)
    {
      unsigned int i;
      int any;

      for (i = 0, any = 0; i < elf_header.e_shnum; i++)
	if (streq (SECTION_NAME (section_headers + i), cur->name))
	  {
	    request_dump_bynumber (i, cur->type);
	    any = 1;
	  }

      if (!any)
	warn (_("Section '%s' was not dumped because it does not exist!\n"),
	      cur->name);
    }
}

static void
process_section_contents (FILE * file)
{
  Elf_Internal_Shdr * section;
  unsigned int i;

  if (! do_dump)
    return;

  initialise_dumps_byname ();

  for (i = 0, section = section_headers;
       i < elf_header.e_shnum && i < num_dump_sects;
       i++, section++)
    {
#ifdef SUPPORT_DISASSEMBLY
      if (dump_sects[i] & DISASS_DUMP)
	disassemble_section (section, file);
#endif
      if (dump_sects[i] & HEX_DUMP)
	dump_section_as_bytes (section, file, FALSE);

      if (dump_sects[i] & RELOC_DUMP)
	dump_section_as_bytes (section, file, TRUE);

      if (dump_sects[i] & STRING_DUMP)
	dump_section_as_strings (section, file);

      if (dump_sects[i] & DEBUG_DUMP)
	display_debug_section (i, section, file);
    }

  /* Check to see if the user requested a
     dump of a section that does not exist.  */
  while (i++ < num_dump_sects)
    if (dump_sects[i])
      warn (_("Section %d was not dumped because it does not exist!\n"), i);
}

static void
process_mips_fpe_exception (int mask)
{
  if (mask)
    {
      int first = 1;
      if (mask & OEX_FPU_INEX)
	fputs ("INEX", stdout), first = 0;
      if (mask & OEX_FPU_UFLO)
	printf ("%sUFLO", first ? "" : "|"), first = 0;
      if (mask & OEX_FPU_OFLO)
	printf ("%sOFLO", first ? "" : "|"), first = 0;
      if (mask & OEX_FPU_DIV0)
	printf ("%sDIV0", first ? "" : "|"), first = 0;
      if (mask & OEX_FPU_INVAL)
	printf ("%sINVAL", first ? "" : "|");
    }
  else
    fputs ("0", stdout);
}

/* Display's the value of TAG at location P.  If TAG is
   greater than 0 it is assumed to be an unknown tag, and
   a message is printed to this effect.  Otherwise it is
   assumed that a message has already been printed.

   If the bottom bit of TAG is set it assumed to have a
   string value, otherwise it is assumed to have an integer
   value.

   Returns an updated P pointing to the first unread byte
   beyond the end of TAG's value.

   Reads at or beyond END will not be made.  */

static unsigned char *
display_tag_value (int tag,
		   unsigned char * p,
		   const unsigned char * const end)
{
  unsigned long val;

  if (tag > 0)
    printf ("  Tag_unknown_%d: ", tag);

  if (p >= end)
    {
      warn (_("corrupt tag\n"));
    }
  else if (tag & 1)
    {
      /* FIXME: we could read beyond END here.  */
      printf ("\"%s\"\n", p);
      p += strlen ((char *) p) + 1;
    }
  else
    {
      unsigned int len;

      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("%ld (0x%lx)\n", val, val);
    }

  return p;
}

/* ARM EABI attributes section.  */
typedef struct
{
  int tag;
  const char * name;
  /* 0 = special, 1 = string, 2 = uleb123, > 0x80 == table lookup.  */
  int type;
  const char ** table;
} arm_attr_public_tag;

static const char * arm_attr_tag_CPU_arch[] =
  {"Pre-v4", "v4", "v4T", "v5T", "v5TE", "v5TEJ", "v6", "v6KZ", "v6T2",
   "v6K", "v7", "v6-M", "v6S-M", "v7E-M", "v8"};
static const char * arm_attr_tag_ARM_ISA_use[] = {"No", "Yes"};
static const char * arm_attr_tag_THUMB_ISA_use[] =
  {"No", "Thumb-1", "Thumb-2"};
static const char * arm_attr_tag_FP_arch[] =
  {"No", "VFPv1", "VFPv2", "VFPv3", "VFPv3-D16", "VFPv4", "VFPv4-D16",
   "FP for ARMv8"};
static const char * arm_attr_tag_WMMX_arch[] = {"No", "WMMXv1", "WMMXv2"};
static const char * arm_attr_tag_Advanced_SIMD_arch[] =
  {"No", "NEONv1", "NEONv1 with Fused-MAC", "NEON for ARMv8"};
static const char * arm_attr_tag_PCS_config[] =
  {"None", "Bare platform", "Linux application", "Linux DSO", "PalmOS 2004",
   "PalmOS (reserved)", "SymbianOS 2004", "SymbianOS (reserved)"};
static const char * arm_attr_tag_ABI_PCS_R9_use[] =
  {"V6", "SB", "TLS", "Unused"};
static const char * arm_attr_tag_ABI_PCS_RW_data[] =
  {"Absolute", "PC-relative", "SB-relative", "None"};
static const char * arm_attr_tag_ABI_PCS_RO_data[] =
  {"Absolute", "PC-relative", "None"};
static const char * arm_attr_tag_ABI_PCS_GOT_use[] =
  {"None", "direct", "GOT-indirect"};
static const char * arm_attr_tag_ABI_PCS_wchar_t[] =
  {"None", "??? 1", "2", "??? 3", "4"};
static const char * arm_attr_tag_ABI_FP_rounding[] = {"Unused", "Needed"};
static const char * arm_attr_tag_ABI_FP_denormal[] =
  {"Unused", "Needed", "Sign only"};
static const char * arm_attr_tag_ABI_FP_exceptions[] = {"Unused", "Needed"};
static const char * arm_attr_tag_ABI_FP_user_exceptions[] = {"Unused", "Needed"};
static const char * arm_attr_tag_ABI_FP_number_model[] =
  {"Unused", "Finite", "RTABI", "IEEE 754"};
static const char * arm_attr_tag_ABI_enum_size[] =
  {"Unused", "small", "int", "forced to int"};
static const char * arm_attr_tag_ABI_HardFP_use[] =
  {"As Tag_FP_arch", "SP only", "DP only", "SP and DP"};
static const char * arm_attr_tag_ABI_VFP_args[] =
  {"AAPCS", "VFP registers", "custom"};
static const char * arm_attr_tag_ABI_WMMX_args[] =
  {"AAPCS", "WMMX registers", "custom"};
static const char * arm_attr_tag_ABI_optimization_goals[] =
  {"None", "Prefer Speed", "Aggressive Speed", "Prefer Size",
    "Aggressive Size", "Prefer Debug", "Aggressive Debug"};
static const char * arm_attr_tag_ABI_FP_optimization_goals[] =
  {"None", "Prefer Speed", "Aggressive Speed", "Prefer Size",
    "Aggressive Size", "Prefer Accuracy", "Aggressive Accuracy"};
static const char * arm_attr_tag_CPU_unaligned_access[] = {"None", "v6"};
static const char * arm_attr_tag_FP_HP_extension[] =
  {"Not Allowed", "Allowed"};
static const char * arm_attr_tag_ABI_FP_16bit_format[] =
  {"None", "IEEE 754", "Alternative Format"};
static const char * arm_attr_tag_MPextension_use[] =
  {"Not Allowed", "Allowed"};
static const char * arm_attr_tag_DIV_use[] =
  {"Allowed in Thumb-ISA, v7-R or v7-M", "Not allowed",
    "Allowed in v7-A with integer division extension"};
static const char * arm_attr_tag_T2EE_use[] = {"Not Allowed", "Allowed"};
static const char * arm_attr_tag_Virtualization_use[] =
  {"Not Allowed", "TrustZone", "Virtualization Extensions",
    "TrustZone and Virtualization Extensions"};
static const char * arm_attr_tag_MPextension_use_legacy[] =
  {"Not Allowed", "Allowed"};

#define LOOKUP(id, name) \
  {id, #name, 0x80 | ARRAY_SIZE(arm_attr_tag_##name), arm_attr_tag_##name}
static arm_attr_public_tag arm_attr_public_tags[] =
{
  {4, "CPU_raw_name", 1, NULL},
  {5, "CPU_name", 1, NULL},
  LOOKUP(6, CPU_arch),
  {7, "CPU_arch_profile", 0, NULL},
  LOOKUP(8, ARM_ISA_use),
  LOOKUP(9, THUMB_ISA_use),
  LOOKUP(10, FP_arch),
  LOOKUP(11, WMMX_arch),
  LOOKUP(12, Advanced_SIMD_arch),
  LOOKUP(13, PCS_config),
  LOOKUP(14, ABI_PCS_R9_use),
  LOOKUP(15, ABI_PCS_RW_data),
  LOOKUP(16, ABI_PCS_RO_data),
  LOOKUP(17, ABI_PCS_GOT_use),
  LOOKUP(18, ABI_PCS_wchar_t),
  LOOKUP(19, ABI_FP_rounding),
  LOOKUP(20, ABI_FP_denormal),
  LOOKUP(21, ABI_FP_exceptions),
  LOOKUP(22, ABI_FP_user_exceptions),
  LOOKUP(23, ABI_FP_number_model),
  {24, "ABI_align_needed", 0, NULL},
  {25, "ABI_align_preserved", 0, NULL},
  LOOKUP(26, ABI_enum_size),
  LOOKUP(27, ABI_HardFP_use),
  LOOKUP(28, ABI_VFP_args),
  LOOKUP(29, ABI_WMMX_args),
  LOOKUP(30, ABI_optimization_goals),
  LOOKUP(31, ABI_FP_optimization_goals),
  {32, "compatibility", 0, NULL},
  LOOKUP(34, CPU_unaligned_access),
  LOOKUP(36, FP_HP_extension),
  LOOKUP(38, ABI_FP_16bit_format),
  LOOKUP(42, MPextension_use),
  LOOKUP(44, DIV_use),
  {64, "nodefaults", 0, NULL},
  {65, "also_compatible_with", 0, NULL},
  LOOKUP(66, T2EE_use),
  {67, "conformance", 1, NULL},
  LOOKUP(68, Virtualization_use),
  LOOKUP(70, MPextension_use_legacy)
};
#undef LOOKUP

static unsigned char *
display_arm_attribute (unsigned char * p,
		       const unsigned char * const end)
{
  int tag;
  unsigned int len;
  int val;
  arm_attr_public_tag * attr;
  unsigned i;
  int type;

  tag = read_uleb128 (p, &len, end);
  p += len;
  attr = NULL;
  for (i = 0; i < ARRAY_SIZE (arm_attr_public_tags); i++)
    {
      if (arm_attr_public_tags[i].tag == tag)
	{
	  attr = &arm_attr_public_tags[i];
	  break;
	}
    }

  if (attr)
    {
      printf ("  Tag_%s: ", attr->name);
      switch (attr->type)
	{
	case 0:
	  switch (tag)
	    {
	    case 7: /* Tag_CPU_arch_profile.  */
	      val = read_uleb128 (p, &len, end);
	      p += len;
	      switch (val)
		{
		case 0: printf (_("None\n")); break;
		case 'A': printf (_("Application\n")); break;
		case 'R': printf (_("Realtime\n")); break;
		case 'M': printf (_("Microcontroller\n")); break;
		case 'S': printf (_("Application or Realtime\n")); break;
		default: printf ("??? (%d)\n", val); break;
		}
	      break;

	    case 24: /* Tag_align_needed.  */
	      val = read_uleb128 (p, &len, end);
	      p += len;
	      switch (val)
		{
		case 0: printf (_("None\n")); break;
		case 1: printf (_("8-byte\n")); break;
		case 2: printf (_("4-byte\n")); break;
		case 3: printf ("??? 3\n"); break;
		default:
		  if (val <= 12)
		    printf (_("8-byte and up to %d-byte extended\n"),
			    1 << val);
		  else
		    printf ("??? (%d)\n", val);
		  break;
		}
	      break;

	    case 25: /* Tag_align_preserved.  */
	      val = read_uleb128 (p, &len, end);
	      p += len;
	      switch (val)
		{
		case 0: printf (_("None\n")); break;
		case 1: printf (_("8-byte, except leaf SP\n")); break;
		case 2: printf (_("8-byte\n")); break;
		case 3: printf ("??? 3\n"); break;
		default:
		  if (val <= 12)
		    printf (_("8-byte and up to %d-byte extended\n"),
			    1 << val);
		  else
		    printf ("??? (%d)\n", val);
		  break;
		}
	      break;

	    case 32: /* Tag_compatibility.  */
	      val = read_uleb128 (p, &len, end);
	      p += len;
	      printf (_("flag = %d, vendor = %s\n"), val, p);
	      p += strlen ((char *) p) + 1;
	      break;

	    case 64: /* Tag_nodefaults.  */
	      p++;
	      printf (_("True\n"));
	      break;

	    case 65: /* Tag_also_compatible_with.  */
	      val = read_uleb128 (p, &len, end);
	      p += len;
	      if (val == 6 /* Tag_CPU_arch.  */)
		{
		  val = read_uleb128 (p, &len, end);
		  p += len;
		  if ((unsigned int)val >= ARRAY_SIZE (arm_attr_tag_CPU_arch))
		    printf ("??? (%d)\n", val);
		  else
		    printf ("%s\n", arm_attr_tag_CPU_arch[val]);
		}
	      else
		printf ("???\n");
	      while (*(p++) != '\0' /* NUL terminator.  */);
	      break;

	    default:
	      abort ();
	    }
	  return p;

	case 1:
	  return display_tag_value (-1, p, end);
	case 2:
	  return display_tag_value (0, p, end);

	default:
	  assert (attr->type & 0x80);
	  val = read_uleb128 (p, &len, end);
	  p += len;
	  type = attr->type & 0x7f;
	  if (val >= type)
	    printf ("??? (%d)\n", val);
	  else
	    printf ("%s\n", attr->table[val]);
	  return p;
	}
    }

  return display_tag_value (tag, p, end);
}

static unsigned char *
display_gnu_attribute (unsigned char * p,
		       unsigned char * (* display_proc_gnu_attribute) (unsigned char *, int, const unsigned char * const),
		       const unsigned char * const end)
{
  int tag;
  unsigned int len;
  int val;

  tag = read_uleb128 (p, &len, end);
  p += len;

  /* Tag_compatibility is the only generic GNU attribute defined at
     present.  */
  if (tag == 32)
    {
      val = read_uleb128 (p, &len, end);
      p += len;
      if (p == end)
	{
	  printf (_("flag = %d, vendor = <corrupt>\n"), val);
	  warn (_("corrupt vendor attribute\n"));
	}
      else
	{
	  printf (_("flag = %d, vendor = %s\n"), val, p);
	  p += strlen ((char *) p) + 1;
	}
      return p;
    }

  if ((tag & 2) == 0 && display_proc_gnu_attribute)
    return display_proc_gnu_attribute (p, tag, end);

  return display_tag_value (tag, p, end);
}

static unsigned char *
display_power_gnu_attribute (unsigned char * p,
			     int tag,
			     const unsigned char * const end)
{
  unsigned int len;
  int val;

  if (tag == Tag_GNU_Power_ABI_FP)
    {
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_GNU_Power_ABI_FP: ");

      switch (val)
	{
	case 0:
	  printf (_("Hard or soft float\n"));
	  break;
	case 1:
	  printf (_("Hard float\n"));
	  break;
	case 2:
	  printf (_("Soft float\n"));
	  break;
	case 3:
	  printf (_("Single-precision hard float\n"));
	  break;
	default:
	  printf ("??? (%d)\n", val);
	  break;
	}
      return p;
   }

  if (tag == Tag_GNU_Power_ABI_Vector)
    {
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_GNU_Power_ABI_Vector: ");
      switch (val)
	{
	case 0:
	  printf (_("Any\n"));
	  break;
	case 1:
	  printf (_("Generic\n"));
	  break;
	case 2:
	  printf ("AltiVec\n");
	  break;
	case 3:
	  printf ("SPE\n");
	  break;
	default:
	  printf ("??? (%d)\n", val);
	  break;
	}
      return p;
   }

  if (tag == Tag_GNU_Power_ABI_Struct_Return)
    {
      if (p == end)
	{
	  warn (_("corrupt Tag_GNU_Power_ABI_Struct_Return"));
	  return p;
	}

      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_GNU_Power_ABI_Struct_Return: ");
      switch (val)
       {
       case 0:
         printf (_("Any\n"));
         break;
       case 1:
         printf ("r3/r4\n");
         break;
       case 2:
         printf (_("Memory\n"));
         break;
       default:
         printf ("??? (%d)\n", val);
         break;
       }
      return p;
    }

  return display_tag_value (tag & 1, p, end);
}

static void
display_sparc_hwcaps (int mask)
{
  if (mask)
    {
      int first = 1;
      if (mask & ELF_SPARC_HWCAP_MUL32)
	fputs ("mul32", stdout), first = 0;
      if (mask & ELF_SPARC_HWCAP_DIV32)
	printf ("%sdiv32", first ? "" : "|"), first = 0;
      if (mask & ELF_SPARC_HWCAP_FSMULD)
	printf ("%sfsmuld", first ? "" : "|"), first = 0;
      if (mask & ELF_SPARC_HWCAP_V8PLUS)
	printf ("%sv8plus", first ? "" : "|"), first = 0;
      if (mask & ELF_SPARC_HWCAP_POPC)
	printf ("%spopc", first ? "" : "|"), first = 0;
      if (mask & ELF_SPARC_HWCAP_VIS)
	printf ("%svis", first ? "" : "|"), first = 0;
      if (mask & ELF_SPARC_HWCAP_VIS2)
	printf ("%svis2", first ? "" : "|"), first = 0;
      if (mask & ELF_SPARC_HWCAP_ASI_BLK_INIT)
	printf ("%sASIBlkInit", first ? "" : "|"), first = 0;
      if (mask & ELF_SPARC_HWCAP_FMAF)
	printf ("%sfmaf", first ? "" : "|"), first = 0;
      if (mask & ELF_SPARC_HWCAP_VIS3)
	printf ("%svis3", first ? "" : "|"), first = 0;
      if (mask & ELF_SPARC_HWCAP_HPC)
	printf ("%shpc", first ? "" : "|"), first = 0;
      if (mask & ELF_SPARC_HWCAP_RANDOM)
	printf ("%srandom", first ? "" : "|"), first = 0;
      if (mask & ELF_SPARC_HWCAP_TRANS)
	printf ("%strans", first ? "" : "|"), first = 0;
      if (mask & ELF_SPARC_HWCAP_FJFMAU)
	printf ("%sfjfmau", first ? "" : "|"), first = 0;
      if (mask & ELF_SPARC_HWCAP_IMA)
	printf ("%sima", first ? "" : "|"), first = 0;
      if (mask & ELF_SPARC_HWCAP_ASI_CACHE_SPARING)
	printf ("%scspare", first ? "" : "|"), first = 0;
    }
  else
    fputc('0', stdout);
  fputc('\n', stdout);
}

static unsigned char *
display_sparc_gnu_attribute (unsigned char * p,
			     int tag,
			     const unsigned char * const end)
{
  if (tag == Tag_GNU_Sparc_HWCAPS)
    {
      unsigned int len;
      int val;

      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_GNU_Sparc_HWCAPS: ");
      display_sparc_hwcaps (val);
      return p;
   }

  return display_tag_value (tag, p, end);
}

static unsigned char *
display_mips_gnu_attribute (unsigned char * p,
			    int tag,
			    const unsigned char * const end)
{
  if (tag == Tag_GNU_MIPS_ABI_FP)
    {
      unsigned int len;
      int val;

      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_GNU_MIPS_ABI_FP: ");

      switch (val)
	{
	case Val_GNU_MIPS_ABI_FP_ANY:
	  printf (_("Hard or soft float\n"));
	  break;
	case Val_GNU_MIPS_ABI_FP_DOUBLE:
	  printf (_("Hard float (double precision)\n"));
	  break;
	case Val_GNU_MIPS_ABI_FP_SINGLE:
	  printf (_("Hard float (single precision)\n"));
	  break;
	case Val_GNU_MIPS_ABI_FP_SOFT:
	  printf (_("Soft float\n"));
	  break;
	case Val_GNU_MIPS_ABI_FP_64:
	  printf (_("Hard float (MIPS32r2 64-bit FPU)\n"));
	  break;
	default:
	  printf ("??? (%d)\n", val);
	  break;
	}
      return p;
   }

  if (tag == Tag_GNU_MIPS_ABI_MSA)
    {
      unsigned int len;
      int val;

      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_GNU_MIPS_ABI_MSA: ");

      switch (val)
	{
	case Val_GNU_MIPS_ABI_MSA_ANY:
	  printf (_("Any MSA or not\n"));
	  break;
	case Val_GNU_MIPS_ABI_MSA_128:
	  printf (_("128-bit MSA\n"));
	  break;
	default:
	  printf ("??? (%d)\n", val);
	  break;
	}
      return p;
    }

  return display_tag_value (tag & 1, p, end);
}

static unsigned char *
display_tic6x_attribute (unsigned char * p,
			 const unsigned char * const end)
{
  int tag;
  unsigned int len;
  int val;

  tag = read_uleb128 (p, &len, end);
  p += len;

  switch (tag)
    {
    case Tag_ISA:
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_ISA: ");

      switch (val)
	{
	case C6XABI_Tag_ISA_none:
	  printf (_("None\n"));
	  break;
	case C6XABI_Tag_ISA_C62X:
	  printf ("C62x\n");
	  break;
	case C6XABI_Tag_ISA_C67X:
	  printf ("C67x\n");
	  break;
	case C6XABI_Tag_ISA_C67XP:
	  printf ("C67x+\n");
	  break;
	case C6XABI_Tag_ISA_C64X:
	  printf ("C64x\n");
	  break;
	case C6XABI_Tag_ISA_C64XP:
	  printf ("C64x+\n");
	  break;
	case C6XABI_Tag_ISA_C674X:
	  printf ("C674x\n");
	  break;
	default:
	  printf ("??? (%d)\n", val);
	  break;
	}
      return p;

    case Tag_ABI_wchar_t:
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_ABI_wchar_t: ");
      switch (val)
	{
	case 0:
	  printf (_("Not used\n"));
	  break;
	case 1:
	  printf (_("2 bytes\n"));
	  break;
	case 2:
	  printf (_("4 bytes\n"));
	  break;
	default:
	  printf ("??? (%d)\n", val);
	  break;
	}
      return p;

    case Tag_ABI_stack_align_needed:
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_ABI_stack_align_needed: ");
      switch (val)
	{
	case 0:
	  printf (_("8-byte\n"));
	  break;
	case 1:
	  printf (_("16-byte\n"));
	  break;
	default:
	  printf ("??? (%d)\n", val);
	  break;
	}
      return p;

    case Tag_ABI_stack_align_preserved:
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_ABI_stack_align_preserved: ");
      switch (val)
	{
	case 0:
	  printf (_("8-byte\n"));
	  break;
	case 1:
	  printf (_("16-byte\n"));
	  break;
	default:
	  printf ("??? (%d)\n", val);
	  break;
	}
      return p;

    case Tag_ABI_DSBT:
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_ABI_DSBT: ");
      switch (val)
	{
	case 0:
	  printf (_("DSBT addressing not used\n"));
	  break;
	case 1:
	  printf (_("DSBT addressing used\n"));
	  break;
	default:
	  printf ("??? (%d)\n", val);
	  break;
	}
      return p;

    case Tag_ABI_PID:
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_ABI_PID: ");
      switch (val)
	{
	case 0:
	  printf (_("Data addressing position-dependent\n"));
	  break;
	case 1:
	  printf (_("Data addressing position-independent, GOT near DP\n"));
	  break;
	case 2:
	  printf (_("Data addressing position-independent, GOT far from DP\n"));
	  break;
	default:
	  printf ("??? (%d)\n", val);
	  break;
	}
      return p;

    case Tag_ABI_PIC:
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_ABI_PIC: ");
      switch (val)
	{
	case 0:
	  printf (_("Code addressing position-dependent\n"));
	  break;
	case 1:
	  printf (_("Code addressing position-independent\n"));
	  break;
	default:
	  printf ("??? (%d)\n", val);
	  break;
	}
      return p;

    case Tag_ABI_array_object_alignment:
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_ABI_array_object_alignment: ");
      switch (val)
	{
	case 0:
	  printf (_("8-byte\n"));
	  break;
	case 1:
	  printf (_("4-byte\n"));
	  break;
	case 2:
	  printf (_("16-byte\n"));
	  break;
	default:
	  printf ("??? (%d)\n", val);
	  break;
	}
      return p;

    case Tag_ABI_array_object_align_expected:
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_ABI_array_object_align_expected: ");
      switch (val)
	{
	case 0:
	  printf (_("8-byte\n"));
	  break;
	case 1:
	  printf (_("4-byte\n"));
	  break;
	case 2:
	  printf (_("16-byte\n"));
	  break;
	default:
	  printf ("??? (%d)\n", val);
	  break;
	}
      return p;

    case Tag_ABI_compatibility:
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_ABI_compatibility: ");
      printf (_("flag = %d, vendor = %s\n"), val, p);
      p += strlen ((char *) p) + 1;
      return p;

    case Tag_ABI_conformance:
      printf ("  Tag_ABI_conformance: ");
      printf ("\"%s\"\n", p);
      p += strlen ((char *) p) + 1;
      return p;
    }

  return display_tag_value (tag, p, end);
}

static void
display_raw_attribute (unsigned char * p, unsigned char * end)
{
  unsigned long addr = 0;
  size_t bytes = end - p;

  while (bytes)
    {
      int j;
      int k;
      int lbytes = (bytes > 16 ? 16 : bytes);

      printf ("  0x%8.8lx ", addr);

      for (j = 0; j < 16; j++)
	{
	  if (j < lbytes)
	    printf ("%2.2x", p[j]);
	  else
	    printf ("  ");

	  if ((j & 3) == 3)
	    printf (" ");
	}

      for (j = 0; j < lbytes; j++)
	{
	  k = p[j];
	  if (k >= ' ' && k < 0x7f)
	    printf ("%c", k);
	  else
	    printf (".");
	}

      putchar ('\n');

      p  += lbytes;
      bytes -= lbytes;
      addr += lbytes;
    }

  putchar ('\n');
}

static unsigned char *
display_msp430x_attribute (unsigned char * p,
			   const unsigned char * const end)
{
  unsigned int len;
  int val;
  int tag;

  tag = read_uleb128 (p, & len, end);
  p += len;

  switch (tag)
    {
    case OFBA_MSPABI_Tag_ISA:
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_ISA: ");
      switch (val)
	{
	case 0: printf (_("None\n")); break;
	case 1: printf (_("MSP430\n")); break;
	case 2: printf (_("MSP430X\n")); break;
	default: printf ("??? (%d)\n", val); break;
	}
      break;

    case OFBA_MSPABI_Tag_Code_Model:
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_Code_Model: ");
      switch (val)
	{
	case 0: printf (_("None\n")); break;
	case 1: printf (_("Small\n")); break;
	case 2: printf (_("Large\n")); break;
	default: printf ("??? (%d)\n", val); break;
	}
      break;

    case OFBA_MSPABI_Tag_Data_Model:
      val = read_uleb128 (p, &len, end);
      p += len;
      printf ("  Tag_Data_Model: ");
      switch (val)
	{
	case 0: printf (_("None\n")); break;
	case 1: printf (_("Small\n")); break;
	case 2: printf (_("Large\n")); break;
	case 3: printf (_("Restricted Large\n")); break;
	default: printf ("??? (%d)\n", val); break;
	}
      break;

    default:
      printf (_("  <unknown tag %d>: "), tag);

      if (tag & 1)
	{
	  printf ("\"%s\"\n", p);
	  p += strlen ((char *) p) + 1;
	}
      else
	{
	  val = read_uleb128 (p, &len, end);
	  p += len;
	  printf ("%d (0x%x)\n", val, val);
	}
      break;
   }

  return p;
}

static int
process_attributes (FILE * file,
		    const char * public_name,
		    unsigned int proc_type,
		    unsigned char * (* display_pub_attribute) (unsigned char *, const unsigned char * const),
		    unsigned char * (* display_proc_gnu_attribute) (unsigned char *, int, const unsigned char * const))
{
  Elf_Internal_Shdr * sect;
  unsigned char * contents;
  unsigned char * p;
  unsigned char * end;
  bfd_vma section_len;
  bfd_vma len;
  unsigned i;

  /* Find the section header so that we get the size.  */
  for (i = 0, sect = section_headers;
       i < elf_header.e_shnum;
       i++, sect++)
    {
      if (sect->sh_type != proc_type && sect->sh_type != SHT_GNU_ATTRIBUTES)
	continue;

      contents = (unsigned char *) get_data (NULL, file, sect->sh_offset, 1,
                                             sect->sh_size, _("attributes"));
      if (contents == NULL)
	continue;

      p = contents;
      if (*p == 'A')
	{
	  len = sect->sh_size - 1;
	  p++;

	  while (len > 0)
	    {
	      int namelen;
	      bfd_boolean public_section;
	      bfd_boolean gnu_section;

	      section_len = byte_get (p, 4);
	      p += 4;

	      if (section_len > len)
		{
		  printf (_("ERROR: Bad section length (%d > %d)\n"),
			  (int) section_len, (int) len);
		  section_len = len;
		}

	      len -= section_len;
	      printf (_("Attribute Section: %s\n"), p);

	      if (public_name && streq ((char *) p, public_name))
		public_section = TRUE;
	      else
		public_section = FALSE;

	      if (streq ((char *) p, "gnu"))
		gnu_section = TRUE;
	      else
		gnu_section = FALSE;

	      namelen = strlen ((char *) p) + 1;
	      p += namelen;
	      section_len -= namelen + 4;

	      while (section_len > 0)
		{
		  int tag = *(p++);
		  int val;
		  bfd_vma size;

		  size = byte_get (p, 4);
		  if (size > section_len)
		    {
		      printf (_("ERROR: Bad subsection length (%d > %d)\n"),
			      (int) size, (int) section_len);
		      size = section_len;
		    }

		  section_len -= size;
		  end = p + size - 1;
		  p += 4;

		  switch (tag)
		    {
		    case 1:
		      printf (_("File Attributes\n"));
		      break;
		    case 2:
		      printf (_("Section Attributes:"));
		      goto do_numlist;
		    case 3:
		      printf (_("Symbol Attributes:"));
		    do_numlist:
		      for (;;)
			{
			  unsigned int j;

			  val = read_uleb128 (p, &j, end);
			  p += j;
			  if (val == 0)
			    break;
			  printf (" %d", val);
			}
		      printf ("\n");
		      break;
		    default:
		      printf (_("Unknown tag: %d\n"), tag);
		      public_section = FALSE;
		      break;
		    }

		  if (public_section)
		    {
		      while (p < end)
			p = display_pub_attribute (p, end);
		    }
		  else if (gnu_section)
		    {
		      while (p < end)
			p = display_gnu_attribute (p,
						   display_proc_gnu_attribute,
						   end);
		    }
		  else
		    {
		      printf (_("  Unknown section contexts\n"));
		      display_raw_attribute (p, end);
		      p = end;
		    }
		}
	    }
	}
      else
	printf (_("Unknown format '%c'\n"), *p);

      free (contents);
    }
  return 1;
}

static int
process_arm_specific (FILE * file)
{
  return process_attributes (file, "aeabi", SHT_ARM_ATTRIBUTES,
			     display_arm_attribute, NULL);
}

static int
process_power_specific (FILE * file)
{
  return process_attributes (file, NULL, SHT_GNU_ATTRIBUTES, NULL,
			     display_power_gnu_attribute);
}

static int
process_sparc_specific (FILE * file)
{
  return process_attributes (file, NULL, SHT_GNU_ATTRIBUTES, NULL,
			     display_sparc_gnu_attribute);
}

static int
process_tic6x_specific (FILE * file)
{
  return process_attributes (file, "c6xabi", SHT_C6000_ATTRIBUTES,
			     display_tic6x_attribute, NULL);
}

static int
process_msp430x_specific (FILE * file)
{
  return process_attributes (file, "mspabi", SHT_MSP430_ATTRIBUTES,
			     display_msp430x_attribute, NULL);
}

/* DATA points to the contents of a MIPS GOT that starts at VMA PLTGOT.
   Print the Address, Access and Initial fields of an entry at VMA ADDR
   and return the VMA of the next entry.  */

static bfd_vma
print_mips_got_entry (unsigned char * data, bfd_vma pltgot, bfd_vma addr)
{
  printf ("  ");
  print_vma (addr, LONG_HEX);
  printf (" ");
  if (addr < pltgot + 0xfff0)
    printf ("%6d(gp)", (int) (addr - pltgot - 0x7ff0));
  else
    printf ("%10s", "");
  printf (" ");
  if (data == NULL)
    printf ("%*s", is_32bit_elf ? 8 : 16, _("<unknown>"));
  else
    {
      bfd_vma entry;

      entry = byte_get (data + addr - pltgot, is_32bit_elf ? 4 : 8);
      print_vma (entry, LONG_HEX);
    }
  return addr + (is_32bit_elf ? 4 : 8);
}

/* DATA points to the contents of a MIPS PLT GOT that starts at VMA
   PLTGOT.  Print the Address and Initial fields of an entry at VMA
   ADDR and return the VMA of the next entry.  */

static bfd_vma
print_mips_pltgot_entry (unsigned char * data, bfd_vma pltgot, bfd_vma addr)
{
  printf ("  ");
  print_vma (addr, LONG_HEX);
  printf (" ");
  if (data == NULL)
    printf ("%*s", is_32bit_elf ? 8 : 16, _("<unknown>"));
  else
    {
      bfd_vma entry;

      entry = byte_get (data + addr - pltgot, is_32bit_elf ? 4 : 8);
      print_vma (entry, LONG_HEX);
    }
  return addr + (is_32bit_elf ? 4 : 8);
}

static int
process_mips_specific (FILE * file)
{
  Elf_Internal_Dyn * entry;
  size_t liblist_offset = 0;
  size_t liblistno = 0;
  size_t conflictsno = 0;
  size_t options_offset = 0;
  size_t conflicts_offset = 0;
  size_t pltrelsz = 0;
  size_t pltrel = 0;
  bfd_vma pltgot = 0;
  bfd_vma mips_pltgot = 0;
  bfd_vma jmprel = 0;
  bfd_vma local_gotno = 0;
  bfd_vma gotsym = 0;
  bfd_vma symtabno = 0;

  process_attributes (file, NULL, SHT_GNU_ATTRIBUTES, NULL,
		      display_mips_gnu_attribute);

  /* We have a lot of special sections.  Thanks SGI!  */
  if (dynamic_section == NULL)
    /* No information available.  */
    return 0;

  for (entry = dynamic_section; entry->d_tag != DT_NULL; ++entry)
    switch (entry->d_tag)
      {
      case DT_MIPS_LIBLIST:
	liblist_offset
	  = offset_from_vma (file, entry->d_un.d_val,
			     liblistno * sizeof (Elf32_External_Lib));
	break;
      case DT_MIPS_LIBLISTNO:
	liblistno = entry->d_un.d_val;
	break;
      case DT_MIPS_OPTIONS:
	options_offset = offset_from_vma (file, entry->d_un.d_val, 0);
	break;
      case DT_MIPS_CONFLICT:
	conflicts_offset
	  = offset_from_vma (file, entry->d_un.d_val,
			     conflictsno * sizeof (Elf32_External_Conflict));
	break;
      case DT_MIPS_CONFLICTNO:
	conflictsno = entry->d_un.d_val;
	break;
      case DT_PLTGOT:
	pltgot = entry->d_un.d_ptr;
	break;
      case DT_MIPS_LOCAL_GOTNO:
	local_gotno = entry->d_un.d_val;
	break;
      case DT_MIPS_GOTSYM:
	gotsym = entry->d_un.d_val;
	break;
      case DT_MIPS_SYMTABNO:
	symtabno = entry->d_un.d_val;
	break;
      case DT_MIPS_PLTGOT:
	mips_pltgot = entry->d_un.d_ptr;
	break;
      case DT_PLTREL:
	pltrel = entry->d_un.d_val;
	break;
      case DT_PLTRELSZ:
	pltrelsz = entry->d_un.d_val;
	break;
      case DT_JMPREL:
	jmprel = entry->d_un.d_ptr;
	break;
      default:
	break;
      }

  if (liblist_offset != 0 && liblistno != 0 && do_dynamic)
    {
      Elf32_External_Lib * elib;
      size_t cnt;

      elib = (Elf32_External_Lib *) get_data (NULL, file, liblist_offset,
                                              liblistno,
                                              sizeof (Elf32_External_Lib),
                                              _("liblist section data"));
      if (elib)
	{
	  printf (_("\nSection '.liblist' contains %lu entries:\n"),
		  (unsigned long) liblistno);
	  fputs (_("     Library              Time Stamp          Checksum   Version Flags\n"),
		 stdout);

	  for (cnt = 0; cnt < liblistno; ++cnt)
	    {
	      Elf32_Lib liblist;
	      time_t atime;
	      char timebuf[20];
	      struct tm * tmp;

	      liblist.l_name = BYTE_GET (elib[cnt].l_name);
	      atime = BYTE_GET (elib[cnt].l_time_stamp);
	      liblist.l_checksum = BYTE_GET (elib[cnt].l_checksum);
	      liblist.l_version = BYTE_GET (elib[cnt].l_version);
	      liblist.l_flags = BYTE_GET (elib[cnt].l_flags);

	      tmp = gmtime (&atime);
	      snprintf (timebuf, sizeof (timebuf),
			"%04u-%02u-%02uT%02u:%02u:%02u",
			tmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,
			tmp->tm_hour, tmp->tm_min, tmp->tm_sec);

	      printf ("%3lu: ", (unsigned long) cnt);
	      if (VALID_DYNAMIC_NAME (liblist.l_name))
		print_symbol (20, GET_DYNAMIC_NAME (liblist.l_name));
	      else
		printf (_("<corrupt: %9ld>"), liblist.l_name);
	      printf (" %s %#10lx %-7ld", timebuf, liblist.l_checksum,
		      liblist.l_version);

	      if (liblist.l_flags == 0)
		puts (_(" NONE"));
	      else
		{
		  static const struct
		  {
		    const char * name;
		    int bit;
		  }
		  l_flags_vals[] =
		  {
		    { " EXACT_MATCH", LL_EXACT_MATCH },
		    { " IGNORE_INT_VER", LL_IGNORE_INT_VER },
		    { " REQUIRE_MINOR", LL_REQUIRE_MINOR },
		    { " EXPORTS", LL_EXPORTS },
		    { " DELAY_LOAD", LL_DELAY_LOAD },
		    { " DELTA", LL_DELTA }
		  };
		  int flags = liblist.l_flags;
		  size_t fcnt;

		  for (fcnt = 0; fcnt < ARRAY_SIZE (l_flags_vals); ++fcnt)
		    if ((flags & l_flags_vals[fcnt].bit) != 0)
		      {
			fputs (l_flags_vals[fcnt].name, stdout);
			flags ^= l_flags_vals[fcnt].bit;
		      }
		  if (flags != 0)
		    printf (" %#x", (unsigned int) flags);

		  puts ("");
		}
	    }

	  free (elib);
	}
    }

  if (options_offset != 0)
    {
      Elf_External_Options * eopt;
      Elf_Internal_Shdr * sect = section_headers;
      Elf_Internal_Options * iopt;
      Elf_Internal_Options * option;
      size_t offset;
      int cnt;

      /* Find the section header so that we get the size.  */
      while (sect->sh_type != SHT_MIPS_OPTIONS)
	++sect;

      eopt = (Elf_External_Options *) get_data (NULL, file, options_offset, 1,
                                                sect->sh_size, _("options"));
      if (eopt)
	{
	  iopt = (Elf_Internal_Options *)
              cmalloc ((sect->sh_size / sizeof (eopt)), sizeof (* iopt));
	  if (iopt == NULL)
	    {
	      error (_("Out of memory\n"));
	      return 0;
	    }

	  offset = cnt = 0;
	  option = iopt;

	  while (offset < sect->sh_size)
	    {
	      Elf_External_Options * eoption;

	      eoption = (Elf_External_Options *) ((char *) eopt + offset);

	      option->kind = BYTE_GET (eoption->kind);
	      option->size = BYTE_GET (eoption->size);
	      option->section = BYTE_GET (eoption->section);
	      option->info = BYTE_GET (eoption->info);

	      offset += option->size;

	      ++option;
	      ++cnt;
	    }

	  printf (_("\nSection '%s' contains %d entries:\n"),
		  SECTION_NAME (sect), cnt);

	  option = iopt;

	  while (cnt-- > 0)
	    {
	      size_t len;

	      switch (option->kind)
		{
		case ODK_NULL:
		  /* This shouldn't happen.  */
		  printf (" NULL       %d %lx", option->section, option->info);
		  break;
		case ODK_REGINFO:
		  printf (" REGINFO    ");
		  if (elf_header.e_machine == EM_MIPS)
		    {
		      /* 32bit form.  */
		      Elf32_External_RegInfo * ereg;
		      Elf32_RegInfo reginfo;

		      ereg = (Elf32_External_RegInfo *) (option + 1);
		      reginfo.ri_gprmask = BYTE_GET (ereg->ri_gprmask);
		      reginfo.ri_cprmask[0] = BYTE_GET (ereg->ri_cprmask[0]);
		      reginfo.ri_cprmask[1] = BYTE_GET (ereg->ri_cprmask[1]);
		      reginfo.ri_cprmask[2] = BYTE_GET (ereg->ri_cprmask[2]);
		      reginfo.ri_cprmask[3] = BYTE_GET (ereg->ri_cprmask[3]);
		      reginfo.ri_gp_value = BYTE_GET (ereg->ri_gp_value);

		      printf ("GPR %08lx  GP 0x%lx\n",
			      reginfo.ri_gprmask,
			      (unsigned long) reginfo.ri_gp_value);
		      printf ("            CPR0 %08lx  CPR1 %08lx  CPR2 %08lx  CPR3 %08lx\n",
			      reginfo.ri_cprmask[0], reginfo.ri_cprmask[1],
			      reginfo.ri_cprmask[2], reginfo.ri_cprmask[3]);
		    }
		  else
		    {
		      /* 64 bit form.  */
		      Elf64_External_RegInfo * ereg;
		      Elf64_Internal_RegInfo reginfo;

		      ereg = (Elf64_External_RegInfo *) (option + 1);
		      reginfo.ri_gprmask    = BYTE_GET (ereg->ri_gprmask);
		      reginfo.ri_cprmask[0] = BYTE_GET (ereg->ri_cprmask[0]);
		      reginfo.ri_cprmask[1] = BYTE_GET (ereg->ri_cprmask[1]);
		      reginfo.ri_cprmask[2] = BYTE_GET (ereg->ri_cprmask[2]);
		      reginfo.ri_cprmask[3] = BYTE_GET (ereg->ri_cprmask[3]);
		      reginfo.ri_gp_value   = BYTE_GET (ereg->ri_gp_value);

		      printf ("GPR %08lx  GP 0x",
			      reginfo.ri_gprmask);
		      printf_vma (reginfo.ri_gp_value);
		      printf ("\n");

		      printf ("            CPR0 %08lx  CPR1 %08lx  CPR2 %08lx  CPR3 %08lx\n",
			      reginfo.ri_cprmask[0], reginfo.ri_cprmask[1],
			      reginfo.ri_cprmask[2], reginfo.ri_cprmask[3]);
		    }
		  ++option;
		  continue;
		case ODK_EXCEPTIONS:
		  fputs (" EXCEPTIONS fpe_min(", stdout);
		  process_mips_fpe_exception (option->info & OEX_FPU_MIN);
		  fputs (") fpe_max(", stdout);
		  process_mips_fpe_exception ((option->info & OEX_FPU_MAX) >> 8);
		  fputs (")", stdout);

		  if (option->info & OEX_PAGE0)
		    fputs (" PAGE0", stdout);
		  if (option->info & OEX_SMM)
		    fputs (" SMM", stdout);
		  if (option->info & OEX_FPDBUG)
		    fputs (" FPDBUG", stdout);
		  if (option->info & OEX_DISMISS)
		    fputs (" DISMISS", stdout);
		  break;
		case ODK_PAD:
		  fputs (" PAD       ", stdout);
		  if (option->info & OPAD_PREFIX)
		    fputs (" PREFIX", stdout);
		  if (option->info & OPAD_POSTFIX)
		    fputs (" POSTFIX", stdout);
		  if (option->info & OPAD_SYMBOL)
		    fputs (" SYMBOL", stdout);
		  break;
		case ODK_HWPATCH:
		  fputs (" HWPATCH   ", stdout);
		  if (option->info & OHW_R4KEOP)
		    fputs (" R4KEOP", stdout);
		  if (option->info & OHW_R8KPFETCH)
		    fputs (" R8KPFETCH", stdout);
		  if (option->info & OHW_R5KEOP)
		    fputs (" R5KEOP", stdout);
		  if (option->info & OHW_R5KCVTL)
		    fputs (" R5KCVTL", stdout);
		  break;
		case ODK_FILL:
		  fputs (" FILL       ", stdout);
		  /* XXX Print content of info word?  */
		  break;
		case ODK_TAGS:
		  fputs (" TAGS       ", stdout);
		  /* XXX Print content of info word?  */
		  break;
		case ODK_HWAND:
		  fputs (" HWAND     ", stdout);
		  if (option->info & OHWA0_R4KEOP_CHECKED)
		    fputs (" R4KEOP_CHECKED", stdout);
		  if (option->info & OHWA0_R4KEOP_CLEAN)
		    fputs (" R4KEOP_CLEAN", stdout);
		  break;
		case ODK_HWOR:
		  fputs (" HWOR      ", stdout);
		  if (option->info & OHWA0_R4KEOP_CHECKED)
		    fputs (" R4KEOP_CHECKED", stdout);
		  if (option->info & OHWA0_R4KEOP_CLEAN)
		    fputs (" R4KEOP_CLEAN", stdout);
		  break;
		case ODK_GP_GROUP:
		  printf (" GP_GROUP  %#06lx  self-contained %#06lx",
			  option->info & OGP_GROUP,
			  (option->info & OGP_SELF) >> 16);
		  break;
		case ODK_IDENT:
		  printf (" IDENT     %#06lx  self-contained %#06lx",
			  option->info & OGP_GROUP,
			  (option->info & OGP_SELF) >> 16);
		  break;
		default:
		  /* This shouldn't happen.  */
		  printf (" %3d ???     %d %lx",
			  option->kind, option->section, option->info);
		  break;
		}

	      len = sizeof (* eopt);
	      while (len < option->size)
		if (((char *) option)[len] >= ' '
		    && ((char *) option)[len] < 0x7f)
		  printf ("%c", ((char *) option)[len++]);
		else
		  printf ("\\%03o", ((char *) option)[len++]);

	      fputs ("\n", stdout);
	      ++option;
	    }

	  free (eopt);
	}
    }

  if (conflicts_offset != 0 && conflictsno != 0)
    {
      Elf32_Conflict * iconf;
      size_t cnt;

      if (dynamic_symbols == NULL)
	{
	  error (_("conflict list found without a dynamic symbol table\n"));
	  return 0;
	}

      iconf = (Elf32_Conflict *) cmalloc (conflictsno, sizeof (* iconf));
      if (iconf == NULL)
	{
	  error (_("Out of memory\n"));
	  return 0;
	}

      if (is_32bit_elf)
	{
	  Elf32_External_Conflict * econf32;

	  econf32 = (Elf32_External_Conflict *)
              get_data (NULL, file, conflicts_offset, conflictsno,
                        sizeof (* econf32), _("conflict"));
	  if (!econf32)
	    return 0;

	  for (cnt = 0; cnt < conflictsno; ++cnt)
	    iconf[cnt] = BYTE_GET (econf32[cnt]);

	  free (econf32);
	}
      else
	{
	  Elf64_External_Conflict * econf64;

	  econf64 = (Elf64_External_Conflict *)
              get_data (NULL, file, conflicts_offset, conflictsno,
                        sizeof (* econf64), _("conflict"));
	  if (!econf64)
	    return 0;

	  for (cnt = 0; cnt < conflictsno; ++cnt)
	    iconf[cnt] = BYTE_GET (econf64[cnt]);

	  free (econf64);
	}

      printf (_("\nSection '.conflict' contains %lu entries:\n"),
	      (unsigned long) conflictsno);
      puts (_("  Num:    Index       Value  Name"));

      for (cnt = 0; cnt < conflictsno; ++cnt)
	{
	  Elf_Internal_Sym * psym = & dynamic_symbols[iconf[cnt]];

	  printf ("%5lu: %8lu  ", (unsigned long) cnt, iconf[cnt]);
	  print_vma (psym->st_value, FULL_HEX);
	  putchar (' ');
	  if (VALID_DYNAMIC_NAME (psym->st_name))
	    print_symbol (25, GET_DYNAMIC_NAME (psym->st_name));
	  else
	    printf (_("<corrupt: %14ld>"), psym->st_name);
	  putchar ('\n');
	}

      free (iconf);
    }

  if (pltgot != 0 && local_gotno != 0)
    {
      bfd_vma ent, local_end, global_end;
      size_t i, offset;
      unsigned char * data;
      int addr_size;

      ent = pltgot;
      addr_size = (is_32bit_elf ? 4 : 8);
      local_end = pltgot + local_gotno * addr_size;
      global_end = local_end + (symtabno - gotsym) * addr_size;

      offset = offset_from_vma (file, pltgot, global_end - pltgot);
      data = (unsigned char *) get_data (NULL, file, offset,
                                         global_end - pltgot, 1,
					 _("Global Offset Table data"));
      if (data == NULL)
	return 0;

      printf (_("\nPrimary GOT:\n"));
      printf (_(" Canonical gp value: "));
      print_vma (pltgot + 0x7ff0, LONG_HEX);
      printf ("\n\n");

      printf (_(" Reserved entries:\n"));
      printf (_("  %*s %10s %*s Purpose\n"),
	      addr_size * 2, _("Address"), _("Access"),
	      addr_size * 2, _("Initial"));
      ent = print_mips_got_entry (data, pltgot, ent);
      printf (_(" Lazy resolver\n"));
      if (data
	  && (byte_get (data + ent - pltgot, addr_size)
	      >> (addr_size * 8 - 1)) != 0)
	{
	  ent = print_mips_got_entry (data, pltgot, ent);
	  printf (_(" Module pointer (GNU extension)\n"));
	}
      printf ("\n");

      if (ent < local_end)
	{
	  printf (_(" Local entries:\n"));
	  printf ("  %*s %10s %*s\n",
		  addr_size * 2, _("Address"), _("Access"),
		  addr_size * 2, _("Initial"));
	  while (ent < local_end)
	    {
	      ent = print_mips_got_entry (data, pltgot, ent);
	      printf ("\n");
	    }
	  printf ("\n");
	}

      if (gotsym < symtabno)
	{
	  int sym_width;

	  printf (_(" Global entries:\n"));
	  printf ("  %*s %10s %*s %*s %-7s %3s %s\n",
		  addr_size * 2, _("Address"),
		  _("Access"),
		  addr_size * 2, _("Initial"),
		  addr_size * 2, _("Sym.Val."),
		  _("Type"),
		  /* Note for translators: "Ndx" = abbreviated form of "Index".  */
		  _("Ndx"), _("Name"));

	  sym_width = (is_32bit_elf ? 80 : 160) - 28 - addr_size * 6 - 1;
	  for (i = gotsym; i < symtabno; i++)
	    {
	      Elf_Internal_Sym * psym;

	      psym = dynamic_symbols + i;
	      ent = print_mips_got_entry (data, pltgot, ent);
	      printf (" ");
	      print_vma (psym->st_value, LONG_HEX);
	      printf (" %-7s %3s ",
		      get_symbol_type (ELF_ST_TYPE (psym->st_info)),
		      get_symbol_index_type (psym->st_shndx));
	      if (VALID_DYNAMIC_NAME (psym->st_name))
		print_symbol (sym_width, GET_DYNAMIC_NAME (psym->st_name));
	      else
		printf (_("<corrupt: %14ld>"), psym->st_name);
	      printf ("\n");
	    }
	  printf ("\n");
	}

      if (data)
	free (data);
    }

  if (mips_pltgot != 0 && jmprel != 0 && pltrel != 0 && pltrelsz != 0)
    {
      bfd_vma ent, end;
      size_t offset, rel_offset;
      unsigned long count, i;
      unsigned char * data;
      int addr_size, sym_width;
      Elf_Internal_Rela * rels;

      rel_offset = offset_from_vma (file, jmprel, pltrelsz);
      if (pltrel == DT_RELA)
	{
	  if (!slurp_rela_relocs (file, rel_offset, pltrelsz, &rels, &count))
	    return 0;
	}
      else
	{
	  if (!slurp_rel_relocs (file, rel_offset, pltrelsz, &rels, &count))
	    return 0;
	}

      ent = mips_pltgot;
      addr_size = (is_32bit_elf ? 4 : 8);
      end = mips_pltgot + (2 + count) * addr_size;

      offset = offset_from_vma (file, mips_pltgot, end - mips_pltgot);
      data = (unsigned char *) get_data (NULL, file, offset, end - mips_pltgot,
                                         1, _("Procedure Linkage Table data"));
      if (data == NULL)
	return 0;

      printf ("\nPLT GOT:\n\n");
      printf (_(" Reserved entries:\n"));
      printf (_("  %*s %*s Purpose\n"),
	      addr_size * 2, _("Address"), addr_size * 2, _("Initial"));
      ent = print_mips_pltgot_entry (data, mips_pltgot, ent);
      printf (_(" PLT lazy resolver\n"));
      ent = print_mips_pltgot_entry (data, mips_pltgot, ent);
      printf (_(" Module pointer\n"));
      printf ("\n");

      printf (_(" Entries:\n"));
      printf ("  %*s %*s %*s %-7s %3s %s\n",
	      addr_size * 2, _("Address"),
	      addr_size * 2, _("Initial"),
	      addr_size * 2, _("Sym.Val."), _("Type"), _("Ndx"), _("Name"));
      sym_width = (is_32bit_elf ? 80 : 160) - 17 - addr_size * 6 - 1;
      for (i = 0; i < count; i++)
	{
	  Elf_Internal_Sym * psym;

	  psym = dynamic_symbols + get_reloc_symindex (rels[i].r_info);
	  ent = print_mips_pltgot_entry (data, mips_pltgot, ent);
	  printf (" ");
	  print_vma (psym->st_value, LONG_HEX);
	  printf (" %-7s %3s ",
		  get_symbol_type (ELF_ST_TYPE (psym->st_info)),
		  get_symbol_index_type (psym->st_shndx));
	  if (VALID_DYNAMIC_NAME (psym->st_name))
	    print_symbol (sym_width, GET_DYNAMIC_NAME (psym->st_name));
	  else
	    printf (_("<corrupt: %14ld>"), psym->st_name);
	  printf ("\n");
	}
      printf ("\n");

      if (data)
	free (data);
      free (rels);
    }

  return 1;
}

static int
process_gnu_liblist (FILE * file)
{
  Elf_Internal_Shdr * section;
  Elf_Internal_Shdr * string_sec;
  Elf32_External_Lib * elib;
  char * strtab;
  size_t strtab_size;
  size_t cnt;
  unsigned i;

  if (! do_arch)
    return 0;

  for (i = 0, section = section_headers;
       i < elf_header.e_shnum;
       i++, section++)
    {
      switch (section->sh_type)
	{
	case SHT_GNU_LIBLIST:
	  if (section->sh_link >= elf_header.e_shnum)
	    break;

	  elib = (Elf32_External_Lib *)
              get_data (NULL, file, section->sh_offset, 1, section->sh_size,
                        _("liblist section data"));

	  if (elib == NULL)
	    break;
	  string_sec = section_headers + section->sh_link;

	  strtab = (char *) get_data (NULL, file, string_sec->sh_offset, 1,
                                      string_sec->sh_size,
                                      _("liblist string table"));
	  if (strtab == NULL
	      || section->sh_entsize != sizeof (Elf32_External_Lib))
	    {
	      free (elib);
	      free (strtab);
	      break;
	    }
	  strtab_size = string_sec->sh_size;

	  printf (_("\nLibrary list section '%s' contains %lu entries:\n"),
		  SECTION_NAME (section),
		  (unsigned long) (section->sh_size / sizeof (Elf32_External_Lib)));

	  puts (_("     Library              Time Stamp          Checksum   Version Flags"));

	  for (cnt = 0; cnt < section->sh_size / sizeof (Elf32_External_Lib);
	       ++cnt)
	    {
	      Elf32_Lib liblist;
	      time_t atime;
	      char timebuf[20];
	      struct tm * tmp;

	      liblist.l_name = BYTE_GET (elib[cnt].l_name);
	      atime = BYTE_GET (elib[cnt].l_time_stamp);
	      liblist.l_checksum = BYTE_GET (elib[cnt].l_checksum);
	      liblist.l_version = BYTE_GET (elib[cnt].l_version);
	      liblist.l_flags = BYTE_GET (elib[cnt].l_flags);

	      tmp = gmtime (&atime);
	      snprintf (timebuf, sizeof (timebuf),
			"%04u-%02u-%02uT%02u:%02u:%02u",
			tmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,
			tmp->tm_hour, tmp->tm_min, tmp->tm_sec);

	      printf ("%3lu: ", (unsigned long) cnt);
	      if (do_wide)
		printf ("%-20s", liblist.l_name < strtab_size
			? strtab + liblist.l_name : _("<corrupt>"));
	      else
		printf ("%-20.20s", liblist.l_name < strtab_size
			? strtab + liblist.l_name : _("<corrupt>"));
	      printf (" %s %#010lx %-7ld %-7ld\n", timebuf, liblist.l_checksum,
		      liblist.l_version, liblist.l_flags);
	    }

	  free (elib);
	  free (strtab);
	}
    }

  return 1;
}

static const char *
get_note_type (unsigned e_type)
{
  static char buff[64];

  if (elf_header.e_type == ET_CORE)
    switch (e_type)
      {
      case NT_AUXV:
	return _("NT_AUXV (auxiliary vector)");
      case NT_PRSTATUS:
	return _("NT_PRSTATUS (prstatus structure)");
      case NT_FPREGSET:
	return _("NT_FPREGSET (floating point registers)");
      case NT_PRPSINFO:
	return _("NT_PRPSINFO (prpsinfo structure)");
      case NT_TASKSTRUCT:
	return _("NT_TASKSTRUCT (task structure)");
      case NT_PRXFPREG:
	return _("NT_PRXFPREG (user_xfpregs structure)");
      case NT_PPC_VMX:
	return _("NT_PPC_VMX (ppc Altivec registers)");
      case NT_PPC_VSX:
	return _("NT_PPC_VSX (ppc VSX registers)");
      case NT_386_TLS:
	return _("NT_386_TLS (x86 TLS information)");
      case NT_386_IOPERM:
	return _("NT_386_IOPERM (x86 I/O permissions)");
      case NT_X86_XSTATE:
	return _("NT_X86_XSTATE (x86 XSAVE extended state)");
      case NT_S390_HIGH_GPRS:
	return _("NT_S390_HIGH_GPRS (s390 upper register halves)");
      case NT_S390_TIMER:
	return _("NT_S390_TIMER (s390 timer register)");
      case NT_S390_TODCMP:
	return _("NT_S390_TODCMP (s390 TOD comparator register)");
      case NT_S390_TODPREG:
	return _("NT_S390_TODPREG (s390 TOD programmable register)");
      case NT_S390_CTRS:
	return _("NT_S390_CTRS (s390 control registers)");
      case NT_S390_PREFIX:
	return _("NT_S390_PREFIX (s390 prefix register)");
      case NT_S390_LAST_BREAK:
	return _("NT_S390_LAST_BREAK (s390 last breaking event address)");
      case NT_S390_SYSTEM_CALL:
	return _("NT_S390_SYSTEM_CALL (s390 system call restart data)");
      case NT_S390_TDB:
	return _("NT_S390_TDB (s390 transaction diagnostic block)");
      case NT_ARM_VFP:
	return _("NT_ARM_VFP (arm VFP registers)");
      case NT_ARM_TLS:
	return _("NT_ARM_TLS (AArch TLS registers)");
      case NT_ARM_HW_BREAK:
	return _("NT_ARM_HW_BREAK (AArch hardware breakpoint registers)");
      case NT_ARM_HW_WATCH:
	return _("NT_ARM_HW_WATCH (AArch hardware watchpoint registers)");
      case NT_PSTATUS:
	return _("NT_PSTATUS (pstatus structure)");
      case NT_FPREGS:
	return _("NT_FPREGS (floating point registers)");
      case NT_PSINFO:
	return _("NT_PSINFO (psinfo structure)");
      case NT_LWPSTATUS:
	return _("NT_LWPSTATUS (lwpstatus_t structure)");
      case NT_LWPSINFO:
	return _("NT_LWPSINFO (lwpsinfo_t structure)");
      case NT_WIN32PSTATUS:
	return _("NT_WIN32PSTATUS (win32_pstatus structure)");
      case NT_SIGINFO:
	return _("NT_SIGINFO (siginfo_t data)");
      case NT_FILE:
	return _("NT_FILE (mapped files)");
      default:
	break;
      }
  else
    switch (e_type)
      {
      case NT_VERSION:
	return _("NT_VERSION (version)");
      case NT_ARCH:
	return _("NT_ARCH (architecture)");
      default:
	break;
      }

  snprintf (buff, sizeof (buff), _("Unknown note type: (0x%08x)"), e_type);
  return buff;
}

static int
print_core_note (Elf_Internal_Note *pnote)
{
  unsigned int addr_size = is_32bit_elf ? 4 : 8;
  bfd_vma count, page_size;
  unsigned char *descdata, *filenames, *descend;

  if (pnote->type != NT_FILE)
    return 1;

#ifndef BFD64
  if (!is_32bit_elf)
    {
      printf (_("    Cannot decode 64-bit note in 32-bit build\n"));
      /* Still "successful".  */
      return 1;
    }
#endif

  if (pnote->descsz < 2 * addr_size)
    {
      printf (_("    Malformed note - too short for header\n"));
      return 0;
    }

  descdata = (unsigned char *) pnote->descdata;
  descend = descdata + pnote->descsz;

  if (descdata[pnote->descsz - 1] != '\0')
    {
      printf (_("    Malformed note - does not end with \\0\n"));
      return 0;
    }

  count = byte_get (descdata, addr_size);
  descdata += addr_size;

  page_size = byte_get (descdata, addr_size);
  descdata += addr_size;

  if (pnote->descsz < 2 * addr_size + count * 3 * addr_size)
    {
      printf (_("    Malformed note - too short for supplied file count\n"));
      return 0;
    }

  printf (_("    Page size: "));
  print_vma (page_size, DEC);
  printf ("\n");

  printf (_("    %*s%*s%*s\n"),
	  (int) (2 + 2 * addr_size), _("Start"),
	  (int) (4 + 2 * addr_size), _("End"),
	  (int) (4 + 2 * addr_size), _("Page Offset"));
  filenames = descdata + count * 3 * addr_size;
  while (--count > 0)
    {
      bfd_vma start, end, file_ofs;

      if (filenames == descend)
	{
	  printf (_("    Malformed note - filenames end too early\n"));
	  return 0;
	}

      start = byte_get (descdata, addr_size);
      descdata += addr_size;
      end = byte_get (descdata, addr_size);
      descdata += addr_size;
      file_ofs = byte_get (descdata, addr_size);
      descdata += addr_size;

      printf ("    ");
      print_vma (start, FULL_HEX);
      printf ("  ");
      print_vma (end, FULL_HEX);
      printf ("  ");
      print_vma (file_ofs, FULL_HEX);
      printf ("\n        %s\n", filenames);

      filenames += 1 + strlen ((char *) filenames);
    }

  return 1;
}

static const char *
get_gnu_elf_note_type (unsigned e_type)
{
  static char buff[64];

  switch (e_type)
    {
    case NT_GNU_ABI_TAG:
      return _("NT_GNU_ABI_TAG (ABI version tag)");
    case NT_GNU_HWCAP:
      return _("NT_GNU_HWCAP (DSO-supplied software HWCAP info)");
    case NT_GNU_BUILD_ID:
      return _("NT_GNU_BUILD_ID (unique build ID bitstring)");
    case NT_GNU_GOLD_VERSION:
      return _("NT_GNU_GOLD_VERSION (gold version)");
    default:
      break;
    }

  snprintf (buff, sizeof (buff), _("Unknown note type: (0x%08x)"), e_type);
  return buff;
}

static int
print_gnu_note (Elf_Internal_Note *pnote)
{
  switch (pnote->type)
    {
    case NT_GNU_BUILD_ID:
      {
	unsigned long i;

	printf (_("    Build ID: "));
	for (i = 0; i < pnote->descsz; ++i)
	  printf ("%02x", pnote->descdata[i] & 0xff);
	printf ("\n");
      }
      break;

    case NT_GNU_ABI_TAG:
      {
	unsigned long os, major, minor, subminor;
	const char *osname;

	os = byte_get ((unsigned char *) pnote->descdata, 4);
	major = byte_get ((unsigned char *) pnote->descdata + 4, 4);
	minor = byte_get ((unsigned char *) pnote->descdata + 8, 4);
	subminor = byte_get ((unsigned char *) pnote->descdata + 12, 4);

	switch (os)
	  {
	  case GNU_ABI_TAG_LINUX:
	    osname = "Linux";
	    break;
	  case GNU_ABI_TAG_HURD:
	    osname = "Hurd";
	    break;
	  case GNU_ABI_TAG_SOLARIS:
	    osname = "Solaris";
	    break;
	  case GNU_ABI_TAG_FREEBSD:
	    osname = "FreeBSD";
	    break;
	  case GNU_ABI_TAG_NETBSD:
	    osname = "NetBSD";
	    break;
	  default:
	    osname = "Unknown";
	    break;
	  }

	printf (_("    OS: %s, ABI: %ld.%ld.%ld\n"), osname,
		major, minor, subminor);
      }
      break;
    }

  return 1;
}

static const char *
get_netbsd_elfcore_note_type (unsigned e_type)
{
  static char buff[64];

  if (e_type == NT_NETBSDCORE_PROCINFO)
    {
      /* NetBSD core "procinfo" structure.  */
      return _("NetBSD procinfo structure");
    }

  /* As of Jan 2002 there are no other machine-independent notes
     defined for NetBSD core files.  If the note type is less
     than the start of the machine-dependent note types, we don't
     understand it.  */

  if (e_type < NT_NETBSDCORE_FIRSTMACH)
    {
      snprintf (buff, sizeof (buff), _("Unknown note type: (0x%08x)"), e_type);
      return buff;
    }

  switch (elf_header.e_machine)
    {
    /* On the Alpha, SPARC (32-bit and 64-bit), PT_GETREGS == mach+0
       and PT_GETFPREGS == mach+2.  */

    case EM_OLD_ALPHA:
    case EM_ALPHA:
    case EM_SPARC:
    case EM_SPARC32PLUS:
    case EM_SPARCV9:
      switch (e_type)
	{
	case NT_NETBSDCORE_FIRSTMACH + 0:
	  return _("PT_GETREGS (reg structure)");
	case NT_NETBSDCORE_FIRSTMACH + 2:
	  return _("PT_GETFPREGS (fpreg structure)");
	default:
	  break;
	}
      break;

    /* On all other arch's, PT_GETREGS == mach+1 and
       PT_GETFPREGS == mach+3.  */
    default:
      switch (e_type)
	{
	case NT_NETBSDCORE_FIRSTMACH + 1:
	  return _("PT_GETREGS (reg structure)");
	case NT_NETBSDCORE_FIRSTMACH + 3:
	  return _("PT_GETFPREGS (fpreg structure)");
	default:
	  break;
	}
    }

  snprintf (buff, sizeof (buff), "PT_FIRSTMACH+%d",
	    e_type - NT_NETBSDCORE_FIRSTMACH);
  return buff;
}

static const char *
get_stapsdt_note_type (unsigned e_type)
{
  static char buff[64];

  switch (e_type)
    {
    case NT_STAPSDT:
      return _("NT_STAPSDT (SystemTap probe descriptors)");

    default:
      break;
    }

  snprintf (buff, sizeof (buff), _("Unknown note type: (0x%08x)"), e_type);
  return buff;
}

static int
print_stapsdt_note (Elf_Internal_Note *pnote)
{
  int addr_size = is_32bit_elf ? 4 : 8;
  char *data = pnote->descdata;
  char *data_end = pnote->descdata + pnote->descsz;
  bfd_vma pc, base_addr, semaphore;
  char *provider, *probe, *arg_fmt;

  pc = byte_get ((unsigned char *) data, addr_size);
  data += addr_size;
  base_addr = byte_get ((unsigned char *) data, addr_size);
  data += addr_size;
  semaphore = byte_get ((unsigned char *) data, addr_size);
  data += addr_size;

  provider = data;
  data += strlen (data) + 1;
  probe = data;
  data += strlen (data) + 1;
  arg_fmt = data;
  data += strlen (data) + 1;

  printf (_("    Provider: %s\n"), provider);
  printf (_("    Name: %s\n"), probe);
  printf (_("    Location: "));
  print_vma (pc, FULL_HEX);
  printf (_(", Base: "));
  print_vma (base_addr, FULL_HEX);
  printf (_(", Semaphore: "));
  print_vma (semaphore, FULL_HEX);
  printf ("\n");
  printf (_("    Arguments: %s\n"), arg_fmt);

  return data == data_end;
}

static const char *
get_ia64_vms_note_type (unsigned e_type)
{
  static char buff[64];

  switch (e_type)
    {
    case NT_VMS_MHD:
      return _("NT_VMS_MHD (module header)");
    case NT_VMS_LNM:
      return _("NT_VMS_LNM (language name)");
    case NT_VMS_SRC:
      return _("NT_VMS_SRC (source files)");
    case NT_VMS_TITLE:
      return "NT_VMS_TITLE";
    case NT_VMS_EIDC:
      return _("NT_VMS_EIDC (consistency check)");
    case NT_VMS_FPMODE:
      return _("NT_VMS_FPMODE (FP mode)");
    case NT_VMS_LINKTIME:
      return "NT_VMS_LINKTIME";
    case NT_VMS_IMGNAM:
      return _("NT_VMS_IMGNAM (image name)");
    case NT_VMS_IMGID:
      return _("NT_VMS_IMGID (image id)");
    case NT_VMS_LINKID:
      return _("NT_VMS_LINKID (link id)");
    case NT_VMS_IMGBID:
      return _("NT_VMS_IMGBID (build id)");
    case NT_VMS_GSTNAM:
      return _("NT_VMS_GSTNAM (sym table name)");
    case NT_VMS_ORIG_DYN:
      return "NT_VMS_ORIG_DYN";
    case NT_VMS_PATCHTIME:
      return "NT_VMS_PATCHTIME";
    default:
      snprintf (buff, sizeof (buff), _("Unknown note type: (0x%08x)"), e_type);
      return buff;
    }
}

static int
print_ia64_vms_note (Elf_Internal_Note * pnote)
{
  switch (pnote->type)
    {
    case NT_VMS_MHD:
      if (pnote->descsz > 36)
        {
          size_t l = strlen (pnote->descdata + 34);
          printf (_("    Creation date  : %.17s\n"), pnote->descdata);
          printf (_("    Last patch date: %.17s\n"), pnote->descdata + 17);
          printf (_("    Module name    : %s\n"), pnote->descdata + 34);
          printf (_("    Module version : %s\n"), pnote->descdata + 34 + l + 1);
        }
      else
        printf (_("    Invalid size\n"));
      break;
    case NT_VMS_LNM:
      printf (_("   Language: %s\n"), pnote->descdata);
      break;
#ifdef BFD64
    case NT_VMS_FPMODE:
      printf (_("   Floating Point mode: "));
      printf ("0x%016" BFD_VMA_FMT "x\n",
              (bfd_vma)byte_get ((unsigned char *)pnote->descdata, 8));
      break;
    case NT_VMS_LINKTIME:
      printf (_("   Link time: "));
      print_vms_time
        ((bfd_int64_t) byte_get ((unsigned char *)pnote->descdata, 8));
      printf ("\n");
      break;
    case NT_VMS_PATCHTIME:
      printf (_("   Patch time: "));
      print_vms_time
        ((bfd_int64_t) byte_get ((unsigned char *)pnote->descdata, 8));
      printf ("\n");
      break;
    case NT_VMS_ORIG_DYN:
      printf (_("   Major id: %u,  minor id: %u\n"),
              (unsigned) byte_get ((unsigned char *)pnote->descdata, 4),
              (unsigned) byte_get ((unsigned char *)pnote->descdata + 4, 4));
      printf (_("   Last modified  : "));
      print_vms_time
        ((bfd_int64_t) byte_get ((unsigned char *)pnote->descdata + 8, 8));
      printf (_("\n   Link flags  : "));
      printf ("0x%016" BFD_VMA_FMT "x\n",
              (bfd_vma)byte_get ((unsigned char *)pnote->descdata + 16, 8));
      printf (_("   Header flags: 0x%08x\n"),
              (unsigned)byte_get ((unsigned char *)pnote->descdata + 24, 4));
      printf (_("   Image id    : %s\n"), pnote->descdata + 32);
      break;
#endif
    case NT_VMS_IMGNAM:
      printf (_("    Image name: %s\n"), pnote->descdata);
      break;
    case NT_VMS_GSTNAM:
      printf (_("    Global symbol table name: %s\n"), pnote->descdata);
      break;
    case NT_VMS_IMGID:
      printf (_("    Image id: %s\n"), pnote->descdata);
      break;
    case NT_VMS_LINKID:
      printf (_("    Linker id: %s\n"), pnote->descdata);
      break;
    default:
      break;
    }
  return 1;
}

/* Note that by the ELF standard, the name field is already null byte
   terminated, and namesz includes the terminating null byte.
   I.E. the value of namesz for the name "FSF" is 4.

   If the value of namesz is zero, there is no name present.  */
static int
process_note (Elf_Internal_Note * pnote)
{
  const char * name = pnote->namesz ? pnote->namedata : "(NONE)";
  const char * nt;

  if (pnote->namesz == 0)
    /* If there is no note name, then use the default set of
       note type strings.  */
    nt = get_note_type (pnote->type);

  else if (const_strneq (pnote->namedata, "GNU"))
    /* GNU-specific object file notes.  */
    nt = get_gnu_elf_note_type (pnote->type);

  else if (const_strneq (pnote->namedata, "NetBSD-CORE"))
    /* NetBSD-specific core file notes.  */
    nt = get_netbsd_elfcore_note_type (pnote->type);

  else if (strneq (pnote->namedata, "SPU/", 4))
    {
      /* SPU-specific core file notes.  */
      nt = pnote->namedata + 4;
      name = "SPU";
    }

  else if (const_strneq (pnote->namedata, "IPF/VMS"))
    /* VMS/ia64-specific file notes.  */
    nt = get_ia64_vms_note_type (pnote->type);

  else if (const_strneq (pnote->namedata, "stapsdt"))
    nt = get_stapsdt_note_type (pnote->type);

  else
    /* Don't recognize this note name; just use the default set of
       note type strings.  */
    nt = get_note_type (pnote->type);

  printf ("  %-20s 0x%08lx\t%s\n", name, pnote->descsz, nt);

  if (const_strneq (pnote->namedata, "IPF/VMS"))
    return print_ia64_vms_note (pnote);
  else if (const_strneq (pnote->namedata, "GNU"))
    return print_gnu_note (pnote);
  else if (const_strneq (pnote->namedata, "stapsdt"))
    return print_stapsdt_note (pnote);
  else if (const_strneq (pnote->namedata, "CORE"))
    return print_core_note (pnote);
  else
    return 1;
}


static int
process_corefile_note_segment (FILE * file, bfd_vma offset, bfd_vma length)
{
  Elf_External_Note * pnotes;
  Elf_External_Note * external;
  int res = 1;

  if (length <= 0)
    return 0;

  pnotes = (Elf_External_Note *) get_data (NULL, file, offset, 1, length,
					   _("notes"));
  if (pnotes == NULL)
    return 0;

  external = pnotes;

  printf (_("\nDisplaying notes found at file offset 0x%08lx with length 0x%08lx:\n"),
	  (unsigned long) offset, (unsigned long) length);
  printf (_("  %-20s %10s\tDescription\n"), _("Owner"), _("Data size"));

  while ((char *) external < (char *) pnotes + length)
    {
      Elf_Internal_Note inote;
      size_t min_notesz;
      char *next;
      char * temp = NULL;
      size_t data_remaining = ((char *) pnotes + length) - (char *) external;

      if (!is_ia64_vms ())
	{
	  /* PR binutils/15191
	     Make sure that there is enough data to read.  */
	  min_notesz = offsetof (Elf_External_Note, name);
	  if (data_remaining < min_notesz)
	    {
	      warn (_("Corrupt note: only %d bytes remain, not enough for a full note\n"),
		    (int) data_remaining);
	      break;
	    }
	  inote.type     = BYTE_GET (external->type);
	  inote.namesz   = BYTE_GET (external->namesz);
	  inote.namedata = external->name;
	  inote.descsz   = BYTE_GET (external->descsz);
	  inote.descdata = inote.namedata + align_power (inote.namesz, 2);
	  inote.descpos  = offset + (inote.descdata - (char *) pnotes);
	  next = inote.descdata + align_power (inote.descsz, 2);
	}
      else
	{
	  Elf64_External_VMS_Note *vms_external;

	  /* PR binutils/15191
	     Make sure that there is enough data to read.  */
	  min_notesz = offsetof (Elf64_External_VMS_Note, name);
	  if (data_remaining < min_notesz)
	    {
	      warn (_("Corrupt note: only %d bytes remain, not enough for a full note\n"),
		    (int) data_remaining);
	      break;
	    }

	  vms_external = (Elf64_External_VMS_Note *) external;
	  inote.type     = BYTE_GET (vms_external->type);
	  inote.namesz   = BYTE_GET (vms_external->namesz);
	  inote.namedata = vms_external->name;
	  inote.descsz   = BYTE_GET (vms_external->descsz);
	  inote.descdata = inote.namedata + align_power (inote.namesz, 3);
	  inote.descpos  = offset + (inote.descdata - (char *) pnotes);
	  next = inote.descdata + align_power (inote.descsz, 3);
	}

      if (inote.descdata < (char *) external + min_notesz
	  || next < (char *) external + min_notesz
	  || data_remaining < (size_t)(next - (char *) external))
	{
	  warn (_("note with invalid namesz and/or descsz found at offset 0x%lx\n"),
		(unsigned long) ((char *) external - (char *) pnotes));
	  warn (_(" type: 0x%lx, namesize: 0x%08lx, descsize: 0x%08lx\n"),
		inote.type, inote.namesz, inote.descsz);
	  break;
	}

      external = (Elf_External_Note *) next;

      /* Verify that name is null terminated.  It appears that at least
	 one version of Linux (RedHat 6.0) generates corefiles that don't
	 comply with the ELF spec by failing to include the null byte in
	 namesz.  */
      if (inote.namedata[inote.namesz - 1] != '\0')
	{
	  temp = (char *) malloc (inote.namesz + 1);

	  if (temp == NULL)
	    {
	      error (_("Out of memory\n"));
	      res = 0;
	      break;
	    }

	  strncpy (temp, inote.namedata, inote.namesz);
	  temp[inote.namesz] = 0;

	  /* warn (_("'%s' NOTE name not properly null terminated\n"), temp);  */
	  inote.namedata = temp;
	}

      res &= process_note (& inote);

      if (temp != NULL)
	{
	  free (temp);
	  temp = NULL;
	}
    }

  free (pnotes);

  return res;
}

static int
process_corefile_note_segments (FILE * file)
{
  Elf_Internal_Phdr * segment;
  unsigned int i;
  int res = 1;

  if (! get_program_headers (file))
      return 0;

  for (i = 0, segment = program_headers;
       i < elf_header.e_phnum;
       i++, segment++)
    {
      if (segment->p_type == PT_NOTE)
	res &= process_corefile_note_segment (file,
					      (bfd_vma) segment->p_offset,
					      (bfd_vma) segment->p_filesz);
    }

  return res;
}

static int
process_note_sections (FILE * file)
{
  Elf_Internal_Shdr * section;
  unsigned long i;
  int res = 1;

  for (i = 0, section = section_headers;
       i < elf_header.e_shnum && section != NULL;
       i++, section++)
    if (section->sh_type == SHT_NOTE)
      res &= process_corefile_note_segment (file,
					    (bfd_vma) section->sh_offset,
					    (bfd_vma) section->sh_size);

  return res;
}

static int
process_notes (FILE * file)
{
  /* If we have not been asked to display the notes then do nothing.  */
  if (! do_notes)
    return 1;

  if (elf_header.e_type != ET_CORE)
    return process_note_sections (file);

  /* No program headers means no NOTE segment.  */
  if (elf_header.e_phnum > 0)
    return process_corefile_note_segments (file);

  printf (_("No note segments present in the core file.\n"));
  return 1;
}

static int
process_arch_specific (FILE * file)
{
  if (! do_arch)
    return 1;

  switch (elf_header.e_machine)
    {
    case EM_ARM:
      return process_arm_specific (file);
    case EM_MIPS:
    case EM_MIPS_RS3_LE:
      return process_mips_specific (file);
      break;
    case EM_PPC:
      return process_power_specific (file);
      break;
    case EM_SPARC:
    case EM_SPARC32PLUS:
    case EM_SPARCV9:
      return process_sparc_specific (file);
      break;
    case EM_TI_C6000:
      return process_tic6x_specific (file);
      break;
    case EM_MSP430:
      return process_msp430x_specific (file);
    default:
      break;
    }
  return 1;
}

static int
get_file_header (FILE * file)
{
  /* Read in the identity array.  */
  if (fread (elf_header.e_ident, EI_NIDENT, 1, file) != 1)
    return 0;

  /* Determine how to read the rest of the header.  */
  switch (elf_header.e_ident[EI_DATA])
    {
    default: /* fall through */
    case ELFDATANONE: /* fall through */
    case ELFDATA2LSB:
      byte_get = byte_get_little_endian;
      byte_put = byte_put_little_endian;
      break;
    case ELFDATA2MSB:
      byte_get = byte_get_big_endian;
      byte_put = byte_put_big_endian;
      break;
    }

  /* For now we only support 32 bit and 64 bit ELF files.  */
  is_32bit_elf = (elf_header.e_ident[EI_CLASS] != ELFCLASS64);

  /* Read in the rest of the header.  */
  if (is_32bit_elf)
    {
      Elf32_External_Ehdr ehdr32;

      if (fread (ehdr32.e_type, sizeof (ehdr32) - EI_NIDENT, 1, file) != 1)
	return 0;

      elf_header.e_type      = BYTE_GET (ehdr32.e_type);
      elf_header.e_machine   = BYTE_GET (ehdr32.e_machine);
      elf_header.e_version   = BYTE_GET (ehdr32.e_version);
      elf_header.e_entry     = BYTE_GET (ehdr32.e_entry);
      elf_header.e_phoff     = BYTE_GET (ehdr32.e_phoff);
      elf_header.e_shoff     = BYTE_GET (ehdr32.e_shoff);
      elf_header.e_flags     = BYTE_GET (ehdr32.e_flags);
      elf_header.e_ehsize    = BYTE_GET (ehdr32.e_ehsize);
      elf_header.e_phentsize = BYTE_GET (ehdr32.e_phentsize);
      elf_header.e_phnum     = BYTE_GET (ehdr32.e_phnum);
      elf_header.e_shentsize = BYTE_GET (ehdr32.e_shentsize);
      elf_header.e_shnum     = BYTE_GET (ehdr32.e_shnum);
      elf_header.e_shstrndx  = BYTE_GET (ehdr32.e_shstrndx);
    }
  else
    {
      Elf64_External_Ehdr ehdr64;

      /* If we have been compiled with sizeof (bfd_vma) == 4, then
	 we will not be able to cope with the 64bit data found in
	 64 ELF files.  Detect this now and abort before we start
	 overwriting things.  */
      if (sizeof (bfd_vma) < 8)
	{
	  error (_("This instance of readelf has been built without support for a\n\
64 bit data type and so it cannot read 64 bit ELF files.\n"));
	  return 0;
	}

      if (fread (ehdr64.e_type, sizeof (ehdr64) - EI_NIDENT, 1, file) != 1)
	return 0;

      elf_header.e_type      = BYTE_GET (ehdr64.e_type);
      elf_header.e_machine   = BYTE_GET (ehdr64.e_machine);
      elf_header.e_version   = BYTE_GET (ehdr64.e_version);
      elf_header.e_entry     = BYTE_GET (ehdr64.e_entry);
      elf_header.e_phoff     = BYTE_GET (ehdr64.e_phoff);
      elf_header.e_shoff     = BYTE_GET (ehdr64.e_shoff);
      elf_header.e_flags     = BYTE_GET (ehdr64.e_flags);
      elf_header.e_ehsize    = BYTE_GET (ehdr64.e_ehsize);
      elf_header.e_phentsize = BYTE_GET (ehdr64.e_phentsize);
      elf_header.e_phnum     = BYTE_GET (ehdr64.e_phnum);
      elf_header.e_shentsize = BYTE_GET (ehdr64.e_shentsize);
      elf_header.e_shnum     = BYTE_GET (ehdr64.e_shnum);
      elf_header.e_shstrndx  = BYTE_GET (ehdr64.e_shstrndx);
    }

  if (elf_header.e_shoff)
    {
      /* There may be some extensions in the first section header.  Don't
	 bomb if we can't read it.  */
      if (is_32bit_elf)
	get_32bit_section_headers (file, 1);
      else
	get_64bit_section_headers (file, 1);
    }

  return 1;
}

/* Process one ELF object file according to the command line options.
   This file may actually be stored in an archive.  The file is
   positioned at the start of the ELF object.  */

static int
process_object (char * file_name, FILE * file)
{
  unsigned int i;

  if (! get_file_header (file))
    {
      error (_("%s: Failed to read file header\n"), file_name);
      return 1;
    }

  /* Initialise per file variables.  */
  for (i = ARRAY_SIZE (version_info); i--;)
    version_info[i] = 0;

  for (i = ARRAY_SIZE (dynamic_info); i--;)
    dynamic_info[i] = 0;
  dynamic_info_DT_GNU_HASH = 0;

  /* Process the file.  */
  if (show_name)
    printf (_("\nFile: %s\n"), file_name);

  /* Initialise the dump_sects array from the cmdline_dump_sects array.
     Note we do this even if cmdline_dump_sects is empty because we
     must make sure that the dump_sets array is zeroed out before each
     object file is processed.  */
  if (num_dump_sects > num_cmdline_dump_sects)
    memset (dump_sects, 0, num_dump_sects * sizeof (* dump_sects));

  if (num_cmdline_dump_sects > 0)
    {
      if (num_dump_sects == 0)
	/* A sneaky way of allocating the dump_sects array.  */
	request_dump_bynumber (num_cmdline_dump_sects, 0);

      assert (num_dump_sects >= num_cmdline_dump_sects);
      memcpy (dump_sects, cmdline_dump_sects,
	      num_cmdline_dump_sects * sizeof (* dump_sects));
    }

  if (! process_file_header ())
    return 1;

  if (! process_section_headers (file))
    {
      /* Without loaded section headers we cannot process lots of
	 things.  */
      do_unwind = do_version = do_dump = do_arch = 0;

      if (! do_using_dynamic)
	do_syms = do_dyn_syms = do_reloc = 0;
    }

  if (! process_section_groups (file))
    {
      /* Without loaded section groups we cannot process unwind.  */
      do_unwind = 0;
    }

  if (process_program_headers (file))
    process_dynamic_section (file);

  process_relocs (file);

  process_unwind (file);

  process_symbol_table (file);

  process_syminfo (file);

  process_version_sections (file);

  process_section_contents (file);

  process_notes (file);

  process_gnu_liblist (file);

  process_arch_specific (file);

  if (program_headers)
    {
      free (program_headers);
      program_headers = NULL;
    }

  if (section_headers)
    {
      free (section_headers);
      section_headers = NULL;
    }

  if (string_table)
    {
      free (string_table);
      string_table = NULL;
      string_table_length = 0;
    }

  if (dynamic_strings)
    {
      free (dynamic_strings);
      dynamic_strings = NULL;
      dynamic_strings_length = 0;
    }

  if (dynamic_symbols)
    {
      free (dynamic_symbols);
      dynamic_symbols = NULL;
      num_dynamic_syms = 0;
    }

  if (dynamic_syminfo)
    {
      free (dynamic_syminfo);
      dynamic_syminfo = NULL;
    }

  if (dynamic_section)
    {
      free (dynamic_section);
      dynamic_section = NULL;
    }

  if (section_headers_groups)
    {
      free (section_headers_groups);
      section_headers_groups = NULL;
    }

  if (section_groups)
    {
      struct group_list * g;
      struct group_list * next;

      for (i = 0; i < group_count; i++)
	{
	  for (g = section_groups [i].root; g != NULL; g = next)
	    {
	      next = g->next;
	      free (g);
	    }
	}

      free (section_groups);
      section_groups = NULL;
    }

  free_debug_memory ();

  return 0;
}

/* Process an ELF archive.
   On entry the file is positioned just after the ARMAG string.  */

static int
process_archive (char * file_name, FILE * file, bfd_boolean is_thin_archive)
{
  struct archive_info arch;
  struct archive_info nested_arch;
  size_t got;
  int ret;

  show_name = 1;

  /* The ARCH structure is used to hold information about this archive.  */
  arch.file_name = NULL;
  arch.file = NULL;
  arch.index_array = NULL;
  arch.sym_table = NULL;
  arch.longnames = NULL;

  /* The NESTED_ARCH structure is used as a single-item cache of information
     about a nested archive (when members of a thin archive reside within
     another regular archive file).  */
  nested_arch.file_name = NULL;
  nested_arch.file = NULL;
  nested_arch.index_array = NULL;
  nested_arch.sym_table = NULL;
  nested_arch.longnames = NULL;

  if (setup_archive (&arch, file_name, file, is_thin_archive, do_archive_index) != 0)
    {
      ret = 1;
      goto out;
    }

  if (do_archive_index)
    {
      if (arch.sym_table == NULL)
	error (_("%s: unable to dump the index as none was found\n"), file_name);
      else
	{
	  unsigned int i, l;
	  unsigned long current_pos;

	  printf (_("Index of archive %s: (%ld entries, 0x%lx bytes in the symbol table)\n"),
		  file_name, (long) arch.index_num, arch.sym_size);
	  current_pos = ftell (file);

	  for (i = l = 0; i < arch.index_num; i++)
	    {
	      if ((i == 0) || ((i > 0) && (arch.index_array[i] != arch.index_array[i - 1])))
	        {
	          char * member_name;

		  member_name = get_archive_member_name_at (&arch, arch.index_array[i], &nested_arch);

                  if (member_name != NULL)
                    {
	              char * qualified_name = make_qualified_name (&arch, &nested_arch, member_name);

                      if (qualified_name != NULL)
                        {
		          printf (_("Contents of binary %s at offset "), qualified_name);
			  (void) print_vma (arch.index_array[i], PREFIX_HEX);
			  putchar ('\n');
		          free (qualified_name);
		        }
		    }
		}

	      if (l >= arch.sym_size)
		{
		  error (_("%s: end of the symbol table reached before the end of the index\n"),
			 file_name);
		  break;
		}
	      printf ("\t%s\n", arch.sym_table + l);
	      l += strlen (arch.sym_table + l) + 1;
	    }

	  if (arch.uses_64bit_indicies)
	    l = (l + 7) & ~ 7;
	  else
	    l += l & 1;

	  if (l < arch.sym_size)
	    error (_("%s: %ld bytes remain in the symbol table, but without corresponding entries in the index table\n"),
		   file_name, arch.sym_size - l);

	  if (fseek (file, current_pos, SEEK_SET) != 0)
	    {
	      error (_("%s: failed to seek back to start of object files in the archive\n"), file_name);
	      ret = 1;
	      goto out;
	    }
	}

      if (!do_dynamic && !do_syms && !do_reloc && !do_unwind && !do_sections
	  && !do_segments && !do_header && !do_dump && !do_version
	  && !do_histogram && !do_debugging && !do_arch && !do_notes
	  && !do_section_groups && !do_dyn_syms)
	{
	  ret = 0; /* Archive index only.  */
	  goto out;
	}
    }

  ret = 0;

  while (1)
    {
      char * name;
      size_t namelen;
      char * qualified_name;

      /* Read the next archive header.  */
      if (fseek (file, arch.next_arhdr_offset, SEEK_SET) != 0)
        {
          error (_("%s: failed to seek to next archive header\n"), file_name);
          return 1;
        }
      got = fread (&arch.arhdr, 1, sizeof arch.arhdr, file);
      if (got != sizeof arch.arhdr)
        {
          if (got == 0)
	    break;
          error (_("%s: failed to read archive header\n"), file_name);
          ret = 1;
          break;
        }
      if (memcmp (arch.arhdr.ar_fmag, ARFMAG, 2) != 0)
        {
          error (_("%s: did not find a valid archive header\n"), arch.file_name);
          ret = 1;
          break;
        }

      arch.next_arhdr_offset += sizeof arch.arhdr;

      archive_file_size = strtoul (arch.arhdr.ar_size, NULL, 10);
      if (archive_file_size & 01)
        ++archive_file_size;

      name = get_archive_member_name (&arch, &nested_arch);
      if (name == NULL)
	{
	  error (_("%s: bad archive file name\n"), file_name);
	  ret = 1;
	  break;
	}
      namelen = strlen (name);

      qualified_name = make_qualified_name (&arch, &nested_arch, name);
      if (qualified_name == NULL)
	{
	  error (_("%s: bad archive file name\n"), file_name);
	  ret = 1;
	  break;
	}

      if (is_thin_archive && arch.nested_member_origin == 0)
        {
          /* This is a proxy for an external member of a thin archive.  */
          FILE * member_file;
          char * member_file_name = adjust_relative_path (file_name, name, namelen);
          if (member_file_name == NULL)
            {
              ret = 1;
              break;
            }

          member_file = fopen (member_file_name, "rb");
          if (member_file == NULL)
            {
              error (_("Input file '%s' is not readable.\n"), member_file_name);
              free (member_file_name);
              ret = 1;
              break;
            }

          archive_file_offset = arch.nested_member_origin;

          ret |= process_object (qualified_name, member_file);

          fclose (member_file);
          free (member_file_name);
        }
      else if (is_thin_archive)
        {
	  /* PR 15140: Allow for corrupt thin archives.  */
	  if (nested_arch.file == NULL)
	    {
	      error (_("%s: contains corrupt thin archive: %s\n"),
		     file_name, name);
	      ret = 1;
	      break;
	    }

          /* This is a proxy for a member of a nested archive.  */
          archive_file_offset = arch.nested_member_origin + sizeof arch.arhdr;

          /* The nested archive file will have been opened and setup by
             get_archive_member_name.  */
          if (fseek (nested_arch.file, archive_file_offset, SEEK_SET) != 0)
            {
              error (_("%s: failed to seek to archive member.\n"), nested_arch.file_name);
              ret = 1;
              break;
            }

          ret |= process_object (qualified_name, nested_arch.file);
        }
      else
        {
          archive_file_offset = arch.next_arhdr_offset;
          arch.next_arhdr_offset += archive_file_size;

          ret |= process_object (qualified_name, file);
        }

      if (dump_sects != NULL)
	{
	  free (dump_sects);
	  dump_sects = NULL;
	  num_dump_sects = 0;
	}

      free (qualified_name);
    }

 out:
  if (nested_arch.file != NULL)
    fclose (nested_arch.file);
  release_archive (&nested_arch);
  release_archive (&arch);

  return ret;
}

static int
process_file (char * file_name)
{
  FILE * file;
  struct stat statbuf;
  char armag[SARMAG];
  int ret;

  if (stat (file_name, &statbuf) < 0)
    {
      if (errno == ENOENT)
	error (_("'%s': No such file\n"), file_name);
      else
	error (_("Could not locate '%s'.  System error message: %s\n"),
	       file_name, strerror (errno));
      return 1;
    }

  if (! S_ISREG (statbuf.st_mode))
    {
      error (_("'%s' is not an ordinary file\n"), file_name);
      return 1;
    }

  file = fopen (file_name, "rb");
  if (file == NULL)
    {
      error (_("Input file '%s' is not readable.\n"), file_name);
      return 1;
    }

  if (fread (armag, SARMAG, 1, file) != 1)
    {
      error (_("%s: Failed to read file's magic number\n"), file_name);
      fclose (file);
      return 1;
    }

  if (memcmp (armag, ARMAG, SARMAG) == 0)
    ret = process_archive (file_name, file, FALSE);
  else if (memcmp (armag, ARMAGT, SARMAG) == 0)
    ret = process_archive (file_name, file, TRUE);
  else
    {
      if (do_archive_index)
	error (_("File %s is not an archive so its index cannot be displayed.\n"),
	       file_name);

      rewind (file);
      archive_file_size = archive_file_offset = 0;
      ret = process_object (file_name, file);
    }

  fclose (file);

  return ret;
}

#ifdef SUPPORT_DISASSEMBLY
/* Needed by the i386 disassembler.  For extra credit, someone could
   fix this so that we insert symbolic addresses here, esp for GOT/PLT
   symbols.  */

void
print_address (unsigned int addr, FILE * outfile)
{
  fprintf (outfile,"0x%8.8x", addr);
}

/* Needed by the i386 disassembler.  */
void
db_task_printsym (unsigned int addr)
{
  print_address (addr, stderr);
}
#endif

int
main (int argc, char ** argv)
{
  int err;

#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

  expandargv (&argc, &argv);

  parse_args (argc, argv);

  if (num_dump_sects > 0)
    {
      /* Make a copy of the dump_sects array.  */
      cmdline_dump_sects = (dump_type *)
          malloc (num_dump_sects * sizeof (* dump_sects));
      if (cmdline_dump_sects == NULL)
	error (_("Out of memory allocating dump request table.\n"));
      else
	{
	  memcpy (cmdline_dump_sects, dump_sects,
		  num_dump_sects * sizeof (* dump_sects));
	  num_cmdline_dump_sects = num_dump_sects;
	}
    }

  if (optind < (argc - 1))
    show_name = 1;

  err = 0;
  while (optind < argc)
    err |= process_file (argv[optind++]);

  if (dump_sects != NULL)
    free (dump_sects);
  if (cmdline_dump_sects != NULL)
    free (cmdline_dump_sects);

  return err;
}
@


1.611
log
@2013-10-14  Jan-Benedict Glaw  <jbglaw@@lug-owl.de>

	* readelf.c (decode_arm_unwind): Don't initialize `addr'.
@
text
@d11772 24
@


1.610
log
@	* gen-aout.c (main): Fix formatting.  Close file.

	* emultempl/aix.em (_read_file): Close file at end of function.

	* gas/all/itbl-test.c (main): Close fas.

	* read.c (add_include_dir): Use xrealloc.
	* config/tc-score.c (do_macro_bcmp): Initialise inst_main.
	* config/tc-tic6x.c (tic6x_parse_operand): Initialise second_reg.

	* readelf.c (decode_arm_unwind): Initialise addr structure.
	(process_symbol_table): Free lengths.
	* srcconv.c (wr_sc): Free info.

	* chew.c (perform): Free next.
@
text
@d7173 1
a7173 1
  struct absaddr addr = { 0 };
@


1.609
log
@binutils/
	* readelf.c (print_dynamic_symbol): Use array subscript syntax
	rather than addition syntax with string literal.
@
text
@d7173 1
a7173 1
  struct absaddr addr;
d9861 1
d9930 1
@


1.608
log
@2013-09-17  Doug Gilmore  <Doug.Gilmore@@imgtec.com>

	* readelf.c (get_machine_flags): Handle EF_MIPS_FP64.
@
text
@d419 1
a419 1
    }  
d2467 1
a2467 1
	    
d2789 1
a2789 1
	  
d2796 1
a2796 1
	    strcat (buf, ", pid");	  
d5012 1
a5012 1
      
d5015 1
a5015 1
      
d5183 1
a5183 1
    }	
d6715 1
a6715 1
	  
d6725 1
a6725 1
	  
d6757 2
a6758 2
  "A15", "B15", "B14", "B13", "B12", "B11", "B10", "B3", 
  "A14", "A13", "A12", "A11", "A10", 
d7243 1
a7243 1
	 
d7245 1
a7245 1
	 
d7429 1
a7429 1
    default: 
d8892 1
a8892 1
			      
d9322 1
a9322 1
    fputs ("     " + n, stdout);
d10055 1
a10055 1
	    
d10067 1
a10067 1
	    
d11643 1
a11643 1
		   
d12048 1
a12048 1
  
d12830 1
a12830 1
	  
@


1.608.2.1
log
@binutils/
	* readelf.c (print_dynamic_symbol): Use array subscript syntax
	rather than addition syntax with string literal.
@
text
@d419 1
a419 1
    }
d2467 1
a2467 1

d2789 1
a2789 1

d2796 1
a2796 1
	    strcat (buf, ", pid");
d5012 1
a5012 1

d5015 1
a5015 1

d5183 1
a5183 1
    }
d6715 1
a6715 1

d6725 1
a6725 1

d6757 2
a6758 2
  "A15", "B15", "B14", "B13", "B12", "B11", "B10", "B3",
  "A14", "A13", "A12", "A11", "A10",
d7243 1
a7243 1

d7245 1
a7245 1

d7429 1
a7429 1
    default:
d8892 1
a8892 1

d9322 1
a9322 1
    fputs (&"     "[n], stdout);
d10055 1
a10055 1

d10067 1
a10067 1

d11643 1
a11643 1

d12048 1
a12048 1

d12830 1
a12830 1

@


1.607
log
@	* elf32-rl78.c (rl78_elf_merge_private_bfd_data): Complain if G10
	flag bits do not match.
	(rl78_elf_print_private_bfd_data): Describe G10 flag.

	* readelf.c (get_machine_flags): Handle RL78 G10 flag.

	* config/tc-rl78.c (elf_flags): New variable.
	(enum options): Add OPTION_G10.
	(md_longopts): Add mg10.
	(md_parse_option): Parse -mg10.
	(rl78_elf_final_processing): New function.
	* config/tc-rl78.c (tc_final_processing): Define.
	* doc/c-rl78.texi: Document -mg10 option.

	* rl78.c (E_FLAG_RL78_G10): Define.

	* lib/ld-lib.exp (check_shared_lib_support): Note that the RL78
	does not support shared library generation.
@
text
@d2574 3
@


1.606
log
@	PR binutils/15745
	* readelf.c (get_unwind_section_word): Whilst searching for a
	reloc section associated with an unwind section, check the type as
	well as the section number.
@
text
@d2782 5
@


1.605
log
@	* readelf.c (process_unwind): Do not return the result of a void
	function.
@
text
@d6626 4
a6629 1
	      || section_headers + relsec->sh_info != sec)
a6638 1
	      break;
d6640 1
a6640 1
	  else if (relsec->sh_type == SHT_RELA)
a6645 1
	      break;
d6647 1
a6647 3
	  else
	    warn (_("unexpected relocation type (%d) for section %d"),
		  relsec->sh_type, relsec->sh_info);
@


1.604
log
@	include/elf/
	* mips.h (Tag_GNU_MIPS_ABI_FP): Remove comment.
	(Val_GNU_MIPS_ABI_FP_ANY, Val_GNU_MIPS_ABI_FP_DOUBLE,
	Val_GNU_MIPS_ABI_FP_SINGLE, Val_GNU_MIPS_ABI_FP_SOFT,
	Val_GNU_MIPS_ABI_FP_64): New enum.

	bfd/
	* elfxx-mips.c (mips_elf_merge_obj_attributes): Replace hardcoded
	magic numbers with enum values.

	binutils/
	* readelf.c (display_mips_gnu_attribute): Replace hardcoded magic
	numbers with enum values.

	gdb/
	* mips-tdep.c (mips_gdbarch_init): Replace hardcoded magic
	numbers with enum values.
@
text
@d7494 4
a7497 1
      return handlers[i].handler (file);
@


1.603
log
@	include/elf/
	* mips.h (EF_MIPS_NAN2008): New macro.

	bfd/
	* elfxx-mips.c (_bfd_mips_elf_merge_private_bfd_data): Handle
	EF_MIPS_NAN2008.
	(_bfd_mips_elf_print_private_bfd_data): Likewise.

	binutils/
	* readelf.c (get_machine_flags): Handle EF_MIPS_NAN2008.

	gas/
	* config/tc-mips.c (mips_flag_nan2008): New variable.
	(options): Add OPTION_NAN enum value.
	(md_longopts): Handle it.
	(md_parse_option): Likewise.
	(s_nan): New function.
	(mips_elf_final_processing): Handle EF_MIPS_NAN2008.
	(md_show_usage): Add -mnan.

	* doc/as.texinfo (Overview): Add -mnan.
	* doc/c-mips.texi (MIPS Opts): Document -mnan.
	(MIPS NaN Encodings): New node.  Document .nan directive.
	(MIPS-Dependent): List the new node.

	gas/testsuite/
	* gas/mips/nan-2008-1.d: New test.
	* gas/mips/nan-2008-2.d: New test.
	* gas/mips/nan-2008-3.d: New test.
	* gas/mips/nan-2008-4.d: New test.
	* gas/mips/nan-legacy-1.d: New test.
	* gas/mips/nan-legacy-2.d: New test.
	* gas/mips/nan-legacy-3.d: New test.
	* gas/mips/nan-legacy-4.d: New test.
	* gas/mips/nan-legacy-5.d: New test.
	* gas/mips/nan-error-1.l: New list test.
	* gas/mips/nan-error-2.l: New list test.
	* gas/mips/nan-2008-override.s: New test source.
	* gas/mips/nan-2008.s: New test source.
	* gas/mips/nan-legacy-override.s: New test source.
	* gas/mips/nan-legacy.s: New test source.
	* gas/mips/nan-error-1.s: New test source.
	* gas/mips/nan-error-2.s: New test source.
	* gas/mips/mips.exp: Run the new tests.

	ld/testsuite/
	* ld-mips-elf/nan-2008.d: New test.
	* ld-mips-elf/nan-legacy.d: New test.
	* ld-mips-elf/nan-mixed-1.d: New test.
	* ld-mips-elf/nan-mixed-2.d: New test.
	* ld-mips-elf/nan-2008.s: New test source.
	* ld-mips-elf/nan-legacy.s: New test source.
@
text
@d11738 1
a11738 1
	case 0:
d11741 1
a11741 1
	case 1:
d11744 1
a11744 1
	case 2:
d11747 1
a11747 1
	case 3:
d11750 1
a11750 1
	case 4:
@


1.602
log
@	* archures.c: Add some more MSP430 machine numbers.
	* config.bfd (msp430): Define targ_selvecs.
	* configure.in: Add bfd_elf32_msp430_ti_vec.
	* cpu-msp430.c: Add some more MSP430 machine numbers.
	* elf32-msp430.c Add support for MSP430X relocations.
	Add support for TI compiler generated relocations.
	Add support for sym_diff relocations.
	Add support for relaxing out of range short branches into long
	branches.
	Add support for MSP430 attribute section.
	* reloc.c: Add MSP430X relocations.
	* targets.c: Add bfd_elf32_msp430_ti_vec.
	* bfd-in2.h: Regenerate.
	* configure: Regenerate.
	* libbfd.h: Regenerate.

	* readelf.c: Add support for MSP430X architecture.

	* readelf.exp: Expect -wi test to fail for the MSP430.

	* config/tc-msp430.c: Add support for the MSP430X architecture.
	Add code to insert a NOP instruction after any instruction that
	might change the interrupt state.
	Add support for the LARGE memory model.
	Add code to initialise the .MSP430.attributes section.
	* config/tc-msp430.h: Add support for the MSP430X architecture.
	* doc/c-msp430.texi: Document the new -mL and -mN command line
	options.
	* NEWS: Mention support for the MSP430X architecture.

	* gas/all/gas.exp: Skip the DIFF1 test for the MSP430.
	Expect the FORWARD test to pass for the MSP430.
	Skip the REDEF tests for the MSP430.
	Expect the 930509A test to fail for the MSP430.
	* gas/all/sleb128-4.d: Skip for the MSP430.
	* gas/elf/elf.exp: Set target_machine to msp430 for the MSP430.
	Skip the EHOPT0 test for the MSP430.
	Skip the REDEF and EQU-RELOC tests for the MSP430.
	* gas/elf/section2.e-msp430: New file.
	* gas/lns/lns-big-delta.d: Remove expectation of 20-bit
	addresses.
	* gas/lns/lns.exp: Use alternate LNS COMMON test for the MSP430.
	* gas/msp430/msp430x.s: New test.
	* gas/msp430/msp430x.d: Expected disassembly.
	* gas/msp430/msp430.exp: Run new test.
	* gas/msp430/opcode.d: Update expected disassembly.

	* msp430.h: Add MSP430X relocs.
	Add some more MSP430 machine numbers.
	Add values used by .MSP430.attributes section.

	* msp430.h: Add patterns for MSP430X instructions.

	* Makefile.am: Add emsp430X.c
	* Makefine.in: Regenerate.
	* configure.tgt (msp430): Add msp430X emulation.
	* ldmain.c (multiple_definition): Only disable relaxation if it
	was enabled by the user.
	* ldmain.h (RELAXATION_ENABLED_BY_USER): New macro.
	* emulparams/msp430all.sh: Add support for MSP430X.
	* emultempl/generic.em: (before_parse): Enable relaxation for the
	MSP430.
	* scripttempl/msp430.sc: Reorganize sections.  Add .rodata
	section.
	* scripttempl/msp430_3.sc: Likewise.
	* NEWS: Mention support for MSP430X.

	* ld-elf/flags1.d: Expect this test to pass on the MSP430.
	* ld-elf/init-fini-arrays.d: Expect this test to fail on the
	MSP430.
	* ld-elf/merge.d: Expect this test to pass on the MSP430.
	* ld-elf/sec64k.exp: Skip these tests for the MSP430.
	* ld-gc/pr13683.d: Expect this test to fail on the MSP430.
	* ld-srec/srec.exp: Expect these tests to fail on the MSP430.
	* ld-undefined/undefined.exp: Expect the UNDEFINED LINE test to
	fail on the MSP430.

	* msp430-dis.c: Add support for MSP430X instructions.
@
text
@d2571 3
@


1.601
log
@	* elflink.c (_bfd_elf_gc_mark_extra_sections): Remove mark from
	fragmented .debug_line sections associated with unmarked code
	sections.

	* dwarf.c (read_debug_line_header): New function.  Reads in a
	header in a .debug_line section.
	(display_debug_lines_raw): Use new function.  Handle fragmentary
	.debug_line sections.
	(display_debug_lines_decoded): Likewise.
	* readelf.c (process_section_headers): Handle fragmenatry
	.debug_line sections.
	(display_debug_section): Likewise.

	* as.c (Options): Add -gdwarf-sections.
	(parse_args): Likewise.
	* as.h (flag_dwarf_sections): Declare.
	* dwarf2dbg.c (emit_fixed_inc_line_addr): Skip section changes.
	(process_entries): When -gdwarf-sections is enabled generate
	fragmentary .debug_line sections.
	(out_debug_line): Set the section for the .debug_line section end
	symbol.
	* doc/as.texinfo: Document -gdwarf-sections.
	* NEWS: Mention -gdwarf-sections.

	* gas/elf/dwarf2-3.d: Fix expected readelf output.

	* scripttempl/DWARF.sc: Add support for .debug_line.* and
	.debug_line_end.
@
text
@d134 1
a156 2
#include "elf/nios2.h"

d905 11
d1138 5
d2799 26
d3250 12
d3326 3
d9053 7
a9059 2
	  if (elf_header.e_machine == EM_ARM && type == STT_ARM_TFUNC)
	    return "THUMB_FUNC";
d10025 54
d10218 1
a10218 1
      return reloc_type == 1; /* R_MSP43_32.  */
d10470 2
d12025 73
d12269 7
d13754 2
@


1.600
log
@	PR binutils/15202
	* dwarf.c (read_leb128): Add END parameter.  Do not read at or
	beyond end.
	(read_sleb128): Add END parameter.
	(read_uleb128): New function.
	(process_extended_line_op): Pass END to leb128 functions.
	(process_abbrev_section): Likewise.
	(decode_location_expression): Likewise.
	(read_and_display_attr_value): Likewise.
	(read_and_display_attr): Likewise.
	(process_debug_info): Likewise.
	(display_debug_lines_raw): Likewise.
	(display_debug_lines_decoded): Likewise.
	(display_debug_macinfo): Likewise.
	(get_line_filename_and_dirname): Likewise.
	(display_debug_macro): Likewise.
	(display_loc_list_dwo): Likewise.
	(display_debug_ranges): Likewise.
	* dwarf.h (read_leb128): Update prototype.
	* readelf.c (read_uleb128): Add END parameter.
	(decode_arm_unwind_bytecode): Pass END to read_uleb128.
	(decode_tic6x_unwind_bytecode): Likewise.
	(display_tag_value): New function.
	(display_arm_attribute): Add END parameter. Pass END to
	read_uleb128.  Use display_tag_value.
	(display_gnu_attribute): Likewise.
	(display_power_gnu_attribute): Likewise.
	(display_sparc_gnu_attribute): Likewise.
	(display_mips_gnu_attribute): Likewise.
	(display_tic6x_attribute): Likewise.
	(process_attributes): Likewise.
	(display_raw_attribute): New function.
@
text
@d4841 2
a4842 1
	      || (do_debug_lines    && const_strneq (name, "line"))
d10976 1
d10985 3
a10987 1
	if (streq (sec->uncompressed_name, name))
@


1.599
log
@	PR binutils/15157
	* readelf.c (apply_relocations): Catch relocations with negative
	offsets.
@
text
@d546 4
a549 2
static unsigned long
read_uleb128 (unsigned char *data, unsigned int *length_return)
d551 1
a551 1
  return read_leb128 (data, length_return, 0);
d6865 1
a6865 1
	  offset = read_uleb128 (buf, &len);
d7061 1
a7061 1
	  offset = read_uleb128 (buf, &len);
d11100 46
d11267 2
a11268 1
display_arm_attribute (unsigned char * p)
d11277 1
a11277 1
  tag = read_uleb128 (p, &len);
d11298 1
a11298 1
	      val = read_uleb128 (p, &len);
d11312 1
a11312 1
	      val = read_uleb128 (p, &len);
d11331 1
a11331 1
	      val = read_uleb128 (p, &len);
d11350 1
a11350 1
	      val = read_uleb128 (p, &len);
d11362 1
a11362 1
	      val = read_uleb128 (p, &len);
d11366 1
a11366 1
		  val = read_uleb128 (p, &len);
d11384 1
d11386 1
a11386 2
	  type = attr->type;
	  break;
d11390 1
a11390 1
	  val = read_uleb128 (p, &len);
a11399 20
  else
    {
      if (tag & 1)
	type = 1; /* String.  */
      else
	type = 2; /* uleb128.  */
      printf ("  Tag_unknown_%d: ", tag);
    }

  if (type == 1)
    {
      printf ("\"%s\"\n", p);
      p += strlen ((char *) p) + 1;
    }
  else
    {
      val = read_uleb128 (p, &len);
      p += len;
      printf ("%d (0x%x)\n", val, val);
    }
d11401 1
a11401 1
  return p;
d11406 2
a11407 1
		       unsigned char * (* display_proc_gnu_attribute) (unsigned char *, int))
a11411 1
  int type;
d11413 1
a11413 1
  tag = read_uleb128 (p, &len);
d11420 1
a11420 1
      val = read_uleb128 (p, &len);
d11422 10
a11431 2
      printf (_("flag = %d, vendor = %s\n"), val, p);
      p += strlen ((char *) p) + 1;
d11436 1
a11436 19
    return display_proc_gnu_attribute (p, tag);

  if (tag & 1)
    type = 1; /* String.  */
  else
    type = 2; /* uleb128.  */
  printf ("  Tag_unknown_%d: ", tag);

  if (type == 1)
    {
      printf ("\"%s\"\n", p);
      p += strlen ((char *) p) + 1;
    }
  else
    {
      val = read_uleb128 (p, &len);
      p += len;
      printf ("%d (0x%x)\n", val, val);
    }
d11438 1
a11438 1
  return p;
d11442 3
a11444 1
display_power_gnu_attribute (unsigned char * p, int tag)
a11445 1
  int type;
d11451 1
a11451 1
      val = read_uleb128 (p, &len);
d11478 1
a11478 1
      val = read_uleb128 (p, &len);
d11504 7
a11510 1
      val = read_uleb128 (p, &len);
d11531 1
a11531 19
  if (tag & 1)
    type = 1; /* String.  */
  else
    type = 2; /* uleb128.  */
  printf ("  Tag_unknown_%d: ", tag);

  if (type == 1)
    {
      printf ("\"%s\"\n", p);
      p += strlen ((char *) p) + 1;
    }
  else
    {
      val = read_uleb128 (p, &len);
      p += len;
      printf ("%d (0x%x)\n", val, val);
    }

  return p;
d11579 3
a11581 1
display_sparc_gnu_attribute (unsigned char * p, int tag)
a11582 4
  int type;
  unsigned int len;
  int val;

d11585 4
a11588 1
      val = read_uleb128 (p, &len);
a11590 1

d11595 1
a11595 19
  if (tag & 1)
    type = 1; /* String.  */
  else
    type = 2; /* uleb128.  */
  printf ("  Tag_unknown_%d: ", tag);

  if (type == 1)
    {
      printf ("\"%s\"\n", p);
      p += strlen ((char *) p) + 1;
    }
  else
    {
      val = read_uleb128 (p, &len);
      p += len;
      printf ("%d (0x%x)\n", val, val);
    }

  return p;
d11599 3
a11601 1
display_mips_gnu_attribute (unsigned char * p, int tag)
a11602 4
  int type;
  unsigned int len;
  int val;

d11605 4
a11608 1
      val = read_uleb128 (p, &len);
d11636 1
a11636 19
  if (tag & 1)
    type = 1; /* String.  */
  else
    type = 2; /* uleb128.  */
  printf ("  Tag_unknown_%d: ", tag);

  if (type == 1)
    {
      printf ("\"%s\"\n", p);
      p += strlen ((char *) p) + 1;
    }
  else
    {
      val = read_uleb128 (p, &len);
      p += len;
      printf ("%d (0x%x)\n", val, val);
    }

  return p;
d11640 2
a11641 1
display_tic6x_attribute (unsigned char * p)
d11647 1
a11647 1
  tag = read_uleb128 (p, &len);
d11653 1
a11653 1
      val = read_uleb128 (p, &len);
d11687 1
a11687 1
      val = read_uleb128 (p, &len);
d11708 1
a11708 1
      val = read_uleb128 (p, &len);
d11726 1
a11726 1
      val = read_uleb128 (p, &len);
d11744 1
a11744 1
      val = read_uleb128 (p, &len);
d11762 1
a11762 1
      val = read_uleb128 (p, &len);
d11783 1
a11783 1
      val = read_uleb128 (p, &len);
d11801 1
a11801 1
      val = read_uleb128 (p, &len);
d11822 1
a11822 1
      val = read_uleb128 (p, &len);
d11843 1
a11843 1
      val = read_uleb128 (p, &len);
d11857 2
a11858 1
  printf ("  Tag_unknown_%d: ", tag);
d11860 7
a11866 1
  if (tag & 1)
d11868 31
a11898 8
      printf ("\"%s\"\n", p);
      p += strlen ((char *) p) + 1;
    }
  else
    {
      val = read_uleb128 (p, &len);
      p += len;
      printf ("%d (0x%x)\n", val, val);
d11901 1
a11901 1
  return p;
d11908 2
a11909 2
		    unsigned char * (* display_pub_attribute) (unsigned char *),
		    unsigned char * (* display_proc_gnu_attribute) (unsigned char *, int))
d12004 1
a12004 1
			  val = read_uleb128 (p, &j);
d12021 1
a12021 1
			p = display_pub_attribute (p);
d12027 2
a12028 1
						   display_proc_gnu_attribute);
a12031 1
		      /* ??? Do something sensible, like dump hex.  */
d12033 1
@


1.598
log
@	* elf-bfd.h (elfcore_write_s390_tdb): Add prototype.
	* elf.c (elfcore_write_s390_tdb): New function.
	(elfcore_write_register_note): Call it.
	(elfcore_grok_s390_tdb): New function.
	(elfcore_grok_note): Call it.

	* readelf.c (get_note_type): Add NT_S390_TDB.
@
text
@d10520 1
a10520 1
	  if ((rloc + reloc_size) > end)
@


1.597
log
@	PR binutils/15191
	* readelf.c (offsetof): Define.
	(CHECK_ENTSIZE_VALUES): Remove extraneous indefinite article.
	(process_corefile_note_segment): Allow notes without name or
	desc.  Combine out-of-range checks.  Disallow "negative"
	notesz or descsz.
@
text
@d12846 2
@


1.596
log
@	PR binutils/15191
	* binutils-all/readelf.n: Updare expected output from readelf.

	* readelf.c (process_corefile_note_segment): Prevent attempts to
	read beyond the end of the note buffer.
@
text
@d163 4
d4761 1
a4761 1
	  error (_("Section %d has invalid an sh_entsize of %" BFD_VMA_FMT "x\n"), \
a13346 1
  bfd_signed_vma data_remaining;
d13352 1
a13352 1
                                           _("notes"));
d13362 1
a13362 2
  data_remaining = length;
  while (external < (Elf_External_Note *) ((char *) pnotes + length))
a13363 1
      Elf_External_Note * next;
d13365 2
d13368 1
d13371 1
a13371 1
        {
d13374 2
a13375 1
	  if (data_remaining < sizeof * next)
d13381 8
a13388 9
          inote.type     = BYTE_GET (external->type);
          inote.namesz   = BYTE_GET (external->namesz);
          inote.namedata = external->name;
          inote.descsz   = BYTE_GET (external->descsz);
          inote.descdata = inote.namedata + align_power (inote.namesz, 2);
          inote.descpos  = offset + (inote.descdata - (char *) pnotes);

          next = (Elf_External_Note *) (inote.descdata + align_power (inote.descsz, 2));
        }
d13390 2
a13391 2
        {
          Elf64_External_VMS_Note *vms_external;
d13395 2
a13396 1
	  if (data_remaining < sizeof * vms_external)
a13401 8
	  
          vms_external = (Elf64_External_VMS_Note *) external;
          inote.type     = BYTE_GET (vms_external->type);
          inote.namesz   = BYTE_GET (vms_external->namesz);
          inote.namedata = vms_external->name;
          inote.descsz   = BYTE_GET (vms_external->descsz);
          inote.descdata = inote.namedata + align_power (inote.namesz, 3);
          inote.descpos  = offset + (inote.descdata - (char *) pnotes);
d13403 9
a13411 3
          next = (Elf_External_Note *)
            (inote.descdata + align_power (inote.descsz, 3));
        }
d13413 3
a13415 2
      data_remaining -= ((char *) next - (char *) external);
      if (data_remaining < 0)
d13417 1
a13417 1
	  warn (_("note with invalid namesz &/or descsz found at offset 0x%lx\n"),
d13424 1
a13424 12
      external = next;

      /* Prevent out-of-bounds indexing.  */
      if (inote.namedata + inote.namesz > (char *) pnotes + length
	  || inote.namedata + inote.namesz < inote.namedata)
        {
          warn (_("note with invalid namesz found at offset 0x%lx\n"),
                (unsigned long) ((char *) external - (char *) pnotes));
          warn (_(" type: 0x%lx, namesize: 0x%08lx, descsize: 0x%08lx\n"),
                inote.type, inote.namesz, inote.descsz);
          break;
        }
@


1.595
log
@	PR binutils/15140
	* ar.c (open_inarch): Fail on attempts to convert a normal archive
	to a thin archive or vice versa.
	* elfcomm.c (make_qualified_name): Handle corrupted thin
	archives.
	* readelf.c (process_archive): Likewise.
	* doc/binutils.texi: Clarify documentation describing thin
	archives.

	* archive.c (_bfd_get_elt_at_filepos): Prevent an infinite loop
	accessing a corrupt nested archive.
@
text
@d4754 1
a4754 2
      size_t expected_entsize						    \
	= is_32bit_elf ? size32 : size64;				    \
d4756 7
a4762 4
	error (_("Section %d has invalid sh_entsize %lx (expected %lx)\n"), \
	       i, (unsigned long int) section->sh_entsize,		    \
	       (unsigned long int) expected_entsize);			    \
      section->sh_entsize = expected_entsize;				    \
d4765 2
a4766 1
#define CHECK_ENTSIZE(section, i, type) \
d13343 1
d13355 1
a13355 1
  printf (_("\nNotes at offset 0x%08lx with length 0x%08lx:\n"),
d13359 1
d13368 8
d13389 10
a13398 1
          vms_external = (Elf64_External_VMS_Note *)external;
d13410 2
a13411 2
      if (   ((char *) next > ((char *) pnotes) + length)
	  || ((char *) next <  (char *) pnotes))
d13413 1
a13413 1
	  warn (_("corrupt note found at offset %lx into core notes\n"),
d13415 1
a13415 1
	  warn (_(" type: %lx, namesize: %08lx, descsize: %08lx\n"),
d13426 1
a13426 1
          warn (_("corrupt note found at offset %lx into core notes\n"),
d13428 1
a13428 1
          warn (_(" type: %lx, namesize: %08lx, descsize: %08lx\n"),
@


1.594
log
@2013-02-06  Sandra Loosemore  <sandra@@codesourcery.com>
            Andrew Jenner <andrew@@codesourcery.com>

	Based on patches from Altera Corporation.

	bfd/
	* Makefile.am (ALL_MACHINES): Add cpu-nios2.lo.
	(ALL_MACHINES_CFILES): Add cpu-nios2.c.
	(BFD_BACKENDS): Add elf32-nios2.lo.
	(BFD32_BACKENDS_CFILES): Add elf32-nios2.c.
	* Makefile.in: Regenerated.
	* configure.in: Add entries for bfd_elf32_bignios2_vec and
	bfd_elf32_littlenios2_vec.
	* configure: Regenerated.
	* config.bfd: Add cases for nios2.
	* archures.c (enum bfd_architecture): Add bfd_arch_nios2.
	(bfd_mach_nios2): Define.
	(bfd_nios2_arch): Declare.
	(bfd_archures_list): Add bfd_nios2_arch.
	* targets.c (bfd_elf32_bignios2_vec): Declare.
	(bfd_elf32_littlenios2_vec): Declare.
	(_bfd_target_vector): Add entries for bfd_elf32_bignios2_vec and
	bfd_elf32_littlenios2_vec.
	* elf-bfd.h (enum elf_target_id): Add NIOS2_ELF_DATA.
	* reloc.c (enum bfd_reloc_code_real): Add Nios II relocations.
	* bfd-in2.h: Regenerated.
	* libbfd.h: Regenerated.
	* cpu-nios2.c: New file.
	* elf32-nios2.c: New file.

	opcodes/
	* Makefile.am (TARGET_LIBOPCODES_CFILES): Add nios2-dis.c and
	nios2-opc.c.
	* Makefile.in: Regenerated.
	* configure.in: Add case for bfd_nios2_arch.
	* configure: Regenerated.
	* disassemble.c (ARCH_nios2): Define.
	(disassembler): Add case for bfd_arch_nios2.
	* nios2-dis.c: New file.
	* nios2-opc.c: New file.

	include/
	* dis-asm.h (print_insn_big_nios2): Declare.
	(print_insn_little_nios2): Declare.

	include/elf
	* nios2.h: New file.

	include/opcode/
	* nios2.h: New file.

	gas/
	* Makefile.am (TARGET_CPU_CFILES): Add config/tc-nios2.c.
	(TARGET_CPU_HFILES): Add config/tc-nios2.h.
	* Makefile.in: Regenerated.
	* configure.tgt: Add case for nios2*-linux*.
	* config/obj-elf.c: Conditionally include elf/nios2.h.
	* config/tc-nios2.c: New file.
	* config/tc-nios2.h: New file.
	* doc/Makefile.am (CPU_DOCS): Add c-nios2.texi.
	* doc/Makefile.in: Regenerated.
	* doc/all.texi: Set NIOSII.
	* doc/as.texinfo (Overview): Add Nios II options.
	(Machine Dependencies): Include c-nios2.texi.
	* doc/c-nios2.texi: New file.
	* NEWS: Note Altera Nios II support.

	gas/testsuite/
	* gas/nios2/add.d: New.
	* gas/nios2/add.s: New.
	* gas/nios2/align_fill.d: New.
	* gas/nios2/align_fill.s: New.
	* gas/nios2/align_text.d: New.
	* gas/nios2/align_text.s: New.
	* gas/nios2/and.d: New.
	* gas/nios2/and.s: New.
	* gas/nios2/branch.d: New.
	* gas/nios2/branch.s: New.
	* gas/nios2/break.d: New.
	* gas/nios2/break.s: New.
	* gas/nios2/bret.d: New.
	* gas/nios2/bret.s: New.
	* gas/nios2/cache.d: New.
	* gas/nios2/cache.s: New.
	* gas/nios2/call26.d: New.
	* gas/nios2/call26.s: New.
	* gas/nios2/call.d: New.
	* gas/nios2/call.s: New.
	* gas/nios2/cmp.d: New.
	* gas/nios2/cmp.s: New.
	* gas/nios2/comments.d: New.
	* gas/nios2/comments.s: New.
	* gas/nios2/complex.d: New.
	* gas/nios2/complex.s: New.
	* gas/nios2/ctl.d: New.
	* gas/nios2/ctl.s: New.
	* gas/nios2/custom.d: New.
	* gas/nios2/custom.s: New.
	* gas/nios2/etbt.d: New.
	* gas/nios2/etbt.s: New.
	* gas/nios2/flushda.d: New.
	* gas/nios2/flushda.s: New.
	* gas/nios2/illegal.l: New.
	* gas/nios2/illegal.s: New.
	* gas/nios2/jmp.d: New.
	* gas/nios2/jmp.s: New.
	* gas/nios2/ldb.d: New.
	* gas/nios2/ldb.s: New.
	* gas/nios2/ldh.d: New.
	* gas/nios2/ldh.s: New.
	* gas/nios2/ldw.d: New.
	* gas/nios2/ldw.s: New.
	* gas/nios2/lineseparator.d: New.
	* gas/nios2/lineseparator.s: New.
	* gas/nios2/mov.d: New.
	* gas/nios2/movia.d: New.
	* gas/nios2/movia.s: New.
	* gas/nios2/movi.d: New.
	* gas/nios2/movi.s: New.
	* gas/nios2/mov.s: New.
	* gas/nios2/mul.d: New.
	* gas/nios2/mul.s: New.
	* gas/nios2/nios2.exp: New.
	* gas/nios2/nor.d: New.
	* gas/nios2/nor.s: New.
	* gas/nios2/or.d: New.
	* gas/nios2/or.s: New.
	* gas/nios2/ret.d: New.
	* gas/nios2/ret.s: New.
	* gas/nios2/rol.d: New.
	* gas/nios2/rol.s: New.
	* gas/nios2/rotate.d: New.
	* gas/nios2/rotate.s: New.
	* gas/nios2/stb.d: New.
	* gas/nios2/stb.s: New.
	* gas/nios2/sth.d: New.
	* gas/nios2/sth.s: New.
	* gas/nios2/stw.d: New.
	* gas/nios2/stw.s: New.
	* gas/nios2/sub.d: New.
	* gas/nios2/sub.s: New.
	* gas/nios2/sync.d: New.
	* gas/nios2/sync.s: New.
	* gas/nios2/trap.d: New.
	* gas/nios2/trap.s: New.
	* gas/nios2/tret.d: New.
	* gas/nios2/tret.s: New.
	* gas/nios2/warn_noat.l: New.
	* gas/nios2/warn_noat.s: New.
	* gas/nios2/warn_nobreak.l: New.
	* gas/nios2/warn_nobreak.s: New.
	* gas/nios2/xor.d: New.
	* gas/nios2/xor.s: New.

	ld/
	* Makefile.am (enios2elf.c): New rule.
	* Makefile.in: Regenerated.
	* configure.tgt: Add case for nios2*-*-*.
	* emulparams/nios2elf.sh: New file.
	* NEWS: Note Altera Nios II support.

	ld/testsuite/
	* ld-nios2/emit-relocs-1a.s: New.
	* ld-nios2/emit-relocs-1b.s: New.
	* ld-nios2/emit-relocs-1.d: New.
	* ld-nios2/emit-relocs-1.ld: New.
	* ld-nios2/gprel.d: New.
	* ld-nios2/gprel.s: New.
	* ld-nios2/hilo16.d: New.
	* ld-nios2/hilo16.s: New.
	* ld-nios2/hilo16_symbol.s: New.
	* ld-nios2/imm5.d: New.
	* ld-nios2/imm5.s: New.
	* ld-nios2/imm5_symbol.s: New.
	* ld-nios2/nios2.exp: New.
	* ld-nios2/pcrel16.d: New.
	* ld-nios2/pcrel16_label.s: New.
	* ld-nios2/pcrel16.s: New.
	* ld-nios2/relax_callr.d: New.
	* ld-nios2/relax_callr.ld: New.
	* ld-nios2/relax_callr.s: New.
	* ld-nios2/relax_cjmp.d: New.
	* ld-nios2/relax_cjmp.s: New.
	* ld-nios2/relax_jmp.ld: New.
	* ld-nios2/relax_section.d: New.
	* ld-nios2/relax_section.s: New.
	* ld-nios2/relax_ujmp.d: New.
	* ld-nios2/relax_ujmp.s: New.
	* ld-nios2/reloc.d: New.
	* ld-nios2/reloc.s: New.
	* ld-nios2/reloc_symbol.s: New.
	* ld-nios2/s16.d: New.
	* ld-nios2/s16.s: New.
	* ld-nios2/s16_symbol.s: New.
	* ld-nios2/u16.d: New.
	* ld-nios2/u16.s: New.
	* ld-nios2/u16_symbol.s: New.
	* ld-elf/indirect.exp: Skip on targets that don't support
	-shared -fPIC.
	* ld-elfcomm/elfcomm.exp: Build with -G0 for nios2.
	* ld-plugin/lto.exp: Skip shared library tests on targets that
	don't support them.  Skip execution tests on non-native targets.

	binutils/
	* readelf.c: Include elf/nios2.h.
	(dump_relocations): Add case for EM_ALTERA_NIOS2.
	(get_nios2_dynamic_type): New.
	(get_dynamic_type): Add case for EM_ALTERA_NIOS2.
	(is_32bit_abs_reloc): Fix EM_ALTERA_NIOS2 case.
	(is_16bit_abs_reloc): Likewise.
	(is_none_reloc): Add EM_ALTERA_NIOS2 and EM_NIOS32 cases.
	* NEWS: Note Altera Nios II support.
	* MAINTAINERS: Add Nios II maintainers.
@
text
@d13978 9
@


1.593
log
@	* readelf.c (process_version_sections): Fix overflow checks to
	avoid undefined behaviour.
@
text
@d156 2
d1293 4
d1696 11
d1820 3
d10097 1
d10348 1
d10405 2
@


1.592
log
@Add support for V850E3V5 architecture
@
text
@d2 1
a2 3
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007,
   2008, 2009, 2010, 2011, 2012, 2013
   Free Software Foundation, Inc.
d8470 2
a8471 2
		/* Check for negative or very large indicies.  */
		if ((unsigned char *) edefs + idx < (unsigned char *) edefs)
d8495 1
a8495 2
		if ((unsigned char *)(vstart + ent.vd_aux) < (unsigned char *) vstart
		    || (unsigned char *)(vstart + ent.vd_aux) > (unsigned char *) endbuf)
d8515 1
a8515 2
		    if ((unsigned char *)(vstart + aux.vda_next) < (unsigned char *) vstart
			|| (unsigned char *)(vstart + aux.vda_next) > (unsigned char *) endbuf)
d8585 1
a8585 1
		if ((unsigned char *) eneed + idx < (unsigned char *) eneed)
d8610 1
a8610 2
		if ((unsigned char *)(vstart + ent.vn_aux) < (unsigned char *) vstart
		    || (unsigned char *)(vstart + ent.vn_aux) > (unsigned char *) endbuf)
d8641 1
a8641 2
		    if ((unsigned char *)(vstart + aux.vna_next) < (unsigned char *) vstart
			|| (unsigned char *)(vstart + aux.vna_next) > (unsigned char *) endbuf)
@


1.591
log
@2013-01-23  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* readelf.c: Add strings for NT_S390_LAST_BREAK and
	NT_S390_SYSTEM_CALL.
@
text
@d2479 3
d10329 1
a10330 1
    case EM_MSP430:
@


1.590
log
@	* common.h: Fix case of "Meta".
	* metag.h: New file.

	* dis-asm.h (print_insn_metag): New declaration.

	* metag.h: New file.

	* Makefile.am: Add Meta.
	* Makefile.in: Regenerate.
	* configure: Regenerate.
	* configure.in: Add Meta.
	* disassemble.c: Add Meta support.
	* metag-dis.c: New file.

	* Makefile.am: Add Meta.
	* Makefile.in: Regenerate.
	* archures.c (bfd_mach_metag): New.
	* bfd-in2.h: Regenerate.
	* config.bfd: Add Meta.
	* configure: Regenerate.
	* configure.in: Add Meta.
	* cpu-metag.c: New file.
	* elf-bfd.h: Add Meta.
	* elf32-metag.c: New file.
	* elf32-metag.h: New file.
	* libbfd.h: Regenerate.
	* reloc.c: Add Meta relocations.
	* targets.c: Add Meta.

	* Makefile.am: Add Meta.
	* Makefile.in: Regenerate.
	* config/tc-metag.c: New file.
	* config/tc-metag.h: New file.
	* configure.tgt: Add Meta.
	* doc/Makefile.am: Add Meta.
	* doc/Makefile.in: Regenerate.
	* doc/all.texi: Add Meta.
	* doc/as.texiinfo: Document Meta options.
	* doc/c-metag.texi: New file.

	* gas/metag/labelarithmetic.d: New file.
	* gas/metag/labelarithmetic.s: New file.
	* gas/metag/metacore12.d: New file.
	* gas/metag/metacore12.s: New file.
	* gas/metag/metacore21-invalid.l: New file.
	* gas/metag/metacore21-invalid.s: New file.
	* gas/metag/metacore21.d: New file.
	* gas/metag/metacore21.s: New file.
	* gas/metag/metacore21ext.d: New file.
	* gas/metag/metacore21ext.s: New file.
	* gas/metag/metadsp21-invalid.l: New file.
	* gas/metag/metadsp21-invalid.s: New file.
	* gas/metag/metadsp21.d: New file.
	* gas/metag/metadsp21.s: New file.
	* gas/metag/metadsp21ext.d: New file.
	* gas/metag/metadsp21ext.s: New file.
	* gas/metag/metafpu21.d: New file.
	* gas/metag/metafpu21.s: New file.
	* gas/metag/metafpu21ext.d: New file.
	* gas/metag/metafpu21ext.s: New file.
	* gas/metag/metag.exp: New file.
	* gas/metag/tls.d: New file.
	* gas/metag/tls.s: New file.

	* Makefile.am: Add Meta.
	* Makefile.in: Regenerate.
	* configure.tgt: Add Meta.
	* emulparams/elf32metag.sh: New file.
	* emultempl/metagelf.em: New file.

	* ld-elf/merge.d: Mark Meta as xfail.
	* ld-gc/start.d: Skip this test on Meta.
	* ld-gc/personality.d: Skip this test on Meta.
	* ld-metag/external.s: New file.
	* ld-metag/metag.exp: New file.
	* ld-metag/pcrel.d: New file.
	* ld-metag/pcrel.s: New file.
	* ld-metag/shared.d: New file.
	* ld-metag/shared.r: New file.
	* ld-metag/shared.s: New file.
	* ld-metag/stub.d: New file.
	* ld-metag/stub.s: New file.
	* ld-metag/stub_pic_app.d: New file.
	* ld-metag/stub_pic_app.r: New file.
	* ld-metag/stub_pic_app.s: New file.
	* ld-metag/stub_pic_shared.d: New file.
	* ld-metag/stub_pic_shared.s: New file.
	* ld-metag/stub_shared.d: New file.
	* ld-metag/stub_shared.r: New file.
	* ld-metag/stub_shared.s: New file.

	* binutils/readelf.c: (guess_is_rela): Add EM_METAG.
	(dump_relocations): Add EM_METAG.
	(get_machine_name): Correct case for Meta.
	(is_32bit_abs_reloc): Add support for Meta ADDR32 reloc.
	(is_none_reloc): Add support for Meta NONE reloc.
@
text
@d12814 4
@


1.589
log
@include/elf/

2013-01-08  Yufeng Zhang  <yufeng.zhang@@arm.com>

	* common.h (NT_ARM_TLS, NT_ARM_HW_BREAK, NT_ARM_HW_WATCH): New macro
	definitions.

bfd/

2013-01-08  Yufeng Zhang  <yufeng.zhang@@arm.com>

	* elf-bfd.h (elfcore_write_aarch_tls): Add prototype.
	(elfcore_write_aarch_hw_break): Likewise.
	(elfcore_write_aarch_hw_watch): Likewise.
	* elf.c (elfcore_grok_aarch_tls): New function.
	(elfcore_grok_aarch_hw_break): Likewise.
	(elfcore_grok_aarch_hw_watch): Likewise.
	(elfcore_grok_note): Call the new functions to handle the
	corresponding notes.
	(elfcore_write_aarch_tls): New function.
	(elfcore_write_aarch_hw_break): Likewise.
	(elfcore_write_aarch_hw_watch): Likewise.
	(elfcore_write_register_note): Call the new functions to handle the
	corresponding pseudo sections.

binutils/

2013-01-08  Yufeng Zhang  <yufeng.zhang@@arm.com>

	* readelf.c (get_note_type): Handle NT_ARM_TLS, NT_ARM_HW_BREAK
	and NT_ARM_HW_WATCH.
@
text
@d127 1
d614 1
d1269 4
d2038 1
a2038 1
    case EM_METAG:		return "Imagination Technologies META processor architecture";
d10058 2
d10395 2
@


1.588
log
@Update DF_1_XXX from Solaris

binutils/

	* readelf.c (process_dynamic_section): Correct DF_1_CONFALT.
	Also dump DF_1_ENDFILTEE, DF_1_DISPRELDNE, DF_1_NODIRECT,
	DF_1_IGNMULDEF, DF_1_NOKSYMS, DF_1_NOHDR, DF_1_EDITED,
	DF_1_NORELOC, DF_1_SYMINTPOSE, DF_1_GLOBAUDIT and DF_1_SINGLETON.

include/elf/

	* common.h (DF_1_CONLFAT): Renamed to ...
	(DF_1_CONFALT): This.
	(DF_1_ENDFILTEE): New.
	(DF_1_DISPRELDNE): Likewise.
	(DF_1_DISPRELPND): Likewise.
	(DF_1_NODIRECT): Likewise.
	(DF_1_IGNMULDEF): Likewise.
	(DF_1_NOKSYMS): Likewise.
	(DF_1_NOHDR): Likewise.
	(DF_1_EDITED): Likewise.
	(DF_1_NORELOC): Likewise.
	(DF_1_SYMINTPOSE): Likewise.
	(DF_1_GLOBAUDIT): Likewise.
	(DF_1_SINGLETON): Likewise.
@
text
@d3 1
a3 1
   2008, 2009, 2010, 2011, 2012
d12806 6
@


1.587
log
@	* readelf.c (get_machine_flags) <EM_MIPS, EM_MIPS_RS3_LE>: Move
	code to handle EF_SH_PIC and EF_SH_FDPIC...
	<EM_SH>: ... here.
@
text
@d8113 1
a8113 1
		  if (val & DF_1_CONLFAT)
d8115 62
a8176 2
		      printf (" CONLFAT");
		      val ^= DF_1_CONLFAT;
@


1.586
log
@2012-11-09  Nick Clifton  <nickc@@redhat.com>

	* elf32-rx.c (describe_flags): New function.  Returns a buffer
	containing a description of the E_FLAG_RX_... values set.
	(rx_elf_merge_private_bfd_data): Use it.
	(rx_elf_print_private_bfd_data): Likewise.
	(elf32_rx_machine): Skip EF_RX_CPU_RX check.
	(elf32_rx_special_sections): Define.
	(elf_backend_special_sections): Define.

2012-11-09  Nick Clifton  <nickc@@redhat.com>

	* readelf.c (get_machine_flags): Add support for E_FLAG_RX_ABI.

2012-11-09  Nick Clifton  <nickc@@redhat.com>

	* config/obj-elf.c (obj_elf_change_section): Allow init array
	sections to have the SHF_EXECINSTR attribute for the RX target.
	* config/tc-rx.c (elf_flags): Initialise with E_FLAG_RX_ABI.
	(enum options): Add OPTION_USES_GCC_ABI and OPTION_USES_RX_ABI.
	(md_longopts): Add -mgcc-abi and -mrx-abi.
	(md_parse_option): Add support for OPTION_USES_GCC_ABI and
	OPTION_USES_RX_ABI.
	* doc/as.texinfo (RX Options): Add mention of remaining RX
	options.
	* doc/c-rx.texi: Document -mgcc-abi and -mrx-abi.

2012-11-09  Nick Clifton  <nickc@@redhat.com>

	* rx.h (EF_RX_CPU_RX): Add comment.
	(E_FLAG_RX_ABI): Define.

2012-11-09  Nick Clifton  <nickc@@redhat.com>

	* emultempl/rxelf.em (no_flag_mismatch_warnings): Initialise to
	true.
	(PARSE_AND_LIST_LONGOPTS): Add flag-mismatch-warnings.
	(PARSE_AND_LIST_ARG_CASES): Add support for
	--flag-mismatch-warnings.
@
text
@a2585 6

	  if (e_flags & EF_SH_PIC)
	    strcat (buf, ", pic");

	  if (e_flags & EF_SH_FDPIC)
	    strcat (buf, ", fdpic");
d2615 5
@


1.585
log
@binutils
	* readelf.c (get_note_type): Handle NT_386_TLS, NT_386_IOPERM.
include/common/elf
	* common.h (NT_386_TLS, NT_386_IOPERM): New defines.
@
text
@d637 1
d1062 3
a1891 1
    case EM_V800:		return "NEC V800";
d1916 1
d2419 50
d2739 2
d10057 2
@


1.584
log
@
bfd:
        * elf32-arm.c (elf32_arm_print_private_bfd_data): Recognise and
        display the new ARM hard-float/soft-float ABI flags for EABI_VER5
        (elf32_arm_post_process_headers): Add the hard-float/soft-float
        ABI flag as appropriate for ET_DYN/ET_EXEC in EABI_VER5.

binutils:
        * readelf.c (decode_ARM_machine_flags): Recognise and display the
        new ARM hard-float/soft-float ABI flags for EABI_VER5. Split out
        the code for EABI_VER4 and EABI_VER5 to allow this.

elfcpp:
        * arm.h: New enum for EABI soft- and hard-float flags.

gold:
        * gold.cc (Target_arm::do_adjust_elf_header): Add the
        hard-float/soft-float ABI flag as appropriate for ET_DYN/ET_EXEC
        in EABI_VER5.

include:
        * elf/arm.h (EF_ARM_ABI_FLOAT_SOFT): New define.
        (EF_ARM_ABI_FLOAT_HARD): Likewise.

ld/testsuite:
        * ld-arm/eabi-hard-float.s: New test source.
        * ld-arm/eabi-soft-float.s: New test source.
        * ld-arm/eabi-hard-float.d: New test.
        * ld-arm/eabi-soft-float.d: New test.
        * ld-arm/eabi-soft-float-ABI4.d: New test.
        * ld-arm/eabi-soft-float-r.d: New test.
        * ld-arm/arm-elf.xp: Use the new tests.

binutils:
	PR binutils/14779
	* configure.in: Add checks for wchar.h and mbstate_t.
	* config.in: Regenerate.
	* configure: Regenerate.
	* readelf.c: Conditionally include wchar.h.
	(print_symbol): Conditionally use mbstate_t.
@
text
@d12669 4
@


1.583
log
@binutils/
	* dwarf.c (do_debug_addr, do_debug_cu_index): New global flags.
	(load_debug_info): Fix typo.
	(cu_tu_indexes_read, shndx_pool, shndx_pool_size, shndx_pool_used):
	New global variables.
	(prealloc_cu_tu_list, add_shndx_to_cu_tu_entry, end_cu_tu_entry)
	(process_cu_tu_index, load_cu_tu_indexes, find_cu_tu_set)
	(display_cu_index): New functions.
	(dwarf_select_sections_by_names): Add "debug_addr", "cu_index".
	Sort entries alphabetically.
	(dwarf_select_sections_all): Set do_debug_addr, do_debug_cu_index.
	(debug_displays): Add .debug_cu_index, .debug_tu_index.
	Clean up formatting.
	* dwarf.h (dwarf_section_display_enum): Add dwp_cu_index,
	dwp_tu_index.
	(do_debug_addr, do_debug_cu_index): New global flags.
	(find_cu_tu_set): New function declaration.
	* objdump.c (usage): Add --dwarf=addr, --dwarf=cu_index.
	* readelf.c (find_section_in_set): New function.
	(usage): Add --debug-dump=addr, --debug_dump=cu_index.
	(process_section_headers): Check do_debug_addr and do_debug_cu_index.
	(section_subset): New global variable.
	(load_debug_section): Restrict search to section subset.
	(display_debug_section): Add section index as paramter.  Select subset
	of sections when dumping a .dwp file.  Update caller.
@
text
@d51 1
d53 1
d391 1
a391 1
   multibye characters.
d405 1
d407 1
d424 1
d427 1
a431 1
      wchar_t w;
d457 3
d465 1
d470 3
d2137 25
a2161 1
      goto eabi;
a2164 1
    eabi:
d2183 8
@


1.582
log
@binutils
	* readelf.c (get_note_type): Handle NT_SIGINFO, NT_FILE.
	(print_core_note): New function.
	(process_note): Call it.
include/common/elf
	* common.h (NT_SIGINFO, NT_FILE): New defines.
@
text
@d508 18
d3265 2
a3266 1
               =gdb_index,=trace_info,=trace_abbrev,=trace_aranges]\n\
d4693 2
a4694 1
		|| do_debug_str || do_debug_loc || do_debug_ranges)
d4717 3
d10699 4
d10710 1
a10710 1
  sec = find_section (section->uncompressed_name);
d10715 1
a10715 1
      sec = find_section (section->compressed_name);
d10722 6
d10746 1
a10746 1
display_debug_section (Elf_Internal_Shdr * section, FILE * file)
d10790 4
d10796 2
d10869 1
a10869 1
	display_debug_section (section, file);
@


1.581
log
@Ignore section symbols without a BFD section

bfd/

	PR binutils/14493
	* elf.c (ignore_section_sym): Also ignore section symbols without
	a BFD section.

binutils/

	PR binutils/14493
	* readelf.c (get_symbol_index_type): Check bad section index.
@
text
@d12615 4
d12637 86
d13083 2
@


1.580
log
@	* bfd/elf32-arm.c (v8): New array.
	(tag_cpu_arch_combine): Add support for ARMv8 attributes.
	(elf32_arm_merge_eabi_attributes): Likewise.
	(VFP_VERSION_COUNT): New define.
	* binutils/readelf.c (arm_attr_tag_CPU_arch): Update for ARMv8.
	(arm_attr_tag_FP_arch): Likewise.
	(arm_attr_tag_Advanced_SIMD_arch): Likewise.
	* gas/config/tc-arm.h (arm_ext_v8): New variable.
	(fpu_vfp_ext_armv8): Likewise.
	(fpu_neon_ext_armv8): Likewise.
	(fpu_crypto_ext_armv8): Likewise.
	(arm_archs): Add armv8-a.
	(arm_extensions): Add crypto, fp, and simd.
	(arm_fpus): Add fp-armv8, neon-fp-armv8, crypto-neon-fp-armv8.
	(cpu_arch_ver): Add support for ARMv8.
	(aeabi_set_public_sttributes): Likewise.
	* gas/doc/c-arm.texi (ARM Options): Document new architecture and
	extension options for ARMv8.
	* gas/testsuite/gas/arm/attr-march-all.d: Update for change in expected
	output.
	* gas/testsuite/gas/arm/attr-mfpu-vfpv4-d16.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfpv4.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv8-a+crypto.d: New testcase.
	* gas/testsuite/gas/arm/attr-march-armv8-a+fp.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv8-a+simd.d: Likewise.
	* gas/testsuite/gas/arm/attr-march-armv8-a.d: Likewise.
	* include/elf/arm.h (TAG_CPU_ARCH_V8): New define.
	(MAX_TAG_CPU_ARCH): Update.
	* include/opcode/arm.h (ARM_EXT_V8): New define.
	(FPU_VFP_EXT_ARMV8): Likewise.
	(FPU_NEON_EXT_ARMV8): Likewise.
	(FPU_CRYPTO_EXT_ARMV8): Likewise.
	(ARM_AEXT_V8A): Likewise.
	(FPU_VFP_ARMV8): Likwise.
	(FPU_NEON_ARMV8): Likewise.
	(FPU_CRYPTO_ARMV8): Likewise.
	(FPU_ARCH_VFP_ARMV8): Likewise.
	(FPU_ARCH_NEON_VFP_ARMV8): Likewise.
	(FPU_ARCH_CRYPTO_NEON_VFP_ARMV8): Likewise.
	(ARM_ARCH_V8A): Likwise.
	(ARM_ARCH_V8A_FP): Likewise.
	(ARM_ARCH_V8A_SIMD): Likewise.
	(ARM_ARCH_V8A_CRYPTO): Likewise.
	* ld/testsuite/ld-arm/arm-elf.exp: Add new testcases.
	* ld/testsuite/ld-arm/attr-merge-vfp-3.d: Update for change in expected
	output.
	* ld/testsuite/ld-arm/attr-merge-vfp-3r.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-4.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-4r.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-5.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-5r.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-7.d: New testcase.
	* ld/testsuite/ld-arm/attr-merge-vfp-7r.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-armv8-hard.s: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-armv8.s: Likewise.
@
text
@d8977 2
@


1.579
log
@Add support for 64-bit ARM architecture: AArch64
@
text
@d10871 1
a10871 1
   "v6K", "v7", "v6-M", "v6S-M", "v7E-M"};
d10876 2
a10877 1
  {"No", "VFPv1", "VFPv2", "VFPv3", "VFPv3-D16", "VFPv4", "VFPv4-D16"};
d10880 1
a10880 1
  {"No", "NEONv1", "NEONv1 with Fused-MAC"};
@


1.578
log
@	* elfcomm.c (setup_archive): Extract index table and symbol table
	scanning code into...
	(process_archive_index_and_symbols): ... this function and add
	support for 64-bit index tables.
	* elfcomm.h (struct archive_info): Change type of index_num and
	index_array to elf_vma.
	Add 'uses_64bit_indicies' field.
	* readelf.c (process_archive): Fix support for 64-bit indicies.
@
text
@d94 1
d555 1
d988 4
d1839 1
d2705 14
d2840 3
d3004 13
d3115 3
d9813 2
d9969 2
d10025 2
d10063 2
d10194 2
@


1.578.2.1
log
@Add support for 64-bit ARM architecture: aarch64
@
text
@a93 1
#include "elf/aarch64.h"
a553 1
    case EM_AARCH64:
a985 4
	case EM_AARCH64:
	  rtype = elf_aarch64_reloc_type (type);
	  break;

a1832 1
    case EM_AARCH64:		return "AArch64";
a2697 14
get_aarch64_segment_type (unsigned long type)
{
  switch (type)
    {
    case PT_AARCH64_ARCHEXT:
      return "AARCH64_ARCHEXT";
    default:
      break;
    }

  return NULL;
}

static const char *
a2818 3
	    case EM_AARCH64:
	      result = get_aarch64_segment_type (p_type);
	      break;
a2979 13
get_aarch64_section_type_name (unsigned int sh_type)
{
  switch (sh_type)
    {
    case SHT_AARCH64_ATTRIBUTES:
      return "AARCH64_ATTRIBUTES";
    default:
      break;
    }
  return NULL;
}

static const char *
a3077 3
	    case EM_AARCH64:
	      result = get_aarch64_section_type_name (sh_type);
	      break;
a9772 2
    case EM_AARCH64:
      return reloc_type == 258; /* R_AARCH64_ABS32 */
a9926 2
    case EM_AARCH64:
      return reloc_type == 261; /* R_AARCH64_PREL32 */
a9980 2
    case EM_AARCH64:
      return reloc_type == 257;	/* R_AARCH64_ABS64.  */
a10016 2
    case EM_AARCH64:
      return reloc_type == 260;	/* R_AARCH64_PREL64.  */
a10145 2
    case EM_AARCH64:
      return reloc_type == 0 || reloc_type == 256;
@


1.578.2.2
log
@	Apply mainline patches

bfd/:
	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* elf32-arm.c (v8): New array.
	(tag_cpu_arch_combine): Add support for ARMv8 attributes.
	(elf32_arm_merge_eabi_attributes): Likewise.
	(VFP_VERSION_COUNT): New define.

gas/:
	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (ARM_ENC_TAB): Add sha1h and sha2op entries.
	(do_sha1h): New function.
	(do_sha1su1): Likewise.
	(do_sha256su0): Likewise.
	(insns): Add 2 operand SHA instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (NEON_ENC_TAB): Add sha3op entry.
	(do_crypto_3op_1): New function.
	(do_sha1c): Likewise.
	(do_sha1p): Likewise.
	(do_sha1m): Likewise.
	(do_sha1su0): Likewise.
	(do_sha256h): Likewise.
	(do_sha256h2): Likewise.
	(do_sha256su1): Likewise.
	(insns): Add SHA 3 operand instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (neon_type_mask): Add P64 type.
	(type_chk_of_el_type): Handle P64 type.
	(el_type_of_type_chk): Likewise.
	(do_neon_vmull): Handle VMULL.P64.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (NEON_ENC_TAB): Add aes entry.
	(neon_type_mask): Add N_UNT.
	(neon_check_type): Don't always decay typed to untyped sizes.
	(do_crypto_2op_1): New function.
	(do_aese): Likewise.
	(do_aesd): Likewise.
	(do_aesmc.8): Likewise.
	(do_aesimc.8): Likewise.
	(insns): Add AES instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (el_type_type_check): Add handling for 16-bit
	floating point types.
	(do_neon_cvttb_2): New function.
	(do_neon_cvttb_1): Likewise.
	(do_neon_cvtb): Refactor to use do_neon_cvttb_1.
	(do_neon_cvtt): Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (NEON_ENC_TAB): Add vrint entries.
	(neon_cvt_mode): Add neon_cvt_mode_r.
	(do_vrint_1): New function.
	(do_vrint_x): Likewise.
	(do_vrint_z): Likewise.
	(do_vrint_r): Likewise.
	(do_vrint_a): Likewise.
	(do_vrint_n): Likewise.
	(do_vrint_p): Likewise.
	(do_vrint_m): Likewise.
	(insns): Add VRINT instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (NEON_ENC_TAB): Add vcvta entry.
	(neon_cvt_mode): New enumeration.
	(do_vfp_nsyn_cvt_fpv8): New function.
	(do_neon_cvt_1): Add support for new conversions.
	(do_neon_cvtr): Use neon_cvt_mode enumerator.
	(do_neon_cvt): Likewise.
	(do_neon_cvta): New function.
	(do_neon_cvtn): Likewise.
	(do_neon_cvtp): Likewise.
	(do_neon_cvtm): Likewise.
	(insns): Add new VCVT instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm>
	* config/tc-arm.c (CVT_FLAVOUR_VAR): New define.
	(CVT_VAR): New helper define.
	(neon_cvt_flavour): New enumeration, function renamed...
	(get_neon_cvt_flavour): ...to this.
	(do_vfp_nsyn_cvt): Update to use new neon_cvt_flavour.
	(do_vfp_nsyn_cvtz): Likewise.
	(do_neon_cvt_1): Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (NEON_ENC_TAB): Add vmaxnm, vminnm entries.
	(vfp_or_neon_is_neon_bits): Add NEON_CHECK_ARCH8 enumerator.
	(vfp_or_neon_is_neon): Add check for SIMD for ARMv8.
	(do_maxnm): New function.
	(insns): Add vmaxnm, vminnm entries.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (NEON_ENC_TAB): Add entries for VSEL.
	(NEON_ENC_FPV8_): New define.
	(do_vfp_nsyn_fpv8): New function.
	(do_vsel): Likewise.
	(insns): Add VSEL instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (do_rm_rn): New function.
	(do_strlex): Likewise.
	(do_t_strlex): Likewise.
	(insns): Add support for LDRA/STRL instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (do_t_bkpt_hlt1): New function.
	(do_t_hlt): New function.
	(do_t_bkpt): Use do_t_bkpt_hlt1.
	(insns): Add HLT.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (insns): Add DCPS instruction.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (T16_32_TAB): Add _sevl.
	(insns): Add SEVL.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (asm_barrier_opt): Add arch field.
	(mark_feature_used): New function.
	(parse_barrier): Check specified option is valid for the
	specified architecture.
	(UL_BARRIER): New macro.
	(barrier_opt_names): Update for new barrier options.

	2012-08-24  Matthew Gretton-Dann <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (do_setend): Warn on deprecated SETEND.
	(do_t_setend): Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (do_t_it): Fully initialise now_it.
	(new_automatic_it_block): Likewise.
	(handle_it_block): Record whether current instruction is
	conditionally executed.
	* config/tc-arm.c (depr_insn_mask): New structure.
	(depr_it_insns): New variable.
	(it_fsm_post_encode): Warn on deprecated uses.
	* config/tc-arm.h (current_it): Add new fields.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (deprecated_coproc_regs_s): New structure.
	(deprecated_coproc_regs): New variable.
	(deprecated_coproc_reg_count): Likewise.
	(do_co_reg): Error on obsolete & warn on deprecated registers.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.c (check_obsolete): New function.
	(do_rd_rm_rn): Check swp{b} for obsoletion.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* config/tc-arm.h (arm_ext_v8): New variable.
	(fpu_vfp_ext_armv8): Likewise.
	(fpu_neon_ext_armv8): Likewise.
	(fpu_crypto_ext_armv8): Likewise.
	(arm_archs): Add armv8-a.
	(arm_extensions): Add crypto, fp, and simd.
	(arm_fpus): Add fp-armv8, neon-fp-armv8, crypto-neon-fp-armv8.
	(cpu_arch_ver): Add support for ARMv8.
	(aeabi_set_public_sttributes): Likewise.
	* doc/c-arm.texi (ARM Options): Document new architecture and
	extension options for ARMv8.

gas/testsuite/:
	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a+crypto.s: Update testcase.
	* gas/arm/armv8-a+crypto.d: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a+crypto.d: Update testcase.
	* gas/arm/armv8-a+crypto.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a+crypto.d: Update testcase.
	* gas/arm/armv8-a+crypto.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a+crypto.d: New testcase.
	* gas/arm/armv8-a+crypto.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a+fp.d: Update testcase.
	* gas/arm/armv8-a+fp.s: Likewise.
	* gas/arm/half-prec-vfpv3.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a+fpv5.d: Update testcase.
	* gas/arm/armv8-a+fpv5.s: Likewise.
	* gas/arm/armv8-a+simdv3.d: Likewise.
	* gas/arm/armv8-a+simdv3.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a+fp.d: Update testcase.
	* gas/arm/armv8-a+fp.s: Likewise.
	* gas/arm/armv8-a+simd.d: Likewise.
	* gas/arm/armv8-a+simd.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/testsuite/gas/armv8-a+fp.d: Update testcase.
	* gas/testsuite/gas/armv8-a+fp.s: Likewise.
	* gas/testsuite/gas/armv8-a+simd.d: New testcase.
	* gas/testsuite/gas/armv8-a+simd.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a+fp.d: New testcase.
	* gas/arm/armv8-a+fp.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a-bad.l: Update testcase.
	* gas/arm/armv8-a-bad.s: Likewise.
	* gas/arm/armv8-a.d: Likewise.
	* gas/arm/armv8-a.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a-bad.l: Update for HLT.
	* gas/arm/armv8-a-bad.s: Likewise.
	* gas/arm/armv8-a.d: Likewise.
	* gas/arm/armv8-a.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a.d: Update.
	* gas/arm/armv8-a.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a.s: New testcase.
	* gas/arm/armv8-a.d: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a-barrier.s: New testcase.
	* gas/arm/armv8-a-barrier-arm.d: Likewise.
	* gas/arm/armv8-a-barrier-thumb.d: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a-bad.l: Update
	* gas/arm/armv8-a-bad.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a-it-bad.d: New testcase.
	* gas/arm/armv8-a-it-bad.l: Likewise.
	* gas/arm/armv8-a-it-bad.s: Likewise.
	* gas/arm/ldr-t-bad.s: Update testcase.
	* gas/arm/ldr-t.d: Likewise.
	* gas/arm/ldr-t.s: Likewise.
	* gas/arm/neon-cond-bad-inc.s: Likewise.
	* gas/arm/sp-pc-validations-bad-t: Likewise.
	* gas/arm/vfp-fma-inc.s: Likewise.
	* gas/arm/vfp-neon-syntax-inc.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a-bad.l: Update testcase.
	* gas/arm/armv8-a-bad.s: Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/armv8-a-bad.d: New testcase.
	* gas/arm/armv8-a-bad.l: Likewise.
	* gas/arm/armv8-a-bad.s: Likewise.
	* gas/arm/depr-swp.l: Update for change in expected output.
	* gas/arm/depr-swp.s: Add additional test.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* gas/arm/attr-march-all.d: Update for change in expected
	output.
	* gas/arm/attr-mfpu-vfpv4-d16.d: Likewise.
	* gas/arm/attr-mfpu-vfpv4.d: Likewise.
	* gas/arm/attr-march-armv8-a+crypto.d: New testcase.
	* gas/arm/attr-march-armv8-a+fp.d: Likewise.
	* gas/arm/attr-march-armv8-a+simd.d: Likewise.
	* gas/arm/attr-march-armv8-a.d: Likewise.

include/:
	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* opcode/arm.h (ARM_CPU_IS_ANY): New define.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* elf/arm.h (TAG_CPU_ARCH_V8): New define.
	(MAX_TAG_CPU_ARCH): Update.
	* opcode/arm.h (ARM_EXT_V8): New define.
	(FPU_VFP_EXT_ARMV8): Likewise.
	(FPU_NEON_EXT_ARMV8): Likewise.
	(FPU_CRYPTO_EXT_ARMV8): Likewise.
	(ARM_AEXT_V8A): Likewise.
	(FPU_VFP_ARMV8): Likwise.
	(FPU_NEON_ARMV8): Likewise.
	(FPU_CRYPTO_ARMV8): Likewise.
	(FPU_ARCH_VFP_ARMV8): Likewise.
	(FPU_ARCH_NEON_VFP_ARMV8): Likewise.
	(FPU_ARCH_CRYPTO_NEON_VFP_ARMV8): Likewise.
	(ARM_ARCH_V8A): Likwise.
	(ARM_ARCH_V8A_FP): Likewise.
	(ARM_ARCH_V8A_SIMD): Likewise.
	(ARM_ARCH_V8A_CRYPTO): Likewise.

ld/testsuite/:
	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* ld-arm/arm-elf.exp: Add new testcases.
	* ld-arm/attr-merge-vfp-3.d: Update for change in expected
	output.
	* ld-arm/attr-merge-vfp-3r.d: Likewise.
	* ld-arm/attr-merge-vfp-4.d: Likewise.
	* ld-arm/attr-merge-vfp-4r.d: Likewise.
	* ld-arm/attr-merge-vfp-5.d: Likewise.
	* ld-arm/attr-merge-vfp-5r.d: Likewise.
	* ld-arm/attr-merge-vfp-7.d: New testcase.
	* ld-arm/attr-merge-vfp-7r.d: Likewise.
	* ld-arm/attr-merge-vfp-armv8-hard.s: Likewise.
	* ld-arm/attr-merge-vfp-armv8.s: Likewise.

opcodes/
	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (neon_opcodes): Add 2 operand sha instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (neon_opcodes): Add SHA 3-operand instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (neon_opcodes): Handle VMULL.P64.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (neon_opcodes): Add support for AES instructions.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (coprocessor_opcodes): Add support for HP/DP
	conversions.

	2012-08-24  Matthew  Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (coprocessor_opcodes): Add VRINT.
	(neon_opcodes): Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (coprocessor_opcodes): Add support for new VCVT
	variants.
	(neon_opcodes): Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (coprocessor_opcodes): Add VMAXNM/VMINNM.
	(neon_opcodes): Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (coprocessor_opcodes): Add VSEL.
	(print_insn_coprocessor): Add new %<>c bitfield format
	specifier.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (arm_opcodes): Add LDRA/STRL instructions.
	(thumb32_opcodes): Likewise.
	(print_arm_insn): Add support for %<>T formatter.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (arm_opcodes): Add HLT.
	(thumb_opcodes): Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (thumb32_opcodes): Add DCPS instruction.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (arm_opcodes): Add SEVL.
	(thumb_opcodes): Likewise.
	(thumb32_opcodes): Likewise.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com>
	* arm-dis.c (data_barrier_option): New function.
	(print_insn_arm): Use data_barrier_option.
	(print_insn_thumb32): Use data_barrier_option.

	2012-08-24  Matthew Gretton-Dann  <matthew.gretton-dann@@arm.com
	* arm-dis.c (COND_UNCOND): New constant.
	(print_insn_coprocessor): Add support for %u format specifier.
	(print_insn_neon): Likewise.
@
text
@d10871 1
a10871 1
   "v6K", "v7", "v6-M", "v6S-M", "v7E-M", "v8"};
d10876 1
a10876 2
  {"No", "VFPv1", "VFPv2", "VFPv3", "VFPv3-D16", "VFPv4", "VFPv4-D16",
   "FP for ARMv8"};
d10879 1
a10879 1
  {"No", "NEONv1", "NEONv1 with Fused-MAC", "NEON for ARMv8"};
@


1.578.2.3
log
@	PR binutils/14779
	* configure.in: Add checks for wchar.h and mbstate_t.
	* config.in: Regenerate.
	* configure: Regenerate.
	* readelf.c: Conditionally include wchar.h.
	(print_symbol): Conditionally use mbstate_t.
@
text
@a50 1
#ifdef HAVE_WCHAR_H
a51 1
#endif
d389 1
a389 1
   multibye characters (assuming the host environment supports them).
a402 1
#ifdef HAVE_MBSTATE_T
a403 1
#endif
a419 1
#ifdef HAVE_MBSTATE_T
a421 1
#endif
d426 1
a451 3
#ifdef HAVE_MBSTATE_T
	  wchar_t w;
#endif
a456 1
#ifdef HAVE_MBSTATE_T
a460 3
#else
	  n = 1;
#endif
@


1.578.2.4
log
@	PR 12549
	PR 14493
	PR 14567
	PR 14662
	PR 14758
	PR 14813
	PR 14904
	PR 14915
	PR 14926
	PR 14950
	PR 14962
	Apply mainline patches
@
text
@a8988 2
      else if (type >= elf_header.e_shnum)
	sprintf (buff, "bad section index[%3d]", type);
@


1.577
log
@	* archive.c (bsd_write_armap): Catch attempts to create an archive
	with indicies bigger than 4Gb.
	(coff_write_armap): Likewise.

	* readelf.c (process_archive): Display member indicies when
	dumping index.
@
text
@d13445 1
a13445 1
		  file_name, arch.index_num, arch.sym_size);
d13462 3
a13464 2
		          printf (_("Binary %s at offset 0x%lx contains:\n"),
				  qualified_name, arch.index_array[i]);
d13480 5
a13484 2
          if (l & 01)
            ++l;
d13486 2
a13487 2
	    error (_("%s: symbols remain in the index symbol table, but without corresponding entries in the index table\n"),
		   file_name);
@


1.576
log
@	* readelf.c (is_16bit_abs_reloc): Handle mn10200 reloc.
@
text
@d13462 2
a13463 1
		          printf (_("Binary %s contains:\n"), qualified_name);
@


1.575
log
@	* readelf.c (process_section_headers): Correct bug in previous
	delta - display full section type in wide mode.

	* ld-tic6x/shlib-1b.rd: Revert previous delta.
	* ld-tic6x/shlib-1rb.rd: Likewise.
	* ld-tic6x/shlib-1.rd: Likewise.
	* ld-tic6x/shlib-1r.rd: Likewise.
	* ld-tic6x/shlib-app-1b.rd: Likewise.
	* ld-tic6x/shlib-app-1rb.rd: Likewise.
	* ld-tic6x/shlib-app-1.rd: Likewise.
	* ld-tic6x/shlib-app-1r.rd: Likewise.
	* ld-tic6x/shlib-noindex.rd: Likewise.
	* ld-tic6x/static-app-1b.rd: Likewise.
	* ld-tic6x/static-app-1rb.rd: Likewise.
	* ld-tic6x/static-app-1.rd: Likewise.
	* ld-tic6x/static-app-1r.rd: Likewise.
@
text
@d10096 3
@


1.574
log
@	* read.c (read_symbol_name): New function.  Reads a symbol names.
	Allows escape codes in names.
	(s_comm_internal): Use read_symbol_name.
	(s_globl, s_lsym, s_set, s_weakref): Likewise.
	* doc/as.texinfo: Document support for multibyte characters in
	symbol names.

	* gas/elf/syms.s: New test - checks the generation of multibyte
	symbol names.
	* gas/elf/syms.d: New file - expected readelf output.
	* gas/elf/elf.exp: Add syms.

	* readelf.c (print_symbol): Display multibyte characters in symbol
	names.
	(process_section_headers): Use print_symbol.

	* ld-ifunc/ifunc-13a-i386.s: Fix use of .global directive.
	* ld-ifunc/ifunc-15a-i385.s: Likewise.
@
text
@d4741 1
a4741 4
	  putchar ('\n');
	  if (is_32bit_elf || do_wide)
	    printf ("       %-15.15s ",
		    get_section_type_name (section->sh_type));
a4745 2
	  printf (" %-15.15s ",
		  get_section_type_name (section->sh_type));
d4747 4
a4750 1

@


1.573
log
@	* config/tc-m68hc11.c: Add S12X and XGATE co-processor support.
	Add option to offset S12 addresses into XGATE memory space.
	Tweak target flags to match other tools. (i.e. -m m68hc11).
	* doc/as.texinfo: Mention new options.
	* doc/c-m68hc11.texi: Document new options.
	* NEWS: Mention new support.

	* archures.c: Add bfd_arch_m9s12x and bfd_arch_m9s12xg.
	* config.bfd: Likewise.
	* cpu-m9s12x.c: New.
	* cpu-m9s12xg.c: New.
	* elf32-m68hc12.c: Add S12X and XGATE co-processor support.
	Add option to offset S12 addresses into XGATE memory space.
	Fix carry bug in IMM16 (IMM8 low/high) relocate.
	* Makefile.am (ALL_MACHINES): Add cpu-m9s12x and cpu-m9s12xg.
	(ALL_MACHINES_CFILES): Likewise.
	* reloc.c: Add S12X relocs.
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

	* gas/m68hc11/insns9s12x.s: New
	* gas/m68hc11/insns9s12x.d: New
	* gas/m68hc11/hexprefix.s: New
	* gas/m68hc11/hexprefix.d: New
	* gas/m68hc11/9s12x-exg-sex-tfr.s: New
	* gas/m68hc11/9s12x-exg-sex-tfr.d: New
	* gas/m68hc11/insns9s12xg.s: New
	* gas/m68hc11/insns9s12xg.d: New
	* gas/m68hc11/9s12x-mov.s: New
	* gas/m68hc11/9s12x-mov.d: New
	* gas/m68hc11/m68hc11.exp: Updated
	* gas/m68hc11/*.d: Brought in line with changed objdump output.
	* gas/all/gas.exp: XFAIL all hc11/12 targets for redef2,3.
	* gas/elf/elf.exp: XFAIL all hc11/12 targets for redef.
	* gas/elf/dwarf2-1.d: Skip for hc11/12 targets.
	* gas/elf/dwarf2-2.d: Likewise.

	* ld-m68hc11/xgate-link.s: New.
	* ld-m68hc11/xgate-link.d: New.
	* ld-m68hc11/xgate-offset.s: New.
	* ld-m68hc11/xgate-offset.d: New.
	* ld-m68hc11/xgate1.s: New.
	* ld-m68hc11/xgate1.d: New.
	* ld-m68hc11/xgate2.s: New.
	* ld-m68hc11/m68hc11.exp: Updated.
	* ld-m68hc11/*.d: Brought in line with changed objdump output.
	* ld-gc/gc.exp: Update CFLAGS for m68hc11.
	* ld-plugin/plugin.exp: Likewise.
	* ld-srec/srec.exp: XFAIL for m68hc11 and m68hc12.

	* configure.in: Add S12X and XGATE co-processor support to m68hc11
	target.
	* disassemble.c: Likewise.
	* configure: Regenerate.
	* m68hc11-dis.c: Make objdump output more consistent, use hex
	instead of decimal and use 0x prefix for hex.
	* m68hc11-opc.c: Add S12X and XGATE opcodes.
	* dis-asm.h (print_insn_m9s12x): Prototype.
	(print_insn_m9s12xg): Prototype.

	* m68hc11.h (R_M68HC12_16B, R_M68HC12_PCREL_9, R_M68HC12_PCREL_10)
	R_M68HC12_HI8XG, R_M68HC12_LO8XG): New relocations.
	(E_M68HC11_XGATE_RAMOFFSET): Define.

	* m68hc11.h: Add XGate definitions.
	(struct m68hc11_opcode): Add xg_mask field.
@
text
@d51 1
d387 2
a388 1
/* Display a symbol on stdout.  Handles the display of non-printing characters.
d390 4
a393 3
   If DO_WIDE is not true then format the symbol to be at most WIDTH characters,
   truncating as necessary.  If WIDTH is negative then format the string to be
   exactly - WIDTH characters, truncating or padding as necessary.
a399 1
  const char *c;
d401 3
a403 1
  unsigned int num_printed = 0;
d405 1
a405 7
  if (do_wide)
    {
      /* Set the width to a very large value.  This simplifies the
	 code below.  */
      width = INT_MAX;
    }
  else if (width < 0)
d410 1
a410 1
    }
d412 6
a417 3
  while (width)
    {
      int len;
d419 2
a420 1
      c = symbol;
d422 5
a426 12
      /* Look for non-printing symbols inside the symbol's name.
	 This test is triggered in particular by the names generated
	 by the assembler for local labels.  */
      while (ISPRINT (*c))
	c++;

      len = c - symbol;

      if (len)
	{
	  if (len > width)
	    len = width;
d428 1
a428 7
	  printf ("%.*s", len, symbol);

	  width -= len;
	  num_printed += len;
	}

      if (*c == 0 || width == 0)
d431 4
a434 3
      /* Now display the non-printing character, if
	 there is room left in which to dipslay it.  */
      if ((unsigned char) *c < 32)
d436 1
a436 1
	  if (width < 2)
d439 2
a440 3
	  printf ("^%c", *c + 0x40);

	  width -= 2;
d443 6
d451 4
a454 4
	  if (width < 6)
	    break;

	  printf ("<0x%.2x>", (unsigned char) *c);
d456 6
a461 2
	  width -= 6;
	  num_printed += 6;
a462 2

      symbol = c + 1;
d465 1
a465 1
  if (extra_padding && width > 0)
d468 2
a469 2
      printf ("%-*s", width, " ");
      num_printed += 2;
d4737 1
d4740 2
a4741 3
	  printf ("  [%2u] %s\n",
		  i,
		  SECTION_NAME (section));
d4747 5
a4751 5
	printf ((do_wide ? "  [%2u] %-17s %-15s "
			 : "  [%2u] %-17.17s %-15.15s "),
		i,
		SECTION_NAME (section),
		get_section_type_name (section->sh_type));
@


1.572
log
@	* doc/binutils.texi: Add --dwarf-check option.
	* dwarf.c (dwarf_check): New global flag.
	(fetch_indexed_string): New function.
	(fetch_indexed_value): New function.
	(get_FORM_name): Add DW_FORM_GNU_str_index and DW_FORM_GNU_addr_index.
	(decode_location_expression): Add DW_OP_GNU_addr_index.
	(read_and_display_attr_value): Add DW_FORM_GNU_str_index,
	DW_FORM_GNU_addr_index, DW_AT_GNU_addr_base, and DW_AT_GNU_ranges_base.
	(get_AT_name): Add new attributes for Fission.
	(process_debug_info): Load new debug sections for Fission.
	(load_debug_info): Check for .debug_info.dwo section.
	(display_loc_list, display_loc_list_dwo): New functions.
	(display_debug_loc): Move logic to above two functions.
	(display_debug_info): Choose abbrev section based on info section.
	(display_debug_types): Likewise.
	(display_trace_info): Likewise.
	(comp_addr_base): New function.
	(display_debug_addr): New function.
	(display_debug_str_offsets): New function.
	(display_debug_ranges): Allow missing range lists.  Suppress
	diagnostics if dwarf_check not set.
	(debug_displays): Add column to select abbrev section.
	* dwarf.h (enum dwarf_section_display_enum): Add new debug sections
	for Fission.
	(struct dwarf_section): Add abbrev_sec field.
	(struct dwarf_section_display): New type.
	(debug_info): Add addr_base, ranges_base fields.
	(dwarf_check): New global variable.
	* objdump.c (usage): Add --dwarf-check option.
	(enum option_values): Add OPTION_DWARF_CHECK.
	(long_options): Add --dwarf-check.
	(main): Likewise.
	* readelf.c (OPTION_DWARF_CHECK): New macro.
	(options): Add --dwarf-check.
	(parse_args): Likewise.
	(process_section_headers): Use const_strneq instead of
	streq.
@
text
@a1870 1
    case EM_68HC12:		return "Motorola M68HC12";
d1905 1
@


1.571
log
@Always display addend as signed hex number

binutils/

	PR binutils/14088
	* readelf.c (dump_relocations): Always display addend as
	signed hex number.

ld/testsuite/

	PR binutils/14088
	* ld-ia64/tlspic.rd: Updated.
	* ld-x86-64/tlsdesc-nacl.rd: Likewise.
	* ld-x86-64/tlsdesc.rd: Likewise.
	* ld-x86-64/tlspic-nacl.rd: Likewise.
	* ld-x86-64/tlspic.rd: Likewise.
@
text
@d3131 1
d3167 1
d3436 3
d4647 13
a4659 13
	      || (do_debug_info     && streq (name, "info"))
	      || (do_debug_info     && streq (name, "types"))
	      || (do_debug_abbrevs  && streq (name, "abbrev"))
	      || (do_debug_lines    && streq (name, "line"))
	      || (do_debug_pubnames && streq (name, "pubnames"))
	      || (do_debug_pubtypes && streq (name, "pubtypes"))
	      || (do_debug_aranges  && streq (name, "aranges"))
	      || (do_debug_ranges   && streq (name, "ranges"))
	      || (do_debug_frames   && streq (name, "frame"))
	      || (do_debug_macinfo  && streq (name, "macinfo"))
	      || (do_debug_macinfo  && streq (name, "macro"))
	      || (do_debug_str      && streq (name, "str"))
	      || (do_debug_loc      && streq (name, "loc"))
@


1.570
log
@Add support for Motorola XGATE embedded CPU
@
text
@d1390 7
a1396 3
	  printf ("%*c", is_32bit_elf ?
		  (do_wide ? 34 : 28) : (do_wide ? 26 : 20), ' ');
	  print_vma (rels[i].r_addend, LONG_HEX);
@


1.569
log
@	* mn10300.h (elf_mn10300_reloc_type): Add R_MN10300_TLS_GD,
	R_MN10300_TLS_LD, R_MN10300_TLS_LDO, R_MN10300_TLS_GOTIE,
	R_MN10300_TLS_IE, R_MN10300_TLS_LE, R_MN10300_TLS_DPTMOD,
	R_MN10300_TLS_DTPOFF and R_MN10300_TLS_TPOFF.

	* elf-m10300.c (elf32_mn10300_link_hash_entry): Add tls_type
	field.
	(elf32_mn10300_link_hash_table): Add tls_ldm_got entry;
	(elf_mn10300_tdata): Define.
	(elf_mn10300_local_got_tls_type): Define.
	(elf_mn10300_howto_table): Add entries for R_MN10300_TLS_GD,
	R_MN10300_TLS_LD, R_MN10300_TLS_LDO, R_MN10300_TLS_GOTIE,
	R_MN10300_TLS_IE, R_MN10300_TLS_LE, R_MN10300_TLS_DPTMOD,
	R_MN10300_TLS_DTPOFF, R_MN10300_TLS_TPOFF relocs.
	(mn10300_reloc_map): Likewise.
	(elf_mn10300_tls_transition): New function.
	(dtpoff, tpoff, mn10300_do_tls_transition): New functions.
	(mn10300_elf_check_relocs): Add TLS support.
	(mn10300_elf_final_link_relocate): Likewise.
	(mn10300_elf_relocate_section): Likewise.
	(mn10300_elf_relax_section): Likewise.
	(elf32_mn10300_link_hash_newfunc): Initialise new field.
	(_bfd_mn10300_copy_indirect_symbol): New function.
	(elf32_mn10300_link_hash_table_create): Initialise new fields.
	(_bfd_mn10300_elf_size_dynamic_sections): Add TLS support.
	(_bfd_mn10300_elf_finish_dynamic_symbol): Likewise.
	(_bfd_mn10300_elf_reloc_type_class): Allocate an
	elf_mn10300_obj_tdata structure.
	(elf_backend_copy_indirect_symbol): Define.
	* reloc.c (BFD_MN10300_TLS_GD, BFD_MN10300_TLS_LD,
	BFD_MN10300_TLS_LDO, BFD_MN10300_TLS_GOTIE, BFD_MN10300_TLS_IE,
	BFD_MN10300_TLS_LE, BFD_MN10300_TLS_DPTMOD,
	BFD_MN10300_TLS_DTPOFF, BFD_MN10300_TLS_TPOFF): New relocations.
	(BFD_RELOC_MN10300_32_PCREL, BFD_RELOC_MN10300_16_PCREL): Move to
	alongside other MN10300 relocations.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

	* config/tc-mn10300.c (other_registers): Add SSP and USP.
	(md_assemble): Add support for TLS relocs.
	(mn10300_parse_name): Likewise.

	* readelf.c (is_16bit_abs_reloc): Add detection of R_MN10300_16.
@
text
@d149 1
d551 1
a563 1
    case EM_CR16_OLD:
a1213 1
	case EM_CR16_OLD:
d1246 4
d1876 1
a1876 1
    case EM_V850:		return "Renesas v850";
d1986 1
a1986 2
    case EM_CR16_OLD:		return "National Semiconductor's CR16";
    case EM_MICROBLAZE:		return "Xilinx MicroBlaze";
d2001 1
a9784 1
    case EM_CR16_OLD:
d9896 2
d10095 2
@


1.568
log
@	* sysdep.h: Include sys/stat.h here.
	* ar.c: Don't include headers already included by sysdep.h.
	* bucomm.c: Likewise.
	* budbg.h: Likewise.
	* dlltool.h: Likewise.
	* elfedit.c: Likewise.
	* nlmconv.c: Likewise.
	* objcopy.c: Likewise.
	* objdump.c: Likewise.
	* objdump.h: Likewise.
	* readelf.c: Likewise.
	* rename.c: Likewise.
	* resrc.c: Likewise.
	* strings.c: Likewise.
	* windres.c: Likewise.
	* od-macho.c: Ensure #include sysdep.h is first.
	* od-xcoff.c: Likewise.
	* dllwrap.c: Remove alloca pragma handled by sysdep.h, and
	remove duplicate headers.
	* dlltool.c: Likewise and ensure #include sysdep.h is first.
@
text
@d10087 3
@


1.567
log
@	PR binutils/13482
	* readelf.c (process_corefile_note_segment): Fix off-by-one errors
	verifying the contents of a note.

	* binutils-all/version.s: New test source file.
	* binutils-all/readelf.n: New file: expected readelf output.
	* binutils-all/readelf.exp: Add test of .note section contents.
@
text
@a44 1
#include "config.h"
a46 1
#include <sys/stat.h>
@


1.566
log
@	PR binutils/13622
	* readelf.c (process_section_groups): If there are no section
	headers do not scan for section groups.
	(process_note_sections): Likewise for note sections.
@
text
@d3 1
a3 1
   2008, 2009, 2010, 2011
d12997 1
a12997 1
      if (inote.namedata + inote.namesz >= (char *) pnotes + length
d13011 1
a13011 1
      if (inote.namedata[inote.namesz] != '\0')
@


1.565
log
@	* readelf.c (get_symbol_type): Add ELFOSABI_FREEBSD to the
	supported abi's.

	* config/obj-elf.c (obj_elf_type): Add ELFOSABI_FREEBSD to the
	supported abi's.
@
text
@d4964 2
a4965 1
      abort ();
d13074 1
a13074 1
       i < elf_header.e_shnum;
@


1.564
log
@2011-12-06 David Daney <david.daney@@cavium.com>

	* readelf.c (dynamic_section_mips_val): Factor out trailing '\n'
	from printed strings and move it to the end of the function.
	Use BFD_VMA_FMT for printf format specifier for dynamic tag value.
	Use print_vma() to print dynamic tag values.
@
text
@d6981 1
a6981 1
	warn (_("Corrupt ARM compact model table entry (%08x)\n"), word);
d7074 6
d8759 1
@


1.563
log
@	* readelf.c (ia64_process_unwind): Turn into a void funtion.
	(hppa_process_unwind): Likewise.
	(arm_process_unwind): Likewise.
	(process_unwind): Likewise.
	(arm_get_section_word): Rename to get_unwind_section_word.
	Add sym_name parameter to return the offset into the string table
	of the symbol associated with the reloc applied to the word.
	(decode_tic6x_unwind_regmask): Add NULL argument to invocation of
	get_unwind_section_word.
	(dump_arm_unwind): Likewise.
	(decode_arm_unwind_bytecode): Prepend a comma when *not* the first
	register in a list.
	(decode_arm_unwind): If the returned function address is 0 and a
	valid symname offset is provided use that to compute the name
	associated with the entry.
	Add extra checks of the compact model index entry.
@
text
@d7237 1
a7237 1
	printf (_("NONE\n"));
a7256 1
	  puts ("");
d7262 1
a7262 1
	printf (_("Interface Version: %s\n"), GET_DYNAMIC_NAME (entry->d_un.d_val));
d7264 1
a7264 1
	printf (_("<corrupt: %ld>\n"), (long) entry->d_un.d_ptr);
d7277 1
a7277 1
	printf (_("Time Stamp: %s\n"), timebuf);
d7294 1
a7294 1
      printf ("%ld\n", (long) entry->d_un.d_ptr);
d7298 1
a7298 1
      printf ("%#lx\n", (unsigned long) entry->d_un.d_ptr);
d7300 1
@


1.562
log
@	PR binutils/13421
	* readelf.c (arm_section_get_word): Add descriptive comments.
	Initliase the rel_type field of the arm_sec structure.
	(expand_prel31): Rename to arm_expand_prel31.
	(dump_arm_unwind): Use new name.
	Print the function name based on the function address entry.
@
text
@d3190 1
a3190 1
  -A --arch-specific     Display architecture specific information (if any).\n\
d5598 1
d5606 1
d5784 1
a5784 1
static int
a5920 2

  return 1;
d6192 1
a6192 1
static int
d6201 3
a6205 3
  if (string_table == NULL)
    return 1;

a6251 2

  return 1;
d6316 1
a6316 1
   3) Update the NEXT_RELA field in ARM_SEC and stores the section index and
d6318 4
a6321 1
   4) Return TRUE upon success, FALSE otherwise.  */
d6324 7
a6330 6
arm_section_get_word (struct arm_unw_aux_info *  aux,
		      struct arm_section *       arm_sec,
		      Elf_Internal_Shdr *        sec,
		      bfd_vma 			 word_offset,
		      unsigned int *             wordp,
		      struct absaddr *           addr)
d6341 3
d6473 2
d6511 2
a6512 2
      if (!arm_section_get_word (aux, data_arm_sec, data_sec,	\
				 data_offset, &word, &addr))	\
d6616 1
a6616 1
	      if (first)
d6893 6
a6898 4
decode_arm_unwind (struct arm_unw_aux_info *aux,
		   unsigned int word, unsigned int remaining,
		   bfd_vma data_offset, Elf_Internal_Shdr *data_sec,
		   struct arm_section *data_arm_sec)
d6903 1
d6907 7
a6913 3
      /* Fetch the first word.  */
      if (!arm_section_get_word (aux, data_arm_sec, data_sec, data_offset,
				 &word, &addr))
d6915 1
d6927 15
a6941 1
      procname = arm_print_vma_and_name (aux, fn, addr);
d6971 12
a6982 1
      
d6984 1
a6984 1
      printf (_("  Compact model %d\n"), per_index);
d7008 4
a7011 1
	printf ("  [reserved]\n");
d7018 1
a7018 1
				      data_offset, data_sec, data_arm_sec);
d7035 1
a7035 1
	printf ("  [reserved]\n");
d7039 2
a7040 1
      abort ();
d7064 4
a7067 4
      if (!arm_section_get_word (aux, &exidx_arm_sec, exidx_sec,
				 8 * i, &exidx_fn, &fn_addr)
	  || !arm_section_get_word (aux, &exidx_arm_sec, exidx_sec,
				    8 * i + 4, &exidx_entry, &entry_addr))
d7069 2
a7070 2
	  arm_free_section (&exidx_arm_sec);
	  arm_free_section (&extab_arm_sec);
d7131 2
a7132 1
static int
a7141 3
  memset (& aux, 0, sizeof (aux));
  aux.file = file;

d7152 4
a7155 2
    default:
	abort();
d7159 4
a7162 1
    return 1;
d7180 1
a7180 1
  if (!unwsec)
d7182 9
d7192 3
a7194 12
  for (i = 0, sec = section_headers; i < elf_header.e_shnum; ++i, ++sec)
    {
      if (sec->sh_type == sec_type)
	{
	  printf (_("\nUnwind table index '%s' at offset 0x%lx contains %lu entries:\n"),
		  SECTION_NAME (sec),
		  (unsigned long) sec->sh_offset,
		  (unsigned long) (sec->sh_size / (2 * eh_addr_size)));

	  dump_arm_unwind (&aux, sec);
	}
    }
a7199 2

  return 1;
d7202 1
a7202 1
static int
d7208 1
a7208 1
    int (* handler)(FILE *);
d7220 1
a7220 1
    return 1;
d7226 2
a7227 2
  printf (_("\nThere are no unwind sections in this file.\n"));
  return 1;
@


1.561
log
@* binutils/readelf.c (process_program_headers): Fix typo printing p_memsz
field.
@
text
@d6258 6
a6263 8
  unsigned char *data;

  Elf_Internal_Shdr *sec;
  Elf_Internal_Rela *rela;
  unsigned long nrelas;
  unsigned int rel_type;

  Elf_Internal_Rela *next_rela;
d6268 5
a6272 6
  FILE *file;

  Elf_Internal_Sym *symtab;	/* The symbol table.  */
  unsigned long nsyms;		/* Number of symbols.  */
  char *strtab;			/* The string table.  */
  unsigned long strtab_size;	/* Size of string table.  */
d6314 15
a6328 5
static int
arm_section_get_word (struct arm_unw_aux_info *aux,
		      struct arm_section *arm_sec,
		      Elf_Internal_Shdr *sec, bfd_vma word_offset,
		      unsigned int *wordp, struct absaddr *addr)
d6339 1
d6360 1
d6366 1
a6366 1
		return 0;
d6374 1
a6374 1
		return 0;
d6377 3
d6385 1
d6387 1
a6387 1
    return 0;
d6389 1
d6392 1
a6415 25
      switch (elf_header.e_machine)
	{
	case EM_ARM:
	  relname = elf_arm_reloc_type (ELF32_R_TYPE (rp->r_info));
	  break;

	case EM_TI_C6000:
	  relname = elf_tic6x_reloc_type (ELF32_R_TYPE (rp->r_info));
	  break;

	default:
	    abort();
	}

      if (streq (relname, "R_ARM_NONE")
	  || streq (relname, "R_C6000_NONE"))
	continue;

      if (!(streq (relname, "R_ARM_PREL31")
	    || streq (relname, "R_C6000_PREL31")))
	{
	  warn (_("Skipping unexpected relocation type %s\n"), relname);
	  continue;
	}

d6424 2
d6427 1
a6427 1
	offset = rp->r_addend;
d6432 32
a6463 2
      if (streq (relname, "R_C6000_PREL31"))
	prelval >>= 1;
d6474 1
a6474 1
  return 1;
d6477 6
a6482 4
static const char *tic6x_unwind_regnames[16] = {
    "A15", "B15", "B14", "B13", "B12", "B11", "B10", "B3", 
    "A14", "A13", "A12", "A11", "A10", 
    "[invalid reg 13]", "[invalid reg 14]", "[invalid reg 15]"};
d6784 2
a6785 1
	  struct {
d6842 1
d6871 1
a6871 1
expand_prel31 (bfd_vma word, bfd_vma where)
d6910 1
a6910 1
      fn = expand_prel31 (word, data_sec->sh_addr + data_offset);
d7030 1
a7030 1
      fn = expand_prel31 (exidx_fn, exidx_sec->sh_addr + 8 * i);
d7032 1
a7032 1
      arm_print_vma_and_name (aux, fn, entry_addr);
d7052 1
a7052 1
	  table = expand_prel31 (exidx_entry, exidx_sec->sh_addr + 8 * i + 4);
@


1.560
log
@[.]
	* configure.ac (rl78-*-*) New case.
	* configure: Regenerate.

[bfd]
	* Makefile.am (ALL_MACHINES): Add cpu-rl78.lo.
	(ALL_MACHINES_CFILES): Add cpu-rl78.c.
	(BFD32_BACKENDS): Add elf32-rl78.lo.
	(BFD32_BACKENDS_CFILES): Add elf32-rl78.c.
	(Makefile.in): Regenerate.
	* archures.c (bfd_architecture): Define bfd_arch_rl78.
	(bfd_archures_list): Add bfd_rl78_arch.
	* config.bfd: Add rl78-*-elf.
	* configure.in: Add bfd_elf32_rl78_vec.
	* reloc.c (bfd_reloc_code_type): Add BFD_RELOC_RL78_* relocations.
	* targets.c (bfd_target_vector): Add bfd_elf32_rl78_vec.
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* configure: Regenerate.
	* libbfd.h: Regenerate.
	* cpu-rl78.c: New file.
	* elf32-rl78.c: New file.

[binutils]
	* readelf.c: Include elf/rl78.h
	(guess_is_rela): Handle EM_RL78.
	(dump_relocations): Likewise.
	(get_machine_name): Likewise.
	(is_32bit_abs_reloc): Likewise.
	* NEWS: Mention addition of RL78 support.
	* MAINTAINERS: Add myself as RL78 port maintainer.

[gas]
	* Makefile.am (TARGET_CPU_CFILES): Add tc-rl78.c.
	(TARGET_CPU_HFILES): Add rc-rl78.h.
	(EXTRA_DIST): Add rl78-parse.c and rl78-parse.y.
	(rl78-parse.c, rl78-parse.h, rl78-parse.o, rl78-defs.h): New rules.
	* Makefile.in: Regenerate.
	* configure.in: Add rl78 case.
	* configure: Regenerate.
	* configure.tgt: Add rl78 case.
	* config/rl78-defs.h: New file.
	* config/rl78-parse.y: New file.
	* config/tc-rl78.c: New file.
	* config/tc-rl78.h: New file.
	* NEWS: Add Renesas RL78.

	* doc/Makefile.am (c-rl78.texi): New.
	* doc/Makefile.in: Likewise.
	* doc/all.texi: Enable it.
	* doc/as.texi: Add it.

[include]
	* dis-asm.h (print_insn_rl78): Declare.

[include/elf]
	* common.h (EM_RL78, EM_78K0R): New.
	* rl78.h: New.

[include/opcode]
	* rl78.h: New file.

[ld]
	* Makefile.am (ALL_EMULATION_SOURCES): Add eelf32rl78.c.
	(+eelf32rl78.c): New rule.
	* Makefile.in: Regenerate.
	* configure.tgt: Add rl78-*-* case.
	* emulparams/elf32rl78.sh: New file.
	* NEWS: Mention addition of Renesas RL78 support.

[opcodes]
	* Makefile.am (TARGET_LIBOPCODES_CFILES): Add rl78-decode.c and
	rl78-dis.c.
	(MAINTAINERCLEANFILES): Add rl78-decode.c.
	(rl78-decode.c): New rule, built from rl78-decode.opc and opc2c.
	* Makefile.in: Regenerate.
	* configure.in: Add bfd_rl78_arch case.
	* configure: Regenerate.
	* disassemble.c: Define ARCH_rl78.
	(disassembler): Add ARCH_rl78 case.
	* rl78-decode.c: New file.
	* rl78-decode.opc: New file.
	* rl78-dis.c: New file.
@
text
@d3812 1
a3812 1
		  print_vma (segment->p_offset, FULL_HEX);
@


1.559
log
@bfd:
	* Makefile.am (ALL_MACHINES): Add cpu-epiphany.lo .
	(ALL_MACHINES_CFILES): Add cpu-epiphany.c .
	(BFD32_BACKENDS): Add elf32-epiphany.lo .
	(BFD32_BACKENDS_CFILES): Add elf32-epiphany.c .
	* Makefile.in, bfd-in2.h, configure, libbfd.h: Regenerate.
	* archures.c (bfd_arch_epiphany): Add.
	(bfd_mach_epiphany16, bfd_mach_epiphany32): Define.
	(bfd_epiphany_arch): Declare.
	(bfd_archures_list): Add &bfd_epiphany_arch.
	* config.bfd (epiphany-*-elf): New target case.
	* configure.in (bfd_elf32_epiphany_vec): New target vector case.
	* reloc.c (BFD_RELOC_EPIPHANY_SIMM8): New relocation.
	(BFD_RELOC_EPIPHANY_SIMM24, BFD_RELOC_EPIPHANY_HIGH): Likewise.
	(BFD_RELOC_EPIPHANY_LOW, BFD_RELOC_EPIPHANY_SIMM11): Likewise.
	(BFD_RELOC_EPIPHANY_IMM11, BFD_RELOC_EPIPHANY_IMM8): Likewise.
	* targets.c (bfd_elf32_epiphany_vec): Declare.
	(_bfd_target_vector): Add bfd_elf32_epiphany_vec.
	* po/SRC-POTFILES.in, po/bfd.pot: Regenerate.
	* cpu-epiphany.c, elf32-epiphany.c: New files.
binutils:
	* readelf.c (include "elf/epiphany.h")
	(guess_is_rela, dump_relocation): Handle EM_ADAPTEVA_EPIPHANY.
	(get_machine_name, is_32bit_abs_reloc, is_32bit_pcrel_reloc): Likewise.
	(is_16bit_abs_reloc, is_none_reloc): Likewise.
	* po/binutils.pot: Regenerate.
cpu:
	* cpu/epiphany.cpu, cpu/epiphany.opc: New files.
gas:
	* NEWS: Mention addition of Adapteva Epiphany support.
	* config/tc-epiphany.c, config/tc-epiphany.h: New files.
	* Makefile.am (TARGET_CPU_CFILES): Add config/tc-epiphany.c .
	(TARGET_CPU_HFILES): Add config/tc-epiphany.h .
	* Makefile.in, configure, doc/Makefile.in, po/POTFILES.in: Regenerate.
	* configure.in: Also set using_cgen for epiphany.
	* configure.tgt: Handle epiphany.
	* doc/Makefile.am (CPU_DOCS): Add c-epiphany.texi .
	* doc/all.texi: Set EPIPHANY.
	* doc/as.texinfo: Add EPIPHANY-specific text.
	* doc/c-epiphany.texi: New file.
	* po/gas.pot: Regenerate.
gas/testsuite:
	* gas/epiphany: New directory.
include:
	* dis-asm.h (print_insn_epiphany): Declare.
	* elf/epiphany.h: New file.
	* elf/common.h (EM_ADAPTEVA_EPIPHANY): Define.
ld:
	* NEWS: Mention addition of Adapteva Epiphany support.
	* Makefile.am (ALL_EMULATION_SOURCES): Add eelf32epiphany.c .
	(eelf32epiphany.c): New rule.
	* Makefile.in: Regenerate.
	* configure.tgt: Handle epiphany-*-elf.
	* po/ld.pot: Regenerate.
	* testsuite/ld-srec/srec.exp: xfail epiphany.
	* emulparams/elf32epiphany.sh: New file.
opcodes:
	* Makefile.am (HFILES): Add epiphany-desc.h and epiphany-opc.h .
	(TARGET_LIBOPCODES_CFILES): Add  epiphany-asm.c, epiphany-desc.c,
	epiphany-dis.c, epiphany-ibld.c and epiphany-opc.c .
	(CLEANFILES): Add stamp-epiphany.
	(EPIPHANY_DEPS): Set.  Make CGEN-generated Epiphany files depend on it.
	(stamp-epiphany): New rule.
	* Makefile.in, configure, po/POTFILES.in, po/opcodes.pot: Regenerate.
	* configure.in: Handle bfd_epiphany_arch.
	* disassemble.c (ARCH_epiphany): Define.
	(disassembler): Handle bfd_arch_epiphany.
	* epiphany-asm.c, epiphany-desc.c, epiphany-desc.h: New files.
	* epiphany-dis.c, epiphany-ibld.c, epiphany-opc.c: Likewise.
	* epiphany-opc.h: Likewise.
@
text
@d137 1
d597 1
d1224 4
d1987 1
d9778 2
@


1.558
log
@2011-10-13  Nick Clifton  <nickc@@redhat.com>

	Fixes to aid translation:
	* addr2line.c (translate_address): Add comments describing context
	of a couple of printf statements.
	* ar.c (write_archive): Allow translation of error message.
	* bucomm.c (endian_string): Allow translation of strings.
	(display_target_list): Allow translation.
	* coffdump.c (dump_coff_type): Allow translation of output.
	(dump_coff_where): Likewise.
	(dump_coff_symbol): Likewise.
	(dump_coff_scope): Likewise.
	(dump_coff_sfile): Likewise.
	(dump_coff_section): Likewise.
	(coff_dump): Likewise.
	* dlltool (def_version): Allow translation of output.
	(run): Likewise.
	* dllwrap.c (run): Allow translation of output.
	* dwarf.c (print_dwarf_vma): Allow translation of output.
	(process_extended_line_op): Remove spurious translation.
	Add translation for strings that can be translated.
	(decode_location_exression): Allow translation of output.
	(read_and_display_attr_value): Allow translation of output.
	* readelf.c (slurp_rela_relocs): Add translation for error
	messages when failing to get data.
	(slurp_rel_relocs): Likewise.
	(get_32bit_elf_symbols): Likewise.
	(get_64bit_elf_symbols): Likewise.
	(dump_ia64_vms_dynamic_relocs): Replace abbreviation with full
	word.
	(process_relocs): Remove spurious translation.
	(decode_tic6x_unwind_bytecode): Likewise.
	(process_version_section): Improve error messages.
	(process_mips_specific): Likewise.
	(print_gnu_note): Remove spurious translation.
	(print_stapsdt_note): Likewise.
	(get_ia64_vms_note_type): Likewise.
	* sysdump.c (getCHARS): Allow translation.
	(fillup): Allow translation of output.
	(getone): Likewise.
	(must): Likewise.
	(derived_type): Likewise.
	* doc/binutils.doc (addr2line): Extend description of command line
	options.
	* po/binutils.pot: Regenerate.
@
text
@d106 1
d556 1
d1173 4
d1920 1
d9690 2
d9832 2
d9975 2
d10022 1
@


1.557
log
@	PR binutils/13219
	* readelf.c (GET_ELF_SYMBOLS): Add sym_count parameter.
	(get_32bit_elf_symbols): Add num_syms_return argument.
	Return the number of symbols loaded into the symbol table.
	(get_64bit_elf_symbols): Likewise.
	(process_section_headers): Use GET_ELF_SYMBOLS to initialise
	symbol count.
	(proces_relocs): Likewise.
	(ia64_process_unwind): Likewise.
	(hppa_process_unwind): Likewise.
	(arm_process_unwind): Likewise.
	(process_dynamic_section): Likewise.
	(process_version_sections): Likewise.
	(process_symbol_table): Likewise.
	(process_section_groups): Likewise.
	Add check before indexing into the symbol table.
	(apply_relocations): Likewise.
@
text
@d657 1
a657 1
                                                 rel_size, _("relocs"));
d687 1
a687 1
                                                 rel_size, _("relocs"));
d755 1
a755 1
                                               rel_size, _("relocs"));
d784 1
a784 1
                                               rel_size, _("relocs"));
d4092 1
a4092 1
                                                   _("symtab shndx"));
d4171 1
a4171 1
                                                   _("symtab shndx"));
d5245 1
a5245 1
		   _("dynamic section image relas"));
d5451 1
a5451 1
		printf (_("'%s'"), SECTION_NAME (section));
d6716 1
a6716 1
      printf (_("  0x%02x "), op);
d6721 1
a6721 1
	  printf (_("     sp = sp + %d"), offset);
d8248 1
a8248 1
                                                       _("version need section"));
d8325 1
d8327 1
a8327 1
		  printf (_("  Version need aux past end of section\n"));
d8331 1
d8333 1
a8333 1
	      printf (_("  Version need past end of section\n"));
d11796 1
a11796 1
                                              _("liblist"));
d12152 2
a12153 1
                                         global_end - pltgot, 1, _("GOT"));
d12197 2
a12198 1
		  addr_size * 2, _("Address"), _("Access"),
d12200 5
a12204 1
		  addr_size * 2, _("Sym.Val."), _("Type"), _("Ndx"), _("Name"));
d12257 1
a12257 1
                                         1, _("PLT GOT"));
d12261 1
a12261 1
      printf (_("\nPLT GOT:\n\n"));
d12330 1
a12330 1
                        _("liblist"));
d12498 1
a12498 1
	printf (_("\n"));
d12600 1
a12600 1
  snprintf (buff, sizeof (buff), _("PT_FIRSTMACH+%d"),
d12654 1
a12654 1
  printf (_("\n"));
d12674 1
a12674 1
      return _("NT_VMS_TITLE");
d12680 1
a12680 1
      return _("NT_VMS_LINKTIME");
d12692 1
a12692 1
      return _("NT_VMS_ORIG_DYN");
d12694 1
a12694 1
      return _("NT_VMS_PATCHTIME");
d12723 1
a12723 1
      printf (_("   FP mode: "));
d12743 1
a12743 1
      printf (_("   Manip date  : "));
d12746 1
a12746 2
      printf (_("\n"
                "   Link flags  : "));
@


1.556
log
@
	* readelf.c (get_machine_dlags): Add support for RX's PID mode.

	* ld-scripts/phdrs.exp: Expect to fail for the RX.

	* elf32-rx.c: Add support for PID mode.
	(rx_elf_relocate_section): Add checks for unsafe PID relocations.
	Include addend in R_RX_SYM relocations.

	* config/rx-defs.h (rx_pid_register): New.
	(rx_gp_register): New.
	* config/rx-parse.y (rx_lex): Add support for %gpreg and %pidreg.
	(displacement): Add PID support.
	* config/tc-rx.c (rx_pid_mode): New.
	(rx_num_int_regs): New.
	(rx_pid_register): New.
	(rx_gp_register): New.
	(options): Add -mpid and -mint-register= options.
	(md_longopts): Likewise.
	(md_parse_option): Likewise.
	(md_show_usage): Likewise.
	(rx_pid_symbol): New.
	(rx_pidreg_symbol): New.
	(rx_gpreg_symbol): New.
	(md_begin): Support PID.
	(rx_validate_fix_sub): Support PID.
	(tc_gen_reloc): Support PID.
	* doc/c-rx.texi: Document PID support.

	* rx.h (E_FLAG_RX_PID): New.
@
text
@d274 3
a276 3
#define GET_ELF_SYMBOLS(file, section)			\
  (is_32bit_elf ? get_32bit_elf_symbols (file, section)	\
   : get_64bit_elf_symbols (file, section))
d4053 3
a4055 1
get_32bit_elf_symbols (FILE * file, Elf_Internal_Shdr * section)
d4057 1
a4057 1
  unsigned long number;
d4059 1
a4059 1
  Elf_External_Sym_Shndx * shndx;
d4068 1
a4068 1
      return NULL;
d4076 1
a4076 1
      return NULL;
d4082 1
a4082 1
    return NULL;
d4121 1
a4121 1
  if (shndx)
d4123 1
a4123 1
  if (esyms)
d4126 3
d4133 8
a4140 6
get_64bit_elf_symbols (FILE * file, Elf_Internal_Shdr * section)
{
  unsigned long number;
  Elf64_External_Sym * esyms;
  Elf_External_Sym_Shndx * shndx;
  Elf_Internal_Sym * isyms;
d4148 1
a4148 1
      return NULL;
d4156 1
a4156 1
      return NULL;
d4162 1
a4162 1
    return NULL;
a4163 1
  shndx = NULL;
d4172 2
a4173 5
      if (!shndx)
	{
	  free (esyms);
	  return NULL;
	}
d4181 1
a4181 4
      if (shndx)
	free (shndx);
      free (esyms);
      return NULL;
d4184 1
a4184 3
  for (j = 0, psym = isyms;
       j < number;
       j++, psym++)
d4190 1
d4196 1
d4201 2
a4202 1
  if (shndx)
d4204 5
a4208 1
  free (esyms);
d4576 1
a4576 2
	  num_dynamic_syms = section->sh_size / section->sh_entsize;
	  dynamic_symbols = GET_ELF_SYMBOLS (file, section);
d4931 1
d4989 1
d5020 1
a5020 1
	      symtab = GET_ELF_SYMBOLS (file, symtab_sec);
d5029 6
d5472 1
a5472 2
		  nsyms = symsec->sh_size / symsec->sh_entsize;
		  symtab = GET_ELF_SYMBOLS (file, symsec);
d5784 1
a5784 2
	  aux.nsyms = sec->sh_size / sec->sh_entsize;
	  aux.symtab = GET_ELF_SYMBOLS (file, sec);
d6197 1
a6197 2
	  aux.nsyms = sec->sh_size / sec->sh_entsize;
	  aux.symtab = GET_ELF_SYMBOLS (file, sec);
d7081 1
a7081 2
	  aux.nsyms = sec->sh_size / sec->sh_entsize;
	  aux.symtab = GET_ELF_SYMBOLS (file, sec);
d7542 1
a7542 1
	  num_dynamic_syms = section.sh_size / section.sh_entsize;
a7547 2

	  dynamic_symbols = GET_ELF_SYMBOLS (file, &section);
d8347 1
d8361 1
a8361 1
	    symbols = GET_ELF_SYMBOLS (file, link_section);
d8430 2
a8431 4
		         array, break to avoid an out-of-bounds read,  */
		      if ((unsigned long)(cnt + j) >=
		         ((unsigned long)link_section->sh_size /
			  (unsigned long)link_section->sh_entsize))
d9163 1
d9187 1
a9187 1
	  symtab = GET_ELF_SYMBOLS (file, section);
d9208 1
a9208 3
	  for (si = 0, psym = symtab;
	       si < section->sh_size / section->sh_entsize;
	       si++, psym++)
d10064 1
d10094 1
a10094 1
      symtab = GET_ELF_SYMBOLS ((FILE *) file, symsec);
d10102 1
d10136 8
a10143 1
	  sym = symtab + get_reloc_symindex (rp->r_info);
@


1.555
log
@2011-09-27  Tristan Gingold  <gingold@@adacore.com>

	* readelf.c (print_ia64_vms_note): Fix xgettext warnings.
@
text
@d2598 3
d2605 1
d2610 1
@


1.554
log
@Annotate sparc objects with cpu hardware capabilities used.

bfd/

	* elfxx-sparc.c (_bfd_sparc_elf_merge_private_bfd_data): New.
	* elfxx-sparc.h: Declare it.
	* elf32-sparc.c (elf32_sparc_merge_private_bfd_data): Call it.
	* elf64-sparc.c (elf64_sparc_merge_private_bfd_data): Likewise.

binutils/

	* readelf.c (display_sparc_hwcaps): New.
	(display_sparc_gnu_attribute): New.
	(process_sparc_specific): New.
	(process_arch_specific): When EM_SPARC, EM_SPARC32PLUS,
	or EM_SPARCV9 invoke process_sparc_specific.

gas/

	* config/tc-sparc.c (hwcap_seen): New bitmask, defined when
	not TE_SOLARIS.
	(sparc_ip): When not TE_SOLARIS, accumulate hwcap bits from
	sparc_opcode->flags of instruction into hwcap_seen.
	(sparc_md_end): Create Tag_GNU_Sparc_HWCAPS attribute if
	hwcap_seen is non-zero and not TE_SOLARIS.

gas/testsuite/

	* gas/sparc/hpcvis3.s: Update for fixed fchksum16 mnemonic.
	* gas/sparc/hpcvis3.d: Likewise.

include/elf/

	* sparc.h (Tag_GNU_Sparc_HWCAPS): New object attribute.
	(ELF_SPARC_HWCAP_*): New HWCAPS bitmask values.

include/opcode/

	* sparc.h (struct sparc_opcode): Expand 'flags' to unsigned int.
	(F_MUL32, F_DIV32, F_FSMULD, F_V8PLUS, F_POPC, F_VIS, F_VIS2,
	F_ASI_BLK_INIT, F_FMAF, F_VIS3, F_HPC, F_RANDOM, F_TRANS,
	F_FJFMAU, F_IMA, F_ASI_CACHE_SPARING): New flag bits.

opcodes/

	* sparc-opc.c (sparc_opcodes): Annotate table with HWCAP flag
	bits.  Fix "fchksm16" mnemonic.
@
text
@d12697 2
a12698 1
      printf (_("   FP mode: 0x%016" BFD_VMA_FMT "x\n"),
d12721 2
a12722 1
                "   Link flags  : 0x%016" BFD_VMA_FMT "x\n"),
@


1.554.2.1
log
@	PR binutils/13622
	* readelf.c (process_section_groups): If there are no section
	headers do not scan for section groups.
	(process_note_sections): Likewise for note sections.
@
text
@d4940 1
a4940 2
      /* PR 13622: This can happen with a corrupt ELF header.  */
      return 0;
d12945 1
a12945 1
       i < elf_header.e_shnum && section != NULL;
@


1.553
log
@	* dwarf2.c (dwarf_debug_sections): Add .debug_macro
	and .zdebug_macro entry.
	(dwarf_debug_section_enum): Add debug_macro.

	* NEWS: Mention .debug_macro support.
	* dwarf.c (read_and_display_attr_value): Don't print a tab
	if attribute is 0.
	(get_AT_name): Handle DW_AT_GNU_macros.
	(get_line_filename_and_dirname, display_debug_macro): New
	functions.
	(debug_displays): Add an entry for .debug_macro and .zdebug_macro.
	* readelf.c (process_section_headers): With do_debug_macinfo
	handle also .debug_macro sections.
	* dwarf.h (dwarf_section_display_enum): Add macro.
@
text
@d11099 82
d11630 7
d12990 5
@


1.552
log
@bfd/
2011-02-25  Chao-ying Fu  <fu@@mips.com>
            Ilie Garbacea  <ilie@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>
            Catherine Moore  <clm@@codesourcery.com>
	    Richard Sandiford  <rdsandiford@@googlemail.com>

	* archures.c (bfd_mach_mips_micromips): New macro.
	* cpu-mips.c (I_micromips): New enum value.
	(arch_info_struct): Add bfd_mach_mips_micromips.
	* elfxx-mips.h (_bfd_mips_elf_is_target_special_symbol): New
	prototype.
	(_bfd_mips_elf_relax_section): Likewise.
	(_bfd_mips16_elf_reloc_unshuffle): Rename to...
	(_bfd_mips_elf_reloc_unshuffle): ... this.  Handle microMIPS
	ASE.
	(_bfd_mips16_elf_reloc_shuffle): Rename to...
	(_bfd_mips_elf_reloc_shuffle): ... this.  Handle microMIPS ASE.
	(gprel16_reloc_p): Handle microMIPS ASE.
	(literal_reloc_p): New function.
	* elf32-mips.c (elf_micromips_howto_table_rel): New variable.
	(_bfd_mips_elf32_gprel16_reloc): Handle microMIPS ASE.
	(mips16_gprel_reloc): Update for _bfd_mips_elf_reloc_unshuffle
	and _bfd_mips_elf_reloc_shuffle changes.
	(mips_elf_gprel32_reloc): Update comment.
	(micromips_reloc_map): New variable.
	(bfd_elf32_bfd_reloc_type_lookup): Handle microMIPS ASE.
	(mips_elf32_rtype_to_howto): Likewise.
	(mips_info_to_howto_rel): Likewise.
	(bfd_elf32_bfd_is_target_special_symbol): Define.
	(bfd_elf32_bfd_relax_section): Likewise.
	* elf64-mips.c (micromips_elf64_howto_table_rel): New variable.
	(micromips_elf64_howto_table_rela): Likewise.
	(mips16_gprel_reloc): Update for _bfd_mips_elf_reloc_unshuffle
	and _bfd_mips_elf_reloc_shuffle changes.
	(micromips_reloc_map): Likewise.
	(bfd_elf64_bfd_reloc_type_lookup): Handle microMIPS ASE.
	(bfd_elf64_bfd_reloc_name_lookup): Likewise.
	(mips_elf64_rtype_to_howto): Likewise.
	(bfd_elf64_bfd_is_target_special_symbol): Define.
	* elfn32-mips.c (elf_micromips_howto_table_rel): New variable.
	(elf_micromips_howto_table_rela): Likewise.
	(mips16_gprel_reloc): Update for _bfd_mips_elf_reloc_unshuffle
	and _bfd_mips_elf_reloc_shuffle changes.
	(micromips_reloc_map): Likewise.
	(bfd_elf32_bfd_reloc_type_lookup): Handle microMIPS ASE.
	(bfd_elf32_bfd_reloc_name_lookup): Likewise.
	(mips_elf_n32_rtype_to_howto): Likewise.
	(bfd_elf32_bfd_is_target_special_symbol): Define.
	* elfxx-mips.c (LA25_LUI_MICROMIPS_1): New macro.
	(LA25_LUI_MICROMIPS_2): Likewise.
	(LA25_J_MICROMIPS_1, LA25_J_MICROMIPS_2): Likewise.
	(LA25_ADDIU_MICROMIPS_1, LA25_ADDIU_MICROMIPS_2): Likewise.
	(TLS_RELOC_P): Handle microMIPS ASE.
	(mips_elf_create_stub_symbol): Adjust value of stub symbol if
	target is a microMIPS function.
	(micromips_reloc_p): New function.
	(micromips_reloc_shuffle_p): Likewise.
	(got16_reloc_p, call16_reloc_p): Handle microMIPS ASE.
	(got_disp_reloc_p, got_page_reloc_p): New functions.
	(got_ofst_reloc_p): Likewise.
	(got_hi16_reloc_p, got_lo16_reloc_p): Likewise.
	(call_hi16_reloc_p, call_lo16_reloc_p): Likewise.
	(hi16_reloc_p, lo16_reloc_p, jal_reloc_p): Handle microMIPS ASE.
	(micromips_branch_reloc_p): New function.
	(tls_gd_reloc_p, tls_ldm_reloc_p): Likewise.
	(tls_gottprel_reloc_p): Likewise.
	(_bfd_mips16_elf_reloc_unshuffle): Rename to...
	(_bfd_mips_elf_reloc_unshuffle): ... this.  Handle microMIPS
	ASE.
	(_bfd_mips16_elf_reloc_shuffle): Rename to...
	(_bfd_mips_elf_reloc_shuffle): ... this.  Handle microMIPS ASE.
	(_bfd_mips_elf_lo16_reloc): Handle microMIPS ASE.
	(mips_tls_got_index, mips_elf_got_page): Likewise.
	(mips_elf_create_local_got_entry): Likewise.
	(mips_elf_relocation_needs_la25_stub): Likewise.
	(mips_elf_calculate_relocation): Likewise.
	(mips_elf_perform_relocation): Likewise.
	(_bfd_mips_elf_symbol_processing): Likewise.
	(_bfd_mips_elf_add_symbol_hook): Likewise.
	(_bfd_mips_elf_link_output_symbol_hook): Likewise.
	(mips_elf_add_lo16_rel_addend): Likewise.
	(_bfd_mips_elf_check_relocs): Likewise.
	(mips_elf_adjust_addend): Likewise.
	(_bfd_mips_elf_relocate_section): Likewise.
	(mips_elf_create_la25_stub): Likewise.
	(_bfd_mips_vxworks_finish_dynamic_symbol): Likewise.
	(_bfd_mips_elf_gc_sweep_hook): Likewise.
	(_bfd_mips_elf_is_target_special_symbol): New function.
	(mips_elf_relax_delete_bytes): Likewise.
	(opcode_descriptor): New structure.
	(RA): New macro.
	(OP32_SREG, OP32_TREG, OP16_VALID_REG): Likewise.
	(b_insns_32, bc_insn_32, bz_insn_32, bzal_insn_32): New variables.
	(beq_insn_32): Likewise.
	(b_insn_16, bz_insn_16): New variables.
	(BZC32_REG_FIELD): New macro.
	(bz_rs_insns_32, bz_rt_insns_32): New variables.
	(bzc_insns_32, bz_insns_16):Likewise.
	(BZ16_REG, BZ16_REG_FIELD): New macros.
	(jal_insn_32_bd16, jal_insn_32_bd32): New variables.
	(jal_x_insn_32_bd32): Likewise.
	(j_insn_32, jalr_insn_32): Likewise.
	(ds_insns_32_bd16, ds_insns_32_bd32): Likewise.
	(jalr_insn_16_bd16, jalr_insn_16_bd32, jr_insn_16): Likewise.
	(JR16_REG): New macro.
	(ds_insns_16_bd16): New variable.
	(lui_insn): Likewise.
	(addiu_insn, addiupc_insn): Likewise.
	(ADDIUPC_REG_FIELD): New macro.
	(MOVE32_RD, MOVE32_RS): Likewise.
	(MOVE16_RD_FIELD, MOVE16_RS_FIELD): Likewise.
	(move_insns_32, move_insns_16): New variables.
	(nop_insn_32, nop_insn_16): Likewise.
	(MATCH): New macro.
	(find_match): New function.
	(check_br16_dslot, check_br32_dslot): Likewise.
	(check_br16, check_br32): Likewise.
	(IS_BITSIZE): New macro.
	(check_4byte_branch): New function.
	(_bfd_mips_elf_relax_section): Likewise.
	(_bfd_mips_elf_merge_private_bfd_data): Disallow linking MIPS16
	and microMIPS modules together.
	(_bfd_mips_elf_print_private_bfd_data):	Handle microMIPS ASE.
	* reloc.c (BFD_RELOC_MICROMIPS_7_PCREL_S1): New relocation.
	(BFD_RELOC_MICROMIPS_10_PCREL_S1): Likewise.
	(BFD_RELOC_MICROMIPS_16_PCREL_S1): Likewise.
	(BFD_RELOC_MICROMIPS_GPREL16): Likewise.
	(BFD_RELOC_MICROMIPS_JMP, BFD_RELOC_MICROMIPS_HI16): Likewise.
	(BFD_RELOC_MICROMIPS_HI16_S): Likewise.
	(BFD_RELOC_MICROMIPS_LO16): Likewise.
	(BFD_RELOC_MICROMIPS_LITERAL): Likewise.
	(BFD_RELOC_MICROMIPS_GOT16): Likewise.
	(BFD_RELOC_MICROMIPS_CALL16): Likewise.
	(BFD_RELOC_MICROMIPS_GOT_HI16): Likewise.
	(BFD_RELOC_MICROMIPS_GOT_LO16): Likewise.
	(BFD_RELOC_MICROMIPS_CALL_HI16): Likewise.
	(BFD_RELOC_MICROMIPS_CALL_LO16): Likewise.
	(BFD_RELOC_MICROMIPS_SUB): Likewise.
	(BFD_RELOC_MICROMIPS_GOT_PAGE): Likewise.
	(BFD_RELOC_MICROMIPS_GOT_OFST): Likewise.
	(BFD_RELOC_MICROMIPS_GOT_DISP): Likewise.
	(BFD_RELOC_MICROMIPS_HIGHEST): Likewise.
	(BFD_RELOC_MICROMIPS_HIGHER): Likewise.
	(BFD_RELOC_MICROMIPS_SCN_DISP): Likewise.
	(BFD_RELOC_MICROMIPS_JALR): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_GD): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_LDM): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_DTPREL_HI16): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_DTPREL_LO16): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_GOTTPREL): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_TPREL_HI16): Likewise.
	(BFD_RELOC_MICROMIPS_TLS_TPREL_LO16): Likewise.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.

binutils/
2011-02-25  Chao-ying Fu  <fu@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* readelf.c (get_machine_flags): Handle microMIPS ASE.
	(get_mips_symbol_other): Likewise.

gas/
2011-02-25  Maciej W. Rozycki  <macro@@codesourcery.com>
            Chao-ying Fu  <fu@@mips.com>
	    Richard Sandiford  <rdsandiford@@googlemail.com>

	* config/tc-mips.h (mips_segment_info): Add one bit for
	microMIPS.
	(TC_LABEL_IS_LOCAL): New macro.
	(mips_label_is_local): New prototype.
	* config/tc-mips.c (S0, S7): New macros.
	(emit_branch_likely_macro): New variable.
	(mips_set_options): Add micromips.
	(mips_opts): Initialise micromips to -1.
	(file_ase_micromips): New variable.
	(CPU_HAS_MICROMIPS): New macro.
	(hilo_interlocks): Set for microMIPS too.
	(gpr_interlocks): Likewise.
	(cop_interlocks): Likewise.
	(cop_mem_interlocks): Likewise.
	(HAVE_CODE_COMPRESSION): New macro.
	(micromips_op_hash): New variable.
	(micromips_nop16_insn, micromips_nop32_insn): New variables.
	(NOP_INSN): Handle microMIPS ASE.
	(mips32_to_micromips_reg_b_map): New macro.
	(mips32_to_micromips_reg_c_map): Likewise.
	(mips32_to_micromips_reg_d_map): Likewise.
	(mips32_to_micromips_reg_e_map): Likewise.
	(mips32_to_micromips_reg_f_map): Likewise.
	(mips32_to_micromips_reg_g_map): Likewise.
	(mips32_to_micromips_reg_l_map): Likewise.
	(mips32_to_micromips_reg_n_map): Likewise.
	(mips32_to_micromips_reg_h_map): New variable.
	(mips32_to_micromips_reg_m_map): Likewise.
	(mips32_to_micromips_reg_q_map): Likewise.
	(micromips_to_32_reg_h_map): New variable.
	(micromips_to_32_reg_i_map): Likewise.
	(micromips_to_32_reg_m_map): Likewise.
	(micromips_to_32_reg_q_map): Likewise.
	(micromips_to_32_reg_b_map): New macro.
	(micromips_to_32_reg_c_map): Likewise.
	(micromips_to_32_reg_d_map): Likewise.
	(micromips_to_32_reg_e_map): Likewise.
	(micromips_to_32_reg_f_map): Likewise.
	(micromips_to_32_reg_g_map): Likewise.
	(micromips_to_32_reg_l_map): Likewise.
	(micromips_to_32_reg_n_map): Likewise.
	(micromips_imm_b_map, micromips_imm_c_map): New macros.
	(RELAX_DELAY_SLOT_16BIT): New macro.
	(RELAX_DELAY_SLOT_SIZE_FIRST): Likewise.
	(RELAX_DELAY_SLOT_SIZE_SECOND): Likewise.
	(RELAX_MICROMIPS_ENCODE, RELAX_MICROMIPS_P): New macros.
	(RELAX_MICROMIPS_TYPE, RELAX_MICROMIPS_AT): Likewise.
	(RELAX_MICROMIPS_U16BIT, RELAX_MICROMIPS_UNCOND): Likewise.
	(RELAX_MICROMIPS_COMPACT, RELAX_MICROMIPS_LINK): Likewise.
	(RELAX_MICROMIPS_RELAX32, RELAX_MICROMIPS_TOOFAR16): Likewise.
	(RELAX_MICROMIPS_MARK_TOOFAR16): Likewise.
	(RELAX_MICROMIPS_CLEAR_TOOFAR16): Likewise.
	(RELAX_MICROMIPS_TOOFAR32): Likewise.
	(RELAX_MICROMIPS_MARK_TOOFAR32): Likewise.
	(RELAX_MICROMIPS_CLEAR_TOOFAR32): Likewise.
	(INSERT_OPERAND, EXTRACT_OPERAND): Handle microMIPS ASE.
	(mips_macro_warning): Add delay_slot_16bit_p, delay_slot_32bit_p,
	fsize and insns.
	(mips_mark_labels): New function.
	(mips16_small, mips16_ext): Remove variables, replacing with...
	(forced_insn_size): ... this.
	(append_insn, mips16_ip): Update accordingly.
	(micromips_insn_length): New function.
	(insn_length): Return the length of microMIPS instructions.
	(mips_record_mips16_mode): Rename to...
	(mips_record_compressed_mode): ... this.  Handle microMIPS ASE.
	(install_insn): Handle microMIPS ASE.
	(reglist_lookup): New function.
	(is_size_valid, is_delay_slot_valid): Likewise.
	(md_begin): Handle microMIPS ASE.
	(md_assemble): Likewise.  Update for append_insn interface change.
	(micromips_reloc_p): New function.
	(got16_reloc_p): Handle microMIPS ASE.
	(hi16_reloc_p): Likewise.
	(lo16_reloc_p): Likewise.
	(jmp_reloc_p): New function.
	(jalr_reloc_p): Likewise.
	(matching_lo_reloc): Handle microMIPS ASE.
	(insn_uses_reg, reg_needs_delay): Likewise.
	(mips_move_labels): Likewise.
	(mips16_mark_labels): Rename to...
	(mips_compressed_mark_labels): ... this.  Handle microMIPS ASE.
	(gpr_mod_mask): New function.
	(gpr_read_mask, gpr_write_mask): Handle microMIPS ASE.
	(fpr_read_mask, fpr_write_mask): Likewise.
	(insns_between, nops_for_vr4130, nops_for_insn): Likewise.
	(fix_loongson2f_nop, fix_loongson2f_jump): Likewise.
	(MICROMIPS_LABEL_CHAR): New macro.
	(micromips_target_label, micromips_target_name): New variables.
	(micromips_label_name, micromips_label_expr): New functions.
	(micromips_label_inc, micromips_add_label): Likewise.
	(mips_label_is_local): Likewise.
	(micromips_map_reloc): Likewise.
	(can_swap_branch_p): Handle microMIPS ASE.
	(append_insn): Add expansionp argument.  Handle microMIPS ASE.
	(start_noreorder, end_noreorder): Handle microMIPS ASE.
	(macro_start, macro_warning, macro_end): Likewise.
	(brk_fmt, cop12_fmt, jalr_fmt, lui_fmt): New variables.
	(mem12_fmt, mfhl_fmt, shft_fmt, trap_fmt): Likewise.
	(BRK_FMT, COP12_FMT, JALR_FMT, LUI_FMT): New macros.
	(MEM12_FMT, MFHL_FMT, SHFT_FMT, TRAP_FMT): Likewise.
	(macro_build): Handle microMIPS ASE.  Update for append_insn
	interface change.
	(mips16_macro_build): Update for append_insn interface change.
	(macro_build_jalr): Handle microMIPS ASE.
	(macro_build_lui): Likewise.  Simplify.
	(load_register): Handle microMIPS ASE.
	(load_address): Likewise.
	(move_register): Likewise.
	(macro_build_branch_likely): New function.
	(macro_build_branch_ccl): Likewise.
	(macro_build_branch_rs): Likewise.
	(macro_build_branch_rsrt): Likewise.
	(macro): Handle microMIPS ASE.
	(validate_micromips_insn): New function.
	(expr_const_in_range): Likewise.
	(mips_ip): Handle microMIPS ASE.
	(options): Add OPTION_MICROMIPS and OPTION_NO_MICROMIPS.
	(md_longopts): Add mmicromips and mno-micromips.
	(md_parse_option): Handle OPTION_MICROMIPS and
	OPTION_NO_MICROMIPS.
	(mips_after_parse_args): Handle microMIPS ASE.
	(md_pcrel_from): Handle microMIPS relocations.
	(mips_force_relocation): Likewise.
	(md_apply_fix): Likewise.
	(mips_align): Handle microMIPS ASE.
	(s_mipsset): Likewise.
	(s_cpload, s_cpsetup, s_cpreturn): Use relocation wrappers.
	(s_dtprel_internal): Likewise.
	(s_gpword, s_gpdword): Likewise.
	(s_insn): Handle microMIPS ASE.
	(s_mips_stab): Likewise.
	(relaxed_micromips_32bit_branch_length): New function.
	(relaxed_micromips_16bit_branch_length): New function.
	(md_estimate_size_before_relax): Handle microMIPS ASE.
	(mips_fix_adjustable): Likewise.
	(tc_gen_reloc): Handle microMIPS relocations.
	(mips_relax_frag): Handle microMIPS ASE.
	(md_convert_frag): Likewise.
	(mips_frob_file_after_relocs): Likewise.
	(mips_elf_final_processing): Likewise.
	(mips_nop_opcode): Likewise.
	(mips_handle_align): Likewise.
	(md_show_usage): Handle microMIPS options.
	* symbols.c (TC_LABEL_IS_LOCAL): New macro.
	(S_IS_LOCAL): Add a TC_LABEL_IS_LOCAL check.

	* doc/as.texinfo (Target MIPS options): Add -mmicromips and
	-mno-micromips.
	(-mmicromips, -mno-micromips): New options.
	* doc/c-mips.texi (-mmicromips, -mno-micromips): New options.
	(MIPS ISA): Document .set micromips and .set nomicromips.
	(MIPS insn): Update for microMIPS support.

gas/testsuite/
2011-02-25  Maciej W. Rozycki  <macro@@codesourcery.com>
            Chao-ying Fu  <fu@@mips.com>
	    Richard Sandiford  <rdsandiford@@googlemail.com>

	* gas/mips/micromips.d: New test.
	* gas/mips/micromips-branch-delay.d: Likewise.
	* gas/mips/micromips-branch-relax.d: Likewise.
	* gas/mips/micromips-branch-relax-pic.d: Likewise.
	* gas/mips/micromips-size-1.d: Likewise.
	* gas/mips/micromips-trap.d: Likewise.
	* gas/mips/micromips.l: New stderr output.
	* gas/mips/micromips-branch-delay.l: Likewise.
	* gas/mips/micromips-branch-relax.l: Likewise.
	* gas/mips/micromips-branch-relax-pic.l: Likewise.
	* gas/mips/micromips-size-0.l: New list test.
	* gas/mips/micromips-size-1.l: New stderr output.
	* gas/mips/micromips.s: New test source.
	* gas/mips/micromips-branch-delay.s: Likewise.
	* gas/mips/micromips-branch-relax.s: Likewise.
	* gas/mips/micromips-size-0.s: Likewise.
	* gas/mips/micromips-size-1.s: Likewise.
	* gas/mips/mips.exp: Run the new tests.

	* gas/mips/dli.s: Use .p2align.
	* gas/mips/elf_ase_micromips.d: New test.
	* gas/mips/elf_ase_micromips-2.d: Likewise.
	* gas/mips/micromips@@abs.d: Likewise.
	* gas/mips/micromips@@add.d: Likewise.
	* gas/mips/micromips@@alnv_ps-swap.d: Likewise.
	* gas/mips/micromips@@and.d: Likewise.
	* gas/mips/micromips@@beq.d: Likewise.
	* gas/mips/micromips@@bge.d: Likewise.
	* gas/mips/micromips@@bgeu.d: Likewise.
	* gas/mips/micromips@@blt.d: Likewise.
	* gas/mips/micromips@@bltu.d: Likewise.
	* gas/mips/micromips@@branch-likely.d: Likewise.
	* gas/mips/micromips@@branch-misc-1.d: Likewise.
	* gas/mips/micromips@@branch-misc-2-64.d: Likewise.
	* gas/mips/micromips@@branch-misc-2.d: Likewise.
	* gas/mips/micromips@@branch-misc-2pic-64.d: Likewise.
	* gas/mips/micromips@@branch-misc-2pic.d: Likewise.
	* gas/mips/micromips@@branch-misc-4-64.d: Likewise.
	* gas/mips/micromips@@branch-misc-4.d: Likewise.
	* gas/mips/micromips@@branch-self.d: Likewise.
	* gas/mips/micromips@@cache.d: Likewise.
	* gas/mips/micromips@@daddi.d: Likewise.
	* gas/mips/micromips@@dli.d: Likewise.
	* gas/mips/micromips@@elf-jal.d: Likewise.
	* gas/mips/micromips@@elf-rel2.d: Likewise.
	* gas/mips/micromips@@elfel-rel2.d: Likewise.
	* gas/mips/micromips@@elf-rel4.d: Likewise.
	* gas/mips/micromips@@jal-svr4pic.d: Likewise.
	* gas/mips/micromips@@jal-svr4pic-noreorder.d: Likewise.
	* gas/mips/micromips@@lb-svr4pic-ilocks.d: Likewise.
	* gas/mips/micromips@@li.d: Likewise.
	* gas/mips/micromips@@loc-swap-dis.d: Likewise.
	* gas/mips/micromips@@loc-swap.d: Likewise.
	* gas/mips/micromips@@mips1-fp.d: Likewise.
	* gas/mips/micromips@@mips32-cp2.d: Likewise.
	* gas/mips/micromips@@mips32-imm.d: Likewise.
	* gas/mips/micromips@@mips32-sf32.d: Likewise.
	* gas/mips/micromips@@mips32.d: Likewise.
	* gas/mips/micromips@@mips32r2-cp2.d: Likewise.
	* gas/mips/micromips@@mips32r2-fp32.d: Likewise.
	* gas/mips/micromips@@mips32r2-sync.d: Likewise.
	* gas/mips/micromips@@mips32r2.d: Likewise.
	* gas/mips/micromips@@mips4-branch-likely.d: Likewise.
	* gas/mips/micromips@@mips4-fp.d: Likewise.
	* gas/mips/micromips@@mips4.d: Likewise.
	* gas/mips/micromips@@mips5.d: Likewise.
	* gas/mips/micromips@@mips64-cp2.d: Likewise.
	* gas/mips/micromips@@mips64.d: Likewise.
	* gas/mips/micromips@@mips64r2.d: Likewise.
	* gas/mips/micromips@@pref.d: Likewise.
	* gas/mips/micromips@@relax-at.d: Likewise.
	* gas/mips/micromips@@relax.d: Likewise.
	* gas/mips/micromips@@rol-hw.d: Likewise.
	* gas/mips/micromips@@uld2-eb.d: Likewise.
	* gas/mips/micromips@@uld2-el.d: Likewise.
	* gas/mips/micromips@@ulh2-eb.d: Likewise.
	* gas/mips/micromips@@ulh2-el.d: Likewise.
	* gas/mips/micromips@@ulw2-eb-ilocks.d: Likewise.
	* gas/mips/micromips@@ulw2-el-ilocks.d: Likewise.
	* gas/mips/cache.d: Likewise.
	* gas/mips/daddi.d: Likewise.
	* gas/mips/mips32-imm.d: Likewise.
	* gas/mips/pref.d: Likewise.
	* gas/mips/elf-rel27.d: Handle microMIPS ASE.
	* gas/mips/l_d.d: Likewise.
	* gas/mips/l_d-n32.d: Likewise.
	* gas/mips/l_d-n64.d: Likewise.
	* gas/mips/ld.d: Likewise.
	* gas/mips/ld-n32.d: Likewise.
	* gas/mips/ld-n64.d: Likewise.
	* gas/mips/s_d.d: Likewise.
	* gas/mips/s_d-n32.d: Likewise.
	* gas/mips/s_d-n64.d: Likewise.
	* gas/mips/sd.d: Likewise.
	* gas/mips/sd-n32.d: Likewise.
	* gas/mips/sd-n64.d: Likewise.
	* gas/mips/mips32.d: Update immediates.
	* gas/mips/micromips@@mips32-cp2.s: New test source.
	* gas/mips/micromips@@mips32-imm.s: Likewise.
	* gas/mips/micromips@@mips32r2-cp2.s: Likewise.
	* gas/mips/micromips@@mips64-cp2.s: Likewise.
	* gas/mips/cache.s: Likewise.
	* gas/mips/daddi.s: Likewise.
	* gas/mips/mips32-imm.s: Likewise.
	* gas/mips/elf-rel4.s: Handle microMIPS ASE.
	* gas/mips/lb-pic.s: Likewise.
	* gas/mips/ld.s: Likewise.
	* gas/mips/mips32.s: Likewise.
	* gas/mips/mips.exp: Add the micromips arch.  Exclude mips16e
	from micromips.  Run mips32-imm.

	* gas/mips/jal-mask-11.d: New test.
	* gas/mips/jal-mask-12.d: Likewise.
	* gas/mips/micromips@@jal-mask-11.d: Likewise.
	* gas/mips/jal-mask-1.s: Source for the new tests.
	* gas/mips/jal-mask-21.d: New test.
	* gas/mips/jal-mask-22.d: Likewise.
	* gas/mips/micromips@@jal-mask-12.d: Likewise.
	* gas/mips/jal-mask-2.s: Source for the new tests.
	* gas/mips/mips.exp: Run the new tests.

	* gas/mips/mips16-e.d: Add --special-syms to `objdump'.
	* gas/mips/tmips16-e.d: Likewise.
	* gas/mips/mipsel16-e.d: Likewise.
	* gas/mips/tmipsel16-e.d: Likewise.

	* gas/mips/and.s: Adjust padding.
	* gas/mips/beq.s: Likewise.
	* gas/mips/bge.s: Likewise.
	* gas/mips/bgeu.s: Likewise.
	* gas/mips/blt.s: Likewise.
	* gas/mips/bltu.s: Likewise.
	* gas/mips/branch-misc-2.s: Likewise.
	* gas/mips/jal.s: Likewise.
	* gas/mips/li.s: Likewise.
	* gas/mips/mips4.s: Likewise.
	* gas/mips/mips4-fp.s: Likewise.
	* gas/mips/relax.s: Likewise.
	* gas/mips/and.d: Update accordingly.
	* gas/mips/elf-jal.d: Likewise.
	* gas/mips/jal.d: Likewise.
	* gas/mips/li.d: Likewise.
	* gas/mips/relax-at.d: Likewise.
	* gas/mips/relax.d: Likewise.

include/elf/
2011-02-25  Chao-ying Fu  <fu@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips.h (R_MICROMIPS_min): New relocations.
	(R_MICROMIPS_26_S1): Likewise.
	(R_MICROMIPS_HI16, R_MICROMIPS_LO16): Likewise.
	(R_MICROMIPS_GPREL16, R_MICROMIPS_LITERAL): Likewise.
	(R_MICROMIPS_GOT16, R_MICROMIPS_PC7_S1): Likewise.
	(R_MICROMIPS_PC10_S1, R_MICROMIPS_PC16_S1): Likewise.
	(R_MICROMIPS_CALL16, R_MICROMIPS_GOT_DISP): Likewise.
	(R_MICROMIPS_GOT_PAGE, R_MICROMIPS_GOT_OFST): Likewise.
	(R_MICROMIPS_GOT_HI16, R_MICROMIPS_GOT_LO16): Likewise.
	(R_MICROMIPS_SUB, R_MICROMIPS_HIGHER): Likewise.
	(R_MICROMIPS_HIGHEST, R_MICROMIPS_CALL_HI16): Likewise.
	(R_MICROMIPS_CALL_LO16, R_MICROMIPS_SCN_DISP): Likewise.
	(R_MICROMIPS_JALR, R_MICROMIPS_HI0_LO16): Likewise.
	(R_MICROMIPS_TLS_GD, R_MICROMIPS_TLS_LDM): Likewise.
	(R_MICROMIPS_TLS_DTPREL_HI, R_MICROMIPS_TLS_DTPREL_LO): Likewise.
	(R_MICROMIPS_TLS_GOTTPREL): Likewise.
	(R_MICROMIPS_TLS_TPREL_HI16): Likewise.
	(R_MICROMIPS_TLS_TPREL_LO16): Likewise.
	(R_MICROMIPS_GPREL7_S2, R_MICROMIPS_PC23_S2): Likewise.
	(R_MICROMIPS_max): Likewise.
	(EF_MIPS_ARCH_ASE_MICROMIPS): New macro.
	(STO_MIPS_ISA, STO_MIPS_FLAGS): Likewise.
	(ELF_ST_IS_MIPS_PLT, ELF_ST_SET_MIPS_PLT): Likewise.
	(STO_MICROMIPS): Likewise.
	(ELF_ST_IS_MICROMIPS, ELF_ST_SET_MICROMIPS): Likewise.
	(ELF_ST_IS_COMPRESSED): Likewise.
	(STO_MIPS_PLT, STO_MIPS_PIC): Rework.
	(ELF_ST_IS_MIPS_PIC, ELF_ST_SET_MIPS_PIC): Likewise.
	(STO_MIPS16, ELF_ST_IS_MIPS16, ELF_ST_SET_MIPS16): Likewise.

include/opcode/
2011-02-25  Chao-ying Fu  <fu@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* mips.h (OP_MASK_EXTLSB, OP_SH_EXTLSB): New macros.
	(OP_MASK_STYPE, OP_SH_STYPE): Likewise.
	(OP_MASK_CODE10, OP_SH_CODE10): Likewise.
	(OP_MASK_TRAP, OP_SH_TRAP): Likewise.
	(OP_MASK_OFFSET12, OP_SH_OFFSET12): Likewise.
	(OP_MASK_OFFSET10, OP_SH_OFFSET10): Likewise.
	(OP_MASK_RS3, OP_SH_RS3): Likewise.
	(OP_MASK_MB, OP_SH_MB, OP_MASK_MC, OP_SH_MC): Likewise.
	(OP_MASK_MD, OP_SH_MD, OP_MASK_ME, OP_SH_ME): Likewise.
	(OP_MASK_MF, OP_SH_MF, OP_MASK_MG, OP_SH_MG): Likewise.
	(OP_MASK_MJ, OP_SH_MJ, OP_MASK_ML, OP_SH_ML): Likewise.
	(OP_MASK_MP, OP_SH_MP, OP_MASK_MQ, OP_SH_MQ): Likewise.
	(OP_MASK_IMMA, OP_SH_IMMA, OP_MASK_IMMB, OP_SH_IMMB): Likewise.
	(OP_MASK_IMMC, OP_SH_IMMC, OP_MASK_IMMF, OP_SH_IMMF): Likewise.
	(OP_MASK_IMMG, OP_SH_IMMG, OP_MASK_IMMH, OP_SH_IMMH): Likewise.
	(OP_MASK_IMMI, OP_SH_IMMI, OP_MASK_IMMJ, OP_SH_IMMJ): Likewise.
	(OP_MASK_IMML, OP_SH_IMML, OP_MASK_IMMM, OP_SH_IMMM): Likewise.
	(OP_MASK_IMMN, OP_SH_IMMN, OP_MASK_IMMO, OP_SH_IMMO): Likewise.
	(OP_MASK_IMMP, OP_SH_IMMP, OP_MASK_IMMQ, OP_SH_IMMQ): Likewise.
	(OP_MASK_IMMU, OP_SH_IMMU, OP_MASK_IMMW, OP_SH_IMMW): Likewise.
	(OP_MASK_IMMX, OP_SH_IMMX, OP_MASK_IMMY, OP_SH_IMMY): Likewise.
	(INSN_WRITE_GPR_S): New macro.
	(INSN2_BRANCH_DELAY_16BIT, INSN2_BRANCH_DELAY_32BIT): Likewise.
	(INSN2_READ_FPR_D): Likewise.
	(INSN2_MOD_GPR_MB, INSN2_MOD_GPR_MC): Likewise.
	(INSN2_MOD_GPR_MD, INSN2_MOD_GPR_ME): Likewise.
	(INSN2_MOD_GPR_MF, INSN2_MOD_GPR_MG): Likewise.
	(INSN2_MOD_GPR_MJ, INSN2_MOD_GPR_MP): Likewise.
	(INSN2_MOD_GPR_MQ, INSN2_MOD_SP): Likewise.
	(INSN2_READ_GPR_31, INSN2_READ_GP, INSN2_READ_PC): Likewise.
	(INSN2_UNCOND_BRANCH, INSN2_COND_BRANCH): Likewise.
	(INSN2_MOD_GPR_MHI, INSN2_MOD_GPR_MM, INSN2_MOD_GPR_MN): Likewise.
	(CPU_MICROMIPS): New macro.
	(M_BC1FL, M_BC1TL, M_BC2FL, M_BC2TL): New enum values.
	(M_BEQL, M_BGEZ, M_BGEZL, M_BGEZALL, M_BGTZ, M_BGTZL): Likewise.
	(M_BLEZ, M_BLEZL, M_BLTZ, M_BLTZL, M_BLTZALL, M_BNEL): Likewise.
	(M_CACHE_OB, M_JALS_1, M_JALS_2, M_JALS_A): Likewise.
	(M_LDC2_OB, M_LDL_OB, M_LDM_AB, M_LDM_OB): Likewise.
	(M_LDP_AB, M_LDP_OB, M_LDR_OB, M_LL_OB, M_LLD_OB): Likewise.
	(M_LWC2_OB, M_LWL_OB, M_LWM_AB, M_LWM_OB): Likewise.
	(M_LWP_AB, M_LWP_OB, M_LWR_OB): Likewise.
	(M_LWU_OB, M_PREF_OB, M_SC_OB, M_SCD_OB): Likewise.
	(M_SDC2_OB, M_SDL_OB, M_SDM_AB, M_SDM_OB): Likewise.
	(M_SDP_AB, M_SDP_OB, M_SDR_OB): Likewise.
	(M_SWC2_OB, M_SWL_OB, M_SWM_AB, M_SWM_OB): Likewise.
	(M_SWP_AB, M_SWP_OB, M_SWR_OB): Likewise.
	(MICROMIPSOP_MASK_MAJOR, MICROMIPSOP_SH_MAJOR): New macros.
	(MICROMIPSOP_MASK_IMMEDIATE, MICROMIPSOP_SH_IMMEDIATE): Likewise.
	(MICROMIPSOP_MASK_DELTA, MICROMIPSOP_SH_DELTA): Likewise.
	(MICROMIPSOP_MASK_CODE10, MICROMIPSOP_SH_CODE10): Likewise.
	(MICROMIPSOP_MASK_TRAP, MICROMIPSOP_SH_TRAP): Likewise.
	(MICROMIPSOP_MASK_SHAMT, MICROMIPSOP_SH_SHAMT): Likewise.
	(MICROMIPSOP_MASK_TARGET, MICROMIPSOP_SH_TARGET): Likewise.
	(MICROMIPSOP_MASK_EXTLSB, MICROMIPSOP_SH_EXTLSB): Likewise.
	(MICROMIPSOP_MASK_EXTMSBD, MICROMIPSOP_SH_EXTMSBD): Likewise.
	(MICROMIPSOP_MASK_INSMSB, MICROMIPSOP_SH_INSMSB): Likewise.
	(MICROMIPSOP_MASK_CODE, MICROMIPSOP_SH_CODE): Likewise.
	(MICROMIPSOP_MASK_CODE2, MICROMIPSOP_SH_CODE2): Likewise.
	(MICROMIPSOP_MASK_CACHE, MICROMIPSOP_SH_CACHE): Likewise.
	(MICROMIPSOP_MASK_SEL, MICROMIPSOP_SH_SEL): Likewise.
	(MICROMIPSOP_MASK_OFFSET12, MICROMIPSOP_SH_OFFSET12): Likewise.
	(MICROMIPSOP_MASK_3BITPOS, MICROMIPSOP_SH_3BITPOS): Likewise.
	(MICROMIPSOP_MASK_STYPE, MICROMIPSOP_SH_STYPE): Likewise.
	(MICROMIPSOP_MASK_OFFSET10, MICROMIPSOP_SH_OFFSET10): Likewise.
	(MICROMIPSOP_MASK_RS, MICROMIPSOP_SH_RS): Likewise.
	(MICROMIPSOP_MASK_RT, MICROMIPSOP_SH_RT): Likewise.
	(MICROMIPSOP_MASK_RD, MICROMIPSOP_SH_RD): Likewise.
	(MICROMIPSOP_MASK_FS, MICROMIPSOP_SH_FS): Likewise.
	(MICROMIPSOP_MASK_FT, MICROMIPSOP_SH_FT): Likewise.
	(MICROMIPSOP_MASK_FD, MICROMIPSOP_SH_FD): Likewise.
	(MICROMIPSOP_MASK_FR, MICROMIPSOP_SH_FR): Likewise.
	(MICROMIPSOP_MASK_RS3, MICROMIPSOP_SH_RS3): Likewise.
	(MICROMIPSOP_MASK_PREFX, MICROMIPSOP_SH_PREFX): Likewise.
	(MICROMIPSOP_MASK_BCC, MICROMIPSOP_SH_BCC): Likewise.
	(MICROMIPSOP_MASK_CCC, MICROMIPSOP_SH_CCC): Likewise.
	(MICROMIPSOP_MASK_COPZ, MICROMIPSOP_SH_COPZ): Likewise.
	(MICROMIPSOP_MASK_MB, MICROMIPSOP_SH_MB): Likewise.
	(MICROMIPSOP_MASK_MC, MICROMIPSOP_SH_MC): Likewise.
	(MICROMIPSOP_MASK_MD, MICROMIPSOP_SH_MD): Likewise.
	(MICROMIPSOP_MASK_ME, MICROMIPSOP_SH_ME): Likewise.
	(MICROMIPSOP_MASK_MF, MICROMIPSOP_SH_MF): Likewise.
	(MICROMIPSOP_MASK_MG, MICROMIPSOP_SH_MG): Likewise.
	(MICROMIPSOP_MASK_MH, MICROMIPSOP_SH_MH): Likewise.
	(MICROMIPSOP_MASK_MI, MICROMIPSOP_SH_MI): Likewise.
	(MICROMIPSOP_MASK_MJ, MICROMIPSOP_SH_MJ): Likewise.
	(MICROMIPSOP_MASK_ML, MICROMIPSOP_SH_ML): Likewise.
	(MICROMIPSOP_MASK_MM, MICROMIPSOP_SH_MM): Likewise.
	(MICROMIPSOP_MASK_MN, MICROMIPSOP_SH_MN): Likewise.
	(MICROMIPSOP_MASK_MP, MICROMIPSOP_SH_MP): Likewise.
	(MICROMIPSOP_MASK_MQ, MICROMIPSOP_SH_MQ): Likewise.
	(MICROMIPSOP_MASK_IMMA, MICROMIPSOP_SH_IMMA): Likewise.
	(MICROMIPSOP_MASK_IMMB, MICROMIPSOP_SH_IMMB): Likewise.
	(MICROMIPSOP_MASK_IMMC, MICROMIPSOP_SH_IMMC): Likewise.
	(MICROMIPSOP_MASK_IMMD, MICROMIPSOP_SH_IMMD): Likewise.
	(MICROMIPSOP_MASK_IMME, MICROMIPSOP_SH_IMME): Likewise.
	(MICROMIPSOP_MASK_IMMF, MICROMIPSOP_SH_IMMF): Likewise.
	(MICROMIPSOP_MASK_IMMG, MICROMIPSOP_SH_IMMG): Likewise.
	(MICROMIPSOP_MASK_IMMH, MICROMIPSOP_SH_IMMH): Likewise.
	(MICROMIPSOP_MASK_IMMI, MICROMIPSOP_SH_IMMI): Likewise.
	(MICROMIPSOP_MASK_IMMJ, MICROMIPSOP_SH_IMMJ): Likewise.
	(MICROMIPSOP_MASK_IMML, MICROMIPSOP_SH_IMML): Likewise.
	(MICROMIPSOP_MASK_IMMM, MICROMIPSOP_SH_IMMM): Likewise.
	(MICROMIPSOP_MASK_IMMN, MICROMIPSOP_SH_IMMN): Likewise.
	(MICROMIPSOP_MASK_IMMO, MICROMIPSOP_SH_IMMO): Likewise.
	(MICROMIPSOP_MASK_IMMP, MICROMIPSOP_SH_IMMP): Likewise.
	(MICROMIPSOP_MASK_IMMQ, MICROMIPSOP_SH_IMMQ): Likewise.
	(MICROMIPSOP_MASK_IMMU, MICROMIPSOP_SH_IMMU): Likewise.
	(MICROMIPSOP_MASK_IMMW, MICROMIPSOP_SH_IMMW): Likewise.
	(MICROMIPSOP_MASK_IMMX, MICROMIPSOP_SH_IMMX): Likewise.
	(MICROMIPSOP_MASK_IMMY, MICROMIPSOP_SH_IMMY): Likewise.
	(MICROMIPSOP_MASK_CODE, MICROMIPSOP_SH_CODE): Likewise.
	(MICROMIPSOP_MASK_CODE2, MICROMIPSOP_SH_CODE2): Likewise.
	(MICROMIPSOP_MASK_CACHE, MICROMIPSOP_SH_CACHE): Likewise.
	(MICROMIPSOP_MASK_CODE20, MICROMIPSOP_SH_CODE20): Likewise.
	(MICROMIPSOP_MASK_PERFREG, MICROMIPSOP_SH_PERFREG): Likewise.
	(MICROMIPSOP_MASK_CODE19, MICROMIPSOP_SH_CODE19): Likewise.
	(MICROMIPSOP_MASK_ALN, MICROMIPSOP_SH_ALN): Likewise.
	(MICROMIPSOP_MASK_VECBYTE, MICROMIPSOP_SH_VECBYTE): Likewise.
	(MICROMIPSOP_MASK_VECALIGN, MICROMIPSOP_SH_VECALIGN): Likewise.
	(MICROMIPSOP_MASK_DSPACC, MICROMIPSOP_SH_DSPACC): Likewise.
	(MICROMIPSOP_MASK_DSPACC_S, MICROMIPSOP_SH_DSPACC_S): Likewise.
	(MICROMIPSOP_MASK_DSPSFT, MICROMIPSOP_SH_DSPSFT): Likewise.
	(MICROMIPSOP_MASK_DSPSFT_7, MICROMIPSOP_SH_DSPSFT_7): Likewise.
	(MICROMIPSOP_MASK_SA3, MICROMIPSOP_SH_SA3): Likewise.
	(MICROMIPSOP_MASK_SA4, MICROMIPSOP_SH_SA4): Likewise.
	(MICROMIPSOP_MASK_IMM8, MICROMIPSOP_SH_IMM8): Likewise.
	(MICROMIPSOP_MASK_IMM10, MICROMIPSOP_SH_IMM10): Likewise.
	(MICROMIPSOP_MASK_WRDSP, MICROMIPSOP_SH_WRDSP): Likewise.
	(MICROMIPSOP_MASK_RDDSP, MICROMIPSOP_SH_RDDSP): Likewise.
	(MICROMIPSOP_MASK_BP, MICROMIPSOP_SH_BP): Likewise.
	(MICROMIPSOP_MASK_MT_U, MICROMIPSOP_SH_MT_U): Likewise.
	(MICROMIPSOP_MASK_MT_H, MICROMIPSOP_SH_MT_H): Likewise.
	(MICROMIPSOP_MASK_MTACC_T, MICROMIPSOP_SH_MTACC_T): Likewise.
	(MICROMIPSOP_MASK_MTACC_D, MICROMIPSOP_SH_MTACC_D): Likewise.
	(MICROMIPSOP_MASK_BBITIND, MICROMIPSOP_SH_BBITIND): Likewise.
	(MICROMIPSOP_MASK_CINSPOS, MICROMIPSOP_SH_CINSPOS): Likewise.
	(MICROMIPSOP_MASK_CINSLM1, MICROMIPSOP_SH_CINSLM1): Likewise.
	(MICROMIPSOP_MASK_SEQI, MICROMIPSOP_SH_SEQI): Likewise.
	(micromips_opcodes): New declaration.
	(bfd_micromips_num_opcodes): Likewise.

ld/testsuite/
2011-02-25  Catherine Moore  <clm@@codesourcery.com>
            Chao-ying Fu  <fu@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* lib/ld-lib.exp (run_dump_test): Support distinct assembler
	flags for the same source named multiple times.
	* ld-mips-elf/jalx-1.s: New test source.
	* ld-mips-elf/jalx-1.d: New test output.
	* ld-mips-elf/jalx-1.ld: New test linker script.
	* ld-mips-elf/jalx-2-main.s: New test source.
	* ld-mips-elf/jalx-2-ex.s: Likewise.
	* ld-mips-elf/jalx-2-printf.s: Likewise.
	* ld-mips-elf/jalx-2.dd: New test output.
	* ld-mips-elf/jalx-2.ld: New test linker script.
	* ld-mips-elf/mips16-and-micromips.d: New test.
	* ld-mips-elf/mips-elf.exp: Run the new tests

opcodes/
2011-02-25  Chao-ying Fu  <fu@@mips.com>
            Maciej W. Rozycki  <macro@@codesourcery.com>

	* micromips-opc.c: New file.
	* mips-dis.c (micromips_to_32_reg_b_map): New array.
	(micromips_to_32_reg_c_map, micromips_to_32_reg_d_map): Likewise.
	(micromips_to_32_reg_e_map, micromips_to_32_reg_f_map): Likewise.
	(micromips_to_32_reg_g_map, micromips_to_32_reg_l_map): Likewise.
	(micromips_to_32_reg_q_map): Likewise.
	(micromips_imm_b_map, micromips_imm_c_map): Likewise.
	(micromips_ase): New variable.
	(is_micromips): New function.
	(set_default_mips_dis_options): Handle microMIPS ASE.
	(print_insn_micromips): New function.
	(is_compressed_mode_p): Likewise.
	(_print_insn_mips): Handle microMIPS instructions.
	* Makefile.am (CFILES): Add micromips-opc.c.
	* configure.in (bfd_mips_arch): Add micromips-opc.lo.
	* Makefile.in: Regenerate.
	* configure: Regenerate.

	* mips-dis.c (micromips_to_32_reg_h_map): New variable.
	(micromips_to_32_reg_i_map): Likewise.
	(micromips_to_32_reg_m_map): Likewise.
	(micromips_to_32_reg_n_map): New macro.
@
text
@d4623 1
@


1.551
log
@Add initial Intel K1OM support.

bfd/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.am (ALL_MACHINES): Add cpu-k1om.lo.
	(ALL_MACHINES_CFILES): Add cpu-k1om.c.
	* Makefile.in: Regenerated.

	* archures.c (bfd_architecture): Add bfd_arch_k1om.
	(bfd_k1om_arch): New.
	(bfd_archures_list): Add &bfd_k1om_arch.
	* bfd-in2.h: Regenerated.

	* config.bfd (targ64_selvecs): Add bfd_elf64_k1om_vec if
	bfd_elf64_x86_64_vec is supported.  Add bfd_elf64_k1om_freebsd_vec
	if bfd_elf64_x86_64_freebsd_vec is supported.
	(targ_selvecs): Likewise.

	* configure.in: Support bfd_elf64_k1om_vec and
	bfd_elf64_k1om_freebsd_vec.
	* configure: Regenerated.

	* cpu-k1om.c: New.

	* elf64-x86-64.c (elf64_k1om_elf_object_p): New.
	(bfd_elf64_k1om_vec): Likewise.
	(bfd_elf64_k1om_freebsd_vec): Likewise.

	* targets.c (bfd_elf64_k1om_vec): New.
	(bfd_elf64_k1om_freebsd_vec): Likewise.
	(_bfd_target_vector): Add bfd_elf64_k1om_vec and
	bfd_elf64_k1om_freebsd_vec.

binutils/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* dwarf.c (init_dwarf_regnames): Handle EM_K1OM.

	* elfedit.c (elf_machine): Support EM_K1OM.
	(elf_class): Likewise.

	* readelf.c (guess_is_rela): Handle EM_K1OM.
	(dump_relocations): Likewise.
	(get_machine_name): Likewise.
	(get_section_type_name): Likewise.
	(get_elf_section_flags): Likewise.
	(process_section_headers): Likewise.
	(get_symbol_index_type): Likewise.
	(is_32bit_abs_reloc): Likewise.
	(is_32bit_pcrel_reloc): Likewise.
	(is_64bit_abs_reloc): Likewise.
	(is_64bit_pcrel_reloc): Likewise.
	(is_none_reloc): Likewise.

	* doc/binutils.texi: Mention K1OM for elfedit.

binutils/testsuite/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* binutils-all/elfedit.exp: Run elfedit-4.

	* binutils-all/elfedit-4.d: New.

gas/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (cpu_arch): Add k1om.
	(i386_align_code): Handle PROCESSOR_K1OM.
	(check_cpu_arch_compatible): Check EM_K1OM.
	(i386_arch): Handle Intel K1OM.
	(i386_mach): Return bfd_mach_k1om for Intel K1OM.
	(i386_target_format): Return ELF_TARGET_K1OM_FORMAT for Intel
	K1OM.

	* config/tc-i386.h (ELF_TARGET_K1OM_FORMAT): New.
	(processor_type): Add PROCESSOR_K1OM.

	* doc/c-i386.texi: Document k1om.

gas/testsuite/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/k1om.d: New.
	* gas/i386/k1om-inval.l: Likewise.
	* gas/i386/k1om-inval.s: Likewise.

	* gas/i386/i386.exp: Run k1om-inval and k1om.

include/elf/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* common.h (EM_K1OM): New.

ld/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.am (ALL_64_EMULATIONS): Add eelf_k1om.o and
	eelf_k1om_fbsd.o
	(eelf_k1om.c): New.
	(eelf_k1om_fbsd.c): Likewise.
	* Makefile.in: Regenerated.

	* configure.tgt (targ64_extra_emuls): Add elf_k1om if elf_x86_64
	is supported.  Add elf_k1om_fbsd if elf_x86_64_fbsd is supported.
	(targ_extra_emuls): Likewise.

	* emulparams/elf_k1om.sh: New.
	* emulparams/elf_k1om_fbsd.sh: Likewise.

ld/testsuite/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-x86-64/abs-k1om.d: New.
	* ld-x86-64/protected2-k1om.d: Likewise.
	* ld-x86-64/protected3-k1om.d: Likewise.

	* ld-x86-64/x86-64.exp: Run abs-k1om, protected2-k1om and
	protected3-k1om.

opcodes/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* configure.in: Handle bfd_k1om_arch.
	* configure: Regenerated.

	* disassemble.c (disassembler): Handle bfd_k1om_arch.

	* i386-dis.c (print_insn): Handle bfd_mach_k1om and
	bfd_mach_k1om_intel_syntax.

	* i386-gen.c (cpu_flag_init): Set CPU_UNKNOWN_FLAGS to
	~(CpuL1OM|CpuK1OM).  Add CPU_K1OM_FLAGS.
	(cpu_flags): Add CpuK1OM.

	* i386-opc.h (CpuK1OM): New.
	(i386_cpu_flags): Add cpuk1om.

	* i386-init.h: Regenerated.
	* i386-tbl.h: Likewise.
@
text
@d2431 3
d8685 14
a8698 5
    case STO_OPTIONAL:  return "OPTIONAL";
    case STO_MIPS16:    return "MIPS16";
    case STO_MIPS_PLT:	return "MIPS PLT";
    case STO_MIPS_PIC:	return "MIPS PIC";
    default:      	return NULL;
@


1.550
log
@ELFOSABI_GNU

	bfd/
	* elf.c (_bfd_elf_set_osabi): Use ELFOSABI_GNU name instead of
	ELFOSABI_LINUX alias.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf64-hppa.c: Likewise.

	binutils/
	* elfedit.c (osabis): Use ELFOSABI_GNU name instead of ELFOSABI_LINUX
	alias and ELFOSABI_HURD.  Add GNU alias.
	* readelf.c (get_osabi_name, get_symbol_binding, get_symbol_type):
	Likewise.
	* doc/binutils.texi <elfedit>: Update accordingly.

	elfcpp/
	* elfcpp.h (ELFOSABI): Add ELFOSABI_GNU with value of ELFOSABI_LINUX,
	keep ELFOSABI_LINUX as an alias.  Remove ELFOSABI_HURD.

	gas/
	* config/obj-elf.c (obj_elf_type): Use ELFOSABI_GNU name instead of
	ELFOSABI_LINUX alias.
	* config/tc-ia64.c: Likewise.

	include/elf/
	* common.h (ELFOSABI_GNU): Define, replaces...
	(ELFOSABI_LINUX): ... this, kept as an alias.
	(ELFOSABI_HURD): Remove.

	ld/testsuite/
	* ld-ifunc/ifunc.exp: Update for changed output.
	* ld-unique/unique.exp: Likewise.
@
text
@d610 1
d1142 1
d1336 2
a1337 1
				|| elf_header.e_machine == EM_L1OM)
d1905 1
d3050 1
d4302 1
d4354 2
a4355 1
		   || elf_header.e_machine == EM_L1OM)
d4745 1
d4874 2
a4875 1
	  || elf_header.e_machine == EM_L1OM)
d8795 2
a8796 1
		|| elf_header.e_machine == EM_L1OM)
d9769 1
d9828 1
d9865 1
d9901 1
d9995 1
@


1.549
log
@	* readelf.c (get_section_type_name): When displaying an unknown
	section type display the hex value first on the assumption that
	the full message will probably be truncated into a 15 character
	field.
@
text
@d2615 1
a2615 2
    case ELFOSABI_LINUX:	return "UNIX - Linux";
    case ELFOSABI_HURD:		return "GNU/Hurd";
d8589 2
a8590 2
	      && (elf_header.e_ident[EI_OSABI] == ELFOSABI_LINUX
		  /* GNU/Linux is still using the default value 0.  */
d8642 2
a8643 2
	      && (elf_header.e_ident[EI_OSABI] == ELFOSABI_LINUX
		  /* GNU/Linux is still using the default value 0.  */
@


1.548
log
@include/elf/
	* common.h (NT_ARM_VFP): Define.

bfd/
	* elf-bfd.h (elfcore_write_arm_vfp): Add prototype.
	* elf.c (elfcore_grok_arm_vfp): New function.
	(elfcore_grok_note): Call it to handle NT_ARM_VFP notes.
	(elfcore_write_arm_vfp): New function.
	(elfcore_write_register_note): Call it to handle .reg-arm-vfp.

binutils/
	* readelf.c (get_note_type): Handle NT_ARM_VFP.
@
text
@d3087 3
a3089 1
	snprintf (buff, sizeof (buff), _("<unknown>: %x"), sh_type);
@


1.547
log
@    * Makefile.am (ALL_MACHINES): Add cpu-tilegx.lo and cpu-tilepro.lo.
    (ALL_MACHINE_CFILES): Add cpu-tilegx.c and cpu-tilepro.c.
    (BFD32_BACKENDS): Add elf32-tilegx.lo, elf32-tilepro.lo,
    and elfxx-tilegx.lo.
    (BFD32_BACKENDS_CFILES): Add elf32-tilegx.c elf32-tilepro.c, and
    elfxx-tilegx.c.
    (BFD64_BACKENDS): Add elf64-tilegx.lo.
    (BFD64_BACKENDS_CFILES): Add elf64-tilegx.c.
    * Makefile.in: Regenerate.
    * arctures.c (bfd_architecture): Define bfd_arch_tilepro,
    bfd_arch_tilegx, bfd_mach_tilepro, bfd_mach_tilegx.
    (bfd_arch_info): Add bfd_tilegx_arch, bfd_tilepro_arch.
    (bfd_archures_list): Add bfd_tilegx_arch, bfd_tilepro_arch.
    bfd-in2.h: Regenerate.
    * config.bfd: Handle tilegx-*-* and tilepro-*-*.
    * configure.in: Handle bfd_elf32_tilegx_vec, bfd_elf32_tilepro_vec,
    and bfd_elf64_tilegx_vec.
    * configure: Regenerate.
    * elf-bfd.h (enum elf_target_id): Define TILEGX_ELF_DATA and
    TILEPRO_ELF_DATA.
    * libbfd.h: Regenerate.
    * reloc.c: Add BFD_RELOC_TILEPRO_{COPY, GLOB_DAT, JMP_SLOT,
    RELATIVE, BROFF_X1, JOFFLONG_X1, JOFFLONG_X1_PLT, IMM8_X0,
    IMM8_Y0, IMM8_X1, IMM8_Y1, DEST_IMM8_X1, MT_IMM15_X1, MF_IMM15_X1,
    IMM16_X0, IMM16_X1, IMM16_X0_LO, IMM16_X1_LO, IMM16_X0_HI,
    IMM16_X1_HI, IMM16_X0_HA, IMM16_X1_HA, IMM16_X0_PCREL,
    IMM16_X1_PCREL, IMM16_X0_LO_PCREL, IMM16_X1_LO_PCREL,
    IMM16_X0_HI_PCREL, IMM16_X1_HI_PCREL, IMM16_X0_HA_PCREL,
    IMM16_X1_HA_PCREL, IMM16_X0_GOT, IMM16_X1_GOT, IMM16_X0_GOT_LO,
    IMM16_X1_GOT_LO, IMM16_X0_GOT_HI, IMM16_X1_GOT_HI,
    IMM16_X0_GOT_HA, IMM16_X1_GOT_HA, MMSTART_X0, MMEND_X0,
    MMSTART_X1, MMEND_X1, SHAMT_X0, SHAMT_X1, SHAMT_Y0, SHAMT_Y1,
    IMM16_X0_TLS_GD, IMM16_X1_TLS_GD, IMM16_X0_TLS_GD_LO,
    IMM16_X1_TLS_GD_LO, IMM16_X0_TLS_GD_HI, IMM16_X1_TLS_GD_HI,
    IMM16_X0_TLS_GD_HA, IMM16_X1_TLS_GD_HA, IMM16_X0_TLS_IE,
    IMM16_X1_TLS_IE, IMM16_X0_TLS_IE_LO, IMM16_X1_TLS_IE_LO,
    IMM16_X0_TLS_IE_HI, IMM16_X1_TLS_IE_HI, IMM16_X0_TLS_IE_HA,
    IMM16_X1_TLS_IE_HA, TLS_DTPMOD32, TLS_DTPOFF32, TLS_TPOFF32}
    Add BFD_RELOC_TILEGX_{HW0, HW1, HW2, HW3, HW0_LAST, HW1_LAST,
    HW2_LAST, COPY, GLOB_DAT, JMP_SLOT, RELATIVE, BROFF_X1,
    JUMPOFF_X1, JUMPOFF_X1_PLT, IMM8_X0, IMM8_Y0, IMM8_X1, IMM8_Y1,
    DEST_IMM8_X1, MT_IMM14_X1, MF_IMM14_X1, MMSTART_X0, MMEND_X0,
    SHAMT_X0, SHAMT_X1, SHAMT_Y0, SHAMT_Y1, IMM16_X0_HW0,
    IMM16_X1_HW0, IMM16_X0_HW1, IMM16_X1_HW1, IMM16_X0_HW2,
    IMM16_X1_HW2, IMM16_X0_HW3, IMM16_X1_HW3, IMM16_X0_HW0_LAST,
    IMM16_X1_HW0_LAST, IMM16_X0_HW1_LAST, IMM16_X1_HW1_LAST,
    IMM16_X0_HW2_LAST, IMM16_X1_HW2_LAST, IMM16_X0_HW0_PCREL,
    IMM16_X1_HW0_PCREL, IMM16_X0_HW1_PCREL, IMM16_X1_HW1_PCREL,
    IMM16_X0_HW2_PCREL, IMM16_X1_HW2_PCREL, IMM16_X0_HW3_PCREL,
    IMM16_X1_HW3_PCREL, IMM16_X0_HW0_LAST_PCREL,
    IMM16_X1_HW0_LAST_PCREL, IMM16_X0_HW1_LAST_PCREL,
    IMM16_X1_HW1_LAST_PCREL, IMM16_X0_HW2_LAST_PCREL,
    IMM16_X1_HW2_LAST_PCREL, IMM16_X0_HW0_GOT, IMM16_X1_HW0_GOT,
    IMM16_X0_HW1_GOT, IMM16_X1_HW1_GOT, IMM16_X0_HW2_GOT,
    IMM16_X1_HW2_GOT, IMM16_X0_HW3_GOT, IMM16_X1_HW3_GOT,
    IMM16_X0_HW0_LAST_GOT, IMM16_X1_HW0_LAST_GOT,
    IMM16_X0_HW1_LAST_GOT, IMM16_X1_HW1_LAST_GOT,
    IMM16_X0_HW2_LAST_GOT, IMM16_X1_HW2_LAST_GOT, IMM16_X0_HW0_TLS_GD,
    IMM16_X1_HW0_TLS_GD, IMM16_X0_HW1_TLS_GD, IMM16_X1_HW1_TLS_GD,
    IMM16_X0_HW2_TLS_GD, IMM16_X1_HW2_TLS_GD, IMM16_X0_HW3_TLS_GD,
    IMM16_X1_HW3_TLS_GD, IMM16_X0_HW0_LAST_TLS_GD,
    IMM16_X1_HW0_LAST_TLS_GD, IMM16_X0_HW1_LAST_TLS_GD,
    IMM16_X1_HW1_LAST_TLS_GD, IMM16_X0_HW2_LAST_TLS_GD,
    IMM16_X1_HW2_LAST_TLS_GD, IMM16_X0_HW0_TLS_IE,
    IMM16_X1_HW0_TLS_IE, IMM16_X0_HW1_TLS_IE, IMM16_X1_HW1_TLS_IE,
    IMM16_X0_HW2_TLS_IE, IMM16_X1_HW2_TLS_IE, IMM16_X0_HW3_TLS_IE,
    IMM16_X1_HW3_TLS_IE, IMM16_X0_HW0_LAST_TLS_IE,
    IMM16_X1_HW0_LAST_TLS_IE, IMM16_X0_HW1_LAST_TLS_IE,
    IMM16_X1_HW1_LAST_TLS_IE, IMM16_X0_HW2_LAST_TLS_IE,
    IMM16_X1_HW2_LAST_TLS_IE, TLS_DTPMOD64, TLS_DTPOFF64, TLS_TPOFF64,
    TLS_DTPMOD32, TLS_DTPOFF32, TLS_TPOFF32}
    * targets.c (bfd_elf32_tilegx_vec): Declare.
    (bfd_elf32_tilepro_vec): Declare.
    (bfd_elf64_tilegx_vec): Declare.
    (bfd_target_vector): Add bfd_elf32_tilegx_vec, bfd_elf32_tilepro_vec,
    and bfd_elf64_tilegx_vec.
    * cpu-tilegx.c: New file.
    * cpu-tilepro.c: New file.
    * elf32-tilepro.h: New file.
    * elf32-tilepro.c: New file.
    * elf32-tilegx.c: New file.
    * elf32-tilegx.h: New file.
    * elf64-tilegx.c: New file.
    * elf64-tilegx.h: New file.
    * elfxx-tilegx.c: New file.
    * elfxx-tilegx.h: New file.

	* Makefile.am (TARGET_CPU_CFILES): Add config/tc-tilegx.c and
	config/tc-tilepro.c.
	(TARGET_CPU_HFILES): Add config/tc-tilegx.h and
	config/tc-tilepro.h.
	* Makefile.in: Regenerate.
	* configure.tgt (tilepro-*-*): New.
	(tilegx-*-*): Likewise.
	* config/tc-tilegx.c: New file.
	* config/tc-tilegx.h: Likewise.
	* config/tc-tilepro.h: Likewise.
	* config/tc-tilepro.c: Likewise.
	* doc/Makefile.am (CPU_DOCS): Add c-tilegx.texi and
	c-tilepro.texi.
	* doc/Makefile.in: Regenerate.
	* doc/all.texi (TILEGX): Define.
	(TILEPRO): Define.
	* doc/as.texinfo: Add Tile-Gx and TILEPro documentation.  Include
	c-tilegx.texi and c-tilepro.texi.
	* doc/c-tilegx.texi: New.
	* doc/c-tilepro.texi: New.

        * gas/tilepro/t_constants.s: New file.
	* gas/tilepro/t_constants.d: Likewise.
	* gas/tilepro/t_insns.s: Likewise.
	* gas/tilepro/tilepro.exp: Likewise.
	* gas/tilepro/t_insns.d: Likewise.
	* gas/tilegx/tilegx.exp: Likewise.
	* gas/tilegx/t_insns.d: Likewise.
	* gas/tilegx/t_insns.s: Likewise.

	* dis-asm.h (print_insn_tilegx): Declare.
	(print_insn_tilepro): Likewise.

	* tilegx.h: New file.
	* tilepro.h: New file.

	* common.h: Add EM_TILEGX.
	* tilegx.h: New file.
	* tilepro.h: New file.

	* Makefile.am (ALL_EMULATION_SOURCES): Add eelf32tilegx.c and
	eelf32tilepro.c.
	(ALL_64_EMULATION_SOURCES): Add eelf64tilegx.c.
	(eelf32tilegx.c): New target.
	(eelf32tilepro.c): Likewise.
	(eelf64tilegx.c): Likewise.
	* Makefile.in: Regenerate.
	* configure.tgt: Handle tilegx-*-* and tilepro-*-*.
	* emulparams/elf32tilegx.sh: New file.
	* emulparams/elf64tilegx.sh: New file.
	* emulparams/elf32tilepro.sh: New file.

	* ld-elf/eh5.d: Don't run on tile*.
	* ld-srec/srec.exp: xfail on tile*.
	* ld-tilegx/external.s: New file.
	* ld-tilegx/reloc.d: New file.
	* ld-tilegx/reloc.s: New file.
	* ld-tilegx/tilegx.exp: New file.
	* ld-tilepro/external.s: New file.
	* ld-tilepro/reloc.d: New file.
	* ld-tilepro/reloc.s: New file.
	* ld-tilepro/tilepro.exp: New file.

	* Makefile.am (TARGET_LIBOPCODES_CFILES): Add tilegx-dis.c,
	tilegx-opc.c, tilepro-dis.c, and tilepro-opc.c.
	* Makefile.in: Regenerate.
	* configure.in: Handle bfd_tilegx_arch and bfd_tilepro_arch.
	* configure: Regenerate.
	* disassemble.c (disassembler): Add ARCH_tilegx and ARCH_tilepro.
	* po/POTFILES.in: Regenerate.
	* tilegx-dis.c: New file.
	* tilegx-opc.c: New file.
	* tilepro-dis.c: New file.
	* tilepro-opc.c: New file.
@
text
@d12287 2
@


1.546
log
@	PR binutils/12855
	* readelf.c (process_version_sections): Handle binaries containing
	corrupt version information.
	(process_symbol_table): Stop processing a symbol's version
	information if it could not be read in.

	(get_data): Add comment describing the function.
	(process_section_headers): Set dynamic_strings_length to 0 if the
	dynamic strings could not be read in.
	(process_dynamic_section): Likewise.
	(process_section_groups): Stop processing the group information if
	the data could not be read in.
	(hppa_processs_unwind): Assert that there is only one string table
	in the file.
	(arm_process_unwind): Likewise.
	(ia64_process_unwind): Likewise.
	Set the size of the unwind auxillary information to 0 if the data
	could not be read.
	(load_specific_debug_section): Handle a failure to read in the
	section.
	(process_mips_specific): Stop display of the PLT GOT section if it
	could not be read in.
@
text
@d143 2
d603 2
d1226 8
d1980 1
d9747 4
d9810 4
d9855 3
a9857 1
      return reloc_type == 22;	/* R_S390_64 */
d9859 1
a9859 1
      return reloc_type == 18;	/* R_MIPS_64 */
d9874 1
a9874 1
      return reloc_type == 11; /* R_ALPHA_SREL64 */
d9876 1
a9876 1
      return reloc_type == 0x4f; /* R_IA64_PCREL64LSB */
d9878 1
a9878 1
      return reloc_type == 72; /* R_PARISC_PCREL64 */
d9880 1
a9880 1
      return reloc_type == 44; /* R_PPC64_REL64 */
d9884 1
a9884 1
      return reloc_type == 46; /* R_SPARC_DISP64 */
d9887 1
a9887 1
      return reloc_type == 24; /* R_X86_64_PC64 */
d9890 3
a9892 1
      return reloc_type == 23;	/* R_S390_PC64 */
d9984 2
@


1.545
log
@	* NEWS: Add note about --dwarf-depth, --dwarf-start, and
	dwarf-mode.el.
	* objdump.c (suppress_bfd_header): New global.
	(usage): Update.
	(OPTION_DWARF_DEPTH, OPTION_DWARF_START): New constants.
	(options): Add dwarf-depth and dwarf-start entries.
	(dump_bfd): Use suppress_bfd_header.
	(main): Handle OPTION_DWARF_START, OPTION_DWARF_DEPTH.
	* doc/binutils.texi (objcopy): Document --dwarf-depth and
	--dwarf-start.
	(readelf): Likewise.
	* dwarf-mode.el: New file.
	* dwarf.c (dwarf_cutoff_level, dwarf_start_die): New globals.
	(read_and_display_attr_value): Also check debug_info_p.
	(process_debug_info): Handle dwarf_start_die and
	dwarf_cutoff_level.
	* dwarf.h (dwarf_cutoff_level, dwarf_start_die): Declare.
	* readelf.c (usage): Update.
	(OPTION_DWARF_DEPTH): New macro.
	(OPTION_DWARF_START): Likewise.
	(options): Add dwarf-depth and dwarf-start entries.
	(parse_args): Handle OPTION_DWARF_START and OPTION_DWARF_DEPTH.
testsuite
	* binutils-all/objdump.W: Correct output.
@
text
@d289 6
d4557 1
a4557 1
	  dynamic_strings_length = section->sh_size;
d5038 2
d5745 1
a5827 1
	  aux.info_size = sec->sh_size;
d5830 1
a5830 1
                                                 aux.info_size,
d5832 1
d6159 1
a6285 1

d7044 1
d7554 1
a7554 1
	  dynamic_strings_length = str_tab_len;
a8091 1
	    endbuf = (char *) edefs + section->sh_size;
d8094 1
a8210 1
	    endbuf = (char *) eneed + section->sh_size;
d8213 1
d8429 4
a8432 3
			      get_data (&evn, file, offset, sizeof (evn), 1,
					_("version need"));

d8440 11
a8450 5
				  get_data (&evna, file, a_off, sizeof (evna),
					    1, _("version need aux (2)"));

				  ivna.vna_next  = BYTE_GET (evna.vna_next);
				  ivna.vna_other = BYTE_GET (evna.vna_other);
d8491 11
a8501 5
			      get_data (&evd, file, offset, sizeof (evd), 1,
					_("version def"));

			      ivd.vd_next = BYTE_GET (evd.vd_next);
			      ivd.vd_ndx  = BYTE_GET (evd.vd_ndx);
d8515 5
a8519 4
			      get_data (&evda, file,
					offset - ivd.vd_next + ivd.vd_aux,
					sizeof (evda), 1,
					_("version def aux"));
d9180 2
a9181 2
	      if (section->sh_type == SHT_DYNSYM &&
		  version_info[DT_VERSIONTAGIDX (DT_VERSYM)] != 0)
d9193 3
a9195 2
		  get_data (&data, file, offset + si * sizeof (vers_data),
			    sizeof (data), 1, _("version data"));
d9223 8
a9230 2
			      get_data (&evn, file, offset, sizeof (evn), 1,
					_("version need"));
d9241 14
a9254 7
				  get_data (&evna, file, vna_off,
					    sizeof (evna), 1,
					    _("version need aux (3)"));

				  ivna.vna_other = BYTE_GET (evna.vna_other);
				  ivna.vna_next  = BYTE_GET (evna.vna_next);
				  ivna.vna_name  = BYTE_GET (evna.vna_name);
d9301 13
a9313 6
				  get_data (&evd, file, off, sizeof (evd),
					    1, _("version def"));

				  ivd.vd_ndx = BYTE_GET (evd.vd_ndx);
				  ivd.vd_aux = BYTE_GET (evd.vd_aux);
				  ivd.vd_next = BYTE_GET (evd.vd_next);
d9323 3
a9325 2
			      get_data (&evda, file, off, sizeof (evda),
					1, _("version def aux"));
a10409 1
  section->size = sec->sh_size;
d10413 8
a10420 2
  if (uncompress_section_contents (&section->start, &section->size))
    sec->sh_size = section->size;
d11988 3
d12087 3
a12167 2
	  strtab_size = string_sec->sh_size;

d12175 1
@


1.544
log
@	* readelf.c (print_stapsdt_note): New function.
	(process_note): Use it.
@
text
@d3076 2
d3111 3
d3157 4
d3367 14
@


1.543
log
@	* readelf.c (get_stapsdt_note_type): New function.
	(process_note): Recognize "stapsdt" notes.
@
text
@d12371 37
d12568 2
@


1.542
log
@	* readelf.c (process_corefile_note_segment): Change header field
	widths.
	(process_note): Change field widths.
@
text
@d12354 18
d12517 3
@


1.541
log
@	* readelf.c (print_gnu_note): New function.
	(process_note): Use it.
@
text
@d12504 1
a12504 1
  printf ("  %-10s\t0x%08lx\t%s\n", name, pnote->descsz, nt);
d12534 1
a12534 1
  printf (_("  Owner\t\tData size\tDescription\n"));
@


1.540
log
@2011-04-07  Paul Brook  <paul@@codesourcery.com>

	binutils/
	* readelf.c (arm_section_get_word): Handle C6000 relocations.
	(decode_tic6x_unwind_regmask, decode_arm_unwind_bytecode,
	decode_tic6x_unwind_bytecode, expand_prel31): New functions.
	(decode_arm_unwind): Split out common code from ARM specific bits.
	(dump_arm_unwind): Use expand_prel31.
	(arm_process_unwind): Handle SHT_C6000_UNWIND sections.
	(process_unwind): Add SHT_C6000_UNWIND.
@
text
@d12234 57
d12508 2
@


1.539
log
@include/elf/
	* tic6x.h (R_C6000_JUMP_SPLOT, R_C6000_EHTYPE,
	R_C6000_PCR_H16, R_C6000_PCR_L16): New relocs.
	(SHN_TIC6X_SCOMMON): Define.

bfd/
	* elf32-tic6x.h (struct elf32_tic6x_params): New.
	(elf32_tic6x_setup): Declare.
	* elf32-tic6x.c: Include <limits.h>.
	(ELF_DYNAMIC_LINKER, DEFAULT_STACK_SIZE, PLT_ENTRY_SIZE): Define.
	(struct elf32_tic6x_link_hash_table, struct elf32_link_hash_entry):
	New structures.
	(elf32_tic6x_link_hash_table, is_tic6x_elf): New macros.
	(tic6x_elf_scom_section, tic6x_elf_scom_symbol,
	tic6x_elf_scom_symbol_ptr): New static variables.
	(elf32_tic6x_howto_table, elf32_tic6x_howto_table_rel,
	elf32_tic6x_reloc_map): Add R_C6000_JUMP_SLOT, R_C6000_EHTYPE,
	R_C6000_PCR_H16 and R_C6000_PCR_L16.
	(elf32_tic6x_link_hash_newfunc, elf32_tic6x_link_hash_table_create,
	elf32_tic6x_link_hash_table_free, elf32_tic6x_setup,
	elf32_tic6x_using_dsbt, elf32_tic6x_install_rela,
	elf32_tic6x_create_dynamic_sections, elf32_tic6x_make_got_dynreloc,
	elf32_tic6x_finish_dynamic_symbol, elf32_tic6x_gc_sweep_hook,
	elf32_tic6x_adjust_dynamic_symbol): New static functions.
	(elf32_tic6x_relocate_section): For R_C6000_PCR_S21, convert branches
	to weak symbols as required by the ABI.
	Handle GOT and DSBT_INDEX relocs, and copy relocs to the output file
	as needed when generating DSBT output.
	(elf32_tic6x_check_relocs, elf32_tic6x_add_symbol_hook,
	elf32_tic6x_symbol_processing, elf32_tic6x_section_from_bfd_section,
	elf32_tic6x_allocate_dynrelocs, elf32_tic6x_size_dynamic_sections,
	elf32_tic6x_always_size_sections, elf32_tic6x_modify_program_headers,
	elf32_tic6x_finish_dynamic_sections, elf32_tic6x_plt_sym_val,
	elf32_tic6x_copy_private_data, elf32_tic6x_link_omit_section_dynsym):
	New static functions.
	(ELF_MAXPAGESIZE): Define to 0x1000.
	(bfd_elf32_bfd_copy_private_bfd_data,
	bfd_elf32_bfd_link_hash_table_create,
	bfd_elf32_bfd_link_hash_table_free, elf_backend_can_refcount,
	elf_backend_want_got_plt, elf_backend_want_dynbss,
	elf_backend_plt_readonly, elf_backend_got_header_size,
	elf_backend_gc_sweep_hook, elf_backend_modify_program_headers,
	elf_backend_create_dynamic_sections, elf_backend_adjust_dynamic_symbol,
	elf_backend_check_relocs, elf_backend_add_symbol_hook,
	elf_backend_symbol_processing, elf_backend_link_output_symbol_hook,
	elf_backend_section_from_bfd_section,
	elf_backend_finish_dynamic_symbol, elf_backend_always_size_sections,
	elf32_tic6x_size_dynamic_sections, elf_backend_finish_dynamic_sections,
	elf_backend_omit_section_dynsym, elf_backend_plt_sym_val): Define.

	* bfd/reloc.c (BFD_RELOC_C6000_JUMP_SLOT, BFD_RELOC_C6000_EHTYPE,
	BFD_RELOC_C6000_PCR_H16, BFD_RELOC_C6000_PCR_S16): Add.
	* bfd/bfd-in2.h: Regenerate.
	* bfd/libbfd.h: Regenerate.
	* config.bfd: Accept tic6x-*-* instead of tic6x-*-elf.

gas/
	* config/tc-tic6x.c (sbss_section, scom_section, scom_symbol): New
	static variables.
	(md_begin): Initialize them.
	(s_tic6x_scomm): New static function.
	(md_pseudo_table): Add "scomm".
	(tc_gen_reloc): Really undo all adjustments made by
	bfd_install_relocation.
	* doc/c-tic6x.texi: Document the .scomm directive.

gas/testsuite/
	* gas/tic6x/scomm-directive-1.s: New test.
	* gas/tic6x/scomm-directive-1.d: New test.
	* gas/tic6x/scomm-directive-2.s: New test.
	* gas/tic6x/scomm-directive-2.d: New test.
	* gas/tic6x/scomm-directive-3.s: New test.
	* gas/tic6x/scomm-directive-3.d: New test.
	* gas/tic6x/scomm-directive-4.s: New test.
	* gas/tic6x/scomm-directive-4.d: New test.
	* gas/tic6x/scomm-directive-5.s: New test.
	* gas/tic6x/scomm-directive-5.d: New test.
	* gas/tic6x/scomm-directive-6.s: New test.
	* gas/tic6x/scomm-directive-6.d: New test.
	* gas/tic6x/scomm-directive-7.s: New test.
	* gas/tic6x/scomm-directive-7.d: New test.
	* gas/tic6x/scomm-directive-8.s: New test.
	* gas/tic6x/scomm-directive-8.d: New test.

ld/
	* emulparams/elf32_tic6x_le.sh (BIG_OUTPUT_FORMAT, EXTRA_EM_FILE,
	GENERATE_SHLIB_SCRIPT): New defines.
	(TEXT_START_ADDR): Define differently depending on target.
	(.got): Redefine to include "*(.dsbt)".
	(SDATA_START_SYMBOLS): Remove, replace with
	(OTHER_GOT_SYMBOLS): New.
	(OTHER_BSS_SECTIONS): Define only for ELF targets.
	* emultempl/tic6xdsbt.em: New file.
	* gen-doc.texi: Set C6X.
	* ld.texinfo: Likewise.
	(Options specific to C6X uClinux targets): New section.

binutils/
	* readelf.c (get_symbol_index_type): Handle SCOM for TIC6X.
	(dump_relocations): Likewise.

binutils/testsuite/
	* lib/binutils-common.exp (is_elf_format): Accept tic6x*-*-uclinux*.

ld/testsuite/
	* ld-scripts/crossref.exp: Add CFLAGS for tic6x*-*-*.
	* ld-elf/sec-to-seg.exp: Remove tic6x from list of targets defining
	pagesize to 1.
	* ld-tic6x/tic6x.exp: Add support for DSBT shared library/executable
	linking tests.
	* ld-tic6x/dsbt.ld: New linker script.
	* ld-tic6x/dsbt-be.ld: New linker script.
	* ld-tic6x/dsbt-overflow.ld: New linker script.
	* ld-tic6x/dsbt-inrange.ld: New linker script.
	* ld-tic6x/shlib-1.s: New test.
	* ld-tic6x/shlib-2.s: New test.
	* ld-tic6x/shlib-app-1r.s: New test.
	* ld-tic6x/shlib-app-1.s: New test.
	* ld-tic6x/shlib-1.sd: New test.
	* ld-tic6x/shlib-1.dd: New test.
	* ld-tic6x/shlib-app-1.rd: New test.
	* ld-tic6x/shlib-app-1rb.rd: New test.
	* ld-tic6x/shlib-app-1.sd: New test.
	* ld-tic6x/static-app-1rb.od: New test.
	* ld-tic6x/shlib-app-1.dd: New test.
	* ld-tic6x/shlib-app-1rb.sd: New test.
	* ld-tic6x/static-app-1b.od: New test.
	* ld-tic6x/static-app-1r.od: New test.
	* ld-tic6x/shlib-1rb.rd: New test.
	* ld-tic6x/shlib-app-1rb.dd: New test.
	* ld-tic6x/shlib-1rb.sd: New test.
	* ld-tic6x/shlib-1rb.dd: New test.
	* ld-tic6x/shlib-app-1b.od: New test.
	* ld-tic6x/tic6x.exp: New test.
	* ld-tic6x/static-app-1rb.rd: New test.
	* ld-tic6x/shlib-app-1r.od: New test.
	* ld-tic6x/static-app-1.od: New test.
	* ld-tic6x/static-app-1b.rd: New test.
	* ld-tic6x/static-app-1r.rd: New test.
	* ld-tic6x/static-app-1rb.sd: New test.
	* ld-tic6x/static-app-1b.sd: New test.
	* ld-tic6x/static-app-1rb.dd: New test.
	* ld-tic6x/static-app-1r.sd: New test.
	* ld-tic6x/static-app-1b.dd: New test.
	* ld-tic6x/shlib-1b.rd: New test.
	* ld-tic6x/static-app-1r.dd: New test.
	* ld-tic6x/shlib-app-1b.rd: New test.
	* ld-tic6x/shlib-1r.rd: New test.
	* ld-tic6x/shlib-app-1r.rd: New test.
	* ld-tic6x/shlib-1b.sd: New test.
	* ld-tic6x/static-app-1.rd: New test.
	* ld-tic6x/shlib-app-1b.sd: New test.
	* ld-tic6x/shlib-1r.sd: New test.
	* ld-tic6x/shlib-1b.dd: New test.
	* ld-tic6x/shlib-app-1r.sd: New test.
	* ld-tic6x/shlib-app-1b.dd: New test.
	* ld-tic6x/shlib-1r.dd: New test.
	* ld-tic6x/static-app-1.sd: New test.
	* ld-tic6x/shlib-app-1r.dd: New test.
	* ld-tic6x/static-app-1.dd: New test.
	* ld-tic6x/shlib-noindex.rd: New test.
	* ld-tic6x/shlib-noindex.dd: New test.
	* ld-tic6x/shlib-noindex.sd: New test.
	* ld-tic6x/got-reloc-local-1.s: New test.
	* ld-tic6x/got-reloc-local-2.s: New test.
	* ld-tic6x/got-reloc-local-r.d: New test.
	* ld-tic6x/got-reloc-global.s: New test.
	* ld-tic6x/got-reloc-global-addend-1.d: New test.
	* ld-tic6x/got-reloc-global-addend-1.s: New test.
	* ld-tic6x/got-reloc-global-addend-2.d: New test.
	* ld-tic6x/got-reloc-inrange.d: New test.
	* ld-tic6x/got-reloc-overflow.d: New test.
	* ld-tic6x/got-reloc-global-addend-2.s: New test.
	* ld-tic6x/dsbt-index-error.d: New test.
	* ld-tic6x/dsbt-index.d: New test.
	* ld-tic6x/dsbt-index.s: New test.
	* ld-tic6x/shlib-app-1.od: New test.
	* ld-tic6x/shlib-app-1rb.od: New test.
	* ld-tic6x/shlib-1.rd: New test.
	* ld-tic6x/weak.d: New test.
	* ld-tic6x/weak-be.d: New test.
	* ld-tic6x/weak.s: New test.
 	* ld-tic6x/weak-data.d: New test.
	* ld-tic6x/common.d: New test.
	* ld-tic6x/common.ld: New test.
	* ld-tic6x/common.s: New test.
@
text
@d6314 5
a6318 1
      relname = elf_arm_reloc_type (ELF32_R_TYPE (rp->r_info));
d6320 10
a6329 1
      if (streq (relname, "R_ARM_NONE"))
d6332 2
a6333 1
      if (! streq (relname, "R_ARM_PREL31"))
d6353 3
d6368 5
d6374 1
a6374 4
decode_arm_unwind (struct arm_unw_aux_info *aux,
		   unsigned int word, unsigned int remaining,
		   bfd_vma data_offset, Elf_Internal_Shdr *data_sec,
		   struct arm_section *data_arm_sec)
d6376 12
a6387 3
  int per_index;
  unsigned int more_words;
  struct absaddr addr;
d6415 8
a6422 71
  if (remaining == 0)
    {
      /* Fetch the first word.  */
      if (!arm_section_get_word (aux, data_arm_sec, data_sec, data_offset,
				 &word, &addr))
	return;
      remaining = 4;
    }

  if ((word & 0x80000000) == 0)
    {
      /* Expand prel31 for personality routine.  */
      bfd_vma fn;
      const char *procname;

      fn = word;
      if (fn & 0x40000000)
	fn |= ~ (bfd_vma) 0x7fffffff;
      fn = fn + data_sec->sh_addr + data_offset;

      printf (_("  Personality routine: "));
      procname = arm_print_vma_and_name (aux, fn, addr);
      fputc ('\n', stdout);

      /* The GCC personality routines use the standard compact
	 encoding, starting with one byte giving the number of
	 words.  */
      if (procname != NULL
	  && (const_strneq (procname, "__gcc_personality_v0")
	      || const_strneq (procname, "__gxx_personality_v0")
	      || const_strneq (procname, "__gcj_personality_v0")
	      || const_strneq (procname, "__gnu_objc_personality_v0")))
	{
	  remaining = 0;
	  more_words = 1;
	  ADVANCE;
	  if (!remaining)
	    {
	      printf (_("  [Truncated data]\n"));
	      return;
	    }
	  more_words = word >> 24;
	  word <<= 8;
	  remaining--;
	}
      else
	return;
    }
  else
    {
      per_index = (word >> 24) & 0x7f;
      if (per_index != 0 && per_index != 1 && per_index != 2)
	{
	  printf (_("  [reserved compact index %d]\n"), per_index);
	  return;
	}

      printf (_("  Compact model %d\n"), per_index);
      if (per_index == 0)
	{
	  more_words = 0;
	  word <<= 8;
	  remaining--;
	}
      else
	{
	  more_words = (word >> 16) & 0xff;
	  word <<= 16;
	  remaining -= 2;
	}
    }
d6620 265
d6917 1
a6917 4
      fn = exidx_fn & 0x7fffffff;
      if (fn & 0x40000000)
	fn |= ~ (bfd_vma) 0x7fffffff;
      fn = fn + exidx_sec->sh_addr + 8 * i;
d6939 1
a6939 4
	  table = exidx_entry;
	  if (table & 0x40000000)
	    table |= ~ (bfd_vma) 0x7fffffff;
	  table = table + exidx_sec->sh_addr + 8 * i + 4;
d6973 1
d6982 1
d6987 14
d7016 1
a7016 1
      else if (sec->sh_type == SHT_ARM_EXIDX)
d7025 1
a7025 1
      if (sec->sh_type == SHT_ARM_EXIDX)
d7056 1
@


1.538
log
@binutils/
2011-03-31  Tristan Gingold  <gingold@@adacore.com>

	* readelf.c (get_ia64_vms_note_type): New function.
	(print_ia64_vms_note): Ditto.
	(process_note): Recognize VMS/ia64 specific notes.
	Display them.
	(process_corefile_note_segment): Decode VMS notes.

include/elf
2011-03-31  Tristan Gingold  <gingold@@adacore.com>

	* ia64.h (Elf64_External_VMS_Note): New struct.
	(NT_VMS_MHD, NT_VMS_LNM, NT_VMS_SRC, NT_VMS_TITLE, NT_VMS_EIDC,
	NT_VMS_FPMODE, NT_VMS_LINKTIME, NT_VMS_IMGNAM, NT_VMS_IMGID
	NT_VMS_LINKID, NT_VMS_IMGBID, NT_VMS_GSTNAM, NT_VMS_ORIG_DYN)
	NT_VMS_PATCHTIME) New macros.
@
text
@d1307 4
a1310 2
		      else if (elf_header.e_machine == EM_MIPS
			       && psym->st_shndx == SHN_MIPS_SCOMMON)
d8487 4
a8490 2
      else if (type == SHN_MIPS_SCOMMON
	       && elf_header.e_machine == EM_MIPS)
@


1.537
log
@	* readelf.c (process_gnu_liblist): Stop memory leak.
@
text
@d12051 111
d12193 4
d12200 3
a12202 1
      nt = get_note_type (pnote->type);
d12204 4
a12207 2
  printf ("  %s\t\t0x%08lx\t%s\n", name, pnote->descsz, nt);
  return 1;
d12238 14
a12251 6
      inote.type     = BYTE_GET (external->type);
      inote.namesz   = BYTE_GET (external->namesz);
      inote.namedata = external->name;
      inote.descsz   = BYTE_GET (external->descsz);
      inote.descdata = inote.namedata + align_power (inote.namesz, 2);
      inote.descpos  = offset + (inote.descdata - (char *) pnotes);
d12253 11
a12263 1
      next = (Elf_External_Note *) (inote.descdata + align_power (inote.descsz, 2));
@


1.536
log
@2011-03-07  Michael Snyder  <msnyder@@vmware.com>

	* readelf.c (process_version_sections): Free symbols.
@
text
@d11849 1
d11891 1
@


1.535
log
@	* common.h (EM_V850): V850s now supplied by Renesas.
	* readelf.c (get_machine_name): Update EM_V850 entry.
@
text
@d8056 4
a8059 1
	      break;
d8079 1
@


1.534
log
@	PR binutils/12523
	* readelf.c (process_object): Clear dynamic_info_DT_GNU_HASH.
@
text
@d1839 1
a1839 1
    case EM_V850:		return "NEC v850";
@


1.533
log
@	* readelf.c (decode_arm_unwind): Implement decoding of remaining
	ARM unwind instructions (i.e. VFP/NEON and Intel Wireless MMX).
@
text
@d12380 1
@


1.532
log
@	PR binutils/12467
	* readelf.c (process_program_headers): Issue a warning if there
	are no program headers but the file header has a non-zero program
	header offset.
	(process_section_headers): Issue a warning if there are no section
	headers but the file header has a non-zero section header offset.
	(process_section_groups): Reword the no section message so that it
	can be distinguished from the one issued by process_section_headers.

	* elf.c (assign_file_positions_for_load_sections): Set the program
	header offset and entry size to zero if there are no program
	headers.
@
text
@d281 7
a287 4
#define REMOVE_ARCH_BITS(ADDR) do {		\
    if (elf_header.e_machine == EM_ARM)		\
      (ADDR) &= ~1;				\
  } while (0)
d1885 1
a1885 1
    case EM_XSTORMY16:		return "Sanyo Xstormy16 CPU core";
d6474 1
d6480 1
d6519 1
d6549 1
d6568 1
d6581 45
a6625 1
      else
d6627 3
a6629 5
	  if (op == 0xb3 || op == 0xc6 || op == 0xc7 || op == 0xc8 || op == 0xc9)
	    {
	      GET_OP (op2);
	      printf (_("[unsupported two-byte opcode]"));
	    }
d6632 15
a6646 1
	      printf (_("     [unsupported opcode]"));
d6649 2
@


1.531
log
@	* readelf.c (process_object): Free dynamic_section after use.
@
text
@d3641 5
a3645 1
      if (do_segments)
d4384 5
a4388 1
      if (do_sections)
d4871 1
a4871 1
	printf (_("\nThere are no sections in this file.\n"));
@


1.530
log
@Reset dump_sects after processing each archive member.

2011-01-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/12408
	* readelf.c (process_archive): Free and reset dump_sects
	after processing each archive member.
@
text
@d12408 6
@


1.529
log
@* readelf.c (print_symbol): Handle symbol characters as unsigned.
Whitespace fixes.
@
text
@d12643 7
@


1.528
log
@	* dwarf.c: #include "bfd_stdint.h".
	(do_gdb_index): New global.
	(display_gdb_index): New function.
	(dwarf_select_sections_by_names) Add "gdb_index".
	(dwarf_select_sections_all): Set do_gdb_index.
	(debug_displays): Add .gdb_index.
	* dwarf.h (do_gdb_index): Declare.
	* objdump.c (usage): Add gdb_index.
	* readelf.c (usage): Add gdb_index.
	(process_section_headers): Process ".gdb_index".
	* doc/binutils.texi (readelf): Document gdb_index dump.
	(objdump): Ditto.
@
text
@d3 1
a3 1
   2008, 2009, 2010
d383 1
a383 1
print_symbol (int width, const char * symbol)
d385 1
a385 1
  const char * c;
d391 2
a392 1
      /* Set the width to a very large value.  This simplifies the code below.  */
d411 1
a411 1
      while (ISPRINT (* c))
d427 1
a427 1
      if (* c == 0 || width == 0)
d432 1
a432 1
      if (*c < 32)
d447 1
a447 1
	  printf ("<0x%.2x>", *c);
@


1.527
log
@Add and use elfcomm.c/elfcomm.h.

2010-11-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/12235
	* elfcomm.c: New.
	* elfcomm.h: Likewise.

	* Makefile.am (HFILES): Add elfcomm.h.
	(CFILES): Add elfcomm.c.
	(ELFLIBS): New.
	(readelf_SOURCES): Add $(ELFLIBS).
	(elfedit_SOURCES): Likewise.
	(objdump_SOURCES): Likewise.
	* Makefile.in: Regenerated.

	* dwarf.c: Include "elfcomm.h".
	(byte_get): Removed.
	(byte_get_little_endian): Likewise.
	(byte_get_big_endian): Likewise.
	(byte_get_signed): Likewise.
	(error): Likewise.
	(warn): Likewise.

	* dwarf.h (dwarf_vma): Defined with HOST_WIDEST_INT.
	(dwarf_size_type): Likewise.
	(byte_get): Removed.
	(byte_get_signed): Likewise.
	(byte_get_little_endian): Likewise.
	(byte_get_big_endian): Likewise.
	(error): Likewise.
	(warn): Likewise.

	* elfedit.c: Include "elfcomm.h".  Don't include "aout/ar.h".
	Call error () instead of non_fatal ().
	(streq): Removed.
	(strneq): Likewise.
	(const_strneq): Likewise.
	(non_fatal): Likewise.
	(BYTE_GET): Likewise.
	(BYTE_PUT): Likewise.
	(byte_get): Likewise.
	(byte_put): Likewise.
	(byte_get_little_endian): Likewise.
	(byte_get_big_endian): Likewise.
	(byte_put_little_endian): Likewise.
	(byte_put_big_endian): Likewise.
	(adjust_relative_path): Likewise.
	(archive_info): Likewise.
	(setup_archive): Likewise.
	(release_archive): Likewise.
	(setup_nested_archive): Likewise.
	(get_archive_member_name): Likewise.
	(get_archive_member_name_at): Likewise.
	(make_qualified_name): Likewise.

	* objdump.c: Include "elfcomm.h".

	* readelf.c: Include "elfcomm.h".  Don't include "aout/ar.h".
	(BYTE_GET): Removed.
	(BYTE_GET_SIGNED): Removed.
	(streq): Likewise.
	(strneq): Likewise.
	(const_strneq): Likewise.
	(byte_put): Likewise.
	(byte_put_little_endian): Likewise.
	(byte_put_big_endian): Likewise.
	(adjust_relative_path): Likewise.
	(archive_info): Likewise.
	(setup_archive): Likewise.
	(release_archive): Likewise.
	(setup_nested_archive): Likewise.
	(get_archive_member_name): Likewise.
	(get_archive_member_name_at): Likewise.
	(make_qualified_name): Likewise.
@
text
@d3144 1
a3144 1
               =trace_info,=trace_abbrev,=trace_aranges]\n\
d4567 2
@


1.526
log
@	PR binutils/11742
	* readelf.c (get_archive_member_name): Formatting.  Properly
	handle full size ar_name.
@
text
@d64 1
a149 2
#include "aout/ar.h"

a261 2
static void (* byte_put) (unsigned char *, bfd_vma, int);

a271 3
#define BYTE_GET(field)		byte_get (field, sizeof (field))
#define BYTE_GET_SIGNED(field)	byte_get_signed (field, sizeof (field))

a280 5
/* This is just a bit of syntatic sugar.  */
#define streq(a,b)	  (strcmp ((a), (b)) == 0)
#define strneq(a,b,n)	  (strncmp ((a), (b), (n)) == 0)
#define const_strneq(a,b) (strncmp ((a), (b), sizeof (b) - 1) == 0)

a331 30
static void
byte_put_little_endian (unsigned char * field, bfd_vma value, int size)
{
  switch (size)
    {
    case 8:
      field[7] = (((value >> 24) >> 24) >> 8) & 0xff;
      field[6] = ((value >> 24) >> 24) & 0xff;
      field[5] = ((value >> 24) >> 16) & 0xff;
      field[4] = ((value >> 24) >> 8) & 0xff;
      /* Fall through.  */
    case 4:
      field[3] = (value >> 24) & 0xff;
      /* Fall through.  */
    case 3:
      field[2] = (value >> 16) & 0xff;
      /* Fall through.  */
    case 2:
      field[1] = (value >> 8) & 0xff;
      /* Fall through.  */
    case 1:
      field[0] = value & 0xff;
      break;

    default:
      error (_("Unhandled data length: %d\n"), size);
      abort ();
    }
}

a464 35
static void
byte_put_big_endian (unsigned char * field, bfd_vma value, int size)
{
  switch (size)
    {
    case 8:
      field[7] = value & 0xff;
      field[6] = (value >> 8) & 0xff;
      field[5] = (value >> 16) & 0xff;
      field[4] = (value >> 24) & 0xff;
      value >>= 16;
      value >>= 16;
      /* Fall through.  */
    case 4:
      field[3] = value & 0xff;
      value >>= 8;
      /* Fall through.  */
    case 3:
      field[2] = value & 0xff;
      value >>= 8;
      /* Fall through.  */
    case 2:
      field[1] = value & 0xff;
      value >>= 8;
      /* Fall through.  */
    case 1:
      field[0] = value & 0xff;
      break;

    default:
      error (_("Unhandled data length: %d\n"), size);
      abort ();
    }
}

a12433 426
/* Return the path name for a proxy entry in a thin archive, adjusted relative
   to the path name of the thin archive itself if necessary.  Always returns
   a pointer to malloc'ed memory.  */

static char *
adjust_relative_path (char * file_name, char * name, int name_len)
{
  char * member_file_name;
  const char * base_name = lbasename (file_name);

  /* This is a proxy entry for a thin archive member.
     If the extended name table contains an absolute path
     name, or if the archive is in the current directory,
     use the path name as given.  Otherwise, we need to
     find the member relative to the directory where the
     archive is located.  */
  if (IS_ABSOLUTE_PATH (name) || base_name == file_name)
    {
      member_file_name = (char *) malloc (name_len + 1);
      if (member_file_name == NULL)
        {
          error (_("Out of memory\n"));
          return NULL;
        }
      memcpy (member_file_name, name, name_len);
      member_file_name[name_len] = '\0';
    }
  else
    {
      /* Concatenate the path components of the archive file name
         to the relative path name from the extended name table.  */
      size_t prefix_len = base_name - file_name;
      member_file_name = (char *) malloc (prefix_len + name_len + 1);
      if (member_file_name == NULL)
        {
          error (_("Out of memory\n"));
          return NULL;
        }
      memcpy (member_file_name, file_name, prefix_len);
      memcpy (member_file_name + prefix_len, name, name_len);
      member_file_name[prefix_len + name_len] = '\0';
    }
  return member_file_name;
}

/* Structure to hold information about an archive file.  */

struct archive_info
{
  char * file_name;                     /* Archive file name.  */
  FILE * file;                          /* Open file descriptor.  */
  unsigned long index_num;              /* Number of symbols in table.  */
  unsigned long * index_array;          /* The array of member offsets.  */
  char * sym_table;                     /* The symbol table.  */
  unsigned long sym_size;               /* Size of the symbol table.  */
  char * longnames;                     /* The long file names table.  */
  unsigned long longnames_size;         /* Size of the long file names table.  */
  unsigned long nested_member_origin;   /* Origin in the nested archive of the current member.  */
  unsigned long next_arhdr_offset;      /* Offset of the next archive header.  */
  bfd_boolean is_thin_archive;          /* TRUE if this is a thin archive.  */
  struct ar_hdr arhdr;                  /* Current archive header.  */
};

/* Read the symbol table and long-name table from an archive.  */

static int
setup_archive (struct archive_info * arch, char * file_name, FILE * file,
               bfd_boolean is_thin_archive, bfd_boolean read_symbols)
{
  size_t got;
  unsigned long size;

  arch->file_name = strdup (file_name);
  arch->file = file;
  arch->index_num = 0;
  arch->index_array = NULL;
  arch->sym_table = NULL;
  arch->sym_size = 0;
  arch->longnames = NULL;
  arch->longnames_size = 0;
  arch->nested_member_origin = 0;
  arch->is_thin_archive = is_thin_archive;
  arch->next_arhdr_offset = SARMAG;

  /* Read the first archive member header.  */
  if (fseek (file, SARMAG, SEEK_SET) != 0)
    {
      error (_("%s: failed to seek to first archive header\n"), file_name);
      return 1;
    }
  got = fread (&arch->arhdr, 1, sizeof arch->arhdr, file);
  if (got != sizeof arch->arhdr)
    {
      if (got == 0)
	return 0;

      error (_("%s: failed to read archive header\n"), file_name);
      return 1;
    }

  /* See if this is the archive symbol table.  */
  if (const_strneq (arch->arhdr.ar_name, "/               ")
      || const_strneq (arch->arhdr.ar_name, "/SYM64/         "))
    {
      size = strtoul (arch->arhdr.ar_size, NULL, 10);
      size = size + (size & 1);

      arch->next_arhdr_offset += sizeof arch->arhdr + size;

      if (read_symbols)
	{
	  unsigned long i;
	  /* A buffer used to hold numbers read in from an archive index.
	     These are always 4 bytes long and stored in big-endian format.  */
#define SIZEOF_AR_INDEX_NUMBERS 4
	  unsigned char integer_buffer[SIZEOF_AR_INDEX_NUMBERS];
	  unsigned char * index_buffer;

	  /* Check the size of the archive index.  */
	  if (size < SIZEOF_AR_INDEX_NUMBERS)
	    {
	      error (_("%s: the archive index is empty\n"), file_name);
	      return 1;
	    }

	  /* Read the numer of entries in the archive index.  */
	  got = fread (integer_buffer, 1, sizeof integer_buffer, file);
	  if (got != sizeof (integer_buffer))
	    {
	      error (_("%s: failed to read archive index\n"), file_name);
	      return 1;
	    }
	  arch->index_num = byte_get_big_endian (integer_buffer, sizeof integer_buffer);
	  size -= SIZEOF_AR_INDEX_NUMBERS;

	  /* Read in the archive index.  */
	  if (size < arch->index_num * SIZEOF_AR_INDEX_NUMBERS)
	    {
	      error (_("%s: the archive index is supposed to have %ld entries, but the size in the header is too small\n"),
		     file_name, arch->index_num);
	      return 1;
	    }
	  index_buffer = (unsigned char *)
              malloc (arch->index_num * SIZEOF_AR_INDEX_NUMBERS);
	  if (index_buffer == NULL)
	    {
	      error (_("Out of memory whilst trying to read archive symbol index\n"));
	      return 1;
	    }
	  got = fread (index_buffer, SIZEOF_AR_INDEX_NUMBERS, arch->index_num, file);
	  if (got != arch->index_num)
	    {
	      free (index_buffer);
	      error (_("%s: failed to read archive index\n"), file_name);
	      return 1;
	    }
	  size -= arch->index_num * SIZEOF_AR_INDEX_NUMBERS;

	  /* Convert the index numbers into the host's numeric format.  */
	  arch->index_array = (long unsigned int *)
              malloc (arch->index_num * sizeof (* arch->index_array));
	  if (arch->index_array == NULL)
	    {
	      free (index_buffer);
	      error (_("Out of memory whilst trying to convert the archive symbol index\n"));
	      return 1;
	    }

	  for (i = 0; i < arch->index_num; i++)
	    arch->index_array[i] = byte_get_big_endian ((unsigned char *) (index_buffer + (i * SIZEOF_AR_INDEX_NUMBERS)),
						        SIZEOF_AR_INDEX_NUMBERS);
	  free (index_buffer);

	  /* The remaining space in the header is taken up by the symbol table.  */
	  if (size < 1)
	    {
	      error (_("%s: the archive has an index but no symbols\n"), file_name);
	      return 1;
	    }
	  arch->sym_table = (char *) malloc (size);
	  arch->sym_size = size;
	  if (arch->sym_table == NULL)
	    {
	      error (_("Out of memory whilst trying to read archive index symbol table\n"));
	      return 1;
	    }
	  got = fread (arch->sym_table, 1, size, file);
	  if (got != size)
	    {
	      error (_("%s: failed to read archive index symbol table\n"), file_name);
	      return 1;
	    }
  	}
      else
	{
	  if (fseek (file, size, SEEK_CUR) != 0)
	    {
	      error (_("%s: failed to skip archive symbol table\n"), file_name);
	      return 1;
	    }
	}

      /* Read the next archive header.  */
      got = fread (&arch->arhdr, 1, sizeof arch->arhdr, file);
      if (got != sizeof arch->arhdr)
	{
	  if (got == 0)
            return 0;
	  error (_("%s: failed to read archive header following archive index\n"), file_name);
	  return 1;
	}
    }
  else if (read_symbols)
    printf (_("%s has no archive index\n"), file_name);

  if (const_strneq (arch->arhdr.ar_name, "//              "))
    {
      /* This is the archive string table holding long member names.  */
      arch->longnames_size = strtoul (arch->arhdr.ar_size, NULL, 10);
      arch->next_arhdr_offset += sizeof arch->arhdr + arch->longnames_size;

      arch->longnames = (char *) malloc (arch->longnames_size);
      if (arch->longnames == NULL)
	{
	  error (_("Out of memory reading long symbol names in archive\n"));
	  return 1;
	}

      if (fread (arch->longnames, arch->longnames_size, 1, file) != 1)
	{
	  free (arch->longnames);
	  arch->longnames = NULL;
	  error (_("%s: failed to read long symbol name string table\n"), file_name);
	  return 1;
	}

      if ((arch->longnames_size & 1) != 0)
	getc (file);
    }

  return 0;
}

/* Release the memory used for the archive information.  */

static void
release_archive (struct archive_info * arch)
{
  if (arch->file_name != NULL)
    free (arch->file_name);
  if (arch->index_array != NULL)
    free (arch->index_array);
  if (arch->sym_table != NULL)
    free (arch->sym_table);
  if (arch->longnames != NULL)
    free (arch->longnames);
}

/* Open and setup a nested archive, if not already open.  */

static int
setup_nested_archive (struct archive_info * nested_arch, char * member_file_name)
{
  FILE * member_file;

  /* Have we already setup this archive?  */
  if (nested_arch->file_name != NULL
      && streq (nested_arch->file_name, member_file_name))
    return 0;

  /* Close previous file and discard cached information.  */
  if (nested_arch->file != NULL)
    fclose (nested_arch->file);
  release_archive (nested_arch);

  member_file = fopen (member_file_name, "rb");
  if (member_file == NULL)
    return 1;
  return setup_archive (nested_arch, member_file_name, member_file, FALSE, FALSE);
}

static char *
get_archive_member_name_at (struct archive_info *  arch,
			    unsigned long          offset,
			    struct archive_info *  nested_arch);

/* Get the name of an archive member from the current archive header.
   For simple names, this will modify the ar_name field of the current
   archive header.  For long names, it will return a pointer to the
   longnames table.  For nested archives, it will open the nested archive
   and get the name recursively.  NESTED_ARCH is a single-entry cache so
   we don't keep rereading the same information from a nested archive.  */

static char *
get_archive_member_name (struct archive_info *  arch,
                         struct archive_info *  nested_arch)
{
  unsigned long j, k;

  if (arch->arhdr.ar_name[0] == '/')
    {
      /* We have a long name.  */
      char * endp;
      char * member_file_name;
      char * member_name;

      arch->nested_member_origin = 0;
      k = j = strtoul (arch->arhdr.ar_name + 1, &endp, 10);
      if (arch->is_thin_archive && endp != NULL && * endp == ':')
        arch->nested_member_origin = strtoul (endp + 1, NULL, 10);

      while ((j < arch->longnames_size)
             && (arch->longnames[j] != '\n')
             && (arch->longnames[j] != '\0'))
        j++;
      if (arch->longnames[j-1] == '/')
        j--;
      arch->longnames[j] = '\0';

      if (!arch->is_thin_archive || arch->nested_member_origin == 0)
        return arch->longnames + k;

      /* This is a proxy for a member of a nested archive.
         Find the name of the member in that archive.  */
      member_file_name = adjust_relative_path (arch->file_name,
					       arch->longnames + k, j - k);
      if (member_file_name != NULL
          && setup_nested_archive (nested_arch, member_file_name) == 0)
	{
          member_name = get_archive_member_name_at (nested_arch,
						    arch->nested_member_origin,
						    NULL);
	  if (member_name != NULL)
	    {
	      free (member_file_name);
	      return member_name;
	    }
	}
      free (member_file_name);

      /* Last resort: just return the name of the nested archive.  */
      return arch->longnames + k;
    }

  /* We have a normal (short) name.  */
  for (j = 0; j < sizeof (arch->arhdr.ar_name); j++)
    if (arch->arhdr.ar_name[j] == '/')
      {
	arch->arhdr.ar_name[j] = '\0';
	return arch->arhdr.ar_name;
      }

  /* The full ar_name field is used.  Don't rely on ar_date starting
     with a zero byte.  */
  {
    char *name = xmalloc (sizeof (arch->arhdr.ar_name) + 1);
    memcpy (name, arch->arhdr.ar_name, sizeof (arch->arhdr.ar_name));
    name[sizeof (arch->arhdr.ar_name)] = '\0';
    return name;
  }
}

/* Get the name of an archive member at a given OFFSET within an archive ARCH.  */

static char *
get_archive_member_name_at (struct archive_info * arch,
                            unsigned long         offset,
			    struct archive_info * nested_arch)
{
  size_t got;

  if (fseek (arch->file, offset, SEEK_SET) != 0)
    {
      error (_("%s: failed to seek to next file name\n"), arch->file_name);
      return NULL;
    }
  got = fread (&arch->arhdr, 1, sizeof arch->arhdr, arch->file);
  if (got != sizeof arch->arhdr)
    {
      error (_("%s: failed to read archive header\n"), arch->file_name);
      return NULL;
    }
  if (memcmp (arch->arhdr.ar_fmag, ARFMAG, 2) != 0)
    {
      error (_("%s: did not find a valid archive header\n"), arch->file_name);
      return NULL;
    }

  return get_archive_member_name (arch, nested_arch);
}

/* Construct a string showing the name of the archive member, qualified
   with the name of the containing archive file.  For thin archives, we
   use square brackets to denote the indirection.  For nested archives,
   we show the qualified name of the external member inside the square
   brackets (e.g., "thin.a[normal.a(foo.o)]").  */

static char *
make_qualified_name (struct archive_info * arch,
                     struct archive_info * nested_arch,
                     char * member_name)
{
  size_t len;
  char * name;

  len = strlen (arch->file_name) + strlen (member_name) + 3;
  if (arch->is_thin_archive && arch->nested_member_origin != 0)
    len += strlen (nested_arch->file_name) + 2;

  name = (char *) malloc (len);
  if (name == NULL)
    {
      error (_("Out of memory\n"));
      return NULL;
    }

  if (arch->is_thin_archive && arch->nested_member_origin != 0)
    snprintf (name, len, "%s[%s(%s)]", arch->file_name, nested_arch->file_name, member_name);
  else if (arch->is_thin_archive)
    snprintf (name, len, "%s[%s]", arch->file_name, member_name);
  else
    snprintf (name, len, "%s(%s)", arch->file_name, member_name);

  return name;
}

@


1.525
log
@	* ar.c (print_contents): Don't internationalize strings without words.
	* dwarf.c (process_extended_line_op): Likewise.
	(process_debug_info): Likwise.
	(display_debug_lines_raw): Likewise.
	(display_debug_lines_decoded): Likewise.
	(display_debug_abbrev): Likewise.
	* readelf.c (process_file_header): Likewise.
	(GET_OP): Likewise.
	(decode_arm_unwind): Likewise.
	(process_mips_specific): Likewise.
	* resrc.c (run_cmd): Likewise.
	(rcparse_warning): Likewise.
	* objdump.c (dump_headers): Don't print "Pg".
@
text
@d12834 2
a12835 1
      member_file_name = adjust_relative_path (arch->file_name, arch->longnames + k, j - k);
d12837 11
a12847 6
          && setup_nested_archive (nested_arch, member_file_name) == 0
          && (member_name = get_archive_member_name_at (nested_arch, arch->nested_member_origin, NULL)) != NULL)
        {
          free (member_file_name);
          return member_name;
        }
d12855 15
a12869 6
  j = 0;
  while ((arch->arhdr.ar_name[j] != '/')
	 && (j < sizeof (arch->arhdr.ar_name) - 1))
    j++;
  arch->arhdr.ar_name[j] = '\0';
  return arch->arhdr.ar_name;
@


1.524
log
@blackfin: add support for L1 code/data flags

Add new linker options for marking programs to load into L1 memory
at runtime.  This needs new EF flag bits, so declare them.

Signed-off-by: Jie Zhang <jie.zhang@@analog.com>
Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d3567 1
a3567 1
	printf (_(" (%ld)"), (long) section_headers[0].sh_info);
d6445 1
a6445 1
  printf (_("0x%02x "), OP)
d6531 1
a6531 1
      printf (_("  0x%02x "), op);
d6536 1
a6536 1
	  printf (_("     vsp = vsp + %d"), offset);
d6541 1
a6541 1
	  printf (_("     vsp = vsp - %d"), offset);
d6572 1
a6572 1
	    printf (_("     vsp = r%d"), op & 0x0f);
d6636 1
a6636 1
	  printf (_("vsp = vsp + %ld"), offset);
d11687 1
a11687 1
	  printf (_("  %*s %10s %*s\n"),
d11703 1
a11703 1
	  printf (_("  %*s %10s %*s %*s %-7s %3s %s\n"),
d11771 1
a11771 1
      printf (_("  %*s %*s %*s %-7s %3s %s\n"),
@


1.523
log
@	bfd/
	* archures.c (bfd_mach_mips_loongson_3a): Defined.
	* bfd-in2.h (bfd_mach_mips_loongson_3a): Defined.
	* cpu-mips.c (I_loongson_3a): New add.
	(arch_info_struct): Add loongson_3a.
	* elfxx-mips.c (_bfd_elf_mips_mach): Add loongson_3a.
	(mips_set_isa_flags): Add loongson_3a.
	(mips_mach_extensions): Add loongson_3a in MIPS64 extensions.

	binutils/
	* readelf.c (get_machine_flags): Add loongson-3a.

	gas/
	* config/tc-mips.c (mips_cpu_info_table): Add loongson3a in MIPS 64.
	* doc/c-mips.texi (MIPS cpu): Add loongson3a.

	include/
	* elf/mips.h (E_MIPS_MACH_LS3A): Defined.
	* opcode/mips.h (INSN_LOONGSON_3A): Defined.
	(CPU_LOONGSON_3A): Defined.
	(OPCODE_IS_MEMBER): Add LOONGSON_3A.

	opcodes/
	* mips-dis.c (mips_arch_choices): Add loongson3a.
	* mips-opc.c (IL3A): Defined as INSN_LOONGSON_3A.
	(mips_builtin_opcodes): Modify some instructions' membership from
	IL2F to IL2F|IL3A, since these instructions are supported by Loongson_3A.
@
text
@d2241 15
@


1.522
log
@bfd:
	* elf32-tic6x.c (elf32_tic6x_obj_attrs_arg_type): Except for
	Tag_ABI_compatibility, treat odd tags as strings and even ones as
	integers.
	(elf32_tic6x_obj_attrs_order, elf32_tic6x_tag_to_array_alignment,
	elf32_tic6x_array_alignment_to_tag): New.
	(elf32_tic6x_merge_attributes): Handle more attributes.  Set type
	for merged attributes.
	(elf_backend_obj_attrs_order): Define.

binutils:
	* readelf.c (display_tic6x_attribute): Handle more attributes.

gas:
	* config/tc-tic6x.c (OPTION_MPID, OPTION_MPIC, OPTION_MNO_PIC):
	New enum values.
	(md_longopts): Add options mpid, mpic and mno-pic.
	(tic6x_pid_type, tic6x_pid, tic6x_pic, tic6x_pid_type_table,
	tic6x_pid_types, tic6x_use_pid): New.
	(md_parse_option): Handle new options.
	(md_show_usage): Output help text for new options.
	(tic6x_set_attributes): Set PID and PIC attributes.
	* doc/as.texinfo: Document -mpid=, -mpic and -mno-pic.
	* doc/c-tic6x.texi (TIC6X Options): Likewise.

gas/testsuite:
	* gas/tic6x/attr-array-directive-1.d,
	gas/tic6x/attr-array-directive-1.s,
	gas/tic6x/attr-array-directive-2.d,
	gas/tic6x/attr-array-directive-2.s,
	gas/tic6x/attr-array-directive-3.d,
	gas/tic6x/attr-array-directive-3.s,
	gas/tic6x/attr-array-directive-4.d,
	gas/tic6x/attr-array-directive-4.s,
	gas/tic6x/attr-conformance-directive-1.d,
	gas/tic6x/attr-conformance-directive-1.s,
	gas/tic6x/attr-conformance-directive-2.d,
	gas/tic6x/attr-conformance-directive-2.s,
	gas/tic6x/attr-pic-directive-1.d,
	gas/tic6x/attr-pic-directive-1.s,
	gas/tic6x/attr-pic-directive-2.d,
	gas/tic6x/attr-pic-directive-2.s,
	gas/tic6x/attr-pic-opts-mno-pic.d, gas/tic6x/attr-pic-opts-mpic.d,
	gas/tic6x/attr-pid-directive-1.d,
	gas/tic6x/attr-pid-directive-1.s,
	gas/tic6x/attr-pid-directive-2.d,
	gas/tic6x/attr-pid-directive-2.s,
	gas/tic6x/attr-pid-opts-mpid-far.d,
	gas/tic6x/attr-pid-opts-mpid-near.d,
	gas/tic6x/attr-pid-opts-mpid-no.d,
	gas/tic6x/attr-stack-directive-1.d,
	gas/tic6x/attr-stack-directive-1.s,
	gas/tic6x/attr-stack-directive-2.d,
	gas/tic6x/attr-stack-directive-2.s,
	gas/tic6x/attr-wchar-directive-1.d,
	gas/tic6x/attr-wchar-directive-1.s,
	gas/tic6x/attr-wchar-directive-2.d,
	gas/tic6x/attr-wchar-directive-2.s: New tests.

include/elf:
	* tic6x-attrs.h (Tag_ABI_wchar_t, Tag_ABI_stack_align_needed,
	Tag_ABI_stack_align_preserved, Tag_ABI_PID, Tag_ABI_PIC,
	Tag_ABI_array_object_alignment,
	Tag_ABI_array_object_align_expected, Tag_ABI_conformance): Define.

ld/testsuite:
	* ld-tic6x/attr-array-16-16.d, ld-tic6x/attr-array-16-4.d,
	ld-tic6x/attr-array-16-416.d, ld-tic6x/attr-array-16-48.d,
	ld-tic6x/attr-array-16-8.d, ld-tic6x/attr-array-16-816.d,
	ld-tic6x/attr-array-16.s, ld-tic6x/attr-array-4-16.d,
	ld-tic6x/attr-array-4-4.d, ld-tic6x/attr-array-4-416.d,
	ld-tic6x/attr-array-4-48.d, ld-tic6x/attr-array-4-8.d,
	ld-tic6x/attr-array-4-816.d, ld-tic6x/attr-array-4.s,
	ld-tic6x/attr-array-416-16.d, ld-tic6x/attr-array-416-4.d,
	ld-tic6x/attr-array-416-416.d, ld-tic6x/attr-array-416-48.d,
	ld-tic6x/attr-array-416-8.d, ld-tic6x/attr-array-416-816.d,
	ld-tic6x/attr-array-416.s, ld-tic6x/attr-array-48-16.d,
	ld-tic6x/attr-array-48-4.d, ld-tic6x/attr-array-48-416.d,
	ld-tic6x/attr-array-48-48.d, ld-tic6x/attr-array-48-8.d,
	ld-tic6x/attr-array-48-816.d, ld-tic6x/attr-array-48.s,
	ld-tic6x/attr-array-8-16.d, ld-tic6x/attr-array-8-4.d,
	ld-tic6x/attr-array-8-416.d, ld-tic6x/attr-array-8-48.d,
	ld-tic6x/attr-array-8-8.d, ld-tic6x/attr-array-8-816.d,
	ld-tic6x/attr-array-8.s, ld-tic6x/attr-array-816-16.d,
	ld-tic6x/attr-array-816-4.d, ld-tic6x/attr-array-816-416.d,
	ld-tic6x/attr-array-816-48.d, ld-tic6x/attr-array-816-8.d,
	ld-tic6x/attr-array-816-816.d, ld-tic6x/attr-array-816.s,
	ld-tic6x/attr-conformance-10-10.d,
	ld-tic6x/attr-conformance-10-11.d,
	ld-tic6x/attr-conformance-10-none.d,
	ld-tic6x/attr-conformance-10.s, ld-tic6x/attr-conformance-11-10.d,
	ld-tic6x/attr-conformance-11-11.d,
	ld-tic6x/attr-conformance-11-none.d,
	ld-tic6x/attr-conformance-11.s,
	ld-tic6x/attr-conformance-none-10.d,
	ld-tic6x/attr-conformance-none-11.d,
	ld-tic6x/attr-conformance-none-none.d,
	ld-tic6x/attr-conformance-none.s, ld-tic6x/attr-pic-0.s,
	ld-tic6x/attr-pic-00.d, ld-tic6x/attr-pic-01.d,
	ld-tic6x/attr-pic-1.s, ld-tic6x/attr-pic-10.d,
	ld-tic6x/attr-pic-11.d, ld-tic6x/attr-pid-0.s,
	ld-tic6x/attr-pid-00.d, ld-tic6x/attr-pid-01.d,
	ld-tic6x/attr-pid-02.d, ld-tic6x/attr-pid-1.s,
	ld-tic6x/attr-pid-10.d, ld-tic6x/attr-pid-11.d,
	ld-tic6x/attr-pid-12.d, ld-tic6x/attr-pid-2.s,
	ld-tic6x/attr-pid-20.d, ld-tic6x/attr-pid-21.d,
	ld-tic6x/attr-pid-22.d, ld-tic6x/attr-stack-16-16.d,
	ld-tic6x/attr-stack-16-8.d, ld-tic6x/attr-stack-16-816.d,
	ld-tic6x/attr-stack-16.s, ld-tic6x/attr-stack-8-16.d,
	ld-tic6x/attr-stack-8-8.d, ld-tic6x/attr-stack-8-816.d,
	ld-tic6x/attr-stack-8.s, ld-tic6x/attr-stack-816-16.d,
	ld-tic6x/attr-stack-816-8.d, ld-tic6x/attr-stack-816-816.d,
	ld-tic6x/attr-stack-816.s, ld-tic6x/attr-wchar-0.s,
	ld-tic6x/attr-wchar-00.d, ld-tic6x/attr-wchar-01.d,
	ld-tic6x/attr-wchar-02.d, ld-tic6x/attr-wchar-1.s,
	ld-tic6x/attr-wchar-10.d, ld-tic6x/attr-wchar-11.d,
	ld-tic6x/attr-wchar-12.d, ld-tic6x/attr-wchar-2.s,
	ld-tic6x/attr-wchar-20.d, ld-tic6x/attr-wchar-21.d,
	ld-tic6x/attr-wchar-22.d: New tests.
@
text
@d2430 1
@


1.522.2.1
log
@backport from mainline
@
text
@d3 1
a3 1
   2008, 2009, 2010, 2011
a63 1
#include "elfcomm.h"
d149 2
d263 2
d275 3
d287 5
d343 30
d424 1
a424 1
print_symbol (int width, const char *symbol)
d426 1
a426 1
  const char *c;
d432 1
a432 2
      /* Set the width to a very large value.  This simplifies the
	 code below.  */
d451 1
a451 1
      while (ISPRINT (*c))
d467 1
a467 1
      if (*c == 0 || width == 0)
d472 1
a472 1
      if ((unsigned char) *c < 32)
d487 1
a487 1
	  printf ("<0x%.2x>", (unsigned char) *c);
d506 35
d3204 1
a3204 1
               =gdb_index,=trace_info,=trace_abbrev,=trace_aranges]\n\
d3551 1
a3551 1
	printf (" (%ld)", (long) section_headers[0].sh_info);
a4626 2
      else if (do_gdb_index && streq (name, ".gdb_index"))
	request_dump_bynumber (i, DEBUG_DUMP);
d6429 1
a6429 1
  printf ("0x%02x ", OP)
d6515 1
a6515 1
      printf ("  0x%02x ", op);
d6520 1
a6520 1
	  printf ("     vsp = vsp + %d", offset);
d6525 1
a6525 1
	  printf ("     vsp = vsp - %d", offset);
d6556 1
a6556 1
	    printf ("     vsp = r%d", op & 0x0f);
d6620 1
a6620 1
	  printf ("vsp = vsp + %ld", offset);
d11671 1
a11671 1
	  printf ("  %*s %10s %*s\n",
d11687 1
a11687 1
	  printf ("  %*s %10s %*s %*s %-7s %3s %s\n",
d11755 1
a11755 1
      printf ("  %*s %*s %*s %-7s %3s %s\n",
a12464 6
  if (dynamic_section)
    {
      free (dynamic_section);
      dynamic_section = NULL;
    }

d12494 411
a13110 7
      if (dump_sects != NULL)
	{
	  free (dump_sects);
	  dump_sects = NULL;
	  num_dump_sects = 0;
	}

@


1.522.2.2
log
@	PR binutils/12523
	* readelf.c (process_object): Clear dynamic_info_DT_GNU_HASH.
@
text
@a12289 1
  dynamic_info_DT_GNU_HASH = 0;
@


1.521
log
@bfd:
	* elf32-tic6x.c (elf32_tic6x_obj_attrs_arg_type): Check
	Tag_ABI_compatibility not Tag_compatibility.
	(elf32_tic6x_merge_attributes): Update compatibility attribute
	name in comment.  Return FALSE if merging common attributes fails.

binutils:
	* readelf.c (display_tic6x_attribute): Use Tag_ABI_compatibility
	not hardcoded 32.  Display name of this attribute.

gas:
	* doc/c-tic6x.texi (TIC6X Directives): Mention
	Tag_ABI_compatibility.

gas/testsuite:
	* gas/tic6x/attr-compatibility-directive-1.d,
	gas/tic6x/attr-compatibility-directive-1.s,
	gas/tic6x/attr-compatibility-directive-2.d,
	gas/tic6x/attr-compatibility-directive-2.s: New tests.

include/elf:
	* tic6x-attrs.h (Tag_ABI_compatibility): Define.

ld/testsuite:
	* ld-tic6x/attr-compatibility-gnu-gnu.d,
	ld-tic6x/attr-compatibility-gnu-other.d,
	ld-tic6x/attr-compatibility-gnu.s,
	ld-tic6x/attr-compatibility-other-gnu.d,
	ld-tic6x/attr-compatibility-other-other.d,
	ld-tic6x/attr-compatibility-other.s: New tests.
@
text
@d10807 57
d10882 81
d10970 6
d10980 11
a10990 5
  /* No general documentation of handling unknown attributes, treat as
     ULEB128 for now.  */
  val = read_uleb128 (p, &len);
  p += len;
  printf ("%d (0x%x)\n", val, val);
@


1.520
log
@Add compressed debug section support to binutils and ld.

bfd/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>
	    Cary Coutant  <ccoutant@@google.com>

	* archive.c (bfd_openr_next_archived_file): Copy BFD_COMPRESS
	and BFD_DECOMPRESS.

	* bfd.c (BFD_COMPRESS): New.
	(BFD_DECOMPRESS): Likewise.
	(BFD_FLAGS_SAVED): Likewise.
	(bfd_preserve_save): Replace BFD_IN_MEMORY with BFD_FLAGS_SAVED.

	* compress.c (bfd_uncompress_section_contents): Removed.
	(get_uncompressed_size): New.
	(decompress_contents): Likewise.
	(bfd_compress_section_contents): Likewise.
	(bfd_get_full_section_contents): Likewise.
	(bfd_is_section_compressed): Likewise.
	(bfd_init_section_decompress_status): Likewise.
	(bfd_init_section_compress_status): Likewise.

	* dwarf2.c (dwarf_debug_sections): New.
	(dwarf_debug_section_enum): Likewise.
	(read_section): Remove section_name and compressed_section_name.
	Add dwarf_debug_section_enum.  Try compressed debug section.
	(read_indirect_string): Updated.
	(read_abbrevs): Likewise.
	(decode_line_info): Likewise.
	(read_debug_ranges): Likewise.
	(find_line): Updated.

	* ecoff.c (bfd_debug_section): Add compress_status and
	compressed_size.

	* elf.c (_bfd_elf_make_section_from_shdr): Call
	bfd_is_section_compressed to check if a DWARF debug section is
	compressed.  Call bfd_init_section_compress_status or
	bfd_init_section_decompress_status if needed.

	* elflink.c (elf_link_input_bfd): Replace bfd_get_section_contents
	with bfd_get_full_section_contents.
	* merge.c (_bfd_add_merge_section): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents): Likewise.
	* simple.c (bfd_simple_get_relocated_section_contents): Likewise.

	* elfxx-target.h (TARGET_BIG_SYM): Allow BFD_COMPRESS and
	BFD_DECOMPRESS.
	(TARGET_LITTLE_SYM): Likewise.

	* libbfd-in.h (dwarf_debug_section): New.
	(dwarf_debug_sections): Likewise.

	* libbfd.c (_bfd_generic_get_section_contents): Issue an error
	when getting contents on compressed/decompressed section.

	* section.c (COMPRESS_SECTION_NONE): New.
	(COMPRESS_SECTION_DONE): Likewise.
	(DECOMPRESS_SECTION_SIZED): Likewise.
	(BFD_FAKE_SECTION): Add compress_status and compressed_size.
	(bfd_malloc_and_get_section): Replace bfd_get_section_contents
	with bfd_get_full_section_contents.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.

binutils/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* addr2line.c (process_file): Set BFD_DECOMPRESS.

	* objcopy.c (do_debug_sections): New.
	(OPTION_COMPRESS_DEBUG_SECTIONS): New.
	(OPTION_DECOMPRESS_DEBUG_SECTIONS): Likewise.
	(copy_options): Add OPTION_COMPRESS_DEBUG_SECTIONS and
	OPTION_DECOMPRESS_DEBUG_SECTIONS.
	(copy_usage): Add --compress-debug-sections and
	--decompress-debug-sections.
	(copy_file): Set BFD_COMPRESS or BFD_DECOMPRESS.
	(copy_section): Replace bfd_get_section_contents with
	bfd_get_full_section_contents.
	(copy_main): Handle OPTION_COMPRESS_DEBUG_SECTIONS and
	OPTION_DECOMPRESS_DEBUG_SECTIONS.  Check do_debug_sections to
	rename DWARF debug sections.

	* objdump.c (load_specific_debug_section): Replace
	bfd_get_section_contents with bfd_get_full_section_contents.
	Remove bfd_uncompress_section_contents.
	(dump_section): Replace bfd_get_section_contents with
	bfd_get_full_section_contents.
	(display_file): Set BFD_DECOMPRESS if needed.

	* readelf.c (uncompress_section_contents): Set buffer to NULL
	to indiate decompression failure.
	(load_specific_debug_section): Always call
	uncompress_section_contents.

	* doc/binutils.texi: Document --compress-debug-sections and
	--decompress-debug-sections.

binutils/testsuite/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* binutils-all/compress.exp: New.
	* binutils-all/dw2-1.S: Likewise.
	* binutils-all/dw2-2.S: Likewise.
	* binutils-all/libdw2-compressed.out: Likewise.
	* binutils-all/libdw2.out: Likewise.

gas/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* write.c (compress_debug): Optimize section flags check.

gas/testsuite/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf/dwarf2-1.s: Replace .zdebug_abbrev section with
	.debug_abbrev section.
	* elf/dwarf2-2.3: Likewise.

	* elf/dwarf2-1.d: Pass --compress-debug-sections to assembler.
	Updated.
	* elf/dwarf2-2.d: Likewise.

	* gas/i386/i386.exp: Remove xfail on dw2-compress-2 and
	x86-64-dw2-compress-2.

ld/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldfile.c (ldfile_try_open_bfd): Set BFD_DECOMPRESS after
	bfd_openr returns.
	* emultempl/elf32.em (gld${EMULATION_NAME}_try_needed): Likewise.

	* scripttempl/elf.sc: Include compressed DWARF debug sections.

ld/testsuite/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-elf/compress.exp: New.
	* ld-elf/compress1.s: Likewise.
	* ld-elf/compress1a.d: Likewise.
	* ld-elf/compress1b.d: Likewise.
	* ld-elf/compress1c.d: Likewise.
@
text
@d10825 1
a10825 3
    case 32:
      /* Tag_compatibility - treated as generic by binutils for now
	 although not currently specified for C6X.  */
d10828 1
@


1.519
log
@bfd:
2010-10-29  Bernd Schmidt  <bernds@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* elf32-tic6x.c (elf32_tic6x_merge_attributes): Check for mismatch
	of DSBT attributes.

binutils:
2010-10-29  Bernd Schmidt  <bernds@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* readelf.c (display_tic6x_attribute): Handle Tag_ABI_DSBT.

gas:
2010-10-29  Bernd Schmidt  <bernds@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* config/tc-tic6x.c (OPTION_MDSBT, OPTION_MNO_DSBT): New enum
	values.
	(md_longopts): Add mdsbt and mno-dsbt.
	(tic6x_dsbt): New static variable.
	(md_parse_option): Handle OPTION_MDSBT and OPTION_MNO_DSBT.
	(md_show_usage): Output help text for -mdsbt and -mno-dsbt.
	(TAG): Add comma at the end.
	(tic6x_set_attributes): Set Tag_ABI_DSBT.
	* doc/as.texinfo: Document -mdsbt and -mno-dsbt.
	* doc/c-tic6x.texi (TIC6X Options): Likewise.
	(TIC6X Directives): Mention Tag_ABI_DSBT.

gas/testsuite:
2010-10-29  Bernd Schmidt  <bernds@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* gas/tic6x/attr-dsbt-directive-1.d,
	gas/tic6x/attr-dsbt-directive-1.s,
	gas/tic6x/attr-dsbt-directive-2.d,
	gas/tic6x/attr-dsbt-directive-2.s,
	gas/tic6x/attr-dsbt-opts-mdsbt.d,
	gas/tic6x/attr-dsbt-opts-mno-dsbt.d: New tests.

include/elf:
2010-10-29  Bernd Schmidt  <bernds@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* tic6x-attrs.h (Tag_ABI_DSBT): New.

ld/testsuite:
2010-10-29  Bernd Schmidt  <bernds@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>

	* ld-tic6x/attr-dsbt-0.s, ld-tic6x/attr-dsbt-00.d,
	ld-tic6x/attr-dsbt-01.d, ld-tic6x/attr-dsbt-1.s,
	ld-tic6x/attr-dsbt-10.d, ld-tic6x/attr-dsbt-11.d: New tests.
@
text
@d9990 1
a9990 2
/* Uncompresses a section that was compressed using zlib, in place.
   This is a copy of bfd_uncompress_section_contents, in bfd/compress.c  */
d10056 2
a10067 1
  int section_is_compressed;
a10072 2
  section_is_compressed = section->name == section->compressed_name;

d10079 3
a10084 7
  if (section_is_compressed)
    {
      if (! uncompress_section_contents (&section->start, &section->size))
        return 0;
      sec->sh_size = section->size;
    }

@


1.518
log
@	* readelf.c (is_32bit_abs_reloc): Support i960 and microblaze.
	(is_32bit_pcrel_reloc): Support microblaze.
@
text
@d10813 18
@


1.517
log
@bfd:
	* elf32-tic6x.c (elf32_tic6x_merge_arch_attributes): Update for
	attribute renaming.
	(elf_backend_obj_attrs_section): Change to ".c6xabi.attributes".

binutils:
	* readelf.c (display_tic6x_attribute): Update for attribute
	renaming.

gas:
	* config/tc-tic6x.c (tic6x_arch_attribute, tic6x_arches,
	md_assemble, tic6x_set_attributes): Update for attribute renaming.
	* doc/c-tic6x.texi: Update for attribute renaming.

gas/testsuite:
	* gas/tic6x/attr-arch-directive-1.d,
	gas/tic6x/attr-arch-directive-2.d,
	gas/tic6x/attr-arch-directive-3.d,
	gas/tic6x/attr-arch-directive-4.d,
	gas/tic6x/attr-arch-directive-4.s,
	gas/tic6x/attr-arch-directive-5.d,
	gas/tic6x/attr-arch-directive-5.s,
	gas/tic6x/attr-arch-opts-c62x.d, gas/tic6x/attr-arch-opts-c64x+.d,
	gas/tic6x/attr-arch-opts-c64x.d, gas/tic6x/attr-arch-opts-c674x.d,
	gas/tic6x/attr-arch-opts-c67x+.d, gas/tic6x/attr-arch-opts-c67x.d,
	gas/tic6x/attr-arch-opts-none-1.d,
	gas/tic6x/attr-arch-opts-none-2.d,
	gas/tic6x/attr-arch-opts-override-1.d,
	gas/tic6x/attr-arch-opts-override-2.d: Update for attribute
	renaming and renumbering.

include/elf:
	* tic6x-attrs.h (Tag_C6XABI_Tag_CPU_arch): Change to Tag_ISA,
	value 4.
	* tic6x.h (Values for Tag_C6XABI_Tag_CPU_arch): Rename for
	attribute renaming.

ld:
	* emulparams/elf32_tic6x_le.sh (ATTRS_SECTIONS): Use
	.c6xabi.attributes, not __TI_build_attributes.

ld/testsuite:
	* ld-tic6x/attr-arch-c62x-c62x.d, ld-tic6x/attr-arch-c62x-c64x+.d,
	ld-tic6x/attr-arch-c62x-c64x.d, ld-tic6x/attr-arch-c62x-c674x.d,
	ld-tic6x/attr-arch-c62x-c67x+.d, ld-tic6x/attr-arch-c62x-c67x.d,
	ld-tic6x/attr-arch-c64x+-c62x.d, ld-tic6x/attr-arch-c64x+-c64x+.d,
	ld-tic6x/attr-arch-c64x+-c64x.d, ld-tic6x/attr-arch-c64x+-c674x.d,
	ld-tic6x/attr-arch-c64x+-c67x+.d, ld-tic6x/attr-arch-c64x+-c67x.d,
	ld-tic6x/attr-arch-c64x-c62x.d, ld-tic6x/attr-arch-c64x-c64x+.d,
	ld-tic6x/attr-arch-c64x-c64x.d, ld-tic6x/attr-arch-c64x-c674x.d,
	ld-tic6x/attr-arch-c64x-c67x+.d, ld-tic6x/attr-arch-c64x-c67x.d,
	ld-tic6x/attr-arch-c674x-c62x.d, ld-tic6x/attr-arch-c674x-c64x+.d,
	ld-tic6x/attr-arch-c674x-c64x.d, ld-tic6x/attr-arch-c674x-c674x.d,
	ld-tic6x/attr-arch-c674x-c67x+.d, ld-tic6x/attr-arch-c674x-c67x.d,
	ld-tic6x/attr-arch-c67x+-c62x.d, ld-tic6x/attr-arch-c67x+-c64x+.d,
	ld-tic6x/attr-arch-c67x+-c64x.d, ld-tic6x/attr-arch-c67x+-c674x.d,
	ld-tic6x/attr-arch-c67x+-c67x+.d, ld-tic6x/attr-arch-c67x+-c67x.d,
	ld-tic6x/attr-arch-c67x-c62x.d, ld-tic6x/attr-arch-c67x-c64x+.d,
	ld-tic6x/attr-arch-c67x-c64x.d, ld-tic6x/attr-arch-c67x-c674x.d,
	ld-tic6x/attr-arch-c67x-c67x+.d, ld-tic6x/attr-arch-c67x-c67x.d:
	Update for attribute renaming.
@
text
@d9289 2
d9292 1
a9292 1
      return reloc_type == 1; /* XXX Is this right ?  */
d9344 2
d9439 2
@


1.516
log
@Use BYTE_GET_SIGNED on r_addend.

2010-10-08  H.J. Lu  <hongjiu.lu@@intel.com>

	* dwarf.c (byte_get_signed): Make it extern.

	* dwarf.h (byte_get_signed): New.

	* readelf.c (BYTE_GET_SIGNED): New.
	(slurp_rela_relocs): Use BYTE_GET_SIGNED on r_addend.
	(dump_relocations): Properly dump r_addend.
@
text
@d10773 1
a10773 1
    case Tag_C6XABI_Tag_CPU_arch:
d10776 1
a10776 1
      printf ("  Tag_C6XABI_Tag_CPU_arch: ");
d10780 1
a10780 1
	case C6XABI_Tag_CPU_arch_none:
d10783 1
a10783 1
	case C6XABI_Tag_CPU_arch_C62X:
d10786 1
a10786 1
	case C6XABI_Tag_CPU_arch_C67X:
d10789 1
a10789 1
	case C6XABI_Tag_CPU_arch_C67XP:
d10792 1
a10792 1
	case C6XABI_Tag_CPU_arch_C64X:
d10795 1
a10795 1
	case C6XABI_Tag_CPU_arch_C64XP:
d10798 1
a10798 1
	case C6XABI_Tag_CPU_arch_C674X:
@


1.515
log
@        * ldwrite.c (clone_section): Call bfd_copy_private_section_data on
        newly cloned section.
        * ld-x86-64/split-by-file.rd: New test.
        * ld-x86-64/split-by-file1.s: New test source code.
        * ld-x86-64/split-by-file2.s: New test source code.
        * ld-x86-64/x86-64.exp: Run the new test.
        * readelf.c (process_section_headers): Mention meaning of 'l'
        section flag for x86-64 targets.
@
text
@d275 2
a276 1
#define BYTE_GET(field)	byte_get (field, sizeof (field))
d738 1
a738 1
	  relas[i].r_addend = BYTE_GET (erelas[i].r_addend);
d768 1
a768 1
	  relas[i].r_addend = BYTE_GET (erelas[i].r_addend);
d1414 1
a1414 1
		  long off = (long) (bfd_signed_vma) rels[i].r_addend;
d1417 1
a1417 1
		    printf (" - %lx", - off);
d1419 1
a1419 1
		    printf (" + %lx", off);
@


1.514
log
@	binutils/
	* readelf.c (display_mips_gnu_attribute): Replace GCC options
	with a textual description of a MIPS32r2 64-bit FPU.

	ld/testsuite/
	* ld-mips-elf/attr-gnu-4-04.d: Adjust Tag_GNU_MIPS_ABI_FP for
	the new MIPS32r2 64-bit FPU description.
	* ld-mips-elf/attr-gnu-4-40.d: Likewise.
	* ld-mips-elf/attr-gnu-4-44.d: Likewise.
@
text
@d4864 9
a4872 1
    printf (_("Key to Flags:\n\
d4876 1
@


1.513
log
@        PR binutils/11889
        * readelf.c (get_32bit_elf_symbols): Check for a corrupt
        sh_entsize.
        (get_64bit_elf_symbols): Likewise.
        (process_symbol_table): Likewise.
        (process_section_groups): Check for corrupt headers.
        (process_version_sections): Check for corrupt indicies.
        (process_corefile_note_segment): Likewise.
@
text
@d10721 1
a10721 1
	  printf (_("64-bit float (-mips32r2 -mfp64)\n"));
@


1.512
log
@	bfd/
	* elf32-m69k.c (elf32_m68k_print_private_bfd_data): Detect EMAC_B
	variant.

	binutils/
	* readelf.c (get_machine_flags): Detect CF ISA C and EMAC_B
	variants.
@
text
@d1269 1
a1269 1
	
d2624 1
a2624 1
	    strcat (buf, ", dsp");	  
d4049 1
a4049 1
  Elf32_External_Sym * esyms;
d4051 1
a4051 1
  Elf_Internal_Sym * isyms;
d4055 15
d4072 1
a4072 1
  if (!esyms)
d4084 2
a4085 5
      if (!shndx)
	{
	  free (esyms);
	  return NULL;
	}
a4087 1
  number = section->sh_size / section->sh_entsize;
d4093 1
a4093 4
      if (shndx)
	free (shndx);
      free (esyms);
      return NULL;
d4096 1
a4096 3
  for (j = 0, psym = isyms;
       j < number;
       j++, psym++)
d4111 1
d4114 2
a4115 1
  free (esyms);
d4130 15
a4165 1
  number = section->sh_size / section->sh_entsize;
d4990 6
a6470 1
      
d7803 4
d7827 5
d7848 5
d7870 1
d7876 1
d7920 3
d7944 5
d7976 5
d8020 2
d8083 10
d8800 7
d8810 1
d9812 1
a9812 1
		      
d10285 1
a10285 1
static const char * arm_attr_tag_Advanced_SIMD_arch[] = 
d10326 1
a10326 1
static const char * arm_attr_tag_MPextension_use[] = 
d10329 1
a10329 1
  {"Allowed in Thumb-ISA, v7-R or v7-M", "Not allowed", 
d10333 1
a10333 1
  {"Not Allowed", "TrustZone", "Virtualization Extensions", 
d10335 1
a10335 1
static const char * arm_attr_tag_MPextension_use_legacy[] = 
d10440 1
a10440 1
		    printf (_("8-byte and up to %d-byte extended\n"), 
d10459 1
a10459 1
		    printf (_("8-byte and up to %d-byte extended\n"), 
d11904 1
a11904 1
  if (!pnotes)
d11928 2
a11929 1
      if (((char *) next) > (((char *) pnotes) + length))
d11940 11
@


1.511
log
@        PR binutils/11742
        * readelf.c (get_archive_member_name): Do not read beyond the end
        of the ar_name field.
@
text
@d2313 7
d2338 3
@


1.510
log
@	* readelf.c (apply_relocations): D30V is really REL.
@
text
@d12559 2
a12560 1
  while ((arch->arhdr.ar_name[j] != '/') && (j < 16))
@


1.509
log
@Add support for v850E2 and v850E2V3
@
text
@d9660 2
a9661 1
	  /* R_XTENSA_32 and R_PJ_DATA_DIR32 are partial_inplace.  */
d9667 4
a9670 1
		  && reloc_type == 1))
@


1.508
log
@	* readelf.c: Add Moxie support.
@
text
@d2355 8
a2362 2
	    case E_V850E1_ARCH:
	      strcat (buf, ", v850e1");
@


1.507
log
@include/elf/
	* internal.h (ELF_TBSS_SPECIAL): New macro, extracted from..
	(ELF_SECTION_SIZE): ..here.
	(ELF_SECTION_IN_SEGMENT_1): Add "strict" arg.
	(ELF_SECTION_IN_SEGMENT_STRICT): New macro.
bfd/
	* elf.c (assign_file_positions_for_load_sections): Check that
	zero size sections are allocated in segments too.
	(assign_file_positions_for_non_load_sections): Warn if zero
	size alloc sections are found here.
	(copy_elf_program_header): Don't drop zero size sections from
	segment map.
	(copy_private_bfd_data): Check for changes in zero size sections.
binutils/
	* readelf.c (process_program_headers): Don't ignore all zero size
	sections.
ld/testsuite/
	* ld-powerpc/tlsexe.r: Update.
	* ld-powerpc/tlsexetoc.r: Update.
	* ld-powerpc/tlsso.r: Update.
	* ld-powerpc/tlstocso.r: Update.
@
text
@d128 1
d650 1
d1135 4
d1915 1
d9250 2
d9513 1
@


1.506
log
@* readelf.c (process_section_headers): Update key to flags.
@
text
@d3892 2
a3893 2
	      if (ELF_SECTION_SIZE (section, segment) != 0
		  && ELF_SECTION_IN_SEGMENT (section, segment))
@


1.505
log
@	* readelf.c (uncompress_section_contents): Avoid gcc-4.6 warning.
@
text
@d4821 1
a4821 1
  I (info), L (link order), G (group), x (unknown)\n\
@


1.504
log
@bfd/ChangeLog:

	* compress.c (bfd_uncompress_section_contents): Add ATTRIBUTE_UNUSED.
	* dwarf2.c (read_and_uncompress_section): New function.
	(read_section): Call it.
	(find_line): Likewise.

binutils/ChangeLog:

	* objdump.c (load_specific_debug_section): Decompress section contents
	before applying relocations.
	* readelf.c (load_specific_debug_section): Update section size after
	decompression.

gas/ChangeLog:

	* Makefile.am: Add compress-debug.c and compress-debug.h.
	* Makefile.in: Regenerate.
	* config.in: Add HAVE_ZLIB_H.
	* configure.in: Check for zlib.h.
	* configure: Regenerate.

	* as.c (parse_args): Add --compress-debug-sections and
	--nocompress-debug-sections.
	* as.h (flag_compress_debug): New variable.
	* compress-debug.c: New file.
	* compress-debug.h: New file.
	* write.c: Include compress-debug.h.
	(compress_frag): New function.
	(compress_debug): New function.
	(write_object_file): Compress debug sections if requested.
@
text
@d9872 2
a9873 1
uncompress_section_contents (unsigned char ** buffer, dwarf_size_type * size)
a9875 3
  /* These are just to quiet gcc.  */
  buffer = 0;
  size = 0;
@


1.503
log
@bfd:
	* elf-bfd.h (LEAST_KNOWN_OBJ_ATTRIBUTE): Decrease to 2.
	* elf32-tic6x.c (elf32_tic6x_obj_attrs_arg_type,
	elf32_tic6x_merge_arch_attributes, elf32_tic6x_merge_attributes,
	elf32_tic6x_merge_private_bfd_data): New.
	(bfd_elf32_bfd_merge_private_bfd_data,
	elf_backend_obj_attrs_arg_type, elf_backend_obj_attrs_section,
	elf_backend_obj_attrs_section_type, elf_backend_obj_attrs_vendor):
	Define.
	* elf32-tic6x.h (elf32_tic6x_merge_arch_attributes): Declare.

binutils:
	* readelf.c (display_tic6x_attribute, process_tic6x_specific):
	New.
	(process_arch_specific): Call process_tic6x_specific for
	EM_TI_C6000.

gas:
	* config/tc-tic6x.c: Include elf/tic6x.h.
	(tic6x_arch_attribute, tic6x_seen_insns): New.
	(tic6x_arch_table, tic6x_arches): Add attribute values.
	(tic6x_use_arch): Handle attribute settings.
	(tic6x_attributes_set_explicitly, s_tic6x_c6xabi_attribute,
	tic6x_attribute_table, tic6x_attributes,
	tic6x_convert_symbolic_attribute): New.
	(md_pseudo_table): Add c6xabi_attribute.
	(md_assemble): Set tic6x_seen_insns and tic6x_arch_attribute.
	(tic6x_set_attribute_int, tic6x_set_attributes): New.
	(tic6x_end): Call tic6x_set_attributes.
	* config/tc-tic6x.h (CONVERT_SYMBOLIC_ATTRIBUTE): Define.
	(tic6x_convert_symbolic_attribute): Declare.

gas/testsuite:
	* gas/elf/elf.exp: Set target_machine for tic6x-*-*.
	* gas/elf/section2.e-tic6x, gas/tic6x/attr-arch-directive-1.d,
	gas/tic6x/attr-arch-directive-1.s,
	gas/tic6x/attr-arch-directive-2.d,
	gas/tic6x/attr-arch-directive-2.s,
	gas/tic6x/attr-arch-directive-3.d,
	gas/tic6x/attr-arch-directive-3.s,
	gas/tic6x/attr-arch-directive-4.d,
	gas/tic6x/attr-arch-directive-4.s,
	gas/tic6x/attr-arch-directive-5.d,
	gas/tic6x/attr-arch-directive-5.s,
	gas/tic6x/attr-arch-opts-c62x.d, gas/tic6x/attr-arch-opts-c64x+.d,
	gas/tic6x/attr-arch-opts-c64x.d, gas/tic6x/attr-arch-opts-c674x.d,
	gas/tic6x/attr-arch-opts-c67x+.d, gas/tic6x/attr-arch-opts-c67x.d,
	gas/tic6x/attr-arch-opts-none-1.d,
	gas/tic6x/attr-arch-opts-none-2.d,
	gas/tic6x/attr-arch-opts-override-1.d,
	gas/tic6x/attr-arch-opts-override-2.d, gas/tic6x/empty.s: New.

include/elf:
	* tic6x-attrs.h: New.
	* tic6x.h: Include elf/tic6x-attrs.h for attribute table.
	(C6XABI_Tag_CPU_arch_none, C6XABI_Tag_CPU_arch_C62X,
	C6XABI_Tag_CPU_arch_C67X, C6XABI_Tag_CPU_arch_C67XP,
	C6XABI_Tag_CPU_arch_C64X, C6XABI_Tag_CPU_arch_C64XP,
	C6XABI_Tag_CPU_arch_C674X): Define.

ld:
	* emulparams/elf32_tic6x_le.sh (ATTRS_SECTIONS): Define.

ld/testsuite:
	* ld-elf/orphan3.d: Allow section names starting '_'.
	* ld-tic6x/attr-arch-c62x-c62x.d, ld-tic6x/attr-arch-c62x-c64x+.d,
	ld-tic6x/attr-arch-c62x-c64x.d, ld-tic6x/attr-arch-c62x-c674x.d,
	ld-tic6x/attr-arch-c62x-c67x+.d, ld-tic6x/attr-arch-c62x-c67x.d,
	ld-tic6x/attr-arch-c62x.s, ld-tic6x/attr-arch-c64x+-c62x.d,
	ld-tic6x/attr-arch-c64x+-c64x+.d, ld-tic6x/attr-arch-c64x+-c64x.d,
	ld-tic6x/attr-arch-c64x+-c674x.d,
	ld-tic6x/attr-arch-c64x+-c67x+.d, ld-tic6x/attr-arch-c64x+-c67x.d,
	ld-tic6x/attr-arch-c64x+.s, ld-tic6x/attr-arch-c64x-c62x.d,
	ld-tic6x/attr-arch-c64x-c64x+.d, ld-tic6x/attr-arch-c64x-c64x.d,
	ld-tic6x/attr-arch-c64x-c674x.d, ld-tic6x/attr-arch-c64x-c67x+.d,
	ld-tic6x/attr-arch-c64x-c67x.d, ld-tic6x/attr-arch-c64x.s,
	ld-tic6x/attr-arch-c674x-c62x.d, ld-tic6x/attr-arch-c674x-c64x+.d,
	ld-tic6x/attr-arch-c674x-c64x.d, ld-tic6x/attr-arch-c674x-c674x.d,
	ld-tic6x/attr-arch-c674x-c67x+.d, ld-tic6x/attr-arch-c674x-c67x.d,
	ld-tic6x/attr-arch-c674x.s, ld-tic6x/attr-arch-c67x+-c62x.d,
	ld-tic6x/attr-arch-c67x+-c64x+.d, ld-tic6x/attr-arch-c67x+-c64x.d,
	ld-tic6x/attr-arch-c67x+-c674x.d,
	ld-tic6x/attr-arch-c67x+-c67x+.d, ld-tic6x/attr-arch-c67x+-c67x.d,
	ld-tic6x/attr-arch-c67x+.s, ld-tic6x/attr-arch-c67x-c62x.d,
	ld-tic6x/attr-arch-c67x-c64x+.d, ld-tic6x/attr-arch-c67x-c64x.d,
	ld-tic6x/attr-arch-c67x-c674x.d, ld-tic6x/attr-arch-c67x-c67x+.d,
	ld-tic6x/attr-arch-c67x-c67x.d, ld-tic6x/attr-arch-c67x.s: New.
@
text
@d9965 5
a9969 2
    if (! uncompress_section_contents (&section->start, &section->size))
      return 0;
@


1.502
log
@Cast to unsigned long for 0x%lx.

2010-06-11  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (dump_ia64_vms_dynamic_fixups): Cast to unsigned long
	for 0x%lx.
@
text
@d10644 67
d10867 7
d11944 3
@


1.501
log
@include/elf
2010-06-11  Tristan Gingold  <gingold@@adacore.com>

	* ia64.h (EF_IA_64_VMS_COMCOD, EF_IA_64_VMS_COMCOD_SUCCESS)
	(EF_IA_64_VMS_COMCOD_WARNING, EF_IA_64_VMS_COMCOD_ERROR)
	(EF_IA_64_VMS_COMCOD_ABORT, EF_IA_64_VMS_LINKAGES): Define.
	(VMS_LF_CALL_DEBUG, VMS_LF_NOP0BUFS, VMS_LF_P0IMAGE)
	(VMS_LF_MKTHREADS, VMS_LF_UPCALLS, VMS_LF_IMGSTA)
	(VMS_LF_INITIALIZE, VMS_LF_MAIN, VMS_LF_EXE_INIT)
	(VMS_LF_TBK_IN_IMG, VMS_LF_DBG_IN_IMG, VMS_LF_TBK_IN_DSF)
	(VMS_LF_DBG_IN_DSF, VMS_LF_SIGNATURES, VMS_LF_REL_SEG_OFF): Define.
	(VMS_STO_VISIBILITY, VMS_ST_VISIBILITY, VMS_STO_FUNC_TYPE)
	(VMS_ST_FUNC_TYPE, VMS_SFT_CODE_ADDR, VMS_SFT_SYMV_IDX)
	(VMS_SFT_FD, VMS_SFT_RESERVE, VMS_STO_LINKAGE, VMS_ST_LINKAGE)
	(VMS_STL_IGNORE, VMS_STL_RESERVE, VMS_STL_STD, VMS_STL_LNK): Define.
	(Elf64_External_VMS_IMAGE_FIXUP): New declaration.
	(Elf64_External_VMS_IMAGE_RELA): Ditto.
	(R_IA64_VMS_DIR8, R_IA64_VMS_DIR16LSB, R_IA64_VMS_CALL_SIGNATURE)
	(R_IA64_VMS_EXECLET_FUNC, R_IA64_VMS_EXECLET_DATA, R_IA64_VMS_FIX8)
	(R_IA64_VMS_FIX16, R_IA64_VMS_FIX32, R_IA64_VMS_FIX64)
	(R_IA64_VMS_FIXFD, R_IA64_VMS_ACC_LOAD, R_IA64_VMS_ACC_ADD)
	(R_IA64_VMS_ACC_SUB, R_IA64_VMS_ACC_MUL, R_IA64_VMS_ACC_DIV)
	(R_IA64_VMS_ACC_AND, R_IA64_VMS_ACC_IOR, R_IA64_VMS_ACC_EOR)
	(R_IA64_VMS_ACC_ASH, R_IA64_VMS_ACC_STO8, R_IA64_VMS_ACC_STO16LSH)
	(R_IA64_VMS_ACC_STO32LSH, R_IA64_VMS_ACC_STO64LSH): New.

binutils/
2010-06-11  Tristan Gingold  <gingold@@adacore.com>
	    Doug Rupp <rupp@@gnat.com>

	* readelf.c (is_ia64_vms): New function.
	(dump_relocations): Use it.
	(get_machine_flags): Display IA-64 OpenVMS flags.
	(process_program_headers): No error on OpenVMS if no .dynamic section.
	(struct ia64_vms_dynfixup, struct ia64_vms_dynimgrela): New
	declarations.
	(dump_ia64_vms_dynamic_fixups): New function.
	(dump_ia64_vms_dynamic_relocs): Ditto.
	(process_ia64_vms_dynamic_relocs): Ditto.
	(process_relocs): Handle IA-64 OpenVMS relocs.
	(VMS_EPOCH_OFFSET, VMS_GRANULARITY_FACTOR): New macros.
	(print_vms_time): New function.
	(dynamic_section_ia64_val): Handle DT_IA_64_VMS_LINKTIME and
	DT_IA_64_VMS_LNKFLAGS.
	(get_ia64_symbol_other): New function.
	(get_symbol_other): Handle EM_IA_64.
@
text
@d5115 1
a5115 1
            fixup->needed);
@


1.500
log
@2010-06-10  Tristan Gingold  <gingold@@adacore.com>

	* readelf.c (slurp_ia64_unwind_table): IA64 rela relocations are
	not inplace.
@
text
@d580 11
d1386 1
a1386 3
		      else if (elf_header.e_machine == EM_IA_64
			       && (elf_header.e_ident[EI_OSABI]
				   == ELFOSABI_OPENVMS)
d2565 21
d3822 4
a3825 1
		  error (_("no .dynamic section in the dynamic segment\n"));
d5074 181
d5326 3
d6887 23
d6922 40
d8256 61
d8329 4
@


1.499
log
@2010-05-21  Daniel Jacobowitz  <dan@@codesourcery.com>
            Joseph Myers  <joseph@@codesourcery.com>
            Andrew Stubbs  <ams@@codesourcery.com>

        bfd/
        * config.bfd (sh-*-uclinux* | sh[12]-*-uclinux*): Add
        bfd_elf32_shl_vec, and FDPIC vectors to targ_selvecs.
        * configure.in: Handle FDPIC vectors.
        * elf32-sh-relocs.h: Add FDPIC and movi20 relocations.
        * elf32-sh.c (DEFAULT_STACK_SIZE): Define.
        (SYMBOL_FUNCDESC_LOCAL): Define.  Use it instead of
        SYMBOL_REFERENCES_LOCAL for function descriptors.
        (fdpic_object_p): New.
        (sh_reloc_map): Add FDPIC and movi20 relocations.
        (sh_elf_info_to_howto, sh_elf_relocate_section): Handle new invalid
        range.
        (struct elf_sh_plt_info): Add got20 and short_plt.  Update all
        definitions.
        (FDPIC_PLT_ENTRY_SIZE, FDPIC_PLT_LAZY_OFFSET): Define.
        (fdpic_sh_plt_entry_be, fdpic_sh_plt_entry_le, fdpic_sh_plts): New.
        (FDPIC_SH2A_PLT_ENTRY_SIZE, FDPIC_SH2A_PLT_LAZY_OFFSET): Define.
        (fdpic_sh2a_plt_entry_be, fdpic_sh2a_plt_entry_le)
        (fdpic_sh2a_short_plt_be, fdpic_sh2a_short_plt_le, fdpic_sh2a_plts):
        New.
        (get_plt_info): Handle FDPIC.
        (MAX_SHORT_PLT): Define.
        (get_plt_index, get_plt_offset): Handle short_plt.
        (union gotref): New.
        (struct elf_sh_link_hash_entry): Add funcdesc, rename tls_type to
        got_type and adjust all uses.  Add GOT_FUNCDESC.
        (struct sh_elf_obj_tdata): Add local_funcdesc.  Rename
        local_got_tls_type to local_got_type.
        (sh_elf_local_got_type): Renamed from sh_elf_local_got_tls_type.  All
        users changed.
        (sh_elf_local_funcdesc): Define.
        (struct elf_sh_link_hash_table): Add sfuncdesc, srelfuncdesc, fdpic_p,
        and srofixup.
        (sh_elf_link_hash_newfunc): Initialize new fields.
        (sh_elf_link_hash_table_create): Set fdpic_p.
        (sh_elf_omit_section_dynsym): New.
        (create_got_section): Create .got.funcdesc, .rela.got.funcdesc
        and .rofixup.
        (allocate_dynrelocs): Allocate local function descriptors and space
        for R_SH_FUNCDESC-related relocations, and for rofixups.
        Handle GOT_FUNCDESC.  Create fixups.  Handle GOT entries which
        require function descriptors.
        (sh_elf_always_size_sections): Handle PT_GNU_STACK and __stacksize.
        (sh_elf_modify_program_headers): New.
        (sh_elf_size_dynamic_sections): Allocate function descriptors for
        local symbols.  Allocate .got.funcdesc contents.  Allocate rofixups.
        Handle local GOT entries of type GOT_FUNCDESC.  Create fixups for
        local GOT entries.  Ensure that FDPIC libraries always have a PLTGOT
        entry in the .dynamic section.
        (sh_elf_add_dyn_reloc, sh_elf_got_offset, sh_elf_initialize_funcdesc)
        (sh_elf_add_rofixup, sh_elf_osec_to_segment)
        (sh_elf_osec_readonly_p, install_movi20_field): New functions.
        (sh_elf_relocate_section): Handle new relocations, R_SH_FUNCDESC,
        R_SH_GOTFUNCDESC and R_SH_GOTOFFFUNCDESC.  Use sh_elf_got_offset
        and .got.plt throughout to find _GLOBAL_OFFSET_TABLE_.  Add rofixup
        read-only section warnings.  Handle undefined weak symbols.  Generate
        fixups for R_SH_DIR32 and GOT entries.  Check for cross-segment
        relocations and clear EF_SH_PIC.  Handle 20-bit relocations.
        Always generate R_SH_DIR32 for FDPIC instead of R_SH_RELATIVE.
        (sh_elf_gc_sweep_hook): Handle R_SH_FUNCDESC, R_SH_GOTOFF20,
        R_SH_GOTFUNCDESC, R_SH_GOTFUNCDESC20, and R_SH_GOTOFFFUNCDESC.
        Handle 20-bit relocations.
        (sh_elf_copy_indirect_symbol): Copy function descriptor reference
        counts.
        (sh_elf_check_relocs): Handle new relocations.  Make symbols
        dynamic for FDPIC relocs.  Account for rofixups.  Error for FDPIC
        symbol mismatches.  Allocate a GOT for R_SH_DIR32. Allocate fixups
        for R_SH_DIR32.
        (sh_elf_copy_private_data): Copy PT_GNU_STACK size.
        (sh_elf_merge_private_data): Copy initial flags.  Do not clobber
        non-mach flags.  Set EF_SH_PIC for FDPIC.  Reject FDPIC mismatches.
        (sh_elf_finish_dynamic_symbol): Do not handle got_funcdesc entries
        here.  Rename sgot to sgotplt and srel to srelplt.  Handle short_plt,
        FDPIC descriptors, and got20.  Create R_SH_FUNCDESC_VALUE for FDPIC.
        Use install_movi20_field.  Rename srel to srelgot.  Always generate
        R_SH_DIR32 for FDPIC instead of R_SH_RELATIVE.
        (sh_elf_finish_dynamic_sections): Fill in the GOT pointer in rofixup.
        Do not fill in reserved GOT entries for FDPIC.  Correct DT_PLTGOT.
        Rename sgot to sgotplt.  Assert that the right number of rofixups
        and dynamic relocations were allocated.
        (sh_elf_use_relative_eh_frame, sh_elf_encode_eh_address): New.
        (elf_backend_omit_section_dynsym): Use sh_elf_omit_section_dynsym.
        (elf_backend_can_make_relative_eh_frame)
        (elf_backend_can_make_lsda_relative_eh_frame)
        (elf_backend_encode_eh_address): Define.
        (TARGET_BIG_SYM, TARGET_BIG_NAME, TARGET_LITTLE_SYM)
        (TARGET_LITTLE_NAME, elf_backend_modify_program_headers, elf32_bed):
        Redefine for FDPIC vector.
        * reloc.c: Add SH FDPIC and movi20 relocations.
        * targets.c (_bfd_target_vector): Add FDPIC vectors.
        * configure, bfd-in2.h, libbfd.h: Regenerated.

        binutils/
        * readelf.c (get_machine_flags): Handle EF_SH_PIC and EF_SH_FDPIC.

        gas/
        * config/tc-sh.c (sh_fdpic): New.
        (sh_check_fixup): Handle relocations on movi20.
        (parse_exp): Do not reject PIC operators here.
        (build_Mytes): Check for unhandled PIC operators here.  Use
        sh_check_fixup for movi20.
        (enum options): Add OPTION_FDPIC.
        (md_longopts, md_parse_option, md_show_usage): Add --fdpic.
        (sh_fix_adjustable, md_apply_fix): Handle FDPIC and movi20 relocations.
        (sh_elf_final_processing): Handle --fdpic.
        (sh_uclinux_target_format): New.
        (sh_parse_name): Handle FDPIC relocation operators.
        * config/tc-sh.h (TARGET_FORMAT): Define specially for TE_UCLINUX.
        (sh_uclinux_target_format): Declare for TE_UCLINUX.
        * configure.tgt (sh-*-uclinux* | sh[12]-*-uclinux*): Set
        em=uclinux.
        * doc/c-sh.texi (SH Options): Document --fdpic.

        gas/testsuite/
        * gas/sh/basic.exp: Run new tests.  Handle uClinux like Linux.
        * gas/sh/fdpic.d: New file.
        * gas/sh/fdpic.s: New file.
        * gas/sh/reg-prefix.d: Force big-endian.
        * gas/sh/sh2a-pic.d: New file.
        * gas/sh/sh2a-pic.s: New file.
        * lib/gas-defs.exp (is_elf_format): Include sh*-*-uclinux*.

        include/elf/
        * sh.h (EF_SH_PIC, EF_SH_FDPIC): Define.
        (R_SH_FIRST_INVALID_RELOC_6, R_SH_LAST_INVALID_RELOC_6): New.  Adjust
        other invalid ranges.
        (R_SH_GOT20, R_SH_GOTOFF20, R_SH_GOTFUNCDESC, R_SH_GOTFUNCDESC20)
        (R_SH_GOTOFFFUNCDESC, R_SH_GOTOFFFUNCDESC20, R_SH_FUNCDESC)
        (R_SH_FUNCDESC_VALUE): New.

        ld/
        * Makefile.am (ALL_EMULATIONS): Add eshelf_fd.o and eshlelf_fd.o.
        (eshelf_fd.c, eshlelf_fd.c): New rules.
        * Makefile.in: Regenerate.
        * configure.tgt (sh-*-uclinux*): Add shelf_fd and shlelf_fd
        emulations.
        * emulparams/shelf_fd.sh: New file.
        * emulparams/shlelf_fd.sh: New file.
        * emulparams/shlelf_linux.sh: Update comment.

        ld/testsuite/
        * ld-sh/sh.exp: Handle uClinux like Linux.
        * lib/ld-lib.exp (is_elf_format): Include sh*-*-uclinux*.
        * ld-sh/fdpic-funcdesc-shared.d: New file.
        * ld-sh/fdpic-funcdesc-shared.s: New file.
        * ld-sh/fdpic-funcdesc-static.d: New file.
        * ld-sh/fdpic-funcdesc-static.s: New file.
        * ld-sh/fdpic-gotfuncdesc-shared.d: New file.
        * ld-sh/fdpic-gotfuncdesc-shared.s: New file.
        * ld-sh/fdpic-gotfuncdesc-static.d: New file.
        * ld-sh/fdpic-gotfuncdesc-static.s: New file.
        * ld-sh/fdpic-gotfuncdesci20-shared.d: New file.
        * ld-sh/fdpic-gotfuncdesci20-shared.s: New file.
        * ld-sh/fdpic-gotfuncdesci20-static.d: New file.
        * ld-sh/fdpic-gotfuncdesci20-static.s: New file.
        * ld-sh/fdpic-goti20-shared.d: New file.
        * ld-sh/fdpic-goti20-shared.s: New file.
        * ld-sh/fdpic-goti20-static.d: New file.
        * ld-sh/fdpic-goti20-static.s: New file.
        * ld-sh/fdpic-gotofffuncdesc-shared.d: New file.
        * ld-sh/fdpic-gotofffuncdesc-shared.s: New file.
        * ld-sh/fdpic-gotofffuncdesc-static.d: New file.
        * ld-sh/fdpic-gotofffuncdesc-static.s: New file.
        * ld-sh/fdpic-gotofffuncdesci20-shared.d: New file.
        * ld-sh/fdpic-gotofffuncdesci20-shared.s: New file.
        * ld-sh/fdpic-gotofffuncdesci20-static.d: New file.
        * ld-sh/fdpic-gotofffuncdesci20-static.s: New file.
        * ld-sh/fdpic-gotoffi20-shared.d: New file.
        * ld-sh/fdpic-gotoffi20-shared.s: New file.
        * ld-sh/fdpic-gotoffi20-static.d: New file.
        * ld-sh/fdpic-gotoffi20-static.s: New file.
        * ld-sh/fdpic-plt-be.d: New file.
        * ld-sh/fdpic-plt-le.d: New file.
        * ld-sh/fdpic-plt.s: New file.
        * ld-sh/fdpic-plti20-be.d: New file.
        * ld-sh/fdpic-plti20-le.d: New file.
        * ld-sh/fdpic-stack-default.d: New file.
        * ld-sh/fdpic-stack-size.d: New file.
        * ld-sh/fdpic-stack.s: New file.
@
text
@d5438 1
a5438 1
	      aux->table[i].start.offset += rp->r_addend + sym->st_value;
d5442 1
a5442 1
	      aux->table[i].end.offset   += rp->r_addend + sym->st_value;
d5446 1
a5446 1
	      aux->table[i].info.offset  += rp->r_addend + sym->st_value;
@


1.498
log
@2010-05-24  Tristan Gingold  <gingold@@adacore.com>

	* readelf.c (usage): Add new trace sections for --debug-dump.
	(process_section_headers): Handle dump of trace sections.
	* objdump.c (usage): Add new trace sections for --dwarf.
	* dwarf.h (do_trace_info, do_trace_abbrevs): New variables.
	(do_trace_aranges): Ditto.
	(enum dwarf_section_display_enum): Add trace_info, trace_abbrev
	and trace_aranges literals.
	* dwarf.c (do_trace_info, do_trace_abbrevs): New variables.
	(do_trace_aranges): Ditto.
	(process_debug_info): Add abbrev_sec argument and replace
	abbrev with abbrev_sec.
	(load_debug_info): Adjust call of process_debug_info.
	(display_debug_info): Ditto.
	(display_trace_info): New function.
	(dwarf_select_sections_by_names): Add trace_info, trace_abbrevs
	and trace_aranges sections name.
	(dwarf_select_sections_all): Also select trace sections.
	(debug_displays): Reindent.  Add entries for the trace sections.
	* doc/binutils.texi (readelf): Document new --dwarf parameters.
	(objdump): Ditto.
@
text
@d2443 5
@


1.497
log
@Implement generic SHF_EXCLUDE.

bfd/

2010-05-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11600
	* elf.c (_bfd_elf_make_section_from_shdr): Handle SHF_EXCLUDE
	(elf_fake_sections): Likewise.

	* elf32-i370.c (i370_elf_section_from_shdr): Don't handle
	SHF_EXCLUDE here.
	* elf32-ppc.c (ppc_elf_fake_sections): Likewise.

binutils/

2010-05-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11600
	* readelf.c (get_elf_section_flags): Treat SHF_EXCLUDE as a
	generic flag.

binutils/testsuite/

2010-05-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11600
	* binutils-all/objcopy.exp: Run exclude-1a and exclude-1b for
	ELF targets.

	* binutils-all/exclude-1.s: New.
	* binutils-all/exclude-1a.d: Likewise.
	* binutils-all/exclude-1b.d: Likewise.

gas/

2010-05-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11600
	* obj-elf.c (obj_elf_change_section): Handle SHF_EXCLUDE.
	(obj_elf_parse_section_letters): Likewise.
	(obj_elf_section_word): Likewise.

	* config/tc-ppc.c (ppc_section_letter): Removed.
	(ppc_section_word): Likewise.
	* config/tc-ppc.h (ppc_section_letter): Likewise.
	(ppc_section_word): Likewise.
	(md_elf_section_letter): Likewise.
	(md_elf_section_word): Likewise.

	* doc/as.texinfo: Document `e' and `#exclude'.

gas/testsuite/

2010-05-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11600
	* gas/elf/elf.exp: Run section8.

	* gas/elf/section8.d: New.
	* gas/elf/section8.s: Likewise.

include/elf/

2010-05-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11600
	* common.h (SHF_EXCLUDE): New.

	* i370.h (SHF_EXCLUDE): Removed.
	* or32.h (SHF_EXCLUDE): Likewise.
	* ppc.h (SHF_EXCLUDE): Likewise.
	* sparc.h (SHF_EXCLUDE): Likewise.

ld/testsuite/

2010-05-18  H.J. Lu  <hongjiu.lu@@intel.com>

	PR gas/11600
	* ld-elf/exclude3.s: New.
	* ld-elf/exclude3a.d: Likewise.
	* ld-elf/exclude3b.d: Likewise.
	* ld-elf/exclude3c.d: Likewise.
@
text
@d3144 2
a3145 1
               =frames-interp,=str,=loc,=Ranges,=pubtypes]\n\
d4543 15
@


1.496
log
@Handle EM_L1OM.

2010-05-06  H.J. Lu  <hongjiu.lu@@intel.com>

	* dwarf.c (init_dwarf_regnames): Handle EM_L1OM.
	* readelf.c (get_elf_section_flags): Likewise.
	(process_section_headers): Likewise.
@
text
@d4155 2
a4157 1
      /* 18 */ { STRING_COMMA_LEN ("EXCLUDE") },
d4189 1
d4223 1
a4223 3
		  if (flag == SHF_EXCLUDE)
		    sindex = 18;
		  else if (flag == SHF_ORDERED)
d4266 1
@


1.495
log
@include/elf/
	* internal.h (ELF_SECTION_SIZE): Protect macro args with parentheses.
	Invert logic to clarify test for .tbss.
	(ELF_IS_SECTION_IN_SEGMENT): Rename to..
	(ELF_SECTION_IN_SEGMENT_1): ..this.  Add check_vma param.  Protect
	macro args with parentheses.
	(ELF_SECTION_IN_SEGMENT): Define.
	(ELF_IS_SECTION_IN_SEGMENT_FILE): Delete.
	(ELF_IS_SECTION_IN_SEGMENT_MEMORY): Delete.
bfd/
	* elf.c: Replace use of ELF_IS_SECTION_IN_SEGMENT and
	ELF_IS_SECTION_IN_SEGMENT_FILE with ELF_SECTION_IN_SEGMENT
	throughout file.
	(assign_file_positions_for_load_sections): Modify section in
	segment warning to ignore overlay vmas.
	* elf32-spu.c (spu_elf_object_p): Replace use of
	ELF_IS_SECTION_IN_SEGMENT_MEMORY with ELF_SECTION_IN_SEGMENT.
binutils/
	* readelf.c (process_program_headers): Replace use of
	ELF_IS_SECTION_IN_SEGMENT_MEMORY with ELF_SECTION_IN_SEGMENT.
@
text
@d4216 1
d4637 1
@


1.494
log
@        * readelf.c: Add _() macros to constant strings that are
        translatable.
@
text
@d3853 2
a3854 1
	      if (ELF_IS_SECTION_IN_SEGMENT_MEMORY (section, segment))
@


1.493
log
@	* ld/testsuite/ld-arm/attr-merge-2.attr: Update for changes in attribute output.
	* ld/testsuite/ld-arm/attr-merge-3.attr: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-1.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-1r.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-2.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-2r.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-3.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-3r.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-4.d: Likeiwse.
	* ld/testsuite/ld-arm/attr-merge-vfp-4r.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-5.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-vfp-5r.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-00-nowarn.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-00.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-02-nowarn.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-02.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-04-nowarn.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-04.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-20-nowarn.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-20.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-22-nowarn.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-22.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-24-nowarn.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-40-nowarn.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-40.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-42-nowarn.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-44-nowarn.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge-wchar-44.d: Likewise.
	* ld/testsuite/ld-arm/attr-merge.attr: Likewise.
	* binutils/readelf.c (arm_attr_tag_FP_arch): Rename from arm_attr_tag_VFP_arch.
	(arm_attr_tag_ABI_align8_needed): Remove.
	(arm_attr_tag_ABI_align8_preserved): Remove.
	(arm_attr_tag_ABI_HardFP_use): Update text strings.
	(arm_attr_public_tags): Add strings for ABI v2.08 attribute tags.
	(display_arm_attribute): Add decoding of ABI v2.08 attributes.
	* include/elf/arm.h (Tag_FP_arch, Tag_ABI_align_needed, Tag_ABI_align_preserved,
	Tag_FP_HP_extension): Add new ABI attribute tags.
	* gas/config/tc-arm.c (arm_convert_symbolic_attribute): Add support for
	new tag names in v2.08 of ARM ABI.
	* gas/doc/c-arm.texi: Document new tag names in ABI.
	* gas/testsuite/gas/arm/attr-mcpu.d: Update for new attribute tag names.
	* gas/testsuite/gas/arm/attr-mfpu-arm1020e.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-arm1020t.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-arm1136jf-s.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-arm1136jfs.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-neon-fp16.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-neon.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-softvfp+vfp.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfp.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfp10-r0.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfp10.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfp3.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfp9.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfpv2.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfpv3-d16.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfpv3.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfpv4-d16.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfpv4.d: Likewise.
	* gas/testsuite/gas/arm/attr-mfpu-vfpxd.d: Likewise.
	* gas/testsuite/gas/arm/attr-names.d: Add test to make sure all attribute names
	are recognised.
	* gas/testsuite/gas/arm/attr-names.s: Likewise.
@
text
@d266 4
a269 4
#define SECTION_NAME(X)	\
  ((X) == NULL ? "<none>" \
  : string_table == NULL ? "<no-name>" \
  : ((X)->sh_name >= string_table_length ? "<corrupt>" \
d1305 1
a1305 1
	    printf (" bad symbol index: %08lx", (unsigned long) symtab_index);
d2203 1
a2203 1
    strcat (buf,", <unknown>");
d2329 1
a2329 1
	    strcat (buf, ", relocatable");
d2332 1
a2332 1
	    strcat (buf, ", relocatable-lib");
d2349 1
a2349 1
	      strcat (buf, ", unknown v850 architecture variant");
d2405 1
a2405 1
	    default: strcat (buf, ", unknown CPU"); break;
d2420 1
a2420 1
	    default: strcat (buf, ", unknown ABI"); break;
d2440 1
a2440 1
	    default: strcat (buf, ", unknown ISA"); break;
d2469 1
a2469 1
	    default: strcat (buf, ", unknown ISA"); break;
d3458 1
a3458 1
		  ? "<unknown: %lx>"
d3507 1
a3507 1
	printf (" <corrupt: out of range>");
d4331 1
a4331 1
	  sprintf (p, "UNKNOWN (%*.*lx)", field_size, field_size,
d4928 1
a4928 1
			   ? strtab + sym->st_name : "<corrupt>";
d4942 1
a4942 1
	      printf ("\n%sgroup section [%5u] `%s' [%s] contains %u sections:\n",
d5254 1
a5254 1
		  ? "<corrupt>" : strtab + best->st_name);
d5308 1
a5308 1
	  printf ("\tUnknown version.\n");
d6123 1
a6123 1
      printf ("[Truncated opcode]\n");	\
d6235 1
d6517 1
a6517 1
	printf ("NONE\n");
d6530 1
d6543 1
a6543 1
	printf ("Interface Version: %s\n", GET_DYNAMIC_NAME (entry->d_un.d_val));
d6545 1
a6545 1
	printf ("<corrupt: %ld>\n", (long) entry->d_un.d_ptr);
d6558 1
a6558 1
	printf ("Time Stamp: %s\n", timebuf);
a6582 1

d6780 1
a6780 1
	default:		fputs ("unknown", stdout); break;
d7257 1
a7257 1
	      printf (" (bytes)\n");
d7387 1
a7387 1
    strcat (buff, "| <unknown>");
d7429 1
a7429 1
		    : "<corrupt>");
d7531 1
a7531 1
		    : "<corrupt>");
d8079 1
a8079 1
    printf (" <corrupt: %14ld>", psym->st_name);
d8386 1
a8386 1
			    ? strtab + psym->st_name : "<corrupt>");
d8466 1
a8466 1
				      ? strtab + ivna.vna_name : "<corrupt>",
d8519 1
a8519 1
					? strtab + ivda.vda_name : "<corrupt>");
d8695 1
a8695 1
	printf ("<corrupt: %19ld>", dynamic_symbols[i].st_name);
d9943 5
a9947 5
		case 0: printf ("None\n"); break;
		case 'A': printf ("Application\n"); break;
		case 'R': printf ("Realtime\n"); break;
		case 'M': printf ("Microcontroller\n"); break;
		case 'S': printf ("Application or Realtime\n"); break;
d9957 3
a9959 3
		case 0: printf ("None\n"); break;
		case 1: printf ("8-byte\n"); break;
		case 2: printf ("4-byte\n"); break;
d9963 1
a9963 1
		    printf ("8-byte and up to %d-byte extended\n", 
d9976 3
a9978 3
		case 0: printf ("None\n"); break;
		case 1: printf ("8-byte, except leaf SP\n"); break;
		case 2: printf ("8-byte\n"); break;
d9982 1
a9982 1
		    printf ("8-byte and up to %d-byte extended\n", 
d9993 1
a9993 1
	      printf ("flag = %d, vendor = %s\n", val, p);
d9999 1
a9999 1
	      printf ("True\n");
d10083 1
a10083 1
      printf ("flag = %d, vendor = %s\n", val, p);
d10128 1
a10128 1
	  printf ("Hard or soft float\n");
d10131 1
a10131 1
	  printf ("Hard float\n");
d10134 1
a10134 1
	  printf ("Soft float\n");
d10137 1
a10137 1
	  printf ("Single-precision hard float\n");
d10154 1
a10154 1
	  printf ("Any\n");
d10157 1
a10157 1
	  printf ("Generic\n");
d10180 1
a10180 1
         printf ("Any\n");
d10186 1
a10186 1
         printf ("Memory\n");
d10232 1
a10232 1
	  printf ("Hard or soft float\n");
d10235 1
a10235 1
	  printf ("Hard float (-mdouble-float)\n");
d10238 1
a10238 1
	  printf ("Hard float (-msingle-float)\n");
d10241 1
a10241 1
	  printf ("Soft float\n");
d10244 1
a10244 1
	  printf ("64-bit float (-mips32r2 -mfp64)\n");
d10325 1
a10325 1
	      printf ("Attribute Section: %s\n", p);
d10362 1
a10362 1
		      printf ("File Attributes\n");
d10365 1
a10365 1
		      printf ("Section Attributes:");
d10368 1
a10368 1
		      printf ("Symbol Attributes:");
d10383 1
a10383 1
		      printf ("Unknown tag: %d\n", tag);
d10402 1
a10402 1
		      printf ("  Unknown section contexts\n");
d10446 1
a10446 1
    printf ("%*s", is_32bit_elf ? 8 : 16, "<unknown>");
d10468 1
a10468 1
    printf ("%*s", is_32bit_elf ? 8 : 16, "<unknown>");
d10566 1
a10566 1
	  printf ("\nSection '.liblist' contains %lu entries:\n",
d10568 1
a10568 1
	  fputs ("     Library              Time Stamp          Checksum   Version Flags\n",
d10594 1
a10594 1
		printf ("<corrupt: %9ld>", liblist.l_name);
d10599 1
a10599 1
		puts (" NONE");
d10898 1
a10898 1
	    printf ("<corrupt: %14ld>", psym->st_name);
d10927 2
a10928 2
	      addr_size * 2, "Address", "Access",
	      addr_size * 2, "Initial");
d10930 1
a10930 1
      printf (" Lazy resolver\n");
d10936 1
a10936 1
	  printf (" Module pointer (GNU extension)\n");
d10944 2
a10945 2
		  addr_size * 2, "Address", "Access",
		  addr_size * 2, "Initial");
d10960 3
a10962 3
		  addr_size * 2, "Address", "Access",
		  addr_size * 2, "Initial",
		  addr_size * 2, "Sym.Val.", "Type", "Ndx", "Name");
d10978 1
a10978 1
		printf ("<corrupt: %14ld>", psym->st_name);
d11019 1
a11019 1
	      addr_size * 2, "Address", addr_size * 2, "Initial");
d11021 1
a11021 1
      printf (" PLT lazy resolver\n");
d11023 1
a11023 1
      printf (" Module pointer\n");
d11028 3
a11030 3
	      addr_size * 2, "Address",
	      addr_size * 2, "Initial",
	      addr_size * 2, "Sym.Val.", "Type", "Ndx", "Name");
d11046 1
a11046 1
	    printf ("<corrupt: %14ld>", psym->st_name);
d11107 1
a11107 1
	  puts ("     Library              Time Stamp          Checksum   Version Flags");
d11132 1
a11132 1
				 ? strtab + liblist.l_name : "<corrupt>");
d11135 1
a11135 1
				    ? strtab + liblist.l_name : "<corrupt>");
d11272 1
a11272 1
	case NT_NETBSDCORE_FIRSTMACH+0:
d11274 1
a11274 1
	case NT_NETBSDCORE_FIRSTMACH+2:
d11286 1
a11286 1
	case NT_NETBSDCORE_FIRSTMACH+1:
d11288 1
a11288 1
	case NT_NETBSDCORE_FIRSTMACH+3:
@


1.492
log
@bfd/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * aoutx.h (aout_link_input_bfd): Remove unused variable sym_count.
        * elf-eh-frame.c (_bfd_elf_eh_frame_section_offset): Remove unused
        variables htab and hdr_info and mark info parameter as unused.
        * elf.c (prep_headers): Remove unused variable i_phdrp.
        (_bfd_elf_write_object_contents): Remove unused variable i_ehdrp.
        * elf32-i386.c (elf_i386_relocate_section): Mark variabled warned
        as unused.
        * peXXigen.c (pe_print_reloc): Remove unused variable datasize.
        * verilog.c (verilog_write_section): Remove unused variable
        address.

binutils/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * dwarf.c (process_debug_info): Remove unused variable
        cu_abbrev_offset_ptr.
        (display_debug_lines_decoded): Remove unused variable prev_line.
        * elfedit.c (process_archive): Remove unused variable
        file_name_size.
        * ieee.c (ieee_start_compilation_unit): Remove unused variable
        nindx.
        (ieee_set_type): Remove unused variables info, targetindx and
        baseindx.
        * objdump.c (disassmble_byte): Remove unused variable done_dot.
        * rddbg.c (read_section_stabs_debugging_info): Remove unused
        variable other.
        * readelf.c (dump_section_as_strings): Remove unused variable
        addr.
        (process_archive): Remove unused variable file_name_size.
        * stabs.c (parse_stab_string): Mark desc parameter as unused.
        Remove unused variable lineno.
        (parse_stab_struct_type): Remove unused variable orig.
        (stab_demangle_type): Remove unused variables constp, volatilep
        and hold.

gas/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * as.c (create_obj_attrs_section): Remove unused variable addr.
        * listing.c (listing_listing): Remove unused variable message.
        * read.c: Remove unnecessary register type qualifiers.
        (s_mri): Only define/use old_flag variable if MRI_MODE_CHANGE is
        defined.

ld/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * ldlang.c (wild_sort): Remove unused variable section_name.

opcodes/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * i386-dis.c (print_insn): Remove unused variable op.
        (OP_sI): Remove unused variable mask.
@
text
@d9804 1
a9804 1
static const char * arm_attr_tag_VFP_arch[] =
a9828 3
static const char * arm_attr_tag_ABI_align8_needed[] = {"No", "Yes", "4-byte"};
static const char * arm_attr_tag_ABI_align8_preserved[] =
  {"No", "Yes, except leaf SP", "Yes"};
d9832 1
a9832 1
  {"As Tag_VFP_arch", "SP only", "DP only", "SP and DP"};
d9844 1
a9844 1
static const char * arm_attr_tag_VFP_HP_extension[] =
d9870 1
a9870 1
  LOOKUP(10, VFP_arch),
d9884 2
a9885 2
  LOOKUP(24, ABI_align8_needed),
  LOOKUP(25, ABI_align8_preserved),
d9894 1
a9894 1
  LOOKUP(36, VFP_HP_extension),
d9946 1
d9951 38
@


1.491
log
@bfd:
	* Makefile.am (ALL_MACHINES): Add cpu-tic6x.lo.
	(ALL_MACHINES_CFILES): Add cpu-tic6x.c.
	(BFD32_BACKENDS): Add elf32-tic6x.lo.
	(BFD32_BACKENDS_CFILES): Add elf32-tic6x.c.
	* Makefile.in: Regenerate.
	* archures.c (bfd_arch_tic6x, bfd_tic6x_arch): New.
	(bfd_archures_list): Update.
	* config.bfd (tic6x-*-elf): New.
	* configure.in (bfd_elf32_tic6x_be_vec, bfd_elf32_tic6x_le_vec):
	New.
	* configure: Regenerate.
	* cpu-tic6x.c, elf32-tic6x.c: New.
	* reloc.c (BFD_RELOC_C6000_PCR_S21, BFD_RELOC_C6000_PCR_S12,
	BFD_RELOC_C6000_PCR_S10, BFD_RELOC_C6000_PCR_S7,
	BFD_RELOC_C6000_ABS_S16, BFD_RELOC_C6000_ABS_L16,
	BFD_RELOC_C6000_ABS_H16, BFD_RELOC_C6000_SBR_U15_B,
	BFD_RELOC_C6000_SBR_U15_H, BFD_RELOC_C6000_SBR_U15_W,
	BFD_RELOC_C6000_SBR_S16, BFD_RELOC_C6000_SBR_L16_B,
	BFD_RELOC_C6000_SBR_L16_H, BFD_RELOC_C6000_SBR_L16_W,
	BFD_RELOC_C6000_SBR_H16_B, BFD_RELOC_C6000_SBR_H16_H,
	BFD_RELOC_C6000_SBR_H16_W, BFD_RELOC_C6000_SBR_GOT_U15_W,
	BFD_RELOC_C6000_SBR_GOT_L16_W, BFD_RELOC_C6000_SBR_GOT_H16_W,
	BFD_RELOC_C6000_DSBT_INDEX, BFD_RELOC_C6000_PREL31,
	BFD_RELOC_C6000_COPY, BFD_RELOC_C6000_ALIGN,
	BFD_RELOC_C6000_FPHEAD, BFD_RELOC_C6000_NOCMP): New.
	* targets.c (bfd_elf32_tic6x_be_vec, bfd_elf32_tic6x_le_vec): New.
	(_bfd_target_vector): Update.
	* bfd-in2.h, libbfd.h: Regenerate.

binutils:
	* MAINTAINERS: Add self as TI C6X maintainer.
	* NEWS: Add news entry for TI C6X support.
	* readelf.c: Include elf/tic6x.h.
	(guess_is_rela): Handle EM_TI_C6000.
	(dump_relocations): Likewise.
	(get_tic6x_dynamic_type): New.
	(get_dynamic_type): Call it.
	(get_machine_flags): Handle EF_C6000_REL.
	(get_osabi_name): Handle machine-specific values only for relevant
	machines.  Handle C6X values.
	(get_tic6x_segment_type): New.
	(get_segment_type): Call it.
	(get_tic6x_section_type_name): New.
	(get_section_type_name): Call it.
	(is_32bit_abs_reloc, is_16bit_abs_reloc, is_none_reloc): Handle
	EM_TI_C6000.

gas:
	* Makefile.am (TARGET_CPU_CFILES): Add config/tc-tic6x.c.
	(TARGET_CPU_HFILES): Add config/tc-tic6x.h.
	* Makefile.in: Regenerate.
	* NEWS: Add news entry for TI C6X support.
	* app.c (do_scrub_chars): Handle "||^" for TI C6X.  Handle
	TC_PREDICATE_START_CHAR and TC_PREDICATE_END_CHAR.  Keep spaces in
	operands if TC_KEEP_OPERAND_SPACES.
	* configure.tgt (tic6x-*-*): New.
	* config/tc-ia64.h (TC_PREDICATE_START_CHAR,
	TC_PREDICATE_END_CHAR): Define.
	* config/tc-tic6x.c, config/tc-tic6x.h: New.
	* doc/Makefile.am (CPU_DOCS): Add c-tic6x.texi.
	* doc/Makefile.in: Regenerate.
	* doc/all.texi (TIC6X): Define.
	* doc/as.texinfo: Add TI C6X documentation.  Include c-tic6x.texi.
	* doc/c-tic6x.texi: New.

gas/testsuite:
	* gas/tic6x: New directory and testcases.

include:
	* dis-asm.h (print_insn_tic6x): Declare.

include/elf:
	* common.h (ELFOSABI_C6000_ELFABI, ELFOSABI_C6000_LINUX): Define.
	* tic6x.h: New.

include/opcode:
	* tic6x-control-registers.h, tic6x-insn-formats.h,
	tic6x-opcode-table.h, tic6x.h: New.

ld:
	* Makefile.am (ALL_EMULATIONS): Add eelf32_tic6x_be.o and
	eelf32_tic6x_le.o.
	(eelf32_tic6x_be.c, eelf32_tic6x_le.c): New.
	* NEWS: Add news entry for TI C6X support.
	* configure.tgt (tic6x-*-*): New.
	* emulparams/elf32_tic6x_be.sh, emulparams/elf32_tic6x_le.sh: New.

ld/testsuite:
	* ld-elf/flags1.d, ld-elf/merge.d: XFAIL for tic6x-*-*.
	* ld-elf/sec-to-seg.exp: Set B_test_same_seg to 0 for tic6x-*-*.
	* ld-tic6x: New directory and testcases.

opcodes:
	* Makefile.am (TARGET_LIBOPCODES_CFILES): Add tic6x-dis.c.
	* Makefile.in: Regenerate.
	* configure.in (bfd_tic6x_arch): New.
	* configure: Regenerate.
	* disassemble.c (ARCH_tic6x): Define if ARCH_all.
	(disassembler): Handle TI C6X.
	* tic6x-dis.c: New.
@
text
@a9340 1
  bfd_vma addr;
a9373 1
  addr = section->sh_addr;
a12132 1
  size_t file_name_size;
a12225 1
  file_name_size = strlen (file_name);
@


1.490
log
@Avoid buffer overflow.

2010-03-18  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (decode_arm_unwind): Increase buf size to 9 byte.
@
text
@d140 1
d652 1
d1266 4
d1647 15
d1774 3
d2571 4
a2603 2
    case ELFOSABI_STANDALONE:	return _("Standalone App");
    case ELFOSABI_ARM:		return "ARM";
d2605 35
d2727 13
d2780 3
d2944 27
d3028 3
d8911 2
d9096 2
d9134 1
@


1.489
log
@warning fixes
@
text
@d6197 1
a6197 1
	  unsigned char buf[5];
d6200 1
a6200 1
	  for (i = 0; i < 9; i++)
@


1.488
log
@	include:
	* elf/common.h (VER_FLG_*): Document.
	(VER_FLG_INFO): Define.

	gold:
	* dynobj.h (Verdef::Verdef): Add is_info arg, is_info member
	function, is_info_ member.
	* dynobj.cc (Verdef::write): Set VER_FLG_INFO if this->is_info_.
	(Versions::Versions): Update caller.
	(Versions::define_base_version): Likewise.
	(Versions::add_def): Likewise.

	elfcpp:
	* elfcpp.h (VER_FLG_INFO): Define.

	binutils:
	* readelf.c (get_ver_flags): Handle VER_FLG_INFO.
@
text
@d6279 1
a6279 1
	  bfd_vma table, table_offset;
@


1.487
log
@	* NEWS: Document .ARM.exidx / .ARM.extab support.

	* dwarf.c (read_leb128): Make non-static.
	* dwarf.h (read_leb128): Declare.
	* readelf.c (REMOVE_ARCH_BITS): Define.
	(find_section_by_address): New.
	(read_uleb128): Move higher.  Use read_leb128 from dwarf.c.
	(find_symbol_for_address): Handle the Thumb bit for ARM, by
	using REMOVE_ARCH_BITS.
	(struct arm_section, struct arm_unw_aux_info, arm_print_vma_and_name)
	(arm_free_section, arm_section_get_word, decode_arm_unwind)
	(dump_arm_unwind, arm_process_unwind): New.
	(process_unwind): Handle ARM.
@
text
@d7270 9
a7278 1
  if (flags & ~(VER_FLG_BASE | VER_FLG_WEAK))
@


1.486
log
@	* readelf.c (get_group_flags): Return empty string when flags zero.
	Add space in other returned values.
	(process_section_groups): Adjust format string.
@
text
@d288 5
d552 27
d5124 2
d5128 4
d5135 2
a5136 2
	  && addr.offset >= sym->st_value
	  && addr.offset - sym->st_value < dist)
d5139 1
a5139 1
	  dist = addr.offset - sym->st_value;
d5802 573
d6384 1
a9791 27
/* Read an unsigned LEB128 encoded value from p.  Set *PLEN to the number of
   bytes read.  */

static unsigned int
read_uleb128 (unsigned char * p, unsigned int * plen)
{
  unsigned char c;
  unsigned int val;
  int shift;
  int len;

  val = 0;
  shift = 0;
  len = 0;
  do
    {
      c = *(p++);
      len++;
      val |= ((unsigned int)c & 0x7f) << shift;
      shift += 7;
    }
  while (c & 0x80);

  *plen = len;
  return val;
}

@


1.485
log
@	* bfd/elf32-arm.c (elf32_arm_merge_eabi_attributes): Add support for
	merging Tag_DIV_use, Tag_MPextension_use, and
	Tag_MPextension_use_legacy tags.
	* binutils/readelf.c (arm_attr_tag_Advanced_SIMD_arch): Add
	description of newly permitted attribute values.
	(arm_attr_tag_Virtualization_use): Likewise.
	(arm_attr_tag_DIV_use): Add description of new attribute.
	(arm_attr_tag_MPextension_use_legacy): Likewise.
	* gas/config/tc-arm.c (arm_convert_symbolic_attribute):
	Add Tag_DIV_use.
	* gas/doc/c-arm.texi: Likewise.
	* gas/testsuite/gas/arm/attr-order.d: Fix test for new names for
	attribute values.
	* include/elf/arm.h (Tag_MPextension_use): Renumber.
	(Tag_DIV_use): Add.
	(Tag_MPextension_use_legacy): Likewise.
	* ld/testsuite/ld-arm/attr-merge-3.attr: Fix test for new attribute
	values.
	* ld/testsuite/ld-arm/attr-merge-3b.s: Likewise.
	* ld/testsuite/ld-arm/attr-merge-unknown-1.d: Fix test now that 42
	is a recognised attribute ID.
	* ld/testsuite/ld-arm/attr-merge-unknown-1.s: Likewise.
	* ld/testsuite/ld-arm/attr-merge-6.attr: New test.
	* ld/testsuite/ld-arm/attr-merge-6a.s: Likewise.
	* ld/testsuite/ld-arm/attr-merge-6b.s: Likewise.
	* ld/testsuite/ld-arm/attr-merge-7.attr: Likewise.
	* ld/testsuite/ld-arm/attr-merge-7a.s: Likewise.
	* ld/testsuite/ld-arm/attr-merge-7b.s: Likewise.
	* ld/testsuite/ld-arm/arm-elf.exp: Run the new tests.
@
text
@d4636 3
d4640 1
a4640 1
      return "COMDAT";
d4643 1
a4643 1
      snprintf (buff, sizeof (buff), _("[<unknown>: 0x%x]"), flags);
d4803 1
a4803 1
	      printf ("\n%s group section [%5u] `%s' [%s] contains %u sections:\n",
@


1.484
log
@bfd/

2010-02-09  Michael Holzheu  <holzheu@@de.ibm.com>

	* elf-bfd.h (elfcore_write_s390_timer, elfcore_write_s390_todcmp,
	elfcore_write_s390_todpreg, elfcore_write_s390_ctrs,
	elfcore_write_s390_prefix): New.
	* elf.c (elfcore_write_s390_timer, elfcore_write_s390_todcmp,
	elfcore_write_s390_todpreg, elfcore_write_s390_ctrs,
	elfcore_write_s390_prefix): New.
	(elfcore_grok_note): Handle NT_S390_TIMER, NT_S390_TODCMP,
	NT_S390_TODPREG, NT_S390_CTRS and NT_S390_PREFIX.
	(elfcore_write_register_note): Handle .reg-s390-timer,
	.reg-s390-todcmp, .reg-s390-todpreg, .reg-s390-ctrs,
	.reg-s390-prefix section.

binutils/

2010-02-09  Michael Holzheu  <holzheu@@de.ibm.com>

	* readelf.c (get_note_type): Handle NT_S390_TIMER, NT_S390_TODCMP,
	NT_S390_TODPREG, NT_S390_CTRS and NT_S390_PREFIX.

include/elf/

2010-02-09  Michael Holzheu  <holzheu@@de.ibm.com>

	* common.h (NT_S390_TIMER, NT_S390_TODCMP, NT_S390_TODPREG,
	NT_S390_CTRS and NT_S390_PREFIX): Define.
@
text
@d9074 2
a9075 1
static const char * arm_attr_tag_Advanced_SIMD_arch[] = {"No", "NEONv1"};
d9118 5
d9125 3
a9128 1
static const char * arm_attr_tag_MPextension_use[] = {"Not Allowed", "Allowed"};
d9166 2
d9173 1
a9173 1
  LOOKUP(70, MPextension_use)
@


1.483
log
@Add NT_386_XSTATE.

bfd/

2010-02-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (elfcore_write_xstatereg): New.

	* elf.c (elfcore_grok_xstatereg): New.
	(elfcore_write_xstatereg): Likewise.
	(elfcore_grok_note): Handle NT_X86_XSTATE.
	(elfcore_write_register_note): Handle .reg-xstate section.

binutils/

2010-02-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (get_note_type): Handle NT_X86_XSTATE.

include/elf/

2010-02-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* common.h (NT_386_XSTATE): New.
@
text
@d10422 10
@


1.482
log
@2010-01-21  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* readelf.c (get_machine_flags): Handle EF_S390_HIGH_GPRS.

2010-01-21  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* s390.h (EF_S390_HIGH_GPRS): Added macro definition.

2010-01-21  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* config/tc-s390.c (s390_elf_final_processing): New function.
	* config/tc-s390.h (elf_tc_final_processing): New macro definition.
	(s390_elf_final_processing): Added prototype.

2010-01-21  Andreas Krebbel  <Andreas.Krebbel@@de.ibm.com>

	* elf32-s390.c (elf32_s390_merge_private_bfd_data): New function.
	(bfd_elf32_bfd_merge_private_bfd_data): New macro definition.
@
text
@d10418 2
@


1.481
log
@        * readelf.c (process_file_header): Handle e_phnum extension.
@
text
@d2511 4
@


1.480
log
@Add --dyn-syms to readelf

binutils/

2010-01-11  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11146
	* NEWS: Mention --dyn-syms for readelf.

	* readelf.c (do_dyn_syms): New.
	(OPTION_DYN_SYMS): Likewise.
	(options): Add "dyn-syms".
	(usage): Add --dyn-syms.
	(parse_args): Handle OPTION_DYN_SYMS.
	(process_symbol_table): Handle do_dyn_syms.
	(process_object): Likewise.
	(process_archive): Likewise.

	* doc/binutils.texi: Document --dyn-syms for readelf.  Mention
	symbol hash tables for -D.

ld/testsuite/

2010-01-11  H.J. Lu  <hongjiu.lu@@intel.com>

	PR ld/11146
	* ld-elf/dynsym1.d: New.
@
text
@d3343 1
a3343 1
      printf (_("  Number of program headers:         %ld\n"),
d3345 5
d3370 3
@


1.479
log
@Fix indent for --symbols in "readelf -h"

2010-01-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (usage): Fix indent for --symbols.
@
text
@d181 1
d2927 1
d2944 1
d2984 1
d3209 3
d3238 2
a3239 1
      && !do_section_groups && !do_archive_index)
d7354 1
a7354 1
  if (! do_syms && !do_histogram)
d7359 3
a7361 1
	  || (do_using_dynamic && dynamic_strings != NULL)))
d7417 3
a7419 1
	  || (do_using_dynamic && dynamic_strings != NULL)))
d7576 1
a7576 1
  else if (do_syms && !do_using_dynamic)
d7590 4
a7593 2
	  if (   section->sh_type != SHT_SYMTAB
	      && section->sh_type != SHT_DYNSYM)
d10876 1
a10876 1
	do_syms = do_reloc = 0;
d11480 1
a11480 1
	  && !do_section_groups)
@


1.478
log
@Update copyright

2010-01-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* objcopy.c: Update copyright.
	* readelf.c: Likewise.
@
text
@d2980 1
a2980 1
      --symbols          An alias for --syms\n\
@


1.477
log
@        PR 11128
        * readelf.c (dump_section_as_strings): Use two separate
        invocations of printf() in order to work around bugs in
        the Solaris 8 implementation.
@
text
@d3 2
a4 1
   2008, 2009  Free Software Foundation, Inc.
@


1.476
log
@include/elf/
	* common.h (NT_S390_HIGH_GPRS): Define.

bfd/
	* elf.c (elfcore_grok_s390_high_gprs): New function.
	(elfcore_grok_note): Handle NT_S390_HIGH_GPRS notes.
	(elfcore_write_s390_high_gprs): New function.
	(elfcore_write_register_note): Call it.

binutils/
	* readelf.c (get_note_type): Handle NT_S390_HIGH_GPRS notes.
@
text
@d8627 4
a8630 1
	  printf ("  [%6tx]  %s\n", data - start, data);
@


1.475
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d10388 2
@


1.474
log
@include/
2009-12-03  David Daney  <ddaney@@caviumnetworks.com>
	Adam Nemet  <adambnemet@@gmail.com>

	* elf/mips.h (E_MIPS_MACH_OCTEON2): New machine flag.
binutils/
2009-12-03  David Daney  <ddaney@@caviumnetworks.com>
	Adam Nemet  <adambnemet@@gmail.com>

	* readelf.c (get_machine_flags): Handle E_MIPS_MACH_OCTEON2 case.
@
text
@d732 7
a738 7
	      bfd_vma info = relas[i].r_info;
	      info = (((info & 0xffffffff) << 32)
		      | ((info >> 56) & 0xff)
		      | ((info >> 40) & 0xff00)
		      | ((info >> 24) & 0xff0000)
		      | ((info >> 8) & 0xff000000));
	      relas[i].r_info = info;
d828 7
a834 7
	      bfd_vma info = rels[i].r_info;
	      info = (((info & 0xffffffff) << 32)
		      | ((info >> 56) & 0xff)
		      | ((info >> 40) & 0xff00)
		      | ((info >> 24) & 0xff0000)
		      | ((info >> 8) & 0xff000000));
	      rels[i].r_info = info;
d945 1
a945 1
      bfd_vma info;
d950 1
a950 1
      info   = rels[i].r_info;
d952 2
a953 2
      type = get_reloc_type (info);
      symtab_index = get_reloc_symindex  (info);
d959 1
a959 1
		  (unsigned long) info & 0xffffffff);
d967 1
a967 1
		  offset, info);
d973 1
a973 1
		  offset, info);
d978 1
a978 1
		  offset, info);
d986 2
a987 2
		  _bfd_int64_high (info),
		  _bfd_int64_low (info));
d1358 1
a1358 1
		  long offset = (long) (bfd_signed_vma) rels[i].r_addend;
d1360 2
a1361 2
		  if (offset < 0)
		    printf (" - %lx", - offset);
d1363 1
a1363 1
		    printf (" + %lx", offset);
d1377 1
a1377 1
	printf (" + %lx", (unsigned long) ELF64_R_TYPE_DATA (info));
d1384 2
a1385 2
	  bfd_vma type2 = ELF64_MIPS_R_TYPE2 (info);
	  bfd_vma type3 = ELF64_MIPS_R_TYPE3 (info);
d3371 1
a3371 1
get_32bit_program_headers (FILE * file, Elf_Internal_Phdr * program_headers)
d3385 1
a3385 1
  for (i = 0, internal = program_headers, external = phdrs;
d3405 1
a3405 1
get_64bit_program_headers (FILE * file, Elf_Internal_Phdr * program_headers)
d3419 1
a3419 1
  for (i = 0, internal = program_headers, external = phdrs;
d3962 2
a3963 1
  int index, size = sizeof (buff) - (field_size + 4 + 1);
d4017 10
a4026 10
	    case SHF_WRITE:		index = 0; break;
	    case SHF_ALLOC:		index = 1; break;
	    case SHF_EXECINSTR:		index = 2; break;
	    case SHF_MERGE:		index = 3; break;
	    case SHF_STRINGS:		index = 4; break;
	    case SHF_INFO_LINK:		index = 5; break;
	    case SHF_LINK_ORDER:	index = 6; break;
	    case SHF_OS_NONCONFORMING:	index = 7; break;
	    case SHF_GROUP:		index = 8; break;
	    case SHF_TLS:		index = 9; break;
d4029 1
a4029 1
	      index = -1;
d4034 1
a4034 1
		    index = 10;
d4036 1
a4036 1
		    index = 11;
d4041 6
a4046 6
		      case SHF_IA_64_VMS_GLOBAL:      index = 12; break;
		      case SHF_IA_64_VMS_OVERLAID:    index = 13; break;
		      case SHF_IA_64_VMS_SHARED:      index = 14; break;
		      case SHF_IA_64_VMS_VECTOR:      index = 15; break;
		      case SHF_IA_64_VMS_ALLOC_64BIT: index = 16; break;
		      case SHF_IA_64_VMS_PROTECTED:   index = 17; break;
d4060 1
a4060 1
		    index = 18;
d4062 1
a4062 1
		    index = 19;
d4069 1
a4069 1
	  if (index != -1)
d4080 2
a4081 2
	      size -= flags [index].len;
	      p = stpcpy (p, flags [index].str);
d5808 2
a5809 2
	time_t time = entry->d_un.d_val;
	tmp = gmtime (&time);
d6563 1
a6563 1
	      time_t time = entry->d_un.d_val;
d6565 1
a6565 1
	      tmp = gmtime (&time);
d7726 1
a7726 1
			      unsigned long offset;
d7728 1
a7728 1
			      offset = offset_from_vma
d7737 1
a7737 1
				  get_data (&evd, file, offset, sizeof (evd),
d7744 1
a7744 1
				  offset += ivd.vd_next;
d7749 2
a7750 2
			      offset -= ivd.vd_next;
			      offset += ivd.vd_aux;
d7752 1
a7752 1
			      get_data (&evda, file, offset, sizeof (evda),
d8449 1
a8449 1
	  unsigned char * loc;
d8474 2
a8475 2
	  loc = start + rp->r_offset;
	  if ((loc + reloc_size) > end)
d8518 1
a8518 1
	    addend += byte_get (loc, reloc_size);
d8526 1
a8526 1
	      byte_put (loc, (addend + sym->st_value) - rp->r_offset,
d8530 1
a8530 1
	    byte_put (loc, addend + sym->st_value, reloc_size);
d9589 1
a9589 1
			  unsigned int i;
d9591 2
a9592 2
			  val = read_uleb128 (p, &i);
			  p += i;
d9791 1
a9791 1
	      time_t time;
d9796 1
a9796 1
	      time = BYTE_GET (elib[cnt].l_time_stamp);
d9801 1
a9801 1
	      tmp = gmtime (&time);
d10124 1
a10124 1
      bfd_vma entry, local_end, global_end;
d10129 1
a10129 1
      entry = pltgot;
d10146 1
a10146 1
      entry = print_mips_got_entry (data, pltgot, entry);
d10149 1
a10149 1
	  && (byte_get (data + entry - pltgot, addr_size)
d10152 1
a10152 1
	  entry = print_mips_got_entry (data, pltgot, entry);
d10157 1
a10157 1
      if (entry < local_end)
d10163 1
a10163 1
	  while (entry < local_end)
d10165 1
a10165 1
	      entry = print_mips_got_entry (data, pltgot, entry);
d10186 1
a10186 1
	      entry = print_mips_got_entry (data, pltgot, entry);
d10207 1
a10207 1
      bfd_vma entry, end;
d10226 1
a10226 1
      entry = mips_pltgot;
d10237 1
a10237 1
      entry = print_mips_pltgot_entry (data, mips_pltgot, entry);
d10239 1
a10239 1
      entry = print_mips_pltgot_entry (data, mips_pltgot, entry);
d10254 1
a10254 1
	  entry = print_mips_pltgot_entry (data, mips_pltgot, entry);
d10330 1
a10330 1
	      time_t time;
d10335 1
a10335 1
	      time = BYTE_GET (elib[cnt].l_time_stamp);
d10340 1
a10340 1
	      tmp = gmtime (&time);
@


1.473
log
@        PR binutils/11045
        * dwarf.c (do_debug_pubtypes): New variable.
        (dwarf_select_sections_by_names): Handle .debug_pubtypes.
        (dwarf_select_sections_by_letters): Add 't' for .debug_pubtype.
        (dwarf_select_sections_all): Set do_debug_pubtypes.
        (debug_displays): Add support for .debug_pubtypes.
        * dwarf.h (do_debug_pubtypes): Export.
        * objdump.c (usage): Add -wt or --dwarf=pubtypes.
        * readelf.c (usage): Likewise.
        (process_section_headers): Enable debug display if
        do_debug_pubtypes is set.
        * doc/binutils.texi: Document -wt/--dwarf=pubtypes option.
@
text
@d2340 1
@


1.472
log
@	* readelf.c (get_machine_name, get_osabi_name): Handle more
	allocated values.
@
text
@d2993 1
a2993 1
  -w[lLiaprmfFsoR] or\n\
d2995 1
a2995 1
               =frames-interp,=str,=loc,=Ranges]\n\
d4344 1
a4344 1
		|| do_debug_lines || do_debug_pubnames
d4361 1
@


1.471
log
@        * readelf.c: Include xc16x.h.
        (dump_relocations): Handle relocations for the xc16x target.
        (get_machine_name): Accept EM_C166 for xc16x targets.
        (is_32bit_abs_reloc): Add support for xc16c 32-bit absolute reloc.
        (is_16bit_abs_reloc): Add support for xc16c 16-bit absolute reloc.
        (is_none_reloc): Add support for xc16c null reloc.
@
text
@d1855 3
d1885 1
d1893 9
d1907 6
d1917 25
d1948 10
d2536 1
@


1.470
log
@2009-11-17  Paul Brook  <paul@@codesourcery.com>
	Daniel Jacobowitz  <dan@@codesourcery.com>

	gas/
	* doc/c-arm.texi: Document .arch armv7e-m.
	* config/tc-arm.c (arm_ext_v6_dsp, arm_ext_v7m): New.
	(insns): Put Thumb versions of v5TExP instructions into
	arm_ext_v5exp also.  Move some Thumb variants from
	arm_ext_v6_notm to arm_ext_v6_dsp.
	(arm_archs): Add armv7e-m architecture.
	(aeabi_set_public_attributes): Handle -march=armv7e-m.

	gas/testsuite/
	* gas/arm/attr-march-armv7em.d: New test.
	* gas/arm/arch7em-bad.d: New test.
	* gas/arm/arch7em-bad.l: New test.
	* gas/arm/arch7em.d: New test.
	* gas/arm/arch7em.s: New test.

	include/elf/
	* arm.h (TAG_CPU_ARCH_V7E_M): Define.

	include/opcode/
	* arm.h (ARM_EXT_V6_DSP): Define.
	(ARM_AEXT_V6T2, ARM_AEXT_NOTM): Include ARM_EXT_V6_DSP.
	(ARM_AEXT_V7EM, ARM_ARCH_V7EM): Define.

	binutils/
	* readelf.c (arm_attr_tag_CPU_arch): Add v7E-M.

	bfd/
	* elf32-arm.c (using_thumb_only, arch_has_arm_nop,
	arch_has_thumb2_nop): Handle TAG_CPU_ARCH_V7E_M.
	(tag_cpu_arch_combine): Ditto. Correct MAX_TAG_CPU_ARCH test.
@
text
@d142 1
d1225 5
d1896 1
d8104 3
a8111 1

d8279 3
d8315 2
@


1.469
log
@	* readelf.c (slurp_hppa_unwind_table): Don't relocate address twice.
@
text
@d8965 1
a8965 1
   "v6K", "v7", "v6-M", "v6S-M"};
@


1.468
log
@2009-11-02  Paul Brook  <paul@@codesourcery.com>

	ld/testsuite/
	* ld-arm/arm-elf.exp: Add new attr-merge-vfp tests.
	* ld-arm/attr-merge-vfp-1.d: New test.
	* ld-arm/attr-merge-vfp-1r.d: New test.
	* ld-arm/attr-merge-vfp-2.d: New test.
	* ld-arm/attr-merge-vfp-2r.d: New test.
	* ld-arm/attr-merge-vfp-3.d: New test.
	* ld-arm/attr-merge-vfp-3r.d: New test.
	* ld-arm/attr-merge-vfp-4.d: New test.
	* ld-arm/attr-merge-vfp-4r.d: New test.
	* ld-arm/attr-merge-vfp-5.d: New test.
	* ld-arm/attr-merge-vfp-5r.d: New test.
	* ld-arm/attr-merge-vfp-2.s: New test.
	* ld-arm/attr-merge-vfp-3.s: New test.
	* ld-arm/attr-merge-vfp-3-d16.s: New test.
	* ld-arm/attr-merge-vfp-4.s: New test.
	* ld-arm/attr-merge-vfp-4-d16.s: New test.

	gas/
	* doc/c-arm.texi: Document new -mfpu options.
	* config/tc-arm.c (fpu_vfp_ext_v3xd, fpu_vfp_fp16, fpu_neon_ext_fma,
	fpu_vfp_ext_fma): New.
	(NEON_ENC_TAB): Add vfma, vfms, vfnma and vfnms.
	(do_vfp_nsyn_fma_fms, do_neon_fmac): New functions.
	(insns): Move double precision load/store.  Split out double
	precision VFPv3 instrucitons.  Add VFPv4 instructions.
	(arm_fpus): Add VFPv3-FP16, VFPv3xD and VFPv4 variants.
	(aeabi_set_public_attributes): Set VFPv4 variants

	gas/testsuite/
	* gas/arm/attr-mfpu-vfpv4.d: New test.
	* gas/arm/attr-mfpu-vfpv4-d16.d: New test.
	* gas/arm/neon-fma-cov.d: New test.
	* gas/arm/neon-fma-cov.s: New test.
	* gas/arm/vfp-fma-inc.s: New test.
	* gas/arm/vfp-fma-arm.d: New test.
	* gas/arm/vfp-fma-arm.s: New test.
	* gas/arm/vfp-fma-thumb.d: New test.
	* gas/arm/vfp-fma-thumb.s: New test.
	* gas/arm/vfma1.d: New test.
	* gas/arm/vfma1.s: New test.
	* gas/arm/vfpv3xd.d: New test.
	* gas/arm/vfpv3xd.s: New test.

	include/opcode/
	* arm.h (FPU_VFP_EXT_V3xD, FPU_VFP_EXT_FP16, FPU_NEON_EXT_FMA,
	FPU_VFP_EXT_FMA, FPU_VFP_V3xD, FPU_VFP_V4D16, FPU_VFP_V4): Define.
	(FPU_ARCH_VFP_V3D16_FP16, FPU_ARCH_VFP_V3_FP16, FPU_ARCH_VFP_V3xD,
	FPU_ARCH_VFP_V3xD_FP16, FPU_ARCH_VFP_V4, FPU_ARCH_VFP_V4D16,
	FPU_ARCH_NEON_VFP_V4): Define.

	binutils/
	* readelf.c (arm_attr_tag_VFP_arch): Add VFPv4 and VFPv4-D16.

	bfd/
	* elf32-arm.c (elf32_arm_merge_eabi_attributes): Handle VFPv4
	attributes.

	opcodes/
	* arm-dis.c (coprocessor_opcodes): Update to use new feature flags.
	Add VFPv4 instructions.
@
text
@d5592 1
a5592 1
	      aux->table[i].start.offset += sym->st_value + rp->r_addend;
d5596 1
a5596 1
	      aux->table[i].end.offset   += sym->st_value + rp->r_addend;
@


1.467
log
@	* readelf.c (dynamic_info): Correct size of array.
@
text
@d8970 1
a8970 1
  {"No", "VFPv1", "VFPv2", "VFPv3", "VFPv3-D16"};
@


1.466
log
@        * readelf.c (usage): Add mention of --debug-dump=frames-interp.
        Wrap output to 80 columns.
        * objdump.c (usage): Likewise.
        * doc/binutils.texi (readelf): Add note about =frames-interp.
@
text
@d168 1
a168 1
static bfd_vma dynamic_info[DT_JMPREL + 1];
@


1.465
log
@bfd
        * Makefile.am (ALL_MACHINES): Add cpu-rx.lo.
        (ALL_MACHINES_CFILES): Add cpu-rx.c.
        (BFD32_BACKENDS): Add elf32-rx.lo.
        (BFD32_BACKENDS_CFILES): Add elf32-rx.c.
        * archures.c (bfd_architecture): Add bfd_arch_rx and bfd_mach_rx.
        Export bfd_rx_arch.
        (bfd_archures_list): Add bfd_rx_arch.
        * config.bfd: Add entry for rx-*-elf.
        * configure.in: Add entries for bfd_elf32_rx_le_vec and
        bfd_elf32_rx_be_vec.
        * reloc.c: Add RX relocations.
        * targets.c: Add RX target vectors.
        * Makefile.in: Regenerate.
        * bfd-in2.h: Regenerate.
        * configure: Regenerate.
        * libbfd.h: Regenerate.
        * cpu-rx.c: New file.
        * elf32-rx.c: New file.

binutils
        * readelf.c: Add support for RX target.
        * MAINTAINERS: Add DJ and NickC as maintainers for RX.

gas
        * Makefile.am: Add RX target.
        * configure.in: Likewise.
        * configure.tgt: Likewise.
        * read.c (do_repeat_with_expander): New function.
        * read.h: Provide a prototype for do_repeat_with_expander.
        * doc/Makefile.am: Add RX target documentation.
        * doc/all.texi: Likewise.
        * doc/as.texinfo: Likewise.
        * Makefile.in: Regenerate.
        * NEWS: Mention support for RX architecture.
        * configure: Regenerate.
        * doc/Makefile.in: Regenerate.
        * config/rx-defs.h: New file.
        * config/rx-parse.y: New file.
        * config/tc-rx.h: New file.
        * config/tc-rx.c: New file.
        * doc/c-rx.texi: New file.

gas/testsuite
        * gas/rx: New directory.
        * gas/rx/*: New set of test cases.
        * gas/elf/section2.e-rx: New expected output file.
        * gas/all/gas.exp: Add support for RX target.
        * gas/elf/elf.exp: Likewise.
        * gas/lns/lns.exp: Likewise.
        * gas/macros/macros.exp: Likewise.

include
        * dis-asm.h: Add prototype for print_insn_rx.

include/elf
        * rx.h: New file.

include/opcode
        * rx.h: New file.

ld
        * Makefile.am: Add rules to build RX emulation.
        * configure.tgt: Likewise.
        * NEWS: Mention support for RX architecture.
        * Makefile.in: Regenerate.
        * emulparams/elf32rx.sh: New file.
        * emultempl/rxelf.em: New file.

opcodes
        * Makefile.am: Add RX files.
        * configure.in: Add support for RX target.
        * disassemble.c: Likewise.
        * Makefile.in: Regenerate.
        * configure: Regenerate.
        * opc2c.c: New file.
        * rx-decode.c: New file.
        * rx-decode.opc: New file.
        * rx-dis.c: New file.
@
text
@d2932 2
a2933 1
  --debug-dump[=rawline,=decodedline,=info,=abbrev,=pubnames,=aranges,=macro,=frames,=str,=loc,=Ranges]\n\
@


1.464
log
@        PR 10478
        * elf.c (bfd_section_from_shdr): Allow SHN_BEFORE and SHN_AFTER
        section link values in x86 binaries.
        * elfcode.h (elf_object_p): Likewise.
        * readelf.c (get_elf_section_flags): Allow SHN_BEFORE and
        SHN_AFTER section link values in x86 binaries.
        (process_section_headers): Likewise.
@
text
@d133 1
d608 1
d1220 4
d1896 1
d2441 6
d8070 2
@


1.463
log
@        PR 10656
        * readelf.c: Remove duplicate declaration of variable do_wide.
        * dwarf.h: Add export of do_wide.

        * hist.h: Move declaration of histograms and num_histograms
        variables from here to...
        * hist.c: ...here.
@
text
@d3974 3
d4390 1
a4390 1
		 an error but it can have special values in SPARC binaries.  */
d4393 3
@


1.462
log
@include/

	* dwarf2.h (DW_TAG_rvalue_reference_type, DW_TAG_template_alias):
	New tags.
	(DW_FORM_ref_sig8): New name for DW_FORM_sig8.
	(DW_AT_main_subprogram, DW_AT_data_bit_offset, DW_AT_const_expr,
	DW_AT_enum_class, DW_AT_linkage_name, DW_AT_GNU_guarded_by,
	DW_AT_GNU_pt_guarded_by, DW_AT_GNU_guarded, DW_AT_GNU_pt_guarded,
	DW_AT_GNU_locks_excluded, DW_AT_GNU_exclusive_locks_required,
	DW_AT_GNU_shared_locks_required, DW_AT_GNU_odr_signature): New
	attributes.
	(DW_LANG_Python): New language.

binutils/

	* dwarf.c (get_TAG_name): Add missing DWARF-3 and new DWARF-4 tags.
	(get_FORM_name): Add new DWARF-4 forms.
	(read_and_display_attr_value): Add DW_FORM_ref_sig8, DW_LANG_Python.
	(get_AT_name): Add new DWARF-4 and GNU-specific attributes.
	(process_debug_info): Add do_types parameter; change all callers.
	Add support for .debug_types sections.
	(display_debug_types): New function.
	(debug_displays): Add .debug_types section.
	* readelf.c (process_section_headers): Add .debug_types section.
	(display_debug_section): Simplify call to streq.
@
text
@a151 1
int do_wide;
@


1.461
log
@	* readelf.c (print_dynamic_symbol): Format entries as for
	normal symbol table.
	(process_symbol_table): Use -7s format string for visibility.
@
text
@d4279 1
d8821 1
a8821 1
	if (streq (debug_displays[i].section.uncompressed_name, name))
@


1.460
log
@include/elf/
	* ppc.h (DT_PPC_TLSOPT): Define.
	* ppc64.h (DT_PPC64_TLSOPT): Define.
bfd/
	* elf32-ppc.c (TLS_GET_ADDR_GLINK_SIZE): Define.
	(ADD_3_12_2, BEQLR, CMPWI_11_0, LWZ_11_3, LWZ_12_3): Define.
	(MR_0_3, MR_3_0): Define.
	(struct ppc_elf_link_hash_table): Add no_tls_get_addr_opt.
	(ppc_elf_select_plt_layout): Save emit_stub_syms param earlier.
	(ppc_elf_tls_setup): Add no_tls_get_addr_opt param and save to hash
	table.  Check for presense of __tls_get_addr_opt
	(allocate_dynrelocs): Increase glink entry size for __tls_get_addr.
	(ppc_elf_size_dynamic_sections): Add DT_PPC_TLS_OPT tag.
	(write_glink_stub): Add param p.
	(ppc_elf_relocate_section): Adjust write_glink_stub call.
	(ppc_elf_finish_dynamic_symbol): Emit special glink call stub for
	__tls_get_addr.
	* elf32-ppc.h (ppc_elf_tls_setup): Update prototype.
	* elf64-ppc.c (struct ppc_link_hash_table): Add no_tls_get_addr_opt.
	(ppc64_elf_tls_setup): Add no_tls_get_addr_opt param and save to hash
	table.  Check for presense of __tls_get_addr_opt.
	(ppc64_elf_size_dynamic_sections): Add DT_PPC64_TLS_OPT tag.
	(LD_R11_0R3, LD_R12_0R3, MR_R0_R3, CMPDI_R11_0, ADD_R3_R12_R13,
	BEQLR, MR_R3_R0, MFLR_R11, STD_R11_0R1, BCTRL, LD_R11_0R1,
	LD_R2_0R1, MTLR_R11): Define.
	(build_tls_get_addr_stub): New function.
	(ppc_build_one_stub): Call it.
	(ppc_size_one_stub): Add extra size for __tls_get_addr stub.
	(ppc64_elf_relocate_section): Don't change nop to ld 2,40(1) for
	__tls_get_addr plt call.
	* elf64-ppc.h (ppc64_elf_tls_setup): Update prototype.
binutils/
	* readelf.c (get_ppc_dynamic_type): Add TLSOPT.
	(get_ppc64_dynamic_type): Likewise.
ld/
	* emultempl/ppc32elf.em (no_tls_get_addr_opt): New var.
	(ppc_before_allocation): Pass to ppc_elf_tls_setup.
	(OPTION_NO_TLS_GET_ADDR_OPT): Define.  Redefine other options in
	terms of previous option.
	(PARSE_AND_LIST_LONGOPTS, PARSE_AND_LIST_OPTIONS): Add
	--no-tls-get-addr-optimize.
	(PARSE_AND_LIST_ARGS_CASES): Handle it.
	* emultempl/ppc64elf.em (no_tls_get_addr_opt): New var.
	(ppc_before_allocation): Pass to ppc64_elf_tls_setup.
	(OPTION_NO_TLS_GET_ADDR_OPT): Define.
	(PARSE_AND_LIST_LONGOPTS, PARSE_AND_LIST_OPTIONS): Add
	--no-tls-get-addr-optimize.
	(PARSE_AND_LIST_ARGS_CASES): Handle it.
ld/testsuite/
	* ld-powerpc/tlslib.s: Delete dot-symbol entry syms.  Add
	__tls_get_addr_opt.
	* ld-powerpc/tlslib32.s: Add __tls_get_addr_opt.
	* ld-powerpc/oldtlslib.s: New file, old-abi version of tlslib.s.
	* ld-powerpc/powerpc.exp: Build old-abi library and use it in
	two new link tests.
	* ld-powerpc/tlsexe.d: Update for new __tls_get_addr stub.
	* ld-powerpc/tlsexe.g, * ld-powerpc/tlsexe.r, *ld-powerpc/tlsexe32.d,
	* ld-powerpc/tlsexe32.g, * ld-powerpc/tlsexe32.r,
	* ld-powerpc/tlsexetoc.d, * ld-powerpc/tlsexetoc.g,
	* ld-powerpc/tlsexetoc.r: Likewise.
@
text
@d7229 3
a7231 3
  printf ("  %6s", get_symbol_type (ELF_ST_TYPE (psym->st_info)));
  printf (" %6s",  get_symbol_binding (ELF_ST_BIND (psym->st_info)));
  printf (" %3s",  get_symbol_visibility (ELF_ST_VISIBILITY (psym->st_other)));
d7535 1
a7535 1
	      printf (" %-3s", get_symbol_visibility (ELF_ST_VISIBILITY (psym->st_other)));
@


1.459
log
@        * readelf.c (process_version_sections, process_symbol_table):
        Use symbolic constants.
@
text
@d1473 2
a1474 1
    case DT_PPC_GOT: return "PPC_GOT";
d1485 4
a1488 3
    case DT_PPC64_GLINK: return "PPC64_GLINK";
    case DT_PPC64_OPD:   return "PPC64_OPD";
    case DT_PPC64_OPDSZ: return "PPC64_OPDSZ";
@


1.458
log
@        Updated soruces in binutils/* to compile cleanly with -Wc++-compat.

        * binutils/addr2line.c (slurp_symtab): Fix casts. Introduce
        variable minisyms to avoid aliasing varning.
        * binutils/ar.c: Add casts. (normalize): Use name del instead of
        delete. (display_target_list,display_info_table): Change loop
        counter variable a to int.
        * binutils/bucomm.c: Add casts.
        * binutils/debug.c: Update function to use new names. (struct
        debug_baseclass): Rename member from virtual to
        is_virtual. (struct debug_type_s,struct debug_field_s,struct
        debug_baseclass_s,struct debug_method_s,struct
        debug_method_variant_s,struct debug_type_s): Rename struct from
        avoid name collision.
        * /binutils/debug.h: Use new struct names.
        * binutils/dwarf.c: Add casts. (free_debug_memory): Change loop
        counter variable a to int.
        * binutils/ieee.c: Add casts. (enum ieee_var_kind): Move to top
        level. (ieee_class_baseclass): Rename parameter virtual to
        is_virtual. (ieee_class_method_var): Rename variable virtual to
        is_virtual.
        * binutils/nm.c: Add casts.
        * binutils/objcopy.c: Add casts. (copy_archive): Rename variable
        delete to del.
        * binutils/objdump.c: Add casts. (dump_dwarf_section): Change loop
        counter variable i to int.
        * binutils/prdbg.c: Add
        casts. (pr_class_baseclass,tg_class_baseclass): Rename parameters
        virtual to is_virtual.
        * binutils/readelf.c: Add casts. (struct
        ia64_unw_table_entry,struct hppa_unw_table_entry): Move to top
        level.
        * binutils/size.c: Add casts.
        * binutils/stabs.c (parse_stab_type, parse_stab_range_type)
        (parse_stab_cpp_abbrev): Rename parameter from typename to
        type_name. (parse_stab_baseclasses): Rename variable virtual to
        is_virtual.
        * binutils/strings.c: Add casts.
        * binutils/wrstabs.c (stab_class_baseclass): Rename parameter
        virtual to is_virtual.
@
text
@d6855 2
a6856 2
		      nn = printf ("%4x%c", data[cnt + j] & 0x7fff,
				   data[cnt + j] & 0x8000 ? 'h' : ' ');
d6950 1
a6950 1
			  while (ivd.vd_ndx != (data[cnt + j] & 0x7fff)
d6953 1
a6953 1
			  if (ivd.vd_ndx == (data[cnt + j] & 0x7fff))
d7567 1
a7567 1
		  if ((vers_data & 0x8000) || vers_data > 1)
d7659 1
a7659 1
			      while (ivd.vd_ndx != (vers_data & 0x7fff)
d7671 1
a7671 1
				printf ((vers_data & 0x8000)
@


1.457
log
@        PR 10478:
        * elf.c (bfd_section_from_shdr): Do not reject sparc binaries with
        section headers containing sh_link values of SHN_BEFORE or
        SHN_AFTER.
        * elfcode.h (elf_object_p): Likewise.

        readelf.c (get_elf_section_flags): Add support for SHF_EXCLUDE and
        SHF_ORDERED.
        (process_section_headers): Warn about out of range sh_link
        values.  When displaying detailed section header information
        annote the SHN_BEFORE and SHN_AFTER values.
@
text
@d665 2
a666 1
      erelas = get_data (NULL, file, rel_offset, 1, rel_size, _("relocs"));
d672 2
a673 1
      relas = cmalloc (nrelas, sizeof (Elf_Internal_Rela));
d695 2
a696 1
      erelas = get_data (NULL, file, rel_offset, 1, rel_size, _("relocs"));
d702 2
a703 1
      relas = cmalloc (nrelas, sizeof (Elf_Internal_Rela));
d763 2
a764 1
      erels = get_data (NULL, file, rel_offset, 1, rel_size, _("relocs"));
d770 1
a770 1
      rels = cmalloc (nrels, sizeof (Elf_Internal_Rela));
d792 2
a793 1
      erels = get_data (NULL, file, rel_offset, 1, rel_size, _("relocs"));
d799 1
a799 1
      rels = cmalloc (nrels, sizeof (Elf_Internal_Rela));
d2950 2
a2951 1
      new_dump_sects = calloc (section + 1, sizeof (* dump_sects));
d2980 2
a2981 1
  new_request = malloc (sizeof (struct dump_list_entry));
d3300 4
a3303 3
  phdrs = get_data (NULL, file, elf_header.e_phoff,
		    elf_header.e_phentsize, elf_header.e_phnum,
		    _("program headers"));
d3334 4
a3337 3
  phdrs = get_data (NULL, file, elf_header.e_phoff,
		    elf_header.e_phentsize, elf_header.e_phnum,
		    _("program headers"));
d3371 2
a3372 1
  phdrs = cmalloc (elf_header.e_phnum, sizeof (Elf_Internal_Phdr));
d3665 3
a3667 2
  shdrs = get_data (NULL, file, elf_header.e_shoff,
		    elf_header.e_shentsize, num, _("section headers"));
d3671 2
a3672 1
  section_headers = cmalloc (num, sizeof (Elf_Internal_Shdr));
d3708 3
a3710 2
  shdrs = get_data (NULL, file, elf_header.e_shoff,
		    elf_header.e_shentsize, num, _("section headers"));
d3714 2
a3715 1
  section_headers = cmalloc (num, sizeof (Elf_Internal_Shdr));
d3754 2
a3755 2
  esyms = get_data (NULL, file, section->sh_offset, 1, section->sh_size,
		    _("symbols"));
d3764 4
a3767 2
      shndx = get_data (NULL, file, symtab_shndx_hdr->sh_offset,
			1, symtab_shndx_hdr->sh_size, _("symtab shndx"));
d3776 1
a3776 1
  isyms = cmalloc (number, sizeof (Elf_Internal_Sym));
d3821 2
a3822 2
  esyms = get_data (NULL, file, section->sh_offset, 1, section->sh_size,
		    _("symbols"));
d3831 4
a3834 2
      shndx = get_data (NULL, file, symtab_shndx_hdr->sh_offset,
			1, symtab_shndx_hdr->sh_size, _("symtab shndx"));
d3843 1
a3843 1
  isyms = cmalloc (number, sizeof (Elf_Internal_Sym));
d4135 3
a4137 2
	  string_table = get_data (NULL, file, section->sh_offset,
				   1, section->sh_size, _("string table"));
d4241 3
a4243 2
	  dynamic_strings = get_data (NULL, file, section->sh_offset,
				      1, section->sh_size, _("dynamic strings"));
d4568 2
a4569 2
  section_headers_groups = calloc (elf_header.e_shnum,
				   sizeof (struct group *));
d4593 1
a4593 1
  section_groups = calloc (group_count, sizeof (struct group));
d4672 3
a4674 3
		  strtab = get_data (NULL, file, strtab_sec->sh_offset,
				     1, strtab_sec->sh_size,
				     _("string table"));
d4681 3
a4683 2
	  start = get_data (NULL, file, section->sh_offset,
			    1, section->sh_size, _("section data"));
d4746 1
a4746 1
	      g = xmalloc (sizeof (struct group_list));
d4899 3
a4901 3
		      strtab = get_data (NULL, file, strsec->sh_offset,
					 1, strsec->sh_size,
					 _("string table"));
d4945 7
d4954 2
a4955 7
    struct ia64_unw_table_entry
      {
	struct absaddr start;
	struct absaddr end;
	struct absaddr info;
      }
    *table;			/* Unwind table.  */
d5104 2
a5105 1
  table = get_data (NULL, file, sec->sh_offset, 1, size, _("unwind table"));
d5109 2
a5110 1
  aux->table = xcmalloc (size / (3 * eh_addr_size), sizeof (aux->table[0]));
d5199 3
a5201 2
	  aux.strtab = get_data (NULL, file, strsec->sh_offset,
				 1, strsec->sh_size, _("string table"));
d5283 3
a5285 2
	  aux.info = get_data (NULL, file, sec->sh_offset, 1, aux.info_size,
			       _("unwind info"));
d5320 37
d5359 1
a5359 37
    struct hppa_unw_table_entry
      {
	struct absaddr start;
	struct absaddr end;
	unsigned int Cannot_unwind:1;			/* 0 */
	unsigned int Millicode:1;			/* 1 */
	unsigned int Millicode_save_sr0:1;		/* 2 */
	unsigned int Region_description:2;		/* 3..4 */
	unsigned int reserved1:1;			/* 5 */
	unsigned int Entry_SR:1;			/* 6 */
	unsigned int Entry_FR:4;     /* number saved */	/* 7..10 */
	unsigned int Entry_GR:5;     /* number saved */	/* 11..15 */
	unsigned int Args_stored:1;			/* 16 */
	unsigned int Variable_Frame:1;			/* 17 */
	unsigned int Separate_Package_Body:1;		/* 18 */
	unsigned int Frame_Extension_Millicode:1;	/* 19 */
	unsigned int Stack_Overflow_Check:1;		/* 20 */
	unsigned int Two_Instruction_SP_Increment:1;	/* 21 */
	unsigned int Ada_Region:1;			/* 22 */
	unsigned int cxx_info:1;			/* 23 */
	unsigned int cxx_try_catch:1;			/* 24 */
	unsigned int sched_entry_seq:1;			/* 25 */
	unsigned int reserved2:1;			/* 26 */
	unsigned int Save_SP:1;				/* 27 */
	unsigned int Save_RP:1;				/* 28 */
	unsigned int Save_MRP_in_frame:1;		/* 29 */
	unsigned int extn_ptr_defined:1;		/* 30 */
	unsigned int Cleanup_defined:1;			/* 31 */

	unsigned int MPE_XL_interrupt_marker:1;		/* 0 */
	unsigned int HP_UX_interrupt_marker:1;		/* 1 */
	unsigned int Large_frame:1;			/* 2 */
	unsigned int Pseudo_SP_Set:1;			/* 3 */
	unsigned int reserved4:1;			/* 4 */
	unsigned int Total_frame_size:27;		/* 5..31 */
      }
    *table;			/* Unwind table.  */
d5477 2
a5478 1
  table = get_data (NULL, file, sec->sh_offset, 1, size, _("unwind table"));
d5486 2
a5487 1
  tep = aux->table = xcmalloc (nentries, sizeof (aux->table[0]));
d5612 3
a5614 2
	  aux.strtab = get_data (NULL, file, strsec->sh_offset,
				 1, strsec->sh_size, _("string table"));
d5840 2
a5841 2
  edyn = get_data (NULL, file, dynamic_addr, 1, dynamic_size,
		   _("dynamic section"));
d5857 2
a5858 1
  dynamic_section = cmalloc (dynamic_nent, sizeof (* entry));
d5886 2
a5887 2
  edyn = get_data (NULL, file, dynamic_addr, 1, dynamic_size,
		   _("dynamic section"));
d5903 2
a5904 1
  dynamic_section = cmalloc (dynamic_nent, sizeof (* entry));
d6062 3
a6064 2
	  dynamic_strings = get_data (NULL, file, offset, 1, str_tab_len,
				      _("dynamic string table"));
d6099 3
a6101 2
	  extsyminfo = get_data (NULL, file, dynamic_syminfo_offset, 1,
				 syminsz, _("symbol information"));
d6105 1
a6105 1
	  dynamic_syminfo = malloc (syminsz);
d6592 3
a6594 3
	    edefs = get_data (NULL, file, section->sh_offset, 1,
			      section->sh_size,
			      _("version definition section"));
d6694 4
a6697 3
	    eneed = get_data (NULL, file, section->sh_offset, 1,
			      section->sh_size,
			      _("version need section"));
d6800 3
a6802 2
	    strtab = get_data (NULL, file, string_sec->sh_offset, 1,
			       string_sec->sh_size, _("version string table"));
d6818 3
a6820 2
	    edata = get_data (NULL, file, off, total, sizeof (short),
			      _("version symbol data"));
d6827 1
a6827 1
	    data = cmalloc (total, sizeof (short));
d7180 1
a7180 1
  e_data = cmalloc (number, ent_size);
d7194 1
a7194 1
  i_data = cmalloc (number, sizeof (*i_data));
d7517 3
a7519 2
	      strtab = get_data (NULL, file, string_sec->sh_offset,
				 1, string_sec->sh_size, _("string table"));
d7706 1
a7706 1
      lengths = calloc (nbuckets, sizeof (*lengths));
d7722 1
a7722 1
      counts = calloc (maxlength + 1, sizeof (*counts));
d7765 1
a7765 1
      lengths = calloc (ngnubuckets, sizeof (*lengths));
d7790 1
a7790 1
      counts = calloc (maxlength + 1, sizeof (*counts));
d8330 2
a8331 2
	  if (!slurp_rela_relocs (file, relsec->sh_offset, relsec->sh_size,
				  & relocs, & num_relocs))
d8336 2
a8337 2
	  if (!slurp_rel_relocs (file, relsec->sh_offset, relsec->sh_size,
				 & relocs, & num_relocs))
d8346 1
a8346 1
      symtab = GET_ELF_SYMBOLS (file, symsec);
d8473 2
a8474 2
  return get_data (NULL, file, section->sh_offset, 1, num_bytes,
		   _("section contents"));
d8681 1
a8681 1
  uncompressed_buffer = xmalloc (uncompressed_size);
d8728 3
a8730 2
  section->start = get_data (NULL, file, sec->sh_offset, 1,
			     sec->sh_size, buf);
d8739 1
a8739 1
    apply_relocations (file, sec, section->start);
d8763 1
a8763 1
  return load_specific_debug_section (debug, sec, file);
d8786 1
a8786 1
  enum dwarf_section_display_enum i;
d8816 1
a8816 1
	  free_debug_section (i);
d8822 2
a8823 1
	if (load_specific_debug_section (i, section, file))
d8828 1
a8828 1
	      free_debug_section (i);
d9418 2
a9419 2
      contents = get_data (NULL, file, sect->sh_offset, 1, sect->sh_size,
			   _("attributes"));
d9681 4
a9684 3
      elib = get_data (NULL, file, liblist_offset,
		       liblistno, sizeof (Elf32_External_Lib),
		       _("liblist"));
d9770 2
a9771 2
      eopt = get_data (NULL, file, options_offset, 1, sect->sh_size,
		       _("options"));
d9774 2
a9775 1
	  iopt = cmalloc ((sect->sh_size / sizeof (eopt)), sizeof (* iopt));
d9967 1
a9967 1
      iconf = cmalloc (conflictsno, sizeof (* iconf));
d9978 3
a9980 2
	  econf32 = get_data (NULL, file, conflicts_offset,
			      conflictsno, sizeof (* econf32), _("conflict"));
d9993 3
a9995 2
	  econf64 = get_data (NULL, file, conflicts_offset,
			      conflictsno, sizeof (* econf64), _("conflict"));
d10039 2
a10040 1
      data = get_data (NULL, file, offset, global_end - pltgot, 1, _("GOT"));
d10135 2
a10136 1
      data = get_data (NULL, file, offset, end - mips_pltgot, 1, _("PLT GOT"));
d10204 3
a10206 2
	  elib = get_data (NULL, file, section->sh_offset, 1, section->sh_size,
			   _("liblist"));
d10212 3
a10214 2
	  strtab = get_data (NULL, file, string_sec->sh_offset, 1,
			     string_sec->sh_size, _("liblist string table"));
d10458 2
a10459 1
  pnotes = get_data (NULL, file, offset, 1, length, _("notes"));
d10501 1
a10501 1
	  temp = malloc (inote.namesz + 1);
d10876 1
a10876 1
      member_file_name = malloc (name_len + 1);
d10890 1
a10890 1
      member_file_name = malloc (prefix_len + name_len + 1);
d11000 2
a11001 1
	  index_buffer = malloc (arch->index_num * SIZEOF_AR_INDEX_NUMBERS);
d11017 2
a11018 1
	  arch->index_array = malloc (arch->index_num * sizeof (* arch->index_array));
d11037 1
a11037 1
	  arch->sym_table = malloc (size);
d11079 1
a11079 1
      arch->longnames = malloc (arch->longnames_size);
d11251 1
a11251 1
  name = malloc (len);
d11586 2
a11587 1
      cmdline_dump_sects = malloc (num_dump_sects * sizeof (* dump_sects));
@


1.456
log
@	* dwarf.c (byte_get_little_endian): Handle size of 3.
	(byte_get_big_endian): Likewise.
	* readelf.c (byte_put_little_endian): Likewise.
	(byte_put_big_endian): Likewise.
	(is_24bit_abs_reloc): New function.
	(is_none_reloc): Formatting.
	(apply_relocations): Use is_24bit_abs_reloc.  Handle pj and xtensa
	reloc peculiarity.
@
text
@d3876 23
a3898 20
	{ "WRITE", 5 },
	{ "ALLOC", 5 },
	{ "EXEC", 4 },
	{ "MERGE", 5 },
	{ "STRINGS", 7 },
	{ "INFO LINK", 9 },
	{ "LINK ORDER", 10 },
	{ "OS NONCONF", 10 },
	{ "GROUP", 5 },
	{ "TLS", 3 },
	/* IA-64 specific.  */
	{ "SHORT", 5 },
	{ "NORECOV", 7 },
	/* IA-64 OpenVMS specific.  */
	{ "VMS_GLOBAL", 10 },
	{ "VMS_OVERLAID", 12 },
	{ "VMS_SHARED", 10 },
	{ "VMS_VECTOR", 10 },
	{ "VMS_ALLOC_64BIT", 15 },
	{ "VMS_PROTECTED", 13}
d3932 1
a3932 1
	      if (elf_header.e_machine == EM_IA_64)
d3934 1
d3952 13
a3965 1
	      break;
d4346 2
d4360 39
a4398 4
	  printf ("%2u %3u %2lu\n",
		  section->sh_link,
		  section->sh_info,
		  (unsigned long) section->sh_addralign);
@


1.455
log
@binutils/
	* readelf.c (is_none_reloc <EM_XTENSA_OLD>, is_none_reloc <EM_XTENSA>):
	New.
@
text
@d345 2
d510 5
a514 2
      field[2] = (value >> 8) & 0xff;
      value >>= 16;
d8108 16
d8189 4
a8192 4
      return reloc_type == 0      /* R_XTENSA_NONE.  */
	     || reloc_type == 17  /* R_XTENSA_DIFF8.  */
	     || reloc_type == 18  /* R_XTENSA_DIFF16.  */
	     || reloc_type == 19; /* R_XTENSA_DIFF32.  */
d8274 2
d8319 11
a8329 1
	  addend = is_rela ? rp->r_addend : byte_get (loc, reloc_size);
@


1.454
log
@        * readelf.c (is_32bit_abs_reloc): Treat R_PARISC_SECREL32 as a
        32-bit absolute reloc for the purposes of processing debug
        sections.
@
text
@d8166 6
@


1.454.2.1
log
@	* dwarf.c (byte_get_little_endian): Handle size of 3.
	(byte_get_big_endian): Likewise.
	* readelf.c (byte_put_little_endian): Likewise.
	(byte_put_big_endian): Likewise.
	(is_24bit_abs_reloc): New function.
	(is_none_reloc): Formatting.
	(apply_relocations): Use is_24bit_abs_reloc.  Handle pj and xtensa
	reloc peculiarity.

	2009-09-07  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	* readelf.c (is_none_reloc <EM_XTENSA_OLD>, is_none_reloc <EM_XTENSA>):
	New.

	2009-09-07  Jan Kratochvil  <jan.kratochvil@@redhat.com>
	* dwarf.c (process_debug_info): Support section padding abbrev codes.
@
text
@a344 2
      /* Fall through.  */
    case 3:
d508 2
a509 5
      value >>= 8;
      /* Fall through.  */
    case 3:
      field[2] = value & 0xff;
      value >>= 8;
a8102 16
   a 24-bit absolute RELA relocation used in DWARF debug sections.  */

static bfd_boolean
is_24bit_abs_reloc (unsigned int reloc_type)
{
  switch (elf_header.e_machine)
    {
    case EM_CYGNUS_MN10200:
    case EM_MN10200:
      return reloc_type == 4; /* R_MN10200_24.  */
    default:
      return FALSE;
    }
}

/* Like is_32bit_abs_reloc except that it returns TRUE iff RELOC_TYPE is
a8165 6
    case EM_XTENSA_OLD:
    case EM_XTENSA:
      return (reloc_type == 0      /* R_XTENSA_NONE.  */
	      || reloc_type == 17  /* R_XTENSA_DIFF8.  */
	      || reloc_type == 18  /* R_XTENSA_DIFF16.  */
	      || reloc_type == 19  /* R_XTENSA_DIFF32.  */);
a8246 2
	  else if (is_24bit_abs_reloc (reloc_type))
	    reloc_size = 3;
d8290 1
a8290 11
	  addend = 0;
	  if (is_rela)
	    addend += rp->r_addend;
	  /* R_XTENSA_32 and R_PJ_DATA_DIR32 are partial_inplace.  */
	  if (!is_rela
	      || (elf_header.e_machine == EM_XTENSA
		  && reloc_type == 1)
	      || ((elf_header.e_machine == EM_PJ
		   || elf_header.e_machine == EM_PJ_OLD)
		  && reloc_type == 1))
	    addend += byte_get (loc, reloc_size);
@


1.454.2.2
log
@        PR 10478:
        * elf.c (bfd_section_from_shdr): Do not reject sparc binaries with
        section headers containing sh_link values of SHN_BEFORE or
        SHN_AFTER.
        * elfcode.h (elf_object_p): Likewise.

        readelf.c (get_elf_section_flags): Add support for SHF_EXCLUDE and
        SHF_ORDERED.
        (process_section_headers): Warn about out of range sh_link
        values.  When displaying detailed section header information
        annote the SHN_BEFORE and SHN_AFTER values.
@
text
@d3876 20
a3895 23
      /*  0 */ { STRING_COMMA_LEN ("WRITE") },
      /*  1 */ { STRING_COMMA_LEN ("ALLOC") },
      /*  2 */ { STRING_COMMA_LEN ("EXEC") },
      /*  3 */ { STRING_COMMA_LEN ("MERGE") },
      /*  4 */ { STRING_COMMA_LEN ("STRINGS") },
      /*  5 */ { STRING_COMMA_LEN ("INFO LINK") },
      /*  6 */ { STRING_COMMA_LEN ("LINK ORDER") },
      /*  7 */ { STRING_COMMA_LEN ("OS NONCONF") },
      /*  8 */ { STRING_COMMA_LEN ("GROUP") },
      /*  9 */ { STRING_COMMA_LEN ("TLS") },
      /* IA-64 specific.  */
      /* 10 */ { STRING_COMMA_LEN ("SHORT") },
      /* 11 */ { STRING_COMMA_LEN ("NORECOV") },
      /* IA-64 OpenVMS specific.  */
      /* 12 */ { STRING_COMMA_LEN ("VMS_GLOBAL") },
      /* 13 */ { STRING_COMMA_LEN ("VMS_OVERLAID") },
      /* 14 */ { STRING_COMMA_LEN ("VMS_SHARED") },
      /* 15 */ { STRING_COMMA_LEN ("VMS_VECTOR") },
      /* 16 */ { STRING_COMMA_LEN ("VMS_ALLOC_64BIT") },
      /* 17 */ { STRING_COMMA_LEN ("VMS_PROTECTED") },
      /* SPARC specific.  */
      /* 18 */ { STRING_COMMA_LEN ("EXCLUDE") },
      /* 19 */ { STRING_COMMA_LEN ("ORDERED") }
d3929 1
a3929 1
	      switch (elf_header.e_machine)
a3930 1
		case EM_IA_64:
a3947 13
		  break;

		case EM_OLD_SPARCV9:
		case EM_SPARC32PLUS:
		case EM_SPARCV9:
		case EM_SPARC:
		  if (flag == SHF_EXCLUDE)
		    index = 18;
		  else if (flag == SHF_ORDERED)
		    index = 19;
		  break;
		default:
		  break;
d3949 1
a4329 2
	  const char * link_too_big = NULL;

d4342 4
a4345 39
	  if (section->sh_link >= elf_header.e_shnum)
	    {
	      link_too_big = "";
	      /* The sh_link value is out of range.  Normally this indicates
		 an error but it can have special values in SPARC binaries.  */
	      switch (elf_header.e_machine)
		{
		case EM_OLD_SPARCV9:
		case EM_SPARC32PLUS:
		case EM_SPARCV9:
		case EM_SPARC:
		  if (section->sh_link == (SHN_BEFORE & 0xffff))
		    link_too_big = "BEFORE";
		  else if (section->sh_link == (SHN_AFTER & 0xffff))
		    link_too_big = "AFTER";
		  break;
		default:
		  break;
		}
	    }

	  if (do_section_details)
	    {
	      if (link_too_big != NULL && * link_too_big)
		printf ("<%s> ", link_too_big);
	      else
		printf ("%2u ", section->sh_link);
	      printf ("%3u %2lu\n", section->sh_info,
		      (unsigned long) section->sh_addralign);
	    }
	  else
	    printf ("%2u %3u %2lu\n",
		    section->sh_link,
		    section->sh_info,
		    (unsigned long) section->sh_addralign);

	  if (link_too_big && ! * link_too_big)
	    warn (_("section %u: sh_link value of %u is larger than the number of sections\n"),
		  i, section->sh_link);
@


1.454.2.3
log
@        Update soruces to compile cleanly with -Wc++-compat:

        * addr2line.c (slurp_symtab): Fix casts. Introduce variable
        minisyms to avoid aliasing varning.
        * ar.c: Add casts.
        (normalize): Use name del instead of delete.
        (display_target_list,display_info_table): Change loop counter
        variable a to int.
        * bucomm.c: Add casts.
        * debug.c: Update function to use new names.
        (struct debug_baseclass): Rename member from virtual to
        is_virtual.
        (struct debug_type_s, struct debug_field_s, struct
        debug_baseclass_s, struct debug_method_s, struct
        debug_method_variant_s, struct debug_type_s): Rename struct from
        avoid name collision.
        * debug.h: Use new struct names.
        * dwarf.c: Add casts.
        (free_debug_memory): Change loop counter variable a to int.
        * ieee.c: Add casts.
        (enum ieee_var_kind): Move to top level.
        (ieee_class_baseclass): Rename parameter virtual to is_virtual.
        (ieee_class_method_var): Rename variable virtual to is_virtual.
        * nm.c: Add casts.
        * objcopy.c: Add casts.
        (copy_archive): Rename variable delete to del.
        * objdump.c: Add casts.
        (dump_dwarf_section): Change loop counter variable i to int.
        * prdbg.c: Add casts.
        (pr_class_baseclass,tg_class_baseclass): Rename parameters virtual
        to is_virtual.
        * readelf.c: Add casts.
        (struct ia64_unw_table_entry,struct hppa_unw_table_entry): Move to
        top level.
        * size.c: Add casts.
        * stabs.c (parse_stab_type, parse_stab_range_type,
        (parse_stab_cpp_abbrev): Rename parameter from typename to
        type_name.
        (parse_stab_baseclasses): Rename variable virtual to is_virtual.
        * strings.c: Add casts.
        * wrstabs.c (stab_class_baseclass): Rename parameter virtual to
        is_virtual.
@
text
@d665 1
a665 2
      erelas = (Elf32_External_Rela *) get_data (NULL, file, rel_offset, 1,
                                                 rel_size, _("relocs"));
d671 1
a671 2
      relas = (Elf_Internal_Rela *) cmalloc (nrelas,
                                             sizeof (Elf_Internal_Rela));
d693 1
a693 2
      erelas = (Elf64_External_Rela *) get_data (NULL, file, rel_offset, 1,
                                                 rel_size, _("relocs"));
d699 1
a699 2
      relas = (Elf_Internal_Rela *) cmalloc (nrelas,
                                             sizeof (Elf_Internal_Rela));
d759 1
a759 2
      erels = (Elf32_External_Rel *) get_data (NULL, file, rel_offset, 1,
                                               rel_size, _("relocs"));
d765 1
a765 1
      rels = (Elf_Internal_Rela *) cmalloc (nrels, sizeof (Elf_Internal_Rela));
d787 1
a787 2
      erels = (Elf64_External_Rel *) get_data (NULL, file, rel_offset, 1,
                                               rel_size, _("relocs"));
d793 1
a793 1
      rels = (Elf_Internal_Rela *) cmalloc (nrels, sizeof (Elf_Internal_Rela));
d2944 1
a2944 2
      new_dump_sects = (dump_type *) calloc (section + 1,
                                             sizeof (* dump_sects));
d2973 1
a2973 2
  new_request = (struct dump_list_entry *)
      malloc (sizeof (struct dump_list_entry));
d3292 3
a3294 4
  phdrs = (Elf32_External_Phdr *) get_data (NULL, file, elf_header.e_phoff,
                                            elf_header.e_phentsize,
                                            elf_header.e_phnum,
                                            _("program headers"));
d3325 3
a3327 4
  phdrs = (Elf64_External_Phdr *) get_data (NULL, file, elf_header.e_phoff,
                                            elf_header.e_phentsize,
                                            elf_header.e_phnum,
                                            _("program headers"));
d3361 1
a3361 2
  phdrs = (Elf_Internal_Phdr *) cmalloc (elf_header.e_phnum,
                                         sizeof (Elf_Internal_Phdr));
d3654 2
a3655 3
  shdrs = (Elf32_External_Shdr *) get_data (NULL, file, elf_header.e_shoff,
                                            elf_header.e_shentsize, num,
                                            _("section headers"));
d3659 1
a3659 2
  section_headers = (Elf_Internal_Shdr *) cmalloc (num,
                                                   sizeof (Elf_Internal_Shdr));
d3695 2
a3696 3
  shdrs = (Elf64_External_Shdr *) get_data (NULL, file, elf_header.e_shoff,
                                            elf_header.e_shentsize, num,
                                            _("section headers"));
d3700 1
a3700 2
  section_headers = (Elf_Internal_Shdr *) cmalloc (num,
                                                   sizeof (Elf_Internal_Shdr));
d3739 2
a3740 2
  esyms = (Elf32_External_Sym *) get_data (NULL, file, section->sh_offset, 1,
                                           section->sh_size, _("symbols"));
d3749 2
a3750 4
      shndx = (Elf_External_Sym_Shndx *) get_data (NULL, file,
                                                   symtab_shndx_hdr->sh_offset,
                                                   1, symtab_shndx_hdr->sh_size,
                                                   _("symtab shndx"));
d3759 1
a3759 1
  isyms = (Elf_Internal_Sym *) cmalloc (number, sizeof (Elf_Internal_Sym));
d3804 2
a3805 2
  esyms = (Elf64_External_Sym *) get_data (NULL, file, section->sh_offset, 1,
                                           section->sh_size, _("symbols"));
d3814 2
a3815 4
      shndx = (Elf_External_Sym_Shndx *) get_data (NULL, file,
                                                   symtab_shndx_hdr->sh_offset,
                                                   1, symtab_shndx_hdr->sh_size,
                                                   _("symtab shndx"));
d3824 1
a3824 1
  isyms = (Elf_Internal_Sym *) cmalloc (number, sizeof (Elf_Internal_Sym));
d4116 2
a4117 3
	  string_table = (char *) get_data (NULL, file, section->sh_offset,
                                            1, section->sh_size,
                                            _("string table"));
d4221 2
a4222 3
	  dynamic_strings = (char *) get_data (NULL, file, section->sh_offset,
                                               1, section->sh_size,
                                               _("dynamic strings"));
d4547 2
a4548 2
  section_headers_groups = (struct group **) calloc (elf_header.e_shnum,
                                                     sizeof (struct group *));
d4572 1
a4572 1
  section_groups = (struct group *) calloc (group_count, sizeof (struct group));
d4651 3
a4653 3
		  strtab = (char *) get_data (NULL, file, strtab_sec->sh_offset,
                                              1, strtab_sec->sh_size,
                                              _("string table"));
d4660 2
a4661 3
	  start = (unsigned char *) get_data (NULL, file, section->sh_offset,
                                              1, section->sh_size,
                                              _("section data"));
d4724 1
a4724 1
	      g = (struct group_list *) xmalloc (sizeof (struct group_list));
d4877 3
a4879 3
		      strtab = (char *) get_data (NULL, file, strsec->sh_offset,
                                                  1, strsec->sh_size,
                                                  _("string table"));
a4922 7
struct ia64_unw_table_entry
  {
    struct absaddr start;
    struct absaddr end;
    struct absaddr info;
  };

d4925 7
a4931 2

    struct ia64_unw_table_entry *table;	/* Unwind table.  */
d5080 1
a5080 2
  table = (unsigned char *) get_data (NULL, file, sec->sh_offset, 1, size,
                                      _("unwind table"));
d5084 1
a5084 2
  aux->table = (struct ia64_unw_table_entry *)
      xcmalloc (size / (3 * eh_addr_size), sizeof (aux->table[0]));
d5173 2
a5174 3
	  aux.strtab = (char *) get_data (NULL, file, strsec->sh_offset,
                                          1, strsec->sh_size,
                                          _("string table"));
d5256 2
a5257 3
	  aux.info = (unsigned char *) get_data (NULL, file, sec->sh_offset, 1,
                                                 aux.info_size,
                                                 _("unwind info"));
a5291 37
struct hppa_unw_table_entry
  {
    struct absaddr start;
    struct absaddr end;
    unsigned int Cannot_unwind:1;			/* 0 */
    unsigned int Millicode:1;			/* 1 */
    unsigned int Millicode_save_sr0:1;		/* 2 */
    unsigned int Region_description:2;		/* 3..4 */
    unsigned int reserved1:1;			/* 5 */
    unsigned int Entry_SR:1;			/* 6 */
    unsigned int Entry_FR:4;     /* number saved */	/* 7..10 */
    unsigned int Entry_GR:5;     /* number saved */	/* 11..15 */
    unsigned int Args_stored:1;			/* 16 */
    unsigned int Variable_Frame:1;			/* 17 */
    unsigned int Separate_Package_Body:1;		/* 18 */
    unsigned int Frame_Extension_Millicode:1;	/* 19 */
    unsigned int Stack_Overflow_Check:1;		/* 20 */
    unsigned int Two_Instruction_SP_Increment:1;	/* 21 */
    unsigned int Ada_Region:1;			/* 22 */
    unsigned int cxx_info:1;			/* 23 */
    unsigned int cxx_try_catch:1;			/* 24 */
    unsigned int sched_entry_seq:1;			/* 25 */
    unsigned int reserved2:1;			/* 26 */
    unsigned int Save_SP:1;				/* 27 */
    unsigned int Save_RP:1;				/* 28 */
    unsigned int Save_MRP_in_frame:1;		/* 29 */
    unsigned int extn_ptr_defined:1;		/* 30 */
    unsigned int Cleanup_defined:1;			/* 31 */

    unsigned int MPE_XL_interrupt_marker:1;		/* 0 */
    unsigned int HP_UX_interrupt_marker:1;		/* 1 */
    unsigned int Large_frame:1;			/* 2 */
    unsigned int Pseudo_SP_Set:1;			/* 3 */
    unsigned int reserved4:1;			/* 4 */
    unsigned int Total_frame_size:27;		/* 5..31 */
  };

d5294 37
a5330 1
    struct hppa_unw_table_entry *table;	/* Unwind table.  */
d5448 1
a5448 2
  table = (unsigned char *) get_data (NULL, file, sec->sh_offset, 1, size,
                                      _("unwind table"));
d5456 1
a5456 2
  tep = aux->table = (struct hppa_unw_table_entry *)
      xcmalloc (nentries, sizeof (aux->table[0]));
d5581 2
a5582 3
	  aux.strtab = (char *) get_data (NULL, file, strsec->sh_offset,
                                          1, strsec->sh_size,
                                          _("string table"));
d5808 2
a5809 2
  edyn = (Elf32_External_Dyn *) get_data (NULL, file, dynamic_addr, 1,
                                          dynamic_size, _("dynamic section"));
d5825 1
a5825 2
  dynamic_section = (Elf_Internal_Dyn *) cmalloc (dynamic_nent,
                                                  sizeof (* entry));
d5853 2
a5854 2
  edyn = (Elf64_External_Dyn *) get_data (NULL, file, dynamic_addr, 1,
                                          dynamic_size, _("dynamic section"));
d5870 1
a5870 2
  dynamic_section = (Elf_Internal_Dyn *) cmalloc (dynamic_nent,
                                                  sizeof (* entry));
d6028 2
a6029 3
	  dynamic_strings = (char *) get_data (NULL, file, offset, 1,
                                               str_tab_len,
                                               _("dynamic string table"));
d6064 2
a6065 3
	  extsyminfo = (Elf_External_Syminfo *)
              get_data (NULL, file, dynamic_syminfo_offset, 1, syminsz,
                        _("symbol information"));
d6069 1
a6069 1
	  dynamic_syminfo = (Elf_Internal_Syminfo *) malloc (syminsz);
d6556 3
a6558 3
	    edefs = (Elf_External_Verdef *)
                get_data (NULL, file, section->sh_offset, 1,section->sh_size,
                          _("version definition section"));
d6658 3
a6660 4
	    eneed = (Elf_External_Verneed *) get_data (NULL, file,
                                                       section->sh_offset, 1,
                                                       section->sh_size,
                                                       _("version need section"));
d6763 2
a6764 3
	    strtab = (char *) get_data (NULL, file, string_sec->sh_offset, 1,
                                        string_sec->sh_size,
                                        _("version string table"));
d6780 2
a6781 3
	    edata = (unsigned char *) get_data (NULL, file, off, total,
                                                sizeof (short),
                                                _("version symbol data"));
d6788 1
a6788 1
	    data = (short unsigned int *) cmalloc (total, sizeof (short));
d7141 1
a7141 1
  e_data = (unsigned char *) cmalloc (number, ent_size);
d7155 1
a7155 1
  i_data = (bfd_vma *) cmalloc (number, sizeof (*i_data));
d7478 2
a7479 3
	      strtab = (char *) get_data (NULL, file, string_sec->sh_offset,
                                          1, string_sec->sh_size,
                                          _("string table"));
d7666 1
a7666 1
      lengths = (unsigned long *) calloc (nbuckets, sizeof (*lengths));
d7682 1
a7682 1
      counts = (unsigned long *) calloc (maxlength + 1, sizeof (*counts));
d7725 1
a7725 1
      lengths = (unsigned long *) calloc (ngnubuckets, sizeof (*lengths));
d7750 1
a7750 1
      counts = (unsigned long *) calloc (maxlength + 1, sizeof (*counts));
d8290 2
a8291 2
	  if (!slurp_rela_relocs ((FILE *) file, relsec->sh_offset,
                                  relsec->sh_size, & relocs, & num_relocs))
d8296 2
a8297 2
	  if (!slurp_rel_relocs ((FILE *) file, relsec->sh_offset,
                                 relsec->sh_size, & relocs, & num_relocs))
d8306 1
a8306 1
      symtab = GET_ELF_SYMBOLS ((FILE *) file, symsec);
d8433 2
a8434 2
  return  (char *) get_data (NULL, file, section->sh_offset, 1, num_bytes,
                             _("section contents"));
d8641 1
a8641 1
  uncompressed_buffer = (unsigned char *) xmalloc (uncompressed_size);
d8688 2
a8689 3
  section->start = (unsigned char *) get_data (NULL, (FILE *) file,
                                               sec->sh_offset, 1,
                                               sec->sh_size, buf);
d8698 1
a8698 1
    apply_relocations ((FILE *) file, sec, section->start);
d8722 1
a8722 1
  return load_specific_debug_section (debug, sec, (FILE *) file);
d8745 1
a8745 1
  int i;
d8775 1
a8775 1
	  free_debug_section ((enum dwarf_section_display_enum) i);
d8781 1
a8781 2
	if (load_specific_debug_section ((enum dwarf_section_display_enum) i,
                                         section, file))
d8786 1
a8786 1
	      free_debug_section ((enum dwarf_section_display_enum) i);
d9376 2
a9377 2
      contents = (unsigned char *) get_data (NULL, file, sect->sh_offset, 1,
                                             sect->sh_size, _("attributes"));
d9639 3
a9641 4
      elib = (Elf32_External_Lib *) get_data (NULL, file, liblist_offset,
                                              liblistno,
                                              sizeof (Elf32_External_Lib),
                                              _("liblist"));
d9727 2
a9728 2
      eopt = (Elf_External_Options *) get_data (NULL, file, options_offset, 1,
                                                sect->sh_size, _("options"));
d9731 1
a9731 2
	  iopt = (Elf_Internal_Options *)
              cmalloc ((sect->sh_size / sizeof (eopt)), sizeof (* iopt));
d9923 1
a9923 1
      iconf = (Elf32_Conflict *) cmalloc (conflictsno, sizeof (* iconf));
d9934 2
a9935 3
	  econf32 = (Elf32_External_Conflict *)
              get_data (NULL, file, conflicts_offset, conflictsno,
                        sizeof (* econf32), _("conflict"));
d9948 2
a9949 3
	  econf64 = (Elf64_External_Conflict *)
              get_data (NULL, file, conflicts_offset, conflictsno,
                        sizeof (* econf64), _("conflict"));
d9993 1
a9993 2
      data = (unsigned char *) get_data (NULL, file, offset,
                                         global_end - pltgot, 1, _("GOT"));
d10088 1
a10088 2
      data = (unsigned char *) get_data (NULL, file, offset, end - mips_pltgot,
                                         1, _("PLT GOT"));
d10156 2
a10157 3
	  elib = (Elf32_External_Lib *)
              get_data (NULL, file, section->sh_offset, 1, section->sh_size,
                        _("liblist"));
d10163 2
a10164 3
	  strtab = (char *) get_data (NULL, file, string_sec->sh_offset, 1,
                                      string_sec->sh_size,
                                      _("liblist string table"));
d10408 1
a10408 2
  pnotes = (Elf_External_Note *) get_data (NULL, file, offset, 1, length,
                                           _("notes"));
d10450 1
a10450 1
	  temp = (char *) malloc (inote.namesz + 1);
d10825 1
a10825 1
      member_file_name = (char *) malloc (name_len + 1);
d10839 1
a10839 1
      member_file_name = (char *) malloc (prefix_len + name_len + 1);
d10949 1
a10949 2
	  index_buffer = (unsigned char *)
              malloc (arch->index_num * SIZEOF_AR_INDEX_NUMBERS);
d10965 1
a10965 2
	  arch->index_array = (long unsigned int *)
              malloc (arch->index_num * sizeof (* arch->index_array));
d10984 1
a10984 1
	  arch->sym_table = (char *) malloc (size);
d11026 1
a11026 1
      arch->longnames = (char *) malloc (arch->longnames_size);
d11198 1
a11198 1
  name = (char *) malloc (len);
d11533 1
a11533 2
      cmdline_dump_sects = (dump_type *)
          malloc (num_dump_sects * sizeof (* dump_sects));
@


1.454.2.4
log
@include/elf/
	* ppc.h (DT_PPC_TLSOPT): Define.
	* ppc64.h (DT_PPC64_TLSOPT): Define.
bfd/
	* elf32-ppc.c (TLS_GET_ADDR_GLINK_SIZE): Define.
	(ADD_3_12_2, BEQLR, CMPWI_11_0, LWZ_11_3, LWZ_12_3): Define.
	(MR_0_3, MR_3_0): Define.
	(struct ppc_elf_link_hash_table): Add no_tls_get_addr_opt.
	(ppc_elf_select_plt_layout): Save emit_stub_syms param earlier.
	(ppc_elf_tls_setup): Add no_tls_get_addr_opt param and save to hash
	table.  Check for presense of __tls_get_addr_opt
	(allocate_dynrelocs): Increase glink entry size for __tls_get_addr.
	(ppc_elf_size_dynamic_sections): Add DT_PPC_TLS_OPT tag.
	(write_glink_stub): Add param p.
	(ppc_elf_relocate_section): Adjust write_glink_stub call.
	(ppc_elf_finish_dynamic_symbol): Emit special glink call stub for
	__tls_get_addr.
	* elf32-ppc.h (ppc_elf_tls_setup): Update prototype.
	* elf64-ppc.c (struct ppc_link_hash_table): Add no_tls_get_addr_opt.
	(ppc64_elf_tls_setup): Add no_tls_get_addr_opt param and save to hash
	table.  Check for presense of __tls_get_addr_opt.
	(ppc64_elf_size_dynamic_sections): Add DT_PPC64_TLS_OPT tag.
	(LD_R11_0R3, LD_R12_0R3, MR_R0_R3, CMPDI_R11_0, ADD_R3_R12_R13,
	BEQLR, MR_R3_R0, MFLR_R11, STD_R11_0R1, BCTRL, LD_R11_0R1,
	LD_R2_0R1, MTLR_R11): Define.
	(build_tls_get_addr_stub): New function.
	(ppc_build_one_stub): Call it.
	(ppc_size_one_stub): Add extra size for __tls_get_addr stub.
	(ppc64_elf_relocate_section): Don't change nop to ld 2,40(1) for
	__tls_get_addr plt call.
	* elf64-ppc.h (ppc64_elf_tls_setup): Update prototype.
binutils/
	* readelf.c (get_ppc_dynamic_type): Add TLSOPT.
	(get_ppc64_dynamic_type): Likewise.
ld/
	* emultempl/ppc32elf.em (no_tls_get_addr_opt): New var.
	(ppc_before_allocation): Pass to ppc_elf_tls_setup.
	(OPTION_NO_TLS_GET_ADDR_OPT): Define.  Redefine other options in
	terms of previous option.
	(PARSE_AND_LIST_LONGOPTS, PARSE_AND_LIST_OPTIONS): Add
	--no-tls-get-addr-optimize.
	(PARSE_AND_LIST_ARGS_CASES): Handle it.
	* emultempl/ppc64elf.em (no_tls_get_addr_opt): New var.
	(ppc_before_allocation): Pass to ppc64_elf_tls_setup.
	(OPTION_NO_TLS_GET_ADDR_OPT): Define.
	(PARSE_AND_LIST_LONGOPTS, PARSE_AND_LIST_OPTIONS): Add
	--no-tls-get-addr-optimize.
	(PARSE_AND_LIST_ARGS_CASES): Handle it.
ld/testsuite/
	* ld-powerpc/tlslib.s: Delete dot-symbol entry syms.  Add
	__tls_get_addr_opt.
	* ld-powerpc/tlslib32.s: Add __tls_get_addr_opt.
	* ld-powerpc/oldtlslib.s: New file, old-abi version of tlslib.s.
	* ld-powerpc/powerpc.exp: Build old-abi library and use it in
	two new link tests.
	* ld-powerpc/tlsexe.d: Update for new __tls_get_addr stub.
	* ld-powerpc/tlsexe.g, * ld-powerpc/tlsexe.r, *ld-powerpc/tlsexe32.d,
	* ld-powerpc/tlsexe32.g, * ld-powerpc/tlsexe32.r,
	* ld-powerpc/tlsexetoc.d, * ld-powerpc/tlsexetoc.g,
	* ld-powerpc/tlsexetoc.r: Likewise.
@
text
@d1473 1
a1473 2
    case DT_PPC_GOT:    return "PPC_GOT";
    case DT_PPC_TLSOPT: return "PPC_TLSOPT";
d1484 3
a1486 4
    case DT_PPC64_GLINK:  return "PPC64_GLINK";
    case DT_PPC64_OPD:    return "PPC64_OPD";
    case DT_PPC64_OPDSZ:  return "PPC64_OPDSZ";
    case DT_PPC64_TLSOPT: return "PPC64_TLSOPT";
@


1.454.2.5
log
@	* readelf.c (dynamic_info): Correct size of array.
@
text
@d168 1
a168 1
static bfd_vma dynamic_info[DT_ENCODING];
@


1.453
log
@    * readelf.c (get_arm_section_type_name): Added support for
    new sections headers.

    * arm.h: (SHT_ARM_DEBUGOVERLAY): New define.
    (SHT_ARM_OVERLAYSECTION): New define.
@
text
@d7942 2
a7943 1
      return reloc_type == 1; /* R_PARISC_DIR32.  */
@


1.452
log
@        Add support for Xilinx MicroBlaze processor.

        * bfd/Makefile.am: Add cpu-microblaze.{lo,c}, elf32-microblaze.{lo,c}.
        * bfd/Makefile.in: Same.
        * bfd/archures.c: Add bfd_arch_microblaze.
        * bfd/bfd-in2.h: Regenerate.
        * bfd/config.bfd: Add microblaze target.
        * bfd/configure: Add bfd_elf32_microblaze_vec target.
        * bfd/configure.in: Same.
        * bfd/cpu-microblaze.c: New.
        * bfd/elf32-microblaze.c: New.
        * bfd/libbfd-in.h: Add prototype _bfd_dwarf2_fixup_section_debug_loc().
        * bfd/libbfd.h: Regenerate.
        * bfd/reloc.c: Add MICROBLAZE relocations.
        * bfd/section.c: Add struct relax_table and relax_count to section.
        * bfd/targets.c: Add bfd_elf32_microblaze_vec.
        * binutils/MAINTAINERS: Add self as maintainer.
        * binutils/readelf.c: Include elf/microblaze.h, add EM_MICROBLAZE &
        EM_MICROBLAZE_OLD to guess_is_rela(), dump_relocations(),
        get_machine_name().
        * config.sub: Add microblaze target.
        * configure: Same.
        * configure.ac: Same.
        * gas/Makefile.am: add microblaze to CPU_TYPES, config/tc-microblaze.c to
        TARGET_CPU_CFILES, config/tc-microblaze.h to TARGET_CPU_HFILES, add
        DEP_microblaze_elf target.
        * gas/Makefile.in: Same.
        * gas/config/tc-microblaze.c: Add MicroBlaze assembler.
        * gas/config/tc-microblaze.h: Add header for tc-microblaze.c.
        * gas/configure: Add microblaze target.
        * gas/configure.in: Same.
        * gas/configure.tgt: Same.
        * gas/doc/Makefile.am: Add c-microblaze.texi to CPU_DOCS.
        * gas/doc/Makefile.in: Same.
        * gas/doc/all.texi: Set MICROBLAZE.
        * gas/doc/as.texinfo: Add MicroBlaze doc links.
        * gas/doc/c-microblaze.texi: New MicroBlaze docs.
        * include/dis-asm.h: Decl print_insn_microblaze().
        * include/elf/common.h: Define EM_MICROBLAZE & EM_MICROBLAZE_OLD.
        * include/elf/microblaze.h: New reloc definitions.
        * ld/Makefile.am: Add eelf32mb_linux.o, eelf32microblaze.o to
        ALL_EMULATIONS, targets.
        * ld/Makefile.in: Same.
        * ld/configure.tgt: Add microblaze*-linux*, microblaze* targets.
        * ld/emulparams/elf32mb_linux.sh: New.
        * ld/emulparams/elf32microblaze.sh. New.
        * ld/scripttempl/elfmicroblaze.sc: New.
        * opcodes/Makefile.am: Add microblaze-opc.h to HFILES, microblaze-dis.c to
        CFILES, microblaze-dis.lo to ALL_MACHINES, targets.
        * opcodes/Makefile.in: Same.
        * opcodes/configure: Add bfd_microblaze_arch target.
        * opcodes/configure.in: Same.
        * opcodes/disassemble.c: Define ARCH_microblaze, return
        print_insn_microblaze().
        * opcodes/microblaze-dis.c: New MicroBlaze disassembler.
        * opcodes/microblaze-opc.h: New MicroBlaze opcode definitions.
        * opcodes/microblaze-opcm.h: New MicroBlaze opcode types.
@
text
@d2729 5
a2733 6
    case SHT_ARM_EXIDX:
      return "ARM_EXIDX";
    case SHT_ARM_PREEMPTMAP:
      return "ARM_PREEMPTMAP";
    case SHT_ARM_ATTRIBUTES:
      return "ARM_ATTRIBUTES";
@


1.451
log
@bfd/

2009-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* archures.c (bfd_architecture): Add bfd_arch_l1om.
	(bfd_l1om_arch): New.
	(bfd_archures_list): Add &bfd_l1om_arch.
	* bfd-in2.h: Regenerated.

	* config.bfd (targ64_selvecs): Add bfd_elf64_l1om_vec if
	bfd_elf64_x86_64_vec is supported.  Add bfd_elf64_l1om_freebsd_vec
	if bfd_elf64_x86_64_freebsd_vec is supported.
	(targ_selvecs): Likewise.

	* configure.in: Support bfd_elf64_l1om_vec and
	bfd_elf64_l1om_freebsd_vec.
	* configure: Regenerated.

	* cpu-l1om.c: New.

	* elf64-x86-64.c (elf64_l1om_elf_object_p): New.
	(bfd_elf64_l1om_vec): Likewise.
	(bfd_elf64_l1om_freebsd_vec): Likewise.

	* Makefile.am (ALL_MACHINES): Add cpu-l1om.lo.
	(ALL_MACHINES_CFILES): Add cpu-l1om.c.
	* Makefile.in: Regenerated.

	* targets.c (bfd_elf64_l1om_vec): New.
	(bfd_elf64_l1om_freebsd_vec): Likewise.
	(_bfd_target_vector): Add bfd_elf64_l1om_vec and
	bfd_elf64_l1om_freebsd_vec.

binutils/

2009-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (guess_is_rela): Handle EM_L1OM.
	(dump_relocations): Likewise.
	(get_machine_name): Likewise.
	(get_section_type_name): Likewise.
	(get_elf_section_flags): Likewise.
	(get_symbol_index_type): Likewise.
	(is_32bit_abs_reloc): Likewise.
	(is_32bit_pcrel_reloc): Likewise.
	(is_64bit_abs_reloc): Likewise.
	(is_64bit_pcrel_reloc): Likewise.
	(is_none_reloc): Likewise.

gas/

2009-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (cpu_arch): Add l1om.
	(check_cpu_arch_compatible): New.
	(set_cpu_arch): Use it.
	(i386_arch): New.
	(i386_mach): Return bfd_mach_l1om for Intel L1OM.
	(md_show_usage): Display l1om.
	(i386_target_format): Return ELF_TARGET_L1OM_FORMAT if
	cpu_arch_isa_flags.bitfield.cpul1om is set.

	* config/tc-i386.h (TARGET_ARCH): Use (i386_arch ()).
	(i386_arch): New.
	(ELF_TARGET_L1OM_FORMAT): Likewise.

	* doc/c-i386.texi: Document l1om.

gas/testsuite/

2009-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/l1om.d: New.
	* gas/i386/l1om-inval.l: Likewise.
	* gas/i386/l1om-inval.s: Likewise.

	* gas/i386/i386.exp: Run l1om-inval and l1om.

include/elf/

2009-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* common.h (EM_L1OM): New.

ld/

2009-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* configure.tgt (targ64_extra_emuls): Add elf_l1om if elf_x86_64
	is supported.  Add elf_l1om_fbsd if elf_x86_64_fbsd is supported.
	(targ_extra_emuls): Likewise.

	* Makefile.am (ALL_64_EMULATIONS): Add eelf_l1om.o and
	eelf_l1om_fbsd.o
	(eelf_l1om.c): New.
	(eelf_l1om_fbsd.c): Likewise.
	* Makefile.in: Regenerated.

	* emulparams/elf_l1om.sh: New.
	* emulparams/elf_l1om_fbsd.sh: Likewise.

ld/testsuite/

2009-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-x86-64/abs-l1om.d: New.
	* ld-x86-64/protected2-l1om.d: Likewise.
	* ld-x86-64/protected3-l1om.d: Likewise.

	* ld-x86-64/x86-64.exp: Run abs-l1om, protected2-l1om and
	protected3-l1om.

opcodes/

2009-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* configure.in: Handle bfd_l1om_arch.
	* disassemble.c (disassembler): Likewise.

	* configure: Regenerated.

	* i386-dis.c (print_insn): Handle bfd_mach_l1om and
	bfd_mach_l1om_intel_syntax.  Use 8 bytes per line for Intel L1OM.

	* i386-gen.c (cpu_flag_init): Set CPU_UNKNOWN_FLAGS to ~CpuL1OM.
	Add CPU_L1OM_FLAGS.
	(cpu_flags): Add CpuL1OM.
	(set_bitfield): Take an argument to set the value field.
	(process_i386_cpu_flag): Support ~CpuXXX and ~(CpuXXX|CpuYYY).
	(process_i386_opcode_modifier): Updated.
	(process_i386_operand_type): Likewise.
	* i386-init.h: Regenerated.
	* i386-tbl.h: Likewise.

	* i386-opc.h (CpuL1OM): New.
	(CpuXsave): Updated.
	(i386_cpu_flags): Add cpul1om.
@
text
@d122 1
d618 2
d1203 5
d1876 2
@


1.450
log
@        * config/obj-elf.c (obj_elf_type): Add code to support a type of
        gnu_unique_object.
        * doc/as.texinfo: Document new feature of .type directive.
        * NEWS: Mention support for gnu_unique_object symbol type.

        * common.h (STB_GNU_UNIQUE): Define.

        * NEWS: Mention the linker's support for symbols with a binding of
        STB_GNU_UNIQUE.

        * gas/elf/type.s: Add unique global symbol definition.
        * gas/elf/type.e: Add expected readelf output for global unique
        symbol.

        * elfcpp.h (enum STB): Add STB_GNU_UNIQUE.

        * readelf.c (get_symbol_binding): For Linux targeted files return
        UNIQUE for symbols with the STB_GNU_UNIQUE binding.
        * doc/binutils.texi: Document the meaning of the 'u' symbol
        binding in the output of nm and objdump --syms.

        * elf-bfd.h (struct elf_link_hash_entry): Add unique_global field.
        * elf.c (swap_out_syms): Set binding to STB_GNU_UNIQUE for symbols
        with the BSF_GNU_UNIQUE flag bit set.
        * elfcode.h (elf_slurp_symbol_table): Set the BSF_GNU_UNIQUE flag
        for symbols with STB_GNU_UNIQUE binding.
        * elflink.c (_bfd_elf_merge_symbol): Set unique_global for symbols
        with the STB_GNU_UNIQUE binding.
        (elf_link_add_object_symbols): Set the BSF_GNU_UNIQUE flag for
        symbols with STB_GNU_UNIQUE binding.  Set STB_GNU_UNIQUE for
        symbols with the unique_global field set.
        (elf_link_output_extsym): Set unique_global field for symbols with
        the STB_GNU_UNIQUE binding.
        * syms.c (struct bfd_symbol): Define BSF_GNU_UNIQUE flag bit.
        (bfd_print_symbol_vandf): Print a 'u' character for BSF_GNU_UNIQUE
        symbols.
        (bfd_decode_symclass): Return a 'u' character for BSF_GNU_UNIQUE
        symbols.
        * bfd-in2.h: Regenerate.
@
text
@d613 1
d1132 1
d1297 2
a1298 1
		      else if (elf_header.e_machine == EM_X86_64
d1843 1
d2783 1
d3975 2
a3976 1
	      if (elf_header.e_machine == EM_X86_64
d7044 2
a7045 1
      else if (elf_header.e_machine == EM_X86_64
d7963 1
d8013 1
d8049 1
d8082 1
d8152 1
@


1.449
log
@        * dwarf.c (display_debug_lines_raw): Include the name of the
        section in warning message.
        (struct debug_display): Enable reloc processing for .debug_line
        and .debug_ranges sections.

        * readelf.c: Add --relocated-dump command line option to dump the
        relocated contents of a specified section.
        (request_dump): New function.
        (parse_args): Use it.
        (dump_section_as_bytes): Add parameter to indicate whether the
        contents should be relocated.
        (target_specific_reloc_handling): Add code for a R_MN10300_16
        reloc found after a R_MN10300_SYM_DIFF reloc.
        (debug_apply_relocations): Rename to apply_relocations.
        (get_section_contents): New function.  Replaces common code found
        in dump_section_as_strings and dump_section_as_bytes.
        * doc/binutils.texi: Document new command line option.
        * NEWS: Mention the new feature.
@
text
@d6905 8
a6912 1
	snprintf (buff, sizeof (buff), _("<OS specific>: %d"), binding);
@


1.448
log
@        * readelf.c (target_specific_reloc_handling): New function:
        Processes relocs in a target specific manner.
        (debug_apply_relocations): Use the new function.
        * dwarf.c (display_debug_loc): End the dump with a blank line.
        (struct debug_display): Enable reloc processing for .debug_aranges
        and .debug_loc sections.
@
text
@d217 1
d2848 1
a2848 1
  {"debug-dump",       optional_argument, 0, OPTION_DEBUG_DUMP},
d2853 1
d2890 2
d2968 16
d2993 1
a2993 1
	  (argc, argv, "ADHINSVWacdeghi:lnp:rstuvw::x:", options, NULL)) != EOF)
a2994 3
      char * cp;
      int section;

d3068 1
a3068 6
	  do_dump++;
	  section = strtoul (optarg, & cp, 0);
	  if (! *cp && section >= 0)
	    request_dump_bynumber (section, HEX_DUMP);
	  else
	    request_dump_byname (optarg, HEX_DUMP);
d3071 4
a3074 6
	  do_dump++;
	  section = strtoul (optarg, & cp, 0);
	  if (! *cp && section >= 0)
	    request_dump_bynumber (section, STRING_DUMP);
	  else
	    request_dump_byname (optarg, STRING_DUMP);
d3101 2
a3102 6
	  do_dump++;
	  section = strtoul (optarg, & cp, 0);
	  if (! *cp && section >= 0)
	    request_dump_bynumber (section, DISASS_DUMP);
	  else
	    request_dump_byname (optarg, DISASS_DUMP);
d7768 3
a7770 6
#ifdef SUPPORT_DISASSEMBLY
static int
disassemble_section (Elf_Internal_Shdr * section, FILE * file)
{
  printf (_("\nAssembly dump of section %s\n"),
	  SECTION_NAME (section));
d7772 4
a7775 8
  /* XXX -- to be done --- XXX */

  return 1;
}
#endif

static int
dump_section_as_strings (Elf_Internal_Shdr * section, FILE * file)
d7777 1
a7777 8
  Elf_Internal_Shdr * relsec;
  bfd_size_type num_bytes;
  bfd_vma addr;
  char * data;
  char * end;
  char * start;
  char * name = SECTION_NAME (section);
  bfd_boolean some_strings_shown;
d7779 1
a7779 3
  num_bytes = section->sh_size;

  if (num_bytes == 0 || section->sh_type == SHT_NOBITS)
d7781 4
a7784 3
      printf (_("\nSection '%s' has no data to dump.\n"), name);
      return 0;
    }
d7786 12
a7797 1
  addr = section->sh_addr;
d7799 3
a7801 4
  start = get_data (NULL, file, section->sh_offset, 1, num_bytes,
		    _("section data"));
  if (!start)
    return 0;
d7803 1
a7803 1
  printf (_("\nString dump of section '%s':\n"), name);
d7805 11
a7815 18
  /* If the section being dumped has relocations against it the user might
     be expecting these relocations to have been applied.  Check for this
     case and issue a warning message in order to avoid confusion.
     FIXME: Maybe we ought to have an option that dumps a section with
     relocs applied ?  */
  for (relsec = section_headers;
       relsec < section_headers + elf_header.e_shnum;
       ++relsec)
    {
      if ((relsec->sh_type != SHT_RELA && relsec->sh_type != SHT_REL)
	  || relsec->sh_info >= elf_header.e_shnum
	  || section_headers + relsec->sh_info != section
	  || relsec->sh_size == 0
	  || relsec->sh_link >= elf_header.e_shnum)
	continue;

      printf (_("  Note: This section has relocations against it, but these have NOT been applied to this dump.\n"));
      break;
d7818 1
a7818 122
  data = start;
  end  = start + num_bytes;
  some_strings_shown = FALSE;

  while (data < end)
    {
      while (!ISPRINT (* data))
	if (++ data >= end)
	  break;

      if (data < end)
	{
#ifndef __MSVCRT__
	  printf ("  [%6tx]  %s\n", data - start, data);
#else
	  printf ("  [%6Ix]  %s\n", (size_t) (data - start), data);
#endif
	  data += strlen (data);
	  some_strings_shown = TRUE;
	}
    }

  if (! some_strings_shown)
    printf (_("  No strings found in this section."));

  free (start);

  putchar ('\n');
  return 1;
}


static int
dump_section_as_bytes (Elf_Internal_Shdr * section, FILE * file)
{
  Elf_Internal_Shdr * relsec;
  bfd_size_type bytes;
  bfd_vma addr;
  unsigned char * data;
  unsigned char * start;

  bytes = section->sh_size;

  if (bytes == 0 || section->sh_type == SHT_NOBITS)
    {
      printf (_("\nSection '%s' has no data to dump.\n"),
	      SECTION_NAME (section));
      return 0;
    }
  else
    printf (_("\nHex dump of section '%s':\n"), SECTION_NAME (section));

  addr = section->sh_addr;

  start = get_data (NULL, file, section->sh_offset, 1, bytes,
		    _("section data"));
  if (!start)
    return 0;

  /* If the section being dumped has relocations against it the user might
     be expecting these relocations to have been applied.  Check for this
     case and issue a warning message in order to avoid confusion.
     FIXME: Maybe we ought to have an option that dumps a section with
     relocs applied ?  */
  for (relsec = section_headers;
       relsec < section_headers + elf_header.e_shnum;
       ++relsec)
    {
      if ((relsec->sh_type != SHT_RELA && relsec->sh_type != SHT_REL)
	  || relsec->sh_info >= elf_header.e_shnum
	  || section_headers + relsec->sh_info != section
	  || relsec->sh_size == 0
	  || relsec->sh_link >= elf_header.e_shnum)
	continue;

      printf (_(" NOTE: This section has relocations against it, but these have NOT been applied to this dump.\n"));
      break;
    }

  data = start;

  while (bytes)
    {
      int j;
      int k;
      int lbytes;

      lbytes = (bytes > 16 ? 16 : bytes);

      printf ("  0x%8.8lx ", (unsigned long) addr);

      for (j = 0; j < 16; j++)
	{
	  if (j < lbytes)
	    printf ("%2.2x", data[j]);
	  else
	    printf ("  ");

	  if ((j & 3) == 3)
	    printf (" ");
	}

      for (j = 0; j < lbytes; j++)
	{
	  k = data[j];
	  if (k >= ' ' && k < 0x7f)
	    printf ("%c", k);
	  else
	    printf (".");
	}

      putchar ('\n');

      data  += lbytes;
      addr  += lbytes;
      bytes -= lbytes;
    }

  free (start);

  putchar ('\n');
  return 1;
d8006 2
a8007 2
	 more helpful warning message will be generated by
	 debug_apply_relocations anyway, so just return.  */
d8141 4
a8144 2
/* Uncompresses a section that was compressed using zlib, in place.
   This is a copy of bfd_uncompress_section_contents, in bfd/compress.c  */
d8146 4
a8149 2
static int
uncompress_section_contents (unsigned char ** buffer, dwarf_size_type * size)
d8151 2
a8152 13
#ifndef HAVE_ZLIB_H
  /* These are just to quiet gcc.  */
  buffer = 0;
  size = 0;
  return FALSE;
#else
  dwarf_size_type compressed_size = *size;
  unsigned char * compressed_buffer = *buffer;
  dwarf_size_type uncompressed_size;
  unsigned char * uncompressed_buffer;
  z_stream strm;
  int rc;
  dwarf_size_type header_size = 12;
d8154 2
a8155 5
  /* Read the zlib header.  In this case, it should be "ZLIB" followed
     by the uncompressed section size, 8 bytes in big-endian order.  */
  if (compressed_size < header_size
      || ! streq ((char *) compressed_buffer, "ZLIB"))
    return 0;
d8157 12
a8168 120
  uncompressed_size = compressed_buffer[4]; uncompressed_size <<= 8;
  uncompressed_size += compressed_buffer[5]; uncompressed_size <<= 8;
  uncompressed_size += compressed_buffer[6]; uncompressed_size <<= 8;
  uncompressed_size += compressed_buffer[7]; uncompressed_size <<= 8;
  uncompressed_size += compressed_buffer[8]; uncompressed_size <<= 8;
  uncompressed_size += compressed_buffer[9]; uncompressed_size <<= 8;
  uncompressed_size += compressed_buffer[10]; uncompressed_size <<= 8;
  uncompressed_size += compressed_buffer[11];

  /* It is possible the section consists of several compressed
     buffers concatenated together, so we uncompress in a loop.  */
  strm.zalloc = NULL;
  strm.zfree = NULL;
  strm.opaque = NULL;
  strm.avail_in = compressed_size - header_size;
  strm.next_in = (Bytef *) compressed_buffer + header_size;
  strm.avail_out = uncompressed_size;
  uncompressed_buffer = xmalloc (uncompressed_size);

  rc = inflateInit (& strm);
  while (strm.avail_in > 0)
    {
      if (rc != Z_OK)
        goto fail;
      strm.next_out = ((Bytef *) uncompressed_buffer
                       + (uncompressed_size - strm.avail_out));
      rc = inflate (&strm, Z_FINISH);
      if (rc != Z_STREAM_END)
        goto fail;
      rc = inflateReset (& strm);
    }
  rc = inflateEnd (& strm);
  if (rc != Z_OK
      || strm.avail_out != 0)
    goto fail;

  free (compressed_buffer);
  *buffer = uncompressed_buffer;
  *size = uncompressed_size;
  return 1;

 fail:
  free (uncompressed_buffer);
  return 0;
#endif  /* HAVE_ZLIB_H */
}

/* Check to see if the given reloc needs to be handled in a target specific
   manner.  If so then process the reloc and return TRUE otherwise return
   FALSE.  */

static bfd_boolean
target_specific_reloc_handling (Elf_Internal_Rela * reloc,
				unsigned char *     start,
				Elf_Internal_Sym *  symtab)
{
  unsigned int reloc_type = get_reloc_type (reloc->r_info);

  switch (elf_header.e_machine)
    {
    case EM_MN10300:
    case EM_CYGNUS_MN10300:
      {
	static Elf_Internal_Sym * saved_sym = NULL;

	switch (reloc_type)
	  {
	  case 34: /* R_MN10300_ALIGN */
	    return TRUE;
	  case 33: /* R_MN10300_SYM_DIFF */
	    saved_sym = symtab + get_reloc_symindex (reloc->r_info);
	    return TRUE;
	  case 1: /* R_MN10300_32 */
	    if (saved_sym != NULL)
	      {
		bfd_vma value;

		value = reloc->r_addend
		  + (symtab[get_reloc_symindex (reloc->r_info)].st_value
		     - saved_sym->st_value);

		byte_put (start + reloc->r_offset, value, 4);

		saved_sym = NULL;
		return TRUE;
	      }
	    break;
	  }
	break;
      }
    }

  return FALSE;
}

/* Apply relocations to a debug section.  */

static void
debug_apply_relocations (void * file,
			 Elf_Internal_Shdr * section,
			 unsigned char * start)
{
  Elf_Internal_Shdr * relsec;
  unsigned char * end = start + section->sh_size;

  if (elf_header.e_type != ET_REL)
    return;

  /* Find the reloc section associated with the debug section.  */
  for (relsec = section_headers;
       relsec < section_headers + elf_header.e_shnum;
       ++relsec)
    {
      bfd_boolean is_rela;
      unsigned long num_relocs;
      Elf_Internal_Rela * relocs;
      Elf_Internal_Rela * rp;
      Elf_Internal_Shdr * symsec;
      Elf_Internal_Sym * symtab;
      Elf_Internal_Sym * sym;
d8282 268
d8577 1
a8577 1
    debug_apply_relocations (file, sec, section->start);
d8726 1
a8726 1
	dump_section_as_bytes (section, file);
d8728 2
a8729 2
      if (dump_sects[i] & DEBUG_DUMP)
	display_debug_section (section, file);
d8733 3
@


1.447
log
@        * readelf.c (process_symbol_table): Set gnubuckets to NULL after
        freeing it and before returning.
@
text
@d6439 1
d8341 48
d8453 3
a8455 1
	  if (is_none_reloc (reloc_type))
d8457 2
a8458 3

	  if (is_32bit_abs_reloc (reloc_type)
	      || is_32bit_pcrel_reloc (reloc_type))
@


1.446
log
@	* readelf.c (process_symbol_table): Don't return early if
	.hash/.gnu.hash is empty/unusable and not -D.
@
text
@d7292 2
a7295 2
	  gnubuckets = NULL;
	  ngnubuckets = 0;
@


1.445
log
@        * readelf.c (display_debug_section): Do not display debug sections
        with the NOBITS section type.
@
text
@d7155 1
a7155 1
	  return 0;
d7161 1
a7161 1
	  return 0;
d7167 1
a7167 1
	  return 0;
d7176 1
d7178 10
a7187 1
	return 0;
d7205 1
a7205 1
	  return 0;
d7211 1
a7211 1
	  return 0;
d7229 1
a7229 1
	  return 0;
d7235 1
a7235 1
	return 0;
d7248 1
a7248 1
	return 0;
d7259 1
a7259 1
	  return 0;
d7267 1
a7267 1
	      return 0;
d7271 1
a7271 1
	    return 0;
d7283 1
a7283 1
	  return 0;
d7288 1
d7290 7
a7296 1
	return 0;
d7628 1
a7628 1
  if (do_histogram && dynamic_info_DT_GNU_HASH)
@


1.444
log
@include/elf
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * common.h (STT_GNU_IFUNC): Define.

elfcpp
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * (enum STT): Add STT_GNU_IFUNC.

gas
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * config/obj-elf.c (obj_elf_type): Add support for a
        gnu_indirect_function type.
        * config/tc-i386.c (tc_i386_fix_adjustable): Do not adjust fixups
        against indirect function symbols.
        * doc/as.texinfo (.type): Document the support for the
        gnu_indirect_function symbol type.
        * NEWS: Mention the new feature.

gas/testsuite
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * gas/elf/elf.exp: Extend type test to include an ifunc symbol.
        Provide an alternative test for targets which do not support ifunc
        symbols.
        (type.s): Add entry for an ifunc symbol.
        (type.e): Add ifunc entry to expected symbol dump.
        (section2.e-armelf): Add  entry for ifunc symbol.
        (type-noifunc.s): New file.
        (type-noifunc.e): New file.

bfd/
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * elf-bfd.h (struct bfd_elf_section_data): Add indirect_relocs
        section pointer.
        (struct elf_obj_data): Add has_ifunc_symbols boolean.
        * elf.c (swap_out_syms): Convert BSF_GNU_INDIRECT_FUNCTION flags
        into a STT_GNU_IFUNC symbol type.
        (_bfd_elf_is_function_type): Accept STT_GNU_IFUNC as a function
        type.
        (_bfd_elf_set_osabi): Set the osasbi field to ELFOSABI_LINUX if
        the binary contains ifunc symbols.
        * elfcode.h (elf_slurp_symbol_table): Translate the STT_GNU_IFUNC
        symbol type into a BSF_GNU_INDIRECT_FUNCTION flag.
        * elf32-i386.c (is_indirect_function): New function.
        (elf_i386_check_relocs): Create an ifunc output section.
        (allocate_dynrelocs): Create dynamic relocs in the ifunc output
        section if necessary.
        (elf_i386_relocate_section): Emit a reloc against an ifunc symbol
        if necessary.
        (elf_i386_add_symbol_hook): New function. Set the
        has_ifunc_symbols field of the elf_obj_data structure if an ifunc
        symbol is encountered.
        (elf_backend_post_process_headers): Define.
        (elf_backend_add_symbol_hook): Define.
        (elf_i386_post_process_headers): Rename to
        elf_i388_fbsd_post_process_headers.
        * elf64-x86_64.c (IS_X86_64_PCREL_TYPE): New macro.
        (is_indirect_function): New function.
        (elf64_x86_64_check_relocs): Create an ifunc output section.
        (allocate_dynrelocs): Create dynamic relocs in the ifunc output
        section if necessary.
        (elf64_x86_64_relocate_section): Emit a reloc against an ifunc
        symbol if necessary.
        (elf_i386_add_symbol_hook): Set the has_ifunc_symbols field of the
        elf_obj_data structure if an ifunc symbol is encountered.
        (elf_backend_post_process_headers): Define.
        * elflink.c (_bfd_elf_adjust_dynamic_symbol): Always create a PLT
        if we have ifunc symbols to handle.
        (get_ifunc_reloc_section_name): New function.  Computes the name
        for an ifunc section.
        (_bfd_elf_make_ifunc_reloc_section): New function.  Creates a
        section to hold ifunc relocs.
        * syms.c (BSF_GNU_INDIRECT_FUNCTION): Define.
        (bfd_print_symbol_vandf): Handle ifunc symbols.
        (bfd_decode_symclass): Likewise.
        * bfd-in2.h: Regenerate.

binutils
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * readelf.c (dump_relocations): Display a relocation against an
        ifunc symbol as if it were a function invocation.
        (get_symbol_type): Handle STT_GNU_IFUNC.

ld
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * NEWS: Mention support for IFUNC symbols.

ld/testsuite
2009-04-30  Nick Clifton  <nickc@@redhat.com>

        * ld-ifunc: New directory.
        * ld-ifunc/ifunc.exp: New file: Run the IFUNC tests.
        * ld-ifunc/prog.c: New file.
        * ld-ifunc/lib.c: New file.
@
text
@d8542 9
@


1.443
log
@	* readelf.c (slurp_ia64_unwind_table): Correct 64-bit unwind table
	read, and merge with 32-bit case.
@
text
@d1241 29
a1269 1
	      print_vma (psym->st_value, LONG_HEX);
d1271 2
a1272 1
	      printf (is_32bit_elf ? "   " : " ");
d6945 6
@


1.442
log
@	* readelf.c (process_file_header): Don't report a corrupt string
	table index if it is zero.
@
text
@d4978 1
a4978 1
  for (tp = table; tp < table + size; tp += 3 * eh_addr_size, ++tep)
d4983 3
a4985 12
      if (is_32bit_elf)
	{
	  tep->start.offset = byte_get ((unsigned char *) tp + 0, 4);
	  tep->end.offset   = byte_get ((unsigned char *) tp + 4, 4);
	  tep->info.offset  = byte_get ((unsigned char *) tp + 8, 4);
	}
      else
	{
	  tep->start.offset = BYTE_GET ((unsigned char *) tp +  0);
	  tep->end.offset   = BYTE_GET ((unsigned char *) tp +  8);
	  tep->info.offset  = BYTE_GET ((unsigned char *) tp + 16);
	}
@


1.441
log
@2009-03-19  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (debug_apply_relocations): Check relocations
	against STT_SECTION symbol.
@
text
@d3208 2
a3209 1
      else if (elf_header.e_shstrndx >= elf_header.e_shnum)
@


1.440
log
@2009-03-18  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (debug_apply_relocations): Allow relocations
	against function symbols.
@
text
@d8390 12
a8401 1
	     make sure that it is of an appropriate type.  */
d8403 1
a8403 12
	      && ELF_ST_TYPE (sym->st_info) != STT_SECTION
	      /* Relocations against symbols without type can happen.
		 Gcc -feliminate-dwarf2-dups may generate symbols
		 without type for debug info.  */
	      && ELF_ST_TYPE (sym->st_info) != STT_NOTYPE
	      /* Icc generates relocations against function symbols
		 instead of local labels.  */
	      && ELF_ST_TYPE (sym->st_info) != STT_FUNC
	      /* Relocations against object symbols can happen,
		 eg when referencing a global array.  For an
		 example of this see the _clz.o binary in libgcc.a.  */
	      && ELF_ST_TYPE (sym->st_info) != STT_OBJECT)
@


1.439
log
@        * readelf.c (adjust_relative_path): New function.
        (struct archive_info): New type.
        (setup_archive): New function.
        (release_archive): New function.
        (setup_nested_archive): New function.
        (get_archive_member_name): New function.
        (get_archive_member_name_at): New function.
        (make_qualified_name): New function.
        (process_archive): Factor out code for reading archive index and
        long filename table to setup_archive.  Add support for thin archives.
@
text
@d8397 3
@


1.438
log
@	* readelf.c (parse_args): Select all sections explicitly for -w.
@
text
@d3 1
a3 1
   2008  Free Software Foundation, Inc.
d148 1
d150 1
a150 1
char *program_name = "readelf";
d157 1
a157 1
static char *dynamic_strings;
d159 1
a159 1
static char *string_table;
d162 2
a163 2
static Elf_Internal_Sym *dynamic_symbols;
static Elf_Internal_Syminfo *dynamic_syminfo;
d171 4
a174 4
static Elf_Internal_Shdr *section_headers;
static Elf_Internal_Phdr *program_headers;
static Elf_Internal_Dyn *dynamic_section;
static Elf_Internal_Shdr *symtab_shndx_hdr;
d197 1
a197 1
  struct group_list *next;
d203 1
a203 1
  struct group_list *root;
d208 2
a209 2
static struct group *section_groups;
static struct group **section_headers_groups;
d223 1
a223 1
  char *name;
d225 1
a225 1
  struct dump_list_entry *next;
d227 1
a227 1
static struct dump_list_entry *dump_sects_byname;
d256 1
a256 1
static void (*byte_put) (unsigned char *, bfd_vma, int);
d285 2
a286 2
get_data (void *var, FILE *file, long offset, size_t size, size_t nmemb,
	  const char *reason)
d288 1
a288 1
  void *mvar;
d331 1
a331 1
byte_put_little_endian (unsigned char *field, bfd_vma value, int size)
d409 1
a409 1
print_symbol (int width, const char *symbol)
d492 1
a492 1
byte_put_big_endian (unsigned char *field, bfd_vma value, int size)
d526 1
a526 1
find_section (const char *name)
d641 1
a641 1
slurp_rela_relocs (FILE *file,
d644 2
a645 2
		   Elf_Internal_Rela **relasp,
		   unsigned long *nrelasp)
d647 1
a647 1
  Elf_Internal_Rela *relas;
d653 1
a653 1
      Elf32_External_Rela *erelas;
d681 1
a681 1
      Elf64_External_Rela *erelas;
d735 1
a735 1
slurp_rel_relocs (FILE *file,
d738 2
a739 2
		  Elf_Internal_Rela **relsp,
		  unsigned long *nrelsp)
d741 1
a741 1
  Elf_Internal_Rela *rels;
d747 1
a747 1
      Elf32_External_Rel *erels;
d775 1
a775 1
      Elf64_External_Rel *erels;
d862 1
a862 1
dump_relocations (FILE *file,
d865 1
a865 1
		  Elf_Internal_Sym *symtab,
d867 1
a867 1
		  char *strtab,
d872 1
a872 2
  Elf_Internal_Rela *rels;

d925 1
a925 1
      const char *rtype;
d1235 1
a1235 1
	      Elf_Internal_Sym *psym;
d1247 1
a1247 1
		  const char *sec_name = "<null>";
d1323 2
a1324 2
	  const char *rtype2 = elf_mips_reloc_type (type2);
	  const char *rtype3 = elf_mips_reloc_type (type3);
d1628 1
a1628 1
	  const char *result;
d1668 1
a1668 1
	  const char *result;
d2092 3
a2094 3
	      char const *isa = _("unknown");
	      char const *mac = _("unknown mac");
	      char const *additional = NULL;
d2519 1
a2519 1
	  const char *result;
d2548 1
a2548 1
	  const char *result;
d2734 1
a2734 1
	  const char *result;
d2766 1
a2766 1
	  const char *result;
d2831 1
a2831 1
usage (FILE *stream)
d2890 1
a2890 1
      dump_type *new_dump_sects;
d2917 1
a2917 1
request_dump_byname (const char *section, dump_type type)
d2919 1
a2919 1
  struct dump_list_entry *new_request;
d2936 1
a2936 1
parse_args (int argc, char **argv)
d2946 1
a2946 1
      char *cp;
d3230 1
a3230 1
get_32bit_program_headers (FILE *file, Elf_Internal_Phdr *program_headers)
d3232 3
a3234 3
  Elf32_External_Phdr *phdrs;
  Elf32_External_Phdr *external;
  Elf_Internal_Phdr *internal;
d3263 1
a3263 1
get_64bit_program_headers (FILE *file, Elf_Internal_Phdr *program_headers)
d3265 3
a3267 3
  Elf64_External_Phdr *phdrs;
  Elf64_External_Phdr *external;
  Elf_Internal_Phdr *internal;
d3298 1
a3298 1
get_program_headers (FILE *file)
d3300 1
a3300 1
  Elf_Internal_Phdr *phdrs;
d3329 1
a3329 1
process_program_headers (FILE *file)
d3331 1
a3331 1
  Elf_Internal_Phdr *segment;
d3477 1
a3477 1
	      Elf_Internal_Shdr *sec;
d3540 1
a3540 1
	  Elf_Internal_Shdr *section;
d3549 1
a3549 1
	      if (ELF_IS_SECTION_IN_SEGMENT_MEMORY(section, segment))
d3564 1
a3564 1
offset_from_vma (FILE *file, bfd_vma vma, bfd_size_type size)
d3566 1
a3566 1
  Elf_Internal_Phdr *seg;
d3593 1
a3593 1
get_32bit_section_headers (FILE *file, unsigned int num)
d3595 2
a3596 2
  Elf32_External_Shdr *shdrs;
  Elf_Internal_Shdr *internal;
d3634 1
a3634 1
get_64bit_section_headers (FILE *file, unsigned int num)
d3636 2
a3637 2
  Elf64_External_Shdr *shdrs;
  Elf_Internal_Shdr *internal;
d3675 1
a3675 1
get_32bit_elf_symbols (FILE *file, Elf_Internal_Shdr *section)
d3678 4
a3681 4
  Elf32_External_Sym *esyms;
  Elf_External_Sym_Shndx *shndx;
  Elf_Internal_Sym *isyms;
  Elf_Internal_Sym *psym;
d3740 1
a3740 1
get_64bit_elf_symbols (FILE *file, Elf_Internal_Shdr *section)
d3743 4
a3746 4
  Elf64_External_Sym *esyms;
  Elf_External_Sym_Shndx *shndx;
  Elf_Internal_Sym *isyms;
  Elf_Internal_Sym *psym;
d3808 1
a3808 1
  char *p = buff;
d3816 1
a3816 1
      const char *str;
d4009 1
a4009 1
process_section_headers (FILE *file)
d4011 1
a4011 1
  Elf_Internal_Shdr *section;
d4126 1
a4126 1
      char *name = SECTION_NAME (section);
d4409 1
a4409 1
process_section_groups (FILE *file)
d4411 1
a4411 1
  Elf_Internal_Shdr *section;
d4413 5
a4417 4
  struct group *group;
  Elf_Internal_Shdr *symtab_sec, *strtab_sec;
  Elf_Internal_Sym *symtab;
  char *strtab;
d4482 4
a4485 3
	  char *name = SECTION_NAME (section);
	  char *group_name;
	  unsigned char *start, *indices;
d4487 2
a4488 2
	  Elf_Internal_Shdr *sec;
	  Elf_Internal_Sym *sym;
d4571 1
a4571 1
	      struct group_list *g;
d4637 1
a4637 1
  const char *name;
d4651 1
a4651 1
process_relocs (FILE *file)
d4663 1
a4663 1
      const char *name;
d4711 1
a4711 1
      Elf_Internal_Shdr *section;
d4728 1
a4728 1
	      Elf_Internal_Shdr *strsec;
d4746 2
a4747 2
		  Elf_Internal_Shdr *symsec;
		  Elf_Internal_Sym *symtab;
d4750 1
a4750 1
		  char *strtab = NULL;
d4824 1
a4824 1
    unsigned char *info;	/* Unwind info.  */
d4828 1
a4828 1
    Elf_Internal_Sym *symtab;	/* The symbol table.  */
d4830 1
a4830 1
    char *strtab;		/* The string table.  */
d4835 1
a4835 1
find_symbol_for_address (Elf_Internal_Sym *symtab,
d4837 1
a4837 1
			 const char *strtab,
d4840 2
a4841 2
			 const char **symname,
			 bfd_vma *offset)
d4844 2
a4845 1
  Elf_Internal_Sym *sym, *best = NULL;
d4874 1
a4874 1
dump_ia64_unwind (struct ia64_unw_aux_info *aux)
d4876 1
a4876 1
  struct ia64_unw_table_entry *tp;
d4883 3
a4885 3
      const unsigned char *dp;
      const unsigned char *head;
      const char *procname;
d4930 3
a4932 3
slurp_ia64_unwind_table (FILE *file,
			 struct ia64_unw_aux_info *aux,
			 Elf_Internal_Shdr *sec)
d4935 9
a4943 7
  Elf_Internal_Phdr *seg;
  struct ia64_unw_table_entry *tep;
  Elf_Internal_Shdr *relsec;
  Elf_Internal_Rela *rela, *rp;
  unsigned char *table, *tp;
  Elf_Internal_Sym *sym;
  const char *relname;
d5054 1
a5054 1
ia64_process_unwind (FILE *file)
d5056 3
a5058 1
  Elf_Internal_Shdr *sec, *unwsec = NULL, *strsec;
d5086 1
a5086 1
      char *suffix;
d5103 1
a5103 1
	  struct group_list *g = section_headers_groups [i]->root;
d5233 1
a5233 1
    Elf_Internal_Sym *symtab;	/* The symbol table.  */
d5235 1
a5235 1
    char *strtab;		/* The string table.  */
d5240 1
a5240 1
dump_hppa_unwind (struct hppa_unw_aux_info *aux)
d5242 1
a5242 1
  struct hppa_unw_table_entry *tp;
d5247 1
a5247 1
      const char *procname;
d5306 3
a5308 3
slurp_hppa_unwind_table (FILE *file,
			 struct hppa_unw_aux_info *aux,
			 Elf_Internal_Shdr *sec)
d5311 9
a5319 7
  Elf_Internal_Phdr *seg;
  struct hppa_unw_table_entry *tep;
  Elf_Internal_Shdr *relsec;
  Elf_Internal_Rela *rela, *rp;
  unsigned char *table, *tp;
  Elf_Internal_Sym *sym;
  const char *relname;
d5459 1
a5459 1
hppa_process_unwind (FILE *file)
d5462 3
a5464 3
  Elf_Internal_Shdr *unwsec = NULL;
  Elf_Internal_Shdr *strsec;
  Elf_Internal_Shdr *sec;
d5522 1
a5522 1
process_unwind (FILE *file)
d5524 2
a5525 1
  struct unwind_handler {
d5527 3
a5529 2
    int (*handler)(FILE *file);
  } handlers[] = {
d5548 1
a5548 1
dynamic_section_mips_val (Elf_Internal_Dyn *entry)
d5587 1
a5587 1
	struct tm *tmp;
d5621 1
a5621 1
dynamic_section_parisc_val (Elf_Internal_Dyn *entry)
d5630 1
a5630 1
	  const char *str;
d5683 1
a5683 1
dynamic_section_ia64_val (Elf_Internal_Dyn *entry)
d5702 1
a5702 1
get_32bit_dynamic_section (FILE *file)
d5704 3
a5706 2
  Elf32_External_Dyn *edyn, *ext;
  Elf_Internal_Dyn *entry;
d5725 1
a5725 1
  dynamic_section = cmalloc (dynamic_nent, sizeof (*entry));
d5747 1
a5747 1
get_64bit_dynamic_section (FILE *file)
d5749 3
a5751 2
  Elf64_External_Dyn *edyn, *ext;
  Elf_Internal_Dyn *entry;
d5770 1
a5770 1
  dynamic_section = cmalloc (dynamic_nent, sizeof (*entry));
d5824 1
a5824 1
process_dynamic_section (FILE *file)
d5826 1
a5826 1
  Elf_Internal_Dyn *entry;
d5959 3
a5961 2
	  Elf_External_Syminfo *extsyminfo, *extsym;
	  Elf_Internal_Syminfo *syminfo;
d6001 1
a6001 1
	  const char *dtype;
d6230 1
a6230 1
	      char *name;
d6316 1
a6316 1
		  char *name = GET_DYNAMIC_NAME (entry->d_un.d_val);
d6339 1
a6339 1
	      struct tm *tmp;
d6419 1
a6419 1
process_version_sections (FILE *file)
d6421 1
a6421 1
  Elf_Internal_Shdr *section;
d6436 1
a6436 1
	    Elf_External_Verdef *edefs;
d6439 1
a6439 1
	    char *endbuf;
d6464 2
a6465 2
		char *vstart;
		Elf_External_Verdef *edef;
d6467 1
a6467 1
		Elf_External_Verdaux *eaux;
d6539 1
a6539 1
	    Elf_External_Verneed *eneed;
d6542 1
a6542 1
	    char *endbuf;
d6566 1
a6566 1
		Elf_External_Verneed *entry;
d6570 1
a6570 1
		char *vstart;
d6597 1
a6597 1
		    Elf_External_Vernaux *eaux;
d6637 1
a6637 1
	    Elf_Internal_Shdr *link_section;
d6640 5
a6644 5
	    unsigned char *edata;
	    unsigned short *data;
	    char *strtab;
	    Elf_Internal_Sym *symbols;
	    Elf_Internal_Shdr *string_sec;
d6699 1
a6699 1
		char *name;
d7021 1
a7021 1
get_dynamic_data (FILE *file, unsigned int number, unsigned int ent_size)
d7023 2
a7024 2
  unsigned char *e_data;
  bfd_vma *i_data;
d7060 1
a7060 1
  Elf_Internal_Sym *psym;
d7092 1
a7092 1
process_symbol_table (FILE *file)
d7094 1
a7094 1
  Elf_Internal_Shdr *section;
d7097 2
a7098 2
  bfd_vma *buckets = NULL;
  bfd_vma *chains = NULL;
d7100 2
a7101 2
  bfd_vma *gnubuckets = NULL;
  bfd_vma *gnuchains = NULL;
d7314 1
a7314 1
	  char *strtab = NULL;
d7316 2
a7317 3
	  Elf_Internal_Sym *symtab;
	  Elf_Internal_Sym *psym;

d7342 1
a7342 1
	      Elf_Internal_Shdr *string_sec;
d7522 2
a7523 2
      unsigned long *lengths;
      unsigned long *counts;
d7586 2
a7587 2
      unsigned long *lengths;
      unsigned long *counts;
d7652 1
a7652 1
process_syminfo (FILE *file ATTRIBUTE_UNUSED)
d7719 1
a7719 1
disassemble_section (Elf_Internal_Shdr *section, FILE *file)
d7731 1
a7731 1
dump_section_as_strings (Elf_Internal_Shdr *section, FILE *file)
d7733 1
a7733 1
  Elf_Internal_Shdr *relsec;
d7736 4
a7739 4
  char *data;
  char *end;
  char *start;
  char *name = SECTION_NAME (section);
d7812 1
a7812 1
dump_section_as_bytes (Elf_Internal_Shdr *section, FILE *file)
d7814 1
a7814 1
  Elf_Internal_Shdr *relsec;
d7817 2
a7818 2
  unsigned char *data;
  unsigned char *start;
d8227 1
a8227 1
uncompress_section_contents (unsigned char **buffer, dwarf_size_type *size)
d8299 3
a8301 3
debug_apply_relocations (void *file,
			 Elf_Internal_Shdr *section,
			 unsigned char *start)
d8303 2
a8304 2
  Elf_Internal_Shdr *relsec;
  unsigned char *end = start + section->sh_size;
d8316 5
a8320 4
      Elf_Internal_Rela *relocs, *rp;
      Elf_Internal_Shdr *symsec;
      Elf_Internal_Sym *symtab;
      Elf_Internal_Sym *sym;
d8432 1
a8432 1
			     Elf_Internal_Shdr *sec, void *file)
d8434 1
a8434 1
  struct dwarf_section *section = &debug_displays [debug].section;
d8463 1
a8463 1
load_debug_section (enum dwarf_section_display_enum debug, void *file)
d8465 2
a8466 2
  struct dwarf_section *section = &debug_displays [debug].section;
  Elf_Internal_Shdr *sec;
d8487 1
a8487 1
  struct dwarf_section *section = &debug_displays [debug].section;
d8499 1
a8499 1
display_debug_section (Elf_Internal_Shdr *section, FILE *file)
d8501 1
a8501 1
  char *name = SECTION_NAME (section);
d8521 1
a8521 1
	struct dwarf_section *sec = &debug_displays [i].section;
d8557 1
a8557 1
  struct dump_list_entry *cur;
d8578 1
a8578 1
process_section_contents (FILE *file)
d8580 1
a8580 1
  Elf_Internal_Shdr *section;
d8638 1
a8638 1
  const char *name;
d8641 1
a8641 1
  const char **table;
d8644 1
a8644 1
static const char *arm_attr_tag_CPU_arch[] =
d8647 2
a8648 2
static const char *arm_attr_tag_ARM_ISA_use[] = {"No", "Yes"};
static const char *arm_attr_tag_THUMB_ISA_use[] =
d8650 1
a8650 1
static const char *arm_attr_tag_VFP_arch[] =
d8652 3
a8654 3
static const char *arm_attr_tag_WMMX_arch[] = {"No", "WMMXv1", "WMMXv2"};
static const char *arm_attr_tag_Advanced_SIMD_arch[] = {"No", "NEONv1"};
static const char *arm_attr_tag_PCS_config[] =
d8657 1
a8657 1
static const char *arm_attr_tag_ABI_PCS_R9_use[] =
d8659 1
a8659 1
static const char *arm_attr_tag_ABI_PCS_RW_data[] =
d8661 1
a8661 1
static const char *arm_attr_tag_ABI_PCS_RO_data[] =
d8663 1
a8663 1
static const char *arm_attr_tag_ABI_PCS_GOT_use[] =
d8665 1
a8665 1
static const char *arm_attr_tag_ABI_PCS_wchar_t[] =
d8667 2
a8668 2
static const char *arm_attr_tag_ABI_FP_rounding[] = {"Unused", "Needed"};
static const char *arm_attr_tag_ABI_FP_denormal[] =
d8670 3
a8672 3
static const char *arm_attr_tag_ABI_FP_exceptions[] = {"Unused", "Needed"};
static const char *arm_attr_tag_ABI_FP_user_exceptions[] = {"Unused", "Needed"};
static const char *arm_attr_tag_ABI_FP_number_model[] =
d8674 2
a8675 2
static const char *arm_attr_tag_ABI_align8_needed[] = {"No", "Yes", "4-byte"};
static const char *arm_attr_tag_ABI_align8_preserved[] =
d8677 1
a8677 1
static const char *arm_attr_tag_ABI_enum_size[] =
d8679 1
a8679 1
static const char *arm_attr_tag_ABI_HardFP_use[] =
d8681 1
a8681 1
static const char *arm_attr_tag_ABI_VFP_args[] =
d8683 1
a8683 1
static const char *arm_attr_tag_ABI_WMMX_args[] =
d8685 1
a8685 1
static const char *arm_attr_tag_ABI_optimization_goals[] =
d8688 1
a8688 1
static const char *arm_attr_tag_ABI_FP_optimization_goals[] =
d8691 2
a8692 2
static const char *arm_attr_tag_CPU_unaligned_access[] = {"None", "v6"};
static const char *arm_attr_tag_VFP_HP_extension[] =
d8694 1
a8694 1
static const char *arm_attr_tag_ABI_FP_16bit_format[] =
d8696 2
a8697 2
static const char *arm_attr_tag_T2EE_use[] = {"Not Allowed", "Allowed"};
static const char *arm_attr_tag_Virtualization_use[] =
d8699 1
a8699 1
static const char *arm_attr_tag_MPextension_use[] = {"Not Allowed", "Allowed"};
d8748 1
d8750 1
a8750 1
read_uleb128 (unsigned char *p, unsigned int *plen)
d8774 1
a8774 1
display_arm_attribute (unsigned char *p)
d8779 1
a8779 1
  arm_attr_public_tag *attr;
d8786 1
a8786 1
  for (i = 0; i < ARRAY_SIZE(arm_attr_public_tags); i++)
d8820 1
a8820 1
	      p += strlen((char *)p) + 1;
d8835 1
a8835 1
		  if ((unsigned int)val >= ARRAY_SIZE(arm_attr_tag_CPU_arch))
d8846 1
a8846 1
	      abort();
d8879 1
a8879 1
      p += strlen((char *)p) + 1;
d8939 1
a8939 1
display_power_gnu_attribute (unsigned char *p, int tag)
d9043 1
a9043 1
display_mips_gnu_attribute (unsigned char *p, int tag)
d9107 4
a9110 4
  Elf_Internal_Shdr *sect;
  unsigned char *contents;
  unsigned char *p;
  unsigned char *end;
d9243 1
a9243 1
process_arm_specific (FILE *file)
d9250 1
a9250 1
process_power_specific (FILE *file)
d9261 1
a9261 1
print_mips_got_entry (unsigned char *data, bfd_vma pltgot, bfd_vma addr)
d9288 1
a9288 1
print_mips_pltgot_entry (unsigned char *data, bfd_vma pltgot, bfd_vma addr)
d9306 1
a9306 1
process_mips_specific (FILE *file)
d9308 1
a9308 1
  Elf_Internal_Dyn *entry;
d9383 1
a9383 1
      Elf32_External_Lib *elib;
d9401 1
a9401 1
	      struct tm *tmp;
d9429 1
a9429 1
		    const char *name;
d9463 4
a9466 4
      Elf_External_Options *eopt;
      Elf_Internal_Shdr *sect = section_headers;
      Elf_Internal_Options *iopt;
      Elf_Internal_Options *option;
d9478 1
a9478 1
	  iopt = cmalloc ((sect->sh_size / sizeof (eopt)), sizeof (*iopt));
d9490 1
a9490 1
	      Elf_External_Options *eoption;
d9525 1
a9525 1
		      Elf32_External_RegInfo *ereg;
d9546 1
a9546 1
		      Elf64_External_RegInfo *ereg;
d9643 1
a9643 1
	      len = sizeof (*eopt);
d9661 1
a9661 1
      Elf32_Conflict *iconf;
d9670 1
a9670 1
      iconf = cmalloc (conflictsno, sizeof (*iconf));
d9679 1
a9679 1
	  Elf32_External_Conflict *econf32;
d9682 1
a9682 1
			      conflictsno, sizeof (*econf32), _("conflict"));
d9693 1
a9693 1
	  Elf64_External_Conflict *econf64;
d9696 1
a9696 1
			      conflictsno, sizeof (*econf64), _("conflict"));
d9712 1
a9712 1
	  Elf_Internal_Sym *psym = & dynamic_symbols[iconf[cnt]];
d9731 1
a9731 1
      unsigned char *data;
d9787 1
a9787 1
	      Elf_Internal_Sym *psym;
d9814 1
a9814 1
      unsigned char *data;
d9816 1
a9816 1
      Elf_Internal_Rela *rels;
d9854 1
a9854 1
	  Elf_Internal_Sym *psym;
d9880 1
a9880 1
process_gnu_liblist (FILE *file)
d9882 4
a9885 3
  Elf_Internal_Shdr *section, *string_sec;
  Elf32_External_Lib *elib;
  char *strtab;
d9933 1
a9933 1
	      struct tm *tmp;
d10110 1
a10110 1
process_note (Elf_Internal_Note *pnote)
d10112 2
a10113 2
  const char *name = pnote->namesz ? pnote->namedata : "(NONE)";
  const char *nt;
d10146 1
a10146 1
process_corefile_note_segment (FILE *file, bfd_vma offset, bfd_vma length)
d10148 2
a10149 2
  Elf_External_Note *pnotes;
  Elf_External_Note *external;
d10165 1
a10165 1
  while (external < (Elf_External_Note *)((char *) pnotes + length))
d10167 1
a10167 1
      Elf_External_Note *next;
d10169 1
a10169 1
      char *temp = NULL;
d10178 1
a10178 1
      next = (Elf_External_Note *)(inote.descdata + align_power (inote.descsz, 2));
d10228 1
a10228 1
process_corefile_note_segments (FILE *file)
d10230 1
a10230 1
  Elf_Internal_Phdr *segment;
d10251 1
a10251 1
process_note_sections (FILE *file)
d10253 1
a10253 1
  Elf_Internal_Shdr *section;
d10269 1
a10269 1
process_notes (FILE *file)
d10287 1
a10287 1
process_arch_specific (FILE *file)
d10310 1
a10310 1
get_file_header (FILE *file)
d10407 1
a10407 1
process_object (char *file_name, FILE *file)
d10533 2
a10534 1
      struct group_list *g, *next;
d10554 64
a10617 2
/* Process an ELF archive.
   On entry the file is positioned just after the ARMAG string.  */
d10620 2
a10621 1
process_archive (char *file_name, FILE *file)
a10622 1
  struct ar_hdr arhdr;
a10624 8
  unsigned long index_num = 0;
  unsigned long *index_array = NULL;
  char *sym_table = NULL;
  unsigned long sym_size = 0;
  char *longnames = NULL;
  unsigned long longnames_size = 0;
  size_t file_name_size;
  int ret;
d10626 11
a10636 1
  show_name = 1;
d10638 8
a10645 2
  got = fread (&arhdr, 1, sizeof arhdr, file);
  if (got != sizeof arhdr)
d10655 2
a10656 2
  if (const_strneq (arhdr.ar_name, "/               ")
      || const_strneq (arhdr.ar_name, "/SYM64/         "))
d10658 1
a10658 1
      size = strtoul (arhdr.ar_size, NULL, 10);
d10661 3
a10663 1
      if (do_archive_index)
d10686 1
a10686 1
	  index_num = byte_get_big_endian (integer_buffer, sizeof integer_buffer);
d10690 1
a10690 1
	  if (size < index_num * SIZEOF_AR_INDEX_NUMBERS)
d10693 1
a10693 1
		     file_name, index_num);
d10696 1
a10696 1
	  index_buffer = malloc (index_num * SIZEOF_AR_INDEX_NUMBERS);
d10702 2
a10703 2
	  got = fread (index_buffer, SIZEOF_AR_INDEX_NUMBERS, index_num, file);
	  if (got != index_num)
d10707 1
a10707 2
	      ret = 1;
	      goto out;
d10709 1
a10709 1
	  size -= index_num * SIZEOF_AR_INDEX_NUMBERS;
d10712 2
a10713 2
	  index_array = malloc (index_num * sizeof (* index_array));
	  if (index_array == NULL)
d10720 3
a10722 3
	  for (i = 0; i < index_num; i++)
	    index_array[i] = byte_get_big_endian ((unsigned char *)(index_buffer + (i * SIZEOF_AR_INDEX_NUMBERS)),
						  SIZEOF_AR_INDEX_NUMBERS);
d10729 1
a10729 2
	      ret = 1;
	      goto out;
d10731 3
a10733 3
	  sym_table = malloc (size);
	  sym_size = size;
	  if (sym_table == NULL)
d10736 1
a10736 2
	      ret = 1;
	      goto out;
d10738 1
a10738 1
	  got = fread (sym_table, 1, size, file);
d10742 1
a10742 2
	      ret = 1;
	      goto out;
d10754 3
a10756 2
      got = fread (& arhdr, 1, sizeof arhdr, file);
      if (got != sizeof arhdr)
d10759 1
a10759 5
	    {
	      ret = 0;
	      goto out;
	    }

d10761 1
a10761 2
	  ret = 1;
	  goto out;
d10764 1
a10764 1
  else if (do_archive_index)
d10767 1
a10767 1
  if (const_strneq (arhdr.ar_name, "//              "))
d10769 3
a10771 2
      /* This is the archive string table holding long member
	 names.  */
d10773 2
a10774 3
      longnames_size = strtoul (arhdr.ar_size, NULL, 10);
      longnames = malloc (longnames_size);
      if (longnames == NULL)
d10777 1
a10777 2
	  ret = 1;
	  goto out;
d10780 1
a10780 1
      if (fread (longnames, longnames_size, 1, file) != 1)
d10782 2
a10783 1
	  free (longnames);
d10785 1
a10785 2
	  ret = 1;
	  goto out;
d10788 1
a10788 1
      if ((longnames_size & 1) != 0)
d10790 171
d10962 34
a10995 12
      got = fread (& arhdr, 1, sizeof arhdr, file);
      if (got != sizeof arhdr)
	{
	  if (got == 0)
	    ret = 0;
	  else
	    {
	      error (_("%s: failed to read archive header following long symbol names\n"), file_name);
	      ret = 1;
	    }
	  goto out;
	}
d11000 1
a11000 1
      if (sym_table == NULL)
d11004 1
a11004 2
	  unsigned int i, j, k, l;
	  char elf_name[16];
d11008 1
a11008 1
		  file_name, index_num, sym_size);
d11011 1
a11011 1
	  for (i = l = 0; i < index_num; i++)
d11013 15
a11027 14
	      if ((i == 0) || ((i > 0) && (index_array[i] != index_array[i - 1])))
		{
		  if (fseek (file, index_array[i], SEEK_SET) != 0)
		    {
		      error (_("%s: failed to seek to next file name\n"), file_name);
		      ret = 1;
		      goto out;
		    }
		  got = fread (elf_name, 1, 16, file);
		  if (got != 16)
		    {
		      error (_("%s: failed to read file name\n"), file_name);
		      ret = 1;
		      goto out;
d11029 1
d11031 1
a11031 20
		  if (elf_name[0] == '/')
		    {
		      /* We have a long name.  */
		      k = j = strtoul (elf_name + 1, NULL, 10);
		      while ((j < longnames_size) && (longnames[j] != '/'))
			j++;
		      longnames[j] = '\0';
		      printf (_("Binary %s contains:\n"), longnames + k);
		      longnames[j] = '/';
		    }
		  else
		    {
		      j = 0;
		      while ((elf_name[j] != '/') && (j < 16))
			j++;
		      elf_name[j] = '\0';
		      printf(_("Binary %s contains:\n"), elf_name);
		    }
		}
	      if (l >= sym_size)
d11037 2
a11038 2
	      printf ("\t%s\n", sym_table + l);
	      l += strlen (sym_table + l) + 1;
d11041 3
a11043 1
	  if (l < sym_size)
a11046 4
	  free (index_array);
	  index_array = NULL;
	  free (sym_table);
	  sym_table = NULL;
d11050 2
a11051 1
	      return 1;
d11059 4
a11062 1
	return 0; /* Archive index only.  */
d11070 31
a11100 7
      char *name;
      char *nameend;
      char *namealc;

      if (arhdr.ar_name[0] == '/')
	{
	  unsigned long off;
d11102 2
a11103 18
	  off = strtoul (arhdr.ar_name + 1, NULL, 10);
	  if (off >= longnames_size)
	    {
	      error (_("%s: invalid archive string table offset %lu\n"), file_name, off);
	      ret = 1;
	      break;
	    }

	  name = longnames + off;
	  nameend = memchr (name, '/', longnames_size - off);
	}
      else
	{
	  name = arhdr.ar_name;
	  nameend = memchr (name, '/', 16);
	}

      if (nameend == NULL)
d11109 1
d11111 2
a11112 2
      namealc = malloc (file_name_size + (nameend - name) + 3);
      if (namealc == NULL)
d11114 1
a11114 1
	  error (_("Out of memory\n"));
d11119 40
a11158 5
      memcpy (namealc, file_name, file_name_size);
      namealc[file_name_size] = '(';
      memcpy (namealc + file_name_size + 1, name, nameend - name);
      namealc[file_name_size + 1 + (nameend - name)] = ')';
      namealc[file_name_size + 2 + (nameend - name)] = '\0';
d11160 6
a11165 2
      archive_file_offset = ftell (file);
      archive_file_size = strtoul (arhdr.ar_size, NULL, 10);
d11167 2
a11168 1
      ret |= process_object (namealc, file);
d11170 1
a11170 23
      free (namealc);

      if (fseek (file,
		 (archive_file_offset
		  + archive_file_size
		  + (archive_file_size & 1)),
		 SEEK_SET) != 0)
	{
	  error (_("%s: failed to seek to next archive header\n"), file_name);
	  ret = 1;
	  break;
	}

      got = fread (&arhdr, 1, sizeof arhdr, file);
      if (got != sizeof arhdr)
	{
	  if (got == 0)
	    break;

	  error (_("%s: failed to read archive header\n"), file_name);
	  ret = 1;
	  break;
	}
d11174 4
a11177 6
  if (index_array != NULL)
    free (index_array);
  if (sym_table != NULL)
    free (sym_table);
  if (longnames != NULL)
    free (longnames);
d11183 1
a11183 1
process_file (char *file_name)
d11185 1
a11185 1
  FILE *file;
d11221 3
a11223 1
    ret = process_archive (file_name, file);
d11246 1
a11246 1
print_address (unsigned int addr, FILE *outfile)
d11260 1
a11260 1
main (int argc, char **argv)
@


1.437
log
@2009-02-09  Tristan Gingold  <gingold@@adacore.com>

	* NEWS: Mention feature match between objdump and readelf for dumping
	dwarf info.

	* doc/binutils.texi (objdump): Document -W/--dwarf improvments to
	objdump.

	* objdump.c (usage): Update documentation for -W/--dwarf.
	(enum option_values): Add OPTION_DWARF.
	(long_options): --dwarf can accept arguments.
	(dump_dwarf_section): Also check enabled field.
	(main): Option -W can accept arguments, code moved to
	dwarf.c and call dwarf_select_sections_all instead.
	* readelf.c (process_section_headers): Remove do_debug_lines_decoded.
	(parse_args): Move code to...
	* dwarf.c (dwarf_select_sections_by_letters,
	dwarf_select_sections_by_names): : ...here (new functions).
	(do_debug_lines_decoded): Remove and replaced by ...
	(FLAG_DEBUG_LINES_RAW, FLAG_DEBUG_LINES_DECODED): ... new macros.
	(display_debug_lines): Adjust for previous change.
	(dwarf_select_sections_all): New function.
	(debug_displays): Add initializer for enabled field.
	* dwarf.h (do_debug_lines_decoded): Remove.
	Add prototypes for the new functions.
	(struct dwarf_section_display): Add enabled field.
@
text
@d3040 4
a3043 1
	    do_debugging = 1;
@


1.436
log
@bfd:
2009-02-03  Sandip Matte  <sandip@@rmicorp.com>

	* aoutx.h (NAME (aout, machine_type)): Handle bfd_mach_mips_xlr.
	* archures.c (bfd_mach_mips_xlr): Define.
	* bfd-in2.h: Regenerate.
	* cpu-mips.c (I_xlr): Define.
	(arch_info_struct): Add XLR entry.
	* elfxx-mips.c (_bfd_elf_mips_mach): Handle E_MIPS_MACH_XLR.
	(mips_set_isa_flags): Handle bfd_mach_mips_xlr
	(mips_mach_extensions): Add XLR entry.

binutils:
2009-02-03  Sandip Matte  <sandip@@rmicorp.com>

	* readelf.c (get_machine_flags): Handle E_MIPS_MACH_XLR.

gas:
2009-02-03  Sandip Matte  <sandip@@rmicorp.com>

	* config/tc-mips.c (macro): Handle M_MSGSND, M_MSGLD, M_MSGLD_T,
	M_MSGWAIT and M_MSGWAIT_T.
	(mips_cpu_info_table): Add XLR entry.
	* doc/c-mips.texi (-march): Document xlr.

gas/testsuite:
2009-02-03  Sandip Matte  <sandip@@rmicorp.com>

	* gas/mips/mips.exp (xlr): New architecture.
	(xlr-ext): Run test.
	* gas/mips/xlr-ext.d, gas/mips/xlr-ext.s: New.

include/elf:
2009-02-03  Sandip Matte  <sandip@@rmicorp.com>

	* mips.h (E_MIPS_MACH_XLR): Define.

include/opcode:
2009-02-03  Sandip Matte  <sandip@@rmicorp.com>

	* mips.h (INSN_XLR): Define.
	(INSN_CHIP_MASK): Update.
	(CPU_XLR): Define.
	(OPCODE_IS_MEMBER): Update.
	(M_MSGSND, M_MSGLD, M_MSGLD_T, M_MSGWAIT, M_MSGWAIT_T): Define.

opcodes:
2009-02-03  Sandip Matte  <sandip@@rmicorp.com>

	* mips-dis.c (mips_cp0_names_xlr, mips_cp0sel_names_xlr): Define.
	(mips_arch_choices): Add XLR entry.
	* mips-opc.c (XLR): Define.
	(mips_builtin_opcodes): Add XLR instructions.
@
text
@a3042 2
	      unsigned int index = 0;

d3044 1
a3044 54

	      while (optarg[index])
		switch (optarg[index++])
		  {
		  case 'i':
		    do_debug_info = 1;
		    break;

		  case 'a':
		    do_debug_abbrevs = 1;
		    break;

		  case 'l':
		    do_debug_lines = 1;
		    break;

		  case 'L':
		    do_debug_lines_decoded = 1;
		    break;

		  case 'p':
		    do_debug_pubnames = 1;
		    break;

		  case 'r':
		    do_debug_aranges = 1;
		    break;

		  case 'R':
		    do_debug_ranges = 1;
		    break;

		  case 'F':
		    do_debug_frames_interp = 1;
		  case 'f':
		    do_debug_frames = 1;
		    break;

		  case 'm':
		    do_debug_macinfo = 1;
		    break;

		  case 's':
		    do_debug_str = 1;
		    break;

		  case 'o':
		    do_debug_loc = 1;
		    break;

		  default:
		    warn (_("Unrecognized debug option '%s'\n"), optarg);
		    break;
		  }
a3052 31
	      typedef struct
	      {
		const char * option;
		int *        variable;
	      }
	      debug_dump_long_opts;

	      debug_dump_long_opts opts_table [] =
		{
		  /* Please keep this table alpha- sorted.  */
		  { "Ranges", & do_debug_ranges },
		  { "abbrev", & do_debug_abbrevs },
		  { "aranges", & do_debug_aranges },
		  { "frames", & do_debug_frames },
		  { "frames-interp", & do_debug_frames_interp },
		  { "info", & do_debug_info },
		  { "line", & do_debug_lines }, /* For backwards compatibility.  */
		  { "rawline", & do_debug_lines },
		  { "decodedline", & do_debug_lines_decoded },
		  { "loc",  & do_debug_loc },
		  { "macro", & do_debug_macinfo },
		  { "pubnames", & do_debug_pubnames },
		  /* This entry is for compatability
		     with earlier versions of readelf.  */
		  { "ranges", & do_debug_aranges },
		  { "str", & do_debug_str },
		  { NULL, NULL }
		};

	      const char *p;

d3054 1
a3054 36

	      p = optarg;
	      while (*p)
		{
		  debug_dump_long_opts * entry;

		  for (entry = opts_table; entry->option; entry++)
		    {
		      size_t len = strlen (entry->option);

		      if (strneq (p, entry->option, len)
			  && (p[len] == ',' || p[len] == '\0'))
			{
			  * entry->variable = 1;

			  /* The --debug-dump=frames-interp option also
			     enables the --debug-dump=frames option.  */
			  if (do_debug_frames_interp)
			    do_debug_frames = 1;

			  p += len;
			  break;
			}
		    }

		  if (entry->option == NULL)
		    {
		      warn (_("Unrecognized debug option '%s'\n"), p);
		      p = strchr (p, ',');
		      if (p == NULL)
			break;
		    }

		  if (*p == ',')
		    p++;
		}
d4168 1
a4168 1
		|| do_debug_lines || do_debug_lines_decoded || do_debug_pubnames
d4182 1
a4182 2
	      || ((do_debug_lines || do_debug_lines_decoded)
		  && streq (name, "line"))
@


1.435
log
@2009-02-03  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/9784
	* NEWS: Mention --prefix=PREFIX and --prefix-strip=LEVEL.

	* doc/binutils.texi: Document --prefix=PREFIX and
	--prefix-strip=LEVEL.

	* objdump.c: Include "filenames.h".
	(prefix): New.
	(prefix_strip): Likewise.
	(prefix_length): Likewise.
	(usage): Add --prefix=PREFIX and --prefix-strip=LEVEL.
	(option_values): Add OPTION_PREFIX and OPTION_PREFIX_STRIP.
	(long_options): Likewise.
	(show_line): Handle prefix and prefix_strip.
	(main): Handle OPTION_PREFIX and OPTION_PREFIX_STRIP.

	* readelf.c (PATH_MAX): Moved to ...
	* sysdep.h: Here.
@
text
@d2216 1
@


1.434
log
@Add LM32 port.
@
text
@a52 19
/* For PATH_MAX.  */
#ifdef HAVE_LIMITS_H
#include <limits.h>
#endif

#ifndef PATH_MAX
/* For MAXPATHLEN.  */
# ifdef HAVE_SYS_PARAM_H
#  include <sys/param.h>
# endif
# ifndef PATH_MAX
#  ifdef MAXPATHLEN
#   define PATH_MAX MAXPATHLEN
#  else
#   define PATH_MAX 1024
#  endif
# endif
#endif

@


1.433
log
@Remove STT_IFUNC support.
@
text
@d133 1
d602 1
d1191 4
d1842 1
d8092 2
@


1.432
log
@2008-12-09  Andrew Stubbs  <ams@@codesourcery.com>

	* readelf.c (arm_attr_tag_CPU_arch): Add "v6-M" and "v6S-M".
	(arm_attr_tag_WMMX_arch): Add "WMMXv2".
	(arm_attr_tag_NEON_arch): Rename to ...
	(arm_attr_tag_Advanced_SIMD_arch): ... official name.
	(arm_attr_tag_ABI_PCS_config): Rename to ...
	(arm_attr_tag_PCS_config): ... official name.
	(arm_attr_tag_ABI_PCS_RO_DATA): Rename to ...
	(arm_attr_tag_ABI_PCS_RO_data): ... official name.
	(arm_attr_tag_ABI_FP_denormal): Add "Sign only".
	(arm_attr_tag_CPU_unaligned_access): New array.
	(arm_attr_tag_T2EE_use): New array.
	(arm_attr_tag_Virtualization_use): New array.
	(arm_attr_tag_MPextension_use): New array.
	(arm_attr_publ): NEON_arch -> Advanced_SIMD_arch.
	ABI_PCS_config -> PCS_config.
	ABI_PCS_RO_DATA -> ABI_PCS_RO_data.
	Add CPU_unaligned_access, nodefaults, also_compatible_with,
	T2EE_use, conformance, Virtualization_use and MPextension_use.
	(display_arm_attribute): Handle Tag_nodefaults and
	Tag_also_compatible_with.
@
text
@d1254 1
a1254 29
	      if (ELF_ST_TYPE (psym->st_info) == STT_IFUNC)
		{
		  const char * name;
		  unsigned int len;
		  unsigned int width = is_32bit_elf ? 8 : 14;

		  /* Relocations against IFUNC symbols do not use the value of
		     the symbol as the address to relocate against.  Instead
		     they invoke the function named by the symbol and use its
		     result as the address for relocation.

		     To indicate this to the user, do not display the value of
		     the symbol in the "Symbols's Value" field.  Instead show
		     its name followed by () as a hint that the symbol is
		     invoked.  */

		  if (strtab == NULL
		      || psym->st_name == 0
		      || psym->st_name >= strtablen)
		    name = "??";
		  else
		    name = strtab + psym->st_name;

		  len = print_symbol (width, name);
		  printf ("()%-*s", len <= width ? (width + 1) - len : 1, " ");
		}
	      else
		{
		  print_vma (psym->st_value, LONG_HEX);
d1256 1
a1256 2
		  printf (is_32bit_elf ? "   " : " ");
		}
a7038 8
	  else if (elf_header.e_ident[EI_OSABI] == ELFOSABI_LINUX
		   || elf_header.e_ident[EI_OSABI] == ELFOSABI_HURD
		   /* GNU/Linux is still using the default value 0.  */
		   || elf_header.e_ident[EI_OSABI] == ELFOSABI_NONE)
	    {
	      if (type == STT_IFUNC)
		return "IFUNC";
	    }
@


1.431
log
@* objdump.c (dump_reloc_set): Append "()" to symbol names which
  have the BSF_INDIRECT_FUNCTION type.
  * readelf.c (print_symbol): Fix handling of negative widths.
  (dump_relocations): Append "()" to symbol names which have the
  STT_IFUNC type. Display negative offsets as a positive number with
  a "-" prefix.
  (get_symbol_type): Return "IFUNC" for STT_IFUNC symbols.
  * doc/binutils.texi: Document 'i' symbol type.
@
text
@d8797 1
a8797 1
   "v6K", "v7"};
d8803 3
a8805 3
static const char *arm_attr_tag_WMMX_arch[] = {"No", "WMMXv1"};
static const char *arm_attr_tag_NEON_arch[] = {"No", "NEONv1"};
static const char *arm_attr_tag_ABI_PCS_config[] =
d8812 1
a8812 1
static const char *arm_attr_tag_ABI_PCS_RO_DATA[] =
d8819 2
a8820 1
static const char *arm_attr_tag_ABI_FP_denormal[] = {"Unused", "Needed"};
d8842 1
d8847 4
d8864 2
a8865 2
  LOOKUP(12, NEON_arch),
  LOOKUP(13, ABI_PCS_config),
d8868 1
a8868 1
  LOOKUP(16, ABI_PCS_RO_DATA),
d8885 1
d8888 6
d8973 22
@


1.430
log
@Add support for ARM half-precision conversion instructions.
@
text
@d417 1
a417 7
/* Display a symbol on stdout.  Handles the display of
   non-printing characters.
   If DO_WIDE is not true then format the symbol to be
   at most WIDTH characters, truncating as necessary.
   If WIDTH is negative then format the string to be
   exactly - WIDTH characters, truncating or padding
   as necessary.  */
d419 7
a425 1
static void
a427 1
  const char * format_string;
d429 2
a433 1
      format_string = "%.*s";
a438 1
      format_string = "%-*.*2s";
d441 1
a441 4
    }
  else
    {
      format_string = "%-.*s";
d463 1
a463 1
	  printf (format_string, len, symbol);
d466 1
d482 1
d492 1
d497 9
d1253 33
a1285 2
	      print_vma (psym->st_value, LONG_HEX);
	      printf (is_32bit_elf ? "   " : " ");
d1336 8
a1343 1
		printf (" + %lx", (unsigned long) rels[i].r_addend);
d7068 8
@


1.429
log
@        * readelf.c: Tidy up code formatting.
@
text
@d8787 4
d8824 3
a8826 1
  {32, "compatibility", 0, NULL}
@


1.428
log
@include/elf/
	* ppc.h: Add Tag_GNU_Power_ABI_Struct_Return.
bfd/
	* elf32-ppc.c (ppc_elf_merge_obj_attributes): Merge
	Tag_GNU_Power_ABI_Struct_Return.
binutils/
	* readelf.c (display_power_gnu_attribute): Decode
	Tag_GNU_Power_ABI_Struct_Return.
ld/testsuite/
	* ld-powerpc/gnu-attr-12-1.s: New file.
	* ld-powerpc/gnu-attr-12-2.s: New file.
	* ld-powerpc/gnu-attr-12-11.d: New file.
	* ld-powerpc/gnu-attr-12-21.d: New file.
	* ld-powerpc/powerpc.exp: Run new dump tests.
@
text
@d53 1
a53 1
/* for PATH_MAX */
d59 1
a59 1
/* for MAXPATHLEN */
d376 1
d466 1
a466 1
	  
d490 1
a490 1
	  
d1276 1
a1276 1
			       && (elf_header.e_ident[EI_OSABI] 
d1827 1
a1827 1
    case EM_CR16:		
d4283 2
a4284 2
		|| do_debug_lines || do_debug_lines_decoded || do_debug_pubnames 
		|| do_debug_aranges || do_debug_frames || do_debug_macinfo 
d4297 1
a4297 1
	      || ((do_debug_lines || do_debug_lines_decoded) 
d8032 1
a8032 1
    case EM_AVR_OLD: 
d8297 2
a8298 4
    case EM_68K:
      return reloc_type == 0; /* R_68K_NONE.  */
    case EM_386:
      return reloc_type == 0; /* R_386_NONE.  */
d8301 9
a8309 18
    case EM_SPARC:
      return reloc_type == 0; /* R_SPARC_NONE.  */
    case EM_MIPS:
      return reloc_type == 0; /* R_MIPS_NONE.  */
    case EM_PARISC:
      return reloc_type == 0; /* R_PARISC_NONE.  */
    case EM_ALPHA:
      return reloc_type == 0; /* R_ALPHA_NONE.  */
    case EM_PPC:
      return reloc_type == 0; /* R_PPC_NONE.  */
    case EM_PPC64:
      return reloc_type == 0; /* R_PPC64_NONE.  */
    case EM_ARM:
      return reloc_type == 0; /* R_ARM_NONE.  */
    case EM_IA_64:
      return reloc_type == 0; /* R_IA64_NONE.  */
    case EM_SH:
      return reloc_type == 0; /* R_SH_NONE.  */
d8311 6
a8316 10
    case EM_S390:
      return reloc_type == 0; /* R_390_NONE.  */
    case EM_CRIS:
      return reloc_type == 0; /* R_CRIS_NONE.  */
    case EM_X86_64:
      return reloc_type == 0; /* R_X86_64_NONE.  */
    case EM_MN10300:
      return reloc_type == 0; /* R_MN10300_NONE.  */
    case EM_M32R:
      return reloc_type == 0; /* R_M32R_NONE.  */
d8322 1
a8322 1
 * This is a copy of bfd_uncompress_section_contents, in bfd/compress.c  */
d8334 1
a8334 1
  unsigned char* compressed_buffer = *buffer;
d8336 1
a8336 1
  unsigned char* uncompressed_buffer;
d8344 1
a8344 1
      || ! streq ((char*) compressed_buffer, "ZLIB"))
d8346 1
d8362 1
a8362 1
  strm.next_in = (Bytef*) compressed_buffer + header_size;
d8366 1
a8366 1
  rc = inflateInit (&strm);
d8371 1
a8371 1
      strm.next_out = ((Bytef*) uncompressed_buffer
d8376 1
a8376 1
      rc = inflateReset (&strm);
d8378 1
a8378 1
  rc = inflateEnd (&strm);
d8507 1
a8507 1
	  
d10694 1
a10694 1
	  index_array = malloc (index_num * sizeof (* index_array));	  
d10728 1
a10728 1
	    }	  
d10850 1
a10850 1
		  break;			 
@


1.427
log
@        * readelf.c (process_section_headers): Do not cut the section names and
        types if running with --wide.

        * ld-ia64/tlsbin.rd: Update expected output now that --wide does
        not truncate section names.
        * ld-ia64/tlspic.rd: Likewise.
@
text
@d9066 23
@


1.426
log
@bfd/
	PR 6893 - Do not consider FDEs for discarded sections as invalid.
	* elf-eh-frame.c (_bfd_elf_parse_eh_frame): New REQUIRE_CLEARED_RELOCS.
	Consider FDEs with cleared relocations as valid and ignorable.

ld/testsuite/
	* ld-elf/eh-group.exp, ld-elf/eh-group1.s, ld-elf/eh-group2.s: New test.

binutils/
	Suppress warnings on NONE relocations to discarded sections.
	* readelf.c (is_none_reloc): New function.
	(debug_apply_relocations): Ignore is_none_reloc() relocations.
@
text
@d4378 2
a4379 1
	printf ("  [%2u] %-17.17s %-15.15s ",
@


1.425
log
@	* readelf.c (load_specific_debug_section): New function, from
	load_debug_section.
	(load_debug_section): Use load_specific_debug_section.
	(display_debug_section): Use load_specific_debug_section.  Check for
	multiple sections with the same name.
@
text
@d8287 47
d8469 3
@


1.425.2.1
log
@bfd/
	PR 6893 - Do not consider FDEs for discarded sections as invalid.
	* elf-eh-frame.c (_bfd_elf_parse_eh_frame): New REQUIRE_CLEARED_RELOCS.
	Consider FDEs with cleared relocations as valid and ignorable.

ld/testsuite/
	* ld-elf/eh-group.exp, ld-elf/eh-group1.s, ld-elf/eh-group2.s: New test.

binutils/
	Suppress warnings on NONE relocations to discarded sections.
	* readelf.c (is_none_reloc): New function.
	(debug_apply_relocations): Ignore is_none_reloc() relocations.
@
text
@a8286 47
/* Returns TRUE iff RELOC_TYPE is a NONE relocation used for discarded
   relocation entries (possibly formerly used for SHT_GROUP sections).  */

static bfd_boolean
is_none_reloc (unsigned int reloc_type)
{
  switch (elf_header.e_machine)
    {
    case EM_68K:
      return reloc_type == 0; /* R_68K_NONE.  */
    case EM_386:
      return reloc_type == 0; /* R_386_NONE.  */
    case EM_SPARC32PLUS:
    case EM_SPARCV9:
    case EM_SPARC:
      return reloc_type == 0; /* R_SPARC_NONE.  */
    case EM_MIPS:
      return reloc_type == 0; /* R_MIPS_NONE.  */
    case EM_PARISC:
      return reloc_type == 0; /* R_PARISC_NONE.  */
    case EM_ALPHA:
      return reloc_type == 0; /* R_ALPHA_NONE.  */
    case EM_PPC:
      return reloc_type == 0; /* R_PPC_NONE.  */
    case EM_PPC64:
      return reloc_type == 0; /* R_PPC64_NONE.  */
    case EM_ARM:
      return reloc_type == 0; /* R_ARM_NONE.  */
    case EM_IA_64:
      return reloc_type == 0; /* R_IA64_NONE.  */
    case EM_SH:
      return reloc_type == 0; /* R_SH_NONE.  */
    case EM_S390_OLD:
    case EM_S390:
      return reloc_type == 0; /* R_390_NONE.  */
    case EM_CRIS:
      return reloc_type == 0; /* R_CRIS_NONE.  */
    case EM_X86_64:
      return reloc_type == 0; /* R_X86_64_NONE.  */
    case EM_MN10300:
      return reloc_type == 0; /* R_MN10300_NONE.  */
    case EM_M32R:
      return reloc_type == 0; /* R_M32R_NONE.  */
    }
  return FALSE;
}

a8421 3
	  if (is_none_reloc (reloc_type))
	    continue;

@


1.425.2.2
log
@backport 2008-10-10  Nathan Froyd  <froydnj@@codesourcery.com>
@
text
@a9064 23
  if (tag == Tag_GNU_Power_ABI_Struct_Return)
    {
      val = read_uleb128 (p, &len);
      p += len;
      printf ("  Tag_GNU_Power_ABI_Struct_Return: ");
      switch (val)
       {
       case 0:
         printf ("Any\n");
         break;
       case 1:
         printf ("r3/r4\n");
         break;
       case 2:
         printf ("Memory\n");
         break;
       default:
         printf ("??? (%d)\n", val);
         break;
       }
      return p;
    }

@


1.424
log
@        * readelf.c (is_32bit_pcrel_reloc): Fix hppa entry.
        (is_64bit_pcrel_reloc): New.
        (debug_apply_relocations): Use it.  Handle hppa pcrel bias.
@
text
@d8489 3
a8491 2
int
load_debug_section (enum dwarf_section_display_enum debug, void *file)
a8493 1
  Elf_Internal_Shdr *sec;
a8500 12
  /* Locate the debug section.  */
  sec = find_section (section->uncompressed_name);
  if (sec != NULL)
    section->name = section->uncompressed_name;
  else
    {
      sec = find_section (section->compressed_name);
      if (sec != NULL)
	section->name = section->compressed_name;
    }
  if (sec == NULL)
    return 0;
d8521 22
d8581 4
d8586 5
a8590 1
	if (load_debug_section (i, file))
d8594 1
a8594 1
	    if (i != info && i != abbrev)
@


1.423
log
@2008-08-08  Richard Sandiford  <rdsandiford@@googlemail.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>
	    Catherine Moore  <clm@@codesourcery.com>
	    Mark Shinwell  <shinwell@@codesourcery.com>
	    Maxim Kuvyrkov  <maxim@@codesourcery.com>

	* elf32-mips.c (mips_vxworks_copy_howto_rela): Replace with...
	(elf_mips_copy_howto): ...this howto.  Clear the size fields.
	(mips_vxworks_jump_slot_howto_rela): Replace with...
	(elf_mips_jump_slot_howto): ...this howto.
	(bfd_elf32_bfd_reloc_type_lookup): Handle BFD_RELOC_MIPS_COPY
	and BFD_RELOC_MIPS_JUMP_SLOT.
	(bfd_elf32_bfd_reloc_name_lookup): Handle "R_MIPS_COPY" and
	"R_MIPS_JUMP_SLOT".
	(mips_elf32_rtype_to_howto): Handle R_MIPS_COPY and R_MIPS_JUMP_SLOT.
	(elf_backend_plt_readonly): Define.
	(elf_backend_plt_sym_val): Define for non-VxWorks targets.
	(mips_vxworks_bfd_reloc_type_lookup): Delete.
	(mips_vxworks_bfd_reloc_name_lookup): Likewise.
	(mips_vxworks_rtype_to_howto): Likewise.
	(elf_backend_want_dynbss): Don't define for VxWorks.
	(elf_backend_plt_readonly): Likewise.
	(bfd_elf32_bfd_reloc_type_lookup): Likewise.
	(bfd_elf32_bfd_reloc_name_lookup): Likewise.
	(elf_backend_mips_rtype_to_howto): Likewise.
	(elf_backend_adjust_dynamic_symbol): Likewise.
	(elf_backend_got_symbol_offset): Don't define.
	* elfn32-mips.c (elf_mips_copy_howto, elf_mips_jump_slot_howto): New.
	(bfd_elf32_bfd_reloc_type_lookup): Handle BFD_RELOC_MIPS_COPY
	and BFD_RELOC_MIPS_JUMP_SLOT.
	(bfd_elf32_bfd_reloc_name_lookup): Handle "R_MIPS_COPY" and
	"R_MIPS_JUMP_SLOT".
	(mips_elf32_n32_rtype_to_howto): Handle R_MIPS_COPY and
	R_MIPS_JUMP_SLOT.
	(elf_backend_rela_plts_and_copies_p, elf_backend_plt_readonly)
	(elf_backend_plt_sym_val): Define.
	* elf64-mips.c (elf_mips_copy_howto, elf_mips_jump_slot_howto): New.
	(bfd_elf64_bfd_reloc_type_lookup): Handle BFD_RELOC_MIPS_COPY
	and BFD_RELOC_MIPS_JUMP_SLOT.
	(bfd_elf64_bfd_reloc_name_lookup): Handle "R_MIPS_COPY" and
	"R_MIPS_JUMP_SLOT".
	(mips_elf64_rtype_to_howto): Handle R_MIPS_COPY and R_MIPS_JUMP_SLOT.
	(elf_backend_rela_plts_and_copies_p, elf_backend_plt_readonly)
	(elf_backend_plt_sym_val): Define.
	* elfxx-mips.h (_bfd_mips_vxworks_adjust_dynamic_symbol): Delete.
	(_bfd_mips_elf_use_plts_and_copy_relocs, _bfd_mips_elf_init_stubs)
	(_bfd_mips_elf_plt_sym_val, _bfd_mips_post_process_headers): Declare.
	* elfxx-mips.c (mips_elf_la25_stub): New structure.
	(LA25_LUI, LA25_J, LA25_ADDIU): New macros.
	(mips_elf_link_hash_entry): Add "la25_stubs", "has_static_relocs"
	and "has_nonpic_branches" fields.  Remove "is_relocation_target" and
	"is_branch_target".
	(mips_elf_link_hash_table): Add blank lines.  Add
	"use_plts_and_copy_relocs", "reserved_gotno", "strampoline",
	"la25_stubs" and "add_stub_section" fields.
	(mips_htab_traverse_info): New structure.
	(PIC_OBJECT_P, MIPS_ELF_LOAD_WORD): New macros.
	(MIPS_RESERVED_GOTNO): Delete.
	(mips_o32_exec_plt0_entry, mips_n32_exec_plt0_entry)
	(mips_n64_exec_plt0_entry, mips_exec_plt_entry): New tables.
	(mips_elf_link_hash_newfunc): Update after the changes to
	mips_elf_link_hash_entry.
	(mips_elf_check_mips16_stubs): Replace the DATA parameter with
	an INFO parameter.  Don't look through warnings symbols here;
	do it in mips_elf_check_symbols instead.
	(mips_elf_create_stub_symbol): New function.
	(mips_elf_la25_stub_hash, mips_elf_la25_stub_eq): New functions.
	(_bfd_mips_elf_init_stubs, mips_elf_local_pic_function_p): Likewise.
	(mips_elf_add_la25_intro, mips_elf_add_la25_trampoline): Likewise.
	(mips_elf_add_la25_stub, mips_elf_check_symbols): New functions.
	(mips_elf_gotplt_index): Check for VxWorks.
	(mips_elf_output_dynamic_relocation): Take the relocation index
	as an extra parameter.  Do not increment reloc_count here.
	(mips_elf_initialize_tls_slots): Update the calls to
	mips_elf_output_dynamic_relocation accordingly.
	(mips_elf_multi_got): Use htab->reserved_gotno instead of
	MIPS_RESERVED_GOTNO.
	(mips_elf_create_got_section): Don't allocate reserved GOT
	entries here.  Unconditionally create .got.plt, but don't
	set its alignment here.
	(mips_elf_relocation_needs_la25_stub): New function.
	(mips_elf_calculate_relocation): Redirect branches and jumps to
	a non-PIC stub if one exists.  Check !h->has_static_relocs instead
	of !htab->is_vxworks when deciding whether to create dynamic
	relocations for R_MIPS_32, R_MIPS_REL32 and R_MIPS_64.
	(_bfd_mips_elf_create_dynamic_sections): Unconditionally call
	_bfd_elf_create_dynamic_sections.  Unconditionally set up
	htab->splt and htab->sdynbss.  Set htab->srelplt to ".rel.plt"
	if !htab->is_vxworks.  Add non-VxWorks values of
	htab->plt_header_size and htab->plt_entry_size.
	(_bfd_mips_elf_check_relocs): Set pointer_equality_needed for
	non-branch static relocations.  Set has_nonpic_branches when an la25
	stub might be required.  Set can_make_dynamic_p to TRUE if R_MIPS_32,
	R_MIPS_REL32 and R_MIPS_64 relocations can be made dynamic,
	rather than duplicating the condition.  Do not make them dynamic
	for read-only sections in non-PIC executable objects.
	Do not protect this code with dynobj == NULL || htab->sgot == NULL;
	handle each group of cases separately.  Add a default case that
	sets has_static_relocs for non-GOT relocations that cannot be
	made dynamic.  Don't set is_relocation_target and is_branch_target.
	Reject non-PIC static relocations in shared objects.
	(_bfd_mips_vxworks_adjust_dynamic_symbol): Fold into...
	(_bfd_mips_elf_adjust_dynamic_symbol): ...here, using
	htab->use_plts_and_copy_relocs instead of htab->is_vxworks
	to select PLT and copy-reloc handling.  Set the alignment of
	.plt and .got.plt when allocating the first entry.  Generalize
	code to handle REL as well as RELA sections and 64-bit as well as
	32-bit GOT entries.  Complain if we find a static-only reloc
	against an externally-defined symbol and if we cannot create
	dynamic relocations for it.  Allocate copy relocs using
	mips_elf_allocate_dynamic_relocations on non-VxWorks targets.
	Set possibly_dynamic_relocs to 0 when using PLTs or copy relocs.
	Skip reserved .got.plt entries.
	(_bfd_mips_elf_always_size_sections): Use mips_elf_check_symbols
	instead of mips_elf_check_mips16_stubs to process each symbol.
	Do the traversal for relocatable objects too.
	(mips_elf_lay_out_got): Use htab->reserved_gotno instead of
	MIPS_RESERVED_GOTNO.
	(_bfd_mips_elf_size_dynamic_sections): Exclude sdynbss if it
	is empty.  Extend the DT_PLTREL, DT_JMPREL and DT_PLTRELSZ handling
	to non-VxWorks targets.  Only add DT_REL{,A}, DT_REL{,A}SZ and
	DT_REL{,A}ENT if .rel.dyn is nonempty.  Create a symbol for the
	PLT.  Allocate a nop at the end of the PLT.  Allocate DT_MIPS_PLTGOT.
	(mips_elf_create_la25_stub_info): New function.
	(_bfd_mips_elf_finish_dynamic_symbol): Write out PLT entries
	and copy relocs where necessary.  Check pointer_equality_needed.
	(mips_finish_exec_plt): New function.
	(_bfd_mips_elf_finish_dynamic_sections): Always set DT_PLTGOT
	to the beginning of htab->sgot.  Use htab->reserved_gotno instead
	of MIPS_RESERVED_GOTNO.  Assert htab->use_plts_and_copy_relocs
	instead of htab->is_vxworks for DT_PLTREL, DT_PLTRELSZ and DT_JMPREL.
	Set DT_PLTREL to DT_REL instead of DT_RELA on non-VxWorks targets.
	Use mips_finish_exec_plt to create non-VxWorks PLT headers.  Set
	DT_MIPS_PLTGOT.
	(_bfd_mips_elf_copy_indirect_symbol): Copy has_static_relocs
	from the indirect symbol to the direct symbol.  Also copy
	has_nonpic_branches for indirect symbols.
	(_bfd_mips_elf_get_target_dtag): Handle DT_MIPS_PLTGOT and
	DT_MIPS_RWPLT.
	(_bfd_mips_elf_link_hash_table_create): Initialize the new
	mips_elf_link_hash_table fields.
	(_bfd_mips_vxworks_link_hash_table_create): Set
	use_plts_and_copy_relocs to TRUE.  Use TRUE rather than 1
	when setting is_vxworks.
	(_bfd_mips_elf_use_plts_and_copy_relocs): New function.
	(_bfd_mips_elf_final_link): Call mips_elf_create_la25_stub for
	each la25_stub.
	(_bfd_mips_elf_merge_private_bfd_data): Treat dynamic objects
	as PIC.  Generalize message about linking PIC and non-PIC.
	(_bfd_mips_elf_plt_sym_val, _bfd_mips_post_process_headers): New
	functions.
	* reloc.c: Update comment near BFD_RELOC_MIPS_JUMP_SLOT.
	* bfd-in2.h: Regenerated.

2008-08-08  Richard Sandiford  <rdsandiford@@googlemail.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>
	    Catherine Moore  <clm@@codesourcery.com>
	    Mark Shinwell  <shinwell@@codesourcery.com>

	* readelf.c (get_mips_symbol_other): Handle STO_MIPS_PLT and
	STO_MIPS_PIC.
	(slurp_rela_relocs, slurp_rel_relocs): Handle MIPS ELF64 here.
	(dump_relocations, debug_apply_relocations): Don't handle it here.
	(get_mips_dynamic_type): Handle DT_MIPS_PLTGOT and DT_MIPS_RWPLT.
	(print_mips_pltgot_entry): New function.
	(process_mips_specific): Dump the PLT GOT.

2008-08-08  Richard Sandiford  <rdsandiford@@googlemail.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* config/tc-mips.c (OPTION_CALL_NONPIC): New macro.
	(OPTION_NON_SHARED, OPTION_XGOT, OPTION_MABI, OPTION_32)
	(OPTION_N32, OPTION_64, OPTION_MDEBUG, OPTION_NO_MDEBUG)
	(OPTION_PDR, OPTION_NO_PDR, OPTION_MVXWORKS_PIC): Bump by 1.
	(md_longopts): Add -call_nonpic.
	(md_parse_option): Handle OPTION_CALL_NONPIC.
	(md_show_usage): Add -call_nonpic.

2008-08-08  Richard Sandiford  <rdsandiford@@googlemail.com>

	* gas/mips/call-nonpic-1.s, gas/mips/call-nonpic-1.d: New test.
	* gas/mips/mips.exp: Run it.

2008-08-08  Richard Sandiford  <rdsandiford@@googlemail.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>
	    Catherine Moore  <clm@@codesourcery.com>
	    Mark Shinwell  <shinwell@@codesourcery.com>

	* mips.h (STO_MIPS_PLT, ELF_ST_IS_MIPS_PLT, ELF_ST_SET_MIPS_PLT)
	(STO_MIPS_PIC, DT_MIPS_PLTGOT, DT_MIPS_RWPLT): New macros.

2008-08-08  Richard Sandiford  <rdsandiford@@googlemail.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* emulparams/elf32bmip.sh (GOT): Define, moving .got.plt to...
	(OTHER_RELRO_SECTIONS, OTHER_READWRITE_SECTIONS): ...one of these
	two variables.
	* emulparams/elf32bmipn32-defs.sh: Likewise.
	* emultempl/mipself.em: Include ldctor.h, elf/mips.h and elfxx-mips.h.
	(is_mips_elf): New macro.
	(stub_file, stub_bfd): New variables.
	(hook_stub_info): New structure.
	(hook_in_stub): New function.
	(mips_add_stub_section): Likewise.
	(mips_create_output_section_statements): Likewise.
	(mips_before_allocation): Likewise.
	(real_func): New variable.
	(mips_for_each_input_file_wrapper): New function.
	(mips_lang_for_each_input_file): Likewise.
	(lang_for_each_input_file): Define.
	(LDEMUL_BEFORE_ALLOCATION): Likewise.
	(LDEMUL_CREATE_OUTPUT_SECTION_STATEMENTS): Likewise.

2008-08-08  Richard Sandiford  <rdsandiford@@googlemail.com>
	    Daniel Jacobowitz  <dan@@codesourcery.com>

	* ld-mips-elf/mips16-pic-3a.s,
	ld-mips-elf/mips16-pic-3b.s,
	ld-mips-elf/mips16-pic-3.dd,
	ld-mips-elf/mips16-pic-3.gd,
	ld-mips-elf/mips16-pic-3.rd,
	ld-mips-elf/mips16-pic-3.inc,
	ld-mips-elf/pic-and-nonpic-1a.s,
	ld-mips-elf/pic-and-nonpic-1b.s,
	ld-mips-elf/pic-and-nonpic-1.ld,
	ld-mips-elf/pic-and-nonpic-1.dd,
	ld-mips-elf/pic-and-nonpic-1.nd,
	ld-mips-elf/pic-and-nonpic-1-rel.dd,
	ld-mips-elf/pic-and-nonpic-1-rel.nd,
	ld-mips-elf/pic-and-nonpic-2a.s,
	ld-mips-elf/pic-and-nonpic-2b.s,
	ld-mips-elf/pic-and-nonpic-2.d,
	ld-mips-elf/pic-and-nonpic-3a.s,
	ld-mips-elf/pic-and-nonpic-3a.ld,
	ld-mips-elf/pic-and-nonpic-3a.dd,
	ld-mips-elf/pic-and-nonpic-3a.gd,
	ld-mips-elf/pic-and-nonpic-3a.sd,
	ld-mips-elf/pic-and-nonpic-3b.s,
	ld-mips-elf/pic-and-nonpic-3b.ld,
	ld-mips-elf/pic-and-nonpic-3b.ad,
	ld-mips-elf/pic-and-nonpic-3b.dd,
	ld-mips-elf/pic-and-nonpic-3b.gd,
	ld-mips-elf/pic-and-nonpic-3b.nd,
	ld-mips-elf/pic-and-nonpic-3b.pd,
	ld-mips-elf/pic-and-nonpic-3b.rd,
	ld-mips-elf/pic-and-nonpic-3b.sd,
	ld-mips-elf/pic-and-nonpic-3-error.d,
	ld-mips-elf/pic-and-nonpic-4a.s,
	ld-mips-elf/pic-and-nonpic-4b.s,
	ld-mips-elf/pic-and-nonpic-4b.ld,
	ld-mips-elf/pic-and-nonpic-4b.ad,
	ld-mips-elf/pic-and-nonpic-4b.dd,
	ld-mips-elf/pic-and-nonpic-4b.gd,
	ld-mips-elf/pic-and-nonpic-4b.nd,
	ld-mips-elf/pic-and-nonpic-4b.rd,
	ld-mips-elf/pic-and-nonpic-4b.sd,
	ld-mips-elf/pic-and-nonpic-4-error.d,
	ld-mips-elf/pic-and-nonpic-5a.s,
	ld-mips-elf/pic-and-nonpic-5b.s,
	ld-mips-elf/pic-and-nonpic-5b.ld,
	ld-mips-elf/pic-and-nonpic-5b.ad,
	ld-mips-elf/pic-and-nonpic-5b.dd,
	ld-mips-elf/pic-and-nonpic-5b.gd,
	ld-mips-elf/pic-and-nonpic-5b.nd,
	ld-mips-elf/pic-and-nonpic-5b.rd,
	ld-mips-elf/pic-and-nonpic-5b.sd,
	ld-mips-elf/pic-and-nonpic-5b.pd,
	ld-mips-elf/pic-and-nonpic-6.ld,
	ld-mips-elf/pic-and-nonpic-6-o32a.s,
	ld-mips-elf/pic-and-nonpic-6-o32b.s,
	ld-mips-elf/pic-and-nonpic-6-o32c.s,
	ld-mips-elf/pic-and-nonpic-6-o32.ad,
	ld-mips-elf/pic-and-nonpic-6-o32.dd,
	ld-mips-elf/pic-and-nonpic-6-o32.gd,
	ld-mips-elf/pic-and-nonpic-6-o32.nd,
	ld-mips-elf/pic-and-nonpic-6-o32.pd,
	ld-mips-elf/pic-and-nonpic-6-o32.rd,
	ld-mips-elf/pic-and-nonpic-6-o32.sd,
	ld-mips-elf/pic-and-nonpic-6-n32a.s,
	ld-mips-elf/pic-and-nonpic-6-n32b.s,
	ld-mips-elf/pic-and-nonpic-6-n32c.s,
	ld-mips-elf/pic-and-nonpic-6-n32.ad,
	ld-mips-elf/pic-and-nonpic-6-n32.dd,
	ld-mips-elf/pic-and-nonpic-6-n32.gd,
	ld-mips-elf/pic-and-nonpic-6-n32.nd,
	ld-mips-elf/pic-and-nonpic-6-n32.pd,
	ld-mips-elf/pic-and-nonpic-6-n32.rd,
	ld-mips-elf/pic-and-nonpic-6-n32.sd,
	ld-mips-elf/pic-and-nonpic-6-n64a.s,
	ld-mips-elf/pic-and-nonpic-6-n64b.s,
	ld-mips-elf/pic-and-nonpic-6-n64c.s,
	ld-mips-elf/pic-and-nonpic-6-n64.ad,
	ld-mips-elf/pic-and-nonpic-6-n64.dd,
	ld-mips-elf/pic-and-nonpic-6-n64.gd,
	ld-mips-elf/pic-and-nonpic-6-n64.nd,
	ld-mips-elf/pic-and-nonpic-6-n64.pd,
	ld-mips-elf/pic-and-nonpic-6-n64.rd,
	ld-mips-elf/pic-and-nonpic-6-n64.sd: New tests.
	* ld-mips-elf/mips-elf.exp: Run them.
@
text
@d8159 1
a8159 1
      return reloc_type == 0;  /* R_PARISC_NONE.  *//* FIXME: This reloc is generated, but it may be a bug.  */
d8222 30
d8425 2
a8426 1
	  else if (is_64bit_abs_reloc (reloc_type))
d8470 9
a8478 3
	  if (is_32bit_pcrel_reloc (reloc_type))
	    byte_put (loc, (addend + sym->st_value) - rp->r_offset,
		      reloc_size);
@


1.422
log
@	* readelf.c (is_64bit_abs_reloc): Return true for R_MIPS_64.
@
text
@d710 22
d804 22
a941 20
      /* The #ifdef BFD64 below is to prevent a compile time warning.
	 We know that if we do not have a 64 bit data type that we
	 will never execute this code anyway.  */
#ifdef BFD64
      if (!is_32bit_elf
	  && elf_header.e_machine == EM_MIPS
	  && elf_header.e_ident[EI_DATA] != ELFDATA2MSB)
	{
	  /* In little-endian objects, r_info isn't really a 64-bit
	     little-endian value: it has a 32-bit little-endian
	     symbol index followed by four individual byte fields.
	     Reorder INFO accordingly.  */
	  info = (((info & 0xffffffff) << 32)
		  | ((info >> 56) & 0xff)
		  | ((info >> 40) & 0xff00)
		  | ((info >> 24) & 0xff0000)
		  | ((info >> 8) & 0xff000000));
	}
#endif /* BFD64 */

d1393 2
d7049 2
a8389 13
	  /* In MIPS little-endian objects, r_info isn't really a
	     64-bit little-endian value: it has a 32-bit little-endian
	     symbol index followed by four individual byte fields.
	     Reorder INFO accordingly.  */
	  if (!is_32bit_elf
	      && elf_header.e_machine == EM_MIPS
	      && elf_header.e_ident[EI_DATA] != ELFDATA2MSB)
	    rp->r_info = (((rp->r_info & 0xffffffff) << 32)
			  | ((rp->r_info >> 56) & 0xff)
			  | ((rp->r_info >> 40) & 0xff00)
			  | ((rp->r_info >> 24) & 0xff0000)
			  | ((rp->r_info >> 8) & 0xff000000));

d9222 22
d9253 2
d9256 2
d9293 2
a9294 1
	pltgot = entry->d_un.d_val;
d9304 12
d9748 67
@


1.421
log
@	* readelf.c (get_osabi_name <ELFOSABI_AROS>): Change name.
@
text
@d8187 2
@


1.420
log
@Silence gcc printf warnings
@
text
@d2372 1
a2372 1
    case ELFOSABI_AROS:		return "Amiga Research OS";
@


1.419
log
@	* readelf.c (print_vma): Typo fix.
@
text
@d313 1
a313 1
	     archive_file_offset + offset, reason);
d3672 1
a3672 1
	(long) vma);
d5689 1
a5689 1
      printf ("%#lx\n", (long) entry->d_un.d_ptr);
d9738 1
a9738 1
		  (long) (section->sh_size / sizeof (Elf32_External_Lib)));
d9998 1
a9998 1
		(long)((char *)external - (char *)pnotes));
@


1.418
log
@bfd/
	PR 6769
	* bfd-in.h (BFD_VMA_FMT): Define.
	(printf_vma, sprintf_vma): Use the above.
	(_bfd_int64_low, _bfd_int64_high): Delete.
	* bfd-in2.h: Regenerate.
binutils/
	PR 6769
	* readelf.c (print_dec_vma, print_hex_vma): Delete.
	(print_vma): Use BFD_VMA_FMT.
	* size.c (size_number, rprint_number): Likewise.
@
text
@d390 1
a390 1
	return nc + printf ("%08.8" BFD_VMA_FMT "x", vma);
@


1.417
log
@Support PowerPC single-precision float.
@
text
@d375 1
a375 1
#if defined BFD64 && !BFD_HOST_64BIT_LONG && !BFD_HOST_64BIT_LONG_LONG
d377 1
a377 1
print_dec_vma (bfd_vma vma, int is_signed)
a378 2
  char buf[40];
  char *bufp = buf;
d381 1
a381 28
  if (is_signed && (bfd_signed_vma) vma < 0)
    {
      vma = -vma;
      putchar ('-');
      nc = 1;
    }

  do
    {
      *bufp++ = '0' + vma % 10;
      vma /= 10;
    }
  while (vma != 0);
  nc += bufp - buf;

  while (bufp > buf)
    putchar (*--bufp);
  return nc;
}

static int
print_hex_vma (bfd_vma vma)
{
  char buf[32];
  char *bufp = buf;
  int nc;

  do
d383 3
a385 14
      char digit = '0' + (vma & 0x0f);
      if (digit > '9')
	digit += 'a' - '0' - 10;
      *bufp++ = digit;
      vma >>= 4;
    }
  while (vma != 0);
  nc = bufp - buf;

  while (bufp > buf)
    putchar (*--bufp);
  return nc;
}
#endif
d387 1
a387 4
/* Print a VMA value.  */
static int
print_vma (bfd_vma vma, print_mode mode)
{
d389 2
a390 1
  if (is_32bit_elf)
d392 2
a393 5
    {
      switch (mode)
	{
	case FULL_HEX:
	  return printf ("0x%8.8lx", (unsigned long) vma);
d395 8
a402 2
	case LONG_HEX:
	  return printf ("%8.8lx", (unsigned long) vma);
d404 2
a405 10
	case DEC_5:
	  if (vma <= 99999)
	    return printf ("%5ld", (long) vma);
	  /* Drop through.  */

	case PREFIX_HEX:
	  return printf ("0x%lx", (unsigned long) vma);

	case HEX:
	  return printf ("%lx", (unsigned long) vma);
d407 2
a408 2
	case DEC:
	  return printf ("%ld", (unsigned long) vma);
d410 2
a411 3
	case UNSIGNED:
	  return printf ("%lu", (unsigned long) vma);
	}
a412 85
#ifdef BFD64
  else
    {
      int nc = 0;

      switch (mode)
	{
	case FULL_HEX:
	  nc = printf ("0x");
	  /* Drop through.  */

	case LONG_HEX:
	  printf_vma (vma);
	  return nc + 16;

	case PREFIX_HEX:
	  nc = printf ("0x");
	  /* Drop through.  */

	case HEX:
#if BFD_HOST_64BIT_LONG
	  return nc + printf ("%lx", vma);
#elif BFD_HOST_64BIT_LONG_LONG
#ifndef __MSVCRT__
	  return nc + printf ("%llx", vma);
#else
	  return nc + printf ("%I64x", vma);
#endif
#else
	  return nc + print_hex_vma (vma);
#endif

	case DEC:
#if BFD_HOST_64BIT_LONG
	  return printf ("%ld", vma);
#elif BFD_HOST_64BIT_LONG_LONG
#ifndef __MSVCRT__
	  return printf ("%lld", vma);
#else
	  return printf ("%I64d", vma);
#endif
#else
	  return print_dec_vma (vma, 1);
#endif

	case DEC_5:
#if BFD_HOST_64BIT_LONG
	  if (vma <= 99999)
	    return printf ("%5ld", vma);
	  else
	    return printf ("%#lx", vma);
#elif BFD_HOST_64BIT_LONG_LONG
#ifndef __MSVCRT__
	  if (vma <= 99999)
	    return printf ("%5lld", vma);
	  else
	    return printf ("%#llx", vma);
#else
	  if (vma <= 99999)
	    return printf ("%5I64d", vma);
	  else
	    return printf ("%#I64x", vma);
#endif
#else
	  if (vma <= 99999)
	    return printf ("%5ld", _bfd_int64_low (vma));
	  else
	    return print_hex_vma (vma);
#endif

	case UNSIGNED:
#if BFD_HOST_64BIT_LONG
	  return printf ("%lu", vma);
#elif BFD_HOST_64BIT_LONG_LONG
#ifndef __MSVCRT__
	  return printf ("%llu", vma);
#else
	  return printf ("%I64u", vma);
#endif
#else
	  return print_dec_vma (vma, 0);
#endif
	}
    }
#endif
@


1.416
log
@	* bfd/elf-bfd.h: Declare elfcore_write_ppc_vsx.
	* bfd/elf.c (elfcore_grok_ppc_vsx): New function.
	(elfcore_write_ppc_vsx): New function
	(elfcore_grok_note): Handle VSX notes.
	(elfcore_write_register_note): Handle VSX notes.
	* include/elf/common.h: Define NT_PPC_VSX.
	* binutils/readelf.c (get_note_type): Handle VSX notes.
@
text
@d9040 3
@


1.415
log
@2008-07-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* objdump.c (load_debug_section): Initialize section_is_compressed
	for gcc 3.4/ia64.
	* readelf.c (load_debug_section): Likewise.
@
text
@d9932 2
@


1.414
log
@Revert my last change since it has not been approved.
@
text
@d8583 1
a8583 4
    {
      section->name = section->uncompressed_name;
      section_is_compressed = 0;
    }
d8588 1
a8588 4
        {
          section->name = section->compressed_name;
          section_is_compressed = 1;
        }
d8592 1
@


1.413
log
@	bfd/
	* elf.c (_bfd_elf_map_sections_to_segments): Don't put
	executable sections into the same segment with other
	read only sections if --sep-code.
	* elf32-bfin.c (elf32_bfin_code_in_l1): New variable.
	(elf32_bfin_data_in_l1): New variable.
	(elf32_bfin_final_write_processing): New.
	(elf32_bfin_special_sections[]): New.
	(elf_backend_final_write_processing): Define.
	(elf_backend_special_sections): Define.

	binutils/
	* readelf.c (get_machine_flags): Deal with Blackfin specific
	flags.

	include/
	* bfdlink.h (struct bfd_link_info): Add sep_code member
	variable.
	* elf/bfin.h (EF_BFIN_CODE_IN_L1): Define.
	(EF_BFIN_DATA_IN_L1): Define.

	ld/
	* Makefile.am (eelf32bfin.c): Depend on bfin.em.
	(eelf32bfinfd.c): Likewise.
	* Makefile.in: Regenerate.
	* gen-doc.texi: Set Blackfin.
	* ld.texinfo: Document --sep-code and Blackfin specific
	options.
	* ldmain.c (main): Initialize link_info.sep_code.
	* lexsup.c (enum option_values): Add OPTION_SEP_CODE.
	(ld_options[]): Add --sep-code.
	(parse_args): Deal with --sep-code.
	* emulparams/bfin.sh (EXTRA_EM_FILE): Define.
	* emulparams/elf32bfinfd.sh (OTHER_SECTIONS): Define.
	* emultempl/bfin.em: New file.
@
text
@a2142 15
	case EM_BLACKFIN:
	  if (e_flags & EF_BFIN_PIC)
	    strcat (buf, ", PIC");

	  if (e_flags & EF_BFIN_FDPIC)
	    strcat (buf, ", FDPIC");

	  if (e_flags & EF_BFIN_CODE_IN_L1)
	    strcat (buf, ", code in L1");

	  if (e_flags & EF_BFIN_DATA_IN_L1)
	    strcat (buf, ", data in L1");

	  break;

@


1.412
log
@bfd/
	* Makefile.am (BFD32_LIBS): Add compress.lo.
	(BFD32_LIBS_CFILES): Add compress.c.
	(BFD_H_FILES): Likewise.
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* config.in: Add HAVE_ZLIB_H
	* configure.in: Add test for libz and zlib.h
	* configure: Regenerate.
	* dwarf2.c (read_section): New function.
	(read_indirect_string): Call new function read_section.
	(read_abbrevs): Likewise.
	(decode_line_info): Likewise.
	(read_debug_ranges): Likewise.
	(find_line): Call new function read_section when just one
	.zdebug_info section is found, otherwise read and compress
	multiple sections.
	(_bfd_dwarf2_cleanup_debug_info): Free sec_info_ptr.
	* elf.c (_bfd_elf_make_section_from_shdr): Add zdebug prefix.
	(special_sections_z): New struct.
	(special_sections): Refer to special_sections_z.
	* elfxx-mips.c (_bfd_mips_elf_section_from_shdr): Recognize
	sections named .zdebug_*.
	(_bfd_mips_elf_fake_sections): Likewise.
	* compress.c: New file.
	(bfd_uncompress_section_contents): New function.
bfd/doc/
	* Makefile.am (BFD_H_DEP): Add ../compress.c.
	* Makefile.in: Regenerate.
binutils/
	* config.in: Add HAVE_ZLIB_H
	* configure.in: Add test for libz and zlib.h
	* configure: Regenerate.
	* dwarf.c (debug_displays): Add .zdebug_* strings.
	* dwarf.h (struct dwarf_section): Add fields uncompressed_namd
	and compressed_name.
	* objdump.c (load_debug_section): Call
	bfd_uncompress_section_contents when loading a compressed
	section.
	(dump_dwarf_section): Recognize compressed section name.
	(mach_o_dwarf_sections): Rename as
	mach_o_uncompressed_dwarf_sections.
	(mach_o_compressed_dwarf_sections): New variable.
	(generic_dwarf_section): Rename as
	generic_uncompressed_dwarf_sections.
	(generic_compressed_dwarf_sections): New variable.
	(check_mach_o_dwarf): Save and restore
	mach_o_compressed_dwarf_sections.
	* readelf.c: Add #include for config.h and zlib.h
	(process_section_headers): Recognize compressed section name.
	(uncompress_section_contents): New function.
	(load_debug_section): Call uncompress_section_contents when
	loading a compressed section.
	(display_debug_section): Recognize compressed section name.
binutils/testsuite:
	* binutils-all/objdump.exp: Add test for objdump -s on a file
	with a compressed debug section.  Add test for objdump -W on a
	file that contains a compressed debug section.
	* binutils-all/readelf.exp: Call readelf_compressed_wa_test.
	(readelf_compressed_wa_test): New function.
	* binutils-all/dw2-compressed.S: New file.
	* binutils-all/objdump.W: New file.
	* binutils-all/objdump.s: New file.
	* binutils-all/readelf.wa: New file.
@
text
@d2143 15
@


1.411
log
@
        (guess_is_rela): Add EM_CR16_OLD.
        (dump_relocations): Likewise.
        (get_machine_name): Likewise.
        (is_32bit_abs_reloc): Likewise.
@
text
@d44 1
d49 3
d4392 2
a4393 1
	       && const_strneq (name, ".debug_"))
d4395 4
a4398 1
	  name += 7;
d8360 72
d8574 1
d8581 15
a8595 1
  sec = find_section (section->name);
d8604 6
d8614 1
a8614 1
  return section->start != NULL;
d8651 2
a8652 1
    if (streq (debug_displays[i].section.name, name))
@


1.410
log
@* common.h (EM_M32C_NEW): Rename to EM_M32C.
(EM_M32C): Rename to EM_M32C_OLD.

* elf32-m32c.c (ELF_MACHINE_ALT1): Define as EM_M32C_OLD.

* readelf.c (guess_is_rela): Add EM_M32C_OLD.
(dump_relocations): Likewise.
(process_section_headers): Likewise.
(is_32bit_abs_reloc): Likewise.
(is_16bit_abs_reloc): Likewise.
@
text
@d706 1
d1303 1
d1929 2
a1930 1
    case EM_CR16:		return "National Semiconductor's CR16";
d8135 1
@


1.409
log
@* readelf.c (print_symbol): Add code to display non-printing characters.
@
text
@d720 1
d1284 1
d1919 1
d4306 1
d8159 1
d8334 1
@


1.408
log
@	* readelf.c (process_program_headers): Correct section in segment
	display.
@
text
@d545 7
a551 5
/* Display a symbol on stdout.  If do_wide is not true then
   format the symbol to be at most WIDTH characters,
   truncating as necessary.  If WIDTH is negative then
   format the string to be exactly - WIDTH characters,
   truncating or padding as necessary.  */
d556 3
d560 5
a564 1
    printf ("%s", symbol);
d566 5
a570 1
    printf ("%-*.*s", width, width, symbol);
d572 54
a625 1
    printf ("%-.*s", width, symbol);
@


1.407
log
@	* readelf.c (get_gnu_elf_note_type): Recognize NT_GNU_GOLD_VERSION.
@
text
@d3685 1
a3685 1
	  section = section_headers;
@


1.406
log
@        * dwarf.c (display_debug_lines): Rename to
        display_debug_lines_raw.
        (display_debug_lines_decoded): New function.  Displays the
        interpreted contents of a .debug_line section.
        (display_debug_lines): New function: Selects either a raw dump or
        a decoded dump (or both) as requested by the user.
        * dwarf.h (do_debug_lines_decoded): New extern.
        * readelf.c: Add support for -wL or --debug-dump=decodedline
        option to display the decoded contents of a .debug_line section.
        * doc/binutils.texi: Document the new option.
        * NEWS: Mention the new feature.
@
text
@d9802 2
@


1.405
log
@2008-03-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (process_mips_specific): Declare addr_size as int.
@
text
@d164 1
a200 1
static int do_wide;
d2883 2
a2884 2
  -w[liaprmfFsoR] or\n\
  --debug-dump[=line,=info,=abbrev,=pubnames,=aranges,=macro,=frames,=str,=loc,=Ranges]\n\
d3086 4
d3148 3
a3150 1
		  { "line", & do_debug_lines },
d4312 3
a4314 3
		|| do_debug_lines || do_debug_pubnames || do_debug_aranges
		|| do_debug_frames || do_debug_macinfo || do_debug_str
		|| do_debug_loc || do_debug_ranges)
d4322 2
a4323 1
	      || (do_debug_lines    && streq (name, "line"))
d4334 1
a4334 1
      /* linkonce section to be combined with .debug_info at link time.  */
@


1.404
log
@binutils/
	* readelf.c (print_mips_got_entry): New function.
	(process_mips_specific): Print GOT information.

ld/testsuite/
	* ld-mips-elf/got-dump-1.d, ld-mips-elf/got-dump-1.s,
	ld-mips-elf/got-dump-1.ld, ld-mips-elf/got-dump-2.d,
	ld-mips-elf/got-dump-2.s, ld-mips-elf/got-dump-2.ld: New tests.
	* ld-mips-elf/mips-elf.exp: Run them.
@
text
@d9563 1
a9563 1
      size_t addr_size, i, offset;
d9565 1
@


1.403
log
@include/elf/
	* internal.h (Elf_Internal_Shdr): Change sh_link and sh_info from
	unsigned long to unsigned int.  Change sh_addralign to bfd_vma.
	Order struct as for external version.
bfd/
	* elf.c (_bfd_elf_make_section_from_shdr): Remove unnecessary cast.
	(_bfd_elf_assign_file_position_for_section): Simplify align.
	(_bfd_elf_init_reloc_shdr): Ensure shift expression wide enough
	for sh_addralign.
	(elf_fake_sections, swap_out_syms): Likewise.
	* elflink.c (bfd_elf_final_link): Likewise.
binutils/
	* readelf.c: Use %u throughout when printing sh_link or sh_info,
	%lu when printing sh_addralign.
	(process_version_sections): Use identical formats when printing
	all offset and sh_link fields.
@
text
@d9128 27
d9164 4
d9199 11
d9560 81
@


1.402
log
@include/elf/
	PR 5900
	* common.h (SHN_BAD): Delete.
	(SHN_LORESERVE .. SHN_HIRESERVE): Move to..
	* external.h: ..here.
	* internal.h (SHN_LORESERVE, SHN_HIRESERVE): Define.
	(SHN_LOPROC, SHN_HIPROC, SHN_LOOS, SHN_HIOS): Define.
	(SHN_ABS, SHN_COMMON, SHN_XINDEX, SHN_BAD): Define.
bfd/
	PR 5900
	* elf-bfd.h: Include elf/internal.h after elf/external.h.
	* elfcode.h (elf_swap_symbol_in): Map reserved shndx range.
	(elf_swap_symbol_out): Adjust SHN_XINDEX test.
	(elf_swap_ehdr_out): Mask SHN_LORESERVE and SHN_XINDEX to values
	seen in external structs.
	(valid_section_index_p): Delete.
	(elf_object_p): Don't increment section numbers over reserved range.
	Simplify test for valid sh_link, sh_info and e_shstrndx fields.
	(elf_write_shdrs_and_ehdr): Mask SHN_LORESERVE and SHN_XINDEX to values
	seen in external structs.  Don't increment section numbers over
	reserved range.
	* elf.c (bfd_elf_sym_name): Remove redundant tests on st_shndx.
	(bfd_section_from_shdr): Likewise.
	(group_signature): Range check before accessing elf_elfsections.
	(_bfd_elf_setup_sections): Likewise.
	(bfd_section_from_shdr): Likewise.
	(bfd_section_from_shdr): Don't increment section number over
	reserved sections.
	(assign_file_positions_for_non_load_sections): Likewise.
	(assign_file_positions_except_relocs): Likewise.
	(_bfd_elf_write_object_contents): Likewise.
	(assign_section_numbers): Likewise.  Adjust for changed SHN_*.
	(prep_headers): Delete unused variable.
	* elflink.c (bfd_elf_link_record_local_dynamic_symbol): Adjust
	for changed SHN_* values.
	(check_dynsym, elf_link_input_bfd): Likewise.
	(bfd_elf_final_link): Likewise.  Don't skip over reserved section
	range.
	(elf_fixup_link_order): Check that sh_link field is valid.
	* elf-hppa.h (elf_hppa_add_symbol_hook): Make "index" unsigned.
	* elf32-arm.c (elf32_arm_gc_mark_extra_sections): Range check before
	accesssing elf_elfsections.
	* elf32-avr.c (elf32_avr_size_stubs): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Likewise.
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs): Likewise.
	* elf64-hppa.c (elf64_hppa_check_relocs): Adjust for changed
	SHN_* defines.  Test for SHN_BAD return from
	_bfd_elf_section_from_bfd_section
binutils/
	PR 5900
	* readelf.c (SECTION_HEADER_INDEX, SECTION_HEADER_NUM): Delete.
	Remove use throughout file.
	(SECTION_HEADER): Likewise.
	(dump_relocations): Don't adjust st_shndx for reserved range.
	(process_file_header): Mask SHN_XINDEX to values seen in external
	elf structs.  Simplify valid section index tests.
	(get_32bit_elf_symbols, get_64bit_elf_symbols): Mask SHN_XINDEX.
	Map reserved st_shndx to internal form.
	(process_section_groups): Test that group symbol st_shndx is in
	range, not just non-zero.  Delete reserved range check.
	(get_symbol_index_type): Mask "type" to 16 bits when printing PRC,
	OS or RSV.
gdb/
	PR 5900
	* elfread.c (elf_symtab_read): Make shndx an unsigned int.
	* mipsread.c: Include elf/internal.h.
	(read_alphacoff_dynamic_symtab): Map external reserved sym_shndx
	to internal range.
ld/testsuite/
	PR 5900
	* ld-elf/sec64k.exp: Update.
@
text
@d3343 1
a3343 1
	printf (" (%ld)", (long) section_headers[0].sh_link);
d4416 3
a4418 3
	  printf ("%2ld %3lu %2ld\n",
		  (unsigned long) section->sh_link,
		  (unsigned long) section->sh_info,
d4454 1
a4454 3
	  printf ("%2ld %3lu ",
		  (unsigned long) section->sh_link,
		  (unsigned long) section->sh_info);
d4457 1
a4457 1
	    printf ("%2ld\n", (unsigned long) section->sh_addralign);
d4476 1
a4476 1
	  printf ("  %ld\n       ", (unsigned long) section->sh_link);
d4481 2
a4482 2
	  printf ("  %-16lu  %ld\n",
		  (unsigned long) section->sh_info,
d4503 3
a4505 3
	  printf ("     %2ld   %3lu     %ld\n",
		  (unsigned long) section->sh_link,
		  (unsigned long) section->sh_info,
d6560 1
a6560 1
	      (_("\nVersion definition section '%s' contains %ld entries:\n"),
d6565 1
a6565 1
	    printf (_("  Offset: %#08lx  Link: %lx (%s)\n"),
d6662 1
a6662 1
	    printf (_("\nVersion needs section '%s' contains %ld entries:\n"),
d6667 1
a6667 1
	    printf (_("  Offset: %#08lx  Link to section: %ld (%s)\n"),
d6788 1
a6788 1
	    printf (_("  Offset: %#08lx  Link: %lx (%s)\n"),
@


1.401
log
@2008-03-09  Paul Brook  <paul@@codesourcery.com>

	bfd/
	* elf32-arm.c (elf32_arm_merge_eabi_attributes): Handle new
	Tag_VFP_arch values.

	binutils/
	* readelf.c (arm_attr_tag_VFP_arch): Add "VFPv3-D16".

	gas/
	* config/tc-arm.c (fpu_vfp_ext_d32): New vairable.
	(parse_vfp_reg_list, encode_arm_vfp_reg): Use it.
	(arm_option_cpu_value): Add vfpv3-d16, vfpv2 and vfpv3.
	(aeabi_set_public_attributes): Handle Tag_VFP_arch=VFPV3-D16.
	* doc/c-arm.texi: Document new ARM FPU variants.

	gas/testsuite/
	* gas/arm/vfpv3-d16-bad.d: New test.
	* gas/arm/vfpv3-d16-bad.l: New test.

	include/opcode/
	* arm.h (FPU_VFP_EXT_D32, FPU_VFP_V3D16, FPU_ARCH_VFP_V3D16): Define.
@
text
@a278 16
/* Given st_shndx I, map to section_headers index.  */
#define SECTION_HEADER_INDEX(I)				\
  ((I) < SHN_LORESERVE					\
   ? (I)						\
   : ((I) <= SHN_HIRESERVE				\
      ? 0						\
      : (I) - (SHN_HIRESERVE + 1 - SHN_LORESERVE)))

/* Reverse of the above.  */
#define SECTION_HEADER_NUM(N)				\
  ((N) < SHN_LORESERVE					\
   ? (N)						\
   : (N) + (SHN_HIRESERVE + 1 - SHN_LORESERVE))

#define SECTION_HEADER(I) (section_headers + SECTION_HEADER_INDEX (I))

d1289 3
a1291 10
		      bfd_vma sec_index = (bfd_vma) -1;

		      if (psym->st_shndx < SHN_LORESERVE)
			sec_index = psym->st_shndx;
		      else if (psym->st_shndx > SHN_HIRESERVE)
			sec_index = psym->st_shndx - (SHN_HIRESERVE + 1
						      - SHN_LORESERVE);

		      if (sec_index != (bfd_vma) -1)
			sec_name = SECTION_NAME (section_headers + sec_index);
d3336 1
a3336 1
      if (section_headers != NULL && elf_header.e_shnum == 0)
d3341 2
a3342 1
      if (section_headers != NULL && elf_header.e_shstrndx == SHN_XINDEX)
d3344 1
a3344 4
      else if (elf_header.e_shstrndx != SHN_UNDEF
	       && (elf_header.e_shstrndx >= elf_header.e_shnum
		   || (elf_header.e_shstrndx >= SHN_LORESERVE
		       && elf_header.e_shstrndx <= SHN_HIRESERVE)))
d3351 1
a3351 1
      if (elf_header.e_shnum == 0)
d3353 1
a3353 1
      if (elf_header.e_shstrndx == SHN_XINDEX)
d3355 1
a3355 4
      else if (elf_header.e_shstrndx != SHN_UNDEF
	       && (elf_header.e_shstrndx >= elf_header.e_shnum
		   || (elf_header.e_shstrndx >= SHN_LORESERVE
		       && elf_header.e_shstrndx <= SHN_HIRESERVE)))
d3828 1
a3828 1
	  == (unsigned long) SECTION_HEADER_NUM (section - section_headers)))
d3859 1
a3859 1
      if (psym->st_shndx == SHN_XINDEX && shndx != NULL)
d3862 2
d3893 1
a3893 1
	  == (unsigned long) SECTION_HEADER_NUM (section - section_headers)))
d3924 1
a3924 1
      if (psym->st_shndx == SHN_XINDEX && shndx != NULL)
d3927 2
d4174 1
a4174 1
       && SECTION_HEADER_INDEX (elf_header.e_shstrndx) < elf_header.e_shnum)
d4176 1
a4176 1
      section = SECTION_HEADER (elf_header.e_shstrndx);
d4390 1
a4390 1
		  SECTION_HEADER_NUM (i),
d4398 1
a4398 1
		SECTION_HEADER_NUM (i),
d4621 2
a4622 2
	  if (SECTION_HEADER_INDEX (section->sh_link) >= elf_header.e_shnum
	      || ((sec = SECTION_HEADER (section->sh_link))->sh_type
d4641 2
a4642 2
	      bfd_vma sec_index = SECTION_HEADER_INDEX (sym->st_shndx);
	      if (sec_index == 0)
d4648 1
a4648 1
	      group_name = SECTION_NAME (section_headers + sec_index);
d4658 1
a4658 2
	      if (SECTION_HEADER_INDEX (symtab_sec->sh_link)
		  >= elf_header.e_shnum)
d4667 1
a4667 1
		       != (sec = SECTION_HEADER (symtab_sec->sh_link)))
d4706 1
a4706 1
	      if (SECTION_HEADER_INDEX (entry) >= elf_header.e_shnum)
a4711 6
	      else if (entry >= SHN_LORESERVE && entry <= SHN_HIRESERVE)
		{
		  error (_("invalid section [%5u] in group section [%5u]\n"),
			 entry, i);
		  continue;
		}
d4713 1
a4713 2
	      if (section_headers_groups [SECTION_HEADER_INDEX (entry)]
		  != NULL)
d4719 1
a4719 1
			     section_headers_groups [SECTION_HEADER_INDEX (entry)]->group_index);
d4731 1
a4731 1
				 section_headers_groups [SECTION_HEADER_INDEX (entry)]->group_index);
d4737 1
a4737 2
	      section_headers_groups [SECTION_HEADER_INDEX (entry)]
		= group;
d4741 1
a4741 1
		  sec = SECTION_HEADER (entry);
d4873 2
a4874 3
	      if (section->sh_link
		  && SECTION_HEADER_INDEX (section->sh_link)
		     < elf_header.e_shnum)
d4882 1
a4882 1
		  symsec = SECTION_HEADER (section->sh_link);
d4893 2
a4894 2
		  if (SECTION_HEADER_INDEX (symsec->sh_link)
		      < elf_header.e_shnum)
d4896 1
a4896 1
		      strsec = SECTION_HEADER (symsec->sh_link);
d5133 2
a5134 2
	  || SECTION_HEADER_INDEX (relsec->sh_info) >= elf_header.e_shnum
	  || SECTION_HEADER (relsec->sh_info) != sec)
d5192 1
a5192 1
	  && SECTION_HEADER_INDEX (sec->sh_link) < elf_header.e_shnum)
d5197 1
a5197 1
	  strsec = SECTION_HEADER (sec->sh_link);
d5232 1
a5232 1
	      sec = SECTION_HEADER (g->section_index);
d5536 2
a5537 2
	  || SECTION_HEADER_INDEX (relsec->sh_info) >= elf_header.e_shnum
	  || SECTION_HEADER (relsec->sh_info) != sec)
d5598 1
a5598 1
	  && SECTION_HEADER_INDEX (sec->sh_link) < elf_header.e_shnum)
d5603 1
a5603 1
	  strsec = SECTION_HEADER (sec->sh_link);
d6569 2
a6570 3
		    SECTION_HEADER_INDEX (section->sh_link)
		    < elf_header.e_shnum
		    ? SECTION_NAME (SECTION_HEADER (section->sh_link))
d6671 2
a6672 3
		    SECTION_HEADER_INDEX (section->sh_link)
		    < elf_header.e_shnum
		    ? SECTION_NAME (SECTION_HEADER (section->sh_link))
d6765 1
a6765 1
	    if (SECTION_HEADER_INDEX (section->sh_link) >= elf_header.e_shnum)
d6768 1
a6768 1
	    link_section = SECTION_HEADER (section->sh_link);
d6771 1
a6771 2
	    if (SECTION_HEADER_INDEX (link_section->sh_link)
		>= elf_header.e_shnum)
d6778 1
a6778 1
	    string_sec = SECTION_HEADER (link_section->sh_link);
d6838 2
a6839 3
		      if (SECTION_HEADER_INDEX (symbols[cnt + j].st_shndx)
			  >= elf_header.e_shnum
			  || SECTION_HEADER (symbols[cnt + j].st_shndx)->sh_type
d7123 1
a7123 1
	sprintf (buff, "PRC[0x%04x]", type);
d7125 3
a7127 3
	sprintf (buff, "OS [0x%04x]", type);
      else if (type >= SHN_LORESERVE && type <= SHN_HIRESERVE)
	sprintf (buff, "RSV[0x%04x]", type);
d7457 1
a7457 1
	  else if (SECTION_HEADER_INDEX (section->sh_link) < elf_header.e_shnum)
d7461 1
a7461 1
	      string_sec = SECTION_HEADER (section->sh_link);
d7506 2
a7507 3
		  is_nobits = (SECTION_HEADER_INDEX (psym->st_shndx)
			       < elf_header.e_shnum
			       && SECTION_HEADER (psym->st_shndx)->sh_type
d7886 2
a7887 2
	  || SECTION_HEADER_INDEX (relsec->sh_info) >= elf_header.e_shnum
	  || SECTION_HEADER (relsec->sh_info) != section
d7889 1
a7889 1
	  || SECTION_HEADER_INDEX (relsec->sh_link) >= elf_header.e_shnum)
d7965 2
a7966 2
	  || SECTION_HEADER_INDEX (relsec->sh_info) >= elf_header.e_shnum
	  || SECTION_HEADER (relsec->sh_info) != section
d7968 1
a7968 1
	  || SECTION_HEADER_INDEX (relsec->sh_link) >= elf_header.e_shnum)
d8297 2
a8298 2
	  || SECTION_HEADER_INDEX (relsec->sh_info) >= elf_header.e_shnum
	  || SECTION_HEADER (relsec->sh_info) != section
d8300 1
a8300 1
	  || SECTION_HEADER_INDEX (relsec->sh_link) >= elf_header.e_shnum)
d8322 1
a8322 1
      symsec = SECTION_HEADER (relsec->sh_link);
d9543 1
a9543 1
	  if (SECTION_HEADER_INDEX (section->sh_link) >= elf_header.e_shnum)
d9551 1
a9551 1
	  string_sec = SECTION_HEADER (section->sh_link);
@


1.400
log
@	* readelf.c (get_machine_flags): Handle Octeon.
@
text
@d8631 2
a8632 2
/* FIXME: VFPv3 encoding was extrapolated!  */
static const char *arm_attr_tag_VFP_arch[] = {"No", "VFPv1", "VFPv2", "VFPv3"};
@


1.399
log
@        Add OpenVMS extensions.
        * ia64.h (SHF_IA_64_VMS_GLOBAL, SHF_IA_64_VMS_OVERLAID)
        (SHF_IA_64_VMS_SHARED, SHF_IA_64_VMS_VECTOR)
        (SHF_IA_64_VMS_ALLOC_64BIT, SHF_IA_64_VMS_PROTECTED)
        (SHT_IA_64_VMS_TRACE, SHT_IA_64_VMS_TIE_SIGNATURES)
        (SHT_IA_64_VMS_DEBUG, SHT_IA_64_VMS_DEBUG_STR)
        (SHT_IA_64_VMS_LINKAGES, SHT_IA_64_VMS_SYMBOL_VECTOR)
        (SHT_IA_64_VMS_FIXUP, DT_IA_64_VMS_SUBTYPE)
        (DT_IA_64_VMS_IMGIOCNT, DT_IA_64_VMS_LNKFLAGS)
        (DT_IA_64_VMS_VIR_MEM_BLK_SIZ, DT_IA_64_VMS_IDENT)
        (DT_IA_64_VMS_NEEDED_IDENT, DT_IA_64_VMS_IMG_RELA_CNT)
        (DT_IA_64_VMS_SEG_RELA_CNT, DT_IA_64_VMS_FIXUP_RELA_CNT)
        (DT_IA_64_VMS_FIXUP_NEEDED, DT_IA_64_VMS_SYMVEC_CNT)
        (DT_IA_64_VMS_XLATED, DT_IA_64_VMS_STACKSIZE)
        (DT_IA_64_VMS_UNWINDSZ, DT_IA_64_VMS_UNWIND_CODSEG)
        (DT_IA_64_VMS_UNWIND_INFOSEG, DT_IA_64_VMS_LINKTIME)
        (DT_IA_64_VMS_SEG_NO, DT_IA_64_VMS_SYMVEC_OFFSET)
        (DT_IA_64_VMS_SYMVEC_SEG, DT_IA_64_VMS_UNWIND_OFFSET)
        (DT_IA_64_VMS_UNWIND_SEG, DT_IA_64_VMS_STRTAB_OFFSET)
        (DT_IA_64_VMS_SYSVER_OFFSET, DT_IA_64_VMS_IMG_RELA_OFF)
        (DT_IA_64_VMS_SEG_RELA_OFF, DT_IA_64_VMS_FIXUP_RELA_OFF)
        (DT_IA_64_VMS_PLTGOT_OFFSET, DT_IA_64_VMS_PLTGOT_SEG)
        (DT_IA_64_VMS_FPMODE, SHN_IA_64_VMS_SYMVEC): Define

        * readelf.c (dump_relocations): Decode OpenVMS-specific sections.
        (get_ia64_dynamic_type): Decode OpenVMS-specific tags.
        (get_dynamic_type): Handle IA64-specific tags.
        (get_ia64_section_type_name): Handle OpenVMS-specific sections.
        (get_section_type_name): Handle OS-specific sections (and
        particularly IA64 OpenVMS one).
        (get_elf_section_flags): Makes flags static.  Add entries for IA64 and
        decode them.
@
text
@d2263 1
@


1.398
log
@binutils/

2008-01-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* dwarf.c: Include "elf/common.h".
	(eh_addr_size): Changed to int.
	(dwarf_regnames_i386): New.
	(dwarf_regnames_x86_64): Likewise.
	(dwarf_regnames): Likewise.
	(dwarf_regnames_count): Likewise.
	(init_dwarf_regnames): Likewise.
	(regname): Likewise.
	(frame_display_row): Properly support different address size.
	Call regname to get register name.
	(display_debug_frames): Call regname to get register name.
	Display DW_CFA_def_cfa_register as DW_CFA_def_cfa_register
	instead of DW_CFA_def_cfa_reg.

	* dwarf.h (init_dwarf_regnames): New.

	* objdump.c: Include "elf-bfd.h".
	(dump_dwarf): Call init_dwarf_regnames on ELF input.

	* readelf.c (guess_is_rela): Change argument to int.
	(parse_args): Remove the undocumented upper case options for
	-wX.
	(process_file_header): Call init_dwarf_regnames if
	do_dwarf_register is true.

gas/testsuite/

2008-01-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/cfi/cfi-alpha-1.d: Replace DW_CFA_def_cfa_reg with
	DW_CFA_def_cfa_register.
	* gas/cfi/cfi-alpha-3.d: Likewise.
	* gas/cfi/cfi-hppa-1.d: Likewise.
	* gas/cfi/cfi-i386.d: Likewise.
	* gas/cfi/cfi-m68k.d: Likewise.
	* gas/cfi/cfi-mips-1.d: Likewise.
	* gas/cfi/cfi-sh-1.d: Likewise.
	* gas/cfi/cfi-sparc-1.d: Likewise.
	* gas/cfi/cfi-sparc64-1.d: Likewise.
	* gas/cfi/cfi-x86_64.d: Likewise.

	* gas/cfi/cfi-common-1.d: Updated for i386/x86-64 register
	names.
	* gas/cfi/cfi-common-2.d: Likewise.
	* gas/cfi/cfi-common-5.d: Likewise.
	* gas/cfi/cfi-i386.d: Likewise.
	* gas/cfi/cfi-x86_64.d: Likewise.

ld/testsuite/

2008-01-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-elf/eh1.d: Replace DW_CFA_def_cfa_reg with
	DW_CFA_def_cfa_register. Updated for i386/x86-64 register
	names.
	* ld-elf/eh2.d: Likewise.
	* ld-elf/eh3.d: Likewise.
	* ld-elf/eh4.d: Likewise.
	* ld-elf/eh5.d: Likewise.
@
text
@d1332 5
d1530 31
a1560 1
    case DT_IA_64_PLT_RESERVE: return "IA_64_PLT_RESERVE";
d1726 3
d2698 10
a2707 3
    case SHT_IA_64_EXT:		  return "IA_64_EXT";
    case SHT_IA_64_UNWIND:	  return "IA_64_UNWIND";
    case SHT_IA_64_PRIORITY_INIT: return "IA_64_PRIORITY_INIT";
d2811 18
a2828 1
	sprintf (buff, "LOOS+%x", sh_type - SHT_LOOS);
d3973 1
a3973 1
  const struct
d3989 11
a3999 1
	{ "TLS", 3 }
d4033 20
@


1.397
log
@* readelf.c (process_section_headers): Add m16c handler.
(is_16bit_abs_reloc): Recognize R_M32C_16.
@
text
@d627 1
a627 1
guess_is_rela (unsigned long e_machine)
a3034 1
		  case 'I':
a3038 1
		  case 'A':
a3042 1
		  case 'L':
a3046 1
		  case 'P':
a3064 1
		  case 'M':
a3068 1
		  case 'S':
a3072 1
		  case 'O':
d3242 2
@


1.396
log
@Add mingw I64 support for printing long and long long values
@
text
@d4165 10
d8209 2
@


1.395
log
@* readelf.c (is_64bit_abs_reloc): Handle R_S390_64.
@
text
@d2 2
a3 2
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
   Free Software Foundation, Inc.
d496 1
d499 3
d509 1
d512 3
d525 1
d532 6
d547 1
d550 3
d1012 1
d1019 6
d7849 1
d7851 3
@


1.394
log
@	* readelf.c (is_32bit_pcrel_reloc): Add Xtensa.
@
text
@d8140 3
@


1.393
log
@	* readelf.c (is_32bit_abs_reloc, is_32bit_pcrel_reloc): Add SPU.
@
text
@d8105 3
@


1.392
log
@	bfd/
	* archures.c (bfd_mach_mips_loongson_2e): New.
	(bfd_mach_mips_loongson_2f): New.
	* bfd-in2.h (bfd_mach_mips_loongson_2e): New.
	(bfd_mach_mips_loongson_2f): New.
	* cpu-mips.c: Add I_loongson_2e and I_loongson_2f to
	anonymous enum.
	(arch_info_struct): Add Loongson-2E and Loongson-2F entries.
	* elfxx-mips.c (_bfd_elf_mips_mach): Handle Loongson-2E
	and Loongson-2F flags.
	(mips_set_isa_flags): Likewise.
	(mips_mach_extensions): Add Loongson-2E and Loongson-2F
	entries.

	binutils/
	* readelf.c (get_machine_flags): Handle Loongson-2E and -2F
	flags.

	gas/
	* config/tc-mips.c (mips_cpu_info_table): Add loongson2e
	and loongson2f entries.
	* doc/c-mips.texi: Document -march=loongson{2e,2f} options.

	gas/testsuite/
	* gas/mips/mips.exp: Add loongson-2e and -2f tests.
	* gas/mips/loongson-2e.d: New.
	* gas/mips/loongson-2e.s: New.
	* gas/mips/loongson-2f.d: New.
	* gas/mips/loongson-2f.s: New.

	include/elf/
	* mips.h (E_MIPS_MACH_LS2E): New.
	(E_MIPS_MACH_LS2F): New.

	include/opcode/
	* mips.h (INSN_LOONGSON_2E): New.
	(INSN_LOONGSON_2F): New.
	(CPU_LOONGSON_2E): New.
	(CPU_LOONGSON_2F): New.
	(OPCODE_IS_MEMBER): Update for Loongson-2E and -2F flags.

	opcodes/
	* mips-dis.c (mips_arch_choices): Add Loongson-2E and -2F
	entries.
	* mips-opc.c (IL2E): New.
	(IL2F): New.
	(mips_builtin_opcodes): Add Loongson-2E and -2F instructions.
	Allow movz and movn for Loongson-2E and -2F.  Add movnz entry.
	Move coprocessor encodings to the end of the table.  Allow
	certain MIPS V .ps instructions on the Loongson-2E and -2F.
@
text
@d8047 2
d8101 2
@


1.391
log
@* readelf.c (is_32bit_abs_reloc): Add support for NIOS relocs.
   (is_64bit_abs_reloc): Add support for HPPA relocs.
   (is_16bit_abs_reloc): Add support for NIOS relocs.
@
text
@d2197 2
@


1.390
log
@	[ld/testsuite/ChangeLog]
	* ld-mips-elf/attr-gnu-4-14.d, ld-mips-elf/attr-gnu-4-41.d:
	Adjust warning message for -mfp64 flag.
	* ld-mips-elf/attr-gnu-4-5.s, ld-mips-elf/attr-gnu-4-04.d,
	ld-mips-elf/attr-gnu-4-51.d, ld-mips-elf/attr-gnu-4-05.d,
	ld-mips-elf/attr-gnu-4-15.d, ld-mips-elf/attr-gnu-4-24.d,
	ld-mips-elf/attr-gnu-4-25.d, ld-mips-elf/attr-gnu-4-34.d,
	ld-mips-elf/attr-gnu-4-35.d, ld-mips-elf/attr-gnu-4-42.d,
	ld-mips-elf/attr-gnu-4-43.d, ld-mips-elf/attr-gnu-4-44.d,
	ld-mips-elf/attr-gnu-4-45.d, ld-mips-elf/attr-gnu-4-40.d,
	ld-mips-elf/attr-gnu-4-14.d: New testcases files.
	* ld-mips-elf/mips-elf.exp: Run new testcases.

	[binutils/ChangeLog]
	* readelf.c (display_mips_gnu_attribute): Recognize -mips32r2 -mfp64
	objects.

	[include/ChangeLog]
	* elf/mips.h (Tag_GNU_MIPS_ABI_FP): Mention -mips32r2 -mfp64 variant
	in comment.

	[bfd/ChangeLog]
	* elfxx-mips.c (mips_elf_merge_obj_attributes): Handle -mips32r2
	-mfp64 attribute.

	[gas/ChangeLog]
	* doc/as.texinfo: Document the new attribute value.
@
text
@d8016 3
a8057 4
    case EM_ALTERA_NIOS2:
      /* Fall through (what reloc type is used ?).  */
    case EM_NIOS32:
      /* Fall through (what reloc type is used ?).  */
d8075 1
a8075 1
      return reloc_type == 2; /* R_386_PC32.  */
d8077 1
a8077 1
      return reloc_type == 4; /* R_68K_PC32.  */
d8081 1
a8081 1
      return reloc_type == 3; /* R_ARM_REL32 */
d8083 1
a8083 1
      return reloc_type == 0; /* R_PARISC_NONE.  *//* FIXME: This reloc is generated, but it may be a bug.  */
d8087 1
a8087 1
      return reloc_type == 26;  /* R_PPC64_REL32.  */
d8090 1
a8090 1
      return reloc_type == 5; /* R_390_PC32.  */
d8092 1
a8092 1
      return reloc_type == 2; /* R_SH_REL32.  */
d8096 1
a8096 1
      return reloc_type == 6; /* R_SPARC_DISP32.  */
d8098 1
a8098 1
      return reloc_type == 2; /* R_X86_64_PC32.  */
d8121 2
d8160 3
@


1.389
log
@Add cast to avoid compile time warning
@
text
@d8836 3
@


1.388
log
@* dwarf.c (is_relocatable): Remove definition.
  (display_debug_frames): Remove check in is_relocatable.
* dwarf.h (is_relocatable): Remove declaration.
* objdump.c (is_relocatable): New static definition.
* readelf.c (dump_relocations): Make the function void.
  (is_32bit_abs_reloc): Add support for x86, Arc, Arm, D10V, Dlx, OR32 and Score.
  (is_32bit_pcrel_reloc): Add support for x86 and Arm.
  (is_16bit_abs_reloc): Add support for D10V.
  (debug_apply_rela_addends): Rename to debug_apply_relocations.
  Add code to support rel relocations.
  (load_debug_section): Fix call to debug_apply_relocations.
  (get_file_header): Remove setting of is_relocatable.
* gas/cfi/cfi-common-6.d: Allow for possible relocation of the .debug.eh_frame section.
@
text
@d8280 1
a8280 1
		    rp - relocs,
@


1.387
log
@	* readelf.c (debug_apply_rela_addends): Clarify FIXME.
@
text
@d882 1
a882 1
static int
d902 1
a902 1
	return 0;
d907 1
a907 1
	return 0;
a1369 2

  return 1;
d5035 1
a5035 2
  /* Third, apply any relocations to the unwind table: */

a5438 1

d7945 3
d7954 4
d7971 3
d7977 2
d8016 3
d8033 2
d8074 3
d8081 2
d8104 2
a8105 2
	 more helpful warning message will be generated by debug_apply_rela_addends
	 anyway, so just return.  */
d8146 3
d8164 1
a8164 1
/* Apply addends of RELA relocations.  */
d8166 4
a8169 4
static int
debug_apply_rela_addends (void *file,
			  Elf_Internal_Shdr *section,
			  unsigned char *start)
d8174 2
a8175 6
  if (!is_relocatable)
    return 1;

  /* SH uses RELA but uses in place value instead of the addend field.  */
  if (elf_header.e_machine == EM_SH)
    return 0;
d8177 1
d8182 3
a8184 2
      unsigned long nrelas;
      Elf_Internal_Rela *rela, *rp;
d8189 1
a8189 1
      if (relsec->sh_type != SHT_RELA
d8196 18
a8213 3
      if (!slurp_rela_relocs (file, relsec->sh_offset, relsec->sh_size,
			      &rela, &nrelas))
	return 0;
d8218 1
a8218 1
      for (rp = rela; rp < rela + nrelas; ++rp)
d8220 4
a8223 3
	  unsigned int reloc_type;
	  unsigned int reloc_size;
	  unsigned char *loc;
a8237 1
	  sym = symtab + get_reloc_symindex (rp->r_info);
d8239 1
d8249 1
a8249 1
	      warn (_("skipping unsupported reloc type %d in section .rela%s\n"),
d8263 4
d8278 1
a8278 1
	      warn (_("skipping unexpected symbol type %s in relocation in section .rela%s\n"),
d8280 2
a8281 1
		    SECTION_NAME (section));
d8285 7
a8291 7
	  /* FIXME.  We apply pcrel relocs as if they were absolute,
	     ie. without subtracting the pc.  This is to suit
	     display_debug_frames which does not add the pc even
	     though it ought to for DW_EH_PE_pcrel FDEs.  Removing
	     the hack in display_debug_frames will require that we
	     apply rel relocs too.  */
	  byte_put (loc, rp->r_addend + sym->st_value, reloc_size);
d8295 1
a8295 1
      free (rela);
a8297 1
  return 1;
d8323 1
a8323 1
    debug_apply_rela_addends (file, sec, section->start);
a9927 2
  is_relocatable = elf_header.e_type == ET_REL;

@


1.386
log
@* readelf.c (is_32bit_abs_reloc): Add knowledge of reloc used by IA64.
  (is_64bit_abs_reloc): Likewise.
@
text
@d8245 7
a8251 8
	  if (is_32bit_pcrel_reloc (reloc_type))
	    /* FIXME: Not sure how to apply a pc-rel reloc yet.
	       I think that it ought to be:
	       (rp->r_addend + sym->st_value) - rp->r_offset
	       but this breaks GAS CFI tests...  */
	    byte_put (loc, (rp->r_addend + sym->st_value) /*- rp->r_offset*/, reloc_size);
	  else
	    byte_put (loc, rp->r_addend + sym->st_value, reloc_size);
@


1.385
log
@* dwarf.c (process_debug_info): Check for corrupt lengths.
* readelf.c (get_reloc_type): New function.  Returns the reloc number extracted from the info field of a reloc.
  (get_reloc_symindex): New function.  Returns the symbol index
  (extracted from the info field of a reloc.
  (dump_relocations): Use the new functions.
  (slurp_ia64_unwind_table): Use the new functions.
  (slurp_hppa_unwind_table): Use the new functions.
  (dump_section_as_bytes): Use the new functions.
  (get_reloc_size): Delete function.
  (is_32bit_abs_reloc): New function.  Determines if a given reloc type is a 32-bit absolute relocation.
  (is_32bit_pcrel_reloc): New function.  Like is_32bit_abs_reloc but for pc-relative relocations.
  (is_64bit_abs_reloc): New function.  Like is_32bit_abs_reloc but for 64-bit absolute relocations.
  (is_16bit_abs_reloc): New function.  Like is_32bit_abs_reloc but for 32-bit absolute relocations.
  (debug_apply_rela_addends): Use the new functions.  Skip and warn about any unrecognised relocations.
@
text
@d7978 2
a8044 1
    case EM_IA_64:
d8102 2
@


1.384
log
@	* elf32-ppc.c (ppc_elf_merge_obj_attributes): Add support for
	Tag_GNU_Power_ABI_Vector.

	* readelf.c (display_power_gnu_attribute): Add support for
	Tag_GNU_Power_ABI_Vector.

	* ppc.h (Tag_GNU_Power_ABI_Vector): New.

	* ld-powerpc/attr-gnu-8-1.s, ld-powerpc/attr-gnu-8-11.d,
	ld-powerpc/attr-gnu-8-2.s, ld-powerpc/attr-gnu-8-23.d,
	ld-powerpc/attr-gnu-8-3.s, ld-powerpc/attr-gnu-8-31.d: New.
	* ld-powerpc/powerpc.exp: Run new tests.
@
text
@d849 30
a947 2
      const char *rtype2 = NULL;
      const char *rtype3 = NULL;
a951 2
      bfd_vma type2 = 0;
      bfd_vma type3 = 0;
d956 17
a972 4
      if (is_32bit_elf)
	{
	  type         = ELF32_R_TYPE (info);
	  symtab_index = ELF32_R_SYM  (info);
d974 1
a974 26
      else
	{
	  /* The #ifdef BFD64 below is to prevent a compile time warning.
	     We know that if we do not have a 64 bit data type that we
	     will never execute this code anyway.  */
#ifdef BFD64
	  if (elf_header.e_machine == EM_MIPS)
	    {
	      /* In little-endian objects, r_info isn't really a 64-bit
		 little-endian value: it has a 32-bit little-endian
		 symbol index followed by four individual byte fields.
		 Reorder INFO accordingly.  */
	      if (elf_header.e_ident[EI_DATA] != ELFDATA2MSB)
		info = (((info & 0xffffffff) << 32)
			| ((info >> 56) & 0xff)
			| ((info >> 40) & 0xff00)
			| ((info >> 24) & 0xff0000)
			| ((info >> 8) & 0xff000000));
	      type  = ELF64_MIPS_R_TYPE (info);
	      type2 = ELF64_MIPS_R_TYPE2 (info);
	      type3 = ELF64_MIPS_R_TYPE3 (info);
	    }
	  else if (elf_header.e_machine == EM_SPARCV9)
	    type = ELF64_R_TYPE_ID (info);
	  else
	    type = ELF64_R_TYPE (info);
d976 2
a977 3
	  symtab_index = ELF64_R_SYM  (info);
#endif
	}
a1118 5
	  if (!is_32bit_elf)
	    {
	      rtype2 = elf_mips_reloc_type (type2);
	      rtype3 = elf_mips_reloc_type (type3);
	    }
d1340 1
d1343 5
d1366 1
d5054 2
a5055 10
	  if (is_32bit_elf)
	    {
	      relname = elf_ia64_reloc_type (ELF32_R_TYPE (rp->r_info));
	      sym = aux->symtab + ELF32_R_SYM (rp->r_info);
	    }
	  else
	    {
	      relname = elf_ia64_reloc_type (ELF64_R_TYPE (rp->r_info));
	      sym = aux->symtab + ELF64_R_SYM (rp->r_info);
	    }
d5458 2
a5459 10
	  if (is_32bit_elf)
	    {
	      relname = elf_hppa_reloc_type (ELF32_R_TYPE (rp->r_info));
	      sym = aux->symtab + ELF32_R_SYM (rp->r_info);
	    }
	  else
	    {
	      relname = elf_hppa_reloc_type (ELF64_R_TYPE (rp->r_info));
	      sym = aux->symtab + ELF64_R_SYM (rp->r_info);
	    }
d7933 10
a7942 8
/* Return the number of bytes affected by a given reloc.
   This information is architecture and reloc dependent.
   Returns 4 by default, although this is not always correct.
   It should return 0 if a decision cannot be made.
   FIXME: This is not the correct way to solve this problem.
   The proper way is to have target specific reloc sizing functions
   created by the reloc-macros.h header, in the same way that it
   already creates the reloc naming functions.  */
d7944 175
a8118 2
static unsigned int
get_reloc_size (Elf_Internal_Rela * reloc)
d8122 3
d8128 7
a8134 10
    case EM_H8_500:
      switch (ELF32_R_TYPE (reloc->r_info))
	{
	  /* PR gas/3800 - without this information we do not correctly
	     decode the debug information generated by the h8300 assembler.  */
	case R_H8_DIR16:
	  return 2;
	default:
	  return 4;
	}
d8136 1
a8136 6
      /* FIXME: We need to extend this switch statement to cope with other
	 architecture's relocs.  (When those relocs are used against debug
	 sections, and when their size is not 4).  But see the multiple
	 inclusions of <elf/h8.h> for an example of the hoops that we need
	 to jump through in order to obtain the reloc numbers.  */
      return 4;
d8183 2
a8185 1
	  unsigned int reloc_size;
d8187 23
a8209 2
	  reloc_size = get_reloc_size (rp);
	  if (reloc_size == 0)
d8211 2
a8212 3
	      warn (_("skipping relocation of unknown size against offset 0x%lx in section %s\n"),
		    (unsigned long) rp->r_offset,
		    SECTION_NAME (section));
d8225 10
a8234 1
	  if (is_32bit_elf)
d8236 5
a8240 1
	      sym = symtab + ELF32_R_SYM (rp->r_info);
d8242 6
a8247 17
	      if (ELF32_R_SYM (rp->r_info) != 0
		  && ELF32_ST_TYPE (sym->st_info) != STT_SECTION
		  /* Relocations against symbols without type can happen.
		     Gcc -feliminate-dwarf2-dups may generate symbols
		     without type for debug info.  */
		  && ELF32_ST_TYPE (sym->st_info) != STT_NOTYPE
		  /* Relocations against object symbols can happen,
		     eg when referencing a global array.  For an
		     example of this see the _clz.o binary in libgcc.a.  */
		  && ELF32_ST_TYPE (sym->st_info) != STT_OBJECT)
		{
		  warn (_("skipping unexpected symbol type %s in relocation in section .rela%s\n"),
			get_symbol_type (ELF32_ST_TYPE (sym->st_info)),
			SECTION_NAME (section));
		  continue;
		}
	    }
d8249 1
a8249 28
	    {
	      /* In MIPS little-endian objects, r_info isn't really a
		 64-bit little-endian value: it has a 32-bit little-endian
		 symbol index followed by four individual byte fields.
		 Reorder INFO accordingly.  */
	      if (elf_header.e_machine == EM_MIPS
		  && elf_header.e_ident[EI_DATA] != ELFDATA2MSB)
		rp->r_info = (((rp->r_info & 0xffffffff) << 32)
			      | ((rp->r_info >> 56) & 0xff)
			      | ((rp->r_info >> 40) & 0xff00)
			      | ((rp->r_info >> 24) & 0xff0000)
			      | ((rp->r_info >> 8) & 0xff000000));

	      sym = symtab + ELF64_R_SYM (rp->r_info);

	      if (ELF64_R_SYM (rp->r_info) != 0
		  && ELF64_ST_TYPE (sym->st_info) != STT_SECTION
		  && ELF64_ST_TYPE (sym->st_info) != STT_NOTYPE
		  && ELF64_ST_TYPE (sym->st_info) != STT_OBJECT)
		{
		  warn (_("skipping unexpected symbol type %s in relocation in section .rela.%s\n"),
			get_symbol_type (ELF64_ST_TYPE (sym->st_info)),
			SECTION_NAME (section));
		  continue;
		}
	    }

	  byte_put (loc, rp->r_addend, reloc_size);
@


1.383
log
@	* readelf.c (get_note_type): Handle NT_PPC_VMX.
@
text
@d8556 26
@


1.382
log
@	* readelf.c (process_program_headers): Use dynamic segment unless
	dynamic section is found.
@
text
@d9286 2
@


1.381
log
@binutils/

2007-10-09  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/4476
	* readelf.c (print_dynamic_symbol): New.
	(process_symbol_table): Handle DT_GNU_HASH for dynamic symbols.

ld/testsuite/

2007-10-09  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/4476
	* ld-elf/hash.d: Check "-s -D" for readelf.
@
text
@d3533 5
d3552 4
a3555 1
		break;
d3562 2
a3563 1
		warn (_("the .dynamic section is not contained within the dynamic segment\n"));
d3565 2
a3566 8
		warn (_("the .dynamic section is not the first section in the dynamic segment.\n"));
	    }
	  else
	    {
	      /* Otherwise, we can only assume that the .dynamic
		 section is the first section in the DYNAMIC segment.  */
	      dynamic_addr = segment->p_offset;
	      dynamic_size = segment->p_filesz;
@


1.380
log
@	* readelf.c (dump_section_as_strings): Use %6tx instead of %6zx.
@
text
@d7087 33
d7132 1
d7137 3
a7139 2
  if (dynamic_info[DT_HASH] && ((do_using_dynamic && dynamic_strings != NULL)
				|| do_histogram))
d7183 3
a7185 2
  if (do_syms
      && dynamic_info[DT_HASH] && do_using_dynamic && dynamic_strings != NULL)
d7187 19
a7205 2
      unsigned long hn;
      bfd_vma si;
d7207 4
a7210 1
      printf (_("\nSymbol table for image:\n"));
d7212 1
a7212 1
	printf (_("  Num Buc:    Value  Size   Type   Bind Vis      Ndx Name\n"));
d7214 25
a7238 1
	printf (_("  Num Buc:    Value          Size   Type   Bind Vis      Ndx Name\n"));
d7240 10
a7249 1
      for (hn = 0; hn < nbuckets; hn++)
d7251 3
a7253 2
	  if (! buckets[hn])
	    continue;
d7255 3
a7257 1
	  for (si = buckets[hn]; si < nchains && si > 0; si = chains[si])
d7259 19
a7277 2
	      Elf_Internal_Sym *psym;
	      int n;
d7279 1
a7279 1
	      psym = dynamic_symbols + si;
d7281 25
a7305 7
	      n = print_vma (si, DEC_5);
	      if (n < 5)
		fputs ("     " + n, stdout);
	      printf (" %3lu: ", hn);
	      print_vma (psym->st_value, LONG_HEX);
	      putchar (' ');
	      print_vma (psym->st_size, DEC_5);
d7307 2
a7308 14
	      printf ("  %6s", get_symbol_type (ELF_ST_TYPE (psym->st_info)));
	      printf (" %6s",  get_symbol_binding (ELF_ST_BIND (psym->st_info)));
	      printf (" %3s",  get_symbol_visibility (ELF_ST_VISIBILITY (psym->st_other)));
	      /* Check to see if any other bits in the st_other field are set.
	         Note - displaying this information disrupts the layout of the
	         table being generated, but for the moment this case is very rare.  */
	      if (psym->st_other ^ ELF_ST_VISIBILITY (psym->st_other))
		printf (" [%s] ", get_symbol_other (psym->st_other ^ ELF_ST_VISIBILITY (psym->st_other)));
	      printf (" %3.3s ", get_symbol_index_type (psym->st_shndx));
	      if (VALID_DYNAMIC_NAME (psym->st_name))
		print_symbol (25, GET_DYNAMIC_NAME (psym->st_name));
	      else
		printf (" <corrupt: %14ld>", psym->st_name);
	      putchar ('\n');
d7311 23
a7617 2
      unsigned char nb[16];
      bfd_vma i, maxchain = 0xffffffff, symidx, bitmaskwords;
a7623 94
      bfd_vma buckets_vma;

      if (fseek (file,
		 (archive_file_offset
		  + offset_from_vma (file, dynamic_info_DT_GNU_HASH,
				     sizeof nb)),
		 SEEK_SET))
	{
	  error (_("Unable to seek to start of dynamic information\n"));
	  return 0;
	}

      if (fread (nb, 16, 1, file) != 1)
	{
	  error (_("Failed to read in number of buckets\n"));
	  return 0;
	}

      ngnubuckets = byte_get (nb, 4);
      symidx = byte_get (nb + 4, 4);
      bitmaskwords = byte_get (nb + 8, 4);
      buckets_vma = dynamic_info_DT_GNU_HASH + 16;
      if (is_32bit_elf)
	buckets_vma += bitmaskwords * 4;
      else
	buckets_vma += bitmaskwords * 8;

      if (fseek (file,
		 (archive_file_offset
		  + offset_from_vma (file, buckets_vma, 4)),
		 SEEK_SET))
	{
	  error (_("Unable to seek to start of dynamic information\n"));
	  return 0;
	}

      gnubuckets = get_dynamic_data (file, ngnubuckets, 4);

      if (gnubuckets == NULL)
	return 0;

      for (i = 0; i < ngnubuckets; i++)
	if (gnubuckets[i] != 0)
	  {
	    if (gnubuckets[i] < symidx)
	      return 0;

	    if (maxchain == 0xffffffff || gnubuckets[i] > maxchain)
	      maxchain = gnubuckets[i];
	  }

      if (maxchain == 0xffffffff)
	return 0;

      maxchain -= symidx;

      if (fseek (file,
		 (archive_file_offset
		  + offset_from_vma (file, buckets_vma
					   + 4 * (ngnubuckets + maxchain), 4)),
		 SEEK_SET))
	{
	  error (_("Unable to seek to start of dynamic information\n"));
	  return 0;
	}

      do
	{
	  if (fread (nb, 4, 1, file) != 1)
	    {
	      error (_("Failed to determine last chain length\n"));
	      return 0;
	    }

	  if (maxchain + 1 == 0)
	    return 0;

	  ++maxchain;
	}
      while ((byte_get (nb, 4) & 1) == 0);

      if (fseek (file,
		 (archive_file_offset
		  + offset_from_vma (file, buckets_vma + 4 * ngnubuckets, 4)),
		 SEEK_SET))
	{
	  error (_("Unable to seek to start of dynamic information\n"));
	  return 0;
	}

      gnuchains = get_dynamic_data (file, maxchain, 4);

      if (gnuchains == NULL)
	return 0;
d7641 1
a7641 1
	    for (off = gnubuckets[hn] - symidx;
@


1.379
log
@* readelf.c (do_archive_index): New.
  (options): Add -c and --archive-index option.
  (usage): Add -c option.
  (parse_args): Add c option parsing.
  (process_archive): Dump archive index.
* NEWS: Mention the new feature.
* doc/binutils.texi: Document the new feature.
@
text
@d7781 1
a7781 1
	  printf ("  [%6zx]  %s\n", data - start, data);
@


1.378
log
@	* nm.c (value_format_64bit, set_print_radix, print_value): Handle
	BFD_HOST_64BIT_LONG_LONG.
	* readelf.c (print_dec_vma): Don't define if BFD_HOST_64BIT_LONG_LONG.
	(print_vma): Handle BFD_HOST_64BIT_LONG_LONG.
	(dump_relocations): Likewise.  Expand _bfd_int64_low in a
	number of places.
@
text
@d205 1
d2759 1
d2796 1
d2887 1
a2887 1
	  (argc, argv, "ersuahnldSDAINtgw::x:i:vVWHp:", options, NULL)) != EOF)
d2961 3
d3152 1
a3152 1
      && !do_section_groups)
d9805 2
a9806 2
/* Process an ELF archive.  The file is positioned just after the
   ARMAG string.  */
d9814 4
d9835 1
a9838 2
      /* This is the archive symbol table.  Skip it.
	 FIXME: We should have an option to dump it.  */
d9840 89
a9928 1
      if (fseek (file, size + (size & 1), SEEK_CUR) != 0)
d9930 5
a9934 2
	  error (_("%s: failed to skip archive symbol table\n"), file_name);
	  return 1;
d9937 1
a9937 1
      got = fread (&arhdr, 1, sizeof arhdr, file);
d9941 4
a9944 1
	    return 0;
d9946 3
a9948 2
	  error (_("%s: failed to read archive header\n"), file_name);
	  return 1;
d9951 2
a9959 1

d9963 3
a9965 2
	  error (_("Out of memory\n"));
	  return 1;
d9971 3
a9973 2
	  error (_("%s: failed to read string table\n"), file_name);
	  return 1;
d9979 1
a9979 1
      got = fread (&arhdr, 1, sizeof arhdr, file);
d9982 71
a10052 1
	  free (longnames);
d10054 3
a10056 2
	  if (got == 0)
	    return 0;
d10058 9
a10066 2
	  error (_("%s: failed to read archive header\n"), file_name);
	  return 1;
d10068 6
d10157 6
a10162 1
  if (longnames != 0)
d10201 1
a10201 1
      error (_("%s: Failed to read file header\n"), file_name);
d10210 4
@


1.377
log
@	PR 5011
	* readelf.c (process_version_sections): Don't read past end of
	various section buffers.
@
text
@d386 1
a386 1
#if defined BFD64 && !BFD_HOST_64BIT_LONG
d494 2
d503 2
d515 5
d530 2
d967 3
a969 5
#ifdef _bfd_int64_low
	  printf ("%8.8lx  %8.8lx ", _bfd_int64_low (offset), _bfd_int64_low (info));
#else
	  printf ("%8.8lx  %8.8lx ", offset, info);
#endif
d973 11
a983 1
#ifdef _bfd_int64_low
a990 5
#else
	  printf (do_wide
		  ? "%16.16lx  %16.16lx "
		  : "%12.12lx  %12.12lx ",
		  offset, info);
d1220 1
a1220 5
#ifdef _bfd_int64_low
	printf (_("unrecognized: %-7lx"), _bfd_int64_low (type));
#else
	printf (_("unrecognized: %-7lx"), type);
#endif
d1336 2
a1337 5
#ifdef _bfd_int64_low
	    printf (_("unrecognized: %-7lx"), _bfd_int64_low (type2));
#else
	    printf (_("unrecognized: %-7lx"), type2);
#endif
d1344 2
a1345 5
#ifdef _bfd_int64_low
	    printf (_("unrecognized: %-7lx"), _bfd_int64_low (type3));
#else
	    printf (_("unrecognized: %-7lx"), type3);
#endif
@


1.376
log
@* readelf.c (dump_type): New type used to classify the kinds of dump requested by the user.
  (dump_sects, cmdline_dump_sects): Use the new type.
  (options): Add --string-dump option.
  (request_dump): Rename to request_dump_bynumber.  Use dump_type.
  (request_dump_byname): Use dump_type.
  (parse_args): Parse --string-dump option.
  (process_section_headers): Fix calls to request_dump.
  (initialise_dumps_byname): Likewise.
  (dump_section): Rename to dump_section_as_bytes.
  (dump_section_as_strings): New function.  Display the contents of a section as printable strings.
  (process_section_contents): String dump the section if requested.
  (process_object): Use dump_type.
  (main): Likewise.
* Makefile.am: Add dependency for readelf.c on safe-ctype.h.
* Makefile.in: Regenerate.
* NEWS: Mention the new feature.
* doc/binutils.texi: Document the new feature.
* testsuite/binutils-all/dumptest.s: New test file.
* testsuite/binutils-all/readelf.exp: Add test of readelf's -p switch.
@
text
@d6457 1
d6477 1
d6492 2
d6531 2
d6544 2
d6549 2
d6561 1
d6580 1
d6593 2
d6620 2
d6643 2
d6648 2
d6794 4
a6797 1
				  name = strtab + ivna.vna_name;
d6849 4
a6852 1
			      name = strtab + ivda.vda_name;
@


1.375
log
@include/elf/
	* common.h (NT_SPU): Define.
bfd/
	* elf.c (elfcore_grok_spu_note): New function.
	(elf_parse_notes): Call it.
binutils/
	* readelf.c (process_note): Recognize SPU core file notes.
@
text
@d161 1
d223 10
a232 2
/* A linked list of the section names for which dumps were requested
   by name.  */
d236 1
a236 1
  int type;
d241 4
a244 5
/* A dynamic array of flags indicating for which sections a hex dump
   has been requested (via the -x switch) and/or a disassembly dump
   (via the -i switch).  */
char *cmdline_dump_sects = NULL;
unsigned num_cmdline_dump_sects = 0;
d251 2
a252 2
char *dump_sects = NULL;
unsigned int num_dump_sects = 0;
a253 3
#define HEX_DUMP	(1 << 0)
#define DISASS_DUMP	(1 << 1)
#define DEBUG_DUMP	(1 << 2)
d2753 1
d2756 1
a2756 1
  {"unwind",	       no_argument, 0, 'u'},
d2791 4
a2794 1
  -x --hex-dump=<number> Dump the contents of section <number>\n\
d2800 2
a2801 2
  -i --instruction-dump=<number>\n\
                         Disassemble the contents of section <number>\n"));
d2822 1
a2822 1
request_dump (unsigned int section, int type)
d2826 1
a2826 1
      char *new_dump_sects;
d2828 1
a2828 1
      new_dump_sects = calloc (section + 1, 1);
d2835 1
a2835 1
	  memcpy (new_dump_sects, dump_sects, num_dump_sects);
d2853 1
a2853 1
request_dump_byname (const char *section, int type)
d2880 1
a2880 1
	  (argc, argv, "ersuahnldSDAINtgw::x:i:vVWH", options, NULL)) != EOF)
d2958 1
a2958 1
	    request_dump (section, HEX_DUMP);
d2962 8
d3117 3
a3119 5
	    {
	      request_dump (section, DISASS_DUMP);
	      break;
	    }
	  goto oops;
a3130 3
#ifdef SUPPORT_DISASSEMBLY
	oops:
#endif
d4197 1
a4197 1
	    request_dump (i, DEBUG_DUMP);
d4202 1
a4202 1
	request_dump (i, DEBUG_DUMP);
d4204 1
a4204 1
	request_dump (i, DEBUG_DUMP);
d7685 78
a7762 1
dump_section (Elf_Internal_Shdr *section, FILE *file)
d8115 1
a8115 1
	    request_dump (i, cur->type);
d8145 1
a8145 1
	dump_section (section, file);
d8149 3
d9649 1
a9649 1
    memset (dump_sects, 0, num_dump_sects);
d9655 1
a9655 1
	request_dump (num_cmdline_dump_sects, 0);
d9658 2
a9659 1
      memcpy (dump_sects, cmdline_dump_sects, num_cmdline_dump_sects);
d10034 1
a10034 1
      cmdline_dump_sects = malloc (num_dump_sects);
d10039 2
a10040 1
	  memcpy (cmdline_dump_sects, dump_sects, num_dump_sects);
@


1.374
log
@bfd/

2007-08-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf.c: Revert last change.

binutils/

2007-08-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c: Revert last change.

include/elf/

2007-08-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* common.h: Revert last change.
@
text
@d9234 1
d9250 7
d9262 1
a9262 3
  printf ("  %s\t\t0x%08lx\t%s\n",
	  pnote->namesz ? pnote->namedata : "(NONE)",
	  pnote->descsz, nt);
@


1.373
log
@bfd/

2007-08-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf.c (get_segment_type): Change PT_GNU_STACK to PT_GNU_ATTR.
	(bfd_section_from_phdr): Likewise.
	(get_program_header_size): Likewise. Add a PT_GNU_ATTR segment
	if there is an attribute section.
	(_bfd_elf_map_sections_to_segments): Likewise.
	(IS_SECTION_IN_INPUT_SEGMENT): Likewise.

binutils/

2007-08-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (get_segment_type): Change PT_GNU_STACK to
	PT_GNU_ATTR.

include/elf/

2007-08-16  H.J. Lu  <hongjiu.lu@@intel.com>

	* common.h (PT_GNU_STACK): Renamed to ...
	(PT_GNU_ATTR): This.
	(PT_GNU_STACK): New.  Make an alias of PT_GNU_ATTR.
@
text
@d2470 1
a2470 1
    case PT_GNU_ATTR:	return "GNU_ATTR";
@


1.372
log
@	* readelf.c (process_archive): Also skip Irix6-style archive symbol
	tables.
@
text
@d2470 1
a2470 1
    case PT_GNU_STACK:	return "GNU_STACK";
@


1.372.2.1
log
@include/elf/
	* common.h (NT_SPU): Define.
bfd/
	* elf.c (elfcore_grok_spu_note): New function.
	(elfcore_read_notes): Call it.
binutils/
	* readelf.c (process_note): Recognize SPU core file notes.
@
text
@a9233 1
  const char *name = pnote->namesz ? pnote->namedata : "(NONE)";
a9248 7
  else if (strneq (pnote->namedata, "SPU/", 4))
    {
      /* SPU-specific core file notes.  */
      nt = pnote->namedata + 4;
      name = "SPU";
    }

d9254 3
a9256 1
  printf ("  %s\t\t0x%08lx\t%s\n", name, pnote->descsz, nt);
@


1.371
log
@* readelf.c (NUM_ELEM): Remove redundant macro; replace references to it
   with references to ARRAY_SIZE.
  Add support for CR16.
  Fix formatting.
@
text
@d9696 2
a9697 1
  if (const_strneq (arhdr.ar_name, "/               "))
@


1.370
log
@2007-07-09  Roland McGrath  <roland@@redhat.com>

	* readelf.c (get_gnu_elf_note_type): New function.
	(process_note): Use it for "GNU" name.
@
text
@d113 1
a292 2
#define NUM_ELEM(array) 	(sizeof (array) / sizeof ((array)[0]))

d303 2
a304 2
#define streq(a,b)	(strcmp ((a), (b)) == 0)
#define strneq(a,b,n)	(strncmp ((a), (b), (n)) == 0)
d619 1
d1194 4
d1794 1
d5576 1
a5576 1
	  for (cnt = 0; cnt < NUM_ELEM (opts); ++cnt)
d5665 1
a5665 1
	for (cnt = 0; cnt < sizeof (flags) / sizeof (flags[0]); ++cnt)
a8304 1

d8306 2
a8307 3
display_gnu_attribute (unsigned char *p,
		       unsigned char *(*display_proc_gnu_attribute)
			    (unsigned char *, int))
d8324 1
a8324 1
      p += strlen((char *)p) + 1;
d8340 1
a8340 1
      p += strlen ((char *)p) + 1;
d8364 1
d8392 1
a8392 1
      p += strlen ((char *)p) + 1;
d8416 1
d8447 1
a8447 1
      p += strlen ((char *)p) + 1;
d8460 2
a8461 1
process_attributes (FILE *file, const char *public_name,
d8463 2
a8464 3
		    unsigned char *(*display_pub_attribute) (unsigned char *),
		    unsigned char *(*display_proc_gnu_attribute)
			 (unsigned char *, int))
d8484 2
a8486 2
      if (!contents)
	continue;
d8492 1
d8501 1
d8505 1
a8505 1
			  (int)section_len, (int)len);
d8508 1
d8511 2
a8512 1
	      if (public_name && strcmp ((char *)p, public_name) == 0)
d8516 2
a8517 1
	      if (strcmp ((char *)p, "gnu") == 0)
d8521 2
a8522 1
	      namelen = strlen ((char *)p) + 1;
d8525 1
d8531 1
d8536 1
a8536 1
			      (int)size, (int)section_len);
d8539 1
d8543 1
d8558 1
d8572 1
d8594 1
a8594 3
	{
	  printf (_("Unknown format '%c'\n"), *p);
	}
d8596 1
a8596 1
      free(contents);
d8722 1
a8722 3
		  for (fcnt = 0;
		       fcnt < sizeof (l_flags_vals) / sizeof (l_flags_vals[0]);
		       ++fcnt)
d9536 1
a9536 1
  for (i = NUM_ELEM (version_info); i--;)
d9539 1
a9539 1
  for (i = NUM_ELEM (dynamic_info); i--;)
@


1.369
log
@Change sources over to using GPLv3
@
text
@d2795 1
a2795 1
  
d7713 1
a7713 1
  
d9131 21
d9228 4
@


1.368
log
@bfd:
	* elf32-ppc.c (ppc_elf_merge_obj_attributes): New.
	(ppc_elf_merge_private_bfd_data): Call it.

binutils:
	* readelf.c (display_power_gnu_attribute, process_power_specific):
	New.
	(process_arch_specific): Call process_power_specific.

include/elf:
	* ppc.h (Tag_GNU_Power_ABI_FP): Define.

ld/testsuite:
	* ld-powerpc/attr-gnu-4-0.s, ld-powerpc/attr-gnu-4-00.d,
	ld-powerpc/attr-gnu-4-01.d, ld-powerpc/attr-gnu-4-02.d,
	ld-powerpc/attr-gnu-4-1.s, ld-powerpc/attr-gnu-4-10.d,
	ld-powerpc/attr-gnu-4-11.d, ld-powerpc/attr-gnu-4-12.d,
	ld-powerpc/attr-gnu-4-13.d, ld-powerpc/attr-gnu-4-2.s,
	ld-powerpc/attr-gnu-4-20.d, ld-powerpc/attr-gnu-4-21.d,
	ld-powerpc/attr-gnu-4-22.d, ld-powerpc/attr-gnu-4-3.s,
	ld-powerpc/attr-gnu-4-31.d: New.
	* ld-powerpc/powerpc.exp: Run these new tests.
@
text
@d12 1
a12 1
   the Free Software Foundation; either version 2 of the License, or
@


1.367
log
@bfd:
	* elfxx-mips.c (mips_elf_merge_obj_attributes): New.
	(_bfd_mips_elf_merge_private_bfd_data): Call it.

binutils:
	* readelf.c (display_mips_gnu_attribute): New.
	(process_mips_specific): Call process_attributes.

include/elf:
	* mips.h (Tag_GNU_MIPS_ABI_FP): Define.

ld/testsuite:
	* ld-mips-elf/attr-gnu-4-0.s, ld-mips-elf/attr-gnu-4-00.d,
	ld-mips-elf/attr-gnu-4-01.d, ld-mips-elf/attr-gnu-4-02.d,
	ld-mips-elf/attr-gnu-4-03.d, ld-mips-elf/attr-gnu-4-1.s,
	ld-mips-elf/attr-gnu-4-10.d, ld-mips-elf/attr-gnu-4-11.d,
	ld-mips-elf/attr-gnu-4-12.d, ld-mips-elf/attr-gnu-4-13.d,
	ld-mips-elf/attr-gnu-4-14.d, ld-mips-elf/attr-gnu-4-2.s,
	ld-mips-elf/attr-gnu-4-20.d, ld-mips-elf/attr-gnu-4-21.d,
	ld-mips-elf/attr-gnu-4-22.d, ld-mips-elf/attr-gnu-4-23.d,
	ld-mips-elf/attr-gnu-4-3.s, ld-mips-elf/attr-gnu-4-30.d,
	ld-mips-elf/attr-gnu-4-31.d, ld-mips-elf/attr-gnu-4-32.d,
	ld-mips-elf/attr-gnu-4-33.d, ld-mips-elf/attr-gnu-4-4.s,
	ld-mips-elf/attr-gnu-4-41.d: New.
	* ld-mips-elf/mips-elf.exp: Run these new tests.
@
text
@d8350 51
d8594 7
d9378 3
@


1.366
log
@bfd:
	* elf-attrs.c: New.
	* Makefile.am (BFD32_BACKENDS): Add elf-attrs.lo.
	(BFD32_BACKENDS_CFILES): Add elf-attrs.c.
	(elf-attrs.lo): Generate dependencies.
	* Makefile.in: Regenerate.
	* configure.in (elf): Add elf-attrs.lo.
	* configure: Regenerate.
	* elf-bfd.h (struct elf_backend_data): Add entries for object
	attributes.
	(NUM_KNOWN_OBJ_ATTRIBUTES, obj_attribute, obj_attribute_list,
	OBJ_ATTR_PROC, OBJ_ATTR_GNU, OBJ_ATTR_FIRST, OBJ_ATTR_LAST,
	Tag_NULL, Tag_File, Tag_Section, Tag_Symbol, Tag_compatibility):
	New.
	(struct elf_obj_tdata): Add entries for object attributes.
	(elf_known_obj_attributes, elf_other_obj_attributes,
	elf_known_obj_attributes_proc, elf_other_obj_attributes_proc):
	New.
	(bfd_elf_obj_attr_size, bfd_elf_set_obj_attr_contents,
	bfd_elf_get_obj_attr_int, bfd_elf_add_obj_attr_int,
	bfd_elf_add_proc_attr_int, bfd_elf_add_obj_attr_string,
	bfd_elf_add_proc_attr_string, bfd_elf_add_obj_attr_compat,
	bfd_elf_add_proc_attr_compat, _bfd_elf_attr_strdup,
	_bfd_elf_copy_obj_attributes, _bfd_elf_obj_attrs_arg_type,
	_bfd_elf_parse_attributes, _bfd_elf_merge_object_attributes): New.
	* elf.c (_bfd_elf_copy_private_bfd_data): Copy object attributes.
	(bfd_section_from_shdr): Handle attributes sections.
	* elflink.c (bfd_elf_final_link): Handle attributes sections.
	* elfxx-target.h (elf_backend_obj_attrs_vendor,
	elf_backend_obj_attrs_section, elf_backend_obj_attrs_arg_type,
	elf_backend_obj_attrs_section_type): New.
	(elfNN_bed): Update.
	* elf32-arm.c (NUM_KNOWN_ATTRIBUTES, aeabi_attribute,
	aeabi_attribute_list): Remove.
	(struct elf32_arm_obj_tdata): Remove object attributes fields.
	(check_use_blx, bfd_elf32_arm_set_vfp11_fix, using_thumb2,
	elf32_arm_copy_private_bfd_data, elf32_arm_merge_eabi_attributes):
	Update for new object attributes interfaces.
	(uleb128_size, is_default_attr, eabi_attr_size,
	elf32_arm_eabi_attr_size, write_uleb128, write_eabi_attribute,
	elf32_arm_set_eabi_attr_contents, elf32_arm_bfd_final_link,
	elf32_arm_new_eabi_attr, elf32_arm_get_eabi_attr_int,
	elf32_arm_add_eabi_attr_int, attr_strdup,
	elf32_arm_add_eabi_attr_string, elf32_arm_add_eabi_attr_compat,
	copy_eabi_attributes, elf32_arm_parse_attributes): Remove.  Moved
	to generic code in elf-attrs.c.
	(elf32_arm_obj_attrs_arg_type): New.
	(elf32_arm_fake_sections): Do not handle .ARM.attributes.
	(elf32_arm_section_from_shdr): Do not handle SHT_ARM_ATTRIBUTES.
	(bfd_elf32_bfd_final_link): Remove.
	(elf_backend_obj_attrs_vendor, elf_backend_obj_attrs_section,
	elf_backend_obj_attrs_arg_type,
	elf_backend_obj_attrs_section_type): New.
	* elf32-bfin.c (bfin_elf_copy_private_bfd_data): Copy object
	attributes.
	* elf32-frv.c (frv_elf_copy_private_bfd_data): Likewise.
	* elf32-iq2000.c (iq2000_elf_copy_private_bfd_data): Likewise.
	* elf32-mep.c (mep_elf_copy_private_bfd_data): Likewise.
	* elf32-mt.c (mt_elf_copy_private_bfd_data): Likewise.
	* elf32-sh.c (sh_elf_copy_private_data): Likewise.
	* elf64-sh64.c (sh_elf64_copy_private_data_internal): Likewise.

binutils:
	* readelf.c (display_gnu_attribute): New.
	(process_arm_specific): Rearrange as process_attributes.
	(process_arm_specific): Replace by wrapper of process_attributes.

gas:
	* as.c (create_obj_attrs_section): New.
	(main): Call create_obj_attrs_section for ELF.
	* read.c (s_gnu_attribute, skip_whitespace, skip_past_char,
	skip_past_comma, s_vendor_attribute): New.
	(potable): Add gnu_attribute for ELF.
	* read.h (s_vendor_attribute): Declare.
	* config/tc-arm.c (s_arm_eabi_attribute): Replace by wrapper
	round s_vendor_attribute.
	(aeabi_set_public_attributes): Update for new attributes
	interfaces.
	(arm_md_end): Remove attributes contents setting now done
	generically.

include/elf:
	* arm.h (elf32_arm_add_eabi_attr_int,
	elf32_arm_add_eabi_attr_string, elf32_arm_add_eabi_attr_compat,
	elf32_arm_get_eabi_attr_int, elf32_arm_set_eabi_attr_contents,
	elf32_arm_eabi_attr_size, Tag_NULL, Tag_File, Tag_Section,
	Tag_Symbol, Tag_compatibility): Remove.
	* common.h (SHT_GNU_ATTRIBUTES): Define.

ld:
	* emulparams/armelf.sh (OTHER_SECTIONS): Remove .ARM.attributes.
	(ATTRS_SECTIONS): Define.
	* scripttempl/elf.sc, scripttempl/elf32sh-symbian.sc,
	scripttempl/elf_chaos.sc, scripttempl/elfi370.sc,
	scripttempl/elfxtensa.sc: Handle ATTRS_SECTIONS.
@
text
@d8349 54
d8552 3
@


1.365
log
@bfd/
	* elf.c (elf_fake_sections): Adjust test for SHT_NOBITS sections
	created by objcopy --only-keep-debug.
	(_bfd_elf_init_private_section_data): Only change elf_section_type
	if it is SHT_NULL.
binutils/
	* objcopy.c (copy_object): Revert 2007-05-11 change.  Don't
	avoid calling bfd_copy_private_bfd_data for ELF STRIP_NONDEBUG.
	(setup_section): Don't modify flags, and don't avoid calling
	bfd_copy_private_section_data for ELF STRIP_NONDEBUG.
	* readelf.c (process_program_headers): Ignore .dynamic of type
	SHT_NOBITS.
@
text
@d8300 49
d8350 5
a8354 1
process_arm_specific (FILE *file)
d8369 1
a8369 1
      if (sect->sh_type != SHT_ARM_ATTRIBUTES)
d8386 1
d8398 1
a8398 1
	      if (strcmp ((char *)p, "aeabi") == 0)
d8402 4
d8454 7
a8460 1
			p = display_arm_attribute(p);
d8482 7
@


1.364
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d3519 3
@


1.363
log
@	PR gas/3811
	* readelf.c (debug_apply_rela_addends): Do nothing for SH.
@
text
@d44 1
a45 1
#include <sys/types.h>
a46 1
#include <stdio.h>
d76 2
a157 1
#include "bucomm.h"
@


1.362
log
@Use pc-relative relocation instead of an absolute relocation for x86_64-pc-mingw32 target.
@
text
@d7806 4
@


1.361
log
@* readelf.c (dump_section): Also test for SHT_REL sections when producing
  the warning about unapplied relocs.
@
text
@d714 1
a714 1
	  error (_("out of memory parsing relocs"));
d742 1
a742 1
	  error (_("out of memory parsing relocs"));
d786 1
a786 1
	  error (_("out of memory parsing relocs"));
d814 1
a814 1
	  error (_("out of memory parsing relocs"));
d2817 1
a2817 1
	error (_("Out of memory allocating dump request table."));
d2845 1
a2845 1
    error (_("Out of memory allocating dump request table."));
d2849 1
a2849 1
    error (_("Out of memory allocating dump request table."));
d3515 1
a3515 1
		  error (_("no .dynamic section in the dynamic segment"));
d3524 1
a3524 1
		warn (_("the .dynamic section is not contained within the dynamic segment"));
d3526 1
a3526 1
		warn (_("the .dynamic section is not the first section in the dynamic segment."));
d3547 1
a3547 1
		error (_("Internal error: failed to create format string to display program interpreter"));
d5868 1
a5868 1
		error (_("Unable to seek to end of file!"));
d7066 1
a7066 1
	  error (_("Unable to seek to start of dynamic information"));
d7292 1
a7292 1
			    error (_("bad dynamic symbol"));
d7375 1
a7375 1
	  error (_("Out of memory"));
d7391 1
a7391 1
	  error (_("Out of memory"));
d7440 1
a7440 1
	  error (_("Unable to seek to start of dynamic information"));
d7464 1
a7464 1
	  error (_("Unable to seek to start of dynamic information"));
d7494 1
a7494 1
	  error (_("Unable to seek to start of dynamic information"));
d7518 1
a7518 1
	  error (_("Unable to seek to start of dynamic information"));
d7530 1
a7530 1
	  error (_("Out of memory"));
d7555 1
a7555 1
	  error (_("Out of memory"));
d8553 1
a8553 1
	      error (_("Out of memory"));
d8738 1
a8738 1
	  error (_("conflict list found without a dynamic symbol table"));
d8745 1
a8745 1
	  error (_("Out of memory"));
d9702 1
a9702 1
	error (_("Out of memory allocating dump request table."));
@


1.360
log
@top level:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.ac (TOPLEVEL_CONFIGURE_ARGUMENTS): Fix quoting.
	* configure: Regenerate.

bfd:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-pkgversion): New option.
	* configure: Regenerate.
	* Makefile.am (bfdver.h): Substitute for @@bfd_version_package@@.
	* Makefile.in: Regenerate.
	* version.h (BFD_VERSION_STRING): Define using
	@@bfd_version_package@@.

bfd/doc:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* Makefile.in: Regenerate.

binutils:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-bugurl): New option.
	* configure: Regenerate.
	* Makefile.am (REPORT_BUGS_TO): Define.
	(INCLUDES): Define REPORT_BUGS_TO.
	Regenerate dependencies.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* bucomm.h: Remove include of bin-bugs.h.
	* addr2line.c (usage): Don't print empty REPORT_BUGS_TO.
	* ar.c (usage): Pass s to list_supported_targets.  Don't print
	empty REPORT_BUGS_TO.
	* coffdump.c (show_usage): Don't print empty REPORT_BUGS_TO.
	* cxxfilt.c (usage): Print bug url when giving help.
	* dlltool.c (usage): Likewise.
	* dllwrap.c (usage): Likewise.
	* nlmconv.c (show_usage): Don't print empty REPORT_BUGS_TO.
	* nm.c (usage): Likewise.
	* objcopy.c (copy_usage, strip_usage): Likewise.
	* objdump.c (usage): Likewise.
	* readelf.c ((usage): Likewise. Add STREAM argument.  Adjust
	callers.
	* size.c (usage): Don't print empty REPORT_BUGS_TO.
	* srconv.c (show_usage): Likewise.
	* strings.c (usage): Likewise.
	* sysdymp.c (show_usage): Likewise.
	* windres.c (usage): Likewise.

gas:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-bugurl): New option.
	* configure: Regenerate.
	* dep-in.sed: Remove bin-bugs.h.
	* Makefile.am (REPORT_BUGS_TO): Define.
	(INCLUDES): Define REPORT_BUGS_TO.
	(DEP_INCLUDES): Likewise.
	($(OBJS)): No longer depend on bin-bugs.h.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* as.c (show_usage): Don't print empty REPORT_BUGS_TO.
	* as.h: Remove include of bin-bugs.h.

gprof:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-pkgversion, --with-bugurl): New options.
	* configure: Regenerate.
	* Makefile.am (PKGVERSION, REPORT_BUGS_TO): Define.
	(INCLUDES): Define PKGVERSION and REPORT_BUGS_TO.
	Regenerate dependencies.
	* Makefile.in: Regenerate.
	* gprof.c (usage): Don't print empty REPORT_BUGS_TO.
	(main): Include PKGVERSION in version output.
	* gprof.h: Remove include of bin-bugs.h.

include:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* bin-bugs.h: Remove.

ld:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-bugurl): New option.
	* configure: Regenerate.
	* Makefile.am (REPORT_BUGS_TO): Define.
	(INCLUDES): Define REPORT_BUGS_TO.
	Regenerate dependencies.
	* Makefile.in: Regenerate.
	* ld.h: Remove include of bin-bugs.h.
	* lexsup.c (help): Don't print empty REPORT_BUGS_TO.
@
text
@d1791 1
a1791 1
      snprintf (buff, sizeof (buff), _("<unknown>: %x"), e_machine);
d7700 1
a7700 1
      if (relsec->sh_type != SHT_RELA
@


1.359
log
@PR gas/3800
* readelf.c: Include elf/h8.h twice.  The first time in order to get the reloc
  numbers, the second time in order to get the reloc decoder function.
  (dump_section): Tell the user if the section being displayed has unprocessed
  relocs associated with it.
  (get_reloc_size): New function - returns the size of a reloc.
  (debug_apply_rela_addends): Use get_reloc_size().
* dwarf.c (read_and_display_attr_value): Extend number of languages known for
  the DW_AT_language attribute.
  (process_debug_info): Display the attribute offset before decoding the
  attribute, in case there are problems.
@
text
@d2757 1
a2757 1
usage (void)
d2759 3
a2761 3
  fprintf (stdout, _("Usage: readelf <option(s)> elf-file(s)\n"));
  fprintf (stdout, _(" Display information about the contents of ELF format files\n"));
  fprintf (stdout, _(" Options are:\n\
d2785 1
a2785 1
  fprintf (stdout, _("\
d2789 1
a2789 1
  fprintf (stdout, _("\
d2795 3
a2797 1
  fprintf (stdout, _("Report bugs to %s\n"), REPORT_BUGS_TO);
d2799 1
a2799 1
  exit (0);
d2863 1
a2863 1
    usage ();
d2877 1
a2877 1
	  usage ();
d3118 1
a3118 1
	  usage ();
d3126 1
a3126 1
    usage ();
d3130 1
a3130 1
      usage ();
@


1.358
log
@2007-02-05  Dave Brolley  <brolley@@redhat.com>

        * readelf.c (dump_relocations): Don't check for
        (rtype == NULL && type == R_RELC).

2007-02-05  Dave Brolley  <brolley@@redhat.com>

        * Contribute the following changes:
        2003-10-29  Dave Brolley  <brolley@@redhat.com>

        * configure.in: Define SKIP_ZEROES and SKIP_ZEROES_AT_END for mep.
        * configure: Regenerated.

        2001-04-03  Ben Elliston  <bje@@redhat.com>

        * readelf.c: Include "elf/mep.h".
        (guess_is_rela): Handle EM_CYGNUS_MEP.
        (get_machine_name): Ditto.
        (dump_relocations): Ditto.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005, 2006
d83 18
d7665 1
d7689 20
d7750 1
d7754 37
a7799 2
  /* FIXME: The relocation field size is relocation type dependent.  */
  unsigned int reloc_size = 4;
a7803 3
  if (section->sh_size < reloc_size)
    return 1;

d7831 10
@


1.357
log
@	* ar.c (open_inarch): Check fwrite return.  Use size_t.
	(extract_file): Likewise.  Remove test for "negative" file size.
	* readelf.c (process_program_headers): Check fscanf return.
@
text
@d115 1
d619 1
d1172 4
d1771 1
d6854 2
@


1.356
log
@bfd/
	* archures.c (bfd_mach_cpu32_fido): Rename to bfd_mach_fido.
	* bfd-in2.h: Regenerate.
	* cpu-m68k.c (arch_info_struct): Use bfd_mach_fido instead of
	bfd_mach_cpu32_fido.
	(m68k_arch_features): Use fido_a instead of cpu32.
	(bfd_m68k_compatible): Reject the combination of Fido and
	ColdFire.  Accept the combination of CPU32 and Fido with a
	warning.
	* elf32-m68k.c (elf32_m68k_object_p,
	elf32_m68k_merge_private_bfd_data,
	elf32_m68k_print_private_bfd_data): Treat Fido as an
	architecture by itself.

binutils/
	* readelf.c (get_machine_flags): Treat Fido as an architecture
	by itself.

gas/
	* config/tc-m68k.c (m68k_archs, m68k_cpus): Treat Fido as an
	architecture by itself.
	(m68k_ip): Don't issue a warning for tbl instructions on fido.
	(m68k_elf_final_processing): Treat Fido as an architecture by
	itself.

include/elf/
	* m68k.h (EF_M68K_FIDO): New.
	(EF_M68K_ARCH_MASK): OR EF_M68K_FIDO.
	(EF_M68K_CPU32_FIDO_A, EF_M68K_CPU32_MASK): Remove.

include/opcode/
	* m68k.h (m68010up): OR fido_a.

opcodes/
	* m68k-opc.c (m68k_opcodes): Replace cpu32 with
	cpu32 | fido_a except on tbl instructions.
@
text
@d3523 2
a3524 1
	      fscanf (file, fmt, program_interpreter);
@


1.355
log
@	* readelf.c (dump_section): Don't print 32-bit values, which
	were done incorrectly for little-endian.  Instead print bytes.
@
text
@d2018 3
a2020 5
	    {
	      strcat (buf, ", cpu32");
	      if (e_flags & EF_M68K_CPU32_FIDO_A)
		strcat (buf, ", fido_a");
	    }
@


1.354
log
@bfd/
	* archures.c (bfd_mach_cpu32_fido): New.
	(bfd_mach_mcf_isa_a_nodiv, bfd_mach_mcf_isa_a,
	bfd_mach_mcf_isa_a_mac, bfd_mach_mcf_isa_a_emac,
	bfd_mach_mcf_isa_aplus, bfd_mach_mcf_isa_aplus_mac,
	bfd_mach_mcf_isa_aplus_emac, bfd_mach_mcf_isa_b_nousp,
	bfd_mach_mcf_isa_b_nousp_mac, bfd_mach_mcf_isa_b_nousp_emac,
	bfd_mach_mcf_isa_b, bfd_mach_mcf_isa_b_mac,
	bfd_mach_mcf_isa_b_emac, bfd_mach_mcf_isa_b_float,
	bfd_mach_mcf_isa_b_float_mac, bfd_mach_mcf_isa_b_float_emac):
	Increment the defined values.
	* bfd-in2.h: Regenerate.
	* cpu-m68k.c (arch_info_struct): Add en entry for
	bfd_mach_cpu32_fido.
	* elf32-m68k.c (elf32_m68k_object_p): Handle
	EF_M68K_CPU32_FIDO_A.
	(elf32_m68k_merge_private_bfd_data): Use EF_M68K_CPU32_MASK.
	(elf32_m68k_print_private_bfd_data): Handle
	EF_M68K_CPU32_FIDO_A.

binutils/
	* readelf.c (get_machine_flags): Handle EF_M68K_CPU32_FIDO_A.

gas/
	* config/tc-m68k.c (cpu_of_arch): Add fido.
	(m68k_archs, m68k_cpu): Add entries for fido.
	(m68k_elf_final_processing): Handle EF_M68K_CPU32_FIDO_A.

include/elf/
	* m68k.h (EF_M68K_CPU32_FIDO_A, EF_M68K_CPU32_MASK): New.

include/opcode/
	* m68k.h (fido_a): New.
@
text
@d7674 1
a7674 1
      switch (elf_header.e_ident[EI_DATA])
d7676 4
a7679 21
	default:
	case ELFDATA2LSB:
	  for (j = 15; j >= 0; j --)
	    {
	      if (j < lbytes)
		printf ("%2.2x", data[j]);
	      else
		printf ("  ");

	      if (!(j & 0x3))
		printf (" ");
	    }
	  break;

	case ELFDATA2MSB:
	  for (j = 0; j < 16; j++)
	    {
	      if (j < lbytes)
		printf ("%2.2x", data[j]);
	      else
		printf ("  ");
d7681 2
a7682 4
	      if ((j & 3) == 3)
		printf (" ");
	    }
	  break;
@


1.353
log
@bfd/
	* elf32-m68k.c (elf32_m68k_object_p,
	elf32_m68k_print_private_bfd_data): Use EF_M68K_ARCH_MASK to
	extract architecture mask.

include/elf/
	* m68k.h (EF_M68K_ARCH_MASK): New.
@
text
@d2018 5
a2022 1
	    strcat (buf, ", cpu32");
@


1.352
log
@bfd/
	* elf32-m68k.c: Update uses of EF_M68K_*.

binutils/
	* readelf.c: Update uses of EF_M68K_*.

gas/
	* config/tc-m68k.c: Update uses of EF_M68K_*.

include/elf
	* m68k.h (EF_M68K_ISA_MASK, EF_M68K_ISA_A_NODIV,
	EF_M68K_ISA_A, EF_M68K_ISA_A_PLUS, EF_M68K_ISA_B_NOUSP,
	EF_M68K_ISA_B, EF_M68K_ISA_C, EF_M68K_MAC_MASK, EF_M68K_MAC,
	EF_M68K_EMAC, EF_M68K_EMAC_B, EF_M68K_FLOAT): Rename to
	EF_M68K_CF_ISA_MASK, EF_M68K_CF_ISA_A_NODIV, EF_M68K_CF_ISA_A,
	EF_M68K_CF_ISA_A_PLUS, EF_M68K_CF_ISA_B_NOUSP,
	EF_M68K_CF_ISA_B, EF_M68K_CF_ISA_C, EF_M68K_CF_MAC_MASK,
	EF_M68K_CF_MAC, EF_M68K_CF_EMAC, EF_M68K_CF_EMAC_B,
	EF_M68K_CF_FLOAT, respectively.
@
text
@d2015 3
a2017 1
	  if (e_flags & EF_M68K_CPU32)
d2019 1
a2019 3
	  if (e_flags & EF_M68K_M68000)
	    strcat (buf, ", m68000");
	  if (e_flags & EF_M68K_CF_ISA_MASK)
@


1.351
log
@2006-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/3384
	* configure.in (AC_CHECK_HEADERS): Add limits.h and sys/param.h.
	* configure: Regenerated.
	* config.in: Likewise.

	* readelf.c: Include <limits.h> and <sys/param.h> for PATH_MAX.
	(program_interpreter): Allocate PATH_MAX bytes instead of 64.
	(process_program_headers): Don't assume that program interpreter
	is shorter than 64 characters.
@
text
@d2019 1
a2019 1
	  if (e_flags & EF_M68K_ISA_MASK)
d2025 1
a2025 1
	      switch (e_flags & EF_M68K_ISA_MASK)
d2027 1
a2027 1
		case EF_M68K_ISA_A_NODIV:
d2031 1
a2031 1
		case EF_M68K_ISA_A:
d2034 1
a2034 1
		case EF_M68K_ISA_A_PLUS:
d2037 1
a2037 1
		case EF_M68K_ISA_B_NOUSP:
d2041 1
a2041 1
		case EF_M68K_ISA_B:
d2049 1
a2049 1
	      if (e_flags & EF_M68K_FLOAT)
d2051 1
a2051 1
	      switch (e_flags & EF_M68K_MAC_MASK)
d2056 1
a2056 1
		case EF_M68K_MAC:
d2059 1
a2059 1
		case EF_M68K_EMAC:
@


1.350
log
@New Cell SPU port.
@
text
@d50 19
d157 1
a157 1
static char program_interpreter[64];
d3514 6
d3521 1
a3521 1
	      fscanf (file, "%63s", program_interpreter);
@


1.349
log
@2006-10-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (debug_apply_rela_addends): Don't ignore relocation
	against symbols without type.
@
text
@d110 1
a558 1
    case EM_ARM:
d562 1
a562 4
    case EM_DLX:
    case EM_OPENRISC:
    case EM_OR32:
    case EM_CYGNUS_M32R:
d565 1
d568 3
d576 8
a583 10
    case EM_H8_300:
    case EM_H8_300H:
    case EM_H8S:
    case EM_SPARC32PLUS:
    case EM_SPARCV9:
    case EM_SPARC:
    case EM_PPC:
    case EM_PPC64:
    case EM_V850:
    case EM_CYGNUS_V850:
a585 4
    case EM_MN10200:
    case EM_CYGNUS_MN10200:
    case EM_MN10300:
    case EM_CYGNUS_MN10300:
d589 9
a597 2
    case EM_SH:
    case EM_ALPHA:
a598 8
    case EM_IA_64:
    case EM_AVR:
    case EM_AVR_OLD:
    case EM_CRIS:
    case EM_860:
    case EM_X86_64:
    case EM_S390:
    case EM_S390_OLD:
d600 4
d606 15
a621 5
    case EM_CRX:
    case EM_VAX:
    case EM_IP2K:
    case EM_IP2K_OLD:
    case EM_IQ2000:
a623 6
    case EM_M32R:
    case EM_M32C:
    case EM_MT:
    case EM_BLACKFIN:
    case EM_NIOS32:
    case EM_ALTERA_NIOS2:
d626 6
a632 1
    case EM_PCP:
d635 1
a635 2
    case EM_STARCORE:
    case EM_ME16:
d637 2
a638 2
    case EM_TINYJ:
    case EM_FX66:
d640 1
a640 5
    case EM_ST7:
    case EM_68HC16:
    case EM_68HC11:
    case EM_68HC08:
    case EM_68HC05:
d642 1
a642 1
    case EM_ST19:
d977 4
d1647 1
@


1.348
log
@Add support for Score target.
@
text
@d7750 4
d7783 1
@


1.347
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d76 1
d90 1
d107 1
a113 2
#include "elf/crx.h"
#include "elf/iq2000.h"
d570 1
d1104 4
d1441 17
d1565 3
d1722 1
@


1.346
log
@PR binutils/3146
* readelf.c (dump_relocations): Check for a NULL value in rtype before using it.
@
text
@d266 1
a1138 1

d1971 1
a1971 1
      
a2051 1

d4072 1
a4072 1
	       && strneq (name, ".debug_", 7))
d4092 1
a4092 1
	       && strneq (name, ".gnu.linkonce.wi.", 17))
d4928 1
a4928 1
	  if (! strneq (relname, "R_IA64_SEGREL", 13))
d5341 1
a5341 1
	  if (strncmp (relname, "R_PARISC_SEGREL", 15) != 0)
d7828 1
a7828 1
  if (strneq (name, ".gnu.linkonce.wi.", 17))
d8873 1
a8873 1
  else if (strneq (pnote->namedata, "NetBSD-CORE", 11))
d9321 1
a9321 1
  if (memcmp (arhdr.ar_name, "/               ", 16) == 0)
d9343 1
a9343 1
  if (memcmp (arhdr.ar_name, "//              ", 16) == 0)
@


1.345
log
@	* readelf.c (dump_relocations): Handle MIPS-specific
	SHN_MIPS_SCOMMON and SHN_MIPS_SUNDEFINED.
	(get_symbol_index_type): Similarly.
@
text
@d1151 1
d1250 3
a1252 1
      if (elf_header.e_machine == EM_SPARCV9 && streq (rtype, "R_SPARC_OLO10"))
@


1.344
log
@include/
	* bfdlink.h (struct bfd_link_info): Add emit_hash and
	emit_gnu_hash bitfields.
include/elf/
	* common.h (SHT_GNU_HASH, DT_GNU_HASH): Define.
ld/
	* scripttempl/elf.sc: Add .gnu.hash section.
	* emultempl/elf32.em (OPTION_HASH_STYLE): Define.
	(gld${EMULATION_NAME}_add_options): Register --hash-style option.
	(gld${EMULATION_NAME}_handle_option): Handle it.
	(gld${EMULATION_NAME}_list_options): Document it.
	* ldmain.c (main): Initialize emit_hash and emit_gnu_hash.
	* ld.texinfo: Document --hash-style option.
bfd/
	* elf.c (_bfd_elf_print_private_bfd_data): Handle DT_GNU_HASH.
	(bfd_section_from_shdr, elf_fake_sections, assign_section_numbers):
	Handle SHT_GNU_HASH.
	(special_sections_g): Include .gnu.hash section.
	(bfd_elf_gnu_hash): New function.
	* elf-bfd.h (bfd_elf_gnu_hash, _bfd_elf_hash_symbol): New prototypes.
	(struct elf_backend_data): Add elf_hash_symbol method.
	* elflink.c (_bfd_elf_link_create_dynamic_sections): Create .hash
	only if info->emit_hash, create .gnu.hash section if
	info->emit_gnu_hash.
	(struct collect_gnu_hash_codes): New type.
	(elf_collect_gnu_hash_codes, elf_renumber_gnu_hash_syms,
	_bfd_elf_hash_symbol): New functions.
	(compute_bucket_count): Don't compute HASHCODES array, instead add
	that and NSYMS as arguments.  Use bed->s->sizeof_hash_entry
	instead of bed->s->arch_size / 8.  Fix .hash size estimation.
	When not optimizing, use the number of hashed symbols rather than
	dynsymcount.
	(bfd_elf_size_dynamic_sections): Only add DT_HASH if info->emit_hash,
	and ADD DT_GNU_HASH if info->emit_gnu_hash.
	(bfd_elf_size_dynsym_hash_dynstr): Size .hash only if info->emit_hash,
	adjust compute_bucket_count caller.  Create and populate .gnu.hash
	section if info->emit_gnu_hash.
	(elf_link_output_extsym): Only populate .hash section if
	finfo->hash_sec != NULL.
	(bfd_elf_final_link): Adjust assertion.  Handle DT_GNU_HASH.
	* elfxx-target.h (elf_backend_hash_symbol): Define if not yet defined.
	(elfNN_bed): Add elf_backend_hash_symbol.
	* elf64-x86-64.c (elf64_x86_64_hash_symbol): New function.
	(elf_backend_hash_symbol): Define.
	* elf32-i386.c (elf_i386_hash_symbol): New function.
	(elf_backend_hash_symbol): Define.
binutils/
	* readelf.c (get_dynamic_type): Handle DT_GNU_HASH.
	(get_section_type_name): Handle SHT_GNU_HASH.
	(dynamic_info_DT_GNU_HASH): New variable.
	(process_dynamic_section): Handle DT_GNU_HASH.
	(process_symbol_table): Print also DT_GNU_HASH histogram.
ld/testsuite/
	* ld-powerpc/tlsso32.r: Adjust.
	* ld-powerpc/tlsso32.d: Adjust.
	* ld-powerpc/tlsso32.g: Adjust.
	* ld-powerpc/tlsso.r: Adjust.
	* ld-powerpc/tlsso.g: Adjust.
	* ld-powerpc/tlstocso.g: Adjust.
@
text
@d1209 6
d6881 6
@


1.343
log
@* readelf.c (process_section_headers): Add H8/300 support.
@
text
@d138 1
d1505 1
d2576 1
d6251 9
d6935 3
d7317 160
@


1.342
log
@	* readelf.c (arm_attr_tag_VFP_arch): Add VFPv3.
@
text
@d3974 17
@


1.341
log
@PR 2257
* elfcode.h (elf_object_p): Allow files with corrupt e_shstrndx fields to
  still be handled as ELF files.
* readelf.c (SECTION_NAME): Cope with a missing string table.
  (process_file_header): Cope with a corrupt e_shstrndx field.
  (process_section_headers): Correctly handle an e_shstrndx value of SHF_UNDEF.
@
text
@d7747 2
a7748 1
static const char *arm_attr_tag_VFP_arch[] = {"No", "VFPv1", "VFPv2"};
@


1.340
log
@2006-03-10  Paul Brook  <paul@@codesourcery.com>

bfd/
	* elf32-arm.c (INTERWORK_FLAG): Handle EABIv5.
	(elf32_arm_print_private_bfd_data): Ditto.
binutils/
	* readelf.c (decode_ARM_machine_flags):  Handle EABIv5.
gas/
	* config/tc-arm.c (md_begin): Handle EABIv5.
	(arm_eabis): Add EF_ARM_EABI_VER5.
	* doc/c-arm.texi: Document -meabi=5.
include/elf/
	* arm.h (EF_ARM_EABI_VER5): Define.
@
text
@d225 5
a229 3
#define SECTION_NAME(X)	((X) == NULL ? "<none>" : \
			 ((X)->sh_name >= string_table_length \
			  ? "<corrupt>" : string_table + (X)->sh_name))
d3147 5
d3161 5
d3935 2
a3936 1
  if (SECTION_HEADER_INDEX (elf_header.e_shstrndx) < elf_header.e_shnum)
@


1.340.2.1
log
@	* binutils/readelf.c (arm_attr_tag_VFP_arch): Add VFPv3.

	* gas/config/tc-arm.c (limits.h): Include.
	(fpu_arch_vfp_v3, fpu_vfp_ext_v3, fpu_neon_ext_v1)
	(fpu_vfp_v3_or_neon_ext): Declare constants.
	(neon_el_type): New enumeration of types for Neon vector elements.
	(neon_type_el): New struct. Define type and size of a vector element.
   	(NEON_MAX_TYPE_ELS): Define constant. The maximum number of types per
	instruction.
	(neon_type): Define struct. The type of an instruction.
	(arm_it): Add 'vectype' for the current instruction.
	(isscalar, immisalign, regisimm, isquad): New predicates for operands.
	(vfp_sp_reg_pos): Rename to...
	(vfp_reg_pos): ...this, and add VFP_REG_Dd, VFP_REG_Dm, VFP_REG_Dn
	tags.
	(arm_reg_type): Add REG_TYPE_NQ (Neon Q register) and REG_TYPE_NDQ
	(Neon D or Q register).
	(reg_expected_msgs): Sync with above. Allow VFD to mean VFP or Neon
	D register.
	(GE_OPT_PREFIX_BIG): Define constant, for use in...
	(my_get_expression): Allow above constant as argument to accept
	64-bit constants with optional prefix.
	(arm_reg_parse): Add extra argument to return the specific type of
	register in when either a D or Q register (REG_TYPE_NDQ) is requested.
	Can be NULL.
	(parse_scalar): New function. Parse Neon scalar (vector reg and index).
	(parse_reg_list): Update for new arm_reg_parse args.
	(parse_vfp_reg_list): Allow parsing of Neon D/Q register lists.
	(parse_neon_el_struct_list): New function. Parse element/structure
	register lists for VLD<n>/VST<n> instructions.
	(s_arm_unwind_save_vfp): Update for new parse_vfp_reg_list args.
	(s_arm_unwind_save_mmxwr): Likewise.
	(s_arm_unwind_save_mmxwcg): Likewise.
	(s_arm_unwind_movsp): Likewise.
	(s_arm_unwind_setfp): Likewise.
	(parse_big_immediate): New function. Parse an immediate, which may
	be 64 bits wide. Put results in inst.operands[i].
	(parse_shift): Update for new arm_reg_parse args.
	(parse_address): Likewise. Add parsing of alignment specifiers.
	(parse_neon_mov): Parse the operands of a VMOV instruction.
	(operand_parse_code): Add OP_RND, OP_RNQ, OP_RNDQ, OP_RNSC,
	OP_NRDLST, OP_NSTRLST, OP_NILO, OP_RNDQ_I0, OP_RR_RNSC,
	OP_RNDQ_RNSC, OP_RND_RNSC, OP_VMOV, OP_RNDQ_IMVNb, OP_RNDQ_I63b,
	OP_I0, OP_I16z, OP_I32z, OP_I64, OP_I64z, OP_oI32b, OP_oRND,
	OP_oRNQ, OP_oRNDQ.
	(parse_operands): Handle new codes above.
	(encode_arm_vfp_sp_reg): Rename to...
	(encode_arm_vfp_reg): ...this. Handle D regs (0-31) too. Complain if
	selected VFP version only supports D0-D15.
	(do_vfp_sp_monadic, do_vfp_sp_dyadic, do_vfp_sp_compare_z)
	(do_vfp_dp_sp_cvt, do_vfp_reg_from_sp, do_vfp_reg2_from_sp2)
	(do_vfp_sp_from_reg, do_vfp_sp2_from_reg2, do_vfp_sp_ldst)
	(do_vfp_dp_ldst, vfp_sp_ldstm, vfp_dp_ldstm): Update for new
	encode_arm_vfp_reg name, and allow 32 D regs.
	(do_vfp_dp_rd_rm, do_vfp_dp_rn_rd, do_vfp_dp_rd_rn)
	(do_vfp_dp_rd_rn_rm, do_vfp_rm_rd_rn): New functions to encode VFP
	insns allowing 32 D regs.
	(do_vfp_sp_const, do_vfp_dp_const, vfp_conv, do_vfp_sp_conv_16)
	(do_vfp_dp_conv_16, do_vfp_sp_conv_32, do_vfp_dp_conv_32): Handle
	constant-load and conversion insns introduced with VFPv3.
	(neon_tab_entry): New struct.
	(NEON_ENC_TAB): Bit patterns for overloaded Neon instructions, and
	those which are the targets of pseudo-instructions.
	(neon_opc): Enumerate opcodes, use as indices into...
	(neon_enc_tab): ...this. Hold data from NEON_ENC_TAB.
	(NEON_ENC_INTEGER, NEON_ENC_ARMREG, NEON_ENC_POLY, NEON_ENC_FLOAT)
	(NEON_ENC_SCALAR, NEON_ENC_IMMED, NEON_ENC_INTERLV, NEON_ENC_LANE)
	(NEON_ENC_DUP): Define meaningful helper macros to look up values in
	neon_enc_tab.
	(neon_shape): Enumerate shapes (permitted register widths, etc.) for
	Neon instructions.
	(neon_type_mask): New. Compact type representation for type
	checking.
	(N_SU_ALL, N_SU_32, N_SU_16_64, N_SUF_32, N_I_ALL, N_IF_32): Common
	permitted type combinations.
	(N_IGNORE_TYPE): New macro.
	(neon_check_shape): New function. Check an instruction shape for
	multiple alternatives. Return the specific shape for the current
	instruction.
	(neon_modify_type_size): New function. Modify a vector type and
	size, depending on the bit mask in argument 1.
	(neon_type_promote): New function. Convert a given "key" type (of an
	operand) into the correct type for a different operand, based on a bit
	mask.
	(type_chk_of_el_type): New function. Convert a type and size into the
	compact representation used for type checking.
	(el_type_of_type_ckh): New function. Reverse of above (only when a
	single bit is set in the bit mask).
	(modify_types_allowed): New function. Alter a mask of allowed types
	based on a bit mask of modifications.
	(neon_check_type): New function. Check the type of the current
	instruction against the variable argument list. The "key" type of the
	instruction is returned.
	(neon_dp_fixup): New function. Fill in and modify instruction bits for
	a Neon data-processing instruction depending on whether we're in ARM
	mode or Thumb-2 mode.
	(neon_logbits): New function.
	(neon_three_same, neon_two_same, do_neon_dyadic_i_su)
	(do_neon_dyadic_i64_su, neon_imm_shift, do_neon_shl_imm)
	(do_neon_qshl_imm, neon_cmode_for_logic_imm)
	(neon_bits_same_in_bytes, neon_squash_bits, neon_is_quarter_float)
	(neon_qfloat_bits, neon_cmode_for_move_imm, neon_write_immbits)
	(neon_invert_size, do_neon_logic, do_neon_bitfield, neon_dyadic)
	(do_neon_dyadic_if_su, do_neon_dyadic_if_su_d, do_neon_dyadic_if_i)
	(do_neon_dyadic_if_i_d, do_neon_addsub_if_i, neon_exchange_operands)
	(neon_compare, do_neon_cmp, do_neon_cmp_inv, do_neon_ceq)
	(neon_scalar_for_mul, neon_mul_mac, do_neon_mac_maybe_scalar)
	(do_neon_tst, do_neon_mul, do_neon_qdmulh, do_neon_fcmp_absolute)
	(do_neon_fcmp_absolute_inv, do_neon_step, do_neon_abs_neg)
	(do_neon_sli, do_neon_sri, do_neon_qshlu_imm, do_neon_qmovn)
	(do_neon_qmovun, do_neon_rshift_sat_narrow)
	(do_neon_rshift_sat_narrow_u, do_neon_movn, do_neon_rshift_narrow)
	(do_neon_shll, neon_cvt_flavour, do_neon_cvt, neon_move_immediate)
	(do_neon_mvn, neon_mixed_length, do_neon_dyadic_long, do_neon_abal)
	(neon_mac_reg_scalar_long, do_neon_mac_maybe_scalar_long)
	(do_neon_dyadic_wide, do_neon_vmull, do_neon_ext, do_neon_rev)
	(do_neon_dup, do_neon_mov, do_neon_rshift_round_imm, do_neon_movl)
	(do_neon_trn, do_neon_zip_uzp, do_neon_sat_abs_neg)
	(do_neon_pair_long, do_neon_recip_est, do_neon_cls, do_neon_clz)
	(do_neon_cnt, do_neon_swp, do_neon_tbl_tbx, do_neon_ldm_stm)
	(do_neon_ldr_str, do_neon_ld_st_interleave, neon_alignment_bit)
	(do_neon_ld_st_lane, do_neon_ld_dup, do_neon_ldx_stx): New
	functions. Neon bit encoding and encoding helpers.
	(parse_neon_type): New function. Parse Neon type specifier.
	(opcode_lookup): Allow parsing of Neon type specifiers.
	(REGNUM2, REGSETH, REGSET2): New macros.
	(reg_names): Add new VFPv3 and Neon registers.
	(NUF, nUF, NCE, nCE): New macros for opcode table.
	(insns): More VFP registers allowed in fcpyd, fmdhr, fmdlr, fmrdh,
	fmrdl, fabsd, fnegd, fsqrtd, faddd, fsubd, fmuld, fdivd, fmacd,
	fmscd, fnmuld, fnmacd, fnmscd, fcmpd, fcmpzd, fcmped, fcmpezd,
	fmdrr, fmrrd. Add Neon instructions vaba, vhadd, vrhadd, vhsub,
	vqadd, vqsub, vrshl, vqrshl, vshl, vqshl{u}, vand, vbic, vorr, vorn,
	veor, vbsl, vbit, vbif, vabd, vmax, vmin, vcge, vcgt, vclt, vcle,
	vceq, vpmax, vpmin, vmla, vmls, vpadd, vadd, vsub, vtst, vmul,
	vqdmulh, vqrdmulh, vacge, vacgt, vaclt, vacle, vrecps, vrsqrts,
	vabs, vneg, v{r}shr,  v{r}sra, vsli, vsri, vqshrn, vq{r}shr{u}n,
	v{r}shrn, vshll, vcvt, vmov, vmvn, vabal, vabdl, vaddl, vsubl,
	vmlal, vmlsl, vaddw, vsubw, v{r}addhn, v{r}subhn, vqdmlal, vqdmlsl,
	vqdmull, vmull, vext, vrev64, vrev32, vrev16, vdup, vmovl, v{q}movn,
	vzip, vuzp, vqabs, vqneg, vpadal, vpaddl, vrecpe, vrsqrte, vcls,
	vclz, vcnt, vswp, vtrn, vtbl, vtbx, vldm, vstm, vldr, vstr,
	vld[1234], vst[1234], fconst[sd], f[us][lh]to[sd], fto[us][lh][sd].
	(tc_arm_regname_to_dw2regnum): Update for arm_reg_parse args.
	(arm_cpu_option_table): Add Neon and VFPv3 to Cortex-A8.
	(arm_option_cpu_value): Add vfp3 and neon.
	(aeabi_set_public_attributes): Support VFPv3 and NEON attributes.
	Fix VFPv1 attribute.

	* gas/testsuite/gas/arm/copro.s: Avoid ldcl which encodes as a bad Neon
	instruction.
	* gas/testsuite/gas/arm/copro.d: Update accordingly.
	* gas/testsuite/gas/arm/neon-cond.s: New test. Conditional Neon opcodes
	in ARM mode.
	* gas/testsuite/gas/arm/neon-cond.d: Expected results of above.
	* gas/testsuite/gas/arm/neon-cov.s: New test. Coverage of Neon
	instructions.
	* gas/testsuite/gas/arm/neon-cov.d: Expected results of above.
	* gas/testsuite/gas/arm/neon-ldst-es.s: New test. Element and structure
	loads and stores.
	* gas/testsuite/gas/arm/neon-ldst-es.d: Expected results of above.
	* gas/testsuite/gas/arm/neon-ldst-rm.s: New test. Single and multiple
	register loads and stores.
	* gas/testsuite/gas/arm/neon-ldst-rm.d: Expected results of above.
	* gas/testsuite/gas/arm/neon-omit.s: New test. Omission of optional
	operands.
	* gas/testsuite/gas/arm/neon-omit.d: Expected results of above.
	* gas/testsuite/gas/arm/vfp1.d: Expect Neon syntax for some VFP
	instructions.
	* gas/testsuite/gas/arm/vfp1_t2.d: Likewise.
	* gas/testsuite/gas/arm/vfp1xD.d: Likewise.
	* gas/testsuite/gas/arm/vfp1xD_t2.d: Likewise.
	* gas/testsuite/gas/arm/vfp2.d: Likewise.
	* gas/testsuite/gas/arm/vfp2_t2.d: Likewise.
	* gas/testsuite/gas/arm/vfp3-32drs.s: New test. Extended D register
	range for VFP instructions.
	* gas/testsuite/gas/arm/vfp3-32drs.d: Expected results of above.
	* gas/testsuite/gas/arm/vfp3-const-conv.s: New test. VFPv3
	constant-load and conversion instructions.
	* gas/testsuite/gas/arm/vfp3-const-conv.d: Expected results of above.

	* include/opcode/arm.h (FPU_VFP_EXT_V3): Define constant.
	(FPU_NEON_EXT_V1): Likewise.
	(FPU_VFP_HARD): Update.
	(FPU_VFP_V3): Define macro.
	(FPU_ARCH_VFP_V3, FPU_ARCH_VFP_V3_PLUS_NEON_V1): Define macros.

	* opcodes/arm-dis.c (coprocessor_opcodes): Add %A, %B, %k,
	convert %<code>[zy] into %[zy]<code>.  Expand meaning of
	%<bitfield>['`?].
	Add unified load/store instruction names.
	(neon_opcode_table): New.
	(arm_opcodes): Expand meaning of %<bitfield>['`?].
	(arm_decode_bitfield): New.
	(print_insn_coprocessor): Add pc argument. Add %A & %B specifiers.
	Use arm_decode_bitfield and adjust numeric specifiers.
	Adjust %z & %y.
	(print_insn_neon): New.
	(print_insn_arm): Adjust print_insn_coprocessor call. Call
	print_insn_neon. Use arm_decode_bitfield and adjust numeric specifiers.
	(print_insn_thumb32): Likewise.
@
text
@d7734 1
a7734 2
/* FIXME: VFPv3 encoding was extrapolated!  */
static const char *arm_attr_tag_VFP_arch[] = {"No", "VFPv1", "VFPv2", "VFPv3"};
@


1.340.2.2
log
@	binutils/
	* Makefile.am: Rebuild dependencies.
	(REPORT_BUGS_TO): Always defined.
	(INCLUDES): Adjust.
	* Makefile.in: Rebuilt.
	* configure.in (REPORT_BUGS_TO): Provide default value.
	* configure: Rebuilt.
	* bucomm.h: Remove bin-bugs.h.
	* addr2line.c (usage): Don't print empty REPORT_BUGS_TO.
	* coffdump.c (show_usage): Likewise.
	* cxxfilt.c (usage): Likewise.
	* nlmconv.c (show_usage): Likewise.
	* nm.c (usage): Likewise.
	* objcopy.c (copy_usage, strip_usage): Likewise.
	* objdump.c (usage): Likewise.
	* size.c (usage): Likewise.
	* srconv.c (show_usage): Likewise.
	* string.c (usage): Likewise.
	* sysdymp.c (show_usage): Likewise.
	* windres.c (usage): Likewise.
	* readelf (usage): Likewise. Add STREAM argument.  Adjust callers.

	gas/
	* Makefile.am: Rebuild dependencies.
	(REPORT_BUGS_TO): Always defined.
	(INCLUDES): Adjust.
	* Makefile.in: Rebuilt.
	* configure.in (REPORT_BUGS_TO): Provide default value.
	* configure: Rebuilt.
	* as.c (show_usage): Don't print empty REPORT_BUGS_TO.
	* as.h: Remove bin-bugs.h.

	ld/
	* Makefile.am: Rebuild dependencies.
	(REPORT_BUGS_TO): Always defined.
	(INCLUDES): Adjust.
	* Makefile.in: Rebuilt.
	* configure.in (REPORT_BUGS_TO): Provide default value.
	* configure: Rebuilt.
	* ld.h: Remove bin-bugs.h
	* lexsup.c (help):  Don't print empty REPORT_BUGS_TO.

	gprof/
	* Makefile.am: Rebuild dependencies.
	(REPORT_BUGS_TO): Always defined.
	(PKGVERSION): Define.
	(INCLUDES): Adjust.
	* Makefile.in: Rebuilt.
	* configure.in (REPORT_BUGS_TO): Provide default value.
	* configure: Rebuilt.
	* gprof.c (usage): Don't print empty REPORT_BUGS_TO.
	* gprof.h: Remove bin-bugs.h

	include/
	* bin-bugs.h: Remove.
@
text
@d2664 1
a2664 1
usage (FILE *stream)
d2666 3
a2668 3
  fprintf (stream, _("Usage: readelf <option(s)> elf-file(s)\n"));
  fprintf (stream, _(" Display information about the contents of ELF format files\n"));
  fprintf (stream, _(" Options are:\n\
d2692 1
a2692 1
  fprintf (stream, _("\
d2696 1
a2696 1
  fprintf (stream, _("\
d2702 1
a2702 3
  
  if (REPORT_BUGS_TO[0] && stream == stdout)
    fprintf (stdout, _("Report bugs to %s\n"), REPORT_BUGS_TO);
d2704 1
a2704 1
  exit (stream == stdout ? 0 : 1);
d2768 1
a2768 1
    usage (stderr);
d2782 1
a2782 1
	  usage (stdout);
d3023 1
a3023 1
	  usage (stderr);
d3031 1
a3031 1
    usage (stderr);
d3035 1
a3035 1
      usage (stderr);
@


1.340.2.3
log
@	bfd/
	* elf32-m68k.c: Update uses of EF_M68K_*.

	binutils/
	* readelf.c: Update uses of EF_M68K_*.

	gas/
	* config/tc-m68k.c: Update uses of EF_M68K_*.

	include/elf
	* m68k.h (EF_M68K_ISA_MASK, EF_M68K_ISA_A_NODIV,
	EF_M68K_ISA_A, EF_M68K_ISA_A_PLUS, EF_M68K_ISA_B_NOUSP,
	EF_M68K_ISA_B, EF_M68K_ISA_C, EF_M68K_MAC_MASK, EF_M68K_MAC,
	EF_M68K_EMAC, EF_M68K_EMAC_B, EF_M68K_FLOAT): Rename to
	EF_M68K_CF_ISA_MASK, EF_M68K_CF_ISA_A_NODIV, EF_M68K_CF_ISA_A,
	EF_M68K_CF_ISA_A_PLUS, EF_M68K_CF_ISA_B_NOUSP,
	EF_M68K_CF_ISA_B, EF_M68K_CF_ISA_C, EF_M68K_CF_MAC_MASK,
	EF_M68K_CF_MAC, EF_M68K_CF_EMAC, EF_M68K_CF_EMAC_B,
	EF_M68K_CF_FLOAT, respectively.
@
text
@d1953 1
a1953 1
	  if (e_flags & EF_M68K_CF_ISA_MASK)
d1959 1
a1959 1
	      switch (e_flags & EF_M68K_CF_ISA_MASK)
d1961 1
a1961 1
		case EF_M68K_CF_ISA_A_NODIV:
d1965 1
a1965 1
		case EF_M68K_CF_ISA_A:
d1968 1
a1968 1
		case EF_M68K_CF_ISA_A_PLUS:
d1971 1
a1971 1
		case EF_M68K_CF_ISA_B_NOUSP:
d1975 1
a1975 1
		case EF_M68K_CF_ISA_B:
d1983 1
a1983 1
	      if (e_flags & EF_M68K_CF_FLOAT)
d1985 1
a1985 1
	      switch (e_flags & EF_M68K_CF_MAC_MASK)
d1990 1
a1990 1
		case EF_M68K_CF_MAC:
d1993 1
a1993 1
		case EF_M68K_CF_EMAC:
@


1.340.2.4
log
@	bfd/
	* elf32-m68k.c (elf32_m68k_object_p,
	elf32_m68k_print_private_bfd_data): Use EF_M68K_ARCH_MASK to
	extract architecture mask.

	binutils/
	* readelf.c (get_machine_flags): Use EF_M68K_ARCH_MASK to
	extract architecture mask.

	include/elf/
	* m68k.h (EF_M68K_ARCH_MASK): New.
@
text
@d1949 3
a1951 1
	  if ((e_flags & EF_M68K_ARCH_MASK) == EF_M68K_M68000)
d1953 1
a1953 5
	  else if ((e_flags & EF_M68K_ARCH_MASK) == EF_M68K_CPU32)
	    strcat (buf, ", cpu32");
	  else if (((e_flags & EF_M68K_ARCH_MASK) == 0
		    && (e_flags & EF_M68K_CF_ISA_MASK) != 0)
		   || (e_flags & EF_M68K_ARCH_MASK) == EF_M68K_CFV4E)
@


1.340.2.5
log
@	bfd/
	* elf32-m68k.c (elf32_m68k_object_p): Treat the default case
	as ColdFire.
	(elf32_m68k_merge_private_bfd_data): Use EF_M68K_ARCH_MASK to
	extract architecture mask.  Treat the default case as ColdFire.

	binutils/
	* readelf.c (get_machine_flags): Treat the default case as
	ColdFire.
@
text
@d1953 3
a1955 1
	  else
@


1.340.2.6
log
@        Backport from mainline:

        2006-07-29  Richard Sandiford  <richard@@codesourcery.com>

        ld/
        * Makefile.am (eelf32b4300.c): Update dependencies.
        (eelf32bmip.c): Likewise.
        (eelf32bsmip.c): Likewise.
        (eelf32btsmip.c): Likewise.
        (eelf32btsmipn32.c): Likewise.
        (eelf32ltsmip.c): Likewise.
        (eelf32ltsmipn32.c): Likewise.
        (eelf32ebmip.c): Likewise.
        (eelf32ebmipvxworks.c): Likewise.
        (eelf32elmip.c): Likewise.
        (eelf32elmipvxworks.c): Likewise.
        (eelf32bmipn32.c): Likewise.
        (eelf32lmip.c): Likewise.
        (eelf32mipswindiss.c): Likewise.
        (eelf32lsmip.c): Likewise.
        (eelf64bmip.c): Likewise.
        (eelf64btsmip.c): Likewise.
        (eelf64ltsmip.c): Likewise.
        (emipsbig.c): Likewise.  Canonicalize ${GENSCRIPTS} line.
        (emipsbsd.c): Likewise.
        (emipsidt.c): Update dependencies.
        (emipsidtl.c): Likewise.
        (emipslit.c): Likewise.
        (emipslnews.c): Likewise.
        (emipspe.c): Likewise.  Fix ${GENSCRIPTS} invocation.
        * Makefile.in: Regenerate.
        * emulparams/elf32bmip.sh (EXTRA_EM_FILE): Define.
        * emulparams/elf32bmipn32-defs.sh (EXTRA_EM_FILE): Likewise.
        * emultempl/irix.em: Include emultempl/mipself.em.
        * emultempl/mipself.em: New file.

        ld/testsuite/
        * ld-mips-elf/hash1.s, ld-mips-elf/hash1a.d,
        * ld-mips-elf/hash1b.d, ld-mips-elf/hash1c.d: New tests.
        * ld-mips-elf/mips-elf.exp: Run them.

        2006-07-14  Jakub Jelinek  <jakub@@redhat.com>

        * elflink.c (bfd_elf_size_dynsym_hash_dynstr): Fix cinfo.shift2 value.

        2006-07-10  Jakub Jelinek  <jakub@@redhat.com>

        include/
        * bfdlink.h (struct bfd_link_info): Add emit_hash and
        emit_gnu_hash bitfields.

        include/elf/
        * common.h (SHT_GNU_HASH, DT_GNU_HASH): Define.

        ld/
        * scripttempl/elf.sc: Add .gnu.hash section.
        * emultempl/elf32.em (OPTION_HASH_STYLE): Define.
        (gld${EMULATION_NAME}_add_options): Register --hash-style option.
        (gld${EMULATION_NAME}_handle_option): Handle it.
        (gld${EMULATION_NAME}_list_options): Document it.
        * ldmain.c (main): Initialize emit_hash and emit_gnu_hash.
        * ld.texinfo: Document --hash-style option.

        ld/testsuite/
        * ld-powerpc/tlsso32.r: Adjust.
        * ld-powerpc/tlsso32.d: Adjust.
        * ld-powerpc/tlsso32.g: Adjust.
        * ld-powerpc/tlsso.r: Adjust.
        * ld-powerpc/tlsso.g: Adjust.
        * ld-powerpc/tlstocso.g: Adjust.

        bfd/
        * elf.c (_bfd_elf_print_private_bfd_data): Handle DT_GNU_HASH.
        (bfd_section_from_shdr, elf_fake_sections, assign_section_numbers):
        Handle SHT_GNU_HASH.
        (special_sections_g): Include .gnu.hash section.
        (bfd_elf_gnu_hash): New function.
        * elf-bfd.h (bfd_elf_gnu_hash, _bfd_elf_hash_symbol): New prototypes.
        (struct elf_backend_data): Add elf_hash_symbol method.
        * elflink.c (_bfd_elf_link_create_dynamic_sections): Create .hash
        only if info->emit_hash, create .gnu.hash section if
        info->emit_gnu_hash.
        (struct collect_gnu_hash_codes): New type.
        (elf_collect_gnu_hash_codes, elf_renumber_gnu_hash_syms,
        _bfd_elf_hash_symbol): New functions.
        (compute_bucket_count): Don't compute HASHCODES array, instead add
        that and NSYMS as arguments.  Use bed->s->sizeof_hash_entry
        instead of bed->s->arch_size / 8.  Fix .hash size estimation.
        When not optimizing, use the number of hashed symbols rather than
        dynsymcount.
        (bfd_elf_size_dynamic_sections): Only add DT_HASH if info->emit_hash,
        and ADD DT_GNU_HASH if info->emit_gnu_hash.
        (bfd_elf_size_dynsym_hash_dynstr): Size .hash only if info->emit_hash,
        adjust compute_bucket_count caller.  Create and populate .gnu.hash
        section if info->emit_gnu_hash.
        (elf_link_output_extsym): Only populate .hash section if
        finfo->hash_sec != NULL.
        (bfd_elf_final_link): Adjust assertion.  Handle DT_GNU_HASH.
        * elfxx-target.h (elf_backend_hash_symbol): Define if not yet defined.
        (elfNN_bed): Add elf_backend_hash_symbol.
        * elf64-x86-64.c (elf64_x86_64_hash_symbol): New function.
        (elf_backend_hash_symbol): Define.
        * elf32-i386.c (elf_i386_hash_symbol): New function.
        (elf_backend_hash_symbol): Define.

        binutils/
        * readelf.c (get_dynamic_type): Handle DT_GNU_HASH.
        (get_section_type_name): Handle SHT_GNU_HASH.
        (dynamic_info_DT_GNU_HASH): New variable.
        (process_dynamic_section): Handle DT_GNU_HASH.
        (process_symbol_table): Print also DT_GNU_HASH histogram.
@
text
@a137 1
static bfd_vma dynamic_info_DT_GNU_HASH;
a1501 1
    case DT_GNU_HASH:	return "GNU_HASH";
a2571 1
    case SHT_GNU_HASH:		return "GNU_HASH";
a6219 9
	case DT_GNU_HASH:
	  dynamic_info_DT_GNU_HASH = entry->d_un.d_val;
	  if (do_dynamic)
	    {
	      print_vma (entry->d_un.d_val, PREFIX_HEX);
	      putchar ('\n');
	    }
	  break;

a6894 3
  bfd_vma ngnubuckets = 0;
  bfd_vma *gnubuckets = NULL;
  bfd_vma *gnuchains = NULL;
a7273 160
  if (do_histogram && dynamic_info_DT_GNU_HASH)
    {
      unsigned char nb[16];
      bfd_vma i, maxchain = 0xffffffff, symidx, bitmaskwords;
      unsigned long *lengths;
      unsigned long *counts;
      unsigned long hn;
      unsigned long maxlength = 0;
      unsigned long nzero_counts = 0;
      unsigned long nsyms = 0;
      bfd_vma buckets_vma;

      if (fseek (file,
		 (archive_file_offset
		  + offset_from_vma (file, dynamic_info_DT_GNU_HASH,
				     sizeof nb)),
		 SEEK_SET))
	{
	  error (_("Unable to seek to start of dynamic information"));
	  return 0;
	}

      if (fread (nb, 16, 1, file) != 1)
	{
	  error (_("Failed to read in number of buckets\n"));
	  return 0;
	}

      ngnubuckets = byte_get (nb, 4);
      symidx = byte_get (nb + 4, 4);
      bitmaskwords = byte_get (nb + 8, 4);
      buckets_vma = dynamic_info_DT_GNU_HASH + 16;
      if (is_32bit_elf)
	buckets_vma += bitmaskwords * 4;
      else
	buckets_vma += bitmaskwords * 8;

      if (fseek (file,
		 (archive_file_offset
		  + offset_from_vma (file, buckets_vma, 4)),
		 SEEK_SET))
	{
	  error (_("Unable to seek to start of dynamic information"));
	  return 0;
	}

      gnubuckets = get_dynamic_data (file, ngnubuckets, 4);

      if (gnubuckets == NULL)
	return 0;

      for (i = 0; i < ngnubuckets; i++)
	if (gnubuckets[i] != 0)
	  {
	    if (gnubuckets[i] < symidx)
	      return 0;

	    if (maxchain == 0xffffffff || gnubuckets[i] > maxchain)
	      maxchain = gnubuckets[i];
	  }

      if (maxchain == 0xffffffff)
	return 0;

      maxchain -= symidx;

      if (fseek (file,
		 (archive_file_offset
		  + offset_from_vma (file, buckets_vma
					   + 4 * (ngnubuckets + maxchain), 4)),
		 SEEK_SET))
	{
	  error (_("Unable to seek to start of dynamic information"));
	  return 0;
	}

      do
	{
	  if (fread (nb, 4, 1, file) != 1)
	    {
	      error (_("Failed to determine last chain length\n"));
	      return 0;
	    }

	  if (maxchain + 1 == 0)
	    return 0;

	  ++maxchain;
	}
      while ((byte_get (nb, 4) & 1) == 0);

      if (fseek (file,
		 (archive_file_offset
		  + offset_from_vma (file, buckets_vma + 4 * ngnubuckets, 4)),
		 SEEK_SET))
	{
	  error (_("Unable to seek to start of dynamic information"));
	  return 0;
	}

      gnuchains = get_dynamic_data (file, maxchain, 4);

      if (gnuchains == NULL)
	return 0;

      lengths = calloc (ngnubuckets, sizeof (*lengths));
      if (lengths == NULL)
	{
	  error (_("Out of memory"));
	  return 0;
	}

      printf (_("\nHistogram for `.gnu.hash' bucket list length (total of %lu buckets):\n"),
	      (unsigned long) ngnubuckets);
      printf (_(" Length  Number     %% of total  Coverage\n"));

      for (hn = 0; hn < ngnubuckets; ++hn)
	if (gnubuckets[hn] != 0)
	  {
	    bfd_vma off, length = 1;

	    for (off = gnubuckets[hn] - symidx;
		 (gnuchains[off] & 1) == 0; ++off)
	      ++length;
	    lengths[hn] = length;
	    if (length > maxlength)
	      maxlength = length;
	    nsyms += length;
	  }

      counts = calloc (maxlength + 1, sizeof (*counts));
      if (counts == NULL)
	{
	  error (_("Out of memory"));
	  return 0;
	}

      for (hn = 0; hn < ngnubuckets; ++hn)
	++counts[lengths[hn]];

      if (ngnubuckets > 0)
	{
	  unsigned long j;
	  printf ("      0  %-10lu (%5.1f%%)\n",
		  counts[0], (counts[0] * 100.0) / ngnubuckets);
	  for (j = 1; j <= maxlength; ++j)
	    {
	      nzero_counts += counts[j] * j;
	      printf ("%7lu  %-10lu (%5.1f%%)    %5.1f%%\n",
		      j, counts[j], (counts[j] * 100.0) / ngnubuckets,
		      (nzero_counts * 100.0) / nsyms);
	    }
	}

      free (counts);
      free (lengths);
      free (gnubuckets);
      free (gnuchains);
    }

@


1.340.2.7
log
@	bfd/
	* archures.c (bfd_mach_cpu32_fido): New.
	(bfd_mach_mcf_isa_a_nodiv, bfd_mach_mcf_isa_a,
	bfd_mach_mcf_isa_a_mac, bfd_mach_mcf_isa_a_emac,
	bfd_mach_mcf_isa_aplus, bfd_mach_mcf_isa_aplus_mac,
	bfd_mach_mcf_isa_aplus_emac, bfd_mach_mcf_isa_b_nousp,
	bfd_mach_mcf_isa_b_nousp_mac, bfd_mach_mcf_isa_b_nousp_emac,
	bfd_mach_mcf_isa_b, bfd_mach_mcf_isa_b_mac,
	bfd_mach_mcf_isa_b_emac, bfd_mach_mcf_isa_b_float,
	bfd_mach_mcf_isa_b_float_mac, bfd_mach_mcf_isa_b_float_emac):
	Increment the defined values.
	* cpu-m68k.c (arch_info_struct): Add en entry for
	bfd_mach_cpu32_fido.
	(m68k_arch_features): Add an entry corresponding to
	bfd_mach_cpu32_fido.
	(bfd_m68k_compatible): Handle bfd_mach_cpu32_fido.
	* elf32-m68k.c (elf32_m68k_object_p): Handle
	EF_M68K_CPU32_FIDO_A.
	(elf32_m68k_merge_private_bfd_data): Use EF_M68K_CPU32_MASK.
	(elf32_m68k_print_private_bfd_data): Handle
	EF_M68K_CPU32_FIDO_A.

	binutils/
	* readelf.c (get_machine_flags): Handle EF_M68K_CPU32_FIDO_A.

	gas/
	* config/tc-m68k.c (m68k_elf_final_processing): Handle
	EF_M68K_CPU32_FIDO_A.

	include/
	* include/elf/m68k.h (EF_M68K_CPU32_FIDO_A,
	EF_M68K_CPU32_MASK): New.
@
text
@d1954 1
a1954 5
	    {
	      strcat (buf, ", cpu32");
	      if (e_flags & EF_M68K_CPU32_FIDO_A)
		strcat (buf, ", fido_a");
	    }
@


1.339
log
@	bfd:
	* archures.c (bfd_mach_mcf_isa_a_nodiv, bfd_mach_mcf_isa_b_nousp):
	New.  Adjust other variants.
	(bfd_default_scan): Update.
	* bfd-in2.h: Rebuilt.
	* cpu-m68k.c: Adjust.
	(bfd_m68k_compatible): New. Use it for architectures.
	* elf32-m68k.c (elf32_m68k_object_p): Adjust.
	(elf32_m68k_merge_private_bfd_data): Adjust.  Correct isa-a/b
	mismatch.
	(elf32_m68k_print_private_bfd_data): Adjust.
	* ieee.c (ieee_write_processor): Adjust.

	binutils:
	* readelf.c (get_machine_flags): Adjust.

	gas:
	* config/tc-m68k.c (m68k_extensions): Allow 'float' on both m68k
	and cf.
	(m68k_ip): <case 'J'> Check we have some control regs.
	(md_parse_option): Allow raw arch switch.
	(m68k_init_arch): Better detection of arch/cpu mismatch.  Detect
	whether 68881 or cfloat was meant by -mfloat.
	(md_show_usage): Adjust extension display.
	(m68k_elf_final_processing): Adjust.

	gas/testsuite:
	* gas/m68k/arch-cpu-1.s: Tweak.
	* gas/m68k/arch-cpu-1.d: Tweak.

	include/elf:
	* m68k.h (EF_M68K_ISA_MASK, EF_M68K_ISA_A,
	EF_M68K_ISA_A_PLUS, EF_M68K_ISA_B, EF_M68K_ISA_C): Adjust.
	(EF_M68K_ISA_A_NODIV, EF_M68K_ISA_B_NOUSP): New.
	(EF_M68K_HW_DIV, EF_M68K_USP): Remove.
	(EF_M68K_MAC, EF_M68K_EMAC, EF_M68K_FLOAT): Adjust.
	(EF_M68K_EMAC_B): New.

	ld/testsuite:
	* ld-m68k: New tests.
@
text
@d1796 5
@


1.338
log
@Add support for the Infineon XC16X.
@
text
@d1952 1
d1956 4
d1966 4
d1976 4
a1979 2
	      if (e_flags & EF_M68K_HW_DIV)
		strcat (buf, ", hwdiv");
a1996 4
	      if (e_flags & EF_M68K_USP)
		strcat (buf, ", usp");
	      if (e_flags & EF_M68K_FLOAT)
		strcat (buf, ", float");
@


1.337
log
@	* readelf.c (get_machine_flags): Add logic for missing EF_SH flags.
@
text
@d1698 1
d7764 1
a7764 1
static arm_attr_public_tag arm_attr_public_tags[] = 
d7941 1
a7941 1
      
d8031 1
a8031 1
	
d8955 1
a8955 1
  
d9201 1
a9201 1
      
@


1.336
log
@bfd/

2006-02-10  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/2258
	* elf.c (copy_private_bfd_data): Renamed to ...
	(rewrite_elf_program_header): This.
	(copy_elf_program_header): New function.
	(copy_private_bfd_data): Likewise.

binutils/

2006-02-10  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/2258
	* readelf.c (process_program_headers): Use
	ELF_IS_SECTION_IN_SEGMENT_MEMORY.

include/elf/

2006-02-10  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/2258
	* internal.h (ELF_IS_SECTION_IN_SEGMENT_FILE): New.
	(ELF_IS_SECTION_IN_SEGMENT_MEMORY): Likewise.
@
text
@d2127 6
@


1.335
log
@2006-02-08  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (process_program_headers): Match PT_TLS segment
	only with SHT_TLS sections.
@
text
@d3450 1
a3450 18
	      if (section->sh_size > 0
		  /* PT_TLS segment contains only SHF_TLS sections.  */
		  && (segment->p_type != PT_TLS
		      || (section->sh_flags & SHF_TLS) != 0)
		  /* Compare allocated sections by VMA, unallocated
		     sections by file offset.  */
		  && (section->sh_flags & SHF_ALLOC
		      ? (section->sh_addr >= segment->p_vaddr
			 && section->sh_addr + section->sh_size
			 <= segment->p_vaddr + segment->p_memsz)
		      : ((bfd_vma) section->sh_offset >= segment->p_offset
			 && (section->sh_offset + section->sh_size
			     <= segment->p_offset + segment->p_filesz)))
		  /* .tbss is special.  It doesn't contribute memory space
		     to normal segments.  */
		  && (!((section->sh_flags & SHF_TLS) != 0
			&& section->sh_type == SHT_NOBITS)
		      || segment->p_type == PT_TLS))
@


1.334
log
@	* bfd/archures.c (bfd_mach_mcf5200, bfd_mach_mcf5206e,
	bfd_mach_mcf5307, bfd_mach_mcf5407, bfd_mach_mcf528x,
	bfd_mach_mcfv4e, bfd_mach_mcf521x, bfd_mach_mcf5249,
	bfd_mach_mcf547x, bfd_mach_mcf548x): Remove.
	(bfd_mach_mcf_isa_a, bfd_mach_mcf_isa_a_div,
	bfd_mach_mcf_isa_a_div_mac, bfd_mach_mcf_isa_a_div_emac,
	bfd_mach_mcf_isa_aplus, bfd_mach_mcf_isa_aplus_mac,
	bfd_mach_mcf_isa_aplus_emac, bfd_mach_mcf_isa_aplus_usp,
	bfd_mach_mcf_isa_aplus_usp_mac, bfd_mach_mcf_isa_aplus_usp_emac,
	bfd_mach_mcf_isa_b, bfd_mach_mcf_isa_b_mac, bfd_mach_mcf_isa_b_emac,
	bfd_mach_mcf_isa_b_usp_float, bfd_mach_mcf_isa_b_usp_float_mac,
	bfd_mach_mcf_isa_b_usp_float_emac): New.
	(bfd_default_scan): Update coldfire mapping.
	* bfd/bfd-in.h (bfd_m68k_mach_to_features,
	bfd_m68k_features_to_mach): Declare.
	* bfd/bfd-in2.h: Rebuilt.
	* bfd/cpu-m68k.c (arch_info_struct): Add new coldfire machines,
	adjust legacy names.
	(m68k_arch_features): New.
	(bfd_m68k_mach_to_features,
	bfd_m68k_features_to_mach): Define.
	* bfd/elf32-m68k.c (elf32_m68k_object_p): New.
	(elf32_m68k_merge_private_bfd_data): Merge the CF EF flags.
	(elf32_m68k_print_private_bfd_data): Print the CF EF flags.
	(elf_backend_object_p): Define.
	* bfd/ieee.c (ieee_write_processor): Update coldfire machines.
	* bfd/libbfd.h: Rebuilt.

	* gas/config/tc-m68k.c (mcf5208_control_regs, mcf5213_control_regs,
	mcf5329_control_regs): New.
	(not_current_architecture, selected_arch, selected_cpu): New.
	(m68k_archs, m68k_extensions): New.
	(archs): Renamed to ...
	(m68k_cpus): ... here.  Adjust.
	(n_arches): Remove.
	(md_pseudo_table): Add arch and cpu directives.
	(find_cf_chip, m68k_ip): Adjust table scanning.
	(no_68851, no_68881): Remove.
	(md_assemble): Lazily initialize.
	(select_control_regs): Adjust cpu names. Add 5208, 5213, 5329.
	(md_init_after_args): Move functionality to m68k_init_arch.
	(mri_chip): Adjust table scanning.
	(md_parse_option): Reimplement 'm' processing to add -march & -mcpu
	options with saner parsing.
	(m68k_lookup_cpu, m68k_set_arch, m68k_set_cpu, m68k_set_extension,
	m68k_init_arch): New.
	(s_m68k_cpu, s_m68k_arch): New.
	(md_show_usage): Adjust.
	(m68k_elf_final_processing): Set CF EF flags.
	* gas/config/tc-m68k.h (m68k_init_after_args): Remove.
	(tc_init_after_args): Remove.
	* gas/doc/c-m68k.texi (M68K-Opts): Document -march, -mcpu options.
	(M68k-Directives): Document .arch and .cpu directives.

	* gas/testsuite/gas/m68k/all.exp: Add arch-cpu-1 test.
	* gas/testsuite/gas/m68k/arch-cpu-1.[sd]: New.

	* include/elf/m68k.h (EF_CPU32, EF_M68000, EF_CFV4E): Rename to ...
	(EF_M68K_CPU32, EF_M68K_M68000, EF_M68K_CFV4E): ... here.
	(EF_M68K_ISA_MASK, EF_M68K_ISA_A, EF_M68K_M68K_ISA_A_PLUS,
	EF_M68K_ISA_B, EF_M68K_HW_DIV, EF_M68K_MAC_MASK, EF_M68K_MAC,
	EF_M68K_EMAC, EF_M68K_USP, EF_M68K_FLOAT): New.

	* include/opcode/m68k.h (m68008, m68ec030, m68882): Remove.
	(m68k_mask): New.
	(cpu_m68k, cpu_cf): New.
	(mcf5200, mcf5206e, mcf521x, mcf5249, mcf528x, mcf5307, mcf5407,
	mcf5470, mcf5480): Rename to cpu_<foo>. Add m680x0 variants.

	* opcodes/m68k-dis.c (print_insn_m68k): Use
	bfd_m68k_mach_to_features.

	* binutils/readelf.c (get_machine_flags): Add logic for EF_M68K flags.
@
text
@d3451 3
@


1.333
log
@Updo the last change to binutils and ld/testsuite.
@
text
@d1943 1
a1943 1
	  if (e_flags & EF_CPU32)
d1945 1
a1945 1
	  if (e_flags & EF_M68000)
d1947 43
@


1.332
log
@binutils/

2006-02-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (process_program_headers): Undo the change made on
	2004-09-22.  Match PT_DYNAMIC segment only with SHT_DYNAMIC
	sections.

ld/testsuite/

2006-02-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-i386/tlsbin.rd: Update for changed segment map.
	* ld-i386/tlsnopic.rd: Likewise.
	* ld-i386/tlspic.rd: Likewise.
	* ld-powerpc/tlsexe.r: Likewise.
	* ld-powerpc/tlsexe32.r: Likewise.
	* ld-powerpc/tlsexetoc.r: Likewise.
	* ld-powerpc/tlsso.r: Likewise.
	* ld-powerpc/tlsso32.r: Likewise.
	* ld-powerpc/tlstocso.r: Likewise.
	* ld-s390/tlsbin.rd: Likewise.
	* ld-s390/tlsbin_64.rd: Likewise.
	* ld-s390/tlspic.rd: Likewise.
	* ld-s390/tlspic_64.rd: Likewise.
	* ld-sh/tlsbin-2.d: Likewise.
	* ld-sh/tlspic-2.d: Likewise.
	* ld-x86-64/tlsbin.rd: Likewise.
	* ld-x86-64/tlspic.rd: Likewise.
@
text
@a3407 4
		  /* PT_DYNAMIC segment contains only SHT_DYNAMIC
		     sections.  */
		  && (segment->p_type != PT_DYNAMIC
		      || section->sh_type == SHT_DYNAMIC)
d3416 6
a3421 1
			     <= segment->p_offset + segment->p_filesz))))
@


1.331
log
@include/elf/ChangeLog:
Introduce TLS descriptors for i386 and x86_64.
* common.h (DT_TLSDESC_GOT, DT_TLSDESC_PLT): New.
* i386.h (R_386_TLS_GOTDESC, R_386_TLS_DESC_CALL, R_386_TLS_DESC):
New.
* x86-64.h (R_X86_64_GOTPC32_TLSDESC, R_X86_64_TLSDESC_CALL,
R_X86_64_TLSDESC): New.
bfd/ChangeLog:
Introduce TLS descriptors for i386 and x86_64.
* reloc.c (BFD_RELOC_386_TLS_GOTDESC, BFD_RELOC_386_TLS_DESC,
BFD_RELOC_386_TLS_DESC_CALL, BFD_RELOC_X86_64_GOTPC32_TLSDESC,
BFD_RELOC_X86_64_TLSDESC, BFD_RELOC_X86_64_TLSDESC_CALL): New.
* libbfd.h, bfd-in2.h: Rebuilt.
* elf32-i386.c (elf_howto_table): New relocations.
(R_386_tls): Adjust.
(elf_i386_reloc_type_lookup): Map new relocations.
(GOT_TLS_GDESC, GOT_TLS_GD_BOTH_P): New macros.
(GOT_TLS_GD_P, GOT_TLS_GDESC_P, GOT_TLS_GD_ANY_P): New macros.
(struct elf_i386_link_hash_entry): Add tlsdesc_got field.
(struct elf_i386_obj_tdata): Add local_tlsdesc_gotent field.
(elf_i386_local_tlsdesc_gotent): New macro.
(struct elf_i386_link_hash_table): Add sgotplt_jump_table_size.
(elf_i386_compute_jump_table_size): New macro.
(link_hash_newfunc): Initialize tlsdesc_got.
(elf_i386_link_hash_table_create): Set sgotplt_jump_table_size.
(elf_i386_tls_transition): Handle R_386_TLS_GOTDESC and
R_386_TLS_DESC_CALL.
(elf_i386_check_relocs): Likewise.  Allocate space for
local_tlsdesc_gotent.
(elf_i386_gc_sweep_hook): Handle R_386_TLS_GOTDESC and
R_386_TLS_DESC_CALL.
(allocate_dynrelocs): Count function PLT relocations.  Reserve
space for TLS descriptors and relocations.
(elf_i386_size_dynamic_sections): Reserve space for TLS
descriptors and relocations.  Set up sgotplt_jump_table_size.
Don't zero reloc_count in srelplt.
(elf_i386_always_size_sections): New.  Set up _TLS_MODULE_BASE_.
(elf_i386_relocate_section): Handle R_386_TLS_GOTDESC and
R_386_TLS_DESC_CALL.
(elf_i386_finish_dynamic_symbol): Use GOT_TLS_GD_ANY_P.
(elf_backend_always_size_sections): Define.
* elf64-x86-64.c (x86_64_elf_howto): Add R_X86_64_GOTPC32_TLSDESC,
R_X86_64_TLSDESC, R_X86_64_TLSDESC_CALL.
(R_X86_64_standard): Adjust.
(x86_64_reloc_map): Map new relocs.
(elf64_x86_64_rtype_to_howto): New, split out of...
(elf64_x86_64_info_to_howto): ... this function, and...
(elf64_x86_64_reloc_type_lookup): ... use it to map elf_reloc_val.
(GOT_TLS_GDESC, GOT_TLS_GD_BOTH_P): New macros.
(GOT_TLS_GD_P, GOT_TLS_GDESC_P, GOT_TLS_GD_ANY_P): New macros.
(struct elf64_x86_64_link_hash_entry): Add tlsdesc_got field.
(struct elf64_x86_64_obj_tdata): Add local_tlsdesc_gotent field.
(elf64_x86_64_local_tlsdesc_gotent): New macro.
(struct elf64_x86_64_link_hash_table): Add tlsdesc_plt,
tlsdesc_got and sgotplt_jump_table_size fields.
(elf64_x86_64_compute_jump_table_size): New macro.
(link_hash_newfunc): Initialize tlsdesc_got.
(elf64_x86_64_link_hash_table_create): Initialize new fields.
(elf64_x86_64_tls_transition): Handle R_X86_64_GOTPC32_TLSDESC and
R_X86_64_TLSDESC_CALL.
(elf64_x86_64_check_relocs): Likewise.  Allocate space for
local_tlsdesc_gotent.
(elf64_x86_64_gc_sweep_hook): Handle R_X86_64_GOTPC32_TLSDESC and
R_X86_64_TLSDESC_CALL.
(allocate_dynrelocs): Count function PLT relocations.  Reserve
space for TLS descriptors and relocations.
(elf64_x86_64_size_dynamic_sections): Reserve space for TLS
descriptors and relocations.  Set up sgotplt_jump_table_size,
tlsdesc_plt and tlsdesc_got.  Make room for them.  Don't zero
reloc_count in srelplt.  Add dynamic entries for DT_TLSDESC_PLT
and DT_TLSDESC_GOT.
(elf64_x86_64_always_size_sections): New.  Set up
_TLS_MODULE_BASE_.
(elf64_x86_64_relocate_section): Handle R_386_TLS_GOTDESC and
R_386_TLS_DESC_CALL.
(elf64_x86_64_finish_dynamic_symbol): Use GOT_TLS_GD_ANY_P.
(elf64_x86_64_finish_dynamic_sections): Set DT_TLSDESC_PLT and
DT_TLSDESC_GOT.  Set up TLS descriptor lazy resolver PLT entry.
(elf_backend_always_size_sections): Define.
binutils/ChangeLog:
Introduce TLS descriptors for i386 and x86_64.
* readelf.c (get_dynamic_type): Handle DT_TLSDESC_GOT and
DT_TLSDESC_PLT.
gas/ChangeLog:
Introduce TLS descriptors for i386 and x86_64.
* config/tc-i386.c (tc_i386_fix_adjustable): Handle
BFD_RELOC_386_TLS_GOTDESC, BFD_RELOC_386_TLS_DESC_CALL,
BFD_RELOC_X86_64_GOTPC32_TLSDESC, BFD_RELOC_X86_64_TLSDESC_CALL.
(optimize_disp): Emit fix up for BFD_RELOC_386_TLS_DESC_CALL and
BFD_RELOC_X86_64_TLSDESC_CALL immediately, and clear the
displacement bits.
(build_modrm_byte): Set up zero modrm for TLS desc calls.
(lex_got): Handle @@tlsdesc and @@tlscall.
(md_apply_fix, tc_gen_reloc): Handle the new relocations.
ld/testsuite/ChangeLog:
Introduce TLS descriptors for i386 and x86_64.
* ld-i386/i386.exp: Run on x86_64-*-linux* and amd64-*-linux*.
Add new tests.
* ld-i386/pcrel16.d: Add -melf_i386.
* ld-i386/pcrel8.d: Likewise.
* ld-i386/tlsbindesc.dd: New.
* ld-i386/tlsbindesc.rd: New.
* ld-i386/tlsbindesc.s: New.
* ld-i386/tlsbindesc.sd: New.
* ld-i386/tlsbindesc.td: New.
* ld-i386/tlsdesc.dd: New.
* ld-i386/tlsdesc.rd: New.
* ld-i386/tlsdesc.s: New.
* ld-i386/tlsdesc.sd: New.
* ld-i386/tlsdesc.td: New.
* ld-i386/tlsgdesc.dd: New.
* ld-i386/tlsgdesc.rd: New.
* ld-i386/tlsgdesc.s: New.
* ld-x86-64/x86-64.exp: Run new tests.
* ld-x86-64/tlsbindesc.dd: New.
* ld-x86-64/tlsbindesc.rd: New.
* ld-x86-64/tlsbindesc.s: New.
* ld-x86-64/tlsbindesc.sd: New.
* ld-x86-64/tlsbindesc.td: New.
* ld-x86-64/tlsdesc.dd: New.
* ld-x86-64/tlsdesc.pd: New.
* ld-x86-64/tlsdesc.rd: New.
* ld-x86-64/tlsdesc.s: New.
* ld-x86-64/tlsdesc.sd: New.
* ld-x86-64/tlsdesc.td: New.
* ld-x86-64/tlsgdesc.dd: New.
* ld-x86-64/tlsgdesc.rd: New.
* ld-x86-64/tlsgdesc.s: New.
@
text
@d3408 4
d3420 1
a3420 6
			     <= segment->p_offset + segment->p_filesz)))
		  /* .tbss is special.  It doesn't contribute memory space
		     to normal segments.  */
		  && (!((section->sh_flags & SHF_TLS) != 0
			&& section->sh_type == SHT_NOBITS)
		      || segment->p_type == PT_TLS))
@


1.330
log
@Define EM_ALTERA_NIOS2 and EM_NIOS32.
@
text
@d1483 2
@


1.329
log
@	* readelf.c (get_machine_name): Add case for Blackfin.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004, 2005
d614 2
d1694 2
@


1.328
log
@	Second part of ms1 to mt renaming.
	* bfd/archures.c (bfd_arch_mt): Renamed.
	(bfd_mt_arch): Renamed.
	(bfd_archures_list): Adjusted.
	* bfd/bfd-in2.h: Rebuilt.
	* bfd/config.bfd (mt): Remove special case targ_archs.
	(mt-*-elf): Rename bfd_elf32_mt_vec.
	* bfd/configure: Rebuilt.
	* bfd/configure.in (bfd_elf32_mt_vec): Renamed.
	(selarchs) Remove mt special case.
	* bfd/cpu-mt.c (arch_info_struct): Adjust.
	(bfd_mt_arch): Renamed, adjust.
	* bfd/elf32-mt.c (mt_reloc_type_lookup, mt_info_to_howto_rela,
	mt_elf_relocate_hi16, mt_final_link_relocate, mt_relocate_section,
	mt_elf_howto_table): Renamed, adjusted.
	(mt_elf_gc_mark_hook, mt_elf_gc_sweep_hook, mt_elf_check_relocs,
	elf32_mt_machine, mt_elf_object_p, mt_elf_set_private_flags,
	mt_elf_copy_private_bfd_data, mt_elf_merge_private_bfd_data,
	mt_elf_print_private_bfd_data): Renamed, adjusted.
	(TARGET_BIG_SYM, TARGET_BIG_NAME, ELF_ARCH, ELF_MACHINE_CODE,
	ELF_MAXPAGESIZE, elf_info_to_howto, elf_backend_relocate_section,
	bfd_elf32_bfd_reloc_type_lookup, elf_backend_gc_mark_hook,
	elf_backend_gc_sweep_hook, elf_backend_check_relocs,
	eld_backend_object_p, bfd_elf32_bfd_set_private_flags,
	bfd_elf32_bfd_copy_private_bfd_data,
	bfd_elf32_bfd_merge_private_bfd_data,
	bfd_elf32_bfd_print_private_bfd_data): Adjusted.
	* bfd/libbfd.h: Regenerated.
	* bfd/reloc.c (BFD_RELOC_MT_PC16, BFD_RELOC_MT_HI16,
	BFD_RELOC_MT_LO16, BFD_RELOC_MT_GNU_VTINHERIT,
	BFD_RELOC_MT_GNU_VTENTRY, BFD_RELOC_MT_PCINSN8): Renamed.
	* bfd/targets.c (bfd_elf32_mt_vec): Renamed.
	(_bfd_target_vector): Adjusted.
	* binutils/readelf.c (guess_is_rela): Use EM_MT.
	(dump_relocations, get_machine_name): Adjust.

	* cpu/mt.cpu (define-arch, define-isa): Set name to mt.
	(define-mach): Adjust.
	* cpu/mt.opc (CGEN_ASM_HASH): Update.
	(mt_asm_hash, mt_cgen_insn_supported): Renamed.
	(parse_loopsize, parse_imm16): Adjust.

	* gas/configure: Rebuilt.
	* gas/configure.in (mt): Remove special case.
	* gas/config/tc-mt.c (opcodes/mt-desc.h, opcodes/mt-opc.h): Change
	#includes.
	(mt_insn, mt_mach, mt_mach_bitmask, mt_flags, mt_architectures):
	Rename, adjust.
	(md_parse_option, md_show_usage, md_begin, md_assemble,
	md_cgen_lookup_reloc, md_atof): Adjust.
	(mt_force_relocation, mt_apply_fix, mt_fix_adjustable): Rename, adjust.
	* gas/config/tc-mt.h (TC_MT): Rename.
	(LISTING_HEADER, TARGET_ARCH, TARGET_FORMAT): Adjust.
	(md_apply_fix): Adjust.
	(mt_apply_fix, mt_fix_adjustable, mt_force_relocation): Rename.
	(TC_FORCE_RELOCATION, tc_fix_adjustable): Adjust.

	* gdb/mt-tdep.c (mt_arch_constants, mt_gdb_regnums): Rename, adjust.
	(mt_register_name, mt_register_type, mt_register_reggroup_p,
	mt_return_value, mt_skip_prologue, mt_breapoint_from_pc,
	mt_pseudo_register_read, mt_pseudo_register_write, mt_frame_align,
	mt_registers_info, mt_push_dummy_call, mt_unwind_cache,
	mt_frame_unwind_cache, mt_unwind_pc, mt_unwind_dummy_id,
	mt_frame_this_id, mt_frame_prev_register, mt_frame_base_address,
	mt_frame_unwind, mt_frame_sniffer, mt_frame_base, mt_gdbarch_init,
	_initialize_mt_tdep): Rename & adjust.

	* include/dis-asm.h (print_insn_mt): Renamed.

	* include/elf/common.h (EM_MT): Renamed.
	* include/elf/mt.h: Rename relocs, cpu & other defines.

	* ld/emulparams/elf32mt.sh (ARCH, OUTPUT_FORMAT): Adjust.

	* opcodes/Makefile.am (HFILES, CFILES, ALL_MACHINES): Adjust.
	(stamp-mt): Adjust rule.
	(mt-asm.lo, mt-desc.lo, mt-dis.lo, mt-ibld.lo, mt-opc.lo): Rename &
	adjust.
	* opcodes/Makefile.in: Rebuilt.
	* opcodes/configure: Rebuilt.
	* opcodes/configure.in (bfd_mt_arch): Rename & adjust.
	* opcodes/disassemble.c (ARCH_mt): Renamed.
	(disassembler): Adjust.
	* opcodes/mt-asm.c: Renamed, rebuilt.
	* opcodes/mt-desc.c: Renamed, rebuilt.
	* opcodes/mt-desc.h: Renamed, rebuilt.
	* opcodes/mt-dis.c: Renamed, rebuilt.
	* opcodes/mt-ibld.c: Renamed, rebuilt.
	* opcodes/mt-opc.c: Renamed, rebuilt.
	* opcodes/mt-opc.h: Renamed, rebuilt.

	* sid/Makefile.in: Rebuilt.
	* sid/aclocal.m4: Rebuilt.
	* sid/configure: Rebuilt.
	* sid/sid.spec: Adjust.
	* sid/bsp/Makefile.am: Adjust.
	* sid/bsp/Makefile.in: Rebuilt.
	* sid/bsp/aclocal.m4: Rebuilt.
	* sid/bsp/configrun-sid.in: Adjust.
	* sid/bsp/pregen/Makefile.in: Rebuilt.
	* sid/bsp/pregen/mt-gdb.conf: Renamed & rebuilt.
	* sid/bsp/pregen/mt-gloss.conf: Renamed & rebuilt.
	* sid/bsp/pregen/pregen-configs.in: Adjust.
	* sid/component/aclocal.m4: Rebuilt.
	* sid/component/configure: Rebuilt.
	* sid/component/tconfig.in: Adjust.
	* sid/component/bochs/aclocal.m4: Rebuilt.
	* sid/component/cache/Makefile.in: Rebuilt.
	* sid/component/cgen-cpu/Makefile.in: Rebuilt.
	* sid/component/cgen-cpu/aclocal.m4: Rebuilt.
	* sid/component/cgen-cpu/compCGEN.cxx: Adjust.
	* sid/component/cgen-cpu/configure: Rebuilt.
	* sid/component/cgen-cpu/configure.in: Rebult.
	* sid/component/cgen-cpu/mt/Makefile.am: Adjust.
	* sid/component/cgen-cpu/mt/Makefile.in: Rebuilt.
	* sid/component/cgen-cpu/mt/hw-cpu-mt.txt: Adjust.
	* sid/component/cgen-cpu/mt/mt-cpu.h: Rebuilt.
	* sid/component/cgen-cpu/mt/mt-decode.cxx: Rebuilt.
	* sid/component/cgen-cpu/mt/mt-decode.h: Rebuilt.
	* sid/component/cgen-cpu/mt/mt-defs.h: Rebuilt.
	* sid/component/cgen-cpu/mt/mt-desc.h: Rebuilt.
	* sid/component/cgen-cpu/mt/mt-sem.cxx: Rebuilt.
	* sid/component/cgen-cpu/mt/mt-write.cxx: Rebuilt.
	* sid/component/cgen-cpu/mt/mt.cxx: Adjust.
	* sid/component/cgen-cpu/mt/mt.h: Adjust.
	* sid/component/consoles/Makefile.in: Rebuilt.
	* sid/component/families/aclocal.m4: Rebuilt.
	* sid/component/families/configure: Rebuilt.
	* sid/component/gdb/Makefile.in: Rebuilt.
	* sid/component/gloss/Makefile.in: Rebuilt.
	* sid/component/glue/Makefile.in: Rebuilt.
	* sid/component/ide/Makefile.in: Rebuilt.
	* sid/component/interrupt/Makefile.in: Rebuilt.
	* sid/component/lcd/Makefile.in: Rebuilt.
	* sid/component/lcd/testsuite/Makefile.in: Rebuilt.
	* sid/component/loader/Makefile.am: Rebuilt.
	* sid/component/loader/Makefile.in: Rebuilt.
	* sid/component/mapper/Makefile.in: Rebuilt.
	* sid/component/mapper/testsuite/Makefile.in: Rebuilt.
	* sid/component/memory/Makefile.in: Rebuilt.
	* sid/component/mmu/Makefile.in: Rebuilt.
	* sid/component/parport/Makefile.in: Rebuilt.
	* sid/component/profiling/Makefile.in: Rebuilt.
	* sid/component/rtc/Makefile.in: Rebuilt.
	* sid/component/sched/Makefile.in: Rebuilt.
	* sid/component/testsuite/Makefile.in: Rebuilt.
	* sid/component/timers/aclocal.m4: Rebuilt.
	* sid/component/timers/configure: Rebuilt.
	* sid/component/uart/Makefile.in: Rebuilt.
	* sid/component/uart/testsuite/Makefile.in: Rebuilt.
	* sid/config/config.sub: Adjust.
	* sid/config/info.tcl.in: Adjust.
	* sid/config/sidtargets.m4: Adjust.
	* sid/doc/Makefile.in: Rebuilt.
	* sid/main/dynamic/Makefile.am: Rebuilt.
	* sid/main/dynamic/Makefile.in: Rebuilt.
	* sid/main/dynamic/aclocal.m4: Rebuilt.
	* sid/main/dynamic/configure: Rebuilt.
@
text
@d1691 1
@


1.327
log
@
	Rename ms1 to mt, part 1
	* config.sub: Replace ms1 arch with mt.  Allow ms1 as alias.
	* configure.in: Replace ms1 arch with mt.
	* configure: Rebuilt.

	* bfd/Makefile.am (ALL_MACHINES, ALL_MACHINES_CFILES,
	BFD32_BACKENDS, BFD32_BACKENDS_CFILES): Replace ms1 with mt.
	(cpu_mt.lo, elf32-mt.lo): Update target and dependency names.
	* bfd/Makefile.in: Rebuilt.
	* bfd/config.bfd: Replace ms1 arch with mt.
	* bfd/configure.in: Replace ms1 files with mt files.
	* bfd/configure: Rebuilt.
	* bfd/elf32-mt.c: Renamed from elf32-ms1.c.  Update include files.
	* bfd/cpu-mt.c: Renamed from cpu-ms1.c.

	* cpu/mt.cpu: Rename from ms1.cpu.
	* cpu/mt.opc: Rename from ms1.opc.

	* binutils/Makefile.am: Replace ms1 files with mt files.
	* binutils/Makefile.in: Rebuilt.
	* binutils/readelf.c (elf/mt.h): Adjust #include.

	* gas/configure.in: Replace ms1 arch with mt arch.
	* gas/configure: Rebuilt.
	* gas/configure.tgt: Replace ms1 arch with mt arch.
	* gas/config/tc-mt.c: Renamed from tc-ms1.c: Update include files.

	* gas/doc/Makefile.am (CPU_DOCS): Replace ms1 files with mt files.
	* gas/doc/Makefile.in: Rebuilt.

	* gas/testsuite/gas/mt: Renamed from ms1 dir.  Update file names as
	needed.
	* gas/testsuite/gas/mt/errors.exp: Replace ms1 arch with mt arch.
	* gas/testsuite/gas/mt/mt.exp: Replace ms1 arch with mt arch.
	* gas/testsuite/gas/mt/relocs.exp: Replace ms1 arch with mt arch.

	* gdb/configure.tgt: Replace ms1 arch with mt arch.
	* gdb/config/mt: Renamed from ms1 dir.  Update file names as needed.
	* gdb/config/mt/mt.mt (TDEPFILES): Replace ms1 file with mt file.

	* include/elf/mt.h: Renamed from ms1.h

	* ld/Makefile.am (ALL_EMULATIONS): Replace ms1 files with mt files.
	(eelf32mt.c): Update target name and dependencies.
	* ld/Makefile.in: Rebuilt.
	* ld/configure.tgt: Replace ms1 arch with mt arch.
	* ld/emulparams/elf32mt.sh: Renamed from elf32ms1.sh. Update
	comment.

	* libgloss/configure.in: Replace ms1 arch with mt arch.
	* libgloss/configure: Rebuilt.
	* libgloss/mt: Renamed from ms1 dir.

	* newlib/configure.host: Replace ms1 arch with mt arch.
	* newlib/libc/machine/mt: Renamed from ms1 dir.

	* opcodes/Makefile.am (CLEANFILES, CGEN_CPUS, MT_DEPS): Replace ms1
	with mt.
	* opcodes/Makefile.in: Rebuilt.
	* opcodes/configure.in: Replace ms1 files with mt files.
	* opcodes/configure: Rebuilt.

	* sid/component/cgen-cpu/mt: Renamed from ms1 dir.  Update file
	names as appropriate.
	* sid/component/cgen-cpu/mt/Makefile.am: Replace ms1 files with mt
	files.
	* sid/component/cgen-cpu/mt/Makefile.in: Rebuilt.
@
text
@d612 1
a612 1
    case EM_MS1:
d1126 2
a1127 2
	case EM_MS1:
	  rtype = elf_ms1_reloc_type (type);
d1690 1
a1690 1
    case EM_MS1:                return "Morpho Techologies MS1 processor";
@


1.326
log
@	* readelf.c (struct dump_list_entry, request_dump_byname)
	(initialise_dumps_byname): New.
	(parse_args): Call request_dump_byname.
	(process_section_contents): Call initialise_dumps_byname.
	* doc/binutils.texi (readelf): Mention -x NAME.
	* NEWS: Likewise.
@
text
@d98 1
a98 1
#include "elf/ms1.h"
@


1.325
log
@PR 1150
* readelf.c (get_mips_symbol_other): New function.
  (get_symbol_other): New function.
  (process_symbol_table): Call get_symbol_other() to get a description of the
    st_other field if it contains more information than just the visibility.
* elfxx-mips.c (mips_elf_calculate_relocation): Ignore an undefined symbol if
    it is optional.
  (_bfd_mips_elf_merge_symbol_attribute): Make sure that the optional flag is
    merged as well as the visibility.
* elfxx-mips.h (_bfd_mips_elf_merge_symbol_attribute): Prototype.
  (elf_backend_merge_symbol_attribute): Define.
* mips.h (STO_OPTIONAL): Define.
  (ELF_MIPS_IS_OPTIONAL): Define.
@
text
@d180 10
d198 3
a200 2
   basis and then initialised from the cmdline_dump_sects array and
   the results of interpreting the -w switch.  */
d2672 21
d2780 4
a2783 5
	    {
	      request_dump (section, HEX_DUMP);
	      break;
	    }
	  goto oops;
d2947 1
d2949 1
d7583 26
d7618 2
@


1.324
log
@2005-10-10  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/1436
	* readelf.c (ABSADDR): New.
	(dump_ia64_unwind): Use ABSADDR to get the unwind info address.
@
text
@d6693 35
d6889 5
d6961 5
@


1.323
log
@	* addr2line.c (usage): Document @@file.
	* ar.c (usage): Likewise.
	* coffdump (usage): Likewise.
	* cxxfilt.c (usage): Likewise.
	* dlltool.c (usage): Likewise.
	* dllwrap.c (usage): Likewise.
	* nlmconv.c (usage): Likewise.
	* nm.c (usage): Likewise.
	* objcopy.c (usage): Likewise.
	* objdump.c (usage): Likewise.
	* readelf.c (usage): Likewise.
	* size.c (usage): Likeise.
	* srconv.c (usage): Likewise.
	* strings.c (usage): Likewise.
	* windres.c (usage): Likewise.
	* doc/binutils.texi: Add section on common options.
@
text
@d4583 5
d4680 1
a4680 1
      head = aux->info + (tp->info.offset - aux->info_addr);
@


1.322
log
@2005-10-01  Paul Brook  <paul@@codesourcery.com>

	* readelf.c (arm_attr_tag_CPU_arch, arm_attr_tag_ARM_ISA_use,
	arm_attr_tag_THUMB_ISA_use, arm_attr_tag_VFP_arch,
	arm_attr_tag_WMMX_arch, arm_attr_tag_NEON_arch,
	arm_attr_tag_ABI_PCS_config, arm_attr_tag_ABI_PCS_R9_use,
	arm_attr_tag_ABI_PCS_RW_data, arm_attr_tag_ABI_PCS_RO_DATA,
	arm_attr_tag_ABI_PCS_GOT_use, arm_attr_tag_ABI_PCS_wchar_t,
	arm_attr_tag_ABI_FP_rounding, arm_attr_tag_ABI_FP_denormal,
	arm_attr_tag_ABI_FP_exceptions, arm_attr_tag_ABI_FP_user_exceptions,
	arm_attr_tag_ABI_FP_number_model, arm_attr_tag_ABI_align8_needed,
	arm_attr_tag_ABI_align8_preserved, arm_attr_tag_ABI_enum_size,
	arm_attr_tag_ABI_HardFP_use, arm_attr_tag_ABI_VFP_args,
	arm_attr_tag_ABI_WMMX_args, arm_attr_tag_ABI_optimization_goals,
	arm_attr_tag_ABI_FP_optimization_goals, arm_attr_public_tags): New.
	(display_arm_attribute, process_arm_specific): New functions.
	(process_arch_specific): Add EM_ARM.
@
text
@d2619 1
@


1.321
log
@	* addr2line.c (main): Likewise.
	* ar.c (main): Likewise.
	* coffdump.c (main): Likewise.
	* cxxfilt.c (main): Likewise.
	* dlltool.c (main): Likewise.
	* dllwrap.c (main): Likewise.
	* nlmconv.c (main): Likewise.
	* nm.c (main): Likewise.
	* objcopy.c (main): Likewise.
	* objdump.c (main): Likewise.
	* readelf.c (main): Likewise.
	* size.c (main): Likeiwse.
	* srcconv.c (main): Likewise.
	* strings.c (main): Likewise.
	* sysdump.c (main): Likewise.
	* sysinfo.c (main): Likewise.
	* windres.c (main): Likewise.

	* ldmain.c (main): Use expandargv.

	* gprof.c (main): Use expandargv.

	* as.c (main): Use expandargv.
@
text
@d7551 331
d8651 2
@


1.320
log
@	* Makefile.am: Bfin support.
	* Makefile.in: Regenerated.
	* aclocal.m4: Regenerated.
	* readelf.c (elf/bfin.h): Include.
	(guess_is_rela): EM_BLACKFIN support.
	(dump_relocations): Likewise.
@
text
@d8832 2
@


1.319
log
@2005-09-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.am (CFILES): Add dwarf.c.
	(readelf_SOURCES): Likewise.
	* Makefile.in: Regenerated.

	* dwarf.c: New file.
	* dwarf.h. Likewise.

	* readelf.c: Include "dwarf.h" instead of "bfd.h".
	(do_debug_info): Remove the static definition.
	(do_debug_abbrevs): Likewise.
	(do_debug_lines): Likewise.
	(do_debug_pubnames): Likewise.
	(do_debug_aranges): Likewise.
	(do_debug_ranges): Likewise.
	(do_debug_frames): Likewise.
	(do_debug_frames_interp): Likewise.
	(do_debug_macinfo): Likewise.
	(do_debug_str): Likewise.
	(do_debug_loc): Likewise.
	(is_relocatable): Likewise.
	(have_frame_base): Likewise.
	(need_base_address): Likewise.
	(eh_addr_size): Likewise.
	(error): Likewise.
	(warn): Likewise.
	(cmalloc): Likewise.
	(xcmalloc): Likewise.
	(xcrealloc): Likewise.
	(dwarf_section): Removed.
	(byte_get_little_endian): Likewise.
	(byte_get_signed): Likewise.
	(byte_get_big_endian): Likewise.
	(read_leb128): Likewise.
	(State_Machine_Registers): Likewise.
	(state_machine_regs): Likewise.
	(reset_state_machine): Likewise.
	(process_extended_line_op): Likewise.
	(debug_str_section): Likewise.
	(fetch_indirect_string): Likewise.
	(debug_abbrev_section): Likewise.
	(abbrev_attr): Likewise.
	(first_abbrev): Likewise.
	(last_abbrev): Likewise.
	(free_abbrevs): Likewise.
	(add_abbrev_attr): Likewise.
	(process_abbrev_section): Likewise.
	(get_TAG_name): Likewise.
	(get_FORM_name): Likewise.
	(display_block): Likewise.
	(decode_location_expression): Likewise.
	(debug_info): Likewise.
	(debug_information): Likewise.
	(num_debug_info_entries): Likewise.
	(last_pointer_size): Likewise.
	(warned_about_missing_comp_units): Likewise.
	(read_and_display_attr_value): Likewise.
	(get_AT_name): Likewise.
	(read_and_display_attr): Likewise.
	(process_debug_info): Likewise.
	(get_pointer_size_and_offset_of_comp_unit): Likewise.
	(get_debug_info): Likewise.
	(display_debug_lines): Likewise.
	(display_debug_pubnames): Likewise.
	(display_debug_macinfo): Likewise.
	(display_debug_abbrev): Likewise.
	(display_debug_loc): Likewise.
	(display_debug_str): Likewise.
	(display_debug_aranges): Likewise.
	(display_debug_ranges): Likewise.
	(Frame_Chunk): Likewise.
	(DW_CFA_unreferenced): Likewise.
	(frame_need_space): Likewise.
	(frame_display_row): Likewise.
	(size_of_encoded_value): Likewise.
	(get_encoded_value): Likewise.
	(GET): Likewise.
	(LEB): Likewise.
	(SLEB): Likewise.
	(display_debug_frames): Likewise.
	(display_debug_not_supported): Likewise.
	(debug_displays): Likewise.
	(load_debug_section): Updated.
	(free_debug_section): Likewise.
	(display_debug_section): Likewise.
	(process_object): Call free_debug_memory to free debug memory.
@
text
@d74 1
d602 1
d1118 5
@


1.318
log
@2005-09-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c: Reordered.
	(is_relocatable): New.
	(dwarf_section): New structure for DWARF section.
	(load_debug_section): New.
	(free_debug_section): Likewise.
	(debug_str_section): Likewise.
	(debug_abbrev_section): Likewise.
	(debug_str_contents): Removed.
	(debug_str_size): Likewise.
	(debug_loc_contents): Likewise.
	(debug_loc_size): Likewise.
	(debug_range_contents): Likewise.
	(debug_range_size): Likewise.
	(load_debug_str): Likewise.
	(free_debug_str): Likewise.
	(load_debug_loc): Likewise.
	(free_debug_loc): Likewise.
	(load_debug_arange): Likewise.
	(free_debug_arange): Likewise.
	(load_debug_abbrev): Likewise.
	(free_debug_abbrev): Likewise.
	(fetch_indirect_string): Updated.
	(debug_apply_rela_addends): Likewise.
	(process_debug_info): Likewise.
	(get_debug_info): Likewise.
	(display_debug_lines): Likewise.
	(display_debug_pubnames): Likewise.
	(display_debug_macinfo): Likewise.
	(display_debug_abbrev): Likewise.
	(display_debug_loc): Likewise.
	(display_debug_str): Likewise.
	(display_debug_info): Likewise.
	(display_debug_aranges): Likewise.
	(display_debug_ranges): Likewise.
	(display_debug_frames): Likewise.
	(display_debug_not_supported): Likewise.
	(debug_displays): Likewise.
	(display_debug_section): Likewise.
	(get_file_header): Set is_relocatable.
@
text
@d58 1
a58 1
#include "bfd.h"
a62 1
#include "elf/dwarf2.h"
a158 11
static int do_debug_info;
static int do_debug_abbrevs;
static int do_debug_lines;
static int do_debug_pubnames;
static int do_debug_aranges;
static int do_debug_ranges;
static int do_debug_frames;
static int do_debug_frames_interp;
static int do_debug_macinfo;
static int do_debug_str;
static int do_debug_loc;
a161 4
static int is_relocatable;
static int have_frame_base;
static int need_base_address;
static bfd_vma eh_addr_size;
a208 1
static bfd_vma (*byte_get) (unsigned char *, int);
a251 52
static void ATTRIBUTE_PRINTF_1
error (const char *message, ...)
{
  va_list args;

  va_start (args, message);
  fprintf (stderr, _("%s: Error: "), program_name);
  vfprintf (stderr, message, args);
  va_end (args);
}

static void ATTRIBUTE_PRINTF_1
warn (const char *message, ...)
{
  va_list args;

  va_start (args, message);
  fprintf (stderr, _("%s: Warning: "), program_name);
  vfprintf (stderr, message, args);
  va_end (args);
}

static void *
cmalloc (size_t nmemb, size_t size)
{
  /* Check for overflow.  */
  if (nmemb >= ~(size_t) 0 / size)
    return NULL;
  else
    return malloc (nmemb * size);
}

static void *
xcmalloc (size_t nmemb, size_t size)
{
  /* Check for overflow.  */
  if (nmemb >= ~(size_t) 0 / size)
    return NULL;
  else
    return xmalloc (nmemb * size);
}

static void *
xcrealloc (void *ptr, size_t nmemb, size_t size)
{
  /* Check for overflow.  */
  if (nmemb >= ~(size_t) 0 / size)
    return NULL;
  else
    return xrealloc (ptr, nmemb * size);
}

a7296 45

struct dwarf_section
{
  const char *name;
  unsigned char *start;
  bfd_vma address;
  bfd_size_type size;
};

static int process_debug_info (struct dwarf_section *, void *, int);

static void
load_debug_section (struct dwarf_section *section, void *file)
{
  Elf_Internal_Shdr *sec;
  char buf [64];

  /* If it is already loaded, do nothing.  */
  if (section->start != NULL)
    return;

  /* Locate the debug section.  */
  sec = find_section (section->name);
  if (sec == NULL)
    return;

  snprintf (buf, sizeof (buf), _("%s section data"), section->name);
  section->address = sec->sh_addr;
  section->size = sec->sh_size;
  section->start = get_data (NULL, file, sec->sh_offset, 1,
			     sec->sh_size, buf);
}

static void
free_debug_section (struct dwarf_section *section)
{
  if (section->start == NULL)
    return;

  free ((char *) section->start);
  section->start = NULL;
  section->address = 0;
  section->size = 0;
}

d7406 2
a7407 2
static bfd_vma
byte_get_little_endian (unsigned char *field, int size)
d7409 3
a7411 4
  switch (size)
    {
    case 1:
      return *field;
d7413 3
a7415 3
    case 2:
      return  ((unsigned int) (field[0]))
	|    (((unsigned int) (field[1])) << 8);
d7417 4
a7420 12
#ifndef BFD64
    case 8:
      /* We want to extract data from an 8 byte wide field and
	 place it into a 4 byte wide field.  Since this is a little
	 endian source we can just use the 4 byte extraction code.  */
      /* Fall through.  */
#endif
    case 4:
      return  ((unsigned long) (field[0]))
	|    (((unsigned long) (field[1])) << 8)
	|    (((unsigned long) (field[2])) << 16)
	|    (((unsigned long) (field[3])) << 24);
d7422 5
a7426 16
#ifdef BFD64
    case 8:
      return  ((bfd_vma) (field[0]))
	|    (((bfd_vma) (field[1])) << 8)
	|    (((bfd_vma) (field[2])) << 16)
	|    (((bfd_vma) (field[3])) << 24)
	|    (((bfd_vma) (field[4])) << 32)
	|    (((bfd_vma) (field[5])) << 40)
	|    (((bfd_vma) (field[6])) << 48)
	|    (((bfd_vma) (field[7])) << 56);
#endif
    default:
      error (_("Unhandled data length: %d\n"), size);
      abort ();
    }
}
d7428 2
a7429 4
static bfd_vma
byte_get_signed (unsigned char *field, int size)
{
  bfd_vma x = byte_get (field, size);
d7431 1
a7431 13
  switch (size)
    {
    case 1:
      return (x ^ 0x80) - 0x80;
    case 2:
      return (x ^ 0x8000) - 0x8000;
    case 4:
      return (x ^ 0x80000000) - 0x80000000;
    case 8:
      return x;
    default:
      abort ();
    }
d7434 2
a7435 2
static bfd_vma
byte_get_big_endian (unsigned char *field, int size)
d7437 1
a7437 4
  switch (size)
    {
    case 1:
      return *field;
d7439 2
a7440 2
    case 2:
      return ((unsigned int) (field[1])) | (((int) (field[0])) << 8);
d7442 4
a7445 87
#ifndef BFD64
    case 8:
      /* Although we are extracing data from an 8 byte wide field,
	 we are returning only 4 bytes of data.  */
      field += 4;
      /* Fall thru */
#endif
    case 4:
      return ((unsigned long) (field[3]))
	|   (((unsigned long) (field[2])) << 8)
	|   (((unsigned long) (field[1])) << 16)
	|   (((unsigned long) (field[0])) << 24);

#ifdef BFD64
    case 8:
      return ((bfd_vma) (field[7]))
	|   (((bfd_vma) (field[6])) << 8)
	|   (((bfd_vma) (field[5])) << 16)
	|   (((bfd_vma) (field[4])) << 24)
	|   (((bfd_vma) (field[3])) << 32)
	|   (((bfd_vma) (field[2])) << 40)
	|   (((bfd_vma) (field[1])) << 48)
	|   (((bfd_vma) (field[0])) << 56);
#endif

    default:
      error (_("Unhandled data length: %d\n"), size);
      abort ();
    }
}

static unsigned long int
read_leb128 (unsigned char *data, unsigned int *length_return, int sign)
{
  unsigned long int result = 0;
  unsigned int num_read = 0;
  unsigned int shift = 0;
  unsigned char byte;

  do
    {
      byte = *data++;
      num_read++;

      result |= ((unsigned long int) (byte & 0x7f)) << shift;

      shift += 7;

    }
  while (byte & 0x80);

  if (length_return != NULL)
    *length_return = num_read;

  if (sign && (shift < 8 * sizeof (result)) && (byte & 0x40))
    result |= -1L << shift;

  return result;
}

typedef struct State_Machine_Registers
{
  unsigned long address;
  unsigned int file;
  unsigned int line;
  unsigned int column;
  int is_stmt;
  int basic_block;
  int end_sequence;
/* This variable hold the number of the last entry seen
   in the File Table.  */
  unsigned int last_file_entry;
} SMR;

static SMR state_machine_regs;

static void
reset_state_machine (int is_stmt)
{
  state_machine_regs.address = 0;
  state_machine_regs.file = 1;
  state_machine_regs.line = 1;
  state_machine_regs.column = 0;
  state_machine_regs.is_stmt = is_stmt;
  state_machine_regs.basic_block = 0;
  state_machine_regs.end_sequence = 0;
  state_machine_regs.last_file_entry = 0;
a7447 3
/* Handled an extend line op.
   Returns the number of bytes read.  */

d7449 1
a7449 1
process_extended_line_op (unsigned char *data, int is_stmt, int pointer_size)
d7451 4
a7454 5
  unsigned char op_code;
  unsigned int bytes_read;
  unsigned int len;
  unsigned char *name;
  unsigned long adr;
d7456 2
a7457 4
  len = read_leb128 (data, & bytes_read, 0);
  data += bytes_read;

  if (len == 0)
d7459 2
a7460 2
      warn (_("badly formed extended line op encountered!\n"));
      return bytes_read;
d7463 2
a7464 2
  len += bytes_read;
  op_code = *data++;
d7466 5
a7470 1
  printf (_("  Extended opcode %d: "), op_code);
d7472 3
a7474 6
  switch (op_code)
    {
    case DW_LNE_end_sequence:
      printf (_("End of Sequence\n\n"));
      reset_state_machine (is_stmt);
      break;
d7476 3
a7478 5
    case DW_LNE_set_address:
      adr = byte_get (data, pointer_size);
      printf (_("set Address to 0x%lx\n"), adr);
      state_machine_regs.address = adr;
      break;
d7480 2
a7481 19
    case DW_LNE_define_file:
      printf (_("  define new File Table entry\n"));
      printf (_("  Entry\tDir\tTime\tSize\tName\n"));

      printf (_("   %d\t"), ++state_machine_regs.last_file_entry);
      name = data;
      data += strlen ((char *) data) + 1;
      printf (_("%lu\t"), read_leb128 (data, & bytes_read, 0));
      data += bytes_read;
      printf (_("%lu\t"), read_leb128 (data, & bytes_read, 0));
      data += bytes_read;
      printf (_("%lu\t"), read_leb128 (data, & bytes_read, 0));
      printf (_("%s\n\n"), name);
      break;

    default:
      printf (_("UNKNOWN: length %d\n"), len - bytes_read);
      break;
    }
d7483 1
a7483 17
  return len;
}

static struct dwarf_section debug_str_section = {
  ".debug_str",
  NULL,
  0,
  0
};

static const char *
fetch_indirect_string (unsigned long offset)
{
  if (debug_str_section.start == NULL)
    return _("<no .debug_str section>");

  if (offset > debug_str_section.size)
d7485 2
a7486 2
      warn (_("DW_FORM_strp offset too big: %lx\n"), offset);
      return _("<offset is too big>");
d7489 1
a7489 29
  return debug_str_section.start + offset;
}

static struct dwarf_section debug_abbrev_section = {
  ".debug_abbrev",
  NULL,
  0,
  0
};

/* FIXME:  There are better and more efficient ways to handle
   these structures.  For now though, I just want something that
   is simple to implement.  */
typedef struct abbrev_attr
{
  unsigned long attribute;
  unsigned long form;
  struct abbrev_attr *next;
}
abbrev_attr;

typedef struct abbrev_entry
{
  unsigned long entry;
  unsigned long tag;
  int children;
  struct abbrev_attr *first_attr;
  struct abbrev_attr *last_attr;
  struct abbrev_entry *next;
a7490 4
abbrev_entry;

static abbrev_entry *first_abbrev = NULL;
static abbrev_entry *last_abbrev = NULL;
d7493 1
a7493 1
free_abbrevs (void)
d7495 5
a7499 1
  abbrev_entry *abbrev;
d7501 3
a7503 1
  for (abbrev = first_abbrev; abbrev;)
d7505 6
a7510 2
      abbrev_entry *next = abbrev->next;
      abbrev_attr *attr;
d7512 2
a7513 10
      for (attr = abbrev->first_attr; attr;)
	{
	  abbrev_attr *next = attr->next;

	  free (attr);
	  attr = next;
	}

      free (abbrev);
      abbrev = next;
d7516 5
a7520 1
  last_abbrev = first_abbrev = NULL;
d7524 1
a7524 1
add_abbrev (unsigned long number, unsigned long tag, int children)
d7526 14
a7539 17
  abbrev_entry *entry;

  entry = malloc (sizeof (*entry));

  if (entry == NULL)
    /* ugg */
    return;

  entry->entry      = number;
  entry->tag        = tag;
  entry->children   = children;
  entry->first_attr = NULL;
  entry->last_attr  = NULL;
  entry->next       = NULL;

  if (first_abbrev == NULL)
    first_abbrev = entry;
d7541 1
a7541 3
    last_abbrev->next = entry;

  last_abbrev = entry;
d7544 2
a7545 2
static void
add_abbrev_attr (unsigned long attribute, unsigned long form)
d7547 6
a7552 1
  abbrev_attr *attr;
d7554 4
a7557 1
  attr = malloc (sizeof (*attr));
d7559 4
a7562 3451
  if (attr == NULL)
    /* ugg */
    return;

  attr->attribute = attribute;
  attr->form      = form;
  attr->next      = NULL;

  if (last_abbrev->first_attr == NULL)
    last_abbrev->first_attr = attr;
  else
    last_abbrev->last_attr->next = attr;

  last_abbrev->last_attr = attr;
}

/* Processes the (partial) contents of a .debug_abbrev section.
   Returns NULL if the end of the section was encountered.
   Returns the address after the last byte read if the end of
   an abbreviation set was found.  */

static unsigned char *
process_abbrev_section (unsigned char *start, unsigned char *end)
{
  if (first_abbrev != NULL)
    return NULL;

  while (start < end)
    {
      unsigned int bytes_read;
      unsigned long entry;
      unsigned long tag;
      unsigned long attribute;
      int children;

      entry = read_leb128 (start, & bytes_read, 0);
      start += bytes_read;

      /* A single zero is supposed to end the section according
	 to the standard.  If there's more, then signal that to
	 the caller.  */
      if (entry == 0)
	return start == end ? NULL : start;

      tag = read_leb128 (start, & bytes_read, 0);
      start += bytes_read;

      children = *start++;

      add_abbrev (entry, tag, children);

      do
	{
	  unsigned long form;

	  attribute = read_leb128 (start, & bytes_read, 0);
	  start += bytes_read;

	  form = read_leb128 (start, & bytes_read, 0);
	  start += bytes_read;

	  if (attribute != 0)
	    add_abbrev_attr (attribute, form);
	}
      while (attribute != 0);
    }

  return NULL;
}

static char *
get_TAG_name (unsigned long tag)
{
  switch (tag)
    {
    case DW_TAG_padding:		return "DW_TAG_padding";
    case DW_TAG_array_type:		return "DW_TAG_array_type";
    case DW_TAG_class_type:		return "DW_TAG_class_type";
    case DW_TAG_entry_point:		return "DW_TAG_entry_point";
    case DW_TAG_enumeration_type:	return "DW_TAG_enumeration_type";
    case DW_TAG_formal_parameter:	return "DW_TAG_formal_parameter";
    case DW_TAG_imported_declaration:	return "DW_TAG_imported_declaration";
    case DW_TAG_label:			return "DW_TAG_label";
    case DW_TAG_lexical_block:		return "DW_TAG_lexical_block";
    case DW_TAG_member:			return "DW_TAG_member";
    case DW_TAG_pointer_type:		return "DW_TAG_pointer_type";
    case DW_TAG_reference_type:		return "DW_TAG_reference_type";
    case DW_TAG_compile_unit:		return "DW_TAG_compile_unit";
    case DW_TAG_string_type:		return "DW_TAG_string_type";
    case DW_TAG_structure_type:		return "DW_TAG_structure_type";
    case DW_TAG_subroutine_type:	return "DW_TAG_subroutine_type";
    case DW_TAG_typedef:		return "DW_TAG_typedef";
    case DW_TAG_union_type:		return "DW_TAG_union_type";
    case DW_TAG_unspecified_parameters: return "DW_TAG_unspecified_parameters";
    case DW_TAG_variant:		return "DW_TAG_variant";
    case DW_TAG_common_block:		return "DW_TAG_common_block";
    case DW_TAG_common_inclusion:	return "DW_TAG_common_inclusion";
    case DW_TAG_inheritance:		return "DW_TAG_inheritance";
    case DW_TAG_inlined_subroutine:	return "DW_TAG_inlined_subroutine";
    case DW_TAG_module:			return "DW_TAG_module";
    case DW_TAG_ptr_to_member_type:	return "DW_TAG_ptr_to_member_type";
    case DW_TAG_set_type:		return "DW_TAG_set_type";
    case DW_TAG_subrange_type:		return "DW_TAG_subrange_type";
    case DW_TAG_with_stmt:		return "DW_TAG_with_stmt";
    case DW_TAG_access_declaration:	return "DW_TAG_access_declaration";
    case DW_TAG_base_type:		return "DW_TAG_base_type";
    case DW_TAG_catch_block:		return "DW_TAG_catch_block";
    case DW_TAG_const_type:		return "DW_TAG_const_type";
    case DW_TAG_constant:		return "DW_TAG_constant";
    case DW_TAG_enumerator:		return "DW_TAG_enumerator";
    case DW_TAG_file_type:		return "DW_TAG_file_type";
    case DW_TAG_friend:			return "DW_TAG_friend";
    case DW_TAG_namelist:		return "DW_TAG_namelist";
    case DW_TAG_namelist_item:		return "DW_TAG_namelist_item";
    case DW_TAG_packed_type:		return "DW_TAG_packed_type";
    case DW_TAG_subprogram:		return "DW_TAG_subprogram";
    case DW_TAG_template_type_param:	return "DW_TAG_template_type_param";
    case DW_TAG_template_value_param:	return "DW_TAG_template_value_param";
    case DW_TAG_thrown_type:		return "DW_TAG_thrown_type";
    case DW_TAG_try_block:		return "DW_TAG_try_block";
    case DW_TAG_variant_part:		return "DW_TAG_variant_part";
    case DW_TAG_variable:		return "DW_TAG_variable";
    case DW_TAG_volatile_type:		return "DW_TAG_volatile_type";
    case DW_TAG_MIPS_loop:		return "DW_TAG_MIPS_loop";
    case DW_TAG_format_label:		return "DW_TAG_format_label";
    case DW_TAG_function_template:	return "DW_TAG_function_template";
    case DW_TAG_class_template:		return "DW_TAG_class_template";
      /* DWARF 2.1 values.  */
    case DW_TAG_dwarf_procedure:	return "DW_TAG_dwarf_procedure";
    case DW_TAG_restrict_type:		return "DW_TAG_restrict_type";
    case DW_TAG_interface_type:		return "DW_TAG_interface_type";
    case DW_TAG_namespace:		return "DW_TAG_namespace";
    case DW_TAG_imported_module:	return "DW_TAG_imported_module";
    case DW_TAG_unspecified_type:	return "DW_TAG_unspecified_type";
    case DW_TAG_partial_unit:		return "DW_TAG_partial_unit";
    case DW_TAG_imported_unit:		return "DW_TAG_imported_unit";
      /* UPC values.  */
    case DW_TAG_upc_shared_type:	return "DW_TAG_upc_shared_type";
    case DW_TAG_upc_strict_type:	return "DW_TAG_upc_strict_type";
    case DW_TAG_upc_relaxed_type:	return "DW_TAG_upc_relaxed_type";
    default:
      {
	static char buffer[100];

	snprintf (buffer, sizeof (buffer), _("Unknown TAG value: %lx"), tag);
	return buffer;
      }
    }
}

static char *
get_FORM_name (unsigned long form)
{
  switch (form)
    {
    case DW_FORM_addr:		return "DW_FORM_addr";
    case DW_FORM_block2:	return "DW_FORM_block2";
    case DW_FORM_block4:	return "DW_FORM_block4";
    case DW_FORM_data2:		return "DW_FORM_data2";
    case DW_FORM_data4:		return "DW_FORM_data4";
    case DW_FORM_data8:		return "DW_FORM_data8";
    case DW_FORM_string:	return "DW_FORM_string";
    case DW_FORM_block:		return "DW_FORM_block";
    case DW_FORM_block1:	return "DW_FORM_block1";
    case DW_FORM_data1:		return "DW_FORM_data1";
    case DW_FORM_flag:		return "DW_FORM_flag";
    case DW_FORM_sdata:		return "DW_FORM_sdata";
    case DW_FORM_strp:		return "DW_FORM_strp";
    case DW_FORM_udata:		return "DW_FORM_udata";
    case DW_FORM_ref_addr:	return "DW_FORM_ref_addr";
    case DW_FORM_ref1:		return "DW_FORM_ref1";
    case DW_FORM_ref2:		return "DW_FORM_ref2";
    case DW_FORM_ref4:		return "DW_FORM_ref4";
    case DW_FORM_ref8:		return "DW_FORM_ref8";
    case DW_FORM_ref_udata:	return "DW_FORM_ref_udata";
    case DW_FORM_indirect:	return "DW_FORM_indirect";
    default:
      {
	static char buffer[100];

	snprintf (buffer, sizeof (buffer), _("Unknown FORM value: %lx"), form);
	return buffer;
      }
    }
}

static unsigned char *
display_block (unsigned char *data, unsigned long length)
{
  printf (_(" %lu byte block: "), length);

  while (length --)
    printf ("%lx ", (unsigned long) byte_get (data++, 1));

  return data;
}

static int
decode_location_expression (unsigned char * data,
			    unsigned int pointer_size,
			    unsigned long length,
			    unsigned long cu_offset)
{
  unsigned op;
  unsigned int bytes_read;
  unsigned long uvalue;
  unsigned char *end = data + length;
  int need_frame_base = 0;

  while (data < end)
    {
      op = *data++;

      switch (op)
	{
	case DW_OP_addr:
	  printf ("DW_OP_addr: %lx",
		  (unsigned long) byte_get (data, pointer_size));
	  data += pointer_size;
	  break;
	case DW_OP_deref:
	  printf ("DW_OP_deref");
	  break;
	case DW_OP_const1u:
	  printf ("DW_OP_const1u: %lu", (unsigned long) byte_get (data++, 1));
	  break;
	case DW_OP_const1s:
	  printf ("DW_OP_const1s: %ld", (long) byte_get_signed (data++, 1));
	  break;
	case DW_OP_const2u:
	  printf ("DW_OP_const2u: %lu", (unsigned long) byte_get (data, 2));
	  data += 2;
	  break;
	case DW_OP_const2s:
	  printf ("DW_OP_const2s: %ld", (long) byte_get_signed (data, 2));
	  data += 2;
	  break;
	case DW_OP_const4u:
	  printf ("DW_OP_const4u: %lu", (unsigned long) byte_get (data, 4));
	  data += 4;
	  break;
	case DW_OP_const4s:
	  printf ("DW_OP_const4s: %ld", (long) byte_get_signed (data, 4));
	  data += 4;
	  break;
	case DW_OP_const8u:
	  printf ("DW_OP_const8u: %lu %lu", (unsigned long) byte_get (data, 4),
		  (unsigned long) byte_get (data + 4, 4));
	  data += 8;
	  break;
	case DW_OP_const8s:
	  printf ("DW_OP_const8s: %ld %ld", (long) byte_get (data, 4),
		  (long) byte_get (data + 4, 4));
	  data += 8;
	  break;
	case DW_OP_constu:
	  printf ("DW_OP_constu: %lu", read_leb128 (data, &bytes_read, 0));
	  data += bytes_read;
	  break;
	case DW_OP_consts:
	  printf ("DW_OP_consts: %ld", read_leb128 (data, &bytes_read, 1));
	  data += bytes_read;
	  break;
	case DW_OP_dup:
	  printf ("DW_OP_dup");
	  break;
	case DW_OP_drop:
	  printf ("DW_OP_drop");
	  break;
	case DW_OP_over:
	  printf ("DW_OP_over");
	  break;
	case DW_OP_pick:
	  printf ("DW_OP_pick: %ld", (unsigned long) byte_get (data++, 1));
	  break;
	case DW_OP_swap:
	  printf ("DW_OP_swap");
	  break;
	case DW_OP_rot:
	  printf ("DW_OP_rot");
	  break;
	case DW_OP_xderef:
	  printf ("DW_OP_xderef");
	  break;
	case DW_OP_abs:
	  printf ("DW_OP_abs");
	  break;
	case DW_OP_and:
	  printf ("DW_OP_and");
	  break;
	case DW_OP_div:
	  printf ("DW_OP_div");
	  break;
	case DW_OP_minus:
	  printf ("DW_OP_minus");
	  break;
	case DW_OP_mod:
	  printf ("DW_OP_mod");
	  break;
	case DW_OP_mul:
	  printf ("DW_OP_mul");
	  break;
	case DW_OP_neg:
	  printf ("DW_OP_neg");
	  break;
	case DW_OP_not:
	  printf ("DW_OP_not");
	  break;
	case DW_OP_or:
	  printf ("DW_OP_or");
	  break;
	case DW_OP_plus:
	  printf ("DW_OP_plus");
	  break;
	case DW_OP_plus_uconst:
	  printf ("DW_OP_plus_uconst: %lu",
		  read_leb128 (data, &bytes_read, 0));
	  data += bytes_read;
	  break;
	case DW_OP_shl:
	  printf ("DW_OP_shl");
	  break;
	case DW_OP_shr:
	  printf ("DW_OP_shr");
	  break;
	case DW_OP_shra:
	  printf ("DW_OP_shra");
	  break;
	case DW_OP_xor:
	  printf ("DW_OP_xor");
	  break;
	case DW_OP_bra:
	  printf ("DW_OP_bra: %ld", (long) byte_get_signed (data, 2));
	  data += 2;
	  break;
	case DW_OP_eq:
	  printf ("DW_OP_eq");
	  break;
	case DW_OP_ge:
	  printf ("DW_OP_ge");
	  break;
	case DW_OP_gt:
	  printf ("DW_OP_gt");
	  break;
	case DW_OP_le:
	  printf ("DW_OP_le");
	  break;
	case DW_OP_lt:
	  printf ("DW_OP_lt");
	  break;
	case DW_OP_ne:
	  printf ("DW_OP_ne");
	  break;
	case DW_OP_skip:
	  printf ("DW_OP_skip: %ld", (long) byte_get_signed (data, 2));
	  data += 2;
	  break;

	case DW_OP_lit0:
	case DW_OP_lit1:
	case DW_OP_lit2:
	case DW_OP_lit3:
	case DW_OP_lit4:
	case DW_OP_lit5:
	case DW_OP_lit6:
	case DW_OP_lit7:
	case DW_OP_lit8:
	case DW_OP_lit9:
	case DW_OP_lit10:
	case DW_OP_lit11:
	case DW_OP_lit12:
	case DW_OP_lit13:
	case DW_OP_lit14:
	case DW_OP_lit15:
	case DW_OP_lit16:
	case DW_OP_lit17:
	case DW_OP_lit18:
	case DW_OP_lit19:
	case DW_OP_lit20:
	case DW_OP_lit21:
	case DW_OP_lit22:
	case DW_OP_lit23:
	case DW_OP_lit24:
	case DW_OP_lit25:
	case DW_OP_lit26:
	case DW_OP_lit27:
	case DW_OP_lit28:
	case DW_OP_lit29:
	case DW_OP_lit30:
	case DW_OP_lit31:
	  printf ("DW_OP_lit%d", op - DW_OP_lit0);
	  break;

	case DW_OP_reg0:
	case DW_OP_reg1:
	case DW_OP_reg2:
	case DW_OP_reg3:
	case DW_OP_reg4:
	case DW_OP_reg5:
	case DW_OP_reg6:
	case DW_OP_reg7:
	case DW_OP_reg8:
	case DW_OP_reg9:
	case DW_OP_reg10:
	case DW_OP_reg11:
	case DW_OP_reg12:
	case DW_OP_reg13:
	case DW_OP_reg14:
	case DW_OP_reg15:
	case DW_OP_reg16:
	case DW_OP_reg17:
	case DW_OP_reg18:
	case DW_OP_reg19:
	case DW_OP_reg20:
	case DW_OP_reg21:
	case DW_OP_reg22:
	case DW_OP_reg23:
	case DW_OP_reg24:
	case DW_OP_reg25:
	case DW_OP_reg26:
	case DW_OP_reg27:
	case DW_OP_reg28:
	case DW_OP_reg29:
	case DW_OP_reg30:
	case DW_OP_reg31:
	  printf ("DW_OP_reg%d", op - DW_OP_reg0);
	  break;

	case DW_OP_breg0:
	case DW_OP_breg1:
	case DW_OP_breg2:
	case DW_OP_breg3:
	case DW_OP_breg4:
	case DW_OP_breg5:
	case DW_OP_breg6:
	case DW_OP_breg7:
	case DW_OP_breg8:
	case DW_OP_breg9:
	case DW_OP_breg10:
	case DW_OP_breg11:
	case DW_OP_breg12:
	case DW_OP_breg13:
	case DW_OP_breg14:
	case DW_OP_breg15:
	case DW_OP_breg16:
	case DW_OP_breg17:
	case DW_OP_breg18:
	case DW_OP_breg19:
	case DW_OP_breg20:
	case DW_OP_breg21:
	case DW_OP_breg22:
	case DW_OP_breg23:
	case DW_OP_breg24:
	case DW_OP_breg25:
	case DW_OP_breg26:
	case DW_OP_breg27:
	case DW_OP_breg28:
	case DW_OP_breg29:
	case DW_OP_breg30:
	case DW_OP_breg31:
	  printf ("DW_OP_breg%d: %ld", op - DW_OP_breg0,
		  read_leb128 (data, &bytes_read, 1));
	  data += bytes_read;
	  break;

	case DW_OP_regx:
	  printf ("DW_OP_regx: %lu", read_leb128 (data, &bytes_read, 0));
	  data += bytes_read;
	  break;
	case DW_OP_fbreg:
	  need_frame_base = 1;
	  printf ("DW_OP_fbreg: %ld", read_leb128 (data, &bytes_read, 1));
	  data += bytes_read;
	  break;
	case DW_OP_bregx:
	  uvalue = read_leb128 (data, &bytes_read, 0);
	  data += bytes_read;
	  printf ("DW_OP_bregx: %lu %ld", uvalue,
		  read_leb128 (data, &bytes_read, 1));
	  data += bytes_read;
	  break;
	case DW_OP_piece:
	  printf ("DW_OP_piece: %lu", read_leb128 (data, &bytes_read, 0));
	  data += bytes_read;
	  break;
	case DW_OP_deref_size:
	  printf ("DW_OP_deref_size: %ld", (long) byte_get (data++, 1));
	  break;
	case DW_OP_xderef_size:
	  printf ("DW_OP_xderef_size: %ld", (long) byte_get (data++, 1));
	  break;
	case DW_OP_nop:
	  printf ("DW_OP_nop");
	  break;

	  /* DWARF 3 extensions.  */
	case DW_OP_push_object_address:
	  printf ("DW_OP_push_object_address");
	  break;
	case DW_OP_call2:
	  /* XXX: Strictly speaking for 64-bit DWARF3 files
	     this ought to be an 8-byte wide computation.  */
	  printf ("DW_OP_call2: <%lx>", (long) byte_get (data, 2) + cu_offset);
	  data += 2;
	  break;
	case DW_OP_call4:
	  /* XXX: Strictly speaking for 64-bit DWARF3 files
	     this ought to be an 8-byte wide computation.  */
	  printf ("DW_OP_call4: <%lx>", (long) byte_get (data, 4) + cu_offset);
	  data += 4;
	  break;
	case DW_OP_call_ref:
	  printf ("DW_OP_call_ref");
	  break;

	  /* GNU extensions.  */
	case DW_OP_GNU_push_tls_address:
	  printf ("DW_OP_GNU_push_tls_address");
	  break;

	default:
	  if (op >= DW_OP_lo_user
	      && op <= DW_OP_hi_user)
	    printf (_("(User defined location op)"));
	  else
	    printf (_("(Unknown location op)"));
	  /* No way to tell where the next op is, so just bail.  */
	  return need_frame_base;
	}

      /* Separate the ops.  */
      if (data < end)
	printf ("; ");
    }

  return need_frame_base;
}

/* This structure records the information that
   we extract from the.debug_info section.  */
typedef struct
{
  unsigned int   pointer_size;
  unsigned long  cu_offset;
  unsigned long	 base_address;
  /* This is an array of offsets to the location list table.  */
  unsigned long *loc_offsets;
  int		*have_frame_base;
  unsigned int   num_loc_offsets;
  unsigned int   max_loc_offsets;
  unsigned long *range_lists;
  unsigned int   num_range_lists;
  unsigned int   max_range_lists;
}
debug_info;

static debug_info *   debug_information = NULL;
static unsigned int   num_debug_info_entries = 0;
static unsigned int   last_pointer_size = 0;
static int            warned_about_missing_comp_units = FALSE;

static unsigned char *
read_and_display_attr_value (unsigned long attribute,
			     unsigned long form,
			     unsigned char *data,
			     unsigned long cu_offset,
			     unsigned long pointer_size,
			     unsigned long offset_size,
			     int dwarf_version,
			     debug_info *debug_info_p,
			     int do_loc)
{
  unsigned long uvalue = 0;
  unsigned char *block_start = NULL;
  unsigned int bytes_read;

  switch (form)
    {
    default:
      break;

    case DW_FORM_ref_addr:
      if (dwarf_version == 2)
	{
	  uvalue = byte_get (data, pointer_size);
	  data += pointer_size;
	}
      else if (dwarf_version == 3)
	{
	  uvalue = byte_get (data, offset_size);
	  data += offset_size;
	}
      else
	{
	  error (_("Internal error: DWARF version is not 2 or 3.\n"));
	}
      break;

    case DW_FORM_addr:
      uvalue = byte_get (data, pointer_size);
      data += pointer_size;
      break;

    case DW_FORM_strp:
      uvalue = byte_get (data, offset_size);
      data += offset_size;
      break;

    case DW_FORM_ref1:
    case DW_FORM_flag:
    case DW_FORM_data1:
      uvalue = byte_get (data++, 1);
      break;

    case DW_FORM_ref2:
    case DW_FORM_data2:
      uvalue = byte_get (data, 2);
      data += 2;
      break;

    case DW_FORM_ref4:
    case DW_FORM_data4:
      uvalue = byte_get (data, 4);
      data += 4;
      break;

    case DW_FORM_sdata:
      uvalue = read_leb128 (data, & bytes_read, 1);
      data += bytes_read;
      break;

    case DW_FORM_ref_udata:
    case DW_FORM_udata:
      uvalue = read_leb128 (data, & bytes_read, 0);
      data += bytes_read;
      break;

    case DW_FORM_indirect:
      form = read_leb128 (data, & bytes_read, 0);
      data += bytes_read;
      if (!do_loc)
	printf (" %s", get_FORM_name (form));
      return read_and_display_attr_value (attribute, form, data,
					  cu_offset, pointer_size,
					  offset_size, dwarf_version,
					  debug_info_p, do_loc);
    }

  switch (form)
    {
    case DW_FORM_ref_addr:
      if (!do_loc)
	printf (" <#%lx>", uvalue);
      break;

    case DW_FORM_ref1:
    case DW_FORM_ref2:
    case DW_FORM_ref4:
    case DW_FORM_ref_udata:
      if (!do_loc)
	printf (" <%lx>", uvalue + cu_offset);
      break;

    case DW_FORM_data4:
    case DW_FORM_addr:
      if (!do_loc)
	printf (" %#lx", uvalue);
      break;

    case DW_FORM_flag:
    case DW_FORM_data1:
    case DW_FORM_data2:
    case DW_FORM_sdata:
    case DW_FORM_udata:
      if (!do_loc)
	printf (" %ld", uvalue);
      break;

    case DW_FORM_ref8:
    case DW_FORM_data8:
      if (!do_loc)
	{
	  uvalue = byte_get (data, 4);
	  printf (" %lx", uvalue);
	  printf (" %lx", (unsigned long) byte_get (data + 4, 4));
	}
      if ((do_loc || do_debug_loc || do_debug_ranges)
	  && num_debug_info_entries == 0)
	{
	  if (sizeof (uvalue) == 8)
	    uvalue = byte_get (data, 8);
	  else
	    error (_("DW_FORM_data8 is unsupported when sizeof (unsigned long) != 8\n"));
	}
      data += 8;
      break;

    case DW_FORM_string:
      if (!do_loc)
	printf (" %s", data);
      data += strlen ((char *) data) + 1;
      break;

    case DW_FORM_block:
      uvalue = read_leb128 (data, & bytes_read, 0);
      block_start = data + bytes_read;
      if (do_loc)
	data = block_start + uvalue;
      else
	data = display_block (block_start, uvalue);
      break;

    case DW_FORM_block1:
      uvalue = byte_get (data, 1);
      block_start = data + 1;
      if (do_loc)
	data = block_start + uvalue;
      else
	data = display_block (block_start, uvalue);
      break;

    case DW_FORM_block2:
      uvalue = byte_get (data, 2);
      block_start = data + 2;
      if (do_loc)
	data = block_start + uvalue;
      else
	data = display_block (block_start, uvalue);
      break;

    case DW_FORM_block4:
      uvalue = byte_get (data, 4);
      block_start = data + 4;
      if (do_loc)
	data = block_start + uvalue;
      else
	data = display_block (block_start, uvalue);
      break;

    case DW_FORM_strp:
      if (!do_loc)
	printf (_(" (indirect string, offset: 0x%lx): %s"),
		uvalue, fetch_indirect_string (uvalue));
      break;

    case DW_FORM_indirect:
      /* Handled above.  */
      break;

    default:
      warn (_("Unrecognized form: %lu\n"), form);
      break;
    }

  /* For some attributes we can display further information.  */
  if ((do_loc || do_debug_loc || do_debug_ranges)
      && num_debug_info_entries == 0)
    {
      switch (attribute)
	{
	case DW_AT_frame_base:
	  have_frame_base = 1;
	case DW_AT_location:
	case DW_AT_data_member_location:
	case DW_AT_vtable_elem_location:
	case DW_AT_allocated:
	case DW_AT_associated:
	case DW_AT_data_location:
	case DW_AT_stride:
	case DW_AT_upper_bound:
	case DW_AT_lower_bound:
	  if (form == DW_FORM_data4 || form == DW_FORM_data8)
	    {
	      /* Process location list.  */
	      unsigned int max = debug_info_p->max_loc_offsets;
	      unsigned int num = debug_info_p->num_loc_offsets;

	      if (max == 0 || num >= max)
		{
		  max += 1024;
		  debug_info_p->loc_offsets
		    = xcrealloc (debug_info_p->loc_offsets,
				 max, sizeof (*debug_info_p->loc_offsets));
		  debug_info_p->have_frame_base
		    = xcrealloc (debug_info_p->have_frame_base,
				 max, sizeof (*debug_info_p->have_frame_base));
		  debug_info_p->max_loc_offsets = max;
		}
	      debug_info_p->loc_offsets [num] = uvalue;
	      debug_info_p->have_frame_base [num] = have_frame_base;
	      debug_info_p->num_loc_offsets++;
	    }
	  break;
	
	case DW_AT_low_pc:
	  if (need_base_address)
	    debug_info_p->base_address = uvalue;
	  break;

	case DW_AT_ranges:
	  if (form == DW_FORM_data4 || form == DW_FORM_data8)
	    {
	      /* Process range list.  */
	      unsigned int max = debug_info_p->max_range_lists;
	      unsigned int num = debug_info_p->num_range_lists;

	      if (max == 0 || num >= max)
		{
		  max += 1024;
		  debug_info_p->range_lists
		    = xcrealloc (debug_info_p->range_lists,
				 max, sizeof (*debug_info_p->range_lists));
		  debug_info_p->max_range_lists = max;
		}
	      debug_info_p->range_lists [num] = uvalue;
	      debug_info_p->num_range_lists++;
	    }
	  break;

	default:
	  break;
	}
    }

  if (do_loc)
    return data;

  printf ("\t");

  switch (attribute)
    {
    case DW_AT_inline:
      switch (uvalue)
	{
	case DW_INL_not_inlined:
	  printf (_("(not inlined)"));
	  break;
	case DW_INL_inlined:
	  printf (_("(inlined)"));
	  break;
	case DW_INL_declared_not_inlined:
	  printf (_("(declared as inline but ignored)"));
	  break;
	case DW_INL_declared_inlined:
	  printf (_("(declared as inline and inlined)"));
	  break;
	default:
	  printf (_("  (Unknown inline attribute value: %lx)"), uvalue);
	  break;
	}
      break;

    case DW_AT_language:
      switch (uvalue)
	{
	case DW_LANG_C:			printf ("(non-ANSI C)"); break;
	case DW_LANG_C89:		printf ("(ANSI C)"); break;
	case DW_LANG_C_plus_plus:	printf ("(C++)"); break;
	case DW_LANG_Fortran77:		printf ("(FORTRAN 77)"); break;
	case DW_LANG_Fortran90:		printf ("(Fortran 90)"); break;
	case DW_LANG_Modula2:		printf ("(Modula 2)"); break;
	case DW_LANG_Pascal83:		printf ("(ANSI Pascal)"); break;
	case DW_LANG_Ada83:		printf ("(Ada)"); break;
	case DW_LANG_Cobol74:		printf ("(Cobol 74)"); break;
	case DW_LANG_Cobol85:		printf ("(Cobol 85)"); break;
	  /* DWARF 2.1 values.	*/
	case DW_LANG_C99:		printf ("(ANSI C99)"); break;
	case DW_LANG_Ada95:		printf ("(ADA 95)"); break;
	case DW_LANG_Fortran95:		printf ("(Fortran 95)"); break;
	  /* MIPS extension.  */
	case DW_LANG_Mips_Assembler:	printf ("(MIPS assembler)"); break;
	  /* UPC extension.  */
	case DW_LANG_Upc:		printf ("(Unified Parallel C)"); break;
	default:
	  printf ("(Unknown: %lx)", uvalue);
	  break;
	}
      break;

    case DW_AT_encoding:
      switch (uvalue)
	{
	case DW_ATE_void:		printf ("(void)"); break;
	case DW_ATE_address:		printf ("(machine address)"); break;
	case DW_ATE_boolean:		printf ("(boolean)"); break;
	case DW_ATE_complex_float:	printf ("(complex float)"); break;
	case DW_ATE_float:		printf ("(float)"); break;
	case DW_ATE_signed:		printf ("(signed)"); break;
	case DW_ATE_signed_char:	printf ("(signed char)"); break;
	case DW_ATE_unsigned:		printf ("(unsigned)"); break;
	case DW_ATE_unsigned_char:	printf ("(unsigned char)"); break;
	  /* DWARF 2.1 value.  */
	case DW_ATE_imaginary_float:	printf ("(imaginary float)"); break;
	case DW_ATE_decimal_float:	printf ("(decimal float)"); break;
	default:
	  if (uvalue >= DW_ATE_lo_user
	      && uvalue <= DW_ATE_hi_user)
	    printf ("(user defined type)");
	  else
	    printf ("(unknown type)");
	  break;
	}
      break;

    case DW_AT_accessibility:
      switch (uvalue)
	{
	case DW_ACCESS_public:		printf ("(public)"); break;
	case DW_ACCESS_protected:	printf ("(protected)"); break;
	case DW_ACCESS_private:		printf ("(private)"); break;
	default:
	  printf ("(unknown accessibility)");
	  break;
	}
      break;

    case DW_AT_visibility:
      switch (uvalue)
	{
	case DW_VIS_local:		printf ("(local)"); break;
	case DW_VIS_exported:		printf ("(exported)"); break;
	case DW_VIS_qualified:		printf ("(qualified)"); break;
	default:			printf ("(unknown visibility)"); break;
	}
      break;

    case DW_AT_virtuality:
      switch (uvalue)
	{
	case DW_VIRTUALITY_none:	printf ("(none)"); break;
	case DW_VIRTUALITY_virtual:	printf ("(virtual)"); break;
	case DW_VIRTUALITY_pure_virtual:printf ("(pure_virtual)"); break;
	default:			printf ("(unknown virtuality)"); break;
	}
      break;

    case DW_AT_identifier_case:
      switch (uvalue)
	{
	case DW_ID_case_sensitive:	printf ("(case_sensitive)"); break;
	case DW_ID_up_case:		printf ("(up_case)"); break;
	case DW_ID_down_case:		printf ("(down_case)"); break;
	case DW_ID_case_insensitive:	printf ("(case_insensitive)"); break;
	default:			printf ("(unknown case)"); break;
	}
      break;

    case DW_AT_calling_convention:
      switch (uvalue)
	{
	case DW_CC_normal:	printf ("(normal)"); break;
	case DW_CC_program:	printf ("(program)"); break;
	case DW_CC_nocall:	printf ("(nocall)"); break;
	default:
	  if (uvalue >= DW_CC_lo_user
	      && uvalue <= DW_CC_hi_user)
	    printf ("(user defined)");
	  else
	    printf ("(unknown convention)");
	}
      break;

    case DW_AT_ordering:
      switch (uvalue)
	{
	case -1: printf ("(undefined)"); break;
	case 0:  printf ("(row major)"); break;
	case 1:  printf ("(column major)"); break;
	}
      break;

    case DW_AT_frame_base:
      have_frame_base = 1;
    case DW_AT_location:
    case DW_AT_data_member_location:
    case DW_AT_vtable_elem_location:
    case DW_AT_allocated:
    case DW_AT_associated:
    case DW_AT_data_location:
    case DW_AT_stride:
    case DW_AT_upper_bound:
    case DW_AT_lower_bound:
      if (block_start)
	{
	  int need_frame_base;

	  printf ("(");
	  need_frame_base = decode_location_expression (block_start,
							pointer_size,
							uvalue,
							cu_offset);
	  printf (")");
	  if (need_frame_base && !have_frame_base)
	    printf (_(" [without DW_AT_frame_base]"));
	}
      else if (form == DW_FORM_data4 || form == DW_FORM_data8)
	printf (_("(location list)"));

      break;

    default:
      break;
    }

  return data;
}

static char *
get_AT_name (unsigned long attribute)
{
  switch (attribute)
    {
    case DW_AT_sibling:			return "DW_AT_sibling";
    case DW_AT_location:		return "DW_AT_location";
    case DW_AT_name:			return "DW_AT_name";
    case DW_AT_ordering:		return "DW_AT_ordering";
    case DW_AT_subscr_data:		return "DW_AT_subscr_data";
    case DW_AT_byte_size:		return "DW_AT_byte_size";
    case DW_AT_bit_offset:		return "DW_AT_bit_offset";
    case DW_AT_bit_size:		return "DW_AT_bit_size";
    case DW_AT_element_list:		return "DW_AT_element_list";
    case DW_AT_stmt_list:		return "DW_AT_stmt_list";
    case DW_AT_low_pc:			return "DW_AT_low_pc";
    case DW_AT_high_pc:			return "DW_AT_high_pc";
    case DW_AT_language:		return "DW_AT_language";
    case DW_AT_member:			return "DW_AT_member";
    case DW_AT_discr:			return "DW_AT_discr";
    case DW_AT_discr_value:		return "DW_AT_discr_value";
    case DW_AT_visibility:		return "DW_AT_visibility";
    case DW_AT_import:			return "DW_AT_import";
    case DW_AT_string_length:		return "DW_AT_string_length";
    case DW_AT_common_reference:	return "DW_AT_common_reference";
    case DW_AT_comp_dir:		return "DW_AT_comp_dir";
    case DW_AT_const_value:		return "DW_AT_const_value";
    case DW_AT_containing_type:		return "DW_AT_containing_type";
    case DW_AT_default_value:		return "DW_AT_default_value";
    case DW_AT_inline:			return "DW_AT_inline";
    case DW_AT_is_optional:		return "DW_AT_is_optional";
    case DW_AT_lower_bound:		return "DW_AT_lower_bound";
    case DW_AT_producer:		return "DW_AT_producer";
    case DW_AT_prototyped:		return "DW_AT_prototyped";
    case DW_AT_return_addr:		return "DW_AT_return_addr";
    case DW_AT_start_scope:		return "DW_AT_start_scope";
    case DW_AT_stride_size:		return "DW_AT_stride_size";
    case DW_AT_upper_bound:		return "DW_AT_upper_bound";
    case DW_AT_abstract_origin:		return "DW_AT_abstract_origin";
    case DW_AT_accessibility:		return "DW_AT_accessibility";
    case DW_AT_address_class:		return "DW_AT_address_class";
    case DW_AT_artificial:		return "DW_AT_artificial";
    case DW_AT_base_types:		return "DW_AT_base_types";
    case DW_AT_calling_convention:	return "DW_AT_calling_convention";
    case DW_AT_count:			return "DW_AT_count";
    case DW_AT_data_member_location:	return "DW_AT_data_member_location";
    case DW_AT_decl_column:		return "DW_AT_decl_column";
    case DW_AT_decl_file:		return "DW_AT_decl_file";
    case DW_AT_decl_line:		return "DW_AT_decl_line";
    case DW_AT_declaration:		return "DW_AT_declaration";
    case DW_AT_discr_list:		return "DW_AT_discr_list";
    case DW_AT_encoding:		return "DW_AT_encoding";
    case DW_AT_external:		return "DW_AT_external";
    case DW_AT_frame_base:		return "DW_AT_frame_base";
    case DW_AT_friend:			return "DW_AT_friend";
    case DW_AT_identifier_case:		return "DW_AT_identifier_case";
    case DW_AT_macro_info:		return "DW_AT_macro_info";
    case DW_AT_namelist_items:		return "DW_AT_namelist_items";
    case DW_AT_priority:		return "DW_AT_priority";
    case DW_AT_segment:			return "DW_AT_segment";
    case DW_AT_specification:		return "DW_AT_specification";
    case DW_AT_static_link:		return "DW_AT_static_link";
    case DW_AT_type:			return "DW_AT_type";
    case DW_AT_use_location:		return "DW_AT_use_location";
    case DW_AT_variable_parameter:	return "DW_AT_variable_parameter";
    case DW_AT_virtuality:		return "DW_AT_virtuality";
    case DW_AT_vtable_elem_location:	return "DW_AT_vtable_elem_location";
      /* DWARF 2.1 values.  */
    case DW_AT_allocated:		return "DW_AT_allocated";
    case DW_AT_associated:		return "DW_AT_associated";
    case DW_AT_data_location:		return "DW_AT_data_location";
    case DW_AT_stride:			return "DW_AT_stride";
    case DW_AT_entry_pc:		return "DW_AT_entry_pc";
    case DW_AT_use_UTF8:		return "DW_AT_use_UTF8";
    case DW_AT_extension:		return "DW_AT_extension";
    case DW_AT_ranges:			return "DW_AT_ranges";
    case DW_AT_trampoline:		return "DW_AT_trampoline";
    case DW_AT_call_column:		return "DW_AT_call_column";
    case DW_AT_call_file:		return "DW_AT_call_file";
    case DW_AT_call_line:		return "DW_AT_call_line";
      /* SGI/MIPS extensions.  */
    case DW_AT_MIPS_fde:		return "DW_AT_MIPS_fde";
    case DW_AT_MIPS_loop_begin:		return "DW_AT_MIPS_loop_begin";
    case DW_AT_MIPS_tail_loop_begin:	return "DW_AT_MIPS_tail_loop_begin";
    case DW_AT_MIPS_epilog_begin:	return "DW_AT_MIPS_epilog_begin";
    case DW_AT_MIPS_loop_unroll_factor: return "DW_AT_MIPS_loop_unroll_factor";
    case DW_AT_MIPS_software_pipeline_depth:
      return "DW_AT_MIPS_software_pipeline_depth";
    case DW_AT_MIPS_linkage_name:	return "DW_AT_MIPS_linkage_name";
    case DW_AT_MIPS_stride:		return "DW_AT_MIPS_stride";
    case DW_AT_MIPS_abstract_name:	return "DW_AT_MIPS_abstract_name";
    case DW_AT_MIPS_clone_origin:	return "DW_AT_MIPS_clone_origin";
    case DW_AT_MIPS_has_inlines:	return "DW_AT_MIPS_has_inlines";
      /* GNU extensions.  */
    case DW_AT_sf_names:		return "DW_AT_sf_names";
    case DW_AT_src_info:		return "DW_AT_src_info";
    case DW_AT_mac_info:		return "DW_AT_mac_info";
    case DW_AT_src_coords:		return "DW_AT_src_coords";
    case DW_AT_body_begin:		return "DW_AT_body_begin";
    case DW_AT_body_end:		return "DW_AT_body_end";
    case DW_AT_GNU_vector:		return "DW_AT_GNU_vector";
      /* UPC extension.  */
    case DW_AT_upc_threads_scaled:	return "DW_AT_upc_threads_scaled";
    default:
      {
	static char buffer[100];

	snprintf (buffer, sizeof (buffer), _("Unknown AT value: %lx"),
		  attribute);
	return buffer;
      }
    }
}

static unsigned char *
read_and_display_attr (unsigned long attribute,
		       unsigned long form,
		       unsigned char *data,
		       unsigned long cu_offset,
		       unsigned long pointer_size,
		       unsigned long offset_size,
		       int dwarf_version,
		       debug_info *debug_info_p,
		       int do_loc)
{
  if (!do_loc)
    printf ("     %-18s:", get_AT_name (attribute));
  data = read_and_display_attr_value (attribute, form, data, cu_offset,
				      pointer_size, offset_size,
				      dwarf_version, debug_info_p,
				      do_loc);
  if (!do_loc)
    printf ("\n");
  return data;
}


/* Process the contents of a .debug_info section.  If do_loc is non-zero
   then we are scanning for location lists and we do not want to display
   anything to the user.  */

static int
process_debug_info (struct dwarf_section *section, void *file,
		    int do_loc)
{
  unsigned char *start = section->start;
  unsigned char *end = start + section->size;
  unsigned char *section_begin;
  unsigned int unit;
  unsigned int num_units = 0;

  if ((do_loc || do_debug_loc || do_debug_ranges)
      && num_debug_info_entries == 0)
    {
      unsigned long length;

      /* First scan the section to get the number of comp units.  */
      for (section_begin = start, num_units = 0; section_begin < end;
	   num_units ++)
	{
	  /* Read the first 4 bytes.  For a 32-bit DWARF section, this
	     will be the length.  For a 64-bit DWARF section, it'll be
	     the escape code 0xffffffff followed by an 8 byte length.  */
	  length = byte_get (section_begin, 4);

	  if (length == 0xffffffff)
	    {
	      length = byte_get (section_begin + 4, 8);
	      section_begin += length + 12;
	    }
	  else
	    section_begin += length + 4;
	}

      if (num_units == 0)
	{
	  error (_("No comp units in %s section ?"), section->name);
	  return 0;
	}

      /* Then allocate an array to hold the information.  */
      debug_information = cmalloc (num_units,
				   sizeof (* debug_information));
      if (debug_information == NULL)
	{
	  error (_("Not enough memory for a debug info array of %u entries"),
		 num_units);
	  return 0;
	}
    }

  if (!do_loc)
    {
      printf (_("The section %s contains:\n\n"), section->name);

      load_debug_section (&debug_str_section, file);
    }

  load_debug_section (&debug_abbrev_section, file);
  if (debug_abbrev_section.start == NULL)
    {
      warn (_("Unable to locate %s section!\n"),
	    debug_abbrev_section.name);
      return 0;
    }

  for (section_begin = start, unit = 0; start < end; unit++)
    {
      DWARF2_Internal_CompUnit compunit;
      unsigned char *hdrptr;
      unsigned char *cu_abbrev_offset_ptr;
      unsigned char *tags;
      int level;
      unsigned long cu_offset;
      int offset_size;
      int initial_length_size;

      hdrptr = start;

      compunit.cu_length = byte_get (hdrptr, 4);
      hdrptr += 4;

      if (compunit.cu_length == 0xffffffff)
	{
	  compunit.cu_length = byte_get (hdrptr, 8);
	  hdrptr += 8;
	  offset_size = 8;
	  initial_length_size = 12;
	}
      else
	{
	  offset_size = 4;
	  initial_length_size = 4;
	}

      compunit.cu_version = byte_get (hdrptr, 2);
      hdrptr += 2;

      cu_offset = start - section_begin;
      start += compunit.cu_length + initial_length_size;

      cu_abbrev_offset_ptr = hdrptr;
      compunit.cu_abbrev_offset = byte_get (hdrptr, offset_size);
      hdrptr += offset_size;

      compunit.cu_pointer_size = byte_get (hdrptr, 1);
      hdrptr += 1;
      if ((do_loc || do_debug_loc || do_debug_ranges)
	  && num_debug_info_entries == 0)
	{
	  debug_information [unit].cu_offset = cu_offset;
	  debug_information [unit].pointer_size
	    = compunit.cu_pointer_size;
	  debug_information [unit].base_address = 0;
	  debug_information [unit].loc_offsets = NULL;
	  debug_information [unit].have_frame_base = NULL;
	  debug_information [unit].max_loc_offsets = 0;
	  debug_information [unit].num_loc_offsets = 0;
	  debug_information [unit].range_lists = NULL;
	  debug_information [unit].max_range_lists= 0;
	  debug_information [unit].num_range_lists = 0;
	}

      tags = hdrptr;

      if (!do_loc)
	{
	  printf (_("  Compilation Unit @@ offset 0x%lx:\n"), cu_offset);
	  printf (_("   Length:        %ld\n"), compunit.cu_length);
	  printf (_("   Version:       %d\n"), compunit.cu_version);
	  printf (_("   Abbrev Offset: %ld\n"), compunit.cu_abbrev_offset);
	  printf (_("   Pointer Size:  %d\n"), compunit.cu_pointer_size);
	}

      if (compunit.cu_version != 2 && compunit.cu_version != 3)
	{
	  warn (_("Only version 2 and 3 DWARF debug information is currently supported.\n"));
	  continue;
	}

      free_abbrevs ();

      /* Process the abbrevs used by this compilation unit.  */
      process_abbrev_section
	((unsigned char *) debug_abbrev_section.start
	 + compunit.cu_abbrev_offset,
	 (unsigned char *) debug_abbrev_section.start
	 + debug_abbrev_section.size);

      level = 0;
      while (tags < start)
	{
	  unsigned int bytes_read;
	  unsigned long abbrev_number;
	  abbrev_entry *entry;
	  abbrev_attr *attr;

	  abbrev_number = read_leb128 (tags, & bytes_read, 0);
	  tags += bytes_read;

	  /* A null DIE marks the end of a list of children.  */
	  if (abbrev_number == 0)
	    {
	      --level;
	      continue;
	    }

	  /* Scan through the abbreviation list until we reach the
	     correct entry.  */
	  for (entry = first_abbrev;
	       entry && entry->entry != abbrev_number;
	       entry = entry->next)
	    continue;

	  if (entry == NULL)
	    {
	      warn (_("Unable to locate entry %lu in the abbreviation table\n"),
		    abbrev_number);
	      return 0;
	    }

	  if (!do_loc)
	    printf (_(" <%d><%lx>: Abbrev Number: %lu (%s)\n"),
		    level,
		    (unsigned long) (tags - section_begin
				     - bytes_read),
		    abbrev_number,
		    get_TAG_name (entry->tag));
 
	  switch (entry->tag)
	    {
	    default:
	      need_base_address = 0;
	      break;
	    case DW_TAG_compile_unit:
	      need_base_address = 1;
	      break;
	    case DW_TAG_entry_point:
	    case DW_TAG_inlined_subroutine:
	    case DW_TAG_subprogram:
	      need_base_address = 0;
	      /* Assuming that there is no DW_AT_frame_base.  */
	      have_frame_base = 0;
	      break;
	    }

	  for (attr = entry->first_attr; attr; attr = attr->next)
	    tags = read_and_display_attr (attr->attribute,
					  attr->form,
					  tags, cu_offset,
					  compunit.cu_pointer_size,
					  offset_size,
					  compunit.cu_version,
					  &debug_information [unit],
					  do_loc);
 
 	  if (entry->children)
 	    ++level;
 	}
    }
 
  free_debug_section (&debug_abbrev_section);

  /* Set num_debug_info_entries here so that it can be used to check if
     we need to process .debug_loc and .debug_ranges sections.  */
  if ((do_loc || do_debug_loc || do_debug_ranges)
      && num_debug_info_entries == 0)
    num_debug_info_entries = num_units;
      
  if (!do_loc)
    {
      free_debug_section (&debug_str_section);

      printf ("\n");
    }
 
  return 1;
}

/* Retrieve the pointer size associated with the given compilation unit.
   Optionally the offset of this unit into the .debug_info section is
   also retutned.  If there is no .debug_info section then an error
   message is issued and 0 is returned.  If the requested comp unit has
   not been defined in the .debug_info section then a warning message
   is issued and the last know pointer size is returned.  This message
   is only issued once per section dumped per file dumped.  */

static unsigned int
get_pointer_size_and_offset_of_comp_unit (unsigned int comp_unit,
					  const char * section_name,
					  unsigned long * offset_return)
{
  unsigned long offset = 0;

  if (num_debug_info_entries == 0)
    error (_("%s section needs a populated .debug_info section\n"),
	   section_name);

  else if (comp_unit >= num_debug_info_entries)
    {
      if (!warned_about_missing_comp_units)
	{
	  warn (_("%s section has more comp units than .debug_info section\n"),
		section_name);
	  warn (_("assuming that the pointer size is %d, from the last comp unit in .debug_info\n\n"),
		last_pointer_size);
	  warned_about_missing_comp_units = TRUE;
	}
    }
  else
    {
      last_pointer_size = debug_information [comp_unit].pointer_size;
      offset = debug_information [comp_unit].cu_offset;
    }

  if (offset_return != NULL)
    * offset_return = offset;

  return last_pointer_size;
}

/* Locate and scan the .debug_info section in the file and record the pointer
   sizes and offsets for the compilation units in it.  Usually an executable
   will have just one pointer size, but this is not guaranteed, and so we try
   not to make any assumptions.  Returns zero upon failure, or the number of
   compilation units upon success.  */

static unsigned int
get_debug_info (void * file)
{
  Elf_Internal_Shdr * section;
  struct dwarf_section sec;
  int ret;

  /* Reset the last pointer size so that we can issue correct error
     messages if we are displaying the contents of more than one section.  */
  last_pointer_size = 0;
  warned_about_missing_comp_units = FALSE;

  /* If we already have the information there is nothing else to do.  */
  if (num_debug_info_entries > 0)
    return num_debug_info_entries;

  sec.name = ".debug_info";
  section = find_section (sec.name);
  if (section == NULL)
    return 0;

  sec.start = get_data (NULL, file, section->sh_offset, 1,
			section->sh_size,
			_("extracting information from .debug_info section"));
  if (sec.start == NULL)
    return 0;

  sec.address = section->sh_addr;
  sec.size = section->sh_size;
  ret = (debug_apply_rela_addends (file, section, sec.start)
	 && process_debug_info (&sec, file, 1));

  free (sec.start);

  return ret ? num_debug_info_entries : 0;
}

static int
display_debug_lines (struct dwarf_section *section, void *file)
{
  unsigned char *start = section->start;
  unsigned char *data = start;
  unsigned char *end = start + section->size;
  unsigned int comp_unit = 0;

  printf (_("\nDump of debug contents of section %s:\n\n"),
	  section->name);

  get_debug_info (file);

  while (data < end)
    {
      DWARF2_Internal_LineInfo info;
      unsigned char *standard_opcodes;
      unsigned char *end_of_sequence;
      unsigned char *hdrptr;
      unsigned int pointer_size;
      int initial_length_size;
      int offset_size;
      int i;

      hdrptr = data;

      /* Check the length of the block.  */
      info.li_length = byte_get (hdrptr, 4);
      hdrptr += 4;

      if (info.li_length == 0xffffffff)
	{
	  /* This section is 64-bit DWARF 3.  */
	  info.li_length = byte_get (hdrptr, 8);
	  hdrptr += 8;
	  offset_size = 8;
	  initial_length_size = 12;
	}
      else
	{
	  offset_size = 4;
	  initial_length_size = 4;
	}

      if (info.li_length + initial_length_size > section->size)
	{
	  warn
	    (_("The line info appears to be corrupt - the section is too small\n"));
	  return 0;
	}

      /* Check its version number.  */
      info.li_version = byte_get (hdrptr, 2);
      hdrptr += 2;
      if (info.li_version != 2 && info.li_version != 3)
	{
	  warn (_("Only DWARF version 2 and 3 line info is currently supported.\n"));
	  return 0;
	}

      info.li_prologue_length = byte_get (hdrptr, offset_size);
      hdrptr += offset_size;
      info.li_min_insn_length = byte_get (hdrptr, 1);
      hdrptr++;
      info.li_default_is_stmt = byte_get (hdrptr, 1);
      hdrptr++;
      info.li_line_base = byte_get (hdrptr, 1);
      hdrptr++;
      info.li_line_range = byte_get (hdrptr, 1);
      hdrptr++;
      info.li_opcode_base = byte_get (hdrptr, 1);
      hdrptr++;

      /* Sign extend the line base field.  */
      info.li_line_base <<= 24;
      info.li_line_base >>= 24;

      /* Get the pointer size from the comp unit associated
	 with this block of line number information.  */
      pointer_size = get_pointer_size_and_offset_of_comp_unit
	(comp_unit, ".debug_line", NULL);
      comp_unit ++;

      printf (_("  Length:                      %ld\n"), info.li_length);
      printf (_("  DWARF Version:               %d\n"), info.li_version);
      printf (_("  Prologue Length:             %d\n"), info.li_prologue_length);
      printf (_("  Minimum Instruction Length:  %d\n"), info.li_min_insn_length);
      printf (_("  Initial value of 'is_stmt':  %d\n"), info.li_default_is_stmt);
      printf (_("  Line Base:                   %d\n"), info.li_line_base);
      printf (_("  Line Range:                  %d\n"), info.li_line_range);
      printf (_("  Opcode Base:                 %d\n"), info.li_opcode_base);
      printf (_("  (Pointer size:               %u)%s\n"),
	      pointer_size,
	      warned_about_missing_comp_units ? " [assumed]" : "" );

      end_of_sequence = data + info.li_length + initial_length_size;

      reset_state_machine (info.li_default_is_stmt);

      /* Display the contents of the Opcodes table.  */
      standard_opcodes = hdrptr;

      printf (_("\n Opcodes:\n"));

      for (i = 1; i < info.li_opcode_base; i++)
	printf (_("  Opcode %d has %d args\n"), i, standard_opcodes[i - 1]);

      /* Display the contents of the Directory table.  */
      data = standard_opcodes + info.li_opcode_base - 1;

      if (*data == 0)
	printf (_("\n The Directory Table is empty.\n"));
      else
	{
	  printf (_("\n The Directory Table:\n"));

	  while (*data != 0)
	    {
	      printf (_("  %s\n"), data);

	      data += strlen ((char *) data) + 1;
	    }
	}

      /* Skip the NUL at the end of the table.  */
      data++;

      /* Display the contents of the File Name table.  */
      if (*data == 0)
	printf (_("\n The File Name Table is empty.\n"));
      else
	{
	  printf (_("\n The File Name Table:\n"));
	  printf (_("  Entry\tDir\tTime\tSize\tName\n"));

	  while (*data != 0)
	    {
	      unsigned char *name;
	      unsigned int bytes_read;

	      printf (_("  %d\t"), ++state_machine_regs.last_file_entry);
	      name = data;

	      data += strlen ((char *) data) + 1;

	      printf (_("%lu\t"), read_leb128 (data, & bytes_read, 0));
	      data += bytes_read;
	      printf (_("%lu\t"), read_leb128 (data, & bytes_read, 0));
	      data += bytes_read;
	      printf (_("%lu\t"), read_leb128 (data, & bytes_read, 0));
	      data += bytes_read;
	      printf (_("%s\n"), name);
	    }
	}

      /* Skip the NUL at the end of the table.  */
      data++;

      /* Now display the statements.  */
      printf (_("\n Line Number Statements:\n"));

      while (data < end_of_sequence)
	{
	  unsigned char op_code;
	  int adv;
	  unsigned long int uladv;
	  unsigned int bytes_read;

	  op_code = *data++;

	  if (op_code >= info.li_opcode_base)
	    {
	      op_code -= info.li_opcode_base;
	      uladv = (op_code / info.li_line_range) * info.li_min_insn_length;
	      state_machine_regs.address += uladv;
	      printf (_("  Special opcode %d: advance Address by %lu to 0x%lx"),
		      op_code, uladv, state_machine_regs.address);
	      adv = (op_code % info.li_line_range) + info.li_line_base;
	      state_machine_regs.line += adv;
	      printf (_(" and Line by %d to %d\n"),
		      adv, state_machine_regs.line);
	    }
	  else switch (op_code)
	    {
	    case DW_LNS_extended_op:
	      if (pointer_size == 0)
		{
		  warn (_("Extend line ops need a valid pointer size, guessing at 4\n"));
		  pointer_size = 4;
		}

	      data += process_extended_line_op (data, info.li_default_is_stmt,
						pointer_size);
	      break;

	    case DW_LNS_copy:
	      printf (_("  Copy\n"));
	      break;

	    case DW_LNS_advance_pc:
	      uladv = read_leb128 (data, & bytes_read, 0);
	      uladv *= info.li_min_insn_length;
	      data += bytes_read;
	      state_machine_regs.address += uladv;
	      printf (_("  Advance PC by %lu to 0x%lx\n"), uladv,
		      state_machine_regs.address);
	      break;

	    case DW_LNS_advance_line:
	      adv = read_leb128 (data, & bytes_read, 1);
	      data += bytes_read;
	      state_machine_regs.line += adv;
	      printf (_("  Advance Line by %d to %d\n"), adv,
		      state_machine_regs.line);
	      break;

	    case DW_LNS_set_file:
	      adv = read_leb128 (data, & bytes_read, 0);
	      data += bytes_read;
	      printf (_("  Set File Name to entry %d in the File Name Table\n"),
		      adv);
	      state_machine_regs.file = adv;
	      break;

	    case DW_LNS_set_column:
	      uladv = read_leb128 (data, & bytes_read, 0);
	      data += bytes_read;
	      printf (_("  Set column to %lu\n"), uladv);
	      state_machine_regs.column = uladv;
	      break;

	    case DW_LNS_negate_stmt:
	      adv = state_machine_regs.is_stmt;
	      adv = ! adv;
	      printf (_("  Set is_stmt to %d\n"), adv);
	      state_machine_regs.is_stmt = adv;
	      break;

	    case DW_LNS_set_basic_block:
	      printf (_("  Set basic block\n"));
	      state_machine_regs.basic_block = 1;
	      break;

	    case DW_LNS_const_add_pc:
	      uladv = (((255 - info.li_opcode_base) / info.li_line_range)
		      * info.li_min_insn_length);
	      state_machine_regs.address += uladv;
	      printf (_("  Advance PC by constant %lu to 0x%lx\n"), uladv,
		      state_machine_regs.address);
	      break;

	    case DW_LNS_fixed_advance_pc:
	      uladv = byte_get (data, 2);
	      data += 2;
	      state_machine_regs.address += uladv;
	      printf (_("  Advance PC by fixed size amount %lu to 0x%lx\n"),
		      uladv, state_machine_regs.address);
	      break;

	    case DW_LNS_set_prologue_end:
	      printf (_("  Set prologue_end to true\n"));
	      break;

	    case DW_LNS_set_epilogue_begin:
	      printf (_("  Set epilogue_begin to true\n"));
	      break;

	    case DW_LNS_set_isa:
	      uladv = read_leb128 (data, & bytes_read, 0);
	      data += bytes_read;
	      printf (_("  Set ISA to %lu\n"), uladv);
	      break;

	    default:
	      printf (_("  Unknown opcode %d with operands: "), op_code);

	      for (i = standard_opcodes[op_code - 1]; i > 0 ; --i)
		{
		  printf ("0x%lx%s", read_leb128 (data, &bytes_read, 0),
			  i == 1 ? "" : ", ");
		  data += bytes_read;
		}
	      putchar ('\n');
	      break;
	    }
	}
      putchar ('\n');
    }

  return 1;
}

static int
display_debug_pubnames (struct dwarf_section *section,
			void *file ATTRIBUTE_UNUSED)
{
  DWARF2_Internal_PubNames pubnames;
  unsigned char *start = section->start;
  unsigned char *end = start + section->size;

  printf (_("Contents of the %s section:\n\n"), section->name);

  while (start < end)
    {
      unsigned char *data;
      unsigned long offset;
      int offset_size, initial_length_size;

      data = start;

      pubnames.pn_length = byte_get (data, 4);
      data += 4;
      if (pubnames.pn_length == 0xffffffff)
	{
	  pubnames.pn_length = byte_get (data, 8);
	  data += 8;
	  offset_size = 8;
	  initial_length_size = 12;
	}
      else
	{
	  offset_size = 4;
	  initial_length_size = 4;
	}

      pubnames.pn_version = byte_get (data, 2);
      data += 2;
      pubnames.pn_offset = byte_get (data, offset_size);
      data += offset_size;
      pubnames.pn_size = byte_get (data, offset_size);
      data += offset_size;

      start += pubnames.pn_length + initial_length_size;

      if (pubnames.pn_version != 2 && pubnames.pn_version != 3)
	{
	  static int warned = 0;

	  if (! warned)
	    {
	      warn (_("Only DWARF 2 and 3 pubnames are currently supported\n"));
	      warned = 1;
	    }

	  continue;
	}

      printf (_("  Length:                              %ld\n"),
	      pubnames.pn_length);
      printf (_("  Version:                             %d\n"),
	      pubnames.pn_version);
      printf (_("  Offset into .debug_info section:     %ld\n"),
	      pubnames.pn_offset);
      printf (_("  Size of area in .debug_info section: %ld\n"),
	      pubnames.pn_size);

      printf (_("\n    Offset\tName\n"));

      do
	{
	  offset = byte_get (data, offset_size);

	  if (offset != 0)
	    {
	      data += offset_size;
	      printf ("    %-6ld\t\t%s\n", offset, data);
	      data += strlen ((char *) data) + 1;
	    }
	}
      while (offset != 0);
    }

  printf ("\n");
  return 1;
}

static int
display_debug_macinfo (struct dwarf_section *section,
		       void *file ATTRIBUTE_UNUSED)
{
  unsigned char *start = section->start;
  unsigned char *end = start + section->size;
  unsigned char *curr = start;
  unsigned int bytes_read;
  enum dwarf_macinfo_record_type op;

  printf (_("Contents of the %s section:\n\n"), section->name);

  while (curr < end)
    {
      unsigned int lineno;
      const char *string;

      op = *curr;
      curr++;

      switch (op)
	{
	case DW_MACINFO_start_file:
	  {
	    unsigned int filenum;

	    lineno = read_leb128 (curr, & bytes_read, 0);
	    curr += bytes_read;
	    filenum = read_leb128 (curr, & bytes_read, 0);
	    curr += bytes_read;

	    printf (_(" DW_MACINFO_start_file - lineno: %d filenum: %d\n"),
		    lineno, filenum);
	  }
	  break;

	case DW_MACINFO_end_file:
	  printf (_(" DW_MACINFO_end_file\n"));
	  break;

	case DW_MACINFO_define:
	  lineno = read_leb128 (curr, & bytes_read, 0);
	  curr += bytes_read;
	  string = (char *) curr;
	  curr += strlen (string) + 1;
	  printf (_(" DW_MACINFO_define - lineno : %d macro : %s\n"),
		  lineno, string);
	  break;

	case DW_MACINFO_undef:
	  lineno = read_leb128 (curr, & bytes_read, 0);
	  curr += bytes_read;
	  string = (char *) curr;
	  curr += strlen (string) + 1;
	  printf (_(" DW_MACINFO_undef - lineno : %d macro : %s\n"),
		  lineno, string);
	  break;

	case DW_MACINFO_vendor_ext:
	  {
	    unsigned int constant;

	    constant = read_leb128 (curr, & bytes_read, 0);
	    curr += bytes_read;
	    string = (char *) curr;
	    curr += strlen (string) + 1;
	    printf (_(" DW_MACINFO_vendor_ext - constant : %d string : %s\n"),
		    constant, string);
	  }
	  break;
	}
    }

  return 1;
}


static int
display_debug_abbrev (struct dwarf_section *section,
		      void *file ATTRIBUTE_UNUSED)
{
  abbrev_entry *entry;
  unsigned char *start = section->start;
  unsigned char *end = start + section->size;

  printf (_("Contents of the %s section:\n\n"), section->name);

  do
    {
      start = process_abbrev_section (start, end);

      if (first_abbrev == NULL)
	continue;

      printf (_("  Number TAG\n"));

      for (entry = first_abbrev; entry; entry = entry->next)
	{
	  abbrev_attr *attr;

	  printf (_("   %ld      %s    [%s]\n"),
		  entry->entry,
		  get_TAG_name (entry->tag),
		  entry->children ? _("has children") : _("no children"));

	  for (attr = entry->first_attr; attr; attr = attr->next)
	    printf (_("    %-18s %s\n"),
		    get_AT_name (attr->attribute),
		    get_FORM_name (attr->form));
	}

      free_abbrevs ();
    }
  while (start);

  printf ("\n");

  return 1;
}

static int
display_debug_loc (struct dwarf_section *section, void *file)
{
  unsigned char *start = section->start;
  unsigned char *section_end;
  unsigned long bytes;
  unsigned char *section_begin = start;
  unsigned int num_loc_list = 0;
  unsigned long last_offset = 0;
  unsigned int first = 0;
  unsigned int i;
  unsigned int j;
  int seen_first_offset = 0;
  int use_debug_info = 1;
  unsigned char *next;

  bytes = section->size;
  section_end = start + bytes;

  if (bytes == 0)
    {
      printf (_("\nThe %s section is empty.\n"), section->name);
      return 0;
    }

  get_debug_info (file);

  /* Check the order of location list in .debug_info section. If
     offsets of location lists are in the ascending order, we can
     use `debug_information' directly.  */
  for (i = 0; i < num_debug_info_entries; i++)
    {
      unsigned int num;

      num = debug_information [i].num_loc_offsets;
      num_loc_list += num;

      /* Check if we can use `debug_information' directly.  */
      if (use_debug_info && num != 0)
	{
	  if (!seen_first_offset)
	    {
	      /* This is the first location list.  */
	      last_offset = debug_information [i].loc_offsets [0];
	      first = i;
	      seen_first_offset = 1;
	      j = 1;
	    }
	  else
	    j = 0;

	  for (; j < num; j++)
	    {
	      if (last_offset >
		  debug_information [i].loc_offsets [j])
		{
		  use_debug_info = 0;
		  break;
		}
	      last_offset = debug_information [i].loc_offsets [j];
	    }
	}
    }

  if (!use_debug_info)
    /* FIXME: Should we handle this case?  */
    error (_("Location lists in .debug_info section aren't in ascending order!\n"));

  if (!seen_first_offset)
    error (_("No location lists in .debug_info section!\n"));

  if (debug_information [first].loc_offsets [0] != 0)
    warn (_("Location lists in %s section start at 0x%lx\n"),
	  section->name, debug_information [first].loc_offsets [0]);

  printf (_("Contents of the %s section:\n\n"), section->name);
  printf (_("    Offset   Begin    End      Expression\n"));

  seen_first_offset = 0;
  for (i = first; i < num_debug_info_entries; i++)
    {
      unsigned long begin;
      unsigned long end;
      unsigned short length;
      unsigned long offset;
      unsigned int pointer_size;
      unsigned long cu_offset;
      unsigned long base_address;
      int need_frame_base;
      int has_frame_base;

      pointer_size = debug_information [i].pointer_size;
      cu_offset = debug_information [i].cu_offset;

      for (j = 0; j < debug_information [i].num_loc_offsets; j++)
	{
	  has_frame_base = debug_information [i].have_frame_base [j];
	  offset = debug_information [i].loc_offsets [j];
	  next = section_begin + offset;
	  base_address = debug_information [i].base_address;

	  if (!seen_first_offset)
	    seen_first_offset = 1;
	  else
	    {
	      if (start < next)
		warn (_("There is a hole [0x%lx - 0x%lx] in .debug_loc section.\n"),
		      (long)(start - section_begin), (long)(next - section_begin));
	      else if (start > next)
		warn (_("There is an overlap [0x%lx - 0x%lx] in .debug_loc section.\n"),
		      (long)(start - section_begin), (long)(next - section_begin));
	    }
	  start = next;

	  if (offset >= bytes)
	    {
	      warn (_("Offset 0x%lx is bigger than .debug_loc section size.\n"),
		    offset);
	      continue;
	    }

	  while (1)
	    {
	      if (start + 2 * pointer_size > section_end)
		{
		  warn (_("Location list starting at offset 0x%lx is not terminated.\n"),
			offset);
		  break;
		}

	      begin = byte_get (start, pointer_size);
	      start += pointer_size;
	      end = byte_get (start, pointer_size);
	      start += pointer_size;

	      if (begin == 0 && end == 0)
		{
		  printf (_("    %8.8lx <End of list>\n"), offset);
		  break;
		}

	      /* Check base address specifiers.  */
	      if (begin == -1UL && end != -1UL)
		{
		  base_address = end;
		  printf (_("    %8.8lx %8.8lx %8.8lx (base address)\n"),
			  offset, begin, end);
		  continue;
		}

	      if (start + 2 > section_end)
		{
		  warn (_("Location list starting at offset 0x%lx is not terminated.\n"),
			offset);
		  break;
		}

	      length = byte_get (start, 2);
	      start += 2;

	      if (start + length > section_end)
		{
		  warn (_("Location list starting at offset 0x%lx is not terminated.\n"),
			offset);
		  break;
		}

	      printf ("    %8.8lx %8.8lx %8.8lx (",
		      offset, begin + base_address, end + base_address);
	      need_frame_base = decode_location_expression (start,
							    pointer_size,
							    length,
							    cu_offset);
	      putchar (')');

	      if (need_frame_base && !has_frame_base)
		printf (_(" [without DW_AT_frame_base]"));

	      if (begin == end)
		fputs (_(" (start == end)"), stdout);
	      else if (begin > end)
		fputs (_(" (start > end)"), stdout);

	      putchar ('\n');

	      start += length;
	    }
	}
    }
  return 1;
}

static int
display_debug_str (struct dwarf_section *section,
		   void *file ATTRIBUTE_UNUSED)
{
  unsigned char *start = section->start;
  unsigned long bytes = section->size;
  bfd_vma addr = section->address;

  if (bytes == 0)
    {
      printf (_("\nThe %s section is empty.\n"), section->name);
      return 0;
    }

  printf (_("Contents of the %s section:\n\n"), section->name);

  while (bytes)
    {
      int j;
      int k;
      int lbytes;

      lbytes = (bytes > 16 ? 16 : bytes);

      printf ("  0x%8.8lx ", (unsigned long) addr);

      for (j = 0; j < 16; j++)
	{
	  if (j < lbytes)
	    printf ("%2.2x", start[j]);
	  else
	    printf ("  ");

	  if ((j & 3) == 3)
	    printf (" ");
	}

      for (j = 0; j < lbytes; j++)
	{
	  k = start[j];
	  if (k >= ' ' && k < 0x80)
	    printf ("%c", k);
	  else
	    printf (".");
	}

      putchar ('\n');

      start += lbytes;
      addr  += lbytes;
      bytes -= lbytes;
    }

  putchar ('\n');

  return 1;
}


static int
display_debug_info (struct dwarf_section *section, void *file)
{
  return process_debug_info (section, file, 0);
}


static int
display_debug_aranges (struct dwarf_section *section,
		       void *file ATTRIBUTE_UNUSED)
{
  unsigned char *start = section->start;
  unsigned char *end = start + section->size;

  printf (_("The section %s contains:\n\n"), section->name);

  while (start < end)
    {
      unsigned char *hdrptr;
      DWARF2_Internal_ARange arange;
      unsigned char *ranges;
      unsigned long length;
      unsigned long address;
      int excess;
      int offset_size;
      int initial_length_size;

      hdrptr = start;

      arange.ar_length = byte_get (hdrptr, 4);
      hdrptr += 4;

      if (arange.ar_length == 0xffffffff)
	{
	  arange.ar_length = byte_get (hdrptr, 8);
	  hdrptr += 8;
	  offset_size = 8;
	  initial_length_size = 12;
	}
      else
	{
	  offset_size = 4;
	  initial_length_size = 4;
	}

      arange.ar_version = byte_get (hdrptr, 2);
      hdrptr += 2;

      arange.ar_info_offset = byte_get (hdrptr, offset_size);
      hdrptr += offset_size;

      arange.ar_pointer_size = byte_get (hdrptr, 1);
      hdrptr += 1;

      arange.ar_segment_size = byte_get (hdrptr, 1);
      hdrptr += 1;

      if (arange.ar_version != 2 && arange.ar_version != 3)
	{
	  warn (_("Only DWARF 2 and 3 aranges are currently supported.\n"));
	  break;
	}

      printf (_("  Length:                   %ld\n"), arange.ar_length);
      printf (_("  Version:                  %d\n"), arange.ar_version);
      printf (_("  Offset into .debug_info:  %lx\n"), arange.ar_info_offset);
      printf (_("  Pointer Size:             %d\n"), arange.ar_pointer_size);
      printf (_("  Segment Size:             %d\n"), arange.ar_segment_size);

      printf (_("\n    Address  Length\n"));

      ranges = hdrptr;

      /* Must pad to an alignment boundary that is twice the pointer size.  */
      excess = (hdrptr - start) % (2 * arange.ar_pointer_size);
      if (excess)
	ranges += (2 * arange.ar_pointer_size) - excess;

      for (;;)
	{
	  address = byte_get (ranges, arange.ar_pointer_size);

	  ranges += arange.ar_pointer_size;

	  length  = byte_get (ranges, arange.ar_pointer_size);

	  ranges += arange.ar_pointer_size;

	  /* A pair of zeros marks the end of the list.  */
	  if (address == 0 && length == 0)
	    break;

	  printf ("    %8.8lx %lu\n", address, length);
	}

      start += arange.ar_length + initial_length_size;
    }

  printf ("\n");

  return 1;
}

static int
display_debug_ranges (struct dwarf_section *section,
		      void *file ATTRIBUTE_UNUSED)
{
  unsigned char *start = section->start;
  unsigned char *section_end;
  unsigned long bytes;
  unsigned char *section_begin = start;
  unsigned int num_range_list = 0;
  unsigned long last_offset = 0;
  unsigned int first = 0;
  unsigned int i;
  unsigned int j;
  int seen_first_offset = 0;
  int use_debug_info = 1;
  unsigned char *next;

  bytes = section->size;
  section_end = start + bytes;

  if (bytes == 0)
    {
      printf (_("\nThe %s section is empty.\n"), section->name);
      return 0;
    }

  get_debug_info (file);

  /* Check the order of range list in .debug_info section. If
     offsets of range lists are in the ascending order, we can
     use `debug_information' directly.  */
  for (i = 0; i < num_debug_info_entries; i++)
    {
      unsigned int num;

      num = debug_information [i].num_range_lists;
      num_range_list += num;

      /* Check if we can use `debug_information' directly.  */
      if (use_debug_info && num != 0)
	{
	  if (!seen_first_offset)
	    {
	      /* This is the first range list.  */
	      last_offset = debug_information [i].range_lists [0];
	      first = i;
	      seen_first_offset = 1;
	      j = 1;
	    }
	  else
	    j = 0;

	  for (; j < num; j++)
	    {
	      if (last_offset >
		  debug_information [i].range_lists [j])
		{
		  use_debug_info = 0;
		  break;
		}
	      last_offset = debug_information [i].range_lists [j];
	    }
	}
    }

  if (!use_debug_info)
    /* FIXME: Should we handle this case?  */
    error (_("Range lists in .debug_info section aren't in ascending order!\n"));

  if (!seen_first_offset)
    error (_("No range lists in .debug_info section!\n"));

  if (debug_information [first].range_lists [0] != 0)
    warn (_("Range lists in %s section start at 0x%lx\n"),
	  section->name, debug_information [first].range_lists [0]);

  printf (_("Contents of the %s section:\n\n"), section->name);
  printf (_("    Offset   Begin    End\n"));

  seen_first_offset = 0;
  for (i = first; i < num_debug_info_entries; i++)
    {
      unsigned long begin;
      unsigned long end;
      unsigned long offset;
      unsigned int pointer_size;
      unsigned long base_address;

      pointer_size = debug_information [i].pointer_size;

      for (j = 0; j < debug_information [i].num_range_lists; j++)
	{
	  offset = debug_information [i].range_lists [j];
	  next = section_begin + offset;
	  base_address = debug_information [i].base_address;

	  if (!seen_first_offset)
	    seen_first_offset = 1;
	  else
	    {
	      if (start < next)
		warn (_("There is a hole [0x%lx - 0x%lx] in %s section.\n"),
		      (long)(start - section_begin),
		      (long)(next - section_begin), section->name);
	      else if (start > next)
		warn (_("There is an overlap [0x%lx - 0x%lx] in %s section.\n"),
		      (long)(start - section_begin),
		      (long)(next - section_begin), section->name);
	    }
	  start = next;

	  while (1)
	    {
	      begin = byte_get (start, pointer_size);
	      start += pointer_size;
	      end = byte_get (start, pointer_size);
	      start += pointer_size;

	      if (begin == 0 && end == 0)
		{
		  printf (_("    %8.8lx <End of list>\n"), offset);
		  break;
		}

	      /* Check base address specifiers.  */
	      if (begin == -1UL && end != -1UL)
		{
		  base_address = end;
		  printf ("    %8.8lx %8.8lx %8.8lx (base address)\n",
			  offset, begin, end);
		  continue;
		}

	      printf ("    %8.8lx %8.8lx %8.8lx",
		      offset, begin + base_address, end + base_address);

	      if (begin == end)
		fputs (_(" (start == end)"), stdout);
	      else if (begin > end)
		fputs (_(" (start > end)"), stdout);

	      putchar ('\n');
	    }
	}
    }
  putchar ('\n');
  return 1;
}

typedef struct Frame_Chunk
{
  struct Frame_Chunk *next;
  unsigned char *chunk_start;
  int ncols;
  /* DW_CFA_{undefined,same_value,offset,register,unreferenced}  */
  short int *col_type;
  int *col_offset;
  char *augmentation;
  unsigned int code_factor;
  int data_factor;
  unsigned long pc_begin;
  unsigned long pc_range;
  int cfa_reg;
  int cfa_offset;
  int ra;
  unsigned char fde_encoding;
  unsigned char cfa_exp;
}
Frame_Chunk;

/* A marker for a col_type that means this column was never referenced
   in the frame info.  */
#define DW_CFA_unreferenced (-1)

static void
frame_need_space (Frame_Chunk *fc, int reg)
{
  int prev = fc->ncols;

  if (reg < fc->ncols)
    return;

  fc->ncols = reg + 1;
  fc->col_type = xcrealloc (fc->col_type, fc->ncols, sizeof (short int));
  fc->col_offset = xcrealloc (fc->col_offset, fc->ncols, sizeof (int));

  while (prev < fc->ncols)
    {
      fc->col_type[prev] = DW_CFA_unreferenced;
      fc->col_offset[prev] = 0;
      prev++;
    }
}

static void
frame_display_row (Frame_Chunk *fc, int *need_col_headers, int *max_regs)
{
  int r;
  char tmp[100];

  if (*max_regs < fc->ncols)
    *max_regs = fc->ncols;

  if (*need_col_headers)
    {
      *need_col_headers = 0;

      printf ("   LOC   CFA      ");

      for (r = 0; r < *max_regs; r++)
	if (fc->col_type[r] != DW_CFA_unreferenced)
	  {
	    if (r == fc->ra)
	      printf ("ra   ");
	    else
	      printf ("r%-4d", r);
	  }

      printf ("\n");
    }

  printf ("%08lx ", fc->pc_begin);
  if (fc->cfa_exp)
    strcpy (tmp, "exp");
  else
    sprintf (tmp, "r%d%+d", fc->cfa_reg, fc->cfa_offset);
  printf ("%-8s ", tmp);

  for (r = 0; r < fc->ncols; r++)
    {
      if (fc->col_type[r] != DW_CFA_unreferenced)
	{
	  switch (fc->col_type[r])
	    {
	    case DW_CFA_undefined:
	      strcpy (tmp, "u");
	      break;
	    case DW_CFA_same_value:
	      strcpy (tmp, "s");
	      break;
	    case DW_CFA_offset:
	      sprintf (tmp, "c%+d", fc->col_offset[r]);
	      break;
	    case DW_CFA_register:
	      sprintf (tmp, "r%d", fc->col_offset[r]);
	      break;
	    case DW_CFA_expression:
	      strcpy (tmp, "exp");
	      break;
	    default:
	      strcpy (tmp, "n/a");
	      break;
	    }
	  printf ("%-5s", tmp);
	}
    }
  printf ("\n");
}

static int
size_of_encoded_value (int encoding)
{
  switch (encoding & 0x7)
    {
    default:	/* ??? */
    case 0:	return eh_addr_size;
    case 2:	return 2;
    case 3:	return 4;
    case 4:	return 8;
    }
}

static bfd_vma
get_encoded_value (unsigned char *data, int encoding)
{
  int size = size_of_encoded_value (encoding);
  if (encoding & DW_EH_PE_signed)
    return byte_get_signed (data, size);
  else
    return byte_get (data, size);
}

#define GET(N)	byte_get (start, N); start += N
#define LEB()	read_leb128 (start, & length_return, 0); start += length_return
#define SLEB()	read_leb128 (start, & length_return, 1); start += length_return

static int
display_debug_frames (struct dwarf_section *section,
		      void *file ATTRIBUTE_UNUSED)
{
  unsigned char *start = section->start;
  unsigned char *end = start + section->size;
  unsigned char *section_start = start;
  Frame_Chunk *chunks = 0;
  Frame_Chunk *remembered_state = 0;
  Frame_Chunk *rs;
  int is_eh = streq (section->name, ".eh_frame");
  unsigned int length_return;
  int max_regs = 0;

  printf (_("The section %s contains:\n"), section->name);

  while (start < end)
    {
      unsigned char *saved_start;
      unsigned char *block_end;
      unsigned long length;
      unsigned long cie_id;
      Frame_Chunk *fc;
      Frame_Chunk *cie;
      int need_col_headers = 1;
      unsigned char *augmentation_data = NULL;
      unsigned long augmentation_data_len = 0;
      int encoded_ptr_size = eh_addr_size;
      int offset_size;
      int initial_length_size;

      saved_start = start;
      length = byte_get (start, 4); start += 4;

      if (length == 0)
	{
	  printf ("\n%08lx ZERO terminator\n\n",
		    (unsigned long)(saved_start - section_start));
	  return 1;
	}

      if (length == 0xffffffff)
	{
	  length = byte_get (start, 8);
	  start += 8;
	  offset_size = 8;
	  initial_length_size = 12;
	}
      else
	{
	  offset_size = 4;
	  initial_length_size = 4;
	}

      block_end = saved_start + length + initial_length_size;
      cie_id = byte_get (start, offset_size); start += offset_size;

      if (is_eh ? (cie_id == 0) : (cie_id == DW_CIE_ID))
	{
	  int version;

	  fc = xmalloc (sizeof (Frame_Chunk));
	  memset (fc, 0, sizeof (Frame_Chunk));

	  fc->next = chunks;
	  chunks = fc;
	  fc->chunk_start = saved_start;
	  fc->ncols = 0;
	  fc->col_type = xmalloc (sizeof (short int));
	  fc->col_offset = xmalloc (sizeof (int));
	  frame_need_space (fc, max_regs-1);

	  version = *start++;

	  fc->augmentation = (char *) start;
	  start = (unsigned char *) strchr ((char *) start, '\0') + 1;

	  if (fc->augmentation[0] == 'z')
	    {
	      fc->code_factor = LEB ();
	      fc->data_factor = SLEB ();
	      if (version == 1)
		{
		  fc->ra = GET (1);
		}
	      else
		{
		  fc->ra = LEB ();
		}
	      augmentation_data_len = LEB ();
	      augmentation_data = start;
	      start += augmentation_data_len;
	    }
	  else if (streq (fc->augmentation, "eh"))
	    {
	      start += eh_addr_size;
	      fc->code_factor = LEB ();
	      fc->data_factor = SLEB ();
	      if (version == 1)
		{
		  fc->ra = GET (1);
		}
	      else
		{
		  fc->ra = LEB ();
		}
	    }
	  else
	    {
	      fc->code_factor = LEB ();
	      fc->data_factor = SLEB ();
	      if (version == 1)
		{
		  fc->ra = GET (1);
		}
	      else
		{
		  fc->ra = LEB ();
		}
	    }
	  cie = fc;

	  if (do_debug_frames_interp)
	    printf ("\n%08lx %08lx %08lx CIE \"%s\" cf=%d df=%d ra=%d\n",
		    (unsigned long)(saved_start - section_start), length, cie_id,
		    fc->augmentation, fc->code_factor, fc->data_factor,
		    fc->ra);
	  else
	    {
	      printf ("\n%08lx %08lx %08lx CIE\n",
		      (unsigned long)(saved_start - section_start), length, cie_id);
	      printf ("  Version:               %d\n", version);
	      printf ("  Augmentation:          \"%s\"\n", fc->augmentation);
	      printf ("  Code alignment factor: %u\n", fc->code_factor);
	      printf ("  Data alignment factor: %d\n", fc->data_factor);
	      printf ("  Return address column: %d\n", fc->ra);

	      if (augmentation_data_len)
		{
		  unsigned long i;
		  printf ("  Augmentation data:    ");
		  for (i = 0; i < augmentation_data_len; ++i)
		    printf (" %02x", augmentation_data[i]);
		  putchar ('\n');
		}
	      putchar ('\n');
	    }

	  if (augmentation_data_len)
	    {
	      unsigned char *p, *q;
	      p = (unsigned char *) fc->augmentation + 1;
	      q = augmentation_data;

	      while (1)
		{
		  if (*p == 'L')
		    q++;
		  else if (*p == 'P')
		    q += 1 + size_of_encoded_value (*q);
		  else if (*p == 'R')
		    fc->fde_encoding = *q++;
		  else
		    break;
		  p++;
		}

	      if (fc->fde_encoding)
		encoded_ptr_size = size_of_encoded_value (fc->fde_encoding);
	    }

	  frame_need_space (fc, fc->ra);
	}
      else
	{
	  unsigned char *look_for;
	  static Frame_Chunk fde_fc;

	  fc = & fde_fc;
	  memset (fc, 0, sizeof (Frame_Chunk));

	  look_for = is_eh ? start - 4 - cie_id : section_start + cie_id;

	  for (cie = chunks; cie ; cie = cie->next)
	    if (cie->chunk_start == look_for)
	      break;

	  if (!cie)
	    {
	      warn ("Invalid CIE pointer %08lx in FDE at %p\n",
		    cie_id, saved_start);
	      start = block_end;
	      fc->ncols = 0;
	      fc->col_type = xmalloc (sizeof (short int));
	      fc->col_offset = xmalloc (sizeof (int));
	      frame_need_space (fc, max_regs - 1);
	      cie = fc;
	      fc->augmentation = "";
	      fc->fde_encoding = 0;
	    }
	  else
	    {
	      fc->ncols = cie->ncols;
	      fc->col_type = xcmalloc (fc->ncols, sizeof (short int));
	      fc->col_offset = xcmalloc (fc->ncols, sizeof (int));
	      memcpy (fc->col_type, cie->col_type, fc->ncols * sizeof (short int));
	      memcpy (fc->col_offset, cie->col_offset, fc->ncols * sizeof (int));
	      fc->augmentation = cie->augmentation;
	      fc->code_factor = cie->code_factor;
	      fc->data_factor = cie->data_factor;
	      fc->cfa_reg = cie->cfa_reg;
	      fc->cfa_offset = cie->cfa_offset;
	      fc->ra = cie->ra;
	      frame_need_space (fc, max_regs-1);
	      fc->fde_encoding = cie->fde_encoding;
	    }

	  if (fc->fde_encoding)
	    encoded_ptr_size = size_of_encoded_value (fc->fde_encoding);

	  fc->pc_begin = get_encoded_value (start, fc->fde_encoding);
	  if ((fc->fde_encoding & 0x70) == DW_EH_PE_pcrel
	      /* Don't adjust for relocatable file since there's
		 invariably a pcrel reloc here, which we haven't
		 applied.  */
	      && !is_relocatable)
	    fc->pc_begin += section->address + (start - section_start);
	  start += encoded_ptr_size;
	  fc->pc_range = byte_get (start, encoded_ptr_size);
	  start += encoded_ptr_size;

	  if (cie->augmentation[0] == 'z')
	    {
	      augmentation_data_len = LEB ();
	      augmentation_data = start;
	      start += augmentation_data_len;
	    }

	  printf ("\n%08lx %08lx %08lx FDE cie=%08lx pc=%08lx..%08lx\n",
		  (unsigned long)(saved_start - section_start), length, cie_id,
		  (unsigned long)(cie->chunk_start - section_start),
		  fc->pc_begin, fc->pc_begin + fc->pc_range);
	  if (! do_debug_frames_interp && augmentation_data_len)
	    {
	      unsigned long i;

	      printf ("  Augmentation data:    ");
	      for (i = 0; i < augmentation_data_len; ++i)
		printf (" %02x", augmentation_data[i]);
	      putchar ('\n');
	      putchar ('\n');
	    }
	}

      /* At this point, fc is the current chunk, cie (if any) is set, and
	 we're about to interpret instructions for the chunk.  */
      /* ??? At present we need to do this always, since this sizes the
	 fc->col_type and fc->col_offset arrays, which we write into always.
	 We should probably split the interpreted and non-interpreted bits
	 into two different routines, since there's so much that doesn't
	 really overlap between them.  */
      if (1 || do_debug_frames_interp)
	{
	  /* Start by making a pass over the chunk, allocating storage
	     and taking note of what registers are used.  */
	  unsigned char *tmp = start;

	  while (start < block_end)
	    {
	      unsigned op, opa;
	      unsigned long reg, tmp;

	      op = *start++;
	      opa = op & 0x3f;
	      if (op & 0xc0)
		op &= 0xc0;

	      /* Warning: if you add any more cases to this switch, be
		 sure to add them to the corresponding switch below.  */
	      switch (op)
		{
		case DW_CFA_advance_loc:
		  break;
		case DW_CFA_offset:
		  LEB ();
		  frame_need_space (fc, opa);
		  fc->col_type[opa] = DW_CFA_undefined;
		  break;
		case DW_CFA_restore:
		  frame_need_space (fc, opa);
		  fc->col_type[opa] = DW_CFA_undefined;
		  break;
		case DW_CFA_set_loc:
		  start += encoded_ptr_size;
		  break;
		case DW_CFA_advance_loc1:
		  start += 1;
		  break;
		case DW_CFA_advance_loc2:
		  start += 2;
		  break;
		case DW_CFA_advance_loc4:
		  start += 4;
		  break;
		case DW_CFA_offset_extended:
		  reg = LEB (); LEB ();
		  frame_need_space (fc, reg);
		  fc->col_type[reg] = DW_CFA_undefined;
		  break;
		case DW_CFA_restore_extended:
		  reg = LEB ();
		  frame_need_space (fc, reg);
		  fc->col_type[reg] = DW_CFA_undefined;
		  break;
		case DW_CFA_undefined:
		  reg = LEB ();
		  frame_need_space (fc, reg);
		  fc->col_type[reg] = DW_CFA_undefined;
		  break;
		case DW_CFA_same_value:
		  reg = LEB ();
		  frame_need_space (fc, reg);
		  fc->col_type[reg] = DW_CFA_undefined;
		  break;
		case DW_CFA_register:
		  reg = LEB (); LEB ();
		  frame_need_space (fc, reg);
		  fc->col_type[reg] = DW_CFA_undefined;
		  break;
		case DW_CFA_def_cfa:
		  LEB (); LEB ();
		  break;
		case DW_CFA_def_cfa_register:
		  LEB ();
		  break;
		case DW_CFA_def_cfa_offset:
		  LEB ();
		  break;
		case DW_CFA_def_cfa_expression:
		  tmp = LEB ();
		  start += tmp;
		  break;
		case DW_CFA_expression:
		  reg = LEB ();
		  tmp = LEB ();
		  start += tmp;
		  frame_need_space (fc, reg);
		  fc->col_type[reg] = DW_CFA_undefined;
		  break;
		case DW_CFA_offset_extended_sf:
		  reg = LEB (); SLEB ();
		  frame_need_space (fc, reg);
		  fc->col_type[reg] = DW_CFA_undefined;
		  break;
		case DW_CFA_def_cfa_sf:
		  LEB (); SLEB ();
		  break;
		case DW_CFA_def_cfa_offset_sf:
		  SLEB ();
		  break;
		case DW_CFA_MIPS_advance_loc8:
		  start += 8;
		  break;
		case DW_CFA_GNU_args_size:
		  LEB ();
		  break;
		case DW_CFA_GNU_negative_offset_extended:
		  reg = LEB (); LEB ();
		  frame_need_space (fc, reg);
		  fc->col_type[reg] = DW_CFA_undefined;

		default:
		  break;
		}
	    }
	  start = tmp;
	}

      /* Now we know what registers are used, make a second pass over
	 the chunk, this time actually printing out the info.  */

      while (start < block_end)
	{
	  unsigned op, opa;
	  unsigned long ul, reg, roffs;
	  long l, ofs;
	  bfd_vma vma;

	  op = *start++;
	  opa = op & 0x3f;
	  if (op & 0xc0)
	    op &= 0xc0;

	  /* Warning: if you add any more cases to this switch, be
	     sure to add them to the corresponding switch above.  */
	  switch (op)
	    {
	    case DW_CFA_advance_loc:
	      if (do_debug_frames_interp)
		frame_display_row (fc, &need_col_headers, &max_regs);
	      else
		printf ("  DW_CFA_advance_loc: %d to %08lx\n",
			opa * fc->code_factor,
			fc->pc_begin + opa * fc->code_factor);
	      fc->pc_begin += opa * fc->code_factor;
	      break;

	    case DW_CFA_offset:
	      roffs = LEB ();
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_offset: r%d at cfa%+ld\n",
			opa, roffs * fc->data_factor);
	      fc->col_type[opa] = DW_CFA_offset;
	      fc->col_offset[opa] = roffs * fc->data_factor;
	      break;

	    case DW_CFA_restore:
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_restore: r%d\n", opa);
	      fc->col_type[opa] = cie->col_type[opa];
	      fc->col_offset[opa] = cie->col_offset[opa];
	      break;

	    case DW_CFA_set_loc:
	      vma = get_encoded_value (start, fc->fde_encoding);
	      if ((fc->fde_encoding & 0x70) == DW_EH_PE_pcrel
		  && !is_relocatable)
		vma += section->address + (start - section_start);
	      start += encoded_ptr_size;
	      if (do_debug_frames_interp)
		frame_display_row (fc, &need_col_headers, &max_regs);
	      else
		printf ("  DW_CFA_set_loc: %08lx\n", (unsigned long)vma);
	      fc->pc_begin = vma;
	      break;

	    case DW_CFA_advance_loc1:
	      ofs = byte_get (start, 1); start += 1;
	      if (do_debug_frames_interp)
		frame_display_row (fc, &need_col_headers, &max_regs);
	      else
		printf ("  DW_CFA_advance_loc1: %ld to %08lx\n",
			ofs * fc->code_factor,
			fc->pc_begin + ofs * fc->code_factor);
	      fc->pc_begin += ofs * fc->code_factor;
	      break;

	    case DW_CFA_advance_loc2:
	      ofs = byte_get (start, 2); start += 2;
	      if (do_debug_frames_interp)
		frame_display_row (fc, &need_col_headers, &max_regs);
	      else
		printf ("  DW_CFA_advance_loc2: %ld to %08lx\n",
			ofs * fc->code_factor,
			fc->pc_begin + ofs * fc->code_factor);
	      fc->pc_begin += ofs * fc->code_factor;
	      break;

	    case DW_CFA_advance_loc4:
	      ofs = byte_get (start, 4); start += 4;
	      if (do_debug_frames_interp)
		frame_display_row (fc, &need_col_headers, &max_regs);
	      else
		printf ("  DW_CFA_advance_loc4: %ld to %08lx\n",
			ofs * fc->code_factor,
			fc->pc_begin + ofs * fc->code_factor);
	      fc->pc_begin += ofs * fc->code_factor;
	      break;

	    case DW_CFA_offset_extended:
	      reg = LEB ();
	      roffs = LEB ();
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_offset_extended: r%ld at cfa%+ld\n",
			reg, roffs * fc->data_factor);
	      fc->col_type[reg] = DW_CFA_offset;
	      fc->col_offset[reg] = roffs * fc->data_factor;
	      break;

	    case DW_CFA_restore_extended:
	      reg = LEB ();
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_restore_extended: r%ld\n", reg);
	      fc->col_type[reg] = cie->col_type[reg];
	      fc->col_offset[reg] = cie->col_offset[reg];
	      break;

	    case DW_CFA_undefined:
	      reg = LEB ();
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_undefined: r%ld\n", reg);
	      fc->col_type[reg] = DW_CFA_undefined;
	      fc->col_offset[reg] = 0;
	      break;

	    case DW_CFA_same_value:
	      reg = LEB ();
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_same_value: r%ld\n", reg);
	      fc->col_type[reg] = DW_CFA_same_value;
	      fc->col_offset[reg] = 0;
	      break;

	    case DW_CFA_register:
	      reg = LEB ();
	      roffs = LEB ();
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_register: r%ld in r%ld\n", reg, roffs);
	      fc->col_type[reg] = DW_CFA_register;
	      fc->col_offset[reg] = roffs;
	      break;

	    case DW_CFA_remember_state:
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_remember_state\n");
	      rs = xmalloc (sizeof (Frame_Chunk));
	      rs->ncols = fc->ncols;
	      rs->col_type = xcmalloc (rs->ncols, sizeof (short int));
	      rs->col_offset = xcmalloc (rs->ncols, sizeof (int));
	      memcpy (rs->col_type, fc->col_type, rs->ncols);
	      memcpy (rs->col_offset, fc->col_offset, rs->ncols * sizeof (int));
	      rs->next = remembered_state;
	      remembered_state = rs;
	      break;

	    case DW_CFA_restore_state:
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_restore_state\n");
	      rs = remembered_state;
	      if (rs)
		{
		  remembered_state = rs->next;
		  frame_need_space (fc, rs->ncols-1);
		  memcpy (fc->col_type, rs->col_type, rs->ncols);
		  memcpy (fc->col_offset, rs->col_offset,
			  rs->ncols * sizeof (int));
		  free (rs->col_type);
		  free (rs->col_offset);
		  free (rs);
		}
	      else if (do_debug_frames_interp)
		printf ("Mismatched DW_CFA_restore_state\n");
	      break;

	    case DW_CFA_def_cfa:
	      fc->cfa_reg = LEB ();
	      fc->cfa_offset = LEB ();
	      fc->cfa_exp = 0;
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_def_cfa: r%d ofs %d\n",
			fc->cfa_reg, fc->cfa_offset);
	      break;

	    case DW_CFA_def_cfa_register:
	      fc->cfa_reg = LEB ();
	      fc->cfa_exp = 0;
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_def_cfa_reg: r%d\n", fc->cfa_reg);
	      break;

	    case DW_CFA_def_cfa_offset:
	      fc->cfa_offset = LEB ();
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_def_cfa_offset: %d\n", fc->cfa_offset);
	      break;

	    case DW_CFA_nop:
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_nop\n");
	      break;

	    case DW_CFA_def_cfa_expression:
	      ul = LEB ();
	      if (! do_debug_frames_interp)
		{
		  printf ("  DW_CFA_def_cfa_expression (");
		  decode_location_expression (start, eh_addr_size, ul, 0);
		  printf (")\n");
		}
	      fc->cfa_exp = 1;
	      start += ul;
	      break;

	    case DW_CFA_expression:
	      reg = LEB ();
	      ul = LEB ();
	      if (! do_debug_frames_interp)
		{
		  printf ("  DW_CFA_expression: r%ld (", reg);
		  decode_location_expression (start, eh_addr_size, ul, 0);
		  printf (")\n");
		}
	      fc->col_type[reg] = DW_CFA_expression;
	      start += ul;
	      break;

	    case DW_CFA_offset_extended_sf:
	      reg = LEB ();
	      l = SLEB ();
	      frame_need_space (fc, reg);
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_offset_extended_sf: r%ld at cfa%+ld\n",
			reg, l * fc->data_factor);
	      fc->col_type[reg] = DW_CFA_offset;
	      fc->col_offset[reg] = l * fc->data_factor;
	      break;

	    case DW_CFA_def_cfa_sf:
	      fc->cfa_reg = LEB ();
	      fc->cfa_offset = SLEB ();
	      fc->cfa_offset = fc->cfa_offset * fc->data_factor;
	      fc->cfa_exp = 0;
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_def_cfa_sf: r%d ofs %d\n",
			fc->cfa_reg, fc->cfa_offset);
	      break;

	    case DW_CFA_def_cfa_offset_sf:
	      fc->cfa_offset = SLEB ();
	      fc->cfa_offset = fc->cfa_offset * fc->data_factor;
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_def_cfa_offset_sf: %d\n", fc->cfa_offset);
	      break;

	    case DW_CFA_MIPS_advance_loc8:
	      ofs = byte_get (start, 8); start += 8;
	      if (do_debug_frames_interp)
		frame_display_row (fc, &need_col_headers, &max_regs);
	      else
		printf ("  DW_CFA_MIPS_advance_loc8: %ld to %08lx\n",
			ofs * fc->code_factor,
			fc->pc_begin + ofs * fc->code_factor);
	      fc->pc_begin += ofs * fc->code_factor;
	      break;

	    case DW_CFA_GNU_window_save:
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_GNU_window_save\n");
	      break;

	    case DW_CFA_GNU_args_size:
	      ul = LEB ();
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_GNU_args_size: %ld\n", ul);
	      break;

	    case DW_CFA_GNU_negative_offset_extended:
	      reg = LEB ();
	      l = - LEB ();
	      frame_need_space (fc, reg);
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_GNU_negative_offset_extended: r%ld at cfa%+ld\n",
			reg, l * fc->data_factor);
	      fc->col_type[reg] = DW_CFA_offset;
	      fc->col_offset[reg] = l * fc->data_factor;
	      break;

	    default:
	      warn (_("unsupported or unknown DW_CFA_%d\n"), op);
	      start = block_end;
	    }
	}

      if (do_debug_frames_interp)
	frame_display_row (fc, &need_col_headers, &max_regs);

      start = block_end;
    }

  printf ("\n");

  return 1;
}

#undef GET
#undef LEB
#undef SLEB

static int
display_debug_not_supported (struct dwarf_section *section,
			     void *file ATTRIBUTE_UNUSED)
{
  printf (_("Displaying the debug contents of section %s is not yet supported.\n"),
	    section->name);

  return 1;
}

/* A structure containing the name of a debug section
   and a pointer to a function that can decode it.  */
static struct
{
  const char *const name;
  int (*display) (struct dwarf_section *, void *);
  unsigned int relocate : 1;
}
debug_displays[] =
{
  { ".debug_abbrev",		display_debug_abbrev,		0 },
  { ".debug_aranges",		display_debug_aranges,		0 },
  { ".debug_frame",		display_debug_frames,		1 },
  { ".debug_info",		display_debug_info,		1 },
  { ".debug_line",		display_debug_lines,		0 },
  { ".debug_pubnames",		display_debug_pubnames,		0 },
  { ".eh_frame",		display_debug_frames,		1 },
  { ".debug_macinfo",		display_debug_macinfo,		0 },
  { ".debug_str",		display_debug_str,		0 },
  { ".debug_loc",		display_debug_loc,		0 },
  { ".debug_pubtypes",		display_debug_pubnames,		0 },
  { ".debug_ranges",		display_debug_ranges,		0 },
  { ".debug_static_func",	display_debug_not_supported,	0 },
  { ".debug_static_vars",	display_debug_not_supported,	0 },
  { ".debug_types",		display_debug_not_supported,	0 },
  { ".debug_weaknames",		display_debug_not_supported,	0 }
};

static int
display_debug_section (Elf_Internal_Shdr *section, FILE *file)
{
  char *name = SECTION_NAME (section);
  bfd_size_type length;
  int result = 1;
  int i;

  length = section->sh_size;
  if (length == 0)
    {
      printf (_("\nSection '%s' has no debugging data.\n"), name);
      return 0;
    }

  if (strneq (name, ".gnu.linkonce.wi.", 17))
    name = ".debug_info";

  /* See if we know how to display the contents of this section.  */
  for (i = NUM_ELEM (debug_displays); i--;)
    if (streq (debug_displays[i].name, name))
      {
	struct dwarf_section sec;

	sec.name = name;
	sec.address = section->sh_addr;
	sec.size = section->sh_size;
	sec.start = get_data (NULL, file, section->sh_offset, 1,
			      length, _("debug section data"));
	if (sec.start == NULL)
	  {
	    result = 0;
	    break;
	  }

	if (!debug_displays[i].relocate
	    || debug_apply_rela_addends (file, section, sec.start))
	  result &= debug_displays[i].display (&sec, file);

	free (sec.start);

	/* If we loaded in the abbrev section
	   at some point, we must release it here.  */
	free_abbrevs ();

	break;
      }

  if (i == -1)
    {
      printf (_("Unrecognized debug section: %s\n"), name);
      result = 0;
    }

  return result;
}

static void
process_section_contents (FILE *file)
{
  Elf_Internal_Shdr *section;
  unsigned int i;

  if (! do_dump)
    return;

  for (i = 0, section = section_headers;
       i < elf_header.e_shnum && i < num_dump_sects;
       i++, section++)
    {
#ifdef SUPPORT_DISASSEMBLY
      if (dump_sects[i] & DISASS_DUMP)
	disassemble_section (section, file);
#endif
      if (dump_sects[i] & HEX_DUMP)
	dump_section (section, file);

      if (dump_sects[i] & DEBUG_DUMP)
	display_debug_section (section, file);
    }

  /* Check to see if the user requested a
     dump of a section that does not exist.  */
  while (i++ < num_dump_sects)
    if (dump_sects[i])
      warn (_("Section %d was not dumped because it does not exist!\n"), i);
}

static void
process_mips_fpe_exception (int mask)
{
  if (mask)
    {
      int first = 1;
      if (mask & OEX_FPU_INEX)
	fputs ("INEX", stdout), first = 0;
      if (mask & OEX_FPU_UFLO)
	printf ("%sUFLO", first ? "" : "|"), first = 0;
      if (mask & OEX_FPU_OFLO)
	printf ("%sOFLO", first ? "" : "|"), first = 0;
      if (mask & OEX_FPU_DIV0)
	printf ("%sDIV0", first ? "" : "|"), first = 0;
      if (mask & OEX_FPU_INVAL)
	printf ("%sINVAL", first ? "" : "|");
    }
  else
    fputs ("0", stdout);
}

static int
process_mips_specific (FILE *file)
{
  Elf_Internal_Dyn *entry;
  size_t liblist_offset = 0;
  size_t liblistno = 0;
  size_t conflictsno = 0;
  size_t options_offset = 0;
  size_t conflicts_offset = 0;

  /* We have a lot of special sections.  Thanks SGI!  */
  if (dynamic_section == NULL)
    /* No information available.  */
    return 0;

  for (entry = dynamic_section; entry->d_tag != DT_NULL; ++entry)
    switch (entry->d_tag)
      {
      case DT_MIPS_LIBLIST:
d8563 1
a8563 16
  if (debug_information)
    {
      for (i = 0; i < num_debug_info_entries; i++)
	{
	  if (!debug_information [i].max_loc_offsets)
	    {
	      free (debug_information [i].loc_offsets);
	      free (debug_information [i].have_frame_base);
	    }
	  if (!debug_information [i].max_range_lists)
	    free (debug_information [i].range_lists);
	}
      free (debug_information);
      debug_information = NULL;
      num_debug_info_entries = 0;
    }
@


1.317
log
@2005-09-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (debug_apply_rela_addends): Relocate the whole
	section.
	(process_debug_info): Don't call debug_apply_rela_addends.
	(display_debug_frames): Likewise.
	(get_debug_info): Call debug_apply_rela_addends.
	(debug_displays): Add the "relocate" field.
	(display_debug_section): Call debug_apply_rela_addends if
	needed.
@
text
@d174 1
a366 62
static bfd_vma
byte_get_little_endian (unsigned char *field, int size)
{
  switch (size)
    {
    case 1:
      return *field;

    case 2:
      return  ((unsigned int) (field[0]))
	|    (((unsigned int) (field[1])) << 8);

#ifndef BFD64
    case 8:
      /* We want to extract data from an 8 byte wide field and
	 place it into a 4 byte wide field.  Since this is a little
	 endian source we can just use the 4 byte extraction code.  */
      /* Fall through.  */
#endif
    case 4:
      return  ((unsigned long) (field[0]))
	|    (((unsigned long) (field[1])) << 8)
	|    (((unsigned long) (field[2])) << 16)
	|    (((unsigned long) (field[3])) << 24);

#ifdef BFD64
    case 8:
      return  ((bfd_vma) (field[0]))
	|    (((bfd_vma) (field[1])) << 8)
	|    (((bfd_vma) (field[2])) << 16)
	|    (((bfd_vma) (field[3])) << 24)
	|    (((bfd_vma) (field[4])) << 32)
	|    (((bfd_vma) (field[5])) << 40)
	|    (((bfd_vma) (field[6])) << 48)
	|    (((bfd_vma) (field[7])) << 56);
#endif
    default:
      error (_("Unhandled data length: %d\n"), size);
      abort ();
    }
}

static bfd_vma
byte_get_signed (unsigned char *field, int size)
{
  bfd_vma x = byte_get (field, size);

  switch (size)
    {
    case 1:
      return (x ^ 0x80) - 0x80;
    case 2:
      return (x ^ 0x8000) - 0x8000;
    case 4:
      return (x ^ 0x80000000) - 0x80000000;
    case 8:
      return x;
    default:
      abort ();
    }
}

a555 42
static bfd_vma
byte_get_big_endian (unsigned char *field, int size)
{
  switch (size)
    {
    case 1:
      return *field;

    case 2:
      return ((unsigned int) (field[1])) | (((int) (field[0])) << 8);

#ifndef BFD64
    case 8:
      /* Although we are extracing data from an 8 byte wide field,
	 we are returning only 4 bytes of data.  */
      field += 4;
      /* Fall thru */
#endif
    case 4:
      return ((unsigned long) (field[3]))
	|   (((unsigned long) (field[2])) << 8)
	|   (((unsigned long) (field[1])) << 16)
	|   (((unsigned long) (field[0])) << 24);

#ifdef BFD64
    case 8:
      return ((bfd_vma) (field[7]))
	|   (((bfd_vma) (field[6])) << 8)
	|   (((bfd_vma) (field[5])) << 16)
	|   (((bfd_vma) (field[4])) << 24)
	|   (((bfd_vma) (field[3])) << 32)
	|   (((bfd_vma) (field[2])) << 40)
	|   (((bfd_vma) (field[1])) << 48)
	|   (((bfd_vma) (field[0])) << 56);
#endif

    default:
      error (_("Unhandled data length: %d\n"), size);
      abort ();
    }
}

d7367 1
a7367 2
static unsigned long int
read_leb128 (unsigned char *data, unsigned int *length_return, int sign)
d7369 5
a7373 4
  unsigned long int result = 0;
  unsigned int num_read = 0;
  unsigned int shift = 0;
  unsigned char byte;
d7375 1
a7375 4
  do
    {
      byte = *data++;
      num_read++;
d7377 5
a7381 1
      result |= ((unsigned long int) (byte & 0x7f)) << shift;
d7383 3
a7385 1
      shift += 7;
d7387 4
a7390 2
    }
  while (byte & 0x80);
d7392 5
a7396 7
  if (length_return != NULL)
    *length_return = num_read;

  if (sign && (shift < 8 * sizeof (result)) && (byte & 0x40))
    result |= -1L << shift;

  return result;
d7399 2
a7400 1
typedef struct State_Machine_Registers
d7402 2
a7403 13
  unsigned long address;
  unsigned int file;
  unsigned int line;
  unsigned int column;
  int is_stmt;
  int basic_block;
  int end_sequence;
/* This variable hold the number of the last entry seen
   in the File Table.  */
  unsigned int last_file_entry;
} SMR;

static SMR state_machine_regs;
d7405 4
a7408 11
static void
reset_state_machine (int is_stmt)
{
  state_machine_regs.address = 0;
  state_machine_regs.file = 1;
  state_machine_regs.line = 1;
  state_machine_regs.column = 0;
  state_machine_regs.is_stmt = is_stmt;
  state_machine_regs.basic_block = 0;
  state_machine_regs.end_sequence = 0;
  state_machine_regs.last_file_entry = 0;
d7411 1
a7411 2
/* Handled an extend line op.
   Returns the number of bytes read.  */
d7414 3
a7416 1
process_extended_line_op (unsigned char *data, int is_stmt, int pointer_size)
d7418 4
a7421 5
  unsigned char op_code;
  unsigned int bytes_read;
  unsigned int len;
  unsigned char *name;
  unsigned long adr;
d7423 2
a7424 2
  len = read_leb128 (data, & bytes_read, 0);
  data += bytes_read;
d7426 2
a7427 5
  if (len == 0)
    {
      warn (_("badly formed extended line op encountered!\n"));
      return bytes_read;
    }
d7429 3
a7431 6
  len += bytes_read;
  op_code = *data++;

  printf (_("  Extended opcode %d: "), op_code);

  switch (op_code)
d7433 5
a7437 4
    case DW_LNE_end_sequence:
      printf (_("End of Sequence\n\n"));
      reset_state_machine (is_stmt);
      break;
d7439 6
a7444 5
    case DW_LNE_set_address:
      adr = byte_get (data, pointer_size);
      printf (_("set Address to 0x%lx\n"), adr);
      state_machine_regs.address = adr;
      break;
d7446 3
a7448 3
    case DW_LNE_define_file:
      printf (_("  define new File Table entry\n"));
      printf (_("  Entry\tDir\tTime\tSize\tName\n"));
d7450 2
a7451 10
      printf (_("   %d\t"), ++state_machine_regs.last_file_entry);
      name = data;
      data += strlen ((char *) data) + 1;
      printf (_("%lu\t"), read_leb128 (data, & bytes_read, 0));
      data += bytes_read;
      printf (_("%lu\t"), read_leb128 (data, & bytes_read, 0));
      data += bytes_read;
      printf (_("%lu\t"), read_leb128 (data, & bytes_read, 0));
      printf (_("%s\n\n"), name);
      break;
d7453 3
a7455 4
    default:
      printf (_("UNKNOWN: length %d\n"), len - bytes_read);
      break;
    }
d7457 8
a7464 2
  return len;
}
d7466 3
a7468 2
static const char *debug_str_contents;
static bfd_vma debug_str_size;
d7470 26
a7495 4
static void
load_debug_str (FILE *file)
{
  Elf_Internal_Shdr *sec;
d7497 1
a7497 3
  /* If it is already loaded, do nothing.  */
  if (debug_str_contents != NULL)
    return;
d7499 10
a7508 4
  /* Locate the .debug_str section.  */
  sec = find_section (".debug_str");
  if (sec == NULL)
    return;
d7510 2
a7511 1
  debug_str_size = sec->sh_size;
d7513 5
a7517 2
  debug_str_contents = get_data (NULL, file, sec->sh_offset, 1, sec->sh_size,
				 _("debug_str section data"));
d7520 2
a7521 2
static void
free_debug_str (void)
d7523 21
a7543 2
  if (debug_str_contents == NULL)
    return;
d7545 15
a7559 3
  free ((char *) debug_str_contents);
  debug_str_contents = NULL;
  debug_str_size = 0;
d7562 2
a7563 2
static const char *
fetch_indirect_string (unsigned long offset)
d7565 1
a7565 2
  if (debug_str_contents == NULL)
    return _("<no .debug_str section>");
d7567 1
a7567 1
  if (offset > debug_str_size)
d7569 10
a7578 2
      warn (_("DW_FORM_strp offset too big: %lx\n"), offset);
      return _("<offset is too big>");
a7579 2

  return debug_str_contents + offset;
d7582 2
a7583 5
static const char *debug_loc_contents;
static bfd_vma debug_loc_size;

static void
load_debug_loc (FILE *file)
d7585 4
a7588 1
  Elf_Internal_Shdr *sec;
d7590 2
a7591 3
  /* If it is already loaded, do nothing.  */
  if (debug_loc_contents != NULL)
    return;
d7593 12
a7604 4
  /* Locate the .debug_loc section.  */
  sec = find_section (".debug_loc");
  if (sec == NULL)
    return;
d7606 11
a7616 1
  debug_loc_size = sec->sh_size;
d7618 4
a7621 2
  debug_loc_contents = get_data (NULL, file, sec->sh_offset, 1, sec->sh_size,
				 _("debug_loc section data"));
d7624 2
a7625 2
static void
free_debug_loc (void)
d7627 4
a7630 2
  if (debug_loc_contents == NULL)
    return;
d7632 4
a7635 4
  free ((char *) debug_loc_contents);
  debug_loc_contents = NULL;
  debug_loc_size = 0;
}
d7637 1
a7637 2
static const char *   debug_range_contents;
static unsigned long  debug_range_size;
d7639 1
a7639 4
static void
load_debug_range (FILE *file)
{
  Elf_Internal_Shdr *sec;
d7641 2
a7642 3
  /* If it is already loaded, do nothing.  */
  if (debug_range_contents != NULL)
    return;
d7644 2
a7645 4
  /* Locate the .debug_ranges section.  */
  sec = find_section (".debug_ranges");
  if (sec == NULL)
    return;
d7647 2
a7648 1
  debug_range_size = sec->sh_size;
d7650 1
a7650 2
  debug_range_contents = get_data (NULL, file, sec->sh_offset, 1, sec->sh_size,
				   _("debug_range section data"));
d7653 1
a7653 2
static void
free_debug_range (void)
d7655 11
a7665 2
  if (debug_range_contents == NULL)
    return;
d7667 1
a7667 7
  free ((char *) debug_range_contents);
  debug_range_contents = NULL;
  debug_range_size = 0;
}

static unsigned char *debug_abbrev_contents;
static unsigned long debug_abbrev_size;
d7670 1
a7670 1
load_debug_abbrev (FILE *file)
d7672 8
a7679 16
  Elf_Internal_Shdr *sec;

  /* If it is already loaded, do nothing.  */
  if (debug_abbrev_contents != NULL)
    return;

  /* Locate the .debug_ranges section.  */
  sec = find_section (".debug_abbrev");
  if (sec == NULL)
    return;

  debug_abbrev_size = sec->sh_size;

  debug_abbrev_contents = get_data (NULL, file, sec->sh_offset, 1,
				    sec->sh_size,
				    _("debug_abbrev section data"));
d7682 2
a7683 12
static void
free_debug_abbrev (void)
{
  if (debug_abbrev_contents == NULL)
    return;

  free ((char *) debug_abbrev_contents);
  debug_abbrev_contents = NULL;
  debug_abbrev_size = 0;
}

/* Apply addends of RELA relocations.  */
d7686 1
a7686 3
debug_apply_rela_addends (FILE *file,
			  Elf_Internal_Shdr *section,
			  unsigned char *start)
d7688 5
a7692 4
  Elf_Internal_Shdr *relsec;
  unsigned char *end = start + section->sh_size;
  /* FIXME: The relocation field size is relocation type dependent.  */
  unsigned int reloc_size = 4;
d7694 2
a7695 2
  if (elf_header.e_type != ET_REL)
    return 1;
d7697 1
a7697 6
  if (section->sh_size < reloc_size)
    return 1;

  for (relsec = section_headers;
       relsec < section_headers + elf_header.e_shnum;
       ++relsec)
d7699 3
a7701 5
      unsigned long nrelas;
      Elf_Internal_Rela *rela, *rp;
      Elf_Internal_Shdr *symsec;
      Elf_Internal_Sym *symtab;
      Elf_Internal_Sym *sym;
d7703 2
a7704 6
      if (relsec->sh_type != SHT_RELA
	  || SECTION_HEADER_INDEX (relsec->sh_info) >= elf_header.e_shnum
	  || SECTION_HEADER (relsec->sh_info) != section
	  || relsec->sh_size == 0
	  || SECTION_HEADER_INDEX (relsec->sh_link) >= elf_header.e_shnum)
	continue;
d7706 1
a7706 3
      if (!slurp_rela_relocs (file, relsec->sh_offset, relsec->sh_size,
			      &rela, &nrelas))
	return 0;
d7708 6
a7713 2
      symsec = SECTION_HEADER (relsec->sh_link);
      symtab = GET_ELF_SYMBOLS (file, symsec);
d7715 5
a7719 3
      for (rp = rela; rp < rela + nrelas; ++rp)
	{
	  unsigned char *loc;
d7721 3
a7723 8
	  loc = start + rp->r_offset;
	  if ((loc + reloc_size) > end)
	    {
	      warn (_("skipping invalid relocation offset 0x%lx in section %s\n"),
		    (unsigned long) rp->r_offset,
		    SECTION_NAME (section));
	      continue;
	    }
d7725 10
a7734 3
	  if (is_32bit_elf)
	    {
	      sym = symtab + ELF32_R_SYM (rp->r_info);
d7736 4
a7739 26
	      if (ELF32_R_SYM (rp->r_info) != 0
		  && ELF32_ST_TYPE (sym->st_info) != STT_SECTION
		  /* Relocations against object symbols can happen,
		     eg when referencing a global array.  For an
		     example of this see the _clz.o binary in libgcc.a.  */
		  && ELF32_ST_TYPE (sym->st_info) != STT_OBJECT)
		{
		  warn (_("skipping unexpected symbol type %s in relocation in section .rela%s\n"),
			get_symbol_type (ELF32_ST_TYPE (sym->st_info)),
			SECTION_NAME (section));
		  continue;
		}
	    }
	  else
	    {
	      /* In MIPS little-endian objects, r_info isn't really a
		 64-bit little-endian value: it has a 32-bit little-endian
		 symbol index followed by four individual byte fields.
		 Reorder INFO accordingly.  */
	      if (elf_header.e_machine == EM_MIPS
		  && elf_header.e_ident[EI_DATA] != ELFDATA2MSB)
		rp->r_info = (((rp->r_info & 0xffffffff) << 32)
			      | ((rp->r_info >> 56) & 0xff)
			      | ((rp->r_info >> 40) & 0xff00)
			      | ((rp->r_info >> 24) & 0xff0000)
			      | ((rp->r_info >> 8) & 0xff000000));
d7741 2
a7742 1
	      sym = symtab + ELF64_R_SYM (rp->r_info);
d7744 6
a7749 10
	      if (ELF64_R_SYM (rp->r_info) != 0
		  && ELF64_ST_TYPE (sym->st_info) != STT_SECTION
		  && ELF64_ST_TYPE (sym->st_info) != STT_OBJECT)
		{
		  warn (_("skipping unexpected symbol type %s in relocation in section .rela.%s\n"),
			get_symbol_type (ELF64_ST_TYPE (sym->st_info)),
			SECTION_NAME (section));
		  continue;
		}
	    }
d7751 5
a7755 2
	  byte_put (loc, rp->r_addend, reloc_size);
	}
d7757 4
a7760 3
      free (symtab);
      free (rela);
      break;
d7762 2
a7763 1
  return 1;
d7766 7
d9005 2
a9006 2
process_debug_info (Elf_Internal_Shdr *section, unsigned char *start,
		    FILE *file, int do_loc)
d9008 2
a9009 1
  unsigned char *end = start + section->sh_size;
d9039 1
a9039 1
	  error (_("No comp units in .debug_info section ?"));
d9056 1
a9056 2
      printf (_("The section %s contains:\n\n"),
	      SECTION_NAME (section));
d9058 1
a9058 3
      load_debug_str (file);
      load_debug_loc (file);
      load_debug_range (file);
d9061 2
a9062 2
  load_debug_abbrev (file);
  if (debug_abbrev_contents == NULL)
d9064 2
a9065 1
      warn (_("Unable to locate .debug_abbrev section!\n"));
d9147 4
a9150 2
	(debug_abbrev_contents + compunit.cu_abbrev_offset,
	 debug_abbrev_contents + debug_abbrev_size);
d9224 1
a9224 1
  free_debug_abbrev ();
d9234 1
a9234 3
      free_debug_range ();
      free_debug_str ();
      free_debug_loc (); 
d9291 1
a9291 1
get_debug_info (FILE * file)
d9294 2
a9295 2
  unsigned char *     start;
  int		      ret;
d9306 2
a9307 1
  section = find_section (".debug_info");
d9311 4
a9314 3
  start = get_data (NULL, file, section->sh_offset, 1, section->sh_size,
		    _("extracting information from .debug_info section"));
  if (start == NULL)
d9317 4
a9320 2
  ret = (debug_apply_rela_addends (file, section, start)
	 && process_debug_info (section, start, file, 1));
d9322 1
a9322 1
  free (start);
d9328 1
a9328 2
display_debug_lines (Elf_Internal_Shdr *section,
		     unsigned char *start, FILE *file)
d9330 1
d9332 1
a9332 1
  unsigned char *end = start + section->sh_size;
d9336 1
a9336 1
	  SECTION_NAME (section));
d9371 1
a9371 1
      if (info.li_length + initial_length_size > section->sh_size)
d9620 2
a9621 3
display_debug_pubnames (Elf_Internal_Shdr *section,
			unsigned char *start,
			FILE *file ATTRIBUTE_UNUSED)
d9624 2
a9625 3
  unsigned char *end;

  end = start + section->sh_size;
d9627 1
a9627 1
  printf (_("Contents of the %s section:\n\n"), SECTION_NAME (section));
d9704 2
a9705 3
display_debug_macinfo (Elf_Internal_Shdr *section,
		       unsigned char *start,
		       FILE *file ATTRIBUTE_UNUSED)
d9707 2
a9708 1
  unsigned char *end = start + section->sh_size;
d9713 1
a9713 1
  printf (_("Contents of the %s section:\n\n"), SECTION_NAME (section));
d9781 2
a9782 3
display_debug_abbrev (Elf_Internal_Shdr *section,
		      unsigned char *start,
		      FILE *file ATTRIBUTE_UNUSED)
d9785 2
a9786 1
  unsigned char *end = start + section->sh_size;
d9788 1
a9788 1
  printf (_("Contents of the %s section:\n\n"), SECTION_NAME (section));
d9824 1
a9824 2
display_debug_loc (Elf_Internal_Shdr *section,
		   unsigned char *start, FILE *file)
d9826 1
d9839 1
a9839 1
  bytes = section->sh_size;
d9844 1
a9844 1
      printf (_("\nThe .debug_loc section is empty.\n"));
d9895 2
a9896 2
    warn (_("Location lists in .debug_loc section start at 0x%lx\n"),
	  debug_information [first].loc_offsets [0]);
d9898 1
a9898 1
  printf (_("Contents of the .debug_loc section:\n\n"));
d10016 2
a10017 3
display_debug_str (Elf_Internal_Shdr *section,
		   unsigned char *start,
		   FILE *file ATTRIBUTE_UNUSED)
d10019 3
a10021 5
  unsigned long bytes;
  bfd_vma addr;

  addr  = section->sh_addr;
  bytes = section->sh_size;
d10025 1
a10025 1
      printf (_("\nThe .debug_str section is empty.\n"));
d10029 1
a10029 1
  printf (_("Contents of the .debug_str section:\n\n"));
d10075 1
a10075 2
display_debug_info (Elf_Internal_Shdr * section,
		    unsigned char * start, FILE * file)
d10077 1
a10077 1
  return process_debug_info (section, start, file, 0);
d10082 2
a10083 3
display_debug_aranges (Elf_Internal_Shdr *section,
		       unsigned char *start,
		       FILE *file ATTRIBUTE_UNUSED)
d10085 2
a10086 1
  unsigned char *end = start + section->sh_size;
d10088 1
a10088 1
  printf (_("The section %s contains:\n\n"), SECTION_NAME (section));
d10178 2
a10179 3
display_debug_ranges (Elf_Internal_Shdr *section,
		      unsigned char *start,
		      FILE *file ATTRIBUTE_UNUSED)
d10181 1
d10194 1
a10194 1
  bytes = section->sh_size;
d10199 1
a10199 1
      printf (_("\nThe .debug_ranges section is empty.\n"));
d10250 2
a10251 2
    warn (_("Range lists in .debug_ranges section start at 0x%lx\n"),
	  debug_information [first].range_lists [0]);
d10253 1
a10253 1
  printf (_("Contents of the .debug_ranges section:\n\n"));
d10278 3
a10280 2
		warn (_("There is a hole [0x%lx - 0x%lx] in .debug_ranges section.\n"),
		      (long)(start - section_begin), (long)(next - section_begin));
d10282 3
a10284 2
		warn (_("There is an overlap [0x%lx - 0x%lx] in .debug_ranges section.\n"),
		      (long)(start - section_begin), (long)(next - section_begin));
d10464 2
a10465 3
display_debug_frames (Elf_Internal_Shdr *section,
		      unsigned char *start,
		      FILE *file ATTRIBUTE_UNUSED)
d10467 2
a10468 1
  unsigned char *end = start + section->sh_size;
d10473 1
a10473 1
  int is_eh = streq (SECTION_NAME (section), ".eh_frame");
d10477 1
a10477 1
  printf (_("The section %s contains:\n"), SECTION_NAME (section));
d10685 5
a10689 4
	      /* Don't adjust for ET_REL since there's invariably a pcrel
		 reloc here, which we haven't applied.  */
	      && elf_header.e_type != ET_REL)
	    fc->pc_begin += section->sh_addr + (start - section_start);
d10889 2
a10890 2
		  && elf_header.e_type != ET_REL)
		vma += section->sh_addr + (start - section_start);
d11142 2
a11143 3
display_debug_not_supported (Elf_Internal_Shdr *section,
			     unsigned char *start ATTRIBUTE_UNUSED,
			     FILE *file ATTRIBUTE_UNUSED)
d11146 1
a11146 1
	    SECTION_NAME (section));
d11156 1
a11156 1
  int (*display) (Elf_Internal_Shdr *, unsigned char *, FILE *);
d11201 1
a11201 1
	unsigned char *start;
d11203 6
a11208 3
	start = get_data (NULL, file, section->sh_offset, 1, length,
			  _("debug section data"));
	if (start == NULL)
d11215 2
a11216 2
	    || debug_apply_rela_addends (file, section, start))
	  result &= debug_displays[i].display (section, start, file);
d11218 1
a11218 1
	free (start);
d12157 2
@


1.316
log
@        * readelf.c (display_debug_lines): Use unsigned long for address
        increments.  Use 0x prefix for all hex numbers.
@
text
@d7747 1
a7747 4
			  int reloc_size,
			  unsigned char *sec_data,
			  unsigned char *start,
			  unsigned char *end)
d7750 6
d7757 1
a7757 1
  if (end - start < reloc_size)
d7788 8
a7795 5
	  if (rp->r_offset >= (bfd_vma) (start - sec_data)
	      && rp->r_offset < (bfd_vma) (end - sec_data) - reloc_size)
	    loc = sec_data + rp->r_offset;
	  else
	    continue;
a9182 5
      if (elf_header.e_type == ET_REL
	  && !debug_apply_rela_addends (file, section, offset_size,
					section_begin, hdrptr, start))
	return 0;

d9394 3
a9396 1
  ret = process_debug_info (section, start, file, 1);
a10598 5
      if (elf_header.e_type == ET_REL
	  && !debug_apply_rela_addends (file, section, offset_size,
					section_start, start, block_end))
	return 0;

d11236 1
d11240 16
a11255 16
  { ".debug_abbrev",		display_debug_abbrev },
  { ".debug_aranges",		display_debug_aranges },
  { ".debug_frame",		display_debug_frames },
  { ".debug_info",		display_debug_info },
  { ".debug_line",		display_debug_lines },
  { ".debug_pubnames",		display_debug_pubnames },
  { ".eh_frame",		display_debug_frames },
  { ".debug_macinfo",		display_debug_macinfo },
  { ".debug_str",		display_debug_str },
  { ".debug_loc",		display_debug_loc },
  { ".debug_pubtypes",		display_debug_pubnames },
  { ".debug_ranges",		display_debug_ranges },
  { ".debug_static_func",	display_debug_not_supported },
  { ".debug_static_vars",	display_debug_not_supported },
  { ".debug_types",		display_debug_not_supported },
  { ".debug_weaknames",		display_debug_not_supported }
d11290 4
a11293 1
	result &= debug_displays[i].display (section, start, file);
@


1.315
log
@	* readelf.c (get_arm_section_type_name): Add SHT_ARM_PREEMPTMAP and
	SHT_ARM_ATTRIBUTES.
@
text
@d9564 1
d9572 4
a9575 4
	      adv      = (op_code / info.li_line_range) * info.li_min_insn_length;
	      state_machine_regs.address += adv;
	      printf (_("  Special opcode %d: advance Address by %d to 0x%lx"),
		      op_code, adv, state_machine_regs.address);
d9599 2
a9600 1
	      adv = info.li_min_insn_length * read_leb128 (data, & bytes_read, 0);
d9602 2
a9603 2
	      state_machine_regs.address += adv;
	      printf (_("  Advance PC by %d to %lx\n"), adv,
d9624 1
a9624 1
	      adv = read_leb128 (data, & bytes_read, 0);
d9626 2
a9627 2
	      printf (_("  Set column to %d\n"), adv);
	      state_machine_regs.column = adv;
d9643 4
a9646 4
	      adv = (((255 - info.li_opcode_base) / info.li_line_range)
		     * info.li_min_insn_length);
	      state_machine_regs.address += adv;
	      printf (_("  Advance PC by constant %d to 0x%lx\n"), adv,
d9651 1
a9651 1
	      adv = byte_get (data, 2);
d9653 3
a9655 3
	      state_machine_regs.address += adv;
	      printf (_("  Advance PC by fixed size amount %d to 0x%lx\n"),
		      adv, state_machine_regs.address);
d9667 1
a9667 1
	      adv = read_leb128 (data, & bytes_read, 0);
d9669 1
a9669 1
	      printf (_("  Set ISA to %d\n"), adv);
@


1.314
log
@2005-09-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (get_elf_section_flags): Handle 64bit sh_flags.
@
text
@d2625 4
@


1.313
log
@2005-09-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (debug_abbrev_contents): New.
	(debug_abbrev_size): Likewise.
	(load_debug_abbrev): Likewise.
	(free_debug_abbrev): Likewise.
	(process_debug_info): Use them.
@
text
@d3797 5
a3801 1
  int index, size = sizeof (buff) - (8 + 4 + 1);
d3823 3
a3825 2
      sprintf (buff, "[%8.8lx]: ", (unsigned long) sh_flags);
      p += 8 + 4;
d3855 1
a3855 1
	  if (p != buff + 8 + 4)
d3857 8
a3864 6
	      if (size < 10 + 2)
		abort ();
	      size -= 2;
	      *p++ = ',';
	      *p++ = ' ';
	    }
a3865 2
	  if (index != -1)
	    {
d3870 1
a3870 5
	    {
	      size -= 5 + 8;
	      sprintf (p, "OS (%8.8lx)", (unsigned long) flag);
	      p += 5 + 8;
	    }
d3872 1
a3872 5
	    {
	      size -= 7 + 8;
	      sprintf (p, "PROC (%8.8lx)", (unsigned long) flag);
	      p += 7 + 8;
	    }
d3874 1
a3874 5
	    {
	      size -= 10 + 8;
	      sprintf (p, "UNKNOWN (%8.8lx)", (unsigned long) flag);
	      p += 10 + 8;
	    }
d3913 49
@


1.312
log
@	* readelf.c (slurp_hppa_unwind_table): Fix entry size on hppa64-hpux.
	Don't access table entries past the end of the table.
@
text
@d7661 35
d9089 7
d9177 4
a9180 23
      /* Read in the abbrevs used by this compilation unit.  */
      {
	Elf_Internal_Shdr *sec;
	unsigned char *begin;

	/* Locate the .debug_abbrev section and process it.  */
	sec = find_section (".debug_abbrev");
	if (sec == NULL)
	  {
	    warn (_("Unable to locate .debug_abbrev section!\n"));
	    return 0;
	  }

	begin = get_data (NULL, file, sec->sh_offset, 1, sec->sh_size,
			  _("debug_abbrev section data"));
	if (!begin)
	  return 0;

	process_abbrev_section (begin + compunit.cu_abbrev_offset,
				begin + sec->sh_size);

	free (begin);
      }
d9254 2
@


1.311
log
@	* readelf.c (get_parisc_segment_type): Handle PT_PARISC_WEAKORDER.
	(get_parisc_section_type_name): Handle SHT_PARISC_DLKM.
@
text
@d5201 1
a5201 1
  unsigned long size, unw_ent_size, nrelas, i;
d5241 3
a5243 1
  unw_ent_size = 2 * eh_addr_size + 8;
d5245 1
a5245 1
  tep = aux->table = xcmalloc (size / unw_ent_size, sizeof (aux->table[0]));
d5247 1
a5247 1
  for (tp = table; tp < table + size; tp += (2 * eh_addr_size + 8), ++tep)
d5254 7
a5260 14
      if (is_32bit_elf)
	{
	  tep->start.offset = byte_get ((unsigned char *) tp + 0, 4);
	  tep->end.offset = byte_get ((unsigned char *) tp + 4, 4);
	  tmp1 = byte_get ((unsigned char *) tp + 8, 4);
	  tmp2 = byte_get ((unsigned char *) tp + 12, 4);
	}
      else
	{
	  tep->start.offset = BYTE_GET ((unsigned char *) tp + 0);
	  tep->end.offset = BYTE_GET ((unsigned char *) tp + 8);
	  tmp1 = byte_get ((unsigned char *) tp + 16, 4);
	  tmp2 = byte_get ((unsigned char *) tp + 20, 4);
	}
a5292 3

      tep->start.offset += aux->seg_base;
      tep->end.offset   += aux->seg_base;
d5351 1
a5351 1
  aux->table_len = size / unw_ent_size;
@


1.310
log
@2005-08-11  H.J. Lu  <hongjiu.lu@@intel.com>

	* NEWS: Mention "-t/--section-details" and
	"-N/--full-section-name".

	* doc/binutils.texi: Document "-t/--section-details". Remove
	"-N/--full-section-name".

	* readelf.c (do_full_section_name): Renamed to ...
	(do_section_details): This.
	(option): Rename "-N/--full-section-name" to
	"-t/--section-details".
	(usage): Likewise.
	(parse_args): Likewise.
	(get_elf_section_flags): Support do_section_details.
	(process_section_headers): Updated for do_section_details.
@
text
@d2414 1
d2581 1
@


1.309
log
@	* readelf.c (get_parisc_dynamic_type): Add new dynamic types.
	(get_dynamic_type): Use old values for DT_LOOS and DT_HIOS when
	e_machine is EM_PARISC.
	(get_parisc_segment_type): Add new segment types.
	(get_parisc_section_type_name): Add new section names.
	(dynamic_section_parisc_val): Add new table entries.
@
text
@d150 1
a150 1
static int do_full_section_name;
d2719 1
d2755 1
a2755 2
  -N --full-section-name\n\
                         Display the full section name\n\
d2828 1
a2828 1
	  (argc, argv, "ersuahnldSDAINgw::x:i:vVWH", options, NULL)) != EOF)
d2859 1
d2861 2
a2862 1
	  do_full_section_name++;
d3793 1
a3793 1
  static char buff[33];
d3795 25
d3828 1
a3828 1
      switch (flag)
d3830 12
a3841 10
	case SHF_WRITE:		   *p = 'W'; break;
	case SHF_ALLOC:		   *p = 'A'; break;
	case SHF_EXECINSTR:	   *p = 'X'; break;
	case SHF_MERGE:		   *p = 'M'; break;
	case SHF_STRINGS:	   *p = 'S'; break;
	case SHF_INFO_LINK:	   *p = 'I'; break;
	case SHF_LINK_ORDER:	   *p = 'L'; break;
	case SHF_OS_NONCONFORMING: *p = 'O'; break;
	case SHF_GROUP:		   *p = 'G'; break;
	case SHF_TLS:		   *p = 'T'; break;
d3843 19
a3861 4
	default:
	  if (elf_header.e_machine == EM_X86_64
	      && flag == SHF_X86_64_LARGE)
	    *p = 'l';
d3864 3
a3866 2
	      *p = 'o';
	      sh_flags &= ~ SHF_MASKOS;
d3870 3
a3872 2
	      *p = 'p';
	      sh_flags &= ~ SHF_MASKPROC;
d3875 40
a3914 2
	    *p = 'x';
	  break;
a3915 1
      p++;
d4095 1
a4095 1
      if (do_full_section_name)
d4098 1
a4098 1
	  printf (_("       Type            Addr     Off    Size   ES Flg Lk Inf Al\n"));
d4106 1
a4106 1
      if (do_full_section_name)
d4109 1
a4109 1
	  printf (_("       Type            Address          Off    Size   ES Flg Lk Inf Al\n"));
d4117 1
a4117 1
      if (do_full_section_name)
d4120 2
a4121 2
	  printf (_("       Flags             Type             Address           Offset\n"));
	  printf (_("       Size              EntSize          Link     Info     Align\n"));
d4130 3
d4137 1
a4137 1
      if (do_full_section_name)
d4161 4
a4164 1
	  printf (" %3s ", get_elf_section_flags (section->sh_flags));
d4199 4
a4202 1
	  printf (" %3s ", get_elf_section_flags (section->sh_flags));
d4216 1
a4216 1
      else if (do_full_section_name)
d4218 1
a4218 2
	  printf ("       %-15.15s   %-15.15s ",
		  get_elf_section_flags (section->sh_flags),
a4219 1
	  putchar (' ');
d4222 1
a4222 1
	    printf ("  %8.8lx", (unsigned long) section->sh_offset);
d4228 1
a4228 1
	  printf ("\n       ");
d4230 1
a4230 1
	  printf ("  ");
d4233 1
a4233 2
	  printf ("   %2ld      %3lu        %ld\n",
		  (unsigned long) section->sh_link,
d4260 3
d4265 2
a4266 1
  printf (_("Key to Flags:\n\
@


1.308
log
@bfd/

2005-07-25  Jan Hubicka  <jh@@suse.cz>
	    H.J. Lu  <hongjiu.lu@@intel.com>

	* elf-bfd.h (_bfd_elf_large_com_section): New.
	* elf.c (_bfd_elf_large_com_section): New. Defined.

	* elf64-x86-64.c (elf64_x86_64_add_symbol_hook): New.
	(elf64_x86_64_elf_section_from_bfd_section): New.
	(elf64_x86_64_symbol_processing): New.
	(elf64_x86_64_common_definition): New.
	(elf64_x86_64_common_section_index): New.
	(elf64_x86_64_common_section): New.
	(elf64_x86_64_merge_symbol): New.
	(elf64_x86_64_additional_program_headers): New.
	(elf64_x86_64_special_sections): New.
	(elf_backend_section_from_bfd_section): New. Defined.
	(elf_backend_add_symbol_hook): Likewise.
	(elf_backend_common_section_index): Likewise.
	(elf_backend_common_section): Likewise.
	(elf_backend_common_definition): Likewise.
	(elf_backend_merge_symbol): Likewise.
	(elf_backend_special_sections): Likewise.
	(elf_backend_additional_program_headers): Likewise.

binutils/

2005-07-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (dump_relocations): Handle SHN_X86_64_LCOMMON.
	(get_symbol_index_type): Likewise.
	(get_elf_section_flags): Handle SHF_X86_64_LARGE.

gas/

2005-07-25  Jan Hubicka  <jh@@suse.cz>
	    H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-elf.c: Include "elf/x86-64.h" if TC_I386 is
	defined.
	(elf_com_section_ptr): New.
	(elf_begin): Set elf_com_section_ptr to bfd_com_section_ptr.
	(elf_common_parse): Make it global. Use elf_com_section_ptr
	instead of bfd_com_section_ptr.
	(obj_elf_change_section): Handle x86-64 large bss sections.

	* config/obj-elf.h (elf_com_section_ptr): New.
	(elf_common_parse): New.

	* config/tc-i386.c (handle_large_common): New.
	(md_pseudo_table): Add "largecomm".
	(x86_64_section_letter): New.
	(x86_64_section_word): New.

	* config/tc-i386.h (x86_64_section_word): New.
	(x86_64_section_letter): New.
	(md_elf_section_letter): New. Defined.
	(md_elf_section_word): Likewise.

include/elf/

2005-07-25  Jan Hubicka  <jh@@suse.cz>

	* x86-64.h (SHN_X86_64_LCOMMON): New.
	(SHF_X86_64_LARGE): New.

ld/

2005-07-25  Jan Hubicka  <jh@@suse.cz>
	    H.J. Lu  <hongjiu.lu@@intel.com>

	* emulparams/elf_x86_64.sh (LARGE_SECTIONS): New.

	* scripttempl/elf.sc: Updated for large section support.
@
text
@d1536 11
d1689 3
a1691 1
      else if ((type >= DT_LOOS) && (type <= DT_HIOS))
d2408 4
d2577 3
d5453 7
a5459 1
	  { DT_HP_BIND_DEPTH_FIRST, "HP_BIND_DEPTH_FIRST" }
@


1.307
log
@	* readelf.c (read_and_display_attr_value): Remove comment adjacent
	to DW_ATE_decimal_float about it being a GNU extension.
@
text
@d1358 3
d3795 4
a3798 1
	  if (flag & SHF_MASKOS)
d6707 3
@


1.306
log
@binutils/
	* readelf.c (read_and_display_attr_value): Handle a DW_AT_encoding
	value of DW_ATE_decimal_float instead of DW_ATE_GNU_decimal_float.
include/elf/
	* dwarf2.h (enum dwarf_type): Remove DW_AT_GNU_decimal_float.
	Replace with DW_ATE_decimal_float (now in DWARF 3).
@
text
@a8617 1
	  /* GNU extension.  */
@


1.305
log
@ChangeLog:
2005-07-14  Jim Blandy  <jimb@@redhat.com>

	* configure.in: Add cases for Renesas m32c.
	* configure: Regenerated.

bfd/ChangeLog:
2005-07-14  Jim Blandy  <jimb@@redhat.com>

	Add support for m32c-*-elf (Renesas m32c and m16c).
	* Makefile.am (ALL_MACHINES): Add cpu-m32c.lo.
	(ALL_MACHINES_CFILES): Add cpu-m32c.c.
	(BFD32_BACKENDS): Add elf32-m32c.lo.
	(BFD32_BACKENDS_CFILES): Add elf32-m32c.c.
	(cpu-m32c.lo, elf32-m32c.lo): New rules, generated by 'make dep-am'.
	* Makefile.in: Regenerated.
	* archures.c (bfd_arch_m32c, bfd_mach_m16c, bfd_mach_m32c): New
	arch and mach codes.
	(bfd_m32c_arch): New arch info object.
	(bfd_archures_list): List bfd_m32c_arch.
	* bfd-in2.h: Regenerated.
	* config.bfd: Add case for the m32c.
	* configure.in: Add case for the m32c.
	* configure: Regenerated.
	* cpu-m32c.c, elf32-m32c.c: New files.
	* libbfd.h: Regenerated.
	* targets.c (bfd_elf32_m32c_vec): Declare.
	(_bfd_target_vector): List bfd_elf32_m32c_vec.

binutils/ChangeLog:
2005-07-14  Jim Blandy  <jimb@@redhat.com>

	* readelf.c: #include "elf/m32c.h"
	(guess_is_rela, dump_relocations, get_machine_name): Add cases for
	EM_M32C.
	* Makefile.am (readelf.o): Update dependencies.
	* Makefile.in: Regenerated.

cpu/ChangeLog:
2005-07-14  Jim Blandy  <jimb@@redhat.com>

	* m32c.cpu, m32c.opc: Machine description for the Renesas M32C.

gas/ChangeLog:
2005-07-14  Jim Blandy  <jimb@@redhat.com>

	Add support for the Renesas M32C.
	* Makefile.am (CPU_TYPES): List m32c.
	(TARGET_CPU_CFILES): List config/tc-m32c.c.
	(TARGET_CPU_HFILES): List config/tc-m32c.h.
	* configure.in: Add case for m32c.
	* configure.tgt: Add cases for m32c and m32c-*-elf.
	* configure: Regenerated.
	* config/tc-m32c.c, config/tc-m32c.h: New files.
	* doc/Makefile.am (CPU_DOCS): Add c-m32c.texi.
	* doc/Makefile.in: Regenerated.
	* doc/all.texi: Set M32C.
	* doc/as.texinfo: Add text for the M32C-specific options and line
	comment characters, and refer to c-m32c.texi.
	* doc/c-m32c.texi: New file.

include/ChangeLog:
2005-07-14  Jim Blandy  <jimb@@redhat.com>

	* dis-asm.h (print_insn_m32c): New declaration.

include/elf/ChangeLog:
2005-07-14  Jim Blandy  <jimb@@redhat.com>

	Add support for Renesas M32C and M16C.
	* common.h (EM_M32C): New machine number.
	* m32c.h: New file.

ld/ChangeLog:
2005-07-14  Jim Blandy  <jimb@@redhat.com>

	Add support for the Renesas M32C and M16C.
	* Makefile.am (ALL_EMULATIONS): Add eelf32m32c.o.
	(eelf32m32c.c): New target.
	* Makefile.in: Regenerated.
	* configure.tgt: Add case for m32c-*-elf.
	* emulparams/elf32m32c.sh: New file.

opcodes/ChangeLog:
2005-07-14  Jim Blandy  <jimb@@redhat.com>

	Add support for the Renesas M32C and M16C.
	* m32c-asm.c, m32c-desc.c, m32c-dis.c, m32c-ibld.c, m32c-opc.c: New.
	* m32c-desc.h, m32c-opc.h: New.
	* Makefile.am (HFILES): List m32c-desc.h and m32c-opc.h.
	(CFILES): List m32c-asm.c, m32c-desc.c, m32c-dis.c, m32c-ibld.c,
	m32c-opc.c.
	(ALL_MACHINES): List m32c-asm.lo, m32c-desc.lo, m32c-dis.lo,
	m32c-ibld.lo, m32c-opc.lo.
	(CLEANFILES): List stamp-m32c.
	(M32C_DEPS): List stamp-m32c, if CGEN_MAINT.
	(CGEN_CPUS): Add m32c.
	(m32c-asm.c, m32c-desc.c, m32c-dis.c, m32c-ibld.c, m32c-opc.c)
	(m32c-desc.h, m32c-opc.h): Depend on M32C_DEPS.
	(m32c_opc_h): New variable.
	(stamp-m32c, m32c-asm.lo, m32c-desc.lo, m32c-dis.lo, m32c-ibld.lo)
	(m32c-opc.lo): New rules.
	* Makefile.in: Regenerated.
	* configure.in: Add case for bfd_m32c_arch.
	* configure: Regenerated.
	* disassemble.c (ARCH_m32c): New.
	[ARCH_m32c]: #include "m32c-desc.h".
	(disassembler) [ARCH_m32c]: Add case for bfd_arch_m32c.
	(disassemble_init_for_target) [ARCH_m32c]: Same.

	* cgen-ops.h, cgen-types.h: New files.
	* Makefile.am (HFILES): List them.
	* Makefile.in: Regenerated.
@
text
@d8619 1
a8619 1
	case DW_ATE_GNU_decimal_float:	printf ("(decimal float)"); break;
@


1.304
log
@Kaveh Ghazi's printf format attribute checking patch.
bfd:
	* elf32-xtensa.c (vsprint_msg): Add format attribute.  Fix
	format bugs.
	* vms.h (_bfd_vms_debug): Add format attribute.
	(_bfd_vms_debug, _bfd_hexdump): Fix typos.

binutils:
	* bucomm.h (report): Add format attribute.
	* dlltool.c (inform): Likewise.
	* dllwrap.c (display, inform, warn): Likewise.
	* objdump.c (objdump_sprintf): Likewise.
	* readelf.c (error, warn): Likewise.  Fix format bugs.

gas:
	* config/tc-tic30.c (debug): Add format attribute.  Fix format
	bugs.

include:
	* dis-asm.h (fprintf_ftype): Add format attribute.

opcodes:
	* arc-dis.c, arm-dis.c, cris-dis.c, crx-dis.c, d10v-dis.c,
	d30v-dis.c, fr30-dis.c, h8300-dis.c, h8500-dis.c, i860-dis.c,
	ia64-dis.c, ip2k-dis.c, m10200-dis.c, m10300-dis.c,
	m88k-dis.c, mcore-dis.c, mips-dis.c, ms1-dis.c, or32-dis.c,
	ppc-dis.c, sh64-dis.c, sparc-dis.c, tic4x-dis.c, tic80-dis.c,
	v850-dis.c: Fix format bugs.
	* ia64-gen.c (fail, warn): Add format attribute.
	* or32-opc.c (debug): Likewise.
@
text
@d89 1
d771 1
d1281 4
d1827 1
@


1.303
log
@	* elf/external.h (GRP_ENTRY_SIZE): Define.

	* readelf.c (CHECK_ENTSIZE_VALUES, CHECK_ENTSIZE): Define.
	(process_section_headers): Use it.
	(process_relocs): Don't crash if symsec is not SHT_SYMTAB
	or SHT_DYNSYM.
	(process_version_sections): Use sizeof (Elf_External_Versym)
	instead of sh_entsize.
@
text
@d267 1
a267 1
static void
d278 1
a278 1
static void
d330 1
a330 1
      error (_("Unable to seek to 0x%x for %s\n"),
d345 2
a346 2
	  error (_("Out of memory allocating 0x%x bytes for %s\n"),
		 size * nmemb, reason);
d355 2
a356 1
      error (_("Unable to read in 0x%x bytes of %s\n"), size * nmemb, reason);
d7457 1
a7457 1
      warn (_("DW_FORM_strp offset too big: %x\n"), offset);
d8468 1
a8468 1
      warn (_("Unrecognized form: %d\n"), form);
d9803 1
a9803 1
		      start - section_begin, next - section_begin);
d9806 1
a9806 1
		      start - section_begin, next - section_begin);
d10156 1
a10156 1
		      start - section_begin, next - section_begin);
d10159 1
a10159 1
		      start - section_begin, next - section_begin);
d10532 1
a10532 1
	      warn ("Invalid CIE pointer %08lx in FDE at %08lx\n",
d11818 3
a11820 3
	  warn (_("corrupt note found at offset %x into core notes\n"),
		((char *) external) - ((char *) pnotes));
	  warn (_(" type: %x, namesize: %08lx, descsize: %08lx\n"),
d12299 1
a12299 1
	      error (_("%s: invalid archive string table offset %lu\n"), off);
d12315 1
a12315 1
	  error (_("%s: bad archive file name\n"));
@


1.302
log
@	* readelf.c (cmalloc, xcmalloc, xcrealloc): New functions.
	(get_data): Add nmemb argument.  Return NULL if nmemb * size
	overflows.  If var == NULL, allocate one extra byte and
	clear it.
	(slurp_rela_relocs, slurp_rel_relocs, get_32bit_program_headers,
	get_64bit_program_headers, get_program_headers,
	get_32bit_section_headers, get_64bit_section_headers,
	get_32bit_elf_symbols, get_64bit_elf_symbols, process_section_headers,
	process_section_groups, process_relocs, slurp_ia64_unwind_table,
	ia64_process_unwind, slurp_hppa_unwind_table, hppa_process_unwind,
	get_32bit_dynamic_section, get_64bit_dynamic_section,
	process_dynamic_section, process_version_sections, get_dynamic_data,
	process_symbol_table, dump_section, load_debug_str, load_debug_loc,
	load_debug_range, read_and_display_attr_value, process_debug_info,
	get_debug_info, frame_need_space, display_debug_frames,
	display_debug_section, process_mips_specific, process_gnu_liblist,
	process_corefile_note_segment): Adjust get_data callers.  Use
	cmalloc, xcmalloc and xcrealloc instead of {m,xm,xre}alloc where
	passed size is a product of 2 numbers.

	* readelf.c (print_mode): Fix comment typo.
	(slurp_rela_relocs, slurp_rel_relocs): Fix memory leaks.
	(dump_relocations): Fix a thinko in check for invalid st_name.
	(process_program_headers): Don't crash if string_table is NULL.
	(process_section_headers): Don't crash if e_shstrndx is invalid.
	Ensure string_table_length is 0 if string_table == NULL.
	Don't return just because string_table is NULL.
	(process_section_groups): Don't crash if symtab's sh_link or
	symbol's st_name is invalid.  Fix a memory leak.  Fix check for
	invalid section number entry.
	(process_relocs): Don't crash if relocation or symbol section's
	sh_link is invalid.
	(slurp_ia64_unwind_table, slurp_hppa_unwind_table): Don't crash if
	relocation section's sh_info is invalid.
	(ia64_process_unwind, hppa_process_unwind): Don't crash if symbol
	table's sh_link is invalid.
	(process_version_sections): Don't crash on version or symbol
	section's sh_link is invalid.  Don't crash if symbol's st_shndx
	is invalid.
	(process_symbol_table): Don't crash if string table is corrupt
	or symbol's st_name, st_shndx, vna_name or vda_name is invalid.
	(debug_apply_rela_addends): Don't crash if relocation section's
	sh_info or sh_link is invalid.
	(display_debug_loc): Warn for unterminated .debug_loc section
	or start offsets not within .debug_loc section boundaries.
	(process_gnu_liblist): Don't crash if liblist section's sh_link
	or entry's l_name is invalid.
@
text
@d3874 16
d3904 1
d3930 8
d4516 4
d6390 1
a6390 1
	    total = section->sh_size / section->sh_entsize;
@


1.301
log
@2005-06-07  Eric Christopher  <echristo@@redhat.com>

        * Makefile.am (eelf32ms1.c): Use tab.
        * Makefile.in: Regenerate.

2005-06-07  Eric Christopher  <echristo@@redhat.com>

        * readelf.c (guess_is_rela): Support ms1.
        (dump_relocations): Ditto.
        (get_machine_name): Ditto.
@
text
@d210 1
a210 1
/* How to rpint a vma value.  */
d290 32
a321 1
get_data (void *var, FILE *file, long offset, size_t size, const char *reason)
d325 1
a325 1
  if (size == 0)
d338 4
a341 1
      mvar = malloc (size);
d346 1
a346 1
		 size, reason);
d349 2
d353 1
a353 1
  if (fread (mvar, size, 1, file) != 1)
d355 1
a355 1
      error (_("Unable to read in 0x%x bytes of %s\n"), size, reason);
d810 1
a810 1
      erelas = get_data (NULL, file, rel_offset, rel_size, _("relocs"));
d816 1
a816 1
      relas = malloc (nrelas * sizeof (Elf_Internal_Rela));
d820 1
d838 1
a838 1
      erelas = get_data (NULL, file, rel_offset, rel_size, _("relocs"));
d844 1
a844 1
      relas = malloc (nrelas * sizeof (Elf_Internal_Rela));
d848 1
d882 1
a882 1
      erels = get_data (NULL, file, rel_offset, rel_size, _("relocs"));
d888 1
a888 1
      rels = malloc (nrels * sizeof (Elf_Internal_Rela));
d892 1
d910 1
a910 1
      erels = get_data (NULL, file, rel_offset, rel_size, _("relocs"));
d916 1
a916 1
      rels = malloc (nrels * sizeof (Elf_Internal_Rela));
d920 1
d1366 1
a1366 1
	      else if (psym->st_name > strtablen)
d3194 1
a3194 1
		    elf_header.e_phentsize * elf_header.e_phnum,
d3227 1
a3227 1
		    elf_header.e_phentsize * elf_header.e_phnum,
d3262 1
a3262 1
  phdrs = malloc (elf_header.e_phnum * sizeof (Elf_Internal_Phdr));
d3475 1
a3475 1
  if (do_segments && section_headers != NULL)
a3479 2
      assert (string_table != NULL);

d3557 1
a3557 1
		    elf_header.e_shentsize * num, _("section headers"));
d3561 1
a3561 1
  section_headers = malloc (num * sizeof (Elf_Internal_Shdr));
d3598 1
a3598 1
		    elf_header.e_shentsize * num, _("section headers"));
d3602 1
a3602 1
  section_headers = malloc (num * sizeof (Elf_Internal_Shdr));
d3641 1
a3641 1
  esyms = get_data (NULL, file, section->sh_offset, section->sh_size,
d3652 1
a3652 1
			symtab_shndx_hdr->sh_size, _("symtab shndx"));
d3661 1
a3661 1
  isyms = malloc (number * sizeof (Elf_Internal_Sym));
d3704 1
a3704 1
  esyms = get_data (NULL, file, section->sh_offset, section->sh_size,
d3715 1
a3715 1
			symtab_shndx_hdr->sh_size, _("symtab shndx"));
d3724 1
a3724 1
  isyms = malloc (number * sizeof (Elf_Internal_Sym));
d3834 1
a3834 3
  section = SECTION_HEADER (elf_header.e_shstrndx);

  if (section->sh_size != 0)
d3836 1
a3836 2
      string_table = get_data (NULL, file, section->sh_offset,
			       section->sh_size, _("string table"));
d3838 4
a3841 2
      if (string_table == NULL)
	return 0;
d3843 2
a3844 1
      string_table_length = section->sh_size;
d3901 1
a3901 1
				      section->sh_size, _("dynamic strings"));
d4147 1
d4204 1
d4219 3
a4221 2
	  sec = SECTION_HEADER (section->sh_link);
	  if (sec->sh_type != SHT_SYMTAB)
d4247 3
d4251 1
d4256 11
a4266 2
	      sec = SECTION_HEADER (symtab_sec->sh_link);
	      if (strtab_sec != sec)
d4272 1
a4272 1
				     strtab_sec->sh_size,
d4274 1
d4276 2
a4277 1
	      group_name = strtab + sym->st_name;
d4281 1
a4281 1
			    section->sh_size, _("section data"));
d4305 1
a4305 1
	      if (entry >= elf_header.e_shnum)
d4349 1
a4349 2
		  printf ("   [%5u]   %s\n",
			  entry, SECTION_NAME (sec));
d4480 3
a4482 1
	      if (section->sh_link)
d4487 1
a4487 1
		  unsigned long strtablen;
d4497 4
a4500 1
		  strsec = SECTION_HEADER (symsec->sh_link);
d4502 5
a4506 3
		  strtab = get_data (NULL, file, strsec->sh_offset,
				     strsec->sh_size, _("string table"));
		  strtablen = strtab == NULL ? 0 : strsec->sh_size;
d4697 1
a4697 1
  table = get_data (NULL, file, sec->sh_offset, size, _("unwind table"));
d4701 1
a4701 1
  aux->table = xmalloc (size / (3 * eh_addr_size) * sizeof (aux->table[0]));
d4733 1
d4799 2
a4800 1
      if (sec->sh_type == SHT_SYMTAB)
a4805 1
	  aux.strtab_size = strsec->sh_size;
d4807 2
a4808 1
				 aux.strtab_size, _("string table"));
d4889 1
a4889 1
	  aux.info = get_data (NULL, file, sec->sh_offset, aux.info_size,
d5079 1
a5079 1
  table = get_data (NULL, file, sec->sh_offset, size, _("unwind table"));
d5085 1
a5085 1
  tep = aux->table = xmalloc (size / unw_ent_size * sizeof (aux->table[0]));
d5153 1
d5217 2
a5218 1
  assert (string_table != NULL);
d5222 2
a5223 1
      if (sec->sh_type == SHT_SYMTAB)
a5228 1
	  aux.strtab_size = strsec->sh_size;
d5230 2
a5231 1
				 aux.strtab_size, _("string table"));
d5447 1
a5447 1
  edyn = get_data (NULL, file, dynamic_addr, dynamic_size,
d5464 1
a5464 1
  dynamic_section = malloc (dynamic_nent * sizeof (*entry));
d5491 1
a5491 1
  edyn = get_data (NULL, file, dynamic_addr, dynamic_size,
d5508 1
a5508 1
  dynamic_section = malloc (dynamic_nent * sizeof (*entry));
d5666 1
a5666 1
	  dynamic_strings = get_data (NULL, file, offset, str_tab_len,
d5701 2
a5702 2
	  extsyminfo = get_data (NULL, file, dynamic_syminfo_offset, syminsz,
				 _("symbol information"));
d6178 4
a6181 1
		    SECTION_NAME (SECTION_HEADER (section->sh_link)));
d6183 2
a6184 1
	    edefs = get_data (NULL, file, section->sh_offset, section->sh_size,
d6271 4
a6274 1
		    SECTION_NAME (SECTION_HEADER (section->sh_link)));
d6276 2
a6277 1
	    eneed = get_data (NULL, file, section->sh_offset, section->sh_size,
d6357 3
d6363 4
d6373 1
a6373 1
	    strtab = get_data (NULL, file, string_sec->sh_offset,
d6390 1
a6390 1
	    edata = get_data (NULL, file, off, total * sizeof (short),
d6398 1
a6398 1
	    data = malloc (total * sizeof (short));
d6431 4
a6434 2
		      if (SECTION_HEADER (symbols[cnt + j].st_shndx)->sh_type
			  != SHT_NOBITS)
d6459 1
a6459 1
			      get_data (&evn, file, offset, sizeof (evn),
d6470 1
a6470 1
					    _("version need aux (2)"));
d6511 1
a6511 1
			      get_data (&evd, file, offset, sizeof (evd),
d6531 2
a6532 1
					sizeof (evda), _("version def aux"));
d6684 1
a6684 1
  e_data = malloc (number * ent_size);
d6698 1
a6698 1
  i_data = malloc (number * sizeof (*i_data));
d6826 2
a6827 1
	  char *strtab;
d6849 5
a6853 2
	    strtab = string_table;
	  else
d6860 2
a6861 1
				 string_sec->sh_size, _("string table"));
d6876 2
a6877 1
	      print_symbol (25, strtab + psym->st_name);
d6893 1
a6893 1
			    sizeof (data), _("version data"));
d6897 4
a6900 2
		  is_nobits = (SECTION_HEADER (psym->st_shndx)->sh_type
			       == SHT_NOBITS);
d6922 1
a6922 1
			      get_data (&evn, file, offset, sizeof (evn),
d6935 1
a6935 1
					    sizeof (evna),
d6957 3
a6959 1
				      strtab + ivna.vna_name, ivna.vna_other);
d6988 1
a6988 1
					    _("version def"));
d7003 1
a7003 1
					_("version def aux"));
d7010 2
a7011 1
					strtab + ivda.vda_name);
d7196 2
a7197 1
  start = get_data (NULL, file, section->sh_offset, bytes, _("section data"));
d7404 1
a7404 1
  debug_str_contents = get_data (NULL, file, sec->sh_offset, sec->sh_size,
d7453 1
a7453 1
  debug_loc_contents = get_data (NULL, file, sec->sh_offset, sec->sh_size,
d7487 1
a7487 1
  debug_range_contents = get_data (NULL, file, sec->sh_offset, sec->sh_size,
d7528 1
d7530 2
a7531 1
	  || relsec->sh_size == 0)
d8469 2
a8470 2
		    = xrealloc (debug_info_p->loc_offsets,
				max * sizeof (*debug_info_p->loc_offsets));
d8472 2
a8473 2
		    = xrealloc (debug_info_p->have_frame_base,
				max * sizeof (*debug_info_p->have_frame_base));
d8498 2
a8499 2
		    = xrealloc (debug_info_p->range_lists,
				max * sizeof (*debug_info_p->range_lists));
d8876 2
a8877 2
      debug_information = malloc (num_units *
				  sizeof (* debug_information));
d8990 1
a8990 1
	begin = get_data (NULL, file, sec->sh_offset, sec->sh_size,
d9159 1
a9159 1
  start = get_data (NULL, file, section->sh_offset, section->sh_size,
d9780 7
d9789 7
d9811 1
a9811 1
		  printf ("    %8.8lx %8.8lx %8.8lx (base address)\n",
d9816 7
d9826 7
d10205 2
a10206 2
  fc->col_type = xrealloc (fc->col_type, fc->ncols * sizeof (short int));
  fc->col_offset = xrealloc (fc->col_offset, fc->ncols * sizeof (int));
d10516 2
a10517 2
	      fc->col_type = xmalloc (fc->ncols * sizeof (short int));
	      fc->col_offset = xmalloc (fc->ncols * sizeof (int));
d10829 2
a10830 2
	      rs->col_type = xmalloc (rs->ncols * sizeof (short int));
	      rs->col_offset = xmalloc (rs->ncols * sizeof (int));
d11052 1
a11052 1
	start = get_data (NULL, file, section->sh_offset, length,
d11178 1
a11178 1
		       liblistno * sizeof (Elf32_External_Lib),
d11267 1
a11267 1
      eopt = get_data (NULL, file, options_offset, sect->sh_size,
d11271 1
a11271 1
	  iopt = malloc ((sect->sh_size / sizeof (eopt)) * sizeof (*iopt));
d11463 1
a11463 1
      iconf = malloc (conflictsno * sizeof (*iconf));
d11475 1
a11475 1
			      conflictsno * sizeof (*econf32), _("conflict"));
d11489 1
a11489 1
			      conflictsno * sizeof (*econf64), _("conflict"));
d11529 1
d11543 4
a11546 1
	  elib = get_data (NULL, file, section->sh_offset, section->sh_size,
d11553 1
a11553 1
	  strtab = get_data (NULL, file, string_sec->sh_offset,
d11555 1
d11592 2
a11593 1
		printf ("%-20s", strtab + liblist.l_name);
d11595 2
a11596 1
		printf ("%-20.20s", strtab + liblist.l_name);
d11761 1
a11761 1
  pnotes = get_data (NULL, file, offset, length, _("notes"));
@


1.300
log
@	* Makefile.am (readelf.o): Depend on ms1.h.

	* Makefile.in: Regenerate.

	* readelf.c: Include ms1.h.
@
text
@d733 1
d1237 4
d1780 1
@


1.299
log
@        * readelf.c (dump_relocations): Special case R_ALPHA_LITUSE.
@
text
@d97 1
@


1.298
log
@        * readelf.c (get_alpha_dynamic_type): New.
        (get_dynamic_type): Call it.
@
text
@d1246 25
a1270 1
      if (symtab_index)
d1336 1
a1336 2
      if (elf_header.e_machine == EM_SPARCV9
	  && streq (rtype, "R_SPARC_OLO10"))
@


1.297
log
@2005-05-24  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (process_section_groups): Report group section
	index. Check if the section member index is valid.
@
text
@d1474 11
d1586 3
@


1.296
log
@(fetch_indirect_string): Display a warning message when a corrupt
  DW_FORM_strp value is encountered.

(process_debug_info): Mention that the compilation unit offset is being
  displayed in hexadecimal.

(display_debug_lines): Fix typo in name of .debug_line section.
@
text
@d4190 2
a4191 2
	      printf ("\n%s group section `%s' [%s] contains %u sections:\n",
		      get_group_flags (entry), name, group_name, size);
d4205 13
d4223 2
a4224 2
		      error (_("section [%5u] already in group section [%5u]\n"),
			     entry,
@


1.295
log
@binutils/ChangeLog
	* readelf.c (read_and_display_attr_value): Handle a DW_AT_encoding
	value of DW_ATE_GNU_decimal_float.

include/elf/ChangeLog
	* dwarf2.h (enum dwarf_type): Assign DW_ATE_GNU_decimal_float from
	the user-defined encoding space pending inclusion in the standard.
@
text
@d7272 4
a7275 1
    return _("<offset is too big>");
d8806 1
a8806 1
	  printf (_("  Compilation Unit @@ %lx:\n"), cu_offset);
d9094 1
a9094 1
	(comp_unit, ".debug_lines", NULL);
d9205 1
a9205 1
						  pointer_size);
@


1.294
log
@include/elf/
	* ppc.h (DT_PPC_GOT): Rename from DT_PPC_GLINK.
bfd/
	* elf32-ppc.c (ppc_elf_size_dynamic_sections): Set DT_PPC_GOT,
	not DT_PPC_GLINK.
	(ppc_elf_finish_dynamic_sections): Likewise.
binutils/
	* readelf.c (get_ppc_dynamic_type): Display DT_PPC_GOT, not
	DT_PPC_GLINK.
@
text
@d8422 2
@


1.293
log
@	2005-05-13  Fred Fish  <fnf@@specifixinc.com>
	* readelf.c: Fix a couple of obvious comment typos,
	'debug_str' -> 'debug_ranges' and proecess' -> 'process'.
@
text
@d1420 1
a1420 1
    case DT_PPC_GLINK: return "PPC_GLINK";
@


1.292
log
@2005-05-13  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (dump_ia64_unwind): Get stamp with proper size.
@
text
@d7323 1
a7323 1
  /* Locate the .debug_str section.  */
d8913 1
a8913 1
     we need to proecess .debug_loc and .debug_ranges sections.  */
@


1.291
log
@Add missing \n character to end of warning message created by the previous delta
@
text
@d4517 1
a4517 1
      stamp = BYTE_GET ((unsigned char *) head);
@


1.290
log
@If pointer_size has not been found then assume that it is 4 in order to
prevent a seg fault when process_extend_line_op attempts to read the line
data.
@
text
@d9195 1
a9195 1
		  warn (_("Extend line ops need a valid pointer size, guessing at 4"));
@


1.289
log
@	* readelf.c (get_ppc_dynamic_type): New function for DT_PPC_GLINK.
	(get_dynamic_type): Call the above.
@
text
@d7169 2
a7170 2
/* Handled an extend line op.  Returns true if this is the end
   of sequence.  */
d9100 3
a9102 1
      printf (_("  (Pointer size:               %u)\n"), pointer_size);
d9193 6
d9200 1
a9200 1
						pointer_size);
@


1.288
log
@Update FSF address
@
text
@d1416 11
d1566 3
@


1.287
log
@	* ar.c (mri_mode): Make static.
	* arsup.c (obfd, real_name, outfile): Likewise.
	* binemul.c (ar_emul_create): Remove unused function.
	(ar_emul_default_create): Likewise.
	* binemul.h (ar_emul_create): Remove declaration.
	(ar_emul_default_create): Likewise.
	(struct bin_emulation_xfer_struct): Remove ar_create member.
	* bucomm.c (report): Make static.
	* bucomm.h (report): Remove declaration.
	* cxxfilt.c (mbuffer): Make static.
	(main): Use unsigned ints for some loop control variables.
	* readelf.c: Make many global variables static.
	* size.c (berkeley_format): Make static.
	(long_options): Likewise.
	* emul_aix.c (bin_aix_emulation): Remove ar_emul_default_create
	structure initialiser.
	(bin_aix5_emulation): Likewise.
	* emul_vanilla.c (bin_vanilla_emulation): Likewise.
@
text
@d22 2
a23 2
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.286
log
@	* readelf.c (display_debug_frames): Use data factor for
	DW_CFA_def_cfa_sf and DW_CFA_def_cfa_offset_sf.
@
text
@d120 55
a174 55
long archive_file_offset;
unsigned long archive_file_size;
unsigned long dynamic_addr;
bfd_size_type dynamic_size;
unsigned int dynamic_nent;
char *dynamic_strings;
unsigned long dynamic_strings_length;
char *string_table;
unsigned long string_table_length;
unsigned long num_dynamic_syms;
Elf_Internal_Sym *dynamic_symbols;
Elf_Internal_Syminfo *dynamic_syminfo;
unsigned long dynamic_syminfo_offset;
unsigned int dynamic_syminfo_nent;
char program_interpreter[64];
bfd_vma dynamic_info[DT_JMPREL + 1];
bfd_vma version_info[16];
Elf_Internal_Ehdr elf_header;
Elf_Internal_Shdr *section_headers;
Elf_Internal_Phdr *program_headers;
Elf_Internal_Dyn *dynamic_section;
Elf_Internal_Shdr *symtab_shndx_hdr;
int show_name;
int do_dynamic;
int do_syms;
int do_reloc;
int do_sections;
int do_section_groups;
int do_full_section_name;
int do_segments;
int do_unwind;
int do_using_dynamic;
int do_header;
int do_dump;
int do_version;
int do_wide;
int do_histogram;
int do_debugging;
int do_debug_info;
int do_debug_abbrevs;
int do_debug_lines;
int do_debug_pubnames;
int do_debug_aranges;
int do_debug_ranges;
int do_debug_frames;
int do_debug_frames_interp;
int do_debug_macinfo;
int do_debug_str;
int do_debug_loc;
int do_arch;
int do_notes;
int is_32bit_elf;
int have_frame_base;
int need_base_address;
bfd_vma eh_addr_size;
d188 3
a190 4
struct group *section_groups;
size_t group_count;

struct group **section_headers_groups;
d2579 1
a2579 1
struct option options[] =
d4246 1
a4246 1
struct
d10792 1
a10792 1
struct
@


1.285
log
@(debug_apply_rela_addends): Remove redundant %s from printf string.
@
text
@d10712 1
d10721 1
@


1.284
log
@* readelf.c (debug_apply_rela_addends): Reorder r_info as
necessary for 64-bit MIPS.
@
text
@d7390 1
a7390 1
		  warn (_("%s: skipping unexpected symbol type %s in relocation in section .rela%s\n"),
@


1.283
log
@2005-03-31  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (do_full_section_name): New.
	(options): Add "--full-section-name"/'N'.
	(usage): Add -N/--full-section-name.
	(parse_args): Handle 'N'.
	(process_section_headers): Print out the full section name if
	do_full_section_name isn't 0.
@
text
@d7398 12
@


1.282
log
@	* elf32-arm.c (elf32_arm_modify_segment_map): New function.
	(elf32_arm_additional_program_headers): Likewise.
	(elf_backend_modify_segment_map): Define.
	(elf_backend_additional_program_headers): Likewise.
	(elf32_arm_symbian_modify_segment_map): Use
	elf32_arm_modify_segment_map.

	* binutils/readelf.c (get_arm_segment_type): New function.
	(get_segment_type): Use it.

	* arm.h (PT_ARM_EXIDX): Define.
@
text
@d148 1
d2591 1
d2626 2
d2700 1
a2700 1
	  (argc, argv, "ersuahnldSDAIgw::x:i:vVWH", options, NULL)) != EOF)
d2731 3
d3857 10
a3866 2
    printf
      (_("  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al\n"));
d3868 10
a3877 2
    printf
      (_("  [Nr] Name              Type            Address          Off    Size   ES Flg Lk Inf Al\n"));
d3880 11
a3890 2
      printf (_("  [Nr] Name              Type             Address           Offset\n"));
      printf (_("       Size              EntSize          Flags  Link  Info  Align\n"));
d3897 14
a3910 4
      printf ("  [%2u] %-17.17s %-15.15s ",
	      SECTION_HEADER_NUM (i),
	      SECTION_NAME (section),
	      get_section_type_name (section->sh_type));
d3970 24
@


1.281
log
@	* readelf.c (get_file_type, get_machine_name, get_osabi_name,
	get_segment_type, get_section_type_name, get_elf_class,
	get_data_encoding, get_group_flags, dynamic_section_mips_val,
	get_symbol_binding, get_symbol_type, get_TAG_name, get_FORM_name,
	get_AT_name, process_mips_specific, process_gnu_liblist,
	get_note_type, get_netbsd_elfcore_note_type): Use snprintf instead of
	sprintf where needed.
	(get_dynamic_type): Likewise.  Increase buff to 64 bytes.
	(get_elf_section_flags): Increase buff to 33 bytes.  Avoid
	using strcat.
	(get_dynamic_flags): Renamed to...
	(print_dynamic_flags): ... this.  Print the flags to stdout instead
	of returning them as string.
	(process_dynamic_section): Adjust caller.
@
text
@d2238 14
d2341 3
@


1.281.2.1
log
@	* elf32-arm.c (elf32_arm_modify_segment_map): New function.
	(elf32_arm_additional_program_headers): Likewise.
	(elf_backend_modify_segment_map): Define.
	(elf_backend_additional_program_headers): Likewise.
	(elf32_arm_symbian_modify_segment_map): Use
	elf32_arm_modify_segment_map.

	* binutils/readelf.c (get_arm_segment_type): New function.
	(get_segment_type): Use it.

	* arm.h (PT_ARM_EXIDX): Define.
@
text
@a2237 14
get_arm_segment_type (unsigned long type)
{
  switch (type)
    {
    case PT_ARM_EXIDX:
      return "EXIDX";
    default:
      break;
    }

  return NULL;
}

static const char *
a2326 3
	    case EM_ARM:
	      result = get_arm_segment_type (p_type);
	      break;
@


1.281.2.2
log
@* readelf.c (debug_apply_rela_addends): Reorder r_info as
necessary for 64-bit MIPS.
@
text
@a7331 12
	      /* In MIPS little-endian objects, r_info isn't really a
		 64-bit little-endian value: it has a 32-bit little-endian
		 symbol index followed by four individual byte fields.
		 Reorder INFO accordingly.  */
	      if (elf_header.e_machine == EM_MIPS
		  && elf_header.e_ident[EI_DATA] != ELFDATA2MSB)
		rp->r_info = (((rp->r_info & 0xffffffff) << 32)
			      | ((rp->r_info >> 56) & 0xff)
			      | ((rp->r_info >> 40) & 0xff00)
			      | ((rp->r_info >> 24) & 0xff0000)
			      | ((rp->r_info >> 8) & 0xff000000));

@


1.281.2.3
log
@	* readelf.c (display_debug_frames): Use data factor for
	DW_CFA_def_cfa_sf and DW_CFA_def_cfa_offset_sf.
@
text
@a10645 1
	      fc->cfa_offset = fc->cfa_offset * fc->data_factor;
a10653 1
	      fc->cfa_offset = fc->cfa_offset * fc->data_factor;
@


1.281.2.3.2.1
log
@	* ld/ldmain.c (main): Use expandargv.
	* binutils/addr2line.c (main): Likewise.
	* binutils/ar.c (main): Likewise.
	* binutils/coffdump.c (main): Likewise.
	* binutils/cxxfilt.c (main): Likewise.
	* binutils/dlltool.c (main): Likewise.
	* binutils/dllwrap.c (main): Likewise.
	* binutils/nlmconv.c (main): Likewise.
	* binutils/nm.c (main): Likewise.
	* binutils/objcopy.c (main): Likewise.
	* binutils/objdump.c (main): Likewise.
	* binutils/readelf.c (main): Likewise.
	* binutils/size.c (main): Likeiwse.
	* binutils/srcconv.c (main): Likewise.
	* binutils/strings.c (main): Likewise.
	* binutils/sysdump.c (main): Likewise.
	* binutils/sysinfo.c (main): Likewise.
	* binutils/windres.c (main): Likewise.

	* include/libiberty.h (expandargv): New function.
	* libiberty/argv.c (safe-ctype.h): Include it.
	(ISBLANK): Remove.
	(stdio.h): Include.
	(expandargv): New function.
	* libiberty/Makefile.in: Regenerated.
@
text
@a12141 2
  expandargv (&argc, &argv);

@


1.280
log
@2005-02-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (display_debug_ranges): Print out offset for end of
	list.
@
text
@d1465 1
a1465 1
  static char buff[32];
d1569 1
a1569 1
	  sprintf (buff, _("Processor Specific: %lx"), type);
d1588 2
a1589 1
	  sprintf (buff, _("Operating System specific: %lx"), type);
d1592 1
a1592 1
	sprintf (buff, _("<unknown>: %lx"), type);
d1613 1
a1613 1
	sprintf (buff, _("Processor Specific: (%x)"), e_type);
d1615 1
a1615 1
	sprintf (buff, _("OS Specific: (%x)"), e_type);
d1617 1
a1617 1
	sprintf (buff, _("<unknown>: %x"), e_type);
d1724 1
a1724 1
      sprintf (buff, _("<unknown>: %x"), e_machine);
d2232 1
a2232 1
      sprintf (buff, _("<unknown: %x>"), osabi);
d2370 1
a2370 1
	sprintf (buff, _("<unknown>: %lx"), p_type);
d2554 1
a2554 1
	sprintf (buff, _("<unknown>: %x"), sh_type);
d2952 1
a2952 1
      sprintf (buff, _("<unknown: %x>"), elf_class);
d2968 1
a2968 1
      sprintf (buff, _("<unknown: %x>"), encoding);
d3641 2
a3642 3
  static char buff[32];

  *buff = 0;
d3653 10
a3662 10
	case SHF_WRITE:		   strcat (buff, "W"); break;
	case SHF_ALLOC:		   strcat (buff, "A"); break;
	case SHF_EXECINSTR:	   strcat (buff, "X"); break;
	case SHF_MERGE:		   strcat (buff, "M"); break;
	case SHF_STRINGS:	   strcat (buff, "S"); break;
	case SHF_INFO_LINK:	   strcat (buff, "I"); break;
	case SHF_LINK_ORDER:	   strcat (buff, "L"); break;
	case SHF_OS_NONCONFORMING: strcat (buff, "O"); break;
	case SHF_GROUP:		   strcat (buff, "G"); break;
	case SHF_TLS:		   strcat (buff, "T"); break;
d3667 1
a3667 1
	      strcat (buff, "o");
d3672 1
a3672 1
	      strcat (buff, "p");
d3676 1
a3676 1
	    strcat (buff, "x");
d3679 1
d3682 1
d3954 1
a3954 1
      sprintf (buff, _("[<unknown>: 0x%x]"), flags);
d5117 3
a5119 3
	sprintf (timebuf, "%04u-%02u-%02uT%02u:%02u:%02u",
		 tmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,
		 tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
d5309 2
a5310 2
static const char *
get_dynamic_flags (bfd_vma flags)
d5312 1
a5312 2
  static char buff[128];
  char *p = buff;
a5313 1
  *p = '\0';
d5321 4
a5324 2
      if (p != buff)
	*p++ = ' ';
d5328 6
a5333 6
	case DF_ORIGIN:		strcpy (p, "ORIGIN"); break;
	case DF_SYMBOLIC:	strcpy (p, "SYMBOLIC"); break;
	case DF_TEXTREL:	strcpy (p, "TEXTREL"); break;
	case DF_BIND_NOW:	strcpy (p, "BIND_NOW"); break;
	case DF_STATIC_TLS:	strcpy (p, "STATIC_TLS"); break;
	default:		strcpy (p, "unknown"); break;
a5334 2

      p = strchr (p, '\0');
d5336 1
a5336 1
  return buff;
d5533 1
a5533 1
	    puts (get_dynamic_flags (entry->d_un.d_val));
d6342 2
a6343 1
	sprintf (buff, _("<processor specific>: %d"), binding);
d6345 1
a6345 1
	sprintf (buff, _("<OS specific>: %d"), binding);
d6347 1
a6347 1
	sprintf (buff, _("<unknown>: %d"), binding);
d6378 1
a6378 1
	  sprintf (buff, _("<processor specific>: %d"), type);
d6390 1
a6390 1
	  sprintf (buff, _("<OS specific>: %d"), type);
d6393 1
a6393 1
	sprintf (buff, _("<unknown>: %d"), type);
d7565 1
a7565 1
	sprintf (buffer, _("Unknown TAG value: %lx"), tag);
d7601 1
a7601 1
	sprintf (buffer, _("Unknown FORM value: %lx"), form);
d8534 2
a8535 1
	sprintf (buffer, _("Unknown AT value: %lx"), attribute);
d10894 4
a10897 3
	      sprintf (timebuf, "%04u-%02u-%02uT%02u:%02u:%02u",
		       tmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,
		       tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
d11273 4
a11276 3
	      sprintf (timebuf, "%04u-%02u-%02uT%02u:%02u:%02u",
		       tmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,
		       tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
d11340 1
a11340 1
  sprintf (buff, _("Unknown note type: (0x%08x)"), e_type);
d11362 1
a11362 1
      sprintf (buff, _("Unknown note type: (0x%08x)"), e_type);
d11401 2
a11402 1
  sprintf (buff, _("PT_FIRSTMACH+%d"), e_type - NT_NETBSDCORE_FIRSTMACH);
@


1.279
log
@	* Makefile.am (syslex.o, sysinfo.o): Pass AM_CFLAGS to compiler.
	(syslex.o, sysinfo.o, dlltool.o, rescoff.o): Remove duplicate
	dependencies.  Run "make dep-am".
	* nlmconv.c: Warning fixes.
	* readelf.c: Likewise.
	* srconv.c: Likewise.
	* sysdump.c: Likewise.
	* sysinfo.y: Likewise.
	* syslex.l: Likewise.  Use yyleng instead of strlen, memcpy instead
	of strcpy.
	* Makefile.in: Regenerate.
@
text
@d9834 4
a9837 1
		break;
a9857 1
	  fputs (_("  <End of list>\n"), stdout);
@


1.278
log
@	* readelf.c (BYTE_GET8): Delete.  Replace uses with BYTE_GET.
	(byte_get_little_endian): Don't handle size of -8.
	(byte_get_signed, byte_get_big_endian): Likewise.
	(print_dec_vma, print_hex_vma): New functions.
	(print_vma): Use them.  Return chars output.
	(get_dynamic_data): Return a bfd_vma array.  Add ent_size parm.
	(process_symbol_table): Handle alpha and s390 .hash.
@
text
@d4030 2
a4031 1
	  char *group_name, *start, *indices;
d7015 1
a7015 1
read_leb128 (unsigned char *data, int *length_return, int sign)
d7079 1
a7079 1
  int bytes_read;
d7449 1
a7449 1
      int bytes_read;
d7624 1
a7624 1
  int bytes_read;
d7994 1
a7994 1
  int bytes_read;
d8733 1
a8733 1
	  int bytes_read;
d9035 1
a9035 1
	      int bytes_read;
d9062 1
a9062 1
	  int bytes_read;
d9310 1
a9310 1
	  string = curr;
d9319 1
a9319 1
	  string = curr;
d9331 1
a9331 1
	    string = curr;
d10010 1
a10010 1
  int length_return;
d10078 2
a10079 2
	  fc->augmentation = start;
	  start = strchr (start, '\0') + 1;
d10155 1
a10155 1
	      p = fc->augmentation + 1;
@


1.277
log
@2005-02-18  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (display_debug_loc): Print out offset for end of
	list.
@
text
@a250 14
/* If we can support a 64 bit data type then BFD64 should be defined
   and sizeof (bfd_vma) == 8.  In this case when translating from an
   external 8 byte field to an internal field, we can assume that the
   internal field is also 8 bytes wide and so we can extract all the data.
   If, however, BFD64 is not defined, then we must assume that the
   internal data structure only has 4 byte wide fields that are the
   equivalent of the 8 byte wide external counterparts, and so we must
   truncate the data.  */
#ifdef  BFD64
#define BYTE_GET8(field)	byte_get (field, -8)
#else
#define BYTE_GET8(field)	byte_get (field, 8)
#endif

a353 5
    case -8:
      /* This is a special case, generated by the BYTE_GET8 macro.
	 It means that we are loading an 8 byte value from a field
	 in an external structure into an 8 byte value in a field
	 in an internal structure.  */
a382 1
    case -8:
d417 52
d470 1
a470 1
static void
d480 2
a481 2
	  printf ("0x");
	  /* Drop through.  */
d483 1
a483 2
	  printf ("%8.8lx", (unsigned long) vma);
	  break;
d487 1
a487 4
	    {
	      printf ("%5ld", (long) vma);
	      break;
	    }
d489 1
d491 2
a492 2
	  printf ("0x");
	  /* Drop through.  */
d494 1
a494 2
	  printf ("%lx", (unsigned long) vma);
	  break;
d497 1
a497 2
	  printf ("%ld", (unsigned long) vma);
	  break;
d500 1
a500 2
	  printf ("%lu", (unsigned long) vma);
	  break;
d506 2
d511 1
a511 1
	  printf ("0x");
d516 1
a516 1
	  break;
d519 1
a519 1
	  printf ("0x");
d524 1
a524 1
	  printf ("%lx", vma);
d526 1
a526 4
	  if (_bfd_int64_high (vma))
	    printf ("%lx%8.8lx", _bfd_int64_high (vma), _bfd_int64_low (vma));
	  else
	    printf ("%lx", _bfd_int64_low (vma));
a527 1
	  break;
d531 1
a531 1
	  printf ("%ld", vma);
d533 1
a533 5
	  if (_bfd_int64_high (vma))
	    /* ugg */
	    printf ("++%ld", _bfd_int64_low (vma));
	  else
	    printf ("%ld", _bfd_int64_low (vma));
a534 1
	  break;
d539 1
a539 1
	    printf ("%5ld", vma);
d541 1
a541 1
	    printf ("%#lx", vma);
d543 2
a544 5
	  if (_bfd_int64_high (vma))
	    /* ugg */
	    printf ("++%ld", _bfd_int64_low (vma));
	  else if (vma <= 99999)
	    printf ("%5ld", _bfd_int64_low (vma));
d546 1
a546 1
	    printf ("%#lx", _bfd_int64_low (vma));
a547 1
	  break;
d551 1
a551 1
	  printf ("%lu", vma);
d553 1
a553 5
	  if (_bfd_int64_high (vma))
	    /* ugg */
	    printf ("++%lu", _bfd_int64_low (vma));
	  else
	    printf ("%lu", _bfd_int64_low (vma));
a554 1
	  break;
d558 1
d589 7
d602 1
a602 9
#ifndef BFD64
    case 8:
      /* Although we are extracing data from an 8 byte wide field,
	 we are returning only 4 bytes of data.  */
      return ((unsigned long) (field[7]))
	|   (((unsigned long) (field[6])) << 8)
	|   (((unsigned long) (field[5])) << 16)
	|   (((unsigned long) (field[4])) << 24);
#else
a603 5
    case -8:
      /* This is a special case, generated by the BYTE_GET8 macro.
	 It means that we are loading an 8 byte value from a field
	 in an external structure into an 8 byte value in a field
	 in an internal structure.  */
d815 3
a817 3
	  relas[i].r_offset = BYTE_GET8 (erelas[i].r_offset);
	  relas[i].r_info   = BYTE_GET8 (erelas[i].r_info);
	  relas[i].r_addend = BYTE_GET8 (erelas[i].r_addend);
d885 2
a886 2
	  rels[i].r_offset = BYTE_GET8 (erels[i].r_offset);
	  rels[i].r_info   = BYTE_GET8 (erels[i].r_info);
d3116 6
a3121 6
      internal->p_offset = BYTE_GET8 (external->p_offset);
      internal->p_vaddr  = BYTE_GET8 (external->p_vaddr);
      internal->p_paddr  = BYTE_GET8 (external->p_paddr);
      internal->p_filesz = BYTE_GET8 (external->p_filesz);
      internal->p_memsz  = BYTE_GET8 (external->p_memsz);
      internal->p_align  = BYTE_GET8 (external->p_align);
d3496 4
a3499 4
      internal->sh_flags     = BYTE_GET8 (shdrs[i].sh_flags);
      internal->sh_addr      = BYTE_GET8 (shdrs[i].sh_addr);
      internal->sh_size      = BYTE_GET8 (shdrs[i].sh_size);
      internal->sh_entsize   = BYTE_GET8 (shdrs[i].sh_entsize);
d3626 2
a3627 2
      psym->st_value = BYTE_GET8 (esyms[j].st_value);
      psym->st_size  = BYTE_GET8 (esyms[j].st_size);
d4418 1
a4418 1
      stamp = BYTE_GET8 ((unsigned char *) head);
d4498 3
a4500 3
	  tep->start.offset = BYTE_GET8 ((unsigned char *) tp +  0);
	  tep->end.offset   = BYTE_GET8 ((unsigned char *) tp +  8);
	  tep->info.offset  = BYTE_GET8 ((unsigned char *) tp + 16);
d4883 2
a4884 2
	  tep->start.offset = BYTE_GET8 ((unsigned char *) tp + 0);
	  tep->end.offset = BYTE_GET8 ((unsigned char *) tp + 8);
d5281 1
a5281 1
      if (BYTE_GET8 (ext->d_tag) == DT_NULL)
d5297 2
a5298 2
      entry->d_tag      = BYTE_GET8 (ext->d_tag);
      entry->d_un.d_val = BYTE_GET8 (ext->d_un.d_val);
d6438 2
a6439 2
static int *
get_dynamic_data (FILE *file, unsigned int number)
d6442 1
a6442 1
  int *i_data;
d6444 1
a6444 1
  e_data = malloc (number * 4);
d6452 1
a6452 1
  if (fread (e_data, 4, number, file) != number)
d6468 1
a6468 1
    i_data[number] = byte_get (e_data + number * 4, 4);
d6480 4
a6483 6
  unsigned char nb[4];
  unsigned char nc[4];
  int nbuckets = 0;
  int nchains = 0;
  int *buckets = NULL;
  int *chains = NULL;
d6491 10
d6511 1
a6511 1
      if (fread (nb, sizeof (nb), 1, file) != 1)
d6517 1
a6517 1
      if (fread (nc, sizeof (nc), 1, file) != 1)
d6523 2
a6524 2
      nbuckets = byte_get (nb, 4);
      nchains  = byte_get (nc, 4);
d6526 2
a6527 2
      buckets = get_dynamic_data (file, nbuckets);
      chains  = get_dynamic_data (file, nchains);
d6536 2
a6537 2
      int hn;
      int si;
d6553 1
d6557 4
a6560 1
	      printf ("  %3d %3d: ", si, hn);
d6562 1
a6562 1
	      putchar (' ' );
d6780 7
a6786 7
      int *lengths;
      int *counts;
      int hn;
      int si;
      int maxlength = 0;
      int nzero_counts = 0;
      int nsyms = 0;
d6788 2
a6789 2
      printf (_("\nHistogram for bucket list length (total of %d buckets):\n"),
	      nbuckets);
d6792 1
a6792 1
      lengths = calloc (nbuckets, sizeof (int));
a6799 3
	  if (! buckets[hn])
	    continue;

d6808 1
a6808 1
      counts = calloc (maxlength + 1, sizeof (int));
d6820 2
a6821 1
	  printf ("      0  %-10d (%5.1f%%)\n",
d6823 1
a6823 1
	  for (si = 1; si <= maxlength; ++si)
d6825 3
a6827 3
	      nzero_counts += counts[si] * si;
	      printf ("%7d  %-10d (%5.1f%%)    %5.1f%%\n",
		      si, counts[si], (counts[si] * 100.0) / nbuckets,
d11035 1
a11035 1
		      reginfo.ri_gp_value   = BYTE_GET8 (ereg->ri_gp_value);
d11656 3
a11658 3
      elf_header.e_entry     = BYTE_GET8 (ehdr64.e_entry);
      elf_header.e_phoff     = BYTE_GET8 (ehdr64.e_phoff);
      elf_header.e_shoff     = BYTE_GET8 (ehdr64.e_shoff);
@


1.276
log
@2005-02-10  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (group_count): Don't initialize it.
	(process_section_groups): Reurn 1 if we won't do unwind nor
	section groups. Set group_count to 0 before counting group
	sections and return 1 if there are no group sections. Reread
	SHT_SYMTAB/SHT_STRTAB sections only when needed. Don't skip
	section 0.
	(process_object): Only set do_unwind to 0 if
	process_section_groups return 0.
@
text
@d9493 4
a9496 1
		break;
a9529 2

	  fputs (_("  <End of list>\n"), stdout);
@


1.275
log
@	* readelf.c (eh_addr_size): New variable.
	(find_section): Move earlier in file.  Return empty sections too.
	(process_program_headers): Use find_section to find .dynamic.
	(process_section_headers): Initialize eh_addr_size.
	(dump_ia64_unwind, slurp_ia64_unwind_table, ia64_process_unwind)
	(dump_hppa_unwind, slurp_hppa_unwind_table, hppa_process_unwind)
	(display_debug_frames): Use it instead of local addr_size variable.
	(size_of_encoded_value): Get pointer size from eh_addr_size rather
	than is_32bit_elf.
@
text
@d188 1
a188 1
size_t group_count = 0;
d3959 7
d3970 1
a3970 1
	printf (_("\nThere are no section groups in this file.\n"));
d3991 1
d3998 8
d4014 4
d4025 1
a4025 1
	  char *group_name, *strtab, *start, *indices;
d4027 1
a4028 2
	  Elf_Internal_Shdr *symtab_sec, *strtab_sec, *sec;
	  Elf_Internal_Sym *symtab;
d4031 2
a4032 2
	  symtab_sec = SECTION_HEADER (section->sh_link);
	  if (symtab_sec->sh_type != SHT_SYMTAB)
d4037 8
a4044 1
	  symtab = GET_ELF_SYMBOLS (file, symtab_sec);
d4063 10
a4072 5
	      strtab_sec = SECTION_HEADER (symtab_sec->sh_link);
	      strtab = get_data (NULL, file, strtab_sec->sh_offset,
				 strtab_sec->sh_size,
				 _("string table"));

d4104 20
a4123 3
		  error (_("section [%5u] already in group section [%5u]\n"),
			 entry, section_headers_groups [SECTION_HEADER_INDEX (entry)]->group_index);
		  continue;
a4141 4
	  if (symtab)
	    free (symtab);
	  if (strtab)
	    free (strtab);
d4149 4
d11711 1
a11711 2
  if (! process_section_headers (file)
      || ! process_section_groups (file))
d11713 2
a11714 2
      /* Without loaded section headers and section groups we
	 cannot process lots of things.  */
d11721 6
@


1.274
log
@2005-01-10  H.J. Lu  <hongjiu.lu@@intel.com>

	BZ 635
	readelf.c (saved_base_address): Removed.
	(decode_64bit_range): Likewise.
	(decode_range): Likewise.
	(display_64bit_debug_ranges): Likewise.
	(debug_info): Add range_lists, num_range_lists and
	max_range_lists.
	(read_and_display_attr_value): Handle do_debug_ranges.
	(process_debug_info): Likewise.
	(display_debug_ranges): Rewrite.
	(process_object): Free range_lists.
@
text
@d173 1
d647 14
a3301 1
	      unsigned int j;
d3303 2
a3304 7
	      for (j = 0, sec = section_headers;
		   j < elf_header.e_shnum;
		   j++, sec++)
		if (streq (SECTION_NAME (sec), ".dynamic"))
		  break;

	      if (j == elf_header.e_shnum || sec->sh_size == 0)
d3728 20
a4332 1
  bfd_vma addr_size;
a4335 2
  addr_size = is_32bit_elf ? 4 : 8;

d4372 1
a4372 1
	      (unsigned long) (addr_size * UNW_LENGTH (stamp)));
d4381 1
a4381 1
      for (dp = head + 8; dp < head + 8 + addr_size * UNW_LENGTH (stamp);)
d4391 1
a4391 1
  unsigned long size, addr_size, nrelas, i;
a4399 2
  addr_size = is_32bit_elf ? 4 : 8;

d4430 3
a4432 2
  tep = aux->table = xmalloc (size / (3 * addr_size) * sizeof (aux->table[0]));
  for (tp = table; tp < table + size; tp += 3 * addr_size, ++tep)
d4488 1
a4488 1
	  i = rp->r_offset / (3 * addr_size);
d4490 1
a4490 1
	  switch (rp->r_offset/addr_size % 3)
d4512 1
a4512 1
  aux->table_len = size / (3 * addr_size);
d4520 1
a4520 1
  unsigned long i, addr_size, unwcount = 0, unwstart = 0;
a4524 2
  addr_size = is_32bit_elf ? 4 : 8;

d4628 1
a4628 1
		  (unsigned long) (unwsec->sh_size / (3 * addr_size)));
a4701 1
  bfd_vma addr_size;
a4703 1
  addr_size = is_32bit_elf ? 4 : 8;
d4770 1
a4770 1
  unsigned long size, unw_ent_size, addr_size, nrelas, i;
a4778 2
  addr_size = is_32bit_elf ? 4 : 8;

d4810 1
a4810 1
  unw_ent_size = 2 * addr_size + 8;
d4814 1
a4814 1
  for (tp = table; tp < table + size; tp += (2 * addr_size + 8), ++tep)
d4909 1
a4909 1
	  switch ((rp->r_offset % unw_ent_size) / addr_size)
a4938 1
  unsigned long addr_size;
a4943 1
  addr_size = is_32bit_elf ? 4 : 8;
d4973 1
a4973 1
		  (unsigned long) (sec->sh_size / (2 * addr_size + 8)));
a7069 20
/* Finds section NAME inside FILE and returns a
   pointer to it, or NULL upon failure.  */

static Elf_Internal_Shdr *
find_section (const char * name)
{
  Elf_Internal_Shdr *sec;
  unsigned int i;

  for (i = elf_header.e_shnum, sec = section_headers + i - 1;
       i; --i, --sec)
    if (streq (SECTION_NAME (sec), name))
      break;

  if (i && sec && sec->sh_size != 0)
    return sec;

  return NULL;
}

d9913 1
a9913 1
    case 0:	return is_32bit_elf ? 4 : 8;
a9946 1
  int addr_size = is_32bit_elf ? 4 : 8;
d9961 1
a9961 1
      int encoded_ptr_size = addr_size;
d10034 1
a10034 1
	      start += addr_size;
d10514 1
a10514 1
		  decode_location_expression (start, addr_size, ul, 0);
d10527 1
a10527 1
		  decode_location_expression (start, addr_size, ul, 0);
@


1.273
log
@2005-01-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (display_debug_loc): Display base address
	specifiers.  Always output <End of list>.
@
text
@a172 1
unsigned long saved_base_address;
a7896 114
/* Decode a DW_AT_ranges attribute for 64bit DWARF3 .  */

static void
decode_64bit_range (unsigned long offset, bfd_vma base_address)
{
  const char * start = debug_range_contents + offset;
  const char * end   = debug_range_contents + debug_range_size;

  do
    {
      bfd_vma a;
      bfd_vma b;

      a = byte_get ((unsigned char *) start, 8);
      b = byte_get ((unsigned char *) start + 8, 8);

      if (a == 0xffffffff)
	{
	  base_address = b;
	}
      else if (a == 0 && b == 0)
	break;
      else if (a > b)
	printf (_(" [corrupt: start > end]"));
      else
	{
	  printf (" ");
	  print_vma (base_address + a, PREFIX_HEX);
	  printf (" - ");
	  print_vma (base_address + b, PREFIX_HEX);
	  printf (", ");
	}

      start += 16;
    }
  while (start < end);
}

/* Decode a DW_AT_ranges attribute.  */

static void
decode_range (unsigned long offset, bfd_vma base_address)
{
  const char * start;
  const char * end;

  if (offset >= (debug_range_size - 8))
    {
      printf (_("[corrupt: offset is outside the .debug_ranges section]"));
      return;
    }

  /* Since all entries in the .debug_ranges section are pairs of either
     4-byte integers (32-bit DWARF3) or 8-byte integers (64-bit DWARF3)
     the offset should always be a multiple of 8 bytes.  */
  if (offset % 8)
    {
      printf (_("[corrupt: offset is not a multiple of 8]"));
      return;
    }  

  start = debug_range_contents + offset;

  if (offset > 0
      /* Be paranoid - check to see if the previous
	 two words were and end-of-range marker.  */
      && (byte_get ((unsigned char *) start - 4, 4) != 0
	  || byte_get ((unsigned char *) start - 8, 4) != 0))
    {
      printf (_("[corrupt: offset is not at the start of a range]"));
      return;
    }  

  end = debug_range_contents + debug_range_size;

  printf ("(");
  do
    {
      unsigned long a;
      unsigned long b;

      a = byte_get ((unsigned char *) start, 4);
      b = byte_get ((unsigned char *) start + 4, 4);

      if (a == 0xffffffff)
	{
	  if (b == 0xffffffff)
	    {
	      decode_64bit_range (offset, base_address);
	      return;
	    }

	  base_address = b;
	}
      else if (a == 0 && b == 0)
	break;
      else if (a > b)
	printf (_("[corrupt: start > end]"));
      else
	{
	  if (start > debug_range_contents + offset)
	    printf (", ");

	  printf (_("0x%lx - 0x%lx"),
		  (unsigned long) base_address + a,
		  (unsigned long) base_address + b);
	}

      start += 8;
    }
  while (start < end);
  printf (")");
}

d7909 3
d8045 1
a8045 1
      if ((do_loc || do_debug_loc)
d8114 1
a8114 1
  if ((do_loc || do_debug_loc)
d8158 20
a8357 9
    case DW_AT_low_pc:
      if (need_base_address)
	saved_base_address = uvalue;
      break;

    case DW_AT_ranges:
      decode_range (uvalue, saved_base_address);
      break;

d8514 1
a8514 1
  if ((do_loc || do_debug_loc)
d8610 1
a8610 1
      if ((do_loc || do_debug_loc)
d8621 3
a8715 1
	      saved_base_address = 0;
d8741 3
a8743 3
  /* Set num_debug_info_entries here so that it can be used
     to check if we need to proecess .debug_loc section.  */
  if ((do_loc || do_debug_loc)
d9656 3
a9658 1
display_64bit_debug_ranges (unsigned char * start, unsigned char * end)
d9660 22
a9681 1
  bfd_vma base_address = 0;
d9683 4
a9686 1
  while (start < end)
d9688 1
a9688 1
      bfd_vma a, b;
d9690 2
a9691 2
      a = byte_get (start, 8);
      b = byte_get (start + 8, 8);
d9693 2
a9694 1
      if (a == 0xffffffffffffffffLL)
d9696 21
a9716 21
	  printf (_(" set base address to "));
	  print_vma (b, PREFIX_HEX);
	  base_address = b;
	}
      else if (a == 0 && b == 0)
	printf ( _("end of range"));
      else if (a > b)
	printf (_(" <corrupt range entry, start is greater than end>"));
      else if (base_address == 0)
	{
	  printf ("range from base address + ");
	  print_vma (a, PREFIX_HEX);
	  printf (" to base address + ");
	  print_vma (b, PREFIX_HEX);
	}
      else
	{
	  printf ("range from ");
	  print_vma (base_address + a, PREFIX_HEX);
	  printf (" to ");
	  print_vma (base_address + b, PREFIX_HEX);
d9718 1
d9720 3
a9722 3
      start += 16;
      printf ("\n");
    }
d9724 2
a9725 2
  return 1;
}
d9727 3
a9729 7
static int
display_debug_ranges (Elf_Internal_Shdr *section,
		      unsigned char *start,
		      FILE *file ATTRIBUTE_UNUSED)
{
  unsigned long base_address = 0;
  unsigned char *end = start + section->sh_size;
d9731 2
a9732 1
  printf (_("The section %s contains:\n\n"), SECTION_NAME (section));
d9734 2
a9735 1
  while (start < end)
d9737 5
a9741 2
      unsigned long a;
      unsigned long b;
d9743 1
a9743 2
      a = byte_get (start, 4);
      b = byte_get (start + 4, 4);
d9745 1
a9745 1
      if (a == 0xffffffff)
d9747 47
a9793 9
	  /* Attempt to handle 64-bit DWARF3 format.  This assumes
	     that in a 32-bit DWARF3 file the base address will
	     never be 0xffffffff, and that the .debug_ranges section
	     will never contain a mixture of 32-bit and 64-bit entries.  */
	  if (b == 0xffffffff)
	    return display_64bit_debug_ranges (start, end);
      
	  printf (_(" set base address to 0x%lx\n"), b);
	  base_address = b;
a9794 10
      else if (a == 0 && b == 0)
	printf (_(" end of range\n"));
      else if (a > b)
	printf (_(" <corrupt range entry, start is greater than end>\n"));
      else if (base_address == 0)
	printf (_(" range from base address + 0x%lx to base address + 0x%lx\n"), a, b);
      else
	printf (_(" range from 0x%lx to 0x%lx\n"), base_address + a, base_address + b);

      start += 8;
d9796 1
a9796 1

d11764 9
a11772 5
	if (!debug_information [i].max_loc_offsets)
	  {
	    free (debug_information [i].loc_offsets);
	    free (debug_information [i].have_frame_base);
	  }
@


1.272
log
@2005-01-05  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (have_frame_base): New.
	(need_base_address): Likewise.
	(saved_base_address): Likewise.
	(decode_location_expression): Return 1 if DW_AT_frame_base is
	needed.
	(debug_info): Add base_address and a have_frame_base pointer.
	(read_and_display_attr_value): Replace saved_DW_AT_low_pc with
	saved_base_address. Record base address. Set have_frame_base.
	Record if a location list has DW_AT_frame_base. Display if a
	location expression has no DW_AT_frame_base but needs one. Set
	saved_base_address only if needed.
	(process_debug_info): Clear have_frame_base, saved_base_address
	and set need_base_address.
	(display_debug_loc): Display if a location expression has no
	DW_AT_frame_base but needs one. Display if start >= end. Don't
	adjust for section address. Properly handle base address.
	(process_object): Free the have_frame_base pointer in
	debug_info.
@
text
@d9553 2
d9582 1
a9582 3
	  if (j < debug_information [i].num_loc_offsets -1)
	    printf (_("  <End of list>"));
	  printf ("\n");
@


1.271
log
@2005-01-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (display_debug_loc): Display offsets for hole and
	overlap.
	(display_debug_str): Add a newline at the end.
@
text
@d171 3
d7557 1
a7557 1
static void
d7567 1
d7830 1
d7887 1
a7887 1
	  return;
d7894 2
d8018 1
d8021 1
a8042 1
  static unsigned long saved_DW_AT_low_pc = 0;
d8232 1
d8254 3
d8260 1
d8264 5
d8422 1
d8434 2
d8437 4
a8440 1
	  decode_location_expression (block_start, pointer_size, uvalue, cu_offset);
d8442 2
d8451 2
a8452 5
      /* This is a hack.  We keep track of the DW_AT_low_pc attributes
	 and use them when decoding DW_AT_ranges attributes.  The
	 assumption here is that we are decoding the attributes in order
	 and so the correct base address for the range is the low_pc.  */
      saved_DW_AT_low_pc = uvalue;
d8456 1
a8456 1
      decode_range (uvalue, saved_DW_AT_low_pc);
d8717 1
d8719 1
d8807 18
a9431 1
  bfd_vma addr;
a9440 1
  addr = section->sh_addr;
d9512 3
d9521 1
d9524 1
d9549 6
a9554 6
	      /* For now, skip any base address specifiers.  */
	      if (begin == 0xffffffff)
		continue;

	      begin += addr;
	      end += addr;
d9560 16
a9575 8
		      offset, begin, end);
	      decode_location_expression (start, pointer_size, length,
					  cu_offset);
	      printf (")\n");

	      if (begin >= end)
		warn ("Bad location list at %8.8lx from %8.8lx to %8.8lx\n",
		      offset, begin, end);
d11807 5
a11811 2
	if (debug_information [i].loc_offsets != NULL)
	  free (debug_information [i].loc_offsets);
@


1.270
log
@BZ 615
* readelf.c (process_debug_info): New.
(debug_info): Add num_loc_offsets, loc_offsets and
last_loc_offset_p.
(get_debug_info): Use process_debug_info.
(display_debug_loc): Properly handle location list. Warn if bad
location lists are encoutnered.
(read_and_process_attr_value): New.
(read_and_display_attr_value): Use "%lx" for DW_FORM_data4.
(display_debug_info): Use process_debug_info.
(process_object): Also free loc_offsets in debug_information.
@
text
@d9486 1
a9486 1
		      start, next);
d9489 1
a9489 1
		      start, next);
d9590 2
@


1.269
log
@2004-12-27  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (read_leb128): Support 64bit host.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004
d7071 5
a7075 4
/* This could just be an array of unsigned integers, but I expect
   that we will want to extend the structure to contain other
   information.  */
typedef struct
d7077 15
a7091 1
  unsigned int pointer_size;
a7092 1
debug_info;
d7094 10
a7103 4
static debug_info *   debug_information = NULL;
static unsigned int   num_debug_info_entries = 0;
static unsigned int   last_pointer_size = 0;
static int            warned_about_missing_comp_units = FALSE;
d7105 2
a7106 3
static unsigned int
get_pointer_size_of_comp_unit (unsigned int comp_unit,
			       const char * section_name)
d7108 2
a7109 6
  if (num_debug_info_entries == 0)
    {
      error (_("%s section needs a populated .debug_info section\n"),
	     section_name);
      return 0;
    }
d7111 2
a7112 15
  if (comp_unit >= num_debug_info_entries)
    {
      if (!warned_about_missing_comp_units)
	{
	  warn (_("%s section has more comp units than .debug_info section\n"),
		section_name);
	  warn (_("assuming that the pointer size is %d, from the last comp unit in .debug_info\n\n"),
		last_pointer_size);
	  warned_about_missing_comp_units = TRUE;
	}
    }
  else
    last_pointer_size = debug_information [comp_unit].pointer_size;

  return last_pointer_size;
d7114 1
d7117 2
a7118 5
/* Locate and scan the .debug_info section in the file and record the pointer
   sizes for the compilation units in it.  Usually an executable will have
   just one pointer size, but this is not guaranteed, and so we try not to
   make any assumptions.  Returns zero upon failure, or the number of
   compilation units upon success.  */
d7120 2
a7121 2
static unsigned int
get_debug_info (FILE * file)
d7123 1
a7123 13
  Elf_Internal_Shdr * section;
  unsigned char *     start;
  unsigned char *     end;
  unsigned char *     begin;
  unsigned long       length;
  unsigned int        num_units;
  unsigned int        unit;

  /* Reset the last pointer size so that we can issue correct
     error messages if we are displaying the contents of more
     than one file.  */
  last_pointer_size = 0;
  warned_about_missing_comp_units = FALSE;
d7125 3
a7127 3
  /* If we already have the information there is nothing else to do.  */
  if (num_debug_info_entries > 0)
    return num_debug_info_entries;
d7129 4
a7132 3
  section = find_section (".debug_info");
  if (section == NULL)
    return 0;
d7134 1
a7134 5
  length = section->sh_size;
  start = get_data (NULL, file, section->sh_offset, section->sh_size,
		    _("extracting information from .debug_info section"));
  if (start == NULL)
    return 0;
d7136 3
a7138 8
  end = start + section->sh_size;
  /* First scan the section to get the number of comp units.  */
  for (begin = start, num_units = 0; begin < end; num_units++)
    {
      /* Read the first 4 bytes.  For a 32-bit DWARF section, this will
	 be the length.  For a 64-bit DWARF section, it'll be the escape
	 code 0xffffffff followed by an 8 byte length.  */
      length = byte_get (begin, 4);
d7140 5
a7144 8
      if (length == 0xffffffff)
	{
	  length = byte_get (begin + 4, 8);
	  begin += length + 12;
	}
      else
	begin += length + 4;
    }
d7146 4
a7149 6
  if (num_units == 0)
    {
      error (_("No comp units in .debug_info section ?"));
      free (start);
      return 0;
    }
d7151 2
a7152 9
  /* Then allocate an array to hold the information.  */
  debug_information = malloc (num_units * sizeof * debug_information);
  if (debug_information == NULL)
    {
      error (_("Not enough memory for a debug info array of %u entries"),
	     num_units);
      free (start);
      return 0;
    }
d7154 4
a7157 8
  /* Populate the array.  */
  for (begin = start, unit = 0; begin < end; unit++)
    {
      length = byte_get (begin, 4);
      if (length == 0xffffffff)
	{
	  /* For 64-bit DWARF, the 1-byte address_size field is 22 bytes
	     from the start of the section.  This is computed as follows:
d7159 3
a7161 5
	     unit_length:         12 bytes
	     version:              2 bytes
	     debug_abbrev_offset:  8 bytes
	     -----------------------------
	     Total:               22 bytes  */
d7163 4
a7166 8
	  debug_information [unit].pointer_size = byte_get (begin + 22, 1);
	  length = byte_get (begin + 4, 8);
	  begin += length + 12;
	}
      else
	{
	  /* For 32-bit DWARF, the 1-byte address_size field is 10 bytes from
	     the start of the section:
d7168 1
a7168 5
	     unit_length:          4 bytes
	     version:              2 bytes
	     debug_abbrev_offset:  4 bytes
	     -----------------------------
	     Total:               10 bytes  */
d7170 3
a7172 4
	  debug_information [unit].pointer_size = byte_get (begin + 10, 1);
	  begin += length + 4;
	}
    }
d7174 5
a7178 1
  free (start);
d7180 3
a7182 1
  return num_debug_info_entries = num_units;
d7185 2
d7188 6
a7193 2
display_debug_lines (Elf_Internal_Shdr *section,
		     unsigned char *start, FILE *file)
d7195 1
a7195 3
  unsigned char *data = start;
  unsigned char *end = start + section->sh_size;
  unsigned int comp_unit = 0;
d7197 2
a7198 2
  printf (_("\nDump of debug contents of section %s:\n\n"),
	  SECTION_NAME (section));
d7200 3
a7202 3
  get_debug_info (file);

  while (data < end)
d7204 5
a7208 8
      DWARF2_Internal_LineInfo info;
      unsigned char *standard_opcodes;
      unsigned char *end_of_sequence;
      unsigned char *hdrptr;
      unsigned int pointer_size;
      int initial_length_size;
      int offset_size;
      int i;
d7210 4
a7213 1
      hdrptr = data;
d7215 3
a7217 3
      /* Check the length of the block.  */
      info.li_length = byte_get (hdrptr, 4);
      hdrptr += 4;
d7219 2
a7220 13
      if (info.li_length == 0xffffffff)
	{
	  /* This section is 64-bit DWARF 3.  */
	  info.li_length = byte_get (hdrptr, 8);
	  hdrptr += 8;
	  offset_size = 8;
	  initial_length_size = 12;
	}
      else
	{
	  offset_size = 4;
	  initial_length_size = 4;
	}
d7222 1
a7222 1
      if (info.li_length + initial_length_size > section->sh_size)
d7224 1
a7224 4
	  warn
	    (_("The line info appears to be corrupt - the section is too small\n"));
	  return 0;
	}
d7226 5
a7230 8
      /* Check its version number.  */
      info.li_version = byte_get (hdrptr, 2);
      hdrptr += 2;
      if (info.li_version != 2 && info.li_version != 3)
	{
	  warn (_("Only DWARF version 2 and 3 line info is currently supported.\n"));
	  return 0;
	}
d7232 3
a7234 12
      info.li_prologue_length = byte_get (hdrptr, offset_size);
      hdrptr += offset_size;
      info.li_min_insn_length = byte_get (hdrptr, 1);
      hdrptr++;
      info.li_default_is_stmt = byte_get (hdrptr, 1);
      hdrptr++;
      info.li_line_base = byte_get (hdrptr, 1);
      hdrptr++;
      info.li_line_range = byte_get (hdrptr, 1);
      hdrptr++;
      info.li_opcode_base = byte_get (hdrptr, 1);
      hdrptr++;
d7236 16
a7251 3
      /* Sign extend the line base field.  */
      info.li_line_base <<= 24;
      info.li_line_base >>= 24;
d7253 10
a7262 5
      /* Get the pointer size from the comp unit associated
	 with this block of line number information.  */
      pointer_size = get_pointer_size_of_comp_unit (comp_unit,
						    ".debug_lines");
      comp_unit ++;
d7264 2
a7265 9
      printf (_("  Length:                      %ld\n"), info.li_length);
      printf (_("  DWARF Version:               %d\n"), info.li_version);
      printf (_("  Prologue Length:             %d\n"), info.li_prologue_length);
      printf (_("  Minimum Instruction Length:  %d\n"), info.li_min_insn_length);
      printf (_("  Initial value of 'is_stmt':  %d\n"), info.li_default_is_stmt);
      printf (_("  Line Base:                   %d\n"), info.li_line_base);
      printf (_("  Line Range:                  %d\n"), info.li_line_range);
      printf (_("  Opcode Base:                 %d\n"), info.li_opcode_base);
      printf (_("  (Pointer size:               %u)\n"), pointer_size);
d7267 6
a7272 1
      end_of_sequence = data + info.li_length + initial_length_size;
d7274 10
a7283 1
      reset_state_machine (info.li_default_is_stmt);
d7285 10
a7294 2
      /* Display the contents of the Opcodes table.  */
      standard_opcodes = hdrptr;
d7296 2
a7297 1
      printf (_("\n Opcodes:\n"));
d7299 4
a7302 2
      for (i = 1; i < info.li_opcode_base; i++)
	printf (_("  Opcode %d has %d args\n"), i, standard_opcodes[i - 1]);
d7304 4
a7307 2
      /* Display the contents of the Directory table.  */
      data = standard_opcodes + info.li_opcode_base - 1;
d7309 1
a7309 3
      if (*data == 0)
	printf (_("\n The Directory Table is empty.\n"));
      else
d7311 1
a7311 1
	  printf (_("\n The Directory Table:\n"));
d7313 3
a7315 3
	  while (*data != 0)
	    {
	      printf (_("  %s\n"), data);
d7317 3
a7319 3
	      data += strlen ((char *) data) + 1;
	    }
	}
d7321 2
a7322 2
      /* Skip the NUL at the end of the table.  */
      data++;
d7324 4
a7327 7
      /* Display the contents of the File Name table.  */
      if (*data == 0)
	printf (_("\n The File Name Table is empty.\n"));
      else
	{
	  printf (_("\n The File Name Table:\n"));
	  printf (_("  Entry\tDir\tTime\tSize\tName\n"));
d7329 1
a7329 4
	  while (*data != 0)
	    {
	      unsigned char *name;
	      int bytes_read;
d7331 3
a7333 2
	      printf (_("  %d\t"), ++state_machine_regs.last_file_entry);
	      name = data;
d7335 6
a7340 1
	      data += strlen ((char *) data) + 1;
d7342 4
a7345 9
	      printf (_("%lu\t"), read_leb128 (data, & bytes_read, 0));
	      data += bytes_read;
	      printf (_("%lu\t"), read_leb128 (data, & bytes_read, 0));
	      data += bytes_read;
	      printf (_("%lu\t"), read_leb128 (data, & bytes_read, 0));
	      data += bytes_read;
	      printf (_("%s\n"), name);
	    }
	}
d7347 2
a7348 2
      /* Skip the NUL at the end of the table.  */
      data++;
d7350 4
a7353 2
      /* Now display the statements.  */
      printf (_("\n Line Number Statements:\n"));
d7355 1
a7355 5
      while (data < end_of_sequence)
	{
	  unsigned char op_code;
	  int adv;
	  int bytes_read;
d7357 3
a7359 1
	  op_code = *data++;
d7361 3
a7363 18
	  if (op_code >= info.li_opcode_base)
	    {
	      op_code -= info.li_opcode_base;
	      adv      = (op_code / info.li_line_range) * info.li_min_insn_length;
	      state_machine_regs.address += adv;
	      printf (_("  Special opcode %d: advance Address by %d to 0x%lx"),
		      op_code, adv, state_machine_regs.address);
	      adv = (op_code % info.li_line_range) + info.li_line_base;
	      state_machine_regs.line += adv;
	      printf (_(" and Line by %d to %d\n"),
		      adv, state_machine_regs.line);
	    }
	  else switch (op_code)
	    {
	    case DW_LNS_extended_op:
	      data += process_extended_line_op (data, info.li_default_is_stmt,
						pointer_size);
	      break;
d7365 4
a7368 3
	    case DW_LNS_copy:
	      printf (_("  Copy\n"));
	      break;
d7370 2
a7371 7
	    case DW_LNS_advance_pc:
	      adv = info.li_min_insn_length * read_leb128 (data, & bytes_read, 0);
	      data += bytes_read;
	      state_machine_regs.address += adv;
	      printf (_("  Advance PC by %d to %lx\n"), adv,
		      state_machine_regs.address);
	      break;
d7373 4
a7376 7
	    case DW_LNS_advance_line:
	      adv = read_leb128 (data, & bytes_read, 1);
	      data += bytes_read;
	      state_machine_regs.line += adv;
	      printf (_("  Advance Line by %d to %d\n"), adv,
		      state_machine_regs.line);
	      break;
d7378 5
a7382 7
	    case DW_LNS_set_file:
	      adv = read_leb128 (data, & bytes_read, 0);
	      data += bytes_read;
	      printf (_("  Set File Name to entry %d in the File Name Table\n"),
		      adv);
	      state_machine_regs.file = adv;
	      break;
d7384 7
a7390 6
	    case DW_LNS_set_column:
	      adv = read_leb128 (data, & bytes_read, 0);
	      data += bytes_read;
	      printf (_("  Set column to %d\n"), adv);
	      state_machine_regs.column = adv;
	      break;
d7392 2
a7393 6
	    case DW_LNS_negate_stmt:
	      adv = state_machine_regs.is_stmt;
	      adv = ! adv;
	      printf (_("  Set is_stmt to %d\n"), adv);
	      state_machine_regs.is_stmt = adv;
	      break;
d7395 5
a7399 4
	    case DW_LNS_set_basic_block:
	      printf (_("  Set basic block\n"));
	      state_machine_regs.basic_block = 1;
	      break;
d7401 2
a7402 7
	    case DW_LNS_const_add_pc:
	      adv = (((255 - info.li_opcode_base) / info.li_line_range)
		     * info.li_min_insn_length);
	      state_machine_regs.address += adv;
	      printf (_("  Advance PC by constant %d to 0x%lx\n"), adv,
		      state_machine_regs.address);
	      break;
d7404 1
a7404 7
	    case DW_LNS_fixed_advance_pc:
	      adv = byte_get (data, 2);
	      data += 2;
	      state_machine_regs.address += adv;
	      printf (_("  Advance PC by fixed size amount %d to 0x%lx\n"),
		      adv, state_machine_regs.address);
	      break;
d7406 1
a7406 3
	    case DW_LNS_set_prologue_end:
	      printf (_("  Set prologue_end to true\n"));
	      break;
d7408 1
a7408 52
	    case DW_LNS_set_epilogue_begin:
	      printf (_("  Set epilogue_begin to true\n"));
	      break;

	    case DW_LNS_set_isa:
	      adv = read_leb128 (data, & bytes_read, 0);
	      data += bytes_read;
	      printf (_("  Set ISA to %d\n"), adv);
	      break;

	    default:
	      printf (_("  Unknown opcode %d with operands: "), op_code);

	      for (i = standard_opcodes[op_code - 1]; i > 0 ; --i)
		{
		  printf ("0x%lx%s", read_leb128 (data, &bytes_read, 0),
			  i == 1 ? "" : ", ");
		  data += bytes_read;
		}
	      putchar ('\n');
	      break;
	    }
	}
      putchar ('\n');
    }

  return 1;
}

static int
display_debug_pubnames (Elf_Internal_Shdr *section,
			unsigned char *start,
			FILE *file ATTRIBUTE_UNUSED)
{
  DWARF2_Internal_PubNames pubnames;
  unsigned char *end;

  end = start + section->sh_size;

  printf (_("Contents of the %s section:\n\n"), SECTION_NAME (section));

  while (start < end)
    {
      unsigned char *data;
      unsigned long offset;
      int offset_size, initial_length_size;

      data = start;

      pubnames.pn_length = byte_get (data, 4);
      data += 4;
      if (pubnames.pn_length == 0xffffffff)
d7410 1
a7410 10
	  pubnames.pn_length = byte_get (data, 8);
	  data += 8;
	  offset_size = 8;
	  initial_length_size = 12;
	}
      else
	{
	  offset_size = 4;
	  initial_length_size = 4;
	}
d7412 2
a7413 6
      pubnames.pn_version = byte_get (data, 2);
      data += 2;
      pubnames.pn_offset = byte_get (data, offset_size);
      data += offset_size;
      pubnames.pn_size = byte_get (data, offset_size);
      data += offset_size;
d7415 2
a7416 1
      start += pubnames.pn_length + initial_length_size;
d7418 2
a7419 11
      if (pubnames.pn_version != 2 && pubnames.pn_version != 3)
	{
	  static int warned = 0;

	  if (! warned)
	    {
	      warn (_("Only DWARF 2 and 3 pubnames are currently supported\n"));
	      warned = 1;
	    }

	  continue;
d7421 1
a7421 24

      printf (_("  Length:                              %ld\n"),
	      pubnames.pn_length);
      printf (_("  Version:                             %d\n"),
	      pubnames.pn_version);
      printf (_("  Offset into .debug_info section:     %ld\n"),
	      pubnames.pn_offset);
      printf (_("  Size of area in .debug_info section: %ld\n"),
	      pubnames.pn_size);

      printf (_("\n    Offset\tName\n"));

      do
	{
	  offset = byte_get (data, offset_size);

	  if (offset != 0)
	    {
	      data += offset_size;
	      printf ("    %-6ld\t\t%s\n", offset, data);
	      data += strlen ((char *) data) + 1;
	    }
	}
      while (offset != 0);
d7424 1
a7424 2
  printf ("\n");
  return 1;
a7507 113
get_AT_name (unsigned long attribute)
{
  switch (attribute)
    {
    case DW_AT_sibling:			return "DW_AT_sibling";
    case DW_AT_location:		return "DW_AT_location";
    case DW_AT_name:			return "DW_AT_name";
    case DW_AT_ordering:		return "DW_AT_ordering";
    case DW_AT_subscr_data:		return "DW_AT_subscr_data";
    case DW_AT_byte_size:		return "DW_AT_byte_size";
    case DW_AT_bit_offset:		return "DW_AT_bit_offset";
    case DW_AT_bit_size:		return "DW_AT_bit_size";
    case DW_AT_element_list:		return "DW_AT_element_list";
    case DW_AT_stmt_list:		return "DW_AT_stmt_list";
    case DW_AT_low_pc:			return "DW_AT_low_pc";
    case DW_AT_high_pc:			return "DW_AT_high_pc";
    case DW_AT_language:		return "DW_AT_language";
    case DW_AT_member:			return "DW_AT_member";
    case DW_AT_discr:			return "DW_AT_discr";
    case DW_AT_discr_value:		return "DW_AT_discr_value";
    case DW_AT_visibility:		return "DW_AT_visibility";
    case DW_AT_import:			return "DW_AT_import";
    case DW_AT_string_length:		return "DW_AT_string_length";
    case DW_AT_common_reference:	return "DW_AT_common_reference";
    case DW_AT_comp_dir:		return "DW_AT_comp_dir";
    case DW_AT_const_value:		return "DW_AT_const_value";
    case DW_AT_containing_type:		return "DW_AT_containing_type";
    case DW_AT_default_value:		return "DW_AT_default_value";
    case DW_AT_inline:			return "DW_AT_inline";
    case DW_AT_is_optional:		return "DW_AT_is_optional";
    case DW_AT_lower_bound:		return "DW_AT_lower_bound";
    case DW_AT_producer:		return "DW_AT_producer";
    case DW_AT_prototyped:		return "DW_AT_prototyped";
    case DW_AT_return_addr:		return "DW_AT_return_addr";
    case DW_AT_start_scope:		return "DW_AT_start_scope";
    case DW_AT_stride_size:		return "DW_AT_stride_size";
    case DW_AT_upper_bound:		return "DW_AT_upper_bound";
    case DW_AT_abstract_origin:		return "DW_AT_abstract_origin";
    case DW_AT_accessibility:		return "DW_AT_accessibility";
    case DW_AT_address_class:		return "DW_AT_address_class";
    case DW_AT_artificial:		return "DW_AT_artificial";
    case DW_AT_base_types:		return "DW_AT_base_types";
    case DW_AT_calling_convention:	return "DW_AT_calling_convention";
    case DW_AT_count:			return "DW_AT_count";
    case DW_AT_data_member_location:	return "DW_AT_data_member_location";
    case DW_AT_decl_column:		return "DW_AT_decl_column";
    case DW_AT_decl_file:		return "DW_AT_decl_file";
    case DW_AT_decl_line:		return "DW_AT_decl_line";
    case DW_AT_declaration:		return "DW_AT_declaration";
    case DW_AT_discr_list:		return "DW_AT_discr_list";
    case DW_AT_encoding:		return "DW_AT_encoding";
    case DW_AT_external:		return "DW_AT_external";
    case DW_AT_frame_base:		return "DW_AT_frame_base";
    case DW_AT_friend:			return "DW_AT_friend";
    case DW_AT_identifier_case:		return "DW_AT_identifier_case";
    case DW_AT_macro_info:		return "DW_AT_macro_info";
    case DW_AT_namelist_items:		return "DW_AT_namelist_items";
    case DW_AT_priority:		return "DW_AT_priority";
    case DW_AT_segment:			return "DW_AT_segment";
    case DW_AT_specification:		return "DW_AT_specification";
    case DW_AT_static_link:		return "DW_AT_static_link";
    case DW_AT_type:			return "DW_AT_type";
    case DW_AT_use_location:		return "DW_AT_use_location";
    case DW_AT_variable_parameter:	return "DW_AT_variable_parameter";
    case DW_AT_virtuality:		return "DW_AT_virtuality";
    case DW_AT_vtable_elem_location:	return "DW_AT_vtable_elem_location";
      /* DWARF 2.1 values.  */
    case DW_AT_allocated:		return "DW_AT_allocated";
    case DW_AT_associated:		return "DW_AT_associated";
    case DW_AT_data_location:		return "DW_AT_data_location";
    case DW_AT_stride:			return "DW_AT_stride";
    case DW_AT_entry_pc:		return "DW_AT_entry_pc";
    case DW_AT_use_UTF8:		return "DW_AT_use_UTF8";
    case DW_AT_extension:		return "DW_AT_extension";
    case DW_AT_ranges:			return "DW_AT_ranges";
    case DW_AT_trampoline:		return "DW_AT_trampoline";
    case DW_AT_call_column:		return "DW_AT_call_column";
    case DW_AT_call_file:		return "DW_AT_call_file";
    case DW_AT_call_line:		return "DW_AT_call_line";
      /* SGI/MIPS extensions.  */
    case DW_AT_MIPS_fde:		return "DW_AT_MIPS_fde";
    case DW_AT_MIPS_loop_begin:		return "DW_AT_MIPS_loop_begin";
    case DW_AT_MIPS_tail_loop_begin:	return "DW_AT_MIPS_tail_loop_begin";
    case DW_AT_MIPS_epilog_begin:	return "DW_AT_MIPS_epilog_begin";
    case DW_AT_MIPS_loop_unroll_factor: return "DW_AT_MIPS_loop_unroll_factor";
    case DW_AT_MIPS_software_pipeline_depth:
      return "DW_AT_MIPS_software_pipeline_depth";
    case DW_AT_MIPS_linkage_name:	return "DW_AT_MIPS_linkage_name";
    case DW_AT_MIPS_stride:		return "DW_AT_MIPS_stride";
    case DW_AT_MIPS_abstract_name:	return "DW_AT_MIPS_abstract_name";
    case DW_AT_MIPS_clone_origin:	return "DW_AT_MIPS_clone_origin";
    case DW_AT_MIPS_has_inlines:	return "DW_AT_MIPS_has_inlines";
      /* GNU extensions.  */
    case DW_AT_sf_names:		return "DW_AT_sf_names";
    case DW_AT_src_info:		return "DW_AT_src_info";
    case DW_AT_mac_info:		return "DW_AT_mac_info";
    case DW_AT_src_coords:		return "DW_AT_src_coords";
    case DW_AT_body_begin:		return "DW_AT_body_begin";
    case DW_AT_body_end:		return "DW_AT_body_end";
    case DW_AT_GNU_vector:		return "DW_AT_GNU_vector";
      /* UPC extension.  */
    case DW_AT_upc_threads_scaled:	return "DW_AT_upc_threads_scaled";
    default:
      {
	static char buffer[100];

	sprintf (buffer, _("Unknown AT value: %lx"), attribute);
	return buffer;
      }
    }
}

static char *
d7543 2
a7544 4
/* FIXME:  There are better and more efficient ways to handle
   these structures.  For now though, I just want something that
   is simple to implement.  */
typedef struct abbrev_attr
d7546 4
a7549 5
  unsigned long attribute;
  unsigned long form;
  struct abbrev_attr *next;
}
abbrev_attr;
d7551 1
a7551 8
typedef struct abbrev_entry
{
  unsigned long entry;
  unsigned long tag;
  int children;
  struct abbrev_attr *first_attr;
  struct abbrev_attr *last_attr;
  struct abbrev_entry *next;
a7552 4
abbrev_entry;

static abbrev_entry *first_abbrev = NULL;
static abbrev_entry *last_abbrev = NULL;
d7555 4
a7558 1
free_abbrevs (void)
d7560 4
a7563 1
  abbrev_entry *abbrev;
d7565 1
a7565 1
  for (abbrev = first_abbrev; abbrev;)
d7567 1
a7567 141
      abbrev_entry *next = abbrev->next;
      abbrev_attr *attr;

      for (attr = abbrev->first_attr; attr;)
	{
	  abbrev_attr *next = attr->next;

	  free (attr);
	  attr = next;
	}

      free (abbrev);
      abbrev = next;
    }

  last_abbrev = first_abbrev = NULL;
}

static void
add_abbrev (unsigned long number, unsigned long tag, int children)
{
  abbrev_entry *entry;

  entry = malloc (sizeof (*entry));

  if (entry == NULL)
    /* ugg */
    return;

  entry->entry      = number;
  entry->tag        = tag;
  entry->children   = children;
  entry->first_attr = NULL;
  entry->last_attr  = NULL;
  entry->next       = NULL;

  if (first_abbrev == NULL)
    first_abbrev = entry;
  else
    last_abbrev->next = entry;

  last_abbrev = entry;
}

static void
add_abbrev_attr (unsigned long attribute, unsigned long form)
{
  abbrev_attr *attr;

  attr = malloc (sizeof (*attr));

  if (attr == NULL)
    /* ugg */
    return;

  attr->attribute = attribute;
  attr->form      = form;
  attr->next      = NULL;

  if (last_abbrev->first_attr == NULL)
    last_abbrev->first_attr = attr;
  else
    last_abbrev->last_attr->next = attr;

  last_abbrev->last_attr = attr;
}

/* Processes the (partial) contents of a .debug_abbrev section.
   Returns NULL if the end of the section was encountered.
   Returns the address after the last byte read if the end of
   an abbreviation set was found.  */

static unsigned char *
process_abbrev_section (unsigned char *start, unsigned char *end)
{
  if (first_abbrev != NULL)
    return NULL;

  while (start < end)
    {
      int bytes_read;
      unsigned long entry;
      unsigned long tag;
      unsigned long attribute;
      int children;

      entry = read_leb128 (start, & bytes_read, 0);
      start += bytes_read;

      /* A single zero is supposed to end the section according
	 to the standard.  If there's more, then signal that to
	 the caller.  */
      if (entry == 0)
	return start == end ? NULL : start;

      tag = read_leb128 (start, & bytes_read, 0);
      start += bytes_read;

      children = *start++;

      add_abbrev (entry, tag, children);

      do
	{
	  unsigned long form;

	  attribute = read_leb128 (start, & bytes_read, 0);
	  start += bytes_read;

	  form = read_leb128 (start, & bytes_read, 0);
	  start += bytes_read;

	  if (attribute != 0)
	    add_abbrev_attr (attribute, form);
	}
      while (attribute != 0);
    }

  return NULL;
}


static int
display_debug_macinfo (Elf_Internal_Shdr *section,
		       unsigned char *start,
		       FILE *file ATTRIBUTE_UNUSED)
{
  unsigned char *end = start + section->sh_size;
  unsigned char *curr = start;
  unsigned int bytes_read;
  enum dwarf_macinfo_record_type op;

  printf (_("Contents of the %s section:\n\n"), SECTION_NAME (section));

  while (curr < end)
    {
      unsigned int lineno;
      const char *string;

      op = *curr;
      curr++;
d7571 25
a7595 12
	case DW_MACINFO_start_file:
	  {
	    unsigned int filenum;

	    lineno = read_leb128 (curr, & bytes_read, 0);
	    curr += bytes_read;
	    filenum = read_leb128 (curr, & bytes_read, 0);
	    curr += bytes_read;

	    printf (_(" DW_MACINFO_start_file - lineno: %d filenum: %d\n"),
		    lineno, filenum);
	  }
d7597 3
a7599 3

	case DW_MACINFO_end_file:
	  printf (_(" DW_MACINFO_end_file\n"));
d7601 4
a7604 8

	case DW_MACINFO_define:
	  lineno = read_leb128 (curr, & bytes_read, 0);
	  curr += bytes_read;
	  string = curr;
	  curr += strlen (string) + 1;
	  printf (_(" DW_MACINFO_define - lineno : %d macro : %s\n"),
		  lineno, string);
d7606 4
a7609 8

	case DW_MACINFO_undef:
	  lineno = read_leb128 (curr, & bytes_read, 0);
	  curr += bytes_read;
	  string = curr;
	  curr += strlen (string) + 1;
	  printf (_(" DW_MACINFO_undef - lineno : %d macro : %s\n"),
		  lineno, string);
d7611 3
a7613 12

	case DW_MACINFO_vendor_ext:
	  {
	    unsigned int constant;

	    constant = read_leb128 (curr, & bytes_read, 0);
	    curr += bytes_read;
	    string = curr;
	    curr += strlen (string) + 1;
	    printf (_(" DW_MACINFO_vendor_ext - constant : %d string : %s\n"),
		    constant, string);
	  }
d7615 2
a7616 124
	}
    }

  return 1;
}


static int
display_debug_abbrev (Elf_Internal_Shdr *section,
		      unsigned char *start,
		      FILE *file ATTRIBUTE_UNUSED)
{
  abbrev_entry *entry;
  unsigned char *end = start + section->sh_size;

  printf (_("Contents of the %s section:\n\n"), SECTION_NAME (section));

  do
    {
      start = process_abbrev_section (start, end);

      if (first_abbrev == NULL)
	continue;

      printf (_("  Number TAG\n"));

      for (entry = first_abbrev; entry; entry = entry->next)
	{
	  abbrev_attr *attr;

	  printf (_("   %ld      %s    [%s]\n"),
		  entry->entry,
		  get_TAG_name (entry->tag),
		  entry->children ? _("has children") : _("no children"));

	  for (attr = entry->first_attr; attr; attr = attr->next)
	    printf (_("    %-18s %s\n"),
		    get_AT_name (attr->attribute),
		    get_FORM_name (attr->form));
	}

      free_abbrevs ();
    }
  while (start);

  printf ("\n");

  return 1;
}


static unsigned char *
display_block (unsigned char *data, unsigned long length)
{
  printf (_(" %lu byte block: "), length);

  while (length --)
    printf ("%lx ", (unsigned long) byte_get (data++, 1));

  return data;
}

static void
decode_location_expression (unsigned char * data,
			    unsigned int pointer_size,
			    unsigned long length)
{
  unsigned op;
  int bytes_read;
  unsigned long uvalue;
  unsigned char *end = data + length;

  while (data < end)
    {
      op = *data++;

      switch (op)
	{
	case DW_OP_addr:
	  printf ("DW_OP_addr: %lx",
		  (unsigned long) byte_get (data, pointer_size));
	  data += pointer_size;
	  break;
	case DW_OP_deref:
	  printf ("DW_OP_deref");
	  break;
	case DW_OP_const1u:
	  printf ("DW_OP_const1u: %lu", (unsigned long) byte_get (data++, 1));
	  break;
	case DW_OP_const1s:
	  printf ("DW_OP_const1s: %ld", (long) byte_get_signed (data++, 1));
	  break;
	case DW_OP_const2u:
	  printf ("DW_OP_const2u: %lu", (unsigned long) byte_get (data, 2));
	  data += 2;
	  break;
	case DW_OP_const2s:
	  printf ("DW_OP_const2s: %ld", (long) byte_get_signed (data, 2));
	  data += 2;
	  break;
	case DW_OP_const4u:
	  printf ("DW_OP_const4u: %lu", (unsigned long) byte_get (data, 4));
	  data += 4;
	  break;
	case DW_OP_const4s:
	  printf ("DW_OP_const4s: %ld", (long) byte_get_signed (data, 4));
	  data += 4;
	  break;
	case DW_OP_const8u:
	  printf ("DW_OP_const8u: %lu %lu", (unsigned long) byte_get (data, 4),
		  (unsigned long) byte_get (data + 4, 4));
	  data += 8;
	  break;
	case DW_OP_const8s:
	  printf ("DW_OP_const8s: %ld %ld", (long) byte_get (data, 4),
		  (long) byte_get (data + 4, 4));
	  data += 8;
	  break;
	case DW_OP_constu:
	  printf ("DW_OP_constu: %lu", read_leb128 (data, &bytes_read, 0));
	  data += bytes_read;
	  break;
	case DW_OP_consts:
	  printf ("DW_OP_consts: %ld", read_leb128 (data, &bytes_read, 1));
d7855 3
a7857 1
	  printf ("DW_OP_call2: <%lx>", (long) byte_get (data, 2));
d7861 3
a7863 1
	  printf ("DW_OP_call4: <%lx>", (long) byte_get (data, 4));
d7873 862
a8734 1
	  break;
d8736 2
a8737 9
	default:
	  if (op >= DW_OP_lo_user
	      && op <= DW_OP_hi_user)
	    printf (_("(User defined location op)"));
	  else
	    printf (_("(Unknown location op)"));
	  /* No way to tell where the next op is, so just bail.  */
	  return;
	}
d8739 2
a8740 5
      /* Separate the ops.  */
      if (data < end)
	printf ("; ");
    }
}
d8742 7
a8748 2
static const char *debug_loc_contents;
static bfd_vma debug_loc_size;
d8750 2
a8751 4
static void
load_debug_loc (FILE *file)
{
  Elf_Internal_Shdr *sec;
d8753 6
a8758 3
  /* If it is already loaded, do nothing.  */
  if (debug_loc_contents != NULL)
    return;
d8760 6
a8765 4
  /* Locate the .debug_loc section.  */
  sec = find_section (".debug_loc");
  if (sec == NULL)
    return;
d8767 6
a8772 1
  debug_loc_size = sec->sh_size;
d8774 34
a8807 3
  debug_loc_contents = get_data (NULL, file, sec->sh_offset, sec->sh_size,
				 _("debug_loc section data"));
}
d8809 4
a8812 9
static void
free_debug_loc (void)
{
  if (debug_loc_contents == NULL)
    return;

  free ((char *) debug_loc_contents);
  debug_loc_contents = NULL;
  debug_loc_size = 0;
d8815 7
d8823 4
a8826 3
static int
display_debug_loc (Elf_Internal_Shdr *section,
		   unsigned char *start, FILE *file)
d8828 1
a8828 5
  unsigned char *section_end;
  unsigned long bytes;
  unsigned char *section_begin = start;
  bfd_vma addr;
  unsigned int comp_unit = 0;
d8830 3
a8832 3
  addr = section->sh_addr;
  bytes = section->sh_size;
  section_end = start + bytes;
d8834 1
a8834 1
  if (bytes == 0)
d8836 8
a8843 2
      printf (_("\nThe .debug_loc section is empty.\n"));
      return 0;
d8845 1
a8845 7

  get_debug_info (file);

  printf (_("Contents of the .debug_loc section:\n\n"));
  printf (_("\n    Offset   Begin    End      Expression\n"));

  while (start < section_end)
d8847 3
a8849 5
      unsigned long begin;
      unsigned long end;
      unsigned short length;
      unsigned long offset;
      unsigned int pointer_size;
d8851 2
a8852 1
      offset = start - section_begin;
d8854 2
a8855 3
      /* Get the pointer size from the comp unit associated
	 with this block of location information.  */
      pointer_size = get_pointer_size_of_comp_unit (comp_unit, ".debug_loc");
d8857 5
a8861 1
      comp_unit ++;
d8863 6
a8868 6
      while (1)
	{
	  begin = byte_get (start, pointer_size);
	  start += pointer_size;
	  end = byte_get (start, pointer_size);
	  start += pointer_size;
d8870 4
a8873 2
	  if (begin == 0 && end == 0)
	    break;
d8875 3
a8877 3
	  /* For now, skip any base address specifiers.  */
	  if (begin == 0xffffffff)
	    continue;
d8879 3
a8881 2
	  begin += addr;
	  end += addr;
d8883 4
a8886 2
	  length = byte_get (start, 2);
	  start += 2;
d8888 2
a8889 3
	  printf ("    %8.8lx %8.8lx %8.8lx (", offset, begin, end);
	  decode_location_expression (start, pointer_size, length);
	  printf (")\n");
d8891 1
a8891 5
	  start += length;
	}
      printf ("\n");
    }
  return 1;
d8894 3
a8896 5
static const char *debug_str_contents;
static bfd_vma debug_str_size;

static void
load_debug_str (FILE *file)
d8898 3
a8900 1
  Elf_Internal_Shdr *sec;
d8902 2
a8903 3
  /* If it is already loaded, do nothing.  */
  if (debug_str_contents != NULL)
    return;
d8905 1
a8905 4
  /* Locate the .debug_str section.  */
  sec = find_section (".debug_str");
  if (sec == NULL)
    return;
d8907 10
a8916 1
  debug_str_size = sec->sh_size;
d8918 1
a8918 3
  debug_str_contents = get_data (NULL, file, sec->sh_offset, sec->sh_size,
				 _("debug_str section data"));
}
d8920 3
a8922 5
static void
free_debug_str (void)
{
  if (debug_str_contents == NULL)
    return;
d8924 13
a8936 4
  free ((char *) debug_str_contents);
  debug_str_contents = NULL;
  debug_str_size = 0;
}
d8938 6
a8943 5
static const char *
fetch_indirect_string (unsigned long offset)
{
  if (debug_str_contents == NULL)
    return _("<no .debug_str section>");
d8945 8
a8952 2
  if (offset > debug_str_size)
    return _("<offset is too big>");
d8954 12
a8965 2
  return debug_str_contents + offset;
}
d8967 3
a8969 7
static int
display_debug_str (Elf_Internal_Shdr *section,
		   unsigned char *start,
		   FILE *file ATTRIBUTE_UNUSED)
{
  unsigned long bytes;
  bfd_vma addr;
d8971 5
a8975 2
  addr  = section->sh_addr;
  bytes = section->sh_size;
d8977 9
a8985 5
  if (bytes == 0)
    {
      printf (_("\nThe .debug_str section is empty.\n"));
      return 0;
    }
d8987 1
a8987 1
  printf (_("Contents of the .debug_str section:\n\n"));
d8989 1
a8989 5
  while (bytes)
    {
      int j;
      int k;
      int lbytes;
d8991 2
a8992 1
      lbytes = (bytes > 16 ? 16 : bytes);
d8994 1
a8994 1
      printf ("  0x%8.8lx ", (unsigned long) addr);
d8996 2
a8997 6
      for (j = 0; j < 16; j++)
	{
	  if (j < lbytes)
	    printf ("%2.2x", start[j]);
	  else
	    printf ("  ");
d8999 2
a9000 3
	  if ((j & 3) == 3)
	    printf (" ");
	}
d9002 3
a9004 1
      for (j = 0; j < lbytes; j++)
d9006 1
a9006 6
	  k = start[j];
	  if (k >= ' ' && k < 0x80)
	    printf ("%c", k);
	  else
	    printf (".");
	}
d9008 3
a9010 1
      putchar ('\n');
d9012 3
a9014 4
      start += lbytes;
      addr  += lbytes;
      bytes -= lbytes;
    }
d9016 2
a9017 2
  return 1;
}
d9019 7
a9025 2
static const char *   debug_range_contents;
static unsigned long  debug_range_size;
d9027 4
a9030 4
static void
load_debug_range (FILE *file)
{
  Elf_Internal_Shdr *sec;
d9032 2
a9033 3
  /* If it is already loaded, do nothing.  */
  if (debug_range_contents != NULL)
    return;
d9035 1
a9035 4
  /* Locate the .debug_str section.  */
  sec = find_section (".debug_ranges");
  if (sec == NULL)
    return;
d9037 9
a9045 1
  debug_range_size = sec->sh_size;
d9047 2
a9048 3
  debug_range_contents = get_data (NULL, file, sec->sh_offset, sec->sh_size,
				   _("debug_range section data"));
}
d9050 2
a9051 5
static void
free_debug_range (void)
{
  if (debug_range_contents == NULL)
    return;
d9053 5
a9057 4
  free ((char *) debug_range_contents);
  debug_range_contents = NULL;
  debug_range_size = 0;
}
d9059 1
d9061 18
a9078 1
/* Decode a DW_AT_ranges attribute for 64bit DWARF3 .  */
d9080 3
a9082 5
static void
decode_64bit_range (unsigned long offset, bfd_vma base_address)
{
  const char * start = debug_range_contents + offset;
  const char * end   = debug_range_contents + debug_range_size;
d9084 7
a9090 4
  do
    {
      bfd_vma a;
      bfd_vma b;
d9092 7
a9098 2
      a = byte_get ((unsigned char *) start, 8);
      b = byte_get ((unsigned char *) start + 8, 8);
d9100 7
a9106 16
      if (a == 0xffffffff)
	{
	  base_address = b;
	}
      else if (a == 0 && b == 0)
	break;
      else if (a > b)
	printf (_(" [corrupt: start > end]"));
      else
	{
	  printf (" ");
	  print_vma (base_address + a, PREFIX_HEX);
	  printf (" - ");
	  print_vma (base_address + b, PREFIX_HEX);
	  printf (", ");
	}
d9108 6
a9113 4
      start += 16;
    }
  while (start < end);
}
d9115 6
a9120 1
/* Decode a DW_AT_ranges attribute.  */
d9122 4
a9125 5
static void
decode_range (unsigned long offset, bfd_vma base_address)
{
  const char * start;
  const char * end;
d9127 7
a9133 5
  if (offset >= (debug_range_size - 8))
    {
      printf (_("[corrupt: offset is outside the .debug_ranges section]"));
      return;
    }
d9135 7
a9141 10
  /* Since all entries in the .debug_ranges section are pairs of either
     4-byte integers (32-bit DWARF3) or 8-byte integers (64-bit DWARF3)
     the offset should always be a multiple of 8 bytes.  */
  if (offset % 8)
    {
      printf (_("[corrupt: offset is not a multiple of 8]"));
      return;
    }  

  start = debug_range_contents + offset;
d9143 3
a9145 9
  if (offset > 0
      /* Be paranoid - check to see if the previous
	 two words were and end-of-range marker.  */
      && (byte_get ((unsigned char *) start - 4, 4) != 0
	  || byte_get ((unsigned char *) start - 8, 4) != 0))
    {
      printf (_("[corrupt: offset is not at the start of a range]"));
      return;
    }  
d9147 3
a9149 1
  end = debug_range_contents + debug_range_size;
d9151 5
a9155 5
  printf ("(");
  do
    {
      unsigned long a;
      unsigned long b;
d9157 2
a9158 2
      a = byte_get ((unsigned char *) start, 4);
      b = byte_get ((unsigned char *) start + 4, 4);
d9160 8
a9167 6
      if (a == 0xffffffff)
	{
	  if (b == 0xffffffff)
	    {
	      decode_64bit_range (offset, base_address);
	      return;
a9168 2

	  base_address = b;
d9170 2
a9171 8
      else if (a == 0 && b == 0)
	break;
      else if (a > b)
	printf (_("[corrupt: start > end]"));
      else
	{
	  if (start > debug_range_contents + offset)
	    printf (", ");
d9173 2
a9174 4
	  printf (_("0x%lx - 0x%lx"),
		  (unsigned long) base_address + a,
		  (unsigned long) base_address + b);
	}
d9176 7
a9182 5
      start += 8;
    }
  while (start < end);
  printf (")");
}
d9184 1
d9186 1
a9186 13
static unsigned char *
read_and_display_attr_value (unsigned long attribute,
			     unsigned long form,
			     unsigned char *data,
			     unsigned long cu_offset,
			     unsigned long pointer_size,
			     unsigned long offset_size,
			     int dwarf_version)
{
  static unsigned long saved_DW_AT_low_pc = 0;
  unsigned long uvalue = 0;
  unsigned char *block_start = NULL;
  int bytes_read;
d9188 1
a9188 1
  switch (form)
d9190 5
a9194 2
    default:
      break;
d9196 3
a9198 2
    case DW_FORM_ref_addr:
      if (dwarf_version == 2)
d9200 4
a9203 7
	  uvalue = byte_get (data, pointer_size);
	  data += pointer_size;
	}
      else if (dwarf_version == 3)
	{
	  uvalue = byte_get (data, offset_size);
	  data += offset_size;
d9207 2
a9208 1
	  error (_("Internal error: DWARF version is not 2 or 3.\n"));
a9209 1
      break;
d9211 5
a9215 7
    case DW_FORM_addr:
      uvalue = byte_get (data, pointer_size);
      data += pointer_size;
      break;

    case DW_FORM_strp:
      uvalue = byte_get (data, offset_size);
a9216 1
      break;
d9218 1
a9218 5
    case DW_FORM_ref1:
    case DW_FORM_flag:
    case DW_FORM_data1:
      uvalue = byte_get (data++, 1);
      break;
d9220 3
a9222 5
    case DW_FORM_ref2:
    case DW_FORM_data2:
      uvalue = byte_get (data, 2);
      data += 2;
      break;
d9224 5
a9228 5
    case DW_FORM_ref4:
    case DW_FORM_data4:
      uvalue = byte_get (data, 4);
      data += 4;
      break;
d9230 2
a9231 4
    case DW_FORM_sdata:
      uvalue = read_leb128 (data, & bytes_read, 1);
      data += bytes_read;
      break;
d9233 8
a9240 5
    case DW_FORM_ref_udata:
    case DW_FORM_udata:
      uvalue = read_leb128 (data, & bytes_read, 0);
      data += bytes_read;
      break;
d9242 1
a9242 8
    case DW_FORM_indirect:
      form = read_leb128 (data, & bytes_read, 0);
      data += bytes_read;
      printf (" %s", get_FORM_name (form));
      return read_and_display_attr_value (attribute, form, data, cu_offset,
					  pointer_size, offset_size,
					  dwarf_version);
    }
d9244 3
a9246 5
  switch (form)
    {
    case DW_FORM_ref_addr:
      printf (" <#%lx>", uvalue);
      break;
d9248 9
a9256 6
    case DW_FORM_ref1:
    case DW_FORM_ref2:
    case DW_FORM_ref4:
    case DW_FORM_ref_udata:
      printf (" <%lx>", uvalue + cu_offset);
      break;
d9258 3
a9260 3
    case DW_FORM_addr:
      printf (" %#lx", uvalue);
      break;
d9262 9
a9270 8
    case DW_FORM_flag:
    case DW_FORM_data1:
    case DW_FORM_data2:
    case DW_FORM_data4:
    case DW_FORM_sdata:
    case DW_FORM_udata:
      printf (" %ld", uvalue);
      break;
d9272 1
a9272 7
    case DW_FORM_ref8:
    case DW_FORM_data8:
      uvalue = byte_get (data, 4);
      printf (" %lx", uvalue);
      printf (" %lx", (unsigned long) byte_get (data + 4, 4));
      data += 8;
      break;
d9274 4
a9277 33
    case DW_FORM_string:
      printf (" %s", data);
      data += strlen ((char *) data) + 1;
      break;

    case DW_FORM_block:
      uvalue = read_leb128 (data, & bytes_read, 0);
      block_start = data + bytes_read;
      data = display_block (block_start, uvalue);
      break;

    case DW_FORM_block1:
      uvalue = byte_get (data, 1);
      block_start = data + 1;
      data = display_block (block_start, uvalue);
      break;

    case DW_FORM_block2:
      uvalue = byte_get (data, 2);
      block_start = data + 2;
      data = display_block (block_start, uvalue);
      break;

    case DW_FORM_block4:
      uvalue = byte_get (data, 4);
      block_start = data + 4;
      data = display_block (block_start, uvalue);
      break;

    case DW_FORM_strp:
      printf (_(" (indirect string, offset: 0x%lx): %s"),
	      uvalue, fetch_indirect_string (uvalue));
      break;
d9279 2
a9280 3
    case DW_FORM_indirect:
      /* Handled above.  */
      break;
d9282 5
a9286 4
    default:
      warn (_("Unrecognized form: %d\n"), form);
      break;
    }
d9288 4
a9291 1
  /* For some attributes we can display further information.  */
d9293 4
a9296 1
  printf ("\t");
d9298 2
a9299 7
  switch (attribute)
    {
    case DW_AT_inline:
      switch (uvalue)
	{
	case DW_INL_not_inlined:
	  printf (_("(not inlined)"));
d9301 8
a9308 2
	case DW_INL_inlined:
	  printf (_("(inlined)"));
d9310 8
a9317 2
	case DW_INL_declared_not_inlined:
	  printf (_("(declared as inline but ignored)"));
a9318 8
	case DW_INL_declared_inlined:
	  printf (_("(declared as inline and inlined)"));
	  break;
	default:
	  printf (_("  (Unknown inline attribute value: %lx)"), uvalue);
	  break;
	}
      break;
d9320 11
a9330 23
    case DW_AT_language:
      switch (uvalue)
	{
	case DW_LANG_C:			printf ("(non-ANSI C)"); break;
	case DW_LANG_C89:		printf ("(ANSI C)"); break;
	case DW_LANG_C_plus_plus:	printf ("(C++)"); break;
	case DW_LANG_Fortran77:		printf ("(FORTRAN 77)"); break;
	case DW_LANG_Fortran90:		printf ("(Fortran 90)"); break;
	case DW_LANG_Modula2:		printf ("(Modula 2)"); break;
	case DW_LANG_Pascal83:		printf ("(ANSI Pascal)"); break;
	case DW_LANG_Ada83:		printf ("(Ada)"); break;
	case DW_LANG_Cobol74:		printf ("(Cobol 74)"); break;
	case DW_LANG_Cobol85:		printf ("(Cobol 85)"); break;
	  /* DWARF 2.1 values.	*/
	case DW_LANG_C99:		printf ("(ANSI C99)"); break;
	case DW_LANG_Ada95:		printf ("(ADA 95)"); break;
	case DW_LANG_Fortran95:		printf ("(Fortran 95)"); break;
	  /* MIPS extension.  */
	case DW_LANG_Mips_Assembler:	printf ("(MIPS assembler)"); break;
	  /* UPC extension.  */
	case DW_LANG_Upc:		printf ("(Unified Parallel C)"); break;
	default:
	  printf ("(Unknown: %lx)", uvalue);
d9333 1
a9333 1
      break;
d9335 2
a9336 23
    case DW_AT_encoding:
      switch (uvalue)
	{
	case DW_ATE_void:		printf ("(void)"); break;
	case DW_ATE_address:		printf ("(machine address)"); break;
	case DW_ATE_boolean:		printf ("(boolean)"); break;
	case DW_ATE_complex_float:	printf ("(complex float)"); break;
	case DW_ATE_float:		printf ("(float)"); break;
	case DW_ATE_signed:		printf ("(signed)"); break;
	case DW_ATE_signed_char:	printf ("(signed char)"); break;
	case DW_ATE_unsigned:		printf ("(unsigned)"); break;
	case DW_ATE_unsigned_char:	printf ("(unsigned char)"); break;
	  /* DWARF 2.1 value.  */
	case DW_ATE_imaginary_float:	printf ("(imaginary float)"); break;
	default:
	  if (uvalue >= DW_ATE_lo_user
	      && uvalue <= DW_ATE_hi_user)
	    printf ("(user defined type)");
	  else
	    printf ("(unknown type)");
	  break;
	}
      break;
a9337 11
    case DW_AT_accessibility:
      switch (uvalue)
	{
	case DW_ACCESS_public:		printf ("(public)"); break;
	case DW_ACCESS_protected:	printf ("(protected)"); break;
	case DW_ACCESS_private:		printf ("(private)"); break;
	default:
	  printf ("(unknown accessibility)");
	  break;
	}
      break;
d9339 7
a9345 9
    case DW_AT_visibility:
      switch (uvalue)
	{
	case DW_VIS_local:		printf ("(local)"); break;
	case DW_VIS_exported:		printf ("(exported)"); break;
	case DW_VIS_qualified:		printf ("(qualified)"); break;
	default:			printf ("(unknown visibility)"); break;
	}
      break;
d9347 1
a9347 9
    case DW_AT_virtuality:
      switch (uvalue)
	{
	case DW_VIRTUALITY_none:	printf ("(none)"); break;
	case DW_VIRTUALITY_virtual:	printf ("(virtual)"); break;
	case DW_VIRTUALITY_pure_virtual:printf ("(pure_virtual)"); break;
	default:			printf ("(unknown virtuality)"); break;
	}
      break;
d9349 3
a9351 10
    case DW_AT_identifier_case:
      switch (uvalue)
	{
	case DW_ID_case_sensitive:	printf ("(case_sensitive)"); break;
	case DW_ID_up_case:		printf ("(up_case)"); break;
	case DW_ID_down_case:		printf ("(down_case)"); break;
	case DW_ID_case_insensitive:	printf ("(case_insensitive)"); break;
	default:			printf ("(unknown case)"); break;
	}
      break;
d9353 2
a9354 14
    case DW_AT_calling_convention:
      switch (uvalue)
	{
	case DW_CC_normal:	printf ("(normal)"); break;
	case DW_CC_program:	printf ("(program)"); break;
	case DW_CC_nocall:	printf ("(nocall)"); break;
	default:
	  if (uvalue >= DW_CC_lo_user
	      && uvalue <= DW_CC_hi_user)
	    printf ("(user defined)");
	  else
	    printf ("(unknown convention)");
	}
      break;
d9356 1
a9356 8
    case DW_AT_ordering:
      switch (uvalue)
	{
	case -1: printf ("(undefined)"); break;
	case 0:  printf ("(row major)"); break;
	case 1:  printf ("(column major)"); break;
	}
      break;
d9358 1
a9358 11
    case DW_AT_frame_base:
    case DW_AT_location:
    case DW_AT_data_member_location:
    case DW_AT_vtable_elem_location:
    case DW_AT_allocated:
    case DW_AT_associated:
    case DW_AT_data_location:
    case DW_AT_stride:
    case DW_AT_upper_bound:
    case DW_AT_lower_bound:
      if (block_start)
d9360 1
a9360 6
	  printf ("(");
	  decode_location_expression (block_start, pointer_size, uvalue);
	  printf (")");
	}
      else if (form == DW_FORM_data4 || form == DW_FORM_data8)
	printf (_("(location list)"));
d9362 4
a9365 1
      break;
d9367 5
a9371 7
    case DW_AT_low_pc:
      /* This is a hack.  We keep track of the DW_AT_low_pc attributes
	 and use them when decoding DW_AT_ranges attributes.  The
	 assumption here is that we are decoding the attributes in order
	 and so the correct base address for the range is the low_pc.  */
      saved_DW_AT_low_pc = uvalue;
      break;
d9373 1
a9373 6
    case DW_AT_ranges:
      decode_range (uvalue, saved_DW_AT_low_pc);
      break;

    default:
      break;
d9375 1
d9377 1
a9377 2
  return data;
}
d9379 1
a9379 14
static unsigned char *
read_and_display_attr (unsigned long attribute,
		       unsigned long form,
		       unsigned char *data,
		       unsigned long cu_offset,
		       unsigned long pointer_size,
		       unsigned long offset_size,
		       int dwarf_version)
{
  printf ("     %-18s:", get_AT_name (attribute));
  data = read_and_display_attr_value (attribute, form, data, cu_offset,
				      pointer_size, offset_size, dwarf_version);
  printf ("\n");
  return data;
a9381 2
/* Apply addends of RELA relocations.  */

d9383 2
a9384 6
debug_apply_rela_addends (FILE *file,
			  Elf_Internal_Shdr *section,
			  int reloc_size,
			  unsigned char *sec_data,
			  unsigned char *start,
			  unsigned char *end)
d9386 12
a9397 1
  Elf_Internal_Shdr *relsec;
d9399 3
a9401 2
  if (end - start < reloc_size)
    return 1;
d9403 1
a9403 3
  for (relsec = section_headers;
       relsec < section_headers + elf_header.e_shnum;
       ++relsec)
d9405 3
a9407 5
      unsigned long nrelas;
      Elf_Internal_Rela *rela, *rp;
      Elf_Internal_Shdr *symsec;
      Elf_Internal_Sym *symtab;
      Elf_Internal_Sym *sym;
d9409 1
a9409 4
      if (relsec->sh_type != SHT_RELA
	  || SECTION_HEADER (relsec->sh_info) != section
	  || relsec->sh_size == 0)
	continue;
d9411 6
a9416 3
      if (!slurp_rela_relocs (file, relsec->sh_offset, relsec->sh_size,
			      &rela, &nrelas))
	return 0;
d9418 2
a9419 2
      symsec = SECTION_HEADER (relsec->sh_link);
      symtab = GET_ELF_SYMBOLS (file, symsec);
d9421 2
a9422 1
      for (rp = rela; rp < rela + nrelas; ++rp)
d9424 1
a9424 9
	  unsigned char *loc;

	  if (rp->r_offset >= (bfd_vma) (start - sec_data)
	      && rp->r_offset < (bfd_vma) (end - sec_data) - reloc_size)
	    loc = sec_data + rp->r_offset;
	  else
	    continue;

	  if (is_32bit_elf)
d9426 5
a9430 14
	      sym = symtab + ELF32_R_SYM (rp->r_info);

	      if (ELF32_R_SYM (rp->r_info) != 0
		  && ELF32_ST_TYPE (sym->st_info) != STT_SECTION
		  /* Relocations against object symbols can happen,
		     eg when referencing a global array.  For an
		     example of this see the _clz.o binary in libgcc.a.  */
		  && ELF32_ST_TYPE (sym->st_info) != STT_OBJECT)
		{
		  warn (_("%s: skipping unexpected symbol type %s in relocation in section .rela%s\n"),
			get_symbol_type (ELF32_ST_TYPE (sym->st_info)),
			SECTION_NAME (section));
		  continue;
		}
d9433 3
d9437 2
a9438 5
	      sym = symtab + ELF64_R_SYM (rp->r_info);

	      if (ELF64_R_SYM (rp->r_info) != 0
		  && ELF64_ST_TYPE (sym->st_info) != STT_SECTION
		  && ELF64_ST_TYPE (sym->st_info) != STT_OBJECT)
d9440 2
a9441 4
		  warn (_("skipping unexpected symbol type %s in relocation in section .rela.%s\n"),
			get_symbol_type (ELF64_ST_TYPE (sym->st_info)),
			SECTION_NAME (section));
		  continue;
d9443 1
a9444 2

	  byte_put (loc, rp->r_addend, reloc_size);
d9446 1
d9448 3
a9450 6
      free (symtab);
      free (rela);
      break;
    }
  return 1;
}
d9452 2
a9453 7
static int
display_debug_info (Elf_Internal_Shdr *section,
		    unsigned char *start,
		    FILE *file)
{
  unsigned char *end = start + section->sh_size;
  unsigned char *section_begin = start;
d9455 3
a9457 1
  printf (_("The section %s contains:\n\n"), SECTION_NAME (section));
d9459 2
a9460 3
  load_debug_str (file);
  load_debug_loc (file);
  load_debug_range (file);
d9462 2
a9463 1
  while (start < end)
d9465 5
a9469 5
      DWARF2_Internal_CompUnit compunit;
      unsigned char *hdrptr;
      unsigned char *cu_abbrev_offset_ptr;
      unsigned char *tags;
      int level;
a9470 4
      int offset_size;
      int initial_length_size;

      hdrptr = start;
d9472 2
a9473 2
      compunit.cu_length = byte_get (hdrptr, 4);
      hdrptr += 4;
d9475 1
a9475 1
      if (compunit.cu_length == 0xffffffff)
d9477 2
a9478 10
	  compunit.cu_length = byte_get (hdrptr, 8);
	  hdrptr += 8;
	  offset_size = 8;
	  initial_length_size = 12;
	}
      else
	{
	  offset_size = 4;
	  initial_length_size = 4;
	}
d9480 12
a9491 2
      compunit.cu_version = byte_get (hdrptr, 2);
      hdrptr += 2;
d9493 6
a9498 2
      cu_offset = start - section_begin;
      start += compunit.cu_length + initial_length_size;
d9500 2
a9501 4
      if (elf_header.e_type == ET_REL
	  && !debug_apply_rela_addends (file, section, offset_size,
					section_begin, hdrptr, start))
	return 0;
d9503 3
a9505 3
      cu_abbrev_offset_ptr = hdrptr;
      compunit.cu_abbrev_offset = byte_get (hdrptr, offset_size);
      hdrptr += offset_size;
d9507 2
a9508 2
      compunit.cu_pointer_size = byte_get (hdrptr, 1);
      hdrptr += 1;
d9510 2
a9511 1
      tags = hdrptr;
d9513 5
a9517 5
      printf (_("  Compilation Unit @@ %lx:\n"), cu_offset);
      printf (_("   Length:        %ld\n"), compunit.cu_length);
      printf (_("   Version:       %d\n"), compunit.cu_version);
      printf (_("   Abbrev Offset: %ld\n"), compunit.cu_abbrev_offset);
      printf (_("   Pointer Size:  %d\n"), compunit.cu_pointer_size);
d9519 3
a9521 5
      if (compunit.cu_version != 2 && compunit.cu_version != 3)
	{
	  warn (_("Only version 2 and 3 DWARF debug information is currently supported.\n"));
	  continue;
	}
d9523 2
a9524 1
      free_abbrevs ();
d9526 7
a9532 4
      /* Read in the abbrevs used by this compilation unit.  */
      {
	Elf_Internal_Shdr *sec;
	unsigned char *begin;
d9534 7
a9540 7
	/* Locate the .debug_abbrev section and process it.  */
	sec = find_section (".debug_abbrev");
	if (sec == NULL)
	  {
	    warn (_("Unable to locate .debug_abbrev section!\n"));
	    return 0;
	  }
d9542 2
a9543 4
	begin = get_data (NULL, file, sec->sh_offset, sec->sh_size,
			  _("debug_abbrev section data"));
	if (!begin)
	  return 0;
d9545 5
a9549 2
	process_abbrev_section (begin + compunit.cu_abbrev_offset,
				begin + sec->sh_size);
d9551 1
a9551 2
	free (begin);
      }
d9553 5
a9557 7
      level = 0;
      while (tags < start)
	{
	  int bytes_read;
	  unsigned long abbrev_number;
	  abbrev_entry *entry;
	  abbrev_attr *attr;
d9559 1
a9559 2
	  abbrev_number = read_leb128 (tags, & bytes_read, 0);
	  tags += bytes_read;
d9561 1
a9561 6
	  /* A null DIE marks the end of a list of children.  */
	  if (abbrev_number == 0)
	    {
	      --level;
	      continue;
	    }
d9563 6
a9568 6
	  /* Scan through the abbreviation list until we reach the
	     correct entry.  */
	  for (entry = first_abbrev;
	       entry && entry->entry != abbrev_number;
	       entry = entry->next)
	    continue;
d9570 3
a9572 6
	  if (entry == NULL)
	    {
	      warn (_("Unable to locate entry %lu in the abbreviation table\n"),
		    abbrev_number);
	      return 0;
	    }
d9574 8
a9581 5
	  printf (_(" <%d><%lx>: Abbrev Number: %lu (%s)\n"),
		  level,
		  (unsigned long) (tags - section_begin - bytes_read),
		  abbrev_number,
		  get_TAG_name (entry->tag));
d9583 1
a9583 7
	  for (attr = entry->first_attr; attr; attr = attr->next)
	    tags = read_and_display_attr (attr->attribute,
					  attr->form,
					  tags, cu_offset,
					  compunit.cu_pointer_size,
					  offset_size,
					  compunit.cu_version);
d9585 3
a9587 3
	  if (entry->children)
	    ++level;
	}
d9590 2
a9591 3
  free_debug_range ();
  free_debug_str ();
  free_debug_loc ();
a9592 1
  printf ("\n");
d9594 5
a9598 1
  return 1;
d9601 1
d10174 1
d10505 1
a10505 1
		  decode_location_expression (start, addr_size, ul);
d10518 1
a10518 1
		  decode_location_expression (start, addr_size, ul);
d11750 3
@


1.268
log
@readelf.c (last_pointer_size, warned_about_missing_comp_units):
  New variables associated with obtaining the pointer size for a comp_unit.
  (get_pointer_size_of_comp_unit): Add an extra parameter - the name of the
  section requesting the pointer size.  Use this name in error messages.  If
  there are not enough comp_units available produce a warning message, but
  return the last known pointer size so that section dumping can continue.
  (get_debug_info): Reset the new variables.
  (display_debug_lines): Add extra parameter to invocation of
  get_pointer_size_of_comp_unit and remove error message when it returns 0.
  (display_debug_loc): Likewise.
@
text
@d6936 1
a6936 1
  int shift = 0;
d6944 1
a6944 1
      result |= (byte & 0x7f) << shift;
d6954 2
a6955 2
  if (sign && (shift < 32) && (byte & 0x40))
    result |= -1 << shift;
@


1.267
log
@	* readelf.c (get_machine_flags): Handle E_MIPS_MACH_9000.
@
text
@d7082 2
d7086 2
a7087 1
get_pointer_size_of_comp_unit (unsigned int comp_unit)
d7089 22
a7110 3
  if (num_debug_info_entries == 0
      || comp_unit >= num_debug_info_entries)
    return 0;
a7111 1
  return debug_information [comp_unit].pointer_size;
d7131 6
d7305 2
a7306 6
      pointer_size = get_pointer_size_of_comp_unit (comp_unit);
      if (pointer_size == 0)
	{
	  error (_("Not enough comp units for .debug_line section\n"));
	  return 0;
	}
d8513 2
a8514 6
      pointer_size = get_pointer_size_of_comp_unit (comp_unit);
      if (pointer_size == 0)
	{
	  error (_("Not enough comp units for .debug_loc section\n"));
	  return 0;
	}
@


1.266
log
@*sigh* undo previous delta which was done too early...
@
text
@d2022 1
@


1.265
log
@oops - omitted from previous delta
@
text
@a2083 1
	    case EF_SH4_NOMMU_NOFPU: strcat (buf,", sh4-nommu-nofpu"); break;
d2085 1
a2085 6
	    case EF_SH3_NOMMU: strcat (buf, ", sh3-nommu"); break;
	    case EF_SH2A_FAKE1: strcat (buf, ", sh2a (fake1)"); break;
	    case EF_SH2A_FAKE2: strcat (buf, ", sh2a (fake2)"); break;
	    case EF_SH2A_FAKE3: strcat (buf, ", sh2a (fake3)"); break;
	    case EF_SH2A_FAKE4: strcat (buf, ", sh2a (fake4)"); break;
	    default: strcat (buf, ", unknown ISA: "); break;
@


1.264
log
@Add support to readelf to decode and display the contents of .debug_ranges
sections.
@
text
@d2084 1
d2086 6
a2091 1
	    default: strcat (buf, ", unknown ISA"); break;
@


1.263
log
@	* readelf.c (ia64_unw_aux_info, ia64_unw_table_entry): Rename from
	unw_aux_info and unw_table_entry.
	(find_symbol_for_address): Pass symtab and strtab info explicitly.
	(dump_ia64_unwind): Rename unw_{aux_info,table_entry} with ia64_
	prefix.
	(slurp_ia64_unwind_table): Likewise.
	(ia64_process_unwind): Rename from old process_unwind.
	(hppa_unw_aux_info): New.
	(dump_hppa_unwind): New.
	(slurp_hppa_unwind_table): New.
	(hppa_process_unwind): New.
	(process_unwind): Factor out common unwinding checks; dispatch to
	unwind handler based on machine type.
@
text
@d162 1
d189 10
a198 1
/* A dynamic array of flags indicating which sections require dumping.  */
d225 2
a226 2
				 ((X)->sh_name >= string_table_length \
				  ? "<corrupt>" : string_table + (X)->sh_name))
d272 4
d583 2
a584 2
      /* Although we are extracing data from an 8 byte wide field, we
	 are returning only 4 bytes of data.  */
d760 1
a760 1
	  error(_("out of memory parsing relocs"));
d787 1
a787 1
	  error(_("out of memory parsing relocs"));
d830 1
a830 1
	  error(_("out of memory parsing relocs"));
d857 1
a857 1
	  error(_("out of memory parsing relocs"));
d1285 2
a1286 1
	  printf ("%*c", is_32bit_elf ? (do_wide ? 34 : 28) : (do_wide ? 26 : 20), ' ');
d1291 1
a1291 1
	  && !strcmp (rtype, "R_SPARC_OLO10"))
d1309 1
a1309 1
	  printf("\n                    Type3: ");
d2419 1
a2419 1
  /* If the top 8 bits are 0x78 the next 8 are the os/abi ID. */
d2594 2
a2595 2
  -w[liaprmfFso] or\n\
  --debug-dump[=line,=info,=abbrev,=pubnames,=ranges,=macro,=frames,=str,=loc]\n\
d2612 5
d2767 3
d2771 1
a2771 1
		    do_debug_aranges = 1;
d2807 27
a2833 4
	      static const char *debug_dump_opt[]
		= { "line", "info", "abbrev", "pubnames", "ranges",
		    "macro", "frames", "frames-interp", "str", "loc", NULL };
	      unsigned int index;
d2841 3
a2843 1
		  for (index = 0; debug_dump_opt[index]; index++)
d2845 1
a2845 1
		      size_t len = strlen (debug_dump_opt[index]);
d2847 1
a2847 1
		      if (strncmp (p, debug_dump_opt[index], len) == 0
d2850 6
a2855 39
			  switch (p[0])
			    {
			    case 'i':
			      do_debug_info = 1;
			      break;

			    case 'a':
			      do_debug_abbrevs = 1;
			      break;

			    case 'l':
			      if (p[1] == 'i')
				do_debug_lines = 1;
			      else
				do_debug_loc = 1;
			      break;

			    case 'p':
			      do_debug_pubnames = 1;
			      break;

			    case 'r':
			      do_debug_aranges = 1;
			      break;

			    case 'f':
			      if (len > 6)
				do_debug_frames_interp = 1;
			      do_debug_frames = 1;
			      break;

			    case 'm':
			      do_debug_macinfo = 1;
			      break;

			    case 's':
			      do_debug_str = 1;
			      break;
			    }
d2862 1
a2862 1
		  if (debug_dump_opt[index] == NULL)
d2913 1
a2913 1
      usage();
d3289 1
a3289 1
		if (strcmp (SECTION_NAME (sec), ".dynamic") == 0)
d3734 1
a3734 1
	       && strcmp (name, ".dynstr") == 0)
d3758 2
a3759 2
		|| do_debug_loc)
	       && strncmp (name, ".debug_", 7) == 0)
d3764 10
a3773 9
	      || (do_debug_info     && (strcmp (name, "info") == 0))
	      || (do_debug_abbrevs  && (strcmp (name, "abbrev") == 0))
	      || (do_debug_lines    && (strcmp (name, "line") == 0))
	      || (do_debug_pubnames && (strcmp (name, "pubnames") == 0))
	      || (do_debug_aranges  && (strcmp (name, "aranges") == 0))
	      || (do_debug_frames   && (strcmp (name, "frame") == 0))
	      || (do_debug_macinfo  && (strcmp (name, "macinfo") == 0))
	      || (do_debug_str      && (strcmp (name, "str") == 0))
	      || (do_debug_loc      && (strcmp (name, "loc") == 0))
d3779 1
a3779 1
	       && strncmp (name, ".gnu.linkonce.wi.", 17) == 0)
d3781 1
a3781 1
      else if (do_debug_frames && strcmp (name, ".eh_frame") == 0)
d4090 1
d4454 1
a4454 1
	  if (strncmp (relname, "R_IA64_SEGREL", 13) != 0)
d4542 2
a4543 2
	      if (strcmp (SECTION_NAME (sec),
			  ELF_STRING_ia64_unwind_info) == 0)
d4550 1
a4550 2
      else if (strncmp (SECTION_NAME (unwsec),
			ELF_STRING_ia64_unwind_once, len) == 0)
d4552 1
a4552 1
	  /* .gnu.linkonce.ia64unw.FOO -> .gnu.linkonce.ia64unwi.FOO */
d4557 2
a4558 3
	    if (strncmp (SECTION_NAME (sec),
			 ELF_STRING_ia64_unwind_info_once, len2) == 0
		&& strcmp (SECTION_NAME (sec) + len2, suffix) == 0)
d4564 1
a4564 1
	     .IA_64.unwind or BAR -> .IA_64.unwind_info */
d4568 1
a4568 2
	  if (strncmp (SECTION_NAME (unwsec), ELF_STRING_ia64_unwind,
		       len) == 0)
d4572 2
a4573 3
	    if (strncmp (SECTION_NAME (sec),
			 ELF_STRING_ia64_unwind_info, len2) == 0
		&& strcmp (SECTION_NAME (sec) + len2, suffix) == 0)
d4705 2
a4706 2
#define PF(_m) if (tp->_m) printf(#_m " ");
#define PV(_m) if (tp->_m) printf(#_m "=%d ", tp->_m);
d4710 1
a4710 1
      /* PV(Region_description); */
d4738 1
a4738 1
  printf("\n");
a4912 2
  Elf_Internal_Shdr *sec, *unwsec = NULL, *strsec;
  unsigned long i, addr_size;
d4914 5
d4937 1
a4937 1
      else if (strcmp (SECTION_NAME(sec), ".PARISC.unwind") == 0)
d4946 1
a4946 1
      if (strcmp (SECTION_NAME(sec), ".PARISC.unwind") == 0)
a4947 1

d4991 1
a4991 1
      return handlers[i].handler(file);
d5687 1
a5687 1
		      if (strcmp (name, program_interpreter) == 0)
d6829 1
a6829 1
static void
d6990 1
d7061 1
a7061 1
    if (strcmp (SECTION_NAME (sec), name) == 0)
d7070 21
a7090 5
/* Size of pointers in the .debug_line section.  This information is not
   really present in that section.  It's obtained before dumping the debug
   sections by doing some pre-scan of the .debug_info section.  */
static unsigned int * debug_line_pointer_sizes = NULL;
static unsigned int   num_debug_line_pointer_sizes = 0;
d7099 1
a7099 1
get_debug_line_pointer_sizes (FILE * file)
d7109 4
d7119 1
a7119 1
		    _("extracting pointer sizes from .debug_info section"));
d7148 3
a7150 3
  /* Then allocate an array to hold the pointer sizes.  */
  debug_line_pointer_sizes = malloc (num_units * sizeof * debug_line_pointer_sizes);
  if (debug_line_pointer_sizes == NULL)
d7152 1
a7152 1
      error (_("Not enough memory for a pointer size array of %u entries"),
d7173 1
a7173 1
	  debug_line_pointer_sizes [unit] = byte_get (begin + 22, 1);
d7188 1
a7188 1
	  debug_line_pointer_sizes [unit] = byte_get (begin + 10, 1);
d7194 2
a7195 2
  num_debug_line_pointer_sizes = num_units;
  return num_units;
a7201 3
  unsigned char *hdrptr;
  DWARF2_Internal_LineInfo info;
  unsigned char *standard_opcodes;
a7203 4
  unsigned char *end_of_sequence;
  int i;
  int offset_size;
  int initial_length_size;
d7209 1
a7209 2
  if (num_debug_line_pointer_sizes == 0)
    get_debug_line_pointer_sizes (file);
d7213 4
d7218 3
d7277 2
a7278 1
      if (comp_unit >= num_debug_line_pointer_sizes)
d7283 1
a7283 5
      else
	{
	  pointer_size = debug_line_pointer_sizes [comp_unit];
	  comp_unit ++;
	}
a7360 1

d7467 8
a7474 10
	      {
		int i;
		for (i = standard_opcodes[op_code - 1]; i > 0 ; --i)
		  {
		    printf ("0x%lx%s", read_leb128 (data, &bytes_read, 0),
			    i == 1 ? "" : ", ");
		    data += bytes_read;
		  }
		putchar ('\n');
	      }
d7984 2
a7985 1
	    printf (_(" DW_MACINFO_start_file - lineno: %d filenum: %d\n"), lineno, filenum);
d7998 2
a7999 1
	  printf (_(" DW_MACINFO_define - lineno : %d macro : %s\n"), lineno, string);
d8007 2
a8008 1
	  printf (_(" DW_MACINFO_undef - lineno : %d macro : %s\n"), lineno, string);
d8019 2
a8020 1
	    printf (_(" DW_MACINFO_vendor_ext - constant : %d string : %s\n"), constant, string);
d8059 3
a8061 5
	    {
	      printf (_("    %-18s %s\n"),
		      get_AT_name (attr->attribute),
		      get_FORM_name (attr->form));
	    }
d8472 1
a8472 2
  if (num_debug_line_pointer_sizes == 0)
    get_debug_line_pointer_sizes (file);
d8489 2
a8490 1
      if (comp_unit >= num_debug_line_pointer_sizes)
d8495 1
a8495 5
      else
	{
	  pointer_size = debug_line_pointer_sizes [comp_unit];
	  comp_unit ++;
	}
d8633 150
d8792 1
d9106 14
a9119 5
	{
	  printf ("(");
	  printf ("location list");
	  printf (")");
	}
d9197 5
a9201 1
		  && ELF32_ST_TYPE (sym->st_info) != STT_SECTION)
d9203 3
a9205 2
		  warn (_("Skipping unexpected symbol type %u\n"),
			ELF32_ST_TYPE (sym->st_info));
d9214 2
a9215 1
		  && ELF64_ST_TYPE (sym->st_info) != STT_SECTION)
d9217 3
a9219 2
		  warn (_("Skipping unexpected symbol type %u\n"),
			ELF64_ST_TYPE (sym->st_info));
d9246 1
d9386 1
d9491 89
d9727 1
a9727 1
  int is_eh = (strcmp (SECTION_NAME (section), ".eh_frame") == 0);
d9816 1
a9816 1
	  else if (strcmp (fc->augmentation, "eh") == 0)
d9975 2
a9976 2
      /* At this point, fc is the current chunk, cie (if any) is set, and we're
	 about to interpret instructions for the chunk.  */
d10377 1
a10377 1
	      fprintf (stderr, "unsupported or unknown DW_CFA_%d\n", op);
d10428 1
a10428 1
  { ".debug_ranges",		display_debug_not_supported },
d10440 1
a10440 1
  unsigned char *start;
d10450 2
a10451 4
  start = get_data (NULL, file, section->sh_offset, length,
		    _("debug section data"));
  if (!start)
    return 0;
a10453 3
  if (strncmp (name, ".gnu.linkonce.wi.", 17) == 0)
    name = ".debug_info";

d10455 1
a10455 1
    if (strcmp (debug_displays[i].name, name) == 0)
d10457 17
a10473 1
	debug_displays[i].display (section, start, file);
d10478 4
a10481 1
    printf (_("Unrecognized debug section: %s\n"), name);
d10483 1
a10483 7
  free (start);

  /* If we loaded in the abbrev section at some point,
     we must release it here.  */
  free_abbrevs ();

  return 1;
d10486 1
a10486 1
static int
d10493 1
a10493 1
    return 1;
d10510 5
a10514 4
  if (i < num_dump_sects)
    warn (_("Some sections were not dumped because they do not exist!\n"));

  return 1;
d11132 1
a11132 1
  else if (strncmp (pnote->namedata, "NetBSD-CORE", 11) == 0)
d11426 17
d11540 7
d11615 1
a11615 1
	  error(_("%s: failed to read string table\n"), file_name);
d11688 1
a11688 1

a11796 2
  char *cmdline_dump_sects = NULL;
  unsigned num_cmdline_dump_sects = 0;
d11809 1
a11809 6
  if (optind < (argc - 1))
    show_name = 1;

  /* When processing more than one file remember the dump requests
     issued on command line to reset them after each file.  */
  if (optind + 1 < argc && dump_sects != NULL)
d11811 1
d11822 3
d11827 1
a11827 11
    {
      err |= process_file (argv[optind++]);

      /* Reset dump requests.  */
      if (optind < argc && dump_sects != NULL)
	{
	  num_dump_sects = num_cmdline_dump_sects;
	  if (num_cmdline_dump_sects > 0)
	    memcpy (dump_sects, cmdline_dump_sects, num_cmdline_dump_sects);
	}
    }
@


1.262
log
@(display_debug_lines): Fix typo in error message.
@
text
@d1897 1
a1897 1
	      
d2074 1
a2074 1
	  
d4174 1
a4174 1
		  
d4209 2
d4223 1
a4223 1
struct unw_aux_info
d4225 1
a4225 1
    struct unw_table_entry
d4244 4
a4247 1
find_symbol_for_address (struct unw_aux_info *aux,
d4256 1
a4256 1
  for (i = 0, sym = aux->symtab; i < aux->nsyms; ++i, ++sym)
d4272 2
a4273 2
      *symname = (best->st_name >= aux->strtab_size
		  ? "<corrupt>" : aux->strtab + best->st_name);
d4282 1
a4282 1
dump_ia64_unwind (struct unw_aux_info *aux)
d4285 1
a4285 1
  struct unw_table_entry *tp;
d4298 2
a4299 1
      find_symbol_for_address (aux, tp->start, &procname, &offset);
d4342 1
a4342 1
			 struct unw_aux_info *aux,
d4347 1
a4347 1
  struct unw_table_entry *tep;
d4472 1
a4472 1
process_unwind (FILE *file)
d4476 1
a4476 10
  struct unw_aux_info aux;

  if (!do_unwind)
    return 1;

  if (elf_header.e_machine != EM_IA_64)
    {
      printf (_("\nThere are no unwind sections in this file.\n"));
      return 1;
    }
d4527 1
a4527 1
		  break;
d4613 369
d10720 1
a10720 1
      case NT_AUXV: 	
d10722 1
a10722 1
      case NT_PRSTATUS:	
d10724 1
a10724 1
      case NT_FPREGSET:	
d10726 1
a10726 1
      case NT_PRPSINFO:	
d10728 1
a10728 1
      case NT_TASKSTRUCT:	
d10730 1
a10730 1
      case NT_PRXFPREG:	
d10732 1
a10732 1
      case NT_PSTATUS:	
d10734 1
a10734 1
      case NT_FPREGS:	
d10736 1
a10736 1
      case NT_PSINFO:	
d10738 1
a10738 1
      case NT_LWPSTATUS:	
d10740 1
a10740 1
      case NT_LWPSINFO:	
d10742 1
a10742 1
      case NT_WIN32PSTATUS: 
@


1.261
log
@readelf.c (get_note_type): Handle notes not in core files.
  (process_note_sections): New function.
  (process_corefile_contents): Rename to ...
  (process_notes): ... this.
  (process_object): Call process_notes, not process_corefile_contents.
doc/binutils.texi: Update readelf -n documentation.
@
text
@d6878 1
a6878 1
	  error (_("Not enough comp units for .debug_lines section\n"));
@


1.260
log
@2004-10-25  David Mosberger  <davidm@@hpl.hp.com>

	* readelf.c (slurp_ia64_unwind_table): Support relocations against
	non-section symbols by adding in the symbol value.
@
text
@d10351 43
a10393 18
  switch (e_type)
    {
    case NT_AUXV: 	return _("NT_AUXV (auxiliary vector)");
    case NT_PRSTATUS:	return _("NT_PRSTATUS (prstatus structure)");
    case NT_FPREGSET:	return _("NT_FPREGSET (floating point registers)");
    case NT_PRPSINFO:	return _("NT_PRPSINFO (prpsinfo structure)");
    case NT_TASKSTRUCT:	return _("NT_TASKSTRUCT (task structure)");
    case NT_PRXFPREG:	return _("NT_PRXFPREG (user_xfpregs structure)");
    case NT_PSTATUS:	return _("NT_PSTATUS (pstatus structure)");
    case NT_FPREGS:	return _("NT_FPREGS (floating point registers)");
    case NT_PSINFO:	return _("NT_PSINFO (psinfo structure)");
    case NT_LWPSTATUS:	return _("NT_LWPSTATUS (lwpstatus_t structure)");
    case NT_LWPSINFO:	return _("NT_LWPSINFO (lwpsinfo_t structure)");
    case NT_WIN32PSTATUS: return _("NT_WIN32PSTATUS (win32_pstatus structure)");
    default:
      sprintf (buff, _("Unknown note type: (0x%08x)"), e_type);
      return buff;
    }
d10468 4
a10471 5
    {
      /* If there is no note name, then use the default set of
	 note type strings.  */
      nt = get_note_type (pnote->type);
    }
d10473 3
a10475 4
    {
      /* NetBSD-specific core file notes.  */
      nt = get_netbsd_elfcore_note_type (pnote->type);
    }
d10477 2
a10478 3
    {
      /* Don't recognize this note name; just use the default set of
	 note type strings.  */
a10479 1
    }
d10594 19
a10612 1
process_corefile_contents (FILE *file)
a10617 1
  /* If file is not a core file then exit.  */
d10619 1
a10619 1
    return 1;
d10622 2
a10623 5
  if (elf_header.e_phnum == 0)
    {
      printf (_("No note segments present in the core file.\n"));
      return 1;
   }
d10625 2
a10626 1
  return process_corefile_note_segments (file);
d10795 1
a10795 1
  process_corefile_contents (file);
@


1.259
log
@PR 465
* readelf.c (dynamic_strings_length): New global variable.
(VALID_DYNAMIC_NAME, GET_DYNAMIC_NAME): New macros for accessing
strings in the dynamic string table.
(process_section_headers): Initialise dynamic_strings_length.
(process_dynamic_section): Likewise.
(process_object): Reset dynamic_string_length when the buffer is freed.
(dynamic_sections_mips_val): Use the new macros.
(process_dynamic_section): Likewise.
(process_version_sections): Likewise.
(process_symbol_table): Likewise.
(process_syminfo): Likewise.
(process_mips_specific): Likewise.
(dump_relocations): Add a new parameter 'strtablen' and use this to verify that
  string offset in a given reloc is valid.  Print a suitable error message
  otherwise.
(process_relocs): Pass the new argument to dump_relocations.
@
text
@a4423 7

	      if (ELF32_ST_TYPE (sym->st_info) != STT_SECTION)
		{
		  warn (_("Skipping unexpected symbol type %u\n"),
			ELF32_ST_TYPE (sym->st_info));
		  continue;
		}
a4428 7

	      if (ELF64_ST_TYPE (sym->st_info) != STT_SECTION)
		{
		  warn (_("Skipping unexpected symbol type %u\n"),
			ELF64_ST_TYPE (sym->st_info));
		  continue;
		}
d4443 1
a4443 1
	      aux->table[i].start.offset += rp->r_addend;
d4447 1
a4447 1
	      aux->table[i].end.offset   += rp->r_addend;
d4451 1
a4451 1
	      aux->table[i].info.offset  += rp->r_addend;
@


1.258
log
@2004-10-19  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (process_section_groups): Free symtab after use.
@
text
@d126 1
d258 5
a262 1

d871 1
d1259 3
a1261 1
		printf (_("<string table index %3ld>"), psym->st_name);
d3729 1
d4126 1
a4126 1
				dynamic_strings, is_rela);
a4152 2
	      Elf_Internal_Sym *symtab;
	      char *strtab;
a4153 1
	      unsigned long nsyms;
d4165 2
a4166 3
	      symtab = NULL;
	      strtab = NULL;
	      nsyms = 0;
d4170 5
a4174 1

d4186 7
d4194 3
a4196 9
	      is_rela = section->sh_type == SHT_RELA;

	      dump_relocations (file, rel_offset, rel_size,
				symtab, nsyms, strtab, is_rela);

	      if (strtab)
		free (strtab);
	      if (symtab)
		free (symtab);
d4661 2
a4662 3
      if (dynamic_strings != NULL)
	printf ("Interface Version: %s\n",
		dynamic_strings + entry->d_un.d_val);
d4664 1
a4664 1
	printf ("%ld\n", (long) entry->d_un.d_ptr);
d5007 1
d5125 2
a5126 2
	      if (dynamic_strings)
		printf (": [%s]\n", dynamic_strings + entry->d_un.d_val);
d5308 3
a5310 1
	      if (dynamic_strings == NULL)
a5311 2
	      else
		name = dynamic_strings + entry->d_un.d_val;
d5389 2
a5390 1
	      if (dynamic_strings != NULL && entry->d_tag == DT_USED)
d5392 1
a5392 3
		  char *name;

		  name = dynamic_strings + entry->d_un.d_val;
d5559 2
a5560 2
		if (dynamic_strings)
		  printf (_("Name: %s\n"), dynamic_strings + aux.vda_name);
d5576 1
a5576 1
		    if (dynamic_strings)
d5578 1
a5578 1
			      isum, j, dynamic_strings + aux.vda_name);
d5633 2
a5634 2
		if (dynamic_strings)
		  printf (_("  File: %s"), dynamic_strings + ent.vn_file);
d5655 1
a5655 1
		    if (dynamic_strings)
d5657 1
a5657 1
			      isum, dynamic_strings + aux.vna_name);
d6117 4
a6120 1
	      print_symbol (25, dynamic_strings + psym->st_name);
d6419 4
a6422 1
      print_symbol (30, dynamic_strings + dynamic_symbols[i].st_name);
d6435 2
a6436 1
	      && dynamic_syminfo[i].si_boundto < dynamic_nent)
d6438 1
a6438 4
	      print_symbol (10,
			    dynamic_strings
			    + (dynamic_section
			       [dynamic_syminfo[i].si_boundto].d_un.d_val));
d9967 4
a9970 1
	      print_symbol (20, dynamic_strings + liblist.l_name);
d10270 4
a10273 1
	  print_symbol (25, dynamic_strings + psym->st_name);
d10802 1
@


1.257
log
@2004-10-12  Paul Brook  <paul@@codesourcery.com>

bfd/
	* elf32-arm.h: Support EABI version 4 objects.
binutils/
	* readelf.c (decode_ARM_machine_flags): Support EABI version 4.
gas/
	* config/tc-arm.c (md_begin): Change EF_ARM_EABI_VER3 to
	EF_ARM_EABI_VER4.
	(arm_eabis): Ditto.
	* doc/c-arm.texi: Document that we actually support -meabi=4, not
	-meabi=3.
include/
	* elf/arm.h (EF_ARM_EABI_VER4): Define.
@
text
@d4037 2
@


1.256
log
@bfd/
	* config.bfd: Include 64-bit support for i[3-7]86-*-solaris2*.
	* elf64-x86-64.c (elf64_x86_64_section_from_shdr): New function.
	(elf_backend_section_from_shdr): Define.
binutils/
	* readelf.c (get_x86_64_section_type_name): New function.
	(get_section_type_name): Use it.
gas/
	* config/tc-i386.c: Include "elf/x86-64.h".
	(i386_elf_section_type): New function.
	* config/tc-i386.h (md_elf_section_type): Define.
	(i386_elf_section_type): New prototype.
gas/testsuite/
	* gas/i386/i386.exp: Don't run divide test for targets where '/'
	is a comment.  Run x86-64-unwind for 64-bit ELF targets.
	* gas/i386/x86-64-unwind.d, gas/i386/x86-64-unwind.s: New.
include/
	* elf/common.h (PT_SUNW_EH_FRAME): Define.
	* elf/x86-64.h (SHT_X86_64_UNWIND): Define.
ld/
	* configure.tgt: Include elf_x86_64 for i[3-7]86-*-solaris2*.
@
text
@d1770 4
@


1.255
log
@* readelf.c (get_machine_flags): Don't fall through into m68k cpu
types.
@
text
@d2408 12
d2482 3
@


1.254
log
@The patch below adds binutils support for the SHT_ARM_EXIDX, as defined by
 the ARM EABI.
@
text
@d1915 1
@


1.253
log
@binutils/
	* readelf.c (process_program_headers): Don't include .tbss in non-TLS
	segments.

ld/testsuite/
	* ld-i386/tlsbin.rd: Update for changed segment map.
	* ld-i386/tlsnopic.rd: Likewise.
	* ld-i386/tlspic.rd: Likewise.
	* ld-powerpc/tlsexe.r: Likewise.
	* ld-powerpc/tlsexe32.r: Likewise.
	* ld-powerpc/tlsexetoc.r: Likewise.
	* ld-powerpc/tlsso.r: Likewise.
	* ld-powerpc/tlsso32.r: Likewise.
	* ld-powerpc/tlstocso.r: Likewise.
	* ld-s390/tlsbin.rd: Likewise.
	* ld-s390/tlsbin_64.rd: Likewise.
	* ld-s390/tlspic.rd: Likewise.
	* ld-s390/tlspic_64.rd: Likewise.
	* ld-sh/tlsbin-2.d: Likewise.
	* ld-sh/tlspic-2.d: Likewise.
	* ld-x86-64/tlsbin.rd: Likewise.
	* ld-x86-64/tlspic.rd: Likewise.
@
text
@d2407 13
d2469 3
@


1.252
log
@	* readelf.c (decode_location_expression): Sign extend value for
	DW_OP_const1s, DW_OP_const2s, DW_OP_const4s, DW_OP_bra, DW_OP_skip.
@
text
@d3305 6
a3310 1
			     <= segment->p_offset + segment->p_filesz))))
@


1.251
log
@* MAINTAINERS: Add self as co-maintainer of FR-V.
* readelf.c (get_machine_flags): Print FR-V cpu types.
@
text
@d2 2
a3 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003, 2004 Free Software Foundation, Inc.
d27 1
a27 1
  Both programs are capabale of displaying the contents of ELF format files,
d7674 1
a7674 1
	  printf ("DW_OP_const1s: %ld", (long) byte_get (data++, 1));
d7681 1
a7681 1
	  printf ("DW_OP_const2s: %ld", (long) byte_get (data, 2));
d7689 1
a7689 1
	  printf ("DW_OP_const4s: %ld", (long) byte_get (data, 4));
d7779 1
a7779 1
	  printf ("DW_OP_bra: %ld", (long) byte_get (data, 2));
d7801 1
a7801 1
	  printf ("DW_OP_skip: %ld", (long) byte_get (data, 2));
@


1.250
log
@binutils/
	* readelf.c (debug_apply_rela_addends): New function, extracted from..
	(display_debug_info): ..here.
	(display_debug_frames): Call debug_apply_rela_addends.  Don't do
	DW_EH_PE_pcrel adjustment for ET_REL.
gas/testsuite/
	* gas/cfi/cfi-alpha-1.d: Adjust for readelf fix.
	* gas/cfi/cfi-alpha-3.d: Likewise.
	* gas/cfi/cfi-i386.d: Likewise.
	* gas/cfi/cfi-m68k.d: Likewise.
	* gas/cfi/cfi-ppc-1.d: Likewise.
	* gas/cfi/cfi-s390-1.d: Likewise.
	* gas/cfi/cfi-s390x-1.d: Likewise.
	* gas/cfi/cfi-sh-1.d: Likewise.
	* gas/cfi/cfi-sparc-1.d: Likewise.
	* gas/cfi/cfi-sparc64-1.d: Likewise.
	* gas/cfi/cfi-x86_64.d: Likewise.
@
text
@d1875 40
@


1.249
log
@	* readelf.c (dump_relocations): Fix typo when calculating
	sec_index.
@
text
@d8509 82
a8606 1
      Elf_Internal_Shdr *relsec;
d8636 2
a8637 15
      /* Apply addends of RELA relocations.  */
      for (relsec = section_headers;
	   relsec < section_headers + elf_header.e_shnum;
	   ++relsec)
	{
	  unsigned long nrelas;
	  Elf_Internal_Rela *rela, *rp;
	  Elf_Internal_Shdr *symsec;
	  Elf_Internal_Sym *symtab;
	  Elf_Internal_Sym *sym;

	  if (relsec->sh_type != SHT_RELA
	      || SECTION_HEADER (relsec->sh_info) != section
	      || relsec->sh_size == 0)
	    continue;
d8639 4
a8642 49
	  if (!slurp_rela_relocs (file, relsec->sh_offset, relsec->sh_size,
				  & rela, & nrelas))
	    return 0;

	  symsec = SECTION_HEADER (relsec->sh_link);
	  symtab = GET_ELF_SYMBOLS (file, symsec);

	  for (rp = rela; rp < rela + nrelas; ++rp)
	    {
	      unsigned char *loc;

	      if (rp->r_offset >= (bfd_vma) (hdrptr - section_begin)
		  && section->sh_size > (bfd_vma) offset_size
		  && rp->r_offset <= section->sh_size - offset_size)
		loc = section_begin + rp->r_offset;
	      else
		continue;

	      if (is_32bit_elf)
		{
		  sym = symtab + ELF32_R_SYM (rp->r_info);

		  if (ELF32_R_SYM (rp->r_info) != 0
		      && ELF32_ST_TYPE (sym->st_info) != STT_SECTION)
		    {
		      warn (_("Skipping unexpected symbol type %u\n"),
			    ELF32_ST_TYPE (sym->st_info));
		      continue;
		    }
		}
	      else
		{
		  sym = symtab + ELF64_R_SYM (rp->r_info);

		  if (ELF64_R_SYM (rp->r_info) != 0
		      && ELF64_ST_TYPE (sym->st_info) != STT_SECTION)
		    {
		      warn (_("Skipping unexpected symbol type %u\n"),
			    ELF64_ST_TYPE (sym->st_info));
		      continue;
		    }
		}

	      byte_put (loc, rp->r_addend, offset_size);
	    }

	  free (rela);
	  break;
	}
a8651 2
      cu_offset = start - section_begin;
      start += compunit.cu_length + initial_length_size;
d9041 5
d9210 4
a9213 1
	  if ((fc->fde_encoding & 0x70) == DW_EH_PE_pcrel)
d9412 2
a9413 1
	      if ((fc->fde_encoding & 0x70) == DW_EH_PE_pcrel)
@


1.248
log
@include/elf/ChangeLog:
Introduce SH2a support.
2004-02-18  Corinna Vinschen  <vinschen@@redhat.com>
* sh.h (EF_SH2A_NOFPU): New.
2003-12-01  Michael Snyder  <msnyder@@redhat.com>
* sh.h (EF_SH2A): New.
bfd/ChangeLog:
Introduce SH2a support.
2004-02-18  Corinna Vinschen  <vinschen@@redhat.com>
* archures.c (bfd_mach_sh2a_nofpu): New.
* bfd-in2.h: Rebuilt.
* cpu-sh.c (SH2A_NOFPU_NEXT): New.
(arch_info_struct): Add sh2a_nofpu.
* elf32-sh.c (sh_elf_set_mach_from_flags): Handle sh2a_nofpu.
2003-12-29  DJ Delorie  <dj@@redhat.com>
* reloc.c: Add relocs for sh2a.
* bfd-in2.h: Regenerate.
* libbfd.hh: Regenerate.
2003-12-01  Michael Snyder  <msnyder@@redhat.com>
* archures.c (bfd_mach_sh2a): New.
* bfd-in2.h: Rebuilt.
* cpu-sh.c (SH_NEXT, SH2_NEXT, etc.): Change defines to enums.
(SH2A_NEXT): New.
(arch_info_struct): Add sh2a.
* elf32-sh.c (sh_elf_set_mach_from_flags): Handle sh2a.
binutils/ChangeLog:
* readelf.c (get_machine_flags <EM_SH>): Handle EF_SH2A and
EF_SH2A_NOFPU.
gas/ChangeLog:
Introduce SH2a support.
2004-02-24  Corinna Vinschen  <vinschen@@redhat.com>
* config/tc-sh.c (get_specific): Change arch_sh2a_up to
arch_sh2a_nofpu_up.
2004-02-24  Corinna Vinschen  <vinschen@@redhat.com>
* config/tc-sh.c (md_parse_option): Add sh2a-nofpu ISA handling.
2004-02-20  Corinna Vinschen  <vinschen@@redhat.com>
* config/tc-sh.c (sh_elf_final_processing): Move sh2a recognition
to end of conditional expression.
2004-02-20  Corinna Vinschen  <vinschen@@redhat.com>
* config/tc-sh.c: Add sh2a-nofpu support.
2003-12-29  DJ Delorie  <dj@@redhat.com>
* tc-sh.c: Add sh2a support.
(parse_reg): Add tbr.
(parse_at): Support @@@@(disp,tbr).
(get_specific): Support sh2a opcodes.
(insert4): New, for 4 byte relocs.
(build_Mytes): Support sh2a opcodes.
(md_apply_fix3_Mytes): Support sh2a opcodes.
2003-12-02  Michael Snyder  <msnyder@@redhat.com>
* config/tc-sh.c (md_parse_option): Handle sh2a.
(sh_elf_final_processing): Ditto.
gas/testsuite/ChangeLog:
2003-12-30  DJ Delorie  <dj@@redhat.com>
* gas/sh/sh2a.s: New.
* gas/sh/sh2a.d: New.
* gas/sh/basic.exp: Add it.
@
text
@d1228 1
a1228 1
		      else if (psym->st_shndx > SHN_LORESERVE)
@


1.247
log
@2003-07-08  Alexandre Oliva  <aoliva@@redhat.com>
* readelf.c (get_machine_flags <EM_SH)): Handle EF_SH4_NOFPU and
EF_SH4A_NOFPU.
2003-06-12  Alexandre Oliva  <aoliva@@redhat.com>
* readelf.c (get_machine_flags <EM_SH>): Print SH ISA name.
@
text
@d2012 1
d2015 1
@


1.246
log
@Add new port: crx-elf
@
text
@d1998 21
@


1.245
log
@	* readelf.c (get_segment_type): Display "GNU_STACK", not just
	"STACK", when a PT_GNU_STACK segment is encountered.
@
text
@d108 1
d682 1
d1171 4
d1669 1
@


1.244
log
@	* readelf.c (Elf32_Word): Delete.
	(get_32bit_dynamic_section): Handle SGI ELF dynamic segment.
	(get_64bit_dynamic_section): Likewise.
@
text
@d2194 1
a2194 1
    case PT_GNU_STACK:	return "STACK";
@


1.243
log
@	* readelf.c (dynamic_nent): New variable.
	(get_32bit_dynamic_section): Set it.
	(get_64bit_dynamic_section): Here too.
	(process_dynamic_section): Use it instead of dynamic_size.
	(process_syminfo): Likewise.
@
text
@a208 2
typedef int Elf32_Word;

d1011 4
a1014 4
        case EM_68HC11:
        case EM_68HC12:
          rtype = elf_m68hc11_reloc_type (type);
          break;
d1074 3
a1076 3
        case EM_CYGNUS_FRV:
          rtype = elf_frv_reloc_type (type);
          break;
d1554 3
a1556 3
    case ET_EXEC:       return _("EXEC (Executable file)");
    case ET_DYN:        return _("DYN (Shared object file)");
    case ET_CORE:       return _("CORE (Core file)");
d3861 1
a3861 1
	      
d3887 2
a3888 2
		      get_group_flags (entry), name, group_name, size); 
	      
d3917 2
a3918 2
		} 
	      
d4666 12
a4677 1
  dynamic_nent = dynamic_size / sizeof (*ext);
a4678 1

d4687 1
a4687 1
       (char *) ext < (char *) edyn + dynamic_size;
d4710 12
a4721 1
  dynamic_nent = dynamic_size / sizeof (*ext);
a4722 1

d4731 1
a4731 1
       (char *) ext < (char *) edyn + dynamic_size;
d7129 3
a7131 3
    case DW_TAG_upc_shared_type:        return "DW_TAG_upc_shared_type";
    case DW_TAG_upc_strict_type:        return "DW_TAG_upc_strict_type";
    case DW_TAG_upc_relaxed_type:       return "DW_TAG_upc_relaxed_type";
d8157 1
a8157 1
        {
d8732 1
a8732 1
        {
d9176 1
a9176 1
	        printf (" %02x", augmentation_data[i]);
d9206 1
a9206 1
	         sure to add them to the corresponding switch below.  */
d9307 1
a9307 1
         the chunk, this time actually printing out the info.  */
@


1.242
log
@	* readelf.c (get_32bit_dynamic_section): Correct number of entries
	translated from external to internal form.
	(get_64bit_dynamic_section): Likewise.
@
text
@d122 1
d4668 2
a4669 1
  dynamic_section = malloc (dynamic_size * sizeof (Elf_Internal_Dyn));
d4702 2
a4703 1
  dynamic_section = malloc (dynamic_size * sizeof (Elf_Internal_Dyn));
a4762 1
  bfd_size_type i;
d4783 3
a4785 3
      for (i = 0, entry = dynamic_section;
	   i < dynamic_size;
	   ++i, ++entry)
d4829 3
a4831 3
      for (i = 0, entry = dynamic_section;
	   i < dynamic_size;
	   ++i, ++entry)
d4875 3
a4877 3
      for (i = 0, entry = dynamic_section;
	   i < dynamic_size;
	   ++i, ++entry)
d4894 1
a4894 1
	  Elf_External_Syminfo *extsyminfo;
d4911 3
a4913 2
	  for (i = 0, syminfo = dynamic_syminfo; i < dynamic_syminfo_nent;
	       ++i, ++syminfo)
d4915 2
a4916 2
	      syminfo->si_boundto = BYTE_GET (extsyminfo[i].si_boundto);
	      syminfo->si_flags = BYTE_GET (extsyminfo[i].si_flags);
d4924 2
a4925 2
    printf (_("\nDynamic section at offset 0x%lx contains %ld entries:\n"),
	    dynamic_addr, (long) dynamic_size);
d4929 3
a4931 3
  for (i = 0, entry = dynamic_section;
       i < dynamic_size;
       i++, entry++)
d6288 1
a6288 1
	      && dynamic_syminfo[i].si_boundto < dynamic_size)
@


1.241
log
@* readelf.c (process_program_headers): When locating the dynamic section use
  the section table if it is present.
(dynamic_segment): Renamed to dynamic_section.
Replace references to dynamic segment with references to dynamic
section, except where appropriate.
(dynamic_segment_mips_val): Rename to dynamic_section_mips_val.
(dynamic_segment_parisc_val): Rename to dynamic_section_parisc_val.
(dynamic_segment_ia64_val): Rename to dynamic_section_ia64_val.
(get_32bit_dynamic_segment): Rename to get_32bit_dynamic_section.
Remove tag counting code as it is no longer needed.
(get_64bit_dynamic_segment): Rename to get_64bit_dynamic_section.
Remove tag counting code as it is no longer needed.
(process_dynamic_segment): Rename to process_dynamic_section.
@
text
@d4659 1
a4659 1
  Elf32_External_Dyn *edyn;
a4660 1
  bfd_size_type i;
d4676 3
a4678 3
  for (i = 0, entry = dynamic_section;
       i < dynamic_size;
       i++, entry++)
d4680 2
a4681 2
      entry->d_tag      = BYTE_GET (edyn[i].d_tag);
      entry->d_un.d_val = BYTE_GET (edyn[i].d_un.d_val);
d4692 1
a4692 1
  Elf64_External_Dyn *edyn;
a4693 1
  bfd_size_type i;
d4709 3
a4711 3
  for (i = 0, entry = dynamic_section;
       i < dynamic_size;
       i++, entry++)
d4713 2
a4714 2
      entry->d_tag      = BYTE_GET8 (edyn[i].d_tag);
      entry->d_un.d_val = BYTE_GET8 (edyn[i].d_un.d_val);
@


1.240
log
@	* readelf.c (decode_ARM_machine_flags): Add EF_ARM_VFP_FLOAT.
@
text
@d136 1
a136 1
Elf_Internal_Dyn *dynamic_segment;
d2460 1
a2460 1
  -d --dynamic           Display the dynamic segment (if present)\n\
d3150 35
a3184 2
	  dynamic_addr = segment->p_offset;
	  dynamic_size = segment->p_filesz;
d4508 1
a4508 1
dynamic_segment_mips_val (Elf_Internal_Dyn *entry)
d4582 1
a4582 1
dynamic_segment_parisc_val (Elf_Internal_Dyn *entry)
d4638 1
a4638 1
dynamic_segment_ia64_val (Elf_Internal_Dyn *entry)
d4657 1
a4657 1
get_32bit_dynamic_segment (FILE *file)
d4664 1
a4664 1
		   _("dynamic segment"));
d4668 1
a4668 6
  /* SGI's ELF has more than one section in the DYNAMIC segment.  Determine
     how large this .dynamic is now.  We can do this even before the byte
     swapping since the DT_NULL tag is recognizable.  */
  dynamic_size = 0;
  while (*(Elf32_Word *) edyn[dynamic_size++].d_tag != DT_NULL)
    ;
d4670 1
a4670 3
  dynamic_segment = malloc (dynamic_size * sizeof (Elf_Internal_Dyn));

  if (dynamic_segment == NULL)
d4677 1
a4677 1
  for (i = 0, entry = dynamic_segment;
d4691 1
a4691 1
get_64bit_dynamic_segment (FILE *file)
d4698 1
a4698 1
		   _("dynamic segment"));
d4702 1
a4702 8
  /* SGI's ELF has more than one section in the DYNAMIC segment.  Determine
     how large this .dynamic is now.  We can do this even before the byte
     swapping since the DT_NULL tag is recognizable.  */
  dynamic_size = 0;
  while (*(bfd_vma *) edyn[dynamic_size++].d_tag != DT_NULL)
    ;

  dynamic_segment = malloc (dynamic_size * sizeof (Elf_Internal_Dyn));
d4704 1
a4704 1
  if (dynamic_segment == NULL)
d4711 1
a4711 1
  for (i = 0, entry = dynamic_segment;
d4756 2
a4757 1
/* Parse and display the contents of the dynamic segment.  */
d4759 1
a4759 1
process_dynamic_segment (FILE *file)
d4767 1
a4767 1
	printf (_("\nThere is no dynamic segment in this file.\n"));
d4774 1
a4774 1
      if (! get_32bit_dynamic_segment (file))
d4777 1
a4777 1
  else if (! get_64bit_dynamic_segment (file))
d4783 1
a4783 1
      for (i = 0, entry = dynamic_segment;
d4829 1
a4829 1
      for (i = 0, entry = dynamic_segment;
d4875 1
a4875 1
      for (i = 0, entry = dynamic_segment;
d4923 1
a4923 1
    printf (_("\nDynamic segment at offset 0x%lx contains %ld entries:\n"),
d4928 1
a4928 1
  for (i = 0, entry = dynamic_segment;
d5295 1
a5295 1
		  dynamic_segment_mips_val (entry);
d5298 1
a5298 1
		  dynamic_segment_parisc_val (entry);
d5301 1
a5301 1
		  dynamic_segment_ia64_val (entry);
d6291 1
a6291 1
			    + (dynamic_segment
d9727 1
a9727 1
  if (dynamic_segment == NULL)
d9731 1
a9731 1
  for (entry = dynamic_segment; entry->d_tag != DT_NULL; ++entry)
d10577 1
a10577 1
    process_dynamic_segment (file);
@


1.239
log
@Handle dwarf3 format CIE entries.
@
text
@d1832 4
@


1.238
log
@bfd/
	* elflink.c (elf_bfd_final_link): Don't output STT_SECTION symbol
	into .dynsym if elf_section_data (sec)->dynindx <= 0.
	Adjust counting of last_local.
	(_bfd_elf_link_renumber_dynsyms): Don't assign dynindx to sections
	other than SHT_PROGBITS/SHT_NOBITS and neither for .got/.got.plt/.plt
	created by the linker nor !SHF_ALLOC.

	* elf32-i386.c (elf_i386_finish_dynamic_sections): Point
	DT_PLTGOT to the start of the .got.plt section instead of the
	.got output section.  Set sh_entsize for .got section in addition
	to .got.plt.
	(elf_i386_relocate_section): Don't assume _GLOBAL_OFFSET_TABLE_
	is at sgot->output_section->vma.
	* elf64-x86-64.c (elf64_x86_64_finish_dynamic_sections): Point
	DT_PLTGOT to the start of the .got.plt section instead of the
	.got output section.
	(elf64_x86_64_relocate_section): Don't assume _GLOBAL_OFFSET_TABLE_
	is at sgot->output_section->vma.  Set sh_entsize for .got section
	in addition to .got.plt.
	* elf.c (_bfd_elf_print_private_bfd_data): Handle PT_GNU_RELRO.
	(bfd_section_from_phdr): Likewise.
	(map_sections_to_segments): Likewise.
	(assign_file_positions_for_segments): Likewise.
	(get_program_header_size): Likewise.
	* elflink.c (bfd_elf_size_dynamic_sections): Set
	elf_tdata (output_bfd)->relro from info->relro.
	* elf-bfd.h (struct elf_obj_tdata): Add relro field.
include/
	* bfdlink.h (struct bfd_link_info): Add relro, relro_start and
	relro_end fields.
	* elf/common.h (PT_GNU_EH_FRAME, PT_GNU_STACK): Add comments.
	(PT_GNU_RELRO): Define.
binutils/
	* readelf.c (get_segment_type): Handle PT_GNU_RELRO.
ld/
	* genscripts.sh: Generate -z combreloc -z now -z relro scripts
	for binaries, -shared and -pie.
	* emulparams/elf_i386.sh (SEPARATE_GOTPLT): Set.
	* emulparams/elf_x86_64.sh (SEPARATE_GOTPLT): Set.
	* emulparams/elf32ppc.sh (OTHER_READWRITE_SECTIONS): Rename to...
	(OTHER_RELRO_SECTIONS): ... this.
	* ldlex.l (DATA_SEGMENT_RELRO_END): Add.
	* emultempl/elf32.em (gld${EMULATION_NAME}_handle_option): Handle
	-z relro and -z norelro.
	(gld${EMULATION_NAME}_list_options): Add it to usage.
	(gld${EMULATION_NAME}_get_script): Return -z combreloc -z now
	-z relro scripts when appropriate.
	* scripttempl/elf.sc: Unset SEPARATE_GOTPLT if RELRO_NOW is set.
	Create separate .got.plt section if SEPARATE_GOTPLT.
	Move sections which are only written during relocation handling
	to the beginning of RW segment.  If NO_SMALL_DATA, move .got
	before .data.  Add DATA_SEGMENT_RELRO_END directive.
	Include OTHER_RELRO_SECTIONS.
	* ldgram.y (DATA_SEGMENT_RELRO_END): Add.
	* ldexp.c (exp_print_token): Handle DATA_SEGMENT_RELRO_END.
	(fold_unary): Likewise.
	(fold_binary): Handle -z relro.
	* ldexp.h (struct exp_data_seg): Add exp_dataseg_relro_seen and
	exp_dataseg_relro_adjust phases.  Add relro_end field.
	* ldmain.c (main): Initialize link_info.relro to FALSE.
	* ldlang.c (lang_size_sections): Handle -z relro.
ld/testsuite/
	* ld-i386/tlspic.rd: Adjust for section reordering changes
	and removal of unneeded STT_SECTION symbols from .dynsym.
	* ld-i386/tlspic.dd: Likewise.
	* ld-i386/tlspic.sd: Likewise.
	* ld-i386/tlsbin.rd: Likewise.
	* ld-i386/tlsbinpic.s: Likewise.
	* ld-i386/tlsbin.dd: Likewise.
	* ld-i386/tlsbin.sd: Likewise.
	* ld-i386/tlsnopic.rd: Likewise.
	* ld-i386/tlsnopic1.s: Likewise.
	* ld-i386/combreloc.d: Likewise.
	* ld-i386/tlsnopic.dd: Likewise.
	* ld-i386/tlsnopic.sd: Likewise.
	* ld-x86-64/tlspic.rd: Likewise.
	* ld-x86-64/tlspic.dd: Likewise.
	* ld-x86-64/tlsbin.dd: Likewise.
	* ld-x86-64/tlspic.sd: Likewise.
	* ld-x86-64/tlsbin.sd: Likewise.
	* ld-x86-64/tlspic.td: Likewise.
	* ld-x86-64/tlsbin.td: Likewise.
	* ld-x86-64/tlsbin.rd: Likewise.
	* ld-s390/tlspic1.s: Likewise.
	* ld-s390/tlsbinpic.s: Likewise.
	* ld-s390/tlspic.rd: Likewise.
	* ld-s390/tlsbin.rd: Likewise.
	* ld-s390/tlspic.dd: Likewise.
	* ld-s390/tlsbin.dd: Likewise.
	* ld-s390/tlsbin.sd: Likewise.
	* ld-s390/tlsbin.td: Likewise.
	* ld-s390/tlspic.sd: Likewise.
	* ld-s390/tlspic.td: Likewise.
	* ld-s390/tlspic1_64.s: Likewise.
	* ld-s390/tlsbinpic_64.s: Likewise.
	* ld-s390/tlspic_64.rd: Likewise.
	* ld-s390/tlsbin_64.rd: Likewise.
	* ld-s390/tlspic_64.dd: Likewise.
	* ld-s390/tlsbin_64.dd: Likewise.
	* ld-s390/tlspic_64.sd: Likewise.
	* ld-s390/tlspic_64.td: Likewise.
	* ld-s390/tlsbin_64.td: Likewise.
	* ld-s390/tlsbin_64.sd: Likewise.
	* ld-powerpc/tlsexe32.r: Likewise.
	* ld-powerpc/tlsso32.r: Likewise.
	* ld-powerpc/tlsso32.d: Likewise.
	* ld-powerpc/tlsso32.g: Likewise.
	* ld-powerpc/tlsso32.t: Likewise.
	* ld-powerpc/tlsexe.r: Likewise.
	* ld-powerpc/tlsso.r: Likewise.
	* ld-powerpc/tlsso.g: Likewise.
	* ld-powerpc/tlsexetoc.r: Likewise.
	* ld-powerpc/tlstocso.r: Likewise.
	* ld-powerpc/tlstocso.g: Likewise.
	* ld-ia64/tlspic.rd: Likewise.
	* ld-ia64/tlspic.dd: Likewise.
	* ld-ia64/tlspic.sd: Likewise.
	* ld-ia64/tlspic.td: Likewise.
	* ld-ia64/tlsbin.rd: Likewise.
	* ld-ia64/tlsbin.sd: Likewise.
	* ld-ia64/tlsbin.td: Likewise.
	* ld-elfvsb/elfvsb.exp: XFAIL non-PIC load offset tests on s390x.
	* ld-shared/shared.exp: Likewise.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d8971 8
a8978 1
	      fc->ra = byte_get (start, 1); start += 1;
d8988 8
a8995 1
	      fc->ra = byte_get (start, 1); start += 1;
d9001 8
a9008 1
	      fc->ra = byte_get (start, 1); start += 1;
@


1.237
log
@2004-05-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (section_groups): New.
	(group_count): New.
	(section_headers_groups): New.
	(process_section_groups): Populate group_count, section_groups
	and section_headers_groups.
	(process_unwind): Support section group.
	(process_object): Always call process_section_groups. Free
	section_groups and section_headers_groups.
@
text
@d2192 1
@


1.236
log
@2004-04-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (process_section_headers): Use %3lu on sh_info.
@
text
@d167 17
d3752 1
a3752 3

  if (!do_section_groups)
    return 1;
d3768 9
d3781 14
d3846 11
a3856 4
	  printf ("\n%s group section `%s' [%s] contains %u sections:\n",
		  get_group_flags (entry), name, group_name, size);
	  
	  printf (_("   [Index]    Name\n"));
d3859 2
d3864 22
a3885 3
	      sec = SECTION_HEADER (entry);
	      printf ("   [%5u]   %s\n",
		      entry, SECTION_NAME (sec));
d3892 2
d4373 18
a4390 2
      if (strncmp (SECTION_NAME (unwsec), ELF_STRING_ia64_unwind_once,
		   len) == 0)
d10519 2
a10520 1
  if (! process_section_headers (file))
d10522 1
a10522 1
      /* Without loaded section headers we
a10544 2
  process_section_groups (file);

d10587 23
@


1.235
log
@binutils/

2004-04-26  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (do_section_groups): New.
	(options): Add --section-groups/-g.
	(usage): Mention --section-groups/-g.
	(parse_args): Support --section-groups/-g.
	(get_group_flags): New.
	(process_section_groups): New.
	(process_object): Call process_section_groups.

gas/

2004-04-26  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-elf.c (obj_elf_change_section): Check if the old
	group name is NULL before comparison.

gas/testsuite/

2004-04-26  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/elf/elf.exp: Add group0a, group0b and group1 for section
	group.

	* gas/elf/group0.s: New file.
	* gas/elf/group0a.d: Likewise.
	* gas/elf/group0b.d: Likewise.
	* gas/elf/group1.e: Likewise.
	* gas/elf/group1.s: Likewise.
@
text
@d3634 1
a3634 1
	  printf ("%2ld %3lx %2ld\n",
d3669 1
a3669 1
	  printf ("%2ld %3lx ",
d3699 1
a3699 1
	  printf ("     %2ld   %3lx     %ld\n",
@


1.234
log
@(display_debug_pubnames): Align offset and data	columns.
(read_and_display_attr_value): Add missing break;
(debug_displays): Enable the display of the .debug_pubtypes section.
@
text
@d143 1
d2397 1
d2431 1
d2499 1
a2499 1
	  (argc, argv, "ersuahnldSDAIw::x:i:vVWH", options, NULL)) != EOF)
d2520 1
d2527 3
d2756 2
a2757 1
      && !do_histogram && !do_debugging && !do_arch && !do_notes)
d3714 118
d10459 2
@


1.233
log
@	* bfd/elf32-arm.h (arm_print_private_bfd_data): Add EABI v3.
	* binutils/readelf.c (decode_ARM_machine_flags): Add EABI v3.
	* gas/config/tc-arm.c (meabi_flags): New variable.
	(arm_parse_eabi): New function.
	(md_begin): Set flags for EABI v3.
	(arm_eabis): Add.
	(arm_long_opts): Add meabi.
	* include/elf/arm.h (EF_ERM_BE8, EF_ARM_LE8, EF_ARM_EABI_VER3): Add.
	* doc/as.texinf <ARM>: Document -meabi.
	* doc/c-arm.texi: Ditto.
@
text
@d6797 1
a6797 1
	      printf ("    %ld\t\t%s\n", offset, data);
d7971 1
d9358 1
a9358 1
  { ".debug_pubtypes",		display_debug_not_supported },
@


1.232
log
@        * readelf.c (display_debug_frames): Don't crash for mismatched
        DW_CFA_restore_state.
@
text
@d1743 27
@


1.231
log
@(process_mips_specific): Print conflictsno as an unsigned long.
@
text
@d9153 13
a9165 7
	      remembered_state = rs->next;
	      frame_need_space (fc, rs->ncols-1);
	      memcpy (fc->col_type, rs->col_type, rs->ncols);
	      memcpy (fc->col_offset, rs->col_offset, rs->ncols * sizeof (int));
	      free (rs->col_type);
	      free (rs->col_offset);
	      free (rs);
@


1.230
log
@2004-01-21  Roland McGrath  <roland@@redhat.com>

	* readelf.c (get_note_type): Match NT_AUXV.
@
text
@d9790 2
a9791 2
      printf (_("\nSection '.conflict' contains %ld entries:\n"),
	      (long) conflictsno);
@


1.230.4.1
log
@Merge to 2.15 branch.
@
text
@d6770 1
a6770 1
	      printf ("    %-6ld\t\t%s\n", offset, data);
a7943 1
      break;
d9153 7
a9159 13
	      if (rs)
		{
		  remembered_state = rs->next;
		  frame_need_space (fc, rs->ncols-1);
		  memcpy (fc->col_type, rs->col_type, rs->ncols);
		  memcpy (fc->col_offset, rs->col_offset,
			  rs->ncols * sizeof (int));
		  free (rs->col_type);
		  free (rs->col_offset);
		  free (rs);
		}
	      else if (do_debug_frames_interp)
		printf ("Mismatched DW_CFA_restore_state\n");
d9324 1
a9324 1
  { ".debug_pubtypes",		display_debug_pubnames },
d9790 2
a9791 2
      printf (_("\nSection '.conflict' contains %lu entries:\n"),
	      (unsigned long) conflictsno);
@


1.229
log
@Fix initialisation of debug_line_pointer_sizes array so that it is done as needed
@
text
@d28 1
a28 1
  
d2274 1
a2274 1
      
d3481 1
a3481 1
      
d3709 1
a3709 1
      
d4367 1
a4367 1
    case DT_IA_64_PLT_RESERVE: 
d6282 1
a6282 1
  
d6385 1
a6385 1
	     
d9895 1
@


1.228
log
@Update pointer_size patch
@
text
@d6274 20
d6300 102
d6404 1
a6404 2
		     unsigned char * start,
		     FILE *file ATTRIBUTE_UNUSED)
d6420 3
a7632 1
  unsigned int i;
d7639 2
a7640 7
  for (i = 0, sec = section_headers;
       i < elf_header.e_shnum;
       i++, sec++)
    if (strcmp (SECTION_NAME (sec), ".debug_loc") == 0)
      break;

  if (i == elf_header.e_shnum || sec->sh_size == 0)
d7663 1
a7663 2
		   unsigned char *start,
		   FILE *file ATTRIBUTE_UNUSED)
d7681 3
a7747 1
  unsigned int i;
d7754 2
a7755 7
  for (i = 0, sec = section_headers;
       i < elf_header.e_shnum;
       i++, sec++)
    if (strcmp (SECTION_NAME (sec), ".debug_str") == 0)
      break;

  if (i == elf_header.e_shnum || sec->sh_size == 0)
a8216 1
      unsigned int i;
d8340 2
a8341 7
	for (i = 0, sec = section_headers;
	     i < elf_header.e_shnum;
	     i++, sec++)
	  if (strcmp (SECTION_NAME (sec), ".debug_abbrev") == 0)
	    break;

	if (i == elf_header.e_shnum || sec->sh_size == 0)
d9305 2
a9306 91
/* Pre-scan the .debug_info section to record the pointer sizes for the
   compilation units.  Usually an executable will have just one pointer
   size, but this is not guaranteed, and so we try not to make any
   assumptions.  Returns zero upon failure, or the number of compilation
   units upon success.  */

static unsigned int
prescan_debug_info (Elf_Internal_Shdr *section, unsigned char *start,
		    FILE *file ATTRIBUTE_UNUSED)
{
  unsigned char *begin;
  unsigned char *end = start + section->sh_size;
  unsigned long  length;
  unsigned int   num_units;
  unsigned int   unit;
    
  /* First scan the section to compute the number of comp units.  */
  for (begin = start, num_units = 0; begin < end; num_units++)
    {
      /* Read the first 4 bytes.  For a 32-bit DWARF section, this will
	 be the length.  For a 64-bit DWARF section, it'll be the escape
	 code 0xffffffff followed by an 8 byte length.  */
      length = byte_get (begin, 4);

      if (length == 0xffffffff)
	{
	  length = byte_get (begin + 4, 8);
	  begin += length + 12;
	}
      else
	begin += length + 4;
    }

  if (num_units == 0)
    {
      error (_("No comp units in .debug_info section ?"));
      return 0;
    }

  /* Then allocate an array to hold the pointer sizes.  */
  debug_line_pointer_sizes = malloc (num_units * sizeof * debug_line_pointer_sizes);
  if (debug_line_pointer_sizes == NULL)
    {
      error (_("Not enough memory for a pointer size array of %u entries"),
	     num_units);
      return 0;
    }

  /* Populate the array.  */
  for (begin = start, unit = 0; begin < end; unit++)
    {
      length = byte_get (begin, 4);
      if (length == 0xffffffff)
	{
	  /* For 64-bit DWARF, the 1-byte address_size field is 22 bytes
	     from the start of the section.  This is computed as follows:

	     unit_length:         12 bytes
	     version:              2 bytes
	     debug_abbrev_offset:  8 bytes
	     -----------------------------
	     Total:               22 bytes  */

	  debug_line_pointer_sizes [unit] = byte_get (begin + 22, 1);
	  length = byte_get (begin + 4, 8);
	  begin += length + 12;
	}
      else
	{
	  /* For 32-bit DWARF, the 1-byte address_size field is 10 bytes from
	     the start of the section:
	     
	     unit_length:          4 bytes
	     version:              2 bytes
	     debug_abbrev_offset:  4 bytes
	     -----------------------------
	     Total:               10 bytes  */

	  debug_line_pointer_sizes [unit] = byte_get (begin + 10, 1);
	  begin += length + 4;
	}
    }

  num_debug_line_pointer_sizes = num_units;
  return num_units;
}

/* A structure containing the name of a debug section and a pointer
   to a function that can decode it.  The third field is a prescan
   function to be run over the section before displaying any of the
   sections.  */
a9310 1
  int (*prescan) (Elf_Internal_Shdr *, unsigned char *, FILE *);
d9314 16
a9329 16
  { ".debug_abbrev",		display_debug_abbrev, NULL },
  { ".debug_aranges",		display_debug_aranges, NULL },
  { ".debug_frame",		display_debug_frames, NULL },
  { ".debug_info",		display_debug_info, prescan_debug_info },
  { ".debug_line",		display_debug_lines, NULL },
  { ".debug_pubnames",		display_debug_pubnames, NULL },
  { ".eh_frame",		display_debug_frames, NULL },
  { ".debug_macinfo",		display_debug_macinfo, NULL },
  { ".debug_str",		display_debug_str, NULL },
  { ".debug_loc",		display_debug_loc, NULL },
  { ".debug_pubtypes",		display_debug_not_supported, NULL },
  { ".debug_ranges",		display_debug_not_supported, NULL },
  { ".debug_static_func",	display_debug_not_supported, NULL },
  { ".debug_static_vars",	display_debug_not_supported, NULL },
  { ".debug_types",		display_debug_not_supported, NULL },
  { ".debug_weaknames",		display_debug_not_supported, NULL }
a9382 36

  /* Pre-scan the debug sections to find some debug information not
     present in some of them.  For the .debug_line, we must find out the
     size of address (specified in .debug_info and .debug_aranges).  */
  for (i = 0, section = section_headers;
       i < elf_header.e_shnum && i < num_dump_sects;
       i++, section++)
    {
      char *name = SECTION_NAME (section);
      int j;

      if (section->sh_size == 0)
	continue;

      /* See if there is some pre-scan operation for this section.  */
      for (j = NUM_ELEM (debug_displays); j--;)
	if (strcmp (debug_displays[j].name, name) == 0)
	  {
	    if (debug_displays[j].prescan != NULL)
	      {
		bfd_size_type length;
		unsigned char *start;

		length = section->sh_size;
		start = get_data (NULL, file, section->sh_offset, length,
				  _("debug section data"));
		if (!start)
		  return 0;

		debug_displays[j].prescan (section, start, file);
		free (start);
	      }

	    break;
	  }
    }
@


1.227
log
@Add support for m32r-linux target, including a RELA ABI and PIC.
@
text
@d6277 2
a6278 1
static int debug_line_pointer_size = 4;
d6294 1
d6301 2
d6356 13
d6377 1
d6470 1
a6470 1
						debug_line_pointer_size);
d7552 1
d7573 1
d7577 13
d7592 4
a7595 10
	  /* Normally, the lists in the debug_loc section are related to a
	     given compilation unit, and thus, we would use the pointer size
	     of that compilation unit.  However, since we are displaying it
	     separately here, we either have to store pointer sizes of all
	     compilation units, or assume they don't change.   We assume,
	     like the debug_line display, that it doesn't change.  */
	  begin = byte_get (start, debug_line_pointer_size);
	  start += debug_line_pointer_size;
	  end = byte_get (start, debug_line_pointer_size);
	  start += debug_line_pointer_size;
d7611 1
a7611 1
	  decode_location_expression (start, debug_line_pointer_size, length);
d9197 8
a9204 6
/* Pre-scan the .debug_info section to record the size of address.
   When dumping the .debug_line, we use that size information, assuming
   that all compilation units have the same address size.  */
static int
prescan_debug_info (Elf_Internal_Shdr *section ATTRIBUTE_UNUSED,
		    unsigned char *start,
d9207 22
a9228 1
  unsigned long length;
d9230 5
a9234 18
  /* Read the first 4 bytes.  For a 32-bit DWARF section, this will
     be the length.  For a 64-bit DWARF section, it'll be the escape
     code 0xffffffff followed by an 8 byte length.  For the purposes
     of this prescan, we don't care about the actual length, but the
     presence of the escape bytes does affect the location of the byte
     which describes the address size.  */
  length = byte_get (start, 4);

  if (length == 0xffffffff)
    {
      /* For 64-bit DWARF, the 1-byte address_size field is 22 bytes
         from the start of the section.  This is computed as follows:

	    unit_length:         12 bytes
	    version:              2 bytes
	    debug_abbrev_offset:  8 bytes
	    -----------------------------
	    Total:               22 bytes  */
d9236 7
a9242 1
      debug_line_pointer_size = byte_get (start + 22, 1);
d9244 3
a9246 1
  else
d9248 40
a9287 17
      /* For 32-bit DWARF, the 1-byte address_size field is 10 bytes from
         the start of the section:
	    unit_length:          4 bytes
	    version:              2 bytes
	    debug_abbrev_offset:  4 bytes
	    -----------------------------
	    Total:               10 bytes  */

      debug_line_pointer_size = byte_get (start + 10, 1);
    }
  return 0;
}

  /* A structure containing the name of a debug section and a pointer
     to a function that can decode it.  The third field is a prescan
     function to be run over the section before displaying any of the
     sections.  */
@


1.226
log
@Add a comment describing the difference between	readelf and objdump.
@
text
@a620 1
    case EM_M32R:
d670 1
@


1.225
log
@Use consistent error messages for missing files.
Detect directories where an ordinary file is expected.
@
text
@d24 1
d26 17
@


1.224
log
@Do not dump the contents of SHT_NOBITS sections - they have no file space
assigned to their contents.
@
text
@d10460 11
a10470 1
      error (_("Cannot stat input file %s.\n"), file_name);
d10477 1
a10477 1
      error (_("Input file %s not found.\n"), file_name);
@


1.223
log
@	* readelf.c (dump_section): Don't display DEL characters.
@
text
@d6058 1
a6058 1
  if (bytes == 0)
@


1.222
log
@	* ChangeLog: Fix typos.
	* ChangeLog-9197: Likewise.
	* ChangeLog-9899: Likewise.
	* NEWS: Likewise.
	* ar.c: Fix comment typos.
	* arsup.c: Likewise.
	* coffgrok.c: Likewise.
	* debug.c: Likewise.
	* debug.h: Likewise.
	* dlltool.c: Likewise.
	* ieee.c: Likewise.
	* nm.c: Likewise.
	* objdump.c: Likewise.
	* prdbg.c: Likewise.
	* readelf.c: Likewise.
	* resrc.c: Likewise.
	* sysinfo.y: Likewise.
	* windres.c: Likewise.
@
text
@d6118 1
a6118 1
	  if (k >= ' ' && k < 0x80)
@


1.221
log
@[ bfd/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* archures.c (bfd_mach_mipsisa64r2): New define.
	* bfd-in2.h: Regenerate.
	* aoutx.h (NAME(aout,machine_type)): Handle bfd_mach_mipsisa64r2.
	* cpu-mips.c (I_mipsisa64r2): New enum value.
	(arch_info_struct): Add entry for I_mipsisa64r2.
	* elfxx-mips.c (_bfd_elf_mips_mach)
	(_bfd_mips_elf_print_private_bfd_data): Handle E_MIPS_ARCH_64R2.
	(mips_set_isa_flags): Add bfd_mach_mipsisa64r2 case.
	(mips_mach_extensions): Add entry for bfd_mach_mipsisa64r2.

[ binutils/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* readelf.c (get_machine_flags): Handle E_MIPS_ARCH_64R2.

[ gas/Changelog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* configure.in (mipsisa64r2, mipsisa64r2el, mipsisa64r2*): New CPUs.
	* configure: Regenerate.
	* config/tc-mips.c (imm2_expr): New variable.
	(md_assemble, mips16_ip): Initialize imm2_expr.
	(ISA_HAS_64BIT_REGS, ISA_HAS_DROR, ISA_HAS_ROR): Add ISA_MIPS64R2.
	(macro_build): Handle +A, +B, +C, +E, +F, +G, and +H format operands.
	(macro): Handle M_DEXT and M_DINS.
	(validate_mips_insn): Handle +E, +F, +G, +H, and +I format operands.
	(mips_ip): Likewise.
	(OPTION_MIPS64R2): New define.
	(md_longopts): New entry for -mips64r2 (OPTION_MIPS64R2).
	OPTION_ASE_BASE): Increase to compensate for OPTION_MIPS64R2.
	(md_parse_option): Handle OPTION_MIPS64R2.
	(s_mipsset): Handle setting "mips64r2" ISA.
	(mips_cpu_info_table): Add mips64r2.
	(md_show_usage): Document -mips64r2 option.
	* doc/as.texinfo: Docuemnt -mips64r2 option.
	* doc/c-mips.texi: Likewise.

[ gas/testsuite/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* gas/mips/cp0-names-mips64r2.d: New file.
	* gas/mips/cp0sel-names-mips64r2.d: New file.
	* gas/mips/elf_arch_mips64r2.d: New file.
	* gas/mips/hwr-names-mips64r2.d: New file.
	* gas/mips/mips32r2-ill-fp64.l: New file.
	* gas/mips/mips32r2-ill-fp64.s: New file.
	* gas/mips/mips64r2-ill.l: New file.
	* gas/mips/mips64r2-ill.s: New file.
	* gas/mips/mips64r2.d: New file.
	* gas/mips/mips64r2.s: New file.
	* gas/mips/mips.exp: Define "mips64r2" arch, and run new tests.

[ include/elf/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* mips.h (E_MIPS_ARCH_64R2): New define.

[ include/opcode/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* mips.h: Document +E, +F, +G, +H, and +I operand types.
	Update documentation of I, +B and +C operand types.
	(INSN_ISA64R2, ISA_MIPS64R2, CPU_MIPS64R2): New defines.
	(M_DEXT, M_DINS): New enum values.

[ ld/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* ldmain.c (get_emulation): Ignore "-mips64r2".

[ ld/testsuite/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* ld-mips-elf/mips-elf-flags.exp: Add tests for combinations
	with MIPS64r2.

[ opcodes/ChangeLog ]
2003-09-30  Chris Demetriou  <cgd@@broadcom.com>

	* mips-dis.c (mips_arch_choices): Add entry for "mips64r2"
	(print_insn_args): Add handing for +E, +F, +G, and +H.
	* mips-opc.c (I65): New define for MIPS64r2.
	(mips_builtin_opcodes): Add "dext", "dextm", "dextu", "dins",
	"dinsm", "dinsu", "drotl", "drotr", "drotr32", "drotrv", "dsbh",
	and "dshd" for MIPS64r2.  Adjust "dror", "dror32", and "drorv" to
	be supported on MIPS64r2.
@
text
@d313 1
a313 1
	 in an internal strcuture.  */
d539 1
a539 1
	 in an internal strcuture.  */
d6850 1
a6850 1
/* FIXME:  There are better and more effiecint ways to handle
d7544 1
a7544 1
	     seperately here, we either have to store pointer sizes of all
d7846 1
a7846 1
  /* For some attributes we can display futher information.  */
d10138 1
a10138 1
	 overwritting things.  */
@


1.220
log
@2003-09-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (dump_relocations): Support SHN_IA_64_ANSI_COMMON.
	(get_symbol_index_type): Likewise.

testsuites/

2003-09-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* binutils-all/readelf.exp: Use is_elf_format.

	* binutils-all/readelf.h: Support IA64/ILP32.
	* binutils-all/readelf.s: Likewise.
	* binutils-all/readelf.ss: Likewise.

	* lib/utils-lib.exp (proc is_elf_format): Copy from ld
	testsuite. Add ia64-*-hpux*.
@
text
@d1919 1
@


1.219
log
@2003-09-25  H.J. Lu  <hongjiu.lu@@intel.com>

	* readelf.c (process_version_sections): Indent version names.
@
text
@d1197 4
d5557 5
a5561 1
      if (type >= SHN_LOPROC && type <= SHN_HIPROC)
@


1.218
log
@Add binutils support for v850e1 processor
@
text
@d5229 1
a5229 1
		      printf (_("  %#06x: Name: %s"),
d5232 1
a5232 1
		      printf (_("  %#06x: Name index: %lx"),
@


1.217
log
@	* readelf.c (process_archive): Fix error handling.  Remove memory
	leak.
@
text
@d1820 3
@


1.216
log
@Add ability for readelf to parse archives
@
text
@d10278 1
d10330 1
d10341 2
d10352 1
d10368 2
a10369 1
	      return 1;
d10384 2
a10385 1
	  return 1;
d10392 2
a10393 1
	  return 1;
d10405 1
a10405 1
      process_object (namealc, file);
d10416 2
a10417 1
	  return 1;
d10424 1
a10424 1
	    return 0;
d10427 2
a10428 1
	  return 1;
d10435 1
a10435 1
  return 0;
@


1.215
log
@	* objcopy.c: Remove unnecessary prototypes and casts.
	* objdump.c: Remove unnecessary casts.
	* readelf.c: Convert to C90.  Remove unnecessary prototypes and casts.
	(get_osabi_name): Move so we don't need a forward declaration.
@
text
@d93 2
d100 2
d251 1
a251 1
  if (fseek (file, offset, SEEK_SET))
d253 2
a254 1
      error (_("Unable to seek to 0x%x for %s\n"), offset, reason);
d3072 2
a3073 1
	  if (fseek (file, (long) segment->p_offset, SEEK_SET))
d4512 9
a4520 2
	  if (fseek (file, 0, SEEK_END))
	    error (_("Unable to seek to end of file!"));
a4521 1
	  section.sh_size = ftell (file) - section.sh_offset;
d4559 9
a4567 3
	  if (fseek (file, 0, SEEK_END))
	    error (_("Unable to seek to end of file\n"));
	  str_tab_len = ftell (file) - offset;
d5619 4
a5622 2
      if (fseek (file, offset_from_vma (file, dynamic_info[DT_HASH],
					sizeof nb + sizeof nc),
d10165 4
d10170 1
a10170 1
process_file (char *file_name)
a10171 2
  FILE *file;
  struct stat statbuf;
a10173 13
  if (stat (file_name, & statbuf) < 0)
    {
      error (_("Cannot stat input file %s.\n"), file_name);
      return 1;
    }

  file = fopen (file_name, "rb");
  if (file == NULL)
    {
      error (_("Input file %s not found.\n"), file_name);
      return 1;
    }

a10176 1
      fclose (file);
d10192 1
a10192 4
    {
      fclose (file);
      return 1;
    }
a10224 2
  fclose (file);

d10264 204
@


1.214
log
@* readelf.c (get_data): Print (unsigned) hex values for size and offset in
  error messages.
  (process_section_headers): If the string table could not be allocated, do
  not continue.
@
text
@d165 2
a166 234
/* Forward declarations for dumb compilers.  */
static void print_vma
  PARAMS ((bfd_vma, print_mode));
static void print_symbol
  PARAMS ((int, const char *));
static bfd_vma (*byte_get)
  PARAMS ((unsigned char *, int));
static bfd_vma byte_get_little_endian
  PARAMS ((unsigned char *, int));
static bfd_vma byte_get_big_endian
  PARAMS ((unsigned char *, int));
static bfd_vma byte_get_signed
  PARAMS ((unsigned char *, int));
static void (*byte_put)
  PARAMS ((unsigned char *, bfd_vma, int));
static void byte_put_little_endian
  PARAMS ((unsigned char *, bfd_vma, int));
static void byte_put_big_endian
  PARAMS ((unsigned char *, bfd_vma, int));
static const char *get_mips_dynamic_type
  PARAMS ((unsigned long));
static const char *get_sparc64_dynamic_type
  PARAMS ((unsigned long));
static const char *get_ppc64_dynamic_type
  PARAMS ((unsigned long));
static const char *get_parisc_dynamic_type
  PARAMS ((unsigned long));
static const char *get_ia64_dynamic_type
  PARAMS ((unsigned long));
static const char *get_dynamic_type
  PARAMS ((unsigned long));
static int slurp_rela_relocs
  PARAMS ((FILE *, unsigned long, unsigned long, Elf_Internal_Rela **,
	   unsigned long *));
static int slurp_rel_relocs
  PARAMS ((FILE *, unsigned long, unsigned long, Elf_Internal_Rela **,
	   unsigned long *));
static int dump_relocations
  PARAMS ((FILE *, unsigned long, unsigned long, Elf_Internal_Sym *,
	   unsigned long, char *, int));
static char *get_file_type
  PARAMS ((unsigned));
static char *get_machine_name
  PARAMS ((unsigned));
static void decode_ARM_machine_flags
  PARAMS ((unsigned, char[]));
static char *get_machine_flags
  PARAMS ((unsigned, unsigned));
static const char *get_mips_segment_type
  PARAMS ((unsigned long));
static const char *get_parisc_segment_type
  PARAMS ((unsigned long));
static const char *get_ia64_segment_type
  PARAMS ((unsigned long));
static const char *get_segment_type
  PARAMS ((unsigned long));
static const char *get_mips_section_type_name
  PARAMS ((unsigned int));
static const char *get_parisc_section_type_name
  PARAMS ((unsigned int));
static const char *get_ia64_section_type_name
  PARAMS ((unsigned int));
static const char *get_section_type_name
  PARAMS ((unsigned int));
static const char *get_symbol_binding
  PARAMS ((unsigned int));
static const char *get_symbol_type
  PARAMS ((unsigned int));
static const char *get_symbol_visibility
  PARAMS ((unsigned int));
static const char *get_symbol_index_type
  PARAMS ((unsigned int));
static const char *get_dynamic_flags
  PARAMS ((bfd_vma));
static void usage
  PARAMS ((void));
static void parse_args
  PARAMS ((int, char **));
static int process_file_header
  PARAMS ((void));
static int process_program_headers
  PARAMS ((FILE *));
static int process_section_headers
  PARAMS ((FILE *));
static int process_unwind
  PARAMS ((FILE *));
static void dynamic_segment_mips_val
  PARAMS ((Elf_Internal_Dyn *));
static void dynamic_segment_parisc_val
  PARAMS ((Elf_Internal_Dyn *));
static void dynamic_segment_ia64_val
  PARAMS ((Elf_Internal_Dyn *));
static int process_dynamic_segment
  PARAMS ((FILE *));
static int process_symbol_table
  PARAMS ((FILE *));
static int process_syminfo
  PARAMS ((FILE *));
static int process_section_contents
  PARAMS ((FILE *));
static void process_mips_fpe_exception
  PARAMS ((int));
static int process_mips_specific
  PARAMS ((FILE *));
static int process_file
  PARAMS ((char *));
static int process_relocs
  PARAMS ((FILE *));
static int process_version_sections
  PARAMS ((FILE *));
static char *get_ver_flags
  PARAMS ((unsigned int));
static int get_32bit_section_headers
  PARAMS ((FILE *, unsigned int));
static int get_64bit_section_headers
  PARAMS ((FILE *, unsigned int));
static int get_32bit_program_headers
  PARAMS ((FILE *, Elf_Internal_Phdr *));
static int get_64bit_program_headers
  PARAMS ((FILE *, Elf_Internal_Phdr *));
static int get_program_headers
  PARAMS ((FILE *));
static int get_file_header
  PARAMS ((FILE *));
static Elf_Internal_Sym *get_32bit_elf_symbols
  PARAMS ((FILE *, Elf_Internal_Shdr *));
static Elf_Internal_Sym *get_64bit_elf_symbols
  PARAMS ((FILE *, Elf_Internal_Shdr *));
static const char *get_elf_section_flags
  PARAMS ((bfd_vma));
static int *get_dynamic_data
  PARAMS ((FILE *, unsigned int));
static int get_32bit_dynamic_segment
  PARAMS ((FILE *));
static int get_64bit_dynamic_segment
  PARAMS ((FILE *));
static long offset_from_vma
  PARAMS ((FILE *, bfd_vma vma, bfd_size_type size));
#ifdef SUPPORT_DISASSEMBLY
static int disassemble_section
  PARAMS ((Elf_Internal_Shdr *, FILE *));
#endif
static int dump_section
  PARAMS ((Elf_Internal_Shdr *, FILE *));
static int display_debug_section
  PARAMS ((Elf_Internal_Shdr *, FILE *));
static int display_debug_info
  PARAMS ((Elf_Internal_Shdr *, unsigned char *, FILE *));
static int display_debug_not_supported
  PARAMS ((Elf_Internal_Shdr *, unsigned char *, FILE *));
static int prescan_debug_info
  PARAMS ((Elf_Internal_Shdr *, unsigned char *, FILE *));
static int display_debug_lines
  PARAMS ((Elf_Internal_Shdr *, unsigned char *, FILE *));
static int display_debug_pubnames
  PARAMS ((Elf_Internal_Shdr *, unsigned char *, FILE *));
static int display_debug_abbrev
  PARAMS ((Elf_Internal_Shdr *, unsigned char *, FILE *));
static int display_debug_aranges
  PARAMS ((Elf_Internal_Shdr *, unsigned char *, FILE *));
static int display_debug_frames
  PARAMS ((Elf_Internal_Shdr *, unsigned char *, FILE *));
static int display_debug_macinfo
  PARAMS ((Elf_Internal_Shdr *, unsigned char *, FILE *));
static int display_debug_str
  PARAMS ((Elf_Internal_Shdr *, unsigned char *, FILE *));
static int display_debug_loc
  PARAMS ((Elf_Internal_Shdr *, unsigned char *, FILE *));
static unsigned char *process_abbrev_section
  PARAMS ((unsigned char *, unsigned char *));
static void load_debug_str
  PARAMS ((FILE *));
static void free_debug_str
  PARAMS ((void));
static const char *fetch_indirect_string
  PARAMS ((unsigned long));
static void load_debug_loc
  PARAMS ((FILE *));
static void free_debug_loc
  PARAMS ((void));
static unsigned long read_leb128
  PARAMS ((unsigned char *, int *, int));
static int process_extended_line_op
  PARAMS ((unsigned char *, int, int));
static void reset_state_machine
  PARAMS ((int));
static char *get_TAG_name
  PARAMS ((unsigned long));
static char *get_AT_name
  PARAMS ((unsigned long));
static char *get_FORM_name
  PARAMS ((unsigned long));
static void free_abbrevs
  PARAMS ((void));
static void add_abbrev
  PARAMS ((unsigned long, unsigned long, int));
static void add_abbrev_attr
  PARAMS ((unsigned long, unsigned long));
static unsigned char *read_and_display_attr
  PARAMS ((unsigned long, unsigned long, unsigned char *, unsigned long,
	   unsigned long, unsigned long, int));
static unsigned char *read_and_display_attr_value
  PARAMS ((unsigned long, unsigned long, unsigned char *, unsigned long,
	   unsigned long, unsigned long, int));
static unsigned char *display_block
  PARAMS ((unsigned char *, unsigned long));
static void decode_location_expression
  PARAMS ((unsigned char *, unsigned int, unsigned long));
static void request_dump
  PARAMS ((unsigned int, int));
static const char *get_elf_class
  PARAMS ((unsigned int));
static const char *get_data_encoding
  PARAMS ((unsigned int));
static const char *get_osabi_name
  PARAMS ((unsigned int));
static int guess_is_rela
  PARAMS ((unsigned long));
static const char *get_note_type
  PARAMS ((unsigned int));
static const char *get_netbsd_elfcore_note_type
  PARAMS ((unsigned int));
static int process_note
  PARAMS ((Elf_Internal_Note *));
static int process_corefile_note_segment
  PARAMS ((FILE *, bfd_vma, bfd_vma));
static int process_corefile_note_segments
  PARAMS ((FILE *));
static int process_corefile_contents
  PARAMS ((FILE *));
static int process_arch_specific
  PARAMS ((FILE *));
static int process_gnu_liblist
  PARAMS ((FILE *));
d218 1
a218 1
error VPARAMS ((const char *message, ...))
d220 1
a220 2
  VA_OPEN (args, message);
  VA_FIXEDARG (args, const char *, message);
d222 1
d225 1
a225 1
  VA_CLOSE (args);
d229 1
a229 1
warn VPARAMS ((const char *message, ...))
d231 1
a231 2
  VA_OPEN (args, message);
  VA_FIXEDARG (args, const char *, message);
d233 1
d236 1
a236 1
  VA_CLOSE (args);
d239 2
a240 9
static PTR get_data PARAMS ((PTR, FILE *, long, size_t, const char *));

static PTR
get_data (var, file, offset, size, reason)
     PTR var;
     FILE *file;
     long offset;
     size_t size;
     const char *reason;
d242 1
a242 1
  PTR mvar;
d256 1
a256 1
      mvar = (PTR) malloc (size);
d278 1
a278 3
byte_get_little_endian (field, size)
     unsigned char *field;
     int size;
d325 1
a325 3
byte_get_signed (field, size)
     unsigned char *field;
     int size;
d346 1
a346 4
byte_put_little_endian (field, value, size)
     unsigned char * field;
     bfd_vma	     value;
     int             size;
d375 1
a375 3
print_vma (vma, mode)
     bfd_vma vma;
     print_mode mode;
d493 1
a493 3
print_symbol (width, symbol)
     int width;
     const char *symbol;
d504 1
a504 3
byte_get_big_endian (field, size)
     unsigned char *field;
     int size;
d552 1
a552 4
byte_put_big_endian (field, value, size)
     unsigned char * field;
     bfd_vma	     value;
     int             size;
d586 1
a586 2
guess_is_rela (e_machine)
     unsigned long e_machine;
d674 5
a678 6
slurp_rela_relocs (file, rel_offset, rel_size, relasp, nrelasp)
     FILE *file;
     unsigned long rel_offset;
     unsigned long rel_size;
     Elf_Internal_Rela **relasp;
     unsigned long *nrelasp;
d688 1
a688 2
      erelas = (Elf32_External_Rela *) get_data (NULL, file, rel_offset,
						 rel_size, _("relocs"));
d694 1
a694 2
      relas = (Elf_Internal_Rela *)
	malloc (nrelas * sizeof (Elf_Internal_Rela));
d715 1
a715 2
      erelas = (Elf64_External_Rela *) get_data (NULL, file, rel_offset,
						 rel_size, _("relocs"));
d721 1
a721 2
      relas = (Elf_Internal_Rela *)
	malloc (nrelas * sizeof (Elf_Internal_Rela));
d744 5
a748 6
slurp_rel_relocs (file, rel_offset, rel_size, relsp, nrelsp)
     FILE *file;
     unsigned long rel_offset;
     unsigned long rel_size;
     Elf_Internal_Rela **relsp;
     unsigned long *nrelsp;
d758 1
a758 2
      erels = (Elf32_External_Rel *) get_data (NULL, file, rel_offset,
					       rel_size, _("relocs"));
d764 1
a764 1
      rels = (Elf_Internal_Rela *) malloc (nrels * sizeof (Elf_Internal_Rela));
d785 1
a785 2
      erels = (Elf64_External_Rel *) get_data (NULL, file, rel_offset,
					       rel_size, _("relocs"));
d791 1
a791 1
      rels = (Elf_Internal_Rela *) malloc (nrels * sizeof (Elf_Internal_Rela));
d813 2
a814 1
/* Display the contents of the relocation data found at the specified offset.  */
d817 7
a823 8
dump_relocations (file, rel_offset, rel_size, symtab, nsyms, strtab, is_rela)
     FILE *file;
     unsigned long rel_offset;
     unsigned long rel_size;
     Elf_Internal_Sym *symtab;
     unsigned long nsyms;
     char *strtab;
     int is_rela;
d887 2
a888 2
      bfd_vma type2 = (bfd_vma) NULL;
      bfd_vma type3 = (bfd_vma) NULL;
d1256 1
a1256 2
get_mips_dynamic_type (type)
     unsigned long type;
d1309 1
a1309 2
get_sparc64_dynamic_type (type)
     unsigned long type;
d1320 1
a1320 2
get_ppc64_dynamic_type (type)
     unsigned long type;
d1333 1
a1333 2
get_parisc_dynamic_type (type)
     unsigned long type;
d1356 1
a1356 2
get_ia64_dynamic_type (type)
     unsigned long type;
d1367 1
a1367 2
get_dynamic_type (type)
     unsigned long type;
d1502 1
a1502 2
get_file_type (e_type)
     unsigned e_type;
d1526 1
a1526 2
get_machine_name (e_machine)
     unsigned e_machine;
d1632 1
a1632 3
decode_ARM_machine_flags (e_flags, buf)
     unsigned e_flags;
     char buf[];
d1776 1
a1776 3
get_machine_flags (e_flags, e_machine)
     unsigned e_flags;
     unsigned e_machine;
d2006 31
a2036 2
get_mips_segment_type (type)
     unsigned long type;
d2054 1
a2054 2
get_parisc_segment_type (type)
     unsigned long type;
d2080 1
a2080 2
get_ia64_segment_type (type)
     unsigned long type;
d2098 1
a2098 2
get_segment_type (p_type)
     unsigned long p_type;
d2174 1
a2174 2
get_mips_section_type_name (sh_type)
     unsigned int sh_type;
d2224 1
a2224 2
get_parisc_section_type_name (sh_type)
     unsigned int sh_type;
d2238 1
a2238 2
get_ia64_section_type_name (sh_type)
     unsigned int sh_type;
d2256 1
a2256 2
get_section_type_name (sh_type)
     unsigned int sh_type;
d2360 1
a2360 1
usage ()
d2401 1
a2401 3
request_dump (section, type)
     unsigned int section;
     int type;
d2407 1
a2407 1
      new_dump_sects = (char *) calloc (section + 1, 1);
d2430 1
a2430 3
parse_args (argc, argv)
     int argc;
     char **argv;
d2701 1
a2701 2
get_elf_class (elf_class)
     unsigned int elf_class;
d2717 1
a2717 2
get_data_encoding (encoding)
     unsigned int encoding;
a2731 31
static const char *
get_osabi_name (osabi)
     unsigned int osabi;
{
  static char buff[32];

  switch (osabi)
    {
    case ELFOSABI_NONE:		return "UNIX - System V";
    case ELFOSABI_HPUX:		return "UNIX - HP-UX";
    case ELFOSABI_NETBSD:	return "UNIX - NetBSD";
    case ELFOSABI_LINUX:	return "UNIX - Linux";
    case ELFOSABI_HURD:		return "GNU/Hurd";
    case ELFOSABI_SOLARIS:	return "UNIX - Solaris";
    case ELFOSABI_AIX:		return "UNIX - AIX";
    case ELFOSABI_IRIX:		return "UNIX - IRIX";
    case ELFOSABI_FREEBSD:	return "UNIX - FreeBSD";
    case ELFOSABI_TRU64:	return "UNIX - TRU64";
    case ELFOSABI_MODESTO:	return "Novell - Modesto";
    case ELFOSABI_OPENBSD:	return "UNIX - OpenBSD";
    case ELFOSABI_OPENVMS:	return "VMS - OpenVMS";
    case ELFOSABI_NSK:		return "HP - Non-Stop Kernel";
    case ELFOSABI_AROS:		return "Amiga Research OS";
    case ELFOSABI_STANDALONE:	return _("Standalone App");
    case ELFOSABI_ARM:		return "ARM";
    default:
      sprintf (buff, _("<unknown: %x>"), osabi);
      return buff;
    }
}

d2735 1
a2735 1
process_file_header ()
d2824 1
a2824 3
get_32bit_program_headers (file, program_headers)
     FILE *file;
     Elf_Internal_Phdr *program_headers;
d2831 3
a2833 4
  phdrs = ((Elf32_External_Phdr *)
	   get_data (NULL, file, elf_header.e_phoff,
		     elf_header.e_phentsize * elf_header.e_phnum,
		     _("program headers")));
d2857 1
a2857 3
get_64bit_program_headers (file, program_headers)
     FILE *file;
     Elf_Internal_Phdr *program_headers;
d2864 3
a2866 4
  phdrs = ((Elf64_External_Phdr *)
	   get_data (NULL, file, elf_header.e_phoff,
		     elf_header.e_phentsize * elf_header.e_phnum,
		     _("program headers")));
d2892 1
a2892 2
get_program_headers (file)
     FILE *file;
d2900 1
a2900 2
  phdrs = (Elf_Internal_Phdr *) malloc
    (elf_header.e_phnum * sizeof (Elf_Internal_Phdr));
d2923 1
a2923 2
process_program_headers (file)
     FILE *file;
d3128 1
a3128 4
offset_from_vma (file, vma, size)
     FILE *file;
     bfd_vma vma;
     bfd_size_type size;
d3157 1
a3157 3
get_32bit_section_headers (file, num)
     FILE *file;
     unsigned int num;
d3163 2
a3164 4
  shdrs = ((Elf32_External_Shdr *)
	   get_data (NULL, file, elf_header.e_shoff,
		     elf_header.e_shentsize * num,
		     _("section headers")));
d3168 1
a3168 2
  section_headers = ((Elf_Internal_Shdr *)
		     malloc (num * sizeof (Elf_Internal_Shdr)));
d3198 1
a3198 3
get_64bit_section_headers (file, num)
     FILE *file;
     unsigned int num;
d3204 2
a3205 4
  shdrs = ((Elf64_External_Shdr *)
	   get_data (NULL, file, elf_header.e_shoff,
		     elf_header.e_shentsize * num,
		     _("section headers")));
d3209 1
a3209 2
  section_headers = ((Elf_Internal_Shdr *)
		     malloc (num * sizeof (Elf_Internal_Shdr)));
d3239 1
a3239 3
get_32bit_elf_symbols (file, section)
     FILE *file;
     Elf_Internal_Shdr *section;
d3248 2
a3249 3
  esyms = ((Elf32_External_Sym *)
	   get_data (NULL, file, section->sh_offset,
		     section->sh_size, _("symbols")));
d3258 2
a3259 3
      shndx = ((Elf_External_Sym_Shndx *)
	       get_data (NULL, file, symtab_shndx_hdr->sh_offset,
			 symtab_shndx_hdr->sh_size, _("symtab shndx")));
d3268 1
a3268 1
  isyms = (Elf_Internal_Sym *) malloc (number * sizeof (Elf_Internal_Sym));
d3302 1
a3302 3
get_64bit_elf_symbols (file, section)
     FILE *file;
     Elf_Internal_Shdr *section;
d3311 2
a3312 3
  esyms = ((Elf64_External_Sym *)
	   get_data (NULL, file, section->sh_offset,
		     section->sh_size, _("symbols")));
d3321 2
a3322 3
      shndx = ((Elf_External_Sym_Shndx *)
	       get_data (NULL, file, symtab_shndx_hdr->sh_offset,
			 symtab_shndx_hdr->sh_size, _("symtab shndx")));
d3331 1
a3331 1
  isyms = (Elf_Internal_Sym *) malloc (number * sizeof (Elf_Internal_Sym));
d3365 1
a3365 2
get_elf_section_flags (sh_flags)
     bfd_vma sh_flags;
d3412 1
a3412 2
process_section_headers (file)
     FILE *file;
d3444 2
a3445 2
      string_table = (char *) get_data (NULL, file, section->sh_offset,
					section->sh_size, _("string table"));
d3486 2
a3487 3
	  dynamic_strings = (char *) get_data (NULL, file, section->sh_offset,
					       section->sh_size,
					       _("dynamic strings"));
d3662 1
a3662 2
process_relocs (file)
     FILE *file;
d3771 2
a3772 3
		  strtab = (char *) get_data (NULL, file, strsec->sh_offset,
					      strsec->sh_size,
					      _("string table"));
a3826 7
static void find_symbol_for_address
  PARAMS ((struct unw_aux_info *, struct absaddr, const char **, bfd_vma *));
static void dump_ia64_unwind
  PARAMS ((struct unw_aux_info *));
static int slurp_ia64_unwind_table
  PARAMS ((FILE *, struct unw_aux_info *, Elf_Internal_Shdr *));

d3828 4
a3831 5
find_symbol_for_address (aux, addr, symname, offset)
     struct unw_aux_info *aux;
     struct absaddr addr;
     const char **symname;
     bfd_vma *offset;
d3833 1
a3833 1
  bfd_vma dist = (bfd_vma) 0x100000;
d3863 1
a3863 2
dump_ia64_unwind (aux)
     struct unw_aux_info *aux;
d3921 3
a3923 4
slurp_ia64_unwind_table (file, aux, sec)
     FILE *file;
     struct unw_aux_info *aux;
     Elf_Internal_Shdr *sec;
d3962 1
a3962 2
  table = (char *) get_data (NULL, file, sec->sh_offset,
			     size, _("unwind table"));
d4066 1
a4066 2
process_unwind (file)
     FILE *file;
d4094 2
a4095 2
	  aux.strtab = (char *) get_data (NULL, file, strsec->sh_offset,
					  aux.strtab_size, _("string table"));
d4164 2
a4165 2
	  aux.info = (char *) get_data (NULL, file, sec->sh_offset,
					aux.info_size, _("unwind info"));
d4201 1
a4201 2
dynamic_segment_mips_val (entry)
     Elf_Internal_Dyn *entry;
d4275 1
a4275 2
dynamic_segment_parisc_val (entry)
     Elf_Internal_Dyn *entry;
d4331 1
a4331 2
dynamic_segment_ia64_val (entry)
     Elf_Internal_Dyn *entry;
d4350 1
a4350 2
get_32bit_dynamic_segment (file)
     FILE *file;
d4356 2
a4357 2
  edyn = (Elf32_External_Dyn *) get_data (NULL, file, dynamic_addr,
					  dynamic_size, _("dynamic segment"));
d4368 1
a4368 2
  dynamic_segment = (Elf_Internal_Dyn *)
    malloc (dynamic_size * sizeof (Elf_Internal_Dyn));
d4391 1
a4391 2
get_64bit_dynamic_segment (file)
     FILE *file;
d4397 2
a4398 2
  edyn = (Elf64_External_Dyn *) get_data (NULL, file, dynamic_addr,
					  dynamic_size, _("dynamic segment"));
d4409 1
a4409 2
  dynamic_segment = (Elf_Internal_Dyn *)
    malloc (dynamic_size * sizeof (Elf_Internal_Dyn));
d4432 1
a4432 2
get_dynamic_flags (flags)
     bfd_vma flags;
d4465 1
a4465 2
process_dynamic_segment (file)
     FILE *file;
d4558 2
a4559 2
	  dynamic_strings = (char *) get_data (NULL, file, offset, str_tab_len,
					       _("dynamic string table"));
d4592 2
a4593 3
	  extsyminfo = ((Elf_External_Syminfo *)
			get_data (NULL, file, dynamic_syminfo_offset,
				  syminsz, _("symbol information")));
d4597 1
a4597 1
	  dynamic_syminfo = (Elf_Internal_Syminfo *) malloc (syminsz);
d5010 1
a5010 2
get_ver_flags (flags)
     unsigned int flags;
d5038 1
a5038 2
process_version_sections (file)
     FILE *file;
d5071 2
a5072 4
	    edefs = ((Elf_External_Verdef *)
		     get_data (NULL, file, section->sh_offset,
			       section->sh_size,
			       _("version definition section")));
d5160 2
a5161 3
	    eneed = ((Elf_External_Verneed *)
		     get_data (NULL, file, section->sh_offset,
			       section->sh_size, _("version need section")));
d5238 1
d5249 2
a5250 3
	    strtab = (char *) get_data (NULL, file, string_sec->sh_offset,
					string_sec->sh_size,
					_("version string table"));
d5263 5
a5267 7
	    edata =
	      ((unsigned char *)
	       get_data (NULL, file,
			 offset_from_vma
			 (file, version_info[DT_VERSIONTAGIDX (DT_VERSYM)],
			  total * sizeof (short)),
			 total * sizeof (short), _("version symbol data")));
d5274 1
a5274 1
	    data = (unsigned short *) malloc (total * sizeof (short));
d5442 1
a5442 2
get_symbol_binding (binding)
     unsigned int binding;
d5463 1
a5463 2
get_symbol_type (type)
     unsigned int type;
d5509 1
a5509 2
get_symbol_visibility (visibility)
     unsigned int visibility;
d5522 1
a5522 2
get_symbol_index_type (type)
     unsigned int type;
d5547 1
a5547 3
get_dynamic_data (file, number)
     FILE *file;
     unsigned int number;
d5552 1
a5552 1
  e_data = (unsigned char *) malloc (number * 4);
d5566 1
a5566 1
  i_data = (int *) malloc (number * sizeof (*i_data));
d5585 1
a5585 2
process_symbol_table (file)
     FILE *file;
d5706 2
a5707 3
	      strtab = (char *) get_data (NULL, file, string_sec->sh_offset,
					  string_sec->sh_size,
					  _("string table"));
d5883 1
a5883 1
      lengths = (int *) calloc (nbuckets, sizeof (int));
d5902 1
a5902 1
      counts = (int *) calloc (maxlength + 1, sizeof (int));
d5939 1
a5939 2
process_syminfo (file)
     FILE *file ATTRIBUTE_UNUSED;
d6005 1
a6005 3
disassemble_section (section, file)
     Elf_Internal_Shdr *section;
     FILE *file;
d6017 1
a6017 3
dump_section (section, file)
     Elf_Internal_Shdr *section;
     FILE *file;
d6037 1
a6037 2
  start = (unsigned char *) get_data (NULL, file, section->sh_offset, bytes,
				      _("section data"));
d6106 1
a6106 4
read_leb128 (data, length_return, sign)
     unsigned char *data;
     int *length_return;
     int sign;
d6151 1
a6151 2
reset_state_machine (is_stmt)
     int is_stmt;
d6166 1
a6166 4
process_extended_line_op (data, is_stmt, pointer_size)
     unsigned char *data;
     int is_stmt;
     int pointer_size;
d6230 3
a6232 4
display_debug_lines (section, start, file)
     Elf_Internal_Shdr *section;
     unsigned char * start;
     FILE *file ATTRIBUTE_UNUSED;
d6504 3
a6506 4
display_debug_pubnames (section, start, file)
     Elf_Internal_Shdr *section;
     unsigned char *start;
     FILE *file ATTRIBUTE_UNUSED;
d6590 1
a6590 2
get_TAG_name (tag)
     unsigned long tag;
d6670 1
a6670 2
get_AT_name (attribute)
     unsigned long attribute;
d6783 1
a6783 2
get_FORM_name (form)
     unsigned long form;
d6844 1
a6844 1
free_abbrevs ()
d6869 1
a6869 4
add_abbrev (number, tag, children)
     unsigned long number;
     unsigned long tag;
     int children;
d6873 1
a6873 1
  entry = (abbrev_entry *) malloc (sizeof (*entry));
d6895 1
a6895 3
add_abbrev_attr (attribute, form)
     unsigned long attribute;
     unsigned long form;
d6899 1
a6899 1
  attr = (abbrev_attr *) malloc (sizeof (*attr));
d6923 1
a6923 3
process_abbrev_section (start, end)
     unsigned char *start;
     unsigned char *end;
d6973 3
a6975 4
display_debug_macinfo (section, start, file)
     Elf_Internal_Shdr *section;
     unsigned char *start;
     FILE *file ATTRIBUTE_UNUSED;
d7046 3
a7048 4
display_debug_abbrev (section, start, file)
     Elf_Internal_Shdr *section;
     unsigned char *start;
     FILE *file ATTRIBUTE_UNUSED;
d7092 1
a7092 3
display_block (data, length)
     unsigned char *data;
     unsigned long length;
d7103 3
a7105 4
decode_location_expression (data, pointer_size, length)
     unsigned char * data;
     unsigned int pointer_size;
     unsigned long length;
d7438 1
a7438 2
load_debug_loc (file)
     FILE *file;
d7459 2
a7460 3
  debug_loc_contents = ((char *)
			get_data (NULL, file, sec->sh_offset, sec->sh_size,
				  _("debug_loc section data")));
d7464 1
a7464 1
free_debug_loc ()
d7476 3
a7478 4
display_debug_loc (section, start, file)
     Elf_Internal_Shdr *section;
     unsigned char *start;
     FILE *file ATTRIBUTE_UNUSED;
d7548 1
a7548 2
load_debug_str (file)
     FILE *file;
d7569 2
a7570 3
  debug_str_contents = ((char *)
			get_data (NULL, file, sec->sh_offset, sec->sh_size,
				  _("debug_str section data")));
d7574 1
a7574 1
free_debug_str ()
d7585 1
a7585 2
fetch_indirect_string (offset)
     unsigned long offset;
d7597 3
a7599 4
display_debug_str (section, start, file)
     Elf_Internal_Shdr *section;
     unsigned char *start;
     FILE *file ATTRIBUTE_UNUSED;
d7656 7
a7662 9
read_and_display_attr_value (attribute, form, data, cu_offset, pointer_size,
                             offset_size, dwarf_version)
     unsigned long attribute;
     unsigned long form;
     unsigned char *data;
     unsigned long cu_offset;
     unsigned long pointer_size;
     unsigned long offset_size;
     int dwarf_version;
d7991 7
a7997 9
read_and_display_attr (attribute, form, data, cu_offset, pointer_size,
                       offset_size, dwarf_version)
     unsigned long attribute;
     unsigned long form;
     unsigned char *data;
     unsigned long cu_offset;
     unsigned long pointer_size;
     unsigned long offset_size;
     int dwarf_version;
d8007 3
a8009 4
display_debug_info (section, start, file)
     Elf_Internal_Shdr *section;
     unsigned char *start;
     FILE *file;
d8162 2
a8163 3
	begin = ((unsigned char *)
		 get_data (NULL, file, sec->sh_offset, sec->sh_size,
			   _("debug_abbrev section data")));
d8233 3
a8235 4
display_debug_aranges (section, start, file)
     Elf_Internal_Shdr *section;
     unsigned char *start;
     FILE *file ATTRIBUTE_UNUSED;
a8352 5
static void frame_need_space PARAMS ((Frame_Chunk *, int));
static void frame_display_row PARAMS ((Frame_Chunk *, int *, int *));
static int size_of_encoded_value PARAMS ((int));
static bfd_vma get_encoded_value PARAMS ((unsigned char *, int));

d8354 1
a8354 3
frame_need_space (fc, reg)
     Frame_Chunk *fc;
     int reg;
d8362 2
a8363 4
  fc->col_type = (short int *) xrealloc (fc->col_type,
					 fc->ncols * sizeof (short int));
  fc->col_offset = (int *) xrealloc (fc->col_offset,
				     fc->ncols * sizeof (int));
d8374 1
a8374 4
frame_display_row (fc, need_col_headers, max_regs)
     Frame_Chunk *fc;
     int *need_col_headers;
     int *max_regs;
d8439 1
a8439 2
size_of_encoded_value (encoding)
     int encoding;
d8452 1
a8452 3
get_encoded_value (data, encoding)
     unsigned char *data;
     int encoding;
d8466 3
a8468 4
display_debug_frames (section, start, file)
     Elf_Internal_Shdr *section;
     unsigned char *start;
     FILE *file ATTRIBUTE_UNUSED;
d8527 1
a8527 1
	  fc = (Frame_Chunk *) xmalloc (sizeof (Frame_Chunk));
d8534 2
a8535 2
	  fc->col_type = (short int *) xmalloc (sizeof (short int));
	  fc->col_offset = (int *) xmalloc (sizeof (int));
d8638 2
a8639 2
	      fc->col_type = (short int *) xmalloc (sizeof (short int));
	      fc->col_offset = (int *) xmalloc (sizeof (int));
d8648 2
a8649 2
	      fc->col_type = (short int *) xmalloc (fc->ncols * sizeof (short int));
	      fc->col_offset = (int *) xmalloc (fc->ncols * sizeof (int));
d8954 1
a8954 1
	      rs = (Frame_Chunk *) xmalloc (sizeof (Frame_Chunk));
d8956 2
a8957 2
	      rs->col_type = (short int *) xmalloc (rs->ncols * sizeof (short int));
	      rs->col_offset = (int *) xmalloc (rs->ncols * sizeof (int));
d9110 3
a9112 4
display_debug_not_supported (section, start, file)
     Elf_Internal_Shdr *section;
     unsigned char *start ATTRIBUTE_UNUSED;
     FILE *file ATTRIBUTE_UNUSED;
d9124 3
a9126 4
prescan_debug_info (section, start, file)
     Elf_Internal_Shdr *section ATTRIBUTE_UNUSED;
     unsigned char *start;
     FILE *file ATTRIBUTE_UNUSED;
d9173 2
a9174 2
  int (*display) PARAMS ((Elf_Internal_Shdr *, unsigned char *, FILE *));
  int (*prescan) PARAMS ((Elf_Internal_Shdr *, unsigned char *, FILE *));
d9197 1
a9197 3
display_debug_section (section, file)
     Elf_Internal_Shdr *section;
     FILE *file;
d9211 2
a9212 2
  start = (unsigned char *) get_data (NULL, file, section->sh_offset, length,
				      _("debug section data"));
d9240 1
a9240 2
process_section_contents (file)
     FILE *file;
d9271 2
a9272 3
		start = ((unsigned char *)
			 get_data (NULL, file, section->sh_offset, length,
				   _("debug section data")));
d9306 1
a9306 2
process_mips_fpe_exception (mask)
     int mask;
d9327 1
a9327 2
process_mips_specific (file)
     FILE *file;
d9372 3
a9374 4
      elib = ((Elf32_External_Lib *)
	      get_data (NULL, file, liblist_offset,
			liblistno * sizeof (Elf32_External_Lib),
			_("liblist")));
d9458 2
a9459 2
      eopt = (Elf_External_Options *) get_data (NULL, file, options_offset,
						sect->sh_size, _("options"));
d9462 1
a9462 2
	  iopt = ((Elf_Internal_Options *)
		  malloc ((sect->sh_size / sizeof (eopt)) * sizeof (*iopt)));
d9654 1
a9654 1
      iconf = (Elf32_Conflict *) malloc (conflictsno * sizeof (*iconf));
d9665 2
a9666 4
	  econf32 = ((Elf32_External_Conflict *)
		     get_data (NULL, file, conflicts_offset,
			       conflictsno * sizeof (*econf32),
			       _("conflict")));
d9679 2
a9680 4
	  econf64 = ((Elf64_External_Conflict *)
		     get_data (NULL, file, conflicts_offset,
			       conflictsno * sizeof (*econf64),
			       _("conflict")));
d9712 1
a9712 2
process_gnu_liblist (file)
     FILE *file;
d9730 2
a9731 3
	  elib = ((Elf32_External_Lib *)
		 get_data (NULL, file, section->sh_offset, section->sh_size,
			   _("liblist")));
d9737 2
a9738 3
	  strtab = (char *) get_data (NULL, file, string_sec->sh_offset,
				      string_sec->sh_size,
				      _("liblist string table"));
d9789 1
a9789 2
get_note_type (e_type)
     unsigned e_type;
d9813 1
a9813 2
get_netbsd_elfcore_note_type (e_type)
     unsigned e_type;
d9879 1
a9879 2
process_note (pnote)
     Elf_Internal_Note *pnote;
d9909 1
a9909 4
process_corefile_note_segment (file, offset, length)
     FILE *file;
     bfd_vma offset;
     bfd_vma length;
d9918 1
a9918 2
  pnotes = (Elf_External_Note *) get_data (NULL, file, offset, length,
					   _("notes"));
d9991 1
a9991 2
process_corefile_note_segments (file)
     FILE *file;
d10014 1
a10014 2
process_corefile_contents (file)
     FILE *file;
d10035 1
a10035 2
process_arch_specific (file)
     FILE *file;
d10053 1
a10053 2
get_file_header (file)
     FILE *file;
d10146 1
a10146 2
process_file (file_name)
     char *file_name;
a10281 2
int main PARAMS ((int, char **));

d10283 1
a10283 3
main (argc, argv)
     int argc;
     char **argv;
@


1.213
log
@	* readelf.c (dynamic_segment_ia64_val): Print address and newline
	for sections by default.  Comment fix.
@
text
@d488 1
a488 1
      error (_("Unable to seek to %x for %s\n"), offset, reason);
d499 1
a499 1
	  error (_("Out of memory allocating %d bytes for %s\n"),
d507 1
a507 1
      error (_("Unable to read in %d bytes of %s\n"), size, reason);
d3770 3
@


1.212
log
@Fix computation of offsets in PT_LOAD sections.
@
text
@d4674 1
a4674 1
      /* First 3 bytes reserved.  */
d4678 5
a4682 1
      printf ("\n");
d4684 1
@


1.211
log
@oops - remove spurious debugging left in previous delta
@
text
@d109 2
a110 3
long dynamic_info[DT_JMPREL + 1];
long version_info[16];
long loadaddr = 0;
d113 1
d285 2
d301 2
d3186 33
a3224 1
  Elf_Internal_Phdr *program_headers;
d3246 1
a3246 6
  program_headers = (Elf_Internal_Phdr *) malloc
    (elf_header.e_phnum * sizeof (Elf_Internal_Phdr));

  if (program_headers == NULL)
    {
      error (_("Out of memory\n"));
a3247 12
    }

  if (is_32bit_elf)
    i = get_32bit_program_headers (file, program_headers);
  else
    i = get_64bit_program_headers (file, program_headers);

  if (i == 0)
    {
      free (program_headers);
      return 0;
    }
a3270 1
  loadaddr = -1;
a3357 12
	case PT_LOAD:
	  if (loadaddr == -1)
	    {
	      unsigned long align_mask = -segment->p_align;

	      if (align_mask == 0)
		--align_mask;
	      loadaddr = ((segment->p_vaddr & align_mask)
			  - (segment->p_offset & align_mask));
	    }
	  break;

a3384 6
  if (loadaddr == -1)
    {
      /* Very strange.  */
      loadaddr = 0;
    }

d3421 31
a3451 1
  free (program_headers);
d3453 3
a3455 1
  return 1;
d4031 3
a4033 1
	      dump_relocations (file, rel_offset - loadaddr, rel_size,
d4259 1
a4259 1
  Elf_Internal_Phdr *prog_hdrs, *seg;
a4265 1
  int result;
d4274 1
a4274 11
      prog_hdrs = (Elf_Internal_Phdr *)
	xmalloc (elf_header.e_phnum * sizeof (Elf_Internal_Phdr));

      if (is_32bit_elf)
	result = get_32bit_program_headers (file, prog_hdrs);
      else
	result = get_64bit_program_headers (file, prog_hdrs);

      if (!result)
	{
	  free (prog_hdrs);
a4275 1
	}
d4277 3
a4279 1
      for (seg = prog_hdrs; seg < prog_hdrs + elf_header.e_phnum; ++seg)
a4290 2

      free (prog_hdrs);
d4843 1
a4843 1
	  section.sh_offset = entry->d_un.d_val - loadaddr;
d4885 1
a4885 1
	  offset = entry->d_un.d_val - loadaddr;
d4921 2
a4922 1
	    dynamic_syminfo_offset = entry->d_un.d_val - loadaddr;
d5611 3
a5613 1
			 version_info[DT_VERSIONTAGIDX (DT_VERSYM)] - loadaddr,
d5669 3
a5671 2
			  offset = version_info[DT_VERSIONTAGIDX (DT_VERNEED)]
			    - loadaddr;
d5726 3
a5728 2
			  offset = (version_info[DT_VERSIONTAGIDX (DT_VERDEF)]
				    - loadaddr);
d5955 3
a5957 1
      if (fseek (file, dynamic_info[DT_HASH] - loadaddr, SEEK_SET))
d6088 3
a6090 2
		  offset = version_info[DT_VERSIONTAGIDX (DT_VERSYM)]
		    - loadaddr;
d6112 3
a6114 2
			  offset = (version_info[DT_VERSIONTAGIDX (DT_VERNEED)]
				    - loadaddr);
d6174 4
a6177 3
			      offset
				= (version_info[DT_VERSIONTAGIDX (DT_VERDEF)]
				   - loadaddr);
d9768 3
a9770 1
	liblist_offset = entry->d_un.d_val - loadaddr;
d9776 1
a9776 1
	options_offset = entry->d_un.d_val - loadaddr;
d9779 3
a9781 1
	conflicts_offset = entry->d_un.d_val - loadaddr;
a10432 1
  Elf_Internal_Phdr *program_headers;
d10437 1
a10437 6
  program_headers = (Elf_Internal_Phdr *) malloc
    (elf_header.e_phnum * sizeof (Elf_Internal_Phdr));

  if (program_headers == NULL)
    {
      error (_("Out of memory\n"));
a10438 12
    }

  if (is_32bit_elf)
    i = get_32bit_program_headers (file, program_headers);
  else
    i = get_64bit_program_headers (file, program_headers);

  if (i == 0)
    {
      free (program_headers);
      return 0;
    }
a10449 2
  free (program_headers);

d10665 6
@


1.210
log
@When printing DEC_5 values, if the number is bigger than 99999 switch to using
hexadecimal notation.
@
text
@d637 1
a637 1
	      printf ("** %5ld", (long) vma);
@


1.209
log
@binutils/
	* readelf.c (get_segment_type): Handle PT_GNU_STACK.
bfd/
	* elf.c (_bfd_elf_print_private_bfd_data): Handle PT_GNU_STACK.
	(bfd_section_from_phdr): Likewise.
	(map_sections_to_segments): Create PT_GNU_STACK segment header.
	(get_program_header_size): Count with PT_GNU_STACK.
	* elf-bfd.h (struct elf_obj_tdata): Add stack_flags.
	* elflink.h (bfd_elfNN_size_dynamic_sections): Set stack_flags.
include/
	* bfdlink.h (struct bfd_link_info): Add execstack and noexecstack.
	* elf/common.h (PT_GNU_STACK): Define.
ld/
	* ldgram.y (phdr_type): Grok PT_GNU_STACK.
	* emultempl/elf32.em (gld${EMULATION_NAME}_handle_option): Add
	-z execstack and -z noexecstack.
	(gld${EMULATION_NAME}_list_options): Likewise.
	* scripttempl/elf.sc: If not -r, discard .note.GNU-stack section.
@
text
@d627 28
a654 7
	case FULL_HEX: printf ("0x"); /* drop through */
	case LONG_HEX: printf ("%8.8lx", (unsigned long) vma); break;
	case PREFIX_HEX: printf ("0x"); /* drop through */
	case HEX: printf ("%lx", (unsigned long) vma); break;
	case DEC: printf ("%ld", (unsigned long) vma); break;
	case DEC_5: printf ("%5ld", (long) vma); break;
	case UNSIGNED: printf ("%lu", (unsigned long) vma); break;
d664 1
a664 1
	  /* drop through */
d672 1
a672 1
	  /* drop through */
d699 4
a702 1
	  printf ("%5ld", vma);
d707 2
d710 1
a710 1
	    printf ("%5ld", _bfd_int64_low (vma));
@


1.208
log
@        * readelf.c (byte_get_signed): New.
        (get_encoded_value): New.
        (display_debug_frames): Use it.  Always pre-process opcodes.
@
text
@d2335 1
@


1.207
log
@2003-05-20  Michal Ludvig  <mludvig@@suse.cz>

	* readelf.c (display_debug_frames): Print both registers
	for DW_CFA_register.
@
text
@d176 2
d561 23
d8696 1
d8804 12
d9021 1
a9021 1
	  fc->pc_begin = byte_get (start, encoded_ptr_size);
d9052 6
a9057 2

      if (do_debug_frames_interp)
d9220 1
a9220 1
	      vma = byte_get (start, encoded_ptr_size);
@


1.206
log
@2003-05-07  H.J. Lu <hongjiu.lu@@intel.com>

	* readelf.c (dump_relocations): Enlarge the type field in wide
	mode by one character.
@
text
@d9260 1
a9260 1
		printf ("  DW_CFA_register: r%ld\n", reg);
@


1.205
log
@        * readelf.c (struct Frame_Chunk): Add cfa_exp.
        (frame_display_row): Just print "exp" for cfa or register
        defined by a location expression.
        (display_debug_frames): Handle DW_CFA_def_cfa_expression,
        DW_CFA_expression, DW_CFA_MIPS_advance_loc8.
@
text
@d1074 1
a1074 1
	    printf (_("    Offset             Info            Type               Symbol's Value  Symbol's Name + Addend\n"));
d1081 1
a1081 1
	    printf (_("    Offset             Info            Type               Symbol's Value  Symbol's Name\n"));
d1364 1
a1364 1
	printf (do_wide ? "%-21.21s" : "%-17.17s", rtype);
@


1.204
log
@bfd:
        * archures.c (enum bfd_architecture): Amend comment to refer to SuperH.
        * cpu-sh.c: Likewise.
        * elf32-sh.c: Likewise.
        * reloc.c (bfd_reloc_code_real): Likewise.
        * elf32-sh64-com.c: Change comment to refer to SuperH.
        * elf32-sh64.c: Likewise.
        * elf64-sh64.c: Likewise.
        * bfd-in2.h (enum bfd_architecture): Regenerate.
binutils:
        * readelf.c (get_machine_name) <EM_SH>: Amend return value
        to refer to SuperH.
gas:
        * config/tc-sh.c: Amend comment to refer to SuperH.
        * config/tc-sh.h: Likewise.
        (LISTING_HEADER): Amend to refer to SuperH.
        * config/tc-sh64.c: Change comment to refer to SuperH.
        * config/tc-sh64.h (LISTING_HEADER): Change to refer to SuperH.
        * doc/as.texinfo [SH, GENERIC]: Amend / Change to refer to SuperH.
        * doc/c-sh.texi: Amend to refer to SuperH.
        Add SuperH architecture documentation references.
        * doc/c-sh64.texi: Change to refer to SuperH.
include/elf:
        * common.h (EM_SH): Amend comment to refer to SuperH.
ld/testsuite:
        * ld-sh/sh64/crange3-cmpct.rd (Machine): Change to refer to SuperH.
        * ld-sh/sh64/crange3-media.rd (Machine): Likewise.
@
text
@d8660 1
d8727 4
a8730 1
  sprintf (tmp, "r%d%+d", fc->cfa_reg, fc->cfa_offset);
d8751 3
d9024 1
a9024 1
	      unsigned long reg;
d9092 11
d9114 3
d9294 1
d9302 1
d9318 25
d9357 1
d9369 11
a9399 11
	      break;

	    /* FIXME: How do we handle these? */
	    case DW_CFA_def_cfa_expression:
	      fprintf (stderr, "unsupported DW_CFA_def_cfa_expression\n");
	      start = block_end;
	      break;

	    case DW_CFA_expression:
	      fprintf (stderr, "unsupported DW_CFA_expression\n");
	      start = block_end;
@


1.204.2.1
log
@	* readelf.c (struct Frame_Chunk): Add cfa_exp.
	(frame_display_row): Just print "exp" for cfa or register
	defined by a location expression.
	(display_debug_frames): Handle DW_CFA_def_cfa_expression,
	DW_CFA_expression, DW_CFA_MIPS_advance_loc8.
@
text
@a8659 1
  unsigned char cfa_exp;
d8726 1
a8726 4
  if (fc->cfa_exp)
    strcpy (tmp, "exp");
  else
    sprintf (tmp, "r%d%+d", fc->cfa_reg, fc->cfa_offset);
a8746 3
	    case DW_CFA_expression:
	      strcpy (tmp, "exp");
	      break;
d9017 1
a9017 1
	      unsigned long reg, tmp;
a9084 11
		case DW_CFA_def_cfa_expression:
		  tmp = LEB ();
		  start += tmp;
		  break;
		case DW_CFA_expression:
		  reg = LEB ();
		  tmp = LEB ();
		  start += tmp;
		  frame_need_space (fc, reg);
		  fc->col_type[reg] = DW_CFA_undefined;
		  break;
a9095 3
		case DW_CFA_MIPS_advance_loc8:
		  start += 8;
		  break;
a9272 1
	      fc->cfa_exp = 0;
a9279 1
	      fc->cfa_exp = 0;
a9294 25
	    case DW_CFA_def_cfa_expression:
	      ul = LEB ();
	      if (! do_debug_frames_interp)
		{
		  printf ("  DW_CFA_def_cfa_expression (");
		  decode_location_expression (start, addr_size, ul);
		  printf (")\n");
		}
	      fc->cfa_exp = 1;
	      start += ul;
	      break;

	    case DW_CFA_expression:
	      reg = LEB ();
	      ul = LEB ();
	      if (! do_debug_frames_interp)
		{
		  printf ("  DW_CFA_expression: r%ld (", reg);
		  decode_location_expression (start, addr_size, ul);
		  printf (")\n");
		}
	      fc->col_type[reg] = DW_CFA_expression;
	      start += ul;
	      break;

a9308 1
	      fc->cfa_exp = 0;
a9319 11
	    case DW_CFA_MIPS_advance_loc8:
	      ofs = byte_get (start, 8); start += 8;
	      if (do_debug_frames_interp)
		frame_display_row (fc, &need_col_headers, &max_regs);
	      else
		printf ("  DW_CFA_MIPS_advance_loc8: %ld to %08lx\n",
			ofs * fc->code_factor,
			fc->pc_begin + ofs * fc->code_factor);
	      fc->pc_begin += ofs * fc->code_factor;
	      break;

d9340 11
@


1.204.2.2
log
@	Merge from mainline:

	2003-05-13  Michael Eager <eager@@mvista.com>
	* objcopy.c: Treat identical src/dst file names as if only one
	entered.  One Windows creating an output file of the same name as
	the input file will delete the input file before it is read.

	2003-05-12  Salvador Eduardo Tropea  <salvador@@inti.gov.ar>
	* debug.c (debug_get_real_type): Extend test for circular debug
	references.

	2003-05-12  Nick Clifton  <nickc@@redhat.com>
	* configure.in (ALL_LINGUAS): Add zh_CN.
	* configure: Regenerate.
	* po/zh_CN.po: New file: Chinese (simplified) translation.

	2003-05-07  H.J. Lu <hongjiu.lu@@intel.com>
	* readelf.c (dump_relocations): Enlarge the type field in wide
	mode by one character.
@
text
@d1074 1
a1074 1
	    printf (_("    Offset             Info             Type               Symbol's Value  Symbol's Name + Addend\n"));
d1081 1
a1081 1
	    printf (_("    Offset             Info             Type               Symbol's Value  Symbol's Name\n"));
d1364 1
a1364 1
	printf (do_wide ? "%-22.22s" : "%-17.17s", rtype);
@


1.203
log
@Fix "readelf -wi" test
@
text
@d1773 1
a1773 1
    case EM_SH:			return "Renesas SH";
@


1.202
log
@Replace references to Mitsubishi M32R with references to Renesas M32R.
@
text
@d7730 2
a7731 1
      printf ("; ");
@


1.201
log
@Replace occurrances of 'Hitachi' with 'Renesas'.
@
text
@d1791 1
a1791 1
    case EM_M32R:		return "Mitsubishi M32r";
@


1.200
log
@* readelf.c (display_debug_info): Apply RELA relocations on the
entire section.
(byte_put_little_endian, byte_put_big_endian): New functions.
(byte_put): New variable.
(get_file_header): Initialize it.
@
text
@d1773 1
a1773 1
    case EM_SH:			return "Hitachi SH";
d1777 4
a1780 4
    case EM_H8_300:		return "Hitachi H8/300";
    case EM_H8_300H:		return "Hitachi H8/300H";
    case EM_H8S:		return "Hitachi H8S";
    case EM_H8_500:		return "Hitachi H8/500";
@


1.199
log
@Add Xtensa port (omitted from previous delta)
@
text
@d176 6
d559 31
d748 35
d8365 1
a8365 9
      cu_abbrev_offset_ptr = hdrptr;
      compunit.cu_abbrev_offset = byte_get (hdrptr, offset_size);
      hdrptr += offset_size;

      compunit.cu_pointer_size = byte_get (hdrptr, 1);
      hdrptr += 1;

      /* Check for RELA relocations in the
	 abbrev_offset address, and apply them.  */
d8390 7
a8396 2
	      if (rp->r_offset
		  != (bfd_vma) (cu_abbrev_offset_ptr - section_begin))
d8424 1
a8424 2
	      compunit.cu_abbrev_offset = rp->r_addend;
	      break;
d8431 7
d10372 8
a10379 2
    case ELFDATA2LSB: byte_get = byte_get_little_endian; break;
    case ELFDATA2MSB: byte_get = byte_get_big_endian; break;
@


1.198
log
@2003-03-31  H.J. Lu <hjl@@gnu.org>

	* readelf.c: Include "libiberty.h".
	(dynamic_relocations): New.
	(process_relocs): Properly handle dynamic relocation.
	(process_dynamic_segment): Fill relocation elements in
	dynamic_info.
@
text
@d91 1
d775 2
d1278 5
d1768 2
@


1.197
log
@Add some initial 64-bit DWARF support
@
text
@d94 1
d3802 13
d3829 6
a3834 1
      int is_rela = FALSE;
d3836 6
a3841 2
      rel_size   = 0;
      rel_offset = 0;
d3843 1
a3843 16
      if (dynamic_info[DT_REL])
	{
	  rel_offset = dynamic_info[DT_REL];
	  rel_size   = dynamic_info[DT_RELSZ];
	  is_rela    = FALSE;
	}
      else if (dynamic_info[DT_RELA])
	{
	  rel_offset = dynamic_info[DT_RELA];
	  rel_size   = dynamic_info[DT_RELASZ];
	  is_rela    = TRUE;
	}
      else if (dynamic_info[DT_JMPREL])
	{
	  rel_offset = dynamic_info[DT_JMPREL];
	  rel_size   = dynamic_info[DT_PLTRELSZ];
d3845 1
a3845 1
	  switch (dynamic_info[DT_PLTREL])
d3847 10
a3856 9
	    case DT_REL:
	      is_rela = FALSE;
	      break;
	    case DT_RELA:
	      is_rela = TRUE;
	      break;
	    default:
	      is_rela = UNKNOWN;
	      break;
a3857 1
	}
d3859 5
a3863 5
      if (rel_size)
	{
	  printf
	    (_("\nRelocation section at offset 0x%lx contains %ld bytes:\n"),
	     rel_offset, rel_size);
d3865 4
a3868 3
	  dump_relocations (file, rel_offset - loadaddr, rel_size,
			    dynamic_symbols, num_dynamic_syms, dynamic_strings,
			    is_rela);
d3870 2
a3871 1
      else
d5014 1
d5089 1
@


1.196
log
@Add SHT_IA_64_LOPSREG, SHT_IA_64_HIPSREG and SHT_IA_64_PRIORITY_INIT.
Add code to display these values in readelf.
@
text
@d351 1
a351 1
	   unsigned long));
d354 1
a354 1
	   unsigned long));
d410 1
a410 1
#define DT_VERSIONTAGIDX(tag)	(DT_VERNEEDNUM - (tag))	/* Reverse order! */
d947 1
d2885 1
d6425 1
a6425 1
  DWARF2_External_LineInfo *external;
d6432 2
d6440 1
a6440 1
      external = (DWARF2_External_LineInfo *) data;
d6443 2
a6444 1
      info.li_length = BYTE_GET (external->li_length);
d6448 10
a6457 2
	  warn (_("64-bit DWARF line info is not supported yet.\n"));
	  break;
d6460 1
a6460 1
      if (info.li_length + sizeof (external->li_length) > section->sh_size)
d6468 3
a6470 2
      info.li_version = BYTE_GET (external->li_version);
      if (info.li_version != 2)
d6472 1
a6472 1
	  warn (_("Only DWARF version 2 line info is currently supported.\n"));
d6476 12
a6487 6
      info.li_prologue_length = BYTE_GET (external->li_prologue_length);
      info.li_min_insn_length = BYTE_GET (external->li_min_insn_length);
      info.li_default_is_stmt = BYTE_GET (external->li_default_is_stmt);
      info.li_line_base       = BYTE_GET (external->li_line_base);
      info.li_line_range      = BYTE_GET (external->li_line_range);
      info.li_opcode_base     = BYTE_GET (external->li_opcode_base);
d6502 1
a6502 1
      end_of_sequence = data + info.li_length + sizeof (external->li_length);
d6507 1
a6507 1
      standard_opcodes = data + sizeof (*external);
a6699 1
  DWARF2_External_PubNames *external;
d6711 1
d6713 1
a6713 9
      external = (DWARF2_External_PubNames *) start;

      pubnames.pn_length  = BYTE_GET (external->pn_length);
      pubnames.pn_version = BYTE_GET (external->pn_version);
      pubnames.pn_offset  = BYTE_GET (external->pn_offset);
      pubnames.pn_size    = BYTE_GET (external->pn_size);

      data   = start + sizeof (*external);
      start += pubnames.pn_length + sizeof (external->pn_length);
d6715 2
d6719 9
a6727 2
	  warn (_("64-bit DWARF pubnames are not supported yet.\n"));
	  break;
d6730 10
a6739 1
      if (pubnames.pn_version != 2)
d6745 1
a6745 1
	      warn (_("Only DWARF 2 pubnames are currently supported\n"));
d6765 1
a6765 1
	  offset = byte_get (data, 4);
d6769 1
a6769 1
	      data += 4;
d7869 2
a7870 1
read_and_display_attr_value (attribute, form, data, cu_offset, pointer_size)
d7876 2
d7889 16
d7911 2
a7912 2
      uvalue = byte_get (data, /* offset_size */ 4);
      data += /* offset_size */ 4;
d7949 2
a7950 1
					  pointer_size);
d8190 1
a8190 1
      else if (form == DW_FORM_data4)
d8206 2
a8207 1
read_and_display_attr (attribute, form, data, cu_offset, pointer_size)
d8213 2
d8218 1
a8218 1
				      pointer_size);
a8238 1
      DWARF2_External_CompUnit *external;
d8241 2
d8247 2
d8250 1
a8250 1
      external = (DWARF2_External_CompUnit *) start;
d8252 2
a8253 4
      compunit.cu_length        = BYTE_GET (external->cu_length);
      compunit.cu_version       = BYTE_GET (external->cu_version);
      compunit.cu_abbrev_offset = BYTE_GET (external->cu_abbrev_offset);
      compunit.cu_pointer_size  = BYTE_GET (external->cu_pointer_size);
d8257 9
a8265 2
	  warn (_("64-bit DWARF debug info is not supported yet.\n"));
	  break;
d8268 10
d8305 1
a8305 2
		  != (bfd_vma) ((unsigned char *) &external->cu_abbrev_offset
				- section_begin))
d8341 1
a8341 1
      tags = start + sizeof (*external);
d8343 1
a8343 1
      start += compunit.cu_length + sizeof (external->cu_length);
d8351 1
a8351 1
      if (compunit.cu_version != 2)
d8353 1
a8353 1
	  warn (_("Only version 2 DWARF debug information is currently supported.\n"));
d8431 3
a8433 1
					  compunit.cu_pointer_size);
d8460 1
a8460 1
      DWARF2_External_ARange *external;
d8466 2
d8469 1
a8469 1
      external = (DWARF2_External_ARange *) start;
d8471 2
a8472 5
      arange.ar_length       = BYTE_GET (external->ar_length);
      arange.ar_version      = BYTE_GET (external->ar_version);
      arange.ar_info_offset  = BYTE_GET (external->ar_info_offset);
      arange.ar_pointer_size = BYTE_GET (external->ar_pointer_size);
      arange.ar_segment_size = BYTE_GET (external->ar_segment_size);
d8476 9
a8484 2
	  warn (_("64-bit DWARF aranges are not supported yet.\n"));
	  break;
d8487 13
a8499 1
      if (arange.ar_version != 2)
d8501 1
a8501 1
	  warn (_("Only DWARF 2 aranges are currently supported.\n"));
d8513 1
a8513 1
      ranges = start + sizeof (*external);
d8516 1
a8516 1
      excess = sizeof (*external) % (2 * arange.ar_pointer_size);
d8537 1
a8537 1
      start += arange.ar_length + sizeof (external->ar_length);
d8707 2
d8722 9
a8730 2
	  warn (_("64-bit DWARF format frames are not supported yet.\n"));
	  break;
d8733 2
a8734 2
      block_end = saved_start + length + 4;
      cie_id = byte_get (start, 4); start += 4;
d9297 20
a9316 1
  DWARF2_External_CompUnit *external;
d9318 11
a9328 1
  external = (DWARF2_External_CompUnit *) start;
d9330 2
a9331 1
  debug_line_pointer_size = BYTE_GET (external->cu_pointer_size);
@


1.195
log
@Add 'H' to getlongopts so that "readelf -H" does not display "unknown option"
@
text
@d182 2
d245 2
d1487 12
d1595 3
d2353 4
d2359 3
a2361 2
    case SHT_IA_64_EXT:		return "IA_64_EXT";
    case SHT_IA_64_UNWIND:	return "IA_64_UNWIND";
d4499 15
d5162 3
@


1.194
log
@Add support for marking ARM ELF binaries as support the Cirrus EP9312 Maverick
floating point co-processor.
@
text
@d2532 1
a2532 1
	  (argc, argv, "ersuahnldSDAIw::x:i:vVW", options, NULL)) != EOF)
@


1.193
log
@	* readelf.c (dump_relocations): Reorder the r_info field for
	little-endian mips elf64.  Move #ifdef BFD64 to cover the new code.
@
text
@d1876 4
@


1.192
log
@(display_debug_loc): Skip address base changes.
@
text
@d1028 4
d1034 10
d1052 1
a1052 4
	  /* The #ifdef BFD64 below is to prevent a compile time warning.
	     We know that if we do not have a 64 bit data type that we
	     will never execute this code anyway.  */
#ifdef BFD64
@


1.191
log
@	* readelf.c (get_osabi_name): Handle ELFOSABI_AROS, ELFOSABI_OPENVMS
	and ELFOSABI_NSK.
@
text
@d7631 6
a7636 7
	  /* Normally, the lists in  the debug_loc section are related to a
	     given compilation unit, and thus, we would use the
	     pointer size of that compilation unit.  However, since we are
	     displaying it seperately here, we either have to store
	     pointer sizes of all compilation units, or assume they don't
	     change.   We assume, like the debug_line display, that
	     it doesn't change.  */
d7644 4
@


1.190
log
@	* readelf.c: Include elf/ppc64.h.
	(dump_relocations <EM_PPC64>): Use elf_ppc64_reloc_type.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
@
text
@d2833 3
@


1.189
log
@	* readelf.c (guess_is_rela): Handle EM_IQ2000.
	(get_machine_name): Likewise.
	(dump_relocations): Likewise.
	* NEWS: Mention IQ2000 support.
@
text
@d82 1
d1169 3
d1173 1
a1173 1
	  rtype = elf_ppc_reloc_type (type);
@


1.188
log
@	* readelf.c (get_machine_flags): Handle E_MIPS_ARCH_32R2.
@
text
@d89 1
d767 1
d1250 4
d1713 1
a1713 1
    case EM_PRISM:		return "SiTera Prism";
d1723 1
@


1.187
log
@Add support for msp430.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d1997 1
@


1.186
log
@	* readelf.c (main): Reset dump request after each file.
@
text
@d78 1
d760 2
d1158 5
@


1.185
log
@Add support for displaying extension to DWARF2 used by Unified Parallel C
compiler.
@
text
@d10278 2
d10295 14
d10311 11
a10321 1
    err |= process_file (argv[optind++]);
d10325 2
@


1.184
log
@	* readelf.c (process_program_headers): When setting loadaddr, don't
	assume segment size is 4k.  Use p_align instead.
	(loadaddr): Change from int to long.
	(dynamic_addr, dynamic_info, version_info): Likewise.
	(process_dynamic_segment <syminsz>): Likewise.
	(process_dynamic_segment): Adjust print format string.
	(rela_addr, rela_size): Delete.
	(process_relocs): Formatting.
@
text
@d6738 4
d6854 2
d7942 2
@


1.183
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d93 1
a93 1
unsigned int dynamic_addr;
a94 2
unsigned int rela_addr;
unsigned int rela_size;
d104 3
a106 3
int dynamic_info[DT_JMPREL + 1];
int version_info[16];
int loadaddr = 0;
d161 1
a161 1
static void print_vma		     
d163 1
a163 1
static void print_symbol		     
d165 1
a165 1
static bfd_vma (*byte_get)                  
d167 1
a167 1
static bfd_vma byte_get_little_endian     
d169 1
a169 1
static bfd_vma byte_get_big_endian        
d171 1
a171 1
static const char *get_mips_dynamic_type      
d173 1
a173 1
static const char *get_sparc64_dynamic_type   
d175 1
a175 1
static const char *get_ppc64_dynamic_type     
d177 1
a177 1
static const char *get_parisc_dynamic_type    
d179 1
a179 1
static const char *get_dynamic_type           
d181 1
a181 1
static int slurp_rela_relocs	     
d184 1
a184 1
static int slurp_rel_relocs	     
d187 1
a187 1
static int dump_relocations           
d190 1
a190 1
static char *get_file_type              
d192 1
a192 1
static char *get_machine_name           
d194 1
a194 1
static void decode_ARM_machine_flags   
d196 1
a196 1
static char *get_machine_flags          
d198 1
a198 1
static const char *get_mips_segment_type      
d200 1
a200 1
static const char *get_parisc_segment_type    
d202 1
a202 1
static const char *get_ia64_segment_type      
d204 1
a204 1
static const char *get_segment_type           
d206 1
a206 1
static const char *get_mips_section_type_name 
d210 1
a210 1
static const char *get_ia64_section_type_name 
d212 1
a212 1
static const char *get_section_type_name      
d214 1
a214 1
static const char *get_symbol_binding         
d216 1
a216 1
static const char *get_symbol_type            
d218 1
a218 1
static const char *get_symbol_visibility      
d220 1
a220 1
static const char *get_symbol_index_type      
d222 1
a222 1
static const char *get_dynamic_flags	     
d224 1
a224 1
static void usage                      
d226 1
a226 1
static void parse_args                 
d228 1
a228 1
static int process_file_header        
d230 1
a230 1
static int process_program_headers    
d232 1
a232 1
static int process_section_headers    
d234 1
a234 1
static int process_unwind	     
d236 1
a236 1
static void dynamic_segment_mips_val   
d238 1
a238 1
static void dynamic_segment_parisc_val 
d240 1
a240 1
static int process_dynamic_segment    
d242 1
a242 1
static int process_symbol_table       
d244 1
a244 1
static int process_syminfo            
d246 1
a246 1
static int process_section_contents   
d248 1
a248 1
static void process_mips_fpe_exception 
d250 1
a250 1
static int process_mips_specific      
d252 1
a252 1
static int process_file               
d254 1
a254 1
static int process_relocs             
d256 1
a256 1
static int process_version_sections   
d258 1
a258 1
static char *get_ver_flags              
d260 1
a260 1
static int get_32bit_section_headers  
d262 1
a262 1
static int get_64bit_section_headers  
d264 1
a264 1
static int get_32bit_program_headers  
d266 1
a266 1
static int get_64bit_program_headers  
d268 1
a268 1
static int get_file_header            
d270 1
a270 1
static Elf_Internal_Sym *get_32bit_elf_symbols      
d272 1
a272 1
static Elf_Internal_Sym *get_64bit_elf_symbols      
d274 1
a274 1
static const char *get_elf_section_flags	     
d276 1
a276 1
static int *get_dynamic_data           
d278 1
a278 1
static int get_32bit_dynamic_segment  
d280 1
a280 1
static int get_64bit_dynamic_segment  
d283 1
a283 1
static int disassemble_section        
d286 1
a286 1
static int dump_section               
d288 1
a288 1
static int display_debug_section      
d290 1
a290 1
static int display_debug_info         
d294 1
a294 1
static int prescan_debug_info         
d296 1
a296 1
static int display_debug_lines        
d298 1
a298 1
static int display_debug_pubnames     
d300 1
a300 1
static int display_debug_abbrev       
d302 1
a302 1
static int display_debug_aranges      
d304 1
a304 1
static int display_debug_frames       
d306 1
a306 1
static int display_debug_macinfo      
d308 1
a308 1
static int display_debug_str          
d310 1
a310 1
static int display_debug_loc          
d312 1
a312 1
static unsigned char *process_abbrev_section     
d314 1
a314 1
static void load_debug_str             
d316 1
a316 1
static void free_debug_str             
d318 1
a318 1
static const char *fetch_indirect_string      
d320 1
a320 1
static void load_debug_loc             
d322 1
a322 1
static void free_debug_loc             
d324 1
a324 1
static unsigned long read_leb128                
d326 1
a326 1
static int process_extended_line_op   
d328 1
a328 1
static void reset_state_machine        
d330 1
a330 1
static char *get_TAG_name               
d332 1
a332 1
static char *get_AT_name                
d334 1
a334 1
static char *get_FORM_name              
d336 1
a336 1
static void free_abbrevs               
d338 1
a338 1
static void add_abbrev                 
d340 1
a340 1
static void add_abbrev_attr            
d342 1
a342 1
static unsigned char *read_and_display_attr      
d348 1
a348 1
static unsigned char *display_block              
d350 1
a350 1
static void decode_location_expression 
d352 1
a352 1
static void request_dump               
d354 1
a354 1
static const char *get_elf_class              
d356 1
a356 1
static const char *get_data_encoding          
d358 1
a358 1
static const char *get_osabi_name             
d360 1
a360 1
static int guess_is_rela              
d362 1
a362 1
static const char *get_note_type		        
d364 1
a364 1
static const char *get_netbsd_elfcore_note_type  
d366 1
a366 1
static int process_note		        
d368 1
a368 1
static int process_corefile_note_segment 
d372 1
a372 1
static int process_corefile_contents	
d374 1
a374 1
static int process_arch_specific		
d376 1
a376 1
static int process_gnu_liblist		
d3143 8
a3150 2
	    loadaddr = (segment->p_vaddr & 0xfffff000)
	      - (segment->p_offset & 0xfffff000);
d3794 2
a3795 1
			    dynamic_symbols, num_dynamic_syms, dynamic_strings, is_rela);
d4661 1
a4661 1
      unsigned int syminsz = 0;
d4711 1
a4711 1
    printf (_("\nDynamic segment at offset 0x%x contains %ld entries:\n"),
@


1.182
log
@	* readelf.c Replace occurrences of Elf32_Internal_* and
	Elf64_Internal_* with Elf_Internal_*.
	(slurp_rel_relocs): Change Elf_Internal_Rel to Elf_Internal_Rela.
	Zero r_addend fields.
	(dump_relocations): Remove relas variable, change Elf_Internal_Rel to
	Elf_Internal_Rela.
@
text
@d34 1
a34 1
   Only do this if we belive that the compiler can support a 64 bit
d92 48
a139 48
char *			program_name = "readelf";
unsigned int		dynamic_addr;
bfd_size_type		dynamic_size;
unsigned int		rela_addr;
unsigned int		rela_size;
char *			dynamic_strings;
char *			string_table;
unsigned long		string_table_length;
unsigned long           num_dynamic_syms;
Elf_Internal_Sym *	dynamic_symbols;
Elf_Internal_Syminfo *	dynamic_syminfo;
unsigned long		dynamic_syminfo_offset;
unsigned int		dynamic_syminfo_nent;
char			program_interpreter [64];
int			dynamic_info[DT_JMPREL + 1];
int			version_info[16];
int			loadaddr = 0;
Elf_Internal_Ehdr       elf_header;
Elf_Internal_Shdr *     section_headers;
Elf_Internal_Dyn *      dynamic_segment;
Elf_Internal_Shdr *     symtab_shndx_hdr;
int			show_name;
int			do_dynamic;
int			do_syms;
int			do_reloc;
int			do_sections;
int			do_segments;
int			do_unwind;
int			do_using_dynamic;
int			do_header;
int			do_dump;
int			do_version;
int			do_wide;
int			do_histogram;
int			do_debugging;
int                     do_debug_info;
int                     do_debug_abbrevs;
int                     do_debug_lines;
int                     do_debug_pubnames;
int                     do_debug_aranges;
int                     do_debug_frames;
int                     do_debug_frames_interp;
int			do_debug_macinfo;
int			do_debug_str;
int                     do_debug_loc;
int                     do_arch;
int                     do_notes;
int			is_32bit_elf;
d142 2
a143 2
char *			dump_sects = NULL;
unsigned int		num_dump_sects = 0;
d163 121
a283 59
static void		  print_vma		      PARAMS ((bfd_vma, print_mode));
static void		  print_symbol		      PARAMS ((int, const char *));
static bfd_vma (*         byte_get)                   PARAMS ((unsigned char *, int));
static bfd_vma            byte_get_little_endian      PARAMS ((unsigned char *, int));
static bfd_vma            byte_get_big_endian         PARAMS ((unsigned char *, int));
static const char *       get_mips_dynamic_type       PARAMS ((unsigned long));
static const char *       get_sparc64_dynamic_type    PARAMS ((unsigned long));
static const char *       get_ppc64_dynamic_type      PARAMS ((unsigned long));
static const char *       get_parisc_dynamic_type     PARAMS ((unsigned long));
static const char *       get_dynamic_type            PARAMS ((unsigned long));
static int		  slurp_rela_relocs	      PARAMS ((FILE *, unsigned long, unsigned long, Elf_Internal_Rela **, unsigned long *));
static int		  slurp_rel_relocs	      PARAMS ((FILE *, unsigned long, unsigned long, Elf_Internal_Rela **, unsigned long *));
static int                dump_relocations            PARAMS ((FILE *, unsigned long, unsigned long, Elf_Internal_Sym *, unsigned long, char *, int));
static char *             get_file_type               PARAMS ((unsigned));
static char *             get_machine_name            PARAMS ((unsigned));
static void		  decode_ARM_machine_flags    PARAMS ((unsigned, char []));
static char *             get_machine_flags           PARAMS ((unsigned, unsigned));
static const char *       get_mips_segment_type       PARAMS ((unsigned long));
static const char *       get_parisc_segment_type     PARAMS ((unsigned long));
static const char *       get_ia64_segment_type       PARAMS ((unsigned long));
static const char *       get_segment_type            PARAMS ((unsigned long));
static const char *       get_mips_section_type_name  PARAMS ((unsigned int));
static const char *       get_parisc_section_type_name PARAMS ((unsigned int));
static const char *       get_ia64_section_type_name  PARAMS ((unsigned int));
static const char *       get_section_type_name       PARAMS ((unsigned int));
static const char *       get_symbol_binding          PARAMS ((unsigned int));
static const char *       get_symbol_type             PARAMS ((unsigned int));
static const char *       get_symbol_visibility       PARAMS ((unsigned int));
static const char *       get_symbol_index_type       PARAMS ((unsigned int));
static const char *       get_dynamic_flags	      PARAMS ((bfd_vma));
static void               usage                       PARAMS ((void));
static void               parse_args                  PARAMS ((int, char **));
static int                process_file_header         PARAMS ((void));
static int                process_program_headers     PARAMS ((FILE *));
static int                process_section_headers     PARAMS ((FILE *));
static int		  process_unwind	      PARAMS ((FILE *));
static void               dynamic_segment_mips_val    PARAMS ((Elf_Internal_Dyn *));
static void               dynamic_segment_parisc_val  PARAMS ((Elf_Internal_Dyn *));
static int                process_dynamic_segment     PARAMS ((FILE *));
static int                process_symbol_table        PARAMS ((FILE *));
static int                process_syminfo             PARAMS ((FILE *));
static int                process_section_contents    PARAMS ((FILE *));
static void               process_mips_fpe_exception  PARAMS ((int));
static int                process_mips_specific       PARAMS ((FILE *));
static int                process_file                PARAMS ((char *));
static int                process_relocs              PARAMS ((FILE *));
static int                process_version_sections    PARAMS ((FILE *));
static char *             get_ver_flags               PARAMS ((unsigned int));
static int                get_32bit_section_headers   PARAMS ((FILE *, unsigned int));
static int                get_64bit_section_headers   PARAMS ((FILE *, unsigned int));
static int		  get_32bit_program_headers   PARAMS ((FILE *, Elf_Internal_Phdr *));
static int		  get_64bit_program_headers   PARAMS ((FILE *, Elf_Internal_Phdr *));
static int                get_file_header             PARAMS ((FILE *));
static Elf_Internal_Sym * get_32bit_elf_symbols       PARAMS ((FILE *, Elf_Internal_Shdr *));
static Elf_Internal_Sym * get_64bit_elf_symbols       PARAMS ((FILE *, Elf_Internal_Shdr *));
static const char *	  get_elf_section_flags	      PARAMS ((bfd_vma));
static int *              get_dynamic_data            PARAMS ((FILE *, unsigned int));
static int                get_32bit_dynamic_segment   PARAMS ((FILE *));
static int                get_64bit_dynamic_segment   PARAMS ((FILE *));
d285 2
a286 1
static int	          disassemble_section         PARAMS ((Elf_Internal_Shdr *, FILE *));
d288 92
a379 45
static int	          dump_section                PARAMS ((Elf_Internal_Shdr *, FILE *));
static int	          display_debug_section       PARAMS ((Elf_Internal_Shdr *, FILE *));
static int                display_debug_info          PARAMS ((Elf_Internal_Shdr *, unsigned char *, FILE *));
static int                display_debug_not_supported PARAMS ((Elf_Internal_Shdr *, unsigned char *, FILE *));
static int                prescan_debug_info          PARAMS ((Elf_Internal_Shdr *, unsigned char *, FILE *));
static int                display_debug_lines         PARAMS ((Elf_Internal_Shdr *, unsigned char *, FILE *));
static int                display_debug_pubnames      PARAMS ((Elf_Internal_Shdr *, unsigned char *, FILE *));
static int                display_debug_abbrev        PARAMS ((Elf_Internal_Shdr *, unsigned char *, FILE *));
static int                display_debug_aranges       PARAMS ((Elf_Internal_Shdr *, unsigned char *, FILE *));
static int                display_debug_frames        PARAMS ((Elf_Internal_Shdr *, unsigned char *, FILE *));
static int                display_debug_macinfo       PARAMS ((Elf_Internal_Shdr *, unsigned char *, FILE *));
static int                display_debug_str           PARAMS ((Elf_Internal_Shdr *, unsigned char *, FILE *));
static int                display_debug_loc           PARAMS ((Elf_Internal_Shdr *, unsigned char *, FILE *));
static unsigned char *    process_abbrev_section      PARAMS ((unsigned char *, unsigned char *));
static void               load_debug_str              PARAMS ((FILE *));
static void               free_debug_str              PARAMS ((void));
static const char *       fetch_indirect_string       PARAMS ((unsigned long));
static void               load_debug_loc              PARAMS ((FILE *));
static void               free_debug_loc              PARAMS ((void));
static unsigned long      read_leb128                 PARAMS ((unsigned char *, int *, int));
static int                process_extended_line_op    PARAMS ((unsigned char *, int, int));
static void               reset_state_machine         PARAMS ((int));
static char *             get_TAG_name                PARAMS ((unsigned long));
static char *             get_AT_name                 PARAMS ((unsigned long));
static char *             get_FORM_name               PARAMS ((unsigned long));
static void               free_abbrevs                PARAMS ((void));
static void               add_abbrev                  PARAMS ((unsigned long, unsigned long, int));
static void               add_abbrev_attr             PARAMS ((unsigned long, unsigned long));
static unsigned char *    read_and_display_attr       PARAMS ((unsigned long, unsigned long, unsigned char *, unsigned long, unsigned long));
static unsigned char *    read_and_display_attr_value PARAMS ((unsigned long, unsigned long, unsigned char *, unsigned long, unsigned long));
static unsigned char *    display_block               PARAMS ((unsigned char *, unsigned long));
static void               decode_location_expression  PARAMS ((unsigned char *, unsigned int, unsigned long));
static void		  request_dump                PARAMS ((unsigned int, int));
static const char *       get_elf_class               PARAMS ((unsigned int));
static const char *       get_data_encoding           PARAMS ((unsigned int));
static const char *       get_osabi_name              PARAMS ((unsigned int));
static int		  guess_is_rela               PARAMS ((unsigned long));
static const char *	  get_note_type		         PARAMS ((unsigned int));
static const char *	  get_netbsd_elfcore_note_type   PARAMS ((unsigned int));
static int		  process_note		         PARAMS ((Elf_Internal_Note *));
static int		  process_corefile_note_segment  PARAMS ((FILE *, bfd_vma, bfd_vma));
static int		  process_corefile_note_segments PARAMS ((FILE *));
static int		  process_corefile_contents	 PARAMS ((FILE *));
static int		  process_arch_specific		 PARAMS ((FILE *));
static int		  process_gnu_liblist		 PARAMS ((FILE *));
a382 4
#ifndef TRUE
#define TRUE     1
#define FALSE    0
#endif
d499 2
a500 2
     unsigned char * field;
     int             size;
d505 1
a505 1
      return * field;
d508 2
a509 2
      return  ((unsigned int) (field [0]))
	|    (((unsigned int) (field [1])) << 8);
d519 4
a522 4
      return  ((unsigned long) (field [0]))
	|    (((unsigned long) (field [1])) << 8)
	|    (((unsigned long) (field [2])) << 16)
	|    (((unsigned long) (field [3])) << 24);
d531 8
a538 8
      return  ((bfd_vma) (field [0]))
	|    (((bfd_vma) (field [1])) << 8)
	|    (((bfd_vma) (field [2])) << 16)
	|    (((bfd_vma) (field [3])) << 24)
	|    (((bfd_vma) (field [4])) << 32)
	|    (((bfd_vma) (field [5])) << 40)
	|    (((bfd_vma) (field [6])) << 48)
	|    (((bfd_vma) (field [7])) << 56);
d644 1
a644 1
     const char * symbol;
d656 2
a657 2
     unsigned char * field;
     int             size;
d662 1
a662 1
      return * field;
d665 1
a665 1
      return ((unsigned int) (field [1])) | (((int) (field [0])) << 8);
d668 4
a671 4
      return ((unsigned long) (field [3]))
	|   (((unsigned long) (field [2])) << 8)
	|   (((unsigned long) (field [1])) << 16)
	|   (((unsigned long) (field [0])) << 24);
d677 4
a680 4
      return ((unsigned long) (field [7]))
	|   (((unsigned long) (field [6])) << 8)
	|   (((unsigned long) (field [5])) << 16)
	|   (((unsigned long) (field [4])) << 24);
d688 8
a695 8
      return ((bfd_vma) (field [7]))
	|   (((bfd_vma) (field [6])) << 8)
	|   (((bfd_vma) (field [5])) << 16)
	|   (((bfd_vma) (field [4])) << 24)
	|   (((bfd_vma) (field [3])) << 32)
	|   (((bfd_vma) (field [2])) << 40)
	|   (((bfd_vma) (field [1])) << 48)
	|   (((bfd_vma) (field [0])) << 56);
d804 1
a804 1
      Elf32_External_Rela * erelas;
d833 1
a833 1
      Elf64_External_Rela * erelas;
d879 1
a879 1
      Elf32_External_Rel * erels;
d907 1
a907 1
      Elf64_External_Rel * erels;
d941 7
a947 7
     FILE *             file;
     unsigned long      rel_offset;
     unsigned long      rel_size;
     Elf_Internal_Sym * symtab;
     unsigned long      nsyms;
     char *             strtab;
     int                is_rela;
d949 2
a950 2
  unsigned int        i;
  Elf_Internal_Rela * rels;
d1004 9
a1012 9
      const char * rtype;
      const char * rtype2 = NULL;
      const char * rtype3 = NULL;
      bfd_vma      offset;
      bfd_vma      info;
      bfd_vma      symtab_index;
      bfd_vma      type;
      bfd_vma      type2 = (bfd_vma) NULL;
      bfd_vma      type3 = (bfd_vma) NULL;
d1014 2
a1015 2
      offset = rels [i].r_offset;
      info   = rels [i].r_info;
d1259 1
a1259 1
	      Elf_Internal_Sym * psym;
d1303 1
a1303 1
		printf (" + %lx", (unsigned long) rels [i].r_addend);
d1459 1
a1459 1
  static char buff [32];
d1538 1
a1538 1
	  const char * result;
d1564 1
a1564 1
	  const char * result;
d1592 1
a1592 1
  static char buff [32];
d1617 1
a1617 1
  static char buff [64]; /* XXX */
d1642 1
a1642 1
    case EM_MCORE:	        return "MCORE";
d1661 1
a1661 1
    case EM_D30V:	        return "d30v";
d1672 1
a1672 1
    case EM_CYGNUS_FRV:	        return "Fujitsu FR-V";
d1674 1
a1674 1
    case EM_PJ:                 return "picoJava";
d1694 1
a1694 1
    case EM_AVR:                return "Atmel AVR 8-bit microcontroller";
d1699 1
a1699 1
    case EM_MMIX:	        return "Donald Knuth's educational 64-bit processor";
d1704 1
a1704 1
    case EM_S390:               return "IBM S/390";
d1710 1
a1710 1
    case EM_IP2K:               return "Ubicom IP2xxx 8-bit microcontrollers";
d1864 1
a1864 1
  static char buf [1024];
d2159 1
a2159 1
  static char buff [32];
d2163 2
a2164 2
    case PT_NULL:       return "NULL";
    case PT_LOAD:       return "LOAD";
d2166 4
a2169 4
    case PT_INTERP:     return "INTERP";
    case PT_NOTE:       return "NOTE";
    case PT_SHLIB:      return "SHLIB";
    case PT_PHDR:       return "PHDR";
d2178 1
a2178 1
	  const char * result;
d2204 1
a2204 1
	  const char * result;
d2237 38
a2274 38
    case SHT_MIPS_LIBLIST:       return "MIPS_LIBLIST";
    case SHT_MIPS_MSYM:          return "MIPS_MSYM";
    case SHT_MIPS_CONFLICT:      return "MIPS_CONFLICT";
    case SHT_MIPS_GPTAB:         return "MIPS_GPTAB";
    case SHT_MIPS_UCODE:         return "MIPS_UCODE";
    case SHT_MIPS_DEBUG:         return "MIPS_DEBUG";
    case SHT_MIPS_REGINFO:       return "MIPS_REGINFO";
    case SHT_MIPS_PACKAGE:       return "MIPS_PACKAGE";
    case SHT_MIPS_PACKSYM:       return "MIPS_PACKSYM";
    case SHT_MIPS_RELD:          return "MIPS_RELD";
    case SHT_MIPS_IFACE:         return "MIPS_IFACE";
    case SHT_MIPS_CONTENT:       return "MIPS_CONTENT";
    case SHT_MIPS_OPTIONS:       return "MIPS_OPTIONS";
    case SHT_MIPS_SHDR:          return "MIPS_SHDR";
    case SHT_MIPS_FDESC:         return "MIPS_FDESC";
    case SHT_MIPS_EXTSYM:        return "MIPS_EXTSYM";
    case SHT_MIPS_DENSE:         return "MIPS_DENSE";
    case SHT_MIPS_PDESC:         return "MIPS_PDESC";
    case SHT_MIPS_LOCSYM:        return "MIPS_LOCSYM";
    case SHT_MIPS_AUXSYM:        return "MIPS_AUXSYM";
    case SHT_MIPS_OPTSYM:        return "MIPS_OPTSYM";
    case SHT_MIPS_LOCSTR:        return "MIPS_LOCSTR";
    case SHT_MIPS_LINE:          return "MIPS_LINE";
    case SHT_MIPS_RFDESC:        return "MIPS_RFDESC";
    case SHT_MIPS_DELTASYM:      return "MIPS_DELTASYM";
    case SHT_MIPS_DELTAINST:     return "MIPS_DELTAINST";
    case SHT_MIPS_DELTACLASS:    return "MIPS_DELTACLASS";
    case SHT_MIPS_DWARF:         return "MIPS_DWARF";
    case SHT_MIPS_DELTADECL:     return "MIPS_DELTADECL";
    case SHT_MIPS_SYMBOL_LIB:    return "MIPS_SYMBOL_LIB";
    case SHT_MIPS_EVENTS:        return "MIPS_EVENTS";
    case SHT_MIPS_TRANSLATE:     return "MIPS_TRANSLATE";
    case SHT_MIPS_PIXIE:         return "MIPS_PIXIE";
    case SHT_MIPS_XLATE:         return "MIPS_XLATE";
    case SHT_MIPS_XLATE_DEBUG:   return "MIPS_XLATE_DEBUG";
    case SHT_MIPS_WHIRL:         return "MIPS_WHIRL";
    case SHT_MIPS_EH_REGION:     return "MIPS_EH_REGION";
    case SHT_MIPS_XLATE_OLD:     return "MIPS_XLATE_OLD";
d2315 1
a2315 1
  static char buff [32];
d2339 2
a2340 2
    case 0x6ffffff0:	        return "VERSYM";
    case 0x6ffffffc:	        return "VERDEF";
d2348 1
a2348 1
	  const char * result;
d2385 1
a2385 1
struct option options [] =
d2387 1
a2387 1
  {"all",              no_argument, 0, 'a'},
d2390 4
a2393 4
  {"headers",          no_argument, 0, 'e'},
  {"histogram",        no_argument, 0, 'I'},
  {"segments",         no_argument, 0, 'l'},
  {"sections",         no_argument, 0, 'S'},
d2395 5
a2399 5
  {"symbols",          no_argument, 0, 's'},
  {"syms",             no_argument, 0, 's'},
  {"relocs",           no_argument, 0, 'r'},
  {"notes",            no_argument, 0, 'n'},
  {"dynamic",          no_argument, 0, 'd'},
d2403 1
a2403 1
  {"hex-dump",         required_argument, 0, 'x'},
d2410 4
a2413 4
  {"version",          no_argument, 0, 'v'},
  {"wide",             no_argument, 0, 'W'},
  {"help",             no_argument, 0, 'H'},
  {0,                  no_argument, 0, 0}
d2460 1
a2460 1
     int         type;
d2464 1
a2464 1
      char * new_dump_sects;
d2483 1
a2483 1
    dump_sects [section] |= type;
d2491 1
a2491 1
     char ** argv;
d2501 2
a2502 2
      char *    cp;
      int	section;
d2514 11
a2524 11
	  do_syms ++;
	  do_reloc ++;
	  do_unwind ++;
	  do_dynamic ++;
	  do_header ++;
	  do_sections ++;
	  do_segments ++;
	  do_version ++;
	  do_histogram ++;
	  do_arch ++;
	  do_notes ++;
d2527 3
a2529 3
	  do_header ++;
	  do_sections ++;
	  do_segments ++;
d2532 1
a2532 1
	  do_arch ++;
d2535 1
a2535 1
	  do_using_dynamic ++;
d2538 1
a2538 1
	  do_reloc ++;
d2541 1
a2541 1
	  do_unwind ++;
d2544 1
a2544 1
	  do_header ++;
d2547 1
a2547 1
	  do_segments ++;
d2550 1
a2550 1
	  do_syms ++;
d2553 1
a2553 1
	  do_sections ++;
d2556 1
a2556 1
	  do_dynamic ++;
d2559 1
a2559 1
	  do_histogram ++;
d2562 1
a2562 1
	  do_notes ++;
d2565 1
a2565 1
	  do_dump ++;
d2567 1
a2567 1
	  if (! * cp && section >= 0)
d2574 1
a2574 1
	  do_dump ++;
d2639 1
a2639 1
	  do_dump ++;
d2722 1
a2722 1
	  do_dump ++;
d2724 1
a2724 1
	  if (! * cp && section >= 0)
d2735 1
a2735 1
	  do_version ++;
d2738 1
a2738 1
	  do_wide ++;
d2765 1
a2765 1
  static char buff [32];
d2782 1
a2782 1
  static char buff [32];
d2799 1
a2799 1
  static char buff [32];
d2803 14
a2816 14
    case ELFOSABI_NONE:       return "UNIX - System V";
    case ELFOSABI_HPUX:       return "UNIX - HP-UX";
    case ELFOSABI_NETBSD:     return "UNIX - NetBSD";
    case ELFOSABI_LINUX:      return "UNIX - Linux";
    case ELFOSABI_HURD:       return "GNU/Hurd";
    case ELFOSABI_SOLARIS:    return "UNIX - Solaris";
    case ELFOSABI_AIX:        return "UNIX - AIX";
    case ELFOSABI_IRIX:       return "UNIX - IRIX";
    case ELFOSABI_FREEBSD:    return "UNIX - FreeBSD";
    case ELFOSABI_TRU64:      return "UNIX - TRU64";
    case ELFOSABI_MODESTO:    return "Novell - Modesto";
    case ELFOSABI_OPENBSD:    return "UNIX - OpenBSD";
    case ELFOSABI_STANDALONE: return _("Standalone App");
    case ELFOSABI_ARM:        return "ARM";
d2827 4
a2830 4
  if (   elf_header.e_ident [EI_MAG0] != ELFMAG0
      || elf_header.e_ident [EI_MAG1] != ELFMAG1
      || elf_header.e_ident [EI_MAG2] != ELFMAG2
      || elf_header.e_ident [EI_MAG3] != ELFMAG3)
d2843 2
a2844 2
      for (i = 0; i < EI_NIDENT; i ++)
	printf ("%2.2x ", elf_header.e_ident [i]);
d2847 1
a2847 1
	      get_elf_class (elf_header.e_ident [EI_CLASS]));
d2849 1
a2849 1
	      get_data_encoding (elf_header.e_ident [EI_DATA]));
d2851 2
a2852 2
	      elf_header.e_ident [EI_VERSION],
	      (elf_header.e_ident [EI_VERSION] == EV_CURRENT
d2854 1
a2854 1
	       : (elf_header.e_ident [EI_VERSION] != EV_NONE
d2858 1
a2858 1
	      get_osabi_name (elf_header.e_ident [EI_OSABI]));
d2860 1
a2860 1
	      elf_header.e_ident [EI_ABIVERSION]);
d2915 2
a2916 2
     FILE * file;
     Elf_Internal_Phdr * program_headers;
d2918 4
a2921 4
  Elf32_External_Phdr * phdrs;
  Elf32_External_Phdr * external;
  Elf_Internal_Phdr *   internal;
  unsigned int          i;
d2932 1
a2932 1
       i ++, internal ++, external ++)
d2951 2
a2952 2
     FILE * file;
     Elf_Internal_Phdr * program_headers;
d2954 4
a2957 4
  Elf64_External_Phdr * phdrs;
  Elf64_External_Phdr * external;
  Elf_Internal_Phdr *   internal;
  unsigned int          i;
d2968 1
a2968 1
       i ++, internal ++, external ++)
d2989 1
a2989 1
     FILE * file;
d2991 3
a2993 3
  Elf_Internal_Phdr * program_headers;
  Elf_Internal_Phdr * segment;
  unsigned int	      i;
d3061 1
a3061 1
       i ++, segment ++)
d3192 1
a3192 1
	  Elf_Internal_Shdr * section;
d3199 1
a3199 1
	  for (j = 1; j < elf_header.e_shnum; j++, section ++)
d3226 1
a3226 1
     FILE * file;
d3229 3
a3231 3
  Elf32_External_Shdr * shdrs;
  Elf_Internal_Shdr *   internal;
  unsigned int          i;
d3251 1
a3251 1
       i ++, internal ++)
d3272 1
a3272 1
     FILE * file;
d3275 3
a3277 3
  Elf64_External_Shdr * shdrs;
  Elf_Internal_Shdr *   internal;
  unsigned int          i;
d3297 1
a3297 1
       i ++, internal ++)
d3318 1
a3318 1
     FILE * file;
d3322 1
a3322 1
  Elf32_External_Sym * esyms;
d3324 3
a3326 3
  Elf_Internal_Sym *   isyms;
  Elf_Internal_Sym *   psym;
  unsigned int         j;
d3363 1
a3363 1
       j ++, psym ++)
d3385 1
a3385 1
     FILE * file;
d3389 1
a3389 1
  Elf64_External_Sym * esyms;
d3391 3
a3393 3
  Elf_Internal_Sym *   isyms;
  Elf_Internal_Sym *   psym;
  unsigned int         j;
d3430 1
a3430 1
       j ++, psym ++)
d3454 1
a3454 1
  static char buff [32];
d3456 1
a3456 1
  * buff = 0;
d3467 7
a3473 7
	case SHF_WRITE:            strcat (buff, "W"); break;
	case SHF_ALLOC:            strcat (buff, "A"); break;
	case SHF_EXECINSTR:        strcat (buff, "X"); break;
	case SHF_MERGE:            strcat (buff, "M"); break;
	case SHF_STRINGS:          strcat (buff, "S"); break;
	case SHF_INFO_LINK:        strcat (buff, "I"); break;
	case SHF_LINK_ORDER:       strcat (buff, "L"); break;
d3475 1
a3475 1
	case SHF_GROUP:            strcat (buff, "G"); break;
d3500 1
a3500 1
     FILE * file;
d3502 2
a3503 2
  Elf_Internal_Shdr * section;
  unsigned int        i;
d3547 1
a3547 1
       i ++, section ++)
d3549 1
a3549 1
      char * name = SECTION_NAME (section);
d3635 1
a3635 1
       i ++, section ++)
d3736 1
a3736 1
     FILE * file;
d3738 2
a3739 2
  unsigned long    rel_size;
  unsigned long	   rel_offset;
d3758 1
a3758 1
      else if (dynamic_info [DT_RELA])
d3797 3
a3799 3
      Elf_Internal_Shdr *	section;
      unsigned long		i;
      int		found = 0;
d3803 1
a3803 1
	   i++, section ++)
d3814 5
a3818 5
	      Elf_Internal_Shdr * strsec;
	      Elf_Internal_Sym *  symtab;
	      char *              strtab;
	      int                 is_rela;
	      unsigned long       nsyms;
d3835 1
a3835 1
		  Elf_Internal_Shdr * symsec;
d3887 3
a3889 3
	struct absaddr    start;
	struct absaddr    end;
	struct absaddr    info;
d3891 10
a3900 10
    *table;				/* Unwind table.  */
    unsigned long         table_len;	/* Length of unwind table.  */
    unsigned char *       info;		/* Unwind info.  */
    unsigned long         info_size;	/* Size of unwind info.  */
    bfd_vma               info_addr;	/* starting address of unwind info.  */
    bfd_vma               seg_base;	/* Starting address of segment.  */
    Elf_Internal_Sym *    symtab;	/* The symbol table.  */
    unsigned              long nsyms;	/* Number of symbols.  */
    char *                strtab;	/* The string table.  */
    unsigned long         strtab_size;	/* Size of string table.  */
d3903 6
a3908 6
static void find_symbol_for_address PARAMS ((struct unw_aux_info *,
					     struct absaddr, const char **,
					     bfd_vma *));
static void dump_ia64_unwind PARAMS ((struct unw_aux_info *));
static int  slurp_ia64_unwind_table PARAMS ((FILE *, struct unw_aux_info *,
					    Elf_Internal_Shdr *));
d3951 1
a3951 1
  struct unw_table_entry * tp;
d3960 3
a3962 3
      const unsigned char * dp;
      const unsigned char * head;
      const char * procname;
d4066 1
a4066 1
  for (tp = table; tp < table + size; tp += 3 * addr_size, ++ tep)
d4166 1
a4166 1
     FILE * file;
d4302 1
a4302 1
     Elf_Internal_Dyn * entry;
d4321 1
a4321 1
	  for (cnt = 0; cnt < NUM_ELEM (opts); ++ cnt)
d4342 1
a4342 1
	struct tm * tmp;
d4377 1
a4377 1
     Elf_Internal_Dyn * entry;
d4386 1
a4386 1
	  const char * str;
d4434 1
a4434 1
     FILE * file;
d4436 3
a4438 3
  Elf32_External_Dyn * edyn;
  Elf_Internal_Dyn *   entry;
  bfd_size_type        i;
d4449 1
a4449 1
  while (*(Elf32_Word *) edyn [dynamic_size++].d_tag != DT_NULL)
d4464 1
a4464 1
       i ++, entry ++)
d4466 2
a4467 2
      entry->d_tag      = BYTE_GET (edyn [i].d_tag);
      entry->d_un.d_val = BYTE_GET (edyn [i].d_un.d_val);
d4477 1
a4477 1
     FILE * file;
d4479 3
a4481 3
  Elf64_External_Dyn * edyn;
  Elf_Internal_Dyn *   entry;
  bfd_size_type        i;
d4492 1
a4492 1
  while (*(bfd_vma *) edyn [dynamic_size ++].d_tag != DT_NULL)
d4507 1
a4507 1
       i ++, entry ++)
d4509 2
a4510 2
      entry->d_tag      = BYTE_GET8 (edyn [i].d_tag);
      entry->d_un.d_val = BYTE_GET8 (edyn [i].d_un.d_val);
d4522 1
a4522 1
  static char buff [128];
d4538 6
a4543 6
	case DF_ORIGIN:   strcpy (p, "ORIGIN"); break;
	case DF_SYMBOLIC: strcpy (p, "SYMBOLIC"); break;
	case DF_TEXTREL:  strcpy (p, "TEXTREL"); break;
	case DF_BIND_NOW: strcpy (p, "BIND_NOW"); break;
	case DF_STATIC_TLS: strcpy (p, "STATIC_TLS"); break;
	default:          strcpy (p, "unknown"); break;
d4554 1
a4554 1
     FILE * file;
d4556 2
a4557 2
  Elf_Internal_Dyn * entry;
  bfd_size_type      i;
d4580 1
a4580 1
	   ++i, ++ entry)
d4620 1
a4620 1
	   ++i, ++ entry)
d4623 1
a4623 1
	  long          str_tab_len;
d4660 1
a4660 1
	   ++i, ++ entry)
d4676 2
a4677 2
	  Elf_External_Syminfo * extsyminfo;
	  Elf_Internal_Syminfo * syminfo;
d4713 1
a4713 1
       i++, entry ++)
d4717 1
a4717 1
	  const char * dtype;
d4743 1
a4743 1
	        {
d4752 1
a4752 1
	        case DT_CONFIG:
d4945 1
a4945 1
	      char * name;
d5029 1
a5029 1
		  char * name;
d5033 1
a5033 1
		  if (* name)
d5054 1
a5054 1
	      struct tm * tmp;
d5067 1
a5067 1
	    version_info [DT_VERSIONTAGIDX (entry->d_tag)] =
d5097 1
a5097 1
  static char buff [32];
d5124 1
a5124 1
     FILE * file;
d5126 3
a5128 3
  Elf_Internal_Shdr * section;
  unsigned   i;
  int        found = 0;
d5135 1
a5135 1
       i++, section ++)
d5141 3
a5143 3
	    Elf_External_Verdef * edefs;
	    unsigned int          idx;
	    unsigned int          cnt;
d5164 1
a5164 1
	    for (idx = cnt = 0; cnt < section->sh_info; ++ cnt)
d5166 7
a5172 7
		char *                 vstart;
		Elf_External_Verdef *  edef;
		Elf_Internal_Verdef    ent;
		Elf_External_Verdaux * eaux;
		Elf_Internal_Verdaux   aux;
		int                    j;
		int                    isum;
d5206 1
a5206 1
		for (j = 1; j < ent.vd_cnt; j ++)
d5233 3
a5235 3
	    Elf_External_Verneed *  eneed;
	    unsigned int            idx;
	    unsigned int            cnt;
d5256 5
a5260 5
		Elf_External_Verneed * entry;
		Elf_Internal_Verneed     ent;
		int                      j;
		int                      isum;
		char *                   vstart;
d5285 2
a5286 2
		    Elf_External_Vernaux * eaux;
		    Elf_Internal_Vernaux   aux;
d5319 8
a5326 8
	    Elf_Internal_Shdr *		link_section;
	    int              		total;
	    int              		cnt;
	    unsigned char * 		edata;
	    unsigned short * 		data;
	    char *           		strtab;
	    Elf_Internal_Sym * 		symbols;
	    Elf_Internal_Shdr *		string_sec;
d5366 2
a5367 2
	      data [cnt] = byte_get (edata + cnt * sizeof (short),
				     sizeof (short));
d5375 1
a5375 1
		char * name;
d5380 1
a5380 1
		  switch (data [cnt + j])
d5391 2
a5392 2
		      nn = printf ("%4x%c", data [cnt + j] & 0x7fff,
				   data [cnt + j] & 0x8000 ? 'h' : ' ');
d5396 1
a5396 1
		      if (SECTION_HEADER (symbols [cnt + j].st_shndx)->sh_type
d5399 1
a5399 1
			  if (symbols [cnt + j].st_shndx == SHN_UNDEF)
d5406 1
a5406 1
			  && version_info [DT_VERSIONTAGIDX (DT_VERNEED)])
d5408 2
a5409 2
			  Elf_Internal_Verneed     ivn;
			  unsigned long            offset;
d5411 1
a5411 1
			  offset = version_info [DT_VERSIONTAGIDX (DT_VERNEED)]
d5414 1
a5414 1
		          do
d5416 4
a5419 4
			      Elf_Internal_Vernaux   ivna;
			      Elf_External_Verneed   evn;
			      Elf_External_Vernaux   evna;
			      unsigned long          a_off;
d5439 1
a5439 1
			      while (ivna.vna_other != data [cnt + j]
d5442 1
a5442 1
			      if (ivna.vna_other == data [cnt + j])
d5460 2
a5461 2
		      if (check_def && data [cnt + j] != 0x8001
			  && version_info [DT_VERSIONTAGIDX (DT_VERDEF)])
d5463 3
a5465 3
			  Elf_Internal_Verdef  ivd;
			  Elf_External_Verdef  evd;
			  unsigned long        offset;
d5467 2
a5468 2
			  offset = version_info
			    [DT_VERSIONTAGIDX (DT_VERDEF)] - loadaddr;
d5480 1
a5480 1
			  while (ivd.vd_ndx != (data [cnt + j] & 0x7fff)
d5483 1
a5483 1
			  if (ivd.vd_ndx == (data [cnt + j] & 0x7fff))
d5485 2
a5486 2
			      Elf_External_Verdaux  evda;
			      Elf_Internal_Verdaux  ivda;
d5532 1
a5532 1
  static char buff [32];
d5536 3
a5538 3
    case STB_LOCAL:  return "LOCAL";
    case STB_GLOBAL: return "GLOBAL";
    case STB_WEAK:   return "WEAK";
d5554 1
a5554 1
  static char buff [32];
d5558 7
a5564 7
    case STT_NOTYPE:   return "NOTYPE";
    case STT_OBJECT:   return "OBJECT";
    case STT_FUNC:     return "FUNC";
    case STT_SECTION:  return "SECTION";
    case STT_FILE:     return "FILE";
    case STT_COMMON:   return "COMMON";
    case STT_TLS:      return "TLS";
d5603 3
a5605 3
    case STV_DEFAULT:   return "DEFAULT";
    case STV_INTERNAL:  return "INTERNAL";
    case STV_HIDDEN:    return "HIDDEN";
d5615 1
a5615 1
  static char buff [32];
d5619 3
a5621 3
    case SHN_UNDEF:  return "UND";
    case SHN_ABS:    return "ABS";
    case SHN_COMMON: return "COM";
d5639 1
a5639 1
     FILE *       file;
d5642 2
a5643 2
  unsigned char * e_data;
  int *  i_data;
d5659 1
a5659 1
  i_data = (int *) malloc (number * sizeof (* i_data));
d5669 1
a5669 1
    i_data [number] = byte_get (e_data + number * 4, 4);
d5679 1
a5679 1
     FILE * file;
d5681 7
a5687 7
  Elf_Internal_Shdr * section;
  unsigned char   nb [4];
  unsigned char   nc [4];
  int    nbuckets = 0;
  int    nchains = 0;
  int *  buckets = NULL;
  int *  chains = NULL;
d5726 2
a5727 2
      int    hn;
      int    si;
d5737 1
a5737 1
	  if (! buckets [hn])
d5740 1
a5740 1
	  for (si = buckets [hn]; si < nchains && si > 0; si = chains [si])
d5742 1
a5742 1
	      Elf_Internal_Sym * psym;
d5762 1
a5762 1
      unsigned int     i;
d5768 4
a5771 4
	  unsigned int          si;
	  char *                strtab;
	  Elf_Internal_Sym *    symtab;
	  Elf_Internal_Sym *    psym;
d5794 1
a5794 1
	      Elf_Internal_Shdr * string_sec;
d5805 1
a5805 1
	       si ++, psym ++)
d5818 1
a5818 1
		  version_info [DT_VERSIONTAGIDX (DT_VERSYM)] != 0)
d5820 5
a5824 5
		  unsigned char   data[2];
		  unsigned short  vers_data;
		  unsigned long   offset;
		  int             is_nobits;
		  int             check_def;
d5826 1
a5826 1
		  offset = version_info [DT_VERSIONTAGIDX (DT_VERSYM)]
d5841 1
a5841 1
		      if (version_info [DT_VERSIONTAGIDX (DT_VERNEED)]
d5844 3
a5846 3
			  Elf_External_Verneed  evn;
			  Elf_Internal_Verneed  ivn;
			  Elf_Internal_Vernaux  ivna;
d5849 2
a5850 2
			  offset = version_info
			    [DT_VERSIONTAGIDX (DT_VERNEED)] - loadaddr;
d5854 1
a5854 1
			      unsigned long  vna_off;
d5866 1
a5866 1
				  Elf_External_Vernaux  evna;
d5903 1
a5903 1
			      && version_info [DT_VERSIONTAGIDX (DT_VERDEF)])
d5905 8
a5912 8
			      Elf_Internal_Verdef     ivd;
			      Elf_Internal_Verdaux    ivda;
			      Elf_External_Verdaux  evda;
			      unsigned long           offset;

			      offset =
				version_info [DT_VERSIONTAGIDX (DT_VERDEF)]
				- loadaddr;
d5916 1
a5916 1
				  Elf_External_Verdef   evd;
d5921 2
a5922 2
				  ivd.vd_ndx  = BYTE_GET (evd.vd_ndx);
				  ivd.vd_aux  = BYTE_GET (evd.vd_aux);
d5961 7
a5967 7
      int * lengths;
      int * counts;
      int   hn;
      int   si;
      int   maxlength = 0;
      int   nzero_counts = 0;
      int   nsyms = 0;
d5981 1
a5981 1
	  if (! buckets [hn])
d5986 1
a5986 1
	      ++ nsyms;
d5988 1
a5988 1
		++ maxlength;
d6000 1
a6000 1
	++ counts [lengths [hn]];
d6030 1
a6030 1
     FILE * file ATTRIBUTE_UNUSED;
d6068 4
a6071 3
	      print_symbol (10, dynamic_strings
			    + dynamic_segment
			    [dynamic_syminfo[i].si_boundto].d_un.d_val);
d6097 2
a6098 2
     Elf_Internal_Shdr * section;
     FILE * file;
d6111 2
a6112 2
     Elf_Internal_Shdr * section;
     FILE * file;
d6114 4
a6117 4
  bfd_size_type   bytes;
  bfd_vma         addr;
  unsigned char * data;
  unsigned char * start;
d6149 1
a6149 1
      switch (elf_header.e_ident [EI_DATA])
d6156 1
a6156 1
		printf ("%2.2x", data [j]);
d6169 1
a6169 1
		printf ("%2.2x", data [j]);
d6181 1
a6181 1
	  k = data [j];
d6203 3
a6205 3
     unsigned char * data;
     int *           length_return;
     int             sign;
d6208 3
a6210 3
  unsigned int      num_read = 0;
  int               shift = 0;
  unsigned char     byte;
d6214 2
a6215 2
      byte = * data ++;
      num_read ++;
d6225 1
a6225 1
    * length_return = num_read;
d6235 7
a6241 7
  unsigned long	address;
  unsigned int  file;
  unsigned int  line;
  unsigned int  column;
  int           is_stmt;
  int           basic_block;
  int	        end_sequence;
d6244 1
a6244 1
  unsigned int  last_file_entry;
d6267 1
a6267 1
     unsigned char * data;
d6271 5
a6275 5
  unsigned char   op_code;
  int             bytes_read;
  unsigned int    len;
  unsigned char * name;
  unsigned long   adr;
d6287 1
a6287 1
  op_code = * data ++;
d6308 1
a6308 1
      printf (_("   %d\t"), ++ state_machine_regs.last_file_entry);
d6334 11
a6344 11
     Elf_Internal_Shdr *   section;
     unsigned char *       start;
     FILE *                file ATTRIBUTE_UNUSED;
{
  DWARF2_External_LineInfo * external;
  DWARF2_Internal_LineInfo   info;
  unsigned char *            standard_opcodes;
  unsigned char *            data = start;
  unsigned char *            end  = start + section->sh_size;
  unsigned char *            end_of_sequence;
  int                        i;
d6402 1
a6402 1
      standard_opcodes = data + sizeof (* external);
d6412 1
a6412 1
      if (* data == 0)
d6418 1
a6418 1
	  while (* data != 0)
d6427 1
a6427 1
      data ++;
d6430 1
a6430 1
      if (* data == 0)
d6437 1
a6437 1
	  while (* data != 0)
d6439 1
a6439 1
	      unsigned char * name;
d6442 1
a6442 1
	      printf (_("  %d\t"), ++ state_machine_regs.last_file_entry);
d6458 1
a6458 1
      data ++;
d6467 2
a6468 2
	  int           adv;
	  int           bytes_read;
d6470 1
a6470 1
	  op_code = * data ++;
d6591 7
a6597 7
     Elf_Internal_Shdr *   section;
     unsigned char *       start;
     FILE *                file ATTRIBUTE_UNUSED;
{
  DWARF2_External_PubNames * external;
  DWARF2_Internal_PubNames   pubnames;
  unsigned char *            end;
d6605 2
a6606 2
      unsigned char * data;
      unsigned long   offset;
d6615 1
a6615 1
      data   = start + sizeof (* external);
d6672 18
a6689 18
    case DW_TAG_padding:                return "DW_TAG_padding";
    case DW_TAG_array_type:             return "DW_TAG_array_type";
    case DW_TAG_class_type:             return "DW_TAG_class_type";
    case DW_TAG_entry_point:            return "DW_TAG_entry_point";
    case DW_TAG_enumeration_type:       return "DW_TAG_enumeration_type";
    case DW_TAG_formal_parameter:       return "DW_TAG_formal_parameter";
    case DW_TAG_imported_declaration:   return "DW_TAG_imported_declaration";
    case DW_TAG_label:                  return "DW_TAG_label";
    case DW_TAG_lexical_block:          return "DW_TAG_lexical_block";
    case DW_TAG_member:                 return "DW_TAG_member";
    case DW_TAG_pointer_type:           return "DW_TAG_pointer_type";
    case DW_TAG_reference_type:         return "DW_TAG_reference_type";
    case DW_TAG_compile_unit:           return "DW_TAG_compile_unit";
    case DW_TAG_string_type:            return "DW_TAG_string_type";
    case DW_TAG_structure_type:         return "DW_TAG_structure_type";
    case DW_TAG_subroutine_type:        return "DW_TAG_subroutine_type";
    case DW_TAG_typedef:                return "DW_TAG_typedef";
    case DW_TAG_union_type:             return "DW_TAG_union_type";
d6691 33
a6723 33
    case DW_TAG_variant:                return "DW_TAG_variant";
    case DW_TAG_common_block:           return "DW_TAG_common_block";
    case DW_TAG_common_inclusion:       return "DW_TAG_common_inclusion";
    case DW_TAG_inheritance:            return "DW_TAG_inheritance";
    case DW_TAG_inlined_subroutine:     return "DW_TAG_inlined_subroutine";
    case DW_TAG_module:                 return "DW_TAG_module";
    case DW_TAG_ptr_to_member_type:     return "DW_TAG_ptr_to_member_type";
    case DW_TAG_set_type:               return "DW_TAG_set_type";
    case DW_TAG_subrange_type:          return "DW_TAG_subrange_type";
    case DW_TAG_with_stmt:              return "DW_TAG_with_stmt";
    case DW_TAG_access_declaration:     return "DW_TAG_access_declaration";
    case DW_TAG_base_type:              return "DW_TAG_base_type";
    case DW_TAG_catch_block:            return "DW_TAG_catch_block";
    case DW_TAG_const_type:             return "DW_TAG_const_type";
    case DW_TAG_constant:               return "DW_TAG_constant";
    case DW_TAG_enumerator:             return "DW_TAG_enumerator";
    case DW_TAG_file_type:              return "DW_TAG_file_type";
    case DW_TAG_friend:                 return "DW_TAG_friend";
    case DW_TAG_namelist:               return "DW_TAG_namelist";
    case DW_TAG_namelist_item:          return "DW_TAG_namelist_item";
    case DW_TAG_packed_type:            return "DW_TAG_packed_type";
    case DW_TAG_subprogram:             return "DW_TAG_subprogram";
    case DW_TAG_template_type_param:    return "DW_TAG_template_type_param";
    case DW_TAG_template_value_param:   return "DW_TAG_template_value_param";
    case DW_TAG_thrown_type:            return "DW_TAG_thrown_type";
    case DW_TAG_try_block:              return "DW_TAG_try_block";
    case DW_TAG_variant_part:           return "DW_TAG_variant_part";
    case DW_TAG_variable:               return "DW_TAG_variable";
    case DW_TAG_volatile_type:          return "DW_TAG_volatile_type";
    case DW_TAG_MIPS_loop:              return "DW_TAG_MIPS_loop";
    case DW_TAG_format_label:           return "DW_TAG_format_label";
    case DW_TAG_function_template:      return "DW_TAG_function_template";
    case DW_TAG_class_template:         return "DW_TAG_class_template";
d6725 8
a6732 8
    case DW_TAG_dwarf_procedure:        return "DW_TAG_dwarf_procedure";
    case DW_TAG_restrict_type:          return "DW_TAG_restrict_type";
    case DW_TAG_interface_type:         return "DW_TAG_interface_type";
    case DW_TAG_namespace:              return "DW_TAG_namespace";
    case DW_TAG_imported_module:        return "DW_TAG_imported_module";
    case DW_TAG_unspecified_type:       return "DW_TAG_unspecified_type";
    case DW_TAG_partial_unit:           return "DW_TAG_partial_unit";
    case DW_TAG_imported_unit:          return "DW_TAG_imported_unit";
d6735 1
a6735 1
	static char buffer [100];
d6749 62
a6810 62
    case DW_AT_sibling:              return "DW_AT_sibling";
    case DW_AT_location:             return "DW_AT_location";
    case DW_AT_name:                 return "DW_AT_name";
    case DW_AT_ordering:             return "DW_AT_ordering";
    case DW_AT_subscr_data:          return "DW_AT_subscr_data";
    case DW_AT_byte_size:            return "DW_AT_byte_size";
    case DW_AT_bit_offset:           return "DW_AT_bit_offset";
    case DW_AT_bit_size:             return "DW_AT_bit_size";
    case DW_AT_element_list:         return "DW_AT_element_list";
    case DW_AT_stmt_list:            return "DW_AT_stmt_list";
    case DW_AT_low_pc:               return "DW_AT_low_pc";
    case DW_AT_high_pc:              return "DW_AT_high_pc";
    case DW_AT_language:             return "DW_AT_language";
    case DW_AT_member:               return "DW_AT_member";
    case DW_AT_discr:                return "DW_AT_discr";
    case DW_AT_discr_value:          return "DW_AT_discr_value";
    case DW_AT_visibility:           return "DW_AT_visibility";
    case DW_AT_import:               return "DW_AT_import";
    case DW_AT_string_length:        return "DW_AT_string_length";
    case DW_AT_common_reference:     return "DW_AT_common_reference";
    case DW_AT_comp_dir:             return "DW_AT_comp_dir";
    case DW_AT_const_value:          return "DW_AT_const_value";
    case DW_AT_containing_type:      return "DW_AT_containing_type";
    case DW_AT_default_value:        return "DW_AT_default_value";
    case DW_AT_inline:               return "DW_AT_inline";
    case DW_AT_is_optional:          return "DW_AT_is_optional";
    case DW_AT_lower_bound:          return "DW_AT_lower_bound";
    case DW_AT_producer:             return "DW_AT_producer";
    case DW_AT_prototyped:           return "DW_AT_prototyped";
    case DW_AT_return_addr:          return "DW_AT_return_addr";
    case DW_AT_start_scope:          return "DW_AT_start_scope";
    case DW_AT_stride_size:          return "DW_AT_stride_size";
    case DW_AT_upper_bound:          return "DW_AT_upper_bound";
    case DW_AT_abstract_origin:      return "DW_AT_abstract_origin";
    case DW_AT_accessibility:        return "DW_AT_accessibility";
    case DW_AT_address_class:        return "DW_AT_address_class";
    case DW_AT_artificial:           return "DW_AT_artificial";
    case DW_AT_base_types:           return "DW_AT_base_types";
    case DW_AT_calling_convention:   return "DW_AT_calling_convention";
    case DW_AT_count:                return "DW_AT_count";
    case DW_AT_data_member_location: return "DW_AT_data_member_location";
    case DW_AT_decl_column:          return "DW_AT_decl_column";
    case DW_AT_decl_file:            return "DW_AT_decl_file";
    case DW_AT_decl_line:            return "DW_AT_decl_line";
    case DW_AT_declaration:          return "DW_AT_declaration";
    case DW_AT_discr_list:           return "DW_AT_discr_list";
    case DW_AT_encoding:             return "DW_AT_encoding";
    case DW_AT_external:             return "DW_AT_external";
    case DW_AT_frame_base:           return "DW_AT_frame_base";
    case DW_AT_friend:               return "DW_AT_friend";
    case DW_AT_identifier_case:      return "DW_AT_identifier_case";
    case DW_AT_macro_info:           return "DW_AT_macro_info";
    case DW_AT_namelist_items:       return "DW_AT_namelist_items";
    case DW_AT_priority:             return "DW_AT_priority";
    case DW_AT_segment:              return "DW_AT_segment";
    case DW_AT_specification:        return "DW_AT_specification";
    case DW_AT_static_link:          return "DW_AT_static_link";
    case DW_AT_type:                 return "DW_AT_type";
    case DW_AT_use_location:         return "DW_AT_use_location";
    case DW_AT_variable_parameter:   return "DW_AT_variable_parameter";
    case DW_AT_virtuality:           return "DW_AT_virtuality";
    case DW_AT_vtable_elem_location: return "DW_AT_vtable_elem_location";
d6812 12
a6823 12
    case DW_AT_allocated:            return "DW_AT_allocated";
    case DW_AT_associated:           return "DW_AT_associated";
    case DW_AT_data_location:        return "DW_AT_data_location";
    case DW_AT_stride:               return "DW_AT_stride";
    case DW_AT_entry_pc:             return "DW_AT_entry_pc";
    case DW_AT_use_UTF8:             return "DW_AT_use_UTF8";
    case DW_AT_extension:            return "DW_AT_extension";
    case DW_AT_ranges:               return "DW_AT_ranges";
    case DW_AT_trampoline:           return "DW_AT_trampoline";
    case DW_AT_call_column:          return "DW_AT_call_column";
    case DW_AT_call_file:            return "DW_AT_call_file";
    case DW_AT_call_line:            return "DW_AT_call_line";
d6825 4
a6828 4
    case DW_AT_MIPS_fde:             return "DW_AT_MIPS_fde";
    case DW_AT_MIPS_loop_begin:      return "DW_AT_MIPS_loop_begin";
    case DW_AT_MIPS_tail_loop_begin: return "DW_AT_MIPS_tail_loop_begin";
    case DW_AT_MIPS_epilog_begin:    return "DW_AT_MIPS_epilog_begin";
d6830 7
a6836 6
    case DW_AT_MIPS_software_pipeline_depth: return "DW_AT_MIPS_software_pipeline_depth";
    case DW_AT_MIPS_linkage_name:    return "DW_AT_MIPS_linkage_name";
    case DW_AT_MIPS_stride:          return "DW_AT_MIPS_stride";
    case DW_AT_MIPS_abstract_name:   return "DW_AT_MIPS_abstract_name";
    case DW_AT_MIPS_clone_origin:    return "DW_AT_MIPS_clone_origin";
    case DW_AT_MIPS_has_inlines:     return "DW_AT_MIPS_has_inlines";
d6838 7
a6844 7
    case DW_AT_sf_names:             return "DW_AT_sf_names";
    case DW_AT_src_info:             return "DW_AT_src_info";
    case DW_AT_mac_info:             return "DW_AT_mac_info";
    case DW_AT_src_coords:           return "DW_AT_src_coords";
    case DW_AT_body_begin:           return "DW_AT_body_begin";
    case DW_AT_body_end:             return "DW_AT_body_end";
    case DW_AT_GNU_vector:           return "DW_AT_GNU_vector";
d6847 1
a6847 1
	static char buffer [100];
d6861 21
a6881 21
    case DW_FORM_addr:      return "DW_FORM_addr";
    case DW_FORM_block2:    return "DW_FORM_block2";
    case DW_FORM_block4:    return "DW_FORM_block4";
    case DW_FORM_data2:     return "DW_FORM_data2";
    case DW_FORM_data4:     return "DW_FORM_data4";
    case DW_FORM_data8:     return "DW_FORM_data8";
    case DW_FORM_string:    return "DW_FORM_string";
    case DW_FORM_block:     return "DW_FORM_block";
    case DW_FORM_block1:    return "DW_FORM_block1";
    case DW_FORM_data1:     return "DW_FORM_data1";
    case DW_FORM_flag:      return "DW_FORM_flag";
    case DW_FORM_sdata:     return "DW_FORM_sdata";
    case DW_FORM_strp:      return "DW_FORM_strp";
    case DW_FORM_udata:     return "DW_FORM_udata";
    case DW_FORM_ref_addr:  return "DW_FORM_ref_addr";
    case DW_FORM_ref1:      return "DW_FORM_ref1";
    case DW_FORM_ref2:      return "DW_FORM_ref2";
    case DW_FORM_ref4:      return "DW_FORM_ref4";
    case DW_FORM_ref8:      return "DW_FORM_ref8";
    case DW_FORM_ref_udata: return "DW_FORM_ref_udata";
    case DW_FORM_indirect:  return "DW_FORM_indirect";
d6884 1
a6884 1
	static char buffer [100];
d6897 3
a6899 3
  unsigned long        attribute;
  unsigned long        form;
  struct abbrev_attr * next;
d6905 6
a6910 6
  unsigned long          entry;
  unsigned long          tag;
  int                    children;
  struct abbrev_attr *   first_attr;
  struct abbrev_attr *   last_attr;
  struct abbrev_entry *  next;
d6914 2
a6915 2
static abbrev_entry * first_abbrev = NULL;
static abbrev_entry * last_abbrev = NULL;
d6918 1
a6918 1
free_abbrevs PARAMS ((void))
d6920 1
a6920 1
  abbrev_entry * abbrev;
d6924 2
a6925 2
      abbrev_entry * next = abbrev->next;
      abbrev_attr  * attr;
d6929 1
a6929 1
	  abbrev_attr * next = attr->next;
d6946 1
a6946 1
     int           children;
d6948 1
a6948 1
  abbrev_entry * entry;
d6950 1
a6950 1
  entry = (abbrev_entry *) malloc (sizeof (* entry));
d6976 1
a6976 1
  abbrev_attr * attr;
d6978 1
a6978 1
  attr = (abbrev_attr *) malloc (sizeof (* attr));
d7003 2
a7004 2
     unsigned char * start;
     unsigned char * end;
d7011 1
a7011 1
      int           bytes_read;
d7015 1
a7015 1
      int           children;
d7029 1
a7029 1
      children = * start ++;
d7055 3
a7057 3
     Elf_Internal_Shdr *   section;
     unsigned char *       start;
     FILE *                file ATTRIBUTE_UNUSED;
d7059 2
a7060 2
  unsigned char * end = start + section->sh_size;
  unsigned char * curr = start;
d7069 1
a7069 1
      const char * string;
d7071 2
a7072 2
      op = * curr;
      curr ++;
d7129 3
a7131 3
     Elf_Internal_Shdr *   section;
     unsigned char *       start;
     FILE *                file ATTRIBUTE_UNUSED;
d7133 2
a7134 2
  abbrev_entry *  entry;
  unsigned char * end = start + section->sh_size;
d7149 1
a7149 1
	  abbrev_attr * attr;
d7176 2
a7177 2
     unsigned char * data;
     unsigned long   length;
d7182 1
a7182 1
    printf ("%lx ", (unsigned long) byte_get (data ++, 1));
d7190 2
a7191 2
     unsigned int    pointer_size;
     unsigned long   length;
d7193 4
a7196 4
  unsigned        op;
  int             bytes_read;
  unsigned long   uvalue;
  unsigned char * end = data + length;
d7200 1
a7200 1
      op = * data ++;
d7519 2
a7520 2
static const char * debug_loc_contents;
static bfd_vma      debug_loc_size;
d7524 1
a7524 1
     FILE * file;
d7526 2
a7527 2
  Elf_Internal_Shdr * sec;
  unsigned int        i;
d7536 1
a7536 1
       i ++, sec ++)
d7564 3
a7566 3
     Elf_Internal_Shdr * section;
     unsigned char * start;
     FILE * file ATTRIBUTE_UNUSED;
d7629 2
a7630 2
static const char * debug_str_contents;
static bfd_vma      debug_str_size;
d7634 1
a7634 1
     FILE * file;
d7636 2
a7637 2
  Elf_Internal_Shdr * sec;
  unsigned int        i;
d7646 1
a7646 1
       i ++, sec ++)
d7686 3
a7688 3
     Elf_Internal_Shdr * section;
     unsigned char *       start;
     FILE *                file ATTRIBUTE_UNUSED;
d7690 2
a7691 2
  unsigned long   bytes;
  bfd_vma         addr;
d7717 1
a7717 1
	    printf ("%2.2x", start [j]);
d7727 1
a7727 1
	  k = start [j];
d7746 9
a7754 9
     unsigned long   attribute;
     unsigned long   form;
     unsigned char * data;
     unsigned long   cu_offset;
     unsigned long   pointer_size;
{
  unsigned long   uvalue = 0;
  unsigned char * block_start = NULL;
  int             bytes_read;
d7775 1
a7775 1
      uvalue = byte_get (data ++, 1);
d7894 15
a7908 5
	case DW_INL_not_inlined:          printf (_("(not inlined)")); break;
	case DW_INL_inlined:              printf (_("(inlined)")); break;
	case DW_INL_declared_not_inlined: printf (_("(declared as inline but ignored)")); break;
	case DW_INL_declared_inlined:     printf (_("(declared as inline and inlined)")); break;
	default: printf (_("  (Unknown inline attribute value: %lx)"), uvalue); break;
d7915 14
a7928 14
	case DW_LANG_C:              printf ("(non-ANSI C)"); break;
	case DW_LANG_C89:            printf ("(ANSI C)"); break;
	case DW_LANG_C_plus_plus:    printf ("(C++)"); break;
	case DW_LANG_Fortran77:      printf ("(FORTRAN 77)"); break;
	case DW_LANG_Fortran90:      printf ("(Fortran 90)"); break;
	case DW_LANG_Modula2:        printf ("(Modula 2)"); break;
	case DW_LANG_Pascal83:       printf ("(ANSI Pascal)"); break;
	case DW_LANG_Ada83:          printf ("(Ada)"); break;
	case DW_LANG_Cobol74:        printf ("(Cobol 74)"); break;
	case DW_LANG_Cobol85:        printf ("(Cobol 85)"); break;
	  /* DWARF 2.1 values.  */
	case DW_LANG_C99:            printf ("(ANSI C99)"); break;
	case DW_LANG_Ada95:          printf ("(ADA 95)"); break;
	case DW_LANG_Fortran95:      printf ("(Fortran 95)"); break;
d7930 4
a7933 2
	case DW_LANG_Mips_Assembler: printf ("(MIPS assembler)"); break;
	default:                     printf ("(Unknown: %lx)", uvalue); break;
d7940 9
a7948 9
	case DW_ATE_void:            printf ("(void)"); break;
	case DW_ATE_address:         printf ("(machine address)"); break;
	case DW_ATE_boolean:         printf ("(boolean)"); break;
	case DW_ATE_complex_float:   printf ("(complex float)"); break;
	case DW_ATE_float:           printf ("(float)"); break;
	case DW_ATE_signed:          printf ("(signed)"); break;
	case DW_ATE_signed_char:     printf ("(signed char)"); break;
	case DW_ATE_unsigned:        printf ("(unsigned)"); break;
	case DW_ATE_unsigned_char:   printf ("(unsigned char)"); break;
d7950 1
a7950 1
 	case DW_ATE_imaginary_float: printf ("(imaginary float)"); break;
d7967 3
a7969 1
	default:		        printf ("(unknown accessibility)"); break;
d7976 4
a7979 4
	case DW_VIS_local:	printf ("(local)"); break;
	case DW_VIS_exported:	printf ("(exported)"); break;
	case DW_VIS_qualified:	printf ("(qualified)"); break;
	default:		printf ("(unknown visibility)"); break;
d7989 1
a7989 1
	default:		        printf ("(unknown virtuality)"); break;
d8000 1
a8000 1
	default:		        printf ("(unknown case)"); break;
d8061 5
a8065 5
     unsigned long   attribute;
     unsigned long   form;
     unsigned char * data;
     unsigned long   cu_offset;
     unsigned long   pointer_size;
d8076 3
a8078 3
     Elf_Internal_Shdr *   section;
     unsigned char *       start;
     FILE *                file;
d8080 2
a8081 2
  unsigned char * end = start + section->sh_size;
  unsigned char * section_begin = start;
d8090 7
a8096 7
      DWARF2_External_CompUnit * external;
      DWARF2_Internal_CompUnit   compunit;
      Elf_Internal_Shdr *        relsec;
      unsigned char *            tags;
      unsigned int               i;
      int			 level;
      unsigned long		 cu_offset;
d8175 1
a8175 1
      tags = start + sizeof (* external);
d8195 2
a8196 2
	Elf_Internal_Shdr * sec;
	unsigned char *     begin;
d8201 1
a8201 1
	     i ++, sec ++)
d8226 4
a8229 4
	  int            bytes_read;
	  unsigned long  abbrev_number;
	  abbrev_entry * entry;
	  abbrev_attr  * attr;
d8282 3
a8284 3
     Elf_Internal_Shdr *   section;
     unsigned char *       start;
     FILE *                file ATTRIBUTE_UNUSED;
d8286 1
a8286 1
  unsigned char * end = start + section->sh_size;
d8292 6
a8297 6
      DWARF2_External_ARange * external;
      DWARF2_Internal_ARange   arange;
      unsigned char *          ranges;
      unsigned long            length;
      unsigned long            address;
      int		       excess;
d8327 1
a8327 1
      ranges = start + sizeof (* external);
d8330 1
a8330 1
      excess = sizeof (* external) % (2 * arange.ar_pointer_size);
d8361 3
a8363 3
  struct Frame_Chunk * next;
  unsigned char *      chunk_start;
  int                  ncols;
d8365 11
a8375 11
  short int *          col_type;
  int *                col_offset;
  char *               augmentation;
  unsigned int         code_factor;
  int                  data_factor;
  unsigned long        pc_begin;
  unsigned long        pc_range;
  int                  cfa_reg;
  int                  cfa_offset;
  int                  ra;
  unsigned char        fde_encoding;
d8389 1
a8389 1
     Frame_Chunk * fc;
d8413 3
a8415 3
     Frame_Chunk * fc;
     int *         need_col_headers;
     int *         max_regs;
d8420 2
a8421 2
  if (* max_regs < fc->ncols)
    * max_regs = fc->ncols;
d8423 1
a8423 1
  if (* need_col_headers)
d8425 1
a8425 1
      * need_col_headers = 0;
d8429 1
a8429 1
      for (r = 0; r < * max_regs; r++)
d8493 13
a8505 13
     Elf_Internal_Shdr * section;
     unsigned char *       start;
     FILE *                file ATTRIBUTE_UNUSED;
{
  unsigned char * end = start + section->sh_size;
  unsigned char * section_start = start;
  Frame_Chunk *   chunks = 0;
  Frame_Chunk *   remembered_state = 0;
  Frame_Chunk *   rs;
  int             is_eh = (strcmp (SECTION_NAME (section), ".eh_frame") == 0);
  int             length_return;
  int             max_regs = 0;
  int             addr_size = is_32bit_elf ? 4 : 8;
d8511 10
a8520 10
      unsigned char * saved_start;
      unsigned char * block_end;
      unsigned long   length;
      unsigned long   cie_id;
      Frame_Chunk *   fc;
      Frame_Chunk *   cie;
      int             need_col_headers = 1;
      unsigned char * augmentation_data = NULL;
      unsigned long   augmentation_data_len = 0;
      int	      encoded_ptr_size = addr_size;
d8638 1
a8638 1
	  unsigned char *    look_for;
d8719 1
a8719 1
	  unsigned char * tmp = start;
d8726 1
a8726 1
	      op = * start ++;
d8828 1
a8828 1
	  op = * start ++;
d9083 3
a9085 3
     Elf_Internal_Shdr * section;
     unsigned char *     start ATTRIBUTE_UNUSED;
     FILE *              file ATTRIBUTE_UNUSED;
d9098 3
a9100 3
     Elf_Internal_Shdr * section ATTRIBUTE_UNUSED;
     unsigned char *     start;
     FILE *              file ATTRIBUTE_UNUSED;
d9102 1
a9102 1
  DWARF2_External_CompUnit * external;
d9116 3
a9118 3
  const char * const name;
  int (* display) PARAMS ((Elf_Internal_Shdr *, unsigned char *, FILE *));
  int (* prescan) PARAMS ((Elf_Internal_Shdr *, unsigned char *, FILE *));
d9122 16
a9137 16
  { ".debug_abbrev",      display_debug_abbrev, NULL },
  { ".debug_aranges",     display_debug_aranges, NULL },
  { ".debug_frame",       display_debug_frames, NULL },
  { ".debug_info",        display_debug_info, prescan_debug_info },
  { ".debug_line",        display_debug_lines, NULL },
  { ".debug_pubnames",    display_debug_pubnames, NULL },
  { ".eh_frame",          display_debug_frames, NULL },
  { ".debug_macinfo",     display_debug_macinfo, NULL },
  { ".debug_str",         display_debug_str, NULL },
  { ".debug_loc",         display_debug_loc, NULL },
  { ".debug_pubtypes",    display_debug_not_supported, NULL },
  { ".debug_ranges",      display_debug_not_supported, NULL },
  { ".debug_static_func", display_debug_not_supported, NULL },
  { ".debug_static_vars", display_debug_not_supported, NULL },
  { ".debug_types",       display_debug_not_supported, NULL },
  { ".debug_weaknames",   display_debug_not_supported, NULL }
d9142 2
a9143 2
     Elf_Internal_Shdr * section;
     FILE * file;
d9145 4
a9148 4
  char *          name = SECTION_NAME (section);
  bfd_size_type   length;
  unsigned char * start;
  int             i;
d9187 1
a9187 1
     FILE * file;
d9189 2
a9190 2
  Elf_Internal_Shdr * section;
  unsigned int	i;
d9200 1
a9200 1
       i ++, section ++)
d9202 2
a9203 2
      char *	name = SECTION_NAME (section);
      int       j;
d9214 2
a9215 2
		bfd_size_type   length;
		unsigned char * start;
d9234 1
a9234 1
       i ++, section ++)
d9277 1
a9277 1
     FILE * file;
d9279 1
a9279 1
  Elf_Internal_Dyn * entry;
d9315 1
a9315 1
      Elf32_External_Lib * elib;
d9334 1
a9334 1
	      struct tm * tmp;
d9358 1
a9358 1
		    const char * name;
d9394 4
a9397 4
      Elf_External_Options * eopt;
      Elf_Internal_Shdr *    sect = section_headers;
      Elf_Internal_Options * iopt;
      Elf_Internal_Options * option;
d9403 1
a9403 1
	++ sect;
d9410 1
a9410 1
		  malloc ((sect->sh_size / sizeof (eopt)) * sizeof (* iopt)));
d9422 1
a9422 1
	      Elf_External_Options * eoption;
d9457 2
a9458 2
		      Elf32_External_RegInfo * ereg;
		      Elf32_RegInfo            reginfo;
d9478 1
a9478 1
		      Elf64_External_RegInfo * ereg;
d9575 1
a9575 1
	      len = sizeof (* eopt);
d9593 1
a9593 1
      Elf32_Conflict * iconf;
d9602 1
a9602 1
      iconf = (Elf32_Conflict *) malloc (conflictsno * sizeof (* iconf));
d9611 1
a9611 1
	  Elf32_External_Conflict * econf32;
d9615 1
a9615 1
			       conflictsno * sizeof (* econf32),
d9627 1
a9627 1
	  Elf64_External_Conflict * econf64;
d9631 1
a9631 1
			       conflictsno * sizeof (* econf64),
d9648 1
a9648 1
	  Elf_Internal_Sym * psym = & dynamic_symbols [iconf [cnt]];
d9650 1
a9650 1
	  printf ("%5lu: %8lu  ", (unsigned long) cnt, iconf [cnt]);
d9665 1
a9665 1
     FILE * file;
d9667 3
a9669 3
  Elf_Internal_Shdr * section, * string_sec;
  Elf32_External_Lib * elib;
  char * strtab;
d9678 1
a9678 1
       i++, section ++)
d9714 1
a9714 1
	      struct tm * tmp;
d9753 3
a9755 3
    case NT_PRPSINFO:   return _("NT_PRPSINFO (prpsinfo structure)");
    case NT_TASKSTRUCT: return _("NT_TASKSTRUCT (task structure)");
    case NT_PRXFPREG:   return _("NT_PRXFPREG (user_xfpregs structure)");
d9837 1
a9837 1
     Elf_Internal_Note * pnote;
d9868 1
a9868 1
     FILE * file;
d9872 3
a9874 3
  Elf_External_Note *  pnotes;
  Elf_External_Note *  external;
  int                  res = 1;
d9892 3
a9894 3
      Elf_External_Note * next;
      Elf_Internal_Note   inote;
      char * temp = NULL;
d9954 1
a9954 1
     FILE * file;
d9956 4
a9959 4
  Elf_Internal_Phdr * program_headers;
  Elf_Internal_Phdr * segment;
  unsigned int	      i;
  int                 res = 1;
d9983 1
a9983 1
       i ++, segment ++)
d9998 1
a9998 1
     FILE * file;
d10020 1
a10020 1
     FILE * file;
d10039 1
a10039 1
     FILE * file;
d10046 1
a10046 1
  switch (elf_header.e_ident [EI_DATA])
d10055 1
a10055 1
  is_32bit_elf = (elf_header.e_ident [EI_CLASS] != ELFCLASS64);
d10127 1
a10127 1
     char * file_name;
d10129 2
a10130 2
  FILE *       file;
  struct stat  statbuf;
d10244 1
a10244 1
print_address (unsigned int addr, FILE * outfile)
d10261 2
a10262 2
     int     argc;
     char ** argv;
d10282 1
a10282 1
    err |= process_file (argv [optind ++]);
@


1.181
log
@Handle binaries with corrupt section or segment headers
@
text
@d174 1
a174 1
static int		  slurp_rel_relocs	      PARAMS ((FILE *, unsigned long, unsigned long, Elf_Internal_Rel **, unsigned long *));
d223 1
a223 1
static int	          disassemble_section         PARAMS ((Elf32_Internal_Shdr *, FILE *));
d225 13
a237 13
static int	          dump_section                PARAMS ((Elf32_Internal_Shdr *, FILE *));
static int	          display_debug_section       PARAMS ((Elf32_Internal_Shdr *, FILE *));
static int                display_debug_info          PARAMS ((Elf32_Internal_Shdr *, unsigned char *, FILE *));
static int                display_debug_not_supported PARAMS ((Elf32_Internal_Shdr *, unsigned char *, FILE *));
static int                prescan_debug_info          PARAMS ((Elf32_Internal_Shdr *, unsigned char *, FILE *));
static int                display_debug_lines         PARAMS ((Elf32_Internal_Shdr *, unsigned char *, FILE *));
static int                display_debug_pubnames      PARAMS ((Elf32_Internal_Shdr *, unsigned char *, FILE *));
static int                display_debug_abbrev        PARAMS ((Elf32_Internal_Shdr *, unsigned char *, FILE *));
static int                display_debug_aranges       PARAMS ((Elf32_Internal_Shdr *, unsigned char *, FILE *));
static int                display_debug_frames        PARAMS ((Elf32_Internal_Shdr *, unsigned char *, FILE *));
static int                display_debug_macinfo       PARAMS ((Elf32_Internal_Shdr *, unsigned char *, FILE *));
static int                display_debug_str           PARAMS ((Elf32_Internal_Shdr *, unsigned char *, FILE *));
static int                display_debug_loc           PARAMS ((Elf32_Internal_Shdr *, unsigned char *, FILE *));
d264 1
a264 1
static int		  process_note		         PARAMS ((Elf32_Internal_Note *));
d764 1
a764 1
     Elf_Internal_Rel **relsp;
d767 1
a767 1
  Elf_Internal_Rel *rels;
d782 1
a782 1
      rels = (Elf_Internal_Rel *) malloc (nrels * sizeof (Elf_Internal_Rel));
d794 1
d810 1
a810 1
      rels = (Elf_Internal_Rel *) malloc (nrels * sizeof (Elf_Internal_Rel));
d822 1
d844 1
a844 2
  Elf_Internal_Rel *  rels;
  Elf_Internal_Rela * relas;
d852 1
a852 1
      if (!slurp_rela_relocs (file, rel_offset, rel_size, &relas, &rel_size))
d908 2
a909 10
      if (is_rela)
	{
	  offset = relas [i].r_offset;
	  info   = relas [i].r_info;
	}
      else
	{
	  offset = rels [i].r_offset;
	  info   = rels [i].r_info;
	}
d1197 1
a1197 1
		printf (" + %lx", (unsigned long) relas [i].r_addend);
d1203 1
a1203 1
	  print_vma (relas[i].r_addend, LONG_HEX);
d1240 1
a1240 4
  if (is_rela)
    free (relas);
  else
    free (rels);
d2814 1
a2814 1
  Elf32_Internal_Phdr * internal;
d2850 1
a2850 1
  Elf64_Internal_Phdr * internal;
d3124 1
a3124 1
  Elf32_Internal_Shdr * internal;
d3170 1
a3170 1
  Elf64_Internal_Shdr * internal;
d3691 1
a3691 1
      Elf32_Internal_Shdr *     section;
d3708 5
a3712 5
	      Elf32_Internal_Shdr * strsec;
	      Elf_Internal_Sym *    symtab;
	      char *                strtab;
	      int                   is_rela;
	      unsigned long         nsyms;
d3729 1
a3729 1
		  Elf32_Internal_Shdr * symsec;
d3802 1
a3802 1
					    Elf32_Internal_Shdr *));
d3903 1
a3903 1
     Elf32_Internal_Shdr *sec;
d3908 1
a3908 1
  Elf32_Internal_Shdr *relsec;
d4062 1
a4062 1
  Elf32_Internal_Shdr *sec, *unwsec = NULL, *strsec;
d4476 1
a4476 1
	  Elf32_Internal_Shdr section;
d5020 1
a5020 1
  Elf32_Internal_Shdr * section;
d5213 1
a5213 1
	    Elf32_Internal_Shdr *       link_section;
d5220 1
a5220 1
	    Elf32_Internal_Shdr *       string_sec;
d5575 1
a5575 1
  Elf32_Internal_Shdr *   section;
d5688 1
a5688 1
	      Elf32_Internal_Shdr * string_sec;
d5990 1
a5990 1
     Elf32_Internal_Shdr * section;
d6004 1
a6004 1
     Elf32_Internal_Shdr * section;
d6227 1
a6227 1
     Elf32_Internal_Shdr * section;
d6484 1
a6484 1
     Elf32_Internal_Shdr * section;
d6947 1
a6947 1
     Elf32_Internal_Shdr * section;
d7021 1
a7021 1
     Elf32_Internal_Shdr * section;
d7418 2
a7419 2
  Elf32_Internal_Shdr * sec;
  unsigned int          i;
d7456 1
a7456 1
     Elf32_Internal_Shdr * section;
d7528 2
a7529 2
  Elf32_Internal_Shdr * sec;
  unsigned int          i;
d7578 1
a7578 1
     Elf32_Internal_Shdr * section;
d7954 1
a7954 1
     Elf32_Internal_Shdr * section;
d7970 1
a7970 1
      Elf32_Internal_Shdr *      relsec;
d7997 1
a7997 1
	  Elf32_Internal_Shdr *symsec;
d8073 2
a8074 2
	Elf32_Internal_Shdr * sec;
	unsigned char *       begin;
d8160 1
a8160 1
     Elf32_Internal_Shdr * section;
d8371 1
a8371 1
     Elf32_Internal_Shdr * section;
d8961 3
a8963 3
     Elf32_Internal_Shdr * section;
     unsigned char *       start ATTRIBUTE_UNUSED;
     FILE *                file ATTRIBUTE_UNUSED;
d8976 3
a8978 3
     Elf32_Internal_Shdr * section ATTRIBUTE_UNUSED;
     unsigned char *       start;
     FILE *                file ATTRIBUTE_UNUSED;
d8995 2
a8996 2
  int (* display) PARAMS ((Elf32_Internal_Shdr *, unsigned char *, FILE *));
  int (* prescan) PARAMS ((Elf32_Internal_Shdr *, unsigned char *, FILE *));
d9020 1
a9020 1
     Elf32_Internal_Shdr * section;
d9067 1
a9067 1
  Elf32_Internal_Shdr * section;
d9715 1
a9715 1
     Elf32_Internal_Note * pnote;
d9771 1
a9771 1
      Elf32_Internal_Note inote;
@


1.180
log
@Revert part of previous patch: Display unknown symbol types in decimal, not hex.
@
text
@d2889 2
d2903 1
a2903 1
      return 1;
d10058 5
a10062 1
  process_section_headers (file);
d10064 3
a10066 1
  process_program_headers (file);
d10068 2
a10069 1
  process_dynamic_segment (file);
@


1.179
log
@oops - omitted fix to display unknown symbol type in hex.
@
text
@d5532 1
a5532 1
	sprintf (buff, "0x%04x", type);
@


1.178
log
@Add hex number to PROCESSOR-specific, OS-specific, and reserved symbol types.
@
text
@d5532 1
a5532 1
	sprintf (buff, "%3d", type);
@


1.177
log
@	* readelf.c (byte_get_little_endian): Comment typo fix.
	(print_symbol): Constify "symbol" arg.  Don't pass "symbol" to printf
	as the format string.
	(dump_relocations): Correct section sym names.
	(process_section_headers): Clear symtab_shndx_hdr.
	(read_and_display_attr_value): Don't pass indirect string to printf
	as the format string.
	(display_debug_frames): Indicate when zero terminator found.  Decode
	DW_EH_PE_pcrel addresses.
@
text
@d5517 2
d5526 1
a5526 1
	return "PRC";
d5528 1
a5528 1
	return "OS ";
d5530 1
a5530 1
	return "RSV";
d5532 3
a5534 2
	{
	  static char buff [32];
d5536 1
a5536 4
	  sprintf (buff, "%3d", type);
	  return buff;
	}
    }
@


1.176
log
@        * readelf.c (display_debug_info): Ignore empty .rela.debug_info
        sections.  Allow relocations against the absolute symbol.  Don't
        use the value in compunit.cu_abbrev_offset if we found a RELA
        relocation.
@
text
@d164 1
a164 1
static void		  print_symbol		      PARAMS ((int, char *));
d409 1
a409 1
	 endian source we can juts use the 4 byte extraction code.  */
d538 1
a538 1
     char * symbol;
d541 1
a541 1
    printf (symbol);
d1169 29
a1197 1
		print_symbol (22, SECTION_NAME (section_headers + psym->st_shndx));
d3445 1
d7772 2
a7773 2
      printf (_(" (indirect string, offset: 0x%lx): "), uvalue);
      printf (fetch_indirect_string (uvalue));
d8412 5
a8416 1
	return 1;
d8570 2
d8751 2
@


1.175
log
@2002-09-30  H.J. Lu <hjl@@gnu.org>

	* readelf.c (get_machine_flags): Handle E_MIPS_MACH_4120,
	E_MIPS_MACH_5400 and E_MIPS_MACH_5500.
@
text
@d7981 2
a7982 1
	      || SECTION_HEADER (relsec->sh_info) != section)
d8003 2
a8004 1
		  if (ELF32_ST_TYPE (sym->st_info) != STT_SECTION)
d8015 2
a8016 1
		  if (ELF64_ST_TYPE (sym->st_info) != STT_SECTION)
d8024 1
a8024 1
	      compunit.cu_abbrev_offset += rp->r_addend;
@


1.174
log
@Handle DW_OP_GNU_push_tls_address.
Synch up with the gcc's dwarf2.h
@
text
@d1824 2
d1827 2
a1828 1
	    case E_MIPS_MACH_4111: strcat (buf, ", 4111"); break;
@


1.173
log
@Remove redundant reference to E_V850EA_ARCH.
@
text
@d7351 1
a7351 1
	  /* DWARF 2.1 extensions.  */
d7363 7
a7369 2
	case DW_OP_calli:
	  printf ("DW_OP_calli");
d7444 1
d7450 1
d7453 1
a7551 1

a7611 1

d7965 2
a7966 2
      /* Check for RELA relocations in the abbrev_offset address, and
         apply them.  */
a8044 1

@


1.172
log
@	* readelf.c (parse_args): Change debug_dump_opt to static.
@
text
@a1779 3
	    case E_V850EA_ARCH:
	      strcat (buf, ", v850ea");
	      break;
@


1.171
log
@Revert previous delta - it was bogus.
@
text
@d2520 1
a2520 1
	      const char *debug_dump_opt[]
@


1.170
log
@Put a newline after display an unknown dynamic type.
@
text
@a4958 2
	  else
	    putchar ('\n');
@


1.169
log
@	* readelf.c: Include elf/i370.h.
	(dump_relocations): Handle EM_S370.
	(dynamic_segment_parisc_val): Print \n.
	(process_dynamic_segment <DT_BIND_NOW>): Here too.
@
text
@d3853 1
a3853 1
      printf ("), info at +0x%lx\n",
d3859 1
a3859 1
      printf ("  v%u, flags=0x%lx (%s%s ), len=%lu bytes\n",
d4653 1
d4659 1
d4681 1
d4687 1
d4714 1
d4959 2
@


1.168
log
@	* readelf.c (OPTION_DEBUG_DUMP): Define.
	(options): Use it.
	(usage): Update help.
	(parse_args): Handle --debug-dump separately from -w.
	* doc/binutils.texi (readelf): Update documentation.
@
text
@d65 1
d1122 4
d4302 1
d4915 2
@


1.167
log
@Add IP2K support
@
text
@d2254 2
d2275 1
a2275 1
  {"debug-dump",       optional_argument, 0, 'w'},
d2310 2
a2311 1
  -w --debug-dump[=line,=info,=abbrev,=pubnames,=ranges,=macro,=frames,=str,=loc]\n\
d2507 82
@


1.166
log
@	* readelf.c (get_dynamic_type): Handle DT_GNU_PRELINKED,
	DT_GNU_CONFLICT* and DT_GNU_LIBLISZ*.
	(get_section_type_name): Handle SHT_GNU_LIBLIST.
	(process_dynamic_segment): Handle DT_GNU_CONFLICTSZ,
	DT_GNU_LIBLISTSZ and DT_GNU_PRELINKED.
	(process_gnu_liblist): New.
	(process_file): Call it.

	* elf/common.h (SHT_GNU_LIBLIST, DT_GNU_PRELINKED,
	DT_GNU_CONFLICT*, DT_GNU_LIBLIST*): Define.
@
text
@d68 1
d656 2
d1133 5
d1580 2
@


1.166.2.1
log
@        Merge from mainline:
        2002-07-30  Jakub Jelinek  <jakub@@redhat.com>
        * readelf.c (OPTION_DEBUG_DUMP): Define.
        (options): Use it.
        (usage): Update help.
        (parse_args): Handle --debug-dump separately from -w.
        * doc/binutils.texi (readelf): Update documentation.
@
text
@a2243 2
#define OPTION_DEBUG_DUMP	512

d2263 1
a2263 1
  {"debug-dump",       optional_argument, 0, OPTION_DEBUG_DUMP},
d2298 1
a2298 2
  -w[liaprmfFso] or\n\
  --debug-dump[=line,=info,=abbrev,=pubnames,=ranges,=macro,=frames,=str,=loc]\n\
a2493 82
	    }
	  break;
	case OPTION_DEBUG_DUMP:
	  do_dump ++;
	  if (optarg == 0)
	    do_debugging = 1;
	  else
	    {
	      const char *debug_dump_opt[]
		= { "line", "info", "abbrev", "pubnames", "ranges",
		    "macro", "frames", "frames-interp", "str", "loc", NULL };
	      unsigned int index;
	      const char *p;

	      do_debugging = 0;

	      p = optarg;
	      while (*p)
		{
		  for (index = 0; debug_dump_opt[index]; index++)
		    {
		      size_t len = strlen (debug_dump_opt[index]);

		      if (strncmp (p, debug_dump_opt[index], len) == 0
			  && (p[len] == ',' || p[len] == '\0'))
			{
			  switch (p[0])
			    {
			    case 'i':
			      do_debug_info = 1;
			      break;

			    case 'a':
			      do_debug_abbrevs = 1;
			      break;

			    case 'l':
			      if (p[1] == 'i')
				do_debug_lines = 1;
			      else
				do_debug_loc = 1;
			      break;

			    case 'p':
			      do_debug_pubnames = 1;
			      break;

			    case 'r':
			      do_debug_aranges = 1;
			      break;

			    case 'f':
			      if (len > 6)
				do_debug_frames_interp = 1;
			      do_debug_frames = 1;
			      break;

			    case 'm':
			      do_debug_macinfo = 1;
			      break;

			    case 's':
			      do_debug_str = 1;
			      break;
			    }

			  p += len;
			  break;
			}
		    }

		  if (debug_dump_opt[index] == NULL)
		    {
		      warn (_("Unrecognized debug option '%s'\n"), p);
		      p = strchr (p, ',');
		      if (p == NULL)
			break;
		    }

		  if (*p == ',')
		    p++;
		}
@


1.166.2.2
log
@Merge from mainline.
@
text
@d7952 1
a7952 2
	      || SECTION_HEADER (relsec->sh_info) != section
	      || relsec->sh_size == 0)
d7973 1
a7973 2
		  if (ELF32_R_SYM (rp->r_info) != 0
		      && ELF32_ST_TYPE (sym->st_info) != STT_SECTION)
d7984 1
a7984 2
		  if (ELF64_R_SYM (rp->r_info) != 0
		      && ELF64_ST_TYPE (sym->st_info) != STT_SECTION)
d7992 1
a7992 1
	      compunit.cu_abbrev_offset = rp->r_addend;
@


1.165
log
@include/elf:

2002-07-01  Matt Thomas  <matt@@3am-software.com>

* Rename EF_* to EF_VAX_*.

bfd:

2002-07-01  Matt Thomas  <matt@@3am-software.com>

* elf32-vax.c (elf32_vax_print_private_bfd_data): Change EF_*
to EF_VAX_*.

binutils:

2002-07-01  Matt Thomas  <matt@@3am-software.com>

* readelf.c: Include "elf/vax.h".
(guess_is_rela): Move EM_VAX from unknown to RELA case.
(dump_relocations): Handle VAX relocations.
(get_machine_flags): Handle VAX machine flags.
@
text
@d267 1
d529 1
a529 1
   truhncating as necessary.  If WIDTH is negative then
d1392 6
d2204 1
d4766 2
d4816 14
d9396 80
d9922 2
@


1.164
log
@	* readelf.c (dump_relocations): Handle 68HC11/68HC12 relocations.
@
text
@d83 1
d653 1
a672 1
    case EM_VAX:
d1125 4
d1928 9
@


1.163
log
@2002-06-18  Dave Brolley  <brolley@@redhat.com>

	From Catherine Moore:
	* readelf.c (elf/frv.h): #include it.
	(guess_is_rela): Support EM_CYGNUS_FRV.
	(dump_relocations): Ditto.
	(get_machine_name): Ditto.
	* Makefile.am (readelf.o): add dependency on $(INCDIR)/elf/frv.h.
@
text
@d70 1
d978 5
@


1.162
log
@binutils/
	* readelf.c (get_file_header): Only read the first section header if
	e_shoff is non-zero.

bfd/
	* elfcode.h (elf_object_p): Sanity check eh_shoff == 0 implies
	e_shnum == 0.
	Only read the first section header if e_shoff is non-zero.
	Don't consider e_shstrndx if there are no sections.
@
text
@d61 1
d637 1
d1036 4
d1517 1
@


1.161
log
@2002-06-07  H.J. Lu <hjl@@gnu.org>

	* readelf.c (DW_CFA_GNU_args_size): Don't define.
	(DW_CFA_GNU_negative_offset_extended): Likewise.
	(DW_CFA_GNU_window_save): Likewise.
	(display_debug_frames): Handle DW_CFA_offset_extended_sf,
	DW_CFA_def_cfa_sf and DW_CFA_def_cfa_offset_sf.
@
text
@d9714 9
a9722 6
  /* There may be some extensions in the first section header.  Don't
     bomb if we can't read it.  */
  if (is_32bit_elf)
    get_32bit_section_headers (file, 1);
  else
    get_64bit_section_headers (file, 1);
@


1.160
log
@Add DLX target
@
text
@d8476 11
a8486 3
#ifndef DW_CFA_GNU_args_size
#define DW_CFA_GNU_args_size 0x2e
#endif
a8489 3
#ifndef DW_CFA_GNU_negative_offset_extended
#define DW_CFA_GNU_negative_offset_extended 0x2f
#endif
d8684 25
a8708 3
#ifndef DW_CFA_GNU_window_save
#define DW_CFA_GNU_window_save 0x2d
#endif
d8729 11
@


1.159
log
@Fix transaltion problems.
@
text
@d59 1
d605 1
d1011 4
d1546 1
@


1.158
log
@	* elf.c (_bfd_elf_make_section_from_shdr): Set SEC_THREAD_LOCAL
	for symbols from SHF_TLS section.
	(_bfd_elf_print_private_bfd_data): Add PT_TLS.
	(elf_fake_sections): Set SHF_TLS for SEC_THREAD_LOCAL sections.
	(map_sections_to_segments): Build PT_TLS segment if necessary.
	(assign_file_positions_for_segments): Likewise.
	(get_program_header_size): Account for PT_TLS segment.
	(swap_out_syms): Set type of BSF_THREAD_LOCAL symbols and symbols from
	SEC_THREAD_LOCAL sections to STT_TLS.
	* reloc.c: Add 386 and IA-64 TLS relocs.
	* section.c (SEC_THREAD_LOCAL): Define.
	(SEC_CONSTRUCTOR_TEXT, SEC_CONSTRUCTOR_DATA, SEC_CONSTRUCTOR_BSS):
	Remove.
	* elflink.h (elf_link_add_object_symbols): Support .tcommon.
	(size_dynamic_sections): If DF_STATIC_TLS, set DF_FLAGS
	unconditionally.
	(struct elf_final_link_info): Add first_tls_sec.
	(elf_bfd_final_link): Set first_tls_sec.
	Compute elf_hash_table (info)->tls_segment.
	(elf_link_output_extsym): Handle STT_TLS symbols.
	(elf_link_input_bfd): Likewise.
	* syms.c (BSF_THREAD_LOCAL): Define.
	* bfd-in2.h: Rebuilt.
	* libbfd.h: Rebuilt.
	* elf32-i386.c (elf_i386_tls_transition, dtpoff_base, tpoff,
	elf_i386_mkobject, elf_i386_object_p): New functions.
	(elf_howto_table): Add TLS relocs.
	(elf_i386_reloc_type_lookup): Support TLS relocs.
	(elf_i386_info_to_howto_rel): Likewise.
	(struct elf_i386_link_hash_entry): Add tls_type.
	(struct elf_i386_obj_tdata): New.
	(elf_i386_hash_entry, elf_i386_tdata, elf_i386_local_got_tls_type):
	New macros.
	(struct elf_i386_link_hash_table): Add tls_ldm_got.
	(link_hash_newfunc): Clear tls_type.
	(elf_i386_check_relocs): Support TLS relocs.
	(elf_i386_gc_sweep_hook): Likewise.
	(allocate_dynrelocs): Likewise.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Likewise.
	(elf_i386_finish_dynamic_symbol): Likewise.
	(bfd_elf32_mkobject, elf_backend_object_p): Define.
	* elfxx-ia64.c (struct elfNN_ia64_dyn_sym_info): Add tprel_offset,
	dtpmod_offset, dtprel_offset, tprel_done, dtpmod_done, dtprel_done,
	want_tprel, want_dtpmod, want_dtprel.
	(elfNN_ia64_tprel_base, elfNN_ia64_dtprel_base): New functions.
	(ia64_howto_table): Add TLS relocs, rename R_IA64_LTOFF_TP22 to
	R_IA64_LTOFF_TPREL22.
	(elf_code_to_howto_index): Add TLS relocs.
	(elfNN_ia64_check_relocs): Support TLS relocs.
	(allocate_global_data_got): Account for TLS .got data.
	(allocate_dynrel_entries): Account for TLS dynamic relocations.
	(elfNN_ia64_install_value): Supprt TLS relocs.
	(set_got_entry): Support TLS relocs.
	(elfNN_ia64_relocate_section): Likewise.

	* config/obj-elf.c (elf_common): Renamed from obj_elf_common.
	(obj_elf_common): Call elf_common.
	(obj_elf_tls_common): New function.
	(elf_pseudo_tab): Support .tls_common.
	(special_sections): Add .tdata and .tbss.
	(obj_elf_change_section): Set SEC_THREAD_LOCAL for SHF_TLS
	sections.
	(obj_elf_parse_section_letters): Support T in section flags (SHF_TLS).
	(obj_elf_parse_section_letters): Include T in error message.
	* config/tc-ppc.c (ppc_section_letter): Likewise.
	* config/tc-alpha.c (alpha_elf_section_letter): Likewise.
	(tc_gen_reloc): Handle SEC_THREAD_LOCAL the same way as
	SEC_MERGE.
	* config/tc-sparc.c (md_apply_fix3): Likewise.
	* config/tc-i386.c (tc_i386_fix_adjustable): Add TLS relocs.
	Define them if not BFD_ASSEMBLER.
	(lex_got): Support @@TLSGD, @@TLSLDM, @@GOTTPOFF, @@TPOFF, @@DTPOFF
	and @@NTPOFF.
	(md_apply_fix3): Add TLS relocs.
	* config/tc-ia64.c (enum reloc_func): Add FUNC_DTP_MODULE,
	FUNC_DTP_RELATIVE, FUNC_TP_RELATIVE, FUNC_LT_DTP_MODULE,
	FUNC_LT_DTP_RELATIVE, FUNC_LT_TP_RELATIVE.
	(pseudo_func): Support @@dtpmod(), @@dtprel() and @@tprel().
	(ia64_elf_section_letter): Include T in error message.
	(md_begin): Support TLS operators.
	(md_operand): Likewise.
	(ia64_gen_real_reloc_type): Support TLS relocs.
	* testsuite/gas/i386/tlspic.s: New file.
	* testsuite/gas/i386/tlsd.s: New file.
	* testsuite/gas/i386/tlsnopic.s: New file.
	* testsuite/gas/i386/tlsd.d: New file.
	* testsuite/gas/i386/tlsnopic.d: New file.
	* testsuite/gas/i386/tlspic.d: New file.
	* testsuite/gas/i386/i386.exp: Add tlsd, tlsnopic and tlspic tests.
	* testsuite/gas/ia64/tls.s: New file.
	* testsuite/gas/ia64/tls.d: New file.
	* testsuite/gas/ia64/ia64.exp: Add tls test.
	* write.c (adjust_reloc_syms): Don't change symbols in
	SEC_THREAD_LOCAL sections to STT_SECTION + addend.

	* elf/common.h (PT_TLS, SHF_TLS, STT_TLS, DF_STATIC_TLS): Define.
	* elf/ia64.h (R_IA64_LTOFF_TPREL22): Renamed from R_IA64_LTOFF_TP22.
	* elf/i386.h: Add TLS relocs.

	* scripttempl/elf.sc: Add .rel{,a}.t{bss,data}, .tdata and .tbss.
	* ldlang.c (lang_add_section): Set SEC_THREAD_LOCAL for
	output section if necessary.  Handle .tbss.
	(lang_size_sections): Clear _raw_size for .tbss section
	(it allocates space in PT_TLS segment only).
	* ldwrite.c (build_link_order): Build link order for .tbss too.

	* readelf.c (get_segment_type): Add PT_TLS.
	(get_elf_section_flags): Add SHF_TLS.
	(get_dynamic_flags): Optimize.  Add DF_STATIC_TLS.
	(process_dynamic_segment): Use puts instead of printf.
	(get_symbol_type): Support STT_TLS.
	* objdump.c (dump_section_header): Remove SEC_CONSTRUCTOR_TEXT,
	SEC_CONSTRUCTOR_DATA, SEC_CONSTRUCTOR_BSS.
	Add SEC_THREAD_LOCAL.
@
text
@d2767 4
a2770 2
      printf
	(_("\nProgram Header%s:\n"), elf_header.e_phnum > 1 ? "s" : "");
d3347 4
a3350 1
  printf (_("\nSection Header%s:\n"), elf_header.e_shnum > 1 ? "s" : "");
d3556 1
a3556 1
		printf ("'%s'", SECTION_NAME (section));
d3989 1
a3989 1
	    printf ("'%s'", SECTION_NAME (unwsec));
d4003 1
a4003 1
	    printf ("'%s'", SECTION_NAME (unwsec));
d9235 1
a9235 1
	  error (_("conflict list with without table"));
d9318 1
a9318 1
    case NT_WIN32PSTATUS: return _("NT_WIN32PSTATUS (win32_pstatus strcuture)");
@


1.157
log
@	* rdcoff.c: Fix formatting.
	* rddbg.c: Likewise.
	* readelf.c: Likewise.
	* rename.c: Likewise.
	* resbin.c: Likewise.
	* resrc.c: Likewise.
	* resres.c: Likewise.
@
text
@d1990 1
d3206 1
d4247 4
a4250 1
  static char buff [64];
d4258 3
d4263 6
a4268 5
	case DF_ORIGIN:   strcat (buff, "ORIGIN "); break;
	case DF_SYMBOLIC: strcat (buff, "SYMBOLIC "); break;
	case DF_TEXTREL:  strcat (buff, "TEXTREL "); break;
	case DF_BIND_NOW: strcat (buff, "BIND_NOW "); break;
	default:          strcat (buff, "unknown "); break;
d4270 2
d4457 1
a4457 1
	    printf ("%s", get_dynamic_flags (entry->d_un.d_val));
d5266 1
@


1.156
log
@2002-04-25  Elena Zannoni <ezannoni@@redhat.com>

        * readelf.c (get_AT_name): Handle DW_AT_GNU_vector.
@
text
@d537 1
a537 1
  else 
d914 1
a914 1
	  if (elf_header.e_machine == EM_MIPS) 
d1044 1
a1044 1
	  if (!is_32bit_elf) 
d1098 4
a1101 4
        case EM_S390_OLD:
        case EM_S390:
          rtype = elf_s390_reloc_type (type);
          break;
d1154 1
a1154 1
      if (! is_32bit_elf && elf_header.e_machine == EM_MIPS) 
d1178 1
a1178 1
          putchar ('\n');
d1708 3
a1710 3
        case EM_68K:
          if (e_flags & EF_CPU32)
            strcat (buf, ", cpu32");
d1713 1
a1713 1
          break;
d2395 1
a2395 1
	      
d2446 1
a2446 1
		    
d3428 7
a3434 7
 	  if ((long) section->sh_offset == section->sh_offset)
 	    printf ("  %8.8lx", (unsigned long) section->sh_offset);
 	  else
 	    {
 	      printf ("  ");
 	      print_vma (section->sh_offset, LONG_HEX);
 	    }
d6172 2
a6173 2
	    } 
	  else switch (op_code) 
d6177 1
a6177 1
                                                debug_line_pointer_size);
d6246 1
a6246 1
	      
d6250 1
a6250 1
	      
d6256 1
a6256 1
	      
d7255 1
a7255 1
  
d7277 1
a7277 1
          /* Normally, the lists in  the debug_loc section are related to a
d7288 1
a7288 1
	  
d7291 1
a7291 1
	  
d7294 1
a7294 1
	  
d7297 1
a7297 1
	  
d7301 1
a7301 1
	  
d7488 1
a7488 1
                                          pointer_size);
d7737 1
a7737 1
                                      pointer_size);
d8376 76
a8451 76
      {
	/* Start by making a pass over the chunk, allocating storage
           and taking note of what registers are used.  */
	unsigned char * tmp = start;

	while (start < block_end)
	  {
	    unsigned op, opa;
	    unsigned long reg;

	    op = * start ++;
	    opa = op & 0x3f;
	    if (op & 0xc0)
	      op &= 0xc0;

	    /* Warning: if you add any more cases to this switch, be
	       sure to add them to the corresponding switch below.  */
	    switch (op)
	      {
	      case DW_CFA_advance_loc:
		break;
	      case DW_CFA_offset:
		LEB ();
		frame_need_space (fc, opa);
		fc->col_type[opa] = DW_CFA_undefined;
		break;
	      case DW_CFA_restore:
		frame_need_space (fc, opa);
		fc->col_type[opa] = DW_CFA_undefined;
		break;
	      case DW_CFA_set_loc:
		start += encoded_ptr_size;
		break;
	      case DW_CFA_advance_loc1:
		start += 1;
		break;
	      case DW_CFA_advance_loc2:
		start += 2;
		break;
	      case DW_CFA_advance_loc4:
		start += 4;
		break;
	      case DW_CFA_offset_extended:
		reg = LEB (); LEB ();
		frame_need_space (fc, reg);
		fc->col_type[reg] = DW_CFA_undefined;
		break;
	      case DW_CFA_restore_extended:
		reg = LEB ();
		frame_need_space (fc, reg);
		fc->col_type[reg] = DW_CFA_undefined;
		break;
	      case DW_CFA_undefined:
		reg = LEB ();
		frame_need_space (fc, reg);
		fc->col_type[reg] = DW_CFA_undefined;
		break;
	      case DW_CFA_same_value:
		reg = LEB ();
		frame_need_space (fc, reg);
		fc->col_type[reg] = DW_CFA_undefined;
		break;
	      case DW_CFA_register:
		reg = LEB (); LEB ();
		frame_need_space (fc, reg);
		fc->col_type[reg] = DW_CFA_undefined;
		break;
	      case DW_CFA_def_cfa:
		LEB (); LEB ();
		break;
	      case DW_CFA_def_cfa_register:
		LEB ();
		break;
	      case DW_CFA_def_cfa_offset:
		LEB ();
		break;
d8455 3
a8457 3
	      case DW_CFA_GNU_args_size:
		LEB ();
		break;
d8461 4
a8464 4
	      case DW_CFA_GNU_negative_offset_extended:
		reg = LEB (); LEB ();
		frame_need_space (fc, reg);
		fc->col_type[reg] = DW_CFA_undefined;
d8466 6
a8471 6
	      default:
		break;
	      }
	  }
	start = tmp;
      }
d8488 2
a8489 2
	    /* Warning: if you add any more cases to this switch, be
	       sure to add them to the corresponding switch above.  */
d8494 1
a8494 1
	        frame_display_row (fc, &need_col_headers, &max_regs);
d8496 2
a8497 2
	        printf ("  DW_CFA_advance_loc: %d to %08lx\n",
		        opa * fc->code_factor,
d8505 1
a8505 1
	        printf ("  DW_CFA_offset: r%d at cfa%+ld\n",
d8513 1
a8513 1
	        printf ("  DW_CFA_restore: r%d\n", opa);
d8522 1
a8522 1
	        frame_display_row (fc, &need_col_headers, &max_regs);
d8524 1
a8524 1
	        printf ("  DW_CFA_set_loc: %08lx\n", (unsigned long)vma);
d8531 1
a8531 1
	        frame_display_row (fc, &need_col_headers, &max_regs);
d8533 2
a8534 2
	        printf ("  DW_CFA_advance_loc1: %ld to %08lx\n",
		        ofs * fc->code_factor,
d8542 1
a8542 1
	        frame_display_row (fc, &need_col_headers, &max_regs);
d8544 2
a8545 2
	        printf ("  DW_CFA_advance_loc2: %ld to %08lx\n",
		        ofs * fc->code_factor,
d8553 1
a8553 1
	        frame_display_row (fc, &need_col_headers, &max_regs);
d8555 2
a8556 2
	        printf ("  DW_CFA_advance_loc4: %ld to %08lx\n",
		        ofs * fc->code_factor,
d8574 1
a8574 1
	        printf ("  DW_CFA_restore_extended: r%ld\n", reg);
d8582 1
a8582 1
	        printf ("  DW_CFA_undefined: r%ld\n", reg);
d8590 1
a8590 1
	        printf ("  DW_CFA_same_value: r%ld\n", reg);
d8599 1
a8599 1
	        printf ("  DW_CFA_register: r%ld\n", reg);
d8606 1
a8606 1
	        printf ("  DW_CFA_remember_state\n");
d8619 1
a8619 1
	        printf ("  DW_CFA_restore_state\n");
d8634 1
a8634 1
	        printf ("  DW_CFA_def_cfa: r%d ofs %d\n",
d8641 1
a8641 1
	        printf ("  DW_CFA_def_cfa_reg: r%d\n", fc->cfa_reg);
d8647 1
a8647 1
	        printf ("  DW_CFA_def_cfa_offset: %d\n", fc->cfa_offset);
d8652 1
a8652 1
	        printf ("  DW_CFA_nop\n");
d8660 1
a8660 1
	        printf ("  DW_CFA_GNU_window_save\n");
d8666 1
a8666 1
	        printf ("  DW_CFA_GNU_args_size: %ld\n", ul);
d8674 1
a8674 1
	        printf ("  DW_CFA_GNU_negative_offset_extended: r%ld at cfa%+ld\n",
d8687 1
a8687 1
        frame_display_row (fc, &need_col_headers, &max_regs);
d8826 1
a8826 1
        continue;
d8830 1
a8830 1
        if (strcmp (debug_displays[j].name, name) == 0)
d8848 2
a8849 2
            break;
          }
d9377 1
a9377 1
  Elf32_Internal_Note * pnote;
@


1.155
log
@Remove unused function fetch_location_list.
Catch corrupt core notes and display a warning message.
@
text
@d6532 1
@


1.154
log
@2002-03-20  Daniel Berlin  <dan@@dberlin.org>

	* readelf.c: Add support for displaying dwarf2 location lists.
	(do_debug_loc, debug_loc_section, debug_loc_size): New.
	(parse_args): Use 'O' as shorthand for displaying location list
	section.
	(process_section_headers): Handle debug_loc as well.
	(load_debug_loc): New.
	(free_debug_loc): New.
	(fetch_location_list): New.
	(display_debug_loc): New.
	(display_debug_info): Call load_debug_loc and free_debug_loc.
	(debug_displays): We can display .debug_loc now, too.
	(usage): Update usage string.
	(read_and_display_attr_value): Note location lists, but don't
	display them inline.
@
text
@a237 1
static const char *       fetch_location_list         PARAMS ((unsigned long));
a7242 9
static const char *
fetch_location_list (offset)
     unsigned long offset;
{
  if (debug_loc_contents == NULL)
    return _("<no .debug_loc section>");

  if (offset > debug_loc_size)
    return _("<offset is too big>");
a7243 2
  return debug_loc_contents + offset;
}
d9431 1
d9442 12
a9453 1
      external = (Elf_External_Note *)(inote.descdata + align_power (inote.descsz, 2));
@


1.153
log
@Fix typo.
@
text
@d130 1
d231 1
d236 3
d2256 1
a2256 1
  -w --debug-dump[=line,=info,=abbrev,=pubnames,=ranges,=macro,=frames,=str]\n\
d2443 5
d3314 2
a3315 1
		|| do_debug_frames || do_debug_macinfo || do_debug_str)
d3329 1
d7202 117
d7723 6
d7765 1
d7950 1
d8762 1
a8762 1
  
@


1.152
log
@Display 2nd and 3rd reloc types for 64-bit MIPS.
Narrow some fields for 80-char output.
@
text
@d948 1
a948 1
		  ? "%16.16lx  %16.16lx ",
@


1.151
log
@bfd:
2002-02-13  Matt Fredette  <fredette@@netbsd.org>

* elf32-m68k.c (elf32_m68k_print_private_bfd_data): Recognize
EF_M68000.


bintuls:
2002-02-13  Matt Fredette  <fredette@@netbsd.org>

* readelf.c (get_machine_flags): Recognize EF_M68000.


gas:
2002-02-13  Matt Fredette  <fredette@@netbsd.org>

* config/tc-m68k.c (md_show_usage): No longer display a
hard-coded "68020" for the default CPU, instead display the
canonical name of the true, configured default CPU.
(m68k_elf_final_processing): Mark objects for sub-68020
CPUs with the new EF_M68000 flag.


include/elf:
2002-02-13  Matt Fredette  <fredette@@netbsd.org>

* m68k.h (EF_M68000): Define.
@
text
@d848 6
a853 2
	printf
	  (_(" Offset     Info    Type            Symbol's Value  Symbol's Name          Addend\n"));
d855 6
a860 2
	printf
	  (_(" Offset     Info    Type            Symbol's Value  Symbol's Name\n"));
d865 6
a870 2
	printf
	  (_("    Offset             Info            Type               Symbol's Value   Symbol's Name           Addend\n"));
d872 6
a877 2
	printf
	  (_("    Offset             Info            Type               Symbol's Value   Symbol's Name\n"));
d883 2
d889 2
d910 8
a917 2
	  if (elf_header.e_machine == EM_SPARCV9)
	    type       = ELF64_R_TYPE_ID (info);
d919 1
a919 1
	    type       = ELF64_R_TYPE (info);
d939 3
a941 1
	  printf ("%8.8lx%8.8lx  %8.8lx%8.8lx ",
d947 4
a950 1
	  printf ("%16.16lx  %16.16lx ", offset, info);
d1040 5
d1106 1
a1106 1
	printf (_("unrecognised: %-7lx"), _bfd_int64_low (type));
d1108 1
a1108 1
	printf (_("unrecognised: %-7lx"), type);
d1111 1
a1111 1
	printf ("%-21.21s", rtype);
d1125 1
a1125 1
	      printf ("  ");
d1128 1
a1128 1
		print_symbol (-25, SECTION_NAME (section_headers + psym->st_shndx));
d1132 1
a1132 1
		print_symbol (-25, strtab + psym->st_name);
d1140 1
a1140 1
	  printf ("%*c", is_32bit_elf ? 34 : 26, ' ');
d1149 27
d1570 1
a1570 1
      strcat (buf, ", <unrecognised EABI>");
d2439 1
a2439 1
		    warn (_("Unrecognised debug option '%s'\n"), optarg);
d7445 1
a7445 1
      warn (_("Unrecognised form: %d\n"), form);
d8668 1
a8668 1
    printf (_("Unrecognised debug section: %s\n"), name);
@


1.150
log
@Add DT_PPC64_OPD and DT_PPC64_OPDSZ dynamic tags
@
text
@d1644 2
@


1.149
log
@Add support for OpenRISC 32-bit embedded processor
@
text
@d1196 2
@


1.149.2.1
log
@Add DT_PPC64_OPD and DT_PPC64_OPDSZ dynamic tags.

	* elf64-ppc.c (ppc64_elf_size_stubs): Correct test for crossing
	64k boundary.
@
text
@a1195 2
    case DT_PPC64_OPD:   return "PPC64_OPD";
    case DT_PPC64_OPDSZ: return "PPC64_OPDSZ";
@


1.149.2.2
log
@bfd:
2002-02-13  Matt Fredette  <fredette@@netbsd.org>

* elf32-m68k.c (elf32_m68k_print_private_bfd_data): Recognize
EF_M68000.

bintuls:
2002-02-13  Matt Fredette  <fredette@@netbsd.org>

* readelf.c (get_machine_flags): Recognize EF_M68000.

gas:
2002-02-13  Matt Fredette  <fredette@@netbsd.org>

* config/tc-m68k.c (md_show_usage): No longer display a
hard-coded "68020" for the default CPU, instead display the
canonical name of the true, configured default CPU.
(m68k_elf_final_processing): Mark objects for sub-68020
CPUs with the new EF_M68000 flag.

include/elf:
2002-02-13  Matt Fredette  <fredette@@netbsd.org>

* m68k.h (EF_M68000): Define.
@
text
@a1643 2
	  if (e_flags & EF_M68000)
	    strcat (buf, ", m68000");
@


1.149.2.3
log
@	Merge from mainline
	2002-04-25  Elena Zannoni <ezannoni@@redhat.com>
        * readelf.c (get_AT_name): Handle DW_AT_GNU_vector.

	2002-04-16  Nick Clifton  <nickc@@cambridge.redhat.com>
	* readelf.c (fetch_location_list): Remove unused function.
	* readelf.c (process_corefile_note_segment): Catch corrupt notes
	and display a warning message, then exit the loop.

	2002-04-24  Christian Groessler <chris@@groessler.org>
	* MAINTAINERS: Changed my email address.

	2002-04-09  J"orn Rennecke <joern.rennecke@@superh.com>
	* MAINTAINERS: Update my email address.

	2002-03-27  Peter Targett  <peter.targett@@arc.com>
	* MAINTAINERS: Update my email address.

	2002-03-20  Daniel Berlin  <dan@@dberlin.org>
	* readelf.c: Add support for displaying dwarf2 location lists.
	(do_debug_loc, debug_loc_section, debug_loc_size): New.
	(parse_args): Use 'O' as shorthand for displaying location list
	section.
	(process_section_headers): Handle debug_loc as well.
	(load_debug_loc): New.
	(free_debug_loc): New.
	(fetch_location_list): New.
	(display_debug_loc): New.
	(display_debug_info): Call load_debug_loc and free_debug_loc.
	(debug_displays): We can display .debug_loc now, too.
	(usage): Update usage string.
	(read_and_display_attr_value): Note location lists, but don't
	display them inline.

	2002-03-01  Dmitry Timoshkov <dmitry@@baikal.ru>
	* dlltool.c (gen_exp_file): Take into account --kill-at (-k) while
	generating .exp file.

	2002-02-21  Nick Clifton  <nickc@@cambridge.redhat.com>
	* readelf.c (dump_relocations): Fix typo.

	2002-02-18  Timothy Daly  <remote_bob@@yahoo.com>
	* readelf.c (dump_relocations): Display 2nd and 3rd reloc
	types for 64-bit MIPS.  Narrow some fields for 80-char
	output.
	(dump_relocations): Change spelling from 'unrecognised'
	to 'unrecognized'.
	(decode_ARM_machine_flags): Likewise.
	(parse_args): Likewise.
	(read_and_display_attr_value): Likewise.
	(display_debug_section): Likewise.
@
text
@a129 1
int                     do_debug_loc;
a229 1
static int                display_debug_loc           PARAMS ((Elf32_Internal_Shdr *, unsigned char *, FILE *));
a233 2
static void               load_debug_loc              PARAMS ((FILE *));
static void               free_debug_loc              PARAMS ((void));
d848 2
a849 6
	{
	  if (do_wide)
	    printf (_(" Offset     Info    Type                Sym. Value  Symbol's Name + Addend\n"));
	  else
	    printf (_(" Offset     Info    Type            Sym.Value  Sym. Name + Addend\n"));
	}
d851 2
a852 6
	{
	  if (do_wide)
	    printf (_(" Offset     Info    Type                Sym. Value  Symbol's Name\n"));
	  else
	    printf (_(" Offset     Info    Type            Sym.Value  Sym. Name\n"));
	}
d857 2
a858 6
	{
	  if (do_wide)
	    printf (_("    Offset             Info            Type               Symbol's Value  Symbol's Name + Addend\n"));
	  else
	    printf (_("  Offset          Info           Type           Sym. Value    Sym. Name + Addend\n"));
	}
d860 2
a861 6
	{
	  if (do_wide)
	    printf (_("    Offset             Info            Type               Symbol's Value  Symbol's Name\n"));
	  else
	    printf (_("  Offset          Info           Type           Sym. Value    Sym. Name\n"));
	}
a866 2
      const char * rtype2 = NULL;
      const char * rtype3 = NULL;
a870 2
      bfd_vma      type2 = (bfd_vma) NULL;
      bfd_vma      type3 = (bfd_vma) NULL;
d890 2
a891 8
	  if (elf_header.e_machine == EM_MIPS) 
	    {
	      type  = ELF64_MIPS_R_TYPE (info);
	      type2 = ELF64_MIPS_R_TYPE2 (info);
	      type3 = ELF64_MIPS_R_TYPE3 (info);
	    }
	  else if (elf_header.e_machine == EM_SPARCV9)
	    type = ELF64_R_TYPE_ID (info);
d893 1
a893 1
	    type = ELF64_R_TYPE (info);
d913 1
a913 3
	  printf (do_wide
		  ? "%8.8lx%8.8lx  %8.8lx%8.8lx "
		  : "%4.4lx%8.8lx  %4.4lx%8.8lx ",
d919 1
a919 4
	  printf (do_wide
		  ? "%16.16lx  %16.16lx "
		  : "%12.12lx  %12.12lx ",
		  offset, info);
a1008 5
	  if (!is_32bit_elf) 
	    {
	      rtype2 = elf_mips_reloc_type (type2);
	      rtype3 = elf_mips_reloc_type (type3);
	    }
d1070 1
a1070 1
	printf (_("unrecognized: %-7lx"), _bfd_int64_low (type));
d1072 1
a1072 1
	printf (_("unrecognized: %-7lx"), type);
d1075 1
a1075 1
	printf (do_wide ? "%-21.21s" : "%-17.17s", rtype);
d1089 1
a1089 1
	      printf (is_32bit_elf ? "   " : " ");
d1092 1
a1092 1
		print_symbol (22, SECTION_NAME (section_headers + psym->st_shndx));
d1096 1
a1096 1
		print_symbol (22, strtab + psym->st_name);
d1104 1
a1104 1
	  printf ("%*c", is_32bit_elf ? (do_wide ? 34 : 28) : (do_wide ? 26 : 20), ' ');
a1112 27

      if (! is_32bit_elf && elf_header.e_machine == EM_MIPS) 
	{
	  printf ("                    Type2: ");

	  if (rtype2 == NULL)
#ifdef _bfd_int64_low
	    printf (_("unrecognized: %-7lx"), _bfd_int64_low (type2));
#else
	    printf (_("unrecognized: %-7lx"), type2);
#endif
	  else
	    printf ("%-17.17s", rtype2);

	  printf("\n                    Type3: ");

	  if (rtype3 == NULL)
#ifdef _bfd_int64_low
	    printf (_("unrecognized: %-7lx"), _bfd_int64_low (type3));
#else
	    printf (_("unrecognized: %-7lx"), type3);
#endif
	  else
	    printf ("%-17.17s", rtype3);

          putchar ('\n');
	}
d1507 1
a1507 1
      strcat (buf, ", <unrecognized EABI>");
d2188 1
a2188 1
  -w --debug-dump[=line,=info,=abbrev,=pubnames,=ranges,=macro,=frames,=str,=loc]\n\
a2374 5
		  case 'o':
		  case 'O':
		    do_debug_loc = 1;
		    break;
		    
d2376 1
a2376 1
		    warn (_("Unrecognized debug option '%s'\n"), optarg);
d3241 1
a3241 2
		|| do_debug_frames || do_debug_macinfo || do_debug_str
		|| do_debug_loc)
a3254 1
	      || (do_debug_loc      && (strcmp (name, "loc") == 0))
a6457 1
    case DW_AT_GNU_vector:           return "DW_AT_GNU_vector";
a7126 106
static const char * debug_loc_contents;
static bfd_vma      debug_loc_size;

static void
load_debug_loc (file)
     FILE * file;
{
  Elf32_Internal_Shdr * sec;
  unsigned int          i;

  /* If it is already loaded, do nothing.  */
  if (debug_loc_contents != NULL)
    return;

  /* Locate the .debug_loc section.  */
  for (i = 0, sec = section_headers;
       i < elf_header.e_shnum;
       i ++, sec ++)
    if (strcmp (SECTION_NAME (sec), ".debug_loc") == 0)
      break;

  if (i == elf_header.e_shnum || sec->sh_size == 0)
    return;

  debug_loc_size = sec->sh_size;

  debug_loc_contents = ((char *)
			get_data (NULL, file, sec->sh_offset, sec->sh_size,
				  _("debug_loc section data")));
}

static void
free_debug_loc ()
{
  if (debug_loc_contents == NULL)
    return;

  free ((char *) debug_loc_contents);
  debug_loc_contents = NULL;
  debug_loc_size = 0;
}


static int
display_debug_loc (section, start, file)
     Elf32_Internal_Shdr * section;
     unsigned char * start;
     FILE * file ATTRIBUTE_UNUSED;
{
  unsigned char *section_end;
  unsigned long bytes;
  unsigned char *section_begin = start;
  bfd_vma addr;
  
  addr = section->sh_addr;
  bytes = section->sh_size;
  section_end = start + bytes;
  if (bytes == 0)
    {
      printf (_("\nThe .debug_loc section is empty.\n"));
      return 0;
    }
  printf (_("Contents of the .debug_loc section:\n\n"));
  printf (_("\n    Offset   Begin    End      Expression\n"));
  while (start < section_end)
    {
      unsigned long begin;
      unsigned long end;
      unsigned short length;
      unsigned long offset;

      offset = start - section_begin;

      while (1)
	{
          /* Normally, the lists in  the debug_loc section are related to a
	     given compilation unit, and thus, we would use the
	     pointer size of that compilation unit.  However, since we are
	     displaying it seperately here, we either have to store
	     pointer sizes of all compilation units, or assume they don't
	     change.   We assume, like the debug_line display, that
	     it doesn't change.  */
	  begin = byte_get (start, debug_line_pointer_size);
	  start += debug_line_pointer_size;
	  end = byte_get (start, debug_line_pointer_size);
	  start += debug_line_pointer_size;
	  
	  if (begin == 0 && end == 0)
	    break;
	  
	  begin += addr;
	  end += addr;
	  
	  length = byte_get (start, 2);
	  start += 2;
	  
	  printf ("    %8.8lx %8.8lx %8.8lx (", offset, begin, end);
	  decode_location_expression (start, debug_line_pointer_size, length);
	  printf (")\n");
	  
	  start += length;
	}
      printf ("\n");
    }
  return 1;
}
d7382 1
a7382 1
      warn (_("Unrecognized form: %d\n"), form);
a7530 6
      else if (form == DW_FORM_data4)
	{
	  printf ("(");
	  printf ("location list");
	  printf (")");
	}
a7566 1
  load_debug_loc (file);
a7750 1
  free_debug_loc ();
d8562 1
a8562 1
  { ".debug_loc",         display_debug_loc, NULL },
d8605 1
a8605 1
    printf (_("Unrecognized debug section: %s\n"), name);
a9242 1
      Elf_External_Note * next;
d9253 1
a9253 12
      next = (Elf_External_Note *)(inote.descdata + align_power (inote.descsz, 2));

      if (((char *) next) > (((char *) pnotes) + length))
	{
	  warn (_("corrupt note found at offset %x into core notes\n"),
		((char *) external) - ((char *) pnotes));
	  warn (_(" type: %x, namesize: %08lx, descsize: %08lx\n"),
		inote.type, inote.namesz, inote.descsz);
	  break;
	}

      external = next;
@


1.148
log
@Tidy up formatting of --help output.
@
text
@a51 4
#include "elf/i386.h"
#include "elf/v850.h"
#include "elf/ppc.h"
#include "elf/mips.h"
d53 1
d55 2
a56 3
#include "elf/m68k.h"
#include "elf/sparc.h"
#include "elf/m32r.h"
d59 2
a60 3
#include "elf/sh.h"
#include "elf/mn10200.h"
#include "elf/mn10300.h"
d62 6
a67 3
#include "elf/h8.h"
#include "elf/arc.h"
#include "elf/fr30.h"
d69 1
d71 3
a73 1
#include "elf/i960.h"
d75 5
a79 4
#include "elf/avr.h"
#include "elf/ia64.h"
#include "elf/cris.h"
#include "elf/i860.h"
a80 1
#include "elf/s390.h"
d600 2
d1033 5
d1469 2
@


1.147
log
@	* readelf.c (get_machine_name): Handle EM_PPC64.
	(guess_is_rela): Here too.
@
text
@d2154 22
a2175 21
  fprintf (stdout, _("Usage: readelf {options} elf-file(s)\n"));
  fprintf (stdout, _("  Options are:\n"));
  fprintf (stdout, _("  -a or --all               Equivalent to: -h -l -S -s -r -d -V -A -I\n"));
  fprintf (stdout, _("  -h or --file-header       Display the ELF file header\n"));
  fprintf (stdout, _("  -l or --program-headers or --segments\n"));
  fprintf (stdout, _("                            Display the program headers\n"));
  fprintf (stdout, _("  -S or --section-headers or --sections\n"));
  fprintf (stdout, _("                            Display the sections' header\n"));
  fprintf (stdout, _("  -e or --headers           Equivalent to: -h -l -S\n"));
  fprintf (stdout, _("  -s or --syms or --symbols Display the symbol table\n"));
  fprintf (stdout, _("  -n or --notes             Display the core notes (if present)\n"));
  fprintf (stdout, _("  -r or --relocs            Display the relocations (if present)\n"));
  fprintf (stdout, _("  -u or --unwind            Display the unwind info (if present)\n"));
  fprintf (stdout, _("  -d or --dynamic           Display the dynamic segment (if present)\n"));
  fprintf (stdout, _("  -V or --version-info      Display the version sections (if present)\n"));
  fprintf (stdout, _("  -A or --arch-specific     Display architecture specific information (if any).\n"));
  fprintf (stdout, _("  -D or --use-dynamic       Use the dynamic section info when displaying symbols\n"));
  fprintf (stdout, _("  -x <number> or --hex-dump=<number>\n"));
  fprintf (stdout, _("                            Dump the contents of section <number>\n"));
  fprintf (stdout, _("  -w[liaprmfs] or --debug-dump[=line,=info,=abbrev,=pubnames,=ranges,=macro,=frames,=str]\n"));
  fprintf (stdout, _("                            Display the contents of DWARF2 debug sections\n"));
d2177 3
a2179 2
  fprintf (stdout, _("  -i <number> or --instruction-dump=<number>\n"));
  fprintf (stdout, _("                            Disassemble the contents of section <number>\n"));
d2181 5
a2185 4
  fprintf (stdout, _("  -I or --histogram         Display histogram of bucket list lengths\n"));
  fprintf (stdout, _("  -v or --version           Display the version number of readelf\n"));
  fprintf (stdout, _("  -W or --wide              Don't split lines or truncate symbols to fit into 80 columns\n"));
  fprintf (stdout, _("  -H or --help              Display this information\n"));
@


1.146
log
@	* readelf.c (get_ppc64_dynamic_type): New.
	(get_dynamic_type): Call it.
@
text
@d616 1
d1394 1
@


1.145
log
@include/elf:
* common.h: Update copyright years.
(NT_NETBSDCORE_PROCINFO): Define.
(NT_NETBSDCORE_FIRSTMACH): Define.

bfd:
* elf.c: Update copyright years.
(elfcore_grok_netbsd_note): Use NT_NETBSDCORE_PROCINFO
and NT_NETBSDCORE_FIRSTMACH.  Improve a comment.

bintuils:
* readelf.c (get_netbsd_elfcore_note_type): Use
NT_NETBSDCORE_PROCINFO and NT_NETBSDCORE_FIRSTMACH.
@
text
@d162 1
d1181 12
d1303 3
@


1.144
log
@* readelf.c: Update copyright years.
(get_note_type): Return a const char *.
(get_netbsd_elfcore_note_type): New function.
(process_note): Use get_netbsd_elfcore_note_type to get
the note type string for NetBSD ELF core files.
@
text
@d9090 1
a9090 1
  if (e_type == 1)
d9101 1
a9101 1
  if (e_type < 32)
d9119 4
a9122 2
	case 32+0:	return _("PT_GETREGS (reg structure)");
	case 32+2:	return _("PT_GETFPREGS (fpreg structure)");
d9133 4
a9136 2
	case 32+1:	return _("PT_GETREGS (reg structure)");
	case 32+3:	return _("PT_GETFPREGS (fpreg structure)");
d9142 1
a9142 1
  sprintf (buff, _("PT_FIRSTMACH+%d"), e_type - 32);
@


1.143
log
@	* readelf.c (get_ia64_segment_type): Add support for macros.
	(get_segment_type): Add support for IA64 specific macros.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d250 2
a251 1
static char *		  get_note_type		         PARAMS ((unsigned int));
d9059 1
a9059 1
static char *
d9084 58
d9151 20
d9173 1
a9173 1
	  pnote->descsz, get_note_type (pnote->type));
@


1.142
log
@When --wide is used, do not truncate symbol names.
@
text
@d1864 4
d1929 3
@


1.141
log
@	* readelf.c (get_machine_flags): Recognize header flags for ABI and
	ASE extensions. More robust code for ISA checking. Ignore empty fields
	in header flags for GNU extensions.
@
text
@d156 1
d515 19
d1081 1
a1081 2
		printf ("%-25.25s",
			SECTION_NAME (SECTION_HEADER (psym->st_shndx)));
d1085 1
a1085 1
		printf ("%-25.25s", strtab + psym->st_name);
d2155 1
a2155 1
  fprintf (stdout, _("  -W or --wide              Don't split lines to fit into 80 columns\n"));
d5327 3
a5329 2
	      printf (" %3.3s", get_symbol_index_type (psym->st_shndx));
	      printf (" %s\n", dynamic_strings + psym->st_name);
d5387 2
a5388 2
	      printf (" %4s", get_symbol_index_type (psym->st_shndx));
	      printf (" %s", strtab + psym->st_name);
d5625 3
a5627 2
      printf ("%4d: %-30s ", i,
	      dynamic_strings + dynamic_symbols[i].st_name);
d5640 6
a5645 3
	    printf ("%-10s ",
		    dynamic_strings
		    + dynamic_segment[dynamic_syminfo[i].si_boundto].d_un.d_val);
d8735 4
a8738 3
	      printf ("%3lu: %-20s %s %#10lx %-7ld", (unsigned long) cnt,
		      dynamic_strings + liblist.l_name, timebuf,
		      liblist.l_checksum, liblist.l_version);
d9036 1
a9036 1
	  Elf_Internal_Sym * psym = &dynamic_symbols[iconf[cnt]];
d9038 1
a9038 1
	  printf ("%5lu: %8lu  ", (unsigned long) cnt, iconf[cnt]);
d9040 3
a9042 1
	  printf ("  %s\n", dynamic_strings + psym->st_name);
@


1.140
log
@	Support for more than 64k ELF sections.
include/elf/ChangeLog
	* external.h (Elf_External_Sym_Shndx): Declare.
	* internal.h (struct elf_internal_sym <st_shndx>): Make it an
	unsigned int.
	* common.h (SHN_BAD): Define.

bfd/ChangeLog
	* configure.in: Bump bfd version.
	* configure: Regenerate.
	* elf-bfd.h (elf_size_info <swap_symbol_out>): Add shndx param.
	(bfd_elf32_swap_symbol_in): Likewise.
	(bfd_elf32_swap_symbol_out): Likewise.
	(bfd_elf64_swap_symbol_in): Likewise.
	(bfd_elf64_swap_symbol_out): Likewise.
	(elf_reloc_cookie): Add locsym_shndx field.  Make locsyms a PTR.
	(elf_obj_tdata): Add num_elf_sections, symtab_shndx_hdr and
	symtab_shndx_section.
	(elf_numsections): Define.
	(elf_symtab_shndx): Define.
	* elf.c (setup_group): Use elf_numsections rather than header e_shnum.
	(bfd_elf_find_section): Likewise.
	(bfd_section_from_elf_index): Likewise.
	(bfd_section_from_shdr): Likewise.  Handle SHT_SYMTAB_SHNDX.
	(bfd_section_from_r_symndx): Read symbol shndx extension, and
	translate st_shndx for > SHN_HIRESERVE.
	(assign_section_numbers): Skip reserved sections.  Assign
	symtab_shndx_section and elf_numsections.  Exclude reserved
	sections from e_shnum.  Set up symtab_shndx_hdr.
	(_bfd_elf_compute_section_file_positions): Handle symtab_shndx_hdr.
	(map_sections_to_segments): Don't map eh_frame_hdr unless required.
	(assign_file_positions_except_relocs): Use elf_numsections rather
	than header e_shnum.  Skip reserved sections and symtab_shndx_section.
	(prep_headers): Set name for symtab_shndx_hdr.
	(_bfd_elf_assign_file_positions_for_relocs): Use elf_numsections.
	(_bfd_elf_write_object_contents): Likewise.  Skip reserved sections.
	(_bfd_elf_section_from_bfd_section): Check bfd_{abs,com,und}_section
	first.  Use elf_section_data if available.  Use elf_numsections.
	Start scan at index 1.
	(copy_private_bfd_data ): Comment fixes.
	(MAP_ONESYMTAB): Define above SHN_HIOS.
	(MAP_DYNSYMTAB): Likewise.
	(MAP_STRTAB): Likewise.
	(MAP_SHSTRTAB): Likewise.
	(MAP_SYM_SHNDX): New define.
	(_bfd_elf_copy_private_symbol_data): Handle symtab_shndx_section.
	(swap_out_syms): Swap out SHT_SYMTAB_SHNDX section too.
	* elfcode.h (elf_swap_symbol_in): Add shndx param, and handle shndx
	extension.
	(elf_swap_symbol_out): Likewise.
	(elf_object_p): Set elf_numsections, and use instead of e_shnum.
	Initialialise reserved elf_elfsections to point at shdr[0].  Remove
	redundant bfd_release calls.
	(elf_slurp_symbol_table): Read symbol shndx extension, and use with
	elf_swap_symbol_in.  Translate st_shndx for > SHN_HIRESERVE too.
	* elflink.h (elf_link_is_defined_archive_symbol): Read symbol shndx
	extension, and use with elf_swap_symbol_in.
	(elf_link_record_local_dynamic_symbol): Likewise.
	(elf_link_add_object_symbols): Likewise.  Also translate st_shndx
	for elf sections > SHN_HIRESERVE.
	(NAME(bfd_elf,size_dynamic_sections)): Adjust elf_swap_symbol_out
	call.
	(struct elf_final_link_info): Add locsym_shndx and symshndxbuf.
	(elf_bfd_final_link): Allocate the above, and tidy code allocating
	other buffers.  Use elf_numsections instead of e_shnum.  Adjust
	elf_swap_symbol_out calls.
	(elf_link_output_sym): Swap out symbol shndx extension too.
	(elf_link_flush_output_syms): And flush them to disk.
	(elf_link_output_extsym): Use SHN_BAD.  Adjust elf_swap_symbol_out
	calls.
	(elf_gc_mark): Read symbol shndx extension, and use with
	elf_swap_symbol_in.
	(elf_link_input_bfd): Likewise,  Translate st_shndx for elf sections
	> SHN_HIRESERVE too.  Use SHN_BAD.
	(elf_reloc_symbol_deleted_p): Use symbol shndx extensions with
	elf_swap_symbol_in.  Translate st_shndx > SHN_HIRESERVE too.
	(elf_bfd_discard_info): Read symbol shndx extension.  Don't attempt
	to continue after a bfd error.
	* elf-m10200.c (mn10200_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Translate SHN_UNDEF,
	SHN_ABS, SHN_COMMON and elf sections > SHN_HIRESERVE to bfd
	sections too.  Remove dead code.
	(mn10200_elf_relax_delete_bytes): Use symbol shndx extension
	when swapping in symbols.  Tidy code adjusting global syms.
	Don't swap in global syms.
	(mn10200_elf_symbol_address_p): Likewise.  Remove extsyms param.
	(mn10200_elf_get_relocated_section_contents): Read symbol shndx
	extension, and use with swap_symbol_in.  Rename "size" -> "amt"
	to maximize code in common with other files.  Translate st_shndx
	for > SHN_HIRESERVE too.  Remove dead code.
	* elf-m10300.c (mn10300_elf_relax_section): Only read local syms.
	Stash them immediately to symtab_hdr->contents rather than later
	in multiple places.  Clean up afterwards.  Read symbol shndx
	extension, and use with swap_symbol_in.  Remove dead code.
	(mn10300_elf_relax_delete_bytes): As for elf-m10200.c.
	(mn10300_elf_symbol_address_p): Likewise.
	(mn10300_elf_get_relocated_section_contents): Likewise.
	* elf32-h8300.c (elf32_h8_relax_section): As for elf-m10300.c.
	(elf32_h8_relax_delete_bytes): Likewise.
	(elf32_h8_symbol_address_p): Likewise.
	(elf32_h8_get_relocated_section_contents): Likewise.
	* elf32-hppa.c (elf32_hppa_size_stubs): Read symbol shndx
	extension, and use with swap_symbol_in.
	* elf64-hppa.c (elf64_hppa_check_relocs): Likewise.
	* elf32-i370.c (i370_elf_finish_dynamic_sections): Adjust call to
	bfd_elf32_swap_symbol_out.
	* elf32-m32r.c (m32r_elf_get_relocated_section_contents): Translate
	elf sections > SHN_HIRESERVE too.
	* elf32-m68k.c (bfd_m68k_elf32_create_embedded_relocs): Only read
	local syms.  Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-mips.c (_bfd_mips_elf_final_write_processing): Use
	elf_numsections rather than header e_shnum.
	* elf32-sh.c (sh_elf_relax_section): As for elf-m10300.c.
	(sh_elf_relax_delete_bytes): Likewise.
	(sh_elf_get_relocated_section_contents): Likewise.  Only read local
	symbols.
	* elf32-v850.c (v850_elf_symbol_processing): Use an unsigned int to
	hold section index.  Use elf_numsections rather than e_shnum.
	Rename "index" -> "indx" to avoid shadowing warning.
	(v850_elf_add_symbol_hook): Likewise.
	* elf64-alpha.c (elf64_alpha_relax_section): Only read local syms.
	Read symbol shndx extension, and use with swap_symbol_in.
	* elf32-xstormy16.c (xstormy16_elf_relax_section): Likewise.
	Translate SHN_COMMON and elf sections > SHN_HIRESERVE too.
	* elfxx-ia64.c (elfNN_ia64_relax_section): Likewise.
	(elfNN_ia64_aix_add_symbol_hook): Use elf_numsections.

	* elf-m10300.c (mn10300_elf_gc_mark_hook): Remove unnecessary checks
	before calling bfd_section_from_elf_index on local syms.
	* elf32-arm.h (elf32_arm_gc_mark_hook): Likewise.
	* elf32-avr.c (elf32_avr_gc_mark_hook): Likewise.
	* elf32-cris.c (cris_elf_gc_mark_hook): Likewise.
	* elf32-d10v.c (elf32_d10v_gc_mark_hook): Likewise.
	* elf32-fr30.c (fr30_elf_gc_mark_hook): Likewise.
	* elf32-hppa.c (elf32_hppa_gc_mark_hook): Likewise.
	* elf32-i386.c (elf_i386_gc_mark_hook): Likewise.
	* elf32-m32r.c (m32r_elf_gc_mark_hook): Likewise.
	* elf32-m68k.c (elf_m68k_gc_mark_hook): Likewise.
	* elf32-mcore.c (mcore_elf_gc_mark_hook): Likewise.
	* elf32-mips.c (_bfd_mips_elf_gc_mark_hook): Likewise.
	* elf32-openrisc.c (openrisc_elf_gc_mark_hook): Likewise.
	* elf32-ppc.c (ppc_elf_gc_mark_hook): Likewise.
	* elf32-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf32-sh.c (sh_elf_gc_mark_hook): Likewise.
	* elf32-sparc.c (elf32_sparc_gc_mark_hook): Likewise.
	* elf32-v850.c (v850_elf_gc_mark_hook): Likewise.
	* elf32-xstormy16.c (xstormy16_elf_gc_mark_hook): Likewise.
	* elf64-mips.c (mips_elf64_gc_mark_hook): Likewise.
	* elf64-mmix.c (mmix_elf_gc_mark_hook): Likewise.
	* elf64-ppc.c (ppc64_elf_gc_mark_hook): Likewise.
	* elf64-s390.c (elf_s390_gc_mark_hook): Likewise.
	* elf64-x86-64.c (elf64_x86_64_gc_mark_hook): Likewise.

binutils/ChangeLog
	* readelf.c (symtab_shndx_hdr): New global.
	(SECTION_HEADER_INDEX): Define.
	(SECTION_HEADER_NUM): Define.
	(SECTION_HEADER): Define.
	(GET_ELF_SYMBOLS): Pass two params rather than three.
	(get_32bit_elf_symbols): Take file and section args.  Read and
	use SHT_SYMTAB_SHNDX.
	(get_64bit_elf_symbols): Likewise.
	(dump_relocations): Use SECTION_HEADER to index "section_headers".
	(process_section_headers): Likewise.  Use SECTION_HEADER_NUM too.
	Remember symtab_shdx_hdr.
	(process_program_headers): Scan from index 1 for segment map.
	(slurp_ia64_unwind_table): Use SECTION_HEADER to index
	"section_headers".
	(process_relocs): Likewise.  Also adjust call to GET_ELF_SYMBOLS.
	(process_unwind): Likewise.
	(process_version_sections): Likewise.
	(process_symbol_table): Likewise.
	(display_debug_info): Likewise.
	(process_dynamic_segment): Fake up a symtab section for changed
	GET_ELF_SYMBOLS.
	(get_symbol_index_type): Check SHN_LOOS before SHN_LORESERVE.
	(process_program_headers): Kill signed/unsigned warning.
	(load_debug_str): Likewise.
	(display_debug_info): Likewise.
@
text
@d1650 3
a1655 21
	  if ((e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_1)
	    strcat (buf, ", mips1");

	  if ((e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_2)
	    strcat (buf, ", mips2");

	  if ((e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_3)
	    strcat (buf, ", mips3");

	  if ((e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_4)
	    strcat (buf, ", mips4");

	  if ((e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_5)
	    strcat (buf, ", mips5");

	  if ((e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_32)
	    strcat (buf, ", mips32");

	  if ((e_flags & EF_MIPS_ARCH) == E_MIPS_ARCH_64)
	    strcat (buf, ", mips64");

d1664 6
a1669 1
	    default: strcat (buf, " UNKNOWN"); break;
d1671 34
@


1.139
log
@	* elf-bfd.h (enum elf_link_info_type): New.
	(struct bfd_elf_section_data): Remove stab_info and merge_info
	fields, add sec_info and sec_info_type.
	(struct elf_obj_tdata): Add eh_frame_hdr field.
	(_bfd_elf_discard_section_eh_frame): New prototype.
	(_bfd_elf_discard_section_eh_frame_hdr): Likewise.
	(_bfd_elf_eh_frame_section_offset): Likewise.
	(_bfd_elf_write_section_eh_frame): Likewise.
	(_bfd_elf_write_section_eh_frame_hdr): Likewise.
	* Makefile.am (BFD32_BACKENDS): Add elf-eh-frame.lo.
	(BFD32_BACKENDS_CFILES): Add elf-eh-frame.c.
	(elf-eh-frame.lo): New.
	* Makefile.in: Rebuilt.
	* configure.in (elf): Add elf-eh-frame.lo.
	* configure: Rebuilt.
	* elf.c (_bfd_elf_print_private_bfd_data): Support PT_GNU_EH_FRAME.
	(map_sections_to_segments): Create PT_GNU_EH_FRAME if requested.
	(get_program_header_size): Take into account PT_GNU_EH_FRAME
	segment.
	(_bfd_elf_rela_local_sym): Use sec_info_type and sec_info.
	(_bfd_elf_rel_local_sym): Likewise.
	(_bfd_elf_section_offset): Likewise.  Call
	_bfd_elf_eh_frame_section_offset too.
	* elfxx-ia64.c (elfNN_ia64_relocate_section): Use sec_info_type and
	sec_info.
	* elf64-alpha.c (elf64_alpha_relocate_section): Likewise.
	* elf-eh-frame.c: New file.
	* elflink.h (elf_link_add_object_symbols): Don't optimize SHF_MERGE
	.stab sections.  Set sec_info_type, use sec_info instead
	of merge_info and stab_info.
	(elf_link_create_dynamic_sections): Create .eh_frame_hdr section
	if --eh-frame-hdr.
	(elf_bfd_final_link): Write .eh_frame_hdr section.
	(elf_link_sec_merge_syms): Use sec_info_type and sec_info.
	(elf_link_input_bfd): Likewise.
	Call _bfd_elf_write_section_eh_frame to write .eh_frame sections.
	(elf_bfd_discard_info): Add output_bfd argument.
	Call _bfd_elf_discard_section_eh_frame and
	_bfd_elf_discard_section_eh_frame_hdr.
	(elf_section_ignore_discarded_relocs): Use sec_info_type, not section
	names.
	* bfd-in.h (bfd_elf32_discard_info, bfd_elf64_discard_info): Adjust
	prototypes.
	* bfd-in2.h (bfd_elf32_discard_info, bfd_elf64_discard_info): Likewise.

	* elf/common.h (PT_GNU_EH_FRAME): Define.
	* bfdlink.h (struct bfd_link_info): Add eh_frame_hdr field.

	* emultempl/elf32.em (finish): Supply output_bfd
	to bfd_elf*_discard_info.
	(OPTION_EH_FRAME_HDR): Define.
	(longopts): Add --eh-frame-hdr.
	(parse_args): Handle it.
	(list_options): Add --eh-frame-hdr to help.
	* emultempl/hppaelf.em (finish): Supply output_bfd
	to bfd_elf*_discard_info.
	* scripttempl/elf.sc (.eh_frame_hdr): Add.

	* readelf.c (get_segment_type): Support PT_GNU_EH_FRAME.
@
text
@d105 1
d206 2
a207 2
static Elf_Internal_Sym * get_32bit_elf_symbols       PARAMS ((FILE *, unsigned long, unsigned long));
static Elf_Internal_Sym * get_64bit_elf_symbols       PARAMS ((FILE *, unsigned long, unsigned long));
d268 16
d304 3
a306 3
#define GET_ELF_SYMBOLS(file, offset, size)			\
  (is_32bit_elf ? get_32bit_elf_symbols (file, offset, size)	\
   : get_64bit_elf_symbols (file, offset, size))
d1062 1
a1062 1
			SECTION_NAME (section_headers + psym->st_shndx));
d2765 1
a2765 1
	  int                 j;
d2773 1
a2773 1
	  for (j = 0; j < elf_header.e_shnum; j++, section ++)
d2891 1
a2891 1
get_32bit_elf_symbols (file, offset, number)
d2893 1
a2893 2
     unsigned long offset;
     unsigned long number;
d2895 1
d2897 1
d2903 2
a2904 2
	   get_data (NULL, file, offset,
		     number * sizeof (Elf32_External_Sym), _("symbols")));
d2908 16
d2929 2
a2931 1

d2943 3
d2950 2
d2958 1
a2958 1
get_64bit_elf_symbols (file, offset, number)
d2960 1
a2960 2
     unsigned long offset;
     unsigned long number;
d2962 1
d2964 1
d2970 2
a2971 2
	   get_data (NULL, file, offset,
		     number * sizeof (Elf64_External_Sym), _("symbols")));
d2975 16
d2996 2
a2998 1

d3010 3
d3017 2
d3076 1
a3076 1
  int                 i;
d3101 1
a3101 1
  section = section_headers + elf_header.e_shstrndx;
d3132 1
a3132 2
	  dynamic_symbols =
	    GET_ELF_SYMBOLS (file, section->sh_offset, num_dynamic_syms);
d3147 9
d3204 2
a3205 2
      printf ("  [%2d] %-17.17s %-15.15s ",
	      i,
d3404 1
a3404 1
		  symsec = section_headers + section->sh_link;
d3406 1
a3406 1
		  symtab = GET_ELF_SYMBOLS (file, symsec->sh_offset, nsyms);
d3411 1
a3411 1
		  strsec = section_headers + symsec->sh_link;
d3663 1
a3663 1
	  || section_headers + relsec->sh_info != sec)
d3757 1
a3757 1
	  aux.symtab = GET_ELF_SYMBOLS (file, sec->sh_offset, aux.nsyms);
d3759 1
a3759 1
	  strsec = section_headers + sec->sh_link;
d4139 1
a4139 1
	  unsigned long        offset;
d4150 1
a4150 1
	  offset = entry->d_un.d_val - loadaddr;
d4155 1
d4157 1
a4157 1
	    num_dynamic_syms = (ftell (file) - offset) / sizeof (Elf32_External_Sym);
d4159 1
a4159 1
	    num_dynamic_syms = (ftell (file) - offset) / sizeof (Elf64_External_Sym);
d4161 1
d4168 1
a4168 1
	  dynamic_symbols = GET_ELF_SYMBOLS (file, offset, num_dynamic_syms);
d4689 1
a4689 1
		    SECTION_NAME (section_headers + section->sh_link));
d4780 1
a4780 1
		    SECTION_NAME (section_headers + section->sh_link));
d4862 1
a4862 1
	    link_section = section_headers + section->sh_link;
d4867 1
a4867 2
	    symbols = GET_ELF_SYMBOLS (file, link_section->sh_offset,
				       link_section->sh_size / link_section->sh_entsize);
d4869 1
a4869 1
	    string_sec = section_headers + link_section->sh_link;
d4930 1
a4930 2
		      if (symbols [cnt + j].st_shndx >= SHN_LORESERVE
			  || section_headers[symbols [cnt + j].st_shndx].sh_type
d5156 2
a5159 2
      else if (type >= SHN_LOOS && type <= SHN_HIOS)
	return "OS ";
d5318 1
a5318 2
	  symtab = GET_ELF_SYMBOLS (file, section->sh_offset,
				    section->sh_size / section->sh_entsize);
d5328 1
a5328 1
	      string_sec = section_headers + section->sh_link;
d5366 2
a5367 3
		  is_nobits = psym->st_shndx < SHN_LORESERVE ?
		    (section_headers [psym->st_shndx].sh_type == SHT_NOBITS)
		    : 0;
d7048 1
a7048 1
  int                   i;
d7486 1
a7486 1
      int                        i;
d7509 1
a7509 1
	  unsigned long nrelas, nsyms;
d7516 1
a7516 1
	      || section_headers + relsec->sh_info != section)
d7523 2
a7524 3
	  symsec = section_headers + relsec->sh_link;
	  nsyms = symsec->sh_size / symsec->sh_entsize;
	  symtab = GET_ELF_SYMBOLS (file, symsec->sh_offset, nsyms);
@


1.138
log
@	* readelf.c (process_file_header): Print extended e_shnum and
	e_shdtrndx values.  Set elf_header values for same.
	(get_32bit_section_headers): Add "num" arg to read "num" headers.
	(get_64bit_section_headers): Likewise.
	(process_section_headers): Update calls.
	(get_file_header): Call get_32bit_section_headers or 64bit variant.
@
text
@d1830 3
@


1.137
log
@Index: bfd/ChangeLog
2001-12-07  Geoffrey Keating  <geoffk@@redhat.com>
	    Richard Henderson  <rth@@redhat.com>
	    Corinna Vinschen  <vinschen@@redhat.com>

	* Makefile.am: Add support for xstormy16.
	* archures.c: Add support for xstormy16.
	* config.bfd: Add support for xstormy16.
	* configure.in: Add support for xstormy16.
	* reloc.c: Add support for xstormy16.
	* targets.c: Add support for xstormy16.
	* cpu-xstormy16.c: New file.
	* elf32-xstormy16.c: New file.
	* Makefile.in: Regenerated.
	* bfd-in2.h: Regenerated.
	* configure: Regenerated.
	* libbfd.h: Regenerated.

Index: binutils/ChangeLog
2001-12-07  Geoffrey Keating  <geoffk@@redhat.com>

	* readelf.c (guess_is_rela): Add support for stormy16.
	(dump_relocations): Likewise.
	(get_machine_name): Likewise.

Index: gas/ChangeLog
2001-12-07  Geoffrey Keating  <geoffk@@redhat.com>
	    Richard Henderson  <rth@@redhat.com>

	* configure.in: Add support for xstormy16.
	* configure: Regenerated.
	* Makefile.am: Add support for xstormy16.
	* Makefile.in: Regenerated.
	* config/tc-xstormy16.c: New file.
	* config/tc-xstormy16.h: New file.

Index: gas/testsuite/ChangeLog
2001-12-07  Geoffrey Keating  <geoffk@@redhat.com>
	    matthew green  <mrg@@redhat.com>

	* gas/xstormy16/allinsn.d: New file.
	* gas/xstormy16/allinsn.exp: New file.
	* gas/xstormy16/allinsn.s: New file.
	* gas/xstormy16/allinsn.sh: New file.
	* gas/xstormy16/gcc.d: New file.
	* gas/xstormy16/gcc.s: New file.
	* gas/xstormy16/gcc.sh: New file.
	* gas/xstormy16/reloc-1.d: New file.
	* gas/xstormy16/reloc-1.s: New file.
	* gas/xstormy16/reloc-2.d: New file.
	* gas/xstormy16/reloc-2.s: New file.

Index: ld/ChangeLog
2001-12-07  Geoffrey Keating  <geoffk@@redhat.com>
	    Richard Henderson  <rth@@redhat.com>

	* Makefile.am: Add support for xstormy16.
	* configure.tgt: Add support for xstormy16.
	* Makefile.in: Regenerate.
	* emulparams/elf32xstormy16.sh: New file.
	* scripttempl/xstormy16.sc: New file.

Index: opcodes/ChangeLog
2001-12-07  Geoffrey Keating  <geoffk@@redhat.com>

	* Makefile.am: Add support for xstormy16.
	* Makefile.in: Regenerate.
	* configure.in: Add support for xstormy16.
	* configure: Regenerate.
	* disassemble.c: Add support for xstormy16.
	* xstormy16-asm.c: New generated file.
	* xstormy16-desc.c: New generated file.
	* xstormy16-desc.h: New generated file.
	* xstormy16-dis.c: New generated file.
	* xstormy16-ibld.c: New generated file.
	* xstormy16-opc.c: New generated file.
	* xstormy16-opc.h: New generated file.

Index: include/ChangeLog
2001-12-07  Geoffrey Keating  <geoffk@@redhat.com>

	* dis-asm.h (print_insn_xstormy16): Declare.

Index: include/elf/ChangeLog
2001-12-07  Geoffrey Keating  <geoffk@@redhat.com>
	    Richard Henderson  <rth@@redhat.com>

	* common.h (EM_XSTORMY16): Define.
	* xstormy16.h: New file.
@
text
@d200 2
a201 2
static int                get_32bit_section_headers   PARAMS ((FILE *));
static int                get_64bit_section_headers   PARAMS ((FILE *));
d2445 1
a2445 1
      printf (_("  Number of section headers:         %ld\n"),
d2447 4
a2450 1
      printf (_("  Section header string table index: %ld\n"),
d2452 13
d2779 1
a2779 1
get_32bit_section_headers (file)
d2781 1
d2789 1
a2789 1
		     elf_header.e_shentsize * elf_header.e_shnum,
d2794 2
a2795 2
  section_headers = (Elf_Internal_Shdr *) malloc
    (elf_header.e_shnum * sizeof (Elf_Internal_Shdr));
d2804 1
a2804 1
       i < elf_header.e_shnum;
d2825 1
a2825 1
get_64bit_section_headers (file)
d2827 1
d2835 1
a2835 1
		     elf_header.e_shentsize * elf_header.e_shnum,
d2840 2
a2841 2
  section_headers = (Elf_Internal_Shdr *) malloc
    (elf_header.e_shnum * sizeof (Elf_Internal_Shdr));
d2850 1
a2850 1
       i < elf_header.e_shnum;
d3028 1
a3028 1
      if (! get_32bit_section_headers (file))
d3031 1
a3031 1
  else if (! get_64bit_section_headers (file))
d9206 7
@


1.136
log
@Fixes to improve the ability to translate messages in the binutils tools
@
text
@d80 1
d599 1
d1014 4
d1405 1
@


1.135
log
@Add -ws switch to display contents of .debug_str sections
@
text
@d2321 2
a2322 2
    case ELFCLASS32:   return _("ELF32");
    case ELFCLASS64:   return _("ELF64");
d2354 12
a2365 12
    case ELFOSABI_NONE:       return _("UNIX - System V");
    case ELFOSABI_HPUX:       return _("UNIX - HP-UX");
    case ELFOSABI_NETBSD:     return _("UNIX - NetBSD");
    case ELFOSABI_LINUX:      return _("UNIX - Linux");
    case ELFOSABI_HURD:       return _("GNU/Hurd");
    case ELFOSABI_SOLARIS:    return _("UNIX - Solaris");
    case ELFOSABI_AIX:        return _("UNIX - AIX");
    case ELFOSABI_IRIX:       return _("UNIX - IRIX");
    case ELFOSABI_FREEBSD:    return _("UNIX - FreeBSD");
    case ELFOSABI_TRU64:      return _("UNIX - TRU64");
    case ELFOSABI_MODESTO:    return _("Novell - Modesto");
    case ELFOSABI_OPENBSD:    return _("UNIX - OpenBSD");
d2367 1
a2367 1
    case ELFOSABI_ARM:        return _("ARM");
d2709 1
a2709 1
      /* Very strange. */
d3021 1
a3021 1
     and dynamic string table and debug sections. */
d3193 4
a3196 4
  printf (_("Key to Flags:\n"));
  printf (_("  W (write), A (alloc), X (execute), M (merge), S (strings)\n"));
  printf (_("  I (info), L (link order), G (group), x (unknown)\n"));
  printf (_("  O (extra OS processing required) o (OS specific), p (processor specific)\n"));
d4050 1
a4050 1
	     should work. */
d4089 1
a4089 1
	     should work. */
d5110 1
a5110 1
/* Dump the symbol table */
d7193 1
a7193 1
      /* handled above */
d8936 1
a8936 1
   If the value of namesz is zero, there is no name present. */
d9159 2
a9160 2
	  error (_("This instance of readelf has been built without support for a\n"));
	  error (_("64 bit data type and so it cannot read 64 bit ELF files.\n"));
d9292 1
a9292 1
   symbols */
d9300 1
a9300 1
/* Needed by the i386 disassembler. */
@


1.134
log
@	* readelf.c: Fix warnings without terminating newline.
@
text
@d126 1
d224 1
d226 3
d284 1
a284 1
#define NUM_ELEM(array)	(sizeof (array) / sizeof ((array)[0]))
d2080 1
a2080 1
  fprintf (stdout, _("  -w[liaprmf] or --debug-dump[=line,=info,=abbrev,=pubnames,=ranges,=macro,=frames]\n"));
d2260 5
d3059 1
a3059 1
		|| do_debug_frames || do_debug_macinfo)
d3072 1
a4104 1

d4753 6
a4758 6
	    int		total;
	    int		cnt;
	    unsigned char *		edata;
	    unsigned short *		data;
	    char *		strtab;
	    Elf_Internal_Sym *		symbols;
a6319 3
static const char *debug_str;
static bfd_vma debug_str_size;

d6943 117
d7188 2
a7189 7
      if (debug_str == NULL)
	warn (_("DW_FORM_strp used but no .debug_str section\n"));
      else if (uvalue >= debug_str_size)
	warn (_("DW_FORM_strp %lx points outside of .debug_str section\n"),
	      uvalue);
      else
        printf (" %s", debug_str + uvalue);
d7381 1
a7381 17
  {
    Elf32_Internal_Shdr * sec;
    int i;

    /* Locate the .debug_str section and read it.  */
    for (i = 0, sec = section_headers;
	 i < elf_header.e_shnum;
	 i ++, sec ++)
      if (strcmp (SECTION_NAME (sec), ".debug_str") == 0 && sec->sh_size != 0)
	{
	  debug_str = (const char *)
		      get_data (NULL, file, sec->sh_offset, sec->sh_size,
				_("debug_str section data"));
	  debug_str_size = sec->sh_size;
	  break;
	}
  }
d7484 1
a7484 2
      if (first_abbrev != NULL)
	free_abbrevs ();
d7566 1
a7566 5
  if (debug_str != NULL)
    {
      free ((char *) debug_str);
      debug_str = NULL;
    }
d8363 1
a8363 1
  char * name;
d8369 3
a8372 1
  { ".debug_abbrev",      display_debug_abbrev, NULL },
a8373 1
  { ".debug_aranges",     display_debug_aranges, NULL },
a8374 1
  { ".debug_frame",       display_debug_frames, NULL },
d8377 2
d8380 1
a8380 1
  { ".debug_str",         display_debug_not_supported, NULL },
d8427 1
a8427 2
  if (first_abbrev != NULL)
    free_abbrevs ();
@


1.133
log
@        * readelf.c (read_and_display_attr_value): New function to
        handle DW_FORM_indirect.
        (read_and_display_attr): Use it.
@
text
@d3569 1
a3569 1
		  warn (_("Skipping unexpected symbol type %u"),
d3581 1
a3581 1
		  warn (_("Skipping unexpected symbol type %u"),
d3589 1
a3589 1
	      warn (_("Skipping unexpected relocation type %s"), relname);
d5702 1
a5702 1
      warn (_("badly formed extended line op encountered!"));
d7065 1
a7065 1
	warn (_("DW_FORM_strp used but no .debug_str section"));
d7067 1
a7067 1
	warn (_("DW_FORM_strp %lx points outside of .debug_str section"),
d7078 1
a7078 1
      warn (_("Unrecognised form: %d"), form);
d7340 1
a7340 1
		      warn (_("Skipping unexpected symbol type %u"),
d7351 1
a7351 1
		      warn (_("Skipping unexpected symbol type %u"),
@


1.132
log
@Index: bfd/ChangeLog
2001-11-11  Geoffrey Keating  <geoffk@@redhat.com>

	* dwarf2.c (decode_line_info): Properly deal with unknown standard
	opcodes.

Index: binutils/ChangeLog
2001-11-11  Geoffrey Keating  <geoffk@@redhat.com>

	* readelf.c (display_debug_lines): Deal with unknown standard
	opcodes.  Handle DW_LNS_set_prologue_end, DW_LNS_set_epilogue_begin,
	DW_LNS_set_isa.

Index: include/elf/ChangeLog
2001-11-11  Geoffrey Keating  <geoffk@@redhat.com>

	* dwarf2.h (dwarf_line_number_ops): Add DWARF 3 opcodes.
@
text
@d234 1
d6937 1
a6937 1
read_and_display_attr (attribute, form, data, cu_offset, pointer_size)
a6947 2
  printf ("     %-18s:", get_AT_name (attribute));

d6992 7
d7074 1
a7074 1
      warn (_("Unable to handle FORM: %d"), form);
d7233 14
@


1.131
log
@
        * readelf.c (get_elf_class): Fix ISO portability glitch.
        (get_data_encoding, get_osabi_name, request_dump): Likewise.
@
text
@d5891 13
a5903 1
	  switch (op_code)
d5973 14
d5988 11
a5998 9
	      op_code -= info.li_opcode_base;
	      adv      = (op_code / info.li_line_range) * info.li_min_insn_length;
	      state_machine_regs.address += adv;
	      printf (_("  Special opcode %d: advance Address by %d to 0x%lx"),
		      op_code, adv, state_machine_regs.address);
	      adv = (op_code % info.li_line_range) + info.li_line_base;
	      state_machine_regs.line += adv;
	      printf (_(" and Line by %d to %d\n"),
		      adv, state_machine_regs.line);
d6002 1
a6002 1
      printf ("\n");
@


1.130
log
@	* readelf.c (debug_str, debug_str_size): New.
	(display_debug_abbrev): If no abbrevs were read, skip the CU.
	Call free_abbrevs.
	(read_and_display_addr): Handle DW_FORM_strp.
	(display_debug_info): Read .debug_str section if present,
	so that DW_FORM_strp can be handled.
	Fix test for non-existant .debug_abbrev section.
@
text
@d236 4
a239 4
static void		  request_dump                PARAMS ((unsigned int, char));
static const char *       get_elf_class               PARAMS ((unsigned char));
static const char *       get_data_encoding           PARAMS ((unsigned char));
static const char *       get_osabi_name              PARAMS ((unsigned char));
d2092 1
a2092 1
     char         type;
d2303 1
a2303 1
     unsigned char elf_class;
d2320 1
a2320 1
     unsigned char encoding;
d2337 1
a2337 1
     unsigned char osabi;
@


1.129
log
@Add MMIX support
@
text
@d6281 3
d6534 3
d6555 2
d6932 5
d7030 9
d7214 18
d7349 1
a7349 1
	if (i == -1 || sec->sh_size == 0)
d7414 6
@


1.128
log
@support multiple options to the -w switch
@
text
@d71 1
d591 1
d944 4
@


1.127
log
@	* readelf.c (get_section_type_name): Don't print SHT_ prefix for
	LOPROC, LOOS and LOUSER.
@
text
@d2205 2
a2207 6
	      switch (optarg[0])
		{
		case 'i':
		case 'I':
		  do_debug_info = 1;
		  break;
d2209 43
a2251 35
		case 'a':
		case 'A':
		  do_debug_abbrevs = 1;
		  break;

		case 'l':
		case 'L':
		  do_debug_lines = 1;
		  break;

		case 'p':
		case 'P':
		  do_debug_pubnames = 1;
		  break;

		case 'r':
		case 'R':
		  do_debug_aranges = 1;
		  break;

		case 'F':
		  do_debug_frames_interp = 1;
		case 'f':
		  do_debug_frames = 1;
		  break;

		case 'm':
		case 'M':
		  do_debug_macinfo = 1;
		  break;

		default:
		  warn (_("Unrecognised debug option '%s'\n"), optarg);
		  break;
		}
d7053 1
a7053 1
	case DW_LANG_Fortran95:       printf ("(Fortran 95)"); break;
@


1.126
log
@Add more detection of 64-bit DWARF sections
@
text
@d2002 1
a2002 1
	  sprintf (buff, "SHT_LOPROC+%x", sh_type - SHT_LOPROC);
d2005 1
a2005 1
	sprintf (buff, "SHT_LOOS+%x", sh_type - SHT_LOOS);
d2007 1
a2007 1
	sprintf (buff, "SHT_LOUSER+%x", sh_type - SHT_LOUSER);
@


1.125
log
@Detect and warn about DWARF64 format .debug_arange sections
@
text
@d5764 7
d5999 6
d7199 6
d7400 1
a7400 1
	  warn (_("DWARF64 aranges not currently supported.\n"));
d7619 6
d7733 1
a7733 1
	  for (cie=chunks; cie ; cie = cie->next)
d8175 1
@


1.124
log
@	* bucomm.c (fatal): Define using VPARAMS, VA_OPEN, VA_FIXEDARG,
	VA_CLOSE.
	(non_fatal): Likewise.
	* objdump.c (objdump_sprintf): Likewise.
	* readelf.c (error): Likewise.
	(warn): Likewise.
@
text
@d7379 6
d9078 2
@


1.123
log
@	* readelf.c (do_wide): New.
	(options): Add --wide.
	(usage, parse_args): Likewise.
	(process_program_headers): Put each segment on a single line if
	--wide is given.
	(process_section_headers): Put each section on a single line if
	--wide is given.
	* doc/binutils.texi: Document it.
	* NEWS: Likewise.
@
text
@a283 1
#ifdef ANSI_PROTOTYPES
d285 1
a285 1
error (const char * message, ...)
d287 2
a288 1
  va_list args;
a290 1
  va_start (args, message);
d292 1
a292 2
  va_end (args);
  return;
d296 1
a296 1
warn (const char * message, ...)
d298 2
a299 1
  va_list args;
a301 1
  va_start (args, message);
d303 1
a303 2
  va_end (args);
  return;
a304 31
#else
static void
error (va_alist)
     va_dcl
{
  char * message;
  va_list args;

  fprintf (stderr, _("%s: Error: "), program_name);
  va_start (args);
  message = va_arg (args, char *);
  vfprintf (stderr, message, args);
  va_end (args);
  return;
}

static void
warn (va_alist)
     va_dcl
{
  char * message;
  va_list args;

  fprintf (stderr, _("%s: Warning: "), program_name);
  va_start (args);
  message = va_arg (args, char *);
  vfprintf (stderr, message, args);
  va_end (args);
  return;
}
#endif
@


1.122
log
@	* readelf.c (print_vma): Print 8 digits of low hex value.
@
text
@d114 1
d2075 1
d2110 1
d2159 1
a2159 1
	  (argc, argv, "ersuahnldSDAIw::x:i:vV", options, NULL)) != EOF)
d2301 3
d2587 3
d2624 42
d3104 3
d3138 42
d3184 7
a3190 1
	  printf ("  %8.8lx", (unsigned long) section->sh_offset);
@


1.121
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d476 1
a476 1
	    printf ("%lx%lx", _bfd_int64_high (vma), _bfd_int64_low (vma));
@


1.120
log
@	* ar.c (print_contents): Cast args of bfd_seek to the right types.
	Replace bfd_read call with call to bfd_bread.
	(extract_file): Likewise.

	* objdump.c (dump_section_header): Cast section->filepos to
	unsigned long to suit printf format string.
	* readelf.c (process_section_headers): Similarly for sh_offset.
	(process_unwind): Likewise.
@
text
@d9015 3
@


1.119
log
@* readelf.c (guess_is_rela, dump_relocations, get_machine_name,
get_machine_flags): Added EM_M32R, EM_D10V, EM_V850, EM_D30V,
EM_MN10200, EM_MN10300, EM_FR30, EM_AVR_OLD and EM_PJ_OLD.
Removed EM_CYGNUS_ARC.
@
text
@d3088 1
a3088 1
	  printf ("  %8.8lx", section->sh_offset);
d3653 1
a3653 1
		  unwsec->sh_offset,
@


1.118
log
@	* readelf.c: Include elf/h8 for H8 series definitions.
	(guess_is_rela): H8 series if RELA.
	(dump_relocations): Handle H8 series relocations.

	* testsuite/binutils/all/readelf.exp: Expect readelf -wi to
	fail for the H8 series.
@
text
@d585 1
d587 1
d602 1
d604 1
d606 1
d608 1
d610 1
d617 1
d909 1
d928 1
d939 1
d944 1
d949 1
d958 1
d963 1
d968 1
a994 1
	case EM_CYGNUS_ARC:
d1010 1
d1374 15
a1388 8
    case EM_CYGNUS_D10V:        return "d10v";
    case EM_CYGNUS_D30V:        return "d30v";
    case EM_CYGNUS_ARC:		return "ARC";
    case EM_CYGNUS_M32R:	return "Mitsubishi M32r";
    case EM_CYGNUS_V850:	return "NEC v850";
    case EM_CYGNUS_MN10300:	return "mn10300";
    case EM_CYGNUS_MN10200:	return "mn10200";
    case EM_CYGNUS_FR30:	return "Fujitsu FR30";
d1408 1
d1604 1
d1623 1
d1739 1
@


1.117
log
@2001-08-31  Eric Christopher  <echristo@@redhat.com>
	    Jason Eckhardt    <jle@@redhat.com>

	* mips-dis.c: Add support for bfd_mach_mipsisa32 and
	bfd_mach_mipsisa64. Remove bfd_mach_mips32, bfd_mach_mips32_4k,
	bfd_mach_mips64.
@
text
@d67 1
d593 3
d986 6
@


1.116
log
@	* readelf.c (dump_relocations): Recognise EM_PPC64.
@
text
@a1641 1
	    case E_MIPS_MACH_MIPS32_4K: strcat (buf, ", mips32-4k"); break;
d6386 1
a6386 1
  
d7111 1
a7111 1
	      
d7182 1
a7182 1
		 get_data (NULL, file, sec->sh_offset, sec->sh_size, 
d8063 1
a8063 1
  start = (unsigned char *) get_data (NULL, file, section->sh_offset, length, 
d8126 1
a8126 1
			 get_data (NULL, file, section->sh_offset, length, 
@


1.115
log
@	* readelf.c (get_machine_flags): Add detection of EF_MIPS_32BITMODE.
@
text
@d958 1
@


1.114
log
@	* readelf.c (get_machine_flags): Add detection of EF_MIPS_UCODE.
@
text
@d1610 3
@


1.113
log
@2001-08-21  H.J. Lu  <hjl@@gnu.org>

	* readelf.c (dump_relocations): Support ELF64 on 32bit hosts.
	(display_debug_info): Cast for 64bit hosts.
	(display_debug_frames): Likewise.
	(process_mips_specific): Likewise.
@
text
@d1604 3
@


1.112
log
@	* readelf.c: Add missing prototypes.
	* objdump.c: Likewise.  Format existing prototypes.
@
text
@d813 9
a821 3
  if (is_rela)
    printf
      (_("  Offset    Info  Type            Symbol's Value  Symbol's Name          Addend\n"));
d823 8
a830 2
    printf
      (_("  Offset    Info  Type            Symbol's Value  Symbol's Name\n"));
d870 10
d881 5
a885 1
      printf ("  %8.8lx  %5.5lx ", _bfd_int64_low (offset), _bfd_int64_low (info));
d887 1
a887 1
      printf ("  %8.8lx  %5.5lx ", offset, info);
d889 1
d7219 3
a7221 2
	  printf (_(" <%d><%x>: Abbrev Number: %lu (%s)\n"),
		  level, tags - section_begin - bytes_read,
d7640 1
a7640 1
	  printf ("\n%08lx %08lx %08lx FDE cie=%08x pc=%08lx..%08lx\n",
d7642 2
a7643 2
		  cie->chunk_start - section_start, fc->pc_begin,
		  fc->pc_begin + fc->pc_range);
d8542 2
a8543 1
      printf (_("\nSection '.conflict' contains %d entries:\n"), conflictsno);
@


1.111
log
@* readelf.c (display_debug_info): Add to abbrev_offset the addend
of any RELA relocation for the abbrev_offset memory location that
refers to the .debug_abbrev section symbol.
@
text
@d187 1
d189 2
d213 1
d215 1
d243 1
d7309 4
@


1.110
log
@2001-08-07  H.J. Lu  <hjl@@gnu.org>

	* readelf.c (process_file): Return 0 if OK, otherwise return 1.
	(main): Return process_file ().
@
text
@d7029 1
d7041 62
@


1.109
log
@Display the contents of a .debug.macinfo section
@
text
@d188 1
a188 1
static void               process_file                PARAMS ((char *));
d8737 1
a8737 1
static void
d8748 1
a8748 1
      return;
d8755 1
a8755 1
      return;
d8762 1
a8762 1
      return;
d8779 1
a8779 1
      return;
d8837 2
d8865 2
d8878 1
d8880 1
a8880 1
    process_file (argv [optind ++]);
d8885 1
a8885 1
  return 0;
@


1.108
log
@Support DWARF 2.1 tags, encodings, languages.
@
text
@d122 1
d214 1
d2024 1
a2024 1
  fprintf (stdout, _("  -w[liaprf] or --debug-dump[=line,=info,=abbrev,=pubnames,=ranges,=frames]\n"));
d2194 5
d2945 1
a2945 1
		|| do_debug_frames)
d2957 1
d6276 74
d7931 1
a7931 1
  { ".debug_macinfo",     display_debug_not_supported, NULL },
@


1.107
log
@Add DWARF 2.1 attributes
@
text
@d5888 18
a5905 18
    case DW_TAG_padding: return "DW_TAG_padding";
    case DW_TAG_array_type: return "DW_TAG_array_type";
    case DW_TAG_class_type: return "DW_TAG_class_type";
    case DW_TAG_entry_point: return "DW_TAG_entry_point";
    case DW_TAG_enumeration_type: return "DW_TAG_enumeration_type";
    case DW_TAG_formal_parameter: return "DW_TAG_formal_parameter";
    case DW_TAG_imported_declaration: return "DW_TAG_imported_declaration";
    case DW_TAG_label: return "DW_TAG_label";
    case DW_TAG_lexical_block: return "DW_TAG_lexical_block";
    case DW_TAG_member: return "DW_TAG_member";
    case DW_TAG_pointer_type: return "DW_TAG_pointer_type";
    case DW_TAG_reference_type: return "DW_TAG_reference_type";
    case DW_TAG_compile_unit: return "DW_TAG_compile_unit";
    case DW_TAG_string_type: return "DW_TAG_string_type";
    case DW_TAG_structure_type: return "DW_TAG_structure_type";
    case DW_TAG_subroutine_type: return "DW_TAG_subroutine_type";
    case DW_TAG_typedef: return "DW_TAG_typedef";
    case DW_TAG_union_type: return "DW_TAG_union_type";
d5907 42
a5948 33
    case DW_TAG_variant: return "DW_TAG_variant";
    case DW_TAG_common_block: return "DW_TAG_common_block";
    case DW_TAG_common_inclusion: return "DW_TAG_common_inclusion";
    case DW_TAG_inheritance: return "DW_TAG_inheritance";
    case DW_TAG_inlined_subroutine: return "DW_TAG_inlined_subroutine";
    case DW_TAG_module: return "DW_TAG_module";
    case DW_TAG_ptr_to_member_type: return "DW_TAG_ptr_to_member_type";
    case DW_TAG_set_type: return "DW_TAG_set_type";
    case DW_TAG_subrange_type: return "DW_TAG_subrange_type";
    case DW_TAG_with_stmt: return "DW_TAG_with_stmt";
    case DW_TAG_access_declaration: return "DW_TAG_access_declaration";
    case DW_TAG_base_type: return "DW_TAG_base_type";
    case DW_TAG_catch_block: return "DW_TAG_catch_block";
    case DW_TAG_const_type: return "DW_TAG_const_type";
    case DW_TAG_constant: return "DW_TAG_constant";
    case DW_TAG_enumerator: return "DW_TAG_enumerator";
    case DW_TAG_file_type: return "DW_TAG_file_type";
    case DW_TAG_friend: return "DW_TAG_friend";
    case DW_TAG_namelist: return "DW_TAG_namelist";
    case DW_TAG_namelist_item: return "DW_TAG_namelist_item";
    case DW_TAG_packed_type: return "DW_TAG_packed_type";
    case DW_TAG_subprogram: return "DW_TAG_subprogram";
    case DW_TAG_template_type_param: return "DW_TAG_template_type_param";
    case DW_TAG_template_value_param: return "DW_TAG_template_value_param";
    case DW_TAG_thrown_type: return "DW_TAG_thrown_type";
    case DW_TAG_try_block: return "DW_TAG_try_block";
    case DW_TAG_variant_part: return "DW_TAG_variant_part";
    case DW_TAG_variable: return "DW_TAG_variable";
    case DW_TAG_volatile_type: return "DW_TAG_volatile_type";
    case DW_TAG_MIPS_loop: return "DW_TAG_MIPS_loop";
    case DW_TAG_format_label: return "DW_TAG_format_label";
    case DW_TAG_function_template: return "DW_TAG_function_template";
    case DW_TAG_class_template: return "DW_TAG_class_template";
d5965 40
a6004 40
    case DW_AT_sibling: return "DW_AT_sibling";
    case DW_AT_location: return "DW_AT_location";
    case DW_AT_name: return "DW_AT_name";
    case DW_AT_ordering: return "DW_AT_ordering";
    case DW_AT_subscr_data: return "DW_AT_subscr_data";
    case DW_AT_byte_size: return "DW_AT_byte_size";
    case DW_AT_bit_offset: return "DW_AT_bit_offset";
    case DW_AT_bit_size: return "DW_AT_bit_size";
    case DW_AT_element_list: return "DW_AT_element_list";
    case DW_AT_stmt_list: return "DW_AT_stmt_list";
    case DW_AT_low_pc: return "DW_AT_low_pc";
    case DW_AT_high_pc: return "DW_AT_high_pc";
    case DW_AT_language: return "DW_AT_language";
    case DW_AT_member: return "DW_AT_member";
    case DW_AT_discr: return "DW_AT_discr";
    case DW_AT_discr_value: return "DW_AT_discr_value";
    case DW_AT_visibility: return "DW_AT_visibility";
    case DW_AT_import: return "DW_AT_import";
    case DW_AT_string_length: return "DW_AT_string_length";
    case DW_AT_common_reference: return "DW_AT_common_reference";
    case DW_AT_comp_dir: return "DW_AT_comp_dir";
    case DW_AT_const_value: return "DW_AT_const_value";
    case DW_AT_containing_type: return "DW_AT_containing_type";
    case DW_AT_default_value: return "DW_AT_default_value";
    case DW_AT_inline: return "DW_AT_inline";
    case DW_AT_is_optional: return "DW_AT_is_optional";
    case DW_AT_lower_bound: return "DW_AT_lower_bound";
    case DW_AT_producer: return "DW_AT_producer";
    case DW_AT_prototyped: return "DW_AT_prototyped";
    case DW_AT_return_addr: return "DW_AT_return_addr";
    case DW_AT_start_scope: return "DW_AT_start_scope";
    case DW_AT_stride_size: return "DW_AT_stride_size";
    case DW_AT_upper_bound: return "DW_AT_upper_bound";
    case DW_AT_abstract_origin: return "DW_AT_abstract_origin";
    case DW_AT_accessibility: return "DW_AT_accessibility";
    case DW_AT_address_class: return "DW_AT_address_class";
    case DW_AT_artificial: return "DW_AT_artificial";
    case DW_AT_base_types: return "DW_AT_base_types";
    case DW_AT_calling_convention: return "DW_AT_calling_convention";
    case DW_AT_count: return "DW_AT_count";
d6006 20
a6025 20
    case DW_AT_decl_column: return "DW_AT_decl_column";
    case DW_AT_decl_file: return "DW_AT_decl_file";
    case DW_AT_decl_line: return "DW_AT_decl_line";
    case DW_AT_declaration: return "DW_AT_declaration";
    case DW_AT_discr_list: return "DW_AT_discr_list";
    case DW_AT_encoding: return "DW_AT_encoding";
    case DW_AT_external: return "DW_AT_external";
    case DW_AT_frame_base: return "DW_AT_frame_base";
    case DW_AT_friend: return "DW_AT_friend";
    case DW_AT_identifier_case: return "DW_AT_identifier_case";
    case DW_AT_macro_info: return "DW_AT_macro_info";
    case DW_AT_namelist_items: return "DW_AT_namelist_items";
    case DW_AT_priority: return "DW_AT_priority";
    case DW_AT_segment: return "DW_AT_segment";
    case DW_AT_specification: return "DW_AT_specification";
    case DW_AT_static_link: return "DW_AT_static_link";
    case DW_AT_type: return "DW_AT_type";
    case DW_AT_use_location: return "DW_AT_use_location";
    case DW_AT_variable_parameter: return "DW_AT_variable_parameter";
    case DW_AT_virtuality: return "DW_AT_virtuality";
d6028 12
a6039 12
    case DW_AT_allocated: return "DW_AT_allocated";
    case DW_AT_associated: return "DW_AT_associated";
    case DW_AT_data_location: return "DW_AT_data_location";
    case DW_AT_stride: return "DW_AT_stride";
    case DW_AT_entry_pc: return "DW_AT_entry_pc";
    case DW_AT_use_UTF8: return "DW_AT_use_UTF8";
    case DW_AT_extension: return "DW_AT_extension";
    case DW_AT_ranges: return "DW_AT_ranges";
    case DW_AT_trampoline: return "DW_AT_trampoline";
    case DW_AT_call_column: return "DW_AT_call_column";
    case DW_AT_call_file: return "DW_AT_call_file";
    case DW_AT_call_line: return "DW_AT_call_line";
d6041 2
a6042 2
    case DW_AT_MIPS_fde: return "DW_AT_MIPS_fde";
    case DW_AT_MIPS_loop_begin: return "DW_AT_MIPS_loop_begin";
d6044 1
a6044 1
    case DW_AT_MIPS_epilog_begin: return "DW_AT_MIPS_epilog_begin";
d6047 5
a6051 5
    case DW_AT_MIPS_linkage_name: return "DW_AT_MIPS_linkage_name";
    case DW_AT_MIPS_stride: return "DW_AT_MIPS_stride";
    case DW_AT_MIPS_abstract_name: return "DW_AT_MIPS_abstract_name";
    case DW_AT_MIPS_clone_origin: return "DW_AT_MIPS_clone_origin";
    case DW_AT_MIPS_has_inlines: return "DW_AT_MIPS_has_inlines";
d6053 6
a6058 6
    case DW_AT_sf_names: return "DW_AT_sf_names";
    case DW_AT_src_info: return "DW_AT_src_info";
    case DW_AT_mac_info: return "DW_AT_mac_info";
    case DW_AT_src_coords: return "DW_AT_src_coords";
    case DW_AT_body_begin: return "DW_AT_body_begin";
    case DW_AT_body_end: return "DW_AT_body_end";
d6075 19
a6093 19
    case DW_FORM_addr: return "DW_FORM_addr";
    case DW_FORM_block2: return "DW_FORM_block2";
    case DW_FORM_block4: return "DW_FORM_block4";
    case DW_FORM_data2: return "DW_FORM_data2";
    case DW_FORM_data4: return "DW_FORM_data4";
    case DW_FORM_data8: return "DW_FORM_data8";
    case DW_FORM_string: return "DW_FORM_string";
    case DW_FORM_block: return "DW_FORM_block";
    case DW_FORM_block1: return "DW_FORM_block1";
    case DW_FORM_data1: return "DW_FORM_data1";
    case DW_FORM_flag: return "DW_FORM_flag";
    case DW_FORM_sdata: return "DW_FORM_sdata";
    case DW_FORM_strp: return "DW_FORM_strp";
    case DW_FORM_udata: return "DW_FORM_udata";
    case DW_FORM_ref_addr: return "DW_FORM_ref_addr";
    case DW_FORM_ref1: return "DW_FORM_ref1";
    case DW_FORM_ref2: return "DW_FORM_ref2";
    case DW_FORM_ref4: return "DW_FORM_ref4";
    case DW_FORM_ref8: return "DW_FORM_ref8";
d6095 1
a6095 1
    case DW_FORM_indirect: return "DW_FORM_indirect";
d6807 5
d6829 2
@


1.106
log
@	* readelf.c (GET_DATA_ALLOC): Remove.
	(GET_DATA): Remove.
	(get_data): New function combining above macros, with an extra
	test for zero size.
	Use get_data, and catch error return throughout file.
@
text
@d5 1
a5 1
   Modifications by Nick Clifton <nickc@@cygnus.com>
d6018 14
d6043 1
d6609 16
d6634 3
d6881 9
d6894 6
@


1.105
log
@	* readelf.c (dump_relocations): Print "bad symbol index" if
	symtab == NULL with non-zero symtab_index.
	(process_relocs): Don't bomb if reloc section has no symsec.
@
text
@a268 36
#define GET_DATA_ALLOC(offset, size, var, type, reason)			\
  if (fseek (file, offset, SEEK_SET))					\
    {									\
      error (_("Unable to seek to start of %s at %x\n"), reason, offset); \
      return 0;								\
    }									\
									\
  var = (type) malloc (size);						\
									\
  if (var == NULL)							\
    {									\
      error (_("Out of memory allocating %d bytes for %s\n"), size, reason); \
      return 0;								\
    }									\
									\
  if (fread (var, size, 1, file) != 1)					\
    {									\
      error (_("Unable to read in %d bytes of %s\n"), size, reason);	\
      free (var);							\
      var = NULL;							\
      return 0;							\
    }


#define GET_DATA(offset, var, reason)					\
  if (fseek (file, offset, SEEK_SET))					\
    {									\
      error (_("Unable to seek to %x for %s\n"), offset, reason);	\
      return 0;								\
    }									\
  else if (fread (& var, sizeof (var), 1, file) != 1)			\
    {									\
      error (_("Unable to read data at %x for %s\n"), offset, reason);	\
      return 0;								\
    }

d330 45
d645 4
a648 2
      GET_DATA_ALLOC (rel_offset, rel_size, erelas,
		      Elf32_External_Rela *, "relocs");
d674 4
a677 2
      GET_DATA_ALLOC (rel_offset, rel_size, erelas,
		      Elf64_External_Rela *, "relocs");
d720 4
a723 2
      GET_DATA_ALLOC (rel_offset, rel_size, erels,
		      Elf32_External_Rel *, "relocs");
d747 4
a750 2
      GET_DATA_ALLOC (rel_offset, rel_size, erels,
		      Elf64_External_Rel *, "relocs");
d2382 6
a2387 3
  GET_DATA_ALLOC (elf_header.e_phoff,
		  elf_header.e_phentsize * elf_header.e_phnum,
		  phdrs, Elf32_External_Phdr *, "program headers");
d2418 6
a2423 3
  GET_DATA_ALLOC (elf_header.e_phoff,
		  elf_header.e_phentsize * elf_header.e_phnum,
		  phdrs, Elf64_External_Phdr *, "program headers");
d2642 6
a2647 3
  GET_DATA_ALLOC (elf_header.e_shoff,
		  elf_header.e_shentsize * elf_header.e_shnum,
		  shdrs, Elf32_External_Shdr *, "section headers");
d2687 6
a2692 3
  GET_DATA_ALLOC (elf_header.e_shoff,
		  elf_header.e_shentsize * elf_header.e_shnum,
		  shdrs, Elf64_External_Shdr *, "section headers");
d2735 5
a2739 2
  GET_DATA_ALLOC (offset, number * sizeof (Elf32_External_Sym),
		  esyms, Elf32_External_Sym *, "symbols");
d2779 5
a2783 2
  GET_DATA_ALLOC (offset, number * sizeof (Elf64_External_Sym),
		  esyms, Elf64_External_Sym *, "symbols");
d2893 2
a2894 2
      GET_DATA_ALLOC (section->sh_offset, section->sh_size,
		      string_table, char *, "string table");
d2932 3
a2934 2
	  GET_DATA_ALLOC (section->sh_offset, section->sh_size,
			  dynamic_strings, char *, "dynamic strings");
d3140 3
a3142 2
		  GET_DATA_ALLOC (strsec->sh_offset, strsec->sh_size, strtab,
				  char *, "string table");
d3354 4
a3357 1
  GET_DATA_ALLOC (sec->sh_offset, size, table, char *, "unwind table");
d3488 2
a3489 2
	  GET_DATA_ALLOC (strsec->sh_offset, aux.strtab_size,
			  aux.strtab, char *, "string table");
d3558 2
a3559 2
	  GET_DATA_ALLOC (sec->sh_offset, aux.info_size, aux.info,
			  char *, "unwind info");
d3733 4
a3736 2
  GET_DATA_ALLOC (dynamic_addr, dynamic_size,
		  edyn, Elf32_External_Dyn *, "dynamic segment");
d3776 4
a3779 2
  GET_DATA_ALLOC (dynamic_addr, dynamic_size,
		  edyn, Elf64_External_Dyn *, "dynamic segment");
d3929 2
a3930 2
	  GET_DATA_ALLOC (offset, str_tab_len, dynamic_strings, char *,
			  "dynamic string table");
d3963 5
a3967 2
	  GET_DATA_ALLOC (dynamic_syminfo_offset, syminsz, extsyminfo,
			  Elf_External_Syminfo *, "symbol information");
d4417 6
a4422 3
	    GET_DATA_ALLOC (section->sh_offset, section->sh_size,
			    edefs, Elf_External_Verdef *,
			    "version definition section");
d4508 5
a4512 3
	    GET_DATA_ALLOC (section->sh_offset, section->sh_size,
			    eneed, Elf_External_Verneed *,
			    "version need section");
d4598 5
a4602 2
	    GET_DATA_ALLOC (string_sec->sh_offset, string_sec->sh_size,
			    strtab, char *, "version string table");
d4613 10
a4622 4
	    GET_DATA_ALLOC (version_info [DT_VERSIONTAGIDX (DT_VERSYM)]
			    - loadaddr,
			    total * sizeof (short), edata,
			    unsigned char *, "version symbol data");
d4683 2
a4684 1
			      GET_DATA (offset, evn, "version need");
d4693 2
a4694 2
				  GET_DATA (a_off, evna,
					    "version need aux (2)");
d4734 2
a4735 1
			      GET_DATA (offset, evd, "version def");
d4752 3
a4754 2
			      GET_DATA (offset - ivd.vd_next + ivd.vd_aux,
					evda, "version def aux");
d5059 3
a5061 2
	      GET_DATA_ALLOC (string_sec->sh_offset, string_sec->sh_size,
			      strtab, char *, "string table");
d5090 2
a5091 2
		  GET_DATA (offset + si * sizeof (vers_data), data,
			    "version data");
d5118 2
a5119 1
			      GET_DATA (offset, evn, "version need");
d5130 3
a5132 2
				  GET_DATA (vna_off, evna,
					    "version need aux (3)");
d5180 2
a5181 1
				  GET_DATA (offset, evd, "version def");
d5195 2
a5196 1
			      GET_DATA (offset, evda, "version def aux");
d5389 4
a5392 2
  GET_DATA_ALLOC (section->sh_offset, bytes, start, unsigned char *,
		  "section data");
d6932 5
a6936 2
	GET_DATA_ALLOC (sec->sh_offset, sec->sh_size, begin, unsigned char *,
			"debug_abbrev section data");
d7809 4
a7812 2
  GET_DATA_ALLOC (section->sh_offset, length, start, unsigned char *,
		  "debug section data");
d7871 5
a7875 2
		GET_DATA_ALLOC (section->sh_offset, length, start, unsigned char *,
				"debug section data");
d7971 32
a8002 2
      GET_DATA_ALLOC (liblist_offset, liblistno * sizeof (Elf32_External_Lib),
		      elib, Elf32_External_Lib *, "liblist");
d8004 5
a8008 52
      printf ("\nSection '.liblist' contains %lu entries:\n",
	      (unsigned long) liblistno);
      fputs ("     Library              Time Stamp          Checksum   Version Flags\n",
	     stdout);

      for (cnt = 0; cnt < liblistno; ++cnt)
	{
	  Elf32_Lib liblist;
	  time_t time;
	  char timebuf[20];
	  struct tm * tmp;

	  liblist.l_name = BYTE_GET (elib[cnt].l_name);
	  time = BYTE_GET (elib[cnt].l_time_stamp);
	  liblist.l_checksum = BYTE_GET (elib[cnt].l_checksum);
	  liblist.l_version = BYTE_GET (elib[cnt].l_version);
	  liblist.l_flags = BYTE_GET (elib[cnt].l_flags);

	  tmp = gmtime (&time);
	  sprintf (timebuf, "%04u-%02u-%02uT%02u:%02u:%02u",
		   tmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,
		   tmp->tm_hour, tmp->tm_min, tmp->tm_sec);

	  printf ("%3lu: %-20s %s %#10lx %-7ld", (unsigned long) cnt,
		  dynamic_strings + liblist.l_name, timebuf,
		  liblist.l_checksum, liblist.l_version);

	  if (liblist.l_flags == 0)
	    puts (" NONE");
	  else
	    {
	      static const struct
	      {
		const char * name;
		int bit;
	      }
	      l_flags_vals[] =
	      {
		{ " EXACT_MATCH", LL_EXACT_MATCH },
		{ " IGNORE_INT_VER", LL_IGNORE_INT_VER },
		{ " REQUIRE_MINOR", LL_REQUIRE_MINOR },
		{ " EXPORTS", LL_EXPORTS },
		{ " DELAY_LOAD", LL_DELAY_LOAD },
		{ " DELTA", LL_DELTA }
	      };
	      int flags = liblist.l_flags;
	      size_t fcnt;

	      for (fcnt = 0;
		   fcnt < sizeof (l_flags_vals) / sizeof (l_flags_vals[0]);
		   ++fcnt)
		if ((flags & l_flags_vals[fcnt].bit) != 0)
d8010 2
a8011 2
		    fputs (l_flags_vals[fcnt].name, stdout);
		    flags ^= l_flags_vals[fcnt].bit;
d8013 22
a8034 2
	      if (flags != 0)
		printf (" %#x", (unsigned int) flags);
d8036 2
a8037 1
	      puts ("");
d8039 2
a8041 2

      free (elib);
d8057 11
a8067 2
      GET_DATA_ALLOC (options_offset, sect->sh_size, eopt,
		      Elf_External_Options *, "options");
d8069 2
a8070 7
      iopt = (Elf_Internal_Options *) malloc ((sect->sh_size / sizeof (eopt))
					      * sizeof (* iopt));
      if (iopt == NULL)
	{
	  error (_("Out of memory"));
	  return 0;
	}
d8072 3
a8074 2
      offset = cnt = 0;
      option = iopt;
d8076 1
a8076 3
      while (offset < sect->sh_size)
	{
	  Elf_External_Options * eoption;
d8078 4
a8081 1
	  eoption = (Elf_External_Options *) ((char *) eopt + offset);
d8083 1
a8083 4
	  option->kind = BYTE_GET (eoption->kind);
	  option->size = BYTE_GET (eoption->size);
	  option->section = BYTE_GET (eoption->section);
	  option->info = BYTE_GET (eoption->info);
d8085 3
a8087 1
	  offset += option->size;
d8089 2
a8090 3
	  ++option;
	  ++cnt;
	}
d8092 1
a8092 2
      printf (_("\nSection '%s' contains %d entries:\n"),
	      SECTION_NAME (sect), cnt);
d8094 3
a8096 5
      option = iopt;

      while (cnt-- > 0)
	{
	  size_t len;
d8098 1
a8098 9
	  switch (option->kind)
	    {
	    case ODK_NULL:
	      /* This shouldn't happen.  */
	      printf (" NULL       %d %lx", option->section, option->info);
	      break;
	    case ODK_REGINFO:
	      printf (" REGINFO    ");
	      if (elf_header.e_machine == EM_MIPS)
d8100 125
a8224 41
		  /* 32bit form.  */
		  Elf32_External_RegInfo * ereg;
		  Elf32_RegInfo            reginfo;

		  ereg = (Elf32_External_RegInfo *) (option + 1);
		  reginfo.ri_gprmask = BYTE_GET (ereg->ri_gprmask);
		  reginfo.ri_cprmask[0] = BYTE_GET (ereg->ri_cprmask[0]);
		  reginfo.ri_cprmask[1] = BYTE_GET (ereg->ri_cprmask[1]);
		  reginfo.ri_cprmask[2] = BYTE_GET (ereg->ri_cprmask[2]);
		  reginfo.ri_cprmask[3] = BYTE_GET (ereg->ri_cprmask[3]);
		  reginfo.ri_gp_value = BYTE_GET (ereg->ri_gp_value);

		  printf ("GPR %08lx  GP 0x%lx\n",
			  reginfo.ri_gprmask,
			  (unsigned long) reginfo.ri_gp_value);
		  printf ("            CPR0 %08lx  CPR1 %08lx  CPR2 %08lx  CPR3 %08lx\n",
			  reginfo.ri_cprmask[0], reginfo.ri_cprmask[1],
			  reginfo.ri_cprmask[2], reginfo.ri_cprmask[3]);
		}
	      else
		{
		  /* 64 bit form.  */
		  Elf64_External_RegInfo * ereg;
		  Elf64_Internal_RegInfo reginfo;

		  ereg = (Elf64_External_RegInfo *) (option + 1);
		  reginfo.ri_gprmask    = BYTE_GET (ereg->ri_gprmask);
		  reginfo.ri_cprmask[0] = BYTE_GET (ereg->ri_cprmask[0]);
		  reginfo.ri_cprmask[1] = BYTE_GET (ereg->ri_cprmask[1]);
		  reginfo.ri_cprmask[2] = BYTE_GET (ereg->ri_cprmask[2]);
		  reginfo.ri_cprmask[3] = BYTE_GET (ereg->ri_cprmask[3]);
		  reginfo.ri_gp_value   = BYTE_GET8 (ereg->ri_gp_value);

		  printf ("GPR %08lx  GP 0x",
			  reginfo.ri_gprmask);
		  printf_vma (reginfo.ri_gp_value);
		  printf ("\n");

		  printf ("            CPR0 %08lx  CPR1 %08lx  CPR2 %08lx  CPR3 %08lx\n",
			  reginfo.ri_cprmask[0], reginfo.ri_cprmask[1],
			  reginfo.ri_cprmask[2], reginfo.ri_cprmask[3]);
d8226 10
a8236 74
	      continue;
	    case ODK_EXCEPTIONS:
	      fputs (" EXCEPTIONS fpe_min(", stdout);
	      process_mips_fpe_exception (option->info & OEX_FPU_MIN);
	      fputs (") fpe_max(", stdout);
	      process_mips_fpe_exception ((option->info & OEX_FPU_MAX) >> 8);
	      fputs (")", stdout);

	      if (option->info & OEX_PAGE0)
		fputs (" PAGE0", stdout);
	      if (option->info & OEX_SMM)
		fputs (" SMM", stdout);
	      if (option->info & OEX_FPDBUG)
		fputs (" FPDBUG", stdout);
	      if (option->info & OEX_DISMISS)
		fputs (" DISMISS", stdout);
	      break;
	    case ODK_PAD:
	      fputs (" PAD       ", stdout);
	      if (option->info & OPAD_PREFIX)
		fputs (" PREFIX", stdout);
	      if (option->info & OPAD_POSTFIX)
		fputs (" POSTFIX", stdout);
	      if (option->info & OPAD_SYMBOL)
		fputs (" SYMBOL", stdout);
	      break;
	    case ODK_HWPATCH:
	      fputs (" HWPATCH   ", stdout);
	      if (option->info & OHW_R4KEOP)
		fputs (" R4KEOP", stdout);
	      if (option->info & OHW_R8KPFETCH)
		fputs (" R8KPFETCH", stdout);
	      if (option->info & OHW_R5KEOP)
		fputs (" R5KEOP", stdout);
	      if (option->info & OHW_R5KCVTL)
		fputs (" R5KCVTL", stdout);
	      break;
	    case ODK_FILL:
	      fputs (" FILL       ", stdout);
	      /* XXX Print content of info word?  */
	      break;
	    case ODK_TAGS:
	      fputs (" TAGS       ", stdout);
	      /* XXX Print content of info word?  */
	      break;
	    case ODK_HWAND:
	      fputs (" HWAND     ", stdout);
	      if (option->info & OHWA0_R4KEOP_CHECKED)
		fputs (" R4KEOP_CHECKED", stdout);
	      if (option->info & OHWA0_R4KEOP_CLEAN)
		fputs (" R4KEOP_CLEAN", stdout);
	      break;
	    case ODK_HWOR:
	      fputs (" HWOR      ", stdout);
	      if (option->info & OHWA0_R4KEOP_CHECKED)
		fputs (" R4KEOP_CHECKED", stdout);
	      if (option->info & OHWA0_R4KEOP_CLEAN)
		fputs (" R4KEOP_CLEAN", stdout);
	      break;
	    case ODK_GP_GROUP:
	      printf (" GP_GROUP  %#06lx  self-contained %#06lx",
		      option->info & OGP_GROUP,
		      (option->info & OGP_SELF) >> 16);
	      break;
	    case ODK_IDENT:
	      printf (" IDENT     %#06lx  self-contained %#06lx",
		      option->info & OGP_GROUP,
		      (option->info & OGP_SELF) >> 16);
	      break;
	    default:
	      /* This shouldn't happen.  */
	      printf (" %3d ???     %d %lx",
		      option->kind, option->section, option->info);
	      break;
d8239 1
a8239 10
	  len = sizeof (* eopt);
	  while (len < option->size)
	    if (((char *) option)[len] >= ' '
		&& ((char *) option)[len] < 0x7f)
	      printf ("%c", ((char *) option)[len++]);
	    else
	      printf ("\\%03o", ((char *) option)[len++]);

	  fputs ("\n", stdout);
	  ++option;
a8240 2

      free (eopt);
a8244 2
      Elf32_External_Conflict * econf32;
      Elf64_External_Conflict * econf64;
d8263 8
a8270 2
	  GET_DATA_ALLOC (conflicts_offset, conflictsno * sizeof (* econf32),
			  econf32, Elf32_External_Conflict *, "conflict");
d8274 2
d8279 8
a8286 2
	  GET_DATA_ALLOC (conflicts_offset, conflictsno * sizeof (* econf64),
			  econf64, Elf64_External_Conflict *, "conflict");
d8290 2
d8366 4
a8369 1
  GET_DATA_ALLOC (offset, length, pnotes, Elf_External_Note *, "notes");
@


1.104
log
@Remove auot generated man pages
@
text
@d967 3
a969 1
	  if (symtab != NULL)
d971 1
a971 5
	      if (symtab_index >= nsyms)
		printf (" bad symbol index: %08lx", (unsigned long) symtab_index);
	      else
		{
		  Elf_Internal_Sym * psym;
d973 1
a973 1
		  psym = symtab + symtab_index;
d975 11
a985 11
		  printf (" ");
		  print_vma (psym->st_value, LONG_HEX);
		  printf ("  ");

		  if (psym->st_name == 0)
		    printf ("%-25.25s",
			    SECTION_NAME (section_headers + psym->st_shndx));
		  else if (strtab == NULL)
		    printf (_("<string table index %3ld>"), psym->st_name);
		  else
		    printf ("%-25.25s", strtab + psym->st_name);
d987 2
a988 3
		  if (is_rela)
		    printf (" + %lx", (unsigned long) relas [i].r_addend);
		}
a3072 1
	      Elf32_Internal_Shdr * symsec;
d3088 6
a3093 1
	      symsec = section_headers + section->sh_link;
d3095 3
a3097 2
	      nsyms = symsec->sh_size / symsec->sh_entsize;
	      symtab = GET_ELF_SYMBOLS (file, symsec->sh_offset, nsyms);
d3099 2
a3100 2
	      if (symtab == NULL)
		continue;
d3102 1
a3102 4
	      strsec = section_headers + symsec->sh_link;

	      GET_DATA_ALLOC (strsec->sh_offset, strsec->sh_size, strtab,
			      char *, "string table");
d3104 3
d3109 2
a3110 1
	      dump_relocations (file, rel_offset, rel_size, symtab, nsyms, strtab, is_rela);
d3112 4
a3115 2
	      free (strtab);
	      free (symtab);
@


1.103
log
@	* readelf.c (display_debug_frames): Fix warnings: Remove unused
	variables, fix format strings.
@
text
@d82 2
a83 2
char *	program_name = "readelf";
unsigned int	dynamic_addr;
d85 3
a87 3
unsigned int	rela_addr;
unsigned int	rela_size;
char *	dynamic_strings;
d93 1
a93 1
unsigned long	dynamic_syminfo_offset;
d95 4
a98 4
char	program_interpreter [64];
int	dynamic_info[DT_JMPREL + 1];
int	version_info[16];
int	loadaddr = 0;
d1262 10
a1271 10
    case EM_NONE:	return _("None");
    case EM_M32:	return "WE32100";
    case EM_SPARC:	return "Sparc";
    case EM_386:	return "Intel 80386";
    case EM_68K:	return "MC68000";
    case EM_88K:	return "MC88000";
    case EM_486:	return "Intel 80486";
    case EM_860:	return "Intel 80860";
    case EM_MIPS:	return "MIPS R3000";
    case EM_S370:	return "IBM System/370";
d1274 1
a1274 1
    case EM_PARISC:	return "HPPA";
d1277 5
a1281 5
    case EM_960:	return "Intel 90860";
    case EM_PPC:	return "PowerPC";
    case EM_V800:	return "NEC V800";
    case EM_FR20:	return "Fujitsu FR20";
    case EM_RH32:	return "TRW RH32";
d1286 2
a1287 2
    case EM_SPARCV9:	return "Sparc v9";
    case EM_TRICORE:	return "Siemens Tricore";
d1297 1
a1297 1
    case EM_ALPHA:	return "Alpha";
d1327 3
a1329 3
    case EM_JAVELIN:	return "Infineon Technologies 32-bit embedded cpu";
    case EM_FIREPATH:	return "Element 14 64-bit DSP processor";
    case EM_ZSP:	return "LSI Logic's 16-bit DSP processor";
d1331 2
a1332 2
    case EM_HUANY:	return "Harvard Universitys's machine-independent object format";
    case EM_PRISM:	return "SiTera Prism";
@


1.102
log
@        * readelf.c (do_debug_frames_interp): New.
        (byte_get_little_endian): If BFD64, always read entire 8-byte fields.
        (byte_get_big_endian): Likewise.
        (parse_args) ['F']: Set do_debug_frames_interp.
        (Frame_Chunk): Make data_factor signed, add fde_encoding.
        (frame_display_row): Don't trunc pc_begin to int.
        (size_of_encoded_value): New.
        (display_debug_frames): Handle 64-bit targets.  Print raw data
        unless do_debug_frames_interp.
        (debug_displays): Remove duplicate .debug_frame.
@
text
@d82 6
a87 6
char *          	program_name = "readelf";
unsigned int    	dynamic_addr;
bfd_size_type  		dynamic_size;
unsigned int    	rela_addr;
unsigned int    	rela_size;
char *          	dynamic_strings;
d91 1
a91 1
Elf_Internal_Sym * 	dynamic_symbols;
d93 1
a93 1
unsigned long   	dynamic_syminfo_offset;
d95 4
a98 4
char            	program_interpreter [64];
int             	dynamic_info[DT_JMPREL + 1];
int             	version_info[16];
int             	loadaddr = 0;
d102 6
a107 6
int 			show_name;
int 			do_dynamic;
int 			do_syms;
int 			do_reloc;
int 			do_sections;
int 			do_segments;
d109 4
a112 4
int 			do_using_dynamic;
int 			do_header;
int 			do_dump;
int 			do_version;
d156 2
a157 2
static int		  slurp_rela_relocs 	      PARAMS ((FILE *, unsigned long, unsigned long, Elf_Internal_Rela **, unsigned long *));
static int		  slurp_rel_relocs 	      PARAMS ((FILE *, unsigned long, unsigned long, Elf_Internal_Rel **, unsigned long *));
d175 1
a175 1
static const char *       get_dynamic_flags 	      PARAMS ((bfd_vma));
d203 1
a203 1
static int 	          disassemble_section         PARAMS ((Elf32_Internal_Shdr *, FILE *));
d205 2
a206 2
static int 	          dump_section                PARAMS ((Elf32_Internal_Shdr *, FILE *));
static int 	          display_debug_section       PARAMS ((Elf32_Internal_Shdr *, FILE *));
d231 1
a231 1
static char * 		  get_note_type		         PARAMS ((unsigned int));
d235 1
a235 1
static int 		  process_corefile_contents	 PARAMS ((FILE *));
d245 1
a245 1
#define SECTION_NAME(X) 	((X) == NULL ? "<none>" : \
d251 1
a251 1
#define BYTE_GET(field) 	byte_get (field, sizeof (field))
d262 1
a262 1
#define BYTE_GET8(field) 	byte_get (field, -8)
d264 1
a264 1
#define BYTE_GET8(field) 	byte_get (field, 8)
d267 1
a267 1
#define NUM_ELEM(array) 	(sizeof (array) / sizeof ((array)[0]))
d282 6
a287 6
    } 									\
 									\
  if (fread (var, size, 1, file) != 1) 					\
    { 									\
      error (_("Unable to read in %d bytes of %s\n"), size, reason); 	\
      free (var); 							\
d289 1
a289 1
      return 0; 							\
d293 1
a293 1
#define GET_DATA(offset, var, reason) 					\
d295 1
a295 1
    { 									\
d1262 11
a1272 11
    case EM_NONE:        	return _("None");
    case EM_M32:         	return "WE32100";
    case EM_SPARC:       	return "Sparc";
    case EM_386:         	return "Intel 80386";
    case EM_68K:         	return "MC68000";
    case EM_88K:         	return "MC88000";
    case EM_486:         	return "Intel 80486";
    case EM_860:         	return "Intel 80860";
    case EM_MIPS:        	return "MIPS R3000";
    case EM_S370:        	return "IBM System/370";
    case EM_MIPS_RS3_LE: 	return "MIPS R4000 big-endian";
d1274 1
a1274 1
    case EM_PARISC:      	return "HPPA";
d1276 6
a1281 6
    case EM_SPARC32PLUS: 	return "Sparc v8+" ;
    case EM_960:         	return "Intel 90860";
    case EM_PPC:         	return "PowerPC";
    case EM_V800:         	return "NEC V800";
    case EM_FR20:         	return "Fujitsu FR20";
    case EM_RH32:         	return "TRW RH32";
d1283 5
a1287 5
    case EM_ARM:	 	return "ARM";
    case EM_OLD_ALPHA:	 	return "Digital Alpha (old)";
    case EM_SH:		 	return "Hitachi SH";
    case EM_SPARCV9:     	return "Sparc v9";
    case EM_TRICORE:    	return "Siemens Tricore";
d1297 1
a1297 1
    case EM_ALPHA:       	return "Alpha";
d1307 18
a1324 18
    case EM_MMA:      		return "Fujitsu Multimedia Accelerator";
    case EM_PCP:      		return "Siemens PCP";
    case EM_NCPU:     		return "Sony nCPU embedded RISC processor";
    case EM_NDR1:     		return "Denso NDR1 microprocesspr";
    case EM_STARCORE: 		return "Motorola Star*Core processor";
    case EM_ME16:     		return "Toyota ME16 processor";
    case EM_ST100:    		return "STMicroelectronics ST100 processor";
    case EM_TINYJ:    		return "Advanced Logic Corp. TinyJ embedded processor";
    case EM_FX66:     		return "Siemens FX66 microcontroller";
    case EM_ST9PLUS:  		return "STMicroelectronics ST9+ 8/16 bit microcontroller";
    case EM_ST7:      		return "STMicroelectronics ST7 8-bit microcontroller";
    case EM_68HC16:   		return "Motorola MC68HC16 Microcontroller";
    case EM_68HC11:   		return "Motorola MC68HC11 Microcontroller";
    case EM_68HC08:   		return "Motorola MC68HC08 Microcontroller";
    case EM_68HC05:   		return "Motorola MC68HC05 Microcontroller";
    case EM_SVX:      		return "Silicon Graphics SVx";
    case EM_ST19:     		return "STMicroelectronics ST19 8-bit microcontroller";
    case EM_VAX:      		return "Digital VAX";
d1327 3
a1329 3
    case EM_JAVELIN:     	return "Infineon Technologies 32-bit embedded cpu";
    case EM_FIREPATH:    	return "Element 14 64-bit DSP processor";
    case EM_ZSP:         	return "LSI Logic's 16-bit DSP processor";
d1331 2
a1332 2
    case EM_HUANY:       	return "Harvard Universitys's machine-independent object format";
    case EM_PRISM:       	return "SiTera Prism";
d3059 2
a3060 2
      unsigned long 		i;
      int           		found = 0;
d3205 1
a3205 1
  
d4523 6
a4528 6
	    int              		total;
	    int              		cnt;
	    unsigned char * 		edata;
	    unsigned short * 		data;
	    char *           		strtab;
	    Elf_Internal_Sym * 		symbols;
d7205 1
a7205 1
		    saved_start - section_start, length, cie_id,
d7211 1
a7211 1
		      saved_start - section_start, length, cie_id);
d7238 1
a7238 1
		    *q++;
a7257 1
	  int size;
d7314 1
a7314 1
		  saved_start - section_start, length, cie_id, 
d7341 1
a7341 2
	    bfd_vma vma;
	    
d7346 1
a7346 1
	    
d7413 1
a7413 1
		break;		
d7418 1
a7418 1
		reg = LEB (); LEB ();      
d7421 1
a7421 1
		
d7461 1
a7461 1
	        printf ("  DW_CFA_offset: r%d at cfa%+d\n",
d7480 1
a7480 1
	        printf ("  DW_CFA_set_loc: %08x\n", vma);
d7489 1
a7489 1
	        printf ("  DW_CFA_advance_loc1: %d to %08lx\n",
d7500 1
a7500 1
	        printf ("  DW_CFA_advance_loc2: %d to %08lx\n",
d7511 1
a7511 1
	        printf ("  DW_CFA_advance_loc4: %d to %08lx\n",
d7521 1
a7521 1
		printf ("  DW_CFA_offset_extended: r%d at cfa%+d\n",
d7530 1
a7530 1
	        printf ("  DW_CFA_restore_extended: r%d\n", reg);
d7538 1
a7538 1
	        printf ("  DW_CFA_undefined: r%d\n", reg);
d7546 1
a7546 1
	        printf ("  DW_CFA_same_value: r%d\n", reg);
d7555 1
a7555 1
	        printf ("  DW_CFA_register: r%d\n", reg);
d7622 1
a7622 1
	        printf ("  DW_CFA_GNU_args_size: %d\n", ul);
d7630 1
a7630 1
	        printf ("  DW_CFA_GNU_negative_offset_extended: r%d at cfa%+d\n",
d7735 1
a7735 1
    name = ".debug_info";  
d7762 1
a7762 1
  unsigned int  	i;
d8244 1
a8244 1
  	  pnote->descsz, get_note_type (pnote->type));
@


1.101
log
@Remove definition of EM_MIPS_RS4_BE.  The constant was never in active use
and is used otherwise by the ABI.
@
text
@d121 1
d380 1
d386 1
d394 1
d523 1
d531 2
a532 2

#ifdef BFD64
d2172 2
a2174 1
		case 'F':
d2904 2
a2905 1
		|| do_debug_lines || do_debug_pubnames || do_debug_aranges || do_debug_frames)
d7001 1
a7001 1
  unsigned int         data_factor;
d7007 1
d7069 1
a7069 1
  printf ("%08x ", (unsigned int) fc->pc_begin);
d7101 14
d7133 1
d7146 3
a7158 2
      printf ("\n%08x %08lx %08lx ", saved_start - section_start, length, cie_id);

d7161 2
d7174 2
a7175 1
	  start ++; /* version */
d7177 1
a7177 5

	  while (* start)
	    start++;

	  start++; /* skip past NUL */
a7180 1
	      int xtra;
d7184 3
a7186 3
	      xtra = LEB ();
	      printf ("skipping %d extra bytes\n", xtra);
	      start += xtra;
d7190 1
a7190 1
	      start += 4;
d7202 49
a7250 2
	  printf ("CIE \"%s\" cf=%d df=%d ra=%d\n",
		  fc->augmentation, fc->code_factor, fc->data_factor, fc->ra);
d7258 1
d7263 1
a7263 1
	  look_for = is_eh ? start-4-cie_id : (unsigned char *) cie_id;
d7265 3
a7267 2
	  fc->pc_begin = byte_get (start, 4); start += 4;
	  fc->pc_range = byte_get (start, 4); start += 4;
a7268 1
	  for (cie=chunks; cie && (cie->chunk_start != look_for); cie = cie->next);
d7271 2
a7272 1
	      warn ("Invalid CIE pointer %08x in FDE at %08x\n", cie_id, saved_start);
d7280 1
d7296 1
d7299 8
d7309 3
a7311 2
	      unsigned long l = LEB ();
	      start += l;
d7314 3
a7316 2
	  printf ("FDE cie=%08x pc=%08lx..%08lx\n",
		  cie->chunk_start-section_start, fc->pc_begin,
d7318 9
d7332 1
a7332 3
      /* This exists for readelf maintainers.  */
#define FDEBUG 0

d7365 1
a7365 1
		start += sizeof (vma);
d7451 6
a7456 5
	      frame_display_row (fc, &need_col_headers, &max_regs);
#if FDEBUG
	      printf ("  DW_CFA_advance_loc: %08x = %08x + %d*%d\n",
		      fc->pc_begin + opa * fc->code_factor, fc->pc_begin, opa, fc->code_factor);
#endif
d7462 3
a7464 3
#if FDEBUG
	      printf ("  DW_CFA_offset: r%d = cfa[%d*%d]\n", opa, roffs, fc->data_factor);
#endif
d7470 2
a7471 3
#if FDEBUG
	      printf ("  DW_CFA_restore: r%d\n", opa);
#endif
d7477 6
a7482 5
	      frame_display_row (fc, &need_col_headers, &max_regs);
	      vma = byte_get (start, sizeof (vma)); start += sizeof (vma);
#if FDEBUG
	      printf ("  DW_CFA_set_loc: %08x\n", vma);
#endif
a7486 1
	      frame_display_row (fc, &need_col_headers, &max_regs);
d7488 6
a7493 4
#if FDEBUG
	      printf ("  DW_CFA_advance_loc1: %08x = %08x + %d*%d\n",
		      fc->pc_begin + ofs * fc->code_factor, fc->pc_begin, ofs, fc->code_factor);
#endif
a7497 1
	      frame_display_row (fc, &need_col_headers, &max_regs);
d7499 6
a7504 4
#if FDEBUG
	      printf ("  DW_CFA_advance_loc2: %08x = %08x + %d*%d\n",
		      fc->pc_begin + ofs * fc->code_factor, fc->pc_begin, ofs, fc->code_factor);
#endif
a7508 1
	      frame_display_row (fc, &need_col_headers, &max_regs);
d7510 6
a7515 4
#if FDEBUG
	      printf ("  DW_CFA_advance_loc4: %08x = %08x + %d*%d\n",
		      fc->pc_begin + ofs * fc->code_factor, fc->pc_begin, ofs, fc->code_factor);
#endif
d7522 3
a7524 3
#if FDEBUG
	      printf ("  DW_CFA_offset_extended: r%d = cfa[%d*%d]\n", reg, roffs, fc->data_factor);
#endif
d7531 2
a7532 3
#if FDEBUG
	      printf ("  DW_CFA_restore_extended: r%d\n", reg);
#endif
d7539 2
a7540 3
#if FDEBUG
	      printf ("  DW_CFA_undefined: r%d\n", reg);
#endif
d7547 2
a7548 3
#if FDEBUG
	      printf ("  DW_CFA_same_value: r%d\n", reg);
#endif
d7556 2
a7557 3
#if FDEBUG
	      printf ("  DW_CFA_register: r%d\n", reg);
#endif
d7563 2
a7564 3
#if FDEBUG
	      printf ("  DW_CFA_remember_state\n");
#endif
d7576 2
a7577 3
#if FDEBUG
	      printf ("  DW_CFA_restore_state\n");
#endif
d7591 3
a7593 3
#if FDEBUG
	      printf ("  DW_CFA_def_cfa: reg %d ofs %d\n", fc->cfa_reg, fc->cfa_offset);
#endif
d7598 2
a7599 3
#if FDEBUG
	      printf ("  DW_CFA_def_cfa_reg: %d\n", fc->cfa_reg);
#endif
d7604 2
a7605 3
#if FDEBUG
	      printf ("  DW_CFA_def_cfa_offset: %d\n", fc->cfa_offset);
#endif
d7609 2
a7610 3
#if FDEBUG
	      printf ("  DW_CFA_nop\n");
#endif
d7617 2
a7618 3
#if FDEBUG
	      printf ("  DW_CFA_GNU_window_save\n");
#endif
a7620 3
#ifndef DW_CFA_GNU_args_size
#define DW_CFA_GNU_args_size 0x2e
#endif
d7623 2
a7624 3
#if FDEBUG
	      printf ("  DW_CFA_GNU_args_size: %d\n", ul);
#endif
a7626 3
#ifndef DW_CFA_GNU_negative_offset_extended
#define DW_CFA_GNU_negative_offset_extended 0x2f
#endif
d7631 3
a7633 3
#if FDEBUG
	      printf ("  DW_CFA_GNU_negative_offset_extended: r%d = cfa[%d*%d]\n", reg, l, fc->data_factor);
#endif
d7644 2
a7645 1
      frame_display_row (fc, &need_col_headers, &max_regs);
a7707 1
  { ".debug_frame",       display_debug_not_supported, NULL },
@


1.100
log
@	* elfxx-ia64.c (is_unwind_section_name): Consider linkonce unwind
	sections as well.
	(elfNN_ia64_final_write_processing): Map .gnu.linkonce.ia64unw.FOO
	to .gnu.linkonce.t.FOO text section.

	* readelf.c (process_unwind): Print all unwind sections, not just
	one.

	* config/tc-ia64.c (special_linkonce_name): New.
	(make_unw_section): Map .gnu.linkonce.t.FOO text section into
	.gnu.linkonce.ia64unw{,i}.FOO.
	(ia64_elf_section_type): Handle .gnu.linkonce.ia64unw{,i}.FOO.
	(dot_endp): Add comment about it.

	* elf/ia64.h (ELF_STRING_ia64_unwind_once): Define.
	(ELF_STRING_ia64_unwind_info_once): Define.

	* emulparams/elf64_ia64.sh (OTHER_READONLY_SECTIONS): Put
	.gnu.linkonce.ia64unw{,i} sections into corresponding .IA_64.unwind*
	output sections.
	* emulparams/elf64_aix.sh (OTHER_READONLY_SECTIONS): Likewise.
@
text
@d565 1
a565 1
    case EM_MIPS_RS4_BE:
d905 1
a905 1
	case EM_MIPS_RS4_BE:
d1182 1
a1182 1
	    case EM_MIPS_RS4_BE:
d1267 1
a1267 1
    case EM_MIPS_RS4_BE: 	return "MIPS R4000 big-endian";
d1540 1
a1540 1
	case EM_MIPS_RS4_BE:
d1755 1
a1755 1
	    case EM_MIPS_RS4_BE:
d1921 1
a1921 1
	    case EM_MIPS_RS4_BE:
d4276 1
a4276 1
		case EM_MIPS_RS4_BE:
d8321 1
a8321 1
    case EM_MIPS_RS4_BE:
@


1.99
log
@	* readelf.c (process_unwind): Remove const specifier.
@
text
@d3411 1
a3411 1
  unsigned long i, addr_size;
d3440 1
a3440 8
	unwsec = sec;
      else if (strcmp (SECTION_NAME (sec), ELF_STRING_ia64_unwind_info) == 0)
	{
	  aux.info_size = sec->sh_size;
	  aux.info_addr = sec->sh_addr;
	  GET_DATA_ALLOC (sec->sh_offset, aux.info_size, aux.info,
			  char *, "unwind info");
	}
d3443 4
a3446 1
  if (unwsec)
d3448 13
a3460 1
      printf (_("\nUnwind section "));
d3462 13
a3474 2
      if (string_table == NULL)
	printf ("%d", unwsec->sh_name);
d3476 20
a3495 1
	printf ("'%s'", SECTION_NAME (unwsec));
d3497 11
a3507 2
      printf (_(" at offset 0x%lx contains %lu entries:\n"),
	      unwsec->sh_offset, (unsigned long) (unwsec->sh_size / (3 * addr_size)));
d3509 1
a3509 1
      (void) slurp_ia64_unwind_table (file, & aux, unwsec);
d3511 21
a3531 2
      if (aux.table_len > 0)
	dump_ia64_unwind (& aux);
a3532 2
  else
    printf (_("\nThere are no unwind sections in this file.\n"));
a3533 4
  if (aux.table)
    free ((char *) aux.table);
  if (aux.info)
    free ((char *) aux.info);
@


1.98
log
@	* readelf.c (display_debug_lines): Fix typo for "Prologue".
@
text
@d3437 1
a3437 1
			  aux.strtab, const char *, "string table");
@


1.97
log
@2001-03-30  H.J. Lu  <hjl@@gnu.org>

	* readelf.c (process_unwind): Just return if do_unwind is 0.
@
text
@d5497 1
a5497 1
      printf (_("  Prolgue Length:              %d\n"), info.li_prologue_length);
@


1.96
log
@2001-03-29  H.J. Lu  <hjl@@gnu.org>

	* readelf.c (process_unwind): Only do unwind sections for
	IA64.
@
text
@d3414 3
a3425 3

  if (!do_unwind)
    return 1;
@


1.95
log
@Fix typos in ChangeLogs and update copyright notices
@
text
@d3414 6
@


1.94
log
@Handle EM_S390_OLD.
@
text
@d2 1
a2 1
   Copyright (C) 1998, 99, 2000, 2001 Free Software Foundation, Inc.
@


1.93
log
@Remove non-K&R compliant LHS type cast in call to GET_DATA_ALLOC macro.
@
text
@d588 1
d945 1
d1329 1
@


1.92
log
@2001-02-28  Philip Blundell  <pb@@futuretv.com>

	* readelf.c (decode_ARM_machine_flags): Explicitly mention which
	ABI is in use; remove ambiguity between the "unknown" EABI and
	unrecognised ABIs.  Handle version 2 ARM EABI.  Update uses of
	renamed EF_xx constants.
@
text
@d3141 1
a3141 1
    const char *          strtab;	/* The string table.  */
d3428 1
a3428 1
			  (char *) aux.strtab, char *, "string table");
@


1.91
log
@	* readelf.c (struct unw_aux_info): Remove const from the info member.
	(process_unwind): Don't type-cast the third argument to the
	GET_DATA_ALLOC macro.
@
text
@d1362 1
a1362 1
      strcat (buf, ", <unknown EABI>");
d1368 1
d1379 1
a1379 1
	    case EF_ARM_SYMSARESORTED: /* Conflicts with EF_INTERWORK.  */
d1390 31
d1422 1
d1433 1
a1433 1
	    case EF_INTERWORK:
d1437 1
a1437 1
	    case EF_APCS_26:
d1441 1
a1441 1
	    case EF_APCS_FLOAT:
d1445 1
a1445 1
	    case EF_PIC:
d1449 1
a1449 1
	    case EF_ALIGN8:
d1453 1
a1453 1
	    case EF_NEW_ABI:
d1457 1
a1457 1
	    case EF_OLD_ABI:
d1461 1
a1461 1
	    case EF_SOFT_FLOAT:
@


1.90
log
@fix seg fault in reloc reading code
@
text
@d3102 1
a3102 1
    const unsigned char * info;		/* Unwind info.  */
d3403 1
a3403 1
	  GET_DATA_ALLOC (sec->sh_offset, aux.info_size, (char *) aux.info,
@


1.89
log
@Document new --unwind option to readelf.
@
text
@d1000 4
a1003 1
  free (relas);
d3418 1
a3418 1
	      unwsec->sh_offset, unwsec->sh_size / (3 * addr_size));
@


1.88
log
@Add s390 support
@
text
@d3113 1
a3113 1
static int  slurp_ia64_unwind_table PARAMS ((FILE *file, struct unw_aux_info *,
a3435 1

@


1.87
log
@Add -u option toi readelf to display unwind info.
Add support to display unwind info for IA64 binaries.
@
text
@d77 1
d587 1
d943 4
d1324 1
@


1.86
log
@	* readelf.c (process_version_sections): Check if VERDEF or VERNEED
	sections are present before using them.  Remove code duplication.
	(process_symbol_table): Check if VERDEF or VERNEED sections are
	present before using them.
@
text
@d107 1
d154 2
d163 1
d167 1
d179 1
d196 1
d254 1
a254 1
   internal field is also 8 bytes wide and so we can extact all the data.
a611 1
/* Display the contents of the relocation data found at the specified offset.  */
d613 6
a618 8
dump_relocations (file, rel_offset, rel_size, symtab, nsyms, strtab, is_rela)
     FILE *             file;
     unsigned long      rel_offset;
     unsigned long      rel_size;
     Elf_Internal_Sym * symtab;
     unsigned long      nsyms;
     char *             strtab;
     int                is_rela;
d620 10
a629 3
  unsigned int        i;
  Elf_Internal_Rel *  rels;
  Elf_Internal_Rela * relas;
d631 1
d633 2
a634 2
  if (is_rela == UNKNOWN)
    is_rela = guess_is_rela (elf_header.e_machine);
d636 1
a636 3
  if (is_rela)
    {
      if (is_32bit_elf)
d638 3
a640 1
	  Elf32_External_Rela * erelas;
d642 6
a647 2
	  GET_DATA_ALLOC (rel_offset, rel_size, erelas,
			  Elf32_External_Rela *, "relocs");
d649 5
a653 4
	  rel_size = rel_size / sizeof (Elf32_External_Rela);

	  relas = (Elf_Internal_Rela *)
	    malloc (rel_size * sizeof (Elf_Internal_Rela));
d655 2
a656 5
	  if (relas == NULL)
	    {
	      error(_("out of memory parsing relocs"));
	      return 0;
	    }
d658 1
a658 6
	  for (i = 0; i < rel_size; i++)
	    {
	      relas[i].r_offset = BYTE_GET (erelas[i].r_offset);
	      relas[i].r_info   = BYTE_GET (erelas[i].r_info);
	      relas[i].r_addend = BYTE_GET (erelas[i].r_addend);
	    }
d660 2
a661 1
	  free (erelas);
d663 4
a666 1
	  rels = (Elf_Internal_Rel *) relas;
d668 2
a669 1
      else
d671 4
a674 1
	  Elf64_External_Rela * erelas;
d676 6
a681 2
	  GET_DATA_ALLOC (rel_offset, rel_size, erelas,
			  Elf64_External_Rela *, "relocs");
d683 15
a697 1
	  rel_size = rel_size / sizeof (Elf64_External_Rela);
d699 2
a700 2
	  relas = (Elf_Internal_Rela *)
	    malloc (rel_size * sizeof (Elf_Internal_Rela));
d702 1
a702 5
	  if (relas == NULL)
	    {
	      error(_("out of memory parsing relocs"));
	      return 0;
	    }
d704 1
a704 6
	  for (i = 0; i < rel_size; i++)
	    {
	      relas[i].r_offset = BYTE_GET8 (erelas[i].r_offset);
	      relas[i].r_info   = BYTE_GET8 (erelas[i].r_info);
	      relas[i].r_addend = BYTE_GET8 (erelas[i].r_addend);
	    }
d706 5
a710 1
	  free (erelas);
d712 4
a715 1
	  rels = (Elf_Internal_Rel *) relas;
d717 2
d722 1
a722 3
      if (is_32bit_elf)
	{
	  Elf32_External_Rel * erels;
d724 2
a725 2
	  GET_DATA_ALLOC (rel_offset, rel_size, erels,
			  Elf32_External_Rel *, "relocs");
d727 1
a727 1
	  rel_size = rel_size / sizeof (Elf32_External_Rel);
d729 1
a729 2
	  rels = (Elf_Internal_Rel *)
	    malloc (rel_size * sizeof (Elf_Internal_Rel));
d731 5
a735 5
	  if (rels == NULL)
	    {
	      error(_("out of memory parsing relocs"));
	      return 0;
	    }
d737 4
a740 9
	  for (i = 0; i < rel_size; i++)
	    {
	      rels[i].r_offset = BYTE_GET (erels[i].r_offset);
	      rels[i].r_info   = BYTE_GET (erels[i].r_info);
	    }

	  free (erels);

	  relas = (Elf_Internal_Rela *) rels;
a741 3
      else
	{
	  Elf64_External_Rel * erels;
d743 6
a748 2
	  GET_DATA_ALLOC (rel_offset, rel_size, erels,
			  Elf64_External_Rel *, "relocs");
d750 14
a763 1
	  rel_size = rel_size / sizeof (Elf64_External_Rel);
a764 2
	  rels = (Elf_Internal_Rel *)
	    malloc (rel_size * sizeof (Elf_Internal_Rel));
d766 2
a767 5
	  if (rels == NULL)
	    {
	      error(_("out of memory parsing relocs"));
	      return 0;
	    }
d769 9
a777 10
	  for (i = 0; i < rel_size; i++)
	    {
	      rels[i].r_offset = BYTE_GET8 (erels[i].r_offset);
	      rels[i].r_info   = BYTE_GET8 (erels[i].r_info);
	    }

	  free (erels);

	  relas = (Elf_Internal_Rela *) rels;
	}
d1603 15
d1671 15
d1715 3
d1821 14
d1881 3
d1925 1
d1950 1
d2013 1
a2013 1
	  (argc, argv, "ersahnldSDAIw::x:i:vV", options, NULL)) != EOF)
d2030 1
d2054 3
d2159 1
a2159 1
  if (!do_dynamic && !do_syms && !do_reloc && !do_sections
d3070 360
d8349 2
@


1.86.2.1
log
@	* readelf.c (display_debug_lines): Fix typo for "Prologue".
@
text
@d4995 1
a4995 1
      printf (_("  Prologue Length:             %d\n"), info.li_prologue_length);
@


1.86.2.2
log
@2001-05-28  Philip Blundell  <philb@@gnu.org>

	From 2001-05-28  Andreas Jaeger  <aj@@suse.de>
	* readelf.c (display_debug_frames): Fix warnings: Remove unused
	variables, fix format strings.

	From 2001-05-16  Richard Henderson  <rth@@redhat.com>
	* readelf.c (do_debug_frames_interp): New.
	(byte_get_little_endian): If BFD64, always read entire 8-byte fields.
	(byte_get_big_endian): Likewise.
	(parse_args) ['F']: Set do_debug_frames_interp.
	(Frame_Chunk): Make data_factor signed, add fde_encoding.
	(frame_display_row): Don't trunc pc_begin to int.
	(size_of_encoded_value): New.
	(display_debug_frames): Handle 64-bit targets.  Print raw data
	unless do_debug_frames_interp.
	(debug_displays): Remove duplicate .debug_frame.

	From 2001-05-15  Ralf Baechle  <ralf@@gnu.org>
	* readelf.c: Replace uses of EM_MIPS_RS4_BE with EM_MIPS_RS3_LE.
	The former constant was never in active use and is used otherwise
	by the ABI.

	From 2001-05-11  Jakub Jelinek  <jakub@@redhat.com>
	* readelf.c (process_unwind): Print all unwind sections, not just
	one.

	From 2001-05-07  Thiemo Seufer <seufer@@csv.ica.uni-stuttgart.de>
	* readelf.c (process_unwind): Remove const specifier.

	From 2001-03-30  H.J. Lu  <hjl@@gnu.org>
	* readelf.c (process_unwind): Just return if do_unwind is 0.

	From 2001-03-29  H.J. Lu  <hjl@@gnu.org>
	* readelf.c (process_unwind): Only do unwind sections for
	IA64.

	From 2001-02-28  Nick Clifton  <nickc@@redhat.com>
	* readelf.c: (struct unw_aux_info): Remove const modifier for
	'strtab' field.
	(process_unwind): Remove non-K&R compliant LHS type cast in call
	to GET_DATA_ALLOC macro.

	From 2001-02-11  Michael Sokolov  <msokolov@@ivan.Harhan.ORG>
	* readelf.c (struct unw_aux_info): Remove const from the info member.
	(process_unwind): Don't type-cast the third argument to the
	GET_DATA_ALLOC macro.

	From 2001-02-11  Nick Clifton  <nickc@@redhat.com>
	* readelf.c (dump_relocations): Free corrected allocated
	array.
	(process_unwind): Fix compile time warning.

	From 2001-02-07  David Mosberger  <davidm@@hpl.hp.com>
	* readelf.c (process_unwind): New function.
	(slurp_ia64_unwind_table): Ditto.
	(dump_ia64_unwind): Ditto.
	(find_symbol_for_address): Ditto.
	(slurp_rela_relocs): New function (split off from dump_relocations()).
	(slurp_rel_relocs): Ditto.
	(parse_args): Handle '-u' option.
	* unwind-ia64.c: New file.
	* unwind-ia64.h: New file.
	* Makefile.am: Include unwind-ia64.c in readelf build.
	* Makefile.in: Regenerate.
	* po/binutils.pot: Regenerate.
@
text
@d2 1
a2 1
   Copyright 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d81 6
a86 6
char *	program_name = "readelf";
unsigned int	dynamic_addr;
bfd_size_type		dynamic_size;
unsigned int	rela_addr;
unsigned int	rela_size;
char *	dynamic_strings;
d90 1
a90 1
Elf_Internal_Sym *	dynamic_symbols;
d92 1
a92 1
unsigned long	dynamic_syminfo_offset;
d94 4
a97 4
char	program_interpreter [64];
int	dynamic_info[DT_JMPREL + 1];
int	version_info[16];
int	loadaddr = 0;
d101 10
a110 11
int			show_name;
int			do_dynamic;
int			do_syms;
int			do_reloc;
int			do_sections;
int			do_segments;
int			do_unwind;
int			do_using_dynamic;
int			do_header;
int			do_dump;
int			do_version;
a118 1
int                     do_debug_frames_interp;
a152 2
static int		  slurp_rela_relocs	      PARAMS ((FILE *, unsigned long, unsigned long, Elf_Internal_Rela **, unsigned long *));
static int		  slurp_rel_relocs	      PARAMS ((FILE *, unsigned long, unsigned long, Elf_Internal_Rel **, unsigned long *));
a159 1
static const char *       get_ia64_segment_type       PARAMS ((unsigned long));
a162 1
static const char *       get_ia64_section_type_name  PARAMS ((unsigned int));
d168 1
a168 1
static const char *       get_dynamic_flags	      PARAMS ((bfd_vma));
a173 1
static int		  process_unwind	      PARAMS ((FILE *));
a189 1
static const char *	  get_elf_section_flags	      PARAMS ((bfd_vma));
d194 1
a194 1
static int	          disassemble_section         PARAMS ((Elf32_Internal_Shdr *, FILE *));
d196 2
a197 2
static int	          dump_section                PARAMS ((Elf32_Internal_Shdr *, FILE *));
static int	          display_debug_section       PARAMS ((Elf32_Internal_Shdr *, FILE *));
d222 1
a222 1
static char *		  get_note_type		         PARAMS ((unsigned int));
d226 1
a226 1
static int		  process_corefile_contents	 PARAMS ((FILE *));
d236 1
a236 1
#define SECTION_NAME(X)	((X) == NULL ? "<none>" : \
d242 1
a242 1
#define BYTE_GET(field)	byte_get (field, sizeof (field))
d247 1
a247 1
   internal field is also 8 bytes wide and so we can extract all the data.
d253 1
a253 1
#define BYTE_GET8(field)	byte_get (field, -8)
d255 1
a255 1
#define BYTE_GET8(field)	byte_get (field, 8)
d258 1
a258 1
#define NUM_ELEM(array)	(sizeof (array) / sizeof ((array)[0]))
d273 6
a278 6
    }									\
									\
  if (fread (var, size, 1, file) != 1)					\
    {									\
      error (_("Unable to read in %d bytes of %s\n"), size, reason);	\
      free (var);							\
d280 1
a280 1
      return 0;							\
d284 1
a284 1
#define GET_DATA(offset, var, reason)					\
d286 1
a286 1
    {									\
a370 1
#ifndef BFD64
a375 1
#endif
a382 1
    case 8:
a510 1
#ifndef BFD64
d518 2
a519 2
#else
    case 8:
d557 1
a557 1
    case EM_MIPS_RS3_LE:
d605 1
d607 8
a614 6
slurp_rela_relocs (file, rel_offset, rel_size, relasp, nrelasp)
     FILE *file;
     unsigned long rel_offset;
     unsigned long rel_size;
     Elf_Internal_Rela **relasp;
     unsigned long *nrelasp;
d616 3
a618 7
  Elf_Internal_Rela *relas;
  unsigned long nrelas;
  unsigned int i;

  if (is_32bit_elf)
    {
      Elf32_External_Rela * erelas;
a619 2
      GET_DATA_ALLOC (rel_offset, rel_size, erelas,
		      Elf32_External_Rela *, "relocs");
d621 2
a622 1
      nrelas = rel_size / sizeof (Elf32_External_Rela);
d624 5
a628 2
      relas = (Elf_Internal_Rela *)
	malloc (nrelas * sizeof (Elf_Internal_Rela));
d630 2
a631 5
      if (relas == NULL)
	{
	  error(_("out of memory parsing relocs"));
	  return 0;
	}
d633 1
a633 6
      for (i = 0; i < nrelas; i++)
	{
	  relas[i].r_offset = BYTE_GET (erelas[i].r_offset);
	  relas[i].r_info   = BYTE_GET (erelas[i].r_info);
	  relas[i].r_addend = BYTE_GET (erelas[i].r_addend);
	}
d635 2
a636 5
      free (erelas);
    }
  else
    {
      Elf64_External_Rela * erelas;
d638 5
a642 2
      GET_DATA_ALLOC (rel_offset, rel_size, erelas,
		      Elf64_External_Rela *, "relocs");
d644 6
a649 1
      nrelas = rel_size / sizeof (Elf64_External_Rela);
d651 1
a651 2
      relas = (Elf_Internal_Rela *)
	malloc (nrelas * sizeof (Elf_Internal_Rela));
d653 1
a653 4
      if (relas == NULL)
	{
	  error(_("out of memory parsing relocs"));
	  return 0;
d655 1
a655 2

      for (i = 0; i < nrelas; i++)
d657 1
a657 4
	  relas[i].r_offset = BYTE_GET8 (erelas[i].r_offset);
	  relas[i].r_info   = BYTE_GET8 (erelas[i].r_info);
	  relas[i].r_addend = BYTE_GET8 (erelas[i].r_addend);
	}
d659 2
a660 6
      free (erelas);
    }
  *relasp = relas;
  *nrelasp = nrelas;
  return 1;
}
d662 1
a662 11
static int
slurp_rel_relocs (file, rel_offset, rel_size, relsp, nrelsp)
     FILE *file;
     unsigned long rel_offset;
     unsigned long rel_size;
     Elf_Internal_Rel **relsp;
     unsigned long *nrelsp;
{
  Elf_Internal_Rel *rels;
  unsigned long nrels;
  unsigned int i;
d664 2
a665 3
  if (is_32bit_elf)
    {
      Elf32_External_Rel * erels;
d667 5
a671 2
      GET_DATA_ALLOC (rel_offset, rel_size, erels,
		      Elf32_External_Rel *, "relocs");
d673 6
a678 1
      nrels = rel_size / sizeof (Elf32_External_Rel);
d680 1
a680 7
      rels = (Elf_Internal_Rel *) malloc (nrels * sizeof (Elf_Internal_Rel));

      if (rels == NULL)
	{
	  error(_("out of memory parsing relocs"));
	  return 0;
	}
d682 1
a682 4
      for (i = 0; i < nrels; i++)
	{
	  rels[i].r_offset = BYTE_GET (erels[i].r_offset);
	  rels[i].r_info   = BYTE_GET (erels[i].r_info);
a683 2

      free (erels);
d687 6
a692 1
      Elf64_External_Rel * erels;
d694 1
a694 2
      GET_DATA_ALLOC (rel_offset, rel_size, erels,
		      Elf64_External_Rel *, "relocs");
d696 2
a697 1
      nrels = rel_size / sizeof (Elf64_External_Rel);
d699 11
a709 1
      rels = (Elf_Internal_Rel *) malloc (nrels * sizeof (Elf_Internal_Rel));
d711 5
a715 1
      if (rels == NULL)
d717 4
a720 3
	  error(_("out of memory parsing relocs"));
	  return 0;
	}
d722 1
a722 5
      for (i = 0; i < nrels; i++)
	{
	  rels[i].r_offset = BYTE_GET8 (erels[i].r_offset);
	  rels[i].r_info   = BYTE_GET8 (erels[i].r_info);
	}
d724 2
a725 6
      free (erels);
    }
  *relsp = rels;
  *nrelsp = nrels;
  return 1;
}
d727 5
a731 14
/* Display the contents of the relocation data found at the specified offset.  */
static int
dump_relocations (file, rel_offset, rel_size, symtab, nsyms, strtab, is_rela)
     FILE *             file;
     unsigned long      rel_offset;
     unsigned long      rel_size;
     Elf_Internal_Sym * symtab;
     unsigned long      nsyms;
     char *             strtab;
     int                is_rela;
{
  unsigned int        i;
  Elf_Internal_Rel *  rels;
  Elf_Internal_Rela * relas;
d733 5
d739 1
a739 2
  if (is_rela == UNKNOWN)
    is_rela = guess_is_rela (elf_header.e_machine);
d741 2
a742 9
  if (is_rela)
    {
      if (!slurp_rela_relocs (file, rel_offset, rel_size, &relas, &rel_size))
	return 0;
    }
  else
    {
      if (!slurp_rel_relocs (file, rel_offset, rel_size, &rels, &rel_size))
	return 0;
d867 1
a867 1
	case EM_MIPS_RS3_LE:
d959 1
a959 4
  if (is_rela)
    free (relas);
  else
    free (rels);
d1136 1
a1136 1
	    case EM_MIPS_RS3_LE:
d1211 11
a1221 11
    case EM_NONE:	return _("None");
    case EM_M32:	return "WE32100";
    case EM_SPARC:	return "Sparc";
    case EM_386:	return "Intel 80386";
    case EM_68K:	return "MC68000";
    case EM_88K:	return "MC88000";
    case EM_486:	return "Intel 80486";
    case EM_860:	return "Intel 80860";
    case EM_MIPS:	return "MIPS R3000";
    case EM_S370:	return "IBM System/370";
    case EM_MIPS_RS3_LE:	return "MIPS R4000 big-endian";
d1223 1
a1223 1
    case EM_PARISC:	return "HPPA";
d1225 6
a1230 6
    case EM_SPARC32PLUS:	return "Sparc v8+" ;
    case EM_960:	return "Intel 90860";
    case EM_PPC:	return "PowerPC";
    case EM_V800:	return "NEC V800";
    case EM_FR20:	return "Fujitsu FR20";
    case EM_RH32:	return "TRW RH32";
d1232 5
a1236 5
    case EM_ARM:		return "ARM";
    case EM_OLD_ALPHA:		return "Digital Alpha (old)";
    case EM_SH:			return "Hitachi SH";
    case EM_SPARCV9:	return "Sparc v9";
    case EM_TRICORE:	return "Siemens Tricore";
d1246 1
a1246 1
    case EM_ALPHA:	return "Alpha";
d1256 18
a1273 18
    case EM_MMA:		return "Fujitsu Multimedia Accelerator";
    case EM_PCP:		return "Siemens PCP";
    case EM_NCPU:		return "Sony nCPU embedded RISC processor";
    case EM_NDR1:		return "Denso NDR1 microprocesspr";
    case EM_STARCORE:		return "Motorola Star*Core processor";
    case EM_ME16:		return "Toyota ME16 processor";
    case EM_ST100:		return "STMicroelectronics ST100 processor";
    case EM_TINYJ:		return "Advanced Logic Corp. TinyJ embedded processor";
    case EM_FX66:		return "Siemens FX66 microcontroller";
    case EM_ST9PLUS:		return "STMicroelectronics ST9+ 8/16 bit microcontroller";
    case EM_ST7:		return "STMicroelectronics ST7 8-bit microcontroller";
    case EM_68HC16:		return "Motorola MC68HC16 Microcontroller";
    case EM_68HC11:		return "Motorola MC68HC11 Microcontroller";
    case EM_68HC08:		return "Motorola MC68HC08 Microcontroller";
    case EM_68HC05:		return "Motorola MC68HC05 Microcontroller";
    case EM_SVX:		return "Silicon Graphics SVx";
    case EM_ST19:		return "STMicroelectronics ST19 8-bit microcontroller";
    case EM_VAX:		return "Digital VAX";
d1276 3
a1278 3
    case EM_JAVELIN:	return "Infineon Technologies 32-bit embedded cpu";
    case EM_FIREPATH:	return "Element 14 64-bit DSP processor";
    case EM_ZSP:	return "LSI Logic's 16-bit DSP processor";
d1280 2
a1281 2
    case EM_HUANY:	return "Harvard Universitys's machine-independent object format";
    case EM_PRISM:	return "SiTera Prism";
d1459 1
a1459 1
	case EM_MIPS_RS3_LE:
a1567 15

	case EM_IA_64:
	  if ((e_flags & EF_IA_64_ABI64))
	    strcat (buf, ", 64-bit");
	  else
	    strcat (buf, ", 32-bit");
	  if ((e_flags & EF_IA_64_REDUCEDFP))
	    strcat (buf, ", reduced fp model");
	  if ((e_flags & EF_IA_64_NOFUNCDESC_CONS_GP))
	    strcat (buf, ", no function descriptors, constant gp");
	  else if ((e_flags & EF_IA_64_CONS_GP))
	    strcat (buf, ", constant gp");
	  if ((e_flags & EF_IA_64_ABSOLUTE))
	    strcat (buf, ", absolute");
	  break;
a1620 15
get_ia64_segment_type (type)
     unsigned long type;
{
  switch (type)
    {
    case PT_IA_64_ARCHEXT:	return "IA_64_ARCHEXT";
    case PT_IA_64_UNWIND:	return "IA_64_UNWIND";
    default:
      break;
    }

  return NULL;
}

static const char *
d1644 1
a1644 1
	    case EM_MIPS_RS3_LE:
a1649 3
	    case EM_IA_64:
	      result = get_ia64_segment_type (p_type);
	      break;
a1752 14
get_ia64_section_type_name (sh_type)
     unsigned int sh_type;
{
  switch (sh_type)
    {
    case SHT_IA_64_EXT:		return "IA_64_EXT";
    case SHT_IA_64_UNWIND:	return "IA_64_UNWIND";
    default:
      break;
    }
  return NULL;
}

static const char *
d1793 1
a1793 1
	    case EM_MIPS_RS3_LE:
a1798 3
	    case EM_IA_64:
	      result = get_ia64_section_type_name (sh_type);
	      break;
a1839 1
  {"unwind",	       no_argument, 0, 'u'},
a1863 1
  fprintf (stdout, _("  -u or --unwind            Display the unwind info (if present)\n"));
d1926 1
a1926 1
	  (argc, argv, "ersuahnldSDAIw::x:i:vV", options, NULL)) != EOF)
a1942 1
	  do_unwind ++;
a1965 3
	case 'u':
	  do_unwind ++;
	  break;
d2030 1
a2031 2
		  do_debug_frames_interp = 1;
		case 'f':
d2068 1
a2068 1
  if (!do_dynamic && !do_syms && !do_reloc && !do_unwind && !do_sections
d2761 1
a2761 2
		|| do_debug_lines || do_debug_pubnames || do_debug_aranges
		|| do_debug_frames)
d2915 2
a2916 2
      unsigned long		i;
      int		found = 0;
a2978 425
#include "unwind-ia64.h"

/* An absolute address consists of a section and an offset.  If the
   section is NULL, the offset itself is the address, otherwise, the
   address equals to LOAD_ADDRESS(section) + offset.  */

struct absaddr
  {
    unsigned short section;
    bfd_vma offset;
  };

struct unw_aux_info
  {
    struct unw_table_entry
      {
	struct absaddr    start;
	struct absaddr    end;
	struct absaddr    info;
      }
    *table;				/* Unwind table.  */
    unsigned long         table_len;	/* Length of unwind table.  */
    unsigned char *       info;		/* Unwind info.  */
    unsigned long         info_size;	/* Size of unwind info.  */
    bfd_vma               info_addr;	/* starting address of unwind info.  */
    bfd_vma               seg_base;	/* Starting address of segment.  */
    Elf_Internal_Sym *    symtab;	/* The symbol table.  */
    unsigned              long nsyms;	/* Number of symbols.  */
    char *                strtab;	/* The string table.  */
    unsigned long         strtab_size;	/* Size of string table.  */
  };

static void find_symbol_for_address PARAMS ((struct unw_aux_info *,
					     struct absaddr, const char **,
					     bfd_vma *));
static void dump_ia64_unwind PARAMS ((struct unw_aux_info *));
static int  slurp_ia64_unwind_table PARAMS ((FILE *, struct unw_aux_info *,
					    Elf32_Internal_Shdr *));

static void
find_symbol_for_address (aux, addr, symname, offset)
     struct unw_aux_info *aux;
     struct absaddr addr;
     const char **symname;
     bfd_vma *offset;
{
  bfd_vma dist = (bfd_vma) 0x100000;
  Elf_Internal_Sym *sym, *best = NULL;
  unsigned long i;

  for (i = 0, sym = aux->symtab; i < aux->nsyms; ++i, ++sym)
    {
      if (ELF_ST_TYPE (sym->st_info) == STT_FUNC
	  && sym->st_name != 0
	  && (addr.section == SHN_UNDEF || addr.section == sym->st_shndx)
	  && addr.offset >= sym->st_value
	  && addr.offset - sym->st_value < dist)
	{
	  best = sym;
	  dist = addr.offset - sym->st_value;
	  if (!dist)
	    break;
	}
    }
  if (best)
    {
      *symname = (best->st_name >= aux->strtab_size
		  ? "<corrupt>" : aux->strtab + best->st_name);
      *offset = dist;
      return;
    }
  *symname = NULL;
  *offset = addr.offset;
}

static void
dump_ia64_unwind (aux)
     struct unw_aux_info *aux;
{
  bfd_vma addr_size;
  struct unw_table_entry * tp;
  int in_body;

  addr_size = is_32bit_elf ? 4 : 8;

  for (tp = aux->table; tp < aux->table + aux->table_len; ++tp)
    {
      bfd_vma stamp;
      bfd_vma offset;
      const unsigned char * dp;
      const unsigned char * head;
      const char * procname;

      find_symbol_for_address (aux, tp->start, &procname, &offset);

      fputs ("\n<", stdout);

      if (procname)
	{
	  fputs (procname, stdout);

	  if (offset)
	    printf ("+%lx", (unsigned long) offset);
	}

      fputs (">: [", stdout);
      print_vma (tp->start.offset, PREFIX_HEX);
      fputc ('-', stdout);
      print_vma (tp->end.offset, PREFIX_HEX);
      printf ("), info at +0x%lx\n",
	      (unsigned long) (tp->info.offset - aux->seg_base));

      head = aux->info + (tp->info.offset - aux->info_addr);
      stamp = BYTE_GET8 ((unsigned char *) head);

      printf ("  v%u, flags=0x%lx (%s%s ), len=%lu bytes\n",
	      (unsigned) UNW_VER (stamp),
	      (unsigned long) ((stamp & UNW_FLAG_MASK) >> 32),
	      UNW_FLAG_EHANDLER (stamp) ? " ehandler" : "",
	      UNW_FLAG_UHANDLER (stamp) ? " uhandler" : "",
	      (unsigned long) (addr_size * UNW_LENGTH (stamp)));

      if (UNW_VER (stamp) != 1)
	{
	  printf ("\tUnknown version.\n");
	  continue;
	}

      in_body = 0;
      for (dp = head + 8; dp < head + 8 + addr_size * UNW_LENGTH (stamp);)
	dp = unw_decode (dp, in_body, & in_body);
    }
}

static int
slurp_ia64_unwind_table (file, aux, sec)
     FILE *file;
     struct unw_aux_info *aux;
     Elf32_Internal_Shdr *sec;
{
  unsigned long size, addr_size, nrelas, i;
  Elf_Internal_Phdr *prog_hdrs, *seg;
  struct unw_table_entry *tep;
  Elf32_Internal_Shdr *relsec;
  Elf_Internal_Rela *rela, *rp;
  unsigned char *table, *tp;
  Elf_Internal_Sym *sym;
  const char *relname;
  int result;

  addr_size = is_32bit_elf ? 4 : 8;

  /* First, find the starting address of the segment that includes
     this section: */

  if (elf_header.e_phnum)
    {
      prog_hdrs = (Elf_Internal_Phdr *)
	xmalloc (elf_header.e_phnum * sizeof (Elf_Internal_Phdr));

      if (is_32bit_elf)
	result = get_32bit_program_headers (file, prog_hdrs);
      else
	result = get_64bit_program_headers (file, prog_hdrs);

      if (!result)
	{
	  free (prog_hdrs);
	  return 0;
	}

      for (seg = prog_hdrs; seg < prog_hdrs + elf_header.e_phnum; ++seg)
	{
	  if (seg->p_type != PT_LOAD)
	    continue;

	  if (sec->sh_addr >= seg->p_vaddr
	      && (sec->sh_addr + sec->sh_size <= seg->p_vaddr + seg->p_memsz))
	    {
	      aux->seg_base = seg->p_vaddr;
	      break;
	    }
	}

      free (prog_hdrs);
    }

  /* Second, build the unwind table from the contents of the unwind section:  */
  size = sec->sh_size;
  GET_DATA_ALLOC (sec->sh_offset, size, table, char *, "unwind table");

  tep = aux->table = xmalloc (size / (3 * addr_size) * sizeof (aux->table[0]));
  for (tp = table; tp < table + size; tp += 3 * addr_size, ++ tep)
    {
      tep->start.section = SHN_UNDEF;
      tep->end.section   = SHN_UNDEF;
      tep->info.section  = SHN_UNDEF;
      if (is_32bit_elf)
	{
	  tep->start.offset = byte_get ((unsigned char *) tp + 0, 4);
	  tep->end.offset   = byte_get ((unsigned char *) tp + 4, 4);
	  tep->info.offset  = byte_get ((unsigned char *) tp + 8, 4);
	}
      else
	{
	  tep->start.offset = BYTE_GET8 ((unsigned char *) tp +  0);
	  tep->end.offset   = BYTE_GET8 ((unsigned char *) tp +  8);
	  tep->info.offset  = BYTE_GET8 ((unsigned char *) tp + 16);
	}
      tep->start.offset += aux->seg_base;
      tep->end.offset   += aux->seg_base;
      tep->info.offset  += aux->seg_base;
    }
  free (table);

  /* Third, apply any relocations to the unwind table: */

  for (relsec = section_headers;
       relsec < section_headers + elf_header.e_shnum;
       ++relsec)
    {
      if (relsec->sh_type != SHT_RELA
	  || section_headers + relsec->sh_info != sec)
	continue;

      if (!slurp_rela_relocs (file, relsec->sh_offset, relsec->sh_size,
			      & rela, & nrelas))
	return 0;

      for (rp = rela; rp < rela + nrelas; ++rp)
	{
	  if (is_32bit_elf)
	    {
	      relname = elf_ia64_reloc_type (ELF32_R_TYPE (rp->r_info));
	      sym = aux->symtab + ELF32_R_SYM (rp->r_info);

	      if (ELF32_ST_TYPE (sym->st_info) != STT_SECTION)
		{
		  warn (_("Skipping unexpected symbol type %u"),
			ELF32_ST_TYPE (sym->st_info));
		  continue;
		}
	    }
	  else
	    {
	      relname = elf_ia64_reloc_type (ELF64_R_TYPE (rp->r_info));
	      sym = aux->symtab + ELF64_R_SYM (rp->r_info);

	      if (ELF64_ST_TYPE (sym->st_info) != STT_SECTION)
		{
		  warn (_("Skipping unexpected symbol type %u"),
			ELF64_ST_TYPE (sym->st_info));
		  continue;
		}
	    }

	  if (strncmp (relname, "R_IA64_SEGREL", 13) != 0)
	    {
	      warn (_("Skipping unexpected relocation type %s"), relname);
	      continue;
	    }

	  i = rp->r_offset / (3 * addr_size);

	  switch (rp->r_offset/addr_size % 3)
	    {
	    case 0:
	      aux->table[i].start.section = sym->st_shndx;
	      aux->table[i].start.offset += rp->r_addend;
	      break;
	    case 1:
	      aux->table[i].end.section   = sym->st_shndx;
	      aux->table[i].end.offset   += rp->r_addend;
	      break;
	    case 2:
	      aux->table[i].info.section  = sym->st_shndx;
	      aux->table[i].info.offset  += rp->r_addend;
	      break;
	    default:
	      break;
	    }
	}

      free (rela);
    }

  aux->table_len = size / (3 * addr_size);
  return 1;
}

static int
process_unwind (file)
     FILE * file;
{
  Elf32_Internal_Shdr *sec, *unwsec = NULL, *strsec;
  unsigned long i, addr_size, unwcount = 0, unwstart = 0;
  struct unw_aux_info aux;

  if (!do_unwind)
    return 1;

  if (elf_header.e_machine != EM_IA_64)
    {
      printf (_("\nThere are no unwind sections in this file.\n"));
      return 1;
    }

  memset (& aux, 0, sizeof (aux));

  addr_size = is_32bit_elf ? 4 : 8;

  for (i = 0, sec = section_headers; i < elf_header.e_shnum; ++i, ++sec)
    {
      if (sec->sh_type == SHT_SYMTAB)
	{
	  aux.nsyms = sec->sh_size / sec->sh_entsize;
	  aux.symtab = GET_ELF_SYMBOLS (file, sec->sh_offset, aux.nsyms);

	  strsec = section_headers + sec->sh_link;
	  aux.strtab_size = strsec->sh_size;
	  GET_DATA_ALLOC (strsec->sh_offset, aux.strtab_size,
			  aux.strtab, char *, "string table");
	}
      else if (sec->sh_type == SHT_IA_64_UNWIND)
	unwcount++;
    }

  if (!unwcount)
    printf (_("\nThere are no unwind sections in this file.\n"));

  while (unwcount-- > 0)
    {
      char *suffix;
      size_t len, len2;

      for (i = unwstart, sec = section_headers + unwstart;
	   i < elf_header.e_shnum; ++i, ++sec)
	if (sec->sh_type == SHT_IA_64_UNWIND)
	  {
	    unwsec = sec;
	    break;
	  }

      unwstart = i + 1;
      len = sizeof (ELF_STRING_ia64_unwind_once) - 1;

      if (strncmp (SECTION_NAME (unwsec), ELF_STRING_ia64_unwind_once,
		   len) == 0)
	{
	  /* .gnu.linkonce.ia64unw.FOO -> .gnu.linkonce.ia64unwi.FOO */
	  len2 = sizeof (ELF_STRING_ia64_unwind_info_once) - 1;
	  suffix = SECTION_NAME (unwsec) + len;
	  for (i = 0, sec = section_headers; i < elf_header.e_shnum;
	       ++i, ++sec)
	    if (strncmp (SECTION_NAME (sec),
			 ELF_STRING_ia64_unwind_info_once, len2) == 0
		&& strcmp (SECTION_NAME (sec) + len2, suffix) == 0)
	      break;
	}
      else
	{
	  /* .IA_64.unwindFOO -> .IA_64.unwind_infoFOO
	     .IA_64.unwind or BAR -> .IA_64.unwind_info */
	  len = sizeof (ELF_STRING_ia64_unwind) - 1;
	  len2 = sizeof (ELF_STRING_ia64_unwind_info) - 1;
	  suffix = "";
	  if (strncmp (SECTION_NAME (unwsec), ELF_STRING_ia64_unwind,
		       len) == 0)
	    suffix = SECTION_NAME (unwsec) + len;
	  for (i = 0, sec = section_headers; i < elf_header.e_shnum;
	       ++i, ++sec)
	    if (strncmp (SECTION_NAME (sec),
			 ELF_STRING_ia64_unwind_info, len2) == 0
		&& strcmp (SECTION_NAME (sec) + len2, suffix) == 0)
	      break;
	}

      if (i == elf_header.e_shnum)
	{
	  printf (_("\nCould not find unwind info section for "));

	  if (string_table == NULL)
	    printf ("%d", unwsec->sh_name);
	  else
	    printf ("'%s'", SECTION_NAME (unwsec));
	}
      else
	{
	  aux.info_size = sec->sh_size;
	  aux.info_addr = sec->sh_addr;
	  GET_DATA_ALLOC (sec->sh_offset, aux.info_size, aux.info,
			  char *, "unwind info");

	  printf (_("\nUnwind section "));

	  if (string_table == NULL)
	    printf ("%d", unwsec->sh_name);
	  else
	    printf ("'%s'", SECTION_NAME (unwsec));

	  printf (_(" at offset 0x%lx contains %lu entries:\n"),
		  unwsec->sh_offset,
		  (unsigned long) (unwsec->sh_size / (3 * addr_size)));

	  (void) slurp_ia64_unwind_table (file, & aux, unwsec);

	  if (aux.table_len > 0)
	    dump_ia64_unwind (& aux);

	  if (aux.table)
	    free ((char *) aux.table);
	  if (aux.info)
	    free ((char *) aux.info);
	  aux.table = NULL;
	  aux.info = NULL;
	}
    }

  if (aux.symtab)
    free (aux.symtab);
  if (aux.strtab)
    free ((char *) aux.strtab);

  return 1;
}
d3714 1
a3714 1
		case EM_MIPS_RS3_LE:
d3954 6
a3959 6
	    int		total;
	    int		cnt;
	    unsigned char *		edata;
	    unsigned short *		data;
	    char *		strtab;
	    Elf_Internal_Sym *		symbols;
d6432 1
a6432 1
  int                  data_factor;
a6437 1
  unsigned char        fde_encoding;
d6499 1
a6499 1
  printf ("%08lx ", fc->pc_begin);
a6530 14
static int
size_of_encoded_value (encoding)
     int encoding;
{
  switch (encoding & 0x7)
    {
    default:	/* ??? */
    case 0:	return is_32bit_elf ? 4 : 8;
    case 2:	return 2;
    case 3:	return 4;
    case 4:	return 8;
    }
}

a6548 1
  int             addr_size = is_32bit_elf ? 4 : 8;
a6560 3
      unsigned char * augmentation_data = NULL;
      unsigned long   augmentation_data_len = 0;
      int	      encoded_ptr_size = addr_size;
d6571 2
a6574 2
	  int version;

d6586 5
a6590 1
	  version = *start++;
d6592 1
a6592 2
	  fc->augmentation = start;
	  start = strchr (start, '\0') + 1;
d6596 1
d6600 3
a6602 3
	      augmentation_data_len = LEB ();
	      augmentation_data = start;
	      start += augmentation_data_len;
d6606 1
a6606 1
	      start += addr_size;
d6618 2
a6619 49

	  if (do_debug_frames_interp)
	    printf ("\n%08lx %08lx %08lx CIE \"%s\" cf=%d df=%d ra=%d\n",
		    (unsigned long)(saved_start - section_start), length, cie_id,
		    fc->augmentation, fc->code_factor, fc->data_factor,
		    fc->ra);
	  else
	    {
	      printf ("\n%08lx %08lx %08lx CIE\n",
		      (unsigned long)(saved_start - section_start), length, cie_id);
	      printf ("  Version:               %d\n", version);
	      printf ("  Augmentation:          \"%s\"\n", fc->augmentation);
	      printf ("  Code alignment factor: %u\n", fc->code_factor);
	      printf ("  Data alignment factor: %d\n", fc->data_factor);
	      printf ("  Return address column: %d\n", fc->ra);

	      if (augmentation_data_len)
		{
		  unsigned long i;
		  printf ("  Augmentation data:    ");
		  for (i = 0; i < augmentation_data_len; ++i)
		    printf (" %02x", augmentation_data[i]);
		  putchar ('\n');
		}
	      putchar ('\n');
	    }

	  if (augmentation_data_len)
	    {
	      unsigned char *p, *q;
	      p = fc->augmentation + 1;
	      q = augmentation_data;

	      while (1)
		{
		  if (*p == 'L')
		    q++;
		  else if (*p == 'P')
		    q += 1 + size_of_encoded_value (*q);
		  else if (*p == 'R')
		    fc->fde_encoding = *q++;
		  else
		    break;
		  p++;
		}

	      if (fc->fde_encoding)
		encoded_ptr_size = size_of_encoded_value (fc->fde_encoding);
	    }
d6631 1
a6631 1
	  look_for = is_eh ? start - 4 - cie_id : section_start + cie_id;
d6633 2
a6634 3
	  for (cie=chunks; cie ; cie = cie->next)
	    if (cie->chunk_start == look_for)
	      break;
d6636 1
d6639 1
a6639 2
	      warn ("Invalid CIE pointer %08lx in FDE at %08lx\n",
		    cie_id, saved_start);
a6646 1
	      fc->fde_encoding = 0;
a6661 1
	      fc->fde_encoding = cie->fde_encoding;
a6663 8
	  if (fc->fde_encoding)
	    encoded_ptr_size = size_of_encoded_value (fc->fde_encoding);

	  fc->pc_begin = byte_get (start, encoded_ptr_size);
	  start += encoded_ptr_size;
	  fc->pc_range = byte_get (start, encoded_ptr_size);
	  start += encoded_ptr_size;

d6666 2
a6667 3
	      augmentation_data_len = LEB ();
	      augmentation_data = start;
	      start += augmentation_data_len;
d6670 2
a6671 3
	  printf ("\n%08lx %08lx %08lx FDE cie=%08x pc=%08lx..%08lx\n",
		  (unsigned long)(saved_start - section_start), length, cie_id,
		  cie->chunk_start - section_start, fc->pc_begin,
a6672 9
	  if (! do_debug_frames_interp && augmentation_data_len)
	    {
	      unsigned long i;
	      printf ("  Augmentation data:    ");
	      for (i = 0; i < augmentation_data_len; ++i)
	        printf (" %02x", augmentation_data[i]);
	      putchar ('\n');
	      putchar ('\n');
	    }
d6678 3
a6680 1
      if (do_debug_frames_interp)
d6690 2
a6691 1

d6696 1
a6696 1

d6713 1
a6713 1
		start += encoded_ptr_size;
d6763 1
a6763 1
		break;
d6768 1
a6768 1
		reg = LEB (); LEB ();
d6771 1
a6771 1

d6799 5
a6803 6
	      if (do_debug_frames_interp)
	        frame_display_row (fc, &need_col_headers, &max_regs);
	      else
	        printf ("  DW_CFA_advance_loc: %d to %08lx\n",
		        opa * fc->code_factor,
			fc->pc_begin + opa * fc->code_factor);
d6809 3
a6811 3
	      if (! do_debug_frames_interp)
	        printf ("  DW_CFA_offset: r%d at cfa%+ld\n",
			opa, roffs * fc->data_factor);
d6817 3
a6819 2
	      if (! do_debug_frames_interp)
	        printf ("  DW_CFA_restore: r%d\n", opa);
d6825 5
a6829 6
	      vma = byte_get (start, encoded_ptr_size);
	      start += encoded_ptr_size;
	      if (do_debug_frames_interp)
	        frame_display_row (fc, &need_col_headers, &max_regs);
	      else
	        printf ("  DW_CFA_set_loc: %08lx\n", (unsigned long)vma);
d6834 1
d6836 4
a6839 6
	      if (do_debug_frames_interp)
	        frame_display_row (fc, &need_col_headers, &max_regs);
	      else
	        printf ("  DW_CFA_advance_loc1: %ld to %08lx\n",
		        ofs * fc->code_factor,
			fc->pc_begin + ofs * fc->code_factor);
d6844 1
d6846 4
a6849 6
	      if (do_debug_frames_interp)
	        frame_display_row (fc, &need_col_headers, &max_regs);
	      else
	        printf ("  DW_CFA_advance_loc2: %ld to %08lx\n",
		        ofs * fc->code_factor,
			fc->pc_begin + ofs * fc->code_factor);
d6854 1
d6856 4
a6859 6
	      if (do_debug_frames_interp)
	        frame_display_row (fc, &need_col_headers, &max_regs);
	      else
	        printf ("  DW_CFA_advance_loc4: %ld to %08lx\n",
		        ofs * fc->code_factor,
			fc->pc_begin + ofs * fc->code_factor);
d6866 3
a6868 3
	      if (! do_debug_frames_interp)
		printf ("  DW_CFA_offset_extended: r%ld at cfa%+ld\n",
			reg, roffs * fc->data_factor);
d6875 3
a6877 2
	      if (! do_debug_frames_interp)
	        printf ("  DW_CFA_restore_extended: r%ld\n", reg);
d6884 3
a6886 2
	      if (! do_debug_frames_interp)
	        printf ("  DW_CFA_undefined: r%ld\n", reg);
d6893 3
a6895 2
	      if (! do_debug_frames_interp)
	        printf ("  DW_CFA_same_value: r%ld\n", reg);
d6903 3
a6905 2
	      if (! do_debug_frames_interp)
	        printf ("  DW_CFA_register: r%ld\n", reg);
d6911 3
a6913 2
	      if (! do_debug_frames_interp)
	        printf ("  DW_CFA_remember_state\n");
d6925 3
a6927 2
	      if (! do_debug_frames_interp)
	        printf ("  DW_CFA_restore_state\n");
d6941 3
a6943 3
	      if (! do_debug_frames_interp)
	        printf ("  DW_CFA_def_cfa: r%d ofs %d\n",
			fc->cfa_reg, fc->cfa_offset);
d6948 3
a6950 2
	      if (! do_debug_frames_interp)
	        printf ("  DW_CFA_def_cfa_reg: r%d\n", fc->cfa_reg);
d6955 3
a6957 2
	      if (! do_debug_frames_interp)
	        printf ("  DW_CFA_def_cfa_offset: %d\n", fc->cfa_offset);
d6961 3
a6963 2
	      if (! do_debug_frames_interp)
	        printf ("  DW_CFA_nop\n");
d6970 3
a6972 2
	      if (! do_debug_frames_interp)
	        printf ("  DW_CFA_GNU_window_save\n");
d6975 3
d6980 3
a6982 2
	      if (! do_debug_frames_interp)
	        printf ("  DW_CFA_GNU_args_size: %ld\n", ul);
d6985 3
d6992 3
a6994 3
	      if (! do_debug_frames_interp)
	        printf ("  DW_CFA_GNU_negative_offset_extended: r%ld at cfa%+ld\n",
			reg, l * fc->data_factor);
d7005 1
a7005 2
      if (do_debug_frames_interp)
        frame_display_row (fc, &need_col_headers, &max_regs);
d7068 1
d7098 1
a7098 1
    name = ".debug_info";
d7125 1
a7125 1
  unsigned int	i;
d7607 1
a7607 1
	  pnote->descsz, get_note_type (pnote->type));
d7759 1
a7759 1
    case EM_MIPS_RS3_LE:
a7897 2

  process_unwind (file);
@


1.86.2.3
log
@Add DWARF 2.1 attributes
@
text
@d5 1
a5 1
   Modifications by Nick Clifton <nickc@@redhat.com>
a5898 14
      /* DWARF 2.1 values.  */
    case DW_AT_allocated: return "DW_AT_allocated";
    case DW_AT_associated: return "DW_AT_associated";
    case DW_AT_data_location: return "DW_AT_data_location";
    case DW_AT_stride: return "DW_AT_stride";
    case DW_AT_entry_pc: return "DW_AT_entry_pc";
    case DW_AT_use_UTF8: return "DW_AT_use_UTF8";
    case DW_AT_extension: return "DW_AT_extension";
    case DW_AT_ranges: return "DW_AT_ranges";
    case DW_AT_trampoline: return "DW_AT_trampoline";
    case DW_AT_call_column: return "DW_AT_call_column";
    case DW_AT_call_file: return "DW_AT_call_file";
    case DW_AT_call_line: return "DW_AT_call_line";
      /* SGI/MIPS extensions.  */
a5909 1
      /* GNU extensions.  */
a6474 16
	  /* DWARF 2.1 extensions.  */
	case DW_OP_push_object_address:
	  printf ("DW_OP_push_object_address");
	  break;
	case DW_OP_call2:
	  printf ("DW_OP_call2: <%lx>", (long) byte_get (data, 2));
	  data += 2;
	  break;
	case DW_OP_call4:
	  printf ("DW_OP_call4: <%lx>", (long) byte_get (data, 4));
	  data += 4;
	  break;
	case DW_OP_calli:
	  printf ("DW_OP_calli");
	  break;

a6727 9
    case DW_AT_ordering:
      switch (uvalue)
	{
	case -1: printf ("(undefined)"); break;
	case 0:  printf ("(row major)"); break;
	case 1:  printf ("(column major)"); break;
	}
      break;

a6731 6
    case DW_AT_allocated:
    case DW_AT_associated:
    case DW_AT_data_location:
    case DW_AT_stride:
    case DW_AT_upper_bound:
    case DW_AT_lower_bound:
@


1.86.2.4
log
@Detect and warn about DWARF64 format .debug_arange sections
@
text
@a6947 6
      if (arange.ar_length == 0xffffffff)
	{
	  warn (_("DWARF64 aranges not currently supported.\n"));
	  break;
	}

@


1.86.2.5
log
@Detect and warna bout more 64bit DWARF debug sections
@
text
@a5492 7

      if (info.li_length == 0xffffffff)
	{
	  warn (_("64-bit DWARF line info is not supported yet.\n"));
	  break;
	}

a5720 6
      if (pubnames.pn_length == 0xffffffff)
	{
	  warn (_("64-bit DWARF pubnames are not supported yet.\n"));
	  break;
	}

a6820 6
      if (compunit.cu_length == 0xffffffff)
	{
	  warn (_("64-bit DWARF debug info is not supported yet.\n"));
	  break;
	}

d6950 1
a6950 1
	  warn (_("64-bit DWARF aranges are not supported yet.\n"));
a7164 6
      if (length == 0xffffffff)
	{
	  warn (_("64-bit DWARF format frames are not supported yet.\n"));
	  break;
	}

d7273 1
a7273 1
	  for (cie = chunks; cie ; cie = cie->next)
a7714 1
  { ".debug_pubtypes",    display_debug_not_supported, NULL },
@


1.85
log
@Prevent seg fault with corrupt section name indicies
@
text
@d4000 1
d4020 5
a4024 3
		      if (symbols [cnt + j].st_shndx < SHN_LORESERVE
			  && section_headers[symbols [cnt + j].st_shndx].sh_type
			  == SHT_NOBITS)
d4026 5
a4030 92
			  /* We must test both.  */
			  Elf_Internal_Verneed     ivn;
			  unsigned long            offset;

			  offset = version_info [DT_VERSIONTAGIDX (DT_VERNEED)]
			    - loadaddr;

			  do
			    {
			      Elf_External_Verneed   evn;
			      Elf_External_Vernaux   evna;
			      Elf_Internal_Vernaux   ivna;
			      unsigned long          vna_off;

			      GET_DATA (offset, evn, "version need");

			      ivn.vn_aux  = BYTE_GET (evn.vn_aux);
			      ivn.vn_next = BYTE_GET (evn.vn_next);

			      vna_off = offset + ivn.vn_aux;

			      do
				{
				  GET_DATA (vna_off, evna,
					    "version need aux (1)");

				  ivna.vna_next  = BYTE_GET (evna.vna_next);
				  ivna.vna_other = BYTE_GET (evna.vna_other);

				  vna_off += ivna.vna_next;
				}
			      while (ivna.vna_other != data [cnt + j]
				     && ivna.vna_next != 0);

			      if (ivna.vna_other == data [cnt + j])
				{
				  ivna.vna_name = BYTE_GET (evna.vna_name);

				  name = strtab + ivna.vna_name;
				  nn += printf ("(%s%-*s",
						name,
						12 - (int) strlen (name),
						")");
				  break;
				}
			      else if (ivn.vn_next == 0)
				{
				  if (data [cnt + j] != 0x8001)
				    {
				      Elf_Internal_Verdef  ivd;
				      Elf_External_Verdef  evd;

				      offset = version_info
					[DT_VERSIONTAGIDX (DT_VERDEF)]
					- loadaddr;

				      do
					{
					  GET_DATA (offset, evd,
						    "version definition");

					  ivd.vd_next = BYTE_GET (evd.vd_next);
					  ivd.vd_ndx  = BYTE_GET (evd.vd_ndx);

					  offset += ivd.vd_next;
					}
				      while (ivd.vd_ndx
					     != (data [cnt + j] & 0x7fff)
					     && ivd.vd_next != 0);

				      if (ivd.vd_ndx
					  == (data [cnt + j] & 0x7fff))
					{
					  Elf_External_Verdaux  evda;
					  Elf_Internal_Verdaux  ivda;

					  ivd.vd_aux = BYTE_GET (evd.vd_aux);

					  GET_DATA (offset + ivd.vd_aux, evda,
						    "version definition aux");

					  ivda.vda_name =
					    BYTE_GET (evda.vda_name);

					  name = strtab + ivda.vda_name;
					  nn +=
					    printf ("(%s%-*s",
						    name,
						    12 - (int) strlen (name),
						    ")");
					}
				    }
d4032 2
a4033 8
				  break;
				}
			      else
				offset += ivn.vn_next;
			    }
			  while (ivn.vn_next);
			}
		      else if (symbols [cnt + j].st_shndx == SHN_UNDEF)
d4077 1
d4085 3
a4087 1
		      else if (data [cnt + j] != 0x8001)
d4464 2
a4465 1
		      if (is_nobits || ! check_def)
d4523 2
a4524 1
			  if (vers_data != 0x8001)
@


1.84
log
@Add EM_X86_64.
@
text
@d2 1
a2 1
   Copyright (C) 1998, 99, 2000 Free Software Foundation, Inc.
d88 1
d236 3
a238 1
#define SECTION_NAME(X) 	(string_table + (X)->sh_name)
a2717 4
      unsigned long string_table_offset;

      string_table_offset = section->sh_offset;

d2720 2
d7449 1
a7449 1
	      string_table + sect->sh_name, cnt);
d8008 1
@


1.83
log
@Fix formatting.
@
text
@d76 1
d538 1
a539 1
/* Guess the relocation sized based on the sized commonly used by the specific machine.  */
d575 1
d899 4
d1279 1
@


1.82
log
@2000-12-07  Andrew Haley  <aph@@redhat.com>

        * readelf.c (display_debug_frames): Only display columns that are
        referenced by the frame debug info.
@
text
@d875 1
d1228 1
a1228 1
    case EM_ARC:		return "Argonaut RISC Core";
d1240 1
a1240 1
    case EM_CYGNUS_ARC:		return "Arc";
a1272 1
      
d4657 7
a4663 7
      int *lengths;
      int *counts;
      int hn;
      int si;
      int maxlength = 0;
      int nzero_counts = 0;
      int nsyms = 0;
d5681 1
a5681 1
  abbrev_entry * entry;
d5734 1
a5734 1
     unsigned long length;
d5736 4
a5739 4
  unsigned op;
  int           bytes_read;
  unsigned long uvalue;
  unsigned char *end = data + length;
d6470 1
a6470 1
      excess = sizeof (*external) % (2 * arange.ar_pointer_size);
d6501 3
a6503 3
  struct Frame_Chunk *next;
  unsigned char *chunk_start;
  int ncols;
d6505 10
a6514 10
  short int *col_type;
  int *col_offset;
  char *augmentation;
  unsigned int code_factor;
  unsigned int data_factor;
  unsigned long pc_begin;
  unsigned long pc_range;
  int cfa_reg;
  int cfa_offset;
  int ra;
d6524 1
a6524 1
     Frame_Chunk *fc;
d6531 1
d6548 3
a6550 3
     Frame_Chunk *fc;
     int *need_col_headers;
     int *max_regs;
d6555 4
a6558 3
  if (*max_regs < fc->ncols)
    *max_regs = fc->ncols;
  if (*need_col_headers)
d6560 2
a6561 1
      *need_col_headers = 0;
d6563 2
a6564 1
      for (r=0; r<*max_regs; r++)
d6572 1
d6575 1
d6579 2
a6580 1
  for (r=0; r<fc->ncols; r++)
d6609 2
a6610 2
#define LEB()	read_leb128 (start, &length_return, 0); start += length_return
#define SLEB()	read_leb128 (start, &length_return, 1); start += length_return
d6619 7
a6625 6
  unsigned char *section_start = start;
  Frame_Chunk *chunks = 0;
  Frame_Chunk *remembered_state = 0, *rs;
  int is_eh = (strcmp (SECTION_NAME (section), ".eh_frame") == 0);
  int length_return;
  int max_regs = 0;
d6631 7
a6637 4
      unsigned char *saved_start, *block_end;
      unsigned long length, cie_id;
      Frame_Chunk *fc, *cie;
      int need_col_headers = 1;
d6665 6
a6670 1
	  while (*start) start++; start++; /* skip past NUL */
d6702 1
a6702 1
	  unsigned char *look_for;
d6704 2
a6705 1
	  fc = &fde_fc;
d6721 1
a6721 1
	      frame_need_space (fc, max_regs-1);
d6761 1
a6762 1
	unsigned char *tmp = start;
d6769 1
a6769 1
	    op = *start++;
d7176 1
d7413 1
a7413 1
					      * sizeof (*iopt));
d7460 2
a7461 2
		  Elf32_External_RegInfo *ereg;
		  Elf32_RegInfo reginfo;
d7578 1
a7578 1
	  len = sizeof (*eopt);
d7606 1
a7606 1
      iconf = (Elf32_Conflict *) malloc (conflictsno * sizeof (*iconf));
d7615 1
a7615 1
	  GET_DATA_ALLOC (conflicts_offset, conflictsno * sizeof (*econf32),
d7623 1
a7623 1
	  GET_DATA_ALLOC (conflicts_offset, conflictsno * sizeof (*econf64),
@


1.81
log
@        * readelf.c (process_section_headers): Handle linkonce.wi sections.
        (display_debug_section): Likewise.
        (display_debug_info): Display CU header before bailing.
@
text
@d6504 2
a6505 2
  /* DW_CFA_{undefined,same_value,offset,register}  */
  unsigned char *col_type;
d6518 4
d6532 2
a6533 2
  fc->col_type = (unsigned char *) xrealloc (fc->col_type,
					     fc->ncols * sizeof (unsigned char));
d6539 1
a6539 1
      fc->col_type[prev] = DW_CFA_undefined;
d6561 7
a6567 4
	if (r == fc->ra)
	  printf ("ra   ");
	else
	  printf ("r%-4d", r);
d6575 1
a6575 1
      switch (fc->col_type[r])
d6577 19
a6595 15
	case DW_CFA_undefined:
	  strcpy (tmp, "u");
	  break;
	case DW_CFA_same_value:
	  strcpy (tmp, "s");
	  break;
	case DW_CFA_offset:
	  sprintf (tmp, "c%+d", fc->col_offset[r]);
	  break;
	case DW_CFA_register:
	  sprintf (tmp, "r%d", fc->col_offset[r]);
	  break;
	default:
	  strcpy (tmp, "n/a");
	  break;
a6596 1
      printf ("%-5s", tmp);
d6648 1
a6648 1
	  fc->col_type = (unsigned char *) xmalloc (sizeof (unsigned char));
d6702 1
a6702 1
	      fc->col_type = (unsigned char *) xmalloc (sizeof (unsigned char));
d6711 1
a6711 1
	      fc->col_type = (unsigned char *) xmalloc (fc->ncols * sizeof (unsigned char));
d6713 1
a6713 1
	      memcpy (fc->col_type, cie->col_type, fc->ncols);
d6741 101
d6854 2
a6867 1
	      frame_need_space (fc, opa);
a6876 1
	      frame_need_space (fc, opa);
a6925 1
	      frame_need_space (fc, reg);
a6934 1
	      frame_need_space (fc, reg);
a6943 1
	      frame_need_space (fc, reg);
a6952 1
	      frame_need_space (fc, reg);
a6962 1
	      frame_need_space (fc, reg);
d6964 1
a6964 1
	      printf ("  DW_CFA_ame_value: r%d\n", reg);
d6976 1
a6976 1
	      rs->col_type = (unsigned char *) xmalloc (rs->ncols);
@


1.80
log
@Add MIPS SB1 machine
@
text
@d2768 4
d6330 6
a6341 6
      printf (_("  Compilation Unit:\n"));
      printf (_("   Length:        %ld\n"), compunit.cu_length);
      printf (_("   Version:       %d\n"), compunit.cu_version);
      printf (_("   Abbrev Offset: %ld\n"), compunit.cu_abbrev_offset);
      printf (_("   Pointer Size:  %d\n"), compunit.cu_pointer_size);

d7051 2
@


1.79
log
@Add MIPS V and MIPS 64 machine numbers
@
text
@d1491 1
@


1.78
log
@Add MIPS32 as a seperate MIPS architecture
@
text
@d1474 3
d1479 3
@


1.77
log
@* readelf.c (frame_display_row): Output 's' for DW_CFA_same_value.
@
text
@d1474 3
d1484 2
a1485 1
	    case E_MIPS_MACH_MIPS32: strcat (buf, ", mips32"); break;
@


1.76
log
@oops, forgot a semicolon
@
text
@d6559 1
a6559 1
	  strcpy (tmp, "u");
@


1.75
log
@* readelf.c (usage): Add -wf (--debug-dump=frames) option.
(parse_args): Support -wf option.
(process_section_headers): Ditto.
(debug_displays): Ditto.
(display_debug_frames): New, dump *_frame sections.
(frame_need_space): Support for above.
(frame_display_row): Ditto.
* binutils.texi: Document it.
@
text
@d6498 1
a6498 1
  int cfa_offset
@


1.74
log
@Add new machien types and section flags
@
text
@d116 1
d201 1
d1849 1
a1849 1
  fprintf (stdout, _("  -w[liapr] or --debug-dump[=line,=info,=abbrev,=pubnames,=ranges]\n"));
d2009 5
d2742 1
a2742 1
		|| do_debug_lines || do_debug_pubnames || do_debug_aranges)
d2753 1
d2757 2
d6484 473
d7004 2
@


1.73
log
@2000-11-20  H.J. Lu  <hjl@@gnu.org>

	* readelf.c (get_osabi_name): Change ELFOSABI_MONTEREY to
	ELFOSABI_AIX.
@
text
@d1264 7
d1752 2
d2634 1
d2785 1
a2785 1
	  printf (" %2ld %3lx %ld\n",
d2809 4
a2812 3
  printf (_("Key to Flags: W (write), A (alloc), X (execute), M (merge), S (strings)\n"));
  printf (_("              I (info), L (link order), O (extra OS processing required)\n"));
  printf (_("              o (os specific), p (processor specific) x (unknown)\n"));
@


1.72
log
@        * readelf.c (display_debug_lines): Adjust last change to
        use sizeof (external->li_length).
@
text
@d2090 1
a2090 1
    case ELFOSABI_MONTEREY:   return _("UNIX - Monterey");
@


1.71
log
@        * readelf.c (display_debug_lines): Fix section length check
        and end_of_sequence computation.
@
text
@d5008 1
a5008 1
      if (info.li_length + 4 > section->sh_size)
d5043 1
a5043 1
      end_of_sequence = data + info.li_length + 4;
@


1.70
log
@Remove extraneous whitepaces
@
text
@d5008 1
a5008 1
      if (info.li_length > section->sh_size)
d5043 1
a5043 1
      end_of_sequence = data + info.li_length + sizeof (info.li_length);
@


1.69
log
@Add support for the MIPS32
@
text
@d426 1
a426 1
	  
d430 1
a430 1
	  
d434 1
a434 1
	  
d455 1
a455 1
#endif	  
d467 1
a467 1
#endif	  
d469 1
a469 1
	  
d473 1
a473 1
#else	  
d1287 1
a1287 1
	      
d1293 1
a1293 1
  
d1307 1
a1307 1
	  
d1311 1
a1311 1
	  
d1317 1
a1317 1
	      
d1324 1
a1324 1
      
d1329 1
a1329 1
	  
d1333 1
a1333 1
	  
d1339 1
a1339 1
	  
d1343 1
a1343 1
	  
d1347 1
a1347 1
	  
d1351 1
a1351 1
	  
d1355 1
a1355 1
	  
d1359 1
a1359 1
	  
d1363 1
a1363 1
	  
d1367 1
a1367 1
	  
d1387 1
a1387 1
  
d1398 1
a1398 1
	  
d1530 1
a1530 1
	  
d2148 1
a2148 1
      
d2156 1
a2156 1
	
d2294 1
a2294 1
      
d2607 1
a2607 1
  
d2614 1
a2614 1
      
d2625 1
a2625 1
	  
d2642 1
a2642 1
  
d2745 1
a2745 1
  
d2767 1
a2767 1
      
d2774 1
a2774 1
		  
d2789 1
a2789 1
	  
d2791 1
a2791 1
		  
d3051 1
a3051 1
	
d3060 1
a3060 1
      
d3352 1
a3352 1
	  
d4416 1
a4416 1
		      
d5245 1
a5245 1
	  
d6021 1
a6021 1
      
d6063 1
a6063 1
      
d6785 1
a6785 1
      
d6798 1
a6798 1
	  
d6807 1
a6807 1
      
d7084 1
a7084 1
      
d7094 1
a7094 1
	  
d7101 1
a7101 1
	  
d7104 1
a7104 1
	  
@


1.68
log
@Catch and warn about attempts to display debug information for version 1 aranges.
@
text
@d1464 10
@


1.67
log
@2000-08-05  Jason Eckhardt  <jle@@cygnus.com>

        * readelf.c (elf/i860.h): Include.
        (dump_relocations): Add recognition of i860 architecture.
        (guess_is_rela): Add recognition of i860 architecture.
@
text
@d5228 8
a5235 1
	  warn (_("Only DWARF 2 pubnames are currently supported"));
d6406 6
@


1.66
log
@	* MAINTAINERS: Add self as CRIS port maintainer.
	* readelf.c: Include elf/cris.h.
	(guess_is_rela): Handle EM_CRIS.
	(dump_relocations): Ditto.
	(get_machine_name): Ditto.
	* Makefile.am: Rebuild dependencies.
	* Makefile.in: Regenerate.
	* po/binutils.pot: Regenerate.
@
text
@d75 1
d571 1
d889 4
@


1.65
log
@2000-07-19  H.J. Lu  <hjl@@gnu.org>

	* readelf.c (get_dynamic_type): Change "AUXILARY" to
	"AUXILIARY".
	(process_dynamic_segment): Print out strings for DT_CONFIG,
	DT_DEPAUDIT, DT_AUDIT and DT_RUNPATH.
@
text
@d74 1
d569 1
d884 4
d1257 1
@


1.64
log
@2000-07-19  H.J. Lu  <hjl@@gnu.org>

	* readelf.c (process_dynamic_segment): Change DF_1_NODEPLIB
	to DF_1_NODEFLIB.
@
text
@d1100 1
a1100 1
    case DT_AUXILIARY:	return "AUXILARY";
d3332 3
d3337 22
a3358 4
	      if (entry->d_tag == DT_AUXILIARY)
		printf (_("Auxiliary library"));
	      else
		printf (_("Filter library"));
d3530 1
d3559 4
@


1.63
log
@2000-07-19  H.J. Lu  <hjl@@gnu.org>

	* readelf.c (get_dynamic_type): Fix DT_CHECKSUM.
@
text
@d3466 1
a3466 1
		  if (val & DF_1_NODEPLIB)
d3468 2
a3469 2
		      printf (" NODEPLIB");
		      val ^= DF_1_NODEPLIB;
@


1.62
log
@2000-07-19  H.J. Lu  <hjl@@gnu.org>

	* readelf.c (get_dynamic_type): Change DT_FEATURE_1 to
	DT_FEATURE.
	(process_dynamic_segment): Likewise.

	* readelf.c (get_dynamic_type): Handle DT_CONFIG, DT_DEPAUDIT,
	DT_AUDIT, DT_PLTPAD, DT_MOVETAB and DT_CHECKSUM.
	(process_dynamic_segment): Handle DTF_1_CONFEXP, DF_1_NODEPLIB,
	DF_1_NODUMP and DF_1_CONLFAT.
@
text
@d1073 1
a1102 4

#if DT_CHECKSUM != 0
    case DT_CHECKSUM:	return "CHECKSUM";
#endif
@


1.61
log
@Warning fixes.
@
text
@d1076 1
a1076 1
    case DT_FEATURE_1:	return "FEATURE_1";
d1082 5
d1103 4
d3353 1
a3353 1
	case DT_FEATURE_1:
d3367 5
d3468 15
@


1.60
log
@Applied Stephane Carrez <Stephane.Carrez@@worldnet.fr> patches to add support
for m68hc11 and m68hc12 processors.
@
text
@d4233 1
a4233 1
  char * e_data;
d4236 1
a4236 1
  e_data = (char *) malloc (number * 4);
d4273 2
a4274 2
  char   nb [4];
  char   nc [4];
d4888 1
a4888 1
      data += strlen (data) + 1;
d4993 1
a4993 1
	      data += strlen (data) + 1;
d5010 1
a5010 1
	      char * name;
d5016 1
a5016 1
	      data += strlen (data) + 1;
d5186 1
a5186 1
	      data += strlen (data) + 1;
d6011 1
a6011 1
      data += strlen (data) + 1;
@


1.59
log
@2000-05-02  H.J. Lu  <hjl@@gnu.org>

	* readelf.c (get_osabi_name): Handle ELFOSABI_NONE instead of
	ELFOSABI_SYSV. Also handle ELFOSABI_NETBSD, ELFOSABI_HURD,
	ELFOSABI_SOLARIS, ELFOSABI_MONTEREY, ELFOSABI_IRIX,
	ELFOSABI_FREEBSD, ELFOSABI_TRU64, ELFOSABI_MODESTO
	and ELFOSABI_OPENBSD.
@
text
@d5937 3
@


1.58
log
@	* readelf.c (guess_is_rela): AVR uses RELA relocations.
	(get_machine_name): machine name for EM_AVR added.
@
text
@d2055 1
a2055 1
    case ELFOSABI_SYSV:       return _("UNIX - System V");
d2057 1
d2059 8
@


1.57
log
@IA-64 ELF support.
@
text
@d567 1
d1244 1
a1244 1
    case EM_AVR:                return "AVR";
@


1.56
log
@Portability fixes.
@
text
@d73 1
d566 1
d877 3
@


1.55
log
@Replace 'strftime' with 'sprintf'.
@
text
@a76 6
#ifdef ANSI_PROTOTYPES
#include <stdarg.h>
#else
#include <varargs.h>
#endif

@


1.54
log
@        * readelf.c (decode_location_expression): Loop through multiple
        operations.
        (read_and_display_attr): Pass in length.
@
text
@d2940 2
d2943 4
a2946 1
	strftime (timebuf, 20, "%Y-%m-%dT%H:%M:%S", gmtime (&time));
d6603 1
d6611 4
a6614 1
	  strftime (timebuf, 20, "%Y-%m-%dT%H:%M:%S", gmtime (&time));
@


1.53
log
@        * readelf.c (read_and_display_attr): Add CU offset to references.
        (display_debug_info): Pass it in.
@
text
@d215 1
a215 1
static void               decode_location_expression  PARAMS ((unsigned char *, unsigned int));
d5599 1
a5599 1
decode_location_expression (data, pointer_size)
d5602 1
d5604 1
a5604 1
  unsigned char op;
d5607 1
d5609 3
a5611 1
  op = * data ++;
d5613 280
a5892 441
  switch (op)
    {
    case DW_OP_addr:
      printf ("DW_OP_addr: %lx", (unsigned long) byte_get (data, pointer_size));
      break;
    case DW_OP_deref:
      printf ("DW_OP_deref");
      break;
    case DW_OP_const1u:
      printf ("DW_OP_const1u: %lu", (unsigned long) byte_get (data, 1));
      break;
    case DW_OP_const1s:
      printf ("DW_OP_const1s: %ld", (long) byte_get (data, 1));
      break;
    case DW_OP_const2u:
      printf ("DW_OP_const2u: %lu", (unsigned long) byte_get (data, 2));
      break;
    case DW_OP_const2s:
      printf ("DW_OP_const2s: %ld", (long) byte_get (data, 2));
      break;
    case DW_OP_const4u:
      printf ("DW_OP_const4u: %lu", (unsigned long) byte_get (data, 4));
      break;
    case DW_OP_const4s:
      printf ("DW_OP_const4s: %ld", (long) byte_get (data, 4));
      break;
    case DW_OP_const8u:
      printf ("DW_OP_const8u: %lu %lu", (unsigned long) byte_get (data, 4),
	      (unsigned long) byte_get (data + 4, 4));
      break;
    case DW_OP_const8s:
      printf ("DW_OP_const8s: %ld %ld", (long) byte_get (data, 4),
	      (long) byte_get (data + 4, 4));
      break;
    case DW_OP_constu:
      printf ("DW_OP_constu: %lu", read_leb128 (data, NULL, 0));
      break;
    case DW_OP_consts:
      printf ("DW_OP_consts: %ld", read_leb128 (data, NULL, 1));
      break;
    case DW_OP_dup:
      printf ("DW_OP_dup");
      break;
    case DW_OP_drop:
      printf ("DW_OP_drop");
      break;
    case DW_OP_over:
      printf ("DW_OP_over");
      break;
    case DW_OP_pick:
      printf ("DW_OP_pick: %ld", (unsigned long) byte_get (data, 1));
      break;
    case DW_OP_swap:
      printf ("DW_OP_swap");
      break;
    case DW_OP_rot:
      printf ("DW_OP_rot");
      break;
    case DW_OP_xderef:
      printf ("DW_OP_xderef");
      break;
    case DW_OP_abs:
      printf ("DW_OP_abs");
      break;
    case DW_OP_and:
      printf ("DW_OP_and");
      break;
    case DW_OP_div:
      printf ("DW_OP_div");
      break;
    case DW_OP_minus:
      printf ("DW_OP_minus");
      break;
    case DW_OP_mod:
      printf ("DW_OP_mod");
      break;
    case DW_OP_mul:
      printf ("DW_OP_mul");
      break;
    case DW_OP_neg:
      printf ("DW_OP_neg");
      break;
    case DW_OP_not:
      printf ("DW_OP_not");
      break;
    case DW_OP_or:
      printf ("DW_OP_or");
      break;
    case DW_OP_plus:
      printf ("DW_OP_plus");
      break;
    case DW_OP_plus_uconst:
      printf ("DW_OP_plus_uconst: %lu", read_leb128 (data, NULL, 0));
      break;
    case DW_OP_shl:
      printf ("DW_OP_shl");
      break;
    case DW_OP_shr:
      printf ("DW_OP_shr");
      break;
    case DW_OP_shra:
      printf ("DW_OP_shra");
      break;
    case DW_OP_xor:
      printf ("DW_OP_xor");
      break;
    case DW_OP_bra:
      printf ("DW_OP_bra: %ld", (long) byte_get (data, 2));
      break;
    case DW_OP_eq:
      printf ("DW_OP_eq");
      break;
    case DW_OP_ge:
      printf ("DW_OP_ge");
      break;
    case DW_OP_gt:
      printf ("DW_OP_gt");
      break;
    case DW_OP_le:
      printf ("DW_OP_le");
      break;
    case DW_OP_lt:
      printf ("DW_OP_lt");
      break;
    case DW_OP_ne:
      printf ("DW_OP_ne");
      break;
    case DW_OP_skip:
      printf ("DW_OP_skip: %ld", (long) byte_get (data, 2));
      break;
    case DW_OP_lit0:
      printf ("DW_OP_lit0");
      break;
    case DW_OP_lit1:
      printf ("DW_OP_lit1");
      break;
    case DW_OP_lit2:
      printf ("DW_OP_lit2");
      break;
    case DW_OP_lit3:
      printf ("DW_OP_lit3");
      break;
    case DW_OP_lit4:
      printf ("DW_OP_lit4");
      break;
    case DW_OP_lit5:
      printf ("DW_OP_lit5");
      break;
    case DW_OP_lit6:
      printf ("DW_OP_lit6");
      break;
    case DW_OP_lit7:
      printf ("DW_OP_lit7");
      break;
    case DW_OP_lit8:
      printf ("DW_OP_lit8");
      break;
    case DW_OP_lit9:
      printf ("DW_OP_lit9");
      break;
    case DW_OP_lit10:
      printf ("DW_OP_lit10");
      break;
    case DW_OP_lit11:
      printf ("DW_OP_lit11");
      break;
    case DW_OP_lit12:
      printf ("DW_OP_lit12");
      break;
    case DW_OP_lit13:
      printf ("DW_OP_lit13");
      break;
    case DW_OP_lit14:
      printf ("DW_OP_lit14");
      break;
    case DW_OP_lit15:
      printf ("DW_OP_lit15");
      break;
    case DW_OP_lit16:
      printf ("DW_OP_lit16");
      break;
    case DW_OP_lit17:
      printf ("DW_OP_lit17");
      break;
    case DW_OP_lit18:
      printf ("DW_OP_lit18");
      break;
    case DW_OP_lit19:
      printf ("DW_OP_lit19");
      break;
    case DW_OP_lit20:
      printf ("DW_OP_lit20");
      break;
    case DW_OP_lit21:
      printf ("DW_OP_lit21");
      break;
    case DW_OP_lit22:
      printf ("DW_OP_lit22");
      break;
    case DW_OP_lit23:
      printf ("DW_OP_lit23");
      break;
    case DW_OP_lit24:
      printf ("DW_OP_lit24");
      break;
    case DW_OP_lit25:
      printf ("DW_OP_lit25");
      break;
    case DW_OP_lit26:
      printf ("DW_OP_lit26");
      break;
    case DW_OP_lit27:
      printf ("DW_OP_lit27");
      break;
    case DW_OP_lit28:
      printf ("DW_OP_lit28");
      break;
    case DW_OP_lit29:
      printf ("DW_OP_lit29");
      break;
    case DW_OP_lit30:
      printf ("DW_OP_lit30");
      break;
    case DW_OP_lit31:
      printf ("DW_OP_lit31");
      break;
    case DW_OP_reg0:
      printf ("DW_OP_reg0");
      break;
    case DW_OP_reg1:
      printf ("DW_OP_reg1");
      break;
    case DW_OP_reg2:
      printf ("DW_OP_reg2");
      break;
    case DW_OP_reg3:
      printf ("DW_OP_reg3");
      break;
    case DW_OP_reg4:
      printf ("DW_OP_reg4");
      break;
    case DW_OP_reg5:
      printf ("DW_OP_reg5");
      break;
    case DW_OP_reg6:
      printf ("DW_OP_reg6");
      break;
    case DW_OP_reg7:
      printf ("DW_OP_reg7");
      break;
    case DW_OP_reg8:
      printf ("DW_OP_reg8");
      break;
    case DW_OP_reg9:
      printf ("DW_OP_reg9");
      break;
    case DW_OP_reg10:
      printf ("DW_OP_reg10");
      break;
    case DW_OP_reg11:
      printf ("DW_OP_reg11");
      break;
    case DW_OP_reg12:
      printf ("DW_OP_reg12");
      break;
    case DW_OP_reg13:
      printf ("DW_OP_reg13");
      break;
    case DW_OP_reg14:
      printf ("DW_OP_reg14");
      break;
    case DW_OP_reg15:
      printf ("DW_OP_reg15");
      break;
    case DW_OP_reg16:
      printf ("DW_OP_reg16");
      break;
    case DW_OP_reg17:
      printf ("DW_OP_reg17");
      break;
    case DW_OP_reg18:
      printf ("DW_OP_reg18");
      break;
    case DW_OP_reg19:
      printf ("DW_OP_reg19");
      break;
    case DW_OP_reg20:
      printf ("DW_OP_reg20");
      break;
    case DW_OP_reg21:
      printf ("DW_OP_reg21");
      break;
    case DW_OP_reg22:
      printf ("DW_OP_reg22");
      break;
    case DW_OP_reg23:
      printf ("DW_OP_reg23");
      break;
    case DW_OP_reg24:
      printf ("DW_OP_reg24");
      break;
    case DW_OP_reg25:
      printf ("DW_OP_reg25");
      break;
    case DW_OP_reg26:
      printf ("DW_OP_reg26");
      break;
    case DW_OP_reg27:
      printf ("DW_OP_reg27");
      break;
    case DW_OP_reg28:
      printf ("DW_OP_reg28");
      break;
    case DW_OP_reg29:
      printf ("DW_OP_reg29");
      break;
    case DW_OP_reg30:
      printf ("DW_OP_reg30");
      break;
    case DW_OP_reg31:
      printf ("DW_OP_reg31");
      break;
    case DW_OP_breg0:
      printf ("DW_OP_breg0: %ld", read_leb128 (data, NULL, 1));
      break;
    case DW_OP_breg1:
      printf ("DW_OP_breg1: %ld", read_leb128 (data, NULL, 1));
      break;
    case DW_OP_breg2:
      printf ("DW_OP_breg2: %ld", read_leb128 (data, NULL, 1));
      break;
    case DW_OP_breg3:
      printf ("DW_OP_breg3: %ld", read_leb128 (data, NULL, 1));
      break;
    case DW_OP_breg4:
      printf ("DW_OP_breg4: %ld", read_leb128 (data, NULL, 1));
      break;
    case DW_OP_breg5:
      printf ("DW_OP_breg5: %ld", read_leb128 (data, NULL, 1));
      break;
    case DW_OP_breg6:
      printf ("DW_OP_breg6: %ld", read_leb128 (data, NULL, 1));
      break;
    case DW_OP_breg7:
      printf ("DW_OP_breg7: %ld", read_leb128 (data, NULL, 1));
      break;
    case DW_OP_breg8:
      printf ("DW_OP_breg8: %ld", read_leb128 (data, NULL, 1));
      break;
    case DW_OP_breg9:
      printf ("DW_OP_breg9: %ld", read_leb128 (data, NULL, 1));
      break;
    case DW_OP_breg10:
      printf ("DW_OP_breg10: %ld", read_leb128 (data, NULL, 1));
      break;
    case DW_OP_breg11:
      printf ("DW_OP_breg11: %ld", read_leb128 (data, NULL, 1));
      break;
    case DW_OP_breg12:
      printf ("DW_OP_breg12: %ld", read_leb128 (data, NULL, 1));
      break;
    case DW_OP_breg13:
      printf ("DW_OP_breg13: %ld", read_leb128 (data, NULL, 1));
      break;
    case DW_OP_breg14:
      printf ("DW_OP_breg14: %ld", read_leb128 (data, NULL, 1));
      break;
    case DW_OP_breg15:
      printf ("DW_OP_breg15: %ld", read_leb128 (data, NULL, 1));
      break;
    case DW_OP_breg16:
      printf ("DW_OP_breg16: %ld", read_leb128 (data, NULL, 1));
      break;
    case DW_OP_breg17:
      printf ("DW_OP_breg17: %ld", read_leb128 (data, NULL, 1));
      break;
    case DW_OP_breg18:
      printf ("DW_OP_breg18: %ld", read_leb128 (data, NULL, 1));
      break;
    case DW_OP_breg19:
      printf ("DW_OP_breg19: %ld", read_leb128 (data, NULL, 1));
      break;
    case DW_OP_breg20:
      printf ("DW_OP_breg20: %ld", read_leb128 (data, NULL, 1));
      break;
    case DW_OP_breg21:
      printf ("DW_OP_breg21: %ld", read_leb128 (data, NULL, 1));
      break;
    case DW_OP_breg22:
      printf ("DW_OP_breg22: %ld", read_leb128 (data, NULL, 1));
      break;
    case DW_OP_breg23:
      printf ("DW_OP_breg23: %ld", read_leb128 (data, NULL, 1));
      break;
    case DW_OP_breg24:
      printf ("DW_OP_breg24: %ld", read_leb128 (data, NULL, 1));
      break;
    case DW_OP_breg25:
      printf ("DW_OP_breg25: %ld", read_leb128 (data, NULL, 1));
      break;
    case DW_OP_breg26:
      printf ("DW_OP_breg26: %ld", read_leb128 (data, NULL, 1));
      break;
    case DW_OP_breg27:
      printf ("DW_OP_breg27: %ld", read_leb128 (data, NULL, 1));
      break;
    case DW_OP_breg28:
      printf ("DW_OP_breg28: %ld", read_leb128 (data, NULL, 1));
      break;
    case DW_OP_breg29:
      printf ("DW_OP_breg29: %ld", read_leb128 (data, NULL, 1));
      break;
    case DW_OP_breg30:
      printf ("DW_OP_breg30: %ld", read_leb128 (data, NULL, 1));
      break;
    case DW_OP_breg31:
      printf ("DW_OP_breg31: %ld", read_leb128 (data, NULL, 1));
      break;
    case DW_OP_regx:
      printf ("DW_OP_regx: %lu", read_leb128 (data, NULL, 0));
      break;
    case DW_OP_fbreg:
      printf ("DW_OP_fbreg: %ld", read_leb128 (data, NULL, 1));
      break;
    case DW_OP_bregx:
      uvalue = read_leb128 (data, &bytes_read, 0);
      printf ("DW_OP_bregx: %lu %ld", uvalue,
	      read_leb128 (data + bytes_read, NULL, 1));
      break;
    case DW_OP_piece:
      printf ("DW_OP_piece: %lu", read_leb128 (data, NULL, 0));
      break;
    case DW_OP_deref_size:
      printf ("DW_OP_deref_size: %ld", (long) byte_get (data, 1));
      break;
    case DW_OP_xderef_size:
      printf ("DW_OP_xderef_size: %ld", (long) byte_get (data, 1));
      break;
    case DW_OP_nop:
      printf ("DW_OP_nop");
      break;
d5894 9
a5902 7
    default:
      if (op >= DW_OP_lo_user
	  && op <= DW_OP_hi_user)
	printf (_("(User defined location op)"));
      else
	printf (_("(Unknown location op)"));
      break;
a6000 1
      uvalue = * block_start;
a6006 1
      uvalue = * block_start;
a6012 1
      uvalue = * block_start;
a6018 1
      uvalue = * block_start;
a6047 5
    case DW_AT_frame_base:
      if (uvalue >= DW_OP_reg0 && uvalue <= DW_OP_reg31)
	printf ("(reg %ld)", uvalue - DW_OP_reg0);
      break;

d6144 1
d6148 6
a6153 3
      printf ("(");
      decode_location_expression (block_start, pointer_size);
      printf (")");
@


1.52
log
@Remove spurious blank line
@
text
@d213 1
a213 1
static unsigned char *    read_and_display_attr       PARAMS ((unsigned long, unsigned long, unsigned char *, unsigned long));
d6063 1
a6063 1
read_and_display_attr (attribute, form, data, pointer_size)
d6067 1
a6072 1
  int		  is_ref = 0;
a6078 11
    case DW_FORM_ref1:
    case DW_FORM_ref2:
    case DW_FORM_ref4:
    case DW_FORM_ref8:
    case DW_FORM_ref_udata:
      is_ref = 1;
    }

  switch (form)
    {
    case DW_FORM_ref_addr:
a6080 1
      printf (is_ref ? " <%lx>" : " %#lx", uvalue);
a6087 1
      printf (is_ref ? " <%lx>" : " %ld", uvalue);
a6093 1
      printf (is_ref ? " <%lx>" : " %ld", uvalue);
d6100 37
a6136 1
      printf (is_ref ? " <%lx>" : " %ld", uvalue);
a6151 13
    case DW_FORM_sdata:
      uvalue = read_leb128 (data, & bytes_read, 1);
      data += bytes_read;
      printf (" %ld", (long) uvalue);
      break;

    case DW_FORM_ref_udata:
    case DW_FORM_udata:
      uvalue = read_leb128 (data, & bytes_read, 0);
      data += bytes_read;
      printf (is_ref ? " <%lx>" : " %ld", uvalue);
      break;

d6342 1
d6352 1
d6438 1
a6438 1
					  tags,
@


1.51
log
@Detect EM_AVR machine number
@
text
@a1354 1
  
@


1.50
log
@Add code to decode the e_flags field of an ARM ELF binary.
@
text
@d1244 1
@


1.49
log
@2000-04-04  H.J. Lu  <hjl@@gnu.org>

	* readelf.c (process_symbol_table): Correctly read in symbol
	versioning information.
@
text
@d156 1
d1250 110
d1376 4
d3292 1
a3292 1
	  const char *dtype;
d3867 1
a3867 1
		char *name;
d7110 1
a7110 2
	  (unsigned long) offset,
	  (unsigned long) length);
@


1.48
log
@Move translated part of bug report string back into .c files so
xgettext can find it.  Regnerate .pot files.
@
text
@d3786 2
a3787 2
			      Elf_Internal_Vernaux     ivna;
			      unsigned long            vna_off;
d3885 1
a3885 1
			      Elf_Internal_Vernaux     ivna;
d3888 1
a3888 1
			      unsigned long            a_off;
a4312 5
			  GET_DATA (offset, evn, "version need");

			  ivn.vn_aux  = BYTE_GET (evn.vn_aux);
			  ivn.vn_next = BYTE_GET (evn.vn_next);

d4316 5
@


1.47
log
@Move bug report string to one place.
@
text
@d1703 1
a1703 1
  fprintf (stdout, REPORT_BUGS_TO);
@


1.46
log
@Include sys/types.h before sys/stat.h for ultrix.
@
text
@d1703 1
a1703 1
  fprintf (stdout, _("Report bugs to bug-gnu-utils@@gnu.org\n"));
@


1.46.2.1
log
@This is a grab-bag of my stuff from the head branch.
Should have done it separately, I know.
- move bug report address to include file
- objcopy --redefine-sym
- update makefile dependencies (but use automake-000227)
- H.J. Lu's fix to readelf.c
@
text
@d1703 1
a1703 1
  fprintf (stdout, _("Report bugs to %s\n"), REPORT_BUGS_TO);
d3786 2
a3787 2
			      Elf_Internal_Vernaux   ivna;
			      unsigned long          vna_off;
d3885 1
a3885 1
			      Elf_Internal_Vernaux   ivna;
d3888 1
a3888 1
			      unsigned long          a_off;
d4313 5
a4320 5

			      GET_DATA (offset, evn, "version need");

			      ivn.vn_aux  = BYTE_GET (evn.vn_aux);
			      ivn.vn_next = BYTE_GET (evn.vn_next);
@


1.46.2.2
log
@Replace 'strftime' with 'sprintf'
@
text
@a2824 2
	struct tm * tmp;

d2826 1
a2826 4
	tmp = gmtime (&time);
	sprintf (timebuf, "%04u-%02u-%02uT%02u:%02u:%02u",
		 tmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,
		 tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
a6631 1
	  struct tm * tmp;
d6639 1
a6639 4
	  tmp = gmtime (&time);
	  sprintf (timebuf, "%04u-%02u-%02uT%02u:%02u:%02u",
		   tmp->tm_year + 1900, tmp->tm_mon + 1, tmp->tm_mday,
		   tmp->tm_hour, tmp->tm_min, tmp->tm_sec);
@


1.46.2.3
log
@2000-04-14  Michael Sokolov  <msokolov@@ivan.Harhan.ORG>

	* arlex.l: Add directives to increase lex buffer size.

	* objdump.c, readelf.c: Don't include strarg.h or varargs.h. They are
        already included by bucomm.h.
@
text
@d77 6
@


1.46.2.4
log
@H.J.'s ELFOSABI changes.
@
text
@d1934 1
a1934 1
    case ELFOSABI_NONE:       return _("UNIX - System V");
a1935 1
    case ELFOSABI_NETBSD:     return _("UNIX - NetBSD");
a1936 8
    case ELFOSABI_HURD:       return _("GNU/Hurd");
    case ELFOSABI_SOLARIS:    return _("UNIX - Solaris");
    case ELFOSABI_MONTEREY:   return _("UNIX - Monterey");
    case ELFOSABI_IRIX:       return _("UNIX - IRIX");
    case ELFOSABI_FREEBSD:    return _("UNIX - FreeBSD");
    case ELFOSABI_TRU64:      return _("UNIX - TRU64");
    case ELFOSABI_MODESTO:    return _("Novell - Modesto");
    case ELFOSABI_OPENBSD:    return _("UNIX - OpenBSD");
@


1.46.2.5
log
@Merge from mainline
@
text
@a1065 1
    case DT_CHECKSUM:	return "CHECKSUM";
d1069 1
a1069 1
    case DT_FEATURE:	return "FEATURE";
a1074 5
    case DT_CONFIG:	return "CONFIG";
    case DT_DEPAUDIT:	return "DEPAUDIT";
    case DT_AUDIT:	return "AUDIT";
    case DT_PLTPAD:	return "PLTPAD";
    case DT_MOVETAB:	return "MOVETAB";
d1087 1
a1087 1
    case DT_AUXILIARY:	return "AUXILIARY";
a3204 3
	case DT_CONFIG:
	case DT_DEPAUDIT:
	case DT_AUDIT:
d3207 4
a3210 22
	      switch (entry->d_tag)
	        {
		case DT_AUXILIARY:
		  printf (_("Auxiliary library"));
		  break;

		case DT_FILTER:
		  printf (_("Filter library"));
		  break;

	        case DT_CONFIG:
		  printf (_("Configuration file"));
		  break;

		case DT_DEPAUDIT:
		  printf (_("Dependency audit library"));
		  break;

		case DT_AUDIT:
		  printf (_("Audit library"));
		  break;
		}
d3223 1
a3223 1
	case DT_FEATURE:
a3236 5
		  if (val & DTF_1_CONFEXP)
		    {
		      printf (" CONFEXP");
		      val ^= DTF_1_CONFEXP;
		    }
a3333 15
		  if (val & DF_1_NODEFLIB)
		    {
		      printf (" NODEFLIB");
		      val ^= DF_1_NODEFLIB;
		    }
		  if (val & DF_1_NODUMP)
		    {
		      printf (" NODUMP");
		      val ^= DF_1_NODUMP;
		    }
		  if (val & DF_1_CONLFAT)
		    {
		      printf (" CONLFAT");
		      val ^= DF_1_CONLFAT;
		    }
a3361 1
	case DT_RUNPATH	:
a3391 4
		    case DT_RUNPATH:
		      printf (_("Library runpath: [%s]"), name);
		      break;

d5042 1
a5042 8
	  static int warned = 0;

	  if (! warned)
	    {
	      warn (_("Only DWARF 2 pubnames are currently supported\n"));
	      warned = 1;
	    }
	  
a6358 6

      if (arange.ar_version != 2)
	{
	  warn (_("Only DWARF 2 aranges are currently supported.\n"));
	  break;
	}
@


1.45
log
@ATMEL AVR microcontroller support.
@
text
@d26 1
@


1.44
log
@	From Brad Lucier <lucier@@math.purdue.edu>:
	* readelf.c (process_dynamic_segment): Add cast to make sure
	argument to %* is int.
@
text
@d71 1
d807 4
@


1.43
log
@Teach get_osabi_name about Linux
@
text
@d3171 2
d3175 4
a3178 3
	  printf (" (%s)%*s",
		  get_dynamic_type (entry->d_tag),
		  (is_32bit_elf ? 27 : 19) - strlen (get_dynamic_type (entry->d_tag)),
@


1.42
log
@Remove use of ELF_ST_OTHER.
@
text
@d1936 1
@


1.41
log
@	From Brad Lucier <lucier@@math.purdue.edu>:
	* readelf.c (process_version_sections): Add casts to make sure
	argument to %* is an int.
	(process_mips_specific): Add casts to make printf arguments match
	format.
@
text
@d4183 1
a4183 1
	printf (_("  Num Buc:    Value  Size   Type   Bind Vis      Ot Ndx Name\n"));
d4185 1
a4185 1
	printf (_("  Num Buc:    Value          Size   Type   Bind Vis      Ot Ndx Name\n"));
a4205 1
	      printf (" %2d",  ELF_ST_OTHER (psym->st_other));
d4233 1
a4233 1
	    printf (_("   Num:    Value  Size Type    Bind   Vis      Ot Ndx Name\n"));
d4235 1
a4235 1
	    printf (_("   Num:    Value          Size Type    Bind   Vis      Ot  Ndx Name\n"));
a4264 1
	      printf (" %2d", ELF_ST_OTHER (psym->st_other));
@


1.40
log
@Most of these changes are really only cosmetic.  The readelf.c patch
fixes a thinko in get_dynamic_flags.  I found at least one message
string that included a `%' being passed to printf in the format
argument.
@
text
@d3742 1
d3803 1
d3805 2
a3806 3
						strtab + ivna.vna_name,
						12 - strlen (strtab
							     + ivna.vna_name),
d3849 1
d3852 2
a3853 4
						    strtab + ivda.vda_name,
						    12
						    - strlen (strtab
							      + ivda.vda_name),
d3904 1
d3906 2
a3907 3
						strtab + ivna.vna_name,
						12 - strlen (strtab
							     + ivna.vna_name),
d3949 1
d3951 2
a3952 3
					    strtab + ivda.vda_name,
					    12 - strlen (strtab
							 + ivda.vda_name),
d6614 2
a6615 1
      printf ("\nSection '.liblist' contains %d entries:\n", liblistno);
d6633 1
a6633 1
	  printf ("%3d: %-20s %s %#10lx %-7ld", cnt,
d6917 1
a6917 1
	  printf ("%5u: %8lu  ", cnt, iconf[cnt]);
@


1.39
log
@Detect ELFOSABI_ARM.
@
text
@d2 1
a2 1
   Copyright (C) 1998, 1999 Free Software Foundation, Inc.
d3002 1
a3002 1
	default:          strcat (buff, "unknown "); return;
d3005 1
d3182 1
a3182 1
	    printf (get_dynamic_flags (entry->d_un.d_val));
d5969 1
a5969 1
      printf (is_ref ? " <%x>" : " %#x", uvalue);
d5977 1
a5977 1
      printf (is_ref ? " <%x>" : " %d", uvalue);
d5984 1
a5984 1
      printf (is_ref ? " <%x>" : " %d", uvalue);
d5991 1
a5991 1
      printf (is_ref ? " <%x>" : " %d", uvalue);
d6985 3
a6987 1
  printf (_("\nNotes at offset 0x%08lx with length 0x%08lx:\n"), offset, length);
@


1.38
log
@Fix description of EM_S370.
@
text
@d1937 1
@


1.37
log
@Fix mistakes made about interpretation of ELF ABI spec
@
text
@d1183 1
a1183 1
    case EM_S370:        	return "Amdahl";
@


1.36
log
@Add NT_WIN32PSTATUS to list of recognised core notes
@
text
@d1062 1
a1062 1
    case DT_ENCODING:   return "ENCODING";
@


1.35
log
@Add decoding of new constants defined in Oct 4, 1999 draft of ELF ABI spec.
@
text
@d6943 1
@


1.34
log
@Fix support for native 64bit ELF systems
@
text
@d161 5
a165 2
static char *             get_symbol_binding          PARAMS ((unsigned int));
static char *             get_symbol_type             PARAMS ((unsigned int));
a179 1
static char *             get_symbol_index_type       PARAMS ((unsigned int));
d570 18
d1060 5
d1170 1
a1170 1
  static char buff [32];
d1182 1
a1182 1
    case EM_MIPS:        	return "MIPS R3000 big-endian";
d1219 18
d1251 1
d1592 3
d2439 46
d2584 1
d2611 4
a2614 5
	  
	  printf (" %c%c%c %2ld %3lx %ld\n",
		  (section->sh_flags & SHF_WRITE ? 'W' : ' '),
		  (section->sh_flags & SHF_ALLOC ? 'A' : ' '),
		  (section->sh_flags & SHF_EXECINSTR ? 'X' : ' '),
d2629 2
a2630 5
	  printf (" %c%c%c",
		  (section->sh_flags & SHF_WRITE ? 'W' : ' '),
		  (section->sh_flags & SHF_ALLOC ? 'A' : ' '),
		  (section->sh_flags & SHF_EXECINSTR ? 'X' : ' '));
	  
d2638 4
d2983 23
d3178 5
d3979 1
a3979 1
static char *
d4001 1
a4001 1
static char *
d4014 1
d4047 15
a4061 1
static char *
a4086 1

d4181 1
a4181 1
	printf (_("  Num Buc:    Value  Size   Type   Bind Ot Ndx Name\n"));
d4183 1
a4183 1
	printf (_("  Num Buc:    Value          Size   Type   Bind Ot Ndx Name\n"));
d4199 1
a4199 1
	      print_vma (psym->st_size,  DEC_5);
d4201 5
a4205 7
	      printf ("  %6s %6s %2d ",
		      get_symbol_type (ELF_ST_TYPE (psym->st_info)),
		      get_symbol_binding (ELF_ST_BIND (psym->st_info)),
		      psym->st_other);

	      printf ("%3.3s", get_symbol_index_type (psym->st_shndx));

d4232 1
a4232 1
	    printf (_("   Num:    Value  Size Type    Bind   Ot  Ndx Name\n"));
d4234 1
a4234 1
	    printf (_("   Num:    Value          Size Type    Bind   Ot  Ndx Name\n"));
d4261 5
a4265 7
	      printf (" %-7s %-6s %2d ",
		      get_symbol_type (ELF_ST_TYPE (psym->st_info)),
		      get_symbol_binding (ELF_ST_BIND (psym->st_info)),
		      psym->st_other);

	      printf ("%4s", get_symbol_index_type (psym->st_shndx));

d6676 1
a6676 1
      Elf_Internal_Shdr * sect = section_headers;
d6684 1
a6684 1
	++sect;
d6699 1
d6712 1
d6721 1
d6937 1
@


1.33
log
@fix typo in previous delta
@
text
@d445 3
d453 1
d457 3
d465 1
d469 3
d477 1
@


1.32
log
@minor formatting changes
@
text
@d129 13
a395 12
typedef enum print_mode
{
  HEX,
  DEC,
  DEC_5,
  UNSIGNED,
  PREFIX_HEX,
  FULL_HEX,
  LONG_HEX
}
print_mode;

@


1.31
log
@Fix compile time warnings & asupport more than 999 symbols
@
text
@d130 1
a394 2
static void print_vma PARAMS ((bfd_vma, print_mode));

d1167 1
a1167 1
    case EM_IA_64:		return "Intel Merced";
d1322 2
a1323 1

d2771 7
a2777 7
           {
             if (! first)
               putchar (' ');
             fputs (flags[cnt].str, stdout);
             first = 0;
             val ^= flags[cnt].bit;
           }
d2787 1
a2787 1

d4301 1
a4301 1
	++counts[lengths [hn]];
d6495 1
a6495 1
		const char *name;
d6497 10
a6506 9
	      } l_flags_vals[] =
		{
		  { " EXACT_MATCH", LL_EXACT_MATCH },
		  { " IGNORE_INT_VER", LL_IGNORE_INT_VER },
		  { " REQUIRE_MINOR", LL_REQUIRE_MINOR },
		  { " EXPORTS", LL_EXPORTS },
		  { " DELAY_LOAD", LL_DELAY_LOAD },
		  { " DELTA", LL_DELTA }
		};
d6921 2
a6922 2
					      (bfd_vma)segment->p_offset,
					      (bfd_vma)segment->p_filesz);
@


1.30
log
@Fix displaying 64bit ELF files.
@
text
@d408 1
a408 1
	case LONG_HEX: printf ("%08.8lx", vma); break;
d410 4
a413 4
	case HEX: printf ("%lx", vma); break;
	case DEC: printf ("%ld", vma); break;
	case DEC_5: printf ("%5ld", vma); break;
	case UNSIGNED: printf ("%lu", vma); break;
d2517 1
a2517 1
	  printf ("  %08.8lx", section->sh_offset);
d2749 16
a2764 15
	  const char *str;
	} flags[] =
	  {
	    { DT_HP_DEBUG_PRIVATE, "HP_DEBUG_PRIVATE" },
	    { DT_HP_DEBUG_CALLBACK, "HP_DEBUG_CALLBACK" },
	    { DT_HP_DEBUG_CALLBACK_BOR, "HP_DEBUG_CALLBACK_BOR" },
	    { DT_HP_NO_ENVVAR, "HP_NO_ENVVAR" },
	    { DT_HP_BIND_NOW, "HP_BIND_NOW" },
	    { DT_HP_BIND_NONFATAL, "HP_BIND_NONFATAL" },
	    { DT_HP_BIND_VERBOSE, "HP_BIND_VERBOSE" },
	    { DT_HP_BIND_RESTRICTED, "HP_BIND_RESTRICTED" },
	    { DT_HP_BIND_SYMBOLIC, "HP_BIND_SYMBOLIC" },
	    { DT_HP_RPATH_FIRST, "HP_RPATH_FIRST" },
	    { DT_HP_BIND_DEPTH_FIRST, "HP_BIND_DEPTH_FIRST" }
	  };
d2766 1
a2766 1
	int cnt;
d2778 1
d3986 1
a3986 1
  int    nchains;
d4085 1
a4085 1
	    printf (_("  Num:    Value  Size Type    Bind   Ot  Ndx Name\n"));
d4087 1
a4087 1
	    printf (_("  Num:    Value          Size Type    Bind   Ot  Ndx Name\n"));
d4110 1
a4110 1
	      printf ("  %3d: ", si);
@


1.29
log
@Applied Fred Fish's patch to fix decoding of core notes.
@
text
@d204 1
a204 1
static int		  process_corefile_note_segment  PARAMS ((FILE *, unsigned long, unsigned long));
d381 91
d866 3
a868 1
		  printf (" %08lx  ", (unsigned long) psym->st_value);
d884 4
a887 1
	printf ("%34c%lx", ' ', (unsigned long) relas[i].r_addend);
d1927 9
a1935 6
      printf (_("  Entry point address:               0x%lx\n"),
	      (unsigned long) elf_header.e_entry);
      printf (_("  Start of program headers:          %ld (bytes into file)\n"),
	      (long) elf_header.e_phoff);
      printf (_("  Start of section headers:          %ld (bytes into file)\n"),
	      (long) elf_header.e_shoff);
d2040 7
a2046 4
      printf (_("\nElf file is %s\n"), get_file_type (elf_header.e_type));
      printf (_("Entry point 0x%lx\n"), (unsigned long) elf_header.e_entry);
      printf (_("There are %d program headers, starting at offset %lx:\n"),
	      elf_header.e_phnum, (unsigned long) elf_header.e_phoff);
d2073 11
a2083 2
      printf
	(_("  Type           Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align\n"));
d2097 31
a2127 10
	  printf ("0x%6.6lx ", (unsigned long) segment->p_offset);
	  printf ("0x%8.8lx ", (unsigned long) segment->p_vaddr);
	  printf ("0x%8.8lx ", (unsigned long) segment->p_paddr);
	  printf ("0x%5.5lx ", (unsigned long) segment->p_filesz);
	  printf ("0x%5.5lx ", (unsigned long) segment->p_memsz);
	  printf ("%c%c%c ",
		  (segment->p_flags & PF_R ? 'R' : ' '),
		  (segment->p_flags & PF_W ? 'W' : ' '),
		  (segment->p_flags & PF_X ? 'E' : ' '));
	  printf ("%#lx", (unsigned long) segment->p_align);
d2147 1
a2147 1
	  if (fseek (file, segment->p_offset, SEEK_SET))
d2478 8
a2485 2
  printf
    (_("  [Nr] Name              Type            Addr     Off    Size   ES Flg Lk Inf Al\n"));
d2496 37
a2532 13
      printf ( "%8.8lx %6.6lx %6.6lx %2.2lx",
	       (unsigned long) section->sh_addr,
	       (unsigned long) section->sh_offset,
	       (unsigned long) section->sh_size,
	       (unsigned long) section->sh_entsize);

      printf (" %c%c%c %2ld %3lx %ld\n",
	      (section->sh_flags & SHF_WRITE ? 'W' : ' '),
	      (section->sh_flags & SHF_ALLOC ? 'A' : ' '),
	      (section->sh_flags & SHF_EXECINSTR ? 'X' : ' '),
	      (unsigned long) section->sh_link,
	      (unsigned long) section->sh_info,
	      (unsigned long) section->sh_addralign);
d2766 1
a2766 1
	long int val = entry->d_un.d_val;
d2778 5
a2782 2
	  printf ("%s%#lx", first ? "" : " ", val);
	puts ("");
d2787 2
a2788 1
      printf ("%#lx\n", (long) entry->d_un.d_ptr);
d3035 8
a3042 5
	printf (_("  0x%-8.8lx (%s)%*s"),
		(unsigned long) entry->d_tag,
		get_dynamic_type (entry->d_tag),
		27 - strlen (get_dynamic_type (entry->d_tag)),
		" ");
d3058 5
a3062 1
		printf (": %#lx\n", (long) entry->d_un.d_val);
d3223 2
a3224 4
		      if (strcmp (name, program_interpreter))
			printf ("\n");
		      else
			printf (_(" program interpreter\n"));
d3228 1
a3228 1
		      printf (_("Library soname: [%s]\n"), name);
d3232 1
a3232 1
		      printf (_("Library rpath: [%s]\n"), name);
d3236 2
a3237 1
		      printf ("%#lx\n", (long) entry->d_un.d_val);
d3241 3
a3243 1
		printf ("%#lx\n", (long) entry->d_un.d_val);
d3260 4
a3263 1
	    printf ("%lu (bytes)\n", (unsigned long) entry->d_un.d_val);
d3271 4
a3274 1
	    printf ("%lu\n", (unsigned long) entry->d_un.d_val);
d3298 2
a3299 1
	      printf ("%#lx\n", (long) entry->d_un.d_val);
d3324 2
a3325 1
		  printf ("%#lx\n", (long) entry->d_un.d_ptr);
d4029 4
a4032 1
      printf (_("  Num Buc:    Value  Size   Type   Bind Ot Ndx Name\n"));
d4039 1
a4039 1
	  for (si = buckets [hn]; si; si = chains [si])
d4045 6
a4050 4
	      printf ("  %3d %3d: %8lx %5ld %6s %6s %2d ",
		      si, hn,
		      (unsigned long) psym->st_value,
		      (unsigned long) psym->st_size,
d4082 4
a4085 2
	  fputs (_("  Num:    Value  Size Type    Bind   Ot  Ndx Name\n"),
		 stdout);
d4108 5
a4112 4
	      printf ("  %3d: %8lx %5ld %-7s %-6s %2d ",
		      si,
		      (unsigned long) psym->st_value,
		      (unsigned long) psym->st_size,
d4283 1
a4283 1
	  for (si = buckets[hn]; si; si = chains[si])
d4285 1
a4285 1
	      ++nsyms;
d4287 1
a4287 1
		++maxlength;
d6763 3
a6765 3
	  printf ("%5u: %8lu  %#10lx  %s\n",
		  cnt, iconf[cnt], (unsigned long) psym->st_value,
		  dynamic_strings + psym->st_name);
a6767 1

d6816 2
a6817 2
     unsigned long offset;
     unsigned long length;
d6918 2
a6919 2
					      (unsigned long)segment->p_offset,
					      (unsigned long)segment->p_filesz);
@


1.28
log
@1999-09-15  Ulrich Drepper  <drepper@@cygnus.com>

	* readelf.c (dynamic_segment_parisc_val): Print 0 for DLD_FLAGS if
	the value is zero.
	(process_symbol_table): Don't print histogram if hash table is empty.

1999-09-15  Ulrich Drepper  <drepper@@cygnus.com>

	* readelf.c (get_parisc_dynamic_type): Handle DT_HP_GST_* values.

1999-09-02  Ulrich Drepper  <drepper@@cygnus.com>

	* readelf.c (get_symbol_type): Add support for HPUX and PARISC
	specific symbol types.

	* readelf.c: Add HPUX and PARISC extensions to dynamic and program
	header table printing.

	* readelf.c (get_machine_flags): Add handling of PARISC.
@
text
@d203 1
a203 1
static int		  process_note		         PARAMS ((Elf_External_Note *));
d6608 5
d6615 1
a6615 1
  Elf_External_Note * pnote;
a6616 15
  Elf32_Internal_Note * internal;
  char * pname;

  internal = (Elf32_Internal_Note *) pnote;
  pname = malloc (internal->namesz + 1);

  if (pname == NULL)
    {
      error (_("Out of memory\n"));
      return 0;
    }

  memcpy (pname, pnote->name, internal->namesz);
  pname[internal->namesz] = '\0';

d6618 2
a6619 4
  	  pname, internal->descsz, get_note_type (internal->type));

  free (pname);

d6623 1
a6631 4
  Elf32_Internal_Note* internal;
  unsigned int	       notesz;
  unsigned int         nlength;
  unsigned char *      p;
a6639 2
  p = (unsigned char *) pnotes;
  nlength = length;
d6644 1
a6644 1
  while (nlength > 0)
d6646 35
a6680 1
      res &= process_note (external);
d6682 5
a6686 5
      internal = (Elf32_Internal_Note *) p;
      notesz   = 3 * sizeof(unsigned long) + internal->namesz + internal->descsz;
      nlength -= notesz;
      p       += notesz;
      external = (Elf_External_Note *) p;
@


1.27
log
@1999-09-04  Steve Chamberlain  <sac@@pobox.com>

	* readelf.c: Include "elf/pj.h".
	(dump_relocations): Handle EM_PJ.
	(get_machine_name): Likewise.
	(get_machine_flags): Likewise.
@
text
@d135 1
d142 1
d145 1
d155 1
d423 1
a423 1
      
d448 1
a448 1
      
d464 1
a464 1
      
d486 1
a486 1
  
d495 1
a495 1
	  
d498 1
a498 1
	  
d500 1
a500 1
	  
d503 1
a503 1
      
d509 1
a509 1
	  
d516 1
a516 1
      
d518 1
a518 1
      
d524 1
a524 1
	  
d527 1
a527 1
	  
d529 1
a529 1
	  
d532 1
a532 1
      
d538 1
a538 1
	  
d545 1
a545 1
      
d547 1
a547 1
      
d559 1
a559 1
	  
d561 1
a561 1
	  
d564 1
a564 1
	  
d570 1
a570 1
	  
d576 1
a576 1
	  
d578 1
a578 1
	  
d587 1
a587 1
	  
d589 1
a589 1
	  
d592 1
a592 1
	  
d598 1
a598 1
	  
d604 1
a604 1
	  
d606 1
a606 1
	  
d625 1
a625 1
      
d636 1
a636 1
      
d651 1
a651 1
#ifdef BFD64 
d661 1
a661 1
      
d755 1
a755 1
#ifdef _bfd_int64_low	
d774 1
a774 1
		  
d776 1
a776 1
		  
d784 1
a784 1
		  
d869 25
a893 1
}    
d932 1
a932 1
      
d940 1
a940 1
      
d943 1
a943 1
      
d945 1
a945 1
      
d953 1
a953 1
      
d957 1
a957 1
      
d962 1
a962 1
	  
d983 18
a1000 1
	sprintf (buff, _("Operating System specific: %lx"), type);
d1003 1
a1003 1
      
d1200 28
d1261 27
d1307 1
a1307 1
	  
d1314 3
d1321 1
a1321 1
	  
d1324 1
a1324 1
	  
d1328 18
a1345 1
	sprintf (buff, "LOOS+%lx", p_type - PT_LOOS);
d1405 15
d1458 3
d1477 1
a1477 1
      
d1741 1
a1741 1
  
d1758 1
a1758 1
  
d1764 1
a1764 1
    default:          
d1775 1
a1775 1
  
d1853 1
a1853 1
  
d1867 1
a1867 1
  
d1900 1
a1900 1
  
d1966 1
a1966 1
  
d1972 1
a1972 1
	(_("  Type        Offset   VirtAddr   PhysAddr   FileSiz MemSiz  Flg Align\n"));
d1985 1
a1985 1
	  printf ("  %-11.11s ", get_segment_type (segment->p_type));
d2294 1
a2294 1
  
d2411 1
a2411 1
	  
d2463 1
a2463 1
	      
d2486 1
a2486 1
	      
d2536 1
a2536 1
      
d2544 1
a2544 1
      
d2553 1
a2553 1
      
d2569 52
a2620 1
      
d2633 1
a2633 1
  
d2636 1
a2636 1
  
d2674 1
a2674 1
  
d2677 1
a2677 1
  
d3117 1
a3117 1
	      
d3125 1
a3125 1
	  
d3139 3
d3230 1
a3230 1
		
d3287 1
a3287 1
	  
d3367 1
a3367 1
	    
d3648 1
a3648 1
	
d3668 3
a3670 3
    case STB_LOCAL:  return _("LOCAL");
    case STB_GLOBAL: return _("GLOBAL");
    case STB_WEAK:   return _("WEAK");
d3690 5
a3694 5
    case STT_NOTYPE:   return _("NOTYPE");
    case STT_OBJECT:   return _("OBJECT");
    case STT_FUNC:     return _("FUNC");
    case STT_SECTION:  return _("SECTION");
    case STT_FILE:     return _("FILE");
d3699 2
a3700 2
	    return _("THUMB_FUNC");
	    
d3702 5
a3706 2
	    return _("REGISTER");
	  
d3710 11
a3720 1
	sprintf (buff, _("<OS specific>: %d"), type);
d4109 1
a4109 1
	++ counts [lengths [hn]];
d4111 11
a4121 8
      printf ("      0  %-10d (%5.1f%%)\n",
	      counts[0], (counts[0] * 100.0) / nbuckets);
      for (si = 1; si <= maxlength; ++si)
	{
	  nzero_counts += counts[si] * si;
	  printf ("%7d  %-10d (%5.1f%%)    %5.1f%%\n",
		  si, counts[si], (counts[si] * 100.0) / nbuckets,
		  (nzero_counts * 100.0) / nsyms);
d4378 1
a4378 1
  
d4392 1
a4392 1
  
d4409 1
a4409 1
	 
d4463 1
a4463 1
      
d4471 1
a4471 1
      
d4478 1
a4478 1
      
d4482 1
a4482 1
      
d4495 1
a4495 1
      
d4498 1
a4498 1
      
d4500 1
a4500 1
      
d4503 1
a4503 1
      
d4506 1
a4506 1
      
d4512 1
a4512 1
	  
d4516 1
a4516 1
	      
d4520 1
a4520 1
      
d4523 1
a4523 1
      
d4531 1
a4531 1
	  
d4536 1
a4536 1
	      
d4539 1
a4539 1
	      
d4541 1
a4541 1
	      
d4551 1
a4551 1
      
d4554 1
a4554 1
      
d4557 2
a4558 2
      
      
d4564 1
a4564 1
	  
d4566 1
a4566 1
	  
d4573 1
a4573 1
	      
d4577 1
a4577 1
	      
d4585 1
a4585 1
	      
d4593 1
a4593 1
	      
d4601 1
a4601 1
	      
d4608 1
a4608 1
	      
d4615 1
a4615 1
	      
d4620 1
a4620 1
	      
d4628 1
a4628 1
	      
d4636 1
a4636 1
	      
d4652 1
a4652 1
  
d6033 1
a6033 1
	  
d6181 1
a6181 1
	    
d6590 1
a6590 1
  
d6614 1
a6614 1
  
d6617 1
a6617 1
  
d6627 1
a6627 1
  printf ("  %s\t\t0x%08lx\t%s\n", 
d6629 1
a6629 1
  	   
d6648 1
a6648 1
  
d6651 1
a6651 1
    
d6654 1
a6654 1
  external = pnotes; 
d6657 1
a6657 1
 
d6660 1
a6660 1
  
d6664 1
a6664 1
      
d6673 1
a6673 1
  
d6685 1
a6685 1
  
d6705 1
a6705 1
  
d6711 1
a6711 1
	res &= process_corefile_note_segment (file, 
d6715 1
a6715 1
    
d6728 1
a6728 1
  
d6732 1
a6732 1
    
d6789 1
a6789 1
      
d6818 1
a6818 1
      
d6821 1
a6821 1
      
d6900 1
a6900 1
  
d6902 1
a6902 1
  
@


1.26
log
@Apply patch from Scott Bambrough to display the contents of a NOTES segment
in a core file.
@
text
@d70 1
d744 4
d1040 1
a1040 1

d1153 8
@


1.25
log
@Applied patch from Stephane Carrez  <stcarrez@@worldnet.fr> to fix pointer size assumption.
@
text
@d117 1
d197 5
d1344 1
d1373 1
d1437 1
a1437 1
	  (argc, argv, "ersahldSDAIw::x:i:vV", options, NULL)) != EOF)
d1461 1
d1495 3
d1576 1
a1576 1
      && !do_histogram && !do_debugging && !do_arch)
d6364 158
d6679 3
a6681 1

@


1.24
log
@Patch from Jim Wilson - more bug fixes for line table decoding.
@
text
@d180 1
a180 1
static int                process_extended_line_op    PARAMS ((unsigned char *, int));
d4135 1
a4135 1
process_extended_line_op (data, is_stmt)
d4138 1
d4168 1
a4168 2
      /* XXX - assumption here that address size is 4! */
      adr = byte_get (data, 4);
d4196 4
d4337 2
a4338 1
	      data += process_extended_line_op (data, info.li_default_is_stmt);
d5825 17
d5843 3
a5845 1
     to a function that can decode it.  */
d5849 2
a5850 1
  int (* display) PARAMS((Elf32_Internal_Shdr *, unsigned char *, FILE *));
d5854 12
a5865 12
  { ".debug_info",        display_debug_info },
  { ".debug_abbrev",      display_debug_abbrev },
  { ".debug_line",        display_debug_lines },
  { ".debug_aranges",     display_debug_aranges },
  { ".debug_pubnames",    display_debug_pubnames },
  { ".debug_macinfo",     display_debug_not_supported },
  { ".debug_frame",       display_debug_not_supported },
  { ".debug_str",         display_debug_not_supported },
  { ".debug_static_func", display_debug_not_supported },
  { ".debug_static_vars", display_debug_not_supported },
  { ".debug_types",       display_debug_not_supported },
  { ".debug_weaknames",   display_debug_not_supported }
d5913 2
a5914 2
  Elf32_Internal_Shdr *    section;
  unsigned int  i;
d5919 34
d5954 1
a5954 2
       i < elf_header.e_shnum
       && i < num_dump_sects;
@


1.23
log
@(display_debug_lines, case DW_LNS_const_add_pc): Multiply adv by info.li_min_insn_length.
@
text
@d4265 1
a4265 1
	printf (_("  Opcode %d has %d args\n"), i, standard_opcodes[i]);
d5757 1
d5777 5
a5785 3
	  if (address == 0)
	    break;

d5792 4
@


1.22
log
@        * readelf.c (get_sparc64_dynamic_type): New function.
        (get_dynamic_type): Use it.
@
text
@d4384 2
a4385 1
	      adv = (255 - info.li_opcode_base) / info.li_line_range;
@


1.21
log
@(display_debug_lines, case default): Change second line setting adv to use = not +=
@
text
@d132 1
d845 12
d929 3
@


1.20
log
@Hans-Peter Nilsson  <hp@@bitrange.com>

	* readelf.c (process_abbrev_section): Handle standard-conforming
	single zero at the end of the section.
@
text
@d4388 1
a4388 1
	      adv    += (op_code % info.li_line_range) + info.li_line_base;
@


1.19
log
@Jakub Jelinek  <jj@@ultra.linux.cz>

        * readelf.c (get_machine_flags): Print EF_SPARC_SUN_US3.
@
text
@d4793 3
d4797 1
a4797 1
	return start;
@


1.18
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Add variable initializations.  Add casts.
	* objdump.c (disassemble_bytes): Change j to bfd_vma.
	* readelf.c (process_syminfo): Change i to unsigned int.
	(display_debug_info): Change abbrev_number to unsigned long.
	(process_mips_specific): Change fcnt to size_t.
@
text
@d1107 4
a1110 1
	    strcat (buf, ", ultrasparc");
@


1.17
log
@Only decode 64bit ELF files if the host compiler supports a 64bit data type.
@
text
@d1883 1
a1883 1
		      : (section->sh_offset >= segment->p_offset
d2208 1
a2208 1
      int is_rela;
d3552 1
a3552 1
  int    nbuckets;
d3887 1
a3887 1
     FILE * file;
d3889 1
a3889 1
  int i;
d4182 1
a4182 1
     FILE *                file;
d4402 1
a4402 1
     FILE *                file;
d4824 1
a4824 1
     FILE *                file;
d5346 2
a5347 2
  unsigned long   uvalue;
  unsigned char * block_start;
d5668 1
a5668 1
	  int            abbrev_number;
d5691 1
a5691 1
	      warn (_("Unable to locate entry %d in the abbreviation table\n"),
d5696 1
a5696 1
	  printf (_(" <%d><%x>: Abbrev Number: %d (%s)\n"),
d5721 1
a5721 1
     FILE *                file;
d5781 2
a5782 2
     unsigned char *       start;
     FILE *                file;
d5994 1
a5994 1
	      int fcnt;
@


1.16
log
@Jakub Jelinek  <jj@@ultra.linux.cz>
        * readelf.c (guess_is_rela): Sparcv9 and v8plus use rela.
        (dump_relocations): Use ELF64_R_TYPE_ID for Sparc, for R_SPARC_OLO10
        print the secondary addend.
        (get_machine_flags): Print Sparc machine flags.
        (get_symbol_type): Print STT_REGISTER.
@
text
@d30 1
d32 3
a34 1
   as this will allow us to read in and parse 64bit and 32bit ELF files.  */
d36 2
d116 1
d209 10
d220 3
d348 1
d362 1
a362 1

d396 1
d410 1
d636 4
d641 1
d1312 1
a1312 1
  {"histogram",        no_argument, & do_histogram, 1},
d1320 1
d1339 1
a1339 1
  fprintf (stdout, _("  -a or --all               Equivalent to: -h -l -S -s -r -d -V --histogram\n"));
d1350 1
d1360 1
a1360 1
  fprintf (stdout, _("        --histogram         Display histogram of bucket list lengths\n"));
d1410 1
a1410 1
	  (argc, argv, "ersahldSDw::x:i:vV", options, NULL)) != EOF)
d1433 1
d1440 3
d1464 3
d1545 1
a1545 1
      && !do_histogram && !do_debugging)
d6268 3
d6328 11
@


1.15
log
@h
        * readelf.c (dump_relocations): Use elf_hppa_reloc_type instead of
        elf32_hppa_reloc_type.
@
text
@d417 2
d610 4
a613 1
	  type         = ELF64_R_TYPE (info);
d750 4
d1074 23
d3428 3
@


1.14
log
@Detect symbols typed as thumb functions.
@
text
@d702 1
a702 1
	  rtype = elf32_hppa_reloc_type (type);
@


1.13
log
@	* readelf.c (get_elf_class): Use correct printf format for type.
	(get_data_encoding): Likewise.
	(get_osabi_name): Likewise.
	(process_file_header): Don't pass an extra argument to printf.
	(process_dynamic_segment): Cast dynamic_size to long before
	printing.
	(decode_location_expression): Cast byte_get to long before
	printing.
@
text
@d3393 6
a3398 1
	sprintf (buff, _("<processor specific>: %d"), type);
@


1.12
log
@	* readelf.c (dump_section): Cast bfd_vma values to [unsigned] long
	for printing, in case it is wider than long.
	(display_block): Likewise.
	(read_and_display_attr): Likewise.
	(decode_location_expression): Likewise.  Don't depend on
	evaluation order.
@
text
@d1498 1
a1498 1
      sprintf (buff, _("<unknown: %lx>"), elf_class);
d1515 1
a1515 1
      sprintf (buff, _("<unknown: %lx>"), encoding);
d1532 1
a1532 1
      sprintf (buff, _("<unknown: %lx>"), osabi);
d1566 5
a1570 3
	      elf_header.e_ident [EI_VERSION] == EV_CURRENT ? "(current)" :
	      elf_header.e_ident [EI_VERSION] != EV_NONE ? "<unknown: %lx>" : "",
	      elf_header.e_ident [EI_VERSION]);
d2558 2
a2559 2
    printf (_("\nDynamic segment at offset 0x%x contains %d entries:\n"),
	    dynamic_addr, dynamic_size);
d4917 1
a4917 1
      printf ("DW_OP_bra: %ld", byte_get (data, 2));
@


1.11
log
@Use 64bit wide values in internal fields.
Check symbol index against number of symbols when displaying relocations
@
text
@d3919 1
a3919 1
      printf ("  0x%8.8x ", addr);
d4792 1
a4792 1
    printf ("%lx ", byte_get (data ++, 1));
d4804 1
d4810 439
a5248 145
    case DW_OP_addr:	printf ("DW_OP_addr: %lx", byte_get (data, pointer_size)); break;
    case DW_OP_deref:	printf ("DW_OP_deref"); break;
    case DW_OP_const1u:	printf ("DW_OP_const1u: %lu", byte_get (data, 1)); break;
    case DW_OP_const1s:	printf ("DW_OP_const1s: %ld", (long) byte_get (data, 1)); break;
    case DW_OP_const2u:	printf ("DW_OP_const2u: %lu", byte_get (data, 2)); break;
    case DW_OP_const2s:	printf ("DW_OP_const2s: %ld", (long) byte_get (data, 2)); break;
    case DW_OP_const4u:	printf ("DW_OP_const4u: %lu", byte_get (data, 4)); break;
    case DW_OP_const4s:	printf ("DW_OP_const4s: %ld", (long) byte_get (data, 4)); break;
    case DW_OP_const8u:	printf ("DW_OP_const8u: %lu %lu", byte_get (data, 4), byte_get (data + 4, 4)); break;
    case DW_OP_const8s:	printf ("DW_OP_const8s: %ld %ld", byte_get (data, 4), byte_get (data + 4, 4)); break;
    case DW_OP_constu:	printf ("DW_OP_constu: %lu", read_leb128 (data, NULL, 0)); break;
    case DW_OP_consts:	printf ("DW_OP_consts: %ld", read_leb128 (data, NULL, 1)); break;
    case DW_OP_dup:	printf ("DW_OP_dup"); break;
    case DW_OP_drop:	printf ("DW_OP_drop"); break;
    case DW_OP_over:	printf ("DW_OP_over"); break;
    case DW_OP_pick:	printf ("DW_OP_pick: %ld", byte_get (data, 1)); break;
    case DW_OP_swap:	printf ("DW_OP_swap"); break;
    case DW_OP_rot:	printf ("DW_OP_rot"); break;
    case DW_OP_xderef:	printf ("DW_OP_xderef"); break;
    case DW_OP_abs:	printf ("DW_OP_abs"); break;
    case DW_OP_and:	printf ("DW_OP_and"); break;
    case DW_OP_div:	printf ("DW_OP_div"); break;
    case DW_OP_minus:	printf ("DW_OP_minus"); break;
    case DW_OP_mod:	printf ("DW_OP_mod"); break;
    case DW_OP_mul:	printf ("DW_OP_mul"); break;
    case DW_OP_neg:	printf ("DW_OP_neg"); break;
    case DW_OP_not:	printf ("DW_OP_not"); break;
    case DW_OP_or:	printf ("DW_OP_or"); break;
    case DW_OP_plus:	printf ("DW_OP_plus"); break;
    case DW_OP_plus_uconst:	printf ("DW_OP_plus_uconst: %lu", read_leb128 (data, NULL, 0)); break;
    case DW_OP_shl:	printf ("DW_OP_shl"); break;
    case DW_OP_shr:	printf ("DW_OP_shr"); break;
    case DW_OP_shra:	printf ("DW_OP_shra"); break;
    case DW_OP_xor:	printf ("DW_OP_xor"); break;
    case DW_OP_bra:	printf ("DW_OP_bra: %ld", byte_get (data, 2)); break;
    case DW_OP_eq:	printf ("DW_OP_eq"); break;
    case DW_OP_ge:	printf ("DW_OP_ge"); break;
    case DW_OP_gt:	printf ("DW_OP_gt"); break;
    case DW_OP_le:	printf ("DW_OP_le"); break;
    case DW_OP_lt:	printf ("DW_OP_lt"); break;
    case DW_OP_ne:	printf ("DW_OP_ne"); break;
    case DW_OP_skip:	printf ("DW_OP_skip: %ld", byte_get (data, 2)); break;
    case DW_OP_lit0:	printf ("DW_OP_lit0"); break;
    case DW_OP_lit1:	printf ("DW_OP_lit1"); break;
    case DW_OP_lit2:	printf ("DW_OP_lit2"); break;
    case DW_OP_lit3:	printf ("DW_OP_lit3"); break;
    case DW_OP_lit4:	printf ("DW_OP_lit4"); break;
    case DW_OP_lit5:	printf ("DW_OP_lit5"); break;
    case DW_OP_lit6:	printf ("DW_OP_lit6"); break;
    case DW_OP_lit7:	printf ("DW_OP_lit7"); break;
    case DW_OP_lit8:	printf ("DW_OP_lit8"); break;
    case DW_OP_lit9:	printf ("DW_OP_lit9"); break;
    case DW_OP_lit10:	printf ("DW_OP_lit10"); break;
    case DW_OP_lit11:	printf ("DW_OP_lit11"); break;
    case DW_OP_lit12:	printf ("DW_OP_lit12"); break;
    case DW_OP_lit13:	printf ("DW_OP_lit13"); break;
    case DW_OP_lit14:	printf ("DW_OP_lit14"); break;
    case DW_OP_lit15:	printf ("DW_OP_lit15"); break;
    case DW_OP_lit16:	printf ("DW_OP_lit16"); break;
    case DW_OP_lit17:	printf ("DW_OP_lit17"); break;
    case DW_OP_lit18:	printf ("DW_OP_lit18"); break;
    case DW_OP_lit19:	printf ("DW_OP_lit19"); break;
    case DW_OP_lit20:	printf ("DW_OP_lit20"); break;
    case DW_OP_lit21:	printf ("DW_OP_lit21"); break;
    case DW_OP_lit22:	printf ("DW_OP_lit22"); break;
    case DW_OP_lit23:	printf ("DW_OP_lit23"); break;
    case DW_OP_lit24:	printf ("DW_OP_lit24"); break;
    case DW_OP_lit25:	printf ("DW_OP_lit25"); break;
    case DW_OP_lit26:	printf ("DW_OP_lit26"); break;
    case DW_OP_lit27:	printf ("DW_OP_lit27"); break;
    case DW_OP_lit28:	printf ("DW_OP_lit28"); break;
    case DW_OP_lit29:	printf ("DW_OP_lit29"); break;
    case DW_OP_lit30:	printf ("DW_OP_lit30"); break;
    case DW_OP_lit31:	printf ("DW_OP_lit31"); break;
    case DW_OP_reg0:	printf ("DW_OP_reg0"); break;
    case DW_OP_reg1:	printf ("DW_OP_reg1"); break;
    case DW_OP_reg2:	printf ("DW_OP_reg2"); break;
    case DW_OP_reg3:	printf ("DW_OP_reg3"); break;
    case DW_OP_reg4:	printf ("DW_OP_reg4"); break;
    case DW_OP_reg5:	printf ("DW_OP_reg5"); break;
    case DW_OP_reg6:	printf ("DW_OP_reg6"); break;
    case DW_OP_reg7:	printf ("DW_OP_reg7"); break;
    case DW_OP_reg8:	printf ("DW_OP_reg8"); break;
    case DW_OP_reg9:	printf ("DW_OP_reg9"); break;
    case DW_OP_reg10:	printf ("DW_OP_reg10"); break;
    case DW_OP_reg11:	printf ("DW_OP_reg11"); break;
    case DW_OP_reg12:	printf ("DW_OP_reg12"); break;
    case DW_OP_reg13:	printf ("DW_OP_reg13"); break;
    case DW_OP_reg14:	printf ("DW_OP_reg14"); break;
    case DW_OP_reg15:	printf ("DW_OP_reg15"); break;
    case DW_OP_reg16:	printf ("DW_OP_reg16"); break;
    case DW_OP_reg17:	printf ("DW_OP_reg17"); break;
    case DW_OP_reg18:	printf ("DW_OP_reg18"); break;
    case DW_OP_reg19:	printf ("DW_OP_reg19"); break;
    case DW_OP_reg20:	printf ("DW_OP_reg20"); break;
    case DW_OP_reg21:	printf ("DW_OP_reg21"); break;
    case DW_OP_reg22:	printf ("DW_OP_reg22"); break;
    case DW_OP_reg23:	printf ("DW_OP_reg23"); break;
    case DW_OP_reg24:	printf ("DW_OP_reg24"); break;
    case DW_OP_reg25:	printf ("DW_OP_reg25"); break;
    case DW_OP_reg26:	printf ("DW_OP_reg26"); break;
    case DW_OP_reg27:	printf ("DW_OP_reg27"); break;
    case DW_OP_reg28:	printf ("DW_OP_reg28"); break;
    case DW_OP_reg29:	printf ("DW_OP_reg29"); break;
    case DW_OP_reg30:	printf ("DW_OP_reg30"); break;
    case DW_OP_reg31:	printf ("DW_OP_reg31"); break;
    case DW_OP_breg0:	printf ("DW_OP_breg0: %ld", read_leb128 (data, NULL, 1)); break;
    case DW_OP_breg1:	printf ("DW_OP_breg1: %ld", read_leb128 (data, NULL, 1)); break;
    case DW_OP_breg2:	printf ("DW_OP_breg2: %ld", read_leb128 (data, NULL, 1)); break;
    case DW_OP_breg3:	printf ("DW_OP_breg3: %ld", read_leb128 (data, NULL, 1)); break;
    case DW_OP_breg4:	printf ("DW_OP_breg4: %ld", read_leb128 (data, NULL, 1)); break;
    case DW_OP_breg5:	printf ("DW_OP_breg5: %ld", read_leb128 (data, NULL, 1)); break;
    case DW_OP_breg6:	printf ("DW_OP_breg6: %ld", read_leb128 (data, NULL, 1)); break;
    case DW_OP_breg7:	printf ("DW_OP_breg7: %ld", read_leb128 (data, NULL, 1)); break;
    case DW_OP_breg8:	printf ("DW_OP_breg8: %ld", read_leb128 (data, NULL, 1)); break;
    case DW_OP_breg9:	printf ("DW_OP_breg9: %ld", read_leb128 (data, NULL, 1)); break;
    case DW_OP_breg10:	printf ("DW_OP_breg10: %ld", read_leb128 (data, NULL, 1)); break;
    case DW_OP_breg11:	printf ("DW_OP_breg11: %ld", read_leb128 (data, NULL, 1)); break;
    case DW_OP_breg12:	printf ("DW_OP_breg12: %ld", read_leb128 (data, NULL, 1)); break;
    case DW_OP_breg13:	printf ("DW_OP_breg13: %ld", read_leb128 (data, NULL, 1)); break;
    case DW_OP_breg14:	printf ("DW_OP_breg14: %ld", read_leb128 (data, NULL, 1)); break;
    case DW_OP_breg15:	printf ("DW_OP_breg15: %ld", read_leb128 (data, NULL, 1)); break;
    case DW_OP_breg16:	printf ("DW_OP_breg16: %ld", read_leb128 (data, NULL, 1)); break;
    case DW_OP_breg17:	printf ("DW_OP_breg17: %ld", read_leb128 (data, NULL, 1)); break;
    case DW_OP_breg18:	printf ("DW_OP_breg18: %ld", read_leb128 (data, NULL, 1)); break;
    case DW_OP_breg19:	printf ("DW_OP_breg19: %ld", read_leb128 (data, NULL, 1)); break;
    case DW_OP_breg20:	printf ("DW_OP_breg20: %ld", read_leb128 (data, NULL, 1)); break;
    case DW_OP_breg21:	printf ("DW_OP_breg21: %ld", read_leb128 (data, NULL, 1)); break;
    case DW_OP_breg22:	printf ("DW_OP_breg22: %ld", read_leb128 (data, NULL, 1)); break;
    case DW_OP_breg23:	printf ("DW_OP_breg23: %ld", read_leb128 (data, NULL, 1)); break;
    case DW_OP_breg24:	printf ("DW_OP_breg24: %ld", read_leb128 (data, NULL, 1)); break;
    case DW_OP_breg25:	printf ("DW_OP_breg25: %ld", read_leb128 (data, NULL, 1)); break;
    case DW_OP_breg26:	printf ("DW_OP_breg26: %ld", read_leb128 (data, NULL, 1)); break;
    case DW_OP_breg27:	printf ("DW_OP_breg27: %ld", read_leb128 (data, NULL, 1)); break;
    case DW_OP_breg28:	printf ("DW_OP_breg28: %ld", read_leb128 (data, NULL, 1)); break;
    case DW_OP_breg29:	printf ("DW_OP_breg29: %ld", read_leb128 (data, NULL, 1)); break;
    case DW_OP_breg30:	printf ("DW_OP_breg30: %ld", read_leb128 (data, NULL, 1)); break;
    case DW_OP_breg31:	printf ("DW_OP_breg31: %ld", read_leb128 (data, NULL, 1)); break;
    case DW_OP_regx:	printf ("DW_OP_regx: %lu", read_leb128 (data, NULL, 0)); break;
    case DW_OP_fbreg:	printf ("DW_OP_fbreg: %ld", read_leb128 (data, NULL, 1)); break;
    case DW_OP_bregx:	printf ("DW_OP_bregx: %lu %ld", read_leb128 (data, & bytes_read, 0), read_leb128 (data + bytes_read, NULL, 1)); break;
    case DW_OP_piece:	printf ("DW_OP_piece: %lu", read_leb128 (data, NULL, 0)); break;
    case DW_OP_deref_size:	printf ("DW_OP_deref_size: %ld", byte_get (data, 1)); break;
    case DW_OP_xderef_size:	printf ("DW_OP_xderef_size: %ld", byte_get (data, 1)); break;
    case DW_OP_nop:	printf ("DW_OP_nop"); break;
d5320 1
a5320 1
      printf (" %lx", byte_get (data + 4, 4));
@


1.10
log
@Add support for 64 bit ELF files.
@
text
@d30 3
d82 1
d127 1
a127 1
static int                dump_relocations            PARAMS ((FILE *, unsigned long, unsigned long, Elf_Internal_Sym *, char *, int));
d437 1
a437 1
dump_relocations (file, rel_offset, rel_size, symtab, strtab, is_rela)
d442 1
a599 1

d715 1
a715 1
      if (symtab_index && symtab != NULL)
d717 7
a723 1
	  Elf_Internal_Sym * psym;
d725 16
a740 14
	  psym = symtab + symtab_index;

	  printf (" %08lx  ", (unsigned long) psym->st_value);

	  if (psym->st_name == 0)
	    printf ("%-25.25s",
		    SECTION_NAME (section_headers + psym->st_shndx));
	  else if (strtab == NULL)
	    printf (_("<string table index %3ld>"), psym->st_name);
	  else
	    printf ("%-25.25s", strtab + psym->st_name);

	  if (is_rela)
	    printf (" + %lx", (unsigned long) relas [i].r_addend);
d2057 1
d2059 1
a2059 2
	    GET_ELF_SYMBOLS (file, section->sh_offset,
			     section->sh_size / section->sh_entsize);
d2159 1
d2181 1
a2181 1
			    dynamic_symbols, dynamic_strings, is_rela);
d2210 1
d2215 1
a2215 3
		{
		  printf ("%d", section->sh_name);
		}
d2217 1
a2217 3
		{
		  printf ("'%s'", SECTION_NAME (section));
		}
d2224 2
a2225 3
	      symtab = 
		GET_ELF_SYMBOLS (file, symsec->sh_offset,
				 symsec->sh_size / symsec->sh_entsize);
d2237 1
a2237 1
	      dump_relocations (file, rel_offset, rel_size, symtab, strtab, is_rela);
a2436 1
	  long                 num_syms;
d2453 1
a2453 1
	    num_syms = (ftell (file) - offset) / sizeof (Elf32_External_Sym);
d2455 1
a2455 1
	    num_syms = (ftell (file) - offset) / sizeof (Elf64_External_Sym);
d2457 1
a2457 1
	  if (num_syms < 1)
d2463 1
a2463 1
	  dynamic_symbols = GET_ELF_SYMBOLS (file, offset, num_syms);
d5877 1
a5877 1
	  Elf_Internal_Sym *psym = &dynamic_symbols[iconf[cnt]];
d6061 1
@


1.9
log
@	* readelf.c (process_relocs): Determine type of reloc from
	DT_PLTREL and from section type.
@
text
@d74 1
a74 1
unsigned int    	dynamic_size;
d107 1
a107 1
int			binary_class;
d118 5
a122 3
static unsigned long (*   byte_get)                   PARAMS ((unsigned char *, int));
static const char *       get_mips_dynamic_type       PARAMS ((unsigned long type));
static const char *       get_dynamic_type            PARAMS ((unsigned long type));
d124 9
a132 10
static char *             get_file_type               PARAMS ((unsigned e_type));
static char *             get_machine_name            PARAMS ((unsigned e_machine));
static char *             get_machine_data            PARAMS ((unsigned e_data));
static char *             get_machine_flags           PARAMS ((unsigned, unsigned e_machine));
static const char *       get_mips_segment_type       PARAMS ((unsigned long type));
static const char *       get_segment_type            PARAMS ((unsigned long p_type));
static const char *       get_mips_section_type_name  PARAMS ((unsigned int sh_type));
static const char *       get_section_type_name       PARAMS ((unsigned int sh_type));
static char *             get_symbol_binding          PARAMS ((unsigned int binding));
static char *             get_symbol_type             PARAMS ((unsigned int type));
d134 1
a134 1
static void               parse_args                  PARAMS ((int argc, char ** argv));
d138 1
a138 1
static void               dynamic_segment_mips_val    PARAMS ((Elf_Internal_Dyn *entry));
d142 1
a142 1
static void               process_file                PARAMS ((char * file_name));
d145 12
a156 6
static char *             get_ver_flags               PARAMS ((unsigned int flags));
static char *             get_symbol_index_type       PARAMS ((unsigned int type));
static int                get_section_headers         PARAMS ((FILE * file));
static int                get_file_header             PARAMS ((FILE * file));
static Elf_Internal_Sym * get_elf_symbols             PARAMS ((FILE * file, unsigned long offset, unsigned long number));
static int *              get_dynamic_data            PARAMS ((FILE * file, unsigned int number));
d199 1
d239 5
d300 1
a300 1
static unsigned long int
d314 5
d325 14
d341 1
a341 1
      abort();
d345 1
a345 1
static unsigned long int
d364 22
d388 1
a388 1
      abort();
d431 1
a431 2
/* Display the contents of the relocation data
   found at the specified offset.  */
d434 6
a439 6
     FILE *                 file;
     unsigned long          rel_offset;
     unsigned long          rel_size;
     Elf_Internal_Sym *     symtab;
     char *                 strtab;
     int                    is_rela;
d451 11
a461 1
      Elf32_External_Rela * erelas;
d463 12
a474 2
      GET_DATA_ALLOC (rel_offset, rel_size, erelas,
		      Elf32_External_Rela *, "relocs");
d476 1
a476 1
      rel_size = rel_size / sizeof (Elf32_External_Rela);
d478 3
a480 4
      relas = (Elf_Internal_Rela *) malloc (rel_size *
					    sizeof (Elf_Internal_Rela));
      
      if (relas == NULL)
d482 9
a490 3
	  error(_("out of memory parsing relocs"));
	  return 0;
	}
d492 12
a503 6
      for (i = 0; i < rel_size; i++)
	{
	  relas[i].r_offset = BYTE_GET (erelas[i].r_offset);
	  relas[i].r_info   = BYTE_GET (erelas[i].r_info);
	  relas[i].r_addend = BYTE_GET (erelas[i].r_addend);
	}
d505 1
a505 1
      free (erelas);
d507 2
a508 1
      rels = (Elf_Internal_Rel *) relas;
d512 3
a514 2
      Elf32_External_Rel * erels;
      unsigned long        saved_rel_size = rel_size;
d516 23
a538 11
      GET_DATA_ALLOC (rel_offset, rel_size, erels,
		      Elf32_External_Rel *, "relocs");
      
      rel_size = rel_size / sizeof (Elf32_External_Rel);
      
      rels = (Elf_Internal_Rel *) malloc (rel_size *
					  sizeof (Elf_Internal_Rel));
      if (rels == NULL)
	{
	  error(_("out of memory parsing relocs"));
	  return 0;
d540 1
a540 2
      
      for (i = 0; i < rel_size; i++)
d542 25
a566 2
	  rels[i].r_offset = BYTE_GET (erels[i].r_offset);
	  rels[i].r_info   = BYTE_GET (erels[i].r_info);
a567 4
      
      free (erels);
      
      relas = (Elf_Internal_Rela *) rels;
d579 6
a584 5
      const char *  rtype;
      unsigned long offset;
      unsigned long info;
      int           symtab_index;

d596 15
d612 2
a613 1

d621 1
a621 1
	  rtype = elf_m32r_reloc_type (ELF32_R_TYPE (info));
d626 1
a626 1
	  rtype = elf_i386_reloc_type (ELF32_R_TYPE (info));
d630 1
a630 1
	  rtype = elf_m68k_reloc_type (ELF32_R_TYPE (info));
d634 1
a634 1
	  rtype = elf_i960_reloc_type (ELF32_R_TYPE (info));
d637 3
d641 1
a641 1
	  rtype = elf_sparc_reloc_type (ELF32_R_TYPE (info));
d645 1
a645 1
	  rtype = v850_reloc_type (ELF32_R_TYPE (info));
d649 1
a649 1
	  rtype = elf_d10v_reloc_type (ELF32_R_TYPE (info));
d653 1
a653 1
	  rtype = elf_d30v_reloc_type (ELF32_R_TYPE (info));
d657 1
a657 1
	  rtype = elf_sh_reloc_type (ELF32_R_TYPE (info));
d661 1
a661 1
	  rtype = elf_mn10300_reloc_type (ELF32_R_TYPE (info));
d665 1
a665 1
	  rtype = elf_mn10200_reloc_type (ELF32_R_TYPE (info));
d669 1
a669 1
	  rtype = elf_fr30_reloc_type (ELF32_R_TYPE (info));
d673 1
a673 1
	  rtype = elf_mcore_reloc_type (ELF32_R_TYPE (info));
d677 1
a677 1
	  rtype = elf_ppc_reloc_type (ELF32_R_TYPE (info));
d682 1
a682 1
	  rtype = elf_mips_reloc_type (ELF32_R_TYPE (info));
d686 1
a686 1
	  rtype = elf_alpha_reloc_type (ELF32_R_TYPE (info));
d690 1
a690 1
	  rtype = elf_arm_reloc_type (ELF32_R_TYPE (info));
d694 1
a694 1
	  rtype = elf_arc_reloc_type (ELF32_R_TYPE (info));
d698 1
a698 1
	  rtype = elf32_hppa_reloc_type (ELF32_R_TYPE (info));
d703 5
a707 1
	printf (_("unrecognised: %-7lx"), ELF32_R_TYPE (info));
a710 2
      symtab_index = ELF32_R_SYM (info);

a1058 16
static char *
get_machine_data (e_data)
     unsigned e_data;
{
  static char buff [32];

  switch (e_data)
    {
    case ELFDATA2LSB: return _("ELFDATA2LSB (little endian)");
    case ELFDATA2MSB: return _("ELFDATA2MSB (big endian)");
    default:
      sprintf (buff, _("<unknown>: %x"), e_data);
      return buff;
    }
}

a1566 2
      printf (_("  Data:                              %s\n"),
	      get_machine_data (elf_header.e_ident [EI_DATA]));
d1589 4
d1594 9
a1602 2
  /* Test class after dumping header so that at least the header can be
     display on 64 bit binaries.  */
d1604 7
a1610 2
  binary_class = elf_header.e_ident [EI_CLASS];
  if (binary_class != ELFCLASS32)
d1612 8
a1619 2
      error (_("Not a 32 bit ELF file\n"));
      return 0;
d1622 2
d1627 32
d1664 3
a1666 4
  Elf32_External_Phdr * phdrs;
  Elf32_Internal_Phdr * program_headers;
  Elf32_Internal_Phdr * segment;
  unsigned int	        i;
d1683 2
a1684 6
  GET_DATA_ALLOC (elf_header.e_phoff,
		  elf_header.e_phentsize * elf_header.e_phnum,
		  phdrs, Elf32_External_Phdr *, "program headers");

  program_headers = (Elf32_Internal_Phdr *) malloc
    (elf_header.e_phnum * sizeof (Elf32_Internal_Phdr));
d1692 6
a1697 3
  for (i = 0, segment = program_headers;
       i < elf_header.e_phnum;
       i ++, segment ++)
d1699 2
a1700 8
      segment->p_type   = BYTE_GET (phdrs[i].p_type);
      segment->p_offset = BYTE_GET (phdrs[i].p_offset);
      segment->p_vaddr  = BYTE_GET (phdrs[i].p_vaddr);
      segment->p_paddr  = BYTE_GET (phdrs[i].p_paddr);
      segment->p_filesz = BYTE_GET (phdrs[i].p_filesz);
      segment->p_memsz  = BYTE_GET (phdrs[i].p_memsz);
      segment->p_flags  = BYTE_GET (phdrs[i].p_flags);
      segment->p_align  = BYTE_GET (phdrs[i].p_align);
d1702 1
a1702 3

  free (phdrs);

d1784 2
a1785 2
	  int        j;
	  Elf32_Internal_Shdr * section;
d1818 1
a1818 1
get_section_headers (file)
d1829 2
a1830 2
  section_headers = (Elf32_Internal_Shdr *) malloc
    (elf_header.e_shnum * sizeof (Elf32_Internal_Shdr));
d1859 42
d1902 1
a1902 1
get_elf_symbols (file, offset, number)
d1942 41
d1987 2
a1988 2
  Elf32_Internal_Shdr * section;
  int        i;
d2001 1
a2001 1
    printf (_("There are %d section headers, starting at offset %lx:\n"),
d2004 6
a2009 1
  if (! get_section_headers (file))
d2030 1
d2045 3
a2047 3
	  dynamic_symbols = get_elf_symbols
	    (file, section->sh_offset,
	     section->sh_size / section->sh_entsize);
d2214 3
a2216 2
	      symtab = get_elf_symbols (file, symsec->sh_offset,
					symsec->sh_size / symsec->sh_entsize);
a2313 1
/* Parse the dynamic segment */
d2315 1
a2315 1
process_dynamic_segment (file)
d2318 16
a2333 3
  Elf_Internal_Dyn *    entry;
  Elf32_External_Dyn *  edyn;
  unsigned int i;
d2335 1
a2335 1
  if (dynamic_size == 0)
d2337 4
a2340 2
      if (do_dynamic)
	printf (_("\nThere is no dynamic segment in this file.\n"));
d2342 6
a2347 1
      return 1;
d2350 13
d2364 1
a2364 1
		  edyn, Elf32_External_Dyn *, "dynamic segment");
d2367 1
a2367 1
     how large .dynamic is now.  We can do this even before the byte
d2370 1
a2370 1
  while (*(Elf32_Word *) edyn[dynamic_size++].d_tag != DT_NULL)
d2387 2
a2388 2
      entry->d_tag      = BYTE_GET (edyn [i].d_tag);
      entry->d_un.d_val = BYTE_GET (edyn [i].d_un.d_val);
d2393 27
a2438 1

d2444 4
a2447 1
	  num_syms = (ftell (file) - offset) / sizeof (Elf32_External_Sym);
d2455 1
a2455 1
	  dynamic_symbols = get_elf_symbols (file, offset, num_syms);
d2521 2
a2522 2
	  Elf_External_Syminfo *extsyminfo;
	  Elf_Internal_Syminfo *syminfo;
d3074 2
a3075 3
	    symbols = get_elf_symbols
	      (file, link_section->sh_offset,
	       link_section->sh_size / link_section->sh_entsize);
d3563 1
a3563 1
	  symtab = get_elf_symbols (file, section->sh_offset,
d3880 2
a3881 2
  int             bytes;
  int             addr;
d3915 1
d5529 1
a5529 1
     FILE *file;
d5531 1
a5531 1
  Elf_Internal_Dyn *entry;
d5567 1
a5567 1
      Elf32_External_Lib *elib;
d5635 4
a5638 4
      Elf_External_Options *eopt;
      Elf_Internal_Shdr *sect = section_headers;
      Elf_Internal_Options *iopt;
      Elf_Internal_Options *option;
d5661 1
a5661 1
	  Elf_External_Options *eoption;
d5715 1
a5715 1
		  Elf64_External_RegInfo *ereg;
d5719 1
a5719 1
		  reginfo.ri_gprmask = BYTE_GET (ereg->ri_gprmask);
d5724 1
a5724 1
		  reginfo.ri_gp_value = BYTE_GET (ereg->ri_gp_value);
d5829 3
a5831 3
      Elf32_External_Conflict *econf32;
      Elf64_External_Conflict *econf64;
      Elf32_Conflict *iconf;
d5847 1
a5847 1
      if (binary_class == ELFCLASS32)
d5885 1
a5885 1
     FILE *file;
d5903 3
a5905 1
  Elf32_External_Ehdr ehdr;
d5907 11
a5917 2
  if (fread (& ehdr, sizeof (ehdr), 1, file) != 1)
    return 0;
d5919 4
a5922 1
  memcpy (elf_header.e_ident, ehdr.e_ident, EI_NIDENT);
d5924 17
a5940 2
  if (elf_header.e_ident [EI_DATA] == ELFDATA2LSB)
    byte_get = byte_get_little_endian;
d5942 20
a5961 15
    byte_get = byte_get_big_endian;

  elf_header.e_entry     = BYTE_GET (ehdr.e_entry);
  elf_header.e_phoff     = BYTE_GET (ehdr.e_phoff);
  elf_header.e_shoff     = BYTE_GET (ehdr.e_shoff);
  elf_header.e_version   = BYTE_GET (ehdr.e_version);
  elf_header.e_flags     = BYTE_GET (ehdr.e_flags);
  elf_header.e_type      = BYTE_GET (ehdr.e_type);
  elf_header.e_machine   = BYTE_GET (ehdr.e_machine);
  elf_header.e_ehsize    = BYTE_GET (ehdr.e_ehsize);
  elf_header.e_phentsize = BYTE_GET (ehdr.e_phentsize);
  elf_header.e_phnum     = BYTE_GET (ehdr.e_phnum);
  elf_header.e_shentsize = BYTE_GET (ehdr.e_shentsize);
  elf_header.e_shnum     = BYTE_GET (ehdr.e_shnum);
  elf_header.e_shstrndx  = BYTE_GET (ehdr.e_shstrndx);
d6064 2
a6065 2
fix this so that we insert symbolic addresses here, esp for GOT/PLT
symbols */
@


1.8
log
@Display unknown values detected in ELF program header.
@
text
@d1892 12
a1903 1
	  is_rela    = UNKNOWN;
a1947 1
		  is_rela = UNKNOWN;
a1951 7

		  if (strncmp (".rela.", SECTION_NAME (section), 6) == 0)
		    is_rela = TRUE;
		  else if (strncmp (".rel.", SECTION_NAME (section), 5) == 0)
		    is_rela = FALSE;
		  else
		    is_rela = UNKNOWN;
d1969 2
@


1.7
log
@fix typo.
@
text
@d1356 2
d1363 3
a1365 1
    default:           return _("<unknown>");
d1373 2
d1380 3
a1382 1
    default:          return _("<unknown>");
d1390 2
d1397 3
a1399 1
    default:                  return _("<unknown>");
d1433 2
a1434 1
	      elf_header.e_ident [EI_VERSION] != EV_NONE ? "<unknown>" : "");
@


1.6
log
@remove spurious code.
@
text
@d380 1
a380 1
dump_relocations (file, rel_offset, rel_size, symtab, strtabm, is_rela)
@


1.5
log
@Better coping with different reloc types.
@
text
@a365 3
/* start-sanitize-venus */
    case EM_CYGNUS_VENUS:
/* end-sanitize-venus */
@


1.4
log
@	* readelf.c: Include "elf/i960.h".
	(dump_relocations): Handle EM_960.
@
text
@d121 1
a121 1
static int                dump_relocations            PARAMS ((FILE *, unsigned long, unsigned long, Elf_Internal_Sym *, char *));
d177 1
d181 6
d339 1
a339 2
/* Display the contents of the relocation data
   found at the specified offset.  */
d341 2
a342 6
dump_relocations (file, rel_offset, rel_size, symtab, strtab)
     FILE *                 file;
     unsigned long          rel_offset;
     unsigned long          rel_size;
     Elf_Internal_Sym *     symtab;
     char *                 strtab;
d344 1
a344 8
  unsigned int        i;
  int                 is_rela;
  Elf_Internal_Rel *  rels;
  Elf_Internal_Rela * relas;


  /* Compute number of relocations and read them in.  */
  switch (elf_header.e_machine)
d355 2
a356 24
      {
	Elf32_External_Rel * erels;

	GET_DATA_ALLOC (rel_offset, rel_size, erels,
			Elf32_External_Rel *, "relocs");

	rel_size = rel_size / sizeof (Elf32_External_Rel);

	rels = (Elf_Internal_Rel *) malloc (rel_size *
					    sizeof (Elf_Internal_Rel));

	for (i = 0; i < rel_size; i++)
	  {
	    rels[i].r_offset = BYTE_GET (erels[i].r_offset);
	    rels[i].r_info   = BYTE_GET (erels[i].r_info);
	  }

	free (erels);

	is_rela = 0;
	relas   = (Elf_Internal_Rela *) rels;
      }
    break;

d366 3
d372 7
a378 2
      {
	Elf32_External_Rela * erelas;
d380 14
a393 2
	GET_DATA_ALLOC (rel_offset, rel_size, erelas,
			Elf32_External_Rela *, "relocs");
d395 3
a397 1
	rel_size = rel_size / sizeof (Elf32_External_Rela);
d399 33
a431 16
	relas = (Elf_Internal_Rela *) malloc (rel_size *
					      sizeof (Elf_Internal_Rela));

	for (i = 0; i < rel_size; i++)
	  {
	    relas[i].r_offset = BYTE_GET (erelas[i].r_offset);
	    relas[i].r_info   = BYTE_GET (erelas[i].r_info);
	    relas[i].r_addend = BYTE_GET (erelas[i].r_addend);
	  }

	free (erelas);

	is_rela = 1;
	rels    = (Elf_Internal_Rel *) relas;
      }
    break;
d433 22
a454 3
    default:
      warn (_("Don't know about relocations on this machine architecture\n"));
      return 0;
d1861 2
d1870 1
d1876 1
d1882 1
d1892 1
a1892 1
			    dynamic_symbols, dynamic_strings);
d1920 2
a1921 1

d1925 4
a1928 1
		printf ("%d", section->sh_name);
d1930 10
a1939 1
		printf ("'%s'", SECTION_NAME (section));
d1957 1
a1957 1
	      dump_relocations (file, rel_offset, rel_size, symtab, strtab);
@


1.3
log
@	* readelf.c (dump_relocations): Always print the addend on RELA
	systems even if there is no symbol.
	(process_program_headers): Reset dynamic_size before looping
	through the program headers.
	(process_version_sections): Cast sh_offset to unsigned long for
	printing in case bfd_vma is wider.
	(process_symbol_table): Use get_symbol_index_type when printing
	st_shndx.
@
text
@d61 1
d355 1
d470 4
@


1.2
log
@       * readelf.c (get_machine_flags):  Check for EF_CPU32.
        (get_data_encoding): Fix typo.
@
text
@d558 2
d1500 1
d2513 1
a2513 1
		    section->sh_offset, section->sh_link,
d2601 1
a2601 1
		    section->sh_offset, section->sh_link,
d2702 1
a2702 1
		    section->sh_offset, section->sh_link,
d3206 1
a3206 8
	      if (psym->st_shndx == 0)
		fputs (" UND", stdout);
	      else if ((psym->st_shndx & 0xffff) == 0xfff1)
		fputs (" ABS", stdout);
	      else if ((psym->st_shndx & 0xffff) == 0xfff2)
		fputs (" COM", stdout);
	      else
		printf ("%4x", psym->st_shndx);
@


1.1
log
@Initial revision
@
text
@d813 5
d1336 2
a1337 2
    case ELFDATA2LSB: return _("2's compilment, little endian");
    case ELFDATA2MSB: return _("2's compilment, big endian");
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

