head	1.42;
access;
symbols
	binutils-2_24-branch:1.42.0.2
	binutils-2_24-branchpoint:1.42
	binutils-2_21_1:1.36.2.1
	binutils-2_23_2:1.41
	binutils-2_23_1:1.41
	binutils-2_23:1.41
	binutils-2_23-branch:1.41.0.2
	binutils-2_23-branchpoint:1.41
	binutils-2_22_branch:1.37.0.4
	binutils-2_22:1.37
	binutils-2_22-branch:1.37.0.2
	binutils-2_22-branchpoint:1.37
	binutils-2_21:1.36
	binutils-2_21-branch:1.36.0.2
	binutils-2_21-branchpoint:1.36
	binutils-2_20_1:1.35
	binutils-2_20:1.35
	binutils-arc-20081103-branch:1.35.0.10
	binutils-arc-20081103-branchpoint:1.35
	binutils-2_20-branch:1.35.0.8
	binutils-2_20-branchpoint:1.35
	dje-cgen-play1-branch:1.35.0.6
	dje-cgen-play1-branchpoint:1.35
	arc-20081103-branch:1.35.0.4
	arc-20081103-branchpoint:1.35
	binutils-2_19_1:1.35
	binutils-2_19:1.35
	binutils-2_19-branch:1.35.0.2
	binutils-2_19-branchpoint:1.35
	binutils-2_18:1.32
	binutils-2_18-branch:1.32.0.2
	binutils-2_18-branchpoint:1.32
	binutils-csl-coldfire-4_1-32:1.27
	binutils-csl-sourcerygxx-4_1-32:1.27
	binutils-csl-innovasic-fido-3_4_4-33:1.27
	binutils-csl-sourcerygxx-3_4_4-32:1.26
	binutils-csl-coldfire-4_1-30:1.27
	binutils-csl-sourcerygxx-4_1-30:1.27
	binutils-csl-coldfire-4_1-28:1.27
	binutils-csl-sourcerygxx-4_1-29:1.27
	binutils-csl-sourcerygxx-4_1-28:1.27
	binutils-csl-arm-2006q3-27:1.27
	binutils-csl-sourcerygxx-4_1-27:1.27
	binutils-csl-arm-2006q3-26:1.27
	binutils-csl-sourcerygxx-4_1-26:1.27
	binutils-csl-sourcerygxx-4_1-25:1.27
	binutils-csl-sourcerygxx-4_1-24:1.27
	binutils-csl-sourcerygxx-4_1-23:1.27
	binutils-csl-sourcerygxx-4_1-21:1.27
	binutils-csl-arm-2006q3-21:1.27
	binutils-csl-sourcerygxx-4_1-22:1.27
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.27
	binutils-csl-sourcerygxx-4_1-20:1.27
	binutils-csl-arm-2006q3-19:1.27
	binutils-csl-sourcerygxx-4_1-19:1.27
	binutils-csl-sourcerygxx-4_1-18:1.27
	binutils-csl-renesas-4_1-9:1.27
	binutils-csl-sourcerygxx-3_4_4-25:1.26
	binutils-csl-renesas-4_1-8:1.27
	binutils-csl-renesas-4_1-7:1.27
	binutils-csl-renesas-4_1-6:1.27
	binutils-csl-sourcerygxx-4_1-17:1.27
	binutils-csl-sourcerygxx-4_1-14:1.27
	binutils-csl-sourcerygxx-4_1-15:1.27
	binutils-csl-sourcerygxx-4_1-13:1.27
	binutils-2_17:1.27
	binutils-csl-sourcerygxx-4_1-12:1.27
	binutils-csl-sourcerygxx-3_4_4-21:1.27
	binutils-csl-wrs-linux-3_4_4-24:1.26
	binutils-csl-wrs-linux-3_4_4-23:1.26
	binutils-csl-sourcerygxx-4_1-9:1.27
	binutils-csl-sourcerygxx-4_1-8:1.27
	binutils-csl-sourcerygxx-4_1-7:1.27
	binutils-csl-arm-2006q1-6:1.27
	binutils-csl-sourcerygxx-4_1-6:1.27
	binutils-csl-wrs-linux-3_4_4-22:1.26
	binutils-csl-coldfire-4_1-11:1.27
	binutils-csl-sourcerygxx-3_4_4-19:1.27
	binutils-csl-coldfire-4_1-10:1.27
	binutils-csl-sourcerygxx-4_1-5:1.27
	binutils-csl-sourcerygxx-4_1-4:1.27
	binutils-csl-wrs-linux-3_4_4-21:1.26
	binutils-csl-morpho-4_1-4:1.27
	binutils-csl-sourcerygxx-3_4_4-17:1.27
	binutils-csl-wrs-linux-3_4_4-20:1.26
	binutils-2_17-branch:1.27.0.4
	binutils-2_17-branchpoint:1.27
	binutils-csl-2_17-branch:1.27.0.2
	binutils-csl-2_17-branchpoint:1.27
	binutils-csl-gxxpro-3_4-branch:1.26.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.26
	binutils-2_16_1:1.26
	binutils-csl-arm-2005q1b:1.26
	binutils-2_16:1.26
	binutils-csl-arm-2005q1a:1.26
	binutils-csl-arm-2005q1-branch:1.26.0.4
	binutils-csl-arm-2005q1-branchpoint:1.26
	binutils-2_16-branch:1.26.0.2
	binutils-2_16-branchpoint:1.26
	csl-arm-2004-q3d:1.25
	csl-arm-2004-q3:1.25
	binutils-2_15:1.25
	binutils-2_15-branchpoint:1.25
	csl-arm-2004-q1a:1.25
	csl-arm-2004-q1:1.25
	binutils-2_15-branch:1.25.0.6
	cagney_bfdfile-20040213-branch:1.25.0.4
	cagney_bfdfile-20040213-branchpoint:1.25
	cagney_bigcore-20040122-branch:1.25.0.2
	cagney_bigcore-20040122-branchpoint:1.25
	csl-arm-2003-q4:1.25
	binutils-2_14:1.21
	binutils-2_14-branch:1.21.0.2
	binutils-2_14-branchpoint:1.21
	binutils-2_13_2_1:1.20
	binutils-2_13_2:1.20
	binutils-2_13_1:1.20
	binutils-2_13:1.20
	binutils-2_13-branchpoint:1.20
	binutils-2_13-branch:1.20.0.2
	binutils-2_12_1:1.14.2.1
	binutils-2_12:1.14
	binutils-2_12-branch:1.14.0.2
	binutils-2_12-branchpoint:1.14
	cygnus_cvs_20020108_pre:1.14
	binutils-2_11_2:1.11.2.1
	binutils-2_11_1:1.11.2.1
	binutils-2_11:1.11
	x86_64versiong3:1.11
	binutils-2_11-branch:1.11.0.2
	binutils-2_10_1:1.7
	binutils-2_10:1.7
	binutils-2_10-branch:1.7.0.2
	binutils-2_10-branchpoint:1.7
	binutils_latest_snapshot:1.42
	repo-unification-2000-02-06:1.6
	binu_ss_19990721:1.4
	binu_ss_19990602:1.2
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.42
date	2012.11.09.08.29.31;	author hjl;	state Exp;
branches;
next	1.41;

1.41
date	2012.02.11.15.15.34;	author ktietz;	state Exp;
branches;
next	1.40;

1.40
date	2012.02.09.04.51.44;	author amodra;	state Exp;
branches;
next	1.39;

1.39
date	2011.10.25.08.03.17;	author ktietz;	state Exp;
branches;
next	1.38;

1.38
date	2011.10.11.15.56.28;	author nickc;	state Exp;
branches;
next	1.37;

1.37
date	2010.11.17.03.35.50;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2009.12.11.13.42.06;	author nickc;	state Exp;
branches
	1.36.2.1;
next	1.35;

1.35
date	2008.07.30.04.34.56;	author amodra;	state Exp;
branches;
next	1.34;

1.34
date	2007.10.08.13.50.18;	author carlos;	state Exp;
branches;
next	1.33;

1.33
date	2007.09.17.09.58.27;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2007.07.05.16.54.45;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	2007.07.05.09.51.30;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	2007.06.06.08.02.47;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	2007.05.23.08.48.29;	author nickc;	state Exp;
branches;
next	1.28;

1.28
date	2007.04.26.14.46.59;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2005.05.08.14.17.39;	author nickc;	state Exp;
branches;
next	1.26;

1.26
date	2005.01.17.16.24.12;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2003.10.27.13.20.32;	author kazu;	state Exp;
branches;
next	1.24;

1.24
date	2003.10.02.14.13.10;	author cgf;	state Exp;
branches;
next	1.23;

1.23
date	2003.09.14.12.20.16;	author aj;	state Exp;
branches;
next	1.22;

1.22
date	2003.06.28.02.37.43;	author dannysmith;	state Exp;
branches;
next	1.21;

1.21
date	2003.03.31.10.15.58;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.23.04.11.57;	author kazu;	state Exp;
branches;
next	1.19;

1.19
date	2002.05.05.23.19.32;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2002.04.15.14.12.38;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2002.04.09.17.06.12;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2002.04.09.15.59.12;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2002.04.09.15.21.00;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2001.09.19.05.33.16;	author hjl;	state Exp;
branches
	1.14.2.1;
next	1.13;

1.13
date	2001.07.17.01.19.19;	author dj;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.13.06.43.58;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2000.08.30.23.06.03;	author dj;	state Exp;
branches
	1.11.2.1;
next	1.10;

1.10
date	2000.08.02.00.20.30;	author dj;	state Exp;
branches;
next	1.9;

1.9
date	2000.06.13.21.21.43;	author dj;	state Exp;
branches;
next	1.8;

1.8
date	2000.05.26.18.46.47;	author dj;	state Exp;
branches;
next	1.7;

1.7
date	2000.02.19.03.59.10;	author fche;	state Exp;
branches;
next	1.6;

1.6
date	2000.01.07.22.33.48;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	99.09.19.23.59.35;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	99.06.22.22.50.22;	author ian;	state Exp;
branches;
next	1.3;

1.3
date	99.06.22.20.39.46;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.05.25.12.10.26;	author dj;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.29.10;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.36.2.1
date	2011.02.01.12.25.36;	author amodra;	state Exp;
branches;
next	;

1.14.2.1
date	2002.05.09.11.53.25;	author amodra;	state Exp;
branches;
next	;

1.11.2.1
date	2001.06.07.03.12.28;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.10;	author rth;	state Exp;
branches;
next	;


desc
@@


1.42
log
@Remove trailing redundant `;'

bfd/

	* aout-tic30.c (MY_final_link_callback): Remove trailing
	redundant `;'.
	* coff-h8500.c (extra_case): Likewise.
	(bfd_coff_reloc16_get_value): Likewise.
	* dwarf2.c (_bfd_dwarf2_cleanup_debug_info): Likewise.
	* elf.c (_bfd_elf_slurp_version_tables): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_perform_relocation): Likewise.
	* opncls.c (bfd_calc_gnu_debuglink_crc32): Likewise.
	* plugin.c (add_symbols): Likewise.
	* reloc.c (bfd_check_overflow): Likewise.
	* vms-lib.c (_bfd_vms_lib_archive_p): Likewise.

binutils/

	* coffgrok.c (coff_grok): Remove trailing redundant `;'.
	* resrc.c (open_input_stream): Likewise.

gas/

	* config/atof-ieee.c (gen_to_words): Remove trailing redundant
	`;'.
	* config/atof-vax.c (flonum_gen2vax): Likewise.
	* config/tc-d10v.c (write_2_short): Likewise.
	* config/tc-i386-intel.c (i386_intel_simplify): Likewise.
	* config/tc-s390.c (tc_s390_force_relocation): Likewise.
	* config/tc-v850.c (md_parse_option): Likewise.
	* config/tc-xtensa.c (find_address_of_next_align_frag): Likewise.
	* dwarf2dbg.c (out_header): Likewise.
	* symbols.c (dollar_label_name): Likewise.
	(fb_label_name): Likewise.

ld/

	* testplug.c (record_add_file): Remove trailing redundant `;'.

opcodes/

	* aarch64-opc.h (gen_mask): Remove trailing redundant `;'.
	* ia64-gen.c (fetch_insn_class): Likewise.
@
text
@/* resrc.c -- read and write Windows rc files.
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2007, 2008, 2011
   Free Software Foundation, Inc.
   Written by Ian Lance Taylor, Cygnus Support.
   Rewritten by Kai Tietz, Onevision.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* This file contains functions that read and write Windows rc files.
   These are text files that represent resources.  */

#include "sysdep.h"
#include "bfd.h"
#include "bucomm.h"
#include "libiberty.h"
#include "safe-ctype.h"
#include "windres.h"

#include <assert.h>

#ifdef HAVE_SYS_WAIT_H
#include <sys/wait.h>
#else /* ! HAVE_SYS_WAIT_H */
#if ! defined (_WIN32) || defined (__CYGWIN__)
#ifndef WIFEXITED
#define WIFEXITED(w)	(((w)&0377) == 0)
#endif
#ifndef WIFSIGNALED
#define WIFSIGNALED(w)	(((w)&0377) != 0177 && ((w)&~0377) == 0)
#endif
#ifndef WTERMSIG
#define WTERMSIG(w)	((w) & 0177)
#endif
#ifndef WEXITSTATUS
#define WEXITSTATUS(w)	(((w) >> 8) & 0377)
#endif
#else /* defined (_WIN32) && ! defined (__CYGWIN__) */
#ifndef WIFEXITED
#define WIFEXITED(w)	(((w) & 0xff) == 0)
#endif
#ifndef WIFSIGNALED
#define WIFSIGNALED(w)	(((w) & 0xff) != 0 && ((w) & 0xff) != 0x7f)
#endif
#ifndef WTERMSIG
#define WTERMSIG(w)	((w) & 0x7f)
#endif
#ifndef WEXITSTATUS
#define WEXITSTATUS(w)	(((w) & 0xff00) >> 8)
#endif
#endif /* defined (_WIN32) && ! defined (__CYGWIN__) */
#endif /* ! HAVE_SYS_WAIT_H */

#ifndef STDOUT_FILENO
#define STDOUT_FILENO 1
#endif

#if defined (_WIN32) && ! defined (__CYGWIN__)
#define popen _popen
#define pclose _pclose
#endif

/* The default preprocessor.  */

#define DEFAULT_PREPROCESSOR "gcc -E -xc -DRC_INVOKED"

/* We read the directory entries in a cursor or icon file into
   instances of this structure.  */

struct icondir
{
  /* Width of image.  */
  bfd_byte width;
  /* Height of image.  */
  bfd_byte height;
  /* Number of colors in image.  */
  bfd_byte colorcount;
  union
  {
    struct
    {
      /* Color planes.  */
      unsigned short planes;
      /* Bits per pixel.  */
      unsigned short bits;
    } icon;
    struct
    {
      /* X coordinate of hotspot.  */
      unsigned short xhotspot;
      /* Y coordinate of hotspot.  */
      unsigned short yhotspot;
    } cursor;
  } u;
  /* Bytes in image.  */
  unsigned long bytes;
  /* File offset of image.  */
  unsigned long offset;
};

/* The name of the rc file we are reading.  */

char *rc_filename;

/* The line number in the rc file.  */

int rc_lineno;

/* The pipe we are reading from, so that we can close it if we exit.  */

FILE *cpp_pipe;

/* The temporary file used if we're not using popen, so we can delete it
   if we exit.  */

static char *cpp_temp_file;

/* Input stream is either a file or a pipe.  */

static enum {ISTREAM_PIPE, ISTREAM_FILE} istream_type;

/* As we read the rc file, we attach information to this structure.  */

static rc_res_directory *resources;

/* The number of cursor resources we have written out.  */

static int cursors;

/* The number of font resources we have written out.  */

static int fonts;

/* Font directory information.  */

rc_fontdir *fontdirs;

/* Resource info to use for fontdirs.  */

rc_res_res_info fontdirs_resinfo;

/* The number of icon resources we have written out.  */

static int icons;

/* The windres target bfd .  */

static windres_bfd wrtarget =
{
  (bfd *) NULL, (asection *) NULL, WR_KIND_TARGET
};

/* Local functions for rcdata based resource definitions.  */

static void define_font_rcdata (rc_res_id, const rc_res_res_info *,
				rc_rcdata_item *);
static void define_icon_rcdata (rc_res_id, const rc_res_res_info *,
				rc_rcdata_item *);
static void define_bitmap_rcdata (rc_res_id, const rc_res_res_info *,
				  rc_rcdata_item *);
static void define_cursor_rcdata (rc_res_id, const rc_res_res_info *,
				  rc_rcdata_item *);
static void define_fontdir_rcdata (rc_res_id, const rc_res_res_info *,
				   rc_rcdata_item *);
static void define_messagetable_rcdata (rc_res_id, const rc_res_res_info *,
					rc_rcdata_item *);
static rc_uint_type rcdata_copy (const rc_rcdata_item *, bfd_byte *);
static bfd_byte *rcdata_render_as_buffer (const rc_rcdata_item *, rc_uint_type *);

static int run_cmd (char *, const char *);
static FILE *open_input_stream (char *);
static FILE *look_for_default
  (char *, const char *, int, const char *, const char *);
static void close_input_stream (void);
static void unexpected_eof (const char *);
static int get_word (FILE *, const char *);
static unsigned long get_long (FILE *, const char *);
static void get_data (FILE *, bfd_byte *, rc_uint_type, const char *);
static void define_fontdirs (void);

/* Run `cmd' and redirect the output to `redir'.  */

static int
run_cmd (char *cmd, const char *redir)
{
  char *s;
  int pid, wait_status, retcode;
  int i;
  const char **argv;
  char *errmsg_fmt, *errmsg_arg;
  char *temp_base = choose_temp_base ();
  int in_quote;
  char sep;
  int redir_handle = -1;
  int stdout_save = -1;

  /* Count the args.  */
  i = 0;

  for (s = cmd; *s; s++)
    if (*s == ' ')
      i++;

  i++;
  argv = alloca (sizeof (char *) * (i + 3));
  i = 0;
  s = cmd;

  while (1)
    {
      while (*s == ' ' && *s != 0)
	s++;

      if (*s == 0)
	break;

      in_quote = (*s == '\'' || *s == '"');
      sep = (in_quote) ? *s++ : ' ';
      argv[i++] = s;

      while (*s != sep && *s != 0)
	s++;

      if (*s == 0)
	break;

      *s++ = 0;

      if (in_quote)
	s++;
    }
  argv[i++] = NULL;

  /* Setup the redirection.  We can't use the usual fork/exec and redirect
     since we may be running on non-POSIX Windows host.  */

  fflush (stdout);
  fflush (stderr);

  /* Open temporary output file.  */
  redir_handle = open (redir, O_WRONLY | O_TRUNC | O_CREAT, 0666);
  if (redir_handle == -1)
    fatal (_("can't open temporary file `%s': %s"), redir,
	   strerror (errno));

  /* Duplicate the stdout file handle so it can be restored later.  */
  stdout_save = dup (STDOUT_FILENO);
  if (stdout_save == -1)
    fatal (_("can't redirect stdout: `%s': %s"), redir, strerror (errno));

  /* Redirect stdout to our output file.  */
  dup2 (redir_handle, STDOUT_FILENO);

  pid = pexecute (argv[0], (char * const *) argv, program_name, temp_base,
		  &errmsg_fmt, &errmsg_arg, PEXECUTE_ONE | PEXECUTE_SEARCH);

  /* Restore stdout to its previous setting.  */
  dup2 (stdout_save, STDOUT_FILENO);

  /* Close response file.  */
  close (redir_handle);

  if (pid == -1)
    {
      fatal ("%s %s: %s", errmsg_fmt, errmsg_arg, strerror (errno));
      return 1;
    }

  retcode = 0;
  pid = pwait (pid, &wait_status, 0);

  if (pid == -1)
    {
      fatal (_("wait: %s"), strerror (errno));
      retcode = 1;
    }
  else if (WIFSIGNALED (wait_status))
    {
      fatal (_("subprocess got fatal signal %d"), WTERMSIG (wait_status));
      retcode = 1;
    }
  else if (WIFEXITED (wait_status))
    {
      if (WEXITSTATUS (wait_status) != 0)
	{
	  fatal (_("%s exited with status %d"), cmd,
	         WEXITSTATUS (wait_status));
	  retcode = 1;
	}
    }
  else
    retcode = 1;

  return retcode;
}

static FILE *
open_input_stream (char *cmd)
{
  if (istream_type == ISTREAM_FILE)
    {
      char *fileprefix;

      fileprefix = choose_temp_base ();
      cpp_temp_file = (char *) xmalloc (strlen (fileprefix) + 5);
      sprintf (cpp_temp_file, "%s.irc", fileprefix);
      free (fileprefix);

      if (run_cmd (cmd, cpp_temp_file))
	fatal (_("can't execute `%s': %s"), cmd, strerror (errno));

      cpp_pipe = fopen (cpp_temp_file, FOPEN_RT);
      if (cpp_pipe == NULL)
	fatal (_("can't open temporary file `%s': %s"),
	       cpp_temp_file, strerror (errno));

      if (verbose)
	fprintf (stderr,
	         _("Using temporary file `%s' to read preprocessor output\n"),
		 cpp_temp_file);
    }
  else
    {
      cpp_pipe = popen (cmd, FOPEN_RT);
      if (cpp_pipe == NULL)
	fatal (_("can't popen `%s': %s"), cmd, strerror (errno));
      if (verbose)
	fprintf (stderr, _("Using popen to read preprocessor output\n"));
    }

  xatexit (close_input_stream);
  return cpp_pipe;
}

/* Determine if FILENAME contains special characters that
   can cause problems unless the entire filename is quoted.  */

static int
filename_need_quotes (const char *filename)
{
  if (filename == NULL || (filename[0] == '-' && filename[1] == 0))
    return 0;

  while (*filename != 0)
    {
      switch (*filename)
        {
        case '&':
        case ' ':
        case '<':
        case '>':
        case '|':
        case '%':
          return 1;
        }
      ++filename;
    }
  return 0;
}

/* Look for the preprocessor program.  */

static FILE *
look_for_default (char *cmd, const char *prefix, int end_prefix,
		  const char *preprocargs, const char *filename)
{
  char *space;
  int found;
  struct stat s;
  const char *fnquotes = (filename_need_quotes (filename) ? "\"" : "");

  strcpy (cmd, prefix);

  sprintf (cmd + end_prefix, "%s", DEFAULT_PREPROCESSOR);
  space = strchr (cmd + end_prefix, ' ');
  if (space)
    *space = 0;

  if (
#if defined (__DJGPP__) || defined (__CYGWIN__) || defined (_WIN32)
      strchr (cmd, '\\') ||
#endif
      strchr (cmd, '/'))
    {
      found = (stat (cmd, &s) == 0
#ifdef HAVE_EXECUTABLE_SUFFIX
	       || stat (strcat (cmd, EXECUTABLE_SUFFIX), &s) == 0
#endif
	       );

      if (! found)
	{
	  if (verbose)
	    fprintf (stderr, _("Tried `%s'\n"), cmd);
	  return NULL;
	}
    }

  strcpy (cmd, prefix);

  sprintf (cmd + end_prefix, "%s %s %s%s%s",
	   DEFAULT_PREPROCESSOR, preprocargs, fnquotes, filename, fnquotes);

  if (verbose)
    fprintf (stderr, _("Using `%s'\n"), cmd);

  cpp_pipe = open_input_stream (cmd);
  return cpp_pipe;
}

/* Read an rc file.  */

rc_res_directory *
read_rc_file (const char *filename, const char *preprocessor,
	      const char *preprocargs, int language, int use_temp_file)
{
  char *cmd;
  const char *fnquotes = (filename_need_quotes (filename) ? "\"" : "");

  if (filename == NULL)
    filename = "-";
  /* Setup the default resource import path taken from input file.  */
  else if (strchr (filename, '/') != NULL || strchr (filename, '\\') != NULL)
    {
      char *edit, *dir;

      if (filename[0] == '/'
	  || filename[0] == '\\'
	  || filename[1] == ':')
        /* Absolute path.  */
	edit = dir = xstrdup (filename);
      else
	{
	  /* Relative path.  */
	  edit = dir = xmalloc (strlen (filename) + 3);
	  sprintf (dir, "./%s", filename);
	}

      /* Walk dir backwards stopping at the first directory separator.  */
      edit += strlen (dir);
      while (edit > dir && (edit[-1] != '\\' && edit[-1] != '/'))
	{
	  --edit;
	  edit[0] = 0;
	}

      /* Cut off trailing slash.  */
      --edit;
      edit[0] = 0;

      /* Convert all back slashes to forward slashes.  */
      while ((edit = strchr (dir, '\\')) != NULL)
	*edit = '/';

      windres_add_include_dir (dir);
    }

  istream_type = (use_temp_file) ? ISTREAM_FILE : ISTREAM_PIPE;

  if (preprocargs == NULL)
    preprocargs = "";

  if (preprocessor)
    {
      cmd = xmalloc (strlen (preprocessor)
		     + strlen (preprocargs)
		     + strlen (filename)
		     + strlen (fnquotes) * 2
		     + 10);
      sprintf (cmd, "%s %s %s%s%s", preprocessor, preprocargs,
	       fnquotes, filename, fnquotes);

      cpp_pipe = open_input_stream (cmd);
    }
  else
    {
      char *dash, *slash, *cp;

      preprocessor = DEFAULT_PREPROCESSOR;

      cmd = xmalloc (strlen (program_name)
		     + strlen (preprocessor)
		     + strlen (preprocargs)
		     + strlen (filename)
		     + strlen (fnquotes) * 2
#ifdef HAVE_EXECUTABLE_SUFFIX
		     + strlen (EXECUTABLE_SUFFIX)
#endif
		     + 10);


      dash = slash = 0;
      for (cp = program_name; *cp; cp++)
	{
	  if (*cp == '-')
	    dash = cp;
	  if (
#if defined (__DJGPP__) || defined (__CYGWIN__) || defined(_WIN32)
	      *cp == ':' || *cp == '\\' ||
#endif
	      *cp == '/')
	    {
	      slash = cp;
	      dash = 0;
	    }
	}

      cpp_pipe = 0;

      if (dash)
	{
	  /* First, try looking for a prefixed gcc in the windres
	     directory, with the same prefix as windres */

	  cpp_pipe = look_for_default (cmd, program_name, dash - program_name + 1,
				       preprocargs, filename);
	}

      if (slash && ! cpp_pipe)
	{
	  /* Next, try looking for a gcc in the same directory as
             that windres */

	  cpp_pipe = look_for_default (cmd, program_name, slash - program_name + 1,
				       preprocargs, filename);
	}

      if (! cpp_pipe)
	{
	  /* Sigh, try the default */

	  cpp_pipe = look_for_default (cmd, "", 0, preprocargs, filename);
	}

    }

  free (cmd);

  rc_filename = xstrdup (filename);
  rc_lineno = 1;
  if (language != -1)
    rcparse_set_language (language);
  yyparse ();
  rcparse_discard_strings ();

  close_input_stream ();

  if (fontdirs != NULL)
    define_fontdirs ();

  free (rc_filename);
  rc_filename = NULL;

  return resources;
}

/* Close the input stream if it is open.  */

static void
close_input_stream (void)
{
  if (istream_type == ISTREAM_FILE)
    {
      if (cpp_pipe != NULL)
	fclose (cpp_pipe);

      if (cpp_temp_file != NULL)
	{
	  int errno_save = errno;

	  unlink (cpp_temp_file);
	  errno = errno_save;
	  free (cpp_temp_file);
	}
    }
  else
    {
      if (cpp_pipe != NULL)
        {
	  int err;
	  err = pclose (cpp_pipe);
	  /* We are reading from a pipe, therefore we don't
             know if cpp failed or succeeded until pclose.  */
	  if (err != 0 || errno == ECHILD)
	    {
	      /* Since this is also run via xatexit, safeguard.  */
	      cpp_pipe = NULL;
	      cpp_temp_file = NULL;
	      fatal (_("preprocessing failed."));
	    }
        }
    }

  /* Since this is also run via xatexit, safeguard.  */
  cpp_pipe = NULL;
  cpp_temp_file = NULL;
}

/* Report an error while reading an rc file.  */

void
yyerror (const char *msg)
{
  fatal ("%s:%d: %s", rc_filename, rc_lineno, msg);
}

/* Issue a warning while reading an rc file.  */

void
rcparse_warning (const char *msg)
{
  fprintf (stderr, "%s:%d: %s\n", rc_filename, rc_lineno, msg);
}

/* Die if we get an unexpected end of file.  */

static void
unexpected_eof (const char *msg)
{
  fatal (_("%s: unexpected EOF"), msg);
}

/* Read a 16 bit word from a file.  The data is assumed to be little
   endian.  */

static int
get_word (FILE *e, const char *msg)
{
  int b1, b2;

  b1 = getc (e);
  b2 = getc (e);
  if (feof (e))
    unexpected_eof (msg);
  return ((b2 & 0xff) << 8) | (b1 & 0xff);
}

/* Read a 32 bit word from a file.  The data is assumed to be little
   endian.  */

static unsigned long
get_long (FILE *e, const char *msg)
{
  int b1, b2, b3, b4;

  b1 = getc (e);
  b2 = getc (e);
  b3 = getc (e);
  b4 = getc (e);
  if (feof (e))
    unexpected_eof (msg);
  return (((((((b4 & 0xff) << 8)
	      | (b3 & 0xff)) << 8)
	    | (b2 & 0xff)) << 8)
	  | (b1 & 0xff));
}

/* Read data from a file.  This is a wrapper to do error checking.  */

static void
get_data (FILE *e, bfd_byte *p, rc_uint_type c, const char *msg)
{
  rc_uint_type got; // $$$d

  got = (rc_uint_type) fread (p, 1, c, e);
  if (got == c)
    return;

  fatal (_("%s: read of %lu returned %lu"),
	 msg, (unsigned long) c, (unsigned long) got);
}

/* Define an accelerator resource.  */

void
define_accelerator (rc_res_id id, const rc_res_res_info *resinfo,
		    rc_accelerator *data)
{
  rc_res_resource *r;

  r = define_standard_resource (&resources, RT_ACCELERATOR, id,
				resinfo->language, 0);
  r->type = RES_TYPE_ACCELERATOR;
  r->u.acc = data;
  r->res_info = *resinfo;
}

/* Define a bitmap resource.  Bitmap data is stored in a file.  The
   first 14 bytes of the file are a standard header, which is not
   included in the resource data.  */

#define BITMAP_SKIP (14)

void
define_bitmap (rc_res_id id, const rc_res_res_info *resinfo,
	       const char *filename)
{
  FILE *e;
  char *real_filename;
  struct stat s;
  bfd_byte *data;
  rc_uint_type i;
  rc_res_resource *r;

  e = open_file_search (filename, FOPEN_RB, "bitmap file", &real_filename);

  if (stat (real_filename, &s) < 0)
    fatal (_("stat failed on bitmap file `%s': %s"), real_filename,
	   strerror (errno));

  data = (bfd_byte *) res_alloc (s.st_size - BITMAP_SKIP);

  for (i = 0; i < BITMAP_SKIP; i++)
    getc (e);

  get_data (e, data, s.st_size - BITMAP_SKIP, real_filename);

  fclose (e);
  free (real_filename);

  r = define_standard_resource (&resources, RT_BITMAP, id,
				resinfo->language, 0);

  r->type = RES_TYPE_BITMAP;
  r->u.data.length = s.st_size - BITMAP_SKIP;
  r->u.data.data = data;
  r->res_info = *resinfo;
}

/* Define a cursor resource.  A cursor file may contain a set of
   bitmaps, each representing the same cursor at various different
   resolutions.  They each get written out with a different ID.  The
   real cursor resource is then a group resource which can be used to
   select one of the actual cursors.  */

void
define_cursor (rc_res_id id, const rc_res_res_info *resinfo,
	       const char *filename)
{
  FILE *e;
  char *real_filename;
  int type, count, i;
  struct icondir *icondirs;
  int first_cursor;
  rc_res_resource *r;
  rc_group_cursor *first, **pp;

  e = open_file_search (filename, FOPEN_RB, "cursor file", &real_filename);

  /* A cursor file is basically an icon file.  The start of the file
     is a three word structure.  The first word is ignored.  The
     second word is the type of data.  The third word is the number of
     entries.  */

  get_word (e, real_filename);
  type = get_word (e, real_filename);
  count = get_word (e, real_filename);
  if (type != 2)
    fatal (_("cursor file `%s' does not contain cursor data"), real_filename);

  /* Read in the icon directory entries.  */

  icondirs = (struct icondir *) xmalloc (count * sizeof *icondirs);

  for (i = 0; i < count; i++)
    {
      icondirs[i].width = getc (e);
      icondirs[i].height = getc (e);
      icondirs[i].colorcount = getc (e);
      getc (e);
      icondirs[i].u.cursor.xhotspot = get_word (e, real_filename);
      icondirs[i].u.cursor.yhotspot = get_word (e, real_filename);
      icondirs[i].bytes = get_long (e, real_filename);
      icondirs[i].offset = get_long (e, real_filename);

      if (feof (e))
	unexpected_eof (real_filename);
    }

  /* Define each cursor as a unique resource.  */

  first_cursor = cursors;

  for (i = 0; i < count; i++)
    {
      bfd_byte *data;
      rc_res_id name;
      rc_cursor *c;

      if (fseek (e, icondirs[i].offset, SEEK_SET) != 0)
	fatal (_("%s: fseek to %lu failed: %s"), real_filename,
	       icondirs[i].offset, strerror (errno));

      data = (bfd_byte *) res_alloc (icondirs[i].bytes);

      get_data (e, data, icondirs[i].bytes, real_filename);

      c = (rc_cursor *) res_alloc (sizeof (rc_cursor));
      c->xhotspot = icondirs[i].u.cursor.xhotspot;
      c->yhotspot = icondirs[i].u.cursor.yhotspot;
      c->length = icondirs[i].bytes;
      c->data = data;

      ++cursors;

      name.named = 0;
      name.u.id = cursors;

      r = define_standard_resource (&resources, RT_CURSOR, name,
				    resinfo->language, 0);
      r->type = RES_TYPE_CURSOR;
      r->u.cursor = c;
      r->res_info = *resinfo;
    }

  fclose (e);
  free (real_filename);

  /* Define a cursor group resource.  */

  first = NULL;
  pp = &first;
  for (i = 0; i < count; i++)
    {
      rc_group_cursor *cg;

      cg = (rc_group_cursor *) res_alloc (sizeof (rc_group_cursor));
      cg->next = NULL;
      cg->width = icondirs[i].width;
      cg->height = 2 * icondirs[i].height;

      /* FIXME: What should these be set to?  */
      cg->planes = 1;
      cg->bits = 1;

      cg->bytes = icondirs[i].bytes + 4;
      cg->index = first_cursor + i + 1;

      *pp = cg;
      pp = &(*pp)->next;
    }

  free (icondirs);

  r = define_standard_resource (&resources, RT_GROUP_CURSOR, id,
				resinfo->language, 0);
  r->type = RES_TYPE_GROUP_CURSOR;
  r->u.group_cursor = first;
  r->res_info = *resinfo;
}

/* Define a dialog resource.  */

void
define_dialog (rc_res_id id, const rc_res_res_info *resinfo,
	       const rc_dialog *dialog)
{
  rc_dialog *copy;
  rc_res_resource *r;

  copy = (rc_dialog *) res_alloc (sizeof *copy);
  *copy = *dialog;

  r = define_standard_resource (&resources, RT_DIALOG, id,
				resinfo->language, 0);
  r->type = RES_TYPE_DIALOG;
  r->u.dialog = copy;
  r->res_info = *resinfo;
}

/* Define a dialog control.  This does not define a resource, but
   merely allocates and fills in a structure.  */

rc_dialog_control *
define_control (const rc_res_id iid, rc_uint_type id, rc_uint_type x,
		rc_uint_type y, rc_uint_type width, rc_uint_type height,
		const rc_res_id class, rc_uint_type style,
		rc_uint_type exstyle)
{
  rc_dialog_control *n;

  n = (rc_dialog_control *) res_alloc (sizeof (rc_dialog_control));
  n->next = NULL;
  n->id = id;
  n->style = style;
  n->exstyle = exstyle;
  n->x = x;
  n->y = y;
  n->width = width;
  n->height = height;
  n->class = class;
  n->text = iid;
  n->data = NULL;
  n->help = 0;

  return n;
}

rc_dialog_control *
define_icon_control (rc_res_id iid, rc_uint_type id, rc_uint_type x,
		     rc_uint_type y, rc_uint_type style,
		     rc_uint_type exstyle, rc_uint_type help,
		     rc_rcdata_item *data, rc_dialog_ex *ex)
{
  rc_dialog_control *n;
  rc_res_id tid;
  rc_res_id cid;

  if (style == 0)
    style = SS_ICON | WS_CHILD | WS_VISIBLE;
  res_string_to_id (&tid, "");
  cid.named = 0;
  cid.u.id = CTL_STATIC;
  n = define_control (tid, id, x, y, 0, 0, cid, style, exstyle);
  n->text = iid;
  if (help && ! ex)
    rcparse_warning (_("help ID requires DIALOGEX"));
  if (data && ! ex)
    rcparse_warning (_("control data requires DIALOGEX"));
  n->help = help;
  n->data = data;

  return n;
}

/* Define a font resource.  */

void
define_font (rc_res_id id, const rc_res_res_info *resinfo,
	     const char *filename)
{
  FILE *e;
  char *real_filename;
  struct stat s;
  bfd_byte *data;
  rc_res_resource *r;
  long offset;
  long fontdatalength;
  bfd_byte *fontdata;
  rc_fontdir *fd;
  const char *device, *face;
  rc_fontdir **pp;

  e = open_file_search (filename, FOPEN_RB, "font file", &real_filename);

  if (stat (real_filename, &s) < 0)
    fatal (_("stat failed on font file `%s': %s"), real_filename,
	   strerror (errno));

  data = (bfd_byte *) res_alloc (s.st_size);

  get_data (e, data, s.st_size, real_filename);

  fclose (e);
  free (real_filename);

  r = define_standard_resource (&resources, RT_FONT, id,
				resinfo->language, 0);

  r->type = RES_TYPE_FONT;
  r->u.data.length = s.st_size;
  r->u.data.data = data;
  r->res_info = *resinfo;

  /* For each font resource, we must add an entry in the FONTDIR
     resource.  The FONTDIR resource includes some strings in the font
     file.  To find them, we have to do some magic on the data we have
     read.  */

  offset = ((((((data[47] << 8)
		| data[46]) << 8)
	      | data[45]) << 8)
	    | data[44]);
  if (offset > 0 && offset < s.st_size)
    device = (char *) data + offset;
  else
    device = "";

  offset = ((((((data[51] << 8)
		| data[50]) << 8)
	      | data[49]) << 8)
	    | data[48]);
  if (offset > 0 && offset < s.st_size)
    face = (char *) data + offset;
  else
    face = "";

  ++fonts;

  fontdatalength = 58 + strlen (device) + strlen (face);
  fontdata = (bfd_byte *) res_alloc (fontdatalength);
  memcpy (fontdata, data, 56);
  strcpy ((char *) fontdata + 56, device);
  strcpy ((char *) fontdata + 57 + strlen (device), face);

  fd = (rc_fontdir *) res_alloc (sizeof (rc_fontdir));
  fd->next = NULL;
  fd->index = fonts;
  fd->length = fontdatalength;
  fd->data = fontdata;

  for (pp = &fontdirs; *pp != NULL; pp = &(*pp)->next)
    ;
  *pp = fd;

  /* For the single fontdirs resource, we always use the resource
     information of the last font.  I don't know what else to do.  */
  fontdirs_resinfo = *resinfo;
}

static void
define_font_rcdata (rc_res_id id,const rc_res_res_info *resinfo,
		    rc_rcdata_item *data)
{
  rc_res_resource *r;
  rc_uint_type len_data;
  bfd_byte *pb_data;

  r = define_standard_resource (&resources, RT_FONT, id,
				resinfo->language, 0);

  pb_data = rcdata_render_as_buffer (data, &len_data);

  r->type = RES_TYPE_FONT;
  r->u.data.length = len_data;
  r->u.data.data = pb_data;
  r->res_info = *resinfo;
}

/* Define the fontdirs resource.  This is called after the entire rc
   file has been parsed, if any font resources were seen.  */

static void
define_fontdirs (void)
{
  rc_res_resource *r;
  rc_res_id id;

  id.named = 0;
  id.u.id = 1;

  r = define_standard_resource (&resources, RT_FONTDIR, id, 0x409, 0);

  r->type = RES_TYPE_FONTDIR;
  r->u.fontdir = fontdirs;
  r->res_info = fontdirs_resinfo;
}

static bfd_byte *
rcdata_render_as_buffer (const rc_rcdata_item *data, rc_uint_type *plen)
{
  const rc_rcdata_item *d;
  bfd_byte *ret = NULL, *pret;
  rc_uint_type len = 0;

  for (d = data; d != NULL; d = d->next)
    len += rcdata_copy (d, NULL);
  if (len != 0)
    {
      ret = pret = (bfd_byte *) res_alloc (len);
      for (d = data; d != NULL; d = d->next)
	pret += rcdata_copy (d, pret);
    }
  if (plen)
    *plen = len;
  return ret;
}

static void
define_fontdir_rcdata (rc_res_id id,const rc_res_res_info *resinfo,
		       rc_rcdata_item *data)
{
  rc_res_resource *r;
  rc_fontdir *fd, *fd_first, *fd_cur;
  rc_uint_type len_data;
  bfd_byte *pb_data;
  rc_uint_type c;

  fd_cur = fd_first = NULL;
  r = define_standard_resource (&resources, RT_FONTDIR, id, 0x409, 0);

  pb_data = rcdata_render_as_buffer (data, &len_data);

  if (pb_data)
    {
      rc_uint_type off = 2;
      c = windres_get_16 (&wrtarget, pb_data, len_data);
      for (; c > 0; c--)
	{
	  size_t len;
	  rc_uint_type safe_pos = off;
	  const struct bin_fontdir_item *bfi;

	  bfi = (const struct bin_fontdir_item *) pb_data + off;
	  fd = (rc_fontdir *) res_alloc (sizeof (rc_fontdir));
	  fd->index = windres_get_16 (&wrtarget, bfi->index, len_data - off);
	  fd->data = pb_data + off;
	  off += 56;
	  len = strlen ((char *) bfi->device_name) + 1;
	  off += (rc_uint_type) len;
	  off += (rc_uint_type) strlen ((char *) bfi->device_name + len) + 1;
	  fd->length = (off - safe_pos);
	  fd->next = NULL;
	  if (fd_first == NULL)
	    fd_first = fd;
	  else
	    fd_cur->next = fd;
	  fd_cur = fd;
	}
    }
  r->type = RES_TYPE_FONTDIR;
  r->u.fontdir = fd_first;
  r->res_info = *resinfo;
}

static void define_messagetable_rcdata (rc_res_id id, const rc_res_res_info *resinfo,
					rc_rcdata_item *data)
{
  rc_res_resource *r;
  rc_uint_type len_data;
  bfd_byte *pb_data;

  r = define_standard_resource (&resources, RT_MESSAGETABLE, id, resinfo->language, 0);

  pb_data = rcdata_render_as_buffer (data, &len_data);
  r->type = RES_TYPE_MESSAGETABLE;
  r->u.data.length = len_data;
  r->u.data.data = pb_data;
  r->res_info = *resinfo;
}

/* Define an icon resource.  An icon file may contain a set of
   bitmaps, each representing the same icon at various different
   resolutions.  They each get written out with a different ID.  The
   real icon resource is then a group resource which can be used to
   select one of the actual icon bitmaps.  */

void
define_icon (rc_res_id id, const rc_res_res_info *resinfo,
	     const char *filename)
{
  FILE *e;
  char *real_filename;
  int type, count, i;
  struct icondir *icondirs;
  int first_icon;
  rc_res_resource *r;
  rc_group_icon *first, **pp;

  e = open_file_search (filename, FOPEN_RB, "icon file", &real_filename);

  /* The start of an icon file is a three word structure.  The first
     word is ignored.  The second word is the type of data.  The third
     word is the number of entries.  */

  get_word (e, real_filename);
  type = get_word (e, real_filename);
  count = get_word (e, real_filename);
  if (type != 1)
    fatal (_("icon file `%s' does not contain icon data"), real_filename);

  /* Read in the icon directory entries.  */

  icondirs = (struct icondir *) xmalloc (count * sizeof *icondirs);

  for (i = 0; i < count; i++)
    {
      icondirs[i].width = getc (e);
      icondirs[i].height = getc (e);
      icondirs[i].colorcount = getc (e);
      getc (e);
      icondirs[i].u.icon.planes = get_word (e, real_filename);
      icondirs[i].u.icon.bits = get_word (e, real_filename);
      icondirs[i].bytes = get_long (e, real_filename);
      icondirs[i].offset = get_long (e, real_filename);

      if (feof (e))
	unexpected_eof (real_filename);
    }

  /* Define each icon as a unique resource.  */

  first_icon = icons;

  for (i = 0; i < count; i++)
    {
      bfd_byte *data;
      rc_res_id name;

      if (fseek (e, icondirs[i].offset, SEEK_SET) != 0)
	fatal (_("%s: fseek to %lu failed: %s"), real_filename,
	       icondirs[i].offset, strerror (errno));

      data = (bfd_byte *) res_alloc (icondirs[i].bytes);

      get_data (e, data, icondirs[i].bytes, real_filename);

      ++icons;

      name.named = 0;
      name.u.id = icons;

      r = define_standard_resource (&resources, RT_ICON, name,
				    resinfo->language, 0);
      r->type = RES_TYPE_ICON;
      r->u.data.length = icondirs[i].bytes;
      r->u.data.data = data;
      r->res_info = *resinfo;
    }

  fclose (e);
  free (real_filename);

  /* Define an icon group resource.  */

  first = NULL;
  pp = &first;
  for (i = 0; i < count; i++)
    {
      rc_group_icon *cg;

      /* For some reason, at least in some files the planes and bits
         are zero.  We instead set them from the color.  This is
         copied from rcl.  */

      cg = (rc_group_icon *) res_alloc (sizeof (rc_group_icon));
      cg->next = NULL;
      cg->width = icondirs[i].width;
      cg->height = icondirs[i].height;
      cg->colors = icondirs[i].colorcount;

      if (icondirs[i].u.icon.planes)
	cg->planes = icondirs[i].u.icon.planes;
      else
	cg->planes = 1;

      if (icondirs[i].u.icon.bits)
	cg->bits = icondirs[i].u.icon.bits;
      else
	{
	  cg->bits = 0;

	  while ((1L << cg->bits) < cg->colors)
	    ++cg->bits;
	}

      cg->bytes = icondirs[i].bytes;
      cg->index = first_icon + i + 1;

      *pp = cg;
      pp = &(*pp)->next;
    }

  free (icondirs);

  r = define_standard_resource (&resources, RT_GROUP_ICON, id,
				resinfo->language, 0);
  r->type = RES_TYPE_GROUP_ICON;
  r->u.group_icon = first;
  r->res_info = *resinfo;
}

static void
define_group_icon_rcdata (rc_res_id id, const rc_res_res_info *resinfo,
			  rc_rcdata_item *data)
{
  rc_res_resource *r;
  rc_group_icon *cg, *first, *cur;
  rc_uint_type len_data;
  bfd_byte *pb_data;

  pb_data = rcdata_render_as_buffer (data, &len_data);

  cur = NULL;
  first = NULL;

  while (len_data >= 6)
    {
      int c, i;
      unsigned short type;
      type = windres_get_16 (&wrtarget, pb_data + 2, len_data - 2);
      if (type != 1)
	fatal (_("unexpected group icon type %d"), type);
      c = windres_get_16 (&wrtarget, pb_data + 4, len_data - 4);
      len_data -= 6;
      pb_data += 6;

      for (i = 0; i < c; i++)
	{
	  if (len_data < 14)
	    fatal ("too small group icon rcdata");
	  cg = (rc_group_icon *) res_alloc (sizeof (rc_group_icon));
	  cg->next = NULL;
	  cg->width = pb_data[0];
	  cg->height = pb_data[1];
	  cg->colors = pb_data[2];
	  cg->planes = windres_get_16 (&wrtarget, pb_data + 4, len_data - 4);
	  cg->bits =  windres_get_16 (&wrtarget, pb_data + 6, len_data - 6);
	  cg->bytes = windres_get_32 (&wrtarget, pb_data + 8, len_data - 8);
	  cg->index = windres_get_16 (&wrtarget, pb_data + 12, len_data - 12);
	  if (! first)
	    first = cg;
	  else
	    cur->next = cg;
	  cur = cg;
	  pb_data += 14;
	  len_data -= 14;
	}
    }
  r = define_standard_resource (&resources, RT_GROUP_ICON, id,
				resinfo->language, 0);
  r->type = RES_TYPE_GROUP_ICON;
  r->u.group_icon = first;
  r->res_info = *resinfo;
}

static void
define_group_cursor_rcdata (rc_res_id id, const rc_res_res_info *resinfo,
			    rc_rcdata_item *data)
{
  rc_res_resource *r;
  rc_group_cursor *cg, *first, *cur;
  rc_uint_type len_data;
  bfd_byte *pb_data;

  pb_data = rcdata_render_as_buffer (data, &len_data);

  first = cur = NULL;

  while (len_data >= 6)
    {
      int c, i;
      unsigned short type;
      type = windres_get_16 (&wrtarget, pb_data + 2, len_data - 2);
      if (type != 2)
	fatal (_("unexpected group cursor type %d"), type);
      c = windres_get_16 (&wrtarget, pb_data + 4, len_data - 4);
      len_data -= 6;
      pb_data += 6;

      for (i = 0; i < c; i++)
	{
	  if (len_data < 14)
	    fatal ("too small group icon rcdata");
	  cg = (rc_group_cursor *) res_alloc (sizeof (rc_group_cursor));
	  cg->next = NULL;
	  cg->width = windres_get_16 (&wrtarget, pb_data, len_data);
	  cg->height = windres_get_16 (&wrtarget, pb_data + 2, len_data - 2);
	  cg->planes = windres_get_16 (&wrtarget, pb_data + 4, len_data - 4);
	  cg->bits =  windres_get_16 (&wrtarget, pb_data + 6, len_data - 6);
	  cg->bytes = windres_get_32 (&wrtarget, pb_data + 8, len_data - 8);
	  cg->index = windres_get_16 (&wrtarget, pb_data + 12, len_data - 12);
	  if (! first)
	    first = cg;
	  else
	    cur->next = cg;
	  cur = cg;
	  pb_data += 14;
	  len_data -= 14;
	}
    }

  r = define_standard_resource (&resources, RT_GROUP_ICON, id,
				resinfo->language, 0);
  r->type = RES_TYPE_GROUP_CURSOR;
  r->u.group_cursor = first;
  r->res_info = *resinfo;
}

static void
define_cursor_rcdata (rc_res_id id, const rc_res_res_info *resinfo,
		      rc_rcdata_item *data)
{
  rc_cursor *c;
  rc_res_resource *r;
  rc_uint_type len_data;
  bfd_byte *pb_data;

  pb_data = rcdata_render_as_buffer (data, &len_data);

  c = (rc_cursor *) res_alloc (sizeof (rc_cursor));
  c->xhotspot = windres_get_16 (&wrtarget, pb_data, len_data);
  c->yhotspot = windres_get_16 (&wrtarget, pb_data + 2, len_data - 2);
  c->length = len_data - BIN_CURSOR_SIZE;
  c->data = (const bfd_byte *) (data + BIN_CURSOR_SIZE);

  r = define_standard_resource (&resources, RT_CURSOR, id, resinfo->language, 0);
  r->type = RES_TYPE_CURSOR;
  r->u.cursor = c;
  r->res_info = *resinfo;
}

static void
define_bitmap_rcdata (rc_res_id id, const rc_res_res_info *resinfo,
		      rc_rcdata_item *data)
{
  rc_res_resource *r;
  rc_uint_type len_data;
  bfd_byte *pb_data;

  pb_data = rcdata_render_as_buffer (data, &len_data);

  r = define_standard_resource (&resources, RT_BITMAP, id, resinfo->language, 0);
  r->type = RES_TYPE_BITMAP;
  r->u.data.length = len_data;
  r->u.data.data = pb_data;
  r->res_info = *resinfo;
}

static void
define_icon_rcdata (rc_res_id id, const rc_res_res_info *resinfo,
		    rc_rcdata_item *data)
{
  rc_res_resource *r;
  rc_uint_type len_data;
  bfd_byte *pb_data;

  pb_data = rcdata_render_as_buffer (data, &len_data);

  r = define_standard_resource (&resources, RT_ICON, id, resinfo->language, 0);
  r->type = RES_TYPE_ICON;
  r->u.data.length = len_data;
  r->u.data.data = pb_data;
  r->res_info = *resinfo;
}

/* Define a menu resource.  */

void
define_menu (rc_res_id id, const rc_res_res_info *resinfo,
	     rc_menuitem *menuitems)
{
  rc_menu *m;
  rc_res_resource *r;

  m = (rc_menu *) res_alloc (sizeof (rc_menu));
  m->items = menuitems;
  m->help = 0;

  r = define_standard_resource (&resources, RT_MENU, id, resinfo->language, 0);
  r->type = RES_TYPE_MENU;
  r->u.menu = m;
  r->res_info = *resinfo;
}

/* Define a menu item.  This does not define a resource, but merely
   allocates and fills in a structure.  */

rc_menuitem *
define_menuitem (const unichar *text, rc_uint_type menuid, rc_uint_type type,
		 rc_uint_type state, rc_uint_type help,
		 rc_menuitem *menuitems)
{
  rc_menuitem *mi;

  mi = (rc_menuitem *) res_alloc (sizeof (rc_menuitem));
  mi->next = NULL;
  mi->type = type;
  mi->state = state;
  mi->id = menuid;
  mi->text = unichar_dup (text);
  mi->help = help;
  mi->popup = menuitems;
  return mi;
}

/* Define a messagetable resource.  */

void
define_messagetable (rc_res_id id, const rc_res_res_info *resinfo,
		     const char *filename)
{
  FILE *e;
  char *real_filename;
  struct stat s;
  bfd_byte *data;
  rc_res_resource *r;

  e = open_file_search (filename, FOPEN_RB, "messagetable file",
			&real_filename);

  if (stat (real_filename, &s) < 0)
    fatal (_("stat failed on bitmap file `%s': %s"), real_filename,
	   strerror (errno));

  data = (bfd_byte *) res_alloc (s.st_size);

  get_data (e, data, s.st_size, real_filename);

  fclose (e);
  free (real_filename);

  r = define_standard_resource (&resources, RT_MESSAGETABLE, id,
				resinfo->language, 0);

  r->type = RES_TYPE_MESSAGETABLE;
  r->u.data.length = s.st_size;
  r->u.data.data = data;
  r->res_info = *resinfo;
}

/* Define an rcdata resource.  */

void
define_rcdata (rc_res_id id, const rc_res_res_info *resinfo,
	       rc_rcdata_item *data)
{
  rc_res_resource *r;

  r = define_standard_resource (&resources, RT_RCDATA, id,
				resinfo->language, 0);
  r->type = RES_TYPE_RCDATA;
  r->u.rcdata = data;
  r->res_info = *resinfo;
}

/* Create an rcdata item holding a string.  */

rc_rcdata_item *
define_rcdata_string (const char *string, rc_uint_type len)
{
  rc_rcdata_item *ri;
  char *s;

  ri = (rc_rcdata_item *) res_alloc (sizeof (rc_rcdata_item));
  ri->next = NULL;
  ri->type = RCDATA_STRING;
  ri->u.string.length = len;
  s = (char *) res_alloc (len);
  memcpy (s, string, len);
  ri->u.string.s = s;

  return ri;
}

/* Create an rcdata item holding a unicode string.  */

rc_rcdata_item *
define_rcdata_unistring (const unichar *string, rc_uint_type len)
{
  rc_rcdata_item *ri;
  unichar *s;

  ri = (rc_rcdata_item *) res_alloc (sizeof (rc_rcdata_item));
  ri->next = NULL;
  ri->type = RCDATA_WSTRING;
  ri->u.wstring.length = len;
  s = (unichar *) res_alloc (len * sizeof (unichar));
  memcpy (s, string, len * sizeof (unichar));
  ri->u.wstring.w = s;

  return ri;
}

/* Create an rcdata item holding a number.  */

rc_rcdata_item *
define_rcdata_number (rc_uint_type val, int dword)
{
  rc_rcdata_item *ri;

  ri = (rc_rcdata_item *) res_alloc (sizeof (rc_rcdata_item));
  ri->next = NULL;
  ri->type = dword ? RCDATA_DWORD : RCDATA_WORD;
  ri->u.word = val;

  return ri;
}

/* Define a stringtable resource.  This is called for each string
   which appears in a STRINGTABLE statement.  */

void
define_stringtable (const rc_res_res_info *resinfo,
		    rc_uint_type stringid, const unichar *string, int len)
{
  unichar *h;
  rc_res_id id;
  rc_res_resource *r;

  id.named = 0;
  id.u.id = (stringid >> 4) + 1;
  r = define_standard_resource (&resources, RT_STRING, id,
				resinfo->language, 1);

  if (r->type == RES_TYPE_UNINITIALIZED)
    {
      int i;

      r->type = RES_TYPE_STRINGTABLE;
      r->u.stringtable = ((rc_stringtable *)
			  res_alloc (sizeof (rc_stringtable)));
      for (i = 0; i < 16; i++)
	{
	  r->u.stringtable->strings[i].length = 0;
	  r->u.stringtable->strings[i].string = NULL;
	}

      r->res_info = *resinfo;
    }
  h = (unichar *) res_alloc ((len + 1) * sizeof (unichar));
  if (len)
    memcpy (h, string, len * sizeof (unichar));
  h[len] = 0;
  r->u.stringtable->strings[stringid & 0xf].length = (rc_uint_type) len;
  r->u.stringtable->strings[stringid & 0xf].string = h;
}

void
define_toolbar (rc_res_id id, rc_res_res_info *resinfo, rc_uint_type width, rc_uint_type height,
		rc_toolbar_item *items)
{
  rc_toolbar *t;
  rc_res_resource *r;

  t = (rc_toolbar *) res_alloc (sizeof (rc_toolbar));
  t->button_width = width;
  t->button_height = height;
  t->nitems = 0;
  t->items = items;
  while (items != NULL)
  {
    t->nitems+=1;
    items = items->next;
  }
  r = define_standard_resource (&resources, RT_TOOLBAR, id, resinfo->language, 0);
  r->type = RES_TYPE_TOOLBAR;
  r->u.toolbar = t;
  r->res_info = *resinfo;
}

/* Define a user data resource where the data is in the rc file.  */

void
define_user_data (rc_res_id id, rc_res_id type,
		  const rc_res_res_info *resinfo,
		  rc_rcdata_item *data)
{
  rc_res_id ids[3];
  rc_res_resource *r;
  bfd_byte *pb_data;
  rc_uint_type len_data;

  /* We have to check if the binary data is parsed specially.  */
  if (type.named == 0)
    {
      switch (type.u.id)
      {
      case RT_FONTDIR:
	define_fontdir_rcdata (id, resinfo, data);
	return;
      case RT_FONT:
	define_font_rcdata (id, resinfo, data);
	return;
      case RT_ICON:
	define_icon_rcdata (id, resinfo, data);
	return;
      case RT_BITMAP:
	define_bitmap_rcdata (id, resinfo, data);
	return;
      case RT_CURSOR:
	define_cursor_rcdata (id, resinfo, data);
	return;
      case RT_GROUP_ICON:
	define_group_icon_rcdata (id, resinfo, data);
	return;
      case RT_GROUP_CURSOR:
	define_group_cursor_rcdata (id, resinfo, data);
	return;
      case RT_MESSAGETABLE:
	define_messagetable_rcdata (id, resinfo, data);
	return;
      default:
	/* Treat as normal user-data.  */
	break;
      }
    }
  ids[0] = type;
  ids[1] = id;
  ids[2].named = 0;
  ids[2].u.id = resinfo->language;

  r = define_resource (& resources, 3, ids, 0);
  r->type = RES_TYPE_USERDATA;
  r->u.userdata = ((rc_rcdata_item *)
		   res_alloc (sizeof (rc_rcdata_item)));
  r->u.userdata->next = NULL;
  r->u.userdata->type = RCDATA_BUFFER;
  pb_data = rcdata_render_as_buffer (data, &len_data);
  r->u.userdata->u.buffer.length = len_data;
  r->u.userdata->u.buffer.data = pb_data;
  r->res_info = *resinfo;
}

void
define_rcdata_file (rc_res_id id, const rc_res_res_info *resinfo,
		    const char *filename)
{
  rc_rcdata_item *ri;
  FILE *e;
  char *real_filename;
  struct stat s;
  bfd_byte *data;

  e = open_file_search (filename, FOPEN_RB, "file", &real_filename);


  if (stat (real_filename, &s) < 0)
    fatal (_("stat failed on file `%s': %s"), real_filename,
	   strerror (errno));

  data = (bfd_byte *) res_alloc (s.st_size);

  get_data (e, data, s.st_size, real_filename);

  fclose (e);
  free (real_filename);

  ri = (rc_rcdata_item *) res_alloc (sizeof (rc_rcdata_item));
  ri->next = NULL;
  ri->type = RCDATA_BUFFER;
  ri->u.buffer.length = s.st_size;
  ri->u.buffer.data = data;

  define_rcdata (id, resinfo, ri);
}

/* Define a user data resource where the data is in a file.  */

void
define_user_file (rc_res_id id, rc_res_id type,
		  const rc_res_res_info *resinfo, const char *filename)
{
  FILE *e;
  char *real_filename;
  struct stat s;
  bfd_byte *data;
  rc_res_id ids[3];
  rc_res_resource *r;

  e = open_file_search (filename, FOPEN_RB, "file", &real_filename);

  if (stat (real_filename, &s) < 0)
    fatal (_("stat failed on file `%s': %s"), real_filename,
	   strerror (errno));

  data = (bfd_byte *) res_alloc (s.st_size);

  get_data (e, data, s.st_size, real_filename);

  fclose (e);
  free (real_filename);

  ids[0] = type;
  ids[1] = id;
  ids[2].named = 0;
  ids[2].u.id = resinfo->language;

  r = define_resource (&resources, 3, ids, 0);
  r->type = RES_TYPE_USERDATA;
  r->u.userdata = ((rc_rcdata_item *)
		   res_alloc (sizeof (rc_rcdata_item)));
  r->u.userdata->next = NULL;
  r->u.userdata->type = RCDATA_BUFFER;
  r->u.userdata->u.buffer.length = s.st_size;
  r->u.userdata->u.buffer.data = data;
  r->res_info = *resinfo;
}

/* Define a versioninfo resource.  */

void
define_versioninfo (rc_res_id id, rc_uint_type language,
		    rc_fixed_versioninfo *fixedverinfo,
		    rc_ver_info *verinfo)
{
  rc_res_resource *r;

  r = define_standard_resource (&resources, RT_VERSION, id, language, 0);
  r->type = RES_TYPE_VERSIONINFO;
  r->u.versioninfo = ((rc_versioninfo *)
		      res_alloc (sizeof (rc_versioninfo)));
  r->u.versioninfo->fixed = fixedverinfo;
  r->u.versioninfo->var = verinfo;
  r->res_info.language = language;
}

/* Add string version info to a list of version information.  */

rc_ver_info *
append_ver_stringfileinfo (rc_ver_info *verinfo,
			   rc_ver_stringtable *stringtables)
{
  rc_ver_info *vi, **pp;

  vi = (rc_ver_info *) res_alloc (sizeof (rc_ver_info));
  vi->next = NULL;
  vi->type = VERINFO_STRING;
  vi->u.string.stringtables = stringtables;

  for (pp = &verinfo; *pp != NULL; pp = &(*pp)->next)
    ;
  *pp = vi;

  return verinfo;
}

rc_ver_stringtable *
append_ver_stringtable (rc_ver_stringtable *stringtable,
			const char *language,
			rc_ver_stringinfo *strings)
{
  rc_ver_stringtable *vst, **pp;

  vst = (rc_ver_stringtable *) res_alloc (sizeof (rc_ver_stringtable));
  vst->next = NULL;
  unicode_from_ascii ((rc_uint_type *) NULL, &vst->language, language);
  vst->strings = strings;

  for (pp = &stringtable; *pp != NULL; pp = &(*pp)->next)
    ;
  *pp = vst;

  return stringtable;
}

/* Add variable version info to a list of version information.  */

rc_ver_info *
append_ver_varfileinfo (rc_ver_info *verinfo, const unichar *key,
			rc_ver_varinfo *var)
{
  rc_ver_info *vi, **pp;

  vi = (rc_ver_info *) res_alloc (sizeof *vi);
  vi->next = NULL;
  vi->type = VERINFO_VAR;
  vi->u.var.key = unichar_dup (key);
  vi->u.var.var = var;

  for (pp = &verinfo; *pp != NULL; pp = &(*pp)->next)
    ;
  *pp = vi;

  return verinfo;
}

/* Append version string information to a list.  */

rc_ver_stringinfo *
append_verval (rc_ver_stringinfo *strings, const unichar *key,
	       const unichar *value)
{
  rc_ver_stringinfo *vs, **pp;

  vs = (rc_ver_stringinfo *) res_alloc (sizeof (rc_ver_stringinfo));
  vs->next = NULL;
  vs->key = unichar_dup (key);
  vs->value = unichar_dup (value);

  for (pp = &strings; *pp != NULL; pp = &(*pp)->next)
    ;
  *pp = vs;

  return strings;
}

/* Append version variable information to a list.  */

rc_ver_varinfo *
append_vertrans (rc_ver_varinfo *var, rc_uint_type language,
		 rc_uint_type charset)
{
  rc_ver_varinfo *vv, **pp;

  vv = (rc_ver_varinfo *) res_alloc (sizeof (rc_ver_varinfo));
  vv->next = NULL;
  vv->language = language;
  vv->charset = charset;

  for (pp = &var; *pp != NULL; pp = &(*pp)->next)
    ;
  *pp = vv;

  return var;
}

/* Local functions used to write out an rc file.  */

static void indent (FILE *, int);
static void write_rc_directory (FILE *, const rc_res_directory *, const rc_res_id *,
				const rc_res_id *, rc_uint_type *, int);
static void write_rc_subdir (FILE *, const rc_res_entry *, const rc_res_id *,
			     const rc_res_id *, rc_uint_type *, int);
static void write_rc_resource (FILE *, const rc_res_id *, const rc_res_id *,
			       const rc_res_resource *, rc_uint_type *);
static void write_rc_accelerators (FILE *, const rc_accelerator *);
static void write_rc_cursor (FILE *, const rc_cursor *);
static void write_rc_group_cursor (FILE *, const rc_group_cursor *);
static void write_rc_dialog (FILE *, const rc_dialog *);
static void write_rc_dialog_control (FILE *, const rc_dialog_control *);
static void write_rc_fontdir (FILE *, const rc_fontdir *);
static void write_rc_group_icon (FILE *, const rc_group_icon *);
static void write_rc_menu (FILE *, const rc_menu *, int);
static void write_rc_toolbar (FILE *, const rc_toolbar *);
static void write_rc_menuitems (FILE *, const rc_menuitem *, int, int);
static void write_rc_messagetable (FILE *, rc_uint_type , const bfd_byte *);

static void write_rc_datablock (FILE *, rc_uint_type , const bfd_byte *, int, int, int);
static void write_rc_rcdata (FILE *, const rc_rcdata_item *, int);
static void write_rc_stringtable (FILE *, const rc_res_id *, const rc_stringtable *);
static void write_rc_versioninfo (FILE *, const rc_versioninfo *);

/* Indent a given number of spaces.  */

static void
indent (FILE *e, int c)
{
  int i;

  for (i = 0; i < c; i++)
    putc (' ', e);
}

/* Dump the resources we have read in the format of an rc file.

   Reasoned by the fact, that some resources need to be stored into file and
   refer to that file, we use the user-data model for that to express it binary
   without the need to store it somewhere externally.  */

void
write_rc_file (const char *filename, const rc_res_directory *res_dir)
{
  FILE *e;
  rc_uint_type language;

  if (filename == NULL)
    e = stdout;
  else
    {
      e = fopen (filename, FOPEN_WT);
      if (e == NULL)
	fatal (_("can't open `%s' for output: %s"), filename, strerror (errno));
    }

  language = (rc_uint_type) ((bfd_signed_vma) -1);
  write_rc_directory (e, res_dir, (const rc_res_id *) NULL,
		      (const rc_res_id *) NULL, &language, 1);
}

/* Write out a directory.  E is the file to write to.  RD is the
   directory.  TYPE is a pointer to the level 1 ID which serves as the
   resource type.  NAME is a pointer to the level 2 ID which serves as
   an individual resource name.  LANGUAGE is a pointer to the current
   language.  LEVEL is the level in the tree.  */

static void
write_rc_directory (FILE *e, const rc_res_directory *rd,
		    const rc_res_id *type, const rc_res_id *name,
		    rc_uint_type *language, int level)
{
  const rc_res_entry *re;

  /* Print out some COFF information that rc files can't represent.  */
  if (rd->time != 0 || rd->characteristics != 0 || rd->major != 0 || rd->minor != 0)
    {
      wr_printcomment (e, "COFF information not part of RC");
  if (rd->time != 0)
	wr_printcomment (e, "Time stamp: %u", rd->time);
  if (rd->characteristics != 0)
	wr_printcomment (e, "Characteristics: %u", rd->characteristics);
  if (rd->major != 0 || rd->minor != 0)
	wr_printcomment (e, "Version major:%d minor:%d", rd->major, rd->minor);
    }

  for (re = rd->entries;  re != NULL; re = re->next)
    {
      switch (level)
	{
	case 1:
	  /* If we're at level 1, the key of this resource is the
             type.  This normally duplicates the information we have
             stored with the resource itself, but we need to remember
             the type if this is a user define resource type.  */
	  type = &re->id;
	  break;

	case 2:
	  /* If we're at level 2, the key of this resource is the name
	     we are going to use in the rc printout.  */
	  name = &re->id;
	  break;

	case 3:
	  /* If we're at level 3, then this key represents a language.
	     Use it to update the current language.  */
	  if (! re->id.named
	      && re->id.u.id != (unsigned long) (unsigned int) *language
	      && (re->id.u.id & 0xffff) == re->id.u.id)
	    {
	      wr_print (e, "LANGUAGE %u, %u\n",
		       re->id.u.id & ((1 << SUBLANG_SHIFT) - 1),
		       (re->id.u.id >> SUBLANG_SHIFT) & 0xff);
	      *language = re->id.u.id;
	    }
	  break;

	default:
	  break;
	}

      if (re->subdir)
	write_rc_subdir (e, re, type, name, language, level);
      else
	{
	  if (level == 3)
	    {
	      /* This is the normal case: the three levels are
                 TYPE/NAME/LANGUAGE.  NAME will have been set at level
                 2, and represents the name to use.  We probably just
                 set LANGUAGE, and it will probably match what the
                 resource itself records if anything.  */
	      write_rc_resource (e, type, name, re->u.res, language);
	    }
	  else
	    {
	      wr_printcomment (e, "Resource at unexpected level %d", level);
	      write_rc_resource (e, type, (rc_res_id *) NULL, re->u.res,
				 language);
	    }
	}
    }
  if (rd->entries == NULL)
    {
      wr_print_flush (e);
    }
}

/* Write out a subdirectory entry.  E is the file to write to.  RE is
   the subdirectory entry.  TYPE and NAME are pointers to higher level
   IDs, or NULL.  LANGUAGE is a pointer to the current language.
   LEVEL is the level in the tree.  */

static void
write_rc_subdir (FILE *e, const rc_res_entry *re,
		 const rc_res_id *type, const rc_res_id *name,
		 rc_uint_type *language, int level)
{
  fprintf (e, "\n");
  switch (level)
    {
    case 1:
      wr_printcomment (e, "Type: ");
      if (re->id.named)
	res_id_print (e, re->id, 1);
      else
	{
	  const char *s;

	  switch (re->id.u.id)
	    {
	    case RT_CURSOR: s = "cursor"; break;
	    case RT_BITMAP: s = "bitmap"; break;
	    case RT_ICON: s = "icon"; break;
	    case RT_MENU: s = "menu"; break;
	    case RT_DIALOG: s = "dialog"; break;
	    case RT_STRING: s = "stringtable"; break;
	    case RT_FONTDIR: s = "fontdir"; break;
	    case RT_FONT: s = "font"; break;
	    case RT_ACCELERATOR: s = "accelerators"; break;
	    case RT_RCDATA: s = "rcdata"; break;
	    case RT_MESSAGETABLE: s = "messagetable"; break;
	    case RT_GROUP_CURSOR: s = "group cursor"; break;
	    case RT_GROUP_ICON: s = "group icon"; break;
	    case RT_VERSION: s = "version"; break;
	    case RT_DLGINCLUDE: s = "dlginclude"; break;
	    case RT_PLUGPLAY: s = "plugplay"; break;
	    case RT_VXD: s = "vxd"; break;
	    case RT_ANICURSOR: s = "anicursor"; break;
	    case RT_ANIICON: s = "aniicon"; break;
	    case RT_TOOLBAR: s = "toolbar"; break;
	    case RT_HTML: s = "html"; break;
	    default: s = NULL; break;
	    }

	  if (s != NULL)
	    fprintf (e, "%s", s);
	  else
	    res_id_print (e, re->id, 1);
	}
      break;

    case 2:
      wr_printcomment (e, "Name: ");
      res_id_print (e, re->id, 1);
      break;

    case 3:
      wr_printcomment (e, "Language: ");
      res_id_print (e, re->id, 1);
      break;

    default:
      wr_printcomment (e, "Level %d: ", level);
      res_id_print (e, re->id, 1);
    }

  write_rc_directory (e, re->u.dir, type, name, language, level + 1);
}

/* Write out a single resource.  E is the file to write to.  TYPE is a
   pointer to the type of the resource.  NAME is a pointer to the name
   of the resource; it will be NULL if there is a level mismatch.  RES
   is the resource data.  LANGUAGE is a pointer to the current
   language.  */

static void
write_rc_resource (FILE *e, const rc_res_id *type,
		   const rc_res_id *name, const rc_res_resource *res,
		   rc_uint_type *language)
{
  const char *s;
  int rt;
  int menuex = 0;

  switch (res->type)
    {
    default:
      abort ();

    case RES_TYPE_ACCELERATOR:
      s = "ACCELERATORS";
      rt = RT_ACCELERATOR;
      break;

    case RES_TYPE_BITMAP:
      s = "2 /* RT_BITMAP */";
      rt = RT_BITMAP;
      break;

    case RES_TYPE_CURSOR:
      s = "1 /* RT_CURSOR */";
      rt = RT_CURSOR;
      break;

    case RES_TYPE_GROUP_CURSOR:
      s = "12 /* RT_GROUP_CURSOR */";
      rt = RT_GROUP_CURSOR;
      break;

    case RES_TYPE_DIALOG:
      if (extended_dialog (res->u.dialog))
	s = "DIALOGEX";
      else
	s = "DIALOG";
      rt = RT_DIALOG;
      break;

    case RES_TYPE_FONT:
      s = "8 /* RT_FONT */";
      rt = RT_FONT;
      break;

    case RES_TYPE_FONTDIR:
      s = "7 /* RT_FONTDIR */";
      rt = RT_FONTDIR;
      break;

    case RES_TYPE_ICON:
      s = "3 /* RT_ICON */";
      rt = RT_ICON;
      break;

    case RES_TYPE_GROUP_ICON:
      s = "14 /* RT_GROUP_ICON */";
      rt = RT_GROUP_ICON;
      break;

    case RES_TYPE_MENU:
      if (extended_menu (res->u.menu))
	{
	  s = "MENUEX";
	  menuex = 1;
	}
      else
	{
	  s = "MENU";
	  menuex = 0;
	}
      rt = RT_MENU;
      break;

    case RES_TYPE_MESSAGETABLE:
      s = "11 /* RT_MESSAGETABLE */";
      rt = RT_MESSAGETABLE;
      break;

    case RES_TYPE_RCDATA:
      s = "RCDATA";
      rt = RT_RCDATA;
      break;

    case RES_TYPE_STRINGTABLE:
      s = "STRINGTABLE";
      rt = RT_STRING;
      break;

    case RES_TYPE_USERDATA:
      s = NULL;
      rt = 0;
      break;

    case RES_TYPE_VERSIONINFO:
      s = "VERSIONINFO";
      rt = RT_VERSION;
      break;

    case RES_TYPE_TOOLBAR:
      s = "TOOLBAR";
      rt = RT_TOOLBAR;
      break;
    }

  if (rt != 0
      && type != NULL
      && (type->named || type->u.id != (unsigned long) rt))
    {
      wr_printcomment (e, "Unexpected resource type mismatch: ");
      res_id_print (e, *type, 1);
      fprintf (e, " != %d", rt);
    }

  if (res->coff_info.codepage != 0)
    wr_printcomment (e, "Code page: %u", res->coff_info.codepage);
  if (res->coff_info.reserved != 0)
    wr_printcomment (e, "COFF reserved value: %u", res->coff_info.reserved);

  wr_print (e, "\n");
  if (rt == RT_STRING)
    ;
  else
    {
  if (name != NULL)
	res_id_print (e, *name, 1);
  else
    fprintf (e, "??Unknown-Name??");
  fprintf (e, " ");
    }

  if (s != NULL)
    fprintf (e, "%s", s);
  else if (type != NULL)
    {
      if (type->named == 0)
	{
#define PRINT_RT_NAME(NAME) case NAME: \
	fprintf (e, "%u /* %s */", (unsigned int) NAME, #NAME); \
	break

	  switch (type->u.id)
	    {
	    default:
    res_id_print (e, *type, 0);
	      break;
	
	    PRINT_RT_NAME(RT_MANIFEST);
	    PRINT_RT_NAME(RT_ANICURSOR);
	    PRINT_RT_NAME(RT_ANIICON);
	    PRINT_RT_NAME(RT_RCDATA);
	    PRINT_RT_NAME(RT_ICON);
	    PRINT_RT_NAME(RT_CURSOR);
	    PRINT_RT_NAME(RT_BITMAP);
	    PRINT_RT_NAME(RT_PLUGPLAY);
	    PRINT_RT_NAME(RT_VXD);
	    PRINT_RT_NAME(RT_FONT);
	    PRINT_RT_NAME(RT_FONTDIR);
	    PRINT_RT_NAME(RT_HTML);
	    PRINT_RT_NAME(RT_MESSAGETABLE);
	    PRINT_RT_NAME(RT_DLGINCLUDE);
	    PRINT_RT_NAME(RT_DLGINIT);
	    }
#undef PRINT_RT_NAME
	}
      else
	res_id_print (e, *type, 1);
    }
  else
    fprintf (e, "??Unknown-Type??");

  if (res->res_info.memflags != 0)
    {
      if ((res->res_info.memflags & MEMFLAG_MOVEABLE) != 0)
	fprintf (e, " MOVEABLE");
      if ((res->res_info.memflags & MEMFLAG_PURE) != 0)
	fprintf (e, " PURE");
      if ((res->res_info.memflags & MEMFLAG_PRELOAD) != 0)
	fprintf (e, " PRELOAD");
      if ((res->res_info.memflags & MEMFLAG_DISCARDABLE) != 0)
	fprintf (e, " DISCARDABLE");
    }

  if (res->type == RES_TYPE_DIALOG)
    {
      fprintf (e, " %d, %d, %d, %d",
	       (int) res->u.dialog->x, (int) res->u.dialog->y,
	       (int) res->u.dialog->width, (int) res->u.dialog->height);
      if (res->u.dialog->ex != NULL
	  && res->u.dialog->ex->help != 0)
	fprintf (e, ", %u", (unsigned int) res->u.dialog->ex->help);
    }
  else if (res->type == RES_TYPE_TOOLBAR)
  {
    fprintf (e, " %d, %d", (int) res->u.toolbar->button_width,
	     (int) res->u.toolbar->button_height);
    }

  fprintf (e, "\n");

  if ((res->res_info.language != 0 && res->res_info.language != *language)
      || res->res_info.characteristics != 0
      || res->res_info.version != 0)
    {
      int modifiers;

      switch (res->type)
	{
	case RES_TYPE_ACCELERATOR:
	case RES_TYPE_DIALOG:
	case RES_TYPE_MENU:
	case RES_TYPE_RCDATA:
	case RES_TYPE_STRINGTABLE:
	  modifiers = 1;
	  break;

	default:
	  modifiers = 0;
	  break;
	}

      if (res->res_info.language != 0 && res->res_info.language != *language)
	fprintf (e, "%sLANGUAGE %d, %d\n",
		 modifiers ? "// " : "",
		 (int) res->res_info.language & ((1<<SUBLANG_SHIFT)-1),
		 (int) (res->res_info.language >> SUBLANG_SHIFT) & 0xff);
      if (res->res_info.characteristics != 0)
	fprintf (e, "%sCHARACTERISTICS %u\n",
		 modifiers ? "// " : "",
		 (unsigned int) res->res_info.characteristics);
      if (res->res_info.version != 0)
	fprintf (e, "%sVERSION %u\n",
		 modifiers ? "// " : "",
		 (unsigned int) res->res_info.version);
    }

  switch (res->type)
    {
    default:
      abort ();

    case RES_TYPE_ACCELERATOR:
      write_rc_accelerators (e, res->u.acc);
      break;

    case RES_TYPE_CURSOR:
      write_rc_cursor (e, res->u.cursor);
      break;

    case RES_TYPE_GROUP_CURSOR:
      write_rc_group_cursor (e, res->u.group_cursor);
      break;

    case RES_TYPE_DIALOG:
      write_rc_dialog (e, res->u.dialog);
      break;

    case RES_TYPE_FONTDIR:
      write_rc_fontdir (e, res->u.fontdir);
      break;

    case RES_TYPE_GROUP_ICON:
      write_rc_group_icon (e, res->u.group_icon);
      break;

    case RES_TYPE_MENU:
      write_rc_menu (e, res->u.menu, menuex);
      break;

    case RES_TYPE_RCDATA:
      write_rc_rcdata (e, res->u.rcdata, 0);
      break;

    case RES_TYPE_STRINGTABLE:
      write_rc_stringtable (e, name, res->u.stringtable);
      break;

    case RES_TYPE_USERDATA:
      write_rc_rcdata (e, res->u.userdata, 0);
      break;

    case RES_TYPE_TOOLBAR:
      write_rc_toolbar (e, res->u.toolbar);
      break;

    case RES_TYPE_VERSIONINFO:
      write_rc_versioninfo (e, res->u.versioninfo);
      break;

    case RES_TYPE_BITMAP:
    case RES_TYPE_FONT:
    case RES_TYPE_ICON:
      write_rc_datablock (e, res->u.data.length, res->u.data.data, 0, 1, 0);
      break;
    case RES_TYPE_MESSAGETABLE:
      write_rc_messagetable (e, res->u.data.length, res->u.data.data);
      break;
    }
}

/* Write out accelerator information.  */

static void
write_rc_accelerators (FILE *e, const rc_accelerator *accelerators)
{
  const rc_accelerator *acc;

  fprintf (e, "BEGIN\n");
  for (acc = accelerators; acc != NULL; acc = acc->next)
    {
      int printable;

      fprintf (e, "  ");

      if ((acc->key & 0x7f) == acc->key
	  && ISPRINT (acc->key)
	  && (acc->flags & ACC_VIRTKEY) == 0)
	{
	  fprintf (e, "\"%c\"", (char) acc->key);
	  printable = 1;
	}
      else
	{
	  fprintf (e, "%d", (int) acc->key);
	  printable = 0;
	}

      fprintf (e, ", %d", (int) acc->id);

      if (! printable)
	{
	  if ((acc->flags & ACC_VIRTKEY) != 0)
	    fprintf (e, ", VIRTKEY");
	  else
	    fprintf (e, ", ASCII");
	}

      if ((acc->flags & ACC_SHIFT) != 0)
	fprintf (e, ", SHIFT");
      if ((acc->flags & ACC_CONTROL) != 0)
	fprintf (e, ", CONTROL");
      if ((acc->flags & ACC_ALT) != 0)
	fprintf (e, ", ALT");

      fprintf (e, "\n");
    }

  fprintf (e, "END\n");
}

/* Write out cursor information.  This would normally be in a separate
   file, which the rc file would include.  */

static void
write_rc_cursor (FILE *e, const rc_cursor *cursor)
{
  fprintf (e, "BEGIN\n");
  indent (e, 2);
  fprintf (e, " 0x%x, 0x%x,\t/* Hotspot x: %d, y: %d.  */\n",
	   (unsigned int) cursor->xhotspot, (unsigned int) cursor->yhotspot,
	   (int) cursor->xhotspot, (int) cursor->yhotspot);
  write_rc_datablock (e, (rc_uint_type) cursor->length, (const bfd_byte *) cursor->data,
  		      0, 0, 0);
  fprintf (e, "END\n");
}

/* Write out group cursor data.  This would normally be built from the
   cursor data.  */

static void
write_rc_group_cursor (FILE *e, const rc_group_cursor *group_cursor)
{
  const rc_group_cursor *gc;
  int c;

  for (c = 0, gc = group_cursor; gc != NULL; gc = gc->next, c++)
    ;
  fprintf (e, "BEGIN\n");

  indent (e, 2);
  fprintf (e, "0, 2, %d%s\t /* Having %d items.  */\n", c, (c != 0 ? "," : ""), c);
  indent (e, 4);
  fprintf (e, "/* width, height, planes, bits, bytes, index.  */\n");

  for (c = 1, gc = group_cursor; gc != NULL; gc = gc->next, c++)
    {
      indent (e, 4);
      fprintf (e, "%d, %d, %d, %d, 0x%xL, %d%s /* Element %d. */\n",
	(int) gc->width, (int) gc->height, (int) gc->planes, (int) gc->bits,
	(unsigned int) gc->bytes, (int) gc->index, (gc->next != NULL ? "," : ""), c);
      fprintf (e, "/* width: %d; height %d; planes %d; bits %d.  */\n",
	     (int) gc->width, (int) gc->height, (int) gc->planes,
	     (int) gc->bits);
    }
  fprintf (e, "END\n");
}

/* Write dialog data.  */

static void
write_rc_dialog (FILE *e, const rc_dialog *dialog)
{
  const rc_dialog_control *control;

  fprintf (e, "STYLE 0x%x\n", dialog->style);

  if (dialog->exstyle != 0)
    fprintf (e, "EXSTYLE 0x%x\n", (unsigned int) dialog->exstyle);

  if ((dialog->class.named && dialog->class.u.n.length > 0)
      || dialog->class.u.id != 0)
    {
      fprintf (e, "CLASS ");
      res_id_print (e, dialog->class, 1);
      fprintf (e, "\n");
    }

  if (dialog->caption != NULL)
    {
      fprintf (e, "CAPTION ");
      unicode_print_quoted (e, dialog->caption, -1);
      fprintf (e, "\n");
    }

  if ((dialog->menu.named && dialog->menu.u.n.length > 0)
      || dialog->menu.u.id != 0)
    {
      fprintf (e, "MENU ");
      res_id_print (e, dialog->menu, 0);
      fprintf (e, "\n");
    }

  if (dialog->font != NULL)
    {
      fprintf (e, "FONT %d, ", (int) dialog->pointsize);
      unicode_print_quoted (e, dialog->font, -1);
      if (dialog->ex != NULL
	  && (dialog->ex->weight != 0
	      || dialog->ex->italic != 0
	      || dialog->ex->charset != 1))
	fprintf (e, ", %d, %d, %d",
		 (int) dialog->ex->weight,
		 (int) dialog->ex->italic,
		 (int) dialog->ex->charset);
      fprintf (e, "\n");
    }

  fprintf (e, "BEGIN\n");

  for (control = dialog->controls; control != NULL; control = control->next)
    write_rc_dialog_control (e, control);

  fprintf (e, "END\n");
}

/* For each predefined control keyword, this table provides the class
   and the style.  */

struct control_info
{
  const char *name;
  unsigned short class;
  unsigned long style;
};

static const struct control_info control_info[] =
{
  { "AUTO3STATE", CTL_BUTTON, BS_AUTO3STATE },
  { "AUTOCHECKBOX", CTL_BUTTON, BS_AUTOCHECKBOX },
  { "AUTORADIOBUTTON", CTL_BUTTON, BS_AUTORADIOBUTTON },
  { "CHECKBOX", CTL_BUTTON, BS_CHECKBOX },
  { "COMBOBOX", CTL_COMBOBOX, (unsigned long) -1 },
  { "CTEXT", CTL_STATIC, SS_CENTER },
  { "DEFPUSHBUTTON", CTL_BUTTON, BS_DEFPUSHBUTTON },
  { "EDITTEXT", CTL_EDIT, (unsigned long) -1 },
  { "GROUPBOX", CTL_BUTTON, BS_GROUPBOX },
  { "ICON", CTL_STATIC, SS_ICON },
  { "LISTBOX", CTL_LISTBOX, (unsigned long) -1 },
  { "LTEXT", CTL_STATIC, SS_LEFT },
  { "PUSHBOX", CTL_BUTTON, BS_PUSHBOX },
  { "PUSHBUTTON", CTL_BUTTON, BS_PUSHBUTTON },
  { "RADIOBUTTON", CTL_BUTTON, BS_RADIOBUTTON },
  { "RTEXT", CTL_STATIC, SS_RIGHT },
  { "SCROLLBAR", CTL_SCROLLBAR, (unsigned long) -1 },
  { "STATE3", CTL_BUTTON, BS_3STATE },
  /* It's important that USERBUTTON come after all the other button
     types, so that it won't be matched too early.  */
  { "USERBUTTON", CTL_BUTTON, (unsigned long) -1 },
  { NULL, 0, 0 }
};

/* Write a dialog control.  */

static void
write_rc_dialog_control (FILE *e, const rc_dialog_control *control)
{
  const struct control_info *ci;

  fprintf (e, "  ");

  if (control->class.named)
    ci = NULL;
  else
    {
      for (ci = control_info; ci->name != NULL; ++ci)
	if (ci->class == control->class.u.id
	    && (ci->style == (unsigned long) -1
		|| ci->style == (control->style & 0xff)))
	  break;
    }
  if (ci == NULL)
    fprintf (e, "CONTROL");
  else if (ci->name != NULL)
    fprintf (e, "%s", ci->name);
  else
    {
    fprintf (e, "CONTROL");
      ci = NULL;
    }

  /* For EDITTEXT, COMBOBOX, LISTBOX, and SCROLLBAR don't dump text.  */
  if ((control->text.named || control->text.u.id != 0)
      && (!ci
          || (ci->class != CTL_EDIT
              && ci->class != CTL_COMBOBOX
              && ci->class != CTL_LISTBOX
              && ci->class != CTL_SCROLLBAR)))
    {
      fprintf (e, " ");
      res_id_print (e, control->text, 1);
      fprintf (e, ",");
    }

  fprintf (e, " %d, ", (int) control->id);

  if (ci == NULL)
    {
      if (control->class.named)
	fprintf (e, "\"");
      res_id_print (e, control->class, 0);
      if (control->class.named)
	fprintf (e, "\"");
      fprintf (e, ", 0x%x, ", (unsigned int) control->style);
    }

  fprintf (e, "%d, %d", (int) control->x, (int) control->y);

  if (control->style != SS_ICON
      || control->exstyle != 0
      || control->width != 0
      || control->height != 0
      || control->help != 0)
    {
      fprintf (e, ", %d, %d", (int) control->width, (int) control->height);

      /* FIXME: We don't need to print the style if it is the default.
	 More importantly, in certain cases we actually need to turn
	 off parts of the forced style, by using NOT.  */
      if (ci != NULL)
	fprintf (e, ", 0x%x", (unsigned int) control->style);

      if (control->exstyle != 0 || control->help != 0)
	fprintf (e, ", 0x%x, %u", (unsigned int) control->exstyle,
		 (unsigned int) control->help);
    }

  fprintf (e, "\n");

  if (control->data != NULL)
    write_rc_rcdata (e, control->data, 2);
}

/* Write out font directory data.  This would normally be built from
   the font data.  */

static void
write_rc_fontdir (FILE *e, const rc_fontdir *fontdir)
{
  const rc_fontdir *fc;
  int c;

  for (c = 0, fc = fontdir; fc != NULL; fc = fc->next, c++)
    ;
  fprintf (e, "BEGIN\n");
  indent (e, 2);
  fprintf (e, "%d%s\t /* Has %d elements.  */\n", c, (c != 0 ? "," : ""), c);
  for (c = 1, fc = fontdir; fc != NULL; fc = fc->next, c++)
    {
      indent (e, 4);
      fprintf (e, "%d,\t/* Font no %d with index %d.  */\n",
	(int) fc->index, c, (int) fc->index);
      write_rc_datablock (e, (rc_uint_type) fc->length - 2,
			  (const bfd_byte *) fc->data + 4,fc->next != NULL,
			  0, 0);
    }
  fprintf (e, "END\n");
}

/* Write out group icon data.  This would normally be built from the
   icon data.  */

static void
write_rc_group_icon (FILE *e, const rc_group_icon *group_icon)
{
  const rc_group_icon *gi;
  int c;

  for (c = 0, gi = group_icon; gi != NULL; gi = gi->next, c++)
    ;

  fprintf (e, "BEGIN\n");
  indent (e, 2);
  fprintf (e, " 0, 1, %d%s\t /* Has %d elements.  */\n", c, (c != 0 ? "," : ""), c);

  indent (e, 4);
  fprintf (e, "/* \"width height colors pad\", planes, bits, bytes, index.  */\n");
  for (c = 1, gi = group_icon; gi != NULL; gi = gi->next, c++)
    {
      indent (e, 4);
      fprintf (e, "\"\\%03o\\%03o\\%03o\\%03o\", %d, %d, 0x%xL, %d%s\t/* Element no %d.  */\n",
	gi->width, gi->height, gi->colors, 0, (int) gi->planes, (int) gi->bits,
	(unsigned int) gi->bytes, (int) gi->index, (gi->next != NULL ? "," : ""), c);
    }
  fprintf (e, "END\n");
}

/* Write out a menu resource.  */

static void
write_rc_menu (FILE *e, const rc_menu *menu, int menuex)
{
  if (menu->help != 0)
    fprintf (e, "// Help ID: %u\n", (unsigned int) menu->help);
  write_rc_menuitems (e, menu->items, menuex, 0);
}

static void
write_rc_toolbar (FILE *e, const rc_toolbar *tb)
{
  rc_toolbar_item *it;
  indent (e, 0);
  fprintf (e, "BEGIN\n");
  it = tb->items;
  while(it != NULL)
  {
    indent (e, 2);
    if (it->id.u.id == 0)
      fprintf (e, "SEPARATOR\n");
    else 
      fprintf (e, "BUTTON %d\n", (int) it->id.u.id);
    it = it->next;
  }
  indent (e, 0);
  fprintf (e, "END\n");
}

/* Write out menuitems.  */

static void
write_rc_menuitems (FILE *e, const rc_menuitem *menuitems, int menuex,
		    int ind)
{
  const rc_menuitem *mi;

  indent (e, ind);
  fprintf (e, "BEGIN\n");

  for (mi = menuitems; mi != NULL; mi = mi->next)
    {
      indent (e, ind + 2);

      if (mi->popup == NULL)
	fprintf (e, "MENUITEM");
      else
	fprintf (e, "POPUP");

      if (! menuex
	  && mi->popup == NULL
	  && mi->text == NULL
	  && mi->type == 0
	  && mi->id == 0)
	{
	  fprintf (e, " SEPARATOR\n");
	  continue;
	}

      if (mi->text == NULL)
	fprintf (e, " \"\"");
      else
	{
	  fprintf (e, " ");
	  unicode_print_quoted (e, mi->text, -1);
	}

      if (! menuex)
	{
	  if (mi->popup == NULL)
	    fprintf (e, ", %d", (int) mi->id);

	  if ((mi->type & MENUITEM_CHECKED) != 0)
	    fprintf (e, ", CHECKED");
	  if ((mi->type & MENUITEM_GRAYED) != 0)
	    fprintf (e, ", GRAYED");
	  if ((mi->type & MENUITEM_HELP) != 0)
	    fprintf (e, ", HELP");
	  if ((mi->type & MENUITEM_INACTIVE) != 0)
	    fprintf (e, ", INACTIVE");
	  if ((mi->type & MENUITEM_MENUBARBREAK) != 0)
	    fprintf (e, ", MENUBARBREAK");
	  if ((mi->type & MENUITEM_MENUBREAK) != 0)
	    fprintf (e, ", MENUBREAK");
	}
      else
	{
	  if (mi->id != 0 || mi->type != 0 || mi->state != 0 || mi->help != 0)
	    {
	      fprintf (e, ", %d", (int) mi->id);
	      if (mi->type != 0 || mi->state != 0 || mi->help != 0)
		{
		  fprintf (e, ", %u", (unsigned int) mi->type);
		  if (mi->state != 0 || mi->help != 0)
		    {
		      fprintf (e, ", %u", (unsigned int) mi->state);
		      if (mi->help != 0)
			fprintf (e, ", %u", (unsigned int) mi->help);
		    }
		}
	    }
	}

      fprintf (e, "\n");

      if (mi->popup != NULL)
	write_rc_menuitems (e, mi->popup, menuex, ind + 2);
    }

  indent (e, ind);
  fprintf (e, "END\n");
}

static int
test_rc_datablock_unicode (rc_uint_type length, const bfd_byte *data)
{
  rc_uint_type i;
  if ((length & 1) != 0)
    return 0;

  for (i = 0; i < length; i += 2)
    {
      if (data[i] == 0 && data[i + 1] == 0 && (i + 2) < length)
	return 0;
      if (data[i] == 0xff && data[i + 1] == 0xff)
	return 0;
    }
  return 1;
}

static int
test_rc_datablock_text (rc_uint_type length, const bfd_byte *data)
{
  int has_nl;
  rc_uint_type c;
  rc_uint_type i;
  
  if (length <= 1)
    return 0;

  has_nl = 0;
  for (i = 0, c = 0; i < length; i++)
    {
      if (! ISPRINT (data[i]) && data[i] != '\n'
      	  && ! (data[i] == '\r' && (i + 1) < length && data[i + 1] == '\n')
      	  && data[i] != '\t'
	  && ! (data[i] == 0 && (i + 1) != length))
	{
	  if (data[i] <= 7)
	    return 0;
	  c++;
	}
      else if (data[i] == '\n') has_nl++;
    }
  if (length > 80 && ! has_nl)
    return 0;
  c = (((c * 10000) + (i / 100) - 1)) / i;
  if (c >= 150)
    return 0;
  return 1;
}

static void
write_rc_messagetable (FILE *e, rc_uint_type length, const bfd_byte *data)
{
  int has_error = 0;
  const struct bin_messagetable *mt;
  fprintf (e, "BEGIN\n");

  write_rc_datablock (e, length, data, 0, 0, 0);

  fprintf (e, "\n");
  wr_printcomment (e, "MC syntax dump");
  if (length < BIN_MESSAGETABLE_SIZE)
    has_error = 1;
  else
    do {
      rc_uint_type m, i;
      mt = (const struct bin_messagetable *) data;
      m = windres_get_32 (&wrtarget, mt->cblocks, length);
      if (length < (BIN_MESSAGETABLE_SIZE + m * BIN_MESSAGETABLE_BLOCK_SIZE))
	{
	  has_error = 1;
	  break;
	}
      for (i = 0; i < m; i++)
	{
	  rc_uint_type low, high, offset;
	  const struct bin_messagetable_item *mti;

	  low = windres_get_32 (&wrtarget, mt->items[i].lowid, 4);
	  high = windres_get_32 (&wrtarget, mt->items[i].highid, 4);
	  offset = windres_get_32 (&wrtarget, mt->items[i].offset, 4);
	  while (low <= high)
	    {
	      rc_uint_type elen, flags;
	      if ((offset + BIN_MESSAGETABLE_ITEM_SIZE) > length)
		{
		  has_error = 1;
	  break;
		}
	      mti = (const struct bin_messagetable_item *) &data[offset];
	      elen = windres_get_16 (&wrtarget, mti->length, 2);
	      flags = windres_get_16 (&wrtarget, mti->flags, 2);
	      if ((offset + elen) > length)
		{
		  has_error = 1;
		  break;
		}
	      wr_printcomment (e, "MessageId = 0x%x", low);
	      wr_printcomment (e, "");
	      if ((flags & MESSAGE_RESOURCE_UNICODE) == MESSAGE_RESOURCE_UNICODE)
		unicode_print (e, (const unichar *) mti->data,
			       (elen - BIN_MESSAGETABLE_ITEM_SIZE) / 2);
	      else
		ascii_print (e, (const char *) mti->data,
			     (elen - BIN_MESSAGETABLE_ITEM_SIZE));
	      wr_printcomment (e,"");
	      ++low;
	      offset += elen;
	    }
	}
    } while (0);
  if (has_error)
    wr_printcomment (e, "Illegal data");
  wr_print_flush (e);
  fprintf (e, "END\n");
}

static void
write_rc_datablock (FILE *e, rc_uint_type length, const bfd_byte *data, int has_next,
		    int hasblock, int show_comment)
{
  int plen;

  if (hasblock)
    fprintf (e, "BEGIN\n");

  if (show_comment == -1)
	  {
      if (test_rc_datablock_text(length, data))
	{
	  rc_uint_type i, c;
	  for (i = 0; i < length;)
	    {
	      indent (e, 2);
	      fprintf (e, "\"");

	      for (c = 0; i < length && c < 160 && data[i] != '\n'; c++, i++)
		;
	      if (i < length && data[i] == '\n')
		++i, ++c;
	      ascii_print (e, (const char *) &data[i - c], c);
	    fprintf (e, "\"");
	      if (i < length)
		fprintf (e, "\n");
	    }
          
	  if (i == 0)
	      {
	      indent (e, 2);
	      fprintf (e, "\"\"");
	      }
	  if (has_next)
	    fprintf (e, ",");
	  fprintf (e, "\n");
	  if (hasblock)
	    fprintf (e, "END\n");
	  return;
	  }
      if (test_rc_datablock_unicode (length, data))
	{
	  rc_uint_type i, c;
	  for (i = 0; i < length;)
	    {
	      const unichar *u;

	      u = (const unichar *) &data[i];
	      indent (e, 2);
	  fprintf (e, "L\"");
    	  
	      for (c = 0; i < length && c < 160 && u[c] != '\n'; c++, i += 2)
		;
	      if (i < length && u[c] == '\n')
		i += 2, ++c;
	      unicode_print (e, u, c);
	  fprintf (e, "\"");
	      if (i < length)
		fprintf (e, "\n");
	    }

	  if (i == 0)
	  {
	      indent (e, 2);
	      fprintf (e, "L\"\"");
	    }
	  if (has_next)
	    fprintf (e, ",");
	  fprintf (e, "\n");
	  if (hasblock)
	    fprintf (e, "END\n");
	  return;
	}

      show_comment = 0;
    }

  if (length != 0)
	      {
      rc_uint_type i, max_row;
      int first = 1;

      max_row = (show_comment ? 4 : 8);
      indent (e, 2);
      for (i = 0; i + 3 < length;)
		  {
	  rc_uint_type k;
	  rc_uint_type comment_start;
	  
	  comment_start = i;
	  
	  if (! first)
	    indent (e, 2);

	  for (k = 0; k < max_row && i + 3 < length; k++, i += 4)
		      {
	      if (k == 0)
		plen  = fprintf (e, "0x%lxL",
				 (unsigned long) windres_get_32 (&wrtarget, data + i, length - i));
			else
		plen = fprintf (e, " 0x%lxL",
				(unsigned long) windres_get_32 (&wrtarget, data + i, length - i)) - 1;
	      if (has_next || (i + 4) < length)
			  {
		  if (plen>0 && plen < 11)
		    indent (e, 11 - plen);
		  fprintf (e, ",");
			  }
		      }
	  if (show_comment)
	    {
	      fprintf (e, "\t/* ");
	      ascii_print (e, (const char *) &data[comment_start], i - comment_start);
	      fprintf (e, ".  */");
		  }
		fprintf (e, "\n");
		first = 0;
	      }

      if (i + 1 < length)
	      {
		if (! first)
	    indent (e, 2);
	  plen = fprintf (e, "0x%x",
	  		  (int) windres_get_16 (&wrtarget, data + i, length - i));
	  if (has_next || i + 2 < length)
		  {
	      if (plen > 0 && plen < 11)
		indent (e, 11 - plen);
	      fprintf (e, ",");
		      }
	  if (show_comment)
	    {
	      fprintf (e, "\t/* ");
	      ascii_print (e, (const char *) &data[i], 2);
	      fprintf (e, ".  */");
		  }
		fprintf (e, "\n");
		i += 2;
		first = 0;
	      }

      if (i < length)
	      {
		if (! first)
	    indent (e, 2);
	  fprintf (e, "\"");
	  ascii_print (e, (const char *) &data[i], 1);
	  fprintf (e, "\"");
	  if (has_next)
		  fprintf (e, ",");
		fprintf (e, "\n");
		first = 0;
	      }
    }
  if (hasblock)
    fprintf (e, "END\n");
}

/* Write out an rcdata resource.  This is also used for other types of
   resources that need to print arbitrary data.  */

static void
write_rc_rcdata (FILE *e, const rc_rcdata_item *rcdata, int ind)
{
  const rc_rcdata_item *ri;

  indent (e, ind);
  fprintf (e, "BEGIN\n");

  for (ri = rcdata; ri != NULL; ri = ri->next)
    {
      if (ri->type == RCDATA_BUFFER && ri->u.buffer.length == 0)
	continue;

      switch (ri->type)
	{
	default:
	  abort ();

	case RCDATA_WORD:
	  indent (e, ind + 2);
	  fprintf (e, "%ld", (long) (ri->u.word & 0xffff));
	  break;

	case RCDATA_DWORD:
	  indent (e, ind + 2);
	  fprintf (e, "%luL", (unsigned long) ri->u.dword);
	  break;

	case RCDATA_STRING:
	  indent (e, ind + 2);
	  fprintf (e, "\"");
	  ascii_print (e, ri->u.string.s, ri->u.string.length);
	  fprintf (e, "\"");
	  break;

	case RCDATA_WSTRING:
	  indent (e, ind + 2);
	  fprintf (e, "L\"");
	  unicode_print (e, ri->u.wstring.w, ri->u.wstring.length);
	  fprintf (e, "\"");
	  break;

	case RCDATA_BUFFER:
	  write_rc_datablock (e, (rc_uint_type) ri->u.buffer.length,
	  		      (const bfd_byte *) ri->u.buffer.data,
	    		      ri->next != NULL, 0, -1);
	    break;
	}

      if (ri->type != RCDATA_BUFFER)
	{
	  if (ri->next != NULL)
	    fprintf (e, ",");
	  fprintf (e, "\n");
	}
    }

  indent (e, ind);
  fprintf (e, "END\n");
}

/* Write out a stringtable resource.  */

static void
write_rc_stringtable (FILE *e, const rc_res_id *name,
		      const rc_stringtable *stringtable)
{
  rc_uint_type offset;
  int i;

  if (name != NULL && ! name->named)
    offset = (name->u.id - 1) << 4;
  else
    {
      fprintf (e, "/* %s string table name.  */\n",
	       name == NULL ? "Missing" : "Invalid");
      offset = 0;
    }

  fprintf (e, "BEGIN\n");

  for (i = 0; i < 16; i++)
    {
      if (stringtable->strings[i].length != 0)
	{
	  fprintf (e, "  %lu, ", (unsigned long) offset + i);
	  unicode_print_quoted (e, stringtable->strings[i].string,
			 stringtable->strings[i].length);
	  fprintf (e, "\n");
	}
    }

  fprintf (e, "END\n");
}

/* Write out a versioninfo resource.  */

static void
write_rc_versioninfo (FILE *e, const rc_versioninfo *versioninfo)
{
  const rc_fixed_versioninfo *f;
  const rc_ver_info *vi;

  f = versioninfo->fixed;
  if (f->file_version_ms != 0 || f->file_version_ls != 0)
    fprintf (e, " FILEVERSION %u, %u, %u, %u\n",
	     (unsigned int) ((f->file_version_ms >> 16) & 0xffff),
	     (unsigned int) (f->file_version_ms & 0xffff),
	     (unsigned int) ((f->file_version_ls >> 16) & 0xffff),
	     (unsigned int) (f->file_version_ls & 0xffff));
  if (f->product_version_ms != 0 || f->product_version_ls != 0)
    fprintf (e, " PRODUCTVERSION %u, %u, %u, %u\n",
	     (unsigned int) ((f->product_version_ms >> 16) & 0xffff),
	     (unsigned int) (f->product_version_ms & 0xffff),
	     (unsigned int) ((f->product_version_ls >> 16) & 0xffff),
	     (unsigned int) (f->product_version_ls & 0xffff));
  if (f->file_flags_mask != 0)
    fprintf (e, " FILEFLAGSMASK 0x%x\n", (unsigned int) f->file_flags_mask);
  if (f->file_flags != 0)
    fprintf (e, " FILEFLAGS 0x%x\n", (unsigned int) f->file_flags);
  if (f->file_os != 0)
    fprintf (e, " FILEOS 0x%x\n", (unsigned int) f->file_os);
  if (f->file_type != 0)
    fprintf (e, " FILETYPE 0x%x\n", (unsigned int) f->file_type);
  if (f->file_subtype != 0)
    fprintf (e, " FILESUBTYPE 0x%x\n", (unsigned int) f->file_subtype);
  if (f->file_date_ms != 0 || f->file_date_ls != 0)
    fprintf (e, "/* Date: %u, %u.  */\n",
    	     (unsigned int) f->file_date_ms, (unsigned int) f->file_date_ls);

  fprintf (e, "BEGIN\n");

  for (vi = versioninfo->var; vi != NULL; vi = vi->next)
    {
      switch (vi->type)
	{
	case VERINFO_STRING:
	  {
	    const rc_ver_stringtable *vst;
	    const rc_ver_stringinfo *vs;

	    fprintf (e, "  BLOCK \"StringFileInfo\"\n");
	    fprintf (e, "  BEGIN\n");

	    for (vst = vi->u.string.stringtables; vst != NULL; vst = vst->next)
	      {
		fprintf (e, "    BLOCK ");
		unicode_print_quoted (e, vst->language, -1);

		fprintf (e, "\n");
		fprintf (e, "    BEGIN\n");

		for (vs = vst->strings; vs != NULL; vs = vs->next)
		  {
		    fprintf (e, "      VALUE ");
		    unicode_print_quoted (e, vs->key, -1);
		    fprintf (e, ", ");
		    unicode_print_quoted (e, vs->value, -1);
		    fprintf (e, "\n");
		  }

		fprintf (e, "    END\n");
	      }
	    fprintf (e, "  END\n");
	    break;
	  }

	case VERINFO_VAR:
	  {
	    const rc_ver_varinfo *vv;

	    fprintf (e, "  BLOCK \"VarFileInfo\"\n");
	    fprintf (e, "  BEGIN\n");
	    fprintf (e, "    VALUE ");
	    unicode_print_quoted (e, vi->u.var.key, -1);

	    for (vv = vi->u.var.var; vv != NULL; vv = vv->next)
	      fprintf (e, ", 0x%x, %d", (unsigned int) vv->language,
		       (int) vv->charset);

	    fprintf (e, "\n  END\n");

	    break;
	  }
	}
    }

  fprintf (e, "END\n");
}

static rc_uint_type
rcdata_copy (const rc_rcdata_item *src, bfd_byte *dst)
{
  if (! src)
    return 0;
  switch (src->type)
	{
    case RCDATA_WORD:
      if (dst)
	windres_put_16 (&wrtarget, dst, (rc_uint_type) src->u.word);
      return 2;
    case RCDATA_DWORD:
      if (dst)
	windres_put_32 (&wrtarget, dst, (rc_uint_type) src->u.dword);
      return 4;
    case RCDATA_STRING:
      if (dst && src->u.string.length)
	memcpy (dst, src->u.string.s, src->u.string.length);
      return (rc_uint_type) src->u.string.length;
    case RCDATA_WSTRING:
      if (dst && src->u.wstring.length)
	memcpy (dst, src->u.wstring.w, src->u.wstring.length * sizeof (unichar));
      return (rc_uint_type) (src->u.wstring.length  * sizeof (unichar));
    case RCDATA_BUFFER:
      if (dst && src->u.buffer.length)
	memcpy (dst, src->u.buffer.data, src->u.buffer.length);
      return (rc_uint_type) src->u.buffer.length;
    default:
      abort ();
    }
  /* Never reached.  */
  return 0;
}
@


1.41
log
@	PR binutils/13297
	* resrc.c (write_rc_dialog_control): Omit text dump for
	EDITTEXT, COMBOBOX, LISTBOX, and SCROLLBAR.
@
text
@d326 1
a326 1
      cpp_pipe = fopen (cpp_temp_file, FOPEN_RT);;
@


1.40
log
@	* sysdep.h: Include sys/stat.h here.
	* ar.c: Don't include headers already included by sysdep.h.
	* bucomm.c: Likewise.
	* budbg.h: Likewise.
	* dlltool.h: Likewise.
	* elfedit.c: Likewise.
	* nlmconv.c: Likewise.
	* objcopy.c: Likewise.
	* objdump.c: Likewise.
	* objdump.h: Likewise.
	* readelf.c: Likewise.
	* rename.c: Likewise.
	* resrc.c: Likewise.
	* strings.c: Likewise.
	* windres.c: Likewise.
	* od-macho.c: Ensure #include sysdep.h is first.
	* od-xcoff.c: Likewise.
	* dllwrap.c: Remove alloca pragma handled by sysdep.h, and
	remove duplicate headers.
	* dlltool.c: Likewise and ensure #include sysdep.h is first.
@
text
@d2653 7
a2659 1
  if (control->text.named || control->text.u.id != 0)
@


1.39
log
@2011-10-25  Kai Tietz  <ktietz@@redhat.com>

	* winduni.h (unicode_from_ascii_len): New prototype.
	* winduni.c (unicode_from_ascii_len): New function.
	* windres.h (define_stringtable): Add additional length argument.
	* windres.c (define_stringtable): Add length argument for string.
	* rcparse.y (res_unicode_sizedstring): New rule.
	(res_unicode_sizedstring_concat): Likewise.
	(string_data): Adjust rule.

2011-10-25  Kai Tietz  <ktietz@@redhat.com>

	* binutils-all/windres/strtab4.rc: New test.
	* binutils-all/windres/strtab4.rsd: Likewise.
@
text
@a34 5
#include <errno.h>
#include <sys/stat.h>
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
@


1.38
log
@	PR binutils/13051
	Fix a syntax error bug when compiling rc files with the VERSIONINFO resource
	containing more than one language block inside a single StringFileInfo block.

	* windint.h (rc_ver_stringtable): New structure definition.
	(rc_ver_info): Use it.
	* rcparse.y (verstringtable): New variable.
	(verstringtables): New type.
	(verstringtables:): New rule declaration.
	(verblocks:): Use it.
	* resrc.c (append_ver_stringtable): New function.
	(append_ver_stringfileinfo): Update to use stringtables.
	* windres.h (append_ver_stringfileinfo): Update declaration.
	(append_ver_stringtable): New declaration.
	* resrc.c (write_rc_versioninfo): Update to support multiple blocks.
	* resbin.c (bin_to_res_version): Likewise.
	(res_to_bin_versioninfo): Likewise.

	* binutils-all\windres\version.rsd: Regenerate.
	* binutils-all\windres\version_cat.rsd: Regenerate.
	* binutils-all\windres\version_mlang.rc: Add new test.
	* binutils-all\windres\version_mlang.rsd: Likewise.
@
text
@d1594 1
a1594 1
		    rc_uint_type stringid, const unichar *string)
d1596 1
d1620 6
a1625 3

  r->u.stringtable->strings[stringid & 0xf].length = unichar_len (string);
  r->u.stringtable->strings[stringid & 0xf].string = unichar_dup (string);
@


1.37
log
@	* ar.c (print_contents): Don't internationalize strings without words.
	* dwarf.c (process_extended_line_op): Likewise.
	(process_debug_info): Likwise.
	(display_debug_lines_raw): Likewise.
	(display_debug_lines_decoded): Likewise.
	(display_debug_abbrev): Likewise.
	* readelf.c (process_file_header): Likewise.
	(GET_OP): Likewise.
	(decode_arm_unwind): Likewise.
	(process_mips_specific): Likewise.
	* resrc.c (run_cmd): Likewise.
	(rcparse_warning): Likewise.
	* objdump.c (dump_headers): Don't print "Pg".
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2007, 2008
d1806 2
a1807 2
append_ver_stringfileinfo (rc_ver_info *verinfo, const char *language,
			   rc_ver_stringinfo *strings)
d1814 1
a1814 2
  unicode_from_ascii ((rc_uint_type *) NULL, &vi->u.string.language, language);
  vi->u.string.strings = strings;
d1823 19
d3285 1
a3289 4
	    fprintf (e, "    BLOCK ");
	    unicode_print_quoted (e, vi->u.string.language, -1);
	    fprintf (e, "\n");
	    fprintf (e, "    BEGIN\n");
d3291 1
a3291 1
	    for (vs = vi->u.string.strings; vs != NULL; vs = vs->next)
d3293 3
a3295 4
		fprintf (e, "      VALUE ");
		unicode_print_quoted (e, vs->key, -1);
		fprintf (e, ", ");
		unicode_print_quoted (e, vs->value, -1);
d3297 12
a3309 2

	    fprintf (e, "    END\n");
@


1.36
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d284 1
a284 1
      fatal (_("%s %s: %s"), errmsg_fmt, errmsg_arg, strerror (errno));
d631 1
a631 1
  fprintf (stderr, _("%s:%d: %s\n"), rc_filename, rc_lineno, msg);
@


1.36.2.1
log
@backport from mainline
@
text
@d284 1
a284 1
      fatal ("%s %s: %s", errmsg_fmt, errmsg_arg, strerror (errno));
d631 1
a631 1
  fprintf (stderr, "%s:%d: %s\n", rc_filename, rc_lineno, msg);
@


1.35
log
@Silence gcc printf warnings
@
text
@d1929 1
a1929 1
write_rc_file (const char *filename, const rc_res_directory *resources)
d1944 1
a1944 1
  write_rc_directory (e, resources, (const rc_res_id *) NULL,
@


1.34
log
@
2007-10-08  Carlos O'Donell  <carlos@@codesourcery.com>

	* resrc.c (read_rc_file): Rename e to edit, and c to dir.
	Pass dir to windres_add_include_dir.  Add comments.
	(close_input_stream): Check pclose error, and call fatal if
	the preprocessor failed.
	* windres.c (windres_add_include_dir): Assert that p is non-NULL,
	and not an empty string.
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005, 2007
d688 2
a689 1
  fatal (_("%s: read of %lu returned %lu"), msg, (long) c, (long) got);
d3065 1
a3065 1
				 (long) windres_get_32 (&wrtarget, data + i, length - i));
d3068 1
a3068 1
				(long) windres_get_32 (&wrtarget, data + i, length - i)) - 1;
d3214 1
a3214 1
	  fprintf (e, "  %lu, ", (long) offset + i);
@


1.33
log
@PR binutils/4987
* resrc.c: (read_rc_file): Move 'filename' default initialization to start of function.
@
text
@d444 1
a444 1
      char *e, *c;
d449 2
a450 1
	e = c = xstrdup (filename);
d453 3
a455 2
	  e = c = xmalloc (strlen (filename) + 3);
	  sprintf (c, "./%s", filename);
d457 4
a460 2
      e += strlen (c);
      while (e > c && (e[-1] != '\\' && e[-1] != '/'))
d462 2
a463 2
	  --e;
	  e[0] = 0;
d465 1
d467 6
a472 4
      --e;
      e[0] = 0;
      while ((e = strchr (c, '\\')) != NULL)
	*e = '/';
d474 1
a474 1
      windres_add_include_dir (e);
d598 13
a610 1
	pclose (cpp_pipe);
@


1.32
log
@Change sources over to using GPLv3
@
text
@d439 2
d442 1
a442 1
  if (strchr (filename, '/') != NULL || strchr (filename, '\\') != NULL)
a473 2
  if (filename == NULL)
    filename = "-";
@


1.31
log
@* resrc.c: (read_rc_file): Add include path of user passed rc input file.
* windres.c: (windres_add_include_dir): New.
  (main): Use of windres_add_include_dir.
* windres.h: (windres_add_include_dir): Add prototype.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
@


1.30
log
@PR binutils/4356 binutils/591
* resrc.c (filename_need_quotes): New function.
  (look_for_default): If filename_need_quotes is true then quote the filename in the command line being created.
  (read_rc_file): Likewise.
@
text
@d439 29
@


1.29
log
@Updated windres tool
@
text
@d354 27
a380 1
/* look for the preprocessor program */
d389 1
d420 2
a421 2
  sprintf (cmd + end_prefix, "%s %s %s",
	   DEFAULT_PREPROCESSOR, preprocargs, filename);
d437 1
d451 1
d453 2
a454 1
      sprintf (cmd, "%s %s %s", preprocessor, preprocargs, filename);
d468 1
@


1.28
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d5 1
d29 1
a31 1
#include "bucomm.h"
d35 1
d37 3
d92 1
a92 1
  unsigned char width;
d94 1
a94 1
  unsigned char height;
d96 1
a96 1
  unsigned char colorcount;
d130 1
a130 1
static FILE *cpp_pipe;
d143 1
a143 1
static struct res_directory *resources;
d155 1
a155 1
struct fontdir *fontdirs;
d159 1
a159 1
struct res_res_info fontdirs_resinfo;
d165 23
a187 1
/* Local functions.  */
d197 1
a197 1
static void get_data (FILE *, unsigned char *, unsigned long, const char *);
d405 1
a405 1
struct res_directory *
d467 1
a467 1
	  cpp_pipe = look_for_default (cmd, program_name, dash-program_name+1,
d471 1
a471 1
      if (slash && !cpp_pipe)
d476 1
a476 1
	  cpp_pipe = look_for_default (cmd, program_name, slash-program_name+1,
d480 1
a480 1
      if (!cpp_pipe)
a494 1
  yyin = cpp_pipe;
d601 1
a601 1
get_data (FILE *e, unsigned char *p, unsigned long c, const char *msg)
d603 1
a603 1
  unsigned long got;
d605 1
a605 1
  got = fread (p, 1, c, e);
d609 1
a609 1
  fatal (_("%s: read of %lu returned %lu"), msg, c, got);
d615 2
a616 2
define_accelerator (struct res_id id, const struct res_res_info *resinfo,
		    struct accelerator *data)
d618 1
a618 1
  struct res_resource *r;
d634 1
a634 1
define_bitmap (struct res_id id, const struct res_res_info *resinfo,
d640 3
a642 3
  unsigned char *data;
  int i;
  struct res_resource *r;
d650 1
a650 1
  data = (unsigned char *) res_alloc (s.st_size - BITMAP_SKIP);
d676 1
a676 1
define_cursor (struct res_id id, const struct res_res_info *resinfo,
d684 2
a685 2
  struct res_resource *r;
  struct group_cursor *first, **pp;
d725 3
a727 3
      unsigned char *data;
      struct res_id name;
      struct cursor *c;
d733 1
a733 1
      data = (unsigned char *) res_alloc (icondirs[i].bytes);
d737 1
a737 1
      c = (struct cursor *) res_alloc (sizeof *c);
d764 1
a764 1
      struct group_cursor *cg;
d766 1
a766 1
      cg = (struct group_cursor *) res_alloc (sizeof *cg);
d794 2
a795 2
define_dialog (struct res_id id, const struct res_res_info *resinfo,
	       const struct dialog *dialog)
d797 2
a798 2
  struct dialog *copy;
  struct res_resource *r;
d800 1
a800 1
  copy = (struct dialog *) res_alloc (sizeof *copy);
d813 5
a817 5
struct dialog_control *
define_control (const struct res_id iid, unsigned long id, unsigned long x,
		unsigned long y, unsigned long width, unsigned long height,
		unsigned long class, unsigned long style,
		unsigned long exstyle)
d819 1
a819 1
  struct dialog_control *n;
d821 1
a821 1
  n = (struct dialog_control *) res_alloc (sizeof *n);
d830 1
a830 2
  n->class.named = 0;
  n->class.u.id = class;
d838 9
a846 8
struct dialog_control *
define_icon_control (struct res_id iid, unsigned long id, unsigned long x,
		     unsigned long y, unsigned long style,
		     unsigned long exstyle, unsigned long help,
		     struct rcdata_item *data, struct dialog_ex *ex)
{
  struct dialog_control *n;
  struct res_id tid;
d851 3
a853 1
  n = define_control (tid, id, x, y, 0, 0, CTL_STATIC, style, exstyle);
d855 1
a855 1
  if (help && !ex)
d857 1
a857 1
  if (data && !ex)
d868 1
a868 1
define_font (struct res_id id, const struct res_res_info *resinfo,
d874 2
a875 2
  unsigned char *data;
  struct res_resource *r;
d878 2
a879 2
  unsigned char *fontdata;
  struct fontdir *fd;
d881 1
a881 1
  struct fontdir **pp;
d889 1
a889 1
  data = (unsigned char *) res_alloc (s.st_size);
d930 1
a930 1
  fontdata = (unsigned char *) res_alloc (fontdatalength);
d935 1
a935 1
  fd = (struct fontdir *) res_alloc (sizeof *fd);
d950 19
d975 2
a976 2
  struct res_resource *r;
  struct res_id id;
d988 83
d1078 1
a1078 1
define_icon (struct res_id id, const struct res_res_info *resinfo,
d1086 2
a1087 2
  struct res_resource *r;
  struct group_icon *first, **pp;
d1126 2
a1127 2
      unsigned char *data;
      struct res_id name;
d1133 1
a1133 1
      data = (unsigned char *) res_alloc (icondirs[i].bytes);
d1159 1
a1159 1
      struct group_icon *cg;
d1165 1
a1165 1
      cg = (struct group_icon *) res_alloc (sizeof *cg);
d1202 164
d1369 2
a1370 2
define_menu (struct res_id id, const struct res_res_info *resinfo,
	     struct menuitem *menuitems)
d1372 2
a1373 2
  struct menu *m;
  struct res_resource *r;
d1375 1
a1375 1
  m = (struct menu *) res_alloc (sizeof *m);
d1388 4
a1391 4
struct menuitem *
define_menuitem (const char *text, int menuid, unsigned long type,
		 unsigned long state, unsigned long help,
		 struct menuitem *menuitems)
d1393 1
a1393 1
  struct menuitem *mi;
d1395 1
a1395 1
  mi = (struct menuitem *) res_alloc (sizeof *mi);
d1400 1
a1400 4
  if (text == NULL)
    mi->text = NULL;
  else
    unicode_from_ascii ((int *) NULL, &mi->text, text);
d1409 1
a1409 1
define_messagetable (struct res_id id, const struct res_res_info *resinfo,
d1415 2
a1416 2
  unsigned char *data;
  struct res_resource *r;
d1425 1
a1425 1
  data = (unsigned char *) res_alloc (s.st_size);
d1444 2
a1445 2
define_rcdata (struct res_id id, const struct res_res_info *resinfo,
	       struct rcdata_item *data)
d1447 1
a1447 1
  struct res_resource *r;
d1458 2
a1459 2
struct rcdata_item *
define_rcdata_string (const char *string, unsigned long len)
d1461 1
a1461 1
  struct rcdata_item *ri;
d1464 1
a1464 1
  ri = (struct rcdata_item *) res_alloc (sizeof *ri);
d1475 19
d1496 2
a1497 2
struct rcdata_item *
define_rcdata_number (unsigned long val, int dword)
d1499 1
a1499 1
  struct rcdata_item *ri;
d1501 1
a1501 1
  ri = (struct rcdata_item *) res_alloc (sizeof *ri);
d1513 2
a1514 2
define_stringtable (const struct res_res_info *resinfo,
		    unsigned long stringid, const char *string)
d1516 2
a1517 2
  struct res_id id;
  struct res_resource *r;
d1529 2
a1530 2
      r->u.stringtable = ((struct stringtable *)
			  res_alloc (sizeof (struct stringtable)));
d1540 25
a1564 3
  unicode_from_ascii (&r->u.stringtable->strings[stringid & 0xf].length,
		      &r->u.stringtable->strings[stringid & 0xf].string,
		      string);
d1570 43
a1612 7
define_user_data (struct res_id id, struct res_id type,
		  const struct res_res_info *resinfo,
		  struct rcdata_item *data)
{
  struct res_id ids[3];
  struct res_resource *r;

d1620 7
a1626 1
  r->u.userdata = data;
d1631 1
a1631 1
define_rcdata_file (struct res_id id, const struct res_res_info *resinfo,
d1634 1
a1634 1
  struct rcdata_item *ri;
d1638 1
a1638 1
  unsigned char *data;
d1647 1
a1647 1
  data = (unsigned char *) res_alloc (s.st_size);
d1654 1
a1654 1
  ri = (struct rcdata_item *) res_alloc (sizeof *ri);
d1666 2
a1667 2
define_user_file (struct res_id id, struct res_id type,
		  const struct res_res_info *resinfo, const char *filename)
d1672 3
a1674 3
  unsigned char *data;
  struct res_id ids[3];
  struct res_resource *r;
d1682 1
a1682 1
  data = (unsigned char *) res_alloc (s.st_size);
d1696 2
a1697 2
  r->u.userdata = ((struct rcdata_item *)
		   res_alloc (sizeof (struct rcdata_item)));
d1708 3
a1710 3
define_versioninfo (struct res_id id, int language,
		    struct fixed_versioninfo *fixedverinfo,
		    struct ver_info *verinfo)
d1712 1
a1712 1
  struct res_resource *r;
d1716 2
a1717 2
  r->u.versioninfo = ((struct versioninfo *)
		      res_alloc (sizeof (struct versioninfo)));
d1725 3
a1727 3
struct ver_info *
append_ver_stringfileinfo (struct ver_info *verinfo, const char *language,
			   struct ver_stringinfo *strings)
d1729 1
a1729 1
  struct ver_info *vi, **pp;
d1731 1
a1731 1
  vi = (struct ver_info *) res_alloc (sizeof *vi);
d1734 1
a1734 1
  unicode_from_ascii ((int *) NULL, &vi->u.string.language, language);
d1746 3
a1748 3
struct ver_info *
append_ver_varfileinfo (struct ver_info *verinfo, const char *key,
			struct ver_varinfo *var)
d1750 1
a1750 1
  struct ver_info *vi, **pp;
d1752 1
a1752 1
  vi = (struct ver_info *) res_alloc (sizeof *vi);
d1755 1
a1755 1
  unicode_from_ascii ((int *) NULL, &vi->u.var.key, key);
d1767 3
a1769 3
struct ver_stringinfo *
append_verval (struct ver_stringinfo *strings, const char *key,
	       const char *value)
d1771 1
a1771 1
  struct ver_stringinfo *vs, **pp;
d1773 1
a1773 1
  vs = (struct ver_stringinfo *) res_alloc (sizeof *vs);
d1775 2
a1776 2
  unicode_from_ascii ((int *) NULL, &vs->key, key);
  unicode_from_ascii ((int *) NULL, &vs->value, value);
d1787 3
a1789 3
struct ver_varinfo *
append_vertrans (struct ver_varinfo *var, unsigned long language,
		 unsigned long charset)
d1791 1
a1791 1
  struct ver_varinfo *vv, **pp;
d1793 1
a1793 1
  vv = (struct ver_varinfo *) res_alloc (sizeof *vv);
d1808 22
a1829 23
static void write_rc_directory
  (FILE *, const struct res_directory *, const struct res_id *,
   const struct res_id *, int *, int);
static void write_rc_subdir
  (FILE *, const struct res_entry *, const struct res_id *,
   const struct res_id *, int *, int);
static void write_rc_resource
  (FILE *, const struct res_id *, const struct res_id *,
   const struct res_resource *, int *);
static void write_rc_accelerators (FILE *, const struct accelerator *);
static void write_rc_cursor (FILE *, const struct cursor *);
static void write_rc_group_cursor (FILE *, const struct group_cursor *);
static void write_rc_dialog (FILE *, const struct dialog *);
static void write_rc_dialog_control (FILE *, const struct dialog_control *);
static void write_rc_fontdir (FILE *, const struct fontdir *);
static void write_rc_group_icon (FILE *, const struct group_icon *);
static void write_rc_menu (FILE *, const struct menu *, int);
static void write_rc_menuitems (FILE *, const struct menuitem *, int, int);
static void write_rc_rcdata (FILE *, const struct rcdata_item *, int);
static void write_rc_stringtable
  (FILE *, const struct res_id *, const struct stringtable *);
static void write_rc_versioninfo (FILE *, const struct versioninfo *);
static void write_rc_filedata (FILE *, unsigned long, const unsigned char *);
d1844 3
a1846 7
   Actually, we don't use the format of an rc file, because it's way
   too much of a pain--for example, we'd have to write icon resources
   into a file and refer to that file.  We just generate a readable
   format that kind of looks like an rc file, and is useful for
   understanding the contents of a resource file.  Someday we may want
   to generate an rc file which the rc compiler can read; if that day
   comes, this code will have to be fixed up.  */
d1849 1
a1849 1
write_rc_file (const char *filename, const struct res_directory *resources)
d1852 1
a1852 1
  int language;
d1863 3
a1865 3
  language = -1;
  write_rc_directory (e, resources, (const struct res_id *) NULL,
		      (const struct res_id *) NULL, &language, 1);
d1875 3
a1877 3
write_rc_directory (FILE *e, const struct res_directory *rd,
		    const struct res_id *type, const struct res_id *name,
		    int *language, int level)
d1879 1
a1879 1
  const struct res_entry *re;
d1882 3
a1884 1

d1886 1
a1886 1
    fprintf (e, "// Time stamp: %lu\n", rd->time);
d1888 1
a1888 1
    fprintf (e, "// Characteristics: %lu\n", rd->characteristics);
d1890 2
a1891 1
    fprintf (e, "// Version: %d %d\n", rd->major, rd->minor);
d1918 1
a1918 1
	      fprintf (e, "LANGUAGE %lu, %lu\n",
d1944 2
a1945 2
	      fprintf (e, "// Resource at unexpected level %d\n", level);
	      write_rc_resource (e, type, (struct res_id *) NULL, re->u.res,
d1950 4
d1962 3
a1964 3
write_rc_subdir (FILE *e, const struct res_entry *re,
		 const struct res_id *type, const struct res_id *name,
		 int *language, int level)
d1970 1
a1970 1
      fprintf (e, "// Type: ");
d1998 2
a2007 1
      fprintf (e, "\n");
d2011 1
a2011 1
      fprintf (e, "// Name: ");
a2012 1
      fprintf (e, "\n");
d2016 1
a2016 1
      fprintf (e, "// Language: ");
a2017 1
      fprintf (e, "\n");
d2021 1
a2021 1
      fprintf (e, "// Level %d: ", level);
a2022 1
      fprintf (e, "\n");
d2035 3
a2037 3
write_rc_resource (FILE *e, const struct res_id *type,
		   const struct res_id *name, const struct res_resource *res,
		   int *language)
a2042 2
  fprintf (e, "\n");

d2049 1
a2049 1
      s = "ACCELERATOR";
d2054 1
a2054 1
      s = "BITMAP";
d2059 1
a2059 1
      s = "CURSOR";
d2064 1
a2064 1
      s = "GROUP_CURSOR";
d2077 1
a2077 1
      s = "FONT";
d2082 1
a2082 1
      s = "FONTDIR";
d2087 1
a2087 1
      s = "ICON";
d2092 1
a2092 1
      s = "GROUP_ICON";
d2111 1
a2111 1
      s = "MESSAGETABLE";
d2134 5
d2145 1
a2145 1
      fprintf (e, "// Unexpected resource type mismatch: ");
d2151 1
a2151 1
    fprintf (e, "// Code page: %lu\n", res->coff_info.codepage);
d2153 1
a2153 1
    fprintf (e, "// COFF reserved value: %lu\n", res->coff_info.reserved);
d2155 5
d2161 1
a2161 1
    res_id_print (e, *name, 0);
d2164 2
a2166 1
  fprintf (e, " ");
d2170 10
d2181 23
d2221 3
a2223 2
      fprintf (e, " %d, %d, %d, %d", res->u.dialog->x, res->u.dialog->y,
	       res->u.dialog->width, res->u.dialog->height);
d2226 6
a2231 1
	fprintf (e, ", %lu", res->u.dialog->ex->help);
d2260 2
a2261 2
		 res->res_info.language & ((1<<SUBLANG_SHIFT)-1),
		 (res->res_info.language >> SUBLANG_SHIFT) & 0xff);
d2263 1
a2263 1
	fprintf (e, "%sCHARACTERISTICS %lu\n",
d2265 1
a2265 1
		 res->res_info.characteristics);
d2267 1
a2267 1
	fprintf (e, "%sVERSION %lu\n",
d2269 1
a2269 1
		 res->res_info.version);
d2317 4
d2328 2
d2331 1
a2331 1
      write_rc_filedata (e, res->u.data.length, res->u.data.data);
d2339 1
a2339 1
write_rc_accelerators (FILE *e, const struct accelerator *accelerators)
d2341 1
a2341 1
  const struct accelerator *acc;
d2354 1
a2354 1
	  fprintf (e, "\"%c\"", acc->key);
d2359 1
a2359 1
	  fprintf (e, "%d", acc->key);
d2363 1
a2363 1
      fprintf (e, ", %d", acc->id);
d2390 1
a2390 1
write_rc_cursor (FILE *e, const struct cursor *cursor)
d2392 8
a2399 3
  fprintf (e, "// Hotspot: x: %d; y: %d\n", cursor->xhotspot,
	   cursor->yhotspot);
  write_rc_filedata (e, cursor->length, cursor->data);
d2406 1
a2406 1
write_rc_group_cursor (FILE *e, const struct group_cursor *group_cursor)
d2408 6
a2413 1
  const struct group_cursor *gc;
d2415 14
a2428 6
  for (gc = group_cursor; gc != NULL; gc = gc->next)
    {
      fprintf (e, "// width: %d; height %d; planes %d; bits %d\n",
	     gc->width, gc->height, gc->planes, gc->bits);
      fprintf (e, "// data bytes: %lu; index: %d\n",
	       gc->bytes, gc->index);
d2430 1
d2436 1
a2436 1
write_rc_dialog (FILE *e, const struct dialog *dialog)
d2438 1
a2438 1
  const struct dialog_control *control;
d2440 1
a2440 1
  fprintf (e, "STYLE 0x%lx\n", dialog->style);
d2443 1
a2443 1
    fprintf (e, "EXSTYLE 0x%lx\n", dialog->exstyle);
d2455 3
a2457 3
      fprintf (e, "CAPTION \"");
      unicode_print (e, dialog->caption, -1);
      fprintf (e, "\"\n");
d2470 2
a2471 3
      fprintf (e, "FONT %d, \"", dialog->pointsize);
      unicode_print (e, dialog->font, -1);
      fprintf (e, "\"");
d2477 3
a2479 1
		 dialog->ex->weight, dialog->ex->italic, dialog->ex->charset);
d2530 1
a2530 1
write_rc_dialog_control (FILE *e, const struct dialog_control *control)
d2551 1
d2553 2
d2563 1
a2563 1
  fprintf (e, " %d, ", control->id);
d2572 1
a2572 1
      fprintf (e, ", 0x%lx, ", control->style);
d2575 1
a2575 1
  fprintf (e, "%d, %d", control->x, control->y);
d2583 1
a2583 1
      fprintf (e, ", %d, %d", control->width, control->height);
d2588 2
a2589 1
      fprintf (e, ", 0x%lx", control->style);
d2592 2
a2593 1
	fprintf (e, ", 0x%lx, %lu", control->exstyle, control->help);
d2606 1
a2606 1
write_rc_fontdir (FILE *e, const struct fontdir *fontdir)
d2608 2
a2609 1
  const struct fontdir *fc;
d2611 13
a2623 4
  for (fc = fontdir; fc != NULL; fc = fc->next)
    {
      fprintf (e, "// Font index: %d\n", fc->index);
      write_rc_filedata (e, fc->length, fc->data);
d2625 1
d2632 1
a2632 1
write_rc_group_icon (FILE *e, const struct group_icon *group_icon)
d2634 2
a2635 1
  const struct group_icon *gi;
d2637 15
a2651 6
  for (gi = group_icon; gi != NULL; gi = gi->next)
    {
      fprintf (e, "// width: %d; height %d; colors: %d; planes %d; bits %d\n",
	       gi->width, gi->height, gi->colors, gi->planes, gi->bits);
      fprintf (e, "// data bytes: %lu; index: %d\n",
	       gi->bytes, gi->index);
d2653 1
d2659 1
a2659 1
write_rc_menu (FILE *e, const struct menu *menu, int menuex)
d2662 1
a2662 1
    fprintf (e, "// Help ID: %lu\n", menu->help);
d2666 20
d2689 1
a2689 1
write_rc_menuitems (FILE *e, const struct menuitem *menuitems, int menuex,
d2692 1
a2692 1
  const struct menuitem *mi;
d2720 2
a2721 3
	  fprintf (e, " \"");
	  unicode_print (e, mi->text, -1);
	  fprintf (e, "\"");
d2727 1
a2727 1
	    fprintf (e, ", %d", mi->id);
d2746 1
a2746 1
	      fprintf (e, ", %d", mi->id);
d2749 1
a2749 1
		  fprintf (e, ", %lu", mi->type);
d2752 1
a2752 1
		      fprintf (e, ", %lu", mi->state);
d2754 1
a2754 1
			fprintf (e, ", %lu", mi->help);
d2770 48
a2817 2
/* Write out an rcdata resource.  This is also used for other types of
   resources that need to print arbitrary data.  */
d2820 1
a2820 1
write_rc_rcdata (FILE *e, const struct rcdata_item *rcdata, int ind)
d2822 2
a2823 3
  const struct rcdata_item *ri;

  indent (e, ind);
d2826 1
a2826 6
  for (ri = rcdata; ri != NULL; ri = ri->next)
    {
      if (ri->type == RCDATA_BUFFER && ri->u.buffer.length == 0)
	continue;

      indent (e, ind + 2);
d2828 15
a2842 1
      switch (ri->type)
d2844 2
a2845 2
	default:
	  abort ();
d2847 9
a2855 2
	case RCDATA_WORD:
	  fprintf (e, "%d", ri->u.word);
d2857 34
d2892 2
a2893 3
	case RCDATA_DWORD:
	  fprintf (e, "%luL", ri->u.dword);
	  break;
d2895 1
a2895 1
	case RCDATA_STRING:
d2897 7
a2903 2
	    const char *s;
	    unsigned long i;
d2905 5
d2911 5
a2915 2
	    s = ri->u.string.s;
	    for (i = 0; i < ri->u.string.length; i++)
d2917 2
a2918 4
		if (ISPRINT (*s))
		  putc (*s, e);
		else
		  fprintf (e, "\\%03o", *s);
d2920 6
a2925 2
	    fprintf (e, "\"");
	    break;
d2927 6
d2934 2
a2935 1
	case RCDATA_WSTRING:
d2937 6
a2942 1
	  unicode_print (e, ri->u.wstring.w, ri->u.wstring.length);
d2944 3
a2946 1
	  break;
d2948 1
a2948 1
	case RCDATA_BUFFER:
d2950 10
a2959 2
	    unsigned long i;
	    int first;
d2961 2
a2962 1
	    /* Assume little endian data.  */
d2964 1
a2964 2
	    first = 1;
	    for (i = 0; i + 3 < ri->u.buffer.length; i += 4)
d2966 2
a2967 2
		unsigned long l;
		int j;
d2969 3
a2971 14
		if (! first)
		  indent (e, ind + 2);
		l = ((((((ri->u.buffer.data[i + 3] << 8)
			 | ri->u.buffer.data[i + 2]) << 8)
		       | ri->u.buffer.data[i + 1]) << 8)
		     | ri->u.buffer.data[i]);
		fprintf (e, "%luL", l);
		if (i + 4 < ri->u.buffer.length || ri->next != NULL)
		  fprintf (e, ",");
		for (j = 0; j < 4; ++j)
		  if (! ISPRINT (ri->u.buffer.data[i + j])
		      && ri->u.buffer.data[i + j] != 0)
		    break;
		if (j >= 4)
d2973 9
a2981 2
		    fprintf (e, "\t// ");
		    for (j = 0; j < 4; ++j)
d2983 3
a2985 2
			if (! ISPRINT (ri->u.buffer.data[i + j]))
			  fprintf (e, "\\%03o", ri->u.buffer.data[i + j]);
d2987 3
d2991 3
a2993 3
			    if (ri->u.buffer.data[i + j] == '\\')
			      fprintf (e, "\\");
			    fprintf (e, "%c", ri->u.buffer.data[i + j]);
d2996 5
d3006 1
a3006 1
	    if (i + 1 < ri->u.buffer.length)
a3007 3
		int s;
		int j;

d3009 4
a3012 10
		  indent (e, ind + 2);
		s = (ri->u.buffer.data[i + 1] << 8) | ri->u.buffer.data[i];
		fprintf (e, "%d", s);
		if (i + 2 < ri->u.buffer.length || ri->next != NULL)
		  fprintf (e, ",");
		for (j = 0; j < 2; ++j)
		  if (! ISPRINT (ri->u.buffer.data[i + j])
		      && ri->u.buffer.data[i + j] != 0)
		    break;
		if (j >= 2)
d3014 3
a3016 11
		    fprintf (e, "\t// ");
		    for (j = 0; j < 2; ++j)
		      {
			if (! ISPRINT (ri->u.buffer.data[i + j]))
			  fprintf (e, "\\%03o", ri->u.buffer.data[i + j]);
			else
			  {
			    if (ri->u.buffer.data[i + j] == '\\')
			      fprintf (e, "\\");
			    fprintf (e, "%c", ri->u.buffer.data[i + j]);
			  }
d3018 5
d3029 1
a3029 1
	    if (i < ri->u.buffer.length)
d3032 5
a3036 7
		  indent (e, ind + 2);
		if ((ri->u.buffer.data[i] & 0x7f) == ri->u.buffer.data[i]
		    && ISPRINT (ri->u.buffer.data[i]))
		  fprintf (e, "\"%c\"", ri->u.buffer.data[i]);
		else
		  fprintf (e, "\"\\%03o\"", ri->u.buffer.data[i]);
		if (ri->next != NULL)
d3041 20
d3062 33
a3095 1
	  }
d3113 2
a3114 2
write_rc_stringtable (FILE *e, const struct res_id *name,
		      const struct stringtable *stringtable)
d3116 1
a3116 1
  unsigned long offset;
d3123 1
a3123 1
      fprintf (e, "// %s string table name\n",
d3134 2
a3135 2
	  fprintf (e, "  %lu, \"", offset + i);
	  unicode_print (e, stringtable->strings[i].string,
d3137 1
a3137 1
	  fprintf (e, "\"\n");
d3147 1
a3147 1
write_rc_versioninfo (FILE *e, const struct versioninfo *versioninfo)
d3149 2
a3150 2
  const struct fixed_versioninfo *f;
  const struct ver_info *vi;
d3154 5
a3158 5
    fprintf (e, " FILEVERSION %lu, %lu, %lu, %lu\n",
	     (f->file_version_ms >> 16) & 0xffff,
	     f->file_version_ms & 0xffff,
	     (f->file_version_ls >> 16) & 0xffff,
	     f->file_version_ls & 0xffff);
d3160 5
a3164 5
    fprintf (e, " PRODUCTVERSION %lu, %lu, %lu, %lu\n",
	     (f->product_version_ms >> 16) & 0xffff,
	     f->product_version_ms & 0xffff,
	     (f->product_version_ls >> 16) & 0xffff,
	     f->product_version_ls & 0xffff);
d3166 1
a3166 1
    fprintf (e, " FILEFLAGSMASK 0x%lx\n", f->file_flags_mask);
d3168 1
a3168 1
    fprintf (e, " FILEFLAGS 0x%lx\n", f->file_flags);
d3170 1
a3170 1
    fprintf (e, " FILEOS 0x%lx\n", f->file_os);
d3172 1
a3172 1
    fprintf (e, " FILETYPE 0x%lx\n", f->file_type);
d3174 1
a3174 1
    fprintf (e, " FILESUBTYPE 0x%lx\n", f->file_subtype);
d3176 2
a3177 1
    fprintf (e, "// Date: %lu, %lu\n", f->file_date_ms, f->file_date_ls);
d3187 1
a3187 1
	    const struct ver_stringinfo *vs;
d3191 3
a3193 3
	    fprintf (e, "    BLOCK \"");
	    unicode_print (e, vi->u.string.language, -1);
	    fprintf (e, "\"\n");
d3198 5
a3202 5
		fprintf (e, "      VALUE \"");
		unicode_print (e, vs->key, -1);
		fprintf (e, "\", \"");
		unicode_print (e, vs->value, -1);
		fprintf (e, "\"\n");
d3212 1
a3212 1
	    const struct ver_varinfo *vv;
d3216 2
a3217 3
	    fprintf (e, "    VALUE \"");
	    unicode_print (e, vi->u.var.key, -1);
	    fprintf (e, "\"");
d3221 1
a3221 1
		       vv->charset);
d3233 2
a3234 4
/* Write out data which would normally be read from a file.  */

static void
write_rc_filedata (FILE *e, unsigned long length, const unsigned char *data)
d3236 26
a3261 22
  unsigned long i;

  for (i = 0; i + 15 < length; i += 16)
    {
      fprintf (e, "// %4lx: ", i);
      fprintf (e, "%02x %02x %02x %02x %02x %02x %02x %02x ",
	       data[i + 0], data[i + 1], data[i + 2], data[i + 3],
	       data[i + 4], data[i + 5], data[i + 6], data[i + 7]);
      fprintf (e, "%02x %02x %02x %02x %02x %02x %02x %02x\n",
	       data[i +  8], data[i +  9], data[i + 10], data[i + 11],
	       data[i + 12], data[i + 13], data[i + 14], data[i + 15]);
    }

  if (i < length)
    {
      fprintf (e, "// %4lx:", i);
      while (i < length)
	{
	  fprintf (e, " %02x", data[i]);
	  ++i;
	}
      fprintf (e, "\n");
d3263 2
@


1.27
log
@Update FSF address
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003, 2005
d26 1
a27 1
#include "bucomm.h"
d30 1
a33 1
#include <errno.h>
a34 3
#ifdef HAVE_UNISTD_H
#include <unistd.h>
#endif
@


1.26
log
@PR binutils/647
* rcparse.y (RCDATA): Allow a filename to be supplied as the parameter.
  Parse it with define_rcdata_file().
* resrc.c (define_rcdata_file): New function.
* windres.h: Provide a prototype for the new function.

* resrc.c (define_user_file): Fix typo by replacing "font file" with "file".
@
text
@d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.25
log
@	* ChangeLog: Fix typos.
	* ChangeLog-9197: Likewise.
	* ChangeLog-9899: Likewise.
	* NEWS: Likewise.
	* ar.c: Fix comment typos.
	* arsup.c: Likewise.
	* coffgrok.c: Likewise.
	* debug.c: Likewise.
	* debug.h: Likewise.
	* dlltool.c: Likewise.
	* ieee.c: Likewise.
	* nm.c: Likewise.
	* objdump.c: Likewise.
	* prdbg.c: Likewise.
	* readelf.c: Likewise.
	* resrc.c: Likewise.
	* sysinfo.y: Likewise.
	* windres.c: Likewise.
@
text
@d2 2
a3 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d861 1
a861 1
    fatal (_("stat failed on bitmap file `%s': %s"), real_filename,
d1253 1
a1253 1
  r = define_resource (&resources, 3, ids, 0);
d1259 33
d1305 1
a1305 1
  e = open_file_search (filename, FOPEN_RB, "font file", &real_filename);
d1308 1
a1308 1
    fatal (_("stat failed on bitmap file `%s': %s"), real_filename,
@


1.24
log
@* resrc.c (define_icon): Fix storage of color attributes 'planes' and 'bit
count' in icon groups.
@
text
@d254 1
a254 1
  /* Close reponse file.  */
@


1.23
log
@	* addr2line.c: Convert to ISO C90 prototypes, change PTR, remove
	unneeded (void *) casts.
	* ar.c: Likewise.
	* arlex.l: Likewise.
	* arparse.y: Likewise.
	* arsup.c: Likewise.
	* binemul.c: Likewise.
	* binemul.h: Likewise.
	* bucomm.c: Likewise.
	* bucomm.h: Likewise.
	* budbg.h: Likewise.
	* budemang.c: Likewise.
	* budemang.h: Likewise.
	* coffdump.c: Likewise.
	* coffgrok.c: Likewise.
	* cxxfilt.c: Likewise.
	* debug.c: Likewise.
	* debug.h: Likewise.
	* deflex.l: Likewise.
	* dlltool.c: Likewise.
	* dlltool.h: Likewise.
	* dllwrap.c: Likewise.
	* emul_aix.c: Likewise.
	* filemode.c: Likewise.
	* ieee.c: Likewise.
	* nlmconv.c: Likewise.
	* nlmconv.h: Likewise.
	* nlmheader.y: Likewise.
	* nm.c: Likewise.
	* prdbg.c: Likewise.
	* rclex.l: Likewise.
	* rcparse.y: Likewise.
	* rdcoff.c: Likewise.
	* rddbg.c: Likewise.
	* rename.c: Likewise.
	* resbin.c: Likewise.
	* rescoff.c: Likewise.
	* resrc.c: Likewise.
	* size.c: Likewise.
	* srconv.c: Likewise.
	* stabs.c: Likewise.
	* strings.c: Likewise.
	* sysdump.c: Likewise.
	* sysinfo.y: Likewise.
	* syslex.l: Likewise.
	* unwind-ia64.c: Likewise.
	* unwind-ia64.h: Likewise.
	* version.c: Likewise.
	* windres.c: Likewise.
	* windres.h: Likewise.
	* winduni.c: Likewise.
	* wrstabs.c: Likewise.
@
text
@d1043 14
a1056 4
      cg->planes = 1;
      cg->bits = 0;
      while ((1 << cg->bits) < cg->colors)
	++cg->bits;
@


1.22
log
@	* rcparse.y (res_text_field): New res_id variable.
	(res_null_text): New static const struct res_id object,
	with empty unicode name field.
	(control): Pop parsing of optresidc up one level. Set
	res_text_field to $2 except for controls which do not accept
	a text field.  Set res_text_field to res_null_text for the
	special cases (viz. COMBOBOX, EDITTEXT, LISTBOX, SCROLLBAR).
	(control_params): Adjust to use res_text_field rather
	than optresidc.
	(COMBOBOX): Add comment about discrepency between documented
	vs. observed default style.
	* resrc.c (define_control): Make first param const.
	* windres.h (define_control): Adjust prototype.

testsuite:

	* binutils-all/windres/checkbox.rc: New file.
	* binutils-all/windres/checkbox.rsd: New file.
	* binutils-all/windres/combobox.rc: New file.
	* binutils-all/windres/combobox.rsd: New file.
	* binutils-all/windres/edittext.rc: New file.
	* binutils-all/windres/edittext.rsd: New file.
	* binutils-all/windres/listbox.rc: New file.
	* binutils-all/windres/listbox.rsd: New file.
	* binutils-all/windres/scrollbar.rc: New file.
	* binutils-all/windres/scrollbar.rsd: New file.
@
text
@d164 10
a173 11
static int run_cmd PARAMS ((char *, const char *));
static FILE *open_input_stream PARAMS ((char *));
static FILE *look_for_default PARAMS ((char *, const char *, int,
				       const char *, const char *));
static void close_input_stream PARAMS ((void));
static void unexpected_eof PARAMS ((const char *));
static int get_word PARAMS ((FILE *, const char *));
static unsigned long get_long PARAMS ((FILE *, const char *));
static void get_data
  PARAMS ((FILE *, unsigned char *, unsigned long, const char *));
static void define_fontdirs PARAMS ((void));
d178 1
a178 3
run_cmd (cmd, redir)
     char *cmd;
     const char *redir;
d292 1
a292 2
open_input_stream (cmd)
     char *cmd;
d332 2
a333 6
look_for_default (cmd, prefix, end_prefix, preprocargs, filename)
     char *cmd;
     const char *prefix;
     int end_prefix;
     const char *preprocargs;
     const char *filename;
d381 2
a382 6
read_rc_file (filename, preprocessor, preprocargs, language, use_temp_file)
     const char *filename;
     const char *preprocessor;
     const char *preprocargs;
     int language;
     int use_temp_file;
d488 1
a488 1
close_input_stream ()
d518 1
a518 2
yyerror (msg)
     const char *msg;
d526 1
a526 2
rcparse_warning (msg)
     const char *msg;
d534 1
a534 2
unexpected_eof (msg)
     const char *msg;
d543 1
a543 3
get_word (e, msg)
     FILE *e;
     const char *msg;
d558 1
a558 3
get_long (e, msg)
     FILE *e;
     const char *msg;
d577 1
a577 5
get_data (e, p, c, msg)
     FILE *e;
     unsigned char *p;
     unsigned long c;
     const char *msg;
d591 2
a592 4
define_accelerator (id, resinfo, data)
     struct res_id id;
     const struct res_res_info *resinfo;
     struct accelerator *data;
d610 2
a611 4
define_bitmap (id, resinfo, filename)
     struct res_id id;
     const struct res_res_info *resinfo;
     const char *filename;
d652 2
a653 4
define_cursor (id, resinfo, filename)
     struct res_id id;
     const struct res_res_info *resinfo;
     const char *filename;
d770 2
a771 4
define_dialog (id, resinfo, dialog)
     struct res_id id;
     const struct res_res_info *resinfo;
     const struct dialog *dialog;
d790 4
a793 10
define_control (iid, id, x, y, width, height, class, style, exstyle)
     const struct res_id iid;
     unsigned long id;
     unsigned long x;
     unsigned long y;
     unsigned long width;
     unsigned long height;
     unsigned long class;
     unsigned long style;
     unsigned long exstyle;
d816 4
a819 10
define_icon_control (iid, id, x, y, style, exstyle, help, data, ex)
     struct res_id iid;
     unsigned long id;
     unsigned long x;
     unsigned long y;
     unsigned long style;
     unsigned long exstyle;
     unsigned long help;
     struct rcdata_item *data;
     struct dialog_ex *ex;
d842 2
a843 4
define_font (id, resinfo, filename)
     struct res_id id;
     const struct res_res_info *resinfo;
     const char *filename;
d928 1
a928 1
define_fontdirs ()
d950 2
a951 4
define_icon (id, resinfo, filename)
     struct res_id id;
     const struct res_res_info *resinfo;
     const char *filename;
d1067 2
a1068 4
define_menu (id, resinfo, menuitems)
     struct res_id id;
     const struct res_res_info *resinfo;
     struct menuitem *menuitems;
d1087 3
a1089 7
define_menuitem (text, menuid, type, state, help, menuitems)
     const char *text;
     int menuid;
     unsigned long type;
     unsigned long state;
     unsigned long help;
     struct menuitem *menuitems;
d1110 2
a1111 4
define_messagetable (id, resinfo, filename)
     struct res_id id;
     const struct res_res_info *resinfo;
     const char *filename;
d1145 2
a1146 4
define_rcdata (id, resinfo, data)
     struct res_id id;
     const struct res_res_info *resinfo;
     struct rcdata_item *data;
d1160 1
a1160 3
define_rcdata_string (string, len)
     const char *string;
     unsigned long len;
d1179 1
a1179 3
define_rcdata_number (val, dword)
     unsigned long val;
     int dword;
d1195 2
a1196 4
define_stringtable (resinfo, stringid, string)
     const struct res_res_info *resinfo;
     unsigned long stringid;
     const char *string;
d1230 3
a1232 5
define_user_data (id, type, resinfo, data)
     struct res_id id;
     struct res_id type;
     const struct res_res_info *resinfo;
     struct rcdata_item *data;
d1251 2
a1252 5
define_user_file (id, type, resinfo, filename)
     struct res_id id;
     struct res_id type;
     const struct res_res_info *resinfo;
     const char *filename;
d1293 3
a1295 5
define_versioninfo (id, language, fixedverinfo, verinfo)
     struct res_id id;
     int language;
     struct fixed_versioninfo *fixedverinfo;
     struct ver_info *verinfo;
d1311 2
a1312 4
append_ver_stringfileinfo (verinfo, language, strings)
     struct ver_info *verinfo;
     const char *language;
     struct ver_stringinfo *strings;
d1332 2
a1333 4
append_ver_varfileinfo (verinfo, key, var)
     struct ver_info *verinfo;
     const char *key;
     struct ver_varinfo *var;
d1353 2
a1354 4
append_verval (strings, key, value)
     struct ver_stringinfo *strings;
     const char *key;
     const char *value;
d1373 2
a1374 4
append_vertrans (var, language, charset)
     struct ver_varinfo *var;
     unsigned long language;
     unsigned long charset;
d1392 1
a1392 1
static void indent PARAMS ((FILE *, int));
d1394 2
a1395 2
  PARAMS ((FILE *, const struct res_directory *, const struct res_id *,
	   const struct res_id *, int *, int));
d1397 2
a1398 2
  PARAMS ((FILE *, const struct res_entry *, const struct res_id *,
	   const struct res_id *, int *, int));
d1400 12
a1411 16
  PARAMS ((FILE *, const struct res_id *, const struct res_id *,
	   const struct res_resource *, int *));
static void write_rc_accelerators
  PARAMS ((FILE *, const struct accelerator *));
static void write_rc_cursor PARAMS ((FILE *, const struct cursor *));
static void write_rc_group_cursor
  PARAMS ((FILE *, const struct group_cursor *));
static void write_rc_dialog PARAMS ((FILE *, const struct dialog *));
static void write_rc_dialog_control
  PARAMS ((FILE *, const struct dialog_control *));
static void write_rc_fontdir PARAMS ((FILE *, const struct fontdir *));
static void write_rc_group_icon PARAMS ((FILE *, const struct group_icon *));
static void write_rc_menu PARAMS ((FILE *, const struct menu *, int));
static void write_rc_menuitems
  PARAMS ((FILE *, const struct menuitem *, int, int));
static void write_rc_rcdata PARAMS ((FILE *, const struct rcdata_item *, int));
d1413 3
a1415 4
  PARAMS ((FILE *, const struct res_id *, const struct stringtable *));
static void write_rc_versioninfo PARAMS ((FILE *, const struct versioninfo *));
static void write_rc_filedata
  PARAMS ((FILE *, unsigned long, const unsigned char *));
d1420 1
a1420 3
indent (e, c)
     FILE *e;
     int c;
d1439 1
a1439 3
write_rc_file (filename, resources)
     const char *filename;
     const struct res_directory *resources;
d1465 3
a1467 7
write_rc_directory (e, rd, type, name, language, level)
     FILE *e;
     const struct res_directory *rd;
     const struct res_id *type;
     const struct res_id *name;
     int *language;
     int level;
d1545 3
a1547 7
write_rc_subdir (e, re, type, name, language, level)
     FILE *e;
     const struct res_entry *re;
     const struct res_id *type;
     const struct res_id *name;
     int *language;
     int level;
d1620 3
a1622 6
write_rc_resource (e, type, name, res, language)
     FILE *e;
     const struct res_id *type;
     const struct res_id *name;
     const struct res_resource *res;
     int *language;
d1870 1
a1870 3
write_rc_accelerators (e, accelerators)
     FILE *e;
     const struct accelerator *accelerators;
d1921 1
a1921 3
write_rc_cursor (e, cursor)
     FILE *e;
     const struct cursor *cursor;
d1932 1
a1932 3
write_rc_group_cursor (e, group_cursor)
     FILE *e;
     const struct group_cursor *group_cursor;
d1948 1
a1948 3
write_rc_dialog (e, dialog)
     FILE *e;
     const struct dialog *dialog;
d2041 1
a2041 3
write_rc_dialog_control (e, control)
     FILE *e;
     const struct dialog_control *control;
d2112 1
a2112 3
write_rc_fontdir (e, fontdir)
     FILE *e;
     const struct fontdir *fontdir;
d2127 1
a2127 3
write_rc_group_icon (e, group_icon)
     FILE *e;
     const struct group_icon *group_icon;
d2143 1
a2143 4
write_rc_menu (e, menu, menuex)
     FILE *e;
     const struct menu *menu;
     int menuex;
d2153 2
a2154 5
write_rc_menuitems (e, menuitems, menuex, ind)
     FILE *e;
     const struct menuitem *menuitems;
     int menuex;
     int ind;
d2239 1
a2239 4
write_rc_rcdata (e, rcdata, ind)
     FILE *e;
     const struct rcdata_item *rcdata;
     int ind;
d2404 2
a2405 4
write_rc_stringtable (e, name, stringtable)
     FILE *e;
     const struct res_id *name;
     const struct stringtable *stringtable;
d2438 1
a2438 3
write_rc_versioninfo (e, versioninfo)
     FILE *e;
     const struct versioninfo *versioninfo;
d2527 1
a2527 4
write_rc_filedata (e, length, data)
     FILE *e;
     unsigned long length;
     const unsigned char *data;
@


1.21
log
@Allow resource IDs to be strings or numbers.
Add a test for this.
@
text
@d822 1
a822 1
     struct res_id iid;
@


1.20
log
@	* rdcoff.c: Fix formatting.
	* rddbg.c: Likewise.
	* readelf.c: Likewise.
	* rename.c: Likewise.
	* resbin.c: Likewise.
	* resrc.c: Likewise.
	* resres.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d821 2
a822 2
define_control (text, id, x, y, width, height, class, style, exstyle)
     const char *text;
d845 1
a845 3
  if (text == NULL)
    text = "";
  res_string_to_id (&n->text, text);
d865 2
d869 2
a870 1
  n = define_control (0, id, x, y, 0, 0, CTL_STATIC, style, exstyle);
@


1.19
log
@	* rcparse.y: Remove newcmd rule.  Move rcparse_discard_strings
	call to rules that need no lookahead.  Check for no lookahead.

	* rclex.l (get_string): Correct "strings" list handling.
	* resrc.c (read_rc_file): Discard strings.
@
text
@d73 1
a73 1
 
d196 1
a196 1
  
d200 1
a200 1
  
d205 1
a205 1
  
d210 1
a210 1
      
d213 1
a213 1
      
d217 1
a217 1
      
d220 1
a220 1
      
d223 1
a223 1
      
d225 1
a225 1
      
d227 1
a227 1
        s++;
d240 2
a241 2
    fatal (_("can't open temporary file `%s': %s"), redir, 
           strerror (errno));
d268 1
a268 1
  
d283 1
a283 1
	  fatal (_("%s exited with status %d"), cmd, 
d290 1
a290 1
  
d312 1
a312 1
        fatal (_("can't open temporary file `%s': %s"), 
d314 1
a314 1
      
d316 1
a316 1
	fprintf (stderr, 
d324 1
a324 1
        fatal (_("can't popen `%s': %s"), cmd, strerror (errno));
d475 1
a475 1
  
d487 1
a487 1
  
d510 1
a510 1
	  
d1596 1
a1596 1
		       re->id.u.id & ((1 << SUBLANG_SHIFT) - 1), 
d1702 1
a1702 1
    }		
d2170 1
a2170 1
  
@


1.18
log
@Allow two to five parameter in FONT statement of DIALOGEX resources.
@
text
@d484 1
@


1.17
log
@Fix overlooked sublang shift bug.
Add testcase.
@
text
@d2090 5
a2094 2
	  && (dialog->ex->weight != 0 || dialog->ex->italic != 0))
	fprintf (e, ", %d, %d", dialog->ex->weight, dialog->ex->italic);
@


1.16
log
@Don't add default dialog style when explicit style specified.
Print style even if it is 0.
Add testcase.
@
text
@d1595 2
a1596 1
		       re->id.u.id & 0xff, (re->id.u.id >> 8) & 0xff);
@


1.15
log
@Apply patch from Bernd Herd to fix quoted class definitions inside dialogs.
@
text
@d134 1
a134 1
/* Input stream is either a file or a pipe. */
d2055 2
a2056 2
  if (dialog->style != 0)
    fprintf (e, "STYLE 0x%lx\n", dialog->style);
d2059 1
d2067 1
d2074 1
d2082 1
@


1.14
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d176 1
a176 1
/* Run `cmd' and redirect the output to `redir'. */
d521 1
a521 1
  /* Since this is also run via xatexit, safeguard. */
d1583 1
a1583 1
	     we are going to use in the rc printout. */
d2063 1
a2063 1
      res_id_print (e, dialog->class, 0);
@


1.14.2.1
log
@Merge from mainline
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d134 1
a134 1
/* Input stream is either a file or a pipe.  */
d176 1
a176 1
/* Run `cmd' and redirect the output to `redir'.  */
a483 1
  rcparse_discard_strings ();
d521 1
a521 1
  /* Since this is also run via xatexit, safeguard.  */
d1583 1
a1583 1
	     we are going to use in the rc printout.  */
d1595 1
a1595 2
		       re->id.u.id & ((1 << SUBLANG_SHIFT) - 1), 
		       (re->id.u.id >> SUBLANG_SHIFT) & 0xff);
d2055 2
a2056 2
  fprintf (e, "STYLE 0x%lx\n", dialog->style);

a2058 1

d2063 1
a2063 1
      res_id_print (e, dialog->class, 1);
a2065 1

a2071 1

a2078 1

d2085 2
a2086 5
	  && (dialog->ex->weight != 0
	      || dialog->ex->italic != 0
	      || dialog->ex->charset != 1))
	fprintf (e, ", %d, %d, %d",
		 dialog->ex->weight, dialog->ex->italic, dialog->ex->charset);
@


1.13
log
@* rcparse.y (styles): use SUBLANG_SHIFT instead of 8 (or the more
correct 10).
* resrc.c (write_rc_resource): Likewise.
* windres.h (SUBLANG_SHIFT): Define - as 10.
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
d28 1
a31 1
#include <ctype.h>
d1979 1
a1979 1
	  && isprint ((unsigned char) acc->key)
d2386 1
a2386 1
		if (isprint ((unsigned char) *s))
d2424 1
a2424 1
		  if (! isprint (ri->u.buffer.data[i + j])
d2432 1
a2432 1
			if (! isprint (ri->u.buffer.data[i + j]))
d2458 1
a2458 1
		  if (! isprint (ri->u.buffer.data[i + j])
d2466 1
a2466 1
			if (! isprint (ri->u.buffer.data[i + j]))
d2486 1
a2486 1
		    && isprint (ri->u.buffer.data[i]))
@


1.12
log
@Fix typos in ChangeLogs and update copyright notices
@
text
@d1892 2
a1893 2
		 res->res_info.language & 0xff,
		 (res->res_info.language >> 8) & 0xff);
@


1.11
log
@* resrc.c (close_input_stream): delete extraneous logic
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999 Free Software Foundation, Inc.
@


1.11.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
@


1.10
log
@* resrc.c: use "gcc -xc" instead of -xc-header
@
text
@a500 6
  if (cpp_pipe != NULL)
    {
      pclose (cpp_pipe);
      cpp_pipe = NULL;
    }
  
@


1.9
log
@* rcparse.y (control): ICON controls take an id as the first
parameter, not an optional string.  Also, call new convenience
function that takes res_id's.
* resrc.c (define_control): missing text means zero-length string,
not zero ID.
(define_icon_control): New.
* windres.h: declare define_icon_control.
@
text
@d81 1
a81 1
#define DEFAULT_PREPROCESSOR "gcc -E -xc-header -DRC_INVOKED"
@


1.8
log
@* resrc.c (close_input_stream): zero out cpp_pipe after closing it.
@
text
@d850 3
a852 7
  if (text != NULL)
    res_string_to_id (&n->text, text);
  else
    {
      n->text.named = 0;
      n->text.u.id = 0;
    }
d855 27
@


1.7
log
@* build fix

2000-02-18  Frank Ch. Eigler  <fche@@redhat.com>

	* resrc.c: Remove unmatched #if for cygwin.
@
text
@d502 4
a505 1
    pclose (cpp_pipe);
@


1.6
log
@Apply Mumit Khan's patch to allow temporary file for process interconnection
@
text
@a69 1
#if defined (_WIN32) && ! defined (__CYGWIN32__)
@


1.5
log
@	* resrc.c (write_rc_rcdata): Fix local variable shadowing
	problem.  If RCDATA_BUFFER data can be read as strings, modify
	code to print the strings as comments.
	* resres.c: Add casts to avoid warnings.
	(write_res_data, read_res_data): Don't put the program name in the
	error message; fatal already puts it there.
@
text
@d32 1
d34 35
d71 5
d130 9
d165 2
d169 1
a169 1
static void close_pipe PARAMS ((void));
d177 157
d355 5
a359 1
  if (strchr (cmd, '/'))
d370 1
a370 1
	    fprintf (stderr, "Tried `%s'\n", cmd);
d381 1
a381 1
    fprintf (stderr, "Using `%s'\n", cmd);
d383 1
a383 1
  cpp_pipe = popen (cmd, FOPEN_RT);
d390 1
a390 1
read_rc_file (filename, preprocessor, preprocargs, language)
d395 1
d399 2
d414 1
a414 1
      cpp_pipe = popen (cmd, FOPEN_RT);
d438 1
a438 1
#if defined(__DJGPP__) || defined (__CYGWIN__) || defined(__WIN32__)
d476 1
a476 2
  if (cpp_pipe == NULL)
    fatal (_("can't popen `%s': %s"), cmd, strerror (errno));
a478 2
  xatexit (close_pipe);

d486 2
a487 4
  if (pclose (cpp_pipe) != 0)
    fprintf (stderr, _("%s: warning: preprocessor failed\n"), program_name);
  cpp_pipe = NULL;

d497 1
a497 1
/* Close the pipe if it is open.  This is called via xatexit.  */
d499 2
a500 2
void
close_pipe ()
d504 24
d545 1
a545 1
  fprintf (stderr, "%s:%d: %s\n", rc_filename, rc_lineno, msg);
@


1.4
log
@1999-06-23  Mumit Khan  <khan@@xraylith.wisc.edu>
	* configure.in (HAVE_EXECUTABLE_SUFFIX): Define.
	* dlltool.c (look_for_prog): Use HAVE_EXECUTABLE_SUFFIX.
	* dllwrap.c (look_for_prog): Likewise.
	* resrc.c (look_for_default): Likewise.
	* configure, config.in: Rebuild.
@
text
@d2158 1
d2160 2
d2166 8
a2173 3
		if (first)
		  first = 0;
		else
d2175 12
a2186 2
		    fprintf (e, ",\n");
		    indent (e, ind + 2);
d2188 2
a2189 1
		fprintf (e, "%luL", l);
d2194 2
a2195 1
		int i;
d2197 11
a2207 4
		i = (ri->u.buffer.data[i + 1] << 8) | ri->u.buffer.data[i];
		if (first)
		  first = 0;
		else
d2209 12
a2220 2
		    fprintf (e, ",\n");
		    indent (e, ind + 2);
d2222 1
a2222 1
		fprintf (e, "%d", i);
d2224 1
d2229 2
a2230 7
		if (first)
		  first = 0;
		else
		  {
		    fprintf (e, ",\n");
		    indent (e, ind + 2);
		  }
d2235 5
a2239 1
		  fprintf (e, "\"\%03o\"", ri->u.buffer.data[i]);
d2246 6
a2251 3
      if (ri->next != NULL)
	fprintf (e, ",");
      fprintf (e, "\n");
@


1.3
log
@	Based on patches from Mumit Khan <khan@@xraylith.wisc.EDU>:
	* configure.in: Define EXECUTABLE_SUFFIX.
	* dlltool.c: Include "dyn-string.h".  Include <stdarg.h> based on
	ANSI_PROTOTYPES, not __STDC__.
	(outfile): Remove.
	(gen_exp_file): Change uses of outfile to use alloca.
	(make_one_lib_file, make_head, make_tail): Likewise.
	(gen_lib_file): Likewise.
	(look_for_prog): New static function.
	(deduce_name): Rewrite to use look_for_prog.
	(mcore_elf_gen_out_file): Use dyn_string_t rather than outfile.
	* dllwrap.c: Don't include <stdio.h>, <errno.h>, <string.h>,
	<stdlib.h>, or <unistd.h>.  Include <sys/stat.h> and either
	<stdarg.h> or <varargs.h>.
	(driver_name): Initialize to NULL, not "gcc".
	(dlltool_name): Initialize to NULL, not "dlltool".
	(display, inform, look_for_prog, deduce_name): New static
	functions.
	(usage): Mention -mno-cygwin.
	(OPTION_MNO_CYGWIN): Define.
	(main): Handle -mno-cygwin.  Deduce driver_name and dlltool_name.
	* resrc.c (look_for_default): Make static.  Remove unused local
	path.  Check using EXECUTABLE_SUFFIX.
	(read_rc_file): Allocate enough space to hold EXECUTABLE_SUFFIX.
	* Makefile.am: Rebuild dependencies.
	(dllwrap_LDADD): Add $(INTLLIBS).
	* configure, Makefile.in, config.in: Rebuild.
@
text
@d149 1
a149 1
#ifdef EXECUTABLE_SUFFIX
d210 1
a210 1
#ifdef EXECUTABLE_SUFFIX
@


1.2
log
@* windres.c: add verbose option
(main): process verbose option
* resrc.c (look_for_default): new.  Look for the default
preprocessor in a given location.
(read_rc_file): for foo/bar-windres, look for foo/bar-gcc,
foo/gcc (in case of foo/windres), and then gcc (the old default).
@
text
@d2 1
a2 1
   Copyright 1997, 1998 Free Software Foundation, Inc.
d115 2
d127 1
a127 1
FILE *
d130 1
a130 1
     char *prefix;
d132 2
a133 2
     char *preprocargs;
     char *filename;
a134 1
  char *path = getenv ("PATH");
d141 2
a142 2
  sprintf (cmd+end_prefix, "%s", DEFAULT_PREPROCESSOR);
  space = strchr (cmd+end_prefix, ' ');
d148 5
a152 1
      found = stat (cmd, &s);
d154 1
a154 1
      if (found < 0)
d158 1
a158 1
	  return 0;
d164 1
a164 1
  sprintf (cmd+end_prefix, "%s %s %s",
d210 3
d217 1
a217 1
      for (cp=program_name; *cp; cp++)
@


1.1
log
@Initial revision
@
text
@d123 46
a179 3
  if (preprocessor == NULL)
    preprocessor = DEFAULT_PREPROCESSOR;

d185 7
a191 5
  cmd = xmalloc (strlen (preprocessor)
		 + strlen (preprocargs)
		 + strlen (filename)
		 + 10);
  sprintf (cmd, "%s %s %s", preprocessor, preprocargs, filename);
d193 59
a251 1
  cpp_pipe = popen (cmd, FOPEN_RT);
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

