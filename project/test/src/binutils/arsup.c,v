head	1.22;
access;
symbols
	binutils-2_24-branch:1.21.0.12
	binutils-2_24-branchpoint:1.21
	binutils-2_21_1:1.21
	binutils-2_23_2:1.21
	binutils-2_23_1:1.21
	binutils-2_23:1.21
	binutils-2_23-branch:1.21.0.10
	binutils-2_23-branchpoint:1.21
	binutils-2_22_branch:1.21.0.8
	binutils-2_22:1.21
	binutils-2_22-branch:1.21.0.6
	binutils-2_22-branchpoint:1.21
	binutils-2_21:1.21
	binutils-2_21-branch:1.21.0.4
	binutils-2_21-branchpoint:1.21
	binutils-2_20_1:1.21
	binutils-2_20:1.21
	binutils-arc-20081103-branch:1.20.0.8
	binutils-arc-20081103-branchpoint:1.20
	binutils-2_20-branch:1.21.0.2
	binutils-2_20-branchpoint:1.21
	dje-cgen-play1-branch:1.20.0.6
	dje-cgen-play1-branchpoint:1.20
	arc-20081103-branch:1.20.0.4
	arc-20081103-branchpoint:1.20
	binutils-2_19_1:1.20
	binutils-2_19:1.20
	binutils-2_19-branch:1.20.0.2
	binutils-2_19-branchpoint:1.20
	binutils-2_18:1.19
	binutils-2_18-branch:1.19.0.2
	binutils-2_18-branchpoint:1.19
	binutils-csl-coldfire-4_1-32:1.16
	binutils-csl-sourcerygxx-4_1-32:1.16
	binutils-csl-innovasic-fido-3_4_4-33:1.16
	binutils-csl-sourcerygxx-3_4_4-32:1.14
	binutils-csl-coldfire-4_1-30:1.16
	binutils-csl-sourcerygxx-4_1-30:1.16
	binutils-csl-coldfire-4_1-28:1.16
	binutils-csl-sourcerygxx-4_1-29:1.16
	binutils-csl-sourcerygxx-4_1-28:1.16
	binutils-csl-arm-2006q3-27:1.16
	binutils-csl-sourcerygxx-4_1-27:1.16
	binutils-csl-arm-2006q3-26:1.16
	binutils-csl-sourcerygxx-4_1-26:1.16
	binutils-csl-sourcerygxx-4_1-25:1.16
	binutils-csl-sourcerygxx-4_1-24:1.16
	binutils-csl-sourcerygxx-4_1-23:1.16
	binutils-csl-sourcerygxx-4_1-21:1.16
	binutils-csl-arm-2006q3-21:1.16
	binutils-csl-sourcerygxx-4_1-22:1.16
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.16
	binutils-csl-sourcerygxx-4_1-20:1.16
	binutils-csl-arm-2006q3-19:1.16
	binutils-csl-sourcerygxx-4_1-19:1.16
	binutils-csl-sourcerygxx-4_1-18:1.16
	binutils-csl-renesas-4_1-9:1.16
	binutils-csl-sourcerygxx-3_4_4-25:1.14
	binutils-csl-renesas-4_1-8:1.16
	binutils-csl-renesas-4_1-7:1.16
	binutils-csl-renesas-4_1-6:1.16
	binutils-csl-sourcerygxx-4_1-17:1.16
	binutils-csl-sourcerygxx-4_1-14:1.16
	binutils-csl-sourcerygxx-4_1-15:1.16
	binutils-csl-sourcerygxx-4_1-13:1.16
	binutils-2_17:1.16
	binutils-csl-sourcerygxx-4_1-12:1.16
	binutils-csl-sourcerygxx-3_4_4-21:1.16
	binutils-csl-wrs-linux-3_4_4-24:1.14
	binutils-csl-wrs-linux-3_4_4-23:1.14
	binutils-csl-sourcerygxx-4_1-9:1.16
	binutils-csl-sourcerygxx-4_1-8:1.16
	binutils-csl-sourcerygxx-4_1-7:1.16
	binutils-csl-arm-2006q1-6:1.16
	binutils-csl-sourcerygxx-4_1-6:1.16
	binutils-csl-wrs-linux-3_4_4-22:1.14
	binutils-csl-coldfire-4_1-11:1.16
	binutils-csl-sourcerygxx-3_4_4-19:1.16
	binutils-csl-coldfire-4_1-10:1.16
	binutils-csl-sourcerygxx-4_1-5:1.16
	binutils-csl-sourcerygxx-4_1-4:1.16
	binutils-csl-wrs-linux-3_4_4-21:1.14
	binutils-csl-morpho-4_1-4:1.16
	binutils-csl-sourcerygxx-3_4_4-17:1.16
	binutils-csl-wrs-linux-3_4_4-20:1.14
	binutils-2_17-branch:1.16.0.4
	binutils-2_17-branchpoint:1.16
	binutils-csl-2_17-branch:1.16.0.2
	binutils-csl-2_17-branchpoint:1.16
	binutils-csl-gxxpro-3_4-branch:1.14.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.14
	binutils-2_16_1:1.14
	binutils-csl-arm-2005q1b:1.14
	binutils-2_16:1.14
	binutils-csl-arm-2005q1a:1.14
	binutils-csl-arm-2005q1-branch:1.14.0.4
	binutils-csl-arm-2005q1-branchpoint:1.14
	binutils-2_16-branch:1.14.0.2
	binutils-2_16-branchpoint:1.14
	csl-arm-2004-q3d:1.13
	csl-arm-2004-q3:1.13
	binutils-2_15:1.12.2.1
	binutils-2_15-branchpoint:1.12
	csl-arm-2004-q1a:1.13
	csl-arm-2004-q1:1.13
	binutils-2_15-branch:1.12.0.2
	cagney_bfdfile-20040213-branch:1.11.0.4
	cagney_bfdfile-20040213-branchpoint:1.11
	cagney_bigcore-20040122-branch:1.11.0.2
	cagney_bigcore-20040122-branchpoint:1.11
	csl-arm-2003-q4:1.11
	binutils-2_14:1.9
	binutils-2_14-branch:1.9.0.2
	binutils-2_14-branchpoint:1.9
	binutils-2_13_2_1:1.8
	binutils-2_13_2:1.8
	binutils-2_13_1:1.8
	binutils-2_13:1.8
	binutils-2_13-branchpoint:1.8
	binutils-2_13-branch:1.8.0.2
	binutils-2_12_1:1.5
	binutils-2_12:1.5
	binutils-2_12-branch:1.5.0.2
	binutils-2_12-branchpoint:1.5
	cygnus_cvs_20020108_pre:1.5
	binutils-2_11_2:1.3.2.1
	binutils-2_11_1:1.3.2.1
	binutils-2_11:1.3
	x86_64versiong3:1.3
	binutils-2_11-branch:1.3.0.2
	binutils-2_10_1:1.2.2.1
	binutils-2_10:1.2.2.1
	binutils-2_10-branch:1.2.0.2
	binutils-2_10-branchpoint:1.2
	binutils_latest_snapshot:1.22
	repo-unification-2000-02-06:1.2
	binu_ss_19990721:1.2
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.22
date	2013.10.01.13.44.37;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2009.09.02.07.22.31;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2008.03.28.06.49.44;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2007.07.05.16.54.45;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2007.06.27.11.54.09;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2007.04.26.14.46.59;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.08.14.17.38;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2005.04.29.00.03.32;	author bje;	state Exp;
branches;
next	1.14;

1.14
date	2005.03.03.11.46.12;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2004.04.07.05.11.24;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2004.02.15.02.24.53;	author cagney;	state Exp;
branches
	1.12.2.1;
next	1.11;

1.11
date	2003.10.27.13.20.32;	author kazu;	state Exp;
branches;
next	1.10;

1.10
date	2003.09.14.12.20.16;	author aj;	state Exp;
branches;
next	1.9;

1.9
date	2002.11.30.08.39.41;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2002.05.27.15.46.09;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2002.05.26.14.55.04;	author kazu;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.19.16.17.54;	author kazu;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.05.16.20.37;	author jakub;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.13.06.43.57;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.26.13.11.55;	author amodra;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	99.07.11.20.02.16;	author ian;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	99.05.03.07.29.09;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.12.2.1
date	2004.04.09.18.28.06;	author drow;	state Exp;
branches;
next	;

1.3.2.1
date	2001.06.07.03.12.27;	author amodra;	state Exp;
branches;
next	;

1.2.2.1
date	2000.05.28.10.57.50;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.09;	author rth;	state Exp;
branches;
next	;


desc
@@


1.22
log
@	* arsup.c (ar_save): Respect the deterministic setting when
	reading from an mri script.
	* ar.c (main): Set the default deterministic mode when reading
	from an mri script.
@
text
@/* arsup.c - Archive support for MRI compatibility
   Copyright 1992-2013 2008 Free Software Foundation, Inc.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */


/* Contributed by Steve Chamberlain
   sac@@cygnus.com

   This file looks after requests from arparse.y, to provide the MRI
   style librarian command syntax + 1 word LIST.  */

#include "sysdep.h"
#include "bfd.h"
#include "libiberty.h"
#include "filenames.h"
#include "bucomm.h"
#include "arsup.h"

static void map_over_list
  (bfd *, void (*function) (bfd *, bfd *), struct list *);
static void ar_directory_doer (bfd *, bfd *);
static void ar_addlib_doer (bfd *, bfd *);

extern int verbose;
extern int deterministic;

static bfd *obfd;
static char *real_name;
static FILE *outfile;

static void
map_over_list (bfd *arch, void (*function) (bfd *, bfd *), struct list *list)
{
  bfd *head;

  if (list == NULL)
    {
      bfd *next;

      head = arch->archive_next;
      while (head != NULL)
	{
	  next = head->archive_next;
	  function (head, (bfd *) NULL);
	  head = next;
	}
    }
  else
    {
      struct list *ptr;

      /* This may appear to be a baroque way of accomplishing what we
	 want.  however we have to iterate over the filenames in order
	 to notice where a filename is requested but does not exist in
	 the archive.  Ditto mapping over each file each time -- we
	 want to hack multiple references.  */
      for (ptr = list; ptr; ptr = ptr->next)
	{
	  bfd_boolean found = FALSE;
	  bfd *prev = arch;

	  for (head = arch->archive_next; head; head = head->archive_next)
	    {
	      if (head->filename != NULL
		  && FILENAME_CMP (ptr->name, head->filename) == 0)
		{
		  found = TRUE;
		  function (head, prev);
		}
	      prev = head;
	    }
	  if (! found)
	    fprintf (stderr, _("No entry %s in archive.\n"), ptr->name);
	}
    }
}



static void
ar_directory_doer (bfd *abfd, bfd *ignore ATTRIBUTE_UNUSED)
{
  print_arelt_descr(outfile, abfd, verbose);
}

void
ar_directory (char *ar_name, struct list *list, char *output)
{
  bfd *arch;

  arch = open_inarch (ar_name, (char *) NULL);
  if (output)
    {
      outfile = fopen(output,"w");
      if (outfile == 0)
	{
	  outfile = stdout;
	  fprintf (stderr,_("Can't open file %s\n"), output);
	  output = 0;
	}
    }
  else
    outfile = stdout;

  map_over_list (arch, ar_directory_doer, list);

  bfd_close (arch);

  if (output)
   fclose (outfile);
}

void
prompt (void)
{
  extern int interactive;

  if (interactive)
    {
      printf ("AR >");
      fflush (stdout);
    }
}

void
maybequit (void)
{
  if (! interactive)
    xexit (9);
}


void
ar_open (char *name, int t)
{
  char *tname = (char *) xmalloc (strlen (name) + 10);
  const char *bname = lbasename (name);
  real_name = name;

  /* Prepend tmp- to the beginning, to avoid file-name clashes after
     truncation on filesystems with limited namespaces (DOS).  */
  sprintf (tname, "%.*stmp-%s", (int) (bname - name), name, bname);
  obfd = bfd_openw (tname, NULL);

  if (!obfd)
    {
      fprintf (stderr,
	       _("%s: Can't open output archive %s\n"),
	       program_name,  tname);

      maybequit ();
    }
  else
    {
      if (!t)
	{
	  bfd **ptr;
	  bfd *element;
	  bfd *ibfd;

	  ibfd = bfd_openr (name, NULL);

	  if (!ibfd)
	    {
	      fprintf (stderr,_("%s: Can't open input archive %s\n"),
		       program_name, name);
	      maybequit ();
	      return;
	    }

	  if (!bfd_check_format(ibfd, bfd_archive))
	    {
	      fprintf (stderr,
		       _("%s: file %s is not an archive\n"),
		       program_name, name);
	      maybequit ();
	      return;
	    }

	  ptr = &(obfd->archive_head);
	  element = bfd_openr_next_archived_file (ibfd, NULL);

	  while (element)
	    {
	      *ptr = element;
	      ptr = &element->archive_next;
	      element = bfd_openr_next_archived_file (ibfd, element);
	    }
	}

      bfd_set_format (obfd, bfd_archive);

      obfd->has_armap = 1;
      obfd->is_thin_archive = 0;
    }
}

static void
ar_addlib_doer (bfd *abfd, bfd *prev)
{
  /* Add this module to the output bfd.  */
  if (prev != NULL)
    prev->archive_next = abfd->archive_next;

  abfd->archive_next = obfd->archive_head;
  obfd->archive_head = abfd;
}

void
ar_addlib (char *name, struct list *list)
{
  if (obfd == NULL)
    {
      fprintf (stderr, _("%s: no output archive specified yet\n"), program_name);
      maybequit ();
    }
  else
    {
      bfd *arch;

      arch = open_inarch (name, (char *) NULL);
      if (arch != NULL)
	map_over_list (arch, ar_addlib_doer, list);

      /* Don't close the bfd, since it will make the elements disappear.  */
    }
}

void
ar_addmod (struct list *list)
{
  if (!obfd)
    {
      fprintf (stderr, _("%s: no open output archive\n"), program_name);
      maybequit ();
    }
  else
    {
      while (list)
	{
	  bfd *abfd = bfd_openr (list->name, NULL);

	  if (!abfd)
	    {
	      fprintf (stderr, _("%s: can't open file %s\n"),
		       program_name, list->name);
	      maybequit ();
	    }
	  else
	    {
	      abfd->archive_next = obfd->archive_head;
	      obfd->archive_head = abfd;
	    }
	  list = list->next;
	}
    }
}


void
ar_clear (void)
{
  if (obfd)
    obfd->archive_head = 0;
}

void
ar_delete (struct list *list)
{
  if (!obfd)
    {
      fprintf (stderr, _("%s: no open output archive\n"), program_name);
      maybequit ();
    }
  else
    {
      while (list)
	{
	  /* Find this name in the archive.  */
	  bfd *member = obfd->archive_head;
	  bfd **prev = &(obfd->archive_head);
	  int found = 0;

	  while (member)
	    {
	      if (FILENAME_CMP(member->filename, list->name) == 0)
		{
		  *prev = member->archive_next;
		  found = 1;
		}
	      else
		prev = &(member->archive_next);

	      member = member->archive_next;
	    }

	  if (!found)
	    {
	      fprintf (stderr, _("%s: can't find module file %s\n"),
		       program_name, list->name);
	      maybequit ();
	    }

	  list = list->next;
	}
    }
}

void
ar_save (void)
{
  if (!obfd)
    {
      fprintf (stderr, _("%s: no open output archive\n"), program_name);
      maybequit ();
    }
  else
    {
      char *ofilename = xstrdup (bfd_get_filename (obfd));

      if (deterministic > 0)
        obfd->flags |= BFD_DETERMINISTIC_OUTPUT;

      bfd_close (obfd);

      smart_rename (ofilename, real_name, 0);
      obfd = 0;
      free (ofilename);
    }
}

void
ar_replace (struct list *list)
{
  if (!obfd)
    {
      fprintf (stderr, _("%s: no open output archive\n"), program_name);
      maybequit ();
    }
  else
    {
      while (list)
	{
	  /* Find this name in the archive.  */
	  bfd *member = obfd->archive_head;
	  bfd **prev = &(obfd->archive_head);
	  int found = 0;

	  while (member)
	    {
	      if (FILENAME_CMP (member->filename, list->name) == 0)
		{
		  /* Found the one to replace.  */
		  bfd *abfd = bfd_openr (list->name, 0);

		  if (!abfd)
		    {
		      fprintf (stderr, _("%s: can't open file %s\n"),
			       program_name, list->name);
		      maybequit ();
		    }
		  else
		    {
		      *prev = abfd;
		      abfd->archive_next = member->archive_next;
		      found = 1;
		    }
		}
	      else
		{
		  prev = &(member->archive_next);
		}
	      member = member->archive_next;
	    }

	  if (!found)
	    {
	      bfd *abfd = bfd_openr (list->name, 0);

	      fprintf (stderr,_("%s: can't find module file %s\n"),
		       program_name, list->name);
	      if (!abfd)
		{
		  fprintf (stderr, _("%s: can't open file %s\n"),
			   program_name, list->name);
		  maybequit ();
		}
	      else
		*prev = abfd;
	    }

	  list = list->next;
	}
    }
}

/* And I added this one.  */
void
ar_list (void)
{
  if (!obfd)
    {
      fprintf (stderr, _("%s: no open output archive\n"), program_name);
      maybequit ();
    }
  else
    {
      bfd *abfd;

      outfile = stdout;
      verbose =1 ;
      printf (_("Current open archive is %s\n"), bfd_get_filename (obfd));

      for (abfd = obfd->archive_head;
	   abfd != (bfd *)NULL;
	   abfd = abfd->archive_next)
	ar_directory_doer (abfd, (bfd *) NULL);
    }
}

void
ar_end (void)
{
  if (obfd)
    {
      bfd_cache_close (obfd);
      unlink (bfd_get_filename (obfd));
    }
}

void
ar_extract (struct list *list)
{
  if (!obfd)
    {
      fprintf (stderr, _("%s: no open archive\n"), program_name);
      maybequit ();
    }
  else
    {
      while (list)
	{
	  /* Find this name in the archive.  */
	  bfd *member = obfd->archive_head;
	  int found = 0;

	  while (member && !found)
	    {
	      if (FILENAME_CMP (member->filename, list->name) == 0)
		{
		  extract_file (member);
		  found = 1;
		}

	      member = member->archive_next;
	    }

	  if (!found)
	    {
	      bfd_openr (list->name, 0);
	      fprintf (stderr, _("%s: can't find module file %s\n"),
		       program_name, list->name);
	    }

	  list = list->next;
	}
    }
}
@


1.21
log
@update copyright dates
@
text
@d2 1
a2 2
   Copyright 1992, 1994, 1995, 1996, 1997, 1999, 2000, 2001, 2002, 2003,
   2004, 2005, 2007, 2008 Free Software Foundation, Inc.
d41 1
d337 3
@


1.20
log
@Add support for thin archives.
    * bfd/archive.c (_bfd_find_nested_archive): New function.
    (get_extended_arelt_filename): Add origin parameter.
    (_bfd_generic_read_ar_hdr_mag): Deal with extended name
    combined with a file offset.
    (append_relative_path): New function.
    (_bfd_get_elt_at_filepos): Deal with external members and
    nested archives.
    (bfd_generic_openr_next_archived_file): Thin archives.
    (bfd_generic_archive_p): Recognize new magic string.
    (adjust_relative_path): New function.
    (_bfd_construct_extended_name_table): Construct extended
    names for thin archive members.
    (_bfd_write_archive_contents): Emit new magic string, skip
    copying files for thin archives.
    * bfd/bfd-in.h (bfd_is_thin_archive): New macro.
    * bfd/bfd.c (struct bfd): New fields for thin archives.
    * bfd/libbfd-in.h (struct areltdata): New field for thin archives.
    * bfd/opncls.c (bfd_close): Delete BFDs for nested archives.
    * binutils/ar.c (make_thin_archive): New global flag.
    (map_over_members): Deal with full pathnames in thin archives.
    (usage, main): Add 'T' option for building thin archives.
    (replace_members): Pass thin archive flag to ar_emul_append.
    * binutils/arsup.c (ar_open): Initialize new flag.
    * binutils/binemul.c (ar_emul_append): Add new parameter for
    flattening nested archives.
    (do_ar_emul_default_append): New function.
    (ar_emul_default_append): Factored out recursive code.
    * binutils/binemul.h (ar_emul_default_append): Add new parameter.
    (struct bin_emulation_xfer_struct): New parameter for ar_append.
    * binutils/dlltool.c (gen_lib_file): Initialize thin archive flag.
    * binutils/emul_aix.c (ar_emul_aix_internal): Add new flatten
    parameter, currently unimplemented.
    All callers changed.
    * binutils/objcopy.c (copy_archive): Preserve thin archive flag.
    * binutils/doc/binutils.texi: Update ar documentation.
    * binutils/testsuite/binutils-all/ar.exp: Add thin archive tests.
    * include/aout/ar.h (ARMAGT): New magic string for thin archives.
@
text
@d3 1
a3 1
   2004, 2007, 2008 Free Software Foundation, Inc.
@


1.19
log
@Change sources over to using GPLv3
@
text
@d3 1
a3 1
   2004, 2007 Free Software Foundation, Inc.
d210 1
@


1.18
log
@bfd/
	* bfd.c (struct bfd): Rename "next" to "archive_next".
	* archive.c: Rename uses throughout file.
	* archive64.c: Likewise.
	* coff-rs6000.c: Likewise.
	* ecoff.c: Likewise.
	* som.c: Likewise.
	* bfd-in2.h: Regenerate.
binutils/
	* ar.c: Rename uses of bfd.next to bfd.archive_next throughout.
	* arsup.c: Likewise.
	* binemul.c: Likewise.
	* objcopy.c: Likewise.
	* dlltool.c: Likewise.
ld/
	* pe-dll.c: Rename uses of bfd.next to bfd.archive_next throughout.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
d19 2
a20 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.17
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d55 1
a55 1
      head = arch->next;
d58 1
a58 1
	  next = head->next;
d77 1
a77 1
	  for (head = arch->next; head; head = head->next)
d201 1
a201 1
	      ptr = &element->next;
d217 1
a217 1
    prev->next = abfd->next;
d219 1
a219 1
  abfd->next = obfd->archive_head;
d265 1
a265 1
	      abfd->next = obfd->archive_head;
d302 1
a302 1
		  *prev = member->next;
d306 1
a306 1
		prev = &(member->next);
d308 1
a308 1
	      member = member->next;
d376 1
a376 1
		      abfd->next = member->next;
d382 1
a382 1
		  prev = &(member->next);
d384 1
a384 1
	      member = member->next;
d427 1
a427 1
	   abfd = abfd->next)
d466 1
a466 1
	      member = member->next;
@


1.16
log
@Update FSF address
@
text
@d3 1
a3 1
   2004 Free Software Foundation, Inc.
d28 1
a29 1
#include "arsup.h"
d31 1
d33 1
a33 1
#include "filenames.h"
@


1.15
log
@	* ar.c (mri_mode): Make static.
	* arsup.c (obfd, real_name, outfile): Likewise.
	* binemul.c (ar_emul_create): Remove unused function.
	(ar_emul_default_create): Likewise.
	* binemul.h (ar_emul_create): Remove declaration.
	(ar_emul_default_create): Likewise.
	(struct bin_emulation_xfer_struct): Remove ar_create member.
	* bucomm.c (report): Make static.
	* bucomm.h (report): Remove declaration.
	* cxxfilt.c (mbuffer): Make static.
	(main): Use unsigned ints for some loop control variables.
	* readelf.c: Make many global variables static.
	* size.c (berkeley_format): Make static.
	(long_options): Likewise.
	* emul_aix.c (bin_aix_emulation): Remove ar_emul_default_create
	structure initialiser.
	(bin_aix5_emulation): Likewise.
	* emul_vanilla.c (bin_vanilla_emulation): Likewise.
@
text
@d19 1
a19 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.14
log
@update copyright dates
@
text
@d41 4
a92 1
FILE *outfile;
a146 3
bfd *obfd;
char *real_name;

@


1.13
log
@	PR 86
	* arsup.c (ar_save): Use smart_rename.
@
text
@d2 2
a3 2
   Copyright 1992, 1994, 1995, 1996, 1997, 2000, 2002, 2003, 2004
   Free Software Foundation, Inc.
@


1.12
log
@Use bfd_cache_close, instead of accessing bfd->iostream directly.
@
text
@d2 1
a2 1
   Copyright 1992, 1994, 1995, 1996, 1997, 2000, 2002, 2003
d336 1
a336 1
      rename (ofilename, real_name);
@


1.12.2.1
log
@Merge to 2.15 branch.
@
text
@d2 1
a2 1
   Copyright 1992, 1994, 1995, 1996, 1997, 2000, 2002, 2003, 2004
d336 1
a336 1
      smart_rename (ofilename, real_name, 0);
@


1.11
log
@	* ChangeLog: Fix typos.
	* ChangeLog-9197: Likewise.
	* ChangeLog-9899: Likewise.
	* NEWS: Likewise.
	* ar.c: Fix comment typos.
	* arsup.c: Likewise.
	* coffgrok.c: Likewise.
	* debug.c: Likewise.
	* debug.h: Likewise.
	* dlltool.c: Likewise.
	* ieee.c: Likewise.
	* nm.c: Likewise.
	* objdump.c: Likewise.
	* prdbg.c: Likewise.
	* readelf.c: Likewise.
	* resrc.c: Likewise.
	* sysinfo.y: Likewise.
	* windres.c: Likewise.
@
text
@d436 1
a436 1
      fclose ((FILE *)(obfd->iostream));
@


1.10
log
@	* addr2line.c: Convert to ISO C90 prototypes, change PTR, remove
	unneeded (void *) casts.
	* ar.c: Likewise.
	* arlex.l: Likewise.
	* arparse.y: Likewise.
	* arsup.c: Likewise.
	* binemul.c: Likewise.
	* binemul.h: Likewise.
	* bucomm.c: Likewise.
	* bucomm.h: Likewise.
	* budbg.h: Likewise.
	* budemang.c: Likewise.
	* budemang.h: Likewise.
	* coffdump.c: Likewise.
	* coffgrok.c: Likewise.
	* cxxfilt.c: Likewise.
	* debug.c: Likewise.
	* debug.h: Likewise.
	* deflex.l: Likewise.
	* dlltool.c: Likewise.
	* dlltool.h: Likewise.
	* dllwrap.c: Likewise.
	* emul_aix.c: Likewise.
	* filemode.c: Likewise.
	* ieee.c: Likewise.
	* nlmconv.c: Likewise.
	* nlmconv.h: Likewise.
	* nlmheader.y: Likewise.
	* nm.c: Likewise.
	* prdbg.c: Likewise.
	* rclex.l: Likewise.
	* rcparse.y: Likewise.
	* rdcoff.c: Likewise.
	* rddbg.c: Likewise.
	* rename.c: Likewise.
	* resbin.c: Likewise.
	* rescoff.c: Likewise.
	* resrc.c: Likewise.
	* size.c: Likewise.
	* srconv.c: Likewise.
	* stabs.c: Likewise.
	* strings.c: Likewise.
	* sysdump.c: Likewise.
	* sysinfo.y: Likewise.
	* syslex.l: Likewise.
	* unwind-ia64.c: Likewise.
	* unwind-ia64.h: Likewise.
	* version.c: Likewise.
	* windres.c: Likewise.
	* windres.h: Likewise.
	* winduni.c: Likewise.
	* wrstabs.c: Likewise.
@
text
@d238 1
a238 1
      /* Don't close the bfd, since it will make the elements disasppear.  */
@


1.9
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2 1
a2 1
   Copyright 1992, 1994, 1995, 1996, 1997, 2000, 2002
d35 3
a37 3
  PARAMS ((bfd *, void (*function) (bfd *, bfd *), struct list *));
static void ar_directory_doer PARAMS ((bfd *, bfd *));
static void ar_addlib_doer PARAMS ((bfd *, bfd *));
d42 1
a42 4
map_over_list (arch, function, list)
     bfd *arch;
     void (*function) PARAMS ((bfd *, bfd *));
     struct list *list;
d92 1
a92 3
ar_directory_doer (abfd, ignore)
     bfd *abfd;
     bfd *ignore ATTRIBUTE_UNUSED;
d98 1
a98 4
ar_directory (ar_name, list, output)
     char *ar_name;
     struct list *list;
     char *output;
d125 1
a125 1
DEFUN_VOID(prompt)
d137 1
a137 1
maybequit ()
d148 1
a148 3
ar_open (name, t)
  char *name;
  int t;
d212 1
a212 3
ar_addlib_doer (abfd, prev)
     bfd *abfd;
     bfd *prev;
d223 1
a223 3
ar_addlib (name, list)
     char *name;
     struct list *list;
d243 1
a243 2
ar_addmod (list)
     struct list *list;
d274 1
a274 1
ar_clear ()
d281 1
a281 2
ar_delete (list)
     struct list *list;
d323 1
a323 1
ar_save ()
d343 1
a343 2
ar_replace (list)
     struct list *list;
d409 1
a409 1
ar_list ()
d432 1
a432 1
ar_end ()
d442 1
a442 2
ar_extract (list)
     struct list *list;
@


1.8
log
@Fix transaltion problems.
@
text
@d72 1
a72 1
	  boolean found = false;
d80 1
a80 1
		  found = true;
d195 1
a195 1
	  if (bfd_check_format(ibfd, bfd_archive) != true)
@


1.7
log
@	* arsup.c: Remove ARGSUSED.
	* debug.c: Likewise.
	* ieee.c: Likewise.
	* nlmconv.c: Likewise.
	* prdbg.c: Likewise.
	* stabs.c: Likewise.
	* wrstabs.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 1992, 1994, 1995, 1996, 1997, 2000
d5 1
a5 1
This file is part of GNU Binutils.
d7 13
a19 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d23 1
a23 1
   		  sac@@cygnus.com
d25 2
a26 4
This file looks after requests from arparse.y, to provide the MRI
style librarian command syntax + 1 word LIST

*/
d99 1
a99 1
    print_arelt_descr(outfile, abfd, verbose);
d136 1
d138 4
a141 4
  {
    printf("AR >");
    fflush(stdout);
  }
d153 2
a154 1
char *real_name ;
d156 3
a158 4
DEFUN(ar_open,(name, t),
      char *name AND
      int t)

d163 1
d166 8
a173 2
  sprintf(tname, "%.*stmp-%s", (int) (bname - name), name, bname);
  obfd = bfd_openw(tname, NULL);
d175 1
a175 32
  if (!obfd) {
    fprintf(stderr,_("%s: Can't open output archive %s\n"), program_name,
	    tname);

    maybequit();
  }
  else {
    if (!t) {
      bfd **ptr;
      bfd *element;
      bfd *ibfd;
      ibfd = bfd_openr(name, NULL);
      if (!ibfd) {
	fprintf(stderr,_("%s: Can't open input archive %s\n"),
		program_name, name);
	maybequit();
	return;
      }
      if (bfd_check_format(ibfd, bfd_archive) != true) {
	fprintf(stderr,_("%s: file %s is not an archive\n"), program_name,
		name);
	maybequit();
	return;
      }
      ptr = &(obfd->archive_head);
      element = bfd_openr_next_archived_file(ibfd, NULL);

      while (element) {
	*ptr = element;
	ptr = &element->next;
	element = bfd_openr_next_archived_file(ibfd, element);
      }
d177 37
d215 1
a215 1
    bfd_set_format(obfd, bfd_archive);
d217 2
a218 2
    obfd->has_armap = 1;
  }
a220 1

d226 1
a226 1
  /* Add this module to the output bfd */
d229 1
d252 1
a252 1
      /* Don't close the bfd, since it will make the elements disasppear */
d257 2
a258 2
DEFUN(ar_addmod, (list),
      struct list *list)
d260 5
a264 4
  if (!obfd) {
    fprintf(stderr, _("%s: no open output archive\n"), program_name);
    maybequit();
  }
d266 18
a283 13
  {
    while (list) {
      bfd *abfd = bfd_openr(list->name, NULL);
      if (!abfd)  {
	fprintf(stderr,_("%s: can't open file %s\n"), program_name,
		list->name);
	maybequit();
      }
      else {
	abfd->next = obfd->archive_head;
	obfd->archive_head = abfd;
      }
      list = list->next;
a284 1
  }
a287 1

d289 1
a289 1
DEFUN_VOID(ar_clear)
d291 2
a292 2
if (obfd)
 obfd->archive_head = 0;
d296 2
a297 2
DEFUN(ar_delete, (list),
      struct list *list)
d299 5
a303 4
  if (!obfd) {
    fprintf(stderr, _("%s: no open output archive\n"), program_name);
    maybequit();
  }
d305 29
a333 10
  {
    while (list) {
      /* Find this name in the archive */
      bfd *member = obfd->archive_head;
      bfd **prev = &(obfd->archive_head);
      int found = 0;
      while (member) {
	if (FILENAME_CMP(member->filename, list->name) == 0) {
	  *prev = member->next;
	  found = 1;
a334 11
	else {
	  prev = &(member->next);
	}
	  member = member->next;
      }
      if (!found)  {
	fprintf(stderr,_("%s: can't find module file %s\n"), program_name,
		list->name);
	maybequit();
      }
      list = list->next;
a335 1
  }
a337 1

d339 1
a339 1
DEFUN_VOID(ar_save)
d341 8
d350 1
a350 7
  if (!obfd) {
    fprintf(stderr, _("%s: no open output archive\n"), program_name);
    maybequit();
  }
  else {
    char *ofilename = xstrdup (bfd_get_filename (obfd));
    bfd_close(obfd);
d352 4
a355 4
    rename (ofilename, real_name);
    obfd = 0;
    free(ofilename);
  }
a357 2


d359 2
a360 2
DEFUN(ar_replace, (list),
      struct list *list)
d362 5
a366 4
  if (!obfd) {
    fprintf(stderr, _("%s: no open output archive\n"), program_name);
    maybequit();
  }
d368 2
a369 9
  {
    while (list) {
      /* Find this name in the archive */
      bfd *member = obfd->archive_head;
      bfd **prev = &(obfd->archive_head);
      int found = 0;
      while (member)
      {
	if (FILENAME_CMP(member->filename, list->name) == 0)
d371 49
a419 15
	  /* Found the one to replace */
	  bfd *abfd = bfd_openr(list->name, 0);
	  if (!abfd)
	  {
	    fprintf(stderr, _("%s: can't open file %s\n"), program_name, list->name);
	    maybequit();
	  }
	  else {
	    *prev = abfd;
	    abfd->next = member->next;
	    found = 1;
	  }
	}
	else {
	  prev = &(member->next);
a420 18
	member = member->next;
      }
      if (!found)  {
	bfd *abfd = bfd_openr(list->name, 0);
	fprintf(stderr,_("%s: can't find module file %s\n"), program_name,
		list->name);
	if (!abfd)
	{
	  fprintf(stderr, _("%s: can't open file %s\n"), program_name, list->name);
	  maybequit();
	}
	else
	{
	  *prev = abfd;
	}
      }

    list = list->next;
a421 1
  }
d424 1
a424 1
/* And I added this one */
d426 1
a426 1
DEFUN_VOID(ar_list)
a428 12
  {
    fprintf(stderr, _("%s: no open output archive\n"), program_name);
    maybequit();
  }
  else {
    bfd *abfd;
    outfile = stdout;
    verbose =1 ;
    printf(_("Current open archive is %s\n"), bfd_get_filename (obfd));
    for (abfd = obfd->archive_head;
	 abfd != (bfd *)NULL;
	 abfd = abfd->next)
d430 15
a444 1
      ar_directory_doer (abfd, (bfd *) NULL);
a445 1
  }
a447 1

d449 1
a449 1
DEFUN_VOID(ar_end)
d452 4
a455 4
  {
    fclose((FILE *)(obfd->iostream));
    unlink(bfd_get_filename (obfd));
  }
d457 1
d459 2
a460 2
DEFUN(ar_extract,(list),
      struct list *list)
d463 4
a466 5
  {

    fprintf(stderr, _("%s: no open  archive\n"), program_name);
    maybequit();
  }
d468 2
a469 8
  {
    while (list) {
      /* Find this name in the archive */
      bfd *member = obfd->archive_head;
      int found = 0;
      while (member && !found)
      {
	if (FILENAME_CMP(member->filename, list->name) == 0)
d471 14
a484 10
	  extract_file(member);
	  found = 1;
	  }

	member = member->next;
      }
      if (!found)  {
	bfd_openr(list->name, 0);
	fprintf(stderr,_("%s: can't find module file %s\n"), program_name,
		list->name);
d486 9
a494 2
      }
      list = list->next;
a495 1
  }
@


1.6
log
@	* addr2line.c: Fix formatting.
	* ar.c: Likewise.
	* arsup.c: Likewise.
	* arsup.h: Likewise.
	* binemul.c: Likewise.
	* binemul.h: Likewise.
	* bucomm.c: Likewise.
	* coffdump.c: Likewise.
	* coffgrok.c: Likewise.
	* coffgrok.h: Likewise.
@
text
@a95 1
/*ARGSUSED*/
@


1.5
log
@	* arlex.l: Accept `\' in filenames.  Patch by <earl_chew@@agilent.com>.

	* arsup.c (ar_open): Prepend tmp- to basename, not whole path.
@
text
@d77 1
a77 1
	  for (head = arch->next; head; head = head->next) 
d124 1
a124 1
  else 
d139 1
a139 1
  if (interactive) 
d142 1
a142 1
    fflush(stdout); 
d149 1
a149 1
  if (! interactive) 
d155 1
a155 1
char *real_name ; 
d253 1
a253 1
  else 
d276 1
a276 1
if (obfd) 
d288 1
a288 1
  else 
d327 1
a327 1
    
d344 1
a344 1
  else 
d351 1
a351 1
      while (member) 
d353 1
a353 1
	if (FILENAME_CMP(member->filename, list->name) == 0) 
d357 1
a357 1
	  if (!abfd) 
d377 1
a377 1
	if (!abfd) 
d382 1
a382 1
	else 
d397 1
a397 1
  if (!obfd) 
d409 1
a409 1
	 abfd = abfd->next) 
d417 1
a417 1
void 
d430 1
a430 1
  if (!obfd) 
d436 1
a436 1
  else 
d442 1
a442 1
      while (member && !found) 
d444 1
a444 1
	if (FILENAME_CMP(member->filename, list->name) == 0) 
@


1.4
log
@Fix typos in ChangeLogs and update copyright notices
@
text
@d163 1
d167 1
a167 1
  sprintf(tname, "tmp-%s", name);
@


1.3
log
@Eli Zaretskii's DOSish file name patches.
@
text
@d2 1
a2 1
   Copyright (C) 1992, 93, 94, 95, 96, 97, 98, 99, 2000
@


1.3.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1992, 1994, 1995, 1996, 1997, 2000
@


1.2
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Add variable initializations.  Add casts.
	* objdump.c (disassemble_bytes): Change j to bfd_vma.
	* readelf.c (process_syminfo): Change i to unsigned int.
	(display_debug_info): Change abbrev_number to unsigned long.
	(process_mips_specific): Change fcnt to size_t.
@
text
@d2 1
a2 1
   Copyright (C) 1992, 93, 94, 95, 96, 97, 98, 1999
d34 1
d80 1
a80 1
		  && strcmp (ptr->name, head->filename) == 0)
d164 3
a166 1
  sprintf(tname, "%s-tmp", name);
d295 1
a295 1
	if (strcmp(member->filename, list->name) == 0) {
d352 1
a352 1
	if (strcmp(member->filename, list->name) == 0) 
d443 1
a443 1
	if (strcmp(member->filename, list->name) == 0) 
@


1.2.2.1
log
@Eli Zaretskii's DOSish file name patches.
@
text
@d2 1
a2 1
   Copyright (C) 1992, 93, 94, 95, 96, 97, 98, 99, 2000
a33 1
#include "filenames.h"
d79 1
a79 1
		  && FILENAME_CMP (ptr->name, head->filename) == 0)
d163 1
a163 3
  /* Prepend tmp- to the beginning, to avoid file-name clashes after
     truncation on filesystems with limited namespaces (DOS).  */
  sprintf(tname, "tmp-%s", name);
d292 1
a292 1
	if (FILENAME_CMP(member->filename, list->name) == 0) {
d349 1
a349 1
	if (FILENAME_CMP(member->filename, list->name) == 0) 
d440 1
a440 1
	if (FILENAME_CMP(member->filename, list->name) == 0) 
@


1.1
log
@Initial revision
@
text
@d2 2
a3 1
   Copyright (C) 1992, 93, 94, 95, 96, 1997, 1998 Free Software Foundation, Inc.
d99 1
a99 1
     bfd *ignore;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

