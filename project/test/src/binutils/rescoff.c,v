head	1.13;
access;
symbols
	binutils-2_24-branch:1.13.0.4
	binutils-2_24-branchpoint:1.13
	binutils-2_21_1:1.12
	binutils-2_23_2:1.13
	binutils-2_23_1:1.13
	binutils-2_23:1.13
	binutils-2_23-branch:1.13.0.2
	binutils-2_23-branchpoint:1.13
	binutils-2_22_branch:1.12.0.8
	binutils-2_22:1.12
	binutils-2_22-branch:1.12.0.6
	binutils-2_22-branchpoint:1.12
	binutils-2_21:1.12
	binutils-2_21-branch:1.12.0.4
	binutils-2_21-branchpoint:1.12
	binutils-2_20_1:1.12
	binutils-2_20:1.12
	binutils-arc-20081103-branch:1.11.0.8
	binutils-arc-20081103-branchpoint:1.11
	binutils-2_20-branch:1.12.0.2
	binutils-2_20-branchpoint:1.12
	dje-cgen-play1-branch:1.11.0.6
	dje-cgen-play1-branchpoint:1.11
	arc-20081103-branch:1.11.0.4
	arc-20081103-branchpoint:1.11
	binutils-2_19_1:1.11
	binutils-2_19:1.11
	binutils-2_19-branch:1.11.0.2
	binutils-2_19-branchpoint:1.11
	binutils-2_18:1.10
	binutils-2_18-branch:1.10.0.2
	binutils-2_18-branchpoint:1.10
	binutils-csl-coldfire-4_1-32:1.7
	binutils-csl-sourcerygxx-4_1-32:1.7
	binutils-csl-innovasic-fido-3_4_4-33:1.7
	binutils-csl-sourcerygxx-3_4_4-32:1.6
	binutils-csl-coldfire-4_1-30:1.7
	binutils-csl-sourcerygxx-4_1-30:1.7
	binutils-csl-coldfire-4_1-28:1.7
	binutils-csl-sourcerygxx-4_1-29:1.7
	binutils-csl-sourcerygxx-4_1-28:1.7
	binutils-csl-arm-2006q3-27:1.7
	binutils-csl-sourcerygxx-4_1-27:1.7
	binutils-csl-arm-2006q3-26:1.7
	binutils-csl-sourcerygxx-4_1-26:1.7
	binutils-csl-sourcerygxx-4_1-25:1.7
	binutils-csl-sourcerygxx-4_1-24:1.7
	binutils-csl-sourcerygxx-4_1-23:1.7
	binutils-csl-sourcerygxx-4_1-21:1.7
	binutils-csl-arm-2006q3-21:1.7
	binutils-csl-sourcerygxx-4_1-22:1.7
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.7
	binutils-csl-sourcerygxx-4_1-20:1.7
	binutils-csl-arm-2006q3-19:1.7
	binutils-csl-sourcerygxx-4_1-19:1.7
	binutils-csl-sourcerygxx-4_1-18:1.7
	binutils-csl-renesas-4_1-9:1.7
	binutils-csl-sourcerygxx-3_4_4-25:1.6
	binutils-csl-renesas-4_1-8:1.7
	binutils-csl-renesas-4_1-7:1.7
	binutils-csl-renesas-4_1-6:1.7
	binutils-csl-sourcerygxx-4_1-17:1.7
	binutils-csl-sourcerygxx-4_1-14:1.7
	binutils-csl-sourcerygxx-4_1-15:1.7
	binutils-csl-sourcerygxx-4_1-13:1.7
	binutils-2_17:1.7
	binutils-csl-sourcerygxx-4_1-12:1.7
	binutils-csl-sourcerygxx-3_4_4-21:1.7
	binutils-csl-wrs-linux-3_4_4-24:1.6
	binutils-csl-wrs-linux-3_4_4-23:1.6
	binutils-csl-sourcerygxx-4_1-9:1.7
	binutils-csl-sourcerygxx-4_1-8:1.7
	binutils-csl-sourcerygxx-4_1-7:1.7
	binutils-csl-arm-2006q1-6:1.7
	binutils-csl-sourcerygxx-4_1-6:1.7
	binutils-csl-wrs-linux-3_4_4-22:1.6
	binutils-csl-coldfire-4_1-11:1.7
	binutils-csl-sourcerygxx-3_4_4-19:1.7
	binutils-csl-coldfire-4_1-10:1.7
	binutils-csl-sourcerygxx-4_1-5:1.7
	binutils-csl-sourcerygxx-4_1-4:1.7
	binutils-csl-wrs-linux-3_4_4-21:1.6
	binutils-csl-morpho-4_1-4:1.7
	binutils-csl-sourcerygxx-3_4_4-17:1.7
	binutils-csl-wrs-linux-3_4_4-20:1.6
	binutils-2_17-branch:1.7.0.4
	binutils-2_17-branchpoint:1.7
	binutils-csl-2_17-branch:1.7.0.2
	binutils-csl-2_17-branchpoint:1.7
	binutils-csl-gxxpro-3_4-branch:1.6.0.12
	binutils-csl-gxxpro-3_4-branchpoint:1.6
	binutils-2_16_1:1.6
	binutils-csl-arm-2005q1b:1.6
	binutils-2_16:1.6
	binutils-csl-arm-2005q1a:1.6
	binutils-csl-arm-2005q1-branch:1.6.0.10
	binutils-csl-arm-2005q1-branchpoint:1.6
	binutils-2_16-branch:1.6.0.8
	binutils-2_16-branchpoint:1.6
	csl-arm-2004-q3d:1.6
	csl-arm-2004-q3:1.6
	binutils-2_15:1.6
	binutils-2_15-branchpoint:1.6
	csl-arm-2004-q1a:1.6
	csl-arm-2004-q1:1.6
	binutils-2_15-branch:1.6.0.6
	cagney_bfdfile-20040213-branch:1.6.0.4
	cagney_bfdfile-20040213-branchpoint:1.6
	cagney_bigcore-20040122-branch:1.6.0.2
	cagney_bigcore-20040122-branchpoint:1.6
	csl-arm-2003-q4:1.6
	binutils-2_14:1.5
	binutils-2_14-branch:1.5.0.6
	binutils-2_14-branchpoint:1.5
	binutils-2_13_2_1:1.5
	binutils-2_13_2:1.5
	binutils-2_13_1:1.5
	binutils-2_13:1.5
	binutils-2_13-branchpoint:1.5
	binutils-2_13-branch:1.5.0.4
	binutils-2_12_1:1.5
	binutils-2_12:1.5
	binutils-2_12-branch:1.5.0.2
	binutils-2_12-branchpoint:1.5
	cygnus_cvs_20020108_pre:1.5
	binutils-2_11_2:1.4.2.1
	binutils-2_11_1:1.4.2.1
	binutils-2_11:1.4
	x86_64versiong3:1.4
	binutils-2_11-branch:1.4.0.2
	binutils-2_10_1:1.3.2.1
	binutils-2_10:1.3.2.1
	binutils-2_10-branch:1.3.0.2
	binutils-2_10-branchpoint:1.3
	binutils_latest_snapshot:1.13
	repo-unification-2000-02-06:1.2
	binu_ss_19990721:1.2
	binu_ss_19990602:1.2
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.13
date	2012.05.01.16.07.36;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2009.09.02.07.22.32;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2008.07.07.00.44.41;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2007.07.05.16.54.45;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2007.05.23.08.48.29;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2007.04.26.14.46.59;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2005.05.08.14.17.39;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2003.09.14.12.20.16;	author aj;	state Exp;
branches;
next	1.5;

1.5
date	2001.03.13.06.43.58;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2000.04.07.04.34.50;	author amodra;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	2000.02.24.19.37.32;	author nickc;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	99.05.11.21.06.15;	author dj;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.29.10;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.4.2.1
date	2001.06.07.03.12.28;	author amodra;	state Exp;
branches;
next	;

1.3.2.1
date	2000.04.07.04.39.25;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.10;	author rth;	state Exp;
branches;
next	;


desc
@@


1.13
log
@	PR binutils/13121
	Rename 'finfo' to 'flaginfo' to avoid conflicts with
	AIX system headers.
@
text
@/* rescoff.c -- read and write resources in Windows COFF files.
   Copyright 1997, 1998, 1999, 2000, 2003, 2005, 2007, 2008
   Free Software Foundation, Inc.
   Written by Ian Lance Taylor, Cygnus Support.
   Rewritten by Kai Tietz, Onevision.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* This file contains function that read and write Windows resources
   in COFF files.  */

#include "sysdep.h"
#include "bfd.h"
#include "bucomm.h"
#include "libiberty.h"
#include "windres.h"

#include <assert.h>

/* In order to use the address of a resource data entry, we need to
   get the image base of the file.  Right now we extract it from
   internal BFD information.  FIXME.  */

#include "coff/internal.h"
#include "libcoff.h"

/* Information we extract from the file.  */

struct coff_file_info
{
  /* File name.  */
  const char *filename;
  /* Data read from the file.  */
  const bfd_byte *data;
  /* End of data read from file.  */
  const bfd_byte *data_end;
  /* Address of the resource section minus the image base of the file.  */
  rc_uint_type secaddr;
};

/* A resource directory table in a COFF file.  */

struct __attribute__ ((__packed__)) extern_res_directory
{
  /* Characteristics.  */
  bfd_byte characteristics[4];
  /* Time stamp.  */
  bfd_byte time[4];
  /* Major version number.  */
  bfd_byte major[2];
  /* Minor version number.  */
  bfd_byte minor[2];
  /* Number of named directory entries.  */
  bfd_byte name_count[2];
  /* Number of directory entries with IDs.  */
  bfd_byte id_count[2];
};

/* A resource directory entry in a COFF file.  */

struct extern_res_entry
{
  /* Name or ID.  */
  bfd_byte name[4];
  /* Address of resource entry or subdirectory.  */
  bfd_byte rva[4];
};

/* A resource data entry in a COFF file.  */

struct extern_res_data
{
  /* Address of resource data.  This is apparently a file relative
     address, rather than a section offset.  */
  bfd_byte rva[4];
  /* Size of resource data.  */
  bfd_byte size[4];
  /* Code page.  */
  bfd_byte codepage[4];
  /* Reserved.  */
  bfd_byte reserved[4];
};

/* Local functions.  */

static void overrun (const struct coff_file_info *, const char *);
static rc_res_directory *read_coff_res_dir (windres_bfd *, const bfd_byte *,
					    const struct coff_file_info *,
					    const rc_res_id *, int);
static rc_res_resource *read_coff_data_entry (windres_bfd *, const bfd_byte *,
					      const struct coff_file_info *,
					      const rc_res_id *);

/* Read the resources in a COFF file.  */

rc_res_directory *
read_coff_rsrc (const char *filename, const char *target)
{
  rc_res_directory *ret;
  bfd *abfd;
  windres_bfd wrbfd;
  char **matching;
  asection *sec;
  bfd_size_type size;
  bfd_byte *data;
  struct coff_file_info flaginfo;

  if (filename == NULL)
    fatal (_("filename required for COFF input"));

  abfd = bfd_openr (filename, target);
  if (abfd == NULL)
    bfd_fatal (filename);

  if (! bfd_check_format_matches (abfd, bfd_object, &matching))
    {
      bfd_nonfatal (bfd_get_filename (abfd));
      if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
	list_matching_formats (matching);
      xexit (1);
    }

  sec = bfd_get_section_by_name (abfd, ".rsrc");
  if (sec == NULL)
    {
      fatal (_("%s: no resource section"), filename);
    }

  set_windres_bfd (&wrbfd, abfd, sec, WR_KIND_BFD);
  size = bfd_section_size (abfd, sec);
  data = (bfd_byte *) res_alloc (size);

  get_windres_bfd_content (&wrbfd, data, 0, size);

  flaginfo.filename = filename;
  flaginfo.data = data;
  flaginfo.data_end = data + size;
  flaginfo.secaddr = (bfd_get_section_vma (abfd, sec)
		   - pe_data (abfd)->pe_opthdr.ImageBase);

  /* Now just read in the top level resource directory.  Note that we
     don't free data, since we create resource entries that point into
     it.  If we ever want to free up the resource information we read,
     this will have to be cleaned up.  */

  ret = read_coff_res_dir (&wrbfd, data, &flaginfo, (const rc_res_id *) NULL, 0);
  
  bfd_close (abfd);

  return ret;
}

/* Give an error if we are out of bounds.  */

static void
overrun (const struct coff_file_info *flaginfo, const char *msg)
{
  fatal (_("%s: %s: address out of bounds"), flaginfo->filename, msg);
}

/* Read a resource directory.  */

static rc_res_directory *
read_coff_res_dir (windres_bfd *wrbfd, const bfd_byte *data,
		   const struct coff_file_info *flaginfo,
		   const rc_res_id *type, int level)
{
  const struct extern_res_directory *erd;
  rc_res_directory *rd;
  int name_count, id_count, i;
  rc_res_entry **pp;
  const struct extern_res_entry *ere;

  if ((size_t) (flaginfo->data_end - data) < sizeof (struct extern_res_directory))
    overrun (flaginfo, _("directory"));

  erd = (const struct extern_res_directory *) data;

  rd = (rc_res_directory *) res_alloc (sizeof (rc_res_directory));
  rd->characteristics = windres_get_32 (wrbfd, erd->characteristics, 4);
  rd->time = windres_get_32 (wrbfd, erd->time, 4);
  rd->major = windres_get_16 (wrbfd, erd->major, 2);
  rd->minor = windres_get_16 (wrbfd, erd->minor, 2);
  rd->entries = NULL;

  name_count = windres_get_16 (wrbfd, erd->name_count, 2);
  id_count = windres_get_16 (wrbfd, erd->id_count, 2);

  pp = &rd->entries;

  /* The resource directory entries immediately follow the directory
     table.  */
  ere = (const struct extern_res_entry *) (erd + 1);

  for (i = 0; i < name_count; i++, ere++)
    {
      rc_uint_type name, rva;
      rc_res_entry *re;
      const bfd_byte *ers;
      int length, j;

      if ((const bfd_byte *) ere >= flaginfo->data_end)
	overrun (flaginfo, _("named directory entry"));

      name = windres_get_32 (wrbfd, ere->name, 4);
      rva = windres_get_32 (wrbfd, ere->rva, 4);

      /* For some reason the high bit in NAME is set.  */
      name &=~ 0x80000000;

      if (name > (rc_uint_type) (flaginfo->data_end - flaginfo->data))
	overrun (flaginfo, _("directory entry name"));

      ers = flaginfo->data + name;

      re = (rc_res_entry *) res_alloc (sizeof *re);
      re->next = NULL;
      re->id.named = 1;
      length = windres_get_16 (wrbfd, ers, 2);
      re->id.u.n.length = length;
      re->id.u.n.name = (unichar *) res_alloc (length * sizeof (unichar));
      for (j = 0; j < length; j++)
	re->id.u.n.name[j] = windres_get_16 (wrbfd, ers + j * 2 + 2, 2);

      if (level == 0)
	type = &re->id;

      if ((rva & 0x80000000) != 0)
	{
	  rva &=~ 0x80000000;
	  if (rva >= (rc_uint_type) (flaginfo->data_end - flaginfo->data))
	    overrun (flaginfo, _("named subdirectory"));
	  re->subdir = 1;
	  re->u.dir = read_coff_res_dir (wrbfd, flaginfo->data + rva, flaginfo, type,
					 level + 1);
	}
      else
	{
	  if (rva >= (rc_uint_type) (flaginfo->data_end - flaginfo->data))
	    overrun (flaginfo, _("named resource"));
	  re->subdir = 0;
	  re->u.res = read_coff_data_entry (wrbfd, flaginfo->data + rva, flaginfo, type);
	}

      *pp = re;
      pp = &re->next;
    }

  for (i = 0; i < id_count; i++, ere++)
    {
      unsigned long name, rva;
      rc_res_entry *re;

      if ((const bfd_byte *) ere >= flaginfo->data_end)
	overrun (flaginfo, _("ID directory entry"));

      name = windres_get_32 (wrbfd, ere->name, 4);
      rva = windres_get_32 (wrbfd, ere->rva, 4);

      re = (rc_res_entry *) res_alloc (sizeof *re);
      re->next = NULL;
      re->id.named = 0;
      re->id.u.id = name;

      if (level == 0)
	type = &re->id;

      if ((rva & 0x80000000) != 0)
	{
	  rva &=~ 0x80000000;
	  if (rva >= (rc_uint_type) (flaginfo->data_end - flaginfo->data))
	    overrun (flaginfo, _("ID subdirectory"));
	  re->subdir = 1;
	  re->u.dir = read_coff_res_dir (wrbfd, flaginfo->data + rva, flaginfo, type,
					 level + 1);
	}
      else
	{
	  if (rva >= (rc_uint_type) (flaginfo->data_end - flaginfo->data))
	    overrun (flaginfo, _("ID resource"));
	  re->subdir = 0;
	  re->u.res = read_coff_data_entry (wrbfd, flaginfo->data + rva, flaginfo, type);
	}

      *pp = re;
      pp = &re->next;
    }

  return rd;
}

/* Read a resource data entry.  */

static rc_res_resource *
read_coff_data_entry (windres_bfd *wrbfd, const bfd_byte *data,
		      const struct coff_file_info *flaginfo,
		      const rc_res_id *type)
{
  const struct extern_res_data *erd;
  rc_res_resource *r;
  rc_uint_type size, rva;
  const bfd_byte *resdata;

  if (type == NULL)
    fatal (_("resource type unknown"));

  if ((size_t) (flaginfo->data_end - data) < sizeof (struct extern_res_data))
    overrun (flaginfo, _("data entry"));

  erd = (const struct extern_res_data *) data;

  size = windres_get_32 (wrbfd, erd->size, 4);
  rva = windres_get_32 (wrbfd, erd->rva, 4);
  if (rva < flaginfo->secaddr
      || rva - flaginfo->secaddr >= (rc_uint_type) (flaginfo->data_end - flaginfo->data))
    overrun (flaginfo, _("resource data"));

  resdata = flaginfo->data + (rva - flaginfo->secaddr);

  if (size > (rc_uint_type) (flaginfo->data_end - resdata))
    overrun (flaginfo, _("resource data size"));

  r = bin_to_res (wrbfd, *type, resdata, size);

  memset (&r->res_info, 0, sizeof (rc_res_res_info));
  r->coff_info.codepage = windres_get_32 (wrbfd, erd->codepage, 4);
  r->coff_info.reserved = windres_get_32 (wrbfd, erd->reserved, 4);

  return r;
}

/* This structure is used to build a list of bindata structures.  */

struct bindata_build
{
  /* The data.  */
  bindata *d;
  /* The last structure we have added to the list.  */
  bindata *last;
  /* The size of the list as a whole.  */
  unsigned long length;
};

struct coff_res_data_build
{
  /* The data.  */
  coff_res_data *d;
  /* The last structure we have added to the list.  */
  coff_res_data *last;
  /* The size of the list as a whole.  */
  unsigned long length;
};

/* This structure keeps track of information as we build the directory
   tree.  */

struct coff_write_info
{
  /* These fields are based on the BFD.  */
  /* The BFD itself.  */
  windres_bfd *wrbfd;
  /* Pointer to section symbol used to build RVA relocs.  */
  asymbol **sympp;

  /* These fields are computed initially, and then not changed.  */
  /* Length of directory tables and entries.  */
  unsigned long dirsize;
  /* Length of directory entry strings.  */
  unsigned long dirstrsize;
  /* Length of resource data entries.  */
  unsigned long dataentsize;

  /* These fields are updated as we add data.  */
  /* Directory tables and entries.  */
  struct bindata_build dirs;
  /* Directory entry strings.  */
  struct bindata_build dirstrs;
  /* Resource data entries.  */
  struct bindata_build dataents;
  /* Actual resource data.  */
  struct coff_res_data_build resources;
  /* Relocations.  */
  arelent **relocs;
  /* Number of relocations.  */
  unsigned int reloc_count;
};

static void coff_bin_sizes (const rc_res_directory *, struct coff_write_info *);
static bfd_byte *coff_alloc (struct bindata_build *, rc_uint_type);
static void coff_to_bin
  (const rc_res_directory *, struct coff_write_info *);
static void coff_res_to_bin
  (const rc_res_resource *, struct coff_write_info *);

/* Write resources to a COFF file.  RESOURCES should already be
   sorted.

   Right now we always create a new file.  Someday we should also
   offer the ability to merge resources into an existing file.  This
   would require doing the basic work of objcopy, just modifying or
   adding the .rsrc section.  */

void
write_coff_file (const char *filename, const char *target,
		 const rc_res_directory *resources)
{
  bfd *abfd;
  asection *sec;
  struct coff_write_info cwi;
  windres_bfd wrbfd;
  bindata *d;
  coff_res_data *rd;
  unsigned long length, offset;

  if (filename == NULL)
    fatal (_("filename required for COFF output"));

  abfd = bfd_openw (filename, target);
  if (abfd == NULL)
    bfd_fatal (filename);

  if (! bfd_set_format (abfd, bfd_object))
    bfd_fatal ("bfd_set_format");

#if defined DLLTOOL_SH
  if (! bfd_set_arch_mach (abfd, bfd_arch_sh, 0))
    bfd_fatal ("bfd_set_arch_mach(sh)");
#elif defined DLLTOOL_MIPS
  if (! bfd_set_arch_mach (abfd, bfd_arch_mips, 0))
    bfd_fatal ("bfd_set_arch_mach(mips)");
#elif defined DLLTOOL_ARM
  if (! bfd_set_arch_mach (abfd, bfd_arch_arm, 0))
    bfd_fatal ("bfd_set_arch_mach(arm)");
#else
  /* FIXME: This is obviously i386 specific.  */
  if (! bfd_set_arch_mach (abfd, bfd_arch_i386, 0))
    bfd_fatal ("bfd_set_arch_mach(i386)");
#endif

  if (! bfd_set_file_flags (abfd, HAS_SYMS | HAS_RELOC))
    bfd_fatal ("bfd_set_file_flags");

  sec = bfd_make_section_with_flags (abfd, ".rsrc",
				     (SEC_HAS_CONTENTS | SEC_ALLOC
				      | SEC_LOAD | SEC_DATA));
  if (sec == NULL)
    bfd_fatal ("bfd_make_section");

  if (! bfd_set_symtab (abfd, sec->symbol_ptr_ptr, 1))
    bfd_fatal ("bfd_set_symtab");

  /* Requiring this is probably a bug in BFD.  */
  sec->output_section = sec;

  /* The order of data in the .rsrc section is
       resource directory tables and entries
       resource directory strings
       resource data entries
       actual resource data

     We build these different types of data in different lists.  */

  set_windres_bfd (&wrbfd, abfd, sec, WR_KIND_BFD);

  cwi.wrbfd = &wrbfd;
  cwi.sympp = sec->symbol_ptr_ptr;
  cwi.dirsize = 0;
  cwi.dirstrsize = 0;
  cwi.dataentsize = 0;
  cwi.dirs.d = NULL;
  cwi.dirs.last = NULL;
  cwi.dirs.length = 0;
  cwi.dirstrs.d = NULL;
  cwi.dirstrs.last = NULL;
  cwi.dirstrs.length = 0;
  cwi.dataents.d = NULL;
  cwi.dataents.last = NULL;
  cwi.dataents.length = 0;
  cwi.resources.d = NULL;
  cwi.resources.last = NULL;
  cwi.resources.length = 0;
  cwi.relocs = NULL;
  cwi.reloc_count = 0;

  /* Work out the sizes of the resource directory entries, so that we
     know the various offsets we will need.  */
  coff_bin_sizes (resources, &cwi);

  /* Force the directory strings to be 32 bit aligned.  Every other
     structure is 32 bit aligned anyhow.  */
  cwi.dirstrsize = (cwi.dirstrsize + 3) &~ 3;

  /* Actually convert the resources to binary.  */
  coff_to_bin (resources, &cwi);

  /* Add another 2 bytes to the directory strings if needed for
     alignment.  */
  if ((cwi.dirstrs.length & 3) != 0)
    {
      bfd_byte *ex;

      ex = coff_alloc (&cwi.dirstrs, 2);
      ex[0] = 0;
      ex[1] = 0;
    }

  /* Make sure that the data we built came out to the same size as we
     calculated initially.  */
  assert (cwi.dirs.length == cwi.dirsize);
  assert (cwi.dirstrs.length == cwi.dirstrsize);
  assert (cwi.dataents.length == cwi.dataentsize);

  length = (cwi.dirsize
	    + cwi.dirstrsize
	    + cwi.dataentsize
	    + cwi.resources.length);

  if (! bfd_set_section_size (abfd, sec, length))
    bfd_fatal ("bfd_set_section_size");

  bfd_set_reloc (abfd, sec, cwi.relocs, cwi.reloc_count);

  offset = 0;
  for (d = cwi.dirs.d; d != NULL; d = d->next)
    {
      if (! bfd_set_section_contents (abfd, sec, d->data, offset, d->length))
	bfd_fatal ("bfd_set_section_contents");
      offset += d->length;
    }
  for (d = cwi.dirstrs.d; d != NULL; d = d->next)
    {
      set_windres_bfd_content (&wrbfd, d->data, offset, d->length);
      offset += d->length;
    }
  for (d = cwi.dataents.d; d != NULL; d = d->next)
    {
      set_windres_bfd_content (&wrbfd, d->data, offset, d->length);
      offset += d->length;
    }
  for (rd = cwi.resources.d; rd != NULL; rd = rd->next)
    {
      res_to_bin (cwi.wrbfd, (rc_uint_type) offset, rd->res);
      offset += rd->length;
    }

  assert (offset == length);

  if (! bfd_close (abfd))
    bfd_fatal ("bfd_close");

  /* We allocated the relocs array using malloc.  */
  free (cwi.relocs);
}

/* Work out the sizes of the various fixed size resource directory
   entries.  This updates fields in CWI.  */

static void
coff_bin_sizes (const rc_res_directory *resdir,
		struct coff_write_info *cwi)
{
  const rc_res_entry *re;

  cwi->dirsize += sizeof (struct extern_res_directory);

  for (re = resdir->entries; re != NULL; re = re->next)
    {
      cwi->dirsize += sizeof (struct extern_res_entry);

      if (re->id.named)
	cwi->dirstrsize += re->id.u.n.length * 2 + 2;

      if (re->subdir)
	coff_bin_sizes (re->u.dir, cwi);
      else
	cwi->dataentsize += sizeof (struct extern_res_data);
    }
}

/* Allocate data for a particular list.  */

static bfd_byte *
coff_alloc (struct bindata_build *bb, rc_uint_type size)
{
  bindata *d;

  d = (bindata *) reswr_alloc (sizeof (bindata));

  d->next = NULL;
  d->data = (bfd_byte *) reswr_alloc (size);
  d->length = size;

  if (bb->d == NULL)
    bb->d = d;
  else
    bb->last->next = d;
  bb->last = d;
  bb->length += size;

  return d->data;
}

/* Convert the resource directory RESDIR to binary.  */

static void
coff_to_bin (const rc_res_directory *resdir, struct coff_write_info *cwi)
{
  struct extern_res_directory *erd;
  int ci, cn;
  const rc_res_entry *e;
  struct extern_res_entry *ere;

  /* Write out the directory table.  */

  erd = ((struct extern_res_directory *)
	 coff_alloc (&cwi->dirs, sizeof (*erd)));

  windres_put_32 (cwi->wrbfd, erd->characteristics, resdir->characteristics);
  windres_put_32 (cwi->wrbfd, erd->time, resdir->time);
  windres_put_16 (cwi->wrbfd, erd->major, resdir->major);
  windres_put_16 (cwi->wrbfd, erd->minor, resdir->minor);

  ci = 0;
  cn = 0;
  for (e = resdir->entries; e != NULL; e = e->next)
    {
      if (e->id.named)
	++cn;
      else
	++ci;
    }

  windres_put_16 (cwi->wrbfd, erd->name_count, cn);
  windres_put_16 (cwi->wrbfd, erd->id_count, ci);

  /* Write out the data entries.  Note that we allocate space for all
     the entries before writing them out.  That permits a recursive
     call to work correctly when writing out subdirectories.  */

  ere = ((struct extern_res_entry *)
	 coff_alloc (&cwi->dirs, (ci + cn) * sizeof (*ere)));
  for (e = resdir->entries; e != NULL; e = e->next, ere++)
    {
      if (! e->id.named)
	windres_put_32 (cwi->wrbfd, ere->name, e->id.u.id);
      else
	{
	  bfd_byte *str;
	  rc_uint_type i;

	  /* For some reason existing files seem to have the high bit
             set on the address of the name, although that is not
             documented.  */
	  windres_put_32 (cwi->wrbfd, ere->name,
		     0x80000000 | (cwi->dirsize + cwi->dirstrs.length));

	  str = coff_alloc (&cwi->dirstrs, e->id.u.n.length * 2 + 2);
	  windres_put_16 (cwi->wrbfd, str, e->id.u.n.length);
	  for (i = 0; i < e->id.u.n.length; i++)
	    windres_put_16 (cwi->wrbfd, str + (i + 1) * sizeof (unichar), e->id.u.n.name[i]);
	}

      if (e->subdir)
	{
	  windres_put_32 (cwi->wrbfd, ere->rva, 0x80000000 | cwi->dirs.length);
	  coff_to_bin (e->u.dir, cwi);
	}
      else
	{
	  windres_put_32 (cwi->wrbfd, ere->rva,
		     cwi->dirsize + cwi->dirstrsize + cwi->dataents.length);

	  coff_res_to_bin (e->u.res, cwi);
	}
    }
}

/* Convert the resource RES to binary.  */

static void
coff_res_to_bin (const rc_res_resource *res, struct coff_write_info *cwi)
{
  arelent *r;
  struct extern_res_data *erd;
  coff_res_data *d;

  /* For some reason, although every other address is a section
     offset, the address of the resource data itself is an RVA.  That
     means that we need to generate a relocation for it.  We allocate
     the relocs array using malloc so that we can use realloc.  FIXME:
     This relocation handling is correct for the i386, but probably
     not for any other target.  */

  r = (arelent *) reswr_alloc (sizeof (arelent));
  r->sym_ptr_ptr = cwi->sympp;
  r->address = cwi->dirsize + cwi->dirstrsize + cwi->dataents.length;
  r->addend = 0;
  r->howto = bfd_reloc_type_lookup (WR_BFD (cwi->wrbfd), BFD_RELOC_RVA);
  if (r->howto == NULL)
    bfd_fatal (_("can't get BFD_RELOC_RVA relocation type"));

  cwi->relocs = xrealloc (cwi->relocs,
			  (cwi->reloc_count + 2) * sizeof (arelent *));
  cwi->relocs[cwi->reloc_count] = r;
  cwi->relocs[cwi->reloc_count + 1] = NULL;
  ++cwi->reloc_count;

  erd = (struct extern_res_data *) coff_alloc (&cwi->dataents, sizeof (*erd));

  windres_put_32 (cwi->wrbfd, erd->rva,
	     (cwi->dirsize
	      + cwi->dirstrsize
	      + cwi->dataentsize
	      + cwi->resources.length));
  windres_put_32 (cwi->wrbfd, erd->codepage, res->coff_info.codepage);
  windres_put_32 (cwi->wrbfd, erd->reserved, res->coff_info.reserved);

  d = (coff_res_data *) reswr_alloc (sizeof (coff_res_data));
  d->length = res_to_bin (NULL, (rc_uint_type) 0, res);
  d->res = res;
  d->next = NULL;

  if (cwi->resources.d == NULL)
    cwi->resources.d = d;
  else
    cwi->resources.last->next = d;

  cwi->resources.last = d;
  cwi->resources.length += (d->length + 3) & ~3;

  windres_put_32 (cwi->wrbfd, erd->size, d->length);

  /* Force the next resource to have 32 bit alignment.  */
  d->length = (d->length + 3) & ~3;
}
@


1.12
log
@update copyright dates
@
text
@d121 1
a121 1
  struct coff_file_info finfo;
d150 4
a153 4
  finfo.filename = filename;
  finfo.data = data;
  finfo.data_end = data + size;
  finfo.secaddr = (bfd_get_section_vma (abfd, sec)
d161 1
a161 1
  ret = read_coff_res_dir (&wrbfd, data, &finfo, (const rc_res_id *) NULL, 0);
d171 1
a171 1
overrun (const struct coff_file_info *finfo, const char *msg)
d173 1
a173 1
  fatal (_("%s: %s: address out of bounds"), finfo->filename, msg);
d180 1
a180 1
		   const struct coff_file_info *finfo,
d189 2
a190 2
  if ((size_t) (finfo->data_end - data) < sizeof (struct extern_res_directory))
    overrun (finfo, _("directory"));
d217 2
a218 2
      if ((const bfd_byte *) ere >= finfo->data_end)
	overrun (finfo, _("named directory entry"));
d226 2
a227 2
      if (name > (rc_uint_type) (finfo->data_end - finfo->data))
	overrun (finfo, _("directory entry name"));
d229 1
a229 1
      ers = finfo->data + name;
d246 2
a247 2
	  if (rva >= (rc_uint_type) (finfo->data_end - finfo->data))
	    overrun (finfo, _("named subdirectory"));
d249 1
a249 1
	  re->u.dir = read_coff_res_dir (wrbfd, finfo->data + rva, finfo, type,
d254 2
a255 2
	  if (rva >= (rc_uint_type) (finfo->data_end - finfo->data))
	    overrun (finfo, _("named resource"));
d257 1
a257 1
	  re->u.res = read_coff_data_entry (wrbfd, finfo->data + rva, finfo, type);
d269 2
a270 2
      if ((const bfd_byte *) ere >= finfo->data_end)
	overrun (finfo, _("ID directory entry"));
d286 2
a287 2
	  if (rva >= (rc_uint_type) (finfo->data_end - finfo->data))
	    overrun (finfo, _("ID subdirectory"));
d289 1
a289 1
	  re->u.dir = read_coff_res_dir (wrbfd, finfo->data + rva, finfo, type,
d294 2
a295 2
	  if (rva >= (rc_uint_type) (finfo->data_end - finfo->data))
	    overrun (finfo, _("ID resource"));
d297 1
a297 1
	  re->u.res = read_coff_data_entry (wrbfd, finfo->data + rva, finfo, type);
d311 1
a311 1
		      const struct coff_file_info *finfo,
d322 2
a323 2
  if ((size_t) (finfo->data_end - data) < sizeof (struct extern_res_data))
    overrun (finfo, _("data entry"));
d329 3
a331 3
  if (rva < finfo->secaddr
      || rva - finfo->secaddr >= (rc_uint_type) (finfo->data_end - finfo->data))
    overrun (finfo, _("resource data"));
d333 1
a333 1
  resdata = finfo->data + (rva - finfo->secaddr);
d335 2
a336 2
  if (size > (rc_uint_type) (finfo->data_end - resdata))
    overrun (finfo, _("resource data size"));
@


1.11
log
@	* ieee.c (write_ieee_debugging_info): Use bfd_make_section_with_flags.
	* nlmconv.c (main, powerpc_build_stubs): Likewise.
	* rescoff.c (write_coff_file): Likewise.
	* resres.c (write_res_file): Likewise.
	* windmc.c (windmc_write_bin): Likewise.
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2000, 2003, 2007, 2008
@


1.10
log
@Change sources over to using GPLv3
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2000, 2003, 2007
d458 3
a460 1
  sec = bfd_make_section (abfd, ".rsrc");
a463 5
  if (! bfd_set_section_flags (abfd, sec,
			       (SEC_HAS_CONTENTS | SEC_ALLOC
				| SEC_LOAD | SEC_DATA)))
    bfd_fatal ("bfd_set_section_flags");

@


1.9
log
@Updated windres tool
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
@


1.8
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d5 1
d29 1
a30 1
#include "bucomm.h"
d53 1
a53 3
  bfd_vma secaddr;
  /* Non-zero if the file is big endian.  */
  int big_endian;
d58 1
a58 1
struct extern_res_directory
a98 5
/* Macros to swap in values.  */

#define getfi_16(fi, s) ((fi)->big_endian ? bfd_getb16 (s) : bfd_getl16 (s))
#define getfi_32(fi, s) ((fi)->big_endian ? bfd_getb32 (s) : bfd_getl32 (s))

d102 6
a107 5
static struct res_directory *read_coff_res_dir
  (const bfd_byte *, const struct coff_file_info *,
   const struct res_id *, int);
static struct res_resource *read_coff_data_entry
  (const bfd_byte *, const struct coff_file_info *, const struct res_id *);
d111 1
a111 1
struct res_directory *
d114 1
d116 1
d144 1
d148 1
a148 2
  if (! bfd_get_section_contents (abfd, sec, data, 0, size))
    bfd_fatal (_("can't read resource section"));
a154 3
  finfo.big_endian = bfd_big_endian (abfd);

  bfd_close (abfd);
d161 5
a165 1
  return read_coff_res_dir (data, &finfo, (const struct res_id *) NULL, 0);
d178 4
a181 3
static struct res_directory *
read_coff_res_dir (const bfd_byte *data, const struct coff_file_info *finfo,
		   const struct res_id *type, int level)
d184 1
a184 1
  struct res_directory *rd;
d186 1
a186 1
  struct res_entry **pp;
d194 5
a198 5
  rd = (struct res_directory *) res_alloc (sizeof *rd);
  rd->characteristics = getfi_32 (finfo, erd->characteristics);
  rd->time = getfi_32 (finfo, erd->time);
  rd->major = getfi_16 (finfo, erd->major);
  rd->minor = getfi_16 (finfo, erd->minor);
d201 2
a202 2
  name_count = getfi_16 (finfo, erd->name_count);
  id_count = getfi_16 (finfo, erd->id_count);
d212 2
a213 2
      unsigned long name, rva;
      struct res_entry *re;
d220 2
a221 2
      name = getfi_32 (finfo, ere->name);
      rva = getfi_32 (finfo, ere->rva);
d226 1
a226 1
      if (name > (size_t) (finfo->data_end - finfo->data))
d231 1
a231 1
      re = (struct res_entry *) res_alloc (sizeof *re);
d234 1
a234 1
      length = getfi_16 (finfo, ers);
d238 1
a238 1
	re->id.u.n.name[j] = getfi_16 (finfo, ers + j * 2 + 2);
d246 1
a246 1
	  if (rva >= (size_t) (finfo->data_end - finfo->data))
d249 1
a249 1
	  re->u.dir = read_coff_res_dir (finfo->data + rva, finfo, type,
d254 1
a254 1
	  if (rva >= (size_t) (finfo->data_end - finfo->data))
d257 1
a257 1
	  re->u.res = read_coff_data_entry (finfo->data + rva, finfo, type);
d267 1
a267 1
      struct res_entry *re;
d272 2
a273 2
      name = getfi_32 (finfo, ere->name);
      rva = getfi_32 (finfo, ere->rva);
d275 1
a275 1
      re = (struct res_entry *) res_alloc (sizeof *re);
d286 1
a286 1
	  if (rva >= (size_t) (finfo->data_end - finfo->data))
d289 1
a289 1
	  re->u.dir = read_coff_res_dir (finfo->data + rva, finfo, type,
d294 1
a294 1
	  if (rva >= (size_t) (finfo->data_end - finfo->data))
d297 1
a297 1
	  re->u.res = read_coff_data_entry (finfo->data + rva, finfo, type);
d309 4
a312 2
static struct res_resource *
read_coff_data_entry (const bfd_byte *data, const struct coff_file_info *finfo, const struct res_id *type)
d315 2
a316 2
  struct res_resource *r;
  unsigned long size, rva;
d327 2
a328 2
  size = getfi_32 (finfo, erd->size);
  rva = getfi_32 (finfo, erd->rva);
d330 1
a330 1
      || rva - finfo->secaddr >= (size_t) (finfo->data_end - finfo->data))
d335 1
a335 1
  if (size > (size_t) (finfo->data_end - resdata))
d338 1
a338 1
  r = bin_to_res (*type, resdata, size, finfo->big_endian);
d340 3
a342 3
  memset (&r->res_info, 0, sizeof (struct res_res_info));
  r->coff_info.codepage = getfi_32 (finfo, erd->codepage);
  r->coff_info.reserved = getfi_32 (finfo, erd->reserved);
d352 1
a352 1
  struct bindata *d;
d354 11
a364 1
  struct bindata *last;
d376 1
a376 3
  bfd *abfd;
  /* Non-zero if the file is big endian.  */
  int big_endian;
d396 1
a396 1
  struct bindata_build resources;
d403 2
a404 10
/* Macros to swap out values.  */

#define putcwi_16(cwi, v, s) \
  ((cwi->big_endian) ? bfd_putb16 ((v), (s)) : bfd_putl16 ((v), (s)))
#define putcwi_32(cwi, v, s) \
  ((cwi->big_endian) ? bfd_putb32 ((v), (s)) : bfd_putl32 ((v), (s)))

static void coff_bin_sizes
  (const struct res_directory *, struct coff_write_info *);
static unsigned char *coff_alloc (struct bindata_build *, size_t);
d406 1
a406 1
  (const struct res_directory *, struct coff_write_info *);
d408 1
a408 1
  (const struct res_resource *, struct coff_write_info *);
d420 1
a420 1
		 const struct res_directory *resources)
d425 3
a427 1
  struct bindata *d;
d481 3
a483 2
  cwi.abfd = abfd;
  cwi.big_endian = bfd_big_endian (abfd);
d518 1
a518 1
      unsigned char *ex;
d550 1
a550 2
      if (! bfd_set_section_contents (abfd, sec, d->data, offset, d->length))
	bfd_fatal ("bfd_set_section_contents");
d555 1
a555 2
      if (! bfd_set_section_contents (abfd, sec, d->data, offset, d->length))
	bfd_fatal ("bfd_set_section_contents");
d558 1
a558 1
  for (d = cwi.resources.d; d != NULL; d = d->next)
d560 2
a561 3
      if (! bfd_set_section_contents (abfd, sec, d->data, offset, d->length))
	bfd_fatal ("bfd_set_section_contents");
      offset += d->length;
d577 1
a577 1
coff_bin_sizes (const struct res_directory *resdir,
d580 1
a580 1
  const struct res_entry *re;
d600 2
a601 2
static unsigned char *
coff_alloc (struct bindata_build *bb, size_t size)
d603 1
a603 1
  struct bindata *d;
d605 1
a605 1
  d = (struct bindata *) reswr_alloc (sizeof *d);
d608 1
a608 1
  d->data = (unsigned char *) reswr_alloc (size);
d624 1
a624 1
coff_to_bin (const struct res_directory *resdir, struct coff_write_info *cwi)
d628 1
a628 1
  const struct res_entry *e;
d636 4
a639 4
  putcwi_32 (cwi, resdir->characteristics, erd->characteristics);
  putcwi_32 (cwi, resdir->time, erd->time);
  putcwi_16 (cwi, resdir->major, erd->major);
  putcwi_16 (cwi, resdir->minor, erd->minor);
d651 2
a652 2
  putcwi_16 (cwi, cn, erd->name_count);
  putcwi_16 (cwi, ci, erd->id_count);
d663 1
a663 1
	putcwi_32 (cwi, e->id.u.id, ere->name);
d666 2
a667 2
	  unsigned char *str;
	  int i;
d672 2
a673 3
	  putcwi_32 (cwi,
		     0x80000000 | (cwi->dirsize + cwi->dirstrs.length),
		     ere->name);
d676 1
a676 1
	  putcwi_16 (cwi, e->id.u.n.length, str);
d678 1
a678 1
	    putcwi_16 (cwi, e->id.u.n.name[i], str + i * 2 + 2);
d683 1
a683 1
	  putcwi_32 (cwi, 0x80000000 | cwi->dirs.length, ere->rva);
d688 2
a689 3
	  putcwi_32 (cwi,
		     cwi->dirsize + cwi->dirstrsize + cwi->dataents.length,
		     ere->rva);
d699 1
a699 1
coff_res_to_bin (const struct res_resource *res, struct coff_write_info *cwi)
d703 1
a703 2
  struct bindata *d;
  unsigned long length;
d716 1
a716 1
  r->howto = bfd_reloc_type_lookup (cwi->abfd, BFD_RELOC_RVA);
d728 1
a728 1
  putcwi_32 (cwi,
d732 8
a739 6
	      + cwi->resources.length),
	     erd->rva);
  putcwi_32 (cwi, res->coff_info.codepage, erd->codepage);
  putcwi_32 (cwi, res->coff_info.reserved, erd->reserved);

  d = res_to_bin (res, cwi->big_endian);
a745 4
  length = 0;
  for (; d->next != NULL; d = d->next)
    length += d->length;
  length += d->length;
d747 1
a747 1
  cwi->resources.length += length;
d749 1
a749 1
  putcwi_32 (cwi, length, erd->size);
d752 1
a752 11

  if ((length & 3) != 0)
    {
      int add;
      unsigned char *ex;

      add = 4 - (length & 3);

      ex = coff_alloc (&cwi->resources, add);
      memset (ex, 0, add);
    }
@


1.7
log
@Update FSF address
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2000, 2003
d26 1
d28 1
a29 1
#include "libiberty.h"
@


1.6
log
@	* addr2line.c: Convert to ISO C90 prototypes, change PTR, remove
	unneeded (void *) casts.
	* ar.c: Likewise.
	* arlex.l: Likewise.
	* arparse.y: Likewise.
	* arsup.c: Likewise.
	* binemul.c: Likewise.
	* binemul.h: Likewise.
	* bucomm.c: Likewise.
	* bucomm.h: Likewise.
	* budbg.h: Likewise.
	* budemang.c: Likewise.
	* budemang.h: Likewise.
	* coffdump.c: Likewise.
	* coffgrok.c: Likewise.
	* cxxfilt.c: Likewise.
	* debug.c: Likewise.
	* debug.h: Likewise.
	* deflex.l: Likewise.
	* dlltool.c: Likewise.
	* dlltool.h: Likewise.
	* dllwrap.c: Likewise.
	* emul_aix.c: Likewise.
	* filemode.c: Likewise.
	* ieee.c: Likewise.
	* nlmconv.c: Likewise.
	* nlmconv.h: Likewise.
	* nlmheader.y: Likewise.
	* nm.c: Likewise.
	* prdbg.c: Likewise.
	* rclex.l: Likewise.
	* rcparse.y: Likewise.
	* rdcoff.c: Likewise.
	* rddbg.c: Likewise.
	* rename.c: Likewise.
	* resbin.c: Likewise.
	* rescoff.c: Likewise.
	* resrc.c: Likewise.
	* size.c: Likewise.
	* srconv.c: Likewise.
	* stabs.c: Likewise.
	* strings.c: Likewise.
	* sysdump.c: Likewise.
	* sysinfo.y: Likewise.
	* syslex.l: Likewise.
	* unwind-ia64.c: Likewise.
	* unwind-ia64.h: Likewise.
	* version.c: Likewise.
	* windres.c: Likewise.
	* windres.h: Likewise.
	* winduni.c: Likewise.
	* wrstabs.c: Likewise.
@
text
@d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.5
log
@Fix typos in ChangeLogs and update copyright notices
@
text
@d2 2
a3 1
   Copyright 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
d106 1
a106 1
static void overrun PARAMS ((const struct coff_file_info *, const char *));
d108 2
a109 2
  PARAMS ((const bfd_byte *, const struct coff_file_info *,
	   const struct res_id *, int));
d111 1
a111 2
  PARAMS ((const bfd_byte *, const struct coff_file_info *,
	   const struct res_id *));
d116 1
a116 3
read_coff_rsrc (filename, target)
     const char *filename;
     const char *target;
d172 1
a172 3
overrun (finfo, msg)
     const struct coff_file_info *finfo;
     const char *msg;
d180 2
a181 5
read_coff_res_dir (data, finfo, type, level)
     const bfd_byte *data;
     const struct coff_file_info *finfo;
     const struct res_id *type;
     int level;
d310 1
a310 4
read_coff_data_entry (data, finfo, type)
     const bfd_byte *data;
     const struct coff_file_info *finfo;
     const struct res_id *type;
d401 2
a402 2
  PARAMS ((const struct res_directory *, struct coff_write_info *));
static unsigned char *coff_alloc PARAMS ((struct bindata_build *, size_t));
d404 1
a404 1
  PARAMS ((const struct res_directory *, struct coff_write_info *));
d406 1
a406 1
  PARAMS ((const struct res_resource *, struct coff_write_info *));
d417 2
a418 4
write_coff_file (filename, target, resources)
     const char *filename;
     const char *target;
     const struct res_directory *resources;
d575 2
a576 3
coff_bin_sizes (resdir, cwi)
     const struct res_directory *resdir;
     struct coff_write_info *cwi;
d599 1
a599 3
coff_alloc (bb, size)
     struct bindata_build *bb;
     size_t size;
d622 1
a622 3
coff_to_bin (resdir, cwi)
     const struct res_directory *resdir;
     struct coff_write_info *cwi;
d699 1
a699 3
coff_res_to_bin (res, cwi)
     const struct res_resource *res;
     struct coff_write_info *cwi;
@


1.4
log
@A mostly cosmetic tidy up of warnings and error message reporting.
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 2000 Free Software Foundation, Inc.
@


1.4.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
@


1.3
log
@Add support for WinCE targeted toolchains.
@
text
@d145 1
a145 3
      fprintf (stderr, _("%s: %s: no resource section\n"), program_name,
	       filename);
      xexit (1);
@


1.3.2.1
log
@A mostly cosmetic tidy up of warnings and error message reporting.
@
text
@d145 3
a147 1
      fatal (_("%s: no resource section"), filename);
@


1.2
log
@1999-05-10  DJ Delorie  <dj@@cygnus.com>
	* windres.c (quot): Quote shell metacharacters in a string
	(main): quote parameters to cpp that might have metacharacters in
	them.  Allow -D as an alias for --define to allow for sharing make
	macros with gcc.
	* objdump.c (dump_reloc_set): don't core if howto->name is NULL
	* Makefile.am: Give rescoff.c a cpu-specific -D so it can set
	the correct BFD.
	* Makefile.in: ditto
	* rescoff.c (write_coff_file): Set the correct BFD
@
text
@d2 1
a2 1
   Copyright 1997, 1998 Free Software Foundation, Inc.
d450 7
a456 1
#ifdef DLLTOOL_ARM
d463 1
a463 1
#endif /* arm */
@


1.1
log
@Initial revision
@
text
@d450 4
d456 2
a457 1
    bfd_fatal ("bfd_set_arch_mach");
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

