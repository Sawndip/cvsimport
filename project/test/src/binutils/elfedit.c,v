head	1.10;
access;
symbols
	binutils-2_24-branch:1.10.0.4
	binutils-2_24-branchpoint:1.10
	binutils-2_21_1:1.6.2.1
	binutils-2_23_2:1.10
	binutils-2_23_1:1.10
	binutils-2_23:1.10
	binutils-2_23-branch:1.10.0.2
	binutils-2_23-branchpoint:1.10
	binutils-2_22_branch:1.9.0.4
	binutils-2_22:1.9
	binutils-2_22-branch:1.9.0.2
	binutils-2_22-branchpoint:1.9
	binutils-2_21:1.6
	binutils-2_21-branch:1.6.0.2
	binutils-2_21-branchpoint:1.6
	binutils_latest_snapshot:1.10;
locks; strict;
comment	@ * @;


1.10
date	2012.02.09.04.51.43;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2011.07.22.20.22.34;	author hjl;	state Exp;
branches;
next	1.8;

1.8
date	2011.07.03.13.37.07;	author tschwinge;	state Exp;
branches;
next	1.7;

1.7
date	2010.11.21.21.27.15;	author hjl;	state Exp;
branches;
next	1.6;

1.6
date	2010.08.23.16.25.52;	author hjl;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	2010.04.09.14.40.13;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2010.01.08.18.50.38;	author hjl;	state Exp;
branches;
next	1.3;

1.3
date	2010.01.08.15.58.08;	author hjl;	state Exp;
branches;
next	1.2;

1.2
date	2010.01.07.20.49.23;	author hjl;	state Exp;
branches;
next	1.1;

1.1
date	2010.01.06.16.52.14;	author hjl;	state Exp;
branches;
next	;

1.6.2.1
date	2011.02.01.12.25.36;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.10
log
@	* sysdep.h: Include sys/stat.h here.
	* ar.c: Don't include headers already included by sysdep.h.
	* bucomm.c: Likewise.
	* budbg.h: Likewise.
	* dlltool.h: Likewise.
	* elfedit.c: Likewise.
	* nlmconv.c: Likewise.
	* objcopy.c: Likewise.
	* objdump.c: Likewise.
	* objdump.h: Likewise.
	* readelf.c: Likewise.
	* rename.c: Likewise.
	* resrc.c: Likewise.
	* strings.c: Likewise.
	* windres.c: Likewise.
	* od-macho.c: Ensure #include sysdep.h is first.
	* od-xcoff.c: Likewise.
	* dllwrap.c: Remove alloca pragma handled by sysdep.h, and
	remove duplicate headers.
	* dlltool.c: Likewise and ensure #include sysdep.h is first.
@
text
@/* elfedit.c -- Update the ELF header of an ELF format file
   Copyright 2010, 2011, 2012
   Free Software Foundation, Inc.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include "sysdep.h"
#include <assert.h>

#if __GNUC__ >= 2
/* Define BFD64 here, even if our default architecture is 32 bit ELF
   as this will allow us to read in and parse 64bit and 32bit ELF files.
   Only do this if we believe that the compiler can support a 64 bit
   data type.  For now we only rely on GCC being able to do this.  */
#define BFD64
#endif

#include "bfd.h"
#include "elfcomm.h"
#include "bucomm.h"

#include "elf/common.h"
#include "elf/external.h"
#include "elf/internal.h"

#include "getopt.h"
#include "libiberty.h"
#include "safe-ctype.h"
#include "filenames.h"

char * program_name = "elfedit";
static long archive_file_offset;
static unsigned long archive_file_size;
static Elf_Internal_Ehdr elf_header;
static Elf32_External_Ehdr ehdr32;
static Elf64_External_Ehdr ehdr64;
static int input_elf_machine = -1;
static int output_elf_machine = -1;
static int input_elf_type = -1;
static int output_elf_type = -1;
static int input_elf_osabi = -1;
static int output_elf_osabi = -1;
static int input_elf_class = -1;

static int
update_elf_header (const char *file_name, FILE *file)
{
  int class, machine, type, status, osabi;

  if (elf_header.e_ident[EI_MAG0] != ELFMAG0
      || elf_header.e_ident[EI_MAG1] != ELFMAG1
      || elf_header.e_ident[EI_MAG2] != ELFMAG2
      || elf_header.e_ident[EI_MAG3] != ELFMAG3)
    {
      error
	(_("%s: Not an ELF file - wrong magic bytes at the start\n"),
	 file_name);
      return 0;
    }

  if (elf_header.e_ident[EI_VERSION] != EV_CURRENT)
    {
      error
	(_("%s: Unsupported EI_VERSION: %d is not %d\n"),
	 file_name, elf_header.e_ident[EI_VERSION],
	 EV_CURRENT);
      return 0;
    }

  /* Return if e_machine is the same as output_elf_machine.  */
  if (output_elf_machine == elf_header.e_machine)
    return 1;

  class = elf_header.e_ident[EI_CLASS];

  /* Skip if class doesn't match. */
  if (input_elf_class != -1 && class != input_elf_class)
    {
      error
	(_("%s: Unmatched EI_CLASS: %d is not %d\n"),
	 file_name, class, input_elf_class);
      return 0;
    }

  machine = elf_header.e_machine;

  /* Skip if e_machine doesn't match. */
  if (input_elf_machine != -1 && machine != input_elf_machine)
    {
      error
	(_("%s: Unmatched e_machine: %d is not %d\n"),
	 file_name, machine, input_elf_machine);
      return 0;
    }

  type = elf_header.e_type;

  /* Skip if e_type doesn't match. */
  if (input_elf_type != -1 && type != input_elf_type)
    {
      error
	(_("%s: Unmatched e_type: %d is not %d\n"),
	 file_name, type, input_elf_type);
      return 0;
    }

  osabi = elf_header.e_ident[EI_OSABI];

  /* Skip if OSABI doesn't match. */
  if (input_elf_osabi != -1 && osabi != input_elf_osabi)
    {
      error
	(_("%s: Unmatched EI_OSABI: %d is not %d\n"),
	 file_name, osabi, input_elf_osabi);
      return 0;
    }

  /* Update e_machine, e_type and EI_OSABI.  */
  switch (class)
    {
    default:
      /* We should never get here.  */
      abort ();
      break;
    case ELFCLASS32:
      if (output_elf_machine != -1)
	BYTE_PUT (ehdr32.e_machine, output_elf_machine);
      if (output_elf_type != -1)
	BYTE_PUT (ehdr32.e_type, output_elf_type);
      if (output_elf_osabi != -1)
	ehdr32.e_ident[EI_OSABI] = output_elf_osabi;
      status = fwrite (&ehdr32, sizeof (ehdr32), 1, file) == 1;
      break;
    case ELFCLASS64:
      if (output_elf_machine != -1)
	BYTE_PUT (ehdr64.e_machine, output_elf_machine);
      if (output_elf_type != -1)
	BYTE_PUT (ehdr64.e_type, output_elf_type);
      if (output_elf_osabi != -1)
	ehdr64.e_ident[EI_OSABI] = output_elf_osabi;
      status = fwrite (&ehdr64, sizeof (ehdr64), 1, file) == 1;
      break;
    }

  if (status != 1)
    error (_("%s: Failed to update ELF header: %s\n"),
	       file_name, strerror (errno));

  return status;
}

static int
get_file_header (FILE * file)
{
  /* Read in the identity array.  */
  if (fread (elf_header.e_ident, EI_NIDENT, 1, file) != 1)
    return 0;

  /* Determine how to read the rest of the header.  */
  switch (elf_header.e_ident[EI_DATA])
    {
    default: /* fall through */
    case ELFDATANONE: /* fall through */
    case ELFDATA2LSB:
      byte_get = byte_get_little_endian;
      byte_put = byte_put_little_endian;
      break;
    case ELFDATA2MSB:
      byte_get = byte_get_big_endian;
      byte_put = byte_put_big_endian;
      break;
    }

  /* Read in the rest of the header.  For now we only support 32 bit
     and 64 bit ELF files.  */
  switch (elf_header.e_ident[EI_CLASS])
    {
    default:
      error (_("Unsupported EI_CLASS: %d\n"),
		 elf_header.e_ident[EI_CLASS]);
      return 0;

    case ELFCLASS32:
      if (fread (ehdr32.e_type, sizeof (ehdr32) - EI_NIDENT,
		 1, file) != 1)
	return 0;

      elf_header.e_type      = BYTE_GET (ehdr32.e_type);
      elf_header.e_machine   = BYTE_GET (ehdr32.e_machine);
      elf_header.e_version   = BYTE_GET (ehdr32.e_version);
      elf_header.e_entry     = BYTE_GET (ehdr32.e_entry);
      elf_header.e_phoff     = BYTE_GET (ehdr32.e_phoff);
      elf_header.e_shoff     = BYTE_GET (ehdr32.e_shoff);
      elf_header.e_flags     = BYTE_GET (ehdr32.e_flags);
      elf_header.e_ehsize    = BYTE_GET (ehdr32.e_ehsize);
      elf_header.e_phentsize = BYTE_GET (ehdr32.e_phentsize);
      elf_header.e_phnum     = BYTE_GET (ehdr32.e_phnum);
      elf_header.e_shentsize = BYTE_GET (ehdr32.e_shentsize);
      elf_header.e_shnum     = BYTE_GET (ehdr32.e_shnum);
      elf_header.e_shstrndx  = BYTE_GET (ehdr32.e_shstrndx);

      memcpy (&ehdr32, &elf_header, EI_NIDENT);
      break;

    case ELFCLASS64:
      /* If we have been compiled with sizeof (bfd_vma) == 4, then
	 we will not be able to cope with the 64bit data found in
	 64 ELF files.  Detect this now and abort before we start
	 overwriting things.  */
      if (sizeof (bfd_vma) < 8)
	{
	  error (_("This executable has been built without support for a\n\
64 bit data type and so it cannot process 64 bit ELF files.\n"));
	  return 0;
	}

      if (fread (ehdr64.e_type, sizeof (ehdr64) - EI_NIDENT,
		 1, file) != 1)
	return 0;

      elf_header.e_type      = BYTE_GET (ehdr64.e_type);
      elf_header.e_machine   = BYTE_GET (ehdr64.e_machine);
      elf_header.e_version   = BYTE_GET (ehdr64.e_version);
      elf_header.e_entry     = BYTE_GET (ehdr64.e_entry);
      elf_header.e_phoff     = BYTE_GET (ehdr64.e_phoff);
      elf_header.e_shoff     = BYTE_GET (ehdr64.e_shoff);
      elf_header.e_flags     = BYTE_GET (ehdr64.e_flags);
      elf_header.e_ehsize    = BYTE_GET (ehdr64.e_ehsize);
      elf_header.e_phentsize = BYTE_GET (ehdr64.e_phentsize);
      elf_header.e_phnum     = BYTE_GET (ehdr64.e_phnum);
      elf_header.e_shentsize = BYTE_GET (ehdr64.e_shentsize);
      elf_header.e_shnum     = BYTE_GET (ehdr64.e_shnum);
      elf_header.e_shstrndx  = BYTE_GET (ehdr64.e_shstrndx);

      memcpy (&ehdr64, &elf_header, EI_NIDENT);
      break;
    }
  return 1;
}

/* Process one ELF object file according to the command line options.
   This file may actually be stored in an archive.  The file is
   positioned at the start of the ELF object.  */

static int
process_object (const char *file_name, FILE *file)
{
  /* Rememeber where we are.  */
  long offset = ftell (file);

  if (! get_file_header (file))
    {
      error (_("%s: Failed to read ELF header\n"), file_name);
      return 1;
    }

  /* Go to the position of the ELF header.  */
  if (fseek (file, offset, SEEK_SET) != 0)
    {
      error (_("%s: Failed to seek to ELF header\n"), file_name);
    }

  if (! update_elf_header (file_name, file))
    return 1;

  return 0;
}

/* Process an ELF archive.
   On entry the file is positioned just after the ARMAG string.  */

static int
process_archive (const char * file_name, FILE * file,
		 bfd_boolean is_thin_archive)
{
  struct archive_info arch;
  struct archive_info nested_arch;
  size_t got;
  int ret;

  /* The ARCH structure is used to hold information about this archive.  */
  arch.file_name = NULL;
  arch.file = NULL;
  arch.index_array = NULL;
  arch.sym_table = NULL;
  arch.longnames = NULL;

  /* The NESTED_ARCH structure is used as a single-item cache of information
     about a nested archive (when members of a thin archive reside within
     another regular archive file).  */
  nested_arch.file_name = NULL;
  nested_arch.file = NULL;
  nested_arch.index_array = NULL;
  nested_arch.sym_table = NULL;
  nested_arch.longnames = NULL;

  if (setup_archive (&arch, file_name, file, is_thin_archive, FALSE) != 0)
    {
      ret = 1;
      goto out;
    }

  ret = 0;

  while (1)
    {
      char * name;
      size_t namelen;
      char * qualified_name;

      /* Read the next archive header.  */
      if (fseek (file, arch.next_arhdr_offset, SEEK_SET) != 0)
        {
          error (_("%s: failed to seek to next archive header\n"),
		     file_name);
          return 1;
        }
      got = fread (&arch.arhdr, 1, sizeof arch.arhdr, file);
      if (got != sizeof arch.arhdr)
        {
          if (got == 0)
	    break;
          error (_("%s: failed to read archive header\n"),
		     file_name);
          ret = 1;
          break;
        }
      if (memcmp (arch.arhdr.ar_fmag, ARFMAG, 2) != 0)
        {
          error (_("%s: did not find a valid archive header\n"),
		     arch.file_name);
          ret = 1;
          break;
        }

      arch.next_arhdr_offset += sizeof arch.arhdr;

      archive_file_size = strtoul (arch.arhdr.ar_size, NULL, 10);
      if (archive_file_size & 01)
        ++archive_file_size;

      name = get_archive_member_name (&arch, &nested_arch);
      if (name == NULL)
	{
	  error (_("%s: bad archive file name\n"), file_name);
	  ret = 1;
	  break;
	}
      namelen = strlen (name);

      qualified_name = make_qualified_name (&arch, &nested_arch, name);
      if (qualified_name == NULL)
	{
	  error (_("%s: bad archive file name\n"), file_name);
	  ret = 1;
	  break;
	}

      if (is_thin_archive && arch.nested_member_origin == 0)
        {
          /* This is a proxy for an external member of a thin archive.  */
          FILE *member_file;
          char *member_file_name = adjust_relative_path (file_name,
							 name, namelen);
          if (member_file_name == NULL)
            {
              ret = 1;
              break;
            }

          member_file = fopen (member_file_name, "r+b");
          if (member_file == NULL)
            {
              error (_("Input file '%s' is not readable\n"),
			 member_file_name);
              free (member_file_name);
              ret = 1;
              break;
            }

          archive_file_offset = arch.nested_member_origin;

          ret |= process_object (qualified_name, member_file);

          fclose (member_file);
          free (member_file_name);
        }
      else if (is_thin_archive)
        {
          /* This is a proxy for a member of a nested archive.  */
          archive_file_offset = arch.nested_member_origin + sizeof arch.arhdr;

          /* The nested archive file will have been opened and setup by
             get_archive_member_name.  */
          if (fseek (nested_arch.file, archive_file_offset,
		     SEEK_SET) != 0)
            {
              error (_("%s: failed to seek to archive member\n"),
			 nested_arch.file_name);
              ret = 1;
              break;
            }

          ret |= process_object (qualified_name, nested_arch.file);
        }
      else
        {
          archive_file_offset = arch.next_arhdr_offset;
          arch.next_arhdr_offset += archive_file_size;

          ret |= process_object (qualified_name, file);
        }

      free (qualified_name);
    }

 out:
  if (nested_arch.file != NULL)
    fclose (nested_arch.file);
  release_archive (&nested_arch);
  release_archive (&arch);

  return ret;
}

static int
check_file (const char *file_name, struct stat *statbuf_p)
{
  struct stat statbuf;

  if (statbuf_p == NULL)
    statbuf_p = &statbuf;

  if (stat (file_name, statbuf_p) < 0)
    {
      if (errno == ENOENT)
	error (_("'%s': No such file\n"), file_name);
      else
	error (_("Could not locate '%s'.  System error message: %s\n"),
		   file_name, strerror (errno));
      return 1;
    }

  if (! S_ISREG (statbuf_p->st_mode))
    {
      error (_("'%s' is not an ordinary file\n"), file_name);
      return 1;
    }

  return 0;
}

static int
process_file (const char *file_name)
{
  FILE * file;
  char armag[SARMAG];
  int ret;

  if (check_file (file_name, NULL))
    return 1;

  file = fopen (file_name, "r+b");
  if (file == NULL)
    {
      error (_("Input file '%s' is not readable\n"), file_name);
      return 1;
    }

  if (fread (armag, SARMAG, 1, file) != 1)
    {
      error (_("%s: Failed to read file's magic number\n"),
		 file_name);
      fclose (file);
      return 1;
    }

  if (memcmp (armag, ARMAG, SARMAG) == 0)
    ret = process_archive (file_name, file, FALSE);
  else if (memcmp (armag, ARMAGT, SARMAG) == 0)
    ret = process_archive (file_name, file, TRUE);
  else
    {
      rewind (file);
      archive_file_size = archive_file_offset = 0;
      ret = process_object (file_name, file);
    }

  fclose (file);

  return ret;
}

static const struct
{
  int osabi;
  const char *name;
}
osabis[] =
{
  { ELFOSABI_NONE, "none" },
  { ELFOSABI_HPUX, "HPUX" },
  { ELFOSABI_NETBSD, "NetBSD" },
  { ELFOSABI_GNU, "GNU" },
  { ELFOSABI_GNU, "Linux" },
  { ELFOSABI_SOLARIS, "Solaris" },
  { ELFOSABI_AIX, "AIX" },
  { ELFOSABI_IRIX, "Irix" },
  { ELFOSABI_FREEBSD, "FreeBSD" },
  { ELFOSABI_TRU64, "TRU64" },
  { ELFOSABI_MODESTO, "Modesto" },
  { ELFOSABI_OPENBSD, "OpenBSD" },
  { ELFOSABI_OPENVMS, "OpenVMS" },
  { ELFOSABI_NSK, "NSK" },
  { ELFOSABI_AROS, "AROS" },
  { ELFOSABI_FENIXOS, "FenixOS" }
};

/* Return ELFOSABI_XXX for an OSABI string, OSABI.  */

static int
elf_osabi (const char *osabi)
{
  unsigned int i;

  for (i = 0; i < ARRAY_SIZE (osabis); i++)
    if (strcasecmp (osabi, osabis[i].name) == 0)
      return osabis[i].osabi;

  error (_("Unknown OSABI: %s\n"), osabi);

  return -1;
}

/* Return EM_XXX for a machine string, MACH.  */

static int
elf_machine (const char *mach)
{
  if (strcasecmp (mach, "l1om") == 0)
    return EM_L1OM;
  if (strcasecmp (mach, "k1om") == 0)
    return EM_K1OM;
  if (strcasecmp (mach, "x86_64") == 0)
    return EM_X86_64;
  if (strcasecmp (mach, "x86-64") == 0)
    return EM_X86_64;
  if (strcasecmp (mach, "none") == 0)
    return EM_NONE;

  error (_("Unknown machine type: %s\n"), mach);

  return -1;
}

/* Return ELF class for a machine type, MACH.  */

static int
elf_class (int mach)
{
  switch (mach)
    {
    case EM_L1OM:
    case EM_K1OM:
    case EM_X86_64:
      return ELFCLASS64;
    case EM_NONE:
      return ELFCLASSNONE;
    default:
      error (_("Unknown machine type: %d\n"), mach);
      return -1;
    }
}

/* Return ET_XXX for a type string, TYPE.  */

static int
elf_type (const char *type)
{
  if (strcasecmp (type, "rel") == 0)
    return ET_REL;
  if (strcasecmp (type, "exec") == 0)
    return ET_EXEC;
  if (strcasecmp (type, "dyn") == 0)
    return ET_DYN;
  if (strcasecmp (type, "none") == 0)
    return ET_NONE;

  error (_("Unknown type: %s\n"), type);

  return -1;
}

enum command_line_switch
  {
    OPTION_INPUT_MACH = 150,
    OPTION_OUTPUT_MACH,
    OPTION_INPUT_TYPE,
    OPTION_OUTPUT_TYPE,
    OPTION_INPUT_OSABI,
    OPTION_OUTPUT_OSABI
  };

static struct option options[] =
{
  {"input-mach",	required_argument, 0, OPTION_INPUT_MACH},
  {"output-mach",	required_argument, 0, OPTION_OUTPUT_MACH},
  {"input-type",	required_argument, 0, OPTION_INPUT_TYPE},
  {"output-type",	required_argument, 0, OPTION_OUTPUT_TYPE},
  {"input-osabi",	required_argument, 0, OPTION_INPUT_OSABI},
  {"output-osabi",	required_argument, 0, OPTION_OUTPUT_OSABI},
  {"version",		no_argument, 0, 'v'},
  {"help",		no_argument, 0, 'h'},
  {0,			no_argument, 0, 0}
};

static void
usage (FILE *stream, int exit_status)
{
  fprintf (stream, _("Usage: %s <option(s)> elffile(s)\n"),
	   program_name);
  fprintf (stream, _(" Update the ELF header of ELF files\n"));
  fprintf (stream, _(" The options are:\n"));
  fprintf (stream, _("\
  --input-mach <machine>      Set input machine type to <machine>\n\
  --output-mach <machine>     Set output machine type to <machine>\n\
  --input-type <type>         Set input file type to <type>\n\
  --output-type <type>        Set output file type to <type>\n\
  --input-osabi <osabi>       Set input OSABI to <osabi>\n\
  --output-osabi <osabi>      Set output OSABI to <osabi>\n\
  -h --help                   Display this information\n\
  -v --version                Display the version number of %s\n\
"),
	   program_name);
  if (REPORT_BUGS_TO[0] && exit_status == 0)
    fprintf (stream, _("Report bugs to %s\n"), REPORT_BUGS_TO);
  exit (exit_status);
}

int
main (int argc, char ** argv)
{
  int c, status;

#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

  expandargv (&argc, &argv);

  while ((c = getopt_long (argc, argv, "hv",
			   options, (int *) 0)) != EOF)
    {
      switch (c)
	{
	case OPTION_INPUT_MACH:
	  input_elf_machine = elf_machine (optarg);
	  if (input_elf_machine < 0)
	    return 1;
	  input_elf_class = elf_class (input_elf_machine);
	  if (input_elf_class < 0)
	    return 1;
	  break;

	case OPTION_OUTPUT_MACH:
	  output_elf_machine = elf_machine (optarg);
	  if (output_elf_machine < 0)
	    return 1;
	  break;

	case OPTION_INPUT_TYPE:
	  input_elf_type = elf_type (optarg);
	  if (input_elf_type < 0)
	    return 1;
	  break;

	case OPTION_OUTPUT_TYPE:
	  output_elf_type = elf_type (optarg);
	  if (output_elf_type < 0)
	    return 1;
	  break;

	case OPTION_INPUT_OSABI:
	  input_elf_osabi = elf_osabi (optarg);
	  if (input_elf_osabi < 0)
	    return 1;
	  break;

	case OPTION_OUTPUT_OSABI:
	  output_elf_osabi = elf_osabi (optarg);
	  if (output_elf_osabi < 0)
	    return 1;
	  break;

	case 'h':
	  usage (stdout, 0);

	case 'v':
	  print_version (program_name);
	  break;

	default:
	  usage (stderr, 1);
	}
    }

  if (optind == argc
      || (output_elf_machine == -1
	  && output_elf_type == -1
	  && output_elf_osabi == -1))
    usage (stderr, 1);

  status = 0;
  while (optind < argc)
    status |= process_file (argv[optind++]);

  return status;
}
@


1.9
log
@Add initial Intel K1OM support.

bfd/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.am (ALL_MACHINES): Add cpu-k1om.lo.
	(ALL_MACHINES_CFILES): Add cpu-k1om.c.
	* Makefile.in: Regenerated.

	* archures.c (bfd_architecture): Add bfd_arch_k1om.
	(bfd_k1om_arch): New.
	(bfd_archures_list): Add &bfd_k1om_arch.
	* bfd-in2.h: Regenerated.

	* config.bfd (targ64_selvecs): Add bfd_elf64_k1om_vec if
	bfd_elf64_x86_64_vec is supported.  Add bfd_elf64_k1om_freebsd_vec
	if bfd_elf64_x86_64_freebsd_vec is supported.
	(targ_selvecs): Likewise.

	* configure.in: Support bfd_elf64_k1om_vec and
	bfd_elf64_k1om_freebsd_vec.
	* configure: Regenerated.

	* cpu-k1om.c: New.

	* elf64-x86-64.c (elf64_k1om_elf_object_p): New.
	(bfd_elf64_k1om_vec): Likewise.
	(bfd_elf64_k1om_freebsd_vec): Likewise.

	* targets.c (bfd_elf64_k1om_vec): New.
	(bfd_elf64_k1om_freebsd_vec): Likewise.
	(_bfd_target_vector): Add bfd_elf64_k1om_vec and
	bfd_elf64_k1om_freebsd_vec.

binutils/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* dwarf.c (init_dwarf_regnames): Handle EM_K1OM.

	* elfedit.c (elf_machine): Support EM_K1OM.
	(elf_class): Likewise.

	* readelf.c (guess_is_rela): Handle EM_K1OM.
	(dump_relocations): Likewise.
	(get_machine_name): Likewise.
	(get_section_type_name): Likewise.
	(get_elf_section_flags): Likewise.
	(process_section_headers): Likewise.
	(get_symbol_index_type): Likewise.
	(is_32bit_abs_reloc): Likewise.
	(is_32bit_pcrel_reloc): Likewise.
	(is_64bit_abs_reloc): Likewise.
	(is_64bit_pcrel_reloc): Likewise.
	(is_none_reloc): Likewise.

	* doc/binutils.texi: Mention K1OM for elfedit.

binutils/testsuite/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* binutils-all/elfedit.exp: Run elfedit-4.

	* binutils-all/elfedit-4.d: New.

gas/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/tc-i386.c (cpu_arch): Add k1om.
	(i386_align_code): Handle PROCESSOR_K1OM.
	(check_cpu_arch_compatible): Check EM_K1OM.
	(i386_arch): Handle Intel K1OM.
	(i386_mach): Return bfd_mach_k1om for Intel K1OM.
	(i386_target_format): Return ELF_TARGET_K1OM_FORMAT for Intel
	K1OM.

	* config/tc-i386.h (ELF_TARGET_K1OM_FORMAT): New.
	(processor_type): Add PROCESSOR_K1OM.

	* doc/c-i386.texi: Document k1om.

gas/testsuite/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/i386/k1om.d: New.
	* gas/i386/k1om-inval.l: Likewise.
	* gas/i386/k1om-inval.s: Likewise.

	* gas/i386/i386.exp: Run k1om-inval and k1om.

include/elf/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* common.h (EM_K1OM): New.

ld/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.am (ALL_64_EMULATIONS): Add eelf_k1om.o and
	eelf_k1om_fbsd.o
	(eelf_k1om.c): New.
	(eelf_k1om_fbsd.c): Likewise.
	* Makefile.in: Regenerated.

	* configure.tgt (targ64_extra_emuls): Add elf_k1om if elf_x86_64
	is supported.  Add elf_k1om_fbsd if elf_x86_64_fbsd is supported.
	(targ_extra_emuls): Likewise.

	* emulparams/elf_k1om.sh: New.
	* emulparams/elf_k1om_fbsd.sh: Likewise.

ld/testsuite/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-x86-64/abs-k1om.d: New.
	* ld-x86-64/protected2-k1om.d: Likewise.
	* ld-x86-64/protected3-k1om.d: Likewise.

	* ld-x86-64/x86-64.exp: Run abs-k1om, protected2-k1om and
	protected3-k1om.

opcodes/

2011-07-22  H.J. Lu  <hongjiu.lu@@intel.com>

	* configure.in: Handle bfd_k1om_arch.
	* configure: Regenerated.

	* disassemble.c (disassembler): Handle bfd_k1om_arch.

	* i386-dis.c (print_insn): Handle bfd_mach_k1om and
	bfd_mach_k1om_intel_syntax.

	* i386-gen.c (cpu_flag_init): Set CPU_UNKNOWN_FLAGS to
	~(CpuL1OM|CpuK1OM).  Add CPU_K1OM_FLAGS.
	(cpu_flags): Add CpuK1OM.

	* i386-opc.h (CpuK1OM): New.
	(i386_cpu_flags): Add cpuk1om.

	* i386-init.h: Regenerated.
	* i386-tbl.h: Likewise.
@
text
@d2 1
a2 1
   Copyright 2010
a21 1
#include "config.h"
a23 1
#include <sys/stat.h>
@


1.8
log
@ELFOSABI_GNU

	bfd/
	* elf.c (_bfd_elf_set_osabi): Use ELFOSABI_GNU name instead of
	ELFOSABI_LINUX alias.
	* elf32-hppa.c: Likewise.
	* elf32-i370.c: Likewise.
	* elf64-hppa.c: Likewise.

	binutils/
	* elfedit.c (osabis): Use ELFOSABI_GNU name instead of ELFOSABI_LINUX
	alias and ELFOSABI_HURD.  Add GNU alias.
	* readelf.c (get_osabi_name, get_symbol_binding, get_symbol_type):
	Likewise.
	* doc/binutils.texi <elfedit>: Update accordingly.

	elfcpp/
	* elfcpp.h (ELFOSABI): Add ELFOSABI_GNU with value of ELFOSABI_LINUX,
	keep ELFOSABI_LINUX as an alias.  Remove ELFOSABI_HURD.

	gas/
	* config/obj-elf.c (obj_elf_type): Use ELFOSABI_GNU name instead of
	ELFOSABI_LINUX alias.
	* config/tc-ia64.c: Likewise.

	include/elf/
	* common.h (ELFOSABI_GNU): Define, replaces...
	(ELFOSABI_LINUX): ... this, kept as an alias.
	(ELFOSABI_HURD): Remove.

	ld/testsuite/
	* ld-ifunc/ifunc.exp: Update for changed output.
	* ld-unique/unique.exp: Likewise.
@
text
@d559 2
d581 1
@


1.7
log
@Add and use elfcomm.c/elfcomm.h.

2010-11-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/12235
	* elfcomm.c: New.
	* elfcomm.h: Likewise.

	* Makefile.am (HFILES): Add elfcomm.h.
	(CFILES): Add elfcomm.c.
	(ELFLIBS): New.
	(readelf_SOURCES): Add $(ELFLIBS).
	(elfedit_SOURCES): Likewise.
	(objdump_SOURCES): Likewise.
	* Makefile.in: Regenerated.

	* dwarf.c: Include "elfcomm.h".
	(byte_get): Removed.
	(byte_get_little_endian): Likewise.
	(byte_get_big_endian): Likewise.
	(byte_get_signed): Likewise.
	(error): Likewise.
	(warn): Likewise.

	* dwarf.h (dwarf_vma): Defined with HOST_WIDEST_INT.
	(dwarf_size_type): Likewise.
	(byte_get): Removed.
	(byte_get_signed): Likewise.
	(byte_get_little_endian): Likewise.
	(byte_get_big_endian): Likewise.
	(error): Likewise.
	(warn): Likewise.

	* elfedit.c: Include "elfcomm.h".  Don't include "aout/ar.h".
	Call error () instead of non_fatal ().
	(streq): Removed.
	(strneq): Likewise.
	(const_strneq): Likewise.
	(non_fatal): Likewise.
	(BYTE_GET): Likewise.
	(BYTE_PUT): Likewise.
	(byte_get): Likewise.
	(byte_put): Likewise.
	(byte_get_little_endian): Likewise.
	(byte_get_big_endian): Likewise.
	(byte_put_little_endian): Likewise.
	(byte_put_big_endian): Likewise.
	(adjust_relative_path): Likewise.
	(archive_info): Likewise.
	(setup_archive): Likewise.
	(release_archive): Likewise.
	(setup_nested_archive): Likewise.
	(get_archive_member_name): Likewise.
	(get_archive_member_name_at): Likewise.
	(make_qualified_name): Likewise.

	* objdump.c: Include "elfcomm.h".

	* readelf.c: Include "elfcomm.h".  Don't include "aout/ar.h".
	(BYTE_GET): Removed.
	(BYTE_GET_SIGNED): Removed.
	(streq): Likewise.
	(strneq): Likewise.
	(const_strneq): Likewise.
	(byte_put): Likewise.
	(byte_put_little_endian): Likewise.
	(byte_put_big_endian): Likewise.
	(adjust_relative_path): Likewise.
	(archive_info): Likewise.
	(setup_archive): Likewise.
	(release_archive): Likewise.
	(setup_nested_archive): Likewise.
	(get_archive_member_name): Likewise.
	(get_archive_member_name_at): Likewise.
	(make_qualified_name): Likewise.
@
text
@d521 2
a522 2
  { ELFOSABI_LINUX, "Linux" },
  { ELFOSABI_HURD, "Hurd" },
@


1.6
log
@Add --input-osabi and --output-osabi to elfedit.

binutils/

2010-08-23  H.J. Lu  <hongjiu.lu@@intel.com>

	* elfedit.c (input_elf_osabi): New.
	(output_elf_osbi): Likewise.
	(osabis): Likewise.
	(elf_osabi): Likewise.
	(update_elf_header): Support updating ELF OSABI.
	(make_qualified_name): Break long line.
	(command_line_switch): Add OPTION_INPUT_OSABI and
	OPTION_OUTPUT_OSABI.
	(options): Likewise.
	(usage): Add --input-osabi and --output-osabi.
	(main): Handle OPTION_INPUT_OSABI and OPTION_OUTPUT_OSABI.

	* doc/binutils.texi: Document --input-osabi and --output-osabi
	for elfedit.

binutils/testsuite/

2010-08-23  H.J. Lu  <hongjiu.lu@@intel.com>

	* binutils-all/elfedit-3.d: New.

	* binutils-all/elfedit.exp: Run elfedit-3.
@
text
@d36 1
a42 3

#include "aout/ar.h"

a61 168
#define streq(a,b)	  (strcmp ((a), (b)) == 0)
#define strneq(a,b,n)	  (strncmp ((a), (b), (n)) == 0)
#define const_strneq(a,b) (strncmp ((a), (b), sizeof (b) - 1) == 0)

void
non_fatal (const char *message, ...)
{
  va_list args;

  va_start (args, message);
  fprintf (stderr, _("%s: Error: "), program_name);
  vfprintf (stderr, message, args);
  va_end (args);
}

#define BYTE_GET(field)		byte_get (field, sizeof (field))
#define BYTE_PUT(field, val)	byte_put (field, val, sizeof (field))

static bfd_vma (*byte_get) (unsigned char *, int);
static void (*byte_put) (unsigned char *, bfd_vma, int);

static bfd_vma
byte_get_little_endian (unsigned char *field, int size)
{
  switch (size)
    {
    case 1:
      return *field;

    case 2:
      return  ((unsigned int) (field[0]))
	|    (((unsigned int) (field[1])) << 8);

    case 4:
      return  ((unsigned long) (field[0]))
	|    (((unsigned long) (field[1])) << 8)
	|    (((unsigned long) (field[2])) << 16)
	|    (((unsigned long) (field[3])) << 24);

    case 8:
      if (sizeof (bfd_vma) == 8)
	return  ((bfd_vma) (field[0]))
	  |    (((bfd_vma) (field[1])) << 8)
	  |    (((bfd_vma) (field[2])) << 16)
	  |    (((bfd_vma) (field[3])) << 24)
	  |    (((bfd_vma) (field[4])) << 32)
	  |    (((bfd_vma) (field[5])) << 40)
	  |    (((bfd_vma) (field[6])) << 48)
	  |    (((bfd_vma) (field[7])) << 56);
      else if (sizeof (bfd_vma) == 4)
	/* We want to extract data from an 8 byte wide field and
	   place it into a 4 byte wide field.  Since this is a little
	   endian source we can just use the 4 byte extraction code.  */
	return  ((unsigned long) (field[0]))
	  |    (((unsigned long) (field[1])) << 8)
	  |    (((unsigned long) (field[2])) << 16)
	  |    (((unsigned long) (field[3])) << 24);

    default:
      non_fatal (_("Unhandled data length: %d\n"), size);
      abort ();
    }
}

static bfd_vma
byte_get_big_endian (unsigned char *field, int size)
{
  switch (size)
    {
    case 1:
      return *field;

    case 2:
      return ((unsigned int) (field[1])) | (((int) (field[0])) << 8);

    case 4:
      return ((unsigned long) (field[3]))
	|   (((unsigned long) (field[2])) << 8)
	|   (((unsigned long) (field[1])) << 16)
	|   (((unsigned long) (field[0])) << 24);

    case 8:
      if (sizeof (bfd_vma) == 8)
	return ((bfd_vma) (field[7]))
	  |   (((bfd_vma) (field[6])) << 8)
	  |   (((bfd_vma) (field[5])) << 16)
	  |   (((bfd_vma) (field[4])) << 24)
	  |   (((bfd_vma) (field[3])) << 32)
	  |   (((bfd_vma) (field[2])) << 40)
	  |   (((bfd_vma) (field[1])) << 48)
	  |   (((bfd_vma) (field[0])) << 56);
      else if (sizeof (bfd_vma) == 4)
	{
	  /* Although we are extracing data from an 8 byte wide field,
	     we are returning only 4 bytes of data.  */
	  field += 4;
	  return ((unsigned long) (field[3]))
	    |   (((unsigned long) (field[2])) << 8)
	    |   (((unsigned long) (field[1])) << 16)
	    |   (((unsigned long) (field[0])) << 24);
	}

    default:
      non_fatal (_("Unhandled data length: %d\n"), size);
      abort ();
    }
}

static void
byte_put_little_endian (unsigned char * field, bfd_vma value, int size)
{
  switch (size)
    {
    case 8:
      field[7] = (((value >> 24) >> 24) >> 8) & 0xff;
      field[6] = ((value >> 24) >> 24) & 0xff;
      field[5] = ((value >> 24) >> 16) & 0xff;
      field[4] = ((value >> 24) >> 8) & 0xff;
      /* Fall through.  */
    case 4:
      field[3] = (value >> 24) & 0xff;
      field[2] = (value >> 16) & 0xff;
      /* Fall through.  */
    case 2:
      field[1] = (value >> 8) & 0xff;
      /* Fall through.  */
    case 1:
      field[0] = value & 0xff;
      break;

    default:
      non_fatal (_("Unhandled data length: %d\n"), size);
      abort ();
    }
}

static void
byte_put_big_endian (unsigned char * field, bfd_vma value, int size)
{
  switch (size)
    {
    case 8:
      field[7] = value & 0xff;
      field[6] = (value >> 8) & 0xff;
      field[5] = (value >> 16) & 0xff;
      field[4] = (value >> 24) & 0xff;
      value >>= 16;
      value >>= 16;
      /* Fall through.  */
    case 4:
      field[3] = value & 0xff;
      field[2] = (value >> 8) & 0xff;
      value >>= 16;
      /* Fall through.  */
    case 2:
      field[1] = value & 0xff;
      value >>= 8;
      /* Fall through.  */
    case 1:
      field[0] = value & 0xff;
      break;

    default:
      non_fatal (_("Unhandled data length: %d\n"), size);
      abort ();
    }
}

d72 1
a72 1
      non_fatal
d80 1
a80 1
      non_fatal
d96 1
a96 1
      non_fatal
d107 1
a107 1
      non_fatal
d118 1
a118 1
      non_fatal
d129 1
a129 1
      non_fatal
d163 1
a163 1
    non_fatal (_("%s: Failed to update ELF header: %s\n"),
d196 1
a196 1
      non_fatal (_("Unsupported EI_CLASS: %d\n"),
d229 1
a229 1
	  non_fatal (_("This executable has been built without support for a\n\
d270 1
a270 1
      non_fatal (_("%s: Failed to read ELF header\n"), file_name);
d277 1
a277 1
      non_fatal (_("%s: Failed to seek to ELF header\n"), file_name);
a285 335
/* Return the path name for a proxy entry in a thin archive, adjusted relative
   to the path name of the thin archive itself if necessary.  Always returns
   a pointer to malloc'ed memory.  */

static char *
adjust_relative_path (const char *file_name, char * name, int name_len)
{
  char * member_file_name;
  const char * base_name = lbasename (file_name);

  /* This is a proxy entry for a thin archive member.
     If the extended name table contains an absolute path
     name, or if the archive is in the current directory,
     use the path name as given.  Otherwise, we need to
     find the member relative to the directory where the
     archive is located.  */
  if (IS_ABSOLUTE_PATH (name) || base_name == file_name)
    {
      member_file_name = malloc (name_len + 1);
      if (member_file_name == NULL)
        {
          non_fatal (_("Out of memory\n"));
          return NULL;
        }
      memcpy (member_file_name, name, name_len);
      member_file_name[name_len] = '\0';
    }
  else
    {
      /* Concatenate the path components of the archive file name
         to the relative path name from the extended name table.  */
      size_t prefix_len = base_name - file_name;
      member_file_name = malloc (prefix_len + name_len + 1);
      if (member_file_name == NULL)
        {
          non_fatal (_("Out of memory\n"));
          return NULL;
        }
      memcpy (member_file_name, file_name, prefix_len);
      memcpy (member_file_name + prefix_len, name, name_len);
      member_file_name[prefix_len + name_len] = '\0';
    }
  return member_file_name;
}

/* Structure to hold information about an archive file.  */

struct archive_info
{
  char * file_name;                     /* Archive file name.  */
  FILE * file;                          /* Open file descriptor.  */
  unsigned long index_num;              /* Number of symbols in table.  */
  unsigned long * index_array;          /* The array of member offsets.  */
  char * sym_table;                     /* The symbol table.  */
  unsigned long sym_size;               /* Size of the symbol table.  */
  char * longnames;                     /* The long file names table.  */
  unsigned long longnames_size;         /* Size of the long file names table.  */
  unsigned long nested_member_origin;   /* Origin in the nested archive of the current member.  */
  unsigned long next_arhdr_offset;      /* Offset of the next archive header.  */
  bfd_boolean is_thin_archive;          /* TRUE if this is a thin archive.  */
  struct ar_hdr arhdr;                  /* Current archive header.  */
};

/* Read the symbol table and long-name table from an archive.  */

static int
setup_archive (struct archive_info * arch, const char * file_name,
	       FILE * file, bfd_boolean is_thin_archive)
{
  size_t got;
  unsigned long size;

  arch->file_name = strdup (file_name);
  arch->file = file;
  arch->index_num = 0;
  arch->index_array = NULL;
  arch->sym_table = NULL;
  arch->sym_size = 0;
  arch->longnames = NULL;
  arch->longnames_size = 0;
  arch->nested_member_origin = 0;
  arch->is_thin_archive = is_thin_archive;
  arch->next_arhdr_offset = SARMAG;

  /* Read the first archive member header.  */
  if (fseek (file, SARMAG, SEEK_SET) != 0)
    {
      non_fatal (_("%s: failed to seek to first archive header\n"),
		 file_name);
      return 1;
    }
  got = fread (&arch->arhdr, 1, sizeof arch->arhdr, file);
  if (got != sizeof arch->arhdr)
    {
      if (got == 0)
	return 0;

      non_fatal (_("%s: failed to read archive header\n"), file_name);
      return 1;
    }

  /* See if this is the archive symbol table.  */
  if (const_strneq (arch->arhdr.ar_name, "/               ")
      || const_strneq (arch->arhdr.ar_name, "/SYM64/         "))
    {
      size = strtoul (arch->arhdr.ar_size, NULL, 10);
      size = size + (size & 1);

      arch->next_arhdr_offset += sizeof arch->arhdr + size;

      if (fseek (file, size, SEEK_CUR) != 0)
	{
	  non_fatal (_("%s: failed to skip archive symbol table\n"),
		     file_name);
	  return 1;
	}

      /* Read the next archive header.  */
      got = fread (&arch->arhdr, 1, sizeof arch->arhdr, file);
      if (got != sizeof arch->arhdr)
	{
	  if (got == 0)
            return 0;
	  non_fatal (_("%s: failed to read archive header following archive index\n"),
		     file_name);
	  return 1;
	}
    }

  if (const_strneq (arch->arhdr.ar_name, "//              "))
    {
      /* This is the archive string table holding long member names.  */
      arch->longnames_size = strtoul (arch->arhdr.ar_size, NULL, 10);
      arch->next_arhdr_offset += sizeof arch->arhdr + arch->longnames_size;

      arch->longnames = malloc (arch->longnames_size);
      if (arch->longnames == NULL)
	{
	  non_fatal (_("Out of memory reading long symbol names in archive\n"));
	  return 1;
	}

      if (fread (arch->longnames, arch->longnames_size, 1, file) != 1)
	{
	  free (arch->longnames);
	  arch->longnames = NULL;
	  non_fatal (_("%s: failed to read long symbol name string table\n")
		     , file_name);
	  return 1;
	}

      if ((arch->longnames_size & 1) != 0)
	getc (file);
    }

  return 0;
}

/* Release the memory used for the archive information.  */

static void
release_archive (struct archive_info * arch)
{
  if (arch->file_name != NULL)
    free (arch->file_name);
  if (arch->index_array != NULL)
    free (arch->index_array);
  if (arch->sym_table != NULL)
    free (arch->sym_table);
  if (arch->longnames != NULL)
    free (arch->longnames);
}

/* Open and setup a nested archive, if not already open.  */

static int
setup_nested_archive (struct archive_info * nested_arch, char * member_file_name)
{
  FILE * member_file;

  /* Have we already setup this archive?  */
  if (nested_arch->file_name != NULL
      && streq (nested_arch->file_name, member_file_name))
    return 0;

  /* Close previous file and discard cached information.  */
  if (nested_arch->file != NULL)
    fclose (nested_arch->file);
  release_archive (nested_arch);

  member_file = fopen (member_file_name, "r+b");
  if (member_file == NULL)
    return 1;
  return setup_archive (nested_arch, member_file_name, member_file,
			FALSE);
}

static char *
get_archive_member_name_at (struct archive_info *  arch,
			    unsigned long          offset,
			    struct archive_info *  nested_arch);

/* Get the name of an archive member from the current archive header.
   For simple names, this will modify the ar_name field of the current
   archive header.  For long names, it will return a pointer to the
   longnames table.  For nested archives, it will open the nested archive
   and get the name recursively.  NESTED_ARCH is a single-entry cache so
   we don't keep rereading the same information from a nested archive.  */

static char *
get_archive_member_name (struct archive_info *  arch,
                         struct archive_info *  nested_arch)
{
  unsigned long j, k;

  if (arch->arhdr.ar_name[0] == '/')
    {
      /* We have a long name.  */
      char * endp;
      char * member_file_name;
      char * member_name;

      arch->nested_member_origin = 0;
      k = j = strtoul (arch->arhdr.ar_name + 1, &endp, 10);
      if (arch->is_thin_archive && endp != NULL && * endp == ':')
        arch->nested_member_origin = strtoul (endp + 1, NULL, 10);

      while ((j < arch->longnames_size)
             && (arch->longnames[j] != '\n')
             && (arch->longnames[j] != '\0'))
        j++;
      if (arch->longnames[j-1] == '/')
        j--;
      arch->longnames[j] = '\0';

      if (!arch->is_thin_archive || arch->nested_member_origin == 0)
        return arch->longnames + k;

      /* This is a proxy for a member of a nested archive.
         Find the name of the member in that archive.  */
      member_file_name = adjust_relative_path (arch->file_name,
					       arch->longnames + k,
					       j - k);
      if (member_file_name != NULL
          && setup_nested_archive (nested_arch, member_file_name) == 0
          && (member_name = get_archive_member_name_at (nested_arch,
							arch->nested_member_origin,
							NULL)) != NULL)
        {
          free (member_file_name);
          return member_name;
        }
      free (member_file_name);

      /* Last resort: just return the name of the nested archive.  */
      return arch->longnames + k;
    }

  /* We have a normal (short) name.  */
  j = 0;
  while ((arch->arhdr.ar_name[j] != '/') && (j < 16))
    j++;
  arch->arhdr.ar_name[j] = '\0';
  return arch->arhdr.ar_name;
}

/* Get the name of an archive member at a given OFFSET within an
   archive ARCH.  */

static char *
get_archive_member_name_at (struct archive_info * arch,
                            unsigned long         offset,
			    struct archive_info * nested_arch)
{
  size_t got;

  if (fseek (arch->file, offset, SEEK_SET) != 0)
    {
      non_fatal (_("%s: failed to seek to next file name\n"),
		 arch->file_name);
      return NULL;
    }
  got = fread (&arch->arhdr, 1, sizeof arch->arhdr, arch->file);
  if (got != sizeof arch->arhdr)
    {
      non_fatal (_("%s: failed to read archive header\n"),
		 arch->file_name);
      return NULL;
    }
  if (memcmp (arch->arhdr.ar_fmag, ARFMAG, 2) != 0)
    {
      non_fatal (_("%s: did not find a valid archive header\n"),
		 arch->file_name);
      return NULL;
    }

  return get_archive_member_name (arch, nested_arch);
}

/* Construct a string showing the name of the archive member, qualified
   with the name of the containing archive file.  For thin archives, we
   use square brackets to denote the indirection.  For nested archives,
   we show the qualified name of the external member inside the square
   brackets (e.g., "thin.a[normal.a(foo.o)]").  */

static char *
make_qualified_name (struct archive_info * arch,
                     struct archive_info * nested_arch,
                     char * member_name)
{
  size_t len;
  char * name;

  len = strlen (arch->file_name) + strlen (member_name) + 3;
  if (arch->is_thin_archive && arch->nested_member_origin != 0)
    len += strlen (nested_arch->file_name) + 2;

  name = malloc (len);
  if (name == NULL)
    {
      non_fatal (_("Out of memory\n"));
      return NULL;
    }

  if (arch->is_thin_archive && arch->nested_member_origin != 0)
    snprintf (name, len, "%s[%s(%s)]", arch->file_name,
	      nested_arch->file_name, member_name);
  else if (arch->is_thin_archive)
    snprintf (name, len, "%s[%s]", arch->file_name, member_name);
  else
    snprintf (name, len, "%s(%s)", arch->file_name, member_name);

  return name;
}

d314 1
a314 1
  if (setup_archive (&arch, file_name, file, is_thin_archive) != 0)
d331 1
a331 1
          non_fatal (_("%s: failed to seek to next archive header\n"),
d340 1
a340 1
          non_fatal (_("%s: failed to read archive header\n"),
d347 1
a347 1
          non_fatal (_("%s: did not find a valid archive header\n"),
d362 1
a362 1
	  non_fatal (_("%s: bad archive file name\n"), file_name);
d371 1
a371 1
	  non_fatal (_("%s: bad archive file name\n"), file_name);
d391 1
a391 1
              non_fatal (_("Input file '%s' is not readable\n"),
d415 1
a415 1
              non_fatal (_("%s: failed to seek to archive member\n"),
d454 1
a454 1
	non_fatal (_("'%s': No such file\n"), file_name);
d456 1
a456 1
	non_fatal (_("Could not locate '%s'.  System error message: %s\n"),
d463 1
a463 1
      non_fatal (_("'%s' is not an ordinary file\n"), file_name);
d483 1
a483 1
      non_fatal (_("Input file '%s' is not readable\n"), file_name);
d489 1
a489 1
      non_fatal (_("%s: Failed to read file's magic number\n"),
d547 1
a547 1
  non_fatal (_("Unknown OSABI: %s\n"), osabi);
d566 1
a566 1
  non_fatal (_("Unknown machine type: %s\n"), mach);
d584 1
a584 1
      non_fatal (_("Unknown machine type: %d\n"), mach);
d603 1
a603 1
  non_fatal (_("Unknown type: %s\n"), type);
@


1.6.2.1
log
@backport from mainline
@
text
@a35 1
#include "elfcomm.h"
d42 3
d64 168
d242 1
a242 1
      error
d250 1
a250 1
      error
d266 1
a266 1
      error
d277 1
a277 1
      error
d288 1
a288 1
      error
d299 1
a299 1
      error
d333 1
a333 1
    error (_("%s: Failed to update ELF header: %s\n"),
d366 1
a366 1
      error (_("Unsupported EI_CLASS: %d\n"),
d399 1
a399 1
	  error (_("This executable has been built without support for a\n\
d440 1
a440 1
      error (_("%s: Failed to read ELF header\n"), file_name);
d447 1
a447 1
      error (_("%s: Failed to seek to ELF header\n"), file_name);
d456 335
d819 1
a819 1
  if (setup_archive (&arch, file_name, file, is_thin_archive, FALSE) != 0)
d836 1
a836 1
          error (_("%s: failed to seek to next archive header\n"),
d845 1
a845 1
          error (_("%s: failed to read archive header\n"),
d852 1
a852 1
          error (_("%s: did not find a valid archive header\n"),
d867 1
a867 1
	  error (_("%s: bad archive file name\n"), file_name);
d876 1
a876 1
	  error (_("%s: bad archive file name\n"), file_name);
d896 1
a896 1
              error (_("Input file '%s' is not readable\n"),
d920 1
a920 1
              error (_("%s: failed to seek to archive member\n"),
d959 1
a959 1
	error (_("'%s': No such file\n"), file_name);
d961 1
a961 1
	error (_("Could not locate '%s'.  System error message: %s\n"),
d968 1
a968 1
      error (_("'%s' is not an ordinary file\n"), file_name);
d988 1
a988 1
      error (_("Input file '%s' is not readable\n"), file_name);
d994 1
a994 1
      error (_("%s: Failed to read file's magic number\n"),
d1052 1
a1052 1
  error (_("Unknown OSABI: %s\n"), osabi);
d1071 1
a1071 1
  error (_("Unknown machine type: %s\n"), mach);
d1089 1
a1089 1
      error (_("Unknown machine type: %d\n"), mach);
d1108 1
a1108 1
  error (_("Unknown type: %s\n"), type);
@


1.5
log
@bfd/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * aoutx.h (aout_link_input_bfd): Remove unused variable sym_count.
        * elf-eh-frame.c (_bfd_elf_eh_frame_section_offset): Remove unused
        variables htab and hdr_info and mark info parameter as unused.
        * elf.c (prep_headers): Remove unused variable i_phdrp.
        (_bfd_elf_write_object_contents): Remove unused variable i_ehdrp.
        * elf32-i386.c (elf_i386_relocate_section): Mark variabled warned
        as unused.
        * peXXigen.c (pe_print_reloc): Remove unused variable datasize.
        * verilog.c (verilog_write_section): Remove unused variable
        address.

binutils/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * dwarf.c (process_debug_info): Remove unused variable
        cu_abbrev_offset_ptr.
        (display_debug_lines_decoded): Remove unused variable prev_line.
        * elfedit.c (process_archive): Remove unused variable
        file_name_size.
        * ieee.c (ieee_start_compilation_unit): Remove unused variable
        nindx.
        (ieee_set_type): Remove unused variables info, targetindx and
        baseindx.
        * objdump.c (disassmble_byte): Remove unused variable done_dot.
        * rddbg.c (read_section_stabs_debugging_info): Remove unused
        variable other.
        * readelf.c (dump_section_as_strings): Remove unused variable
        addr.
        (process_archive): Remove unused variable file_name_size.
        * stabs.c (parse_stab_string): Mark desc parameter as unused.
        Remove unused variable lineno.
        (parse_stab_struct_type): Remove unused variable orig.
        (stab_demangle_type): Remove unused variables constp, volatilep
        and hold.

gas/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * as.c (create_obj_attrs_section): Remove unused variable addr.
        * listing.c (listing_listing): Remove unused variable message.
        * read.c: Remove unnecessary register type qualifiers.
        (s_mri): Only define/use old_flag variable if MRI_MODE_CHANGE is
        defined.

ld/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * ldlang.c (wild_sort): Remove unused variable section_name.

opcodes/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * i386-dis.c (print_insn): Remove unused variable op.
        (OP_sI): Remove unused variable mask.
@
text
@d60 2
d235 1
a235 1
  int class, machine, type, status;
d294 12
a305 1
  /* Update e_machine and e_type.  */
d317 2
d326 2
d781 2
a782 1
    snprintf (name, len, "%s[%s(%s)]", arch->file_name, nested_arch->file_name, member_name);
d1016 41
d1118 3
a1120 1
    OPTION_OUTPUT_TYPE
d1129 2
d1139 1
a1139 1
  fprintf (stream, _("Usage: %s [option(s)] {--output-mach <machine>|--output-type <type>} elffile(s)\n"),
d1148 2
d1207 12
d1233 2
a1234 1
	  && output_elf_type == -1))
@


1.4
log
@Add --input-type and --output-type to elfedit

binutils/

2010-01-08  H.J. Lu  <hongjiu.lu@@intel.com>

	* elfedit.c (input_elf_type): New.
	(output_elf_type): Likewise.
	(elf_type): Likewise.
	(update_elf_header): Support updating ELF file type.
	(command_line_switch): Add OPTION_INPUT_TYPE and
	OPTION_OUTPUT_TYPE.
	(options): Likewise.
	(usage): Add --input-type and --output-type.
	(main): Handle OPTION_INPUT_TYPE and OPTION_OUTPUT_TYPE.  Check
	one of --output-mach and --output-type must be specified.

	* doc/binutils.texi: Document --input-type and --output-type
	for elfedit.

binutils/testsuite/

2010-01-08  H.J. Lu  <hongjiu.lu@@intel.com>

	* binutils-all/elfedit-2.d: New.

	* binutils-all/elfedit.exp: Run elfedit-2.
@
text
@a782 1
  size_t file_name_size;
a806 1
  file_name_size = strlen (file_name);
@


1.3
log
@Don't change input_elf_XXX if they are -1

2010-01-08  H.J. Lu  <hongjiu.lu@@intel.com>

	* elfedit.c (update_elf_header): Don't change input_elf_class
	nor input_elf_machine if they are -1.
@
text
@d58 2
d233 1
a233 1
  int class, machine, status;
d281 12
a292 1
  /* Update e_machine.  */
d300 4
a303 1
      BYTE_PUT (ehdr32.e_machine, output_elf_machine);
d307 4
a310 1
      BYTE_PUT (ehdr64.e_machine, output_elf_machine);
d1037 19
d1059 3
a1061 1
    OPTION_OUTPUT_MACH
d1068 2
d1078 1
a1078 1
  fprintf (stream, _("Usage: %s [option(s)] --output-mach <machine> elffile(s)\n"),
d1085 2
d1132 12
d1156 3
a1158 1
  if (optind == argc || output_elf_machine == -1)
@


1.2
log
@Reformat elfedit.c

2010-01-07  H.J. Lu  <hongjiu.lu@@intel.com>

	* elfedit.c (update_elf_header): Reformat.
@
text
@d231 1
a231 1
  int status;
d253 6
d260 1
a260 3
  if (input_elf_class == -1)
    input_elf_class = elf_header.e_ident[EI_CLASS];
  else if (elf_header.e_ident[EI_CLASS] != input_elf_class)
d264 1
a264 2
	 file_name, elf_header.e_ident[EI_CLASS],
	 input_elf_class);
d268 1
a268 3
  /* Return if e_machine is the same as output_elf_machine.  */
  if (output_elf_machine == elf_header.e_machine)
    return 1;
d271 1
a271 3
  if (input_elf_machine == -1)
    input_elf_machine = elf_header.e_machine;
  else if (elf_header.e_machine != input_elf_machine)
d275 1
a275 1
	 file_name, elf_header.e_machine, input_elf_machine);
d280 1
a280 1
  switch (input_elf_class)
@


1.1
log
@Add elfedit

binutils/

2010-01-06  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/11131
	* Makefile.am (ELFEDIT_PROG): New.
	(bin_PROGRAMS): Add $(ELFEDIT_PROG).
	(CFILES): Add elfedit.c.
	(elfedit_DEPENDENCIES): New.
	(elfedit_SOURCES): Likewise.
	(elfedit_LDADD): Likewise.
	* Makefile.in: Regenerated.

	* elfedit.c: New.

	* doc/binutils.texi: Document elfedit.

	* doc/Makefile.am (man_MANS): Add elfedit.1.
	(elfedit.1): New.
	* doc/Makefile.in: Regenerated.

binutils/testsuite/

2010-01-06  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/11131
	* binutils-all/elfedit-1.d: New.
	* binutils-all/elfedit.exp: Likewise.

	* config/default.exp (ELFEDIT): New. Set if it doesn't exist.
	(ELFEDITFLAGS): Likewise.

	* lib/utils-lib.exp (run_dump_test): Support elfedit.
@
text
@d256 1
a256 2
  else
  if (elf_header.e_ident[EI_CLASS] != input_elf_class)
@

