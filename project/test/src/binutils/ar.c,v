head	1.90;
access;
symbols
	binutils-2_24-branch:1.89.0.2
	binutils-2_24-branchpoint:1.89
	binutils-2_21_1:1.67.2.1
	binutils-2_23_2:1.85.2.1
	binutils-2_23_1:1.85
	binutils-2_23:1.85
	binutils-2_23-branch:1.85.0.2
	binutils-2_23-branchpoint:1.85
	binutils-2_22_branch:1.78.2.1.0.2
	binutils-2_22:1.78.2.1
	binutils-2_22-branch:1.78.0.2
	binutils-2_22-branchpoint:1.78
	binutils-2_21:1.67
	binutils-2_21-branch:1.67.0.2
	binutils-2_21-branchpoint:1.67
	binutils-2_20_1:1.60.4.1
	binutils-2_20:1.60.4.1
	binutils-arc-20081103-branch:1.56.0.6
	binutils-arc-20081103-branchpoint:1.56
	binutils-2_20-branch:1.60.0.4
	binutils-2_20-branchpoint:1.60
	dje-cgen-play1-branch:1.60.0.2
	dje-cgen-play1-branchpoint:1.60
	arc-20081103-branch:1.56.0.4
	arc-20081103-branchpoint:1.56
	binutils-2_19_1:1.56
	binutils-2_19:1.56
	binutils-2_19-branch:1.56.0.2
	binutils-2_19-branchpoint:1.56
	binutils-2_18:1.53
	binutils-2_18-branch:1.53.0.2
	binutils-2_18-branchpoint:1.53
	binutils-csl-coldfire-4_1-32:1.44.2.2
	binutils-csl-sourcerygxx-4_1-32:1.44.2.2
	binutils-csl-innovasic-fido-3_4_4-33:1.44.2.2
	binutils-csl-sourcerygxx-3_4_4-32:1.39.6.1
	binutils-csl-coldfire-4_1-30:1.44.2.2
	binutils-csl-sourcerygxx-4_1-30:1.44.2.2
	binutils-csl-coldfire-4_1-28:1.44.2.2
	binutils-csl-sourcerygxx-4_1-29:1.44.2.2
	binutils-csl-sourcerygxx-4_1-28:1.44.2.2
	binutils-csl-arm-2006q3-27:1.44.2.2
	binutils-csl-sourcerygxx-4_1-27:1.44.2.2
	binutils-csl-arm-2006q3-26:1.44.2.2
	binutils-csl-sourcerygxx-4_1-26:1.44.2.2
	binutils-csl-sourcerygxx-4_1-25:1.44.2.2
	binutils-csl-sourcerygxx-4_1-24:1.44.2.1
	binutils-csl-sourcerygxx-4_1-23:1.44.2.1
	binutils-csl-sourcerygxx-4_1-21:1.44.2.1
	binutils-csl-arm-2006q3-21:1.44.2.1
	binutils-csl-sourcerygxx-4_1-22:1.44.2.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.44
	binutils-csl-sourcerygxx-4_1-20:1.44
	binutils-csl-arm-2006q3-19:1.44
	binutils-csl-sourcerygxx-4_1-19:1.44
	binutils-csl-sourcerygxx-4_1-18:1.44
	binutils-csl-renesas-4_1-9:1.44
	binutils-csl-sourcerygxx-3_4_4-25:1.39.6.1
	binutils-csl-renesas-4_1-8:1.44
	binutils-csl-renesas-4_1-7:1.44
	binutils-csl-renesas-4_1-6:1.44
	binutils-csl-sourcerygxx-4_1-17:1.44
	binutils-csl-sourcerygxx-4_1-14:1.44
	binutils-csl-sourcerygxx-4_1-15:1.44
	binutils-csl-sourcerygxx-4_1-13:1.44
	binutils-2_17:1.44
	binutils-csl-sourcerygxx-4_1-12:1.44
	binutils-csl-sourcerygxx-3_4_4-21:1.44
	binutils-csl-wrs-linux-3_4_4-24:1.39
	binutils-csl-wrs-linux-3_4_4-23:1.39
	binutils-csl-sourcerygxx-4_1-9:1.44
	binutils-csl-sourcerygxx-4_1-8:1.44
	binutils-csl-sourcerygxx-4_1-7:1.44
	binutils-csl-arm-2006q1-6:1.44
	binutils-csl-sourcerygxx-4_1-6:1.44
	binutils-csl-wrs-linux-3_4_4-22:1.39
	binutils-csl-coldfire-4_1-11:1.44
	binutils-csl-sourcerygxx-3_4_4-19:1.44
	binutils-csl-coldfire-4_1-10:1.44
	binutils-csl-sourcerygxx-4_1-5:1.44
	binutils-csl-sourcerygxx-4_1-4:1.44
	binutils-csl-wrs-linux-3_4_4-21:1.39
	binutils-csl-morpho-4_1-4:1.44
	binutils-csl-sourcerygxx-3_4_4-17:1.44
	binutils-csl-wrs-linux-3_4_4-20:1.39
	binutils-2_17-branch:1.44.0.4
	binutils-2_17-branchpoint:1.44
	binutils-csl-2_17-branch:1.44.0.2
	binutils-csl-2_17-branchpoint:1.44
	binutils-csl-gxxpro-3_4-branch:1.39.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.39
	binutils-2_16_1:1.39
	binutils-csl-arm-2005q1b:1.39
	binutils-2_16:1.39
	binutils-csl-arm-2005q1a:1.39
	binutils-csl-arm-2005q1-branch:1.39.0.4
	binutils-csl-arm-2005q1-branchpoint:1.39
	binutils-2_16-branch:1.39.0.2
	binutils-2_16-branchpoint:1.39
	csl-arm-2004-q3d:1.36
	csl-arm-2004-q3:1.35
	binutils-2_15:1.33.2.1
	binutils-2_15-branchpoint:1.33
	csl-arm-2004-q1a:1.34
	csl-arm-2004-q1:1.34
	binutils-2_15-branch:1.33.0.2
	cagney_bfdfile-20040213-branch:1.32.0.4
	cagney_bfdfile-20040213-branchpoint:1.32
	cagney_bigcore-20040122-branch:1.32.0.2
	cagney_bigcore-20040122-branchpoint:1.32
	csl-arm-2003-q4:1.32
	binutils-2_14:1.27
	binutils-2_14-branch:1.27.0.2
	binutils-2_14-branchpoint:1.27
	binutils-2_13_2_1:1.26
	binutils-2_13_2:1.26
	binutils-2_13_1:1.26
	binutils-2_13:1.26
	binutils-2_13-branchpoint:1.26
	binutils-2_13-branch:1.26.0.2
	binutils-2_12_1:1.23
	binutils-2_12:1.23
	binutils-2_12-branch:1.23.0.2
	binutils-2_12-branchpoint:1.23
	cygnus_cvs_20020108_pre:1.22
	binutils-2_11_2:1.18.2.1
	binutils-2_11_1:1.18.2.1
	binutils-2_11:1.18
	x86_64versiong3:1.18
	binutils-2_11-branch:1.18.0.2
	binutils-2_10_1:1.8.2.3
	binutils-2_10:1.8.2.3
	binutils-2_10-branch:1.8.0.2
	binutils-2_10-branchpoint:1.8
	binutils_latest_snapshot:1.90
	repo-unification-2000-02-06:1.8
	binu_ss_19990721:1.2
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.90
date	2013.10.01.13.44.37;	author nickc;	state Exp;
branches;
next	1.89;

1.89
date	2013.08.27.16.22.48;	author nickc;	state Exp;
branches;
next	1.88;

1.88
date	2013.07.18.16.12.34;	author nickc;	state Exp;
branches;
next	1.87;

1.87
date	2013.02.15.14.37.35;	author nickc;	state Exp;
branches;
next	1.86;

1.86
date	2013.01.07.17.40.59;	author roland;	state Exp;
branches;
next	1.85;

1.85
date	2012.06.29.12.59.49;	author nickc;	state Exp;
branches
	1.85.2.1;
next	1.84;

1.84
date	2012.02.09.04.51.43;	author amodra;	state Exp;
branches;
next	1.83;

1.83
date	2012.02.01.16.49.25;	author nickc;	state Exp;
branches;
next	1.82;

1.82
date	2011.12.21.19.39.11;	author roland;	state Exp;
branches;
next	1.81;

1.81
date	2011.11.29.18.07.41;	author roland;	state Exp;
branches;
next	1.80;

1.80
date	2011.10.16.19.36.10;	author hjl;	state Exp;
branches;
next	1.79;

1.79
date	2011.10.13.15.33.32;	author nickc;	state Exp;
branches;
next	1.78;

1.78
date	2011.06.30.15.08.17;	author nickc;	state Exp;
branches
	1.78.2.1;
next	1.77;

1.77
date	2011.05.02.06.04.11;	author amodra;	state Exp;
branches;
next	1.76;

1.76
date	2011.03.25.17.18.54;	author nickc;	state Exp;
branches;
next	1.75;

1.75
date	2011.03.25.17.17.03;	author nickc;	state Exp;
branches;
next	1.74;

1.74
date	2011.03.25.17.14.02;	author nickc;	state Exp;
branches;
next	1.73;

1.73
date	2011.03.17.12.56.35;	author amodra;	state Exp;
branches;
next	1.72;

1.72
date	2010.12.08.05.05.30;	author amodra;	state Exp;
branches;
next	1.71;

1.71
date	2010.12.08.05.00.14;	author amodra;	state Exp;
branches;
next	1.70;

1.70
date	2010.12.08.04.59.36;	author amodra;	state Exp;
branches;
next	1.69;

1.69
date	2010.12.08.04.58.23;	author amodra;	state Exp;
branches;
next	1.68;

1.68
date	2010.11.17.03.35.50;	author amodra;	state Exp;
branches;
next	1.67;

1.67
date	2010.10.29.08.47.02;	author nickc;	state Exp;
branches
	1.67.2.1;
next	1.66;

1.66
date	2010.10.28.14.11.29;	author nickc;	state Exp;
branches;
next	1.65;

1.65
date	2010.09.15.17.10.15;	author hjl;	state Exp;
branches;
next	1.64;

1.64
date	2010.01.13.11.15.52;	author gingold;	state Exp;
branches;
next	1.63;

1.63
date	2010.01.08.11.14.29;	author gingold;	state Exp;
branches;
next	1.62;

1.62
date	2009.12.11.13.42.05;	author nickc;	state Exp;
branches;
next	1.61;

1.61
date	2009.09.10.13.40.44;	author nickc;	state Exp;
branches;
next	1.60;

1.60
date	2009.06.19.15.05.23;	author nickc;	state Exp;
branches
	1.60.4.1;
next	1.59;

1.59
date	2009.05.28.11.30.49;	author nickc;	state Exp;
branches;
next	1.58;

1.58
date	2009.05.26.14.12.03;	author nickc;	state Exp;
branches;
next	1.57;

1.57
date	2009.03.11.04.36.39;	author cgd;	state Exp;
branches;
next	1.56;

1.56
date	2008.04.28.08.30.23;	author nickc;	state Exp;
branches;
next	1.55;

1.55
date	2008.03.28.06.49.44;	author nickc;	state Exp;
branches;
next	1.54;

1.54
date	2008.02.27.10.56.20;	author nickc;	state Exp;
branches;
next	1.53;

1.53
date	2007.07.05.16.54.45;	author nickc;	state Exp;
branches;
next	1.52;

1.52
date	2007.06.27.11.54.09;	author amodra;	state Exp;
branches;
next	1.51;

1.51
date	2007.04.26.14.46.59;	author amodra;	state Exp;
branches;
next	1.50;

1.50
date	2007.02.17.13.33.53;	author jsm28;	state Exp;
branches;
next	1.49;

1.49
date	2007.01.25.15.40.22;	author kazu;	state Exp;
branches;
next	1.48;

1.48
date	2007.01.12.03.12.56;	author amodra;	state Exp;
branches;
next	1.47;

1.47
date	2006.10.13.09.43.28;	author nickc;	state Exp;
branches;
next	1.46;

1.46
date	2006.09.16.18.12.17;	author nickc;	state Exp;
branches;
next	1.45;

1.45
date	2006.08.06.15.49.46;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	2005.10.03.19.37.44;	author mmitchel;	state Exp;
branches
	1.44.2.1;
next	1.43;

1.43
date	2005.09.30.16.37.31;	author mmitchel;	state Exp;
branches;
next	1.42;

1.42
date	2005.06.14.13.26.42;	author hjl;	state Exp;
branches;
next	1.41;

1.41
date	2005.05.08.14.17.38;	author nickc;	state Exp;
branches;
next	1.40;

1.40
date	2005.04.29.00.03.32;	author bje;	state Exp;
branches;
next	1.39;

1.39
date	2005.03.03.11.46.12;	author amodra;	state Exp;
branches
	1.39.6.1;
next	1.38;

1.38
date	2005.03.02.09.03.53;	author jbeulich;	state Exp;
branches;
next	1.37;

1.37
date	2005.01.21.05.40.23;	author bje;	state Exp;
branches;
next	1.36;

1.36
date	2004.10.26.08.08.21;	author jakub;	state Exp;
branches;
next	1.35;

1.35
date	2004.09.09.11.52.41;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	2004.02.27.11.04.36;	author schwab;	state Exp;
branches;
next	1.33;

1.33
date	2004.02.15.02.24.53;	author cagney;	state Exp;
branches
	1.33.2.1;
next	1.32;

1.32
date	2003.11.13.16.01.52;	author nickc;	state Exp;
branches;
next	1.31;

1.31
date	2003.11.10.17.28.33;	author nickc;	state Exp;
branches;
next	1.30;

1.30
date	2003.11.07.12.19.34;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	2003.10.27.13.20.31;	author kazu;	state Exp;
branches;
next	1.28;

1.28
date	2003.09.14.12.20.16;	author aj;	state Exp;
branches;
next	1.27;

1.27
date	2002.11.30.08.39.41;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2002.05.19.16.17.54;	author kazu;	state Exp;
branches;
next	1.25;

1.25
date	2002.05.04.01.55.39;	author amodra;	state Exp;
branches;
next	1.24;

1.24
date	2002.03.18.12.45.54;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2002.01.23.16.12.55;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2001.12.18.08.22.30;	author ths;	state Exp;
branches;
next	1.21;

1.21
date	2001.09.19.05.33.15;	author hjl;	state Exp;
branches;
next	1.20;

1.20
date	2001.09.18.10.05.55;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2001.03.13.06.43.56;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2000.08.11.18.26.28;	author geoffk;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2000.07.27.01.39.45;	author geoffk;	state Exp;
branches;
next	1.16;

1.16
date	2000.06.26.23.15.58;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2000.06.25.16.30.27;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2000.06.20.12.33.20;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2000.06.19.01.09.55;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2000.05.26.13.11.55;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2000.04.07.04.34.50;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2000.04.04.14.32.29;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.03.14.10.03;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	99.10.15.16.50.47;	author ian;	state Exp;
branches
	1.8.2.1;
next	1.7;

1.7
date	99.09.12.19.00.11;	author ian;	state Exp;
branches;
next	1.6;

1.6
date	99.09.12.18.14.07;	author ian;	state Exp;
branches;
next	1.5;

1.5
date	99.09.12.17.47.19;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	99.09.12.17.43.21;	author ian;	state Exp;
branches;
next	1.3;

1.3
date	99.09.12.17.34.19;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.06.12.16.07.57;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.29.09;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.85.2.1
date	2013.01.07.17.42.43;	author roland;	state Exp;
branches;
next	;

1.78.2.1
date	2011.10.25.03.08.40;	author amodra;	state Exp;
branches;
next	;

1.67.2.1
date	2011.02.01.12.25.36;	author amodra;	state Exp;
branches;
next	;

1.60.4.1
date	2009.09.10.13.42.08;	author nickc;	state Exp;
branches;
next	;

1.44.2.1
date	2006.09.29.12.25.31;	author nathan;	state Exp;
branches;
next	1.44.2.2;

1.44.2.2
date	2006.10.16.20.21.23;	author nathan;	state Exp;
branches;
next	;

1.39.6.1
date	2005.08.30.19.57.32;	author mmitchel;	state Exp;
branches;
next	;

1.33.2.1
date	2004.04.09.18.28.06;	author drow;	state Exp;
branches;
next	;

1.18.2.1
date	2001.06.07.03.12.27;	author amodra;	state Exp;
branches;
next	;

1.8.2.1
date	2000.04.05.05.36.40;	author amodra;	state Exp;
branches;
next	1.8.2.2;

1.8.2.2
date	2000.04.07.04.39.24;	author amodra;	state Exp;
branches;
next	1.8.2.3;

1.8.2.3
date	2000.05.28.10.57.50;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.09;	author rth;	state Exp;
branches;
next	;


desc
@@


1.90
log
@	* arsup.c (ar_save): Respect the deterministic setting when
	reading from an mri script.
	* ar.c (main): Set the default deterministic mode when reading
	from an mri script.
@
text
@/* ar.c - Archive modify and extract.
   Copyright 1991-2013 Free Software Foundation, Inc.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */

/*
   Bugs: GNU ar used to check file against filesystem in quick_update and
   replace operations (would check mtime). Doesn't warn when name truncated.
   No way to specify pos_end. Error messages should be more consistent.  */

#include "sysdep.h"
#include "bfd.h"
#include "libiberty.h"
#include "progress.h"
#include "getopt.h"
#include "aout/ar.h"
#include "libbfd.h"
#include "bucomm.h"
#include "arsup.h"
#include "filenames.h"
#include "binemul.h"
#include "plugin.h"

#ifdef __GO32___
#define EXT_NAME_LEN 3		/* Bufflen of addition to name if it's MS-DOS.  */
#else
#define EXT_NAME_LEN 6		/* Ditto for *NIX.  */
#endif

/* Static declarations.  */

static void mri_emul (void);
static const char *normalize (const char *, bfd *);
static void remove_output (void);
static void map_over_members (bfd *, void (*)(bfd *), char **, int);
static void print_contents (bfd * member);
static void delete_members (bfd *, char **files_to_delete);

static void move_members (bfd *, char **files_to_move);
static void replace_members
  (bfd *, char **files_to_replace, bfd_boolean quick);
static void print_descr (bfd * abfd);
static void write_archive (bfd *);
static int  ranlib_only (const char *archname);
static int  ranlib_touch (const char *archname);
static void usage (int);

/** Globals and flags.  */

static int mri_mode;

/* This flag distinguishes between ar and ranlib:
   1 means this is 'ranlib'; 0 means this is 'ar'.
   -1 means if we should use argv[0] to decide.  */
extern int is_ranlib;

/* Nonzero means don't warn about creating the archive file if necessary.  */
int silent_create = 0;

/* Nonzero means describe each action performed.  */
int verbose = 0;

/* Nonzero means preserve dates of members when extracting them.  */
int preserve_dates = 0;

/* Nonzero means don't replace existing members whose dates are more recent
   than the corresponding files.  */
int newer_only = 0;

/* Controls the writing of an archive symbol table (in BSD: a __.SYMDEF
   member).  -1 means we've been explicitly asked to not write a symbol table;
   +1 means we've been explicitly asked to write it;
   0 is the default.
   Traditionally, the default in BSD has been to not write the table.
   However, for POSIX.2 compliance the default is now to write a symbol table
   if any of the members are object files.  */
int write_armap = 0;

/* Operate in deterministic mode: write zero for timestamps, uids,
   and gids for archive members and the archive symbol table, and write
   consistent file modes.  */
int deterministic = -1;			/* Determinism indeterminate.  */

/* Nonzero means it's the name of an existing member; position new or moved
   files with respect to this one.  */
char *posname = NULL;

/* Sez how to use `posname': pos_before means position before that member.
   pos_after means position after that member. pos_end means always at end.
   pos_default means default appropriately. For the latter two, `posname'
   should also be zero.  */
enum pos
  {
    pos_default, pos_before, pos_after, pos_end
  } postype = pos_default;

enum operations
  {
    none = 0, del, replace, print_table,
    print_files, extract, move, quick_append
  } operation = none;

static bfd **
get_pos_bfd (bfd **, enum pos, const char *);

/* For extract/delete only.  If COUNTED_NAME_MODE is TRUE, we only
   extract the COUNTED_NAME_COUNTER instance of that name.  */
static bfd_boolean counted_name_mode = 0;
static int counted_name_counter = 0;

/* Whether to truncate names of files stored in the archive.  */
static bfd_boolean ar_truncate = FALSE;

/* Whether to use a full file name match when searching an archive.
   This is convenient for archives created by the Microsoft lib
   program.  */
static bfd_boolean full_pathname = FALSE;

/* Whether to create a "thin" archive (symbol index only -- no files).  */
static bfd_boolean make_thin_archive = FALSE;

static int show_version = 0;

static int show_help = 0;

static const char *plugin_target = NULL;

static const char *target = NULL;

#define OPTION_PLUGIN 201
#define OPTION_TARGET 202

static struct option long_options[] =
{
  {"help", no_argument, &show_help, 1},
  {"plugin", required_argument, NULL, OPTION_PLUGIN},
  {"target", required_argument, NULL, OPTION_TARGET},
  {"version", no_argument, &show_version, 1},
  {NULL, no_argument, NULL, 0}
};

int interactive = 0;

static void
mri_emul (void)
{
  interactive = isatty (fileno (stdin));
  yyparse ();
}

/* If COUNT is 0, then FUNCTION is called once on each entry.  If nonzero,
   COUNT is the length of the FILES chain; FUNCTION is called on each entry
   whose name matches one in FILES.  */

static void
map_over_members (bfd *arch, void (*function)(bfd *), char **files, int count)
{
  bfd *head;
  int match_count;

  if (count == 0)
    {
      for (head = arch->archive_next; head; head = head->archive_next)
	{
	  PROGRESS (1);
	  function (head);
	}
      return;
    }

  /* This may appear to be a baroque way of accomplishing what we want.
     However we have to iterate over the filenames in order to notice where
     a filename is requested but does not exist in the archive.  Ditto
     mapping over each file each time -- we want to hack multiple
     references.  */

  for (head = arch->archive_next; head; head = head->archive_next)
    head->archive_pass = 0;

  for (; count > 0; files++, count--)
    {
      bfd_boolean found = FALSE;

      match_count = 0;
      for (head = arch->archive_next; head; head = head->archive_next)
	{
	  const char * filename;

	  PROGRESS (1);
	  /* PR binutils/15796: Once an archive element has been matched
	     do not match it again.  If the user provides multiple same-named
	     parameters on the command line their intent is to match multiple
	     same-named entries in the archive, not the same entry multiple
	     times.  */
	  if (head->archive_pass)
	    continue;

	  filename = head->filename;
	  if (filename == NULL)
	    {
	      /* Some archive formats don't get the filenames filled in
		 until the elements are opened.  */
	      struct stat buf;
	      bfd_stat_arch_elt (head, &buf);
	    }
	  else if (bfd_is_thin_archive (arch))
	    {
	      /* Thin archives store full pathnames.  Need to normalize.  */
	      filename = normalize (filename, arch);
	    }

	  if (filename != NULL
	      && !FILENAME_CMP (normalize (*files, arch), filename))
	    {
	      ++match_count;
	      if (counted_name_mode
		  && match_count != counted_name_counter)
		{
		  /* Counting, and didn't match on count; go on to the
                     next one.  */
		  continue;
		}

	      found = TRUE;
	      function (head);
	      head->archive_pass = 1;
	      /* PR binutils/15796: Once a file has been matched, do not
		 match any more same-named files in the archive.  If the
		 user does want to match multiple same-name files in an
		 archive they should provide multiple same-name parameters
		 to the ar command.  */
	      break;
	    }
	}

      if (!found)
	/* xgettext:c-format */
	fprintf (stderr, _("no entry %s in archive\n"), *files);
    }
}

bfd_boolean operation_alters_arch = FALSE;

static void
usage (int help)
{
  FILE *s;

#if BFD_SUPPORTS_PLUGINS
  /* xgettext:c-format */
  const char *command_line
    = _("Usage: %s [emulation options] [-]{dmpqrstx}[abcDfilMNoPsSTuvV]"
	" [--plugin <name>] [member-name] [count] archive-file file...\n");

#else
  /* xgettext:c-format */
  const char *command_line
    = _("Usage: %s [emulation options] [-]{dmpqrstx}[abcDfilMNoPsSTuvV]"
	" [member-name] [count] archive-file file...\n");
#endif
  s = help ? stdout : stderr;

  fprintf (s, command_line, program_name);

  /* xgettext:c-format */
  fprintf (s, _("       %s -M [<mri-script]\n"), program_name);
  fprintf (s, _(" commands:\n"));
  fprintf (s, _("  d            - delete file(s) from the archive\n"));
  fprintf (s, _("  m[ab]        - move file(s) in the archive\n"));
  fprintf (s, _("  p            - print file(s) found in the archive\n"));
  fprintf (s, _("  q[f]         - quick append file(s) to the archive\n"));
  fprintf (s, _("  r[ab][f][u]  - replace existing or insert new file(s) into the archive\n"));
  fprintf (s, _("  s            - act as ranlib\n"));
  fprintf (s, _("  t            - display contents of archive\n"));
  fprintf (s, _("  x[o]         - extract file(s) from the archive\n"));
  fprintf (s, _(" command specific modifiers:\n"));
  fprintf (s, _("  [a]          - put file(s) after [member-name]\n"));
  fprintf (s, _("  [b]          - put file(s) before [member-name] (same as [i])\n"));
  if (DEFAULT_AR_DETERMINISTIC)
    {
      fprintf (s, _("\
  [D]          - use zero for timestamps and uids/gids (default)\n"));
      fprintf (s, _("\
  [U]          - use actual timestamps and uids/gids\n"));
    }
  else
    {
      fprintf (s, _("\
  [D]          - use zero for timestamps and uids/gids\n"));
      fprintf (s, _("\
  [U]          - use actual timestamps and uids/gids (default)\n"));
    }
  fprintf (s, _("  [N]          - use instance [count] of name\n"));
  fprintf (s, _("  [f]          - truncate inserted file names\n"));
  fprintf (s, _("  [P]          - use full path names when matching\n"));
  fprintf (s, _("  [o]          - preserve original dates\n"));
  fprintf (s, _("  [u]          - only replace files that are newer than current archive contents\n"));
  fprintf (s, _(" generic modifiers:\n"));
  fprintf (s, _("  [c]          - do not warn if the library had to be created\n"));
  fprintf (s, _("  [s]          - create an archive index (cf. ranlib)\n"));
  fprintf (s, _("  [S]          - do not build a symbol table\n"));
  fprintf (s, _("  [T]          - make a thin archive\n"));
  fprintf (s, _("  [v]          - be verbose\n"));
  fprintf (s, _("  [V]          - display the version number\n"));
  fprintf (s, _("  @@<file>      - read options from <file>\n"));
  fprintf (s, _("  --target=BFDNAME - specify the target object format as BFDNAME\n"));
#if BFD_SUPPORTS_PLUGINS
  fprintf (s, _(" optional:\n"));
  fprintf (s, _("  --plugin <p> - load the specified plugin\n"));
#endif

  ar_emul_usage (s);

  list_supported_targets (program_name, s);

  if (REPORT_BUGS_TO[0] && help)
    fprintf (s, _("Report bugs to %s\n"), REPORT_BUGS_TO);

  xexit (help ? 0 : 1);
}

static void
ranlib_usage (int help)
{
  FILE *s;

  s = help ? stdout : stderr;

  /* xgettext:c-format */
  fprintf (s, _("Usage: %s [options] archive\n"), program_name);
  fprintf (s, _(" Generate an index to speed access to archives\n"));
  fprintf (s, _(" The options are:\n\
  @@<file>                      Read options from <file>\n"));
#if BFD_SUPPORTS_PLUGINS
  fprintf (s, _("\
  --plugin <name>              Load the specified plugin\n"));
#endif
  if (DEFAULT_AR_DETERMINISTIC)
    fprintf (s, _("\
  -D                           Use zero for symbol map timestamp (default)\n\
  -U                           Use an actual symbol map timestamp\n"));
  else
    fprintf (s, _("\
  -D                           Use zero for symbol map timestamp\n\
  -U                           Use actual symbol map timestamp (default)\n"));
  fprintf (s, _("\
  -t                           Update the archive's symbol map timestamp\n\
  -h --help                    Print this help message\n\
  -v --version                 Print version information\n"));

  list_supported_targets (program_name, s);

  if (REPORT_BUGS_TO[0] && help)
    fprintf (s, _("Report bugs to %s\n"), REPORT_BUGS_TO);

  xexit (help ? 0 : 1);
}

/* Normalize a file name specified on the command line into a file
   name which we will use in an archive.  */

static const char *
normalize (const char *file, bfd *abfd)
{
  const char *filename;

  if (full_pathname)
    return file;

  filename = lbasename (file);

  if (ar_truncate
      && abfd != NULL
      && strlen (filename) > abfd->xvec->ar_max_namelen)
    {
      char *s;

      /* Space leak.  */
      s = (char *) xmalloc (abfd->xvec->ar_max_namelen + 1);
      memcpy (s, filename, abfd->xvec->ar_max_namelen);
      s[abfd->xvec->ar_max_namelen] = '\0';
      filename = s;
    }

  return filename;
}

/* Remove any output file.  This is only called via xatexit.  */

static const char *output_filename = NULL;
static FILE *output_file = NULL;
static bfd *output_bfd = NULL;

static void
remove_output (void)
{
  if (output_filename != NULL)
    {
      if (output_bfd != NULL)
	bfd_cache_close (output_bfd);
      if (output_file != NULL)
	fclose (output_file);
      unlink_if_ordinary (output_filename);
    }
}

static char **
decode_options (int argc, char **argv)
{
  int c;

  /* Convert old-style tar call by exploding option element and rearranging
     options accordingly.  */

  if (argc > 1 && argv[1][0] != '-')
    {
      int new_argc;		/* argc value for rearranged arguments */
      char **new_argv;		/* argv value for rearranged arguments */
      char *const *in;		/* cursor into original argv */
      char **out;		/* cursor into rearranged argv */
      const char *letter;	/* cursor into old option letters */
      char buffer[3];		/* constructed option buffer */

      /* Initialize a constructed option.  */

      buffer[0] = '-';
      buffer[2] = '\0';

      /* Allocate a new argument array, and copy program name in it.  */

      new_argc = argc - 1 + strlen (argv[1]);
      new_argv = xmalloc ((new_argc + 1) * sizeof (*argv));
      in = argv;
      out = new_argv;
      *out++ = *in++;

      /* Copy each old letter option as a separate option.  */

      for (letter = *in++; *letter; letter++)
	{
	  buffer[1] = *letter;
	  *out++ = xstrdup (buffer);
	}

      /* Copy all remaining options.  */

      while (in < argv + argc)
	*out++ = *in++;
      *out = NULL;

      /* Replace the old option list by the new one.  */

      argc = new_argc;
      argv = new_argv;
    }

  while ((c = getopt_long (argc, argv, "hdmpqrtxlcoVsSuvabiMNfPTDU",
			   long_options, NULL)) != EOF)
    {
      switch (c)
        {
        case 'd':
        case 'm':
        case 'p':
        case 'q':
        case 'r':
        case 't':
        case 'x':
          if (operation != none)
            fatal (_("two different operation options specified"));
	  break;
	}

      switch (c)
        {
        case 'h':
	  show_help = 1;
	  break;
        case 'd':
          operation = del;
          operation_alters_arch = TRUE;
          break;
        case 'm':
          operation = move;
          operation_alters_arch = TRUE;
          break;
        case 'p':
          operation = print_files;
          break;
        case 'q':
          operation = quick_append;
          operation_alters_arch = TRUE;
          break;
        case 'r':
          operation = replace;
          operation_alters_arch = TRUE;
          break;
        case 't':
          operation = print_table;
          break;
        case 'x':
          operation = extract;
          break;
        case 'l':
          break;
        case 'c':
          silent_create = 1;
          break;
        case 'o':
          preserve_dates = 1;
          break;
        case 'V':
          show_version = TRUE;
          break;
        case 's':
          write_armap = 1;
          break;
        case 'S':
          write_armap = -1;
          break;
        case 'u':
          newer_only = 1;
          break;
        case 'v':
          verbose = 1;
          break;
        case 'a':
          postype = pos_after;
          break;
        case 'b':
          postype = pos_before;
          break;
        case 'i':
          postype = pos_before;
          break;
        case 'M':
          mri_mode = 1;
          break;
        case 'N':
          counted_name_mode = TRUE;
          break;
        case 'f':
          ar_truncate = TRUE;
          break;
        case 'P':
          full_pathname = TRUE;
          break;
        case 'T':
          make_thin_archive = TRUE;
          break;
        case 'D':
          deterministic = TRUE;
          break;
        case 'U':
          deterministic = FALSE;
          break;
	case OPTION_PLUGIN:
#if BFD_SUPPORTS_PLUGINS
	  plugin_target = "plugin";
	  bfd_plugin_set_plugin (optarg);
#else
	  fprintf (stderr, _("sorry - this program has been built without plugin support\n"));
	  xexit (1);
#endif
	  break;
	case OPTION_TARGET:
	  target = optarg;
	  break;
	case 0:		/* A long option that just sets a flag.  */
	  break;
        default:
          usage (0);
        }
    }

  return &argv[optind];
}

/* If neither -D nor -U was specified explicitly,
   then use the configured default.  */
static void
default_deterministic (void)
{
  if (deterministic < 0)
    deterministic = DEFAULT_AR_DETERMINISTIC;
}

static void
ranlib_main (int argc, char **argv)
{
  int arg_index, status = 0;
  bfd_boolean touch = FALSE;
  int c;

  while ((c = getopt_long (argc, argv, "DhHUvVt", long_options, NULL)) != EOF)
    {
      switch (c)
        {
	case 'D':
	  deterministic = TRUE;
	  break;
        case 'U':
          deterministic = FALSE;
          break;
	case 'h':
	case 'H':
	  show_help = 1;
	  break;
	case 't':
	  touch = TRUE;
	  break;
	case 'v':
	case 'V':
	  show_version = 1;
	  break;

	  /* PR binutils/13493: Support plugins.  */
	case OPTION_PLUGIN:
#if BFD_SUPPORTS_PLUGINS
	  plugin_target = "plugin";
	  bfd_plugin_set_plugin (optarg);
#else
	  fprintf (stderr, _("sorry - this program has been built without plugin support\n"));
	  xexit (1);
#endif
	  break;
	}
    }

  if (argc < 2)
    ranlib_usage (0);

  if (show_help)
    ranlib_usage (1);

  if (show_version)
    print_version ("ranlib");

  default_deterministic ();

  arg_index = optind;

  while (arg_index < argc)
    {
      if (! touch)
        status |= ranlib_only (argv[arg_index]);
      else
        status |= ranlib_touch (argv[arg_index]);
      ++arg_index;
    }

  xexit (status);
}

int main (int, char **);

int
main (int argc, char **argv)
{
  int arg_index;
  char **files;
  int file_count;
  char *inarch_filename;
  int i;

#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

  program_name = argv[0];
  xmalloc_set_program_name (program_name);
#if BFD_SUPPORTS_PLUGINS
  bfd_plugin_set_program_name (program_name);
#endif

  expandargv (&argc, &argv);

  if (is_ranlib < 0)
    {
      const char *temp = lbasename (program_name);

      if (strlen (temp) >= 6
	  && FILENAME_CMP (temp + strlen (temp) - 6, "ranlib") == 0)
	is_ranlib = 1;
      else
	is_ranlib = 0;
    }

  START_PROGRESS (program_name, 0);

  bfd_init ();
  set_default_bfd_target ();

  xatexit (remove_output);

  for (i = 1; i < argc; i++)
    if (! ar_emul_parse_arg (argv[i]))
      break;
  argv += (i - 1);
  argc -= (i - 1);

  if (is_ranlib)
    ranlib_main (argc, argv);

  if (argc < 2)
    usage (0);

  argv = decode_options (argc, argv);

  if (show_help)
    usage (1);

  if (show_version)
    print_version ("ar");

  arg_index = 0;

  if (mri_mode)
    {
      default_deterministic ();
      mri_emul ();
    }
  else
    {
      bfd *arch;

      /* We don't use do_quick_append any more.  Too many systems
	 expect ar to always rebuild the symbol table even when q is
	 used.  */

      /* We can't write an armap when using ar q, so just do ar r
         instead.  */
      if (operation == quick_append && write_armap)
	operation = replace;

      if ((operation == none || operation == print_table)
	  && write_armap == 1)
	xexit (ranlib_only (argv[arg_index]));

      if (operation == none)
	fatal (_("no operation specified"));

      if (newer_only && operation != replace)
	fatal (_("`u' is only meaningful with the `r' option."));

      if (newer_only && deterministic > 0)
        fatal (_("`u' is not meaningful with the `D' option."));

      if (newer_only && deterministic < 0 && DEFAULT_AR_DETERMINISTIC)
        non_fatal (_("\
`u' modifier ignored since `D' is the default (see `U')"));

      default_deterministic ();

      if (postype != pos_default)
	posname = argv[arg_index++];

      if (counted_name_mode)
	{
	  if (operation != extract && operation != del)
	    fatal (_("`N' is only meaningful with the `x' and `d' options."));
	  counted_name_counter = atoi (argv[arg_index++]);
	  if (counted_name_counter <= 0)
	    fatal (_("Value for `N' must be positive."));
	}

      inarch_filename = argv[arg_index++];

      for (file_count = 0; argv[arg_index + file_count] != NULL; file_count++)
	continue;

      files = (file_count > 0) ? argv + arg_index : NULL;

      arch = open_inarch (inarch_filename,
			  files == NULL ? (char *) NULL : files[0]);

      if (operation == extract && bfd_is_thin_archive (arch))
	fatal (_("`x' cannot be used on thin archives."));

      switch (operation)
	{
	case print_table:
	  map_over_members (arch, print_descr, files, file_count);
	  break;

	case print_files:
	  map_over_members (arch, print_contents, files, file_count);
	  break;

	case extract:
	  map_over_members (arch, extract_file, files, file_count);
	  break;

	case del:
	  if (files != NULL)
	    delete_members (arch, files);
	  else
	    output_filename = NULL;
	  break;

	case move:
	  /* PR 12558: Creating and moving at the same time does
	     not make sense.  Just create the archive instead.  */
	  if (! silent_create)
	    {
	      if (files != NULL)
		move_members (arch, files);
	      else
		output_filename = NULL;
	      break;
	    }
	  /* Fall through.  */

	case replace:
	case quick_append:
	  if (files != NULL || write_armap > 0)
	    replace_members (arch, files, operation == quick_append);
	  else
	    output_filename = NULL;
	  break;

	  /* Shouldn't happen! */
	default:
	  /* xgettext:c-format */
	  fatal (_("internal error -- this option not implemented"));
	}
    }

  END_PROGRESS (program_name);

  xexit (0);
  return 0;
}

bfd *
open_inarch (const char *archive_filename, const char *file)
{
  bfd **last_one;
  bfd *next_one;
  struct stat sbuf;
  bfd *arch;
  char **matching;

  bfd_set_error (bfd_error_no_error);

  if (target == NULL)
    target = plugin_target;

  if (stat (archive_filename, &sbuf) != 0)
    {
#if !defined(__GO32__) || defined(__DJGPP__)

      /* FIXME: I don't understand why this fragment was ifndef'ed
	 away for __GO32__; perhaps it was in the days of DJGPP v1.x.
	 stat() works just fine in v2.x, so I think this should be
	 removed.  For now, I enable it for DJGPP v2. -- EZ.  */

      /* KLUDGE ALERT! Temporary fix until I figger why
	 stat() is wrong ... think it's buried in GO32's IDT - Jax */
      if (errno != ENOENT)
	bfd_fatal (archive_filename);
#endif

      if (!operation_alters_arch)
	{
	  fprintf (stderr, "%s: ", program_name);
	  perror (archive_filename);
	  maybequit ();
	  return NULL;
	}

      /* If the target isn't set, try to figure out the target to use
	 for the archive from the first object on the list.  */
      if (target == NULL && file != NULL)
	{
	  bfd *obj;

	  obj = bfd_openr (file, target);
	  if (obj != NULL)
	    {
	      if (bfd_check_format (obj, bfd_object))
		target = bfd_get_target (obj);
	      (void) bfd_close (obj);
	    }
	}

      /* Create an empty archive.  */
      arch = bfd_openw (archive_filename, target);
      if (arch == NULL
	  || ! bfd_set_format (arch, bfd_archive)
	  || ! bfd_close (arch))
	bfd_fatal (archive_filename);
      else if (!silent_create)
        non_fatal (_("creating %s"), archive_filename);

      /* If we die creating a new archive, don't leave it around.  */
      output_filename = archive_filename;
    }

  arch = bfd_openr (archive_filename, target);
  if (arch == NULL)
    {
    bloser:
      bfd_fatal (archive_filename);
    }

  if (! bfd_check_format_matches (arch, bfd_archive, &matching))
    {
      bfd_nonfatal (archive_filename);
      if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
	{
	  list_matching_formats (matching);
	  free (matching);
	}
      xexit (1);
    }

  if ((operation == replace || operation == quick_append)
      && bfd_openr_next_archived_file (arch, NULL) != NULL)
    {
      /* PR 15140: Catch attempts to convert a normal
	 archive into a thin archive or vice versa.  */
      if (make_thin_archive && ! bfd_is_thin_archive (arch))
	{
	  fatal (_("Cannot convert existing library %s to thin format"),
		 bfd_get_filename (arch));
	  goto bloser;
	}
      else if (! make_thin_archive && bfd_is_thin_archive (arch))
	{
	  fatal (_("Cannot convert existing thin library %s to normal format"),
		 bfd_get_filename (arch));
	  goto bloser;
	}
    }  

  last_one = &(arch->archive_next);
  /* Read all the contents right away, regardless.  */
  for (next_one = bfd_openr_next_archived_file (arch, NULL);
       next_one;
       next_one = bfd_openr_next_archived_file (arch, next_one))
    {
      PROGRESS (1);
      *last_one = next_one;
      last_one = &next_one->archive_next;
    }
  *last_one = (bfd *) NULL;
  if (bfd_get_error () != bfd_error_no_more_archived_files)
    goto bloser;
  return arch;
}

static void
print_contents (bfd *abfd)
{
  bfd_size_type ncopied = 0;
  bfd_size_type size;
  char *cbuf = (char *) xmalloc (BUFSIZE);
  struct stat buf;

  if (bfd_stat_arch_elt (abfd, &buf) != 0)
    /* xgettext:c-format */
    fatal (_("internal stat error on %s"), bfd_get_filename (abfd));

  if (verbose)
    printf ("\n<%s>\n\n", bfd_get_filename (abfd));

  bfd_seek (abfd, (file_ptr) 0, SEEK_SET);

  size = buf.st_size;
  while (ncopied < size)
    {
      bfd_size_type nread;
      bfd_size_type tocopy = size - ncopied;

      if (tocopy > BUFSIZE)
	tocopy = BUFSIZE;

      nread = bfd_bread (cbuf, tocopy, abfd);
      if (nread != tocopy)
	/* xgettext:c-format */
	fatal (_("%s is not a valid archive"),
	       bfd_get_filename (bfd_my_archive (abfd)));

      /* fwrite in mingw32 may return int instead of bfd_size_type. Cast the
	 return value to bfd_size_type to avoid comparison between signed and
	 unsigned values.  */
      if ((bfd_size_type) fwrite (cbuf, 1, nread, stdout) != nread)
	fatal ("stdout: %s", strerror (errno));
      ncopied += tocopy;
    }
  free (cbuf);
}

/* Extract a member of the archive into its own file.

   We defer opening the new file until after we have read a BUFSIZ chunk of the
   old one, since we know we have just read the archive header for the old
   one.  Since most members are shorter than BUFSIZ, this means we will read
   the old header, read the old data, write a new inode for the new file, and
   write the new data, and be done. This 'optimization' is what comes from
   sitting next to a bare disk and hearing it every time it seeks.  -- Gnu
   Gilmore  */

void
extract_file (bfd *abfd)
{
  FILE *ostream;
  char *cbuf = (char *) xmalloc (BUFSIZE);
  bfd_size_type nread, tocopy;
  bfd_size_type ncopied = 0;
  bfd_size_type size;
  struct stat buf;

  if (bfd_stat_arch_elt (abfd, &buf) != 0)
    /* xgettext:c-format */
    fatal (_("internal stat error on %s"), bfd_get_filename (abfd));
  size = buf.st_size;

  if (verbose)
    printf ("x - %s\n", bfd_get_filename (abfd));

  bfd_seek (abfd, (file_ptr) 0, SEEK_SET);

  ostream = NULL;
  if (size == 0)
    {
      /* Seems like an abstraction violation, eh?  Well it's OK! */
      output_filename = bfd_get_filename (abfd);

      ostream = fopen (bfd_get_filename (abfd), FOPEN_WB);
      if (ostream == NULL)
	{
	  perror (bfd_get_filename (abfd));
	  xexit (1);
	}

      output_file = ostream;
    }
  else
    while (ncopied < size)
      {
	tocopy = size - ncopied;
	if (tocopy > BUFSIZE)
	  tocopy = BUFSIZE;

	nread = bfd_bread (cbuf, tocopy, abfd);
	if (nread != tocopy)
	  /* xgettext:c-format */
	  fatal (_("%s is not a valid archive"),
		 bfd_get_filename (bfd_my_archive (abfd)));

	/* See comment above; this saves disk arm motion */
	if (ostream == NULL)
	  {
	    /* Seems like an abstraction violation, eh?  Well it's OK! */
	    output_filename = bfd_get_filename (abfd);

	    ostream = fopen (bfd_get_filename (abfd), FOPEN_WB);
	    if (ostream == NULL)
	      {
		perror (bfd_get_filename (abfd));
		xexit (1);
	      }

	    output_file = ostream;
	  }

	/* fwrite in mingw32 may return int instead of bfd_size_type. Cast
	   the return value to bfd_size_type to avoid comparison between
	   signed and unsigned values.  */
	if ((bfd_size_type) fwrite (cbuf, 1, nread, ostream) != nread)
	  fatal ("%s: %s", output_filename, strerror (errno));
	ncopied += tocopy;
      }

  if (ostream != NULL)
    fclose (ostream);

  output_file = NULL;
  output_filename = NULL;

  chmod (bfd_get_filename (abfd), buf.st_mode);

  if (preserve_dates)
    {
      /* Set access time to modification time.  Only st_mtime is
	 initialized by bfd_stat_arch_elt.  */
      buf.st_atime = buf.st_mtime;
      set_times (bfd_get_filename (abfd), &buf);
    }

  free (cbuf);
}

static void
write_archive (bfd *iarch)
{
  bfd *obfd;
  char *old_name, *new_name;
  bfd *contents_head = iarch->archive_next;

  old_name = (char *) xmalloc (strlen (bfd_get_filename (iarch)) + 1);
  strcpy (old_name, bfd_get_filename (iarch));
  new_name = make_tempname (old_name);

  if (new_name == NULL)
    bfd_fatal (_("could not create temporary file whilst writing archive"));

  output_filename = new_name;

  obfd = bfd_openw (new_name, bfd_get_target (iarch));

  if (obfd == NULL)
    bfd_fatal (old_name);

  output_bfd = obfd;

  bfd_set_format (obfd, bfd_archive);

  /* Request writing the archive symbol table unless we've
     been explicitly requested not to.  */
  obfd->has_armap = write_armap >= 0;

  if (ar_truncate)
    {
      /* This should really use bfd_set_file_flags, but that rejects
         archives.  */
      obfd->flags |= BFD_TRADITIONAL_FORMAT;
    }

  if (deterministic)
    obfd->flags |= BFD_DETERMINISTIC_OUTPUT;

  if (make_thin_archive || bfd_is_thin_archive (iarch))
    bfd_is_thin_archive (obfd) = 1;

  if (!bfd_set_archive_head (obfd, contents_head))
    bfd_fatal (old_name);

  if (!bfd_close (obfd))
    bfd_fatal (old_name);

  output_bfd = NULL;
  output_filename = NULL;

  /* We don't care if this fails; we might be creating the archive.  */
  bfd_close (iarch);

  if (smart_rename (new_name, old_name, 0) != 0)
    xexit (1);
  free (old_name);
}

/* Return a pointer to the pointer to the entry which should be rplacd'd
   into when altering.  DEFAULT_POS should be how to interpret pos_default,
   and should be a pos value.  */

static bfd **
get_pos_bfd (bfd **contents, enum pos default_pos, const char *default_posname)
{
  bfd **after_bfd = contents;
  enum pos realpos;
  const char *realposname;

  if (postype == pos_default)
    {
      realpos = default_pos;
      realposname = default_posname;
    }
  else
    {
      realpos = postype;
      realposname = posname;
    }

  if (realpos == pos_end)
    {
      while (*after_bfd)
	after_bfd = &((*after_bfd)->archive_next);
    }
  else
    {
      for (; *after_bfd; after_bfd = &(*after_bfd)->archive_next)
	if (FILENAME_CMP ((*after_bfd)->filename, realposname) == 0)
	  {
	    if (realpos == pos_after)
	      after_bfd = &(*after_bfd)->archive_next;
	    break;
	  }
    }
  return after_bfd;
}

static void
delete_members (bfd *arch, char **files_to_delete)
{
  bfd **current_ptr_ptr;
  bfd_boolean found;
  bfd_boolean something_changed = FALSE;
  int match_count;

  for (; *files_to_delete != NULL; ++files_to_delete)
    {
      /* In a.out systems, the armap is optional.  It's also called
	 __.SYMDEF.  So if the user asked to delete it, we should remember
	 that fact. This isn't quite right for COFF systems (where
	 __.SYMDEF might be regular member), but it's very unlikely
	 to be a problem.  FIXME */

      if (!strcmp (*files_to_delete, "__.SYMDEF"))
	{
	  arch->has_armap = FALSE;
	  write_armap = -1;
	  continue;
	}

      found = FALSE;
      match_count = 0;
      current_ptr_ptr = &(arch->archive_next);
      while (*current_ptr_ptr)
	{
	  if (FILENAME_CMP (normalize (*files_to_delete, arch),
			    (*current_ptr_ptr)->filename) == 0)
	    {
	      ++match_count;
	      if (counted_name_mode
		  && match_count != counted_name_counter)
		{
		  /* Counting, and didn't match on count; go on to the
                     next one.  */
		}
	      else
		{
		  found = TRUE;
		  something_changed = TRUE;
		  if (verbose)
		    printf ("d - %s\n",
			    *files_to_delete);
		  *current_ptr_ptr = ((*current_ptr_ptr)->archive_next);
		  goto next_file;
		}
	    }

	  current_ptr_ptr = &((*current_ptr_ptr)->archive_next);
	}

      if (verbose && !found)
	{
	  /* xgettext:c-format */
	  printf (_("No member named `%s'\n"), *files_to_delete);
	}
    next_file:
      ;
    }

  if (something_changed)
    write_archive (arch);
  else
    output_filename = NULL;
}


/* Reposition existing members within an archive */

static void
move_members (bfd *arch, char **files_to_move)
{
  bfd **after_bfd;		/* New entries go after this one */
  bfd **current_ptr_ptr;	/* cdr pointer into contents */

  for (; *files_to_move; ++files_to_move)
    {
      current_ptr_ptr = &(arch->archive_next);
      while (*current_ptr_ptr)
	{
	  bfd *current_ptr = *current_ptr_ptr;
	  if (FILENAME_CMP (normalize (*files_to_move, arch),
			    current_ptr->filename) == 0)
	    {
	      /* Move this file to the end of the list - first cut from
		 where it is.  */
	      bfd *link_bfd;
	      *current_ptr_ptr = current_ptr->archive_next;

	      /* Now glue to end */
	      after_bfd = get_pos_bfd (&arch->archive_next, pos_end, NULL);
	      link_bfd = *after_bfd;
	      *after_bfd = current_ptr;
	      current_ptr->archive_next = link_bfd;

	      if (verbose)
		printf ("m - %s\n", *files_to_move);

	      goto next_file;
	    }

	  current_ptr_ptr = &((*current_ptr_ptr)->archive_next);
	}
      /* xgettext:c-format */
      fatal (_("no entry %s in archive %s!"), *files_to_move, arch->filename);

    next_file:;
    }

  write_archive (arch);
}

/* Ought to default to replacing in place, but this is existing practice!  */

static void
replace_members (bfd *arch, char **files_to_move, bfd_boolean quick)
{
  bfd_boolean changed = FALSE;
  bfd **after_bfd;		/* New entries go after this one.  */
  bfd *current;
  bfd **current_ptr;

  while (files_to_move && *files_to_move)
    {
      if (! quick)
	{
	  current_ptr = &arch->archive_next;
	  while (*current_ptr)
	    {
	      current = *current_ptr;

	      /* For compatibility with existing ar programs, we
		 permit the same file to be added multiple times.  */
	      if (FILENAME_CMP (normalize (*files_to_move, arch),
				normalize (current->filename, arch)) == 0
		  && current->arelt_data != NULL)
		{
		  if (newer_only)
		    {
		      struct stat fsbuf, asbuf;

		      if (stat (*files_to_move, &fsbuf) != 0)
			{
			  if (errno != ENOENT)
			    bfd_fatal (*files_to_move);
			  goto next_file;
			}
		      if (bfd_stat_arch_elt (current, &asbuf) != 0)
			/* xgettext:c-format */
			fatal (_("internal stat error on %s"),
			       current->filename);

		      if (fsbuf.st_mtime <= asbuf.st_mtime)
			goto next_file;
		    }

		  after_bfd = get_pos_bfd (&arch->archive_next, pos_after,
					   current->filename);
		  if (ar_emul_replace (after_bfd, *files_to_move,
				       target, verbose))
		    {
		      /* Snip out this entry from the chain.  */
		      *current_ptr = (*current_ptr)->archive_next;
		      changed = TRUE;
		    }

		  goto next_file;
		}
	      current_ptr = &(current->archive_next);
	    }
	}

      /* Add to the end of the archive.  */
      after_bfd = get_pos_bfd (&arch->archive_next, pos_end, NULL);

      if (ar_emul_append (after_bfd, *files_to_move, target,
			  verbose, make_thin_archive))
	changed = TRUE;

    next_file:;

      files_to_move++;
    }

  if (changed)
    write_archive (arch);
  else
    output_filename = NULL;
}

static int
ranlib_only (const char *archname)
{
  bfd *arch;

  if (get_file_size (archname) < 1)
    return 1;
  write_armap = 1;
  arch = open_inarch (archname, (char *) NULL);
  if (arch == NULL)
    xexit (1);
  write_archive (arch);
  return 0;
}

/* Update the timestamp of the symbol map of an archive.  */

static int
ranlib_touch (const char *archname)
{
#ifdef __GO32__
  /* I don't think updating works on go32.  */
  ranlib_only (archname);
#else
  int f;
  bfd *arch;
  char **matching;

  if (get_file_size (archname) < 1)
    return 1;
  f = open (archname, O_RDWR | O_BINARY, 0);
  if (f < 0)
    {
      bfd_set_error (bfd_error_system_call);
      bfd_fatal (archname);
    }

  arch = bfd_fdopenr (archname, (const char *) NULL, f);
  if (arch == NULL)
    bfd_fatal (archname);
  if (! bfd_check_format_matches (arch, bfd_archive, &matching))
    {
      bfd_nonfatal (archname);
      if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
	{
	  list_matching_formats (matching);
	  free (matching);
	}
      xexit (1);
    }

  if (! bfd_has_map (arch))
    /* xgettext:c-format */
    fatal (_("%s: no archive map to update"), archname);

  if (deterministic)
    arch->flags |= BFD_DETERMINISTIC_OUTPUT;

  bfd_update_armap_timestamp (arch);

  if (! bfd_close (arch))
    bfd_fatal (archname);
#endif
  return 0;
}

/* Things which are interesting to map over all or some of the files: */

static void
print_descr (bfd *abfd)
{
  print_arelt_descr (stdout, abfd, verbose);
}
@


1.89
log
@	PR binutils/15796
	* ar.c (map_over_members): Correctly handle multiple same-name
	entries on the command line and in the archive.
@
text
@d740 1
@


1.88
log
@	* ar.c (usage): Fix C conformance issue.

	* config/tc-i386-intel.c (i386_intel_operand): Fixed signed vs
	unsigned comparison.
@
text
@d192 3
d205 8
d241 7
@


1.87
log
@	PR binutils/15140
	* ar.c (open_inarch): Fail on attempts to convert a normal archive
	to a thin archive or vice versa.
	* elfcomm.c (make_qualified_name): Handle corrupted thin
	archives.
	* readelf.c (process_archive): Likewise.
	* doc/binutils.texi: Clarify documentation describing thin
	archives.

	* archive.c (_bfd_get_elt_at_filepos): Prevent an infinite loop
	accessing a corrupt nested archive.
@
text
@a245 2
  s = help ? stdout : stderr;

d258 2
@


1.86
log
@binutils/
	* objcopy.c (deterministic): Make int rather than bfd_boolean,
	initialize to -1.
	(strip_options, copy_options): Add -U/--disable-deterministic-archives.
	(default_deterministic): New function.
	(strip_main, copy_main): Handle -U.  Call default_deterministic.
	(copy_usage, strip_usage): Describe -U.  Cite whether -D or -U is
	the default based on DEFAULT_AR_DETERMINISTIC.
	* doc/binutils.texi (objcopy, strip): Describe -U and effect of
	configure options on -D.

	* ar.c (default_deterministic): Comment fix.
@
text
@d2 1
a2 3
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013
   Free Software Foundation, Inc.
d919 19
@


1.85
log
@	PR binutils/14302
	* bucomm.c (print_arelt_descr): Correctly report the archive size
	field (for 'ar tv').
	* ar.c (print_contents): Use correct types for archive element
	sizes (for 'ar p').
	(extract_file): Likewise (for 'ar x').
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
d578 1
a578 1
/* If neither -D nor -U was not specified explicitly,
@


1.85.2.1
log
@binutils/
	* objcopy.c (deterministic): Make int rather than bfd_boolean,
	initialize to -1.
	(strip_options, copy_options): Add -U/--disable-deterministic-archives.
	(default_deterministic): New function.
	(strip_main, copy_main): Handle -U.  Call default_deterministic.
	(copy_usage, strip_usage): Describe -U.  Cite whether -D or -U is
	the default based on DEFAULT_AR_DETERMINISTIC.
	* doc/binutils.texi (objcopy, strip): Describe -U and effect of
	configure options on -D.

	* ar.c (default_deterministic): Comment fix.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013
d578 1
a578 1
/* If neither -D nor -U was specified explicitly,
@


1.84
log
@	* sysdep.h: Include sys/stat.h here.
	* ar.c: Don't include headers already included by sysdep.h.
	* bucomm.c: Likewise.
	* budbg.h: Likewise.
	* dlltool.h: Likewise.
	* elfedit.c: Likewise.
	* nlmconv.c: Likewise.
	* objcopy.c: Likewise.
	* objdump.c: Likewise.
	* objdump.h: Likewise.
	* readelf.c: Likewise.
	* rename.c: Likewise.
	* resrc.c: Likewise.
	* strings.c: Likewise.
	* windres.c: Likewise.
	* od-macho.c: Ensure #include sysdep.h is first.
	* od-xcoff.c: Likewise.
	* dllwrap.c: Remove alloca pragma handled by sysdep.h, and
	remove duplicate headers.
	* dlltool.c: Likewise and ensure #include sysdep.h is first.
@
text
@d940 2
a941 1
  size_t ncopied = 0;
d944 1
a944 1
  size_t size;
d957 2
a959 2
      size_t nread;
      size_t tocopy = size - ncopied;
d963 1
a963 1
      nread = bfd_bread (cbuf, (bfd_size_type) tocopy, abfd);
d969 2
a970 2
      /* fwrite in mingw32 may return int instead of size_t. Cast the
	 return value to size_t to avoid comparison between signed and
d972 1
a972 1
      if ((size_t) fwrite (cbuf, 1, nread, stdout) != nread)
d994 3
a996 3
  size_t nread, tocopy;
  size_t ncopied = 0;
  size_t size;
d1031 1
a1031 1
	nread = bfd_bread (cbuf, (bfd_size_type) tocopy, abfd);
d1053 2
a1054 2
	/* fwrite in mingw32 may return int instead of size_t. Cast
	   the return value to size_t to avoid comparison between
d1056 1
a1056 1
	if ((size_t) fwrite (cbuf, 1, nread, ostream) != nread)
@


1.83
log
@	PR binutils/13493
	* ar.c (ranlib_main): Process --plugin option.
	* doc/binutils.texi: Document --plugin support for ranlib.
@
text
@a39 1
#include <sys/stat.h>
@


1.82
log
@	* configure.in (--enable-deterministic-archives): Grok new
	argument.  Set DEFAULT_AR_DETERMINISTIC to 1 or 0 accordingly.
	* configure: Regenerated.
	* config.in: Regenerated.
	* ar.c (deterministic): Initialize to -1.
	(decode_options, ranlib_main): Grok U option.
	(usage, ranlib_usage): Mention U; say for D and U which is the default.
	(default_deterministic): New function.
	(ranlib_main): Call it.
	(main): Likewise.  Make newer_only && deterministic error
	non-fatal if it was just DEFAULT_AR_DETERMINISTIC and not the D option.
	* doc/binutils.texi (ar cmdline, ranlib): Document U modifier and
	--enable-deterministic-archives behavior.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d616 12
a627 1
        }
@


1.81
log
@	* ar.c (ranlib_usage): Describe -D.
	(ranlib_main): Parse -D.
	(ranlib_touch): Set BFD_DETERMINISTIC_OUTPUT under -D.
	* doc/binutils.texi (ranlib): Describe -D, and also --help/-h/-H.
@
text
@d100 1
a100 1
int deterministic = 0;
d279 14
a292 1
  fprintf (s, _("  [D]          - use zero for timestamps and uids/gids\n"));
d338 8
a347 1
  -D                           Use zero for the symbol map timestamp\n\
d457 1
a457 1
  while ((c = getopt_long (argc, argv, "hdmpqrtxlcoVsSuvabiMNfPTD",
d554 3
d579 9
d595 1
a595 1
  while ((c = getopt_long (argc, argv, "DhHvVt", long_options, NULL)) != EOF)
d602 3
d628 2
d739 8
a746 2
      if (newer_only && deterministic)
	fatal (_("`u' is not meaningful with the `D' option."));
@


1.80
log
@Set target from the the first object only if it isn't set.

2011-10-16  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/13278
	* ar.c (open_inarch): Set the target from the the first object
	on the list only if it isn't set.
@
text
@d327 1
d563 1
a563 1
  while ((c = getopt_long (argc, argv, "hHvVt", long_options, NULL)) != EOF)
d567 3
d588 1
a588 1
    usage (1);
d1372 3
@


1.79
log
@2011-10-13  Nick Clifton  <nickc@@redhat.com>

	Fixes to aid translation:
	* addr2line.c (translate_address): Add comments describing context
	of a couple of printf statements.
	* ar.c (write_archive): Allow translation of error message.
	* bucomm.c (endian_string): Allow translation of strings.
	(display_target_list): Allow translation.
	* coffdump.c (dump_coff_type): Allow translation of output.
	(dump_coff_where): Likewise.
	(dump_coff_symbol): Likewise.
	(dump_coff_scope): Likewise.
	(dump_coff_sfile): Likewise.
	(dump_coff_section): Likewise.
	(coff_dump): Likewise.
	* dlltool (def_version): Allow translation of output.
	(run): Likewise.
	* dllwrap.c (run): Allow translation of output.
	* dwarf.c (print_dwarf_vma): Allow translation of output.
	(process_extended_line_op): Remove spurious translation.
	Add translation for strings that can be translated.
	(decode_location_exression): Allow translation of output.
	(read_and_display_attr_value): Allow translation of output.
	* readelf.c (slurp_rela_relocs): Add translation for error
	messages when failing to get data.
	(slurp_rel_relocs): Likewise.
	(get_32bit_elf_symbols): Likewise.
	(get_64bit_elf_symbols): Likewise.
	(dump_ia64_vms_dynamic_relocs): Replace abbreviation with full
	word.
	(process_relocs): Remove spurious translation.
	(decode_tic6x_unwind_bytecode): Likewise.
	(process_version_section): Improve error messages.
	(process_mips_specific): Likewise.
	(print_gnu_note): Remove spurious translation.
	(print_stapsdt_note): Likewise.
	(get_ia64_vms_note_type): Likewise.
	* sysdump.c (getCHARS): Allow translation.
	(fillup): Allow translation of output.
	(getone): Likewise.
	(must): Likewise.
	(derived_type): Likewise.
	* doc/binutils.doc (addr2line): Extend description of command line
	options.
	* po/binutils.pot: Regenerate.
@
text
@d818 3
a820 3
      /* Try to figure out the target to use for the archive from the
         first object on the list.  */
      if (file != NULL)
@


1.78
log
@	PR binutils/12558
	* ar.c (main): When asked to move members in an archive that is
	being created, ignore the move request.
@
text
@d1034 1
a1034 1
    bfd_fatal ("could not create temporary file whilst writing archive");
@


1.78.2.1
log
@	PR binutils/13278
	2011-10-16  H.J. Lu  <hongjiu.lu@@intel.com>
	* ar.c (open_inarch): Set the target from the the first object
	on the list only if it isn't set.
@
text
@d818 3
a820 3
      /* If the target isn't set, try to figure out the target to use
	 for the archive from the first object on the list.  */
      if (target == NULL && file != NULL)
@


1.77
log
@	PR binutils/12720
	Revert the following change
	Michael Snyder  <msnyder@@vmware.com>
	* ar.c (move_members): Plug memory leak.
	(delete_members): Plug memory leak.
@
text
@d748 11
a758 5
	  if (files != NULL)
	    move_members (arch, files);
	  else
	    output_filename = NULL;
	  break;
@


1.76
log
@	* ar.c (write_archive): Plug memory leak.
@
text
@a1121 1
  const char * tmp = NULL;
d1143 2
a1144 4
	  if (tmp != NULL)
	    free ((char *) tmp);
	  tmp = normalize (*files_to_delete, arch);
	  if (FILENAME_CMP (tmp, (*current_ptr_ptr)->filename) == 0)
a1180 3

  if (tmp != NULL)
    free ((char *) tmp);
d1189 2
a1190 3
  bfd **after_bfd;		/* New entries go after this one.  */
  bfd **current_ptr_ptr;	/* cdr pointer into contents.  */
  const char *tmp = NULL;
d1198 2
a1199 5

	  if (tmp != NULL)
	    free ((char *) tmp);
	  tmp = normalize (*files_to_move, arch);
	  if (FILENAME_CMP (tmp, current_ptr->filename) == 0)
d1223 1
a1223 2
    next_file:
      ;
a1226 2
  if (tmp != NULL)
    free ((char *) tmp);
@


1.75
log
@	* ar.c (delete_members): Plug memory leak.
@
text
@d1072 1
@


1.74
log
@	* ar.c (move_members): Plug memory leak.
@
text
@d1121 1
d1143 4
a1146 2
	  if (FILENAME_CMP (normalize (*files_to_delete, arch),
			    (*current_ptr_ptr)->filename) == 0)
d1183 3
@


1.73
log
@	PR 12590
	* ar.c (ranlib_main): Init arg_index properly.
	(usage): Describe --target.
@
text
@d1188 3
a1190 2
  bfd **after_bfd;		/* New entries go after this one */
  bfd **current_ptr_ptr;	/* cdr pointer into contents */
d1198 5
a1202 2
	  if (FILENAME_CMP (normalize (*files_to_move, arch),
			    current_ptr->filename) == 0)
d1226 2
a1227 1
    next_file:;
d1231 2
@


1.72
log
@	* ar.c: Formatting.
	(usage): Correct help strings.
	(decode_options): Correct getopt_long short options.  Remove
	duplicate non-handled option message.
	(main): Don't handle -M specially.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d293 1
d589 1
a589 1
  arg_index = 1;
@


1.71
log
@	* ar.c (long_options): Add target.
	(decode_options): Handle the --target option.
	(open_inarch): Check for plugin's target, default to --target
	(replace_members): Use generic `target'.
@
text
@d219 2
a220 2
	  if ((filename != NULL) &&
	      (!FILENAME_CMP (normalize (*files, arch), filename)))
d251 1
d253 4
a256 3
  const char * command_line =
#if BFD_SUPPORTS_PLUGINS
	_("Usage: %s [emulation options] [-]{dmpqrstx}[abcfilNoPsSuvV] [--plugin <name>] [member-name] [count] archive-file file...\n");
d258 4
a261 1
	_("Usage: %s [emulation options] [-]{dmpqrstx}[abcfilNoPsSuvV] [member-name] [count] archive-file file...\n");
d309 1
a309 1
ranlib_usage(int help)
d386 1
a386 1
decode_options(int argc, char **argv)
d435 1
a435 1
  while ((c = getopt_long (argc, argv, "hdmpqrstxabcfilNoPsSuvV",
a546 2
          /* xgettext:c-format */
          non_fatal (_("illegal option -- '%d'"), c);
d555 1
a555 1
ranlib_main(int argc, char **argv)
d583 1
a583 1
    usage(1);
a601 3
/* The option parsing should be in its own function.
   It will be when I have getopt working.  */

d655 1
a655 7
    ranlib_main(argc, argv);

  if (argc == 2 && strcmp (argv[1], "-M") == 0)
    {
      mri_emul ();
      xexit (0);
    }
d660 1
a660 1
  argv = decode_options(argc, argv);
d663 1
a663 1
    usage(1);
d706 1
a706 1
	     fatal (_("`N' is only meaningful with the `x' and `d' options."));
d715 1
a715 1
	      continue;
d797 2
a798 2
/* KLUDGE ALERT! Temporary fix until I figger why
   stat() is wrong ... think it's buried in GO32's IDT - Jax */
@


1.70
log
@	* ar.c (operation): New global variable.
	(show_version): Likewise.
	(show_help): Likewise.
	(long_options): Likewise.
	(usage): Fix help string argument order.
	(decode_options): New.
	(ranlib_main): Use getopt_long.
	(main): Use decode_options.
@
text
@d146 2
d149 1
d155 1
d536 3
a782 1
  const char *target;
d791 2
a792 1
  target = plugin_target;
d1280 1
a1280 1
				       plugin_target, verbose))
d1296 1
a1296 1
      if (ar_emul_append (after_bfd, *files_to_move, plugin_target,
@


1.69
log
@	* ar.c (main): Split ranlib path.
	(ranlib_usage): New
	(ranlib_main): New
@
text
@d24 3
a26 5
   Bugs: should use getopt the way tar does (complete w/optional -) and
   should have long options too. GNU ar used to check file against filesystem
   in quick_update and replace operations (would check mtime). Doesn't warn
   when name truncated. No way to specify pos_end. Error messages should be
   more consistent.  */
d32 1
d115 6
d140 4
d146 10
d250 1
a250 1
	_("Usage: %s [emulation options] [--plugin <name>] [-]{dmpqrstx}[abcfilNoPsSuvV] [member-name] [count] archive-file file...\n");
d376 168
d549 1
d551 1
a551 1
  if (argc > 1 && argv[1][0] == '-')
d553 14
a566 6
      if (strcmp (argv[1], "--help") == 0)
	ranlib_usage (1);
      else if (strcmp (argv[1], "--version") == 0)
	{
	  print_version ("ranlib");
	}
d569 1
a569 4
  if (argc < 2
      || strcmp (argv[1], "--help") == 0
      || strcmp (argv[1], "-h") == 0
      || strcmp (argv[1], "-H") == 0)
d572 4
a575 3
  if (strcmp (argv[1], "-V") == 0
      || strcmp (argv[1], "-v") == 0
      || CONST_STRNEQ (argv[1], "--v"))
d577 1
a579 6
  if (strcmp (argv[1], "-t") == 0)
    {
      ++arg_index;
      touch = TRUE;
    }

a599 7
  char *arg_ptr;
  char c;
  enum
    {
      none = 0, del, replace, print_table,
      print_files, extract, move, quick_append
    } operation = none;
a603 1
  int show_version;
a604 1
  int do_posix = 0;
a633 1

a638 2
  show_version = 0;

a649 8
  if (argc > 1 && argv[1][0] == '-')
    {
      if (strcmp (argv[1], "--help") == 0)
	usage (1);
      else if (strcmp (argv[1], "--version") == 0)
	print_version ("ar");
    }

d659 1
a659 10
  arg_index = 1;
  arg_ptr = argv[arg_index];

  if (strcmp (arg_ptr, "--plugin") == 0)
    {
#if BFD_SUPPORTS_PLUGINS
      if (argc < 4)
	usage (1);

      bfd_plugin_set_plugin (argv[2]);
d661 2
a662 126
      arg_index += 2;
      arg_ptr = argv[arg_index];

      plugin_target = "plugin";
#else
      fprintf (stderr, _("sorry - this program has been built without plugin support\n"));
      xexit (1);
#endif
    }

  if (*arg_ptr == '-')
    {
      /* When the first option starts with '-' we support POSIX-compatible
	 option parsing.  */
      do_posix = 1;
      ++arg_ptr;			/* compatibility */
    }

  do
    {
      while ((c = *arg_ptr++) != '\0')
	{
	  switch (c)
	    {
	    case 'd':
	    case 'm':
	    case 'p':
	    case 'q':
	    case 'r':
	    case 't':
	    case 'x':
	      if (operation != none)
		fatal (_("two different operation options specified"));
	      switch (c)
		{
		case 'd':
		  operation = del;
		  operation_alters_arch = TRUE;
		  break;
		case 'm':
		  operation = move;
		  operation_alters_arch = TRUE;
		  break;
		case 'p':
		  operation = print_files;
		  break;
		case 'q':
		  operation = quick_append;
		  operation_alters_arch = TRUE;
		  break;
		case 'r':
		  operation = replace;
		  operation_alters_arch = TRUE;
		  break;
		case 't':
		  operation = print_table;
		  break;
		case 'x':
		  operation = extract;
		  break;
		}
	    case 'l':
	      break;
	    case 'c':
	      silent_create = 1;
	      break;
	    case 'o':
	      preserve_dates = 1;
	      break;
	    case 'V':
	      show_version = TRUE;
	      break;
	    case 's':
	      write_armap = 1;
	      break;
	    case 'S':
	      write_armap = -1;
	      break;
	    case 'u':
	      newer_only = 1;
	      break;
	    case 'v':
	      verbose = 1;
	      break;
	    case 'a':
	      postype = pos_after;
	      break;
	    case 'b':
	      postype = pos_before;
	      break;
	    case 'i':
	      postype = pos_before;
	      break;
	    case 'M':
	      mri_mode = 1;
	      break;
	    case 'N':
	      counted_name_mode = TRUE;
	      break;
	    case 'f':
	      ar_truncate = TRUE;
	      break;
	    case 'P':
	      full_pathname = TRUE;
	      break;
	    case 'T':
	      make_thin_archive = TRUE;
	      break;
	    case 'D':
	      deterministic = TRUE;
	      break;
	    default:
	      /* xgettext:c-format */
	      non_fatal (_("illegal option -- %c"), c);
	      usage (0);
	    }
	}

      /* With POSIX-compatible option parsing continue with the next
	 argument if it starts with '-'.  */
      if (do_posix && arg_index + 1 < argc && argv[arg_index + 1][0] == '-')
	arg_ptr = argv[++arg_index] + 1;
      else
	do_posix = 0;
    }
  while (do_posix);
d667 1
a667 3
  ++arg_index;
  if (arg_index >= argc)
    usage (0);
d713 4
a716 2
      files = arg_index < argc ? argv + arg_index : NULL;
      file_count = argc - arg_index;
@


1.68
log
@	* ar.c (print_contents): Don't internationalize strings without words.
	* dwarf.c (process_extended_line_op): Likewise.
	(process_debug_info): Likwise.
	(display_debug_lines_raw): Likewise.
	(display_debug_lines_decoded): Likewise.
	(display_debug_abbrev): Likewise.
	* readelf.c (process_file_header): Likewise.
	(GET_OP): Likewise.
	(decode_arm_unwind): Likewise.
	(process_mips_specific): Likewise.
	* resrc.c (run_cmd): Likewise.
	(rcparse_warning): Likewise.
	* objdump.c (dump_headers): Don't print "Pg".
@
text
@d228 2
a229 4
  if (! is_ranlib)
    {
      /* xgettext:c-format */
      const char * command_line =
d235 1
a235 1
      fprintf (s, command_line, program_name);
d237 28
a264 28
      /* xgettext:c-format */
      fprintf (s, _("       %s -M [<mri-script]\n"), program_name);
      fprintf (s, _(" commands:\n"));
      fprintf (s, _("  d            - delete file(s) from the archive\n"));
      fprintf (s, _("  m[ab]        - move file(s) in the archive\n"));
      fprintf (s, _("  p            - print file(s) found in the archive\n"));
      fprintf (s, _("  q[f]         - quick append file(s) to the archive\n"));
      fprintf (s, _("  r[ab][f][u]  - replace existing or insert new file(s) into the archive\n"));
      fprintf (s, _("  s            - act as ranlib\n"));
      fprintf (s, _("  t            - display contents of archive\n"));
      fprintf (s, _("  x[o]         - extract file(s) from the archive\n"));
      fprintf (s, _(" command specific modifiers:\n"));
      fprintf (s, _("  [a]          - put file(s) after [member-name]\n"));
      fprintf (s, _("  [b]          - put file(s) before [member-name] (same as [i])\n"));
      fprintf (s, _("  [D]          - use zero for timestamps and uids/gids\n"));
      fprintf (s, _("  [N]          - use instance [count] of name\n"));
      fprintf (s, _("  [f]          - truncate inserted file names\n"));
      fprintf (s, _("  [P]          - use full path names when matching\n"));
      fprintf (s, _("  [o]          - preserve original dates\n"));
      fprintf (s, _("  [u]          - only replace files that are newer than current archive contents\n"));
      fprintf (s, _(" generic modifiers:\n"));
      fprintf (s, _("  [c]          - do not warn if the library had to be created\n"));
      fprintf (s, _("  [s]          - create an archive index (cf. ranlib)\n"));
      fprintf (s, _("  [S]          - do not build a symbol table\n"));
      fprintf (s, _("  [T]          - make a thin archive\n"));
      fprintf (s, _("  [v]          - be verbose\n"));
      fprintf (s, _("  [V]          - display the version number\n"));
      fprintf (s, _("  @@<file>      - read options from <file>\n"));
d266 2
a267 2
      fprintf (s, _(" optional:\n"));
      fprintf (s, _("  --plugin <p> - load the specified plugin\n"));
d269 22
a290 8
      ar_emul_usage (s);
    }
  else
    {
      /* xgettext:c-format */
      fprintf (s, _("Usage: %s [options] archive\n"), program_name);
      fprintf (s, _(" Generate an index to speed access to archives\n"));
      fprintf (s, _(" The options are:\n\
d293 1
a293 1
      fprintf (s, _("\
d296 1
a296 1
      fprintf (s, _("\
a299 1
    }
d357 46
a453 12
  if (argc > 1 && argv[1][0] == '-')
    {
      if (strcmp (argv[1], "--help") == 0)
	usage (1);
      else if (strcmp (argv[1], "--version") == 0)
	{
	  if (is_ranlib)
	    print_version ("ranlib");
	  else
	    print_version ("ar");
	}
    }
d471 3
d475 4
a478 27
      int status = 0;
      bfd_boolean touch = FALSE;

      if (argc < 2
	  || strcmp (argv[1], "--help") == 0
	  || strcmp (argv[1], "-h") == 0
	  || strcmp (argv[1], "-H") == 0)
	usage (0);
      if (strcmp (argv[1], "-V") == 0
	  || strcmp (argv[1], "-v") == 0
	  || CONST_STRNEQ (argv[1], "--v"))
	print_version ("ranlib");
      arg_index = 1;
      if (strcmp (argv[1], "-t") == 0)
	{
	  ++arg_index;
	  touch = TRUE;
	}
      while (arg_index < argc)
	{
	  if (! touch)
	    status |= ranlib_only (argv[arg_index]);
	  else
	    status |= ranlib_touch (argv[arg_index]);
	  ++arg_index;
	}
      xexit (status);
@


1.67
log
@        PR binutils/12058
        * ar.c (usage): Revert previous change.  Describe how 's' can be
        used as a command letter.
        * doc/binutils.texi (ar cmdline): Describe how 's' can be used as
        a command letter.
@
text
@d823 1
a823 2
    /* xgettext:c-format */
    printf (_("\n<%s>\n\n"), bfd_get_filename (abfd));
@


1.67.2.1
log
@backport from mainline
@
text
@d823 2
a824 1
    printf ("\n<%s>\n\n", bfd_get_filename (abfd));
@


1.66
log
@        PR binutils/12058
        * ar.c (usage): Remove spurious 's' from list of accepted command
        letters.
@
text
@d233 1
a233 1
	_("Usage: %s [emulation options] [--plugin <name>] [-]{dmpqrtx}[abcfilNoPsSuvV] [member-name] [count] archive-file file...\n");
d235 1
a235 1
	_("Usage: %s [emulation options] [-]{dmpqrtx}[abcfilNoPsSuvV] [member-name] [count] archive-file file...\n");
d247 1
@


1.65
log
@Pass "plugin" as target for "ar --plugin" when opening a BFD file.

2010-09-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* ar.c (plugin_target): New.
	(main): Set plugin_target to "plugin" for --plugin.
	(open_inarch): Initialize target to plugin_target.
	(replace_members): Pass plugin_target to ar_emul_replace
	and ar_emul_append.

	* binemul.h (ar_emul_append): Add a target argument.
	(ar_emul_default_append): Likewise.
	(ar_emul_replace): Likewise.
	(ar_emul_default_replace): Likewise.
	(bin_emulation_xfer_struct): Add a target argument to
	ar_append and ar_replace.

	* binemul.c (ar_emul_append): Updated.  Pass target to bfd_openr.
	(do_ar_emul_default_append): Likewise.
	(ar_emul_default_append): Likewise.
	(ar_emul_replace): Likewise.
	(ar_emul_default_replace): Likewise.
@
text
@d233 1
a233 1
	_("Usage: %s [emulation options] [--plugin <name>] [-]{dmpqrstx}[abcfilNoPsSuvV] [member-name] [count] archive-file file...\n");
d235 1
a235 1
	_("Usage: %s [emulation options] [-]{dmpqrstx}[abcfilNoPsSuvV] [member-name] [count] archive-file file...\n");
@


1.64
log
@2010-01-13  Tristan Gingold  <gingold@@adacore.com>

	* ar.c (main): Use lbasename.
	(normalize): Ditto.
	* objdump.c (update_source_path): Ditto.
@
text
@d135 2
d477 2
d723 1
a723 1
  target = NULL;
d754 1
a754 1
	  obj = bfd_openr (file, NULL);
d1212 1
a1212 1
				       verbose))
d1228 2
a1229 2
      if (ar_emul_append (after_bfd, *files_to_move, verbose,
                          make_thin_archive))
@


1.63
log
@2010-01-08  Tristan Gingold  <gingold@@adacore.com>

	* ar.c: Remove bfd_special_undocumented_glue prototype.
@
text
@d306 1
a306 16
  filename = strrchr (file, '/');
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
  {
    /* We could have foo/bar\\baz, or foo\\bar, or d:bar.  */
    char *bslash = strrchr (file, '\\');

    if (filename == NULL || (bslash != NULL && bslash > filename))
      filename = bslash;
    if (filename == NULL && file[0] != '\0' && file[1] == ':')
      filename = file + 1;
  }
#endif
  if (filename != (char *) NULL)
    filename++;
  else
    filename = file;
d385 1
a385 7
      char *temp;

      temp = strrchr (program_name, '/');
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
      {
	/* We could have foo/bar\\baz, or foo\\bar, or d:bar.  */
	char *bslash = strrchr (program_name, '\\');
a386 10
	if (temp == NULL || (bslash != NULL && bslash > temp))
	  temp = bslash;
	if (temp == NULL && program_name[0] != '\0' && program_name[1] == ':')
	  temp = program_name + 1;
      }
#endif
      if (temp == NULL)
	temp = program_name;
      else
	++temp;
@


1.62
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
a48 5
/* Kludge declaration from BFD!  This is ugly!  FIXME!  XXX  */

struct ar_hdr *
  bfd_special_undocumented_glue (bfd * abfd, const char *filename);

@


1.61
log
@        Updated soruces in binutils/* to compile cleanly with -Wc++-compat.

        * binutils/addr2line.c (slurp_symtab): Fix casts. Introduce
        variable minisyms to avoid aliasing varning.
        * binutils/ar.c: Add casts. (normalize): Use name del instead of
        delete. (display_target_list,display_info_table): Change loop
        counter variable a to int.
        * binutils/bucomm.c: Add casts.
        * binutils/debug.c: Update function to use new names. (struct
        debug_baseclass): Rename member from virtual to
        is_virtual. (struct debug_type_s,struct debug_field_s,struct
        debug_baseclass_s,struct debug_method_s,struct
        debug_method_variant_s,struct debug_type_s): Rename struct from
        avoid name collision.
        * /binutils/debug.h: Use new struct names.
        * binutils/dwarf.c: Add casts. (free_debug_memory): Change loop
        counter variable a to int.
        * binutils/ieee.c: Add casts. (enum ieee_var_kind): Move to top
        level. (ieee_class_baseclass): Rename parameter virtual to
        is_virtual. (ieee_class_method_var): Rename variable virtual to
        is_virtual.
        * binutils/nm.c: Add casts.
        * binutils/objcopy.c: Add casts. (copy_archive): Rename variable
        delete to del.
        * binutils/objdump.c: Add casts. (dump_dwarf_section): Change loop
        counter variable i to int.
        * binutils/prdbg.c: Add
        casts. (pr_class_baseclass,tg_class_baseclass): Rename parameters
        virtual to is_virtual.
        * binutils/readelf.c: Add casts. (struct
        ia64_unw_table_entry,struct hppa_unw_table_entry): Move to top
        level.
        * binutils/size.c: Add casts.
        * binutils/stabs.c (parse_stab_type, parse_stab_range_type)
        (parse_stab_cpp_abbrev): Rename parameter from typename to
        type_name. (parse_stab_baseclasses): Rename variable virtual to
        is_virtual.
        * binutils/strings.c: Add casts.
        * binutils/wrstabs.c (stab_class_baseclass): Rename parameter
        virtual to is_virtual.
@
text
@d1171 1
a1171 1
	      bfd *link;
d1176 1
a1176 1
	      link = *after_bfd;
d1178 1
a1178 1
	      current_ptr->archive_next = link;
@


1.60
log
@        * ar.c (usage): Do not use #ifdef inside _("...).
        * nm.c (usage): Likewise.
@
text
@d335 1
a335 1
      s = xmalloc (abfd->xvec->ar_max_namelen + 1);
d375 1
a375 1
      none = 0, delete, replace, print_table,
d543 1
a543 1
		  operation = delete;
d676 1
a676 1
	  if (operation != extract && operation != delete)
d708 1
a708 1
	case delete:
d846 1
a846 1
  char *cbuf = xmalloc (BUFSIZE);
d898 1
a898 1
  char *cbuf = xmalloc (BUFSIZE);
d992 1
a992 1
  old_name = xmalloc (strlen (bfd_get_filename (iarch)) + 1);
@


1.60.4.1
log
@        Update soruces to compile cleanly with -Wc++-compat:

        * addr2line.c (slurp_symtab): Fix casts. Introduce variable
        minisyms to avoid aliasing varning.
        * ar.c: Add casts.
        (normalize): Use name del instead of delete.
        (display_target_list,display_info_table): Change loop counter
        variable a to int.
        * bucomm.c: Add casts.
        * debug.c: Update function to use new names.
        (struct debug_baseclass): Rename member from virtual to
        is_virtual.
        (struct debug_type_s, struct debug_field_s, struct
        debug_baseclass_s, struct debug_method_s, struct
        debug_method_variant_s, struct debug_type_s): Rename struct from
        avoid name collision.
        * debug.h: Use new struct names.
        * dwarf.c: Add casts.
        (free_debug_memory): Change loop counter variable a to int.
        * ieee.c: Add casts.
        (enum ieee_var_kind): Move to top level.
        (ieee_class_baseclass): Rename parameter virtual to is_virtual.
        (ieee_class_method_var): Rename variable virtual to is_virtual.
        * nm.c: Add casts.
        * objcopy.c: Add casts.
        (copy_archive): Rename variable delete to del.
        * objdump.c: Add casts.
        (dump_dwarf_section): Change loop counter variable i to int.
        * prdbg.c: Add casts.
        (pr_class_baseclass,tg_class_baseclass): Rename parameters virtual
        to is_virtual.
        * readelf.c: Add casts.
        (struct ia64_unw_table_entry,struct hppa_unw_table_entry): Move to
        top level.
        * size.c: Add casts.
        * stabs.c (parse_stab_type, parse_stab_range_type,
        (parse_stab_cpp_abbrev): Rename parameter from typename to
        type_name.
        (parse_stab_baseclasses): Rename variable virtual to is_virtual.
        * strings.c: Add casts.
        * wrstabs.c (stab_class_baseclass): Rename parameter virtual to
        is_virtual.
@
text
@d335 1
a335 1
      s = (char *) xmalloc (abfd->xvec->ar_max_namelen + 1);
d375 1
a375 1
      none = 0, del, replace, print_table,
d543 1
a543 1
		  operation = del;
d676 1
a676 1
	  if (operation != extract && operation != del)
d708 1
a708 1
	case del:
d846 1
a846 1
  char *cbuf = (char *) xmalloc (BUFSIZE);
d898 1
a898 1
  char *cbuf = (char *) xmalloc (BUFSIZE);
d992 1
a992 1
  old_name = (char *) xmalloc (strlen (bfd_get_filename (iarch)) + 1);
@


1.59
log
@2009-05-28  Nick Clifton  <nickc@@redhat.com>

        * targets.c (_bfd_target_vector): Only include plugin target in
        all-targets build if BFD_SUPPORTS_PLUGINS is non-zero.

2009-05-27  Rafael Avila de Espindola  <espindola@@google.com>

        * plugin.c (program_name): Remove.
        (plugin_program_name): New.
        (bfd_plugin_set_program_name): New.
        (try_load_plugin): Use plugin_program_name.
        * plugin.h (bfd_plugin_set_program_name): New.

2009-05-27  Rafael Avila de Espindola  <espindola@@google.com>

        * ar.c (main): Call bfd_plugin_set_program_name.
        * nm.c (main): Call bfd_plugin_set_program_name.
@
text
@d281 1
a281 1
  @@<file>                      Read options from <file>\n"
d283 2
a284 1
"  --plugin <name>              Load the specified plugin\n"
d286 2
a287 1
"  -t                           Update the archive's symbol map timestamp\n\
@


1.58
log
@        * Makefile.am: Run "make dep-am".
        (AM_CPPFLAGS): New.
        (LIBDL): New.
        (ALL_MACHINES): Add cpu-plugin.lo.
        (ALL_MACHINES_CFILES): Add cpu-plugin.c.
        (BFD32_BACKENDS): Add plugin.lo.
        (BFD32_BACKENDS_CFILES): Add plugin.c.
        (libbfd_la_LIBADD): Add LIBDL
        * archures.c (bfd_architecture): Add bfd_arch_plugin.
        (bfd_plugin_arch): Declare.
        * bfd-in.h (BFD_SUPPORTS_PLUGINS): New.
        * bfd.c (bfd): Add plugin_data.
        * config.bfd: Handle the plugin target.
        * configure.in: Check for --enable-plugins.
        (LT_INIT): Use the dlopen option.
        * cpu-plugin.c: New.
        * plugin.c: New.
        * plugin.h: New.
        * targets.c (plugin_vec): Declare.
        (_bfd_target_vector): Add plugin_vec.
        * Makefile.in: Regenerate.
        * bfd-in2.h: Regenerate.
        * configure: Regenerate.
        * ar.c: Include plugin.h.
        (main): Handle the --plugin option.
        * nm.c: Include plugin.h.
        (OPTION_PLUGIN): New.
        (long_options): Add plugin.
        (main): Handle OPTION_PLUGIN.
        * NEWS: Mention  the new feature.
        * doc/binutils: Documement the new command line options.
        * configure.in: Check for --enable-plugins.
        * configure: Regenerate.
@
text
@d395 3
@


1.57
log
@[bfd/ChangeLog]
2009-03-11  Chris Demetriou  <cgd@@google.com>

	* bfd.c (BFD_DETERMINISTIC_OUTPUT): New flag.
	* bfd-in2.h: Regenerate.
	* archive.c (bfd_ar_hdr_from_filesystem): If BFD_DETERMINISTIC_OUTPUT
	flag is set, use 0 for uid, gid, and timestamp, and use 0644 for file
	mode.
	(bsd_write_armap): Likewise.
	(_bfd_archive_bsd_update_armap_timestamp): If BFD_DETERMINISTIC_OUTPUT
	flag is set, do nothing.
	(coff_write_armap): If BFD_DETERMINISTIC_OUTPUT flag is set, use 0
	for timestamp.

[binutils/ChangeLog]
2009-03-11  Chris Demetriou  <cgd@@google.com>

	* ar.c (deterministic): New global variable.
	(main): Recognize new 'D' option, which enables 'deterministic mode'.
	(usage): Document new 'D' option.
	(write_archive): Set BFD_DETERMINISTIC_OUTPUT in output archive's
	flags if deterministic mode was requested.
	* doc/binutils.texi (ar): Document deterministic mode ('D' option).

[binutils/testsuite/ChangeLog]
2009-03-11  Chris Demetriou  <cgd@@google.com>

	* binutils-all/ar.exp (deterministic_archive): New test.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
d40 1
d234 8
a241 2
      fprintf (s, _("Usage: %s [emulation options] [-]{dmpqrstx}[abcfilNoPsSuvV] [member-name] [count] archive-file file...\n"),
	       program_name);
d269 4
a272 1

d281 5
a285 2
  @@<file>                      Read options from <file>\n\
  -t                           Update the archive's symbol map timestamp\n\
d496 16
@


1.56
log
@                PR binutils/6449
                * objdump.c (slurp_file): Open the file in binary mode.
                * ar.c: Remove conditional definition of O_BINARY.
                * bin2.c: Likewise.
                * rename.c: Likewise.
                * strings.c: Likewise.
                * sysdep.h: Add conditional definition of O_BINARY.
@
text
@d102 5
d248 1
d581 3
d634 3
d987 3
@


1.55
log
@Add support for thin archives.
    * bfd/archive.c (_bfd_find_nested_archive): New function.
    (get_extended_arelt_filename): Add origin parameter.
    (_bfd_generic_read_ar_hdr_mag): Deal with extended name
    combined with a file offset.
    (append_relative_path): New function.
    (_bfd_get_elt_at_filepos): Deal with external members and
    nested archives.
    (bfd_generic_openr_next_archived_file): Thin archives.
    (bfd_generic_archive_p): Recognize new magic string.
    (adjust_relative_path): New function.
    (_bfd_construct_extended_name_table): Construct extended
    names for thin archive members.
    (_bfd_write_archive_contents): Emit new magic string, skip
    copying files for thin archives.
    * bfd/bfd-in.h (bfd_is_thin_archive): New macro.
    * bfd/bfd.c (struct bfd): New fields for thin archives.
    * bfd/libbfd-in.h (struct areltdata): New field for thin archives.
    * bfd/opncls.c (bfd_close): Delete BFDs for nested archives.
    * binutils/ar.c (make_thin_archive): New global flag.
    (map_over_members): Deal with full pathnames in thin archives.
    (usage, main): Add 'T' option for building thin archives.
    (replace_members): Pass thin archive flag to ar_emul_append.
    * binutils/arsup.c (ar_open): Initialize new flag.
    * binutils/binemul.c (ar_emul_append): Add new parameter for
    flattening nested archives.
    (do_ar_emul_default_append): New function.
    (ar_emul_default_append): Factored out recursive code.
    * binutils/binemul.h (ar_emul_default_append): Add new parameter.
    (struct bin_emulation_xfer_struct): New parameter for ar_append.
    * binutils/dlltool.c (gen_lib_file): Initialize thin archive flag.
    * binutils/emul_aix.c (ar_emul_aix_internal): Add new flatten
    parameter, currently unimplemented.
    All callers changed.
    * binutils/objcopy.c (copy_archive): Preserve thin archive flag.
    * binutils/doc/binutils.texi: Update ar documentation.
    * binutils/testsuite/binutils-all/ar.exp: Add thin archive tests.
    * include/aout/ar.h (ARMAGT): New magic string for thin archives.
@
text
@a47 6
/* We need to open files in binary modes on system where that makes a
   difference.  */
#ifndef O_BINARY
#define O_BINARY 0
#endif

@


1.54
log
@        * ar.c (usage): Mention -t command line switch.
        * doc/binutils.texi (ranlib): Document -t command line switch.
@
text
@d43 1
a43 1
#define EXT_NAME_LEN 3		/* bufflen of addition to name if it's MS-DOS */
d45 1
a45 1
#define EXT_NAME_LEN 6		/* ditto for *NIX */
d54 1
a54 1
/* Kludge declaration from BFD!  This is ugly!  FIXME!  XXX */
d59 1
a59 1
/* Static declarations */
d77 1
a77 1
/** Globals and flags */
d137 3
d182 2
d185 2
a186 1
	  if (head->filename == NULL)
d193 8
a200 2
	  if ((head->filename != NULL) &&
	      (!FILENAME_CMP (normalize (*files, arch), head->filename)))
d215 1
d258 1
d262 1
a262 1
 
d301 1
d320 1
a320 1
      s = (char *) xmalloc (abfd->xvec->ar_max_namelen + 1);
d394 1
d578 3
d651 3
d958 1
a958 1
  
d981 3
d1217 2
a1218 1
      if (ar_emul_append (after_bfd, *files_to_move, verbose))
@


1.53
log
@Change sources over to using GPLv3
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007
d258 1
d260 1
a260 1
  -V --version                 Print version information\n"));
@


1.52
log
@bfd/
	* bfd.c (struct bfd): Rename "next" to "archive_next".
	* archive.c: Rename uses throughout file.
	* archive64.c: Likewise.
	* coff-rs6000.c: Likewise.
	* ecoff.c: Likewise.
	* som.c: Likewise.
	* bfd-in2.h: Regenerate.
binutils/
	* ar.c: Rename uses of bfd.next to bfd.archive_next throughout.
	* arsup.c: Likewise.
	* binemul.c: Likewise.
	* objcopy.c: Likewise.
	* dlltool.c: Likewise.
ld/
	* pe-dll.c: Rename uses of bfd.next to bfd.archive_next throughout.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
d20 2
a21 1
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.51
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d157 1
a157 1
      for (head = arch->next; head; head = head->next)
d176 1
a176 1
      for (head = arch->next; head; head = head->next)
d762 1
a762 1
  last_one = &(arch->next);
d770 1
a770 1
      last_one = &next_one->next;
d926 1
a926 1
  bfd *contents_head = iarch->next;
d998 1
a998 1
	after_bfd = &((*after_bfd)->next);
d1002 1
a1002 1
      for (; *after_bfd; after_bfd = &(*after_bfd)->next)
d1006 1
a1006 1
	      after_bfd = &(*after_bfd)->next;
d1038 1
a1038 1
      current_ptr_ptr = &(arch->next);
d1058 1
a1058 1
		  *current_ptr_ptr = ((*current_ptr_ptr)->next);
d1063 1
a1063 1
	  current_ptr_ptr = &((*current_ptr_ptr)->next);
d1092 1
a1092 1
      current_ptr_ptr = &(arch->next);
d1102 1
a1102 1
	      *current_ptr_ptr = current_ptr->next;
d1105 1
a1105 1
	      after_bfd = get_pos_bfd (&arch->next, pos_end, NULL);
d1108 1
a1108 1
	      current_ptr->next = link;
d1116 1
a1116 1
	  current_ptr_ptr = &((*current_ptr_ptr)->next);
d1141 1
a1141 1
	  current_ptr = &arch->next;
d1171 1
a1171 1
		  after_bfd = get_pos_bfd (&arch->next, pos_after,
d1177 1
a1177 1
		      *current_ptr = (*current_ptr)->next;
d1183 1
a1183 1
	      current_ptr = &(current->next);
d1188 1
a1188 1
      after_bfd = get_pos_bfd (&arch->next, pos_end, NULL);
@


1.50
log
@top level:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.ac (TOPLEVEL_CONFIGURE_ARGUMENTS): Fix quoting.
	* configure: Regenerate.

bfd:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-pkgversion): New option.
	* configure: Regenerate.
	* Makefile.am (bfdver.h): Substitute for @@bfd_version_package@@.
	* Makefile.in: Regenerate.
	* version.h (BFD_VERSION_STRING): Define using
	@@bfd_version_package@@.

bfd/doc:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* Makefile.in: Regenerate.

binutils:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-bugurl): New option.
	* configure: Regenerate.
	* Makefile.am (REPORT_BUGS_TO): Define.
	(INCLUDES): Define REPORT_BUGS_TO.
	Regenerate dependencies.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* bucomm.h: Remove include of bin-bugs.h.
	* addr2line.c (usage): Don't print empty REPORT_BUGS_TO.
	* ar.c (usage): Pass s to list_supported_targets.  Don't print
	empty REPORT_BUGS_TO.
	* coffdump.c (show_usage): Don't print empty REPORT_BUGS_TO.
	* cxxfilt.c (usage): Print bug url when giving help.
	* dlltool.c (usage): Likewise.
	* dllwrap.c (usage): Likewise.
	* nlmconv.c (show_usage): Don't print empty REPORT_BUGS_TO.
	* nm.c (usage): Likewise.
	* objcopy.c (copy_usage, strip_usage): Likewise.
	* objdump.c (usage): Likewise.
	* readelf.c ((usage): Likewise. Add STREAM argument.  Adjust
	callers.
	* size.c (usage): Don't print empty REPORT_BUGS_TO.
	* srconv.c (show_usage): Likewise.
	* strings.c (usage): Likewise.
	* sysdymp.c (show_usage): Likewise.
	* windres.c (usage): Likewise.

gas:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-bugurl): New option.
	* configure: Regenerate.
	* dep-in.sed: Remove bin-bugs.h.
	* Makefile.am (REPORT_BUGS_TO): Define.
	(INCLUDES): Define REPORT_BUGS_TO.
	(DEP_INCLUDES): Likewise.
	($(OBJS)): No longer depend on bin-bugs.h.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* as.c (show_usage): Don't print empty REPORT_BUGS_TO.
	* as.h: Remove include of bin-bugs.h.

gprof:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-pkgversion, --with-bugurl): New options.
	* configure: Regenerate.
	* Makefile.am (PKGVERSION, REPORT_BUGS_TO): Define.
	(INCLUDES): Define PKGVERSION and REPORT_BUGS_TO.
	Regenerate dependencies.
	* Makefile.in: Regenerate.
	* gprof.c (usage): Don't print empty REPORT_BUGS_TO.
	(main): Include PKGVERSION in version output.
	* gprof.h: Remove include of bin-bugs.h.

include:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* bin-bugs.h: Remove.

ld:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-bugurl): New option.
	* configure: Regenerate.
	* Makefile.am (REPORT_BUGS_TO): Define.
	(INCLUDES): Define REPORT_BUGS_TO.
	Regenerate dependencies.
	* Makefile.in: Regenerate.
	* ld.h: Remove include of bin-bugs.h.
	* lexsup.c (help): Don't print empty REPORT_BUGS_TO.
@
text
@d29 1
a32 1
#include "bucomm.h"
d35 1
@


1.49
log
@	* ar.c (print_contents, extract_file): Cast the return value
	of fwrite to size_t.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006
d260 1
a260 1
  list_supported_targets (program_name, stderr);
d262 1
a262 1
  if (help)
@


1.48
log
@	* ar.c (open_inarch): Check fwrite return.  Use size_t.
	(extract_file): Likewise.  Remove test for "negative" file size.
	* readelf.c (process_program_headers): Check fscanf return.
@
text
@d808 5
a812 1
      if (fwrite (cbuf, 1, nread, stdout) != nread)
d892 5
a896 1
	if (fwrite (cbuf, 1, nread, ostream) != nread)
@


1.47
log
@PR binutils/2876
* configure.in: Check for the mkstemp and mkdtemp functions.
* configure: Regenerate.
* config.in (HAVE_MKDTEMP): New potential define.
(MAKE_MKSTEMP): Likewise.
* bucomm.c (make_tempname): Use mkstemp if it is available.
* make_tempdir): New function: Create a temporary directory using mkdtemp, if
it is available.
* bucomm.h (make_tempdir): New prototype.
* objcopy.c (copy_archive): Use make_tempdir if it is available.
  (strip_main): Produce an warning message if a temporary file could not be
  (copy_main): Likewise.
* ar.c (write_archive): Likewise.
@
text
@d780 1
a780 1
  int ncopied = 0;
d783 1
a783 1
  long size;
d798 2
a799 2
      int nread;
      int tocopy = size - ncopied;
d808 2
a809 1
      fwrite (cbuf, 1, nread, stdout);
d830 3
a832 3
  int nread, tocopy;
  long ncopied = 0;
  long size;
a839 4
  if (size < 0)
    /* xgettext:c-format */
    fatal (_("stat returns negative size for %s"), bfd_get_filename (abfd));

d888 2
a889 1
	fwrite (cbuf, 1, nread, ostream);
@


1.46
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d925 3
@


1.45
log
@ PR binutils/3001
* addr2line.c (process_file): Change function from void to returning an int.  Return 0 upon success, 1 otherwise.
 (main): Use return value from process_file as the exit value.
* ar.c (ranlib_only):  Change function from void to returning an int.  Return 0 upon success, 1 otherwise.
  (ranlib_touch): Likewise.
  (main): Use return value from ranlib functions as exit value.
* objcopy.c (add_specific_symbol): Set status to 1 if get_file_size fails.
  (copy_file): Likewise.
  (strip_main): Likewise.
  (copy_main): Likewise.
* objdump.c (display_file): Set exit_status to 1 if get_file_size fails.
* size.c (display_file): Set return_code to 1 if get_file_size fails.
@
text
@d433 1
a433 1
	  || strncmp (argv[1], "--v", 3) == 0)
@


1.44
log
@	* addr2line.c (usage): Document @@file.
	* ar.c (usage): Likewise.
	* coffdump (usage): Likewise.
	* cxxfilt.c (usage): Likewise.
	* dlltool.c (usage): Likewise.
	* dllwrap.c (usage): Likewise.
	* nlmconv.c (usage): Likewise.
	* nm.c (usage): Likewise.
	* objcopy.c (usage): Likewise.
	* objdump.c (usage): Likewise.
	* readelf.c (usage): Likewise.
	* size.c (usage): Likeise.
	* srconv.c (usage): Likewise.
	* strings.c (usage): Likewise.
	* windres.c (usage): Likewise.
	* doc/binutils.texi: Add section on common options.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005
d71 2
a72 2
static void ranlib_only (const char *archname);
static void ranlib_touch (const char *archname);
d423 1
d444 1
a444 1
	    ranlib_only (argv[arg_index]);
d446 1
a446 1
	    ranlib_touch (argv[arg_index]);
d449 1
a449 1
      xexit (0);
d601 1
a601 4
	{
	  ranlib_only (argv[arg_index]);
	  xexit (0);
	}
d1194 1
a1194 1
static void
d1200 1
a1200 1
    return;
d1206 1
d1211 1
a1211 1
static void
d1223 1
a1223 1
    return;
d1254 1
@


1.44.2.1
log
@	binutils/
	* ar.c (usage): Pass s to list_supported_targets.
	* cxxfilt.c (usage): Print bug url when giving help.
@
text
@d260 1
a260 1
  list_supported_targets (program_name, s);
@


1.44.2.2
log
@	binutils/
	* Makefile.am: Rebuild dependencies.
	(REPORT_BUGS_TO): Always defined.
	(INCLUDES): Adjust.
	* Makefile.in: Rebuilt.
	* configure.in (REPORT_BUGS_TO): Provide default value.
	* configure: Rebuilt.
	* bucomm.h: Remove bin-bugs.h.
	* addr2line.c (usage): Don't print empty REPORT_BUGS_TO.
	* coffdump.c (show_usage): Likewise.
	* cxxfilt.c (usage): Likewise.
	* nlmconv.c (show_usage): Likewise.
	* nm.c (usage): Likewise.
	* objcopy.c (copy_usage, strip_usage): Likewise.
	* objdump.c (usage): Likewise.
	* size.c (usage): Likewise.
	* srconv.c (show_usage): Likewise.
	* string.c (usage): Likewise.
	* sysdymp.c (show_usage): Likewise.
	* windres.c (usage): Likewise.
	* readelf (usage): Likewise. Add STREAM argument.  Adjust callers.

	gas/
	* Makefile.am: Rebuild dependencies.
	(REPORT_BUGS_TO): Always defined.
	(INCLUDES): Adjust.
	* Makefile.in: Rebuilt.
	* configure.in (REPORT_BUGS_TO): Provide default value.
	* configure: Rebuilt.
	* as.c (show_usage): Don't print empty REPORT_BUGS_TO.
	* as.h: Remove bin-bugs.h.

	ld/
	* Makefile.am: Rebuild dependencies.
	(REPORT_BUGS_TO): Always defined.
	(INCLUDES): Adjust.
	* Makefile.in: Rebuilt.
	* configure.in (REPORT_BUGS_TO): Provide default value.
	* configure: Rebuilt.
	* ld.h: Remove bin-bugs.h
	* lexsup.c (help):  Don't print empty REPORT_BUGS_TO.

	gprof/
	* Makefile.am: Rebuild dependencies.
	(REPORT_BUGS_TO): Always defined.
	(PKGVERSION): Define.
	(INCLUDES): Adjust.
	* Makefile.in: Rebuilt.
	* configure.in (REPORT_BUGS_TO): Provide default value.
	* configure: Rebuilt.
	* gprof.c (usage): Don't print empty REPORT_BUGS_TO.
	* gprof.h: Remove bin-bugs.h

	include/
	* bin-bugs.h: Remove.
@
text
@d262 1
a262 1
  if (REPORT_BUGS_TO[0] && help)
@


1.43
log
@	* addr2line.c (main): Likewise.
	* ar.c (main): Likewise.
	* coffdump.c (main): Likewise.
	* cxxfilt.c (main): Likewise.
	* dlltool.c (main): Likewise.
	* dllwrap.c (main): Likewise.
	* nlmconv.c (main): Likewise.
	* nm.c (main): Likewise.
	* objcopy.c (main): Likewise.
	* objdump.c (main): Likewise.
	* readelf.c (main): Likewise.
	* size.c (main): Likeiwse.
	* srcconv.c (main): Likewise.
	* strings.c (main): Likewise.
	* sysdump.c (main): Likewise.
	* sysinfo.c (main): Likewise.
	* windres.c (main): Likewise.

	* ldmain.c (main): Use expandargv.

	* gprof.c (main): Use expandargv.

	* as.c (main): Use expandargv.
@
text
@d245 2
a246 1

d255 1
@


1.42
log
@2005-06-14  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 995
	* ar.c (BUFSIZE): Moved to ...
	* bucomm.h (BUFSIZE): Here.

	* bucomm.c: Include <assert.h>.
	(bfd_get_archive_filename): New.
	* bucomm.h (bfd_get_archive_filename): New.

	* objcopy.c (copy_unknown_object): New.
	(copy_object): Use bfd_get_archive_filename when reporting input
	error. Don't call fatal on unknown arch.
	(copy_archive): Call copy_unknown_object on unknown format or
	arch.
@
text
@d363 2
@


1.41
log
@Update FSF address
@
text
@a51 2
#define BUFSIZE 8192

@


1.40
log
@	* ar.c (mri_mode): Make static.
	* arsup.c (obfd, real_name, outfile): Likewise.
	* binemul.c (ar_emul_create): Remove unused function.
	(ar_emul_default_create): Likewise.
	* binemul.h (ar_emul_create): Remove declaration.
	(ar_emul_default_create): Likewise.
	(struct bin_emulation_xfer_struct): Remove ar_create member.
	* bucomm.c (report): Make static.
	* bucomm.h (report): Remove declaration.
	* cxxfilt.c (mbuffer): Make static.
	(main): Use unsigned ints for some loop control variables.
	* readelf.c: Make many global variables static.
	* size.c (berkeley_format): Make static.
	(long_options): Likewise.
	* emul_aix.c (bin_aix_emulation): Remove ar_emul_default_create
	structure initialiser.
	(bin_aix5_emulation): Likewise.
	* emul_vanilla.c (bin_vanilla_emulation): Likewise.
@
text
@d20 1
a20 1
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.39
log
@update copyright dates
@
text
@d79 1
a79 1
int mri_mode;
@


1.39.6.1
log
@	* ld/ldmain.c (main): Use expandargv.
	* binutils/addr2line.c (main): Likewise.
	* binutils/ar.c (main): Likewise.
	* binutils/coffdump.c (main): Likewise.
	* binutils/cxxfilt.c (main): Likewise.
	* binutils/dlltool.c (main): Likewise.
	* binutils/dllwrap.c (main): Likewise.
	* binutils/nlmconv.c (main): Likewise.
	* binutils/nm.c (main): Likewise.
	* binutils/objcopy.c (main): Likewise.
	* binutils/objdump.c (main): Likewise.
	* binutils/readelf.c (main): Likewise.
	* binutils/size.c (main): Likeiwse.
	* binutils/srcconv.c (main): Likewise.
	* binutils/strings.c (main): Likewise.
	* binutils/sysdump.c (main): Likewise.
	* binutils/sysinfo.c (main): Likewise.
	* binutils/windres.c (main): Likewise.

	* include/libiberty.h (expandargv): New function.
	* libiberty/argv.c (safe-ctype.h): Include it.
	(ISBLANK): Remove.
	(stdio.h): Include.
	(expandargv): New function.
	* libiberty/Makefile.in: Regenerated.
@
text
@a364 2
  expandargv (&argc, &argv);

@


1.38
log
@bfd/
2005-03-02  Jan Beulich  <jbeulich@@novell.com>

	* Makefile.am: Add dependency of cache.o on libiberty.h.
	* cache.c: Include libiberty.h.
	(bfd_open_file): Use unlink_if_ordinary instead of unlink.

binutils/
2005-03-02  Jan Beulich  <jbeulich@@novell.com>

	* ar.c (remove_output): Use unlink_if_ordinary instead of unlink.
	* objcopy.c (copy_file): Likewise.
	(strip_main): Likewise.

gas/
2005-03-02  Jan Beulich  <jbeulich@@novell.com>

	* as.c (main): Use unlink_if_ordinary instead of unlink.
	* messages.c (as_fatal): Likewise.

ld/
2005-03-02  Jan Beulich  <jbeulich@@novell.com>

	* ldmain.c (remove_output): Use unlink_if_ordinary instead of unlink.
	* pe-dll.c (pe_dll_generate_implib): Likewise.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004
@


1.37
log
@	* dlltool.c (dump_iat): Remove unused function.
	(gen_exp_file): Remove #if 0'd code.
	(make_one_lib_file): Likewise.
	* srconv.c: Remove #if 0'd code throughout.
	* size.c (lprint_number): Remove.
	(print_berkeley_format): Remove #if 0'd code.
	* ar.c (do_quick_append): Remove declaration and definiton.
	(main): Remove #if 0'd code.
	* filemode.c (filemodestring): Remove #if 0'd function.
	* sysdump.c (unit_info_list): Remove function.
	(object_body_list): Likewise.
	(program_structure): Likewise.
	(debug_list): Likewise.
	(module): Remove #if 0'd code.
@
text
@d326 1
a326 1
      unlink (output_filename);
@


1.36
log
@	* ar.c (extract_file): Set atime to mtime for ar xo.
@
text
@a67 5
#if 0
static void do_quick_append
  (const char *archive_filename, char **files_to_append);
#endif

d587 4
a625 33
#if 0
      /* We don't use do_quick_append any more.  Too many systems
         expect ar to always rebuild the symbol table even when q is
         used.  */

      /* We can't do a quick append if we need to construct an
	 extended name table, because do_quick_append won't be able to
	 rebuild the name table.  Unfortunately, at this point we
	 don't actually know the maximum name length permitted by this
	 object file format.  So, we guess.  FIXME.  */
      if (operation == quick_append && ! ar_truncate)
	{
	  char **chk;

	  for (chk = files; chk != NULL && *chk != '\0'; chk++)
	    {
	      if (strlen (normalize (*chk, (bfd *) NULL)) > 14)
		{
		  operation = replace;
		  break;
		}
	    }
	}

      if (operation == quick_append)
	{
	  /* Note that quick appending to a non-existent archive creates it,
	     even if there are no files to append.  */
	  do_quick_append (inarch_filename, files);
	  xexit (0);
	}
#endif

a913 119
#if 0

/* We don't use this anymore.  Too many systems expect ar to rebuild
   the symbol table even when q is used.  */

/* Just do it quickly; don't worry about dups, armap, or anything like that */

static void
do_quick_append (const char *archive_filename, char **files_to_append)
{
  FILE *ofile, *ifile;
  char *buf = xmalloc (BUFSIZE);
  long tocopy, thistime;
  bfd *temp;
  struct stat sbuf;
  bfd_boolean newfile = FALSE;
  bfd_set_error (bfd_error_no_error);

  if (stat (archive_filename, &sbuf) != 0)
    {

#if !defined(__GO32__) || defined(__DJGPP__)

      /* FIXME: I don't understand why this fragment was ifndef'ed
	 away for __GO32__; perhaps it was in the days of DJGPP v1.x.
	 stat() works just fine in v2.x, so I think this should be
	 removed.  For now, I enable it for DJGPP v2.

	 (And yes, I know this is all unused, but somebody, someday,
	 might wish to resurrect this again... -- EZ.  */

/* KLUDGE ALERT! Temporary fix until I figger why
   stat() is wrong ... think it's buried in GO32's IDT - Jax  */

      if (errno != ENOENT)
	bfd_fatal (archive_filename);
#endif

      newfile = TRUE;
    }

  ofile = fopen (archive_filename, FOPEN_AUB);
  if (ofile == NULL)
    {
      perror (program_name);
      xexit (1);
    }

  temp = bfd_openr (archive_filename, NULL);
  if (temp == NULL)
    {
      bfd_fatal (archive_filename);
    }
  if (!newfile)
    {
      if (!bfd_check_format (temp, bfd_archive))
	/* xgettext:c-format */
	fatal (_("%s is not an archive"), archive_filename);
    }
  else
    {
      fwrite (ARMAG, 1, SARMAG, ofile);
      if (!silent_create)
	/* xgettext:c-format */
	non_fatal (_("creating %s"), archive_filename);
    }

  if (ar_truncate)
    temp->flags |= BFD_TRADITIONAL_FORMAT;

  /* assume it's an archive, go straight to the end, sans $200 */
  fseek (ofile, 0, 2);

  for (; files_to_append && *files_to_append; ++files_to_append)
    {
      struct ar_hdr *hdr = bfd_special_undocumented_glue (temp, *files_to_append);
      if (hdr == NULL)
	{
	  bfd_fatal (*files_to_append);
	}

      BFD_SEND (temp, _bfd_truncate_arname, (temp, *files_to_append, (char *) hdr));

      ifile = fopen (*files_to_append, FOPEN_RB);
      if (ifile == NULL)
	{
	  bfd_nonfatal (*files_to_append);
	}

      if (stat (*files_to_append, &sbuf) != 0)
	{
	  bfd_nonfatal (*files_to_append);
	}

      tocopy = sbuf.st_size;

      /* XXX should do error-checking! */
      fwrite (hdr, 1, sizeof (struct ar_hdr), ofile);

      while (tocopy > 0)
	{
	  thistime = tocopy;
	  if (thistime > BUFSIZE)
	    thistime = BUFSIZE;
	  fread (buf, 1, thistime, ifile);
	  fwrite (buf, 1, thistime, ofile);
	  tocopy -= thistime;
	}
      fclose (ifile);
      if ((sbuf.st_size % 2) == 1)
	putc ('\012', ofile);
    }
  fclose (ofile);
  bfd_close (temp);
  free (buf);
}

#endif /* 0 */

@


1.35
log
@PR 363
* ar.c (replace_members): Do not use get_file_size as ar_emul_append correctly
handles missing files.
@
text
@d938 6
a943 1
    set_times (bfd_get_filename (abfd), &buf);
@


1.34
log
@	* ar.c (main): Support POSIX-compatible argument parsing.

testsuite:
	* binutils-all/ar.exp (argument_parsing): New test.
@
text
@d1271 1
a1271 1
  bfd **after_bfd;		/* New entries go after this one */
d1328 1
a1328 2
      if (get_file_size (* files_to_move) > 0
	  && ar_emul_append (after_bfd, *files_to_move, verbose))
@


1.33
log
@Use bfd_cache_close, instead of accessing bfd->iostream directly.
@
text
@d3 1
a3 1
   2001, 2002, 2003
d356 1
d463 2
a464 1
  arg_ptr = argv[1];
d467 6
a472 1
    ++arg_ptr;			/* compatibility */
d474 1
a474 1
  while ((c = *arg_ptr++) != '\0')
d476 1
a476 1
      switch (c)
a477 9
	case 'd':
	case 'm':
	case 'p':
	case 'q':
	case 'r':
	case 't':
	case 'x':
	  if (operation != none)
	    fatal (_("two different operation options specified"));
d481 49
a529 2
	      operation = delete;
	      operation_alters_arch = TRUE;
d531 14
a544 3
	    case 'm':
	      operation = move;
	      operation_alters_arch = TRUE;
d546 2
a547 2
	    case 'p':
	      operation = print_files;
d549 2
a550 3
	    case 'q':
	      operation = quick_append;
	      operation_alters_arch = TRUE;
d552 2
a553 3
	    case 'r':
	      operation = replace;
	      operation_alters_arch = TRUE;
d555 2
a556 2
	    case 't':
	      operation = print_table;
d558 2
a559 2
	    case 'x':
	      operation = extract;
d561 4
a565 48
	case 'l':
	  break;
	case 'c':
	  silent_create = 1;
	  break;
	case 'o':
	  preserve_dates = 1;
	  break;
	case 'V':
	  show_version = TRUE;
	  break;
	case 's':
	  write_armap = 1;
	  break;
	case 'S':
	  write_armap = -1;
	  break;
	case 'u':
	  newer_only = 1;
	  break;
	case 'v':
	  verbose = 1;
	  break;
	case 'a':
	  postype = pos_after;
	  break;
	case 'b':
	  postype = pos_before;
	  break;
	case 'i':
	  postype = pos_before;
	  break;
	case 'M':
	  mri_mode = 1;
	  break;
	case 'N':
	  counted_name_mode = TRUE;
	  break;
	case 'f':
	  ar_truncate = TRUE;
	  break;
	case 'P':
	  full_pathname = TRUE;
	  break;
	default:
	  /* xgettext:c-format */
	  non_fatal (_("illegal option -- %c"), c);
	  usage (0);
d567 7
d575 1
d580 2
a581 1
  if (argc < 3)
d600 1
a600 1
	  ranlib_only (argv[2]);
a608 2

      arg_index = 2;
@


1.33.2.1
log
@Merge to 2.15 branch.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004
a355 1
  int do_posix = 0;
d462 1
a462 2
  arg_index = 1;
  arg_ptr = argv[arg_index];
d465 1
a465 6
    {
      /* When the first option starts with '-' we support POSIX-compatible
	 option parsing.  */
      do_posix = 1;
      ++arg_ptr;			/* compatibility */
    }
d467 1
a467 1
  do
d469 1
a469 1
      while ((c = *arg_ptr++) != '\0')
d471 9
d483 3
d487 3
d491 2
d494 3
d498 3
d502 2
d505 1
a505 43
	      if (operation != none)
		fatal (_("two different operation options specified"));
	      switch (c)
		{
		case 'd':
		  operation = delete;
		  operation_alters_arch = TRUE;
		  break;
		case 'm':
		  operation = move;
		  operation_alters_arch = TRUE;
		  break;
		case 'p':
		  operation = print_files;
		  break;
		case 'q':
		  operation = quick_append;
		  operation_alters_arch = TRUE;
		  break;
		case 'r':
		  operation = replace;
		  operation_alters_arch = TRUE;
		  break;
		case 't':
		  operation = print_table;
		  break;
		case 'x':
		  operation = extract;
		  break;
		}
	    case 'l':
	      break;
	    case 'c':
	      silent_create = 1;
	      break;
	    case 'o':
	      preserve_dates = 1;
	      break;
	    case 'V':
	      show_version = TRUE;
	      break;
	    case 's':
	      write_armap = 1;
a506 34
	    case 'S':
	      write_armap = -1;
	      break;
	    case 'u':
	      newer_only = 1;
	      break;
	    case 'v':
	      verbose = 1;
	      break;
	    case 'a':
	      postype = pos_after;
	      break;
	    case 'b':
	      postype = pos_before;
	      break;
	    case 'i':
	      postype = pos_before;
	      break;
	    case 'M':
	      mri_mode = 1;
	      break;
	    case 'N':
	      counted_name_mode = TRUE;
	      break;
	    case 'f':
	      ar_truncate = TRUE;
	      break;
	    case 'P':
	      full_pathname = TRUE;
	      break;
	    default:
	      /* xgettext:c-format */
	      non_fatal (_("illegal option -- %c"), c);
	      usage (0);
d508 48
a556 7

      /* With POSIX-compatible option parsing continue with the next
	 argument if it starts with '-'.  */
      if (do_posix && arg_index + 1 < argc && argv[arg_index + 1][0] == '-')
	arg_ptr = argv[++arg_index] + 1;
      else
	do_posix = 0;
a557 1
  while (do_posix);
d562 1
a562 2
  ++arg_index;
  if (arg_index >= argc)
d581 1
a581 1
	  ranlib_only (argv[arg_index]);
d590 2
@


1.32
log
@Emit a warning when an archive is created (only shown with -v) in order to
confrom to POSIX specification.
@
text
@d327 2
a328 2
      if (output_bfd != NULL && output_bfd->iostream != NULL)
	fclose ((FILE *) (output_bfd->iostream));
@


1.31
log
@Remove "member" from verbose output of "-dv" in order to conform to POSIX
specification.
@
text
@d753 2
@


1.30
log
@Use consistent error messages for missing files.
Detect directories where an ordinary file is expected.
@
text
@d805 1
a805 1
    printf (_("\n<member %s>\n\n"), bfd_get_filename (abfd));
@


1.29
log
@	* ChangeLog: Fix typos.
	* ChangeLog-9197: Likewise.
	* ChangeLog-9899: Likewise.
	* NEWS: Likewise.
	* ar.c: Fix comment typos.
	* arsup.c: Likewise.
	* coffgrok.c: Likewise.
	* debug.c: Likewise.
	* debug.h: Likewise.
	* dlltool.c: Likewise.
	* ieee.c: Likewise.
	* nm.c: Likewise.
	* objdump.c: Likewise.
	* prdbg.c: Likewise.
	* readelf.c: Likewise.
	* resrc.c: Likewise.
	* sysinfo.y: Likewise.
	* windres.c: Likewise.
@
text
@d1308 3
a1310 1
      if (ar_emul_append (after_bfd, *files_to_move, verbose))
d1329 2
d1351 2
@


1.28
log
@	* addr2line.c: Convert to ISO C90 prototypes, change PTR, remove
	unneeded (void *) casts.
	* ar.c: Likewise.
	* arlex.l: Likewise.
	* arparse.y: Likewise.
	* arsup.c: Likewise.
	* binemul.c: Likewise.
	* binemul.h: Likewise.
	* bucomm.c: Likewise.
	* bucomm.h: Likewise.
	* budbg.h: Likewise.
	* budemang.c: Likewise.
	* budemang.h: Likewise.
	* coffdump.c: Likewise.
	* coffgrok.c: Likewise.
	* cxxfilt.c: Likewise.
	* debug.c: Likewise.
	* debug.h: Likewise.
	* deflex.l: Likewise.
	* dlltool.c: Likewise.
	* dlltool.h: Likewise.
	* dllwrap.c: Likewise.
	* emul_aix.c: Likewise.
	* filemode.c: Likewise.
	* ieee.c: Likewise.
	* nlmconv.c: Likewise.
	* nlmconv.h: Likewise.
	* nlmheader.y: Likewise.
	* nm.c: Likewise.
	* prdbg.c: Likewise.
	* rclex.l: Likewise.
	* rcparse.y: Likewise.
	* rdcoff.c: Likewise.
	* rddbg.c: Likewise.
	* rename.c: Likewise.
	* resbin.c: Likewise.
	* rescoff.c: Likewise.
	* resrc.c: Likewise.
	* size.c: Likewise.
	* srconv.c: Likewise.
	* stabs.c: Likewise.
	* strings.c: Likewise.
	* sysdump.c: Likewise.
	* sysinfo.y: Likewise.
	* syslex.l: Likewise.
	* unwind-ia64.c: Likewise.
	* unwind-ia64.h: Likewise.
	* version.c: Likewise.
	* windres.c: Likewise.
	* windres.h: Likewise.
	* winduni.c: Likewise.
	* wrstabs.c: Likewise.
@
text
@d27 1
a27 1
   more consistant.  */
d106 1
a106 1
   +1 means we've been explictly asked to write it;
d994 1
a994 1
  /* assume it's an achive, go straight to the end, sans $200 */
@


1.27
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d3 1
a3 1
   2001, 2002
d57 1
a57 1
  bfd_special_undocumented_glue PARAMS ((bfd * abfd, const char *filename));
d61 6
a66 17
static void
mri_emul PARAMS ((void));

static const char *
normalize PARAMS ((const char *, bfd *));

static void
remove_output PARAMS ((void));

static void
map_over_members PARAMS ((bfd *, void (*)(bfd *), char **, int));

static void
print_contents PARAMS ((bfd * member));

static void
delete_members PARAMS ((bfd *, char **files_to_delete));
d69 2
a70 3
static void
do_quick_append PARAMS ((const char *archive_filename,
			 char **files_to_append));
d73 8
a80 20
static void
move_members PARAMS ((bfd *, char **files_to_move));

static void
replace_members PARAMS ((bfd *, char **files_to_replace, bfd_boolean quick));

static void
print_descr PARAMS ((bfd * abfd));

static void
write_archive PARAMS ((bfd *));

static void
ranlib_only PARAMS ((const char *archname));

static void
ranlib_touch PARAMS ((const char *archname));

static void
usage PARAMS ((int));
d127 1
a127 1
get_pos_bfd PARAMS ((bfd **, enum pos, const char *));
d145 1
a145 1
mri_emul ()
d156 1
a156 5
map_over_members (arch, function, files, count)
     bfd *arch;
     void (*function) PARAMS ((bfd *));
     char **files;
     int count;
d217 1
a217 2
usage (help)
     int help;
d277 1
a277 3
normalize (file, abfd)
     const char *file;
     bfd *abfd;
d323 1
a323 1
remove_output ()
d338 1
a338 1
int main PARAMS ((int, char **));
d341 1
a341 3
main (argc, argv)
     int argc;
     char **argv;
d696 1
a696 3
open_inarch (archive_filename, file)
     const char *archive_filename;
     const char *file;
d793 1
a793 2
print_contents (abfd)
     bfd *abfd;
d840 1
a840 2
extract_file (abfd)
     bfd *abfd;
d932 1
a932 3
do_quick_append (archive_filename, files_to_append)
     const char *archive_filename;
     char **files_to_append;
d1044 1
a1044 2
write_archive (iarch)
     bfd *iarch;
d1097 1
a1097 4
get_pos_bfd (contents, default_pos, default_posname)
     bfd **contents;
     enum pos default_pos;
     const char *default_posname;
d1133 1
a1133 3
delete_members (arch, files_to_delete)
     bfd *arch;
     char **files_to_delete;
d1204 1
a1204 3
move_members (arch, files_to_move)
     bfd *arch;
     char **files_to_move;
d1249 1
a1249 4
replace_members (arch, files_to_move, quick)
     bfd *arch;
     char **files_to_move;
     bfd_boolean quick;
d1323 1
a1323 2
ranlib_only (archname)
     const char *archname;
d1337 1
a1337 2
ranlib_touch (archname)
     const char *archname;
d1382 1
a1382 2
print_descr (abfd)
     bfd *abfd;
@


1.26
log
@	* addr2line.c: Fix formatting.
	* ar.c: Likewise.
	* arsup.c: Likewise.
	* arsup.h: Likewise.
	* binemul.c: Likewise.
	* binemul.h: Likewise.
	* bucomm.c: Likewise.
	* coffdump.c: Likewise.
	* coffgrok.c: Likewise.
	* coffgrok.h: Likewise.
@
text
@d89 1
a89 1
replace_members PARAMS ((bfd *, char **files_to_replace, boolean quick));
d153 1
a153 1
/* For extract/delete only.  If COUNTED_NAME_MODE is true, we only
d155 1
a155 1
static boolean counted_name_mode = 0;
d159 1
a159 1
static boolean ar_truncate = false;
d164 1
a164 1
static boolean full_pathname = false;
d207 1
a207 1
      boolean found = false;
d232 1
a232 1
	      found = true;
d242 1
a242 1
boolean operation_alters_arch = false;
d458 1
a458 1
      boolean touch = false;
d473 1
a473 1
	  touch = true;
d517 1
a517 1
	      operation_alters_arch = true;
d521 1
a521 1
	      operation_alters_arch = true;
d528 1
a528 1
	      operation_alters_arch = true;
d532 1
a532 1
	      operation_alters_arch = true;
d550 1
a550 1
	  show_version = true;
d577 1
a577 1
	  counted_name_mode = true;
d580 1
a580 1
	  ar_truncate = true;
d583 1
a583 1
	  full_pathname = true;
d978 1
a978 1
  boolean newfile = false;
d1001 1
a1001 1
      newfile = true;
d1016 1
a1016 1
  if (newfile == false)
d1018 1
a1018 1
      if (bfd_check_format (temp, bfd_archive) != true)
d1116 1
a1116 1
  if (bfd_set_archive_head (obfd, contents_head) != true)
d1181 2
a1182 2
  boolean found;
  boolean something_changed = false;
d1195 1
a1195 1
	  arch->has_armap = false;
d1200 1
a1200 1
      found = false;
d1217 2
a1218 2
		  found = true;
		  something_changed = true;
d1230 1
a1230 1
      if (verbose && found == false)
d1239 1
a1239 1
  if (something_changed == true)
d1299 1
a1299 1
     boolean quick;
d1301 1
a1301 1
  boolean changed = false;
d1347 1
a1347 1
		      changed = true;
d1359 1
a1359 1
	changed = true;
@


1.25
log
@	* ar.c (replace_members): Remove unused var.  Formatting fix.
	* binemul.c (ar_emul_default_parse_arg): Add ATTRIBUTE_UNUSED.
@
text
@d225 1
a225 1
		  && match_count != counted_name_counter) 
d251 1
a251 1
  
d286 1
a286 1
    /* xgettext:c-format */
d408 8
a415 8
	{
	  /* We could have foo/bar\\baz, or foo\\bar, or d:bar.  */
	  char *bslash = strrchr (program_name, '\\');
	  if (temp == NULL || (bslash != NULL && bslash > temp))
	    temp = bslash;
	  if (temp == NULL && program_name[0] != '\0' && program_name[1] == ':')
	    temp = program_name + 1;
	}
d455 1
a455 1
  	  
d629 1
a629 1
      if (counted_name_mode) 
d631 1
a631 1
          if (operation != extract && operation != delete) 
d634 1
a634 1
          if (counted_name_counter <= 0)
d670 1
a670 1
	     even if there are no files to append. */
d885 1
a885 1
  
d894 1
a894 1
  
d1206 1
a1206 1
		      (*current_ptr_ptr)->filename) == 0)
d1210 1
a1210 1
		  && match_count != counted_name_counter) 
d1342 1
a1342 1
		  if (ar_emul_replace (after_bfd, *files_to_move, 
@


1.24
log
@Add AIX 64 shared library support and emulation layer for binutils
@
text
@a1304 1
  bfd *temp;
d1333 2
a1334 1
			fatal (_("internal stat error on %s"), current->filename);
@


1.23
log
@Tidy up formatting of --help output.
@
text
@d6 1
a6 1
This file is part of GNU Binutils.
d8 13
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d27 2
a28 2
   more consistant.
*/
d37 1
d255 1
a255 1
      fprintf (s, _("Usage: %s [-X32_64] [-]{dmpqrstx}[abcfilNoPsSuvV] [member-name] [count] archive-file file...\n"),
d281 2
a282 1
      fprintf (s, _("  [-X32_64]    - (ignored)\n"));
d388 1
d450 6
a455 11
  /* Ignored for (partial) AIX compatibility.  On AIX,
     the -X option can be used to ignore certain kinds
     of object files in the archive (the 64-bit objects
     or the 32-bit objects).  GNU ar always looks at all
     kinds of objects in an archive.  */
  while (argc > 1 && strcmp (argv[1], "-X32_64") == 0)
    {
      argv++;
      argc--;
    }

d1342 2
a1343 4
		  temp = *after_bfd;

		  *after_bfd = bfd_openr (*files_to_move, NULL);
		  if (*after_bfd == (bfd *) NULL)
d1345 3
a1347 1
		      bfd_fatal (*files_to_move);
a1348 11
		  (*after_bfd)->next = temp;

		  /* snip out this entry from the chain */
		  *current_ptr = (*current_ptr)->next;

		  if (verbose)
		    {
		      printf ("r - %s\n", *files_to_move);
		    }

		  changed = true;
a1356 1

d1358 2
a1359 14
      temp = *after_bfd;
      *after_bfd = bfd_openr (*files_to_move, NULL);
      if (*after_bfd == (bfd *) NULL)
	{
	  bfd_fatal (*files_to_move);
	}
      if (verbose)
	{
	  printf ("a - %s\n", *files_to_move);
	}

      (*after_bfd)->next = temp;

      changed = true;
@


1.22
log
@	* addr2line.c (main): Protoype.
	* ar.c (main): Protoype.
	* nm.c (main): Protoype.
	* objcopy.c (main): Protoype.
	* objdump.c (main): Protoype.
	* size.c (main): Protoype.
	* strings.c (main): Protoype.
	* gasp.c (main): Protoype.
@
text
@d3 1
a3 1
   2001
d283 1
d285 6
a290 1
    fprintf (s, _("Usage: %s [-vV] archive\n"), program_name);
d462 4
a465 1
      if (argc < 2 || strcmp (argv[1], "--help") == 0)
@


1.21
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d361 2
@


1.20
log
@	* ar.c (print_contents): Cast args of bfd_seek to the right types.
	Replace bfd_read call with call to bfd_bread.
	(extract_file): Likewise.

	* objdump.c (dump_section_header): Cast section->filepos to
	unsigned long to suit printf format string.
	* readelf.c (process_section_headers): Similarly for sh_offset.
	(process_unwind): Likewise.
@
text
@d382 3
@


1.19
log
@Fix typos in ChangeLogs and update copyright notices
@
text
@d2 2
a3 1
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
d831 1
a831 1
  bfd_seek (abfd, 0, SEEK_SET);
d842 1
a842 2
      nread = bfd_read (cbuf, 1, tocopy, abfd);	/* oops -- broke
							   abstraction!  */
d886 1
a886 1
  bfd_seek (abfd, 0, SEEK_SET);
d910 1
a910 1
	nread = bfd_read (cbuf, 1, tocopy, abfd);
@


1.18
log
@* ar.c (main): Don't crash if called with no arguments
or only '-X32_64' as an argument.
@
text
@d2 1
a2 1
   Copyright 1991, 92, 93, 94, 95, 96, 97, 98, 99, 2000
@


1.18.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000
@


1.17
log
@* nm.c (main): Ignore '-X32_64' as an option.
* ar.c (main): Likewise.
* binutils.texi (nm): Document new option.
(ar): Likewise.
@
text
@d440 1
a440 1
  while (strcmp (argv[1], "-X32_64") == 0)
@


1.16
log
@Revert incorrect 2000-06-25 patch.
@
text
@d253 1
a253 1
      fprintf (s, _("Usage: %s [-]{dmpqrstx}[abcfilNoPsSuvV] [member-name] [count] archive-file file...\n"),
d279 1
d434 11
@


1.15
log
@Advance past both parts of dos based <letter>: filepath prefix.
@
text
@d313 1
a313 1
      filename = file + 2;
d398 1
a398 1
	    temp = program_name + 2;
@


1.14
log
@Correct pointer comparisons relying on NULL less than any other pointer.
Alexander Aganichev's fix for ieee.c
@
text
@d313 1
a313 1
      filename = file + 1;
d398 1
a398 1
	    temp = program_name + 1;
@


1.13
log
@Improve verbose message
@
text
@d310 1
a310 1
    if (bslash > filename)
d313 1
a313 1
	filename = file + 1;
d395 1
a395 1
	  if (bslash > temp)
@


1.12
log
@Eli Zaretskii's DOSish file name patches.
@
text
@d815 2
a816 1
    printf ("\n<%s>\n\n", bfd_get_filename (abfd));
@


1.11
log
@A mostly cosmetic tidy up of warnings and error message reporting.
@
text
@d35 1
d219 1
a219 1
	      (!strcmp (normalize (*files, arch), head->filename)))
d306 10
d391 10
d406 1
a406 1
	  && strcmp (temp + strlen (temp) - 6, "ranlib") == 0)
d721 6
a726 1
#ifndef __GO32__
d729 1
a729 3
 * stat() is wrong ... think it's buried in GO32's IDT
 * - Jax
 */
d959 9
a967 1
#ifndef __GO32__
d970 1
a970 3
 * stat() is wrong ... think it's buried in GO32's IDT
 * - Jax
 */
d1140 1
a1140 1
	if (strcmp ((*after_bfd)->filename, realposname) == 0)
d1180 1
a1180 1
	  if (strcmp (normalize (*files_to_delete, arch),
d1237 2
a1238 2
	  if (strcmp (normalize (*files_to_move, arch),
		      current_ptr->filename) == 0)
d1293 2
a1294 2
	      if (strcmp (normalize (*files_to_move, arch),
			  normalize (current->filename, arch)) == 0
@


1.10
log
@Move translated part of bug report string back into .c files so
xgettext can find it.  Regnerate .pot files.
@
text
@d2 1
a2 1
   Copyright 1991, 92, 93, 94, 95, 96, 97, 98, 1999
d541 1
a541 1
	  fprintf (stderr, _("%s: illegal option -- %c\n"), program_name, c);
d586 1
a586 1
	     fatal (_("`N' is only meaningful with the `x' and 'd' options."));
d672 1
a672 3
	  fprintf (stderr, _("%s: internal error -- this option not implemented\n"),
		   program_name);
	  xexit (1);
d972 1
a972 2
	fprintf (stderr, _("%s: creating %s\n"),
		 program_name, archive_filename);
d1230 2
a1231 3
      fprintf (stderr, _("%s: no entry %s in archive %s!\n"),
	       program_name, *files_to_move, arch->filename);
      xexit (1);
@


1.9
log
@Move bug report string to one place.
@
text
@d286 1
a286 1
    fprintf (s, REPORT_BUGS_TO);
@


1.8
log
@	* ar.c (normalize): Fix full_pathname code.
@
text
@d286 1
a286 1
    fprintf (s, _("Report bugs to bug-gnu-utils@@gnu.org\n"));
@


1.8.2.1
log
@This is a grab-bag of my stuff from the head branch.
Should have done it separately, I know.
- move bug report address to include file
- objcopy --redefine-sym
- update makefile dependencies (but use automake-000227)
- H.J. Lu's fix to readelf.c
@
text
@d286 1
a286 1
    fprintf (s, _("Report bugs to %s\n"), REPORT_BUGS_TO);
@


1.8.2.2
log
@A mostly cosmetic tidy up of warnings and error message reporting.
@
text
@d2 1
a2 1
   Copyright 1991, 92, 93, 94, 95, 96, 97, 98, 99, 2000
d541 1
a541 1
	  non_fatal (_("illegal option -- %c"), c);
d586 1
a586 1
	     fatal (_("`N' is only meaningful with the `x' and `d' options."));
d672 3
a674 1
	  fatal (_("internal error -- this option not implemented"));
d974 2
a975 1
	non_fatal (_("creating %s"), archive_filename);
d1233 3
a1235 2
      fatal (_("no entry %s in archive %s!"), *files_to_move, arch->filename);

@


1.8.2.3
log
@Eli Zaretskii's DOSish file name patches.
@
text
@a34 1
#include "filenames.h"
d218 1
a218 1
	      (!FILENAME_CMP (normalize (*files, arch), head->filename)))
a304 10
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
  {
    /* We could have foo/bar\\baz, or foo\\bar, or d:bar.  */
    char *bslash = strrchr (file, '\\');
    if (bslash > filename)
      filename = bslash;
    if (filename == NULL && file[0] != '\0' && file[1] == ':')
	filename = file + 1;
  }
#endif
a379 10
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
	{
	  /* We could have foo/bar\\baz, or foo\\bar, or d:bar.  */
	  char *bslash = strrchr (program_name, '\\');
	  if (bslash > temp)
	    temp = bslash;
	  if (temp == NULL && program_name[0] != '\0' && program_name[1] == ':')
	    temp = program_name + 1;
	}
#endif
d385 1
a385 1
	  && FILENAME_CMP (temp + strlen (temp) - 6, "ranlib") == 0)
d700 1
a700 6
#if !defined(__GO32__) || defined(__DJGPP__)

      /* FIXME: I don't understand why this fragment was ifndef'ed
	 away for __GO32__; perhaps it was in the days of DJGPP v1.x.
	 stat() works just fine in v2.x, so I think this should be
	 removed.  For now, I enable it for DJGPP v2. -- EZ.  */
d703 3
a705 1
   stat() is wrong ... think it's buried in GO32's IDT - Jax */
d935 1
a935 9
#if !defined(__GO32__) || defined(__DJGPP__)

      /* FIXME: I don't understand why this fragment was ifndef'ed
	 away for __GO32__; perhaps it was in the days of DJGPP v1.x.
	 stat() works just fine in v2.x, so I think this should be
	 removed.  For now, I enable it for DJGPP v2.

	 (And yes, I know this is all unused, but somebody, someday,
	 might wish to resurrect this again... -- EZ.  */
d938 3
a940 1
   stat() is wrong ... think it's buried in GO32's IDT - Jax  */
d1110 1
a1110 1
	if (FILENAME_CMP ((*after_bfd)->filename, realposname) == 0)
d1150 1
a1150 1
	  if (FILENAME_CMP (normalize (*files_to_delete, arch),
d1207 2
a1208 2
	  if (FILENAME_CMP (normalize (*files_to_move, arch),
			    current_ptr->filename) == 0)
d1263 2
a1264 2
	      if (FILENAME_CMP (normalize (*files_to_move, arch),
				normalize (current->filename, arch)) == 0
@


1.7
log
@	* ar.c (main): Clear output_file if we don't change the archive.
	(delete_members, replace_members): Likewise.
@
text
@d302 1
a302 1
    return filename;
@


1.6
log
@1999-09-12  Donn Terry  <donn@@interix.com>

	* ar.c (counted_name_mode): New static variable.
	(counted_name_counter): New static variable.
	(map_over_members): Handle counted mode.
	(usage): Mention N modifier.
	(main): Handle N modifier.
	(delete_members): Handle counted mode.
	* binutils.texi, ar.1: Document N modifier.
@
text
@d650 2
d657 2
d665 2
d1188 3
a1190 3
    {
      write_archive (arch);
    }
d1341 2
@


1.5
log
@1999-09-12  Donn Terry  <donn@@interix.com>

	* ar.c (print_contents): Change printing of member name for
	POSIX.2 conformance.
@
text
@d150 5
d184 1
d195 1
d206 1
d220 9
d252 2
a253 1
      fprintf (s, _("Usage: %s [-]{dmpqrstx}[abcilosSuvV] [member-name] archive-file file...\n"), program_name);
d267 1
d362 1
d530 3
d583 9
d595 1
d636 1
a636 1
	  map_over_members (arch, print_descr, files, argc - 3);
d640 1
a640 1
	  map_over_members (arch, print_contents, files, argc - 3);
d644 1
a644 1
	  map_over_members (arch, extract_file, files, argc - 3);
d1125 2
d1143 1
d1147 2
a1148 1
	  if (strcmp (*files_to_delete, (*current_ptr_ptr)->filename) == 0)
d1150 17
a1166 11
	      found = true;
	      something_changed = true;
	      if (verbose)
		printf ("d - %s\n",
			*files_to_delete);
	      *current_ptr_ptr = ((*current_ptr_ptr)->next);
	      goto next_file;
	    }
	  else
	    {
	      current_ptr_ptr = &((*current_ptr_ptr)->next);
d1168 2
@


1.4
log
@1999-09-12  Donn Terry  <donn@@interix.com>

	* ar.c (output_filename): Make const.
	(open_inarch): If creating a new empty archive, set
	output_filename.
@
text
@d754 1
a754 2
    /* xgettext:c-format */
    printf (_("\n<member %s>\n\n"), bfd_get_filename (abfd));
@


1.3
log
@	* ar.c (full_pathname): New static variable.
	(map_over_members): Call normalize on command line parameter.
	(usage): Mention P modifier.
	(normalize): If full_pathname is true, don't do anything.
	(main): Accept P modifier.
	* binutils.texi, ar.1: Document P modifier.
@
text
@d309 1
a309 1
static char *output_filename = NULL;
d702 3
@


1.2
log
@	* ar.c (O_BINARY): Define as 0 if not defined.
	(ranlib_touch): Open file with O_BINARY.
@
text
@d153 5
d210 1
a210 1
	      (!strcmp (*files, head->filename)))
d250 1
d282 3
d512 3
@


1.1
log
@Initial revision
@
text
@d43 6
d1305 1
a1305 1
  f = open (archname, O_RDWR, 0);
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

