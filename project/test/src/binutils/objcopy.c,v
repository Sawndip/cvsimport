head	1.165;
access;
symbols
	binutils-2_24-branch:1.165.0.2
	binutils-2_24-branchpoint:1.165
	binutils-2_21_1:1.147.2.2
	binutils-2_23_2:1.157.2.1
	binutils-2_23_1:1.157
	binutils-2_23:1.157
	binutils-2_23-branch:1.157.0.2
	binutils-2_23-branchpoint:1.157
	binutils-2_22_branch:1.153.0.4
	binutils-2_22:1.153
	binutils-2_22-branch:1.153.0.2
	binutils-2_22-branchpoint:1.153
	binutils-2_21:1.147
	binutils-2_21-branch:1.147.0.2
	binutils-2_21-branchpoint:1.147
	binutils-2_20_1:1.134.2.2
	binutils-2_20:1.134.2.1
	binutils-arc-20081103-branch:1.124.0.4
	binutils-arc-20081103-branchpoint:1.124
	binutils-2_20-branch:1.134.0.2
	binutils-2_20-branchpoint:1.134
	dje-cgen-play1-branch:1.133.0.2
	dje-cgen-play1-branchpoint:1.133
	arc-20081103-branch:1.124.0.2
	arc-20081103-branchpoint:1.124
	binutils-2_19_1:1.123
	binutils-2_19:1.123
	binutils-2_19-branch:1.123.0.2
	binutils-2_19-branchpoint:1.123
	binutils-2_18:1.118
	binutils-2_18-branch:1.118.0.2
	binutils-2_18-branchpoint:1.118
	binutils-csl-coldfire-4_1-32:1.95.2.2
	binutils-csl-sourcerygxx-4_1-32:1.95.2.2
	binutils-csl-innovasic-fido-3_4_4-33:1.95.2.2
	binutils-csl-sourcerygxx-3_4_4-32:1.76.6.1
	binutils-csl-coldfire-4_1-30:1.95.2.2
	binutils-csl-sourcerygxx-4_1-30:1.95.2.2
	binutils-csl-coldfire-4_1-28:1.95.2.2
	binutils-csl-sourcerygxx-4_1-29:1.95.2.2
	binutils-csl-sourcerygxx-4_1-28:1.95.2.2
	binutils-csl-arm-2006q3-27:1.95.2.2
	binutils-csl-sourcerygxx-4_1-27:1.95.2.2
	binutils-csl-arm-2006q3-26:1.95.2.2
	binutils-csl-sourcerygxx-4_1-26:1.95.2.2
	binutils-csl-sourcerygxx-4_1-25:1.95.2.2
	binutils-csl-sourcerygxx-4_1-24:1.95.2.1
	binutils-csl-sourcerygxx-4_1-23:1.95.2.1
	binutils-csl-sourcerygxx-4_1-21:1.95.2.1
	binutils-csl-arm-2006q3-21:1.95.2.1
	binutils-csl-sourcerygxx-4_1-22:1.95.2.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.95.2.1
	binutils-csl-sourcerygxx-4_1-20:1.95.2.1
	binutils-csl-arm-2006q3-19:1.95.2.1
	binutils-csl-sourcerygxx-4_1-19:1.95.2.1
	binutils-csl-sourcerygxx-4_1-18:1.95.2.1
	binutils-csl-renesas-4_1-9:1.95.2.1
	binutils-csl-sourcerygxx-3_4_4-25:1.76.6.1
	binutils-csl-renesas-4_1-8:1.95.2.1
	binutils-csl-renesas-4_1-7:1.95.2.1
	binutils-csl-renesas-4_1-6:1.95.2.1
	binutils-csl-sourcerygxx-4_1-17:1.95.2.1
	binutils-csl-sourcerygxx-4_1-14:1.95.2.1
	binutils-csl-sourcerygxx-4_1-15:1.95.2.1
	binutils-csl-sourcerygxx-4_1-13:1.95.2.1
	binutils-2_17:1.95
	binutils-csl-sourcerygxx-4_1-12:1.95.2.1
	binutils-csl-sourcerygxx-3_4_4-21:1.95
	binutils-csl-wrs-linux-3_4_4-24:1.76
	binutils-csl-wrs-linux-3_4_4-23:1.76
	binutils-csl-sourcerygxx-4_1-9:1.95
	binutils-csl-sourcerygxx-4_1-8:1.95
	binutils-csl-sourcerygxx-4_1-7:1.95
	binutils-csl-arm-2006q1-6:1.95
	binutils-csl-sourcerygxx-4_1-6:1.95
	binutils-csl-wrs-linux-3_4_4-22:1.76
	binutils-csl-coldfire-4_1-11:1.95
	binutils-csl-sourcerygxx-3_4_4-19:1.95
	binutils-csl-coldfire-4_1-10:1.95
	binutils-csl-sourcerygxx-4_1-5:1.95
	binutils-csl-sourcerygxx-4_1-4:1.95
	binutils-csl-wrs-linux-3_4_4-21:1.76
	binutils-csl-morpho-4_1-4:1.95
	binutils-csl-sourcerygxx-3_4_4-17:1.95
	binutils-csl-wrs-linux-3_4_4-20:1.76
	binutils-2_17-branch:1.95.0.4
	binutils-2_17-branchpoint:1.95
	binutils-csl-2_17-branch:1.95.0.2
	binutils-csl-2_17-branchpoint:1.95
	binutils-csl-gxxpro-3_4-branch:1.76.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.76
	binutils-2_16_1:1.76
	binutils-csl-arm-2005q1b:1.76
	binutils-2_16:1.76
	binutils-csl-arm-2005q1a:1.76
	binutils-csl-arm-2005q1-branch:1.76.0.4
	binutils-csl-arm-2005q1-branchpoint:1.76
	binutils-2_16-branch:1.76.0.2
	binutils-2_16-branchpoint:1.76
	csl-arm-2004-q3d:1.72
	csl-arm-2004-q3:1.71
	binutils-2_15:1.65.6.1
	binutils-2_15-branchpoint:1.65
	csl-arm-2004-q1a:1.67
	csl-arm-2004-q1:1.66
	binutils-2_15-branch:1.65.0.6
	cagney_bfdfile-20040213-branch:1.65.0.4
	cagney_bfdfile-20040213-branchpoint:1.65
	cagney_bigcore-20040122-branch:1.65.0.2
	cagney_bigcore-20040122-branchpoint:1.65
	csl-arm-2003-q4:1.61
	binutils-2_14:1.46.2.1
	binutils-2_14-branch:1.46.0.2
	binutils-2_14-branchpoint:1.46
	binutils-2_13_2_1:1.40
	binutils-2_13_2:1.40
	binutils-2_13_1:1.40
	binutils-2_13:1.40
	binutils-2_13-branchpoint:1.40
	binutils-2_13-branch:1.40.0.2
	binutils-2_12_1:1.36.2.1
	binutils-2_12:1.36.2.1
	binutils-2_12-branch:1.36.0.2
	binutils-2_12-branchpoint:1.36
	cygnus_cvs_20020108_pre:1.33
	binutils-2_11_2:1.15.2.2
	binutils-2_11_1:1.15.2.2
	binutils-2_11:1.15
	x86_64versiong3:1.15
	binutils-2_11-branch:1.15.0.2
	binutils-2_10_1:1.6.2.3
	binutils-2_10:1.6.2.2
	binutils-2_10-branch:1.6.0.2
	binutils-2_10-branchpoint:1.6
	binutils_latest_snapshot:1.165
	repo-unification-2000-02-06:1.6
	binu_ss_19990721:1.4
	binu_ss_19990602:1.2
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.165
date	2013.02.15.14.25.34;	author ktietz;	state Exp;
branches;
next	1.164;

1.164
date	2013.02.15.09.32.31;	author nickc;	state Exp;
branches;
next	1.163;

1.163
date	2013.02.14.11.52.25;	author nickc;	state Exp;
branches;
next	1.162;

1.162
date	2013.01.28.09.31.01;	author amodra;	state Exp;
branches;
next	1.161;

1.161
date	2013.01.25.11.32.44;	author nickc;	state Exp;
branches;
next	1.160;

1.160
date	2013.01.07.17.40.59;	author roland;	state Exp;
branches;
next	1.159;

1.159
date	2012.11.07.06.16.26;	author hjl;	state Exp;
branches;
next	1.158;

1.158
date	2012.10.18.17.29.54;	author ktietz;	state Exp;
branches;
next	1.157;

1.157
date	2012.05.08.17.49.36;	author ccoutant;	state Exp;
branches
	1.157.2.1;
next	1.156;

1.156
date	2012.04.25.17.50.14;	author ccoutant;	state Exp;
branches;
next	1.155;

1.155
date	2012.04.13.02.52.34;	author hjl;	state Exp;
branches;
next	1.154;

1.154
date	2012.02.09.04.51.43;	author amodra;	state Exp;
branches;
next	1.153;

1.153
date	2011.09.16.04.23.17;	author hjl;	state Exp;
branches;
next	1.152;

1.152
date	2011.05.06.14.41.56;	author amodra;	state Exp;
branches;
next	1.151;

1.151
date	2011.04.04.01.35.59;	author hjl;	state Exp;
branches;
next	1.150;

1.150
date	2011.03.14.20.51.59;	author msnyder;	state Exp;
branches;
next	1.149;

1.149
date	2011.02.28.18.32.51;	author ktietz;	state Exp;
branches;
next	1.148;

1.148
date	2010.11.08.02.48.57;	author amodra;	state Exp;
branches;
next	1.147;

1.147
date	2010.10.29.12.10.25;	author hjl;	state Exp;
branches
	1.147.2.1;
next	1.146;

1.146
date	2010.09.10.12.11.27;	author nickc;	state Exp;
branches;
next	1.145;

1.145
date	2010.07.17.19.33.11;	author davek;	state Exp;
branches;
next	1.144;

1.144
date	2010.07.17.14.41.28;	author hjl;	state Exp;
branches;
next	1.143;

1.143
date	2010.06.29.08.47.40;	author amodra;	state Exp;
branches;
next	1.142;

1.142
date	2010.02.01.09.59.46;	author nathan;	state Exp;
branches;
next	1.141;

1.141
date	2010.01.20.00.09.13;	author ian;	state Exp;
branches;
next	1.140;

1.140
date	2010.01.05.00.41.54;	author hjl;	state Exp;
branches;
next	1.139;

1.139
date	2010.01.05.00.39.47;	author hjl;	state Exp;
branches;
next	1.138;

1.138
date	2009.12.31.14.40.36;	author nickc;	state Exp;
branches;
next	1.137;

1.137
date	2009.12.11.13.42.06;	author nickc;	state Exp;
branches;
next	1.136;

1.136
date	2009.09.11.11.16.19;	author nickc;	state Exp;
branches;
next	1.135;

1.135
date	2009.09.10.13.40.44;	author nickc;	state Exp;
branches;
next	1.134;

1.134
date	2009.08.03.13.47.35;	author hjl;	state Exp;
branches
	1.134.2.1;
next	1.133;

1.133
date	2009.06.27.17.19.02;	author hjl;	state Exp;
branches;
next	1.132;

1.132
date	2009.05.12.09.07.37;	author amodra;	state Exp;
branches;
next	1.131;

1.131
date	2009.04.27.13.59.43;	author hjl;	state Exp;
branches;
next	1.130;

1.130
date	2009.04.17.15.03.46;	author hjl;	state Exp;
branches;
next	1.129;

1.129
date	2009.04.17.13.46.18;	author hjl;	state Exp;
branches;
next	1.128;

1.128
date	2009.04.14.09.47.44;	author davek;	state Exp;
branches;
next	1.127;

1.127
date	2009.03.13.13.39.57;	author hjl;	state Exp;
branches;
next	1.126;

1.126
date	2009.03.10.00.48.09;	author hjl;	state Exp;
branches;
next	1.125;

1.125
date	2009.01.29.13.03.21;	author amodra;	state Exp;
branches;
next	1.124;

1.124
date	2008.09.28.13.29.18;	author amodra;	state Exp;
branches;
next	1.123;

1.123
date	2008.08.06.00.42.17;	author amodra;	state Exp;
branches
	1.123.2.1;
next	1.122;

1.122
date	2008.06.12.11.57.40;	author nickc;	state Exp;
branches;
next	1.121;

1.121
date	2008.04.16.08.24.21;	author nickc;	state Exp;
branches;
next	1.120;

1.120
date	2008.03.28.06.49.44;	author nickc;	state Exp;
branches;
next	1.119;

1.119
date	2007.08.30.10.19.03;	author nathan;	state Exp;
branches;
next	1.118;

1.118
date	2007.08.04.08.26.38;	author amodra;	state Exp;
branches;
next	1.117;

1.117
date	2007.07.05.16.54.45;	author nickc;	state Exp;
branches;
next	1.116;

1.116
date	2007.07.02.08.05.06;	author amodra;	state Exp;
branches;
next	1.115;

1.115
date	2007.06.29.00.34.14;	author roland;	state Exp;
branches;
next	1.114;

1.114
date	2007.06.27.11.54.09;	author amodra;	state Exp;
branches;
next	1.113;

1.113
date	2007.05.30.14.29.27;	author amodra;	state Exp;
branches;
next	1.112;

1.112
date	2007.05.18.06.36.14;	author nathan;	state Exp;
branches;
next	1.111;

1.111
date	2007.05.11.14.09.50;	author amodra;	state Exp;
branches;
next	1.110;

1.110
date	2007.04.26.14.46.59;	author amodra;	state Exp;
branches;
next	1.109;

1.109
date	2007.04.24.10.56.58;	author nickc;	state Exp;
branches;
next	1.108;

1.108
date	2007.04.23.10.59.07;	author nickc;	state Exp;
branches;
next	1.107;

1.107
date	2007.04.12.19.20.46;	author hjl;	state Exp;
branches;
next	1.106;

1.106
date	2007.03.01.16.39.42;	author rsandifo;	state Exp;
branches;
next	1.105;

1.105
date	2007.02.17.13.33.54;	author jsm28;	state Exp;
branches;
next	1.104;

1.104
date	2007.01.10.13.36.34;	author amodra;	state Exp;
branches;
next	1.103;

1.103
date	2006.10.13.09.43.29;	author nickc;	state Exp;
branches;
next	1.102;

1.102
date	2006.09.14.23.37.35;	author hjl;	state Exp;
branches;
next	1.101;

1.101
date	2006.09.14.12.11.33;	author amodra;	state Exp;
branches;
next	1.100;

1.100
date	2006.09.13.15.08.38;	author amodra;	state Exp;
branches;
next	1.99;

1.99
date	2006.09.11.14.40.39;	author nickc;	state Exp;
branches;
next	1.98;

1.98
date	2006.09.05.08.22.27;	author nickc;	state Exp;
branches;
next	1.97;

1.97
date	2006.08.06.15.49.46;	author nickc;	state Exp;
branches;
next	1.96;

1.96
date	2006.06.23.16.23.09;	author rsandifo;	state Exp;
branches;
next	1.95;

1.95
date	2006.02.28.16.09.01;	author nickc;	state Exp;
branches
	1.95.2.1;
next	1.94;

1.94
date	2006.01.30.13.06.53;	author nickc;	state Exp;
branches;
next	1.93;

1.93
date	2006.01.18.11.01.09;	author nickc;	state Exp;
branches;
next	1.92;

1.92
date	2006.01.10.22.34.03;	author amodra;	state Exp;
branches;
next	1.91;

1.91
date	2006.01.10.22.14.18;	author amodra;	state Exp;
branches;
next	1.90;

1.90
date	2005.11.15.08.33.38;	author jbeulich;	state Exp;
branches;
next	1.89;

1.89
date	2005.10.12.08.55.55;	author nickc;	state Exp;
branches;
next	1.88;

1.88
date	2005.10.11.16.33.16;	author nickc;	state Exp;
branches;
next	1.87;

1.87
date	2005.10.03.19.37.44;	author mmitchel;	state Exp;
branches;
next	1.86;

1.86
date	2005.09.30.16.37.31;	author mmitchel;	state Exp;
branches;
next	1.85;

1.85
date	2005.07.04.01.53.42;	author amodra;	state Exp;
branches;
next	1.84;

1.84
date	2005.06.14.13.26.42;	author hjl;	state Exp;
branches;
next	1.83;

1.83
date	2005.05.08.14.17.38;	author nickc;	state Exp;
branches;
next	1.82;

1.82
date	2005.05.06.06.32.43;	author jbeulich;	state Exp;
branches;
next	1.81;

1.81
date	2005.04.25.14.27.00;	author nickc;	state Exp;
branches;
next	1.80;

1.80
date	2005.04.25.09.25.57;	author nickc;	state Exp;
branches;
next	1.79;

1.79
date	2005.04.25.09.23.23;	author nickc;	state Exp;
branches;
next	1.78;

1.78
date	2005.04.15.16.28.52;	author nickc;	state Exp;
branches;
next	1.77;

1.77
date	2005.03.15.17.45.18;	author nickc;	state Exp;
branches;
next	1.76;

1.76
date	2005.03.03.11.46.12;	author amodra;	state Exp;
branches
	1.76.6.1;
next	1.75;

1.75
date	2005.03.02.09.03.53;	author jbeulich;	state Exp;
branches;
next	1.74;

1.74
date	2005.02.22.00.50.06;	author hjl;	state Exp;
branches;
next	1.73;

1.73
date	2004.12.16.13.16.30;	author jbeulich;	state Exp;
branches;
next	1.72;

1.72
date	2004.10.18.14.04.40;	author nickc;	state Exp;
branches;
next	1.71;

1.71
date	2004.07.21.15.42.58;	author hjl;	state Exp;
branches;
next	1.70;

1.70
date	2004.06.24.04.46.27;	author amodra;	state Exp;
branches;
next	1.69;

1.69
date	2004.06.15.01.19.13;	author amodra;	state Exp;
branches;
next	1.68;

1.68
date	2004.05.17.16.39.59;	author bwilson;	state Exp;
branches;
next	1.67;

1.67
date	2004.04.27.06.31.16;	author amodra;	state Exp;
branches;
next	1.66;

1.66
date	2004.02.19.17.15.28;	author jakub;	state Exp;
branches;
next	1.65;

1.65
date	2004.01.13.15.41.00;	author jakub;	state Exp;
branches
	1.65.6.1;
next	1.64;

1.64
date	2004.01.12.13.34.30;	author nickc;	state Exp;
branches;
next	1.63;

1.63
date	2004.01.12.13.10.02;	author nickc;	state Exp;
branches;
next	1.62;

1.62
date	2004.01.02.22.54.47;	author amodra;	state Exp;
branches;
next	1.61;

1.61
date	2003.12.23.13.01.11;	author macro;	state Exp;
branches;
next	1.60;

1.60
date	2003.12.11.13.22.51;	author nickc;	state Exp;
branches;
next	1.59;

1.59
date	2003.12.06.00.06.12;	author kazu;	state Exp;
branches;
next	1.58;

1.58
date	2003.12.04.18.24.07;	author nickc;	state Exp;
branches;
next	1.57;

1.57
date	2003.11.11.17.50.26;	author nickc;	state Exp;
branches;
next	1.56;

1.56
date	2003.11.07.12.19.34;	author nickc;	state Exp;
branches;
next	1.55;

1.55
date	2003.10.27.12.45.38;	author nickc;	state Exp;
branches;
next	1.54;

1.54
date	2003.10.21.14.08.12;	author nickc;	state Exp;
branches;
next	1.53;

1.53
date	2003.08.05.14.40.54;	author amodra;	state Exp;
branches;
next	1.52;

1.52
date	2003.07.23.17.34.03;	author nickc;	state Exp;
branches;
next	1.51;

1.51
date	2003.06.27.08.01.28;	author nickc;	state Exp;
branches;
next	1.50;

1.50
date	2003.06.26.08.14.10;	author nickc;	state Exp;
branches;
next	1.49;

1.49
date	2003.06.12.07.23.31;	author nickc;	state Exp;
branches;
next	1.48;

1.48
date	2003.06.02.14.45.12;	author thorpej;	state Exp;
branches;
next	1.47;

1.47
date	2003.05.13.11.15.59;	author nickc;	state Exp;
branches;
next	1.46;

1.46
date	2003.03.24.16.11.46;	author nickc;	state Exp;
branches
	1.46.2.1;
next	1.45;

1.45
date	2003.02.21.01.12.13;	author amodra;	state Exp;
branches;
next	1.44;

1.44
date	2002.12.13.13.19.44;	author nickc;	state Exp;
branches;
next	1.43;

1.43
date	2002.11.30.08.39.41;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2002.10.15.05.10.48;	author amodra;	state Exp;
branches;
next	1.41;

1.41
date	2002.08.13.13.39.02;	author hjl;	state Exp;
branches;
next	1.40;

1.40
date	2002.06.05.14.06.52;	author amodra;	state Exp;
branches;
next	1.39;

1.39
date	2002.05.21.19.34.58;	author kazu;	state Exp;
branches;
next	1.38;

1.38
date	2002.02.11.05.08.42;	author amodra;	state Exp;
branches;
next	1.37;

1.37
date	2002.02.11.02.34.14;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2002.01.25.15.37.02;	author nickc;	state Exp;
branches
	1.36.2.1;
next	1.35;

1.35
date	2002.01.23.16.12.55;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	2002.01.15.17.18.53;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	2001.12.19.05.18.34;	author msnyder;	state Exp;
branches;
next	1.32;

1.32
date	2001.12.18.11.54.10;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2001.12.18.08.22.30;	author ths;	state Exp;
branches;
next	1.30;

1.30
date	2001.12.10.11.03.54;	author jakub;	state Exp;
branches;
next	1.29;

1.29
date	2001.11.29.00.51.58;	author mrs;	state Exp;
branches;
next	1.28;

1.28
date	2001.09.19.06.58.06;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2001.09.19.05.33.16;	author hjl;	state Exp;
branches;
next	1.26;

1.26
date	2001.08.24.13.56.08;	author aoliva;	state Exp;
branches;
next	1.25;

1.25
date	2001.07.31.13.49.38;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2001.07.06.08.05.27;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2001.07.06.08.01.17;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2001.07.05.07.49.05;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2001.07.05.07.27.16;	author hjl;	state Exp;
branches;
next	1.20;

1.20
date	2001.06.24.16.27.00;	author hjl;	state Exp;
branches;
next	1.19;

1.19
date	2001.06.22.09.02.05;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2001.05.30.10.46.26;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2001.03.13.06.43.57;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2001.03.13.00.08.35;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2001.01.18.00.17.43;	author nickc;	state Exp;
branches
	1.15.2.1;
next	1.14;

1.14
date	2000.11.03.01.47.13;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2000.08.14.19.47.01;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2000.05.26.13.11.56;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2000.05.14.17.13.16;	author hjl;	state Exp;
branches;
next	1.10;

1.10
date	2000.05.08.04.28.06;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2000.04.05.03.43.56;	author amodra;	state Exp;
branches;
next	1.8;

1.8
date	2000.04.04.14.32.29;	author amodra;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.03.14.10.03;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	99.11.22.09.42.42;	author nickc;	state Exp;
branches
	1.6.2.1;
next	1.5;

1.5
date	99.09.12.18.33.05;	author ian;	state Exp;
branches;
next	1.4;

1.4
date	99.07.11.20.02.22;	author ian;	state Exp;
branches;
next	1.3;

1.3
date	99.06.12.15.42.01;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.05.27.03.16.15;	author schwab;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.29.10;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.157.2.1
date	2013.01.07.17.42.43;	author roland;	state Exp;
branches;
next	;

1.147.2.1
date	2011.02.01.12.25.36;	author amodra;	state Exp;
branches;
next	1.147.2.2;

1.147.2.2
date	2011.05.29.04.51.25;	author amodra;	state Exp;
branches;
next	;

1.134.2.1
date	2009.09.10.13.42.08;	author nickc;	state Exp;
branches;
next	1.134.2.2;

1.134.2.2
date	2009.12.31.14.43.49;	author nickc;	state Exp;
branches;
next	;

1.123.2.1
date	2009.03.02.13.31.14;	author amodra;	state Exp;
branches;
next	;

1.95.2.1
date	2006.06.22.15.44.18;	author rsandifo;	state Exp;
branches;
next	1.95.2.2;

1.95.2.2
date	2006.10.16.20.21.23;	author nathan;	state Exp;
branches;
next	;

1.76.6.1
date	2005.08.30.19.57.32;	author mmitchel;	state Exp;
branches;
next	;

1.65.6.1
date	2004.04.09.18.28.06;	author drow;	state Exp;
branches;
next	;

1.46.2.1
date	2003.05.15.19.20.38;	author drow;	state Exp;
branches;
next	;

1.36.2.1
date	2002.02.11.02.57.17;	author amodra;	state Exp;
branches;
next	;

1.15.2.1
date	2001.05.30.10.49.03;	author nickc;	state Exp;
branches;
next	1.15.2.2;

1.15.2.2
date	2001.06.07.03.12.27;	author amodra;	state Exp;
branches;
next	1.15.2.3;

1.15.2.3
date	2001.06.27.16.45.43;	author nickc;	state Exp;
branches;
next	;

1.6.2.1
date	2000.04.05.05.36.40;	author amodra;	state Exp;
branches;
next	1.6.2.2;

1.6.2.2
date	2000.05.28.10.57.50;	author amodra;	state Exp;
branches;
next	1.6.2.3;

1.6.2.3
date	2000.09.05.08.56.22;	author obrien;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.10;	author rth;	state Exp;
branches;
next	;


desc
@@


1.165
log
@        * objcopy.c (copy_main): Initialize context variable.
@
text
@/* objcopy.c -- copy object file from input to output, optionally massaging it.
   Copyright 1991-2013 Free Software Foundation, Inc.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "progress.h"
#include "getopt.h"
#include "libiberty.h"
#include "bucomm.h"
#include "budbg.h"
#include "filenames.h"
#include "fnmatch.h"
#include "elf-bfd.h"
#include "libbfd.h"
#include "coff/internal.h"
#include "libcoff.h"

/* FIXME: See bfd/peXXigen.c for why we include an architecture specific
   header in generic PE code.  */
#include "coff/i386.h"
#include "coff/pe.h"

static bfd_vma pe_file_alignment = (bfd_vma) -1;
static bfd_vma pe_heap_commit = (bfd_vma) -1;
static bfd_vma pe_heap_reserve = (bfd_vma) -1;
static bfd_vma pe_image_base = (bfd_vma) -1;
static bfd_vma pe_section_alignment = (bfd_vma) -1;
static bfd_vma pe_stack_commit = (bfd_vma) -1;
static bfd_vma pe_stack_reserve = (bfd_vma) -1;
static short pe_subsystem = -1;
static short pe_major_subsystem_version = -1;
static short pe_minor_subsystem_version = -1;

struct is_specified_symbol_predicate_data
{
  const char	*name;
  bfd_boolean	found;
};

/* A list to support redefine_sym.  */
struct redefine_node
{
  char *source;
  char *target;
  struct redefine_node *next;
};

typedef struct section_rename
{
  const char *            old_name;
  const char *            new_name;
  flagword                flags;
  struct section_rename * next;
}
section_rename;

/* List of sections to be renamed.  */
static section_rename *section_rename_list;

static asymbol **isympp = NULL;	/* Input symbols.  */
static asymbol **osympp = NULL;	/* Output symbols that survive stripping.  */

/* If `copy_byte' >= 0, copy 'copy_width' byte(s) of every `interleave' bytes.  */
static int copy_byte = -1;
static int interleave = 0; /* Initialised to 4 in copy_main().  */
static int copy_width = 1;

static bfd_boolean verbose;		/* Print file and target names.  */
static bfd_boolean preserve_dates;	/* Preserve input file timestamp.  */
static int deterministic = -1;		/* Enable deterministic archives.  */
static int status = 0;		/* Exit status.  */

enum strip_action
  {
    STRIP_UNDEF,
    STRIP_NONE,			/* Don't strip.  */
    STRIP_DEBUG,		/* Strip all debugger symbols.  */
    STRIP_UNNEEDED,		/* Strip unnecessary symbols.  */
    STRIP_NONDEBUG,		/* Strip everything but debug info.  */
    STRIP_DWO,			/* Strip all DWO info.  */
    STRIP_NONDWO,		/* Strip everything but DWO info.  */
    STRIP_ALL			/* Strip all symbols.  */
  };

/* Which symbols to remove.  */
static enum strip_action strip_symbols = STRIP_UNDEF;

enum locals_action
  {
    LOCALS_UNDEF,
    LOCALS_START_L,		/* Discard locals starting with L.  */
    LOCALS_ALL			/* Discard all locals.  */
  };

/* Which local symbols to remove.  Overrides STRIP_ALL.  */
static enum locals_action discard_locals;

/* Structure used to hold lists of sections and actions to take.  */
struct section_list
{
  struct section_list * next;	   /* Next section to change.  */
  const char *		pattern;   /* Section name pattern.  */
  bfd_boolean		used;	   /* Whether this entry was used.  */

  unsigned int          context;   /* What to do with matching sections.  */
  /* Flag bits used in the context field.
     COPY and REMOVE are mutually exlusive.  SET and ALTER are mutually exclusive.  */
#define SECTION_CONTEXT_REMOVE    (1 << 0) /* Remove this section.  */
#define SECTION_CONTEXT_COPY      (1 << 1) /* Copy this section, delete all non-copied section.  */
#define SECTION_CONTEXT_SET_VMA   (1 << 2) /* Set the sections' VMA address.  */
#define SECTION_CONTEXT_ALTER_VMA (1 << 3) /* Increment or decrement the section's VMA address.  */
#define SECTION_CONTEXT_SET_LMA   (1 << 4) /* Set the sections' LMA address.  */
#define SECTION_CONTEXT_ALTER_LMA (1 << 5) /* Increment or decrement the section's LMA address.  */
#define SECTION_CONTEXT_SET_FLAGS (1 << 6) /* Set the section's flags.  */

  bfd_vma		vma_val;   /* Amount to change by or set to.  */
  bfd_vma		lma_val;   /* Amount to change by or set to.  */
  flagword		flags;	   /* What to set the section flags to.	 */
};

static struct section_list *change_sections;

/* TRUE if some sections are to be removed.  */
static bfd_boolean sections_removed;

/* TRUE if only some sections are to be copied.  */
static bfd_boolean sections_copied;

/* Changes to the start address.  */
static bfd_vma change_start = 0;
static bfd_boolean set_start_set = FALSE;
static bfd_vma set_start;

/* Changes to section addresses.  */
static bfd_vma change_section_address = 0;

/* Filling gaps between sections.  */
static bfd_boolean gap_fill_set = FALSE;
static bfd_byte gap_fill = 0;

/* Pad to a given address.  */
static bfd_boolean pad_to_set = FALSE;
static bfd_vma pad_to;

/* Use alternative machine code?  */
static unsigned long use_alt_mach_code = 0;

/* Output BFD flags user wants to set or clear */
static flagword bfd_flags_to_set;
static flagword bfd_flags_to_clear;

/* List of sections to add.  */
struct section_add
{
  /* Next section to add.  */
  struct section_add *next;
  /* Name of section to add.  */
  const char *name;
  /* Name of file holding section contents.  */
  const char *filename;
  /* Size of file.  */
  size_t size;
  /* Contents of file.  */
  bfd_byte *contents;
  /* BFD section, after it has been added.  */
  asection *section;
};

/* List of sections to add to the output BFD.  */
static struct section_add *add_sections;

/* If non-NULL the argument to --add-gnu-debuglink.
   This should be the filename to store in the .gnu_debuglink section.  */
static const char * gnu_debuglink_filename = NULL;

/* Whether to convert debugging information.  */
static bfd_boolean convert_debugging = FALSE;

/* Whether to compress/decompress DWARF debug sections.  */
static enum
{
  nothing,
  compress,
  decompress
} do_debug_sections = nothing;

/* Whether to change the leading character in symbol names.  */
static bfd_boolean change_leading_char = FALSE;

/* Whether to remove the leading character from global symbol names.  */
static bfd_boolean remove_leading_char = FALSE;

/* Whether to permit wildcard in symbol comparison.  */
static bfd_boolean wildcard = FALSE;

/* True if --localize-hidden is in effect.  */
static bfd_boolean localize_hidden = FALSE;

/* List of symbols to strip, keep, localize, keep-global, weaken,
   or redefine.  */
static htab_t strip_specific_htab = NULL;
static htab_t strip_unneeded_htab = NULL;
static htab_t keep_specific_htab = NULL;
static htab_t localize_specific_htab = NULL;
static htab_t globalize_specific_htab = NULL;
static htab_t keepglobal_specific_htab = NULL;
static htab_t weaken_specific_htab = NULL;
static struct redefine_node *redefine_sym_list = NULL;

/* If this is TRUE, we weaken global symbols (set BSF_WEAK).  */
static bfd_boolean weaken = FALSE;

/* If this is TRUE, we retain BSF_FILE symbols.  */
static bfd_boolean keep_file_symbols = FALSE;

/* Prefix symbols/sections.  */
static char *prefix_symbols_string = 0;
static char *prefix_sections_string = 0;
static char *prefix_alloc_sections_string = 0;

/* True if --extract-symbol was passed on the command line.  */
static bfd_boolean extract_symbol = FALSE;

/* If `reverse_bytes' is nonzero, then reverse the order of every chunk
   of <reverse_bytes> bytes within each output section.  */
static int reverse_bytes = 0;

/* For Coff objects, we may want to allow or disallow long section names,
   or preserve them where found in the inputs.  Debug info relies on them.  */
enum long_section_name_handling
  {
    DISABLE,
    ENABLE,
    KEEP
  };

/* The default long section handling mode is to preserve them.
   This is also the only behaviour for 'strip'.  */
static enum long_section_name_handling long_section_names = KEEP;

/* 150 isn't special; it's just an arbitrary non-ASCII char value.  */
enum command_line_switch
  {
    OPTION_ADD_SECTION=150,
    OPTION_CHANGE_ADDRESSES,
    OPTION_CHANGE_LEADING_CHAR,
    OPTION_CHANGE_START,
    OPTION_CHANGE_SECTION_ADDRESS,
    OPTION_CHANGE_SECTION_LMA,
    OPTION_CHANGE_SECTION_VMA,
    OPTION_CHANGE_WARNINGS,
    OPTION_COMPRESS_DEBUG_SECTIONS,
    OPTION_DEBUGGING,
    OPTION_DECOMPRESS_DEBUG_SECTIONS,
    OPTION_GAP_FILL,
    OPTION_NO_CHANGE_WARNINGS,
    OPTION_PAD_TO,
    OPTION_REMOVE_LEADING_CHAR,
    OPTION_SET_SECTION_FLAGS,
    OPTION_SET_START,
    OPTION_STRIP_UNNEEDED,
    OPTION_WEAKEN,
    OPTION_REDEFINE_SYM,
    OPTION_REDEFINE_SYMS,
    OPTION_SREC_LEN,
    OPTION_SREC_FORCES3,
    OPTION_STRIP_SYMBOLS,
    OPTION_STRIP_UNNEEDED_SYMBOL,
    OPTION_STRIP_UNNEEDED_SYMBOLS,
    OPTION_KEEP_SYMBOLS,
    OPTION_LOCALIZE_HIDDEN,
    OPTION_LOCALIZE_SYMBOLS,
    OPTION_LONG_SECTION_NAMES,
    OPTION_GLOBALIZE_SYMBOL,
    OPTION_GLOBALIZE_SYMBOLS,
    OPTION_KEEPGLOBAL_SYMBOLS,
    OPTION_WEAKEN_SYMBOLS,
    OPTION_RENAME_SECTION,
    OPTION_ALT_MACH_CODE,
    OPTION_PREFIX_SYMBOLS,
    OPTION_PREFIX_SECTIONS,
    OPTION_PREFIX_ALLOC_SECTIONS,
    OPTION_FORMATS_INFO,
    OPTION_ADD_GNU_DEBUGLINK,
    OPTION_ONLY_KEEP_DEBUG,
    OPTION_KEEP_FILE_SYMBOLS,
    OPTION_READONLY_TEXT,
    OPTION_WRITABLE_TEXT,
    OPTION_PURE,
    OPTION_IMPURE,
    OPTION_EXTRACT_SYMBOL,
    OPTION_REVERSE_BYTES,
    OPTION_FILE_ALIGNMENT,
    OPTION_HEAP,
    OPTION_IMAGE_BASE,
    OPTION_SECTION_ALIGNMENT,
    OPTION_STACK,
    OPTION_INTERLEAVE_WIDTH,
    OPTION_SUBSYSTEM,
    OPTION_EXTRACT_DWO,
    OPTION_STRIP_DWO
  };

/* Options to handle if running as "strip".  */

static struct option strip_options[] =
{
  {"disable-deterministic-archives", no_argument, 0, 'U'},
  {"discard-all", no_argument, 0, 'x'},
  {"discard-locals", no_argument, 0, 'X'},
  {"enable-deterministic-archives", no_argument, 0, 'D'},
  {"format", required_argument, 0, 'F'}, /* Obsolete */
  {"help", no_argument, 0, 'h'},
  {"info", no_argument, 0, OPTION_FORMATS_INFO},
  {"input-format", required_argument, 0, 'I'}, /* Obsolete */
  {"input-target", required_argument, 0, 'I'},
  {"keep-file-symbols", no_argument, 0, OPTION_KEEP_FILE_SYMBOLS},
  {"keep-symbol", required_argument, 0, 'K'},
  {"only-keep-debug", no_argument, 0, OPTION_ONLY_KEEP_DEBUG},
  {"output-format", required_argument, 0, 'O'},	/* Obsolete */
  {"output-target", required_argument, 0, 'O'},
  {"output-file", required_argument, 0, 'o'},
  {"preserve-dates", no_argument, 0, 'p'},
  {"remove-section", required_argument, 0, 'R'},
  {"strip-all", no_argument, 0, 's'},
  {"strip-debug", no_argument, 0, 'S'},
  {"strip-dwo", no_argument, 0, OPTION_STRIP_DWO},
  {"strip-unneeded", no_argument, 0, OPTION_STRIP_UNNEEDED},
  {"strip-symbol", required_argument, 0, 'N'},
  {"target", required_argument, 0, 'F'},
  {"verbose", no_argument, 0, 'v'},
  {"version", no_argument, 0, 'V'},
  {"wildcard", no_argument, 0, 'w'},
  {0, no_argument, 0, 0}
};

/* Options to handle if running as "objcopy".  */

static struct option copy_options[] =
{
  {"add-gnu-debuglink", required_argument, 0, OPTION_ADD_GNU_DEBUGLINK},
  {"add-section", required_argument, 0, OPTION_ADD_SECTION},
  {"adjust-start", required_argument, 0, OPTION_CHANGE_START},
  {"adjust-vma", required_argument, 0, OPTION_CHANGE_ADDRESSES},
  {"adjust-section-vma", required_argument, 0, OPTION_CHANGE_SECTION_ADDRESS},
  {"adjust-warnings", no_argument, 0, OPTION_CHANGE_WARNINGS},
  {"alt-machine-code", required_argument, 0, OPTION_ALT_MACH_CODE},
  {"binary-architecture", required_argument, 0, 'B'},
  {"byte", required_argument, 0, 'b'},
  {"change-addresses", required_argument, 0, OPTION_CHANGE_ADDRESSES},
  {"change-leading-char", no_argument, 0, OPTION_CHANGE_LEADING_CHAR},
  {"change-section-address", required_argument, 0, OPTION_CHANGE_SECTION_ADDRESS},
  {"change-section-lma", required_argument, 0, OPTION_CHANGE_SECTION_LMA},
  {"change-section-vma", required_argument, 0, OPTION_CHANGE_SECTION_VMA},
  {"change-start", required_argument, 0, OPTION_CHANGE_START},
  {"change-warnings", no_argument, 0, OPTION_CHANGE_WARNINGS},
  {"compress-debug-sections", no_argument, 0, OPTION_COMPRESS_DEBUG_SECTIONS},
  {"debugging", no_argument, 0, OPTION_DEBUGGING},
  {"decompress-debug-sections", no_argument, 0, OPTION_DECOMPRESS_DEBUG_SECTIONS},
  {"disable-deterministic-archives", no_argument, 0, 'U'},
  {"discard-all", no_argument, 0, 'x'},
  {"discard-locals", no_argument, 0, 'X'},
  {"enable-deterministic-archives", no_argument, 0, 'D'},
  {"extract-dwo", no_argument, 0, OPTION_EXTRACT_DWO},
  {"extract-symbol", no_argument, 0, OPTION_EXTRACT_SYMBOL},
  {"format", required_argument, 0, 'F'}, /* Obsolete */
  {"gap-fill", required_argument, 0, OPTION_GAP_FILL},
  {"globalize-symbol", required_argument, 0, OPTION_GLOBALIZE_SYMBOL},
  {"globalize-symbols", required_argument, 0, OPTION_GLOBALIZE_SYMBOLS},
  {"help", no_argument, 0, 'h'},
  {"impure", no_argument, 0, OPTION_IMPURE},
  {"info", no_argument, 0, OPTION_FORMATS_INFO},
  {"input-format", required_argument, 0, 'I'}, /* Obsolete */
  {"input-target", required_argument, 0, 'I'},
  {"interleave", optional_argument, 0, 'i'},
  {"interleave-width", required_argument, 0, OPTION_INTERLEAVE_WIDTH},
  {"keep-file-symbols", no_argument, 0, OPTION_KEEP_FILE_SYMBOLS},
  {"keep-global-symbol", required_argument, 0, 'G'},
  {"keep-global-symbols", required_argument, 0, OPTION_KEEPGLOBAL_SYMBOLS},
  {"keep-symbol", required_argument, 0, 'K'},
  {"keep-symbols", required_argument, 0, OPTION_KEEP_SYMBOLS},
  {"localize-hidden", no_argument, 0, OPTION_LOCALIZE_HIDDEN},
  {"localize-symbol", required_argument, 0, 'L'},
  {"localize-symbols", required_argument, 0, OPTION_LOCALIZE_SYMBOLS},
  {"long-section-names", required_argument, 0, OPTION_LONG_SECTION_NAMES},
  {"no-adjust-warnings", no_argument, 0, OPTION_NO_CHANGE_WARNINGS},
  {"no-change-warnings", no_argument, 0, OPTION_NO_CHANGE_WARNINGS},
  {"only-keep-debug", no_argument, 0, OPTION_ONLY_KEEP_DEBUG},
  {"only-section", required_argument, 0, 'j'},
  {"output-format", required_argument, 0, 'O'},	/* Obsolete */
  {"output-target", required_argument, 0, 'O'},
  {"pad-to", required_argument, 0, OPTION_PAD_TO},
  {"prefix-symbols", required_argument, 0, OPTION_PREFIX_SYMBOLS},
  {"prefix-sections", required_argument, 0, OPTION_PREFIX_SECTIONS},
  {"prefix-alloc-sections", required_argument, 0, OPTION_PREFIX_ALLOC_SECTIONS},
  {"preserve-dates", no_argument, 0, 'p'},
  {"pure", no_argument, 0, OPTION_PURE},
  {"readonly-text", no_argument, 0, OPTION_READONLY_TEXT},
  {"redefine-sym", required_argument, 0, OPTION_REDEFINE_SYM},
  {"redefine-syms", required_argument, 0, OPTION_REDEFINE_SYMS},
  {"remove-leading-char", no_argument, 0, OPTION_REMOVE_LEADING_CHAR},
  {"remove-section", required_argument, 0, 'R'},
  {"rename-section", required_argument, 0, OPTION_RENAME_SECTION},
  {"reverse-bytes", required_argument, 0, OPTION_REVERSE_BYTES},
  {"set-section-flags", required_argument, 0, OPTION_SET_SECTION_FLAGS},
  {"set-start", required_argument, 0, OPTION_SET_START},
  {"srec-len", required_argument, 0, OPTION_SREC_LEN},
  {"srec-forceS3", no_argument, 0, OPTION_SREC_FORCES3},
  {"strip-all", no_argument, 0, 'S'},
  {"strip-debug", no_argument, 0, 'g'},
  {"strip-dwo", no_argument, 0, OPTION_STRIP_DWO},
  {"strip-unneeded", no_argument, 0, OPTION_STRIP_UNNEEDED},
  {"strip-unneeded-symbol", required_argument, 0, OPTION_STRIP_UNNEEDED_SYMBOL},
  {"strip-unneeded-symbols", required_argument, 0, OPTION_STRIP_UNNEEDED_SYMBOLS},
  {"strip-symbol", required_argument, 0, 'N'},
  {"strip-symbols", required_argument, 0, OPTION_STRIP_SYMBOLS},
  {"target", required_argument, 0, 'F'},
  {"verbose", no_argument, 0, 'v'},
  {"version", no_argument, 0, 'V'},
  {"weaken", no_argument, 0, OPTION_WEAKEN},
  {"weaken-symbol", required_argument, 0, 'W'},
  {"weaken-symbols", required_argument, 0, OPTION_WEAKEN_SYMBOLS},
  {"wildcard", no_argument, 0, 'w'},
  {"writable-text", no_argument, 0, OPTION_WRITABLE_TEXT},
  {"file-alignment", required_argument, 0, OPTION_FILE_ALIGNMENT},
  {"heap", required_argument, 0, OPTION_HEAP},
  {"image-base", required_argument, 0 , OPTION_IMAGE_BASE},
  {"section-alignment", required_argument, 0, OPTION_SECTION_ALIGNMENT},
  {"stack", required_argument, 0, OPTION_STACK},
  {"subsystem", required_argument, 0, OPTION_SUBSYSTEM},
  {0, no_argument, 0, 0}
};

/* IMPORTS */
extern char *program_name;

/* This flag distinguishes between strip and objcopy:
   1 means this is 'strip'; 0 means this is 'objcopy'.
   -1 means if we should use argv[0] to decide.  */
extern int is_strip;

/* The maximum length of an S record.  This variable is declared in srec.c
   and can be modified by the --srec-len parameter.  */
extern unsigned int Chunk;

/* Restrict the generation of Srecords to type S3 only.
   This variable is declare in bfd/srec.c and can be toggled
   on by the --srec-forceS3 command line switch.  */
extern bfd_boolean S3Forced;

/* Forward declarations.  */
static void setup_section (bfd *, asection *, void *);
static void setup_bfd_headers (bfd *, bfd *);
static void copy_relocations_in_section (bfd *, asection *, void *);
static void copy_section (bfd *, asection *, void *);
static void get_sections (bfd *, asection *, void *);
static int compare_section_lma (const void *, const void *);
static void mark_symbols_used_in_relocations (bfd *, asection *, void *);
static bfd_boolean write_debugging_info (bfd *, void *, long *, asymbol ***);
static const char *lookup_sym_redefinition (const char *);

static void
copy_usage (FILE *stream, int exit_status)
{
  fprintf (stream, _("Usage: %s [option(s)] in-file [out-file]\n"), program_name);
  fprintf (stream, _(" Copies a binary file, possibly transforming it in the process\n"));
  fprintf (stream, _(" The options are:\n"));
  fprintf (stream, _("\
  -I --input-target <bfdname>      Assume input file is in format <bfdname>\n\
  -O --output-target <bfdname>     Create an output file in format <bfdname>\n\
  -B --binary-architecture <arch>  Set output arch, when input is arch-less\n\
  -F --target <bfdname>            Set both input and output format to <bfdname>\n\
     --debugging                   Convert debugging information, if possible\n\
  -p --preserve-dates              Copy modified/access timestamps to the output\n"));
  if (DEFAULT_AR_DETERMINISTIC)
    fprintf (stream, _("\
  -D --enable-deterministic-archives\n\
                                   Produce deterministic output when stripping archives (default)\n\
  -U --disable-deterministic-archives\n\
                                   Disable -D behavior\n"));
  else
    fprintf (stream, _("\
  -D --enable-deterministic-archives\n\
                                   Produce deterministic output when stripping archives\n\
  -U --disable-deterministic-archives\n\
                                   Disable -D behavior (default)\n"));
  fprintf (stream, _("\
  -j --only-section <name>         Only copy section <name> into the output\n\
     --add-gnu-debuglink=<file>    Add section .gnu_debuglink linking to <file>\n\
  -R --remove-section <name>       Remove section <name> from the output\n\
  -S --strip-all                   Remove all symbol and relocation information\n\
  -g --strip-debug                 Remove all debugging symbols & sections\n\
     --strip-dwo                   Remove all DWO sections\n\
     --strip-unneeded              Remove all symbols not needed by relocations\n\
  -N --strip-symbol <name>         Do not copy symbol <name>\n\
     --strip-unneeded-symbol <name>\n\
                                   Do not copy symbol <name> unless needed by\n\
                                     relocations\n\
     --only-keep-debug             Strip everything but the debug information\n\
     --extract-dwo                 Copy only DWO sections\n\
     --extract-symbol              Remove section contents but keep symbols\n\
  -K --keep-symbol <name>          Do not strip symbol <name>\n\
     --keep-file-symbols           Do not strip file symbol(s)\n\
     --localize-hidden             Turn all ELF hidden symbols into locals\n\
  -L --localize-symbol <name>      Force symbol <name> to be marked as a local\n\
     --globalize-symbol <name>     Force symbol <name> to be marked as a global\n\
  -G --keep-global-symbol <name>   Localize all symbols except <name>\n\
  -W --weaken-symbol <name>        Force symbol <name> to be marked as a weak\n\
     --weaken                      Force all global symbols to be marked as weak\n\
  -w --wildcard                    Permit wildcard in symbol comparison\n\
  -x --discard-all                 Remove all non-global symbols\n\
  -X --discard-locals              Remove any compiler-generated symbols\n\
  -i --interleave [<number>]       Only copy N out of every <number> bytes\n\
     --interleave-width <number>   Set N for --interleave\n\
  -b --byte <num>                  Select byte <num> in every interleaved block\n\
     --gap-fill <val>              Fill gaps between sections with <val>\n\
     --pad-to <addr>               Pad the last section up to address <addr>\n\
     --set-start <addr>            Set the start address to <addr>\n\
    {--change-start|--adjust-start} <incr>\n\
                                   Add <incr> to the start address\n\
    {--change-addresses|--adjust-vma} <incr>\n\
                                   Add <incr> to LMA, VMA and start addresses\n\
    {--change-section-address|--adjust-section-vma} <name>{=|+|-}<val>\n\
                                   Change LMA and VMA of section <name> by <val>\n\
     --change-section-lma <name>{=|+|-}<val>\n\
                                   Change the LMA of section <name> by <val>\n\
     --change-section-vma <name>{=|+|-}<val>\n\
                                   Change the VMA of section <name> by <val>\n\
    {--[no-]change-warnings|--[no-]adjust-warnings}\n\
                                   Warn if a named section does not exist\n\
     --set-section-flags <name>=<flags>\n\
                                   Set section <name>'s properties to <flags>\n\
     --add-section <name>=<file>   Add section <name> found in <file> to output\n\
     --rename-section <old>=<new>[,<flags>] Rename section <old> to <new>\n\
     --long-section-names {enable|disable|keep}\n\
                                   Handle long section names in Coff objects.\n\
     --change-leading-char         Force output format's leading character style\n\
     --remove-leading-char         Remove leading character from global symbols\n\
     --reverse-bytes=<num>         Reverse <num> bytes at a time, in output sections with content\n\
     --redefine-sym <old>=<new>    Redefine symbol name <old> to <new>\n\
     --redefine-syms <file>        --redefine-sym for all symbol pairs \n\
                                     listed in <file>\n\
     --srec-len <number>           Restrict the length of generated Srecords\n\
     --srec-forceS3                Restrict the type of generated Srecords to S3\n\
     --strip-symbols <file>        -N for all symbols listed in <file>\n\
     --strip-unneeded-symbols <file>\n\
                                   --strip-unneeded-symbol for all symbols listed\n\
                                     in <file>\n\
     --keep-symbols <file>         -K for all symbols listed in <file>\n\
     --localize-symbols <file>     -L for all symbols listed in <file>\n\
     --globalize-symbols <file>    --globalize-symbol for all in <file>\n\
     --keep-global-symbols <file>  -G for all symbols listed in <file>\n\
     --weaken-symbols <file>       -W for all symbols listed in <file>\n\
     --alt-machine-code <index>    Use the target's <index>'th alternative machine\n\
     --writable-text               Mark the output text as writable\n\
     --readonly-text               Make the output text write protected\n\
     --pure                        Mark the output file as demand paged\n\
     --impure                      Mark the output file as impure\n\
     --prefix-symbols <prefix>     Add <prefix> to start of every symbol name\n\
     --prefix-sections <prefix>    Add <prefix> to start of every section name\n\
     --prefix-alloc-sections <prefix>\n\
                                   Add <prefix> to start of every allocatable\n\
                                     section name\n\
     --file-alignment <num>        Set PE file alignment to <num>\n\
     --heap <reserve>[,<commit>]   Set PE reserve/commit heap to <reserve>/\n\
                                   <commit>\n\
     --image-base <address>        Set PE image base to <address>\n\
     --section-alignment <num>     Set PE section alignment to <num>\n\
     --stack <reserve>[,<commit>]  Set PE reserve/commit stack to <reserve>/\n\
                                   <commit>\n\
     --subsystem <name>[:<version>]\n\
                                   Set PE subsystem to <name> [& <version>]\n\
     --compress-debug-sections     Compress DWARF debug sections using zlib\n\
     --decompress-debug-sections   Decompress DWARF debug sections using zlib\n\
  -v --verbose                     List all object files modified\n\
  @@<file>                          Read options from <file>\n\
  -V --version                     Display this program's version number\n\
  -h --help                        Display this output\n\
     --info                        List object formats & architectures supported\n\
"));
  list_supported_targets (program_name, stream);
  if (REPORT_BUGS_TO[0] && exit_status == 0)
    fprintf (stream, _("Report bugs to %s\n"), REPORT_BUGS_TO);
  exit (exit_status);
}

static void
strip_usage (FILE *stream, int exit_status)
{
  fprintf (stream, _("Usage: %s <option(s)> in-file(s)\n"), program_name);
  fprintf (stream, _(" Removes symbols and sections from files\n"));
  fprintf (stream, _(" The options are:\n"));
  fprintf (stream, _("\
  -I --input-target=<bfdname>      Assume input file is in format <bfdname>\n\
  -O --output-target=<bfdname>     Create an output file in format <bfdname>\n\
  -F --target=<bfdname>            Set both input and output format to <bfdname>\n\
  -p --preserve-dates              Copy modified/access timestamps to the output\n\
"));
  if (DEFAULT_AR_DETERMINISTIC)
    fprintf (stream, _("\
  -D --enable-deterministic-archives\n\
                                   Produce deterministic output when stripping archives (default)\n\
  -U --disable-deterministic-archives\n\
                                   Disable -D behavior\n"));
  else
    fprintf (stream, _("\
  -D --enable-deterministic-archives\n\
                                   Produce deterministic output when stripping archives\n\
  -U --disable-deterministic-archives\n\
                                   Disable -D behavior (default)\n"));
  fprintf (stream, _("\
  -R --remove-section=<name>       Remove section <name> from the output\n\
  -s --strip-all                   Remove all symbol and relocation information\n\
  -g -S -d --strip-debug           Remove all debugging symbols & sections\n\
     --strip-dwo                   Remove all DWO sections\n\
     --strip-unneeded              Remove all symbols not needed by relocations\n\
     --only-keep-debug             Strip everything but the debug information\n\
  -N --strip-symbol=<name>         Do not copy symbol <name>\n\
  -K --keep-symbol=<name>          Do not strip symbol <name>\n\
     --keep-file-symbols           Do not strip file symbol(s)\n\
  -w --wildcard                    Permit wildcard in symbol comparison\n\
  -x --discard-all                 Remove all non-global symbols\n\
  -X --discard-locals              Remove any compiler-generated symbols\n\
  -v --verbose                     List all object files modified\n\
  -V --version                     Display this program's version number\n\
  -h --help                        Display this output\n\
     --info                        List object formats & architectures supported\n\
  -o <file>                        Place stripped output into <file>\n\
"));

  list_supported_targets (program_name, stream);
  if (REPORT_BUGS_TO[0] && exit_status == 0)
    fprintf (stream, _("Report bugs to %s\n"), REPORT_BUGS_TO);
  exit (exit_status);
}

/* Parse section flags into a flagword, with a fatal error if the
   string can't be parsed.  */

static flagword
parse_flags (const char *s)
{
  flagword ret;
  const char *snext;
  int len;

  ret = SEC_NO_FLAGS;

  do
    {
      snext = strchr (s, ',');
      if (snext == NULL)
	len = strlen (s);
      else
	{
	  len = snext - s;
	  ++snext;
	}

      if (0) ;
#define PARSE_FLAG(fname,fval) \
  else if (strncasecmp (fname, s, len) == 0) ret |= fval
      PARSE_FLAG ("alloc", SEC_ALLOC);
      PARSE_FLAG ("load", SEC_LOAD);
      PARSE_FLAG ("noload", SEC_NEVER_LOAD);
      PARSE_FLAG ("readonly", SEC_READONLY);
      PARSE_FLAG ("debug", SEC_DEBUGGING);
      PARSE_FLAG ("code", SEC_CODE);
      PARSE_FLAG ("data", SEC_DATA);
      PARSE_FLAG ("rom", SEC_ROM);
      PARSE_FLAG ("share", SEC_COFF_SHARED);
      PARSE_FLAG ("contents", SEC_HAS_CONTENTS);
      PARSE_FLAG ("merge", SEC_MERGE);
      PARSE_FLAG ("strings", SEC_STRINGS);
#undef PARSE_FLAG
      else
	{
	  char *copy;

	  copy = (char *) xmalloc (len + 1);
	  strncpy (copy, s, len);
	  copy[len] = '\0';
	  non_fatal (_("unrecognized section flag `%s'"), copy);
	  fatal (_("supported flags: %s"),
		 "alloc, load, noload, readonly, debug, code, data, rom, share, contents, merge, strings");
	}

      s = snext;
    }
  while (s != NULL);

  return ret;
}

/* Find and optionally add an entry in the change_sections list.

   We need to be careful in how we match section names because of the support
   for wildcard characters.  For example suppose that the user has invoked
   objcopy like this:
         
       --set-section-flags .debug_*=debug
       --set-section-flags .debug_str=readonly,debug
       --change-section-address .debug_*ranges=0x1000

   With the idea that all debug sections will receive the DEBUG flag, the
   .debug_str section will also receive the READONLY flag and the
   .debug_ranges and .debug_aranges sections will have their address set to
   0x1000.  (This may not make much sense, but it is just an example).

   When adding the section name patterns to the section list we need to make
   sure that previous entries do not match with the new entry, unless the
   match is exact.  (In which case we assume that the user is overriding
   the previous entry with the new context).

   When matching real section names to the section list we make use of the
   wildcard characters, but we must do so in context.  Eg if we are setting
   section addresses then we match for .debug_ranges but not for .debug_info.

   Finally, if ADD is false and we do find a match, we mark the section list
   entry as used.  */

static struct section_list *
find_section_list (const char *name, bfd_boolean add, unsigned int context)
{
  struct section_list *p;

  /* assert ((context & ((1 << 7) - 1)) != 0); */
  
  for (p = change_sections; p != NULL; p = p->next)
    {
      if (add)
	{
	  if (strcmp (p->pattern, name) == 0)
	    {
	      /* Check for context conflicts.  */
	      if (((p->context & SECTION_CONTEXT_REMOVE)
		   && (context & SECTION_CONTEXT_COPY))
		  || ((context & SECTION_CONTEXT_REMOVE)
		      && (p->context & SECTION_CONTEXT_COPY)))
		fatal (_("error: %s both copied and removed"), name);

	      if (((p->context & SECTION_CONTEXT_SET_VMA)
		  && (context & SECTION_CONTEXT_ALTER_VMA))
		  || ((context & SECTION_CONTEXT_SET_VMA)
		      && (context & SECTION_CONTEXT_ALTER_VMA)))
		fatal (_("error: %s both sets and alters VMA"), name);

	      if (((p->context & SECTION_CONTEXT_SET_LMA)
		  && (context & SECTION_CONTEXT_ALTER_LMA))
		  || ((context & SECTION_CONTEXT_SET_LMA)
		      && (context & SECTION_CONTEXT_ALTER_LMA)))
		fatal (_("error: %s both sets and alters LMA"), name);

	      /* Extend the context.  */
	      p->context |= context;
	      return p;
	    }
	}
      /* If we are not adding a new name/pattern then
	 only check for a match if the context applies.  */
      else if ((p->context & context)
	       /* We could check for the presence of wildchar characters
		  first and choose between calling strcmp and fnmatch,
		  but is that really worth it ?  */
	       && fnmatch (p->pattern, name, 0) == 0)
	{
	  p->used = TRUE;
	  return p;
	}
    }

  if (! add)
    return NULL;

  p = (struct section_list *) xmalloc (sizeof (struct section_list));
  p->pattern = name;
  p->used = FALSE;
  p->context = context;
  p->vma_val = 0;
  p->lma_val = 0;
  p->flags = 0;
  p->next = change_sections;
  change_sections = p;

  return p;
}

/* There is htab_hash_string but no htab_eq_string. Makes sense.  */

static int
eq_string (const void *s1, const void *s2)
{
  return strcmp ((const char *) s1, (const char *) s2) == 0;
}

static htab_t
create_symbol_htab (void)
{
  return htab_create_alloc (16, htab_hash_string, eq_string, NULL, xcalloc, free);
}

static void
create_symbol_htabs (void)
{
  strip_specific_htab = create_symbol_htab ();
  strip_unneeded_htab = create_symbol_htab ();
  keep_specific_htab = create_symbol_htab ();
  localize_specific_htab = create_symbol_htab ();
  globalize_specific_htab = create_symbol_htab ();
  keepglobal_specific_htab = create_symbol_htab ();
  weaken_specific_htab = create_symbol_htab ();
}

/* Add a symbol to strip_specific_list.  */

static void
add_specific_symbol (const char *name, htab_t htab)
{
  *htab_find_slot (htab, name, INSERT) = (char *) name;
}

/* Add symbols listed in `filename' to strip_specific_list.  */

#define IS_WHITESPACE(c)      ((c) == ' ' || (c) == '\t')
#define IS_LINE_TERMINATOR(c) ((c) == '\n' || (c) == '\r' || (c) == '\0')

static void
add_specific_symbols (const char *filename, htab_t htab)
{
  off_t  size;
  FILE * f;
  char * line;
  char * buffer;
  unsigned int line_count;

  size = get_file_size (filename);
  if (size == 0)
    {
      status = 1;
      return;
    }

  buffer = (char *) xmalloc (size + 2);
  f = fopen (filename, FOPEN_RT);
  if (f == NULL)
    fatal (_("cannot open '%s': %s"), filename, strerror (errno));

  if (fread (buffer, 1, size, f) == 0 || ferror (f))
    fatal (_("%s: fread failed"), filename);

  fclose (f);
  buffer [size] = '\n';
  buffer [size + 1] = '\0';

  line_count = 1;

  for (line = buffer; * line != '\0'; line ++)
    {
      char * eol;
      char * name;
      char * name_end;
      int finished = FALSE;

      for (eol = line;; eol ++)
	{
	  switch (* eol)
	    {
	    case '\n':
	      * eol = '\0';
	      /* Cope with \n\r.  */
	      if (eol[1] == '\r')
		++ eol;
	      finished = TRUE;
	      break;

	    case '\r':
	      * eol = '\0';
	      /* Cope with \r\n.  */
	      if (eol[1] == '\n')
		++ eol;
	      finished = TRUE;
	      break;

	    case 0:
	      finished = TRUE;
	      break;

	    case '#':
	      /* Line comment, Terminate the line here, in case a
		 name is present and then allow the rest of the
		 loop to find the real end of the line.  */
	      * eol = '\0';
	      break;

	    default:
	      break;
	    }

	  if (finished)
	    break;
	}

      /* A name may now exist somewhere between 'line' and 'eol'.
	 Strip off leading whitespace and trailing whitespace,
	 then add it to the list.  */
      for (name = line; IS_WHITESPACE (* name); name ++)
	;
      for (name_end = name;
	   (! IS_WHITESPACE (* name_end))
	   && (! IS_LINE_TERMINATOR (* name_end));
	   name_end ++)
	;

      if (! IS_LINE_TERMINATOR (* name_end))
	{
	  char * extra;

	  for (extra = name_end + 1; IS_WHITESPACE (* extra); extra ++)
	    ;

	  if (! IS_LINE_TERMINATOR (* extra))
	    non_fatal (_("%s:%d: Ignoring rubbish found on this line"),
		       filename, line_count);
	}

      * name_end = '\0';

      if (name_end > name)
	add_specific_symbol (name, htab);

      /* Advance line pointer to end of line.  The 'eol ++' in the for
	 loop above will then advance us to the start of the next line.  */
      line = eol;
      line_count ++;
    }
}

/* See whether a symbol should be stripped or kept
   based on strip_specific_list and keep_symbols.  */

static int
is_specified_symbol_predicate (void **slot, void *data)
{
  struct is_specified_symbol_predicate_data *d =
      (struct is_specified_symbol_predicate_data *) data;
  const char *slot_name = (char *) *slot;

  if (*slot_name != '!')
    {
      if (! fnmatch (slot_name, d->name, 0))
	{
	  d->found = TRUE;
	  /* Stop traversal.  */
	  return 0;
	}
    }
  else
    {
      if (fnmatch (slot_name + 1, d->name, 0))
	{
	  d->found = TRUE;
	  /* Stop traversal.  */
	  return 0;
	}
    }

  /* Continue traversal.  */
  return 1;
}

static bfd_boolean
is_specified_symbol (const char *name, htab_t htab)
{
  if (wildcard)
    {
      struct is_specified_symbol_predicate_data data;

      data.name = name;
      data.found = FALSE;

      htab_traverse (htab, is_specified_symbol_predicate, &data);

      return data.found;
    }

  return htab_find (htab, name) != NULL;
}

/* Return a pointer to the symbol used as a signature for GROUP.  */

static asymbol *
group_signature (asection *group)
{
  bfd *abfd = group->owner;
  Elf_Internal_Shdr *ghdr;

  if (bfd_get_flavour (abfd) != bfd_target_elf_flavour)
    return NULL;

  ghdr = &elf_section_data (group)->this_hdr;
  if (ghdr->sh_link < elf_numsections (abfd))
    {
      const struct elf_backend_data *bed = get_elf_backend_data (abfd);
      Elf_Internal_Shdr *symhdr = elf_elfsections (abfd) [ghdr->sh_link];

      if (symhdr->sh_type == SHT_SYMTAB
	  && ghdr->sh_info < symhdr->sh_size / bed->s->sizeof_sym)
	return isympp[ghdr->sh_info - 1];
    }
  return NULL;
}

/* Return TRUE if the section is a DWO section.  */

static bfd_boolean
is_dwo_section (bfd *abfd ATTRIBUTE_UNUSED, asection *sec)
{
  const char *name = bfd_get_section_name (abfd, sec);
  int len = strlen (name);

  return strncmp (name + len - 4, ".dwo", 4) == 0;
}

/* See if a non-group section is being removed.  */

static bfd_boolean
is_strip_section_1 (bfd *abfd ATTRIBUTE_UNUSED, asection *sec)
{
  if (sections_removed || sections_copied)
    {
      struct section_list *p;
      struct section_list *q;

      p = find_section_list (bfd_get_section_name (abfd, sec), FALSE,
			     SECTION_CONTEXT_REMOVE);
      q = find_section_list (bfd_get_section_name (abfd, sec), FALSE,
			     SECTION_CONTEXT_COPY);

      if (p && q)
	fatal (_("error: section %s matches both remove and copy options"),
	       bfd_get_section_name (abfd, sec));

      if (p != NULL)
	return TRUE;
      if (sections_copied && q == NULL)
	return TRUE;
    }

  if ((bfd_get_section_flags (abfd, sec) & SEC_DEBUGGING) != 0)
    {
      if (strip_symbols == STRIP_DEBUG
	  || strip_symbols == STRIP_UNNEEDED
	  || strip_symbols == STRIP_ALL
	  || discard_locals == LOCALS_ALL
	  || convert_debugging)
	{
	  /* By default we don't want to strip .reloc section.
	     This section has for pe-coff special meaning.   See
	     pe-dll.c file in ld, and peXXigen.c in bfd for details.  */
	  if (strcmp (bfd_get_section_name (abfd, sec), ".reloc") != 0)
	    return TRUE;
	}

      if (strip_symbols == STRIP_DWO)
	return is_dwo_section (abfd, sec);

      if (strip_symbols == STRIP_NONDEBUG)
	return FALSE;
    }

  if (strip_symbols == STRIP_NONDWO)
    return !is_dwo_section (abfd, sec);

  return FALSE;
}

/* See if a section is being removed.  */

static bfd_boolean
is_strip_section (bfd *abfd ATTRIBUTE_UNUSED, asection *sec)
{
  if (is_strip_section_1 (abfd, sec))
    return TRUE;

  if ((bfd_get_section_flags (abfd, sec) & SEC_GROUP) != 0)
    {
      asymbol *gsym;
      const char *gname;
      asection *elt, *first;

      /* PR binutils/3181
	 If we are going to strip the group signature symbol, then
	 strip the group section too.  */
      gsym = group_signature (sec);
      if (gsym != NULL)
	gname = gsym->name;
      else
	gname = sec->name;
      if ((strip_symbols == STRIP_ALL
	   && !is_specified_symbol (gname, keep_specific_htab))
	  || is_specified_symbol (gname, strip_specific_htab))
	return TRUE;

      /* Remove the group section if all members are removed.  */
      first = elt = elf_next_in_group (sec);
      while (elt != NULL)
	{
	  if (!is_strip_section_1 (abfd, elt))
	    return FALSE;
	  elt = elf_next_in_group (elt);
	  if (elt == first)
	    break;
	}

      return TRUE;
    }

  return FALSE;
}

/* Return true if SYM is a hidden symbol.  */

static bfd_boolean
is_hidden_symbol (asymbol *sym)
{
  elf_symbol_type *elf_sym;

  elf_sym = elf_symbol_from (sym->the_bfd, sym);
  if (elf_sym != NULL)
    switch (ELF_ST_VISIBILITY (elf_sym->internal_elf_sym.st_other))
      {
      case STV_HIDDEN:
      case STV_INTERNAL:
	return TRUE;
      }
  return FALSE;
}

/* Choose which symbol entries to copy; put the result in OSYMS.
   We don't copy in place, because that confuses the relocs.
   Return the number of symbols to print.  */

static unsigned int
filter_symbols (bfd *abfd, bfd *obfd, asymbol **osyms,
		asymbol **isyms, long symcount)
{
  asymbol **from = isyms, **to = osyms;
  long src_count = 0, dst_count = 0;
  int relocatable = (abfd->flags & (EXEC_P | DYNAMIC)) == 0;

  for (; src_count < symcount; src_count++)
    {
      asymbol *sym = from[src_count];
      flagword flags = sym->flags;
      char *name = (char *) bfd_asymbol_name (sym);
      bfd_boolean keep;
      bfd_boolean used_in_reloc = FALSE;
      bfd_boolean undefined;
      bfd_boolean rem_leading_char;
      bfd_boolean add_leading_char;

      undefined = bfd_is_und_section (bfd_get_section (sym));

      if (redefine_sym_list)
	{
	  char *old_name, *new_name;

	  old_name = (char *) bfd_asymbol_name (sym);
	  new_name = (char *) lookup_sym_redefinition (old_name);
	  bfd_asymbol_name (sym) = new_name;
	  name = new_name;
	}

      /* Check if we will remove the current leading character.  */
      rem_leading_char =
	(name[0] == bfd_get_symbol_leading_char (abfd))
	&& (change_leading_char
	    || (remove_leading_char
		&& ((flags & (BSF_GLOBAL | BSF_WEAK)) != 0
		    || undefined
		    || bfd_is_com_section (bfd_get_section (sym)))));

      /* Check if we will add a new leading character.  */
      add_leading_char =
	change_leading_char
	&& (bfd_get_symbol_leading_char (obfd) != '\0')
	&& (bfd_get_symbol_leading_char (abfd) == '\0'
	    || (name[0] == bfd_get_symbol_leading_char (abfd)));

      /* Short circuit for change_leading_char if we can do it in-place.  */
      if (rem_leading_char && add_leading_char && !prefix_symbols_string)
        {
	  name[0] = bfd_get_symbol_leading_char (obfd);
	  bfd_asymbol_name (sym) = name;
	  rem_leading_char = FALSE;
	  add_leading_char = FALSE;
        }

      /* Remove leading char.  */
      if (rem_leading_char)
	bfd_asymbol_name (sym) = ++name;

      /* Add new leading char and/or prefix.  */
      if (add_leading_char || prefix_symbols_string)
        {
          char *n, *ptr;

          ptr = n = (char *) xmalloc (1 + strlen (prefix_symbols_string)
                                      + strlen (name) + 1);
          if (add_leading_char)
	    *ptr++ = bfd_get_symbol_leading_char (obfd);

          if (prefix_symbols_string)
            {
              strcpy (ptr, prefix_symbols_string);
              ptr += strlen (prefix_symbols_string);
           }

          strcpy (ptr, name);
          bfd_asymbol_name (sym) = n;
          name = n;
	}

      if (strip_symbols == STRIP_ALL)
	keep = FALSE;
      else if ((flags & BSF_KEEP) != 0		/* Used in relocation.  */
	       || ((flags & BSF_SECTION_SYM) != 0
		   && ((*bfd_get_section (sym)->symbol_ptr_ptr)->flags
		       & BSF_KEEP) != 0))
	{
	  keep = TRUE;
	  used_in_reloc = TRUE;
	}
      else if (relocatable			/* Relocatable file.  */
	       && ((flags & (BSF_GLOBAL | BSF_WEAK)) != 0
		   || bfd_is_com_section (bfd_get_section (sym))))
	keep = TRUE;
      else if (bfd_decode_symclass (sym) == 'I')
	/* Global symbols in $idata sections need to be retained
	   even if relocatable is FALSE.  External users of the
	   library containing the $idata section may reference these
	   symbols.  */
	keep = TRUE;
      else if ((flags & BSF_GLOBAL) != 0	/* Global symbol.  */
	       || (flags & BSF_WEAK) != 0
	       || undefined
	       || bfd_is_com_section (bfd_get_section (sym)))
	keep = strip_symbols != STRIP_UNNEEDED;
      else if ((flags & BSF_DEBUGGING) != 0)	/* Debugging symbol.  */
	keep = (strip_symbols != STRIP_DEBUG
		&& strip_symbols != STRIP_UNNEEDED
		&& ! convert_debugging);
      else if (bfd_coff_get_comdat_section (abfd, bfd_get_section (sym)))
	/* COMDAT sections store special information in local
	   symbols, so we cannot risk stripping any of them.  */
	keep = TRUE;
      else			/* Local symbol.  */
	keep = (strip_symbols != STRIP_UNNEEDED
		&& (discard_locals != LOCALS_ALL
		    && (discard_locals != LOCALS_START_L
			|| ! bfd_is_local_label (abfd, sym))));

      if (keep && is_specified_symbol (name, strip_specific_htab))
	{
	  /* There are multiple ways to set 'keep' above, but if it
	     was the relocatable symbol case, then that's an error.  */
	  if (used_in_reloc)
	    {
	      non_fatal (_("not stripping symbol `%s' because it is named in a relocation"), name);
	      status = 1;
	    }
	  else
	    keep = FALSE;
	}

      if (keep
	  && !(flags & BSF_KEEP)
	  && is_specified_symbol (name, strip_unneeded_htab))
	keep = FALSE;

      if (!keep
	  && ((keep_file_symbols && (flags & BSF_FILE))
	      || is_specified_symbol (name, keep_specific_htab)))
	keep = TRUE;

      if (keep && is_strip_section (abfd, bfd_get_section (sym)))
	keep = FALSE;

      if (keep)
	{
	  if ((flags & BSF_GLOBAL) != 0
	      && (weaken || is_specified_symbol (name, weaken_specific_htab)))
	    {
	      sym->flags &= ~ BSF_GLOBAL;
	      sym->flags |= BSF_WEAK;
	    }

	  if (!undefined
	      && (flags & (BSF_GLOBAL | BSF_WEAK))
	      && (is_specified_symbol (name, localize_specific_htab)
		  || (htab_elements (keepglobal_specific_htab) != 0
		      && ! is_specified_symbol (name, keepglobal_specific_htab))
		  || (localize_hidden && is_hidden_symbol (sym))))
	    {
	      sym->flags &= ~ (BSF_GLOBAL | BSF_WEAK);
	      sym->flags |= BSF_LOCAL;
	    }

	  if (!undefined
	      && (flags & BSF_LOCAL)
	      && is_specified_symbol (name, globalize_specific_htab))
	    {
	      sym->flags &= ~ BSF_LOCAL;
	      sym->flags |= BSF_GLOBAL;
	    }

	  to[dst_count++] = sym;
	}
    }

  to[dst_count] = NULL;

  return dst_count;
}

/* Find the redefined name of symbol SOURCE.  */

static const char *
lookup_sym_redefinition (const char *source)
{
  struct redefine_node *list;

  for (list = redefine_sym_list; list != NULL; list = list->next)
    if (strcmp (source, list->source) == 0)
      return list->target;

  return source;
}

/* Add a node to a symbol redefine list.  */

static void
redefine_list_append (const char *cause, const char *source, const char *target)
{
  struct redefine_node **p;
  struct redefine_node *list;
  struct redefine_node *new_node;

  for (p = &redefine_sym_list; (list = *p) != NULL; p = &list->next)
    {
      if (strcmp (source, list->source) == 0)
	fatal (_("%s: Multiple redefinition of symbol \"%s\""),
	       cause, source);

      if (strcmp (target, list->target) == 0)
	fatal (_("%s: Symbol \"%s\" is target of more than one redefinition"),
	       cause, target);
    }

  new_node = (struct redefine_node *) xmalloc (sizeof (struct redefine_node));

  new_node->source = strdup (source);
  new_node->target = strdup (target);
  new_node->next = NULL;

  *p = new_node;
}

/* Handle the --redefine-syms option.  Read lines containing "old new"
   from the file, and add them to the symbol redefine list.  */

static void
add_redefine_syms_file (const char *filename)
{
  FILE *file;
  char *buf;
  size_t bufsize;
  size_t len;
  size_t outsym_off;
  int c, lineno;

  file = fopen (filename, "r");
  if (file == NULL)
    fatal (_("couldn't open symbol redefinition file %s (error: %s)"),
	   filename, strerror (errno));

  bufsize = 100;
  buf = (char *) xmalloc (bufsize + 1 /* For the terminating NUL.  */);

  lineno = 1;
  c = getc (file);
  len = 0;
  outsym_off = 0;
  while (c != EOF)
    {
      /* Collect the input symbol name.  */
      while (! IS_WHITESPACE (c) && ! IS_LINE_TERMINATOR (c) && c != EOF)
	{
	  if (c == '#')
	    goto comment;
	  buf[len++] = c;
	  if (len >= bufsize)
	    {
	      bufsize *= 2;
	      buf = (char *) xrealloc (buf, bufsize + 1);
	    }
	  c = getc (file);
	}
      buf[len++] = '\0';
      if (c == EOF)
	break;

      /* Eat white space between the symbol names.  */
      while (IS_WHITESPACE (c))
	c = getc (file);
      if (c == '#' || IS_LINE_TERMINATOR (c))
	goto comment;
      if (c == EOF)
	break;

      /* Collect the output symbol name.  */
      outsym_off = len;
      while (! IS_WHITESPACE (c) && ! IS_LINE_TERMINATOR (c) && c != EOF)
	{
	  if (c == '#')
	    goto comment;
	  buf[len++] = c;
	  if (len >= bufsize)
	    {
	      bufsize *= 2;
	      buf = (char *) xrealloc (buf, bufsize + 1);
	    }
	  c = getc (file);
	}
      buf[len++] = '\0';
      if (c == EOF)
	break;

      /* Eat white space at end of line.  */
      while (! IS_LINE_TERMINATOR(c) && c != EOF && IS_WHITESPACE (c))
	c = getc (file);
      if (c == '#')
	goto comment;
      /* Handle \r\n.  */
      if ((c == '\r' && (c = getc (file)) == '\n')
	  || c == '\n' || c == EOF)
	{
 end_of_line:
	  /* Append the redefinition to the list.  */
	  if (buf[0] != '\0')
	    redefine_list_append (filename, &buf[0], &buf[outsym_off]);

	  lineno++;
	  len = 0;
	  outsym_off = 0;
	  if (c == EOF)
	    break;
	  c = getc (file);
	  continue;
	}
      else
	fatal (_("%s:%d: garbage found at end of line"), filename, lineno);
 comment:
      if (len != 0 && (outsym_off == 0 || outsym_off == len))
	fatal (_("%s:%d: missing new symbol name"), filename, lineno);
      buf[len++] = '\0';

      /* Eat the rest of the line and finish it.  */
      while (c != '\n' && c != EOF)
	c = getc (file);
      goto end_of_line;
    }

  if (len != 0)
    fatal (_("%s:%d: premature end of file"), filename, lineno);

  free (buf);
}

/* Copy unkown object file IBFD onto OBFD.
   Returns TRUE upon success, FALSE otherwise.  */

static bfd_boolean
copy_unknown_object (bfd *ibfd, bfd *obfd)
{
  char *cbuf;
  int tocopy;
  long ncopied;
  long size;
  struct stat buf;

  if (bfd_stat_arch_elt (ibfd, &buf) != 0)
    {
      bfd_nonfatal_message (NULL, ibfd, NULL, NULL);
      return FALSE;
    }

  size = buf.st_size;
  if (size < 0)
    {
      non_fatal (_("stat returns negative size for `%s'"),
		 bfd_get_archive_filename (ibfd));
      return FALSE;
    }

  if (bfd_seek (ibfd, (file_ptr) 0, SEEK_SET) != 0)
    {
      bfd_nonfatal (bfd_get_archive_filename (ibfd));
      return FALSE;
    }

  if (verbose)
    printf (_("copy from `%s' [unknown] to `%s' [unknown]\n"),
	    bfd_get_archive_filename (ibfd), bfd_get_filename (obfd));

  cbuf = (char *) xmalloc (BUFSIZE);
  ncopied = 0;
  while (ncopied < size)
    {
      tocopy = size - ncopied;
      if (tocopy > BUFSIZE)
	tocopy = BUFSIZE;

      if (bfd_bread (cbuf, (bfd_size_type) tocopy, ibfd)
	  != (bfd_size_type) tocopy)
	{
	  bfd_nonfatal_message (NULL, ibfd, NULL, NULL);
	  free (cbuf);
	  return FALSE;
	}

      if (bfd_bwrite (cbuf, (bfd_size_type) tocopy, obfd)
	  != (bfd_size_type) tocopy)
	{
	  bfd_nonfatal_message (NULL, obfd, NULL, NULL);
	  free (cbuf);
	  return FALSE;
	}

      ncopied += tocopy;
    }

  /* We should at least to be able to read it back when copying an
     unknown object in an archive.  */
  chmod (bfd_get_filename (obfd), buf.st_mode | S_IRUSR);
  free (cbuf);
  return TRUE;
}

/* Copy object file IBFD onto OBFD.
   Returns TRUE upon success, FALSE otherwise.  */

static bfd_boolean
copy_object (bfd *ibfd, bfd *obfd, const bfd_arch_info_type *input_arch)
{
  bfd_vma start;
  long symcount;
  asection **osections = NULL;
  asection *gnu_debuglink_section = NULL;
  bfd_size_type *gaps = NULL;
  bfd_size_type max_gap = 0;
  long symsize;
  void *dhandle;
  enum bfd_architecture iarch;
  unsigned int imach;

  if (ibfd->xvec->byteorder != obfd->xvec->byteorder
      && ibfd->xvec->byteorder != BFD_ENDIAN_UNKNOWN
      && obfd->xvec->byteorder != BFD_ENDIAN_UNKNOWN)
    fatal (_("Unable to change endianness of input file(s)"));

  if (!bfd_set_format (obfd, bfd_get_format (ibfd)))
    {
      bfd_nonfatal_message (NULL, obfd, NULL, NULL);
      return FALSE;
    }

  if (verbose)
    printf (_("copy from `%s' [%s] to `%s' [%s]\n"),
	    bfd_get_archive_filename (ibfd), bfd_get_target (ibfd),
	    bfd_get_filename (obfd), bfd_get_target (obfd));

  if (extract_symbol)
    start = 0;
  else
    {
      if (set_start_set)
	start = set_start;
      else
	start = bfd_get_start_address (ibfd);
      start += change_start;
    }

  /* Neither the start address nor the flags
     need to be set for a core file.  */
  if (bfd_get_format (obfd) != bfd_core)
    {
      flagword flags;

      flags = bfd_get_file_flags (ibfd);
      flags |= bfd_flags_to_set;
      flags &= ~bfd_flags_to_clear;
      flags &= bfd_applicable_file_flags (obfd);

      if (strip_symbols == STRIP_ALL)
	flags &= ~HAS_RELOC;

      if (!bfd_set_start_address (obfd, start)
	  || !bfd_set_file_flags (obfd, flags))
	{
	  bfd_nonfatal_message (NULL, ibfd, NULL, NULL);
	  return FALSE;
	}
    }

  /* Copy architecture of input file to output file.  */
  iarch = bfd_get_arch (ibfd);
  imach = bfd_get_mach (ibfd);
  if (input_arch)
    {
      if (bfd_get_arch_info (ibfd) == NULL
	  || bfd_get_arch_info (ibfd)->arch == bfd_arch_unknown)
	{
	  iarch = input_arch->arch;
	  imach = input_arch->mach;
	}
      else
	non_fatal (_("Input file `%s' ignores binary architecture parameter."),
		   bfd_get_archive_filename (ibfd));
    }
  if (!bfd_set_arch_mach (obfd, iarch, imach)
      && (ibfd->target_defaulted
	  || bfd_get_arch (ibfd) != bfd_get_arch (obfd)))
    {
      if (bfd_get_arch (ibfd) == bfd_arch_unknown)
	non_fatal (_("Unable to recognise the format of the input file `%s'"),
		   bfd_get_archive_filename (ibfd));
      else
	non_fatal (_("Output file cannot represent architecture `%s'"),
		   bfd_printable_arch_mach (bfd_get_arch (ibfd),
					    bfd_get_mach (ibfd)));
      return FALSE;
    }

  if (!bfd_set_format (obfd, bfd_get_format (ibfd)))
    {
      bfd_nonfatal_message (NULL, ibfd, NULL, NULL);
      return FALSE;
    }

  if (bfd_get_flavour (obfd) == bfd_target_coff_flavour
      && bfd_pei_p (obfd))
    {
      /* Set up PE parameters.  */
      pe_data_type *pe = pe_data (obfd);

      /* Copy PE parameters before changing them.  */
      if (ibfd->xvec->flavour == bfd_target_coff_flavour
	  && bfd_pei_p (ibfd))
	pe->pe_opthdr = pe_data (ibfd)->pe_opthdr;

      if (pe_file_alignment != (bfd_vma) -1)
	pe->pe_opthdr.FileAlignment = pe_file_alignment;
      else
	pe_file_alignment = PE_DEF_FILE_ALIGNMENT;

      if (pe_heap_commit != (bfd_vma) -1)
	pe->pe_opthdr.SizeOfHeapCommit = pe_heap_commit;

      if (pe_heap_reserve != (bfd_vma) -1)
	pe->pe_opthdr.SizeOfHeapCommit = pe_heap_reserve;

      if (pe_image_base != (bfd_vma) -1)
	pe->pe_opthdr.ImageBase = pe_image_base;

      if (pe_section_alignment != (bfd_vma) -1)
	pe->pe_opthdr.SectionAlignment = pe_section_alignment;
      else
	pe_section_alignment = PE_DEF_SECTION_ALIGNMENT;

      if (pe_stack_commit != (bfd_vma) -1)
	pe->pe_opthdr.SizeOfStackCommit = pe_stack_commit;

      if (pe_stack_reserve != (bfd_vma) -1)
	pe->pe_opthdr.SizeOfStackCommit = pe_stack_reserve;

      if (pe_subsystem != -1)
	pe->pe_opthdr.Subsystem = pe_subsystem;

      if (pe_major_subsystem_version != -1)
	pe->pe_opthdr.MajorSubsystemVersion = pe_major_subsystem_version;

      if (pe_minor_subsystem_version != -1)
	pe->pe_opthdr.MinorSubsystemVersion = pe_minor_subsystem_version;

      if (pe_file_alignment > pe_section_alignment)
	{
	  char file_alignment[20], section_alignment[20];

	  sprintf_vma (file_alignment, pe_file_alignment);
	  sprintf_vma (section_alignment, pe_section_alignment);
	  non_fatal (_("warning: file alignment (0x%s) > section alignment (0x%s)"),

		     file_alignment, section_alignment);
	}
    }

  if (isympp)
    free (isympp);

  if (osympp != isympp)
    free (osympp);

  isympp = NULL;
  osympp = NULL;

  symsize = bfd_get_symtab_upper_bound (ibfd);
  if (symsize < 0)
    {
      bfd_nonfatal_message (NULL, ibfd, NULL, NULL);
      return FALSE;
    }

  osympp = isympp = (asymbol **) xmalloc (symsize);
  symcount = bfd_canonicalize_symtab (ibfd, isympp);
  if (symcount < 0)
    {
      bfd_nonfatal_message (NULL, ibfd, NULL, NULL);
      return FALSE;
    }

  /* BFD mandates that all output sections be created and sizes set before
     any output is done.  Thus, we traverse all sections multiple times.  */
  bfd_map_over_sections (ibfd, setup_section, obfd);

  if (!extract_symbol)
    setup_bfd_headers (ibfd, obfd);

  if (add_sections != NULL)
    {
      struct section_add *padd;
      struct section_list *pset;

      for (padd = add_sections; padd != NULL; padd = padd->next)
	{
	  flagword flags;

	  pset = find_section_list (padd->name, FALSE,
				    SECTION_CONTEXT_SET_FLAGS);
	  if (pset != NULL)
	    flags = pset->flags | SEC_HAS_CONTENTS;
	  else
	    flags = SEC_HAS_CONTENTS | SEC_READONLY | SEC_DATA;

	  /* bfd_make_section_with_flags() does not return very helpful
	     error codes, so check for the most likely user error first.  */
	  if (bfd_get_section_by_name (obfd, padd->name))
	    {
	      bfd_nonfatal_message (NULL, obfd, NULL,
				 _("can't add section '%s'"), padd->name);
	      return FALSE;
	    }
	  else
	    {
	      /* We use LINKER_CREATED here so that the backend hooks
	         will create any special section type information,
	         instead of presuming we know what we're doing merely
	         because we set the flags.  */
	      padd->section = bfd_make_section_with_flags
		(obfd, padd->name, flags | SEC_LINKER_CREATED);
	      if (padd->section == NULL)
		{
		  bfd_nonfatal_message (NULL, obfd, NULL,
					_("can't create section `%s'"),
					padd->name);
		  return FALSE;
		}
	    }

	  if (! bfd_set_section_size (obfd, padd->section, padd->size))
	    {
	      bfd_nonfatal_message (NULL, obfd, padd->section, NULL);
	      return FALSE;
	    }

	  pset = find_section_list (padd->name, FALSE,
				    SECTION_CONTEXT_SET_VMA | SECTION_CONTEXT_ALTER_VMA);
	  if (pset != NULL
	      && ! bfd_set_section_vma (obfd, padd->section, pset->vma_val))
	    {
	      bfd_nonfatal_message (NULL, obfd, padd->section, NULL);
	      return FALSE;
	    }

	  pset = find_section_list (padd->name, FALSE,
				    SECTION_CONTEXT_SET_LMA | SECTION_CONTEXT_ALTER_LMA);
	  if (pset != NULL)
	    {
	      padd->section->lma = pset->lma_val;

	      if (! bfd_set_section_alignment
		  (obfd, padd->section,
		   bfd_section_alignment (obfd, padd->section)))
		{
		  bfd_nonfatal_message (NULL, obfd, padd->section, NULL);
		  return FALSE;
		}
	    }
	}
    }

  if (gnu_debuglink_filename != NULL)
    {
      /* PR 15125: Give a helpful warning message if
	 the debuglink section already exists, and
	 allow the rest of the copy to complete.  */
      if (bfd_get_section_by_name (obfd, ".gnu_debuglink"))
	{
	  non_fatal (_("%s: debuglink section already exists"),
		     bfd_get_filename (obfd));
	  gnu_debuglink_filename = NULL;
	}
      else
	{
	  gnu_debuglink_section = bfd_create_gnu_debuglink_section
	    (obfd, gnu_debuglink_filename);

	  if (gnu_debuglink_section == NULL)
	    {
	      bfd_nonfatal_message (NULL, obfd, NULL,
				    _("cannot create debug link section `%s'"),
				    gnu_debuglink_filename);
	      return FALSE;
	    }

	  /* Special processing for PE format files.  We
	     have no way to distinguish PE from COFF here.  */
	  if (bfd_get_flavour (obfd) == bfd_target_coff_flavour)
	    {
	      bfd_vma debuglink_vma;
	      asection * highest_section;
	      asection * sec;

	      /* The PE spec requires that all sections be adjacent and sorted
		 in ascending order of VMA.  It also specifies that debug
		 sections should be last.  This is despite the fact that debug
		 sections are not loaded into memory and so in theory have no
		 use for a VMA.

		 This means that the debuglink section must be given a non-zero
		 VMA which makes it contiguous with other debug sections.  So
		 walk the current section list, find the section with the
		 highest VMA and start the debuglink section after that one.  */
	      for (sec = obfd->sections, highest_section = NULL;
		   sec != NULL;
		   sec = sec->next)
		if (sec->vma > 0
		    && (highest_section == NULL
			|| sec->vma > highest_section->vma))
		  highest_section = sec;

	      if (highest_section)
		debuglink_vma = BFD_ALIGN (highest_section->vma
					   + highest_section->size,
					   /* FIXME: We ought to be using
					      COFF_PAGE_SIZE here or maybe
					      bfd_get_section_alignment() (if it
					      was set) but since this is for PE
					      and we know the required alignment
					      it is easier just to hard code it.  */
					   0x1000);
	      else
		/* Umm, not sure what to do in this case.  */
		debuglink_vma = 0x1000;

	      bfd_set_section_vma (obfd, gnu_debuglink_section, debuglink_vma);
	    }
	}
    }

  if (bfd_count_sections (obfd) != 0
      && (gap_fill_set || pad_to_set))
    {
      asection **set;
      unsigned int c, i;

      /* We must fill in gaps between the sections and/or we must pad
	 the last section to a specified address.  We do this by
	 grabbing a list of the sections, sorting them by VMA, and
	 increasing the section sizes as required to fill the gaps.
	 We write out the gap contents below.  */

      c = bfd_count_sections (obfd);
      osections = (asection **) xmalloc (c * sizeof (asection *));
      set = osections;
      bfd_map_over_sections (obfd, get_sections, &set);

      qsort (osections, c, sizeof (asection *), compare_section_lma);

      gaps = (bfd_size_type *) xmalloc (c * sizeof (bfd_size_type));
      memset (gaps, 0, c * sizeof (bfd_size_type));

      if (gap_fill_set)
	{
	  for (i = 0; i < c - 1; i++)
	    {
	      flagword flags;
	      bfd_size_type size;
	      bfd_vma gap_start, gap_stop;

	      flags = bfd_get_section_flags (obfd, osections[i]);
	      if ((flags & SEC_HAS_CONTENTS) == 0
		  || (flags & SEC_LOAD) == 0)
		continue;

	      size = bfd_section_size (obfd, osections[i]);
	      gap_start = bfd_section_lma (obfd, osections[i]) + size;
	      gap_stop = bfd_section_lma (obfd, osections[i + 1]);
	      if (gap_start < gap_stop)
		{
		  if (! bfd_set_section_size (obfd, osections[i],
					      size + (gap_stop - gap_start)))
		    {
		      bfd_nonfatal_message (NULL, obfd, osections[i],
					    _("Can't fill gap after section"));
		      status = 1;
		      break;
		    }
		  gaps[i] = gap_stop - gap_start;
		  if (max_gap < gap_stop - gap_start)
		    max_gap = gap_stop - gap_start;
		}
	    }
	}

      if (pad_to_set)
	{
	  bfd_vma lma;
	  bfd_size_type size;

	  lma = bfd_section_lma (obfd, osections[c - 1]);
	  size = bfd_section_size (obfd, osections[c - 1]);
	  if (lma + size < pad_to)
	    {
	      if (! bfd_set_section_size (obfd, osections[c - 1],
					  pad_to - lma))
		{
		  bfd_nonfatal_message (NULL, obfd, osections[c - 1],
					_("can't add padding"));
		  status = 1;
		}
	      else
		{
		  gaps[c - 1] = pad_to - (lma + size);
		  if (max_gap < pad_to - (lma + size))
		    max_gap = pad_to - (lma + size);
		}
	    }
	}
    }

  /* Symbol filtering must happen after the output sections
     have been created, but before their contents are set.  */
  dhandle = NULL;
  if (convert_debugging)
    dhandle = read_debugging_info (ibfd, isympp, symcount, FALSE);

  if (strip_symbols == STRIP_DEBUG
      || strip_symbols == STRIP_ALL
      || strip_symbols == STRIP_UNNEEDED
      || strip_symbols == STRIP_NONDEBUG
      || strip_symbols == STRIP_DWO
      || strip_symbols == STRIP_NONDWO
      || discard_locals != LOCALS_UNDEF
      || localize_hidden
      || htab_elements (strip_specific_htab) != 0
      || htab_elements (keep_specific_htab) != 0
      || htab_elements (localize_specific_htab) != 0
      || htab_elements (globalize_specific_htab) != 0
      || htab_elements (keepglobal_specific_htab) != 0
      || htab_elements (weaken_specific_htab) != 0
      || prefix_symbols_string
      || sections_removed
      || sections_copied
      || convert_debugging
      || change_leading_char
      || remove_leading_char
      || redefine_sym_list
      || weaken)
    {
      /* Mark symbols used in output relocations so that they
	 are kept, even if they are local labels or static symbols.

	 Note we iterate over the input sections examining their
	 relocations since the relocations for the output sections
	 haven't been set yet.  mark_symbols_used_in_relocations will
	 ignore input sections which have no corresponding output
	 section.  */
      if (strip_symbols != STRIP_ALL)
	bfd_map_over_sections (ibfd,
			       mark_symbols_used_in_relocations,
			       isympp);
      osympp = (asymbol **) xmalloc ((symcount + 1) * sizeof (asymbol *));
      symcount = filter_symbols (ibfd, obfd, osympp, isympp, symcount);
    }

  if (convert_debugging && dhandle != NULL)
    {
      if (! write_debugging_info (obfd, dhandle, &symcount, &osympp))
	{
	  status = 1;
	  return FALSE;
	}
    }

  bfd_set_symtab (obfd, osympp, symcount);

  /* This has to happen before section positions are set.  */
  bfd_map_over_sections (ibfd, copy_relocations_in_section, obfd);

  /* This has to happen after the symbol table has been set.  */
  bfd_map_over_sections (ibfd, copy_section, obfd);

  if (add_sections != NULL)
    {
      struct section_add *padd;

      for (padd = add_sections; padd != NULL; padd = padd->next)
	{
	  if (! bfd_set_section_contents (obfd, padd->section, padd->contents,
					  0, padd->size))
	    {
	      bfd_nonfatal_message (NULL, obfd, padd->section, NULL);
	      return FALSE;
	    }
	}
    }

  if (gnu_debuglink_filename != NULL)
    {
      if (! bfd_fill_in_gnu_debuglink_section
	  (obfd, gnu_debuglink_section, gnu_debuglink_filename))
	{
	  bfd_nonfatal_message (NULL, obfd, NULL,
				_("cannot fill debug link section `%s'"),
				gnu_debuglink_filename);
	  return FALSE;
	}
    }

  if (gap_fill_set || pad_to_set)
    {
      bfd_byte *buf;
      int c, i;

      /* Fill in the gaps.  */
      if (max_gap > 8192)
	max_gap = 8192;
      buf = (bfd_byte *) xmalloc (max_gap);
      memset (buf, gap_fill, max_gap);

      c = bfd_count_sections (obfd);
      for (i = 0; i < c; i++)
	{
	  if (gaps[i] != 0)
	    {
	      bfd_size_type left;
	      file_ptr off;

	      left = gaps[i];
	      off = bfd_section_size (obfd, osections[i]) - left;

	      while (left > 0)
		{
		  bfd_size_type now;

		  if (left > 8192)
		    now = 8192;
		  else
		    now = left;

		  if (! bfd_set_section_contents (obfd, osections[i], buf,
						  off, now))
		    {
		      bfd_nonfatal_message (NULL, obfd, osections[i], NULL);
		      return FALSE;
		    }

		  left -= now;
		  off += now;
		}
	    }
	}
    }

  /* Do not copy backend data if --extract-symbol is passed; anything
     that needs to look at the section contents will fail.  */
  if (extract_symbol)
    return TRUE;

  /* Allow the BFD backend to copy any private data it understands
     from the input BFD to the output BFD.  This is done last to
     permit the routine to look at the filtered symbol table, which is
     important for the ECOFF code at least.  */
  if (! bfd_copy_private_bfd_data (ibfd, obfd))
    {
      bfd_nonfatal_message (NULL, obfd, NULL,
			    _("error copying private BFD data"));
      return FALSE;
    }

  /* Switch to the alternate machine code.  We have to do this at the
     very end, because we only initialize the header when we create
     the first section.  */
  if (use_alt_mach_code != 0)
    {
      if (! bfd_alt_mach_code (obfd, use_alt_mach_code))
	{
	  non_fatal (_("this target does not support %lu alternative machine codes"),
		     use_alt_mach_code);
	  if (bfd_get_flavour (obfd) == bfd_target_elf_flavour)
	    {
	      non_fatal (_("treating that number as an absolute e_machine value instead"));
	      elf_elfheader (obfd)->e_machine = use_alt_mach_code;
	    }
	  else
	    non_fatal (_("ignoring the alternative value"));
	}
    }

  return TRUE;
}

/* Read each archive element in turn from IBFD, copy the
   contents to temp file, and keep the temp file handle.
   If 'force_output_target' is TRUE then make sure that
   all elements in the new archive are of the type
   'output_target'.  */

static void
copy_archive (bfd *ibfd, bfd *obfd, const char *output_target,
	      bfd_boolean force_output_target,
	      const bfd_arch_info_type *input_arch)
{
  struct name_list
    {
      struct name_list *next;
      const char *name;
      bfd *obfd;
    } *list, *l;
  bfd **ptr = &obfd->archive_head;
  bfd *this_element;
  char *dir;
  const char *filename;

  /* Make a temp directory to hold the contents.  */
  dir = make_tempdir (bfd_get_filename (obfd));
  if (dir == NULL)
      fatal (_("cannot create tempdir for archive copying (error: %s)"),
	   strerror (errno));

  if (strip_symbols == STRIP_ALL)
    obfd->has_armap = FALSE;
  else
    obfd->has_armap = ibfd->has_armap;
  obfd->is_thin_archive = ibfd->is_thin_archive;

  if (deterministic)
    obfd->flags |= BFD_DETERMINISTIC_OUTPUT;

  list = NULL;

  this_element = bfd_openr_next_archived_file (ibfd, NULL);

  if (!bfd_set_format (obfd, bfd_get_format (ibfd)))
    {
      status = 1;
      bfd_nonfatal_message (NULL, obfd, NULL, NULL);
      return;
    }

  while (!status && this_element != NULL)
    {
      char *output_name;
      bfd *output_bfd;
      bfd *last_element;
      struct stat buf;
      int stat_status = 0;
      bfd_boolean del = TRUE;
      bfd_boolean ok_object;

      /* Create an output file for this member.  */
      output_name = concat (dir, "/",
			    bfd_get_filename (this_element), (char *) 0);

      /* If the file already exists, make another temp dir.  */
      if (stat (output_name, &buf) >= 0)
	{
	  output_name = make_tempdir (output_name);
	  if (output_name == NULL)
	    fatal (_("cannot create tempdir for archive copying (error: %s)"),
		   strerror (errno));

	  l = (struct name_list *) xmalloc (sizeof (struct name_list));
	  l->name = output_name;
	  l->next = list;
	  l->obfd = NULL;
	  list = l;
	  output_name = concat (output_name, "/",
				bfd_get_filename (this_element), (char *) 0);
	}

      if (preserve_dates)
	{
	  stat_status = bfd_stat_arch_elt (this_element, &buf);

	  if (stat_status != 0)
	    non_fatal (_("internal stat error on %s"),
		       bfd_get_filename (this_element));
	}

      l = (struct name_list *) xmalloc (sizeof (struct name_list));
      l->name = output_name;
      l->next = list;
      l->obfd = NULL;
      list = l;

      ok_object = bfd_check_format (this_element, bfd_object);
      if (!ok_object)
	bfd_nonfatal_message (NULL, this_element, NULL,
			      _("Unable to recognise the format of file"));

      /* PR binutils/3110: Cope with archives
	 containing multiple target types.  */
      if (force_output_target || !ok_object)
	output_bfd = bfd_openw (output_name, output_target);
      else
	output_bfd = bfd_openw (output_name, bfd_get_target (this_element));

      if (output_bfd == NULL)
	{
	  bfd_nonfatal_message (output_name, NULL, NULL, NULL);
	  status = 1;
	  return;
	}

      if (ok_object)
	{
	  del = !copy_object (this_element, output_bfd, input_arch);

	  if (del && bfd_get_arch (this_element) == bfd_arch_unknown)
	    /* Try again as an unknown object file.  */
	    ok_object = FALSE;
	  else if (!bfd_close (output_bfd))
	    {
	      bfd_nonfatal_message (output_name, NULL, NULL, NULL);
	      /* Error in new object file. Don't change archive.  */
	      status = 1;
	    }
	}

      if (!ok_object)
	{
	  del = !copy_unknown_object (this_element, output_bfd);
	  if (!bfd_close_all_done (output_bfd))
	    {
	      bfd_nonfatal_message (output_name, NULL, NULL, NULL);
	      /* Error in new object file. Don't change archive.  */
	      status = 1;
	    }
	}

      if (del)
	{
	  unlink (output_name);
	  status = 1;
	}
      else
	{
	  if (preserve_dates && stat_status == 0)
	    set_times (output_name, &buf);

	  /* Open the newly output file and attach to our list.  */
	  output_bfd = bfd_openr (output_name, output_target);

	  l->obfd = output_bfd;

	  *ptr = output_bfd;
	  ptr = &output_bfd->archive_next;

	  last_element = this_element;

	  this_element = bfd_openr_next_archived_file (ibfd, last_element);

	  bfd_close (last_element);
	}
    }
  *ptr = NULL;

  filename = bfd_get_filename (obfd);
  if (!bfd_close (obfd))
    {
      status = 1;
      bfd_nonfatal_message (filename, NULL, NULL, NULL);
      return;
    }

  filename = bfd_get_filename (ibfd);
  if (!bfd_close (ibfd))
    {
      status = 1;
      bfd_nonfatal_message (filename, NULL, NULL, NULL);
      return;
    }

  /* Delete all the files that we opened.  */
  for (l = list; l != NULL; l = l->next)
    {
      if (l->obfd == NULL)
	rmdir (l->name);
      else
	{
	  bfd_close (l->obfd);
	  unlink (l->name);
	}
    }
  rmdir (dir);
}

static void
set_long_section_mode (bfd *output_bfd, bfd *input_bfd, enum long_section_name_handling style)
{
  /* This is only relevant to Coff targets.  */
  if (bfd_get_flavour (output_bfd) == bfd_target_coff_flavour)
    {
      if (style == KEEP
	  && bfd_get_flavour (input_bfd) == bfd_target_coff_flavour)
	style = bfd_coff_long_section_names (input_bfd) ? ENABLE : DISABLE;
      bfd_coff_set_long_section_names (output_bfd, style != DISABLE);
    }
}

/* The top-level control.  */

static void
copy_file (const char *input_filename, const char *output_filename,
	   const char *input_target,   const char *output_target,
	   const bfd_arch_info_type *input_arch)
{
  bfd *ibfd;
  char **obj_matching;
  char **core_matching;
  off_t size = get_file_size (input_filename);

  if (size < 1)
    {
      if (size == 0)
	non_fatal (_("error: the input file '%s' is empty"),
		   input_filename);
      status = 1;
      return;
    }

  /* To allow us to do "strip *" without dying on the first
     non-object file, failures are nonfatal.  */
  ibfd = bfd_openr (input_filename, input_target);
  if (ibfd == NULL)
    {
      bfd_nonfatal_message (input_filename, NULL, NULL, NULL);
      status = 1;
      return;
    }

  switch (do_debug_sections)
    {
    case compress:
      ibfd->flags |= BFD_COMPRESS;
      break;
    case decompress:
      ibfd->flags |= BFD_DECOMPRESS;
      break;
    default:
      break;
    }

  if (bfd_check_format (ibfd, bfd_archive))
    {
      bfd_boolean force_output_target;
      bfd *obfd;

      /* bfd_get_target does not return the correct value until
         bfd_check_format succeeds.  */
      if (output_target == NULL)
	{
	  output_target = bfd_get_target (ibfd);
	  force_output_target = FALSE;
	}
      else
	force_output_target = TRUE;

      obfd = bfd_openw (output_filename, output_target);
      if (obfd == NULL)
	{
	  bfd_nonfatal_message (output_filename, NULL, NULL, NULL);
	  status = 1;
	  return;
	}
      /* This is a no-op on non-Coff targets.  */
      set_long_section_mode (obfd, ibfd, long_section_names);

      copy_archive (ibfd, obfd, output_target, force_output_target, input_arch);
    }
  else if (bfd_check_format_matches (ibfd, bfd_object, &obj_matching))
    {
      bfd *obfd;
    do_copy:

      /* bfd_get_target does not return the correct value until
         bfd_check_format succeeds.  */
      if (output_target == NULL)
	output_target = bfd_get_target (ibfd);

      obfd = bfd_openw (output_filename, output_target);
      if (obfd == NULL)
 	{
 	  bfd_nonfatal_message (output_filename, NULL, NULL, NULL);
 	  status = 1;
 	  return;
 	}
      /* This is a no-op on non-Coff targets.  */
      set_long_section_mode (obfd, ibfd, long_section_names);

      if (! copy_object (ibfd, obfd, input_arch))
	status = 1;

      if (!bfd_close (obfd))
	{
	  status = 1;
	  bfd_nonfatal_message (output_filename, NULL, NULL, NULL);
	  return;
	}

      if (!bfd_close (ibfd))
	{
	  status = 1;
	  bfd_nonfatal_message (input_filename, NULL, NULL, NULL);
	  return;
	}
    }
  else
    {
      bfd_error_type obj_error = bfd_get_error ();
      bfd_error_type core_error;

      if (bfd_check_format_matches (ibfd, bfd_core, &core_matching))
	{
	  /* This probably can't happen..  */
	  if (obj_error == bfd_error_file_ambiguously_recognized)
	    free (obj_matching);
	  goto do_copy;
	}

      core_error = bfd_get_error ();
      /* Report the object error in preference to the core error.  */
      if (obj_error != core_error)
	bfd_set_error (obj_error);

      bfd_nonfatal_message (input_filename, NULL, NULL, NULL);

      if (obj_error == bfd_error_file_ambiguously_recognized)
	{
	  list_matching_formats (obj_matching);
	  free (obj_matching);
	}
      if (core_error == bfd_error_file_ambiguously_recognized)
	{
	  list_matching_formats (core_matching);
	  free (core_matching);
	}

      status = 1;
    }
}

/* Add a name to the section renaming list.  */

static void
add_section_rename (const char * old_name, const char * new_name,
		    flagword flags)
{
  section_rename * srename;

  /* Check for conflicts first.  */
  for (srename = section_rename_list; srename != NULL; srename = srename->next)
    if (strcmp (srename->old_name, old_name) == 0)
      {
	/* Silently ignore duplicate definitions.  */
	if (strcmp (srename->new_name, new_name) == 0
	    && srename->flags == flags)
	  return;

	fatal (_("Multiple renames of section %s"), old_name);
      }

  srename = (section_rename *) xmalloc (sizeof (* srename));

  srename->old_name = old_name;
  srename->new_name = new_name;
  srename->flags    = flags;
  srename->next     = section_rename_list;

  section_rename_list = srename;
}

/* Check the section rename list for a new name of the input section
   ISECTION.  Return the new name if one is found.
   Also set RETURNED_FLAGS to the flags to be used for this section.  */

static const char *
find_section_rename (bfd * ibfd ATTRIBUTE_UNUSED, sec_ptr isection,
		     flagword * returned_flags)
{
  const char * old_name = bfd_section_name (ibfd, isection);
  section_rename * srename;

  /* Default to using the flags of the input section.  */
  * returned_flags = bfd_get_section_flags (ibfd, isection);

  for (srename = section_rename_list; srename != NULL; srename = srename->next)
    if (strcmp (srename->old_name, old_name) == 0)
      {
	if (srename->flags != (flagword) -1)
	  * returned_flags = srename->flags;

	return srename->new_name;
      }

  return old_name;
}

/* Once each of the sections is copied, we may still need to do some
   finalization work for private section headers.  Do that here.  */

static void
setup_bfd_headers (bfd *ibfd, bfd *obfd)
{
  /* Allow the BFD backend to copy any private data it understands
     from the input section to the output section.  */
  if (! bfd_copy_private_header_data (ibfd, obfd))
    {
      status = 1;
      bfd_nonfatal_message (NULL, ibfd, NULL,
			    _("error in private header data"));
      return;
    }

  /* All went well.  */
  return;
}

/* Create a section in OBFD with the same
   name and attributes as ISECTION in IBFD.  */

static void
setup_section (bfd *ibfd, sec_ptr isection, void *obfdarg)
{
  bfd *obfd = (bfd *) obfdarg;
  struct section_list *p;
  sec_ptr osection;
  bfd_size_type size;
  bfd_vma vma;
  bfd_vma lma;
  flagword flags;
  const char *err;
  const char * name;
  char *prefix = NULL;
  bfd_boolean make_nobits;

  if (is_strip_section (ibfd, isection))
    return;

  /* Get the, possibly new, name of the output section.  */
  name = find_section_rename (ibfd, isection, & flags);

  /* Prefix sections.  */
  if ((prefix_alloc_sections_string)
      && (bfd_get_section_flags (ibfd, isection) & SEC_ALLOC))
    prefix = prefix_alloc_sections_string;
  else if (prefix_sections_string)
    prefix = prefix_sections_string;

  if (prefix)
    {
      char *n;

      n = (char *) xmalloc (strlen (prefix) + strlen (name) + 1);
      strcpy (n, prefix);
      strcat (n, name);
      name = n;
    }

  make_nobits = FALSE;

  p = find_section_list (bfd_section_name (ibfd, isection), FALSE,
			 SECTION_CONTEXT_SET_FLAGS);
  if (p != NULL)
    flags = p->flags | (flags & (SEC_HAS_CONTENTS | SEC_RELOC));
  else if (strip_symbols == STRIP_NONDEBUG
	   && (flags & (SEC_ALLOC | SEC_GROUP)) != 0
	   && !(ibfd->xvec->flavour == bfd_target_elf_flavour
		&& elf_section_type (isection) == SHT_NOTE))
    {
      flags &= ~(SEC_HAS_CONTENTS | SEC_LOAD | SEC_GROUP);
      if (obfd->xvec->flavour == bfd_target_elf_flavour)
	{
	  make_nobits = TRUE;

	  /* Twiddle the input section flags so that it seems to
	     elf.c:copy_private_bfd_data that section flags have not
	     changed between input and output sections.  This hack
	     prevents wholesale rewriting of the program headers.  */
	  isection->flags &= ~(SEC_HAS_CONTENTS | SEC_LOAD | SEC_GROUP);
	}
    }

  osection = bfd_make_section_anyway_with_flags (obfd, name, flags);

  if (osection == NULL)
    {
      err = _("failed to create output section");
      goto loser;
    }

  if (make_nobits)
    elf_section_type (osection) = SHT_NOBITS;

  size = bfd_section_size (ibfd, isection);
  if (copy_byte >= 0)
    size = (size + interleave - 1) / interleave * copy_width;
  else if (extract_symbol)
    size = 0;
  if (! bfd_set_section_size (obfd, osection, size))
    {
      err = _("failed to set size");
      goto loser;
    }

  vma = bfd_section_vma (ibfd, isection);
  p = find_section_list (bfd_section_name (ibfd, isection), FALSE,
			 SECTION_CONTEXT_ALTER_VMA | SECTION_CONTEXT_SET_VMA);
  if (p != NULL)
    {
      if (p->context & SECTION_CONTEXT_SET_VMA)
	vma = p->vma_val;
      else
	vma += p->vma_val;
    }
  else
    vma += change_section_address;

  if (! bfd_set_section_vma (obfd, osection, vma))
    {
      err = _("failed to set vma");
      goto loser;
    }

  lma = isection->lma;
  p = find_section_list (bfd_section_name (ibfd, isection), FALSE,
			 SECTION_CONTEXT_ALTER_LMA | SECTION_CONTEXT_SET_LMA);
  if (p != NULL)
    {
      if (p->context & SECTION_CONTEXT_ALTER_LMA)
	lma += p->lma_val;
      else
	lma = p->lma_val;
    }
  else
    lma += change_section_address;

  osection->lma = lma;

  /* FIXME: This is probably not enough.  If we change the LMA we
     may have to recompute the header for the file as well.  */
  if (!bfd_set_section_alignment (obfd,
				  osection,
				  bfd_section_alignment (ibfd, isection)))
    {
      err = _("failed to set alignment");
      goto loser;
    }

  /* Copy merge entity size.  */
  osection->entsize = isection->entsize;

  /* This used to be mangle_section; we do here to avoid using
     bfd_get_section_by_name since some formats allow multiple
     sections with the same name.  */
  isection->output_section = osection;
  isection->output_offset = 0;

  /* Do not copy backend data if --extract-symbol is passed; anything
     that needs to look at the section contents will fail.  */
  if (extract_symbol)
    return;

  if ((isection->flags & SEC_GROUP) != 0)
    {
      asymbol *gsym = group_signature (isection);

      if (gsym != NULL)
	{
	  gsym->flags |= BSF_KEEP;
	  if (ibfd->xvec->flavour == bfd_target_elf_flavour)
	    elf_group_id (isection) = gsym;
	}
    }

  /* Allow the BFD backend to copy any private data it understands
     from the input section to the output section.  */
  if (!bfd_copy_private_section_data (ibfd, isection, obfd, osection))
    {
      err = _("failed to copy private data");
      goto loser;
    }

  /* All went well.  */
  return;

loser:
  status = 1;
  bfd_nonfatal_message (NULL, obfd, osection, err);
}

/* Return TRUE if input section ISECTION should be skipped.  */

static bfd_boolean
skip_section (bfd *ibfd, sec_ptr isection)
{
  sec_ptr osection;
  bfd_size_type size;
  flagword flags;

  /* If we have already failed earlier on,
     do not keep on generating complaints now.  */
  if (status != 0)
    return TRUE;

  if (extract_symbol)
    return TRUE;

  if (is_strip_section (ibfd, isection))
    return TRUE;

  flags = bfd_get_section_flags (ibfd, isection);
  if ((flags & SEC_GROUP) != 0)
    return TRUE;

  osection = isection->output_section;
  size = bfd_get_section_size (isection);

  if (size == 0 || osection == 0)
    return TRUE;

  return FALSE;
}

/* Copy relocations in input section ISECTION of IBFD to an output
   section with the same name in OBFDARG.  If stripping then don't
   copy any relocation info.  */

static void
copy_relocations_in_section (bfd *ibfd, sec_ptr isection, void *obfdarg)
{
  bfd *obfd = (bfd *) obfdarg;
  long relsize;
  arelent **relpp;
  long relcount;
  sec_ptr osection;

  if (skip_section (ibfd, isection))
    return;

  osection = isection->output_section;

  /* Core files and DWO files do not need to be relocated.  */
  if (bfd_get_format (obfd) == bfd_core || strip_symbols == STRIP_NONDWO)
    relsize = 0;
  else
    {
      relsize = bfd_get_reloc_upper_bound (ibfd, isection);

      if (relsize < 0)
	{
	  /* Do not complain if the target does not support relocations.  */
	  if (relsize == -1 && bfd_get_error () == bfd_error_invalid_operation)
	    relsize = 0;
	  else
	    {
	      status = 1;
	      bfd_nonfatal_message (NULL, ibfd, isection, NULL);
	      return;
	    }
	}
    }

  if (relsize == 0)
    {
      bfd_set_reloc (obfd, osection, NULL, 0);
      osection->flags &= ~SEC_RELOC;
    }
  else
    {
      relpp = (arelent **) xmalloc (relsize);
      relcount = bfd_canonicalize_reloc (ibfd, isection, relpp, isympp);
      if (relcount < 0)
	{
	  status = 1;
	  bfd_nonfatal_message (NULL, ibfd, isection,
				_("relocation count is negative"));
	  return;
	}

      if (strip_symbols == STRIP_ALL)
	{
	  /* Remove relocations which are not in
	     keep_strip_specific_list.  */
	  arelent **temp_relpp;
	  long temp_relcount = 0;
	  long i;

	  temp_relpp = (arelent **) xmalloc (relsize);
	  for (i = 0; i < relcount; i++)
	    if (is_specified_symbol (bfd_asymbol_name (*relpp[i]->sym_ptr_ptr),
				     keep_specific_htab))
	      temp_relpp [temp_relcount++] = relpp [i];
	  relcount = temp_relcount;
	  free (relpp);
	  relpp = temp_relpp;
	}

      bfd_set_reloc (obfd, osection, relcount == 0 ? NULL : relpp, relcount);
      if (relcount == 0)
	{
	  osection->flags &= ~SEC_RELOC;
	  free (relpp);
	}
    }
}

/* Copy the data of input section ISECTION of IBFD
   to an output section with the same name in OBFD.  */

static void
copy_section (bfd *ibfd, sec_ptr isection, void *obfdarg)
{
  bfd *obfd = (bfd *) obfdarg;
  struct section_list *p;
  sec_ptr osection;
  bfd_size_type size;

  if (skip_section (ibfd, isection))
    return;

  osection = isection->output_section;
  size = bfd_get_section_size (isection);

  if (bfd_get_section_flags (ibfd, isection) & SEC_HAS_CONTENTS
      && bfd_get_section_flags (obfd, osection) & SEC_HAS_CONTENTS)
    {
      bfd_byte *memhunk = NULL;

      if (!bfd_get_full_section_contents (ibfd, isection, &memhunk))
	{
	  status = 1;
	  bfd_nonfatal_message (NULL, ibfd, isection, NULL);
	  return;
	}

      if (reverse_bytes)
	{
	  /* We don't handle leftover bytes (too many possible behaviors,
	     and we don't know what the user wants).  The section length
	     must be a multiple of the number of bytes to swap.  */
	  if ((size % reverse_bytes) == 0)
	    {
	      unsigned long i, j;
	      bfd_byte b;

	      for (i = 0; i < size; i += reverse_bytes)
		for (j = 0; j < (unsigned long)(reverse_bytes / 2); j++)
		  {
		    bfd_byte *m = (bfd_byte *) memhunk;

		    b = m[i + j];
		    m[i + j] = m[(i + reverse_bytes) - (j + 1)];
		    m[(i + reverse_bytes) - (j + 1)] = b;
		  }
	    }
	  else
	    /* User must pad the section up in order to do this.  */
	    fatal (_("cannot reverse bytes: length of section %s must be evenly divisible by %d"),
		   bfd_section_name (ibfd, isection), reverse_bytes);
	}

      if (copy_byte >= 0)
	{
	  /* Keep only every `copy_byte'th byte in MEMHUNK.  */
	  char *from = (char *) memhunk + copy_byte;
	  char *to = (char *) memhunk;
	  char *end = (char *) memhunk + size;
	  int i;

	  for (; from < end; from += interleave)
	    for (i = 0; i < copy_width; i++)
	      {
		if (&from[i] >= end)
		  break;
		*to++ = from[i];
	      }

	  size = (size + interleave - 1 - copy_byte) / interleave * copy_width;
	  osection->lma /= interleave;
	}

      if (!bfd_set_section_contents (obfd, osection, memhunk, 0, size))
	{
	  status = 1;
	  bfd_nonfatal_message (NULL, obfd, osection, NULL);
	  return;
	}
      free (memhunk);
    }
  else if ((p = find_section_list (bfd_get_section_name (ibfd, isection),
				   FALSE, SECTION_CONTEXT_SET_FLAGS)) != NULL
	   && (p->flags & SEC_HAS_CONTENTS) != 0)
    {
      void *memhunk = xmalloc (size);

      /* We don't permit the user to turn off the SEC_HAS_CONTENTS
	 flag--they can just remove the section entirely and add it
	 back again.  However, we do permit them to turn on the
	 SEC_HAS_CONTENTS flag, and take it to mean that the section
	 contents should be zeroed out.  */

      memset (memhunk, 0, size);
      if (! bfd_set_section_contents (obfd, osection, memhunk, 0, size))
	{
	  status = 1;
	  bfd_nonfatal_message (NULL, obfd, osection, NULL);
	  return;
	}
      free (memhunk);
    }
}

/* Get all the sections.  This is used when --gap-fill or --pad-to is
   used.  */

static void
get_sections (bfd *obfd ATTRIBUTE_UNUSED, asection *osection, void *secppparg)
{
  asection ***secppp = (asection ***) secppparg;

  **secppp = osection;
  ++(*secppp);
}

/* Sort sections by VMA.  This is called via qsort, and is used when
   --gap-fill or --pad-to is used.  We force non loadable or empty
   sections to the front, where they are easier to ignore.  */

static int
compare_section_lma (const void *arg1, const void *arg2)
{
  const asection *const *sec1 = (const asection * const *) arg1;
  const asection *const *sec2 = (const asection * const *) arg2;
  flagword flags1, flags2;

  /* Sort non loadable sections to the front.  */
  flags1 = (*sec1)->flags;
  flags2 = (*sec2)->flags;
  if ((flags1 & SEC_HAS_CONTENTS) == 0
      || (flags1 & SEC_LOAD) == 0)
    {
      if ((flags2 & SEC_HAS_CONTENTS) != 0
	  && (flags2 & SEC_LOAD) != 0)
	return -1;
    }
  else
    {
      if ((flags2 & SEC_HAS_CONTENTS) == 0
	  || (flags2 & SEC_LOAD) == 0)
	return 1;
    }

  /* Sort sections by LMA.  */
  if ((*sec1)->lma > (*sec2)->lma)
    return 1;
  else if ((*sec1)->lma < (*sec2)->lma)
    return -1;

  /* Sort sections with the same LMA by size.  */
  if (bfd_get_section_size (*sec1) > bfd_get_section_size (*sec2))
    return 1;
  else if (bfd_get_section_size (*sec1) < bfd_get_section_size (*sec2))
    return -1;

  return 0;
}

/* Mark all the symbols which will be used in output relocations with
   the BSF_KEEP flag so that those symbols will not be stripped.

   Ignore relocations which will not appear in the output file.  */

static void
mark_symbols_used_in_relocations (bfd *ibfd, sec_ptr isection, void *symbolsarg)
{
  asymbol **symbols = (asymbol **) symbolsarg;
  long relsize;
  arelent **relpp;
  long relcount, i;

  /* Ignore an input section with no corresponding output section.  */
  if (isection->output_section == NULL)
    return;

  relsize = bfd_get_reloc_upper_bound (ibfd, isection);
  if (relsize < 0)
    {
      /* Do not complain if the target does not support relocations.  */
      if (relsize == -1 && bfd_get_error () == bfd_error_invalid_operation)
	return;
      bfd_fatal (bfd_get_filename (ibfd));
    }

  if (relsize == 0)
    return;

  relpp = (arelent **) xmalloc (relsize);
  relcount = bfd_canonicalize_reloc (ibfd, isection, relpp, symbols);
  if (relcount < 0)
    bfd_fatal (bfd_get_filename (ibfd));

  /* Examine each symbol used in a relocation.  If it's not one of the
     special bfd section symbols, then mark it with BSF_KEEP.  */
  for (i = 0; i < relcount; i++)
    {
      if (*relpp[i]->sym_ptr_ptr != bfd_com_section_ptr->symbol
	  && *relpp[i]->sym_ptr_ptr != bfd_abs_section_ptr->symbol
	  && *relpp[i]->sym_ptr_ptr != bfd_und_section_ptr->symbol)
	(*relpp[i]->sym_ptr_ptr)->flags |= BSF_KEEP;
    }

  if (relpp != NULL)
    free (relpp);
}

/* Write out debugging information.  */

static bfd_boolean
write_debugging_info (bfd *obfd, void *dhandle,
		      long *symcountp ATTRIBUTE_UNUSED,
		      asymbol ***symppp ATTRIBUTE_UNUSED)
{
  if (bfd_get_flavour (obfd) == bfd_target_ieee_flavour)
    return write_ieee_debugging_info (obfd, dhandle);

  if (bfd_get_flavour (obfd) == bfd_target_coff_flavour
      || bfd_get_flavour (obfd) == bfd_target_elf_flavour)
    {
      bfd_byte *syms, *strings;
      bfd_size_type symsize, stringsize;
      asection *stabsec, *stabstrsec;
      flagword flags;

      if (! write_stabs_in_sections_debugging_info (obfd, dhandle, &syms,
						    &symsize, &strings,
						    &stringsize))
	return FALSE;

      flags = SEC_HAS_CONTENTS | SEC_READONLY | SEC_DEBUGGING;
      stabsec = bfd_make_section_with_flags (obfd, ".stab", flags);
      stabstrsec = bfd_make_section_with_flags (obfd, ".stabstr", flags);
      if (stabsec == NULL
	  || stabstrsec == NULL
	  || ! bfd_set_section_size (obfd, stabsec, symsize)
	  || ! bfd_set_section_size (obfd, stabstrsec, stringsize)
	  || ! bfd_set_section_alignment (obfd, stabsec, 2)
	  || ! bfd_set_section_alignment (obfd, stabstrsec, 0))
	{
	  bfd_nonfatal_message (NULL, obfd, NULL,
				_("can't create debugging section"));
	  return FALSE;
	}

      /* We can get away with setting the section contents now because
         the next thing the caller is going to do is copy over the
         real sections.  We may someday have to split the contents
         setting out of this function.  */
      if (! bfd_set_section_contents (obfd, stabsec, syms, 0, symsize)
	  || ! bfd_set_section_contents (obfd, stabstrsec, strings, 0,
					 stringsize))
	{
	  bfd_nonfatal_message (NULL, obfd, NULL,
				_("can't set debugging section contents"));
	  return FALSE;
	}

      return TRUE;
    }

  bfd_nonfatal_message (NULL, obfd, NULL,
			_("don't know how to write debugging information for %s"),
	     bfd_get_target (obfd));
  return FALSE;
}

/* If neither -D nor -U was specified explicitly,
   then use the configured default.  */
static void
default_deterministic (void)
{
  if (deterministic < 0)
    deterministic = DEFAULT_AR_DETERMINISTIC;
}

static int
strip_main (int argc, char *argv[])
{
  char *input_target = NULL;
  char *output_target = NULL;
  bfd_boolean show_version = FALSE;
  bfd_boolean formats_info = FALSE;
  int c;
  int i;
  char *output_file = NULL;

  while ((c = getopt_long (argc, argv, "I:O:F:K:N:R:o:sSpdgxXHhVvw",
			   strip_options, (int *) 0)) != EOF)
    {
      switch (c)
	{
	case 'I':
	  input_target = optarg;
	  break;
	case 'O':
	  output_target = optarg;
	  break;
	case 'F':
	  input_target = output_target = optarg;
	  break;
	case 'R':
	  find_section_list (optarg, TRUE, SECTION_CONTEXT_REMOVE);
	  sections_removed = TRUE;
	  break;
	case 's':
	  strip_symbols = STRIP_ALL;
	  break;
	case 'S':
	case 'g':
	case 'd':	/* Historic BSD alias for -g.  Used by early NetBSD.  */
	  strip_symbols = STRIP_DEBUG;
	  break;
	case OPTION_STRIP_DWO:
	  strip_symbols = STRIP_DWO;
	  break;
	case OPTION_STRIP_UNNEEDED:
	  strip_symbols = STRIP_UNNEEDED;
	  break;
	case 'K':
	  add_specific_symbol (optarg, keep_specific_htab);
	  break;
	case 'N':
	  add_specific_symbol (optarg, strip_specific_htab);
	  break;
	case 'o':
	  output_file = optarg;
	  break;
	case 'p':
	  preserve_dates = TRUE;
	  break;
	case 'D':
	  deterministic = TRUE;
	  break;
	case 'U':
	  deterministic = FALSE;
	  break;
	case 'x':
	  discard_locals = LOCALS_ALL;
	  break;
	case 'X':
	  discard_locals = LOCALS_START_L;
	  break;
	case 'v':
	  verbose = TRUE;
	  break;
	case 'V':
	  show_version = TRUE;
	  break;
	case OPTION_FORMATS_INFO:
	  formats_info = TRUE;
	  break;
	case OPTION_ONLY_KEEP_DEBUG:
	  strip_symbols = STRIP_NONDEBUG;
	  break;
	case OPTION_KEEP_FILE_SYMBOLS:
	  keep_file_symbols = 1;
	  break;
	case 0:
	  /* We've been given a long option.  */
	  break;
	case 'w':
	  wildcard = TRUE;
	  break;
	case 'H':
	case 'h':
	  strip_usage (stdout, 0);
	default:
	  strip_usage (stderr, 1);
	}
    }

  if (formats_info)
    {
      display_info ();
      return 0;
    }

  if (show_version)
    print_version ("strip");

  default_deterministic ();

  /* Default is to strip all symbols.  */
  if (strip_symbols == STRIP_UNDEF
      && discard_locals == LOCALS_UNDEF
      && htab_elements (strip_specific_htab) == 0)
    strip_symbols = STRIP_ALL;

  if (output_target == NULL)
    output_target = input_target;

  i = optind;
  if (i == argc
      || (output_file != NULL && (i + 1) < argc))
    strip_usage (stderr, 1);

  for (; i < argc; i++)
    {
      int hold_status = status;
      struct stat statbuf;
      char *tmpname;

      if (get_file_size (argv[i]) < 1)
	{
	  status = 1;
	  continue;
	}

      if (preserve_dates)
	/* No need to check the return value of stat().
	   It has already been checked in get_file_size().  */
	stat (argv[i], &statbuf);

      if (output_file == NULL
	  || filename_cmp (argv[i], output_file) == 0)
	tmpname = make_tempname (argv[i]);
      else
	tmpname = output_file;

      if (tmpname == NULL)
	{
	  bfd_nonfatal_message (argv[i], NULL, NULL,
				_("could not create temporary file to hold stripped copy"));
	  status = 1;
	  continue;
	}

      status = 0;
      copy_file (argv[i], tmpname, input_target, output_target, NULL);
      if (status == 0)
	{
	  if (preserve_dates)
	    set_times (tmpname, &statbuf);
	  if (output_file != tmpname)
	    status = (smart_rename (tmpname,
				    output_file ? output_file : argv[i],
				    preserve_dates) != 0);
	  if (status == 0)
	    status = hold_status;
	}
      else
	unlink_if_ordinary (tmpname);
      if (output_file != tmpname)
	free (tmpname);
    }

  return status;
}

/* Set up PE subsystem.  */

static void
set_pe_subsystem (const char *s)
{
  const char *version, *subsystem;
  size_t i;
  static const struct
    {
      const char *name;
      const char set_def;
      const short value;
    }
  v[] =
    {
      { "native", 0, IMAGE_SUBSYSTEM_NATIVE },
      { "windows", 0, IMAGE_SUBSYSTEM_WINDOWS_GUI },
      { "console", 0, IMAGE_SUBSYSTEM_WINDOWS_CUI },
      { "posix", 0, IMAGE_SUBSYSTEM_POSIX_CUI },
      { "wince", 0, IMAGE_SUBSYSTEM_WINDOWS_CE_GUI },
      { "efi-app", 1, IMAGE_SUBSYSTEM_EFI_APPLICATION },
      { "efi-bsd", 1, IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER },
      { "efi-rtd", 1, IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER },
      { "sal-rtd", 1, IMAGE_SUBSYSTEM_SAL_RUNTIME_DRIVER },
      { "xbox", 0, IMAGE_SUBSYSTEM_XBOX }
    };
  short value;
  char *copy;
  int set_def = -1;

  /* Check for the presence of a version number.  */
  version = strchr (s, ':');
  if (version == NULL)
    subsystem = s;
  else
    {
      int len = version - s;
      copy = xstrdup (s);
      subsystem = copy;
      copy[len] = '\0';
      version = copy + 1 + len;
      pe_major_subsystem_version = strtoul (version, &copy, 0);
      if (*copy == '.')
	pe_minor_subsystem_version = strtoul (copy + 1, &copy, 0);
      if (*copy != '\0')
	non_fatal (_("%s: bad version in PE subsystem"), s);
    }

  /* Check for numeric subsystem.  */
  value = (short) strtol (subsystem, &copy, 0);
  if (*copy == '\0')
    {
      for (i = 0; i < ARRAY_SIZE (v); i++)
	if (v[i].value == value)
	  {
	    pe_subsystem = value;
	    set_def = v[i].set_def;
	    break;
	  }
    }
  else
    {
      /* Search for subsystem by name.  */
      for (i = 0; i < ARRAY_SIZE (v); i++)
	if (strcmp (subsystem, v[i].name) == 0)
	  {
	    pe_subsystem = v[i].value;
	    set_def = v[i].set_def;
	    break;
	  }
    }

  switch (set_def)
    {
    case -1:
      fatal (_("unknown PE subsystem: %s"), s);
      break;
    case 0:
      break;
    default:
      if (pe_file_alignment == (bfd_vma) -1)
	pe_file_alignment = PE_DEF_FILE_ALIGNMENT;
      if (pe_section_alignment == (bfd_vma) -1)
	pe_section_alignment = PE_DEF_SECTION_ALIGNMENT;
      break;
    }
  if (s != subsystem)
    free ((char *) subsystem);
}

/* Convert EFI target to PEI target.  */

static void
convert_efi_target (char *efi)
{
  efi[0] = 'p';
  efi[1] = 'e';
  efi[2] = 'i';

  if (strcmp (efi + 4, "ia32") == 0)
    {
      /* Change ia32 to i386.  */
      efi[5]= '3';
      efi[6]= '8';
      efi[7]= '6';
    }
  else if (strcmp (efi + 4, "x86_64") == 0)
    {
      /* Change x86_64 to x86-64.  */
      efi[7] = '-';
    }
}

static int
copy_main (int argc, char *argv[])
{
  char *input_filename = NULL;
  char *output_filename = NULL;
  char *tmpname;
  char *input_target = NULL;
  char *output_target = NULL;
  bfd_boolean show_version = FALSE;
  bfd_boolean change_warn = TRUE;
  bfd_boolean formats_info = FALSE;
  int c;
  struct stat statbuf;
  const bfd_arch_info_type *input_arch = NULL;

  while ((c = getopt_long (argc, argv, "b:B:i:I:j:K:N:s:O:d:F:L:G:R:SpgxXHhVvW:w",
			   copy_options, (int *) 0)) != EOF)
    {
      switch (c)
	{
	case 'b':
	  copy_byte = atoi (optarg);
	  if (copy_byte < 0)
	    fatal (_("byte number must be non-negative"));
	  break;

	case 'B':
	  input_arch = bfd_scan_arch (optarg);
	  if (input_arch == NULL)
	    fatal (_("architecture %s unknown"), optarg);
	  break;

	case 'i':
	  if (optarg)
	    {
	      interleave = atoi (optarg);
	      if (interleave < 1)
		fatal (_("interleave must be positive"));
	    }
	  else
	    interleave = 4;
	  break;

	case OPTION_INTERLEAVE_WIDTH:
	  copy_width = atoi (optarg);
	  if (copy_width < 1)
	    fatal(_("interleave width must be positive"));
	  break;

	case 'I':
	case 's':		/* "source" - 'I' is preferred */
	  input_target = optarg;
	  break;

	case 'O':
	case 'd':		/* "destination" - 'O' is preferred */
	  output_target = optarg;
	  break;

	case 'F':
	  input_target = output_target = optarg;
	  break;

	case 'j':
	  find_section_list (optarg, TRUE, SECTION_CONTEXT_COPY);
	  sections_copied = TRUE;
	  break;

	case 'R':
	  find_section_list (optarg, TRUE, SECTION_CONTEXT_REMOVE);
	  sections_removed = TRUE;
	  break;

	case 'S':
	  strip_symbols = STRIP_ALL;
	  break;

	case 'g':
	  strip_symbols = STRIP_DEBUG;
	  break;

	case OPTION_STRIP_DWO:
	  strip_symbols = STRIP_DWO;
	  break;

	case OPTION_STRIP_UNNEEDED:
	  strip_symbols = STRIP_UNNEEDED;
	  break;

	case OPTION_ONLY_KEEP_DEBUG:
	  strip_symbols = STRIP_NONDEBUG;
	  break;

	case OPTION_KEEP_FILE_SYMBOLS:
	  keep_file_symbols = 1;
	  break;

	case OPTION_ADD_GNU_DEBUGLINK:
	  long_section_names = ENABLE ;
	  gnu_debuglink_filename = optarg;
	  break;

	case 'K':
	  add_specific_symbol (optarg, keep_specific_htab);
	  break;

	case 'N':
	  add_specific_symbol (optarg, strip_specific_htab);
	  break;

	case OPTION_STRIP_UNNEEDED_SYMBOL:
	  add_specific_symbol (optarg, strip_unneeded_htab);
	  break;

	case 'L':
	  add_specific_symbol (optarg, localize_specific_htab);
	  break;

	case OPTION_GLOBALIZE_SYMBOL:
	  add_specific_symbol (optarg, globalize_specific_htab);
	  break;

	case 'G':
	  add_specific_symbol (optarg, keepglobal_specific_htab);
	  break;

	case 'W':
	  add_specific_symbol (optarg, weaken_specific_htab);
	  break;

	case 'p':
	  preserve_dates = TRUE;
	  break;

	case 'D':
	  deterministic = TRUE;
	  break;

	case 'U':
	  deterministic = FALSE;
	  break;

	case 'w':
	  wildcard = TRUE;
	  break;

	case 'x':
	  discard_locals = LOCALS_ALL;
	  break;

	case 'X':
	  discard_locals = LOCALS_START_L;
	  break;

	case 'v':
	  verbose = TRUE;
	  break;

	case 'V':
	  show_version = TRUE;
	  break;

	case OPTION_FORMATS_INFO:
	  formats_info = TRUE;
	  break;

	case OPTION_WEAKEN:
	  weaken = TRUE;
	  break;

	case OPTION_ADD_SECTION:
	  {
	    const char *s;
	    size_t off, alloc;
	    struct section_add *pa;
	    FILE *f;

	    s = strchr (optarg, '=');

	    if (s == NULL)
	      fatal (_("bad format for %s"), "--add-section");

	    pa = (struct section_add *) xmalloc (sizeof (struct section_add));
	    pa->name = xstrndup (optarg, s - optarg);
	    pa->filename = s + 1;

	    /* We don't use get_file_size so that we can do
	         --add-section .note.GNU_stack=/dev/null
	       get_file_size doesn't work on /dev/null.  */

	    f = fopen (pa->filename, FOPEN_RB);
	    if (f == NULL)
	      fatal (_("cannot open: %s: %s"),
		     pa->filename, strerror (errno));

	    off = 0;
	    alloc = 4096;
	    pa->contents = (bfd_byte *) xmalloc (alloc);
	    while (!feof (f))
	      {
		off_t got;

		if (off == alloc)
		  {
		    alloc <<= 1;
		    pa->contents = (bfd_byte *) xrealloc (pa->contents, alloc);
		  }

		got = fread (pa->contents + off, 1, alloc - off, f);
		if (ferror (f))
		  fatal (_("%s: fread failed"), pa->filename);

		off += got;
	      }

	    pa->size = off;

	    fclose (f);

	    pa->next = add_sections;
	    add_sections = pa;
	  }
	  break;

	case OPTION_CHANGE_START:
	  change_start = parse_vma (optarg, "--change-start");
	  break;

	case OPTION_CHANGE_SECTION_ADDRESS:
	case OPTION_CHANGE_SECTION_LMA:
	case OPTION_CHANGE_SECTION_VMA:
	  {
	    struct section_list * p;
	    unsigned int context = 0;
	    const char *s;
	    int len;
	    char *name;
	    char *option = NULL;
	    bfd_vma val;

	    switch (c)
	      {
	      case OPTION_CHANGE_SECTION_ADDRESS:
		option = "--change-section-address";
		context = SECTION_CONTEXT_ALTER_LMA | SECTION_CONTEXT_ALTER_VMA;
		break;
	      case OPTION_CHANGE_SECTION_LMA:
		option = "--change-section-lma";
		context = SECTION_CONTEXT_ALTER_LMA;
		break;
	      case OPTION_CHANGE_SECTION_VMA:
		option = "--change-section-vma";
		context = SECTION_CONTEXT_ALTER_VMA;
		break;
	      }

	    s = strchr (optarg, '=');
	    if (s == NULL)
	      {
		s = strchr (optarg, '+');
		if (s == NULL)
		  {
		    s = strchr (optarg, '-');
		    if (s == NULL)
		      fatal (_("bad format for %s"), option);
		  }
	      }
	    else
	      {
		/* Correct the context.  */
		switch (c)
		  {
		  case OPTION_CHANGE_SECTION_ADDRESS:
		    context = SECTION_CONTEXT_SET_LMA | SECTION_CONTEXT_SET_VMA;
		    break;
		  case OPTION_CHANGE_SECTION_LMA:
		    context = SECTION_CONTEXT_SET_LMA;
		    break;
		  case OPTION_CHANGE_SECTION_VMA:
		    context = SECTION_CONTEXT_SET_VMA;
		    break;
		  }
	      }

	    len = s - optarg;
	    name = (char *) xmalloc (len + 1);
	    strncpy (name, optarg, len);
	    name[len] = '\0';

	    p = find_section_list (name, TRUE, context);

	    val = parse_vma (s + 1, option);
	    if (*s == '-')
	      val = - val;

	    switch (c)
	      {
	      case OPTION_CHANGE_SECTION_ADDRESS:
		p->vma_val = val;
		/* Drop through.  */

	      case OPTION_CHANGE_SECTION_LMA:
		p->lma_val = val;
		break;

	      case OPTION_CHANGE_SECTION_VMA:
		p->vma_val = val;
		break;
	      }
	  }
	  break;

	case OPTION_CHANGE_ADDRESSES:
	  change_section_address = parse_vma (optarg, "--change-addresses");
	  change_start = change_section_address;
	  break;

	case OPTION_CHANGE_WARNINGS:
	  change_warn = TRUE;
	  break;

	case OPTION_CHANGE_LEADING_CHAR:
	  change_leading_char = TRUE;
	  break;

	case OPTION_COMPRESS_DEBUG_SECTIONS:
	  do_debug_sections = compress;
	  break;

	case OPTION_DEBUGGING:
	  convert_debugging = TRUE;
	  break;

	case OPTION_DECOMPRESS_DEBUG_SECTIONS:
	  do_debug_sections = decompress;
	  break;

	case OPTION_GAP_FILL:
	  {
	    bfd_vma gap_fill_vma;

	    gap_fill_vma = parse_vma (optarg, "--gap-fill");
	    gap_fill = (bfd_byte) gap_fill_vma;
	    if ((bfd_vma) gap_fill != gap_fill_vma)
	      {
		char buff[20];

		sprintf_vma (buff, gap_fill_vma);

		non_fatal (_("Warning: truncating gap-fill from 0x%s to 0x%x"),
			   buff, gap_fill);
	      }
	    gap_fill_set = TRUE;
	  }
	  break;

	case OPTION_NO_CHANGE_WARNINGS:
	  change_warn = FALSE;
	  break;

	case OPTION_PAD_TO:
	  pad_to = parse_vma (optarg, "--pad-to");
	  pad_to_set = TRUE;
	  break;

	case OPTION_REMOVE_LEADING_CHAR:
	  remove_leading_char = TRUE;
	  break;

	case OPTION_REDEFINE_SYM:
	  {
	    /* Push this redefinition onto redefine_symbol_list.  */

	    int len;
	    const char *s;
	    const char *nextarg;
	    char *source, *target;

	    s = strchr (optarg, '=');
	    if (s == NULL)
	      fatal (_("bad format for %s"), "--redefine-sym");

	    len = s - optarg;
	    source = (char *) xmalloc (len + 1);
	    strncpy (source, optarg, len);
	    source[len] = '\0';

	    nextarg = s + 1;
	    len = strlen (nextarg);
	    target = (char *) xmalloc (len + 1);
	    strcpy (target, nextarg);

	    redefine_list_append ("--redefine-sym", source, target);

	    free (source);
	    free (target);
	  }
	  break;

	case OPTION_REDEFINE_SYMS:
	  add_redefine_syms_file (optarg);
	  break;

	case OPTION_SET_SECTION_FLAGS:
	  {
	    struct section_list *p;
	    const char *s;
	    int len;
	    char *name;

	    s = strchr (optarg, '=');
	    if (s == NULL)
	      fatal (_("bad format for %s"), "--set-section-flags");

	    len = s - optarg;
	    name = (char *) xmalloc (len + 1);
	    strncpy (name, optarg, len);
	    name[len] = '\0';

	    p = find_section_list (name, TRUE, SECTION_CONTEXT_SET_FLAGS);

	    p->flags = parse_flags (s + 1);
	  }
	  break;

	case OPTION_RENAME_SECTION:
	  {
	    flagword flags;
	    const char *eq, *fl;
	    char *old_name;
	    char *new_name;
	    unsigned int len;

	    eq = strchr (optarg, '=');
	    if (eq == NULL)
	      fatal (_("bad format for %s"), "--rename-section");

	    len = eq - optarg;
	    if (len == 0)
	      fatal (_("bad format for %s"), "--rename-section");

	    old_name = (char *) xmalloc (len + 1);
	    strncpy (old_name, optarg, len);
	    old_name[len] = 0;

	    eq++;
	    fl = strchr (eq, ',');
	    if (fl)
	      {
		flags = parse_flags (fl + 1);
		len = fl - eq;
	      }
	    else
	      {
		flags = -1;
		len = strlen (eq);
	      }

	    if (len == 0)
	      fatal (_("bad format for %s"), "--rename-section");

	    new_name = (char *) xmalloc (len + 1);
	    strncpy (new_name, eq, len);
	    new_name[len] = 0;

	    add_section_rename (old_name, new_name, flags);
	  }
	  break;

	case OPTION_SET_START:
	  set_start = parse_vma (optarg, "--set-start");
	  set_start_set = TRUE;
	  break;

	case OPTION_SREC_LEN:
	  Chunk = parse_vma (optarg, "--srec-len");
	  break;

	case OPTION_SREC_FORCES3:
	  S3Forced = TRUE;
	  break;

	case OPTION_STRIP_SYMBOLS:
	  add_specific_symbols (optarg, strip_specific_htab);
	  break;

	case OPTION_STRIP_UNNEEDED_SYMBOLS:
	  add_specific_symbols (optarg, strip_unneeded_htab);
	  break;

	case OPTION_KEEP_SYMBOLS:
	  add_specific_symbols (optarg, keep_specific_htab);
	  break;

	case OPTION_LOCALIZE_HIDDEN:
	  localize_hidden = TRUE;
	  break;

	case OPTION_LOCALIZE_SYMBOLS:
	  add_specific_symbols (optarg, localize_specific_htab);
	  break;

	case OPTION_LONG_SECTION_NAMES:
	  if (!strcmp ("enable", optarg))
	    long_section_names = ENABLE;
	  else if (!strcmp ("disable", optarg))
	    long_section_names = DISABLE;
	  else if (!strcmp ("keep", optarg))
	    long_section_names = KEEP;
	  else
	    fatal (_("unknown long section names option '%s'"), optarg);
	  break;

	case OPTION_GLOBALIZE_SYMBOLS:
	  add_specific_symbols (optarg, globalize_specific_htab);
	  break;

	case OPTION_KEEPGLOBAL_SYMBOLS:
	  add_specific_symbols (optarg, keepglobal_specific_htab);
	  break;

	case OPTION_WEAKEN_SYMBOLS:
	  add_specific_symbols (optarg, weaken_specific_htab);
	  break;

	case OPTION_ALT_MACH_CODE:
	  use_alt_mach_code = strtoul (optarg, NULL, 0);
	  if (use_alt_mach_code == 0)
	    fatal (_("unable to parse alternative machine code"));
	  break;

	case OPTION_PREFIX_SYMBOLS:
	  prefix_symbols_string = optarg;
	  break;

	case OPTION_PREFIX_SECTIONS:
	  prefix_sections_string = optarg;
	  break;

	case OPTION_PREFIX_ALLOC_SECTIONS:
	  prefix_alloc_sections_string = optarg;
	  break;

	case OPTION_READONLY_TEXT:
	  bfd_flags_to_set |= WP_TEXT;
	  bfd_flags_to_clear &= ~WP_TEXT;
	  break;

	case OPTION_WRITABLE_TEXT:
	  bfd_flags_to_clear |= WP_TEXT;
	  bfd_flags_to_set &= ~WP_TEXT;
	  break;

	case OPTION_PURE:
	  bfd_flags_to_set |= D_PAGED;
	  bfd_flags_to_clear &= ~D_PAGED;
	  break;

	case OPTION_IMPURE:
	  bfd_flags_to_clear |= D_PAGED;
	  bfd_flags_to_set &= ~D_PAGED;
	  break;

	case OPTION_EXTRACT_DWO:
	  strip_symbols = STRIP_NONDWO;
	  break;

	case OPTION_EXTRACT_SYMBOL:
	  extract_symbol = TRUE;
	  break;

	case OPTION_REVERSE_BYTES:
          {
            int prev = reverse_bytes;

            reverse_bytes = atoi (optarg);
            if ((reverse_bytes <= 0) || ((reverse_bytes % 2) != 0))
              fatal (_("number of bytes to reverse must be positive and even"));

            if (prev && prev != reverse_bytes)
              non_fatal (_("Warning: ignoring previous --reverse-bytes value of %d"),
                         prev);
            break;
          }

	case OPTION_FILE_ALIGNMENT:
	  pe_file_alignment = parse_vma (optarg, "--file-alignment");
	  break;

	case OPTION_HEAP:
	    {
	      char *end;
	      pe_heap_reserve = strtoul (optarg, &end, 0);
	      if (end == optarg
		  || (*end != '.' && *end != '\0'))
		non_fatal (_("%s: invalid reserve value for --heap"),
			   optarg);
	      else if (*end != '\0')
		{
		  pe_heap_commit = strtoul (end + 1, &end, 0);
		  if (*end != '\0')
		    non_fatal (_("%s: invalid commit value for --heap"),
			       optarg);
		}
	    }
	  break;

	case OPTION_IMAGE_BASE:
	  pe_image_base = parse_vma (optarg, "--image-base");
	  break;

	case OPTION_SECTION_ALIGNMENT:
	  pe_section_alignment = parse_vma (optarg,
					    "--section-alignment");
	  break;

	case OPTION_SUBSYSTEM:
	  set_pe_subsystem (optarg);
	  break;

	case OPTION_STACK:
	    {
	      char *end;
	      pe_stack_reserve = strtoul (optarg, &end, 0);
	      if (end == optarg
		  || (*end != '.' && *end != '\0'))
		non_fatal (_("%s: invalid reserve value for --stack"),
			   optarg);
	      else if (*end != '\0')
		{
		  pe_stack_commit = strtoul (end + 1, &end, 0);
		  if (*end != '\0')
		    non_fatal (_("%s: invalid commit value for --stack"),
			       optarg);
		}
	    }
	  break;

	case 0:
	  /* We've been given a long option.  */
	  break;

	case 'H':
	case 'h':
	  copy_usage (stdout, 0);

	default:
	  copy_usage (stderr, 1);
	}
    }

  if (formats_info)
    {
      display_info ();
      return 0;
    }

  if (show_version)
    print_version ("objcopy");

  if (interleave && copy_byte == -1)
    fatal (_("interleave start byte must be set with --byte"));

  if (copy_byte >= interleave)
    fatal (_("byte number must be less than interleave"));

  if (copy_width > interleave - copy_byte)
    fatal (_("interleave width must be less than or equal to interleave - byte`"));

  if (optind == argc || optind + 2 < argc)
    copy_usage (stderr, 1);

  input_filename = argv[optind];
  if (optind + 1 < argc)
    output_filename = argv[optind + 1];

  default_deterministic ();

  /* Default is to strip no symbols.  */
  if (strip_symbols == STRIP_UNDEF && discard_locals == LOCALS_UNDEF)
    strip_symbols = STRIP_NONE;

  if (output_target == NULL)
    output_target = input_target;

  /* Convert input EFI target to PEI target.  */
  if (input_target != NULL
      && strncmp (input_target, "efi-", 4) == 0)
    {
      char *efi;

      efi = xstrdup (output_target + 4);
      if (strncmp (efi, "bsdrv-", 6) == 0
	  || strncmp (efi, "rtdrv-", 6) == 0)
	efi += 2;
      else if (strncmp (efi, "app-", 4) != 0)
	fatal (_("unknown input EFI target: %s"), input_target);

      input_target = efi;
      convert_efi_target (efi);
    }

  /* Convert output EFI target to PEI target.  */
  if (output_target != NULL
      && strncmp (output_target, "efi-", 4) == 0)
    {
      char *efi;

      efi = xstrdup (output_target + 4);
      if (strncmp (efi, "app-", 4) == 0)
	{
	  if (pe_subsystem == -1)
	    pe_subsystem = IMAGE_SUBSYSTEM_EFI_APPLICATION;
	}
      else if (strncmp (efi, "bsdrv-", 6) == 0)
	{
	  if (pe_subsystem == -1)
	    pe_subsystem = IMAGE_SUBSYSTEM_EFI_BOOT_SERVICE_DRIVER;
	  efi += 2;
	}
      else if (strncmp (efi, "rtdrv-", 6) == 0)
	{
	  if (pe_subsystem == -1)
	    pe_subsystem = IMAGE_SUBSYSTEM_EFI_RUNTIME_DRIVER;
	  efi += 2;
	}
      else
	fatal (_("unknown output EFI target: %s"), output_target);

      if (pe_file_alignment == (bfd_vma) -1)
	pe_file_alignment = PE_DEF_FILE_ALIGNMENT;
      if (pe_section_alignment == (bfd_vma) -1)
	pe_section_alignment = PE_DEF_SECTION_ALIGNMENT;

      output_target = efi;
      convert_efi_target (efi);
    }

  if (preserve_dates)
    if (stat (input_filename, & statbuf) < 0)
      fatal (_("warning: could not locate '%s'.  System error message: %s"),
	     input_filename, strerror (errno));

  /* If there is no destination file, or the source and destination files
     are the same, then create a temp and rename the result into the input.  */
  if (output_filename == NULL
      || filename_cmp (input_filename, output_filename) == 0)
    tmpname = make_tempname (input_filename);
  else
    tmpname = output_filename;

  if (tmpname == NULL)
    fatal (_("warning: could not create temporary file whilst copying '%s', (error: %s)"),
	   input_filename, strerror (errno));

  copy_file (input_filename, tmpname, input_target, output_target, input_arch);
  if (status == 0)
    {
      if (preserve_dates)
	set_times (tmpname, &statbuf);
      if (tmpname != output_filename)
	status = (smart_rename (tmpname, input_filename,
				preserve_dates) != 0);
    }
  else
    unlink_if_ordinary (tmpname);

  if (change_warn)
    {
      struct section_list *p;

      for (p = change_sections; p != NULL; p = p->next)
	{
	  if (! p->used)
	    {
	      if (p->context & (SECTION_CONTEXT_SET_VMA | SECTION_CONTEXT_ALTER_VMA))
		{
		  char buff [20];

		  sprintf_vma (buff, p->vma_val);

		  /* xgettext:c-format */
		  non_fatal (_("%s %s%c0x%s never used"),
			     "--change-section-vma",
			     p->pattern,
			     p->context & SECTION_CONTEXT_SET_VMA ? '=' : '+',
			     buff);
		}

	      if (p->context & (SECTION_CONTEXT_SET_LMA | SECTION_CONTEXT_ALTER_LMA))
		{
		  char buff [20];

		  sprintf_vma (buff, p->lma_val);

		  /* xgettext:c-format */
		  non_fatal (_("%s %s%c0x%s never used"),
			     "--change-section-lma",
			     p->pattern,
			     p->context & SECTION_CONTEXT_SET_LMA ? '=' : '+',
			     buff);
		}
	    }
	}
    }

  return 0;
}

int
main (int argc, char *argv[])
{
#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

  program_name = argv[0];
  xmalloc_set_program_name (program_name);

  START_PROGRESS (program_name, 0);

  expandargv (&argc, &argv);

  strip_symbols = STRIP_UNDEF;
  discard_locals = LOCALS_UNDEF;

  bfd_init ();
  set_default_bfd_target ();

  if (is_strip < 0)
    {
      int i = strlen (program_name);
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
      /* Drop the .exe suffix, if any.  */
      if (i > 4 && FILENAME_CMP (program_name + i - 4, ".exe") == 0)
	{
	  i -= 4;
	  program_name[i] = '\0';
	}
#endif
      is_strip = (i >= 5 && FILENAME_CMP (program_name + i - 5, "strip") == 0);
    }

  create_symbol_htabs ();

  if (is_strip)
    strip_main (argc, argv);
  else
    copy_main (argc, argv);

  END_PROGRESS (program_name);

  return status;
}
@


1.164
log
@	PR binutils/15033
	* objcopy.c (enum change_action): Delete.
	(struct section_list): Delete remove, copy, change_vma, change_lma
	and set_flags fields.  Add context field.
	(find_section_list): Add a context parameter.  Add support for
	wildcard characters in section names.
	(is_strip_section): Check for sections being both  copied and
	removed.
	(copy_object): Pass context to find_section_list.
	(setup_section): Likewise.
	(copy_section): Likewise.
	(copy_main): Likewise.
	* doc/binutils: Document the new behaviour.
	* NEWS: Mention the new feature
@
text
@d3665 1
a3665 1
	    unsigned int context;
@


1.163
log
@	PR binutils/15125
	* objcopy.c (copy_object): Provide a helpful warning message when
	adding a gnu_debuglink section to an object which already contains
	one.
@
text
@d2 1
a2 3
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013
   Free Software Foundation, Inc.
a114 8
/* What kind of change to perform.  */
enum change_action
{
  CHANGE_IGNORE,
  CHANGE_MODIFY,
  CHANGE_SET
};

d119 1
a119 1
  const char *		name;	   /* Section name.  */
d121 12
a132 3
  bfd_boolean		remove;	   /* Whether to remove this section.  */
  bfd_boolean		copy;	   /* Whether to copy this section.  */
  enum change_action	change_vma;/* Whether to change or set VMA.  */
a133 1
  enum change_action	change_lma;/* Whether to change or set LMA.  */
a134 1
  bfd_boolean		set_flags; /* Whether to set the section flags.	 */
d712 26
a737 1
/* Find and optionally add an entry in the change_sections list.  */
d740 1
a740 1
find_section_list (const char *name, bfd_boolean add)
d744 2
d747 41
a787 2
    if (strcmp (p->name, name) == 0)
      return p;
d793 1
a793 1
  p->name = name;
d795 1
a795 4
  p->remove = FALSE;
  p->copy = FALSE;
  p->change_vma = CHANGE_IGNORE;
  p->change_lma = CHANGE_IGNORE;
a797 1
  p->set_flags = FALSE;
a798 1

d1049 1
d1051 8
a1058 1
      p = find_section_list (bfd_get_section_name (abfd, sec), FALSE);
d1060 1
a1060 1
      if (sections_removed && p != NULL && p->remove)
d1062 1
a1062 1
      if (sections_copied && (p == NULL || ! p->copy))
d1765 2
a1766 1
	  pset = find_section_list (padd->name, FALSE);
a1767 4
	    pset->used = TRUE;

	  flags = SEC_HAS_CONTENTS | SEC_READONLY | SEC_DATA;
	  if (pset != NULL && pset->set_flags)
d1769 2
d1803 11
d1816 1
a1816 7
	      if (pset->change_vma != CHANGE_IGNORE)
		if (! bfd_set_section_vma (obfd, padd->section,
					   pset->vma_val))
		  {
		    bfd_nonfatal_message (NULL, obfd, padd->section, NULL);
		    return FALSE;
		  }
d1818 3
a1820 1
	      if (pset->change_lma != CHANGE_IGNORE)
d1822 2
a1823 9
		  padd->section->lma = pset->lma_val;

		  if (! bfd_set_section_alignment
		      (obfd, padd->section,
		       bfd_section_alignment (obfd, padd->section)))
		    {
		      bfd_nonfatal_message (NULL, obfd, padd->section, NULL);
		      return FALSE;
		    }
a2598 4
  p = find_section_list (bfd_section_name (ibfd, isection), FALSE);
  if (p != NULL)
    p->used = TRUE;

d2620 4
a2623 1
  if (p != NULL && p->set_flags)
d2666 9
a2674 4
  if (p != NULL && p->change_vma == CHANGE_MODIFY)
    vma += p->vma_val;
  else if (p != NULL && p->change_vma == CHANGE_SET)
    vma = p->vma_val;
d2685 3
a2687 1
  if ((p != NULL) && p->change_lma != CHANGE_IGNORE)
d2689 1
a2689 1
      if (p->change_lma == CHANGE_MODIFY)
d2691 1
a2691 1
      else if (p->change_lma == CHANGE_SET)
a2692 2
      else
	abort ();
a2883 2
  p = find_section_list (bfd_get_section_name (ibfd, isection), FALSE);

d2950 3
a2952 1
  else if (p != NULL && p->set_flags && (p->flags & SEC_HAS_CONTENTS) != 0)
a3153 1
  struct section_list *p;
d3171 1
a3171 2
	  p = find_section_list (optarg, TRUE);
	  p->remove = TRUE;
a3443 1
  struct section_list *p;
d3496 1
a3496 4
	  p = find_section_list (optarg, TRUE);
	  if (p->remove)
	    fatal (_("%s both copied and removed"), optarg);
	  p->copy = TRUE;
d3501 1
a3501 4
	  p = find_section_list (optarg, TRUE);
	  if (p->copy)
	    fatal (_("%s both copied and removed"), optarg);
	  p->remove = TRUE;
d3664 2
a3670 1
	    enum change_action what = CHANGE_IGNORE;
d3676 1
d3680 1
d3684 1
d3699 16
d3721 1
a3721 1
	    p = find_section_list (name, TRUE);
d3724 2
a3725 7

	    switch (*s)
	      {
	      case '=': what = CHANGE_SET; break;
	      case '-': val  = - val; /* Drop through.  */
	      case '+': what = CHANGE_MODIFY; break;
	      }
d3730 1
a3730 2
		p->change_vma = what;
		p->vma_val    = val;
d3734 1
a3734 2
		p->change_lma = what;
		p->lma_val    = val;
d3738 1
a3738 2
		p->change_vma = what;
		p->vma_val    = val;
d3837 1
d3851 1
a3851 1
	    p = find_section_list (name, TRUE);
a3852 1
	    p->set_flags = TRUE;
d4201 2
d4207 1
a4207 1
	      if (p->change_vma != CHANGE_IGNORE)
d4216 2
a4217 2
			     p->name,
			     p->change_vma == CHANGE_SET ? '=' : '+',
d4221 1
a4221 1
	      if (p->change_lma != CHANGE_IGNORE)
d4230 2
a4231 2
			     p->name,
			     p->change_lma == CHANGE_SET ? '=' : '+',
@


1.162
log
@	* objcopy.c (parse_flags): Add merge and strings section flags.
@
text
@d1766 13
a1778 2
      gnu_debuglink_section = bfd_create_gnu_debuglink_section
	(obfd, gnu_debuglink_filename);
d1780 7
a1786 7
      if (gnu_debuglink_section == NULL)
	{
	  bfd_nonfatal_message (NULL, obfd, NULL,
				_("cannot create debug link section `%s'"),
				gnu_debuglink_filename);
	  return FALSE;
	}
d1788 39
a1826 39
      /* Special processing for PE format files.  We
	 have no way to distinguish PE from COFF here.  */
      if (bfd_get_flavour (obfd) == bfd_target_coff_flavour)
	{
	  bfd_vma debuglink_vma;
	  asection * highest_section;
	  asection * sec;

	  /* The PE spec requires that all sections be adjacent and sorted
	     in ascending order of VMA.  It also specifies that debug
	     sections should be last.  This is despite the fact that debug
	     sections are not loaded into memory and so in theory have no
	     use for a VMA.

	     This means that the debuglink section must be given a non-zero
	     VMA which makes it contiguous with other debug sections.  So
	     walk the current section list, find the section with the
	     highest VMA and start the debuglink section after that one.  */
	  for (sec = obfd->sections, highest_section = NULL;
	       sec != NULL;
	       sec = sec->next)
	    if (sec->vma > 0
		&& (highest_section == NULL
		    || sec->vma > highest_section->vma))
	      highest_section = sec;

	  if (highest_section)
	    debuglink_vma = BFD_ALIGN (highest_section->vma
				       + highest_section->size,
				       /* FIXME: We ought to be using
					  COFF_PAGE_SIZE here or maybe
					  bfd_get_section_alignment() (if it
					  was set) but since this is for PE
					  and we know the required alignment
					  it is easier just to hard code it.  */
				       0x1000);
	  else
	    /* Umm, not sure what to do in this case.  */
	    debuglink_vma = 0x1000;
d1828 2
a1829 1
	  bfd_set_section_vma (obfd, gnu_debuglink_section, debuglink_vma);
@


1.161
log
@* objcopy.c : Enable long section names for OPTION_ADD_GNU_DEBUGLINK.
@
text
@d693 2
d705 1
a705 1
		 "alloc, load, noload, readonly, debug, code, data, rom, share, contents");
@


1.160
log
@binutils/
	* objcopy.c (deterministic): Make int rather than bfd_boolean,
	initialize to -1.
	(strip_options, copy_options): Add -U/--disable-deterministic-archives.
	(default_deterministic): New function.
	(strip_main, copy_main): Handle -U.  Call default_deterministic.
	(copy_usage, strip_usage): Describe -U.  Cite whether -D or -U is
	the default based on DEFAULT_AR_DETERMINISTIC.
	* doc/binutils.texi (objcopy, strip): Describe -U and effect of
	configure options on -D.

	* ar.c (default_deterministic): Comment fix.
@
text
@d3456 1
@


1.159
log
@Don't read beyond section end

	* objcopy.c (copy_section): Don't read beyond section end.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012
d89 1
a89 1
static bfd_boolean deterministic;	/* Enable deterministic archives.  */
d328 1
d380 1
d494 9
a502 1
  -p --preserve-dates              Copy modified/access timestamps to the output\n\
d505 3
d618 9
d629 3
d3053 9
d3122 3
d3169 2
d3253 1
a3253 1
      { "native", 0, IMAGE_SUBSYSTEM_NATIVE },  
d3495 4
d3933 1
a3933 1
	
d3951 1
a3951 1
	
d3955 1
a3955 1
	
d3960 1
a3960 1
	
d3964 1
a3964 1
	
d3982 1
a3982 1
	
d4021 2
@


1.158
log
@        * objcopy.c (is_strip_section_1): Don't strip
        .reloc section by default.
@
text
@d2826 5
a2830 1
	      *to++ = from[i];
@


1.157
log
@binutils/

	* doc/binutils.texi (objcopy): Add --strip-dwo, --extract-dwo options.
	(strip): Add --strip-dwo option.
	* objcopy.c (enum strip_action): Add STRIP_DWO, STRIP_NONDWO.
	(enum command_line_switch): Add OPTION_EXTRACT_DWO, OPTION_STRIP_DWO.
	(strip_options): Add --strip-dwo option.
	(copy_options): Add --extract-dwo, --strip-dwo options.
	(copy_usage): Likewise.
	(strip_usage): Add --strip-dwo option.
	(is_dwo_section): New function.
	(is_strip_section_1): Check for DWO sections.
	(copy_object): Check for --strip-dwo, --extract-dwo options.
	(copy_relocations_in_section): Discard relocations for DWO sections.
	Discard entire relocation section when no relocations.
	(strip_main): Add --strip-dwo option.
	(copy_main): Add --strip-dwo, --extract-dwo options.
@
text
@d105 1
a105 1
static enum strip_action strip_symbols;
d980 7
a986 1
	return TRUE;
@


1.157.2.1
log
@binutils/
	* objcopy.c (deterministic): Make int rather than bfd_boolean,
	initialize to -1.
	(strip_options, copy_options): Add -U/--disable-deterministic-archives.
	(default_deterministic): New function.
	(strip_main, copy_main): Handle -U.  Call default_deterministic.
	(copy_usage, strip_usage): Describe -U.  Cite whether -D or -U is
	the default based on DEFAULT_AR_DETERMINISTIC.
	* doc/binutils.texi (objcopy, strip): Describe -U and effect of
	configure options on -D.

	* ar.c (default_deterministic): Comment fix.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011, 2012, 2013
d89 1
a89 1
static int deterministic = -1;		/* Enable deterministic archives.  */
a327 1
  {"disable-deterministic-archives", no_argument, 0, 'U'},
a378 1
  {"disable-deterministic-archives", no_argument, 0, 'U'},
d492 1
a492 9
  -p --preserve-dates              Copy modified/access timestamps to the output\n"));
  if (DEFAULT_AR_DETERMINISTIC)
    fprintf (stream, _("\
  -D --enable-deterministic-archives\n\
                                   Produce deterministic output when stripping archives (default)\n\
  -U --disable-deterministic-archives\n\
                                   Disable -D behavior\n"));
  else
    fprintf (stream, _("\
a494 3
  -U --disable-deterministic-archives\n\
                                   Disable -D behavior (default)\n"));
  fprintf (stream, _("\
a604 9
"));
  if (DEFAULT_AR_DETERMINISTIC)
    fprintf (stream, _("\
  -D --enable-deterministic-archives\n\
                                   Produce deterministic output when stripping archives (default)\n\
  -U --disable-deterministic-archives\n\
                                   Disable -D behavior\n"));
  else
    fprintf (stream, _("\
a606 3
  -U --disable-deterministic-archives\n\
                                   Disable -D behavior (default)\n"));
  fprintf (stream, _("\
a3017 9
/* If neither -D nor -U was specified explicitly,
   then use the configured default.  */
static void
default_deterministic (void)
{
  if (deterministic < 0)
    deterministic = DEFAULT_AR_DETERMINISTIC;
}

a3077 3
	case 'U':
	  deterministic = FALSE;
	  break;
a3121 2
  default_deterministic ();

d3204 1
a3204 1
      { "native", 0, IMAGE_SUBSYSTEM_NATIVE },
a3445 4
	case 'U':
	  deterministic = FALSE;
	  break;

d3880 1
a3880 1

d3898 1
a3898 1

d3902 1
a3902 1

d3907 1
a3907 1

d3911 1
a3911 1

d3929 1
a3929 1

a3967 2
  default_deterministic ();

@


1.156
log
@	* doc/binutils.texi: Add -D/--enable-deterministic-archives option
	to strip and objcopy.
	* objcopy.c (deterministic): New global variable.
	(strip_options): Add --enable-deterministic-archives.
	(copy_options): Likewise.
	(copy_usage): Likewise.
	(strip_usage): Likewise.
	(copy_archive): When stripping all, don't add archive map; set
	deterministic output when requested.
	(strip_main): Add -D/--enable-deterministic-archives option.
	(copy_main): Likewise.
@
text
@d99 2
d319 3
a321 1
    OPTION_SUBSYSTEM
d346 1
d382 1
d429 1
d500 1
d507 1
d610 1
d945 11
d982 3
d989 3
d1879 2
d2688 2
a2689 2
  /* Core files do not need to be relocated.  */
  if (bfd_get_format (obfd) == bfd_core)
d2710 4
a2713 1
    bfd_set_reloc (obfd, osection, NULL, 0);
d3057 3
d3390 4
d3855 4
@


1.155
log
@Don't generate empty reloc sections

binutils/

	PR binutils/13947
	* objcopy.c (copy_object): Call copy_relocations_in_section
	before copy_section.
	(skip_section): New.
	(copy_relocations_in_section): Likewise.
	(copy_section): Use skip_section.  Don't copy relocations here.

binutils/testsuite/

	PR binutils/13947
	* binutils-all/i386/compressed-1b.d: Remove empty REL section.
	* binutils-all/i386/compressed-1c.d: Likewise.

	* binutils-all/x86-64/compressed-1b.d: Remove empty RELA
	section.
	* binutils-all/x86-64/compressed-1c.d: Likewise.
@
text
@d89 1
d326 1
d376 1
d486 2
d596 2
d2040 4
a2043 1
  obfd->has_armap = ibfd->has_armap;
d2046 3
d3040 3
d3403 4
@


1.154
log
@	* sysdep.h: Include sys/stat.h here.
	* ar.c: Don't include headers already included by sysdep.h.
	* bucomm.c: Likewise.
	* budbg.h: Likewise.
	* dlltool.h: Likewise.
	* elfedit.c: Likewise.
	* nlmconv.c: Likewise.
	* objcopy.c: Likewise.
	* objdump.c: Likewise.
	* objdump.h: Likewise.
	* readelf.c: Likewise.
	* rename.c: Likewise.
	* resrc.c: Likewise.
	* strings.c: Likewise.
	* windres.c: Likewise.
	* od-macho.c: Ensure #include sysdep.h is first.
	* od-xcoff.c: Likewise.
	* dllwrap.c: Remove alloca pragma handled by sysdep.h, and
	remove duplicate headers.
	* dlltool.c: Likewise and ensure #include sysdep.h is first.
@
text
@d462 1
d1889 3
d2595 1
a2595 3
/* Copy the data of input section ISECTION of IBFD
   to an output section with the same name in OBFD.
   If stripping then don't copy any relocation info.  */
d2597 2
a2598 2
static void
copy_section (bfd *ibfd, sec_ptr isection, void *obfdarg)
a2599 4
  bfd *obfd = (bfd *) obfdarg;
  struct section_list *p;
  arelent **relpp;
  long relcount;
a2601 1
  long relsize;
d2607 4
a2610 1
    return;
d2613 1
a2613 1
    return;
d2617 1
a2617 1
    return;
d2623 17
a2639 1
    return;
d2641 1
a2641 1
  if (extract_symbol)
d2644 1
a2644 1
  p = find_section_list (bfd_get_section_name (ibfd, isection), FALSE);
d2701 4
a2704 1
	free (relpp);
d2706 20
@


1.153
log
@Remove the group section if all members are removed.

binutils/

2011-09-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/13180
	* objcopy.c (is_strip_section_1): New.
	(is_strip_section): Use it.  Remove the group section if all
	members are removed.

binutils/testsuite/

2011-09-15  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/13180
	* binutils-all/group-6.d: New.
	* binutils-all/group-6.s: Likewise.

	* binutils-all/objcopy.exp: Run group-6 for ELF targrts.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
a32 1
#include <sys/stat.h>
@


1.152
log
@	* objcopy.c (copy_archive): Check bfd_openw result in unknown object
	case.  Rewrite without goto.
@
text
@d928 1
a928 1
/* See if a section is being removed.  */
d931 1
a931 1
is_strip_section (bfd *abfd ATTRIBUTE_UNUSED, asection *sec)
d958 11
d973 1
d987 13
@


1.151
log
@Make the unknown archive element readable.

2011-04-03  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/12632
	* objcopy.c (copy_unknown_object): Make the archive element
	readable.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d2027 1
d2065 13
a2077 1
      if (bfd_check_format (this_element, bfd_object))
d2079 8
a2086 6
	  /* PR binutils/3110: Cope with archives
	     containing multiple target types.  */
	  if (force_output_target)
	    output_bfd = bfd_openw (output_name, output_target);
	  else
	    output_bfd = bfd_openw (output_name, bfd_get_target (this_element));
d2088 4
a2091 1
	  if (output_bfd == NULL)
d2094 1
a2095 1
	      return;
d2097 1
d2099 1
a2099 16
 	  del = ! copy_object (this_element, output_bfd, input_arch);

	  if (! del
	      || bfd_get_arch (this_element) != bfd_arch_unknown)
	    {
	      if (!bfd_close (output_bfd))
		{
		  bfd_nonfatal_message (output_name, NULL, NULL, NULL);
		  /* Error in new object file. Don't change archive.  */
		  status = 1;
		}
	    }
	  else
	    goto copy_unknown_element;
	}
      else
a2100 5
	  bfd_nonfatal_message (NULL, this_element, NULL,
				_("Unable to recognise the format of file"));

	  output_bfd = bfd_openw (output_name, output_target);
copy_unknown_element:
@


1.150
log
@2011-03-14  Michael Snyder  <msnyder@@vmware.com>

	* objcopy.c (set_pe_subsystem): Free subsystem.
@
text
@d1402 3
a1404 1
  chmod (bfd_get_filename (obfd), buf.st_mode);
@


1.149
log
@ChangeLog binutils/
2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* debug.c (debug_start_source): Use filename_(n)cmp.
	* ieee.c (ieee_finish_compilation_unit): Likewise.
	(ieee_lineno): Likewise.
	* nlmconv.c (main): Likewise.
	* objcopy.c (strip_main): Likewise.
	(copy_main): Likewise.
	* objdump.c (show_line): Likewise.
	(dump_reloc_set): Likewise.
	* srconv.c (main): Likewise.
	* wrstabs.c (stab_lineno): Likewise.

ChangeLog gas/
2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* depend.c (register_dependency): Use filename_(n)cmp.
	* dwarf2dbg.c (get_filenum): Likewise.
	* ecoff.c (add_file): Likewise.
	(ecoff_generate_asm_lineno): Likewise.
	* input-scrub.c (new_logical_line_flags): Likewise.
	* listing.c (file_info): Likewise.
	(listing_newline): Likewise.
	* remap.c (remap_debug_filename): Likewise.
	* stabs.c (generate_asm_file): Likewise.
	(stabs_generate_asm_lineno): Likewise.
@
text
@d3160 2
@


1.148
log
@bfd/
	* hash.c (bfd_hash_hash): Extract from..
	(bfd_hash_lookup): ..here.
	(bfd_hash_rename): New function.
	* section.c (bfd_rename_section): New function.
	* bfd-in.h (bfd_hash_rename): Declare.
	* bfd-in2.h: Regenerate.
	* elf.c (_bfd_elf_make_section_from_shdr): Rename input sections
	when compressing or decompressing.  Don't assert name match.
	* elf64-hppa.c (get_reloc_section): Don't assert name match.
	* elfxx-ia64.c (get_reloc_section): Likewise.
binutils/
	* objcopy.c (copy_main): No need to rename sections when compressing
	or decompressing.
binutils/testsuite/
	* binutils-all/objdump.W: Adjust expected result for debug section
	rename.
@
text
@d3038 2
a3039 1
      if (output_file == NULL || strcmp (argv[i], output_file) == 0)
d3906 2
a3907 1
  if (output_filename == NULL || strcmp (input_filename, output_filename) == 0)
@


1.147
log
@Add compressed debug section support to binutils and ld.

bfd/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>
	    Cary Coutant  <ccoutant@@google.com>

	* archive.c (bfd_openr_next_archived_file): Copy BFD_COMPRESS
	and BFD_DECOMPRESS.

	* bfd.c (BFD_COMPRESS): New.
	(BFD_DECOMPRESS): Likewise.
	(BFD_FLAGS_SAVED): Likewise.
	(bfd_preserve_save): Replace BFD_IN_MEMORY with BFD_FLAGS_SAVED.

	* compress.c (bfd_uncompress_section_contents): Removed.
	(get_uncompressed_size): New.
	(decompress_contents): Likewise.
	(bfd_compress_section_contents): Likewise.
	(bfd_get_full_section_contents): Likewise.
	(bfd_is_section_compressed): Likewise.
	(bfd_init_section_decompress_status): Likewise.
	(bfd_init_section_compress_status): Likewise.

	* dwarf2.c (dwarf_debug_sections): New.
	(dwarf_debug_section_enum): Likewise.
	(read_section): Remove section_name and compressed_section_name.
	Add dwarf_debug_section_enum.  Try compressed debug section.
	(read_indirect_string): Updated.
	(read_abbrevs): Likewise.
	(decode_line_info): Likewise.
	(read_debug_ranges): Likewise.
	(find_line): Updated.

	* ecoff.c (bfd_debug_section): Add compress_status and
	compressed_size.

	* elf.c (_bfd_elf_make_section_from_shdr): Call
	bfd_is_section_compressed to check if a DWARF debug section is
	compressed.  Call bfd_init_section_compress_status or
	bfd_init_section_decompress_status if needed.

	* elflink.c (elf_link_input_bfd): Replace bfd_get_section_contents
	with bfd_get_full_section_contents.
	* merge.c (_bfd_add_merge_section): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents): Likewise.
	* simple.c (bfd_simple_get_relocated_section_contents): Likewise.

	* elfxx-target.h (TARGET_BIG_SYM): Allow BFD_COMPRESS and
	BFD_DECOMPRESS.
	(TARGET_LITTLE_SYM): Likewise.

	* libbfd-in.h (dwarf_debug_section): New.
	(dwarf_debug_sections): Likewise.

	* libbfd.c (_bfd_generic_get_section_contents): Issue an error
	when getting contents on compressed/decompressed section.

	* section.c (COMPRESS_SECTION_NONE): New.
	(COMPRESS_SECTION_DONE): Likewise.
	(DECOMPRESS_SECTION_SIZED): Likewise.
	(BFD_FAKE_SECTION): Add compress_status and compressed_size.
	(bfd_malloc_and_get_section): Replace bfd_get_section_contents
	with bfd_get_full_section_contents.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.

binutils/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* addr2line.c (process_file): Set BFD_DECOMPRESS.

	* objcopy.c (do_debug_sections): New.
	(OPTION_COMPRESS_DEBUG_SECTIONS): New.
	(OPTION_DECOMPRESS_DEBUG_SECTIONS): Likewise.
	(copy_options): Add OPTION_COMPRESS_DEBUG_SECTIONS and
	OPTION_DECOMPRESS_DEBUG_SECTIONS.
	(copy_usage): Add --compress-debug-sections and
	--decompress-debug-sections.
	(copy_file): Set BFD_COMPRESS or BFD_DECOMPRESS.
	(copy_section): Replace bfd_get_section_contents with
	bfd_get_full_section_contents.
	(copy_main): Handle OPTION_COMPRESS_DEBUG_SECTIONS and
	OPTION_DECOMPRESS_DEBUG_SECTIONS.  Check do_debug_sections to
	rename DWARF debug sections.

	* objdump.c (load_specific_debug_section): Replace
	bfd_get_section_contents with bfd_get_full_section_contents.
	Remove bfd_uncompress_section_contents.
	(dump_section): Replace bfd_get_section_contents with
	bfd_get_full_section_contents.
	(display_file): Set BFD_DECOMPRESS if needed.

	* readelf.c (uncompress_section_contents): Set buffer to NULL
	to indiate decompression failure.
	(load_specific_debug_section): Always call
	uncompress_section_contents.

	* doc/binutils.texi: Document --compress-debug-sections and
	--decompress-debug-sections.

binutils/testsuite/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* binutils-all/compress.exp: New.
	* binutils-all/dw2-1.S: Likewise.
	* binutils-all/dw2-2.S: Likewise.
	* binutils-all/libdw2-compressed.out: Likewise.
	* binutils-all/libdw2.out: Likewise.

gas/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* write.c (compress_debug): Optimize section flags check.

gas/testsuite/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf/dwarf2-1.s: Replace .zdebug_abbrev section with
	.debug_abbrev section.
	* elf/dwarf2-2.3: Likewise.

	* elf/dwarf2-1.d: Pass --compress-debug-sections to assembler.
	Updated.
	* elf/dwarf2-2.d: Likewise.

	* gas/i386/i386.exp: Remove xfail on dw2-compress-2 and
	x86-64-dw2-compress-2.

ld/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldfile.c (ldfile_try_open_bfd): Set BFD_DECOMPRESS after
	bfd_openr returns.
	* emultempl/elf32.em (gld${EMULATION_NAME}_try_needed): Likewise.

	* scripttempl/elf.sc: Include compressed DWARF debug sections.

ld/testsuite/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-elf/compress.exp: New.
	* ld-elf/compress1.s: Likewise.
	* ld-elf/compress1a.d: Likewise.
	* ld-elf/compress1b.d: Likewise.
	* ld-elf/compress1c.d: Likewise.
@
text
@a3198 1
  struct dwarf_debug_section *d;
a3913 16
  switch (do_debug_sections)
    {
    case compress:
      for (d = dwarf_debug_sections; d->uncompressed_name; d++)
	add_section_rename (d->uncompressed_name, d->compressed_name,
			    (flagword) -1);
      break;
    case decompress:
      for (d = dwarf_debug_sections; d->uncompressed_name; d++)
	add_section_rename (d->compressed_name, d->uncompressed_name,
			    (flagword) -1);
      break;
    default:
      break;
    }

@


1.147.2.1
log
@backport from mainline
@
text
@d3199 1
d3915 16
@


1.147.2.2
log
@	PR 12365
	PR 12613
	PR 12632
	PR 12739
	PR 12753
	PR 12760
	PR 12763
Apply fix from mainline along with assorted other small fixes.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
d1402 1
a1402 3
  /* We should at least to be able to read it back when copying an
     unknown object in an archive.  */
  chmod (bfd_get_filename (obfd), buf.st_mode | S_IRUSR);
a2024 1
      bfd_boolean ok_object;
d2062 1
a2062 13
      ok_object = bfd_check_format (this_element, bfd_object);
      if (!ok_object)
	bfd_nonfatal_message (NULL, this_element, NULL,
			      _("Unable to recognise the format of file"));

      /* PR binutils/3110: Cope with archives
	 containing multiple target types.  */
      if (force_output_target || !ok_object)
	output_bfd = bfd_openw (output_name, output_target);
      else
	output_bfd = bfd_openw (output_name, bfd_get_target (this_element));

      if (output_bfd == NULL)
d2064 6
a2069 4
	  bfd_nonfatal_message (output_name, NULL, NULL, NULL);
	  status = 1;
	  return;
	}
d2071 1
a2071 8
      if (ok_object)
	{
	  del = !copy_object (this_element, output_bfd, input_arch);

	  if (del && bfd_get_arch (this_element) == bfd_arch_unknown)
	    /* Try again as an unknown object file.  */
	    ok_object = FALSE;
	  else if (!bfd_close (output_bfd))
a2073 1
	      /* Error in new object file. Don't change archive.  */
d2075 1
d2077 15
d2093 4
d2098 2
a2099 2
      if (!ok_object)
	{
@


1.146
log
@        * objcopy.c: Add --interleave-width option to allow interleaving
        of more than one byte at a time.
        (copy_width): New variable.
        (copy_options): Add --interleave-width.
        (copy_section): When interleaving copy in units of copy_width
        bytes.
        (copy_main): Parse the new option.
        * doc/binutils: Document the new option.
        * NEWS: Mention the new feature.

        * binutils-all/objcopy.exp: Add test of new --interleave-width
        option.
@
text
@d197 8
d270 1
d272 1
d370 1
d372 1
d566 2
d2210 12
d2666 1
a2666 1
      void *memhunk = xmalloc (size);
d2668 1
a2668 1
      if (!bfd_get_section_contents (ibfd, isection, memhunk, 0, size))
d3199 1
d3492 4
d3500 4
d3915 16
@


1.145
log
@	* objcopy.c (copy_usage): Tweak previous typofix.
@
text
@d83 1
a83 1
/* If `copy_byte' >= 0, copy only that byte of every `interleave' bytes.  */
d85 2
a86 1
static int interleave = 4;
d306 1
d373 2
a374 1
  {"interleave", required_argument, 0, 'i'},
d494 2
a495 1
  -i --interleave <number>         Only copy one out of every <number> bytes\n\
d2450 1
a2450 1
    size = (size + interleave - 1) / interleave;
d2681 1
d2684 2
a2685 1
	    *to++ = *from;
d2687 1
a2687 1
	  size = (size + interleave - 1 - copy_byte) / interleave;
d3192 14
a3205 3
	  interleave = atoi (optarg);
	  if (interleave < 1)
	    fatal (_("interleave must be positive"));
d3788 3
d3794 3
@


1.144
log
@Fix a typo in "objcopy --help".

2010-07-17  H.J. Lu  <hongjiu.lu@@intel.com>

	* objcopy.c (copy_usage): Fix a typo.
@
text
@d549 1
a549 1
                                   Set PE subsystem to <name> [& <version>]]\n\
@


1.143
log
@   	PR binutils/3166
	* objcopy.c (is_strip_section): Revert 2006-09-05.
	(setup_section): Make SHT_GROUP section nobits.
@
text
@d549 1
a549 1
                                   Set PE subsystem to <name> [& <version>]\n]\
@


1.142
log
@	* objcopy.c (copy_object): Set SEC_LINKER_CREATED when adding
	sections.

	testsuite/
	* binutils-all/note-1.d: New.
	* binutils-all/objcopy.exp: Add it.
@
text
@a944 6
      /* PR binutils/3166
	 Group sections look like debugging sections but they are not.
	 (They have a non-zero size but they are not ALLOCated).  */
      if (strip_symbols == STRIP_NONDEBUG)
	return TRUE;

d2416 3
a2418 3
	   && (flags & SEC_ALLOC) != 0
	   && (ibfd->xvec->flavour != bfd_target_elf_flavour
	       || elf_section_type (isection) != SHT_NOTE))
d2420 1
a2420 1
      flags &= ~(SEC_HAS_CONTENTS | SEC_LOAD);
d2429 1
a2429 1
	  isection->flags &= ~(SEC_HAS_CONTENTS | SEC_LOAD);
@


1.141
log
@binutils/:
	* objcopy.c (copy_main): Rewrite OPTION_ADD_SECTION code to work
	with non-ordinary files like /dev/null.
binutils/testsuite/:
	* lib/utils-lib.exp (run_dump_test): Permit option values to use
	$srcdir to refer to the source directory.
	* binutils-all/add-section.d: New test.
	* binutils-all/add-empty-section.d: New test.
	* binutils-all/empty-file: New test input file.
	* binutils-all/objcopy.exp: Run new tests.
@
text
@d1611 6
a1616 1
	      padd->section = bfd_make_section_with_flags (obfd, padd->name, flags);
@


1.140
log
@Update copyright

2010-01-04  H.J. Lu  <hongjiu.lu@@intel.com>

	* objcopy.c: Update copyright.
	* readelf.c: Likewise.
@
text
@d3309 1
a3309 1
	    off_t size;
a3310 2
	    int len;
	    char *name;
a3317 7
	    size = get_file_size (s + 1);
	    if (size < 1)
	      {
		status = 1;
		break;
	      }

d3319 2
d3322 3
a3324 9
	    len = s - optarg;
	    name = (char *) xmalloc (len + 1);
	    strncpy (name, optarg, len);
	    name[len] = '\0';
	    pa->name = name;

	    pa->filename = s + 1;
	    pa->size = size;
	    pa->contents = (bfd_byte *) xmalloc (size);
a3326 1

d3331 21
a3351 3
	    if (fread (pa->contents, 1, pa->size, f) == 0
		|| ferror (f))
	      fatal (_("%s: fread failed"), pa->filename);
@


1.139
log
@Remove "Warning: " from error message

2010-01-04  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/11130
	* objcopy.c (copy_object): Remove "Warning: " from error
	message.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
@


1.138
log
@        * objcopy.c (add_redefine_syms_file): Avoid symbol buffer
        overrun.
@
text
@d1484 1
a1484 1
	non_fatal (_("Warning: Output file cannot represent architecture `%s'"),
@


1.137
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d1235 1
a1235 1
  buf = (char *) xmalloc (bufsize);
d1252 1
a1252 1
	      buf = (char *) xrealloc (buf, bufsize);
d1278 1
a1278 1
	      buf = (char *) xrealloc (buf, bufsize);
@


1.136
log
@       * obcopy.c (copy_object): New parameter `input_arch', architecture
       of input file, if not specified in input file itself; all callers
       updated; `binary_architecture' hack removed.
       (copy_archive, copy_file): New parameter `input_arch', for
       `copy_object' usage.
       (copy_main): Accept `-B' (`--binary-architecture') option also
       for any arch-less input ifile format, not only `binary'; remove
       bfd_external_binary_architecture hack; instead, add `input_arch'
       to calls to `copy_file'.
       * windres.c, windmc.c : Obsolete and useless external references
       to `bfd_external_binary_architecture' or `bfd_external_machine'
       removed.

       * binary.c (binary_object_p): Remove bfd_external_binary_architecture
       hack.  objcopy `-B' (`--binary-architecture') option is now handled
       in a generic way.
@
text
@d2298 1
a2298 1
  section_rename * rename;
d2301 2
a2302 2
  for (rename = section_rename_list; rename != NULL; rename = rename->next)
    if (strcmp (rename->old_name, old_name) == 0)
d2305 2
a2306 2
	if (strcmp (rename->new_name, new_name) == 0
	    && rename->flags == flags)
d2312 1
a2312 1
  rename = (section_rename *) xmalloc (sizeof (* rename));
d2314 4
a2317 4
  rename->old_name = old_name;
  rename->new_name = new_name;
  rename->flags    = flags;
  rename->next     = section_rename_list;
d2319 1
a2319 1
  section_rename_list = rename;
d2331 1
a2331 1
  section_rename * rename;
d2336 2
a2337 2
  for (rename = section_rename_list; rename != NULL; rename = rename->next)
    if (strcmp (rename->old_name, old_name) == 0)
d2339 2
a2340 2
	if (rename->flags != (flagword) -1)
	  * returned_flags = rename->flags;
d2342 1
a2342 1
	return rename->new_name;
@


1.135
log
@        Updated soruces in binutils/* to compile cleanly with -Wc++-compat.

        * binutils/addr2line.c (slurp_symtab): Fix casts. Introduce
        variable minisyms to avoid aliasing varning.
        * binutils/ar.c: Add casts. (normalize): Use name del instead of
        delete. (display_target_list,display_info_table): Change loop
        counter variable a to int.
        * binutils/bucomm.c: Add casts.
        * binutils/debug.c: Update function to use new names. (struct
        debug_baseclass): Rename member from virtual to
        is_virtual. (struct debug_type_s,struct debug_field_s,struct
        debug_baseclass_s,struct debug_method_s,struct
        debug_method_variant_s,struct debug_type_s): Rename struct from
        avoid name collision.
        * /binutils/debug.h: Use new struct names.
        * binutils/dwarf.c: Add casts. (free_debug_memory): Change loop
        counter variable a to int.
        * binutils/ieee.c: Add casts. (enum ieee_var_kind): Move to top
        level. (ieee_class_baseclass): Rename parameter virtual to
        is_virtual. (ieee_class_method_var): Rename variable virtual to
        is_virtual.
        * binutils/nm.c: Add casts.
        * binutils/objcopy.c: Add casts. (copy_archive): Rename variable
        delete to del.
        * binutils/objdump.c: Add casts. (dump_dwarf_section): Change loop
        counter variable i to int.
        * binutils/prdbg.c: Add
        casts. (pr_class_baseclass,tg_class_baseclass): Rename parameters
        virtual to is_virtual.
        * binutils/readelf.c: Add casts. (struct
        ia64_unw_table_entry,struct hppa_unw_table_entry): Move to top
        level.
        * binutils/size.c: Add casts.
        * binutils/stabs.c (parse_stab_type, parse_stab_range_type)
        (parse_stab_cpp_abbrev): Rename parameter from typename to
        type_name. (parse_stab_baseclasses): Rename variable virtual to
        is_virtual.
        * binutils/strings.c: Add casts.
        * binutils/wrstabs.c (stab_class_baseclass): Rename parameter
        virtual to is_virtual.
@
text
@a444 5
/* Defined in bfd/binary.c.  Used to set architecture and machine of input
   binary files.  */
extern enum bfd_architecture  bfd_external_binary_architecture;
extern unsigned long          bfd_external_machine;

d464 1
a464 1
  -B --binary-architecture <arch>  Set arch of output file, when input is binary\n\
d1399 1
a1399 1
copy_object (bfd *ibfd, bfd *obfd)
d1464 12
d1966 2
a1967 1
	      bfd_boolean force_output_target)
d2061 1
a2061 1
	  del = ! copy_object (this_element, output_bfd);
d2166 2
a2167 1
	   const char *input_target,   const char *output_target)
d2218 1
a2218 1
      copy_archive (ibfd, obfd, output_target, force_output_target);
d2240 1
a2240 1
      if (! copy_object (ibfd, obfd))
d3021 1
a3021 1
      copy_file (argv[i], tmpname, input_target, output_target);
a3155 1
  char * binary_architecture = NULL;
d3167 1
d3181 3
a3183 1
	  binary_architecture = optarg;
a3837 23
  if (binary_architecture != NULL)
    {
      if (input_target && strcmp (input_target, "binary") == 0)
	{
	  const bfd_arch_info_type * temp_arch_info;

	  temp_arch_info = bfd_scan_arch (binary_architecture);

	  if (temp_arch_info != NULL)
	    {
	      bfd_external_binary_architecture = temp_arch_info->arch;
	      bfd_external_machine             = temp_arch_info->mach;
	    }
	  else
	    fatal (_("architecture %s unknown"), binary_architecture);
	}
      else
	{
	  non_fatal (_("Warning: input target 'binary' required for binary architecture parameter."));
	  non_fatal (_(" Argument %s ignored"), binary_architecture);
	}
    }

d3854 1
a3854 1
  copy_file (input_filename, tmpname, input_target, output_target);
@


1.134
log
@2009-08-03  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/10364
	* objcopy.c (strip_main): Check return from smart_rename.
	(copy_main): Likewise.
@
text
@d643 1
a643 1
	  copy = xmalloc (len + 1);
d672 1
a672 1
  p = xmalloc (sizeof (struct section_list));
d695 1
a695 1
  return strcmp (s1, s2) == 0;
d745 1
a745 1
  buffer = xmalloc (size + 2);
d846 3
a848 2
  struct is_specified_symbol_predicate_data *d = data;
  const char *slot_name = *slot;
d1060 2
a1061 2
          ptr = n = xmalloc (1 + strlen (prefix_symbols_string)
			     + strlen (name) + 1);
d1212 1
a1212 1
  new_node = xmalloc (sizeof (struct redefine_node));
d1240 1
a1240 1
  buf = xmalloc (bufsize);
d1257 1
a1257 1
	      buf = xrealloc (buf, bufsize);
d1283 1
a1283 1
	      buf = xrealloc (buf, bufsize);
d1368 1
a1368 1
  cbuf = xmalloc (BUFSIZE);
d1562 1
a1562 1
  osympp = isympp = xmalloc (symsize);
d1716 1
a1716 1
      osections = xmalloc (c * sizeof (asection *));
d1722 1
a1722 1
      gaps = xmalloc (c * sizeof (bfd_size_type));
d1823 1
a1823 1
      osympp = xmalloc ((symcount + 1) * sizeof (asymbol *));
d1876 1
a1876 1
      buf = xmalloc (max_gap);
d1999 1
a1999 1
      bfd_boolean delete = TRUE;
d2013 1
a2013 1
	  l = xmalloc (sizeof (struct name_list));
d2031 1
a2031 1
      l = xmalloc (sizeof (struct name_list));
d2053 1
a2053 1
	  delete = ! copy_object (this_element, output_bfd);
d2055 1
a2055 1
	  if (! delete
d2075 1
a2075 1
	  delete = !copy_unknown_object (this_element, output_bfd);
d2084 1
a2084 1
      if (delete)
d2303 1
a2303 1
  rename = xmalloc (sizeof (* rename));
d2365 1
a2365 1
  bfd *obfd = obfdarg;
d2398 1
a2398 1
      n = xmalloc (strlen (prefix) + strlen (name) + 1);
d2535 1
a2535 1
  bfd *obfd = obfdarg;
d2592 1
a2592 1
      relpp = xmalloc (relsize);
d2610 1
a2610 1
	  temp_relpp = xmalloc (relsize);
d2667 1
a2667 1
	  char *to = memhunk;
d2712 1
a2712 1
  asection ***secppp = secppparg;
d2725 2
a2726 2
  const asection *const *sec1 = arg1;
  const asection *const *sec2 = arg2;
d2769 1
a2769 1
  asymbol **symbols = symbolsarg;
d2790 1
a2790 1
  relpp = xmalloc (relsize);
d3316 1
a3316 1
	    pa = xmalloc (sizeof (struct section_add));
d3319 1
a3319 1
	    name = xmalloc (len + 1);
d3326 1
a3326 1
	    pa->contents = xmalloc (size);
d3386 1
a3386 1
	    name = xmalloc (len + 1);
d3484 1
a3484 1
	    source = xmalloc (len + 1);
d3490 1
a3490 1
	    target = xmalloc (len + 1);
d3515 1
a3515 1
	    name = xmalloc (len + 1);
d3542 1
a3542 1
	    old_name = xmalloc (len + 1);
d3562 1
a3562 1
	    new_name = xmalloc (len + 1);
@


1.134.2.1
log
@        Update soruces to compile cleanly with -Wc++-compat:

        * addr2line.c (slurp_symtab): Fix casts. Introduce variable
        minisyms to avoid aliasing varning.
        * ar.c: Add casts.
        (normalize): Use name del instead of delete.
        (display_target_list,display_info_table): Change loop counter
        variable a to int.
        * bucomm.c: Add casts.
        * debug.c: Update function to use new names.
        (struct debug_baseclass): Rename member from virtual to
        is_virtual.
        (struct debug_type_s, struct debug_field_s, struct
        debug_baseclass_s, struct debug_method_s, struct
        debug_method_variant_s, struct debug_type_s): Rename struct from
        avoid name collision.
        * debug.h: Use new struct names.
        * dwarf.c: Add casts.
        (free_debug_memory): Change loop counter variable a to int.
        * ieee.c: Add casts.
        (enum ieee_var_kind): Move to top level.
        (ieee_class_baseclass): Rename parameter virtual to is_virtual.
        (ieee_class_method_var): Rename variable virtual to is_virtual.
        * nm.c: Add casts.
        * objcopy.c: Add casts.
        (copy_archive): Rename variable delete to del.
        * objdump.c: Add casts.
        (dump_dwarf_section): Change loop counter variable i to int.
        * prdbg.c: Add casts.
        (pr_class_baseclass,tg_class_baseclass): Rename parameters virtual
        to is_virtual.
        * readelf.c: Add casts.
        (struct ia64_unw_table_entry,struct hppa_unw_table_entry): Move to
        top level.
        * size.c: Add casts.
        * stabs.c (parse_stab_type, parse_stab_range_type,
        (parse_stab_cpp_abbrev): Rename parameter from typename to
        type_name.
        (parse_stab_baseclasses): Rename variable virtual to is_virtual.
        * strings.c: Add casts.
        * wrstabs.c (stab_class_baseclass): Rename parameter virtual to
        is_virtual.
@
text
@d643 1
a643 1
	  copy = (char *) xmalloc (len + 1);
d672 1
a672 1
  p = (struct section_list *) xmalloc (sizeof (struct section_list));
d695 1
a695 1
  return strcmp ((const char *) s1, (const char *) s2) == 0;
d745 1
a745 1
  buffer = (char *) xmalloc (size + 2);
d846 2
a847 3
  struct is_specified_symbol_predicate_data *d =
      (struct is_specified_symbol_predicate_data *) data;
  const char *slot_name = (char *) *slot;
d1059 2
a1060 2
          ptr = n = (char *) xmalloc (1 + strlen (prefix_symbols_string)
                                      + strlen (name) + 1);
d1211 1
a1211 1
  new_node = (struct redefine_node *) xmalloc (sizeof (struct redefine_node));
d1239 1
a1239 1
  buf = (char *) xmalloc (bufsize);
d1256 1
a1256 1
	      buf = (char *) xrealloc (buf, bufsize);
d1282 1
a1282 1
	      buf = (char *) xrealloc (buf, bufsize);
d1367 1
a1367 1
  cbuf = (char *) xmalloc (BUFSIZE);
d1561 1
a1561 1
  osympp = isympp = (asymbol **) xmalloc (symsize);
d1715 1
a1715 1
      osections = (asection **) xmalloc (c * sizeof (asection *));
d1721 1
a1721 1
      gaps = (bfd_size_type *) xmalloc (c * sizeof (bfd_size_type));
d1822 1
a1822 1
      osympp = (asymbol **) xmalloc ((symcount + 1) * sizeof (asymbol *));
d1875 1
a1875 1
      buf = (bfd_byte *) xmalloc (max_gap);
d1998 1
a1998 1
      bfd_boolean del = TRUE;
d2012 1
a2012 1
	  l = (struct name_list *) xmalloc (sizeof (struct name_list));
d2030 1
a2030 1
      l = (struct name_list *) xmalloc (sizeof (struct name_list));
d2052 1
a2052 1
	  del = ! copy_object (this_element, output_bfd);
d2054 1
a2054 1
	  if (! del
d2074 1
a2074 1
	  del = !copy_unknown_object (this_element, output_bfd);
d2083 1
a2083 1
      if (del)
d2302 1
a2302 1
  rename = (section_rename *) xmalloc (sizeof (* rename));
d2364 1
a2364 1
  bfd *obfd = (bfd *) obfdarg;
d2397 1
a2397 1
      n = (char *) xmalloc (strlen (prefix) + strlen (name) + 1);
d2534 1
a2534 1
  bfd *obfd = (bfd *) obfdarg;
d2591 1
a2591 1
      relpp = (arelent **) xmalloc (relsize);
d2609 1
a2609 1
	  temp_relpp = (arelent **) xmalloc (relsize);
d2666 1
a2666 1
	  char *to = (char *) memhunk;
d2711 1
a2711 1
  asection ***secppp = (asection ***) secppparg;
d2724 2
a2725 2
  const asection *const *sec1 = (const asection * const *) arg1;
  const asection *const *sec2 = (const asection * const *) arg2;
d2768 1
a2768 1
  asymbol **symbols = (asymbol **) symbolsarg;
d2789 1
a2789 1
  relpp = (arelent **) xmalloc (relsize);
d3315 1
a3315 1
	    pa = (struct section_add *) xmalloc (sizeof (struct section_add));
d3318 1
a3318 1
	    name = (char *) xmalloc (len + 1);
d3325 1
a3325 1
	    pa->contents = (bfd_byte *) xmalloc (size);
d3385 1
a3385 1
	    name = (char *) xmalloc (len + 1);
d3483 1
a3483 1
	    source = (char *) xmalloc (len + 1);
d3489 1
a3489 1
	    target = (char *) xmalloc (len + 1);
d3514 1
a3514 1
	    name = (char *) xmalloc (len + 1);
d3541 1
a3541 1
	    old_name = (char *) xmalloc (len + 1);
d3561 1
a3561 1
	    new_name = (char *) xmalloc (len + 1);
@


1.134.2.2
log
@        * objcopy.c (add_redefine_syms_file): Avoid symbol buffer
        overrun.
@
text
@d1240 1
a1240 1
  buf = (char *) xmalloc (bufsize + 1 /* For the terminating NUL.  */);
d1257 1
a1257 1
	      buf = (char *) xrealloc (buf, bufsize + 1);
d1283 1
a1283 1
	      buf = (char *) xrealloc (buf, bufsize + 1);
@


1.133
log
@2009-06-27  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/10321
	* bucomm.c (get_file_size): Return -1 on error.

	* objcopy.c (copy_file): Report empty file.
@
text
@d3017 5
a3021 3
	    smart_rename (tmpname, output_file ? output_file : argv[i],
			  preserve_dates);
	  status = hold_status;
d3871 2
a3872 1
	smart_rename (tmpname, input_filename, preserve_dates);
@


1.132
log
@	* objcopy.c (set_long_section_mode): Check input_bfd is coff
	before accessing coff specific fields of bfd.
@
text
@d2162 1
d2164 1
a2164 1
  if (get_file_size (input_filename) < 1)
d2166 3
@


1.131
log
@bfd/

2009-04-27  H.J. Lu  <hongjiu.lu@@intel.com>

	* peXXigen.c (_bfd_XX_bfd_copy_private_bfd_data_common): Don't
	copy pe_opthdr.

binutils/

2009-04-27  H.J. Lu  <hongjiu.lu@@intel.com>

	* objcopy.c (copy_object): Copy pe_opthdr before changing PE
	parameters.
@
text
@d2146 2
a2147 1
      if (style == KEEP)
@


1.130
log
@bfd/

2009-04-17  H.J. Lu  <hongjiu.lu@@intel.com>

	* peXXigen.c (_bfd_XX_print_private_bfd_data_common): Replace
	IMAGE_SUBSYSTEM_EFI_ROM with IMAGE_SUBSYSTEM_SAL_RUNTIME_DRIVER.

binutils/

2009-04-17  H.J. Lu  <hongjiu.lu@@intel.com>

	* objcopy.c (set_pe_subsystem): Replace efi-rom with sal-rtd.
	* doc/binutils.texi: Likewise.

include/coff/

2009-04-17  H.J. Lu  <hongjiu.lu@@intel.com>

	* pe.h (IMAGE_SUBSYSTEM_EFI_ROM): Renamed to ...
	(IMAGE_SUBSYSTEM_SAL_RUNTIME_DRIVER): This.
@
text
@d1494 5
@


1.129
log
@bfd/

2009-04-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/10074
	* coffcode.h (bfd_pei_p): New.

	* config.bfd: Remove bfd_efi_bsdrv_ia32_vec,
	bfd_efi_rtdrv_ia32_vec, bfd_efi_bsdrv_x86_64_vec,
	bfd_efi_rtdrv_x86_64_vec, bfd_efi_bsdrv_ia64_vec and
	bfd_efi_rtdrv_ia64_vec.  Replace bfd_efi_app_ia32_vec,
	bfd_efi_app_x86_64_vec and bfd_efi_app_ia64_vec with
	i386pei_vec, x86_64pei_vec and bfd_pei_ia64_vec, respectively.

	* configure.in: Remove bfd_efi_bsdrv_ia32_vec,
	bfd_efi_rtdrv_ia32_vec, bfd_efi_bsdrv_x86_64_vec,
	bfd_efi_rtdrv_x86_64_vec,
	bfd_efi_bsdrv_ia64_vec and bfd_efi_rtdrv_ia64_vec.  Replace
	bfd_efi_ia64_vec with bfd_pei_ia64_vec.
	* targets.c: Likewise.

	* configure: Regenerated.
	* libcoff.h: Likewise.
	* Makefile.in: Likewise.

	* efi-app-ia32.c: Removed.
	* efi-app-x86_64.c: Likewise.
	* efi-bsdrv-ia32.c: Likewise.
	* efi-bsdrv-ia64.c: Likewise.
	* efi-bsdrv-x86_64.c: Likewise.
	* efi-rtdrv-ia32.c: Likewise.
	* efi-rtdrv-ia64.c: Likewise.
	* efi-rtdrv-x86_64.c: Likewise.
	* efi-rtdrv-ia32.c: Likewise.

	* efi-app-ia64.c: Moved to ...
	* pei-ia64.c: This.
	(TARGET_SYM): Set to bfd_pei_ia64_vec.
	(TARGET_NAME): Set to pei-ia64.

	* libpei.h (bfd_target_pei_p): Removed.
	(bfd_target_pei_arch): Likewise.
	(bfd_target_efi_app_p): Likewise.
	(bfd_target_efi_app_arch): Likewise.
	(bfd_target_efi_bsdrv_p): Likewise.
	(bfd_target_efi_bsdrv_arch): Likewise.
	(bfd_target_efi_rtdrv_p): Likewise.
	(bfd_target_efi_rtdrv_arch): Likewise.
	(bfd_pe_executable_p): Likewise.

	* Makefile.am (BFD32_BACKENDS): Remove efi-app-ia32.lo,
	efi-bsdrv-ia32.lo and efi-rtdrv-ia32.lo.
	(BFD32_BACKENDS_CFILES): Remove efi-app-ia32.c, efi-bsdrv-ia32.c
	and efi-rtdrv-ia32.c.
	(BFD64_BACKENDS): Remove efi-app-ia64.lo, efi-bsdrv-ia64.lo,
	efi-rtdrv-ia64.lo, efi-app-x86_64.lo, efi-bsdrv-x86_64.lo and
	efi-rtdrv-x86_64.lo. Add pei-ia64.lo.
	(BFD64_BACKENDS_CFILES): Remove efi-app-ia64.c, efi-bsdrv-ia64.c,
	efi-rtdrv-ia64.c, efi-app-x86_64.c, efi-bsdrv-x86_64.c and
	efi-rtdrv-x86_64.c. Add pei-ia64.c.
	(efi-app-ia64.lo): Removed.
	(efi-bsdrv-ia32.lo): Likewise.
	(efi-rtdrv-ia32.lo): Likewise.
	(efi-app-ia64.lo): Likewise.
	(efi-bsdrv-ia64.lo): Likewise.
	(efi-rtdrv-ia64.lo): Likewise.
	(efi-app-x86_64.lo): Likewise.
	(efi-bsdrv-x86_64.lo): Likewise.
	(efi-rtdrv-x86_64.lo): Likewise.
	(pei-ia64.lo): New.

	* peicode.h (coff_swap_scnhdr_in): Replace bfd_pe_executable_p
	with bfd_pei_p.
	(arch_type): Removed.
	(pe_arch): Likewise.
	(pe_bfd_object_p): Just return coff_object_p.

	* peXXigen.c (_bfd_XXi_swap_scnhdr_out): Replace
	bfd_pe_executable_p with bfd_pei_p.

binutils/

2009-04-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/10074
	* objcopy.c: Include coff/i386.h and coff/pe.h.
	(pe_file_alignment): New.
	(pe_heap_commit): Likewise.
	(pe_heap_reserve): Likewise.
	(pe_image_base): Likewise.
	(pe_section_alignment): Likewise.
	(pe_stack_commit): Likewise.
	(pe_stack_reserve): Likewise.
	(pe_subsystem): Likewise.
	(pe_major_subsystem_version): Likewise.
	(pe_minor_subsystem_version): Likewise.
	(set_pe_subsystem): Likewise.
	(convert_efi_target): Likewise.
	(command_line_switch): Add OPTION_FILE_ALIGNMENT,
	OPTION_HEAP, OPTION_IMAGE_BASE, OPTION_SECTION_ALIGNMENT,
	OPTION_STACK and OPTION_SUBSYSTEM.
	(copy_options): Likewise.
	(copy_usage): Add --file-alignment, --heap, --image-base,
	--section-alignment, --stack and --subsystem.
	(copy_object): Set up PE parameters.
	(copy_main): Process Add OPTION_FILE_ALIGNMENT,
	OPTION_HEAP, OPTION_IMAGE_BASE, OPTION_SECTION_ALIGNMENT,
	OPTION_STACK and OPTION_SUBSYSTEM.   Convert EFI target to
	PEI target.

	* NEWS: Mention --file-alignment, --heap, --image-base,
	--section-alignment, --stack and --subsystem command line
	options for objcopy.

	* doc/binutils.texi: Document --file-alignment, --heap,
	--image-base, --section-alignment, --stack and --subsystem
	command line options for objcopy.
@
text
@d3043 1
a3043 1
      { "efi-rom", 1, IMAGE_SUBSYSTEM_EFI_ROM },
@


1.128
log
@bfd/ChangeLog

	* coffgen.c (make_a_section_from_file):  Set the backend long
	section names enable if long section names found on input.
	* coffcode.h:  Extend long section names documentation to match.

binutils/ChangeLog

	* objcopy.c (enum long_section_name_handling):  New enum type.
	(enum command_line_switch):  Add OPTION_LONG_SECTION_NAMES.
	(copy_options[]):  Add entry for --long-section-names option.
	(copy_usage):  Document it.
	(set_long_section_mode):  New subroutine.
	(copy_file):  Call it.
	(copy_main):  Accept OPTION_LONG_SECTION_NAMES and parse arg.
	* doc/binutils.texi:  Update objcopy documentation with details
	of new option.
@
text
@d38 16
d299 7
a305 1
    OPTION_REVERSE_BYTES
d419 6
d546 9
d1488 52
d3020 111
d3669 53
d3761 53
@


1.127
log
@bfd/

2009-03-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/9945
	* elf.c (assign_section_numbers): Generate symbol table if there
	is any relocation in output.
	(_bfd_elf_compute_section_file_positions): Likewise.

binutils/

2009-03-13  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/9945
	* objcopy.c (copy_object): Clear HAS_RELOC when stripping all.
@
text
@d35 2
d221 12
d264 1
d358 1
d489 2
d2046 12
d2106 2
d2128 2
d3390 11
@


1.126
log
@binutils/

2009-03-09  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/9933
	* objcopy.c (filter_symbols): Properly handle common symbols
	in relocatable file.

binutils/testsuite/

2009-03-09  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/9933
	* binutils-all/copy-4.d: New.

	* binutils-all/objcopy.exp: Run copy-4.
@
text
@d1399 3
@


1.125
log
@	PR 9798
	* bucomm.c (bfd_nonfatal_message): Use bfd_get_archive_filename.
	(bfd_get_archive_filename): Constify param.
	* bucomm.h (bfd_get_archive_filename): Update prototype.
	* objcopy.c (RETURN_NONFATAL): Delete.
	(copy_unknown_object): Don't call bfd_get_archive_filename for
	bfd_nonfatal_message filename, instead just pass bfd.
	(copy_object): Likewise.
	(copy_archive, copy_file): Likewise.  Expand RETURN_NONFATAL.  On
	bfd_close errors, do not pass the bfd to bfd_nonfatal_message.
	(setup_bfd_headers): Fix error message.
@
text
@d1031 2
a1032 1
	       && (flags & (BSF_GLOBAL | BSF_WEAK)) != 0)
@


1.124
log
@	* objcopy.c (setup_section): Set elf_group_id.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
a61 5
#define RETURN_NONFATAL(bfd) \
  do { \
    status = 1; bfd_nonfatal_message (NULL, bfd, NULL, NULL); return; \
  } while (0)

d1289 1
a1289 1
      bfd_nonfatal_message (bfd_get_archive_filename (ibfd), NULL, NULL, NULL);
d1322 1
a1322 2
	  bfd_nonfatal_message (bfd_get_archive_filename (ibfd),
				NULL, NULL, NULL);
d1401 1
a1401 2
	  bfd_nonfatal_message (bfd_get_archive_filename (ibfd),
				NULL, NULL, NULL);
d1425 1
a1425 1
      bfd_nonfatal_message (bfd_get_archive_filename (ibfd), NULL, NULL, NULL);
d1441 1
a1441 1
      bfd_nonfatal_message (bfd_get_archive_filename (ibfd), NULL, NULL, NULL);
d1852 2
a1853 1
  char * dir;
d1869 5
a1873 1
    RETURN_NONFATAL (obfd);
d1943 1
a1943 1
		  bfd_nonfatal_message (NULL, output_bfd, NULL, NULL);
d1953 1
a1953 2
	  bfd_nonfatal_message (bfd_get_archive_filename (this_element),
				NULL, NULL,
d1961 1
a1961 1
	      bfd_nonfatal_message (NULL, output_bfd, NULL, NULL);
d1994 1
d1996 5
a2000 1
    RETURN_NONFATAL (obfd);
d2002 1
d2004 5
a2008 1
    RETURN_NONFATAL (obfd);
d2097 5
a2101 1
	RETURN_NONFATAL (obfd);
d2104 5
a2108 1
	RETURN_NONFATAL (ibfd);
d2213 1
a2213 1
			    _("error in private h	eader data"));
@


1.123
log
@binutils/
	* objcopy.c (copy_object): Don't setup_bfd_headers when extract_symbol.
	(setup_section): Don't zero vma and lma when extract_symbol.
	(copy_section): Discard relocations when extract_symbol.
	* doc/binutils.texi: Update --extract-symbol description.
ld/testsuite/
	* ld-elf/extract-symbol-1sec.d: Update.
@
text
@d2347 12
a2365 7
  else if ((isection->flags & SEC_GROUP) != 0)
    {
      asymbol *gsym = group_signature (isection);

      if (gsym != NULL)
	gsym->flags |= BSF_KEEP;
    }
@


1.123.2.1
log
@backport 2008-09-28  Alan Modra  <amodra@@bigpond.net.au>
@
text
@a2346 12
  if ((isection->flags & SEC_GROUP) != 0)
    {
      asymbol *gsym = group_signature (isection);

      if (gsym != NULL)
	{
	  gsym->flags |= BSF_KEEP;
	  if (ibfd->xvec->flavour == bfd_target_elf_flavour)
	    elf_group_id (isection) = gsym;
	}
    }

d2354 7
@


1.122
log
@        PR binutils/6483
        * objdump.c (dump_bfd): If the -g option found no STABS or IEEE
        debug information to display, try dumping DWARF information
        instead.
        * rddbg.c (read_debugging_info): Add a parameter to suppress the
        display of a warning message when no debug information is found.
        * budbg.h (read_debugging_info): Update prototype.
        * objcopy.c (copy_object): Continue to allow read_debugging_info
        to produce warning messages.
        * doc/binutils.texi (--debugging): Document new behaviour of the
        -g/--debugging option.
@
text
@d1464 2
a1465 1
  setup_bfd_headers (ibfd, obfd);
d2302 1
a2302 1
  if (! bfd_set_section_vma (obfd, osection, extract_symbol ? 0 : vma))
d2321 1
a2321 1
  osection->lma = extract_symbol ? 0 : lma;
d2340 1
a2340 1
  isection->output_offset = extract_symbol ? vma : 0;
d2404 3
a2466 3
  if (extract_symbol)
    return;

@


1.121
log
@        PR binutils/6034
        * objcopy.c (stuct symlist): Rename to
        is_specified_symbol_predicate_data.
        (strip_specific_list): Rename to strip_specific_htab.
        (strip_unneeded_list): Rename to strip_unneeded_htab.
        (keep_specific_list):  Rename to keep_specific_htab.
        (localize_specific_list): Rename to localize_specific_htab.
        (globalize_specific_list): Rename to globalize_specific_htab.
        (keepglobal_specific_list): Rename to keepglobal_specific_htab.
        (weaken_specific_list): Rename to weaken_specific_htab.
        (eq_string): New function.
        (create_symbol_htab): New function.
        (create_symbol_htabs): New function.
        (add_specific_symbol): Change to use hash tables.
        (is_specified_symbol_predicate): New function.
        (is_specified_symbol): Use hash table lookup.
        (is_strip_section): Update to use new functions and hash tables.
        (filter_symbols): Likewise.
        (copy_object): Likewise.
        (copy_section): Likewise.
        (strip_main): Likewise.
        (copy_main): Likewise.
        (main): Likewise.
@
text
@d1677 1
a1677 1
    dhandle = read_debugging_info (ibfd, isympp, symcount);
@


1.120
log
@Add support for thin archives.
    * bfd/archive.c (_bfd_find_nested_archive): New function.
    (get_extended_arelt_filename): Add origin parameter.
    (_bfd_generic_read_ar_hdr_mag): Deal with extended name
    combined with a file offset.
    (append_relative_path): New function.
    (_bfd_get_elt_at_filepos): Deal with external members and
    nested archives.
    (bfd_generic_openr_next_archived_file): Thin archives.
    (bfd_generic_archive_p): Recognize new magic string.
    (adjust_relative_path): New function.
    (_bfd_construct_extended_name_table): Construct extended
    names for thin archive members.
    (_bfd_write_archive_contents): Emit new magic string, skip
    copying files for thin archives.
    * bfd/bfd-in.h (bfd_is_thin_archive): New macro.
    * bfd/bfd.c (struct bfd): New fields for thin archives.
    * bfd/libbfd-in.h (struct areltdata): New field for thin archives.
    * bfd/opncls.c (bfd_close): Delete BFDs for nested archives.
    * binutils/ar.c (make_thin_archive): New global flag.
    (map_over_members): Deal with full pathnames in thin archives.
    (usage, main): Add 'T' option for building thin archives.
    (replace_members): Pass thin archive flag to ar_emul_append.
    * binutils/arsup.c (ar_open): Initialize new flag.
    * binutils/binemul.c (ar_emul_append): Add new parameter for
    flattening nested archives.
    (do_ar_emul_default_append): New function.
    (ar_emul_default_append): Factored out recursive code.
    * binutils/binemul.h (ar_emul_default_append): Add new parameter.
    (struct bin_emulation_xfer_struct): New parameter for ar_append.
    * binutils/dlltool.c (gen_lib_file): Initialize thin archive flag.
    * binutils/emul_aix.c (ar_emul_aix_internal): Add new flatten
    parameter, currently unimplemented.
    All callers changed.
    * binutils/objcopy.c (copy_archive): Preserve thin archive flag.
    * binutils/doc/binutils.texi: Update ar documentation.
    * binutils/testsuite/binutils-all/ar.exp: Add thin archive tests.
    * include/aout/ar.h (ARMAGT): New magic string for thin archives.
@
text
@d36 1
a36 6
/* A list of symbols to explicitly strip out, or to keep.  A linked
   list is good enough for a small number from the command line, but
   this will slow things down a lot if many symbols are being
   deleted.  */

struct symlist
d38 2
a39 2
  const char *name;
  struct symlist *next;
d197 7
a203 7
static struct symlist *strip_specific_list = NULL;
static struct symlist *strip_unneeded_list = NULL;
static struct symlist *keep_specific_list = NULL;
static struct symlist *localize_specific_list = NULL;
static struct symlist *globalize_specific_list = NULL;
static struct symlist *keepglobal_specific_list = NULL;
static struct symlist *weaken_specific_list = NULL;
d640 26
d669 1
a669 1
add_specific_symbol (const char *name, struct symlist **list)
d671 1
a671 6
  struct symlist *tmp_list;

  tmp_list = xmalloc (sizeof (struct symlist));
  tmp_list->name = name;
  tmp_list->next = *list;
  *list = tmp_list;
d680 1
a680 1
add_specific_symbols (const char *filename, struct symlist **list)
d781 1
a781 1
	add_specific_symbol (name, list);
d790 2
a791 2
/* See whether a symbol should be stripped or kept based on
   strip_specific_list and keep_symbols.  */
d793 2
a794 2
static bfd_boolean
is_specified_symbol (const char *name, struct symlist *list)
d796 2
a797 1
  struct symlist *tmp_list;
d799 1
a799 1
  if (wildcard)
d801 6
a806 11
      for (tmp_list = list; tmp_list; tmp_list = tmp_list->next)
	if (*(tmp_list->name) != '!')
	  {
	    if (!fnmatch (tmp_list->name, name, 0))
	      return TRUE;
	  }
	else
	  {
	    if (fnmatch (tmp_list->name + 1, name, 0))
	      return TRUE;
	  }
d810 6
a815 3
      for (tmp_list = list; tmp_list; tmp_list = tmp_list->next)
	if (strcmp (name, tmp_list->name) == 0)
	  return TRUE;
d818 20
a837 1
  return FALSE;
d914 2
a915 2
	   && !is_specified_symbol (gname, keep_specific_list))
	  || is_specified_symbol (gname, strip_specific_list))
d1063 1
a1063 1
      if (keep && is_specified_symbol (name, strip_specific_list))
d1078 1
a1078 1
	  && is_specified_symbol (name, strip_unneeded_list))
d1083 1
a1083 1
	      || is_specified_symbol (name, keep_specific_list)))
d1092 1
a1092 1
	      && (weaken || is_specified_symbol (name, weaken_specific_list)))
d1100 3
a1102 3
	      && (is_specified_symbol (name, localize_specific_list)
		  || (keepglobal_specific_list != NULL
		      && ! is_specified_symbol (name, keepglobal_specific_list))
d1111 1
a1111 1
	      && is_specified_symbol (name, globalize_specific_list))
d1685 6
a1690 6
      || strip_specific_list != NULL
      || keep_specific_list != NULL
      || localize_specific_list != NULL
      || globalize_specific_list != NULL
      || keepglobal_specific_list != NULL
      || weaken_specific_list != NULL
d2451 1
a2451 1
				     keep_specific_list))
d2753 1
a2753 1
	  add_specific_symbol (optarg, &keep_specific_list);
d2756 1
a2756 1
	  add_specific_symbol (optarg, &strip_specific_list);
d2811 1
a2811 1
      && strip_specific_list == NULL)
d2964 1
a2964 1
	  add_specific_symbol (optarg, &keep_specific_list);
d2968 1
a2968 1
	  add_specific_symbol (optarg, &strip_specific_list);
d2972 1
a2972 1
	  add_specific_symbol (optarg, &strip_unneeded_list);
d2976 1
a2976 1
	  add_specific_symbol (optarg, &localize_specific_list);
d2980 1
a2980 1
	  add_specific_symbol (optarg, &globalize_specific_list);
d2984 1
a2984 1
	  add_specific_symbol (optarg, &keepglobal_specific_list);
d2988 1
a2988 1
	  add_specific_symbol (optarg, &weaken_specific_list);
d3312 1
a3312 1
	  add_specific_symbols (optarg, &strip_specific_list);
d3316 1
a3316 1
	  add_specific_symbols (optarg, &strip_unneeded_list);
d3320 1
a3320 1
	  add_specific_symbols (optarg, &keep_specific_list);
d3328 1
a3328 1
	  add_specific_symbols (optarg, &localize_specific_list);
d3332 1
a3332 1
	  add_specific_symbols (optarg, &globalize_specific_list);
d3336 1
a3336 1
	  add_specific_symbols (optarg, &keepglobal_specific_list);
d3340 1
a3340 1
	  add_specific_symbols (optarg, &weaken_specific_list);
d3567 2
@


1.119
log
@	* bucomm.c (bfd_nonfatal_message): New.
	* bucomm.h (bfd_nonfatal_message): Declare.
	* objcopy.c (RETURN_NONFATAL): Take BFD not NAME, use
	bfd_nonfatal_message.
	(copy_unknown_object): Adjust bfd_nonfatal and RETURN_NONFATAL
	calls, or replace with bfd_nonfatal_message calls as appropriate.
	(copy_object, copy_archive, copy_file, setup_section,
	copy_section, write_debugging_info): Likewise.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006, 2007
d1833 1
@


1.118
log
@	PR 4888
	* objcopy.c (setup_section): Do modify section flags for ELF
	STRIP_NONDEBUG (reverting part of 2007-05-30 change).  Prevent
	header rewrite by twiddling input section flags instead.
	Simplify code setting SHT_NOBITS.
@
text
@d67 4
a70 1
#define RETURN_NONFATAL(s) {bfd_nonfatal (s); status = 1; return;}
d1260 1
a1260 1
      bfd_nonfatal (bfd_get_archive_filename (ibfd));
d1293 2
a1294 1
	  bfd_nonfatal (bfd_get_archive_filename (ibfd));
d1302 1
a1302 1
	  bfd_nonfatal (bfd_get_filename (obfd));
d1339 1
a1339 1
      bfd_nonfatal (bfd_get_filename (obfd));
d1373 2
a1374 1
	  bfd_nonfatal (bfd_get_archive_filename (ibfd));
d1398 1
a1398 1
      bfd_nonfatal (bfd_get_archive_filename (ibfd));
d1414 1
a1414 1
      bfd_nonfatal (bfd_get_archive_filename (ibfd));
d1422 1
a1422 1
      bfd_nonfatal (bfd_get_filename (ibfd));
d1453 2
a1454 1
	      non_fatal (_("can't add section '%s' - it already exists!"), padd->name);
d1462 3
a1464 2
		  non_fatal (_("can't create section `%s': %s"),
			     padd->name, bfd_errmsg (bfd_get_error ()));
d1471 1
a1471 1
	      bfd_nonfatal (bfd_get_filename (obfd));
d1481 1
a1481 1
		    bfd_nonfatal (bfd_get_filename (obfd));
d1493 1
a1493 1
		      bfd_nonfatal (bfd_get_filename (obfd));
d1508 3
a1510 1
	  bfd_nonfatal (gnu_debuglink_filename);
d1601 2
a1602 3
		      non_fatal (_("Can't fill gap after %s: %s"),
				 bfd_get_section_name (obfd, osections[i]),
				 bfd_errmsg (bfd_get_error ()));
d1625 2
a1626 3
		  non_fatal (_("Can't add padding to %s: %s"),
			     bfd_get_section_name (obfd, osections[c - 1]),
			     bfd_errmsg (bfd_get_error ()));
d1705 1
a1705 1
	      bfd_nonfatal (bfd_get_filename (obfd));
d1716 3
a1718 1
	  bfd_nonfatal (gnu_debuglink_filename);
d1757 1
a1757 1
		      bfd_nonfatal (bfd_get_filename (obfd));
d1779 2
a1780 3
      non_fatal (_("%s: error copying private BFD data: %s"),
		 bfd_get_filename (obfd),
		 bfd_errmsg (bfd_get_error ()));
d1839 1
a1839 1
    RETURN_NONFATAL (bfd_get_filename (obfd));
d1896 5
a1900 1
	    RETURN_NONFATAL (output_name);
d1909 1
a1909 1
		  bfd_nonfatal (bfd_get_filename (output_bfd));
d1919 3
a1921 2
	  non_fatal (_("Unable to recognise the format of the input file `%s'"),
		     bfd_get_archive_filename (this_element));
d1928 1
a1928 1
	      bfd_nonfatal (bfd_get_filename (output_bfd));
d1962 1
a1962 1
    RETURN_NONFATAL (bfd_get_filename (obfd));
d1965 1
a1965 1
    RETURN_NONFATAL (bfd_get_filename (ibfd));
d2001 5
a2005 1
    RETURN_NONFATAL (input_filename);
d2024 5
a2028 1
	RETURN_NONFATAL (output_filename);
d2044 5
a2048 1
	RETURN_NONFATAL (output_filename);
d2054 1
a2054 1
	RETURN_NONFATAL (output_filename);
d2057 1
a2057 2
	RETURN_NONFATAL (input_filename);

d2077 1
a2077 1
      bfd_nonfatal (input_filename);
a2155 2
  const char *err;

d2160 4
a2163 2
      err = _("private header data");
      goto loser;
a2167 6

loser:
  non_fatal (_("%s: error in %s: %s"),
	     bfd_get_filename (ibfd),
	     err, bfd_errmsg (bfd_get_error ()));
  status = 1;
d2240 1
a2240 1
      err = _("making");
d2254 1
a2254 1
      err = _("size");
d2268 1
a2268 1
      err = _("vma");
d2293 1
a2293 1
      err = _("alignment");
d2315 1
a2315 1
      err = _("private data");
a2329 4
  non_fatal (_("%s: section `%s': error in %s: %s"),
	     bfd_get_filename (ibfd),
	     bfd_section_name (ibfd, isection),
	     err, bfd_errmsg (bfd_get_error ()));
d2331 1
d2383 5
a2387 1
	    RETURN_NONFATAL (bfd_get_filename (ibfd));
d2398 6
a2403 1
	RETURN_NONFATAL (bfd_get_filename (ibfd));
d2437 5
a2441 1
	RETURN_NONFATAL (bfd_get_filename (ibfd));
d2484 5
a2488 2
	RETURN_NONFATAL (bfd_get_filename (obfd));

d2503 5
a2507 1
	RETURN_NONFATAL (bfd_get_filename (obfd));
d2648 2
a2649 3
	  non_fatal (_("%s: can't create debugging section: %s"),
		     bfd_get_filename (obfd),
		     bfd_errmsg (bfd_get_error ()));
d2661 2
a2662 3
	  non_fatal (_("%s: can't set debugging section contents: %s"),
		     bfd_get_filename (obfd),
		     bfd_errmsg (bfd_get_error ()));
d2669 3
a2671 2
  non_fatal (_("%s: don't know how to write debugging information for %s"),
	     bfd_get_filename (obfd), bfd_get_target (obfd));
d2811 2
a2812 2
	  non_fatal (_("could not create temporary file to hold stripped copy of '%s'"),
		     argv[i]);
@


1.117
log
@Change sources over to using GPLv3
@
text
@d2168 1
d2197 1
d2201 16
a2216 3
	   && obfd->xvec->flavour != bfd_target_elf_flavour
	   && (flags & SEC_ALLOC) != 0)
    flags &= ~(SEC_HAS_CONTENTS | SEC_LOAD);
d2226 1
a2226 7
  if (strip_symbols == STRIP_NONDEBUG
      && obfd->xvec->flavour == bfd_target_elf_flavour
      && (flags & SEC_ALLOC) != 0
      && elf_section_type (osection) != SHT_NOTE
      && (ibfd->xvec->flavour != bfd_target_elf_flavour
	  || elf_section_type (isection) != SHT_NOTE)
      && (p == NULL || !p->set_flags))
@


1.116
log
@	PR 4716
	* objcopy.c (filter_symbols): Correct relocatable file test.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
@


1.115
log
@2007-06-28  Roland McGrath  <roland@@frob.com>

	* objcopy.c (setup_section): Don't reset ELF section type to
	SHT_NOBITS when it is SHT_NOTE.
	* doc/binutils.texi (objcopy, strip): Mention under --only-keep-debug.
@
text
@d913 1
a913 2
  int relocatable = (abfd->flags & (HAS_RELOC | EXEC_P | DYNAMIC))
		    == HAS_RELOC;
@


1.114
log
@bfd/
	* bfd.c (struct bfd): Rename "next" to "archive_next".
	* archive.c: Rename uses throughout file.
	* archive64.c: Likewise.
	* coff-rs6000.c: Likewise.
	* ecoff.c: Likewise.
	* som.c: Likewise.
	* bfd-in2.h: Regenerate.
binutils/
	* ar.c: Rename uses of bfd.next to bfd.archive_next throughout.
	* arsup.c: Likewise.
	* binemul.c: Likewise.
	* objcopy.c: Likewise.
	* dlltool.c: Likewise.
ld/
	* pe-dll.c: Rename uses of bfd.next to bfd.archive_next throughout.
@
text
@d1074 1
a1074 1
	      && (flags & BSF_LOCAL) 
d1217 1
a1217 1
	  lineno++;	
d2215 3
d2727 1
a2727 1
 
d2801 1
a2801 1
  char *tmpname;    
d3340 1
a3340 1
 
d3395 1
a3395 1
  
@


1.113
log
@bfd/
	* elf.c (elf_fake_sections): Adjust test for SHT_NOBITS sections
	created by objcopy --only-keep-debug.
	(_bfd_elf_init_private_section_data): Only change elf_section_type
	if it is SHT_NULL.
binutils/
	* objcopy.c (copy_object): Revert 2007-05-11 change.  Don't
	avoid calling bfd_copy_private_bfd_data for ELF STRIP_NONDEBUG.
	(setup_section): Don't modify flags, and don't avoid calling
	bfd_copy_private_section_data for ELF STRIP_NONDEBUG.
	* readelf.c (process_program_headers): Ignore .dynamic of type
	SHT_NOBITS.
@
text
@d1938 1
a1938 1
	  ptr = &output_bfd->next;
@


1.112
log
@	* objcopy.c (strip_main): Detect identical input and output file
	names.
	(copy_main): Refactor tempname detection and use.
@
text
@d1426 1
a1426 6
  /* Don't copy headers when creating an ELF format debug info file.  */
  if (bfd_get_flavour (ibfd) == bfd_target_elf_flavour
      && strip_symbols == STRIP_NONDEBUG)
    ;
  else
    setup_bfd_headers (ibfd, obfd);
d1769 1
a1769 6
  if (bfd_get_flavour (ibfd) == bfd_target_elf_flavour
      && strip_symbols == STRIP_NONDEBUG)
    /* Do not copy the private data when creating an ELF format
       debug info file.  We do not want the program headers.  */
    ;
  else if (! bfd_copy_private_bfd_data (ibfd, obfd))
d2199 3
a2201 1
  else if (strip_symbols == STRIP_NONDEBUG && (flags & SEC_ALLOC) != 0)
d2284 1
a2284 6
  if (bfd_get_flavour (ibfd) == bfd_target_elf_flavour
      && strip_symbols == STRIP_NONDEBUG)
    /* Do not copy the private data when creating an ELF format
       debug info file.  We do not want the program headers.  */
    ;
  else if (!bfd_copy_private_section_data (ibfd, isection, obfd, osection))
@


1.111
log
@	PR 4479
	* objcopy.c (copy_object): Don't copy ELF program headers for
	--only-keep-debug.
@
text
@d2772 3
a2774 1
      if (output_file != NULL)
a2775 2
      else
	tmpname = make_tempname (argv[i]);
d2791 3
a2793 2
	  if (output_file == NULL)
	    smart_rename (tmpname, argv[i], preserve_dates);
d2798 1
a2798 1
      if (output_file == NULL)
d2811 1
d3402 10
d3413 4
a3416 15
      char *tmpname = make_tempname (input_filename);

      if (tmpname == NULL)
	fatal (_("warning: could not create temporary file whilst copying '%s', (error: %s)"),
	       input_filename, strerror (errno));

      copy_file (input_filename, tmpname, input_target, output_target);
      if (status == 0)
	{
	  if (preserve_dates)
	    set_times (tmpname, &statbuf);
	  smart_rename (tmpname, input_filename, preserve_dates);
	}
      else
	unlink (tmpname);
d3419 1
a3419 8
    {
      copy_file (input_filename, output_filename, input_target, output_target);

      if (status == 0 && preserve_dates)
	set_times (output_filename, &statbuf);
      else if (status != 0)
	unlink_if_ordinary (output_filename);
    }
@


1.110
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d1426 6
a1431 1
  setup_bfd_headers (ibfd, obfd);
@


1.109
log
@* objcopy.c (filter_symbols): Explicitly stripping a symbol used in relocations is an error.
  Retype 'keep' to bfd_boolean.
* binutils-all/objcopy.exp: Add test for stripping a symbol used in a relocation.
* binutils-all/needed-by-reloc.s: New file.
@
text
@d23 1
a25 1
#include "bucomm.h"
d28 1
@


1.108
log
@* objcopy.c (reverse_bytes):  New variable.
  (command_line_switch, copy_main):  Add OPTION_REVERSE_ENDIAN.
  (copy_options, copy_usage):  Add "reverse-bytes" entry.
  (copy_section):  Reverse bytes within output sections.
* doc/binutils.texi:  Document new objcopy option.
* testsuite/binutils-all/objcopy.exp: Add test for --reverse-bytes.
@
text
@d920 2
a921 1
      int keep;
d989 1
a989 1
	keep = 0;
d994 4
a997 1
	keep = 1;
d1000 1
a1000 1
	keep = 1;
d1006 1
a1006 1
	keep = 1;
d1019 1
a1019 1
	keep = 1;
d1027 12
a1038 1
	keep = 0;
d1042 2
a1043 1
	keep = 0;
d1047 2
a1048 1
	keep = 1;
d1050 1
a1050 1
	keep = 0;
@


1.107
log
@2007-04-12  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/4348
	* objcopy.c (copy_object): Don't stop when there are no
	sections to be copied.

testsuite/

2007-04-12  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/4348
	* binutils-all/empty.s: New file.
	* binutils-all/strip-3.d: Likewise.

	* binutils-all/objcopy.exp: Run strip-3 for ELF target.
@
text
@d221 5
d273 2
a274 1
    OPTION_EXTRACT_SYMBOL
d367 1
d481 1
d2394 26
d3293 14
@


1.106
log
@binutils/
200x-xx-xx  Phil Edwards  <phil@@codesourcery.com>
	    Richard Sandiford  <richard@@codesourcery.com>

	* NEWS: Mention addition of --extract-symbol.
	* doc/binutils.texi: Document it.
	* objcopy.c (extract_symbol): New variable.
	(OPTION_EXTRACT_SYMBOLS): New command_line_switch.
	(copy_options): Add an entry for --extract-symbol.
	(copy_usage): Mention --extract-symbol.
	(copy_object): Set the start address to zero for --extract-symbol.
	Do not copy private BFD data in that case.
	(setup_section): Set the size, LMA and VMA to zero for
	--extract-symbol.  Do not copy private BFD data in that case.
	(copy_section): Do not copy section contents if --extract-symbol
	is passed.
	(copy_main): Set extract_symbol to TRUE if --extract-symbol
	is passed.

ld/testsuite/
	* ld-elf/extract-symbol-1sym.d, ld-elf/extract-symbol-1sec.d,
	* ld-elf/extract-symbol-1.s, ld-elf/extract-symbol-1.ld: New tests.
	* ld-elf/binutils.exp: Run them.
@
text
@d1524 2
a1525 7
  if (bfd_count_sections (obfd) == 0)
    {
      non_fatal (_("there are no sections to be copied!"));
      return FALSE;
    }

  if (gap_fill_set || pad_to_set)
@


1.105
log
@top level:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.ac (TOPLEVEL_CONFIGURE_ARGUMENTS): Fix quoting.
	* configure: Regenerate.

bfd:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-pkgversion): New option.
	* configure: Regenerate.
	* Makefile.am (bfdver.h): Substitute for @@bfd_version_package@@.
	* Makefile.in: Regenerate.
	* version.h (BFD_VERSION_STRING): Define using
	@@bfd_version_package@@.

bfd/doc:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* Makefile.in: Regenerate.

binutils:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-bugurl): New option.
	* configure: Regenerate.
	* Makefile.am (REPORT_BUGS_TO): Define.
	(INCLUDES): Define REPORT_BUGS_TO.
	Regenerate dependencies.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* bucomm.h: Remove include of bin-bugs.h.
	* addr2line.c (usage): Don't print empty REPORT_BUGS_TO.
	* ar.c (usage): Pass s to list_supported_targets.  Don't print
	empty REPORT_BUGS_TO.
	* coffdump.c (show_usage): Don't print empty REPORT_BUGS_TO.
	* cxxfilt.c (usage): Print bug url when giving help.
	* dlltool.c (usage): Likewise.
	* dllwrap.c (usage): Likewise.
	* nlmconv.c (show_usage): Don't print empty REPORT_BUGS_TO.
	* nm.c (usage): Likewise.
	* objcopy.c (copy_usage, strip_usage): Likewise.
	* objdump.c (usage): Likewise.
	* readelf.c ((usage): Likewise. Add STREAM argument.  Adjust
	callers.
	* size.c (usage): Don't print empty REPORT_BUGS_TO.
	* srconv.c (show_usage): Likewise.
	* strings.c (usage): Likewise.
	* sysdymp.c (show_usage): Likewise.
	* windres.c (usage): Likewise.

gas:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-bugurl): New option.
	* configure: Regenerate.
	* dep-in.sed: Remove bin-bugs.h.
	* Makefile.am (REPORT_BUGS_TO): Define.
	(INCLUDES): Define REPORT_BUGS_TO.
	(DEP_INCLUDES): Likewise.
	($(OBJS)): No longer depend on bin-bugs.h.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* as.c (show_usage): Don't print empty REPORT_BUGS_TO.
	* as.h: Remove include of bin-bugs.h.

gprof:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-pkgversion, --with-bugurl): New options.
	* configure: Regenerate.
	* Makefile.am (PKGVERSION, REPORT_BUGS_TO): Define.
	(INCLUDES): Define PKGVERSION and REPORT_BUGS_TO.
	Regenerate dependencies.
	* Makefile.in: Regenerate.
	* gprof.c (usage): Don't print empty REPORT_BUGS_TO.
	(main): Include PKGVERSION in version output.
	* gprof.h: Remove include of bin-bugs.h.

include:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* bin-bugs.h: Remove.

ld:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-bugurl): New option.
	* configure: Regenerate.
	* Makefile.am (REPORT_BUGS_TO): Define.
	(INCLUDES): Define REPORT_BUGS_TO.
	Regenerate dependencies.
	* Makefile.in: Regenerate.
	* ld.h: Remove include of bin-bugs.h.
	* lexsup.c (help): Don't print empty REPORT_BUGS_TO.
@
text
@d218 3
d267 2
a268 1
    OPTION_IMPURE
d324 1
d439 1
d1319 2
a1320 2
  if (set_start_set)
    start = set_start;
d1322 7
a1328 2
    start = bfd_get_start_address (ibfd);
  start += change_start;
d1739 5
d2203 2
d2219 1
a2219 1
  if (! bfd_set_section_vma (obfd, osection, vma))
d2238 1
a2238 1
  osection->lma = lma;
d2257 6
a2262 1
  isection->output_offset = 0;
d2380 3
d3260 4
@


1.104
log
@	* bucomm.h (make_tempdir): Declare independently of HAVE_MKDTEMP.
	* bucomm.c (template_in_dir): New function, split out from..
	(make_tempname): ..here.  Open the file with O_EXCL if !HAVE_MKSTEMP.
	(make_tempdir): Use template_in_dir.  Handle directory creation
	when !HAVE_MKDTEMP.
	* objcopy.c (MKDIR): Don't define.
	(copy_archive): Use make_tempdir when !HAVE_MKDTEMP too.  Fix
	error message.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2006
d499 1
a499 1
  if (exit_status == 0)
d534 1
a534 1
  if (exit_status == 0)
@


1.103
log
@PR binutils/2876
* configure.in: Check for the mkstemp and mkdtemp functions.
* configure: Regenerate.
* config.in (HAVE_MKDTEMP): New potential define.
(MAKE_MKSTEMP): Likewise.
* bucomm.c (make_tempname): Use mkstemp if it is available.
* make_tempdir): New function: Create a temporary directory using mkdtemp, if
it is available.
* bucomm.h (make_tempdir): New prototype.
* objcopy.c (copy_archive): Use make_tempdir if it is available.
  (strip_main): Produce an warning message if a temporary file could not be
  (copy_main): Likewise.
* ar.c (write_archive): Likewise.
@
text
@a1766 9
#if ! defined(HAVE_MKDTEMP)
#undef MKDIR
#if defined (_WIN32) && !defined (__CYGWIN32__)
#define MKDIR(DIR, MODE) mkdir (DIR)
#else
#define MKDIR(DIR, MODE) mkdir (DIR, MODE)
#endif
#endif

a1787 1
#if defined(HAVE_MKDTEMP)
a1788 1

a1791 7
#else
  dir = make_tempname (bfd_get_filename (obfd));

  if (MKDIR (dir, 0700) != 0)
    fatal (_("cannot mkdir %s for archive copying (error: %s)"),
	   dir, strerror (errno));
#endif
a1817 1
#if defined(HAVE_MKDTEMP)
d1820 2
a1821 8
	    fatal (_("cannot create temporary dir '%s' for archive copying (error: %s)"),
		   output_name, strerror (errno));
#else
	  output_name = make_tempname (output_name);
	  if (MKDIR (output_name, 0700) != 0)
	    fatal (_("cannot mkdir %s for archive copying (error: %s)"),
		   output_name, strerror (errno));
#endif
@


1.102
log
@binutils/

2006-09-14  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/3182
	* objcopy.c (group_signature): Return proper group signature.

binutils/testsuite/

2006-09-14  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/3182
	* binutils-all/objcopy.exp: Run strip-1 and strip-2 for ELF
	targets.

	* binutils-all/strip-1.d: New file.
	* binutils-all/strip-2.d: Likewise.

	* lib/utils-lib.exp (run_dump_test): Support strip.
@
text
@d1767 1
d1774 1
d1794 1
a1794 1
  char *dir = make_tempname (bfd_get_filename (obfd));
d1797 9
d1809 1
d1836 6
d1846 1
d2724 8
d3332 4
@


1.101
log
@	PR 3182
	* elf.c (_bfd_elf_copy_private_header_data): Fix group members
	that have had their SHT_GROUP section removed.
	* objcopy.c (group_signature): New function, split out from..
	(setup_section): ..here.
	(is_strip_section): Return true for SHT_GROUP sections that are
	going to lose their group signature symbol.
@
text
@d807 1
a807 1
	return isympp[ghdr->sh_info];
@


1.100
log
@	PR 3182
	* objcopy.c (copy_object): Load symbols earlier.
	(setup_section): Mark group signature symbols with BSF_KEEP.
@
text
@d788 24
d842 24
a865 6
  /* PR binutils/3166
     Group sections look like debugging sections but they are not.
     (They have a non-zero size but they are not ALLOCated).  */
  if ((bfd_get_section_flags (abfd, sec) & SEC_GROUP) != 0
      && strip_symbols == STRIP_NONDEBUG)
    return TRUE;
d2259 1
a2259 2
  else if ((isection->flags & SEC_GROUP) != 0
	   && bfd_get_flavour (ibfd) == bfd_target_elf_flavour)
d2261 1
a2261 1
      Elf_Internal_Shdr *ghdr;
d2263 2
a2264 10
      ghdr = &elf_section_data (isection)->this_hdr;
      if (ghdr->sh_link < elf_numsections (ibfd))
	{
	  const struct elf_backend_data *bed = get_elf_backend_data (ibfd);
	  Elf_Internal_Shdr *symhdr = elf_elfsections (ibfd) [ghdr->sh_link];

	  if (symhdr->sh_type == SHT_SYMTAB
	      && ghdr->sh_info < symhdr->sh_size / bed->s->sizeof_sym)
	    isympp[ghdr->sh_info]->flags |= BSF_KEEP;
	}
@


1.99
log
@PR binutils/3110
* objcopy.c (copy_archive): Add new parameter: force_output_target. If not
  true, then perserve the file formats of each copied archive element,
  otherwise force them to be one specific file format.
  (copy_file): Compute force_output_target parameter to pass to copy_archive.
@
text
@d1328 15
a1561 15
  symsize = bfd_get_symtab_upper_bound (ibfd);
  if (symsize < 0)
    {
      bfd_nonfatal (bfd_get_archive_filename (ibfd));
      return FALSE;
    }

  osympp = isympp = xmalloc (symsize);
  symcount = bfd_canonicalize_symtab (ibfd, isympp);
  if (symcount < 0)
    {
      bfd_nonfatal (bfd_get_filename (ibfd));
      return FALSE;
    }

d2217 16
@


1.98
log
@PR binutils/3166
* objcopy.c (is_strip_section): Do not treat group sections as debugging sections.
* doc/binutils.texi (--only-keep-debug): Document that this switch is only intended for use on fully linked files.
@
text
@d1733 4
a1736 1
   contents to temp file, and keep the temp file handle.  */
d1739 2
a1740 1
copy_archive (bfd *ibfd, bfd *obfd, const char *output_target)
a1795 1
      output_bfd = bfd_openw (output_name, output_target);
a1810 3
      if (output_bfd == NULL)
	RETURN_NONFATAL (output_name);

d1813 10
d1843 1
d1925 1
d1931 6
a1936 1
	output_target = bfd_get_target (ibfd);
d1942 1
a1942 1
      copy_archive (ibfd, obfd, output_target);
@


1.97
log
@ PR binutils/3001
* addr2line.c (process_file): Change function from void to returning an int.  Return 0 upon success, 1 otherwise.
 (main): Use return value from process_file as the exit value.
* ar.c (ranlib_only):  Change function from void to returning an int.  Return 0 upon success, 1 otherwise.
  (ranlib_touch): Likewise.
  (main): Use return value from ranlib functions as exit value.
* objcopy.c (add_specific_symbol): Set status to 1 if get_file_size fails.
  (copy_file): Likewise.
  (strip_main): Likewise.
  (copy_main): Likewise.
* objdump.c (display_file): Set exit_status to 1 if get_file_size fails.
* size.c (display_file): Set return_code to 1 if get_file_size fails.
@
text
@d818 7
@


1.96
log
@binutils/
	* objcopy.c (localize_hidden): New variable.
	(OPTION_LOCALIZE_HIDDEN): New command_line_switch value.
	(copy_options): Add --localize-hidden.
	(copy_usage): Mention --localize-hidden.
	(is_hidden_symbol): New function.
	(filter_symbols): Handle localize_hidden.
	(copy_object): Call filter_symbols if localize_hidden.
	(copy_main): Handle OPTION_LOCALIZE_HIDDEN.
	* doc/binutils.texi (--localize-hidden): Document new option.

binutils/testsuite/
	* binutils-all/localize-hidden-1.s,
	* binutils-all/localize-hidden-1.d,
	* binutils-all/localize-hidden-2.s,
	* binutils-all/localize-hidden-2.d: New tests.
	* binutils-all/objcopy.exp: Run them.
@
text
@d656 4
a659 1
    return;
a1894 1
      non_fatal (_("error: the input file '%s' is empty"), input_filename);
d2617 4
a2620 1
	continue;
d2631 1
a2632 1

d2648 1
a2648 1
  return 0;
d2817 4
a2820 1
	      break;
@


1.95
log
@* objcopy.c (use_alt_mach_code): Change type to unsigned long.
   (copy_object):  If bfd_alt_mach_code fails emit a more helpful message
   and if the target architecture is ELF use the alternative as replacement
   value for the e_machine number.
   (copy_main): Use strtoul to parse the number provided with the
   --alt-mach-code switch.
* doc/binutils.texi (--alt-mach-code): Document that this switch can now
    set the absolute e_machine value.
@
text
@d193 3
d246 1
d335 1
d436 1
d818 18
d982 2
a983 1
		      && ! is_specified_symbol (name, keepglobal_specific_list))))
d1560 1
d3093 4
@


1.95.2.1
log
@binutils/
	* objcopy.c (localize_hidden): New variable.
	(OPTION_LOCALIZE_HIDDEN): New command_line_switch value.
	(copy_options): Add --localize-hidden.
	(copy_usage): Mention --localize-hidden.
	(is_hidden_symbol): New function.
	(filter_symbols): Handle localize_hidden.
	(copy_object): Call filter_symbols if localize_hidden.
	(copy_main): Handle OPTION_LOCALIZE_HIDDEN.
	* doc/binutils.texi (--localize-hidden): Document new option.

binutils/testsuite/
	* binutils-all/localize-hidden-1.s,
	* binutils-all/localize-hidden-1.d,
	* binutils-all/localize-hidden-2.s,
	* binutils-all/localize-hidden-2.d: New tests.
	* binutils-all/objcopy.exp: Run them.
@
text
@a192 3
/* True if --localize-hidden is in effect.  */
static bfd_boolean localize_hidden = FALSE;

a242 1
    OPTION_LOCALIZE_HIDDEN,
a330 1
  {"localize-hidden", no_argument, 0, OPTION_LOCALIZE_HIDDEN},
a430 1
     --localize-hidden             Turn all ELF hidden symbols into locals\n\
a811 18
/* Return true if SYM is a hidden symbol.  */

static bfd_boolean
is_hidden_symbol (asymbol *sym)
{
  elf_symbol_type *elf_sym;

  elf_sym = elf_symbol_from (sym->the_bfd, sym);
  if (elf_sym != NULL)
    switch (ELF_ST_VISIBILITY (elf_sym->internal_elf_sym.st_other))
      {
      case STV_HIDDEN:
      case STV_INTERNAL:
	return TRUE;
      }
  return FALSE;
}

d958 1
a958 2
		      && ! is_specified_symbol (name, keepglobal_specific_list))
		  || (localize_hidden && is_hidden_symbol (sym))))
a1534 1
      || localize_hidden
a3066 4
	case OPTION_LOCALIZE_HIDDEN:
	  localize_hidden = TRUE;
	  break;

@


1.95.2.2
log
@	binutils/
	* Makefile.am: Rebuild dependencies.
	(REPORT_BUGS_TO): Always defined.
	(INCLUDES): Adjust.
	* Makefile.in: Rebuilt.
	* configure.in (REPORT_BUGS_TO): Provide default value.
	* configure: Rebuilt.
	* bucomm.h: Remove bin-bugs.h.
	* addr2line.c (usage): Don't print empty REPORT_BUGS_TO.
	* coffdump.c (show_usage): Likewise.
	* cxxfilt.c (usage): Likewise.
	* nlmconv.c (show_usage): Likewise.
	* nm.c (usage): Likewise.
	* objcopy.c (copy_usage, strip_usage): Likewise.
	* objdump.c (usage): Likewise.
	* size.c (usage): Likewise.
	* srconv.c (show_usage): Likewise.
	* string.c (usage): Likewise.
	* sysdymp.c (show_usage): Likewise.
	* windres.c (usage): Likewise.
	* readelf (usage): Likewise. Add STREAM argument.  Adjust callers.

	gas/
	* Makefile.am: Rebuild dependencies.
	(REPORT_BUGS_TO): Always defined.
	(INCLUDES): Adjust.
	* Makefile.in: Rebuilt.
	* configure.in (REPORT_BUGS_TO): Provide default value.
	* configure: Rebuilt.
	* as.c (show_usage): Don't print empty REPORT_BUGS_TO.
	* as.h: Remove bin-bugs.h.

	ld/
	* Makefile.am: Rebuild dependencies.
	(REPORT_BUGS_TO): Always defined.
	(INCLUDES): Adjust.
	* Makefile.in: Rebuilt.
	* configure.in (REPORT_BUGS_TO): Provide default value.
	* configure: Rebuilt.
	* ld.h: Remove bin-bugs.h
	* lexsup.c (help):  Don't print empty REPORT_BUGS_TO.

	gprof/
	* Makefile.am: Rebuild dependencies.
	(REPORT_BUGS_TO): Always defined.
	(PKGVERSION): Define.
	(INCLUDES): Adjust.
	* Makefile.in: Rebuilt.
	* configure.in (REPORT_BUGS_TO): Provide default value.
	* configure: Rebuilt.
	* gprof.c (usage): Don't print empty REPORT_BUGS_TO.
	* gprof.h: Remove bin-bugs.h

	include/
	* bin-bugs.h: Remove.
@
text
@d499 1
a499 1
  if (REPORT_BUGS_TO[0] && exit_status == 0)
d534 1
a534 1
  if (REPORT_BUGS_TO[0] && exit_status == 0)
@


1.94
log
@* objcopy.c (copy_object): Catch the case where an attempt is made to add a
    section that already exists and produce a more helpful warning message.
@
text
@d150 2
a151 2
/* Use alternate machine code?  */
static int use_alt_mach_code = 0;
d476 1
a476 1
     --alt-machine-code <index>    Use alternate machine code for output\n\
d1670 15
a1684 3
  if (use_alt_mach_code != 0
      && ! bfd_alt_mach_code (obfd, use_alt_mach_code))
    non_fatal (_("unknown alternate machine code, ignored"));
d3084 3
a3086 3
	  use_alt_mach_code = atoi (optarg);
	  if (use_alt_mach_code <= 0)
	    fatal (_("alternate machine code index must be positive"));
@


1.93
log
@PR binutils/1391
* objcopy.c (copy_object): For PE format targets set the VMA of a newly
  created gnu_debuglink section to a non-zero, aligned, contiguous value.
* Makefile.am (objcopy.c): Add a dependency upon libbfd.h.
* Makefile.in: Regenerate.
@
text
@d1316 3
a1318 2
	  padd->section = bfd_make_section_with_flags (obfd, padd->name, flags);
	  if (padd->section == NULL)
d1320 1
a1320 2
	      non_fatal (_("can't create section `%s': %s"),
		       padd->name, bfd_errmsg (bfd_get_error ()));
d1323 10
@


1.92
log
@	* objcopy.c (copy_object): Fix thinko.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005
d33 1
d1366 43
@


1.91
log
@	* objcopy.c (copy_object): Set isympp and osympp to NULL after free.
@
text
@d1284 1
a1284 4
    {
      free (isympp);
      isympp = NULL;
    }
d1287 4
a1290 4
    {
      free (osympp);
      osympp = NULL;
    }
@


1.90
log
@binutils/
2005-11-15  Jan Beulich  <jbeulich@@novell.com>

	* objcopy.c (keep_file_symbols): New.
	(enum command_line_switch): Add OPTION_KEEP_FILE_SYMBOLS.
	(strip_options): Add --keep-file-symbols.
	(copy_options): Likewise.
	(copy_usage): Likewise.
	(strip_usage): Likewise.
	(filter_symbols): Act upon keep_file_symbols.
	(strip_main): Handle OPTION_KEEP_FILE_SYMBOLS.
	(copy_main): Likewise.
	* doc/binutils.texi: Document --keep-file-symbols for objcopy
	and strip.
@
text
@d1284 4
a1287 1
    free (isympp);
d1290 4
a1293 1
    free (osympp);
@


1.89
log
@Remove spurious checking of a potential, but untested patch.
@
text
@d206 3
d255 1
d273 1
d325 1
d429 1
d515 1
d937 3
a939 1
      if (!keep && is_specified_symbol (name, keep_specific_list))
d2473 3
d2633 4
@


1.88
log
@PR binutils/1437
* cxxfilt.c (flags): Remove DMGL_TYPES;
  (long_options): Rename --no-types to --types.
  (usage): Likewise.
  (demangle_it): Add a comment describing why _ and $ prefixes are skipped.
  Use printf rather than puts to emit the demangled output in order to avoid
  emitting a new line character.
  (main): Have the -t flag enable type demangling.
  Emit a newline after every demangled command line argument.
  Copy whitespace from stdin to stdout.
* doc/binutils.texi (c++filt): Document the change to the -t switch.
  Document why demangling names on the command line is slightly different
  to demangling names read from the standard input.
@
text
@a1351 7

      if (bfd_get_flavour (obfd) == bfd_target_coff_flavour)
	/* Try to set the VMA of the section to some non-zero value so
	   that it will work for PE format files.  (We have no way to
	   distinguish between COFF and PE flavours).  If this does not
	   work, just ignore the failure.  */
	bfd_set_section_vma (obfd, gnu_debuglink_section, 0xf0000000);
@


1.87
log
@	* addr2line.c (usage): Document @@file.
	* ar.c (usage): Likewise.
	* coffdump (usage): Likewise.
	* cxxfilt.c (usage): Likewise.
	* dlltool.c (usage): Likewise.
	* dllwrap.c (usage): Likewise.
	* nlmconv.c (usage): Likewise.
	* nm.c (usage): Likewise.
	* objcopy.c (usage): Likewise.
	* objdump.c (usage): Likewise.
	* readelf.c (usage): Likewise.
	* size.c (usage): Likeise.
	* srconv.c (usage): Likewise.
	* strings.c (usage): Likewise.
	* windres.c (usage): Likewise.
	* doc/binutils.texi: Add section on common options.
@
text
@d1352 7
@


1.86
log
@	* addr2line.c (main): Likewise.
	* ar.c (main): Likewise.
	* coffdump.c (main): Likewise.
	* cxxfilt.c (main): Likewise.
	* dlltool.c (main): Likewise.
	* dllwrap.c (main): Likewise.
	* nlmconv.c (main): Likewise.
	* nm.c (main): Likewise.
	* objcopy.c (main): Likewise.
	* objdump.c (main): Likewise.
	* readelf.c (main): Likewise.
	* size.c (main): Likeiwse.
	* srcconv.c (main): Likewise.
	* strings.c (main): Likewise.
	* sysdump.c (main): Likewise.
	* sysinfo.c (main): Likewise.
	* windres.c (main): Likewise.

	* ldmain.c (main): Use expandargv.

	* gprof.c (main): Use expandargv.

	* as.c (main): Use expandargv.
@
text
@d479 1
@


1.85
log
@	PR 1004
bfd/
	* elf-bfd.h (struct elf_backend_data): Add get_sec_type_attr.  Delete
	special_sections.
	(_bfd_elf_get_special_section): Declare.
	(bfd_elf_special_section): Update prototype.
	* elf.c (special_sections): Remove unused outer entries.
	(get_special_section): Delete.
	(_bfd_elf_get_special_section): New function.
	(_bfd_elf_get_sec_type_attr): Replace "name" arg with "sec".  Update
	special_sections indexing.
	(_bfd_elf_new_section_hook): Call backend get_sec_type_attr.
	* elf32-arm.c (symbian_special_sections_d): Delete.
	(symbian_special_sections_g, symbian_special_sections_h): Delete.
	(symbian_special_sections_i, symbian_special_sections_f): Delete.
	(symbian_special_sections_p): Delete.
	(elf32_arm_symbian_special_sections): Merge above to here.
	(elf32_arm_symbian_get_sec_type_attr): New function.
	(elf_backend_special_sections): Don't define.
	(elf_backend_get_sec_type_attr): Define.
	* elf32-m32r.c: Similarly to elf32-arm.c.
	* elf32-m68hc11.c: Likewise.
	* elf32-m68hc12.c: Likewise.
	* elf32-mcore.c: Likewise.
	* elf32-sh64.c: Likewise.
	* elf32-v850.c: Likewise.
	* elf32-xtensa.c: Likewise.
	* elf64-alpha.c: Likewise.
	* elf64-hppa.c: Likewise.
	* elf64-ppc.c: Likewise.
	* elf64-sh64.c: Likewise.
	* elfxx-ia64.c: Likewise.
	* elfxx-mips.c: Likewise.
	* elf32-ppc.c: Likewise.
	(bfd_elf_special_section ppc_alt_plt): New.  Use it if .plt loadable.
	* elfxx-mips.h (_bfd_mips_elf_get_sec_type_attr): Declare.
	(_bfd_mips_elf_special_sections, elf_backend_special_sections): Delete.
	(elf_backend_get_sec_type_attr): Define.
	* elfxx-target.h (elf_backend_get_sec_type_attr): Define.
	(elf_backend_special_sections): Don't define.
	(elfNN_bed): Update.

binutils/
	* objcopy.c (copy_object): Use bfd_make_section_with_flags.
	(write_debugging_info): Likewise.
	(setup_section): Use bfd_make_section_anyway_with_flags.
gas/
	* config/obj-elf.c (obj_elf_change_section): Use backend
	get_sec_type_attr.
@
text
@d3184 2
@


1.84
log
@2005-06-14  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 995
	* ar.c (BUFSIZE): Moved to ...
	* bucomm.h (BUFSIZE): Here.

	* bucomm.c: Include <assert.h>.
	(bfd_get_archive_filename): New.
	* bucomm.h (bfd_get_archive_filename): New.

	* objcopy.c (copy_unknown_object): New.
	(copy_object): Use bfd_get_archive_filename when reporting input
	error. Don't call fatal on unknown arch.
	(copy_archive): Call copy_unknown_object on unknown format or
	arch.
@
text
@d1293 9
a1301 1
	  padd->section = bfd_make_section (obfd, padd->name);
a1314 15
	  pset = find_section_list (padd->name, FALSE);
	  if (pset != NULL)
	    pset->used = TRUE;

	  if (pset != NULL && pset->set_flags)
	    flags = pset->flags | SEC_HAS_CONTENTS;
	  else
	    flags = SEC_HAS_CONTENTS | SEC_READONLY | SEC_DATA;

	  if (! bfd_set_section_flags (obfd, padd->section, flags))
	    {
	      bfd_nonfatal (bfd_get_filename (obfd));
	      return FALSE;
	    }

d1997 6
a2002 1
  osection = bfd_make_section_anyway (obfd, name);
d2010 6
a2063 15
  if (p != NULL && p->set_flags)
    flags = p->flags | (flags & (SEC_HAS_CONTENTS | SEC_RELOC));
  else if (strip_symbols == STRIP_NONDEBUG && (flags & SEC_ALLOC) != 0)
    {
      flags &= ~(SEC_HAS_CONTENTS | SEC_LOAD);
      if (obfd->xvec->flavour == bfd_target_elf_flavour)
	elf_section_type (osection) = SHT_NOBITS;
    }

  if (!bfd_set_section_flags (obfd, osection, flags))
    {
      err = _("flags");
      goto loser;
    }

d2345 1
d2352 3
a2354 2
      stabsec = bfd_make_section (obfd, ".stab");
      stabstrsec = bfd_make_section (obfd, ".stabstr");
d2360 1
a2360 9
	  || ! bfd_set_section_alignment (obfd, stabstrsec, 0)
	  || ! bfd_set_section_flags (obfd, stabsec,
				   (SEC_HAS_CONTENTS
				    | SEC_READONLY
				    | SEC_DEBUGGING))
	  || ! bfd_set_section_flags (obfd, stabstrsec,
				      (SEC_HAS_CONTENTS
				       | SEC_READONLY
				       | SEC_DEBUGGING)))
@


1.83
log
@Update FSF address
@
text
@d1123 68
d1220 2
a1221 2
    printf (_("copy from %s(%s) to %s(%s)\n"),
	    bfd_get_filename (ibfd), bfd_get_target (ibfd),
d1244 1
a1244 1
	  bfd_nonfatal (bfd_get_filename (ibfd));
d1257 2
a1258 2
	fatal (_("Unable to recognise the format of the input file %s"),
	       bfd_get_filename (ibfd));
d1260 4
a1263 6
	{
	  non_fatal (_("Warning: Output file cannot represent architecture %s"),
		     bfd_printable_arch_mach (bfd_get_arch (ibfd),
					      bfd_get_mach (ibfd)));
	  return FALSE;
	}
d1268 1
a1268 1
      bfd_nonfatal (bfd_get_filename (ibfd));
d1454 1
a1454 1
      bfd_nonfatal (bfd_get_filename (ibfd));
d1703 2
a1704 1
	delete = ! copy_object (this_element, output_bfd);
d1706 14
a1719 1
      if (!bfd_close (output_bfd))
d1721 11
a1731 3
	  bfd_nonfatal (bfd_get_filename (output_bfd));
	  /* Error in new object file. Don't change archive.  */
	  status = 1;
@


1.82
log
@binutils/
2005-05-06  Jan Beulich  <jbeulich@@novell.com>

	* objcopy.c (copy_file): Don't delete output upon error here.
	(copy_main): Delete output upon error.
@
text
@d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.81
log
@PR872
* objcopy.c (copy_archive): Initialise 'obfd' field of new name_list structure.
@
text
@a1733 1
      bfd_boolean delete;
d1745 2
a1746 1
      delete = ! copy_object (ibfd, obfd);
a1753 5
      if (delete)
	{
	  unlink_if_ordinary (output_filename);
	  status = 1;
	}
d3052 2
@


1.80
log
@Oops - forgot one place where -K is documented.
@
text
@d1630 1
@


1.79
log
@* objcopy.c (copy_usage): Fix description of -K switch.
* doc/binutils.texi (strip, objcopy): Fix description of -K switch.
@
text
@d506 1
a506 1
  -K --keep-symbol=<name>          Only copy symbol <name>\n\
@


1.78
log
@Issue an error message when attmepting to copy an empty input file.
@
text
@d422 1
a422 1
  -K --keep-symbol <name>          Only copy symbol <name>\n\
@


1.77
log
@Add new switch --globalize-symbol to convert local symbols into globals.
@
text
@d1704 1
@


1.76
log
@update copyright dates
@
text
@d198 1
d240 2
d312 2
d424 1
d465 1
d933 1
a933 2
      if (keep && (flags & BSF_GLOBAL) != 0
	  && (weaken || is_specified_symbol (name, weaken_specific_list)))
d935 26
a960 10
	  sym->flags &=~ BSF_GLOBAL;
	  sym->flags |= BSF_WEAK;
	}
      if (keep && !undefined && (flags & (BSF_GLOBAL | BSF_WEAK))
	  && (is_specified_symbol (name, localize_specific_list)
	      || (keepglobal_specific_list != NULL
		  && ! is_specified_symbol (name, keepglobal_specific_list))))
	{
	  sym->flags &= ~(BSF_GLOBAL | BSF_WEAK);
	  sym->flags |= BSF_LOCAL;
a961 3

      if (keep)
	to[dst_count++] = sym;
d1411 1
d2571 4
d2916 4
@


1.76.6.1
log
@	* ld/ldmain.c (main): Use expandargv.
	* binutils/addr2line.c (main): Likewise.
	* binutils/ar.c (main): Likewise.
	* binutils/coffdump.c (main): Likewise.
	* binutils/cxxfilt.c (main): Likewise.
	* binutils/dlltool.c (main): Likewise.
	* binutils/dllwrap.c (main): Likewise.
	* binutils/nlmconv.c (main): Likewise.
	* binutils/nm.c (main): Likewise.
	* binutils/objcopy.c (main): Likewise.
	* binutils/objdump.c (main): Likewise.
	* binutils/readelf.c (main): Likewise.
	* binutils/size.c (main): Likeiwse.
	* binutils/srcconv.c (main): Likewise.
	* binutils/strings.c (main): Likewise.
	* binutils/sysdump.c (main): Likewise.
	* binutils/sysinfo.c (main): Likewise.
	* binutils/windres.c (main): Likewise.

	* include/libiberty.h (expandargv): New function.
	* libiberty/argv.c (safe-ctype.h): Include it.
	(ISBLANK): Remove.
	(stdio.h): Include.
	(expandargv): New function.
	* libiberty/Makefile.in: Regenerated.
@
text
@a3085 2
  expandargv (&argc, &argv);

@


1.75
log
@bfd/
2005-03-02  Jan Beulich  <jbeulich@@novell.com>

	* Makefile.am: Add dependency of cache.o on libiberty.h.
	* cache.c: Include libiberty.h.
	(bfd_open_file): Use unlink_if_ordinary instead of unlink.

binutils/
2005-03-02  Jan Beulich  <jbeulich@@novell.com>

	* ar.c (remove_output): Use unlink_if_ordinary instead of unlink.
	* objcopy.c (copy_file): Likewise.
	(strip_main): Likewise.

gas/
2005-03-02  Jan Beulich  <jbeulich@@novell.com>

	* as.c (main): Use unlink_if_ordinary instead of unlink.
	* messages.c (as_fatal): Likewise.

ld/
2005-03-02  Jan Beulich  <jbeulich@@novell.com>

	* ldmain.c (remove_output): Use unlink_if_ordinary instead of unlink.
	* pe-dll.c (pe_dll_generate_implib): Likewise.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004
@


1.74
log
@bfd/

2005-02-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* coffcode.h (sec_to_styp_flags): Replaced SEC_CLINK with
	SEC_TIC54X_CLINK. Replace SEC_BLOCK with SEC_TIC54X_BLOCK.
	Replace SEC_SHARED with SEC_COFF_SHARED.
	(styp_to_sec_flags): Likewise.

	* elfxx-target.h (TARGET_BIG_SYM): Remove SEC_ARCH_BIT_0.
	(TARGET_LITTLE_SYM): Likewise.

	* section.c (SEC_ARCH_BIT_0): Removed.
	(SEC_LINK_DUPLICATES_SAME_CONTENTS): Defined with
	SEC_LINK_DUPLICATES_ONE_ONLY and SEC_LINK_DUPLICATES_SAME_SIZE.
	(SEC_SHARED): Renamed to ...
	(SEC_COFF_SHARED): This.
	(SEC_BLOCK): Renamed to ...
	(SEC_TIC54X_BLOCK): This.
	(SEC_CLINK): Renamed to ...
	(SEC_TIC54X_CLINK): This.
	(SEC_XXX): Rearranged. Move SEC_COFF_SHARED_LIBRARY,
	SEC_COFF_SHARED, SEC_TIC54X_BLOCK and SEC_TIC54X_CLINK to the
	end.
	* bfd-in2.h: Regenerated.

binutils/

2005-02-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* objcopy.c (parse_flags): Replace SEC_SHARED with
	SEC_COFF_SHARED.

	* objdump.c (dump_section_header): Dump SEC_TIC54X_BLOCK and
	SEC_TIC54X_CLINK for TI c54x only. Remove SEC_ARCH_BIT_0. Dump
	SEC_COFF_SHARED for COFF only.

gas/

2005-02-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-coff.c (obj_coff_section): Replace SEC_SHARED with
	SEC_COFF_SHARED.

	* config/tc-tic54x.c (tic54x_bss): Replace SEC_BLOCK with
	SEC_TIC54X_BLOCK.
	(demand_empty_rest_of_line): Likewise.
	(tic54x_sblock): Likewise.
	(tic54x_clink): Replace with SEC_CLINK with SEC_TIC54X_CLINK.

ld/

2005-02-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldlang.c (lang_add_section): Check SEC_TIC54X_BLOCK for TI
	tic54x input only.
	(lang_size_sections_1): Check SEC_COFF_SHARED_LIBRARY for COFF
	and ECOFF output only.
@
text
@d1734 1
a1734 1
	  unlink (output_filename);
d2441 1
a2441 1
	unlink (tmpname);
@


1.73
log
@binutils/
2004-12-15 Jan Beulich  <jbeulich@@novell.com>

	* doc/binutils.texi: Document --strip-unneeded-symbol and
	--strip-unneeded-symbols.
	* objcopy.c (strip_unneeded_list): New.
	(enum command_line_switch): Add OPTION_STRIP_UNNEEDED_SYMBOL
	and OPTION_STRIP_UNNEEDED_SYMBOLS.
	(copy_options): Add  --strip-unneeded-symbol and
	--strip-unneeded-symbols.
	(copy_usage): Likewise.
	(filter_symbols): Suppress copying of symbol if in strip_unneeded_list
	and the symbol is not needed.
	(copy_main): Handle OPTION_STRIP_UNNEEDED_SYMBOL and
	OPTION_STRIP_UNNEEDED_SYMBOLS.
@
text
@d550 1
a550 1
      PARSE_FLAG ("share", SEC_SHARED);
@


1.72
log
@strings.c (usage): Place radix values for -t option into the correct order.

objcopy.c (add_redefine_syms_file): Change error messages to use
  <filename>:<linenumber>: format for easier parsing by automatic tools.

srconv.c (show_usage): Fix spelling typo.

windres.c (format_from_filename): Suggest the use of -J instead	of -I if the
  file type cannot be determined.
@
text
@d195 1
d235 2
d346 2
d413 3
d454 3
d917 4
d2543 4
d2880 4
@


1.71
log
@bfd/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* aout-adobe.c (aout_32_section_already_linked): Defined.
	* aout-target.h (MY_section_already_linked): Likewise.
	* aout-tic30.c (MY_section_already_linked): Likewise.
	* binary.c (binary_section_already_linked): Likewise.
	* bout.c (b_out_section_already_linked): Likewise.
	* coff-alpha.c (_bfd_ecoff_section_already_linked): Likewise.
	* coff-mips.c (_bfd_ecoff_section_already_linked): Likewise.
	* coffcode.h (coff_section_already_linked): Likewise.
	* i386msdos.c (msdos_section_already_linked): Likewise.
	* i386os9k.c (os9k_section_already_linked): Likewise.
	* ieee.c (ieee_section_already_linked): Likewise.
	* ihex.c (ihex_section_already_linked): Likewise.
	* mach-o.c (bfd_mach_o_section_already_linked): Likewise.
	* mmo.c (mmo_section_already_linked): Likewise.
	* nlm-target.h (nlm_section_already_linked): Likewise.
	* oasys.c (oasys_section_already_linked): Likewise.
	* pef.c (bfd_pef_section_already_linked): Likewise.
	* ppcboot.c (ppcboot_section_already_linked): Likewise.
	* som.c (som_bfd_discard_group): Likewise.
	* srec.c (srec_section_already_linked): Likewise.
	* tekhex.c (tekhex_section_already_linked): Likewise.
	* versados.c (versados_section_already_linked): Likewise.
	* vms.c (vms_section_already_linked): Likewise.
	* coff-target.h (_bfd_xcoff_section_already_linked): Likewise.
	* xsym.c (bfd_sym_section_already_linked): Likewise.

	* bfd-in.h (bfd_section_already_linked_table_init): New.
	(bfd_section_already_linked_table_free): Likewise.

	* coff-rs6000.c (rs6000coff_vec): Add
	_bfd_generic_section_already_linked.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.

	* elf-bfd.h (_bfd_elf_section_already_linked): New prototype.
	* elflink.c (_bfd_elf_section_already_linked): New function.

	* elfxx-target.h (bfd_elfNN_section_already_linked): Defined.

	* libbfd-in.h (_bfd_nolink_section_already_linked): Defined.
	(_bfd_generic_section_already_linked): New.
	(bfd_section_already_linked_hash_entry): Likewise.
	(bfd_section_already_linked): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.

	* linker.c (bfd_section_already_linked): New.
	(_bfd_section_already_linked_table): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.
	(already_linked_newfunc): Likewise.
	(bfd_section_already_linked_table_init): Likewise.
	(bfd_section_already_linked_table_free): Likewise.
	(_bfd_generic_section_already_linked): Likewise.

	* section.c (bfd_section): Remove comdat.
	(bfd_comdat_info): Moved to ...
	* bfd-in.h (coff_comdat_info): Here.
	(bfd_coff_get_comdat_section): New.
	* coffgen.c (bfd_coff_get_comdat_section): Likewise.
	* libcoff-in.h (coff_section_tdata): Add comdat.
	* coffcode.h (handle_COMDAT): Updated.
	* cofflink.c (coff_link_add_symbols): Likewise.
	* ecoff.c (bfd_debug_section): Likewise.

	* targets.c (bfd_target): Add _section_already_linked.
	(BFD_JUMP_TABLE_LINK): Updated.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.
	* libcoff.h: Likewise.

binutils/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* objcopy.c (filter_symbols): Use bfd_coff_get_comdat_section
	to access comdat.
	* objdump.c (dump_section_header): Likewise.

ld/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldlang.c (already_linked_hash_entry): Removed.
	(already_linked): Likewise.
	(already_linked_table): Likewise.
	(section_already_linked): Call bfd_section_already_linked.
	(lang_process): Replace already_linked_table_init with
	bfd_section_already_linked_table_init and check return. Replace
	already_linked_table_free with bfd_section_already_linked_table_free.
@
text
@d703 2
a704 2
	    non_fatal (_("Ignoring rubbish found on line %d of %s"),
		       line_count, filename);
d1071 1
a1071 1
	fatal (_("%s: garbage at end of line %d"), filename, lineno);
d1074 1
a1074 1
	fatal (_("%s: missing new symbol name at line %d"), filename, lineno);
d1084 1
a1084 1
    fatal (_("%s: premature end of file at line %d"), filename, lineno);
@


1.70
log
@bfd/
	* section.c (struct sec): Rename "_cooked_size" to "size".
	Rename "_raw_size" to "rawsize".
	(STD_SECTION): Adjust comments.
	(bfd_set_section_size, bfd_get_section_contents): Use size.
	(bfd_malloc_and_get_section): New function.
	* bfd-in.h (bfd_section_size, bfd_get_section_size): Use size.
	* coff-sh.c (sh_relax_section): Alloc coff_section_data struct early.
	Correctly free reloc and contents memory.
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame): Delete FIXME
	and fake CIE now that we can shink section size to zero.
	(_bfd_elf_write_section_eh_frame): Likewise..
	* elf32-ppc.c (ppc_elf_relax_section): Delay reading section contents.
	* elf-m10300.c (mn10300_elf_final_link_relocate): Don't use
	_bfd_stab_section_offset.  Use _bfd_elf_section_offset.
	* stabs.c (_bfd_stab_section_offset_): Remove unused args and
	unneeded indirection.
	* elf.c (_bfd_elf_section_offset): .. and update call.
	* libbfd-in.h (_bfd_stab_section_offset): Update prototype.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.

	Replace occurrences of "_raw_size" and "_cooked_size" in most places
	with "size".  Set new "rawsize" for stabs, eh_frame, and SEC_MERGE
	sections.  Use "rawsize", if non-zero, for bfd_get_section_contents
	calls if the section might be a stabs, eh_frame, or SEC_MERGE section.
	Similarly use "rawsize", if non-zero, in reloc functions to validate
	reloc addresses.  Use new bfd_malloc_and_get_section in most places
	where bfd_get_section_contents was called.  Expand all occurrences of
	bfd_section_size and bfd_get_section_size.  Rename "raw_size" var in
	grok_prstatus and similar functions to "size".
	* aix386-core.c (aix386_core_file_p): ..
	* aix5ppc-core.c (xcoff64_core_p): ..
	* aout-adobe.c (aout_adobe_callback, aout_adobe_write_object_contents,
	aout_adobe_set_section_contents): ..
	* aout-target.h (callback): ..
	* aout-tic30.c (tic30_aout_callback, tic30_aout_final_link_relocate,
	MY_bfd_final_link): ..
	* aoutf1.h (sunos4_core_file_p): ..
	* aoutx.h (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, translate_from_native_sym_flags,
	final_link, aout_link_input_section): ..
	* binary.c (binary_object_p, binary_canonicalize_symtab,
	binary_set_section_contents): ..
	* bout.c (b_out_callback, b_out_write_object_contents,
	b_out_set_section_contents, b_out_bfd_relax_section,
	b_out_bfd_get_relocated_section_contents): ..
	* cisco-core.c (cisco_core_file_validate): ..
	* coff-alpha.c (alpha_ecoff_object_p,
	alpha_ecoff_get_relocated_section_conten, alpha_relocate_section): ..
	* coff-arm.c (coff_arm_relocate_section,
	bfd_arm_allocate_interworking_sections): ..
	* coff-h8300.c (h8300_reloc16_extra_cases,
	h8300_bfd_link_add_symbols): ..
	* coff-mips.c (mips_refhi_reloc, mips_gprel_reloc): ..
	* coff-ppc.c (coff_ppc_relocate_section, ppc_allocate_toc_section,
	ppc_bfd_coff_final_link): ..
	* coff-rs6000.c (xcoff_reloc_type_br, xcoff_ppc_relocate_section): ..
	* coff-sh.c (sh_relax_section, sh_relax_delete_bytes,
	sh_align_loads, sh_coff_get_relocated_section_contents): ..
	* coff64-rs6000.c (xcoff64_write_object_contents,
	xcoff64_reloc_type_br, xcoff64_ppc_relocate_section): ..
	* coffcode.h (coff_compute_section_file_positions,
	coff_write_object_contents): ..
	* coffgen.c (make_a_section_from_file, coff_write_symbols,
	coff_section_symbol, build_debug_section): ..
	* cofflink.c (coff_link_add_symbols, _bfd_coff_final_link,
	process_embedded_commands, _bfd_coff_link_input_bfd,
	_bfd_coff_write_global_sym): ..
	* cpu-arm.c (bfd_arm_update_notes, bfd_arm_get_mach_from_notes): ..
	* cpu-ns32k.c (do_ns32k_reloc, _bfd_ns32k_final_link_relocate): ..
	* dwarf1.c (parse_line_table, _bfd_dwarf1_find_nearest_line): ..
	* dwarf2.c (read_indirect_string, read_abbrevs, decode_line_info,
	_bfd_dwarf2_find_nearest_line): ..
	* ecoff.c (bfd_debug_section, ecoff_set_symbol_info,
	ecoff_compute_section_file_positions,
	_bfd_ecoff_write_object_contents, ecoff_indirect_link_order): ..
	* elf-eh-frame.c (_bfd_elf_discard_section_eh_frame,
	_bfd_elf_discard_section_eh_frame_hdr,
	_bfd_elf_maybe_strip_eh_frame_hdr, _bfd_elf_eh_frame_section_offset,
	_bfd_elf_write_section_eh_frame,
	_bfd_elf_write_section_eh_frame_hdr): ..
	* elf-hppa.h (elf_hppa_sort_unwind): ..
	* elf-m10200.c (mn10200_elf_relax_section,
	mn10200_elf_relax_delete_bytes,
	mn10200_elf_get_relocated_section_contents): ..
	* elf-m10300.c (_bfd_mn10300_elf_create_got_section,
	mn10300_elf_check_relocs, mn10300_elf_relax_section,
	mn10300_elf_relax_delete_bytes,
	mn10300_elf_get_relocated_section_contents,
	_bfd_mn10300_elf_adjust_dynamic_symbol,
	_bfd_mn10300_elf_discard_copies,
	_bfd_mn10300_elf_size_dynamic_sections,
	_bfd_mn10300_elf_finish_dynamic_sections): ..
	* elf.c (_bfd_elf_print_private_bfd_data, bfd_elf_get_bfd_needed_list,
	_bfd_elf_make_section_from_phdr, elf_fake_sections,
	bfd_elf_set_group_contents, map_sections_to_segments,
	elf_sort_sections, assign_file_positions_for_segments,
	SECTION_SIZE, copy_private_bfd_data,
	_bfd_elf_get_dynamic_reloc_upper_bound,
	_bfd_elf_canonicalize_dynamic_reloc, elfcore_maybe_make_sect,
	_bfd_elfcore_make_pseudosection, elfcore_grok_prstatus,
	elfcore_grok_lwpstatus, elfcore_grok_win32pstatus,
	elfcore_grok_note, elfcore_grok_nto_status, elfcore_grok_nto_gregs,
	_bfd_elf_rel_local_sym, _bfd_elf_get_synthetic_symtab): ..
	* elf32-arm.h (bfd_elf32_arm_allocate_interworking_sect,
	bfd_elf32_arm_process_before_allocation,
	elf32_arm_adjust_dynamic_symbol, allocate_dynrelocs,
	elf32_arm_size_dynamic_sections, elf32_arm_finish_dynamic_sections,
	elf32_arm_write_section): ..
	* elf32-cris.c (cris_elf_grok_prstatus,
	elf_cris_finish_dynamic_sections, cris_elf_gc_sweep_hook,
	elf_cris_adjust_gotplt_to_got, elf_cris_adjust_dynamic_symbol,
	cris_elf_check_relocs, elf_cris_size_dynamic_sections,
	elf_cris_discard_excess_dso_dynamics,
	elf_cris_discard_excess_program_dynamics): ..
	* elf32-d30v.c (bfd_elf_d30v_reloc, bfd_elf_d30v_reloc_21): ..
	* elf32-dlx.c (_bfd_dlx_elf_hi16_reloc): ..
	* elf32-frv.c (_frvfdpic_add_dyn_reloc, _frvfdpic_add_rofixup,
	_frv_create_got_section, _frvfdpic_assign_plt_entries,
	elf32_frvfdpic_size_dynamic_sections,
	elf32_frvfdpic_modify_segment_map,
	elf32_frvfdpic_finish_dynamic_sections): ..
	* elf32-h8300.c (elf32_h8_relax_section, elf32_h8_relax_delete_bytes,
	elf32_h8_get_relocated_section_contents): ..
	* elf32-hppa.c (hppa_build_one_stub, hppa_size_one_stub,
	elf32_hppa_adjust_dynamic_symbol, allocate_plt_static,
	allocate_dynrelocs, elf32_hppa_size_dynamic_sections, group_sections,
	elf32_hppa_size_stubs, elf32_hppa_set_gp, elf32_hppa_build_stubs,
	elf32_hppa_finish_dynamic_sections): ..
	* elf32-i370.c (i370_elf_adjust_dynamic_symbol,
	i370_elf_size_dynamic_sections, i370_elf_check_relocs,
	i370_elf_finish_dynamic_sections): ..
	* elf32-i386.c (elf_i386_grok_prstatus, elf_i386_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_i386_size_dynamic_sections,
	elf_i386_relocate_section, elf_i386_finish_dynamic_sections): ..
	* elf32-i860.c (i860_howto_pc26_reloc, i860_howto_pc16_reloc,
	i860_howto_highadj_reloc, i860_howto_splitn_reloc): ..
	* elf32-ip2k.c (ip2k_is_switch_table_128,
	ip2k_relax_switch_table_128, ip2k_is_switch_table_256,
	ip2k_relax_switch_table_256, ip2k_elf_relax_section,
	adjust_all_relocations, ip2k_elf_relax_delete_bytes): ..
	* elf32-m32r.c (m32r_elf_do_10_pcrel_reloc, m32r_elf_hi16_reloc,
	m32r_elf_generic_reloc, m32r_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, m32r_elf_size_dynamic_sections,
	m32r_elf_relocate_section, m32r_elf_finish_dynamic_sections,
	m32r_elf_relax_section, m32r_elf_relax_delete_bytes,
	m32r_elf_get_relocated_section_contents): ..
	* elf32-m68hc11.c (m68hc11_elf_build_one_stub,
	m68hc11_elf_size_one_stub, m68hc11_elf_relax_section,
	m68hc11_elf_relax_delete_bytes): ..
	* elf32-m68hc12.c (m68hc12_elf_build_one_stub,
	m68hc12_elf_size_one_stub): ..
	* elf32-m68hc1x.c (elf32_m68hc11_size_stubs,
	elf32_m68hc11_build_stubs, m68hc11_elf_special_reloc): ..
	* elf32-m68k.c (elf_m68k_check_relocs, elf_m68k_gc_sweep_hook,
	elf_m68k_adjust_dynamic_symbol, elf_m68k_size_dynamic_sections,
	elf_m68k_discard_copies, elf_m68k_finish_dynamic_sections): ..
	* elf32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elf32-or32.c (or32_elf_consth_reloc): ..
	* elf32-ppc.c (ppc_elf_relax_section, ppc_elf_addr16_ha_reloc,
	elf_create_pointer_linker_section, ppc_elf_create_linker_section,
	ppc_elf_additional_program_headers, ppc_elf_adjust_dynamic_symbol,
	allocate_dynrelocs, ppc_elf_size_dynamic_sections,
	ppc_elf_finish_dynamic_sections, ppc_elf_grok_prstatus,
	ppc_elf_final_write_processing): ..
	* elf32-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections, elf_s390_grok_prstatus): ..
	* elf32-sh.c (sh_elf_reloc_loop, sh_elf_relax_section,
	sh_elf_relax_delete_bytes, sh_elf_align_loads,
	sh_elf_adjust_dynamic_symbol, allocate_dynrelocs,
	sh_elf_size_dynamic_sections, sh_elf_get_relocated_section_contents,
	sh_elf_finish_dynamic_sections, elf32_shlin_grok_prstatus): ..
	* elf32-sh64-com.c (sh64_address_in_cranges,
	sh64_get_contents_type): ..
	* elf32-sh64.c (sh64_find_section_for_address,
	sh64_elf_final_write_processing): ..
	* elf32-sparc.c (sparc_elf_wdisp16_reloc, sparc_elf_hix22_reloc,
	sparc_elf_lox10_reloc, elf32_sparc_adjust_dynamic_symbol,
	allocate_dynrelocs, elf32_sparc_size_dynamic_sections,
	elf32_sparc_relocate_section, elf32_sparc_finish_dynamic_sections): ..
	* elf32-v850.c (v850_elf_reloc, v850_elf_relax_section): ..
	* elf32-vax.c (elf_vax_check_relocs, elf_vax_adjust_dynamic_symbol,
	elf_vax_size_dynamic_sections, elf_vax_discard_copies,
	elf_vax_instantiate_got_entries, elf_vax_relocate_section,
	elf_vax_finish_dynamic_sections): ..
	* elf32-xstormy16.c (xstormy16_elf_24_reloc,
	xstormy16_elf_check_relocs, xstormy16_relax_plt_check,
	xstormy16_elf_relax_section, xstormy16_elf_always_size_sections,
	xstormy16_elf_finish_dynamic_sections): ..
	* elf32-xtensa.c (xtensa_read_table_entries,
	elf_xtensa_allocate_got_size, elf_xtensa_allocate_local_got_size,
	elf_xtensa_size_dynamic_sections, elf_xtensa_do_reloc,
	bfd_elf_xtensa_reloc, elf_xtensa_relocate_section,
	elf_xtensa_combine_prop_entries, elf_xtensa_finish_dynamic_sections,
	elf_xtensa_discard_info_for_section, elf_xtensa_grok_prstatus,
	get_relocation_opcode, retrieve_contents, find_relaxable_sections,
	collect_source_relocs, is_resolvable_asm_expansion, remove_literals,
	relax_section, shrink_dynamic_reloc_sections, relax_property_section,
	xtensa_callback_required_dependence): ..
	* elf64-alpha.c (elf64_alpha_reloc_gpdisp, elf64_alpha_relax_section,
	elf64_alpha_check_relocs, elf64_alpha_adjust_dynamic_symbol,
	elf64_alpha_calc_got_offsets_for_symbol, elf64_alpha_calc_got_offsets,
	elf64_alpha_size_plt_section, elf64_alpha_size_plt_section_1,
	elf64_alpha_always_size_sections, elf64_alpha_calc_dynrel_sizes,
	elf64_alpha_size_rela_got_section, elf64_alpha_size_rela_got_1,
	elf64_alpha_size_dynamic_sections, elf64_alpha_emit_dynrel,
	elf64_alpha_finish_dynamic_sections, elf64_alpha_final_link): ..
	* elf64-hppa.c (allocate_dynrel_entries,
	elf64_hppa_size_dynamic_sections,
	elf64_hppa_finish_dynamic_sections): ..
	* elf64-mips.c (mips_elf64_gprel32_reloc, mips16_gprel_reloc,
	mips_elf64_canonicalize_dynamic_reloc, mips_elf64_slurp_reloc_table,
	elf64_mips_grok_prstatus): ..
	* elf64-mmix.c (mmix_elf_perform_relocation, mmix_elf_reloc,
	mmix_elf_relocate_section, mmix_elf_final_link,
	mmix_set_relaxable_size, _bfd_mmix_after_linker_allocation,
	mmix_elf_relax_section, mmix_elf_get_section_contents): ..
	* elf64-ppc.c (ppc64_elf_object_p, ppc64_elf_grok_prstatus,
	ppc64_elf_check_relocs, ppc64_elf_func_desc_adjust,
	ppc64_elf_adjust_dynamic_symbol, ppc64_elf_edit_opd,
	allocate_dynrelocs, ppc64_elf_size_dynamic_sections,
	ppc_build_one_stub, ppc_size_one_stub, ppc64_elf_next_toc_section,
	toc_adjusting_stub_needed, group_sections, ppc64_elf_size_stubs,
	ppc64_elf_build_stubs, ppc64_elf_relocate_section,
	ppc64_elf_finish_dynamic_sections): ..
	* elf64-s390.c (s390_elf_ldisp_reloc, elf_s390_adjust_dynamic_symbol,
	allocate_dynrelocs, elf_s390_size_dynamic_sections,
	elf_s390_finish_dynamic_sections): ..
	* elf64-sh64.c (sh_elf64_get_relocated_section_contents,
	sh_elf64_check_relocs, sh64_elf64_adjust_dynamic_symbol,
	sh64_elf64_discard_copies, sh64_elf64_size_dynamic_sections,
	sh64_elf64_finish_dynamic_sections): ..
	* elf64-sparc.c (sparc64_elf_slurp_reloc_table, init_insn_reloc,
	sparc64_elf_check_relocs, sparc64_elf_adjust_dynamic_symbol,
	sparc64_elf_size_dynamic_sections, sparc64_elf_relocate_section,
	sparc64_elf_finish_dynamic_symbol,
	sparc64_elf_finish_dynamic_sections): ..
	* elf64-x86-64.c (elf64_x86_64_grok_prstatus,
	elf64_x86_64_adjust_dynamic_symbol, allocate_dynrelocs,
	elf64_x86_64_size_dynamic_sections, elf64_x86_64_relocate_section,
	elf64_x86_64_finish_dynamic_sections): ..
	* elfarm-nabi.c (elf32_arm_nabi_grok_prstatus): ..
	* elfcode.h (elf_slurp_reloc_table): ..
	* elflink.c (_bfd_elf_create_got_section, elf_add_dt_needed_tag,
	elf_finalize_dynstr, elf_link_add_object_symbols,
	bfd_elf_size_dynamic_sections, elf_link_sort_relocs,
	elf_link_input_bfd, bfd_elf_final_link, bfd_elf_discard_info): ..
	* elfn32-mips.c (gprel32_with_gp, mips16_gprel_reloc,
	elf32_mips_grok_prstatus): ..
	* elfxx-ia64.c (elfNN_ia64_relax_section, allocate_dynrel_entries,
	elfNN_ia64_size_dynamic_sections, elfNN_ia64_install_dyn_reloc,
	elfNN_ia64_choose_gp, elfNN_ia64_final_link,
	elfNN_ia64_finish_dynamic_sections): ..
	* elfxx-mips.c (mips_elf_create_procedure_table,
	mips_elf_check_mips16_stubs, _bfd_mips_elf_gprel16_with_gp,
	_bfd_mips_elf_hi16_reloc, _bfd_mips_elf_generic_reloc,
	mips_elf_global_got_index, mips_elf_multi_got,
	mips_elf_create_compact_rel_section, mips_elf_calculate_relocation,
	mips_elf_allocate_dynamic_relocations,
	mips_elf_create_dynamic_relocation, _bfd_mips_elf_fake_sections,
	_bfd_mips_relax_section, _bfd_mips_elf_adjust_dynamic_symbol,
	_bfd_mips_elf_always_size_sections,
	_bfd_mips_elf_size_dynamic_sections,
	_bfd_mips_elf_finish_dynamic_symbol,
	_bfd_mips_elf_finish_dynamic_sections,
	_bfd_mips_elf_modify_segment_map, _bfd_mips_elf_discard_info,
	_bfd_mips_elf_write_section, _bfd_mips_elf_set_section_contents,
	_bfd_elf_mips_get_relocated_section_contents,
	_bfd_mips_elf_final_link, _bfd_mips_elf_merge_private_bfd_data): ..
	* hp300hpux.c (callback): ..
	* hppabsd-core.c (make_bfd_asection): ..
	* hpux-core.c (make_bfd_asection): ..
	* i386linux.c (linux_link_create_dynamic_sections,
	bfd_i386linux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* i386msdos.c (msdos_write_object_contents): ..
	* i386os9k.c (os9k_callback, os9k_write_object_contents,
	os9k_set_section_contents): ..
	* ieee.c (parse_expression, ieee_slurp_external_symbols,
	ieee_slurp_sections, ieee_slurp_debug, ieee_slurp_section_data,
	ieee_write_section_part, do_with_relocs, do_as_repeat,
	do_without_relocs, ieee_write_debug_part, init_for_output,
	ieee_set_section_contents): ..
	* ihex.c (ihex_scan, ihex_read_section, ihex_get_section_contents): ..
	* irix-core.c (do_sections, make_bfd_asection): ..
	* libaout.h (aout_section_merge_with_text_p): ..
	* libbfd.c (_bfd_generic_get_section_contents,
	_bfd_generic_get_section_contents_in_window): ..
	* linker.c (default_indirect_link_order): ..
	* lynx-core.c (make_bfd_asection): ..
	* m68klinux.c (linux_link_create_dynamic_sections,
	bfd_m68klinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* mach-o.c (bfd_mach_o_make_bfd_section,
	bfd_mach_o_scan_read_dylinker, bfd_mach_o_scan_read_dylib,
	bfd_mach_o_scan_read_thread, bfd_mach_o_scan_read_symtab,
	bfd_mach_o_scan_read_segment): ..
	* merge.c (_bfd_add_merge_section, record_section, merge_strings,
	_bfd_merge_sections): ..
	* mmo.c (mmo_find_sec_w_addr, mmo_get_spec_section, mmo_get_loc,
	mmo_map_set_sizes, mmo_canonicalize_symtab,
	mmo_internal_write_section, mmo_write_object_contents): ..
	* netbsd-core.c (netbsd_core_file_p): ..
	* nlm32-alpha.c (nlm_alpha_read_reloc, nlm_alpha_write_import,
	nlm_alpha_set_public_section): ..
	* nlm32-ppc.c (nlm_powerpc_read_reloc, nlm_powerpc_write_reloc): ..
	* nlm32-sparc.c (nlm_sparc_write_import): ..
	* nlmcode.h (add_bfd_section, nlm_swap_auxiliary_headers_in,
	nlm_compute_section_file_positions): ..
	* oasys.c (oasys_object_p, oasys_slurp_section_data,
	oasys_write_sections, oasys_write_data, oasys_set_section_contents): ..
	* opncls.c (get_debug_link_info): ..
	* osf-core.c (make_bfd_asection): ..
	* pdp11.c (some_aout_object_p, adjust_o_magic, adjust_z_magic,
	adjust_n_magic, adjust_sizes_and_vmas, squirt_out_relocs,
	final_link, aout_link_input_section): ..
	* peXXigen.c (_bfd_XXi_swap_sym_in, _bfd_XXi_swap_aouthdr_out,
	pe_print_idata, pe_print_edata, pe_print_pdata, pe_print_reloc): ..
	* pef.c (bfd_pef_make_bfd_section, bfd_pef_print_loader_section,
	bfd_pef_scan_start_address, bfd_pef_parse_symbols): ..
	* ppcboot.c (ppcboot_object_p, ppcboot_canonicalize_symtab): ..
	* ptrace-core.c (ptrace_unix_core_file_p): ..
	* reloc.c (bfd_perform_relocation, bfd_install_relocation,
	_bfd_final_link_relocate, bfd_generic_relax_section,
	bfd_generic_get_relocated_section_contents): ..
	* reloc16.c (bfd_coff_reloc16_relax_section,
	bfd_coff_reloc16_get_relocated_section_c): ..
	* riscix.c (riscix_some_aout_object_p): ..
	* rs6000-core.c (read_hdr, make_bfd_asection): ..
	* sco5-core.c (make_bfd_asection): ..
	* simple.c (bfd_simple_get_relocated_section_contents): ..
	* som.c (som_object_setup, setup_sections, som_prep_headers,
	som_write_fixups, som_begin_writing, bfd_section_from_som_symbol,
	som_set_reloc_info, som_get_section_contents,
	som_bfd_link_split_section): ..
	* sparclinux.c (linux_link_create_dynamic_sections,
	bfd_sparclinux_size_dynamic_sections, linux_finish_dynamic_link): ..
	* srec.c (srec_scan, srec_read_section, srec_get_section_contents): ..
	* stabs.c (_bfd_link_section_stabs, _bfd_discard_section_stabs,
	_bfd_write_stab_strings, _bfd_stab_section_offset): ..
	* sunos.c (sunos_read_dynamic_info, sunos_create_dynamic_sections,
	bfd_sunos_size_dynamic_sections, sunos_scan_std_relocs,
	sunos_scan_ext_relocs, sunos_scan_dynamic_symbol,
	sunos_write_dynamic_symbol, sunos_check_dynamic_reloc,
	sunos_finish_dynamic_link): ..
	* syms.c (_bfd_stab_section_find_nearest_line): ..
	* tekhex.c (first_phase, tekhex_set_section_contents,
	tekhex_write_object_contents): ..
	* trad-core.c (trad_unix_core_file_p): ..
	* versados.c (process_esd, process_otr, process_otr): ..
	* vms-gsd.c (_bfd_vms_slurp_gsd, _bfd_vms_write_gsd): ..
	* vms-misc.c (add_new_contents): ..
	* vms-tir.c (check_section, new_section, _bfd_vms_write_tir): ..
	* vms.c (vms_set_section_contents): ..
	* xcofflink.c (xcoff_get_section_contents, xcoff_link_add_symbols,
	xcoff_sweep, bfd_xcoff_size_dynamic_sections, xcoff_build_ldsyms,
	_bfd_xcoff_bfd_final_link, xcoff_link_input_bfd): ..
	* xsym.c (bfd_sym_scan): .. See above.

binutils/
	* objcopy.c (copy_section): Don't set _cooked_size.

include/
	* bfdlink.h (struct bfd_link_order): Update comment.

ld/
	* ldlang.c (print_output_section_statement): Don't print size before
	relaxation.
	(IGNORE_SECTION): Remove bfd arg.  Update all callers.

	* ldexp.c (fold_name): .. See below.
	* ldlang.c (section_already_linked, print_output_section_statement,
	print_input_section, insert_pad, size_input_section,
	lang_check_section_addresses, lang_size_sections_1,
	lang_size_sections, lang_do_assignments_1, lang_set_startof,
	lang_one_common, lang_reset_memory_regions, lang_process,
	lang_abs_symbol_at_end_of, lang_do_version_exports_section): ..
	* ldwrite.c (build_link_order, clone_section, ds, split_sections): ..
	* pe-dll.c (process_def_file, generate_reloc): ..
	* emultempl/elf32.em (gld${EMULATION_NAME}_find_statement_assignment,
	gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/mmix-elfnmmo.em (mmix_after_allocation): ..
	* emultempl/sh64elf.em (sh64_elf_${EMULATION_NAME}_before_allocation,
	sh64_elf_${EMULATION_NAME}_after_allocation): ..
	* emultempl/sunos.em (gld${EMULATION_NAME}_before_allocation): ..
	* emultempl/xtensaelf.em (ld_assign_relative_paged_dot,
	ld_local_file_relocations_fit, ld_xtensa_insert_page_offsets): Use
	"size" instead of "_raw_size" and "_cooked_size".  Expand
	bfd_section_size macro invocations.
@
text
@d894 1
a894 1
      else if (bfd_get_section (sym)->comdat)
@


1.69
log
@	* objcopy.c (copy_section): Use bfd_get_section_size instead of
	_raw_size or bfd_get_section_size_before_reloc.  Don't set reloc_done.
	(compare_section_lma): Likewise.
	* addr2line.c (find_address_in_section): Likewise.
	* coffgrok.c (do_sections_p1): Likewise.
	* dlltool.c (scan_drectve_symbols): Likewise.
	* nlmconv.c (main): Likewise.
	(copy_sections): Likewise.
	(powerpc_mangle_relocs): Likewise.
	* objdump.c (disassemble_section): Likewise.
	* prdbg.c (find_address_in_section): Likewise.
	* size.c (berkeley_sum): Likewise.
	* srconv.c (wr_ob): Likewise.
	* strings.c (strings_a_section): Likewise.
@
text
@a2072 2
  isection->_cooked_size = isection->_raw_size;

@


1.68
log
@binutils ChangeLog:
	2004-05-17  David Heine  <dlheine@@tensilica.com>
	* objcopy.c (setup_bfd_headers): New function.
	(copy_object): Call setup_bfd_headers.
bfd ChangeLog:
	2004-05-17  David Heine  <dlheine@@tensilica.com>
	* aout-target.h (MY_bfd_copy_private_header_data): Define.
	* aout-tic30.c (MY_bfd_copy_private_header_data): Define.
	* bfd.c (bfd_copy_private_header_data): Define.
	* coff-rs6000.c (rs6000coff_vec, pmac_xcoff_vec): Add entries for new
	interface.
	* coff64-rs6000.c (rs6000coff64_vec, aix5coff64_vec): Likewise.
	* coffcode.h (coff_bfd_copy_private_header_data): Define.
	* elf-bfd.h (_bfd_elf_copy_private_header_data): Declare.
	* elf.c (_bfd_elf_copy_private_section_data): Remove code to set up
	segments by calling copy_private_bfd_data.
	(_bfd_elf_copy_private_header_data): Define.
	* elfxx-target.h (bfd_elfNN_bfd_copy_private_header_data): Define.
	* libbfd-in.h (_bfd_generic_bfd_copy_private_header_data): Define.
	* libecoff.h (_bfd_ecoff_bfd_copy_private_header_data): Define.
	* mach-o.c (bfd_mach_o_bfd_copy_private_header_data): Define.
	* mmo.c (mmo_bfd_copy_private_header_data): Define.
	* ppcboot.c (ppcboot_bfd_copy_private_header_data): Define.
	* som.c (som_bfd_copy_private_header_data): Define.
	* targets.c (BFD_JUMP_TABLE_COPY): Add _bfd_copy_private_header_data.
	* vms.c (vms_bfd_copy_private_header_data): Define.
	* bfd-in2.h: Regenerate.
	* libbfd.h: Regenerate.
@
text
@d2017 1
a2017 1
  size = bfd_get_section_size_before_reloc (isection);
a2073 1
  isection->reloc_done = TRUE;
d2166 1
a2166 1
  if ((*sec1)->_raw_size > (*sec2)->_raw_size)
d2168 1
a2168 1
  else if ((*sec1)->_raw_size < (*sec2)->_raw_size)
@


1.67
log
@	* objcopy.c (copy_usage, strip_usage): Fix spelling.
@
text
@d380 1
d1182 2
d1812 26
@


1.66
log
@gas/
	* stabs.c (generate_asm_file): Avoid warning about use of
	uninitialized variable.
binutils/
	* objcopy.c (copy_section): Avoid warnings.
@
text
@d413 1
a413 1
  -w --wildcard                    Permit wildcard in symbol comparasion\n\
d488 1
a488 1
  -w --wildcard                    Permit wildcard in symbol comparasion\n\
@


1.65
log
@	* objcopy.c: Include elf-bfd.h.
	(is_strip_section): Don't strip debugging sections if
	STRIP_NONDEBUG.
	(setup_section): If STRIP_NONDEBUG make SEC_ALLOC sections
	~(SEC_LOAD | SEC_HAS_CONTENTS) and on ELF targets also SHT_NOBITS.

	* objcopy.c (copy_section): Free relpp if relcount == 0.
@
text
@d2058 1
a2058 1
	  char *from = memhunk + copy_byte;
d2060 1
a2060 1
	  char *end = memhunk + size;
@


1.65.6.1
log
@Merge to 2.15 branch.
@
text
@d2058 1
a2058 1
	  char *from = (char *) memhunk + copy_byte;
d2060 1
a2060 1
	  char *end = (char *) memhunk + size;
@


1.64
log
@Fix typo in comment in previous delta
@
text
@d31 1
d780 1
a780 1
  return strip_symbols == STRIP_NONDEBUG ? TRUE : FALSE;
d1913 7
d2040 2
@


1.63
log
@Do not produce any output if the output file will be empty
@
text
@d1088 1
a1088 1
   Trues TRUE upon success, FALSE otherwise.  */
@


1.62
log
@	* objcopy.c (filter_bytes): Delete.  Move code to..
	(copy_section): ..here.  Simplify size adjustment.  Divide
	section lma by interleave.
@
text
@d1087 2
a1088 1
/* Copy object file IBFD onto OBFD.  */
d1090 1
a1090 1
static void
d1107 3
d1111 2
a1112 2
      fatal (_("Unable to change endianness of input file(s)"));
      return;
a1114 3
  if (!bfd_set_format (obfd, bfd_get_format (ibfd)))
    RETURN_NONFATAL (bfd_get_filename (obfd));

d1139 4
a1142 1
	RETURN_NONFATAL (bfd_get_filename (ibfd));
d1160 1
a1160 2
	  status = 1;
	  return;
d1165 4
a1168 1
    RETURN_NONFATAL (bfd_get_filename (ibfd));
d1194 1
a1194 2
	      status = 1;
	      return;
d1198 4
a1201 1
	    RETURN_NONFATAL (bfd_get_filename (obfd));
d1213 4
a1216 1
	    RETURN_NONFATAL (bfd_get_filename (obfd));
d1223 4
a1226 1
		  RETURN_NONFATAL (bfd_get_filename (obfd));
d1231 1
a1231 1
		  
d1235 4
a1238 1
		    RETURN_NONFATAL (bfd_get_filename (obfd));
d1250 10
a1259 1
	RETURN_NONFATAL (gnu_debuglink_filename);
d1349 4
a1352 1
    RETURN_NONFATAL (bfd_get_filename (ibfd));
d1357 4
a1360 1
    RETURN_NONFATAL (bfd_get_filename (ibfd));
d1405 1
a1405 1
	  return;
d1422 4
a1425 1
	    RETURN_NONFATAL (bfd_get_filename (obfd));
d1433 4
a1436 1
	RETURN_NONFATAL (gnu_debuglink_filename);
d1472 4
a1475 1
		    RETURN_NONFATAL (bfd_get_filename (obfd));
d1498 1
a1498 2
      status = 1;
      return;
d1504 5
a1508 5
  if (use_alt_mach_code != 0)
    {
      if (!bfd_alt_mach_code (obfd, use_alt_mach_code))
	non_fatal (_("unknown alternate machine code, ignored"));
    }
d1555 1
d1597 1
a1597 1
	copy_object (this_element, output_bfd);
d1606 9
a1614 2
      if (preserve_dates && stat_status == 0)
	set_times (output_name, &buf);
d1616 2
a1617 2
      /* Open the newly output file and attach to our list.  */
      output_bfd = bfd_openr (output_name, output_target);
d1619 1
a1619 1
      l->obfd = output_bfd;
d1621 2
a1622 2
      *ptr = output_bfd;
      ptr = &output_bfd->next;
d1624 1
a1624 1
      last_element = this_element;
d1626 1
a1626 1
      this_element = bfd_openr_next_archived_file (ibfd, last_element);
d1628 2
a1629 1
      bfd_close (last_element);
d1693 1
d1695 1
d1705 1
a1705 1
      copy_object (ibfd, obfd);
d1712 6
@


1.61
log
@* objcopy.c (bfd_flags_to_set, bfd_flags_to_clear): New variables
to handle flags for tweaking.
(copy_options): New options: impure, pure, readonly-text,
writable-text.
(copy_usage, copy_object, command_line_switch): Handle the new
options.
* doc/binutils.texi: Document the new options.
@
text
@d3 1
a3 1
   2001, 2002, 2003
a1086 17
/* Keep only every `copy_byte'th byte in MEMHUNK, which is *SIZE bytes long.
   Adjust *SIZE.  */

static void
filter_bytes (char *memhunk, bfd_size_type *size)
{
  char *from = memhunk + copy_byte, *to = memhunk, *end = memhunk + *size;

  for (; from < end; from += interleave)
    *to++ = *from;

  if (*size % interleave > (bfd_size_type) copy_byte)
    *size = (*size / interleave) + 1;
  else
    *size /= interleave;
}

d1989 12
a2000 1
	filter_bytes (memhunk, &size);
@


1.60
log
@Add --only-keep-debug to the --help output.
@
text
@d151 4
d244 5
a248 1
    OPTION_ONLY_KEEP_DEBUG
d306 1
d328 2
d351 1
d449 4
d1146 7
d1154 1
a1154 3
	  || !bfd_set_file_flags (obfd,
				  (bfd_get_file_flags (ibfd)
				   & bfd_applicable_file_flags (obfd))))
d2806 20
@


1.59
log
@	* ChangeLog-9197: Fix comment typos.
	* coffgrok.c: Likewise.
	* filemode.c: Likewise.
	* objcopy.c: Likewise.
	* objdump.c: Likewise.
	* prdbg.c: Likewise.
	* stabs.c: Likewise.
	* unwind-ia64.c: Likewise.
@
text
@d394 1
d468 1
@


1.58
log
@Do not copy the object if the output file's format cannot be set to that of
the input file.	 If the input file's format is unknown, fail.
@
text
@d184 1
a184 1
/* Whether to permit wildcard in symbol comparasion.  */
@


1.57
log
@Add new feature to objcopy/strip.  The -w switch allows wildcards to be used
in symbol names.
@
text
@d1141 13
a1153 3
    non_fatal (_("Warning: Output file cannot represent architecture %s"),
	       bfd_printable_arch_mach (bfd_get_arch (ibfd),
					bfd_get_mach (ibfd)));
@


1.56
log
@Use consistent error messages for missing files.
Detect directories where an ordinary file is expected.
@
text
@d30 1
d184 3
d268 1
d339 1
d399 1
d469 1
d707 20
a726 3
  for (tmp_list = list; tmp_list; tmp_list = tmp_list->next)
    if (strcmp (name, tmp_list->name) == 0)
      return TRUE;
d2179 1
a2179 1
  while ((c = getopt_long (argc, argv, "I:O:F:K:N:R:o:sSpdgxXHhVv",
d2242 3
d2329 1
a2329 1
  while ((c = getopt_long (argc, argv, "b:B:i:I:j:K:N:s:O:d:F:L:G:R:SpgxXHhVvW:",
d2422 4
@


1.55
log
@Do not complain when copying a file format that does not support relocations.
@
text
@d586 1
a586 1
  struct stat st;
d592 2
a593 3
  if (stat (filename, & st) < 0)
    fatal (_("cannot stat: %s: %s"), filename, strerror (errno));
  if (st.st_size == 0)
d596 1
a596 1
  buffer = xmalloc (st.st_size + 2);
d599 1
a599 1
    fatal (_("cannot open: %s: %s"), filename, strerror (errno));
d601 1
a601 1
  if (fread (buffer, 1, st.st_size, f) == 0 || ferror (f))
d605 2
a606 2
  buffer [st.st_size] = '\n';
  buffer [st.st_size + 1] = '\0';
d1573 6
d2254 3
d2258 3
a2260 7
	{
	  if (stat (argv[i], &statbuf) < 0)
	    {
	      non_fatal (_("%s: cannot stat: %s"), argv[i], strerror (errno));
	      continue;
	    }
	}
d2423 1
a2423 1
	    struct stat st;
d2434 3
a2436 2
	    if (stat (s + 1, & st) < 0)
	      fatal (_("cannot stat: %s: %s"), s + 1, strerror (errno));
d2447 2
a2449 3
	    pa->size = st.st_size;

	    pa->contents = xmalloc (pa->size);
d2807 2
a2808 1
      fatal (_("Cannot stat: %s: %s"), input_filename, strerror (errno));
@


1.54
log
@Set the machine number as well as the architecture when converting from a
binary file to another file type.
@
text
@d1888 2
a1889 1
    relsize = bfd_get_reloc_upper_bound (ibfd, isection);
d1891 9
a1899 2
  if (relsize < 0)
    RETURN_NONFATAL (bfd_get_filename (ibfd));
d2041 6
a2046 1
    bfd_fatal (bfd_get_filename (ibfd));
@


1.53
log
@	* objcopy.c: Remove unnecessary prototypes and casts.
	* objdump.c: Remove unnecessary casts.
	* readelf.c: Convert to C90.  Remove unnecessary prototypes and casts.
	(get_osabi_name): Move so we don't need a forward declaration.
@
text
@d354 4
a357 2
/* Defined in bfd/binary.c.  Used to set architecture of input binary files.  */
extern enum bfd_architecture bfd_external_binary_architecture;
d2774 4
a2777 1
	    bfd_external_binary_architecture = temp_arch_info->arch;
@


1.52
log
@Tidy up code.  Switch to ISO C
@
text
@a62 53
static void copy_usage
  (FILE *, int);
static void strip_usage
  (FILE *, int);
static flagword parse_flags
  (const char *);
static struct section_list *find_section_list
  (const char *, bfd_boolean);
static void setup_section
  (bfd *, asection *, void *);
static void copy_section
  (bfd *, asection *, void *);
static void get_sections
  (bfd *, asection *, void *);
static int compare_section_lma
  (const void *, const void *);
static void add_specific_symbol
  (const char *, struct symlist **);
static void add_specific_symbols
  (const char *, struct symlist **);
static bfd_boolean is_specified_symbol
  (const char *, struct symlist *);
static bfd_boolean is_strip_section
  (bfd *, asection *);
static unsigned int filter_symbols
  (bfd *, bfd *, asymbol **, asymbol **, long);
static void mark_symbols_used_in_relocations
  (bfd *, asection *, void *);
static void filter_bytes
  (char *, bfd_size_type *);
static bfd_boolean write_debugging_info
  (bfd *, void *, long *, asymbol ***);
static void copy_object
  (bfd *, bfd *);
static void copy_archive
  (bfd *, bfd *, const char *);
static void copy_file
  (const char *, const char *, const char *, const char *);
static int strip_main
  (int, char **);
static int copy_main
  (int, char **);
static const char *lookup_sym_redefinition
  (const char *);
static void redefine_list_append
  (const char *, const char *, const char *);
static const char * find_section_rename
  (bfd *, sec_ptr, flagword *);
static void add_section_rename
  (const char *, const char *, flagword);
static void add_redefine_syms_file 
  (const char *);

d357 8
d545 1
a545 1
  p = (struct section_list *) xmalloc (sizeof (struct section_list));
d570 1
a570 1
  tmp_list = (struct symlist *) xmalloc (sizeof (struct symlist));
d595 1
a595 1
  buffer = (char *) xmalloc (st.st_size + 2);
d923 1
a923 1
  new_node = (struct redefine_node *) xmalloc (sizeof (struct redefine_node));
d946 1
a946 1
  if (file == (FILE *) NULL)
d951 1
a951 1
  buf = (char *) xmalloc (bufsize);
d1130 1
a1130 1
  bfd_map_over_sections (ibfd, setup_section, (void *) obfd);
d1206 1
a1206 1
      osections = (asection **) xmalloc (c * sizeof (asection *));
d1208 1
a1208 1
      bfd_map_over_sections (obfd, get_sections, (void *) &set);
d1212 1
a1212 1
      gaps = (bfd_size_type *) xmalloc (c * sizeof (bfd_size_type));
d1283 1
a1283 1
  osympp = isympp = (asymbol **) xmalloc (symsize);
d1321 2
a1322 2
			       (void *) isympp);
      osympp = (asymbol **) xmalloc ((symcount + 1) * sizeof (asymbol *));
d1338 1
a1338 1
  bfd_map_over_sections (ibfd, copy_section, (void *) obfd);
d1346 2
a1347 4
	  if (! bfd_set_section_contents (obfd, padd->section,
					  (void *) padd->contents,
					  (file_ptr) 0,
					  (bfd_size_type) padd->size))
d1367 2
a1368 2
      buf = (bfd_byte *) xmalloc (max_gap);
      memset (buf, gap_fill, (size_t) max_gap);
d1466 1
a1466 1
  while (!status && this_element != (bfd *) NULL)
d1486 1
a1486 1
	  l = (struct name_list *) xmalloc (sizeof (struct name_list));
d1505 1
a1505 1
      l = (struct name_list *) xmalloc (sizeof (struct name_list));
d1510 1
a1510 1
      if (output_bfd == (bfd *) NULL)
d1540 1
a1540 1
  *ptr = (bfd *) NULL;
d1669 1
a1669 1
  rename = (section_rename *) xmalloc (sizeof (* rename));
d1711 1
a1711 1
  bfd *obfd = (bfd *) obfdarg;
d1853 1
a1853 1
  bfd *obfd = (bfd *) obfdarg;
d1892 1
a1892 1
    bfd_set_reloc (obfd, osection, (arelent **) NULL, 0);
d1895 1
a1895 1
      relpp = (arelent **) xmalloc (relsize);
d1908 1
a1908 1
	  temp_relpp = (arelent **) xmalloc (relsize);
d1910 2
a1911 3
	    if (is_specified_symbol
		(bfd_asymbol_name (*relpp [i]->sym_ptr_ptr),
		 keep_specific_list))
d1918 1
a1918 2
      bfd_set_reloc (obfd, osection,
		     (relcount == 0 ? (arelent **) NULL : relpp), relcount);
d1927 1
a1927 1
      void *memhunk = (void *) xmalloc ((unsigned) size);
d1929 1
a1929 2
      if (!bfd_get_section_contents (ibfd, isection, memhunk, (file_ptr) 0,
				     size))
d1935 1
a1935 2
      if (!bfd_set_section_contents (obfd, osection, memhunk, (file_ptr) 0,
				     size))
d1942 1
a1942 1
      void * memhunk = (void *) xmalloc ((unsigned) size);
d1951 1
a1951 2
      if (! bfd_set_section_contents (obfd, osection, memhunk, (file_ptr) 0,
				      size))
d1963 1
a1963 1
  asection ***secppp = (asection ***) secppparg;
d1976 2
a1977 2
  const asection **sec1 = (const asection **) arg1;
  const asection **sec2 = (const asection **) arg2;
d2020 1
a2020 1
  asymbol **symbols = (asymbol **) symbolsarg;
d2036 1
a2036 1
  relpp = (arelent **) xmalloc (relsize);
d2104 3
a2106 4
      if (! bfd_set_section_contents (obfd, stabsec, syms, (file_ptr) 0,
				      symsize)
	  || ! bfd_set_section_contents (obfd, stabstrsec, strings,
					 (file_ptr) 0, stringsize))
d2220 1
a2220 1
  if (output_target == (char *) NULL)
d2418 1
a2418 1
	    pa = (struct section_add *) xmalloc (sizeof (struct section_add));
d2421 1
a2421 1
	    name = (char *) xmalloc (len + 1);
d2430 1
a2430 1
	    pa->contents = (bfd_byte *) xmalloc (pa->size);
d2489 1
a2489 1
	    name = (char *) xmalloc (len + 1);
d2587 1
a2587 1
	    source = (char *) xmalloc (len + 1);
d2593 1
a2593 1
	    target = (char *) xmalloc (len + 1);
d2618 1
a2618 1
	    name = (char *) xmalloc (len + 1);
d2645 1
a2645 1
	    old_name = (char *) xmalloc (len + 1);
d2665 1
a2665 1
	    new_name = (char *) xmalloc (len + 1);
d2760 1
a2760 1
  if (output_target == (char *) NULL)
d2763 1
a2763 1
  if (binary_architecture != (char *) NULL)
d2788 2
a2789 3
     are the same,  then create a temp and rename the result into the input.  */
  if ((output_filename == (char *) NULL) ||
      (strcmp (input_filename, output_filename) == 0))
@


1.51
log
@Fix --add-gnu-debuglink
@
text
@d61 1
a61 1
static section_rename * section_rename_list;
d64 1
a64 1
  PARAMS ((FILE *, int));
d66 1
a66 1
  PARAMS ((FILE *, int));
d68 1
a68 1
  PARAMS ((const char *));
d70 1
a70 1
  PARAMS ((const char *, bfd_boolean));
d72 1
a72 1
  PARAMS ((bfd *, asection *, PTR));
d74 1
a74 1
  PARAMS ((bfd *, asection *, PTR));
d76 1
a76 1
  PARAMS ((bfd *, asection *, PTR));
d78 1
a78 1
  PARAMS ((const PTR, const PTR));
d80 1
a80 1
  PARAMS ((const char *, struct symlist **));
d82 1
a82 1
  PARAMS ((const char *, struct symlist **));
d84 1
a84 1
  PARAMS ((const char *, struct symlist *));
d86 1
a86 1
  PARAMS ((bfd *, asection *));
d88 1
a88 1
  PARAMS ((bfd *, bfd *, asymbol **, asymbol **, long));
d90 1
a90 1
  PARAMS ((bfd *, asection *, PTR));
d92 1
a92 1
  PARAMS ((char *, bfd_size_type *));
d94 1
a94 1
  PARAMS ((bfd *, PTR, long *, asymbol ***));
d96 1
a96 1
  PARAMS ((bfd *, bfd *));
d98 1
a98 1
  PARAMS ((bfd *, bfd *, const char *));
d100 1
a100 1
  PARAMS ((const char *, const char *, const char *, const char *));
d102 1
a102 1
  PARAMS ((int, char **));
d104 1
a104 1
  PARAMS ((int, char **));
d106 1
a106 1
  PARAMS((const char *));
d108 1
a108 1
  PARAMS ((const char *, const char *, const char *));
d110 1
a110 1
  PARAMS ((bfd *, sec_ptr, flagword *));
d112 1
a112 1
  PARAMS ((const char *, const char *, flagword));
d114 1
a114 1
  PARAMS ((const char *));
d118 2
a119 2
static asymbol **isympp = NULL;	/* Input symbols */
static asymbol **osympp = NULL;	/* Output symbols that survive stripping */
d132 3
a134 3
    STRIP_NONE,			/* don't strip */
    STRIP_DEBUG,		/* strip all debugger symbols */
    STRIP_UNNEEDED,		/* strip unnecessary symbols */
d136 1
a136 1
    STRIP_ALL			/* strip all symbols */
d145 2
a146 2
    LOCALS_START_L,		/* discard locals starting with L */
    LOCALS_ALL			/* discard all locals */
d254 37
a290 35

#define OPTION_ADD_SECTION 150
#define OPTION_CHANGE_ADDRESSES (OPTION_ADD_SECTION + 1)
#define OPTION_CHANGE_LEADING_CHAR (OPTION_CHANGE_ADDRESSES + 1)
#define OPTION_CHANGE_START (OPTION_CHANGE_LEADING_CHAR + 1)
#define OPTION_CHANGE_SECTION_ADDRESS (OPTION_CHANGE_START + 1)
#define OPTION_CHANGE_SECTION_LMA (OPTION_CHANGE_SECTION_ADDRESS + 1)
#define OPTION_CHANGE_SECTION_VMA (OPTION_CHANGE_SECTION_LMA + 1)
#define OPTION_CHANGE_WARNINGS (OPTION_CHANGE_SECTION_VMA + 1)
#define OPTION_DEBUGGING (OPTION_CHANGE_WARNINGS + 1)
#define OPTION_GAP_FILL (OPTION_DEBUGGING + 1)
#define OPTION_NO_CHANGE_WARNINGS (OPTION_GAP_FILL + 1)
#define OPTION_PAD_TO (OPTION_NO_CHANGE_WARNINGS + 1)
#define OPTION_REMOVE_LEADING_CHAR (OPTION_PAD_TO + 1)
#define OPTION_SET_SECTION_FLAGS (OPTION_REMOVE_LEADING_CHAR + 1)
#define OPTION_SET_START (OPTION_SET_SECTION_FLAGS + 1)
#define OPTION_STRIP_UNNEEDED (OPTION_SET_START + 1)
#define OPTION_WEAKEN (OPTION_STRIP_UNNEEDED + 1)
#define OPTION_REDEFINE_SYM (OPTION_WEAKEN + 1)
#define OPTION_REDEFINE_SYMS (OPTION_REDEFINE_SYM + 1)
#define OPTION_SREC_LEN (OPTION_REDEFINE_SYMS + 1)
#define OPTION_SREC_FORCES3 (OPTION_SREC_LEN + 1)
#define OPTION_STRIP_SYMBOLS (OPTION_SREC_FORCES3 + 1)
#define OPTION_KEEP_SYMBOLS (OPTION_STRIP_SYMBOLS + 1)
#define OPTION_LOCALIZE_SYMBOLS (OPTION_KEEP_SYMBOLS + 1)
#define OPTION_KEEPGLOBAL_SYMBOLS (OPTION_LOCALIZE_SYMBOLS + 1)
#define OPTION_WEAKEN_SYMBOLS (OPTION_KEEPGLOBAL_SYMBOLS + 1)
#define OPTION_RENAME_SECTION (OPTION_WEAKEN_SYMBOLS + 1)
#define OPTION_ALT_MACH_CODE (OPTION_RENAME_SECTION + 1)
#define OPTION_PREFIX_SYMBOLS (OPTION_ALT_MACH_CODE + 1)
#define OPTION_PREFIX_SECTIONS (OPTION_PREFIX_SYMBOLS + 1)
#define OPTION_PREFIX_ALLOC_SECTIONS (OPTION_PREFIX_SECTIONS + 1)
#define OPTION_FORMATS_INFO (OPTION_PREFIX_ALLOC_SECTIONS + 1)
#define OPTION_ADD_GNU_DEBUGLINK (OPTION_FORMATS_INFO + 1)
#define OPTION_ONLY_KEEP_DEBUG (OPTION_ADD_GNU_DEBUGLINK + 1)
d412 1
a412 3
copy_usage (stream, exit_status)
     FILE *stream;
     int exit_status;
d489 1
a489 3
strip_usage (stream, exit_status)
     FILE *stream;
     int exit_status;
d524 1
a524 2
parse_flags (s)
     const char *s;
d579 1
a579 3
find_section_list (name, add)
     const char *name;
     bfd_boolean add;
d581 1
a581 1
  register struct section_list *p;
d611 1
a611 3
add_specific_symbol (name, list)
     const char *name;
     struct symlist **list;
d627 1
a627 3
add_specific_symbols (filename, list)
     const char *filename;
     struct symlist **list;
d739 1
a739 3
is_specified_symbol (name, list)
     const char *name;
     struct symlist *list;
d753 1
a753 3
is_strip_section (abfd, sec)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *sec;
d788 2
a789 5
filter_symbols (abfd, obfd, osyms, isyms, symcount)
     bfd *abfd;
     bfd *obfd;
     asymbol **osyms, **isyms;
     long symcount;
d791 1
a791 1
  register asymbol **from = isyms, **to = osyms;
d852 2
a853 1
          ptr = n = xmalloc (1 + strlen (prefix_symbols_string) + strlen (name) + 1);
d937 1
a937 2
lookup_sym_redefinition (source)
     const char *source;
d951 1
a951 4
redefine_list_append (cause, source, target)
     const char *cause;
     const char *source;
     const char *target;
d981 1
a981 2
add_redefine_syms_file (filename)
     const char *filename;
d985 3
a987 1
  size_t bufsize, len, outsym_off;
d1092 1
a1092 3
filter_bytes (memhunk, size)
     char *memhunk;
     bfd_size_type *size;
d1108 1
a1108 3
copy_object (ibfd, obfd)
     bfd *ibfd;
     bfd *obfd;
d1113 1
a1113 1
  asection * gnu_debuglink_section = NULL;
d1117 1
a1117 1
  PTR dhandle;
d1213 2
a1214 1
		if (! bfd_set_section_vma (obfd, padd->section, pset->vma_val))
d1232 2
a1233 1
      gnu_debuglink_section = bfd_create_gnu_debuglink_section (obfd, gnu_debuglink_filename);
a1235 2
	{
	  fprintf (stderr, "UGG\n");
a1236 1
	}
d1366 1
a1366 1
			       (PTR)isympp);
d1392 1
a1392 1
					  (PTR) padd->contents,
d1403 1
a1403 4
	{
	  fprintf (stderr, "UGG 2\n");
	  RETURN_NONFATAL (gnu_debuglink_filename);
	}
d1487 1
a1487 4
copy_archive (ibfd, obfd, output_target)
     bfd *ibfd;
     bfd *obfd;
     const char *output_target;
d1501 3
a1503 4
    {
      fatal (_("cannot mkdir %s for archive copying (error: %s)"),
	     dir, strerror (errno));
    }
d1530 3
a1532 4
	    {
	      fatal (_("cannot mkdir %s for archive copying (error: %s)"),
		     output_name, strerror (errno));
	    }
d1612 2
a1613 5
copy_file (input_filename, output_filename, input_target, output_target)
     const char *input_filename;
     const char *output_filename;
     const char *input_target;
     const char *output_target;
d1699 2
a1700 4
add_section_rename (old_name, new_name, flags)
     const char * old_name;
     const char * new_name;
     flagword flags;
d1731 2
a1732 4
find_section_rename (ibfd, isection, returned_flags)
     bfd * ibfd ATTRIBUTE_UNUSED;
     sec_ptr isection;
     flagword * returned_flags;
d1756 1
a1756 4
setup_section (ibfd, isection, obfdarg)
     bfd *ibfd;
     sec_ptr isection;
     PTR obfdarg;
d1780 2
a1781 1
  if ((prefix_alloc_sections_string) && (bfd_get_section_flags (ibfd, isection) & SEC_ALLOC))
d1898 1
a1898 4
copy_section (ibfd, isection, obfdarg)
     bfd *ibfd;
     sec_ptr isection;
     PTR obfdarg;
d1976 1
a1976 1
      PTR memhunk = (PTR) xmalloc ((unsigned) size);
d1993 1
a1993 1
      PTR memhunk = (PTR) xmalloc ((unsigned) size);
d2013 1
a2013 4
get_sections (obfd, osection, secppparg)
     bfd *obfd ATTRIBUTE_UNUSED;
     asection *osection;
     PTR secppparg;
d2026 1
a2026 3
compare_section_lma (arg1, arg2)
     const PTR arg1;
     const PTR arg2;
d2070 1
a2070 4
mark_symbols_used_in_relocations (ibfd, isection, symbolsarg)
     bfd *ibfd;
     sec_ptr isection;
     PTR symbolsarg;
d2110 3
a2112 5
write_debugging_info (obfd, dhandle, symcountp, symppp)
     bfd *obfd;
     PTR dhandle;
     long *symcountp ATTRIBUTE_UNUSED;
     asymbol ***symppp ATTRIBUTE_UNUSED;
d2176 1
a2176 3
strip_main (argc, argv)
     int argc;
     char *argv[];
d2258 5
a2262 5
 if (formats_info)
   {
     display_info ();
     return 0;
   }
d2321 1
a2321 3
copy_main (argc, argv)
     int argc;
     char *argv[];
d2487 2
a2488 1
	      fatal (_("cannot open: %s: %s"), pa->filename, strerror (errno));
a2904 2
int main PARAMS ((int, char **));

d2906 1
a2906 3
main (argc, argv)
     int argc;
     char *argv[];
@


1.50
log
@Add --only-keep-debug switch
@
text
@d1135 1
d1253 5
a1257 1
      if (! bfd_add_gnu_debuglink (obfd, gnu_debuglink_filename))
d1259 1
d1419 10
@


1.49
log
@Add new switch to objcopy: --add-gnu-debuglink=<file>
Allows packages to be shipped in two forms, a stripped executable and debug
info file.
@
text
@d135 1
d288 1
d302 1
d356 1
d788 3
d793 1
a793 1
  return FALSE;
d1356 1
d1462 6
a1467 1
  if (! bfd_copy_private_bfd_data (ibfd, obfd))
d1895 6
a1900 1
  if (!bfd_copy_private_section_data (ibfd, isection, obfd, osection))
d2283 3
d2437 4
@


1.48
log
@* objcopy.c (redefine_list_append): Add an argument that
indicates the context from which this function is being
called.  Change all callers.
(copy_options): Add a new option, --redefine-syms.
(copy_usage): Document new option.
(copy_main): Handle the --redefine-syms option.
* doc/binutils.text (objcopy): Document new option.
@
text
@d113 2
d222 4
d286 1
d319 1
d421 1
d424 1
a424 1
  -g --strip-debug                 Remove all debugging symbols\n\
d499 1
a499 1
  -g -S -d --strip-debug           Remove all debugging symbols\n\
d764 11
a774 1
  struct section_list *p;
d776 3
a778 2
  if ((bfd_get_section_flags (abfd, sec) & SEC_DEBUGGING) != 0
      && (strip_symbols == STRIP_DEBUG
d782 3
a784 5
	  || convert_debugging))
    return TRUE;

  if (! sections_removed && ! sections_copied)
    return FALSE;
a785 5
  p = find_section_list (bfd_get_section_name (abfd, sec), FALSE);
  if (sections_removed && p != NULL && p->remove)
    return TRUE;
  if (sections_copied && (p == NULL || ! p->copy))
    return TRUE;
d992 1
a992 1
void
d1198 2
a1207 3
	  else
	    {
	      flagword flags;
d1209 6
a1214 2
	      if (! bfd_set_section_size (obfd, padd->section, padd->size))
		RETURN_NONFATAL (bfd_get_filename (obfd));
d1216 4
a1219 3
	      pset = find_section_list (padd->name, FALSE);
	      if (pset != NULL)
		pset->used = TRUE;
d1221 2
a1222 4
	      if (pset != NULL && pset->set_flags)
		flags = pset->flags | SEC_HAS_CONTENTS;
	      else
		flags = SEC_HAS_CONTENTS | SEC_READONLY | SEC_DATA;
d1224 5
a1228 2
	      if (! bfd_set_section_flags (obfd, padd->section, flags))
		RETURN_NONFATAL (bfd_get_filename (obfd));
d1230 1
a1230 1
	      if (pset != NULL)
d1232 6
a1237 13
		  if (pset->change_vma != CHANGE_IGNORE)
		    if (! bfd_set_section_vma (obfd, padd->section, pset->vma_val))
		      RETURN_NONFATAL (bfd_get_filename (obfd));

		  if (pset->change_lma != CHANGE_IGNORE)
		    {
		      padd->section->lma = pset->lma_val;

		      if (! bfd_set_section_alignment
			  (obfd, padd->section,
			   bfd_section_alignment (obfd, padd->section)))
			RETURN_NONFATAL (bfd_get_filename (obfd));
		    }
d1243 6
d1781 1
a1781 6
  if ((bfd_get_section_flags (ibfd, isection) & SEC_DEBUGGING) != 0
      && (strip_symbols == STRIP_DEBUG
	  || strip_symbols == STRIP_UNNEEDED
	  || strip_symbols == STRIP_ALL
	  || discard_locals == LOCALS_ALL
	  || convert_debugging))
a1787 5
  if (sections_removed && p != NULL && p->remove)
    return;
  if (sections_copied && (p == NULL || ! p->copy))
    return;

d1923 1
a1923 7
  flags = bfd_get_section_flags (ibfd, isection);
  if ((flags & SEC_DEBUGGING) != 0
      && (strip_symbols == STRIP_DEBUG
	  || strip_symbols == STRIP_UNNEEDED
	  || strip_symbols == STRIP_ALL
	  || discard_locals == LOCALS_ALL
	  || convert_debugging))
d1926 1
a1929 7
  p = find_section_list (bfd_section_name (ibfd, isection), FALSE);

  if (sections_removed && p != NULL && p->remove)
    return;
  if (sections_copied && (p == NULL || ! p->copy))
    return;

d1936 2
d2418 4
d2793 2
a2794 1
	  break;		/* we've been given a long option */
@


1.47
log
@Treat identical src/dst file names as if only one entered.  One Windows
creating an output file of the same name as the input file will delete
the input file before it is read.
@
text
@d108 1
a108 1
  PARAMS ((const char *, const char *));
d266 2
a267 1
#define OPTION_SREC_LEN (OPTION_REDEFINE_SYM + 1)
d354 1
d449 2
d947 2
a948 1
redefine_list_append (source, target)
d960 1
a960 2
	       "--redefine-sym",
	       source);
d964 1
a964 2
	       "--redefine-sym",
	       target);
d976 110
d2663 1
a2663 1
	    redefine_list_append (source, target);
d2668 4
@


1.46
log
@Add --info command line switch
@
text
@d2736 4
a2739 3
  /* If there is no destination file then create a temp and rename
     the result into the input.  */
  if (output_filename == (char *) NULL)
@


1.46.2.1
log
@	Merge from mainline:

	2003-05-13  Michael Eager <eager@@mvista.com>
	* objcopy.c: Treat identical src/dst file names as if only one
	entered.  One Windows creating an output file of the same name as
	the input file will delete the input file before it is read.

	2003-05-12  Salvador Eduardo Tropea  <salvador@@inti.gov.ar>
	* debug.c (debug_get_real_type): Extend test for circular debug
	references.

	2003-05-12  Nick Clifton  <nickc@@redhat.com>
	* configure.in (ALL_LINGUAS): Add zh_CN.
	* configure: Regenerate.
	* po/zh_CN.po: New file: Chinese (simplified) translation.

	2003-05-07  H.J. Lu <hongjiu.lu@@intel.com>
	* readelf.c (dump_relocations): Enlarge the type field in wide
	mode by one character.
@
text
@d2736 3
a2738 4
  /* If there is no destination file, or the source and destination files
     are the same,  then create a temp and rename the result into the input.  */
  if ((output_filename == (char *) NULL) ||
      (strcmp (input_filename, output_filename) == 0))
@


1.45
log
@	* objcopy.c (filter_symbols): Fix compilation problems with
	HP-UX's C compiler.
@
text
@d278 1
d288 1
d332 1
d463 1
d495 1
d2089 2
a2090 1
  char *input_target = NULL, *output_target = NULL;
d2092 3
a2094 1
  int c, i;
d2152 3
d2166 6
d2234 4
a2237 2
  char *input_filename = NULL, *output_filename = NULL;
  char *input_target = NULL, *output_target = NULL;
d2240 1
d2348 4
d2686 6
a2737 1

@


1.44
log
@Added --prefix-symbols <prefix> option to rename all symbols by adding the
given prefix to the begining of the symbol name. This is useful to provide
name space seperation regardless of how the object file was created. Added
--prefix-sections <prefix> and --prefix-alloc-sections <prefix> options to
rename all sections (or all sections with the alloc flag set) by adding the
given prefix to the begining of the symbol name.
@
text
@d3 1
a3 1
   2001, 2002
d801 2
a802 1
	  name = (char *) bfd_asymbol_name (sym) = new_name;
d832 1
a832 1
	name = (char *) bfd_asymbol_name (sym) = name + 1;
d850 2
a851 1
          name = (char *) bfd_asymbol_name (sym) = n;
d1001 2
d1038 3
a1040 2
  if (!bfd_set_arch_mach (obfd, bfd_get_arch (ibfd),
			  bfd_get_mach (ibfd))
d1681 1
a1681 1
    
@


1.43
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d241 5
d275 3
d314 1
a326 1
  {"only-section", required_argument, 0, 'j'},
d333 2
d336 3
d341 1
d345 3
d349 1
a349 2
  {"localize-symbol", required_argument, 0, 'L'},
  {"keep-global-symbol", required_argument, 0, 'G'},
d355 2
d361 1
a366 7
  {"redefine-sym", required_argument, 0, OPTION_REDEFINE_SYM},
  {"srec-len", required_argument, 0, OPTION_SREC_LEN},
  {"srec-forceS3", no_argument, 0, OPTION_SREC_FORCES3},
  {"keep-symbols", required_argument, 0, OPTION_KEEP_SYMBOLS},
  {"strip-symbols", required_argument, 0, OPTION_STRIP_SYMBOLS},
  {"keep-global-symbols", required_argument, 0, OPTION_KEEPGLOBAL_SYMBOLS},
  {"localize-symbols", required_argument, 0, OPTION_LOCALIZE_SYMBOLS},
a367 1
  {"alt-machine-code", required_argument, 0, OPTION_ALT_MACH_CODE},
d452 5
d787 1
a787 1
      const char *name = bfd_asymbol_name (sym);
d790 4
d797 1
a797 1
	  const char *old_name, *new_name;
d799 48
a846 4
	  old_name = bfd_asymbol_name (sym);
	  new_name = lookup_sym_redefinition (old_name);
	  name = bfd_asymbol_name (sym) = new_name;
	}
d848 2
a849 20
      if (change_leading_char
	  && (bfd_get_symbol_leading_char (abfd)
	      != bfd_get_symbol_leading_char (obfd))
	  && (bfd_get_symbol_leading_char (abfd) == '\0'
	      || (name[0] == bfd_get_symbol_leading_char (abfd))))
	{
	  if (bfd_get_symbol_leading_char (obfd) == '\0')
	    name = bfd_asymbol_name (sym) = name + 1;
	  else
	    {
	      char *n;

	      n = xmalloc (strlen (name) + 2);
	      n[0] = bfd_get_symbol_leading_char (obfd);
	      if (bfd_get_symbol_leading_char (abfd) == '\0')
		strcpy (n + 1, name);
	      else
		strcpy (n + 1, name + 1);
	      name = bfd_asymbol_name (sym) = n;
	    }
a851 10
      undefined = bfd_is_und_section (bfd_get_section (sym));

      if (remove_leading_char
	  && ((flags & BSF_GLOBAL) != 0
	      || (flags & BSF_WEAK) != 0
	      || undefined
	      || bfd_is_com_section (bfd_get_section (sym)))
	  && name[0] == bfd_get_symbol_leading_char (abfd))
	name = bfd_asymbol_name (sym) = name + 1;

d1215 1
d1639 1
d1661 16
d2631 12
@


1.42
log
@	* objcopy.c (copy_file): Report ambiguous bfd_object matches, and
	other object errors in preference to bfd_core errors.
@
text
@d63 24
a86 12
static void copy_usage PARAMS ((FILE *, int));
static void strip_usage PARAMS ((FILE *, int));
static flagword parse_flags PARAMS ((const char *));
static struct section_list *find_section_list PARAMS ((const char *, boolean));
static void setup_section PARAMS ((bfd *, asection *, PTR));
static void copy_section PARAMS ((bfd *, asection *, PTR));
static void get_sections PARAMS ((bfd *, asection *, PTR));
static int compare_section_lma PARAMS ((const PTR, const PTR));
static void add_specific_symbol PARAMS ((const char *, struct symlist **));
static void add_specific_symbols PARAMS ((const char *, struct symlist **));
static boolean is_specified_symbol PARAMS ((const char *, struct symlist *));
static boolean is_strip_section PARAMS ((bfd *, asection *));
d89 10
a98 5
static void mark_symbols_used_in_relocations PARAMS ((bfd *, asection *, PTR));
static void filter_bytes PARAMS ((char *, bfd_size_type *));
static boolean write_debugging_info PARAMS ((bfd *, PTR, long *, asymbol ***));
static void copy_object PARAMS ((bfd *, bfd *));
static void copy_archive PARAMS ((bfd *, bfd *, const char *));
d101 12
a112 6
static int strip_main PARAMS ((int, char **));
static int copy_main PARAMS ((int, char **));
static const char *lookup_sym_redefinition PARAMS((const char *));
static void redefine_list_append PARAMS ((const char *, const char *));
static const char * find_section_rename PARAMS ((bfd *, sec_ptr, flagword *));
static void add_section_rename PARAMS ((const char *, const char *, flagword));
d123 2
a124 2
static boolean verbose;		/* Print file and target names.  */
static boolean preserve_dates;	/* Preserve input file timestamp.  */
d160 11
a170 11
  struct section_list * next;      /* Next section to change.  */
  const char *          name;      /* Section name.  */
  boolean               used;      /* Whether this entry was used.  */
  boolean               remove;    /* Whether to remove this section.  */
  boolean		copy;      /* Whether to copy this section.  */
  enum change_action    change_vma;/* Whether to change or set VMA.  */
  bfd_vma 		vma_val;   /* Amount to change by or set to.  */
  enum change_action    change_lma;/* Whether to change or set LMA.  */
  bfd_vma 		lma_val;   /* Amount to change by or set to.  */
  boolean 		set_flags; /* Whether to set the section flags.  */
  flagword 		flags;     /* What to set the section flags to.  */
d175 2
a176 2
/* True if some sections are to be removed.  */
static boolean sections_removed;
d178 2
a179 2
/* True if only some sections are to be copied.  */
static boolean sections_copied;
d183 1
a183 1
static boolean set_start_set = false;
d190 1
a190 1
static boolean gap_fill_set = false;
d194 1
a194 1
static boolean pad_to_set = false;
d221 1
a221 1
static boolean convert_debugging = false;
d224 1
a224 1
static boolean change_leading_char = false;
d227 1
a227 1
static boolean remove_leading_char = false;
d238 2
a239 2
/* If this is true, we weaken global symbols (set BSF_WEAK).  */
static boolean weaken = false;
d375 1
a375 1
extern boolean S3Forced;
d546 1
a546 1
     boolean add;
d559 3
a561 3
  p->used = false;
  p->remove = false;
  p->copy = false;
d566 1
a566 1
  p->set_flags = false;
d630 1
a630 1
      int finished = false;
d641 1
a641 1
	      finished = true;
d649 1
a649 1
	      finished = true;
d653 1
a653 1
	      finished = true;
d709 1
a709 1
static boolean
d718 1
a718 1
      return true;
d720 1
a720 1
  return false;
d725 1
a725 1
static boolean
d738 1
a738 1
    return true;
d741 1
a741 1
    return false;
d743 1
a743 1
  p = find_section_list (bfd_get_section_name (abfd, sec), false);
d745 1
a745 1
    return true;
d747 2
a748 2
    return true;
  return false;
d773 1
a773 1
      boolean undefined;
d828 1
a828 1
	   even if relocatable is false.  External users of the
d1041 1
a1041 1
	      pset = find_section_list (padd->name, false);
d1043 1
a1043 1
		pset->used = true;
d1385 1
a1385 1
      if (bfd_check_format (this_element, bfd_object) == true)
d1493 1
a1493 1
      
d1611 1
a1611 1
  p = find_section_list (bfd_section_name (ibfd, isection), false);
d1613 1
a1613 1
    p->used = true;
d1671 3
a1673 4
  if (bfd_set_section_alignment (obfd,
				 osection,
				 bfd_section_alignment (ibfd, isection))
      == false)
d1751 1
a1751 1
  p = find_section_list (bfd_section_name (ibfd, isection), false);
d1806 1
a1806 1
  isection->reloc_done = true;
d1952 1
a1952 1
static boolean
d1972 1
a1972 1
	return false;
d1994 1
a1994 1
	  return false;
d2009 1
a2009 1
	  return false;
d2012 1
a2012 1
      return true;
d2017 1
a2017 1
  return false;
d2026 1
a2026 1
  boolean show_version = false;
d2046 3
a2048 3
	  p = find_section_list (optarg, true);
	  p->remove = true;
	  sections_removed = true;
d2071 1
a2071 1
	  preserve_dates = true;
d2080 1
a2080 1
	  verbose = true;
d2083 1
a2083 1
	  show_version = true;
d2160 2
a2161 2
  boolean show_version = false;
  boolean change_warn = true;
d2202 1
a2202 1
	  p = find_section_list (optarg, true);
d2205 2
a2206 2
	  p->copy = true;
	  sections_copied = true;
d2210 1
a2210 1
	  p = find_section_list (optarg, true);
d2213 2
a2214 2
	  p->remove = true;
	  sections_removed = true;
d2250 1
a2250 1
	  preserve_dates = true;
d2262 1
a2262 1
	  verbose = true;
d2266 1
a2266 1
	  show_version = true;
d2270 1
a2270 1
	  weaken = true;
d2364 1
a2364 1
	    p = find_section_list (name, true);
d2401 1
a2401 1
	  change_warn = true;
d2405 1
a2405 1
	  change_leading_char = true;
d2409 1
a2409 1
	  convert_debugging = true;
d2427 1
a2427 1
	    gap_fill_set = true;
d2432 1
a2432 1
	  change_warn = false;
d2437 1
a2437 1
	  pad_to_set = true;
d2441 1
a2441 1
	  remove_leading_char = true;
d2489 1
a2489 1
	    p = find_section_list (name, true);
d2491 1
a2491 1
	    p->set_flags = true;
d2542 1
a2542 1
	  set_start_set = true;
d2550 1
a2550 1
	  S3Forced = true;
@


1.41
log
@2002-08-13  H.J. Lu <hjl@@gnu.org>

	* objcopy.c (copy_object): Don't warn about the unsupported
	architecture unless the input target is defaulted or the
	output architecture is different from the input.
@
text
@d1421 2
a1422 1
  char **matching;
d1445 1
a1445 2
  else if (bfd_check_format_matches (ibfd, bfd_object, &matching)
	   || bfd_check_format_matches (ibfd, bfd_core, &matching))
d1448 1
a1448 1

d1468 16
d1486 6
a1491 1
      if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
d1493 2
a1494 2
	  list_matching_formats (matching);
	  free (matching);
@


1.40
log
@	* objcopy.c (copy_section): Don't copy SEC_GROUP sections.
@
text
@d976 3
a978 1
			  bfd_get_mach (ibfd)))
@


1.39
log
@	* filemode.c: Fix formatting.
	* ieee.c: Likewise.
	* is-ranlib.c: Likewise.
	* is-strip.c: Likewise.
	* maybe-ranlib.c: Likewise.
	* maybe-strip.c: Likewise.
	* nlmconv.c: Likewise.
	* nm.c: Likewise.
	* not-ranlib.c: Likewise.
	* not-strip.c: Likewise.
	* objcopy.c: Likewise.
	* objdump.c: Likewise.
@
text
@d1687 1
d1694 2
a1695 1
  if ((bfd_get_section_flags (ibfd, isection) & SEC_DEBUGGING) != 0
d1701 3
@


1.38
log
@	* configure: Regenerate.
	* objcopy.c: Update copyright date.
	* doc/Makefile.in: Regenerate.
@
text
@d35 1
a35 1
   deleted. */
d100 1
a100 1
static boolean verbose;		/* Print file and target names. */
d113 1
a113 1
/* Which symbols to remove. */
d342 1
a342 1
   -1 means if we should use argv[0] to decide. */
d567 1
a567 1
/* Add symbols listed in `filename' to strip_specific_list. */
d582 1
a582 1
  
d601 1
a601 1
  
d620 1
a620 1
	      
d628 1
a628 1
	      
d632 1
a632 1
	      
d639 1
a639 1
	      
d656 2
a657 2
           name_end ++)
        ;
d670 1
a670 1
  
d800 1
a800 1
      else if (relocatable			/* Relocatable file. */
d963 2
a964 2
  /* Neither the start address nor the flags 
     need to be set for a core file. */
d1091 2
a1092 2
			       bfd_get_section_name (obfd, osections[i]),
			       bfd_errmsg (bfd_get_error ()));
d1116 2
a1117 2
			   bfd_get_section_name (obfd, osections[c - 1]),
			   bfd_errmsg (bfd_get_error ()));
d1366 1
a1366 1
	  /* Error in new object file. Don't change archive. */
d1496 1
a1496 1
	
d1506 1
a1506 1
  
d1556 1
a1556 1
  
d1576 1
a1576 1
  
d1714 1
a1714 1
  /* Core files do not need to be relocated. */
d1735 1
a1735 1
	     keep_strip_specific_list. */
d1758 1
a1758 1
  if (bfd_get_section_flags (ibfd, isection) & SEC_HAS_CONTENTS 
d2127 3
a2129 3
        case 'B':
          binary_architecture = optarg;
          break;
d2495 3
a2497 3
        case OPTION_SREC_LEN:
          Chunk = parse_vma (optarg, "--srec-len");
          break;
d2499 1
a2499 1
        case OPTION_SREC_FORCES3:
d2501 1
a2501 1
          break;
d2564 2
a2565 2
        {
          const bfd_arch_info_type * temp_arch_info;
d2569 5
a2573 5
          if (temp_arch_info != NULL)
            bfd_external_binary_architecture = temp_arch_info->arch;
          else
            fatal (_("architecture %s unknown"), binary_architecture);
        }
@


1.37
log
@	* objcopy.c (MKDIR): Define.
	(copy_archive): Make name_list.name const.  Use MKDIR.
	Handle duplicate files in archives by making more temp dirs.
@
text
@d3 1
a3 1
   2001
@


1.36
log
@Add --totals option to size
@
text
@d1271 7
d1290 1
a1290 1
      char *name;
d1298 1
a1298 5
#if defined (_WIN32) && !defined (__CYGWIN32__)
  if (mkdir (dir) != 0)
#else
  if (mkdir (dir, 0700) != 0)
#endif
d1314 2
a1315 4
      /* Create an output file for this member.  */
      char *output_name = concat (dir, "/", bfd_get_filename (this_element),
				  (char *) NULL);
      bfd *output_bfd = bfd_openw (output_name, output_target);
d1320 23
d1398 7
a1404 2
      bfd_close (l->obfd);
      unlink (l->name);
@


1.36.2.1
log
@	* objcopy.c (MKDIR): Define.
	(copy_archive): Make name_list.name const.  Use MKDIR.
	Handle duplicate files in archives by making more temp dirs.
@
text
@d3 1
a3 1
   2001, 2002
a1270 7
#undef MKDIR
#if defined (_WIN32) && !defined (__CYGWIN32__)
#define MKDIR(DIR, MODE) mkdir (DIR)
#else
#define MKDIR(DIR, MODE) mkdir (DIR, MODE)
#endif

d1283 1
a1283 1
      const char *name;
d1291 5
a1295 1
  if (MKDIR (dir, 0700) != 0)
d1311 4
a1314 2
      char *output_name;
      bfd *output_bfd;
a1318 23
      /* Create an output file for this member.  */
      output_name = concat (dir, "/",
			    bfd_get_filename (this_element), (char *) 0);

      /* If the file already exists, make another temp dir.  */
      if (stat (output_name, &buf) >= 0)
	{
	  output_name = make_tempname (output_name);
	  if (MKDIR (output_name, 0700) != 0)
	    {
	      fatal (_("cannot mkdir %s for archive copying (error: %s)"),
		     output_name, strerror (errno));
	    }
	  l = (struct name_list *) xmalloc (sizeof (struct name_list));
	  l->name = output_name;
	  l->next = list;
	  l->obfd = NULL;
	  list = l;
	  output_name = concat (output_name, "/",
				bfd_get_filename (this_element), (char *) 0);
	}

      output_bfd = bfd_openw (output_name, output_target);
d1374 2
a1375 7
      if (l->obfd == NULL)
	rmdir (l->name);
      else
	{
	  bfd_close (l->obfd);
	  unlink (l->name);
	}
@


1.35
log
@Tidy up formatting of --help output.
@
text
@d443 1
a443 1
  -g -S --strip-debug              Remove all debugging symbols\n\
@


1.34
log
@Refer to "options" not "switches"
@
text
@d363 2
a364 1
  fprintf (stream, _("Usage: %s <options> in-file [out-file]\n"), program_name);
d433 2
a434 1
  fprintf (stream, _("Usage: %s <options> in-file(s)\n"), program_name);
d437 3
a439 3
  -I --input-target <bfdname>      Assume input file is in format <bfdname>\n\
  -O --output-target <bfdname>     Create an output file in format <bfdname>\n\
  -F --target <bfdname>            Set both input and output format to <bfdname>\n\
d441 1
a441 1
  -R --remove-section <name>       Remove section <name> from the output\n\
d445 2
a446 2
  -N --strip-symbol <name>         Do not copy symbol <name>\n\
  -K --keep-symbol <name>          Only copy symbol <name>\n\
d1952 1
a1952 1
  while ((c = getopt_long (argc, argv, "I:O:F:K:N:R:o:sSpdgxXVv",
d2009 1
d2087 1
a2087 1
  while ((c = getopt_long (argc, argv, "b:B:i:I:j:K:N:s:O:d:F:L:G:R:SpgxXVvW:",
d2503 1
@


1.33
log
@2001-12-18  Michael Snyder  <msnyder@@redhat.com>

        * objcopy.c (copy_file): Accept corefiles (format bfd_core).
        (copy_object): Don't set the start address or flags of a core file.
        (copy_section): Don't relocate a core file.  Don't copy contents
        if the input section has the contents flag set, but the output
        section does not (which happens with the fake 'note' pseudo-
        sections that BFD creates for corefiles).
@
text
@d363 2
a364 2
  fprintf (stream, _("Usage: %s <switches> in-file [out-file]\n"), program_name);
  fprintf (stream, _(" The switches are:\n"));
d432 2
a433 2
  fprintf (stream, _("Usage: %s <switches> in-file(s)\n"), program_name);
  fprintf (stream, _(" The switches are:\n"));
@


1.32
log
@	* objcopy.c (copy_archive): Set output bfd format outside the loop.
@
text
@d961 10
a970 5
  if (!bfd_set_start_address (obfd, start)
      || !bfd_set_file_flags (obfd,
			      (bfd_get_file_flags (ibfd)
			       & bfd_applicable_file_flags (obfd))))
    RETURN_NONFATAL (bfd_get_filename (ibfd));
d1411 2
a1412 1
  else if (bfd_check_format_matches (ibfd, bfd_object, &matching))
d1683 6
a1688 1
  relsize = bfd_get_reloc_upper_bound (ibfd, isection);
d1727 2
a1728 1
  if (bfd_get_section_flags (ibfd, isection) & SEC_HAS_CONTENTS)
@


1.31
log
@	* addr2line.c (main): Protoype.
	* ar.c (main): Protoype.
	* nm.c (main): Protoype.
	* objcopy.c (main): Protoype.
	* objdump.c (main): Protoype.
	* size.c (main): Protoype.
	* strings.c (main): Protoype.
	* gasp.c (main): Protoype.
@
text
@d1299 3
a1327 3

      if (!bfd_set_format (obfd, bfd_get_format (ibfd)))
	RETURN_NONFATAL (bfd_get_filename (obfd));
@


1.30
log
@	* objcopy.c (setup_section): Copy entsize.
@
text
@d2605 2
@


1.29
log
@	* objcopy.c (setup_section): Preserve SEC_RELOC when
	--set-section-flags is used.
@
text
@d1605 3
@


1.28
log
@	* objcopy.c (copy_main): Correct rename-section string parsing.
	Consolidate new_name parsing, and error messages.
@
text
@d1598 1
a1598 1
    flags = p->flags | (flags & SEC_HAS_CONTENTS);
@


1.27
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d2402 3
a2404 3
	    const char * s;
	    char * old_name;
	    char * new_name;
d2407 2
a2408 2
	    s = strchr (optarg, '=');
	    if (s == NULL)
d2411 1
a2411 1
	    len = s - optarg;
d2413 1
a2413 1
	      fatal (_("no old name is %s"), "--rename-section");
d2419 3
a2421 2
	    s = strchr (optarg + len, ',');
	    if (s)
d2423 2
a2424 9
		unsigned int new_len;

		flags = parse_flags (s + 1);
		new_len = s - (optarg + len);
		if (new_len == 0)
		  fatal (_("no new name in %s"), "--rename-section");
		new_name = (char *) xmalloc (new_len + 1);
		strncpy (new_name, optarg + len, new_len);
		new_name [new_len] = 0;
a2427 6
		s = optarg + len;
		len = strlen (s);
		if (len == 0)
		  fatal (_("no new name in %s"), "--rename-section");
		new_name = (char *) xmalloc (len + 1);
		strcpy (new_name, s);
d2429 1
d2431 7
@


1.26
log
@* objcopy.c (use_alt_mach_code): New variable.
(OPTION_ALT_MACH_CODE): Define.
(copy_options): Added --alt-machine-code.
(copy_main): Handle it.
(copy_object): Switch to alternate machine code if requested.
* doc/binutils.texi: Document new option.
* NEWS: Likewise.
@
text
@d2614 3
@


1.25
log
@Implement new switch --rename-section
@
text
@d174 3
d246 1
d333 1
d416 1
d1253 9
d2478 6
@


1.24
log
@And remove the seconf accidental patch commission.
@
text
@d51 12
d88 2
d151 2
d154 2
a174 1

d191 1
a194 1

a197 1

a200 1

a204 1

a212 1

d242 1
d309 1
d352 1
d400 1
d686 3
a688 4
    {
      if (strcmp (name, tmp_list->name) == 0)
	return true;
    }
d851 2
a856 1
  const char *result;
d859 3
a861 1
  result = source;
d863 1
a863 9
  for (list = redefine_sym_list; list != NULL; list = list->next)
    {
      if (strcmp (source, list->source) == 0)
	{
	  result = list->target;
	  break;
	}
    }
  return result;
d866 1
a866 1
/* Add a node to a symbol redefine list */
d880 3
a882 5
	{
	  fatal (_("%s: Multiple redefinition of symbol \"%s\""),
		 "--redefine-sym",
		  source);
	}
d885 3
a887 5
	{
	  fatal (_("%s: Symbol \"%s\" is target of more than one redefinition"),
		 "--redefine-sym",
		  target);
	}
a898 1

d911 1
d961 1
a961 1
  /* Copy architecture of input file to output file */
d1117 2
a1118 2
  /* Symbol filtering must happen after the output sections have
     been created, but before their contents are set.  */
a1198 1

d1214 1
d1239 1
a1239 1
  if (!bfd_copy_private_bfd_data (ibfd, obfd))
d1283 1
d1297 1
a1371 1

d1426 62
a1487 2
/* Create a section in OBFD with the same name and attributes
   as ISECTION in IBFD.  */
d1503 2
a1504 1

d1522 4
a1525 1
  osection = bfd_make_section_anyway (obfd, bfd_section_name (ibfd, isection));
a1581 1
  flags = bfd_get_section_flags (ibfd, isection);
d1604 1
a1604 1
  /* All went well */
d1633 2
a1634 2
  /* If we have already failed earlier on, do not keep on generating
     complaints now.  */
d1975 2
a1976 1
	  break;		/* we've been given a long option */
d2343 1
a2343 3
	      {
		fatal (_("bad format for %s"), "--redefine-sym");
	      }
d2384 48
d2540 1
@


1.23
log
@Remove patch accidentally checked in with readelf.c patch
@
text
@a1618 26
      else if (sections_removed)
	{
	  /* Remove relocations which are against symbols
	     in sections that have been removed, unless
	     the symbols are going to be preserved.  */
	  arelent ** temp_relpp;
	  asymbol *  sym;
	  long temp_relcount = 0;
	  long i;

	  temp_relpp = (arelent **) xmalloc (relsize);
	  for (i = 0; i < relcount; i++)
	    {
	      sym = *relpp [i]->sym_ptr_ptr;

	      /* FIXME: Should we warn about deleted relocs ?  */
	      if (is_specified_symbol (bfd_asymbol_name (sym),
				       keep_specific_list)
		  || bfd_get_output_section (sym) != NULL)
		temp_relpp [temp_relcount++] = relpp [i];
	    }

	  relcount = temp_relcount;
	  free (relpp);
	  relpp = temp_relpp;
	}
@


1.22
log
@Display the contents of a .debug.macinfo section
@
text
@d1780 2
a1781 1
  /* Examine each symbol used in a relocation.  */
d1784 4
a1787 13
      asymbol * sym = * relpp[i]->sym_ptr_ptr;
      
      /* If the symbol's output section does not exist (because it
	 has been removed with -R) then do not keep the symbol.  */
      if (bfd_get_output_section (sym) == NULL)
	continue;
      
      /* If the symbols is not one of the special bfd
	 section symbols, then mark it with BSF_KEEP.  */
      if (sym != bfd_com_section_ptr->symbol
	  && sym != bfd_abs_section_ptr->symbol
	  && sym != bfd_und_section_ptr->symbol)
	sym->flags |= BSF_KEEP;
@


1.21
log
@2001-07-05  H.J. Lu  <hjl@@gnu.org>

	* objcopy.c (filter_symbols): Don't turn undefined symbols
	into local.
@
text
@d810 1
a810 1
            
d1573 1
a1573 3
    {
      return;
    }
a1587 1

d1619 27
d1780 1
a1780 2
  /* Examine each symbol used in a relocation.  If it's not one of the
     special bfd section symbols, then mark it with BSF_KEEP.  */
d1783 13
a1795 4
      if (*relpp[i]->sym_ptr_ptr != bfd_com_section_ptr->symbol
	  && *relpp[i]->sym_ptr_ptr != bfd_abs_section_ptr->symbol
	  && *relpp[i]->sym_ptr_ptr != bfd_und_section_ptr->symbol)
	(*relpp[i]->sym_ptr_ptr)->flags |= BSF_KEEP;
@


1.20
log
@2001-06-24  H.J. Lu  <hjl@@gnu.org>

	* objcopy.c (strip_main): Revert the change made on 2001-05-30
	by accident.
	(copy_main): Apply the the change made to strip_main on
	2001-05-30 by accident.
@
text
@d726 1
d759 2
d764 1
a764 1
	      || bfd_is_und_section (bfd_get_section (sym))
d787 1
a787 1
	       || bfd_is_und_section (bfd_get_section (sym))
d817 1
a817 1
      if (keep && (flags & (BSF_GLOBAL | BSF_WEAK))
@


1.19
log
@Add missing support for -o option.
@
text
@d1848 1
a1848 1
  while ((c = getopt_long (argc, argv, "b:i:o:I:j:K:N:s:O:d:F:L:G:R:SpgxXVvW:",
d1981 1
a1981 1
  while ((c = getopt_long (argc, argv, "b:B:i:I:j:K:N:s:O:d:F:L:R:SpgxXVvW:",
@


1.18
log
@Add command line switches to objcopy to provide lists of symbols in files
@
text
@d243 1
d781 1
a781 1
	  keep = 1;
d791 4
d807 1
a807 1

d1848 1
a1848 1
  while ((c = getopt_long (argc, argv, "b:i:I:j:K:N:s:O:d:F:L:G:R:SpgxXVvW:",
@


1.17
log
@Fix typos in ChangeLogs and update copyright notices
@
text
@d60 1
d188 2
a189 1
/* List of symbols to strip, keep, localize, weaken, or redefine.  */
d194 1
d224 5
d291 1
d308 5
d358 1
d388 5
d541 116
d775 6
d810 3
a812 1
	  && is_specified_symbol (name, localize_specific_list))
d1124 1
d1843 1
a1843 1
  while ((c = getopt_long (argc, argv, "I:O:F:K:N:R:o:sSpdgxXVv",
d2051 4
d2320 20
@


1.16
log
@Add --binary-architecture switch to objcopy to allow the output architecture
to be set when the input file type is binary.
@
text
@d2 2
a3 1
   Copyright (C) 1991, 92, 93, 94, 95, 96, 97, 98, 99, 2000, 2001
@


1.15
log
@Stop objcopy trying to convert endianness.
@
text
@d255 1
d318 3
d331 1
d1821 1
d1830 1
a1830 1
  while ((c = getopt_long (argc, argv, "b:i:I:j:K:N:s:O:d:F:L:R:SpgxXVvW:",
d1841 4
d2202 1
a2202 1
  if (preserve_dates)
d2204 16
a2219 2
      if (stat (input_filename, &statbuf) < 0)
	fatal (_("Cannot stat: %s: %s"), input_filename, strerror (errno));
d2221 4
@


1.15.2.1
log
@Add command line options to objcopy to specify symbols as lists in files
@
text
@a58 1
static void add_specific_symbols PARAMS ((const char *, struct symlist **));
d186 1
a186 2
/* List of symbols to strip, keep, localize, keep-global, weaken,
   or redefine.  */
a190 1
static struct symlist *keepglobal_specific_list = NULL;
a219 5
#define OPTION_STRIP_SYMBOLS (OPTION_SREC_FORCES3 + 1)
#define OPTION_KEEP_SYMBOLS (OPTION_STRIP_SYMBOLS + 1)
#define OPTION_LOCALIZE_SYMBOLS (OPTION_KEEP_SYMBOLS + 1)
#define OPTION_KEEPGLOBAL_SYMBOLS (OPTION_LOCALIZE_SYMBOLS + 1)
#define OPTION_WEAKEN_SYMBOLS (OPTION_KEEPGLOBAL_SYMBOLS + 1)
a280 1
  {"keep-global-symbol", required_argument, 0, 'G'},
a296 5
  {"keep-symbols", required_argument, 0, OPTION_KEEP_SYMBOLS},
  {"strip-symbols", required_argument, 0, OPTION_STRIP_SYMBOLS},
  {"keep-global-symbols", required_argument, 0, OPTION_KEEPGLOBAL_SYMBOLS},
  {"localize-symbols", required_argument, 0, OPTION_LOCALIZE_SYMBOLS},
  {"weaken-symbols", required_argument, 0, OPTION_WEAKEN_SYMBOLS},
a337 1
  -G --keep-global-symbol <name>   Localize all symbols except <name>\n\
a366 5
     --strip-symbols <file>        -N for all symbols listed in <file>\n\
     --keep-symbols <file>         -K for all symbols listed in <file>\n\
     --localize-symbols <file>     -L for all symbols listed in <file>\n\
     --keep-global-symbols <file>  -G for all symbols listed in <file>\n\
     --weaken-symbols <file>       -W for all symbols listed in <file>\n\
a514 116
/* Add symbols listed in `filename' to strip_specific_list. */

#define IS_WHITESPACE(c)      ((c) == ' ' || (c) == '\t')
#define IS_LINE_TERMINATOR(c) ((c) == '\n' || (c) == '\r' || (c) == '\0')

static void
add_specific_symbols (filename, list)
     const char *filename;
     struct symlist **list;
{
  struct stat st;
  FILE * f;
  char * line;
  char * buffer;
  unsigned int line_count;
  
  if (stat (filename, & st) < 0)
    fatal (_("cannot stat: %s: %s"), filename, strerror (errno));
  if (st.st_size == 0)
    return;

  buffer = (char *) xmalloc (st.st_size + 2);
  f = fopen (filename, FOPEN_RT);
  if (f == NULL)
    fatal (_("cannot open: %s: %s"), filename, strerror (errno));

  if (fread (buffer, 1, st.st_size, f) == 0 || ferror (f))
    fatal (_("%s: fread failed"), filename);

  fclose (f);
  buffer [st.st_size] = '\n';
  buffer [st.st_size + 1] = '\0';

  line_count = 1;
  
  for (line = buffer; * line != '\0'; line ++)
    {
      char * eol;
      char * name;
      char * name_end;
      int finished = false;

      for (eol = line;; eol ++)
	{
	  switch (* eol)
	    {
	    case '\n':
	      * eol = '\0';
	      /* Cope with \n\r.  */
	      if (eol[1] == '\r')
		++ eol;
	      finished = true;
	      break;
	      
	    case '\r':
	      * eol = '\0';
	      /* Cope with \r\n.  */
	      if (eol[1] == '\n')
		++ eol;
	      finished = true;
	      break;
	      
	    case 0:
	      finished = true;
	      break;
	      
	    case '#':
	      /* Line comment, Terminate the line here, in case a
		 name is present and then allow the rest of the
		 loop to find the real end of the line.  */
	      * eol = '\0';
	      break;
	      
	    default:
	      break;
	    }

	  if (finished)
	    break;
	}

      /* A name may now exist somewhere between 'line' and 'eol'.
	 Strip off leading whitespace and trailing whitespace,
	 then add it to the list.  */
      for (name = line; IS_WHITESPACE (* name); name ++)
	;
      for (name_end = name;
	   (! IS_WHITESPACE (* name_end))
	   && (! IS_LINE_TERMINATOR (* name_end));
           name_end ++)
        ;

      if (! IS_LINE_TERMINATOR (* name_end))
	{
	  char * extra;

	  for (extra = name_end + 1; IS_WHITESPACE (* extra); extra ++)
	    ;

	  if (! IS_LINE_TERMINATOR (* extra))
	    non_fatal (_("Ignoring rubbish found on line %d of %s"),
		       line_count, filename);
	}
  
      * name_end = '\0';

      if (name_end > name)
	add_specific_symbol (name, list);

      /* Advance line pointer to end of line.  The 'eol ++' in the for
	 loop above will then advance us to the start of the next line.  */
      line = eol;
      line_count ++;
    }
}

a632 6
      else if (bfd_decode_symclass (sym) == 'I')
	/* Global symbols in $idata sections need to be retained
	   even if relocatable is false.  External users of the
	   library containing the $idata section may reference these
	   symbols.  */
	  keep = 1;
d662 1
a662 3
	  && (is_specified_symbol (name, localize_specific_list)
	      || (keepglobal_specific_list != NULL
		  && ! is_specified_symbol (name, keepglobal_specific_list))))
a973 1
      || keepglobal_specific_list != NULL
d1692 1
a1692 1
  while ((c = getopt_long (argc, argv, "b:i:I:j:K:N:s:O:d:F:L:G:R:SpgxXVvW:",
a1894 4
	case 'G':
	  add_specific_symbol (optarg, &keepglobal_specific_list);
	  break;

a2159 20

	case OPTION_STRIP_SYMBOLS:
	  add_specific_symbols (optarg, &strip_specific_list);
	  break;

	case OPTION_KEEP_SYMBOLS:
	  add_specific_symbols (optarg, &keep_specific_list);
	  break;

	case OPTION_LOCALIZE_SYMBOLS:
	  add_specific_symbols (optarg, &localize_specific_list);
	  break;

	case OPTION_KEEPGLOBAL_SYMBOLS:
	  add_specific_symbols (optarg, &keepglobal_specific_list);
	  break;

	case OPTION_WEAKEN_SYMBOLS:
	  add_specific_symbols (optarg, &weaken_specific_list);
	  break;
@


1.15.2.2
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001
@


1.15.2.3
log
@Restore ability of strip to accept -o command line switch
@
text
@a242 1
  {"output-file", required_argument, 0, 'o'},
d775 1
a775 1
	keep = 1;
a784 4
      else if (bfd_get_section (sym)->comdat)
	/* COMDAT sections store special information in local
	   symbols, so we cannot risk stripping any of them.  */
	keep = 1;
d1838 1
a1838 1
  while ((c = getopt_long (argc, argv, "I:O:F:K:N:R:o:sSpdgxXVv",
d1970 1
a1970 1
  while ((c = getopt_long (argc, argv, "b:i:I:j:K:N:s:O:d:F:L:G:R:SpgxXVvW:",
d2363 4
a2366 2
    if (stat (input_filename, & statbuf) < 0)
      fatal (_("Cannot stat: %s: %s"), input_filename, strerror (errno));
@


1.14
log
@Add --srec-len and --srec-forceS3 switches to objcopy
@
text
@d2 1
a2 1
   Copyright (C) 1991, 92, 93, 94, 95, 96, 97, 98, 99, 2000
d768 7
@


1.13
log
@Silently accept -d as an alias for -g for compatability with old BSD systems.
@
text
@d218 2
d295 2
d308 8
d365 2
d2145 8
@


1.12
log
@Eli Zaretskii's DOSish file name patches.
@
text
@d1671 1
a1671 1
  while ((c = getopt_long (argc, argv, "I:O:F:K:N:R:o:sSpgxXVv",
d1695 1
@


1.11
log
@2000-05-14  H.J. Lu  (hjl@@gnu.org)

	* objcopy.c (filter_symbols): Don't strip global symbols in
	relocatable object files.
@
text
@d2 1
a2 1
   Copyright (C) 1991, 92, 93, 94, 95, 96, 97, 98, 1999
d28 1
d2257 9
a2265 1
      is_strip = (i >= 5 && strcmp (program_name + i - 5, "strip") == 0);
@


1.10
log
@(setup_section): Add const and gettext calls for err.
@
text
@d559 2
d614 3
@


1.9
log
@Add --redefine-sym to objcopy.
@
text
@d1248 1
a1248 1
  char *err;
d1271 1
a1271 1
      err = "making";
d1280 1
a1280 1
      err = "size";
d1294 1
a1294 1
      err = "vma";
d1320 1
a1320 1
      err = "alignment";
d1329 1
a1329 1
      err = "flags";
d1343 1
a1343 1
      err = "private data";
@


1.8
log
@Move translated part of bug report string back into .c files so
xgettext can find it.  Regnerate .pot files.
@
text
@d41 8
d71 2
d185 1
a185 1
/* List of symbols to strip, keep, localize, and weaken.  */
d191 1
d216 1
d291 1
d351 1
d440 2
a441 1
	  fatal (_("supported flags: alloc, load, noload, readonly, debug, code, data, rom, share, contents"));
d487 1
a487 1
static void 
d567 9
d657 58
d775 1
a775 1
  
d781 1
a781 1
  
d807 1
a807 1
	      
d819 1
a819 1
	      
d828 1
a828 1
		  
d832 1
a832 1
		      
d931 1
a931 1
  
d936 1
a936 1
  
d939 2
a940 2
  
  if (strip_symbols == STRIP_DEBUG 
d953 1
d958 1
a958 1
	 
d1221 1
a1221 1
      
d1227 1
a1227 1
      
d1268 1
a1268 1
  
d1283 1
a1283 1
  
d1291 1
a1291 1
  
d1310 1
a1310 1
  
d1380 1
a1380 1
  
d1408 1
a1408 1
  
d1417 1
a1417 1
      
d1425 1
a1425 1
	  
d1439 1
a1439 1
  
d1451 1
a1451 1
      if (copy_byte >= 0) 
d1806 1
d1812 1
d1817 1
d1822 1
d1826 1
d1834 1
d1842 1
d1846 1
d1850 1
d1854 1
d1858 1
d1862 1
d1866 1
d1870 1
d1874 1
d1878 1
d1882 1
d1886 1
d1890 1
d1894 1
d1905 1
a1905 1
	    
d1907 1
a1907 1
	      fatal (_("bad format for --add-section NAME=FILENAME"));
d1926 1
a1926 1
	    
d1929 1
a1929 1
	    
d1940 1
d1944 1
d1955 1
a1955 1
	    
d1968 1
a1968 1
	    
d1996 1
a1996 1
	    
d2003 1
a2003 1
		
d2008 1
a2008 1
		
d2016 1
d2021 1
d2025 1
d2029 1
d2033 1
d2043 1
a2043 1
		
d2045 1
a2045 1
		
d2052 1
d2056 1
d2061 1
d2065 33
d2106 1
a2106 1
	      fatal (_("bad format for --set-section-flags"));
d2119 1
d2124 1
d2127 1
d2130 1
d2171 1
a2171 1
	{	
d2197 1
a2197 1
		  
d2199 2
a2200 1
		  non_fatal (_("Warning: --change-section-vma %s%c0x%s never used"),
d2205 1
a2205 1
	      
d2211 1
a2211 1
		  
d2213 2
a2214 1
		  non_fatal (_("Warning: --change-section-lma %s%c0x%s never used"),
@


1.7
log
@Move bug report string to one place.
@
text
@d344 1
a344 1
    fprintf (stream, REPORT_BUGS_TO);
d376 1
a376 1
    fprintf (stream, REPORT_BUGS_TO);
@


1.6
log
@Overhaul --help output.
@
text
@d344 1
a344 1
    fprintf (stream, _("Report bugs to bug-gnu-utils@@gnu.org\n"));
d376 1
a376 1
    fprintf (stream, _("Report bugs to bug-gnu-utils@@gnu.org\n"));
@


1.6.2.1
log
@This is a grab-bag of my stuff from the head branch.
Should have done it separately, I know.
- move bug report address to include file
- objcopy --redefine-sym
- update makefile dependencies (but use automake-000227)
- H.J. Lu's fix to readelf.c
@
text
@a40 8
/* A list to support redefine_sym.  */
struct redefine_node
{
  char *source;
  char *target;
  struct redefine_node *next;
};

a62 2
static const char *lookup_sym_redefinition PARAMS((const char *));
static void redefine_list_append PARAMS ((const char *, const char *));
d175 1
a175 1
/* List of symbols to strip, keep, localize, weaken, or redefine.  */
a180 1
static struct redefine_node *redefine_sym_list = NULL;
a204 1
#define OPTION_REDEFINE_SYM (OPTION_WEAKEN + 1)
a278 1
  {"redefine-sym", required_argument, 0, OPTION_REDEFINE_SYM},
a337 1
     --redefine-sym <old>=<new>    Redefine symbol name <old> to <new>\n\
d344 1
a344 1
    fprintf (stream, _("Report bugs to %s\n"), REPORT_BUGS_TO);
d376 1
a376 1
    fprintf (stream, _("Report bugs to %s\n"), REPORT_BUGS_TO);
d426 1
a426 2
	  fatal (_("supported flags: %s"),
		 "alloc, load, noload, readonly, debug, code, data, rom, share, contents");
d472 1
a472 1
static void
a551 9
      if (redefine_sym_list)
	{
	  const char *old_name, *new_name;

	  old_name = bfd_asymbol_name (sym);
	  new_name = lookup_sym_redefinition (old_name);
	  name = bfd_asymbol_name (sym) = new_name;
	}

a632 58
static const char *
lookup_sym_redefinition (source)
     const char *source;
{
  const char *result;
  struct redefine_node *list;

  result = source;

  for (list = redefine_sym_list; list != NULL; list = list->next)
    {
      if (strcmp (source, list->source) == 0)
	{
	  result = list->target;
	  break;
	}
    }
  return result;
}

/* Add a node to a symbol redefine list */

static void
redefine_list_append (source, target)
     const char *source;
     const char *target;
{
  struct redefine_node **p;
  struct redefine_node *list;
  struct redefine_node *new_node;

  for (p = &redefine_sym_list; (list = *p) != NULL; p = &list->next)
    {
      if (strcmp (source, list->source) == 0)
	{
	  fatal (_("%s: Multiple redefinition of symbol \"%s\""),
		 "--redefine-sym",
		  source);
	}

      if (strcmp (target, list->target) == 0)
	{
	  fatal (_("%s: Symbol \"%s\" is target of more than one redefinition"),
		 "--redefine-sym",
		  target);
	}
    }

  new_node = (struct redefine_node *) xmalloc (sizeof (struct redefine_node));

  new_node->source = strdup (source);
  new_node->target = strdup (target);
  new_node->next = NULL;

  *p = new_node;
}


d693 1
a693 1

d699 1
a699 1

d725 1
a725 1

d737 1
a737 1

d746 1
a746 1

d750 1
a750 1

d849 1
a849 1

d854 1
a854 1

d857 2
a858 2

  if (strip_symbols == STRIP_DEBUG
a870 1
      || redefine_sym_list
d875 1
a875 1

d1138 1
a1138 1

d1144 1
a1144 1

d1185 1
a1185 1

d1200 1
a1200 1

d1208 1
a1208 1

d1227 1
a1227 1

d1297 1
a1297 1

d1325 1
a1325 1

d1334 1
a1334 1

d1342 1
a1342 1

d1356 1
a1356 1

d1368 1
a1368 1
      if (copy_byte >= 0)
a1722 1

a1727 1

a1731 1

a1735 1

a1738 1

a1745 1

a1752 1

a1755 1

a1758 1

a1761 1

a1764 1

a1767 1

a1770 1

a1773 1

a1776 1

a1779 1

a1782 1

a1785 1

a1788 1

a1791 1

d1802 1
a1802 1

d1804 1
a1804 1
	      fatal (_("bad format for %s"), "--add-section");
d1823 1
a1823 1

d1826 1
a1826 1

a1836 1

a1839 1

d1850 1
a1850 1

d1863 1
a1863 1

d1891 1
a1891 1

d1898 1
a1898 1

d1903 1
a1903 1

a1910 1

a1914 1

a1917 1

a1920 1

a1923 1

d1933 1
a1933 1

d1935 1
a1935 1

a1941 1

a1944 1

a1948 1

a1951 33

	case OPTION_REDEFINE_SYM:
	  {
	    /* Push this redefinition onto redefine_symbol_list.  */

	    int len;
	    const char *s;
	    const char *nextarg;
	    char *source, *target;

	    s = strchr (optarg, '=');
	    if (s == NULL)
	      {
		fatal (_("bad format for %s"), "--redefine-sym");
	      }

	    len = s - optarg;
	    source = (char *) xmalloc (len + 1);
	    strncpy (source, optarg, len);
	    source[len] = '\0';

	    nextarg = s + 1;
	    len = strlen (nextarg);
	    target = (char *) xmalloc (len + 1);
	    strcpy (target, nextarg);

	    redefine_list_append (source, target);

	    free (source);
	    free (target);
	  }
	  break;

d1960 1
a1960 1
	      fatal (_("bad format for %s"), "--set-section-flags");
a1972 1

a1976 1

a1978 1

a1980 1

d2021 1
a2021 1
	{
d2047 1
a2047 1

d2049 1
a2049 2
		  non_fatal (_("%s %s%c0x%s never used"),
			     "--change-section-vma",
d2054 1
a2054 1

d2060 1
a2060 1

d2062 1
a2062 2
		  non_fatal (_("%s %s%c0x%s never used"),
			     "--change-section-lma",
@


1.6.2.2
log
@Eli Zaretskii's DOSish file name patches.
@
text
@d2 1
a2 1
   Copyright (C) 1991, 92, 93, 94, 95, 96, 97, 98, 99, 2000
a27 1
#include "filenames.h"
d2251 1
a2251 9
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
      /* Drop the .exe suffix, if any.  */
      if (i > 4 && FILENAME_CMP (program_name + i - 4, ".exe") == 0)
	{
	  i -= 4;
	  program_name[i] = '\0';
	}
#endif
      is_strip = (i >= 5 && FILENAME_CMP (program_name + i - 5, "strip") == 0);
@


1.6.2.3
log
@2000-09-05  Todd Vierling <tv@@wasabisystems.com>
	From 2000-08-14  Todd Vierling <tv@@wasabisystems.com>
	* objcopy.c (strip_main): Silently accept -d as an alias for -g
	for compatability with old BSD systems.

Approved by:  Philip Blundell <pb@@tazenda.demon.co.uk>
              Message-Id: <E13W4ea-0002M7-00@@kings-cross.london.uk.eu.org>
@
text
@d1666 1
a1666 1
  while ((c = getopt_long (argc, argv, "I:O:F:K:N:R:o:sSpdgxXVv",
a1689 1
	case 'd':	/* NetBSD, historic BSD strip */
@


1.5
log
@1999-09-12  Donn Terry  <donn@@interix.com>

	* objcopy.c (parse_flags): Handle "noload", "debug", and "share".
	* binutils.texi, objcopy.1: Document new flags.
@
text
@d296 2
d299 43
a341 24
Usage: %s [-vVSpgxX] [-I bfdname] [-O bfdname] [-F bfdname] [-b byte]\n\
       [-j section] [-R section]\n\
       [-i interleave] [--interleave=interleave] [--byte=byte]\n\
       [--input-target=bfdname] [--output-target=bfdname] [--target=bfdname]\n\
       [--strip-all] [--strip-debug] [--strip-unneeded] [--discard-all]\n\
       [--discard-locals] [--debugging]\n\
       [--only-section=section] [--remove-section=section]\n"),
	   program_name);
  fprintf (stream, _("\
       [--gap-fill=val] [--pad-to=address] [--preserve-dates]\n\
       [--set-start=val] \n\
       [--change-start=incr] [--change-addresses=incr] \n\
       (--adjust-start   and  --adjust-vma are aliases for these two) \n\
       [--change-section-address=section{=,+,-}val]\n\
       (--adjust-section-vma is an alias for --change-section-address)\n\
       [--change-section-lma=section{=,+,-}val]\n\
       [--change-section-vma=section{=,+,-}val]\n\
       [--adjust-warnings] [--no-adjust-warnings]\n\
       [--change-warnings] [--no-change-warnings]\n\
       [--set-section-flags=section=flags] [--add-section=sectionname=filename]\n\
       [--keep-symbol symbol] [-K symbol] [--strip-symbol symbol] [-N symbol]\n\
       [--localize-symbol symbol] [-L symbol] [--weaken-symbol symbol]\n\
       [-W symbol] [--change-leading-char] [--remove-leading-char] [--weaken]\n\
       [--verbose] [--version] [--help] in-file [out-file]\n"));
d353 2
d356 18
a373 7
Usage: %s [-vVsSpgxX] [-I bfdname] [-O bfdname] [-F bfdname] [-R section]\n\
       [--input-target=bfdname] [--output-target=bfdname] [--target=bfdname]\n\
       [--strip-all] [--strip-debug] [--strip-unneeded] [--discard-all]\n\
       [--discard-locals] [--keep-symbol symbol] [-K symbol]\n\
       [--strip-symbol symbol] [-N symbol] [--remove-section=section]\n\
       [-o file] [--preserve-dates] [--verbose] [--version] [--help] file...\n"),
	   program_name);
@


1.4
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Add variable initializations.  Add casts.
	* objdump.c (disassemble_bytes): Change j to bfd_vma.
	* readelf.c (process_syminfo): Change i to unsigned int.
	(display_debug_info): Change abbrev_number to unsigned long.
	(process_mips_specific): Change fcnt to size_t.
@
text
@d375 1
d377 1
d381 1
d392 1
a392 1
	  fatal (_("supported flags: alloc, load, readonly, code, data, rom, contents"));
@


1.3
log
@	Based on patch from H. Peter Anvin <hpa@@transmeta.com>:
	* objcopy.c (struct section_list): Add copy field.
	(sections_copied): New static variable.
	(copy_options): Add "only-section".
	(copy_usage): Mention -j and --only-section.
	(find_section_list): Initialize copy field.
	(is_strip_section): Check for copying sections.
	(copy_object): Check sections_copied when calling filter_symbols.
	(setup_section): Check for copying sections.
	(copy_section): Likewise.
	(copy_main): Handle -j/--only-section.
	* binutils.texi, objcopy.1: Document -j/--only-section.
@
text
@d470 1
a470 1
     bfd *abfd;
d608 1
a608 1
  if (*size % interleave > copy_byte)
d1363 1
a1363 1
     bfd *obfd;
d1470 2
a1471 2
     long *symcountp;
     asymbol ***symppp;
d1810 1
a1810 1
	    char *option;
d1812 1
a1812 1
	    enum change_action what;
d1816 9
a1824 3
	      case OPTION_CHANGE_SECTION_ADDRESS: option = "--change-section-address"; break;
	      case OPTION_CHANGE_SECTION_LMA: option = "--change-section-lma"; break;
	      case OPTION_CHANGE_SECTION_VMA: option = "--change-section-vma"; break;
@


1.2
log
@	* objcopy.c (copy_archive): Preserve dates of archive members if
	requested.
@
text
@d114 1
d125 1
d251 1
d298 2
a299 1
       [-R section] [-i interleave] [--interleave=interleave] [--byte=byte]\n\
d302 2
a303 1
       [--discard-locals] [--debugging] [--remove-section=section]\n"),
d419 1
d483 1
a483 1
  if (! sections_removed)
d485 1
d487 5
a491 1
  return p != NULL && p->remove ? true : false;
d830 1
d1142 3
a1144 1
  if (p != NULL && p->remove)
d1273 3
a1275 1
  if (p != NULL && p->remove)
d1676 1
a1676 1
  while ((c = getopt_long (argc, argv, "b:i:I:K:N:s:O:d:F:L:R:SpgxXVvW:",
d1702 7
d1711 2
@


1.1
log
@Initial revision
@
text
@d965 10
d996 3
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

