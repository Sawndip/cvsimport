head	1.19;
access;
symbols
	binutils-2_24-branch:1.19.0.2
	binutils-2_24-branchpoint:1.19
	binutils-2_21_1:1.16
	binutils-2_23_2:1.18
	binutils-2_23_1:1.18
	binutils-2_23:1.18
	binutils-2_23-branch:1.18.0.2
	binutils-2_23-branchpoint:1.18
	binutils-2_22_branch:1.17.0.4
	binutils-2_22:1.17
	binutils-2_22-branch:1.17.0.2
	binutils-2_22-branchpoint:1.17
	binutils-2_21:1.16
	binutils-2_21-branch:1.16.0.2
	binutils-2_21-branchpoint:1.16
	binutils-2_20_1:1.14
	binutils-2_20:1.14
	binutils-arc-20081103-branch:1.13.0.10
	binutils-arc-20081103-branchpoint:1.13
	binutils-2_20-branch:1.14.0.2
	binutils-2_20-branchpoint:1.14
	dje-cgen-play1-branch:1.13.0.8
	dje-cgen-play1-branchpoint:1.13
	arc-20081103-branch:1.13.0.6
	arc-20081103-branchpoint:1.13
	binutils-2_19_1:1.13
	binutils-2_19:1.13
	binutils-2_19-branch:1.13.0.4
	binutils-2_19-branchpoint:1.13
	binutils-2_18:1.13
	binutils-2_18-branch:1.13.0.2
	binutils-2_18-branchpoint:1.13
	binutils-csl-coldfire-4_1-32:1.9.2.1
	binutils-csl-sourcerygxx-4_1-32:1.9.2.1
	binutils-csl-innovasic-fido-3_4_4-33:1.9.2.1
	binutils-csl-sourcerygxx-3_4_4-32:1.7
	binutils-csl-coldfire-4_1-30:1.9.2.1
	binutils-csl-sourcerygxx-4_1-30:1.9.2.1
	binutils-csl-coldfire-4_1-28:1.9.2.1
	binutils-csl-sourcerygxx-4_1-29:1.9.2.1
	binutils-csl-sourcerygxx-4_1-28:1.9.2.1
	binutils-csl-arm-2006q3-27:1.9.2.1
	binutils-csl-sourcerygxx-4_1-27:1.9.2.1
	binutils-csl-arm-2006q3-26:1.9.2.1
	binutils-csl-sourcerygxx-4_1-26:1.9.2.1
	binutils-csl-sourcerygxx-4_1-25:1.9.2.1
	binutils-csl-sourcerygxx-4_1-24:1.9.2.1
	binutils-csl-sourcerygxx-4_1-23:1.9.2.1
	binutils-csl-sourcerygxx-4_1-21:1.9.2.1
	binutils-csl-arm-2006q3-21:1.9.2.1
	binutils-csl-sourcerygxx-4_1-22:1.9.2.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.9.2.1
	binutils-csl-sourcerygxx-4_1-20:1.9.2.1
	binutils-csl-arm-2006q3-19:1.9.2.1
	binutils-csl-sourcerygxx-4_1-19:1.9.2.1
	binutils-csl-sourcerygxx-4_1-18:1.9.2.1
	binutils-csl-renesas-4_1-9:1.9.2.1
	binutils-csl-sourcerygxx-3_4_4-25:1.7
	binutils-csl-renesas-4_1-8:1.9
	binutils-csl-renesas-4_1-7:1.9
	binutils-csl-renesas-4_1-6:1.9
	binutils-csl-sourcerygxx-4_1-17:1.9
	binutils-csl-sourcerygxx-4_1-14:1.9
	binutils-csl-sourcerygxx-4_1-15:1.9
	binutils-csl-sourcerygxx-4_1-13:1.9
	binutils-2_17:1.10
	binutils-csl-sourcerygxx-4_1-12:1.9
	binutils-csl-sourcerygxx-3_4_4-21:1.9
	binutils-csl-wrs-linux-3_4_4-24:1.7
	binutils-csl-wrs-linux-3_4_4-23:1.7
	binutils-csl-sourcerygxx-4_1-9:1.9
	binutils-csl-sourcerygxx-4_1-8:1.9
	binutils-csl-sourcerygxx-4_1-7:1.9
	binutils-csl-arm-2006q1-6:1.9
	binutils-csl-sourcerygxx-4_1-6:1.9
	binutils-csl-wrs-linux-3_4_4-22:1.7
	binutils-csl-coldfire-4_1-11:1.9
	binutils-csl-sourcerygxx-3_4_4-19:1.9
	binutils-csl-coldfire-4_1-10:1.9
	binutils-csl-sourcerygxx-4_1-5:1.9
	binutils-csl-sourcerygxx-4_1-4:1.9
	binutils-csl-wrs-linux-3_4_4-21:1.7
	binutils-csl-morpho-4_1-4:1.9
	binutils-csl-sourcerygxx-3_4_4-17:1.9
	binutils-csl-wrs-linux-3_4_4-20:1.7
	binutils-2_17-branch:1.10.0.2
	binutils-2_17-branchpoint:1.10
	binutils-csl-2_17-branch:1.9.0.2
	binutils-csl-2_17-branchpoint:1.9
	binutils-csl-gxxpro-3_4-branch:1.7.0.12
	binutils-csl-gxxpro-3_4-branchpoint:1.7
	binutils-2_16_1:1.7
	binutils-csl-arm-2005q1b:1.7
	binutils-2_16:1.7
	binutils-csl-arm-2005q1a:1.7
	binutils-csl-arm-2005q1-branch:1.7.0.10
	binutils-csl-arm-2005q1-branchpoint:1.7
	binutils-2_16-branch:1.7.0.8
	binutils-2_16-branchpoint:1.7
	csl-arm-2004-q3d:1.7
	csl-arm-2004-q3:1.7
	binutils-2_15:1.7
	binutils-2_15-branchpoint:1.7
	csl-arm-2004-q1a:1.7
	csl-arm-2004-q1:1.7
	binutils-2_15-branch:1.7.0.6
	cagney_bfdfile-20040213-branch:1.7.0.4
	cagney_bfdfile-20040213-branchpoint:1.7
	cagney_bigcore-20040122-branch:1.7.0.2
	cagney_bigcore-20040122-branchpoint:1.7
	csl-arm-2003-q4:1.7
	binutils-2_14:1.6
	binutils-2_14-branch:1.6.0.4
	binutils-2_14-branchpoint:1.6
	binutils-2_13_2_1:1.6
	binutils-2_13_2:1.6
	binutils-2_13_1:1.6
	binutils-2_13:1.6
	binutils-2_13-branchpoint:1.6
	binutils-2_13-branch:1.6.0.2
	binutils-2_12_1:1.2.2.1
	binutils-2_12:1.2
	binutils-2_12-branch:1.2.0.2
	binutils-2_12-branchpoint:1.2
	cygnus_cvs_20020108_pre:1.2
	binutils-2_11_2:1.1.1.1.4.1
	binutils-2_11_1:1.1.1.1.4.1
	binutils-2_11:1.1.1.1
	x86_64versiong3:1.1.1.1
	binutils-2_11-branch:1.1.1.1.0.4
	binutils-2_10_1:1.1.1.1
	binutils-2_10:1.1.1.1
	binutils-2_10-branch:1.1.1.1.0.2
	binutils-2_10-branchpoint:1.1.1.1
	binutils_latest_snapshot:1.19
	repo-unification-2000-02-06:1.1.1.1
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.19
date	2012.11.28.15.53.37;	author ktietz;	state Exp;
branches;
next	1.18;

1.18
date	2011.10.11.15.56.28;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2011.02.28.18.32.51;	author ktietz;	state Exp;
branches;
next	1.16;

1.16
date	2010.06.27.04.07.54;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2009.12.11.13.42.06;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2009.09.02.07.22.32;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2007.07.05.16.54.45;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2007.05.23.08.48.29;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2007.04.26.14.46.59;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2006.03.29.00.24.28;	author bje;	state Exp;
branches;
next	1.9;

1.9
date	2005.10.10.15.54.42;	author nickc;	state Exp;
branches
	1.9.2.1;
next	1.8;

1.8
date	2005.05.08.14.17.39;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2003.09.14.12.20.16;	author aj;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.23.04.11.56;	author kazu;	state Exp;
branches;
next	1.5;

1.5
date	2002.04.15.14.12.37;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2002.04.09.17.14.59;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2002.04.09.16.37.20;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	2001.03.13.06.43.58;	author nickc;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	99.05.03.07.29.10;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.9.2.1
date	2006.08.22.15.08.29;	author jsm28;	state Exp;
branches;
next	;

1.2.2.1
date	2002.05.09.11.53.25;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.10;	author rth;	state Exp;
branches
	1.1.1.1.4.1;
next	;

1.1.1.1.4.1
date	2001.06.07.03.12.28;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.19
log
@        * resbin.c (bin_to_res_version):  Correct offset
        and length calculation of resource.
        (get_version_header): Apply alignement of 4 to len.
@
text
@/* resbin.c -- manipulate the Windows binary resource format.
   Copyright 1997, 1998, 1999, 2002, 2003, 2005, 2006, 2007, 2009, 2010, 2011
   Free Software Foundation, Inc.
   Written by Ian Lance Taylor, Cygnus Support.
   Rewritten by Kai Tietz, Onevision.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */


/* This file contains functions to convert between the binary resource
   format and the internal structures that we want to use.  The same
   binary resource format is used in both res and COFF files.  */

#include "sysdep.h"
#include "bfd.h"
#include "bucomm.h"
#include "libiberty.h"
#include "windres.h"

/* Local functions.  */

static void toosmall (const char *);

static unichar *get_unicode (windres_bfd *, const bfd_byte *, rc_uint_type, rc_uint_type *);
static int get_resid (windres_bfd *, rc_res_id *, const bfd_byte *, rc_uint_type);
static rc_res_resource *bin_to_res_generic (windres_bfd *, enum rc_res_type,
					    const bfd_byte *, rc_uint_type);
static rc_res_resource *bin_to_res_cursor (windres_bfd *, const bfd_byte *, rc_uint_type);
static rc_res_resource *bin_to_res_menu (windres_bfd *,const bfd_byte *, rc_uint_type);
static rc_menuitem *bin_to_res_menuitems (windres_bfd *, const bfd_byte *, rc_uint_type,
					  rc_uint_type *);
static rc_menuitem *bin_to_res_menuexitems (windres_bfd *, const bfd_byte *, rc_uint_type,
					    rc_uint_type *);
static rc_res_resource *bin_to_res_dialog (windres_bfd *, const bfd_byte *, rc_uint_type);
static rc_res_resource *bin_to_res_string (windres_bfd *,const bfd_byte *, rc_uint_type);
static rc_res_resource *bin_to_res_fontdir (windres_bfd *, const bfd_byte *, rc_uint_type);
static rc_res_resource *bin_to_res_accelerators (windres_bfd *, const bfd_byte *, rc_uint_type);
static rc_res_resource *bin_to_res_rcdata (windres_bfd *, const bfd_byte *, rc_uint_type, int);
static rc_res_resource *bin_to_res_group_cursor (windres_bfd *, const bfd_byte *, rc_uint_type);
static rc_res_resource *bin_to_res_group_icon (windres_bfd *, const bfd_byte *, rc_uint_type);
static rc_res_resource *bin_to_res_version (windres_bfd *, const bfd_byte *, rc_uint_type);
static rc_res_resource *bin_to_res_userdata (windres_bfd *, const bfd_byte *, rc_uint_type);
static rc_res_resource *bin_to_res_toolbar (windres_bfd *, const bfd_byte *, rc_uint_type);
static void get_version_header (windres_bfd *, const bfd_byte *, rc_uint_type, const char *,
				unichar **, rc_uint_type *, rc_uint_type *, rc_uint_type *,
				rc_uint_type *);

/* Given a resource type ID, a pointer to data, a length, return a
   rc_res_resource structure which represents that resource.  The caller
   is responsible for initializing the res_info and coff_info fields
   of the returned structure.  */

rc_res_resource *
bin_to_res (windres_bfd *wrbfd, rc_res_id type, const bfd_byte *data,
	    rc_uint_type length)
{
  if (type.named)
    return bin_to_res_userdata (wrbfd, data, length);
  else
    {
      switch (type.u.id)
	{
	default:
	  return bin_to_res_userdata (wrbfd, data, length);
	case RT_CURSOR:
	  return bin_to_res_cursor (wrbfd, data, length);
	case RT_BITMAP:
	  return bin_to_res_generic (wrbfd, RES_TYPE_BITMAP, data, length);
	case RT_ICON:
	  return bin_to_res_generic (wrbfd, RES_TYPE_ICON, data, length);
	case RT_MENU:
	  return bin_to_res_menu (wrbfd, data, length);
	case RT_DIALOG:
	  return bin_to_res_dialog (wrbfd, data, length);
	case RT_STRING:
	  return bin_to_res_string (wrbfd, data, length);
	case RT_FONTDIR:
	  return bin_to_res_fontdir (wrbfd, data, length);
	case RT_FONT:
	  return bin_to_res_generic (wrbfd, RES_TYPE_FONT, data, length);
	case RT_ACCELERATOR:
	  return bin_to_res_accelerators (wrbfd, data, length);
	case RT_RCDATA:
	  return bin_to_res_rcdata (wrbfd, data, length, RES_TYPE_RCDATA);
	case RT_MESSAGETABLE:
	  return bin_to_res_generic (wrbfd, RES_TYPE_MESSAGETABLE, data, length);
	case RT_GROUP_CURSOR:
	  return bin_to_res_group_cursor (wrbfd, data, length);
	case RT_GROUP_ICON:
	  return bin_to_res_group_icon (wrbfd, data, length);
	case RT_VERSION:
	  return bin_to_res_version (wrbfd, data, length);
	case RT_TOOLBAR:
	  return  bin_to_res_toolbar (wrbfd, data, length);

	}
    }
}

/* Give an error if the binary data is too small.  */

static void
toosmall (const char *msg)
{
  fatal (_("%s: not enough binary data"), msg);
}

/* Swap in a NULL terminated unicode string.  */

static unichar *
get_unicode (windres_bfd *wrbfd, const bfd_byte *data, rc_uint_type length,
	     rc_uint_type *retlen)
{
  rc_uint_type c, i;
  unichar *ret;

  c = 0;
  while (1)
    {
      if (length < c * 2 + 2)
	toosmall (_("null terminated unicode string"));
      if (windres_get_16 (wrbfd, data + c * 2, 2) == 0)
	break;
      ++c;
    }

  ret = (unichar *) res_alloc ((c + 1) * sizeof (unichar));

  for (i = 0; i < c; i++)
    ret[i] = windres_get_16 (wrbfd, data + i * 2, 2);
  ret[i] = 0;

  if (retlen != NULL)
    *retlen = c;

  return ret;
}

/* Get a resource identifier.  This returns the number of bytes used.  */

static int
get_resid (windres_bfd *wrbfd, rc_res_id *id, const bfd_byte *data,
	   rc_uint_type length)
{
  rc_uint_type first;

  if (length < 2)
    toosmall (_("resource ID"));

  first = windres_get_16 (wrbfd, data, 2);
  if (first == 0xffff)
    {
      if (length < 4)
	toosmall (_("resource ID"));
      id->named = 0;
      id->u.id = windres_get_16 (wrbfd, data + 2, 2);
      return 4;
    }
  else
    {
      id->named = 1;
      id->u.n.name = get_unicode (wrbfd, data, length, &id->u.n.length);
      return id->u.n.length * 2 + 2;
    }
}

/* Convert a resource which just stores uninterpreted data from
   binary.  */

rc_res_resource *
bin_to_res_generic (windres_bfd *wrbfd ATTRIBUTE_UNUSED, enum rc_res_type type,
		    const bfd_byte *data, rc_uint_type length)
{
  rc_res_resource *r;

  r = (rc_res_resource *) res_alloc (sizeof (rc_res_resource));
  r->type = type;
  r->u.data.data = data;
  r->u.data.length = length;

  return r;
}

/* Convert a cursor resource from binary.  */

rc_res_resource *
bin_to_res_cursor (windres_bfd *wrbfd, const bfd_byte *data, rc_uint_type length)
{
  rc_cursor *c;
  rc_res_resource *r;

  if (length < 4)
    toosmall (_("cursor"));

  c = (rc_cursor *) res_alloc (sizeof (rc_cursor));
  c->xhotspot = windres_get_16 (wrbfd, data, 2);
  c->yhotspot = windres_get_16 (wrbfd, data + 2, 2);
  c->length = length - 4;
  c->data = data + 4;

  r = (rc_res_resource *) res_alloc (sizeof *r);
  r->type = RES_TYPE_CURSOR;
  r->u.cursor = c;

  return r;
}

/* Convert a menu resource from binary.  */

rc_res_resource *
bin_to_res_menu (windres_bfd *wrbfd, const bfd_byte *data, rc_uint_type length)
{
  rc_res_resource *r;
  rc_menu *m;
  rc_uint_type version, got;

  r = (rc_res_resource *) res_alloc (sizeof *r);
  r->type = RES_TYPE_MENU;

  m = (rc_menu *) res_alloc (sizeof (rc_menu));
  r->u.menu = m;

  if (length < 2)
    toosmall (_("menu header"));

  version = windres_get_16 (wrbfd, data, 2);

  if (version == 0)
    {
      if (length < 4)
	toosmall (_("menu header"));
      m->help = 0;
      m->items = bin_to_res_menuitems (wrbfd, data + 4, length - 4, &got);
    }
  else if (version == 1)
    {
      rc_uint_type offset;

      if (length < 8)
	toosmall (_("menuex header"));
      m->help = windres_get_32 (wrbfd, data + 4, 4);
      offset = windres_get_16 (wrbfd, data + 2, 2);
      if (offset + 4 >= length)
	toosmall (_("menuex offset"));
      m->items = bin_to_res_menuexitems (wrbfd, data + 4 + offset,
					 length - (4 + offset), &got);
    }
  else
    fatal (_("unsupported menu version %d"), (int) version);

  return r;
}

/* Convert menu items from binary.  */

static rc_menuitem *
bin_to_res_menuitems (windres_bfd *wrbfd, const bfd_byte *data, rc_uint_type length,
		      rc_uint_type *got)
{
  rc_menuitem *first, **pp;

  first = NULL;
  pp = &first;

  *got = 0;

  while (length > 0)
    {
      rc_uint_type flags, slen, itemlen;
      rc_uint_type stroff;
      rc_menuitem *mi;

      if (length < 4)
	toosmall (_("menuitem header"));

      mi = (rc_menuitem *) res_alloc (sizeof *mi);
      mi->state = 0;
      mi->help = 0;

      flags = windres_get_16 (wrbfd, data, 2);
      mi->type = flags &~ (MENUITEM_POPUP | MENUITEM_ENDMENU);

      if ((flags & MENUITEM_POPUP) == 0)
	stroff = 4;
      else
	stroff = 2;

      if (length < stroff + 2)
	toosmall (_("menuitem header"));

      if (windres_get_16 (wrbfd, data + stroff, 2) == 0)
	{
	  slen = 0;
	  mi->text = NULL;
	}
      else
	mi->text = get_unicode (wrbfd, data + stroff, length - stroff, &slen);

      itemlen = stroff + slen * 2 + 2;

      if ((flags & MENUITEM_POPUP) == 0)
	{
	  mi->popup = NULL;
	  mi->id = windres_get_16 (wrbfd, data + 2, 2);
	}
      else
	{
	  rc_uint_type subread;

	  mi->id = 0;
	  mi->popup = bin_to_res_menuitems (wrbfd, data + itemlen, length - itemlen,
	  				    &subread);
	  itemlen += subread;
	}

      mi->next = NULL;
      *pp = mi;
      pp = &mi->next;

      data += itemlen;
      length -= itemlen;
      *got += itemlen;

      if ((flags & MENUITEM_ENDMENU) != 0)
	return first;
    }

  return first;
}

/* Convert menuex items from binary.  */

static rc_menuitem *
bin_to_res_menuexitems (windres_bfd *wrbfd, const bfd_byte *data, rc_uint_type length,
			rc_uint_type *got)
{
  rc_menuitem *first, **pp;

  first = NULL;
  pp = &first;

  *got = 0;

  while (length > 0)
    {
      rc_uint_type flags, slen;
      rc_uint_type itemlen;
      rc_menuitem *mi;

      if (length < 16)
	toosmall (_("menuitem header"));

      mi = (rc_menuitem *) res_alloc (sizeof (rc_menuitem));
      mi->type = windres_get_32 (wrbfd, data, 4);
      mi->state = windres_get_32 (wrbfd, data + 4, 4);
      mi->id = windres_get_32 (wrbfd, data + 8, 4);

      flags = windres_get_16 (wrbfd, data + 12, 2);

      if (windres_get_16 (wrbfd, data + 14, 2) == 0)
	{
	  slen = 0;
	  mi->text = NULL;
	}
      else
	mi->text = get_unicode (wrbfd, data + 14, length - 14, &slen);

      itemlen = 14 + slen * 2 + 2;
      itemlen = (itemlen + 3) &~ 3;

      if ((flags & 1) == 0)
	{
	  mi->popup = NULL;
	  mi->help = 0;
	}
      else
	{
	  rc_uint_type subread;

	  if (length < itemlen + 4)
	    toosmall (_("menuitem"));
	  mi->help = windres_get_32 (wrbfd, data + itemlen, 4);
	  itemlen += 4;

	  mi->popup = bin_to_res_menuexitems (wrbfd, data + itemlen,
					      length - itemlen, &subread);
	  itemlen += subread;
	}

      mi->next = NULL;
      *pp = mi;
      pp = &mi->next;

      data += itemlen;
      length -= itemlen;
      *got += itemlen;

      if ((flags & 0x80) != 0)
	return first;
    }

  return first;
}

/* Convert a dialog resource from binary.  */

static rc_res_resource *
bin_to_res_dialog (windres_bfd *wrbfd, const bfd_byte *data, rc_uint_type length)
{
  rc_uint_type signature;
  rc_dialog *d;
  rc_uint_type c, sublen, i;
  rc_uint_type off;
  rc_dialog_control **pp;
  rc_res_resource *r;

  if (length < 18)
    toosmall (_("dialog header"));

  d = (rc_dialog *) res_alloc (sizeof (rc_dialog));

  signature = windres_get_16 (wrbfd, data + 2, 2);
  if (signature != 0xffff)
    {
      d->ex = NULL;
      d->style = windres_get_32 (wrbfd, data, 4);
      d->exstyle = windres_get_32 (wrbfd, data + 4, 4);
      off = 8;
    }
  else
    {
      int version;

      version = windres_get_16 (wrbfd, data, 2);
      if (version != 1)
	fatal (_("unexpected DIALOGEX version %d"), version);

      d->ex = (rc_dialog_ex *) res_alloc (sizeof (rc_dialog_ex));
      d->ex->help = windres_get_32 (wrbfd, data + 4, 4);
      d->exstyle = windres_get_32 (wrbfd, data + 8, 4);
      d->style = windres_get_32 (wrbfd, data + 12, 4);
      off = 16;
    }

  if (length < off + 10)
    toosmall (_("dialog header"));

  c = windres_get_16 (wrbfd, data + off, 2);
  d->x = windres_get_16 (wrbfd, data + off + 2, 2);
  d->y = windres_get_16 (wrbfd, data + off + 4, 2);
  d->width = windres_get_16 (wrbfd, data + off + 6, 2);
  d->height = windres_get_16 (wrbfd, data + off + 8, 2);

  off += 10;

  sublen = get_resid (wrbfd, &d->menu, data + off, length - off);
  off += sublen;

  sublen = get_resid (wrbfd, &d->class, data + off, length - off);
  off += sublen;

  d->caption = get_unicode (wrbfd, data + off, length - off, &sublen);
  off += sublen * 2 + 2;
  if (sublen == 0)
    d->caption = NULL;

  if ((d->style & DS_SETFONT) == 0)
    {
      d->pointsize = 0;
      d->font = NULL;
      if (d->ex != NULL)
	{
	  d->ex->weight = 0;
	  d->ex->italic = 0;
	  d->ex->charset = 1; /* Default charset.  */
	}
    }
  else
    {
      if (length < off + 2)
	toosmall (_("dialog font point size"));

      d->pointsize = windres_get_16 (wrbfd, data + off, 2);
      off += 2;

      if (d->ex != NULL)
	{
	  if (length < off + 4)
	    toosmall (_("dialogex font information"));
	  d->ex->weight = windres_get_16 (wrbfd, data + off, 2);
	  d->ex->italic = windres_get_8 (wrbfd, data + off + 2, 1);
	  d->ex->charset = windres_get_8 (wrbfd, data + off + 3, 1);
	  off += 4;
	}

      d->font = get_unicode (wrbfd, data + off, length - off, &sublen);
      off += sublen * 2 + 2;
    }

  d->controls = NULL;
  pp = &d->controls;

  for (i = 0; i < c; i++)
    {
      rc_dialog_control *dc;
      int datalen;

      off = (off + 3) &~ 3;

      dc = (rc_dialog_control *) res_alloc (sizeof (rc_dialog_control));

      if (d->ex == NULL)
	{
	  if (length < off + 8)
	    toosmall (_("dialog control"));

	  dc->style = windres_get_32 (wrbfd, data + off, 4);
	  dc->exstyle = windres_get_32 (wrbfd, data + off + 4, 4);
	  dc->help = 0;
	  off += 8;
	}
      else
	{
	  if (length < off + 12)
	    toosmall (_("dialogex control"));
	  dc->help = windres_get_32 (wrbfd, data + off, 4);
	  dc->exstyle = windres_get_32 (wrbfd, data + off + 4, 4);
	  dc->style = windres_get_32 (wrbfd, data + off + 8, 4);
	  off += 12;
	}

      if (length < off + (d->ex != NULL ? 2 : 0) + 10)
	toosmall (_("dialog control"));

      dc->x = windres_get_16 (wrbfd, data + off, 2);
      dc->y = windres_get_16 (wrbfd, data + off + 2, 2);
      dc->width = windres_get_16 (wrbfd, data + off + 4, 2);
      dc->height = windres_get_16 (wrbfd, data + off + 6, 2);

      if (d->ex != NULL)
	dc->id = windres_get_32 (wrbfd, data + off + 8, 4);
      else
	dc->id = windres_get_16 (wrbfd, data + off + 8, 2);

      off += 10 + (d->ex != NULL ? 2 : 0);

      sublen = get_resid (wrbfd, &dc->class, data + off, length - off);
      off += sublen;

      sublen = get_resid (wrbfd, &dc->text, data + off, length - off);
      off += sublen;

      if (length < off + 2)
	toosmall (_("dialog control end"));

      datalen = windres_get_16 (wrbfd, data + off, 2);
      off += 2;

      if (datalen == 0)
	dc->data = NULL;
      else
	{
	  off = (off + 3) &~ 3;

	  if (length < off + datalen)
	    toosmall (_("dialog control data"));

	  dc->data = ((rc_rcdata_item *)
		      res_alloc (sizeof (rc_rcdata_item)));
	  dc->data->next = NULL;
	  dc->data->type = RCDATA_BUFFER;
	  dc->data->u.buffer.length = datalen;
	  dc->data->u.buffer.data = data + off;

	  off += datalen;
	}

      dc->next = NULL;
      *pp = dc;
      pp = &dc->next;
    }

  r = (rc_res_resource *) res_alloc (sizeof *r);
  r->type = RES_TYPE_DIALOG;
  r->u.dialog = d;

  return r;
}

/* Convert a stringtable resource from binary.  */

static rc_res_resource *
bin_to_res_string (windres_bfd *wrbfd, const bfd_byte *data, rc_uint_type length)
{
  rc_stringtable *st;
  int i;
  rc_res_resource *r;

  st = (rc_stringtable *) res_alloc (sizeof (rc_stringtable));

  for (i = 0; i < 16; i++)
    {
      unsigned int slen;

      if (length < 2)
	toosmall (_("stringtable string length"));
      slen = windres_get_16 (wrbfd, data, 2);
      st->strings[i].length = slen;

      if (slen > 0)
	{
	  unichar *s;
	  unsigned int j;

	  if (length < 2 + 2 * slen)
	    toosmall (_("stringtable string"));

	  s = (unichar *) res_alloc (slen * sizeof (unichar));
	  st->strings[i].string = s;

	  for (j = 0; j < slen; j++)
	    s[j] = windres_get_16 (wrbfd, data + 2 + j * 2, 2);
	}

      data += 2 + 2 * slen;
      length -= 2 + 2 * slen;
    }

  r = (rc_res_resource *) res_alloc (sizeof *r);
  r->type = RES_TYPE_STRINGTABLE;
  r->u.stringtable = st;

  return r;
}

/* Convert a fontdir resource from binary.  */

static rc_res_resource *
bin_to_res_fontdir (windres_bfd *wrbfd, const bfd_byte *data, rc_uint_type length)
{
  rc_uint_type c, i;
  rc_fontdir *first, **pp;
  rc_res_resource *r;

  if (length < 2)
    toosmall (_("fontdir header"));

  c = windres_get_16 (wrbfd, data, 2);

  first = NULL;
  pp = &first;

  for (i = 0; i < c; i++)
    {
      const struct bin_fontdir_item *bfi;
      rc_fontdir *fd;
      unsigned int off;

      if (length < 56)
	toosmall (_("fontdir"));

      bfi = (const struct bin_fontdir_item *) data;
      fd = (rc_fontdir *) res_alloc (sizeof *fd);
      fd->index = windres_get_16 (wrbfd, bfi->index, 2);

      /* To work out the length of the fontdir data, we must get the
         length of the device name and face name strings, even though
         we don't store them in the rc_fontdir.  The
         documentation says that these are NULL terminated char
         strings, not Unicode strings.  */

      off = 56;

      while (off < length && data[off] != '\0')
	++off;
      if (off >= length)
	toosmall (_("fontdir device name"));
      ++off;

      while (off < length && data[off] != '\0')
	++off;
      if (off >= length)
	toosmall (_("fontdir face name"));
      ++off;

      fd->length = off;
      fd->data = data;

      fd->next = NULL;
      *pp = fd;
      pp = &fd->next;

      /* The documentation does not indicate that any rounding is
         required.  */

      data += off;
      length -= off;
    }

  r = (rc_res_resource *) res_alloc (sizeof *r);
  r->type = RES_TYPE_FONTDIR;
  r->u.fontdir = first;

  return r;
}

/* Convert an accelerators resource from binary.  */

static rc_res_resource *
bin_to_res_accelerators (windres_bfd *wrbfd, const bfd_byte *data, rc_uint_type length)
{
  rc_accelerator *first, **pp;
  rc_res_resource *r;

  first = NULL;
  pp = &first;

  while (1)
    {
      rc_accelerator *a;

      if (length < 8)
	toosmall (_("accelerator"));

      a = (rc_accelerator *) res_alloc (sizeof (rc_accelerator));

      a->flags = windres_get_16 (wrbfd, data, 2);
      a->key = windres_get_16 (wrbfd, data + 2, 2);
      a->id = windres_get_16 (wrbfd, data + 4, 2);

      a->next = NULL;
      *pp = a;
      pp = &a->next;

      if ((a->flags & ACC_LAST) != 0)
	break;

      data += 8;
      length -= 8;
    }

  r = (rc_res_resource *) res_alloc (sizeof (rc_res_resource));
  r->type = RES_TYPE_ACCELERATOR;
  r->u.acc = first;

  return r;
}

/* Convert an rcdata resource from binary.  */

static rc_res_resource *
bin_to_res_rcdata (windres_bfd *wrbfd ATTRIBUTE_UNUSED, const bfd_byte *data,
		   rc_uint_type length, int rctyp)
{
  rc_rcdata_item *ri;
  rc_res_resource *r;

  ri = (rc_rcdata_item *) res_alloc (sizeof (rc_rcdata_item));

  ri->next = NULL;
  ri->type = RCDATA_BUFFER;
  ri->u.buffer.length = length;
  ri->u.buffer.data = data;

  r = (rc_res_resource *) res_alloc (sizeof *r);
  r->type = rctyp;
  r->u.rcdata = ri;

  return r;
}

/* Convert a group cursor resource from binary.  */

static rc_res_resource *
bin_to_res_group_cursor (windres_bfd *wrbfd, const bfd_byte *data, rc_uint_type length)
{
  int type, c, i;
  rc_group_cursor *first, **pp;
  rc_res_resource *r;

  if (length < 6)
    toosmall (_("group cursor header"));

  type = windres_get_16 (wrbfd, data + 2, 2);
  if (type != 2)
    fatal (_("unexpected group cursor type %d"), type);

  c = windres_get_16 (wrbfd, data + 4, 2);

  data += 6;
  length -= 6;

  first = NULL;
  pp = &first;

  for (i = 0; i < c; i++)
    {
      rc_group_cursor *gc;

      if (length < 14)
	toosmall (_("group cursor"));

      gc = (rc_group_cursor *) res_alloc (sizeof *gc);

      gc->width = windres_get_16 (wrbfd, data, 2);
      gc->height = windres_get_16 (wrbfd, data + 2, 2);
      gc->planes = windres_get_16 (wrbfd, data + 4, 2);
      gc->bits = windres_get_16 (wrbfd, data + 6, 2);
      gc->bytes = windres_get_32 (wrbfd, data + 8, 4);
      gc->index = windres_get_16 (wrbfd, data + 12, 2);

      gc->next = NULL;
      *pp = gc;
      pp = &gc->next;

      data += 14;
      length -= 14;
    }

  r = (rc_res_resource *) res_alloc (sizeof (rc_res_resource));
  r->type = RES_TYPE_GROUP_CURSOR;
  r->u.group_cursor = first;

  return r;
}

/* Convert a group icon resource from binary.  */

static rc_res_resource *
bin_to_res_group_icon (windres_bfd *wrbfd, const bfd_byte *data, rc_uint_type length)
{
  int type, c, i;
  rc_group_icon *first, **pp;
  rc_res_resource *r;

  if (length < 6)
    toosmall (_("group icon header"));

  type = windres_get_16 (wrbfd, data + 2, 2);
  if (type != 1)
    fatal (_("unexpected group icon type %d"), type);

  c = windres_get_16 (wrbfd, data + 4, 2);

  data += 6;
  length -= 6;

  first = NULL;
  pp = &first;

  for (i = 0; i < c; i++)
    {
      rc_group_icon *gi;

      if (length < 14)
	toosmall (_("group icon"));

      gi = (rc_group_icon *) res_alloc (sizeof (rc_group_icon));

      gi->width = windres_get_8 (wrbfd, data, 1);
      gi->height = windres_get_8 (wrbfd, data + 1, 1);
      gi->colors = windres_get_8 (wrbfd, data + 2, 1);
      gi->planes = windres_get_16 (wrbfd, data + 4, 2);
      gi->bits = windres_get_16 (wrbfd, data + 6, 2);
      gi->bytes = windres_get_32 (wrbfd, data + 8, 4);
      gi->index = windres_get_16 (wrbfd, data + 12, 2);

      gi->next = NULL;
      *pp = gi;
      pp = &gi->next;

      data += 14;
      length -= 14;
    }

  r = (rc_res_resource *) res_alloc (sizeof *r);
  r->type = RES_TYPE_GROUP_ICON;
  r->u.group_icon = first;

  return r;
}

/* Extract data from a version header.  If KEY is not NULL, then the
   key must be KEY; otherwise, the key is returned in *PKEY.  This
   sets *LEN to the total length, *VALLEN to the value length, *TYPE
   to the type, and *OFF to the offset to the children.  */

static void
get_version_header (windres_bfd *wrbfd, const bfd_byte *data, rc_uint_type length,
		    const char *key, unichar **pkey,
		    rc_uint_type *len, rc_uint_type *vallen, rc_uint_type *type,
		    rc_uint_type *off)
{
  if (length < 8)
    toosmall (key);

  *len = (windres_get_16 (wrbfd, data, 2) + 3) & ~3;
  *vallen = windres_get_16 (wrbfd, data + 2, 2);
  *type = windres_get_16 (wrbfd, data + 4, 2);

  *off = 6;

  length -= 6;
  data += 6;

  if (key == NULL)
    {
      rc_uint_type sublen;

      *pkey = get_unicode (wrbfd, data, length, &sublen);
      *off += (sublen + 1) * sizeof (unichar);
    }
  else
    {
      while (1)
	{
	  if (length < 2)
	    toosmall (key);
	  if (windres_get_16 (wrbfd, data, 2) != (bfd_byte) *key)
	    fatal (_("unexpected version string"));

	  *off += 2;
	  length -= 2;
	  data += 2;

	  if (*key == '\0')
	    break;

	  ++key;
	}
    }

  *off = (*off + 3) &~ 3;
}

/* Convert a version resource from binary.  */

static rc_res_resource *
bin_to_res_version (windres_bfd *wrbfd, const bfd_byte *data, rc_uint_type length)
{
  rc_uint_type verlen, vallen, type, off;
  rc_fixed_versioninfo *fi;
  rc_ver_info *first, **pp;
  rc_versioninfo *v;
  rc_res_resource *r;

  get_version_header (wrbfd, data, length, "VS_VERSION_INFO",
		      (unichar **) NULL, &verlen, &vallen, &type, &off);

  if ((unsigned int) verlen != length)
    fatal (_("version length %d does not match resource length %lu"),
	   (int) verlen, (unsigned long) length);

  if (type != 0)
    fatal (_("unexpected version type %d"), (int) type);

  data += off;
  length -= off;

  if (vallen == 0)
    fi = NULL;
  else
    {
      unsigned long signature, fiv;

      if (vallen != 52)
	fatal (_("unexpected fixed version information length %ld"), (long) vallen);

      if (length < 52)
	toosmall (_("fixed version info"));

      signature = windres_get_32 (wrbfd, data, 4);
      if (signature != 0xfeef04bd)
	fatal (_("unexpected fixed version signature %lu"), signature);

      fiv = windres_get_32 (wrbfd, data + 4, 4);
      if (fiv != 0 && fiv != 0x10000)
	fatal (_("unexpected fixed version info version %lu"), fiv);

      fi = (rc_fixed_versioninfo *) res_alloc (sizeof (rc_fixed_versioninfo));

      fi->file_version_ms = windres_get_32 (wrbfd, data + 8, 4);
      fi->file_version_ls = windres_get_32 (wrbfd, data + 12, 4);
      fi->product_version_ms = windres_get_32 (wrbfd, data + 16, 4);
      fi->product_version_ls = windres_get_32 (wrbfd, data + 20, 4);
      fi->file_flags_mask = windres_get_32 (wrbfd, data + 24, 4);
      fi->file_flags = windres_get_32 (wrbfd, data + 28, 4);
      fi->file_os = windres_get_32 (wrbfd, data + 32, 4);
      fi->file_type = windres_get_32 (wrbfd, data + 36, 4);
      fi->file_subtype = windres_get_32 (wrbfd, data + 40, 4);
      fi->file_date_ms = windres_get_32 (wrbfd, data + 44, 4);
      fi->file_date_ls = windres_get_32 (wrbfd, data + 48, 4);

      data += 52;
      length -= 52;
    }

  first = NULL;
  pp = &first;

  while (length > 0)
    {
      rc_ver_info *vi;
      int ch;

      if (length < 8)
	toosmall (_("version var info"));

      vi = (rc_ver_info *) res_alloc (sizeof (rc_ver_info));

      ch = windres_get_16 (wrbfd, data + 6, 2);

      if (ch == 'S')
	{
	  rc_ver_stringtable **ppvst;

	  vi->type = VERINFO_STRING;

	  get_version_header (wrbfd, data, length, "StringFileInfo",
			      (unichar **) NULL, &verlen, &vallen, &type,
			      &off);

	  if (vallen != 0)
	    fatal (_("unexpected stringfileinfo value length %ld"), (long) vallen);

	  data += off;
	  length -= off;

	  verlen -= off;

	  vi->u.string.stringtables = NULL;
	  ppvst = &vi->u.string.stringtables;

	  while (verlen > 0)
	    {
	      rc_ver_stringtable *vst;
	      rc_uint_type stverlen;
	      rc_ver_stringinfo **ppvs;

	      if (length < 8)
		toosmall (_("version stringtable"));

	      vst = (rc_ver_stringtable *) res_alloc (sizeof (rc_ver_stringtable));

	      get_version_header (wrbfd, data, length, (const char *) NULL,
				  &vst->language, &stverlen, &vallen, &type, &off);

	      if (vallen != 0)
		fatal (_("unexpected version stringtable value length %ld"), (long) vallen);

	      data += off;
	      length -= off;
	      verlen -= off;

	  stverlen -= off;
 
	  vst->strings = NULL;
	  ppvs = &vst->strings;

	  while (stverlen > 0)
	    {
	      rc_ver_stringinfo *vs;
	      rc_uint_type sverlen, vslen, valoff;

	      if (length < 8)
		toosmall (_("version string"));

	      vs = (rc_ver_stringinfo *) res_alloc (sizeof (rc_ver_stringinfo));

	      get_version_header (wrbfd, data, length, (const char *) NULL,
				  &vs->key, &sverlen, &vallen, &type, &off);

	      data += off;
	      length -= off;

	      vs->value = get_unicode (wrbfd, data, length, &vslen);
	      valoff = vslen * 2 + 2;
	      valoff = (valoff + 3) & ~3;

	      if (off + valoff != sverlen)
		fatal (_("unexpected version string length %ld != %ld + %ld"),
		       (long) sverlen, (long) off, (long) valoff);

	      data += valoff;
	      length -= valoff;

	      if (stverlen < sverlen)
		fatal (_("unexpected version string length %ld < %ld"),
		       (long) verlen, (long) sverlen);
	      stverlen -= sverlen;
	      verlen -= sverlen;

	      vs->next = NULL;
	      *ppvs = vs;
	      ppvs = &vs->next;
	    }

	  vst->next = NULL;
	  *ppvst = vst;
	  ppvst = &vst->next;
	    }
	}
      else if (ch == 'V')
	{
	  rc_ver_varinfo **ppvv;

	  vi->type = VERINFO_VAR;

	  get_version_header (wrbfd, data, length, "VarFileInfo",
			      (unichar **) NULL, &verlen, &vallen, &type,
			      &off);

	  if (vallen != 0)
	    fatal (_("unexpected varfileinfo value length %ld"), (long) vallen);

	  data += off;
	  length -= off;

	  get_version_header (wrbfd, data, length, (const char *) NULL,
			      &vi->u.var.key, &verlen, &vallen, &type, &off);

	  data += off;
	  length -= off;

	  vi->u.var.var = NULL;
	  ppvv = &vi->u.var.var;

	  while (vallen > 0)
	    {
	      rc_ver_varinfo *vv;

	      if (length < 4)
		toosmall (_("version varfileinfo"));

	      vv = (rc_ver_varinfo *) res_alloc (sizeof (rc_ver_varinfo));

	      vv->language = windres_get_16 (wrbfd, data, 2);
	      vv->charset = windres_get_16 (wrbfd, data + 2, 2);

	      vv->next = NULL;
	      *ppvv = vv;
	      ppvv = &vv->next;

	      data += 4;
	      length -= 4;

	      if (vallen < 4)
		fatal (_("unexpected version value length %ld"), (long) vallen);

	      vallen -= 4;
	    }
	}
      else
	fatal (_("unexpected version string"));

      vi->next = NULL;
      *pp = vi;
      pp = &vi->next;
    }

  v = (rc_versioninfo *) res_alloc (sizeof (rc_versioninfo));
  v->fixed = fi;
  v->var = first;

  r = (rc_res_resource *) res_alloc (sizeof *r);
  r->type = RES_TYPE_VERSIONINFO;
  r->u.versioninfo = v;

  return r;
}

/* Convert an arbitrary user defined resource from binary.  */

static rc_res_resource *
bin_to_res_userdata (windres_bfd *wrbfd ATTRIBUTE_UNUSED, const bfd_byte *data,
		     rc_uint_type length)
{
  rc_rcdata_item *ri;
  rc_res_resource *r;

  ri = (rc_rcdata_item *) res_alloc (sizeof (rc_rcdata_item));

  ri->next = NULL;
  ri->type = RCDATA_BUFFER;
  ri->u.buffer.length = length;
  ri->u.buffer.data = data;

  r = (rc_res_resource *) res_alloc (sizeof *r);
  r->type = RES_TYPE_USERDATA;
  r->u.rcdata = ri;

  return r;
}

static rc_res_resource *
bin_to_res_toolbar (windres_bfd *wrbfd, const bfd_byte *data, rc_uint_type length)
{
  rc_toolbar *ri;
  rc_res_resource *r;
  rc_uint_type i;

  ri = (rc_toolbar *) res_alloc (sizeof (rc_toolbar));
  ri->button_width = windres_get_32 (wrbfd, data, 4);
  ri->button_height = windres_get_32 (wrbfd, data + 4, 4);
  ri->nitems = windres_get_32 (wrbfd, data + 8, 4);
  ri->items = NULL;

  data += 12;
  length -= 12;
  for (i=0 ; i < ri->nitems; i++)
  {
    rc_toolbar_item *it;
    it = (rc_toolbar_item *) res_alloc (sizeof (rc_toolbar_item));
    it->id.named = 0;
    it->id.u.id = (int) windres_get_32 (wrbfd, data, 4);
    it->prev = it->next = NULL;
    data += 4;
    length -= 4;
    if(ri->items) {
      rc_toolbar_item *ii = ri->items;
      while (ii->next != NULL)
	ii = ii->next;
      it->prev = ii;
      ii->next = it;
    }
    else
      ri->items = it;
  }
  r = (rc_res_resource *) res_alloc (sizeof *r);
  r->type = RES_TYPE_TOOLBAR;
  r->u.toolbar = ri;
  return r;
}


/* Local functions used to convert resources to binary format.  */

static rc_uint_type resid_to_bin (windres_bfd *, rc_uint_type, rc_res_id);
static rc_uint_type unicode_to_bin (windres_bfd *, rc_uint_type, const unichar *);
static rc_uint_type res_to_bin_accelerator (windres_bfd *, rc_uint_type, const rc_accelerator *);
static rc_uint_type res_to_bin_cursor (windres_bfd *, rc_uint_type, const rc_cursor *);
static rc_uint_type res_to_bin_group_cursor (windres_bfd *, rc_uint_type, const rc_group_cursor *);
static rc_uint_type res_to_bin_dialog (windres_bfd *, rc_uint_type, const rc_dialog *);
static rc_uint_type res_to_bin_fontdir (windres_bfd *, rc_uint_type, const rc_fontdir *);
static rc_uint_type res_to_bin_group_icon (windres_bfd *, rc_uint_type, const rc_group_icon *);
static rc_uint_type res_to_bin_menu (windres_bfd *, rc_uint_type, const rc_menu *);
static rc_uint_type res_to_bin_menuitems (windres_bfd *, rc_uint_type, const rc_menuitem *);
static rc_uint_type res_to_bin_menuexitems (windres_bfd *, rc_uint_type, const rc_menuitem *);
static rc_uint_type res_to_bin_rcdata (windres_bfd *, rc_uint_type, const rc_rcdata_item *);
static rc_uint_type res_to_bin_stringtable (windres_bfd *, rc_uint_type, const rc_stringtable *);
static rc_uint_type string_to_unicode_bin (windres_bfd *, rc_uint_type, const char *);
static rc_uint_type res_to_bin_toolbar (windres_bfd *, rc_uint_type, rc_toolbar *tb);
static rc_uint_type res_to_bin_versioninfo (windres_bfd *, rc_uint_type, const rc_versioninfo *);
static rc_uint_type res_to_bin_generic (windres_bfd *, rc_uint_type, rc_uint_type,
					const bfd_byte *);

/* Convert a resource to binary.  */

rc_uint_type
res_to_bin (windres_bfd *wrbfd, rc_uint_type off, const rc_res_resource *res)
{
  switch (res->type)
    {
    case RES_TYPE_BITMAP:
    case RES_TYPE_FONT:
    case RES_TYPE_ICON:
    case RES_TYPE_MESSAGETABLE:
      return res_to_bin_generic (wrbfd, off, res->u.data.length, res->u.data.data);
    case RES_TYPE_ACCELERATOR:
      return res_to_bin_accelerator (wrbfd, off, res->u.acc);
    case RES_TYPE_CURSOR:
      return res_to_bin_cursor (wrbfd, off, res->u.cursor);
    case RES_TYPE_GROUP_CURSOR:
      return res_to_bin_group_cursor (wrbfd, off, res->u.group_cursor);
    case RES_TYPE_DIALOG:
      return res_to_bin_dialog (wrbfd, off, res->u.dialog);
    case RES_TYPE_FONTDIR:
      return res_to_bin_fontdir (wrbfd, off, res->u.fontdir);
    case RES_TYPE_GROUP_ICON:
      return res_to_bin_group_icon (wrbfd, off, res->u.group_icon);
    case RES_TYPE_MENU:
      return res_to_bin_menu (wrbfd, off, res->u.menu);
    case RES_TYPE_STRINGTABLE:
      return res_to_bin_stringtable (wrbfd, off, res->u.stringtable);
    case RES_TYPE_VERSIONINFO:
      return res_to_bin_versioninfo (wrbfd, off, res->u.versioninfo);
    case RES_TYPE_TOOLBAR:
      return res_to_bin_toolbar (wrbfd, off, res->u.toolbar);
    case RES_TYPE_USERDATA:
    case RES_TYPE_RCDATA:
    default:
      return res_to_bin_rcdata (wrbfd, off, res->u.rcdata);
    }
}

/* Convert a resource ID to binary.  This always returns exactly one
   bindata structure.  */

static rc_uint_type
resid_to_bin (windres_bfd *wrbfd, rc_uint_type off, rc_res_id id)
{
  if (! id.named)
    {
      if (wrbfd)
	{
	  struct bin_res_id bri;
	  
	  windres_put_16 (wrbfd, bri.sig, 0xffff);
	  windres_put_16 (wrbfd, bri.id, id.u.id);
	  set_windres_bfd_content (wrbfd, &bri, off, BIN_RES_ID);
	}
      off += BIN_RES_ID;
    }
  else
    {
      rc_uint_type len = (id.u.n.name ? unichar_len (id.u.n.name) : 0);
      if (wrbfd)
	{
	  bfd_byte *d = (bfd_byte *) reswr_alloc ((len + 1) * sizeof (unichar));
	  rc_uint_type i;
	  for (i = 0; i < len; i++)
	    windres_put_16 (wrbfd, d + (i * sizeof (unichar)), id.u.n.name[i]);
	  windres_put_16 (wrbfd, d + (len * sizeof (unichar)), 0);
	  set_windres_bfd_content (wrbfd, d, off, (len + 1) * sizeof (unichar));
    }
      off += (rc_uint_type) ((len + 1) * sizeof (unichar));
    }
  return off;
}

/* Convert a null terminated unicode string to binary.  This always
   returns exactly one bindata structure.  */

static rc_uint_type
unicode_to_bin (windres_bfd *wrbfd, rc_uint_type off, const unichar *str)
{
  rc_uint_type len = 0;

  if (str != NULL)
    len = unichar_len (str);

  if (wrbfd)
    {
      bfd_byte *d;
      rc_uint_type i;
      d = (bfd_byte *) reswr_alloc ( (len + 1) * sizeof (unichar));
      for (i = 0; i < len; i++)
	windres_put_16 (wrbfd, d + (i * sizeof (unichar)), str[i]);
      windres_put_16 (wrbfd, d + (len * sizeof (unichar)), 0);
      set_windres_bfd_content (wrbfd, d, off, (len + 1) * sizeof (unichar));
    }
  off += (rc_uint_type) ((len + 1) * sizeof (unichar));

  return off;
}

/* Convert an accelerator resource to binary.  */

static rc_uint_type
res_to_bin_accelerator (windres_bfd *wrbfd, rc_uint_type off,
			const rc_accelerator *accelerators)
{
  const rc_accelerator *a;

  for (a = accelerators; a != NULL; a = a->next)
    {
      if (wrbfd)
	{
	  struct bin_accelerator ba;

	  windres_put_16 (wrbfd, ba.flags, a->flags | (a->next != NULL ? 0 : ACC_LAST));
	  windres_put_16 (wrbfd, ba.key, a->key);
	  windres_put_16 (wrbfd, ba.id, a->id);
	  windres_put_16 (wrbfd, ba.pad, 0);
	  set_windres_bfd_content (wrbfd, &ba, off, BIN_ACCELERATOR_SIZE);
    }
      off += BIN_ACCELERATOR_SIZE;
    }
  return off;
}

/* Convert a cursor resource to binary.  */

static rc_uint_type
res_to_bin_cursor (windres_bfd *wrbfd, rc_uint_type off, const rc_cursor *c)
{
  if (wrbfd)
    {
      struct bin_cursor bc;

      windres_put_16 (wrbfd, bc.xhotspot, c->xhotspot);
      windres_put_16 (wrbfd, bc.yhotspot, c->yhotspot);
      set_windres_bfd_content (wrbfd, &bc, off, BIN_CURSOR_SIZE);
      if (c->length)
	set_windres_bfd_content (wrbfd, c->data, off + BIN_CURSOR_SIZE, c->length);
    }
  off = (off + BIN_CURSOR_SIZE + (rc_uint_type) c->length);
  return off;
}

/* Convert a group cursor resource to binary.  */

static rc_uint_type
res_to_bin_group_cursor (windres_bfd *wrbfd, rc_uint_type off,
			 const rc_group_cursor *group_cursors)
{
  int c = 0;
  const rc_group_cursor *gc;
  struct bin_group_cursor bgc;
  struct bin_group_cursor_item bgci;
  rc_uint_type start = off;

  off += BIN_GROUP_CURSOR_SIZE;

  for (c = 0, gc = group_cursors; gc != NULL; gc = gc->next, c++)
    {
      if (wrbfd)
	{
	  windres_put_16 (wrbfd, bgci.width, gc->width);
	  windres_put_16 (wrbfd, bgci.height, gc->height);
	  windres_put_16 (wrbfd, bgci.planes, gc->planes);
	  windres_put_16 (wrbfd, bgci.bits, gc->bits);
	  windres_put_32 (wrbfd, bgci.bytes, gc->bytes);
	  windres_put_16 (wrbfd, bgci.index, gc->index);
	  set_windres_bfd_content (wrbfd, &bgci, off, BIN_GROUP_CURSOR_ITEM_SIZE);
    }

      off += BIN_GROUP_CURSOR_ITEM_SIZE;
    }
  if (wrbfd)
    {
      windres_put_16 (wrbfd, bgc.sig1, 0);
      windres_put_16 (wrbfd, bgc.sig2, 2);
      windres_put_16 (wrbfd, bgc.nitems, c);
      set_windres_bfd_content (wrbfd, &bgc, start, BIN_GROUP_CURSOR_SIZE);
    }
  return off;
}

/* Convert a dialog resource to binary.  */

static rc_uint_type
res_to_bin_dialog (windres_bfd *wrbfd, rc_uint_type off, const rc_dialog *dialog)
{
  rc_uint_type off_delta;
  rc_uint_type start, marker;
  int dialogex;
  int c;
  rc_dialog_control *dc;
  struct bin_dialogex bdx;
  struct bin_dialog bd;

  off_delta = off;
  start = off;
  dialogex = extended_dialog (dialog);

  if (wrbfd)
    {
  if (! dialogex)
    {
	  windres_put_32 (wrbfd, bd.style, dialog->style);
	  windres_put_32 (wrbfd, bd.exstyle, dialog->exstyle);
	  windres_put_16 (wrbfd, bd.x, dialog->x);
	  windres_put_16 (wrbfd, bd.y, dialog->y);
	  windres_put_16 (wrbfd, bd.width, dialog->width);
	  windres_put_16 (wrbfd, bd.height, dialog->height);
    }
  else
    {
	  windres_put_16 (wrbfd, bdx.sig1, 1);
	  windres_put_16 (wrbfd, bdx.sig2, 0xffff);
	  windres_put_32 (wrbfd, bdx.help, (dialog->ex ? dialog->ex->help : 0));
	  windres_put_32 (wrbfd, bdx.exstyle, dialog->exstyle);
	  windres_put_32 (wrbfd, bdx.style, dialog->style);
	  windres_put_16 (wrbfd, bdx.x, dialog->x);
	  windres_put_16 (wrbfd, bdx.y, dialog->y);
	  windres_put_16 (wrbfd, bdx.width, dialog->width);
	  windres_put_16 (wrbfd, bdx.height, dialog->height);
	}
    }

  off += (dialogex != 0 ? BIN_DIALOGEX_SIZE : BIN_DIALOG_SIZE);

  off = resid_to_bin (wrbfd, off, dialog->menu);
  off = resid_to_bin (wrbfd, off, dialog->class);
  off = unicode_to_bin (wrbfd, off, dialog->caption);

  if ((dialog->style & DS_SETFONT) != 0)
    {
      if (wrbfd)
	{
	  if (! dialogex)
	    {
	      struct bin_dialogfont bdf;
	      windres_put_16 (wrbfd, bdf.pointsize, dialog->pointsize);
	      set_windres_bfd_content (wrbfd, &bdf, off, BIN_DIALOGFONT_SIZE);
	    }
	  else
	    {
	      struct bin_dialogexfont bdxf;
	      windres_put_16 (wrbfd, bdxf.pointsize, dialog->pointsize);
	      windres_put_16 (wrbfd, bdxf.weight, (dialog->ex == NULL ? 0 : dialog->ex->weight));
	      windres_put_8 (wrbfd, bdxf.italic, (dialog->ex == NULL ? 0 : dialog->ex->italic));
	      windres_put_8 (wrbfd, bdxf.charset, (dialog->ex == NULL ? 1 : dialog->ex->charset));
	      set_windres_bfd_content (wrbfd, &bdxf, off, BIN_DIALOGEXFONT_SIZE);
	    }
	}
      off += (dialogex ? BIN_DIALOGEXFONT_SIZE : BIN_DIALOGFONT_SIZE);
      off = unicode_to_bin (wrbfd, off, dialog->font);
    }
  for (c = 0, dc = dialog->controls; dc != NULL; dc = dc->next, c++)
    {
      bfd_byte dc_rclen[2];

      off += (4 - ((off - off_delta) & 3)) & 3;
      if (wrbfd)
	{
      if (! dialogex)
	{
	      struct bin_dialog_control bdc;

	      windres_put_32 (wrbfd, bdc.style, dc->style);
	      windres_put_32 (wrbfd, bdc.exstyle, dc->exstyle);
	      windres_put_16 (wrbfd, bdc.x, dc->x);
	      windres_put_16 (wrbfd, bdc.y, dc->y);
	      windres_put_16 (wrbfd, bdc.width, dc->width);
	      windres_put_16 (wrbfd, bdc.height, dc->height);
	      windres_put_16 (wrbfd, bdc.id, dc->id);
	      set_windres_bfd_content (wrbfd, &bdc, off, BIN_DIALOG_CONTROL_SIZE);
	}
      else
	{
	      struct bin_dialogex_control bdc;

	      windres_put_32 (wrbfd, bdc.help, dc->help);
	      windres_put_32 (wrbfd, bdc.exstyle, dc->exstyle);
	      windres_put_32 (wrbfd, bdc.style, dc->style);
	      windres_put_16 (wrbfd, bdc.x, dc->x);
	      windres_put_16 (wrbfd, bdc.y, dc->y);
	      windres_put_16 (wrbfd, bdc.width, dc->width);
	      windres_put_16 (wrbfd, bdc.height, dc->height);
	      windres_put_32 (wrbfd, bdc.id, dc->id);
	      set_windres_bfd_content (wrbfd, &bdc, off, BIN_DIALOGEX_CONTROL_SIZE);
	    }
	}      
      off += (dialogex != 0 ? BIN_DIALOGEX_CONTROL_SIZE : BIN_DIALOG_CONTROL_SIZE);

      off = resid_to_bin (wrbfd, off, dc->class);
      off = resid_to_bin (wrbfd, off, dc->text);

      marker = off; /* Save two bytes for size of optional data.  */
      off += 2;

      if (dc->data == NULL)
        {
	  if (wrbfd)
	    windres_put_16 (wrbfd, dc_rclen, 0);
	}
      else
	{
	  rc_uint_type saved_off = off;
	  rc_uint_type old_off;
	  off += (4 - ((off - off_delta) & 3)) & 3;

	  old_off = off;
	  off = res_to_bin_rcdata (wrbfd, off, dc->data);
	  if ((off - old_off) == 0)
	    old_off = off = saved_off;
	  if (wrbfd)
	    windres_put_16 (wrbfd, dc_rclen, off - old_off);
	    }
      if (wrbfd)
	set_windres_bfd_content (wrbfd, dc_rclen, marker, 2);
	}

  if (wrbfd)
    {
      windres_put_16 (wrbfd, (dialogex != 0 ? bdx.off : bd.off), c);
      if (! dialogex)
	set_windres_bfd_content (wrbfd, &bd, start, BIN_DIALOG_SIZE);
      else
	set_windres_bfd_content (wrbfd, &bdx, start, BIN_DIALOGEX_SIZE);
    }

  return off;
}

/* Convert a fontdir resource to binary.  */
static rc_uint_type
res_to_bin_fontdir (windres_bfd *wrbfd, rc_uint_type off, const rc_fontdir *fontdirs)
{
  rc_uint_type start;
  int c;
  const rc_fontdir *fd;

  start = off;
  off += 2;

  for (c = 0, fd = fontdirs; fd != NULL; fd = fd->next, c++)
    {
      if (wrbfd)
	{
	  bfd_byte d[2];
	  windres_put_16 (wrbfd, d, fd->index);
	  set_windres_bfd_content (wrbfd, d, off, 2);
	  if (fd->length)
	    set_windres_bfd_content (wrbfd, fd->data, off + 2, fd->length);
	}
      off += (rc_uint_type) fd->length + 2;
    }

  if (wrbfd)
    {
      bfd_byte d[2];
      windres_put_16 (wrbfd, d, c);
      set_windres_bfd_content (wrbfd, d, start, 2);
    }
  return off;
}

/* Convert a group icon resource to binary.  */

static rc_uint_type
res_to_bin_group_icon (windres_bfd *wrbfd, rc_uint_type off, const rc_group_icon *group_icons)
{
  rc_uint_type start;
  struct bin_group_icon bgi;
  int c;
  const rc_group_icon *gi;

  start = off;
  off += BIN_GROUP_ICON_SIZE;

  for (c = 0, gi = group_icons; gi != NULL; gi = gi->next, c++)
    {
      struct bin_group_icon_item bgii;

      if (wrbfd)
	{
	  windres_put_8 (wrbfd, bgii.width, gi->width);
	  windres_put_8 (wrbfd, bgii.height, gi->height);
	  windres_put_8 (wrbfd, bgii.colors, gi->colors);
	  windres_put_8 (wrbfd, bgii.pad, 0);
	  windres_put_16 (wrbfd, bgii.planes, gi->planes);
	  windres_put_16 (wrbfd, bgii.bits, gi->bits);
	  windres_put_32 (wrbfd, bgii.bytes, gi->bytes);
	  windres_put_16 (wrbfd, bgii.index, gi->index);
	  set_windres_bfd_content (wrbfd, &bgii, off, BIN_GROUP_ICON_ITEM_SIZE);
	}
      off += BIN_GROUP_ICON_ITEM_SIZE;
    }

  if (wrbfd)
    {
      windres_put_16 (wrbfd, bgi.sig1, 0);
      windres_put_16 (wrbfd, bgi.sig2, 1);
      windres_put_16 (wrbfd, bgi.count, c);
      set_windres_bfd_content (wrbfd, &bgi, start, BIN_GROUP_ICON_SIZE);
    }
  return off;
}

/* Convert a menu resource to binary.  */

static rc_uint_type
res_to_bin_menu (windres_bfd *wrbfd, rc_uint_type off, const rc_menu *menu)
{
  int menuex;

  menuex = extended_menu (menu);

  if (wrbfd)
    {
  if (! menuex)
    {
	  struct bin_menu bm;
	  windres_put_16 (wrbfd, bm.sig1, 0);
	  windres_put_16 (wrbfd, bm.sig2, 0);
	  set_windres_bfd_content (wrbfd, &bm, off, BIN_MENU_SIZE);
    }
  else
    {
	  struct bin_menuex bm;
	  windres_put_16 (wrbfd, bm.sig1, 1);
	  windres_put_16 (wrbfd, bm.sig2, 4);
	  windres_put_32 (wrbfd, bm.help, menu->help);
	  set_windres_bfd_content (wrbfd, &bm, off, BIN_MENUEX_SIZE);
    }
    }
  off += (menuex != 0 ? BIN_MENUEX_SIZE : BIN_MENU_SIZE);
  if (! menuex)
    {
      off = res_to_bin_menuitems (wrbfd, off, menu->items);
    }
  else
    {
      off = res_to_bin_menuexitems (wrbfd, off, menu->items);
    }
  return off;
}

/* Convert menu items to binary.  */

static rc_uint_type
res_to_bin_menuitems (windres_bfd *wrbfd, rc_uint_type off, const rc_menuitem *items)
{
  const rc_menuitem *mi;

  for (mi = items; mi != NULL; mi = mi->next)
    {
      struct bin_menuitem bmi;
      int flags;

      flags = mi->type;
      if (mi->next == NULL)
	flags |= MENUITEM_ENDMENU;
      if (mi->popup != NULL)
	flags |= MENUITEM_POPUP;

      if (wrbfd)
	{
	  windres_put_16 (wrbfd, bmi.flags, flags);
      if (mi->popup == NULL)
	    windres_put_16 (wrbfd, bmi.id, mi->id);
	  set_windres_bfd_content (wrbfd, &bmi, off,
				   mi->popup == NULL ? BIN_MENUITEM_SIZE
				   		     : BIN_MENUITEM_POPUP_SIZE);
	}
      off += (mi->popup == NULL ? BIN_MENUITEM_SIZE : BIN_MENUITEM_POPUP_SIZE);

      off = unicode_to_bin (wrbfd, off, mi->text);

      if (mi->popup != NULL)
	{
	  off = res_to_bin_menuitems (wrbfd, off, mi->popup);
	}
    }
  return off;
}

/* Convert menuex items to binary.  */

static rc_uint_type
res_to_bin_menuexitems (windres_bfd *wrbfd, rc_uint_type off, const rc_menuitem *items)
{
  rc_uint_type off_delta = off;
  const rc_menuitem *mi;

  for (mi = items; mi != NULL; mi = mi->next)
    {
      struct bin_menuitemex bmi;
      int flags;

      off += (4 - ((off - off_delta) & 3)) & 3;

      flags = 0;
      if (mi->next == NULL)
	flags |= 0x80;
      if (mi->popup != NULL)
	flags |= 1;

      if (wrbfd)
	{
	  windres_put_32 (wrbfd, bmi.type, mi->type);
	  windres_put_32 (wrbfd, bmi.state, mi->state);
	  windres_put_32 (wrbfd, bmi.id, mi->id);
	  windres_put_16 (wrbfd, bmi.flags, flags);
	  set_windres_bfd_content (wrbfd, &bmi, off, BIN_MENUITEMEX_SIZE);
	}
      off += BIN_MENUITEMEX_SIZE;

      off = unicode_to_bin (wrbfd, off, mi->text);

      if (mi->popup != NULL)
	{
	  bfd_byte help[4];

	  off += (4 - ((off - off_delta) & 3)) & 3;

	  if (wrbfd)
	    {
	      windres_put_32 (wrbfd, help, mi->help);
	      set_windres_bfd_content (wrbfd, help, off, 4);
	    }
	  off += 4;
	  off = res_to_bin_menuexitems (wrbfd, off, mi->popup);
	}
    }
  return off;
}

/* Convert an rcdata resource to binary.  This is also used to convert
   other information which happens to be stored in rc_rcdata_item lists
   to binary.  */

static rc_uint_type
res_to_bin_rcdata (windres_bfd *wrbfd, rc_uint_type off, const rc_rcdata_item *items)
{
  const rc_rcdata_item *ri;

  for (ri = items; ri != NULL; ri = ri->next)
    {
      rc_uint_type len;
      switch (ri->type)
	{
	default:
	  abort ();
	case RCDATA_WORD:
	  len = 2;
	  break;
	case RCDATA_DWORD:
	  len = 4;
	  break;
	case RCDATA_STRING:
	  len = ri->u.string.length;
	  break;
	case RCDATA_WSTRING:
	  len = ri->u.wstring.length * sizeof (unichar);
	  break;
	case RCDATA_BUFFER:
	  len = ri->u.buffer.length;
	  break;
	}
      if (wrbfd)
	{
	  bfd_byte h[4];
	  bfd_byte *hp = &h[0];
	  switch (ri->type)
	    {
	    case RCDATA_WORD:
	      windres_put_16 (wrbfd, hp, ri->u.word);
	      break;
	    case RCDATA_DWORD:
	      windres_put_32 (wrbfd, hp, ri->u.dword);
	      break;
	    case RCDATA_STRING:
	      hp = (bfd_byte *) ri->u.string.s;
	  break;
	case RCDATA_WSTRING:
	  {
		rc_uint_type i;

		hp = (bfd_byte *) reswr_alloc (len);
	    for (i = 0; i < ri->u.wstring.length; i++)
		  windres_put_16 (wrbfd, hp + i * sizeof (unichar), ri->u.wstring.w[i]);
	  }
	      break;
	case RCDATA_BUFFER:
	      hp = (bfd_byte *) ri->u.buffer.data;
	  break;
	}
	  set_windres_bfd_content (wrbfd, hp, off, len);
    }
      off += len;
    }
  return off;
}

/* Convert a stringtable resource to binary.  */

static rc_uint_type
res_to_bin_stringtable (windres_bfd *wrbfd, rc_uint_type off,
			const rc_stringtable *st)
{
  int i;

  for (i = 0; i < 16; i++)
    {
      rc_uint_type slen, length;
      unichar *s;

      slen = (rc_uint_type) st->strings[i].length;
      if (slen == 0xffffffff) slen = 0;
      s = st->strings[i].string;

      length = 2 + slen * 2;
      if (wrbfd)
	{
	  bfd_byte *hp;
	  rc_uint_type j;

	  hp = (bfd_byte *) reswr_alloc (length);
	  windres_put_16 (wrbfd, hp, slen);

      for (j = 0; j < slen; j++)
	    windres_put_16 (wrbfd, hp + 2 + j * 2, s[j]);
	  set_windres_bfd_content (wrbfd, hp, off, length);
    }
      off += length;
    }
  return off;
}

/* Convert an ASCII string to a unicode binary string.  This always
   returns exactly one bindata structure.  */

static rc_uint_type
string_to_unicode_bin (windres_bfd *wrbfd, rc_uint_type off, const char *s)
{
  rc_uint_type len;

  len = (rc_uint_type) strlen (s);

  if (wrbfd)
    {
      rc_uint_type i;
      bfd_byte *hp;

      hp = (bfd_byte *) reswr_alloc ((len + 1) * sizeof (unichar));

      for (i = 0; i < len; i++)
	windres_put_16 (wrbfd, hp + i * 2, s[i]);
      windres_put_16 (wrbfd, hp + i * 2, 0);
      set_windres_bfd_content (wrbfd, hp, off, (len + 1) * sizeof (unichar));
    }
  off += (rc_uint_type) ((len + 1) * sizeof (unichar));
  return off;
}

static rc_uint_type
res_to_bin_toolbar (windres_bfd *wrbfd, rc_uint_type off, rc_toolbar *tb)
{
  if (wrbfd)
    {
      struct bin_toolbar bt;
      windres_put_32 (wrbfd, bt.button_width, tb->button_width);
      windres_put_32 (wrbfd, bt.button_height, tb->button_height);
      windres_put_32 (wrbfd, bt.nitems, tb->nitems);
      set_windres_bfd_content (wrbfd, &bt, off, BIN_TOOLBAR_SIZE);
      if (tb->nitems > 0)
	{
	  rc_toolbar_item *it;
	  bfd_byte *ids;
	  rc_uint_type i = 0;

	  ids = (bfd_byte *) reswr_alloc (tb->nitems * 4);
	  it=tb->items;
	  while(it != NULL)
	    {
	      windres_put_32 (wrbfd, ids + i, it->id.u.id);
	      i += 4;
	      it = it->next;
	    }
	  set_windres_bfd_content (wrbfd, ids, off + BIN_TOOLBAR_SIZE, i);
 	}
    }
  off += BIN_TOOLBAR_SIZE + tb->nitems * 4;

  return off;
}

/* Convert a versioninfo resource to binary.  */

static rc_uint_type
res_to_bin_versioninfo (windres_bfd *wrbfd, rc_uint_type off,
			const rc_versioninfo *versioninfo)
{
  rc_uint_type off_delta = off;
  rc_uint_type start;
  struct bin_versioninfo bvi;
  rc_ver_info *vi;

  start = off;
  off += BIN_VERSIONINFO_SIZE;
  off = string_to_unicode_bin (wrbfd, off, "VS_VERSION_INFO");
  off += (4 - ((off - off_delta) & 3)) & 3;

  if (versioninfo->fixed != NULL)
    {
      if (wrbfd)
	{
	  struct bin_fixed_versioninfo bfv;
	  const rc_fixed_versioninfo *fi;

      fi = versioninfo->fixed;
	  windres_put_32 (wrbfd, bfv.sig1, 0xfeef04bd);
	  windres_put_32 (wrbfd, bfv.sig2, 0x10000);
	  windres_put_32 (wrbfd, bfv.file_version, fi->file_version_ms);
	  windres_put_32 (wrbfd, bfv.file_version_ls, fi->file_version_ls);
	  windres_put_32 (wrbfd, bfv.product_version_ms, fi->product_version_ms);
	  windres_put_32 (wrbfd, bfv.product_version_ls, fi->product_version_ls);
	  windres_put_32 (wrbfd, bfv.file_flags_mask, fi->file_flags_mask);
	  windres_put_32 (wrbfd, bfv.file_flags, fi->file_flags);
	  windres_put_32 (wrbfd, bfv.file_os, fi->file_os);
	  windres_put_32 (wrbfd, bfv.file_type, fi->file_type);
	  windres_put_32 (wrbfd, bfv.file_subtype, fi->file_subtype);
	  windres_put_32 (wrbfd, bfv.file_date_ms, fi->file_date_ms);
	  windres_put_32 (wrbfd, bfv.file_date_ls, fi->file_date_ls);
	  set_windres_bfd_content (wrbfd, &bfv, off, BIN_FIXED_VERSIONINFO_SIZE);
	}
      off += BIN_FIXED_VERSIONINFO_SIZE;
    }

  for (vi = versioninfo->var; vi != NULL; vi = vi->next)
    {
      struct bin_ver_info bv;
      rc_uint_type bv_off;

      off += (4 - ((off - off_delta) & 3)) & 3;

      bv_off = off;

      off += BIN_VER_INFO_SIZE;

      switch (vi->type)
	{
	default:
	  abort ();
	case VERINFO_STRING:
	  {
	    const rc_ver_stringtable *vst;

	    off = string_to_unicode_bin (wrbfd, off, "StringFileInfo");

	    if (!vi->u.string.stringtables)
	      off += (4 - ((off - off_delta) & 3)) & 3;

	    for (vst = vi->u.string.stringtables; vst != NULL; vst = vst->next)
	      {
		struct bin_ver_info bvst;
		rc_uint_type vst_off;
		const rc_ver_stringinfo *vs;

		off += (4 - ((off - off_delta) & 3)) & 3;

		vst_off = off;
		off += BIN_VER_INFO_SIZE;

		off = unicode_to_bin (wrbfd, off, vst->language);

		for (vs = vst->strings; vs != NULL; vs = vs->next)
		  {
		    struct bin_ver_info bvs;
		    rc_uint_type vs_off, str_off;

		    off += (4 - ((off - off_delta) & 3)) & 3;

		    vs_off = off;
		    off += BIN_VER_INFO_SIZE;

		    off = unicode_to_bin (wrbfd, off, vs->key);

		    off += (4 - ((off - off_delta) & 3)) & 3;

		    str_off = off;
		    off = unicode_to_bin (wrbfd, off, vs->value);

		    if (wrbfd)
		      {
			windres_put_16 (wrbfd, bvs.size, off - vs_off);
			windres_put_16 (wrbfd, bvs.sig1, (off - str_off) / 2);
			windres_put_16 (wrbfd, bvs.sig2, 1);
			set_windres_bfd_content (wrbfd, &bvs, vs_off,
						 BIN_VER_INFO_SIZE);
		      }
		  }

		if (wrbfd)
		  {
		    windres_put_16 (wrbfd, bvst.size, off - vst_off);
		    windres_put_16 (wrbfd, bvst.sig1, 0);
		    windres_put_16 (wrbfd, bvst.sig2, 1);
		    set_windres_bfd_content (wrbfd, &bvst, vst_off,
					     BIN_VER_INFO_SIZE);
		  }
	      }
	    break;
	  }

	case VERINFO_VAR:
	  {
	    rc_uint_type vvd_off, vvvd_off;
	    struct bin_ver_info bvvd;
	    const rc_ver_varinfo *vv;

	    off = string_to_unicode_bin (wrbfd, off, "VarFileInfo");

	    off += (4 - ((off - off_delta) & 3)) & 3;

	    vvd_off = off;
	    off += BIN_VER_INFO_SIZE;

	    off = unicode_to_bin (wrbfd, off, vi->u.var.key);

	    off += (4 - ((off - off_delta) & 3)) & 3;

	    vvvd_off = off;

	    for (vv = vi->u.var.var; vv != NULL; vv = vv->next)
	      {
		if (wrbfd)
		  {
		    bfd_byte vvsd[4];

		    windres_put_16 (wrbfd, &vvsd[0], vv->language);
		    windres_put_16 (wrbfd, &vvsd[2], vv->charset);
		    set_windres_bfd_content (wrbfd, vvsd, off, 4);
		  }
		off += 4;
	      }
	    if (wrbfd)
	    {
		windres_put_16 (wrbfd, bvvd.size, off - vvd_off);
		windres_put_16 (wrbfd, bvvd.sig1, off - vvvd_off);
		windres_put_16 (wrbfd, bvvd.sig2, 0);
		set_windres_bfd_content (wrbfd, &bvvd, vvd_off,
					 BIN_VER_INFO_SIZE);
	    }

	    break;
	  }
	}

      if (wrbfd)
	{
	  windres_put_16 (wrbfd, bv.size, off - bv_off);
	  windres_put_16 (wrbfd, bv.sig1, 0);
	  windres_put_16 (wrbfd, bv.sig2, 1);
	  set_windres_bfd_content (wrbfd, &bv, bv_off,
	  			   BIN_VER_INFO_SIZE);
	}
    }

  if (wrbfd)
    {
      windres_put_16 (wrbfd, bvi.size, off - start);
      windres_put_16 (wrbfd, bvi.fixed_size,
		      versioninfo->fixed == NULL ? 0
		      				 : BIN_FIXED_VERSIONINFO_SIZE);
      windres_put_16 (wrbfd, bvi.sig2, 0);
      set_windres_bfd_content (wrbfd, &bvi, start, BIN_VER_INFO_SIZE);
    }
  return off;
}

/* Convert a generic resource to binary.  */

static rc_uint_type
res_to_bin_generic (windres_bfd *wrbfd, rc_uint_type off, rc_uint_type length,
		    const bfd_byte *data)
{
  if (wrbfd && length != 0)
    set_windres_bfd_content (wrbfd, data, off, length);
  return off + (rc_uint_type) length;
}
@


1.18
log
@	PR binutils/13051
	Fix a syntax error bug when compiling rc files with the VERSIONINFO resource
	containing more than one language block inside a single StringFileInfo block.

	* windint.h (rc_ver_stringtable): New structure definition.
	(rc_ver_info): Use it.
	* rcparse.y (verstringtable): New variable.
	(verstringtables): New type.
	(verstringtables:): New rule declaration.
	(verblocks:): Use it.
	* resrc.c (append_ver_stringtable): New function.
	(append_ver_stringfileinfo): Update to use stringtables.
	* windres.h (append_ver_stringfileinfo): Update declaration.
	(append_ver_stringtable): New declaration.
	* resrc.c (write_rc_versioninfo): Update to support multiple blocks.
	* resbin.c (bin_to_res_version): Likewise.
	(res_to_bin_versioninfo): Likewise.

	* binutils-all\windres\version.rsd: Regenerate.
	* binutils-all\windres\version_cat.rsd: Regenerate.
	* binutils-all\windres\version_mlang.rc: Add new test.
	* binutils-all\windres\version_mlang.rsd: Likewise.
@
text
@d912 1
a912 1
  *len = windres_get_16 (wrbfd, data, 2);
d1044 1
a1044 4
	  /* It's convenient to round verlen to a 4 byte alignment,
             since we round the subvariables in the loop.  */

	  verlen = (verlen + 3) &~ 3;
d1070 1
a1070 1
	  stverlen = (stverlen + 3) &~ 3;
a1087 2
	      sverlen = (sverlen + 3) &~ 3;

d1093 1
a1093 1
	      valoff = (valoff + 3) &~ 3;
d1106 1
@


1.17
log
@ChangeLog binutils/
2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* debug.c (debug_start_source): Use filename_(n)cmp.
	* ieee.c (ieee_finish_compilation_unit): Likewise.
	(ieee_lineno): Likewise.
	* nlmconv.c (main): Likewise.
	* objcopy.c (strip_main): Likewise.
	(copy_main): Likewise.
	* objdump.c (show_line): Likewise.
	(dump_reloc_set): Likewise.
	* srconv.c (main): Likewise.
	* wrstabs.c (stab_lineno): Likewise.

ChangeLog gas/
2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* depend.c (register_dependency): Use filename_(n)cmp.
	* dwarf2dbg.c (get_filenum): Likewise.
	* ecoff.c (add_file): Likewise.
	(ecoff_generate_asm_lineno): Likewise.
	* input-scrub.c (new_logical_line_flags): Likewise.
	* listing.c (file_info): Likewise.
	(listing_newline): Likewise.
	* remap.c (remap_debug_filename): Likewise.
	* stabs.c (generate_asm_file): Likewise.
	(stabs_generate_asm_lineno): Likewise.
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2002, 2003, 2005, 2006, 2007, 2009, 2010
d1030 1
a1030 1
	  rc_ver_stringinfo **ppvs;
d1044 18
a1061 3
	  get_version_header (wrbfd, data, length, (const char *) NULL,
			      &vi->u.string.language, &verlen, &vallen,
			      &type, &off);
d1063 2
a1064 2
	  if (vallen != 0)
	    fatal (_("unexpected version stringtable value length %ld"), (long) vallen);
d1066 2
a1067 3
	  data += off;
	  length -= off;
	  verlen -= off;
d1069 3
a1071 2
	  vi->u.string.strings = NULL;
	  ppvs = &vi->u.string.strings;
d1073 4
a1076 3
	  /* It's convenient to round verlen to a 4 byte alignment,
             since we round the subvariables in the loop.  */
	  verlen = (verlen + 3) &~ 3;
d1078 1
a1078 1
	  while (verlen > 0)
d1081 4
a1084 1
	      rc_uint_type subverlen, vslen, valoff;
d1086 1
a1086 1
	      vs = (rc_ver_stringinfo *) res_alloc (sizeof *vs);
d1088 2
a1089 3
	      get_version_header (wrbfd, data, length,
				  (const char *) NULL, &vs->key, &subverlen,
				  &vallen, &type, &off);
d1091 1
a1091 1
	      subverlen = (subverlen + 3) &~ 3;
d1100 1
a1100 1
	      if (off + valoff != subverlen)
d1102 1
a1102 5
		       (long) subverlen, (long) off, (long) valoff);

	      vs->next = NULL;
	      *ppvs = vs;
	      ppvs = &vs->next;
d1107 1
a1107 1
	      if (verlen < subverlen)
d1109 7
a1115 1
		       (long) verlen, (long) subverlen);
d1117 3
a1119 1
	      verlen -= subverlen;
d2030 1
a2030 3
	    struct bin_ver_info bvsd;
	    rc_uint_type vs_off;
	    const rc_ver_stringinfo *vs;
a2032 5
	    off += (4 - ((off - off_delta) & 3)) & 3;

	    vs_off = off;

	    off += BIN_VER_INFO_SIZE;
d2034 2
a2035 1
	    off = unicode_to_bin (wrbfd, off, vi->u.string.language);
d2037 1
a2037 1
	    for (vs = vi->u.string.strings; vs != NULL; vs = vs->next)
d2039 3
a2041 2
		struct bin_ver_info bvss;
		rc_uint_type vss_off,str_off;
d2045 1
a2045 1
		vss_off = off;
d2048 6
a2053 1
		off = unicode_to_bin (wrbfd, off, vs->key);
d2055 21
a2075 1
		off += (4 - ((off - off_delta) & 3)) & 3;
a2076 2
		str_off = off;
		off = unicode_to_bin (wrbfd, off, vs->value);
d2079 5
a2083 5
		    windres_put_16 (wrbfd, bvss.size, off - vss_off);
		    windres_put_16 (wrbfd, bvss.sig1, (off - str_off) / 2);
		    windres_put_16 (wrbfd, bvss.sig2, 1);
		    set_windres_bfd_content (wrbfd, &bvss, vss_off,
		    			     BIN_VER_INFO_SIZE);
a2085 8
	    if (wrbfd)
	      {
		windres_put_16 (wrbfd, bvsd.size, off - vs_off);
		windres_put_16 (wrbfd, bvsd.sig1, 0);
		windres_put_16 (wrbfd, bvsd.sig2, 0);
		set_windres_bfd_content (wrbfd, &bvsd, vs_off,
					 BIN_VER_INFO_SIZE);
	      }
d2135 1
a2135 1
	  windres_put_16 (wrbfd, bv.size, off-bv_off);
d2137 1
a2137 1
	  windres_put_16 (wrbfd, bv.sig2, 0);
@


1.16
log
@fix set but unused variable warnings
@
text
@d1870 1
@


1.15
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2002, 2003, 2005, 2006, 2007, 2009
a1359 1
  bindata *first, **pp;
a1361 3
  first = NULL;
  pp = &first;

@


1.14
log
@update copyright dates
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2002, 2003, 2005, 2006, 2007
d230 1
a230 1
  rc_uint_type version, read;
d248 1
a248 1
      m->items = bin_to_res_menuitems (wrbfd, data + 4, length - 4, &read);
d261 1
a261 1
					 length - (4 + offset), &read);
d273 1
a273 1
		      rc_uint_type *read)
d280 1
a280 1
  *read = 0;
d337 1
a337 1
      *read += itemlen;
d350 1
a350 1
			rc_uint_type *read)
d357 1
a357 1
  *read = 0;
d411 1
a411 1
      *read += itemlen;
@


1.13
log
@Change sources over to using GPLv3
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2002, 2003, 2007
@


1.12
log
@Updated windres tool
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d24 1
@


1.11
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d5 1
d30 1
a31 1
#include "bucomm.h"
a33 6
/* Macros to swap in values.  */

#define get_8(s)      (*((unsigned char *)(s)))
#define get_16(be, s) ((be) ? bfd_getb16 (s) : bfd_getl16 (s))
#define get_32(be, s) ((be) ? bfd_getb32 (s) : bfd_getl32 (s))

d38 23
a60 35
static unichar *get_unicode
  (const unsigned char *, unsigned long, int, int *);
static int get_resid
  (struct res_id *, const unsigned char *, unsigned long, int);
static struct res_resource *bin_to_res_generic
  (enum res_type, const unsigned char *, unsigned long);
static struct res_resource *bin_to_res_cursor
  (const unsigned char *, unsigned long, int);
static struct res_resource *bin_to_res_menu
  (const unsigned char *, unsigned long, int);
static struct menuitem *bin_to_res_menuitems
  (const unsigned char *, unsigned long, int, int *);
static struct menuitem *bin_to_res_menuexitems
  (const unsigned char *, unsigned long, int, int *);
static struct res_resource *bin_to_res_dialog
  (const unsigned char *, unsigned long, int);
static struct res_resource *bin_to_res_string
  (const unsigned char *, unsigned long, int);
static struct res_resource *bin_to_res_fontdir
  (const unsigned char *, unsigned long, int);
static struct res_resource *bin_to_res_accelerators
  (const unsigned char *, unsigned long, int);
static struct res_resource *bin_to_res_rcdata
  (const unsigned char *, unsigned long, int);
static struct res_resource *bin_to_res_group_cursor
  (const unsigned char *, unsigned long, int);
static struct res_resource *bin_to_res_group_icon
  (const unsigned char *, unsigned long, int);
static struct res_resource *bin_to_res_version
  (const unsigned char *, unsigned long, int);
static struct res_resource *bin_to_res_userdata
  (const unsigned char *, unsigned long, int);
static void get_version_header
  (const unsigned char *, unsigned long, int, const char *,
   unichar **, int *, int *, int *, int *);
d63 1
a63 1
   res_resource structure which represents that resource.  The caller
d67 3
a69 3
struct res_resource *
bin_to_res (struct res_id type, const unsigned char *data,
	    unsigned long length, int big_endian)
d72 1
a72 1
    return bin_to_res_userdata (data, length, big_endian);
d78 1
a78 1
	  return bin_to_res_userdata (data, length, big_endian);
d80 1
a80 1
	  return bin_to_res_cursor (data, length, big_endian);
d82 1
a82 1
	  return bin_to_res_generic (RES_TYPE_BITMAP, data, length);
d84 1
a84 1
	  return bin_to_res_generic (RES_TYPE_ICON, data, length);
d86 1
a86 1
	  return bin_to_res_menu (data, length, big_endian);
d88 1
a88 1
	  return bin_to_res_dialog (data, length, big_endian);
d90 1
a90 1
	  return bin_to_res_string (data, length, big_endian);
d92 1
a92 1
	  return bin_to_res_fontdir (data, length, big_endian);
d94 1
a94 1
	  return bin_to_res_generic (RES_TYPE_FONT, data, length);
d96 1
a96 1
	  return bin_to_res_accelerators (data, length, big_endian);
d98 1
a98 1
	  return bin_to_res_rcdata (data, length, big_endian);
d100 1
a100 1
	  return bin_to_res_generic (RES_TYPE_MESSAGETABLE, data, length);
d102 1
a102 1
	  return bin_to_res_group_cursor (data, length, big_endian);
d104 1
a104 1
	  return bin_to_res_group_icon (data, length, big_endian);
d106 4
a109 1
	  return bin_to_res_version (data, length, big_endian);
d125 2
a126 2
get_unicode (const unsigned char *data, unsigned long length,
	     int big_endian, int *retlen)
d128 1
a128 1
  int c, i;
d134 1
a134 1
      if (length < (unsigned long) c * 2 + 2)
d136 1
a136 1
      if (get_16 (big_endian, data + c * 2) == 0)
d144 1
a144 1
    ret[i] = get_16 (big_endian, data + i * 2);
d156 2
a157 2
get_resid (struct res_id *id, const unsigned char *data,
	   unsigned long length, int big_endian)
d159 1
a159 1
  int first;
d164 1
a164 1
  first = get_16 (big_endian, data);
d170 1
a170 1
      id->u.id = get_16 (big_endian, data + 2);
d176 1
a176 1
      id->u.n.name = get_unicode (data, length, big_endian, &id->u.n.length);
d184 3
a186 3
struct res_resource *
bin_to_res_generic (enum res_type type, const unsigned char *data,
		    unsigned long length)
d188 1
a188 1
  struct res_resource *r;
d190 1
a190 1
  r = (struct res_resource *) res_alloc (sizeof *r);
d200 2
a201 3
struct res_resource *
bin_to_res_cursor (const unsigned char *data, unsigned long length,
		   int big_endian)
d203 2
a204 2
  struct cursor *c;
  struct res_resource *r;
d209 3
a211 3
  c = (struct cursor *) res_alloc (sizeof *c);
  c->xhotspot = get_16 (big_endian, data);
  c->yhotspot = get_16 (big_endian, data + 2);
d215 1
a215 1
  r = (struct res_resource *) res_alloc (sizeof *r);
d224 6
a229 7
struct res_resource *
bin_to_res_menu (const unsigned char *data, unsigned long length,
		 int big_endian)
{
  struct res_resource *r;
  struct menu *m;
  int version, read;
d231 1
a231 1
  r = (struct res_resource *) res_alloc (sizeof *r);
d234 1
a234 1
  m = (struct menu *) res_alloc (sizeof *m);
d240 1
a240 1
  version = get_16 (big_endian, data);
d247 1
a247 2
      m->items = bin_to_res_menuitems (data + 4, length - 4, big_endian,
				       &read);
d251 1
a251 1
      unsigned int offset;
d255 2
a256 2
      m->help = get_32 (big_endian, data + 4);
      offset = get_16 (big_endian, data + 2);
d259 2
a260 4
      m->items = bin_to_res_menuexitems (data + 4 + offset,
					 length - (4 + offset),
					 big_endian,
					 &read);
d263 1
a263 1
    fatal (_("unsupported menu version %d"), version);
d270 3
a272 3
static struct menuitem *
bin_to_res_menuitems (const unsigned char *data, unsigned long length,
		      int big_endian, int *read)
d274 1
a274 1
  struct menuitem *first, **pp;
d283 3
a285 3
      int flags, slen, itemlen;
      unsigned int stroff;
      struct menuitem *mi;
d290 1
a290 1
      mi = (struct menuitem *) res_alloc (sizeof *mi);
d294 1
a294 1
      flags = get_16 (big_endian, data);
d305 1
a305 1
      if (get_16 (big_endian, data + stroff) == 0)
d311 1
a311 2
	mi->text = get_unicode (data + stroff, length - stroff, big_endian,
				&slen);
d318 1
a318 1
	  mi->id = get_16 (big_endian, data + 2);
d322 1
a322 1
	  int subread;
d325 2
a326 2
	  mi->popup = bin_to_res_menuitems (data + itemlen, length - itemlen,
					    big_endian, &subread);
d347 3
a349 3
static struct menuitem *
bin_to_res_menuexitems (const unsigned char *data, unsigned long length,
			int big_endian, int *read)
d351 1
a351 1
  struct menuitem *first, **pp;
d360 3
a362 3
      int flags, slen;
      unsigned int itemlen;
      struct menuitem *mi;
d364 1
a364 1
      if (length < 14)
d367 4
a370 4
      mi = (struct menuitem *) res_alloc (sizeof *mi);
      mi->type = get_32 (big_endian, data);
      mi->state = get_32 (big_endian, data + 4);
      mi->id = get_16 (big_endian, data + 8);
d372 1
a372 1
      flags = get_16 (big_endian, data + 10);
d374 1
a374 1
      if (get_16 (big_endian, data + 12) == 0)
d380 1
a380 1
	mi->text = get_unicode (data + 12, length - 12, big_endian, &slen);
d382 1
a382 1
      itemlen = 12 + slen * 2 + 2;
d392 1
a392 1
	  int subread;
d396 1
a396 1
	  mi->help = get_32 (big_endian, data + itemlen);
d399 2
a400 3
	  mi->popup = bin_to_res_menuexitems (data + itemlen,
					      length - itemlen,
					      big_endian, &subread);
d421 9
a429 10
static struct res_resource *
bin_to_res_dialog (const unsigned char *data, unsigned long length,
		   int big_endian)
{
  int signature;
  struct dialog *d;
  int c, sublen, i;
  unsigned int off;
  struct dialog_control **pp;
  struct res_resource *r;
d434 1
a434 1
  d = (struct dialog *) res_alloc (sizeof *d);
d436 1
a436 1
  signature = get_16 (big_endian, data + 2);
d440 2
a441 2
      d->style = get_32 (big_endian, data);
      d->exstyle = get_32 (big_endian, data + 4);
d448 1
a448 1
      version = get_16 (big_endian, data);
d452 4
a455 4
      d->ex = (struct dialog_ex *) res_alloc (sizeof (struct dialog_ex));
      d->ex->help = get_32 (big_endian, data + 4);
      d->exstyle = get_32 (big_endian, data + 8);
      d->style = get_32 (big_endian, data + 12);
d462 5
a466 5
  c = get_16 (big_endian, data + off);
  d->x = get_16  (big_endian, data + off + 2);
  d->y = get_16 (big_endian, data + off + 4);
  d->width = get_16 (big_endian, data + off + 6);
  d->height = get_16 (big_endian, data + off + 8);
d470 1
a470 1
  sublen = get_resid (&d->menu, data + off, length - off, big_endian);
d473 1
a473 1
  sublen = get_resid (&d->class, data + off, length - off, big_endian);
d476 1
a476 1
  d->caption = get_unicode (data + off, length - off, big_endian, &sublen);
d497 1
a497 1
      d->pointsize = get_16 (big_endian, data + off);
d504 3
a506 3
	  d->ex->weight = get_16 (big_endian, data + off);
	  d->ex->italic = get_8 (data + off + 2);
	  d->ex->charset = get_8 (data + off + 3);
d510 1
a510 1
      d->font = get_unicode (data + off, length - off, big_endian, &sublen);
d519 1
a519 1
      struct dialog_control *dc;
d524 1
a524 1
      dc = (struct dialog_control *) res_alloc (sizeof *dc);
d531 2
a532 2
	  dc->style = get_32 (big_endian, data + off);
	  dc->exstyle = get_32 (big_endian, data + off + 4);
d540 3
a542 3
	  dc->help = get_32 (big_endian, data + off);
	  dc->exstyle = get_32 (big_endian, data + off + 4);
	  dc->style = get_32 (big_endian, data + off + 8);
d546 1
a546 1
      if (length < off + 10)
d549 4
a552 4
      dc->x = get_16 (big_endian, data + off);
      dc->y = get_16 (big_endian, data + off + 2);
      dc->width = get_16 (big_endian, data + off + 4);
      dc->height = get_16 (big_endian, data + off + 6);
d555 1
a555 1
	dc->id = get_32 (big_endian, data + off + 8);
d557 1
a557 1
	dc->id = get_16 (big_endian, data + off + 8);
d561 1
a561 1
      sublen = get_resid (&dc->class, data + off, length - off, big_endian);
d564 1
a564 1
      sublen = get_resid (&dc->text, data + off, length - off, big_endian);
d570 1
a570 1
      datalen = get_16 (big_endian, data + off);
d582 2
a583 2
	  dc->data = ((struct rcdata_item *)
		      res_alloc (sizeof (struct rcdata_item)));
d597 1
a597 1
  r = (struct res_resource *) res_alloc (sizeof *r);
d606 2
a607 3
static struct res_resource *
bin_to_res_string (const unsigned char *data, unsigned long length,
		   int big_endian)
d609 1
a609 1
  struct stringtable *st;
d611 1
a611 1
  struct res_resource *r;
d613 1
a613 1
  st = (struct stringtable *) res_alloc (sizeof *st);
d621 1
a621 1
      slen = get_16 (big_endian, data);
d636 1
a636 1
	    s[j] = get_16 (big_endian, data + 2 + j * 2);
d643 1
a643 1
  r = (struct res_resource *) res_alloc (sizeof *r);
d652 6
a657 7
static struct res_resource *
bin_to_res_fontdir (const unsigned char *data, unsigned long length,
		    int big_endian)
{
  int c, i;
  struct fontdir *first, **pp;
  struct res_resource *r;
d662 1
a662 1
  c = get_16 (big_endian, data);
d669 2
a670 1
      struct fontdir *fd;
d676 3
a678 2
      fd = (struct fontdir *) res_alloc (sizeof *fd);
      fd->index = get_16 (big_endian, data);
d682 1
a682 1
         we don't store them in the fontdir structure.  The
d714 1
a714 1
  r = (struct res_resource *) res_alloc (sizeof *r);
d723 2
a724 3
static struct res_resource *
bin_to_res_accelerators (const unsigned char *data, unsigned long length,
			 int big_endian)
d726 2
a727 2
  struct accelerator *first, **pp;
  struct res_resource *r;
d734 1
a734 1
      struct accelerator *a;
d739 1
a739 1
      a = (struct accelerator *) res_alloc (sizeof *a);
d741 3
a743 3
      a->flags = get_16 (big_endian, data);
      a->key = get_16 (big_endian, data + 2);
      a->id = get_16 (big_endian, data + 4);
d756 1
a756 1
  r = (struct res_resource *) res_alloc (sizeof *r);
d765 3
a767 3
static struct res_resource *
bin_to_res_rcdata (const unsigned char *data, unsigned long length,
		   int big_endian ATTRIBUTE_UNUSED)
d769 2
a770 2
  struct rcdata_item *ri;
  struct res_resource *r;
d772 1
a772 1
  ri = (struct rcdata_item *) res_alloc (sizeof *ri);
d779 2
a780 2
  r = (struct res_resource *) res_alloc (sizeof *r);
  r->type = RES_TYPE_RCDATA;
d788 2
a789 3
static struct res_resource *
bin_to_res_group_cursor (const unsigned char *data, unsigned long length,
			 int big_endian)
d792 2
a793 2
  struct group_cursor *first, **pp;
  struct res_resource *r;
d798 1
a798 1
  type = get_16 (big_endian, data + 2);
d802 1
a802 1
  c = get_16 (big_endian, data + 4);
d812 1
a812 1
      struct group_cursor *gc;
d817 1
a817 1
      gc = (struct group_cursor *) res_alloc (sizeof *gc);
d819 6
a824 6
      gc->width = get_16 (big_endian, data);
      gc->height = get_16 (big_endian, data + 2);
      gc->planes = get_16 (big_endian, data + 4);
      gc->bits = get_16 (big_endian, data + 6);
      gc->bytes = get_32 (big_endian, data + 8);
      gc->index = get_16 (big_endian, data + 12);
d834 1
a834 1
  r = (struct res_resource *) res_alloc (sizeof *r);
d843 2
a844 3
static struct res_resource *
bin_to_res_group_icon (const unsigned char *data, unsigned long length,
		       int big_endian)
d847 2
a848 2
  struct group_icon *first, **pp;
  struct res_resource *r;
d853 1
a853 1
  type = get_16 (big_endian, data + 2);
d857 1
a857 1
  c = get_16 (big_endian, data + 4);
d867 1
a867 1
      struct group_icon *gi;
d872 1
a872 1
      gi = (struct group_icon *) res_alloc (sizeof *gi);
d874 7
a880 7
      gi->width = data[0];
      gi->height = data[1];
      gi->colors = data[2];
      gi->planes = get_16 (big_endian, data + 4);
      gi->bits = get_16 (big_endian, data + 6);
      gi->bytes = get_32 (big_endian, data + 8);
      gi->index = get_16 (big_endian, data + 12);
d890 1
a890 1
  r = (struct res_resource *) res_alloc (sizeof *r);
d903 4
a906 3
get_version_header (const unsigned char *data, unsigned long length,
		    int big_endian, const char *key, unichar **pkey,
		    int *len, int *vallen, int *type, int *off)
d911 3
a913 3
  *len = get_16 (big_endian, data);
  *vallen = get_16 (big_endian, data + 2);
  *type = get_16 (big_endian, data + 4);
d922 1
a922 1
      int sublen;
d924 2
a925 2
      *pkey = get_unicode (data, length, big_endian, &sublen);
      *off += sublen * 2 + 2;
d933 1
a933 1
	  if (get_16 (big_endian, data) != (unsigned char) *key)
d952 8
a959 9
static struct res_resource *
bin_to_res_version (const unsigned char *data, unsigned long length,
		    int big_endian)
{
  int verlen, vallen, type, off;
  struct fixed_versioninfo *fi;
  struct ver_info *first, **pp;
  struct versioninfo *v;
  struct res_resource *r;
d961 1
a961 1
  get_version_header (data, length, big_endian, "VS_VERSION_INFO",
d966 1
a966 1
	   verlen, length);
d969 1
a969 1
    fatal (_("unexpected version type %d"), type);
d981 1
a981 1
	fatal (_("unexpected fixed version information length %d"), vallen);
d986 1
a986 1
      signature = get_32 (big_endian, data);
d990 1
a990 1
      fiv = get_32 (big_endian, data + 4);
d994 1
a994 1
      fi = (struct fixed_versioninfo *) res_alloc (sizeof *fi);
d996 11
a1006 11
      fi->file_version_ms = get_32 (big_endian, data + 8);
      fi->file_version_ls = get_32 (big_endian, data + 12);
      fi->product_version_ms = get_32 (big_endian, data + 16);
      fi->product_version_ls = get_32 (big_endian, data + 20);
      fi->file_flags_mask = get_32 (big_endian, data + 24);
      fi->file_flags = get_32 (big_endian, data + 28);
      fi->file_os = get_32 (big_endian, data + 32);
      fi->file_type = get_32 (big_endian, data + 36);
      fi->file_subtype = get_32 (big_endian, data + 40);
      fi->file_date_ms = get_32 (big_endian, data + 44);
      fi->file_date_ls = get_32 (big_endian, data + 48);
d1017 1
a1017 1
      struct ver_info *vi;
d1023 1
a1023 1
      vi = (struct ver_info *) res_alloc (sizeof *vi);
d1025 1
a1025 1
      ch = get_16 (big_endian, data + 6);
d1029 1
a1029 1
	  struct ver_stringinfo **ppvs;
d1033 1
a1033 1
	  get_version_header (data, length, big_endian, "StringFileInfo",
d1038 1
a1038 1
	    fatal (_("unexpected stringfileinfo value length %d"), vallen);
d1043 1
a1043 1
	  get_version_header (data, length, big_endian, (const char *) NULL,
d1048 1
a1048 1
	    fatal (_("unexpected version stringtable value length %d"), vallen);
d1063 2
a1064 2
	      struct ver_stringinfo *vs;
	      int subverlen, vslen, valoff;
d1066 1
a1066 1
	      vs = (struct ver_stringinfo *) res_alloc (sizeof *vs);
d1068 1
a1068 1
	      get_version_header (data, length, big_endian,
d1077 1
a1077 1
	      vs->value = get_unicode (data, length, big_endian, &vslen);
d1082 2
a1083 2
		fatal (_("unexpected version string length %d != %d + %d"),
		       subverlen, off, valoff);
d1093 2
a1094 2
		fatal (_("unexpected version string length %d < %d"),
		       verlen, subverlen);
d1101 1
a1101 1
	  struct ver_varinfo **ppvv;
d1105 1
a1105 1
	  get_version_header (data, length, big_endian, "VarFileInfo",
d1110 1
a1110 1
	    fatal (_("unexpected varfileinfo value length %d"), vallen);
d1115 1
a1115 1
	  get_version_header (data, length, big_endian, (const char *) NULL,
d1126 1
a1126 1
	      struct ver_varinfo *vv;
d1131 1
a1131 1
	      vv = (struct ver_varinfo *) res_alloc (sizeof *vv);
d1133 2
a1134 2
	      vv->language = get_16 (big_endian, data);
	      vv->charset = get_16 (big_endian, data + 2);
d1144 1
a1144 1
		fatal (_("unexpected version value length %d"), vallen);
d1157 1
a1157 1
  v = (struct versioninfo *) res_alloc (sizeof *v);
d1161 1
a1161 1
  r = (struct res_resource *) res_alloc (sizeof *r);
d1170 3
a1172 3
static struct res_resource *
bin_to_res_userdata (const unsigned char *data, unsigned long length,
		     int big_endian ATTRIBUTE_UNUSED)
d1174 2
a1175 2
  struct rcdata_item *ri;
  struct res_resource *r;
d1177 1
a1177 1
  ri = (struct rcdata_item *) res_alloc (sizeof *ri);
d1184 1
a1184 1
  r = (struct res_resource *) res_alloc (sizeof *r);
d1191 39
a1229 1
/* Macros to swap out values.  */
a1230 3
#define put_8(v, s)      (*((unsigned char *) (s)) = (unsigned char) (v))
#define put_16(be, v, s) ((be) ? bfd_putb16 ((v), (s)) : bfd_putl16 ((v), (s)))
#define put_32(be, v, s) ((be) ? bfd_putb32 ((v), (s)) : bfd_putl32 ((v), (s)))
d1234 18
a1251 30
static void dword_align_bin (struct bindata ***, unsigned long *);
static struct bindata *resid_to_bin (struct res_id, int);
static struct bindata *unicode_to_bin (const unichar *, int);
static struct bindata *res_to_bin_accelerator
  (const struct accelerator *, int);
static struct bindata *res_to_bin_cursor
  (const struct cursor *, int);
static struct bindata *res_to_bin_group_cursor
  (const struct group_cursor *, int);
static struct bindata *res_to_bin_dialog
  (const struct dialog *, int);
static struct bindata *res_to_bin_fontdir
  (const struct fontdir *, int);
static struct bindata *res_to_bin_group_icon
  (const struct group_icon *, int);
static struct bindata *res_to_bin_menu
  (const struct menu *, int);
static struct bindata *res_to_bin_menuitems
  (const struct menuitem *, int);
static struct bindata *res_to_bin_menuexitems
  (const struct menuitem *, int);
static struct bindata *res_to_bin_rcdata
  (const struct rcdata_item *, int);
static struct bindata *res_to_bin_stringtable
  (const struct stringtable *, int);
static struct bindata *string_to_unicode_bin (const char *, int);
static struct bindata *res_to_bin_versioninfo
  (const struct versioninfo *, int);
static struct bindata *res_to_bin_generic
  (unsigned long, const unsigned char *);
d1255 2
a1256 2
struct bindata *
res_to_bin (const struct res_resource *res, int big_endian)
a1259 2
    default:
      abort ();
d1264 1
a1264 1
      return res_to_bin_generic (res->u.data.length, res->u.data.data);
d1266 1
a1266 1
      return res_to_bin_accelerator (res->u.acc, big_endian);
d1268 1
a1268 1
      return res_to_bin_cursor (res->u.cursor, big_endian);
d1270 1
a1270 1
      return res_to_bin_group_cursor (res->u.group_cursor, big_endian);
d1272 1
a1272 1
      return res_to_bin_dialog (res->u.dialog, big_endian);
d1274 1
a1274 1
      return res_to_bin_fontdir (res->u.fontdir, big_endian);
d1276 1
a1276 1
      return res_to_bin_group_icon (res->u.group_icon, big_endian);
d1278 1
a1278 3
      return res_to_bin_menu (res->u.menu, big_endian);
    case RES_TYPE_RCDATA:
      return res_to_bin_rcdata (res->u.rcdata, big_endian);
d1280 5
a1284 1
      return res_to_bin_stringtable (res->u.stringtable, big_endian);
d1286 3
a1288 3
      return res_to_bin_rcdata (res->u.rcdata, big_endian);
    case RES_TYPE_VERSIONINFO:
      return res_to_bin_versioninfo (res->u.versioninfo, big_endian);
a1291 28
/* Align to a 32 bit boundary.  PPP points to the of a list of bindata
   structures.  LENGTH points to the length of the structures.  If
   necessary, this adds a new bindata to bring length up to a 32 bit
   boundary.  It updates *PPP and *LENGTH.  */

static void
dword_align_bin (struct bindata ***ppp, unsigned long *length)
{
  int add;
  struct bindata *d;

  if ((*length & 3) == 0)
    return;

  add = 4 - (*length & 3);

  d = (struct bindata *) reswr_alloc (sizeof *d);
  d->length = add;
  d->data = (unsigned char *) reswr_alloc (add);
  memset (d->data, 0, add);

  d->next = NULL;
  **ppp = d;
  *ppp = &(**ppp)->next;

  *length += add;
}

d1295 2
a1296 2
static struct bindata *
resid_to_bin (struct res_id id, int big_endian)
a1297 4
  struct bindata *d;

  d = (struct bindata *) reswr_alloc (sizeof *d);

d1300 9
a1308 4
      d->length = 4;
      d->data = (unsigned char *) reswr_alloc (d->length);
      put_16 (big_endian, 0xffff, d->data);
      put_16 (big_endian, id.u.id, d->data + 2);
d1312 11
a1322 7
      int i;

      d->length = id.u.n.length * 2 + 2;
      d->data = (unsigned char *) reswr_alloc (d->length);
      for (i = 0; i < id.u.n.length; i++)
	put_16 (big_endian, id.u.n.name[i], d->data + i * 2);
      put_16 (big_endian, 0, d->data + i * 2);
d1324 1
a1324 4

  d->next = NULL;

  return d;
d1330 2
a1331 2
static struct bindata *
unicode_to_bin (const unichar *str, int big_endian)
d1333 1
a1333 2
  int len;
  struct bindata *d;
a1334 1
  len = 0;
d1336 1
a1336 6
    {
      const unichar *s;

      for (s = str; *s != 0; s++)
	++len;
    }
d1338 1
a1338 7
  d = (struct bindata *) reswr_alloc (sizeof *d);
  d->length = len * 2 + 2;
  d->data = (unsigned char *) reswr_alloc (d->length);

  if (str == NULL)
    put_16 (big_endian, 0, d->data);
  else
d1340 7
a1346 6
      const unichar *s;
      int i;

      for (s = str, i = 0; *s != 0; s++, i++)
	put_16 (big_endian, *s, d->data + i * 2);
      put_16 (big_endian, 0, d->data + i * 2);
d1348 1
d1350 1
a1350 3
  d->next = NULL;

  return d;
d1355 3
a1357 3
static struct bindata *
res_to_bin_accelerator (const struct accelerator *accelerators,
			int big_endian)
d1359 2
a1360 2
  struct bindata *first, **pp;
  const struct accelerator *a;
d1367 3
a1369 1
      struct bindata *d;
d1371 7
a1377 14
      d = (struct bindata *) reswr_alloc (sizeof *d);
      d->length = 8;
      d->data = (unsigned char *) reswr_alloc (d->length);

      put_16 (big_endian,
	      a->flags | (a->next != NULL ? 0 : ACC_LAST),
	      d->data);
      put_16 (big_endian, a->key, d->data + 2);
      put_16 (big_endian, a->id, d->data + 4);
      put_16 (big_endian, 0, d->data + 6);

      d->next = NULL;
      *pp = d;
      pp = &d->next;
d1379 1
a1379 2

  return first;
d1384 2
a1385 2
static struct bindata *
res_to_bin_cursor (const struct cursor *c, int big_endian)
d1387 3
a1389 1
  struct bindata *d;
d1391 8
a1398 13
  d = (struct bindata *) reswr_alloc (sizeof *d);
  d->length = 4;
  d->data = (unsigned char *) reswr_alloc (d->length);

  put_16 (big_endian, c->xhotspot, d->data);
  put_16 (big_endian, c->yhotspot, d->data + 2);

  d->next = (struct bindata *) reswr_alloc (sizeof *d);
  d->next->length = c->length;
  d->next->data = (unsigned char *) c->data;
  d->next->next = NULL;

  return d;
d1403 3
a1405 3
static struct bindata *
res_to_bin_group_cursor (const struct group_cursor *group_cursors,
			 int big_endian)
d1407 5
a1411 3
  struct bindata *first, **pp;
  int c;
  const struct group_cursor *gc;
d1413 1
a1413 3
  first = (struct bindata *) reswr_alloc (sizeof *first);
  first->length = 6;
  first->data = (unsigned char *) reswr_alloc (first->length);
d1415 12
a1426 2
  put_16 (big_endian, 0, first->data);
  put_16 (big_endian, 2, first->data + 2);
d1428 3
a1430 5
  first->next = NULL;
  pp = &first->next;

  c = 0;
  for (gc = group_cursors; gc != NULL; gc = gc->next)
d1432 4
a1435 18
      struct bindata *d;

      ++c;

      d = (struct bindata *) reswr_alloc (sizeof *d);
      d->length = 14;
      d->data = (unsigned char *) reswr_alloc (d->length);

      put_16 (big_endian, gc->width, d->data);
      put_16 (big_endian, gc->height, d->data + 2);
      put_16 (big_endian, gc->planes, d->data + 4);
      put_16 (big_endian, gc->bits, d->data + 6);
      put_32 (big_endian, gc->bytes, d->data + 8);
      put_16 (big_endian, gc->index, d->data + 12);

      d->next = NULL;
      *pp = d;
      pp = &d->next;
d1437 1
a1437 4

  put_16 (big_endian, c, first->data + 4);

  return first;
d1442 2
a1443 2
static struct bindata *
res_to_bin_dialog (const struct dialog *dialog, int big_endian)
d1445 2
d1448 4
a1451 4
  struct bindata *first, **pp;
  unsigned long length;
  int off, c;
  struct dialog_control *dc;
d1453 2
d1457 2
a1458 6
  first = (struct bindata *) reswr_alloc (sizeof *first);
  first->length = dialogex ? 26 : 18;
  first->data = (unsigned char *) reswr_alloc (first->length);

  length = first->length;

d1461 6
a1466 3
      put_32 (big_endian, dialog->style, first->data);
      put_32 (big_endian, dialog->exstyle, first->data + 4);
      off = 8;
d1470 10
a1479 10
      put_16 (big_endian, 1, first->data);
      put_16 (big_endian, 0xffff, first->data + 2);

      if (dialog->ex == NULL)
	put_32 (big_endian, 0, first->data + 4);
      else
	put_32 (big_endian, dialog->ex->help, first->data + 4);
      put_32 (big_endian, dialog->exstyle, first->data + 8);
      put_32 (big_endian, dialog->style, first->data + 12);
      off = 16;
d1482 5
a1486 18
  put_16 (big_endian, dialog->x, first->data + off + 2);
  put_16 (big_endian, dialog->y, first->data + off + 4);
  put_16 (big_endian, dialog->width, first->data + off + 6);
  put_16 (big_endian, dialog->height, first->data + off + 8);

  pp = &first->next;

  *pp = resid_to_bin (dialog->menu, big_endian);
  length += (*pp)->length;
  pp = &(*pp)->next;

  *pp = resid_to_bin (dialog->class, big_endian);
  length += (*pp)->length;
  pp = &(*pp)->next;

  *pp = unicode_to_bin (dialog->caption, big_endian);
  length += (*pp)->length;
  pp = &(*pp)->next;
d1490 1
a1490 11
      struct bindata *d;

      d = (struct bindata *) reswr_alloc (sizeof *d);
      d->length = dialogex ? 6 : 2;
      d->data = (unsigned char *) reswr_alloc (d->length);

      length += d->length;

      put_16 (big_endian, dialog->pointsize, d->data);

      if (dialogex)
d1492 1
a1492 1
	  if (dialog->ex == NULL)
d1494 3
a1496 3
	      put_16 (big_endian, 0, d->data + 2);
	      put_8 (0, d->data + 4);
	      put_8 (1, d->data + 5);
d1500 6
a1505 3
	      put_16 (big_endian, dialog->ex->weight, d->data + 2);
	      put_8 (dialog->ex->italic, d->data + 4);
	      put_8 (dialog->ex->charset, d->data + 5);
d1508 2
a1509 7

      *pp = d;
      pp = &d->next;

      *pp = unicode_to_bin (dialog->font, big_endian);
      length += (*pp)->length;
      pp = &(*pp)->next;
d1511 1
a1511 3

  c = 0;
  for (dc = dialog->controls; dc != NULL; dc = dc->next)
d1513 1
a1513 12
      struct bindata *d;
      int dcoff;

      ++c;

      dword_align_bin (&pp, &length);

      d = (struct bindata *) reswr_alloc (sizeof *d);
      d->length = dialogex ? 24 : 18;
      d->data = (unsigned char *) reswr_alloc (d->length);

      length += d->length;
d1515 3
d1520 10
a1529 3
	  put_32 (big_endian, dc->style, d->data);
	  put_32 (big_endian, dc->exstyle, d->data + 4);
	  dcoff = 8;
d1533 1
a1533 5
	  put_32 (big_endian, dc->help, d->data);
	  put_32 (big_endian, dc->exstyle, d->data + 4);
	  put_32 (big_endian, dc->style, d->data + 8);
	  dcoff = 12;
	}
d1535 12
a1546 4
      put_16 (big_endian, dc->x, d->data + dcoff);
      put_16 (big_endian, dc->y, d->data + dcoff + 2);
      put_16 (big_endian, dc->width, d->data + dcoff + 4);
      put_16 (big_endian, dc->height, d->data + dcoff + 6);
d1548 2
a1549 4
      if (dialogex)
	put_32 (big_endian, dc->id, d->data + dcoff + 8);
      else
	put_16 (big_endian, dc->id, d->data + dcoff + 8);
d1551 2
a1552 20
      *pp = d;
      pp = &d->next;

      *pp = resid_to_bin (dc->class, big_endian);
      length += (*pp)->length;
      pp = &(*pp)->next;

      *pp = resid_to_bin (dc->text, big_endian);
      length += (*pp)->length;
      pp = &(*pp)->next;

      d = (struct bindata *) reswr_alloc (sizeof *d);
      d->length = 2;
      d->data = (unsigned char *) reswr_alloc (d->length);

      length += 2;

      d->next = NULL;
      *pp = d;
      pp = &d->next;
d1555 4
a1558 1
	put_16 (big_endian, 0, d->data);
d1561 10
a1570 10
	  unsigned long sublen;

	  dword_align_bin (&pp, &length);

	  *pp = res_to_bin_rcdata (dc->data, big_endian);
	  sublen = 0;
	  while (*pp != NULL)
	    {
	      sublen += (*pp)->length;
	      pp = &(*pp)->next;
d1572 3
d1576 7
a1582 4
	  put_16 (big_endian, sublen, d->data);

	  length += sublen;
	}
a1583 1
  put_16 (big_endian, c, first->data + off);
d1585 1
a1585 1
  return first;
d1589 2
a1590 3

static struct bindata *
res_to_bin_fontdir (const struct fontdir *fontdirs, int big_endian)
d1592 1
a1592 1
  struct bindata *first, **pp;
d1594 1
a1594 1
  const struct fontdir *fd;
d1596 2
a1597 3
  first = (struct bindata *) reswr_alloc (sizeof *first);
  first->length = 2;
  first->data = (unsigned char *) reswr_alloc (first->length);
d1599 12
a1610 2
  first->next = NULL;
  pp = &first->next;
d1612 1
a1612 2
  c = 0;
  for (fd = fontdirs; fd != NULL; fd = fd->next)
d1614 3
a1616 20
      struct bindata *d;

      ++c;

      d = (struct bindata *) reswr_alloc (sizeof *d);
      d->length = 2;
      d->data = (unsigned char *) reswr_alloc (d->length);

      put_16 (big_endian, fd->index, d->data);

      *pp = d;
      pp = &d->next;

      d = (struct bindata *) reswr_alloc (sizeof *d);
      d->length = fd->length;
      d->data = (unsigned char *) fd->data;

      d->next = NULL;
      *pp = d;
      pp = &d->next;
d1618 1
a1618 4

  put_16 (big_endian, c, first->data);

  return first;
d1623 2
a1624 2
static struct bindata *
res_to_bin_group_icon (const struct group_icon *group_icons, int big_endian)
d1626 2
a1627 1
  struct bindata *first, **pp;
d1629 1
a1629 1
  const struct group_icon *gi;
d1631 2
a1632 3
  first = (struct bindata *) reswr_alloc (sizeof *first);
  first->length = 6;
  first->data = (unsigned char *) reswr_alloc (first->length);
d1634 3
a1636 2
  put_16 (big_endian, 0, first->data);
  put_16 (big_endian, 1, first->data + 2);
d1638 14
a1651 2
  first->next = NULL;
  pp = &first->next;
d1653 1
a1653 2
  c = 0;
  for (gi = group_icons; gi != NULL; gi = gi->next)
d1655 4
a1658 20
      struct bindata *d;

      ++c;

      d = (struct bindata *) reswr_alloc (sizeof *d);
      d->length = 14;
      d->data = (unsigned char *) reswr_alloc (d->length);

      d->data[0] = gi->width;
      d->data[1] = gi->height;
      d->data[2] = gi->colors;
      d->data[3] = 0;
      put_16 (big_endian, gi->planes, d->data + 4);
      put_16 (big_endian, gi->bits, d->data + 6);
      put_32 (big_endian, gi->bytes, d->data + 8);
      put_16 (big_endian, gi->index, d->data + 12);

      d->next = NULL;
      *pp = d;
      pp = &d->next;
d1660 1
a1660 4

  put_16 (big_endian, c, first->data + 4);

  return first;
d1665 2
a1666 2
static struct bindata *
res_to_bin_menu (const struct menu *menu, int big_endian)
a1668 1
  struct bindata *d;
d1672 19
a1690 4
  d = (struct bindata *) reswr_alloc (sizeof *d);
  d->length = menuex ? 8 : 4;
  d->data = (unsigned char *) reswr_alloc (d->length);

d1693 1
a1693 4
      put_16 (big_endian, 0, d->data);
      put_16 (big_endian, 0, d->data + 2);

      d->next = res_to_bin_menuitems (menu->items, big_endian);
d1697 1
a1697 5
      put_16 (big_endian, 1, d->data);
      put_16 (big_endian, 4, d->data + 2);
      put_32 (big_endian, menu->help, d->data + 4);

      d->next = res_to_bin_menuexitems (menu->items, big_endian);
d1699 1
a1699 2

  return d;
d1704 2
a1705 2
static struct bindata *
res_to_bin_menuitems (const struct menuitem *items, int big_endian)
d1707 1
a1707 5
  struct bindata *first, **pp;
  const struct menuitem *mi;

  first = NULL;
  pp = &first;
d1711 1
a1711 1
      struct bindata *d;
a1713 4
      d = (struct bindata *) reswr_alloc (sizeof *d);
      d->length = mi->popup == NULL ? 4 : 2;
      d->data = (unsigned char *) reswr_alloc (d->length);

d1720 3
a1722 2
      put_16 (big_endian, flags, d->data);

d1724 6
a1729 1
	put_16 (big_endian, mi->id, d->data + 2);
d1731 1
a1731 5
      *pp = d;
      pp = &d->next;

      *pp = unicode_to_bin (mi->text, big_endian);
      pp = &(*pp)->next;
d1735 1
a1735 3
	  *pp = res_to_bin_menuitems (mi->popup, big_endian);
	  while (*pp != NULL)
	    pp = &(*pp)->next;
d1738 1
a1738 2

  return first;
d1743 2
a1744 2
static struct bindata *
res_to_bin_menuexitems (const struct menuitem *items, int big_endian)
d1746 2
a1747 8
  struct bindata *first, **pp;
  unsigned long length;
  const struct menuitem *mi;

  first = NULL;
  pp = &first;

  length = 0;
d1751 1
a1751 1
      struct bindata *d;
d1754 1
a1754 11
      dword_align_bin (&pp, &length);

      d = (struct bindata *) reswr_alloc (sizeof *d);
      d->length = 12;
      d->data = (unsigned char *) reswr_alloc (d->length);

      length += 12;

      put_32 (big_endian, mi->type, d->data);
      put_32 (big_endian, mi->state, d->data + 4);
      put_16 (big_endian, mi->id, d->data + 8);
a1760 1
      put_16 (big_endian, flags, d->data + 10);
d1762 9
a1770 2
      *pp = d;
      pp = &d->next;
d1772 1
a1772 3
      *pp = unicode_to_bin (mi->text, big_endian);
      length += (*pp)->length;
      pp = &(*pp)->next;
d1776 1
a1776 1
	  dword_align_bin (&pp, &length);
d1778 1
a1778 3
	  d = (struct bindata *) reswr_alloc (sizeof *d);
	  d->length = 4;
	  d->data = (unsigned char *) reswr_alloc (d->length);
d1780 1
a1780 7
	  put_32 (big_endian, mi->help, d->data);

	  *pp = d;
	  pp = &d->next;

	  *pp = res_to_bin_menuexitems (mi->popup, big_endian);
	  while (*pp != NULL)
d1782 2
a1783 2
	      length += (*pp)->length;
	      pp = &(*pp)->next;
d1785 2
d1789 1
a1789 2

  return first;
d1793 1
a1793 1
   other information which happens to be stored in rcdata_item lists
d1796 2
a1797 2
static struct bindata *
res_to_bin_rcdata (const struct rcdata_item *items, int big_endian)
d1799 1
a1799 5
  struct bindata *first, **pp;
  const struct rcdata_item *ri;

  first = NULL;
  pp = &first;
d1803 1
a1803 4
      struct bindata *d;

      d = (struct bindata *) reswr_alloc (sizeof *d);

a1807 1

d1809 1
a1809 3
	  d->length = 2;
	  d->data = (unsigned char *) reswr_alloc (d->length);
	  put_16 (big_endian, ri->u.word, d->data);
a1810 1

d1812 1
a1812 3
	  d->length = 4;
	  d->data = (unsigned char *) reswr_alloc (d->length);
	  put_32 (big_endian, ri->u.dword, d->data);
a1813 1

d1815 23
a1837 2
	  d->length = ri->u.string.length;
	  d->data = (unsigned char *) ri->u.string.s;
a1838 1

d1841 1
a1841 1
	    unsigned long i;
d1843 1
a1843 2
	    d->length = ri->u.wstring.length * 2;
	    d->data = (unsigned char *) reswr_alloc (d->length);
d1845 1
a1845 2
	      put_16 (big_endian, ri->u.wstring.w[i], d->data + i * 2);
	    break;
d1847 1
a1847 1

d1849 1
a1849 2
	  d->length = ri->u.buffer.length;
	  d->data = (unsigned char *) ri->u.buffer.data;
d1852 3
a1854 4

      d->next = NULL;
      *pp = d;
      pp = &d->next;
d1856 1
a1856 2

  return first;
d1861 3
a1863 2
static struct bindata *
res_to_bin_stringtable (const struct stringtable *st, int big_endian)
a1864 1
  struct bindata *first, **pp;
a1866 3
  first = NULL;
  pp = &first;

d1869 1
a1869 2
      int slen, j;
      struct bindata *d;
d1872 1
a1872 1
      slen = st->strings[i].length;
d1875 5
a1879 3
      d = (struct bindata *) reswr_alloc (sizeof *d);
      d->length = 2 + slen * 2;
      d->data = (unsigned char *) reswr_alloc (d->length);
d1881 2
a1882 1
      put_16 (big_endian, slen, d->data);
d1885 4
a1888 5
	put_16 (big_endian, s[j], d->data + 2 + j * 2);

      d->next = NULL;
      *pp = d;
      pp = &d->next;
d1890 1
a1890 2

  return first;
d1896 2
a1897 2
static struct bindata *
string_to_unicode_bin (const char *s, int big_endian)
d1899 1
a1899 2
  size_t len, i;
  struct bindata *d;
d1901 1
a1901 1
  len = strlen (s);
d1903 4
a1906 3
  d = (struct bindata *) reswr_alloc (sizeof *d);
  d->length = len * 2 + 2;
  d->data = (unsigned char *) reswr_alloc (d->length);
d1908 1
a1908 3
  for (i = 0; i < len; i++)
    put_16 (big_endian, s[i], d->data + i * 2);
  put_16 (big_endian, 0, d->data + i * 2);
d1910 7
a1916 3
  d->next = NULL;

  return d;
d1919 2
a1920 4
/* Convert a versioninfo resource to binary.  */

static struct bindata *
res_to_bin_versioninfo (const struct versioninfo *versioninfo, int big_endian)
d1922 12
a1933 3
  struct bindata *first, **pp;
  unsigned long length;
  struct ver_info *vi;
d1935 12
a1946 3
  first = (struct bindata *) reswr_alloc (sizeof *first);
  first->length = 6;
  first->data = (unsigned char *) reswr_alloc (first->length);
d1948 2
a1949 1
  length = 6;
d1951 1
a1951 12
  if (versioninfo->fixed == NULL)
    put_16 (big_endian, 0, first->data + 2);
  else
    put_16 (big_endian, 52, first->data + 2);

  put_16 (big_endian, 0, first->data + 4);

  pp = &first->next;

  *pp = string_to_unicode_bin ("VS_VERSION_INFO", big_endian);
  length += (*pp)->length;
  pp = &(*pp)->next;
d1953 13
a1965 1
  dword_align_bin (&pp, &length);
d1969 4
a1972 8
      const struct fixed_versioninfo *fi;
      struct bindata *d;

      d = (struct bindata *) reswr_alloc (sizeof *d);
      d->length = 52;
      d->data = (unsigned char *) reswr_alloc (d->length);

      length += 52;
d1975 16
a1990 18

      put_32 (big_endian, 0xfeef04bd, d->data);
      put_32 (big_endian, 0x10000, d->data + 4);
      put_32 (big_endian, fi->file_version_ms, d->data + 8);
      put_32 (big_endian, fi->file_version_ls, d->data + 12);
      put_32 (big_endian, fi->product_version_ms, d->data + 16);
      put_32 (big_endian, fi->product_version_ls, d->data + 20);
      put_32 (big_endian, fi->file_flags_mask, d->data + 24);
      put_32 (big_endian, fi->file_flags, d->data + 28);
      put_32 (big_endian, fi->file_os, d->data + 32);
      put_32 (big_endian, fi->file_type, d->data + 36);
      put_32 (big_endian, fi->file_subtype, d->data + 40);
      put_32 (big_endian, fi->file_date_ms, d->data + 44);
      put_32 (big_endian, fi->file_date_ls, d->data + 48);

      d->next = NULL;
      *pp = d;
      pp = &d->next;
d1995 2
a1996 4
      struct bindata *vid;
      unsigned long vilen;

      dword_align_bin (&pp, &length);
d1998 1
a1998 3
      vid = (struct bindata *) reswr_alloc (sizeof *vid);
      vid->length = 6;
      vid->data = (unsigned char *) reswr_alloc (vid->length);
d2000 1
a2000 2
      length += 6;
      vilen = 6;
d2002 1
a2002 5
      put_16 (big_endian, 0, vid->data + 2);
      put_16 (big_endian, 0, vid->data + 4);

      *pp = vid;
      pp = &vid->next;
a2007 1

d2010 12
a2021 32
	    unsigned long hold, vslen;
	    struct bindata *vsd;
	    const struct ver_stringinfo *vs;

	    *pp = string_to_unicode_bin ("StringFileInfo", big_endian);
	    length += (*pp)->length;
	    vilen += (*pp)->length;
	    pp = &(*pp)->next;

	    hold = length;
	    dword_align_bin (&pp, &length);
	    vilen += length - hold;

	    vsd = (struct bindata *) reswr_alloc (sizeof *vsd);
	    vsd->length = 6;
	    vsd->data = (unsigned char *) reswr_alloc (vsd->length);

	    length += 6;
	    vilen += 6;
	    vslen = 6;

	    put_16 (big_endian, 0, vsd->data + 2);
	    put_16 (big_endian, 0, vsd->data + 4);

	    *pp = vsd;
	    pp = &vsd->next;

	    *pp = unicode_to_bin (vi->u.string.language, big_endian);
	    length += (*pp)->length;
	    vilen += (*pp)->length;
	    vslen += (*pp)->length;
	    pp = &(*pp)->next;
d2025 2
a2026 2
		struct bindata *vssd;
		unsigned long vsslen;
d2028 1
a2028 39
		hold = length;
		dword_align_bin (&pp, &length);
		vilen += length - hold;
		vslen += length - hold;

		vssd = (struct bindata *) reswr_alloc (sizeof *vssd);
		vssd->length = 6;
		vssd->data = (unsigned char *) reswr_alloc (vssd->length);

		length += 6;
		vilen += 6;
		vslen += 6;
		vsslen = 6;

		put_16 (big_endian, 1, vssd->data + 4);

		*pp = vssd;
		pp = &vssd->next;

		*pp = unicode_to_bin (vs->key, big_endian);
		length += (*pp)->length;
		vilen += (*pp)->length;
		vslen += (*pp)->length;
		vsslen += (*pp)->length;
		pp = &(*pp)->next;

		hold = length;
		dword_align_bin (&pp, &length);
		vilen += length - hold;
		vslen += length - hold;
		vsslen += length - hold;

		*pp = unicode_to_bin (vs->value, big_endian);
		put_16 (big_endian, (*pp)->length / 2, vssd->data + 2);
		length += (*pp)->length;
		vilen += (*pp)->length;
		vslen += (*pp)->length;
		vsslen += (*pp)->length;
		pp = &(*pp)->next;
d2030 25
a2054 1
		put_16 (big_endian, vsslen, vssd->data);
a2055 3

	    put_16 (big_endian, vslen, vsd->data);

d2061 10
a2070 36
	    unsigned long hold, vvlen, vvvlen;
	    struct bindata *vvd;
	    const struct ver_varinfo *vv;

	    *pp = string_to_unicode_bin ("VarFileInfo", big_endian);
	    length += (*pp)->length;
	    vilen += (*pp)->length;
	    pp = &(*pp)->next;

	    hold = length;
	    dword_align_bin (&pp, &length);
	    vilen += length - hold;

	    vvd = (struct bindata *) reswr_alloc (sizeof *vvd);
	    vvd->length = 6;
	    vvd->data = (unsigned char *) reswr_alloc (vvd->length);

	    length += 6;
	    vilen += 6;
	    vvlen = 6;

	    put_16 (big_endian, 0, vvd->data + 4);

	    *pp = vvd;
	    pp = &vvd->next;

	    *pp = unicode_to_bin (vi->u.var.key, big_endian);
	    length += (*pp)->length;
	    vilen += (*pp)->length;
	    vvlen += (*pp)->length;
	    pp = &(*pp)->next;

	    hold = length;
	    dword_align_bin (&pp, &length);
	    vilen += length - hold;
	    vvlen += length - hold;
d2072 5
a2076 1
	    vvvlen = 0;
d2080 9
a2088 17
		struct bindata *vvsd;

		vvsd = (struct bindata *) reswr_alloc (sizeof *vvsd);
		vvsd->length = 4;
		vvsd->data = (unsigned char *) reswr_alloc (vvsd->length);

		length += 4;
		vilen += 4;
		vvlen += 4;
		vvvlen += 4;

		put_16 (big_endian, vv->language, vvsd->data);
		put_16 (big_endian, vv->charset, vvsd->data + 2);

		vvsd->next = NULL;
		*pp = vvsd;
		pp = &vvsd->next;
d2090 8
a2097 3

	    put_16 (big_endian, vvlen, vvd->data);
	    put_16 (big_endian, vvvlen, vvd->data + 2);
d2103 8
a2110 1
      put_16 (big_endian, vilen, vid->data);
d2113 10
a2122 3
  put_16 (big_endian, length, first->data);

  return first;
d2127 7
a2133 12
static struct bindata *
res_to_bin_generic (unsigned long length, const unsigned char *data)
{
  struct bindata *d;

  d = (struct bindata *) reswr_alloc (sizeof *d);
  d->length = length;
  d->data = (unsigned char *) data;

  d->next = NULL;

  return d;
@


1.10
log
@	* resbin.c: Avoid duplicating constants in calls to reswr_alloc.
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2002, 2003
d27 1
d29 1
a30 1
#include "libiberty.h"
@


1.9
log
@* resbin.c (res_to_bin_accelerator): Place the terminating NUL at the correct
  location in the bindata structure.
@
text
@d1334 1
a1334 1
      d->data = (unsigned char *) reswr_alloc (4);
d1411 1
a1411 1
      d->data = (unsigned char *) reswr_alloc (8);
d1437 1
a1437 1
  d->data = (unsigned char *) reswr_alloc (4);
d1462 1
a1462 1
  first->data = (unsigned char *) reswr_alloc (6);
d1479 1
a1479 1
      d->data = (unsigned char *) reswr_alloc (14);
d1645 1
a1645 1
      d->data = (unsigned char *) reswr_alloc (2);
d1690 1
a1690 1
  first->data = (unsigned char *) reswr_alloc (2);
d1704 1
a1704 1
      d->data = (unsigned char *) reswr_alloc (2);
d1736 1
a1736 1
  first->data = (unsigned char *) reswr_alloc (6);
d1753 1
a1753 1
      d->data = (unsigned char *) reswr_alloc (14);
d1878 1
a1878 1
      d->data = (unsigned char *) reswr_alloc (12);
d1906 1
a1906 1
	  d->data = (unsigned char *) reswr_alloc (4);
d1951 1
a1951 1
	  d->data = (unsigned char *) reswr_alloc (2);
d1957 1
a1957 1
	  d->data = (unsigned char *) reswr_alloc (4);
d2063 1
a2063 1
  first->data = (unsigned char *) reswr_alloc (6);
d2089 1
a2089 1
      d->data = (unsigned char *) reswr_alloc (52);
d2123 1
a2123 1
      vid->data = (unsigned char *) reswr_alloc (6);
d2156 1
a2156 1
	    vsd->data = (unsigned char *) reswr_alloc (6);
d2186 1
a2186 1
		vssd->data = (unsigned char *) reswr_alloc (6);
d2244 1
a2244 1
	    vvd->data = (unsigned char *) reswr_alloc (6);
d2274 1
a2274 1
		vvsd->data = (unsigned char *) reswr_alloc (4);
@


1.9.2.1
log
@Merge changes between binutils-csl-2_17-branchpoint and
binutils-2_17, except for the addition of generated files to CVS.
@
text
@d1334 1
a1334 1
      d->data = (unsigned char *) reswr_alloc (d->length);
d1411 1
a1411 1
      d->data = (unsigned char *) reswr_alloc (d->length);
d1437 1
a1437 1
  d->data = (unsigned char *) reswr_alloc (d->length);
d1462 1
a1462 1
  first->data = (unsigned char *) reswr_alloc (first->length);
d1479 1
a1479 1
      d->data = (unsigned char *) reswr_alloc (d->length);
d1645 1
a1645 1
      d->data = (unsigned char *) reswr_alloc (d->length);
d1690 1
a1690 1
  first->data = (unsigned char *) reswr_alloc (first->length);
d1704 1
a1704 1
      d->data = (unsigned char *) reswr_alloc (d->length);
d1736 1
a1736 1
  first->data = (unsigned char *) reswr_alloc (first->length);
d1753 1
a1753 1
      d->data = (unsigned char *) reswr_alloc (d->length);
d1878 1
a1878 1
      d->data = (unsigned char *) reswr_alloc (d->length);
d1906 1
a1906 1
	  d->data = (unsigned char *) reswr_alloc (d->length);
d1951 1
a1951 1
	  d->data = (unsigned char *) reswr_alloc (d->length);
d1957 1
a1957 1
	  d->data = (unsigned char *) reswr_alloc (d->length);
d2063 1
a2063 1
  first->data = (unsigned char *) reswr_alloc (first->length);
d2089 1
a2089 1
      d->data = (unsigned char *) reswr_alloc (d->length);
d2123 1
a2123 1
      vid->data = (unsigned char *) reswr_alloc (vid->length);
d2156 1
a2156 1
	    vsd->data = (unsigned char *) reswr_alloc (vsd->length);
d2186 1
a2186 1
		vssd->data = (unsigned char *) reswr_alloc (vssd->length);
d2244 1
a2244 1
	    vvd->data = (unsigned char *) reswr_alloc (vvd->length);
d2274 1
a2274 1
		vvsd->data = (unsigned char *) reswr_alloc (vvsd->length);
@


1.8
log
@Update FSF address
@
text
@d1418 1
a1418 1
      put_16 (big_endian, 0, d->data + 8);
@


1.7
log
@	* addr2line.c: Convert to ISO C90 prototypes, change PTR, remove
	unneeded (void *) casts.
	* ar.c: Likewise.
	* arlex.l: Likewise.
	* arparse.y: Likewise.
	* arsup.c: Likewise.
	* binemul.c: Likewise.
	* binemul.h: Likewise.
	* bucomm.c: Likewise.
	* bucomm.h: Likewise.
	* budbg.h: Likewise.
	* budemang.c: Likewise.
	* budemang.h: Likewise.
	* coffdump.c: Likewise.
	* coffgrok.c: Likewise.
	* cxxfilt.c: Likewise.
	* debug.c: Likewise.
	* debug.h: Likewise.
	* deflex.l: Likewise.
	* dlltool.c: Likewise.
	* dlltool.h: Likewise.
	* dllwrap.c: Likewise.
	* emul_aix.c: Likewise.
	* filemode.c: Likewise.
	* ieee.c: Likewise.
	* nlmconv.c: Likewise.
	* nlmconv.h: Likewise.
	* nlmheader.y: Likewise.
	* nm.c: Likewise.
	* prdbg.c: Likewise.
	* rclex.l: Likewise.
	* rcparse.y: Likewise.
	* rdcoff.c: Likewise.
	* rddbg.c: Likewise.
	* rename.c: Likewise.
	* resbin.c: Likewise.
	* rescoff.c: Likewise.
	* resrc.c: Likewise.
	* size.c: Likewise.
	* srconv.c: Likewise.
	* stabs.c: Likewise.
	* strings.c: Likewise.
	* sysdump.c: Likewise.
	* sysinfo.y: Likewise.
	* syslex.l: Likewise.
	* unwind-ia64.c: Likewise.
	* unwind-ia64.h: Likewise.
	* version.c: Likewise.
	* windres.c: Likewise.
	* windres.h: Likewise.
	* winduni.c: Likewise.
	* wrstabs.c: Likewise.
@
text
@d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.6
log
@	* rdcoff.c: Fix formatting.
	* rddbg.c: Likewise.
	* readelf.c: Likewise.
	* rename.c: Likewise.
	* resbin.c: Likewise.
	* resrc.c: Likewise.
	* resres.c: Likewise.
@
text
@d2 2
a3 1
   Copyright 1997, 1998, 1999, 2002 Free Software Foundation, Inc.
d40 2
a41 1
static void toosmall PARAMS ((const char *));
d43 1
a43 1
  PARAMS ((const unsigned char *, unsigned long, int, int *));
d45 1
a45 1
  PARAMS ((struct res_id *, const unsigned char *, unsigned long, int));
d47 1
a47 1
  PARAMS ((enum res_type, const unsigned char *, unsigned long));
d49 1
a49 1
  PARAMS ((const unsigned char *, unsigned long, int));
d51 1
a51 1
  PARAMS ((const unsigned char *, unsigned long, int));
d53 1
a53 1
  PARAMS ((const unsigned char *, unsigned long, int, int *));
d55 1
a55 1
  PARAMS ((const unsigned char *, unsigned long, int, int *));
d57 1
a57 1
  PARAMS ((const unsigned char *, unsigned long, int));
d59 1
a59 1
  PARAMS ((const unsigned char *, unsigned long, int));
d61 1
a61 1
  PARAMS ((const unsigned char *, unsigned long, int));
d63 1
a63 1
  PARAMS ((const unsigned char *, unsigned long, int));
d65 1
a65 1
  PARAMS ((const unsigned char *, unsigned long, int));
d67 1
a67 1
  PARAMS ((const unsigned char *, unsigned long, int));
d69 1
a69 1
  PARAMS ((const unsigned char *, unsigned long, int));
d71 1
a71 1
  PARAMS ((const unsigned char *, unsigned long, int));
d73 1
a73 1
  PARAMS ((const unsigned char *, unsigned long, int));
d75 2
a76 2
  PARAMS ((const unsigned char *, unsigned long, int, const char *,
	   unichar **, int *, int *, int *, int *));
d84 2
a85 5
bin_to_res (type, data, length, big_endian)
     struct res_id type;
     const unsigned char *data;
     unsigned long length;
     int big_endian;
d130 1
a130 2
toosmall (msg)
     const char *msg;
d138 2
a139 5
get_unicode (data, length, big_endian, retlen)
     const unsigned char *data;
     unsigned long length;
     int big_endian;
     int *retlen;
d169 2
a170 5
get_resid (id, data, length, big_endian)
     struct res_id *id;
     const unsigned char *data;
     unsigned long length;
     int big_endian;
d198 2
a199 4
bin_to_res_generic (type, data, length)
     enum res_type type;
     const unsigned char *data;
     unsigned long length;
d214 2
a215 4
bin_to_res_cursor (data, length, big_endian)
     const unsigned char *data;
     unsigned long length;
     int big_endian;
d239 2
a240 4
bin_to_res_menu (data, length, big_endian)
     const unsigned char *data;
     unsigned long length;
     int big_endian;
d289 2
a290 5
bin_to_res_menuitems (data, length, big_endian, read)
     const unsigned char *data;
     unsigned long length;
     int big_endian;
     int *read;
d367 2
a368 5
bin_to_res_menuexitems (data, length, big_endian, read)
     const unsigned char *data;
     unsigned long length;
     int big_endian;
     int *read;
d442 2
a443 4
bin_to_res_dialog (data, length, big_endian)
     const unsigned char *data;
     unsigned long length;
     int big_endian;
d628 2
a629 4
bin_to_res_string (data, length, big_endian)
     const unsigned char *data;
     unsigned long length;
     int big_endian;
d675 2
a676 4
bin_to_res_fontdir (data, length, big_endian)
     const unsigned char *data;
     unsigned long length;
     int big_endian;
d745 2
a746 4
bin_to_res_accelerators (data, length, big_endian)
     const unsigned char *data;
     unsigned long length;
     int big_endian;
d788 2
a789 4
bin_to_res_rcdata (data, length, big_endian)
     const unsigned char *data;
     unsigned long length;
     int big_endian ATTRIBUTE_UNUSED;
d811 2
a812 4
bin_to_res_group_cursor (data, length, big_endian)
     const unsigned char *data;
     unsigned long length;
     int big_endian;
d867 2
a868 4
bin_to_res_group_icon (data, length, big_endian)
     const unsigned char *data;
     unsigned long length;
     int big_endian;
d927 3
a929 11
get_version_header (data, length, big_endian, key, pkey, len, vallen, type,
		    off)
     const unsigned char *data;
     unsigned long length;
     int big_endian;
     const char *key;
     unichar **pkey;
     int *len;
     int *vallen;
     int *type;
     int *off;
d976 2
a977 4
bin_to_res_version (data, length, big_endian)
     const unsigned char *data;
     unsigned long length;
     int big_endian;
d1195 2
a1196 4
bin_to_res_userdata (data, length, big_endian)
     const unsigned char *data;
     unsigned long length;
     int big_endian ATTRIBUTE_UNUSED;
d1223 3
a1225 3
static void dword_align_bin PARAMS ((struct bindata ***, unsigned long *));
static struct bindata *resid_to_bin PARAMS ((struct res_id, int));
static struct bindata *unicode_to_bin PARAMS ((const unichar *, int));
d1227 1
a1227 1
  PARAMS ((const struct accelerator *, int));
d1229 1
a1229 1
  PARAMS ((const struct cursor *, int));
d1231 1
a1231 1
  PARAMS ((const struct group_cursor *, int));
d1233 1
a1233 1
  PARAMS ((const struct dialog *, int));
d1235 1
a1235 1
  PARAMS ((const struct fontdir *, int));
d1237 1
a1237 1
  PARAMS ((const struct group_icon *, int));
d1239 1
a1239 1
  PARAMS ((const struct menu *, int));
d1241 1
a1241 1
  PARAMS ((const struct menuitem *, int));
d1243 1
a1243 1
  PARAMS ((const struct menuitem *, int));
d1245 1
a1245 1
  PARAMS ((const struct rcdata_item *, int));
d1247 2
a1248 2
  PARAMS ((const struct stringtable *, int));
static struct bindata *string_to_unicode_bin PARAMS ((const char *, int));
d1250 1
a1250 1
  PARAMS ((const struct versioninfo *, int));
d1252 1
a1252 1
  PARAMS ((unsigned long, const unsigned char *));
d1257 1
a1257 3
res_to_bin (res, big_endian)
     const struct res_resource *res;
     int big_endian;
d1299 1
a1299 3
dword_align_bin (ppp, length)
     struct bindata ***ppp;
     unsigned long *length;
d1325 1
a1325 3
resid_to_bin (id, big_endian)
     struct res_id id;
     int big_endian;
d1358 1
a1358 3
unicode_to_bin (str, big_endian)
     const unichar *str;
     int big_endian;
d1396 2
a1397 3
res_to_bin_accelerator (accelerators, big_endian)
     const struct accelerator *accelerators;
     int big_endian;
d1431 1
a1431 3
res_to_bin_cursor (c, big_endian)
     const struct cursor *c;
     int big_endian;
d1453 2
a1454 3
res_to_bin_group_cursor (group_cursors, big_endian)
     const struct group_cursor *group_cursors;
     int big_endian;
d1501 1
a1501 3
res_to_bin_dialog (dialog, big_endian)
     const struct dialog *dialog;
     int big_endian;
d1682 1
a1682 3
res_to_bin_fontdir (fontdirs, big_endian)
     const struct fontdir *fontdirs;
     int big_endian;
d1728 1
a1728 3
res_to_bin_group_icon (group_icons, big_endian)
     const struct group_icon *group_icons;
     int big_endian;
d1777 1
a1777 3
res_to_bin_menu (menu, big_endian)
     const struct menu *menu;
     int big_endian;
d1810 1
a1810 3
res_to_bin_menuitems (items, big_endian)
     const struct menuitem *items;
     int big_endian;
d1858 1
a1858 3
res_to_bin_menuexitems (items, big_endian)
     const struct menuitem *items;
     int big_endian;
d1930 1
a1930 3
res_to_bin_rcdata (items, big_endian)
     const struct rcdata_item *items;
     int big_endian;
d1994 1
a1994 3
res_to_bin_stringtable (st, big_endian)
     const struct stringtable *st;
     int big_endian;
d2032 1
a2032 3
string_to_unicode_bin (s, big_endian)
     const char *s;
     int big_endian;
d2055 1
a2055 3
res_to_bin_versioninfo (versioninfo, big_endian)
     const struct versioninfo *versioninfo;
     int big_endian;
d2307 1
a2307 3
res_to_bin_generic (length, data)
     unsigned long length;
     const unsigned char *data;
@


1.5
log
@Allow two to five parameter in FONT statement of DIALOGEX resources.
@
text
@d490 1
a490 1
      
d521 1
a521 1
  if (sublen == 0) 
d598 1
a598 1
        dc->id = get_32 (big_endian, data + off + 8);
d600 1
a600 1
        dc->id = get_16 (big_endian, data + off + 8);
d632 1
a632 1
	  off += datalen;	  
d1222 1
a1222 1
      pp = &vi->next;      
d1233 1
a1233 1
  return r;  
d1688 1
a1688 1
        put_32 (big_endian, dc->id, d->data + dcoff + 8);
d1690 1
a1690 1
        put_16 (big_endian, dc->id, d->data + dcoff + 8);
d1779 1
a1779 1
      pp = &d->next;      
d1784 1
a1784 1
  return first;  
d2096 1
a2096 1
      pp = &d->next;      
d2125 1
a2125 1
  return d;  
d2290 1
a2290 1
 		put_16 (big_endian, (*pp)->length / 2, vssd->data + 2);
@


1.4
log
@Don't print empty dialog caption.
Add testcase.
@
text
@d33 1
d532 1
d548 2
a549 1
	  d->ex->italic = get_16 (big_endian, data + off + 2);
d1263 1
d1633 2
a1634 1
	      put_16 (big_endian, 0, d->data + 4);
d1639 2
a1640 1
	      put_16 (big_endian, dialog->ex->italic, d->data + 4);
@


1.3
log
@Use signature to identify DIALOGEX.
Add testcase.
@
text
@d520 2
@


1.2
log
@Fix typos in ChangeLogs and update copyright notices
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999 Free Software Foundation, Inc.
d71 3
d466 1
a466 1
  int version;
d478 2
a479 2
  version = get_16 (big_endian, data);
  if (version != 1)
d488 5
a492 5
      int signature;

      signature = get_16 (big_endian, data + 2);
      if (signature != 0xffff)
	fatal (_("unexpected dialog signature %d"), signature);
d814 1
a814 1
     int big_endian;
d1025 1
a1025 1
		      (unichar *) NULL, &verlen, &vallen, &type, &off);
d1097 1
a1097 1
			      (unichar *) NULL, &verlen, &vallen, &type,
d1169 1
a1169 1
			      (unichar *) NULL, &verlen, &vallen, &type,
d1237 1
a1237 1
     int big_endian;
@


1.2.2.1
log
@Merge from mainline
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999, 2002 Free Software Foundation, Inc.
a32 1
#define get_8(s)      (*((unsigned char *)(s)))
a70 3
static void get_version_header
  PARAMS ((const unsigned char *, unsigned long, int, const char *,
	   unichar **, int *, int *, int *, int *));
d463 1
a463 1
  int signature;
d475 2
a476 2
  signature = get_16 (big_endian, data + 2);
  if (signature != 0xffff)
d485 1
a485 1
      int version;
d487 3
a489 3
      version = get_16 (big_endian, data);
      if (version != 1)
	fatal (_("unexpected DIALOGEX version %d"), version);
a516 2
  if (sublen == 0) 
    d->caption = NULL;
a525 1
	  d->ex->charset = 1; /* Default charset.  */
d541 1
a541 2
	  d->ex->italic = get_8 (data + off + 2);
	  d->ex->charset = get_8 (data + off + 3);
d811 1
a811 1
     int big_endian ATTRIBUTE_UNUSED;
d1022 1
a1022 1
		      (unichar **) NULL, &verlen, &vallen, &type, &off);
d1094 1
a1094 1
			      (unichar **) NULL, &verlen, &vallen, &type,
d1166 1
a1166 1
			      (unichar **) NULL, &verlen, &vallen, &type,
d1234 1
a1234 1
     int big_endian ATTRIBUTE_UNUSED;
a1254 1
#define put_8(v, s)      (*((unsigned char *) (s)) = (unsigned char) (v))
d1624 1
a1624 2
	      put_8 (0, d->data + 4);
	      put_8 (1, d->data + 5);
d1629 1
a1629 2
	      put_8 (dialog->ex->italic, d->data + 4);
	      put_8 (dialog->ex->charset, d->data + 5);
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1997, 1998 Free Software Foundation, Inc.
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@


1.1.1.1.4.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 1999 Free Software Foundation, Inc.
@


