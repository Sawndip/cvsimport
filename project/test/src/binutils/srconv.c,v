head	1.28;
access;
symbols
	binutils-2_24-branch:1.27.0.8
	binutils-2_24-branchpoint:1.27
	binutils-2_21_1:1.26
	binutils-2_23_2:1.27
	binutils-2_23_1:1.27
	binutils-2_23:1.27
	binutils-2_23-branch:1.27.0.6
	binutils-2_23-branchpoint:1.27
	binutils-2_22_branch:1.27.0.4
	binutils-2_22:1.27
	binutils-2_22-branch:1.27.0.2
	binutils-2_22-branchpoint:1.27
	binutils-2_21:1.26
	binutils-2_21-branch:1.26.0.2
	binutils-2_21-branchpoint:1.26
	binutils-2_20_1:1.25
	binutils-2_20:1.25
	binutils-arc-20081103-branch:1.24.0.6
	binutils-arc-20081103-branchpoint:1.24
	binutils-2_20-branch:1.25.0.4
	binutils-2_20-branchpoint:1.25
	dje-cgen-play1-branch:1.25.0.2
	dje-cgen-play1-branchpoint:1.25
	arc-20081103-branch:1.24.0.4
	arc-20081103-branchpoint:1.24
	binutils-2_19_1:1.24
	binutils-2_19:1.24
	binutils-2_19-branch:1.24.0.2
	binutils-2_19-branchpoint:1.24
	binutils-2_18:1.23
	binutils-2_18-branch:1.23.0.2
	binutils-2_18-branchpoint:1.23
	binutils-csl-coldfire-4_1-32:1.18.2.1
	binutils-csl-sourcerygxx-4_1-32:1.18.2.1
	binutils-csl-innovasic-fido-3_4_4-33:1.18.2.1
	binutils-csl-sourcerygxx-3_4_4-32:1.15.6.1
	binutils-csl-coldfire-4_1-30:1.18.2.1
	binutils-csl-sourcerygxx-4_1-30:1.18.2.1
	binutils-csl-coldfire-4_1-28:1.18.2.1
	binutils-csl-sourcerygxx-4_1-29:1.18.2.1
	binutils-csl-sourcerygxx-4_1-28:1.18.2.1
	binutils-csl-arm-2006q3-27:1.18.2.1
	binutils-csl-sourcerygxx-4_1-27:1.18.2.1
	binutils-csl-arm-2006q3-26:1.18.2.1
	binutils-csl-sourcerygxx-4_1-26:1.18.2.1
	binutils-csl-sourcerygxx-4_1-25:1.18.2.1
	binutils-csl-sourcerygxx-4_1-24:1.18
	binutils-csl-sourcerygxx-4_1-23:1.18
	binutils-csl-sourcerygxx-4_1-21:1.18
	binutils-csl-arm-2006q3-21:1.18
	binutils-csl-sourcerygxx-4_1-22:1.18
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.18
	binutils-csl-sourcerygxx-4_1-20:1.18
	binutils-csl-arm-2006q3-19:1.18
	binutils-csl-sourcerygxx-4_1-19:1.18
	binutils-csl-sourcerygxx-4_1-18:1.18
	binutils-csl-renesas-4_1-9:1.18
	binutils-csl-sourcerygxx-3_4_4-25:1.15.6.1
	binutils-csl-renesas-4_1-8:1.18
	binutils-csl-renesas-4_1-7:1.18
	binutils-csl-renesas-4_1-6:1.18
	binutils-csl-sourcerygxx-4_1-17:1.18
	binutils-csl-sourcerygxx-4_1-14:1.18
	binutils-csl-sourcerygxx-4_1-15:1.18
	binutils-csl-sourcerygxx-4_1-13:1.18
	binutils-2_17:1.18
	binutils-csl-sourcerygxx-4_1-12:1.18
	binutils-csl-sourcerygxx-3_4_4-21:1.18
	binutils-csl-wrs-linux-3_4_4-24:1.15
	binutils-csl-wrs-linux-3_4_4-23:1.15
	binutils-csl-sourcerygxx-4_1-9:1.18
	binutils-csl-sourcerygxx-4_1-8:1.18
	binutils-csl-sourcerygxx-4_1-7:1.18
	binutils-csl-arm-2006q1-6:1.18
	binutils-csl-sourcerygxx-4_1-6:1.18
	binutils-csl-wrs-linux-3_4_4-22:1.15
	binutils-csl-coldfire-4_1-11:1.18
	binutils-csl-sourcerygxx-3_4_4-19:1.18
	binutils-csl-coldfire-4_1-10:1.18
	binutils-csl-sourcerygxx-4_1-5:1.18
	binutils-csl-sourcerygxx-4_1-4:1.18
	binutils-csl-wrs-linux-3_4_4-21:1.15
	binutils-csl-morpho-4_1-4:1.18
	binutils-csl-sourcerygxx-3_4_4-17:1.18
	binutils-csl-wrs-linux-3_4_4-20:1.15
	binutils-2_17-branch:1.18.0.4
	binutils-2_17-branchpoint:1.18
	binutils-csl-2_17-branch:1.18.0.2
	binutils-csl-2_17-branchpoint:1.18
	binutils-csl-gxxpro-3_4-branch:1.15.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.15
	binutils-2_16_1:1.15
	binutils-csl-arm-2005q1b:1.15
	binutils-2_16:1.15
	binutils-csl-arm-2005q1a:1.15
	binutils-csl-arm-2005q1-branch:1.15.0.4
	binutils-csl-arm-2005q1-branchpoint:1.15
	binutils-2_16-branch:1.15.0.2
	binutils-2_16-branchpoint:1.15
	csl-arm-2004-q3d:1.13
	csl-arm-2004-q3:1.12
	binutils-2_15:1.11
	binutils-2_15-branchpoint:1.11
	csl-arm-2004-q1a:1.11
	csl-arm-2004-q1:1.11
	binutils-2_15-branch:1.11.0.6
	cagney_bfdfile-20040213-branch:1.11.0.4
	cagney_bfdfile-20040213-branchpoint:1.11
	cagney_bigcore-20040122-branch:1.11.0.2
	cagney_bigcore-20040122-branchpoint:1.11
	csl-arm-2003-q4:1.11
	binutils-2_14:1.10
	binutils-2_14-branch:1.10.0.4
	binutils-2_14-branchpoint:1.10
	binutils-2_13_2_1:1.10
	binutils-2_13_2:1.10
	binutils-2_13_1:1.10
	binutils-2_13:1.10
	binutils-2_13-branchpoint:1.10
	binutils-2_13-branch:1.10.0.2
	binutils-2_12_1:1.8
	binutils-2_12:1.8
	binutils-2_12-branch:1.8.0.2
	binutils-2_12-branchpoint:1.8
	cygnus_cvs_20020108_pre:1.7
	binutils-2_11_2:1.3.2.1
	binutils-2_11_1:1.3.2.1
	binutils-2_11:1.3
	x86_64versiong3:1.3
	binutils-2_11-branch:1.3.0.2
	binutils-2_10_1:1.1.1.1.2.1
	binutils-2_10:1.1.1.1.2.1
	binutils-2_10-branch:1.1.1.1.0.2
	binutils-2_10-branchpoint:1.1.1.1
	binutils_latest_snapshot:1.28
	repo-unification-2000-02-06:1.1.1.1
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.28
date	2013.10.14.09.15.09;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	2011.02.28.18.32.51;	author ktietz;	state Exp;
branches;
next	1.26;

1.26
date	2009.12.11.13.42.06;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2008.12.09.18.59.54;	author tromey;	state Exp;
branches;
next	1.24;

1.24
date	2007.10.15.02.00.56;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2007.07.19.16.17.38;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2007.07.05.16.54.45;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2007.04.26.14.46.59;	author amodra;	state Exp;
branches;
next	1.20;

1.20
date	2007.04.24.12.08.39;	author nickc;	state Exp;
branches;
next	1.19;

1.19
date	2007.02.17.13.33.54;	author jsm28;	state Exp;
branches;
next	1.18;

1.18
date	2005.10.03.19.37.44;	author mmitchel;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2005.09.30.16.37.31;	author mmitchel;	state Exp;
branches;
next	1.16;

1.16
date	2005.05.08.14.17.39;	author nickc;	state Exp;
branches;
next	1.15;

1.15
date	2005.02.22.12.57.27;	author amodra;	state Exp;
branches
	1.15.6.1;
next	1.14;

1.14
date	2005.01.21.05.40.24;	author bje;	state Exp;
branches;
next	1.13;

1.13
date	2004.10.18.14.04.40;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2004.06.15.01.19.13;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2003.09.14.12.20.16;	author aj;	state Exp;
branches;
next	1.10;

1.10
date	2002.05.25.12.51.38;	author amodra;	state Exp;
branches;
next	1.9;

1.9
date	2002.05.24.00.33.35;	author kazu;	state Exp;
branches;
next	1.8;

1.8
date	2002.01.23.16.12.56;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2001.10.02.06.02.11;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2001.09.19.05.33.17;	author hjl;	state Exp;
branches;
next	1.5;

1.5
date	2001.08.21.10.02.27;	author aj;	state Exp;
branches;
next	1.4;

1.4
date	2001.03.13.06.43.58;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2000.05.02.02.29.17;	author amodra;	state Exp;
branches
	1.3.2.1;
next	1.2;

1.2
date	2000.04.07.04.34.50;	author amodra;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.29.10;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.18.2.1
date	2006.10.16.20.21.23;	author nathan;	state Exp;
branches;
next	;

1.15.6.1
date	2005.08.30.19.57.32;	author mmitchel;	state Exp;
branches;
next	;

1.3.2.1
date	2001.06.07.03.12.28;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.10;	author rth;	state Exp;
branches
	1.1.1.1.2.1;
next	;

1.1.1.1.2.1
date	2000.04.07.04.39.25;	author amodra;	state Exp;
branches;
next	;


desc
@@


1.28
log
@	* gen-aout.c (main): Fix formatting.  Close file.

	* emultempl/aix.em (_read_file): Close file at end of function.

	* gas/all/itbl-test.c (main): Close fas.

	* read.c (add_include_dir): Use xrealloc.
	* config/tc-score.c (do_macro_bcmp): Initialise inst_main.
	* config/tc-tic6x.c (tic6x_parse_operand): Initialise second_reg.

	* readelf.c (decode_arm_unwind): Initialise addr structure.
	(process_symbol_table): Free lengths.
	* srcconv.c (wr_sc): Free info.

	* chew.c (perform): Free next.
@
text
@/* srconv.c -- Sysroff conversion program
   Copyright 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002, 2003, 2004,
   2005, 2007, 2008, 2009 Free Software Foundation, Inc.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* Written by Steve Chamberlain (sac@@cygnus.com)

   This program can be used to convert a coff object file
   into a Hitachi OM/LM (Sysroff) format.

   All debugging information is preserved */

#include "sysdep.h"
#include "bfd.h"
#include "bucomm.h"
#include "sysroff.h"
#include "coffgrok.h"
#include "libiberty.h"
#include "filenames.h"
#include "getopt.h"

#include "coff/internal.h"
#include "../bfd/libcoff.h"

/*#define FOOP1 1 */

static int addrsize;
static char *toolname;
static char **rnames;

static int get_member_id (int);
static int get_ordinary_id (int);
static char *section_translate (char *);
static char *strip_suffix (const char *);
static void checksum (FILE *, unsigned char *, int, int);
static void writeINT (int, unsigned char *, int *, int, FILE *);
static void writeBITS (int, unsigned char *, int *, int);
static void writeBARRAY (barray, unsigned char *, int *, int, FILE *);
static void writeCHARS (char *, unsigned char *, int *, int, FILE *);
static void wr_tr (void);
static void wr_un (struct coff_ofile *, struct coff_sfile *, int, int);
static void wr_hd (struct coff_ofile *);
static void wr_sh (struct coff_ofile *, struct coff_section *);
static void wr_ob (struct coff_ofile *, struct coff_section *);
static void wr_rl (struct coff_ofile *, struct coff_section *);
static void wr_object_body (struct coff_ofile *);
static void wr_dps_start
  (struct coff_sfile *, struct coff_section *, struct coff_scope *, int, int);
static void wr_dps_end (struct coff_section *, struct coff_scope *, int);
static int *nints (int);
static void walk_tree_type_1
  (struct coff_sfile *, struct coff_symbol *, struct coff_type *, int);
static void walk_tree_type
  (struct coff_sfile *, struct coff_symbol *, struct coff_type *, int);
static void walk_tree_symbol
  (struct coff_sfile *, struct coff_section *, struct coff_symbol *, int);
static void walk_tree_scope
  (struct coff_section *, struct coff_sfile *, struct coff_scope *, int, int);
static void walk_tree_sfile (struct coff_section *, struct coff_sfile *);
static void wr_program_structure (struct coff_ofile *, struct coff_sfile *);
static void wr_du (struct coff_ofile *, struct coff_sfile *, int);
static void wr_dus (struct coff_ofile *, struct coff_sfile *);
static int find_base (struct coff_sfile *, struct coff_section *);
static void wr_dln (struct coff_ofile *, struct coff_sfile *, int);
static void wr_globals (struct coff_ofile *, struct coff_sfile *, int);
static void wr_debug (struct coff_ofile *);
static void wr_cs (void);
static int wr_sc (struct coff_ofile *, struct coff_sfile *);
static void wr_er (struct coff_ofile *, struct coff_sfile *, int);
static void wr_ed (struct coff_ofile *, struct coff_sfile *, int);
static void wr_unit_info (struct coff_ofile *);
static void wr_module (struct coff_ofile *);
static int align (int);
static void prescan (struct coff_ofile *);
static void show_usage (FILE *, int);
extern int main (int, char **);

static FILE *file;
static bfd *abfd;
static int debug = 0;
static int quick = 0;
static int noprescan = 0;
static struct coff_ofile *tree;
/* Obsolete ??
   static int absolute_p;
 */

static int segmented_p;
static int code;

static int ids1[20000];
static int ids2[20000];

static int base1 = 0x18;
static int base2 = 0x2018;

static int
get_member_id (int x)
{
  if (ids2[x])
    return ids2[x];

  ids2[x] = base2++;
  return ids2[x];
}

static int
get_ordinary_id (int x)
{
  if (ids1[x])
    return ids1[x];

  ids1[x] = base1++;
  return ids1[x];
}
static char *
section_translate (char *n)
{
  if (strcmp (n, ".text") == 0)
    return "P";
  if (strcmp (n, ".data") == 0)
    return "D";
  if (strcmp (n, ".bss") == 0)
    return "B";
  return n;
}

#define DATE "940201073000";	/* Just a time on my birthday */

static char *
strip_suffix (const char *name)
{
  int i;
  char *res;

  for (i = 0; name[i] != 0 && name[i] != '.'; i++)
    ;
  res = (char *) xmalloc (i + 1);
  memcpy (res, name, i);
  res[i] = 0;
  return res;
}

/* IT LEN stuff CS */
static void
checksum (FILE *ffile, unsigned char *ptr, int size, int ccode)
{
  int j;
  int last;
  int sum = 0;
  int bytes = size / 8;

  last = !(ccode & 0xff00);
  if (size & 0x7)
    abort ();
  ptr[0] = ccode | (last ? 0x80 : 0);
  ptr[1] = bytes + 1;

  for (j = 0; j < bytes; j++)
    sum += ptr[j];

  /* Glue on a checksum too.  */
  ptr[bytes] = ~sum;
  if (fwrite (ptr, bytes + 1, 1, ffile) != 1)
    /* FIXME: Return error status.  */
    abort ();
}


static void
writeINT (int n, unsigned char *ptr, int *idx, int size, FILE *ffile)
{
  int byte = *idx / 8;

  if (size == -2)
    size = addrsize;
  else if (size == -1)
    size = 0;

  if (byte > 240)
    {
      /* Lets write out that record and do another one.  */
      checksum (ffile, ptr, *idx, code | 0x1000);
      *idx = 16;
      byte = *idx / 8;
    }

  switch (size)
    {
    case 0:
      break;
    case 1:
      ptr[byte] = n;
      break;
    case 2:
      ptr[byte + 0] = n >> 8;
      ptr[byte + 1] = n;
      break;
    case 4:
      ptr[byte + 0] = n >> 24;
      ptr[byte + 1] = n >> 16;
      ptr[byte + 2] = n >> 8;
      ptr[byte + 3] = n >> 0;
      break;
    default:
      abort ();
    }
  *idx += size * 8;
}

static void
writeBITS (int val, unsigned char *ptr, int *idx, int size)
{
  int byte = *idx / 8;
  int bit = *idx % 8;
  int old;

  *idx += size;

  old = ptr[byte];
  /* Turn off all about to change bits.  */
  old &= ~((~0 >> (8 - bit - size)) & ((1 << size) - 1));
  /* Turn on the bits we want.  */
  old |= (val & ((1 << size) - 1)) << (8 - bit - size);
  ptr[byte] = old;
}

static void
writeBARRAY (barray data, unsigned char *ptr, int *idx,
	     int size ATTRIBUTE_UNUSED, FILE *ffile)
{
  int i;

  writeINT (data.len, ptr, idx, 1, ffile);
  for (i = 0; i < data.len; i++)
    writeINT (data.data[i], ptr, idx, 1, ffile);
}

static void
writeCHARS (char *string, unsigned char *ptr, int *idx, int size, FILE *ffile)
{
  int i = *idx / 8;

  if (i > 240)
    {
      /* Lets write out that record and do another one.  */
      checksum (ffile, ptr, *idx, code | 0x1000);
      *idx = 16;
      i = *idx / 8;
    }

  if (size == 0)
    {
      /* Variable length string.  */
      size = strlen (string);
      ptr[i++] = size;
    }

  /* BUG WAITING TO HAPPEN.  */
  memcpy (ptr + i, string, size);
  i += size;
  *idx = i * 8;
}

#define SYSROFF_SWAP_OUT
#include "sysroff.c"

static char *rname_sh[] =
{
  "R0", "R1", "R2", "R3", "R4", "R5", "R6", "R7", "R8", "R9", "R10", "R11", "R12", "R13", "R14", "R15"
};

static char *rname_h8300[] =
{
  "ER0", "ER1", "ER2", "ER3", "ER4", "ER5", "ER6", "ER7", "PC", "CCR"
};

static void
wr_tr (void)
{
  /* The TR block is not normal - it doesn't have any contents.  */

  static char b[] =
    {
      0xff,			/* IT */
      0x03,			/* RL */
      0xfd,			/* CS */
    };

  if (fwrite (b, sizeof (b), 1, file) != 1)
    /* FIXME: Return error status.  */
    abort ();
}

static void
wr_un (struct coff_ofile *ptr, struct coff_sfile *sfile, int first,
       int nsecs ATTRIBUTE_UNUSED)
{
  struct IT_un un;
  struct coff_symbol *s;

  un.spare1 = 0;

  if (bfd_get_file_flags (abfd) & EXEC_P)
    un.format = FORMAT_LM;
  else
    un.format = FORMAT_OM;
  un.spare1 = 0;

  /* Don't count the abs section.  */
  un.nsections = ptr->nsections - 1;

  un.nextdefs = 0;
  un.nextrefs = 0;
  /* Count all the undefined and defined variables with global scope.  */

  if (first)
    {
      for (s = ptr->symbol_list_head; s; s = s->next_in_ofile_list)
	{
	  if (s->visible->type == coff_vis_ext_def
	      || s->visible->type == coff_vis_common)
	    un.nextdefs++;

	  if (s->visible->type == coff_vis_ext_ref)
	    un.nextrefs++;
	}
    }
  un.tool = toolname;
  un.tcd = DATE;
  un.linker = "L_GX00";
  un.lcd = DATE;
  un.name = sfile->name;
  sysroff_swap_un_out (file, &un);
}

static void
wr_hd (struct coff_ofile *p)
{
  struct IT_hd hd;

  hd.spare1 = 0;
  if (bfd_get_file_flags (abfd) & EXEC_P)
    hd.mt = MTYPE_ABS_LM;
  else
    hd.mt = MTYPE_OMS_OR_LMS;

  hd.cd = DATE;

  hd.nu = p->nsources;		/* Always one unit */
  hd.code = 0;			/* Always ASCII */
  hd.ver = "0200";		/* Version 2.00 */

  switch (bfd_get_arch (abfd))
    {
    case bfd_arch_h8300:
      hd.au = 8;
      hd.si = 0;
      hd.spcsz = 32;
      hd.segsz = 0;
      hd.segsh = 0;
      switch (bfd_get_mach (abfd))
	{
	case bfd_mach_h8300:
	  hd.cpu = "H8300";
	  hd.afl = 2;
	  addrsize = 2;
	  toolname = "C_H8/300";
	  break;
	case bfd_mach_h8300h:
	  hd.cpu = "H8300H";
	  hd.afl = 4;
	  addrsize = 4;
	  toolname = "C_H8/300H";
	  break;
	case bfd_mach_h8300s:
	  hd.cpu = "H8300S";
	  hd.afl = 4;
	  addrsize = 4;
	  toolname = "C_H8/300S";
	  break;
	default:
	  abort();
	}
      rnames = rname_h8300;
      break;
    case bfd_arch_sh:
      hd.au = 8;
      hd.si = 0;
      hd.afl = 4;
      hd.spcsz = 32;
      hd.segsz = 0;
      hd.segsh = 0;
      hd.cpu = "SH";
      addrsize = 4;
      toolname = "C_SH";
      rnames = rname_sh;
      break;
    default:
      abort ();
    }

  if (! (bfd_get_file_flags(abfd) & EXEC_P))
    {
      hd.ep = 0;
    }
  else
    {
      hd.ep = 1;
      hd.uan = 0;
      hd.sa = 0;
      hd.sad = 0;
      hd.address = bfd_get_start_address (abfd);
    }

  hd.os = "";
  hd.sys = "";
  hd.mn = strip_suffix (bfd_get_filename (abfd));

  sysroff_swap_hd_out (file, &hd);
}


static void
wr_sh (struct coff_ofile *p ATTRIBUTE_UNUSED, struct coff_section *sec)
{
  struct IT_sh sh;
  sh.unit = 0;
  sh.section = sec->number;
#ifdef FOOP1
  sh.section = 0;
#endif
  sysroff_swap_sh_out (file, &sh);
}


static void
wr_ob (struct coff_ofile *p ATTRIBUTE_UNUSED, struct coff_section *section)
{
  bfd_size_type i;
  int first = 1;
  unsigned char stuff[200];

  i = 0;
  while (i < bfd_get_section_size (section->bfd_section))
    {
      struct IT_ob ob;
      int todo = 200;		/* Copy in 200 byte lumps.  */

      ob.spare = 0;
      if (i + todo > bfd_get_section_size (section->bfd_section))
	todo = bfd_get_section_size (section->bfd_section) - i;

      if (first)
	{
	  ob.saf = 1;
	  if (bfd_get_file_flags (abfd) & EXEC_P)
	    ob.address = section->address;
	  else
	    ob.address = 0;

	  first = 0;
	}
      else
	{
	  ob.saf = 0;
	}

      ob.cpf = 0;		/* Never compress.  */
      ob.data.len = todo;
      bfd_get_section_contents (abfd, section->bfd_section, stuff, i, todo);
      ob.data.data = stuff;
      sysroff_swap_ob_out (file, &ob /*, i + todo < section->size */ );
      i += todo;
    }

  /* Now fill the rest with blanks.  */
  while (i < (bfd_size_type) section->size)
    {
      struct IT_ob ob;
      int todo = 200;		/* Copy in 200 byte lumps.  */

      ob.spare = 0;
      if (i + todo > (bfd_size_type) section->size)
	todo = section->size - i;
      ob.saf = 0;

      ob.cpf = 0;		/* Never compress.  */
      ob.data.len = todo;
      memset (stuff, 0, todo);
      ob.data.data = stuff;
      sysroff_swap_ob_out (file, &ob);
      i += todo;
    }
  /* Now fill the rest with blanks.  */
}

static void
wr_rl (struct coff_ofile *ptr ATTRIBUTE_UNUSED, struct coff_section *sec)
{
  int nr = sec->nrelocs;
  int i;

  for (i = 0; i < nr; i++)
    {
      struct coff_reloc *r = sec->relocs + i;
      struct coff_symbol *ref;
      struct IT_rl rl;

      rl.apol = 0;
      rl.boundary = 0;
      rl.segment = 1;
      rl.sign = 0;
      rl.check = 0;
      rl.addr = r->offset;
      rl.bitloc = 0;
      rl.flen = 32;		/* SH Specific.  */

      /* What sort of reloc ? Look in the section to find out.  */
      ref = r->symbol;
      if (ref->visible->type == coff_vis_ext_ref)
	{
	  rl.bcount = 4;	/* Always 4 for us.  */
	  rl.op = OP_EXT_REF;
	  rl.symn = ref->er_number;
	}
      else if (ref->visible->type == coff_vis_common)
	{
	  rl.bcount = 11;	/* Always 11 for us.  */
	  rl.op = OP_SEC_REF;
	  rl.secn = ref->where->section->number;
	  rl.copcode_is_3 = 3;
	  rl.alength_is_4 = 4;
	  rl.addend = ref->where->offset - ref->where->section->address;
	  rl.aopcode_is_0x20 = 0x20;
	}
      else
	{
	  rl.bcount = 11;	/* Always 11 for us.  */
	  rl.op = OP_SEC_REF;
	  rl.secn = ref->where->section->number;
	  rl.copcode_is_3 = 3;
	  rl.alength_is_4 = 4;
	  rl.addend = -ref->where->section->address;
	  rl.aopcode_is_0x20 = 0x20;
	}

      rl.end = 0xff;

      if (   rl.op == OP_SEC_REF
	  || rl.op == OP_EXT_REF)
	sysroff_swap_rl_out (file, &rl);
    }
}

static void
wr_object_body (struct coff_ofile *p)
{
  int i;

  for (i = 1; i < p->nsections; i++)
    {
      wr_sh (p, p->sections + i);
      wr_ob (p, p->sections + i);
      wr_rl (p, p->sections + i);
    }
}

static void
wr_dps_start (struct coff_sfile *sfile,
	      struct coff_section *section ATTRIBUTE_UNUSED,
	      struct coff_scope *scope, int type, int nest)
{
  struct IT_dps dps;

  dps.end = 0;
  dps.opt = 0;
  dps.type = type;

  if (scope->sec)
    {
      dps.san = scope->sec->number;
      dps.address = scope->offset - find_base (sfile, scope->sec);
      dps.block_size = scope->size;

      if (debug)
	{
	  printf ("DPS %s %d %x\n",
		  sfile->name,
		  nest,
		  dps.address);
	}
    }
  else
    {
      dps.san = 0;
      dps.address = 0;
      dps.block_size = 0;
    }

  dps.nesting = nest;
  dps.neg = 0x1001;
  sysroff_swap_dps_out (file, &dps);
}

static void
wr_dps_end (struct coff_section *section ATTRIBUTE_UNUSED,
	    struct coff_scope *scope ATTRIBUTE_UNUSED, int type)
{
  struct IT_dps dps;

  dps.end = 1;
  dps.type = type;
  sysroff_swap_dps_out (file, &dps);
}

static int *
nints (int x)
{
  return (int *) (xcalloc (sizeof (int), x));
}

static void
walk_tree_type_1 (struct coff_sfile *sfile, struct coff_symbol *symbol,
		  struct coff_type *type, int nest)
{
  switch (type->type)
    {
    case coff_secdef_type:
    case coff_basic_type:
      {
	struct IT_dbt dbt;

	switch (type->u.basic)
	  {
	  case T_NULL:
	  case T_VOID:
	    dbt.btype = BTYPE_VOID;
	    dbt.sign = BTYPE_UNSPEC;
	    dbt.fptype = FPTYPE_NOTSPEC;
	    break;

	  case T_CHAR:
	    dbt.btype = BTYPE_CHAR;
	    dbt.sign = BTYPE_UNSPEC;
	    dbt.fptype = FPTYPE_NOTSPEC;
	    break;

	  case T_SHORT:
	  case T_INT:
	  case T_LONG:
	    dbt.btype = BTYPE_INT;
	    dbt.sign = SIGN_SIGNED;
	    dbt.fptype = FPTYPE_NOTSPEC;
	    break;

	  case T_FLOAT:
	    dbt.btype = BTYPE_FLOAT;
	    dbt.fptype = FPTYPE_SINGLE;
	    break;

	  case T_DOUBLE:
	    dbt.btype = BTYPE_FLOAT;
	    dbt.fptype = FPTYPE_DOUBLE;
	    break;

	  case T_LNGDBL:
	    dbt.btype = BTYPE_FLOAT;
	    dbt.fptype = FPTYPE_EXTENDED;
	    break;

	  case T_UCHAR:
	    dbt.btype = BTYPE_CHAR;
	    dbt.sign = SIGN_UNSIGNED;
	    dbt.fptype = FPTYPE_NOTSPEC;
	    break;

	  case T_USHORT:
	  case T_UINT:
	  case T_ULONG:
	    dbt.btype = BTYPE_INT;
	    dbt.sign = SIGN_UNSIGNED;
	    dbt.fptype = FPTYPE_NOTSPEC;
	    break;
	  }

	dbt.bitsize = type->size;
	dbt.neg = 0x1001;
	sysroff_swap_dbt_out (file, &dbt);
	break;
      }

    case coff_pointer_type:
      {
	struct IT_dpt dpt;

	dpt.dunno = 0;
	walk_tree_type_1 (sfile, symbol, type->u.pointer.points_to, nest + 1);
	dpt.neg = 0x1001;
	sysroff_swap_dpt_out (file, &dpt);
	break;
      }

    case coff_function_type:
      {
	struct IT_dfp dfp;
	struct coff_symbol *param;

	dfp.end = 0;
	dfp.spare = 0;
	dfp.nparams = type->u.function.parameters->nvars;
	dfp.neg = 0x1001;

	walk_tree_type_1 (sfile, symbol, type->u.function.function_returns, nest + 1);

	sysroff_swap_dfp_out (file, &dfp);

	for (param = type->u.function.parameters->vars_head;
	     param;
	     param = param->next)
	  walk_tree_symbol (sfile, 0, param, nest);

	dfp.end = 1;
	sysroff_swap_dfp_out (file, &dfp);
	break;
      }

    case coff_structdef_type:
      {
	struct IT_dbt dbt;
	struct IT_dds dds;
	struct coff_symbol *member;

	dds.spare = 0;
	dbt.btype = BTYPE_STRUCT;
	dbt.bitsize = type->size;
	dbt.sign = SIGN_UNSPEC;
	dbt.fptype = FPTYPE_NOTSPEC;
	dbt.sid = get_member_id (type->u.astructdef.idx);
	dbt.neg = 0x1001;
	sysroff_swap_dbt_out (file, &dbt);
	dds.end = 0;
	dds.neg = 0x1001;
	sysroff_swap_dds_out (file, &dds);

	for (member = type->u.astructdef.elements->vars_head;
	     member;
	     member = member->next)
	  walk_tree_symbol (sfile, 0, member, nest + 1);

	dds.end = 1;
	sysroff_swap_dds_out (file, &dds);

      }
      break;

    case coff_structref_type:
      {
	struct IT_dbt dbt;

	dbt.btype = BTYPE_TAG;
	dbt.bitsize = type->size;
	dbt.sign = SIGN_UNSPEC;
	dbt.fptype = FPTYPE_NOTSPEC;

	if (type->u.astructref.ref)
	  dbt.sid = get_member_id (type->u.astructref.ref->number);
	else
	  dbt.sid = 0;

	dbt.neg = 0x1001;
	sysroff_swap_dbt_out (file, &dbt);
      }
      break;

    case coff_array_type:
      {
	struct IT_dar dar;
	int j;
	int dims = 1;		/* Only output one dimension at a time.  */

	dar.dims = dims;
	dar.variable = nints (dims);
	dar.subtype = nints (dims);
	dar.spare = nints (dims);
	dar.max_variable = nints (dims);
	dar.maxspare = nints (dims);
	dar.max = nints (dims);
	dar.min_variable = nints (dims);
	dar.min = nints (dims);
	dar.minspare = nints (dims);
	dar.neg = 0x1001;
	dar.length = type->size / type->u.array.dim;

	for (j = 0; j < dims; j++)
	  {
	    dar.variable[j] = VARIABLE_FIXED;
	    dar.subtype[j] = SUB_INTEGER;
	    dar.spare[j] = 0;
	    dar.max_variable[j] = 0;
	    dar.max[j] = type->u.array.dim;
	    dar.min_variable[j] = 0;
	    dar.min[j] = 1;	/* Why isn't this 0 ? */
	  }
	walk_tree_type_1 (sfile, symbol, type->u.array.array_of, nest + 1);
	sysroff_swap_dar_out (file, &dar);
      }
      break;

    case coff_enumdef_type:
      {
	struct IT_dbt dbt;
	struct IT_den den;
	struct coff_symbol *member;

	dbt.btype = BTYPE_ENUM;
	dbt.bitsize = type->size;
	dbt.sign = SIGN_UNSPEC;
	dbt.fptype = FPTYPE_NOTSPEC;
	dbt.sid = get_member_id (type->u.aenumdef.idx);
	dbt.neg = 0x1001;
	sysroff_swap_dbt_out (file, &dbt);

	den.end = 0;
	den.neg = 0x1001;
	den.spare = 0;
	sysroff_swap_den_out (file, &den);

	for (member = type->u.aenumdef.elements->vars_head;
	     member;
	     member = member->next)
	  walk_tree_symbol (sfile, 0, member, nest + 1);

	den.end = 1;
	sysroff_swap_den_out (file, &den);
      }
      break;

    case coff_enumref_type:
      {
	struct IT_dbt dbt;

	dbt.btype = BTYPE_TAG;
	dbt.bitsize = type->size;
	dbt.sign = SIGN_UNSPEC;
	dbt.fptype = FPTYPE_NOTSPEC;
	dbt.sid = get_member_id (type->u.aenumref.ref->number);
	dbt.neg = 0x1001;
	sysroff_swap_dbt_out (file, &dbt);
      }
      break;

    default:
      abort ();
    }
}

/* Obsolete ?
   static void
   dty_start ()
   {
   struct IT_dty dty;
   dty.end = 0;
   dty.neg = 0x1001;
   dty.spare = 0;
   sysroff_swap_dty_out (file, &dty);
   }

   static void
   dty_stop ()
   {
   struct IT_dty dty;
   dty.end = 0;
   dty.neg = 0x1001;
   dty.end = 1;
   sysroff_swap_dty_out (file, &dty);
   }


   static void
   dump_tree_structure (sfile, symbol, type, nest)
   struct coff_sfile *sfile;
   struct coff_symbol *symbol;
   struct coff_type *type;
   int nest;
   {
   if (symbol->type->type == coff_function_type)
   {


   }

   }
 */

static void
walk_tree_type (struct coff_sfile *sfile, struct coff_symbol *symbol,
		struct coff_type *type, int nest)
{
  if (symbol->type->type == coff_function_type)
    {
      struct IT_dty dty;

      dty.end = 0;
      dty.neg = 0x1001;

      sysroff_swap_dty_out (file, &dty);
      walk_tree_type_1 (sfile, symbol, type, nest);
      dty.end = 1;
      sysroff_swap_dty_out (file, &dty);

      wr_dps_start (sfile,
		    symbol->where->section,
		    symbol->type->u.function.code,
		    BLOCK_TYPE_FUNCTION, nest);
      wr_dps_start (sfile, symbol->where->section,
		    symbol->type->u.function.code,
		    BLOCK_TYPE_BLOCK, nest);
      walk_tree_scope (symbol->where->section,
		       sfile,
		       symbol->type->u.function.code,
		       nest + 1, BLOCK_TYPE_BLOCK);

      wr_dps_end (symbol->where->section,
		  symbol->type->u.function.code,
		  BLOCK_TYPE_BLOCK);
      wr_dps_end (symbol->where->section,
		  symbol->type->u.function.code, BLOCK_TYPE_FUNCTION);
    }
  else
    {
      struct IT_dty dty;

      dty.end = 0;
      dty.neg = 0x1001;
      sysroff_swap_dty_out (file, &dty);
      walk_tree_type_1 (sfile, symbol, type, nest);
      dty.end = 1;
      sysroff_swap_dty_out (file, &dty);
    }
}

static void
walk_tree_symbol (struct coff_sfile *sfile, struct coff_section *section ATTRIBUTE_UNUSED, struct coff_symbol *symbol, int nest)
{
  struct IT_dsy dsy;

  memset (&dsy, 0, sizeof(dsy));
  dsy.nesting = nest;

  switch (symbol->type->type)
    {
    case coff_function_type:
      dsy.type = STYPE_FUNC;
      dsy.assign = 1;
      break;

    case coff_structref_type:
    case coff_pointer_type:
    case coff_array_type:
    case coff_basic_type:
    case coff_enumref_type:
      dsy.type = STYPE_VAR;
      dsy.assign = 1;
      break;

    case coff_enumdef_type:
      dsy.type = STYPE_TAG;
      dsy.assign = 0;
      dsy.magic = 2;
      break;

    case coff_structdef_type:
      dsy.type = STYPE_TAG;
      dsy.assign = 0;
      dsy.magic = symbol->type->u.astructdef.isstruct ? 0 : 1;
      break;

    case coff_secdef_type:
      return;

    default:
      abort ();
    }

  if (symbol->where->where == coff_where_member_of_struct)
    {
      dsy.assign = 0;
      dsy.type = STYPE_MEMBER;
    }

  if (symbol->where->where == coff_where_member_of_enum)
    {
      dsy.type = STYPE_ENUM;
      dsy.assign = 0;
      dsy.evallen = 4;
      dsy.evalue = symbol->where->offset;
    }

  if (symbol->type->type == coff_structdef_type
      || symbol->where->where == coff_where_entag
      || symbol->where->where == coff_where_strtag)
    {
      dsy.snumber = get_member_id (symbol->number);
    }
  else
    {
      dsy.snumber = get_ordinary_id (symbol->number);
    }

  dsy.sname = symbol->name[0] == '_' ? symbol->name + 1 : symbol->name;

  switch (symbol->visible->type)
    {
    case coff_vis_common:
    case coff_vis_ext_def:
      dsy.ainfo = AINFO_STATIC_EXT_DEF;
      break;

    case coff_vis_ext_ref:
      dsy.ainfo = AINFO_STATIC_EXT_REF;
      break;

    case coff_vis_int_def:
      dsy.ainfo = AINFO_STATIC_INT;
      break;

    case coff_vis_auto:
    case coff_vis_autoparam:
      dsy.ainfo = AINFO_AUTO;
      break;

    case coff_vis_register:
    case coff_vis_regparam:
      dsy.ainfo = AINFO_REG;
      break;
      break;

    case coff_vis_tag:
    case coff_vis_member_of_struct:
    case coff_vis_member_of_enum:
      break;

    default:
      abort ();
    }

  dsy.dlength = symbol->type->size;

  switch (symbol->where->where)
    {
    case coff_where_memory:

      dsy.section = symbol->where->section->number;
#ifdef FOOP
      dsy.section = 0;
#endif
      break;

    case coff_where_member_of_struct:
    case coff_where_member_of_enum:
    case coff_where_stack:
    case coff_where_register:
    case coff_where_unknown:
    case coff_where_strtag:
    case coff_where_entag:
    case coff_where_typedef:
      break;

    default:
      abort ();
    }

  switch (symbol->where->where)
    {
    case coff_where_memory:
      dsy.address = symbol->where->offset - find_base (sfile, symbol->where->section);
      break;

    case coff_where_stack:
      dsy.address = symbol->where->offset;
      break;

    case coff_where_member_of_struct:
      if (symbol->where->bitsize)
	{
	  int bits = (symbol->where->offset * 8 + symbol->where->bitoffset);
	  dsy.bitunit = 1;
	  dsy.field_len = symbol->where->bitsize;
	  dsy.field_off = (bits / 32) * 4;
	  dsy.field_bitoff = bits % 32;
	}
      else
	{
	  dsy.bitunit = 0;

	  dsy.field_len = symbol->type->size;
	  dsy.field_off = symbol->where->offset;
	}
      break;

    case coff_where_member_of_enum:
      /*      dsy.bitunit = 0;
         dsy.field_len  = symbol->type->size;
         dsy.field_off = symbol->where->offset; */
      break;

    case coff_where_register:
    case coff_where_unknown:
    case coff_where_strtag:
    case coff_where_entag:
    case coff_where_typedef:
      break;

    default:
      abort ();
    }

  if (symbol->where->where == coff_where_register)
    dsy.reg = rnames[symbol->where->offset];

  switch (symbol->visible->type)
    {
    case coff_vis_common:
      /* We do this 'cause common C symbols are treated as extdefs.  */
    case coff_vis_ext_def:
    case coff_vis_ext_ref:
      dsy.ename = symbol->name;
      break;

    case coff_vis_regparam:
    case coff_vis_autoparam:
      dsy.type = STYPE_PARAMETER;
      break;

    case coff_vis_int_def:
    case coff_vis_auto:
    case coff_vis_register:
    case coff_vis_tag:
    case coff_vis_member_of_struct:
    case coff_vis_member_of_enum:
      break;

    default:
      abort ();
    }

  dsy.sfn = 0;
  dsy.sln = 2;
  dsy.neg = 0x1001;

  sysroff_swap_dsy_out (file, &dsy);

  walk_tree_type (sfile, symbol, symbol->type, nest);
}

static void
walk_tree_scope (struct coff_section *section, struct coff_sfile *sfile, struct coff_scope *scope, int nest, int type)
{
  struct coff_symbol *vars;
  struct coff_scope *child;

  if (scope->vars_head
      || (scope->list_head && scope->list_head->vars_head))
    {
      wr_dps_start (sfile, section, scope, type, nest);

      if (nest == 0)
	wr_globals (tree, sfile, nest + 1);

      for (vars = scope->vars_head; vars; vars = vars->next)
	walk_tree_symbol (sfile, section, vars, nest);

      for (child = scope->list_head; child; child = child->next)
	walk_tree_scope (section, sfile, child, nest + 1, BLOCK_TYPE_BLOCK);

      wr_dps_end (section, scope, type);
    }
}

static void
walk_tree_sfile (struct coff_section *section, struct coff_sfile *sfile)
{
  walk_tree_scope (section, sfile, sfile->scope, 0, BLOCK_TYPE_COMPUNIT);
}

static void
wr_program_structure (struct coff_ofile *p, struct coff_sfile *sfile)
{
  walk_tree_sfile (p->sections + 4, sfile);
}

static void
wr_du (struct coff_ofile *p, struct coff_sfile *sfile, int n)
{
  struct IT_du du;
  int lim;
  int i;
  int j;
  unsigned int *lowest = (unsigned *) nints (p->nsections);
  unsigned int *highest = (unsigned *) nints (p->nsections);

  du.format = bfd_get_file_flags (abfd) & EXEC_P ? 0 : 1;
  du.optimized = 0;
  du.stackfrmt = 0;
  du.spare = 0;
  du.unit = n;
  du.sections = p->nsections - 1;
  du.san = (int *) xcalloc (sizeof (int), du.sections);
  du.address = nints (du.sections);
  du.length = nints (du.sections);

  for (i = 0; i < du.sections; i++)
    {
      lowest[i] = ~0;
      highest[i] = 0;
    }

  lim = du.sections;
  for (j = 0; j < lim; j++)
    {
      int src = j;
      int dst = j;

      du.san[dst] = dst;

      if (sfile->section[src].init)
	{
	  du.length[dst]
	    = sfile->section[src].high - sfile->section[src].low + 1;
	  du.address[dst]
	    = sfile->section[src].low;
	}
      else
	{
	  du.length[dst] = 0;
	  du.address[dst] = 0;
	}

      if (debug)
	{
	  if (sfile->section[src].parent)
	    {
	      printf (" section %6s 0x%08x..0x%08x\n",
		      sfile->section[src].parent->name,
		      du.address[dst],
		      du.address[dst] + du.length[dst] - 1);
	    }
	}

      du.sections = dst + 1;
    }

  du.tool = "c_gcc";
  du.date = DATE;

  sysroff_swap_du_out (file, &du);
}

static void
wr_dus (struct coff_ofile *p ATTRIBUTE_UNUSED, struct coff_sfile *sfile)
{
  struct IT_dus dus;

  dus.efn = 0x1001;
  dus.ns = 1;			/* p->nsources; sac 14 jul 94 */
  dus.drb = nints (dus.ns);
  dus.fname = (char **) xcalloc (sizeof (char *), dus.ns);
  dus.spare = nints (dus.ns);
  dus.ndir = 0;
  /* Find the filenames.  */
  dus.drb[0] = 0;
  dus.fname[0] = sfile->name;

  sysroff_swap_dus_out (file, &dus);

}

/* Find the offset of the .text section for this sfile in the
   .text section for the output file.  */

static int
find_base (struct coff_sfile *sfile, struct coff_section *section)
{
  return sfile->section[section->number].low;
}

static void
wr_dln (struct coff_ofile *p ATTRIBUTE_UNUSED, struct coff_sfile *sfile,
	int n ATTRIBUTE_UNUSED)
{
  /* Count up all the linenumbers */

  struct coff_symbol *sy;
  int lc = 0;
  struct IT_dln dln;

  int idx;

  for (sy = sfile->scope->vars_head;
       sy;
       sy = sy->next)
    {
      struct coff_type *t = sy->type;
      if (t->type == coff_function_type)
	{
	  struct coff_line *l = t->u.function.lines;
	  if (l)
	    lc += l->nlines;
	}
    }

  dln.sfn = nints (lc);
  dln.sln = nints (lc);
  dln.cc = nints (lc);
  dln.section = nints (lc);

  dln.from_address = nints (lc);
  dln.to_address = nints (lc);


  dln.neg = 0x1001;

  dln.nln = lc;

  /* Run through once more and fill up the structure */
  idx = 0;
  for (sy = sfile->scope->vars_head;
       sy;
       sy = sy->next)
    {
      if (sy->type->type == coff_function_type)
	{
	  int i;
	  struct coff_line *l = sy->type->u.function.lines;
	  if (l)
	    {
	      int base = find_base (sfile, sy->where->section);
	      for (i = 0; i < l->nlines; i++)
		{
		  dln.section[idx] = sy->where->section->number;
		  dln.sfn[idx] = 0;
		  dln.sln[idx] = l->lines[i];
		  dln.from_address[idx] =
		    l->addresses[i] + sy->where->section->address - base;
		  dln.cc[idx] = 0;
		  if (idx)
		    dln.to_address[idx - 1] = dln.from_address[idx];
		  idx++;

		}
	      dln.to_address[idx - 1] = dln.from_address[idx - 1] + 2;
	    }
	}
    }
  if (lc)
    sysroff_swap_dln_out (file, &dln);
}

/* Write the global symbols out to the debug info.  */

static void
wr_globals (struct coff_ofile *p, struct coff_sfile *sfile,
	    int n ATTRIBUTE_UNUSED)
{
  struct coff_symbol *sy;

  for (sy = p->symbol_list_head;
       sy;
       sy = sy->next_in_ofile_list)
    {
      if (sy->visible->type == coff_vis_ext_def
	  || sy->visible->type == coff_vis_ext_ref)
	{
	  /* Only write out symbols if they belong to
	     the current source file.  */
	  if (sy->sfile == sfile)
	    walk_tree_symbol (sfile, 0, sy, 0);
	}
    }
}

static void
wr_debug (struct coff_ofile *p)
{
  struct coff_sfile *sfile;
  int n = 0;

  for (sfile = p->source_head;
       sfile;
       sfile = sfile->next)
    {
      if (debug)
	printf ("%s\n", sfile->name);

      wr_du (p, sfile, n);
      wr_dus (p, sfile);
      wr_program_structure (p, sfile);
      wr_dln (p, sfile, n);
      n++;
    }
}

static void
wr_cs (void)
{
  /* It seems that the CS struct is not normal - the size is wrong
     heres one I prepared earlier.  */
  static char b[] =
    {
    0x80,			/* IT */
    0x21,			/* RL */
    0x00,			/* number of chars in variable length part */
    0x80,			/* hd */
    0x00,			/* hs */
    0x80,			/* un */
    0x00,			/* us */
    0x80,			/* sc */
    0x00,			/* ss */
    0x80,			/* er */
    0x80,			/* ed */
    0x80,			/* sh */
    0x80,			/* ob */
    0x80,			/* rl */
    0x80,			/* du */
    0x80,			/* dps */
    0x80,			/* dsy */
    0x80,			/* dty */
    0x80,			/* dln */
    0x80,			/* dso */
    0x80,			/* dus */
    0x00,			/* dss */
    0x80,			/* dbt */
    0x00,			/* dpp */
    0x80,			/* dfp */
    0x80,			/* den */
    0x80,			/* dds */
    0x80,			/* dar */
    0x80,			/* dpt */
    0x00,			/* dul */
    0x00,			/* dse */
    0x00,			/* dot */
    0xDE			/* CS */
  };

  if (fwrite (b, sizeof (b), 1, file) != 1)
    /* FIXME: Return error status.  */
    abort ();
}

/* Write out the SC records for a unit.  Create an SC
   for all the sections which appear in the output file, even
   if there isn't an equivalent one on the input.  */

static int
wr_sc (struct coff_ofile *ptr, struct coff_sfile *sfile)
{
  int i;
  int scount = 0;
  /* First work out the total number of sections.  */
  int total_sec = ptr->nsections;
  struct myinfo
    {
      struct coff_section *sec;
      struct coff_symbol *symbol;
    };
  struct coff_symbol *symbol;
  struct myinfo *info
    = (struct myinfo *) calloc (total_sec, sizeof (struct myinfo));


  for (i = 0; i < total_sec; i++)
    {
      info[i].sec = ptr->sections + i;
      info[i].symbol = 0;
    }

  for (symbol = sfile->scope->vars_head;
       symbol;
       symbol = symbol->next)
    {

      if (symbol->type->type == coff_secdef_type)
	{
	  for (i = 0; i < total_sec; i++)
	    {
	      if (symbol->where->section == info[i].sec)
		{
		  info[i].symbol = symbol;
		  break;
		}
	    }
	}
    }

  /* Now output all the section info, and fake up some stuff for sections
     we don't have.  */
  for (i = 1; i < total_sec; i++)
    {
      struct IT_sc sc;
      char *name;

      symbol = info[i].symbol;
      sc.spare = 0;
      sc.spare1 = 0;

      if (!symbol)
	{
	  /* Don't have a symbol set aside for this section, which means
	     that nothing in this file does anything for the section.  */
	  sc.format = !(bfd_get_file_flags (abfd) & EXEC_P);
	  sc.addr = 0;
	  sc.length = 0;
	  name = info[i].sec->name;
	}
      else
	{
	  if (bfd_get_file_flags (abfd) & EXEC_P)
	    {
	      sc.format = 0;
	      sc.addr = symbol->where->offset;
	    }
	  else
	    {
	      sc.format = 1;
	      sc.addr = 0;
	    }
	  sc.length = symbol->type->size;
	  name = symbol->name;
	}

      sc.align = 4;
      sc.concat = CONCAT_SIMPLE;
      sc.read = 3;
      sc.write = 3;
      sc.exec = 3;
      sc.init = 3;
      sc.mode = 3;
      sc.spare = 0;
      sc.segadd = 0;
      sc.spare1 = 0;		/* If not zero, then it doesn't work.  */
      sc.name = section_translate (name);

      if (strlen (sc.name) == 1)
	{
	  switch (sc.name[0])
	    {
	    case 'D':
	    case 'B':
	      sc.contents = CONTENTS_DATA;
	      break;

	    default:
	      sc.contents = CONTENTS_CODE;
	    }
	}
      else
	{
	  sc.contents = CONTENTS_CODE;
	}

      sysroff_swap_sc_out (file, &sc);
      scount++;
    }
  free (info);
  return scount;
}

/* Write out the ER records for a unit.  */

static void
wr_er (struct coff_ofile *ptr, struct coff_sfile *sfile ATTRIBUTE_UNUSED,
       int first)
{
  int idx = 0;
  struct coff_symbol *sym;

  if (first)
    {
      for (sym = ptr->symbol_list_head; sym; sym = sym->next_in_ofile_list)
	{
	  if (sym->visible->type == coff_vis_ext_ref)
	    {
	      struct IT_er er;

	      er.spare = 0;
	      er.type = ER_NOTSPEC;
	      er.name = sym->name;
	      sysroff_swap_er_out (file, &er);
	      sym->er_number = idx++;
	    }
	}
    }
}

/* Write out the ED records for a unit.  */

static void
wr_ed (struct coff_ofile *ptr, struct coff_sfile *sfile ATTRIBUTE_UNUSED,
       int first)
{
  struct coff_symbol *s;

  if (first)
    {
      for (s = ptr->symbol_list_head; s; s = s->next_in_ofile_list)
	{
	  if (s->visible->type == coff_vis_ext_def
	      || s->visible->type == coff_vis_common)
	    {
	      struct IT_ed ed;

	      ed.section = s->where->section->number;
	      ed.spare = 0;

	      if (s->where->section->data)
		{
		  ed.type = ED_TYPE_DATA;
		}
	      else if (s->where->section->code & SEC_CODE)
		{
		  ed.type = ED_TYPE_ENTRY;
		}
	      else
		{
		  ed.type = ED_TYPE_NOTSPEC;
		  ed.type = ED_TYPE_DATA;
		}

	      ed.address = s->where->offset - s->where->section->address;
	      ed.name = s->name;
	      sysroff_swap_ed_out (file, &ed);
	    }
	}
    }
}

static void
wr_unit_info (struct coff_ofile *ptr)
{
  struct coff_sfile *sfile;
  int first = 1;

  for (sfile = ptr->source_head;
       sfile;
       sfile = sfile->next)
    {
      long p1;
      long p2;
      int nsecs;

      p1 = ftell (file);
      wr_un (ptr, sfile, first, 0);
      nsecs = wr_sc (ptr, sfile);
      p2 = ftell (file);
      fseek (file, p1, SEEK_SET);
      wr_un (ptr, sfile, first, nsecs);
      fseek (file, p2, SEEK_SET);
      wr_er (ptr, sfile, first);
      wr_ed (ptr, sfile, first);
      first = 0;
    }
}

static void
wr_module (struct coff_ofile *p)
{
  wr_cs ();
  wr_hd (p);
  wr_unit_info (p);
  wr_object_body (p);
  wr_debug (p);
  wr_tr ();
}

static int
align (int x)
{
  return (x + 3) & ~3;
}

/* Find all the common variables and turn them into
   ordinary defs - dunno why, but thats what hitachi does with 'em.  */

static void
prescan (struct coff_ofile *otree)
{
  struct coff_symbol *s;
  struct coff_section *common_section;

  /* Find the common section - always section 3.  */
  common_section = otree->sections + 3;

  for (s = otree->symbol_list_head;
       s;
       s = s->next_in_ofile_list)
    {
      if (s->visible->type == coff_vis_common)
	{
	  struct coff_where *w = s->where;

	  /*      s->visible->type = coff_vis_ext_def; leave it as common */
	  common_section->size = align (common_section->size);
	  w->offset = common_section->size + common_section->address;
	  w->section = common_section;
	  common_section->size += s->type->size;
	  common_section->size = align (common_section->size);
	}
    }
}

char *program_name;

static void
show_usage (FILE *ffile, int status)
{
  fprintf (ffile, _("Usage: %s [option(s)] in-file [out-file]\n"), program_name);
  fprintf (ffile, _("Convert a COFF object file into a SYSROFF object file\n"));
  fprintf (ffile, _(" The options are:\n\
  -q --quick       (Obsolete - ignored)\n\
  -n --noprescan   Do not perform a scan to convert commons into defs\n\
  -d --debug       Display information about what is being done\n\
  @@<file>          Read options from <file>\n\
  -h --help        Display this information\n\
  -v --version     Print the program's version number\n"));

  if (REPORT_BUGS_TO[0] && status == 0)
    fprintf (ffile, _("Report bugs to %s\n"), REPORT_BUGS_TO);
  exit (status);
}

int
main (int ac, char **av)
{
  int opt;
  static struct option long_options[] =
  {
    {"debug", no_argument, 0, 'd'},
    {"quick", no_argument, 0, 'q'},
    {"noprescan", no_argument, 0, 'n'},
    {"help", no_argument, 0, 'h'},
    {"version", no_argument, 0, 'V'},
    {NULL, no_argument, 0, 0}
  };
  char **matching;
  char *input_file;
  char *output_file;

#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

  program_name = av[0];
  xmalloc_set_program_name (program_name);

  expandargv (&ac, &av);

  while ((opt = getopt_long (ac, av, "dHhVvqn", long_options,
			     (int *) NULL))
	 != EOF)
    {
      switch (opt)
	{
	case 'q':
	  quick = 1;
	  break;
	case 'n':
	  noprescan = 1;
	  break;
	case 'd':
	  debug = 1;
	  break;
	case 'H':
	case 'h':
	  show_usage (stdout, 0);
	  /*NOTREACHED */
	case 'v':
	case 'V':
	  print_version ("srconv");
	  exit (0);
	  /*NOTREACHED */
	case 0:
	  break;
	default:
	  show_usage (stderr, 1);
	  /*NOTREACHED */
	}
    }

  /* The input and output files may be named on the command line.  */
  output_file = NULL;
  if (optind < ac)
    {
      input_file = av[optind];
      ++optind;
      if (optind < ac)
	{
	  output_file = av[optind];
	  ++optind;
	  if (optind < ac)
	    show_usage (stderr, 1);
	  if (filename_cmp (input_file, output_file) == 0)
	    {
	      fatal (_("input and output files must be different"));
	    }
	}
    }
  else
    input_file = 0;

  if (!input_file)
    {
      fatal (_("no input file specified"));
    }

  if (!output_file)
    {
      /* Take a .o off the input file and stick on a .obj.  If
         it doesn't end in .o, then stick a .obj on anyway */

      int len = strlen (input_file);

      output_file = xmalloc (len + 5);
      strcpy (output_file, input_file);

      if (len > 3
	  && output_file[len - 2] == '.'
	  && output_file[len - 1] == 'o')
	{
	  output_file[len] = 'b';
	  output_file[len + 1] = 'j';
	  output_file[len + 2] = 0;
	}
      else
	{
	  strcat (output_file, ".obj");
	}
    }

  abfd = bfd_openr (input_file, 0);

  if (!abfd)
    bfd_fatal (input_file);

  if (!bfd_check_format_matches (abfd, bfd_object, &matching))
    {
      bfd_nonfatal (input_file);

      if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
	{
	  list_matching_formats (matching);
	  free (matching);
	}
      exit (1);
    }

  file = fopen (output_file, FOPEN_WB);

  if (!file)
    fatal (_("unable to open output file %s"), output_file);

  if (debug)
    printf ("ids %d %d\n", base1, base2);

  tree = coff_grok (abfd);

  if (!noprescan)
    prescan (tree);

  wr_module (tree);
  return 0;
}
@


1.27
log
@ChangeLog binutils/
2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* debug.c (debug_start_source): Use filename_(n)cmp.
	* ieee.c (ieee_finish_compilation_unit): Likewise.
	(ieee_lineno): Likewise.
	* nlmconv.c (main): Likewise.
	* objcopy.c (strip_main): Likewise.
	(copy_main): Likewise.
	* objdump.c (show_line): Likewise.
	(dump_reloc_set): Likewise.
	* srconv.c (main): Likewise.
	* wrstabs.c (stab_lineno): Likewise.

ChangeLog gas/
2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* depend.c (register_dependency): Use filename_(n)cmp.
	* dwarf2dbg.c (get_filenum): Likewise.
	* ecoff.c (add_file): Likewise.
	(ecoff_generate_asm_lineno): Likewise.
	* input-scrub.c (new_logical_line_flags): Likewise.
	* listing.c (file_info): Likewise.
	(listing_newline): Likewise.
	* remap.c (remap_debug_filename): Likewise.
	* stabs.c (generate_asm_file): Likewise.
	(stabs_generate_asm_lineno): Likewise.
@
text
@d1581 1
@


1.26
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d35 1
d1822 1
a1822 1
	  if (strcmp (input_file, output_file) == 0)
@


1.25
log
@bfd
	* pef.c (bfd_pef_parse_traceback_table): Add parens to placate gcc
	4.4.
binutils
	* srconv.c (wr_hd): Add parens to placate gcc 4.4.
@
text
@d3 1
a3 1
   2005, 2007, 2008 Free Software Foundation, Inc.
d161 1
a161 1
checksum (FILE *file, unsigned char *ptr, int size, int code)
d168 1
a168 1
  last = !(code & 0xff00);
d171 1
a171 1
  ptr[0] = code | (last ? 0x80 : 0);
d179 1
a179 1
  if (fwrite (ptr, bytes + 1, 1, file) != 1)
d186 1
a186 1
writeINT (int n, unsigned char *ptr, int *idx, int size, FILE *file)
d198 1
a198 1
      checksum (file, ptr, *idx, code | 0x1000);
d245 1
a245 1
	     int size ATTRIBUTE_UNUSED, FILE *file)
d249 1
a249 1
  writeINT (data.len, ptr, idx, 1, file);
d251 1
a251 1
    writeINT (data.data[i], ptr, idx, 1, file);
d255 1
a255 1
writeCHARS (char *string, unsigned char *ptr, int *idx, int size, FILE *file)
d262 1
a262 1
      checksum (file, ptr, *idx, code | 0x1000);
d1700 1
a1700 1
prescan (struct coff_ofile *tree)
d1706 1
a1706 1
  common_section = tree->sections + 3;
d1708 1
a1708 1
  for (s = tree->symbol_list_head;
d1715 1
d1729 1
a1729 1
show_usage (FILE *file, int status)
d1731 3
a1733 3
  fprintf (file, _("Usage: %s [option(s)] in-file [out-file]\n"), program_name);
  fprintf (file, _("Convert a COFF object file into a SYSROFF object file\n"));
  fprintf (file, _(" The options are:\n\
d1742 1
a1742 1
    fprintf (file, _("Report bugs to %s\n"), REPORT_BUGS_TO);
@


1.24
log
@	* objdump.c (print_line): Check fwrite return value.
	* srconv.c (checksum, wr_tr, wr_cs): Likewise.
	* sysdump.c (fillup): Return zero on getc or fread EOF.  Return count
	read.
@
text
@d3 1
a3 1
   2005, 2007 Free Software Foundation, Inc.
d418 1
a418 1
  if (! bfd_get_file_flags(abfd) & EXEC_P)
@


1.23
log
@PR binutils/4802
* srconv.c (strip_suffix): Add const qualifier to argument
@
text
@d179 3
a181 1
  fwrite (ptr, bytes + 1, 1, file);
d304 4
a307 1
  fwrite (b, 1, sizeof (b), file);
d1460 4
a1463 1
  fwrite (b, 1, sizeof (b), file);
@


1.22
log
@Change sources over to using GPLv3
@
text
@d49 1
a49 1
static char *strip_suffix (char *);
d145 2
a146 3
static
char *
strip_suffix (char *name)
@


1.21
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d9 1
a9 1
   the Free Software Foundation; either version 2 of the License, or
@


1.20
log
@* srconv.c (walk_tree_type_1): Initialise dpt.dunno.
@
text
@d29 1
@


1.19
log
@top level:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.ac (TOPLEVEL_CONFIGURE_ARGUMENTS): Fix quoting.
	* configure: Regenerate.

bfd:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-pkgversion): New option.
	* configure: Regenerate.
	* Makefile.am (bfdver.h): Substitute for @@bfd_version_package@@.
	* Makefile.in: Regenerate.
	* version.h (BFD_VERSION_STRING): Define using
	@@bfd_version_package@@.

bfd/doc:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* Makefile.in: Regenerate.

binutils:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-bugurl): New option.
	* configure: Regenerate.
	* Makefile.am (REPORT_BUGS_TO): Define.
	(INCLUDES): Define REPORT_BUGS_TO.
	Regenerate dependencies.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* bucomm.h: Remove include of bin-bugs.h.
	* addr2line.c (usage): Don't print empty REPORT_BUGS_TO.
	* ar.c (usage): Pass s to list_supported_targets.  Don't print
	empty REPORT_BUGS_TO.
	* coffdump.c (show_usage): Don't print empty REPORT_BUGS_TO.
	* cxxfilt.c (usage): Print bug url when giving help.
	* dlltool.c (usage): Likewise.
	* dllwrap.c (usage): Likewise.
	* nlmconv.c (show_usage): Don't print empty REPORT_BUGS_TO.
	* nm.c (usage): Likewise.
	* objcopy.c (copy_usage, strip_usage): Likewise.
	* objdump.c (usage): Likewise.
	* readelf.c ((usage): Likewise. Add STREAM argument.  Adjust
	callers.
	* size.c (usage): Don't print empty REPORT_BUGS_TO.
	* srconv.c (show_usage): Likewise.
	* strings.c (usage): Likewise.
	* sysdymp.c (show_usage): Likewise.
	* windres.c (usage): Likewise.

gas:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-bugurl): New option.
	* configure: Regenerate.
	* dep-in.sed: Remove bin-bugs.h.
	* Makefile.am (REPORT_BUGS_TO): Define.
	(INCLUDES): Define REPORT_BUGS_TO.
	(DEP_INCLUDES): Likewise.
	($(OBJS)): No longer depend on bin-bugs.h.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* as.c (show_usage): Don't print empty REPORT_BUGS_TO.
	* as.h: Remove include of bin-bugs.h.

gprof:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-pkgversion, --with-bugurl): New options.
	* configure: Regenerate.
	* Makefile.am (PKGVERSION, REPORT_BUGS_TO): Define.
	(INCLUDES): Define PKGVERSION and REPORT_BUGS_TO.
	Regenerate dependencies.
	* Makefile.in: Regenerate.
	* gprof.c (usage): Don't print empty REPORT_BUGS_TO.
	(main): Include PKGVERSION in version output.
	* gprof.h: Remove include of bin-bugs.h.

include:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* bin-bugs.h: Remove.

ld:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-bugurl): New option.
	* configure: Regenerate.
	* Makefile.am (REPORT_BUGS_TO): Define.
	(INCLUDES): Define REPORT_BUGS_TO.
	Regenerate dependencies.
	* Makefile.in: Regenerate.
	* ld.h: Remove include of bin-bugs.h.
	* lexsup.c (help): Don't print empty REPORT_BUGS_TO.
@
text
@d707 1
@


1.18
log
@	* addr2line.c (usage): Document @@file.
	* ar.c (usage): Likewise.
	* coffdump (usage): Likewise.
	* cxxfilt.c (usage): Likewise.
	* dlltool.c (usage): Likewise.
	* dllwrap.c (usage): Likewise.
	* nlmconv.c (usage): Likewise.
	* nm.c (usage): Likewise.
	* objcopy.c (usage): Likewise.
	* objdump.c (usage): Likewise.
	* readelf.c (usage): Likewise.
	* size.c (usage): Likeise.
	* srconv.c (usage): Likewise.
	* strings.c (usage): Likewise.
	* windres.c (usage): Likewise.
	* doc/binutils.texi: Add section on common options.
@
text
@d3 1
a3 1
   2005 Free Software Foundation, Inc.
d1731 1
a1731 1
  if (status == 0)
@


1.18.2.1
log
@	binutils/
	* Makefile.am: Rebuild dependencies.
	(REPORT_BUGS_TO): Always defined.
	(INCLUDES): Adjust.
	* Makefile.in: Rebuilt.
	* configure.in (REPORT_BUGS_TO): Provide default value.
	* configure: Rebuilt.
	* bucomm.h: Remove bin-bugs.h.
	* addr2line.c (usage): Don't print empty REPORT_BUGS_TO.
	* coffdump.c (show_usage): Likewise.
	* cxxfilt.c (usage): Likewise.
	* nlmconv.c (show_usage): Likewise.
	* nm.c (usage): Likewise.
	* objcopy.c (copy_usage, strip_usage): Likewise.
	* objdump.c (usage): Likewise.
	* size.c (usage): Likewise.
	* srconv.c (show_usage): Likewise.
	* string.c (usage): Likewise.
	* sysdymp.c (show_usage): Likewise.
	* windres.c (usage): Likewise.
	* readelf (usage): Likewise. Add STREAM argument.  Adjust callers.

	gas/
	* Makefile.am: Rebuild dependencies.
	(REPORT_BUGS_TO): Always defined.
	(INCLUDES): Adjust.
	* Makefile.in: Rebuilt.
	* configure.in (REPORT_BUGS_TO): Provide default value.
	* configure: Rebuilt.
	* as.c (show_usage): Don't print empty REPORT_BUGS_TO.
	* as.h: Remove bin-bugs.h.

	ld/
	* Makefile.am: Rebuild dependencies.
	(REPORT_BUGS_TO): Always defined.
	(INCLUDES): Adjust.
	* Makefile.in: Rebuilt.
	* configure.in (REPORT_BUGS_TO): Provide default value.
	* configure: Rebuilt.
	* ld.h: Remove bin-bugs.h
	* lexsup.c (help):  Don't print empty REPORT_BUGS_TO.

	gprof/
	* Makefile.am: Rebuild dependencies.
	(REPORT_BUGS_TO): Always defined.
	(PKGVERSION): Define.
	(INCLUDES): Adjust.
	* Makefile.in: Rebuilt.
	* configure.in (REPORT_BUGS_TO): Provide default value.
	* configure: Rebuilt.
	* gprof.c (usage): Don't print empty REPORT_BUGS_TO.
	* gprof.h: Remove bin-bugs.h

	include/
	* bin-bugs.h: Remove.
@
text
@d1731 1
a1731 1
  if (REPORT_BUGS_TO[0] && status == 0)
@


1.17
log
@	* addr2line.c (main): Likewise.
	* ar.c (main): Likewise.
	* coffdump.c (main): Likewise.
	* cxxfilt.c (main): Likewise.
	* dlltool.c (main): Likewise.
	* dllwrap.c (main): Likewise.
	* nlmconv.c (main): Likewise.
	* nm.c (main): Likewise.
	* objcopy.c (main): Likewise.
	* objdump.c (main): Likewise.
	* readelf.c (main): Likewise.
	* size.c (main): Likeiwse.
	* srcconv.c (main): Likewise.
	* strings.c (main): Likewise.
	* sysdump.c (main): Likewise.
	* sysinfo.c (main): Likewise.
	* windres.c (main): Likewise.

	* ldmain.c (main): Use expandargv.

	* gprof.c (main): Use expandargv.

	* as.c (main): Use expandargv.
@
text
@d1727 1
@


1.16
log
@Update FSF address
@
text
@d1764 2
@


1.15
log
@	* Makefile.am (syslex.o, sysinfo.o): Pass AM_CFLAGS to compiler.
	(syslex.o, sysinfo.o, dlltool.o, rescoff.o): Remove duplicate
	dependencies.  Run "make dep-am".
	* nlmconv.c: Warning fixes.
	* readelf.c: Likewise.
	* srconv.c: Likewise.
	* sysdump.c: Likewise.
	* sysinfo.y: Likewise.
	* syslex.l: Likewise.  Use yyleng instead of strlen, memcpy instead
	of strcpy.
	* Makefile.in: Regenerate.
@
text
@d19 2
a20 2
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.15.6.1
log
@	* ld/ldmain.c (main): Use expandargv.
	* binutils/addr2line.c (main): Likewise.
	* binutils/ar.c (main): Likewise.
	* binutils/coffdump.c (main): Likewise.
	* binutils/cxxfilt.c (main): Likewise.
	* binutils/dlltool.c (main): Likewise.
	* binutils/dllwrap.c (main): Likewise.
	* binutils/nlmconv.c (main): Likewise.
	* binutils/nm.c (main): Likewise.
	* binutils/objcopy.c (main): Likewise.
	* binutils/objdump.c (main): Likewise.
	* binutils/readelf.c (main): Likewise.
	* binutils/size.c (main): Likeiwse.
	* binutils/srcconv.c (main): Likewise.
	* binutils/strings.c (main): Likewise.
	* binutils/sysdump.c (main): Likewise.
	* binutils/sysinfo.c (main): Likewise.
	* binutils/windres.c (main): Likewise.

	* include/libiberty.h (expandargv): New function.
	* libiberty/argv.c (safe-ctype.h): Include it.
	(ISBLANK): Remove.
	(stdio.h): Include.
	(expandargv): New function.
	* libiberty/Makefile.in: Regenerated.
@
text
@a1763 2
  expandargv (&ac, &av);

@


1.14
log
@	* dlltool.c (dump_iat): Remove unused function.
	(gen_exp_file): Remove #if 0'd code.
	(make_one_lib_file): Likewise.
	* srconv.c: Remove #if 0'd code throughout.
	* size.c (lprint_number): Remove.
	(print_berkeley_format): Remove #if 0'd code.
	* ar.c (do_quick_append): Remove declaration and definiton.
	(main): Remove #if 0'd code.
	* filemode.c (filemodestring): Remove #if 0'd function.
	* sysdump.c (unit_info_list): Remove function.
	(object_body_list): Likewise.
	(program_structure): Likewise.
	(debug_list): Likewise.
	(module): Remove #if 0'd code.
@
text
@d2 2
a3 2
   Copyright 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002, 2003, 2004
   Free Software Foundation, Inc.
d49 5
a53 5
static void checksum (FILE *, char *, int, int);
static void writeINT (int, char *, int *, int, FILE *);
static void writeBITS (int, char *, int *, int);
static void writeBARRAY (barray, char *, int *, int, FILE *);
static void writeCHARS (char *, char *, int *, int, FILE *);
d161 1
a161 1
checksum (FILE *file, char *ptr, int size, int code)
d184 1
a184 1
writeINT (int n, char *ptr, int *idx, int size, FILE *file)
d225 1
a225 1
writeBITS (int val, char *ptr, int *idx, int size)
d242 2
a243 2
writeBARRAY (barray data, char *ptr, int *idx, int size ATTRIBUTE_UNUSED,
	     FILE *file)
d253 1
a253 1
writeCHARS (char *string, char *ptr, int *idx, int size, FILE *file)
@


1.13
log
@strings.c (usage): Place radix values for -t option into the correct order.

objcopy.c (add_redefine_syms_file): Change error messages to use
  <filename>:<linenumber>: format for easier parsing by automatic tools.

srconv.c (show_usage): Fix spelling typo.

windres.c (format_from_filename): Suggest the use of -J instead	of -I if the
  file type cannot be determined.
@
text
@d320 2
a321 6
#if 1
  un.nsections = ptr->nsections - 1;	/*  Don't count the abs section.  */
#else
  /*NEW - only count sections with size.  */
  un.nsections = nsecs;
#endif
a1206 5
#if 0
  struct coff_symbol *symbol;
  static int incit = 0x500000;
  int used = 0;
#endif
a1227 41
  /* Look through all the symbols and try and work out the extents in this
     source file.  */
#if 0
  for (symbol = sfile->scope->vars_head;
       symbol;
       symbol = symbol->next)
    {
      if (symbol->type->type == coff_secdef_type)
	{
	  unsigned int low = symbol->where->offset;
	  unsigned int high = symbol->where->offset + symbol->type->size - 1;
	  struct coff_section *section = symbol->where->section;

	  int sn = section->number;
	  if (low < lowest[sn])
	    lowest[sn] = low;
	  if (high > highest[sn])
	    highest[sn] = high;
	}
    }

  for (i = 0; i < du.sections; i++)
    {
      if (highest[i] == 0)
	lowest[i] = highest[i] = incit;

      du.san[used] = i;
      du.length[used] = highest[i] - lowest[i];
      du.address[used] = bfd_get_file_flags (abfd) & EXEC_P ? lowest[i] : 0;

      if (debug)
	{
	  printf (" section %6s 0x%08x..0x%08x\n",
		  p->sections[i + 1].name,
		  lowest[i],
		  highest[i]);
	}
      used++;
    }
#endif

a1280 13
#if 0
  i = 0;

  for (sfile = p->source_head;
       sfile;
       sfile = sfile->next)
    {
      dus.drb[i] = 0;
      dus.spare[i] = 0;
      dus.fname[i] = sfile->name;
      i++;
    }
#else
a1282 1
#endif
a1300 63
#if 0
  if (n == 0)
    {
      /* Count up all the linenumbers */
      struct coff_symbol *sy;
      int lc = 0;
      struct IT_dln dln;

      int idx;

      for (sy = p->symbol_list_head;
	   sy;
	   sy = sy->next_in_ofile_list)
	{
	  struct coff_type *t = sy->type;
	  if (t->type == coff_function_type)
	    {
	      struct coff_line *l = t->u.function.lines;
	      lc += l->nlines;
	    }
	}

      dln.sfn = nints (lc);
      dln.sln = nints (lc);
      dln.lln = nints (lc);
      dln.section = nints (lc);

      dln.from_address = nints (lc);
      dln.to_address = nints (lc);


      dln.neg = 0x1001;

      dln.nln = lc;

      /* Run through once more and fill up the structure */
      idx = 0;
      for (sy = p->symbol_list_head;
	   sy;
	   sy = sy->next_in_ofile_list)
	{
	  if (sy->type->type == coff_function_type)
	    {
	      int i;
	      struct coff_line *l = sy->type->u.function.lines;
	      for (i = 0; i < l->nlines; i++)
		{
		  dln.section[idx] = sy->where->section->number;
		  dln.sfn[idx] = n;
		  dln.sln[idx] = l->lines[i];
		  dln.from_address[idx] = l->addresses[i];
		  if (idx)
		    dln.to_address[idx - 1] = dln.from_address[idx];
		  idx++;
		}
	    }
	  n++;
	}
      sysroff_swap_dln_out (file, &dln);
    }

#endif
#if 1
a1366 1
#endif
d1567 3
a1569 10
#if 0
      /* NEW */
      if (sc.length)
	{
#endif
	  sysroff_swap_sc_out (file, &sc);
	  scount++;
#if 0
	}
#endif
@


1.12
log
@	* objcopy.c (copy_section): Use bfd_get_section_size instead of
	_raw_size or bfd_get_section_size_before_reloc.  Don't set reloc_done.
	(compare_section_lma): Likewise.
	* addr2line.c (find_address_in_section): Likewise.
	* coffgrok.c (do_sections_p1): Likewise.
	* dlltool.c (scan_drectve_symbols): Likewise.
	* nlmconv.c (main): Likewise.
	(copy_sections): Likewise.
	(powerpc_mangle_relocs): Likewise.
	* objdump.c (disassemble_section): Likewise.
	* prdbg.c (find_address_in_section): Likewise.
	* size.c (berkeley_sum): Likewise.
	* srconv.c (wr_ob): Likewise.
	* strings.c (strings_a_section): Likewise.
@
text
@d1859 1
a1859 1
  -q --quick       (Obsolete - ignoerd)\n\
@


1.11
log
@	* addr2line.c: Convert to ISO C90 prototypes, change PTR, remove
	unneeded (void *) casts.
	* ar.c: Likewise.
	* arlex.l: Likewise.
	* arparse.y: Likewise.
	* arsup.c: Likewise.
	* binemul.c: Likewise.
	* binemul.h: Likewise.
	* bucomm.c: Likewise.
	* bucomm.h: Likewise.
	* budbg.h: Likewise.
	* budemang.c: Likewise.
	* budemang.h: Likewise.
	* coffdump.c: Likewise.
	* coffgrok.c: Likewise.
	* cxxfilt.c: Likewise.
	* debug.c: Likewise.
	* debug.h: Likewise.
	* deflex.l: Likewise.
	* dlltool.c: Likewise.
	* dlltool.h: Likewise.
	* dllwrap.c: Likewise.
	* emul_aix.c: Likewise.
	* filemode.c: Likewise.
	* ieee.c: Likewise.
	* nlmconv.c: Likewise.
	* nlmconv.h: Likewise.
	* nlmheader.y: Likewise.
	* nm.c: Likewise.
	* prdbg.c: Likewise.
	* rclex.l: Likewise.
	* rcparse.y: Likewise.
	* rdcoff.c: Likewise.
	* rddbg.c: Likewise.
	* rename.c: Likewise.
	* resbin.c: Likewise.
	* rescoff.c: Likewise.
	* resrc.c: Likewise.
	* size.c: Likewise.
	* srconv.c: Likewise.
	* stabs.c: Likewise.
	* strings.c: Likewise.
	* sysdump.c: Likewise.
	* sysinfo.y: Likewise.
	* syslex.l: Likewise.
	* unwind-ia64.c: Likewise.
	* unwind-ia64.h: Likewise.
	* version.c: Likewise.
	* windres.c: Likewise.
	* windres.h: Likewise.
	* winduni.c: Likewise.
	* wrstabs.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002, 2003
d459 1
a459 1
  while (i < section->bfd_section->_raw_size)
d465 2
a466 2
      if (i + todo > section->bfd_section->_raw_size)
	todo = section->bfd_section->_raw_size - i;
@


1.10
log
@	* arlex.l: Use #include "" instead of <> for local header files.
	* coffdump.c: Likewise.
	* coffgrok.c: Likewise.
	* nlmconv.c: Likewise.
	* nlmheader.y: Likewise.
	* srconv.c: Likewise.
	* strings.c: Likewise.
	* sysdump.c: Likewise.
	* unwind-ia64.h: Likewise.
	* windres.h: Likewise.
	* winduni.h: Likewise.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1998, 1999, 2000, 2001, 2002
d45 16
a60 16
static int get_member_id PARAMS ((int));
static int get_ordinary_id PARAMS ((int));
static char *section_translate PARAMS ((char *));
static char *strip_suffix PARAMS ((char *));
static void checksum PARAMS ((FILE *, char *, int, int));
static void writeINT PARAMS ((int, char *, int *, int, FILE *));
static void writeBITS PARAMS ((int, char *, int *, int));
static void writeBARRAY PARAMS ((barray, char *, int *, int, FILE *));
static void writeCHARS PARAMS ((char *, char *, int *, int, FILE *));
static void wr_tr PARAMS ((void));
static void wr_un PARAMS ((struct coff_ofile *, struct coff_sfile *, int, int));
static void wr_hd PARAMS ((struct coff_ofile *));
static void wr_sh PARAMS ((struct coff_ofile *, struct coff_section *));
static void wr_ob PARAMS ((struct coff_ofile *, struct coff_section *));
static void wr_rl PARAMS ((struct coff_ofile *, struct coff_section *));
static void wr_object_body PARAMS ((struct coff_ofile *));
d62 3
a64 5
  PARAMS ((struct coff_sfile *, struct coff_section *, struct coff_scope *,
	   int, int));
static void wr_dps_end
  PARAMS ((struct coff_section *, struct coff_scope *, int));
static int *nints PARAMS ((int));
d66 1
a66 2
  PARAMS ((struct coff_sfile *, struct coff_symbol *, struct coff_type *,
	   int));
d68 1
a68 2
  PARAMS ((struct coff_sfile *, struct coff_symbol *, struct coff_type *,
	   int));
d70 1
a70 2
  PARAMS ((struct coff_sfile *, struct coff_section *,
	   struct coff_symbol *, int));
d72 19
a90 23
  PARAMS ((struct coff_section *, struct coff_sfile *, struct coff_scope *,
	   int, int));
static void walk_tree_sfile
  PARAMS ((struct coff_section *, struct coff_sfile *));
static void wr_program_structure
  PARAMS ((struct coff_ofile *, struct coff_sfile *));
static void wr_du PARAMS ((struct coff_ofile *, struct coff_sfile *, int));
static void wr_dus PARAMS ((struct coff_ofile *, struct coff_sfile *));
static int find_base PARAMS ((struct coff_sfile *, struct coff_section *));
static void wr_dln PARAMS ((struct coff_ofile *, struct coff_sfile *, int));
static void wr_globals
  PARAMS ((struct coff_ofile *, struct coff_sfile *, int));
static void wr_debug PARAMS ((struct coff_ofile *));
static void wr_cs PARAMS ((void));
static int wr_sc PARAMS ((struct coff_ofile *, struct coff_sfile *));
static void wr_er PARAMS ((struct coff_ofile *, struct coff_sfile *, int));
static void wr_ed PARAMS ((struct coff_ofile *, struct coff_sfile *, int));
static void wr_unit_info PARAMS ((struct coff_ofile *));
static void wr_module PARAMS ((struct coff_ofile *));
static int align PARAMS ((int));
static void prescan PARAMS ((struct coff_ofile *));
static void show_usage PARAMS ((FILE *, int));
extern int main PARAMS ((int, char **));
d112 1
a112 2
get_member_id (x)
     int x;
d122 1
a122 2
get_ordinary_id (x)
     int x;
d131 1
a131 2
section_translate (n)
     char *n;
d146 1
a146 2
strip_suffix (name)
     char *name;
d161 1
a161 5
checksum (file, ptr, size, code)
     FILE *file;
     char *ptr;
     int size;
     int code;
d184 1
a184 6
writeINT (n, ptr, idx, size, file)
     int n;
     char *ptr;
     int *idx;
     int size;
     FILE *file;
d225 1
a225 5
writeBITS (val, ptr, idx, size)
     int val;
     char *ptr;
     int *idx;
     int size;
d242 2
a243 6
writeBARRAY (data, ptr, idx, size, file)
     barray data;
     char *ptr;
     int *idx;
     int size ATTRIBUTE_UNUSED;
     FILE *file;
d253 1
a253 6
writeCHARS (string, ptr, idx, size, file)
     char *string;
     char *ptr;
     int *idx;
     int size;
     FILE *file;
d292 1
a292 1
wr_tr ()
d306 2
a307 5
wr_un (ptr, sfile, first, nsecs)
     struct coff_ofile *ptr;
     struct coff_sfile *sfile;
     int first;
     int nsecs ATTRIBUTE_UNUSED;
d352 1
a352 2
wr_hd (p)
     struct coff_ofile *p;
d439 1
a439 3
wr_sh (p, sec)
     struct coff_ofile *p ATTRIBUTE_UNUSED;
     struct coff_section *sec;
d452 1
a452 3
wr_ob (p, section)
     struct coff_ofile *p ATTRIBUTE_UNUSED;
     struct coff_section *section;
d513 1
a513 3
wr_rl (ptr, sec)
     struct coff_ofile *ptr ATTRIBUTE_UNUSED;
     struct coff_section *sec;
d571 1
a571 2
wr_object_body (p)
     struct coff_ofile *p;
d584 3
a586 6
wr_dps_start (sfile, section, scope, type, nest)
     struct coff_sfile *sfile;
     struct coff_section *section ATTRIBUTE_UNUSED;
     struct coff_scope *scope;
     int type;
     int nest;
d621 2
a622 4
wr_dps_end (section, scope, type)
     struct coff_section *section ATTRIBUTE_UNUSED;
     struct coff_scope *scope ATTRIBUTE_UNUSED;
     int type;
d632 1
a632 2
nints (x)
     int x;
d638 2
a639 5
walk_tree_type_1 (sfile, symbol, type, nest)
     struct coff_sfile *sfile;
     struct coff_symbol *symbol;
     struct coff_type *type;
     int nest;
d910 2
a911 5
walk_tree_type (sfile, symbol, type, nest)
     struct coff_sfile *sfile;
     struct coff_symbol *symbol;
     struct coff_type *type;
     int nest;
d957 1
a957 5
walk_tree_symbol (sfile, section, symbol, nest)
     struct coff_sfile *sfile;
     struct coff_section *section ATTRIBUTE_UNUSED;
     struct coff_symbol *symbol;
     int nest;
d1171 1
a1171 6
walk_tree_scope (section, sfile, scope, nest, type)
     struct coff_section *section;
     struct coff_sfile *sfile;
     struct coff_scope *scope;
     int nest;
     int type;
d1195 1
a1195 3
walk_tree_sfile (section, sfile)
     struct coff_section *section;
     struct coff_sfile *sfile;
d1201 1
a1201 3
wr_program_structure (p, sfile)
     struct coff_ofile *p;
     struct coff_sfile *sfile;
d1207 1
a1207 4
wr_du (p, sfile, n)
     struct coff_ofile *p;
     struct coff_sfile *sfile;
     int n;
d1320 1
a1320 3
wr_dus (p, sfile)
     struct coff_ofile *p ATTRIBUTE_UNUSED;
     struct coff_sfile *sfile;
d1356 1
a1356 3
find_base (sfile, section)
     struct coff_sfile *sfile;
     struct coff_section *section;
d1362 2
a1363 5
wr_dln (p, sfile, n)
     struct coff_ofile *p ATTRIBUTE_UNUSED;
     struct coff_sfile *sfile;
     int n ATTRIBUTE_UNUSED;

d1500 2
a1501 4
wr_globals (p, sfile, n)
     struct coff_ofile *p;
     struct coff_sfile *sfile;
     int n ATTRIBUTE_UNUSED;
d1521 1
a1521 2
wr_debug (p)
     struct coff_ofile *p;
d1542 1
a1542 1
wr_cs ()
d1590 1
a1590 3
wr_sc (ptr, sfile)
     struct coff_ofile *ptr;
     struct coff_sfile *sfile;
d1712 2
a1713 4
wr_er (ptr, sfile, first)
     struct coff_ofile *ptr;
     struct coff_sfile *sfile ATTRIBUTE_UNUSED;
     int first;
d1739 2
a1740 4
wr_ed (ptr, sfile, first)
     struct coff_ofile *ptr;
     struct coff_sfile *sfile ATTRIBUTE_UNUSED;
     int first;
d1779 1
a1779 2
wr_unit_info (ptr)
     struct coff_ofile *ptr;
d1806 1
a1806 2
wr_module (p)
     struct coff_ofile *p;
d1817 1
a1817 2
align (x)
     int x;
d1826 1
a1826 2
prescan (tree)
     struct coff_ofile *tree;
d1854 1
a1854 3
show_usage (file, status)
     FILE *file;
     int status;
d1871 1
a1871 3
main (ac, av)
     int ac;
     char *av[];
@


1.9
log
@	* size.c: Fix formatting.
	* srconv.c: Likewise.
	* stabs.c: Likewise.
	* sysdump.c: Likewise.
	* unwind-ia64.c: Likewise.
	* wrstabs.c: Likewise.
@
text
@d29 1
a29 1
#include <bfd.h>
d33 2
a34 2
#include <libiberty.h>
#include <getopt.h>
@


1.8
log
@Tidy up formatting of --help output.
@
text
@d107 1
a107 1
/* Obsolete ?? 
d926 1
a926 1
/* Obsolete ? 
d1635 11
a1645 11
    0x80,			/* hd */ 
    0x00,			/* hs */ 
    0x80,			/* un */ 
    0x00,			/* us */ 
    0x80,			/* sc */ 
    0x00,			/* ss */ 
    0x80,			/* er */ 
    0x80,			/* ed */ 
    0x80,			/* sh */ 
    0x80,			/* ob */ 
    0x80,			/* rl */ 
d1889 1
a1889 1
      fseek (file, p2, SEEK_SET); 
@


1.7
log
@	* coffdump.c (PROGRAM_VERSION): Delete.
	(main <'V'>): Call print_version.
	* srconv.c: Likewise.
	* sysdump.c: Likewise.
	* version.c (program_version): Remove.
	(print_version): Use BFD_VERSION_STRING.  Just print the current
	year in copyright message.
	* addr2line.c (program_version): Remove unused declaration.
	* objdump.c (display_target_tables): Use BFD_VERSION_STRING in
	place of BFD_VERSION.
	* Makefile.am (Makefile): Depend on bfd/configure.in
	(cplus-dem.o): Depend on Makefile.
	Run "make dep-am"
	* Makefile.in: Regenerate.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1998, 1999, 2000, 2001
a98 1
static void show_help PARAMS ((void));
d125 2
a126 3
    {
      return ids2[x];
    }
d136 2
a137 3
    {
      return ids1[x];
    }
a153 2


a155 1

d163 1
a171 1

d184 1
d192 3
a194 4
    {
      sum += ptr[j];
    }
  /* Glue on a checksum too */
a199 2


d217 1
a217 1
      /* Lets write out that record and do another one */
d222 1
a245 1

d256 1
d260 1
a260 1
  /* Turn off all about to change bits */
d262 1
a262 1
  /* Turn on the bits we want */
d276 1
d279 1
a279 3
    {
      writeINT (data.data[i], ptr, idx, 1, file);
    }
a281 1

d294 1
a294 1
      /* Lets write out that record and do another one */
d302 1
a302 1
      /* Variable length string */
d307 1
a307 1
  /* BUG WAITING TO HAPPEN */
a315 1

d329 1
a329 1
  /* The TR block is not normal - it doesn't have any contents. */
d331 6
a336 5
  static char b[] = {
    0xff,			/* IT */
    0x03,			/* RL */
    0xfd,			/* CS */
  };
a347 1

a357 1

d359 1
a359 1
  un.nsections = ptr->nsections - 1;	/*  Don't count the abs section */
d361 1
a361 1
  /*NEW - only count sections with size */
d367 1
a367 1
  /* Count all the undefined and defined variables with global scope */
a388 1

d397 1
a397 3
    {
      hd.mt = MTYPE_ABS_LM;
    }
d399 2
a400 3
    {
      hd.mt = MTYPE_OMS_OR_LMS;
    }
d406 1
d505 2
a506 1
      int todo = 200;		/* Copy in 200 byte lumps */
d526 1
a526 1
      ob.cpf = 0;		/* Never compress */
d533 2
a534 1
  /* Now fill the rest with blanks */
d538 2
a539 1
      int todo = 200;		/* Copy in 200 byte lumps */
d545 1
a545 1
      ob.cpf = 0;		/* Never compress */
d552 1
a552 2
  /* Now fill the rest with blanks */

d562 1
d568 1
d576 3
a578 2
      rl.flen = 32;		/* SH Specific */
      /* What sort of reloc ? Look in the section to find out */
d582 1
a582 1
	  rl.bcount = 4;	/* Always 4 for us */
d588 1
a588 1
	  rl.bcount = 11;	/* Always 11 for us */
a595 1

d598 1
a598 1
	  rl.bcount = 11;	/* Always 11 for us */
d606 1
d608 2
a609 1
      if (rl.op == OP_SEC_REF
d611 1
a611 3
	{
	  sysroff_swap_rl_out (file, &rl);
	}
d620 1
d638 1
d642 1
d648 1
a654 1

d676 1
d711 1
d717 1
d725 1
d730 1
d735 1
d740 1
d746 1
d755 1
d761 1
d765 1
d776 1
d789 2
a790 3
	  {
	    walk_tree_symbol (sfile, 0, param, nest);
	  }
d801 1
d813 1
d817 1
a817 3
	  {
	    walk_tree_symbol (sfile, 0, member, nest + 1);
	  }
d824 1
d828 1
d833 1
d835 1
a835 3
	  {
	    dbt.sid = get_member_id (type->u.astructref.ref->number);
	  }
d837 1
a837 3
	  {
	    dbt.sid = 0;
	  }
d843 1
d848 2
a849 1
	int dims = 1;		/* Only output one dimension at a time */
d862 1
d877 1
d883 1
d896 1
d900 1
a900 3
	  {
	    walk_tree_symbol (sfile, 0, member, nest + 1);
	  }
a906 1
      break;
d910 1
d920 1
d966 1
a966 3

     struct
     coff_sfile *sfile;
d973 1
a974 1
      struct IT_dty dty;
a999 1

d1004 1
a1011 1

a1013 2


d1023 1
a1023 1
  memset(&dsy, 0, sizeof(dsy));
d1032 1
d1041 1
d1047 1
d1053 1
d1056 1
d1066 1
a1085 1

d1094 1
d1098 1
d1102 1
d1107 1
d1113 1
d1118 1
d1124 1
d1134 1
a1140 1

d1144 1
d1154 1
d1158 1
a1159 2


d1176 1
d1182 1
a1185 1

d1189 1
d1200 1
a1200 1
      /* We do this 'cause common C symbols are treated as extdefs */
a1202 1

a1211 1

d1218 1
a1224 1

a1226 1

a1231 1

d1252 1
a1252 3
	{
	  walk_tree_symbol (sfile, section, vars, nest);
	}
d1255 1
a1255 3
	{
	  walk_tree_scope (section, sfile, child, nest + 1, BLOCK_TYPE_BLOCK);
	}
d1260 1
a1266 1

a1273 1

a1274 1

d1294 1
d1312 1
a1312 1
     source file */
a1331 1

d1335 2
a1336 3
	{
	  lowest[i] = highest[i] = incit;
	}
d1340 1
d1350 1
a1351 1
#endif
d1357 1
d1359 1
d1372 1
d1383 1
a1397 1

d1406 1
a1406 1
  /* Find the filenames */
d1429 1
a1429 1
   .text section for the output file */
d1578 2
a1579 1
/* Write the global symbols out to the debug info */
d1587 1
d1596 1
a1596 1
	     the current source file */
a1598 1

d1609 1
a1612 1

d1615 2
a1616 3
	{
	  printf ("%s\n", sfile->name);
	}
d1629 3
a1631 2
     heres one I prepared earlier.. */
  static char b[] = {
d1671 1
a1671 1
   if there isn't an equivalent one on the input */
d1679 2
a1680 3
int scount = 0;
  /* First work out the total number of sections */

a1681 1

a1687 1

a1691 1

d1717 1
a1717 2
     we don't have */

d1722 1
d1726 1
d1729 2
a1730 2
	  /* Don't have a symbol set aside for this section, which means that nothing
	     in this file does anything for the section. */
a1752 1

d1761 1
a1761 1
      sc.spare1 = 0;		/* If not zero, then it doesn't work */
d1763 1
d1772 1
d1783 2
a1784 1
      if (sc.length) {
d1786 2
a1787 2
	sysroff_swap_sc_out (file, &sc);
	scount++;
d1789 1
a1789 1
      }
d1792 1
a1792 1
return scount;
d1795 1
a1796 1
/* Write out the ER records for a unit. */
d1805 1
d1813 1
d1824 2
a1825 1
/* Write out the ED records for a unit. */
d1833 1
d1845 1
d1859 1
d1874 1
d1882 1
d1916 1
a1916 1
   ordinary defs - dunno why, but thats what hitachi does with 'em */
d1924 2
a1925 1
  /* Find the common section - always section 3 */
d1927 1
d1952 11
a1962 1
  fprintf (file, _("Usage: %s [-dhVq] in-file [out-file]\n"), program_name);
a1965 10
static void
show_help ()
{
  printf (_("%s: Convert a COFF object file into a SYSROFF object file\n"),
	  program_name);
  show_usage (stdout, 0);
}



d1997 1
a1997 1
  while ((opt = getopt_long (ac, av, "dhVqn", long_options,
d2012 1
d2014 1
a2014 1
	  show_help ();
d2016 1
d2061 1
d2064 1
d2087 1
d2099 1
a2099 3
    {
      fatal (_("unable to open output file %s"), output_file);
    }
d2103 1
d2105 1
d2108 1
@


1.6
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@a38 1
#define PROGRAM_VERSION "1.5"
d1995 1
a1995 1
	  printf (_("GNU %s version %s\n"), program_name, PROGRAM_VERSION);
@


1.5
log
@	* coffgrok.h: Add missing parameter for prototype of coff_grok.

	* sysdump.c: Add missing prototypes.
	* srconv.c: Likewise.
	* unwind-ia64.c: Likewise.
	* coffdump.c: Likewise.

	* sysinfo.y: Print prototypes, include <ansidecl.h>.

	* coffgrok.c: Add missing prototypes, include libiberty.h instead
	of declaring xcalloc.
@
text
@d1968 3
@


1.4
log
@Fix typos in ChangeLogs and update copyright notices
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1996, 1998, 1999, 2000
d46 56
a101 4
static void wr_cs ();
static void walk_tree_scope ();
static void wr_globals ();
static int find_base ();
a695 1
static void walk_tree_symbol ();
@


1.3
log
@fix gcc warnings
@
text
@d2 2
a3 1
   Copyright (C) 1994, 95, 96, 98, 99, 2000 Free Software Foundation, Inc.
@


1.3.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1994, 1995, 1996, 1998, 1999, 2000
   Free Software Foundation, Inc.
@


1.2
log
@A mostly cosmetic tidy up of warnings and error message reporting.
@
text
@d227 1
a227 1
     int size;
d302 1
a302 1
     int nsecs;
d441 1
a441 1
     struct coff_ofile *p;
d456 1
a456 1
     struct coff_ofile *p;
d517 1
a517 1
     struct coff_ofile *ptr;
d589 1
a589 1
     struct coff_section *section;
d626 2
a627 2
     struct coff_section *section;
     struct coff_scope *scope;
d963 1
a963 1
     struct coff_section *section;
d1332 1
a1332 1
     struct coff_ofile *p;
d1376 1
d1379 1
a1379 1
     struct coff_ofile *p;
d1381 1
a1381 1
     int n;
d1521 1
a1521 1
     int n;
d1738 1
a1738 1
     struct coff_sfile *sfile;
d1764 1
a1764 1
     struct coff_sfile *sfile;
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1994, 95, 96, 98, 1999 Free Software Foundation, Inc.
d1965 1
a1965 4
	      fprintf (stderr,
		       _("%s: input and output files must be different\n"),
		       program_name);
	      exit (1);
d1974 1
a1974 3
      fprintf (stderr, _("%s: no input file specified\n"),
	       program_name);
      exit (1);
d2019 1
a2019 3
      fprintf (stderr, _("%s: unable to open output file %s\n"),
	       program_name, output_file);
      exit (1);
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@


1.1.1.1.2.1
log
@A mostly cosmetic tidy up of warnings and error message reporting.
@
text
@d2 1
a2 1
   Copyright (C) 1994, 95, 96, 98, 99, 2000 Free Software Foundation, Inc.
d1965 4
a1968 1
	      fatal (_("input and output files must be different"));
d1977 3
a1979 1
      fatal (_("no input file specified"));
d2024 3
a2026 1
      fatal (_("unable to open output file %s"), output_file);
@


