head	1.71;
access;
symbols
	binutils-2_24-branch:1.71.0.2
	binutils-2_24-branchpoint:1.71
	binutils-2_21_1:1.65.2.1
	binutils-2_23_2:1.70
	binutils-2_23_1:1.70
	binutils-2_23:1.70
	binutils-2_23-branch:1.70.0.2
	binutils-2_23-branchpoint:1.70
	binutils-2_22_branch:1.68.0.4
	binutils-2_22:1.68
	binutils-2_22-branch:1.68.0.2
	binutils-2_22-branchpoint:1.68
	binutils-2_21:1.65
	binutils-2_21-branch:1.65.0.2
	binutils-2_21-branchpoint:1.65
	binutils-2_20_1:1.60.2.1
	binutils-2_20:1.60.2.1
	binutils-arc-20081103-branch:1.55.0.6
	binutils-arc-20081103-branchpoint:1.55
	binutils-2_20-branch:1.60.0.2
	binutils-2_20-branchpoint:1.60
	dje-cgen-play1-branch:1.59.0.2
	dje-cgen-play1-branchpoint:1.59
	arc-20081103-branch:1.55.0.4
	arc-20081103-branchpoint:1.55
	binutils-2_19_1:1.55
	binutils-2_19:1.55
	binutils-2_19-branch:1.55.0.2
	binutils-2_19-branchpoint:1.55
	binutils-2_18:1.54
	binutils-2_18-branch:1.54.0.2
	binutils-2_18-branchpoint:1.54
	binutils-csl-coldfire-4_1-32:1.48.2.1
	binutils-csl-sourcerygxx-4_1-32:1.48.2.1
	binutils-csl-innovasic-fido-3_4_4-33:1.48.2.1
	binutils-csl-sourcerygxx-3_4_4-32:1.44.6.1
	binutils-csl-coldfire-4_1-30:1.48.2.1
	binutils-csl-sourcerygxx-4_1-30:1.48.2.1
	binutils-csl-coldfire-4_1-28:1.48.2.1
	binutils-csl-sourcerygxx-4_1-29:1.48.2.1
	binutils-csl-sourcerygxx-4_1-28:1.48.2.1
	binutils-csl-arm-2006q3-27:1.48.2.1
	binutils-csl-sourcerygxx-4_1-27:1.48.2.1
	binutils-csl-arm-2006q3-26:1.48.2.1
	binutils-csl-sourcerygxx-4_1-26:1.48.2.1
	binutils-csl-sourcerygxx-4_1-25:1.48.2.1
	binutils-csl-sourcerygxx-4_1-24:1.48
	binutils-csl-sourcerygxx-4_1-23:1.48
	binutils-csl-sourcerygxx-4_1-21:1.48
	binutils-csl-arm-2006q3-21:1.48
	binutils-csl-sourcerygxx-4_1-22:1.48
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.48
	binutils-csl-sourcerygxx-4_1-20:1.48
	binutils-csl-arm-2006q3-19:1.48
	binutils-csl-sourcerygxx-4_1-19:1.48
	binutils-csl-sourcerygxx-4_1-18:1.48
	binutils-csl-renesas-4_1-9:1.48
	binutils-csl-sourcerygxx-3_4_4-25:1.44.6.1
	binutils-csl-renesas-4_1-8:1.48
	binutils-csl-renesas-4_1-7:1.48
	binutils-csl-renesas-4_1-6:1.48
	binutils-csl-sourcerygxx-4_1-17:1.48
	binutils-csl-sourcerygxx-4_1-14:1.48
	binutils-csl-sourcerygxx-4_1-15:1.48
	binutils-csl-sourcerygxx-4_1-13:1.48
	binutils-2_17:1.48
	binutils-csl-sourcerygxx-4_1-12:1.48
	binutils-csl-sourcerygxx-3_4_4-21:1.48
	binutils-csl-wrs-linux-3_4_4-24:1.44
	binutils-csl-wrs-linux-3_4_4-23:1.44
	binutils-csl-sourcerygxx-4_1-9:1.48
	binutils-csl-sourcerygxx-4_1-8:1.48
	binutils-csl-sourcerygxx-4_1-7:1.48
	binutils-csl-arm-2006q1-6:1.48
	binutils-csl-sourcerygxx-4_1-6:1.48
	binutils-csl-wrs-linux-3_4_4-22:1.44
	binutils-csl-coldfire-4_1-11:1.48
	binutils-csl-sourcerygxx-3_4_4-19:1.48
	binutils-csl-coldfire-4_1-10:1.48
	binutils-csl-sourcerygxx-4_1-5:1.48
	binutils-csl-sourcerygxx-4_1-4:1.48
	binutils-csl-wrs-linux-3_4_4-21:1.44
	binutils-csl-morpho-4_1-4:1.48
	binutils-csl-sourcerygxx-3_4_4-17:1.48
	binutils-csl-wrs-linux-3_4_4-20:1.44
	binutils-2_17-branch:1.48.0.4
	binutils-2_17-branchpoint:1.48
	binutils-csl-2_17-branch:1.48.0.2
	binutils-csl-2_17-branchpoint:1.48
	binutils-csl-gxxpro-3_4-branch:1.44.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.44
	binutils-2_16_1:1.44
	binutils-csl-arm-2005q1b:1.44
	binutils-2_16:1.44
	binutils-csl-arm-2005q1a:1.44
	binutils-csl-arm-2005q1-branch:1.44.0.4
	binutils-csl-arm-2005q1-branchpoint:1.44
	binutils-2_16-branch:1.44.0.2
	binutils-2_16-branchpoint:1.44
	csl-arm-2004-q3d:1.43
	csl-arm-2004-q3:1.41
	binutils-2_15:1.39
	binutils-2_15-branchpoint:1.39
	csl-arm-2004-q1a:1.39
	csl-arm-2004-q1:1.39
	binutils-2_15-branch:1.39.0.6
	cagney_bfdfile-20040213-branch:1.39.0.4
	cagney_bfdfile-20040213-branchpoint:1.39
	cagney_bigcore-20040122-branch:1.39.0.2
	cagney_bigcore-20040122-branchpoint:1.39
	csl-arm-2003-q4:1.39
	binutils-2_14:1.36
	binutils-2_14-branch:1.36.0.2
	binutils-2_14-branchpoint:1.36
	binutils-2_13_2_1:1.29
	binutils-2_13_2:1.29
	binutils-2_13_1:1.29
	binutils-2_13:1.29
	binutils-2_13-branchpoint:1.29
	binutils-2_13-branch:1.29.0.2
	binutils-2_12_1:1.19.2.1
	binutils-2_12:1.19
	binutils-2_12-branch:1.19.0.2
	binutils-2_12-branchpoint:1.19
	cygnus_cvs_20020108_pre:1.17
	binutils-2_11_2:1.10.2.3
	binutils-2_11_1:1.10.2.3
	binutils-2_11:1.10.2.1
	x86_64versiong3:1.11
	binutils-2_11-branch:1.10.0.2
	binutils-2_10_1:1.4.2.3
	binutils-2_10:1.4.2.2
	binutils-2_10-branch:1.4.0.2
	binutils-2_10-branchpoint:1.4
	binutils_latest_snapshot:1.71
	repo-unification-2000-02-06:1.4
	binu_ss_19990721:1.2
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.71
date	2013.08.19.15.08.52;	author gingold;	state Exp;
branches;
next	1.70;

1.70
date	2012.06.29.16.55.15;	author hjl;	state Exp;
branches;
next	1.69;

1.69
date	2012.01.16.08.43.20;	author amodra;	state Exp;
branches;
next	1.68;

1.68
date	2011.07.12.04.47.49;	author ccoutant;	state Exp;
branches;
next	1.67;

1.67
date	2011.05.18.16.35.01;	author nickc;	state Exp;
branches;
next	1.66;

1.66
date	2011.03.14.17.37.53;	author msnyder;	state Exp;
branches;
next	1.65;

1.65
date	2010.10.08.15.12.29;	author jsm28;	state Exp;
branches
	1.65.2.1;
next	1.64;

1.64
date	2010.10.03.10.49.19;	author hjl;	state Exp;
branches;
next	1.63;

1.63
date	2010.01.06.08.48.19;	author gingold;	state Exp;
branches;
next	1.62;

1.62
date	2009.12.11.13.42.06;	author nickc;	state Exp;
branches;
next	1.61;

1.61
date	2009.09.10.13.40.44;	author nickc;	state Exp;
branches;
next	1.60;

1.60
date	2009.09.02.07.22.32;	author amodra;	state Exp;
branches
	1.60.2.1;
next	1.59;

1.59
date	2009.06.19.15.05.23;	author nickc;	state Exp;
branches;
next	1.58;

1.58
date	2009.05.28.11.30.49;	author nickc;	state Exp;
branches;
next	1.57;

1.57
date	2009.05.26.14.12.03;	author nickc;	state Exp;
branches;
next	1.56;

1.56
date	2008.11.13.10.57.00;	author hp;	state Exp;
branches;
next	1.55;

1.55
date	2007.09.13.14.32.11;	author amodra;	state Exp;
branches;
next	1.54;

1.54
date	2007.07.05.16.54.45;	author nickc;	state Exp;
branches;
next	1.53;

1.53
date	2007.04.26.14.46.59;	author amodra;	state Exp;
branches;
next	1.52;

1.52
date	2007.04.19.10.43.47;	author amodra;	state Exp;
branches;
next	1.51;

1.51
date	2007.04.05.06.36.35;	author amodra;	state Exp;
branches;
next	1.50;

1.50
date	2007.04.02.16.51.13;	author nickc;	state Exp;
branches;
next	1.49;

1.49
date	2007.02.17.13.33.54;	author jsm28;	state Exp;
branches;
next	1.48;

1.48
date	2005.10.03.19.37.44;	author mmitchel;	state Exp;
branches
	1.48.2.1;
next	1.47;

1.47
date	2005.09.30.16.37.31;	author mmitchel;	state Exp;
branches;
next	1.46;

1.46
date	2005.06.06.14.28.31;	author hjl;	state Exp;
branches;
next	1.45;

1.45
date	2005.05.08.14.17.38;	author nickc;	state Exp;
branches;
next	1.44;

1.44
date	2005.01.25.10.33.55;	author amodra;	state Exp;
branches
	1.44.6.1;
next	1.43;

1.43
date	2004.10.14.09.36.54;	author nickc;	state Exp;
branches;
next	1.42;

1.42
date	2004.10.08.14.54.03;	author nickc;	state Exp;
branches;
next	1.41;

1.41
date	2004.09.28.16.26.39;	author nickc;	state Exp;
branches;
next	1.40;

1.40
date	2004.08.28.08.55.47;	author amodra;	state Exp;
branches;
next	1.39;

1.39
date	2003.11.07.12.19.34;	author nickc;	state Exp;
branches;
next	1.38;

1.38
date	2003.10.27.13.20.32;	author kazu;	state Exp;
branches;
next	1.37;

1.37
date	2003.09.14.12.20.16;	author aj;	state Exp;
branches;
next	1.36;

1.36
date	2003.03.17.10.14.07;	author nickc;	state Exp;
branches;
next	1.35;

1.35
date	2003.03.04.16.23.46;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	2003.02.13.09.53.06;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	2002.11.30.08.39.41;	author amodra;	state Exp;
branches;
next	1.32;

1.32
date	2002.08.26.23.12.56;	author amodra;	state Exp;
branches;
next	1.31;

1.31
date	2002.08.26.10.14.15;	author amodra;	state Exp;
branches;
next	1.30;

1.30
date	2002.08.14.15.12.07;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	2002.07.02.04.21.24;	author amodra;	state Exp;
branches;
next	1.28;

1.28
date	2002.06.26.13.23.45;	author amodra;	state Exp;
branches;
next	1.27;

1.27
date	2002.06.21.02.34.38;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2002.06.19.03.07.04;	author hjl;	state Exp;
branches;
next	1.25;

1.25
date	2002.06.15.18.40.25;	author hjl;	state Exp;
branches;
next	1.24;

1.24
date	2002.06.13.17.04.39;	author nickc;	state Exp;
branches;
next	1.23;

1.23
date	2002.06.08.07.38.30;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2002.06.07.11.02.48;	author nickc;	state Exp;
branches;
next	1.21;

1.21
date	2002.05.21.19.34.58;	author kazu;	state Exp;
branches;
next	1.20;

1.20
date	2002.05.01.06.43.32;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2002.01.30.05.00.07;	author drow;	state Exp;
branches
	1.19.2.1;
next	1.18;

1.18
date	2002.01.23.16.12.55;	author nickc;	state Exp;
branches;
next	1.17;

1.17
date	2001.12.18.08.22.30;	author ths;	state Exp;
branches;
next	1.16;

1.16
date	2001.09.19.05.33.16;	author hjl;	state Exp;
branches;
next	1.15;

1.15
date	2001.08.25.15.16.39;	author hjl;	state Exp;
branches;
next	1.14;

1.14
date	2001.08.10.16.43.18;	author hjl;	state Exp;
branches;
next	1.13;

1.13
date	2001.04.11.07.07.29;	author amodra;	state Exp;
branches;
next	1.12;

1.12
date	2001.03.13.06.43.57;	author nickc;	state Exp;
branches;
next	1.11;

1.11
date	2001.02.09.16.33.21;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2000.07.27.01.39.45;	author geoffk;	state Exp;
branches
	1.10.2.1;
next	1.9;

1.9
date	2000.07.20.18.02.55;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2000.07.20.00.39.10;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2000.04.07.04.34.50;	author amodra;	state Exp;
branches;
next	1.6;

1.6
date	2000.04.04.14.32.29;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2000.04.03.14.10.03;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2000.01.28.01.06.37;	author nickc;	state Exp;
branches
	1.4.2.1;
next	1.3;

1.3
date	99.09.06.18.47.31;	author ian;	state Exp;
branches;
next	1.2;

1.2
date	99.07.11.20.02.20;	author ian;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.29.10;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.65.2.1
date	2011.05.29.04.51.23;	author amodra;	state Exp;
branches;
next	;

1.60.2.1
date	2009.09.10.13.42.08;	author nickc;	state Exp;
branches;
next	;

1.48.2.1
date	2006.10.16.20.21.23;	author nathan;	state Exp;
branches;
next	;

1.44.6.1
date	2005.08.30.19.57.32;	author mmitchel;	state Exp;
branches;
next	;

1.19.2.1
date	2002.05.09.11.53.25;	author amodra;	state Exp;
branches;
next	;

1.10.2.1
date	2001.02.09.16.33.59;	author amodra;	state Exp;
branches;
next	1.10.2.2;

1.10.2.2
date	2001.06.07.03.12.27;	author amodra;	state Exp;
branches;
next	1.10.2.3;

1.10.2.3
date	2001.06.11.10.04.27;	author amodra;	state Exp;
branches;
next	;

1.4.2.1
date	2000.04.05.05.36.40;	author amodra;	state Exp;
branches;
next	1.4.2.2;

1.4.2.2
date	2000.04.07.04.39.24;	author amodra;	state Exp;
branches;
next	1.4.2.3;

1.4.2.3
date	2000.10.14.18.42.22;	author pb;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.10;	author rth;	state Exp;
branches;
next	;


desc
@@


1.71
log
@binutils/
2013-08-19  Tristan Gingold  <gingold@@adacore.com>

	* nm.c (print_size_symbols): Directly get symbol size.


binutils/testsuite/
2013-08-19  Tristan Gingold  <gingold@@adacore.com>

	* binutils-all/nm.exp: Add a test for nm --size-sort
	* binutils-all/nm-elf-1.s: New file.
	* binutils-all/nm-1.s: New file.
@
text
@/* nm.c -- Describe symbol table of a rel file.
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010, 2011, 2012
   Free Software Foundation, Inc.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

#include "sysdep.h"
#include "bfd.h"
#include "progress.h"
#include "getopt.h"
#include "aout/stab_gnu.h"
#include "aout/ranlib.h"
#include "demangle.h"
#include "libiberty.h"
#include "elf-bfd.h"
#include "elf/common.h"
#include "bucomm.h"
#include "plugin.h"

/* When sorting by size, we use this structure to hold the size and a
   pointer to the minisymbol.  */

struct size_sym
{
  const void *minisym;
  bfd_vma size;
};

/* When fetching relocs, we use this structure to pass information to
   get_relocs.  */

struct get_relocs_info
{
  asection **secs;
  arelent ***relocs;
  long *relcount;
  asymbol **syms;
};

struct extended_symbol_info
{
  symbol_info *sinfo;
  bfd_vma ssize;
  elf_symbol_type *elfinfo;
  /* FIXME: We should add more fields for Type, Line, Section.  */
};
#define SYM_NAME(sym)        (sym->sinfo->name)
#define SYM_VALUE(sym)       (sym->sinfo->value)
#define SYM_TYPE(sym)        (sym->sinfo->type)
#define SYM_STAB_NAME(sym)   (sym->sinfo->stab_name)
#define SYM_STAB_DESC(sym)   (sym->sinfo->stab_desc)
#define SYM_STAB_OTHER(sym)  (sym->sinfo->stab_other)
#define SYM_SIZE(sym) \
  (sym->elfinfo ? sym->elfinfo->internal_elf_sym.st_size: sym->ssize)

/* The output formatting functions.  */
static void print_object_filename_bsd (char *);
static void print_object_filename_sysv (char *);
static void print_object_filename_posix (char *);
static void print_archive_filename_bsd (char *);
static void print_archive_filename_sysv (char *);
static void print_archive_filename_posix (char *);
static void print_archive_member_bsd (char *, const char *);
static void print_archive_member_sysv (char *, const char *);
static void print_archive_member_posix (char *, const char *);
static void print_symbol_filename_bsd (bfd *, bfd *);
static void print_symbol_filename_sysv (bfd *, bfd *);
static void print_symbol_filename_posix (bfd *, bfd *);
static void print_value (bfd *, bfd_vma);
static void print_symbol_info_bsd (struct extended_symbol_info *, bfd *);
static void print_symbol_info_sysv (struct extended_symbol_info *, bfd *);
static void print_symbol_info_posix (struct extended_symbol_info *, bfd *);

/* Support for different output formats.  */
struct output_fns
  {
    /* Print the name of an object file given on the command line.  */
    void (*print_object_filename) (char *);

    /* Print the name of an archive file given on the command line.  */
    void (*print_archive_filename) (char *);

    /* Print the name of an archive member file.  */
    void (*print_archive_member) (char *, const char *);

    /* Print the name of the file (and archive, if there is one)
       containing a symbol.  */
    void (*print_symbol_filename) (bfd *, bfd *);

    /* Print a line of information about a symbol.  */
    void (*print_symbol_info) (struct extended_symbol_info *, bfd *);
  };

static struct output_fns formats[] =
{
  {print_object_filename_bsd,
   print_archive_filename_bsd,
   print_archive_member_bsd,
   print_symbol_filename_bsd,
   print_symbol_info_bsd},
  {print_object_filename_sysv,
   print_archive_filename_sysv,
   print_archive_member_sysv,
   print_symbol_filename_sysv,
   print_symbol_info_sysv},
  {print_object_filename_posix,
   print_archive_filename_posix,
   print_archive_member_posix,
   print_symbol_filename_posix,
   print_symbol_info_posix}
};

/* Indices in `formats'.  */
#define FORMAT_BSD 0
#define FORMAT_SYSV 1
#define FORMAT_POSIX 2
#define FORMAT_DEFAULT FORMAT_BSD

/* The output format to use.  */
static struct output_fns *format = &formats[FORMAT_DEFAULT];

/* Command options.  */

static int do_demangle = 0;	/* Pretty print C++ symbol names.  */
static int external_only = 0;	/* Print external symbols only.  */
static int defined_only = 0;	/* Print defined symbols only.  */
static int no_sort = 0;		/* Don't sort; print syms in order found.  */
static int print_debug_syms = 0;/* Print debugger-only symbols too.  */
static int print_armap = 0;	/* Describe __.SYMDEF data in archive files.  */
static int print_size = 0;	/* Print size of defined symbols.  */
static int reverse_sort = 0;	/* Sort in downward(alpha or numeric) order.  */
static int sort_numerically = 0;/* Sort in numeric rather than alpha order.  */
static int sort_by_size = 0;	/* Sort by size of symbol.  */
static int undefined_only = 0;	/* Print undefined symbols only.  */
static int dynamic = 0;		/* Print dynamic symbols.  */
static int show_version = 0;	/* Show the version number.  */
static int show_stats = 0;	/* Show statistics.  */
static int show_synthetic = 0;	/* Display synthesized symbols too.  */
static int line_numbers = 0;	/* Print line numbers for symbols.  */
static int allow_special_symbols = 0;  /* Allow special symbols.  */

/* When to print the names of files.  Not mutually exclusive in SYSV format.  */
static int filename_per_file = 0;	/* Once per file, on its own line.  */
static int filename_per_symbol = 0;	/* Once per symbol, at start of line.  */

/* Print formats for printing a symbol value.  */
static char value_format_32bit[] = "%08lx";
#if BFD_HOST_64BIT_LONG
static char value_format_64bit[] = "%016lx";
#elif BFD_HOST_64BIT_LONG_LONG
#ifndef __MSVCRT__
static char value_format_64bit[] = "%016llx";
#else
static char value_format_64bit[] = "%016I64x";
#endif
#endif
static int print_width = 0;
static int print_radix = 16;
/* Print formats for printing stab info.  */
static char other_format[] = "%02x";
static char desc_format[] = "%04x";

static char *target = NULL;
static char *plugin_target = NULL;

/* Used to cache the line numbers for a BFD.  */
static bfd *lineno_cache_bfd;
static bfd *lineno_cache_rel_bfd;

#define OPTION_TARGET 200
#define OPTION_PLUGIN (OPTION_TARGET + 1)
#define OPTION_SIZE_SORT (OPTION_PLUGIN + 1)

static struct option long_options[] =
{
  {"debug-syms", no_argument, &print_debug_syms, 1},
  {"demangle", optional_argument, 0, 'C'},
  {"dynamic", no_argument, &dynamic, 1},
  {"extern-only", no_argument, &external_only, 1},
  {"format", required_argument, 0, 'f'},
  {"help", no_argument, 0, 'h'},
  {"line-numbers", no_argument, 0, 'l'},
  {"no-cplus", no_argument, &do_demangle, 0},  /* Linux compatibility.  */
  {"no-demangle", no_argument, &do_demangle, 0},
  {"no-sort", no_argument, 0, 'p'},
  {"numeric-sort", no_argument, 0, 'n'},
  {"plugin", required_argument, 0, OPTION_PLUGIN},
  {"portability", no_argument, 0, 'P'},
  {"print-armap", no_argument, &print_armap, 1},
  {"print-file-name", no_argument, 0, 'o'},
  {"print-size", no_argument, 0, 'S'},
  {"radix", required_argument, 0, 't'},
  {"reverse-sort", no_argument, &reverse_sort, 1},
  {"size-sort", no_argument, 0, OPTION_SIZE_SORT},
  {"special-syms", no_argument, &allow_special_symbols, 1},
  {"stats", no_argument, &show_stats, 1},
  {"synthetic", no_argument, &show_synthetic, 1},
  {"target", required_argument, 0, OPTION_TARGET},
  {"defined-only", no_argument, &defined_only, 1},
  {"undefined-only", no_argument, &undefined_only, 1},
  {"version", no_argument, &show_version, 1},
  {0, no_argument, 0, 0}
};

/* Some error-reporting functions.  */

static void
usage (FILE *stream, int status)
{
  fprintf (stream, _("Usage: %s [option(s)] [file(s)]\n"), program_name);
  fprintf (stream, _(" List symbols in [file(s)] (a.out by default).\n"));
  fprintf (stream, _(" The options are:\n\
  -a, --debug-syms       Display debugger-only symbols\n\
  -A, --print-file-name  Print name of the input file before every symbol\n\
  -B                     Same as --format=bsd\n\
  -C, --demangle[=STYLE] Decode low-level symbol names into user-level names\n\
                          The STYLE, if specified, can be `auto' (the default),\n\
                          `gnu', `lucid', `arm', `hp', `edg', `gnu-v3', `java'\n\
                          or `gnat'\n\
      --no-demangle      Do not demangle low-level symbol names\n\
  -D, --dynamic          Display dynamic symbols instead of normal symbols\n\
      --defined-only     Display only defined symbols\n\
  -e                     (ignored)\n\
  -f, --format=FORMAT    Use the output format FORMAT.  FORMAT can be `bsd',\n\
                           `sysv' or `posix'.  The default is `bsd'\n\
  -g, --extern-only      Display only external symbols\n\
  -l, --line-numbers     Use debugging information to find a filename and\n\
                           line number for each symbol\n\
  -n, --numeric-sort     Sort symbols numerically by address\n\
  -o                     Same as -A\n\
  -p, --no-sort          Do not sort the symbols\n\
  -P, --portability      Same as --format=posix\n\
  -r, --reverse-sort     Reverse the sense of the sort\n"));
#if BFD_SUPPORTS_PLUGINS
  fprintf (stream, _("\
      --plugin NAME      Load the specified plugin\n"));
#endif
  fprintf (stream, _("\
  -S, --print-size       Print size of defined symbols\n\
  -s, --print-armap      Include index for symbols from archive members\n\
      --size-sort        Sort symbols by size\n\
      --special-syms     Include special symbols in the output\n\
      --synthetic        Display synthetic symbols as well\n\
  -t, --radix=RADIX      Use RADIX for printing symbol values\n\
      --target=BFDNAME   Specify the target object format as BFDNAME\n\
  -u, --undefined-only   Display only undefined symbols\n\
  -X 32_64               (ignored)\n\
  @@FILE                  Read options from FILE\n\
  -h, --help             Display this information\n\
  -V, --version          Display this program's version number\n\
\n"));
  list_supported_targets (program_name, stream);
  if (REPORT_BUGS_TO[0] && status == 0)
    fprintf (stream, _("Report bugs to %s.\n"), REPORT_BUGS_TO);
  exit (status);
}

/* Set the radix for the symbol value and size according to RADIX.  */

static void
set_print_radix (char *radix)
{
  switch (*radix)
    {
    case 'x':
      break;
    case 'd':
    case 'o':
      if (*radix == 'd')
	print_radix = 10;
      else
	print_radix = 8;
      value_format_32bit[4] = *radix;
#if BFD_HOST_64BIT_LONG
      value_format_64bit[5] = *radix;
#elif BFD_HOST_64BIT_LONG_LONG
#ifndef __MSVCRT__
      value_format_64bit[6] = *radix;
#else
      value_format_64bit[7] = *radix;
#endif
#endif
      other_format[3] = desc_format[3] = *radix;
      break;
    default:
      fatal (_("%s: invalid radix"), radix);
    }
}

static void
set_output_format (char *f)
{
  int i;

  switch (*f)
    {
    case 'b':
    case 'B':
      i = FORMAT_BSD;
      break;
    case 'p':
    case 'P':
      i = FORMAT_POSIX;
      break;
    case 's':
    case 'S':
      i = FORMAT_SYSV;
      break;
    default:
      fatal (_("%s: invalid output format"), f);
    }
  format = &formats[i];
}

static const char *
get_symbol_type (unsigned int type)
{
  static char buff [32];

  switch (type)
    {
    case STT_NOTYPE:   return "NOTYPE";
    case STT_OBJECT:   return "OBJECT";
    case STT_FUNC:     return "FUNC";
    case STT_SECTION:  return "SECTION";
    case STT_FILE:     return "FILE";
    case STT_COMMON:   return "COMMON";
    case STT_TLS:      return "TLS";
    default:
      if (type >= STT_LOPROC && type <= STT_HIPROC)
	sprintf (buff, _("<processor specific>: %d"), type);
      else if (type >= STT_LOOS && type <= STT_HIOS)
	sprintf (buff, _("<OS specific>: %d"), type);
      else
	sprintf (buff, _("<unknown>: %d"), type);
      return buff;
    }
}

/* Print symbol name NAME, read from ABFD, with printf format FORM,
   demangling it if requested.  */

static void
print_symname (const char *form, const char *name, bfd *abfd)
{
  if (do_demangle && *name)
    {
      char *res = bfd_demangle (abfd, name, DMGL_ANSI | DMGL_PARAMS);

      if (res != NULL)
	{
	  printf (form, res);
	  free (res);
	  return;
	}
    }

  printf (form, name);
}

static void
print_symdef_entry (bfd *abfd)
{
  symindex idx = BFD_NO_MORE_SYMBOLS;
  carsym *thesym;
  bfd_boolean everprinted = FALSE;

  for (idx = bfd_get_next_mapent (abfd, idx, &thesym);
       idx != BFD_NO_MORE_SYMBOLS;
       idx = bfd_get_next_mapent (abfd, idx, &thesym))
    {
      bfd *elt;
      if (!everprinted)
	{
	  printf (_("\nArchive index:\n"));
	  everprinted = TRUE;
	}
      elt = bfd_get_elt_at_index (abfd, idx);
      if (elt == NULL)
	bfd_fatal ("bfd_get_elt_at_index");
      if (thesym->name != (char *) NULL)
	{
	  print_symname ("%s", thesym->name, abfd);
	  printf (" in %s\n", bfd_get_filename (elt));
	}
    }
}

/* Choose which symbol entries to print;
   compact them downward to get rid of the rest.
   Return the number of symbols to be printed.  */

static long
filter_symbols (bfd *abfd, bfd_boolean is_dynamic, void *minisyms,
		long symcount, unsigned int size)
{
  bfd_byte *from, *fromend, *to;
  asymbol *store;

  store = bfd_make_empty_symbol (abfd);
  if (store == NULL)
    bfd_fatal (bfd_get_filename (abfd));

  from = (bfd_byte *) minisyms;
  fromend = from + symcount * size;
  to = (bfd_byte *) minisyms;

  for (; from < fromend; from += size)
    {
      int keep = 0;
      asymbol *sym;

      PROGRESS (1);

      sym = bfd_minisymbol_to_symbol (abfd, is_dynamic, (const void *) from, store);
      if (sym == NULL)
	bfd_fatal (bfd_get_filename (abfd));

      if (undefined_only)
	keep = bfd_is_und_section (sym->section);
      else if (external_only)
	/* PR binutls/12753: Unique symbols are global too.  */
	keep = ((sym->flags & (BSF_GLOBAL
			       | BSF_WEAK
			       | BSF_GNU_UNIQUE)) != 0
		|| bfd_is_und_section (sym->section)
		|| bfd_is_com_section (sym->section));
      else
	keep = 1;

      if (keep
	  && ! print_debug_syms
	  && (sym->flags & BSF_DEBUGGING) != 0)
	keep = 0;

      if (keep
	  && sort_by_size
	  && (bfd_is_abs_section (sym->section)
	      || bfd_is_und_section (sym->section)))
	keep = 0;

      if (keep
	  && defined_only)
	{
	  if (bfd_is_und_section (sym->section))
	    keep = 0;
	}

      if (keep
	  && bfd_is_target_special_symbol (abfd, sym)
	  && ! allow_special_symbols)
	keep = 0;

      if (keep)
	{
	  if (to != from)
	    memcpy (to, from, size);
	  to += size;
	}
    }

  return (to - (bfd_byte *) minisyms) / size;
}

/* These globals are used to pass information into the sorting
   routines.  */
static bfd *sort_bfd;
static bfd_boolean sort_dynamic;
static asymbol *sort_x;
static asymbol *sort_y;

/* Symbol-sorting predicates */
#define valueof(x) ((x)->section->vma + (x)->value)

/* Numeric sorts.  Undefined symbols are always considered "less than"
   defined symbols with zero values.  Common symbols are not treated
   specially -- i.e., their sizes are used as their "values".  */

static int
non_numeric_forward (const void *P_x, const void *P_y)
{
  asymbol *x, *y;
  const char *xn, *yn;

  x = bfd_minisymbol_to_symbol (sort_bfd, sort_dynamic, P_x, sort_x);
  y = bfd_minisymbol_to_symbol (sort_bfd, sort_dynamic, P_y, sort_y);
  if (x == NULL || y == NULL)
    bfd_fatal (bfd_get_filename (sort_bfd));

  xn = bfd_asymbol_name (x);
  yn = bfd_asymbol_name (y);

  if (yn == NULL)
    return xn != NULL;
  if (xn == NULL)
    return -1;

#ifdef HAVE_STRCOLL
  /* Solaris 2.5 has a bug in strcoll.
     strcoll returns invalid values when confronted with empty strings.  */
  if (*yn == '\0')
    return *xn != '\0';
  if (*xn == '\0')
    return -1;

  return strcoll (xn, yn);
#else
  return strcmp (xn, yn);
#endif
}

static int
non_numeric_reverse (const void *x, const void *y)
{
  return - non_numeric_forward (x, y);
}

static int
numeric_forward (const void *P_x, const void *P_y)
{
  asymbol *x, *y;
  asection *xs, *ys;

  x = bfd_minisymbol_to_symbol (sort_bfd, sort_dynamic, P_x, sort_x);
  y =  bfd_minisymbol_to_symbol (sort_bfd, sort_dynamic, P_y, sort_y);
  if (x == NULL || y == NULL)
    bfd_fatal (bfd_get_filename (sort_bfd));

  xs = bfd_get_section (x);
  ys = bfd_get_section (y);

  if (bfd_is_und_section (xs))
    {
      if (! bfd_is_und_section (ys))
	return -1;
    }
  else if (bfd_is_und_section (ys))
    return 1;
  else if (valueof (x) != valueof (y))
    return valueof (x) < valueof (y) ? -1 : 1;

  return non_numeric_forward (P_x, P_y);
}

static int
numeric_reverse (const void *x, const void *y)
{
  return - numeric_forward (x, y);
}

static int (*(sorters[2][2])) (const void *, const void *) =
{
  { non_numeric_forward, non_numeric_reverse },
  { numeric_forward, numeric_reverse }
};

/* This sort routine is used by sort_symbols_by_size.  It is similar
   to numeric_forward, but when symbols have the same value it sorts
   by section VMA.  This simplifies the sort_symbols_by_size code
   which handles symbols at the end of sections.  Also, this routine
   tries to sort file names before other symbols with the same value.
   That will make the file name have a zero size, which will make
   sort_symbols_by_size choose the non file name symbol, leading to
   more meaningful output.  For similar reasons, this code sorts
   gnu_compiled_* and gcc2_compiled before other symbols with the same
   value.  */

static int
size_forward1 (const void *P_x, const void *P_y)
{
  asymbol *x, *y;
  asection *xs, *ys;
  const char *xn, *yn;
  size_t xnl, ynl;
  int xf, yf;

  x = bfd_minisymbol_to_symbol (sort_bfd, sort_dynamic, P_x, sort_x);
  y = bfd_minisymbol_to_symbol (sort_bfd, sort_dynamic, P_y, sort_y);
  if (x == NULL || y == NULL)
    bfd_fatal (bfd_get_filename (sort_bfd));

  xs = bfd_get_section (x);
  ys = bfd_get_section (y);

  if (bfd_is_und_section (xs))
    abort ();
  if (bfd_is_und_section (ys))
    abort ();

  if (valueof (x) != valueof (y))
    return valueof (x) < valueof (y) ? -1 : 1;

  if (xs->vma != ys->vma)
    return xs->vma < ys->vma ? -1 : 1;

  xn = bfd_asymbol_name (x);
  yn = bfd_asymbol_name (y);
  xnl = strlen (xn);
  ynl = strlen (yn);

  /* The symbols gnu_compiled and gcc2_compiled convey even less
     information than the file name, so sort them out first.  */

  xf = (strstr (xn, "gnu_compiled") != NULL
	|| strstr (xn, "gcc2_compiled") != NULL);
  yf = (strstr (yn, "gnu_compiled") != NULL
	|| strstr (yn, "gcc2_compiled") != NULL);

  if (xf && ! yf)
    return -1;
  if (! xf && yf)
    return 1;

  /* We use a heuristic for the file name.  It may not work on non
     Unix systems, but it doesn't really matter; the only difference
     is precisely which symbol names get printed.  */

#define file_symbol(s, sn, snl)			\
  (((s)->flags & BSF_FILE) != 0			\
   || ((sn)[(snl) - 2] == '.'			\
       && ((sn)[(snl) - 1] == 'o'		\
	   || (sn)[(snl) - 1] == 'a')))

  xf = file_symbol (x, xn, xnl);
  yf = file_symbol (y, yn, ynl);

  if (xf && ! yf)
    return -1;
  if (! xf && yf)
    return 1;

  return non_numeric_forward (P_x, P_y);
}

/* This sort routine is used by sort_symbols_by_size.  It is sorting
   an array of size_sym structures into size order.  */

static int
size_forward2 (const void *P_x, const void *P_y)
{
  const struct size_sym *x = (const struct size_sym *) P_x;
  const struct size_sym *y = (const struct size_sym *) P_y;

  if (x->size < y->size)
    return reverse_sort ? 1 : -1;
  else if (x->size > y->size)
    return reverse_sort ? -1 : 1;
  else
    return sorters[0][reverse_sort] (x->minisym, y->minisym);
}

/* Sort the symbols by size.  ELF provides a size but for other formats
   we have to make a guess by assuming that the difference between the
   address of a symbol and the address of the next higher symbol is the
   size.  */

static long
sort_symbols_by_size (bfd *abfd, bfd_boolean is_dynamic, void *minisyms,
		      long symcount, unsigned int size,
		      struct size_sym **symsizesp)
{
  struct size_sym *symsizes;
  bfd_byte *from, *fromend;
  asymbol *sym = NULL;
  asymbol *store_sym, *store_next;

  qsort (minisyms, symcount, size, size_forward1);

  /* We are going to return a special set of symbols and sizes to
     print.  */
  symsizes = (struct size_sym *) xmalloc (symcount * sizeof (struct size_sym));
  *symsizesp = symsizes;

  /* Note that filter_symbols has already removed all absolute and
     undefined symbols.  Here we remove all symbols whose size winds
     up as zero.  */
  from = (bfd_byte *) minisyms;
  fromend = from + symcount * size;

  store_sym = sort_x;
  store_next = sort_y;

  if (from < fromend)
    {
      sym = bfd_minisymbol_to_symbol (abfd, is_dynamic, (const void *) from,
				      store_sym);
      if (sym == NULL)
	bfd_fatal (bfd_get_filename (abfd));
    }

  for (; from < fromend; from += size)
    {
      asymbol *next;
      asection *sec;
      bfd_vma sz;
      asymbol *temp;

      if (from + size < fromend)
	{
	  next = bfd_minisymbol_to_symbol (abfd,
					   is_dynamic,
					   (const void *) (from + size),
					   store_next);
	  if (next == NULL)
	    bfd_fatal (bfd_get_filename (abfd));
	}
      else
	next = NULL;

      sec = bfd_get_section (sym);

      if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
	sz = ((elf_symbol_type *) sym)->internal_elf_sym.st_size;
      else if (bfd_is_com_section (sec))
	sz = sym->value;
      else
	{
	  if (from + size < fromend
	      && sec == bfd_get_section (next))
	    sz = valueof (next) - valueof (sym);
	  else
	    sz = (bfd_get_section_vma (abfd, sec)
		  + bfd_section_size (abfd, sec)
		  - valueof (sym));
	}

      if (sz != 0)
	{
	  symsizes->minisym = (const void *) from;
	  symsizes->size = sz;
	  ++symsizes;
	}

      sym = next;

      temp = store_sym;
      store_sym = store_next;
      store_next = temp;
    }

  symcount = symsizes - *symsizesp;

  /* We must now sort again by size.  */
  qsort ((void *) *symsizesp, symcount, sizeof (struct size_sym), size_forward2);

  return symcount;
}

/* This function is used to get the relocs for a particular section.
   It is called via bfd_map_over_sections.  */

static void
get_relocs (bfd *abfd, asection *sec, void *dataarg)
{
  struct get_relocs_info *data = (struct get_relocs_info *) dataarg;

  *data->secs = sec;

  if ((sec->flags & SEC_RELOC) == 0)
    {
      *data->relocs = NULL;
      *data->relcount = 0;
    }
  else
    {
      long relsize;

      relsize = bfd_get_reloc_upper_bound (abfd, sec);
      if (relsize < 0)
	bfd_fatal (bfd_get_filename (abfd));

      *data->relocs = (arelent **) xmalloc (relsize);
      *data->relcount = bfd_canonicalize_reloc (abfd, sec, *data->relocs,
						data->syms);
      if (*data->relcount < 0)
	bfd_fatal (bfd_get_filename (abfd));
    }

  ++data->secs;
  ++data->relocs;
  ++data->relcount;
}

/* Print a single symbol.  */

static void
print_symbol (bfd *abfd, asymbol *sym, bfd_vma ssize, bfd *archive_bfd)
{
  symbol_info syminfo;
  struct extended_symbol_info info;

  PROGRESS (1);

  format->print_symbol_filename (archive_bfd, abfd);

  bfd_get_symbol_info (abfd, sym, &syminfo);
  info.sinfo = &syminfo;
  info.ssize = ssize;
  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
    info.elfinfo = (elf_symbol_type *) sym;
  else
    info.elfinfo = NULL;
  format->print_symbol_info (&info, abfd);

  if (line_numbers)
    {
      static asymbol **syms;
      static long symcount;
      const char *filename, *functionname;
      unsigned int lineno;

      /* We need to get the canonical symbols in order to call
         bfd_find_nearest_line.  This is inefficient, but, then, you
         don't have to use --line-numbers.  */
      if (abfd != lineno_cache_bfd && syms != NULL)
	{
	  free (syms);
	  syms = NULL;
	}
      if (syms == NULL)
	{
	  long symsize;

	  symsize = bfd_get_symtab_upper_bound (abfd);
	  if (symsize < 0)
	    bfd_fatal (bfd_get_filename (abfd));
	  syms = (asymbol **) xmalloc (symsize);
	  symcount = bfd_canonicalize_symtab (abfd, syms);
	  if (symcount < 0)
	    bfd_fatal (bfd_get_filename (abfd));
	  lineno_cache_bfd = abfd;
	}

      if (bfd_is_und_section (bfd_get_section (sym)))
	{
	  static asection **secs;
	  static arelent ***relocs;
	  static long *relcount;
	  static unsigned int seccount;
	  unsigned int i;
	  const char *symname;

	  /* For an undefined symbol, we try to find a reloc for the
             symbol, and print the line number of the reloc.  */
	  if (abfd != lineno_cache_rel_bfd && relocs != NULL)
	    {
	      for (i = 0; i < seccount; i++)
		if (relocs[i] != NULL)
		  free (relocs[i]);
	      free (secs);
	      free (relocs);
	      free (relcount);
	      secs = NULL;
	      relocs = NULL;
	      relcount = NULL;
	    }

	  if (relocs == NULL)
	    {
	      struct get_relocs_info rinfo;

	      seccount = bfd_count_sections (abfd);

	      secs = (asection **) xmalloc (seccount * sizeof *secs);
	      relocs = (arelent ***) xmalloc (seccount * sizeof *relocs);
	      relcount = (long *) xmalloc (seccount * sizeof *relcount);

	      rinfo.secs = secs;
	      rinfo.relocs = relocs;
	      rinfo.relcount = relcount;
	      rinfo.syms = syms;
	      bfd_map_over_sections (abfd, get_relocs, (void *) &rinfo);
	      lineno_cache_rel_bfd = abfd;
	    }

	  symname = bfd_asymbol_name (sym);
	  for (i = 0; i < seccount; i++)
	    {
	      long j;

	      for (j = 0; j < relcount[i]; j++)
		{
		  arelent *r;

		  r = relocs[i][j];
		  if (r->sym_ptr_ptr != NULL
		      && (*r->sym_ptr_ptr)->section == sym->section
		      && (*r->sym_ptr_ptr)->value == sym->value
		      && strcmp (symname,
				 bfd_asymbol_name (*r->sym_ptr_ptr)) == 0
		      && bfd_find_nearest_line (abfd, secs[i], syms,
						r->address, &filename,
						&functionname, &lineno)
		      && filename != NULL)
		    {
		      /* We only print the first one we find.  */
		      printf ("\t%s:%u", filename, lineno);
		      i = seccount;
		      break;
		    }
		}
	    }
	}
      else if (bfd_get_section (sym)->owner == abfd)
	{
	  if ((bfd_find_line (abfd, syms, sym, &filename, &lineno)
	       || bfd_find_nearest_line (abfd, bfd_get_section (sym),
					 syms, sym->value, &filename,
					 &functionname, &lineno))
	      && filename != NULL
	      && lineno != 0)
	    printf ("\t%s:%u", filename, lineno);
	}
    }

  putchar ('\n');
}

/* Print the symbols when sorting by size.  */

static void
print_size_symbols (bfd *abfd, bfd_boolean is_dynamic,
		    struct size_sym *symsizes, long symcount,
		    bfd *archive_bfd)
{
  asymbol *store;
  struct size_sym *from, *fromend;

  store = bfd_make_empty_symbol (abfd);
  if (store == NULL)
    bfd_fatal (bfd_get_filename (abfd));

  from = symsizes;
  fromend = from + symcount;
  for (; from < fromend; from++)
    {
      asymbol *sym;

      sym = bfd_minisymbol_to_symbol (abfd, is_dynamic, from->minisym, store);
      if (sym == NULL)
	bfd_fatal (bfd_get_filename (abfd));

      print_symbol (abfd, sym, from->size, archive_bfd);
    }
}


/* Print the symbols.  If ARCHIVE_BFD is non-NULL, it is the archive
   containing ABFD.  */

static void
print_symbols (bfd *abfd, bfd_boolean is_dynamic, void *minisyms, long symcount,
	       unsigned int size, bfd *archive_bfd)
{
  asymbol *store;
  bfd_byte *from, *fromend;

  store = bfd_make_empty_symbol (abfd);
  if (store == NULL)
    bfd_fatal (bfd_get_filename (abfd));

  from = (bfd_byte *) minisyms;
  fromend = from + symcount * size;
  for (; from < fromend; from += size)
    {
      asymbol *sym;

      sym = bfd_minisymbol_to_symbol (abfd, is_dynamic, from, store);
      if (sym == NULL)
	bfd_fatal (bfd_get_filename (abfd));

      print_symbol (abfd, sym, (bfd_vma) 0, archive_bfd);
    }
}

/* If ARCHIVE_BFD is non-NULL, it is the archive containing ABFD.  */

static void
display_rel_file (bfd *abfd, bfd *archive_bfd)
{
  long symcount;
  void *minisyms;
  unsigned int size;
  struct size_sym *symsizes;

  if (! dynamic)
    {
      if (!(bfd_get_file_flags (abfd) & HAS_SYMS))
	{
	  non_fatal (_("%s: no symbols"), bfd_get_filename (abfd));
	  return;
	}
    }

  symcount = bfd_read_minisymbols (abfd, dynamic, &minisyms, &size);
  if (symcount < 0)
    bfd_fatal (bfd_get_filename (abfd));

  if (symcount == 0)
    {
      non_fatal (_("%s: no symbols"), bfd_get_filename (abfd));
      return;
    }

  if (show_synthetic && size == sizeof (asymbol *))
    {
      asymbol *synthsyms;
      long synth_count;
      asymbol **static_syms = NULL;
      asymbol **dyn_syms = NULL;
      long static_count = 0;
      long dyn_count = 0;

      if (dynamic)
	{
	  dyn_count = symcount;
	  dyn_syms = (asymbol **) minisyms;
	}
      else
	{
	  long storage = bfd_get_dynamic_symtab_upper_bound (abfd);

	  static_count = symcount;
	  static_syms = (asymbol **) minisyms;

	  if (storage > 0)
	    {
	      dyn_syms = (asymbol **) xmalloc (storage);
	      dyn_count = bfd_canonicalize_dynamic_symtab (abfd, dyn_syms);
	      if (dyn_count < 0)
		bfd_fatal (bfd_get_filename (abfd));
	    }
	}
      synth_count = bfd_get_synthetic_symtab (abfd, static_count, static_syms,
					      dyn_count, dyn_syms, &synthsyms);
      if (synth_count > 0)
	{
	  asymbol **symp;
	  void *new_mini;
	  long i;

	  new_mini = xmalloc ((symcount + synth_count + 1) * sizeof (*symp));
	  symp = (asymbol **) new_mini;
	  memcpy (symp, minisyms, symcount * sizeof (*symp));
	  symp += symcount;
	  for (i = 0; i < synth_count; i++)
	    *symp++ = synthsyms + i;
	  *symp = 0;
	  minisyms = new_mini;
	  symcount += synth_count;
	}
    }

  /* Discard the symbols we don't want to print.
     It's OK to do this in place; we'll free the storage anyway
     (after printing).  */

  symcount = filter_symbols (abfd, dynamic, minisyms, symcount, size);

  symsizes = NULL;
  if (! no_sort)
    {
      sort_bfd = abfd;
      sort_dynamic = dynamic;
      sort_x = bfd_make_empty_symbol (abfd);
      sort_y = bfd_make_empty_symbol (abfd);
      if (sort_x == NULL || sort_y == NULL)
	bfd_fatal (bfd_get_filename (abfd));

      if (! sort_by_size)
	qsort (minisyms, symcount, size,
	       sorters[sort_numerically][reverse_sort]);
      else
	symcount = sort_symbols_by_size (abfd, dynamic, minisyms, symcount,
					 size, &symsizes);
    }

  if (! sort_by_size)
    print_symbols (abfd, dynamic, minisyms, symcount, size, archive_bfd);
  else
    print_size_symbols (abfd, dynamic, symsizes, symcount, archive_bfd);

  free (minisyms);
  free (symsizes);
}

static void
set_print_width (bfd *file)
{
  print_width = bfd_get_arch_size (file);

  if (print_width == -1)
    {
      /* PR binutils/4292
	 Guess the target's bitsize based on its name.
	 We assume here than any 64-bit format will include
	 "64" somewhere in its name.  The only known exception
	 is the MMO object file format.  */
      if (strstr (bfd_get_target (file), "64") != NULL
	  || strcmp (bfd_get_target (file), "mmo") == 0)
	print_width = 64;
      else
	print_width = 32;
    }
}

static void
display_archive (bfd *file)
{
  bfd *arfile = NULL;
  bfd *last_arfile = NULL;
  char **matching;

  format->print_archive_filename (bfd_get_filename (file));

  if (print_armap)
    print_symdef_entry (file);

  for (;;)
    {
      PROGRESS (1);

      arfile = bfd_openr_next_archived_file (file, arfile);

      if (arfile == NULL)
	{
	  if (bfd_get_error () != bfd_error_no_more_archived_files)
	    bfd_fatal (bfd_get_filename (file));
	  break;
	}

      if (bfd_check_format_matches (arfile, bfd_object, &matching))
	{
	  set_print_width (arfile);
	  format->print_archive_member (bfd_get_filename (file),
					bfd_get_filename (arfile));
	  display_rel_file (arfile, file);
	}
      else
	{
	  bfd_nonfatal (bfd_get_filename (arfile));
	  if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
	    {
	      list_matching_formats (matching);
	      free (matching);
	    }
	}

      if (last_arfile != NULL)
	{
	  bfd_close (last_arfile);
	  lineno_cache_bfd = NULL;
	  lineno_cache_rel_bfd = NULL;
	}
      last_arfile = arfile;
    }

  if (last_arfile != NULL)
    {
      bfd_close (last_arfile);
      lineno_cache_bfd = NULL;
      lineno_cache_rel_bfd = NULL;
    }
}

static bfd_boolean
display_file (char *filename)
{
  bfd_boolean retval = TRUE;
  bfd *file;
  char **matching;

  if (get_file_size (filename) < 1)
    return FALSE;

  file = bfd_openr (filename, target ? target : plugin_target);
  if (file == NULL)
    {
      bfd_nonfatal (filename);
      return FALSE;
    }

  /* If printing line numbers, decompress the debug sections.  */
  if (line_numbers)
    file->flags |= BFD_DECOMPRESS;

  if (bfd_check_format (file, bfd_archive))
    {
      display_archive (file);
    }
  else if (bfd_check_format_matches (file, bfd_object, &matching))
    {
      set_print_width (file);
      format->print_object_filename (filename);
      display_rel_file (file, NULL);
    }
  else
    {
      bfd_nonfatal (filename);
      if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
	{
	  list_matching_formats (matching);
	  free (matching);
	}
      retval = FALSE;
    }

  if (!bfd_close (file))
    bfd_fatal (filename);

  lineno_cache_bfd = NULL;
  lineno_cache_rel_bfd = NULL;

  return retval;
}

/* The following 3 groups of functions are called unconditionally,
   once at the start of processing each file of the appropriate type.
   They should check `filename_per_file' and `filename_per_symbol',
   as appropriate for their output format, to determine whether to
   print anything.  */

/* Print the name of an object file given on the command line.  */

static void
print_object_filename_bsd (char *filename)
{
  if (filename_per_file && !filename_per_symbol)
    printf ("\n%s:\n", filename);
}

static void
print_object_filename_sysv (char *filename)
{
  if (undefined_only)
    printf (_("\n\nUndefined symbols from %s:\n\n"), filename);
  else
    printf (_("\n\nSymbols from %s:\n\n"), filename);
  if (print_width == 32)
    printf (_("\
Name                  Value   Class        Type         Size     Line  Section\n\n"));
  else
    printf (_("\
Name                  Value           Class        Type         Size             Line  Section\n\n"));
}

static void
print_object_filename_posix (char *filename)
{
  if (filename_per_file && !filename_per_symbol)
    printf ("%s:\n", filename);
}

/* Print the name of an archive file given on the command line.  */

static void
print_archive_filename_bsd (char *filename)
{
  if (filename_per_file)
    printf ("\n%s:\n", filename);
}

static void
print_archive_filename_sysv (char *filename ATTRIBUTE_UNUSED)
{
}

static void
print_archive_filename_posix (char *filename ATTRIBUTE_UNUSED)
{
}

/* Print the name of an archive member file.  */

static void
print_archive_member_bsd (char *archive ATTRIBUTE_UNUSED,
			  const char *filename)
{
  if (!filename_per_symbol)
    printf ("\n%s:\n", filename);
}

static void
print_archive_member_sysv (char *archive, const char *filename)
{
  if (undefined_only)
    printf (_("\n\nUndefined symbols from %s[%s]:\n\n"), archive, filename);
  else
    printf (_("\n\nSymbols from %s[%s]:\n\n"), archive, filename);
  if (print_width == 32)
    printf (_("\
Name                  Value   Class        Type         Size     Line  Section\n\n"));
  else
    printf (_("\
Name                  Value           Class        Type         Size             Line  Section\n\n"));
}

static void
print_archive_member_posix (char *archive, const char *filename)
{
  if (!filename_per_symbol)
    printf ("%s[%s]:\n", archive, filename);
}

/* Print the name of the file (and archive, if there is one)
   containing a symbol.  */

static void
print_symbol_filename_bsd (bfd *archive_bfd, bfd *abfd)
{
  if (filename_per_symbol)
    {
      if (archive_bfd)
	printf ("%s:", bfd_get_filename (archive_bfd));
      printf ("%s:", bfd_get_filename (abfd));
    }
}

static void
print_symbol_filename_sysv (bfd *archive_bfd, bfd *abfd)
{
  if (filename_per_symbol)
    {
      if (archive_bfd)
	printf ("%s:", bfd_get_filename (archive_bfd));
      printf ("%s:", bfd_get_filename (abfd));
    }
}

static void
print_symbol_filename_posix (bfd *archive_bfd, bfd *abfd)
{
  if (filename_per_symbol)
    {
      if (archive_bfd)
	printf ("%s[%s]: ", bfd_get_filename (archive_bfd),
		bfd_get_filename (abfd));
      else
	printf ("%s: ", bfd_get_filename (abfd));
    }
}

/* Print a symbol value.  */

static void
print_value (bfd *abfd ATTRIBUTE_UNUSED, bfd_vma val)
{
  switch (print_width)
    {
    case 32:
      printf (value_format_32bit, (unsigned long) val);
      break;

    case 64:
#if BFD_HOST_64BIT_LONG || BFD_HOST_64BIT_LONG_LONG
      printf (value_format_64bit, val);
#else
      /* We have a 64 bit value to print, but the host is only 32 bit.  */
      if (print_radix == 16)
	bfd_fprintf_vma (abfd, stdout, val);
      else
	{
	  char buf[30];
	  char *s;

	  s = buf + sizeof buf;
	  *--s = '\0';
	  while (val > 0)
	    {
	      *--s = (val % print_radix) + '0';
	      val /= print_radix;
	    }
	  while ((buf + sizeof buf - 1) - s < 16)
	    *--s = '0';
	  printf ("%s", s);
	}
#endif
      break;

    default:
      fatal (_("Print width has not been initialized (%d)"), print_width);
      break;
    }
}

/* Print a line of information about a symbol.  */

static void
print_symbol_info_bsd (struct extended_symbol_info *info, bfd *abfd)
{
  if (bfd_is_undefined_symclass (SYM_TYPE (info)))
    {
      if (print_width == 64)
	printf ("        ");
      printf ("        ");
    }
  else
    {
      /* Normally we print the value of the symbol.  If we are printing the
	 size or sorting by size then we print its size, except for the
	 (weird) special case where both flags are defined, in which case we
	 print both values.  This conforms to documented behaviour.  */
      if (sort_by_size && !print_size)
	print_value (abfd, SYM_SIZE (info));
      else
	print_value (abfd, SYM_VALUE (info));

      if (print_size && SYM_SIZE (info))
	{
	  printf (" ");
	  print_value (abfd, SYM_SIZE (info));
	}
    }

  printf (" %c", SYM_TYPE (info));

  if (SYM_TYPE (info) == '-')
    {
      /* A stab.  */
      printf (" ");
      printf (other_format, SYM_STAB_OTHER (info));
      printf (" ");
      printf (desc_format, SYM_STAB_DESC (info));
      printf (" %5s", SYM_STAB_NAME (info));
    }
  print_symname (" %s", SYM_NAME (info), abfd);
}

static void
print_symbol_info_sysv (struct extended_symbol_info *info, bfd *abfd)
{
  print_symname ("%-20s|", SYM_NAME (info), abfd);

  if (bfd_is_undefined_symclass (SYM_TYPE (info)))
    {
      if (print_width == 32)
	printf ("        ");
      else
	printf ("                ");
    }
  else
    print_value (abfd, SYM_VALUE (info));

  printf ("|   %c  |", SYM_TYPE (info));

  if (SYM_TYPE (info) == '-')
    {
      /* A stab.  */
      printf ("%18s|  ", SYM_STAB_NAME (info));		/* (C) Type.  */
      printf (desc_format, SYM_STAB_DESC (info));	/* Size.  */
      printf ("|     |");				/* Line, Section.  */
    }
  else
    {
      /* Type, Size, Line, Section */
      if (info->elfinfo)
	printf ("%18s|",
		get_symbol_type (ELF_ST_TYPE (info->elfinfo->internal_elf_sym.st_info)));
      else
	printf ("                  |");

      if (SYM_SIZE (info))
	print_value (abfd, SYM_SIZE (info));
      else
	{
	  if (print_width == 32)
	    printf ("        ");
	  else
	    printf ("                ");
	}

      if (info->elfinfo)
	printf("|     |%s", info->elfinfo->symbol.section->name);
      else
	printf("|     |");
    }
}

static void
print_symbol_info_posix (struct extended_symbol_info *info, bfd *abfd)
{
  print_symname ("%s ", SYM_NAME (info), abfd);
  printf ("%c ", SYM_TYPE (info));

  if (bfd_is_undefined_symclass (SYM_TYPE (info)))
    printf ("        ");
  else
    {
      print_value (abfd, SYM_VALUE (info));
      printf (" ");
      if (SYM_SIZE (info))
	print_value (abfd, SYM_SIZE (info));
    }
}

int
main (int argc, char **argv)
{
  int c;
  int retval;

#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
  setlocale (LC_COLLATE, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

  program_name = *argv;
  xmalloc_set_program_name (program_name);
#if BFD_SUPPORTS_PLUGINS
  bfd_plugin_set_program_name (program_name);
#endif

  START_PROGRESS (program_name, 0);

  expandargv (&argc, &argv);

  bfd_init ();
  set_default_bfd_target ();

  while ((c = getopt_long (argc, argv, "aABCDef:gHhlnopPrSst:uvVvX:",
			   long_options, (int *) 0)) != EOF)
    {
      switch (c)
	{
	case 'a':
	  print_debug_syms = 1;
	  break;
	case 'A':
	case 'o':
	  filename_per_symbol = 1;
	  break;
	case 'B':		/* For MIPS compatibility.  */
	  set_output_format ("bsd");
	  break;
	case 'C':
	  do_demangle = 1;
	  if (optarg != NULL)
	    {
	      enum demangling_styles style;

	      style = cplus_demangle_name_to_style (optarg);
	      if (style == unknown_demangling)
		fatal (_("unknown demangling style `%s'"),
		       optarg);

	      cplus_demangle_set_style (style);
	    }
	  break;
	case 'D':
	  dynamic = 1;
	  break;
	case 'e':
	  /* Ignored for HP/UX compatibility.  */
	  break;
	case 'f':
	  set_output_format (optarg);
	  break;
	case 'g':
	  external_only = 1;
	  break;
	case 'H':
	case 'h':
	  usage (stdout, 0);
	case 'l':
	  line_numbers = 1;
	  break;
	case 'n':
	case 'v':
	  no_sort = 0;
	  sort_numerically = 1;
	  sort_by_size = 0;
	  break;
	case 'p':
	  no_sort = 1;
	  sort_numerically = 0;
	  sort_by_size = 0;
	  break;
	case OPTION_SIZE_SORT:
	  no_sort = 0;
	  sort_numerically = 0;
	  sort_by_size = 1;
	  break;
	case 'P':
	  set_output_format ("posix");
	  break;
	case 'r':
	  reverse_sort = 1;
	  break;
	case 's':
	  print_armap = 1;
	  break;
	case 'S':
	  print_size = 1;
	  break;
	case 't':
	  set_print_radix (optarg);
	  break;
	case 'u':
	  undefined_only = 1;
	  break;
	case 'V':
	  show_version = 1;
	  break;
	case 'X':
	  /* Ignored for (partial) AIX compatibility.  On AIX, the
	     argument has values 32, 64, or 32_64, and specifies that
	     only 32-bit, only 64-bit, or both kinds of objects should
	     be examined.  The default is 32.  So plain AIX nm on a
	     library archive with both kinds of objects will ignore
	     the 64-bit ones.  For GNU nm, the default is and always
	     has been -X 32_64, and other options are not supported.  */
	  if (strcmp (optarg, "32_64") != 0)
	    fatal (_("Only -X 32_64 is supported"));
	  break;

	case OPTION_TARGET:	/* --target */
	  target = optarg;
	  break;

	case OPTION_PLUGIN:	/* --plugin */
#if BFD_SUPPORTS_PLUGINS
	  plugin_target = "plugin";
	  bfd_plugin_set_plugin (optarg);
#else
	  fatal (_("sorry - this program has been built without plugin support\n"));
#endif
	  break;

	case 0:		/* A long option that just sets a flag.  */
	  break;

	default:
	  usage (stderr, 1);
	}
    }

  if (show_version)
    print_version ("nm");

  if (sort_by_size && undefined_only)
    {
      non_fatal (_("Using the --size-sort and --undefined-only options together"));
      non_fatal (_("will produce no output, since undefined symbols have no size."));
      return 0;
    }

  /* OK, all options now parsed.  If no filename specified, do a.out.  */
  if (optind == argc)
    return !display_file ("a.out");

  retval = 0;

  if (argc - optind > 1)
    filename_per_file = 1;

  /* We were given several filenames to do.  */
  while (optind < argc)
    {
      PROGRESS (1);
      if (!display_file (argv[optind++]))
	retval++;
    }

  END_PROGRESS (program_name);

#ifdef HAVE_SBRK
  if (show_stats)
    {
      char *lim = (char *) sbrk (0);

      non_fatal (_("data size %ld"), (long) (lim - (char *) &environ));
    }
#endif

  exit (retval);
  return retval;
}
@


1.70
log
@Simplify global symbol handling

	* nm.c (filter_symbols): Simplify global symbol handling.
@
text
@a953 1
      bfd_vma ssize;
d959 1
a959 7
      /* For elf we have already computed the correct symbol size.  */
      if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
	ssize = from->size;
      else
	ssize = from->size - bfd_section_vma (abfd, bfd_get_section (sym));

      print_symbol (abfd, sym, ssize, archive_bfd);
@


1.69
log
@	PR binutils/13593
	* nm.c (OPTION_SIZE_SORT): Define.
	(long_options): Don't set no_sort, sort_numerically or
	sort_by_size directly.
	(main): Instead set the flags here, making them mutually exclusive.
@
text
@d438 4
a441 4
	keep = ((sym->flags & BSF_GLOBAL) != 0
		|| (sym->flags & BSF_WEAK) != 0
		/* PR binutls/12753: Unique symbols are global too.  */
		|| (sym->flags & BSF_GNU_UNIQUE) != 0
@


1.68
log
@	PR 12983
	* binutils/nm.c (display_file): Decompress debug sections when
	printing line numbers.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009, 2010
d187 2
a188 1
#define OPTION_PLUGIN 201
d201 2
a202 2
  {"no-sort", no_argument, &no_sort, 1},
  {"numeric-sort", no_argument, &sort_numerically, 1},
d210 1
a210 1
  {"size-sort", no_argument, &sort_by_size, 1},
d1597 1
d1599 1
d1603 7
@


1.67
log
@	PR binutils/12753
	* nm.c (filter_symbols): Treat unique symbols as global symbols.
	* doc/binutils.texi (nm): Mention that some lowercase letters
	actually indicate global symbols.

	* lib/utils-lib.exp (run_dump_test): Allow nm as a program.
	* binutils-all/nm.exp: Test running "nm -g" on an object file
	containing a unique symbol.
@
text
@d1205 4
@


1.66
log
@2011-03-07  Michael Snyder  <msnyder@@vmware.com>

	* nm.c (display_rel_file): Free symsizes.
@
text
@d439 2
@


1.65
log
@	* nm.c (value_format_64bit): Define appropriately for __MSVCRT__.
	(set_print_radix): Update for __MSVCRT__ definition of
	value_format_64bit.
@
text
@d1104 1
@


1.65.2.1
log
@	PR 12365
	PR 12613
	PR 12632
	PR 12739
	PR 12753
	PR 12760
	PR 12763
Apply fix from mainline along with assorted other small fixes.
@
text
@a438 2
		/* PR binutls/12753: Unique symbols are global too.  */
		|| (sym->flags & BSF_GNU_UNIQUE) != 0
@


1.64
log
@Set BFD target to "plugin" for "nm --plugin".

2010-10-03  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/12088
	* nm.c (plugin_target): New.
	(main): Set plugin_target to "plugin" for --plugin.
	(display_file): Pass plugin_target to bfd_openr if target
	isn't set.
@
text
@d167 1
d169 3
d292 1
d294 3
@


1.63
log
@2010-01-06  Tristan Gingold  <gingold@@adacore.com>

	* nm.c (usage): Remove extra blanks.
	Update copyright.
@
text
@d176 1
d1187 1
a1187 1
  file = bfd_openr (filename, target);
d1625 1
@


1.62
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2007, 2008, 2009
d249 1
a249 1
  -S, --print-size       Print size of defined symbols\n		\
@


1.61
log
@        Updated soruces in binutils/* to compile cleanly with -Wc++-compat.

        * binutils/addr2line.c (slurp_symtab): Fix casts. Introduce
        variable minisyms to avoid aliasing varning.
        * binutils/ar.c: Add casts. (normalize): Use name del instead of
        delete. (display_target_list,display_info_table): Change loop
        counter variable a to int.
        * binutils/bucomm.c: Add casts.
        * binutils/debug.c: Update function to use new names. (struct
        debug_baseclass): Rename member from virtual to
        is_virtual. (struct debug_type_s,struct debug_field_s,struct
        debug_baseclass_s,struct debug_method_s,struct
        debug_method_variant_s,struct debug_type_s): Rename struct from
        avoid name collision.
        * /binutils/debug.h: Use new struct names.
        * binutils/dwarf.c: Add casts. (free_debug_memory): Change loop
        counter variable a to int.
        * binutils/ieee.c: Add casts. (enum ieee_var_kind): Move to top
        level. (ieee_class_baseclass): Rename parameter virtual to
        is_virtual. (ieee_class_method_var): Rename variable virtual to
        is_virtual.
        * binutils/nm.c: Add casts.
        * binutils/objcopy.c: Add casts. (copy_archive): Rename variable
        delete to del.
        * binutils/objdump.c: Add casts. (dump_dwarf_section): Change loop
        counter variable i to int.
        * binutils/prdbg.c: Add
        casts. (pr_class_baseclass,tg_class_baseclass): Rename parameters
        virtual to is_virtual.
        * binutils/readelf.c: Add casts. (struct
        ia64_unw_table_entry,struct hppa_unw_table_entry): Move to top
        level.
        * binutils/size.c: Add casts.
        * binutils/stabs.c (parse_stab_type, parse_stab_range_type)
        (parse_stab_cpp_abbrev): Rename parameter from typename to
        type_name. (parse_stab_baseclasses): Rename variable virtual to
        is_virtual.
        * binutils/strings.c: Add casts.
        * binutils/wrstabs.c (stab_class_baseclass): Rename parameter
        virtual to is_virtual.
@
text
@d346 1
a346 1
/* Print symbol name NAME, read from ABFD, with printf format FORMAT,
d350 1
a350 1
print_symname (const char *format, const char *name, bfd *abfd)
d358 1
a358 1
	  printf (format, res);
d364 1
a364 1
  printf (format, name);
d400 1
a400 1
filter_symbols (bfd *abfd, bfd_boolean dynamic, void *minisyms,
d421 1
a421 1
      sym = bfd_minisymbol_to_symbol (abfd, dynamic, (const void *) from, store);
d662 1
a662 1
sort_symbols_by_size (bfd *abfd, bfd_boolean dynamic, void *minisyms,
d689 1
a689 1
      sym = bfd_minisymbol_to_symbol (abfd, dynamic, (const void *) from,
d705 1
a705 1
					   dynamic,
d864 1
a864 1
	      struct get_relocs_info info;
d872 5
a876 5
	      info.secs = secs;
	      info.relocs = relocs;
	      info.relcount = relcount;
	      info.syms = syms;
	      bfd_map_over_sections (abfd, get_relocs, (void *) &info);
d926 1
a926 1
print_size_symbols (bfd *abfd, bfd_boolean dynamic,
d944 1
a944 1
      sym = bfd_minisymbol_to_symbol (abfd, dynamic, from->minisym, store);
d963 1
a963 1
print_symbols (bfd *abfd, bfd_boolean dynamic, void *minisyms, long symcount,
d979 1
a979 1
      sym = bfd_minisymbol_to_symbol (abfd, dynamic, from, store);
@


1.60
log
@update copyright dates
@
text
@d675 1
a675 1
  symsizes = xmalloc (symcount * sizeof (struct size_sym));
d776 1
a776 1
      *data->relocs = xmalloc (relsize);
d831 1
a831 1
	  syms = xmalloc (symsize);
d868 3
a870 3
	      secs = xmalloc (seccount * sizeof *secs);
	      relocs = xmalloc (seccount * sizeof *relocs);
	      relcount = xmalloc (seccount * sizeof *relcount);
d1028 1
a1028 1
	  dyn_syms = minisyms;
d1035 1
a1035 1
	  static_syms = minisyms;
d1039 1
a1039 1
	      dyn_syms = xmalloc (storage);
d1054 1
a1054 1
	  symp = new_mini;
@


1.60.2.1
log
@        Update soruces to compile cleanly with -Wc++-compat:

        * addr2line.c (slurp_symtab): Fix casts. Introduce variable
        minisyms to avoid aliasing varning.
        * ar.c: Add casts.
        (normalize): Use name del instead of delete.
        (display_target_list,display_info_table): Change loop counter
        variable a to int.
        * bucomm.c: Add casts.
        * debug.c: Update function to use new names.
        (struct debug_baseclass): Rename member from virtual to
        is_virtual.
        (struct debug_type_s, struct debug_field_s, struct
        debug_baseclass_s, struct debug_method_s, struct
        debug_method_variant_s, struct debug_type_s): Rename struct from
        avoid name collision.
        * debug.h: Use new struct names.
        * dwarf.c: Add casts.
        (free_debug_memory): Change loop counter variable a to int.
        * ieee.c: Add casts.
        (enum ieee_var_kind): Move to top level.
        (ieee_class_baseclass): Rename parameter virtual to is_virtual.
        (ieee_class_method_var): Rename variable virtual to is_virtual.
        * nm.c: Add casts.
        * objcopy.c: Add casts.
        (copy_archive): Rename variable delete to del.
        * objdump.c: Add casts.
        (dump_dwarf_section): Change loop counter variable i to int.
        * prdbg.c: Add casts.
        (pr_class_baseclass,tg_class_baseclass): Rename parameters virtual
        to is_virtual.
        * readelf.c: Add casts.
        (struct ia64_unw_table_entry,struct hppa_unw_table_entry): Move to
        top level.
        * size.c: Add casts.
        * stabs.c (parse_stab_type, parse_stab_range_type,
        (parse_stab_cpp_abbrev): Rename parameter from typename to
        type_name.
        (parse_stab_baseclasses): Rename variable virtual to is_virtual.
        * strings.c: Add casts.
        * wrstabs.c (stab_class_baseclass): Rename parameter virtual to
        is_virtual.
@
text
@d675 1
a675 1
  symsizes = (struct size_sym *) xmalloc (symcount * sizeof (struct size_sym));
d776 1
a776 1
      *data->relocs = (arelent **) xmalloc (relsize);
d831 1
a831 1
	  syms = (asymbol **) xmalloc (symsize);
d868 3
a870 3
	      secs = (asection **) xmalloc (seccount * sizeof *secs);
	      relocs = (arelent ***) xmalloc (seccount * sizeof *relocs);
	      relcount = (long *) xmalloc (seccount * sizeof *relcount);
d1028 1
a1028 1
	  dyn_syms = (asymbol **) minisyms;
d1035 1
a1035 1
	  static_syms = (asymbol **) minisyms;
d1039 1
a1039 1
	      dyn_syms = (asymbol **) xmalloc (storage);
d1054 1
a1054 1
	  symp = (asymbol **) new_mini;
@


1.59
log
@        * ar.c (usage): Do not use #ifdef inside _("...).
        * nm.c (usage): Likewise.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2007, 2009
@


1.58
log
@2009-05-28  Nick Clifton  <nickc@@redhat.com>

        * targets.c (_bfd_target_vector): Only include plugin target in
        all-targets build if BFD_SUPPORTS_PLUGINS is non-zero.

2009-05-27  Rafael Avila de Espindola  <espindola@@google.com>

        * plugin.c (program_name): Remove.
        (plugin_program_name): New.
        (bfd_plugin_set_program_name): New.
        (try_load_plugin): Use plugin_program_name.
        * plugin.h (bfd_plugin_set_program_name): New.

2009-05-27  Rafael Avila de Espindola  <espindola@@google.com>

        * ar.c (main): Call bfd_plugin_set_program_name.
        * nm.c (main): Call bfd_plugin_set_program_name.
@
text
@d243 1
a243 1
  -r, --reverse-sort     Reverse the sense of the sort\n"
d245 2
a246 1
"      --plugin NAME      Load the specified plugin\n"
d248 2
a249 1
"  -S, --print-size       Print size of defined symbols\n\
@


1.57
log
@        * Makefile.am: Run "make dep-am".
        (AM_CPPFLAGS): New.
        (LIBDL): New.
        (ALL_MACHINES): Add cpu-plugin.lo.
        (ALL_MACHINES_CFILES): Add cpu-plugin.c.
        (BFD32_BACKENDS): Add plugin.lo.
        (BFD32_BACKENDS_CFILES): Add plugin.c.
        (libbfd_la_LIBADD): Add LIBDL
        * archures.c (bfd_architecture): Add bfd_arch_plugin.
        (bfd_plugin_arch): Declare.
        * bfd-in.h (BFD_SUPPORTS_PLUGINS): New.
        * bfd.c (bfd): Add plugin_data.
        * config.bfd: Handle the plugin target.
        * configure.in: Check for --enable-plugins.
        (LT_INIT): Use the dlopen option.
        * cpu-plugin.c: New.
        * plugin.c: New.
        * plugin.h: New.
        * targets.c (plugin_vec): Declare.
        (_bfd_target_vector): Add plugin_vec.
        * Makefile.in: Regenerate.
        * bfd-in2.h: Regenerate.
        * configure: Regenerate.
        * ar.c: Include plugin.h.
        (main): Handle the --plugin option.
        * nm.c: Include plugin.h.
        (OPTION_PLUGIN): New.
        (long_options): Add plugin.
        (main): Handle OPTION_PLUGIN.
        * NEWS: Mention  the new feature.
        * doc/binutils: Documement the new command line options.
        * configure.in: Check for --enable-plugins.
        * configure: Regenerate.
@
text
@d1518 3
@


1.56
log
@	* nm.c (filter_symbols): Only call memcpy when from != to.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005, 2007
d34 1
d182 1
d197 1
d243 5
a247 2
  -r, --reverse-sort     Reverse the sense of the sort\n\
  -S, --print-size       Print size of defined symbols\n\
d1617 8
@


1.55
log
@	* nm.c (value_format_64bit, set_print_radix, print_value): Handle
	BFD_HOST_64BIT_LONG_LONG.
	* readelf.c (print_dec_vma): Don't define if BFD_HOST_64BIT_LONG_LONG.
	(print_vma): Handle BFD_HOST_64BIT_LONG_LONG.
	(dump_relocations): Likewise.  Expand _bfd_int64_low in a
	number of places.
@
text
@d452 2
a453 1
	  memcpy (to, from, size);
@


1.54
log
@Change sources over to using GPLv3
@
text
@d163 1
d165 3
d276 1
d278 3
d1352 1
a1352 1
#if BFD_HOST_64BIT_LONG
@


1.53
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2 of the License, or
@


1.52
log
@	* budemang.c: Delete.
	* budemang.h: Delete.
	* addr2line.c (translate_addresses): Call bfd_demangle rather than
	demangle.
	* nm.c (print_symname): Likewise.
	* objdump.c (objdump_print_symname, dump_symbols): Likewise.
	(dump_bfd): Likewise.
	* prdbg.c (struct pr_handle <demangler>): Add int param.
	(tg_variable, tg_start_function): Adjust demangler calls.
	* Makefile.am: Remove mention of budemang.[ch].  Run "make dep-am".
	* Makefile.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d23 1
a25 1
#include "bucomm.h"
d33 1
@


1.51
log
@	PR binutils/4292
	* nm.c (print_value): Cast bfd_vma to unsigned long to suit
	value_format_32bit.
@
text
@a25 1
#include "budemang.h"
d337 1
a337 1
      char *res = demangle (abfd, name);
d339 6
a344 3
      printf (format, res);
      free (res);
      return;
@


1.50
log
@PR binutils/4292
* bfd.c (bfd_fprintf_vma): Do not print addresses of 32-bit
  targets as 64-bit values, even if running on a 64-bit host.
* coffgen.c (coff_print_symbol): Likewise.
* nm.c (value_format): Replace with value_format_32bit and
  value_format_64bit.
  (set_radix): Update setting of value_format.
  (set_print_width): New function.  Compute the address size of a
  given bfd and set the print_width global appropriately.
  (display_archive): Use set_print_width.
  (display_file): Likewise,
  (print_object_filename_sysv): Update use of print_width.
  (print_archive_member_sysv): Likewise.
  (print_symbol_filename_posix): Likewise.
  (print_sumbol_info_bfd, print_symbol_info_sysv): Likewise.
@
text
@d1337 1
a1337 1
      printf (value_format_32bit, val);
@


1.49
log
@top level:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.ac (TOPLEVEL_CONFIGURE_ARGUMENTS): Fix quoting.
	* configure: Regenerate.

bfd:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-pkgversion): New option.
	* configure: Regenerate.
	* Makefile.am (bfdver.h): Substitute for @@bfd_version_package@@.
	* Makefile.in: Regenerate.
	* version.h (BFD_VERSION_STRING): Define using
	@@bfd_version_package@@.

bfd/doc:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* Makefile.in: Regenerate.

binutils:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-bugurl): New option.
	* configure: Regenerate.
	* Makefile.am (REPORT_BUGS_TO): Define.
	(INCLUDES): Define REPORT_BUGS_TO.
	Regenerate dependencies.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* bucomm.h: Remove include of bin-bugs.h.
	* addr2line.c (usage): Don't print empty REPORT_BUGS_TO.
	* ar.c (usage): Pass s to list_supported_targets.  Don't print
	empty REPORT_BUGS_TO.
	* coffdump.c (show_usage): Don't print empty REPORT_BUGS_TO.
	* cxxfilt.c (usage): Print bug url when giving help.
	* dlltool.c (usage): Likewise.
	* dllwrap.c (usage): Likewise.
	* nlmconv.c (show_usage): Don't print empty REPORT_BUGS_TO.
	* nm.c (usage): Likewise.
	* objcopy.c (copy_usage, strip_usage): Likewise.
	* objdump.c (usage): Likewise.
	* readelf.c ((usage): Likewise. Add STREAM argument.  Adjust
	callers.
	* size.c (usage): Don't print empty REPORT_BUGS_TO.
	* srconv.c (show_usage): Likewise.
	* strings.c (usage): Likewise.
	* sysdymp.c (show_usage): Likewise.
	* windres.c (usage): Likewise.

gas:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-bugurl): New option.
	* configure: Regenerate.
	* dep-in.sed: Remove bin-bugs.h.
	* Makefile.am (REPORT_BUGS_TO): Define.
	(INCLUDES): Define REPORT_BUGS_TO.
	(DEP_INCLUDES): Likewise.
	($(OBJS)): No longer depend on bin-bugs.h.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* as.c (show_usage): Don't print empty REPORT_BUGS_TO.
	* as.h: Remove include of bin-bugs.h.

gprof:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-pkgversion, --with-bugurl): New options.
	* configure: Regenerate.
	* Makefile.am (PKGVERSION, REPORT_BUGS_TO): Define.
	(INCLUDES): Define PKGVERSION and REPORT_BUGS_TO.
	Regenerate dependencies.
	* Makefile.in: Regenerate.
	* gprof.c (usage): Don't print empty REPORT_BUGS_TO.
	(main): Include PKGVERSION in version output.
	* gprof.h: Remove include of bin-bugs.h.

include:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* bin-bugs.h: Remove.

ld:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-bugurl): New option.
	* configure: Regenerate.
	* Makefile.am (REPORT_BUGS_TO): Define.
	(INCLUDES): Define REPORT_BUGS_TO.
	Regenerate dependencies.
	* Makefile.in: Regenerate.
	* ld.h: Remove include of bin-bugs.h.
	* lexsup.c (help): Don't print empty REPORT_BUGS_TO.
@
text
@d162 3
a164 14
#ifndef BFD64
static char value_format[] = "%08lx";
#else
#if BFD_HOST_64BIT_LONG
static char value_format[] = "%016lx";
#else
/* We don't use value_format for this case.  */
#endif
#endif
#ifdef BFD64
static int print_width = 16;
#else
static int print_width = 8;
#endif
d271 2
a272 10
#ifndef BFD64
      value_format[4] = *radix;
#else
#if BFD_HOST_64BIT_LONG
      value_format[5] = *radix;
#else
      /* This case requires special handling for octal and decimal
         printing.  */
#endif
#endif
d1078 20
d1124 1
a1124 4
	  char buf[30];

	  bfd_sprintf_vma (arfile, buf, (bfd_vma) -1);
	  print_width = strlen (buf);
d1179 1
a1179 4
      char buf[30];

      bfd_sprintf_vma (file, buf, (bfd_vma) -1);
      print_width = strlen (buf);
d1225 1
a1225 1
  if (print_width == 8)
d1276 1
a1276 1
  if (print_width == 8)
d1334 9
a1342 2
#if ! defined (BFD64) || BFD_HOST_64BIT_LONG
  printf (value_format, val);
d1344 21
a1364 7
  /* We have a 64 bit value to print, but the host is only 32 bit.  */
  if (print_radix == 16)
    bfd_fprintf_vma (abfd, stdout, val);
  else
    {
      char buf[30];
      char *s;
d1366 3
a1368 10
      s = buf + sizeof buf;
      *--s = '\0';
      while (val > 0)
	{
	  *--s = (val % print_radix) + '0';
	  val /= print_radix;
	}
      while ((buf + sizeof buf - 1) - s < 16)
	*--s = '0';
      printf ("%s", s);
a1369 1
#endif
d1379 1
a1379 1
      if (print_width == 16)
d1422 1
a1422 1
      if (print_width == 8)
d1452 1
a1452 1
	  if (print_width == 8)
@


1.48
log
@	* addr2line.c (usage): Document @@file.
	* ar.c (usage): Likewise.
	* coffdump (usage): Likewise.
	* cxxfilt.c (usage): Likewise.
	* dlltool.c (usage): Likewise.
	* dllwrap.c (usage): Likewise.
	* nlmconv.c (usage): Likewise.
	* nm.c (usage): Likewise.
	* objcopy.c (usage): Likewise.
	* objdump.c (usage): Likewise.
	* readelf.c (usage): Likewise.
	* size.c (usage): Likeise.
	* srconv.c (usage): Likewise.
	* strings.c (usage): Likewise.
	* windres.c (usage): Likewise.
	* doc/binutils.texi: Add section on common options.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004, 2005
d262 1
a262 1
  if (status == 0)
@


1.48.2.1
log
@	binutils/
	* Makefile.am: Rebuild dependencies.
	(REPORT_BUGS_TO): Always defined.
	(INCLUDES): Adjust.
	* Makefile.in: Rebuilt.
	* configure.in (REPORT_BUGS_TO): Provide default value.
	* configure: Rebuilt.
	* bucomm.h: Remove bin-bugs.h.
	* addr2line.c (usage): Don't print empty REPORT_BUGS_TO.
	* coffdump.c (show_usage): Likewise.
	* cxxfilt.c (usage): Likewise.
	* nlmconv.c (show_usage): Likewise.
	* nm.c (usage): Likewise.
	* objcopy.c (copy_usage, strip_usage): Likewise.
	* objdump.c (usage): Likewise.
	* size.c (usage): Likewise.
	* srconv.c (show_usage): Likewise.
	* string.c (usage): Likewise.
	* sysdymp.c (show_usage): Likewise.
	* windres.c (usage): Likewise.
	* readelf (usage): Likewise. Add STREAM argument.  Adjust callers.

	gas/
	* Makefile.am: Rebuild dependencies.
	(REPORT_BUGS_TO): Always defined.
	(INCLUDES): Adjust.
	* Makefile.in: Rebuilt.
	* configure.in (REPORT_BUGS_TO): Provide default value.
	* configure: Rebuilt.
	* as.c (show_usage): Don't print empty REPORT_BUGS_TO.
	* as.h: Remove bin-bugs.h.

	ld/
	* Makefile.am: Rebuild dependencies.
	(REPORT_BUGS_TO): Always defined.
	(INCLUDES): Adjust.
	* Makefile.in: Rebuilt.
	* configure.in (REPORT_BUGS_TO): Provide default value.
	* configure: Rebuilt.
	* ld.h: Remove bin-bugs.h
	* lexsup.c (help):  Don't print empty REPORT_BUGS_TO.

	gprof/
	* Makefile.am: Rebuild dependencies.
	(REPORT_BUGS_TO): Always defined.
	(PKGVERSION): Define.
	(INCLUDES): Adjust.
	* Makefile.in: Rebuilt.
	* configure.in (REPORT_BUGS_TO): Provide default value.
	* configure: Rebuilt.
	* gprof.c (usage): Don't print empty REPORT_BUGS_TO.
	* gprof.h: Remove bin-bugs.h

	include/
	* bin-bugs.h: Remove.
@
text
@d262 1
a262 1
  if (REPORT_BUGS_TO[0] && status == 0)
@


1.47
log
@	* addr2line.c (main): Likewise.
	* ar.c (main): Likewise.
	* coffdump.c (main): Likewise.
	* cxxfilt.c (main): Likewise.
	* dlltool.c (main): Likewise.
	* dllwrap.c (main): Likewise.
	* nlmconv.c (main): Likewise.
	* nm.c (main): Likewise.
	* objcopy.c (main): Likewise.
	* objdump.c (main): Likewise.
	* readelf.c (main): Likewise.
	* size.c (main): Likeiwse.
	* srcconv.c (main): Likewise.
	* strings.c (main): Likewise.
	* sysdump.c (main): Likewise.
	* sysinfo.c (main): Likewise.
	* windres.c (main): Likewise.

	* ldmain.c (main): Use expandargv.

	* gprof.c (main): Use expandargv.

	* as.c (main): Use expandargv.
@
text
@d257 1
@


1.46
log
@bfd/

2005-06-06  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 990
	* bfd.c (bfd_find_line): New.

	* dwarf2.c (comp_unit): Add variable_table.
	(funcinfo): Add file, line, and sec.
	(varinfo): New.
	(lookup_symbol_in_function_table): New.
	(lookup_symbol_in_variable_table): New.
	(scan_unit_for_functions): Renamed to ...
	(scan_unit_for_symbols): This. Handle DW_TAG_entry_point and
	DW_TAG_variable.
	(comp_unit_find_nearest_line): Updated.
	(comp_unit_find_line): New.
	(_bfd_dwarf2_find_line): New.

	* elf-bfd.h (_bfd_elf_find_line): New.
	(_bfd_generic_find_line): New. Defined.

	* elf.c (_bfd_elf_find_line): New.

	* libbfd-in.h (_bfd_dwarf2_find_line): New.
	(_bfd_generic_find_line): New.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.

	* libbfd.c (_bfd_generic_find_line): New.

	* targets.c (BFD_JUMP_TABLE_SYMBOLS): Initialize _bfd_find_line
	with _bfd_generic_find_line.
	(bfd_target): Add _bfd_find_line.

binutils/

2005-06-06  H.J. Lu  <hongjiu.lu@@intel.com>

	PR 990
	* nm.c (print_symbol): Call bfd_find_line before
	bfd_find_nearest_line.
@
text
@d1494 2
@


1.45
log
@Update FSF address
@
text
@d908 4
a911 3
	  if (bfd_find_nearest_line (abfd, bfd_get_section (sym), syms,
				     sym->value, &filename, &functionname,
				     &lineno)
@


1.44
log
@bfd/
	* elf.c (_bfd_elf_get_dynamic_reloc_upper_bound): Only include
	loadable reloc sections.
	(_bfd_elf_canonicalize_dynamic_reloc): Likewise.
	(_bfd_elf_get_synthetic_symtab): Return 0 if no dynamic syms.
binutils/
	* nm.c (display_rel_file): Read dynamic syms before calling
	bfd_get_synthetic_symtab.
@
text
@d20 2
a21 2
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.44.6.1
log
@	* ld/ldmain.c (main): Use expandargv.
	* binutils/addr2line.c (main): Likewise.
	* binutils/ar.c (main): Likewise.
	* binutils/coffdump.c (main): Likewise.
	* binutils/cxxfilt.c (main): Likewise.
	* binutils/dlltool.c (main): Likewise.
	* binutils/dllwrap.c (main): Likewise.
	* binutils/nlmconv.c (main): Likewise.
	* binutils/nm.c (main): Likewise.
	* binutils/objcopy.c (main): Likewise.
	* binutils/objdump.c (main): Likewise.
	* binutils/readelf.c (main): Likewise.
	* binutils/size.c (main): Likeiwse.
	* binutils/srcconv.c (main): Likewise.
	* binutils/strings.c (main): Likewise.
	* binutils/sysdump.c (main): Likewise.
	* binutils/sysinfo.c (main): Likewise.
	* binutils/windres.c (main): Likewise.

	* include/libiberty.h (expandargv): New function.
	* libiberty/argv.c (safe-ctype.h): Include it.
	(ISBLANK): Remove.
	(stdio.h): Include.
	(expandargv): New function.
	* libiberty/Makefile.in: Regenerated.
@
text
@a1492 2
  expandargv (&argc, &argv);

@


1.43
log
@(usage): Fix description of --special-syms switch.
@
text
@d3 1
a3 1
   2001, 2002, 2003, 2004
d1029 2
d1033 8
@


1.42
log
@Implement a new BFD API function: bfd_is_target_special_symbol.  Use this in nm
and objdump to skip the displaying of ARM Mapping symbols unless specifically
requested.
@
text
@d251 1
a251 1
      --skip-special     Ignore special symbols\n\
@


1.41
log
@Reoder functions to eliminate most of the static function prototypes.
@
text
@d155 1
d209 1
d251 1
d452 5
@


1.40
log
@	* nm.c (show_synthetic): New var.
	(long_options): Add "synthetic".
	(usage): Here too.
	(display_rel_file): Handle show_synthetic.
@
text
@a70 25
static void usage (FILE *, int);
static void set_print_radix (char *);
static void set_output_format (char *);
static void display_archive (bfd *);
static bfd_boolean display_file (char *);
static void display_rel_file (bfd *, bfd *);
static long filter_symbols (bfd *, bfd_boolean, void *, long, unsigned int);
static long sort_symbols_by_size
  (bfd *, bfd_boolean, void *, long, unsigned int, struct size_sym **);
static void print_symbols
  (bfd *, bfd_boolean, void *, long, unsigned int, bfd *);
static void print_size_symbols
  (bfd *, bfd_boolean, struct size_sym *, long, bfd *);
static void print_symname (const char *, const char *, bfd *);
static void print_symbol (bfd *, asymbol *, bfd_vma ssize, bfd *);
static void print_symdef_entry (bfd *);

/* The sorting functions.  */
static int numeric_forward (const void *, const void *);
static int numeric_reverse (const void *, const void *);
static int non_numeric_forward (const void *, const void *);
static int non_numeric_reverse (const void *, const void *);
static int size_forward1 (const void *, const void *);
static int size_forward2 (const void *, const void *);

a87 2
static void get_relocs (bfd *, asection *, void *);
static const char * get_symbol_type (unsigned int);
a319 167
int main (int, char **);

int
main (int argc, char **argv)
{
  int c;
  int retval;

#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
#if defined (HAVE_SETLOCALE)
  setlocale (LC_CTYPE, "");
  setlocale (LC_COLLATE, "");
#endif
  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

  program_name = *argv;
  xmalloc_set_program_name (program_name);

  START_PROGRESS (program_name, 0);

  bfd_init ();
  set_default_bfd_target ();

  while ((c = getopt_long (argc, argv, "aABCDef:gHhlnopPrSst:uvVvX:",
			   long_options, (int *) 0)) != EOF)
    {
      switch (c)
	{
	case 'a':
	  print_debug_syms = 1;
	  break;
	case 'A':
	case 'o':
	  filename_per_symbol = 1;
	  break;
	case 'B':		/* For MIPS compatibility.  */
	  set_output_format ("bsd");
	  break;
	case 'C':
	  do_demangle = 1;
	  if (optarg != NULL)
	    {
	      enum demangling_styles style;

	      style = cplus_demangle_name_to_style (optarg);
	      if (style == unknown_demangling)
		fatal (_("unknown demangling style `%s'"),
		       optarg);

	      cplus_demangle_set_style (style);
	    }
	  break;
	case 'D':
	  dynamic = 1;
	  break;
	case 'e':
	  /* Ignored for HP/UX compatibility.  */
	  break;
	case 'f':
	  set_output_format (optarg);
	  break;
	case 'g':
	  external_only = 1;
	  break;
	case 'H':
	case 'h':
	  usage (stdout, 0);
	case 'l':
	  line_numbers = 1;
	  break;
	case 'n':
	case 'v':
	  sort_numerically = 1;
	  break;
	case 'p':
	  no_sort = 1;
	  break;
	case 'P':
	  set_output_format ("posix");
	  break;
	case 'r':
	  reverse_sort = 1;
	  break;
	case 's':
	  print_armap = 1;
	  break;
	case 'S':
	  print_size = 1;
	  break;
	case 't':
	  set_print_radix (optarg);
	  break;
	case 'u':
	  undefined_only = 1;
	  break;
	case 'V':
	  show_version = 1;
	  break;
	case 'X':
	  /* Ignored for (partial) AIX compatibility.  On AIX, the
	     argument has values 32, 64, or 32_64, and specifies that
	     only 32-bit, only 64-bit, or both kinds of objects should
	     be examined.  The default is 32.  So plain AIX nm on a
	     library archive with both kinds of objects will ignore
	     the 64-bit ones.  For GNU nm, the default is and always
	     has been -X 32_64, and other options are not supported.  */
	  if (strcmp (optarg, "32_64") != 0)
	    fatal (_("Only -X 32_64 is supported"));
	  break;

	case OPTION_TARGET:	/* --target */
	  target = optarg;
	  break;

	case 0:		/* A long option that just sets a flag.  */
	  break;

	default:
	  usage (stderr, 1);
	}
    }

  if (show_version)
    print_version ("nm");

  if (sort_by_size && undefined_only)
    {
      non_fatal (_("Using the --size-sort and --undefined-only options together"));
      non_fatal (_("will produce no output, since undefined symbols have no size."));
      return 0;
    }

  /* OK, all options now parsed.  If no filename specified, do a.out.  */
  if (optind == argc)
    return !display_file ("a.out");

  retval = 0;

  if (argc - optind > 1)
    filename_per_file = 1;

  /* We were given several filenames to do.  */
  while (optind < argc)
    {
      PROGRESS (1);
      if (!display_file (argv[optind++]))
	retval++;
    }

  END_PROGRESS (program_name);

#ifdef HAVE_SBRK
  if (show_stats)
    {
      char *lim = (char *) sbrk (0);

      non_fatal (_("data size %ld"), (long) (lim - (char *) &environ));
    }
#endif

  exit (retval);
  return retval;
}

d344 3
d349 1
a349 1
display_archive (bfd *file)
d351 1
a351 10
  bfd *arfile = NULL;
  bfd *last_arfile = NULL;
  char **matching;

  (*format->print_archive_filename) (bfd_get_filename (file));

  if (print_armap)
    print_symdef_entry (file);

  for (;;)
d353 1
a353 1
      PROGRESS (1);
d355 4
a358 1
      arfile = bfd_openr_next_archived_file (file, arfile);
d360 2
a361 6
      if (arfile == NULL)
	{
	  if (bfd_get_error () != bfd_error_no_more_archived_files)
	    bfd_fatal (bfd_get_filename (file));
	  break;
	}
d363 6
a368 3
      if (bfd_check_format_matches (arfile, bfd_object, &matching))
	{
	  char buf[30];
d370 6
a375 7
	  bfd_sprintf_vma (arfile, buf, (bfd_vma) -1);
	  print_width = strlen (buf);
	  (*format->print_archive_member) (bfd_get_filename (file),
					   bfd_get_filename (arfile));
	  display_rel_file (arfile, file);
	}
      else
d377 2
a378 6
	  bfd_nonfatal (bfd_get_filename (arfile));
	  if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
	    {
	      list_matching_formats (matching);
	      free (matching);
	    }
d380 4
a383 2

      if (last_arfile != NULL)
d385 2
a386 3
	  bfd_close (last_arfile);
	  lineno_cache_bfd = NULL;
	  lineno_cache_rel_bfd = NULL;
a387 8
      last_arfile = arfile;
    }

  if (last_arfile != NULL)
    {
      bfd_close (last_arfile);
      lineno_cache_bfd = NULL;
      lineno_cache_rel_bfd = NULL;
d390 4
d395 3
a397 2
static bfd_boolean
display_file (char *filename)
d399 6
a404 3
  bfd_boolean retval = TRUE;
  bfd *file;
  char **matching;
d406 3
a408 2
  if (get_file_size (filename) < 1)
    return FALSE;
d410 1
a410 2
  file = bfd_openr (filename, target);
  if (file == NULL)
d412 29
a440 3
      bfd_nonfatal (filename);
      return FALSE;
    }
d442 6
a447 7
  if (bfd_check_format (file, bfd_archive))
    {
      display_archive (file);
    }
  else if (bfd_check_format_matches (file, bfd_object, &matching))
    {
      char buf[30];
d449 1
a449 9
      bfd_sprintf_vma (file, buf, (bfd_vma) -1);
      print_width = strlen (buf);
      (*format->print_object_filename) (filename);
      display_rel_file (file, NULL);
    }
  else
    {
      bfd_nonfatal (filename);
      if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
d451 2
a452 2
	  list_matching_formats (matching);
	  free (matching);
a453 1
      retval = FALSE;
d456 1
a456 7
  if (!bfd_close (file))
    bfd_fatal (filename);

  lineno_cache_bfd = NULL;
  lineno_cache_rel_bfd = NULL;

  return retval;
a473 33
numeric_forward (const void *P_x, const void *P_y)
{
  asymbol *x, *y;
  asection *xs, *ys;

  x = bfd_minisymbol_to_symbol (sort_bfd, sort_dynamic, P_x, sort_x);
  y =  bfd_minisymbol_to_symbol (sort_bfd, sort_dynamic, P_y, sort_y);
  if (x == NULL || y == NULL)
    bfd_fatal (bfd_get_filename (sort_bfd));

  xs = bfd_get_section (x);
  ys = bfd_get_section (y);

  if (bfd_is_und_section (xs))
    {
      if (! bfd_is_und_section (ys))
	return -1;
    }
  else if (bfd_is_und_section (ys))
    return 1;
  else if (valueof (x) != valueof (y))
    return valueof (x) < valueof (y) ? -1 : 1;

  return non_numeric_forward (P_x, P_y);
}

static int
numeric_reverse (const void *x, const void *y)
{
  return - numeric_forward (x, y);
}

static int
d512 33
d665 1
a665 1
  symsizes = (struct size_sym *) xmalloc (symcount * sizeof (struct size_sym));
d742 3
a744 2

/* If ARCHIVE_BFD is non-NULL, it is the archive containing ABFD.  */
d747 1
a747 1
display_rel_file (bfd *abfd, bfd *archive_bfd)
d749 3
a751 4
  long symcount;
  void *minisyms;
  unsigned int size;
  struct size_sym *symsizes;
d753 1
a753 1
  if (! dynamic)
d755 2
a756 5
      if (!(bfd_get_file_flags (abfd) & HAS_SYMS))
	{
	  non_fatal (_("%s: no symbols"), bfd_get_filename (abfd));
	  return;
	}
d758 3
d762 3
a764 3
  symcount = bfd_read_minisymbols (abfd, dynamic, &minisyms, &size);
  if (symcount < 0)
    bfd_fatal (bfd_get_filename (abfd));
d766 5
a770 4
  if (symcount == 0)
    {
      non_fatal (_("%s: no symbols"), bfd_get_filename (abfd));
      return;
d773 27
a799 1
  if (show_synthetic && size == sizeof (asymbol *))
d801 4
a804 6
      asymbol *synthsyms;
      long synth_count;
      asymbol **static_syms = NULL;
      asymbol **dyn_syms = NULL;
      long static_count = 0;
      long dyn_count = 0;
d806 4
a809 1
      if (dynamic)
d811 2
a812 2
	  dyn_count = symcount;
	  dyn_syms = minisyms;
d814 1
a814 1
      else
d816 10
a825 2
	  static_count = symcount;
	  static_syms = minisyms;
d827 2
a828 3
      synth_count = bfd_get_synthetic_symtab (abfd, static_count, static_syms,
					      dyn_count, dyn_syms, &synthsyms);
      if (synth_count > 0)
d830 27
a856 3
	  asymbol **symp;
	  void *new_mini;
	  long i;
d858 3
a860 11
	  new_mini = xmalloc ((symcount + synth_count + 1) * sizeof (*symp));
	  symp = new_mini;
	  memcpy (symp, minisyms, symcount * sizeof (*symp));
	  symp += symcount;
	  for (i = 0; i < synth_count; i++)
	    *symp++ = synthsyms + i;
	  *symp = 0;
	  minisyms = new_mini;
	  symcount += synth_count;
	}
    }
d862 7
a868 3
  /* Discard the symbols we don't want to print.
     It's OK to do this in place; we'll free the storage anyway
     (after printing).  */
d870 4
a873 1
  symcount = filter_symbols (abfd, dynamic, minisyms, symcount, size);
d875 3
a877 9
  symsizes = NULL;
  if (! no_sort)
    {
      sort_bfd = abfd;
      sort_dynamic = dynamic;
      sort_x = bfd_make_empty_symbol (abfd);
      sort_y = bfd_make_empty_symbol (abfd);
      if (sort_x == NULL || sort_y == NULL)
	bfd_fatal (bfd_get_filename (abfd));
d879 28
a906 6
      if (! sort_by_size)
	qsort (minisyms, symcount, size,
	       sorters[sort_numerically][reverse_sort]);
      else
	symcount = sort_symbols_by_size (abfd, dynamic, minisyms, symcount,
					 size, &symsizes);
d909 1
a909 6
  if (! sort_by_size)
    print_symbols (abfd, dynamic, minisyms, symcount, size, archive_bfd);
  else
    print_size_symbols (abfd, dynamic, symsizes, symcount, archive_bfd);

  free (minisyms);
d912 1
a912 3
/* Choose which symbol entries to print;
   compact them downward to get rid of the rest.
   Return the number of symbols to be printed.  */
d914 4
a917 3
static long
filter_symbols (bfd *abfd, bfd_boolean dynamic, void *minisyms,
		long symcount, unsigned int size)
a918 1
  bfd_byte *from, *fromend, *to;
d920 1
d926 3
a928 5
  from = (bfd_byte *) minisyms;
  fromend = from + symcount * size;
  to = (bfd_byte *) minisyms;

  for (; from < fromend; from += size)
a929 1
      int keep = 0;
d931 1
d933 1
a933 3
      PROGRESS (1);

      sym = bfd_minisymbol_to_symbol (abfd, dynamic, (const void *) from, store);
d937 3
a939 7
      if (undefined_only)
	keep = bfd_is_und_section (sym->section);
      else if (external_only)
	keep = ((sym->flags & BSF_GLOBAL) != 0
		|| (sym->flags & BSF_WEAK) != 0
		|| bfd_is_und_section (sym->section)
		|| bfd_is_com_section (sym->section));
d941 1
a941 1
	keep = 1;
d943 1
a943 23
      if (keep
	  && ! print_debug_syms
	  && (sym->flags & BSF_DEBUGGING) != 0)
	keep = 0;

      if (keep
	  && sort_by_size
	  && (bfd_is_abs_section (sym->section)
	      || bfd_is_und_section (sym->section)))
	keep = 0;

      if (keep
	  && defined_only)
	{
	  if (bfd_is_und_section (sym->section))
	    keep = 0;
	}

      if (keep)
	{
	  memcpy (to, from, size);
	  to += size;
	}
d945 1
a946 2
  return (to - (bfd_byte *) minisyms) / size;
}
a947 18
/* Print symbol name NAME, read from ABFD, with printf format FORMAT,
   demangling it if requested.  */

static void
print_symname (const char *format, const char *name, bfd *abfd)
{
  if (do_demangle && *name)
    {
      char *res = demangle (abfd, name);

      printf (format, res);
      free (res);
      return;
    }

  printf (format, name);
}

d976 1
a976 1
/* Print the symbols when sorting by size.  */
d979 1
a979 3
print_size_symbols (bfd *abfd, bfd_boolean dynamic,
		    struct size_sym *symsizes, long symcount,
		    bfd *archive_bfd)
d981 13
a993 2
  asymbol *store;
  struct size_sym *from, *fromend;
d995 2
a996 2
  store = bfd_make_empty_symbol (abfd);
  if (store == NULL)
d999 7
a1005 3
  from = symsizes;
  fromend = from + symcount;
  for (; from < fromend; from++)
d1007 42
a1048 2
      asymbol *sym;
      bfd_vma ssize;
d1050 8
a1057 2
      sym = bfd_minisymbol_to_symbol (abfd, dynamic, from->minisym, store);
      if (sym == NULL)
d1060 3
a1062 3
      /* For elf we have already computed the correct symbol size.  */
      if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
	ssize = from->size;
d1064 8
a1071 1
	ssize = from->size - bfd_section_vma (abfd, bfd_get_section (sym));
d1073 1
a1073 2
      print_symbol (abfd, sym, ssize, archive_bfd);
    }
a1075 2
/* Print a single symbol.  */

d1077 1
a1077 1
print_symbol (bfd *abfd, asymbol *sym, bfd_vma ssize, bfd *archive_bfd)
d1079 3
a1081 2
  symbol_info syminfo;
  struct extended_symbol_info info;
d1083 1
a1083 1
  PROGRESS (1);
d1085 2
a1086 1
  (*format->print_symbol_filename) (archive_bfd, abfd);
d1088 3
a1090 8
  bfd_get_symbol_info (abfd, sym, &syminfo);
  info.sinfo = &syminfo;
  info.ssize = ssize;
  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
    info.elfinfo = (elf_symbol_type *) sym;
  else
    info.elfinfo = NULL;
  (*format->print_symbol_info) (&info, abfd);
d1092 1
a1092 6
  if (line_numbers)
    {
      static asymbol **syms;
      static long symcount;
      const char *filename, *functionname;
      unsigned int lineno;
d1094 1
a1094 4
      /* We need to get the canonical symbols in order to call
         bfd_find_nearest_line.  This is inefficient, but, then, you
         don't have to use --line-numbers.  */
      if (abfd != lineno_cache_bfd && syms != NULL)
d1096 3
a1098 2
	  free (syms);
	  syms = NULL;
d1100 2
a1101 1
      if (syms == NULL)
d1103 1
a1103 1
	  long symsize;
d1105 5
a1109 8
	  symsize = bfd_get_symtab_upper_bound (abfd);
	  if (symsize < 0)
	    bfd_fatal (bfd_get_filename (abfd));
	  syms = (asymbol **) xmalloc (symsize);
	  symcount = bfd_canonicalize_symtab (abfd, syms);
	  if (symcount < 0)
	    bfd_fatal (bfd_get_filename (abfd));
	  lineno_cache_bfd = abfd;
d1111 1
a1111 2

      if (bfd_is_und_section (bfd_get_section (sym)))
d1113 2
a1114 10
	  static asection **secs;
	  static arelent ***relocs;
	  static long *relcount;
	  static unsigned int seccount;
	  unsigned int i;
	  const char *symname;

	  /* For an undefined symbol, we try to find a reloc for the
             symbol, and print the line number of the reloc.  */
	  if (abfd != lineno_cache_rel_bfd && relocs != NULL)
d1116 2
a1117 9
	      for (i = 0; i < seccount; i++)
		if (relocs[i] != NULL)
		  free (relocs[i]);
	      free (secs);
	      free (relocs);
	      free (relcount);
	      secs = NULL;
	      relocs = NULL;
	      relcount = NULL;
d1119 10
d1130 7
a1136 3
	  if (relocs == NULL)
	    {
	      struct get_relocs_info info;
d1138 6
a1143 1
	      seccount = bfd_count_sections (abfd);
d1145 2
a1146 3
	      secs = (asection **) xmalloc (seccount * sizeof *secs);
	      relocs = (arelent ***) xmalloc (seccount * sizeof *relocs);
	      relcount = (long *) xmalloc (seccount * sizeof *relcount);
d1148 6
a1153 7
	      info.secs = secs;
	      info.relocs = relocs;
	      info.relcount = relcount;
	      info.syms = syms;
	      bfd_map_over_sections (abfd, get_relocs, (void *) &info);
	      lineno_cache_rel_bfd = abfd;
	    }
d1155 7
a1161 4
	  symname = bfd_asymbol_name (sym);
	  for (i = 0; i < seccount; i++)
	    {
	      long j;
d1163 9
a1171 24
	      for (j = 0; j < relcount[i]; j++)
		{
		  arelent *r;

		  r = relocs[i][j];
		  if (r->sym_ptr_ptr != NULL
		      && (*r->sym_ptr_ptr)->section == sym->section
		      && (*r->sym_ptr_ptr)->value == sym->value
		      && strcmp (symname,
				 bfd_asymbol_name (*r->sym_ptr_ptr)) == 0
		      && bfd_find_nearest_line (abfd, secs[i], syms,
						r->address, &filename,
						&functionname, &lineno)
		      && filename != NULL)
		    {
		      /* We only print the first one we find.  */
		      printf ("\t%s:%u", filename, lineno);
		      i = seccount;
		      break;
		    }
		}
	    }
	}
      else if (bfd_get_section (sym)->owner == abfd)
d1173 2
a1174 8
	  if (bfd_find_nearest_line (abfd, bfd_get_section (sym), syms,
				     sym->value, &filename, &functionname,
				     &lineno)
	      && filename != NULL
	      && lineno != 0)
	    {
	      printf ("\t%s:%u", filename, lineno);
	    }
d1176 1
d1179 7
a1185 1
  putchar ('\n');
d1454 2
a1455 2
static void
print_symdef_entry (bfd *abfd)
d1457 20
a1476 3
  symindex idx = BFD_NO_MORE_SYMBOLS;
  carsym *thesym;
  bfd_boolean everprinted = FALSE;
d1478 2
a1479 3
  for (idx = bfd_get_next_mapent (abfd, idx, &thesym);
       idx != BFD_NO_MORE_SYMBOLS;
       idx = bfd_get_next_mapent (abfd, idx, &thesym))
d1481 1
a1481 2
      bfd *elt;
      if (!everprinted)
d1483 91
a1573 10
	  printf (_("\nArchive index:\n"));
	  everprinted = TRUE;
	}
      elt = bfd_get_elt_at_index (abfd, idx);
      if (elt == NULL)
	bfd_fatal ("bfd_get_elt_at_index");
      if (thesym->name != (char *) NULL)
	{
	  print_symname ("%s", thesym->name, abfd);
	  printf (" in %s\n", bfd_get_filename (elt));
a1575 4
}

/* This function is used to get the relocs for a particular section.
   It is called via bfd_map_over_sections.  */
d1577 15
a1591 4
static void
get_relocs (bfd *abfd, asection *sec, void *dataarg)
{
  struct get_relocs_info *data = (struct get_relocs_info *) dataarg;
d1593 2
a1594 1
  *data->secs = sec;
d1596 2
a1597 1
  if ((sec->flags & SEC_RELOC) == 0)
d1599 3
a1601 2
      *data->relocs = NULL;
      *data->relcount = 0;
d1603 5
a1607 1
  else
d1609 1
a1609 1
      long relsize;
d1611 1
a1611 9
      relsize = bfd_get_reloc_upper_bound (abfd, sec);
      if (relsize < 0)
	bfd_fatal (bfd_get_filename (abfd));

      *data->relocs = (arelent **) xmalloc (relsize);
      *data->relcount = bfd_canonicalize_reloc (abfd, sec, *data->relocs,
						data->syms);
      if (*data->relcount < 0)
	bfd_fatal (bfd_get_filename (abfd));
d1613 1
d1615 2
a1616 3
  ++data->secs;
  ++data->relocs;
  ++data->relcount;
@


1.39
log
@Use consistent error messages for missing files.
Detect directories where an ordinary file is expected.
@
text
@d3 1
a3 1
   2001, 2002, 2003
d180 1
d236 1
d276 1
d964 39
@


1.38
log
@	* ChangeLog: Fix typos.
	* ChangeLog-9197: Likewise.
	* ChangeLog-9899: Likewise.
	* NEWS: Likewise.
	* ar.c: Fix comment typos.
	* arsup.c: Likewise.
	* coffgrok.c: Likewise.
	* debug.c: Likewise.
	* debug.h: Likewise.
	* dlltool.c: Likewise.
	* ieee.c: Likewise.
	* nm.c: Likewise.
	* objdump.c: Likewise.
	* prdbg.c: Likewise.
	* readelf.c: Likewise.
	* resrc.c: Likewise.
	* sysinfo.y: Likewise.
	* windres.c: Likewise.
@
text
@d605 3
@


1.37
log
@	* addr2line.c: Convert to ISO C90 prototypes, change PTR, remove
	unneeded (void *) casts.
	* ar.c: Likewise.
	* arlex.l: Likewise.
	* arparse.y: Likewise.
	* arsup.c: Likewise.
	* binemul.c: Likewise.
	* binemul.h: Likewise.
	* bucomm.c: Likewise.
	* bucomm.h: Likewise.
	* budbg.h: Likewise.
	* budemang.c: Likewise.
	* budemang.h: Likewise.
	* coffdump.c: Likewise.
	* coffgrok.c: Likewise.
	* cxxfilt.c: Likewise.
	* debug.c: Likewise.
	* debug.h: Likewise.
	* deflex.l: Likewise.
	* dlltool.c: Likewise.
	* dlltool.h: Likewise.
	* dllwrap.c: Likewise.
	* emul_aix.c: Likewise.
	* filemode.c: Likewise.
	* ieee.c: Likewise.
	* nlmconv.c: Likewise.
	* nlmconv.h: Likewise.
	* nlmheader.y: Likewise.
	* nm.c: Likewise.
	* prdbg.c: Likewise.
	* rclex.l: Likewise.
	* rcparse.y: Likewise.
	* rdcoff.c: Likewise.
	* rddbg.c: Likewise.
	* rename.c: Likewise.
	* resbin.c: Likewise.
	* rescoff.c: Likewise.
	* resrc.c: Likewise.
	* size.c: Likewise.
	* srconv.c: Likewise.
	* stabs.c: Likewise.
	* strings.c: Likewise.
	* sysdump.c: Likewise.
	* sysinfo.y: Likewise.
	* syslex.l: Likewise.
	* unwind-ia64.c: Likewise.
	* unwind-ia64.h: Likewise.
	* version.c: Likewise.
	* windres.c: Likewise.
	* windres.h: Likewise.
	* winduni.c: Likewise.
	* wrstabs.c: Likewise.
@
text
@d447 1
a447 1
	     argument has values 32, 64, or 32_64, and specfies that
d1445 1
a1445 1
	 size or sorting by size then we print its size, execpt for the
@


1.36
log
@nm.c (print_symbol_info_bsd): Print the symbol's size instead of the symbol's
value when --size-sort is used, unless -S is used.
doc/binutils.texi (--size-sort): For non-bsd formats both the value and size
of the symbols are displayed.
@
text
@d40 1
a40 1
  const PTR minisym;
d71 7
a77 14
static void usage
  PARAMS ((FILE *, int));
static void set_print_radix
  PARAMS ((char *));
static void set_output_format
  PARAMS ((char *));
static void display_archive
  PARAMS ((bfd *));
static bfd_boolean display_file
  PARAMS ((char *));
static void display_rel_file
  PARAMS ((bfd *, bfd *));
static long filter_symbols
  PARAMS ((bfd *, bfd_boolean, PTR, long, unsigned int));
d79 1
a79 1
  PARAMS ((bfd *, bfd_boolean, PTR, long, unsigned int, struct size_sym **));
d81 1
a81 1
  PARAMS ((bfd *, bfd_boolean, PTR, long, unsigned int, bfd *));
d83 4
a86 7
  PARAMS ((bfd *, bfd_boolean, struct size_sym *, long, bfd *));
static void print_symname
  PARAMS ((const char *, const char *, bfd *));
static void print_symbol
  PARAMS ((bfd *, asymbol *, bfd_vma ssize, bfd *));
static void print_symdef_entry
  PARAMS ((bfd *));
d89 6
a94 12
static int numeric_forward
  PARAMS ((const PTR, const PTR));
static int numeric_reverse
  PARAMS ((const PTR, const PTR));
static int non_numeric_forward
  PARAMS ((const PTR, const PTR));
static int non_numeric_reverse
  PARAMS ((const PTR, const PTR));
static int size_forward1
  PARAMS ((const PTR, const PTR));
static int size_forward2
  PARAMS ((const PTR, const PTR));
d97 18
a114 36
static void print_object_filename_bsd
  PARAMS ((char *));
static void print_object_filename_sysv
  PARAMS ((char *));
static void print_object_filename_posix
  PARAMS ((char *));
static void print_archive_filename_bsd
  PARAMS ((char *));
static void print_archive_filename_sysv
  PARAMS ((char *));
static void print_archive_filename_posix
  PARAMS ((char *));
static void print_archive_member_bsd
  PARAMS ((char *, const char *));
static void print_archive_member_sysv
  PARAMS ((char *, const char *));
static void print_archive_member_posix
  PARAMS ((char *, const char *));
static void print_symbol_filename_bsd
  PARAMS ((bfd *, bfd *));
static void print_symbol_filename_sysv
  PARAMS ((bfd *, bfd *));
static void print_symbol_filename_posix
  PARAMS ((bfd *, bfd *));
static void print_value
  PARAMS ((bfd *, bfd_vma));
static void print_symbol_info_bsd
  PARAMS ((struct extended_symbol_info *, bfd *));
static void print_symbol_info_sysv
  PARAMS ((struct extended_symbol_info *, bfd *));
static void print_symbol_info_posix
  PARAMS ((struct extended_symbol_info *, bfd *));
static void get_relocs
  PARAMS ((bfd *, asection *, PTR));
static const char * get_symbol_type
  PARAMS ((unsigned int));
d120 1
a120 1
    void (*print_object_filename) PARAMS ((char *));
d123 1
a123 1
    void (*print_archive_filename) PARAMS ((char *));
d126 1
a126 1
    void (*print_archive_member) PARAMS ((char *, const char *));
d130 1
a130 1
    void (*print_symbol_filename) PARAMS ((bfd *, bfd *));
d133 1
a133 1
    void (*print_symbol_info) PARAMS ((struct extended_symbol_info *, bfd *));
d245 1
a245 3
usage (stream, status)
     FILE *stream;
     int status;
d290 1
a290 2
set_print_radix (radix)
     char *radix;
d320 1
a320 2
set_output_format (f)
     char *f;
d344 1
a344 1
int main PARAMS ((int, char **));
d347 1
a347 3
main (argc, argv)
     int argc;
     char **argv;
d512 1
a512 2
get_symbol_type (type)
     unsigned int type;
d537 1
a537 2
display_archive (file)
     bfd *file;
d599 1
a599 2
display_file (filename)
     char *filename;
d660 1
a660 3
numeric_forward (P_x, P_y)
     const PTR P_x;
     const PTR P_y;
d687 1
a687 3
numeric_reverse (x, y)
     const PTR x;
     const PTR y;
d693 1
a693 3
non_numeric_forward (P_x, P_y)
     const PTR P_x;
     const PTR P_y;
d726 1
a726 3
non_numeric_reverse (x, y)
     const PTR x;
     const PTR y;
d731 1
a731 1
static int (*(sorters[2][2])) PARAMS ((const PTR, const PTR)) =
d749 1
a749 3
size_forward1 (P_x, P_y)
     const PTR P_x;
     const PTR P_y;
d819 1
a819 3
size_forward2 (P_x, P_y)
     const PTR P_x;
     const PTR P_y;
d838 3
a840 7
sort_symbols_by_size (abfd, dynamic, minisyms, symcount, size, symsizesp)
     bfd *abfd;
     bfd_boolean dynamic;
     PTR minisyms;
     long symcount;
     unsigned int size;
     struct size_sym **symsizesp;
d865 1
a865 1
      sym = bfd_minisymbol_to_symbol (abfd, dynamic, (const PTR) from,
d882 1
a882 1
					   (const PTR) (from + size),
d909 1
a909 1
	  symsizes->minisym = (const PTR) from;
d924 1
a924 1
  qsort ((PTR) *symsizesp, symcount, sizeof (struct size_sym), size_forward2);
d932 1
a932 3
display_rel_file (abfd, archive_bfd)
     bfd *abfd;
     bfd *archive_bfd;
d935 1
a935 1
  PTR minisyms;
d995 2
a996 6
filter_symbols (abfd, dynamic, minisyms, symcount, size)
     bfd *abfd;
     bfd_boolean dynamic;
     PTR minisyms;
     long symcount;
     unsigned int size;
d1016 1
a1016 1
      sym = bfd_minisymbol_to_symbol (abfd, dynamic, (const PTR) from, store);
d1062 1
a1062 4
print_symname (format, name, abfd)
     const char *format;
     const char *name;
     bfd *abfd;
d1080 2
a1081 7
print_symbols (abfd, dynamic, minisyms, symcount, size, archive_bfd)
     bfd *abfd;
     bfd_boolean dynamic;
     PTR minisyms;
     long symcount;
     unsigned int size;
     bfd *archive_bfd;
d1107 3
a1109 6
print_size_symbols (abfd, dynamic, symsizes, symcount, archive_bfd)
     bfd *abfd;
     bfd_boolean dynamic;
     struct size_sym *symsizes;
     long symcount;
     bfd *archive_bfd;
d1142 1
a1142 5
print_symbol (abfd, sym, ssize, archive_bfd)
     bfd *abfd;
     asymbol *sym;
     bfd_vma ssize;
     bfd *archive_bfd;
d1146 1
a1146 1
   
d1227 1
a1227 1
	      bfd_map_over_sections (abfd, get_relocs, (PTR) &info);
d1284 1
a1284 2
print_object_filename_bsd (filename)
     char *filename;
d1291 1
a1291 2
print_object_filename_sysv (filename)
     char *filename;
d1306 1
a1306 2
print_object_filename_posix (filename)
     char *filename;
d1315 1
a1315 2
print_archive_filename_bsd (filename)
     char *filename;
d1322 1
a1322 2
print_archive_filename_sysv (filename)
     char *filename ATTRIBUTE_UNUSED;
d1327 1
a1327 2
print_archive_filename_posix (filename)
     char *filename ATTRIBUTE_UNUSED;
d1334 2
a1335 3
print_archive_member_bsd (archive, filename)
     char *archive ATTRIBUTE_UNUSED;
     const char *filename;
d1342 1
a1342 3
print_archive_member_sysv (archive, filename)
     char *archive;
     const char *filename;
d1357 1
a1357 3
print_archive_member_posix (archive, filename)
     char *archive;
     const char *filename;
d1367 1
a1367 2
print_symbol_filename_bsd (archive_bfd, abfd)
     bfd *archive_bfd, *abfd;
d1378 1
a1378 2
print_symbol_filename_sysv (archive_bfd, abfd)
     bfd *archive_bfd, *abfd;
d1389 1
a1389 2
print_symbol_filename_posix (archive_bfd, abfd)
     bfd *archive_bfd, *abfd;
d1404 1
a1404 3
print_value (abfd, val)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_vma val;
d1434 1
a1434 3
print_symbol_info_bsd (info, abfd)
     struct extended_symbol_info *info;
     bfd *abfd;
d1475 1
a1475 3
print_symbol_info_sysv (info, abfd)
     struct extended_symbol_info *info;
     bfd *abfd;
d1525 1
a1525 3
print_symbol_info_posix (info, abfd)
     struct extended_symbol_info *info;
     bfd *abfd;
d1542 1
a1542 2
print_symdef_entry (abfd)
     bfd *abfd;
d1573 1
a1573 4
get_relocs (abfd, sec, dataarg)
     bfd *abfd;
     asection *sec;
     PTR dataarg;
@


1.35
log
@(print_symbol): Remove check for undefined_only.
(main): Print a warning message if --size-sort and --undefined-only are used
together.
@
text
@d1542 8
a1549 1
      print_value (abfd, SYM_VALUE (info));
d1553 1
a1553 1
	  printf(" ");
@


1.34
log
@Fix help messages about demangling styles
@
text
@d512 7
d1224 3
d1231 5
a1235 5
  if (undefined_only)
    {
      if (bfd_is_und_section (bfd_get_section (sym)))
	print_symname ("%s", bfd_asymbol_name (sym), abfd);
    }
d1237 2
a1238 13
    {
      symbol_info syminfo;
      struct extended_symbol_info info;

      bfd_get_symbol_info (abfd, sym, &syminfo);
      info.sinfo = &syminfo;
      info.ssize = ssize;
      if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
	info.elfinfo = (elf_symbol_type *) sym;
      else
	info.elfinfo = NULL;
      (*format->print_symbol_info) (&info, abfd);
    }
d1587 3
a1589 3
      printf ("%18s|  ", SYM_STAB_NAME (info));		/* (C) Type */
      printf (desc_format, SYM_STAB_DESC (info));	/* Size */
      printf ("|     |");				/* Line, Section */
@


1.33
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d3 1
a3 1
   2001, 2002
d291 2
a292 1
                          `gnu', 'lucid', 'arm', 'hp', 'edg' or 'gnu-v3'\n\
@


1.32
log
@Revert last change.
@
text
@d71 26
a96 13
static void usage                PARAMS ((FILE *, int));
static void set_print_radix      PARAMS ((char *));
static void set_output_format    PARAMS ((char *));
static void display_archive      PARAMS ((bfd *));
static boolean display_file      PARAMS ((char *));
static void display_rel_file     PARAMS ((bfd *, bfd *));
static long filter_symbols       PARAMS ((bfd *, boolean, PTR, long, unsigned int));
static long sort_symbols_by_size PARAMS ((bfd *, boolean, PTR, long, unsigned int, struct size_sym **));
static void print_symbols        PARAMS ((bfd *, boolean, PTR, long, unsigned int, bfd *));
static void print_size_symbols   PARAMS ((bfd *, boolean, struct size_sym *, long, bfd *));
static void print_symname        PARAMS ((const char *, const char *, bfd *));
static void print_symbol         PARAMS ((bfd *, asymbol *, bfd_vma ssize, bfd *));
static void print_symdef_entry   PARAMS ((bfd *));
d99 12
a110 6
static int numeric_forward PARAMS ((const PTR, const PTR));
static int numeric_reverse PARAMS ((const PTR, const PTR));
static int non_numeric_forward PARAMS ((const PTR, const PTR));
static int non_numeric_reverse PARAMS ((const PTR, const PTR));
static int size_forward1 PARAMS ((const PTR, const PTR));
static int size_forward2 PARAMS ((const PTR, const PTR));
d113 36
a148 18
static void print_object_filename_bsd PARAMS ((char *));
static void print_object_filename_sysv PARAMS ((char *));
static void print_object_filename_posix PARAMS ((char *));
static void print_archive_filename_bsd PARAMS ((char *));
static void print_archive_filename_sysv PARAMS ((char *));
static void print_archive_filename_posix PARAMS ((char *));
static void print_archive_member_bsd PARAMS ((char *, const char *));
static void print_archive_member_sysv PARAMS ((char *, const char *));
static void print_archive_member_posix PARAMS ((char *, const char *));
static void print_symbol_filename_bsd PARAMS ((bfd *, bfd *));
static void print_symbol_filename_sysv PARAMS ((bfd *, bfd *));
static void print_symbol_filename_posix PARAMS ((bfd *, bfd *));
static void print_value PARAMS ((bfd *, bfd_vma));
static void print_symbol_info_bsd PARAMS ((struct extended_symbol_info *, bfd *));
static void print_symbol_info_sysv PARAMS ((struct extended_symbol_info *, bfd *));
static void print_symbol_info_posix PARAMS ((struct extended_symbol_info *, bfd *));
static void get_relocs PARAMS ((bfd *, asection *, PTR));
static const char * get_symbol_type PARAMS ((unsigned int));
d632 1
a632 1
static boolean
d636 1
a636 1
  boolean retval = true;
d644 1
a644 1
      return false;
d668 1
a668 1
      retval = false;
d671 1
a671 1
  if (bfd_close (file) == false)
d683 1
a683 1
static boolean sort_dynamic;
d887 1
a887 1
     boolean dynamic;
d1050 1
a1050 1
     boolean dynamic;
d1142 1
a1142 1
     boolean dynamic;
d1174 1
a1174 1
     boolean dynamic;
d1642 1
a1642 1
  boolean everprinted = false;
d1652 1
a1652 1
	  everprinted = true;
@


1.31
log
@	* nm.c (display_rel_file): Don't report "no symbols" as an error.
	* objdump.c (slurp_symtab): Likewise.
	(slurp_dynamic_symtab): Likewise.
	(dump_symbols): Likewise.  Do print "no symbols" to stdout.
@
text
@d958 4
a961 1
	return;
d969 4
a972 1
    return;
@


1.30
log
@Replace 'gnu-new-abi' with 'gnu-v3'
@
text
@d958 1
a958 4
	{
	  non_fatal (_("%s: no symbols"), bfd_get_filename (abfd));
	  return;
	}
d966 1
a966 4
    {
      non_fatal (_("%s: no symbols"), bfd_get_filename (abfd));
      return;
    }
@


1.29
log
@	* budemang.c: New file, "demangle" function.
	* budemang.h: New file.
	* addr2line.c (translate_addresses): Use "demangle".
	* nm.c (print_symname): Likewise.
	* objdump.c (objdump_print_symname): Likewise.
	(dump_symbols): Likewise.  Also, don't use bfd_asymbol_name macro
	here since that obfuscates.
	* rdcoff.c: Don't #include demangle.h.
	* Makefile.am (CFILES): Add budemang.c, emul_aix.c,
	emul_vanilla.c.  Remove emul_$(EMULATION).c.  Sort.
	(HFILES): Add budemang.h.  Sort.
	(nm_new_SOURCES, objdump_SOURCES, addr2line_SOURCES): Add budemang.c.
	Run "make dep-am".
	* Makefile.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d254 1
a254 1
                          `gnu', 'lucid', 'arm', 'hp', 'edg' or 'gnu-new-abi'\n\
@


1.28
log
@	* nm.c (print_symname): When demangling, strip leading dots from
	symbol names to avoid confusing the demangler.
@
text
@d26 1
d1089 1
a1089 2
      char *res;
      const char *p;
d1091 3
a1093 34
      /* In this mode, give a user-level view of the symbol name
	 even if it's not mangled; strip off any leading
	 underscore.  */
      if (bfd_get_symbol_leading_char (abfd) == name[0])
	name++;

      /* This is a hack for XCOFF, PowerPC64-ELF or the MS PE format.
	 These formats have a number of leading '.'s on at least some
	 symbols, so we remove all dots to avoid confusing the
	 demangler.  */
      p = name;
      while (*p == '.')
	++p;

      res = cplus_demangle (p, DMGL_ANSI | DMGL_PARAMS);
      if (res)
	{
	  size_t dots = p - name;

	  /* Now put back any stripped dots.  */
	  if (dots != 0)
	    {
	      size_t len = strlen (res) + 1;
	      char *add_dots = xmalloc (len + dots);

	      memcpy (add_dots, name, dots);
	      memcpy (add_dots + dots, res, len);
	      free (res);
	      res = add_dots;
	    }
	  printf (format, res);
	  free (res);
	  return;
	}
@


1.27
log
@	* configure.in: Check for strcoll.
	* configure: Regenerate.
	* config.in: Regenerate.
	* nm.c (main): Set locale for LC_COLLATE category.
	(non_numeric_forward): Use strcoll if available.
@
text
@d1089 1
d1097 9
a1105 1
      res = cplus_demangle (name, DMGL_ANSI | DMGL_PARAMS);
d1108 13
@


1.26
log
@2002-06-18  H.J. Lu  (hjl@@gnu.org)

	* nm.c: Include "elf/common.h".
	(extended_symbol_info): Add elfinfo, a pointer to
	elf_symbol_type.
	(SYM_SIZE): Use elfinfo if it is not NULL.
	(get_symbol_type): New function.
	(display_archive): Set print_width for each archive member.
	(display_file): Likewise.
	(display_rel_file): Don't set print_width here.
	(print_object_filename_sysv): Handle print_width.
	(print_archive_member_sysv): Likewise.
	(print_symbols): Pass (bfd_vma) 0 to print_symbol.
	(print_symbol): Set the elfinfo field in extended_symbol_info
	for ELF.
	(print_object_filename_sysv): Fix the output format.
	(print_symbol_info_sysv): Print type and section for ELF.

2002-06-18  Elias Athanasopoulos  <eathan@@otenet.gr>

	* nm.c (print_size_symbols): Remove assignment, which makes
	the symbol's size equal to its value when --size-sort is
	used.
@
text
@d54 1
a54 1
struct extended_symbol_info 
d358 1
d709 17
a725 2
  return ((xn == NULL) ? ((yn == NULL) ? 0 : -1) :
	  ((yn == NULL) ? 1 : strcmp (xn, yn)));
d905 1
a905 1
      if (bfd_get_flavour (abfd) == bfd_target_elf_flavour) 
d1205 1
a1205 1
      if (bfd_get_flavour (abfd) == bfd_target_elf_flavour) 
d1564 1
a1564 1
    {	
@


1.25
log
@2002-06-15  H.J. Lu  (hjl@@gnu.org)

	* nm.c (print_size): New variable. Initialize to 0.
	(long_options): Add 'S'/"print-size".
	(main): Handle 'S'.
	(print_symbol_info_bsd): Print size only if print_size is not
	0.

	* doc/binutils.texi: Document -S/--print-size.
@
text
@d32 1
d58 1
d67 2
a68 1
#define SYM_SIZE(sym)        (sym->ssize)              
d110 1
d504 26
d558 4
d614 4
a936 1
  char buf[30];
a956 3
  bfd_sprintf_vma (abfd, buf, (bfd_vma) -1);
  print_width = strlen (buf);

a1115 1
      bfd_vma ssize;
d1121 1
a1121 6
      if (bfd_get_flavour (abfd) == bfd_target_elf_flavour) 
	ssize = ((elf_symbol_type *) sym)->internal_elf_sym.st_size;
      else
	ssize = 0;

      print_symbol (abfd, sym, ssize, archive_bfd);
a1152 3
      /* Set the symbol value so that we actually display the symbol size.  */
      sym->value = from->size - bfd_section_vma (abfd, bfd_get_section (sym));

d1189 4
d1335 6
a1340 2
  printf (_("\
Name                  Value   Class        Type         Size   Line  Section\n\n"));
d1393 6
a1398 2
  printf (_("\
Name                  Value   Class        Type         Size   Line  Section\n\n"));
d1529 6
a1534 1
    printf ("        ");
d1550 5
a1554 1
      printf ("                  |");
d1559 6
a1564 1
	printf("        ");
d1566 4
a1569 1
      printf("|     |");	
@


1.24
log
@Display the symbol's size and use it for sorting.
@
text
@d164 1
d222 1
d264 1
d366 1
a366 1
  while ((c = getopt_long (argc, argv, "aABCDef:gHhlnopPrst:uvVvX:",
d429 3
d1463 1
a1463 1
      if (SYM_SIZE (info))
@


1.23
log
@	* bucomm.c: Replace CONST with const.
	* nm.c: Likewise.
	* objdump.c: Likewise.
@
text
@d53 27
a79 39
static void
usage PARAMS ((FILE *, int));

static void
set_print_radix PARAMS ((char *));

static void
set_output_format PARAMS ((char *));

static void
display_archive PARAMS ((bfd *));

static boolean
display_file PARAMS ((char *filename));

static void
display_rel_file PARAMS ((bfd * file, bfd * archive));

static long
filter_symbols PARAMS ((bfd *, boolean, PTR, long, unsigned int));

static long
sort_symbols_by_size PARAMS ((bfd *, boolean, PTR, long, unsigned int,
			      struct size_sym **));

static void
print_symbols PARAMS ((bfd *, boolean, PTR, long, unsigned int, bfd *));

static void
print_size_symbols PARAMS ((bfd *, boolean, struct size_sym *, long, bfd *));

static void
print_symname PARAMS ((const char *, const char *, bfd *));

static void
print_symbol PARAMS ((bfd *, asymbol *, bfd *));

static void
print_symdef_entry PARAMS ((bfd * abfd));
d82 6
a87 18

static int
numeric_forward PARAMS ((const PTR, const PTR));

static int
numeric_reverse PARAMS ((const PTR, const PTR));

static int
non_numeric_forward PARAMS ((const PTR, const PTR));

static int
non_numeric_reverse PARAMS ((const PTR, const PTR));

static int
size_forward1 PARAMS ((const PTR, const PTR));

static int
size_forward2 PARAMS ((const PTR, const PTR));
d90 17
a106 55

static void
print_object_filename_bsd PARAMS ((char *filename));

static void
print_object_filename_sysv PARAMS ((char *filename));

static void
print_object_filename_posix PARAMS ((char *filename));


static void
print_archive_filename_bsd PARAMS ((char *filename));

static void
print_archive_filename_sysv PARAMS ((char *filename));

static void
print_archive_filename_posix PARAMS ((char *filename));


static void
print_archive_member_bsd PARAMS ((char *archive, const char *filename));

static void
print_archive_member_sysv PARAMS ((char *archive, const char *filename));

static void
print_archive_member_posix PARAMS ((char *archive, const char *filename));


static void
print_symbol_filename_bsd PARAMS ((bfd * archive_bfd, bfd * abfd));

static void
print_symbol_filename_sysv PARAMS ((bfd * archive_bfd, bfd * abfd));

static void
print_symbol_filename_posix PARAMS ((bfd * archive_bfd, bfd * abfd));


static void
print_value PARAMS ((bfd *, bfd_vma));

static void
print_symbol_info_bsd PARAMS ((symbol_info * info, bfd * abfd));

static void
print_symbol_info_sysv PARAMS ((symbol_info * info, bfd * abfd));

static void
print_symbol_info_posix PARAMS ((symbol_info * info, bfd * abfd));

static void
get_relocs PARAMS ((bfd *, asection *, PTR));
d112 1
a112 1
    void (*print_object_filename) PARAMS ((char *filename));
d115 1
a115 1
    void (*print_archive_filename) PARAMS ((char *filename));
d118 1
a118 1
    void (*print_archive_member) PARAMS ((char *archive, const char *filename));
d122 1
a122 1
    void (*print_symbol_filename) PARAMS ((bfd * archive_bfd, bfd * abfd));
d125 1
a125 1
    void (*print_symbol_info) PARAMS ((symbol_info * info, bfd * abfd));
d127 1
a155 1

d159 13
a171 13
static int external_only = 0;	/* print external symbols only */
static int defined_only = 0;	/* Print defined symbols only */
static int no_sort = 0;		/* don't sort; print syms in order found */
static int print_debug_syms = 0;	/* print debugger-only symbols too */
static int print_armap = 0;	/* describe __.SYMDEF data in archive files.  */
static int reverse_sort = 0;	/* sort in downward(alpha or numeric) order */
static int sort_numerically = 0;	/* sort in numeric rather than alpha order */
static int sort_by_size = 0;	/* sort by size of symbol */
static int undefined_only = 0;	/* print undefined symbols only */
static int dynamic = 0;		/* print dynamic symbols.  */
static int show_version = 0;	/* show the version number */
static int show_stats = 0;	/* show statistics */
static int line_numbers = 0;	/* print line numbers for symbols */
d232 1
a232 1
/* Some error-reporting functions */
a809 1

d1076 1
d1082 6
a1087 1
      print_symbol (abfd, sym, archive_bfd);
d1113 1
d1119 1
a1119 2
      /* Set the symbol value so that we actually display the symbol
         size.  */
d1122 7
a1128 1
      print_symbol (abfd, sym, archive_bfd);
d1135 1
a1135 1
print_symbol (abfd, sym, archive_bfd)
d1138 1
d1153 1
d1156 3
a1158 1
      (*format->print_symbol_info) (&syminfo, abfd);
a1200 1

d1444 1
a1444 1
     symbol_info *info;
d1447 1
a1447 1
  if (bfd_is_undefined_symclass (info->type))
d1454 13
a1466 3
    print_value (abfd, info->value);
  printf (" %c", info->type);
  if (info->type == '-')
d1470 1
a1470 1
      printf (other_format, info->stab_other);
d1472 2
a1473 2
      printf (desc_format, info->stab_desc);
      printf (" %5s", info->stab_name);
d1475 1
a1475 1
  print_symname (" %s", info->name, abfd);
d1480 1
a1480 1
     symbol_info *info;
d1483 4
a1486 3
  print_symname ("%-20s|", info->name, abfd);	/* Name */
  if (bfd_is_undefined_symclass (info->type))
    printf ("        ");	/* Value */
d1488 5
a1492 3
    print_value (abfd, info->value);
  printf ("|   %c  |", info->type);	/* Class */
  if (info->type == '-')
d1495 3
a1497 3
      printf ("%18s|  ", info->stab_name);	/* (C) Type */
      printf (desc_format, info->stab_desc);	/* Size */
      printf ("|     |");	/* Line, Section */
d1500 11
a1510 1
    printf ("                  |      |     |");	/* Type, Size, Line, Section */
d1515 1
a1515 1
     symbol_info *info;
d1518 4
a1521 3
  print_symname ("%s ", info->name, abfd);
  printf ("%c ", info->type);
  if (bfd_is_undefined_symclass (info->type))
d1524 6
a1529 4
    print_value (abfd, info->value);
  /* POSIX.2 wants the symbol size printed here, when applicable;
     BFD currently doesn't provide it, so we take the easy way out by
     considering it to never be applicable.  */
@


1.22
log
@When computing size of symbols for an ELF target use the internal size field.
@
text
@d136 1
a136 1
print_archive_member_bsd PARAMS ((char *archive, CONST char *filename));
d139 1
a139 1
print_archive_member_sysv PARAMS ((char *archive, CONST char *filename));
d142 1
a142 1
print_archive_member_posix PARAMS ((char *archive, CONST char *filename));
d180 1
a180 1
    void (*print_archive_member) PARAMS ((char *archive, CONST char *filename));
d1387 1
a1387 1
     CONST char *filename;
d1396 1
a1396 1
     CONST char *filename;
d1409 1
a1409 1
     CONST char *filename;
@


1.21
log
@	* filemode.c: Fix formatting.
	* ieee.c: Likewise.
	* is-ranlib.c: Likewise.
	* is-strip.c: Likewise.
	* maybe-ranlib.c: Likewise.
	* maybe-strip.c: Likewise.
	* nlmconv.c: Likewise.
	* nm.c: Likewise.
	* not-ranlib.c: Likewise.
	* not-strip.c: Likewise.
	* objcopy.c: Likewise.
	* objdump.c: Likewise.
@
text
@d3 1
a3 1
   2001
d31 1
d843 4
a846 4
/* Sort the symbols by size.  We guess the size by assuming that the
   difference between the address of a symbol and the address of the
   next higher symbol is the size.  FIXME: ELF actually stores a size
   with each symbol.  We should use it.  */
d908 3
a910 1
      if (bfd_is_com_section (sec))
@


1.20
log
@	* nm.c (print_symbol): Check returned filename from
	bfd_find_nearest_line is non-NULL.
@
text
@d444 1
a444 1
	      
d446 1
a446 1
	      if (style == unknown_demangling) 
d449 1
a449 1
	      
d451 1
a451 1
           }
d1038 1
a1038 1
      
d1147 1
a1147 1
static void 
@


1.19
log
@2002-01-29  Daniel Jacobowitz  <drow@@mvista.com>

        * nm.c (print_value): Mark abfd unused.
@
text
@d1294 2
a1295 1
						&functionname, &lineno))
@


1.19.2.1
log
@Merge from mainline
@
text
@d1294 1
a1294 2
						&functionname, &lineno)
		      && filename != NULL)
@


1.18
log
@Tidy up formatting of --help output.
@
text
@d1456 1
a1456 1
     bfd *abfd;
@


1.17
log
@	* addr2line.c (main): Protoype.
	* ar.c (main): Protoype.
	* nm.c (main): Protoype.
	* objcopy.c (main): Protoype.
	* objdump.c (main): Protoype.
	* size.c (main): Protoype.
	* strings.c (main): Protoype.
	* gasp.c (main): Protoype.
@
text
@d300 3
a302 3
  fprintf (stream, _("Usage: %s [OPTION]... [FILE]...\n"), program_name);
  fprintf (stream, _("List symbols from FILEs (a.out by default).\n"));
  fprintf (stream, _("\n\
a315 1
  -h, --help             Display this information\n\
d328 2
a330 1
  -X 32_64               (ignored)\n\
d424 1
a424 1
  while ((c = getopt_long (argc, argv, "aABCDef:glnopPrst:uvVX:",
d465 1
@


1.16
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d397 2
@


1.15
log
@2001-08-25  H.J. Lu  <hjl@@gnu.org>

	* nm.c (print_width): New.
	(display_rel_file): Set `print_width' according to
	bfd_sprintf_vma.
	(print_symbol_info_bsd): Check `print_width' instead of BFD64.
@
text
@d408 3
@


1.14
log
@2001-08-10  H.J. Lu  <hjl@@gnu.org>

	* nm.c (print_value): Add one arg, bfd *.
	(print_value): Replace fprintf_vma with bfd_fprintf_vma.
	(print_symbol_info_bsd): Also pass `abfd' to print_value ().
	(print_symbol_info_sysv): Likewise.
	(print_symbol_info_posix): Likewise.

	* objdump.c (dump_section_header): Replace printf_vma with
	bfd_printf_vma.
	(print_section_stabs): Likewise.
	(dump_bfd_header): Likewise.
	(objdump_print_value): Replace sprintf_vma with
	bfd_sprintf_vma.
	(disassemble_bytes): Likewise.
	(dump_reloc_set): Likewise.
@
text
@d248 5
d947 1
d968 3
d1487 2
a1488 3
#ifdef BFD64
      printf ("        ");
#endif
@


1.13
log
@	* MAINTAINERS: Update my email address
	* nm.c (print_symbol_info_bsd): Use a simple printf string.
@
text
@d155 1
a155 1
print_value PARAMS ((bfd_vma));
d1440 2
a1441 1
print_value (val)
d1449 1
a1449 1
    fprintf_vma (stdout, val);
d1484 1
a1484 1
    print_value (info->value);
d1507 1
a1507 1
    print_value (info->value);
d1530 1
a1530 1
    print_value (info->value);
@


1.12
log
@Fix typos in ChangeLogs and update copyright notices
@
text
@d1478 1
a1478 3
      printf ("%*s", 16, "");
#else
      printf ("%*s", 8, "");
d1480 1
@


1.11
log
@Don't #ifdef inside printf in case printf is a macro.
@
text
@d2 2
a3 1
   Copyright 1991, 92, 93, 94, 95, 96, 97, 98, 99, 2000, 2001
@


1.10
log
@* nm.c (main): Ignore '-X32_64' as an option.
* ar.c (main): Likewise.
* binutils.texi (nm): Document new option.
(ar): Likewise.
@
text
@d2 1
a2 1
   Copyright 1991, 92, 93, 94, 95, 96, 97, 98, 99, 2000
a1475 1
      printf ("%*s",
d1477 1
a1477 1
	      16,
d1479 1
a1479 1
	      8,
a1480 1
	      "");
@


1.10.2.1
log
@Don't #ifdef inside printf in case printf is a macro.
@
text
@d2 1
a2 1
   Copyright 1991, 92, 93, 94, 95, 96, 97, 98, 99, 2000, 2001
d1476 1
d1478 1
a1478 1
      printf ("%*s", 16, "");
d1480 1
a1480 1
      printf ("%*s", 8, "");
d1482 1
@


1.10.2.2
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999, 2000,
   2001
@


1.10.2.3
log
@Merge from mainline.
@
text
@d1478 3
a1480 1
      printf ("        ");
a1481 1
      printf ("        ");
@


1.9
log
@Add optional style argument to --demangle switch.
@
text
@d324 1
d413 1
a413 1
  while ((c = getopt_long (argc, argv, "aABCDef:glnopPrst:uvV",
d483 11
@


1.8
log
@Change output of `nm --help' to include a description of the purpose of the
program and a detailed description of the accepted options.
@
text
@d263 1
a263 1
  {"demangle", no_argument, &do_demangle, 1},
d300 3
a302 1
  -C, --demangle         Decode low-level symbol names into user-level names\n\
d412 2
a413 1
  while ((c = getopt_long (argc, argv, "aABCDef:glnopPrst:uvV", long_options, (int *) 0)) != EOF)
d429 11
@


1.7
log
@A mostly cosmetic tidy up of warnings and error message reporting.
@
text
@d294 29
a322 10
  fprintf (stream, _("\
Usage: %s [-aABCDglnopPrsuvV] [-t radix] [--radix=radix] [--target=bfdname]\n\
       [--debug-syms] [--extern-only] [--print-armap] [--print-file-name]\n\
       [--numeric-sort] [--no-sort] [--reverse-sort] [--size-sort]\n\
       [--undefined-only] [--portability] [-f {bsd,sysv,posix}]\n\
       [--format={bsd,sysv,posix}] [--demangle] [--no-demangle] [--dynamic]\n\
       [--defined-only] [--line-numbers]\n\
       [--version] [--help]\n\
       [file...]\n"),
	   program_name);
d325 1
a325 1
    fprintf (stream, _("Report bugs to %s\n"), REPORT_BUGS_TO);
@


1.6
log
@Move translated part of bug report string back into .c files so
xgettext can find it.  Regnerate .pot files.
@
text
@d2 1
a2 1
   Copyright 1991, 92, 93, 94, 95, 96, 97, 98, 1999
d339 1
a339 2
      fprintf (stderr, _("%s: %s: invalid radix\n"), program_name, radix);
      exit (1);
d364 1
a364 2
      fprintf (stderr, _("%s: %s: invalid output format\n"), program_name, f);
      exit (1);
d490 1
a490 2
      fprintf (stderr, _("%s: data size %ld\n"), program_name,
	       (long) (lim - (char *) &environ));
d901 1
a901 1
	  fprintf (stderr, _("%s: no symbols\n"), bfd_get_filename (abfd));
d912 1
a912 1
      fprintf (stderr, _("%s: no symbols\n"), bfd_get_filename (abfd));
@


1.5
log
@Move bug report string to one place.
@
text
@d306 1
a306 1
    fprintf (stream, REPORT_BUGS_TO);
@


1.4
log
@Apply patch from Thomas de Lellis to allow nm to distinguish between weak
function symbols and weak data symbols.
@
text
@d258 2
d280 1
a280 1
  {"target", required_argument, 0, 200},
d306 1
a306 1
    fprintf (stream, _("Report bugs to bug-gnu-utils@@gnu.org\n"));
d453 1
a453 1
	case 200:		/* --target */
@


1.4.2.1
log
@This is a grab-bag of my stuff from the head branch.
Should have done it separately, I know.
- move bug report address to include file
- objcopy --redefine-sym
- update makefile dependencies (but use automake-000227)
- H.J. Lu's fix to readelf.c
@
text
@a257 2
#define OPTION_TARGET 200

d278 1
a278 1
  {"target", required_argument, 0, OPTION_TARGET},
d304 1
a304 1
    fprintf (stream, _("Report bugs to %s\n"), REPORT_BUGS_TO);
d451 1
a451 1
	case OPTION_TARGET:	/* --target */
@


1.4.2.2
log
@A mostly cosmetic tidy up of warnings and error message reporting.
@
text
@d2 1
a2 1
   Copyright 1991, 92, 93, 94, 95, 96, 97, 98, 99, 2000
d339 2
a340 1
      fatal (_("%s: invalid radix"), radix);
d365 2
a366 1
      fatal (_("%s: invalid output format"), f);
d492 2
a493 1
      non_fatal (_("data size %ld"), (long) (lim - (char *) &environ));
d904 1
a904 1
	  non_fatal (_("%s: no symbols"), bfd_get_filename (abfd));
d915 1
a915 1
      non_fatal (_("%s: no symbols"), bfd_get_filename (abfd));
@


1.4.2.3
log
@Merge from mainline
@
text
@d294 10
a303 29
  fprintf (stream, _("Usage: %s [OPTION]... [FILE]...\n"), program_name);
  fprintf (stream, _("List symbols from FILEs (a.out by default).\n"));
  fprintf (stream, _("\n\
  -a, --debug-syms       Display debugger-only symbols\n\
  -A, --print-file-name  Print name of the input file before every symbol\n\
  -B                     Same as --format=bsd\n\
  -C, --demangle         Decode low-level symbol names into user-level names\n\
      --no-demangle      Do not demangle low-level symbol names\n\
  -D, --dynamic          Display dynamic symbols instead of normal symbols\n\
      --defined-only     Display only defined symbols\n\
  -e                     (ignored)\n\
  -f, --format=FORMAT    Use the output format FORMAT.  FORMAT can be `bsd',\n\
                           `sysv' or `posix'.  The default is `bsd'\n\
  -g, --extern-only      Display only external symbols\n\
  -h, --help             Display this information\n\
  -l, --line-numbers     Use debugging information to find a filename and\n\
                           line number for each symbol\n\
  -n, --numeric-sort     Sort symbols numerically by address\n\
  -o                     Same as -A\n\
  -p, --no-sort          Do not sort the symbols\n\
  -P, --portability      Same as --format=posix\n\
  -r, --reverse-sort     Reverse the sense of the sort\n\
  -s, --print-armap      Include index for symbols from archive members\n\
      --size-sort        Sort symbols by size\n\
  -t, --radix=RADIX      Use RADIX for printing symbol values\n\
      --target=BFDNAME   Specify the target object format as BFDNAME\n\
  -u, --undefined-only   Display only undefined symbols\n\
  -V, --version          Display this program's version number\n\
\n"));
d306 1
a306 1
    fprintf (stream, _("Report bugs to %s.\n"), REPORT_BUGS_TO);
@


1.3
log
@1999-09-06  Donn Terry  <donn@@interix.com>

	* nm.c (print_symbol_info_bsd): Check for 'w' as well as 'U'.
	(print_symbol_info_sysv): Likewise.
	(print_symbol_info_posix): Likewise.
@
text
@d1430 1
a1430 1
  if (info->type == 'U' || info->type == 'w')
d1461 1
a1461 1
  if (info->type == 'U' || info->type == 'w')
d1484 1
a1484 1
  if (info->type == 'U' || info->type == 'w')
@


1.2
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Add variable initializations.  Add casts.
	* objdump.c (disassemble_bytes): Change j to bfd_vma.
	* readelf.c (process_syminfo): Change i to unsigned int.
	(display_debug_info): Change abbrev_number to unsigned long.
	(process_mips_specific): Change fcnt to size_t.
@
text
@d1430 1
a1430 1
  if (info->type == 'U')
d1461 1
a1461 1
  if (info->type == 'U')
d1484 1
a1484 1
  if (info->type == 'U')
@


1.1
log
@Initial revision
@
text
@d1308 1
a1308 1
     char *filename;
d1314 1
a1314 1
     char *filename;
d1322 1
a1322 1
     char *archive;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

