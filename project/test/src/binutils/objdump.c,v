head	1.203;
access;
symbols
	binutils-2_24-branch:1.202.0.2
	binutils-2_24-branchpoint:1.202
	binutils-2_21_1:1.179.2.1
	binutils-2_23_2:1.195.2.1
	binutils-2_23_1:1.195.2.1
	binutils-2_23:1.195.2.1
	binutils-2_23-branch:1.195.0.2
	binutils-2_23-branchpoint:1.195
	binutils-2_22_branch:1.188.0.4
	binutils-2_22:1.188
	binutils-2_22-branch:1.188.0.2
	binutils-2_22-branchpoint:1.188
	binutils-2_21:1.179
	binutils-2_21-branch:1.179.0.2
	binutils-2_21-branchpoint:1.179
	binutils-2_20_1:1.163.2.3
	binutils-2_20:1.163.2.2
	binutils-arc-20081103-branch:1.146.0.6
	binutils-arc-20081103-branchpoint:1.146
	binutils-2_20-branch:1.163.0.2
	binutils-2_20-branchpoint:1.163
	dje-cgen-play1-branch:1.159.0.2
	dje-cgen-play1-branchpoint:1.159
	arc-20081103-branch:1.146.0.4
	arc-20081103-branchpoint:1.146
	binutils-2_19_1:1.146
	binutils-2_19:1.146
	binutils-2_19-branch:1.146.0.2
	binutils-2_19-branchpoint:1.146
	binutils-2_18:1.132
	binutils-2_18-branch:1.132.0.2
	binutils-2_18-branchpoint:1.132
	binutils-csl-coldfire-4_1-32:1.117.2.3
	binutils-csl-sourcerygxx-4_1-32:1.117.2.3
	binutils-csl-innovasic-fido-3_4_4-33:1.117.2.3
	binutils-csl-sourcerygxx-3_4_4-32:1.101.2.1.2.1
	binutils-csl-coldfire-4_1-30:1.117.2.3
	binutils-csl-sourcerygxx-4_1-30:1.117.2.3
	binutils-csl-coldfire-4_1-28:1.117.2.3
	binutils-csl-sourcerygxx-4_1-29:1.117.2.3
	binutils-csl-sourcerygxx-4_1-28:1.117.2.3
	binutils-csl-arm-2006q3-27:1.117.2.3
	binutils-csl-sourcerygxx-4_1-27:1.117.2.3
	binutils-csl-arm-2006q3-26:1.117.2.3
	binutils-csl-sourcerygxx-4_1-26:1.117.2.3
	binutils-csl-sourcerygxx-4_1-25:1.117.2.3
	binutils-csl-sourcerygxx-4_1-24:1.117.2.1
	binutils-csl-sourcerygxx-4_1-23:1.117.2.1
	binutils-csl-sourcerygxx-4_1-21:1.117.2.1
	binutils-csl-arm-2006q3-21:1.117.2.1
	binutils-csl-sourcerygxx-4_1-22:1.117.2.1
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.117.2.1
	binutils-csl-sourcerygxx-4_1-20:1.117.2.1
	binutils-csl-arm-2006q3-19:1.117.2.1
	binutils-csl-sourcerygxx-4_1-19:1.117.2.1
	binutils-csl-sourcerygxx-4_1-18:1.117.2.1
	binutils-csl-renesas-4_1-9:1.117.2.1
	binutils-csl-sourcerygxx-3_4_4-25:1.101.2.1.2.1
	binutils-csl-renesas-4_1-8:1.117
	binutils-csl-renesas-4_1-7:1.117
	binutils-csl-renesas-4_1-6:1.117
	binutils-csl-sourcerygxx-4_1-17:1.117
	binutils-csl-sourcerygxx-4_1-14:1.117
	binutils-csl-sourcerygxx-4_1-15:1.117
	binutils-csl-sourcerygxx-4_1-13:1.117
	binutils-2_17:1.118
	binutils-csl-sourcerygxx-4_1-12:1.117
	binutils-csl-sourcerygxx-3_4_4-21:1.117
	binutils-csl-wrs-linux-3_4_4-24:1.101
	binutils-csl-wrs-linux-3_4_4-23:1.101
	binutils-csl-sourcerygxx-4_1-9:1.117
	binutils-csl-sourcerygxx-4_1-8:1.117
	binutils-csl-sourcerygxx-4_1-7:1.117
	binutils-csl-arm-2006q1-6:1.117
	binutils-csl-sourcerygxx-4_1-6:1.117
	binutils-csl-wrs-linux-3_4_4-22:1.101
	binutils-csl-coldfire-4_1-11:1.117
	binutils-csl-sourcerygxx-3_4_4-19:1.117
	binutils-csl-coldfire-4_1-10:1.117
	binutils-csl-sourcerygxx-4_1-5:1.117
	binutils-csl-sourcerygxx-4_1-4:1.117
	binutils-csl-wrs-linux-3_4_4-21:1.101
	binutils-csl-morpho-4_1-4:1.117
	binutils-csl-sourcerygxx-3_4_4-17:1.117
	binutils-csl-wrs-linux-3_4_4-20:1.101
	binutils-2_17-branch:1.118.0.2
	binutils-2_17-branchpoint:1.118
	binutils-csl-2_17-branch:1.117.0.2
	binutils-csl-2_17-branchpoint:1.117
	binutils-csl-gxxpro-3_4-branch:1.101.2.1.0.2
	binutils-csl-gxxpro-3_4-branchpoint:1.101.2.1
	binutils-2_16_1:1.101.2.1
	binutils-csl-arm-2005q1b:1.101
	binutils-2_16:1.101.2.1
	binutils-csl-arm-2005q1a:1.101
	binutils-csl-arm-2005q1-branch:1.101.0.4
	binutils-csl-arm-2005q1-branchpoint:1.101
	binutils-2_16-branch:1.101.0.2
	binutils-2_16-branchpoint:1.101
	csl-arm-2004-q3d:1.96
	csl-arm-2004-q3:1.94
	binutils-2_15:1.86
	binutils-2_15-branchpoint:1.86
	csl-arm-2004-q1a:1.89
	csl-arm-2004-q1:1.87
	binutils-2_15-branch:1.86.0.6
	cagney_bfdfile-20040213-branch:1.86.0.4
	cagney_bfdfile-20040213-branchpoint:1.86
	cagney_bigcore-20040122-branch:1.86.0.2
	cagney_bigcore-20040122-branchpoint:1.86
	csl-arm-2003-q4:1.86
	binutils-2_14:1.65
	binutils-2_14-branch:1.65.0.2
	binutils-2_14-branchpoint:1.65
	binutils-2_13_2_1:1.54.2.1
	binutils-2_13_2:1.54.2.1
	binutils-2_13_1:1.54.2.1
	binutils-2_13:1.54
	binutils-2_13-branchpoint:1.54
	binutils-2_13-branch:1.54.0.2
	binutils-2_12_1:1.48
	binutils-2_12:1.48
	binutils-2_12-branch:1.48.0.2
	binutils-2_12-branchpoint:1.48
	cygnus_cvs_20020108_pre:1.46
	binutils-2_11_2:1.32.2.2
	binutils-2_11_1:1.32.2.2
	binutils-2_11:1.32
	x86_64versiong3:1.33
	binutils-2_11-branch:1.32.0.2
	binutils-2_10_1:1.18.2.7
	binutils-2_10:1.18.2.6
	binutils-2_10-branch:1.18.0.2
	binutils-2_10-branchpoint:1.18
	binutils_latest_snapshot:1.203
	repo-unification-2000-02-06:1.16
	binu_ss_19990721:1.7
	binu_ss_19990602:1.3
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.203
date	2013.10.09.16.17.23;	author nickc;	state Exp;
branches;
next	1.202;

1.202
date	2013.08.12.07.55.55;	author schwab;	state Exp;
branches;
next	1.201;

1.201
date	2013.01.17.02.24.47;	author amodra;	state Exp;
branches;
next	1.200;

1.200
date	2012.10.24.01.59.39;	author ccoutant;	state Exp;
branches;
next	1.199;

1.199
date	2012.10.21.10.56.00;	author hjl;	state Exp;
branches;
next	1.198;

1.198
date	2012.10.21.09.06.07;	author amodra;	state Exp;
branches;
next	1.197;

1.197
date	2012.10.18.17.42.24;	author ktietz;	state Exp;
branches;
next	1.196;

1.196
date	2012.08.17.02.43.21;	author amodra;	state Exp;
branches;
next	1.195;

1.195
date	2012.07.24.21.06.56;	author ccoutant;	state Exp;
branches
	1.195.2.1;
next	1.194;

1.194
date	2012.05.14.02.39.57;	author hjl;	state Exp;
branches;
next	1.193;

1.193
date	2012.05.11.18.18.34;	author ccoutant;	state Exp;
branches;
next	1.192;

1.192
date	2012.04.11.14.05.30;	author nickc;	state Exp;
branches;
next	1.191;

1.191
date	2012.02.20.03.25.21;	author amodra;	state Exp;
branches;
next	1.190;

1.190
date	2012.02.09.04.51.43;	author amodra;	state Exp;
branches;
next	1.189;

1.189
date	2012.01.10.11.52.27;	author gingold;	state Exp;
branches;
next	1.188;

1.188
date	2011.05.16.12.22.12;	author gingold;	state Exp;
branches;
next	1.187;

1.187
date	2011.04.28.17.23.15;	author tromey;	state Exp;
branches;
next	1.186;

1.186
date	2011.04.04.00.34.26;	author davem;	state Exp;
branches;
next	1.185;

1.185
date	2011.03.25.17.49.32;	author nickc;	state Exp;
branches;
next	1.184;

1.184
date	2011.03.03.09.38.36;	author vapier;	state Exp;
branches;
next	1.183;

1.183
date	2011.02.28.18.32.51;	author ktietz;	state Exp;
branches;
next	1.182;

1.182
date	2010.12.03.17.07.19;	author devans;	state Exp;
branches;
next	1.181;

1.181
date	2010.11.21.21.27.15;	author hjl;	state Exp;
branches;
next	1.180;

1.180
date	2010.11.17.03.35.50;	author amodra;	state Exp;
branches;
next	1.179;

1.179
date	2010.11.03.02.31.02;	author hjl;	state Exp;
branches
	1.179.2.1;
next	1.178;

1.178
date	2010.10.29.12.10.31;	author hjl;	state Exp;
branches;
next	1.177;

1.177
date	2010.10.05.05.48.10;	author amodra;	state Exp;
branches;
next	1.176;

1.176
date	2010.09.02.22.35.18;	author rth;	state Exp;
branches;
next	1.175;

1.175
date	2010.09.02.21.34.22;	author rth;	state Exp;
branches;
next	1.174;

1.174
date	2010.07.03.20.52.23;	author ccoutant;	state Exp;
branches;
next	1.173;

1.173
date	2010.05.24.13.21.23;	author gingold;	state Exp;
branches;
next	1.172;

1.172
date	2010.04.09.14.40.13;	author nickc;	state Exp;
branches;
next	1.171;

1.171
date	2010.02.08.14.33.22;	author nickc;	state Exp;
branches;
next	1.170;

1.170
date	2010.01.28.15.25.20;	author nickc;	state Exp;
branches;
next	1.169;

1.169
date	2010.01.13.11.15.52;	author gingold;	state Exp;
branches;
next	1.168;

1.168
date	2009.12.11.13.42.06;	author nickc;	state Exp;
branches;
next	1.167;

1.167
date	2009.12.03.12.28.36;	author nickc;	state Exp;
branches;
next	1.166;

1.166
date	2009.10.16.10.05.06;	author nickc;	state Exp;
branches;
next	1.165;

1.165
date	2009.09.22.18.29.06;	author rsandifo;	state Exp;
branches;
next	1.164;

1.164
date	2009.09.10.13.40.44;	author nickc;	state Exp;
branches;
next	1.163;

1.163
date	2009.08.24.18.43.50;	author ccoutant;	state Exp;
branches
	1.163.2.1;
next	1.162;

1.162
date	2009.07.27.17.08.03;	author nickc;	state Exp;
branches;
next	1.161;

1.161
date	2009.07.20.13.40.48;	author hjl;	state Exp;
branches;
next	1.160;

1.160
date	2009.07.06.14.45.56;	author gingold;	state Exp;
branches;
next	1.159;

1.159
date	2009.06.18.10.31.21;	author nickc;	state Exp;
branches;
next	1.158;

1.158
date	2009.06.15.11.37.26;	author nickc;	state Exp;
branches;
next	1.157;

1.157
date	2009.03.05.16.31.50;	author nickc;	state Exp;
branches;
next	1.156;

1.156
date	2009.03.03.01.27.15;	author amodra;	state Exp;
branches;
next	1.155;

1.155
date	2009.02.23.19.44.58;	author ccoutant;	state Exp;
branches;
next	1.154;

1.154
date	2009.02.09.09.14.15;	author gingold;	state Exp;
branches;
next	1.153;

1.153
date	2009.02.03.15.48.49;	author hjl;	state Exp;
branches;
next	1.152;

1.152
date	2009.01.27.15.41.56;	author nickc;	state Exp;
branches;
next	1.151;

1.151
date	2009.01.14.01.26.18;	author amodra;	state Exp;
branches;
next	1.150;

1.150
date	2008.12.23.09.01.46;	author nickc;	state Exp;
branches;
next	1.149;

1.149
date	2008.12.04.08.04.47;	author nickc;	state Exp;
branches;
next	1.148;

1.148
date	2008.11.14.14.56.51;	author gingold;	state Exp;
branches;
next	1.147;

1.147
date	2008.11.10.08.45.13;	author amodra;	state Exp;
branches;
next	1.146;

1.146
date	2008.08.28.16.05.03;	author gingold;	state Exp;
branches;
next	1.145;

1.145
date	2008.07.30.04.34.56;	author amodra;	state Exp;
branches;
next	1.144;

1.144
date	2008.07.15.18.48.34;	author hjl;	state Exp;
branches;
next	1.143;

1.143
date	2008.07.10.01.32.23;	author csilvers;	state Exp;
branches;
next	1.142;

1.142
date	2008.07.07.04.37.53;	author amodra;	state Exp;
branches;
next	1.141;

1.141
date	2008.06.12.11.57.40;	author nickc;	state Exp;
branches;
next	1.140;

1.140
date	2008.04.28.08.30.23;	author nickc;	state Exp;
branches;
next	1.139;

1.139
date	2008.03.01.07.19.06;	author amodra;	state Exp;
branches;
next	1.138;

1.138
date	2008.02.26.08.44.10;	author nickc;	state Exp;
branches;
next	1.137;

1.137
date	2008.02.22.09.42.58;	author nickc;	state Exp;
branches;
next	1.136;

1.136
date	2008.02.07.08.39.54;	author amodra;	state Exp;
branches;
next	1.135;

1.135
date	2008.01.28.15.15.32;	author hjl;	state Exp;
branches;
next	1.134;

1.134
date	2007.10.31.16.09.52;	author nickc;	state Exp;
branches;
next	1.133;

1.133
date	2007.10.15.02.00.56;	author amodra;	state Exp;
branches;
next	1.132;

1.132
date	2007.07.10.13.52.39;	author amodra;	state Exp;
branches;
next	1.131;

1.131
date	2007.07.05.16.54.45;	author nickc;	state Exp;
branches;
next	1.130;

1.130
date	2007.06.19.21.08.17;	author dannysmith;	state Exp;
branches;
next	1.129;

1.129
date	2007.06.18.16.38.49;	author nickc;	state Exp;
branches;
next	1.128;

1.128
date	2007.05.22.15.05.10;	author pbrook;	state Exp;
branches;
next	1.127;

1.127
date	2007.05.21.06.36.01;	author rsandifo;	state Exp;
branches;
next	1.126;

1.126
date	2007.05.17.08.39.22;	author nickc;	state Exp;
branches;
next	1.125;

1.125
date	2007.04.26.14.46.59;	author amodra;	state Exp;
branches;
next	1.124;

1.124
date	2007.04.19.10.43.47;	author amodra;	state Exp;
branches;
next	1.123;

1.123
date	2007.03.15.14.17.16;	author hjl;	state Exp;
branches;
next	1.122;

1.122
date	2007.02.17.13.33.54;	author jsm28;	state Exp;
branches;
next	1.121;

1.121
date	2006.10.31.20.21.56;	author pbrook;	state Exp;
branches;
next	1.120;

1.120
date	2006.09.16.18.12.17;	author nickc;	state Exp;
branches;
next	1.119;

1.119
date	2006.08.06.15.49.46;	author nickc;	state Exp;
branches;
next	1.118;

1.118
date	2006.04.12.13.05.36;	author nickc;	state Exp;
branches;
next	1.117;

1.117
date	2006.02.09.11.49.53;	author ebotcazou;	state Exp;
branches
	1.117.2.1;
next	1.116;

1.116
date	2006.01.17.17.39.20;	author schwab;	state Exp;
branches;
next	1.115;

1.115
date	2005.10.03.19.37.44;	author mmitchel;	state Exp;
branches;
next	1.114;

1.114
date	2005.09.30.16.37.31;	author mmitchel;	state Exp;
branches;
next	1.113;

1.113
date	2005.09.30.14.57.52;	author hjl;	state Exp;
branches;
next	1.112;

1.112
date	2005.09.30.14.56.34;	author hjl;	state Exp;
branches;
next	1.111;

1.111
date	2005.08.17.14.28.01;	author hjl;	state Exp;
branches;
next	1.110;

1.110
date	2005.07.07.19.27.33;	author wilson;	state Exp;
branches;
next	1.109;

1.109
date	2005.07.01.15.19.47;	author sje;	state Exp;
branches;
next	1.108;

1.108
date	2005.06.09.14.51.41;	author jakub;	state Exp;
branches;
next	1.107;

1.107
date	2005.05.08.14.17.38;	author nickc;	state Exp;
branches;
next	1.106;

1.106
date	2005.04.19.21.29.46;	author hjl;	state Exp;
branches;
next	1.105;

1.105
date	2005.04.17.14.33.06;	author hjl;	state Exp;
branches;
next	1.104;

1.104
date	2005.04.04.10.32.28;	author nickc;	state Exp;
branches;
next	1.103;

1.103
date	2005.03.28.12.28.17;	author aaronwl;	state Exp;
branches;
next	1.102;

1.102
date	2005.03.18.16.28.13;	author pbrook;	state Exp;
branches;
next	1.101;

1.101
date	2005.03.01.15.18.42;	author nickc;	state Exp;
branches
	1.101.2.1;
next	1.100;

1.100
date	2005.02.23.12.25.57;	author amodra;	state Exp;
branches;
next	1.99;

1.99
date	2005.02.22.00.50.06;	author hjl;	state Exp;
branches;
next	1.98;

1.98
date	2005.01.10.09.54.50;	author schwab;	state Exp;
branches;
next	1.97;

1.97
date	2004.12.30.22.33.20;	author amodra;	state Exp;
branches;
next	1.96;

1.96
date	2004.10.11.08.18.43;	author amodra;	state Exp;
branches;
next	1.95;

1.95
date	2004.10.08.14.54.03;	author nickc;	state Exp;
branches;
next	1.94;

1.94
date	2004.08.28.03.05.18;	author amodra;	state Exp;
branches;
next	1.93;

1.93
date	2004.08.17.09.07.35;	author jakub;	state Exp;
branches;
next	1.92;

1.92
date	2004.07.22.16.52.43;	author nickc;	state Exp;
branches;
next	1.91;

1.91
date	2004.07.21.15.42.58;	author hjl;	state Exp;
branches;
next	1.90;

1.90
date	2004.06.15.01.19.13;	author amodra;	state Exp;
branches;
next	1.89;

1.89
date	2004.04.24.12.39.47;	author amodra;	state Exp;
branches;
next	1.88;

1.88
date	2004.04.22.14.45.32;	author jakub;	state Exp;
branches;
next	1.87;

1.87
date	2004.03.15.12.31.41;	author nathan;	state Exp;
branches;
next	1.86;

1.86
date	2003.12.22.10.49.59;	author jakub;	state Exp;
branches;
next	1.85;

1.85
date	2003.12.06.00.06.12;	author kazu;	state Exp;
branches;
next	1.84;

1.84
date	2003.11.19.08.21.14;	author amodra;	state Exp;
branches;
next	1.83;

1.83
date	2003.11.14.15.12.42;	author nickc;	state Exp;
branches;
next	1.82;

1.82
date	2003.11.11.01.57.04;	author amodra;	state Exp;
branches;
next	1.81;

1.81
date	2003.11.10.17.28.33;	author nickc;	state Exp;
branches;
next	1.80;

1.80
date	2003.11.07.12.19.34;	author nickc;	state Exp;
branches;
next	1.79;

1.79
date	2003.10.27.13.20.32;	author kazu;	state Exp;
branches;
next	1.78;

1.78
date	2003.10.07.08.53.42;	author nathan;	state Exp;
branches;
next	1.77;

1.77
date	2003.09.03.23.43.18;	author cagney;	state Exp;
branches;
next	1.76;

1.76
date	2003.09.03.08.26.47;	author nickc;	state Exp;
branches;
next	1.75;

1.75
date	2003.08.05.14.40.54;	author amodra;	state Exp;
branches;
next	1.74;

1.74
date	2003.08.04.14.29.34;	author amodra;	state Exp;
branches;
next	1.73;

1.73
date	2003.07.30.03.54.15;	author amodra;	state Exp;
branches;
next	1.72;

1.72
date	2003.07.29.15.40.37;	author nickc;	state Exp;
branches;
next	1.71;

1.71
date	2003.07.24.14.06.07;	author nickc;	state Exp;
branches;
next	1.70;

1.70
date	2003.07.22.13.33.32;	author nickc;	state Exp;
branches;
next	1.69;

1.69
date	2003.07.18.11.34.41;	author nickc;	state Exp;
branches;
next	1.68;

1.68
date	2003.07.17.17.02.46;	author nickc;	state Exp;
branches;
next	1.67;

1.67
date	2003.06.25.06.40.25;	author amodra;	state Exp;
branches;
next	1.66;

1.66
date	2003.05.01.00.40.41;	author hjl;	state Exp;
branches;
next	1.65;

1.65
date	2003.04.01.00.32.47;	author aoliva;	state Exp;
branches;
next	1.64;

1.64
date	2003.03.24.11.28.35;	author nickc;	state Exp;
branches;
next	1.63;

1.63
date	2003.03.17.11.16.51;	author nickc;	state Exp;
branches;
next	1.62;

1.62
date	2003.02.13.09.53.07;	author nickc;	state Exp;
branches;
next	1.61;

1.61
date	2002.11.30.08.39.41;	author amodra;	state Exp;
branches;
next	1.60;

1.60
date	2002.10.21.02.18.58;	author amodra;	state Exp;
branches;
next	1.59;

1.59
date	2002.10.14.12.07.58;	author amodra;	state Exp;
branches;
next	1.58;

1.58
date	2002.08.28.12.32.06;	author amodra;	state Exp;
branches;
next	1.57;

1.57
date	2002.08.28.10.38.45;	author nickc;	state Exp;
branches;
next	1.56;

1.56
date	2002.08.26.10.14.15;	author amodra;	state Exp;
branches;
next	1.55;

1.55
date	2002.08.14.15.12.07;	author nickc;	state Exp;
branches;
next	1.54;

1.54
date	2002.07.02.04.21.24;	author amodra;	state Exp;
branches
	1.54.2.1;
next	1.53;

1.53
date	2002.06.08.07.38.30;	author amodra;	state Exp;
branches;
next	1.52;

1.52
date	2002.06.03.13.02.04;	author amodra;	state Exp;
branches;
next	1.51;

1.51
date	2002.05.23.13.12.42;	author jakub;	state Exp;
branches;
next	1.50;

1.50
date	2002.05.21.19.34.58;	author kazu;	state Exp;
branches;
next	1.49;

1.49
date	2002.05.21.16.21.18;	author ths;	state Exp;
branches;
next	1.48;

1.48
date	2002.01.29.16.46.36;	author drow;	state Exp;
branches;
next	1.47;

1.47
date	2002.01.23.16.12.55;	author nickc;	state Exp;
branches;
next	1.46;

1.46
date	2001.12.18.08.22.30;	author ths;	state Exp;
branches;
next	1.45;

1.45
date	2001.10.02.06.02.12;	author amodra;	state Exp;
branches;
next	1.44;

1.44
date	2001.09.28.21.10.41;	author rth;	state Exp;
branches;
next	1.43;

1.43
date	2001.09.26.01.55.19;	author amodra;	state Exp;
branches;
next	1.42;

1.42
date	2001.09.19.05.33.16;	author hjl;	state Exp;
branches;
next	1.41;

1.41
date	2001.09.18.10.05.55;	author amodra;	state Exp;
branches;
next	1.40;

1.40
date	2001.08.10.16.43.18;	author hjl;	state Exp;
branches;
next	1.39;

1.39
date	2001.08.09.14.46.50;	author amodra;	state Exp;
branches;
next	1.38;

1.38
date	2001.08.03.22.08.44;	author jhealy;	state Exp;
branches;
next	1.37;

1.37
date	2001.07.29.05.31.43;	author amodra;	state Exp;
branches;
next	1.36;

1.36
date	2001.07.25.15.25.11;	author brolley;	state Exp;
branches;
next	1.35;

1.35
date	2001.05.28.10.03.19;	author nickc;	state Exp;
branches;
next	1.34;

1.34
date	2001.03.13.06.43.57;	author nickc;	state Exp;
branches;
next	1.33;

1.33
date	2001.02.07.23.16.22;	author nickc;	state Exp;
branches;
next	1.32;

1.32
date	2001.01.09.20.25.31;	author nickc;	state Exp;
branches
	1.32.2.1;
next	1.31;

1.31
date	2000.08.18.01.58.12;	author hjl;	state Exp;
branches;
next	1.30;

1.30
date	2000.07.20.18.02.55;	author nickc;	state Exp;
branches;
next	1.29;

1.29
date	2000.07.12.19.52.17;	author kettenis;	state Exp;
branches;
next	1.28;

1.28
date	2000.06.24.19.53.12;	author nickc;	state Exp;
branches;
next	1.27;

1.27
date	2000.05.30.07.47.56;	author amodra;	state Exp;
branches;
next	1.26;

1.26
date	2000.05.25.02.05.08;	author amodra;	state Exp;
branches;
next	1.25;

1.25
date	2000.05.13.06.38.34;	author hjl;	state Exp;
branches;
next	1.24;

1.24
date	2000.04.18.17.16.59;	author twall;	state Exp;
branches;
next	1.23;

1.23
date	2000.04.14.04.14.24;	author amodra;	state Exp;
branches;
next	1.22;

1.22
date	2000.04.07.04.34.50;	author amodra;	state Exp;
branches;
next	1.21;

1.21
date	2000.04.07.00.58.07;	author twall;	state Exp;
branches;
next	1.20;

1.20
date	2000.04.04.14.32.29;	author amodra;	state Exp;
branches;
next	1.19;

1.19
date	2000.04.03.14.10.03;	author amodra;	state Exp;
branches;
next	1.18;

1.18
date	2000.02.21.12.01.27;	author amodra;	state Exp;
branches
	1.18.2.1;
next	1.17;

1.17
date	2000.02.08.18.38.13;	author twall;	state Exp;
branches;
next	1.16;

1.16
date	2000.02.03.18.12.55;	author twall;	state Exp;
branches;
next	1.15;

1.15
date	2000.01.27.21.44.26;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	99.11.21.11.37.21;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	99.10.28.03.30.13;	author ian;	state Exp;
branches;
next	1.12;

1.12
date	99.09.19.22.39.49;	author ian;	state Exp;
branches;
next	1.11;

1.11
date	99.09.12.18.49.47;	author ian;	state Exp;
branches;
next	1.10;

1.10
date	99.09.12.18.39.32;	author ian;	state Exp;
branches;
next	1.9;

1.9
date	99.08.09.05.23.29;	author ian;	state Exp;
branches;
next	1.8;

1.8
date	99.08.09.03.23.37;	author ian;	state Exp;
branches;
next	1.7;

1.7
date	99.07.14.17.24.46;	author rth;	state Exp;
branches;
next	1.6;

1.6
date	99.07.11.20.02.23;	author ian;	state Exp;
branches;
next	1.5;

1.5
date	99.06.16.02.24.33;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	99.06.13.19.02.25;	author ian;	state Exp;
branches;
next	1.3;

1.3
date	99.05.11.21.06.14;	author dj;	state Exp;
branches;
next	1.2;

1.2
date	99.05.06.07.41.56;	author nickc;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.29.10;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.195.2.1
date	2012.10.22.12.01.39;	author gingold;	state Exp;
branches;
next	;

1.179.2.1
date	2011.02.01.12.25.36;	author amodra;	state Exp;
branches;
next	;

1.163.2.1
date	2009.09.10.13.42.09;	author nickc;	state Exp;
branches;
next	1.163.2.2;

1.163.2.2
date	2009.09.22.18.30.46;	author rsandifo;	state Exp;
branches;
next	1.163.2.3;

1.163.2.3
date	2010.02.11.14.34.42;	author clyon;	state Exp;
branches;
next	;

1.117.2.1
date	2006.08.22.15.08.29;	author jsm28;	state Exp;
branches;
next	1.117.2.2;

1.117.2.2
date	2006.10.16.20.21.23;	author nathan;	state Exp;
branches;
next	1.117.2.3;

1.117.2.3
date	2006.10.26.19.41.53;	author pbrook;	state Exp;
branches;
next	;

1.101.2.1
date	2005.04.04.14.43.58;	author nickc;	state Exp;
branches
	1.101.2.1.2.1;
next	;

1.101.2.1.2.1
date	2005.08.30.19.57.32;	author mmitchel;	state Exp;
branches;
next	;

1.54.2.1
date	2002.10.21.02.23.25;	author amodra;	state Exp;
branches;
next	;

1.32.2.1
date	2001.06.07.03.12.27;	author amodra;	state Exp;
branches;
next	1.32.2.2;

1.32.2.2
date	2001.06.11.10.04.27;	author amodra;	state Exp;
branches;
next	;

1.18.2.1
date	2000.04.05.05.36.40;	author amodra;	state Exp;
branches;
next	1.18.2.2;

1.18.2.2
date	2000.04.07.04.39.24;	author amodra;	state Exp;
branches;
next	1.18.2.3;

1.18.2.3
date	2000.04.22.20.08.12;	author twall;	state Exp;
branches;
next	1.18.2.4;

1.18.2.4
date	2000.05.23.07.57.58;	author pb;	state Exp;
branches;
next	1.18.2.5;

1.18.2.5
date	2000.05.25.03.13.39;	author amodra;	state Exp;
branches;
next	1.18.2.6;

1.18.2.6
date	2000.05.30.07.51.02;	author amodra;	state Exp;
branches;
next	1.18.2.7;

1.18.2.7
date	2000.10.14.18.34.28;	author pb;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.10;	author rth;	state Exp;
branches;
next	;


desc
@@


1.203
log
@	PR binutils/16024
	* objdump.c (usage): Mark as a no-return function.
	(main): Add comment explaining why a break statement is not
	needed.
@
text
@/* objdump.c -- dump information about an object file.
   Copyright 1990-2013 Free Software Foundation, Inc.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */


/* Objdump overview.

   Objdump displays information about one or more object files, either on
   their own, or inside libraries.  It is commonly used as a disassembler,
   but it can also display information about file headers, symbol tables,
   relocations, debugging directives and more.

   The flow of execution is as follows:
 
   1. Command line arguments are checked for control switches and the
      information to be displayed is selected.
      
   2. Any remaining arguments are assumed to be object files, and they are
      processed in order by display_bfd().  If the file is an archive each
      of its elements is processed in turn.
      
   3. The file's target architecture and binary file format are determined
      by bfd_check_format().  If they are recognised, then dump_bfd() is
      called.

   4. dump_bfd() in turn calls separate functions to display the requested
      item(s) of information(s).  For example disassemble_data() is called if
      a disassembly has been requested.

   When disassembling the code loops through blocks of instructions bounded
   by symbols, calling disassemble_bytes() on each block.  The actual
   disassembling is done by the libopcodes library, via a function pointer
   supplied by the disassembler() function.  */

#include "sysdep.h"
#include "bfd.h"
#include "elf-bfd.h"
#include "progress.h"
#include "bucomm.h"
#include "elfcomm.h"
#include "dwarf.h"
#include "getopt.h"
#include "safe-ctype.h"
#include "dis-asm.h"
#include "libiberty.h"
#include "demangle.h"
#include "filenames.h"
#include "debug.h"
#include "budbg.h"
#include "objdump.h"

#ifdef HAVE_MMAP
#include <sys/mman.h>
#endif

/* Internal headers for the ELF .stab-dump code - sorry.  */
#define	BYTES_IN_WORD	32
#include "aout/aout64.h"

/* Exit status.  */
static int exit_status = 0;

static char *default_target = NULL;	/* Default at runtime.  */

/* The following variables are set based on arguments passed on the
   command line.  */
static int show_version = 0;		/* Show the version number.  */
static int dump_section_contents;	/* -s */
static int dump_section_headers;	/* -h */
static bfd_boolean dump_file_header;	/* -f */
static int dump_symtab;			/* -t */
static int dump_dynamic_symtab;		/* -T */
static int dump_reloc_info;		/* -r */
static int dump_dynamic_reloc_info;	/* -R */
static int dump_ar_hdrs;		/* -a */
static int dump_private_headers;	/* -p */
static char *dump_private_options;	/* -P */
static int prefix_addresses;		/* --prefix-addresses */
static int with_line_numbers;		/* -l */
static bfd_boolean with_source_code;	/* -S */
static int show_raw_insn;		/* --show-raw-insn */
static int dump_dwarf_section_info;	/* --dwarf */
static int dump_stab_section_info;	/* --stabs */
static int do_demangle;			/* -C, --demangle */
static bfd_boolean disassemble;		/* -d */
static bfd_boolean disassemble_all;	/* -D */
static int disassemble_zeroes;		/* --disassemble-zeroes */
static bfd_boolean formats_info;	/* -i */
static int wide_output;			/* -w */
static int insn_width;			/* --insn-width */
static bfd_vma start_address = (bfd_vma) -1; /* --start-address */
static bfd_vma stop_address = (bfd_vma) -1;  /* --stop-address */
static int dump_debugging;		/* --debugging */
static int dump_debugging_tags;		/* --debugging-tags */
static int suppress_bfd_header;
static int dump_special_syms = 0;	/* --special-syms */
static bfd_vma adjust_section_vma = 0;	/* --adjust-vma */
static int file_start_context = 0;      /* --file-start-context */
static bfd_boolean display_file_offsets;/* -F */
static const char *prefix;		/* --prefix */
static int prefix_strip;		/* --prefix-strip */
static size_t prefix_length;

/* A structure to record the sections mentioned in -j switches.  */
struct only
{
  const char * name; /* The name of the section.  */
  bfd_boolean  seen; /* A flag to indicate that the section has been found in one or more input files.  */
  struct only * next; /* Pointer to the next structure in the list.  */
};
/* Pointer to an array of 'only' structures.
   This pointer is NULL if the -j switch has not been used.  */
static struct only * only_list = NULL;

/* Variables for handling include file path table.  */
static const char **include_paths;
static int include_path_count;

/* Extra info to pass to the section disassembler and address printing
   function.  */
struct objdump_disasm_info
{
  bfd *              abfd;
  asection *         sec;
  bfd_boolean        require_sec;
  arelent **         dynrelbuf;
  long               dynrelcount;
  disassembler_ftype disassemble_fn;
  arelent *          reloc;
};

/* Architecture to disassemble for, or default if NULL.  */
static char *machine = NULL;

/* Target specific options to the disassembler.  */
static char *disassembler_options = NULL;

/* Endianness to disassemble for, or default if BFD_ENDIAN_UNKNOWN.  */
static enum bfd_endian endian = BFD_ENDIAN_UNKNOWN;

/* The symbol table.  */
static asymbol **syms;

/* Number of symbols in `syms'.  */
static long symcount = 0;

/* The sorted symbol table.  */
static asymbol **sorted_syms;

/* Number of symbols in `sorted_syms'.  */
static long sorted_symcount = 0;

/* The dynamic symbol table.  */
static asymbol **dynsyms;

/* The synthetic symbol table.  */
static asymbol *synthsyms;
static long synthcount = 0;

/* Number of symbols in `dynsyms'.  */
static long dynsymcount = 0;

static bfd_byte *stabs;
static bfd_size_type stab_size;

static char *strtab;
static bfd_size_type stabstr_size;

static bfd_boolean is_relocatable = FALSE;

/* Handlers for -P/--private.  */
static const struct objdump_private_desc * const objdump_private_vectors[] =
  {
    OBJDUMP_PRIVATE_VECTORS
    NULL
  };

static void usage (FILE *, int) ATTRIBUTE_NORETURN;
static void
usage (FILE *stream, int status)
{
  fprintf (stream, _("Usage: %s <option(s)> <file(s)>\n"), program_name);
  fprintf (stream, _(" Display information from object <file(s)>.\n"));
  fprintf (stream, _(" At least one of the following switches must be given:\n"));
  fprintf (stream, _("\
  -a, --archive-headers    Display archive header information\n\
  -f, --file-headers       Display the contents of the overall file header\n\
  -p, --private-headers    Display object format specific file header contents\n\
  -P, --private=OPT,OPT... Display object format specific contents\n\
  -h, --[section-]headers  Display the contents of the section headers\n\
  -x, --all-headers        Display the contents of all headers\n\
  -d, --disassemble        Display assembler contents of executable sections\n\
  -D, --disassemble-all    Display assembler contents of all sections\n\
  -S, --source             Intermix source code with disassembly\n\
  -s, --full-contents      Display the full contents of all sections requested\n\
  -g, --debugging          Display debug information in object file\n\
  -e, --debugging-tags     Display debug information using ctags style\n\
  -G, --stabs              Display (in raw form) any STABS info in the file\n\
  -W[lLiaprmfFsoRt] or\n\
  --dwarf[=rawline,=decodedline,=info,=abbrev,=pubnames,=aranges,=macro,=frames,\n\
          =frames-interp,=str,=loc,=Ranges,=pubtypes,\n\
          =gdb_index,=trace_info,=trace_abbrev,=trace_aranges,\n\
          =addr,=cu_index]\n\
                           Display DWARF info in the file\n\
  -t, --syms               Display the contents of the symbol table(s)\n\
  -T, --dynamic-syms       Display the contents of the dynamic symbol table\n\
  -r, --reloc              Display the relocation entries in the file\n\
  -R, --dynamic-reloc      Display the dynamic relocation entries in the file\n\
  @@<file>                  Read options from <file>\n\
  -v, --version            Display this program's version number\n\
  -i, --info               List object formats and architectures supported\n\
  -H, --help               Display this information\n\
"));
  if (status != 2)
    {
      const struct objdump_private_desc * const *desc;

      fprintf (stream, _("\n The following switches are optional:\n"));
      fprintf (stream, _("\
  -b, --target=BFDNAME           Specify the target object format as BFDNAME\n\
  -m, --architecture=MACHINE     Specify the target architecture as MACHINE\n\
  -j, --section=NAME             Only display information for section NAME\n\
  -M, --disassembler-options=OPT Pass text OPT on to the disassembler\n\
  -EB --endian=big               Assume big endian format when disassembling\n\
  -EL --endian=little            Assume little endian format when disassembling\n\
      --file-start-context       Include context from start of file (with -S)\n\
  -I, --include=DIR              Add DIR to search list for source files\n\
  -l, --line-numbers             Include line numbers and filenames in output\n\
  -F, --file-offsets             Include file offsets when displaying information\n\
  -C, --demangle[=STYLE]         Decode mangled/processed symbol names\n\
                                  The STYLE, if specified, can be `auto', `gnu',\n\
                                  `lucid', `arm', `hp', `edg', `gnu-v3', `java'\n\
                                  or `gnat'\n\
  -w, --wide                     Format output for more than 80 columns\n\
  -z, --disassemble-zeroes       Do not skip blocks of zeroes when disassembling\n\
      --start-address=ADDR       Only process data whose address is >= ADDR\n\
      --stop-address=ADDR        Only process data whose address is <= ADDR\n\
      --prefix-addresses         Print complete address alongside disassembly\n\
      --[no-]show-raw-insn       Display hex alongside symbolic disassembly\n\
      --insn-width=WIDTH         Display WIDTH bytes on a single line for -d\n\
      --adjust-vma=OFFSET        Add OFFSET to all displayed section addresses\n\
      --special-syms             Include special symbols in symbol dumps\n\
      --prefix=PREFIX            Add PREFIX to absolute paths for -S\n\
      --prefix-strip=LEVEL       Strip initial directory names for -S\n"));
      fprintf (stream, _("\
      --dwarf-depth=N        Do not display DIEs at depth N or greater\n\
      --dwarf-start=N        Display DIEs starting with N, at the same depth\n\
                             or deeper\n\
      --dwarf-check          Make additional dwarf internal consistency checks.\
      \n\n"));
      list_supported_targets (program_name, stream);
      list_supported_architectures (program_name, stream);

      disassembler_usage (stream);

      if (objdump_private_vectors[0] != NULL)
        {
          fprintf (stream,
                   _("\nOptions supported for -P/--private switch:\n"));
          for (desc = objdump_private_vectors; *desc != NULL; desc++)
            (*desc)->help (stream);
        }
    }
  if (REPORT_BUGS_TO[0] && status == 0)
    fprintf (stream, _("Report bugs to %s.\n"), REPORT_BUGS_TO);
  exit (status);
}

/* 150 isn't special; it's just an arbitrary non-ASCII char value.  */
enum option_values
  {
    OPTION_ENDIAN=150,
    OPTION_START_ADDRESS,
    OPTION_STOP_ADDRESS,
    OPTION_DWARF,
    OPTION_PREFIX,
    OPTION_PREFIX_STRIP,
    OPTION_INSN_WIDTH,
    OPTION_ADJUST_VMA,
    OPTION_DWARF_DEPTH,
    OPTION_DWARF_CHECK,
    OPTION_DWARF_START
  };

static struct option long_options[]=
{
  {"adjust-vma", required_argument, NULL, OPTION_ADJUST_VMA},
  {"all-headers", no_argument, NULL, 'x'},
  {"private-headers", no_argument, NULL, 'p'},
  {"private", required_argument, NULL, 'P'},
  {"architecture", required_argument, NULL, 'm'},
  {"archive-headers", no_argument, NULL, 'a'},
  {"debugging", no_argument, NULL, 'g'},
  {"debugging-tags", no_argument, NULL, 'e'},
  {"demangle", optional_argument, NULL, 'C'},
  {"disassemble", no_argument, NULL, 'd'},
  {"disassemble-all", no_argument, NULL, 'D'},
  {"disassembler-options", required_argument, NULL, 'M'},
  {"disassemble-zeroes", no_argument, NULL, 'z'},
  {"dynamic-reloc", no_argument, NULL, 'R'},
  {"dynamic-syms", no_argument, NULL, 'T'},
  {"endian", required_argument, NULL, OPTION_ENDIAN},
  {"file-headers", no_argument, NULL, 'f'},
  {"file-offsets", no_argument, NULL, 'F'},
  {"file-start-context", no_argument, &file_start_context, 1},
  {"full-contents", no_argument, NULL, 's'},
  {"headers", no_argument, NULL, 'h'},
  {"help", no_argument, NULL, 'H'},
  {"info", no_argument, NULL, 'i'},
  {"line-numbers", no_argument, NULL, 'l'},
  {"no-show-raw-insn", no_argument, &show_raw_insn, -1},
  {"prefix-addresses", no_argument, &prefix_addresses, 1},
  {"reloc", no_argument, NULL, 'r'},
  {"section", required_argument, NULL, 'j'},
  {"section-headers", no_argument, NULL, 'h'},
  {"show-raw-insn", no_argument, &show_raw_insn, 1},
  {"source", no_argument, NULL, 'S'},
  {"special-syms", no_argument, &dump_special_syms, 1},
  {"include", required_argument, NULL, 'I'},
  {"dwarf", optional_argument, NULL, OPTION_DWARF},
  {"stabs", no_argument, NULL, 'G'},
  {"start-address", required_argument, NULL, OPTION_START_ADDRESS},
  {"stop-address", required_argument, NULL, OPTION_STOP_ADDRESS},
  {"syms", no_argument, NULL, 't'},
  {"target", required_argument, NULL, 'b'},
  {"version", no_argument, NULL, 'V'},
  {"wide", no_argument, NULL, 'w'},
  {"prefix", required_argument, NULL, OPTION_PREFIX},
  {"prefix-strip", required_argument, NULL, OPTION_PREFIX_STRIP},
  {"insn-width", required_argument, NULL, OPTION_INSN_WIDTH},
  {"dwarf-depth",      required_argument, 0, OPTION_DWARF_DEPTH},
  {"dwarf-start",      required_argument, 0, OPTION_DWARF_START},
  {"dwarf-check",      no_argument, 0, OPTION_DWARF_CHECK},
  {0, no_argument, 0, 0}
};

static void
nonfatal (const char *msg)
{
  bfd_nonfatal (msg);
  exit_status = 1;
}

/* Returns TRUE if the specified section should be dumped.  */

static bfd_boolean
process_section_p (asection * section)
{
  struct only * only;

  if (only_list == NULL)
    return TRUE;

  for (only = only_list; only; only = only->next)
    if (strcmp (only->name, section->name) == 0)
      {
	only->seen = TRUE;
	return TRUE;
      }

  return FALSE;
}

/* Add an entry to the 'only' list.  */

static void
add_only (char * name)
{
  struct only * only;

  /* First check to make sure that we do not
     already have an entry for this name.  */
  for (only = only_list; only; only = only->next)
    if (strcmp (only->name, name) == 0)
      return;

  only = xmalloc (sizeof * only);
  only->name = name;
  only->seen = FALSE;
  only->next = only_list;
  only_list = only;
}

/* Release the memory used by the 'only' list.
   PR 11225: Issue a warning message for unseen sections.
   Only do this if none of the sections were seen.  This is mainly to support
   tools like the GAS testsuite where an object file is dumped with a list of
   generic section names known to be present in a range of different file
   formats.  */

static void
free_only_list (void)
{
  bfd_boolean at_least_one_seen = FALSE;
  struct only * only;
  struct only * next;

  if (only_list == NULL)
    return;

  for (only = only_list; only; only = only->next)
    if (only->seen)
      {
	at_least_one_seen = TRUE;
	break;
      }

  for (only = only_list; only; only = next)
    {
      if (! at_least_one_seen)
	{
	  non_fatal (_("section '%s' mentioned in a -j option, "
		       "but not found in any input file"),
		     only->name);
	  exit_status = 1;
	}
      next = only->next;
      free (only);
    }
}


static void
dump_section_header (bfd *abfd, asection *section,
		     void *ignored ATTRIBUTE_UNUSED)
{
  char *comma = "";
  unsigned int opb = bfd_octets_per_byte (abfd);

  /* Ignore linker created section.  See elfNN_ia64_object_p in
     bfd/elfxx-ia64.c.  */
  if (section->flags & SEC_LINKER_CREATED)
    return;

  /* PR 10413: Skip sections that we are ignoring.  */
  if (! process_section_p (section))
    return;

  printf ("%3d %-13s %08lx  ", section->index,
	  bfd_get_section_name (abfd, section),
	  (unsigned long) bfd_section_size (abfd, section) / opb);
  bfd_printf_vma (abfd, bfd_get_section_vma (abfd, section));
  printf ("  ");
  bfd_printf_vma (abfd, section->lma);
  printf ("  %08lx  2**%u", (unsigned long) section->filepos,
	  bfd_get_section_alignment (abfd, section));
  if (! wide_output)
    printf ("\n                ");
  printf ("  ");

#define PF(x, y) \
  if (section->flags & x) { printf ("%s%s", comma, y); comma = ", "; }

  PF (SEC_HAS_CONTENTS, "CONTENTS");
  PF (SEC_ALLOC, "ALLOC");
  PF (SEC_CONSTRUCTOR, "CONSTRUCTOR");
  PF (SEC_LOAD, "LOAD");
  PF (SEC_RELOC, "RELOC");
  PF (SEC_READONLY, "READONLY");
  PF (SEC_CODE, "CODE");
  PF (SEC_DATA, "DATA");
  PF (SEC_ROM, "ROM");
  PF (SEC_DEBUGGING, "DEBUGGING");
  PF (SEC_NEVER_LOAD, "NEVER_LOAD");
  PF (SEC_EXCLUDE, "EXCLUDE");
  PF (SEC_SORT_ENTRIES, "SORT_ENTRIES");
  if (bfd_get_arch (abfd) == bfd_arch_tic54x)
    {
      PF (SEC_TIC54X_BLOCK, "BLOCK");
      PF (SEC_TIC54X_CLINK, "CLINK");
    }
  PF (SEC_SMALL_DATA, "SMALL_DATA");
  if (bfd_get_flavour (abfd) == bfd_target_coff_flavour)
    PF (SEC_COFF_SHARED, "SHARED");
  PF (SEC_THREAD_LOCAL, "THREAD_LOCAL");
  PF (SEC_GROUP, "GROUP");

  if ((section->flags & SEC_LINK_ONCE) != 0)
    {
      const char *ls;
      struct coff_comdat_info *comdat;

      switch (section->flags & SEC_LINK_DUPLICATES)
	{
	default:
	  abort ();
	case SEC_LINK_DUPLICATES_DISCARD:
	  ls = "LINK_ONCE_DISCARD";
	  break;
	case SEC_LINK_DUPLICATES_ONE_ONLY:
	  ls = "LINK_ONCE_ONE_ONLY";
	  break;
	case SEC_LINK_DUPLICATES_SAME_SIZE:
	  ls = "LINK_ONCE_SAME_SIZE";
	  break;
	case SEC_LINK_DUPLICATES_SAME_CONTENTS:
	  ls = "LINK_ONCE_SAME_CONTENTS";
	  break;
	}
      printf ("%s%s", comma, ls);

      comdat = bfd_coff_get_comdat_section (abfd, section);
      if (comdat != NULL)
	printf (" (COMDAT %s %ld)", comdat->name, comdat->symbol);

      comma = ", ";
    }

  printf ("\n");
#undef PF
}

static void
dump_headers (bfd *abfd)
{
  printf (_("Sections:\n"));

#ifndef BFD64
  printf (_("Idx Name          Size      VMA       LMA       File off  Algn"));
#else
  /* With BFD64, non-ELF returns -1 and wants always 64 bit addresses.  */
  if (bfd_get_arch_size (abfd) == 32)
    printf (_("Idx Name          Size      VMA       LMA       File off  Algn"));
  else
    printf (_("Idx Name          Size      VMA               LMA               File off  Algn"));
#endif

  if (wide_output)
    printf (_("  Flags"));
  printf ("\n");

  bfd_map_over_sections (abfd, dump_section_header, NULL);
}

static asymbol **
slurp_symtab (bfd *abfd)
{
  asymbol **sy = NULL;
  long storage;

  if (!(bfd_get_file_flags (abfd) & HAS_SYMS))
    {
      symcount = 0;
      return NULL;
    }

  storage = bfd_get_symtab_upper_bound (abfd);
  if (storage < 0)
    bfd_fatal (bfd_get_filename (abfd));
  if (storage)
    sy = (asymbol **) xmalloc (storage);

  symcount = bfd_canonicalize_symtab (abfd, sy);
  if (symcount < 0)
    bfd_fatal (bfd_get_filename (abfd));
  return sy;
}

/* Read in the dynamic symbols.  */

static asymbol **
slurp_dynamic_symtab (bfd *abfd)
{
  asymbol **sy = NULL;
  long storage;

  storage = bfd_get_dynamic_symtab_upper_bound (abfd);
  if (storage < 0)
    {
      if (!(bfd_get_file_flags (abfd) & DYNAMIC))
	{
	  non_fatal (_("%s: not a dynamic object"), bfd_get_filename (abfd));
	  exit_status = 1;
	  dynsymcount = 0;
	  return NULL;
	}

      bfd_fatal (bfd_get_filename (abfd));
    }
  if (storage)
    sy = (asymbol **) xmalloc (storage);

  dynsymcount = bfd_canonicalize_dynamic_symtab (abfd, sy);
  if (dynsymcount < 0)
    bfd_fatal (bfd_get_filename (abfd));
  return sy;
}

/* Filter out (in place) symbols that are useless for disassembly.
   COUNT is the number of elements in SYMBOLS.
   Return the number of useful symbols.  */

static long
remove_useless_symbols (asymbol **symbols, long count)
{
  asymbol **in_ptr = symbols, **out_ptr = symbols;

  while (--count >= 0)
    {
      asymbol *sym = *in_ptr++;

      if (sym->name == NULL || sym->name[0] == '\0')
	continue;
      if (sym->flags & (BSF_DEBUGGING | BSF_SECTION_SYM))
	continue;
      if (bfd_is_und_section (sym->section)
	  || bfd_is_com_section (sym->section))
	continue;

      *out_ptr++ = sym;
    }
  return out_ptr - symbols;
}

/* Sort symbols into value order.  */

static int
compare_symbols (const void *ap, const void *bp)
{
  const asymbol *a = * (const asymbol **) ap;
  const asymbol *b = * (const asymbol **) bp;
  const char *an;
  const char *bn;
  size_t anl;
  size_t bnl;
  bfd_boolean af;
  bfd_boolean bf;
  flagword aflags;
  flagword bflags;

  if (bfd_asymbol_value (a) > bfd_asymbol_value (b))
    return 1;
  else if (bfd_asymbol_value (a) < bfd_asymbol_value (b))
    return -1;

  if (a->section > b->section)
    return 1;
  else if (a->section < b->section)
    return -1;

  an = bfd_asymbol_name (a);
  bn = bfd_asymbol_name (b);
  anl = strlen (an);
  bnl = strlen (bn);

  /* The symbols gnu_compiled and gcc2_compiled convey no real
     information, so put them after other symbols with the same value.  */
  af = (strstr (an, "gnu_compiled") != NULL
	|| strstr (an, "gcc2_compiled") != NULL);
  bf = (strstr (bn, "gnu_compiled") != NULL
	|| strstr (bn, "gcc2_compiled") != NULL);

  if (af && ! bf)
    return 1;
  if (! af && bf)
    return -1;

  /* We use a heuristic for the file name, to try to sort it after
     more useful symbols.  It may not work on non Unix systems, but it
     doesn't really matter; the only difference is precisely which
     symbol names get printed.  */

#define file_symbol(s, sn, snl)			\
  (((s)->flags & BSF_FILE) != 0			\
   || ((sn)[(snl) - 2] == '.'			\
       && ((sn)[(snl) - 1] == 'o'		\
	   || (sn)[(snl) - 1] == 'a')))

  af = file_symbol (a, an, anl);
  bf = file_symbol (b, bn, bnl);

  if (af && ! bf)
    return 1;
  if (! af && bf)
    return -1;

  /* Try to sort global symbols before local symbols before function
     symbols before debugging symbols.  */

  aflags = a->flags;
  bflags = b->flags;

  if ((aflags & BSF_DEBUGGING) != (bflags & BSF_DEBUGGING))
    {
      if ((aflags & BSF_DEBUGGING) != 0)
	return 1;
      else
	return -1;
    }
  if ((aflags & BSF_FUNCTION) != (bflags & BSF_FUNCTION))
    {
      if ((aflags & BSF_FUNCTION) != 0)
	return -1;
      else
	return 1;
    }
  if ((aflags & BSF_LOCAL) != (bflags & BSF_LOCAL))
    {
      if ((aflags & BSF_LOCAL) != 0)
	return 1;
      else
	return -1;
    }
  if ((aflags & BSF_GLOBAL) != (bflags & BSF_GLOBAL))
    {
      if ((aflags & BSF_GLOBAL) != 0)
	return -1;
      else
	return 1;
    }

  /* Symbols that start with '.' might be section names, so sort them
     after symbols that don't start with '.'.  */
  if (an[0] == '.' && bn[0] != '.')
    return 1;
  if (an[0] != '.' && bn[0] == '.')
    return -1;

  /* Finally, if we can't distinguish them in any other way, try to
     get consistent results by sorting the symbols by name.  */
  return strcmp (an, bn);
}

/* Sort relocs into address order.  */

static int
compare_relocs (const void *ap, const void *bp)
{
  const arelent *a = * (const arelent **) ap;
  const arelent *b = * (const arelent **) bp;

  if (a->address > b->address)
    return 1;
  else if (a->address < b->address)
    return -1;

  /* So that associated relocations tied to the same address show up
     in the correct order, we don't do any further sorting.  */
  if (a > b)
    return 1;
  else if (a < b)
    return -1;
  else
    return 0;
}

/* Print an address (VMA) to the output stream in INFO.
   If SKIP_ZEROES is TRUE, omit leading zeroes.  */

static void
objdump_print_value (bfd_vma vma, struct disassemble_info *inf,
		     bfd_boolean skip_zeroes)
{
  char buf[30];
  char *p;
  struct objdump_disasm_info *aux;

  aux = (struct objdump_disasm_info *) inf->application_data;
  bfd_sprintf_vma (aux->abfd, buf, vma);
  if (! skip_zeroes)
    p = buf;
  else
    {
      for (p = buf; *p == '0'; ++p)
	;
      if (*p == '\0')
	--p;
    }
  (*inf->fprintf_func) (inf->stream, "%s", p);
}

/* Print the name of a symbol.  */

static void
objdump_print_symname (bfd *abfd, struct disassemble_info *inf,
		       asymbol *sym)
{
  char *alloc;
  const char *name;

  alloc = NULL;
  name = bfd_asymbol_name (sym);
  if (do_demangle && name[0] != '\0')
    {
      /* Demangle the name.  */
      alloc = bfd_demangle (abfd, name, DMGL_ANSI | DMGL_PARAMS);
      if (alloc != NULL)
	name = alloc;
    }

  if (inf != NULL)
    (*inf->fprintf_func) (inf->stream, "%s", name);
  else
    printf ("%s", name);

  if (alloc != NULL)
    free (alloc);
}

/* Locate a symbol given a bfd and a section (from INFO->application_data),
   and a VMA.  If INFO->application_data->require_sec is TRUE, then always
   require the symbol to be in the section.  Returns NULL if there is no
   suitable symbol.  If PLACE is not NULL, then *PLACE is set to the index
   of the symbol in sorted_syms.  */

static asymbol *
find_symbol_for_address (bfd_vma vma,
			 struct disassemble_info *inf,
			 long *place)
{
  /* @@@@ Would it speed things up to cache the last two symbols returned,
     and maybe their address ranges?  For many processors, only one memory
     operand can be present at a time, so the 2-entry cache wouldn't be
     constantly churned by code doing heavy memory accesses.  */

  /* Indices in `sorted_syms'.  */
  long min = 0;
  long max_count = sorted_symcount;
  long thisplace;
  struct objdump_disasm_info *aux;
  bfd *abfd;
  asection *sec;
  unsigned int opb;
  bfd_boolean want_section;

  if (sorted_symcount < 1)
    return NULL;

  aux = (struct objdump_disasm_info *) inf->application_data;
  abfd = aux->abfd;
  sec = aux->sec;
  opb = inf->octets_per_byte;

  /* Perform a binary search looking for the closest symbol to the
     required value.  We are searching the range (min, max_count].  */
  while (min + 1 < max_count)
    {
      asymbol *sym;

      thisplace = (max_count + min) / 2;
      sym = sorted_syms[thisplace];

      if (bfd_asymbol_value (sym) > vma)
	max_count = thisplace;
      else if (bfd_asymbol_value (sym) < vma)
	min = thisplace;
      else
	{
	  min = thisplace;
	  break;
	}
    }

  /* The symbol we want is now in min, the low end of the range we
     were searching.  If there are several symbols with the same
     value, we want the first one.  */
  thisplace = min;
  while (thisplace > 0
	 && (bfd_asymbol_value (sorted_syms[thisplace])
	     == bfd_asymbol_value (sorted_syms[thisplace - 1])))
    --thisplace;

  /* Prefer a symbol in the current section if we have multple symbols
     with the same value, as can occur with overlays or zero size
     sections.  */
  min = thisplace;
  while (min < max_count
	 && (bfd_asymbol_value (sorted_syms[min])
	     == bfd_asymbol_value (sorted_syms[thisplace])))
    {
      if (sorted_syms[min]->section == sec
	  && inf->symbol_is_valid (sorted_syms[min], inf))
	{
	  thisplace = min;

	  if (place != NULL)
	    *place = thisplace;

	  return sorted_syms[thisplace];
	}
      ++min;
    }

  /* If the file is relocatable, and the symbol could be from this
     section, prefer a symbol from this section over symbols from
     others, even if the other symbol's value might be closer.

     Note that this may be wrong for some symbol references if the
     sections have overlapping memory ranges, but in that case there's
     no way to tell what's desired without looking at the relocation
     table.
     
     Also give the target a chance to reject symbols.  */
  want_section = (aux->require_sec
		  || ((abfd->flags & HAS_RELOC) != 0
		      && vma >= bfd_get_section_vma (abfd, sec)
		      && vma < (bfd_get_section_vma (abfd, sec)
				+ bfd_section_size (abfd, sec) / opb)));
  if ((sorted_syms[thisplace]->section != sec && want_section)
      || ! inf->symbol_is_valid (sorted_syms[thisplace], inf))
    {
      long i;
      long newplace = sorted_symcount;

      for (i = min - 1; i >= 0; i--)
	{
	  if ((sorted_syms[i]->section == sec || !want_section)
	      && inf->symbol_is_valid (sorted_syms[i], inf))
	    {
	      if (newplace == sorted_symcount)
		newplace = i;

	      if (bfd_asymbol_value (sorted_syms[i])
		  != bfd_asymbol_value (sorted_syms[newplace]))
		break;

	      /* Remember this symbol and keep searching until we reach
		 an earlier address.  */
	      newplace = i;
	    }
	}

      if (newplace != sorted_symcount)
	thisplace = newplace;
      else
	{
	  /* We didn't find a good symbol with a smaller value.
	     Look for one with a larger value.  */
	  for (i = thisplace + 1; i < sorted_symcount; i++)
	    {
	      if ((sorted_syms[i]->section == sec || !want_section)
		  && inf->symbol_is_valid (sorted_syms[i], inf))
		{
		  thisplace = i;
		  break;
		}
	    }
	}

      if ((sorted_syms[thisplace]->section != sec && want_section)
	  || ! inf->symbol_is_valid (sorted_syms[thisplace], inf))
	/* There is no suitable symbol.  */
	return NULL;
    }

  if (place != NULL)
    *place = thisplace;

  return sorted_syms[thisplace];
}

/* Print an address and the offset to the nearest symbol.  */

static void
objdump_print_addr_with_sym (bfd *abfd, asection *sec, asymbol *sym,
			     bfd_vma vma, struct disassemble_info *inf,
			     bfd_boolean skip_zeroes)
{
  objdump_print_value (vma, inf, skip_zeroes);

  if (sym == NULL)
    {
      bfd_vma secaddr;

      (*inf->fprintf_func) (inf->stream, " <%s",
			    bfd_get_section_name (abfd, sec));
      secaddr = bfd_get_section_vma (abfd, sec);
      if (vma < secaddr)
	{
	  (*inf->fprintf_func) (inf->stream, "-0x");
	  objdump_print_value (secaddr - vma, inf, TRUE);
	}
      else if (vma > secaddr)
	{
	  (*inf->fprintf_func) (inf->stream, "+0x");
	  objdump_print_value (vma - secaddr, inf, TRUE);
	}
      (*inf->fprintf_func) (inf->stream, ">");
    }
  else
    {
      (*inf->fprintf_func) (inf->stream, " <");
      objdump_print_symname (abfd, inf, sym);
      if (bfd_asymbol_value (sym) > vma)
	{
	  (*inf->fprintf_func) (inf->stream, "-0x");
	  objdump_print_value (bfd_asymbol_value (sym) - vma, inf, TRUE);
	}
      else if (vma > bfd_asymbol_value (sym))
	{
	  (*inf->fprintf_func) (inf->stream, "+0x");
	  objdump_print_value (vma - bfd_asymbol_value (sym), inf, TRUE);
	}
      (*inf->fprintf_func) (inf->stream, ">");
    }

  if (display_file_offsets)
    inf->fprintf_func (inf->stream, _(" (File Offset: 0x%lx)"),
			(long int)(sec->filepos + (vma - sec->vma)));
}

/* Print an address (VMA), symbolically if possible.
   If SKIP_ZEROES is TRUE, don't output leading zeroes.  */

static void
objdump_print_addr (bfd_vma vma,
		    struct disassemble_info *inf,
		    bfd_boolean skip_zeroes)
{
  struct objdump_disasm_info *aux;
  asymbol *sym = NULL;
  bfd_boolean skip_find = FALSE;

  aux = (struct objdump_disasm_info *) inf->application_data;

  if (sorted_symcount < 1)
    {
      (*inf->fprintf_func) (inf->stream, "0x");
      objdump_print_value (vma, inf, skip_zeroes);

      if (display_file_offsets)
	inf->fprintf_func (inf->stream, _(" (File Offset: 0x%lx)"),
			   (long int)(aux->sec->filepos + (vma - aux->sec->vma)));
      return;
    }

  if (aux->reloc != NULL
      && aux->reloc->sym_ptr_ptr != NULL
      && * aux->reloc->sym_ptr_ptr != NULL)
    {
      sym = * aux->reloc->sym_ptr_ptr;

      /* Adjust the vma to the reloc.  */
      vma += bfd_asymbol_value (sym);

      if (bfd_is_und_section (bfd_get_section (sym)))
	skip_find = TRUE;
    }

  if (!skip_find)
    sym = find_symbol_for_address (vma, inf, NULL);

  objdump_print_addr_with_sym (aux->abfd, aux->sec, sym, vma, inf,
			       skip_zeroes);
}

/* Print VMA to INFO.  This function is passed to the disassembler
   routine.  */

static void
objdump_print_address (bfd_vma vma, struct disassemble_info *inf)
{
  objdump_print_addr (vma, inf, ! prefix_addresses);
}

/* Determine if the given address has a symbol associated with it.  */

static int
objdump_symbol_at_address (bfd_vma vma, struct disassemble_info * inf)
{
  asymbol * sym;

  sym = find_symbol_for_address (vma, inf, NULL);

  return (sym != NULL && (bfd_asymbol_value (sym) == vma));
}

/* Hold the last function name and the last line number we displayed
   in a disassembly.  */

static char *prev_functionname;
static unsigned int prev_line;
static unsigned int prev_discriminator;

/* We keep a list of all files that we have seen when doing a
   disassembly with source, so that we know how much of the file to
   display.  This can be important for inlined functions.  */

struct print_file_list
{
  struct print_file_list *next;
  const char *filename;
  const char *modname;
  const char *map; 
  size_t mapsize;
  const char **linemap; 
  unsigned maxline;
  unsigned last_line;
  int first;
};

static struct print_file_list *print_files;

/* The number of preceding context lines to show when we start
   displaying a file for the first time.  */

#define SHOW_PRECEDING_CONTEXT_LINES (5)

/* Read a complete file into memory.  */

static const char *
slurp_file (const char *fn, size_t *size)
{
#ifdef HAVE_MMAP
  int ps = getpagesize ();
  size_t msize;
#endif
  const char *map;
  struct stat st;
  int fd = open (fn, O_RDONLY | O_BINARY);

  if (fd < 0)
    return NULL;
  if (fstat (fd, &st) < 0)
    {
      close (fd);
      return NULL;
    }
  *size = st.st_size;
#ifdef HAVE_MMAP
  msize = (*size + ps - 1) & ~(ps - 1);
  map = mmap (NULL, msize, PROT_READ, MAP_SHARED, fd, 0);
  if (map != (char *) -1L)
    {
      close (fd);
      return map;
    }
#endif
  map = (const char *) malloc (*size);
  if (!map || (size_t) read (fd, (char *) map, *size) != *size)
    {
      free ((void *) map);
      map = NULL;
    }
  close (fd);
  return map;
}

#define line_map_decrease 5

/* Precompute array of lines for a mapped file. */

static const char ** 
index_file (const char *map, size_t size, unsigned int *maxline) 
{
  const char *p, *lstart, *end;
  int chars_per_line = 45; /* First iteration will use 40.  */
  unsigned int lineno;
  const char **linemap = NULL; 
  unsigned long line_map_size = 0;
 
  lineno = 0;
  lstart = map;
  end = map + size;

  for (p = map; p < end; p++) 
    { 
      if (*p == '\n') 
	{ 
	  if (p + 1 < end && p[1] == '\r') 
	    p++;  
	} 
      else if (*p == '\r') 
	{ 
	  if (p + 1 < end && p[1] == '\n')
	    p++;
	}
      else
	continue;
      
      /* End of line found.  */

      if (linemap == NULL || line_map_size < lineno + 1) 
	{ 
	  unsigned long newsize;

	  chars_per_line -= line_map_decrease;
	  if (chars_per_line <= 1)
	    chars_per_line = 1;
	  line_map_size = size / chars_per_line + 1;
	  if (line_map_size < lineno + 1)
	    line_map_size = lineno + 1;
	  newsize = line_map_size * sizeof (char *);
	  linemap = (const char **) xrealloc (linemap, newsize);
	}

      linemap[lineno++] = lstart; 
      lstart = p + 1; 
    }
  
  *maxline = lineno; 
  return linemap;
}

/* Tries to open MODNAME, and if successful adds a node to print_files
   linked list and returns that node.  Returns NULL on failure.  */

static struct print_file_list *
try_print_file_open (const char *origname, const char *modname)
{
  struct print_file_list *p;

  p = (struct print_file_list *) xmalloc (sizeof (struct print_file_list));

  p->map = slurp_file (modname, &p->mapsize);
  if (p->map == NULL)
    {
      free (p);
      return NULL;
    }
  
  p->linemap = index_file (p->map, p->mapsize, &p->maxline);
  p->last_line = 0;
  p->filename = origname;
  p->modname = modname;
  p->next = print_files;
  p->first = 1;
  print_files = p;
  return p;
}

/* If the source file, as described in the symtab, is not found
   try to locate it in one of the paths specified with -I
   If found, add location to print_files linked list.  */

static struct print_file_list *
update_source_path (const char *filename)
{
  struct print_file_list *p;
  const char *fname;
  int i;

  p = try_print_file_open (filename, filename);
  if (p != NULL)
    return p;

  if (include_path_count == 0)
    return NULL;

  /* Get the name of the file.  */
  fname = lbasename (filename);

  /* If file exists under a new path, we need to add it to the list
     so that show_line knows about it.  */
  for (i = 0; i < include_path_count; i++)
    {
      char *modname = concat (include_paths[i], "/", fname, (const char *) 0);

      p = try_print_file_open (filename, modname);
      if (p)
	return p;

      free (modname);
    }

  return NULL;
}

/* Print a source file line.  */

static void 
print_line (struct print_file_list *p, unsigned int linenum)
{
  const char *l;
  size_t len;
 
  --linenum; 
  if (linenum >= p->maxline)
    return;
  l = p->linemap [linenum];
  /* Test fwrite return value to quiet glibc warning.  */
  len = strcspn (l, "\n\r");
  if (len == 0 || fwrite (l, len, 1, stdout) == 1)
    putchar ('\n');
}

/* Print a range of source code lines. */

static void
dump_lines (struct print_file_list *p, unsigned int start, unsigned int end)
{
  if (p->map == NULL)
    return;
  while (start <= end) 
    {
      print_line (p, start);
      start++;
    }
}

/* Show the line number, or the source line, in a disassembly
   listing.  */

static void
show_line (bfd *abfd, asection *section, bfd_vma addr_offset)
{
  const char *filename;
  const char *functionname;
  unsigned int linenumber;
  unsigned int discriminator;
  bfd_boolean reloc;

  if (! with_line_numbers && ! with_source_code)
    return;

  if (! bfd_find_nearest_line_discriminator (abfd, section, syms, addr_offset,
                                             &filename, &functionname,
                                             &linenumber, &discriminator))
    return;

  if (filename != NULL && *filename == '\0')
    filename = NULL;
  if (functionname != NULL && *functionname == '\0')
    functionname = NULL;

  if (filename
      && IS_ABSOLUTE_PATH (filename)
      && prefix)
    {
      char *path_up;
      const char *fname = filename;
      char *path = (char *) alloca (prefix_length + PATH_MAX + 1);

      if (prefix_length)
	memcpy (path, prefix, prefix_length);
      path_up = path + prefix_length;

      /* Build relocated filename, stripping off leading directories
	 from the initial filename if requested. */
      if (prefix_strip > 0)
	{
	  int level = 0;
	  const char *s;

	  /* Skip selected directory levels. */
	  for (s = fname + 1; *s != '\0' && level < prefix_strip; s++)
	    if (IS_DIR_SEPARATOR(*s))
	      {
		fname = s;
		level++;
	      }
	}

      /* Update complete filename. */
      strncpy (path_up, fname, PATH_MAX);
      path_up[PATH_MAX] = '\0';

      filename = path;
      reloc = TRUE;
    }
  else
    reloc = FALSE;

  if (with_line_numbers)
    {
      if (functionname != NULL
	  && (prev_functionname == NULL
	      || strcmp (functionname, prev_functionname) != 0))
	printf ("%s():\n", functionname);
      if (linenumber > 0 && (linenumber != prev_line || 
                             (discriminator != prev_discriminator)))
        { 
          if (discriminator > 0)
            printf ("%s:%u (discriminator %u)\n", filename == NULL ? "???" : filename,
                    linenumber, discriminator);
          else
            printf ("%s:%u\n", filename == NULL ? "???" : filename, linenumber);
        }
    }

  if (with_source_code
      && filename != NULL
      && linenumber > 0)
    {
      struct print_file_list **pp, *p;
      unsigned l;

      for (pp = &print_files; *pp != NULL; pp = &(*pp)->next)
	if (filename_cmp ((*pp)->filename, filename) == 0)
	  break;
      p = *pp;

      if (p == NULL)
	{
	  if (reloc)
	    filename = xstrdup (filename);
	  p = update_source_path (filename);
	}

      if (p != NULL && linenumber != p->last_line)
	{
	  if (file_start_context && p->first) 
	    l = 1;
	  else 
	    {
	      l = linenumber - SHOW_PRECEDING_CONTEXT_LINES;
	      if (l >= linenumber) 
		l = 1;
	      if (p->last_line >= l && p->last_line <= linenumber)
		l = p->last_line + 1;
	    }
	  dump_lines (p, l, linenumber);
	  p->last_line = linenumber;
	  p->first = 0;
	}
    }

  if (functionname != NULL
      && (prev_functionname == NULL
	  || strcmp (functionname, prev_functionname) != 0))
    {
      if (prev_functionname != NULL)
	free (prev_functionname);
      prev_functionname = (char *) xmalloc (strlen (functionname) + 1);
      strcpy (prev_functionname, functionname);
    }

  if (linenumber > 0 && linenumber != prev_line)
    prev_line = linenumber;

  if (discriminator != prev_discriminator)
    prev_discriminator = discriminator;
}

/* Pseudo FILE object for strings.  */
typedef struct
{
  char *buffer;
  size_t pos;
  size_t alloc;
} SFILE;

/* sprintf to a "stream".  */

static int ATTRIBUTE_PRINTF_2
objdump_sprintf (SFILE *f, const char *format, ...)
{
  size_t n;
  va_list args;

  while (1)
    {
      size_t space = f->alloc - f->pos;
  
      va_start (args, format);
      n = vsnprintf (f->buffer + f->pos, space, format, args);
      va_end (args);

      if (space > n)
	break;
      
      f->alloc = (f->alloc + n) * 2;
      f->buffer = (char *) xrealloc (f->buffer, f->alloc);
    }
  f->pos += n;
  
  return n;
}

/* The number of zeroes we want to see before we start skipping them.
   The number is arbitrarily chosen.  */

#define DEFAULT_SKIP_ZEROES 8

/* The number of zeroes to skip at the end of a section.  If the
   number of zeroes at the end is between SKIP_ZEROES_AT_END and
   SKIP_ZEROES, they will be disassembled.  If there are fewer than
   SKIP_ZEROES_AT_END, they will be skipped.  This is a heuristic
   attempt to avoid disassembling zeroes inserted by section
   alignment.  */

#define DEFAULT_SKIP_ZEROES_AT_END 3

/* Disassemble some data in memory between given values.  */

static void
disassemble_bytes (struct disassemble_info * inf,
		   disassembler_ftype        disassemble_fn,
		   bfd_boolean               insns,
		   bfd_byte *                data,
		   bfd_vma                   start_offset,
		   bfd_vma                   stop_offset,
		   bfd_vma		     rel_offset,
		   arelent ***               relppp,
		   arelent **                relppend)
{
  struct objdump_disasm_info *aux;
  asection *section;
  int octets_per_line;
  int skip_addr_chars;
  bfd_vma addr_offset;
  unsigned int opb = inf->octets_per_byte;
  unsigned int skip_zeroes = inf->skip_zeroes;
  unsigned int skip_zeroes_at_end = inf->skip_zeroes_at_end;
  int octets = opb;
  SFILE sfile;

  aux = (struct objdump_disasm_info *) inf->application_data;
  section = aux->sec;

  sfile.alloc = 120;
  sfile.buffer = (char *) xmalloc (sfile.alloc);
  sfile.pos = 0;
  
  if (insn_width)
    octets_per_line = insn_width;
  else if (insns)
    octets_per_line = 4;
  else
    octets_per_line = 16;

  /* Figure out how many characters to skip at the start of an
     address, to make the disassembly look nicer.  We discard leading
     zeroes in chunks of 4, ensuring that there is always a leading
     zero remaining.  */
  skip_addr_chars = 0;
  if (! prefix_addresses)
    {
      char buf[30];

      bfd_sprintf_vma (aux->abfd, buf, section->vma + section->size / opb);

      while (buf[skip_addr_chars] == '0')
	++skip_addr_chars;

      /* Don't discard zeros on overflow.  */
      if (buf[skip_addr_chars] == '\0' && section->vma != 0)
	skip_addr_chars = 0;

      if (skip_addr_chars != 0)
	skip_addr_chars = (skip_addr_chars - 1) & -4;
    }

  inf->insn_info_valid = 0;

  addr_offset = start_offset;
  while (addr_offset < stop_offset)
    {
      bfd_vma z;
      bfd_boolean need_nl = FALSE;
      int previous_octets;

      /* Remember the length of the previous instruction.  */
      previous_octets = octets;
      octets = 0;

      /* Make sure we don't use relocs from previous instructions.  */
      aux->reloc = NULL;

      /* If we see more than SKIP_ZEROES octets of zeroes, we just
	 print `...'.  */
      for (z = addr_offset * opb; z < stop_offset * opb; z++)
	if (data[z] != 0)
	  break;
      if (! disassemble_zeroes
	  && (inf->insn_info_valid == 0
	      || inf->branch_delay_insns == 0)
	  && (z - addr_offset * opb >= skip_zeroes
	      || (z == stop_offset * opb &&
		  z - addr_offset * opb < skip_zeroes_at_end)))
	{
	  /* If there are more nonzero octets to follow, we only skip
	     zeroes in multiples of 4, to try to avoid running over
	     the start of an instruction which happens to start with
	     zero.  */
	  if (z != stop_offset * opb)
	    z = addr_offset * opb + ((z - addr_offset * opb) &~ 3);

	  octets = z - addr_offset * opb;

	  /* If we are going to display more data, and we are displaying
	     file offsets, then tell the user how many zeroes we skip
	     and the file offset from where we resume dumping.  */
	  if (display_file_offsets && ((addr_offset + (octets / opb)) < stop_offset))
	    printf ("\t... (skipping %d zeroes, resuming at file offset: 0x%lx)\n",
		    octets / opb,
		    (unsigned long) (section->filepos
				     + (addr_offset + (octets / opb))));
	  else
	    printf ("\t...\n");
	}
      else
	{
	  char buf[50];
	  int bpc = 0;
	  int pb = 0;

	  if (with_line_numbers || with_source_code)
	    show_line (aux->abfd, section, addr_offset);

	  if (! prefix_addresses)
	    {
	      char *s;

	      bfd_sprintf_vma (aux->abfd, buf, section->vma + addr_offset);
	      for (s = buf + skip_addr_chars; *s == '0'; s++)
		*s = ' ';
	      if (*s == '\0')
		*--s = '0';
	      printf ("%s:\t", buf + skip_addr_chars);
	    }
	  else
	    {
	      aux->require_sec = TRUE;
	      objdump_print_address (section->vma + addr_offset, inf);
	      aux->require_sec = FALSE;
	      putchar (' ');
	    }

	  if (insns)
	    {
	      sfile.pos = 0;
	      inf->fprintf_func = (fprintf_ftype) objdump_sprintf;
	      inf->stream = &sfile;
	      inf->bytes_per_line = 0;
	      inf->bytes_per_chunk = 0;
	      inf->flags = disassemble_all ? DISASSEMBLE_DATA : 0;
	      if (machine)
		inf->flags |= USER_SPECIFIED_MACHINE_TYPE;

	      if (inf->disassembler_needs_relocs
		  && (bfd_get_file_flags (aux->abfd) & EXEC_P) == 0
		  && (bfd_get_file_flags (aux->abfd) & DYNAMIC) == 0
		  && *relppp < relppend)
		{
		  bfd_signed_vma distance_to_rel;

		  distance_to_rel = (**relppp)->address
		    - (rel_offset + addr_offset);

		  /* Check to see if the current reloc is associated with
		     the instruction that we are about to disassemble.  */
		  if (distance_to_rel == 0
		      /* FIXME: This is wrong.  We are trying to catch
			 relocs that are addressed part way through the
			 current instruction, as might happen with a packed
			 VLIW instruction.  Unfortunately we do not know the
			 length of the current instruction since we have not
			 disassembled it yet.  Instead we take a guess based
			 upon the length of the previous instruction.  The
			 proper solution is to have a new target-specific
			 disassembler function which just returns the length
			 of an instruction at a given address without trying
			 to display its disassembly. */
		      || (distance_to_rel > 0
			  && distance_to_rel < (bfd_signed_vma) (previous_octets/ opb)))
		    {
		      inf->flags |= INSN_HAS_RELOC;
		      aux->reloc = **relppp;
		    }
		}

	      octets = (*disassemble_fn) (section->vma + addr_offset, inf);
	      inf->fprintf_func = (fprintf_ftype) fprintf;
	      inf->stream = stdout;
	      if (insn_width == 0 && inf->bytes_per_line != 0)
		octets_per_line = inf->bytes_per_line;
	      if (octets < (int) opb)
		{
		  if (sfile.pos)
		    printf ("%s\n", sfile.buffer);
		  if (octets >= 0)
		    {
		      non_fatal (_("disassemble_fn returned length %d"),
				 octets);
		      exit_status = 1;
		    }
		  break;
		}
	    }
	  else
	    {
	      bfd_vma j;

	      octets = octets_per_line;
	      if (addr_offset + octets / opb > stop_offset)
		octets = (stop_offset - addr_offset) * opb;

	      for (j = addr_offset * opb; j < addr_offset * opb + octets; ++j)
		{
		  if (ISPRINT (data[j]))
		    buf[j - addr_offset * opb] = data[j];
		  else
		    buf[j - addr_offset * opb] = '.';
		}
	      buf[j - addr_offset * opb] = '\0';
	    }

	  if (prefix_addresses
	      ? show_raw_insn > 0
	      : show_raw_insn >= 0)
	    {
	      bfd_vma j;

	      /* If ! prefix_addresses and ! wide_output, we print
		 octets_per_line octets per line.  */
	      pb = octets;
	      if (pb > octets_per_line && ! prefix_addresses && ! wide_output)
		pb = octets_per_line;

	      if (inf->bytes_per_chunk)
		bpc = inf->bytes_per_chunk;
	      else
		bpc = 1;

	      for (j = addr_offset * opb; j < addr_offset * opb + pb; j += bpc)
		{
		  int k;

		  if (bpc > 1 && inf->display_endian == BFD_ENDIAN_LITTLE)
		    {
		      for (k = bpc - 1; k >= 0; k--)
			printf ("%02x", (unsigned) data[j + k]);
		      putchar (' ');
		    }
		  else
		    {
		      for (k = 0; k < bpc; k++)
			printf ("%02x", (unsigned) data[j + k]);
		      putchar (' ');
		    }
		}

	      for (; pb < octets_per_line; pb += bpc)
		{
		  int k;

		  for (k = 0; k < bpc; k++)
		    printf ("  ");
		  putchar (' ');
		}

	      /* Separate raw data from instruction by extra space.  */
	      if (insns)
		putchar ('\t');
	      else
		printf ("    ");
	    }

	  if (! insns)
	    printf ("%s", buf);
	  else if (sfile.pos)
	    printf ("%s", sfile.buffer);

	  if (prefix_addresses
	      ? show_raw_insn > 0
	      : show_raw_insn >= 0)
	    {
	      while (pb < octets)
		{
		  bfd_vma j;
		  char *s;

		  putchar ('\n');
		  j = addr_offset * opb + pb;

		  bfd_sprintf_vma (aux->abfd, buf, section->vma + j / opb);
		  for (s = buf + skip_addr_chars; *s == '0'; s++)
		    *s = ' ';
		  if (*s == '\0')
		    *--s = '0';
		  printf ("%s:\t", buf + skip_addr_chars);

		  pb += octets_per_line;
		  if (pb > octets)
		    pb = octets;
		  for (; j < addr_offset * opb + pb; j += bpc)
		    {
		      int k;

		      if (bpc > 1 && inf->display_endian == BFD_ENDIAN_LITTLE)
			{
			  for (k = bpc - 1; k >= 0; k--)
			    printf ("%02x", (unsigned) data[j + k]);
			  putchar (' ');
			}
		      else
			{
			  for (k = 0; k < bpc; k++)
			    printf ("%02x", (unsigned) data[j + k]);
			  putchar (' ');
			}
		    }
		}
	    }

	  if (!wide_output)
	    putchar ('\n');
	  else
	    need_nl = TRUE;
	}

      while ((*relppp) < relppend
	     && (**relppp)->address < rel_offset + addr_offset + octets / opb)
	{
	  if (dump_reloc_info || dump_dynamic_reloc_info)
	    {
	      arelent *q;

	      q = **relppp;

	      if (wide_output)
		putchar ('\t');
	      else
		printf ("\t\t\t");

	      objdump_print_value (section->vma - rel_offset + q->address,
				   inf, TRUE);

	      if (q->howto == NULL)
		printf (": *unknown*\t");
	      else if (q->howto->name)
		printf (": %s\t", q->howto->name);
	      else
		printf (": %d\t", q->howto->type);

	      if (q->sym_ptr_ptr == NULL || *q->sym_ptr_ptr == NULL)
		printf ("*unknown*");
	      else
		{
		  const char *sym_name;

		  sym_name = bfd_asymbol_name (*q->sym_ptr_ptr);
		  if (sym_name != NULL && *sym_name != '\0')
		    objdump_print_symname (aux->abfd, inf, *q->sym_ptr_ptr);
		  else
		    {
		      asection *sym_sec;

		      sym_sec = bfd_get_section (*q->sym_ptr_ptr);
		      sym_name = bfd_get_section_name (aux->abfd, sym_sec);
		      if (sym_name == NULL || *sym_name == '\0')
			sym_name = "*unknown*";
		      printf ("%s", sym_name);
		    }
		}

	      if (q->addend)
		{
		  bfd_signed_vma addend = q->addend;
		  if (addend < 0)
		    {
		      printf ("-0x");
		      addend = -addend;
		    }
		  else
		    printf ("+0x");
		  objdump_print_value (addend, inf, TRUE);
		}

	      printf ("\n");
	      need_nl = FALSE;
	    }
	  ++(*relppp);
	}

      if (need_nl)
	printf ("\n");

      addr_offset += octets / opb;
    }

  free (sfile.buffer);
}

static void
disassemble_section (bfd *abfd, asection *section, void *inf)
{
  const struct elf_backend_data * bed;
  bfd_vma                      sign_adjust = 0;
  struct disassemble_info *    pinfo = (struct disassemble_info *) inf;
  struct objdump_disasm_info * paux;
  unsigned int                 opb = pinfo->octets_per_byte;
  bfd_byte *                   data = NULL;
  bfd_size_type                datasize = 0;
  arelent **                   rel_pp = NULL;
  arelent **                   rel_ppstart = NULL;
  arelent **                   rel_ppend;
  unsigned long                stop_offset;
  asymbol *                    sym = NULL;
  long                         place = 0;
  long                         rel_count;
  bfd_vma                      rel_offset;
  unsigned long                addr_offset;

  /* Sections that do not contain machine
     code are not normally disassembled.  */
  if (! disassemble_all
      && only_list == NULL
      && ((section->flags & (SEC_CODE | SEC_HAS_CONTENTS))
	  != (SEC_CODE | SEC_HAS_CONTENTS)))
    return;

  if (! process_section_p (section))
    return;

  datasize = bfd_get_section_size (section);
  if (datasize == 0)
    return;

  if (start_address == (bfd_vma) -1
      || start_address < section->vma)
    addr_offset = 0;
  else
    addr_offset = start_address - section->vma;

  if (stop_address == (bfd_vma) -1)
    stop_offset = datasize / opb;
  else
    {
      if (stop_address < section->vma)
	stop_offset = 0;
      else
	stop_offset = stop_address - section->vma;
      if (stop_offset > datasize / opb)
	stop_offset = datasize / opb;
    }

  if (addr_offset >= stop_offset)
    return;

  /* Decide which set of relocs to use.  Load them if necessary.  */
  paux = (struct objdump_disasm_info *) pinfo->application_data;
  if (paux->dynrelbuf)
    {
      rel_pp = paux->dynrelbuf;
      rel_count = paux->dynrelcount;
      /* Dynamic reloc addresses are absolute, non-dynamic are section
	 relative.  REL_OFFSET specifies the reloc address corresponding
	 to the start of this section.  */
      rel_offset = section->vma;
    }
  else
    {
      rel_count = 0;
      rel_pp = NULL;
      rel_offset = 0;

      if ((section->flags & SEC_RELOC) != 0
	  && (dump_reloc_info || pinfo->disassembler_needs_relocs))
	{
	  long relsize;

	  relsize = bfd_get_reloc_upper_bound (abfd, section);
	  if (relsize < 0)
	    bfd_fatal (bfd_get_filename (abfd));

	  if (relsize > 0)
	    {
	      rel_ppstart = rel_pp = (arelent **) xmalloc (relsize);
	      rel_count = bfd_canonicalize_reloc (abfd, section, rel_pp, syms);
	      if (rel_count < 0)
		bfd_fatal (bfd_get_filename (abfd));

	      /* Sort the relocs by address.  */
	      qsort (rel_pp, rel_count, sizeof (arelent *), compare_relocs);
	    }
	}
    }
  rel_ppend = rel_pp + rel_count;

  data = (bfd_byte *) xmalloc (datasize);

  bfd_get_section_contents (abfd, section, data, 0, datasize);

  paux->sec = section;
  pinfo->buffer = data;
  pinfo->buffer_vma = section->vma;
  pinfo->buffer_length = datasize;
  pinfo->section = section;

  /* Skip over the relocs belonging to addresses below the
     start address.  */
  while (rel_pp < rel_ppend
	 && (*rel_pp)->address < rel_offset + addr_offset)
    ++rel_pp;

  printf (_("\nDisassembly of section %s:\n"), section->name);

  /* Find the nearest symbol forwards from our current position.  */
  paux->require_sec = TRUE;
  sym = (asymbol *) find_symbol_for_address (section->vma + addr_offset,
                                             (struct disassemble_info *) inf,
                                             &place);
  paux->require_sec = FALSE;

  /* PR 9774: If the target used signed addresses then we must make
     sure that we sign extend the value that we calculate for 'addr'
     in the loop below.  */
  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour
      && (bed = get_elf_backend_data (abfd)) != NULL
      && bed->sign_extend_vma)
    sign_adjust = (bfd_vma) 1 << (bed->s->arch_size - 1);

  /* Disassemble a block of instructions up to the address associated with
     the symbol we have just found.  Then print the symbol and find the
     next symbol on.  Repeat until we have disassembled the entire section
     or we have reached the end of the address range we are interested in.  */
  while (addr_offset < stop_offset)
    {
      bfd_vma addr;
      asymbol *nextsym;
      unsigned long nextstop_offset;
      bfd_boolean insns;

      addr = section->vma + addr_offset;
      addr = ((addr & ((sign_adjust << 1) - 1)) ^ sign_adjust) - sign_adjust;

      if (sym != NULL && bfd_asymbol_value (sym) <= addr)
	{
	  int x;

	  for (x = place;
	       (x < sorted_symcount
		&& (bfd_asymbol_value (sorted_syms[x]) <= addr));
	       ++x)
	    continue;

	  pinfo->symbols = sorted_syms + place;
	  pinfo->num_symbols = x - place;
	  pinfo->symtab_pos = place;
	}
      else
	{
	  pinfo->symbols = NULL;
	  pinfo->num_symbols = 0;
	  pinfo->symtab_pos = -1;
	}

      if (! prefix_addresses)
	{
	  pinfo->fprintf_func (pinfo->stream, "\n");
	  objdump_print_addr_with_sym (abfd, section, sym, addr,
				       pinfo, FALSE);
	  pinfo->fprintf_func (pinfo->stream, ":\n");
	}

      if (sym != NULL && bfd_asymbol_value (sym) > addr)
	nextsym = sym;
      else if (sym == NULL)
	nextsym = NULL;
      else
	{
#define is_valid_next_sym(SYM) \
  ((SYM)->section == section \
   && (bfd_asymbol_value (SYM) > bfd_asymbol_value (sym)) \
   && pinfo->symbol_is_valid (SYM, pinfo))
	    
	  /* Search forward for the next appropriate symbol in
	     SECTION.  Note that all the symbols are sorted
	     together into one big array, and that some sections
	     may have overlapping addresses.  */
	  while (place < sorted_symcount
		 && ! is_valid_next_sym (sorted_syms [place]))
	    ++place;

	  if (place >= sorted_symcount)
	    nextsym = NULL;
	  else
	    nextsym = sorted_syms[place];
	}

      if (sym != NULL && bfd_asymbol_value (sym) > addr)
	nextstop_offset = bfd_asymbol_value (sym) - section->vma;
      else if (nextsym == NULL)
	nextstop_offset = stop_offset;
      else
	nextstop_offset = bfd_asymbol_value (nextsym) - section->vma;

      if (nextstop_offset > stop_offset
	  || nextstop_offset <= addr_offset)
	nextstop_offset = stop_offset;

      /* If a symbol is explicitly marked as being an object
	 rather than a function, just dump the bytes without
	 disassembling them.  */
      if (disassemble_all
	  || sym == NULL
	  || sym->section != section
	  || bfd_asymbol_value (sym) > addr
	  || ((sym->flags & BSF_OBJECT) == 0
	      && (strstr (bfd_asymbol_name (sym), "gnu_compiled")
		  == NULL)
	      && (strstr (bfd_asymbol_name (sym), "gcc2_compiled")
		  == NULL))
	  || (sym->flags & BSF_FUNCTION) != 0)
	insns = TRUE;
      else
	insns = FALSE;

      disassemble_bytes (pinfo, paux->disassemble_fn, insns, data,
			 addr_offset, nextstop_offset,
			 rel_offset, &rel_pp, rel_ppend);
      
      addr_offset = nextstop_offset;
      sym = nextsym;
    }

  free (data);

  if (rel_ppstart != NULL)
    free (rel_ppstart);
}

/* Disassemble the contents of an object file.  */

static void
disassemble_data (bfd *abfd)
{
  struct disassemble_info disasm_info;
  struct objdump_disasm_info aux;
  long i;

  print_files = NULL;
  prev_functionname = NULL;
  prev_line = -1;
  prev_discriminator = 0;

  /* We make a copy of syms to sort.  We don't want to sort syms
     because that will screw up the relocs.  */
  sorted_symcount = symcount ? symcount : dynsymcount;
  sorted_syms = (asymbol **) xmalloc ((sorted_symcount + synthcount)
                                      * sizeof (asymbol *));
  memcpy (sorted_syms, symcount ? syms : dynsyms,
	  sorted_symcount * sizeof (asymbol *));

  sorted_symcount = remove_useless_symbols (sorted_syms, sorted_symcount);

  for (i = 0; i < synthcount; ++i)
    {
      sorted_syms[sorted_symcount] = synthsyms + i;
      ++sorted_symcount;
    }

  /* Sort the symbols into section and symbol order.  */
  qsort (sorted_syms, sorted_symcount, sizeof (asymbol *), compare_symbols);

  init_disassemble_info (&disasm_info, stdout, (fprintf_ftype) fprintf);

  disasm_info.application_data = (void *) &aux;
  aux.abfd = abfd;
  aux.require_sec = FALSE;
  aux.dynrelbuf = NULL;
  aux.dynrelcount = 0;
  aux.reloc = NULL;

  disasm_info.print_address_func = objdump_print_address;
  disasm_info.symbol_at_address_func = objdump_symbol_at_address;

  if (machine != NULL)
    {
      const bfd_arch_info_type *inf = bfd_scan_arch (machine);

      if (inf == NULL)
	fatal (_("can't use supplied machine %s"), machine);

      abfd->arch_info = inf;
    }

  if (endian != BFD_ENDIAN_UNKNOWN)
    {
      struct bfd_target *xvec;

      xvec = (struct bfd_target *) xmalloc (sizeof (struct bfd_target));
      memcpy (xvec, abfd->xvec, sizeof (struct bfd_target));
      xvec->byteorder = endian;
      abfd->xvec = xvec;
    }

  /* Use libopcodes to locate a suitable disassembler.  */
  aux.disassemble_fn = disassembler (abfd);
  if (!aux.disassemble_fn)
    {
      non_fatal (_("can't disassemble for architecture %s\n"),
		 bfd_printable_arch_mach (bfd_get_arch (abfd), 0));
      exit_status = 1;
      return;
    }

  disasm_info.flavour = bfd_get_flavour (abfd);
  disasm_info.arch = bfd_get_arch (abfd);
  disasm_info.mach = bfd_get_mach (abfd);
  disasm_info.disassembler_options = disassembler_options;
  disasm_info.octets_per_byte = bfd_octets_per_byte (abfd);
  disasm_info.skip_zeroes = DEFAULT_SKIP_ZEROES;
  disasm_info.skip_zeroes_at_end = DEFAULT_SKIP_ZEROES_AT_END;
  disasm_info.disassembler_needs_relocs = FALSE;

  if (bfd_big_endian (abfd))
    disasm_info.display_endian = disasm_info.endian = BFD_ENDIAN_BIG;
  else if (bfd_little_endian (abfd))
    disasm_info.display_endian = disasm_info.endian = BFD_ENDIAN_LITTLE;
  else
    /* ??? Aborting here seems too drastic.  We could default to big or little
       instead.  */
    disasm_info.endian = BFD_ENDIAN_UNKNOWN;

  /* Allow the target to customize the info structure.  */
  disassemble_init_for_target (& disasm_info);

  /* Pre-load the dynamic relocs if we are going
     to be dumping them along with the disassembly.  */
  if (dump_dynamic_reloc_info)
    {
      long relsize = bfd_get_dynamic_reloc_upper_bound (abfd);
  
      if (relsize < 0)
	bfd_fatal (bfd_get_filename (abfd));

      if (relsize > 0)
	{
	  aux.dynrelbuf = (arelent **) xmalloc (relsize);
	  aux.dynrelcount = bfd_canonicalize_dynamic_reloc (abfd,
							    aux.dynrelbuf,
							    dynsyms);
	  if (aux.dynrelcount < 0)
	    bfd_fatal (bfd_get_filename (abfd));

	  /* Sort the relocs by address.  */
	  qsort (aux.dynrelbuf, aux.dynrelcount, sizeof (arelent *),
		 compare_relocs);
	}
    }
  disasm_info.symtab = sorted_syms;
  disasm_info.symtab_size = sorted_symcount;

  bfd_map_over_sections (abfd, disassemble_section, & disasm_info);

  if (aux.dynrelbuf != NULL)
    free (aux.dynrelbuf);
  free (sorted_syms);
}

static int
load_specific_debug_section (enum dwarf_section_display_enum debug,
			     asection *sec, void *file)
{
  struct dwarf_section *section = &debug_displays [debug].section;
  bfd *abfd = (bfd *) file;
  bfd_boolean ret;

  /* If it is already loaded, do nothing.  */
  if (section->start != NULL)
    return 1;

  section->address = 0;
  section->size = bfd_get_section_size (sec);
  section->start = NULL;
  ret = bfd_get_full_section_contents (abfd, sec, &section->start);

  if (! ret)
    {
      free_debug_section (debug);
      printf (_("\nCan't get contents for section '%s'.\n"),
	      section->name);
      return 0;
    }

  if (is_relocatable && debug_displays [debug].relocate)
    {
      bfd_cache_section_contents (sec, section->start);

      ret = bfd_simple_get_relocated_section_contents (abfd,
						       sec,
						       section->start,
						       syms) != NULL;

      if (! ret)
        {
          free_debug_section (debug);
          printf (_("\nCan't get contents for section '%s'.\n"),
	          section->name);
          return 0;
        }
    }

  return 1;
}

int
load_debug_section (enum dwarf_section_display_enum debug, void *file)
{
  struct dwarf_section *section = &debug_displays [debug].section;
  bfd *abfd = (bfd *) file;
  asection *sec;

  /* If it is already loaded, do nothing.  */
  if (section->start != NULL)
    return 1;

  /* Locate the debug section.  */
  sec = bfd_get_section_by_name (abfd, section->uncompressed_name);
  if (sec != NULL)
    section->name = section->uncompressed_name;
  else
    {
      sec = bfd_get_section_by_name (abfd, section->compressed_name);
      if (sec != NULL)
        section->name = section->compressed_name;
    }
  if (sec == NULL)
    return 0;

  return load_specific_debug_section (debug, sec, file);
}

void
free_debug_section (enum dwarf_section_display_enum debug)
{
  struct dwarf_section *section = &debug_displays [debug].section;

  if (section->start == NULL)
    return;

  free ((char *) section->start);
  section->start = NULL;
  section->address = 0;
  section->size = 0;
}

static void
dump_dwarf_section (bfd *abfd, asection *section,
		    void *arg ATTRIBUTE_UNUSED)
{
  const char *name = bfd_get_section_name (abfd, section);
  const char *match;
  int i;

  if (CONST_STRNEQ (name, ".gnu.linkonce.wi."))
    match = ".debug_info";
  else
    match = name;

  for (i = 0; i < max; i++)
    if ((strcmp (debug_displays [i].section.uncompressed_name, match) == 0
	 || strcmp (debug_displays [i].section.compressed_name, match) == 0)
	&& debug_displays [i].enabled != NULL
	&& *debug_displays [i].enabled)
      {
	struct dwarf_section *sec = &debug_displays [i].section;

	if (strcmp (sec->uncompressed_name, match) == 0)
	  sec->name = sec->uncompressed_name;
	else
	  sec->name = sec->compressed_name;
	if (load_specific_debug_section ((enum dwarf_section_display_enum) i,
                                         section, abfd))
	  {
	    debug_displays [i].display (sec, abfd);
	    
	    if (i != info && i != abbrev)
	      free_debug_section ((enum dwarf_section_display_enum) i);
	  }
	break;
      }
}

/* Dump the dwarf debugging information.  */

static void
dump_dwarf (bfd *abfd)
{
  is_relocatable = (abfd->flags & (EXEC_P | DYNAMIC)) == 0;

  eh_addr_size = bfd_arch_bits_per_address (abfd) / 8;

  if (bfd_big_endian (abfd))
    byte_get = byte_get_big_endian;
  else if (bfd_little_endian (abfd))
    byte_get = byte_get_little_endian;
  else
    abort ();

  switch (bfd_get_arch (abfd))
    {
    case bfd_arch_i386:
      switch (bfd_get_mach (abfd))
	{
	case bfd_mach_x86_64:
	case bfd_mach_x86_64_intel_syntax:
	case bfd_mach_x64_32:
	case bfd_mach_x64_32_intel_syntax:
	  init_dwarf_regnames_x86_64 ();
	  break;

	default:
	  init_dwarf_regnames_i386 ();
	  break;
	}
      break;

    default:
      break;
    }

  bfd_map_over_sections (abfd, dump_dwarf_section, NULL);

  free_debug_memory ();
}

/* Read ABFD's stabs section STABSECT_NAME, and return a pointer to
   it.  Return NULL on failure.   */

static char *
read_section_stabs (bfd *abfd, const char *sect_name, bfd_size_type *size_ptr)
{
  asection *stabsect;
  bfd_size_type size;
  char *contents;

  stabsect = bfd_get_section_by_name (abfd, sect_name);
  if (stabsect == NULL)
    {
      printf (_("No %s section present\n\n"), sect_name);
      return FALSE;
    }

  size = bfd_section_size (abfd, stabsect);
  contents  = (char *) xmalloc (size);

  if (! bfd_get_section_contents (abfd, stabsect, contents, 0, size))
    {
      non_fatal (_("reading %s section of %s failed: %s"),
		 sect_name, bfd_get_filename (abfd),
		 bfd_errmsg (bfd_get_error ()));
      exit_status = 1;
      free (contents);
      return NULL;
    }

  *size_ptr = size;

  return contents;
}

/* Stabs entries use a 12 byte format:
     4 byte string table index
     1 byte stab type
     1 byte stab other field
     2 byte stab desc field
     4 byte stab value
   FIXME: This will have to change for a 64 bit object format.  */

#define STRDXOFF  (0)
#define TYPEOFF   (4)
#define OTHEROFF  (5)
#define DESCOFF   (6)
#define VALOFF    (8)
#define STABSIZE (12)

/* Print ABFD's stabs section STABSECT_NAME (in `stabs'),
   using string table section STRSECT_NAME (in `strtab').  */

static void
print_section_stabs (bfd *abfd,
		     const char *stabsect_name,
		     unsigned *string_offset_ptr)
{
  int i;
  unsigned file_string_table_offset = 0;
  unsigned next_file_string_table_offset = *string_offset_ptr;
  bfd_byte *stabp, *stabs_end;

  stabp = stabs;
  stabs_end = stabp + stab_size;

  printf (_("Contents of %s section:\n\n"), stabsect_name);
  printf ("Symnum n_type n_othr n_desc n_value  n_strx String\n");

  /* Loop through all symbols and print them.

     We start the index at -1 because there is a dummy symbol on
     the front of stabs-in-{coff,elf} sections that supplies sizes.  */
  for (i = -1; stabp < stabs_end; stabp += STABSIZE, i++)
    {
      const char *name;
      unsigned long strx;
      unsigned char type, other;
      unsigned short desc;
      bfd_vma value;

      strx = bfd_h_get_32 (abfd, stabp + STRDXOFF);
      type = bfd_h_get_8 (abfd, stabp + TYPEOFF);
      other = bfd_h_get_8 (abfd, stabp + OTHEROFF);
      desc = bfd_h_get_16 (abfd, stabp + DESCOFF);
      value = bfd_h_get_32 (abfd, stabp + VALOFF);

      printf ("\n%-6d ", i);
      /* Either print the stab name, or, if unnamed, print its number
	 again (makes consistent formatting for tools like awk).  */
      name = bfd_get_stab_name (type);
      if (name != NULL)
	printf ("%-6s", name);
      else if (type == N_UNDF)
	printf ("HdrSym");
      else
	printf ("%-6d", type);
      printf (" %-6d %-6d ", other, desc);
      bfd_printf_vma (abfd, value);
      printf (" %-6lu", strx);

      /* Symbols with type == 0 (N_UNDF) specify the length of the
	 string table associated with this file.  We use that info
	 to know how to relocate the *next* file's string table indices.  */
      if (type == N_UNDF)
	{
	  file_string_table_offset = next_file_string_table_offset;
	  next_file_string_table_offset += value;
	}
      else
	{
	  /* Using the (possibly updated) string table offset, print the
	     string (if any) associated with this symbol.  */
	  if ((strx + file_string_table_offset) < stabstr_size)
	    printf (" %s", &strtab[strx + file_string_table_offset]);
	  else
	    printf (" *");
	}
    }
  printf ("\n\n");
  *string_offset_ptr = next_file_string_table_offset;
}

typedef struct
{
  const char * section_name;
  const char * string_section_name;
  unsigned string_offset;
}
stab_section_names;

static void
find_stabs_section (bfd *abfd, asection *section, void *names)
{
  int len;
  stab_section_names * sought = (stab_section_names *) names;

  /* Check for section names for which stabsect_name is a prefix, to
     handle .stab.N, etc.  */
  len = strlen (sought->section_name);

  /* If the prefix matches, and the files section name ends with a
     nul or a digit, then we match.  I.e., we want either an exact
     match or a section followed by a number.  */
  if (strncmp (sought->section_name, section->name, len) == 0
      && (section->name[len] == 0
	  || (section->name[len] == '.' && ISDIGIT (section->name[len + 1]))))
    {
      if (strtab == NULL)
	strtab = read_section_stabs (abfd, sought->string_section_name,
				     &stabstr_size);
      
      if (strtab)
	{
	  stabs = (bfd_byte *) read_section_stabs (abfd, section->name,
						   &stab_size);
	  if (stabs)
	    print_section_stabs (abfd, section->name, &sought->string_offset);
	}
    }
}

static void
dump_stabs_section (bfd *abfd, char *stabsect_name, char *strsect_name)
{
  stab_section_names s;

  s.section_name = stabsect_name;
  s.string_section_name = strsect_name;
  s.string_offset = 0;

  bfd_map_over_sections (abfd, find_stabs_section, & s);

  free (strtab);
  strtab = NULL;
}

/* Dump the any sections containing stabs debugging information.  */

static void
dump_stabs (bfd *abfd)
{
  dump_stabs_section (abfd, ".stab", ".stabstr");
  dump_stabs_section (abfd, ".stab.excl", ".stab.exclstr");
  dump_stabs_section (abfd, ".stab.index", ".stab.indexstr");

  /* For Darwin.  */
  dump_stabs_section (abfd, "LC_SYMTAB.stabs", "LC_SYMTAB.stabstr");

  dump_stabs_section (abfd, "$GDB_SYMBOLS$", "$GDB_STRINGS$");
}

static void
dump_bfd_header (bfd *abfd)
{
  char *comma = "";

  printf (_("architecture: %s, "),
	  bfd_printable_arch_mach (bfd_get_arch (abfd),
				   bfd_get_mach (abfd)));
  printf (_("flags 0x%08x:\n"), abfd->flags & ~BFD_FLAGS_FOR_BFD_USE_MASK);

#define PF(x, y)    if (abfd->flags & x) {printf("%s%s", comma, y); comma=", ";}
  PF (HAS_RELOC, "HAS_RELOC");
  PF (EXEC_P, "EXEC_P");
  PF (HAS_LINENO, "HAS_LINENO");
  PF (HAS_DEBUG, "HAS_DEBUG");
  PF (HAS_SYMS, "HAS_SYMS");
  PF (HAS_LOCALS, "HAS_LOCALS");
  PF (DYNAMIC, "DYNAMIC");
  PF (WP_TEXT, "WP_TEXT");
  PF (D_PAGED, "D_PAGED");
  PF (BFD_IS_RELAXABLE, "BFD_IS_RELAXABLE");
  PF (HAS_LOAD_PAGE, "HAS_LOAD_PAGE");
  printf (_("\nstart address 0x"));
  bfd_printf_vma (abfd, abfd->start_address);
  printf ("\n");
}


static void
dump_bfd_private_header (bfd *abfd)
{
  bfd_print_private_bfd_data (abfd, stdout);
}

static void
dump_target_specific (bfd *abfd)
{
  const struct objdump_private_desc * const *desc;
  struct objdump_private_option *opt;
  char *e, *b;

  /* Find the desc.  */
  for (desc = objdump_private_vectors; *desc != NULL; desc++)
    if ((*desc)->filter (abfd))
      break;

  if (*desc == NULL)
    {
      non_fatal (_("option -P/--private not supported by this file"));
      return;
    }

  /* Clear all options.  */
  for (opt = (*desc)->options; opt->name; opt++)
    opt->selected = FALSE;

  /* Decode options.  */
  b = dump_private_options;
  do
    {
      e = strchr (b, ',');

      if (e)
        *e = 0;

      for (opt = (*desc)->options; opt->name; opt++)
        if (strcmp (opt->name, b) == 0)
          {
            opt->selected = TRUE;
            break;
          }
      if (opt->name == NULL)
        non_fatal (_("target specific dump '%s' not supported"), b);

      if (e)
        {
          *e = ',';
          b = e + 1;
        }
    }
  while (e != NULL);

  /* Dump.  */
  (*desc)->dump (abfd);
}

/* Display a section in hexadecimal format with associated characters.
   Each line prefixed by the zero padded address.  */

static void
dump_section (bfd *abfd, asection *section, void *dummy ATTRIBUTE_UNUSED)
{
  bfd_byte *data = 0;
  bfd_size_type datasize;
  bfd_size_type addr_offset;
  bfd_size_type start_offset;
  bfd_size_type stop_offset;
  unsigned int opb = bfd_octets_per_byte (abfd);
  /* Bytes per line.  */
  const int onaline = 16;
  char buf[64];
  int count;
  int width;

  if ((section->flags & SEC_HAS_CONTENTS) == 0)
    return;

  if (! process_section_p (section))
    return;
  
  if ((datasize = bfd_section_size (abfd, section)) == 0)
    return;

  /* Compute the address range to display.  */
  if (start_address == (bfd_vma) -1
      || start_address < section->vma)
    start_offset = 0;
  else
    start_offset = start_address - section->vma;

  if (stop_address == (bfd_vma) -1)
    stop_offset = datasize / opb;
  else
    {
      if (stop_address < section->vma)
	stop_offset = 0;
      else
	stop_offset = stop_address - section->vma;

      if (stop_offset > datasize / opb)
	stop_offset = datasize / opb;
    }

  if (start_offset >= stop_offset)
    return;
  
  printf (_("Contents of section %s:"), section->name);
  if (display_file_offsets)
    printf (_("  (Starting at file offset: 0x%lx)"),
	    (unsigned long) (section->filepos + start_offset));
  printf ("\n");

  if (!bfd_get_full_section_contents (abfd, section, &data))
    {
      non_fatal (_("Reading section failed"));
      return;
    }

  width = 4;

  bfd_sprintf_vma (abfd, buf, start_offset + section->vma);
  if (strlen (buf) >= sizeof (buf))
    abort ();

  count = 0;
  while (buf[count] == '0' && buf[count+1] != '\0')
    count++;
  count = strlen (buf) - count;
  if (count > width)
    width = count;

  bfd_sprintf_vma (abfd, buf, stop_offset + section->vma - 1);
  if (strlen (buf) >= sizeof (buf))
    abort ();

  count = 0;
  while (buf[count] == '0' && buf[count+1] != '\0')
    count++;
  count = strlen (buf) - count;
  if (count > width)
    width = count;

  for (addr_offset = start_offset;
       addr_offset < stop_offset; addr_offset += onaline / opb)
    {
      bfd_size_type j;

      bfd_sprintf_vma (abfd, buf, (addr_offset + section->vma));
      count = strlen (buf);
      if ((size_t) count >= sizeof (buf))
	abort ();

      putchar (' ');
      while (count < width)
	{
	  putchar ('0');
	  count++;
	}
      fputs (buf + count - width, stdout);
      putchar (' ');

      for (j = addr_offset * opb;
	   j < addr_offset * opb + onaline; j++)
	{
	  if (j < stop_offset * opb)
	    printf ("%02x", (unsigned) (data[j]));
	  else
	    printf ("  ");
	  if ((j & 3) == 3)
	    printf (" ");
	}

      printf (" ");
      for (j = addr_offset * opb;
	   j < addr_offset * opb + onaline; j++)
	{
	  if (j >= stop_offset * opb)
	    printf (" ");
	  else
	    printf ("%c", ISPRINT (data[j]) ? data[j] : '.');
	}
      putchar ('\n');
    }
  free (data);
}

/* Actually display the various requested regions.  */

static void
dump_data (bfd *abfd)
{
  bfd_map_over_sections (abfd, dump_section, NULL);
}

/* Should perhaps share code and display with nm?  */

static void
dump_symbols (bfd *abfd ATTRIBUTE_UNUSED, bfd_boolean dynamic)
{
  asymbol **current;
  long max_count;
  long count;

  if (dynamic)
    {
      current = dynsyms;
      max_count = dynsymcount;
      printf ("DYNAMIC SYMBOL TABLE:\n");
    }
  else
    {
      current = syms;
      max_count = symcount;
      printf ("SYMBOL TABLE:\n");
    }

  if (max_count == 0)
    printf (_("no symbols\n"));

  for (count = 0; count < max_count; count++)
    {
      bfd *cur_bfd;

      if (*current == NULL)
	printf (_("no information for symbol number %ld\n"), count);

      else if ((cur_bfd = bfd_asymbol_bfd (*current)) == NULL)
	printf (_("could not determine the type of symbol number %ld\n"),
		count);

      else if (process_section_p ((* current)->section)
	       && (dump_special_syms
		   || !bfd_is_target_special_symbol (cur_bfd, *current)))
	{
	  const char *name = (*current)->name;

	  if (do_demangle && name != NULL && *name != '\0')
	    {
	      char *alloc;

	      /* If we want to demangle the name, we demangle it
		 here, and temporarily clobber it while calling
		 bfd_print_symbol.  FIXME: This is a gross hack.  */
	      alloc = bfd_demangle (cur_bfd, name, DMGL_ANSI | DMGL_PARAMS);
	      if (alloc != NULL)
		(*current)->name = alloc;
	      bfd_print_symbol (cur_bfd, stdout, *current,
				bfd_print_symbol_all);
	      if (alloc != NULL)
		{
		  (*current)->name = name;
		  free (alloc);
		}
	    }
	  else
	    bfd_print_symbol (cur_bfd, stdout, *current,
			      bfd_print_symbol_all);
	  printf ("\n");
	}

      current++;
    }
  printf ("\n\n");
}

static void
dump_reloc_set (bfd *abfd, asection *sec, arelent **relpp, long relcount)
{
  arelent **p;
  char *last_filename, *last_functionname;
  unsigned int last_line;
  unsigned int last_discriminator;

  /* Get column headers lined up reasonably.  */
  {
    static int width;

    if (width == 0)
      {
	char buf[30];

	bfd_sprintf_vma (abfd, buf, (bfd_vma) -1);
	width = strlen (buf) - 7;
      }
    printf ("OFFSET %*s TYPE %*s VALUE \n", width, "", 12, "");
  }

  last_filename = NULL;
  last_functionname = NULL;
  last_line = 0;
  last_discriminator = 0;

  for (p = relpp; relcount && *p != NULL; p++, relcount--)
    {
      arelent *q = *p;
      const char *filename, *functionname;
      unsigned int linenumber;
      unsigned int discriminator;
      const char *sym_name;
      const char *section_name;
      bfd_vma addend2 = 0;

      if (start_address != (bfd_vma) -1
	  && q->address < start_address)
	continue;
      if (stop_address != (bfd_vma) -1
	  && q->address > stop_address)
	continue;

      if (with_line_numbers
	  && sec != NULL
	  && bfd_find_nearest_line_discriminator (abfd, sec, syms, q->address,
                                                  &filename, &functionname,
                                                  &linenumber, &discriminator))
	{
	  if (functionname != NULL
	      && (last_functionname == NULL
		  || strcmp (functionname, last_functionname) != 0))
	    {
	      printf ("%s():\n", functionname);
	      if (last_functionname != NULL)
		free (last_functionname);
	      last_functionname = xstrdup (functionname);
	    }

	  if (linenumber > 0
	      && (linenumber != last_line
		  || (filename != NULL
		      && last_filename != NULL
		      && filename_cmp (filename, last_filename) != 0)
                  || (discriminator != last_discriminator)))
	    {
              if (discriminator > 0)
                printf ("%s:%u\n", filename == NULL ? "???" : filename, linenumber);
              else
                printf ("%s:%u (discriminator %u)\n", filename == NULL ? "???" : filename,
                        linenumber, discriminator);
	      last_line = linenumber;
	      last_discriminator = discriminator;
	      if (last_filename != NULL)
		free (last_filename);
	      if (filename == NULL)
		last_filename = NULL;
	      else
		last_filename = xstrdup (filename);
	    }
	}

      if (q->sym_ptr_ptr && *q->sym_ptr_ptr)
	{
	  sym_name = (*(q->sym_ptr_ptr))->name;
	  section_name = (*(q->sym_ptr_ptr))->section->name;
	}
      else
	{
	  sym_name = NULL;
	  section_name = NULL;
	}

      bfd_printf_vma (abfd, q->address);
      if (q->howto == NULL)
	printf (" *unknown*         ");
      else if (q->howto->name)
	{
	  const char *name = q->howto->name;

	  /* R_SPARC_OLO10 relocations contain two addends.
	     But because 'arelent' lacks enough storage to
	     store them both, the 64-bit ELF Sparc backend
	     records this as two relocations.  One R_SPARC_LO10
	     and one R_SPARC_13, both pointing to the same
	     address.  This is merely so that we have some
	     place to store both addend fields.

	     Undo this transformation, otherwise the output
	     will be confusing.  */
	  if (abfd->xvec->flavour == bfd_target_elf_flavour
	      && elf_tdata(abfd)->elf_header->e_machine == EM_SPARCV9
	      && relcount > 1
	      && !strcmp (q->howto->name, "R_SPARC_LO10"))
	    {
	      arelent *q2 = *(p + 1);
	      if (q2 != NULL
		  && q2->howto
		  && q->address == q2->address
		  && !strcmp (q2->howto->name, "R_SPARC_13"))
		{
		  name = "R_SPARC_OLO10";
		  addend2 = q2->addend;
		  p++;
		}
	    }
	  printf (" %-16s  ", name);
	}
      else
	printf (" %-16d  ", q->howto->type);

      if (sym_name)
	{
	  objdump_print_symname (abfd, NULL, *q->sym_ptr_ptr);
	}
      else
	{
	  if (section_name == NULL)
	    section_name = "*unknown*";
	  printf ("[%s]", section_name);
	}

      if (q->addend)
	{
	  bfd_signed_vma addend = q->addend;
	  if (addend < 0)
	    {
	      printf ("-0x");
	      addend = -addend;
	    }
	  else
	    printf ("+0x");
	  bfd_printf_vma (abfd, addend);
	}
      if (addend2)
	{
	  printf ("+0x");
	  bfd_printf_vma (abfd, addend2);
	}

      printf ("\n");
    }

  if (last_filename != NULL)
    free (last_filename);
  if (last_functionname != NULL)
    free (last_functionname);
}

static void
dump_relocs_in_section (bfd *abfd,
			asection *section,
			void *dummy ATTRIBUTE_UNUSED)
{
  arelent **relpp;
  long relcount;
  long relsize;

  if (   bfd_is_abs_section (section)
      || bfd_is_und_section (section)
      || bfd_is_com_section (section)
      || (! process_section_p (section))
      || ((section->flags & SEC_RELOC) == 0))
    return;

  relsize = bfd_get_reloc_upper_bound (abfd, section);
  if (relsize < 0)
    bfd_fatal (bfd_get_filename (abfd));

  printf ("RELOCATION RECORDS FOR [%s]:", section->name);

  if (relsize == 0)
    {
      printf (" (none)\n\n");
      return;
    }

  relpp = (arelent **) xmalloc (relsize);
  relcount = bfd_canonicalize_reloc (abfd, section, relpp, syms);

  if (relcount < 0)
    bfd_fatal (bfd_get_filename (abfd));
  else if (relcount == 0)
    printf (" (none)\n\n");
  else
    {
      printf ("\n");
      dump_reloc_set (abfd, section, relpp, relcount);
      printf ("\n\n");
    }
  free (relpp);
}

static void
dump_relocs (bfd *abfd)
{
  bfd_map_over_sections (abfd, dump_relocs_in_section, NULL);
}

static void
dump_dynamic_relocs (bfd *abfd)
{
  long relsize;
  arelent **relpp;
  long relcount;

  relsize = bfd_get_dynamic_reloc_upper_bound (abfd);
  if (relsize < 0)
    bfd_fatal (bfd_get_filename (abfd));

  printf ("DYNAMIC RELOCATION RECORDS");

  if (relsize == 0)
    printf (" (none)\n\n");
  else
    {
      relpp = (arelent **) xmalloc (relsize);
      relcount = bfd_canonicalize_dynamic_reloc (abfd, relpp, dynsyms);

      if (relcount < 0)
	bfd_fatal (bfd_get_filename (abfd));
      else if (relcount == 0)
	printf (" (none)\n\n");
      else
	{
	  printf ("\n");
	  dump_reloc_set (abfd, NULL, relpp, relcount);
	  printf ("\n\n");
	}
      free (relpp);
    }
}

/* Creates a table of paths, to search for source files.  */

static void
add_include_path (const char *path)
{
  if (path[0] == 0)
    return;
  include_path_count++;
  include_paths = (const char **)
      xrealloc (include_paths, include_path_count * sizeof (*include_paths));
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
  if (path[1] == ':' && path[2] == 0)
    path = concat (path, ".", (const char *) 0);
#endif
  include_paths[include_path_count - 1] = path;
}

static void
adjust_addresses (bfd *abfd ATTRIBUTE_UNUSED,
		  asection *section,
		  void *arg)
{
  if ((section->flags & SEC_DEBUGGING) == 0)
    {
      bfd_boolean *has_reloc_p = (bfd_boolean *) arg;
      section->vma += adjust_section_vma;
      if (*has_reloc_p)
	section->lma += adjust_section_vma;
    }
}

/* Dump selected contents of ABFD.  */

static void
dump_bfd (bfd *abfd)
{
  /* If we are adjusting section VMA's, change them all now.  Changing
     the BFD information is a hack.  However, we must do it, or
     bfd_find_nearest_line will not do the right thing.  */
  if (adjust_section_vma != 0)
    {
      bfd_boolean has_reloc = (abfd->flags & HAS_RELOC);
      bfd_map_over_sections (abfd, adjust_addresses, &has_reloc);
    }

  if (! dump_debugging_tags && ! suppress_bfd_header)
    printf (_("\n%s:     file format %s\n"), bfd_get_filename (abfd),
	    abfd->xvec->name);
  if (dump_ar_hdrs)
    print_arelt_descr (stdout, abfd, TRUE);
  if (dump_file_header)
    dump_bfd_header (abfd);
  if (dump_private_headers)
    dump_bfd_private_header (abfd);
  if (dump_private_options != NULL)
    dump_target_specific (abfd);
  if (! dump_debugging_tags && ! suppress_bfd_header)
    putchar ('\n');

  if (dump_symtab
      || dump_reloc_info
      || disassemble
      || dump_debugging
      || dump_dwarf_section_info)
    syms = slurp_symtab (abfd);

  if (dump_section_headers)
    dump_headers (abfd);

  if (dump_dynamic_symtab || dump_dynamic_reloc_info
      || (disassemble && bfd_get_dynamic_symtab_upper_bound (abfd) > 0))
    dynsyms = slurp_dynamic_symtab (abfd);
  if (disassemble)
    {
      synthcount = bfd_get_synthetic_symtab (abfd, symcount, syms,
					     dynsymcount, dynsyms, &synthsyms);
      if (synthcount < 0)
	synthcount = 0;
    }

  if (dump_symtab)
    dump_symbols (abfd, FALSE);
  if (dump_dynamic_symtab)
    dump_symbols (abfd, TRUE);
  if (dump_dwarf_section_info)
    dump_dwarf (abfd);
  if (dump_stab_section_info)
    dump_stabs (abfd);
  if (dump_reloc_info && ! disassemble)
    dump_relocs (abfd);
  if (dump_dynamic_reloc_info && ! disassemble)
    dump_dynamic_relocs (abfd);
  if (dump_section_contents)
    dump_data (abfd);
  if (disassemble)
    disassemble_data (abfd);

  if (dump_debugging)
    {
      void *dhandle;

      dhandle = read_debugging_info (abfd, syms, symcount, TRUE);
      if (dhandle != NULL)
	{
	  if (!print_debugging_info (stdout, dhandle, abfd, syms,
				     bfd_demangle,
				     dump_debugging_tags ? TRUE : FALSE))
	    {
	      non_fatal (_("%s: printing debugging information failed"),
			 bfd_get_filename (abfd));
	      exit_status = 1;
	    }
	}
      /* PR 6483: If there was no STABS or IEEE debug
	 info in the file, try DWARF instead.  */
      else if (! dump_dwarf_section_info)
	{
	  dwarf_select_sections_all (); 
	  dump_dwarf (abfd);
	}
    }

  if (syms)
    {
      free (syms);
      syms = NULL;
    }

  if (dynsyms)
    {
      free (dynsyms);
      dynsyms = NULL;
    }

  if (synthsyms)
    {
      free (synthsyms);
      synthsyms = NULL;
    }

  symcount = 0;
  dynsymcount = 0;
  synthcount = 0;
}

static void
display_object_bfd (bfd *abfd)
{
  char **matching;

  if (bfd_check_format_matches (abfd, bfd_object, &matching))
    {
      dump_bfd (abfd);
      return;
    }

  if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
    {
      nonfatal (bfd_get_filename (abfd));
      list_matching_formats (matching);
      free (matching);
      return;
    }

  if (bfd_get_error () != bfd_error_file_not_recognized)
    {
      nonfatal (bfd_get_filename (abfd));
      return;
    }

  if (bfd_check_format_matches (abfd, bfd_core, &matching))
    {
      dump_bfd (abfd);
      return;
    }

  nonfatal (bfd_get_filename (abfd));

  if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
    {
      list_matching_formats (matching);
      free (matching);
    }
}

static void
display_any_bfd (bfd *file, int level)
{
  /* Decompress sections unless dumping the section contents.  */
  if (!dump_section_contents)
    file->flags |= BFD_DECOMPRESS;

  /* If the file is an archive, process all of its elements.  */
  if (bfd_check_format (file, bfd_archive))
    {
      bfd *arfile = NULL;
      bfd *last_arfile = NULL;

      if (level == 0)
        printf (_("In archive %s:\n"), bfd_get_filename (file));
      else
        printf (_("In nested archive %s:\n"), bfd_get_filename (file));

      for (;;)
	{
	  bfd_set_error (bfd_error_no_error);

	  arfile = bfd_openr_next_archived_file (file, arfile);
	  if (arfile == NULL)
	    {
	      if (bfd_get_error () != bfd_error_no_more_archived_files)
		nonfatal (bfd_get_filename (file));
	      break;
	    }

	  display_any_bfd (arfile, level + 1);

	  if (last_arfile != NULL)
	    bfd_close (last_arfile);
	  last_arfile = arfile;
	}

      if (last_arfile != NULL)
	bfd_close (last_arfile);
    }
  else
    display_object_bfd (file);
}

static void
display_file (char *filename, char *target)
{
  bfd *file;

  if (get_file_size (filename) < 1)
    {
      exit_status = 1;
      return;
    }

  file = bfd_openr (filename, target);
  if (file == NULL)
    {
      nonfatal (filename);
      return;
    }

  display_any_bfd (file, 0);

  bfd_close (file);
}

int
main (int argc, char **argv)
{
  int c;
  char *target = default_target;
  bfd_boolean seenflag = FALSE;

#if defined (HAVE_SETLOCALE)
#if defined (HAVE_LC_MESSAGES)
  setlocale (LC_MESSAGES, "");
#endif
  setlocale (LC_CTYPE, "");
#endif

  bindtextdomain (PACKAGE, LOCALEDIR);
  textdomain (PACKAGE);

  program_name = *argv;
  xmalloc_set_program_name (program_name);

  START_PROGRESS (program_name, 0);

  expandargv (&argc, &argv);

  bfd_init ();
  set_default_bfd_target ();

  while ((c = getopt_long (argc, argv,
			   "pP:ib:m:M:VvCdDlfFaHhrRtTxsSI:j:wE:zgeGW::",
			   long_options, (int *) 0))
	 != EOF)
    {
      switch (c)
	{
	case 0:
	  break;		/* We've been given a long option.  */
	case 'm':
	  machine = optarg;
	  break;
	case 'M':
	  if (disassembler_options)
	    /* Ignore potential memory leak for now.  */
	    disassembler_options = concat (disassembler_options, ",",
					   optarg, (const char *) NULL);
	  else
	    disassembler_options = optarg;
	  break;
	case 'j':
	  add_only (optarg);
	  break;
	case 'F':
	  display_file_offsets = TRUE;
	  break;
	case 'l':
	  with_line_numbers = TRUE;
	  break;
	case 'b':
	  target = optarg;
	  break;
	case 'C':
	  do_demangle = TRUE;
	  if (optarg != NULL)
	    {
	      enum demangling_styles style;

	      style = cplus_demangle_name_to_style (optarg);
	      if (style == unknown_demangling)
		fatal (_("unknown demangling style `%s'"),
		       optarg);

	      cplus_demangle_set_style (style);
	    }
	  break;
	case 'w':
	  wide_output = TRUE;
	  break;
	case OPTION_ADJUST_VMA:
	  adjust_section_vma = parse_vma (optarg, "--adjust-vma");
	  break;
	case OPTION_START_ADDRESS:
	  start_address = parse_vma (optarg, "--start-address");
	  if ((stop_address != (bfd_vma) -1) && stop_address <= start_address)
	    fatal (_("error: the start address should be before the end address"));
	  break;
	case OPTION_STOP_ADDRESS:
	  stop_address = parse_vma (optarg, "--stop-address");
	  if ((start_address != (bfd_vma) -1) && stop_address <= start_address)
	    fatal (_("error: the stop address should be after the start address"));
	  break;
	case OPTION_PREFIX:
	  prefix = optarg;
	  prefix_length = strlen (prefix);
	  /* Remove an unnecessary trailing '/' */
	  while (IS_DIR_SEPARATOR (prefix[prefix_length - 1]))
	    prefix_length--;
	  break;
	case OPTION_PREFIX_STRIP:
	  prefix_strip = atoi (optarg);
	  if (prefix_strip < 0)
	    fatal (_("error: prefix strip must be non-negative"));
	  break;
	case OPTION_INSN_WIDTH:
	  insn_width = strtoul (optarg, NULL, 0);
	  if (insn_width <= 0)
	    fatal (_("error: instruction width must be positive"));
	  break;
	case 'E':
	  if (strcmp (optarg, "B") == 0)
	    endian = BFD_ENDIAN_BIG;
	  else if (strcmp (optarg, "L") == 0)
	    endian = BFD_ENDIAN_LITTLE;
	  else
	    {
	      nonfatal (_("unrecognized -E option"));
	      usage (stderr, 1);
	    }
	  break;
	case OPTION_ENDIAN:
	  if (strncmp (optarg, "big", strlen (optarg)) == 0)
	    endian = BFD_ENDIAN_BIG;
	  else if (strncmp (optarg, "little", strlen (optarg)) == 0)
	    endian = BFD_ENDIAN_LITTLE;
	  else
	    {
	      non_fatal (_("unrecognized --endian type `%s'"), optarg);
	      exit_status = 1;
	      usage (stderr, 1);
	    }
	  break;

	case 'f':
	  dump_file_header = TRUE;
	  seenflag = TRUE;
	  break;
	case 'i':
	  formats_info = TRUE;
	  seenflag = TRUE;
	  break;
	case 'I':
	  add_include_path (optarg);
	  break;
	case 'p':
	  dump_private_headers = TRUE;
	  seenflag = TRUE;
	  break;
	case 'P':
	  dump_private_options = optarg;
	  seenflag = TRUE;
	  break;
	case 'x':
	  dump_private_headers = TRUE;
	  dump_symtab = TRUE;
	  dump_reloc_info = TRUE;
	  dump_file_header = TRUE;
	  dump_ar_hdrs = TRUE;
	  dump_section_headers = TRUE;
	  seenflag = TRUE;
	  break;
	case 't':
	  dump_symtab = TRUE;
	  seenflag = TRUE;
	  break;
	case 'T':
	  dump_dynamic_symtab = TRUE;
	  seenflag = TRUE;
	  break;
	case 'd':
	  disassemble = TRUE;
	  seenflag = TRUE;
	  break;
	case 'z':
	  disassemble_zeroes = TRUE;
	  break;
	case 'D':
	  disassemble = TRUE;
	  disassemble_all = TRUE;
	  seenflag = TRUE;
	  break;
	case 'S':
	  disassemble = TRUE;
	  with_source_code = TRUE;
	  seenflag = TRUE;
	  break;
	case 'g':
	  dump_debugging = 1;
	  seenflag = TRUE;
	  break;
	case 'e':
	  dump_debugging = 1;
	  dump_debugging_tags = 1;
	  do_demangle = TRUE;
	  seenflag = TRUE;
	  break;
	case 'W':
	  dump_dwarf_section_info = TRUE;
	  seenflag = TRUE;
	  if (optarg)
	    dwarf_select_sections_by_letters (optarg);
	  else
	    dwarf_select_sections_all ();
	  break;
	case OPTION_DWARF:
	  dump_dwarf_section_info = TRUE;
	  seenflag = TRUE;
	  if (optarg)
	    dwarf_select_sections_by_names (optarg);
	  else
	    dwarf_select_sections_all ();
	  break;
	case OPTION_DWARF_DEPTH:
	  {
	    char *cp;
	    dwarf_cutoff_level = strtoul (optarg, & cp, 0);
	  }
	  break;
	case OPTION_DWARF_START:
	  {
	    char *cp;
	    dwarf_start_die = strtoul (optarg, & cp, 0);
	    suppress_bfd_header = 1;
	  }
	  break;
	case OPTION_DWARF_CHECK:
	  dwarf_check = TRUE;
	  break;
	case 'G':
	  dump_stab_section_info = TRUE;
	  seenflag = TRUE;
	  break;
	case 's':
	  dump_section_contents = TRUE;
	  seenflag = TRUE;
	  break;
	case 'r':
	  dump_reloc_info = TRUE;
	  seenflag = TRUE;
	  break;
	case 'R':
	  dump_dynamic_reloc_info = TRUE;
	  seenflag = TRUE;
	  break;
	case 'a':
	  dump_ar_hdrs = TRUE;
	  seenflag = TRUE;
	  break;
	case 'h':
	  dump_section_headers = TRUE;
	  seenflag = TRUE;
	  break;
	case 'v':
	case 'V':
	  show_version = TRUE;
	  seenflag = TRUE;
	  break;

	case 'H':
	  usage (stdout, 0);
	  /* No need to set seenflag or to break - usage() does not return.  */
	default:
	  usage (stderr, 1);
	}
    }

  if (show_version)
    print_version ("objdump");

  if (!seenflag)
    usage (stderr, 2);

  if (formats_info)
    exit_status = display_info ();
  else
    {
      if (optind == argc)
	display_file ("a.out", target);
      else
	for (; optind < argc;)
	  display_file (argv[optind++], target);
    }

  free_only_list ();

  END_PROGRESS (program_name);

  return exit_status;
}
@


1.202
log
@PR binutils/15818
* objdump.c (disassemble_section): Return early if nothing from
this section needs to be disassembled.
@
text
@d2 1
a2 3
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011,
   2012, 2013 Free Software Foundation, Inc.
d194 1
a3658 3
	case 'H':
	  usage (stdout, 0);
	  seenflag = TRUE;
d3665 3
@


1.201
log
@	* objdump.c (dump_target_specific): Fix NULL pointer test.
@
text
@d4 1
a4 1
   2012 Free Software Foundation, Inc.
d1918 21
a1988 18
  if (start_address == (bfd_vma) -1
      || start_address < pinfo->buffer_vma)
    addr_offset = 0;
  else
    addr_offset = start_address - pinfo->buffer_vma;

  if (stop_address == (bfd_vma) -1)
    stop_offset = datasize / opb;
  else
    {
      if (stop_address < pinfo->buffer_vma)
	stop_offset = 0;
      else
	stop_offset = stop_address - pinfo->buffer_vma;
      if (stop_offset > pinfo->buffer_length / opb)
	stop_offset = pinfo->buffer_length / opb;
    }

d1995 1
a1995 2
  if (addr_offset < stop_offset)
    printf (_("\nDisassembly of section %s:\n"), section->name);
@


1.200
log
@binutils/
	* dwarf.c (do_debug_addr, do_debug_cu_index): New global flags.
	(load_debug_info): Fix typo.
	(cu_tu_indexes_read, shndx_pool, shndx_pool_size, shndx_pool_used):
	New global variables.
	(prealloc_cu_tu_list, add_shndx_to_cu_tu_entry, end_cu_tu_entry)
	(process_cu_tu_index, load_cu_tu_indexes, find_cu_tu_set)
	(display_cu_index): New functions.
	(dwarf_select_sections_by_names): Add "debug_addr", "cu_index".
	Sort entries alphabetically.
	(dwarf_select_sections_all): Set do_debug_addr, do_debug_cu_index.
	(debug_displays): Add .debug_cu_index, .debug_tu_index.
	Clean up formatting.
	* dwarf.h (dwarf_section_display_enum): Add dwp_cu_index,
	dwp_tu_index.
	(do_debug_addr, do_debug_cu_index): New global flags.
	(find_cu_tu_set): New function declaration.
	* objdump.c (usage): Add --dwarf=addr, --dwarf=cu_index.
	* readelf.c (find_section_in_set): New function.
	(usage): Add --debug-dump=addr, --debug_dump=cu_index.
	(process_section_headers): Check do_debug_addr and do_debug_cu_index.
	(section_subset): New global variable.
	(load_debug_section): Restrict search to section subset.
	(display_debug_section): Add section index as paramter.  Select subset
	of sections when dumping a .dwp file.  Update caller.
@
text
@d2654 1
a2654 1
  if (desc == NULL)
@


1.199
log
@Handle x32 in dump_dwarf

	* objdump.c (dump_dwarf): Handle bfd_mach_x64_32 and
	bfd_mach_x64_32_intel_syntax.
@
text
@d219 2
a220 1
          =gdb_index,=trace_info,=trace_abbrev,=trace_aranges]\n\
@


1.198
log
@bfd/
	* compress.c (bfd_cache_section_contents): New function.
	* bfd-in2.h: Regenerate.
binutils/
	* objdump.c (load_specific_debug_section): Use
	bfd_cache_section_contents.
@
text
@d2395 2
@


1.197
log
@ChangeLog bfd

2012-10-18  Kai Tietz  <ktietz@@redhat.com>

	PR binutils/14067
	* coff-i386.c (bfd_target): Add section flag SEC_EXCLUDE.
	Allow BFD_COMPRESS and BFD_DECOMPRESS flags.
	* coff-x86_64.c: Likewise.
	* coffcode.h (DOT_ZDEBUG): New define.
	(sec_to_styp_flags): Check for .zdebug.
	(styp_to_sec_flags): Likewise.
	* coffgen.c (make_a_section): Handle .debug_* section
	compression/decompression flags.
	* cofflink.c (mark_relocs): Ignore relocations
	for a section, which isn't marked as used.
	(_bfd_coff_link_input_bfd): Add support of compressed
	debug sections.
	* compress.c (decompress_contents): Loop as long
	as there is input available and there is room for
	output.
	* bfd/pe-arm.c: Add .zdebug_ partial match entry.
	* pe-i386.c: Likewise.
	* pe-x86_64.c: Likewise.
	* peXXigen.c (_bfd_XXi_swap_aouthdr_out): Don't clear all
	data-directories as this might destroy content.

        * coff-i386.c (_bfd_generic_find_nearest_line_discriminator):
        define as coff_find_nearest_line_discriminator.
        * libcoff-in.h (coff_find_nearest_line_discriminator): New
        * libcoff.h: Regenerated.
        * coff-x86_64.c: Likewise.
        * coffgen.c (coff_find_nearest_line_discriminator): New function.
        prototype.

ChangeLog binutils

2012-10-18  Kai Tietz  <ktietz@@redhat.com>

	* objdump.c (dump_bfd): Call dump headers after
	call of slurp_symtab.

ChangeLog ld

2012-10-18  Kai Tietz  <ktietz@@redhat.com>

	PR binutils/14067
	* NEWS: Menition new feature.
	* scripttempl/pep.sc: Add zdebug sections.
	* scripttempl/pe.sc: L
@
text
@d2275 1
a2275 7
      /* We want to relocate the data we've already read (and
         decompressed), so we store a pointer to the data in
         the bfd_section, and tell it that the contents are
         already in memory.  */
      sec->contents = section->start;
      sec->flags |= SEC_IN_MEMORY;
      sec->size = section->size;
@


1.196
log
@typo fixes
@
text
@a3217 2
  if (dump_section_headers)
    dump_headers (abfd);
d3225 4
@


1.195
log
@2012-07-24  Teresa Johnson  <tejohnson@@google.com>

bfd/
	* bfd.c (bfd_find_nearest_line_discriminator): New macro.
	* coff-rs6000.c: Init _bfd_find_nearest_line_discriminator.
	* coff64-rs6000.c: Likewise.
	* dwarf2.c (struct line_info): Add discriminator field.
	(add_line_info): Fill in new discriminator field.
	(decode_line_info): Record discriminator information instead
        of ignoring it.
	(lookup_address_in_line_info_table): Return discriminator field if
        requested.
	(comp_unit_find_nearest_line): Add discriminator argument.
	(find_line): Likewise.
	(_bfd_dwarf2_find_nearest_line): Likewise.
	(_bfd_dwarf2_find_line): Likewise.
	* elf-bfd.h (_bfd_elf_find_nearest_line_discriminator): New.
        (_bfd_elf_find_line_discriminator): Likewise.
        (_bfd_generic_find_nearest_line_discriminator): Likewise. Defined.
	* elf.c (_bfd_elf_find_nearest_line): Change to a wrapper
        that invokes _bfd_elf_find_nearest_line_discriminator with correct
        arguments.
	(_bfd_elf_find_nearest_line_discriminator): New.
	(_bfd_elf_find_line): Change to a wrapper
        that invokes _bfd_elf_find_line_discriminator with correct
        arguments.
	(_bfd_elf_find_line_discriminator): New.
	* coffgen.c (coff_find_nearest_line_with_names): Handle
        new discriminator argument.
	* elf32-arm.c (elf32_arm_find_nearest_line): Likewise.
	* elf64-alpha.c (elf64_alpha_find_nearest_line): Likewise.
	* elfxx-mips.c (_bfd_mips_elf_find_nearest_line): Likewise.
	* mach-o.c (bfd_mach_o_find_nearest_line): Likewise.
	* libbfd-in.h (_bfd_dwarf2_find_nearest_line): Add discriminator
        argument.
        (_bfd_dwarf2_find_line): Likewise.
        (_bfd_generic_find_nearest_line_discriminator): New.
	* libbfd.c (_bfd_generic_find_nearest_line_discriminator): New.
	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.
	* targets.c (BFD_JUMP_TABLE_SYMBOLS): Initialize
        _bfd_find_nearest_line_discriminator with
        _bfd_generic_find_nearest_line_discriminator.
        (bfd_target): Add _bfd_find_nearest_line_discriminator.

binutils/
	* addr2line.c (find_address_in_section): Invoke
        bfd_find_nearest_line_discriminator to get the discriminator.
	(find_offset_in_section): Likewise.
	(translate_addresses): Print discriminator if it is non-zero.
	* objdump.c (show_line): Invoke
        bfd_find_nearest_line_discriminator to get the discriminator,
        and keep track of prev_discriminator. Print discriminator
        if it is non-zero.
	(disassemble_data): Initialize prev_discriminator.
	(dump_reloc_set): Invoke bfd_find_nearest_line_discriminator
        to get the discriminator, and keep track of last_discriminator.
        Print discriminator if it is non-zero.
@
text
@d1238 1
a1238 1
/* If the the source file, as described in the symtab, is not found
@


1.195.2.1
log
@binutils/
2012-10-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* objdump.c (dump_dwarf): Handle bfd_mach_x64_32 and
	bfd_mach_x64_32_intel_syntax.
@
text
@a2400 2
	case bfd_mach_x64_32:
	case bfd_mach_x64_32_intel_syntax:
@


1.194
log
@Print addend as signed in objdump

binutils/

	* objdump.c (disassemble_bytes): Print addend as signed.
	(dump_reloc_set): Likewise.

gas/testsuite/

	* gas/all/fwdexp.d: Expect addend as signed.
	* gas/alpha/elf-reloc-1.d: Likewise.
	* gas/i386/mixed-mode-reloc64.d: Likewise.
	* gas/i386/reloc64.d: Likewise.
	* gas/i386/ilp32/mixed-mode-reloc64.d: Expect addend as signed.
	* gas/i386/ilp32/reloc64.d: Likewise.
	* gas/ia64/pcrel.d: Likewise.
	* gas/mips/branch-misc-2-64.d: Likewise.
	* gas/mips/branch-misc-2pic-64.d: Likewise.
	* gas/mips/branch-misc-4-64.d: Likewise.
	* gas/mips/ldstla-n64-sym32.d: Likewise.
	* gas/mips/micromips@@branch-misc-2-64.d: Likewise.
	* gas/mips/micromips@@branch-misc-2pic-64.d: Likewise.
	* gas/mips/micromips@@branch-misc-4-64.d: Likewise.
	* gas/mips/mips16-hilo-n32.d: Likewise.
	* gas/ppc/astest.d: Likewise.
	* gas/ppc/astest2.d: Likewise.
	* gas/ppc/astest2_64.d: Likewise.
	* gas/ppc/astest64.d: Likewise.
	* gas/ppc/test1elf32.d: Likewise.
	* gas/ppc/test1elf64.d: Likewise.
	* gas/sparc/reloc64.d: Likewise.
@
text
@d1089 1
d1316 1
d1322 3
a1324 2
  if (! bfd_find_nearest_line (abfd, section, syms, addr_offset, &filename,
			       &functionname, &linenumber))
d1376 9
a1384 2
      if (linenumber > 0 && linenumber != prev_line)
	printf ("%s:%u\n", filename == NULL ? "???" : filename, linenumber);
d1436 3
d2131 1
d2912 1
d2931 1
d2938 1
d2952 3
a2954 2
	  && bfd_find_nearest_line (abfd, sec, syms, q->address,
				    &filename, &functionname, &linenumber))
d2970 2
a2971 1
		      && filename_cmp (filename, last_filename) != 0)))
d2973 5
a2977 1
	      printf ("%s:%u\n", filename == NULL ? "???" : filename, linenumber);
d2979 1
@


1.193
log
@	* doc/binutils.texi: Add --dwarf-check option.
	* dwarf.c (dwarf_check): New global flag.
	(fetch_indexed_string): New function.
	(fetch_indexed_value): New function.
	(get_FORM_name): Add DW_FORM_GNU_str_index and DW_FORM_GNU_addr_index.
	(decode_location_expression): Add DW_OP_GNU_addr_index.
	(read_and_display_attr_value): Add DW_FORM_GNU_str_index,
	DW_FORM_GNU_addr_index, DW_AT_GNU_addr_base, and DW_AT_GNU_ranges_base.
	(get_AT_name): Add new attributes for Fission.
	(process_debug_info): Load new debug sections for Fission.
	(load_debug_info): Check for .debug_info.dwo section.
	(display_loc_list, display_loc_list_dwo): New functions.
	(display_debug_loc): Move logic to above two functions.
	(display_debug_info): Choose abbrev section based on info section.
	(display_debug_types): Likewise.
	(display_trace_info): Likewise.
	(comp_addr_base): New function.
	(display_debug_addr): New function.
	(display_debug_str_offsets): New function.
	(display_debug_ranges): Allow missing range lists.  Suppress
	diagnostics if dwarf_check not set.
	(debug_displays): Add column to select abbrev section.
	* dwarf.h (enum dwarf_section_display_enum): Add new debug sections
	for Fission.
	(struct dwarf_section): Add abbrev_sec field.
	(struct dwarf_section_display): New type.
	(debug_info): Add addr_base, ranges_base fields.
	(dwarf_check): New global variable.
	* objdump.c (usage): Add --dwarf-check option.
	(enum option_values): Add OPTION_DWARF_CHECK.
	(long_options): Add --dwarf-check.
	(main): Likewise.
	* readelf.c (OPTION_DWARF_CHECK): New macro.
	(options): Add --dwarf-check.
	(parse_args): Likewise.
	(process_section_headers): Use const_strneq instead of
	streq.
@
text
@d1843 9
a1851 2
		  printf ("+0x");
		  objdump_print_value (q->addend, inf, TRUE);
d3027 9
a3035 2
	  printf ("+0x");
	  bfd_printf_vma (abfd, q->addend);
@


1.192
log
@        * objdump.c (dump_bfd): If defaulting to dwarf call
        dwarf_select_sections_all to enable displays.
@
text
@d264 3
a266 1
                             or deeper\n\n"));
d297 1
d349 1
d3594 3
@


1.191
log
@	* objdump.c (slurp_file): Close file if fstat fails.
@
text
@d3233 1
@


1.190
log
@	* sysdep.h: Include sys/stat.h here.
	* ar.c: Don't include headers already included by sysdep.h.
	* bucomm.c: Likewise.
	* budbg.h: Likewise.
	* dlltool.h: Likewise.
	* elfedit.c: Likewise.
	* nlmconv.c: Likewise.
	* objcopy.c: Likewise.
	* objdump.c: Likewise.
	* objdump.h: Likewise.
	* readelf.c: Likewise.
	* rename.c: Likewise.
	* resrc.c: Likewise.
	* strings.c: Likewise.
	* windres.c: Likewise.
	* od-macho.c: Ensure #include sysdep.h is first.
	* od-xcoff.c: Likewise.
	* dllwrap.c: Remove alloca pragma handled by sysdep.h, and
	remove duplicate headers.
	* dlltool.c: Likewise and ensure #include sysdep.h is first.
@
text
@d1126 4
a1129 1
    return NULL;
d1134 1
a1134 1
  if (map != (char *)-1L)
d1136 2
a1137 2
      close(fd);
      return map; 
d1141 3
a1143 3
  if (!map || (size_t) read (fd, (char *)map, *size) != *size) 
    { 
      free ((void *)map);
d1147 1
a1147 1
  return map; 
@


1.189
log
@2012-01-10  Tristan Gingold  <gingold@@adacore.com>

	* objdump.c (display_object_bfd): Renamed from ...
	(display_bfd): ... this.
	(display_any_bfd): New function.
	(display_file): Split.  Handle nested archives.
@
text
@d3 2
a4 2
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010, 2011
   Free Software Foundation, Inc.
a73 2
#include <sys/stat.h>

@


1.188
log
@2011-05-16  Tristan Gingold  <gingold@@adacore.com>

	* od-xcoff.c: New file.
	* objdump.h: New file.
	* objdump.c: Include objdump.h
	(dump_private_options, objdump_private_vectors): New variables.
	(usage): Mention -P/--private.  Display handled options.
	(long_options): Add -P/--private.
	(dump_target_specific): New function.
	(dump_bfd): Handle dump_private_options.
	(main): Handle -P.
	* doc/binutils.texi (objdump): Document -P/--private.
	* configure.in (OBJDUMP_PRIVATE_VECTORS, OBJDUMP_PRIVATE_OFILES):
	New variables, compute them.
	(od_vectors): Add vectors for private dumpers. Make them uniq.
	(OBJDUMP_DEFS): Add OBJDUMP_PRIVATE_VECTORS.
	* Makefile.am (HFILES): Add objdump.h
	(CFILES): Add od-xcoff.c
	(OBJDUMP_PRIVATE_OFILES): New variable.
	(objdump_DEPENDENCIES): Append OBJDUMP_PRIVATE_OFILES.
	(objdump_LDADD): Ditto.
	(EXTRA_objdump_SOURCES): Define.
	* Makefile.in: Regenerate.
	* configure: Regenerate.
@
text
@d3260 1
a3260 1
display_bfd (bfd *abfd)
d3300 1
a3300 1
display_file (char *filename, char *target)
a3301 16
  bfd *file;
  bfd *arfile = NULL;

  if (get_file_size (filename) < 1)
    {
      exit_status = 1;
      return;
    }

  file = bfd_openr (filename, target);
  if (file == NULL)
    {
      nonfatal (filename);
      return;
    }

d3309 1
d3312 5
a3316 1
      printf (_("In archive %s:\n"), bfd_get_filename (file));
d3329 1
a3329 1
	  display_bfd (arfile);
d3340 22
a3361 1
    display_bfd (file);
@


1.187
log
@	* NEWS: Add note about --dwarf-depth, --dwarf-start, and
	dwarf-mode.el.
	* objdump.c (suppress_bfd_header): New global.
	(usage): Update.
	(OPTION_DWARF_DEPTH, OPTION_DWARF_START): New constants.
	(options): Add dwarf-depth and dwarf-start entries.
	(dump_bfd): Use suppress_bfd_header.
	(main): Handle OPTION_DWARF_START, OPTION_DWARF_DEPTH.
	* doc/binutils.texi (objcopy): Document --dwarf-depth and
	--dwarf-start.
	(readelf): Likewise.
	* dwarf-mode.el: New file.
	* dwarf.c (dwarf_cutoff_level, dwarf_start_die): New globals.
	(read_and_display_attr_value): Also check debug_info_p.
	(process_debug_info): Handle dwarf_start_die and
	dwarf_cutoff_level.
	* dwarf.h (dwarf_cutoff_level, dwarf_start_die): Declare.
	* readelf.c (usage): Update.
	(OPTION_DWARF_DEPTH): New macro.
	(OPTION_DWARF_START): Likewise.
	(options): Add dwarf-depth and dwarf-start entries.
	(parse_args): Handle OPTION_DWARF_START and OPTION_DWARF_DEPTH.
testsuite
	* binutils-all/objdump.W: Correct output.
@
text
@d68 1
d97 1
d190 7
d208 1
d234 2
d271 8
d305 1
d2619 51
d3171 2
d3384 1
a3384 1
			   "pib:m:M:VvCdDlfFaHhrRtTxsSI:j:wE:zgeGW::",
d3501 4
@


1.186
log
@binutils/

	* objdump.c (dump_reloc_set): Output R_SPARC_OLO10 relocations
	accurately, rather than how they are represented internally.
@
text
@d113 1
d250 5
a254 2
      --prefix-strip=LEVEL       Strip initial directory names for -S\n\
\n"));
d275 3
a277 1
    OPTION_ADJUST_VMA
d325 2
d3090 1
a3090 1
  if (! dump_debugging_tags)
d3099 1
a3099 1
  if (! dump_debugging_tags)
d3487 13
@


1.185
log
@	* objdump.c (dump_reloc_set): Free malloced memory.
@
text
@d2832 1
d2888 31
a2918 1
	printf (" %-16s  ", q->howto->name);
d2938 5
@


1.184
log
@objdump: fix typo in help message
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009, 2010
d2910 5
@


1.183
log
@ChangeLog binutils/
2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* debug.c (debug_start_source): Use filename_(n)cmp.
	* ieee.c (ieee_finish_compilation_unit): Likewise.
	(ieee_lineno): Likewise.
	* nlmconv.c (main): Likewise.
	* objcopy.c (strip_main): Likewise.
	(copy_main): Likewise.
	* objdump.c (show_line): Likewise.
	(dump_reloc_set): Likewise.
	* srconv.c (main): Likewise.
	* wrstabs.c (stab_lineno): Likewise.

ChangeLog gas/
2011-02-28  Kai Tietz  <kai.tietz@@onevision.com>

	* depend.c (register_dependency): Use filename_(n)cmp.
	* dwarf2dbg.c (get_filenum): Likewise.
	* ecoff.c (add_file): Likewise.
	(ecoff_generate_asm_lineno): Likewise.
	* input-scrub.c (new_logical_line_flags): Likewise.
	* listing.c (file_info): Likewise.
	(listing_newline): Likewise.
	* remap.c (remap_debug_filename): Likewise.
	* stabs.c (generate_asm_file): Likewise.
	(stabs_generate_asm_lineno): Likewise.
@
text
@d245 1
a245 1
      --insn-width=WIDTH         Display WIDTH bytes on a signle line for -d\n\
@


1.182
log
@	* dwarf.c: #include "bfd_stdint.h".
	(do_gdb_index): New global.
	(display_gdb_index): New function.
	(dwarf_select_sections_by_names) Add "gdb_index".
	(dwarf_select_sections_all): Set do_gdb_index.
	(debug_displays): Add .gdb_index.
	* dwarf.h (do_gdb_index): Declare.
	* objdump.c (usage): Add gdb_index.
	* readelf.c (usage): Add gdb_index.
	(process_section_headers): Process ".gdb_index".
	* doc/binutils.texi (readelf): Document gdb_index dump.
	(objdump): Ditto.
@
text
@d1351 1
a1351 1
	if (strcmp ((*pp)->filename, filename) == 0)
d2859 1
a2859 1
		      && strcmp (filename, last_filename) != 0)))
@


1.181
log
@Add and use elfcomm.c/elfcomm.h.

2010-11-21  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/12235
	* elfcomm.c: New.
	* elfcomm.h: Likewise.

	* Makefile.am (HFILES): Add elfcomm.h.
	(CFILES): Add elfcomm.c.
	(ELFLIBS): New.
	(readelf_SOURCES): Add $(ELFLIBS).
	(elfedit_SOURCES): Likewise.
	(objdump_SOURCES): Likewise.
	* Makefile.in: Regenerated.

	* dwarf.c: Include "elfcomm.h".
	(byte_get): Removed.
	(byte_get_little_endian): Likewise.
	(byte_get_big_endian): Likewise.
	(byte_get_signed): Likewise.
	(error): Likewise.
	(warn): Likewise.

	* dwarf.h (dwarf_vma): Defined with HOST_WIDEST_INT.
	(dwarf_size_type): Likewise.
	(byte_get): Removed.
	(byte_get_signed): Likewise.
	(byte_get_little_endian): Likewise.
	(byte_get_big_endian): Likewise.
	(error): Likewise.
	(warn): Likewise.

	* elfedit.c: Include "elfcomm.h".  Don't include "aout/ar.h".
	Call error () instead of non_fatal ().
	(streq): Removed.
	(strneq): Likewise.
	(const_strneq): Likewise.
	(non_fatal): Likewise.
	(BYTE_GET): Likewise.
	(BYTE_PUT): Likewise.
	(byte_get): Likewise.
	(byte_put): Likewise.
	(byte_get_little_endian): Likewise.
	(byte_get_big_endian): Likewise.
	(byte_put_little_endian): Likewise.
	(byte_put_big_endian): Likewise.
	(adjust_relative_path): Likewise.
	(archive_info): Likewise.
	(setup_archive): Likewise.
	(release_archive): Likewise.
	(setup_nested_archive): Likewise.
	(get_archive_member_name): Likewise.
	(get_archive_member_name_at): Likewise.
	(make_qualified_name): Likewise.

	* objdump.c: Include "elfcomm.h".

	* readelf.c: Include "elfcomm.h".  Don't include "aout/ar.h".
	(BYTE_GET): Removed.
	(BYTE_GET_SIGNED): Removed.
	(streq): Likewise.
	(strneq): Likewise.
	(const_strneq): Likewise.
	(byte_put): Likewise.
	(byte_put_little_endian): Likewise.
	(byte_put_big_endian): Likewise.
	(adjust_relative_path): Likewise.
	(archive_info): Likewise.
	(setup_archive): Likewise.
	(release_archive): Likewise.
	(setup_nested_archive): Likewise.
	(get_archive_member_name): Likewise.
	(get_archive_member_name_at): Likewise.
	(make_qualified_name): Likewise.
@
text
@d210 1
a210 1
          =trace_info,=trace_abbrev,=trace_aranges]\n\
@


1.180
log
@	* ar.c (print_contents): Don't internationalize strings without words.
	* dwarf.c (process_extended_line_op): Likewise.
	(process_debug_info): Likwise.
	(display_debug_lines_raw): Likewise.
	(display_debug_lines_decoded): Likewise.
	(display_debug_abbrev): Likewise.
	* readelf.c (process_file_header): Likewise.
	(GET_OP): Likewise.
	(decode_arm_unwind): Likewise.
	(process_mips_specific): Likewise.
	* resrc.c (run_cmd): Likewise.
	(rcparse_warning): Likewise.
	* objdump.c (dump_headers): Don't print "Pg".
@
text
@d58 1
@


1.179
log
@Don't display bits only used for BFD in abfd->flags.

bfd/

2010-11-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* bfd.c (BFD_FLAGS_FOR_BFD_USE_MASK): New.
	* bfd-in2.h: Regenerated.

binutils/

2010-11-02  H.J. Lu  <hongjiu.lu@@intel.com>

	* objdump.c (dump_bfd_header): Don't display
	BFD_FLAGS_FOR_BFD_USE_MASK bits in abfd->flags.
@
text
@a513 2
  if (abfd->flags & HAS_LOAD_PAGE)
    printf (_("  Pg"));
@


1.179.2.1
log
@backport from mainline
@
text
@a57 1
#include "elfcomm.h"
d209 1
a209 1
          =gdb_index,=trace_info,=trace_abbrev,=trace_aranges]\n\
d514 2
@


1.178
log
@Add compressed debug section support to binutils and ld.

bfd/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>
	    Cary Coutant  <ccoutant@@google.com>

	* archive.c (bfd_openr_next_archived_file): Copy BFD_COMPRESS
	and BFD_DECOMPRESS.

	* bfd.c (BFD_COMPRESS): New.
	(BFD_DECOMPRESS): Likewise.
	(BFD_FLAGS_SAVED): Likewise.
	(bfd_preserve_save): Replace BFD_IN_MEMORY with BFD_FLAGS_SAVED.

	* compress.c (bfd_uncompress_section_contents): Removed.
	(get_uncompressed_size): New.
	(decompress_contents): Likewise.
	(bfd_compress_section_contents): Likewise.
	(bfd_get_full_section_contents): Likewise.
	(bfd_is_section_compressed): Likewise.
	(bfd_init_section_decompress_status): Likewise.
	(bfd_init_section_compress_status): Likewise.

	* dwarf2.c (dwarf_debug_sections): New.
	(dwarf_debug_section_enum): Likewise.
	(read_section): Remove section_name and compressed_section_name.
	Add dwarf_debug_section_enum.  Try compressed debug section.
	(read_indirect_string): Updated.
	(read_abbrevs): Likewise.
	(decode_line_info): Likewise.
	(read_debug_ranges): Likewise.
	(find_line): Updated.

	* ecoff.c (bfd_debug_section): Add compress_status and
	compressed_size.

	* elf.c (_bfd_elf_make_section_from_shdr): Call
	bfd_is_section_compressed to check if a DWARF debug section is
	compressed.  Call bfd_init_section_compress_status or
	bfd_init_section_decompress_status if needed.

	* elflink.c (elf_link_input_bfd): Replace bfd_get_section_contents
	with bfd_get_full_section_contents.
	* merge.c (_bfd_add_merge_section): Likewise.
	* reloc.c (bfd_generic_get_relocated_section_contents): Likewise.
	* simple.c (bfd_simple_get_relocated_section_contents): Likewise.

	* elfxx-target.h (TARGET_BIG_SYM): Allow BFD_COMPRESS and
	BFD_DECOMPRESS.
	(TARGET_LITTLE_SYM): Likewise.

	* libbfd-in.h (dwarf_debug_section): New.
	(dwarf_debug_sections): Likewise.

	* libbfd.c (_bfd_generic_get_section_contents): Issue an error
	when getting contents on compressed/decompressed section.

	* section.c (COMPRESS_SECTION_NONE): New.
	(COMPRESS_SECTION_DONE): Likewise.
	(DECOMPRESS_SECTION_SIZED): Likewise.
	(BFD_FAKE_SECTION): Add compress_status and compressed_size.
	(bfd_malloc_and_get_section): Replace bfd_get_section_contents
	with bfd_get_full_section_contents.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.

binutils/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* addr2line.c (process_file): Set BFD_DECOMPRESS.

	* objcopy.c (do_debug_sections): New.
	(OPTION_COMPRESS_DEBUG_SECTIONS): New.
	(OPTION_DECOMPRESS_DEBUG_SECTIONS): Likewise.
	(copy_options): Add OPTION_COMPRESS_DEBUG_SECTIONS and
	OPTION_DECOMPRESS_DEBUG_SECTIONS.
	(copy_usage): Add --compress-debug-sections and
	--decompress-debug-sections.
	(copy_file): Set BFD_COMPRESS or BFD_DECOMPRESS.
	(copy_section): Replace bfd_get_section_contents with
	bfd_get_full_section_contents.
	(copy_main): Handle OPTION_COMPRESS_DEBUG_SECTIONS and
	OPTION_DECOMPRESS_DEBUG_SECTIONS.  Check do_debug_sections to
	rename DWARF debug sections.

	* objdump.c (load_specific_debug_section): Replace
	bfd_get_section_contents with bfd_get_full_section_contents.
	Remove bfd_uncompress_section_contents.
	(dump_section): Replace bfd_get_section_contents with
	bfd_get_full_section_contents.
	(display_file): Set BFD_DECOMPRESS if needed.

	* readelf.c (uncompress_section_contents): Set buffer to NULL
	to indiate decompression failure.
	(load_specific_debug_section): Always call
	uncompress_section_contents.

	* doc/binutils.texi: Document --compress-debug-sections and
	--decompress-debug-sections.

binutils/testsuite/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* binutils-all/compress.exp: New.
	* binutils-all/dw2-1.S: Likewise.
	* binutils-all/dw2-2.S: Likewise.
	* binutils-all/libdw2-compressed.out: Likewise.
	* binutils-all/libdw2.out: Likewise.

gas/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* write.c (compress_debug): Optimize section flags check.

gas/testsuite/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* elf/dwarf2-1.s: Replace .zdebug_abbrev section with
	.debug_abbrev section.
	* elf/dwarf2-2.3: Likewise.

	* elf/dwarf2-1.d: Pass --compress-debug-sections to assembler.
	Updated.
	* elf/dwarf2-2.d: Likewise.

	* gas/i386/i386.exp: Remove xfail on dw2-compress-2 and
	x86-64-dw2-compress-2.

ld/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldfile.c (ldfile_try_open_bfd): Set BFD_DECOMPRESS after
	bfd_openr returns.
	* emultempl/elf32.em (gld${EMULATION_NAME}_try_needed): Likewise.

	* scripttempl/elf.sc: Include compressed DWARF debug sections.

ld/testsuite/

2010-10-29  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-elf/compress.exp: New.
	* ld-elf/compress1.s: Likewise.
	* ld-elf/compress1a.d: Likewise.
	* ld-elf/compress1b.d: Likewise.
	* ld-elf/compress1c.d: Likewise.
@
text
@d2565 1
a2565 1
  printf (_("flags 0x%08x:\n"), abfd->flags);
@


1.177
log
@	* bucomm.c (bfd_nonfatal): Flush stdout before output to stderr.
	(bfd_nonfatal_message, report, list_matching_formats): Likewise.
	(list_supported_targets): Tidy.
	* objdump.c (free_only_list): Formatting.
	(slurp_dynamic_symtab): Non-zero exit status for "not a dynamic
	object".
	(update_source_path): Delete redundant check for NULL filename.
	(disassemble_bytes): Error if disassemble_fn returns a value
	that won't increment address.
	(disassemble_data): Don't capitalize error message.
	(read_section_stabs): Likewise.
	(main): Return non-zero exit status on bad options.
@
text
@a2200 1
  int section_is_compressed;
a2205 2
  section_is_compressed = section->name == section->compressed_name;

d2208 2
a2209 4
  section->start = (unsigned char *) xmalloc (section->size);

  ret = bfd_get_section_contents (abfd, sec, section->start, 0,
				  section->size);
a2218 12
  if (section_is_compressed)
    {
      bfd_size_type size = section->size;
      if (! bfd_uncompress_section_contents (&section->start, &size))
        {
          free_debug_section (debug);
          printf (_("\nCan't uncompress section '%s'.\n"), section->name);
          return 0;
        }
      section->size = size;
    }

d2648 5
a2652 3
  data = (bfd_byte *) xmalloc (datasize);

  bfd_get_section_contents (abfd, section, data, 0, datasize);
d3196 4
@


1.176
log
@	* dwarf.c (init_dwarf_regnames_i386, init_dwarf_regnames_x86_64): New.
	(init_dwarf_regnames): Use them.
	* dwarf.h: Declare them.
	* objdump.c (dump_dwarf): Use bfd_get_arch + bfd_get_mach to set up
	the regnames, rather than using elf_machine_code.
@
text
@d396 2
a397 1
	  non_fatal (_("Section '%s' mentioned in a -j option, but not found in any input file"),
d559 1
a1214 3
  if (filename == NULL)
    return NULL;

d1628 1
a1628 1
	      if (octets < 0)
d1632 6
d2115 1
a2115 1
	fatal (_("Can't use supplied machine %s"), machine);
d2134 1
a2134 1
      non_fatal (_("Can't disassemble for architecture %s\n"),
d2404 1
a2404 1
      non_fatal (_("Reading %s section of %s failed: %s"),
d2407 1
a2408 1
      exit_status = 1;
d3358 1
a3358 1
	      non_fatal (_("unrecognized -E option"));
d3370 1
@


1.175
log
@        * objdump.c (dump_dwarf): Use bfd_arch_bits_per_address.
@
text
@d2352 1
a2352 1
  if (bfd_get_flavour (abfd) == bfd_target_elf_flavour)
d2354 16
a2369 2
      const struct elf_backend_data *bed = get_elf_backend_data (abfd);
      init_dwarf_regnames (bed->elf_machine_code);
@


1.174
log
@bfd/ChangeLog:

	* compress.c (bfd_uncompress_section_contents): Add ATTRIBUTE_UNUSED.
	* dwarf2.c (read_and_uncompress_section): New function.
	(read_section): Call it.
	(find_line): Likewise.

binutils/ChangeLog:

	* objdump.c (load_specific_debug_section): Decompress section contents
	before applying relocations.
	* readelf.c (load_specific_debug_section): Update section size after
	decompression.

gas/ChangeLog:

	* Makefile.am: Add compress-debug.c and compress-debug.h.
	* Makefile.in: Regenerate.
	* config.in: Add HAVE_ZLIB_H.
	* configure.in: Check for zlib.h.
	* configure: Regenerate.

	* as.c (parse_args): Add --compress-debug-sections and
	--nocompress-debug-sections.
	* as.h (flag_compress_debug): New variable.
	* compress-debug.c: New file.
	* compress-debug.h: New file.
	* write.c: Include compress-debug.h.
	(compress_frag): New function.
	(compress_debug): New function.
	(write_object_file): Compress debug sections if requested.
@
text
@d2343 1
a2343 3
  /* FIXME: bfd_get_arch_size may return -1.  We assume that 64bit
     targets will return 64.  */
  eh_addr_size = bfd_get_arch_size (abfd) == 64 ? 8 : 4;
@


1.173
log
@2010-05-24  Tristan Gingold  <gingold@@adacore.com>

	* readelf.c (usage): Add new trace sections for --debug-dump.
	(process_section_headers): Handle dump of trace sections.
	* objdump.c (usage): Add new trace sections for --dwarf.
	* dwarf.h (do_trace_info, do_trace_abbrevs): New variables.
	(do_trace_aranges): Ditto.
	(enum dwarf_section_display_enum): Add trace_info, trace_abbrev
	and trace_aranges literals.
	* dwarf.c (do_trace_info, do_trace_abbrevs): New variables.
	(do_trace_aranges): Ditto.
	(process_debug_info): Add abbrev_sec argument and replace
	abbrev with abbrev_sec.
	(load_debug_info): Adjust call of process_debug_info.
	(display_debug_info): Ditto.
	(display_trace_info): New function.
	(dwarf_select_sections_by_names): Add trace_info, trace_abbrevs
	and trace_aranges sections name.
	(dwarf_select_sections_all): Also select trace sections.
	(debug_displays): Reindent.  Add entries for the trace sections.
	* doc/binutils.texi (readelf): Document new --dwarf parameters.
	(objdump): Ditto.
@
text
@d2208 2
a2209 8
  if (is_relocatable && debug_displays [debug].relocate)
    ret = bfd_simple_get_relocated_section_contents (abfd,
						     sec,
						     section->start,
						     syms) != NULL;
  else
    ret = bfd_get_section_contents (abfd, sec, section->start, 0,
				    section->size);
d2231 24
@


1.172
log
@bfd/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * aoutx.h (aout_link_input_bfd): Remove unused variable sym_count.
        * elf-eh-frame.c (_bfd_elf_eh_frame_section_offset): Remove unused
        variables htab and hdr_info and mark info parameter as unused.
        * elf.c (prep_headers): Remove unused variable i_phdrp.
        (_bfd_elf_write_object_contents): Remove unused variable i_ehdrp.
        * elf32-i386.c (elf_i386_relocate_section): Mark variabled warned
        as unused.
        * peXXigen.c (pe_print_reloc): Remove unused variable datasize.
        * verilog.c (verilog_write_section): Remove unused variable
        address.

binutils/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * dwarf.c (process_debug_info): Remove unused variable
        cu_abbrev_offset_ptr.
        (display_debug_lines_decoded): Remove unused variable prev_line.
        * elfedit.c (process_archive): Remove unused variable
        file_name_size.
        * ieee.c (ieee_start_compilation_unit): Remove unused variable
        nindx.
        (ieee_set_type): Remove unused variables info, targetindx and
        baseindx.
        * objdump.c (disassmble_byte): Remove unused variable done_dot.
        * rddbg.c (read_section_stabs_debugging_info): Remove unused
        variable other.
        * readelf.c (dump_section_as_strings): Remove unused variable
        addr.
        (process_archive): Remove unused variable file_name_size.
        * stabs.c (parse_stab_string): Mark desc parameter as unused.
        Remove unused variable lineno.
        (parse_stab_struct_type): Remove unused variable orig.
        (stab_demangle_type): Remove unused variables constp, volatilep
        and hold.

gas/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * as.c (create_obj_attrs_section): Remove unused variable addr.
        * listing.c (listing_listing): Remove unused variable message.
        * read.c: Remove unnecessary register type qualifiers.
        (s_mri): Only define/use old_flag variable if MRI_MODE_CHANGE is
        defined.

ld/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * ldlang.c (wild_sort): Remove unused variable section_name.

opcodes/ChangeLog
2010-04-09  Nick Clifton  <nickc@@redhat.com>

        * i386-dis.c (print_insn): Remove unused variable op.
        (OP_sI): Remove unused variable mask.
@
text
@d208 2
a209 1
          =frames-interp,=str,=loc,=Ranges,=pubtypes]\n\
@


1.171
log
@        * objdump.c (disassemble_bytes): Clear aux->reloc before printing
        a new address, so as not to reuse a previous, non-related reloc.

        * gas/arm/arm-it-auto.d, gas/arm/bl-local-v4t.d,
        gas/arm/blx-local.d, gas/arm/thumb-w-good.d: Update expected
        results.
@
text
@a1459 1
  bfd_boolean done_dot;
a1505 1
  done_dot = FALSE;
a1557 2
	  done_dot = FALSE;

@


1.170
log
@        PR 11225
        * objdump.c (only): Replace with linked list.
        (only_size, only_used): Replace with only_list.
        (process_section_p): Set seen field on matches sections.
        (add_only): New function.
        (free_only_list): New function.
        (disassemble_section): Check only_list.
        (main): Use add_only and free_only_list.

        * gas/pe/aligncomm-c.d: Dump all sections.

        * ld-sh/refdbg-0-dso.d: Dump all sections.
@
text
@d1519 3
a1624 2
		  else
		    aux->reloc = NULL;
@


1.169
log
@2010-01-13  Tristan Gingold  <gingold@@adacore.com>

	* ar.c (main): Use lbasename.
	(normalize): Ditto.
	* objdump.c (update_source_path): Ditto.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009
d120 10
a129 7
/* Pointer to an array of section names provided by
   one or more "-j secname" command line options.  */
static char **only;
/* The total number of slots in the only[] array.  */
static size_t only_size = 0;
/* The number of occupied slots in the only[] array.  */
static size_t only_used = 0;
d332 1
a332 1
  size_t i;
d334 1
a334 1
  if (only == NULL)
d337 6
a342 3
  for (i = 0; i < only_used; i++)
    if (strcmp (only [i], section->name) == 0)
      return TRUE;
d346 58
d1849 1
a1849 1
      && only == NULL
d3260 1
a3260 6
	  if (only_used == only_size)
	    {
	      only_size += 8;
	      only = (char **) xrealloc (only, only_size * sizeof (char *));
	    }
	  only [only_used++] = optarg;
d3471 2
@


1.168
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d1159 1
a1159 15
  fname = strrchr (filename, '/');
#ifdef HAVE_DOS_BASED_FILE_SYSTEM
  {
    /* We could have a mixed forward/back slash case.  */
    char *backslash = strrchr (filename, '\\');
    if (fname == NULL || (backslash != NULL && backslash > fname))
      fname = backslash;
    if (fname == NULL && filename[0] != '\0' && filename[1] == ':')
      fname = filename + 1;
  }
#endif
  if (fname == NULL)
    fname = filename;
  else
    ++fname;
@


1.167
log
@        PR binutils/11045
        * dwarf.c (do_debug_pubtypes): New variable.
        (dwarf_select_sections_by_names): Handle .debug_pubtypes.
        (dwarf_select_sections_by_letters): Add 't' for .debug_pubtype.
        (dwarf_select_sections_all): Set do_debug_pubtypes.
        (debug_displays): Add support for .debug_pubtypes.
        * dwarf.h (do_debug_pubtypes): Export.
        * objdump.c (usage): Add -wt or --dwarf=pubtypes.
        * readelf.c (usage): Likewise.
        (process_section_headers): Enable debug display if
        do_debug_pubtypes is set.
        * doc/binutils.texi: Document -wt/--dwarf=pubtypes option.
@
text
@d670 1
a670 1
objdump_print_value (bfd_vma vma, struct disassemble_info *info,
d677 1
a677 1
  aux = (struct objdump_disasm_info *) info->application_data;
d688 1
a688 1
  (*info->fprintf_func) (info->stream, "%s", p);
d694 1
a694 1
objdump_print_symname (bfd *abfd, struct disassemble_info *info,
d710 2
a711 2
  if (info != NULL)
    (*info->fprintf_func) (info->stream, "%s", name);
d727 1
a727 1
			 struct disassemble_info *info,
d737 1
a737 1
  long max = sorted_symcount;
d748 1
a748 1
  aux = (struct objdump_disasm_info *) info->application_data;
d751 1
a751 1
  opb = info->octets_per_byte;
d754 2
a755 2
     required value.  We are searching the range (min, max].  */
  while (min + 1 < max)
d759 1
a759 1
      thisplace = (max + min) / 2;
d763 1
a763 1
	max = thisplace;
d786 1
a786 1
  while (min < max
d791 1
a791 1
	  && info->symbol_is_valid (sorted_syms[min], info))
d819 1
a819 1
      || !info->symbol_is_valid (sorted_syms[thisplace], info))
d827 1
a827 1
	      && info->symbol_is_valid (sorted_syms[i], info))
d851 1
a851 1
		  && info->symbol_is_valid (sorted_syms[i], info))
d860 1
a860 1
	  || !info->symbol_is_valid (sorted_syms[thisplace], info))
d875 1
a875 1
			     bfd_vma vma, struct disassemble_info *info,
d878 1
a878 1
  objdump_print_value (vma, info, skip_zeroes);
d884 2
a885 2
      (*info->fprintf_func) (info->stream, " <%s",
			     bfd_get_section_name (abfd, sec));
d889 2
a890 2
	  (*info->fprintf_func) (info->stream, "-0x");
	  objdump_print_value (secaddr - vma, info, TRUE);
d894 2
a895 2
	  (*info->fprintf_func) (info->stream, "+0x");
	  objdump_print_value (vma - secaddr, info, TRUE);
d897 1
a897 1
      (*info->fprintf_func) (info->stream, ">");
d901 2
a902 2
      (*info->fprintf_func) (info->stream, " <");
      objdump_print_symname (abfd, info, sym);
d905 2
a906 2
	  (*info->fprintf_func) (info->stream, "-0x");
	  objdump_print_value (bfd_asymbol_value (sym) - vma, info, TRUE);
d910 2
a911 2
	  (*info->fprintf_func) (info->stream, "+0x");
	  objdump_print_value (vma - bfd_asymbol_value (sym), info, TRUE);
d913 1
a913 1
      (*info->fprintf_func) (info->stream, ">");
d917 1
a917 1
    info->fprintf_func (info->stream, _(" (File Offset: 0x%lx)"),
d926 1
a926 1
		    struct disassemble_info *info,
d933 1
a933 1
  aux = (struct objdump_disasm_info *) info->application_data;
d937 2
a938 2
      (*info->fprintf_func) (info->stream, "0x");
      objdump_print_value (vma, info, skip_zeroes);
d941 2
a942 2
	info->fprintf_func (info->stream, _(" (File Offset: 0x%lx)"),
			    (long int)(aux->sec->filepos + (vma - aux->sec->vma)));
d960 1
a960 1
    sym = find_symbol_for_address (vma, info, NULL);
d962 1
a962 1
  objdump_print_addr_with_sym (aux->abfd, aux->sec, sym, vma, info,
d970 1
a970 1
objdump_print_address (bfd_vma vma, struct disassemble_info *info)
d972 1
a972 1
  objdump_print_addr (vma, info, ! prefix_addresses);
d978 1
a978 1
objdump_symbol_at_address (bfd_vma vma, struct disassemble_info * info)
d982 1
a982 1
  sym = find_symbol_for_address (vma, info, NULL);
d1194 1
a1194 1
print_line (struct print_file_list *p, unsigned int line)
d1199 2
a1200 2
  --line; 
  if (line >= p->maxline)
d1202 1
a1202 1
  l = p->linemap [line];
d1231 1
a1231 1
  unsigned int line;
d1238 1
a1238 1
			       &functionname, &line))
d1290 2
a1291 2
      if (line > 0 && line != prev_line)
	printf ("%s:%u\n", filename == NULL ? "???" : filename, line);
d1296 1
a1296 1
      && line > 0)
d1313 1
a1313 1
      if (p != NULL && line != p->last_line)
d1319 2
a1320 2
	      l = line - SHOW_PRECEDING_CONTEXT_LINES;
	      if (l >= line) 
d1322 1
a1322 1
	      if (p->last_line >= l && p->last_line <= line)
d1325 2
a1326 2
	  dump_lines (p, l, line);
	  p->last_line = line;
d1341 2
a1342 2
  if (line > 0 && line != prev_line)
    prev_line = line;
d1397 1
a1397 1
disassemble_bytes (struct disassemble_info * info,
d1413 3
a1415 3
  unsigned int opb = info->octets_per_byte;
  unsigned int skip_zeroes = info->skip_zeroes;
  unsigned int skip_zeroes_at_end = info->skip_zeroes_at_end;
d1419 1
a1419 1
  aux = (struct objdump_disasm_info *) info->application_data;
d1455 1
a1455 1
  info->insn_info_valid = 0;
d1475 2
a1476 2
	  && (info->insn_info_valid == 0
	      || info->branch_delay_insns == 0)
d1526 1
a1526 1
	      objdump_print_address (section->vma + addr_offset, info);
d1534 5
a1538 5
	      info->fprintf_func = (fprintf_ftype) objdump_sprintf;
	      info->stream = &sfile;
	      info->bytes_per_line = 0;
	      info->bytes_per_chunk = 0;
	      info->flags = disassemble_all ? DISASSEMBLE_DATA : 0;
d1540 1
a1540 1
		info->flags |= USER_SPECIFIED_MACHINE_TYPE;
d1542 1
a1542 1
	      if (info->disassembler_needs_relocs
d1569 1
a1569 1
		      info->flags |= INSN_HAS_RELOC;
d1576 5
a1580 5
	      octets = (*disassemble_fn) (section->vma + addr_offset, info);
	      info->fprintf_func = (fprintf_ftype) fprintf;
	      info->stream = stdout;
	      if (insn_width == 0 && info->bytes_per_line != 0)
		octets_per_line = info->bytes_per_line;
d1618 2
a1619 2
	      if (info->bytes_per_chunk)
		bpc = info->bytes_per_chunk;
d1627 1
a1627 1
		  if (bpc > 1 && info->display_endian == BFD_ENDIAN_LITTLE)
d1688 1
a1688 1
		      if (bpc > 1 && info->display_endian == BFD_ENDIAN_LITTLE)
d1725 1
a1725 1
				   info, TRUE);
d1742 1
a1742 1
		    objdump_print_symname (aux->abfd, info, *q->sym_ptr_ptr);
d1758 1
a1758 1
		  objdump_print_value (q->addend, info, TRUE);
d1777 1
a1777 1
disassemble_section (bfd *abfd, asection *section, void *info)
d1781 1
a1781 1
  struct disassemble_info *    pinfo = (struct disassemble_info *) info;
d1891 1
a1891 1
                                             (struct disassemble_info *) info,
d2059 1
a2059 1
      const bfd_arch_info_type *info = bfd_scan_arch (machine);
d2061 1
a2061 1
      if (info == NULL)
d2064 1
a2064 1
      abfd->arch_info = info;
d2668 1
a2668 1
  long max;
d2674 1
a2674 1
      max = dynsymcount;
d2680 1
a2680 1
      max = symcount;
d2684 1
a2684 1
  if (max == 0)
d2687 1
a2687 1
  for (count = 0; count < max; count++)
d2762 1
a2762 1
      unsigned int line;
d2776 1
a2776 1
				    &filename, &functionname, &line))
d2788 2
a2789 2
	  if (line > 0
	      && (line != last_line
d2794 2
a2795 2
	      printf ("%s:%u\n", filename == NULL ? "???" : filename, line);
	      last_line = line;
@


1.166
log
@        * readelf.c (usage): Add mention of --debug-dump=frames-interp.
        Wrap output to 80 columns.
        * objdump.c (usage): Likewise.
        * doc/binutils.texi (readelf): Add note about =frames-interp.
@
text
@d203 1
a203 1
  -W[lLiaprmfFsoR] or\n\
d205 1
a205 1
          =frames-interp,=str,=loc,=Ranges]\n\
@


1.165
log
@binutils/
	* objdump.c (disassemble_section): Use bfd_get_arch_size
	instead of assuming that the address size is 32 bits.
@
text
@d204 2
a205 1
  --dwarf[=rawline,=decodedline,=info,=abbrev,=pubnames,=aranges,=macro,=frames,=str,=loc,=Ranges]\n\
@


1.164
log
@        Updated soruces in binutils/* to compile cleanly with -Wc++-compat.

        * binutils/addr2line.c (slurp_symtab): Fix casts. Introduce
        variable minisyms to avoid aliasing varning.
        * binutils/ar.c: Add casts. (normalize): Use name del instead of
        delete. (display_target_list,display_info_table): Change loop
        counter variable a to int.
        * binutils/bucomm.c: Add casts.
        * binutils/debug.c: Update function to use new names. (struct
        debug_baseclass): Rename member from virtual to
        is_virtual. (struct debug_type_s,struct debug_field_s,struct
        debug_baseclass_s,struct debug_method_s,struct
        debug_method_variant_s,struct debug_type_s): Rename struct from
        avoid name collision.
        * /binutils/debug.h: Use new struct names.
        * binutils/dwarf.c: Add casts. (free_debug_memory): Change loop
        counter variable a to int.
        * binutils/ieee.c: Add casts. (enum ieee_var_kind): Move to top
        level. (ieee_class_baseclass): Rename parameter virtual to
        is_virtual. (ieee_class_method_var): Rename variable virtual to
        is_virtual.
        * binutils/nm.c: Add casts.
        * binutils/objcopy.c: Add casts. (copy_archive): Rename variable
        delete to del.
        * binutils/objdump.c: Add casts. (dump_dwarf_section): Change loop
        counter variable i to int.
        * binutils/prdbg.c: Add
        casts. (pr_class_baseclass,tg_class_baseclass): Rename parameters
        virtual to is_virtual.
        * binutils/readelf.c: Add casts. (struct
        ia64_unw_table_entry,struct hppa_unw_table_entry): Move to top
        level.
        * binutils/size.c: Add casts.
        * binutils/stabs.c (parse_stab_type, parse_stab_range_type)
        (parse_stab_cpp_abbrev): Rename parameter from typename to
        type_name. (parse_stab_baseclasses): Rename variable virtual to
        is_virtual.
        * binutils/strings.c: Add casts.
        * binutils/wrstabs.c (stab_class_baseclass): Rename parameter
        virtual to is_virtual.
@
text
@d1894 3
a1896 3
  /* PR 9774: If the target used signed 32-bit addresses then we must make
     sure that we sign extend the value that we calculate for 'addr' in the
     loop below.  */
d1900 1
a1900 1
    sign_adjust = 0x80000000;
@


1.163
log
@	* objdump.c (find_symbol_for_address): Avoid costly call to
	bfd_octets_per_byte.
@
text
@d470 1
a470 1
    sy = xmalloc (storage);
d499 1
a499 1
    sy = xmalloc (storage);
d1043 1
a1043 1
  map = malloc (*size);
d1098 1
a1098 1
	  linemap = xrealloc (linemap, newsize);
d1117 1
a1117 1
  p = xmalloc (sizeof (struct print_file_list));
d1336 1
a1336 1
      prev_functionname = xmalloc (strlen (functionname) + 1);
d1372 1
a1372 1
      f->buffer = xrealloc (f->buffer, f->alloc);
d1422 1
a1422 1
  sfile.buffer = xmalloc (sfile.alloc);
d1838 1
a1838 1
	      rel_ppstart = rel_pp = xmalloc (relsize);
d1850 1
a1850 1
  data = xmalloc (datasize);
d1889 3
a1891 1
  sym = find_symbol_for_address (section->vma + addr_offset, info, &place);
d2028 2
a2029 1
  sorted_syms = xmalloc ((sorted_symcount + synthcount) * sizeof (asymbol *));
d2070 1
a2070 1
      xvec = xmalloc (sizeof (struct bfd_target));
d2118 1
a2118 1
	  aux.dynrelbuf = xmalloc (relsize);
d2145 1
a2145 1
  bfd *abfd = file;
d2157 1
a2157 1
  section->start = xmalloc (section->size);
d2195 1
a2195 1
  bfd *abfd = file;
d2238 1
a2238 1
  enum dwarf_section_display_enum i;
d2257 2
a2258 1
	if (load_specific_debug_section (i, section, abfd))
d2263 1
a2263 1
	      free_debug_section (i);
d2316 1
a2316 1
  contents  = xmalloc (size);
d2581 1
a2581 1
  data = xmalloc (datasize);
d2872 1
a2872 1
  relpp = xmalloc (relsize);
d2911 1
a2911 1
      relpp = xmalloc (relsize);
d2936 2
a2937 2
  include_paths = xrealloc (include_paths,
			    include_path_count * sizeof (*include_paths));
d3212 1
a3212 1
	      only = xrealloc (only, only_size * sizeof (char *));
@


1.163.2.1
log
@        Update soruces to compile cleanly with -Wc++-compat:

        * addr2line.c (slurp_symtab): Fix casts. Introduce variable
        minisyms to avoid aliasing varning.
        * ar.c: Add casts.
        (normalize): Use name del instead of delete.
        (display_target_list,display_info_table): Change loop counter
        variable a to int.
        * bucomm.c: Add casts.
        * debug.c: Update function to use new names.
        (struct debug_baseclass): Rename member from virtual to
        is_virtual.
        (struct debug_type_s, struct debug_field_s, struct
        debug_baseclass_s, struct debug_method_s, struct
        debug_method_variant_s, struct debug_type_s): Rename struct from
        avoid name collision.
        * debug.h: Use new struct names.
        * dwarf.c: Add casts.
        (free_debug_memory): Change loop counter variable a to int.
        * ieee.c: Add casts.
        (enum ieee_var_kind): Move to top level.
        (ieee_class_baseclass): Rename parameter virtual to is_virtual.
        (ieee_class_method_var): Rename variable virtual to is_virtual.
        * nm.c: Add casts.
        * objcopy.c: Add casts.
        (copy_archive): Rename variable delete to del.
        * objdump.c: Add casts.
        (dump_dwarf_section): Change loop counter variable i to int.
        * prdbg.c: Add casts.
        (pr_class_baseclass,tg_class_baseclass): Rename parameters virtual
        to is_virtual.
        * readelf.c: Add casts.
        (struct ia64_unw_table_entry,struct hppa_unw_table_entry): Move to
        top level.
        * size.c: Add casts.
        * stabs.c (parse_stab_type, parse_stab_range_type,
        (parse_stab_cpp_abbrev): Rename parameter from typename to
        type_name.
        (parse_stab_baseclasses): Rename variable virtual to is_virtual.
        * strings.c: Add casts.
        * wrstabs.c (stab_class_baseclass): Rename parameter virtual to
        is_virtual.
@
text
@d470 1
a470 1
    sy = (asymbol **) xmalloc (storage);
d499 1
a499 1
    sy = (asymbol **) xmalloc (storage);
d1043 1
a1043 1
  map = (const char *) malloc (*size);
d1098 1
a1098 1
	  linemap = (const char **) xrealloc (linemap, newsize);
d1117 1
a1117 1
  p = (struct print_file_list *) xmalloc (sizeof (struct print_file_list));
d1336 1
a1336 1
      prev_functionname = (char *) xmalloc (strlen (functionname) + 1);
d1372 1
a1372 1
      f->buffer = (char *) xrealloc (f->buffer, f->alloc);
d1422 1
a1422 1
  sfile.buffer = (char *) xmalloc (sfile.alloc);
d1838 1
a1838 1
	      rel_ppstart = rel_pp = (arelent **) xmalloc (relsize);
d1850 1
a1850 1
  data = (bfd_byte *) xmalloc (datasize);
d1889 1
a1889 3
  sym = (asymbol *) find_symbol_for_address (section->vma + addr_offset,
                                             (struct disassemble_info *) info,
                                             &place);
d2026 1
a2026 2
  sorted_syms = (asymbol **) xmalloc ((sorted_symcount + synthcount)
                                      * sizeof (asymbol *));
d2067 1
a2067 1
      xvec = (struct bfd_target *) xmalloc (sizeof (struct bfd_target));
d2115 1
a2115 1
	  aux.dynrelbuf = (arelent **) xmalloc (relsize);
d2142 1
a2142 1
  bfd *abfd = (bfd *) file;
d2154 1
a2154 1
  section->start = (unsigned char *) xmalloc (section->size);
d2192 1
a2192 1
  bfd *abfd = (bfd *) file;
d2235 1
a2235 1
  int i;
d2254 1
a2254 2
	if (load_specific_debug_section ((enum dwarf_section_display_enum) i,
                                         section, abfd))
d2259 1
a2259 1
	      free_debug_section ((enum dwarf_section_display_enum) i);
d2312 1
a2312 1
  contents  = (char *) xmalloc (size);
d2577 1
a2577 1
  data = (bfd_byte *) xmalloc (datasize);
d2868 1
a2868 1
  relpp = (arelent **) xmalloc (relsize);
d2907 1
a2907 1
      relpp = (arelent **) xmalloc (relsize);
d2932 2
a2933 2
  include_paths = (const char **)
      xrealloc (include_paths, include_path_count * sizeof (*include_paths));
d3208 1
a3208 1
	      only = (char **) xrealloc (only, only_size * sizeof (char *));
@


1.163.2.2
log
@binutils/
	* objdump.c (disassemble_section): Use bfd_get_arch_size
	instead of assuming that the address size is 32 bits.
@
text
@d1894 3
a1896 3
  /* PR 9774: If the target used signed addresses then we must make
     sure that we sign extend the value that we calculate for 'addr'
     in the loop below.  */
d1900 1
a1900 1
    sign_adjust = (bfd_vma) 1 << (bed->s->arch_size - 1);
@


1.163.2.3
log
@2010-02-05  Christophe Lyon  <christophe.lyon@@st.com>

	binutils/
	* objdump.c (disassemble_bytes): Clear aux->reloc before printing
	a new address, so as not to reuse a previous, non-related reloc.

	gas/testsuite/
	* gas/arm/arm-it-auto.d, gas/arm/bl-local-v4t.d,
	gas/arm/blx-local.d, gas/arm/thumb-w-good.d: Update expected
	results.
@
text
@a1467 3
      /* Make sure we don't use relocs from previous instructions.  */
      aux->reloc = NULL;

d1571 2
@


1.162
log
@        PR 10413
        * objdump.c (dump_section_header): Skip sections that we are
        ignoring.
@
text
@d750 1
a750 1
  opb = bfd_octets_per_byte (abfd);
@


1.161
log
@2009-07-20  H.J. Lu  <hongjiu.lu@@intel.com>

	* NEWS: Mention --insn-width.

	* objdump.c (insn_width): New.
	(usage): Display --insn-width.
	(option_values): Add OPTION_INSN_WIDTH.
	(long_options): Add --insn-width.
	(disassemble_bytes): Handle insn_width.
	(main): Handle OPTION_INSN_WIDTH.

	* doc/binutils.texi: Document --insn-width.
@
text
@d323 17
d352 4
a1378 18
/* Returns TRUE if the specified section should be dumped.  */

static bfd_boolean
process_section_p (asection * section)
{
  size_t i;

  if (only == NULL)
    return TRUE;

  for (i = 0; i < only_used; i++)
    if (strcmp (only [i], section->name) == 0)
      return TRUE;

  return FALSE;
}


@


1.160
log
@2009-07-06  Tristan Gingold  <gingold@@adacore.com>

	* objdump.c (dump_dwarf_section): Handle .eh_frame like other dwarf
	sections.
	* dwarf.h (struct dwarf_section_display): Remove eh_frame field.
	* dwarf.c (debug_displays): Adjust for removed field.
@
text
@d107 1
d239 1
d264 1
d312 1
d1422 3
a1424 1
  if (insns)
d1575 1
a1575 1
	      if (info->bytes_per_line != 0)
d3260 5
@


1.159
log
@        PR 10288
        * arm-dis.c (print_insn_coprocessor): Check that a user specified
        ARM architecture supports the matched instruction.
        (print_insn_arm): Likewise.
        (select_arm_features): New function.  Fills in the fields of an
        arm_feature_set structure based on a given arm machine number.
        (print_insn): Initialise an arm_feature_set structure.

        * objdump.c (disassemble_bytes): Set the
        USER_SPECIFIED_MACHINE_TYPE flag in the disassemble_info structure
        if the user has invoked the -m switch.
        * doc/binutils.texi: Document the additional behaviour of
        objdump's -m switch for ARM targets.

        * dis-asm.h (USER_SPECIFIED_MACHINE_TYPE): New value for the flags
        field of struct disassemble_info.

        * gas/arm/align.s: Add labels so that COFF based targets can
        correctly locate THUMB code.
        * gas/arm/copro.d: Do not pass --architecture switch to objdump.
@
text
@d2239 7
a2245 1
	if (!debug_displays [i].eh_frame)
d2247 4
a2250 13
	    struct dwarf_section *sec = &debug_displays [i].section;

	    if (strcmp (sec->uncompressed_name, match) == 0)
	      sec->name = sec->uncompressed_name;
	    else
	      sec->name = sec->compressed_name;
	    if (load_specific_debug_section (i, section, abfd))
	      {
		debug_displays [i].display (sec, abfd);

		if (i != info && i != abbrev)
		  free_debug_section (i);
	      }
@


1.158
log
@        PR 10263
        * arm-dis.c (print_insn): Ignore is_data if the user has requested
        the disassembly of data as well as instructions.

        * objdump.c (disassemble_bytes): Set the DISASSEMBLE_DATA bit in
        the flags field of the disassemble_info structure if the -D switch
        is in operation.

        * dis-asm.h (struct disassemble_info): New value for the flags
        field.
@
text
@d1529 2
@


1.157
log
@        * objdump.c (disassemble_section): If the computed next offset is
        not beyond the current offset then just continue to the end.
@
text
@d1528 1
a1528 1
	      info->flags = 0;
d1557 1
a1557 1
		      info->flags = INSN_HAS_RELOC;
@


1.156
log
@	* objdump.c (disassemble_section): Mask address before sign extending.
@
text
@d1964 2
a1965 1
      if (nextstop_offset > stop_offset)
d1988 1
a1988 1

@


1.155
log
@	* objdump.c (load_specific_debug_section): New function, from
	load_debug_section.
	(load_debug_section): Use load_specific_debug_section.
	(dump_dwarf_section): Likewise.
@
text
@d1901 1
a1901 1
      addr = (addr ^ sign_adjust) - sign_adjust;
@


1.154
log
@2009-02-09  Tristan Gingold  <gingold@@adacore.com>

	* NEWS: Mention feature match between objdump and readelf for dumping
	dwarf info.

	* doc/binutils.texi (objdump): Document -W/--dwarf improvments to
	objdump.

	* objdump.c (usage): Update documentation for -W/--dwarf.
	(enum option_values): Add OPTION_DWARF.
	(long_options): --dwarf can accept arguments.
	(dump_dwarf_section): Also check enabled field.
	(main): Option -W can accept arguments, code moved to
	dwarf.c and call dwarf_select_sections_all instead.
	* readelf.c (process_section_headers): Remove do_debug_lines_decoded.
	(parse_args): Move code to...
	* dwarf.c (dwarf_select_sections_by_letters,
	dwarf_select_sections_by_names): : ...here (new functions).
	(do_debug_lines_decoded): Remove and replaced by ...
	(FLAG_DEBUG_LINES_RAW, FLAG_DEBUG_LINES_DECODED): ... new macros.
	(display_debug_lines): Adjust for previous change.
	(dwarf_select_sections_all): New function.
	(debug_displays): Add initializer for enabled field.
	* dwarf.h (do_debug_lines_decoded): Remove.
	Add prototypes for the new functions.
	(struct dwarf_section_display): Add enabled field.
@
text
@d2125 3
a2127 2
int
load_debug_section (enum dwarf_section_display_enum debug, void *file)
a2130 1
  asection *sec;
a2137 12
  /* Locate the debug section.  */
  sec = bfd_get_section_by_name (abfd, section->uncompressed_name);
  if (sec != NULL)
    section->name = section->uncompressed_name;
  else
    {
      sec = bfd_get_section_by_name (abfd, section->compressed_name);
      if (sec != NULL)
	section->name = section->compressed_name;
    }
  if (sec == NULL)
    return 0;
d2173 28
a2200 1
  return ret;
d2240 5
a2244 1
	    if (load_debug_section (i, abfd))
@


1.153
log
@2009-02-03  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/9784
	* NEWS: Mention --prefix=PREFIX and --prefix-strip=LEVEL.

	* doc/binutils.texi: Document --prefix=PREFIX and
	--prefix-strip=LEVEL.

	* objdump.c: Include "filenames.h".
	(prefix): New.
	(prefix_strip): Likewise.
	(prefix_length): Likewise.
	(usage): Add --prefix=PREFIX and --prefix-strip=LEVEL.
	(option_values): Add OPTION_PREFIX and OPTION_PREFIX_STRIP.
	(long_options): Likewise.
	(show_line): Handle prefix and prefix_strip.
	(main): Handle OPTION_PREFIX and OPTION_PREFIX_STRIP.

	* readelf.c (PATH_MAX): Moved to ...
	* sysdep.h: Here.
@
text
@d202 3
a204 1
  -W, --dwarf              Display DWARF info in the file\n\
d259 1
d299 1
a299 1
  {"dwarf", no_argument, NULL, 'W'},
d2216 4
a2219 2
    if (strcmp (debug_displays [i].section.uncompressed_name, match) == 0
        || strcmp (debug_displays [i].section.compressed_name, match) == 0)
d3156 2
a3157 1
  while ((c = getopt_long (argc, argv, "pib:m:M:VvCdDlfFaHhrRtTxsSI:j:wE:zgeGW",
d3320 12
a3331 10
	  do_debug_info = 1;
	  do_debug_abbrevs = 1;
	  do_debug_lines = 1;
	  do_debug_pubnames = 1;
	  do_debug_aranges = 1;
	  do_debug_ranges = 1;
	  do_debug_frames = 1;
	  do_debug_macinfo = 1;
	  do_debug_str = 1;
	  do_debug_loc = 1;
@


1.152
log
@        PR 9774
        * objdump.c (disassemble_section): When the target uses signed
        addresses make sure that we compute signed values.
@
text
@d64 1
d115 3
d238 2
d257 2
d304 2
d1203 1
d1217 38
d1278 3
d1282 1
d3217 12
@


1.151
log
@missed commit
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008
d1711 2
a1779 1

d1825 8
d1845 1
@


1.150
log
@Remove STT_IFUNC support.
@
text
@d1906 1
@


1.149
log
@* objdump.c (dump_reloc_set): Append "()" to symbol names which
  have the BSF_INDIRECT_FUNCTION type.
  * readelf.c (print_symbol): Fix handling of negative widths.
  (dump_relocations): Append "()" to symbol names which have the
  STT_IFUNC type. Display negative offsets as a positive number with
  a "-" prefix.
  (get_symbol_type): Return "IFUNC" for STT_IFUNC symbols.
  * doc/binutils.texi: Document 'i' symbol type.
@
text
@a2724 2
	  if ((*q->sym_ptr_ptr)->flags & BSF_INDIRECT_FUNCTION)
	    printf ("() ");
@


1.148
log
@2008-11-14  Tristan Gingold  <gingold@@adacore.com>

	Remove outdated mach-o specific tests.
	* objdump.c (load_debug_section): Remove mach-o specific test.
	(mach_o_uncompressed_dwarf_sections): Removed.
	(mach_o_compressed_dwarf_sections): Removed.
	(generic_uncompressed_dwarf_sections): Removed.
	(generic_compressed_dwarf_sections): Removed.
	(check_mach_o_dwarf): Removed.
	(dump_dwarf): Remove call to check_mach_o_dwarf.
@
text
@d2721 1
d2723 5
a2727 1
	objdump_print_symname (abfd, NULL, *q->sym_ptr_ptr);
@


1.147
log
@	* objdump.c (disassemble_bytes): Don't skip leading zeros when
	end of section calculation overflows.
@
text
@d2085 1
a2085 13
  /* Compute a bias to be added to offsets found within the DWARF debug
     information.  These offsets are meant to be relative to the start of
     the dwarf section, and hence the bias should be 0.  For MACH-O however
     a dwarf section is really just a region of a much larger section and so
     the bias is the address of the start of that area within the larger
     section.  This test is important for PE and COFF based targets which
     use DWARF debug information, since unlike ELF, they do not allow the
     dwarf sections to be placed at address 0.  */
  if (bfd_get_flavour (abfd) == bfd_target_mach_o_flavour)
    section->address = bfd_get_section_vma (abfd, sec);
  else
    section->address = 0;
    
a2167 80
static const char *mach_o_uncompressed_dwarf_sections [] = {
  "LC_SEGMENT.__DWARFA.__debug_abbrev",		/* .debug_abbrev */
  "LC_SEGMENT.__DWARFA.__debug_aranges",	/* .debug_aranges */
  "LC_SEGMENT.__DWARFA.__debug_frame",		/* .debug_frame */
  "LC_SEGMENT.__DWARFA.__debug_info",		/* .debug_info */
  "LC_SEGMENT.__DWARFA.__debug_line",		/* .debug_line */
  "LC_SEGMENT.__DWARFA.__debug_pubnames",	/* .debug_pubnames */
  ".eh_frame",					/* .eh_frame */
  "LC_SEGMENT.__DWARFA.__debug_macinfo",	/* .debug_macinfo */
  "LC_SEGMENT.__DWARFA.__debug_str",		/* .debug_str */
  "LC_SEGMENT.__DWARFA.__debug_loc",		/* .debug_loc */
  "LC_SEGMENT.__DWARFA.__debug_pubtypes",	/* .debug_pubtypes */
  "LC_SEGMENT.__DWARFA.__debug_ranges",		/* .debug_ranges */
  "LC_SEGMENT.__DWARFA.__debug_static_func",	/* .debug_static_func */
  "LC_SEGMENT.__DWARFA.__debug_static_vars",	/* .debug_static_vars */
  "LC_SEGMENT.__DWARFA.__debug_types",		/* .debug_types */
  "LC_SEGMENT.__DWARFA.__debug_weaknames"	/* .debug_weaknames */
};

static const char *mach_o_compressed_dwarf_sections [] = {
  "LC_SEGMENT.__DWARFA.__zdebug_abbrev",	/* .zdebug_abbrev */
  "LC_SEGMENT.__DWARFA.__zdebug_aranges",	/* .zdebug_aranges */
  "LC_SEGMENT.__DWARFA.__zdebug_frame",		/* .zdebug_frame */
  "LC_SEGMENT.__DWARFA.__zdebug_info",		/* .zdebug_info */
  "LC_SEGMENT.__DWARFA.__zdebug_line",		/* .zdebug_line */
  "LC_SEGMENT.__DWARFA.__zdebug_pubnames",	/* .zdebug_pubnames */
  ".eh_frame",					/* .eh_frame */
  "LC_SEGMENT.__DWARFA.__zdebug_macinfo",	/* .zdebug_macinfo */
  "LC_SEGMENT.__DWARFA.__zdebug_str",		/* .zdebug_str */
  "LC_SEGMENT.__DWARFA.__zdebug_loc",		/* .zdebug_loc */
  "LC_SEGMENT.__DWARFA.__zdebug_pubtypes",	/* .zdebug_pubtypes */
  "LC_SEGMENT.__DWARFA.__zdebug_ranges",	/* .zdebug_ranges */
  "LC_SEGMENT.__DWARFA.__zdebug_static_func",	/* .zdebug_static_func */
  "LC_SEGMENT.__DWARFA.__zdebug_static_vars",	/* .zdebug_static_vars */
  "LC_SEGMENT.__DWARFA.__zdebug_types",		/* .zdebug_types */
  "LC_SEGMENT.__DWARFA.__zdebug_weaknames"	/* .zdebug_weaknames */
};

static const char *generic_uncompressed_dwarf_sections [max];
static const char *generic_compressed_dwarf_sections [max];

static void
check_mach_o_dwarf (bfd *abfd)
{
  static enum bfd_flavour old_flavour = bfd_target_unknown_flavour;
  enum bfd_flavour current_flavour = bfd_get_flavour (abfd);
  enum dwarf_section_display_enum i;

  if (generic_uncompressed_dwarf_sections [0] == NULL)
    for (i = 0; i < max; i++)
      {
        generic_uncompressed_dwarf_sections [i]
            = debug_displays[i].section.uncompressed_name;
        generic_compressed_dwarf_sections [i]
            = debug_displays[i].section.compressed_name;
      }

  if (old_flavour != current_flavour)
    {
      if (current_flavour == bfd_target_mach_o_flavour)
	for (i = 0; i < max; i++)
          {
            debug_displays[i].section.uncompressed_name
                = mach_o_uncompressed_dwarf_sections [i];
            debug_displays[i].section.compressed_name
                = mach_o_compressed_dwarf_sections [i];
          }
      else if (old_flavour == bfd_target_mach_o_flavour)
	for (i = 0; i < max; i++)
          {
            debug_displays[i].section.uncompressed_name
                = generic_uncompressed_dwarf_sections [i];
            debug_displays[i].section.compressed_name
                = generic_compressed_dwarf_sections [i];
          }

      old_flavour = current_flavour;
    }
}

a2185 2
  check_mach_o_dwarf (abfd);

@


1.146
log
@2008-08-28  Tristan Gingold  <gingold@@adacore.com>

	* objdump.c (dump_stabs): Add sections for Darwin.
@
text
@a1374 1
      char *s;
d1376 11
a1386 11
      bfd_sprintf_vma
	(aux->abfd, buf,
	 (section->vma
	  + bfd_section_size (section->owner, section) / opb));
      s = buf;
      while (s[0] == '0' && s[1] == '0' && s[2] == '0' && s[3] == '0'
	     && s[4] == '0')
	{
	  skip_addr_chars += 4;
	  s += 4;
	}
@


1.145
log
@Silence gcc printf warnings
@
text
@d2477 4
@


1.144
log
@2008-07-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* objdump.c (load_debug_section): Initialize section_is_compressed
	for gcc 3.4/ia64.
	* readelf.c (load_debug_section): Likewise.
@
text
@d1431 2
a1432 1
		    (long int)(section->filepos + (addr_offset + (octets / opb))));
d2567 2
a2568 1
    printf (_("  (Starting at file offset: 0x%lx)"), (long int)(section->filepos + start_offset));
@


1.143
log
@bfd/
	* Makefile.am (BFD32_LIBS): Add compress.lo.
	(BFD32_LIBS_CFILES): Add compress.c.
	(BFD_H_FILES): Likewise.
	* Makefile.in: Regenerate.
	* bfd-in2.h: Regenerate.
	* config.in: Add HAVE_ZLIB_H
	* configure.in: Add test for libz and zlib.h
	* configure: Regenerate.
	* dwarf2.c (read_section): New function.
	(read_indirect_string): Call new function read_section.
	(read_abbrevs): Likewise.
	(decode_line_info): Likewise.
	(read_debug_ranges): Likewise.
	(find_line): Call new function read_section when just one
	.zdebug_info section is found, otherwise read and compress
	multiple sections.
	(_bfd_dwarf2_cleanup_debug_info): Free sec_info_ptr.
	* elf.c (_bfd_elf_make_section_from_shdr): Add zdebug prefix.
	(special_sections_z): New struct.
	(special_sections): Refer to special_sections_z.
	* elfxx-mips.c (_bfd_mips_elf_section_from_shdr): Recognize
	sections named .zdebug_*.
	(_bfd_mips_elf_fake_sections): Likewise.
	* compress.c: New file.
	(bfd_uncompress_section_contents): New function.
bfd/doc/
	* Makefile.am (BFD_H_DEP): Add ../compress.c.
	* Makefile.in: Regenerate.
binutils/
	* config.in: Add HAVE_ZLIB_H
	* configure.in: Add test for libz and zlib.h
	* configure: Regenerate.
	* dwarf.c (debug_displays): Add .zdebug_* strings.
	* dwarf.h (struct dwarf_section): Add fields uncompressed_namd
	and compressed_name.
	* objdump.c (load_debug_section): Call
	bfd_uncompress_section_contents when loading a compressed
	section.
	(dump_dwarf_section): Recognize compressed section name.
	(mach_o_dwarf_sections): Rename as
	mach_o_uncompressed_dwarf_sections.
	(mach_o_compressed_dwarf_sections): New variable.
	(generic_dwarf_section): Rename as
	generic_uncompressed_dwarf_sections.
	(generic_compressed_dwarf_sections): New variable.
	(check_mach_o_dwarf): Save and restore
	mach_o_compressed_dwarf_sections.
	* readelf.c: Add #include for config.h and zlib.h
	(process_section_headers): Recognize compressed section name.
	(uncompress_section_contents): New function.
	(load_debug_section): Call uncompress_section_contents when
	loading a compressed section.
	(display_debug_section): Recognize compressed section name.
binutils/testsuite:
	* binutils-all/objdump.exp: Add test for objdump -s on a file
	with a compressed debug section.  Add test for objdump -W on a
	file that contains a compressed debug section.
	* binutils-all/readelf.exp: Call readelf_compressed_wa_test.
	(readelf_compressed_wa_test): New function.
	* binutils-all/dw2-compressed.S: New file.
	* binutils-all/objdump.W: New file.
	* binutils-all/objdump.s: New file.
	* binutils-all/readelf.wa: New file.
@
text
@d2074 1
a2074 4
    {
      section->name = section->uncompressed_name;
      section_is_compressed = 0;
    }
d2079 1
a2079 4
        {
          section->name = section->compressed_name;
          section_is_compressed = 1;
        }
d2083 1
@


1.142
log
@	* objdump.c (find_symbol_for_address): Prefer symbols in current
	section.
@
text
@d2065 1
d2072 15
a2086 1
  sec = bfd_get_section_by_name (abfd, section->name);
d2115 1
a2115 1
  if (!ret)
d2120 13
d2166 2
a2167 1
    if (strcmp (debug_displays[i].section.name, match) == 0)
d2169 1
a2169 1
	if (!debug_displays[i].eh_frame)
d2175 1
a2175 1
		debug_displays[i].display (sec, abfd);
d2185 1
a2185 1
static const char *mach_o_dwarf_sections [] = {
d2204 21
a2224 1
static const char *generic_dwarf_sections [max];
d2233 1
a2233 1
  if (generic_dwarf_sections [0] == NULL)
d2235 6
a2240 1
      generic_dwarf_sections [i] = debug_displays[i].section.name;
d2246 6
a2251 1
	  debug_displays[i].section.name = mach_o_dwarf_sections [i];
d2254 6
a2259 1
	  debug_displays[i].section.name = generic_dwarf_sections [i];
@


1.141
log
@        PR binutils/6483
        * objdump.c (dump_bfd): If the -g option found no STABS or IEEE
        debug information to display, try dumping DWARF information
        instead.
        * rddbg.c (read_debugging_info): Add a parameter to suppress the
        display of a warning message when no debug information is found.
        * budbg.h (read_debugging_info): Update prototype.
        * objcopy.c (copy_object): Continue to allow read_debugging_info
        to produce warning messages.
        * doc/binutils.texi (--debugging): Document new behaviour of the
        -g/--debugging option.
@
text
@d743 21
d783 1
a783 11
      long newplace;

      for (i = thisplace + 1; i < sorted_symcount; i++)
	{
	  if (bfd_asymbol_value (sorted_syms[i])
	      != bfd_asymbol_value (sorted_syms[thisplace]))
	    break;
	}

      --i;
      newplace = sorted_symcount;
d785 1
a785 1
      for (; i >= 0; i--)
@


1.140
log
@                PR binutils/6449
                * objdump.c (slurp_file): Open the file in binary mode.
                * ar.c: Remove conditional definition of O_BINARY.
                * bin2.c: Likewise.
                * rename.c: Likewise.
                * strings.c: Likewise.
                * sysdep.h: Add conditional definition of O_BINARY.
@
text
@d2940 1
a2940 1
      dhandle = read_debugging_info (abfd, syms, symcount);
d2952 6
@


1.139
log
@	* objdump.c (objdump_print_addr): Initialise "sym".
@
text
@d967 1
a967 1
/* Read a complete file into memory. */
d978 1
a978 1
  int fd = open (fn, O_RDONLY);
@


1.138
log
@* objdump.c (objdump_print_addr): If displaying file offsets, show
  the offset even if there are no symbols available.
  (dump_section): Display nothing if none of the section is going to
  be dumped.  Display the file offset, if requested, of the location
  from where the dump starts.
  * doc/binutils.texi (objdump): Mention that dumping via the -s
  switch is also affected by the -F option.
@
text
@d880 1
a880 1
  asymbol *sym;
@


1.137
log
@* objdump.c (display_file_offsets): New variable.
  (long_options): Add -F/--file-offsets.
  (objdump_print_addr_with_sym): If displaying file offsets, print
  the offset of the given address.
  (disassemble_bytes): If displaying file offsets, tell the user how
  many zeroes are skipped and the file offset of the point where
  dumping resumes.
  (disassemble_section): Only display the name of the section if
  data is going to be dumped from it.
  (main): Handle new option.  Produce error messages if the start or
  stop addresses do not make sense.
  * doc/binutils.texi: Document the new feature.
  * NEWS: Mention the new feature.
@
text
@d867 1
a867 1
    info->fprintf_func (info->stream, " (File Offset: 0x%lx)",
d880 1
a880 1
  asymbol *sym = NULL; /* Initialize to avoid compiler warning.  */
d883 2
d889 4
a895 2
  aux = (struct objdump_disasm_info *) info->application_data;

a2470 6
  printf (_("Contents of section %s:\n"), section->name);

  data = xmalloc (datasize);

  bfd_get_section_contents (abfd, section, data, 0, datasize);

d2491 12
@


1.136
log
@	* objdump.c (main): Don't pass unadorned NULL to concat.
@
text
@d113 1
d221 1
d272 1
d865 4
a1400 2
	  printf ("\t...\n");

d1409 10
d1801 2
a1802 1
  printf (_("Disassembly of section %s:\n"), section->name);
d3087 1
a3087 1
  while ((c = getopt_long (argc, argv, "pib:m:M:VvCdDlfaHhrRtTxsSI:j:wE:zgeGW",
d3114 3
d3145 2
d3150 2
@


1.135
log
@binutils/

2008-01-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* dwarf.c: Include "elf/common.h".
	(eh_addr_size): Changed to int.
	(dwarf_regnames_i386): New.
	(dwarf_regnames_x86_64): Likewise.
	(dwarf_regnames): Likewise.
	(dwarf_regnames_count): Likewise.
	(init_dwarf_regnames): Likewise.
	(regname): Likewise.
	(frame_display_row): Properly support different address size.
	Call regname to get register name.
	(display_debug_frames): Call regname to get register name.
	Display DW_CFA_def_cfa_register as DW_CFA_def_cfa_register
	instead of DW_CFA_def_cfa_reg.

	* dwarf.h (init_dwarf_regnames): New.

	* objdump.c: Include "elf-bfd.h".
	(dump_dwarf): Call init_dwarf_regnames on ELF input.

	* readelf.c (guess_is_rela): Change argument to int.
	(parse_args): Remove the undocumented upper case options for
	-wX.
	(process_file_header): Call init_dwarf_regnames if
	do_dwarf_register is true.

gas/testsuite/

2008-01-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* gas/cfi/cfi-alpha-1.d: Replace DW_CFA_def_cfa_reg with
	DW_CFA_def_cfa_register.
	* gas/cfi/cfi-alpha-3.d: Likewise.
	* gas/cfi/cfi-hppa-1.d: Likewise.
	* gas/cfi/cfi-i386.d: Likewise.
	* gas/cfi/cfi-m68k.d: Likewise.
	* gas/cfi/cfi-mips-1.d: Likewise.
	* gas/cfi/cfi-sh-1.d: Likewise.
	* gas/cfi/cfi-sparc-1.d: Likewise.
	* gas/cfi/cfi-sparc64-1.d: Likewise.
	* gas/cfi/cfi-x86_64.d: Likewise.

	* gas/cfi/cfi-common-1.d: Updated for i386/x86-64 register
	names.
	* gas/cfi/cfi-common-2.d: Likewise.
	* gas/cfi/cfi-common-5.d: Likewise.
	* gas/cfi/cfi-i386.d: Likewise.
	* gas/cfi/cfi-x86_64.d: Likewise.

ld/testsuite/

2008-01-28  H.J. Lu  <hongjiu.lu@@intel.com>

	* ld-elf/eh1.d: Replace DW_CFA_def_cfa_reg with
	DW_CFA_def_cfa_register. Updated for i386/x86-64 register
	names.
	* ld-elf/eh2.d: Likewise.
	* ld-elf/eh3.d: Likewise.
	* ld-elf/eh4.d: Likewise.
	* ld-elf/eh5.d: Likewise.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007
d3086 1
a3086 1
					   optarg, NULL);
@


1.134
log
@* dwarf.c (is_relocatable): Remove definition.
  (display_debug_frames): Remove check in is_relocatable.
* dwarf.h (is_relocatable): Remove declaration.
* objdump.c (is_relocatable): New static definition.
* readelf.c (dump_relocations): Make the function void.
  (is_32bit_abs_reloc): Add support for x86, Arc, Arm, D10V, Dlx, OR32 and Score.
  (is_32bit_pcrel_reloc): Add support for x86 and Arm.
  (is_16bit_abs_reloc): Add support for D10V.
  (debug_apply_rela_addends): Rename to debug_apply_relocations.
  Add code to support rel relocations.
  (load_debug_section): Fix call to debug_apply_relocations.
  (get_file_header): Remove setting of is_relocatable.
* gas/cfi/cfi-common-6.d: Allow for possible relocation of the .debug.eh_frame section.
@
text
@d55 1
d2190 6
@


1.133
log
@	* objdump.c (print_line): Check fwrite return value.
	* srconv.c (checksum, wr_tr, wr_cs): Likewise.
	* sysdump.c (fillup): Return zero on getc or fread EOF.  Return count
	read.
@
text
@d174 2
@


1.132
log
@	* objdump.c (dump_dwarf): Correct setting of is_relocatable.
@
text
@d1133 1
d1139 5
a1143 3
  fwrite (l, 1, strcspn (l, "\n\r"), stdout);
  putchar ('\n');
} 
@


1.131
log
@Change sources over to using GPLv3
@
text
@d2169 1
a2169 2
  is_relocatable = ((abfd->flags & (HAS_RELOC | EXEC_P | DYNAMIC))
		    == HAS_RELOC);
@


1.130
log
@  	* objdump.c: Include sys/stat.h.
@
text
@d10 1
a10 1
   the Free Software Foundation; either version 2, or (at your option)
d20 3
a22 1
   Foundation, 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
@


1.129
log
@* objdump.c: Include sys/mman.h
  (print_file_list): Remove f, add map, mapsize, linemap, maxline, last_line, first fields.
  (slurp_file): Add.
  (index_file): Add.
  (print_file_open): Call slurp_file and index_file. Initialize new fields.
  (skip_to_line): Rename to print_line and write only single line.
  (dump_line): Add.
  (show_line): Change to new algorithm.
@
text
@d68 2
@


1.128
log
@2007-05-22  Paul Brook  <paul@@codesourcery.com>

	bunutils/
	* objdump.c (find_symbol_for_address): Merge section and target
	specific filtering code.

	ld/testsuite/
	* ld-arm-mixed-lib.d: Update expected output.
	* ld-arm/arm-app.d: Ditto.
	* ld-arm/mixed-app.d: Ditto.
	* ld-arm/arm-lib-plt32.d: Ditto.
	* ld-arm/arm-app-abs32.d: Ditto.
	* ld-arm/mixed-app-v5.d: Ditto.
	* ld-arm/armthumb-lib.d: Ditto.
	* ld-arm/arm-lib.d: Ditto.

	gas/testsuite/
	* gas/arm/backslash-at.d: Update expected output.
@
text
@d64 4
d934 6
a939 2
  unsigned int line;
  FILE *f;
d949 93
a1048 1
  FILE *f;
d1050 1
a1050 3
  f = fopen (modname, "r");
  if (f == NULL)
    return NULL;
d1052 2
a1053 1
  if (print_files != NULL && print_files->f != NULL)
d1055 2
a1056 2
      fclose (print_files->f);
      print_files->f = NULL;
d1058 3
a1060 2

  p = xmalloc (sizeof (struct print_file_list));
a1062 2
  p->line = 0;
  p->f = f;
d1064 1
d1123 16
a1138 2
/* Skip ahead to a given line in a file, optionally printing each
   line.  */
d1141 1
a1141 2
skip_to_line (struct print_file_list *p, unsigned int line,
	      bfd_boolean show)
d1143 3
a1145 1
  while (p->line < line)
d1147 2
a1148 14
      char buf[100];

      if (fgets (buf, sizeof buf, p->f) == NULL)
	{
	  fclose (p->f);
	  p->f = NULL;
	  break;
	}

      if (show)
	printf ("%s", buf);

      if (strchr (buf, '\n') != NULL)
	++p->line;
d1189 1
d1196 2
a1197 40
      if (p != NULL)
	{
	  if (p != print_files)
	    {
	      int l;

	      /* We have reencountered a file name which we saw
		 earlier.  This implies that either we are dumping out
		 code from an included file, or the same file was
		 linked in more than once.  There are two common cases
		 of an included file: inline functions in a header
		 file, and a bison or flex skeleton file.  In the
		 former case we want to just start printing (but we
		 back up a few lines to give context); in the latter
		 case we want to continue from where we left off.  I
		 can't think of a good way to distinguish the cases,
		 so I used a heuristic based on the file name.  */
	      if (strcmp (p->filename + strlen (p->filename) - 2, ".h") != 0)
		l = p->line;
	      else
		{
		  l = line - SHOW_PRECEDING_CONTEXT_LINES;
		  if (l < 0)
		    l = 0;
		}

	      if (p->f == NULL)
		{
		  p->f = fopen (p->modname, "r");
		  p->line = 0;
		}
	      if (p->f != NULL)
		skip_to_line (p, l, FALSE);

	      if (print_files->f != NULL)
		{
		  fclose (print_files->f);
		  print_files->f = NULL;
		}
	    }
d1199 1
a1199 9
	  if (p->f != NULL)
	    {
	      skip_to_line (p, line, TRUE);
	      *pp = p->next;
	      p->next = print_files;
	      print_files = p;
	    }
	}
      else
d1201 13
a1213 16
	  p = update_source_path (filename);

	  if (p != NULL)
	    {
	      int l;

	      if (file_start_context)
		l = 0;
	      else
		l = line - SHOW_PRECEDING_CONTEXT_LINES;
	      if (l < 0)
		l = 0;
	      skip_to_line (p, l, FALSE);
	      if (p->f != NULL)
		skip_to_line (p, line, TRUE);
	    }
@


1.127
log
@binutils/
	* objdump.c (disassemble_bytes): Ignore disassembler_needs_relocs
	for executables and shared libraries.

ld/testsuite/
	* ld-arm/emit-relocs1.d, ld-arm/emit-relocs1.s,
	* ld-arm/emit-relocs1-vxworks.d: New tests.
	* ld-arm/arm-elf.exp: Run them.
	* ld-arm/vxworks1.dd: Expect proper branch targets.
@
text
@d690 1
d736 10
a745 7
     table.  */
  if (sorted_syms[thisplace]->section != sec
      && (aux->require_sec
	  || ((abfd->flags & HAS_RELOC) != 0
	      && vma >= bfd_get_section_vma (abfd, sec)
	      && vma < (bfd_get_section_vma (abfd, sec)
			+ bfd_section_size (abfd, sec) / opb))))
d748 1
d758 1
d762 2
a763 5
	  if (sorted_syms[i]->section == sec
	      && (i == 0
		  || sorted_syms[i - 1]->section != sec
		  || (bfd_asymbol_value (sorted_syms[i])
		      != bfd_asymbol_value (sorted_syms[i - 1]))))
d765 10
a774 2
	      thisplace = i;
	      break;
d778 3
a780 1
      if (sorted_syms[thisplace]->section != sec)
d786 2
a787 1
	      if (sorted_syms[i]->section == sec)
d795 2
a796 6
      if (sorted_syms[thisplace]->section != sec
	  && (aux->require_sec
	      || ((abfd->flags & HAS_RELOC) != 0
		  && vma >= bfd_get_section_vma (abfd, sec)
		  && vma < (bfd_get_section_vma (abfd, sec)
			    + bfd_section_size (abfd, sec)))))
a800 9
  /* Give the target a chance to reject the symbol.  */
  while (! info->symbol_is_valid (sorted_syms [thisplace], info))
    {
      ++ thisplace;
      if (thisplace >= sorted_symcount
	  || bfd_asymbol_value (sorted_syms [thisplace]) > vma)
	return NULL;
    }

@


1.126
log
@* objdump.c (load_debug_section): Select bias for DWARF debug addresses based on the flavour of the bfd.
@
text
@d1380 2
@


1.125
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d1977 13
a1989 1
  section->address = bfd_get_section_vma (abfd, sec);
@


1.124
log
@	* budemang.c: Delete.
	* budemang.h: Delete.
	* addr2line.c (translate_addresses): Call bfd_demangle rather than
	demangle.
	* nm.c (print_symname): Likewise.
	* objdump.c (objdump_print_symname, dump_symbols): Likewise.
	(dump_bfd): Likewise.
	* prdbg.c (struct pr_handle <demangler>): Add int param.
	(tg_variable, tg_start_function): Adjust demangler calls.
	* Makefile.am: Remove mention of budemang.[ch].  Run "make dep-am".
	* Makefile.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d51 1
@


1.123
log
@bfd/

2007-03-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.am (bfdver.h): Substitute report_bugs_to.  Also
	create doc/bfdver.texi.
	* Makefile.in: Regenerated.

	* configure.in (--with-bugurl): New option.
	* configure: Regenerated.

	* version.h (REPORT_BUGS_TO): New.

binutils/

2007-03-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.am (REPORT_BUGS_TO): Removed.
	(INCLUDES): Remove -DREPORT_BUGS_TO.
	* Makefile.in: Regenerated.

	* bucomm.c: Don't include bfdver.h.
	* objdump.c: Likewise.
	* version.c: Likewise.

	* bucomm.h: Include bfdver.h.

	* configure.in (--with-bugurl): Removed.
	* configure: Regenerated.

	* doc/Makefile.am (binutils_TEXINFOS): Removed.
	(AM_MAKEINFOFLAGS): Add -I ../../bfd/doc.
	(TEXI2DVI): Likewise.
	(config.texi): Removed.
	(MOSTLYCLEANFILES): Remove config.texi.
	* doc/Makefile.in: Regenerated.

	* doc/binutils.texi: Include bfdver.texi instead of
	config.texi.

gas/

2007-03-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.am (REPORT_BUGS_TO): Removed.
	(INCLUDES): Remove -DREPORT_BUGS_TO.
	* Makefile.in: Regenerated.

	* configure.in (--with-bugurl): Removed.
	* configure: Regenerated.

	* doc/Makefile.am (as_TEXINFOS): Remove gasver.texi.
	(AM_MAKEINFOFLAGS): Add -I ../../bfd/doc.
	(TEXI2DVI): Likewise.
	(gasver.texi): Removed.
	(MOSTLYCLEANFILES): Remove gasver.texi.
	(as.1): Don't depend on gasver.texi.
	* doc/Makefile.in: Regenerated.

	* doc/as.texi: Include bfdver.texi instead of gasver.texi.

gprof/

2007-03-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.am (REPORT_BUGS_TO): Removed.
	(INCLUDES): Remove -DREPORT_BUGS_TO.
	* Makefile.in: Regenerated.

	* configure.in (--with-bugurl): Removed.
	* configure: Regenerated.

ld/

2007-03-15  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.am (ld_TEXINFOS): Remove ldver.texi.
	(AM_MAKEINFOFLAGS): Add -I ../../bfd/doc.
	(TEXI2DVI): Likewise.
	(REPORT_BUGS_TO): Removed.
	(INCLUDES): Remove -DREPORT_BUGS_TO.
	(ldver.texi): Likewise.
	(ld.1): Don't depend on ldver.texi.
	(MOSTLYCLEANFILES): Remove ldver.texi.
	* Makefile.in: Regenerated.

	* configure.in (--with-bugurl): Removed.
	* configure: Regenerated.

	* lexsup.c: Include bfdver.h.

	* ld.texinfo: Include bfdver.texi instead of ldver.texi.
@
text
@a54 1
#include "budemang.h"
d651 3
a653 2
      alloc = demangle (abfd, name);
      name = alloc;
d2517 3
a2519 2
	      alloc = demangle (cur_bfd, name);
	      (*current)->name = alloc;
d2522 5
a2526 2
	      (*current)->name = name;
	      free (alloc);
d2832 3
a2834 2
	  if (! print_debugging_info (stdout, dhandle, abfd, syms, demangle,
	      dump_debugging_tags ? TRUE : FALSE))
@


1.122
log
@top level:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.ac (TOPLEVEL_CONFIGURE_ARGUMENTS): Fix quoting.
	* configure: Regenerate.

bfd:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-pkgversion): New option.
	* configure: Regenerate.
	* Makefile.am (bfdver.h): Substitute for @@bfd_version_package@@.
	* Makefile.in: Regenerate.
	* version.h (BFD_VERSION_STRING): Define using
	@@bfd_version_package@@.

bfd/doc:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* Makefile.in: Regenerate.

binutils:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-bugurl): New option.
	* configure: Regenerate.
	* Makefile.am (REPORT_BUGS_TO): Define.
	(INCLUDES): Define REPORT_BUGS_TO.
	Regenerate dependencies.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* bucomm.h: Remove include of bin-bugs.h.
	* addr2line.c (usage): Don't print empty REPORT_BUGS_TO.
	* ar.c (usage): Pass s to list_supported_targets.  Don't print
	empty REPORT_BUGS_TO.
	* coffdump.c (show_usage): Don't print empty REPORT_BUGS_TO.
	* cxxfilt.c (usage): Print bug url when giving help.
	* dlltool.c (usage): Likewise.
	* dllwrap.c (usage): Likewise.
	* nlmconv.c (show_usage): Don't print empty REPORT_BUGS_TO.
	* nm.c (usage): Likewise.
	* objcopy.c (copy_usage, strip_usage): Likewise.
	* objdump.c (usage): Likewise.
	* readelf.c ((usage): Likewise. Add STREAM argument.  Adjust
	callers.
	* size.c (usage): Don't print empty REPORT_BUGS_TO.
	* srconv.c (show_usage): Likewise.
	* strings.c (usage): Likewise.
	* sysdymp.c (show_usage): Likewise.
	* windres.c (usage): Likewise.

gas:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-bugurl): New option.
	* configure: Regenerate.
	* dep-in.sed: Remove bin-bugs.h.
	* Makefile.am (REPORT_BUGS_TO): Define.
	(INCLUDES): Define REPORT_BUGS_TO.
	(DEP_INCLUDES): Likewise.
	($(OBJS)): No longer depend on bin-bugs.h.
	* Makefile.in: Regenerate.
	* doc/Makefile.in: Regenerate.
	* as.c (show_usage): Don't print empty REPORT_BUGS_TO.
	* as.h: Remove include of bin-bugs.h.

gprof:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-pkgversion, --with-bugurl): New options.
	* configure: Regenerate.
	* Makefile.am (PKGVERSION, REPORT_BUGS_TO): Define.
	(INCLUDES): Define PKGVERSION and REPORT_BUGS_TO.
	Regenerate dependencies.
	* Makefile.in: Regenerate.
	* gprof.c (usage): Don't print empty REPORT_BUGS_TO.
	(main): Include PKGVERSION in version output.
	* gprof.h: Remove include of bin-bugs.h.

include:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* bin-bugs.h: Remove.

ld:
2007-02-17  Mark Mitchell  <mark@@codesourcery.com>
            Nathan Sidwell  <nathan@@codesourcery.com>
            Vladimir Prus  <vladimir@@codesourcery.com
            Joseph Myers  <joseph@@codesourcery.com>

	* configure.in (--with-bugurl): New option.
	* configure: Regenerate.
	* Makefile.am (REPORT_BUGS_TO): Define.
	(INCLUDES): Define REPORT_BUGS_TO.
	Regenerate dependencies.
	* Makefile.in: Regenerate.
	* ld.h: Remove include of bin-bugs.h.
	* lexsup.c (help): Don't print empty REPORT_BUGS_TO.
@
text
@a51 1
#include "bfdver.h"
@


1.121
log
@2006-10-30  Paul Brook  <paul@@codesourcery.com>

	binutils/
	* objdump.c (disassemble_section): Set info->symtab_pos.
	(disassemble_data): Set info->symtab and info->symtab_size.

	include/
	* dis-asm.h (disassemble_info): Add symtab, symtab_pos and
	symtab_size.

	opcodes/
	* arm-dis.c (last_is_thumb, last_mapping_sym, last_mapping_addr): New.
	(get_sym_code_type): New function.
	(print_insn): Search for mapping symbols.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005, 2006
d228 1
a228 1
  if (status == 0)
@


1.120
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d1751 1
d1757 1
d1950 2
@


1.119
log
@ PR binutils/3001
* addr2line.c (process_file): Change function from void to returning an int.  Return 0 upon success, 1 otherwise.
 (main): Use return value from process_file as the exit value.
* ar.c (ranlib_only):  Change function from void to returning an int.  Return 0 upon success, 1 otherwise.
  (ranlib_touch): Likewise.
  (main): Use return value from ranlib functions as exit value.
* objcopy.c (add_specific_symbol): Set status to 1 if get_file_size fails.
  (copy_file): Likewise.
  (strip_main): Likewise.
  (copy_main): Likewise.
* objdump.c (display_file): Set exit_status to 1 if get_file_size fails.
* size.c (display_file): Set return_code to 1 if get_file_size fails.
@
text
@d2018 1
a2018 1
  if (strncmp (name, ".gnu.linkonce.wi.", 17) == 0)
@


1.118
log
@Fix typo
@
text
@d2905 4
a2908 1
    return;
@


1.117
log
@	* configure.in (CHECK_DECLS): Add snprintf and vsnprintf.
	* configure: Regenerate.
	* objdump.c (fprintf): Remove declaration.
	* bucomm.h (fprintf): Declare if not already declared.
	(snprintf): Likewise.
	(vsnprintf): Likewise.
@
text
@d902 1
a902 1
/* Determine of the given address has a symbol associated with it.  */
@


1.117.2.1
log
@Merge changes between binutils-csl-2_17-branchpoint and
binutils-2_17, except for the addition of generated files to CVS.
@
text
@d902 1
a902 1
/* Determine if the given address has a symbol associated with it.  */
@


1.117.2.2
log
@	binutils/
	* Makefile.am: Rebuild dependencies.
	(REPORT_BUGS_TO): Always defined.
	(INCLUDES): Adjust.
	* Makefile.in: Rebuilt.
	* configure.in (REPORT_BUGS_TO): Provide default value.
	* configure: Rebuilt.
	* bucomm.h: Remove bin-bugs.h.
	* addr2line.c (usage): Don't print empty REPORT_BUGS_TO.
	* coffdump.c (show_usage): Likewise.
	* cxxfilt.c (usage): Likewise.
	* nlmconv.c (show_usage): Likewise.
	* nm.c (usage): Likewise.
	* objcopy.c (copy_usage, strip_usage): Likewise.
	* objdump.c (usage): Likewise.
	* size.c (usage): Likewise.
	* srconv.c (show_usage): Likewise.
	* string.c (usage): Likewise.
	* sysdymp.c (show_usage): Likewise.
	* windres.c (usage): Likewise.
	* readelf (usage): Likewise. Add STREAM argument.  Adjust callers.

	gas/
	* Makefile.am: Rebuild dependencies.
	(REPORT_BUGS_TO): Always defined.
	(INCLUDES): Adjust.
	* Makefile.in: Rebuilt.
	* configure.in (REPORT_BUGS_TO): Provide default value.
	* configure: Rebuilt.
	* as.c (show_usage): Don't print empty REPORT_BUGS_TO.
	* as.h: Remove bin-bugs.h.

	ld/
	* Makefile.am: Rebuild dependencies.
	(REPORT_BUGS_TO): Always defined.
	(INCLUDES): Adjust.
	* Makefile.in: Rebuilt.
	* configure.in (REPORT_BUGS_TO): Provide default value.
	* configure: Rebuilt.
	* ld.h: Remove bin-bugs.h
	* lexsup.c (help):  Don't print empty REPORT_BUGS_TO.

	gprof/
	* Makefile.am: Rebuild dependencies.
	(REPORT_BUGS_TO): Always defined.
	(PKGVERSION): Define.
	(INCLUDES): Adjust.
	* Makefile.in: Rebuilt.
	* configure.in (REPORT_BUGS_TO): Provide default value.
	* configure: Rebuilt.
	* gprof.c (usage): Don't print empty REPORT_BUGS_TO.
	* gprof.h: Remove bin-bugs.h

	include/
	* bin-bugs.h: Remove.
@
text
@d228 1
a228 1
  if (REPORT_BUGS_TO[0] && status == 0)
@


1.117.2.3
log
@2006-10-26  Paul Brook  <paul@@codesourcery.com>

	binutils/
	* objdump.c (disassemble_section): Set info->symtab_pos.
	(disassemble_data): Set info->symtab and info->symtab_size.

	include/
	* dis-asm.h (disassemble_info): Add symtab, symtab_pos and
	symtab_size.

	opcodes/
	* arm-dis.c (last_is_thumb, last_mapping_sym, last_mapping_addr): New.
	(get_sym_code_type): New function.
	(print_insn): Search for mapping symbols.
@
text
@a1750 1
	  pinfo->symtab_pos = place;
a1755 1
	  pinfo->symtab_pos = -1;
a1947 2
  disasm_info.symtab = sorted_syms;
  disasm_info.symtab_size = sorted_symcount;
@


1.116
log
@	PR binutils/1486
binutils/:
	* configure.in: Don't define DISASSEMBLER_NEEDS_RELOCS.
	* configure: Regenerate.
	* objdump.c (struct objdump_disasm_info): Don't check for
	DISASSEMBLER_NEEDS_RELOCS.
	(objdump_print_addr): Likewise.
	(disassemble_bytes): Check disassembler_needs_relocs from
	disassemble_info at run-time instead of DISASSEMBLER_NEEDS_RELOCS
	at compile-time.
	(disassemble_section): Likewise.
	(disassemble_data): Initialize it.

include/:
	* dis-asm.h (struct disassemble_info): Add
	disassembler_needs_relocs.

objdump/:
	* disassemble.c (disassemble_init_for_target): Set
	disassembler_needs_relocs for bfd_arch_arm.
@
text
@a68 5
#if !HAVE_DECL_FPRINTF
/* This is needed by init_disassemble_info().  */
extern int fprintf (FILE *, const char *, ...);
#endif

@


1.115
log
@	* addr2line.c (usage): Document @@file.
	* ar.c (usage): Likewise.
	* coffdump (usage): Likewise.
	* cxxfilt.c (usage): Likewise.
	* dlltool.c (usage): Likewise.
	* dllwrap.c (usage): Likewise.
	* nlmconv.c (usage): Likewise.
	* nm.c (usage): Likewise.
	* objcopy.c (usage): Likewise.
	* objdump.c (usage): Likewise.
	* readelf.c (usage): Likewise.
	* size.c (usage): Likeise.
	* srconv.c (usage): Likewise.
	* strings.c (usage): Likewise.
	* windres.c (usage): Likewise.
	* doc/binutils.texi: Add section on common options.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004, 2005
a132 1
#ifdef DISASSEMBLER_NEEDS_RELOCS
a133 1
#endif
a866 1
#ifdef DISASSEMBLER_NEEDS_RELOCS
a867 1
#endif
a877 1
#ifdef DISASSEMBLER_NEEDS_RELOCS
a891 1
#endif
a1315 1
#ifdef DISASSEMBLER_NEEDS_RELOCS
a1319 1
#endif
d1384 2
a1385 2
#ifdef DISASSEMBLER_NEEDS_RELOCS
	      if (*relppp < relppend)
d1415 1
a1415 1
#endif
d1667 1
a1667 4
#ifndef DISASSEMBLER_NEEDS_RELOCS
	  && dump_reloc_info
#endif
	  )
a1873 1
#ifdef DISASSEMBLER_NEEDS_RELOCS
a1874 1
#endif
d1916 1
@


1.114
log
@	* addr2line.c (main): Likewise.
	* ar.c (main): Likewise.
	* coffdump.c (main): Likewise.
	* cxxfilt.c (main): Likewise.
	* dlltool.c (main): Likewise.
	* dllwrap.c (main): Likewise.
	* nlmconv.c (main): Likewise.
	* nm.c (main): Likewise.
	* objcopy.c (main): Likewise.
	* objdump.c (main): Likewise.
	* readelf.c (main): Likewise.
	* size.c (main): Likeiwse.
	* srcconv.c (main): Likewise.
	* strings.c (main): Likewise.
	* sysdump.c (main): Likewise.
	* sysinfo.c (main): Likewise.
	* windres.c (main): Likewise.

	* ldmain.c (main): Use expandargv.

	* gprof.c (main): Use expandargv.

	* as.c (main): Use expandargv.
@
text
@d199 1
@


1.113
log
@2005-09-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* dwarf.c (fetch_indirect_string): Adjust for section address.
	(process_debug_info): Likewise.
	(display_debug_loc): Likewise.
	(display_debug_ranges): Likewise.

	* objdump.c (mach_o_dwarf_sections): New.
	(generic_dwarf_sections): Likewise.
	(check_mach_o_dwarf): Likewise.
	(dump_dwarf): Call check_mach_o_dwarf.
@
text
@d2986 2
@


1.112
log
@2005-09-30  H.J. Lu  <hongjiu.lu@@intel.com>

	* Makefile.am (objdump_SOURCES): Add dwarf.c.
	* Makefile.in: Regenerated.

	* objdump.c: Include "dwarf.h".
	(usage): Add -W/--dwarf.
	(long_options): Likewise.
	(dump_dwarf_section_info): New.
	(load_debug_section): Likewise.
	(free_debug_section): Likewise.
	(dump_dwarf_section): Likewise.
	(dump_dwarf): Likewise.
	(dump_bfd): Load symbol table and call dump_dwarf if
	dump_dwarf_section_info isn't zero.
	(main): Handle -W/--dwarf.
@
text
@d2058 45
d2122 2
@


1.111
log
@bfd/

2005-08-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/1179
	* dwarf2.c (_bfd_dwarf2_find_nearest_line): Use section lma
	instead of vma.
	(_bfd_dwarf2_find_line): Likewise.

binutils/

2005-08-17  H.J. Lu  <hongjiu.lu@@intel.com>

	PR binutils/1179
	* objdump.c (disassemble_bytes): Don't adjust
	adjust_section_vma.
	(adjust_addresses): Don't adjust vma for debugging section.
	Adjust lma only for relocatable files.
	(dump_bfd): Tell adjust_addresses if it is a relocatable file.
@
text
@d55 1
d95 1
d194 1
d281 1
d1972 110
d2753 5
a2757 1
  if (dump_symtab || dump_reloc_info || disassemble || dump_debugging)
d2774 2
d2942 1
a2942 1
  while ((c = getopt_long (argc, argv, "pib:m:M:VvCdDlfaHhrRtTxsSI:j:wE:zgeG",
d3083 14
@


1.110
log
@Kaveh Ghazi's printf format attribute checking patch.
bfd:
	* elf32-xtensa.c (vsprint_msg): Add format attribute.  Fix
	format bugs.
	* vms.h (_bfd_vms_debug): Add format attribute.
	(_bfd_vms_debug, _bfd_hexdump): Fix typos.

binutils:
	* bucomm.h (report): Add format attribute.
	* dlltool.c (inform): Likewise.
	* dllwrap.c (display, inform, warn): Likewise.
	* objdump.c (objdump_sprintf): Likewise.
	* readelf.c (error, warn): Likewise.  Fix format bugs.

gas:
	* config/tc-tic30.c (debug): Add format attribute.  Fix format
	bugs.

include:
	* dis-asm.h (fprintf_ftype): Add format attribute.

opcodes:
	* arc-dis.c, arm-dis.c, cris-dis.c, crx-dis.c, d10v-dis.c,
	d30v-dis.c, fr30-dis.c, h8300-dis.c, h8500-dis.c, i860-dis.c,
	ia64-dis.c, ip2k-dis.c, m10200-dis.c, m10300-dis.c,
	m88k-dis.c, mcore-dis.c, mips-dis.c, ms1-dis.c, or32-dis.c,
	ppc-dis.c, sh64-dis.c, sparc-dis.c, tic4x-dis.c, tic80-dis.c,
	v850-dis.c: Fix format bugs.
	* ia64-gen.c (fail, warn): Add format attribute.
	* or32-opc.c (debug): Likewise.
@
text
@d1357 1
a1357 4
	    /* The line number tables will refer to unadjusted
	       section VMAs, so we must undo any VMA modifications
	       when calling show_line.  */
	    show_line (aux->abfd, section, addr_offset - adjust_section_vma);
d2600 1
a2600 1
		  void *dummy ATTRIBUTE_UNUSED)
d2602 7
a2608 2
  section->vma += adjust_section_vma;
  section->lma += adjust_section_vma;
d2620 4
a2623 1
    bfd_map_over_sections (abfd, adjust_addresses, NULL);
@


1.109
log
@	* configure.in (AM_BINUTILS_WARNINGS): Add.
	(BFD_NEED_DECLARATION): Replace with AC_CHECK_DECLS.
	* configure: Regenerate.
	* config.in: Regenerate.
	* objdump.c (NEED_DECLARATION_*): Replace with !HAVE_DECL_*.
	* bucomm.h: (NEED_DECLARATION_*): Ditto.
@
text
@d1192 1
a1192 1
static int
@


1.108
log
@	* objdump.c (disassemble_bytes): Don't crash if q->howto == NULL.
	If q->howto->name == NULL, print q->howto->type as number instead.
	(dump_reloc_set): Likewise.
@
text
@d68 1
a68 1
#ifdef NEED_DECLARATION_FPRINTF
@


1.107
log
@Update FSF address
@
text
@d1573 6
a1578 1
	      printf (": %s\t", q->howto->name);
d2473 7
d2481 1
a2481 8
	{
	  bfd_printf_vma (abfd, q->address);
	  if (q->howto->name)
	    printf (" %-16s  ", q->howto->name);
	  else
	    printf (" %-16d  ", q->howto->type);
	  objdump_print_symname (abfd, NULL, *q->sym_ptr_ptr);
	}
d2486 1
a2486 4
	  bfd_printf_vma (abfd, q->address);
	  printf (" %-16s  [%s]",
		  q->howto->name,
		  section_name);
@


1.106
log
@2005-04-19  H.J. Lu  <hongjiu.lu@@intel.com>

	* objdump.c (dump_section_header): Skip linker created section.
@
text
@d20 1
a20 1
   Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.105
log
@2005-04-17  H.J. Lu  <hongjiu.lu@@intel.com>

	* objdump.c (dump_section_header): Support SEC_GROUP.
@
text
@d302 5
@


1.104
log
@Add a check to see if the section for the symbol is chosen using
process_section_p.
@
text
@d339 1
@


1.103
log
@	* objdump.c (disassemble_bytes): Remove cast.
@
text
@d2348 3
a2350 2
      else if (dump_special_syms
	       || !bfd_is_target_special_symbol (cur_bfd, *current))
d2373 1
@


1.102
log
@2005-03-18  Paul Brook  <paul@@codesourcery.com>

	* objdump.c (objdump_print_addr): Avoid uninitialized warning.
@
text
@d1379 1
a1379 1
	      info->stream = (FILE *) &sfile;
@


1.101
log
@objdump.c: Fix coding for DISASSEMBLER_NEEDS_RELOC:
(struct objdump_disasm_info): Add 'reloc' field.
(disassemble_bytes): Fix check for when an insn has a reloc associated with it.
Improve comment explaining why the use of octets is wrong.  Set the 'reloc'
field in objdump_disasm_info structure.
(objdump_print_addr): Use new 'reloc' field to lookup the correct address for
the symbol associated with the current instruction's relocation.
(disassemble_info): Initialise 'reloc' field.

gas/arm/inst.d: Allow for ARM ports which decode the reloc associated with
branches and so show the exact symbolic destination address rather than an
offset from the start of the section.

gas/arm/pic.d: Likewise.
@
text
@d857 1
a857 1
  asymbol *sym;
@


1.101.2.1
log
@PR binutils/813
Add a check to see if the section for the symbol is chosen using
process_section_p.
@
text
@d2348 2
a2349 3
      else if (process_section_p ((* current)->section)
	       && (dump_special_syms
		   || !bfd_is_target_special_symbol (cur_bfd, *current)))
@


1.101.2.1.2.1
log
@	* ld/ldmain.c (main): Use expandargv.
	* binutils/addr2line.c (main): Likewise.
	* binutils/ar.c (main): Likewise.
	* binutils/coffdump.c (main): Likewise.
	* binutils/cxxfilt.c (main): Likewise.
	* binutils/dlltool.c (main): Likewise.
	* binutils/dllwrap.c (main): Likewise.
	* binutils/nlmconv.c (main): Likewise.
	* binutils/nm.c (main): Likewise.
	* binutils/objcopy.c (main): Likewise.
	* binutils/objdump.c (main): Likewise.
	* binutils/readelf.c (main): Likewise.
	* binutils/size.c (main): Likeiwse.
	* binutils/srcconv.c (main): Likewise.
	* binutils/strings.c (main): Likewise.
	* binutils/sysdump.c (main): Likewise.
	* binutils/sysinfo.c (main): Likewise.
	* binutils/windres.c (main): Likewise.

	* include/libiberty.h (expandargv): New function.
	* libiberty/argv.c (safe-ctype.h): Include it.
	(ISBLANK): Remove.
	(stdio.h): Include.
	(expandargv): New function.
	* libiberty/Makefile.in: Regenerated.
@
text
@a2804 2
  expandargv (&argc, &argv);

@


1.100
log
@	* dlltool.c: Warning fixes.
	* objdump.c: Likewise.
@
text
@d131 3
d858 3
d870 19
a888 1
  sym = find_symbol_for_address (vma, info, NULL);
d1265 1
a1309 1
      int octets = 0;
d1311 7
d1382 1
d1385 30
a1414 8
	      /* FIXME: This is wrong.  It tests the number of octets
		 in the last instruction, not the current one.  */
	      if (*relppp < relppend
		  && (**relppp)->address >= rel_offset + addr_offset
		  && ((**relppp)->address
		      < rel_offset + addr_offset + octets / opb))
		info->flags = INSN_HAS_RELOC;
	      else
a1415 2
		info->flags = 0;

d1872 3
@


1.99
log
@bfd/

2005-02-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* coffcode.h (sec_to_styp_flags): Replaced SEC_CLINK with
	SEC_TIC54X_CLINK. Replace SEC_BLOCK with SEC_TIC54X_BLOCK.
	Replace SEC_SHARED with SEC_COFF_SHARED.
	(styp_to_sec_flags): Likewise.

	* elfxx-target.h (TARGET_BIG_SYM): Remove SEC_ARCH_BIT_0.
	(TARGET_LITTLE_SYM): Likewise.

	* section.c (SEC_ARCH_BIT_0): Removed.
	(SEC_LINK_DUPLICATES_SAME_CONTENTS): Defined with
	SEC_LINK_DUPLICATES_ONE_ONLY and SEC_LINK_DUPLICATES_SAME_SIZE.
	(SEC_SHARED): Renamed to ...
	(SEC_COFF_SHARED): This.
	(SEC_BLOCK): Renamed to ...
	(SEC_TIC54X_BLOCK): This.
	(SEC_CLINK): Renamed to ...
	(SEC_TIC54X_CLINK): This.
	(SEC_XXX): Rearranged. Move SEC_COFF_SHARED_LIBRARY,
	SEC_COFF_SHARED, SEC_TIC54X_BLOCK and SEC_TIC54X_CLINK to the
	end.
	* bfd-in2.h: Regenerated.

binutils/

2005-02-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* objcopy.c (parse_flags): Replace SEC_SHARED with
	SEC_COFF_SHARED.

	* objdump.c (dump_section_header): Dump SEC_TIC54X_BLOCK and
	SEC_TIC54X_CLINK for TI c54x only. Remove SEC_ARCH_BIT_0. Dump
	SEC_COFF_SHARED for COFF only.

gas/

2005-02-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* config/obj-coff.c (obj_coff_section): Replace SEC_SHARED with
	SEC_COFF_SHARED.

	* config/tc-tic54x.c (tic54x_bss): Replace SEC_BLOCK with
	SEC_TIC54X_BLOCK.
	(demand_empty_rest_of_line): Likewise.
	(tic54x_sblock): Likewise.
	(tic54x_clink): Replace with SEC_CLINK with SEC_TIC54X_CLINK.

ld/

2005-02-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldlang.c (lang_add_section): Check SEC_TIC54X_BLOCK for TI
	tic54x input only.
	(lang_size_sections_1): Check SEC_COFF_SHARED_LIBRARY for COFF
	and ECOFF output only.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003, 2004
d2059 2
a2060 1
	  stabs = read_section_stabs (abfd, section->name, &stab_size);
@


1.98
log
@binutils/:
	* configure.in: Don't define SKIP_ZEROES.
	* configure: Regenerate.
	* objdump.c (disassemble_data): Set skip_zeroes and
	skip_zeroes_at_end in disasm_info to defaults.
	(DEFAULT_SKIP_ZEROES): Rename from SKIP_ZEROES and always define.
	(DEFAULT_SKIP_ZEROES_AT_END): Rename from SKIP_ZEROES_AT_END and
	always define.
	(disassemble_bytes): Use skip_zeroes and skip_zeroes_at_end from
	objdump_disasm_info.

include/:
	* dis-asm.h (struct disassemble_info): Add skip_zeroes and
	skip_zeroes_at_end.

opcodes/:
	* disassemble.c (disassemble_init_for_target) <case
	bfd_arch_ia64>: Set skip_zeroes to 16.
	<case bfd_arch_tic4x>: Set skip_zeroes to 32.
@
text
@d293 1
a293 1
dump_section_header (bfd *abfd ATTRIBUTE_UNUSED, asection *section,
d327 5
a331 2
  PF (SEC_BLOCK, "BLOCK");
  PF (SEC_CLINK, "CLINK");
d333 2
a334 2
  PF (SEC_SHARED, "SHARED");
  PF (SEC_ARCH_BIT_0, "ARCH_BIT_0");
@


1.97
log
@	* objdump.c (remove_useless_symbols): Discard section symbols.
@
text
@d1205 1
a1205 3
#ifndef SKIP_ZEROES
#define SKIP_ZEROES (8)
#endif
d1214 1
a1214 3
#ifndef SKIP_ZEROES_AT_END
#define SKIP_ZEROES_AT_END (3)
#endif
d1235 3
a1237 1
  int opb = info->octets_per_byte;
d1293 1
a1293 1
	  && (z - addr_offset * opb >= SKIP_ZEROES
d1295 1
a1295 1
		  z - addr_offset * opb < SKIP_ZEROES_AT_END)))
d1856 2
@


1.96
log
@	* objdump.c (dump_symbols): Fix thinko last change.  Improve error
	messages.
@
text
@d461 1
a461 1
      if (sym->flags & (BSF_DEBUGGING))
@


1.95
log
@Implement a new BFD API function: bfd_is_target_special_symbol.  Use this in nm
and objdump to skip the displaying of ARM Mapping symbols unless specifically
requested.
@
text
@d2283 1
a2283 1
	printf (_("no information for the %ld'th symbol"), count);
d2286 1
a2286 1
	printf (_("could not determine the type of the %ld'th symbol"),
d2289 2
a2290 5
      else if (! dump_special_syms
	       && bfd_is_target_special_symbol (cur_bfd, *current))
	continue;

      else
d2311 1
a2312 2

      printf ("\n");
@


1.94
log
@bfd/
	* bfd.c (bfd_get_synthetic_symtab): Pass counts and both symbol tables.
	* elf-bfd.h (_bfd_elf_get_synthetic_symtab): Adjust.
	* elf.c (_bfd_elf_get_synthetic_symtab): Adjust.
	* libbfd-in.h (_bfd_nodynamic_get_synthetic_symtab): Adjust.
	* targets.c (struct bfd_target <_bfd_get_synthetic_symtab>): Adjust.
	* elf64-ppc.c (ppc64_elf_get_synthetic_symtab): Don't read symbols.
	Use both symbol tables on non-relocatable objects.  Use a common
	error exit.  Fix "mid" warning.
	* libbfd.h: Regenerate.
	* bfd-in2.h: Regenerate.
binutils/
	* objdump.c (dump_bfd): Pass both symbol tables to
	bfd_get_synthetic_symtab.
@
text
@d105 1
d221 1
d273 1
d2289 4
@


1.93
log
@bfd/
	* elfxx-target.h (bfd_elfNN_get_synthetic_symtab): Only define
	if not yet defined.
	* elf64-ppc.c (bfd_elf64_get_synthetic_symtab): Define.
	(synthetic_opd, synthetic_relocatable): New variables.
	(compare_symbols, compare_relocs): New helper routines.
	(ppc64_elf_get_synthetic_symtab): New function.
	* bfd.c (bfd_get_synthetic_symtab): Rename dynsyms argument
	to relsyms.
	* bfd-in2.h: Regenerated.
	* elf.c (_bfd_elf_get_synthetic_symtab): Rename dynsyms argument
	to relsyms.  Return 0 if abfd is relocatable.
binutils/
	* objdump.c (dump_bfd): For relocatable objects, pass syms instead
	of dynsyms to bfd_get_synthetic_symtab.
@
text
@d2569 4
a2572 12
      synthcount = 0;
      if (bfd_get_file_flags (abfd) & (DYNAMIC | EXEC_P))
	{
	  if (dynsymcount > 0)
	    synthcount = bfd_get_synthetic_symtab (abfd, dynsyms, &synthsyms);
	}
      else
	{
	  if (symcount > 0)
	    synthcount = bfd_get_synthetic_symtab (abfd, syms, &synthsyms);
	}
      if (synthcount < 0) synthcount = 0;
@


1.92
log
@Fix for PR 280 - remove duplicated raw insn output fron h8300/h8500 disassemblers
@
text
@d2567 1
a2567 1
  if (disassemble && dynsymcount > 0)
d2569 11
a2579 1
      synthcount = bfd_get_synthetic_symtab (abfd, dynsyms, &synthsyms);
@


1.91
log
@bfd/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* aout-adobe.c (aout_32_section_already_linked): Defined.
	* aout-target.h (MY_section_already_linked): Likewise.
	* aout-tic30.c (MY_section_already_linked): Likewise.
	* binary.c (binary_section_already_linked): Likewise.
	* bout.c (b_out_section_already_linked): Likewise.
	* coff-alpha.c (_bfd_ecoff_section_already_linked): Likewise.
	* coff-mips.c (_bfd_ecoff_section_already_linked): Likewise.
	* coffcode.h (coff_section_already_linked): Likewise.
	* i386msdos.c (msdos_section_already_linked): Likewise.
	* i386os9k.c (os9k_section_already_linked): Likewise.
	* ieee.c (ieee_section_already_linked): Likewise.
	* ihex.c (ihex_section_already_linked): Likewise.
	* mach-o.c (bfd_mach_o_section_already_linked): Likewise.
	* mmo.c (mmo_section_already_linked): Likewise.
	* nlm-target.h (nlm_section_already_linked): Likewise.
	* oasys.c (oasys_section_already_linked): Likewise.
	* pef.c (bfd_pef_section_already_linked): Likewise.
	* ppcboot.c (ppcboot_section_already_linked): Likewise.
	* som.c (som_bfd_discard_group): Likewise.
	* srec.c (srec_section_already_linked): Likewise.
	* tekhex.c (tekhex_section_already_linked): Likewise.
	* versados.c (versados_section_already_linked): Likewise.
	* vms.c (vms_section_already_linked): Likewise.
	* coff-target.h (_bfd_xcoff_section_already_linked): Likewise.
	* xsym.c (bfd_sym_section_already_linked): Likewise.

	* bfd-in.h (bfd_section_already_linked_table_init): New.
	(bfd_section_already_linked_table_free): Likewise.

	* coff-rs6000.c (rs6000coff_vec): Add
	_bfd_generic_section_already_linked.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Likewise.
	(aix5coff64_vec): Likewise.

	* elf-bfd.h (_bfd_elf_section_already_linked): New prototype.
	* elflink.c (_bfd_elf_section_already_linked): New function.

	* elfxx-target.h (bfd_elfNN_section_already_linked): Defined.

	* libbfd-in.h (_bfd_nolink_section_already_linked): Defined.
	(_bfd_generic_section_already_linked): New.
	(bfd_section_already_linked_hash_entry): Likewise.
	(bfd_section_already_linked): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.

	* linker.c (bfd_section_already_linked): New.
	(_bfd_section_already_linked_table): Likewise.
	(bfd_section_already_linked_table_lookup): Likewise.
	(bfd_section_already_linked_table_insert): Likewise.
	(already_linked_newfunc): Likewise.
	(bfd_section_already_linked_table_init): Likewise.
	(bfd_section_already_linked_table_free): Likewise.
	(_bfd_generic_section_already_linked): Likewise.

	* section.c (bfd_section): Remove comdat.
	(bfd_comdat_info): Moved to ...
	* bfd-in.h (coff_comdat_info): Here.
	(bfd_coff_get_comdat_section): New.
	* coffgen.c (bfd_coff_get_comdat_section): Likewise.
	* libcoff-in.h (coff_section_tdata): Add comdat.
	* coffcode.h (handle_COMDAT): Updated.
	* cofflink.c (coff_link_add_symbols): Likewise.
	* ecoff.c (bfd_debug_section): Likewise.

	* targets.c (bfd_target): Add _section_already_linked.
	(BFD_JUMP_TABLE_LINK): Updated.

	* bfd-in2.h: Regenerated.
	* libbfd.h: Likewise.
	* libcoff.h: Likewise.

binutils/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* objcopy.c (filter_symbols): Use bfd_coff_get_comdat_section
	to access comdat.
	* objdump.c (dump_section_header): Likewise.

ld/

2004-07-21  H.J. Lu  <hongjiu.lu@@intel.com>

	* ldlang.c (already_linked_hash_entry): Removed.
	(already_linked): Likewise.
	(already_linked_table): Likewise.
	(section_already_linked): Call bfd_section_already_linked.
	(lang_process): Replace already_linked_table_init with
	bfd_section_already_linked_table_init and check return. Replace
	already_linked_table_free with bfd_section_already_linked_table_free.
@
text
@d1410 1
@


1.90
log
@	* objcopy.c (copy_section): Use bfd_get_section_size instead of
	_raw_size or bfd_get_section_size_before_reloc.  Don't set reloc_done.
	(compare_section_lma): Likewise.
	* addr2line.c (find_address_in_section): Likewise.
	* coffgrok.c (do_sections_p1): Likewise.
	* dlltool.c (scan_drectve_symbols): Likewise.
	* nlmconv.c (main): Likewise.
	(copy_sections): Likewise.
	(powerpc_mangle_relocs): Likewise.
	* objdump.c (disassemble_section): Likewise.
	* prdbg.c (find_address_in_section): Likewise.
	* size.c (berkeley_sum): Likewise.
	* srconv.c (wr_ob): Likewise.
	* strings.c (strings_a_section): Likewise.
@
text
@d334 1
d355 3
a357 3
      if (section->comdat != NULL)
	printf (" (COMDAT %s %ld)", section->comdat->name,
		section->comdat->symbol);
@


1.89
log
@	* objdump.c (disassemble_section): Don't disassemble sections
	without SEC_HAS_CONTENTS.
@
text
@d1582 1
a1582 1
  datasize = bfd_get_section_size_before_reloc (section);
@


1.88
log
@bfd/
	* bfd.c (bfd_get_synthetic_symtab): Define.
	* targets.c (BFD_JUMP_TABLE_DYNAMIC): Add
	NAME##_get_synthetic_symtab.
	(struct bfd_target): Add _bfd_get_synthetic_symtab.
	* libbfd-in.h (_bfd_nodynamic_get_synthetic_symtab): Define.
	* elf-bfd.h (struct elf_backend_data): Add plt_sym_val and
	relplt_name fields.
	(_bfd_elf_get_synthetic_symtab): New prototype.
	* elfcode.h (elf_get_synthetic_symtab): Define.
	* elf.c (_bfd_elf_get_synthetic_symtab): New function.
	* elfxx-target.h (bfd_elfNN_get_synthetic_symtab): Define.
	(elf_backend_plt_sym_val, elf_backend_relplt_name): Define.
	(elfNN_bed): Add elf_backend_plt_sym_val and elf_backend_relplt_name.
	* bfd-in2.h: Rebuilt.
	* libbfd.h: Rebuilt.
	* elf32-i386.c (elf_i386_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf64-x86-64.c (elf64_x86_64_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf32-s390.c (elf_s390_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf64-s390.c (elf_s390_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf32-sparc (elf32_sparc_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf64-sparc.c (sparc64_elf_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* elf32-ppc.c (ppc_elf_plt_sym_val): New function.
	(elf_backend_plt_sym_val): Define.
	* aout-target.h (MY_get_synthetic_symtab): Define.
	* aout-tic30.c (MY_get_synthetic_symtab): Define.
	* coff-rs6000.c (rs6000coff_vec): Add
	_bfd_nodynamic_get_synthetic_symtab.
	(pmac_xcoff_vec): Likewise.
	* coff64-rs6000.c (rs6000coff64_vec): Add
	_bfd_nodynamic_get_synthetic_symtab.
	(aix5coff64_vec): Likewise.
	* sunos.c (MY_get_synthetic_symtab): Define.
	* vms.c (vms_get_synthetic_symtab): Define.
binutils/
	* objdump.c (synthsyms, synthcount): New variables.
	(disassemble_data): Use dynsyms for stripped binaries or libraries.
	Add synthetized symbols.
	(dump_bfd): For disassemble, initialize dynsyms always and
	also synthsyms.  Free synthsyms and clear {sym,dynsym,synth}count
	before returning.
@
text
@d1575 2
a1576 1
      && (section->flags & SEC_CODE) == 0)
@


1.87
log
@	* objdump.c (struct SFILE): Replace current pointer with pos
	offset, rename size to alloc.
	(objdump_sprintf): Avoid unnecessary copies in the common case
	(disassemble_bytes): Keep sfile live throughout the
	function. Adjust usage appropriately.
@
text
@d3 1
a3 1
   2000, 2001, 2002, 2003
d156 4
d1782 1
d1790 4
a1793 2
  sorted_syms = xmalloc (symcount * sizeof (asymbol *));
  memcpy (sorted_syms, syms, symcount * sizeof (asymbol *));
d1795 7
a1801 1
  sorted_symcount = remove_useless_symbols (sorted_syms, symcount);
d2561 2
a2562 1
  if (dump_dynamic_symtab || dump_dynamic_reloc_info)
d2564 5
d2613 10
@


1.86
log
@	* objdump.c (disassemble_bytes): Subtract rel_offset from printed
	reloc address.
	(disassemble_section): Set rel_offset to section->vma instead of
	pinfo->buffer_vma.
@
text
@d1145 2
a1146 2
  size_t size;
  char *current;
a1153 1
  char *buf;
d1157 1
a1157 5
  va_start (args, format);

  vasprintf (&buf, format, args);

  if (buf == NULL)
d1159 4
a1163 4
      fatal (_("Out of virtual memory"));
    }

  n = strlen (buf);
d1165 5
a1169 8
  while ((size_t) ((f->buffer + f->size) - f->current) < n + 1)
    {
      size_t curroff;

      curroff = f->current - f->buffer;
      f->size *= 2;
      f->buffer = xrealloc (f->buffer, f->size);
      f->current = f->buffer + curroff;
d1171 2
a1172 8

  memcpy (f->current, buf, n);
  f->current += n;
  f->current[0] = '\0';

  free (buf);

  va_end (args);
d1232 1
d1237 4
a1304 1
	  SFILE sfile;
d1337 1
a1337 3
	      sfile.size = 120;
	      sfile.buffer = xmalloc (sfile.size);
	      sfile.current = sfile.buffer;
d1362 1
a1362 1
		  if (sfile.current != sfile.buffer)
a1363 1
		  free (sfile.buffer);
d1437 2
a1438 5
	  else
	    {
	      printf ("%s", sfile.buffer);
	      free (sfile.buffer);
	    }
d1545 2
@


1.85
log
@	* ChangeLog-9197: Fix comment typos.
	* coffgrok.c: Likewise.
	* filemode.c: Likewise.
	* objcopy.c: Likewise.
	* objdump.c: Likewise.
	* prdbg.c: Likewise.
	* stabs.c: Likewise.
	* unwind-ia64.c: Likewise.
@
text
@d1518 2
a1519 1
	      objdump_print_value (section->vma + q->address, info, TRUE);
d1604 1
a1604 1
      rel_offset = pinfo->buffer_vma;
@


1.84
log
@	* objdump.c: Wrap long lines, init vars separately from decl.
	(disassemble_section): Reset require_sec after call to
	find_symbol_for_address.
@
text
@d44 1
a44 1
      a disassmebly has been requested.
@


1.83
log
@Add new field to disassemble_info structure: symbol_is_valid() and use it to
skip displaying arm elf mapping symbols in disassembly output.
@
text
@d78 2
a79 1
/* The following variables are set based on arguments passed on command line.  */
d120 2
a121 1
/* Extra info to pass to the section disassembler and address printing function.  */
d605 1
a605 2
  struct objdump_disasm_info *aux
    = (struct objdump_disasm_info *) info->application_data;
d607 1
d655 3
a657 1
find_symbol_for_address (bfd_vma vma, struct disassemble_info *info, long *place)
d668 4
a671 4
  struct objdump_disasm_info * aux = (struct objdump_disasm_info *) info->application_data;
  bfd * abfd = aux->abfd;
  asection * sec = aux->sec;
  unsigned int opb = bfd_octets_per_byte (abfd);
d676 5
d838 2
a839 1
objdump_print_addr (bfd_vma vma, struct disassemble_info *info,
d842 1
a842 1
  struct objdump_disasm_info * aux = (struct objdump_disasm_info *) info->application_data;
d852 1
d1566 1
a1566 1
  struct objdump_disasm_info * paux = (struct objdump_disasm_info *) pinfo->application_data;
d1595 1
a1642 1
  paux->require_sec = TRUE;
d1675 1
d1677 1
d1877 3
a1879 1
	  aux.dynrelcount = bfd_canonicalize_dynamic_reloc (abfd, aux.dynrelbuf, dynsyms);
d1884 2
a1885 1
	  qsort (aux.dynrelbuf, aux.dynrelcount, sizeof (arelent *), compare_relocs);
d1950 3
a1952 1
print_section_stabs (bfd *abfd, const char *stabsect_name, unsigned *string_offset_ptr)
d2425 3
a2427 1
dump_relocs_in_section (bfd *abfd, asection *section, void *dummy ATTRIBUTE_UNUSED)
d2526 3
a2528 1
adjust_addresses (bfd *abfd ATTRIBUTE_UNUSED, asection *section, void *dummy ATTRIBUTE_UNUSED)
@


1.82
log
@	* objdump.c: Revert rev 1.81 commit.
@
text
@d646 5
a650 4
/* Locate a symbol given a bfd, a section, and a VMA.  If REQUIRE_SEC
   is TRUE, then always require the symbol to be in the section.  This
   returns NULL if there is no suitable symbol.  If PLACE is not NULL,
   then *PLACE is set to the index of the symbol in sorted_syms.  */
d653 1
a653 2
find_symbol_for_address (bfd *abfd, asection *sec, bfd_vma vma,
			 bfd_boolean require_sec, long *place)
d664 3
d710 1
a710 1
      && (require_sec
d755 1
a755 1
	  && (require_sec
d760 11
a770 4
	{
	  /* There is no suitable symbol.  */
	  return NULL;
	}
d832 1
a832 1
  struct objdump_disasm_info *aux;
d842 1
a842 3
  aux = (struct objdump_disasm_info *) info->application_data;
  sym = find_symbol_for_address (aux->abfd, aux->sec, vma, aux->require_sec,
				 NULL);
a860 1
  struct objdump_disasm_info * aux;
d863 1
a863 7
  /* No symbols - do not bother checking.  */
  if (sorted_symcount < 1)
    return 0;

  aux = (struct objdump_disasm_info *) info->application_data;
  sym = find_symbol_for_address (aux->abfd, aux->sec, vma, aux->require_sec,
				 NULL);
d1631 1
d1664 1
a1664 2
  sym = find_symbol_for_address (abfd, section, section->vma + addr_offset,
				 TRUE, &place);
d1672 1
d1677 3
a1679 2
      if (sym != NULL
	  && bfd_asymbol_value (sym) <= section->vma + addr_offset)
d1685 1
a1685 2
		&& (bfd_asymbol_value (sorted_syms[x])
		    <= section->vma + addr_offset));
d1689 1
a1689 1
	  pinfo->symbols = & sorted_syms[place];
d1693 4
a1696 1
	pinfo->symbols = NULL;
d1701 1
a1701 2
	  objdump_print_addr_with_sym (abfd, section, sym,
				       section->vma + addr_offset,
d1706 1
a1706 2
      if (sym != NULL
	  && bfd_asymbol_value (sym) > section->vma + addr_offset)
d1712 5
d1722 1
a1722 3
		 && (sorted_syms[place]->section != section
		     || (bfd_asymbol_value (sorted_syms[place])
			 <= bfd_asymbol_value (sym))))
d1724 1
d1731 2
a1732 7
      if (sym != NULL
	  && bfd_asymbol_value (sym) > section->vma + addr_offset)
	{
	  nextstop_offset = bfd_asymbol_value (sym) - section->vma;
	  if (nextstop_offset > stop_offset)
	    nextstop_offset = stop_offset;
	}
d1736 4
a1739 5
	{
	  nextstop_offset = bfd_asymbol_value (nextsym) - section->vma;
	  if (nextstop_offset > stop_offset)
	    nextstop_offset = stop_offset;
	}
d1746 1
a1746 1
	  || bfd_asymbol_value (sym) > section->vma + addr_offset
d1793 1
a1793 1
  init_disassemble_info (&disasm_info, stdout, fprintf);
d1848 3
@


1.81
log
@Remove "member" from verbose output of "-dv" in order to conform to POSIX
specification.
@
text
@d646 4
a649 5
/* Locate a symbol given a bfd and a section (from INFO->application_data),
   and a VMA.  If INFO->application_data->require_sec is TRUE, then always
   require the symbol to be in the section.  Returns NULL if there is no
   suitable symbol.  If PLACE is not NULL, then *PLACE is set to the index
   of the symbol in sorted_syms.  */
d652 2
a653 1
find_symbol_for_address (bfd_vma vma, struct disassemble_info *info, long *place)
a663 3
  struct objdump_disasm_info * aux = (struct objdump_disasm_info *) info->application_data;
  bfd * abfd = aux->abfd;
  asection * sec = aux->sec;
d707 1
a707 1
      && (aux->require_sec
d752 1
a752 1
	  && (aux->require_sec
d757 4
a760 11
	/* There is no suitable symbol.  */
	return NULL;
    }

  /* Give the target a chance to reject the symbol.  */
  while (! info->symbol_is_valid (sorted_syms [thisplace], info))
    {
      ++ thisplace;
      if (thisplace >= sorted_symcount
	  || bfd_asymbol_value (sorted_syms [thisplace]) > vma)
	return NULL;
d822 1
a822 1
  struct objdump_disasm_info * aux = (struct objdump_disasm_info *) info->application_data;
d832 3
a834 1
  sym = find_symbol_for_address (vma, info, NULL);
d853 1
d856 7
a862 1
  sym = find_symbol_for_address (vma, info, NULL);
a1629 1
  paux->require_sec = TRUE;
d1662 2
a1663 1
  sym = find_symbol_for_address (section->vma + addr_offset, info, &place);
a1670 1
      bfd_vma addr;
d1675 2
a1676 3
      addr = section->vma + addr_offset;

      if (sym != NULL && bfd_asymbol_value (sym) <= addr)
d1682 2
a1683 1
		&& (bfd_asymbol_value (sorted_syms[x]) <= addr));
d1687 1
a1687 1
	  pinfo->symbols = sorted_syms + place;
d1691 1
a1691 4
	{
	  pinfo->symbols = NULL;
	  pinfo->num_symbols = 0;
	}
d1696 2
a1697 1
	  objdump_print_addr_with_sym (abfd, section, sym, addr,
d1702 2
a1703 1
      if (sym != NULL && bfd_asymbol_value (sym) > addr)
a1708 5
#define is_valid_next_sym(SYM) \
  ((SYM)->section == section \
   && (bfd_asymbol_value (SYM) > bfd_asymbol_value (sym)) \
   && pinfo->symbol_is_valid (SYM, pinfo))
	    
d1714 3
a1716 1
		 && ! is_valid_next_sym (sorted_syms [place]))
a1717 1

d1724 7
a1730 2
      if (sym != NULL && bfd_asymbol_value (sym) > addr)
	nextstop_offset = bfd_asymbol_value (sym) - section->vma;
d1734 5
a1738 4
	nextstop_offset = bfd_asymbol_value (nextsym) - section->vma;

      if (nextstop_offset > stop_offset)
	nextstop_offset = stop_offset;
d1745 1
a1745 1
	  || bfd_asymbol_value (sym) > addr
d1792 1
a1792 1
  init_disassemble_info (&disasm_info, stdout, (fprintf_ftype) fprintf);
a1846 3

  /* Allow the target to customize the info structure.  */
  disassemble_init_for_target (abfd, & disasm_info);
@


1.80
log
@Use consistent error messages for missing files.
Detect directories where an ordinary file is expected.
@
text
@d646 5
a650 4
/* Locate a symbol given a bfd, a section, and a VMA.  If REQUIRE_SEC
   is TRUE, then always require the symbol to be in the section.  This
   returns NULL if there is no suitable symbol.  If PLACE is not NULL,
   then *PLACE is set to the index of the symbol in sorted_syms.  */
d653 1
a653 2
find_symbol_for_address (bfd *abfd, asection *sec, bfd_vma vma,
			 bfd_boolean require_sec, long *place)
d664 3
d710 1
a710 1
      && (require_sec
d755 1
a755 1
	  && (require_sec
d760 11
a770 4
	{
	  /* There is no suitable symbol.  */
	  return NULL;
	}
d832 1
a832 1
  struct objdump_disasm_info *aux;
d842 1
a842 3
  aux = (struct objdump_disasm_info *) info->application_data;
  sym = find_symbol_for_address (aux->abfd, aux->sec, vma, aux->require_sec,
				 NULL);
a860 1
  struct objdump_disasm_info * aux;
d863 1
a863 7
  /* No symbols - do not bother checking.  */
  if (sorted_symcount < 1)
    return 0;

  aux = (struct objdump_disasm_info *) info->application_data;
  sym = find_symbol_for_address (aux->abfd, aux->sec, vma, aux->require_sec,
				 NULL);
d1631 1
d1664 1
a1664 2
  sym = find_symbol_for_address (abfd, section, section->vma + addr_offset,
				 TRUE, &place);
d1672 1
d1677 3
a1679 2
      if (sym != NULL
	  && bfd_asymbol_value (sym) <= section->vma + addr_offset)
d1685 1
a1685 2
		&& (bfd_asymbol_value (sorted_syms[x])
		    <= section->vma + addr_offset));
d1689 1
a1689 1
	  pinfo->symbols = & sorted_syms[place];
d1693 4
a1696 1
	pinfo->symbols = NULL;
d1701 1
a1701 2
	  objdump_print_addr_with_sym (abfd, section, sym,
				       section->vma + addr_offset,
d1706 1
a1706 2
      if (sym != NULL
	  && bfd_asymbol_value (sym) > section->vma + addr_offset)
d1712 5
d1722 1
a1722 3
		 && (sorted_syms[place]->section != section
		     || (bfd_asymbol_value (sorted_syms[place])
			 <= bfd_asymbol_value (sym))))
d1724 1
d1731 2
a1732 7
      if (sym != NULL
	  && bfd_asymbol_value (sym) > section->vma + addr_offset)
	{
	  nextstop_offset = bfd_asymbol_value (sym) - section->vma;
	  if (nextstop_offset > stop_offset)
	    nextstop_offset = stop_offset;
	}
d1736 4
a1739 5
	{
	  nextstop_offset = bfd_asymbol_value (nextsym) - section->vma;
	  if (nextstop_offset > stop_offset)
	    nextstop_offset = stop_offset;
	}
d1746 1
a1746 1
	  || bfd_asymbol_value (sym) > section->vma + addr_offset
d1793 1
a1793 1
  init_disassemble_info (&disasm_info, stdout, fprintf);
d1848 3
@


1.79
log
@	* ChangeLog: Fix typos.
	* ChangeLog-9197: Likewise.
	* ChangeLog-9899: Likewise.
	* NEWS: Likewise.
	* ar.c: Fix comment typos.
	* arsup.c: Likewise.
	* coffgrok.c: Likewise.
	* debug.c: Likewise.
	* debug.h: Likewise.
	* dlltool.c: Likewise.
	* ieee.c: Likewise.
	* nm.c: Likewise.
	* objdump.c: Likewise.
	* prdbg.c: Likewise.
	* readelf.c: Likewise.
	* resrc.c: Likewise.
	* sysinfo.y: Likewise.
	* windres.c: Likewise.
@
text
@d2626 5
a2630 1
  bfd *file, *arfile = NULL;
@


1.78
log
@bfd/Changelog:
	* libbfd-in.h (_bfd_link_section_stabs): Add string offset
	parameter.
	* cofflink.c (coff_link_add_symbols): Deal with split stab
	sections.
	* elflink.h (elf_link_add_object_symbols): Deal with split stab
	sections.
	* stabs.c (_bfd_link_section_stabs): Add string offset parameter.
	* libbfd.h: Regenerated.
ld/ChangeLog:
	* ldwrite.c (unsplittable_name): New.
	(clone_section): Strip existing numeric suffix. Only truncate names
	for coff targets.
	(split_sections): Use unsplittable_name.
binutils/ChangeLog:
	* objdump.c (read_section_stabs): Just read one section, return
	pointer to it. Add size parameter.
	(print_section_stabs): Add string offset parameter. Adjust.
	(struct stab_section_names): Add string offset member.
	(find_stabs_sections): Correct check for split section suffix,
	adjust read_section_stabs and print_section_stabs calls.
	(dump_stabs_section): Clear string_offset, free string table.
@
text
@d38 1
a38 1
   3. The file's target architecture and binary file format are determnined
d42 2
a43 2
   4. dump_bfd() in turn calls seperate functions to display the requested
      item(s) of infomation(s).  For example dissasemble_data() is called if
d47 1
a47 1
   by symbols, calling dissassemble_bytes() on each block.  The actual
d874 1
a874 1
   dissassembly with source, so that we know how much of the file to
d1002 1
a1002 1
/* Show the line number, or the source line, in a dissassembly
d1588 1
a1588 1
	 relative.  REL_OFFSET specifies the reloc address corresponnding
@


1.77
log
@Index: opcodes/ChangeLog
2003-09-03  Andrew Cagney  <cagney@@redhat.com>

	* dis-init.c (init_disassemble_info): New file and function.
	* Makefile.am (CFILES): Add "dis-init.c".
	(libopcodes_la_SOURCES): Add "dis-init.c".
	(dis-init.lo): Specify dependencies.
	* Makefile.in: Regenerate.

Index: include/ChangeLog
2003-08-27  Andrew Cagney  <cagney@@redhat.com>

	* dis-asm.h (init_disassemble_info): Declare.
	(INIT_DISASSEMBLE_INFO): Redefine as a call to
	init_disassemble_info.
	(INIT_DISASSEMBLE_INFO_NO_ARCH): Ditto.

Index: binutils/ChangeLog
2003-09-03  Andrew Cagney  <cagney@@redhat.com>

	* objdump.c: Refer to init_disassemble_info in comments.
	(disassemble_data): Replace INIT_DISASSEMBLE_INFO with
	init_disassemble_info.
@
text
@d1876 5
a1880 8
/* Read ABFD's stabs section STABSECT_NAME into `stabs'
   and string table section STRSECT_NAME into `strtab'.
   If the section exists and was read, allocate the space and return TRUE.
   Otherwise return FALSE.  */

static bfd_boolean
read_section_stabs (bfd *abfd, const char *stabsect_name,
		    const char *strsect_name)
d1882 3
a1884 1
  asection *stabsect, *stabstrsect;
d1886 1
a1886 1
  stabsect = bfd_get_section_by_name (abfd, stabsect_name);
d1889 1
a1889 10
      printf (_("No %s section present\n\n"), stabsect_name);
      return FALSE;
    }

  stabstrsect = bfd_get_section_by_name (abfd, strsect_name);
  if (stabstrsect == NULL)
    {
      non_fatal (_("%s has no %s section"),
		 bfd_get_filename (abfd), strsect_name);
      exit_status = 1;
d1893 2
a1894 2
  stab_size    = bfd_section_size (abfd, stabsect);
  stabstr_size = bfd_section_size (abfd, stabstrsect);
d1896 1
a1896 4
  stabs  = xmalloc (stab_size);
  strtab = xmalloc (stabstr_size);

  if (! bfd_get_section_contents (abfd, stabsect, stabs, 0, stab_size))
d1899 1
a1899 1
		 stabsect_name, bfd_get_filename (abfd),
d1901 1
a1901 2
      free (stabs);
      free (strtab);
d1903 1
a1903 1
      return FALSE;
d1906 1
a1906 11
  if (! bfd_get_section_contents (abfd, stabstrsect, (void *) strtab, 0,
				  stabstr_size))
    {
      non_fatal (_("Reading %s section of %s failed: %s\n"),
		 strsect_name, bfd_get_filename (abfd),
		 bfd_errmsg (bfd_get_error ()));
      free (stabs);
      free (strtab);
      exit_status = 1;
      return FALSE;
    }
d1908 1
a1908 1
  return TRUE;
d1930 1
a1930 1
print_section_stabs (bfd *abfd, const char *stabsect_name)
d1934 1
a1934 1
  unsigned next_file_string_table_offset = 0;
d1994 1
d2001 1
d2012 1
a2012 1
     handle .stab0, etc.  */
d2020 1
a2020 1
	  || ISDIGIT (section->name[len])))
d2022 5
a2026 1
      if (read_section_stabs (abfd, section->name, sought->string_section_name))
d2028 3
a2030 3
	  print_section_stabs (abfd, section->name);
	  free (stabs);
	  free (strtab);
d2042 2
a2043 1
  
d2045 3
@


1.76
log
@Use bfd_map_over_sections to walk section chain.
Do not dump the contents of an empty section.
@
text
@d69 1
a69 1
/* This is needed by INIT_DISASSEMBLE_INFO.  */
d1792 1
a1792 1
  INIT_DISASSEMBLE_INFO (disasm_info, stdout, fprintf);
@


1.75
log
@	* objcopy.c: Remove unnecessary prototypes and casts.
	* objdump.c: Remove unnecessary casts.
	* readelf.c: Convert to C90.  Remove unnecessary prototypes and casts.
	(get_osabi_name): Move so we don't need a forward declaration.
@
text
@d22 29
d78 1
a98 3
static char **only;			/* -j secname */
static size_t only_size = 0;
static size_t only_used = 0;
d107 8
d119 1
a119 1
/* Extra info to pass to the disassembler address printing function.  */
d122 6
a127 3
  bfd *abfd;
  asection *sec;
  bfd_boolean require_sec;
a161 9

/* Forward declarations.  */

static void dump_data (bfd *);
static void dump_relocs (bfd *);
static void dump_dynamic_relocs (bfd *);
static void dump_reloc_set (bfd *, asection *, arelent **, long);
static void dump_symbols (bfd *, bfd_boolean);
static void dump_section_stabs (bfd *, char *, char *);
d594 2
a595 1
/* Print VMA to STREAM.  If SKIP_ZEROES is TRUE, omit leading zeroes.  */
d769 1
a769 1
/* Print an address to INFO symbolically.  */
d815 2
a816 2
/* Print VMA to INFO, symbolically if possible.  If SKIP_ZEROES is
   TRUE, don't output leading zeroes.  */
d1178 18
d1550 220
a1774 2
  unsigned long addr_offset;
  disassembler_ftype disassemble_fn;
a1776 5
  asection *section;
  unsigned int opb;
  arelent **dynrelbuf = NULL;
  long relcount = 0;
  bfd_vma rel_offset;
d1797 3
d1823 3
a1825 2
  disassemble_fn = disassembler (abfd);
  if (!disassemble_fn)
a1832 2
  opb = bfd_octets_per_byte (abfd);

d1837 1
a1837 1
  disasm_info.octets_per_byte = opb;
d1848 2
d1853 1
a1853 1

d1859 3
a1861 3
	  dynrelbuf = xmalloc (relsize);
	  relcount = bfd_canonicalize_dynamic_reloc (abfd, dynrelbuf, dynsyms);
	  if (relcount < 0)
d1865 1
a1865 1
	  qsort (dynrelbuf, relcount, sizeof (arelent *), compare_relocs);
d1869 1
a1869 67
  for (section = abfd->sections;
       section != NULL;
       section = section->next)
    {
      bfd_byte *data = NULL;
      bfd_size_type datasize = 0;
      arelent **relbuf = NULL;
      arelent **relpp = NULL;
      arelent **relppend = NULL;
      unsigned long stop_offset;
      asymbol *sym = NULL;
      long place = 0;

      /* Sections that do not contain machine code are not normally
	 disassembled.  */
      if (! disassemble_all
	  && only == NULL
	  && (section->flags & SEC_CODE) == 0)
	continue;

      if (only != NULL)
	{
	  size_t i;

	  for (i = 0; i < only_used; i++)
	    if (strcmp (only [i], section->name) == 0)
	      break;

	  if (i == only_used)
	    continue;
	}

      if (dynrelbuf == NULL)
	relcount = 0;
      if ((section->flags & SEC_RELOC) != 0
#ifndef DISASSEMBLER_NEEDS_RELOCS
	  && dump_reloc_info
#endif
	  && dynrelbuf == NULL)
	{
	  long relsize;

	  relsize = bfd_get_reloc_upper_bound (abfd, section);
	  if (relsize < 0)
	    bfd_fatal (bfd_get_filename (abfd));

	  if (relsize > 0)
	    {
	      relbuf = xmalloc (relsize);
	      relcount = bfd_canonicalize_reloc (abfd, section, relbuf, syms);
	      if (relcount < 0)
		bfd_fatal (bfd_get_filename (abfd));

	      /* Sort the relocs by address.  */
	      qsort (relbuf, relcount, sizeof (arelent *), compare_relocs);
	    }
	}

      datasize = bfd_get_section_size_before_reloc (section);
      if (datasize == 0)
	continue;

      printf (_("Disassembly of section %s:\n"), section->name);

      data = xmalloc (datasize);

      bfd_get_section_contents (abfd, section, data, 0, datasize);
d1871 2
a1872 152
      aux.sec = section;
      disasm_info.buffer = data;
      disasm_info.buffer_vma = section->vma;
      disasm_info.buffer_length = datasize;
      disasm_info.section = section;

      if (start_address == (bfd_vma) -1
	  || start_address < disasm_info.buffer_vma)
	addr_offset = 0;
      else
	addr_offset = start_address - disasm_info.buffer_vma;

      if (dynrelbuf)
	{
	  relpp = dynrelbuf;
	  /* Dynamic reloc addresses are absolute, non-dynamic are
	     section relative.  REL_OFFSET specifies the reloc address
	     corresponnding to the start of this section.  */
	  rel_offset = disasm_info.buffer_vma;
	}
      else
	{
	  relpp = relbuf;
	  rel_offset = 0;
	}
      relppend = relpp + relcount;

      /* Skip over the relocs belonging to addresses below the
	 start address.  */
      while (relpp < relppend
	     && (*relpp)->address < rel_offset + addr_offset)
	++relpp;

      if (stop_address == (bfd_vma) -1)
	stop_offset = datasize / opb;
      else
	{
	  if (stop_address < disasm_info.buffer_vma)
	    stop_offset = 0;
	  else
	    stop_offset = stop_address - disasm_info.buffer_vma;
	  if (stop_offset > disasm_info.buffer_length / opb)
	    stop_offset = disasm_info.buffer_length / opb;
	}

      sym = find_symbol_for_address (abfd, section, section->vma + addr_offset,
				     TRUE, &place);

      while (addr_offset < stop_offset)
	{
	  asymbol *nextsym;
	  unsigned long nextstop_offset;
	  bfd_boolean insns;

	  if (sym != NULL
	      && bfd_asymbol_value (sym) <= section->vma + addr_offset)
	    {
	      int x;

	      for (x = place;
		   (x < sorted_symcount
		    && (bfd_asymbol_value (sorted_syms[x])
			<= section->vma + addr_offset));
		   ++x)
		continue;

	      disasm_info.symbols = & sorted_syms[place];
	      disasm_info.num_symbols = x - place;
	    }
	  else
	    disasm_info.symbols = NULL;

	  if (! prefix_addresses)
	    {
	      (* disasm_info.fprintf_func) (disasm_info.stream, "\n");
	      objdump_print_addr_with_sym (abfd, section, sym,
					   section->vma + addr_offset,
					   &disasm_info,
					   FALSE);
	      (* disasm_info.fprintf_func) (disasm_info.stream, ":\n");
	    }

	  if (sym != NULL
	      && bfd_asymbol_value (sym) > section->vma + addr_offset)
	    nextsym = sym;
	  else if (sym == NULL)
	    nextsym = NULL;
	  else
	    {
	      /* Search forward for the next appropriate symbol in
		 SECTION.  Note that all the symbols are sorted
		 together into one big array, and that some sections
		 may have overlapping addresses.  */
	      while (place < sorted_symcount
		     && (sorted_syms[place]->section != section
			 || (bfd_asymbol_value (sorted_syms[place])
			     <= bfd_asymbol_value (sym))))
		++place;
	      if (place >= sorted_symcount)
		nextsym = NULL;
	      else
		nextsym = sorted_syms[place];
	    }

	  if (sym != NULL
	      && bfd_asymbol_value (sym) > section->vma + addr_offset)
	    {
	      nextstop_offset = bfd_asymbol_value (sym) - section->vma;
	      if (nextstop_offset > stop_offset)
		nextstop_offset = stop_offset;
	    }
	  else if (nextsym == NULL)
	    nextstop_offset = stop_offset;
	  else
	    {
	      nextstop_offset = bfd_asymbol_value (nextsym) - section->vma;
	      if (nextstop_offset > stop_offset)
		nextstop_offset = stop_offset;
	    }

	  /* If a symbol is explicitly marked as being an object
	     rather than a function, just dump the bytes without
	     disassembling them.  */
	  if (disassemble_all
	      || sym == NULL
	      || bfd_asymbol_value (sym) > section->vma + addr_offset
	      || ((sym->flags & BSF_OBJECT) == 0
		  && (strstr (bfd_asymbol_name (sym), "gnu_compiled")
		      == NULL)
		  && (strstr (bfd_asymbol_name (sym), "gcc2_compiled")
		      == NULL))
	      || (sym->flags & BSF_FUNCTION) != 0)
	    insns = TRUE;
	  else
	    insns = FALSE;

	  disassemble_bytes (&disasm_info, disassemble_fn, insns, data,
			     addr_offset, nextstop_offset,
			     rel_offset, &relpp, relppend);

	  addr_offset = nextstop_offset;
	  sym = nextsym;
	}

      free (data);

      if (relbuf != NULL)
	free (relbuf);
    }

  if (dynrelbuf != NULL)
    free (dynrelbuf);
a1875 12
/* Dump the stabs sections from an object file that has a section that
   uses Sun stabs encoding.  */

static void
dump_stabs (bfd *abfd)
{
  dump_section_stabs (abfd, ".stab", ".stabstr");
  dump_section_stabs (abfd, ".stab.excl", ".stab.exclstr");
  dump_section_stabs (abfd, ".stab.index", ".stab.indexstr");
  dump_section_stabs (abfd, "$GDB_SYMBOLS$", "$GDB_STRINGS$");
}

d1888 1
a1888 1
  if (0 == stabsect)
d1895 1
a1895 1
  if (0 == stabstrsect)
d1954 1
a1954 2
print_section_stabs (bfd *abfd, const char *stabsect_name,
		     const char *strsect_name ATTRIBUTE_UNUSED)
d2020 7
d2028 1
a2028 1
dump_section_stabs (bfd *abfd, char *stabsect_name, char *strsect_name)
d2030 2
a2031 1
  asection *s;
d2035 10
a2044 14
  for (s = abfd->sections;
       s != NULL;
       s = s->next)
    {
      int len;

      len = strlen (stabsect_name);

      /* If the prefix matches, and the files section name ends with a
	 nul or a digit, then we match.  I.e., we want either an exact
	 match or a section followed by a number.  */
      if (strncmp (stabsect_name, s->name, len) == 0
	  && (s->name[len] == '\000'
	      || ISDIGIT (s->name[len])))
d2046 3
a2048 6
	  if (read_section_stabs (abfd, s->name, strsect_name))
	    {
	      print_section_stabs (abfd, s->name, strsect_name);
	      free (stabs);
	      free (strtab);
	    }
d2053 21
d2109 3
a2111 1
/* Dump selected contents of ABFD.  */
d2114 1
a2114 1
dump_bfd (bfd *abfd)
d2116 37
a2152 4
  /* If we are adjusting section VMA's, change them all now.  Changing
     the BFD information is a hack.  However, we must do it, or
     bfd_find_nearest_line will not do the right thing.  */
  if (adjust_section_vma != 0)
d2154 62
a2215 1
      asection *s;
d2217 3
a2219 1
      for (s = abfd->sections; s != NULL; s = s->next)
d2221 4
a2224 2
	  s->vma += adjust_section_vma;
	  s->lma += adjust_section_vma;
d2226 1
d2228 4
d2233 5
a2237 272
  if (! dump_debugging_tags)
    printf (_("\n%s:     file format %s\n"), bfd_get_filename (abfd),
	    abfd->xvec->name);
  if (dump_ar_hdrs)
    print_arelt_descr (stdout, abfd, TRUE);
  if (dump_file_header)
    dump_bfd_header (abfd);
  if (dump_private_headers)
    dump_bfd_private_header (abfd);
  if (! dump_debugging_tags)
    putchar ('\n');
  if (dump_section_headers)
    dump_headers (abfd);

  if (dump_symtab || dump_reloc_info || disassemble || dump_debugging)
    syms = slurp_symtab (abfd);
  if (dump_dynamic_symtab || dump_dynamic_reloc_info)
    dynsyms = slurp_dynamic_symtab (abfd);

  if (dump_symtab)
    dump_symbols (abfd, FALSE);
  if (dump_dynamic_symtab)
    dump_symbols (abfd, TRUE);
  if (dump_stab_section_info)
    dump_stabs (abfd);
  if (dump_reloc_info && ! disassemble)
    dump_relocs (abfd);
  if (dump_dynamic_reloc_info && ! disassemble)
    dump_dynamic_relocs (abfd);
  if (dump_section_contents)
    dump_data (abfd);
  if (disassemble)
    disassemble_data (abfd);
  if (dump_debugging)
    {
      void *dhandle;

      dhandle = read_debugging_info (abfd, syms, symcount);
      if (dhandle != NULL)
	{
	  if (! print_debugging_info (stdout, dhandle, abfd, syms, demangle,
	      dump_debugging_tags ? TRUE : FALSE))
	    {
	      non_fatal (_("%s: printing debugging information failed"),
			 bfd_get_filename (abfd));
	      exit_status = 1;
	    }
	}
    }

  if (syms)
    {
      free (syms);
      syms = NULL;
    }

  if (dynsyms)
    {
      free (dynsyms);
      dynsyms = NULL;
    }
}

static void
display_bfd (bfd *abfd)
{
  char **matching;

  if (bfd_check_format_matches (abfd, bfd_object, &matching))
    {
      dump_bfd (abfd);
      return;
    }

  if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
    {
      nonfatal (bfd_get_filename (abfd));
      list_matching_formats (matching);
      free (matching);
      return;
    }

  if (bfd_get_error () != bfd_error_file_not_recognized)
    {
      nonfatal (bfd_get_filename (abfd));
      return;
    }

  if (bfd_check_format_matches (abfd, bfd_core, &matching))
    {
      dump_bfd (abfd);
      return;
    }

  nonfatal (bfd_get_filename (abfd));

  if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
    {
      list_matching_formats (matching);
      free (matching);
    }
}

static void
display_file (char *filename, char *target)
{
  bfd *file, *arfile = NULL;

  file = bfd_openr (filename, target);
  if (file == NULL)
    {
      nonfatal (filename);
      return;
    }

  if (bfd_check_format (file, bfd_archive))
    {
      bfd *last_arfile = NULL;

      printf (_("In archive %s:\n"), bfd_get_filename (file));
      for (;;)
	{
	  bfd_set_error (bfd_error_no_error);

	  arfile = bfd_openr_next_archived_file (file, arfile);
	  if (arfile == NULL)
	    {
	      if (bfd_get_error () != bfd_error_no_more_archived_files)
		nonfatal (bfd_get_filename (file));
	      break;
	    }

	  display_bfd (arfile);

	  if (last_arfile != NULL)
	    bfd_close (last_arfile);
	  last_arfile = arfile;
	}

      if (last_arfile != NULL)
	bfd_close (last_arfile);
    }
  else
    display_bfd (file);

  bfd_close (file);
}

/* Actually display the various requested regions.  */

static void
dump_data (bfd *abfd)
{
  asection *section;
  bfd_byte *data = 0;
  bfd_size_type datasize = 0;
  bfd_size_type addr_offset;
  bfd_size_type start_offset, stop_offset;
  unsigned int opb = bfd_octets_per_byte (abfd);

  for (section = abfd->sections; section != NULL; section =
       section->next)
    {
      int onaline = 16;
      size_t i;

      for (i = 0; i < only_used; i++)
	if (strcmp (only [i], section->name) == 0)
	  break;

      if (only_used == 0 || i != only_used)
	{
	  if (section->flags & SEC_HAS_CONTENTS)
	    {
	      char buf[64];
	      int count, width;

	      printf (_("Contents of section %s:\n"), section->name);

	      if (bfd_section_size (abfd, section) == 0)
		continue;
	      data = xmalloc (bfd_section_size (abfd, section));
	      datasize = bfd_section_size (abfd, section);


	      bfd_get_section_contents (abfd, section, data, 0,
					bfd_section_size (abfd, section));

	      if (start_address == (bfd_vma) -1
		  || start_address < section->vma)
		start_offset = 0;
	      else
		start_offset = start_address - section->vma;
	      if (stop_address == (bfd_vma) -1)
		stop_offset = bfd_section_size (abfd, section) / opb;
	      else
		{
		  if (stop_address < section->vma)
		    stop_offset = 0;
		  else
		    stop_offset = stop_address - section->vma;
		  if (stop_offset > bfd_section_size (abfd, section) / opb)
		    stop_offset = bfd_section_size (abfd, section) / opb;
		}

	      width = 4;

	      bfd_sprintf_vma (abfd, buf, start_offset + section->vma);
	      if (strlen (buf) >= sizeof (buf))
		abort ();
	      count = 0;
	      while (buf[count] == '0' && buf[count+1] != '\0')
		count++;
	      count = strlen (buf) - count;
	      if (count > width)
		width = count;

	      bfd_sprintf_vma (abfd, buf, stop_offset + section->vma - 1);
	      if (strlen (buf) >= sizeof (buf))
		abort ();
	      count = 0;
	      while (buf[count] == '0' && buf[count+1] != '\0')
		count++;
	      count = strlen (buf) - count;
	      if (count > width)
		width = count;

	      for (addr_offset = start_offset;
		   addr_offset < stop_offset; addr_offset += onaline / opb)
		{
		  bfd_size_type j;

		  bfd_sprintf_vma (abfd, buf, (addr_offset + section->vma));
		  count = strlen (buf);
		  if ((size_t) count >= sizeof (buf))
		    abort ();
		  putchar (' ');
		  while (count < width)
		    {
		      putchar ('0');
		      count++;
		    }
		  fputs (buf + count - width, stdout);
		  putchar (' ');

		  for (j = addr_offset * opb;
		       j < addr_offset * opb + onaline; j++)
		    {
		      if (j < stop_offset * opb)
			printf ("%02x", (unsigned) (data[j]));
		      else
			printf ("  ");
		      if ((j & 3) == 3)
			printf (" ");
		    }

		  printf (" ");
		  for (j = addr_offset * opb;
		       j < addr_offset * opb + onaline; j++)
		    {
		      if (j >= stop_offset * opb)
			printf (" ");
		      else
			printf ("%c", ISPRINT (data[j]) ? data[j] : '.');
		    }
		  putchar ('\n');
		}
	      free (data);
	    }
	}
    }
}
d2266 10
a2275 1
      if (*current)
d2277 1
a2277 1
	  bfd *cur_bfd = bfd_asymbol_bfd (*current);
d2279 1
a2279 1
	  if (cur_bfd != NULL)
a2280 1
	      const char *name;
d2283 5
a2287 11
	      name = (*current)->name;
	      alloc = NULL;
	      if (do_demangle && name != NULL && *name != '\0')
		{
		  /* If we want to demangle the name, we demangle it
		     here, and temporarily clobber it while calling
		     bfd_print_symbol.  FIXME: This is a gross hack.  */
		  alloc = demangle (cur_bfd, name);
		  (*current)->name = alloc;
		}

a2289 1

d2291 1
a2291 4
	      if (alloc != NULL)
		free (alloc);

	      printf ("\n");
a2292 58
	}
      current++;
    }
  printf ("\n");
  printf ("\n");
}

static void
dump_relocs (bfd *abfd)
{
  arelent **relpp;
  long relcount;
  asection *a;

  for (a = abfd->sections; a != NULL; a = a->next)
    {
      long relsize;

      if (bfd_is_abs_section (a))
	continue;
      if (bfd_is_und_section (a))
	continue;
      if (bfd_is_com_section (a))
	continue;

      if (only)
	{
	  size_t i;

	  for (i = 0; i < only_used; i++)
	    if (strcmp (only [i], a->name) == 0)
	      break;

	  if (i == only_used)
	    continue;
	}
      else if ((a->flags & SEC_RELOC) == 0)
	continue;

      relsize = bfd_get_reloc_upper_bound (abfd, a);
      if (relsize < 0)
	bfd_fatal (bfd_get_filename (abfd));

      printf ("RELOCATION RECORDS FOR [%s]:", a->name);

      if (relsize == 0)
	{
	  printf (" (none)\n\n");
	}
      else
	{
	  relpp = xmalloc (relsize);
	  relcount = bfd_canonicalize_reloc (abfd, a, relpp, syms);

	  if (relcount < 0)
	    bfd_fatal (bfd_get_filename (abfd));
	  else if (relcount == 0)
	    printf (" (none)\n\n");
d2294 2
a2295 6
	    {
	      printf ("\n");
	      dump_reloc_set (abfd, a, relpp, relcount);
	      printf ("\n\n");
	    }
	  free (relpp);
a2296 2
    }
}
d2298 2
a2299 31
static void
dump_dynamic_relocs (bfd *abfd)
{
  long relsize;
  arelent **relpp;
  long relcount;

  relsize = bfd_get_dynamic_reloc_upper_bound (abfd);
  if (relsize < 0)
    bfd_fatal (bfd_get_filename (abfd));

  printf ("DYNAMIC RELOCATION RECORDS");

  if (relsize == 0)
    printf (" (none)\n\n");
  else
    {
      relpp = xmalloc (relsize);
      relcount = bfd_canonicalize_dynamic_reloc (abfd, relpp, dynsyms);

      if (relcount < 0)
	bfd_fatal (bfd_get_filename (abfd));
      else if (relcount == 0)
	printf (" (none)\n\n");
      else
	{
	  printf ("\n");
	  dump_reloc_set (abfd, NULL, relpp, relcount);
	  printf ("\n\n");
	}
      free (relpp);
d2301 1
d2303 1
a2303 1

d2318 1
d2416 82
d2514 168
d2690 2
a2691 1
#if defined (HAVE_SETLOCALE) && defined (HAVE_LC_MESSAGES)
a2693 1
#if defined (HAVE_SETLOCALE)
d2696 1
@


1.74
log
@	* objdump.c (include_paths, include_path_count): New vars.
	(usage): Describe --include.
	(long_options): Add "include".
	(add_include_path): New function.
	(struct print_file_list): Make filename const.  Add modname.
	(try_print_file_open, update_source_path): New functions.
	(show_line): Use them.
	(main): Handle 'I' option.  Don't check for NULL xrealloc arg.
@
text
@d93 1
a93 1
static char *machine = (char *) NULL;
d96 1
a96 1
static char *disassembler_options = (char *) NULL;
d357 1
a357 1
  asymbol **sy = (asymbol **) NULL;
d370 1
a370 1
    sy = (asymbol **) xmalloc (storage);
d383 1
a383 1
  asymbol **sy = (asymbol **) NULL;
d399 1
a399 1
    sy = (asymbol **) xmalloc (storage);
d804 1
a804 1
				 (long *) NULL);
d832 1
a832 1
				 (long *) NULL);
d1523 1
a1523 1
  sorted_syms = (asymbol **) xmalloc (symcount * sizeof (asymbol *));
d1539 1
a1539 1
  if (machine != (char *) NULL)
d1553 1
a1553 1
      xvec = (struct bfd_target *) xmalloc (sizeof (struct bfd_target));
d1594 1
a1594 1
	  dynrelbuf = (arelent **) xmalloc (relsize);
d1605 1
a1605 1
       section != (asection *) NULL;
d1652 1
a1652 1
	      relbuf = (arelent **) xmalloc (relsize);
d1668 1
a1668 1
      data = (bfd_byte *) xmalloc ((size_t) datasize);
d1869 2
a1870 2
  stabs  = (bfd_byte *) xmalloc (stab_size);
  strtab = (char *) xmalloc (stabstr_size);
d1872 1
a1872 1
  if (! bfd_get_section_contents (abfd, stabsect, (void *) stabs, 0, stab_size))
d2176 1
a2176 1
  bfd *file, *arfile = (bfd *) NULL;
d2251 1
a2251 2
	      data = (bfd_byte *) xmalloc ((size_t) bfd_section_size
					   (abfd, section));
d2255 1
a2255 1
	      bfd_get_section_contents (abfd, section, (void *) data, 0,
d2413 1
a2413 1
  for (a = abfd->sections; a != (asection *) NULL; a = a->next)
d2450 1
a2450 1
	  relpp = (arelent **) xmalloc (relsize);
d2485 1
a2485 1
      relpp = (arelent **) xmalloc (relsize);
d2495 1
a2495 1
	  dump_reloc_set (abfd, (asection *) NULL, relpp, relcount);
d2526 1
a2526 1
  for (p = relpp; relcount && *p != (arelent *) NULL; p++, relcount--)
d2591 1
a2591 2
	  objdump_print_symname (abfd, (struct disassemble_info *) NULL,
				 *q->sym_ptr_ptr);
d2595 1
a2595 1
	  if (section_name == (const char *) NULL)
@


1.73
log
@	* objdump.c: Remove unnecessary prototypes.
	(disassemble_bytes): Add rel_offset parameter.  Simplify reloc skipping
	code, and print relocs when dump_dynamic_reloc_info.
	(disassemble_data): Read and handle dynamic relocs.  Correct reloc
	skip code.  Formatting.
	(dump_bfd): Don't dump dynamic relocs when disassembling.
@
text
@d80 4
d172 1
d236 1
d850 2
a851 1
  char *filename;
d863 83
d1043 1
a1043 1
		  p->f = fopen (p->filename, "r");
d1066 1
a1066 1
	  FILE *f;
d1068 1
a1068 2
	  f = fopen (filename, "r");
	  if (f != NULL)
a1071 15
	      p = ((struct print_file_list *)
		   xmalloc (sizeof (struct print_file_list)));
	      p->filename = xmalloc (strlen (filename) + 1);
	      strcpy (p->filename, filename);
	      p->line = 0;
	      p->f = f;

	      if (print_files != NULL && print_files->f != NULL)
		{
		  fclose (print_files->f);
		  print_files->f = NULL;
		}
	      p->next = print_files;
	      print_files = p;

d1229 1
a1229 1
         print `...'.  */
d1243 3
a1245 3
             zeroes in multiples of 4, to try to avoid running over
             the start of an instruction which happens to start with
             zero.  */
d1297 1
a1297 1
                 in the last instruction, not the current one.  */
d1345 1
a1345 1
                 octets_per_line octets per line.  */
d1762 3
a1764 3
                 SECTION.  Note that all the symbols are sorted
                 together into one big array, and that some sections
                 may have overlapping addresses.  */
d2246 1
a2246 1
	      
d2385 2
a2386 2
                     here, and temporarily clobber it while calling
                     bfd_print_symbol.  FIXME: This is a gross hack.  */
d2614 17
d2656 1
a2656 1
  while ((c = getopt_long (argc, argv, "pib:m:M:VvCdDlfaHhrRtTxsSj:wE:zgeG",
d2676 1
a2676 6
	  if (only == NULL)
	    {
	      only_size = 8;
	      only = (char **) xmalloc (only_size * sizeof (char *));
	    }
	  else if (only_used == only_size)
d2679 1
a2679 2
	      only = (char **) xrealloc (only,
					 only_size * sizeof (char *));
d2745 3
@


1.72
log
@Update to Iso C.
@
text
@d41 1
a41 2
extern int fprintf
  (FILE *, const char *, ...);
d121 1
a121 1
/* Static declarations.  */
d123 6
a128 68
static void usage
  (FILE *, int);
static void nonfatal
  (const char *);
static void display_file
  (char *, char *);
static void dump_section_header
  (bfd *, asection *, void *);
static void dump_headers
  (bfd *);
static void dump_data
  (bfd *);
static void dump_relocs
  (bfd *);
static void dump_dynamic_relocs
  (bfd *);
static void dump_reloc_set
  (bfd *, asection *, arelent **, long);
static void dump_symbols
  (bfd *, bfd_boolean);
static void dump_bfd_header
  (bfd *);
static void dump_bfd_private_header
  (bfd *);
static void dump_bfd
  (bfd *);
static void display_bfd
  (bfd *);
static void objdump_print_value
  (bfd_vma, struct disassemble_info *, bfd_boolean);
static void objdump_print_symname
  (bfd *, struct disassemble_info *, asymbol *);
static asymbol *find_symbol_for_address
  (bfd *, asection *, bfd_vma, bfd_boolean, long *);
static void objdump_print_addr_with_sym
  (bfd *, asection *, asymbol *, bfd_vma,
   struct disassemble_info *, bfd_boolean);
static void objdump_print_addr
  (bfd_vma, struct disassemble_info *, bfd_boolean);
static void objdump_print_address
  (bfd_vma, struct disassemble_info *);
static int objdump_symbol_at_address
  (bfd_vma, struct disassemble_info *);
static void show_line
  (bfd *, asection *, bfd_vma);
static void disassemble_bytes
  (struct disassemble_info *, disassembler_ftype, bfd_boolean,
   bfd_byte *, bfd_vma, bfd_vma, arelent ***, arelent **);
static void disassemble_data
  (bfd *);
static asymbol ** slurp_symtab
  (bfd *);
static asymbol ** slurp_dynamic_symtab
  (bfd *);
static long remove_useless_symbols
  (asymbol **, long);
static int compare_symbols
  (const void *, const void *);
static int compare_relocs
  (const void *, const void *);
static void dump_stabs
  (bfd *);
static bfd_boolean read_section_stabs
  (bfd *, const char *, const char *);
static void print_section_stabs
  (bfd *, const char *, const char *);
static void dump_section_stabs
  (bfd *, char *, char *);
d1101 1
d1225 3
a1227 2
		  && (**relppp)->address >= addr_offset
		  && (**relppp)->address <= addr_offset + octets / opb)
d1370 2
a1371 5
      if ((section->flags & SEC_RELOC) != 0
#ifndef DISASSEMBLER_NEEDS_RELOCS
	  && dump_reloc_info
#endif
	  )
d1373 1
a1373 8
	  while ((*relppp) < relppend
		 && ((**relppp)->address >= (bfd_vma) addr_offset
		     && (**relppp)->address < (bfd_vma) addr_offset + octets / opb))
#ifdef DISASSEMBLER_NEEDS_RELOCS
	    if (! dump_reloc_info)
	      ++(*relppp);
	    else
#endif
a1416 1
	      ++(*relppp);
d1418 1
d1439 3
d1511 19
d1543 2
a1544 2
      /* Sections that do not contain machine
	 code are not normally disassembled.  */
d1562 2
d1568 1
a1568 1
	  )
a1577 2
	      long relcount;

a1584 10

	      relpp = relbuf;
	      relppend = relpp + relcount;

	      /* Skip over the relocs belonging to addresses below the
		 start address.  */
	      if (start_address != (bfd_vma) -1)
		while (relpp < relppend
		       && (*relpp)->address < start_address)
		  ++relpp;
d1610 21
d1652 2
a1653 1
	  if (sym != NULL && bfd_asymbol_value (sym) <= section->vma + addr_offset)
d1659 2
a1660 2
		    && bfd_asymbol_value (sorted_syms[x])
		       <= section->vma + addr_offset);
d1702 2
a1703 1
	  if (sym != NULL && bfd_asymbol_value (sym) > section->vma + addr_offset)
d1735 2
a1736 1
			     addr_offset, nextstop_offset, &relpp, relppend);
d1747 3
d2023 1
a2023 1
  if (dump_dynamic_reloc_info)
@


1.71
log
@Do not ignore sections without the LOAD flag when disassemble_all is true.
Only print a message about disassembling a section if it contains some data.
@
text
@d42 1
a42 1
  PARAMS ((FILE *, const char *, ...));
d125 1
a125 1
  PARAMS ((FILE *, int));
d127 1
a127 1
  PARAMS ((const char *));
d129 1
a129 1
  PARAMS ((char *, char *));
d131 1
a131 1
  PARAMS ((bfd *, asection *, PTR));
d133 1
a133 1
  PARAMS ((bfd *));
d135 1
a135 1
  PARAMS ((bfd *));
d137 1
a137 1
  PARAMS ((bfd *));
d139 1
a139 1
  PARAMS ((bfd *));
d141 1
a141 1
  PARAMS ((bfd *, asection *, arelent **, long));
d143 1
a143 1
  PARAMS ((bfd *, bfd_boolean));
d145 1
a145 1
  PARAMS ((bfd *));
d147 1
a147 1
  PARAMS ((bfd *));
d149 1
a149 1
  PARAMS ((bfd *));
d151 1
a151 1
  PARAMS ((bfd *));
d153 1
a153 1
  PARAMS ((bfd_vma, struct disassemble_info *, bfd_boolean));
d155 1
a155 1
  PARAMS ((bfd *, struct disassemble_info *, asymbol *));
d157 1
a157 1
  PARAMS ((bfd *, asection *, bfd_vma, bfd_boolean, long *));
d159 2
a160 2
  PARAMS ((bfd *, asection *, asymbol *, bfd_vma,
	   struct disassemble_info *, bfd_boolean));
d162 1
a162 1
  PARAMS ((bfd_vma, struct disassemble_info *, bfd_boolean));
d164 1
a164 1
  PARAMS ((bfd_vma, struct disassemble_info *));
d166 1
a166 1
  PARAMS ((bfd_vma, struct disassemble_info *));
d168 1
a168 1
  PARAMS ((bfd *, asection *, bfd_vma));
d170 2
a171 2
  PARAMS ((struct disassemble_info *, disassembler_ftype, bfd_boolean,
	   bfd_byte *, bfd_vma, bfd_vma, arelent ***, arelent **));
d173 1
a173 1
  PARAMS ((bfd *));
d175 1
a175 1
  PARAMS ((bfd *));
d177 1
a177 1
  PARAMS ((bfd *));
d179 1
a179 1
  PARAMS ((asymbol **, long));
d181 1
a181 1
  PARAMS ((const PTR, const PTR));
d183 1
a183 1
  PARAMS ((const PTR, const PTR));
d185 1
a185 1
  PARAMS ((bfd *));
d187 1
a187 1
  PARAMS ((bfd *, const char *, const char *));
d189 1
a189 1
  PARAMS ((bfd *, const char *, const char *));
d191 1
a191 1
  PARAMS ((bfd *, char *, char *));
d194 1
a194 3
usage (stream, status)
     FILE *stream;
     int status;
d255 7
a261 5

#define OPTION_ENDIAN (150)
#define OPTION_START_ADDRESS (OPTION_ENDIAN + 1)
#define OPTION_STOP_ADDRESS (OPTION_START_ADDRESS + 1)
#define OPTION_ADJUST_VMA (OPTION_STOP_ADDRESS + 1)
d305 1
a305 2
nonfatal (msg)
     const char *msg;
d312 2
a313 4
dump_section_header (abfd, section, ignored)
     bfd *abfd ATTRIBUTE_UNUSED;
     asection *section;
     PTR ignored ATTRIBUTE_UNUSED;
d388 1
a388 2
dump_headers (abfd)
     bfd *abfd;
d408 1
a408 1
  bfd_map_over_sections (abfd, dump_section_header, (PTR) NULL);
d412 1
a412 2
slurp_symtab (abfd)
     bfd *abfd;
d438 1
a438 2
slurp_dynamic_symtab (abfd)
     bfd *abfd;
d469 1
a469 3
remove_useless_symbols (symbols, count)
     asymbol **symbols;
     long count;
d471 1
a471 1
  register asymbol **in_ptr = symbols, **out_ptr = symbols;
d493 12
a504 10
compare_symbols (ap, bp)
     const PTR ap;
     const PTR bp;
{
  const asymbol *a = *(const asymbol **)ap;
  const asymbol *b = *(const asymbol **)bp;
  const char *an, *bn;
  size_t anl, bnl;
  bfd_boolean af, bf;
  flagword aflags, bflags;
d602 1
a602 3
compare_relocs (ap, bp)
     const PTR ap;
     const PTR bp;
d604 2
a605 2
  const arelent *a = *(const arelent **)ap;
  const arelent *b = *(const arelent **)bp;
d625 2
a626 4
objdump_print_value (vma, info, skip_zeroes)
     bfd_vma vma;
     struct disassemble_info *info;
     bfd_boolean skip_zeroes;
d649 2
a650 4
objdump_print_symname (abfd, info, sym)
     bfd *abfd;
     struct disassemble_info *info;
     asymbol *sym;
d679 2
a680 6
find_symbol_for_address (abfd, sec, vma, require_sec, place)
     bfd *abfd;
     asection *sec;
     bfd_vma vma;
     bfd_boolean require_sec;
     long *place;
d799 3
a801 7
objdump_print_addr_with_sym (abfd, sec, sym, vma, info, skip_zeroes)
     bfd *abfd;
     asection *sec;
     asymbol *sym;
     bfd_vma vma;
     struct disassemble_info *info;
     bfd_boolean skip_zeroes;
d846 2
a847 4
objdump_print_addr (vma, info, skip_zeroes)
     bfd_vma vma;
     struct disassemble_info *info;
     bfd_boolean skip_zeroes;
d870 1
a870 3
objdump_print_address (vma, info)
     bfd_vma vma;
     struct disassemble_info *info;
d878 1
a878 3
objdump_symbol_at_address (vma, info)
     bfd_vma vma;
     struct disassemble_info * info;
a921 3
static void skip_to_line
  PARAMS ((struct print_file_list *, unsigned int, bfd_boolean));

d923 2
a924 4
skip_to_line (p, line, show)
     struct print_file_list *p;
     unsigned int line;
     bfd_boolean show;
d949 1
a949 4
show_line (abfd, section, addr_offset)
     bfd *abfd;
     asection *section;
     bfd_vma addr_offset;
d1096 1
a1096 1
/* sprintf to a "stream" */
d1099 1
a1099 1
objdump_sprintf VPARAMS ((SFILE *f, const char *format, ...))
d1103 1
d1105 1
a1105 3
  VA_OPEN (args, format);
  VA_FIXEDARG (args, SFILE *, f);
  VA_FIXEDARG (args, const char *, format);
d1133 1
a1133 1
  VA_CLOSE (args);
d1158 8
a1165 11
disassemble_bytes (info, disassemble_fn, insns, data,
		   start_offset, stop_offset, relppp,
		   relppend)
     struct disassemble_info *info;
     disassembler_ftype disassemble_fn;
     bfd_boolean insns;
     bfd_byte *data;
     bfd_vma start_offset;
     bfd_vma stop_offset;
     arelent ***relppp;
     arelent **relppend;
d1502 1
a1502 2
disassemble_data (abfd)
     bfd *abfd;
d1527 1
a1527 1
  disasm_info.application_data = (PTR) &aux;
d1592 2
a1593 1
      /* Sections that do not contain machine code are not normally disassembled.  */
d1696 2
a1697 1
		    && bfd_asymbol_value (sorted_syms[x]) <= section->vma + addr_offset);
d1717 2
a1718 1
	  if (sym != NULL && bfd_asymbol_value (sym) > section->vma + addr_offset)
d1789 1
a1789 2
dump_stabs (abfd)
     bfd *abfd;
d1803 2
a1804 4
read_section_stabs (abfd, stabsect_name, strsect_name)
     bfd *abfd;
     const char *stabsect_name;
     const char *strsect_name;
d1830 1
a1830 1
  if (! bfd_get_section_contents (abfd, stabsect, (PTR) stabs, 0, stab_size))
d1841 1
a1841 1
  if (! bfd_get_section_contents (abfd, stabstrsect, (PTR) strtab, 0,
d1864 5
a1868 5
#define STRDXOFF (0)
#define TYPEOFF (4)
#define OTHEROFF (5)
#define DESCOFF (6)
#define VALOFF (8)
d1875 2
a1876 4
print_section_stabs (abfd, stabsect_name, strsect_name)
     bfd *abfd;
     const char *stabsect_name;
     const char *strsect_name ATTRIBUTE_UNUSED;
d1879 2
a1880 1
  unsigned file_string_table_offset = 0, next_file_string_table_offset = 0;
d1943 1
a1943 4
dump_section_stabs (abfd, stabsect_name, strsect_name)
     bfd *abfd;
     char *stabsect_name;
     char *strsect_name;
d1976 1
a1976 2
dump_bfd_header (abfd)
     bfd *abfd;
d2004 1
a2004 2
dump_bfd_private_header (abfd)
bfd *abfd;
d2012 1
a2012 2
dump_bfd (abfd)
     bfd *abfd;
d2063 1
a2063 1
      PTR dhandle;
d2092 1
a2092 2
display_bfd (abfd)
     bfd *abfd;
d2132 1
a2132 3
display_file (filename, target)
     char *filename;
     char *target;
d2179 1
a2179 2
dump_data (abfd)
     bfd *abfd;
d2209 2
a2210 1
	      data = (bfd_byte *) xmalloc ((size_t) bfd_section_size (abfd, section));
d2214 2
a2215 1
	      bfd_get_section_contents (abfd, section, (PTR) data, 0, bfd_section_size (abfd, section));
d2305 1
a2305 3
dump_symbols (abfd, dynamic)
     bfd *abfd ATTRIBUTE_UNUSED;
     bfd_boolean dynamic;
d2366 1
a2366 2
dump_relocs (abfd)
     bfd *abfd;
d2428 1
a2428 2
dump_dynamic_relocs (abfd)
     bfd *abfd;
d2462 1
a2462 5
dump_reloc_set (abfd, sec, relpp, relcount)
     bfd *abfd;
     asection *sec;
     arelent **relpp;
     long relcount;
a2572 2
int main PARAMS ((int, char **));

d2574 1
a2574 3
main (argc, argv)
     int argc;
     char **argv;
d2611 2
a2612 1
	    disassembler_options = concat (disassembler_options, ",", optarg, NULL);
@


1.70
log
@* objdump.c: New command line option --debugging-tags.
* doc/binutils.texi: Document new command line option.
* prdbg.c: Code to print the debug info as tags compatible with ctags.
* budbg.h: Adjust prototype.
* NEWS: Mention new switch
@
text
@d1631 4
a1634 4
      if ((section->flags & SEC_LOAD) == 0
	  || (! disassemble_all
	      && only == NULL
	      && (section->flags & SEC_CODE) == 0))
a1684 2
      printf (_("Disassembly of section %s:\n"), section->name);

d1688 2
@


1.69
log
@* objdump.c (main) :Accept multiple -M switch.
* doc/binutils.texi: Document that multiple -M switches are accepted and that
  a single -M switch can contain comma separated options.
* arm-dis.c (parse_arm_disassembler_option): Do not expect option string to be
  NUL terminated.
  (parse_disassembler_options): Allow options to be space or comma separated.
@
text
@d77 1
d212 1
d271 1
d2074 3
a2076 2
  printf (_("\n%s:     file format %s\n"), bfd_get_filename (abfd),
	  abfd->xvec->name);
d2083 2
a2084 1
  putchar ('\n');
d2114 2
a2115 1
	  if (! print_debugging_info (stdout, dhandle))
d2657 1
a2657 1
  while ((c = getopt_long (argc, argv, "pib:m:M:VvCdDlfaHhrRtTxsSj:wE:zgG",
d2792 6
@


1.68
log
@	* objdump.c (main): Issue a warning message if multiple -M
	switches are used.

	* doc/binutils.texi (objdump): Update documentation about -M
	option.
@
text
@d2664 4
a2667 6
	    {
	      non_fatal ("multiple separate -M options are not supported.");
	      non_fatal ("please combine them into a single, space separated option.");
	      non_fatal ("ignoring option '-M%s'", disassembler_options);
	    }
	  disassembler_options = optarg;
@


1.67
log
@Correct spelling of "relocatable".
@
text
@d2663 6
@


1.66
log
@2003-04-30  H.J. Lu <hjl@@gnu.org>

	* objdump.c (only): Change it to char **.
	(only_size): New.
	(only_used): New.
	(disassemble_data): Check only as an array.
	(dump_data): Likewise.
	(dump_relocs): Likewise.
	(main): Treat only as an array.
@
text
@d738 1
a738 1
  /* If the file is relocateable, and the symbol could be from this
@


1.65
log
@* objdump.c (dump_data): Don't truncate the address to long; make
the width large enough, and uniform for all entries in a section.
@
text
@d70 3
a72 1
static char *only;			/* -j secname */
d1633 12
a1644 2
      if (only != (char *) NULL && strcmp (only, section->name) != 0)
	continue;
d2236 1
d2238 5
a2242 2
      if (only == (char *) NULL ||
	  strcmp (only, section->name) == 0)
d2305 1
a2305 1
		  if (count >= sizeof (buf))
d2430 7
a2436 1
	  if (strcmp (only, a->name))
d2666 12
a2677 1
	  only = optarg;
@


1.64
log
@Move display_info() function into bucomm.c
@
text
@d2230 3
d2259 23
d2287 13
a2299 2
		  printf (" %04lx ", (unsigned long int)
			  (addr_offset + section->vma));
@


1.63
log
@(disassemble_data): Use disasm_info.fprintf_func not printf for emitting new
lines.
@
text
@d126 1
a126 1
  PARAMS ((char *filename, char *target));
d132 1
a132 1
  PARAMS ((bfd *abfd));
d134 1
a134 1
  PARAMS ((bfd *abfd));
d136 1
a136 1
  PARAMS ((bfd * abfd));
d140 1
a140 1
  PARAMS ((bfd *abfd, bfd_boolean dynamic));
d148 1
a148 9
  PARAMS ((bfd *abfd));
static void display_target_list
  PARAMS ((void));
static void display_info_table
  PARAMS ((int, int));
static void display_target_tables
  PARAMS ((void));
static void display_info
  PARAMS ((void));
a170 2
static const char *endian_string
  PARAMS ((enum bfd_endian));
a2563 177
/* The length of the longest architecture name + 1.  */
#define LONGEST_ARCH sizeof("powerpc:common")

static const char *
endian_string (endian)
     enum bfd_endian endian;
{
  if (endian == BFD_ENDIAN_BIG)
    return "big endian";
  else if (endian == BFD_ENDIAN_LITTLE)
    return "little endian";
  else
    return "endianness unknown";
}

/* List the targets that BFD is configured to support, each followed
   by its endianness and the architectures it supports.  */

static void
display_target_list ()
{
  extern const bfd_target *const *bfd_target_vector;
  char *dummy_name;
  int t;

  dummy_name = make_temp_file (NULL);
  for (t = 0; bfd_target_vector[t]; t++)
    {
      const bfd_target *p = bfd_target_vector[t];
      bfd *abfd = bfd_openw (dummy_name, p->name);
      int a;

      printf ("%s\n (header %s, data %s)\n", p->name,
	      endian_string (p->header_byteorder),
	      endian_string (p->byteorder));

      if (abfd == NULL)
	{
	  nonfatal (dummy_name);
	  continue;
	}

      if (! bfd_set_format (abfd, bfd_object))
	{
	  if (bfd_get_error () != bfd_error_invalid_operation)
	    nonfatal (p->name);
	  bfd_close_all_done (abfd);
	  continue;
	}

      for (a = (int) bfd_arch_obscure + 1; a < (int) bfd_arch_last; a++)
	if (bfd_set_arch_mach (abfd, (enum bfd_architecture) a, 0))
	  printf ("  %s\n",
		  bfd_printable_arch_mach ((enum bfd_architecture) a, 0));
      bfd_close_all_done (abfd);
    }
  unlink (dummy_name);
  free (dummy_name);
}

/* Print a table showing which architectures are supported for entries
   FIRST through LAST-1 of bfd_target_vector (targets across,
   architectures down).  */

static void
display_info_table (first, last)
     int first;
     int last;
{
  extern const bfd_target *const *bfd_target_vector;
  int t, a;
  char *dummy_name;

  /* Print heading of target names.  */
  printf ("\n%*s", (int) LONGEST_ARCH, " ");
  for (t = first; t < last && bfd_target_vector[t]; t++)
    printf ("%s ", bfd_target_vector[t]->name);
  putchar ('\n');

  dummy_name = make_temp_file (NULL);
  for (a = (int) bfd_arch_obscure + 1; a < (int) bfd_arch_last; a++)
    if (strcmp (bfd_printable_arch_mach (a, 0), "UNKNOWN!") != 0)
      {
	printf ("%*s ", (int) LONGEST_ARCH - 1,
		bfd_printable_arch_mach (a, 0));
	for (t = first; t < last && bfd_target_vector[t]; t++)
	  {
	    const bfd_target *p = bfd_target_vector[t];
	    bfd_boolean ok = TRUE;
	    bfd *abfd = bfd_openw (dummy_name, p->name);

	    if (abfd == NULL)
	      {
		nonfatal (p->name);
		ok = FALSE;
	      }

	    if (ok)
	      {
		if (! bfd_set_format (abfd, bfd_object))
		  {
		    if (bfd_get_error () != bfd_error_invalid_operation)
		      nonfatal (p->name);
		    ok = FALSE;
		  }
	      }

	    if (ok)
	      {
		if (! bfd_set_arch_mach (abfd, a, 0))
		  ok = FALSE;
	      }

	    if (ok)
	      printf ("%s ", p->name);
	    else
	      {
		int l = strlen (p->name);
		while (l--)
		  putchar ('-');
		putchar (' ');
	      }
	    if (abfd != NULL)
	      bfd_close_all_done (abfd);
	  }
	putchar ('\n');
      }
  unlink (dummy_name);
  free (dummy_name);
}

/* Print tables of all the target-architecture combinations that
   BFD has been configured to support.  */

static void
display_target_tables ()
{
  int t, columns;
  extern const bfd_target *const *bfd_target_vector;
  char *colum;

  columns = 0;
  colum = getenv ("COLUMNS");
  if (colum != NULL)
    columns = atoi (colum);
  if (columns == 0)
    columns = 80;

  t = 0;
  while (bfd_target_vector[t] != NULL)
    {
      int oldt = t, wid;

      wid = LONGEST_ARCH + strlen (bfd_target_vector[t]->name) + 1;
      ++t;
      while (wid < columns && bfd_target_vector[t] != NULL)
	{
	  int newwid;

	  newwid = wid + strlen (bfd_target_vector[t]->name) + 1;
	  if (newwid >= columns)
	    break;
	  wid = newwid;
	  ++t;
	}
      display_info_table (oldt, t);
    }
}

static void
display_info ()
{
  printf (_("BFD header file version %s\n"), BFD_VERSION_STRING);
  display_target_list ();
  display_target_tables ();
}

d2759 1
a2759 1
    display_info ();
@


1.62
log
@Fix help messages about demangling styles
@
text
@d48 1
a48 1
static char *default_target = NULL;	/* default at runtime */
d50 1
a50 1
static int show_version = 0;		/* show the version number */
d113 6
d197 2
a533 1

a753 1

d769 1
d771 1
d1566 1
a1566 1
  /* Sort the symbols into section and symbol order */
d1569 2
a1570 1
  INIT_DISASSEMBLE_INFO(disasm_info, stdout, fprintf);
d1580 1
d1582 2
a1583 3
	{
	  fatal (_("Can't use supplied machine %s"), machine);
	}
d1674 3
a1676 5
		{
		  while (relpp < relppend
			 && (*relpp)->address < start_address)
		    ++relpp;
		}
d1695 1
d1701 1
d1732 1
d1741 1
a1741 1
	      printf ("\n");
d1746 1
a1746 1
	      printf (":\n");
d1809 1
a1815 8

/* Define a table of stab values and print-strings.  We wish the initializer
   could be a direct-mapped table, but instead we build one the first
   time we need it.  */

static void dump_section_stabs
  PARAMS ((bfd *abfd, char *stabsect_name, char *strsect_name));

a1828 6
static bfd_byte *stabs;
static bfd_size_type stab_size;

static char *strtab;
static bfd_size_type stabstr_size;

a1927 1

a1958 1

a1967 1

d2011 1
d2040 1
d2049 1
a2049 1
/* Dump selected contents of ABFD */
d2217 1
a2217 1
/* Actually display the various requested regions */
d2301 2
a2302 1
/* Should perhaps share code and display with nm? */
a2345 1

d2407 1
d2411 1
a2411 3
	    {
	      printf (" (none)\n\n");
	    }
d2438 1
a2438 3
    {
      printf (" (none)\n\n");
    }
d2443 1
d2447 1
a2447 3
	{
	  printf (" (none)\n\n");
	}
d2472 1
d2515 1
d2543 1
d2563 1
d2569 1
@


1.61
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d3 1
a3 1
   2000, 2001, 2002
d233 3
a235 2
                                  The STYLE, if specified, can be `auto', 'gnu',\n\
                                  'lucid', 'arm', 'hp', 'edg', or 'gnu-v3'\n\
d238 2
a239 2
      --start-address=ADDR       Only process data whoes address is >= ADDR\n\
      --stop-address=ADDR        Only process data whoes address is <= ADDR\n\
@


1.60
log
@	* objdump.c (dump_data): Correct addr_offset for opb != 1.
@
text
@d41 2
a42 1
extern int fprintf PARAMS ((FILE *, const char *, ...));
d53 1
a53 1
static boolean dump_file_header;	/* -f */
d62 1
a62 1
static boolean with_source_code;	/* -S */
d66 2
a67 2
static boolean disassemble;		/* -d */
static boolean disassemble_all;		/* -D */
d69 1
a69 1
static boolean formats_info;		/* -i */
d83 1
a83 1
  boolean require_sec;
d115 36
a150 18
static void usage PARAMS ((FILE *, int));
static void nonfatal PARAMS ((const char *));
static void display_file PARAMS ((char *filename, char *target));
static void dump_section_header PARAMS ((bfd *, asection *, PTR));
static void dump_headers PARAMS ((bfd *));
static void dump_data PARAMS ((bfd *abfd));
static void dump_relocs PARAMS ((bfd *abfd));
static void dump_dynamic_relocs PARAMS ((bfd * abfd));
static void dump_reloc_set PARAMS ((bfd *, asection *, arelent **, long));
static void dump_symbols PARAMS ((bfd *abfd, boolean dynamic));
static void dump_bfd_header PARAMS ((bfd *));
static void dump_bfd_private_header PARAMS ((bfd *));
static void dump_bfd PARAMS ((bfd *));
static void display_bfd PARAMS ((bfd *abfd));
static void display_target_list PARAMS ((void));
static void display_info_table PARAMS ((int, int));
static void display_target_tables PARAMS ((void));
static void display_info PARAMS ((void));
d152 1
a152 1
  PARAMS ((bfd_vma, struct disassemble_info *, boolean));
d156 1
a156 1
  PARAMS ((bfd *, asection *, bfd_vma, boolean, long *));
d159 1
a159 1
	   struct disassemble_info *, boolean));
d161 1
a161 1
  PARAMS ((bfd_vma, struct disassemble_info *, boolean));
d166 2
a167 1
static void show_line PARAMS ((bfd *, asection *, bfd_vma));
d169 1
a169 1
  PARAMS ((struct disassemble_info *, disassembler_ftype, boolean,
d171 20
a190 10
static void disassemble_data PARAMS ((bfd *));
static const char *endian_string PARAMS ((enum bfd_endian));
static asymbol ** slurp_symtab PARAMS ((bfd *));
static asymbol ** slurp_dynamic_symtab PARAMS ((bfd *));
static long remove_useless_symbols PARAMS ((asymbol **, long));
static int compare_symbols PARAMS ((const PTR, const PTR));
static int compare_relocs PARAMS ((const PTR, const PTR));
static void dump_stabs PARAMS ((bfd *));
static boolean read_section_stabs PARAMS ((bfd *, const char *, const char *));
static void print_section_stabs PARAMS ((bfd *, const char *, const char *));
d505 1
a505 1
  boolean af, bf;
d627 1
a627 1
/* Print VMA to STREAM.  If SKIP_ZEROES is true, omit leading zeroes.  */
d633 1
a633 1
     boolean skip_zeroes;
d683 1
a683 1
   is true, then always require the symbol to be in the section.  This
d692 1
a692 1
     boolean require_sec;
d817 1
a817 1
     boolean skip_zeroes;
d831 1
a831 1
	  objdump_print_value (secaddr - vma, info, true);
d836 1
a836 1
	  objdump_print_value (vma - secaddr, info, true);
d847 1
a847 1
	  objdump_print_value (bfd_asymbol_value (sym) - vma, info, true);
d852 1
a852 1
	  objdump_print_value (vma - bfd_asymbol_value (sym), info, true);
d859 1
a859 1
   true, don't output leading zeroes.  */
d865 1
a865 1
     boolean skip_zeroes;
d944 2
a945 2
static void
skip_to_line PARAMS ((struct print_file_list *, unsigned int, boolean));
d951 1
a951 1
     boolean show;
d1050 1
a1050 1
		skip_to_line (p, l, false);
d1061 1
a1061 1
	      skip_to_line (p, line, true);
d1097 1
a1097 1
	      skip_to_line (p, l, false);
d1099 1
a1099 1
		skip_to_line (p, line, true);
d1194 1
a1194 1
     boolean insns;
d1204 1
a1204 1
  boolean done_dot;
d1242 1
a1242 1
  done_dot = false;
d1248 1
a1248 1
      boolean need_nl = false;
d1280 1
a1280 1
	  done_dot = false;
d1301 1
a1301 1
	      aux->require_sec = true;
d1303 1
a1303 1
	      aux->require_sec = false;
d1462 1
a1462 1
	    need_nl = true;
d1489 1
a1489 1
	      objdump_print_value (section->vma + q->address, info, true);
d1517 1
a1517 1
		  objdump_print_value (q->addend, info, true);
d1521 1
a1521 1
	      need_nl = false;
d1563 1
a1563 1
  aux.require_sec = false;
d1705 1
a1705 1
				     true, &place);
d1711 1
a1711 1
	  boolean insns;
d1734 1
a1734 1
					   false);
d1786 1
a1786 1
	    insns = true;
d1788 1
a1788 1
	    insns = false;
d1809 2
a1810 2
static void dump_section_stabs PARAMS ((bfd *abfd, char *stabsect_name,
					char *strsect_name));
d1833 2
a1834 2
   If the section exists and was read, allocate the space and return true.
   Otherwise return false.  */
d1836 1
a1836 1
static boolean
d1848 1
a1848 1
      return false;
d1857 1
a1857 1
      return false;
d1874 1
a1874 1
      return false;
d1886 1
a1886 1
      return false;
d1889 1
a1889 1
  return true;
d2075 1
a2075 1
    print_arelt_descr (stdout, abfd, true);
d2090 1
a2090 1
    dump_symbols (abfd, false);
d2092 1
a2092 1
    dump_symbols (abfd, true);
d2187 1
a2187 1
  if (bfd_check_format (file, bfd_archive) == true)
d2308 1
a2308 1
     boolean dynamic;
d2664 1
a2664 1
	    boolean ok = true;
d2670 1
a2670 1
		ok = false;
d2679 1
a2679 1
		    ok = false;
d2686 1
a2686 1
		  ok = false;
d2762 1
a2762 1
  boolean seenflag = false;
d2799 1
a2799 1
	  with_line_numbers = true;
d2805 1
a2805 1
	  do_demangle = true;
d2819 1
a2819 1
	  wide_output = true;
d2854 2
a2855 2
	  dump_file_header = true;
	  seenflag = true;
d2858 2
a2859 2
	  formats_info = true;
	  seenflag = true;
d2862 2
a2863 2
	  dump_private_headers = true;
	  seenflag = true;
d2866 7
a2872 7
	  dump_private_headers = true;
	  dump_symtab = true;
	  dump_reloc_info = true;
	  dump_file_header = true;
	  dump_ar_hdrs = true;
	  dump_section_headers = true;
	  seenflag = true;
d2875 2
a2876 2
	  dump_symtab = true;
	  seenflag = true;
d2879 2
a2880 2
	  dump_dynamic_symtab = true;
	  seenflag = true;
d2883 2
a2884 2
	  disassemble = true;
	  seenflag = true;
d2887 1
a2887 1
	  disassemble_zeroes = true;
d2890 3
a2892 3
	  disassemble = true;
	  disassemble_all = true;
	  seenflag = true;
d2895 3
a2897 3
	  disassemble = true;
	  with_source_code = true;
	  seenflag = true;
d2901 1
a2901 1
	  seenflag = true;
d2904 2
a2905 2
	  dump_stab_section_info = true;
	  seenflag = true;
d2908 2
a2909 2
	  dump_section_contents = true;
	  seenflag = true;
d2912 2
a2913 2
	  dump_reloc_info = true;
	  seenflag = true;
d2916 2
a2917 2
	  dump_dynamic_reloc_info = true;
	  seenflag = true;
d2920 2
a2921 2
	  dump_ar_hdrs = true;
	  seenflag = true;
d2924 2
a2925 2
	  dump_section_headers = true;
	  seenflag = true;
d2929 1
a2929 1
	  seenflag = true;
d2932 2
a2933 2
	  show_version = true;
	  seenflag = true;
d2944 1
a2944 1
  if (seenflag == false)
@


1.59
log
@	* Makefile.am: Run "make dep-am".
	* objdump.c: #include "bfdver.h".
	* version.c: Likewise.
	* Makefile.in: Regenerate.
	* config.in: Regenerate.
	* configure: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d2240 1
a2240 1
		   addr_offset < stop_offset; addr_offset += onaline)
d2258 2
a2259 1
		  for (j = addr_offset; j < addr_offset * opb + onaline; j++)
@


1.58
log
@	* objdump.c (dump_bfd): Restore lines accidentally deleted in
	last commit.
@
text
@d23 1
@


1.57
log
@Add TMS320C4x support
@
text
@d2041 2
@


1.56
log
@	* nm.c (display_rel_file): Don't report "no symbols" as an error.
	* objdump.c (slurp_symtab): Likewise.
	(slurp_dynamic_symtab): Likewise.
	(dump_symbols): Likewise.  Do print "no symbols" to stdout.
@
text
@d77 2
a78 1
struct objdump_disasm_info {
d373 2
d2008 1
a2040 2
  printf (_("\n%s:     file format %s\n"), bfd_get_filename (abfd),
	  abfd->xvec->name);
d2050 1
d2052 1
a2052 3
    {
      syms = slurp_symtab (abfd);
    }
d2054 2
a2055 3
    {
      dynsyms = slurp_dynamic_symtab (abfd);
    }
d2085 1
d2091 1
@


1.55
log
@Replace 'gnu-new-abi' with 'gnu-v3'
@
text
@a385 1
      non_fatal (_("%s: no symbols"), bfd_get_filename (abfd));
a398 2
  if (symcount == 0)
    non_fatal (_("%s: no symbols"), bfd_get_filename (abfd));
a428 2
  if (dynsymcount == 0)
    non_fatal (_("%s: No dynamic symbols"), bfd_get_filename (abfd));
a2281 2
      if (max == 0)
	return;
a2287 2
      if (max == 0)
	return;
d2290 3
@


1.54
log
@	* budemang.c: New file, "demangle" function.
	* budemang.h: New file.
	* addr2line.c (translate_addresses): Use "demangle".
	* nm.c (print_symname): Likewise.
	* objdump.c (objdump_print_symname): Likewise.
	(dump_symbols): Likewise.  Also, don't use bfd_asymbol_name macro
	here since that obfuscates.
	* rdcoff.c: Don't #include demangle.h.
	* Makefile.am (CFILES): Add budemang.c, emul_aix.c,
	emul_vanilla.c.  Remove emul_$(EMULATION).c.  Sort.
	(HFILES): Add budemang.h.  Sort.
	(nm_new_SOURCES, objdump_SOURCES, addr2line_SOURCES): Add budemang.c.
	Run "make dep-am".
	* Makefile.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d6 1
a6 1
This file is part of GNU Binutils.
d8 13
a20 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2, or (at your option)
any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
d202 1
a202 1
                                  'lucid', 'arm', 'hp', 'edg', or 'gnu-new-abi'\n\
@


1.54.2.1
log
@	* objdump.c (dump_data): Correct addr_offset for opb != 1.
@
text
@d2240 1
a2240 1
		   addr_offset < stop_offset; addr_offset += onaline / opb)
d2258 1
a2258 2
		  for (j = addr_offset * opb;
		       j < addr_offset * opb + onaline; j++)
@


1.53
log
@	* bucomm.c: Replace CONST with const.
	* nm.c: Likewise.
	* objdump.c: Likewise.
@
text
@d25 1
a633 1
  const char *print;
d637 1
a637 3
  if (! do_demangle || name[0] == '\0')
    print = name;
  else
d640 2
a641 8
      if (bfd_get_symbol_leading_char (abfd) == name[0])
	++name;

      alloc = cplus_demangle (name, DMGL_ANSI | DMGL_PARAMS);
      if (alloc == NULL)
	print = name;
      else
	print = alloc;
d645 1
a645 1
    (*info->fprintf_func) (info->stream, "%s", print);
d647 1
a647 1
    printf ("%s", print);
d2311 1
a2311 1
	      name = bfd_asymbol_name (*current);
a2314 2
		  const char *n;

d2319 2
a2320 8
		  n = name;
		  if (bfd_get_symbol_leading_char (cur_bfd) == *n)
		    ++n;
		  alloc = cplus_demangle (n, DMGL_ANSI | DMGL_PARAMS);
		  if (alloc != NULL)
		    (*current)->name = alloc;
		  else
		    (*current)->name = n;
@


1.52
log
@	* objdump.c: Fix formatting.
@
text
@d960 2
a961 2
  CONST char *filename;
  CONST char *functionname;
d2546 1
a2546 1
	  if (section_name == (CONST char *) NULL)
@


1.51
log
@	* elf.c (_bfd_elf_make_section_from_shdr): Set SEC_THREAD_LOCAL
	for symbols from SHF_TLS section.
	(_bfd_elf_print_private_bfd_data): Add PT_TLS.
	(elf_fake_sections): Set SHF_TLS for SEC_THREAD_LOCAL sections.
	(map_sections_to_segments): Build PT_TLS segment if necessary.
	(assign_file_positions_for_segments): Likewise.
	(get_program_header_size): Account for PT_TLS segment.
	(swap_out_syms): Set type of BSF_THREAD_LOCAL symbols and symbols from
	SEC_THREAD_LOCAL sections to STT_TLS.
	* reloc.c: Add 386 and IA-64 TLS relocs.
	* section.c (SEC_THREAD_LOCAL): Define.
	(SEC_CONSTRUCTOR_TEXT, SEC_CONSTRUCTOR_DATA, SEC_CONSTRUCTOR_BSS):
	Remove.
	* elflink.h (elf_link_add_object_symbols): Support .tcommon.
	(size_dynamic_sections): If DF_STATIC_TLS, set DF_FLAGS
	unconditionally.
	(struct elf_final_link_info): Add first_tls_sec.
	(elf_bfd_final_link): Set first_tls_sec.
	Compute elf_hash_table (info)->tls_segment.
	(elf_link_output_extsym): Handle STT_TLS symbols.
	(elf_link_input_bfd): Likewise.
	* syms.c (BSF_THREAD_LOCAL): Define.
	* bfd-in2.h: Rebuilt.
	* libbfd.h: Rebuilt.
	* elf32-i386.c (elf_i386_tls_transition, dtpoff_base, tpoff,
	elf_i386_mkobject, elf_i386_object_p): New functions.
	(elf_howto_table): Add TLS relocs.
	(elf_i386_reloc_type_lookup): Support TLS relocs.
	(elf_i386_info_to_howto_rel): Likewise.
	(struct elf_i386_link_hash_entry): Add tls_type.
	(struct elf_i386_obj_tdata): New.
	(elf_i386_hash_entry, elf_i386_tdata, elf_i386_local_got_tls_type):
	New macros.
	(struct elf_i386_link_hash_table): Add tls_ldm_got.
	(link_hash_newfunc): Clear tls_type.
	(elf_i386_check_relocs): Support TLS relocs.
	(elf_i386_gc_sweep_hook): Likewise.
	(allocate_dynrelocs): Likewise.
	(elf_i386_size_dynamic_sections): Likewise.
	(elf_i386_relocate_section): Likewise.
	(elf_i386_finish_dynamic_symbol): Likewise.
	(bfd_elf32_mkobject, elf_backend_object_p): Define.
	* elfxx-ia64.c (struct elfNN_ia64_dyn_sym_info): Add tprel_offset,
	dtpmod_offset, dtprel_offset, tprel_done, dtpmod_done, dtprel_done,
	want_tprel, want_dtpmod, want_dtprel.
	(elfNN_ia64_tprel_base, elfNN_ia64_dtprel_base): New functions.
	(ia64_howto_table): Add TLS relocs, rename R_IA64_LTOFF_TP22 to
	R_IA64_LTOFF_TPREL22.
	(elf_code_to_howto_index): Add TLS relocs.
	(elfNN_ia64_check_relocs): Support TLS relocs.
	(allocate_global_data_got): Account for TLS .got data.
	(allocate_dynrel_entries): Account for TLS dynamic relocations.
	(elfNN_ia64_install_value): Supprt TLS relocs.
	(set_got_entry): Support TLS relocs.
	(elfNN_ia64_relocate_section): Likewise.

	* config/obj-elf.c (elf_common): Renamed from obj_elf_common.
	(obj_elf_common): Call elf_common.
	(obj_elf_tls_common): New function.
	(elf_pseudo_tab): Support .tls_common.
	(special_sections): Add .tdata and .tbss.
	(obj_elf_change_section): Set SEC_THREAD_LOCAL for SHF_TLS
	sections.
	(obj_elf_parse_section_letters): Support T in section flags (SHF_TLS).
	(obj_elf_parse_section_letters): Include T in error message.
	* config/tc-ppc.c (ppc_section_letter): Likewise.
	* config/tc-alpha.c (alpha_elf_section_letter): Likewise.
	(tc_gen_reloc): Handle SEC_THREAD_LOCAL the same way as
	SEC_MERGE.
	* config/tc-sparc.c (md_apply_fix3): Likewise.
	* config/tc-i386.c (tc_i386_fix_adjustable): Add TLS relocs.
	Define them if not BFD_ASSEMBLER.
	(lex_got): Support @@TLSGD, @@TLSLDM, @@GOTTPOFF, @@TPOFF, @@DTPOFF
	and @@NTPOFF.
	(md_apply_fix3): Add TLS relocs.
	* config/tc-ia64.c (enum reloc_func): Add FUNC_DTP_MODULE,
	FUNC_DTP_RELATIVE, FUNC_TP_RELATIVE, FUNC_LT_DTP_MODULE,
	FUNC_LT_DTP_RELATIVE, FUNC_LT_TP_RELATIVE.
	(pseudo_func): Support @@dtpmod(), @@dtprel() and @@tprel().
	(ia64_elf_section_letter): Include T in error message.
	(md_begin): Support TLS operators.
	(md_operand): Likewise.
	(ia64_gen_real_reloc_type): Support TLS relocs.
	* testsuite/gas/i386/tlspic.s: New file.
	* testsuite/gas/i386/tlsd.s: New file.
	* testsuite/gas/i386/tlsnopic.s: New file.
	* testsuite/gas/i386/tlsd.d: New file.
	* testsuite/gas/i386/tlsnopic.d: New file.
	* testsuite/gas/i386/tlspic.d: New file.
	* testsuite/gas/i386/i386.exp: Add tlsd, tlsnopic and tlspic tests.
	* testsuite/gas/ia64/tls.s: New file.
	* testsuite/gas/ia64/tls.d: New file.
	* testsuite/gas/ia64/ia64.exp: Add tls test.
	* write.c (adjust_reloc_syms): Don't change symbols in
	SEC_THREAD_LOCAL sections to STT_SECTION + addend.

	* elf/common.h (PT_TLS, SHF_TLS, STT_TLS, DF_STATIC_TLS): Define.
	* elf/ia64.h (R_IA64_LTOFF_TPREL22): Renamed from R_IA64_LTOFF_TP22.
	* elf/i386.h: Add TLS relocs.

	* scripttempl/elf.sc: Add .rel{,a}.t{bss,data}, .tdata and .tbss.
	* ldlang.c (lang_add_section): Set SEC_THREAD_LOCAL for
	output section if necessary.  Handle .tbss.
	(lang_size_sections): Clear _raw_size for .tbss section
	(it allocates space in PT_TLS segment only).
	* ldwrite.c (build_link_order): Build link order for .tbss too.

	* readelf.c (get_segment_type): Add PT_TLS.
	(get_elf_section_flags): Add SHF_TLS.
	(get_dynamic_flags): Optimize.  Add DF_STATIC_TLS.
	(process_dynamic_segment): Use puts instead of printf.
	(get_symbol_type): Support STT_TLS.
	* objdump.c (dump_section_header): Remove SEC_CONSTRUCTOR_TEXT,
	SEC_CONSTRUCTOR_DATA, SEC_CONSTRUCTOR_BSS.
	Add SEC_THREAD_LOCAL.
@
text
@d3 1
a3 1
   2000, 2001
d393 2
a395 4
  if (storage)
    {
      sy = (asymbol **) xmalloc (storage);
    }
d425 2
a427 4
  if (storage)
    {
      sy = (asymbol **) xmalloc (storage);
    }
@


1.50
log
@	* filemode.c: Fix formatting.
	* ieee.c: Likewise.
	* is-ranlib.c: Likewise.
	* is-strip.c: Likewise.
	* maybe-ranlib.c: Likewise.
	* maybe-strip.c: Likewise.
	* nlmconv.c: Likewise.
	* nm.c: Likewise.
	* not-ranlib.c: Likewise.
	* not-strip.c: Likewise.
	* objcopy.c: Likewise.
	* objdump.c: Likewise.
@
text
@a301 3
  PF (SEC_CONSTRUCTOR_TEXT, "CONSTRUCTOR TEXT");
  PF (SEC_CONSTRUCTOR_DATA, "CONSTRUCTOR DATA");
  PF (SEC_CONSTRUCTOR_BSS, "CONSTRUCTOR BSS");
d317 1
@


1.49
log
@	* objdump.c (dump_headers): Fix output formatting for ELF32
	architectures in a BFD64 enabled toolchain.
	* bfd/bfd.c (bfd_get_arch_size): Remove bfd_set_error call for
	non-ELF targets.
@
text
@d444 1
a444 1
   Return the number of useful symbols. */
d472 1
a472 1
static int 
d689 1
a689 1
  unsigned int opb = bfd_octets_per_byte (abfd); 
d726 1
a726 1
       
d955 1
a955 1
}  
d1076 4
a1079 4
              if (file_start_context)
                l = 0;
              else
                l = line - SHOW_PRECEDING_CONTEXT_LINES;
d1174 2
a1175 2
disassemble_bytes (info, disassemble_fn, insns, data, 
                   start_offset, stop_offset, relppp,
d1244 2
a1245 2
	      || (z == stop_offset * opb && 
                  z - addr_offset * opb < SKIP_ZEROES_AT_END)))
d1451 2
a1452 2
#ifndef DISASSEMBLER_NEEDS_RELOCS	  
  	  && dump_reloc_info
d1588 1
a1588 1
  
d1620 1
a1620 1
#ifndef DISASSEMBLER_NEEDS_RELOCS	  
d1623 1
a1623 1
	  ) 
d1697 1
a1697 1
	  
d1722 1
a1722 1
	  
d1743 1
a1743 1
	  
d1758 1
a1758 1
	  
d1774 4
a1777 4
	  
	  disassemble_bytes (&disasm_info, disassemble_fn, insns, data, 
                             addr_offset, nextstop_offset, &relpp, relppend);
	  
d1781 1
a1781 1
      
d1844 1
a1844 1
 
d1850 1
a1850 1
  
d1932 1
a1932 1
	 again (makes consistent formatting for tools like awk). */
d2253 2
a2254 2
	      for (addr_offset = start_offset; 
                   addr_offset < stop_offset; addr_offset += onaline)
d2258 4
a2261 4
		  printf (" %04lx ", (unsigned long int) 
                          (addr_offset + section->vma));
		  for (j = addr_offset * opb; 
                       j < addr_offset * opb + onaline; j++)
d2803 1
a2803 1
	      if (style == unknown_demangling) 
d2808 1
a2808 1
           }
d2927 1
a2927 1
	  
@


1.48
log
@2002-01-29  Daniel Jacobowitz  <drow@@mvista.com>

        * objdump.c: Include "getopt.h" after "bucomm.h" so that
        __GNU_LIBRARY__ will be defined.
        * size.c: Likewise.
@
text
@d364 5
a368 1
  printf (_("Idx Name          Size      VMA               LMA               File off  Algn"));
@


1.47
log
@Tidy up formatting of --help output.
@
text
@a22 1
#include "getopt.h"
d25 1
@


1.46
log
@	* addr2line.c (main): Protoype.
	* ar.c (main): Protoype.
	* nm.c (main): Protoype.
	* objcopy.c (main): Protoype.
	* objdump.c (main): Protoype.
	* size.c (main): Protoype.
	* strings.c (main): Protoype.
	* gasp.c (main): Protoype.
@
text
@d164 3
a166 3
  fprintf (stream, _("Usage: %s OPTION... FILE...\n"), program_name);
  fprintf (stream, _("Display information from object FILE.\n"));
  fprintf (stream, _("\n At least one of the following switches must be given:\n"));
d183 1
a183 1
  -V, --version            Display this program's version number\n\
d2769 1
a2769 1
  while ((c = getopt_long (argc, argv, "pib:m:M:VCdDlfahHrRtTxsSj:wE:zgG",
d2776 1
a2776 1
	  break;		/* we've been given a long option */
d2797 1
a2797 1
	      
d2802 1
a2802 1
	      
d2840 1
a2840 1
	  
d2918 1
@


1.45
log
@	* coffdump.c (PROGRAM_VERSION): Delete.
	(main <'V'>): Call print_version.
	* srconv.c: Likewise.
	* sysdump.c: Likewise.
	* version.c (program_version): Remove.
	(print_version): Use BFD_VERSION_STRING.  Just print the current
	year in copyright message.
	* addr2line.c (program_version): Remove unused declaration.
	* objdump.c (display_target_tables): Use BFD_VERSION_STRING in
	place of BFD_VERSION.
	* Makefile.am (Makefile): Depend on bfd/configure.in
	(cplus-dem.o): Depend on Makefile.
	Run "make dep-am"
	* Makefile.in: Regenerate.
@
text
@d2741 2
@


1.44
log
@        * objdump.c (dump_section_header): Dump SEC_ARCH_BIT_0.
@
text
@d2736 1
a2736 1
  printf (_("BFD header file version %s\n"), BFD_VERSION);
@


1.43
log
@	* bucomm.c (fatal): Define using VPARAMS, VA_OPEN, VA_FIXEDARG,
	VA_CLOSE.
	(non_fatal): Likewise.
	* objdump.c (objdump_sprintf): Likewise.
	* readelf.c (error): Likewise.
	(warn): Likewise.
@
text
@a306 3
#ifdef SEC_BALIGN
  PF (SEC_BALIGN, "BALIGN");
#endif
d319 1
@


1.42
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d1112 1
a1112 6
#ifdef ANSI_PROTOTYPES
objdump_sprintf (SFILE *f, const char *format, ...)
#else
objdump_sprintf (va_alist)
     va_dcl
#endif
a1113 4
#ifndef ANSI_PROTOTYPES
  SFILE *f;
  const char *format;
#endif
a1114 1
  va_list args;
d1117 3
a1119 7
#ifdef ANSI_PROTOTYPES
  va_start (args, format);
#else
  va_start (args);
  f = va_arg (args, SFILE *);
  format = va_arg (args, const char *);
#endif
a1122 2
  va_end (args);

d1125 1
d1147 1
@


1.41
log
@	* ar.c (print_contents): Cast args of bfd_seek to the right types.
	Replace bfd_read call with call to bfd_bread.
	(extract_file): Likewise.

	* objdump.c (dump_section_header): Cast section->filepos to
	unsigned long to suit printf format string.
	* readelf.c (process_section_headers): Similarly for sh_offset.
	(process_unwind): Likewise.
@
text
@d26 1
a26 1
#include <ctype.h>
d1348 1
a1348 1
		  if (isprint (data[j]))
d2002 1
a2002 1
	      || isdigit ((unsigned char) s->name[len])))
d2289 1
a2289 1
			printf ("%c", isprint (data[j]) ? data[j] : '.');
d2768 3
@


1.40
log
@2001-08-10  H.J. Lu  <hjl@@gnu.org>

	* nm.c (print_value): Add one arg, bfd *.
	(print_value): Replace fprintf_vma with bfd_fprintf_vma.
	(print_symbol_info_bsd): Also pass `abfd' to print_value ().
	(print_symbol_info_sysv): Likewise.
	(print_symbol_info_posix): Likewise.

	* objdump.c (dump_section_header): Replace printf_vma with
	bfd_printf_vma.
	(print_section_stabs): Likewise.
	(dump_bfd_header): Likewise.
	(objdump_print_value): Replace sprintf_vma with
	bfd_sprintf_vma.
	(disassemble_bytes): Likewise.
	(dump_reloc_set): Likewise.
@
text
@d290 1
a290 1
  printf ("  %08lx  2**%u", section->filepos,
@


1.39
log
@	* readelf.c: Add missing prototypes.
	* objdump.c: Likewise.  Format existing prototypes.
@
text
@d287 1
a287 1
  printf_vma (bfd_get_section_vma (abfd, section));
d289 1
a289 1
  printf_vma (section->lma);
d611 2
d614 1
a614 1
  sprintf_vma (buf, vma);
d1224 4
a1227 2
      sprintf_vma (buf, section->vma + 
                   bfd_section_size (section->owner, section) / opb);
d1289 1
a1289 1
	      sprintf_vma (buf, section->vma + addr_offset);
d1426 1
a1426 1
		  sprintf_vma (buf, section->vma + j / opb);
d1953 1
a1953 1
      printf_vma (value);
d2037 1
a2037 1
  printf_vma (abfd->start_address);
d2486 1
a2486 1
	sprintf_vma (buf, (bfd_vma) -1);
d2554 1
a2554 1
	  printf_vma (q->address);
d2566 1
a2566 1
	  printf_vma (q->address);
d2574 1
a2574 1
	  printf_vma (q->addend);
@


1.38
log
@2001-08-03  John Healy  <jhealy@@redhat.com>

        Patch suggested by Frank Eigler <fche@@redhat.com>.
        * objdump.c (disassemble_data): Fill in section member of the
        disasm_info structure.
@
text
@d111 47
a157 107
static void
usage PARAMS ((FILE *, int));

static void
nonfatal PARAMS ((const char *));

static void
display_file PARAMS ((char *filename, char *target));

static void
dump_section_header PARAMS ((bfd *, asection *, PTR));

static void
dump_headers PARAMS ((bfd *));

static void
dump_data PARAMS ((bfd *abfd));

static void
dump_relocs PARAMS ((bfd *abfd));

static void
dump_dynamic_relocs PARAMS ((bfd * abfd));

static void
dump_reloc_set PARAMS ((bfd *, asection *, arelent **, long));

static void
dump_symbols PARAMS ((bfd *abfd, boolean dynamic));

static void
dump_bfd_header PARAMS ((bfd *));

static void
dump_bfd_private_header PARAMS ((bfd *));

static void
display_bfd PARAMS ((bfd *abfd));

static void
display_target_list PARAMS ((void));

static void
display_info_table PARAMS ((int, int));

static void
display_target_tables PARAMS ((void));

static void
display_info PARAMS ((void));

static void
objdump_print_value PARAMS ((bfd_vma, struct disassemble_info *, boolean));

static void
objdump_print_symname PARAMS ((bfd *, struct disassemble_info *, asymbol *));

static asymbol *
find_symbol_for_address PARAMS ((bfd *, asection *, bfd_vma, boolean, long *));

static void
objdump_print_addr_with_sym PARAMS ((bfd *, asection *, asymbol *, bfd_vma,
				     struct disassemble_info *, boolean));

static void
objdump_print_addr PARAMS ((bfd_vma, struct disassemble_info *, boolean));

static void
objdump_print_address PARAMS ((bfd_vma, struct disassemble_info *));

static void
show_line PARAMS ((bfd *, asection *, bfd_vma));

static void
disassemble_bytes PARAMS ((struct disassemble_info *, disassembler_ftype,
			   boolean, bfd_byte *, bfd_vma, bfd_vma,
			   arelent ***, arelent **));

static void
disassemble_data PARAMS ((bfd *));

static const char *
endian_string PARAMS ((enum bfd_endian));

static asymbol **
slurp_symtab PARAMS ((bfd *));

static asymbol **
slurp_dynamic_symtab PARAMS ((bfd *));

static long
remove_useless_symbols PARAMS ((asymbol **, long));

static int
compare_symbols PARAMS ((const PTR, const PTR));

static int
compare_relocs PARAMS ((const PTR, const PTR));

static void
dump_stabs PARAMS ((bfd *));

static boolean
read_section_stabs PARAMS ((bfd *, const char *, const char *));

static void
print_section_stabs PARAMS ((bfd *, const char *, const char *));
@


1.37
log
@	* bucomm.c (list_supported_architectures): New function.
	* bucomm.h (list_supported_architectures): Declare.
	* objdump.c (usage): Call the above.
@
text
@d1739 1
@


1.36
log
@2001-07-25  Dave Brolley  <brolley@@redhat.com>

	* objdump.c (SKIP_ZEROES): Only define it if it is not already defined.
	(SKIP_ZEROES_AT_END): Only define it if it is not already defined.
@
text
@d271 1
@


1.35
log
@Remove section VMA adjustment when computing the address of the line to show.
@
text
@d1225 1
d1227 1
d1236 1
d1238 1
@


1.34
log
@Fix typos in ChangeLogs and update copyright notices
@
text
@d1331 4
a1334 1
	    show_line (aux->abfd, section, addr_offset);
@


1.33
log
@Change bfd_target_vector from an array to a pointer
@
text
@d2 2
a3 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
@


1.32
log
@Add OBJDUMP_DEFS to configure and makefile
Check for DISASSEMBLER_NEEDS_RELOCS in objdump and read in relocs if set.
@
text
@d2647 1
a2647 1
  extern bfd_target *bfd_target_vector[];
d2654 1
a2654 1
      bfd_target *p = bfd_target_vector[t];
d2695 1
a2695 1
  extern bfd_target *bfd_target_vector[];
d2713 1
a2713 1
	    bfd_target *p = bfd_target_vector[t];
d2764 1
a2764 1
  extern bfd_target *bfd_target_vector[];
@


1.32.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 2
   Copyright 1990, 1991, 1992, 1993, 1994, 1995, 1996, 1997, 1998, 1999,
   2000, 2001
@


1.32.2.2
log
@Merge from mainline.
@
text
@d2648 1
a2648 1
  extern const bfd_target *const *bfd_target_vector;
d2655 1
a2655 1
      const bfd_target *p = bfd_target_vector[t];
d2696 1
a2696 1
  extern const bfd_target *const *bfd_target_vector;
d2714 1
a2714 1
	    const bfd_target *p = bfd_target_vector[t];
d2765 1
a2765 1
  extern const bfd_target *const *bfd_target_vector;
@


1.31
log
@2000-08-17  Christopher C. Chimelis <chris@@debian.org>

	* objdump.c (LONGEST_ARCH): Set to sizeof("powerpc:common").
@
text
@d1361 1
d1366 1
a1366 1
		  && (**relppp)->address < addr_offset + octets / opb)
d1369 1
d1509 5
a1513 2
      if (dump_reloc_info
	  && (section->flags & SEC_RELOC) != 0)
d1518 5
d1678 5
a1682 2
      if (dump_reloc_info
	  && (section->flags & SEC_RELOC) != 0)
@


1.30
log
@Add optional style argument to --demangle switch.
@
text
@d2614 1
a2614 1
#define LONGEST_ARCH sizeof("rs6000:6000")
@


1.29
log
@* objdump.c (usage): Make output of `objdump --help' more
consistent with the rest of the GNU world.  Add a line describing
the purpose of the program.
@
text
@d258 3
a260 1
  -C, --demangle                 Decode mangled/processed symbol names\n\
d293 1
a293 1
  {"demangle", no_argument, NULL, 'C'},
d2838 11
@


1.28
log
@Fix description of --stabs switch
@
text
@d223 3
a225 2
  fprintf (stream, _("Usage: %s <switches> file(s)\n"), program_name);
  fprintf (stream, _(" At least one of the following switches must be given:\n"));
d227 18
a244 18
  -a  --archive-headers    Display archive header information\n\
  -f  --file-headers       Display the contents of the overall file header\n\
  -p  --private-headers    Display object format specific file header contents\n\
  -h  --[section-]headers  Display the contents of the section headers\n\
  -x  --all-headers        Display the contents of all headers\n\
  -d  --disassemble        Display assembler contents of executable sections\n\
  -D  --disassemble-all    Display assembler contents of all sections\n\
  -S  --source             Intermix source code with disassembly\n\
  -s  --full-contents      Display the full contents of all sections requested\n\
  -g  --debugging          Display debug information in object file\n\
  -G  --stabs              Display (in raw form) any STABS info in the file\n\
  -t  --syms               Display the contents of the symbol table(s)\n\
  -T  --dynamic-syms       Display the contents of the dynamic symbol table\n\
  -r  --reloc              Display the relocation entries in the file\n\
  -R  --dynamic-reloc      Display the dynamic relocation entries in the file\n\
  -V  --version            Display this program's version number\n\
  -i  --info               List object formats and architectures supported\n\
  -H  --help               Display this information\n\
d250 4
a253 4
  -b  --target <bfdname>         Specify the target object format as <bfdname>\n\
  -m  --architecture <machine>   Specify the target architecture as <machine>\n\
  -j  --section <name>           Only display information for section <name>\n\
  -M  --disassembler-options <o> Pass text <o> on to the disassembler\n\
d257 6
a262 6
  -l  --line-numbers             Include line numbers and filenames in output\n\
  -C  --demangle                 Decode mangled/processed symbol names\n\
  -w  --wide                     Format output for more than 80 columns\n\
  -z  --disassemble-zeroes       Do not skip blocks of zeroes when disassembling\n\
      --start-address <addr>     Only process data whoes address is >= <addr>\n\
      --stop-address <addr>      Only process data whoes address is <= <addr>\n\
d265 1
a265 1
      --adjust-vma <offset>      Add <offset> to all displayed section addresses\n\
d268 1
a268 1
      
d272 1
a272 1
    fprintf (stream, _("Report bugs to %s\n"), REPORT_BUGS_TO);
@


1.27
log
@Fix my inept 2000-05-24 change.
@
text
@d236 1
a236 1
  -G  --stabs              Display the STABS contents of an ELF format file\n\
@


1.26
log
@Ensure bfd_close after bfd_openw so we don't get multiple bfd_openw
calls for same file.
@
text
@d2656 1
a2656 1
	  bfd_close (abfd);
d2664 1
a2664 1
      bfd_close (abfd);
d2733 1
a2733 1
	      bfd_close (abfd);
@


1.25
log
@2000-05-12  H.J. Lu  <hjl@@gnu.org>

	* nlmconv.c (temp_filename): Removed.

	* nlmconv.c (link_inputs): Use make_temp_file () instead of
	choose_temp_base ().
	* objdump.c (display_target_list): Likewise.
	(display_info_table): Likewise.
@
text
@d2656 1
d2664 1
d2732 2
@


1.24
log
@Fix bug disassmbling binary files for non-octet byte targets.
@
text
@d2635 1
a2635 1
  dummy_name = choose_temp_base ();
d2687 1
a2687 1
  dummy_name = choose_temp_base ();
@


1.23
log
@Portability fixes.
@
text
@d1575 1
a1575 1
  unsigned int opb = bfd_octets_per_byte (abfd);
a1596 1
  disasm_info.octets_per_byte = opb;
d1627 2
d1633 1
@


1.22
log
@A mostly cosmetic tidy up of warnings and error message reporting.
@
text
@a31 6
#ifdef ANSI_PROTOTYPES
#include <stdarg.h>
#else
#include <varargs.h>
#endif

@


1.21
log
@SEC_BLOCK, SEC_CLINK, and C_STATLAB added (TI COFF support).
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 1999
d446 1
a446 1
      fprintf (stderr, _("%s: no symbols\n"), bfd_get_filename (abfd));
d463 1
a463 1
    fprintf (stderr, _("%s: no symbols\n"), bfd_get_filename (abfd));
d481 1
a481 2
	  fprintf (stderr, _("%s: %s: not a dynamic object\n"),
		   program_name, bfd_get_filename (abfd));
d497 1
a497 2
    fprintf (stderr, _("%s: %s: No dynamic symbols\n"),
	     program_name, bfd_get_filename (abfd));
d1200 1
a1200 2
      fprintf (stderr, _("Out of virtual memory\n"));
      exit (1);
d1610 1
a1610 4
	  fprintf (stderr, _("%s: Can't use supplied machine %s\n"),
		   program_name,
		   machine);
	  exit (1);
d1628 2
a1629 3
      fprintf (stderr, _("%s: Can't disassemble for architecture %s\n"),
	       program_name,
	       bfd_printable_arch_mach (bfd_get_arch (abfd), 0));
d1885 2
a1886 2
      fprintf (stderr, _("%s: %s has no %s section\n"), program_name,
	       bfd_get_filename (abfd), strsect_name);
d1899 3
a1901 3
      fprintf (stderr, _("%s: Reading %s section of %s failed: %s\n"),
	       program_name, stabsect_name, bfd_get_filename (abfd),
	       bfd_errmsg (bfd_get_error ()));
d1911 3
a1913 3
      fprintf (stderr, _("%s: Reading %s section of %s failed: %s\n"),
	       program_name, strsect_name, bfd_get_filename (abfd),
	       bfd_errmsg (bfd_get_error ()));
d2144 2
a2145 3
	      fprintf (stderr,
		       _("%s: printing debugging information failed\n"),
		       bfd_get_filename (abfd));
d2855 1
a2855 2
	      fprintf (stderr, _("%s: unrecognized -E option\n"),
		       program_name);
d2866 1
a2866 2
	      fprintf (stderr, _("%s: unrecognized --endian type `%s'\n"),
		      program_name, optarg);
@


1.20
log
@Move translated part of bug report string back into .c files so
xgettext can find it.  Regnerate .pot files.
@
text
@d379 2
@


1.19
log
@Move bug report string to one place.
@
text
@d277 1
a277 1
    fprintf (stream, REPORT_BUGS_TO);
@


1.18
log
@This lot mainly cleans up `comparison between signed and unsigned' gcc
warnings.  One usused var, and a macro parenthesis fix too.  Also check
input sections are elf when doing gc in elflink.h.
@
text
@d277 1
a277 1
    fprintf (stream, _("Report bugs to bug-gnu-utils@@gnu.org\n"));
@


1.18.2.1
log
@This is a grab-bag of my stuff from the head branch.
Should have done it separately, I know.
- move bug report address to include file
- objcopy --redefine-sym
- update makefile dependencies (but use automake-000227)
- H.J. Lu's fix to readelf.c
@
text
@d277 1
a277 1
    fprintf (stream, _("Report bugs to %s\n"), REPORT_BUGS_TO);
@


1.18.2.2
log
@A mostly cosmetic tidy up of warnings and error message reporting.
@
text
@d2 1
a2 1
   Copyright 1990, 91, 92, 93, 94, 95, 96, 97, 98, 99, 2000
d444 1
a444 1
      non_fatal (_("%s: no symbols"), bfd_get_filename (abfd));
d461 1
a461 1
    non_fatal (_("%s: no symbols"), bfd_get_filename (abfd));
d479 2
a480 1
	  non_fatal (_("%s: not a dynamic object"), bfd_get_filename (abfd));
d496 2
a497 1
    non_fatal (_("%s: No dynamic symbols"), bfd_get_filename (abfd));
d1200 2
a1201 1
      fatal (_("Out of virtual memory"));
d1611 4
a1614 1
	  fatal (_("Can't use supplied machine %s"), machine);
d1632 3
a1634 2
      non_fatal (_("Can't disassemble for architecture %s\n"),
		 bfd_printable_arch_mach (bfd_get_arch (abfd), 0));
d1890 2
a1891 2
      non_fatal (_("%s has no %s section"),
		 bfd_get_filename (abfd), strsect_name);
d1904 3
a1906 3
      non_fatal (_("Reading %s section of %s failed: %s"),
		 stabsect_name, bfd_get_filename (abfd),
		 bfd_errmsg (bfd_get_error ()));
d1916 3
a1918 3
      non_fatal (_("Reading %s section of %s failed: %s\n"),
		 strsect_name, bfd_get_filename (abfd),
		 bfd_errmsg (bfd_get_error ()));
d2149 3
a2151 2
	      non_fatal (_("%s: printing debugging information failed"),
			 bfd_get_filename (abfd));
d2861 2
a2862 1
	      non_fatal (_("unrecognized -E option"));
d2873 2
a2874 1
	      non_fatal (_("unrecognized --endian type `%s'"), optarg);
@


1.18.2.3
log
@Fix bug selecting octets per byte value when loading binary files.
@
text
@d1579 1
a1579 1
  unsigned int opb;
d1601 1
a1631 2
  opb = bfd_octets_per_byte (abfd);

a1635 1
  disasm_info.octets_per_byte = opb;
@


1.18.2.4
log
@2000-04-14  Michael Sokolov  <msokolov@@ivan.Harhan.ORG>

	* arlex.l: Add directives to increase lex buffer size.

	* objdump.c, readelf.c: Don't include strarg.h or varargs.h. They are
        already included by bucomm.h.
@
text
@d32 6
@


1.18.2.5
log
@Ensure bfd_close after bfd_openw so we don't get multiple bfd_openw
calls for same file.
@
text
@a2653 1
	  bfd_close (abfd);
a2660 1
      bfd_close (abfd);
a2727 2
	    if (abfd != NULL)
	      bfd_close (abfd);
@


1.18.2.6
log
@Fix my inept 2000-05-24 change.
@
text
@d2654 1
a2654 1
	  bfd_close_all_done (abfd);
d2662 1
a2662 1
      bfd_close_all_done (abfd);
d2731 1
a2731 1
	      bfd_close_all_done (abfd);
@


1.18.2.7
log
@Merge changes from mainline
@
text
@d223 2
a224 3
  fprintf (stream, _("Usage: %s OPTION... FILE...\n"), program_name);
  fprintf (stream, _("Display information from object FILE.\n"));
  fprintf (stream, _("\n At least one of the following switches must be given:\n"));
d226 18
a243 18
  -a, --archive-headers    Display archive header information\n\
  -f, --file-headers       Display the contents of the overall file header\n\
  -p, --private-headers    Display object format specific file header contents\n\
  -h, --[section-]headers  Display the contents of the section headers\n\
  -x, --all-headers        Display the contents of all headers\n\
  -d, --disassemble        Display assembler contents of executable sections\n\
  -D, --disassemble-all    Display assembler contents of all sections\n\
  -S, --source             Intermix source code with disassembly\n\
  -s, --full-contents      Display the full contents of all sections requested\n\
  -g, --debugging          Display debug information in object file\n\
  -G, --stabs              Display (in raw form) any STABS info in the file\n\
  -t, --syms               Display the contents of the symbol table(s)\n\
  -T, --dynamic-syms       Display the contents of the dynamic symbol table\n\
  -r, --reloc              Display the relocation entries in the file\n\
  -R, --dynamic-reloc      Display the dynamic relocation entries in the file\n\
  -V, --version            Display this program's version number\n\
  -i, --info               List object formats and architectures supported\n\
  -H, --help               Display this information\n\
d249 4
a252 4
  -b, --target=BFDNAME           Specify the target object format as BFDNAME\n\
  -m, --architecture=MACHINE     Specify the target architecture as MACHINE\n\
  -j, --section=NAME             Only display information for section NAME\n\
  -M, --disassembler-options=OPT Pass text OPT on to the disassembler\n\
d256 6
a261 6
  -l, --line-numbers             Include line numbers and filenames in output\n\
  -C, --demangle                 Decode mangled/processed symbol names\n\
  -w, --wide                     Format output for more than 80 columns\n\
  -z, --disassemble-zeroes       Do not skip blocks of zeroes when disassembling\n\
      --start-address=ADDR       Only process data whoes address is >= ADDR\n\
      --stop-address=ADDR        Only process data whoes address is <= ADDR\n\
d264 1
a264 1
      --adjust-vma=OFFSET        Add OFFSET to all displayed section addresses\n\
d267 1
a267 1

d271 1
a271 1
    fprintf (stream, _("Report bugs to %s.\n"), REPORT_BUGS_TO);
d2609 1
a2609 1
#define LONGEST_ARCH sizeof("powerpc:common")
@


1.17
log
@Fix bug in interlisting option, added --file-start-context option.
@
text
@d343 1
a343 1
  int opb = bfd_octets_per_byte (abfd);
d746 1
a746 1
  int opb = bfd_octets_per_byte (abfd); 
d1577 1
a1577 1
  long addr_offset;
d1582 1
a1582 1
  int opb = bfd_octets_per_byte (abfd);
d1662 1
a1662 1
      long stop_offset;
d1746 1
a1746 1
	  long nextstop_offset;
d2267 1
a2267 1
  int opb = bfd_octets_per_byte (abfd);
@


1.16
log
@octets vs bytes changes for binutils
@
text
@d78 1
d261 1
d305 1
d1082 2
a1083 2
		  if (l <= 0)
		    l = 1;
d1133 6
a1138 3
	      l = line - SHOW_PRECEDING_CONTEXT_LINES;
	      if (l <= 0)
		l = 1;
@


1.15
log
@Add support for documenting target specific disassembler options
@
text
@d340 1
d344 1
a344 1
	  (unsigned long) bfd_section_size (abfd, section));
d743 1
d791 1
a791 1
			+ bfd_section_size (abfd, sec)))))
d1015 1
a1015 1
show_line (abfd, section, off)
d1018 1
a1018 1
     bfd_vma off;
d1027 1
a1027 1
  if (! bfd_find_nearest_line (abfd, section, syms, off, &filename,
d1236 2
a1237 1
disassemble_bytes (info, disassemble_fn, insns, data, start, stop, relppp,
d1243 2
a1244 2
     bfd_vma start;
     bfd_vma stop;
d1250 1
a1250 1
  int bytes_per_line;
d1253 2
a1254 1
  bfd_vma i;
d1260 1
a1260 1
    bytes_per_line = 4;
d1262 1
a1262 1
    bytes_per_line = 16;
d1274 2
a1275 2
      sprintf_vma (buf,
		   section->vma + bfd_section_size (section->owner, section));
d1288 2
a1289 2
  i = start;
  while (i < stop)
d1292 1
a1292 1
      int bytes = 0;
d1295 1
a1295 1
      /* If we see more than SKIP_ZEROES bytes of zeroes, we just
d1297 1
a1297 1
      for (z = i; z < stop; z++)
d1303 3
a1305 2
	  && (z - i >= SKIP_ZEROES
	      || (z == stop && z - i < SKIP_ZEROES_AT_END)))
d1309 1
a1309 1
	  /* If there are more nonzero bytes to follow, we only skip
d1313 2
a1314 2
	  if (z != stop)
	    z = i + ((z - i) &~ 3);
d1316 1
a1316 1
	  bytes = z - i;
d1328 1
a1328 1
	    show_line (aux->abfd, section, i);
d1334 1
a1334 1
	      sprintf_vma (buf, section->vma + i);
d1344 1
a1344 1
	      objdump_print_address (section->vma + i, info);
d1359 1
a1359 1
	      /* FIXME: This is wrong.  It tests the number of bytes
d1362 2
a1363 2
		  && (**relppp)->address >= i
		  && (**relppp)->address < i + bytes)
d1368 1
a1368 1
	      bytes = (*disassemble_fn) (section->vma + i, info);
d1372 2
a1373 2
		bytes_per_line = info->bytes_per_line;
	      if (bytes < 0)
d1385 3
a1387 3
	      bytes = bytes_per_line;
	      if (i + bytes > stop)
		bytes = stop - i;
d1389 1
a1389 1
	      for (j = i; j < i + bytes; ++j)
d1392 1
a1392 1
		    buf[j - i] = data[j];
d1394 1
a1394 1
		    buf[j - i] = '.';
d1396 1
a1396 1
	      buf[j - i] = '\0';
d1406 4
a1409 4
                 bytes_per_line bytes per line.  */
	      pb = bytes;
	      if (pb > bytes_per_line && ! prefix_addresses && ! wide_output)
		pb = bytes_per_line;
d1416 1
a1416 1
	      for (j = i; j < i + pb; j += bpc)
d1433 1
a1433 1
	      for (; pb < bytes_per_line; pb += bpc)
d1461 1
a1461 1
	      while (pb < bytes)
d1467 1
a1467 1
		  j = i + pb;
d1469 1
a1469 1
		  sprintf_vma (buf, section->vma + j);
d1476 4
a1479 4
		  pb += bytes_per_line;
		  if (pb > bytes)
		    pb = bytes;
		  for (; j < i + pb; j += bpc)
d1509 2
a1510 2
		 && ((**relppp)->address >= (bfd_vma) i
		     && (**relppp)->address < (bfd_vma) i + bytes))
d1561 1
a1561 1
      i += bytes;
d1571 1
a1571 1
  long i;
d1576 1
d1598 1
d1656 1
a1656 1
      long stop;
d1719 1
a1719 1
	i = 0;
d1721 1
a1721 1
	i = start_address - disasm_info.buffer_vma;
d1723 1
a1723 1
	stop = datasize;
d1727 1
a1727 1
	    stop = 0;
d1729 3
a1731 3
	    stop = stop_address - disasm_info.buffer_vma;
	  if (stop > disasm_info.buffer_length)
	    stop = disasm_info.buffer_length;
d1734 1
a1734 1
      sym = find_symbol_for_address (abfd, section, section->vma + i,
d1737 1
a1737 1
      while (i < stop)
d1740 1
a1740 1
	  long nextstop;
d1743 1
a1743 1
	  if (sym != NULL && bfd_asymbol_value (sym) <= section->vma + i)
d1749 1
a1749 1
		    && bfd_asymbol_value (sorted_syms[x]) <= section->vma + i);
d1762 1
a1762 1
					   section->vma + i,
d1768 1
a1768 1
	  if (sym != NULL && bfd_asymbol_value (sym) > section->vma + i)
d1789 1
a1789 1
	  if (sym != NULL && bfd_asymbol_value (sym) > section->vma + i)
d1791 3
a1793 3
	      nextstop = bfd_asymbol_value (sym) - section->vma;
	      if (nextstop > stop)
		nextstop = stop;
d1796 1
a1796 1
	    nextstop = stop;
d1799 3
a1801 3
	      nextstop = bfd_asymbol_value (nextsym) - section->vma;
	      if (nextstop > stop)
		nextstop = stop;
d1809 1
a1809 1
	      || bfd_asymbol_value (sym) > section->vma + i
d1820 2
a1821 2
	  disassemble_bytes (&disasm_info, disassemble_fn, insns, data, i,
			     nextstop, &relpp, relppend);
d1823 1
a1823 1
	  i = nextstop;
d2259 3
a2261 2
  bfd_size_type i;
  bfd_size_type start, stop;
d2285 1
a2285 1
		start = 0;
d2287 1
a2287 1
		start = start_address - section->vma;
d2289 1
a2289 1
		stop = bfd_section_size (abfd, section);
d2293 1
a2293 1
		    stop = 0;
d2295 3
a2297 3
		    stop = stop_address - section->vma;
		  if (stop > bfd_section_size (abfd, section))
		    stop = bfd_section_size (abfd, section);
d2299 2
a2300 1
	      for (i = start; i < stop; i += onaline)
d2304 4
a2307 2
		  printf (" %04lx ", (unsigned long int) (i + section->vma));
		  for (j = i; j < i + onaline; j++)
d2309 1
a2309 1
		      if (j < stop)
d2318 1
a2318 1
		  for (j = i; j < i + onaline; j++)
d2320 1
a2320 1
		      if (j >= stop)
@


1.14
log
@Overhaul --help output
@
text
@d271 2
@


1.13
log
@1999-10-27  Fred Fish  <fnf@@cygnus.com>

	* objdump.c (display_bfd): Break into two functions.  The
	actual dumping code moves to dump_bfd.  If bfd is not
	unambiguously recognized as a bfd_object, attempt to dump
	it as a bfd_core.
	(dump_bfd): New function.
@
text
@d228 2
d231 41
a271 16
Usage: %s [-ahifCdDprRtTxsSlw] [-b bfdname] [-m machine] \n\
       [-j section-name] [-M disassembler-options]\n\
       [--archive-headers] [--target=bfdname] [--debugging] [--disassemble]\n\
       [--disassemble-all] [--disassemble-zeroes] [--file-headers]\n\
       [--section-headers] [--headers]\n\
       [--info] [--section=section-name] [--line-numbers] [--source]\n"),
	   program_name);
  fprintf (stream, _("\
       [--architecture=machine] [--reloc] [--full-contents] [--stabs]\n\
       [--syms] [--all-headers] [--dynamic-syms] [--dynamic-reloc]\n\
       [--wide] [--version] [--help] [--private-headers]\n\
       [--start-address=addr] [--stop-address=addr]\n\
       [--prefix-addresses] [--[no-]show-raw-insn] [--demangle]\n\
       [--adjust-vma=offset] [-EB|-EL] [--endian={big|little}] objfile...\n\
at least one option besides -l (--line-numbers) must be given\n"));
  list_supported_targets (program_name, stream);
d291 2
a292 2
  {"debugging", no_argument, &dump_debugging, 1},
  {"demangle", no_argument, &do_demangle, 1},
d296 1
a296 1
  {"disassemble-zeroes", no_argument, &disassemble_zeroes, 1},
d313 1
a313 1
  {"stabs", no_argument, &dump_stab_section_info, 1},
d318 2
a319 2
  {"version", no_argument, &show_version, 1},
  {"wide", no_argument, &wide_output, 'w'},
d2797 1
a2797 1
  while ((c = getopt_long (argc, argv, "pib:m:M:VCdDlfahrRtTxsSj:wE:",
a2800 2
      if (c != 'l' && c != OPTION_START_ADDRESS && c != OPTION_STOP_ADDRESS)
	seenflag = true;
d2815 1
a2815 1
	  with_line_numbers = 1;
d2820 40
d2862 1
d2866 1
d2869 2
a2870 1
	  dump_private_headers = 1;
d2873 3
a2875 3
	  dump_private_headers = 1;
	  dump_symtab = 1;
	  dump_reloc_info = 1;
d2877 3
a2879 2
	  dump_ar_hdrs = 1;
	  dump_section_headers = 1;
d2882 2
a2883 1
	  dump_symtab = 1;
d2886 2
a2887 4
	  dump_dynamic_symtab = 1;
	  break;
	case 'C':
	  do_demangle = 1;
d2891 4
d2897 3
a2899 1
	  disassemble = disassemble_all = true;
d2904 9
d2915 2
a2916 1
	  dump_section_contents = 1;
d2919 2
a2920 1
	  dump_reloc_info = 1;
d2923 2
a2924 1
	  dump_dynamic_reloc_info = 1;
d2927 2
a2928 1
	  dump_ar_hdrs = 1;
d2931 2
a2932 1
	  dump_section_headers = 1;
d2936 1
d2938 2
a2939 37
	  show_version = 1;
	  break;
	case 'w':
	  wide_output = 1;
	  break;
	case OPTION_ADJUST_VMA:
	  adjust_section_vma = parse_vma (optarg, "--adjust-vma");
	  break;
	case OPTION_START_ADDRESS:
	  start_address = parse_vma (optarg, "--start-address");
	  break;
	case OPTION_STOP_ADDRESS:
	  stop_address = parse_vma (optarg, "--stop-address");
	  break;
	case 'E':
	  if (strcmp (optarg, "B") == 0)
	    endian = BFD_ENDIAN_BIG;
	  else if (strcmp (optarg, "L") == 0)
	    endian = BFD_ENDIAN_LITTLE;
	  else
	    {
	      fprintf (stderr, _("%s: unrecognized -E option\n"),
		       program_name);
	      usage (stderr, 1);
	    }
	  break;
	case OPTION_ENDIAN:
	  if (strncmp (optarg, "big", strlen (optarg)) == 0)
	    endian = BFD_ENDIAN_BIG;
	  else if (strncmp (optarg, "little", strlen (optarg)) == 0)
	    endian = BFD_ENDIAN_LITTLE;
	  else
	    {
	      fprintf (stderr, _("%s: unrecognized --endian type `%s'\n"),
		      program_name, optarg);
	      usage (stderr, 1);
	    }
d2941 1
d2951 1
a2951 1
    usage (stderr, 1);
d2954 1
a2954 3
    {
      display_info ();
    }
@


1.12
log
@comment fix
@
text
@d2045 2
d2048 1
a2048 1
display_bfd (abfd)
a2050 13
  char **matching;

  if (!bfd_check_format_matches (abfd, bfd_object, &matching))
    {
      nonfatal (bfd_get_filename (abfd));
      if (bfd_get_error () == bfd_error_file_ambiguously_recognized)
	{
	  list_matching_formats (matching);
	  free (matching);
	}
      return;
    }

d2123 41
@


1.11
log
@1999-09-12  Donn Terry  <donn@@interix.com>

	* objdump.c (dump_headers): If wide_output, print Flags header.
@
text
@d1738 4
a1742 1
		     /* ??? Why the test for != section?  */
@


1.10
log
@1999-09-12  Donn Terry  <donn@@interix.com>

	* objdump.c (dump_section_header): Print any comdat information.
@
text
@d388 1
d390 1
a390 1
  printf (_("Idx Name          Size      VMA       LMA       File off  Algn\n"));
d392 1
a392 1
  printf (_("Idx Name          Size      VMA               LMA               File off  Algn\n"));
d394 5
@


1.9
log
@	* objdump.c (exit_status): New static variable.
	(nonfatal): New static function.
	(disassemble_data): Set exit_status on error.
	(read_section_stabs): Likewise.
	(display_bfd): Likewise.  Call nonfatal rather than bfd_nonfatal.
	(display_file): Call nonfatal rather than bfd_nonfatal.
	(display_target_list, display_info_table): Likewise.
	(main): Return exit_status rather than 0.
@
text
@d371 5
@


1.8
log
@	* objdump.c (dump_section_header): Update for renaming of
	SEC_SHORT to SEC_SMALL_DATA.  Print SEC_SHARED flag.
@
text
@d47 3
d119 3
d297 8
d1582 1
d1836 1
d1853 1
d1865 1
d2039 1
a2039 1
      bfd_nonfatal (bfd_get_filename (abfd));
d2103 6
a2108 2
	    fprintf (stderr, _("%s: printing debugging information failed\n"),
		     bfd_get_filename (abfd));
d2133 1
a2133 1
      bfd_nonfatal (filename);
d2150 1
a2150 3
		{
		  bfd_nonfatal (bfd_get_filename (file));
		}
d2568 1
a2568 1
	  bfd_nonfatal (dummy_name);
d2575 1
a2575 1
	    bfd_nonfatal (p->name);
d2621 1
a2621 1
		bfd_nonfatal (p->name);
d2630 1
a2630 1
		      bfd_nonfatal (p->name);
d2826 2
a2827 1
	      fprintf (stderr, _("%s: unrecognized -E option\n"), program_name);
d2869 1
a2869 1
  return 0;
@


1.7
log
@        * objdump.c (dump_section_header): Print SEC_SHORT.
@
text
@d332 2
a333 1
  PF (SEC_SHORT, "SHORT");
@


1.6
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Add variable initializations.  Add casts.
	* objdump.c (disassemble_bytes): Change j to bfd_vma.
	* readelf.c (process_syminfo): Change i to unsigned int.
	(display_debug_info): Change abbrev_number to unsigned long.
	(process_mips_specific): Change fcnt to size_t.
@
text
@d332 1
@


1.5
log
@Add -M command line switch to objdump - text of switch is passed on to disassembler
Add support for register name set selection ot ARM disassembler.
@
text
@d292 1
a292 1
     bfd *abfd;
d294 1
a294 1
     PTR ignored;
d1142 1
a1142 1
  while ((f->buffer + f->size) - f->current < n + 1)
d1322 1
a1322 1
	      long j;
d1342 1
a1342 1
	      long j;
d1402 1
a1402 1
		  long j;
d1874 1
a1874 1
     const char *strsect_name;
d2230 1
a2230 1
     bfd *abfd;
@


1.4
log
@	* objdump.c (disassemble_bytes): If the disassembler returns an
	error, print out anything it may have printed to the buffer.  From
	H.J. Lu <hjl@@gnu.org>.
@
text
@d86 3
d223 2
a224 1
Usage: %s [-ahifCdDprRtTxsSlw] [-b bfdname] [-m machine] [-j section-name]\n\
d262 1
d1572 2
d2704 1
a2704 1
  while ((c = getopt_long (argc, argv, "pib:m:VCdDlfahrRtTxsSj:wE:",
d2716 3
@


1.3
log
@1999-05-10  DJ Delorie  <dj@@cygnus.com>
	* windres.c (quot): Quote shell metacharacters in a string
	(main): quote parameters to cpp that might have metacharacters in
	them.  Allow -D as an alias for --define to allow for sharing make
	macros with gcc.
	* objdump.c (dump_reloc_set): don't core if howto->name is NULL
	* Makefile.am: Give rescoff.c a cpu-specific -D so it can set
	the correct BFD.
	* Makefile.in: ditto
	* rescoff.c (write_coff_file): Set the correct BFD
@
text
@d1308 6
a1313 1
		break;
@


1.2
log
@Set display_endian based on target endianism.
@
text
@d2471 4
a2474 1
	  printf (" %-16s  ", q->howto->name);
@


1.1
log
@Initial revision
@
text
@d1563 1
a1563 1
    disasm_info.endian = BFD_ENDIAN_BIG;
d1565 1
a1565 1
    disasm_info.endian = BFD_ENDIAN_LITTLE;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

