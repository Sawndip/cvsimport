head	1.17;
access;
symbols
	binutils-2_24-branch:1.16.0.2
	binutils-2_24-branchpoint:1.16
	binutils-2_21_1:1.14
	binutils-2_23_2:1.15
	binutils-2_23_1:1.15
	binutils-2_23:1.15
	binutils-2_23-branch:1.15.0.2
	binutils-2_23-branchpoint:1.15
	binutils-2_22_branch:1.14.0.8
	binutils-2_22:1.14
	binutils-2_22-branch:1.14.0.6
	binutils-2_22-branchpoint:1.14
	binutils-2_21:1.14
	binutils-2_21-branch:1.14.0.4
	binutils-2_21-branchpoint:1.14
	binutils-2_20_1:1.14
	binutils-2_20:1.14
	binutils-arc-20081103-branch:1.10.0.8
	binutils-arc-20081103-branchpoint:1.10
	binutils-2_20-branch:1.14.0.2
	binutils-2_20-branchpoint:1.14
	dje-cgen-play1-branch:1.13.0.2
	dje-cgen-play1-branchpoint:1.13
	arc-20081103-branch:1.10.0.6
	arc-20081103-branchpoint:1.10
	binutils-2_19_1:1.10
	binutils-2_19:1.10
	binutils-2_19-branch:1.10.0.4
	binutils-2_19-branchpoint:1.10
	binutils-2_18:1.10
	binutils-2_18-branch:1.10.0.2
	binutils-2_18-branchpoint:1.10
	binutils-csl-coldfire-4_1-32:1.5
	binutils-csl-sourcerygxx-4_1-32:1.5
	binutils-csl-innovasic-fido-3_4_4-33:1.5
	binutils-csl-sourcerygxx-3_4_4-32:1.3
	binutils-csl-coldfire-4_1-30:1.5
	binutils-csl-sourcerygxx-4_1-30:1.5
	binutils-csl-coldfire-4_1-28:1.5
	binutils-csl-sourcerygxx-4_1-29:1.5
	binutils-csl-sourcerygxx-4_1-28:1.5
	binutils-csl-arm-2006q3-27:1.5
	binutils-csl-sourcerygxx-4_1-27:1.5
	binutils-csl-arm-2006q3-26:1.5
	binutils-csl-sourcerygxx-4_1-26:1.5
	binutils-csl-sourcerygxx-4_1-25:1.5
	binutils-csl-sourcerygxx-4_1-24:1.5
	binutils-csl-sourcerygxx-4_1-23:1.5
	binutils-csl-sourcerygxx-4_1-21:1.5
	binutils-csl-arm-2006q3-21:1.5
	binutils-csl-sourcerygxx-4_1-22:1.5
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.5
	binutils-csl-sourcerygxx-4_1-20:1.5
	binutils-csl-arm-2006q3-19:1.5
	binutils-csl-sourcerygxx-4_1-19:1.5
	binutils-csl-sourcerygxx-4_1-18:1.5
	binutils-csl-renesas-4_1-9:1.5
	binutils-csl-sourcerygxx-3_4_4-25:1.3
	binutils-csl-renesas-4_1-8:1.5
	binutils-csl-renesas-4_1-7:1.5
	binutils-csl-renesas-4_1-6:1.5
	binutils-csl-sourcerygxx-4_1-17:1.5
	binutils-csl-sourcerygxx-4_1-14:1.5
	binutils-csl-sourcerygxx-4_1-15:1.5
	binutils-csl-sourcerygxx-4_1-13:1.5
	binutils-2_17:1.5
	binutils-csl-sourcerygxx-4_1-12:1.5
	binutils-csl-sourcerygxx-3_4_4-21:1.5
	binutils-csl-wrs-linux-3_4_4-24:1.3
	binutils-csl-wrs-linux-3_4_4-23:1.3
	binutils-csl-sourcerygxx-4_1-9:1.5
	binutils-csl-sourcerygxx-4_1-8:1.5
	binutils-csl-sourcerygxx-4_1-7:1.5
	binutils-csl-arm-2006q1-6:1.5
	binutils-csl-sourcerygxx-4_1-6:1.5
	binutils-csl-wrs-linux-3_4_4-22:1.3
	binutils-csl-coldfire-4_1-11:1.5
	binutils-csl-sourcerygxx-3_4_4-19:1.5
	binutils-csl-coldfire-4_1-10:1.5
	binutils-csl-sourcerygxx-4_1-5:1.5
	binutils-csl-sourcerygxx-4_1-4:1.5
	binutils-csl-wrs-linux-3_4_4-21:1.3
	binutils-csl-morpho-4_1-4:1.5
	binutils-csl-sourcerygxx-3_4_4-17:1.5
	binutils-csl-wrs-linux-3_4_4-20:1.3
	binutils-2_17-branch:1.5.0.4
	binutils-2_17-branchpoint:1.5
	binutils-csl-2_17-branch:1.5.0.2
	binutils-csl-2_17-branchpoint:1.5
	binutils-csl-gxxpro-3_4-branch:1.3.0.12
	binutils-csl-gxxpro-3_4-branchpoint:1.3
	binutils-2_16_1:1.3
	binutils-csl-arm-2005q1b:1.3
	binutils-2_16:1.3
	binutils-csl-arm-2005q1a:1.3
	binutils-csl-arm-2005q1-branch:1.3.0.10
	binutils-csl-arm-2005q1-branchpoint:1.3
	binutils-2_16-branch:1.3.0.8
	binutils-2_16-branchpoint:1.3
	csl-arm-2004-q3d:1.3
	csl-arm-2004-q3:1.3
	binutils-2_15:1.3
	binutils-2_15-branchpoint:1.3
	csl-arm-2004-q1a:1.3
	csl-arm-2004-q1:1.3
	binutils-2_15-branch:1.3.0.6
	cagney_bfdfile-20040213-branch:1.3.0.4
	cagney_bfdfile-20040213-branchpoint:1.3
	cagney_bigcore-20040122-branch:1.3.0.2
	cagney_bigcore-20040122-branchpoint:1.3
	csl-arm-2003-q4:1.3
	binutils-2_14:1.2
	binutils-2_14-branch:1.2.0.6
	binutils-2_14-branchpoint:1.2
	binutils-2_13_2_1:1.2
	binutils-2_13_2:1.2
	binutils-2_13_1:1.2
	binutils-2_13:1.2
	binutils-2_13-branchpoint:1.2
	binutils-2_13-branch:1.2.0.4
	binutils-2_12_1:1.2
	binutils-2_12:1.2
	binutils-2_12-branch:1.2.0.2
	binutils-2_12-branchpoint:1.2
	cygnus_cvs_20020108_pre:1.2
	binutils-2_11_2:1.1.1.1
	binutils-2_11_1:1.1.1.1
	binutils-2_11:1.1.1.1
	x86_64versiong3:1.1.1.1
	binutils-2_11-branch:1.1.1.1.0.4
	binutils-2_10_1:1.1.1.1
	binutils-2_10:1.1.1.1
	binutils-2_10-branch:1.1.1.1.0.2
	binutils-2_10-branchpoint:1.1.1.1
	binutils_latest_snapshot:1.17
	repo-unification-2000-02-06:1.1.1.1
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.17
date	2013.10.11.17.24.26;	author roland;	state Exp;
branches;
next	1.16;

1.16
date	2013.03.27.11.53.46;	author nickc;	state Exp;
branches
	1.16.2.1;
next	1.15;

1.15
date	2011.10.25.08.03.17;	author ktietz;	state Exp;
branches;
next	1.14;

1.14
date	2009.09.02.07.22.32;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2009.06.09.15.14.23;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2009.05.08.08.48.45;	author ktietz;	state Exp;
branches;
next	1.11;

1.11
date	2009.05.05.09.36.08;	author nickc;	state Exp;
branches;
next	1.10;

1.10
date	2007.07.05.16.54.45;	author nickc;	state Exp;
branches;
next	1.9;

1.9
date	2007.06.18.15.30.33;	author nickc;	state Exp;
branches;
next	1.8;

1.8
date	2007.06.05.13.10.29;	author nickc;	state Exp;
branches;
next	1.7;

1.7
date	2007.05.23.08.48.29;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2007.04.26.14.46.59;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2005.05.08.14.17.39;	author nickc;	state Exp;
branches;
next	1.4;

1.4
date	2005.03.24.21.26.21;	author dannysmith;	state Exp;
branches;
next	1.3;

1.3
date	2003.09.14.12.20.17;	author aj;	state Exp;
branches;
next	1.2;

1.2
date	2001.09.19.05.33.17;	author hjl;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.29.10;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.16.2.1
date	2013.10.11.17.25.06;	author roland;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.10;	author rth;	state Exp;
branches;
next	;


desc
@@


1.17
log
@binutils/
	* winduni.c (languages): Use \345 (octal syntax) rather than
	literal non-ASCII/non-UTF8 character in string literal.
@
text
@/* winduni.c -- unicode support for the windres program.
   Copyright 1997-2013 Free Software Foundation, Inc.
   Written by Ian Lance Taylor, Cygnus Support.
   Rewritten by Kai Tietz, Onevision.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */


/* This file contains unicode support routines for the windres
   program.  Ideally, we would have generic unicode support which
   would work on all systems.  However, we don't.  Instead, on a
   Windows host, we are prepared to call some Windows routines.  This
   means that we will generate different output on Windows and Unix
   hosts, but that seems better than not really supporting unicode at
   all.  */

#include "sysdep.h"
#include "bfd.h"
#include "libiberty.h" /* for xstrdup */
#include "bucomm.h"
/* Must be include before windows.h and winnls.h.  */
#if defined (_WIN32) || defined (__CYGWIN__)
#include <windows.h>
#include <winnls.h>
#endif
#include "winduni.h"
#include "safe-ctype.h"

#if HAVE_ICONV
#include <iconv.h>
#endif

static rc_uint_type wind_WideCharToMultiByte (rc_uint_type, const unichar *, char *, rc_uint_type);
static rc_uint_type wind_MultiByteToWideChar (rc_uint_type, const char *, unichar *, rc_uint_type);
static int unichar_isascii (const unichar *, rc_uint_type);

/* Convert an ASCII string to a unicode string.  We just copy it,
   expanding chars to shorts, rather than doing something intelligent.  */

#if !defined (_WIN32) && !defined (__CYGWIN__)

/* Codepages mapped.  */
static local_iconv_map codepages[] =
{
  { 0, "MS-ANSI" },
  { 1, "WINDOWS-1252" },
  { 437, "MS-ANSI" },
  { 737, "MS-GREEK" },
  { 775, "WINBALTRIM" },
  { 850, "MS-ANSI" },
  { 852, "MS-EE" },
  { 857, "MS-TURK" },
  { 862, "CP862" },
  { 864, "CP864" },
  { 866, "MS-CYRL" },
  { 874, "WINDOWS-874" },
  { 932, "CP932" },
  { 936, "CP936" },
  { 949, "CP949" },
  { 950, "CP950" },
  { 1250, "WINDOWS-1250" },
  { 1251, "WINDOWS-1251" },
  { 1252, "WINDOWS-1252" },
  { 1253, "WINDOWS-1253" },
  { 1254, "WINDOWS-1254" },
  { 1255, "WINDOWS-1255" },
  { 1256, "WINDOWS-1256" },
  { 1257, "WINDOWS-1257" },
  { 1258, "WINDOWS-1258" },
  { CP_UTF7, "UTF-7" },
  { CP_UTF8, "UTF-8" },
  { CP_UTF16, "UTF-16LE" },
  { (rc_uint_type) -1, NULL }
};

/* Languages supported.  */
static const wind_language_t languages[] =
{
  { 0x0000, 437, 1252, "Neutral", "Neutral" },
  { 0x0401, 864, 1256, "Arabic", "Saudi Arabia" },    { 0x0402, 866, 1251, "Bulgarian", "Bulgaria" },
  { 0x0403, 850, 1252, "Catalan", "Spain" },	      { 0x0404, 950,  950, "Chinese", "Taiwan" },
  { 0x0405, 852, 1250, "Czech", "Czech Republic" },   { 0x0406, 850, 1252, "Danish", "Denmark" },
  { 0x0407, 850, 1252, "German", "Germany" },	      { 0x0408, 737, 1253, "Greek", "Greece" },
  { 0x0409, 437, 1252, "English", "United States" },  { 0x040A, 850, 1252, "Spanish - Traditional Sort", "Spain" },
  { 0x040B, 850, 1252, "Finnish", "Finland" },	      { 0x040C, 850, 1252, "French", "France" },
  { 0x040D, 862, 1255, "Hebrew", "Israel" },	      { 0x040E, 852, 1250, "Hungarian", "Hungary" },
  { 0x040F, 850, 1252, "Icelandic", "Iceland" },      { 0x0410, 850, 1252, "Italian", "Italy" },
  { 0x0411, 932,  932, "Japanese", "Japan" },	      { 0x0412, 949,  949, "Korean", "Korea (south)" },
  { 0x0413, 850, 1252, "Dutch", "Netherlands" },      { 0x0414, 850, 1252, "Norwegian (Bokm\345l)", "Norway" },
  { 0x0415, 852, 1250, "Polish", "Poland" },	      { 0x0416, 850, 1252, "Portuguese", "Brazil" },
  { 0x0418, 852, 1250, "Romanian", "Romania" },	      { 0x0419, 866, 1251, "Russian", "Russia" },
  { 0x041A, 852, 1250, "Croatian", "Croatia" },	      { 0x041B, 852, 1250, "Slovak", "Slovakia" },
  { 0x041C, 852, 1250, "Albanian", "Albania" },	      { 0x041D, 850, 1252, "Swedish", "Sweden" },
  { 0x041E, 874,  874, "Thai", "Thailand" },	      { 0x041F, 857, 1254, "Turkish", "Turkey" },
  { 0x0421, 850, 1252, "Indonesian", "Indonesia" },   { 0x0422, 866, 1251, "Ukrainian", "Ukraine" },
  { 0x0423, 866, 1251, "Belarusian", "Belarus" },     { 0x0424, 852, 1250, "Slovene", "Slovenia" },
  { 0x0425, 775, 1257, "Estonian", "Estonia" },	      { 0x0426, 775, 1257, "Latvian", "Latvia" },
  { 0x0427, 775, 1257, "Lithuanian", "Lithuania" },
  { 0x0429, 864, 1256, "Arabic", "Farsi" },	      { 0x042A,1258, 1258, "Vietnamese", "Vietnam" },
  { 0x042D, 850, 1252, "Basque", "Spain" },
  { 0x042F, 866, 1251, "Macedonian", "Former Yugoslav Republic of Macedonia" },
  { 0x0436, 850, 1252, "Afrikaans", "South Africa" },
  { 0x0438, 850, 1252, "Faroese", "Faroe Islands" },
  { 0x043C, 437, 1252, "Irish", "Ireland" },
  { 0x043E, 850, 1252, "Malay", "Malaysia" },
  { 0x0801, 864, 1256, "Arabic", "Iraq" },
  { 0x0804, 936,  936, "Chinese (People's republic of China)", "People's republic of China" },
  { 0x0807, 850, 1252, "German", "Switzerland" },
  { 0x0809, 850, 1252, "English", "United Kingdom" }, { 0x080A, 850, 1252, "Spanish", "Mexico" },
  { 0x080C, 850, 1252, "French", "Belgium" },
  { 0x0810, 850, 1252, "Italian", "Switzerland" },
  { 0x0813, 850, 1252, "Dutch", "Belgium" },	      { 0x0814, 850, 1252, "Norwegian (Nynorsk)", "Norway" },
  { 0x0816, 850, 1252, "Portuguese", "Portugal" },
  { 0x081A, 852, 1252, "Serbian (latin)", "Yugoslavia" },
  { 0x081D, 850, 1252, "Swedish (Finland)", "Finland" },
  { 0x0C01, 864, 1256, "Arabic", "Egypt" },
  { 0x0C04, 950,  950, "Chinese", "Hong Kong" },
  { 0x0C07, 850, 1252, "German", "Austria" },
  { 0x0C09, 850, 1252, "English", "Australia" },      { 0x0C0A, 850, 1252, "Spanish - International Sort", "Spain" },
  { 0x0C0C, 850, 1252, "French", "Canada"},
  { 0x0C1A, 855, 1251, "Serbian (Cyrillic)", "Serbia" },
  { 0x1001, 864, 1256, "Arabic", "Libya" },
  { 0x1004, 936,  936, "Chinese", "Singapore" },
  { 0x1007, 850, 1252, "German", "Luxembourg" },
  { 0x1009, 850, 1252, "English", "Canada" },
  { 0x100A, 850, 1252, "Spanish", "Guatemala" },
  { 0x100C, 850, 1252, "French", "Switzerland" },
  { 0x1401, 864, 1256, "Arabic", "Algeria" },
  { 0x1407, 850, 1252, "German", "Liechtenstein" },
  { 0x1409, 850, 1252, "English", "New Zealand" },    { 0x140A, 850, 1252, "Spanish", "Costa Rica" },
  { 0x140C, 850, 1252, "French", "Luxembourg" },
  { 0x1801, 864, 1256, "Arabic", "Morocco" },
  { 0x1809, 850, 1252, "English", "Ireland" },	      { 0x180A, 850, 1252, "Spanish", "Panama" },
  { 0x180C, 850, 1252, "French", "Monaco" },
  { 0x1C01, 864, 1256, "Arabic", "Tunisia" },
  { 0x1C09, 437, 1252, "English", "South Africa" },   { 0x1C0A, 850, 1252, "Spanish", "Dominican Republic" },
  { 0x2001, 864, 1256, "Arabic", "Oman" },
  { 0x2009, 850, 1252, "English", "Jamaica" },	      { 0x200A, 850, 1252, "Spanish", "Venezuela" },
  { 0x2401, 864, 1256, "Arabic", "Yemen" },
  { 0x2409, 850, 1252, "English", "Caribbean" },      { 0x240A, 850, 1252, "Spanish", "Colombia" },
  { 0x2801, 864, 1256, "Arabic", "Syria" },
  { 0x2809, 850, 1252, "English", "Belize" },	      { 0x280A, 850, 1252, "Spanish", "Peru" },
  { 0x2C01, 864, 1256, "Arabic", "Jordan" },
  { 0x2C09, 437, 1252, "English", "Trinidad & Tobago" },{ 0x2C0A, 850, 1252, "Spanish", "Argentina" },
  { 0x3001, 864, 1256, "Arabic", "Lebanon" },
  { 0x3009, 437, 1252, "English", "Zimbabwe" },	      { 0x300A, 850, 1252, "Spanish", "Ecuador" },
  { 0x3401, 864, 1256, "Arabic", "Kuwait" },
  { 0x3409, 437, 1252, "English", "Philippines" },    { 0x340A, 850, 1252, "Spanish", "Chile" },
  { 0x3801, 864, 1256, "Arabic", "United Arab Emirates" },
  { 0x380A, 850, 1252, "Spanish", "Uruguay" },
  { 0x3C01, 864, 1256, "Arabic", "Bahrain" },
  { 0x3C0A, 850, 1252, "Spanish", "Paraguay" },
  { 0x4001, 864, 1256, "Arabic", "Qatar" },
  { 0x400A, 850, 1252, "Spanish", "Bolivia" },
  { 0x440A, 850, 1252, "Spanish", "El Salvador" },
  { 0x480A, 850, 1252, "Spanish", "Honduras" },
  { 0x4C0A, 850, 1252, "Spanish", "Nicaragua" },
  { 0x500A, 850, 1252, "Spanish", "Puerto Rico" },
  { (unsigned) -1,  0,      0, NULL, NULL }
};

#endif

/* Specifies the default codepage to be used for unicode
   transformations.  By default this is CP_ACP.  */
rc_uint_type wind_default_codepage = CP_ACP;

/* Specifies the currently used codepage for unicode
   transformations.  By default this is CP_ACP.  */
rc_uint_type wind_current_codepage = CP_ACP;

/* Convert an ASCII string to a unicode string.  We just copy it,
   expanding chars to shorts, rather than doing something intelligent.  */

void
unicode_from_ascii (rc_uint_type *length, unichar **unicode, const char *ascii)
{
  unicode_from_codepage (length, unicode, ascii, wind_current_codepage);
}

/* Convert an ASCII string with length A_LENGTH to a unicode string.  We just
   copy it, expanding chars to shorts, rather than doing something intelligent.
   This routine converts also \0 within a string.  */

void
unicode_from_ascii_len (rc_uint_type *length, unichar **unicode, const char *ascii, rc_uint_type a_length)
{
  char *tmp, *p;
  rc_uint_type tlen, elen, idx = 0;

  *unicode = NULL;

  if (!a_length)
    {
      if (length)
        *length = 0;
      return;
    }

  /* Make sure we have zero terminated string.  */
  p = tmp = (char *) alloca (a_length + 1);
  memcpy (tmp, ascii, a_length);
  tmp[a_length] = 0;

  while (a_length > 0)
    {
      unichar *utmp, *up;

      tlen = strlen (p);

      if (tlen > a_length)
        tlen = a_length;
      if (*p == 0)
        {
	  /* Make room for one more character.  */
	  utmp = (unichar *) res_alloc (sizeof (unichar) * (idx + 1));
	  if (idx > 0)
	    {
	      memcpy (utmp, *unicode, idx * sizeof (unichar));
	    }
	  *unicode = utmp;
	  utmp[idx++] = 0;
	  --a_length;
	  p++;
	  continue;
	}
      utmp = NULL;
      elen = 0;
      elen = wind_MultiByteToWideChar (wind_current_codepage, p, NULL, 0);
      if (elen)
	{
	  utmp = ((unichar *) res_alloc (elen + sizeof (unichar) * 2));
	  wind_MultiByteToWideChar (wind_current_codepage, p, utmp, elen);
	  elen /= sizeof (unichar);
	  elen --;
	}
      else
        {
	  /* Make room for one more character.  */
	  utmp = (unichar *) res_alloc (sizeof (unichar) * (idx + 1));
	  if (idx > 0)
	    {
	      memcpy (utmp, *unicode, idx * sizeof (unichar));
	    }
	  *unicode = utmp;
	  utmp[idx++] = ((unichar) *p) & 0xff;
	  --a_length;
	  p++;
	  continue;
	}
      p += tlen;
      a_length -= tlen;

      up = (unichar *) res_alloc (sizeof (unichar) * (idx + elen));
      if (idx > 0)
	memcpy (up, *unicode, idx * sizeof (unichar));

      *unicode = up;
      if (elen)
	memcpy (&up[idx], utmp, sizeof (unichar) * elen);

      idx += elen;
    }

  if (length)
    *length = idx;
}

/* Convert an unicode string to an ASCII string.  We just copy it,
   shrink shorts to chars, rather than doing something intelligent.
   Shorts with not within the char range are replaced by '_'.  */

void
ascii_from_unicode (rc_uint_type *length, const unichar *unicode, char **ascii)
{
  codepage_from_unicode (length, unicode, ascii, wind_current_codepage);
}

/* Print the unicode string UNICODE to the file E.  LENGTH is the
   number of characters to print, or -1 if we should print until the
   end of the string.  FIXME: On a Windows host, we should be calling
   some Windows function, probably WideCharToMultiByte.  */

void
unicode_print (FILE *e, const unichar *unicode, rc_uint_type length)
{
  while (1)
    {
      unichar ch;

      if (length == 0)
	return;
      if ((bfd_signed_vma) length > 0)
	--length;

      ch = *unicode;

      if (ch == 0 && (bfd_signed_vma) length < 0)
	return;

      ++unicode;

      if ((ch & 0x7f) == ch)
	{
	  if (ch == '\\')
	    fputs ("\\\\", e);
	  else if (ch == '"')
	    fputs ("\"\"", e);
	  else if (ISPRINT (ch))
	    putc (ch, e);
	  else
	    {
	      switch (ch)
		{
		case ESCAPE_A:
		  fputs ("\\a", e);
		  break;

		case ESCAPE_B:
		  fputs ("\\b", e);
		  break;

		case ESCAPE_F:
		  fputs ("\\f", e);
		  break;

		case ESCAPE_N:
		  fputs ("\\n", e);
		  break;

		case ESCAPE_R:
		  fputs ("\\r", e);
		  break;

		case ESCAPE_T:
		  fputs ("\\t", e);
		  break;

		case ESCAPE_V:
		  fputs ("\\v", e);
		  break;

		default:
		  fprintf (e, "\\%03o", (unsigned int) ch);
		  break;
		}
	    }
	}
      else if ((ch & 0xff) == ch)
	fprintf (e, "\\%03o", (unsigned int) ch);
      else
	fprintf (e, "\\x%04x", (unsigned int) ch);
    }
}

/* Print a unicode string to a file.  */

void
ascii_print (FILE *e, const char *s, rc_uint_type length)
{
  while (1)
    {
      char ch;

      if (length == 0)
	return;
      if ((bfd_signed_vma) length > 0)
	--length;

      ch = *s;

      if (ch == 0 && (bfd_signed_vma) length < 0)
	return;

      ++s;

      if ((ch & 0x7f) == ch)
	{
	  if (ch == '\\')
	    fputs ("\\\\", e);
	  else if (ch == '"')
	    fputs ("\"\"", e);
	  else if (ISPRINT (ch))
	    putc (ch, e);
	  else
	    {
	      switch (ch)
		{
		case ESCAPE_A:
		  fputs ("\\a", e);
		  break;

		case ESCAPE_B:
		  fputs ("\\b", e);
		  break;

		case ESCAPE_F:
		  fputs ("\\f", e);
		  break;

		case ESCAPE_N:
		  fputs ("\\n", e);
		  break;

		case ESCAPE_R:
		  fputs ("\\r", e);
		  break;

		case ESCAPE_T:
		  fputs ("\\t", e);
		  break;

		case ESCAPE_V:
		  fputs ("\\v", e);
		  break;

		default:
		  fprintf (e, "\\%03o", (unsigned int) ch);
		  break;
		}
	    }
	}
      else
	fprintf (e, "\\%03o", (unsigned int) ch & 0xff);
    }
}

rc_uint_type
unichar_len (const unichar *unicode)
{
  rc_uint_type r = 0;

  if (unicode)
    while (unicode[r] != 0)
      r++;
  else
    --r;
  return r;
}

unichar *
unichar_dup (const unichar *unicode)
{
  unichar *r;
  int len;

  if (! unicode)
    return NULL;
  for (len = 0; unicode[len] != 0; ++len)
    ;
  ++len;
  r = ((unichar *) res_alloc (len * sizeof (unichar)));
  memcpy (r, unicode, len * sizeof (unichar));
  return r;
}

unichar *
unichar_dup_uppercase (const unichar *u)
{
  unichar *r = unichar_dup (u);
  int i;

  if (! r)
    return NULL;

  for (i = 0; r[i] != 0; ++i)
    {
      if (r[i] >= 'a' && r[i] <= 'z')
	r[i] &= 0xdf;
    }
  return r;
}

static int
unichar_isascii (const unichar *u, rc_uint_type len)
{
  rc_uint_type i;

  if ((bfd_signed_vma) len < 0)
    {
      if (u)
	len = (rc_uint_type) unichar_len (u);
      else
	len = 0;
    }

  for (i = 0; i < len; i++)
    if ((u[i] & 0xff80) != 0)
      return 0;
  return 1;
}

void
unicode_print_quoted (FILE *e, const unichar *u, rc_uint_type len)
{
  if (! unichar_isascii (u, len))
    fputc ('L', e);
  fputc ('"', e);
  unicode_print (e, u, len);
  fputc ('"', e);
}

int
unicode_is_valid_codepage (rc_uint_type cp)
{
  if ((cp & 0xffff) != cp)
    return 0;
  if (cp == CP_UTF16 || cp == CP_ACP)
    return 1;

#if !defined (_WIN32) && !defined (__CYGWIN__)
  if (! wind_find_codepage_info (cp))
    return 0;
  return 1;
#else
  return !! IsValidCodePage ((UINT) cp);
#endif
}

#if defined (_WIN32) || defined (__CYGWIN__)

#define max_cp_string_len 6

static unsigned int
codepage_from_langid (unsigned short langid)
{
  char cp_string [max_cp_string_len];
  int c;

  memset (cp_string, 0, max_cp_string_len);
  /* LOCALE_RETURN_NUMBER flag would avoid strtoul conversion,
     but is unavailable on Win95.  */
  c = GetLocaleInfoA (MAKELCID (langid, SORT_DEFAULT),
  		      LOCALE_IDEFAULTANSICODEPAGE,
  		      cp_string, max_cp_string_len);
  /* If codepage data for an LCID is not installed on users's system,
     GetLocaleInfo returns an empty string.  Fall back to system ANSI
     default. */
  if (c == 0)
    return CP_ACP;
  return strtoul (cp_string, 0, 10);
}

static unsigned int
wincodepage_from_langid (unsigned short langid)
{
  char cp_string [max_cp_string_len];
  int c;

  memset (cp_string, 0, max_cp_string_len);
  /* LOCALE_RETURN_NUMBER flag would avoid strtoul conversion,
     but is unavailable on Win95.  */
  c = GetLocaleInfoA (MAKELCID (langid, SORT_DEFAULT),
		      LOCALE_IDEFAULTCODEPAGE,
		      cp_string, max_cp_string_len);
  /* If codepage data for an LCID is not installed on users's system,
     GetLocaleInfo returns an empty string.  Fall back to system ANSI
     default. */
  if (c == 0)
    return CP_OEM;
  return strtoul (cp_string, 0, 10);
}

static char *
lang_from_langid (unsigned short langid)
{
  char cp_string[261];
  int c;

  memset (cp_string, 0, 261);
  c = GetLocaleInfoA (MAKELCID (langid, SORT_DEFAULT),
  		      LOCALE_SENGLANGUAGE,
  		      cp_string, 260);
  /* If codepage data for an LCID is not installed on users's system,
     GetLocaleInfo returns an empty string.  Fall back to system ANSI
     default. */
  if (c == 0)
    strcpy (cp_string, "Neutral");
  return xstrdup (cp_string);
}

static char *
country_from_langid (unsigned short langid)
{
  char cp_string[261];
  int c;

  memset (cp_string, 0, 261);
  c = GetLocaleInfoA (MAKELCID (langid, SORT_DEFAULT),
  		      LOCALE_SENGCOUNTRY,
  		      cp_string, 260);
  /* If codepage data for an LCID is not installed on users's system,
     GetLocaleInfo returns an empty string.  Fall back to system ANSI
     default. */
  if (c == 0)
    strcpy (cp_string, "Neutral");
  return xstrdup (cp_string);
}

#endif

const wind_language_t *
wind_find_language_by_id (unsigned id)
{
#if !defined (_WIN32) && !defined (__CYGWIN__)
  int i;

  if (! id)
    return NULL;
  for (i = 0; languages[i].id != (unsigned) -1 && languages[i].id != id; i++)
    ;
  if (languages[i].id == id)
    return &languages[i];
  return NULL;
#else
  static wind_language_t wl;

  wl.id = id;
  wl.doscp = codepage_from_langid ((unsigned short) id);
  wl.wincp = wincodepage_from_langid ((unsigned short) id);
  wl.name = lang_from_langid ((unsigned short) id);
  wl.country = country_from_langid ((unsigned short) id);

  return & wl;
#endif
}

const local_iconv_map *
wind_find_codepage_info (unsigned cp)
{
#if !defined (_WIN32) && !defined (__CYGWIN__)
  int i;

  for (i = 0; codepages[i].codepage != (rc_uint_type) -1 && codepages[i].codepage != cp; i++)
    ;
  if (codepages[i].codepage == (rc_uint_type) -1)
    return NULL;
  return &codepages[i];
#else
  static local_iconv_map lim;
  if (!unicode_is_valid_codepage (cp))
  	return NULL;
  lim.codepage = cp;
  lim.iconv_name = "";
  return & lim;
#endif
}

/* Convert an Codepage string to a unicode string.  */

void
unicode_from_codepage (rc_uint_type *length, unichar **u, const char *src, rc_uint_type cp)
{
  rc_uint_type len;

  len = wind_MultiByteToWideChar (cp, src, NULL, 0);
  if (len)
    {
      *u = ((unichar *) res_alloc (len));
      wind_MultiByteToWideChar (cp, src, *u, len);
    }
  /* Discount the trailing '/0'.  If MultiByteToWideChar failed,
     this will set *length to -1.  */
  len -= sizeof (unichar);

  if (length != NULL)
    *length = len / sizeof (unichar);
}

/* Convert an unicode string to an codepage string.  */

void
codepage_from_unicode (rc_uint_type *length, const unichar *unicode, char **ascii, rc_uint_type cp)
{
  rc_uint_type len;

  len = wind_WideCharToMultiByte (cp, unicode, NULL, 0);
  if (len)
    {
      *ascii = (char *) res_alloc (len * sizeof (char));
      wind_WideCharToMultiByte (cp, unicode, *ascii, len);
    }
  /* Discount the trailing '/0'.  If MultiByteToWideChar failed,
     this will set *length to -1.  */
  len--;

  if (length != NULL)
    *length = len;
}

#if defined (HAVE_ICONV) && !defined (_WIN32) && !defined (__CYGWIN__)
static int
iconv_onechar (iconv_t cd, ICONV_CONST char *s, char *d, int d_len, const char **n_s, char **n_d)
{
  int i;

  for (i = 1; i <= 32; i++)
    {
      char *tmp_d = d;
      ICONV_CONST char *tmp_s = s;
      size_t ret;
      size_t s_left = (size_t) i;
      size_t d_left = (size_t) d_len;

      ret = iconv (cd, & tmp_s, & s_left, & tmp_d, & d_left);

      if (ret != (size_t) -1)
	{
	  *n_s = tmp_s;
	  *n_d = tmp_d;
	  return 0;
	}
    }

  return 1;
}

static const char *
wind_iconv_cp (rc_uint_type cp)
{
  const local_iconv_map *lim = wind_find_codepage_info (cp);

  if (!lim)
    return NULL;
  return lim->iconv_name;
}
#endif /* HAVE_ICONV */

static rc_uint_type
wind_MultiByteToWideChar (rc_uint_type cp, const char *mb,
			  unichar *u, rc_uint_type u_len)
{
  rc_uint_type ret = 0;

#if defined (_WIN32) || defined (__CYGWIN__)
  rc_uint_type conv_flags = MB_PRECOMPOSED;

  /* MB_PRECOMPOSED is not allowed for UTF-7 or UTF-8.
     MultiByteToWideChar will set the last error to
     ERROR_INVALID_FLAGS if we do. */
  if (cp == CP_UTF8 || cp == CP_UTF7)
    conv_flags = 0;

  ret = (rc_uint_type) MultiByteToWideChar (cp, conv_flags,
					    mb, -1, u, u_len);
  /* Convert to bytes. */
  ret *= sizeof (unichar);

#elif defined (HAVE_ICONV)
  int first = 1;
  char tmp[32];
  char *p_tmp;
  const char *iconv_name = wind_iconv_cp (cp);

  if (!mb || !iconv_name)
    return 0;
  iconv_t cd = iconv_open ("UTF-16LE", iconv_name);

  while (1)
    {
      int iret;
      const char *n_mb = "";
      char *n_tmp = "";

      p_tmp = tmp;
      iret = iconv_onechar (cd, (ICONV_CONST char *) mb, p_tmp, 32, & n_mb, & n_tmp);
      if (first)
	{
	  first = 0;
	  continue;
	}
      if (!iret)
	{
	  size_t l_tmp = (size_t) (n_tmp - p_tmp);

	  if (u)
	    {
	      if ((size_t) u_len < l_tmp)
		break;
	      memcpy (u, tmp, l_tmp);
	      u += l_tmp/2;
	      u_len -= l_tmp;
	    }
	  ret += l_tmp;
	}
      else
	break;
      if (tmp[0] == 0 && tmp[1] == 0)
	break;
      mb = n_mb;
    }
  iconv_close (cd);
#else
  if (cp)
    ret = 0;
  ret = strlen (mb) + 1;
  ret *= sizeof (unichar);
  if (u != NULL && u_len != 0)
    {
      do
	{
	  *u++ = ((unichar) *mb) & 0xff;
	  --u_len; mb++;
	}
      while (u_len != 0 && mb[-1] != 0);
    }
  if (u != NULL && u_len != 0)
    *u = 0;
#endif
  return ret;
}

static rc_uint_type
wind_WideCharToMultiByte (rc_uint_type cp, const unichar *u, char *mb, rc_uint_type mb_len)
{
  rc_uint_type ret = 0;
#if defined (_WIN32) || defined (__CYGWIN__)
  WINBOOL used_def = FALSE;

  ret = (rc_uint_type) WideCharToMultiByte (cp, 0, u, -1, mb, mb_len,
				      	    NULL, & used_def);
#elif defined (HAVE_ICONV)
  int first = 1;
  char tmp[32];
  char *p_tmp;
  const char *iconv_name = wind_iconv_cp (cp);

  if (!u || !iconv_name)
    return 0;
  iconv_t cd = iconv_open (iconv_name, "UTF-16LE");

  while (1)
    {
      int iret;
      const char *n_u = "";
      char *n_tmp = "";

      p_tmp = tmp;
      iret = iconv_onechar (cd, (ICONV_CONST char *) u, p_tmp, 32, &n_u, & n_tmp);
      if (first)
	{
	  first = 0;
	  continue;
	}
      if (!iret)
	{
	  size_t l_tmp = (size_t) (n_tmp - p_tmp);

	  if (mb)
	    {
	      if ((size_t) mb_len < l_tmp)
		break;
	      memcpy (mb, tmp, l_tmp);
	      mb += l_tmp;
	      mb_len -= l_tmp;
	    }
	  ret += l_tmp;
	}
      else
	break;
      if (u[0] == 0)
	break;
      u = (const unichar *) n_u;
    }
  iconv_close (cd);
#else
  if (cp)
    ret = 0;

  while (u[ret] != 0)
    ++ret;

  ++ret;

  if (mb)
    {
      while (*u != 0 && mb_len != 0)
	{
	  if (u[0] == (u[0] & 0x7f))
	    *mb++ = (char) u[0];
	  else
	    *mb++ = '_';
	  ++u; --mb_len;
	}
      if (mb_len != 0)
	*mb = 0;
    }
#endif
  return ret;
}
@


1.16
log
@	PR binutils/13409
	* winduni.c (codepages[]): Use UTF-16LE.
	(wind_MultiByteToWideChar): Likewise.
	(wind_WideCharToMultiByte): Likewise.
@
text
@d54 1
a54 1
 
d104 1
a104 1
  { 0x0413, 850, 1252, "Dutch", "Netherlands" },      { 0x0414, 850, 1252, "Norwegian (Bokmål)", "Norway" },
d753 1
a753 1
  /* MB_PRECOMPOSED is not allowed for UTF-7 or UTF-8.  
@


1.16.2.1
log
@binutils/
	* winduni.c (languages): Use \345 (octal syntax) rather than
	literal non-ASCII/non-UTF8 character in string literal.
@
text
@d54 1
a54 1

d104 1
a104 1
  { 0x0413, 850, 1252, "Dutch", "Netherlands" },      { 0x0414, 850, 1252, "Norwegian (Bokm\345l)", "Norway" },
d753 1
a753 1
  /* MB_PRECOMPOSED is not allowed for UTF-7 or UTF-8.
@


1.15
log
@2011-10-25  Kai Tietz  <ktietz@@redhat.com>

	* winduni.h (unicode_from_ascii_len): New prototype.
	* winduni.c (unicode_from_ascii_len): New function.
	* windres.h (define_stringtable): Add additional length argument.
	* windres.c (define_stringtable): Add length argument for string.
	* rcparse.y (res_unicode_sizedstring): New rule.
	(res_unicode_sizedstring_concat): Likewise.
	(string_data): Adjust rule.

2011-10-25  Kai Tietz  <ktietz@@redhat.com>

	* binutils-all/windres/strtab4.rc: New test.
	* binutils-all/windres/strtab4.rsd: Likewise.
@
text
@d2 1
a2 2
   Copyright 1997, 1998, 2000, 2001, 2003, 2005, 2007, 2009
   Free Software Foundation, Inc.
d87 1
a87 1
  { CP_UTF16, "UTF-16" },
d772 1
a772 1
  iconv_t cd = iconv_open ("UTF-16", iconv_name);
d845 1
a845 1
  iconv_t cd = iconv_open (iconv_name, "UTF-16");
@


1.14
log
@update copyright dates
@
text
@d197 88
@


1.13
log
@        PR 10165
        * winduni.c (wind_MultiByteToWideChar): Do not pass MB_PRECOMPOSED
        to MultiByteToWideChar when using the CP_UTF8 or CO_UTF7 types.
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 2000, 2001, 2003, 2007, 2009
@


1.12
log
@2009-05-08  Kai Tietz  <kai.tietz@@onevision.com>

        * winduni.c (iconv_onechar): Only define when HAVE_ICONV
        is defined, but not when __CYGWIN__ or _WIN32 are defined.
        See wind_iconv_cp for call logic of this local funtion.
@
text
@d664 9
a672 1
  ret = (rc_uint_type) MultiByteToWideChar (cp, MB_PRECOMPOSED,
@


1.11
log
@        PR 10109
        * winduni.c: Replace test of HAVE_ICONV_H with a test of
        HAVE_ICONV.
        (iconv_onechar): Use ICONV_CONST instead of "const".
        (wind_MultiByteToWideChar): Initialise local strings.
@
text
@d619 1
a619 1
#ifdef HAVE_ICONV
@


1.10
log
@Change sources over to using GPLv3
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 2000, 2001, 2003, 2007
d45 1
a45 1
#if HAVE_ICONV_H
d619 1
a619 1
#ifdef HAVE_ICONV_H
d621 1
a621 1
iconv_onechar (iconv_t cd, const char *s, char *d, int d_len, const char **n_s, char **n_d)
d628 1
a628 1
      const char *tmp_s = s;
d655 1
a655 1
#endif /* HAVE_ICONV_H */
d669 1
a669 1
#elif defined (HAVE_ICONV_H)
d682 2
a683 2
      const char *n_mb;
      char *n_tmp;
d686 1
a686 1
      iret = iconv_onechar (cd, (const char *) mb, p_tmp, 32, & n_mb, & n_tmp);
d742 1
a742 1
#elif defined (HAVE_ICONV_H)
d755 2
a756 2
      const char *n_u;
      char *n_tmp;
d759 1
a759 1
      iret = iconv_onechar (cd, (const char *) u, p_tmp, 32, &n_u, & n_tmp);
@


1.9
log
@* rclex.c: (cpp_line): Add code_page pragma support.
* windres.c: (usage, long_options, main): Add new option --codepage or -c.
* winduni.c: (wind_default_codepage, wind_current_codepage): New.
  (unicode_from_ascii, ascii_from_unicode): Use wind_current_codepage as codepage parameter.
  (unicode_print): Print 4 characters for hexadecimal values in unicode strings.
* winduni.h:  (wind_default_codepage, wind_current_codepage): Export.
* doc/binutils.texi: Document new option.
* NEWS: Mention new feature.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
d24 1
@


1.8
log
@* Makefile.am: Add LIBICONV to windres.
* acinclude.m4: Added missing "lib-*.m4" and "lt*.m4" files.
* configure.in: Add AC_CHECK_HEADER for iconv.h and use AM_ICONV.
* config.in: Add ICONV defines.
* aclocal: Regenerate.
* confugure: Regenerate.
* winduni.c: (local_iconv_map codepages, wind_language_t, languages, unicode_is$
  (ascii_from_unicode): Use codepage_from_unicode.
  (ascii_from_unicode): Use unicode_from_codepage.
  Use for cygwin windows API for unicode transformation.
* winduni.h: (CP_ACP, CP_UTF7, CP_UTF8, CP_OEM, CP_UTF16): New macros.
  (wind_language_t, local_iconv_map): New types.
  (wind_find_language_by_id, wind_find_language_by_codepage,
  (unicode_is_valid_codepage, wind_find_codepage_info, unicode_from_codepage, c$
@
text
@a49 2

/* Prototypes.  */
d52 3
d179 8
d193 1
a193 1
  unicode_from_codepage (length, unicode, ascii, 0 /*CP_ACP*/);
d203 1
a203 1
  codepage_from_unicode (length, unicode, ascii, 0/*CP_ACP*/);
d279 1
a279 1
	fprintf (e, "\\x%x", (unsigned int) ch);
@


1.7
log
@Updated windres tool
@
text
@d34 1
d36 5
d44 2
a45 2
#ifdef _WIN32
#include <windows.h>
d48 3
d54 124
d184 1
a184 27
  rc_uint_type len;
#ifndef _WIN32
  const char *s;
  unsigned short *w;

  len = strlen (ascii);
  *unicode = ((unichar *) res_alloc ((len + 1) * sizeof (unichar)));
  for (s = ascii, w = *unicode; *s != '\0'; s++, w++)
    *w = *s & 0xff;
  *w = 0;
#else
  /* We use  MultiByteToWideChar rather than strlen to get the unicode
     string length to allow multibyte "ascii" chars. The value returned
     by this function includes the trailing '\0'.  */
  len = (rc_uint_type) MultiByteToWideChar (CP_ACP, 0, ascii, -1, NULL, 0);
  if (len)
    {
      *unicode = ((unichar *) res_alloc (len * sizeof (unichar)));
      MultiByteToWideChar (CP_ACP, 0, ascii, -1, *unicode, (int) len);
    }
  /* Discount the trailing '/0'.  If MultiByteToWideChar failed,
     this will set *length to -1.  */
  len--;
#endif

  if (length != NULL)
    *length = len;
d194 1
a194 37
  rc_uint_type len;
#ifndef _WIN32
  char *s;
  const unsigned short *w;

  len = 0;
  while (unicode[len] != 0)
    ++len;
  *ascii = ((char *) res_alloc (len + 1));
  for (s = *ascii, w = unicode; *w != '\0'; w++, s++)
    {
      if(w[0]==(w[0]&0xff))
	*s = (char) w[0];
      else
	*s = '_';
    }
  *s = 0;
#else
  WINBOOL used_def = FALSE;
  /* We use  MultiByteToWideChar rather than strlen to get the unicode
     string length to allow multibyte "ascii" chars. The value returned
     by this function includes the trailing '\0'.  */
  len = (rc_uint_type) WideCharToMultiByte (CP_ACP, WC_DEFAULTCHAR, unicode, -1, NULL,
  				       0, "_", &used_def);
  if (len)
    {
      *ascii = (char *) res_alloc (len * sizeof (char));
      WideCharToMultiByte (CP_ACP, WC_DEFAULTCHAR, unicode, -1, *ascii, (int) len,
      			   "_", &used_def);
    }
  /* Discount the trailing '/0'.  If MultiByteToWideChar failed,
     this will set *length to -1.  */
  len--;
#endif

  if (length != NULL)
    *length = len;
d275 1
d350 1
d396 1
d420 381
@


1.6
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d5 1
d34 1
d42 3
d49 1
a49 1
unicode_from_ascii (int *length, unichar **unicode, const char *ascii)
d51 1
a51 1
  int len;
d65 1
a65 1
  len = MultiByteToWideChar (CP_ACP, 0, ascii, -1, NULL, 0);
d69 47
a115 1
      MultiByteToWideChar (CP_ACP, 0, ascii, -1, *unicode, len);
d132 1
a132 1
unicode_print (FILE *e, const unichar *unicode, int length)
d140 1
a140 1
      if (length > 0)
d145 1
a145 1
      if (ch == 0 && length < 0)
d153 3
a155 1
	    fputs ("\\", e);
d202 144
@


1.5
log
@Update FSF address
@
text
@d2 2
a3 1
   Copyright 1997, 1998, 2000, 2001, 2003 Free Software Foundation, Inc.
d31 1
a32 1
#include "bucomm.h"
@


1.4
log
@	* winduni.c (unicode_from_ascii): Don't declare variables
	's' and 'w' if _WIN32.  Use MultiByteToWideChar to set the unicode
	string len.
@
text
@d19 2
a20 2
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.3
log
@	* addr2line.c: Convert to ISO C90 prototypes, change PTR, remove
	unneeded (void *) casts.
	* ar.c: Likewise.
	* arlex.l: Likewise.
	* arparse.y: Likewise.
	* arsup.c: Likewise.
	* binemul.c: Likewise.
	* binemul.h: Likewise.
	* bucomm.c: Likewise.
	* bucomm.h: Likewise.
	* budbg.h: Likewise.
	* budemang.c: Likewise.
	* budemang.h: Likewise.
	* coffdump.c: Likewise.
	* coffgrok.c: Likewise.
	* cxxfilt.c: Likewise.
	* debug.c: Likewise.
	* debug.h: Likewise.
	* deflex.l: Likewise.
	* dlltool.c: Likewise.
	* dlltool.h: Likewise.
	* dllwrap.c: Likewise.
	* emul_aix.c: Likewise.
	* filemode.c: Likewise.
	* ieee.c: Likewise.
	* nlmconv.c: Likewise.
	* nlmconv.h: Likewise.
	* nlmheader.y: Likewise.
	* nm.c: Likewise.
	* prdbg.c: Likewise.
	* rclex.l: Likewise.
	* rcparse.y: Likewise.
	* rdcoff.c: Likewise.
	* rddbg.c: Likewise.
	* rename.c: Likewise.
	* resbin.c: Likewise.
	* rescoff.c: Likewise.
	* resrc.c: Likewise.
	* size.c: Likewise.
	* srconv.c: Likewise.
	* stabs.c: Likewise.
	* strings.c: Likewise.
	* sysdump.c: Likewise.
	* sysinfo.y: Likewise.
	* syslex.l: Likewise.
	* unwind-ia64.c: Likewise.
	* unwind-ia64.h: Likewise.
	* version.c: Likewise.
	* windres.c: Likewise.
	* windres.h: Likewise.
	* winduni.c: Likewise.
	* wrstabs.c: Likewise.
@
text
@d46 1
a50 4

  if (length != NULL)
    *length = len;

a51 6

#ifdef _WIN32
  /* FIXME: On Windows, we should be using MultiByteToWideChar to set
     the length.  */
  MultiByteToWideChar (CP_ACP, 0, ascii, len + 1, *unicode, len + 1);
#else
d55 13
d69 3
@


1.2
log
@Locale changes from Bruno Haible  <haible@@clisp.cons.org>.
@
text
@d2 1
a2 1
   Copyright 1997, 1998, 2000, 2001 Free Software Foundation, Inc.
d43 1
a43 4
unicode_from_ascii (length, unicode, ascii)
     int *length;
     unichar **unicode;
     const char *ascii;
d73 1
a73 4
unicode_print (e, unicode, length)
     FILE *e;
     const unichar *unicode;
     int length;
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright 1997, 1998 Free Software Foundation, Inc.
d33 1
a33 2

#include <ctype.h>
d101 1
a101 1
	  else if (isprint (ch))
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

