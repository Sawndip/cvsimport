head	1.26;
access;
symbols
	binutils-2_24-branch:1.26.0.8
	binutils-2_24-branchpoint:1.26
	binutils-2_21_1:1.25
	binutils-2_23_2:1.26
	binutils-2_23_1:1.26
	binutils-2_23:1.26
	binutils-2_23-branch:1.26.0.6
	binutils-2_23-branchpoint:1.26
	binutils-2_22_branch:1.26.0.4
	binutils-2_22:1.26
	binutils-2_22-branch:1.26.0.2
	binutils-2_22-branchpoint:1.26
	binutils-2_21:1.25
	binutils-2_21-branch:1.25.0.2
	binutils-2_21-branchpoint:1.25
	binutils-2_20_1:1.22.2.2
	binutils-2_20:1.22.2.1
	binutils-arc-20081103-branch:1.21.0.8
	binutils-arc-20081103-branchpoint:1.21
	binutils-2_20-branch:1.22.0.2
	binutils-2_20-branchpoint:1.22
	dje-cgen-play1-branch:1.21.0.6
	dje-cgen-play1-branchpoint:1.21
	arc-20081103-branch:1.21.0.4
	arc-20081103-branchpoint:1.21
	binutils-2_19_1:1.21
	binutils-2_19:1.21
	binutils-2_19-branch:1.21.0.2
	binutils-2_19-branchpoint:1.21
	binutils-2_18:1.19
	binutils-2_18-branch:1.19.0.2
	binutils-2_18-branchpoint:1.19
	binutils-csl-coldfire-4_1-32:1.13
	binutils-csl-sourcerygxx-4_1-32:1.13
	binutils-csl-innovasic-fido-3_4_4-33:1.13
	binutils-csl-sourcerygxx-3_4_4-32:1.12
	binutils-csl-coldfire-4_1-30:1.13
	binutils-csl-sourcerygxx-4_1-30:1.13
	binutils-csl-coldfire-4_1-28:1.13
	binutils-csl-sourcerygxx-4_1-29:1.13
	binutils-csl-sourcerygxx-4_1-28:1.13
	binutils-csl-arm-2006q3-27:1.13
	binutils-csl-sourcerygxx-4_1-27:1.13
	binutils-csl-arm-2006q3-26:1.13
	binutils-csl-sourcerygxx-4_1-26:1.13
	binutils-csl-sourcerygxx-4_1-25:1.13
	binutils-csl-sourcerygxx-4_1-24:1.13
	binutils-csl-sourcerygxx-4_1-23:1.13
	binutils-csl-sourcerygxx-4_1-21:1.13
	binutils-csl-arm-2006q3-21:1.13
	binutils-csl-sourcerygxx-4_1-22:1.13
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.13
	binutils-csl-sourcerygxx-4_1-20:1.13
	binutils-csl-arm-2006q3-19:1.13
	binutils-csl-sourcerygxx-4_1-19:1.13
	binutils-csl-sourcerygxx-4_1-18:1.13
	binutils-csl-renesas-4_1-9:1.13
	binutils-csl-sourcerygxx-3_4_4-25:1.12
	binutils-csl-renesas-4_1-8:1.13
	binutils-csl-renesas-4_1-7:1.13
	binutils-csl-renesas-4_1-6:1.13
	binutils-csl-sourcerygxx-4_1-17:1.13
	binutils-csl-sourcerygxx-4_1-14:1.13
	binutils-csl-sourcerygxx-4_1-15:1.13
	binutils-csl-sourcerygxx-4_1-13:1.13
	binutils-2_17:1.13
	binutils-csl-sourcerygxx-4_1-12:1.13
	binutils-csl-sourcerygxx-3_4_4-21:1.13
	binutils-csl-wrs-linux-3_4_4-24:1.12
	binutils-csl-wrs-linux-3_4_4-23:1.12
	binutils-csl-sourcerygxx-4_1-9:1.13
	binutils-csl-sourcerygxx-4_1-8:1.13
	binutils-csl-sourcerygxx-4_1-7:1.13
	binutils-csl-arm-2006q1-6:1.13
	binutils-csl-sourcerygxx-4_1-6:1.13
	binutils-csl-wrs-linux-3_4_4-22:1.12
	binutils-csl-coldfire-4_1-11:1.13
	binutils-csl-sourcerygxx-3_4_4-19:1.13
	binutils-csl-coldfire-4_1-10:1.13
	binutils-csl-sourcerygxx-4_1-5:1.13
	binutils-csl-sourcerygxx-4_1-4:1.13
	binutils-csl-wrs-linux-3_4_4-21:1.12
	binutils-csl-morpho-4_1-4:1.13
	binutils-csl-sourcerygxx-3_4_4-17:1.13
	binutils-csl-wrs-linux-3_4_4-20:1.12
	binutils-2_17-branch:1.13.0.4
	binutils-2_17-branchpoint:1.13
	binutils-csl-2_17-branch:1.13.0.2
	binutils-csl-2_17-branchpoint:1.13
	binutils-csl-gxxpro-3_4-branch:1.12.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.12
	binutils-2_16_1:1.12
	binutils-csl-arm-2005q1b:1.12
	binutils-2_16:1.12
	binutils-csl-arm-2005q1a:1.12
	binutils-csl-arm-2005q1-branch:1.12.0.4
	binutils-csl-arm-2005q1-branchpoint:1.12
	binutils-2_16-branch:1.12.0.2
	binutils-2_16-branchpoint:1.12
	csl-arm-2004-q3d:1.11
	csl-arm-2004-q3:1.11
	binutils-2_15:1.10
	binutils-2_15-branchpoint:1.10
	csl-arm-2004-q1a:1.10
	csl-arm-2004-q1:1.10
	binutils-2_15-branch:1.10.0.6
	cagney_bfdfile-20040213-branch:1.10.0.4
	cagney_bfdfile-20040213-branchpoint:1.10
	cagney_bigcore-20040122-branch:1.10.0.2
	cagney_bigcore-20040122-branchpoint:1.10
	csl-arm-2003-q4:1.10
	binutils-2_14:1.6
	binutils-2_14-branch:1.6.0.2
	binutils-2_14-branchpoint:1.6
	binutils-2_13_2_1:1.4
	binutils-2_13_2:1.4
	binutils-2_13_1:1.4
	binutils-2_13:1.4
	binutils-2_13-branchpoint:1.4
	binutils-2_13-branch:1.4.0.2
	binutils-2_12_1:1.3
	binutils-2_12:1.3
	binutils-2_12-branch:1.3.0.2
	binutils-2_12-branchpoint:1.3
	cygnus_cvs_20020108_pre:1.3
	binutils-2_11_2:1.2.4.1
	binutils-2_11_1:1.2.4.1
	binutils-2_11:1.2
	x86_64versiong3:1.2
	binutils-2_11-branch:1.2.0.4
	binutils-2_10_1:1.2
	binutils-2_10:1.2
	binutils-2_10-branch:1.2.0.2
	binutils-2_10-branchpoint:1.2
	binutils_latest_snapshot:1.26
	repo-unification-2000-02-06:1.2
	binu_ss_19990721:1.2
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.26
date	2011.03.25.17.24.28;	author nickc;	state Exp;
branches;
next	1.25;

1.25
date	2009.12.11.13.42.06;	author nickc;	state Exp;
branches;
next	1.24;

1.24
date	2009.10.18.23.14.09;	author amodra;	state Exp;
branches;
next	1.23;

1.23
date	2009.09.10.13.40.44;	author nickc;	state Exp;
branches;
next	1.22;

1.22
date	2009.09.02.07.22.32;	author amodra;	state Exp;
branches
	1.22.2.1;
next	1.21;

1.21
date	2008.01.25.16.18.40;	author nickc;	state Exp;
branches;
next	1.20;

1.20
date	2008.01.07.23.17.48;	author gkm;	state Exp;
branches;
next	1.19;

1.19
date	2007.07.05.16.54.45;	author nickc;	state Exp;
branches;
next	1.18;

1.18
date	2007.04.28.06.03.36;	author amodra;	state Exp;
branches;
next	1.17;

1.17
date	2007.04.26.14.46.59;	author amodra;	state Exp;
branches;
next	1.16;

1.16
date	2007.04.19.10.43.47;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2006.09.28.12.59.25;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2006.09.16.18.12.17;	author nickc;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.08.14.17.38;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2005.03.03.11.46.12;	author amodra;	state Exp;
branches;
next	1.11;

1.11
date	2004.06.15.01.19.13;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2003.12.06.00.06.12;	author kazu;	state Exp;
branches;
next	1.9;

1.9
date	2003.10.27.13.20.32;	author kazu;	state Exp;
branches;
next	1.8;

1.8
date	2003.09.14.12.20.16;	author aj;	state Exp;
branches;
next	1.7;

1.7
date	2003.07.22.13.33.32;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2002.11.30.08.39.41;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2002.08.05.00.54.11;	author amodra;	state Exp;
branches;
next	1.4;

1.4
date	2002.05.26.14.55.04;	author kazu;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.13.06.43.57;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	99.07.11.20.02.24;	author ian;	state Exp;
branches
	1.2.4.1;
next	1.1;

1.1
date	99.05.03.07.29.10;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.22.2.1
date	2009.09.10.13.42.09;	author nickc;	state Exp;
branches;
next	1.22.2.2;

1.22.2.2
date	2009.10.18.23.14.52;	author amodra;	state Exp;
branches;
next	;

1.2.4.1
date	2001.06.07.03.12.28;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.10;	author rth;	state Exp;
branches;
next	;


desc
@@


1.26
log
@	* prdbg.c (pr_function_type): Close memory leaks.
	(pr_method_type): Likewise.
	(tg_class_static_member): Likewise.
	(tg_class_method_variant): Likewise.
	(tg_class_static_method_variant): Likewise.
@
text
@/* prdbg.c -- Print out generic debugging information.
   Copyright 1995, 1996, 1999, 2002, 2003, 2004, 2005, 2006, 2007, 2008,
   2009, 2011  Free Software Foundation, Inc.
   Written by Ian Lance Taylor <ian@@cygnus.com>.
   Tags style generation written by Salvador E. Tropea <set@@computer.org>.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA
   02110-1301, USA.  */

/* This file prints out the generic debugging information, by
   supplying a set of routines to debug_write.  */

#include "sysdep.h"
#include <assert.h>
#include "bfd.h"
#include "libiberty.h"
#include "demangle.h"
#include "debug.h"
#include "budbg.h"

/* This is the structure we use as a handle for these routines.  */

struct pr_handle
{
  /* File to print information to.  */
  FILE *f;
  /* Current indentation level.  */
  unsigned int indent;
  /* Type stack.  */
  struct pr_stack *stack;
  /* Parameter number we are about to output.  */
  int parameter;
  /* The following are used only by the tags code (tg_).  */
  /* Name of the file we are using.  */
  char *filename;
  /* The BFD.  */
  bfd *abfd;
  /* The symbols table for this BFD.  */
  asymbol **syms;
  /* Pointer to a function to demangle symbols.  */
  char *(*demangler) (bfd *, const char *, int);
};

/* The type stack.  */

struct pr_stack
{
  /* Next element on the stack.  */
  struct pr_stack *next;
  /* This element.  */
  char *type;
  /* Current visibility of fields if this is a class.  */
  enum debug_visibility visibility;
  /* Name of the current method we are handling.  */
  const char *method;
  /* The following are used only by the tags code (tg_).  */
  /* Type for the container (struct, union, class, union class).  */
  const char *flavor;
  /* A comma separated list of parent classes.  */
  char *parents;
  /* How many parents contains parents.  */
  int num_parents;
};

static void indent (struct pr_handle *);
static bfd_boolean push_type (struct pr_handle *, const char *);
static bfd_boolean prepend_type (struct pr_handle *, const char *);
static bfd_boolean append_type (struct pr_handle *, const char *);
static bfd_boolean substitute_type (struct pr_handle *, const char *);
static bfd_boolean indent_type (struct pr_handle *);
static char *pop_type (struct pr_handle *);
static void print_vma (bfd_vma, char *, bfd_boolean, bfd_boolean);
static bfd_boolean pr_fix_visibility
  (struct pr_handle *, enum debug_visibility);
static bfd_boolean pr_start_compilation_unit (void *, const char *);
static bfd_boolean pr_start_source (void *, const char *);
static bfd_boolean pr_empty_type (void *);
static bfd_boolean pr_void_type (void *);
static bfd_boolean pr_int_type (void *, unsigned int, bfd_boolean);
static bfd_boolean pr_float_type (void *, unsigned int);
static bfd_boolean pr_complex_type (void *, unsigned int);
static bfd_boolean pr_bool_type (void *, unsigned int);
static bfd_boolean pr_enum_type
  (void *, const char *, const char **, bfd_signed_vma *);
static bfd_boolean pr_pointer_type (void *);
static bfd_boolean pr_function_type (void *, int, bfd_boolean);
static bfd_boolean pr_reference_type (void *);
static bfd_boolean pr_range_type (void *, bfd_signed_vma, bfd_signed_vma);
static bfd_boolean pr_array_type
  (void *, bfd_signed_vma, bfd_signed_vma, bfd_boolean);
static bfd_boolean pr_set_type (void *, bfd_boolean);
static bfd_boolean pr_offset_type (void *);
static bfd_boolean pr_method_type (void *, bfd_boolean, int, bfd_boolean);
static bfd_boolean pr_const_type (void *);
static bfd_boolean pr_volatile_type (void *);
static bfd_boolean pr_start_struct_type
  (void *, const char *, unsigned int, bfd_boolean, unsigned int);
static bfd_boolean pr_struct_field
  (void *, const char *, bfd_vma, bfd_vma, enum debug_visibility);
static bfd_boolean pr_end_struct_type (void *);
static bfd_boolean pr_start_class_type
  (void *, const char *, unsigned int, bfd_boolean, unsigned int,
   bfd_boolean, bfd_boolean);
static bfd_boolean pr_class_static_member
  (void *, const char *, const char *, enum debug_visibility);
static bfd_boolean pr_class_baseclass
  (void *, bfd_vma, bfd_boolean, enum debug_visibility);
static bfd_boolean pr_class_start_method (void *, const char *);
static bfd_boolean pr_class_method_variant
  (void *, const char *, enum debug_visibility, bfd_boolean, bfd_boolean,
   bfd_vma, bfd_boolean);
static bfd_boolean pr_class_static_method_variant
  (void *, const char *, enum debug_visibility, bfd_boolean, bfd_boolean);
static bfd_boolean pr_class_end_method (void *);
static bfd_boolean pr_end_class_type (void *);
static bfd_boolean pr_typedef_type (void *, const char *);
static bfd_boolean pr_tag_type
  (void *, const char *, unsigned int, enum debug_type_kind);
static bfd_boolean pr_typdef (void *, const char *);
static bfd_boolean pr_tag (void *, const char *);
static bfd_boolean pr_int_constant (void *, const char *, bfd_vma);
static bfd_boolean pr_float_constant (void *, const char *, double);
static bfd_boolean pr_typed_constant (void *, const char *, bfd_vma);
static bfd_boolean pr_variable
  (void *, const char *, enum debug_var_kind, bfd_vma);
static bfd_boolean pr_start_function (void *, const char *, bfd_boolean);
static bfd_boolean pr_function_parameter
  (void *, const char *, enum debug_parm_kind, bfd_vma);
static bfd_boolean pr_start_block (void *, bfd_vma);
static bfd_boolean pr_end_block (void *, bfd_vma);
static bfd_boolean pr_end_function (void *);
static bfd_boolean pr_lineno (void *, const char *, unsigned long, bfd_vma);
static bfd_boolean append_parent (struct pr_handle *, const char *);
/* Only used by tg_ code.  */
static bfd_boolean tg_fix_visibility
  (struct pr_handle *, enum debug_visibility);
static void find_address_in_section (bfd *, asection *, void *);
static void translate_addresses (bfd *, char *, FILE *, asymbol **);
static const char *visibility_name (enum debug_visibility);
/* Tags style replacements.  */
static bfd_boolean tg_start_compilation_unit (void *, const char *);
static bfd_boolean tg_start_source (void *, const char *);
static bfd_boolean tg_enum_type
  (void *, const char *, const char **, bfd_signed_vma *);
static bfd_boolean tg_start_struct_type
  (void *, const char *, unsigned int, bfd_boolean, unsigned int);
static bfd_boolean pr_struct_field
  (void *, const char *, bfd_vma, bfd_vma, enum debug_visibility);
static bfd_boolean tg_struct_field
  (void *, const char *, bfd_vma, bfd_vma, enum debug_visibility);
static bfd_boolean tg_struct_field
  (void *, const char *, bfd_vma, bfd_vma, enum debug_visibility);
static bfd_boolean tg_end_struct_type (void *);
static bfd_boolean tg_start_class_type
  (void *, const char *, unsigned int, bfd_boolean, unsigned int, bfd_boolean, bfd_boolean);
static bfd_boolean tg_class_static_member
  (void *, const char *, const char *, enum debug_visibility);
static bfd_boolean tg_class_baseclass
  (void *, bfd_vma, bfd_boolean, enum debug_visibility);
static bfd_boolean tg_class_method_variant
  (void *, const char *, enum debug_visibility, bfd_boolean, bfd_boolean, bfd_vma, bfd_boolean);
static bfd_boolean tg_class_static_method_variant
  (void *, const char *, enum debug_visibility, bfd_boolean, bfd_boolean);
static bfd_boolean tg_end_class_type (void *);
static bfd_boolean tg_tag_type
  (void *, const char *, unsigned int, enum debug_type_kind);
static bfd_boolean tg_typdef (void *, const char *);
static bfd_boolean tg_tag (void *, const char *);
static bfd_boolean tg_int_constant (void *, const char *, bfd_vma);
static bfd_boolean tg_float_constant (void *, const char *, double);
static bfd_boolean tg_typed_constant (void *, const char *, bfd_vma);
static bfd_boolean tg_variable
  (void *, const char *, enum debug_var_kind, bfd_vma);
static bfd_boolean tg_start_function (void *, const char *, bfd_boolean);
static bfd_boolean tg_function_parameter
  (void *, const char *, enum debug_parm_kind, bfd_vma);
static bfd_boolean tg_start_block (void *, bfd_vma);
static bfd_boolean tg_end_block (void *, bfd_vma);
static bfd_boolean tg_lineno (void *, const char *, unsigned long, bfd_vma);

static const struct debug_write_fns pr_fns =
{
  pr_start_compilation_unit,
  pr_start_source,
  pr_empty_type,
  pr_void_type,
  pr_int_type,
  pr_float_type,
  pr_complex_type,
  pr_bool_type,
  pr_enum_type,
  pr_pointer_type,
  pr_function_type,
  pr_reference_type,
  pr_range_type,
  pr_array_type,
  pr_set_type,
  pr_offset_type,
  pr_method_type,
  pr_const_type,
  pr_volatile_type,
  pr_start_struct_type,
  pr_struct_field,
  pr_end_struct_type,
  pr_start_class_type,
  pr_class_static_member,
  pr_class_baseclass,
  pr_class_start_method,
  pr_class_method_variant,
  pr_class_static_method_variant,
  pr_class_end_method,
  pr_end_class_type,
  pr_typedef_type,
  pr_tag_type,
  pr_typdef,
  pr_tag,
  pr_int_constant,
  pr_float_constant,
  pr_typed_constant,
  pr_variable,
  pr_start_function,
  pr_function_parameter,
  pr_start_block,
  pr_end_block,
  pr_end_function,
  pr_lineno
};

static const struct debug_write_fns tg_fns =
{
  tg_start_compilation_unit,
  tg_start_source,
  pr_empty_type,		/* Same, push_type.  */
  pr_void_type,			/* Same, push_type.  */
  pr_int_type,			/* Same, push_type.  */
  pr_float_type,		/* Same, push_type.  */
  pr_complex_type,		/* Same, push_type.  */
  pr_bool_type,			/* Same, push_type.  */
  tg_enum_type,
  pr_pointer_type,		/* Same, changes to pointer.  */
  pr_function_type,		/* Same, push_type.  */
  pr_reference_type,		/* Same, changes to reference.  */
  pr_range_type,		/* FIXME: What's that?.  */
  pr_array_type,		/* Same, push_type.  */
  pr_set_type,			/* FIXME: What's that?.  */
  pr_offset_type,		/* FIXME: What's that?.  */
  pr_method_type,		/* Same.  */
  pr_const_type,		/* Same, changes to const.  */
  pr_volatile_type,		/* Same, changes to volatile.  */
  tg_start_struct_type,
  tg_struct_field,
  tg_end_struct_type,
  tg_start_class_type,
  tg_class_static_member,
  tg_class_baseclass,
  pr_class_start_method,	/* Same, remembers that's a method.  */
  tg_class_method_variant,
  tg_class_static_method_variant,
  pr_class_end_method,		/* Same, forgets that's a method.  */
  tg_end_class_type,
  pr_typedef_type,		/* Same, just push type.  */
  tg_tag_type,
  tg_typdef,
  tg_tag,
  tg_int_constant,		/* Untested.  */
  tg_float_constant,		/* Untested.  */
  tg_typed_constant,		/* Untested.  */
  tg_variable,
  tg_start_function,
  tg_function_parameter,
  tg_start_block,
  tg_end_block,
  pr_end_function,		/* Same, does nothing.  */
  tg_lineno
};

/* Print out the generic debugging information recorded in dhandle.  */

bfd_boolean
print_debugging_info (FILE *f, void *dhandle, bfd *abfd, asymbol **syms,
		      void *demangler, bfd_boolean as_tags)
{
  struct pr_handle info;

  info.f = f;
  info.indent = 0;
  info.stack = NULL;
  info.parameter = 0;
  info.filename = NULL;
  info.abfd = abfd;
  info.syms = syms;
  info.demangler = (char * (*)(struct bfd *, const char *, int)) demangler;

  if (as_tags)
    {
      fputs ("!_TAG_FILE_FORMAT\t2\t/extended format/\n", f);
      fputs ("!_TAG_FILE_SORTED\t0\t/0=unsorted, 1=sorted/\n", f);
      fputs ("!_TAG_PROGRAM_AUTHOR\tIan Lance Taylor, Salvador E. Tropea and others\t//\n", f);
      fputs ("!_TAG_PROGRAM_NAME\tobjdump\t/From GNU binutils/\n", f);
    }

  return as_tags ? debug_write (dhandle, &tg_fns, (void *) & info)
    : debug_write (dhandle, &pr_fns, (void *) & info);
}

/* Indent to the current indentation level.  */

static void
indent (struct pr_handle *info)
{
  unsigned int i;

  for (i = 0; i < info->indent; i++)
    putc (' ', info->f);
}

/* Push a type on the type stack.  */

static bfd_boolean
push_type (struct pr_handle *info, const char *type)
{
  struct pr_stack *n;

  if (type == NULL)
    return FALSE;

  n = (struct pr_stack *) xmalloc (sizeof *n);
  memset (n, 0, sizeof *n);

  n->type = xstrdup (type);
  n->visibility = DEBUG_VISIBILITY_IGNORE;
  n->method = NULL;
  n->next = info->stack;
  info->stack = n;

  return TRUE;
}

/* Prepend a string onto the type on the top of the type stack.  */

static bfd_boolean
prepend_type (struct pr_handle *info, const char *s)
{
  char *n;

  assert (info->stack != NULL);

  n = (char *) xmalloc (strlen (s) + strlen (info->stack->type) + 1);
  sprintf (n, "%s%s", s, info->stack->type);
  free (info->stack->type);
  info->stack->type = n;

  return TRUE;
}

/* Append a string to the type on the top of the type stack.  */

static bfd_boolean
append_type (struct pr_handle *info, const char *s)
{
  unsigned int len;

  if (s == NULL)
    return FALSE;

  assert (info->stack != NULL);

  len = strlen (info->stack->type);
  info->stack->type = (char *) xrealloc (info->stack->type,
					 len + strlen (s) + 1);
  strcpy (info->stack->type + len, s);

  return TRUE;
}

/* Append a string to the parents on the top of the type stack.  */

static bfd_boolean
append_parent (struct pr_handle *info, const char *s)
{
  unsigned int len;

  if (s == NULL)
    return FALSE;

  assert (info->stack != NULL);

  len = info->stack->parents ? strlen (info->stack->parents) : 0;
  info->stack->parents = (char *) xrealloc (info->stack->parents,
					    len + strlen (s) + 1);
  strcpy (info->stack->parents + len, s);

  return TRUE;
}

/* We use an underscore to indicate where the name should go in a type
   string.  This function substitutes a string for the underscore.  If
   there is no underscore, the name follows the type.  */

static bfd_boolean
substitute_type (struct pr_handle *info, const char *s)
{
  char *u;

  assert (info->stack != NULL);

  u = strchr (info->stack->type, '|');
  if (u != NULL)
    {
      char *n;

      n = (char *) xmalloc (strlen (info->stack->type) + strlen (s));

      memcpy (n, info->stack->type, u - info->stack->type);
      strcpy (n + (u - info->stack->type), s);
      strcat (n, u + 1);

      free (info->stack->type);
      info->stack->type = n;

      return TRUE;
    }

  if (strchr (s, '|') != NULL
      && (strchr (info->stack->type, '{') != NULL
	  || strchr (info->stack->type, '(') != NULL))
    {
      if (! prepend_type (info, "(")
	  || ! append_type (info, ")"))
	return FALSE;
    }

  if (*s == '\0')
    return TRUE;

  return (append_type (info, " ")
	  && append_type (info, s));
}

/* Indent the type at the top of the stack by appending spaces.  */

static bfd_boolean
indent_type (struct pr_handle *info)
{
  unsigned int i;

  for (i = 0; i < info->indent; i++)
    {
      if (! append_type (info, " "))
	return FALSE;
    }

  return TRUE;
}

/* Pop a type from the type stack.  */

static char *
pop_type (struct pr_handle *info)
{
  struct pr_stack *o;
  char *ret;

  assert (info->stack != NULL);

  o = info->stack;
  info->stack = o->next;
  ret = o->type;
  free (o);

  return ret;
}

/* Print a VMA value into a string.  */

static void
print_vma (bfd_vma vma, char *buf, bfd_boolean unsignedp, bfd_boolean hexp)
{
  if (sizeof (vma) <= sizeof (unsigned long))
    {
      if (hexp)
	sprintf (buf, "0x%lx", (unsigned long) vma);
      else if (unsignedp)
	sprintf (buf, "%lu", (unsigned long) vma);
      else
	sprintf (buf, "%ld", (long) vma);
    }
#if BFD_HOST_64BIT_LONG_LONG
  else if (sizeof (vma) <= sizeof (unsigned long long))
    {
#ifndef __MSVCRT__
      if (hexp)
	sprintf (buf, "0x%llx", (unsigned long long) vma);
      else if (unsignedp)
	sprintf (buf, "%llu", (unsigned long long) vma);
      else
	sprintf (buf, "%lld", (long long) vma);
#else
      if (hexp)
	sprintf (buf, "0x%I64x", (unsigned long long) vma);
      else if (unsignedp)
	sprintf (buf, "%I64u", (unsigned long long) vma);
      else
	sprintf (buf, "%I64d", (long long) vma);
#endif
    }
#endif
  else
    {
      buf[0] = '0';
      buf[1] = 'x';
      sprintf_vma (buf + 2, vma);
    }
}

/* Start a new compilation unit.  */

static bfd_boolean
pr_start_compilation_unit (void *p, const char *filename)
{
  struct pr_handle *info = (struct pr_handle *) p;

  assert (info->indent == 0);

  fprintf (info->f, "%s:\n", filename);

  return TRUE;
}

/* Start a source file within a compilation unit.  */

static bfd_boolean
pr_start_source (void *p, const char *filename)
{
  struct pr_handle *info = (struct pr_handle *) p;

  assert (info->indent == 0);

  fprintf (info->f, " %s:\n", filename);

  return TRUE;
}

/* Push an empty type onto the type stack.  */

static bfd_boolean
pr_empty_type (void *p)
{
  struct pr_handle *info = (struct pr_handle *) p;

  return push_type (info, "<undefined>");
}

/* Push a void type onto the type stack.  */

static bfd_boolean
pr_void_type (void *p)
{
  struct pr_handle *info = (struct pr_handle *) p;

  return push_type (info, "void");
}

/* Push an integer type onto the type stack.  */

static bfd_boolean
pr_int_type (void *p, unsigned int size, bfd_boolean unsignedp)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char ab[10];

  sprintf (ab, "%sint%d", unsignedp ? "u" : "", size * 8);
  return push_type (info, ab);
}

/* Push a floating type onto the type stack.  */

static bfd_boolean
pr_float_type (void *p, unsigned int size)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char ab[10];

  if (size == 4)
    return push_type (info, "float");
  else if (size == 8)
    return push_type (info, "double");

  sprintf (ab, "float%d", size * 8);
  return push_type (info, ab);
}

/* Push a complex type onto the type stack.  */

static bfd_boolean
pr_complex_type (void *p, unsigned int size)
{
  struct pr_handle *info = (struct pr_handle *) p;

  if (! pr_float_type (p, size))
    return FALSE;

  return prepend_type (info, "complex ");
}

/* Push a bfd_boolean type onto the type stack.  */

static bfd_boolean
pr_bool_type (void *p, unsigned int size)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char ab[10];

  sprintf (ab, "bool%d", size * 8);

  return push_type (info, ab);
}

/* Push an enum type onto the type stack.  */

static bfd_boolean
pr_enum_type (void *p, const char *tag, const char **names,
	      bfd_signed_vma *values)
{
  struct pr_handle *info = (struct pr_handle *) p;
  unsigned int i;
  bfd_signed_vma val;

  if (! push_type (info, "enum "))
    return FALSE;
  if (tag != NULL)
    {
      if (! append_type (info, tag)
	  || ! append_type (info, " "))
	return FALSE;
    }
  if (! append_type (info, "{ "))
    return FALSE;

  if (names == NULL)
    {
      if (! append_type (info, "/* undefined */"))
	return FALSE;
    }
  else
    {
      val = 0;
      for (i = 0; names[i] != NULL; i++)
	{
	  if (i > 0)
	    {
	      if (! append_type (info, ", "))
		return FALSE;
	    }

	  if (! append_type (info, names[i]))
	    return FALSE;

	  if (values[i] != val)
	    {
	      char ab[20];

	      print_vma (values[i], ab, FALSE, FALSE);
	      if (! append_type (info, " = ")
		  || ! append_type (info, ab))
		return FALSE;
	      val = values[i];
	    }

	  ++val;
	}
    }

  return append_type (info, " }");
}

/* Turn the top type on the stack into a pointer.  */

static bfd_boolean
pr_pointer_type (void *p)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *s;

  assert (info->stack != NULL);

  s = strchr (info->stack->type, '|');
  if (s != NULL && s[1] == '[')
    return substitute_type (info, "(*|)");
  return substitute_type (info, "*|");
}

/* Turn the top type on the stack into a function returning that type.  */

static bfd_boolean
pr_function_type (void *p, int argcount, bfd_boolean varargs)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char **arg_types;
  unsigned int len;
  char *s;

  assert (info->stack != NULL);

  len = 10;

  if (argcount <= 0)
    {
      arg_types = NULL;
      len += 15;
    }
  else
    {
      int i;

      arg_types = (char **) xmalloc (argcount * sizeof *arg_types);
      for (i = argcount - 1; i >= 0; i--)
	{
	  if (! substitute_type (info, ""))
	    {
	      free (arg_types);
	      return FALSE;
	    }
	  arg_types[i] = pop_type (info);
	  if (arg_types[i] == NULL)
	    {
	      free (arg_types);
	      return FALSE;
	    }
	  len += strlen (arg_types[i]) + 2;
	}
      if (varargs)
	len += 5;
    }

  /* Now the return type is on the top of the stack.  */

  s = (char *) xmalloc (len);
  LITSTRCPY (s, "(|) (");

  if (argcount < 0)
    strcat (s, "/* unknown */");
  else
    {
      int i;

      for (i = 0; i < argcount; i++)
	{
	  if (i > 0)
	    strcat (s, ", ");
	  strcat (s, arg_types[i]);
	}
      if (varargs)
	{
	  if (i > 0)
	    strcat (s, ", ");
	  strcat (s, "...");
	}
      if (argcount > 0)
	free (arg_types);
    }

  strcat (s, ")");

  if (! substitute_type (info, s))
    return FALSE;

  free (s);

  return TRUE;
}

/* Turn the top type on the stack into a reference to that type.  */

static bfd_boolean
pr_reference_type (void *p)
{
  struct pr_handle *info = (struct pr_handle *) p;

  assert (info->stack != NULL);

  return substitute_type (info, "&|");
}

/* Make a range type.  */

static bfd_boolean
pr_range_type (void *p, bfd_signed_vma lower, bfd_signed_vma upper)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char abl[20], abu[20];

  assert (info->stack != NULL);

  if (! substitute_type (info, ""))
    return FALSE;

  print_vma (lower, abl, FALSE, FALSE);
  print_vma (upper, abu, FALSE, FALSE);

  return (prepend_type (info, "range (")
	  && append_type (info, "):")
	  && append_type (info, abl)
	  && append_type (info, ":")
	  && append_type (info, abu));
}

/* Make an array type.  */

static bfd_boolean
pr_array_type (void *p, bfd_signed_vma lower, bfd_signed_vma upper,
	       bfd_boolean stringp)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *range_type;
  char abl[20], abu[20], ab[50];

  range_type = pop_type (info);
  if (range_type == NULL)
    return FALSE;

  if (lower == 0)
    {
      if (upper == -1)
	sprintf (ab, "|[]");
      else
	{
	  print_vma (upper + 1, abu, FALSE, FALSE);
	  sprintf (ab, "|[%s]", abu);
	}
    }
  else
    {
      print_vma (lower, abl, FALSE, FALSE);
      print_vma (upper, abu, FALSE, FALSE);
      sprintf (ab, "|[%s:%s]", abl, abu);
    }

  if (! substitute_type (info, ab))
    return FALSE;

  if (strcmp (range_type, "int") != 0)
    {
      if (! append_type (info, ":")
	  || ! append_type (info, range_type))
	return FALSE;
    }

  if (stringp)
    {
      if (! append_type (info, " /* string */"))
	return FALSE;
    }

  return TRUE;
}

/* Make a set type.  */

static bfd_boolean
pr_set_type (void *p, bfd_boolean bitstringp)
{
  struct pr_handle *info = (struct pr_handle *) p;

  if (! substitute_type (info, ""))
    return FALSE;

  if (! prepend_type (info, "set { ")
      || ! append_type (info, " }"))
    return FALSE;

  if (bitstringp)
    {
      if (! append_type (info, "/* bitstring */"))
	return FALSE;
    }

  return TRUE;
}

/* Make an offset type.  */

static bfd_boolean
pr_offset_type (void *p)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *t;

  if (! substitute_type (info, ""))
    return FALSE;

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  return (substitute_type (info, "")
	  && prepend_type (info, " ")
	  && prepend_type (info, t)
	  && append_type (info, "::|"));
}

/* Make a method type.  */

static bfd_boolean
pr_method_type (void *p, bfd_boolean domain, int argcount, bfd_boolean varargs)
{
  struct pr_handle *info = (struct pr_handle *) p;
  unsigned int len;
  char *domain_type;
  char **arg_types;
  char *s;

  len = 10;

  if (! domain)
    domain_type = NULL;
  else
    {
      if (! substitute_type (info, ""))
	return FALSE;
      domain_type = pop_type (info);
      if (domain_type == NULL)
	return FALSE;
      if (CONST_STRNEQ (domain_type, "class ")
	  && strchr (domain_type + sizeof "class " - 1, ' ') == NULL)
	domain_type += sizeof "class " - 1;
      else if (CONST_STRNEQ (domain_type, "union class ")
	       && (strchr (domain_type + sizeof "union class " - 1, ' ')
		   == NULL))
	domain_type += sizeof "union class " - 1;
      len += strlen (domain_type);
    }

  if (argcount <= 0)
    {
      arg_types = NULL;
      len += 15;
    }
  else
    {
      int i;

      arg_types = (char **) xmalloc (argcount * sizeof *arg_types);
      for (i = argcount - 1; i >= 0; i--)
	{
	  if (! substitute_type (info, ""))
	    {
	      free (arg_types);
	      return FALSE;
	    }
	  arg_types[i] = pop_type (info);
	  if (arg_types[i] == NULL)
	    {
	      free (arg_types);
	      return FALSE;
	    }
	  len += strlen (arg_types[i]) + 2;
	}
      if (varargs)
	len += 5;
    }

  /* Now the return type is on the top of the stack.  */

  s = (char *) xmalloc (len);
  if (! domain)
    *s = '\0';
  else
    strcpy (s, domain_type);
  strcat (s, "::| (");

  if (argcount < 0)
    strcat (s, "/* unknown */");
  else
    {
      int i;

      for (i = 0; i < argcount; i++)
	{
	  if (i > 0)
	    strcat (s, ", ");
	  strcat (s, arg_types[i]);
	}
      if (varargs)
	{
	  if (i > 0)
	    strcat (s, ", ");
	  strcat (s, "...");
	}
      if (argcount > 0)
	free (arg_types);
    }

  strcat (s, ")");

  if (! substitute_type (info, s))
    return FALSE;

  free (s);

  return TRUE;
}

/* Make a const qualified type.  */

static bfd_boolean
pr_const_type (void *p)
{
  struct pr_handle *info = (struct pr_handle *) p;

  return substitute_type (info, "const |");
}

/* Make a volatile qualified type.  */

static bfd_boolean
pr_volatile_type (void *p)
{
  struct pr_handle *info = (struct pr_handle *) p;

  return substitute_type (info, "volatile |");
}

/* Start accumulating a struct type.  */

static bfd_boolean
pr_start_struct_type (void *p, const char *tag, unsigned int id,
		      bfd_boolean structp, unsigned int size)
{
  struct pr_handle *info = (struct pr_handle *) p;

  info->indent += 2;

  if (! push_type (info, structp ? "struct " : "union "))
    return FALSE;
  if (tag != NULL)
    {
      if (! append_type (info, tag))
	return FALSE;
    }
  else
    {
      char idbuf[20];

      sprintf (idbuf, "%%anon%u", id);
      if (! append_type (info, idbuf))
	return FALSE;
    }

  if (! append_type (info, " {"))
    return FALSE;
  if (size != 0 || tag != NULL)
    {
      char ab[30];

      if (! append_type (info, " /*"))
	return FALSE;

      if (size != 0)
	{
	  sprintf (ab, " size %u", size);
	  if (! append_type (info, ab))
	    return FALSE;
	}
      if (tag != NULL)
	{
	  sprintf (ab, " id %u", id);
	  if (! append_type (info, ab))
	    return FALSE;
	}
      if (! append_type (info, " */"))
	return FALSE;
    }
  if (! append_type (info, "\n"))
    return FALSE;

  info->stack->visibility = DEBUG_VISIBILITY_PUBLIC;

  return indent_type (info);
}

/* Output the visibility of a field in a struct.  */

static bfd_boolean
pr_fix_visibility (struct pr_handle *info, enum debug_visibility visibility)
{
  const char *s = NULL;
  char *t;
  unsigned int len;

  assert (info->stack != NULL);

  if (info->stack->visibility == visibility)
    return TRUE;

  switch (visibility)
    {
    case DEBUG_VISIBILITY_PUBLIC:
      s = "public";
      break;
    case DEBUG_VISIBILITY_PRIVATE:
      s = "private";
      break;
    case DEBUG_VISIBILITY_PROTECTED:
      s = "protected";
      break;
    case DEBUG_VISIBILITY_IGNORE:
      s = "/* ignore */";
      break;
    default:
      abort ();
      return FALSE;
    }

  /* Trim off a trailing space in the struct string, to make the
     output look a bit better, then stick on the visibility string.  */

  t = info->stack->type;
  len = strlen (t);
  assert (t[len - 1] == ' ');
  t[len - 1] = '\0';

  if (! append_type (info, s)
      || ! append_type (info, ":\n")
      || ! indent_type (info))
    return FALSE;

  info->stack->visibility = visibility;

  return TRUE;
}

/* Add a field to a struct type.  */

static bfd_boolean
pr_struct_field (void *p, const char *name, bfd_vma bitpos, bfd_vma bitsize,
		 enum debug_visibility visibility)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char ab[20];
  char *t;

  if (! substitute_type (info, name))
    return FALSE;

  if (! append_type (info, "; /* "))
    return FALSE;

  if (bitsize != 0)
    {
      print_vma (bitsize, ab, TRUE, FALSE);
      if (! append_type (info, "bitsize ")
	  || ! append_type (info, ab)
	  || ! append_type (info, ", "))
	return FALSE;
    }

  print_vma (bitpos, ab, TRUE, FALSE);
  if (! append_type (info, "bitpos ")
      || ! append_type (info, ab)
      || ! append_type (info, " */\n")
      || ! indent_type (info))
    return FALSE;

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  if (! pr_fix_visibility (info, visibility))
    return FALSE;

  return append_type (info, t);
}

/* Finish a struct type.  */

static bfd_boolean
pr_end_struct_type (void *p)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *s;

  assert (info->stack != NULL);
  assert (info->indent >= 2);

  info->indent -= 2;

  /* Change the trailing indentation to have a close brace.  */
  s = info->stack->type + strlen (info->stack->type) - 2;
  assert (s[0] == ' ' && s[1] == ' ' && s[2] == '\0');

  *s++ = '}';
  *s = '\0';

  return TRUE;
}

/* Start a class type.  */

static bfd_boolean
pr_start_class_type (void *p, const char *tag, unsigned int id,
		     bfd_boolean structp, unsigned int size,
		     bfd_boolean vptr, bfd_boolean ownvptr)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *tv = NULL;

  info->indent += 2;

  if (vptr && ! ownvptr)
    {
      tv = pop_type (info);
      if (tv == NULL)
	return FALSE;
    }

  if (! push_type (info, structp ? "class " : "union class "))
    return FALSE;
  if (tag != NULL)
    {
      if (! append_type (info, tag))
	return FALSE;
    }
  else
    {
      char idbuf[20];

      sprintf (idbuf, "%%anon%u", id);
      if (! append_type (info, idbuf))
	return FALSE;
    }

  if (! append_type (info, " {"))
    return FALSE;
  if (size != 0 || vptr || ownvptr || tag != NULL)
    {
      if (! append_type (info, " /*"))
	return FALSE;

      if (size != 0)
	{
	  char ab[20];

	  sprintf (ab, "%u", size);
	  if (! append_type (info, " size ")
	      || ! append_type (info, ab))
	    return FALSE;
	}

      if (vptr)
	{
	  if (! append_type (info, " vtable "))
	    return FALSE;
	  if (ownvptr)
	    {
	      if (! append_type (info, "self "))
		return FALSE;
	    }
	  else
	    {
	      if (! append_type (info, tv)
		  || ! append_type (info, " "))
		return FALSE;
	    }
	}

      if (tag != NULL)
	{
	  char ab[30];

	  sprintf (ab, " id %u", id);
	  if (! append_type (info, ab))
	    return FALSE;
	}

      if (! append_type (info, " */"))
	return FALSE;
    }

  info->stack->visibility = DEBUG_VISIBILITY_PRIVATE;

  return (append_type (info, "\n")
	  && indent_type (info));
}

/* Add a static member to a class.  */

static bfd_boolean
pr_class_static_member (void *p, const char *name, const char *physname,
			enum debug_visibility visibility)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *t;

  if (! substitute_type (info, name))
    return FALSE;

  if (! prepend_type (info, "static ")
      || ! append_type (info, "; /* ")
      || ! append_type (info, physname)
      || ! append_type (info, " */\n")
      || ! indent_type (info))
    return FALSE;

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  if (! pr_fix_visibility (info, visibility))
    return FALSE;

  return append_type (info, t);
}

/* Add a base class to a class.  */

static bfd_boolean
pr_class_baseclass (void *p, bfd_vma bitpos, bfd_boolean is_virtual,
		    enum debug_visibility visibility)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *t;
  const char *prefix;
  char ab[20];
  char *s, *l, *n;

  assert (info->stack != NULL && info->stack->next != NULL);

  if (! substitute_type (info, ""))
    return FALSE;

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  if (CONST_STRNEQ (t, "class "))
    t += sizeof "class " - 1;

  /* Push it back on to take advantage of the prepend_type and
     append_type routines.  */
  if (! push_type (info, t))
    return FALSE;

  if (is_virtual)
    {
      if (! prepend_type (info, "virtual "))
	return FALSE;
    }

  switch (visibility)
    {
    case DEBUG_VISIBILITY_PUBLIC:
      prefix = "public ";
      break;
    case DEBUG_VISIBILITY_PROTECTED:
      prefix = "protected ";
      break;
    case DEBUG_VISIBILITY_PRIVATE:
      prefix = "private ";
      break;
    default:
      prefix = "/* unknown visibility */ ";
      break;
    }

  if (! prepend_type (info, prefix))
    return FALSE;

  if (bitpos != 0)
    {
      print_vma (bitpos, ab, TRUE, FALSE);
      if (! append_type (info, " /* bitpos ")
	  || ! append_type (info, ab)
	  || ! append_type (info, " */"))
	return FALSE;
    }

  /* Now the top of the stack is something like "public A / * bitpos
     10 * /".  The next element on the stack is something like "class
     xx { / * size 8 * /\n...".  We want to substitute the top of the
     stack in before the {.  */
  s = strchr (info->stack->next->type, '{');
  assert (s != NULL);
  --s;

  /* If there is already a ':', then we already have a baseclass, and
     we must append this one after a comma.  */
  for (l = info->stack->next->type; l != s; l++)
    if (*l == ':')
      break;
  if (! prepend_type (info, l == s ? " : " : ", "))
    return FALSE;

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  n = (char *) xmalloc (strlen (info->stack->type) + strlen (t) + 1);
  memcpy (n, info->stack->type, s - info->stack->type);
  strcpy (n + (s - info->stack->type), t);
  strcat (n, s);

  free (info->stack->type);
  info->stack->type = n;

  free (t);

  return TRUE;
}

/* Start adding a method to a class.  */

static bfd_boolean
pr_class_start_method (void *p, const char *name)
{
  struct pr_handle *info = (struct pr_handle *) p;

  assert (info->stack != NULL);
  info->stack->method = name;
  return TRUE;
}

/* Add a variant to a method.  */

static bfd_boolean
pr_class_method_variant (void *p, const char *physname,
			 enum debug_visibility visibility,
			 bfd_boolean constp, bfd_boolean volatilep,
			 bfd_vma voffset, bfd_boolean context)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *method_type;
  char *context_type;

  assert (info->stack != NULL);
  assert (info->stack->next != NULL);

  /* Put the const and volatile qualifiers on the type.  */
  if (volatilep)
    {
      if (! append_type (info, " volatile"))
	return FALSE;
    }
  if (constp)
    {
      if (! append_type (info, " const"))
	return FALSE;
    }

  /* Stick the name of the method into its type.  */
  if (! substitute_type (info,
			 (context
			  ? info->stack->next->next->method
			  : info->stack->next->method)))
    return FALSE;

  /* Get the type.  */
  method_type = pop_type (info);
  if (method_type == NULL)
    return FALSE;

  /* Pull off the context type if there is one.  */
  if (! context)
    context_type = NULL;
  else
    {
      context_type = pop_type (info);
      if (context_type == NULL)
	return FALSE;
    }

  /* Now the top of the stack is the class.  */

  if (! pr_fix_visibility (info, visibility))
    return FALSE;

  if (! append_type (info, method_type)
      || ! append_type (info, " /* ")
      || ! append_type (info, physname)
      || ! append_type (info, " "))
    return FALSE;
  if (context || voffset != 0)
    {
      char ab[20];

      if (context)
	{
	  if (! append_type (info, "context ")
	      || ! append_type (info, context_type)
	      || ! append_type (info, " "))
	    return FALSE;
	}
      print_vma (voffset, ab, TRUE, FALSE);
      if (! append_type (info, "voffset ")
	  || ! append_type (info, ab))
	return FALSE;
    }

  return (append_type (info, " */;\n")
	  && indent_type (info));
}

/* Add a static variant to a method.  */

static bfd_boolean
pr_class_static_method_variant (void *p, const char *physname,
				enum debug_visibility visibility,
				bfd_boolean constp, bfd_boolean volatilep)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *method_type;

  assert (info->stack != NULL);
  assert (info->stack->next != NULL);
  assert (info->stack->next->method != NULL);

  /* Put the const and volatile qualifiers on the type.  */
  if (volatilep)
    {
      if (! append_type (info, " volatile"))
	return FALSE;
    }
  if (constp)
    {
      if (! append_type (info, " const"))
	return FALSE;
    }

  /* Mark it as static.  */
  if (! prepend_type (info, "static "))
    return FALSE;

  /* Stick the name of the method into its type.  */
  if (! substitute_type (info, info->stack->next->method))
    return FALSE;

  /* Get the type.  */
  method_type = pop_type (info);
  if (method_type == NULL)
    return FALSE;

  /* Now the top of the stack is the class.  */

  if (! pr_fix_visibility (info, visibility))
    return FALSE;

  return (append_type (info, method_type)
	  && append_type (info, " /* ")
	  && append_type (info, physname)
	  && append_type (info, " */;\n")
	  && indent_type (info));
}

/* Finish up a method.  */

static bfd_boolean
pr_class_end_method (void *p)
{
  struct pr_handle *info = (struct pr_handle *) p;

  info->stack->method = NULL;
  return TRUE;
}

/* Finish up a class.  */

static bfd_boolean
pr_end_class_type (void *p)
{
  return pr_end_struct_type (p);
}

/* Push a type on the stack using a typedef name.  */

static bfd_boolean
pr_typedef_type (void *p, const char *name)
{
  struct pr_handle *info = (struct pr_handle *) p;

  return push_type (info, name);
}

/* Push a type on the stack using a tag name.  */

static bfd_boolean
pr_tag_type (void *p, const char *name, unsigned int id,
	     enum debug_type_kind kind)
{
  struct pr_handle *info = (struct pr_handle *) p;
  const char *t, *tag;
  char idbuf[20];

  switch (kind)
    {
    case DEBUG_KIND_STRUCT:
      t = "struct ";
      break;
    case DEBUG_KIND_UNION:
      t = "union ";
      break;
    case DEBUG_KIND_ENUM:
      t = "enum ";
      break;
    case DEBUG_KIND_CLASS:
      t = "class ";
      break;
    case DEBUG_KIND_UNION_CLASS:
      t = "union class ";
      break;
    default:
      abort ();
      return FALSE;
    }

  if (! push_type (info, t))
    return FALSE;
  if (name != NULL)
    tag = name;
  else
    {
      sprintf (idbuf, "%%anon%u", id);
      tag = idbuf;
    }

  if (! append_type (info, tag))
    return FALSE;
  if (name != NULL && kind != DEBUG_KIND_ENUM)
    {
      sprintf (idbuf, " /* id %u */", id);
      if (! append_type (info, idbuf))
	return FALSE;
    }

  return TRUE;
}

/* Output a typedef.  */

static bfd_boolean
pr_typdef (void *p, const char *name)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *s;

  if (! substitute_type (info, name))
    return FALSE;

  s = pop_type (info);
  if (s == NULL)
    return FALSE;

  indent (info);
  fprintf (info->f, "typedef %s;\n", s);

  free (s);

  return TRUE;
}

/* Output a tag.  The tag should already be in the string on the
   stack, so all we have to do here is print it out.  */

static bfd_boolean
pr_tag (void *p, const char *name ATTRIBUTE_UNUSED)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *t;

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  indent (info);
  fprintf (info->f, "%s;\n", t);

  free (t);

  return TRUE;
}

/* Output an integer constant.  */

static bfd_boolean
pr_int_constant (void *p, const char *name, bfd_vma val)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char ab[20];

  indent (info);
  print_vma (val, ab, FALSE, FALSE);
  fprintf (info->f, "const int %s = %s;\n", name, ab);
  return TRUE;
}

/* Output a floating point constant.  */

static bfd_boolean
pr_float_constant (void *p, const char *name, double val)
{
  struct pr_handle *info = (struct pr_handle *) p;

  indent (info);
  fprintf (info->f, "const double %s = %g;\n", name, val);
  return TRUE;
}

/* Output a typed constant.  */

static bfd_boolean
pr_typed_constant (void *p, const char *name, bfd_vma val)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *t;
  char ab[20];

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  indent (info);
  print_vma (val, ab, FALSE, FALSE);
  fprintf (info->f, "const %s %s = %s;\n", t, name, ab);

  free (t);

  return TRUE;
}

/* Output a variable.  */

static bfd_boolean
pr_variable (void *p, const char *name, enum debug_var_kind kind,
	     bfd_vma val)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *t;
  char ab[20];

  if (! substitute_type (info, name))
    return FALSE;

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  indent (info);
  switch (kind)
    {
    case DEBUG_STATIC:
    case DEBUG_LOCAL_STATIC:
      fprintf (info->f, "static ");
      break;
    case DEBUG_REGISTER:
      fprintf (info->f, "register ");
      break;
    default:
      break;
    }
  print_vma (val, ab, TRUE, TRUE);
  fprintf (info->f, "%s /* %s */;\n", t, ab);

  free (t);

  return TRUE;
}

/* Start outputting a function.  */

static bfd_boolean
pr_start_function (void *p, const char *name, bfd_boolean global)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *t;

  if (! substitute_type (info, name))
    return FALSE;

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  indent (info);
  if (! global)
    fprintf (info->f, "static ");
  fprintf (info->f, "%s (", t);

  info->parameter = 1;

  return TRUE;
}

/* Output a function parameter.  */

static bfd_boolean
pr_function_parameter (void *p, const char *name,
		       enum debug_parm_kind kind, bfd_vma val)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *t;
  char ab[20];

  if (kind == DEBUG_PARM_REFERENCE
      || kind == DEBUG_PARM_REF_REG)
    {
      if (! pr_reference_type (p))
	return FALSE;
    }

  if (! substitute_type (info, name))
    return FALSE;

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  if (info->parameter != 1)
    fprintf (info->f, ", ");

  if (kind == DEBUG_PARM_REG || kind == DEBUG_PARM_REF_REG)
    fprintf (info->f, "register ");

  print_vma (val, ab, TRUE, TRUE);
  fprintf (info->f, "%s /* %s */", t, ab);

  free (t);

  ++info->parameter;

  return TRUE;
}

/* Start writing out a block.  */

static bfd_boolean
pr_start_block (void *p, bfd_vma addr)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char ab[20];

  if (info->parameter > 0)
    {
      fprintf (info->f, ")\n");
      info->parameter = 0;
    }

  indent (info);
  print_vma (addr, ab, TRUE, TRUE);
  fprintf (info->f, "{ /* %s */\n", ab);

  info->indent += 2;

  return TRUE;
}

/* Write out line number information.  */

static bfd_boolean
pr_lineno (void *p, const char *filename, unsigned long lineno, bfd_vma addr)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char ab[20];

  indent (info);
  print_vma (addr, ab, TRUE, TRUE);
  fprintf (info->f, "/* file %s line %lu addr %s */\n", filename, lineno, ab);

  return TRUE;
}

/* Finish writing out a block.  */

static bfd_boolean
pr_end_block (void *p, bfd_vma addr)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char ab[20];

  info->indent -= 2;

  indent (info);
  print_vma (addr, ab, TRUE, TRUE);
  fprintf (info->f, "} /* %s */\n", ab);

  return TRUE;
}

/* Finish writing out a function.  */

static bfd_boolean
pr_end_function (void *p ATTRIBUTE_UNUSED)
{
  return TRUE;
}

/* Tags style generation functions start here.  */

/* Variables for address to line translation.  */
static bfd_vma pc;
static const char *filename;
static const char *functionname;
static unsigned int line;
static bfd_boolean found;

/* Look for an address in a section.  This is called via
   bfd_map_over_sections.  */

static void
find_address_in_section (bfd *abfd, asection *section, void *data)
{
  bfd_vma vma;
  bfd_size_type size;
  asymbol **syms = (asymbol **) data;

  if (found)
    return;

  if ((bfd_get_section_flags (abfd, section) & SEC_ALLOC) == 0)
    return;

  vma = bfd_get_section_vma (abfd, section);
  if (pc < vma)
    return;

  size = bfd_get_section_size (section);
  if (pc >= vma + size)
    return;

  found = bfd_find_nearest_line (abfd, section, syms, pc - vma,
				 &filename, &functionname, &line);
}

static void
translate_addresses (bfd *abfd, char *addr_hex, FILE *f, asymbol **syms)
{
  pc = bfd_scan_vma (addr_hex, NULL, 16);
  found = FALSE;
  bfd_map_over_sections (abfd, find_address_in_section, syms);

  if (! found)
    fprintf (f, "??");
  else
    fprintf (f, "%u", line);
}

/* Start a new compilation unit.  */

static bfd_boolean
tg_start_compilation_unit (void * p, const char *fname ATTRIBUTE_UNUSED)
{
  struct pr_handle *info = (struct pr_handle *) p;

  free (info->filename);
  /* Should it be relative? best way to do it here?.  */
  info->filename = strdup (fname);

  return TRUE;
}

/* Start a source file within a compilation unit.  */

static bfd_boolean
tg_start_source (void *p, const char *fname)
{
  struct pr_handle *info = (struct pr_handle *) p;

  free (info->filename);
  /* Should it be relative? best way to do it here?.  */
  info->filename = strdup (fname);

  return TRUE;
}

/* Push an enum type onto the type stack.  */

static bfd_boolean
tg_enum_type (void *p, const char *tag, const char **names,
	      bfd_signed_vma *values)
{
  struct pr_handle *info = (struct pr_handle *) p;
  unsigned int i;
  const char *name;
  char ab[20];

  if (! pr_enum_type (p, tag, names, values))
    return FALSE;

  name = tag ? tag : "unknown";
  /* Generate an entry for the enum.  */
  if (tag)
    fprintf (info->f, "%s\t%s\t0;\"\tkind:e\ttype:%s\n", tag,
	     info->filename, info->stack->type);

  /* Generate entries for the values.  */
  if (names != NULL)
    {
      for (i = 0; names[i] != NULL; i++)
	{
	  print_vma (values[i], ab, FALSE, FALSE);
	  fprintf (info->f, "%s\t%s\t0;\"\tkind:g\tenum:%s\tvalue:%s\n",
		   names[i], info->filename, name, ab);
	}
    }

  return TRUE;
}

/* Start accumulating a struct type.  */

static bfd_boolean
tg_start_struct_type (void *p, const char *tag, unsigned int id,
		      bfd_boolean structp,
		      unsigned int size ATTRIBUTE_UNUSED)
{
  struct pr_handle *info = (struct pr_handle *) p;
  const char *name;
  char idbuf[20];

  if (tag != NULL)
    name = tag;
  else
    {
      name = idbuf;
      sprintf (idbuf, "%%anon%u", id);
    }

  if (! push_type (info, name))
    return FALSE;

  info->stack->flavor = structp ? "struct" : "union";

  fprintf (info->f, "%s\t%s\t0;\"\tkind:%c\n", name, info->filename,
	   info->stack->flavor[0]);

  info->stack->visibility = DEBUG_VISIBILITY_PUBLIC;

  return indent_type (info);
}

/* Output the visibility of a field in a struct.  */

static bfd_boolean
tg_fix_visibility (struct pr_handle *info, enum debug_visibility visibility)
{
  assert (info->stack != NULL);

  if (info->stack->visibility == visibility)
    return TRUE;

  assert (info->stack->visibility != DEBUG_VISIBILITY_IGNORE);

  info->stack->visibility = visibility;

  return TRUE;
}

/* Add a field to a struct type.  */

static bfd_boolean
tg_struct_field (void *p, const char *name, bfd_vma bitpos ATTRIBUTE_UNUSED,
		 bfd_vma bitsize ATTRIBUTE_UNUSED,
		 enum debug_visibility visibility)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *t;

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  if (! tg_fix_visibility (info, visibility))
    return FALSE;

  /* It happens, a bug? */
  if (! name[0])
    return TRUE;

  fprintf (info->f, "%s\t%s\t0;\"\tkind:m\ttype:%s\t%s:%s\taccess:%s\n",
	   name, info->filename, t, info->stack->flavor, info->stack->type,
	   visibility_name (visibility));

  return TRUE;
}

/* Finish a struct type.  */

static bfd_boolean
tg_end_struct_type (void *p ATTRIBUTE_UNUSED)
{
  assert (((struct pr_handle *) p)->stack != NULL);

  return TRUE;
}

/* Start a class type.  */

static bfd_boolean
tg_start_class_type (void *p, const char *tag, unsigned int id,
		     bfd_boolean structp, unsigned int size,
		     bfd_boolean vptr, bfd_boolean ownvptr)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *tv = NULL;
  const char *name;

  info->indent += 2;

  if (vptr && ! ownvptr)
    {
      tv = pop_type (info);
      if (tv == NULL)
	return FALSE;
    }

  if (tag != NULL)
    name = tag;
  else
    {
      char idbuf[20];

      sprintf (idbuf, "%%anon%u", id);
      name = idbuf;
    }

  if (! push_type (info, name))
    return FALSE;

  info->stack->flavor = structp ? "class" : "union class";
  info->stack->parents = NULL;
  info->stack->num_parents = 0;

  if (size != 0 || vptr || ownvptr || tag != NULL)
    {
      if (vptr)
	{
	  if (! append_type (info, " vtable "))
	    return FALSE;
	  if (ownvptr)
	    {
	      if (! append_type (info, "self "))
		return FALSE;
	    }
	  else
	    {
	      if (! append_type (info, tv)
		  || ! append_type (info, " "))
		return FALSE;
	    }
	}
    }

  info->stack->visibility = DEBUG_VISIBILITY_PRIVATE;

  return TRUE;
}

/* Add a static member to a class.  */

static bfd_boolean
tg_class_static_member (void *p, const char *name,
			const char *physname ATTRIBUTE_UNUSED,
			enum debug_visibility visibility)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *t;
  int len_var, len_class;
  char *full_name;

  len_var = strlen (name);
  len_class = strlen (info->stack->next->type);
  full_name = (char *) xmalloc (len_var + len_class + 3);
  if (! full_name)
    return FALSE;
  sprintf (full_name, "%s::%s", info->stack->next->type, name);

  if (! substitute_type (info, full_name))
    {
      free (full_name);
      return FALSE;
    }

  if (! prepend_type (info, "static "))
    {
      free (full_name);
      return FALSE;
    }

  t = pop_type (info);
  if (t == NULL)
    {
      free (full_name);
      return FALSE;
    }

  if (! tg_fix_visibility (info, visibility))
    {
      free (t);
      free (full_name);
      return FALSE;
    }

  fprintf (info->f, "%s\t%s\t0;\"\tkind:x\ttype:%s\tclass:%s\taccess:%s\n",
	   name, info->filename, t, info->stack->type,
	   visibility_name (visibility));
  free (t);
  free (full_name);

  return TRUE;
}

/* Add a base class to a class.  */

static bfd_boolean
tg_class_baseclass (void *p, bfd_vma bitpos ATTRIBUTE_UNUSED,
		    bfd_boolean is_virtual, enum debug_visibility visibility)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *t;
  const char *prefix;

  assert (info->stack != NULL && info->stack->next != NULL);

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  if (CONST_STRNEQ (t, "class "))
    t += sizeof "class " - 1;

  /* Push it back on to take advantage of the prepend_type and
     append_type routines.  */
  if (! push_type (info, t))
    return FALSE;

  if (is_virtual)
    {
      if (! prepend_type (info, "virtual "))
	return FALSE;
    }

  switch (visibility)
    {
    case DEBUG_VISIBILITY_PUBLIC:
      prefix = "public ";
      break;
    case DEBUG_VISIBILITY_PROTECTED:
      prefix = "protected ";
      break;
    case DEBUG_VISIBILITY_PRIVATE:
      prefix = "private ";
      break;
    default:
      prefix = "/* unknown visibility */ ";
      break;
    }

  if (! prepend_type (info, prefix))
    return FALSE;

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  if (info->stack->num_parents && ! append_parent (info, ", "))
    return FALSE;

  if (! append_parent (info, t))
    return FALSE;
  info->stack->num_parents++;

  free (t);

  return TRUE;
}

/* Add a variant to a method.  */

static bfd_boolean
tg_class_method_variant (void *p, const char *physname ATTRIBUTE_UNUSED,
			 enum debug_visibility visibility,
			 bfd_boolean constp, bfd_boolean volatilep,
			 bfd_vma voffset ATTRIBUTE_UNUSED,
			 bfd_boolean context)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *method_type;
  char *context_type;
  char *method_name;

  assert (info->stack != NULL);
  assert (info->stack->next != NULL);

  /* Put the const and volatile qualifiers on the type.  */
  if (volatilep)
    {
      if (! append_type (info, " volatile"))
	return FALSE;
    }
  if (constp)
    {
      if (! append_type (info, " const"))
	return FALSE;
    }

  method_name = strdup (context ? info->stack->next->next->method
			: info->stack->next->method);

  /* Stick the name of the method into its type.  */
  if (! substitute_type (info, method_name))
    {
      free (method_name);
      return FALSE;
    }

  /* Get the type.  */
  method_type = pop_type (info);
  if (method_type == NULL)
    {
      free (method_name);
      return FALSE;
    }

  /* Pull off the context type if there is one.  */
  if (! context)
    context_type = NULL;
  else
    {
      context_type = pop_type (info);
      if (context_type == NULL)
	{
	  free (method_type);
	  free (method_name);
	  return FALSE;
	}
    }

  /* Now the top of the stack is the class.  */
  if (! tg_fix_visibility (info, visibility))
    {
      free (method_type);
      free (method_name);
      free (context_type);
      return FALSE;
    }

  fprintf (info->f, "%s\t%s\t0;\"\tkind:p\ttype:%s\tclass:%s\n",
	   method_name, info->filename, method_type, info->stack->type);
  free (method_type);
  free (method_name);
  free (context_type);

  return TRUE;
}

/* Add a static variant to a method.  */

static bfd_boolean
tg_class_static_method_variant (void *p,
				const char *physname ATTRIBUTE_UNUSED,
				enum debug_visibility visibility,
				bfd_boolean constp, bfd_boolean volatilep)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *method_type;
  char *method_name;

  assert (info->stack != NULL);
  assert (info->stack->next != NULL);
  assert (info->stack->next->method != NULL);

  /* Put the const and volatile qualifiers on the type.  */
  if (volatilep)
    {
      if (! append_type (info, " volatile"))
	return FALSE;
    }
  if (constp)
    {
      if (! append_type (info, " const"))
	return FALSE;
    }

  /* Mark it as static.  */
  if (! prepend_type (info, "static "))
    return FALSE;

  method_name = strdup (info->stack->next->method);
  /* Stick the name of the method into its type.  */
  if (! substitute_type (info, info->stack->next->method))
    {
      free (method_name);
      return FALSE;
    }

  /* Get the type.  */
  method_type = pop_type (info);
  if (method_type == NULL)
    {
      free (method_name);
      return FALSE;
    }

  /* Now the top of the stack is the class.  */
  if (! tg_fix_visibility (info, visibility))
    {
      free (method_type);
      free (method_name);
      return FALSE;
    }

  fprintf (info->f, "%s\t%s\t0;\"\tkind:p\ttype:%s\tclass:%s\taccess:%s\n",
	   method_name, info->filename, method_type, info->stack->type,
	   visibility_name (visibility));
  free (method_type);
  free (method_name);

  return TRUE;
}

/* Finish up a class.  */

static bfd_boolean
tg_end_class_type (void *p)
{
  struct pr_handle *info = (struct pr_handle *) p;

  fprintf (info->f, "%s\t%s\t0;\"\tkind:c\ttype:%s", info->stack->type,
	   info->filename, info->stack->flavor);
  if (info->stack->num_parents)
    {
      fprintf  (info->f, "\tinherits:%s", info->stack->parents);
      free (info->stack->parents);
    }
  fputc ('\n', info->f);

  return tg_end_struct_type (p);
}

/* Push a type on the stack using a tag name.  */

static bfd_boolean
tg_tag_type (void *p, const char *name, unsigned int id,
	     enum debug_type_kind kind)
{
  struct pr_handle *info = (struct pr_handle *) p;
  const char *t, *tag;
  char idbuf[20];

  switch (kind)
    {
    case DEBUG_KIND_STRUCT:
      t = "struct ";
      break;
    case DEBUG_KIND_UNION:
      t = "union ";
      break;
    case DEBUG_KIND_ENUM:
      t = "enum ";
      break;
    case DEBUG_KIND_CLASS:
      t = "class ";
      break;
    case DEBUG_KIND_UNION_CLASS:
      t = "union class ";
      break;
    default:
      abort ();
      return FALSE;
    }

  if (! push_type (info, t))
    return FALSE;
  if (name != NULL)
    tag = name;
  else
    {
      sprintf (idbuf, "%%anon%u", id);
      tag = idbuf;
    }

  if (! append_type (info, tag))
    return FALSE;

  return TRUE;
}

/* Output a typedef.  */

static bfd_boolean
tg_typdef (void *p, const char *name)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *s;

  s = pop_type (info);
  if (s == NULL)
    return FALSE;

  fprintf (info->f, "%s\t%s\t0;\"\tkind:t\ttype:%s\n", name,
	   info->filename, s);

  free (s);

  return TRUE;
}

/* Output a tag.  The tag should already be in the string on the
   stack, so all we have to do here is print it out.  */

static bfd_boolean
tg_tag (void *p ATTRIBUTE_UNUSED, const char *name ATTRIBUTE_UNUSED)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *t;

  t = pop_type (info);
  if (t == NULL)
    return FALSE;
  free (t);

  return TRUE;
}

/* Output an integer constant.  */

static bfd_boolean
tg_int_constant (void *p, const char *name, bfd_vma val)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char ab[20];

  indent (info);
  print_vma (val, ab, FALSE, FALSE);
  fprintf (info->f, "%s\t%s\t0;\"\tkind:v\ttype:const int\tvalue:%s\n",
	   name, info->filename, ab);
  return TRUE;
}

/* Output a floating point constant.  */

static bfd_boolean
tg_float_constant (void *p, const char *name, double val)
{
  struct pr_handle *info = (struct pr_handle *) p;

  indent (info);
  fprintf (info->f, "%s\t%s\t0;\"\tkind:v\ttype:const double\tvalue:%g\n",
	   name, info->filename, val);
  return TRUE;
}

/* Output a typed constant.  */

static bfd_boolean
tg_typed_constant (void *p, const char *name, bfd_vma val)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *t;
  char ab[20];

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  indent (info);
  print_vma (val, ab, FALSE, FALSE);
  fprintf (info->f, "%s\t%s\t0;\"\tkind:v\ttype:const %s\tvalue:%s\n",
	   name, info->filename, t, ab);

  free (t);

  return TRUE;
}

/* Output a variable.  */

static bfd_boolean
tg_variable (void *p, const char *name, enum debug_var_kind kind,
	     bfd_vma val ATTRIBUTE_UNUSED)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *t, *dname, *from_class;

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  dname = NULL;
  if (info->demangler)
    dname = info->demangler (info->abfd, name, DMGL_ANSI | DMGL_PARAMS);

  from_class = NULL;
  if (dname != NULL)
    {
      char *sep;
      sep = strstr (dname, "::");
      if (sep)
	{
	  *sep = 0;
	  name = sep + 2;
	  from_class = dname;
	}
      else
	/* Obscure types as vts and type_info nodes.  */
	name = dname;
    }

  fprintf (info->f, "%s\t%s\t0;\"\tkind:v\ttype:%s", name, info->filename, t);

  switch (kind)
    {
    case DEBUG_STATIC:
    case DEBUG_LOCAL_STATIC:
      fprintf (info->f, "\tfile:");
      break;
    case DEBUG_REGISTER:
      fprintf (info->f, "\tregister:");
      break;
    default:
      break;
    }

  if (from_class)
    fprintf (info->f, "\tclass:%s", from_class);

  if (dname)
    free (dname);

  fprintf (info->f, "\n");

  free (t);

  return TRUE;
}

/* Start outputting a function.  */

static bfd_boolean
tg_start_function (void *p, const char *name, bfd_boolean global)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *dname;

  if (! global)
    info->stack->flavor = "static";
  else
    info->stack->flavor = NULL;

  dname = NULL;
  if (info->demangler)
    dname = info->demangler (info->abfd, name, DMGL_ANSI | DMGL_PARAMS);

  if (! substitute_type (info, dname ? dname : name))
    return FALSE;

  info->stack->method = NULL;
  if (dname != NULL)
    {
      char *sep;
      sep = strstr (dname, "::");
      if (sep)
	{
	  info->stack->method = dname;
	  *sep = 0;
	  name = sep + 2;
	}
      else
	{
	  info->stack->method = "";
	  name = dname;
	}
      sep = strchr (name, '(');
      if (sep)
	*sep = 0;
      /* Obscure functions as type_info function.  */
    }

  info->stack->parents = strdup (name);

  if (! info->stack->method && ! append_type (info, "("))
    return FALSE;

  info->parameter = 1;

  return TRUE;
}

/* Output a function parameter.  */

static bfd_boolean
tg_function_parameter (void *p, const char *name, enum debug_parm_kind kind,
		       bfd_vma val ATTRIBUTE_UNUSED)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char *t;

  if (kind == DEBUG_PARM_REFERENCE
      || kind == DEBUG_PARM_REF_REG)
    {
      if (! pr_reference_type (p))
	return FALSE;
    }

  if (! substitute_type (info, name))
    return FALSE;

  t = pop_type (info);
  if (t == NULL)
    return FALSE;

  if (! info->stack->method)
    {
      if (info->parameter != 1 && ! append_type (info, ", "))
	return FALSE;

      if (kind == DEBUG_PARM_REG || kind == DEBUG_PARM_REF_REG)
	if (! append_type (info, "register "))
	  return FALSE;

      if (! append_type (info, t))
	return FALSE;
    }

  free (t);

  ++info->parameter;

  return TRUE;
}

/* Start writing out a block.  */

static bfd_boolean
tg_start_block (void *p, bfd_vma addr)
{
  struct pr_handle *info = (struct pr_handle *) p;
  char ab[20], kind, *partof;
  char *t;
  bfd_boolean local;

  if (info->parameter > 0)
    {
      info->parameter = 0;

      /* Delayed name.  */
      fprintf (info->f, "%s\t%s\t", info->stack->parents, info->filename);
      free (info->stack->parents);

      print_vma (addr, ab, TRUE, TRUE);
      translate_addresses (info->abfd, ab, info->f, info->syms);
      local = info->stack->flavor != NULL;
      if (info->stack->method && *info->stack->method)
	{
	  kind = 'm';
	  partof = (char *) info->stack->method;
	}
      else
	{
	  kind = 'f';
	  partof = NULL;
	  if (! info->stack->method && ! append_type (info, ")"))
	    return FALSE;
	}
      t = pop_type (info);
      if (t == NULL)
	return FALSE;
      fprintf (info->f, ";\"\tkind:%c\ttype:%s", kind, t);
      if (local)
	fputs ("\tfile:", info->f);
      if (partof)
	{
	  fprintf (info->f, "\tclass:%s", partof);
	  free (partof);
	}
      fputc ('\n', info->f);
    }

  return TRUE;
}

/* Write out line number information.  */

static bfd_boolean
tg_lineno (void *p ATTRIBUTE_UNUSED, const char *fname ATTRIBUTE_UNUSED,
	   unsigned long lineno ATTRIBUTE_UNUSED,
	   bfd_vma addr ATTRIBUTE_UNUSED)
{
  return TRUE;
}

/* Finish writing out a block.  */

static bfd_boolean
tg_end_block (void *p ATTRIBUTE_UNUSED, bfd_vma addr ATTRIBUTE_UNUSED)
{
  return TRUE;
}

/* Convert the visibility value into a human readable name.  */

static const char *
visibility_name (enum debug_visibility visibility)
{
  const char *s;

  switch (visibility)
    {
    case DEBUG_VISIBILITY_PUBLIC:
      s = "public";
      break;
    case DEBUG_VISIBILITY_PRIVATE:
      s = "private";
      break;
    case DEBUG_VISIBILITY_PROTECTED:
      s = "protected";
      break;
    case DEBUG_VISIBILITY_IGNORE:
      s = "/* ignore */";
      break;
    default:
      abort ();
      return FALSE;
    }
  return s;
}
@


1.25
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d3 1
a3 1
   2009  Free Software Foundation, Inc.
d734 4
a737 1
	    return FALSE;
d740 4
a743 1
	    return FALSE;
d961 4
a964 1
	    return FALSE;
d967 4
a970 1
	    return FALSE;
d2190 4
a2193 1
    return FALSE;
d2196 4
a2199 1
    return FALSE;
d2203 4
a2206 1
    return FALSE;
d2209 5
a2213 1
    return FALSE;
d2323 4
a2326 1
    return FALSE;
d2331 4
a2334 1
    return FALSE;
d2343 5
a2347 1
	return FALSE;
d2352 6
a2357 1
    return FALSE;
d2403 4
a2406 1
    return FALSE;
d2411 4
a2414 1
    return FALSE;
d2418 5
a2422 1
    return FALSE;
@


1.24
log
@	PR binutils/10793
	* prdbg.c (tg_end_struct_type): Warning fix.
@
text
@d1950 1
a1950 1
tg_start_compilation_unit (void * p, const char *filename ATTRIBUTE_UNUSED)
d1956 1
a1956 1
  info->filename = strdup (filename);
d1964 1
a1964 1
tg_start_source (void *p, const char *filename)
d1970 1
a1970 1
  info->filename = strdup (filename);
d2747 1
a2747 1
tg_lineno (void *p ATTRIBUTE_UNUSED, const char *filename ATTRIBUTE_UNUSED,
@


1.23
log
@        Updated soruces in binutils/* to compile cleanly with -Wc++-compat.

        * binutils/addr2line.c (slurp_symtab): Fix casts. Introduce
        variable minisyms to avoid aliasing varning.
        * binutils/ar.c: Add casts. (normalize): Use name del instead of
        delete. (display_target_list,display_info_table): Change loop
        counter variable a to int.
        * binutils/bucomm.c: Add casts.
        * binutils/debug.c: Update function to use new names. (struct
        debug_baseclass): Rename member from virtual to
        is_virtual. (struct debug_type_s,struct debug_field_s,struct
        debug_baseclass_s,struct debug_method_s,struct
        debug_method_variant_s,struct debug_type_s): Rename struct from
        avoid name collision.
        * /binutils/debug.h: Use new struct names.
        * binutils/dwarf.c: Add casts. (free_debug_memory): Change loop
        counter variable a to int.
        * binutils/ieee.c: Add casts. (enum ieee_var_kind): Move to top
        level. (ieee_class_baseclass): Rename parameter virtual to
        is_virtual. (ieee_class_method_var): Rename variable virtual to
        is_virtual.
        * binutils/nm.c: Add casts.
        * binutils/objcopy.c: Add casts. (copy_archive): Rename variable
        delete to del.
        * binutils/objdump.c: Add casts. (dump_dwarf_section): Change loop
        counter variable i to int.
        * binutils/prdbg.c: Add
        casts. (pr_class_baseclass,tg_class_baseclass): Rename parameters
        virtual to is_virtual.
        * binutils/readelf.c: Add casts. (struct
        ia64_unw_table_entry,struct hppa_unw_table_entry): Move to top
        level.
        * binutils/size.c: Add casts.
        * binutils/stabs.c (parse_stab_type, parse_stab_range_type)
        (parse_stab_cpp_abbrev): Rename parameter from typename to
        type_name. (parse_stab_baseclasses): Rename variable virtual to
        is_virtual.
        * binutils/strings.c: Add casts.
        * binutils/wrstabs.c (stab_class_baseclass): Rename parameter
        virtual to is_virtual.
@
text
@d2091 1
a2091 2
  struct pr_handle *info = (struct pr_handle *) p;
  assert (info->stack != NULL);
@


1.22
log
@update copyright dates
@
text
@d2 2
a3 2
   Copyright 1995, 1996, 1999, 2002, 2003, 2004, 2005, 2006, 2007, 2008
   Free Software Foundation, Inc.
d306 1
a306 1
  info.demangler = demangler;
d746 1
a746 1
  s = xmalloc (len);
d1320 1
a1320 1
pr_class_baseclass (void *p, bfd_vma bitpos, bfd_boolean virtual,
d1346 1
a1346 1
  if (virtual)
d2173 1
a2173 1
  full_name = xmalloc (len_var + len_class + 3);
d2204 1
a2204 1
		    bfd_boolean virtual, enum debug_visibility visibility)
d2224 1
a2224 1
  if (virtual)
@


1.22.2.1
log
@        Update soruces to compile cleanly with -Wc++-compat:

        * addr2line.c (slurp_symtab): Fix casts. Introduce variable
        minisyms to avoid aliasing varning.
        * ar.c: Add casts.
        (normalize): Use name del instead of delete.
        (display_target_list,display_info_table): Change loop counter
        variable a to int.
        * bucomm.c: Add casts.
        * debug.c: Update function to use new names.
        (struct debug_baseclass): Rename member from virtual to
        is_virtual.
        (struct debug_type_s, struct debug_field_s, struct
        debug_baseclass_s, struct debug_method_s, struct
        debug_method_variant_s, struct debug_type_s): Rename struct from
        avoid name collision.
        * debug.h: Use new struct names.
        * dwarf.c: Add casts.
        (free_debug_memory): Change loop counter variable a to int.
        * ieee.c: Add casts.
        (enum ieee_var_kind): Move to top level.
        (ieee_class_baseclass): Rename parameter virtual to is_virtual.
        (ieee_class_method_var): Rename variable virtual to is_virtual.
        * nm.c: Add casts.
        * objcopy.c: Add casts.
        (copy_archive): Rename variable delete to del.
        * objdump.c: Add casts.
        (dump_dwarf_section): Change loop counter variable i to int.
        * prdbg.c: Add casts.
        (pr_class_baseclass,tg_class_baseclass): Rename parameters virtual
        to is_virtual.
        * readelf.c: Add casts.
        (struct ia64_unw_table_entry,struct hppa_unw_table_entry): Move to
        top level.
        * size.c: Add casts.
        * stabs.c (parse_stab_type, parse_stab_range_type,
        (parse_stab_cpp_abbrev): Rename parameter from typename to
        type_name.
        (parse_stab_baseclasses): Rename variable virtual to is_virtual.
        * strings.c: Add casts.
        * wrstabs.c (stab_class_baseclass): Rename parameter virtual to
        is_virtual.
@
text
@d306 1
a306 1
  info.demangler = (char * (*)(struct bfd *, const char *, int)) demangler;
d746 1
a746 1
  s = (char *) xmalloc (len);
d1320 1
a1320 1
pr_class_baseclass (void *p, bfd_vma bitpos, bfd_boolean is_virtual,
d1346 1
a1346 1
  if (is_virtual)
d2173 1
a2173 1
  full_name = (char *) xmalloc (len_var + len_class + 3);
d2204 1
a2204 1
		    bfd_boolean is_virtual, enum debug_visibility visibility)
d2224 1
a2224 1
  if (is_virtual)
@


1.22.2.2
log
@	PR binutils/10793
	* prdbg.c (tg_end_struct_type): Warning fix.
@
text
@d2091 2
a2092 1
  assert (((struct pr_handle *) p)->stack != NULL);
@


1.21
log
@Add mingw I64 support for printing long and long long values
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1999, 2002, 2003, 2004, 2006, 2007, 2008
@


1.20
log
@        * prdbg.c (print_vma): Print as long long, if host supports it.
@
text
@d505 1
d512 8
a1953 2
  fprintf (stderr, "New compilation unit: %s\n", filename);

@


1.19
log
@Change sources over to using GPLv3
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1999, 2002, 2003, 2004, 2006, 2007
d502 11
@


1.18
log
@	* prdbg.c (tg_variable): Adjust for changed demangler.
	(tg_start_function): Likewise.
@
text
@d11 1
a11 1
   the Free Software Foundation; either version 2 of the License, or
@


1.17
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d2528 1
a2528 2
  char *t;
  const char *dname, *from_class;
d2534 1
a2534 1
  dname = name;
d2536 1
a2536 8
    {
      dname = info->demangler (info->abfd, name, DMGL_ANSI | DMGL_PARAMS);
      if (strcmp (name, dname) == 0)
	{
	  free ((char *) dname);
	  dname = name;
	}
    }
d2538 2
a2539 1
  if (dname != name)
d2550 2
a2551 5
	{
	  /* Obscure types as vts and type_info nodes.  */
	  name = dname;
	  from_class = NULL;
	}
a2552 2
  else
    from_class = NULL;
d2570 4
a2573 4
    {
      fprintf (info->f, "\tclass:%s",from_class);
      free ((char *) dname);
    }
d2588 1
a2588 1
  const char *dname;
d2595 1
a2595 1
  dname = name;
d2597 1
a2597 8
    {
      dname = info->demangler (info->abfd, name, DMGL_ANSI | DMGL_PARAMS);
      if (strcmp (name, dname) == 0)
	{
	  free ((char *) dname);
	  dname = name;
	}
    }
d2599 1
a2599 1
  if (! substitute_type (info, dname))
d2602 2
a2603 1
  if (dname != name)
a2622 2
  else
    info->stack->method = NULL;
@


1.16
log
@	* budemang.c: Delete.
	* budemang.h: Delete.
	* addr2line.c (translate_addresses): Call bfd_demangle rather than
	demangle.
	* nm.c (print_symname): Likewise.
	* objdump.c (objdump_print_symname, dump_symbols): Likewise.
	(dump_bfd): Likewise.
	* prdbg.c (struct pr_handle <demangler>): Add int param.
	(tg_variable, tg_start_function): Adjust demangler calls.
	* Makefile.am: Remove mention of budemang.[ch].  Run "make dep-am".
	* Makefile.in: Regenerate.
	* po/POTFILES.in: Regenerate.
@
text
@d27 1
a27 1
#include <stdio.h>
a28 1

a29 1
#include "bucomm.h"
@


1.15
log
@* bfd-in.h (CONST_STRNCPY) : Delete.
  (LITSTRCPY) : New.
  (LITMEMCPY) : New.
* bfd-in2.h : Regenerate.
* elflink.c  (bfd_elf_gc_sections) : Use LITMEMCPY. Don't manually calculate string lengths.
* nlmcode.h (nlm_swap_auxiliary_headers_in) : Use LITMEMCPY.
* nlmconv.c (main) : Use LITMEMCPY.
* prdbg.c (tg_class_static_member) : Use LITSTRCPY.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1999, 2002, 2003, 2004, 2006
d33 1
d57 1
a57 1
  char *(*demangler) (bfd *, const char *);
d2540 1
a2540 1
      dname = info->demangler (info->abfd, name);
d2612 1
a2612 1
      dname = info->demangler (info->abfd, name);
@


1.14
log
@* bfd-in.h (STRING_AND_COMMA): New macro.  Takes one constant string as its
  argument and emits the string followed by a comma and then the length of
  the string.
  (CONST_STRNEQ): New macro.  Checks to see if a variable string has a constant
  string as its initial characters.
  (CONST_STRNCPY): New macro.  Copies a constant string to the start of a
  variable string.
* bfd-in2.h: Regenerate.
* <remainign files>: Make use of the new macros.
@
text
@d727 2
a728 2
  s = (char *) xmalloc (len);
  strcpy (s, "(|) (");
d2156 1
a2156 1
  full_name = (char *) xmalloc (len_var + len_class + 3);
d2159 1
a2159 3
  memcpy (full_name, info->stack->next->type, len_class);
  memcpy (full_name + len_class, STRING_COMMA_LEN ("::"));
  memcpy (full_name + len_class + 2, name, len_var + 1);
@


1.13
log
@Update FSF address
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 1999, 2002, 2003, 2004
d913 1
a913 1
      if (strncmp (domain_type, "class ", sizeof "class " - 1) == 0
d916 1
a916 2
      else if (strncmp (domain_type, "union class ",
			sizeof "union class ") == 0
d1319 1
a1319 1
  if (strncmp (t, "class ", sizeof "class " - 1) == 0)
d2160 1
a2160 1
  memcpy (full_name + len_class, "::", 2);
d2201 1
a2201 1
  if (strncmp (t, "class ", sizeof "class " - 1) == 0)
@


1.12
log
@update copyright dates
@
text
@d21 2
a22 2
   Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA
   02111-1307, USA.  */
@


1.11
log
@	* objcopy.c (copy_section): Use bfd_get_section_size instead of
	_raw_size or bfd_get_section_size_before_reloc.  Don't set reloc_done.
	(compare_section_lma): Likewise.
	* addr2line.c (find_address_in_section): Likewise.
	* coffgrok.c (do_sections_p1): Likewise.
	* dlltool.c (scan_drectve_symbols): Likewise.
	* nlmconv.c (main): Likewise.
	(copy_sections): Likewise.
	(powerpc_mangle_relocs): Likewise.
	* objdump.c (disassemble_section): Likewise.
	* prdbg.c (find_address_in_section): Likewise.
	* size.c (berkeley_sum): Likewise.
	* srconv.c (wr_ob): Likewise.
	* strings.c (strings_a_section): Likewise.
@
text
@d2 2
a3 1
   Copyright 1995, 1996, 2002, 2003, 2004 Free Software Foundation, Inc.
@


1.10
log
@	* ChangeLog-9197: Fix comment typos.
	* coffgrok.c: Likewise.
	* filemode.c: Likewise.
	* objcopy.c: Likewise.
	* objdump.c: Likewise.
	* prdbg.c: Likewise.
	* stabs.c: Likewise.
	* unwind-ia64.c: Likewise.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 2002, 2003 Free Software Foundation, Inc.
d1907 1
a1907 1
  size = bfd_get_section_size_before_reloc (section);
@


1.9
log
@	* ChangeLog: Fix typos.
	* ChangeLog-9197: Likewise.
	* ChangeLog-9899: Likewise.
	* NEWS: Likewise.
	* ar.c: Fix comment typos.
	* arsup.c: Likewise.
	* coffgrok.c: Likewise.
	* debug.c: Likewise.
	* debug.h: Likewise.
	* dlltool.c: Likewise.
	* ieee.c: Likewise.
	* nm.c: Likewise.
	* objdump.c: Likewise.
	* prdbg.c: Likewise.
	* readelf.c: Likewise.
	* resrc.c: Likewise.
	* sysinfo.y: Likewise.
	* windres.c: Likewise.
@
text
@d2058 1
a2058 1
  /* It happends, a bug? */
@


1.8
log
@	* addr2line.c: Convert to ISO C90 prototypes, change PTR, remove
	unneeded (void *) casts.
	* ar.c: Likewise.
	* arlex.l: Likewise.
	* arparse.y: Likewise.
	* arsup.c: Likewise.
	* binemul.c: Likewise.
	* binemul.h: Likewise.
	* bucomm.c: Likewise.
	* bucomm.h: Likewise.
	* budbg.h: Likewise.
	* budemang.c: Likewise.
	* budemang.h: Likewise.
	* coffdump.c: Likewise.
	* coffgrok.c: Likewise.
	* cxxfilt.c: Likewise.
	* debug.c: Likewise.
	* debug.h: Likewise.
	* deflex.l: Likewise.
	* dlltool.c: Likewise.
	* dlltool.h: Likewise.
	* dllwrap.c: Likewise.
	* emul_aix.c: Likewise.
	* filemode.c: Likewise.
	* ieee.c: Likewise.
	* nlmconv.c: Likewise.
	* nlmconv.h: Likewise.
	* nlmheader.y: Likewise.
	* nm.c: Likewise.
	* prdbg.c: Likewise.
	* rclex.l: Likewise.
	* rcparse.y: Likewise.
	* rdcoff.c: Likewise.
	* rddbg.c: Likewise.
	* rename.c: Likewise.
	* resbin.c: Likewise.
	* rescoff.c: Likewise.
	* resrc.c: Likewise.
	* size.c: Likewise.
	* srconv.c: Likewise.
	* stabs.c: Likewise.
	* strings.c: Likewise.
	* sysdump.c: Likewise.
	* sysinfo.y: Likewise.
	* syslex.l: Likewise.
	* unwind-ia64.c: Likewise.
	* unwind-ia64.h: Likewise.
	* version.c: Likewise.
	* windres.c: Likewise.
	* windres.h: Likewise.
	* winduni.c: Likewise.
	* wrstabs.c: Likewise.
@
text
@d270 1
a270 1
  pr_class_start_method,	/* Same, remmembers that's a method.  */
@


1.7
log
@* objdump.c: New command line option --debugging-tags.
* doc/binutils.texi: Document new command line option.
* prdbg.c: Code to print the debug info as tags compatible with ctags.
* budbg.h: Adjust prototype.
* NEWS: Mention new switch
@
text
@d79 8
a86 16
static void indent
  PARAMS ((struct pr_handle *));
static bfd_boolean push_type
  PARAMS ((struct pr_handle *, const char *));
static bfd_boolean prepend_type
  PARAMS ((struct pr_handle *, const char *));
static bfd_boolean append_type
  PARAMS ((struct pr_handle *, const char *));
static bfd_boolean substitute_type
  PARAMS ((struct pr_handle *, const char *));
static bfd_boolean indent_type
  PARAMS ((struct pr_handle *));
static char *pop_type
  PARAMS ((struct pr_handle *));
static void print_vma
  PARAMS ((bfd_vma, char *, bfd_boolean, bfd_boolean));
d88 9
a96 17
  PARAMS ((struct pr_handle *, enum debug_visibility));
static bfd_boolean pr_start_compilation_unit
  PARAMS ((PTR, const char *));
static bfd_boolean pr_start_source
  PARAMS ((PTR, const char *));
static bfd_boolean pr_empty_type
  PARAMS ((PTR));
static bfd_boolean pr_void_type
  PARAMS ((PTR));
static bfd_boolean pr_int_type
  PARAMS ((PTR, unsigned int, bfd_boolean));
static bfd_boolean pr_float_type
  PARAMS ((PTR, unsigned int));
static bfd_boolean pr_complex_type
  PARAMS ((PTR, unsigned int));
static bfd_boolean pr_bool_type
  PARAMS ((PTR, unsigned int));
d98 5
a102 9
  PARAMS ((PTR, const char *, const char **, bfd_signed_vma *));
static bfd_boolean pr_pointer_type
  PARAMS ((PTR));
static bfd_boolean pr_function_type
  PARAMS ((PTR, int, bfd_boolean));
static bfd_boolean pr_reference_type
  PARAMS ((PTR));
static bfd_boolean pr_range_type
  PARAMS ((PTR, bfd_signed_vma, bfd_signed_vma));
d104 6
a109 11
  PARAMS ((PTR, bfd_signed_vma, bfd_signed_vma, bfd_boolean));
static bfd_boolean pr_set_type
  PARAMS ((PTR, bfd_boolean));
static bfd_boolean pr_offset_type
  PARAMS ((PTR));
static bfd_boolean pr_method_type
  PARAMS ((PTR, bfd_boolean, int, bfd_boolean));
static bfd_boolean pr_const_type
  PARAMS ((PTR));
static bfd_boolean pr_volatile_type
  PARAMS ((PTR));
d111 1
a111 1
  PARAMS ((PTR, const char *, unsigned int, bfd_boolean, unsigned int));
d113 2
a114 3
  PARAMS ((PTR, const char *, bfd_vma, bfd_vma, enum debug_visibility));
static bfd_boolean pr_end_struct_type
  PARAMS ((PTR));
d116 2
a117 2
  PARAMS ((PTR, const char *, unsigned int, bfd_boolean, unsigned int,
	   bfd_boolean, bfd_boolean));
d119 1
a119 1
  PARAMS ((PTR, const char *, const char *, enum debug_visibility));
d121 2
a122 3
  PARAMS ((PTR, bfd_vma, bfd_boolean, enum debug_visibility));
static bfd_boolean pr_class_start_method
  PARAMS ((PTR, const char *));
d124 2
a125 2
  PARAMS ((PTR, const char *, enum debug_visibility, bfd_boolean, bfd_boolean,
	   bfd_vma, bfd_boolean));
d127 4
a130 8
  PARAMS ((PTR, const char *, enum debug_visibility, bfd_boolean,
	   bfd_boolean));
static bfd_boolean pr_class_end_method
  PARAMS ((PTR));
static bfd_boolean pr_end_class_type
  PARAMS ((PTR));
static bfd_boolean pr_typedef_type
  PARAMS ((PTR, const char *));
d132 6
a137 11
  PARAMS ((PTR, const char *, unsigned int, enum debug_type_kind));
static bfd_boolean pr_typdef
  PARAMS ((PTR, const char *));
static bfd_boolean pr_tag
  PARAMS ((PTR, const char *));
static bfd_boolean pr_int_constant
  PARAMS ((PTR, const char *, bfd_vma));
static bfd_boolean pr_float_constant
  PARAMS ((PTR, const char *, double));
static bfd_boolean pr_typed_constant
  PARAMS ((PTR, const char *, bfd_vma));
d139 2
a140 3
  PARAMS ((PTR, const char *, enum debug_var_kind, bfd_vma));
static bfd_boolean pr_start_function
  PARAMS ((PTR, const char *, bfd_boolean));
d142 5
a146 9
  PARAMS ((PTR, const char *, enum debug_parm_kind, bfd_vma));
static bfd_boolean pr_start_block
  PARAMS ((PTR, bfd_vma));
static bfd_boolean pr_end_block
  PARAMS ((PTR, bfd_vma));
static bfd_boolean pr_end_function
  PARAMS ((PTR));
static bfd_boolean pr_lineno
  PARAMS ((PTR, const char *, unsigned long, bfd_vma));
d149 2
a150 1
static bfd_boolean tg_fix_visibility (struct pr_handle *, enum debug_visibility);
d157 10
a166 5
static bfd_boolean tg_enum_type (void *, const char *, const char **, bfd_signed_vma *);
static bfd_boolean tg_start_struct_type (void *, const char *, unsigned int, bfd_boolean, unsigned int);
static bfd_boolean pr_struct_field (void *, const char *, bfd_vma, bfd_vma, enum debug_visibility);
static bfd_boolean tg_struct_field (void *, const char *, bfd_vma, bfd_vma, enum debug_visibility);
static bfd_boolean tg_struct_field  (void *, const char *, bfd_vma, bfd_vma, enum debug_visibility);
d168 10
a177 5
static bfd_boolean tg_start_class_type (void *, const char *, unsigned int, bfd_boolean, unsigned int, bfd_boolean, bfd_boolean);
static bfd_boolean tg_class_static_member (void *, const char *, const char *, enum debug_visibility);
static bfd_boolean tg_class_baseclass (void *, bfd_vma, bfd_boolean, enum debug_visibility);
static bfd_boolean tg_class_method_variant (void *, const char *, enum debug_visibility, bfd_boolean, bfd_boolean, bfd_vma, bfd_boolean);
static bfd_boolean tg_class_static_method_variant (void *, const char *, enum debug_visibility, bfd_boolean, bfd_boolean);
d179 2
a180 1
static bfd_boolean tg_tag_type (void *, const char *, unsigned int, enum debug_type_kind);
d186 2
a187 1
static bfd_boolean tg_variable (void *, const char *, enum debug_var_kind, bfd_vma);
d189 2
a190 1
static bfd_boolean tg_function_parameter (void *, const char *, enum debug_parm_kind, bfd_vma);
d294 2
a295 7
print_debugging_info (f, dhandle, abfd, syms, demangler, as_tags)
     FILE *f;
     PTR dhandle;
     bfd *abfd;
     asymbol **syms;
     PTR demangler;
     bfd_boolean as_tags;
d323 1
a323 2
indent (info)
     struct pr_handle *info;
d334 1
a334 3
push_type (info, type)
     struct pr_handle *info;
     const char *type;
d356 1
a356 3
prepend_type (info, s)
     struct pr_handle *info;
     const char *s;
d373 1
a373 3
append_type (info, s)
     struct pr_handle *info;
     const char *s;
d415 1
a415 3
substitute_type (info, s)
     struct pr_handle *info;
     const char *s;
d457 1
a457 2
indent_type (info)
     struct pr_handle *info;
d473 1
a473 2
pop_type (info)
     struct pr_handle *info;
d491 1
a491 5
print_vma (vma, buf, unsignedp, hexp)
     bfd_vma vma;
     char *buf;
     bfd_boolean unsignedp;
     bfd_boolean hexp;
d513 1
a513 3
pr_start_compilation_unit (p, filename)
     PTR p;
     const char *filename;
d527 1
a527 3
pr_start_source (p, filename)
     PTR p;
     const char *filename;
d541 1
a541 2
pr_empty_type (p)
     PTR p;
d551 1
a551 2
pr_void_type (p)
     PTR p;
d561 1
a561 4
pr_int_type (p, size, unsignedp)
     PTR p;
     unsigned int size;
     bfd_boolean unsignedp;
d573 1
a573 3
pr_float_type (p, size)
     PTR p;
     unsigned int size;
d590 1
a590 3
pr_complex_type (p, size)
     PTR p;
     unsigned int size;
d603 1
a603 3
pr_bool_type (p, size)
     PTR p;
     unsigned int size;
d616 2
a617 5
pr_enum_type (p, tag, names, values)
     PTR p;
     const char *tag;
     const char **names;
     bfd_signed_vma *values;
d674 1
a674 2
pr_pointer_type (p)
     PTR p;
d690 1
a690 4
pr_function_type (p, argcount, varargs)
     PTR p;
     int argcount;
     bfd_boolean varargs;
d764 1
a764 2
pr_reference_type (p)
     PTR p;
d776 1
a776 4
pr_range_type (p, lower, upper)
     PTR p;
     bfd_signed_vma lower;
     bfd_signed_vma upper;
d799 2
a800 5
pr_array_type (p, lower, upper, stringp)
     PTR p;
     bfd_signed_vma lower;
     bfd_signed_vma upper;
     bfd_boolean stringp;
d849 1
a849 3
pr_set_type (p, bitstringp)
     PTR p;
     bfd_boolean bitstringp;
d872 1
a872 2
pr_offset_type (p)
     PTR p;
d893 1
a893 5
pr_method_type (p, domain, argcount, varargs)
     PTR p;
     bfd_boolean domain;
     int argcount;
     bfd_boolean varargs;
d990 1
a990 2
pr_const_type (p)
     PTR p;
d1000 1
a1000 2
pr_volatile_type (p)
     PTR p;
d1010 2
a1011 6
pr_start_struct_type (p, tag, id, structp, size)
     PTR p;
     const char *tag;
     unsigned int id;
     bfd_boolean structp;
     unsigned int size;
d1068 1
a1068 3
pr_fix_visibility (info, visibility)
     struct pr_handle *info;
     enum debug_visibility visibility;
d1119 2
a1120 6
pr_struct_field (p, name, bitpos, bitsize, visibility)
     PTR p;
     const char *name;
     bfd_vma bitpos;
     bfd_vma bitsize;
     enum debug_visibility visibility;
d1161 1
a1161 2
pr_end_struct_type (p)
     PTR p;
d1184 3
a1186 8
pr_start_class_type (p, tag, id, structp, size, vptr, ownvptr)
     PTR p;
     const char *tag;
     unsigned int id;
     bfd_boolean structp;
     unsigned int size;
     bfd_boolean vptr;
     bfd_boolean ownvptr;
d1272 2
a1273 5
pr_class_static_member (p, name, physname, visibility)
     PTR p;
     const char *name;
     const char *physname;
     enum debug_visibility visibility;
d1301 2
a1302 5
pr_class_baseclass (p, bitpos, virtual, visibility)
     PTR p;
     bfd_vma bitpos;
     bfd_boolean virtual;
     enum debug_visibility visibility;
d1397 1
a1397 3
pr_class_start_method (p, name)
     PTR p;
     const char *name;
d1409 4
a1412 9
pr_class_method_variant (p, physname, visibility, constp, volatilep, voffset,
			 context)
     PTR p;
     const char *physname;
     enum debug_visibility visibility;
     bfd_boolean constp;
     bfd_boolean volatilep;
     bfd_vma voffset;
     bfd_boolean context;
d1489 3
a1491 6
pr_class_static_method_variant (p, physname, visibility, constp, volatilep)
     PTR p;
     const char *physname;
     enum debug_visibility visibility;
     bfd_boolean constp;
     bfd_boolean volatilep;
d1540 1
a1540 2
pr_class_end_method (p)
     PTR p;
d1551 1
a1551 2
pr_end_class_type (p)
     PTR p;
d1559 1
a1559 3
pr_typedef_type (p, name)
     PTR p;
     const char *name;
d1569 2
a1570 5
pr_tag_type (p, name, id, kind)
     PTR p;
     const char *name;
     unsigned int id;
     enum debug_type_kind kind;
d1623 1
a1623 3
pr_typdef (p, name)
     PTR p;
     const char *name;
d1647 1
a1647 3
pr_tag (p, name)
     PTR p;
     const char *name ATTRIBUTE_UNUSED;
d1667 1
a1667 4
pr_int_constant (p, name, val)
     PTR p;
     const char *name;
     bfd_vma val;
d1681 1
a1681 4
pr_float_constant (p, name, val)
     PTR p;
     const char *name;
     double val;
d1693 1
a1693 4
pr_typed_constant (p, name, val)
     PTR p;
     const char *name;
     bfd_vma val;
d1715 2
a1716 5
pr_variable (p, name, kind, val)
     PTR p;
     const char *name;
     enum debug_var_kind kind;
     bfd_vma val;
d1753 1
a1753 4
pr_start_function (p, name, global)
     PTR p;
     const char *name;
     bfd_boolean global;
d1778 2
a1779 5
pr_function_parameter (p, name, kind, val)
     PTR p;
     const char *name;
     enum debug_parm_kind kind;
     bfd_vma val;
d1818 1
a1818 3
pr_start_block (p, addr)
     PTR p;
     bfd_vma addr;
d1841 1
a1841 5
pr_lineno (p, filename, lineno, addr)
     PTR p;
     const char *filename;
     unsigned long lineno;
     bfd_vma addr;
d1856 1
a1856 3
pr_end_block (p, addr)
     PTR p;
     bfd_vma addr;
d1873 1
a1873 2
pr_end_function (p)
     PTR p ATTRIBUTE_UNUSED;
d1996 2
a1997 1
		      bfd_boolean structp, unsigned int size ATTRIBUTE_UNUSED)
d2281 1
a2281 1
  
d2310 1
a2310 1
  
d2320 1
a2320 2
				bfd_boolean constp,
				bfd_boolean volatilep)
d2623 1
a2623 1
    
d2684 1
a2684 1
    
d2688 1
a2688 1
          
d2753 1
a2753 2
tg_lineno (void *p ATTRIBUTE_UNUSED,
	   const char *filename ATTRIBUTE_UNUSED,
@


1.6
log
@s/boolean/bfd_boolean/ s/true/TRUE/ s/false/FALSE/.  Simplify
comparisons of bfd_boolean vars with TRUE/FALSE.  Formatting.
@
text
@d2 1
a2 1
   Copyright 1995, 1996, 2002 Free Software Foundation, Inc.
d4 1
d47 9
d70 7
d188 34
a221 1

d270 48
d321 1
a321 1
print_debugging_info (f, dhandle)
d324 4
d335 12
d348 2
a349 1
  return debug_write (dhandle, &pr_fns, (PTR) &info);
d429 20
d2031 919
@


1.5
log
@	* prdbg.c (pr_fix_visibility): Remove assert.
@
text
@d2 1
a2 1
   Copyright 1995, 1996 Free Software Foundation, Inc.
d62 17
a78 9
static void indent PARAMS ((struct pr_handle *));
static boolean push_type PARAMS ((struct pr_handle *, const char *));
static boolean prepend_type PARAMS ((struct pr_handle *, const char *));
static boolean append_type PARAMS ((struct pr_handle *, const char *));
static boolean substitute_type PARAMS ((struct pr_handle *, const char *));
static boolean indent_type PARAMS ((struct pr_handle *));
static char *pop_type PARAMS ((struct pr_handle *));
static void print_vma PARAMS ((bfd_vma, char *, boolean, boolean));
static boolean pr_fix_visibility
d80 17
a96 10

static boolean pr_start_compilation_unit PARAMS ((PTR, const char *));
static boolean pr_start_source PARAMS ((PTR, const char *));
static boolean pr_empty_type PARAMS ((PTR));
static boolean pr_void_type PARAMS ((PTR));
static boolean pr_int_type PARAMS ((PTR, unsigned int, boolean));
static boolean pr_float_type PARAMS ((PTR, unsigned int));
static boolean pr_complex_type PARAMS ((PTR, unsigned int));
static boolean pr_bool_type PARAMS ((PTR, unsigned int));
static boolean pr_enum_type
d98 23
a120 14
static boolean pr_pointer_type PARAMS ((PTR));
static boolean pr_function_type PARAMS ((PTR, int, boolean));
static boolean pr_reference_type PARAMS ((PTR));
static boolean pr_range_type PARAMS ((PTR, bfd_signed_vma, bfd_signed_vma));
static boolean pr_array_type
  PARAMS ((PTR, bfd_signed_vma, bfd_signed_vma, boolean));
static boolean pr_set_type PARAMS ((PTR, boolean));
static boolean pr_offset_type PARAMS ((PTR));
static boolean pr_method_type PARAMS ((PTR, boolean, int, boolean));
static boolean pr_const_type PARAMS ((PTR));
static boolean pr_volatile_type PARAMS ((PTR));
static boolean pr_start_struct_type
  PARAMS ((PTR, const char *, unsigned int, boolean, unsigned int));
static boolean pr_struct_field
d122 6
a127 5
static boolean pr_end_struct_type PARAMS ((PTR));
static boolean pr_start_class_type
  PARAMS ((PTR, const char *, unsigned int, boolean, unsigned int, boolean,
	   boolean));
static boolean pr_class_static_member
d129 17
a145 12
static boolean pr_class_baseclass
  PARAMS ((PTR, bfd_vma, boolean, enum debug_visibility));
static boolean pr_class_start_method PARAMS ((PTR, const char *));
static boolean pr_class_method_variant
  PARAMS ((PTR, const char *, enum debug_visibility, boolean, boolean,
	   bfd_vma, boolean));
static boolean pr_class_static_method_variant
  PARAMS ((PTR, const char *, enum debug_visibility, boolean, boolean));
static boolean pr_class_end_method PARAMS ((PTR));
static boolean pr_end_class_type PARAMS ((PTR));
static boolean pr_typedef_type PARAMS ((PTR, const char *));
static boolean pr_tag_type
d147 11
a157 6
static boolean pr_typdef PARAMS ((PTR, const char *));
static boolean pr_tag PARAMS ((PTR, const char *));
static boolean pr_int_constant PARAMS ((PTR, const char *, bfd_vma));
static boolean pr_float_constant PARAMS ((PTR, const char *, double));
static boolean pr_typed_constant PARAMS ((PTR, const char *, bfd_vma));
static boolean pr_variable
d159 3
a161 2
static boolean pr_start_function PARAMS ((PTR, const char *, boolean));
static boolean pr_function_parameter
d163 8
a170 4
static boolean pr_start_block PARAMS ((PTR, bfd_vma));
static boolean pr_end_block PARAMS ((PTR, bfd_vma));
static boolean pr_end_function PARAMS ((PTR));
static boolean pr_lineno PARAMS ((PTR, const char *, unsigned long, bfd_vma));
d222 1
a222 1
boolean
d251 1
a251 1
static boolean
d259 1
a259 1
    return false;
d270 1
a270 1
  return true;
d275 1
a275 1
static boolean
d289 1
a289 1
  return true;
d294 1
a294 1
static boolean
d302 1
a302 1
    return false;
d311 1
a311 1
  return true;
d318 1
a318 1
static boolean
d341 1
a341 1
      return true;
d350 1
a350 1
	return false;
d354 1
a354 1
    return true;
d362 1
a362 1
static boolean
d371 1
a371 1
	return false;
d374 1
a374 1
  return true;
d402 2
a403 2
     boolean unsignedp;
     boolean hexp;
d424 1
a424 1
static boolean
d435 1
a435 1
  return true;
d440 1
a440 1
static boolean
d451 1
a451 1
  return true;
d456 1
a456 1
static boolean
d467 1
a467 1
static boolean
d478 1
a478 1
static boolean
d482 1
a482 1
     boolean unsignedp;
d493 1
a493 1
static boolean
d512 1
a512 1
static boolean
d520 1
a520 1
    return false;
d525 1
a525 1
/* Push a boolean type onto the type stack.  */
d527 1
a527 1
static boolean
d542 1
a542 1
static boolean
d554 1
a554 1
    return false;
d559 1
a559 1
	return false;
d562 1
a562 1
    return false;
d567 1
a567 1
	return false;
d577 1
a577 1
		return false;
d581 1
a581 1
	    return false;
d587 1
a587 1
	      print_vma (values[i], ab, false, false);
d590 1
a590 1
		return false;
d603 1
a603 1
static boolean
d620 1
a620 1
static boolean
d624 1
a624 1
     boolean varargs;
d648 1
a648 1
	    return false;
d651 1
a651 1
	    return false;
d688 1
a688 1
    return false;
d692 1
a692 1
  return true;
d697 1
a697 1
static boolean
d710 1
a710 1
static boolean
d722 1
a722 1
    return false;
d724 2
a725 2
  print_vma (lower, abl, false, false);
  print_vma (upper, abu, false, false);
d736 1
a736 1
static boolean
d741 1
a741 1
     boolean stringp;
d749 1
a749 1
    return false;
d757 1
a757 1
	  print_vma (upper + 1, abu, false, false);
d763 2
a764 2
      print_vma (lower, abl, false, false);
      print_vma (upper, abu, false, false);
d769 1
a769 1
    return false;
d775 1
a775 1
	return false;
d781 1
a781 1
	return false;
d784 1
a784 1
  return true;
d789 1
a789 1
static boolean
d792 1
a792 1
     boolean bitstringp;
d797 1
a797 1
    return false;
d801 1
a801 1
    return false;
d806 1
a806 1
	return false;
d809 1
a809 1
  return true;
d814 1
a814 1
static boolean
d822 1
a822 1
    return false;
d826 1
a826 1
    return false;
d836 1
a836 1
static boolean
d839 1
a839 1
     boolean domain;
d841 1
a841 1
     boolean varargs;
d856 1
a856 1
	return false;
d859 1
a859 1
	return false;
d884 1
a884 1
	    return false;
d887 1
a887 1
	    return false;
d928 1
a928 1
    return false;
d932 1
a932 1
  return true;
d937 1
a937 1
static boolean
d948 1
a948 1
static boolean
d959 1
a959 1
static boolean
d964 1
a964 1
     boolean structp;
d972 1
a972 1
    return false;
d976 1
a976 1
	return false;
d984 1
a984 1
	return false;
d988 1
a988 1
    return false;
d994 1
a994 1
	return false;
d1000 1
a1000 1
	    return false;
d1006 1
a1006 1
	    return false;
d1009 1
a1009 1
	return false;
d1012 1
a1012 1
    return false;
d1021 1
a1021 1
static boolean
d1033 1
a1033 1
    return true;
d1051 1
a1051 1
      return false;
d1065 1
a1065 1
    return false;
d1069 1
a1069 1
  return true;
d1074 1
a1074 1
static boolean
d1087 1
a1087 1
    return false;
d1090 1
a1090 1
    return false;
d1094 1
a1094 1
      print_vma (bitsize, ab, true, false);
d1098 1
a1098 1
	return false;
d1101 1
a1101 1
  print_vma (bitpos, ab, true, false);
d1106 1
a1106 1
    return false;
d1110 1
a1110 1
    return false;
d1113 1
a1113 1
    return false;
d1120 1
a1120 1
static boolean
d1139 1
a1139 1
  return true;
d1144 1
a1144 1
static boolean
d1149 1
a1149 1
     boolean structp;
d1151 2
a1152 2
     boolean vptr;
     boolean ownvptr;
d1163 1
a1163 1
	return false;
d1167 1
a1167 1
    return false;
d1171 1
a1171 1
	return false;
d1179 1
a1179 1
	return false;
d1183 1
a1183 1
    return false;
d1187 1
a1187 1
	return false;
d1196 1
a1196 1
	    return false;
d1202 1
a1202 1
	    return false;
d1206 1
a1206 1
		return false;
d1212 1
a1212 1
		return false;
d1222 1
a1222 1
	    return false;
d1226 1
a1226 1
	return false;
d1237 1
a1237 1
static boolean
d1248 1
a1248 1
    return false;
d1255 1
a1255 1
    return false;
d1259 1
a1259 1
    return false;
d1262 1
a1262 1
    return false;
d1269 1
a1269 1
static boolean
d1273 1
a1273 1
     boolean virtual;
d1285 1
a1285 1
    return false;
d1289 1
a1289 1
    return false;
d1297 1
a1297 1
    return false;
d1302 1
a1302 1
	return false;
d1322 1
a1322 1
    return false;
d1326 1
a1326 1
      print_vma (bitpos, ab, true, false);
d1330 1
a1330 1
	return false;
d1347 1
a1347 1
    return false;
d1351 1
a1351 1
    return false;
d1363 1
a1363 1
  return true;
d1368 1
a1368 1
static boolean
d1377 1
a1377 1
  return true;
d1382 1
a1382 1
static boolean
d1388 2
a1389 2
     boolean constp;
     boolean volatilep;
d1391 1
a1391 1
     boolean context;
d1404 1
a1404 1
	return false;
d1409 1
a1409 1
	return false;
d1417 1
a1417 1
    return false;
d1422 1
a1422 1
    return false;
d1431 1
a1431 1
	return false;
d1437 1
a1437 1
    return false;
d1443 1
a1443 1
    return false;
d1453 1
a1453 1
	    return false;
d1455 1
a1455 1
      print_vma (voffset, ab, true, false);
d1458 1
a1458 1
	return false;
d1467 1
a1467 1
static boolean
d1472 2
a1473 2
     boolean constp;
     boolean volatilep;
d1486 1
a1486 1
	return false;
d1491 1
a1491 1
	return false;
d1496 1
a1496 1
    return false;
d1500 1
a1500 1
    return false;
d1505 1
a1505 1
    return false;
d1510 1
a1510 1
    return false;
d1521 1
a1521 1
static boolean
d1528 1
a1528 1
  return true;
d1533 1
a1533 1
static boolean
d1542 1
a1542 1
static boolean
d1554 1
a1554 1
static boolean
d1584 1
a1584 1
      return false;
d1588 1
a1588 1
    return false;
d1598 1
a1598 1
    return false;
d1603 1
a1603 1
	return false;
d1606 1
a1606 1
  return true;
d1611 1
a1611 1
static boolean
d1620 1
a1620 1
    return false;
d1624 1
a1624 1
    return false;
d1631 1
a1631 1
  return true;
d1637 1
a1637 1
static boolean
d1647 1
a1647 1
    return false;
d1654 1
a1654 1
  return true;
d1659 1
a1659 1
static boolean
d1669 1
a1669 1
  print_vma (val, ab, false, false);
d1671 1
a1671 1
  return true;
d1676 1
a1676 1
static boolean
d1686 1
a1686 1
  return true;
d1691 1
a1691 1
static boolean
d1703 1
a1703 1
    return false;
d1706 1
a1706 1
  print_vma (val, ab, false, false);
d1711 1
a1711 1
  return true;
d1716 1
a1716 1
static boolean
d1728 1
a1728 1
    return false;
d1732 1
a1732 1
    return false;
d1747 1
a1747 1
  print_vma (val, ab, true, true);
d1752 1
a1752 1
  return true;
d1757 1
a1757 1
static boolean
d1761 1
a1761 1
     boolean global;
d1767 1
a1767 1
    return false;
d1771 1
a1771 1
    return false;
d1780 1
a1780 1
  return true;
d1785 1
a1785 1
static boolean
d1800 1
a1800 1
	return false;
d1804 1
a1804 1
    return false;
d1808 1
a1808 1
    return false;
d1816 1
a1816 1
  print_vma (val, ab, true, true);
d1823 1
a1823 1
  return true;
d1828 1
a1828 1
static boolean
d1843 1
a1843 1
  print_vma (addr, ab, true, true);
d1848 1
a1848 1
  return true;
d1853 1
a1853 1
static boolean
d1864 1
a1864 1
  print_vma (addr, ab, true, true);
d1867 1
a1867 1
  return true;
d1872 1
a1872 1
static boolean
d1883 1
a1883 1
  print_vma (addr, ab, true, true);
d1886 1
a1886 1
  return true;
d1891 1
a1891 1
static boolean
d1895 1
a1895 1
  return true;
@


1.4
log
@	* arsup.c: Remove ARGSUSED.
	* debug.c: Likewise.
	* ieee.c: Likewise.
	* nlmconv.c: Likewise.
	* prdbg.c: Likewise.
	* stabs.c: Likewise.
	* wrstabs.c: Likewise.
@
text
@a994 2
  assert (info->stack->visibility != DEBUG_VISIBILITY_IGNORE);

@


1.3
log
@Fix typos in ChangeLogs and update copyright notices
@
text
@a695 1
/*ARGSUSED*/
a748 1
/*ARGSUSED*/
a1598 1
/*ARGSUSED*/
a1852 1
/*ARGSUSED*/
@


1.2
log
@	* Many files: Changes to avoid gcc warnings: Add ATTRIBUTE_UNUSED
	as appropriate.  Add variable initializations.  Add casts.
	* objdump.c (disassemble_bytes): Change j to bfd_vma.
	* readelf.c (process_syminfo): Change i to unsigned int.
	(display_debug_info): Change abbrev_number to unsigned long.
	(process_mips_specific): Change fcnt to size_t.
@
text
@d2 1
a2 1
   Copyright (C) 1995, 1996, 1999 Free Software Foundation, Inc.
@


1.2.4.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1995, 1996 Free Software Foundation, Inc.
@


1.1
log
@Initial revision
@
text
@d2 1
a2 1
   Copyright (C) 1995, 1996 Free Software Foundation, Inc.
d988 1
a988 1
  const char *s;
d1605 1
a1605 1
     const char *name;
d1859 1
a1859 1
     PTR p;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

