head	1.18;
access;
symbols
	binutils-2_24-branch:1.18.0.2
	binutils-2_24-branchpoint:1.18
	binutils-2_21_1:1.17
	binutils-2_23_2:1.17
	binutils-2_23_1:1.17
	binutils-2_23:1.17
	binutils-2_23-branch:1.17.0.8
	binutils-2_23-branchpoint:1.17
	binutils-2_22_branch:1.17.0.6
	binutils-2_22:1.17
	binutils-2_22-branch:1.17.0.4
	binutils-2_22-branchpoint:1.17
	binutils-2_21:1.17
	binutils-2_21-branch:1.17.0.2
	binutils-2_21-branchpoint:1.17
	binutils-2_20_1:1.16
	binutils-2_20:1.16
	binutils-arc-20081103-branch:1.15.0.10
	binutils-arc-20081103-branchpoint:1.15
	binutils-2_20-branch:1.16.0.2
	binutils-2_20-branchpoint:1.16
	dje-cgen-play1-branch:1.15.0.8
	dje-cgen-play1-branchpoint:1.15
	arc-20081103-branch:1.15.0.6
	arc-20081103-branchpoint:1.15
	binutils-2_19_1:1.15
	binutils-2_19:1.15
	binutils-2_19-branch:1.15.0.4
	binutils-2_19-branchpoint:1.15
	binutils-2_18:1.15
	binutils-2_18-branch:1.15.0.2
	binutils-2_18-branchpoint:1.15
	binutils-csl-coldfire-4_1-32:1.13
	binutils-csl-sourcerygxx-4_1-32:1.13
	binutils-csl-innovasic-fido-3_4_4-33:1.13
	binutils-csl-sourcerygxx-3_4_4-32:1.11
	binutils-csl-coldfire-4_1-30:1.13
	binutils-csl-sourcerygxx-4_1-30:1.13
	binutils-csl-coldfire-4_1-28:1.13
	binutils-csl-sourcerygxx-4_1-29:1.13
	binutils-csl-sourcerygxx-4_1-28:1.13
	binutils-csl-arm-2006q3-27:1.13
	binutils-csl-sourcerygxx-4_1-27:1.13
	binutils-csl-arm-2006q3-26:1.13
	binutils-csl-sourcerygxx-4_1-26:1.13
	binutils-csl-sourcerygxx-4_1-25:1.13
	binutils-csl-sourcerygxx-4_1-24:1.13
	binutils-csl-sourcerygxx-4_1-23:1.13
	binutils-csl-sourcerygxx-4_1-21:1.13
	binutils-csl-arm-2006q3-21:1.13
	binutils-csl-sourcerygxx-4_1-22:1.13
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.13
	binutils-csl-sourcerygxx-4_1-20:1.13
	binutils-csl-arm-2006q3-19:1.13
	binutils-csl-sourcerygxx-4_1-19:1.13
	binutils-csl-sourcerygxx-4_1-18:1.13
	binutils-csl-renesas-4_1-9:1.13
	binutils-csl-sourcerygxx-3_4_4-25:1.11
	binutils-csl-renesas-4_1-8:1.13
	binutils-csl-renesas-4_1-7:1.13
	binutils-csl-renesas-4_1-6:1.13
	binutils-csl-sourcerygxx-4_1-17:1.13
	binutils-csl-sourcerygxx-4_1-14:1.13
	binutils-csl-sourcerygxx-4_1-15:1.13
	binutils-csl-sourcerygxx-4_1-13:1.13
	binutils-2_17:1.13
	binutils-csl-sourcerygxx-4_1-12:1.13
	binutils-csl-sourcerygxx-3_4_4-21:1.13
	binutils-csl-wrs-linux-3_4_4-24:1.11
	binutils-csl-wrs-linux-3_4_4-23:1.11
	binutils-csl-sourcerygxx-4_1-9:1.13
	binutils-csl-sourcerygxx-4_1-8:1.13
	binutils-csl-sourcerygxx-4_1-7:1.13
	binutils-csl-arm-2006q1-6:1.13
	binutils-csl-sourcerygxx-4_1-6:1.13
	binutils-csl-wrs-linux-3_4_4-22:1.11
	binutils-csl-coldfire-4_1-11:1.13
	binutils-csl-sourcerygxx-3_4_4-19:1.13
	binutils-csl-coldfire-4_1-10:1.13
	binutils-csl-sourcerygxx-4_1-5:1.13
	binutils-csl-sourcerygxx-4_1-4:1.13
	binutils-csl-wrs-linux-3_4_4-21:1.11
	binutils-csl-morpho-4_1-4:1.13
	binutils-csl-sourcerygxx-3_4_4-17:1.13
	binutils-csl-wrs-linux-3_4_4-20:1.11
	binutils-2_17-branch:1.13.0.4
	binutils-2_17-branchpoint:1.13
	binutils-csl-2_17-branch:1.13.0.2
	binutils-csl-2_17-branchpoint:1.13
	binutils-csl-gxxpro-3_4-branch:1.11.0.6
	binutils-csl-gxxpro-3_4-branchpoint:1.11
	binutils-2_16_1:1.11
	binutils-csl-arm-2005q1b:1.11
	binutils-2_16:1.11
	binutils-csl-arm-2005q1a:1.11
	binutils-csl-arm-2005q1-branch:1.11.0.4
	binutils-csl-arm-2005q1-branchpoint:1.11
	binutils-2_16-branch:1.11.0.2
	binutils-2_16-branchpoint:1.11
	csl-arm-2004-q3d:1.11
	csl-arm-2004-q3:1.11
	binutils-2_15:1.10
	binutils-2_15-branchpoint:1.10
	csl-arm-2004-q1a:1.10
	csl-arm-2004-q1:1.10
	binutils-2_15-branch:1.10.0.6
	cagney_bfdfile-20040213-branch:1.10.0.4
	cagney_bfdfile-20040213-branchpoint:1.10
	cagney_bigcore-20040122-branch:1.10.0.2
	cagney_bigcore-20040122-branchpoint:1.10
	csl-arm-2003-q4:1.10
	binutils-2_14:1.6
	binutils-2_14-branch:1.6.0.4
	binutils-2_14-branchpoint:1.6
	binutils-2_13_2_1:1.6
	binutils-2_13_2:1.6
	binutils-2_13_1:1.6
	binutils-2_13:1.6
	binutils-2_13-branchpoint:1.6
	binutils-2_13-branch:1.6.0.2
	binutils-2_12_1:1.4
	binutils-2_12:1.4
	binutils-2_12-branch:1.4.0.2
	binutils-2_12-branchpoint:1.4
	cygnus_cvs_20020108_pre:1.4
	binutils-2_11_2:1.2.2.1
	binutils-2_11_1:1.2.2.1
	binutils-2_11:1.2
	x86_64versiong3:1.2
	binutils-2_11-branch:1.2.0.2
	binutils-2_10_1:1.1.1.1
	binutils-2_10:1.1.1.1
	binutils-2_10-branch:1.1.1.1.0.2
	binutils-2_10-branchpoint:1.1.1.1
	binutils_latest_snapshot:1.18
	repo-unification-2000-02-06:1.1.1.1
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.18
date	2012.11.09.08.29.31;	author hjl;	state Exp;
branches;
next	1.17;

1.17
date	2009.12.11.13.42.05;	author nickc;	state Exp;
branches;
next	1.16;

1.16
date	2009.09.02.07.22.31;	author amodra;	state Exp;
branches;
next	1.15;

1.15
date	2007.07.05.16.54.45;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2007.04.26.14.46.59;	author amodra;	state Exp;
branches;
next	1.13;

1.13
date	2005.05.08.14.17.38;	author nickc;	state Exp;
branches;
next	1.12;

1.12
date	2005.04.29.01.15.21;	author bje;	state Exp;
branches;
next	1.11;

1.11
date	2004.06.15.01.19.13;	author amodra;	state Exp;
branches;
next	1.10;

1.10
date	2003.12.06.10.02.06;	author kazu;	state Exp;
branches;
next	1.9;

1.9
date	2003.12.06.00.06.12;	author kazu;	state Exp;
branches;
next	1.8;

1.8
date	2003.10.27.13.20.32;	author kazu;	state Exp;
branches;
next	1.7;

1.7
date	2003.09.14.12.20.16;	author aj;	state Exp;
branches;
next	1.6;

1.6
date	2002.05.25.12.51.38;	author amodra;	state Exp;
branches;
next	1.5;

1.5
date	2002.05.19.16.17.54;	author kazu;	state Exp;
branches;
next	1.4;

1.4
date	2001.08.21.10.02.26;	author aj;	state Exp;
branches;
next	1.3;

1.3
date	2001.03.13.06.43.57;	author nickc;	state Exp;
branches;
next	1.2;

1.2
date	2000.05.02.02.29.17;	author amodra;	state Exp;
branches
	1.2.2.1;
next	1.1;

1.1
date	99.05.03.07.29.09;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.2.2.1
date	2001.06.07.03.12.27;	author amodra;	state Exp;
branches;
next	;

1.1.1.1
date	99.05.03.07.29.09;	author rth;	state Exp;
branches;
next	;


desc
@@


1.18
log
@Remove trailing redundant `;'

bfd/

	* aout-tic30.c (MY_final_link_callback): Remove trailing
	redundant `;'.
	* coff-h8500.c (extra_case): Likewise.
	(bfd_coff_reloc16_get_value): Likewise.
	* dwarf2.c (_bfd_dwarf2_cleanup_debug_info): Likewise.
	* elf.c (_bfd_elf_slurp_version_tables): Likewise.
	* elf32-frv.c (elf32_frv_relocate_section): Likewise.
	* elf32-v850.c (v850_elf_perform_relocation): Likewise.
	* opncls.c (bfd_calc_gnu_debuglink_crc32): Likewise.
	* plugin.c (add_symbols): Likewise.
	* reloc.c (bfd_check_overflow): Likewise.
	* vms-lib.c (_bfd_vms_lib_archive_p): Likewise.

binutils/

	* coffgrok.c (coff_grok): Remove trailing redundant `;'.
	* resrc.c (open_input_stream): Likewise.

gas/

	* config/atof-ieee.c (gen_to_words): Remove trailing redundant
	`;'.
	* config/atof-vax.c (flonum_gen2vax): Likewise.
	* config/tc-d10v.c (write_2_short): Likewise.
	* config/tc-i386-intel.c (i386_intel_simplify): Likewise.
	* config/tc-s390.c (tc_s390_force_relocation): Likewise.
	* config/tc-v850.c (md_parse_option): Likewise.
	* config/tc-xtensa.c (find_address_of_next_align_frag): Likewise.
	* dwarf2dbg.c (out_header): Likewise.
	* symbols.c (dollar_label_name): Likewise.
	(fb_label_name): Likewise.

ld/

	* testplug.c (record_add_file): Remove trailing redundant `;'.

opcodes/

	* aarch64-opc.h (gen_mask): Remove trailing redundant `;'.
	* ia64-gen.c (fetch_insn_class): Likewise.
@
text
@/* coffgrok.c
   Copyright 1994, 1995, 1997, 1998, 2000, 2001, 2002, 2003, 2004, 2005,
   2007, 2009  Free Software Foundation, Inc.

   This file is part of GNU Binutils.

   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3 of the License, or
   (at your option) any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.

   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston,
   MA 02110-1301, USA.  */


/* Written by Steve Chamberlain (sac@@cygnus.com)

   This module reads a coff file and builds a really simple type tree
   which can be read by other programs.  The first application is a
   coff->sysroff converter.  It can be tested with coffdump.c.  */

#include "sysdep.h"
#include "bfd.h"
#include "libiberty.h"

#include "coff/internal.h"
#include "../bfd/libcoff.h"
#include "bucomm.h"
#include "coffgrok.h"

static int lofile = 1;
static struct coff_scope *top_scope;
static struct coff_scope *file_scope;
static struct coff_ofile *ofile;

static struct coff_symbol *last_function_symbol;
static struct coff_type *last_function_type;
static struct coff_type *last_struct;
static struct coff_type *last_enum;
static struct coff_sfile *cur_sfile;

static struct coff_symbol **tindex;


static asymbol **syms;
static long symcount;

#define N(x) ((x)->_n._n_nptr[1])

static struct coff_ptr_struct *rawsyms;
static int rawcount;
static bfd *abfd;

#define PTR_SIZE	4
#define SHORT_SIZE	2
#define INT_SIZE	4
#define LONG_SIZE	4
#define FLOAT_SIZE	4
#define DOUBLE_SIZE	8

#define INDEXOF(p)  ((struct coff_ptr_struct *)(p)-(rawsyms))

static struct coff_scope *empty_scope (void);
static struct coff_symbol *empty_symbol (void);
static void push_scope (int);
static void pop_scope (void);
static void do_sections_p1 (struct coff_ofile *);
static void do_sections_p2 (struct coff_ofile *);
static struct coff_where *do_where (int);
static struct coff_line *do_lines (int, char *);
static struct coff_type *do_type (int);
static struct coff_visible *do_visible (int);
static int do_define (int, struct coff_scope *);
static struct coff_ofile *doit (void);

static struct coff_scope *
empty_scope (void)
{
  struct coff_scope *l;
  l = (struct coff_scope *) (xcalloc (sizeof (struct coff_scope), 1));
  return l;
}

static struct coff_symbol *
empty_symbol (void)
{
  return (struct coff_symbol *) (xcalloc (sizeof (struct coff_symbol), 1));
}

/*int l;*/
static void
push_scope (int slink)
{
  struct coff_scope *n = empty_scope ();

  if (slink)
    {
      if (top_scope)
	{
	  if (top_scope->list_tail)
	    {
	      top_scope->list_tail->next = n;
	    }
	  else
	    {
	      top_scope->list_head = n;
	    }
	  top_scope->list_tail = n;
	}
    }
  n->parent = top_scope;

  top_scope = n;
}

static void
pop_scope (void)
{
  top_scope = top_scope->parent;
}

static void
do_sections_p1 (struct coff_ofile *head)
{
  asection *section;
  int idx;
  struct coff_section *all = (struct coff_section *) (xcalloc (abfd->section_count + 1,
					     sizeof (struct coff_section)));
  head->nsections = abfd->section_count + 1;
  head->sections = all;

  for (idx = 0, section = abfd->sections; section; section = section->next, idx++)
    {
      long relsize;
      int i = section->target_index;
      arelent **relpp;
      long relcount;

      relsize = bfd_get_reloc_upper_bound (abfd, section);
      if (relsize < 0)
	bfd_fatal (bfd_get_filename (abfd));
      if (relsize == 0)
	continue;
      relpp = (arelent **) xmalloc (relsize);
      relcount = bfd_canonicalize_reloc (abfd, section, relpp, syms);
      if (relcount < 0)
	bfd_fatal (bfd_get_filename (abfd));

      head->sections[i].name = (char *) (section->name);
      head->sections[i].code = section->flags & SEC_CODE;
      head->sections[i].data = section->flags & SEC_DATA;
      if (strcmp (section->name, ".bss") == 0)
	head->sections[i].data = 1;
      head->sections[i].address = section->lma;
      head->sections[i].size = bfd_get_section_size (section);
      head->sections[i].number = idx;
      head->sections[i].nrelocs = section->reloc_count;
      head->sections[i].relocs =
	(struct coff_reloc *) (xcalloc (section->reloc_count,
					sizeof (struct coff_reloc)));
      head->sections[i].bfd_section = section;
    }
  head->sections[0].name = "ABSOLUTE";
  head->sections[0].code = 0;
  head->sections[0].data = 0;
  head->sections[0].address = 0;
  head->sections[0].size = 0;
  head->sections[0].number = 0;
}

static void
do_sections_p2 (struct coff_ofile *head)
{
  asection *section;
  for (section = abfd->sections; section; section = section->next)
    {
      unsigned int j;

      for (j = 0; j < section->reloc_count; j++)
	{
	  int idx;
	  int i = section->target_index;
	  struct coff_reloc *r = head->sections[i].relocs + j;
	  arelent *sr = section->relocation + j;
	  r->offset = sr->address;
	  r->addend = sr->addend;
	  idx = ((coff_symbol_type *) (sr->sym_ptr_ptr[0]))->native - rawsyms;
	  r->symbol = tindex[idx];
	}
    }
}

static struct coff_where *
do_where (int i)
{
  struct internal_syment *sym = &rawsyms[i].u.syment;
  struct coff_where *where =
    (struct coff_where *) (xmalloc (sizeof (struct coff_where)));
  where->offset = sym->n_value;

  if (sym->n_scnum == -1)
    sym->n_scnum = 0;

  switch (sym->n_sclass)
    {
    case C_FIELD:
      where->where = coff_where_member_of_struct;
      where->offset = sym->n_value / 8;
      where->bitoffset = sym->n_value % 8;
      where->bitsize = rawsyms[i + 1].u.auxent.x_sym.x_misc.x_lnsz.x_size;
      break;
    case C_MOE:
      where->where = coff_where_member_of_enum;
      break;
    case C_MOS:
    case C_MOU:
      where->where = coff_where_member_of_struct;
      break;
    case C_AUTO:
    case C_ARG:
      where->where = coff_where_stack;
      break;
    case C_EXT:
    case C_STAT:
    case C_EXTDEF:
    case C_LABEL:
      where->where = coff_where_memory;
      where->section = &ofile->sections[sym->n_scnum];
      break;
    case C_REG:
    case C_REGPARM:
      where->where = coff_where_register;
      break;
    case C_ENTAG:
      where->where = coff_where_entag;
      break;
    case C_STRTAG:
    case C_UNTAG:
      where->where = coff_where_strtag;
      break;
    case C_TPDEF:
      where->where = coff_where_typedef;
      break;
    default:
      abort ();
      break;
    }
  return where;
}

static
struct coff_line *
do_lines (int i, char *name ATTRIBUTE_UNUSED)
{
  struct coff_line *res = (struct coff_line *) xcalloc (sizeof (struct coff_line), 1);
  asection *s;
  unsigned int l;

  /* Find out if this function has any line numbers in the table */
  for (s = abfd->sections; s; s = s->next)
    {
      for (l = 0; l < s->lineno_count; l++)
	{
	  if (s->lineno[l].line_number == 0)
	    {
	      if (rawsyms + i == ((coff_symbol_type *) (&(s->lineno[l].u.sym[0])))->native)
		{
		  /* These lines are for this function - so count them and stick them on */
		  int c = 0;
		  /* Find the linenumber of the top of the function, since coff linenumbers
		     are relative to the start of the function.  */
		  int start_line = rawsyms[i + 3].u.auxent.x_sym.x_misc.x_lnsz.x_lnno;

		  l++;
		  for (c = 0; s->lineno[l + c + 1].line_number; c++)
		    ;

		  /* Add two extra records, one for the prologue and one for the epilogue */
		  c += 1;
		  res->nlines = c;
		  res->lines = (int *) (xcalloc (sizeof (int), c));
		  res->addresses = (int *) (xcalloc (sizeof (int), c));
		  res->lines[0] = start_line;
		  res->addresses[0] = rawsyms[i].u.syment.n_value - s->vma;
		  for (c = 0; s->lineno[l + c + 1].line_number; c++)
		    {
		      res->lines[c + 1] = s->lineno[l + c].line_number + start_line - 1;
		      res->addresses[c + 1] = s->lineno[l + c].u.offset;
		    }
		  return res;
		}
	    }
	}
    }
  return res;
}

static
struct coff_type *
do_type (int i)
{
  struct internal_syment *sym = &rawsyms[i].u.syment;
  union internal_auxent *aux = &rawsyms[i + 1].u.auxent;
  struct coff_type *res =
    (struct coff_type *) xmalloc (sizeof (struct coff_type));
  int type = sym->n_type;
  int which_dt = 0;
  int dimind = 0;

  res->type = coff_basic_type;
  res->u.basic = type & 0xf;

  switch (type & 0xf)
    {
    case T_NULL:
    case T_VOID:
      if (sym->n_numaux && sym->n_sclass == C_STAT)
	{
	  /* This is probably a section definition */
	  res->type = coff_secdef_type;
	  res->size = aux->x_scn.x_scnlen;
	}
      else
	{
	  if (type == 0)
	    {
	      /* Don't know what this is, let's make it a simple int */
	      res->size = INT_SIZE;
	      res->u.basic = T_UINT;
	    }
	  else
	    {
	      /* Else it could be a function or pointer to void */
	      res->size = 0;
	    }
	}
      break;


      break;
    case T_UCHAR:
    case T_CHAR:
      res->size = 1;
      break;
    case T_USHORT:
    case T_SHORT:
      res->size = SHORT_SIZE;
      break;
    case T_UINT:
    case T_INT:
      res->size = INT_SIZE;
      break;
    case T_ULONG:
    case T_LONG:
      res->size = LONG_SIZE;
      break;
    case T_FLOAT:
      res->size = FLOAT_SIZE;
      break;
    case T_DOUBLE:
      res->size = DOUBLE_SIZE;
      break;
    case T_STRUCT:
    case T_UNION:
      if (sym->n_numaux)
	{
	  if (aux->x_sym.x_tagndx.p)
	    {
	      /* Referring to a struct defined elsewhere */
	      res->type = coff_structref_type;
	      res->u.astructref.ref = tindex[INDEXOF (aux->x_sym.x_tagndx.p)];
	      res->size = res->u.astructref.ref ?
		res->u.astructref.ref->type->size : 0;
	    }
	  else
	    {
	      /* A definition of a struct */
	      last_struct = res;
	      res->type = coff_structdef_type;
	      res->u.astructdef.elements = empty_scope ();
	      res->u.astructdef.idx = 0;
	      res->u.astructdef.isstruct = (type & 0xf) == T_STRUCT;
	      res->size = aux->x_sym.x_misc.x_lnsz.x_size;
	    }
	}
      else
	{
	  /* No auxents - it's anonymous */
	  res->type = coff_structref_type;
	  res->u.astructref.ref = 0;
	  res->size = 0;
	}
      break;
    case T_ENUM:
      if (aux->x_sym.x_tagndx.p)
	{
	  /* Referring to a enum defined elsewhere */
	  res->type = coff_enumref_type;
	  res->u.aenumref.ref = tindex[INDEXOF (aux->x_sym.x_tagndx.p)];
	  res->size = res->u.aenumref.ref->type->size;
	}
      else
	{
	  /* A definition of an enum */
	  last_enum = res;
	  res->type = coff_enumdef_type;
	  res->u.aenumdef.elements = empty_scope ();
	  res->size = aux->x_sym.x_misc.x_lnsz.x_size;
	}
      break;
    case T_MOE:
      break;
    }

  for (which_dt = 5; which_dt >= 0; which_dt--)
    {
      switch ((type >> ((which_dt * 2) + 4)) & 0x3)
	{
	case 0:
	  break;
	case DT_ARY:
	  {
	    struct coff_type *ptr = ((struct coff_type *)
				     xmalloc (sizeof (struct coff_type)));
	    int els = (dimind < DIMNUM
		       ? aux->x_sym.x_fcnary.x_ary.x_dimen[dimind]
		       : 0);
	    ++dimind;
	    ptr->type = coff_array_type;
	    ptr->size = els * res->size;
	    ptr->u.array.dim = els;
	    ptr->u.array.array_of = res;
	    res = ptr;
	    break;
	  }
	case DT_PTR:
	  {
	    struct coff_type *ptr =
	      (struct coff_type *) xmalloc (sizeof (struct coff_type));
	    ptr->size = PTR_SIZE;
	    ptr->type = coff_pointer_type;
	    ptr->u.pointer.points_to = res;
	    res = ptr;
	    break;
	  }
	case DT_FCN:
	  {
	    struct coff_type *ptr
	      = (struct coff_type *) xmalloc (sizeof (struct coff_type));
	    ptr->size = 0;
	    ptr->type = coff_function_type;
	    ptr->u.function.function_returns = res;
	    ptr->u.function.parameters = empty_scope ();
	    ptr->u.function.lines = do_lines (i, sym->_n._n_nptr[1]);
	    ptr->u.function.code = 0;
	    last_function_type = ptr;
	    res = ptr;
	    break;
	  }
	}
    }
  return res;
}

static struct coff_visible *
do_visible (int i)
{
  struct internal_syment *sym = &rawsyms[i].u.syment;
  struct coff_visible *visible =
    (struct coff_visible *) (xmalloc (sizeof (struct coff_visible)));
  enum coff_vis_type t;
  switch (sym->n_sclass)
    {
    case C_MOS:
    case C_MOU:
    case C_FIELD:
      t = coff_vis_member_of_struct;
      break;
    case C_MOE:
      t = coff_vis_member_of_enum;
      break;

    case C_REGPARM:
      t = coff_vis_regparam;
      break;

    case C_REG:
      t = coff_vis_register;
      break;
    case C_STRTAG:
    case C_UNTAG:
    case C_ENTAG:
    case C_TPDEF:
      t = coff_vis_tag;
      break;
    case C_AUTOARG:
    case C_ARG:
      t = coff_vis_autoparam;
      break;
    case C_AUTO:


      t = coff_vis_auto;
      break;
    case C_LABEL:
    case C_STAT:
      t = coff_vis_int_def;
      break;
    case C_EXT:
      if (sym->n_scnum == N_UNDEF)
	{
	  if (sym->n_value)
	    t = coff_vis_common;
	  else
	    t = coff_vis_ext_ref;
	}
      else
	t = coff_vis_ext_def;
      break;
    default:
      abort ();
      break;

    }
  visible->type = t;
  return visible;
}

static int
do_define (int i, struct coff_scope *b)
{
  static int symbol_index;
  struct internal_syment *sym = &rawsyms[i].u.syment;

  /* Define a symbol and attach to block b */
  struct coff_symbol *s = empty_symbol ();

  s->number = ++symbol_index;
  s->name = sym->_n._n_nptr[1];
  s->sfile = cur_sfile;
  /* Glue onto the ofile list */
  if (lofile >= 0)
    {
      if (ofile->symbol_list_tail)
	ofile->symbol_list_tail->next_in_ofile_list = s;
      else
	ofile->symbol_list_head = s;
      ofile->symbol_list_tail = s;
      /* And the block list */
    }
  if (b->vars_tail)
    b->vars_tail->next = s;
  else
    b->vars_head = s;

  b->vars_tail = s;
  b->nvars++;
  s->type = do_type (i);
  s->where = do_where (i);
  s->visible = do_visible (i);

  tindex[i] = s;

  /* We remember the lowest address in each section for each source file */

  if (s->where->where == coff_where_memory
      && s->type->type == coff_secdef_type)
    {
      struct coff_isection *is = cur_sfile->section + s->where->section->number;

      if (!is->init)
	{
	  is->low = s->where->offset;
	  is->high = s->where->offset + s->type->size;
	  is->init = 1;
	  is->parent = s->where->section;
	}

    }

  if (s->type->type == coff_function_type)
    last_function_symbol = s;

  return i + sym->n_numaux + 1;
}


static
struct coff_ofile *
doit (void)
{
  int i;
  int infile = 0;
  struct coff_ofile *head =
    (struct coff_ofile *) xmalloc (sizeof (struct coff_ofile));
  ofile = head;
  head->source_head = 0;
  head->source_tail = 0;
  head->nsources = 0;
  head->symbol_list_tail = 0;
  head->symbol_list_head = 0;
  do_sections_p1 (head);
  push_scope (1);

  for (i = 0; i < rawcount;)
    {
      struct internal_syment *sym = &rawsyms[i].u.syment;
      switch (sym->n_sclass)
	{
	case C_FILE:
	  {
	    /* new source file announced */
	    struct coff_sfile *n =
	      (struct coff_sfile *) xmalloc (sizeof (struct coff_sfile));
	    n->section = (struct coff_isection *) xcalloc (sizeof (struct coff_isection), abfd->section_count + 1);
	    cur_sfile = n;
	    n->name = sym->_n._n_nptr[1];
	    n->next = 0;

	    if (infile)
	      {
		pop_scope ();
	      }
	    infile = 1;
	    push_scope (1);
	    file_scope = n->scope = top_scope;

	    if (head->source_tail)
	      head->source_tail->next = n;
	    else
	      head->source_head = n;
	    head->source_tail = n;
	    head->nsources++;
	    i += sym->n_numaux + 1;
	  }
	  break;
	case C_FCN:
	  {
	    char *name = sym->_n._n_nptr[1];
	    if (name[1] == 'b')
	      {
		/* Function start */
		push_scope (0);
		last_function_type->u.function.code = top_scope;
		top_scope->sec = ofile->sections + sym->n_scnum;
		top_scope->offset = sym->n_value;
	      }
	    else
	      {
		top_scope->size = sym->n_value - top_scope->offset + 1;
		pop_scope ();

	      }
	    i += sym->n_numaux + 1;
	  }
	  break;

	case C_BLOCK:
	  {
	    char *name = sym->_n._n_nptr[1];
	    if (name[1] == 'b')
	      {
		/* Block start */
		push_scope (1);
		top_scope->sec = ofile->sections + sym->n_scnum;
		top_scope->offset = sym->n_value;

	      }
	    else
	      {
		top_scope->size = sym->n_value - top_scope->offset + 1;
		pop_scope ();
	      }
	    i += sym->n_numaux + 1;
	  }
	  break;
	case C_REGPARM:
	case C_ARG:
	  i = do_define (i, last_function_symbol->type->u.function.parameters);
	  break;
	case C_MOS:
	case C_MOU:
	case C_FIELD:
	  i = do_define (i, last_struct->u.astructdef.elements);
	  break;
	case C_MOE:
	  i = do_define (i, last_enum->u.aenumdef.elements);
	  break;
	case C_STRTAG:
	case C_ENTAG:
	case C_UNTAG:
	  /* Various definition */
	  i = do_define (i, top_scope);
	  break;
	case C_EXT:
	case C_LABEL:
	  i = do_define (i, file_scope);
	  break;
	case C_STAT:
	case C_TPDEF:
	case C_AUTO:
	case C_REG:
	  i = do_define (i, top_scope);
	  break;
	default:
	  abort ();
	case C_EOS:
	  i += sym->n_numaux + 1;
	  break;
	}
    }
  do_sections_p2 (head);
  return head;
}

struct coff_ofile *
coff_grok (bfd *inabfd)
{
  long storage;
  struct coff_ofile *p;
  abfd = inabfd;
  storage = bfd_get_symtab_upper_bound (abfd);

  if (storage < 0)
    bfd_fatal (abfd->filename);

  syms = (asymbol **) xmalloc (storage);
  symcount = bfd_canonicalize_symtab (abfd, syms);
  if (symcount < 0)
    bfd_fatal (abfd->filename);
  rawsyms = obj_raw_syments (abfd);
  rawcount = obj_raw_syment_count (abfd);
  tindex = (struct coff_symbol **) (xcalloc (sizeof (struct coff_symbol *), rawcount));

  p = doit ();
  return p;
}
@


1.17
log
@Add -Wshadow to the gcc command line options used when compiling the binutils.
Fix up all warnings generated by the addition of this switch.
@
text
@d739 1
a739 1
  rawcount = obj_raw_syment_count (abfd);;
@


1.16
log
@update copyright dates
@
text
@d2 2
a3 2
   Copyright 1994, 1995, 1997, 1998, 2000, 2001, 2002, 2003, 2004, 2005, 2007
   Free Software Foundation, Inc.
d99 1
a99 1
push_scope (int link)
d102 2
a103 1
  if (link)
@


1.15
log
@Change sources over to using GPLv3
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1997, 1998, 2000, 2001, 2002, 2003, 2004, 2007
@


1.14
log
@
bfd/
	Many files: Include sysdep.h before bfd.h.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
binutils/
	* bucumm.h: Split off host dependencies to..
	* sysdep.h: ..here.
	Many files: Include sysdep.h.  Remove duplicate headers and reorder.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
ld/
	Many files: Include sysdep.h first.  Remove duplicate headers.
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
opcodes/
	* Makefile.am: Run "make dep-am".
	* Makefile.in: Regenerate.
	* ns32k-dis.c: Include sysdep.h first.
@
text
@d5 16
a20 1
This file is part of GNU Binutils.
a21 13
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
d27 1
a27 3
   coff->sysroff converter.  It can be tested with coffdump.c.

*/
@


1.13
log
@Update FSF address
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1997, 1998, 2000, 2001, 2002, 2003, 2004
d29 1
a31 1
#include "bucomm.h"
d35 1
d37 1
@


1.12
log
@* more static'ing.

	* syslex.l (word, number, unit): Remove unused variables.
	* nlmheader.y (keyword_tokens): Make static.
	* coffdump.c (dump_coff_symbol, coff_dump): Make static.
	* coffgrok.c (lofile, last_function_symbol, last_function_type,
	last_struct, last_enum, cur_sfile): Make variables static.
	* sysdump.c (getCHARS, fillup, getBARRAY, getINT, getBITS,
	sysroff_swap_tr_in, sysroff_print_tr_out): Make static.
	* sysinfo.y (writecode, it, code, repeat, oldrepeat, name, rdepth,
	names, pnames): Likewise.
@
text
@d19 1
a19 1
Foundation, Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.11
log
@	* objcopy.c (copy_section): Use bfd_get_section_size instead of
	_raw_size or bfd_get_section_size_before_reloc.  Don't set reloc_done.
	(compare_section_lma): Likewise.
	* addr2line.c (find_address_in_section): Likewise.
	* coffgrok.c (do_sections_p1): Likewise.
	* dlltool.c (scan_drectve_symbols): Likewise.
	* nlmconv.c (main): Likewise.
	(copy_sections): Likewise.
	(powerpc_mangle_relocs): Likewise.
	* objdump.c (disassemble_section): Likewise.
	* prdbg.c (find_address_in_section): Likewise.
	* size.c (berkeley_sum): Likewise.
	* srconv.c (wr_ob): Likewise.
	* strings.c (strings_a_section): Likewise.
@
text
@d36 1
a36 1
int lofile = 1;
d41 5
a45 5
struct coff_symbol *last_function_symbol;
struct coff_type *last_function_type;
struct coff_type *last_struct;
struct coff_type *last_enum;
struct coff_sfile *cur_sfile;
@


1.10
log
@Fia x comment typo.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1997, 1998, 2000, 2001, 2002, 2003
d159 1
a159 1
      head->sections[i].size = section->_raw_size;
@


1.9
log
@	* ChangeLog-9197: Fix comment typos.
	* coffgrok.c: Likewise.
	* filemode.c: Likewise.
	* objcopy.c: Likewise.
	* objdump.c: Likewise.
	* prdbg.c: Likewise.
	* stabs.c: Likewise.
	* unwind-ia64.c: Likewise.
@
text
@d373 1
a373 1
	      /* Refe0rring to a struct defined elsewhere */
@


1.8
log
@	* ChangeLog: Fix typos.
	* ChangeLog-9197: Likewise.
	* ChangeLog-9899: Likewise.
	* NEWS: Likewise.
	* ar.c: Fix comment typos.
	* arsup.c: Likewise.
	* coffgrok.c: Likewise.
	* debug.c: Likewise.
	* debug.h: Likewise.
	* dlltool.c: Likewise.
	* ieee.c: Likewise.
	* nm.c: Likewise.
	* objdump.c: Likewise.
	* prdbg.c: Likewise.
	* readelf.c: Likewise.
	* resrc.c: Likewise.
	* sysinfo.y: Likewise.
	* windres.c: Likewise.
@
text
@d373 1
a373 1
	      /* Referring to a struct defined elsewhere */
d401 1
a401 1
	  /* Refering to a enum defined elsewhere */
@


1.7
log
@	* addr2line.c: Convert to ISO C90 prototypes, change PTR, remove
	unneeded (void *) casts.
	* ar.c: Likewise.
	* arlex.l: Likewise.
	* arparse.y: Likewise.
	* arsup.c: Likewise.
	* binemul.c: Likewise.
	* binemul.h: Likewise.
	* bucomm.c: Likewise.
	* bucomm.h: Likewise.
	* budbg.h: Likewise.
	* budemang.c: Likewise.
	* budemang.h: Likewise.
	* coffdump.c: Likewise.
	* coffgrok.c: Likewise.
	* cxxfilt.c: Likewise.
	* debug.c: Likewise.
	* debug.h: Likewise.
	* deflex.l: Likewise.
	* dlltool.c: Likewise.
	* dlltool.h: Likewise.
	* dllwrap.c: Likewise.
	* emul_aix.c: Likewise.
	* filemode.c: Likewise.
	* ieee.c: Likewise.
	* nlmconv.c: Likewise.
	* nlmconv.h: Likewise.
	* nlmheader.y: Likewise.
	* nm.c: Likewise.
	* prdbg.c: Likewise.
	* rclex.l: Likewise.
	* rcparse.y: Likewise.
	* rdcoff.c: Likewise.
	* rddbg.c: Likewise.
	* rename.c: Likewise.
	* resbin.c: Likewise.
	* rescoff.c: Likewise.
	* resrc.c: Likewise.
	* size.c: Likewise.
	* srconv.c: Likewise.
	* stabs.c: Likewise.
	* strings.c: Likewise.
	* sysdump.c: Likewise.
	* sysinfo.y: Likewise.
	* syslex.l: Likewise.
	* unwind-ia64.c: Likewise.
	* unwind-ia64.h: Likewise.
	* version.c: Likewise.
	* windres.c: Likewise.
	* windres.h: Likewise.
	* winduni.c: Likewise.
	* wrstabs.c: Likewise.
@
text
@d373 1
a373 1
	      /* Refering to a struct defined elsewhere */
d392 1
a392 1
	  /* No auxents - it's anonynmous */
@


1.6
log
@	* arlex.l: Use #include "" instead of <> for local header files.
	* coffdump.c: Likewise.
	* coffgrok.c: Likewise.
	* nlmconv.c: Likewise.
	* nlmheader.y: Likewise.
	* srconv.c: Likewise.
	* strings.c: Likewise.
	* sysdump.c: Likewise.
	* unwind-ia64.h: Likewise.
	* windres.h: Likewise.
	* winduni.h: Likewise.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1997, 1998, 2000, 2001, 2002
d59 6
a64 6
#define PTR_SIZE 	4
#define SHORT_SIZE 	2
#define INT_SIZE 	4
#define LONG_SIZE 	4
#define FLOAT_SIZE 	4
#define DOUBLE_SIZE 	8
d68 12
a79 12
static struct coff_scope *empty_scope PARAMS ((void));
static struct coff_symbol *empty_symbol PARAMS ((void));
static void push_scope PARAMS ((int));
static void pop_scope PARAMS ((void));
static void do_sections_p1 PARAMS ((struct coff_ofile *));
static void do_sections_p2 PARAMS ((struct coff_ofile *));
static struct coff_where *do_where PARAMS ((int));
static struct coff_line *do_lines PARAMS ((int, char *));
static struct coff_type *do_type PARAMS ((int));
static struct coff_visible *do_visible PARAMS ((int));
static int do_define PARAMS ((int, struct coff_scope *));
static struct coff_ofile *doit PARAMS ((void));
d82 1
a82 1
empty_scope ()
d90 1
a90 1
empty_symbol ()
d97 1
a97 2
push_scope (link)
     int link;
d121 1
a121 1
pop_scope ()
d127 1
a127 2
do_sections_p1 (head)
     struct coff_ofile *head;
d176 1
a176 2
do_sections_p2 (head)
     struct coff_ofile *head;
d198 1
a198 2
do_where (i)
     int i;
d257 1
a257 3
do_lines (i, name)
     int i;
     char *name ATTRIBUTE_UNUSED;
d304 1
a304 2
do_type (i)
     int i;
d470 1
a470 2
do_visible (i)
     int i;
d534 1
a534 3
do_define (i, b)
     int i;
     struct coff_scope *b;
d594 1
a594 1
doit ()
d721 1
a721 2
coff_grok (inabfd)
     bfd *inabfd;
@


1.5
log
@	* addr2line.c: Fix formatting.
	* ar.c: Likewise.
	* arsup.c: Likewise.
	* arsup.h: Likewise.
	* binemul.c: Likewise.
	* binemul.h: Likewise.
	* bucomm.c: Likewise.
	* coffdump.c: Likewise.
	* coffgrok.c: Likewise.
	* coffgrok.h: Likewise.
@
text
@d2 2
a3 1
   Copyright 1994, 1995, 1997, 1998, 2000, 2001 Free Software Foundation, Inc.
d29 2
a30 2
#include <bfd.h>
#include <libiberty.h>
@


1.4
log
@	* coffgrok.h: Add missing parameter for prototype of coff_grok.

	* sysdump.c: Add missing prototypes.
	* srconv.c: Likewise.
	* unwind-ia64.c: Likewise.
	* coffdump.c: Likewise.

	* sysinfo.y: Print prototypes, include <ansidecl.h>.

	* coffgrok.c: Add missing prototypes, include libiberty.h instead
	of declaring xcalloc.
@
text
@d148 1
a148 1
        continue;
d280 1
a280 1
		     are relative to the start of the function. */
d608 1
a608 1
  (struct coff_ofile *) xmalloc (sizeof (struct coff_ofile));
@


1.3
log
@Fix typos in ChangeLogs and update copyright notices
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1997, 1998, 2000 Free Software Foundation, Inc.
d29 1
d57 1
a57 1
extern char *xcalloc ();
d66 13
@


1.2
log
@fix gcc warnings
@
text
@d2 1
a2 1
   Copyright (C) 1994, 95, 97, 1998 Free Software Foundation, Inc.
@


1.2.2.1
log
@Update copyright notices.
@
text
@d2 1
a2 1
   Copyright 1994, 1995, 1997, 1998, 2000 Free Software Foundation, Inc.
@


1.1
log
@Initial revision
@
text
@d248 1
a248 1
     char *name;
@


1.1.1.1
log
@19990502 sourceware import
@
text
@@

