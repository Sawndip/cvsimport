head	1.1;
access;
symbols
	sid-snapshot-20180601:1.1
	sid-snapshot-20180501:1.1
	sid-snapshot-20180401:1.1
	sid-snapshot-20180301:1.1
	sid-snapshot-20180201:1.1
	sid-snapshot-20180101:1.1
	sid-snapshot-20171201:1.1
	sid-snapshot-20171101:1.1
	sid-snapshot-20171001:1.1
	sid-snapshot-20170901:1.1
	sid-snapshot-20170801:1.1
	sid-snapshot-20170701:1.1
	sid-snapshot-20170601:1.1
	sid-snapshot-20170501:1.1
	sid-snapshot-20170401:1.1
	sid-snapshot-20170301:1.1
	sid-snapshot-20170201:1.1
	sid-snapshot-20170101:1.1
	sid-snapshot-20161201:1.1
	sid-snapshot-20161101:1.1
	sid-snapshot-20160901:1.1
	sid-snapshot-20160801:1.1
	sid-snapshot-20160701:1.1
	sid-snapshot-20160601:1.1
	sid-snapshot-20160501:1.1
	sid-snapshot-20160401:1.1
	sid-snapshot-20160301:1.1
	sid-snapshot-20160201:1.1
	sid-snapshot-20160101:1.1
	sid-snapshot-20151201:1.1
	sid-snapshot-20151101:1.1
	sid-snapshot-20151001:1.1
	sid-snapshot-20150901:1.1
	sid-snapshot-20150801:1.1
	sid-snapshot-20150701:1.1
	sid-snapshot-20150601:1.1
	sid-snapshot-20150501:1.1
	sid-snapshot-20150401:1.1
	sid-snapshot-20150301:1.1
	sid-snapshot-20150201:1.1
	sid-snapshot-20150101:1.1
	sid-snapshot-20141201:1.1
	sid-snapshot-20141101:1.1
	sid-snapshot-20141001:1.1
	sid-snapshot-20140901:1.1
	sid-snapshot-20140801:1.1
	sid-snapshot-20140701:1.1
	sid-snapshot-20140601:1.1
	sid-snapshot-20140501:1.1
	sid-snapshot-20140401:1.1
	sid-snapshot-20140301:1.1
	sid-snapshot-20140201:1.1
	sid-snapshot-20140101:1.1
	sid-snapshot-20131201:1.1
	sid-snapshot-20131101:1.1
	sid-snapshot-20131001:1.1
	binutils-2_24-branch:1.1.0.60
	binutils-2_24-branchpoint:1.1
	binutils-2_21_1:1.1
	sid-snapshot-20130901:1.1
	gdb_7_6_1-2013-08-30-release:1.1
	sid-snapshot-20130801:1.1
	sid-snapshot-20130701:1.1
	sid-snapshot-20130601:1.1
	sid-snapshot-20130501:1.1
	gdb_7_6-2013-04-26-release:1.1
	sid-snapshot-20130401:1.1
	binutils-2_23_2:1.1
	gdb_7_6-branch:1.1.0.58
	gdb_7_6-2013-03-12-branchpoint:1.1
	sid-snapshot-20130301:1.1
	sid-snapshot-20130201:1.1
	sid-snapshot-20130101:1.1
	sid-snapshot-20121201:1.1
	gdb_7_5_1-2012-11-29-release:1.1
	binutils-2_23_1:1.1
	sid-snapshot-20121101:1.1
	binutils-2_23:1.1
	sid-snapshot-20121001:1.1
	sid-snapshot-20120901:1.1
	gdb_7_5-2012-08-17-release:1.1
	sid-snapshot-20120801:1.1
	binutils-2_23-branch:1.1.0.56
	binutils-2_23-branchpoint:1.1
	gdb_7_5-branch:1.1.0.54
	gdb_7_5-2012-07-18-branchpoint:1.1
	sid-snapshot-20120701:1.1
	sid-snapshot-20120601:1.1
	sid-snapshot-20120501:1.1
	binutils-2_22_branch:1.1.0.52
	gdb_7_4_1-2012-04-26-release:1.1
	sid-snapshot-20120401:1.1
	sid-snapshot-20120301:1.1
	sid-snapshot-20120201:1.1
	gdb_7_4-2012-01-24-release:1.1
	sid-snapshot-20120101:1.1
	gdb_7_4-branch:1.1.0.50
	gdb_7_4-2011-12-13-branchpoint:1.1
	sid-snapshot-20111201:1.1
	binutils-2_22:1.1
	sid-snapshot-20111101:1.1
	sid-snapshot-20111001:1.1
	binutils-2_22-branch:1.1.0.48
	binutils-2_22-branchpoint:1.1
	gdb_7_3_1-2011-09-04-release:1.1
	sid-snapshot-20110901:1.1
	sid-snapshot-20110801:1.1
	gdb_7_3-2011-07-26-release:1.1
	sid-snapshot-20110701:1.1
	sid-snapshot-20110601:1.1
	sid-snapshot-20110501:1.1
	gdb_7_3-branch:1.1.0.46
	gdb_7_3-2011-04-01-branchpoint:1.1
	sid-snapshot-20110401:1.1
	sid-snapshot-20110301:1.1
	sid-snapshot-20110201:1.1
	sid-snapshot-20110101:1.1
	binutils-2_21:1.1
	sid-snapshot-20101201:1.1
	binutils-2_21-branch:1.1.0.44
	binutils-2_21-branchpoint:1.1
	sid-snapshot-20101101:1.1
	sid-snapshot-20101001:1.1
	binutils-2_20_1:1.1
	gdb_7_2-2010-09-02-release:1.1
	sid-snapshot-20100901:1.1
	sid-snapshot-20100801:1.1
	gdb_7_2-branch:1.1.0.42
	gdb_7_2-2010-07-07-branchpoint:1.1
	sid-snapshot-20100701:1.1
	sid-snapshot-20100601:1.1
	sid-snapshot-20100501:1.1
	sid-snapshot-20100401:1.1
	gdb_7_1-2010-03-18-release:1.1
	sid-snapshot-20100301:1.1
	gdb_7_1-branch:1.1.0.40
	gdb_7_1-2010-02-18-branchpoint:1.1
	sid-snapshot-20100201:1.1
	sid-snapshot-20100101:1.1
	gdb_7_0_1-2009-12-22-release:1.1
	sid-snapshot-20091201:1.1
	sid-snapshot-20091101:1.1
	binutils-2_20:1.1
	gdb_7_0-2009-10-06-release:1.1
	sid-snapshot-20091001:1.1
	gdb_7_0-branch:1.1.0.38
	gdb_7_0-2009-09-16-branchpoint:1.1
	arc-sim-20090309:1.1
	binutils-arc-20081103-branch:1.1.0.36
	binutils-arc-20081103-branchpoint:1.1
	binutils-2_20-branch:1.1.0.34
	binutils-2_20-branchpoint:1.1
	sid-snapshot-20090901:1.1
	sid-snapshot-20090801:1.1
	msnyder-checkpoint-072509-branch:1.1.0.32
	msnyder-checkpoint-072509-branchpoint:1.1
	sid-snapshot-20090701:1.1
	dje-cgen-play1-branch:1.1.0.30
	dje-cgen-play1-branchpoint:1.1
	sid-snapshot-20090601:1.1
	sid-snapshot-20090501:1.1
	sid-snapshot-20090401:1.1
	arc-20081103-branch:1.1.0.28
	arc-20081103-branchpoint:1.1
	arc-insight_6_8-branch:1.1.0.26
	arc-insight_6_8-branchpoint:1.1
	insight_6_8-branch:1.1.0.24
	insight_6_8-branchpoint:1.1
	sid-snapshot-20090301:1.1
	binutils-2_19_1:1.1
	sid-snapshot-20090201:1.1
	sid-snapshot-20090101:1.1
	reverse-20081226-branch:1.1.0.22
	reverse-20081226-branchpoint:1.1
	sid-snapshot-20081201:1.1
	multiprocess-20081120-branch:1.1.0.20
	multiprocess-20081120-branchpoint:1.1
	sid-snapshot-20081101:1.1
	binutils-2_19:1.1
	sid-snapshot-20081001:1.1
	reverse-20080930-branch:1.1.0.18
	reverse-20080930-branchpoint:1.1
	binutils-2_19-branch:1.1.0.16
	binutils-2_19-branchpoint:1.1
	sid-snapshot-20080901:1.1
	sid-snapshot-20080801:1.1
	reverse-20080717-branch:1.1.0.14
	reverse-20080717-branchpoint:1.1
	sid-snapshot-20080701:1.1
	msnyder-reverse-20080609-branch:1.1.0.12
	msnyder-reverse-20080609-branchpoint:1.1
	drow-reverse-20070409-branch:1.1.0.10
	drow-reverse-20070409-branchpoint:1.1
	sid-snapshot-20080601:1.1
	sid-snapshot-20080501:1.1
	sid-snapshot-20080403:1.1
	sid-snapshot-20080401:1.1
	gdb_6_8-2008-03-27-release:1.1
	sid-snapshot-20080301:1.1
	gdb_6_8-branch:1.1.0.8
	gdb_6_8-2008-02-26-branchpoint:1.1
	sid-snapshot-20080201:1.1
	sid-snapshot-20080101:1.1
	sid-snapshot-20071201:1.1
	sid-snapshot-20071101:1.1
	gdb_6_7_1-2007-10-29-release:1.1
	gdb_6_7-2007-10-10-release:1.1
	sid-snapshot-20071001:1.1
	gdb_6_7-branch:1.1.0.6
	gdb_6_7-2007-09-07-branchpoint:1.1
	binutils-2_18:1.1
	binutils-2_18-branch:1.1.0.4
	binutils-2_18-branchpoint:1.1
	insight_6_6-20070208-release:1.1
	gdb_6_6-2006-12-18-release:1.1
	gdb_6_6-branch:1.1.0.2
	gdb_6_6-2006-11-15-branchpoint:1.1
	nickrob-async-20060828-mergepoint:1.1
	binutils_latest_snapshot:1.1;
locks; strict;
comment	@ * @;


1.1
date	2006.05.22.15.30.13;	author sje;	state Exp;
branches;
next	;


desc
@@


1.1
log
@2006-05-22  Steve Ellcey  <sje@@cup.hp.com>

	* MAINTAINERS: Change intl updating instructions.
	* config.rpath: Copy from GCC tree.
	* intl: Replace contents of intl directory with intl from GCC tree.
@
text
@/* Provide relocatable packages.
   Copyright (C) 2003 Free Software Foundation, Inc.
   Written by Bruno Haible <bruno@@clisp.org>, 2003.

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU Library General Public License as published
   by the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.

   You should have received a copy of the GNU Library General Public
   License along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301,
   USA.  */


/* Tell glibc's <stdio.h> to provide a prototype for getline().
   This must come before <config.h> because <config.h> may include
   <features.h>, and once <features.h> has been included, it's too late.  */
#ifndef _GNU_SOURCE
# define _GNU_SOURCE	1
#endif

#ifdef HAVE_CONFIG_H
# include "config.h"
#endif

/* Specification.  */
#include "relocatable.h"

#if ENABLE_RELOCATABLE

#include <stddef.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#ifdef NO_XMALLOC
# define xmalloc malloc
#else
# include "xmalloc.h"
#endif

#if DEPENDS_ON_LIBCHARSET
# include <libcharset.h>
#endif
#if DEPENDS_ON_LIBICONV && HAVE_ICONV
# include <iconv.h>
#endif
#if DEPENDS_ON_LIBINTL && ENABLE_NLS
# include <libintl.h>
#endif

/* Faked cheap 'bool'.  */
#undef bool
#undef false
#undef true
#define bool int
#define false 0
#define true 1

/* Pathname support.
   ISSLASH(C)           tests whether C is a directory separator character.
   IS_PATH_WITH_DIR(P)  tests whether P contains a directory specification.
 */
#if defined _WIN32 || defined __WIN32__ || defined __EMX__ || defined __DJGPP__
  /* Win32, OS/2, DOS */
# define ISSLASH(C) ((C) == '/' || (C) == '\\')
# define HAS_DEVICE(P) \
    ((((P)[0] >= 'A' && (P)[0] <= 'Z') || ((P)[0] >= 'a' && (P)[0] <= 'z')) \
     && (P)[1] == ':')
# define IS_PATH_WITH_DIR(P) \
    (strchr (P, '/') != NULL || strchr (P, '\\') != NULL || HAS_DEVICE (P))
# define FILESYSTEM_PREFIX_LEN(P) (HAS_DEVICE (P) ? 2 : 0)
#else
  /* Unix */
# define ISSLASH(C) ((C) == '/')
# define IS_PATH_WITH_DIR(P) (strchr (P, '/') != NULL)
# define FILESYSTEM_PREFIX_LEN(P) 0
#endif

/* Original installation prefix.  */
static char *orig_prefix;
static size_t orig_prefix_len;
/* Current installation prefix.  */
static char *curr_prefix;
static size_t curr_prefix_len;
/* These prefixes do not end in a slash.  Anything that will be concatenated
   to them must start with a slash.  */

/* Sets the original and the current installation prefix of this module.
   Relocation simply replaces a pathname starting with the original prefix
   by the corresponding pathname with the current prefix instead.  Both
   prefixes should be directory names without trailing slash (i.e. use ""
   instead of "/").  */
static void
set_this_relocation_prefix (const char *orig_prefix_arg,
			    const char *curr_prefix_arg)
{
  if (orig_prefix_arg != NULL && curr_prefix_arg != NULL
      /* Optimization: if orig_prefix and curr_prefix are equal, the
	 relocation is a nop.  */
      && strcmp (orig_prefix_arg, curr_prefix_arg) != 0)
    {
      /* Duplicate the argument strings.  */
      char *memory;

      orig_prefix_len = strlen (orig_prefix_arg);
      curr_prefix_len = strlen (curr_prefix_arg);
      memory = (char *) xmalloc (orig_prefix_len + 1 + curr_prefix_len + 1);
#ifdef NO_XMALLOC
      if (memory != NULL)
#endif
	{
	  memcpy (memory, orig_prefix_arg, orig_prefix_len + 1);
	  orig_prefix = memory;
	  memory += orig_prefix_len + 1;
	  memcpy (memory, curr_prefix_arg, curr_prefix_len + 1);
	  curr_prefix = memory;
	  return;
	}
    }
  orig_prefix = NULL;
  curr_prefix = NULL;
  /* Don't worry about wasted memory here - this function is usually only
     called once.  */
}

/* Sets the original and the current installation prefix of the package.
   Relocation simply replaces a pathname starting with the original prefix
   by the corresponding pathname with the current prefix instead.  Both
   prefixes should be directory names without trailing slash (i.e. use ""
   instead of "/").  */
void
set_relocation_prefix (const char *orig_prefix_arg, const char *curr_prefix_arg)
{
  set_this_relocation_prefix (orig_prefix_arg, curr_prefix_arg);

  /* Now notify all dependent libraries.  */
#if DEPENDS_ON_LIBCHARSET
  libcharset_set_relocation_prefix (orig_prefix_arg, curr_prefix_arg);
#endif
#if DEPENDS_ON_LIBICONV && HAVE_ICONV && _LIBICONV_VERSION >= 0x0109
  libiconv_set_relocation_prefix (orig_prefix_arg, curr_prefix_arg);
#endif
#if DEPENDS_ON_LIBINTL && ENABLE_NLS && defined libintl_set_relocation_prefix
  libintl_set_relocation_prefix (orig_prefix_arg, curr_prefix_arg);
#endif
}

/* Convenience function:
   Computes the current installation prefix, based on the original
   installation prefix, the original installation directory of a particular
   file, and the current pathname of this file.  Returns NULL upon failure.  */
#ifdef IN_LIBRARY
#define compute_curr_prefix local_compute_curr_prefix
static
#endif
const char *
compute_curr_prefix (const char *orig_installprefix,
		     const char *orig_installdir,
		     const char *curr_pathname)
{
  const char *curr_installdir;
  const char *rel_installdir;

  if (curr_pathname == NULL)
    return NULL;

  /* Determine the relative installation directory, relative to the prefix.
     This is simply the difference between orig_installprefix and
     orig_installdir.  */
  if (strncmp (orig_installprefix, orig_installdir, strlen (orig_installprefix))
      != 0)
    /* Shouldn't happen - nothing should be installed outside $(prefix).  */
    return NULL;
  rel_installdir = orig_installdir + strlen (orig_installprefix);

  /* Determine the current installation directory.  */
  {
    const char *p_base = curr_pathname + FILESYSTEM_PREFIX_LEN (curr_pathname);
    const char *p = curr_pathname + strlen (curr_pathname);
    char *q;

    while (p > p_base)
      {
	p--;
	if (ISSLASH (*p))
	  break;
      }

    q = (char *) xmalloc (p - curr_pathname + 1);
#ifdef NO_XMALLOC
    if (q == NULL)
      return NULL;
#endif
    memcpy (q, curr_pathname, p - curr_pathname);
    q[p - curr_pathname] = '\0';
    curr_installdir = q;
  }

  /* Compute the current installation prefix by removing the trailing
     rel_installdir from it.  */
  {
    const char *rp = rel_installdir + strlen (rel_installdir);
    const char *cp = curr_installdir + strlen (curr_installdir);
    const char *cp_base =
      curr_installdir + FILESYSTEM_PREFIX_LEN (curr_installdir);

    while (rp > rel_installdir && cp > cp_base)
      {
	bool same = false;
	const char *rpi = rp;
	const char *cpi = cp;

	while (rpi > rel_installdir && cpi > cp_base)
	  {
	    rpi--;
	    cpi--;
	    if (ISSLASH (*rpi) || ISSLASH (*cpi))
	      {
		if (ISSLASH (*rpi) && ISSLASH (*cpi))
		  same = true;
		break;
	      }
#if defined _WIN32 || defined __WIN32__ || defined __EMX__ || defined __DJGPP__
	    /* Win32, OS/2, DOS - case insignificant filesystem */
	    if ((*rpi >= 'a' && *rpi <= 'z' ? *rpi - 'a' + 'A' : *rpi)
		!= (*cpi >= 'a' && *cpi <= 'z' ? *cpi - 'a' + 'A' : *cpi))
	      break;
#else
	    if (*rpi != *cpi)
	      break;
#endif
	  }
	if (!same)
	  break;
	/* The last pathname component was the same.  opi and cpi now point
	   to the slash before it.  */
	rp = rpi;
	cp = cpi;
      }

    if (rp > rel_installdir)
      /* Unexpected: The curr_installdir does not end with rel_installdir.  */
      return NULL;

    {
      size_t curr_prefix_len = cp - curr_installdir;
      char *curr_prefix;

      curr_prefix = (char *) xmalloc (curr_prefix_len + 1);
#ifdef NO_XMALLOC
      if (curr_prefix == NULL)
	return NULL;
#endif
      memcpy (curr_prefix, curr_installdir, curr_prefix_len);
      curr_prefix[curr_prefix_len] = '\0';

      return curr_prefix;
    }
  }
}

#if defined PIC && defined INSTALLDIR

/* Full pathname of shared library, or NULL.  */
static char *shared_library_fullname;

#if defined _WIN32 || defined __WIN32__

/* Determine the full pathname of the shared library when it is loaded.  */

BOOL WINAPI
DllMain (HINSTANCE module_handle, DWORD event, LPVOID reserved)
{
  (void) reserved;

  if (event == DLL_PROCESS_ATTACH)
    {
      /* The DLL is being loaded into an application's address range.  */
      static char location[MAX_PATH];

      if (!GetModuleFileName (module_handle, location, sizeof (location)))
	/* Shouldn't happen.  */
	return FALSE;

      if (!IS_PATH_WITH_DIR (location))
	/* Shouldn't happen.  */
	return FALSE;

      shared_library_fullname = strdup (location);
    }

  return TRUE;
}

#else /* Unix */

static void
find_shared_library_fullname ()
{
#ifdef __linux__
  FILE *fp;

  /* Open the current process' maps file.  It describes one VMA per line.  */
  fp = fopen ("/proc/self/maps", "r");
  if (fp)
    {
      unsigned long address = (unsigned long) &find_shared_library_fullname;
      for (;;)
	{
	  unsigned long start, end;
	  int c;

	  if (fscanf (fp, "%lx-%lx", &start, &end) != 2)
	    break;
	  if (address >= start && address <= end - 1)
	    {
	      /* Found it.  Now see if this line contains a filename.  */
	      while (c = getc (fp), c != EOF && c != '\n' && c != '/')
		continue;
	      if (c == '/')
		{
		  size_t size;
		  int len;

		  ungetc (c, fp);
		  shared_library_fullname = NULL; size = 0;
		  len = getline (&shared_library_fullname, &size, fp);
		  if (len >= 0)
		    {
		      /* Success: filled shared_library_fullname.  */
		      if (len > 0 && shared_library_fullname[len - 1] == '\n')
			shared_library_fullname[len - 1] = '\0';
		    }
		}
	      break;
	    }
	  while (c = getc (fp), c != EOF && c != '\n')
	    continue;
	}
      fclose (fp);
    }
#endif
}

#endif /* WIN32 / Unix */

/* Return the full pathname of the current shared library.
   Return NULL if unknown.
   Guaranteed to work only on Linux and Woe32.  */
static char *
get_shared_library_fullname ()
{
#if !(defined _WIN32 || defined __WIN32__)
  static bool tried_find_shared_library_fullname;
  if (!tried_find_shared_library_fullname)
    {
      find_shared_library_fullname ();
      tried_find_shared_library_fullname = true;
    }
#endif
  return shared_library_fullname;
}

#endif /* PIC */

/* Returns the pathname, relocated according to the current installation
   directory.  */
const char *
relocate (const char *pathname)
{
#if defined PIC && defined INSTALLDIR
  static int initialized;

  /* Initialization code for a shared library.  */
  if (!initialized)
    {
      /* At this point, orig_prefix and curr_prefix likely have already been
	 set through the main program's set_program_name_and_installdir
	 function.  This is sufficient in the case that the library has
	 initially been installed in the same orig_prefix.  But we can do
	 better, to also cover the cases that 1. it has been installed
	 in a different prefix before being moved to orig_prefix and (later)
	 to curr_prefix, 2. unlike the program, it has not moved away from
	 orig_prefix.  */
      const char *orig_installprefix = INSTALLPREFIX;
      const char *orig_installdir = INSTALLDIR;
      const char *curr_prefix_better;

      curr_prefix_better =
	compute_curr_prefix (orig_installprefix, orig_installdir,
			     get_shared_library_fullname ());
      if (curr_prefix_better == NULL)
	curr_prefix_better = curr_prefix;

      set_relocation_prefix (orig_installprefix, curr_prefix_better);

      initialized = 1;
    }
#endif

  /* Note: It is not necessary to perform case insensitive comparison here,
     even for DOS-like filesystems, because the pathname argument was
     typically created from the same Makefile variable as orig_prefix came
     from.  */
  if (orig_prefix != NULL && curr_prefix != NULL
      && strncmp (pathname, orig_prefix, orig_prefix_len) == 0)
    {
      if (pathname[orig_prefix_len] == '\0')
	/* pathname equals orig_prefix.  */
	return curr_prefix;
      if (ISSLASH (pathname[orig_prefix_len]))
	{
	  /* pathname starts with orig_prefix.  */
	  const char *pathname_tail = &pathname[orig_prefix_len];
	  char *result =
	    (char *) xmalloc (curr_prefix_len + strlen (pathname_tail) + 1);

#ifdef NO_XMALLOC
	  if (result != NULL)
#endif
	    {
	      memcpy (result, curr_prefix, curr_prefix_len);
	      strcpy (result + curr_prefix_len, pathname_tail);
	      return result;
	    }
	}
    }
  /* Nothing to relocate.  */
  return pathname;
}

#endif
@
