head	1.1;
access;
symbols
	sid-snapshot-20180601:1.1
	sid-snapshot-20180501:1.1
	sid-snapshot-20180401:1.1
	sid-snapshot-20180301:1.1
	sid-snapshot-20180201:1.1
	sid-snapshot-20180101:1.1
	sid-snapshot-20171201:1.1
	sid-snapshot-20171101:1.1
	sid-snapshot-20171001:1.1
	sid-snapshot-20170901:1.1
	sid-snapshot-20170801:1.1
	sid-snapshot-20170701:1.1
	sid-snapshot-20170601:1.1
	sid-snapshot-20170501:1.1
	sid-snapshot-20170401:1.1
	sid-snapshot-20170301:1.1
	sid-snapshot-20170201:1.1
	sid-snapshot-20170101:1.1
	sid-snapshot-20161201:1.1
	sid-snapshot-20161101:1.1
	sid-snapshot-20160901:1.1
	sid-snapshot-20160801:1.1
	sid-snapshot-20160701:1.1
	sid-snapshot-20160601:1.1
	sid-snapshot-20160501:1.1
	sid-snapshot-20160401:1.1
	sid-snapshot-20160301:1.1
	sid-snapshot-20160201:1.1
	sid-snapshot-20160101:1.1
	sid-snapshot-20151201:1.1
	sid-snapshot-20151101:1.1
	sid-snapshot-20151001:1.1
	sid-snapshot-20150901:1.1
	sid-snapshot-20150801:1.1
	sid-snapshot-20150701:1.1
	sid-snapshot-20150601:1.1
	sid-snapshot-20150501:1.1
	sid-snapshot-20150401:1.1
	sid-snapshot-20150301:1.1
	sid-snapshot-20150201:1.1
	sid-snapshot-20150101:1.1
	sid-snapshot-20141201:1.1
	sid-snapshot-20141101:1.1
	sid-snapshot-20141001:1.1
	sid-snapshot-20140901:1.1
	sid-snapshot-20140801:1.1
	sid-snapshot-20140701:1.1
	sid-snapshot-20140601:1.1
	sid-snapshot-20140501:1.1
	sid-snapshot-20140401:1.1
	sid-snapshot-20140301:1.1
	sid-snapshot-20140201:1.1
	sid-snapshot-20140101:1.1
	sid-snapshot-20131201:1.1
	sid-snapshot-20131101:1.1
	sid-snapshot-20131001:1.1
	binutils-2_24-branch:1.1.0.60
	binutils-2_24-branchpoint:1.1
	binutils-2_21_1:1.1
	sid-snapshot-20130901:1.1
	gdb_7_6_1-2013-08-30-release:1.1
	sid-snapshot-20130801:1.1
	sid-snapshot-20130701:1.1
	sid-snapshot-20130601:1.1
	sid-snapshot-20130501:1.1
	gdb_7_6-2013-04-26-release:1.1
	sid-snapshot-20130401:1.1
	binutils-2_23_2:1.1
	gdb_7_6-branch:1.1.0.58
	gdb_7_6-2013-03-12-branchpoint:1.1
	sid-snapshot-20130301:1.1
	sid-snapshot-20130201:1.1
	sid-snapshot-20130101:1.1
	sid-snapshot-20121201:1.1
	gdb_7_5_1-2012-11-29-release:1.1
	binutils-2_23_1:1.1
	sid-snapshot-20121101:1.1
	binutils-2_23:1.1
	sid-snapshot-20121001:1.1
	sid-snapshot-20120901:1.1
	gdb_7_5-2012-08-17-release:1.1
	sid-snapshot-20120801:1.1
	binutils-2_23-branch:1.1.0.56
	binutils-2_23-branchpoint:1.1
	gdb_7_5-branch:1.1.0.54
	gdb_7_5-2012-07-18-branchpoint:1.1
	sid-snapshot-20120701:1.1
	sid-snapshot-20120601:1.1
	sid-snapshot-20120501:1.1
	binutils-2_22_branch:1.1.0.52
	gdb_7_4_1-2012-04-26-release:1.1
	sid-snapshot-20120401:1.1
	sid-snapshot-20120301:1.1
	sid-snapshot-20120201:1.1
	gdb_7_4-2012-01-24-release:1.1
	sid-snapshot-20120101:1.1
	gdb_7_4-branch:1.1.0.50
	gdb_7_4-2011-12-13-branchpoint:1.1
	sid-snapshot-20111201:1.1
	binutils-2_22:1.1
	sid-snapshot-20111101:1.1
	sid-snapshot-20111001:1.1
	binutils-2_22-branch:1.1.0.48
	binutils-2_22-branchpoint:1.1
	gdb_7_3_1-2011-09-04-release:1.1
	sid-snapshot-20110901:1.1
	sid-snapshot-20110801:1.1
	gdb_7_3-2011-07-26-release:1.1
	sid-snapshot-20110701:1.1
	sid-snapshot-20110601:1.1
	sid-snapshot-20110501:1.1
	gdb_7_3-branch:1.1.0.46
	gdb_7_3-2011-04-01-branchpoint:1.1
	sid-snapshot-20110401:1.1
	sid-snapshot-20110301:1.1
	sid-snapshot-20110201:1.1
	sid-snapshot-20110101:1.1
	binutils-2_21:1.1
	sid-snapshot-20101201:1.1
	binutils-2_21-branch:1.1.0.44
	binutils-2_21-branchpoint:1.1
	sid-snapshot-20101101:1.1
	sid-snapshot-20101001:1.1
	binutils-2_20_1:1.1
	gdb_7_2-2010-09-02-release:1.1
	sid-snapshot-20100901:1.1
	sid-snapshot-20100801:1.1
	gdb_7_2-branch:1.1.0.42
	gdb_7_2-2010-07-07-branchpoint:1.1
	sid-snapshot-20100701:1.1
	sid-snapshot-20100601:1.1
	sid-snapshot-20100501:1.1
	sid-snapshot-20100401:1.1
	gdb_7_1-2010-03-18-release:1.1
	sid-snapshot-20100301:1.1
	gdb_7_1-branch:1.1.0.40
	gdb_7_1-2010-02-18-branchpoint:1.1
	sid-snapshot-20100201:1.1
	sid-snapshot-20100101:1.1
	gdb_7_0_1-2009-12-22-release:1.1
	sid-snapshot-20091201:1.1
	sid-snapshot-20091101:1.1
	binutils-2_20:1.1
	gdb_7_0-2009-10-06-release:1.1
	sid-snapshot-20091001:1.1
	gdb_7_0-branch:1.1.0.38
	gdb_7_0-2009-09-16-branchpoint:1.1
	arc-sim-20090309:1.1
	binutils-arc-20081103-branch:1.1.0.36
	binutils-arc-20081103-branchpoint:1.1
	binutils-2_20-branch:1.1.0.34
	binutils-2_20-branchpoint:1.1
	sid-snapshot-20090901:1.1
	sid-snapshot-20090801:1.1
	msnyder-checkpoint-072509-branch:1.1.0.32
	msnyder-checkpoint-072509-branchpoint:1.1
	sid-snapshot-20090701:1.1
	dje-cgen-play1-branch:1.1.0.30
	dje-cgen-play1-branchpoint:1.1
	sid-snapshot-20090601:1.1
	sid-snapshot-20090501:1.1
	sid-snapshot-20090401:1.1
	arc-20081103-branch:1.1.0.28
	arc-20081103-branchpoint:1.1
	arc-insight_6_8-branch:1.1.0.26
	arc-insight_6_8-branchpoint:1.1
	insight_6_8-branch:1.1.0.24
	insight_6_8-branchpoint:1.1
	sid-snapshot-20090301:1.1
	binutils-2_19_1:1.1
	sid-snapshot-20090201:1.1
	sid-snapshot-20090101:1.1
	reverse-20081226-branch:1.1.0.22
	reverse-20081226-branchpoint:1.1
	sid-snapshot-20081201:1.1
	multiprocess-20081120-branch:1.1.0.20
	multiprocess-20081120-branchpoint:1.1
	sid-snapshot-20081101:1.1
	binutils-2_19:1.1
	sid-snapshot-20081001:1.1
	reverse-20080930-branch:1.1.0.18
	reverse-20080930-branchpoint:1.1
	binutils-2_19-branch:1.1.0.16
	binutils-2_19-branchpoint:1.1
	sid-snapshot-20080901:1.1
	sid-snapshot-20080801:1.1
	reverse-20080717-branch:1.1.0.14
	reverse-20080717-branchpoint:1.1
	sid-snapshot-20080701:1.1
	msnyder-reverse-20080609-branch:1.1.0.12
	msnyder-reverse-20080609-branchpoint:1.1
	drow-reverse-20070409-branch:1.1.0.10
	drow-reverse-20070409-branchpoint:1.1
	sid-snapshot-20080601:1.1
	sid-snapshot-20080501:1.1
	sid-snapshot-20080403:1.1
	sid-snapshot-20080401:1.1
	gdb_6_8-2008-03-27-release:1.1
	sid-snapshot-20080301:1.1
	gdb_6_8-branch:1.1.0.8
	gdb_6_8-2008-02-26-branchpoint:1.1
	sid-snapshot-20080201:1.1
	sid-snapshot-20080101:1.1
	sid-snapshot-20071201:1.1
	sid-snapshot-20071101:1.1
	gdb_6_7_1-2007-10-29-release:1.1
	gdb_6_7-2007-10-10-release:1.1
	sid-snapshot-20071001:1.1
	gdb_6_7-branch:1.1.0.6
	gdb_6_7-2007-09-07-branchpoint:1.1
	binutils-2_18:1.1
	binutils-2_18-branch:1.1.0.4
	binutils-2_18-branchpoint:1.1
	insight_6_6-20070208-release:1.1
	gdb_6_6-2006-12-18-release:1.1
	gdb_6_6-branch:1.1.0.2
	gdb_6_6-2006-11-15-branchpoint:1.1
	nickrob-async-20060828-mergepoint:1.1
	binutils_latest_snapshot:1.1;
locks; strict;
comment	@ * @;


1.1
date	2006.05.22.15.30.13;	author sje;	state Exp;
branches;
next	;


desc
@@


1.1
log
@2006-05-22  Steve Ellcey  <sje@@cup.hp.com>

	* MAINTAINERS: Change intl updating instructions.
	* config.rpath: Copy from GCC tree.
	* intl: Replace contents of intl directory with intl from GCC tree.
@
text
@%{
/* Expression parsing for plural form selection.
   Copyright (C) 2000, 2001 Free Software Foundation, Inc.
   Written by Ulrich Drepper <drepper@@cygnus.com>, 2000.

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU Library General Public License as published
   by the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.

   You should have received a copy of the GNU Library General Public
   License along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301,
   USA.  */

/* The bison generated parser uses alloca.  AIX 3 forces us to put this
   declaration at the beginning of the file.  The declaration in bison's
   skeleton file comes too late.  This must come before <config.h>
   because <config.h> may include arbitrary system headers.  */
#if defined _AIX && !defined __GNUC__
 #pragma alloca
#endif

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

#include <stddef.h>
#include <stdlib.h>
#include "plural-exp.h"

/* The main function generated by the parser is called __gettextparse,
   but we want it to be called PLURAL_PARSE.  */
#ifndef _LIBC
# define __gettextparse PLURAL_PARSE
#endif

#define YYLEX_PARAM	&((struct parse_args *) arg)->cp
#define YYPARSE_PARAM	arg
%}
%pure_parser
%expect 7

%union {
  unsigned long int num;
  enum operator op;
  struct expression *exp;
}

%{
/* Prototypes for local functions.  */
static struct expression *new_exp PARAMS ((int nargs, enum operator op,
					   struct expression * const *args));
static inline struct expression *new_exp_0 PARAMS ((enum operator op));
static inline struct expression *new_exp_1 PARAMS ((enum operator op,
						   struct expression *right));
static struct expression *new_exp_2 PARAMS ((enum operator op,
					     struct expression *left,
					     struct expression *right));
static inline struct expression *new_exp_3 PARAMS ((enum operator op,
						   struct expression *bexp,
						   struct expression *tbranch,
						   struct expression *fbranch));
static int yylex PARAMS ((YYSTYPE *lval, const char **pexp));
static void yyerror PARAMS ((const char *str));

/* Allocation of expressions.  */

static struct expression *
new_exp (nargs, op, args)
     int nargs;
     enum operator op;
     struct expression * const *args;
{
  int i;
  struct expression *newp;

  /* If any of the argument could not be malloc'ed, just return NULL.  */
  for (i = nargs - 1; i >= 0; i--)
    if (args[i] == NULL)
      goto fail;

  /* Allocate a new expression.  */
  newp = (struct expression *) malloc (sizeof (*newp));
  if (newp != NULL)
    {
      newp->nargs = nargs;
      newp->operation = op;
      for (i = nargs - 1; i >= 0; i--)
	newp->val.args[i] = args[i];
      return newp;
    }

 fail:
  for (i = nargs - 1; i >= 0; i--)
    FREE_EXPRESSION (args[i]);

  return NULL;
}

static inline struct expression *
new_exp_0 (op)
     enum operator op;
{
  return new_exp (0, op, NULL);
}

static inline struct expression *
new_exp_1 (op, right)
     enum operator op;
     struct expression *right;
{
  struct expression *args[1];

  args[0] = right;
  return new_exp (1, op, args);
}

static struct expression *
new_exp_2 (op, left, right)
     enum operator op;
     struct expression *left;
     struct expression *right;
{
  struct expression *args[2];

  args[0] = left;
  args[1] = right;
  return new_exp (2, op, args);
}

static inline struct expression *
new_exp_3 (op, bexp, tbranch, fbranch)
     enum operator op;
     struct expression *bexp;
     struct expression *tbranch;
     struct expression *fbranch;
{
  struct expression *args[3];

  args[0] = bexp;
  args[1] = tbranch;
  args[2] = fbranch;
  return new_exp (3, op, args);
}

%}

/* This declares that all operators have the same associativity and the
   precedence order as in C.  See [Harbison, Steele: C, A Reference Manual].
   There is no unary minus and no bitwise operators.
   Operators with the same syntactic behaviour have been merged into a single
   token, to save space in the array generated by bison.  */
%right '?'		/*   ?		*/
%left '|'		/*   ||		*/
%left '&'		/*   &&		*/
%left EQUOP2		/*   == !=	*/
%left CMPOP2		/*   < > <= >=	*/
%left ADDOP2		/*   + -	*/
%left MULOP2		/*   * / %	*/
%right '!'		/*   !		*/

%token <op> EQUOP2 CMPOP2 ADDOP2 MULOP2
%token <num> NUMBER
%type <exp> exp

%%

start:	  exp
	  {
	    if ($1 == NULL)
	      YYABORT;
	    ((struct parse_args *) arg)->res = $1;
	  }
	;

exp:	  exp '?' exp ':' exp
	  {
	    $$ = new_exp_3 (qmop, $1, $3, $5);
	  }
	| exp '|' exp
	  {
	    $$ = new_exp_2 (lor, $1, $3);
	  }
	| exp '&' exp
	  {
	    $$ = new_exp_2 (land, $1, $3);
	  }
	| exp EQUOP2 exp
	  {
	    $$ = new_exp_2 ($2, $1, $3);
	  }
	| exp CMPOP2 exp
	  {
	    $$ = new_exp_2 ($2, $1, $3);
	  }
	| exp ADDOP2 exp
	  {
	    $$ = new_exp_2 ($2, $1, $3);
	  }
	| exp MULOP2 exp
	  {
	    $$ = new_exp_2 ($2, $1, $3);
	  }
	| '!' exp
	  {
	    $$ = new_exp_1 (lnot, $2);
	  }
	| 'n'
	  {
	    $$ = new_exp_0 (var);
	  }
	| NUMBER
	  {
	    if (($$ = new_exp_0 (num)) != NULL)
	      $$->val.num = $1;
	  }
	| '(' exp ')'
	  {
	    $$ = $2;
	  }
	;

%%

void
internal_function
FREE_EXPRESSION (exp)
     struct expression *exp;
{
  if (exp == NULL)
    return;

  /* Handle the recursive case.  */
  switch (exp->nargs)
    {
    case 3:
      FREE_EXPRESSION (exp->val.args[2]);
      /* FALLTHROUGH */
    case 2:
      FREE_EXPRESSION (exp->val.args[1]);
      /* FALLTHROUGH */
    case 1:
      FREE_EXPRESSION (exp->val.args[0]);
      /* FALLTHROUGH */
    default:
      break;
    }

  free (exp);
}


static int
yylex (lval, pexp)
     YYSTYPE *lval;
     const char **pexp;
{
  const char *exp = *pexp;
  int result;

  while (1)
    {
      if (exp[0] == '\0')
	{
	  *pexp = exp;
	  return YYEOF;
	}

      if (exp[0] != ' ' && exp[0] != '\t')
	break;

      ++exp;
    }

  result = *exp++;
  switch (result)
    {
    case '0': case '1': case '2': case '3': case '4':
    case '5': case '6': case '7': case '8': case '9':
      {
	unsigned long int n = result - '0';
	while (exp[0] >= '0' && exp[0] <= '9')
	  {
	    n *= 10;
	    n += exp[0] - '0';
	    ++exp;
	  }
	lval->num = n;
	result = NUMBER;
      }
      break;

    case '=':
      if (exp[0] == '=')
	{
	  ++exp;
	  lval->op = equal;
	  result = EQUOP2;
	}
      else
	result = YYERRCODE;
      break;

    case '!':
      if (exp[0] == '=')
	{
	  ++exp;
	  lval->op = not_equal;
	  result = EQUOP2;
	}
      break;

    case '&':
    case '|':
      if (exp[0] == result)
	++exp;
      else
	result = YYERRCODE;
      break;

    case '<':
      if (exp[0] == '=')
	{
	  ++exp;
	  lval->op = less_or_equal;
	}
      else
	lval->op = less_than;
      result = CMPOP2;
      break;

    case '>':
      if (exp[0] == '=')
	{
	  ++exp;
	  lval->op = greater_or_equal;
	}
      else
	lval->op = greater_than;
      result = CMPOP2;
      break;

    case '*':
      lval->op = mult;
      result = MULOP2;
      break;

    case '/':
      lval->op = divide;
      result = MULOP2;
      break;

    case '%':
      lval->op = module;
      result = MULOP2;
      break;

    case '+':
      lval->op = plus;
      result = ADDOP2;
      break;

    case '-':
      lval->op = minus;
      result = ADDOP2;
      break;

    case 'n':
    case '?':
    case ':':
    case '(':
    case ')':
      /* Nothing, just return the character.  */
      break;

    case ';':
    case '\n':
    case '\0':
      /* Be safe and let the user call this function again.  */
      --exp;
      result = YYEOF;
      break;

    default:
      result = YYERRCODE;
#if YYDEBUG != 0
      --exp;
#endif
      break;
    }

  *pexp = exp;

  return result;
}


static void
yyerror (str)
     const char *str;
{
  /* Do nothing.  We don't print error messages here.  */
}
@
