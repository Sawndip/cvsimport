head	1.1;
access;
symbols
	sid-snapshot-20180601:1.1
	sid-snapshot-20180501:1.1
	sid-snapshot-20180401:1.1
	sid-snapshot-20180301:1.1
	sid-snapshot-20180201:1.1
	sid-snapshot-20180101:1.1
	sid-snapshot-20171201:1.1
	sid-snapshot-20171101:1.1
	sid-snapshot-20171001:1.1
	sid-snapshot-20170901:1.1
	sid-snapshot-20170801:1.1
	sid-snapshot-20170701:1.1
	sid-snapshot-20170601:1.1
	sid-snapshot-20170501:1.1
	sid-snapshot-20170401:1.1
	sid-snapshot-20170301:1.1
	sid-snapshot-20170201:1.1
	sid-snapshot-20170101:1.1
	sid-snapshot-20161201:1.1
	sid-snapshot-20161101:1.1
	sid-snapshot-20160901:1.1
	sid-snapshot-20160801:1.1
	sid-snapshot-20160701:1.1
	sid-snapshot-20160601:1.1
	sid-snapshot-20160501:1.1
	sid-snapshot-20160401:1.1
	sid-snapshot-20160301:1.1
	sid-snapshot-20160201:1.1
	sid-snapshot-20160101:1.1
	sid-snapshot-20151201:1.1
	sid-snapshot-20151101:1.1
	sid-snapshot-20151001:1.1
	sid-snapshot-20150901:1.1
	sid-snapshot-20150801:1.1
	sid-snapshot-20150701:1.1
	sid-snapshot-20150601:1.1
	sid-snapshot-20150501:1.1
	sid-snapshot-20150401:1.1
	sid-snapshot-20150301:1.1
	sid-snapshot-20150201:1.1
	sid-snapshot-20150101:1.1
	sid-snapshot-20141201:1.1
	sid-snapshot-20141101:1.1
	sid-snapshot-20141001:1.1
	sid-snapshot-20140901:1.1
	sid-snapshot-20140801:1.1
	sid-snapshot-20140701:1.1
	sid-snapshot-20140601:1.1
	sid-snapshot-20140501:1.1
	sid-snapshot-20140401:1.1
	sid-snapshot-20140301:1.1
	sid-snapshot-20140201:1.1
	sid-snapshot-20140101:1.1
	sid-snapshot-20131201:1.1
	sid-snapshot-20131101:1.1
	sid-snapshot-20131001:1.1
	binutils-2_24-branch:1.1.0.60
	binutils-2_24-branchpoint:1.1
	binutils-2_21_1:1.1
	sid-snapshot-20130901:1.1
	gdb_7_6_1-2013-08-30-release:1.1
	sid-snapshot-20130801:1.1
	sid-snapshot-20130701:1.1
	sid-snapshot-20130601:1.1
	sid-snapshot-20130501:1.1
	gdb_7_6-2013-04-26-release:1.1
	sid-snapshot-20130401:1.1
	binutils-2_23_2:1.1
	gdb_7_6-branch:1.1.0.58
	gdb_7_6-2013-03-12-branchpoint:1.1
	sid-snapshot-20130301:1.1
	sid-snapshot-20130201:1.1
	sid-snapshot-20130101:1.1
	sid-snapshot-20121201:1.1
	gdb_7_5_1-2012-11-29-release:1.1
	binutils-2_23_1:1.1
	sid-snapshot-20121101:1.1
	binutils-2_23:1.1
	sid-snapshot-20121001:1.1
	sid-snapshot-20120901:1.1
	gdb_7_5-2012-08-17-release:1.1
	sid-snapshot-20120801:1.1
	binutils-2_23-branch:1.1.0.56
	binutils-2_23-branchpoint:1.1
	gdb_7_5-branch:1.1.0.54
	gdb_7_5-2012-07-18-branchpoint:1.1
	sid-snapshot-20120701:1.1
	sid-snapshot-20120601:1.1
	sid-snapshot-20120501:1.1
	binutils-2_22_branch:1.1.0.52
	gdb_7_4_1-2012-04-26-release:1.1
	sid-snapshot-20120401:1.1
	sid-snapshot-20120301:1.1
	sid-snapshot-20120201:1.1
	gdb_7_4-2012-01-24-release:1.1
	sid-snapshot-20120101:1.1
	gdb_7_4-branch:1.1.0.50
	gdb_7_4-2011-12-13-branchpoint:1.1
	sid-snapshot-20111201:1.1
	binutils-2_22:1.1
	sid-snapshot-20111101:1.1
	sid-snapshot-20111001:1.1
	binutils-2_22-branch:1.1.0.48
	binutils-2_22-branchpoint:1.1
	gdb_7_3_1-2011-09-04-release:1.1
	sid-snapshot-20110901:1.1
	sid-snapshot-20110801:1.1
	gdb_7_3-2011-07-26-release:1.1
	sid-snapshot-20110701:1.1
	sid-snapshot-20110601:1.1
	sid-snapshot-20110501:1.1
	gdb_7_3-branch:1.1.0.46
	gdb_7_3-2011-04-01-branchpoint:1.1
	sid-snapshot-20110401:1.1
	sid-snapshot-20110301:1.1
	sid-snapshot-20110201:1.1
	sid-snapshot-20110101:1.1
	binutils-2_21:1.1
	sid-snapshot-20101201:1.1
	binutils-2_21-branch:1.1.0.44
	binutils-2_21-branchpoint:1.1
	sid-snapshot-20101101:1.1
	sid-snapshot-20101001:1.1
	binutils-2_20_1:1.1
	gdb_7_2-2010-09-02-release:1.1
	sid-snapshot-20100901:1.1
	sid-snapshot-20100801:1.1
	gdb_7_2-branch:1.1.0.42
	gdb_7_2-2010-07-07-branchpoint:1.1
	sid-snapshot-20100701:1.1
	sid-snapshot-20100601:1.1
	sid-snapshot-20100501:1.1
	sid-snapshot-20100401:1.1
	gdb_7_1-2010-03-18-release:1.1
	sid-snapshot-20100301:1.1
	gdb_7_1-branch:1.1.0.40
	gdb_7_1-2010-02-18-branchpoint:1.1
	sid-snapshot-20100201:1.1
	sid-snapshot-20100101:1.1
	gdb_7_0_1-2009-12-22-release:1.1
	sid-snapshot-20091201:1.1
	sid-snapshot-20091101:1.1
	binutils-2_20:1.1
	gdb_7_0-2009-10-06-release:1.1
	sid-snapshot-20091001:1.1
	gdb_7_0-branch:1.1.0.38
	gdb_7_0-2009-09-16-branchpoint:1.1
	arc-sim-20090309:1.1
	binutils-arc-20081103-branch:1.1.0.36
	binutils-arc-20081103-branchpoint:1.1
	binutils-2_20-branch:1.1.0.34
	binutils-2_20-branchpoint:1.1
	sid-snapshot-20090901:1.1
	sid-snapshot-20090801:1.1
	msnyder-checkpoint-072509-branch:1.1.0.32
	msnyder-checkpoint-072509-branchpoint:1.1
	sid-snapshot-20090701:1.1
	dje-cgen-play1-branch:1.1.0.30
	dje-cgen-play1-branchpoint:1.1
	sid-snapshot-20090601:1.1
	sid-snapshot-20090501:1.1
	sid-snapshot-20090401:1.1
	arc-20081103-branch:1.1.0.28
	arc-20081103-branchpoint:1.1
	arc-insight_6_8-branch:1.1.0.26
	arc-insight_6_8-branchpoint:1.1
	insight_6_8-branch:1.1.0.24
	insight_6_8-branchpoint:1.1
	sid-snapshot-20090301:1.1
	binutils-2_19_1:1.1
	sid-snapshot-20090201:1.1
	sid-snapshot-20090101:1.1
	reverse-20081226-branch:1.1.0.22
	reverse-20081226-branchpoint:1.1
	sid-snapshot-20081201:1.1
	multiprocess-20081120-branch:1.1.0.20
	multiprocess-20081120-branchpoint:1.1
	sid-snapshot-20081101:1.1
	binutils-2_19:1.1
	sid-snapshot-20081001:1.1
	reverse-20080930-branch:1.1.0.18
	reverse-20080930-branchpoint:1.1
	binutils-2_19-branch:1.1.0.16
	binutils-2_19-branchpoint:1.1
	sid-snapshot-20080901:1.1
	sid-snapshot-20080801:1.1
	reverse-20080717-branch:1.1.0.14
	reverse-20080717-branchpoint:1.1
	sid-snapshot-20080701:1.1
	msnyder-reverse-20080609-branch:1.1.0.12
	msnyder-reverse-20080609-branchpoint:1.1
	drow-reverse-20070409-branch:1.1.0.10
	drow-reverse-20070409-branchpoint:1.1
	sid-snapshot-20080601:1.1
	sid-snapshot-20080501:1.1
	sid-snapshot-20080403:1.1
	sid-snapshot-20080401:1.1
	gdb_6_8-2008-03-27-release:1.1
	sid-snapshot-20080301:1.1
	gdb_6_8-branch:1.1.0.8
	gdb_6_8-2008-02-26-branchpoint:1.1
	sid-snapshot-20080201:1.1
	sid-snapshot-20080101:1.1
	sid-snapshot-20071201:1.1
	sid-snapshot-20071101:1.1
	gdb_6_7_1-2007-10-29-release:1.1
	gdb_6_7-2007-10-10-release:1.1
	sid-snapshot-20071001:1.1
	gdb_6_7-branch:1.1.0.6
	gdb_6_7-2007-09-07-branchpoint:1.1
	binutils-2_18:1.1
	binutils-2_18-branch:1.1.0.4
	binutils-2_18-branchpoint:1.1
	insight_6_6-20070208-release:1.1
	gdb_6_6-2006-12-18-release:1.1
	gdb_6_6-branch:1.1.0.2
	gdb_6_6-2006-11-15-branchpoint:1.1
	nickrob-async-20060828-mergepoint:1.1
	binutils_latest_snapshot:1.1;
locks; strict;
comment	@ * @;


1.1
date	2006.05.22.15.30.13;	author sje;	state Exp;
branches;
next	;


desc
@@


1.1
log
@2006-05-22  Steve Ellcey  <sje@@cup.hp.com>

	* MAINTAINERS: Change intl updating instructions.
	* config.rpath: Copy from GCC tree.
	* intl: Replace contents of intl directory with intl from GCC tree.
@
text
@/* Determine a canonical name for the current locale's character encoding.

   Copyright (C) 2000-2003 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU Library General Public License as published
   by the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.

   You should have received a copy of the GNU Library General Public
   License along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301,
   USA.  */

/* Written by Bruno Haible <bruno@@clisp.org>.  */

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

/* Specification.  */
#include "localcharset.h"

#if HAVE_STDDEF_H
# include <stddef.h>
#endif

#include <stdio.h>
#if HAVE_STRING_H
# include <string.h>
#else
# include <strings.h>
#endif
#if HAVE_STDLIB_H
# include <stdlib.h>
#endif

#if defined _WIN32 || defined __WIN32__
# undef WIN32   /* avoid warning on mingw32 */
# define WIN32
#endif

#if defined __EMX__
/* Assume EMX program runs on OS/2, even if compiled under DOS.  */
# define OS2
#endif

#if !defined WIN32
# if HAVE_LANGINFO_CODESET
#  include <langinfo.h>
# else
#  if HAVE_SETLOCALE
#   include <locale.h>
#  endif
# endif
#elif defined WIN32
# define WIN32_LEAN_AND_MEAN
# include <windows.h>
#endif
#if defined OS2
# define INCL_DOS
# include <os2.h>
#endif

#if ENABLE_RELOCATABLE
# include "relocatable.h"
#else
# define relocate(pathname) (pathname)
#endif

#if defined _WIN32 || defined __WIN32__ || defined __EMX__ || defined __DJGPP__
  /* Win32, OS/2, DOS */
# define ISSLASH(C) ((C) == '/' || (C) == '\\')
#endif

#ifndef DIRECTORY_SEPARATOR
# define DIRECTORY_SEPARATOR '/'
#endif

#ifndef ISSLASH
# define ISSLASH(C) ((C) == DIRECTORY_SEPARATOR)
#endif

#ifdef HAVE_GETC_UNLOCKED
# undef getc
# define getc getc_unlocked
#endif

/* The following static variable is declared 'volatile' to avoid a
   possible multithread problem in the function get_charset_aliases. If we
   are running in a threaded environment, and if two threads initialize
   'charset_aliases' simultaneously, both will produce the same value,
   and everything will be ok if the two assignments to 'charset_aliases'
   are atomic. But I don't know what will happen if the two assignments mix.  */
#if __STDC__ != 1
# define volatile /* empty */
#endif
/* Pointer to the contents of the charset.alias file, if it has already been
   read, else NULL.  Its format is:
   ALIAS_1 '\0' CANONICAL_1 '\0' ... ALIAS_n '\0' CANONICAL_n '\0' '\0'  */
static const char * volatile charset_aliases;

/* Return a pointer to the contents of the charset.alias file.  */
static const char *
get_charset_aliases ()
{
  const char *cp;

  cp = charset_aliases;
  if (cp == NULL)
    {
#if !(defined VMS || defined WIN32)
      FILE *fp;
      const char *dir = relocate (LIBDIR);
      const char *base = "charset.alias";
      char *file_name;

      /* Concatenate dir and base into freshly allocated file_name.  */
      {
	size_t dir_len = strlen (dir);
	size_t base_len = strlen (base);
	int add_slash = (dir_len > 0 && !ISSLASH (dir[dir_len - 1]));
	file_name = (char *) malloc (dir_len + add_slash + base_len + 1);
	if (file_name != NULL)
	  {
	    memcpy (file_name, dir, dir_len);
	    if (add_slash)
	      file_name[dir_len] = DIRECTORY_SEPARATOR;
	    memcpy (file_name + dir_len + add_slash, base, base_len + 1);
	  }
      }

      if (file_name == NULL || (fp = fopen (file_name, "r")) == NULL)
	/* Out of memory or file not found, treat it as empty.  */
	cp = "";
      else
	{
	  /* Parse the file's contents.  */
	  int c;
	  char buf1[50+1];
	  char buf2[50+1];
	  char *res_ptr = NULL;
	  size_t res_size = 0;
	  size_t l1, l2;

	  for (;;)
	    {
	      c = getc (fp);
	      if (c == EOF)
		break;
	      if (c == '\n' || c == ' ' || c == '\t')
		continue;
	      if (c == '#')
		{
		  /* Skip comment, to end of line.  */
		  do
		    c = getc (fp);
		  while (!(c == EOF || c == '\n'));
		  if (c == EOF)
		    break;
		  continue;
		}
	      ungetc (c, fp);
	      if (fscanf (fp, "%50s %50s", buf1, buf2) < 2)
		break;
	      l1 = strlen (buf1);
	      l2 = strlen (buf2);
	      if (res_size == 0)
		{
		  res_size = l1 + 1 + l2 + 1;
		  res_ptr = (char *) malloc (res_size + 1);
		}
	      else
		{
		  res_size += l1 + 1 + l2 + 1;
		  res_ptr = (char *) realloc (res_ptr, res_size + 1);
		}
	      if (res_ptr == NULL)
		{
		  /* Out of memory. */
		  res_size = 0;
		  break;
		}
	      strcpy (res_ptr + res_size - (l2 + 1) - (l1 + 1), buf1);
	      strcpy (res_ptr + res_size - (l2 + 1), buf2);
	    }
	  fclose (fp);
	  if (res_size == 0)
	    cp = "";
	  else
	    {
	      *(res_ptr + res_size) = '\0';
	      cp = res_ptr;
	    }
	}

      if (file_name != NULL)
	free (file_name);

#else

# if defined VMS
      /* To avoid the troubles of an extra file charset.alias_vms in the
	 sources of many GNU packages, simply inline the aliases here.  */
      /* The list of encodings is taken from the OpenVMS 7.3-1 documentation
	 "Compaq C Run-Time Library Reference Manual for OpenVMS systems"
	 section 10.7 "Handling Different Character Sets".  */
      cp = "ISO8859-1" "\0" "ISO-8859-1" "\0"
	   "ISO8859-2" "\0" "ISO-8859-2" "\0"
	   "ISO8859-5" "\0" "ISO-8859-5" "\0"
	   "ISO8859-7" "\0" "ISO-8859-7" "\0"
	   "ISO8859-8" "\0" "ISO-8859-8" "\0"
	   "ISO8859-9" "\0" "ISO-8859-9" "\0"
	   /* Japanese */
	   "eucJP" "\0" "EUC-JP" "\0"
	   "SJIS" "\0" "SHIFT_JIS" "\0"
	   "DECKANJI" "\0" "DEC-KANJI" "\0"
	   "SDECKANJI" "\0" "EUC-JP" "\0"
	   /* Chinese */
	   "eucTW" "\0" "EUC-TW" "\0"
	   "DECHANYU" "\0" "DEC-HANYU" "\0"
	   "DECHANZI" "\0" "GB2312" "\0"
	   /* Korean */
	   "DECKOREAN" "\0" "EUC-KR" "\0";
# endif

# if defined WIN32
      /* To avoid the troubles of installing a separate file in the same
	 directory as the DLL and of retrieving the DLL's directory at
	 runtime, simply inline the aliases here.  */

      cp = "CP936" "\0" "GBK" "\0"
	   "CP1361" "\0" "JOHAB" "\0"
	   "CP20127" "\0" "ASCII" "\0"
	   "CP20866" "\0" "KOI8-R" "\0"
	   "CP21866" "\0" "KOI8-RU" "\0"
	   "CP28591" "\0" "ISO-8859-1" "\0"
	   "CP28592" "\0" "ISO-8859-2" "\0"
	   "CP28593" "\0" "ISO-8859-3" "\0"
	   "CP28594" "\0" "ISO-8859-4" "\0"
	   "CP28595" "\0" "ISO-8859-5" "\0"
	   "CP28596" "\0" "ISO-8859-6" "\0"
	   "CP28597" "\0" "ISO-8859-7" "\0"
	   "CP28598" "\0" "ISO-8859-8" "\0"
	   "CP28599" "\0" "ISO-8859-9" "\0"
	   "CP28605" "\0" "ISO-8859-15" "\0";
# endif
#endif

      charset_aliases = cp;
    }

  return cp;
}

/* Determine the current locale's character encoding, and canonicalize it
   into one of the canonical names listed in config.charset.
   The result must not be freed; it is statically allocated.
   If the canonical name cannot be determined, the result is a non-canonical
   name.  */

#ifdef STATIC
STATIC
#endif
const char *
locale_charset ()
{
  const char *codeset;
  const char *aliases;

#if !(defined WIN32 || defined OS2)

# if HAVE_LANGINFO_CODESET

  /* Most systems support nl_langinfo (CODESET) nowadays.  */
  codeset = nl_langinfo (CODESET);

# else

  /* On old systems which lack it, use setlocale or getenv.  */
  const char *locale = NULL;

  /* But most old systems don't have a complete set of locales.  Some
     (like SunOS 4 or DJGPP) have only the C locale.  Therefore we don't
     use setlocale here; it would return "C" when it doesn't support the
     locale name the user has set.  */
#  if HAVE_SETLOCALE && 0
  locale = setlocale (LC_CTYPE, NULL);
#  endif
  if (locale == NULL || locale[0] == '\0')
    {
      locale = getenv ("LC_ALL");
      if (locale == NULL || locale[0] == '\0')
	{
	  locale = getenv ("LC_CTYPE");
	  if (locale == NULL || locale[0] == '\0')
	    locale = getenv ("LANG");
	}
    }

  /* On some old systems, one used to set locale = "iso8859_1". On others,
     you set it to "language_COUNTRY.charset". In any case, we resolve it
     through the charset.alias file.  */
  codeset = locale;

# endif

#elif defined WIN32

  static char buf[2 + 10 + 1];

  /* Woe32 has a function returning the locale's codepage as a number.  */
  sprintf (buf, "CP%u", GetACP ());
  codeset = buf;

#elif defined OS2

  const char *locale;
  static char buf[2 + 10 + 1];
  ULONG cp[3];
  ULONG cplen;

  /* Allow user to override the codeset, as set in the operating system,
     with standard language environment variables.  */
  locale = getenv ("LC_ALL");
  if (locale == NULL || locale[0] == '\0')
    {
      locale = getenv ("LC_CTYPE");
      if (locale == NULL || locale[0] == '\0')
	locale = getenv ("LANG");
    }
  if (locale != NULL && locale[0] != '\0')
    {
      /* If the locale name contains an encoding after the dot, return it.  */
      const char *dot = strchr (locale, '.');

      if (dot != NULL)
	{
	  const char *modifier;

	  dot++;
	  /* Look for the possible @@... trailer and remove it, if any.  */
	  modifier = strchr (dot, '@@');
	  if (modifier == NULL)
	    return dot;
	  if (modifier - dot < sizeof (buf))
	    {
	      memcpy (buf, dot, modifier - dot);
	      buf [modifier - dot] = '\0';
	      return buf;
	    }
	}

      /* Resolve through the charset.alias file.  */
      codeset = locale;
    }
  else
    {
      /* OS/2 has a function returning the locale's codepage as a number.  */
      if (DosQueryCp (sizeof (cp), cp, &cplen))
	codeset = "";
      else
	{
	  sprintf (buf, "CP%u", cp[0]);
	  codeset = buf;
	}
    }

#endif

  if (codeset == NULL)
    /* The canonical name cannot be determined.  */
    codeset = "";

  /* Resolve alias. */
  for (aliases = get_charset_aliases ();
       *aliases != '\0';
       aliases += strlen (aliases) + 1, aliases += strlen (aliases) + 1)
    if (strcmp (codeset, aliases) == 0
	|| (aliases[0] == '*' && aliases[1] == '\0'))
      {
	codeset = aliases + strlen (aliases) + 1;
	break;
      }

  /* Don't return an empty string.  GNU libc and GNU libiconv interpret
     the empty string as denoting "the locale's character encoding",
     thus GNU libiconv would call this function a second time.  */
  if (codeset[0] == '\0')
    codeset = "ASCII";

  return codeset;
}
@
