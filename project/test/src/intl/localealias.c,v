head	1.5;
access;
symbols
	sid-snapshot-20180601:1.5
	sid-snapshot-20180501:1.5
	sid-snapshot-20180401:1.5
	sid-snapshot-20180301:1.5
	sid-snapshot-20180201:1.5
	sid-snapshot-20180101:1.5
	sid-snapshot-20171201:1.5
	sid-snapshot-20171101:1.5
	sid-snapshot-20171001:1.5
	sid-snapshot-20170901:1.5
	sid-snapshot-20170801:1.5
	sid-snapshot-20170701:1.5
	sid-snapshot-20170601:1.5
	sid-snapshot-20170501:1.5
	sid-snapshot-20170401:1.5
	sid-snapshot-20170301:1.5
	sid-snapshot-20170201:1.5
	sid-snapshot-20170101:1.5
	sid-snapshot-20161201:1.5
	sid-snapshot-20161101:1.5
	sid-snapshot-20160901:1.5
	sid-snapshot-20160801:1.5
	sid-snapshot-20160701:1.5
	sid-snapshot-20160601:1.5
	sid-snapshot-20160501:1.5
	sid-snapshot-20160401:1.5
	sid-snapshot-20160301:1.5
	sid-snapshot-20160201:1.5
	sid-snapshot-20160101:1.5
	sid-snapshot-20151201:1.5
	sid-snapshot-20151101:1.5
	sid-snapshot-20151001:1.5
	sid-snapshot-20150901:1.5
	sid-snapshot-20150801:1.5
	sid-snapshot-20150701:1.5
	sid-snapshot-20150601:1.5
	sid-snapshot-20150501:1.5
	sid-snapshot-20150401:1.5
	sid-snapshot-20150301:1.5
	sid-snapshot-20150201:1.5
	sid-snapshot-20150101:1.5
	sid-snapshot-20141201:1.5
	sid-snapshot-20141101:1.5
	sid-snapshot-20141001:1.5
	sid-snapshot-20140901:1.5
	sid-snapshot-20140801:1.5
	sid-snapshot-20140701:1.5
	sid-snapshot-20140601:1.5
	sid-snapshot-20140501:1.5
	sid-snapshot-20140401:1.5
	sid-snapshot-20140301:1.5
	sid-snapshot-20140201:1.5
	sid-snapshot-20140101:1.5
	sid-snapshot-20131201:1.5
	sid-snapshot-20131101:1.5
	sid-snapshot-20131001:1.5
	binutils-2_24-branch:1.5.0.60
	binutils-2_24-branchpoint:1.5
	binutils-2_21_1:1.5
	sid-snapshot-20130901:1.5
	gdb_7_6_1-2013-08-30-release:1.5
	sid-snapshot-20130801:1.5
	sid-snapshot-20130701:1.5
	sid-snapshot-20130601:1.5
	sid-snapshot-20130501:1.5
	gdb_7_6-2013-04-26-release:1.5
	sid-snapshot-20130401:1.5
	binutils-2_23_2:1.5
	gdb_7_6-branch:1.5.0.58
	gdb_7_6-2013-03-12-branchpoint:1.5
	sid-snapshot-20130301:1.5
	sid-snapshot-20130201:1.5
	sid-snapshot-20130101:1.5
	sid-snapshot-20121201:1.5
	gdb_7_5_1-2012-11-29-release:1.5
	binutils-2_23_1:1.5
	sid-snapshot-20121101:1.5
	binutils-2_23:1.5
	sid-snapshot-20121001:1.5
	sid-snapshot-20120901:1.5
	gdb_7_5-2012-08-17-release:1.5
	sid-snapshot-20120801:1.5
	binutils-2_23-branch:1.5.0.56
	binutils-2_23-branchpoint:1.5
	gdb_7_5-branch:1.5.0.54
	gdb_7_5-2012-07-18-branchpoint:1.5
	sid-snapshot-20120701:1.5
	sid-snapshot-20120601:1.5
	sid-snapshot-20120501:1.5
	binutils-2_22_branch:1.5.0.52
	gdb_7_4_1-2012-04-26-release:1.5
	sid-snapshot-20120401:1.5
	sid-snapshot-20120301:1.5
	sid-snapshot-20120201:1.5
	gdb_7_4-2012-01-24-release:1.5
	sid-snapshot-20120101:1.5
	gdb_7_4-branch:1.5.0.50
	gdb_7_4-2011-12-13-branchpoint:1.5
	sid-snapshot-20111201:1.5
	binutils-2_22:1.5
	sid-snapshot-20111101:1.5
	sid-snapshot-20111001:1.5
	binutils-2_22-branch:1.5.0.48
	binutils-2_22-branchpoint:1.5
	gdb_7_3_1-2011-09-04-release:1.5
	sid-snapshot-20110901:1.5
	sid-snapshot-20110801:1.5
	gdb_7_3-2011-07-26-release:1.5
	sid-snapshot-20110701:1.5
	sid-snapshot-20110601:1.5
	sid-snapshot-20110501:1.5
	gdb_7_3-branch:1.5.0.46
	gdb_7_3-2011-04-01-branchpoint:1.5
	sid-snapshot-20110401:1.5
	sid-snapshot-20110301:1.5
	sid-snapshot-20110201:1.5
	sid-snapshot-20110101:1.5
	binutils-2_21:1.5
	sid-snapshot-20101201:1.5
	binutils-2_21-branch:1.5.0.44
	binutils-2_21-branchpoint:1.5
	sid-snapshot-20101101:1.5
	sid-snapshot-20101001:1.5
	binutils-2_20_1:1.5
	gdb_7_2-2010-09-02-release:1.5
	sid-snapshot-20100901:1.5
	sid-snapshot-20100801:1.5
	gdb_7_2-branch:1.5.0.42
	gdb_7_2-2010-07-07-branchpoint:1.5
	sid-snapshot-20100701:1.5
	sid-snapshot-20100601:1.5
	sid-snapshot-20100501:1.5
	sid-snapshot-20100401:1.5
	gdb_7_1-2010-03-18-release:1.5
	sid-snapshot-20100301:1.5
	gdb_7_1-branch:1.5.0.40
	gdb_7_1-2010-02-18-branchpoint:1.5
	sid-snapshot-20100201:1.5
	sid-snapshot-20100101:1.5
	gdb_7_0_1-2009-12-22-release:1.5
	sid-snapshot-20091201:1.5
	sid-snapshot-20091101:1.5
	binutils-2_20:1.5
	gdb_7_0-2009-10-06-release:1.5
	sid-snapshot-20091001:1.5
	gdb_7_0-branch:1.5.0.38
	gdb_7_0-2009-09-16-branchpoint:1.5
	arc-sim-20090309:1.5
	binutils-arc-20081103-branch:1.5.0.36
	binutils-arc-20081103-branchpoint:1.5
	binutils-2_20-branch:1.5.0.34
	binutils-2_20-branchpoint:1.5
	sid-snapshot-20090901:1.5
	sid-snapshot-20090801:1.5
	msnyder-checkpoint-072509-branch:1.5.0.32
	msnyder-checkpoint-072509-branchpoint:1.5
	sid-snapshot-20090701:1.5
	dje-cgen-play1-branch:1.5.0.30
	dje-cgen-play1-branchpoint:1.5
	sid-snapshot-20090601:1.5
	sid-snapshot-20090501:1.5
	sid-snapshot-20090401:1.5
	arc-20081103-branch:1.5.0.28
	arc-20081103-branchpoint:1.5
	arc-insight_6_8-branch:1.5.0.26
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.24
	insight_6_8-branchpoint:1.5
	sid-snapshot-20090301:1.5
	binutils-2_19_1:1.5
	sid-snapshot-20090201:1.5
	sid-snapshot-20090101:1.5
	reverse-20081226-branch:1.5.0.22
	reverse-20081226-branchpoint:1.5
	sid-snapshot-20081201:1.5
	multiprocess-20081120-branch:1.5.0.20
	multiprocess-20081120-branchpoint:1.5
	sid-snapshot-20081101:1.5
	binutils-2_19:1.5
	sid-snapshot-20081001:1.5
	reverse-20080930-branch:1.5.0.18
	reverse-20080930-branchpoint:1.5
	binutils-2_19-branch:1.5.0.16
	binutils-2_19-branchpoint:1.5
	sid-snapshot-20080901:1.5
	sid-snapshot-20080801:1.5
	reverse-20080717-branch:1.5.0.14
	reverse-20080717-branchpoint:1.5
	sid-snapshot-20080701:1.5
	msnyder-reverse-20080609-branch:1.5.0.12
	msnyder-reverse-20080609-branchpoint:1.5
	drow-reverse-20070409-branch:1.5.0.10
	drow-reverse-20070409-branchpoint:1.5
	sid-snapshot-20080601:1.5
	sid-snapshot-20080501:1.5
	sid-snapshot-20080403:1.5
	sid-snapshot-20080401:1.5
	gdb_6_8-2008-03-27-release:1.5
	sid-snapshot-20080301:1.5
	gdb_6_8-branch:1.5.0.8
	gdb_6_8-2008-02-26-branchpoint:1.5
	sid-snapshot-20080201:1.5
	sid-snapshot-20080101:1.5
	sid-snapshot-20071201:1.5
	sid-snapshot-20071101:1.5
	gdb_6_7_1-2007-10-29-release:1.5
	gdb_6_7-2007-10-10-release:1.5
	sid-snapshot-20071001:1.5
	gdb_6_7-branch:1.5.0.6
	gdb_6_7-2007-09-07-branchpoint:1.5
	binutils-2_18:1.5
	binutils-2_18-branch:1.5.0.4
	binutils-2_18-branchpoint:1.5
	insight_6_6-20070208-release:1.5
	binutils-csl-coldfire-4_1-32:1.4
	binutils-csl-sourcerygxx-4_1-32:1.4
	gdb_6_6-2006-12-18-release:1.5
	binutils-csl-innovasic-fido-3_4_4-33:1.4
	binutils-csl-sourcerygxx-3_4_4-32:1.3
	binutils-csl-coldfire-4_1-30:1.4
	binutils-csl-sourcerygxx-4_1-30:1.4
	binutils-csl-coldfire-4_1-28:1.4
	binutils-csl-sourcerygxx-4_1-29:1.4
	binutils-csl-sourcerygxx-4_1-28:1.4
	gdb_6_6-branch:1.5.0.2
	gdb_6_6-2006-11-15-branchpoint:1.5
	binutils-csl-arm-2006q3-27:1.4
	binutils-csl-sourcerygxx-4_1-27:1.4
	binutils-csl-arm-2006q3-26:1.4
	binutils-csl-sourcerygxx-4_1-26:1.4
	binutils-csl-sourcerygxx-4_1-25:1.4
	binutils-csl-sourcerygxx-4_1-24:1.4
	binutils-csl-sourcerygxx-4_1-23:1.4
	binutils-csl-sourcerygxx-4_1-21:1.4
	binutils-csl-arm-2006q3-21:1.4
	binutils-csl-sourcerygxx-4_1-22:1.4
	binutils-csl-palmsource-arm-prelinker-1_0-1:1.4
	binutils-csl-sourcerygxx-4_1-20:1.4
	binutils-csl-arm-2006q3-19:1.4
	binutils-csl-sourcerygxx-4_1-19:1.4
	binutils-csl-sourcerygxx-4_1-18:1.4
	binutils-csl-renesas-4_1-9:1.4
	binutils-csl-sourcerygxx-3_4_4-25:1.3
	nickrob-async-20060828-mergepoint:1.5
	binutils-csl-renesas-4_1-8:1.4
	binutils-csl-renesas-4_1-7:1.4
	binutils-csl-renesas-4_1-6:1.4
	binutils-csl-sourcerygxx-4_1-17:1.4
	binutils-csl-sourcerygxx-4_1-14:1.4
	binutils-csl-sourcerygxx-4_1-15:1.4
	binutils-csl-sourcerygxx-4_1-13:1.4
	binutils-2_17:1.4
	binutils-csl-sourcerygxx-4_1-12:1.4
	binutils-csl-sourcerygxx-3_4_4-21:1.4
	binutils-csl-wrs-linux-3_4_4-24:1.3
	binutils-csl-wrs-linux-3_4_4-23:1.3
	binutils-csl-sourcerygxx-4_1-9:1.4
	binutils-csl-sourcerygxx-4_1-8:1.4
	binutils-csl-sourcerygxx-4_1-7:1.4
	binutils-csl-arm-2006q1-6:1.4
	binutils-csl-sourcerygxx-4_1-6:1.4
	binutils-csl-wrs-linux-3_4_4-22:1.3
	binutils-csl-coldfire-4_1-11:1.4
	binutils-csl-sourcerygxx-3_4_4-19:1.4
	binutils-csl-coldfire-4_1-10:1.4
	binutils-csl-sourcerygxx-4_1-5:1.4
	binutils-csl-sourcerygxx-4_1-4:1.4
	binutils-csl-wrs-linux-3_4_4-21:1.3
	binutils-csl-morpho-4_1-4:1.4
	binutils-csl-sourcerygxx-3_4_4-17:1.4
	binutils-csl-wrs-linux-3_4_4-20:1.3
	binutils-2_17-branch:1.4.0.8
	binutils-2_17-branchpoint:1.4
	binutils-csl-2_17-branch:1.4.0.6
	binutils-csl-2_17-branchpoint:1.4
	msnyder-fork-checkpoint-branch:1.4.0.4
	msnyder-fork-checkpoint-branchpoint:1.4
	gdb-csl-arm-20051020-branch:1.4.0.2
	gdb-csl-arm-20051020-branchpoint:1.4
	binutils-csl-gxxpro-3_4-branch:1.3.0.90
	binutils-csl-gxxpro-3_4-branchpoint:1.3
	binutils-2_16_1:1.3
	binutils-csl-arm-2005q1b:1.3
	binutils-2_16:1.3
	binutils-csl-arm-2005q1a:1.3
	binutils-csl-arm-2005q1-branch:1.3.0.88
	binutils-csl-arm-2005q1-branchpoint:1.3
	binutils-2_16-branch:1.3.0.84
	binutils-2_16-branchpoint:1.3
	csl-arm-2004-q3d:1.3
	csl-arm-2004-q3:1.3
	drow_intercu-merge-20040921:1.3
	drow_intercu-merge-20040915:1.3
	jimb-gdb_6_2-e500-branch:1.3.0.86
	jimb-gdb_6_2-e500-branchpoint:1.3
	gdb_6_2-20040730-release:1.3
	gdb_6_2-branch:1.3.0.82
	gdb_6_2-2004-07-10-gmt-branchpoint:1.3
	gdb_6_1_1-20040616-release:1.3
	binutils-2_15:1.3
	binutils-2_15-branchpoint:1.3
	csl-arm-2004-q1a:1.3
	csl-arm-2004-q1:1.3
	gdb_6_1-2004-04-05-release:1.3
	drow_intercu-merge-20040402:1.3
	drow_intercu-merge-20040327:1.3
	ezannoni_pie-20040323-branch:1.3.0.80
	ezannoni_pie-20040323-branchpoint:1.3
	cagney_tramp-20040321-mergepoint:1.3
	cagney_tramp-20040309-branch:1.3.0.78
	cagney_tramp-20040309-branchpoint:1.3
	gdb_6_1-branch:1.3.0.76
	gdb_6_1-2004-03-01-gmt-branchpoint:1.3
	drow_intercu-20040221-branch:1.3.0.74
	drow_intercu-20040221-branchpoint:1.3
	binutils-2_15-branch:1.3.0.72
	cagney_bfdfile-20040213-branch:1.3.0.70
	cagney_bfdfile-20040213-branchpoint:1.3
	drow-cplus-merge-20040208:1.3
	carlton_dictionary-20040126-merge:1.3
	cagney_bigcore-20040122-branch:1.3.0.68
	cagney_bigcore-20040122-branchpoint:1.3
	drow-cplus-merge-20040113:1.3
	csl-arm-2003-q4:1.3
	drow-cplus-merge-20031224:1.3
	drow-cplus-merge-20031220:1.3
	carlton_dictionary-20031215-merge:1.3
	drow-cplus-merge-20031214:1.3
	carlton-dictionary-20031111-merge:1.3
	gdb_6_0-2003-10-04-release:1.3
	kettenis_sparc-20030918-branch:1.3.0.66
	kettenis_sparc-20030918-branchpoint:1.3
	carlton_dictionary-20030917-merge:1.3
	ezannoni_pie-20030916-branchpoint:1.3
	ezannoni_pie-20030916-branch:1.3.0.64
	cagney_x86i386-20030821-branch:1.3.0.62
	cagney_x86i386-20030821-branchpoint:1.3
	carlton_dictionary-20030805-merge:1.3
	carlton_dictionary-20030627-merge:1.3
	gdb_6_0-branch:1.3.0.60
	gdb_6_0-2003-06-23-branchpoint:1.3
	jimb-ppc64-linux-20030613-branch:1.3.0.58
	jimb-ppc64-linux-20030613-branchpoint:1.3
	binutils-2_14:1.3
	cagney_convert-20030606-branch:1.3.0.56
	cagney_convert-20030606-branchpoint:1.3
	cagney_writestrings-20030508-branch:1.3.0.54
	cagney_writestrings-20030508-branchpoint:1.3
	jimb-ppc64-linux-20030528-branch:1.3.0.52
	jimb-ppc64-linux-20030528-branchpoint:1.3
	carlton_dictionary-20030523-merge:1.3
	cagney_fileio-20030521-branch:1.3.0.50
	cagney_fileio-20030521-branchpoint:1.3
	kettenis_i386newframe-20030517-mergepoint:1.3
	jimb-ppc64-linux-20030509-branch:1.3.0.48
	jimb-ppc64-linux-20030509-branchpoint:1.3
	kettenis_i386newframe-20030504-mergepoint:1.3
	carlton_dictionary-20030430-merge:1.3
	binutils-2_14-branch:1.3.0.46
	binutils-2_14-branchpoint:1.3
	kettenis_i386newframe-20030419-branch:1.3.0.44
	kettenis_i386newframe-20030419-branchpoint:1.3
	carlton_dictionary-20030416-merge:1.3
	cagney_frameaddr-20030409-mergepoint:1.3
	kettenis_i386newframe-20030406-branch:1.3.0.42
	kettenis_i386newframe-20030406-branchpoint:1.3
	cagney_frameaddr-20030403-branchpoint:1.3
	cagney_frameaddr-20030403-branch:1.3.0.40
	cagney_framebase-20030330-mergepoint:1.3
	cagney_framebase-20030326-branch:1.3.0.38
	cagney_framebase-20030326-branchpoint:1.3
	cagney_lazyid-20030317-branch:1.3.0.36
	cagney_lazyid-20030317-branchpoint:1.3
	kettenis-i386newframe-20030316-mergepoint:1.3
	offbyone-20030313-branch:1.3.0.34
	offbyone-20030313-branchpoint:1.3
	kettenis-i386newframe-20030308-branch:1.3.0.32
	kettenis-i386newframe-20030308-branchpoint:1.3
	carlton_dictionary-20030305-merge:1.3
	cagney_offbyone-20030303-branch:1.3.0.30
	cagney_offbyone-20030303-branchpoint:1.3
	carlton_dictionary-20030207-merge:1.3
	interps-20030202-branch:1.3.0.28
	interps-20030202-branchpoint:1.3
	cagney-unwind-20030108-branch:1.3.0.26
	cagney-unwind-20030108-branchpoint:1.3
	binutils-2_13_2_1:1.3
	binutils-2_13_2:1.3
	carlton_dictionary-20021223-merge:1.3
	gdb_5_3-2002-12-12-release:1.3
	carlton_dictionary-20021115-merge:1.3
	binutils-2_13_1:1.3
	kseitz_interps-20021105-merge:1.3
	kseitz_interps-20021103-merge:1.3
	drow-cplus-merge-20021020:1.3
	drow-cplus-merge-20021025:1.3
	carlton_dictionary-20021025-merge:1.3
	carlton_dictionary-20021011-merge:1.3
	drow-cplus-branch:1.3.0.24
	drow-cplus-branchpoint:1.3
	kseitz_interps-20020930-merge:1.3
	carlton_dictionary-20020927-merge:1.3
	carlton_dictionary-branch:1.3.0.22
	carlton_dictionary-20020920-branchpoint:1.3
	sid-20020905-branchpoint:1.3
	sid-20020905-branch:1.3.0.20
	gdb_5_3-branch:1.3.0.18
	gdb_5_3-2002-09-04-branchpoint:1.3
	kseitz_interps-20020829-merge:1.3
	cagney_sysregs-20020825-branch:1.3.0.16
	cagney_sysregs-20020825-branchpoint:1.3
	readline_4_3-import-branch:1.3.0.14
	readline_4_3-import-branchpoint:1.3
	binutils-2_13:1.3
	gdb_5_2_1-2002-07-23-release:1.3
	binutils-2_13-branchpoint:1.3
	binutils-2_13-branch:1.3.0.12
	kseitz_interps-20020528-branch:1.3.0.10
	kseitz_interps-20020528-branchpoint:1.3
	cagney_regbuf-20020515-branch:1.3.0.8
	cagney_regbuf-20020515-branchpoint:1.3
	binutils-2_12_1:1.3
	jimb-macro-020506-branch:1.3.0.6
	jimb-macro-020506-branchpoint:1.3
	gdb_5_2-2002-04-29-release:1.3
	binutils-2_12:1.3
	gdb_5_2-branch:1.3.0.4
	gdb_5_2-2002-03-03-branchpoint:1.3
	binutils-2_12-branch:1.3.0.2
	binutils-2_12-branchpoint:1.3
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	gdb_5_1_0_1-2002-01-03-release:1.1.1.1
	cygnus_cvs_20020108_pre:1.3
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.14
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gettext_0_10_35:1.1.1.2
	pre-gettext-0-10-35:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.12
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.10
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	binutils-2_11_2:1.1.1.1
	binutils-2_11_1:1.1.1.1
	binutils-2_11:1.1.1.1
	x86_64versiong3:1.1.1.1
	binutils-2_11-branch:1.1.1.1.0.8
	insight-precleanup-2001-01-01:1.1.1.1
	binutils-2_10_1:1.1.1.1
	binutils-2_10:1.1.1.1
	gdb-premipsmulti-2000-06-06-branch:1.1.1.1.0.6
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.4
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	binutils-2_10-branch:1.1.1.1.0.2
	binutils-2_10-branchpoint:1.1.1.1
	binutils_latest_snapshot:1.5
	repo-unification-2000-02-06:1.1.1.1
	binu_ss_19990721:1.1.1.1
	binu_ss_19990602:1.1.1.1
	binu_ss_19990502:1.1.1.1
	cygnus:1.1.1;
locks; strict;
comment	@ * @;


1.5
date	2006.05.22.15.30.13;	author sje;	state Exp;
branches;
next	1.4;

1.4
date	2005.05.13.08.04.31;	author nickc;	state Exp;
branches;
next	1.3;

1.3
date	2001.11.29.03.38.59;	author bje;	state Exp;
branches;
next	1.2;

1.2
date	2001.11.29.03.20.34;	author bje;	state Exp;
branches;
next	1.1;

1.1
date	99.05.03.07.29.05;	author rth;	state Exp;
branches
	1.1.1.1;
next	;

1.1.1.1
date	99.05.03.07.29.05;	author rth;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	2001.11.29.03.23.39;	author bje;	state Exp;
branches;
next	;


desc
@@


1.5
log
@2006-05-22  Steve Ellcey  <sje@@cup.hp.com>

	* MAINTAINERS: Change intl updating instructions.
	* config.rpath: Copy from GCC tree.
	* intl: Replace contents of intl directory with intl from GCC tree.
@
text
@/* Handle aliases for locale names.
   Copyright (C) 1995-1999, 2000-2001, 2003 Free Software Foundation, Inc.

   This program is free software; you can redistribute it and/or modify it
   under the terms of the GNU Library General Public License as published
   by the Free Software Foundation; either version 2, or (at your option)
   any later version.

   This program is distributed in the hope that it will be useful,
   but WITHOUT ANY WARRANTY; without even the implied warranty of
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
   Library General Public License for more details.

   You should have received a copy of the GNU Library General Public
   License along with this program; if not, write to the Free Software
   Foundation, Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301,
   USA.  */

/* Tell glibc's <string.h> to provide a prototype for mempcpy().
   This must come before <config.h> because <config.h> may include
   <features.h>, and once <features.h> has been included, it's too late.  */
#ifndef _GNU_SOURCE
# define _GNU_SOURCE    1
#endif

#ifdef HAVE_CONFIG_H
# include <config.h>
#endif

#include <ctype.h>
#include <stdio.h>
#if defined _LIBC || defined HAVE___FSETLOCKING
# include <stdio_ext.h>
#endif
#include <sys/types.h>

#ifdef __GNUC__
# undef alloca
# define alloca __builtin_alloca
# define HAVE_ALLOCA 1
#else
# ifdef _MSC_VER
#  include <malloc.h>
#  define alloca _alloca
# else
#  if defined HAVE_ALLOCA_H || defined _LIBC
#   include <alloca.h>
#  else
#   ifdef _AIX
 #pragma alloca
#   else
#    ifndef alloca
char *alloca ();
#    endif
#   endif
#  endif
# endif
#endif

#include <stdlib.h>
#include <string.h>

#include "gettextP.h"

#if ENABLE_RELOCATABLE
# include "relocatable.h"
#else
# define relocate(pathname) (pathname)
#endif

/* @@@@ end of prolog @@@@ */

#ifdef _LIBC
/* Rename the non ANSI C functions.  This is required by the standard
   because some ANSI C functions will require linking with this object
   file and the name space must not be polluted.  */
# define strcasecmp __strcasecmp

# ifndef mempcpy
#  define mempcpy __mempcpy
# endif
# define HAVE_MEMPCPY	1
# define HAVE___FSETLOCKING	1

/* We need locking here since we can be called from different places.  */
# include <bits/libc-lock.h>

__libc_lock_define_initialized (static, lock);
#endif

#ifndef internal_function
# define internal_function
#endif

/* Some optimizations for glibc.  */
#ifdef _LIBC
# define FEOF(fp)		feof_unlocked (fp)
# define FGETS(buf, n, fp)	fgets_unlocked (buf, n, fp)
#else
# define FEOF(fp)		feof (fp)
# define FGETS(buf, n, fp)	fgets (buf, n, fp)
#endif

/* For those losing systems which don't have `alloca' we have to add
   some additional code emulating it.  */
#ifdef HAVE_ALLOCA
# define freea(p) /* nothing */
#else
# define alloca(n) malloc (n)
# define freea(p) free (p)
#endif

#if defined _LIBC_REENTRANT || defined HAVE_FGETS_UNLOCKED
# undef fgets
# define fgets(buf, len, s) fgets_unlocked (buf, len, s)
#endif
#if defined _LIBC_REENTRANT || defined HAVE_FEOF_UNLOCKED
# undef feof
# define feof(s) feof_unlocked (s)
#endif


struct alias_map
{
  const char *alias;
  const char *value;
};


#ifndef _LIBC
# define libc_freeres_ptr(decl) decl
#endif

libc_freeres_ptr (static char *string_space);
static size_t string_space_act;
static size_t string_space_max;
libc_freeres_ptr (static struct alias_map *map);
static size_t nmap;
static size_t maxmap;


/* Prototypes for local functions.  */
static size_t read_alias_file PARAMS ((const char *fname, int fname_len))
     internal_function;
static int extend_alias_table PARAMS ((void));
static int alias_compare PARAMS ((const struct alias_map *map1,
				  const struct alias_map *map2));


const char *
_nl_expand_alias (name)
    const char *name;
{
  static const char *locale_alias_path;
  struct alias_map *retval;
  const char *result = NULL;
  size_t added;

#ifdef _LIBC
  __libc_lock_lock (lock);
#endif

  if (locale_alias_path == NULL)
    locale_alias_path = LOCALE_ALIAS_PATH;

  do
    {
      struct alias_map item;

      item.alias = name;

      if (nmap > 0)
	retval = (struct alias_map *) bsearch (&item, map, nmap,
					       sizeof (struct alias_map),
					       (int (*) PARAMS ((const void *,
								 const void *))
						) alias_compare);
      else
	retval = NULL;

      /* We really found an alias.  Return the value.  */
      if (retval != NULL)
	{
	  result = retval->value;
	  break;
	}

      /* Perhaps we can find another alias file.  */
      added = 0;
      while (added == 0 && locale_alias_path[0] != '\0')
	{
	  const char *start;

	  while (locale_alias_path[0] == PATH_SEPARATOR)
	    ++locale_alias_path;
	  start = locale_alias_path;

	  while (locale_alias_path[0] != '\0'
		 && locale_alias_path[0] != PATH_SEPARATOR)
	    ++locale_alias_path;

	  if (start < locale_alias_path)
	    added = read_alias_file (start, locale_alias_path - start);
	}
    }
  while (added != 0);

#ifdef _LIBC
  __libc_lock_unlock (lock);
#endif

  return result;
}


static size_t
internal_function
read_alias_file (fname, fname_len)
     const char *fname;
     int fname_len;
{
  FILE *fp;
  char *full_fname;
  size_t added;
  static const char aliasfile[] = "/locale.alias";

  full_fname = (char *) alloca (fname_len + sizeof aliasfile);
#ifdef HAVE_MEMPCPY
  mempcpy (mempcpy (full_fname, fname, fname_len),
	   aliasfile, sizeof aliasfile);
#else
  memcpy (full_fname, fname, fname_len);
  memcpy (&full_fname[fname_len], aliasfile, sizeof aliasfile);
#endif

  fp = fopen (relocate (full_fname), "r");
  freea (full_fname);
  if (fp == NULL)
    return 0;

#ifdef HAVE___FSETLOCKING
  /* No threads present.  */
  __fsetlocking (fp, FSETLOCKING_BYCALLER);
#endif

  added = 0;
  while (!FEOF (fp))
    {
      /* It is a reasonable approach to use a fix buffer here because
	 a) we are only interested in the first two fields
	 b) these fields must be usable as file names and so must not
	    be that long
	 We avoid a multi-kilobyte buffer here since this would use up
	 stack space which we might not have if the program ran out of
	 memory.  */
      char buf[400];
      char *alias;
      char *value;
      char *cp;

      if (FGETS (buf, sizeof buf, fp) == NULL)
	/* EOF reached.  */
	break;

      cp = buf;
      /* Ignore leading white space.  */
      while (isspace ((unsigned char) cp[0]))
	++cp;

      /* A leading '#' signals a comment line.  */
      if (cp[0] != '\0' && cp[0] != '#')
	{
	  alias = cp++;
	  while (cp[0] != '\0' && !isspace ((unsigned char) cp[0]))
	    ++cp;
	  /* Terminate alias name.  */
	  if (cp[0] != '\0')
	    *cp++ = '\0';

	  /* Now look for the beginning of the value.  */
	  while (isspace ((unsigned char) cp[0]))
	    ++cp;

	  if (cp[0] != '\0')
	    {
	      size_t alias_len;
	      size_t value_len;

	      value = cp++;
	      while (cp[0] != '\0' && !isspace ((unsigned char) cp[0]))
		++cp;
	      /* Terminate value.  */
	      if (cp[0] == '\n')
		{
		  /* This has to be done to make the following test
		     for the end of line possible.  We are looking for
		     the terminating '\n' which do not overwrite here.  */
		  *cp++ = '\0';
		  *cp = '\n';
		}
	      else if (cp[0] != '\0')
		*cp++ = '\0';

	      if (nmap >= maxmap)
		if (__builtin_expect (extend_alias_table (), 0))
		  return added;

	      alias_len = strlen (alias) + 1;
	      value_len = strlen (value) + 1;

	      if (string_space_act + alias_len + value_len > string_space_max)
		{
		  /* Increase size of memory pool.  */
		  size_t new_size = (string_space_max
				     + (alias_len + value_len > 1024
					? alias_len + value_len : 1024));
		  char *new_pool = (char *) realloc (string_space, new_size);
		  if (new_pool == NULL)
		    return added;

		  if (__builtin_expect (string_space != new_pool, 0))
		    {
		      size_t i;

		      for (i = 0; i < nmap; i++)
			{
			  map[i].alias += new_pool - string_space;
			  map[i].value += new_pool - string_space;
			}
		    }

		  string_space = new_pool;
		  string_space_max = new_size;
		}

	      map[nmap].alias = memcpy (&string_space[string_space_act],
					alias, alias_len);
	      string_space_act += alias_len;

	      map[nmap].value = memcpy (&string_space[string_space_act],
					value, value_len);
	      string_space_act += value_len;

	      ++nmap;
	      ++added;
	    }
	}

      /* Possibly not the whole line fits into the buffer.  Ignore
	 the rest of the line.  */
      while (strchr (buf, '\n') == NULL)
	if (FGETS (buf, sizeof buf, fp) == NULL)
	  /* Make sure the inner loop will be left.  The outer loop
	     will exit at the `feof' test.  */
	  break;
    }

  /* Should we test for ferror()?  I think we have to silently ignore
     errors.  --drepper  */
  fclose (fp);

  if (added > 0)
    qsort (map, nmap, sizeof (struct alias_map),
	   (int (*) PARAMS ((const void *, const void *))) alias_compare);

  return added;
}


static int
extend_alias_table ()
{
  size_t new_size;
  struct alias_map *new_map;

  new_size = maxmap == 0 ? 100 : 2 * maxmap;
  new_map = (struct alias_map *) realloc (map, (new_size
						* sizeof (struct alias_map)));
  if (new_map == NULL)
    /* Simply don't extend: we don't have any more core.  */
    return -1;

  map = new_map;
  maxmap = new_size;
  return 0;
}


static int
alias_compare (map1, map2)
     const struct alias_map *map1;
     const struct alias_map *map2;
{
#if defined _LIBC || defined HAVE_STRCASECMP
  return strcasecmp (map1->alias, map2->alias);
#else
  const unsigned char *p1 = (const unsigned char *) map1->alias;
  const unsigned char *p2 = (const unsigned char *) map2->alias;
  unsigned char c1, c2;

  if (p1 == p2)
    return 0;

  do
    {
      /* I know this seems to be odd but the tolower() function in
	 some systems libc cannot handle nonalpha characters.  */
      c1 = isupper (*p1) ? tolower (*p1) : *p1;
      c2 = isupper (*p2) ? tolower (*p2) : *p2;
      if (c1 == '\0')
	break;
      ++p1;
      ++p2;
    }
  while (c1 == c2);

  return c1 - c2;
#endif
}
@


1.4
log
@Update the address and telephone number of the FSF organization
@
text
@d2 1
a2 2
   Copyright (C) 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
   Written by Ulrich Drepper <drepper@@gnu.ai.mit.edu>, 1995.
d4 3
a6 3
   This program is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 2, or (at your option)
d11 2
a12 2
   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
   GNU General Public License for more details.
d14 11
a24 3
   You should have received a copy of the GNU General Public License
   along with this program; if not, write to the Free Software Foundation,
   Inc., 51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.  */
d32 3
d38 1
d42 3
a44 2
# if defined HAVE_ALLOCA_H || defined _LIBC
#  include <alloca.h>
d46 4
a49 1
#  ifdef _AIX
d51 2
a52 2
#  else
#   ifndef alloca
d54 1
d60 4
a63 10
#if defined STDC_HEADERS || defined _LIBC
# include <stdlib.h>
#else
char *getenv ();
# ifdef HAVE_MALLOC_H
#  include <malloc.h>
# else
void free ();
# endif
#endif
d65 2
a66 5
#if defined HAVE_STRING_H || defined _LIBC
# ifndef _GNU_SOURCE
#  define _GNU_SOURCE	1
# endif
# include <string.h>
d68 1
a68 4
# include <strings.h>
# ifndef memcpy
#  define memcpy(Dst, Src, Num) bcopy (Src, Dst, Num)
# endif
a69 8
#if !HAVE_STRCHR && !defined _LIBC
# ifndef strchr
#  define strchr index
# endif
#endif

#include "gettext.h"
#include "gettextP.h"
d79 3
a81 1
# define mempcpy __mempcpy
d83 1
d91 3
d95 10
a104 1
/* For those loosing systems which don't have `alloca' we have to add
d107 1
a107 3
/* Nothing has to be done.  */
# define ADD_BLOCK(list, address) /* nothing */
# define FREE_BLOCKS(list) /* nothing */
d109 12
a120 27
struct block_list
{
  void *address;
  struct block_list *next;
};
# define ADD_BLOCK(list, addr)						      \
  do {									      \
    struct block_list *newp = (struct block_list *) malloc (sizeof (*newp));  \
    /* If we cannot get a free block we cannot add the new element to	      \
       the list.  */							      \
    if (newp != NULL) {							      \
      newp->address = (addr);						      \
      newp->next = (list);						      \
      (list) = newp;							      \
    }									      \
  } while (0)
# define FREE_BLOCKS(list)						      \
  do {									      \
    while (list != NULL) {						      \
      struct block_list *old = list;					      \
      list = list->next;						      \
      free (old);							      \
    }									      \
  } while (0)
# undef alloca
# define alloca(size) (malloc (size))
#endif	/* have alloca */
d130 10
a139 6
static char *string_space = NULL;
static size_t string_space_act = 0;
static size_t string_space_max = 0;
static struct alias_map *map;
static size_t nmap = 0;
static size_t maxmap = 0;
d145 1
a145 1
static void extend_alias_table PARAMS ((void));
d154 1
a154 1
  static const char *locale_alias_path = LOCALE_ALIAS_PATH;
d163 3
d194 1
a194 1
	  while (locale_alias_path[0] == ':')
d198 2
a199 1
	  while (locale_alias_path[0] != '\0' && locale_alias_path[0] != ':')
a221 3
#ifndef HAVE_ALLOCA
  struct block_list *block_list = NULL;
#endif
a227 1
  ADD_BLOCK (block_list, full_fname);
d236 2
a237 1
  fp = fopen (full_fname, "r");
d239 6
a244 4
    {
      FREE_BLOCKS (block_list);
      return 0;
    }
d247 1
a247 1
  while (!feof (fp))
d253 7
a259 5
       */
      unsigned char buf[BUFSIZ];
      unsigned char *alias;
      unsigned char *value;
      unsigned char *cp;
d261 1
a261 1
      if (fgets (buf, sizeof buf, fp) == NULL)
a264 13
      /* Possibly not the whole line fits into the buffer.  Ignore
	 the rest of the line.  */
      if (strchr (buf, '\n') == NULL)
	{
	  char altbuf[BUFSIZ];
	  do
	    if (fgets (altbuf, sizeof altbuf, fp) == NULL)
	      /* Make sure the inner loop will be left.  The outer loop
		 will exit at the `feof' test.  */
	      break;
	  while (strchr (altbuf, '\n') == NULL);
	}

d267 1
a267 1
      while (isspace (cp[0]))
d274 1
a274 1
	  while (cp[0] != '\0' && !isspace (cp[0]))
d281 1
a281 1
	  while (isspace (cp[0]))
d290 1
a290 1
	      while (cp[0] != '\0' && !isspace (cp[0]))
d305 2
a306 1
		extend_alias_table ();
d319 3
d323 7
a329 2
		      FREE_BLOCKS (block_list);
		      return added;
d331 1
d348 8
a365 1
  FREE_BLOCKS (block_list);
d370 1
a370 1
static void
d381 1
a381 1
    return;
d385 1
a388 13
#ifdef _LIBC
static void __attribute__ ((unused))
free_mem (void)
{
  if (string_space != NULL)
    free (string_space);
  if (map != NULL)
    free (map);
}
text_set_element (__libc_subfreeres, free_mem);
#endif


@


1.3
log
@* Import GNU gettext 0.10.35.
@
text
@d17 1
a17 1
   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */
@


1.2
log
@touch all source to ease import
@
text
@d1 2
a2 2
/* Handle aliases for locale names
   Copyright (C) 1995, 1996, 1997 Free Software Foundation, Inc.
d82 8
d136 3
d145 2
a146 1
static size_t read_alias_file PARAMS ((const char *fname, int fname_len));
d158 1
d161 4
d182 4
a185 1
	return retval->value;
d206 5
a210 1
  return NULL;
d215 1
d230 4
d236 1
d253 4
a256 4
      char buf[BUFSIZ];
      char *alias;
      char *value;
      char *cp;
d258 1
a258 1
      if (fgets (buf, BUFSIZ, fp) == NULL)
d262 13
d296 2
a297 2
	      char *tp;
	      size_t len;
d317 4
a320 4
	      /* We cannot depend on strdup available in the libc.  Sigh!  */
	      len = strlen (alias) + 1;
	      tp = (char *) malloc (len);
	      if (tp == NULL)
d322 12
a333 2
		  FREE_BLOCKS (block_list);
		  return added;
a334 2
	      memcpy (tp, alias, len);
	      map[nmap].alias = tp;
d336 7
a342 9
	      len = strlen (value) + 1;
	      tp = (char *) malloc (len);
	      if (tp == NULL)
		{
		  FREE_BLOCKS (block_list);
		  return added;
		}
	      memcpy (tp, value, len);
	      map[nmap].value = tp;
a347 11

      /* Possibly not the whole line fits into the buffer.  Ignore
	 the rest of the line.  */
      while (strchr (cp, '\n') == NULL)
	{
	  cp = buf;
	  if (fgets (buf, BUFSIZ, fp) == NULL)
	    /* Make sure the inner loop will be left.  The outer loop
	       will exit at the `feof' test.  */
	    *cp = '\n';
	}
d370 2
a371 2
  new_map = (struct alias_map *) malloc (new_size
					 * sizeof (struct alias_map));
d376 4
a379 1
  memcpy (new_map, map, nmap * sizeof (struct alias_map));
d381 7
a387 1
  if (maxmap != 0)
a388 3

  map = new_map;
  maxmap = new_size;
d390 2
@


1.1
log
@Initial revision
@
text
@@


1.1.1.1
log
@19990502 sourceware import
@
text
@@


1.1.1.2
log
@Import GNU gettext 0.10.35
@
text
@d1 2
a2 2
/* Handle aliases for locale names.
   Copyright (C) 1995, 1996, 1997, 1998 Free Software Foundation, Inc.
a81 8

# define mempcpy __mempcpy
# define HAVE_MEMPCPY	1

/* We need locking here since we can be called from different places.  */
# include <bits/libc-lock.h>

__libc_lock_define_initialized (static, lock);
a127 3
static char *string_space = NULL;
static size_t string_space_act = 0;
static size_t string_space_max = 0;
d134 1
a134 2
static size_t read_alias_file PARAMS ((const char *fname, int fname_len))
     internal_function;
a145 1
  const char *result = NULL;
a147 4
#ifdef _LIBC
  __libc_lock_lock (lock);
#endif

d165 1
a165 4
	{
	  result = retval->value;
	  break;
	}
d186 1
a186 5
#ifdef _LIBC
  __libc_lock_unlock (lock);
#endif

  return result;
a190 1
internal_function
a204 4
#ifdef HAVE_MEMPCPY
  mempcpy (mempcpy (full_fname, fname, fname_len),
	   aliasfile, sizeof aliasfile);
#else
a206 1
#endif
d223 4
a226 4
      unsigned char buf[BUFSIZ];
      unsigned char *alias;
      unsigned char *value;
      unsigned char *cp;
d228 1
a228 1
      if (fgets (buf, sizeof buf, fp) == NULL)
a231 13
      /* Possibly not the whole line fits into the buffer.  Ignore
	 the rest of the line.  */
      if (strchr (buf, '\n') == NULL)
	{
	  char altbuf[BUFSIZ];
	  do
	    if (fgets (altbuf, sizeof altbuf, fp) == NULL)
	      /* Make sure the inner loop will be left.  The outer loop
		 will exit at the `feof' test.  */
	      break;
	  while (strchr (altbuf, '\n') == NULL);
	}

d253 2
a254 2
	      size_t alias_len;
	      size_t value_len;
d274 10
a283 2
	      alias_len = strlen (alias) + 1;
	      value_len = strlen (value) + 1;
d285 3
a287 1
	      if (string_space_act + alias_len + value_len > string_space_max)
d289 2
a290 12
		  /* Increase size of memory pool.  */
		  size_t new_size = (string_space_max
				     + (alias_len + value_len > 1024
					? alias_len + value_len : 1024));
		  char *new_pool = (char *) realloc (string_space, new_size);
		  if (new_pool == NULL)
		    {
		      FREE_BLOCKS (block_list);
		      return added;
		    }
		  string_space = new_pool;
		  string_space_max = new_size;
d292 2
a293 8

	      map[nmap].alias = memcpy (&string_space[string_space_act],
					alias, alias_len);
	      string_space_act += alias_len;

	      map[nmap].value = memcpy (&string_space[string_space_act],
					value, value_len);
	      string_space_act += value_len;
d299 11
d332 2
a333 2
  new_map = (struct alias_map *) realloc (map, (new_size
						* sizeof (struct alias_map)));
d338 5
a345 13


#ifdef _LIBC
static void __attribute__ ((unused))
free_mem (void)
{
  if (string_space != NULL)
    free (string_space);
  if (map != NULL)
    free (map);
}
text_set_element (__libc_subfreeres, free_mem);
#endif
@


