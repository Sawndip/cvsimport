head	1.18;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.17
	gdb_7_6-2013-04-26-release:1.17
	gdb_7_6-branch:1.17.0.2
	gdb_7_6-2013-03-12-branchpoint:1.17
	gdb_7_5_1-2012-11-29-release:1.16
	gdb_7_5-2012-08-17-release:1.16
	gdb_7_5-branch:1.16.0.2
	gdb_7_5-2012-07-18-branchpoint:1.16
	gdb_7_4_1-2012-04-26-release:1.13.2.1
	gdb_7_4-2012-01-24-release:1.13.2.1
	gdb_7_4-branch:1.13.0.2
	gdb_7_4-2011-12-13-branchpoint:1.13
	gdb_7_3_1-2011-09-04-release:1.12
	gdb_7_3-2011-07-26-release:1.12
	gdb_7_3-branch:1.12.0.2
	gdb_7_3-2011-04-01-branchpoint:1.12
	gdb_7_2-2010-09-02-release:1.10
	gdb_7_2-branch:1.10.0.2
	gdb_7_2-2010-07-07-branchpoint:1.10
	gdb_7_1-2010-03-18-release:1.9
	gdb_7_1-branch:1.9.0.2
	gdb_7_1-2010-02-18-branchpoint:1.9
	gdb_7_0_1-2009-12-22-release:1.8
	gdb_7_0-2009-10-06-release:1.8
	gdb_7_0-branch:1.8.0.4
	gdb_7_0-2009-09-16-branchpoint:1.8
	arc-sim-20090309:1.4
	msnyder-checkpoint-072509-branch:1.8.0.2
	msnyder-checkpoint-072509-branchpoint:1.8
	arc-insight_6_8-branch:1.4.0.6
	arc-insight_6_8-branchpoint:1.4
	insight_6_8-branch:1.4.0.4
	insight_6_8-branchpoint:1.4
	reverse-20081226-branch:1.6.0.10
	reverse-20081226-branchpoint:1.6
	multiprocess-20081120-branch:1.6.0.8
	multiprocess-20081120-branchpoint:1.6
	reverse-20080930-branch:1.6.0.6
	reverse-20080930-branchpoint:1.6
	reverse-20080717-branch:1.6.0.4
	reverse-20080717-branchpoint:1.6
	msnyder-reverse-20080609-branch:1.6.0.2
	msnyder-reverse-20080609-branchpoint:1.6
	drow-reverse-20070409-branch:1.2.0.2
	drow-reverse-20070409-branchpoint:1.2
	gdb_6_8-2008-03-27-release:1.4
	gdb_6_8-branch:1.4.0.2
	gdb_6_8-2008-02-26-branchpoint:1.4
	gdb_6_7_1-2007-10-29-release:1.3
	gdb_6_7-2007-10-10-release:1.3
	gdb_6_7-branch:1.3.0.2
	gdb_6_7-2007-09-07-branchpoint:1.3
	insight_6_6-20070208-release:1.1
	gdb_6_6-2006-12-18-release:1.1
	gdb_6_6-branch:1.1.0.18
	gdb_6_6-2006-11-15-branchpoint:1.1
	insight_6_5-20061003-release:1.1
	gdb-csl-symbian-6_4_50_20060226-12:1.1
	nickrob-async-20060828-mergepoint:1.1
	gdb-csl-symbian-6_4_50_20060226-11:1.1
	gdb-csl-sourcerygxx-4_1-17:1.1
	gdb-csl-20060226-branch-local-2:1.1
	gdb-csl-sourcerygxx-4_1-14:1.1
	gdb-csl-sourcerygxx-4_1-13:1.1
	gdb-csl-sourcerygxx-4_1-12:1.1
	gdb-csl-sourcerygxx-3_4_4-21:1.1
	gdb_6_5-20060621-release:1.1
	gdb-csl-sourcerygxx-4_1-9:1.1
	gdb-csl-sourcerygxx-4_1-8:1.1
	gdb-csl-sourcerygxx-4_1-7:1.1
	gdb-csl-arm-2006q1-6:1.1
	gdb-csl-sourcerygxx-4_1-6:1.1
	gdb-csl-symbian-6_4_50_20060226-10:1.1
	gdb-csl-symbian-6_4_50_20060226-9:1.1
	gdb-csl-symbian-6_4_50_20060226-8:1.1
	gdb-csl-coldfire-4_1-11:1.1
	gdb-csl-sourcerygxx-3_4_4-19:1.1
	gdb-csl-coldfire-4_1-10:1.1
	gdb_6_5-branch:1.1.0.16
	gdb_6_5-2006-05-14-branchpoint:1.1
	gdb-csl-sourcerygxx-4_1-5:1.1
	nickrob-async-20060513-branch:1.1.0.14
	nickrob-async-20060513-branchpoint:1.1
	gdb-csl-sourcerygxx-4_1-4:1.1
	msnyder-reverse-20060502-branch:1.1.0.12
	msnyder-reverse-20060502-branchpoint:1.1
	gdb-csl-morpho-4_1-4:1.1
	gdb-csl-sourcerygxx-3_4_4-17:1.1
	readline_5_1-import-branch:1.1.0.10
	readline_5_1-import-branchpoint:1.1
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.1
	gdb-csl-symbian-20060226-branch:1.1.0.8
	gdb-csl-symbian-20060226-branchpoint:1.1
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.1
	msnyder-reverse-20060331-branch:1.1.0.6
	msnyder-reverse-20060331-branchpoint:1.1
	gdb-csl-available-20060303-branch:1.1.0.4
	gdb-csl-available-20060303-branchpoint:1.1
	gdb-csl-20060226-branch:1.1.0.2
	gdb-csl-20060226-branchpoint:1.1;
locks; strict;
comment	@ * @;


1.18
date	2013.03.15.17.53.43;	author sje;	state Exp;
branches;
next	1.17;

1.17
date	2013.01.01.06.41.38;	author brobecke;	state Exp;
branches;
next	1.16;

1.16
date	2012.05.24.16.51.43;	author palves;	state Exp;
branches;
next	1.15;

1.15
date	2012.05.19.16.46.15;	author nickc;	state Exp;
branches;
next	1.14;

1.14
date	2012.01.04.08.28.12;	author brobecke;	state Exp;
branches;
next	1.13;

1.13
date	2011.04.16.18.16.35;	author vapier;	state Exp;
branches
	1.13.2.1;
next	1.12;

1.12
date	2011.01.11.14.19.32;	author aburgess;	state Exp;
branches;
next	1.11;

1.11
date	2011.01.01.15.34.01;	author brobecke;	state Exp;
branches;
next	1.10;

1.10
date	2010.04.14.07.38.04;	author vapier;	state Exp;
branches;
next	1.9;

1.9
date	2010.01.01.10.03.31;	author brobecke;	state Exp;
branches;
next	1.8;

1.8
date	2009.05.08.22.54.34;	author kevinb;	state Exp;
branches;
next	1.7;

1.7
date	2009.01.14.10.53.07;	author brobecke;	state Exp;
branches;
next	1.6;

1.6
date	2008.06.06.19.26.10;	author dj;	state Exp;
branches;
next	1.5;

1.5
date	2008.06.06.19.18.14;	author dj;	state Exp;
branches;
next	1.4;

1.4
date	2008.01.01.22.53.25;	author drow;	state Exp;
branches;
next	1.3;

1.3
date	2007.08.24.14.28.36;	author brobecke;	state Exp;
branches;
next	1.2;

1.2
date	2007.01.09.17.59.18;	author drow;	state Exp;
branches;
next	1.1;

1.1
date	2006.01.23.22.10.41;	author jimb;	state Exp;
branches;
next	;

1.13.2.1
date	2012.01.06.04.54.51;	author brobecke;	state Exp;
branches;
next	;


desc
@@


1.18
log
@gdb:

2013-03-15  Steve Ellcey  <sellcey@@mips.com>

	* remote-sim.c (sim_command_completer): Make char arguments const.

include:


2013-03-15  Steve Ellcey  <sellcey@@mips.com>

	* gdb/remote-sim.h (sim_command_completer): Make char arguments const.

sim:

2013-03-15  Steve Ellcey  <sellcey@@mips.com>

	* arm/wrapper.c (sim_complete_command): Make char arguments const.
	* avr/interp.c (sim_complete_command): Ditto.
	* common/sim-options.c (sim_complete_command): Ditto.
	* cr16/interp.c (sim_complete_command): Ditto.
	* erc32/interf.c (sim_complete_command): Ditto.
	* m32c/gdb-if.c (sim_complete_command): Ditto.
	* microblaze/interp.c (sim_complete_command): Ditto.
	* ppc/sim_calls.c (sim_complete_command): Ditto.
	* rl78/gdb-if.c (sim_complete_command): Ditto.
	* rx/gdb-if.c (sim_complete_command): Ditto.
	* sh/interp.c (sim_complete_command): Ditto.
@
text
@/* gdb.c --- sim interface to GDB.

Copyright (C) 2005-2013 Free Software Foundation, Inc.
Contributed by Red Hat, Inc.

This file is part of the GNU simulators.

This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.  */

#include "config.h"
#include <stdio.h>
#include <assert.h>
#include <signal.h>
#include <string.h>
#include <ctype.h>

#include "ansidecl.h"
#include "gdb/callback.h"
#include "gdb/remote-sim.h"
#include "gdb/signals.h"
#include "gdb/sim-m32c.h"

#include "cpu.h"
#include "mem.h"
#include "load.h"
#include "syscalls.h"
#ifdef TIMER_A
#include "timer_a.h"
#endif

/* I don't want to wrap up all the minisim's data structures in an
   object and pass that around.  That'd be a big change, and neither
   GDB nor run needs that ability.

   So we just have one instance, that lives in global variables, and
   each time we open it, we re-initialize it.  */
struct sim_state
{
  const char *message;
};

static struct sim_state the_minisim = {
  "This is the sole m32c minisim instance.  See libsim.a's global variables."
};

static int open;

SIM_DESC
sim_open (SIM_OPEN_KIND kind,
	  struct host_callback_struct *callback,
	  struct bfd *abfd, char **argv)
{
  setbuf (stdout, 0);
  if (open)
    fprintf (stderr, "m32c minisim: re-opened sim\n");

  /* The 'run' interface doesn't use this function, so we don't care
     about KIND; it's always SIM_OPEN_DEBUG.  */
  if (kind != SIM_OPEN_DEBUG)
    fprintf (stderr, "m32c minisim: sim_open KIND != SIM_OPEN_DEBUG: %d\n",
	     kind);

  if (abfd)
    m32c_set_mach (bfd_get_mach (abfd));

  /* We can use ABFD, if non-NULL to select the appropriate
     architecture.  But we only support the r8c right now.  */

  set_callbacks (callback);

  /* We don't expect any command-line arguments.  */

  init_mem ();
  init_regs ();

  open = 1;
  return &the_minisim;
}

static void
check_desc (SIM_DESC sd)
{
  if (sd != &the_minisim)
    fprintf (stderr, "m32c minisim: desc != &the_minisim\n");
}

void
sim_close (SIM_DESC sd, int quitting)
{
  check_desc (sd);

  /* Not much to do.  At least free up our memory.  */
  init_mem ();

  open = 0;
}

static bfd *
open_objfile (const char *filename)
{
  bfd *prog = bfd_openr (filename, 0);

  if (!prog)
    {
      fprintf (stderr, "Can't read %s\n", filename);
      return 0;
    }

  if (!bfd_check_format (prog, bfd_object))
    {
      fprintf (stderr, "%s not a m32c program\n", filename);
      return 0;
    }

  return prog;
}


SIM_RC
sim_load (SIM_DESC sd, char *prog, struct bfd * abfd, int from_tty)
{
  check_desc (sd);

  if (!abfd)
    abfd = open_objfile (prog);
  if (!abfd)
    return SIM_RC_FAIL;

  m32c_load (abfd);

  return SIM_RC_OK;
}

SIM_RC
sim_create_inferior (SIM_DESC sd, struct bfd * abfd, char **argv, char **env)
{
  check_desc (sd);

  if (abfd)
    m32c_load (abfd);

  return SIM_RC_OK;
}

int
sim_read (SIM_DESC sd, SIM_ADDR mem, unsigned char *buf, int length)
{
  check_desc (sd);

  if (mem == 0)
    return 0;

  mem_get_blk ((int) mem, buf, length);

  return length;
}

int
sim_write (SIM_DESC sd, SIM_ADDR mem, const unsigned char *buf, int length)
{
  check_desc (sd);

  mem_put_blk ((int) mem, buf, length);

  return length;
}


/* Read the LENGTH bytes at BUF as an little-endian value.  */
static DI
get_le (unsigned char *buf, int length)
{
  DI acc = 0;
  while (--length >= 0)
    acc = (acc << 8) + buf[length];

  return acc;
}

/* Store VAL as a little-endian value in the LENGTH bytes at BUF.  */
static void
put_le (unsigned char *buf, int length, DI val)
{
  int i;

  for (i = 0; i < length; i++)
    {
      buf[i] = val & 0xff;
      val >>= 8;
    }
}

static int
check_regno (enum m32c_sim_reg regno)
{
  return 0 <= regno && regno < m32c_sim_reg_num_regs;
}

static size_t
mask_size (int addr_mask)
{
  switch (addr_mask)
    {
    case 0xffff:
      return 2;
    case 0xfffff:
    case 0xffffff:
      return 3;
    default:
      fprintf (stderr,
	       "m32c minisim: addr_mask_size: unexpected mask 0x%x\n",
	       addr_mask);
      return sizeof (addr_mask);
    }
}

static size_t
reg_size (enum m32c_sim_reg regno)
{
  switch (regno)
    {
    case m32c_sim_reg_r0_bank0:
    case m32c_sim_reg_r1_bank0:
    case m32c_sim_reg_r2_bank0:
    case m32c_sim_reg_r3_bank0:
    case m32c_sim_reg_r0_bank1:
    case m32c_sim_reg_r1_bank1:
    case m32c_sim_reg_r2_bank1:
    case m32c_sim_reg_r3_bank1:
    case m32c_sim_reg_flg:
    case m32c_sim_reg_svf:
      return 2;

    case m32c_sim_reg_a0_bank0:
    case m32c_sim_reg_a1_bank0:
    case m32c_sim_reg_fb_bank0:
    case m32c_sim_reg_sb_bank0:
    case m32c_sim_reg_a0_bank1:
    case m32c_sim_reg_a1_bank1:
    case m32c_sim_reg_fb_bank1:
    case m32c_sim_reg_sb_bank1:
    case m32c_sim_reg_usp:
    case m32c_sim_reg_isp:
      return mask_size (addr_mask);

    case m32c_sim_reg_pc:
    case m32c_sim_reg_intb:
    case m32c_sim_reg_svp:
    case m32c_sim_reg_vct:
      return mask_size (membus_mask);

    case m32c_sim_reg_dmd0:
    case m32c_sim_reg_dmd1:
      return 1;

    case m32c_sim_reg_dct0:
    case m32c_sim_reg_dct1:
    case m32c_sim_reg_drc0:
    case m32c_sim_reg_drc1:
      return 2;

    case m32c_sim_reg_dma0:
    case m32c_sim_reg_dma1:
    case m32c_sim_reg_dsa0:
    case m32c_sim_reg_dsa1:
    case m32c_sim_reg_dra0:
    case m32c_sim_reg_dra1:
      return 3;

    default:
      fprintf (stderr, "m32c minisim: unrecognized register number: %d\n",
	       regno);
      return -1;
    }
}

int
sim_fetch_register (SIM_DESC sd, int regno, unsigned char *buf, int length)
{
  size_t size;

  check_desc (sd);

  if (!check_regno (regno))
    return 0;

  size = reg_size (regno);
  if (length == size)
    {
      DI val;

      switch (regno)
	{
	case m32c_sim_reg_r0_bank0:
	  val = regs.r[0].r_r0;
	  break;
	case m32c_sim_reg_r1_bank0:
	  val = regs.r[0].r_r1;
	  break;
	case m32c_sim_reg_r2_bank0:
	  val = regs.r[0].r_r2;
	  break;
	case m32c_sim_reg_r3_bank0:
	  val = regs.r[0].r_r3;
	  break;
	case m32c_sim_reg_a0_bank0:
	  val = regs.r[0].r_a0;
	  break;
	case m32c_sim_reg_a1_bank0:
	  val = regs.r[0].r_a1;
	  break;
	case m32c_sim_reg_fb_bank0:
	  val = regs.r[0].r_fb;
	  break;
	case m32c_sim_reg_sb_bank0:
	  val = regs.r[0].r_sb;
	  break;
	case m32c_sim_reg_r0_bank1:
	  val = regs.r[1].r_r0;
	  break;
	case m32c_sim_reg_r1_bank1:
	  val = regs.r[1].r_r1;
	  break;
	case m32c_sim_reg_r2_bank1:
	  val = regs.r[1].r_r2;
	  break;
	case m32c_sim_reg_r3_bank1:
	  val = regs.r[1].r_r3;
	  break;
	case m32c_sim_reg_a0_bank1:
	  val = regs.r[1].r_a0;
	  break;
	case m32c_sim_reg_a1_bank1:
	  val = regs.r[1].r_a1;
	  break;
	case m32c_sim_reg_fb_bank1:
	  val = regs.r[1].r_fb;
	  break;
	case m32c_sim_reg_sb_bank1:
	  val = regs.r[1].r_sb;
	  break;

	case m32c_sim_reg_usp:
	  val = regs.r_usp;
	  break;
	case m32c_sim_reg_isp:
	  val = regs.r_isp;
	  break;
	case m32c_sim_reg_pc:
	  val = regs.r_pc;
	  break;
	case m32c_sim_reg_intb:
	  val = regs.r_intbl * 65536 + regs.r_intbl;
	  break;
	case m32c_sim_reg_flg:
	  val = regs.r_flags;
	  break;

	  /* These registers aren't implemented by the minisim.  */
	case m32c_sim_reg_svf:
	case m32c_sim_reg_svp:
	case m32c_sim_reg_vct:
	case m32c_sim_reg_dmd0:
	case m32c_sim_reg_dmd1:
	case m32c_sim_reg_dct0:
	case m32c_sim_reg_dct1:
	case m32c_sim_reg_drc0:
	case m32c_sim_reg_drc1:
	case m32c_sim_reg_dma0:
	case m32c_sim_reg_dma1:
	case m32c_sim_reg_dsa0:
	case m32c_sim_reg_dsa1:
	case m32c_sim_reg_dra0:
	case m32c_sim_reg_dra1:
	  return 0;

	default:
	  fprintf (stderr, "m32c minisim: unrecognized register number: %d\n",
		   regno);
	  return -1;
	}

      put_le (buf, length, val);
    }

  return size;
}

int
sim_store_register (SIM_DESC sd, int regno, unsigned char *buf, int length)
{
  size_t size;

  check_desc (sd);

  if (!check_regno (regno))
    return -1;

  size = reg_size (regno);

  if (length == size)
    {
      DI val = get_le (buf, length);

      switch (regno)
	{
	case m32c_sim_reg_r0_bank0:
	  regs.r[0].r_r0 = val & 0xffff;
	  break;
	case m32c_sim_reg_r1_bank0:
	  regs.r[0].r_r1 = val & 0xffff;
	  break;
	case m32c_sim_reg_r2_bank0:
	  regs.r[0].r_r2 = val & 0xffff;
	  break;
	case m32c_sim_reg_r3_bank0:
	  regs.r[0].r_r3 = val & 0xffff;
	  break;
	case m32c_sim_reg_a0_bank0:
	  regs.r[0].r_a0 = val & addr_mask;
	  break;
	case m32c_sim_reg_a1_bank0:
	  regs.r[0].r_a1 = val & addr_mask;
	  break;
	case m32c_sim_reg_fb_bank0:
	  regs.r[0].r_fb = val & addr_mask;
	  break;
	case m32c_sim_reg_sb_bank0:
	  regs.r[0].r_sb = val & addr_mask;
	  break;
	case m32c_sim_reg_r0_bank1:
	  regs.r[1].r_r0 = val & 0xffff;
	  break;
	case m32c_sim_reg_r1_bank1:
	  regs.r[1].r_r1 = val & 0xffff;
	  break;
	case m32c_sim_reg_r2_bank1:
	  regs.r[1].r_r2 = val & 0xffff;
	  break;
	case m32c_sim_reg_r3_bank1:
	  regs.r[1].r_r3 = val & 0xffff;
	  break;
	case m32c_sim_reg_a0_bank1:
	  regs.r[1].r_a0 = val & addr_mask;
	  break;
	case m32c_sim_reg_a1_bank1:
	  regs.r[1].r_a1 = val & addr_mask;
	  break;
	case m32c_sim_reg_fb_bank1:
	  regs.r[1].r_fb = val & addr_mask;
	  break;
	case m32c_sim_reg_sb_bank1:
	  regs.r[1].r_sb = val & addr_mask;
	  break;

	case m32c_sim_reg_usp:
	  regs.r_usp = val & addr_mask;
	  break;
	case m32c_sim_reg_isp:
	  regs.r_isp = val & addr_mask;
	  break;
	case m32c_sim_reg_pc:
	  regs.r_pc = val & membus_mask;
	  break;
	case m32c_sim_reg_intb:
	  regs.r_intbl = (val & membus_mask) & 0xffff;
	  regs.r_intbh = (val & membus_mask) >> 16;
	  break;
	case m32c_sim_reg_flg:
	  regs.r_flags = val & 0xffff;
	  break;

	  /* These registers aren't implemented by the minisim.  */
	case m32c_sim_reg_svf:
	case m32c_sim_reg_svp:
	case m32c_sim_reg_vct:
	case m32c_sim_reg_dmd0:
	case m32c_sim_reg_dmd1:
	case m32c_sim_reg_dct0:
	case m32c_sim_reg_dct1:
	case m32c_sim_reg_drc0:
	case m32c_sim_reg_drc1:
	case m32c_sim_reg_dma0:
	case m32c_sim_reg_dma1:
	case m32c_sim_reg_dsa0:
	case m32c_sim_reg_dsa1:
	case m32c_sim_reg_dra0:
	case m32c_sim_reg_dra1:
	  return 0;

	default:
	  fprintf (stderr, "m32c minisim: unrecognized register number: %d\n",
		   regno);
	  return 0;
	}
    }

  return size;
}

void
sim_info (SIM_DESC sd, int verbose)
{
  check_desc (sd);

  printf ("The m32c minisim doesn't collect any statistics.\n");
}

static volatile int stop;
static enum sim_stop reason;
int siggnal;


/* Given a signal number used by the M32C bsp (that is, newlib),
   return a target signal number used by GDB.  */
int
m32c_signal_to_target (int m32c)
{
  switch (m32c)
    {
    case 4:
      return GDB_SIGNAL_ILL;

    case 5:
      return GDB_SIGNAL_TRAP;

    case 10:
      return GDB_SIGNAL_BUS;

    case 11:
      return GDB_SIGNAL_SEGV;

    case 24:
      return GDB_SIGNAL_XCPU;

    case 2:
      return GDB_SIGNAL_INT;

    case 8:
      return GDB_SIGNAL_FPE;

    case 6:
      return GDB_SIGNAL_ABRT;
    }

  return 0;
}


/* Take a step return code RC and set up the variables consulted by
   sim_stop_reason appropriately.  */
void
handle_step (int rc)
{
  if (M32C_STEPPED (rc) || M32C_HIT_BREAK (rc))
    {
      reason = sim_stopped;
      siggnal = GDB_SIGNAL_TRAP;
    }
  else if (M32C_STOPPED (rc))
    {
      reason = sim_stopped;
      siggnal = m32c_signal_to_target (M32C_STOP_SIG (rc));
    }
  else
    {
      assert (M32C_EXITED (rc));
      reason = sim_exited;
      siggnal = M32C_EXIT_STATUS (rc);
    }
}


void
sim_resume (SIM_DESC sd, int step, int sig_to_deliver)
{
  check_desc (sd);

  if (sig_to_deliver != 0)
    {
      fprintf (stderr,
	       "Warning: the m32c minisim does not implement "
	       "signal delivery yet.\n" "Resuming with no signal.\n");
    }

  if (step)
    {
      handle_step (decode_opcode ());
#ifdef TIMER_A
      update_timer_a ();
#endif
    }
  else
    {
      /* We don't clear 'stop' here, because then we would miss
         interrupts that arrived on the way here.  Instead, we clear
         the flag in sim_stop_reason, after GDB has disabled the
         interrupt signal handler.  */
      for (;;)
	{
	  if (stop)
	    {
	      stop = 0;
	      reason = sim_stopped;
	      siggnal = GDB_SIGNAL_INT;
	      break;
	    }

	  int rc = decode_opcode ();
#ifdef TIMER_A
	  update_timer_a ();
#endif

	  if (!M32C_STEPPED (rc))
	    {
	      handle_step (rc);
	      break;
	    }
	}
    }
  m32c_sim_restore_console ();
}

int
sim_stop (SIM_DESC sd)
{
  stop = 1;

  return 1;
}

void
sim_stop_reason (SIM_DESC sd, enum sim_stop *reason_p, int *sigrc_p)
{
  check_desc (sd);

  *reason_p = reason;
  *sigrc_p = siggnal;
}

void
sim_do_command (SIM_DESC sd, char *cmd)
{
  check_desc (sd);

  char *p = cmd;

  /* Skip leading whitespace.  */
  while (isspace (*p))
    p++;

  /* Find the extent of the command word.  */
  for (p = cmd; *p; p++)
    if (isspace (*p))
      break;

  /* Null-terminate the command word, and record the start of any
     further arguments.  */
  char *args;
  if (*p)
    {
      *p = '\0';
      args = p + 1;
      while (isspace (*args))
	args++;
    }
  else
    args = p;

  if (strcmp (cmd, "trace") == 0)
    {
      if (strcmp (args, "on") == 0)
	trace = 1;
      else if (strcmp (args, "off") == 0)
	trace = 0;
      else
	printf ("The 'sim trace' command expects 'on' or 'off' "
		"as an argument.\n");
    }
  else if (strcmp (cmd, "verbose") == 0)
    {
      if (strcmp (args, "on") == 0)
	verbose = 1;
      else if (strcmp (args, "off") == 0)
	verbose = 0;
      else
	printf ("The 'sim verbose' command expects 'on' or 'off'"
		" as an argument.\n");
    }
  else
    printf ("The 'sim' command expects either 'trace' or 'verbose'"
	    " as a subcommand.\n");
}

char **
sim_complete_command (SIM_DESC sd, const char *text, const char *word)
{
  return NULL;
}
@


1.17
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@d707 1
a707 1
sim_complete_command (SIM_DESC sd, char *text, char *word)
@


1.16
log
@gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

gdb/gdbserver/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

include/gdb/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        * gdb/signals.def: Replace TARGET_SIGNAL_ with GDB_SIGNAL_
	throughout.

sim/arm/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/avr/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/common/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/cr16/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/d10v/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/erc32/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/m32c/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/ppc/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rl78/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.

sim/rx/
2012-05-24  Pedro Alves  <palves@@redhat.com>

	PR gdb/7205

        Replace TARGET_SIGNAL_ with GDB_SIGNAL_ throughout.
@
text
@d3 1
a3 1
Copyright (C) 2005, 2007-2012 Free Software Foundation, Inc.
@


1.15
log
@	PR 14072
	* wrapper.c: Include config.h before system header files.

	* callback.c: Include config.h before system header files.
	* cgen-trace.c: Likewise.
	* cgen-utils.c: Likewise.
	* gentmap.c: Likewise.

	* sim-if.c: Include config.h before system header files.

	* compile.c: Include config.h before system header files.
	* sim-main.h: Likewise.

	* gdb-if.c: Include config.h before system header files.
	* load.c: Likewise.
	* syscalls.c: Likewise.
	* trace.c: Likewise.

	* interp.c: Include config.h before system header files.
@
text
@d533 1
a533 1
      return TARGET_SIGNAL_ILL;
d536 1
a536 1
      return TARGET_SIGNAL_TRAP;
d539 1
a539 1
      return TARGET_SIGNAL_BUS;
d542 1
a542 1
      return TARGET_SIGNAL_SEGV;
d545 1
a545 1
      return TARGET_SIGNAL_XCPU;
d548 1
a548 1
      return TARGET_SIGNAL_INT;
d551 1
a551 1
      return TARGET_SIGNAL_FPE;
d554 1
a554 1
      return TARGET_SIGNAL_ABRT;
d569 1
a569 1
      siggnal = TARGET_SIGNAL_TRAP;
d616 1
a616 1
	      siggnal = TARGET_SIGNAL_INT;
@


1.14
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d21 1
a21 1

@


1.13
log
@sim: add sim_complete_command stubs for non-common-using ports

For the ports that don't use the common/ subdir, we need to add stub funcs
to them to avoid build failures with gdb and command completion.  These do
not implement the actual completion functionality ... any port that wants
that can either convert to the common/ subdir, or fill out the function on
their own time.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d3 1
a3 2
Copyright (C) 2005, 2007, 2008, 2009, 2010, 2011
Free Software Foundation, Inc.
@


1.13.2.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 1
Copyright (C) 2005, 2007-2012 Free Software Foundation, Inc.
@


1.12
log
@http://sourceware.org/ml/gdb-patches/2010-11/msg00112.html
gdb/ChangeLog
	* remote-sim.c (gdbsim_store_register): Update API to
	sim_store_register to check more error conditions.
include/gdb/ChangeLog
	* remote-sim.h (sim_store_register): Update the API
	documentation for this function.
sim/erc32/ChangeLog
sim/h8300/ChangeLog
sim/m32c/ChangeLog
sim/mn10300/ChangeLog
sim/ppc/ChangeLog
sim/rx/ChangeLog
sim/v850/ChangeLog
	* ???.c (sim_store_register): Update return value to
	match new API.
@
text
@d706 6
@


1.11
log
@run copyright.sh for 2011.
@
text
@d409 1
a409 1
    return 0;
d506 1
a506 1
	  return -1;
@


1.10
log
@sim: constify sim_write source buffer (part 2)

As pointed out by Sandra Loosemore, a bunch of targets define sim_write
themselves instead of using the common/ code.  So constify them too.

Signed-off-by: Mike Frysinger <vapier@@gentoo.org>
@
text
@d3 2
a4 1
Copyright (C) 2005, 2007, 2008, 2009, 2010 Free Software Foundation, Inc.
@


1.9
log
@Update copyright notices to add year 2010.
@
text
@d170 1
a170 1
sim_write (SIM_DESC sd, SIM_ADDR mem, unsigned char *buf, int length)
@


1.8
log
@	* m32c/gdb-if.c (m32c_signal_to_host): Rename to
	m32c_signal_to_target.  Change signal return values from SIGILL,
	SIGTRAP, SIGSEGV, etc. to TARGET_SIGNAL_ILL, TARGET_SIGNAL_TRAP,
	TARGET_SIGNAL_SEGV, etc.  Fix all callers.
@
text
@d3 1
a3 1
Copyright (C) 2005, 2007, 2008, 2009 Free Software Foundation, Inc.
@


1.7
log
@        Update the copyright notice of some of the files I missed
        in the previous copyright update.
@
text
@d526 1
a526 2
   return a host signal number.  (Oddly, the gdb/sim interface uses
   host signal numbers...)  */
d528 1
a528 1
m32c_signal_to_host (int m32c)
d533 1
a533 5
#ifdef SIGILL
      return SIGILL;
#else
      return SIGSEGV;
#endif
d536 1
a536 1
      return SIGTRAP;
d539 1
a539 5
#ifdef SIGBUS
      return SIGBUS;
#else
      return SIGSEGV;
#endif
d542 1
a542 1
      return SIGSEGV;
d545 1
a545 5
#ifdef SIGXCPU
      return SIGXCPU;
#else
      break;
#endif
d548 1
a548 1
      return SIGINT;
d551 1
a551 5
#ifdef SIGFPE
      return SIGFPE;
#else
      break;
#endif
d554 1
a554 1
      return SIGABRT;
d574 1
a574 1
      siggnal = m32c_signal_to_host (M32C_STOP_SIG (rc));
@


1.6
log
@Oops, missed some warnings.
* mem.h (m32c_sim_restore_console): New.
@
text
@d3 1
a3 1
Copyright (C) 2005, 2007, 2008 Free Software Foundation, Inc.
@


1.5
log
@* Makefile.in: Add Timer A support.
* cpu.h (m32c_opcode_pc): New.
(in_gdb): New.
* gdb-if.c (sim_open): Add Timer A support.  Support unbuffered
console.
* int.c (trigger_interrupt): Manage the U flag properly.
(trigger_based_interrupt): Likewise.
(trigger_fixed_interrupt): New.
(trigger_peripheral_interrupt): New.
* int.h (trigger_peripheral_interrupt): New.
* m32c.opc: Use m32c_opcode_pc throughout, as needed.
(decode_m32c): Detect jump-to-zero with traceback.
(BRK): Try to do the right thing, keeping track of whether we're
in gdb or not, and if the user has provided a handler or not.
(GBRK): Alternate break opcode for gdb, in case the user's app
needs to use BRK for itself.
(BRK2): Implement.
* main.c: Add Timer A support.  Support TCP-based console.
(setup_tcp_console): New.
(main): Add Timer A support.  Support TCP-based console.
* mem.c: Add Timer A support.  Support TCP-based console.
(mem_ptr): Enhance NULL pointer detection.
(stdin_ready): New.
(m32c_sim_restore_console): New.
(mem_get_byte): Check for console input ready.
(update_timer_a): New.
* r8c.opc (SSTR): Use r0l, not r0h.
(REIT): Fix return frame logic.
* reg.c (print_flags): New.
(trace_register_changes): Use it.
(m32c_dump_all_registers): New.
* timer_a.h: New.

* load.c: Fix indentation.
* trace.c: Fix indentation.
* trace.h: Fix indentation.
@
text
@d38 3
@


1.4
log
@	Updated copyright notices for most files.
@
text
@d61 1
d128 1
a128 1
sim_load (SIM_DESC sd, char *prog, struct bfd *abfd, int from_tty)
d143 1
a143 1
sim_create_inferior (SIM_DESC sd, struct bfd *abfd, char **argv, char **env)
d612 6
a617 1
    handle_step (decode_opcode ());
d635 3
d646 1
@


1.3
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d3 1
a3 1
Copyright (C) 2005, 2007 Free Software Foundation, Inc.
@


1.2
log
@Copyright updates for 2007.
@
text
@d8 9
a16 9
The GNU simulators are free software; you can redistribute them and/or
modify them under the terms of the GNU General Public License as
published by the Free Software Foundation; either version 2 of the
License, or (at your option) any later version.

The GNU simulators are distributed in the hope that they will be
useful, but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
General Public License for more details.
d19 1
a19 3
along with the GNU simulators; if not, write to the Free Software
Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA
02110-1301, USA  */
@


1.1
log
@sim/ChangeLog:
2005-10-06  Jim Blandy  <jimb@@redhat.com>

	Add simulator for Renesas M32C and M16C.

	* m32c: New directory.
	* configure.ac: Add entry for Renesas M32C.
	* configure: Regenerate.

sim/m32c/ChangeLog:
2005-10-06  Jim Blandy  <jimb@@redhat.com>

	Simulator for Renesas M32C and M16C, by DJ Delorie <dj@@redhat.com>,
	with further work from Jim Blandy <jimb@@redhat.com> and
	Kevin Buettner <kevinb@@redhat.com>.

	* ChangeLog: New.
	* Makefile.in: New.
	* blinky.S: New.
	* config.in: New.
	* configure: New.
	* configure.in: New.
	* cpu.h: New.
	* gdb-if.c: New.
	* gloss.S: New.
	* int.c: New.
	* int.h: New.
	* load.c: New.
	* load.h: New.
	* m32c.opc: New.
	* main.c: New.
	* mem.c: New.
	* mem.h: New.
	* misc.c: New.
	* misc.h: New.
	* opc2c.c: New.
	* r8c.opc: New.
	* reg.c: New.
	* safe-fgets.c: New.
	* safe-fgets.h: New.
	* sample.S: New.
	* sample.ld: New.
	* sample2.c: New.
	* srcdest.c: New.
	* syscalls.c: New.
	* syscalls.h: New.
	* trace.c: New.
	* trace.h: New.
@
text
@d3 1
a3 1
Copyright (C) 2005 Free Software Foundation, Inc.
@

