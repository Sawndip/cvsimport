head	1.9;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.9
	gdb_7_6-2013-04-26-release:1.9
	gdb_7_6-branch:1.9.0.2
	gdb_7_6-2013-03-12-branchpoint:1.9
	gdb_7_5_1-2012-11-29-release:1.7
	gdb_7_5-2012-08-17-release:1.7
	gdb_7_5-branch:1.7.0.2
	gdb_7_5-2012-07-18-branchpoint:1.7
	gdb_7_4_1-2012-04-26-release:1.6.8.1
	gdb_7_4-2012-01-24-release:1.6.8.1
	gdb_7_4-branch:1.6.0.8
	gdb_7_4-2011-12-13-branchpoint:1.6
	gdb_7_3_1-2011-09-04-release:1.6
	gdb_7_3-2011-07-26-release:1.6
	gdb_7_3-branch:1.6.0.6
	gdb_7_3-2011-04-01-branchpoint:1.6
	gdb_7_2-2010-09-02-release:1.6
	gdb_7_2-branch:1.6.0.4
	gdb_7_2-2010-07-07-branchpoint:1.6
	gdb_7_1-2010-03-18-release:1.6
	gdb_7_1-branch:1.6.0.2
	gdb_7_1-2010-02-18-branchpoint:1.6
	gdb_7_0_1-2009-12-22-release:1.3
	gdb_7_0-2009-10-06-release:1.3
	gdb_7_0-branch:1.3.0.22
	gdb_7_0-2009-09-16-branchpoint:1.3
	arc-sim-20090309:1.3
	msnyder-checkpoint-072509-branch:1.3.0.20
	msnyder-checkpoint-072509-branchpoint:1.3
	arc-insight_6_8-branch:1.3.0.18
	arc-insight_6_8-branchpoint:1.3
	insight_6_8-branch:1.3.0.16
	insight_6_8-branchpoint:1.3
	reverse-20081226-branch:1.3.0.14
	reverse-20081226-branchpoint:1.3
	multiprocess-20081120-branch:1.3.0.12
	multiprocess-20081120-branchpoint:1.3
	reverse-20080930-branch:1.3.0.10
	reverse-20080930-branchpoint:1.3
	reverse-20080717-branch:1.3.0.8
	reverse-20080717-branchpoint:1.3
	msnyder-reverse-20080609-branch:1.3.0.6
	msnyder-reverse-20080609-branchpoint:1.3
	drow-reverse-20070409-branch:1.2.0.2
	drow-reverse-20070409-branchpoint:1.2
	gdb_6_8-2008-03-27-release:1.3
	gdb_6_8-branch:1.3.0.4
	gdb_6_8-2008-02-26-branchpoint:1.3
	gdb_6_7_1-2007-10-29-release:1.3
	gdb_6_7-2007-10-10-release:1.3
	gdb_6_7-branch:1.3.0.2
	gdb_6_7-2007-09-07-branchpoint:1.3
	gdb-csl-arm-20051020-branch:1.1.0.2
	gdb-csl-arm-20051020-branchpoint:1.1;
locks; strict;
comment	@ * @;


1.9
date	2013.01.01.06.41.40;	author brobecke;	state Exp;
branches;
next	1.8;

1.8
date	2012.12.19.07.18.22;	author brobecke;	state Exp;
branches;
next	1.7;

1.7
date	2012.01.04.08.28.25;	author brobecke;	state Exp;
branches;
next	1.6;

1.6
date	2010.02.12.02.44.26;	author devans;	state Exp;
branches
	1.6.8.1;
next	1.5;

1.5
date	2010.01.02.19.09.21;	author devans;	state Exp;
branches;
next	1.4;

1.4
date	2009.11.04.04.40.47;	author devans;	state Exp;
branches;
next	1.3;

1.3
date	2007.08.24.14.28.42;	author brobecke;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.18.18.13.22;	author brolley;	state Exp;
branches;
next	1.1;

1.1
date	2002.02.01.11.44.27;	author bje;	state Exp;
branches;
next	;

1.6.8.1
date	2012.01.06.04.54.56;	author brobecke;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* Simulator instruction semantics for sh64.

THIS FILE IS MACHINE GENERATED WITH CGEN.

Copyright 1996-2013 Free Software Foundation, Inc.

This file is part of the GNU simulators.

   This file is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License along
   with this program; if not, see <http://www.gnu.org/licenses/>.

*/

#ifdef DEFINE_LABELS

  /* The labels have the case they have because the enum of insn types
     is all uppercase and in the non-stdc case the insn symbol is built
     into the enum name.  */

  static struct {
    int index;
    void *label;
  } labels[] = {
    { SH64_COMPACT_INSN_X_INVALID, && case_sem_INSN_X_INVALID },
    { SH64_COMPACT_INSN_X_AFTER, && case_sem_INSN_X_AFTER },
    { SH64_COMPACT_INSN_X_BEFORE, && case_sem_INSN_X_BEFORE },
    { SH64_COMPACT_INSN_X_CTI_CHAIN, && case_sem_INSN_X_CTI_CHAIN },
    { SH64_COMPACT_INSN_X_CHAIN, && case_sem_INSN_X_CHAIN },
    { SH64_COMPACT_INSN_X_BEGIN, && case_sem_INSN_X_BEGIN },
    { SH64_COMPACT_INSN_ADD_COMPACT, && case_sem_INSN_ADD_COMPACT },
    { SH64_COMPACT_INSN_ADDI_COMPACT, && case_sem_INSN_ADDI_COMPACT },
    { SH64_COMPACT_INSN_ADDC_COMPACT, && case_sem_INSN_ADDC_COMPACT },
    { SH64_COMPACT_INSN_ADDV_COMPACT, && case_sem_INSN_ADDV_COMPACT },
    { SH64_COMPACT_INSN_AND_COMPACT, && case_sem_INSN_AND_COMPACT },
    { SH64_COMPACT_INSN_ANDI_COMPACT, && case_sem_INSN_ANDI_COMPACT },
    { SH64_COMPACT_INSN_ANDB_COMPACT, && case_sem_INSN_ANDB_COMPACT },
    { SH64_COMPACT_INSN_BF_COMPACT, && case_sem_INSN_BF_COMPACT },
    { SH64_COMPACT_INSN_BFS_COMPACT, && case_sem_INSN_BFS_COMPACT },
    { SH64_COMPACT_INSN_BRA_COMPACT, && case_sem_INSN_BRA_COMPACT },
    { SH64_COMPACT_INSN_BRAF_COMPACT, && case_sem_INSN_BRAF_COMPACT },
    { SH64_COMPACT_INSN_BRK_COMPACT, && case_sem_INSN_BRK_COMPACT },
    { SH64_COMPACT_INSN_BSR_COMPACT, && case_sem_INSN_BSR_COMPACT },
    { SH64_COMPACT_INSN_BSRF_COMPACT, && case_sem_INSN_BSRF_COMPACT },
    { SH64_COMPACT_INSN_BT_COMPACT, && case_sem_INSN_BT_COMPACT },
    { SH64_COMPACT_INSN_BTS_COMPACT, && case_sem_INSN_BTS_COMPACT },
    { SH64_COMPACT_INSN_CLRMAC_COMPACT, && case_sem_INSN_CLRMAC_COMPACT },
    { SH64_COMPACT_INSN_CLRS_COMPACT, && case_sem_INSN_CLRS_COMPACT },
    { SH64_COMPACT_INSN_CLRT_COMPACT, && case_sem_INSN_CLRT_COMPACT },
    { SH64_COMPACT_INSN_CMPEQ_COMPACT, && case_sem_INSN_CMPEQ_COMPACT },
    { SH64_COMPACT_INSN_CMPEQI_COMPACT, && case_sem_INSN_CMPEQI_COMPACT },
    { SH64_COMPACT_INSN_CMPGE_COMPACT, && case_sem_INSN_CMPGE_COMPACT },
    { SH64_COMPACT_INSN_CMPGT_COMPACT, && case_sem_INSN_CMPGT_COMPACT },
    { SH64_COMPACT_INSN_CMPHI_COMPACT, && case_sem_INSN_CMPHI_COMPACT },
    { SH64_COMPACT_INSN_CMPHS_COMPACT, && case_sem_INSN_CMPHS_COMPACT },
    { SH64_COMPACT_INSN_CMPPL_COMPACT, && case_sem_INSN_CMPPL_COMPACT },
    { SH64_COMPACT_INSN_CMPPZ_COMPACT, && case_sem_INSN_CMPPZ_COMPACT },
    { SH64_COMPACT_INSN_CMPSTR_COMPACT, && case_sem_INSN_CMPSTR_COMPACT },
    { SH64_COMPACT_INSN_DIV0S_COMPACT, && case_sem_INSN_DIV0S_COMPACT },
    { SH64_COMPACT_INSN_DIV0U_COMPACT, && case_sem_INSN_DIV0U_COMPACT },
    { SH64_COMPACT_INSN_DIV1_COMPACT, && case_sem_INSN_DIV1_COMPACT },
    { SH64_COMPACT_INSN_DIVU_COMPACT, && case_sem_INSN_DIVU_COMPACT },
    { SH64_COMPACT_INSN_MULR_COMPACT, && case_sem_INSN_MULR_COMPACT },
    { SH64_COMPACT_INSN_DMULSL_COMPACT, && case_sem_INSN_DMULSL_COMPACT },
    { SH64_COMPACT_INSN_DMULUL_COMPACT, && case_sem_INSN_DMULUL_COMPACT },
    { SH64_COMPACT_INSN_DT_COMPACT, && case_sem_INSN_DT_COMPACT },
    { SH64_COMPACT_INSN_EXTSB_COMPACT, && case_sem_INSN_EXTSB_COMPACT },
    { SH64_COMPACT_INSN_EXTSW_COMPACT, && case_sem_INSN_EXTSW_COMPACT },
    { SH64_COMPACT_INSN_EXTUB_COMPACT, && case_sem_INSN_EXTUB_COMPACT },
    { SH64_COMPACT_INSN_EXTUW_COMPACT, && case_sem_INSN_EXTUW_COMPACT },
    { SH64_COMPACT_INSN_FABS_COMPACT, && case_sem_INSN_FABS_COMPACT },
    { SH64_COMPACT_INSN_FADD_COMPACT, && case_sem_INSN_FADD_COMPACT },
    { SH64_COMPACT_INSN_FCMPEQ_COMPACT, && case_sem_INSN_FCMPEQ_COMPACT },
    { SH64_COMPACT_INSN_FCMPGT_COMPACT, && case_sem_INSN_FCMPGT_COMPACT },
    { SH64_COMPACT_INSN_FCNVDS_COMPACT, && case_sem_INSN_FCNVDS_COMPACT },
    { SH64_COMPACT_INSN_FCNVSD_COMPACT, && case_sem_INSN_FCNVSD_COMPACT },
    { SH64_COMPACT_INSN_FDIV_COMPACT, && case_sem_INSN_FDIV_COMPACT },
    { SH64_COMPACT_INSN_FIPR_COMPACT, && case_sem_INSN_FIPR_COMPACT },
    { SH64_COMPACT_INSN_FLDS_COMPACT, && case_sem_INSN_FLDS_COMPACT },
    { SH64_COMPACT_INSN_FLDI0_COMPACT, && case_sem_INSN_FLDI0_COMPACT },
    { SH64_COMPACT_INSN_FLDI1_COMPACT, && case_sem_INSN_FLDI1_COMPACT },
    { SH64_COMPACT_INSN_FLOAT_COMPACT, && case_sem_INSN_FLOAT_COMPACT },
    { SH64_COMPACT_INSN_FMAC_COMPACT, && case_sem_INSN_FMAC_COMPACT },
    { SH64_COMPACT_INSN_FMOV1_COMPACT, && case_sem_INSN_FMOV1_COMPACT },
    { SH64_COMPACT_INSN_FMOV2_COMPACT, && case_sem_INSN_FMOV2_COMPACT },
    { SH64_COMPACT_INSN_FMOV3_COMPACT, && case_sem_INSN_FMOV3_COMPACT },
    { SH64_COMPACT_INSN_FMOV4_COMPACT, && case_sem_INSN_FMOV4_COMPACT },
    { SH64_COMPACT_INSN_FMOV5_COMPACT, && case_sem_INSN_FMOV5_COMPACT },
    { SH64_COMPACT_INSN_FMOV6_COMPACT, && case_sem_INSN_FMOV6_COMPACT },
    { SH64_COMPACT_INSN_FMOV7_COMPACT, && case_sem_INSN_FMOV7_COMPACT },
    { SH64_COMPACT_INSN_FMOV8_COMPACT, && case_sem_INSN_FMOV8_COMPACT },
    { SH64_COMPACT_INSN_FMOV9_COMPACT, && case_sem_INSN_FMOV9_COMPACT },
    { SH64_COMPACT_INSN_FMUL_COMPACT, && case_sem_INSN_FMUL_COMPACT },
    { SH64_COMPACT_INSN_FNEG_COMPACT, && case_sem_INSN_FNEG_COMPACT },
    { SH64_COMPACT_INSN_FRCHG_COMPACT, && case_sem_INSN_FRCHG_COMPACT },
    { SH64_COMPACT_INSN_FSCHG_COMPACT, && case_sem_INSN_FSCHG_COMPACT },
    { SH64_COMPACT_INSN_FSQRT_COMPACT, && case_sem_INSN_FSQRT_COMPACT },
    { SH64_COMPACT_INSN_FSTS_COMPACT, && case_sem_INSN_FSTS_COMPACT },
    { SH64_COMPACT_INSN_FSUB_COMPACT, && case_sem_INSN_FSUB_COMPACT },
    { SH64_COMPACT_INSN_FTRC_COMPACT, && case_sem_INSN_FTRC_COMPACT },
    { SH64_COMPACT_INSN_FTRV_COMPACT, && case_sem_INSN_FTRV_COMPACT },
    { SH64_COMPACT_INSN_JMP_COMPACT, && case_sem_INSN_JMP_COMPACT },
    { SH64_COMPACT_INSN_JSR_COMPACT, && case_sem_INSN_JSR_COMPACT },
    { SH64_COMPACT_INSN_LDC_GBR_COMPACT, && case_sem_INSN_LDC_GBR_COMPACT },
    { SH64_COMPACT_INSN_LDC_VBR_COMPACT, && case_sem_INSN_LDC_VBR_COMPACT },
    { SH64_COMPACT_INSN_LDC_SR_COMPACT, && case_sem_INSN_LDC_SR_COMPACT },
    { SH64_COMPACT_INSN_LDCL_GBR_COMPACT, && case_sem_INSN_LDCL_GBR_COMPACT },
    { SH64_COMPACT_INSN_LDCL_VBR_COMPACT, && case_sem_INSN_LDCL_VBR_COMPACT },
    { SH64_COMPACT_INSN_LDS_FPSCR_COMPACT, && case_sem_INSN_LDS_FPSCR_COMPACT },
    { SH64_COMPACT_INSN_LDSL_FPSCR_COMPACT, && case_sem_INSN_LDSL_FPSCR_COMPACT },
    { SH64_COMPACT_INSN_LDS_FPUL_COMPACT, && case_sem_INSN_LDS_FPUL_COMPACT },
    { SH64_COMPACT_INSN_LDSL_FPUL_COMPACT, && case_sem_INSN_LDSL_FPUL_COMPACT },
    { SH64_COMPACT_INSN_LDS_MACH_COMPACT, && case_sem_INSN_LDS_MACH_COMPACT },
    { SH64_COMPACT_INSN_LDSL_MACH_COMPACT, && case_sem_INSN_LDSL_MACH_COMPACT },
    { SH64_COMPACT_INSN_LDS_MACL_COMPACT, && case_sem_INSN_LDS_MACL_COMPACT },
    { SH64_COMPACT_INSN_LDSL_MACL_COMPACT, && case_sem_INSN_LDSL_MACL_COMPACT },
    { SH64_COMPACT_INSN_LDS_PR_COMPACT, && case_sem_INSN_LDS_PR_COMPACT },
    { SH64_COMPACT_INSN_LDSL_PR_COMPACT, && case_sem_INSN_LDSL_PR_COMPACT },
    { SH64_COMPACT_INSN_MACL_COMPACT, && case_sem_INSN_MACL_COMPACT },
    { SH64_COMPACT_INSN_MACW_COMPACT, && case_sem_INSN_MACW_COMPACT },
    { SH64_COMPACT_INSN_MOV_COMPACT, && case_sem_INSN_MOV_COMPACT },
    { SH64_COMPACT_INSN_MOVI_COMPACT, && case_sem_INSN_MOVI_COMPACT },
    { SH64_COMPACT_INSN_MOVI20_COMPACT, && case_sem_INSN_MOVI20_COMPACT },
    { SH64_COMPACT_INSN_MOVB1_COMPACT, && case_sem_INSN_MOVB1_COMPACT },
    { SH64_COMPACT_INSN_MOVB2_COMPACT, && case_sem_INSN_MOVB2_COMPACT },
    { SH64_COMPACT_INSN_MOVB3_COMPACT, && case_sem_INSN_MOVB3_COMPACT },
    { SH64_COMPACT_INSN_MOVB4_COMPACT, && case_sem_INSN_MOVB4_COMPACT },
    { SH64_COMPACT_INSN_MOVB5_COMPACT, && case_sem_INSN_MOVB5_COMPACT },
    { SH64_COMPACT_INSN_MOVB6_COMPACT, && case_sem_INSN_MOVB6_COMPACT },
    { SH64_COMPACT_INSN_MOVB7_COMPACT, && case_sem_INSN_MOVB7_COMPACT },
    { SH64_COMPACT_INSN_MOVB8_COMPACT, && case_sem_INSN_MOVB8_COMPACT },
    { SH64_COMPACT_INSN_MOVB9_COMPACT, && case_sem_INSN_MOVB9_COMPACT },
    { SH64_COMPACT_INSN_MOVB10_COMPACT, && case_sem_INSN_MOVB10_COMPACT },
    { SH64_COMPACT_INSN_MOVL1_COMPACT, && case_sem_INSN_MOVL1_COMPACT },
    { SH64_COMPACT_INSN_MOVL2_COMPACT, && case_sem_INSN_MOVL2_COMPACT },
    { SH64_COMPACT_INSN_MOVL3_COMPACT, && case_sem_INSN_MOVL3_COMPACT },
    { SH64_COMPACT_INSN_MOVL4_COMPACT, && case_sem_INSN_MOVL4_COMPACT },
    { SH64_COMPACT_INSN_MOVL5_COMPACT, && case_sem_INSN_MOVL5_COMPACT },
    { SH64_COMPACT_INSN_MOVL6_COMPACT, && case_sem_INSN_MOVL6_COMPACT },
    { SH64_COMPACT_INSN_MOVL7_COMPACT, && case_sem_INSN_MOVL7_COMPACT },
    { SH64_COMPACT_INSN_MOVL8_COMPACT, && case_sem_INSN_MOVL8_COMPACT },
    { SH64_COMPACT_INSN_MOVL9_COMPACT, && case_sem_INSN_MOVL9_COMPACT },
    { SH64_COMPACT_INSN_MOVL10_COMPACT, && case_sem_INSN_MOVL10_COMPACT },
    { SH64_COMPACT_INSN_MOVL11_COMPACT, && case_sem_INSN_MOVL11_COMPACT },
    { SH64_COMPACT_INSN_MOVL12_COMPACT, && case_sem_INSN_MOVL12_COMPACT },
    { SH64_COMPACT_INSN_MOVL13_COMPACT, && case_sem_INSN_MOVL13_COMPACT },
    { SH64_COMPACT_INSN_MOVW1_COMPACT, && case_sem_INSN_MOVW1_COMPACT },
    { SH64_COMPACT_INSN_MOVW2_COMPACT, && case_sem_INSN_MOVW2_COMPACT },
    { SH64_COMPACT_INSN_MOVW3_COMPACT, && case_sem_INSN_MOVW3_COMPACT },
    { SH64_COMPACT_INSN_MOVW4_COMPACT, && case_sem_INSN_MOVW4_COMPACT },
    { SH64_COMPACT_INSN_MOVW5_COMPACT, && case_sem_INSN_MOVW5_COMPACT },
    { SH64_COMPACT_INSN_MOVW6_COMPACT, && case_sem_INSN_MOVW6_COMPACT },
    { SH64_COMPACT_INSN_MOVW7_COMPACT, && case_sem_INSN_MOVW7_COMPACT },
    { SH64_COMPACT_INSN_MOVW8_COMPACT, && case_sem_INSN_MOVW8_COMPACT },
    { SH64_COMPACT_INSN_MOVW9_COMPACT, && case_sem_INSN_MOVW9_COMPACT },
    { SH64_COMPACT_INSN_MOVW10_COMPACT, && case_sem_INSN_MOVW10_COMPACT },
    { SH64_COMPACT_INSN_MOVW11_COMPACT, && case_sem_INSN_MOVW11_COMPACT },
    { SH64_COMPACT_INSN_MOVA_COMPACT, && case_sem_INSN_MOVA_COMPACT },
    { SH64_COMPACT_INSN_MOVCAL_COMPACT, && case_sem_INSN_MOVCAL_COMPACT },
    { SH64_COMPACT_INSN_MOVCOL_COMPACT, && case_sem_INSN_MOVCOL_COMPACT },
    { SH64_COMPACT_INSN_MOVT_COMPACT, && case_sem_INSN_MOVT_COMPACT },
    { SH64_COMPACT_INSN_MOVUAL_COMPACT, && case_sem_INSN_MOVUAL_COMPACT },
    { SH64_COMPACT_INSN_MOVUAL2_COMPACT, && case_sem_INSN_MOVUAL2_COMPACT },
    { SH64_COMPACT_INSN_MULL_COMPACT, && case_sem_INSN_MULL_COMPACT },
    { SH64_COMPACT_INSN_MULSW_COMPACT, && case_sem_INSN_MULSW_COMPACT },
    { SH64_COMPACT_INSN_MULUW_COMPACT, && case_sem_INSN_MULUW_COMPACT },
    { SH64_COMPACT_INSN_NEG_COMPACT, && case_sem_INSN_NEG_COMPACT },
    { SH64_COMPACT_INSN_NEGC_COMPACT, && case_sem_INSN_NEGC_COMPACT },
    { SH64_COMPACT_INSN_NOP_COMPACT, && case_sem_INSN_NOP_COMPACT },
    { SH64_COMPACT_INSN_NOT_COMPACT, && case_sem_INSN_NOT_COMPACT },
    { SH64_COMPACT_INSN_OCBI_COMPACT, && case_sem_INSN_OCBI_COMPACT },
    { SH64_COMPACT_INSN_OCBP_COMPACT, && case_sem_INSN_OCBP_COMPACT },
    { SH64_COMPACT_INSN_OCBWB_COMPACT, && case_sem_INSN_OCBWB_COMPACT },
    { SH64_COMPACT_INSN_OR_COMPACT, && case_sem_INSN_OR_COMPACT },
    { SH64_COMPACT_INSN_ORI_COMPACT, && case_sem_INSN_ORI_COMPACT },
    { SH64_COMPACT_INSN_ORB_COMPACT, && case_sem_INSN_ORB_COMPACT },
    { SH64_COMPACT_INSN_PREF_COMPACT, && case_sem_INSN_PREF_COMPACT },
    { SH64_COMPACT_INSN_ROTCL_COMPACT, && case_sem_INSN_ROTCL_COMPACT },
    { SH64_COMPACT_INSN_ROTCR_COMPACT, && case_sem_INSN_ROTCR_COMPACT },
    { SH64_COMPACT_INSN_ROTL_COMPACT, && case_sem_INSN_ROTL_COMPACT },
    { SH64_COMPACT_INSN_ROTR_COMPACT, && case_sem_INSN_ROTR_COMPACT },
    { SH64_COMPACT_INSN_RTS_COMPACT, && case_sem_INSN_RTS_COMPACT },
    { SH64_COMPACT_INSN_SETS_COMPACT, && case_sem_INSN_SETS_COMPACT },
    { SH64_COMPACT_INSN_SETT_COMPACT, && case_sem_INSN_SETT_COMPACT },
    { SH64_COMPACT_INSN_SHAD_COMPACT, && case_sem_INSN_SHAD_COMPACT },
    { SH64_COMPACT_INSN_SHAL_COMPACT, && case_sem_INSN_SHAL_COMPACT },
    { SH64_COMPACT_INSN_SHAR_COMPACT, && case_sem_INSN_SHAR_COMPACT },
    { SH64_COMPACT_INSN_SHLD_COMPACT, && case_sem_INSN_SHLD_COMPACT },
    { SH64_COMPACT_INSN_SHLL_COMPACT, && case_sem_INSN_SHLL_COMPACT },
    { SH64_COMPACT_INSN_SHLL2_COMPACT, && case_sem_INSN_SHLL2_COMPACT },
    { SH64_COMPACT_INSN_SHLL8_COMPACT, && case_sem_INSN_SHLL8_COMPACT },
    { SH64_COMPACT_INSN_SHLL16_COMPACT, && case_sem_INSN_SHLL16_COMPACT },
    { SH64_COMPACT_INSN_SHLR_COMPACT, && case_sem_INSN_SHLR_COMPACT },
    { SH64_COMPACT_INSN_SHLR2_COMPACT, && case_sem_INSN_SHLR2_COMPACT },
    { SH64_COMPACT_INSN_SHLR8_COMPACT, && case_sem_INSN_SHLR8_COMPACT },
    { SH64_COMPACT_INSN_SHLR16_COMPACT, && case_sem_INSN_SHLR16_COMPACT },
    { SH64_COMPACT_INSN_STC_GBR_COMPACT, && case_sem_INSN_STC_GBR_COMPACT },
    { SH64_COMPACT_INSN_STC_VBR_COMPACT, && case_sem_INSN_STC_VBR_COMPACT },
    { SH64_COMPACT_INSN_STCL_GBR_COMPACT, && case_sem_INSN_STCL_GBR_COMPACT },
    { SH64_COMPACT_INSN_STCL_VBR_COMPACT, && case_sem_INSN_STCL_VBR_COMPACT },
    { SH64_COMPACT_INSN_STS_FPSCR_COMPACT, && case_sem_INSN_STS_FPSCR_COMPACT },
    { SH64_COMPACT_INSN_STSL_FPSCR_COMPACT, && case_sem_INSN_STSL_FPSCR_COMPACT },
    { SH64_COMPACT_INSN_STS_FPUL_COMPACT, && case_sem_INSN_STS_FPUL_COMPACT },
    { SH64_COMPACT_INSN_STSL_FPUL_COMPACT, && case_sem_INSN_STSL_FPUL_COMPACT },
    { SH64_COMPACT_INSN_STS_MACH_COMPACT, && case_sem_INSN_STS_MACH_COMPACT },
    { SH64_COMPACT_INSN_STSL_MACH_COMPACT, && case_sem_INSN_STSL_MACH_COMPACT },
    { SH64_COMPACT_INSN_STS_MACL_COMPACT, && case_sem_INSN_STS_MACL_COMPACT },
    { SH64_COMPACT_INSN_STSL_MACL_COMPACT, && case_sem_INSN_STSL_MACL_COMPACT },
    { SH64_COMPACT_INSN_STS_PR_COMPACT, && case_sem_INSN_STS_PR_COMPACT },
    { SH64_COMPACT_INSN_STSL_PR_COMPACT, && case_sem_INSN_STSL_PR_COMPACT },
    { SH64_COMPACT_INSN_SUB_COMPACT, && case_sem_INSN_SUB_COMPACT },
    { SH64_COMPACT_INSN_SUBC_COMPACT, && case_sem_INSN_SUBC_COMPACT },
    { SH64_COMPACT_INSN_SUBV_COMPACT, && case_sem_INSN_SUBV_COMPACT },
    { SH64_COMPACT_INSN_SWAPB_COMPACT, && case_sem_INSN_SWAPB_COMPACT },
    { SH64_COMPACT_INSN_SWAPW_COMPACT, && case_sem_INSN_SWAPW_COMPACT },
    { SH64_COMPACT_INSN_TASB_COMPACT, && case_sem_INSN_TASB_COMPACT },
    { SH64_COMPACT_INSN_TRAPA_COMPACT, && case_sem_INSN_TRAPA_COMPACT },
    { SH64_COMPACT_INSN_TST_COMPACT, && case_sem_INSN_TST_COMPACT },
    { SH64_COMPACT_INSN_TSTI_COMPACT, && case_sem_INSN_TSTI_COMPACT },
    { SH64_COMPACT_INSN_TSTB_COMPACT, && case_sem_INSN_TSTB_COMPACT },
    { SH64_COMPACT_INSN_XOR_COMPACT, && case_sem_INSN_XOR_COMPACT },
    { SH64_COMPACT_INSN_XORI_COMPACT, && case_sem_INSN_XORI_COMPACT },
    { SH64_COMPACT_INSN_XORB_COMPACT, && case_sem_INSN_XORB_COMPACT },
    { SH64_COMPACT_INSN_XTRCT_COMPACT, && case_sem_INSN_XTRCT_COMPACT },
    { 0, 0 }
  };
  int i;

  for (i = 0; labels[i].label != 0; ++i)
    {
#if FAST_P
      CPU_IDESC (current_cpu) [labels[i].index].sem_fast_lab = labels[i].label;
#else
      CPU_IDESC (current_cpu) [labels[i].index].sem_full_lab = labels[i].label;
#endif
    }

#undef DEFINE_LABELS
#endif /* DEFINE_LABELS */

#ifdef DEFINE_SWITCH

/* If hyper-fast [well not unnecessarily slow] execution is selected, turn
   off frills like tracing and profiling.  */
/* FIXME: A better way would be to have TRACE_RESULT check for something
   that can cause it to be optimized out.  Another way would be to emit
   special handlers into the instruction "stream".  */

#if FAST_P
#undef TRACE_RESULT
#define TRACE_RESULT(cpu, abuf, name, type, val)
#endif

#undef GET_ATTR
#define GET_ATTR(cpu, num, attr) CGEN_ATTR_VALUE (NULL, abuf->idesc->attrs, CGEN_INSN_##attr)

{

#if WITH_SCACHE_PBB

/* Branch to next handler without going around main loop.  */
#define NEXT(vpc) goto * SEM_ARGBUF (vpc) -> semantic.sem_case
SWITCH (sem, SEM_ARGBUF (vpc) -> semantic.sem_case)

#else /* ! WITH_SCACHE_PBB */

#define NEXT(vpc) BREAK (sem)
#ifdef __GNUC__
#if FAST_P
  SWITCH (sem, SEM_ARGBUF (sc) -> idesc->sem_fast_lab)
#else
  SWITCH (sem, SEM_ARGBUF (sc) -> idesc->sem_full_lab)
#endif
#else
  SWITCH (sem, SEM_ARGBUF (sc) -> idesc->num)
#endif

#endif /* ! WITH_SCACHE_PBB */

    {

  CASE (sem, INSN_X_INVALID) : /* --invalid-- */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_empty.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  {
    /* Update the recorded pc in the cpu state struct.
       Only necessary for WITH_SCACHE case, but to avoid the
       conditional compilation ....  */
    SET_H_PC (pc);
    /* Virtual insns have zero size.  Overwrite vpc with address of next insn
       using the default-insn-bitsize spec.  When executing insns in parallel
       we may want to queue the fault and continue execution.  */
    vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
    vpc = sim_engine_invalid_insn (current_cpu, pc, vpc);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_X_AFTER) : /* --after-- */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_empty.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  {
#if WITH_SCACHE_PBB_SH64_COMPACT
    sh64_compact_pbb_after (current_cpu, sem_arg);
#endif
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_X_BEFORE) : /* --before-- */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_empty.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  {
#if WITH_SCACHE_PBB_SH64_COMPACT
    sh64_compact_pbb_before (current_cpu, sem_arg);
#endif
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_X_CTI_CHAIN) : /* --cti-chain-- */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_empty.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  {
#if WITH_SCACHE_PBB_SH64_COMPACT
#ifdef DEFINE_SWITCH
    vpc = sh64_compact_pbb_cti_chain (current_cpu, sem_arg,
			       pbb_br_type, pbb_br_npc);
    BREAK (sem);
#else
    /* FIXME: Allow provision of explicit ifmt spec in insn spec.  */
    vpc = sh64_compact_pbb_cti_chain (current_cpu, sem_arg,
			       CPU_PBB_BR_TYPE (current_cpu),
			       CPU_PBB_BR_NPC (current_cpu));
#endif
#endif
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_X_CHAIN) : /* --chain-- */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_empty.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  {
#if WITH_SCACHE_PBB_SH64_COMPACT
    vpc = sh64_compact_pbb_chain (current_cpu, sem_arg);
#ifdef DEFINE_SWITCH
    BREAK (sem);
#endif
#endif
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_X_BEGIN) : /* --begin-- */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_empty.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  {
#if WITH_SCACHE_PBB_SH64_COMPACT
#if defined DEFINE_SWITCH || defined FAST_P
    /* In the switch case FAST_P is a constant, allowing several optimizations
       in any called inline functions.  */
    vpc = sh64_compact_pbb_begin (current_cpu, FAST_P);
#else
#if 0 /* cgen engine can't handle dynamic fast/full switching yet.  */
    vpc = sh64_compact_pbb_begin (current_cpu, STATE_RUN_FAST_P (CPU_STATE (current_cpu)));
#else
    vpc = sh64_compact_pbb_begin (current_cpu, 0);
#endif
#endif
#endif
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_ADD_COMPACT) : /* add $rm, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rn)), GET_H_GRC (FLD (f_rm)));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_ADDI_COMPACT) : /* add #$imm8, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_addi_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rn)), EXTQISI (ANDQI (FLD (f_imm8), 255)));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_ADDC_COMPACT) : /* addc $rm, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  BI tmp_flag;
  tmp_flag = ADDCFSI (GET_H_GRC (FLD (f_rn)), GET_H_GRC (FLD (f_rm)), GET_H_TBIT ());
  {
    SI opval = ADDCSI (GET_H_GRC (FLD (f_rn)), GET_H_GRC (FLD (f_rm)), GET_H_TBIT ());
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  {
    BI opval = tmp_flag;
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_ADDV_COMPACT) : /* addv $rm, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  BI tmp_t;
  tmp_t = ADDOFSI (GET_H_GRC (FLD (f_rn)), GET_H_GRC (FLD (f_rm)), 0);
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rn)), GET_H_GRC (FLD (f_rm)));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  {
    BI opval = tmp_t;
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_AND_COMPACT) : /* and $rm64, $rn64 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = ANDDI (GET_H_GR (FLD (f_rm)), GET_H_GR (FLD (f_rn)));
    SET_H_GR (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'D', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_ANDI_COMPACT) : /* and #$uimm8, r0 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_addi_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ANDSI (GET_H_GRC (((UINT) 0)), ZEXTSIDI (FLD (f_imm8)));
    SET_H_GRC (((UINT) 0), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_ANDB_COMPACT) : /* and.b #$imm8, @@(r0, gbr) */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_addi_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_addr;
  UQI tmp_data;
  tmp_addr = ADDSI (GET_H_GRC (((UINT) 0)), GET_H_GBR ());
  tmp_data = ANDQI (GETMEMUQI (current_cpu, pc, tmp_addr), FLD (f_imm8));
  {
    UQI opval = tmp_data;
    SETMEMUQI (current_cpu, pc, tmp_addr, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_BF_COMPACT) : /* bf $disp8 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_bf_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (NOTBI (GET_H_TBIT ())) {
  {
    UDI opval = FLD (i_disp8);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_BFS_COMPACT) : /* bf/s $disp8 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_bf_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (NOTBI (GET_H_TBIT ())) {
{
  {
    UDI opval = ADDDI (pc, 2);
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
((void) 0); /*nop*/
{
  {
    UDI opval = FLD (i_disp8);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
}
}
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_BRA_COMPACT) : /* bra $disp12 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_bra_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    UDI opval = ADDDI (pc, 2);
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
((void) 0); /*nop*/
{
  {
    UDI opval = FLD (i_disp12);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
}
}

  SEM_BRANCH_FINI (vpc);
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_BRAF_COMPACT) : /* braf $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    UDI opval = ADDDI (pc, 2);
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
((void) 0); /*nop*/
{
  {
    UDI opval = ADDDI (EXTSIDI (GET_H_GRC (FLD (f_rn))), ADDDI (pc, 4));
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
}
}

  SEM_BRANCH_FINI (vpc);
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_BRK_COMPACT) : /* brk */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_empty.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

sh64_break (current_cpu, pc);

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_BSR_COMPACT) : /* bsr $disp12 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_bra_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
{
  {
    SI opval = ADDDI (pc, 4);
    SET_H_PR (opval);
    TRACE_RESULT (current_cpu, abuf, "pr", 'x', opval);
  }
}
  {
    UDI opval = ADDDI (pc, 2);
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
((void) 0); /*nop*/
{
  {
    UDI opval = FLD (i_disp12);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
}
}

  SEM_BRANCH_FINI (vpc);
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_BSRF_COMPACT) : /* bsrf $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
{
  {
    SI opval = ADDDI (pc, 4);
    SET_H_PR (opval);
    TRACE_RESULT (current_cpu, abuf, "pr", 'x', opval);
  }
}
  {
    UDI opval = ADDDI (pc, 2);
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
((void) 0); /*nop*/
{
  {
    UDI opval = ADDDI (EXTSIDI (GET_H_GRC (FLD (f_rn))), ADDDI (pc, 4));
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
}
}

  SEM_BRANCH_FINI (vpc);
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_BT_COMPACT) : /* bt $disp8 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_bf_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (GET_H_TBIT ()) {
  {
    UDI opval = FLD (i_disp8);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_BTS_COMPACT) : /* bt/s $disp8 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_bf_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (GET_H_TBIT ()) {
{
  {
    UDI opval = ADDDI (pc, 2);
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
((void) 0); /*nop*/
{
  {
    UDI opval = FLD (i_disp8);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
}
}
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_CLRMAC_COMPACT) : /* clrmac */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_empty.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    SI opval = 0;
    SET_H_MACL (opval);
    TRACE_RESULT (current_cpu, abuf, "macl", 'x', opval);
  }
  {
    SI opval = 0;
    SET_H_MACH (opval);
    TRACE_RESULT (current_cpu, abuf, "mach", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_CLRS_COMPACT) : /* clrs */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_empty.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = 0;
    SET_H_SBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "sbit", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_CLRT_COMPACT) : /* clrt */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_empty.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = 0;
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_CMPEQ_COMPACT) : /* cmp/eq $rm, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = EQSI (GET_H_GRC (FLD (f_rm)), GET_H_GRC (FLD (f_rn)));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_CMPEQI_COMPACT) : /* cmp/eq #$imm8, r0 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_addi_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = EQSI (GET_H_GRC (((UINT) 0)), EXTQISI (ANDQI (FLD (f_imm8), 255)));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_CMPGE_COMPACT) : /* cmp/ge $rm, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = GESI (GET_H_GRC (FLD (f_rn)), GET_H_GRC (FLD (f_rm)));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_CMPGT_COMPACT) : /* cmp/gt $rm, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = GTSI (GET_H_GRC (FLD (f_rn)), GET_H_GRC (FLD (f_rm)));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_CMPHI_COMPACT) : /* cmp/hi $rm, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = GTUSI (GET_H_GRC (FLD (f_rn)), GET_H_GRC (FLD (f_rm)));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_CMPHS_COMPACT) : /* cmp/hs $rm, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = GEUSI (GET_H_GRC (FLD (f_rn)), GET_H_GRC (FLD (f_rm)));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_CMPPL_COMPACT) : /* cmp/pl $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = GTSI (GET_H_GRC (FLD (f_rn)), 0);
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_CMPPZ_COMPACT) : /* cmp/pz $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = GESI (GET_H_GRC (FLD (f_rn)), 0);
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_CMPSTR_COMPACT) : /* cmp/str $rm, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  BI tmp_t;
  SI tmp_temp;
  tmp_temp = XORSI (GET_H_GRC (FLD (f_rm)), GET_H_GRC (FLD (f_rn)));
  tmp_t = EQSI (ANDSI (tmp_temp, 0xff000000), 0);
  tmp_t = ORBI (EQSI (ANDSI (tmp_temp, 16711680), 0), tmp_t);
  tmp_t = ORBI (EQSI (ANDSI (tmp_temp, 65280), 0), tmp_t);
  tmp_t = ORBI (EQSI (ANDSI (tmp_temp, 255), 0), tmp_t);
  {
    BI opval = ((GTUBI (tmp_t, 0)) ? (1) : (0));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_DIV0S_COMPACT) : /* div0s $rm, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    BI opval = SRLSI (GET_H_GRC (FLD (f_rn)), 31);
    SET_H_QBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "qbit", 'x', opval);
  }
  {
    BI opval = SRLSI (GET_H_GRC (FLD (f_rm)), 31);
    SET_H_MBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "mbit", 'x', opval);
  }
  {
    BI opval = ((EQSI (SRLSI (GET_H_GRC (FLD (f_rm)), 31), SRLSI (GET_H_GRC (FLD (f_rn)), 31))) ? (0) : (1));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_DIV0U_COMPACT) : /* div0u */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_empty.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    BI opval = 0;
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
  {
    BI opval = 0;
    SET_H_QBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "qbit", 'x', opval);
  }
  {
    BI opval = 0;
    SET_H_MBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "mbit", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_DIV1_COMPACT) : /* div1 $rm, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  BI tmp_oldq;
  SI tmp_tmp0;
  UQI tmp_tmp1;
  tmp_oldq = GET_H_QBIT ();
  {
    BI opval = SRLSI (GET_H_GRC (FLD (f_rn)), 31);
    SET_H_QBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "qbit", 'x', opval);
  }
  {
    SI opval = ORSI (SLLSI (GET_H_GRC (FLD (f_rn)), 1), ZEXTBISI (GET_H_TBIT ()));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
if (NOTBI (tmp_oldq)) {
if (NOTBI (GET_H_MBIT ())) {
{
  tmp_tmp0 = GET_H_GRC (FLD (f_rn));
  {
    SI opval = SUBSI (GET_H_GRC (FLD (f_rn)), GET_H_GRC (FLD (f_rm)));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  tmp_tmp1 = GTUSI (GET_H_GRC (FLD (f_rn)), tmp_tmp0);
if (NOTBI (GET_H_QBIT ())) {
  {
    BI opval = ((tmp_tmp1) ? (1) : (0));
    SET_H_QBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "qbit", 'x', opval);
  }
} else {
  {
    BI opval = ((EQQI (tmp_tmp1, 0)) ? (1) : (0));
    SET_H_QBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "qbit", 'x', opval);
  }
}
}
} else {
{
  tmp_tmp0 = GET_H_GRC (FLD (f_rn));
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rn)), GET_H_GRC (FLD (f_rm)));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  tmp_tmp1 = LTUSI (GET_H_GRC (FLD (f_rn)), tmp_tmp0);
if (NOTBI (GET_H_QBIT ())) {
  {
    BI opval = ((EQQI (tmp_tmp1, 0)) ? (1) : (0));
    SET_H_QBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "qbit", 'x', opval);
  }
} else {
  {
    BI opval = ((tmp_tmp1) ? (1) : (0));
    SET_H_QBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "qbit", 'x', opval);
  }
}
}
}
} else {
if (NOTBI (GET_H_MBIT ())) {
{
  tmp_tmp0 = GET_H_GRC (FLD (f_rn));
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rm)), GET_H_GRC (FLD (f_rn)));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  tmp_tmp1 = LTUSI (GET_H_GRC (FLD (f_rn)), tmp_tmp0);
if (NOTBI (GET_H_QBIT ())) {
  {
    BI opval = ((tmp_tmp1) ? (1) : (0));
    SET_H_QBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "qbit", 'x', opval);
  }
} else {
  {
    BI opval = ((EQQI (tmp_tmp1, 0)) ? (1) : (0));
    SET_H_QBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "qbit", 'x', opval);
  }
}
}
} else {
{
  tmp_tmp0 = GET_H_GRC (FLD (f_rn));
  {
    SI opval = SUBSI (GET_H_GRC (FLD (f_rn)), GET_H_GRC (FLD (f_rm)));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  tmp_tmp1 = GTUSI (GET_H_GRC (FLD (f_rn)), tmp_tmp0);
if (NOTBI (GET_H_QBIT ())) {
  {
    BI opval = ((EQQI (tmp_tmp1, 0)) ? (1) : (0));
    SET_H_QBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "qbit", 'x', opval);
  }
} else {
  {
    BI opval = ((tmp_tmp1) ? (1) : (0));
    SET_H_QBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "qbit", 'x', opval);
  }
}
}
}
}
  {
    BI opval = ((EQBI (GET_H_QBIT (), GET_H_MBIT ())) ? (1) : (0));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_DIVU_COMPACT) : /* divu r0, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = UDIVSI (GET_H_GRC (FLD (f_rn)), GET_H_GRC (((UINT) 0)));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MULR_COMPACT) : /* mulr r0, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = MULSI (GET_H_GRC (FLD (f_rn)), GET_H_GRC (((UINT) 0)));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_DMULSL_COMPACT) : /* dmuls.l $rm, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_result;
  tmp_result = MULDI (EXTSIDI (GET_H_GRC (FLD (f_rm))), EXTSIDI (GET_H_GRC (FLD (f_rn))));
  {
    SI opval = SUBWORDDISI (tmp_result, 0);
    SET_H_MACH (opval);
    TRACE_RESULT (current_cpu, abuf, "mach", 'x', opval);
  }
  {
    SI opval = SUBWORDDISI (tmp_result, 1);
    SET_H_MACL (opval);
    TRACE_RESULT (current_cpu, abuf, "macl", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_DMULUL_COMPACT) : /* dmulu.l $rm, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_result;
  tmp_result = MULDI (ZEXTSIDI (GET_H_GRC (FLD (f_rm))), ZEXTSIDI (GET_H_GRC (FLD (f_rn))));
  {
    SI opval = SUBWORDDISI (tmp_result, 0);
    SET_H_MACH (opval);
    TRACE_RESULT (current_cpu, abuf, "mach", 'x', opval);
  }
  {
    SI opval = SUBWORDDISI (tmp_result, 1);
    SET_H_MACL (opval);
    TRACE_RESULT (current_cpu, abuf, "macl", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_DT_COMPACT) : /* dt $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    SI opval = SUBSI (GET_H_GRC (FLD (f_rn)), 1);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  {
    BI opval = EQSI (GET_H_GRC (FLD (f_rn)), 0);
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_EXTSB_COMPACT) : /* exts.b $rm, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = EXTQISI (SUBWORDSIQI (GET_H_GRC (FLD (f_rm)), 3));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_EXTSW_COMPACT) : /* exts.w $rm, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = EXTHISI (SUBWORDSIHI (GET_H_GRC (FLD (f_rm)), 1));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_EXTUB_COMPACT) : /* extu.b $rm, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ZEXTQISI (SUBWORDSIQI (GET_H_GRC (FLD (f_rm)), 3));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_EXTUW_COMPACT) : /* extu.w $rm, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ZEXTHISI (SUBWORDSIHI (GET_H_GRC (FLD (f_rm)), 1));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_FABS_COMPACT) : /* fabs $fsdn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (GET_H_PRBIT ()) {
  {
    DF opval = sh64_fabsd (current_cpu, GET_H_FSD (FLD (f_rn)));
    SET_H_FSD (FLD (f_rn), opval);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "fsd", 'f', opval);
  }
} else {
  {
    DF opval = sh64_fabss (current_cpu, GET_H_FSD (FLD (f_rn)));
    SET_H_FSD (FLD (f_rn), opval);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "fsd", 'f', opval);
  }
}

  abuf->written = written;
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_FADD_COMPACT) : /* fadd $fsdm, $fsdn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (GET_H_PRBIT ()) {
  {
    DF opval = sh64_faddd (current_cpu, GET_H_FSD (FLD (f_rm)), GET_H_FSD (FLD (f_rn)));
    SET_H_FSD (FLD (f_rn), opval);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "fsd", 'f', opval);
  }
} else {
  {
    DF opval = sh64_fadds (current_cpu, GET_H_FSD (FLD (f_rm)), GET_H_FSD (FLD (f_rn)));
    SET_H_FSD (FLD (f_rn), opval);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "fsd", 'f', opval);
  }
}

  abuf->written = written;
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_FCMPEQ_COMPACT) : /* fcmp/eq $fsdm, $fsdn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (GET_H_PRBIT ()) {
  {
    BI opval = sh64_fcmpeqd (current_cpu, GET_H_FSD (FLD (f_rm)), GET_H_FSD (FLD (f_rn)));
    SET_H_TBIT (opval);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
} else {
  {
    BI opval = sh64_fcmpeqs (current_cpu, GET_H_FSD (FLD (f_rm)), GET_H_FSD (FLD (f_rn)));
    SET_H_TBIT (opval);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

  abuf->written = written;
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_FCMPGT_COMPACT) : /* fcmp/gt $fsdm, $fsdn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (GET_H_PRBIT ()) {
  {
    BI opval = sh64_fcmpgtd (current_cpu, GET_H_FSD (FLD (f_rn)), GET_H_FSD (FLD (f_rm)));
    SET_H_TBIT (opval);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
} else {
  {
    BI opval = sh64_fcmpgts (current_cpu, GET_H_FSD (FLD (f_rn)), GET_H_FSD (FLD (f_rm)));
    SET_H_TBIT (opval);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

  abuf->written = written;
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_FCNVDS_COMPACT) : /* fcnvds $drn, fpul */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_fmov8_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SF opval = sh64_fcnvds (current_cpu, GET_H_DRC (FLD (f_dn)));
    CPU (h_fr[((UINT) 32)]) = opval;
    TRACE_RESULT (current_cpu, abuf, "fr", 'f', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_FCNVSD_COMPACT) : /* fcnvsd fpul, $drn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_fmov8_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DF opval = sh64_fcnvsd (current_cpu, CPU (h_fr[((UINT) 32)]));
    SET_H_DRC (FLD (f_dn), opval);
    TRACE_RESULT (current_cpu, abuf, "drc", 'f', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_FDIV_COMPACT) : /* fdiv $fsdm, $fsdn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (GET_H_PRBIT ()) {
  {
    DF opval = sh64_fdivd (current_cpu, GET_H_FSD (FLD (f_rn)), GET_H_FSD (FLD (f_rm)));
    SET_H_FSD (FLD (f_rn), opval);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "fsd", 'f', opval);
  }
} else {
  {
    DF opval = sh64_fdivs (current_cpu, GET_H_FSD (FLD (f_rn)), GET_H_FSD (FLD (f_rm)));
    SET_H_FSD (FLD (f_rn), opval);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "fsd", 'f', opval);
  }
}

  abuf->written = written;
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_FIPR_COMPACT) : /* fipr $fvm, $fvn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_fipr_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

sh64_fipr (current_cpu, FLD (f_vm), FLD (f_vn));

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_FLDS_COMPACT) : /* flds $frn, fpul */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SF opval = GET_H_FRC (FLD (f_rn));
    CPU (h_fr[((UINT) 32)]) = opval;
    TRACE_RESULT (current_cpu, abuf, "fr", 'f', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_FLDI0_COMPACT) : /* fldi0 $frn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SF opval = sh64_fldi0 (current_cpu);
    SET_H_FRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "frc", 'f', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_FLDI1_COMPACT) : /* fldi1 $frn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SF opval = sh64_fldi1 (current_cpu);
    SET_H_FRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "frc", 'f', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_FLOAT_COMPACT) : /* float fpul, $fsdn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (GET_H_PRBIT ()) {
  {
    DF opval = sh64_floatld (current_cpu, CPU (h_fr[((UINT) 32)]));
    SET_H_FSD (FLD (f_rn), opval);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "fsd", 'f', opval);
  }
} else {
  {
    DF opval = sh64_floatls (current_cpu, CPU (h_fr[((UINT) 32)]));
    SET_H_FSD (FLD (f_rn), opval);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "fsd", 'f', opval);
  }
}

  abuf->written = written;
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_FMAC_COMPACT) : /* fmac fr0, $frm, $frn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SF opval = sh64_fmacs (current_cpu, GET_H_FRC (((UINT) 0)), GET_H_FRC (FLD (f_rm)), GET_H_FRC (FLD (f_rn)));
    SET_H_FRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "frc", 'f', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_FMOV1_COMPACT) : /* fmov $fmovm, $fmovn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DF opval = GET_H_FMOV (FLD (f_rm));
    SET_H_FMOV (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "fmov", 'f', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_FMOV2_COMPACT) : /* fmov @@$rm, $fmovn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (NOTBI (GET_H_SZBIT ())) {
  {
    DF opval = GETMEMSF (current_cpu, pc, GET_H_GRC (FLD (f_rm)));
    SET_H_FMOV (FLD (f_rn), opval);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "fmov", 'f', opval);
  }
} else {
  {
    DF opval = GETMEMDF (current_cpu, pc, GET_H_GRC (FLD (f_rm)));
    SET_H_FMOV (FLD (f_rn), opval);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "fmov", 'f', opval);
  }
}

  abuf->written = written;
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_FMOV3_COMPACT) : /* fmov @@${rm}+, fmovn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (NOTBI (GET_H_SZBIT ())) {
{
  {
    DF opval = GETMEMSF (current_cpu, pc, GET_H_GRC (FLD (f_rm)));
    SET_H_FMOV (FLD (f_rn), opval);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "fmov", 'f', opval);
  }
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rm)), 4);
    SET_H_GRC (FLD (f_rm), opval);
    written |= (1 << 5);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}
} else {
{
  {
    DF opval = GETMEMDF (current_cpu, pc, GET_H_GRC (FLD (f_rm)));
    SET_H_FMOV (FLD (f_rn), opval);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "fmov", 'f', opval);
  }
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rm)), 8);
    SET_H_GRC (FLD (f_rm), opval);
    written |= (1 << 5);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}
}

  abuf->written = written;
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_FMOV4_COMPACT) : /* fmov @@(r0, $rm), $fmovn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (NOTBI (GET_H_SZBIT ())) {
  {
    DF opval = GETMEMSF (current_cpu, pc, ADDSI (GET_H_GRC (((UINT) 0)), GET_H_GRC (FLD (f_rm))));
    SET_H_FMOV (FLD (f_rn), opval);
    written |= (1 << 5);
    TRACE_RESULT (current_cpu, abuf, "fmov", 'f', opval);
  }
} else {
  {
    DF opval = GETMEMDF (current_cpu, pc, ADDSI (GET_H_GRC (((UINT) 0)), GET_H_GRC (FLD (f_rm))));
    SET_H_FMOV (FLD (f_rn), opval);
    written |= (1 << 5);
    TRACE_RESULT (current_cpu, abuf, "fmov", 'f', opval);
  }
}

  abuf->written = written;
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_FMOV5_COMPACT) : /* fmov $fmovm, @@$rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (NOTBI (GET_H_SZBIT ())) {
  {
    SF opval = GET_H_FMOV (FLD (f_rm));
    SETMEMSF (current_cpu, pc, GET_H_GRC (FLD (f_rn)), opval);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "memory", 'f', opval);
  }
} else {
  {
    DF opval = GET_H_FMOV (FLD (f_rm));
    SETMEMDF (current_cpu, pc, GET_H_GRC (FLD (f_rn)), opval);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "memory", 'f', opval);
  }
}

  abuf->written = written;
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_FMOV6_COMPACT) : /* fmov $fmovm, @@-$rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (NOTBI (GET_H_SZBIT ())) {
{
  {
    SI opval = SUBSI (GET_H_GRC (FLD (f_rn)), 4);
    SET_H_GRC (FLD (f_rn), opval);
    written |= (1 << 5);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  {
    SF opval = GET_H_FMOV (FLD (f_rm));
    SETMEMSF (current_cpu, pc, GET_H_GRC (FLD (f_rn)), opval);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "memory", 'f', opval);
  }
}
} else {
{
  {
    SI opval = SUBSI (GET_H_GRC (FLD (f_rn)), 8);
    SET_H_GRC (FLD (f_rn), opval);
    written |= (1 << 5);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  {
    DF opval = GET_H_FMOV (FLD (f_rm));
    SETMEMDF (current_cpu, pc, GET_H_GRC (FLD (f_rn)), opval);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "memory", 'f', opval);
  }
}
}

  abuf->written = written;
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_FMOV7_COMPACT) : /* fmov $fmovm, @@(r0, $rn) */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (NOTBI (GET_H_SZBIT ())) {
  {
    SF opval = GET_H_FMOV (FLD (f_rm));
    SETMEMSF (current_cpu, pc, ADDSI (GET_H_GRC (((UINT) 0)), GET_H_GRC (FLD (f_rn))), opval);
    written |= (1 << 5);
    TRACE_RESULT (current_cpu, abuf, "memory", 'f', opval);
  }
} else {
  {
    DF opval = GET_H_FMOV (FLD (f_rm));
    SETMEMDF (current_cpu, pc, ADDSI (GET_H_GRC (((UINT) 0)), GET_H_GRC (FLD (f_rn))), opval);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "memory", 'f', opval);
  }
}

  abuf->written = written;
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_FMOV8_COMPACT) : /* fmov.d @@($imm12x8, $rm), $drn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_fmov8_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    DF opval = GETMEMDF (current_cpu, pc, ADDSI (GET_H_GRC (FLD (f_rm)), FLD (f_imm12x8)));
    SET_H_DRC (FLD (f_dn), opval);
    TRACE_RESULT (current_cpu, abuf, "drc", 'f', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_FMOV9_COMPACT) : /* mov.l $drm, @@($imm12x8, $rn) */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_fmov9_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    DF opval = GET_H_DRC (FLD (f_dm));
    SETMEMDF (current_cpu, pc, ADDSI (GET_H_GRC (FLD (f_rn)), FLD (f_imm12x8)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'f', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_FMUL_COMPACT) : /* fmul $fsdm, $fsdn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (GET_H_PRBIT ()) {
  {
    DF opval = sh64_fmuld (current_cpu, GET_H_FSD (FLD (f_rm)), GET_H_FSD (FLD (f_rn)));
    SET_H_FSD (FLD (f_rn), opval);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "fsd", 'f', opval);
  }
} else {
  {
    DF opval = sh64_fmuls (current_cpu, GET_H_FSD (FLD (f_rm)), GET_H_FSD (FLD (f_rn)));
    SET_H_FSD (FLD (f_rn), opval);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "fsd", 'f', opval);
  }
}

  abuf->written = written;
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_FNEG_COMPACT) : /* fneg $fsdn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (GET_H_PRBIT ()) {
  {
    DF opval = sh64_fnegd (current_cpu, GET_H_FSD (FLD (f_rn)));
    SET_H_FSD (FLD (f_rn), opval);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "fsd", 'f', opval);
  }
} else {
  {
    DF opval = sh64_fnegs (current_cpu, GET_H_FSD (FLD (f_rn)));
    SET_H_FSD (FLD (f_rn), opval);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "fsd", 'f', opval);
  }
}

  abuf->written = written;
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_FRCHG_COMPACT) : /* frchg */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_empty.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = NOTBI (GET_H_FRBIT ());
    SET_H_FRBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "frbit", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_FSCHG_COMPACT) : /* fschg */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_empty.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = NOTBI (GET_H_SZBIT ());
    SET_H_SZBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "szbit", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_FSQRT_COMPACT) : /* fsqrt $fsdn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (GET_H_PRBIT ()) {
  {
    DF opval = sh64_fsqrtd (current_cpu, GET_H_FSD (FLD (f_rn)));
    SET_H_FSD (FLD (f_rn), opval);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "fsd", 'f', opval);
  }
} else {
  {
    DF opval = sh64_fsqrts (current_cpu, GET_H_FSD (FLD (f_rn)));
    SET_H_FSD (FLD (f_rn), opval);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "fsd", 'f', opval);
  }
}

  abuf->written = written;
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_FSTS_COMPACT) : /* fsts fpul, $frn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SF opval = CPU (h_fr[((UINT) 32)]);
    SET_H_FRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "frc", 'f', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_FSUB_COMPACT) : /* fsub $fsdm, $fsdn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (GET_H_PRBIT ()) {
  {
    DF opval = sh64_fsubd (current_cpu, GET_H_FSD (FLD (f_rn)), GET_H_FSD (FLD (f_rm)));
    SET_H_FSD (FLD (f_rn), opval);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "fsd", 'f', opval);
  }
} else {
  {
    DF opval = sh64_fsubs (current_cpu, GET_H_FSD (FLD (f_rn)), GET_H_FSD (FLD (f_rm)));
    SET_H_FSD (FLD (f_rn), opval);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "fsd", 'f', opval);
  }
}

  abuf->written = written;
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_FTRC_COMPACT) : /* ftrc $fsdn, fpul */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SF opval = ((GET_H_PRBIT ()) ? (sh64_ftrcdl (current_cpu, GET_H_FSD (FLD (f_rn)))) : (sh64_ftrcsl (current_cpu, GET_H_FSD (FLD (f_rn)))));
    CPU (h_fr[((UINT) 32)]) = opval;
    TRACE_RESULT (current_cpu, abuf, "fr", 'f', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_FTRV_COMPACT) : /* ftrv xmtrx, $fvn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_fipr_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

sh64_ftrv (current_cpu, FLD (f_vn));

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_JMP_COMPACT) : /* jmp @@$rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    UDI opval = ADDDI (pc, 2);
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
((void) 0); /*nop*/
{
  {
    UDI opval = GET_H_GRC (FLD (f_rn));
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
}
((void) 0); /*nop*/
}

  SEM_BRANCH_FINI (vpc);
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_JSR_COMPACT) : /* jsr @@$rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
{
  {
    SI opval = ADDDI (pc, 4);
    SET_H_PR (opval);
    TRACE_RESULT (current_cpu, abuf, "pr", 'x', opval);
  }
}
  {
    UDI opval = ADDDI (pc, 2);
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
((void) 0); /*nop*/
{
  {
    UDI opval = GET_H_GRC (FLD (f_rn));
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
}
((void) 0); /*nop*/
}

  SEM_BRANCH_FINI (vpc);
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_LDC_GBR_COMPACT) : /* ldc $rn, gbr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_GRC (FLD (f_rn));
    SET_H_GBR (opval);
    TRACE_RESULT (current_cpu, abuf, "gbr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_LDC_VBR_COMPACT) : /* ldc $rn, vbr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_GRC (FLD (f_rn));
    SET_H_VBR (opval);
    TRACE_RESULT (current_cpu, abuf, "vbr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_LDC_SR_COMPACT) : /* ldc $rn, sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_GRC (FLD (f_rn));
    CPU (h_sr) = opval;
    TRACE_RESULT (current_cpu, abuf, "sr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_LDCL_GBR_COMPACT) : /* ldc.l @@${rn}+, gbr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    SI opval = GETMEMSI (current_cpu, pc, GET_H_GRC (FLD (f_rn)));
    SET_H_GBR (opval);
    TRACE_RESULT (current_cpu, abuf, "gbr", 'x', opval);
  }
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rn)), 4);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_LDCL_VBR_COMPACT) : /* ldc.l @@${rn}+, vbr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    SI opval = GETMEMSI (current_cpu, pc, GET_H_GRC (FLD (f_rn)));
    SET_H_VBR (opval);
    TRACE_RESULT (current_cpu, abuf, "vbr", 'x', opval);
  }
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rn)), 4);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_LDS_FPSCR_COMPACT) : /* lds $rn, fpscr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_GRC (FLD (f_rn));
    CPU (h_fpscr) = opval;
    TRACE_RESULT (current_cpu, abuf, "fpscr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_LDSL_FPSCR_COMPACT) : /* lds.l @@${rn}+, fpscr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    SI opval = GETMEMSI (current_cpu, pc, GET_H_GRC (FLD (f_rn)));
    CPU (h_fpscr) = opval;
    TRACE_RESULT (current_cpu, abuf, "fpscr", 'x', opval);
  }
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rn)), 4);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_LDS_FPUL_COMPACT) : /* lds $rn, fpul */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SF opval = SUBWORDSISF (GET_H_GRC (FLD (f_rn)));
    CPU (h_fr[((UINT) 32)]) = opval;
    TRACE_RESULT (current_cpu, abuf, "fr", 'f', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_LDSL_FPUL_COMPACT) : /* lds.l @@${rn}+, fpul */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    SF opval = GETMEMSF (current_cpu, pc, GET_H_GRC (FLD (f_rn)));
    CPU (h_fr[((UINT) 32)]) = opval;
    TRACE_RESULT (current_cpu, abuf, "fr", 'f', opval);
  }
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rn)), 4);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_LDS_MACH_COMPACT) : /* lds $rn, mach */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_GRC (FLD (f_rn));
    SET_H_MACH (opval);
    TRACE_RESULT (current_cpu, abuf, "mach", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_LDSL_MACH_COMPACT) : /* lds.l @@${rn}+, mach */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    SI opval = GETMEMSI (current_cpu, pc, GET_H_GRC (FLD (f_rn)));
    SET_H_MACH (opval);
    TRACE_RESULT (current_cpu, abuf, "mach", 'x', opval);
  }
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rn)), 4);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_LDS_MACL_COMPACT) : /* lds $rn, macl */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_GRC (FLD (f_rn));
    SET_H_MACL (opval);
    TRACE_RESULT (current_cpu, abuf, "macl", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_LDSL_MACL_COMPACT) : /* lds.l @@${rn}+, macl */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    SI opval = GETMEMSI (current_cpu, pc, GET_H_GRC (FLD (f_rn)));
    SET_H_MACL (opval);
    TRACE_RESULT (current_cpu, abuf, "macl", 'x', opval);
  }
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rn)), 4);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_LDS_PR_COMPACT) : /* lds $rn, pr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_GRC (FLD (f_rn));
    SET_H_PR (opval);
    TRACE_RESULT (current_cpu, abuf, "pr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_LDSL_PR_COMPACT) : /* lds.l @@${rn}+, pr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    SI opval = GETMEMSI (current_cpu, pc, GET_H_GRC (FLD (f_rn)));
    SET_H_PR (opval);
    TRACE_RESULT (current_cpu, abuf, "pr", 'x', opval);
  }
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rn)), 4);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MACL_COMPACT) : /* mac.l @@${rm}+, @@${rn}+ */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_tmpry;
  DI tmp_mac;
  DI tmp_result;
  SI tmp_x;
  SI tmp_y;
  tmp_x = GETMEMSI (current_cpu, pc, GET_H_GRC (FLD (f_rn)));
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rn)), 4);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
if (EQSI (FLD (f_rn), FLD (f_rm))) {
{
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rn)), 4);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rm)), 4);
    SET_H_GRC (FLD (f_rm), opval);
    written |= (1 << 11);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}
}
  tmp_y = GETMEMSI (current_cpu, pc, GET_H_GRC (FLD (f_rm)));
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rm)), 4);
    SET_H_GRC (FLD (f_rm), opval);
    written |= (1 << 11);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  tmp_tmpry = MULDI (ZEXTSIDI (tmp_x), ZEXTSIDI (tmp_y));
  tmp_mac = ORDI (SLLDI (ZEXTSIDI (GET_H_MACH ()), 32), ZEXTSIDI (GET_H_MACL ()));
  tmp_result = ADDDI (tmp_mac, tmp_tmpry);
{
if (GET_H_SBIT ()) {
{
  SI tmp_min;
  SI tmp_max;
  tmp_max = SRLDI (INVDI (0), 16);
  tmp_min = SRLDI (INVDI (0), 15);
if (GTDI (tmp_result, tmp_max)) {
  tmp_result = tmp_max;
} else {
if (LTDI (tmp_result, tmp_min)) {
  tmp_result = tmp_min;
}
}
}
}
  {
    SI opval = SUBWORDDISI (tmp_result, 0);
    SET_H_MACH (opval);
    TRACE_RESULT (current_cpu, abuf, "mach", 'x', opval);
  }
  {
    SI opval = SUBWORDDISI (tmp_result, 1);
    SET_H_MACL (opval);
    TRACE_RESULT (current_cpu, abuf, "macl", 'x', opval);
  }
}
}

  abuf->written = written;
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MACW_COMPACT) : /* mac.w @@${rm}+, @@${rn}+ */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  SI tmp_tmpry;
  DI tmp_mac;
  DI tmp_result;
  HI tmp_x;
  HI tmp_y;
  tmp_x = GETMEMHI (current_cpu, pc, GET_H_GRC (FLD (f_rn)));
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rn)), 2);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
if (EQSI (FLD (f_rn), FLD (f_rm))) {
{
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rn)), 2);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rm)), 2);
    SET_H_GRC (FLD (f_rm), opval);
    written |= (1 << 11);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}
}
  tmp_y = GETMEMHI (current_cpu, pc, GET_H_GRC (FLD (f_rm)));
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rm)), 2);
    SET_H_GRC (FLD (f_rm), opval);
    written |= (1 << 11);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  tmp_tmpry = MULSI (ZEXTHISI (tmp_x), ZEXTHISI (tmp_y));
if (GET_H_SBIT ()) {
{
if (ADDOFSI (tmp_tmpry, GET_H_MACL (), 0)) {
  {
    SI opval = 1;
    SET_H_MACH (opval);
    written |= (1 << 9);
    TRACE_RESULT (current_cpu, abuf, "mach", 'x', opval);
  }
}
  {
    SI opval = ADDSI (tmp_tmpry, GET_H_MACL ());
    SET_H_MACL (opval);
    written |= (1 << 10);
    TRACE_RESULT (current_cpu, abuf, "macl", 'x', opval);
  }
}
} else {
{
  tmp_mac = ORDI (SLLDI (ZEXTSIDI (GET_H_MACH ()), 32), ZEXTSIDI (GET_H_MACL ()));
  tmp_result = ADDDI (tmp_mac, EXTSIDI (tmp_tmpry));
  {
    SI opval = SUBWORDDISI (tmp_result, 0);
    SET_H_MACH (opval);
    written |= (1 << 9);
    TRACE_RESULT (current_cpu, abuf, "mach", 'x', opval);
  }
  {
    SI opval = SUBWORDDISI (tmp_result, 1);
    SET_H_MACL (opval);
    written |= (1 << 10);
    TRACE_RESULT (current_cpu, abuf, "macl", 'x', opval);
  }
}
}
}

  abuf->written = written;
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOV_COMPACT) : /* mov $rm64, $rn64 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = GET_H_GR (FLD (f_rm));
    SET_H_GR (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'D', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVI_COMPACT) : /* mov #$imm8, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_addi_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = EXTQIDI (ANDQI (FLD (f_imm8), 255));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVI20_COMPACT) : /* movi20 #$imm20, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movi20_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = FLD (f_imm20);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVB1_COMPACT) : /* mov.b $rm, @@$rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    UQI opval = SUBWORDSIUQI (GET_H_GRC (FLD (f_rm)), 3);
    SETMEMUQI (current_cpu, pc, GET_H_GRC (FLD (f_rn)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVB2_COMPACT) : /* mov.b $rm, @@-$rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_addr;
  tmp_addr = SUBSI (GET_H_GRC (FLD (f_rn)), 1);
  {
    UQI opval = SUBWORDSIUQI (GET_H_GRC (FLD (f_rm)), 3);
    SETMEMUQI (current_cpu, pc, tmp_addr, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
  {
    SI opval = tmp_addr;
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVB3_COMPACT) : /* mov.b $rm, @@(r0,$rn) */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    UQI opval = SUBWORDSIUQI (GET_H_GRC (FLD (f_rm)), 3);
    SETMEMUQI (current_cpu, pc, ADDSI (GET_H_GRC (((UINT) 0)), GET_H_GRC (FLD (f_rn))), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVB4_COMPACT) : /* mov.b r0, @@($imm8, gbr) */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_addi_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_addr;
  tmp_addr = ADDSI (GET_H_GBR (), FLD (f_imm8));
  {
    UQI opval = SUBWORDSIUQI (GET_H_GRC (((UINT) 0)), 3);
    SETMEMUQI (current_cpu, pc, tmp_addr, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVB5_COMPACT) : /* mov.b r0, @@($imm4, $rm) */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movb5_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_addr;
  tmp_addr = ADDSI (GET_H_GRC (FLD (f_rm)), FLD (f_imm4));
  {
    UQI opval = SUBWORDSIUQI (GET_H_GRC (((UINT) 0)), 3);
    SETMEMUQI (current_cpu, pc, tmp_addr, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVB6_COMPACT) : /* mov.b @@$rm, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = EXTQISI (GETMEMQI (current_cpu, pc, GET_H_GRC (FLD (f_rm))));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVB7_COMPACT) : /* mov.b @@${rm}+, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  QI tmp_data;
  tmp_data = GETMEMQI (current_cpu, pc, GET_H_GRC (FLD (f_rm)));
if (EQSI (FLD (f_rm), FLD (f_rn))) {
  {
    SI opval = EXTQISI (tmp_data);
    SET_H_GRC (FLD (f_rm), opval);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
} else {
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rm)), 1);
    SET_H_GRC (FLD (f_rm), opval);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}
  {
    SI opval = EXTQISI (tmp_data);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

  abuf->written = written;
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVB8_COMPACT) : /* mov.b @@(r0, $rm), $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = EXTQISI (GETMEMQI (current_cpu, pc, ADDSI (GET_H_GRC (((UINT) 0)), GET_H_GRC (FLD (f_rm)))));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVB9_COMPACT) : /* mov.b @@($imm8, gbr), r0 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_addi_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = EXTQISI (GETMEMQI (current_cpu, pc, ADDSI (GET_H_GBR (), FLD (f_imm8))));
    SET_H_GRC (((UINT) 0), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVB10_COMPACT) : /* mov.b @@($imm4, $rm), r0 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movb5_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = EXTQISI (GETMEMQI (current_cpu, pc, ADDSI (GET_H_GRC (FLD (f_rm)), FLD (f_imm4))));
    SET_H_GRC (((UINT) 0), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVL1_COMPACT) : /* mov.l $rm, @@$rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_GRC (FLD (f_rm));
    SETMEMSI (current_cpu, pc, GET_H_GRC (FLD (f_rn)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVL2_COMPACT) : /* mov.l $rm, @@-$rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  SI tmp_addr;
  tmp_addr = SUBSI (GET_H_GRC (FLD (f_rn)), 4);
  {
    SI opval = GET_H_GRC (FLD (f_rm));
    SETMEMSI (current_cpu, pc, tmp_addr, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
  {
    SI opval = tmp_addr;
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVL3_COMPACT) : /* mov.l $rm, @@(r0, $rn) */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_GRC (FLD (f_rm));
    SETMEMSI (current_cpu, pc, ADDSI (GET_H_GRC (((UINT) 0)), GET_H_GRC (FLD (f_rn))), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVL4_COMPACT) : /* mov.l r0, @@($imm8x4, gbr) */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_GRC (((UINT) 0));
    SETMEMSI (current_cpu, pc, ADDSI (GET_H_GBR (), FLD (f_imm8x4)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVL5_COMPACT) : /* mov.l $rm, @@($imm4x4, $rn) */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_GRC (FLD (f_rm));
    SETMEMSI (current_cpu, pc, ADDSI (GET_H_GRC (FLD (f_rn)), FLD (f_imm4x4)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVL6_COMPACT) : /* mov.l @@$rm, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GETMEMSI (current_cpu, pc, GET_H_GRC (FLD (f_rm)));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVL7_COMPACT) : /* mov.l @@${rm}+, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    SI opval = GETMEMSI (current_cpu, pc, GET_H_GRC (FLD (f_rm)));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
if (EQSI (FLD (f_rm), FLD (f_rn))) {
  {
    SI opval = GET_H_GRC (FLD (f_rn));
    SET_H_GRC (FLD (f_rm), opval);
    written |= (1 << 5);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
} else {
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rm)), 4);
    SET_H_GRC (FLD (f_rm), opval);
    written |= (1 << 5);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}
}

  abuf->written = written;
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVL8_COMPACT) : /* mov.l @@(r0, $rm), $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GETMEMSI (current_cpu, pc, ADDSI (GET_H_GRC (((UINT) 0)), GET_H_GRC (FLD (f_rm))));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVL9_COMPACT) : /* mov.l @@($imm8x4, gbr), r0 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GETMEMSI (current_cpu, pc, ADDSI (GET_H_GBR (), FLD (f_imm8x4)));
    SET_H_GRC (((UINT) 0), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVL10_COMPACT) : /* mov.l @@($imm8x4, pc), $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GETMEMSI (current_cpu, pc, ADDSI (FLD (f_imm8x4), ANDDI (ADDDI (pc, 4), INVSI (3))));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVL11_COMPACT) : /* mov.l @@($imm4x4, $rm), $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GETMEMSI (current_cpu, pc, ADDSI (GET_H_GRC (FLD (f_rm)), FLD (f_imm4x4)));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVL12_COMPACT) : /* mov.l @@($imm12x4, $rm), $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = GETMEMSI (current_cpu, pc, ADDSI (GET_H_GRC (FLD (f_rm)), FLD (f_imm12x4)));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVL13_COMPACT) : /* mov.l $rm, @@($imm12x4, $rn) */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = GET_H_GRC (FLD (f_rm));
    SETMEMSI (current_cpu, pc, ADDSI (GET_H_GRC (FLD (f_rn)), FLD (f_imm12x4)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVW1_COMPACT) : /* mov.w $rm, @@$rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    HI opval = SUBWORDSIHI (GET_H_GRC (FLD (f_rm)), 1);
    SETMEMHI (current_cpu, pc, GET_H_GRC (FLD (f_rn)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVW2_COMPACT) : /* mov.w $rm, @@-$rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_addr;
  tmp_addr = SUBSI (GET_H_GRC (FLD (f_rn)), 2);
  {
    HI opval = SUBWORDSIHI (GET_H_GRC (FLD (f_rm)), 1);
    SETMEMHI (current_cpu, pc, tmp_addr, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
  {
    SI opval = tmp_addr;
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVW3_COMPACT) : /* mov.w $rm, @@(r0, $rn) */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    HI opval = SUBWORDSIHI (GET_H_GRC (FLD (f_rm)), 1);
    SETMEMHI (current_cpu, pc, ADDSI (GET_H_GRC (((UINT) 0)), GET_H_GRC (FLD (f_rn))), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVW4_COMPACT) : /* mov.w r0, @@($imm8x2, gbr) */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    HI opval = SUBWORDSIHI (GET_H_GRC (((UINT) 0)), 1);
    SETMEMHI (current_cpu, pc, ADDSI (GET_H_GBR (), FLD (f_imm8x2)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVW5_COMPACT) : /* mov.w r0, @@($imm4x2, $rm) */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw5_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    HI opval = SUBWORDSIHI (GET_H_GRC (((UINT) 0)), 1);
    SETMEMHI (current_cpu, pc, ADDSI (GET_H_GRC (FLD (f_rm)), FLD (f_imm4x2)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVW6_COMPACT) : /* mov.w @@$rm, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = EXTHISI (GETMEMHI (current_cpu, pc, GET_H_GRC (FLD (f_rm))));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVW7_COMPACT) : /* mov.w @@${rm}+, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  HI tmp_data;
  tmp_data = GETMEMHI (current_cpu, pc, GET_H_GRC (FLD (f_rm)));
if (EQSI (FLD (f_rm), FLD (f_rn))) {
  {
    SI opval = EXTHISI (tmp_data);
    SET_H_GRC (FLD (f_rm), opval);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
} else {
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rm)), 2);
    SET_H_GRC (FLD (f_rm), opval);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}
  {
    SI opval = EXTHISI (tmp_data);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

  abuf->written = written;
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVW8_COMPACT) : /* mov.w @@(r0, $rm), $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = EXTHISI (GETMEMHI (current_cpu, pc, ADDSI (GET_H_GRC (((UINT) 0)), GET_H_GRC (FLD (f_rm)))));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVW9_COMPACT) : /* mov.w @@($imm8x2, gbr), r0 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = EXTHISI (GETMEMHI (current_cpu, pc, ADDSI (GET_H_GBR (), FLD (f_imm8x2))));
    SET_H_GRC (((UINT) 0), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVW10_COMPACT) : /* mov.w @@($imm8x2, pc), $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = EXTHISI (GETMEMHI (current_cpu, pc, ADDDI (ADDDI (pc, 4), FLD (f_imm8x2))));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVW11_COMPACT) : /* mov.w @@($imm4x2, $rm), r0 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw5_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = EXTHISI (GETMEMHI (current_cpu, pc, ADDSI (GET_H_GRC (FLD (f_rm)), FLD (f_imm4x2))));
    SET_H_GRC (((UINT) 0), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVA_COMPACT) : /* mova @@($imm8x4, pc), r0 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ADDDI (ANDDI (ADDDI (pc, 4), INVSI (3)), FLD (f_imm8x4));
    SET_H_GRC (((UINT) 0), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVCAL_COMPACT) : /* movca.l r0, @@$rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_GRC (((UINT) 0));
    SETMEMSI (current_cpu, pc, GET_H_GRC (FLD (f_rn)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVCOL_COMPACT) : /* movco.l r0, @@$rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_GRC (FLD (f_rn));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVT_COMPACT) : /* movt $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ZEXTBISI (GET_H_TBIT ());
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVUAL_COMPACT) : /* movua.l @@$rn, r0 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = sh64_movua (current_cpu, pc, GET_H_GRC (FLD (f_rn)));
    SET_H_GRC (((UINT) 0), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MOVUAL2_COMPACT) : /* movua.l @@$rn+, r0 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    SI opval = sh64_movua (current_cpu, pc, GET_H_GRC (FLD (f_rn)));
    SET_H_GRC (((UINT) 0), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rn)), 4);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MULL_COMPACT) : /* mul.l $rm, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = MULSI (GET_H_GRC (FLD (f_rm)), GET_H_GRC (FLD (f_rn)));
    SET_H_MACL (opval);
    TRACE_RESULT (current_cpu, abuf, "macl", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MULSW_COMPACT) : /* muls.w $rm, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = MULSI (EXTHISI (SUBWORDSIHI (GET_H_GRC (FLD (f_rm)), 1)), EXTHISI (SUBWORDSIHI (GET_H_GRC (FLD (f_rn)), 1)));
    SET_H_MACL (opval);
    TRACE_RESULT (current_cpu, abuf, "macl", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MULUW_COMPACT) : /* mulu.w $rm, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = MULSI (ZEXTHISI (SUBWORDSIHI (GET_H_GRC (FLD (f_rm)), 1)), ZEXTHISI (SUBWORDSIHI (GET_H_GRC (FLD (f_rn)), 1)));
    SET_H_MACL (opval);
    TRACE_RESULT (current_cpu, abuf, "macl", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_NEG_COMPACT) : /* neg $rm, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = NEGSI (GET_H_GRC (FLD (f_rm)));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_NEGC_COMPACT) : /* negc $rm, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  BI tmp_flag;
  tmp_flag = SUBCFSI (0, GET_H_GRC (FLD (f_rm)), GET_H_TBIT ());
  {
    SI opval = SUBCSI (0, GET_H_GRC (FLD (f_rm)), GET_H_TBIT ());
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  {
    BI opval = tmp_flag;
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_NOP_COMPACT) : /* nop */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_empty.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

((void) 0); /*nop*/

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_NOT_COMPACT) : /* not $rm64, $rn64 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = INVDI (GET_H_GR (FLD (f_rm)));
    SET_H_GR (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'D', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_OCBI_COMPACT) : /* ocbi @@$rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    SI opval = GET_H_GRC (FLD (f_rn));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
((void) 0); /*nop*/
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_OCBP_COMPACT) : /* ocbp @@$rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    SI opval = GET_H_GRC (FLD (f_rn));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
((void) 0); /*nop*/
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_OCBWB_COMPACT) : /* ocbwb @@$rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    SI opval = GET_H_GRC (FLD (f_rn));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
((void) 0); /*nop*/
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_OR_COMPACT) : /* or $rm64, $rn64 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = ORDI (GET_H_GR (FLD (f_rm)), GET_H_GR (FLD (f_rn)));
    SET_H_GR (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'D', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_ORI_COMPACT) : /* or #$uimm8, r0 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_addi_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ORSI (GET_H_GRC (((UINT) 0)), ZEXTSIDI (FLD (f_imm8)));
    SET_H_GRC (((UINT) 0), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_ORB_COMPACT) : /* or.b #$imm8, @@(r0, gbr) */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_addi_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_addr;
  UQI tmp_data;
  tmp_addr = ADDSI (GET_H_GRC (((UINT) 0)), GET_H_GBR ());
  tmp_data = ORQI (GETMEMUQI (current_cpu, pc, tmp_addr), FLD (f_imm8));
  {
    UQI opval = tmp_data;
    SETMEMUQI (current_cpu, pc, tmp_addr, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_PREF_COMPACT) : /* pref @@$rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

sh64_pref (current_cpu, GET_H_GRC (FLD (f_rn)));

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_ROTCL_COMPACT) : /* rotcl $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  BI tmp_temp;
  tmp_temp = SRLSI (GET_H_GRC (FLD (f_rn)), 31);
  {
    SI opval = ORSI (SLLSI (GET_H_GRC (FLD (f_rn)), 1), GET_H_TBIT ());
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  {
    BI opval = ((tmp_temp) ? (1) : (0));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_ROTCR_COMPACT) : /* rotcr $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  BI tmp_lsbit;
  SI tmp_temp;
  tmp_lsbit = ((EQSI (ANDSI (GET_H_GRC (FLD (f_rn)), 1), 0)) ? (0) : (1));
  tmp_temp = GET_H_TBIT ();
  {
    SI opval = ORSI (SRLSI (GET_H_GRC (FLD (f_rn)), 1), SLLSI (tmp_temp, 31));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  {
    BI opval = ((tmp_lsbit) ? (1) : (0));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_ROTL_COMPACT) : /* rotl $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  BI tmp_temp;
  tmp_temp = SRLSI (GET_H_GRC (FLD (f_rn)), 31);
  {
    SI opval = ORSI (SLLSI (GET_H_GRC (FLD (f_rn)), 1), tmp_temp);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  {
    BI opval = ((tmp_temp) ? (1) : (0));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_ROTR_COMPACT) : /* rotr $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  BI tmp_lsbit;
  SI tmp_temp;
  tmp_lsbit = ((EQSI (ANDSI (GET_H_GRC (FLD (f_rn)), 1), 0)) ? (0) : (1));
  tmp_temp = tmp_lsbit;
  {
    SI opval = ORSI (SRLSI (GET_H_GRC (FLD (f_rn)), 1), SLLSI (tmp_temp, 31));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  {
    BI opval = ((tmp_lsbit) ? (1) : (0));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_RTS_COMPACT) : /* rts */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_empty.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    UDI opval = ADDDI (pc, 2);
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
((void) 0); /*nop*/
{
  {
    UDI opval = GET_H_PR ();
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
}
((void) 0); /*nop*/
}

  SEM_BRANCH_FINI (vpc);
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SETS_COMPACT) : /* sets */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_empty.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = 1;
    SET_H_SBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "sbit", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SETT_COMPACT) : /* sett */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_empty.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = 1;
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SHAD_COMPACT) : /* shad $rm, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  SI tmp_shamt;
  tmp_shamt = ANDSI (GET_H_GRC (FLD (f_rm)), 31);
if (GESI (GET_H_GRC (FLD (f_rm)), 0)) {
  {
    SI opval = SLLSI (GET_H_GRC (FLD (f_rn)), tmp_shamt);
    SET_H_GRC (FLD (f_rn), opval);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
} else {
if (NESI (tmp_shamt, 0)) {
  {
    SI opval = SRASI (GET_H_GRC (FLD (f_rn)), SUBSI (32, tmp_shamt));
    SET_H_GRC (FLD (f_rn), opval);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
} else {
if (LTSI (GET_H_GRC (FLD (f_rn)), 0)) {
  {
    SI opval = NEGSI (1);
    SET_H_GRC (FLD (f_rn), opval);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
} else {
  {
    SI opval = 0;
    SET_H_GRC (FLD (f_rn), opval);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}
}
}
}

  abuf->written = written;
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SHAL_COMPACT) : /* shal $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  BI tmp_t;
  tmp_t = SRLSI (GET_H_GRC (FLD (f_rn)), 31);
  {
    SI opval = SLLSI (GET_H_GRC (FLD (f_rn)), 1);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  {
    BI opval = ((tmp_t) ? (1) : (0));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SHAR_COMPACT) : /* shar $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  BI tmp_t;
  tmp_t = ANDSI (GET_H_GRC (FLD (f_rn)), 1);
  {
    SI opval = SRASI (GET_H_GRC (FLD (f_rn)), 1);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  {
    BI opval = ((tmp_t) ? (1) : (0));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SHLD_COMPACT) : /* shld $rm, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  SI tmp_shamt;
  tmp_shamt = ANDSI (GET_H_GRC (FLD (f_rm)), 31);
if (GESI (GET_H_GRC (FLD (f_rm)), 0)) {
  {
    SI opval = SLLSI (GET_H_GRC (FLD (f_rn)), tmp_shamt);
    SET_H_GRC (FLD (f_rn), opval);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
} else {
if (NESI (tmp_shamt, 0)) {
  {
    SI opval = SRLSI (GET_H_GRC (FLD (f_rn)), SUBSI (32, tmp_shamt));
    SET_H_GRC (FLD (f_rn), opval);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
} else {
  {
    SI opval = 0;
    SET_H_GRC (FLD (f_rn), opval);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}
}
}

  abuf->written = written;
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SHLL_COMPACT) : /* shll $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  BI tmp_t;
  tmp_t = SRLSI (GET_H_GRC (FLD (f_rn)), 31);
  {
    SI opval = SLLSI (GET_H_GRC (FLD (f_rn)), 1);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  {
    BI opval = ((tmp_t) ? (1) : (0));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SHLL2_COMPACT) : /* shll2 $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = SLLSI (GET_H_GRC (FLD (f_rn)), 2);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SHLL8_COMPACT) : /* shll8 $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = SLLSI (GET_H_GRC (FLD (f_rn)), 8);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SHLL16_COMPACT) : /* shll16 $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = SLLSI (GET_H_GRC (FLD (f_rn)), 16);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SHLR_COMPACT) : /* shlr $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  BI tmp_t;
  tmp_t = ANDSI (GET_H_GRC (FLD (f_rn)), 1);
  {
    SI opval = SRLSI (GET_H_GRC (FLD (f_rn)), 1);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  {
    BI opval = ((tmp_t) ? (1) : (0));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SHLR2_COMPACT) : /* shlr2 $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = SRLSI (GET_H_GRC (FLD (f_rn)), 2);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SHLR8_COMPACT) : /* shlr8 $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = SRLSI (GET_H_GRC (FLD (f_rn)), 8);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SHLR16_COMPACT) : /* shlr16 $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = SRLSI (GET_H_GRC (FLD (f_rn)), 16);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_STC_GBR_COMPACT) : /* stc gbr, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_GBR ();
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_STC_VBR_COMPACT) : /* stc vbr, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_VBR ();
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_STCL_GBR_COMPACT) : /* stc.l gbr, @@-$rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_addr;
  tmp_addr = SUBSI (GET_H_GRC (FLD (f_rn)), 4);
  {
    SI opval = GET_H_GBR ();
    SETMEMSI (current_cpu, pc, tmp_addr, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
  {
    SI opval = tmp_addr;
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_STCL_VBR_COMPACT) : /* stc.l vbr, @@-$rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_addr;
  tmp_addr = SUBSI (GET_H_GRC (FLD (f_rn)), 4);
  {
    SI opval = GET_H_VBR ();
    SETMEMSI (current_cpu, pc, tmp_addr, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
  {
    SI opval = tmp_addr;
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_STS_FPSCR_COMPACT) : /* sts fpscr, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = CPU (h_fpscr);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_STSL_FPSCR_COMPACT) : /* sts.l fpscr, @@-$rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_addr;
  tmp_addr = SUBSI (GET_H_GRC (FLD (f_rn)), 4);
  {
    SI opval = CPU (h_fpscr);
    SETMEMSI (current_cpu, pc, tmp_addr, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
  {
    SI opval = tmp_addr;
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_STS_FPUL_COMPACT) : /* sts fpul, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = SUBWORDSFSI (CPU (h_fr[((UINT) 32)]));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_STSL_FPUL_COMPACT) : /* sts.l fpul, @@-$rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_addr;
  tmp_addr = SUBSI (GET_H_GRC (FLD (f_rn)), 4);
  {
    SF opval = CPU (h_fr[((UINT) 32)]);
    SETMEMSF (current_cpu, pc, tmp_addr, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'f', opval);
  }
  {
    SI opval = tmp_addr;
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_STS_MACH_COMPACT) : /* sts mach, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_MACH ();
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_STSL_MACH_COMPACT) : /* sts.l mach, @@-$rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_addr;
  tmp_addr = SUBSI (GET_H_GRC (FLD (f_rn)), 4);
  {
    SI opval = GET_H_MACH ();
    SETMEMSI (current_cpu, pc, tmp_addr, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
  {
    SI opval = tmp_addr;
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_STS_MACL_COMPACT) : /* sts macl, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_MACL ();
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_STSL_MACL_COMPACT) : /* sts.l macl, @@-$rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_addr;
  tmp_addr = SUBSI (GET_H_GRC (FLD (f_rn)), 4);
  {
    SI opval = GET_H_MACL ();
    SETMEMSI (current_cpu, pc, tmp_addr, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
  {
    SI opval = tmp_addr;
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_STS_PR_COMPACT) : /* sts pr, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_PR ();
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_STSL_PR_COMPACT) : /* sts.l pr, @@-$rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_addr;
  tmp_addr = SUBSI (GET_H_GRC (FLD (f_rn)), 4);
  {
    SI opval = GET_H_PR ();
    SETMEMSI (current_cpu, pc, tmp_addr, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
  {
    SI opval = tmp_addr;
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SUB_COMPACT) : /* sub $rm, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = SUBSI (GET_H_GRC (FLD (f_rn)), GET_H_GRC (FLD (f_rm)));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SUBC_COMPACT) : /* subc $rm, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  BI tmp_flag;
  tmp_flag = SUBCFSI (GET_H_GRC (FLD (f_rn)), GET_H_GRC (FLD (f_rm)), GET_H_TBIT ());
  {
    SI opval = SUBCSI (GET_H_GRC (FLD (f_rn)), GET_H_GRC (FLD (f_rm)), GET_H_TBIT ());
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  {
    BI opval = tmp_flag;
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SUBV_COMPACT) : /* subv $rm, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  BI tmp_t;
  tmp_t = SUBOFSI (GET_H_GRC (FLD (f_rn)), GET_H_GRC (FLD (f_rm)), 0);
  {
    SI opval = SUBSI (GET_H_GRC (FLD (f_rn)), GET_H_GRC (FLD (f_rm)));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  {
    BI opval = ((tmp_t) ? (1) : (0));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SWAPB_COMPACT) : /* swap.b $rm, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  UHI tmp_top_half;
  UQI tmp_byte1;
  UQI tmp_byte0;
  tmp_top_half = SUBWORDSIHI (GET_H_GRC (FLD (f_rm)), 0);
  tmp_byte1 = SUBWORDSIQI (GET_H_GRC (FLD (f_rm)), 2);
  tmp_byte0 = SUBWORDSIQI (GET_H_GRC (FLD (f_rm)), 3);
  {
    SI opval = ORSI (SLLSI (tmp_top_half, 16), ORSI (SLLSI (tmp_byte0, 8), tmp_byte1));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SWAPW_COMPACT) : /* swap.w $rm, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ORSI (SRLSI (GET_H_GRC (FLD (f_rm)), 16), SLLSI (GET_H_GRC (FLD (f_rm)), 16));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_TASB_COMPACT) : /* tas.b @@$rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  UQI tmp_byte;
  tmp_byte = GETMEMUQI (current_cpu, pc, GET_H_GRC (FLD (f_rn)));
  {
    BI opval = ((EQQI (tmp_byte, 0)) ? (1) : (0));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
  tmp_byte = ORQI (tmp_byte, 128);
  {
    UQI opval = tmp_byte;
    SETMEMUQI (current_cpu, pc, GET_H_GRC (FLD (f_rn)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_TRAPA_COMPACT) : /* trapa #$uimm8 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_addi_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

sh64_compact_trapa (current_cpu, FLD (f_imm8), pc);

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_TST_COMPACT) : /* tst $rm, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = ((EQSI (ANDSI (GET_H_GRC (FLD (f_rm)), GET_H_GRC (FLD (f_rn))), 0)) ? (1) : (0));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_TSTI_COMPACT) : /* tst #$uimm8, r0 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_addi_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = ((EQSI (ANDSI (GET_H_GRC (((UINT) 0)), ZEXTSISI (FLD (f_imm8))), 0)) ? (1) : (0));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_TSTB_COMPACT) : /* tst.b #$imm8, @@(r0, gbr) */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_addi_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_addr;
  tmp_addr = ADDSI (GET_H_GRC (((UINT) 0)), GET_H_GBR ());
  {
    BI opval = ((EQQI (ANDQI (GETMEMUQI (current_cpu, pc, tmp_addr), FLD (f_imm8)), 0)) ? (1) : (0));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_XOR_COMPACT) : /* xor $rm64, $rn64 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = XORDI (GET_H_GR (FLD (f_rn)), GET_H_GR (FLD (f_rm)));
    SET_H_GR (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'D', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_XORI_COMPACT) : /* xor #$uimm8, r0 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_addi_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = XORSI (GET_H_GRC (((UINT) 0)), ZEXTSIDI (FLD (f_imm8)));
    SET_H_GRC (((UINT) 0), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_XORB_COMPACT) : /* xor.b #$imm8, @@(r0, gbr) */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_addi_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_addr;
  UQI tmp_data;
  tmp_addr = ADDSI (GET_H_GRC (((UINT) 0)), GET_H_GBR ());
  tmp_data = XORQI (GETMEMUQI (current_cpu, pc, tmp_addr), FLD (f_imm8));
  {
    UQI opval = tmp_data;
    SETMEMUQI (current_cpu, pc, tmp_addr, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_XTRCT_COMPACT) : /* xtrct $rm, $rn */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ORSI (SLLSI (GET_H_GRC (FLD (f_rm)), 16), SRLSI (GET_H_GRC (FLD (f_rn)), 16));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);


    }
  ENDSWITCH (sem) /* End of semantic switch.  */

  /* At this point `vpc' contains the next insn to execute.  */
}

#undef DEFINE_SWITCH
#endif /* DEFINE_SWITCH */
@


1.8
log
@[sim] Update old contact info in GPL license notices

sim/ChangeLog:

        Update old contact info in GPL license notices.
@
text
@d5 1
a5 1
Copyright 1996-2010, 2012 Free Software Foundation, Inc.
@


1.7
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d20 1
a20 2
   with this program; if not, write to the Free Software Foundation, Inc.,
   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
@


1.6
log
@Regenerate cgen-derived files.
@
text
@d5 1
a5 1
Copyright 1996-2010 Free Software Foundation, Inc.
@


1.6.8.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d5 1
a5 1
Copyright 1996-2010, 2012 Free Software Foundation, Inc.
@


1.5
log
@Regenerate cgen files, update copyright year.
@
text
@a264 1
#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
a265 3
#else
#define GET_ATTR(cpu, num, attr) CGEN_ATTR_VALUE (NULL, abuf->idesc->attrs, CGEN_INSN_/**/attr)
#endif
d296 1
a296 1
#define FLD(f) abuf->fields.fmt_empty.f
d321 1
a321 1
#define FLD(f) abuf->fields.fmt_empty.f
d340 1
a340 1
#define FLD(f) abuf->fields.fmt_empty.f
d359 1
a359 1
#define FLD(f) abuf->fields.fmt_empty.f
d387 1
a387 1
#define FLD(f) abuf->fields.fmt_empty.f
d409 1
a409 1
#define FLD(f) abuf->fields.fmt_empty.f
d718 1
a718 1
#define FLD(f) abuf->fields.fmt_empty.f
d870 1
a870 1
#define FLD(f) abuf->fields.fmt_empty.f
d896 1
a896 1
#define FLD(f) abuf->fields.fmt_empty.f
d915 1
a915 1
#define FLD(f) abuf->fields.fmt_empty.f
d1145 1
a1145 1
#define FLD(f) abuf->fields.fmt_empty.f
d2142 1
a2142 1
#define FLD(f) abuf->fields.fmt_empty.f
d2161 1
a2161 1
#define FLD(f) abuf->fields.fmt_empty.f
d3885 1
a3885 1
#define FLD(f) abuf->fields.fmt_empty.f
d4179 1
a4179 1
#define FLD(f) abuf->fields.fmt_empty.f
d4211 1
a4211 1
#define FLD(f) abuf->fields.fmt_empty.f
d4230 1
a4230 1
#define FLD(f) abuf->fields.fmt_empty.f
@


1.4
log
@	* arch.c: Regenerate.
	* arch.h: Regenerate.
	* cpu.c: Regenerate.
	* cpu.h: Regenerate.
	* cpuall.h: Regenerate.
	* decode-compact.c: Regenerate.
	* decode-compact.h: Regenerate.
	* decode-media.c: Regenerate.
	* decode-media.h: Regenerate.
	* defs-compact.h: Regenerate.
	* defs-media.h: Regenerate.
	* sem-compact-switch.c: Regenerate.
	* sem-compact.c: Regenerate.
	* sem-media-switch.c: Regenerate.
	* sem-media.c: Regenerate.
	* sh-desc.c: Regenerate.
	* sh-opc.h: Regenerate.
@
text
@d5 1
a5 1
Copyright 1996-2009 Free Software Foundation, Inc.
@


1.3
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d5 1
a5 1
Copyright 1996-2005 Free Software Foundation, Inc.
d9 13
a21 12
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
@


1.2
log
@2006-10-18  Dave Brolley  <brolley@@redhat.com>

        * Contribute the following changes:

        2006-06-14  Dave Brolley  <brolley@@redhat.com>

        * sh64-sim.h (sh64_fipr,sh64_fiprs,sh64_fldp,sh64_fstp,sh64_ftrv)
        (sh64_fpref): New functions.
        * sh64.c (sh64_fipr,sh64_fiprs,sh64_fldp,sh64_fstp,sh64_ftrv)
        (sh64_fpref): New functions.
        (sh_models): Add sh2e, sh2a, sh2a_nofpu, sh4_nofpu, sh4a,
        sh4a_nofpu and sh4al.
        (sh2e_mach): New MACH.
        (sh2a_fpu_mach): New MACH.
        (sh2a_nofpu_mach): New MACH.
        (sh4_nofpu): New MACH.
        (sh4a_mach): New MACH.
        (sh4a_nofpu_mach): New MACH.
        (sh4al_mach): New MACH.
        * Makefile.in (stamp-*): Depend on $(CGEN_CPU_DIR)/sh-sim.cpu. Pass
        archfile to CGEN script.
        * arch.c: Regenerated.
        * arch.h: Regenerated.
        * cpu.c: Regenerated.
        * cpu.h: Regenerated.
        * cpuall.h: Regenerated.
        * decode-compact.c: Regenerated.
        * decode-compact.h: Regenerated.
        * decode-media.c: Regenerated.
        * decode-media.h: Regenerated.
        * defs-compact.h: Regenerated.
        * defs-media.h: Regenerated.
        * sem-compact-switch.c: Regenerated.
        * sem-compact.c: Regenerated.
        * sem-media-switch.c: Regenerated.
        * sem-media.c: Regenerated.
        * sh-desc.c: Regenerated.
        * sh-desc.h: Regenerated.
        * sh-opc.h: Regenerated.
@
text
@d11 2
a12 2
the Free Software Foundation; either version 2, or (at your option)
any later version.
d19 2
a20 3
You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
@


1.1
log
@* Contribute Hitachi SH5 simulator.
@
text
@d5 1
a5 1
Copyright (C) 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
d7 1
a7 1
This file is part of the GNU Simulators.
d21 1
a21 1
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
d72 2
d101 2
d114 5
a118 2
    { SH64_COMPACT_INSN_LDC_COMPACT, && case_sem_INSN_LDC_COMPACT },
    { SH64_COMPACT_INSN_LDCL_COMPACT, && case_sem_INSN_LDCL_COMPACT },
d133 1
d155 2
d170 1
d172 2
d208 1
d210 1
d442 1
a442 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d450 1
a450 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d469 1
a469 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d480 1
a480 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d491 1
a491 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d508 1
a508 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d519 1
a519 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d536 1
a536 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d544 1
a544 1
    TRACE_RESULT (current_cpu, abuf, "rn64", 'D', opval);
d563 1
a563 1
    TRACE_RESULT (current_cpu, abuf, "r0", 'x', opval);
d633 8
d643 1
a643 1
    written |= (1 << 2);
d648 1
d668 7
d680 1
d699 7
d711 1
d750 8
d788 8
d847 8
d857 1
a857 1
    written |= (1 << 2);
d862 1
d938 1
a938 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d976 1
a976 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d995 1
a995 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1014 1
a1014 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1033 1
a1033 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1090 1
a1090 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1118 1
a1118 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1180 1
a1180 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1198 1
a1198 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d1207 1
a1207 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d1230 1
a1230 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d1255 1
a1255 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d1278 1
a1278 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d1308 38
d1350 1
a1350 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1378 1
a1378 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1415 1
a1415 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d1432 1
a1432 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1440 1
a1440 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d1451 1
a1451 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1459 1
a1459 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d1470 1
a1470 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1478 1
a1478 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d1489 1
a1489 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1497 1
a1497 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d1515 4
a1518 4
    DF opval = sh64_fabsd (current_cpu, GET_H_DR (FLD (f_rn)));
    SET_H_DR (FLD (f_rn), opval);
    written |= (1 << 5);
    TRACE_RESULT (current_cpu, abuf, "dr-index-of--DFLT-fsdn", 'f', opval);
d1522 4
a1525 4
    SF opval = sh64_fabss (current_cpu, GET_H_FRC (FLD (f_rn)));
    SET_H_FRC (FLD (f_rn), opval);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "fsdn", 'f', opval);
d1538 1
a1538 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1545 4
a1548 4
    DF opval = sh64_faddd (current_cpu, GET_H_DR (FLD (f_rm)), GET_H_DR (FLD (f_rn)));
    SET_H_DR (FLD (f_rn), opval);
    written |= (1 << 8);
    TRACE_RESULT (current_cpu, abuf, "dr-index-of--DFLT-fsdn", 'f', opval);
d1552 4
a1555 4
    SF opval = sh64_fadds (current_cpu, GET_H_FRC (FLD (f_rm)), GET_H_FRC (FLD (f_rn)));
    SET_H_FRC (FLD (f_rn), opval);
    written |= (1 << 7);
    TRACE_RESULT (current_cpu, abuf, "fsdn", 'f', opval);
d1568 1
a1568 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1575 1
a1575 1
    BI opval = sh64_fcmpeqd (current_cpu, GET_H_DR (FLD (f_rm)), GET_H_DR (FLD (f_rn)));
d1577 1
a1577 1
    written |= (1 << 7);
d1582 1
a1582 1
    BI opval = sh64_fcmpeqs (current_cpu, GET_H_FRC (FLD (f_rm)), GET_H_FRC (FLD (f_rn)));
d1584 1
a1584 1
    written |= (1 << 7);
d1598 1
a1598 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1605 1
a1605 1
    BI opval = sh64_fcmpgtd (current_cpu, GET_H_DR (FLD (f_rn)), GET_H_DR (FLD (f_rm)));
d1607 1
a1607 1
    written |= (1 << 7);
d1612 1
a1612 1
    BI opval = sh64_fcmpgts (current_cpu, GET_H_FRC (FLD (f_rn)), GET_H_FRC (FLD (f_rm)));
d1614 1
a1614 1
    written |= (1 << 7);
d1628 1
a1628 1
#define FLD(f) abuf->fields.sfmt_fcnvds_compact.f
d1636 1
a1636 1
    TRACE_RESULT (current_cpu, abuf, "fpul", 'f', opval);
d1647 1
a1647 1
#define FLD(f) abuf->fields.sfmt_fcnvds_compact.f
d1655 1
a1655 1
    TRACE_RESULT (current_cpu, abuf, "drn", 'f', opval);
d1666 1
a1666 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1673 4
a1676 4
    DF opval = sh64_fdivd (current_cpu, GET_H_DR (FLD (f_rn)), GET_H_DR (FLD (f_rm)));
    SET_H_DR (FLD (f_rn), opval);
    written |= (1 << 8);
    TRACE_RESULT (current_cpu, abuf, "dr-index-of--DFLT-fsdn", 'f', opval);
d1680 4
a1683 4
    SF opval = sh64_fdivs (current_cpu, GET_H_FRC (FLD (f_rn)), GET_H_FRC (FLD (f_rm)));
    SET_H_FRC (FLD (f_rn), opval);
    written |= (1 << 7);
    TRACE_RESULT (current_cpu, abuf, "fsdn", 'f', opval);
d1701 1
a1701 16
{
  QI tmp_m;
  QI tmp_n;
  SF tmp_res;
  tmp_m = FLD (f_vm);
  tmp_n = FLD (f_vn);
  tmp_res = sh64_fmuls (current_cpu, GET_H_FVC (FLD (f_vm)), GET_H_FVC (FLD (f_vn)));
  tmp_res = sh64_fadds (current_cpu, tmp_res, sh64_fmuls (current_cpu, GET_H_FRC (ADDQI (tmp_m, 1)), GET_H_FRC (ADDQI (tmp_n, 1))));
  tmp_res = sh64_fadds (current_cpu, tmp_res, sh64_fmuls (current_cpu, GET_H_FRC (ADDQI (tmp_m, 2)), GET_H_FRC (ADDQI (tmp_n, 2))));
  tmp_res = sh64_fadds (current_cpu, tmp_res, sh64_fmuls (current_cpu, GET_H_FRC (ADDQI (tmp_m, 3)), GET_H_FRC (ADDQI (tmp_n, 3))));
  {
    SF opval = tmp_res;
    SET_H_FRC (ADDQI (tmp_n, 3), opval);
    TRACE_RESULT (current_cpu, abuf, "frc-add--DFLT-n-3", 'f', opval);
  }
}
d1707 1
a1707 1
  CASE (sem, INSN_FLDS_COMPACT) : /* flds $frn */
d1719 1
a1719 1
    TRACE_RESULT (current_cpu, abuf, "fpul", 'f', opval);
d1738 1
a1738 1
    TRACE_RESULT (current_cpu, abuf, "frn", 'f', opval);
d1757 1
a1757 1
    TRACE_RESULT (current_cpu, abuf, "frn", 'f', opval);
d1776 3
a1778 3
    SET_H_DR (FLD (f_rn), opval);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "dr-index-of--DFLT-fsdn", 'f', opval);
d1782 4
a1785 4
    SF opval = sh64_floatls (current_cpu, CPU (h_fr[((UINT) 32)]));
    SET_H_FRC (FLD (f_rn), opval);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "fsdn", 'f', opval);
d1798 1
a1798 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1806 1
a1806 1
    TRACE_RESULT (current_cpu, abuf, "frn", 'f', opval);
d1813 1
a1813 1
  CASE (sem, INSN_FMOV1_COMPACT) : /* fmov $frm, $frn */
d1817 1
a1817 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
a1821 17
if (NOTBI (GET_H_SZBIT ())) {
  {
    SF opval = GET_H_FRC (FLD (f_rm));
    SET_H_FRC (FLD (f_rn), opval);
    written |= (1 << 6);
    TRACE_RESULT (current_cpu, abuf, "frn", 'f', opval);
  }
} else {
if (EQSI (ANDSI (FLD (f_rm), 1), 1)) {
if (EQSI (ANDSI (FLD (f_rn), 1), 1)) {
  {
    DF opval = GET_H_XD (((FLD (f_rm)) & (INVQI (1))));
    SET_H_XD (((FLD (f_rn)) & (INVQI (1))), opval);
    written |= (1 << 8);
    TRACE_RESULT (current_cpu, abuf, "xd-and--DFLT-index-of--DFLT-frn-inv--QI-1", 'f', opval);
  }
} else {
d1823 3
a1825 4
    DF opval = GET_H_XD (((FLD (f_rm)) & (INVQI (1))));
    SET_H_DR (FLD (f_rn), opval);
    written |= (1 << 7);
    TRACE_RESULT (current_cpu, abuf, "dr-index-of--DFLT-frn", 'f', opval);
a1826 19
}
} else {
if (EQSI (ANDSI (FLD (f_rn), 1), 1)) {
  {
    DF opval = GET_H_DR (FLD (f_rm));
    SET_H_XD (((FLD (f_rn)) & (INVQI (1))), opval);
    written |= (1 << 8);
    TRACE_RESULT (current_cpu, abuf, "xd-and--DFLT-index-of--DFLT-frn-inv--QI-1", 'f', opval);
  }
} else {
  {
    DF opval = GET_H_DR (FLD (f_rm));
    SET_H_DR (FLD (f_rn), opval);
    written |= (1 << 7);
    TRACE_RESULT (current_cpu, abuf, "dr-index-of--DFLT-frn", 'f', opval);
  }
}
}
}
a1827 1
  abuf->written = written;
d1832 1
a1832 1
  CASE (sem, INSN_FMOV2_COMPACT) : /* fmov @@$rm, $frn */
d1836 1
a1836 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1843 4
a1846 4
    SF opval = GETMEMSF (current_cpu, pc, GET_H_GRC (FLD (f_rm)));
    SET_H_FRC (FLD (f_rn), opval);
    written |= (1 << 5);
    TRACE_RESULT (current_cpu, abuf, "frn", 'f', opval);
a1848 1
if (EQSI (ANDSI (FLD (f_rn), 1), 1)) {
d1851 3
a1853 10
    SET_H_XD (((FLD (f_rn)) & (INVQI (1))), opval);
    written |= (1 << 7);
    TRACE_RESULT (current_cpu, abuf, "xd-and--DFLT-index-of--DFLT-frn-inv--QI-1", 'f', opval);
  }
} else {
  {
    DF opval = GETMEMDF (current_cpu, pc, GET_H_GRC (FLD (f_rm)));
    SET_H_DR (FLD (f_rn), opval);
    written |= (1 << 6);
    TRACE_RESULT (current_cpu, abuf, "dr-index-of--DFLT-frn", 'f', opval);
a1855 1
}
d1862 1
a1862 1
  CASE (sem, INSN_FMOV3_COMPACT) : /* fmov @@${rm}+, frn */
d1866 1
a1866 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1874 4
a1877 4
    SF opval = GETMEMSF (current_cpu, pc, GET_H_GRC (FLD (f_rm)));
    SET_H_FRC (FLD (f_rn), opval);
    written |= (1 << 5);
    TRACE_RESULT (current_cpu, abuf, "frn", 'f', opval);
d1882 2
a1883 2
    written |= (1 << 8);
    TRACE_RESULT (current_cpu, abuf, "rm", 'x', opval);
a1887 1
if (EQSI (ANDSI (FLD (f_rn), 1), 1)) {
d1890 3
a1892 10
    SET_H_XD (((FLD (f_rn)) & (INVQI (1))), opval);
    written |= (1 << 7);
    TRACE_RESULT (current_cpu, abuf, "xd-and--DFLT-index-of--DFLT-frn-inv--QI-1", 'f', opval);
  }
} else {
  {
    DF opval = GETMEMDF (current_cpu, pc, GET_H_GRC (FLD (f_rm)));
    SET_H_DR (FLD (f_rn), opval);
    written |= (1 << 6);
    TRACE_RESULT (current_cpu, abuf, "dr-index-of--DFLT-frn", 'f', opval);
a1893 1
}
d1897 2
a1898 2
    written |= (1 << 8);
    TRACE_RESULT (current_cpu, abuf, "rm", 'x', opval);
d1908 1
a1908 1
  CASE (sem, INSN_FMOV4_COMPACT) : /* fmov @@(r0, $rm), $frn */
d1912 1
a1912 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1919 4
a1922 4
    SF opval = GETMEMSF (current_cpu, pc, ADDSI (GET_H_GRC (((UINT) 0)), GET_H_GRC (FLD (f_rm))));
    SET_H_FRC (FLD (f_rn), opval);
    written |= (1 << 6);
    TRACE_RESULT (current_cpu, abuf, "frn", 'f', opval);
a1924 1
if (EQSI (ANDSI (FLD (f_rn), 1), 1)) {
d1927 3
a1929 10
    SET_H_XD (((FLD (f_rn)) & (INVQI (1))), opval);
    written |= (1 << 8);
    TRACE_RESULT (current_cpu, abuf, "xd-and--DFLT-index-of--DFLT-frn-inv--QI-1", 'f', opval);
  }
} else {
  {
    DF opval = GETMEMDF (current_cpu, pc, ADDSI (GET_H_GRC (((UINT) 0)), GET_H_GRC (FLD (f_rm))));
    SET_H_DR (FLD (f_rn), opval);
    written |= (1 << 7);
    TRACE_RESULT (current_cpu, abuf, "dr-index-of--DFLT-frn", 'f', opval);
a1931 1
}
d1938 1
a1938 1
  CASE (sem, INSN_FMOV5_COMPACT) : /* fmov $frm, @@$rn */
d1942 1
a1942 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1949 1
a1949 1
    SF opval = GET_H_FRC (FLD (f_rm));
d1951 1
a1951 1
    written |= (1 << 6);
a1954 1
if (EQSI (ANDSI (FLD (f_rm), 1), 1)) {
d1956 1
a1956 1
    DF opval = GET_H_XD (((FLD (f_rm)) & (INVQI (1))));
d1958 1
a1958 8
    written |= (1 << 7);
    TRACE_RESULT (current_cpu, abuf, "memory", 'f', opval);
  }
} else {
  {
    DF opval = GET_H_DR (FLD (f_rm));
    SETMEMDF (current_cpu, pc, GET_H_GRC (FLD (f_rn)), opval);
    written |= (1 << 7);
a1961 1
}
d1968 1
a1968 1
  CASE (sem, INSN_FMOV6_COMPACT) : /* fmov $frm, @@-$rn */
d1972 1
a1972 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1982 2
a1983 2
    written |= (1 << 8);
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d1986 1
a1986 1
    SF opval = GET_H_FRC (FLD (f_rm));
d1988 1
a1988 1
    written |= (1 << 6);
d1997 2
a1998 2
    written |= (1 << 8);
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
a1999 1
if (EQSI (ANDSI (FLD (f_rm), 1), 1)) {
d2001 1
a2001 1
    DF opval = GET_H_XD (((FLD (f_rm)) & (INVQI (1))));
d2003 1
a2003 1
    written |= (1 << 7);
a2005 8
} else {
  {
    DF opval = GET_H_DR (FLD (f_rm));
    SETMEMDF (current_cpu, pc, GET_H_GRC (FLD (f_rn)), opval);
    written |= (1 << 7);
    TRACE_RESULT (current_cpu, abuf, "memory", 'f', opval);
  }
}
d2014 1
a2014 1
  CASE (sem, INSN_FMOV7_COMPACT) : /* fmov $frm, @@(r0, $rn) */
d2018 1
a2018 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d2025 1
a2025 1
    SF opval = GET_H_FRC (FLD (f_rm));
d2027 1
a2027 1
    written |= (1 << 7);
a2030 1
if (EQSI (ANDSI (FLD (f_rm), 1), 1)) {
d2032 1
a2032 1
    DF opval = GET_H_XD (((FLD (f_rm)) & (INVQI (1))));
d2034 1
a2034 1
    written |= (1 << 8);
d2037 35
a2071 1
} else {
d2073 2
a2074 3
    DF opval = GET_H_DR (FLD (f_rm));
    SETMEMDF (current_cpu, pc, ADDSI (GET_H_GRC (((UINT) 0)), GET_H_GRC (FLD (f_rn))), opval);
    written |= (1 << 8);
a2076 2
}
}
a2077 1
  abuf->written = written;
d2086 1
a2086 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d2093 4
a2096 4
    DF opval = sh64_fmuld (current_cpu, GET_H_DR (FLD (f_rm)), GET_H_DR (FLD (f_rn)));
    SET_H_DR (FLD (f_rn), opval);
    written |= (1 << 8);
    TRACE_RESULT (current_cpu, abuf, "dr-index-of--DFLT-fsdn", 'f', opval);
d2100 4
a2103 4
    SF opval = sh64_fmuls (current_cpu, GET_H_FRC (FLD (f_rm)), GET_H_FRC (FLD (f_rn)));
    SET_H_FRC (FLD (f_rn), opval);
    written |= (1 << 7);
    TRACE_RESULT (current_cpu, abuf, "fsdn", 'f', opval);
d2123 4
a2126 4
    DF opval = sh64_fnegd (current_cpu, GET_H_DR (FLD (f_rn)));
    SET_H_DR (FLD (f_rn), opval);
    written |= (1 << 5);
    TRACE_RESULT (current_cpu, abuf, "dr-index-of--DFLT-fsdn", 'f', opval);
d2130 4
a2133 4
    SF opval = sh64_fnegs (current_cpu, GET_H_FRC (FLD (f_rn)));
    SET_H_FRC (FLD (f_rn), opval);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "fsdn", 'f', opval);
d2191 4
a2194 4
    DF opval = sh64_fsqrtd (current_cpu, GET_H_DR (FLD (f_rn)));
    SET_H_DR (FLD (f_rn), opval);
    written |= (1 << 5);
    TRACE_RESULT (current_cpu, abuf, "dr-index-of--DFLT-fsdn", 'f', opval);
d2198 4
a2201 4
    SF opval = sh64_fsqrts (current_cpu, GET_H_FRC (FLD (f_rn)));
    SET_H_FRC (FLD (f_rn), opval);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "fsdn", 'f', opval);
d2222 1
a2222 1
    TRACE_RESULT (current_cpu, abuf, "frn", 'f', opval);
d2233 1
a2233 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d2240 4
a2243 4
    DF opval = sh64_fsubd (current_cpu, GET_H_DR (FLD (f_rn)), GET_H_DR (FLD (f_rm)));
    SET_H_DR (FLD (f_rn), opval);
    written |= (1 << 8);
    TRACE_RESULT (current_cpu, abuf, "dr-index-of--DFLT-fsdn", 'f', opval);
d2247 4
a2250 4
    SF opval = sh64_fsubs (current_cpu, GET_H_FRC (FLD (f_rn)), GET_H_FRC (FLD (f_rm)));
    SET_H_FRC (FLD (f_rn), opval);
    written |= (1 << 7);
    TRACE_RESULT (current_cpu, abuf, "fsdn", 'f', opval);
d2269 1
a2269 1
    SF opval = ((GET_H_PRBIT ()) ? (sh64_ftrcdl (current_cpu, GET_H_DR (FLD (f_rn)))) : (sh64_ftrcsl (current_cpu, GET_H_FRC (FLD (f_rn)))));
d2271 1
a2271 1
    TRACE_RESULT (current_cpu, abuf, "fpul", 'f', opval);
d2287 23
d2311 4
a2314 38
  QI tmp_n;
  SF tmp_res;
  tmp_n = FLD (f_vn);
  tmp_res = sh64_fmuls (current_cpu, GET_H_XF (((UINT) 0)), GET_H_FRC (tmp_n));
  tmp_res = sh64_fadds (current_cpu, tmp_res, sh64_fmuls (current_cpu, GET_H_XF (((UINT) 4)), GET_H_FRC (ADDQI (tmp_n, 1))));
  tmp_res = sh64_fadds (current_cpu, tmp_res, sh64_fmuls (current_cpu, GET_H_XF (((UINT) 8)), GET_H_FRC (ADDQI (tmp_n, 2))));
  tmp_res = sh64_fadds (current_cpu, tmp_res, sh64_fmuls (current_cpu, GET_H_XF (((UINT) 12)), GET_H_FRC (ADDQI (tmp_n, 3))));
  {
    SF opval = tmp_res;
    SET_H_FRC (tmp_n, opval);
    TRACE_RESULT (current_cpu, abuf, "frc-n", 'f', opval);
  }
  tmp_res = sh64_fmuls (current_cpu, GET_H_XF (((UINT) 1)), GET_H_FRC (tmp_n));
  tmp_res = sh64_fadds (current_cpu, tmp_res, sh64_fmuls (current_cpu, GET_H_XF (((UINT) 5)), GET_H_FRC (ADDQI (tmp_n, 1))));
  tmp_res = sh64_fadds (current_cpu, tmp_res, sh64_fmuls (current_cpu, GET_H_XF (((UINT) 9)), GET_H_FRC (ADDQI (tmp_n, 2))));
  tmp_res = sh64_fadds (current_cpu, tmp_res, sh64_fmuls (current_cpu, GET_H_XF (((UINT) 13)), GET_H_FRC (ADDQI (tmp_n, 3))));
  {
    SF opval = tmp_res;
    SET_H_FRC (ADDQI (tmp_n, 1), opval);
    TRACE_RESULT (current_cpu, abuf, "frc-add--DFLT-n-1", 'f', opval);
  }
  tmp_res = sh64_fmuls (current_cpu, GET_H_XF (((UINT) 2)), GET_H_FRC (tmp_n));
  tmp_res = sh64_fadds (current_cpu, tmp_res, sh64_fmuls (current_cpu, GET_H_XF (((UINT) 6)), GET_H_FRC (ADDQI (tmp_n, 1))));
  tmp_res = sh64_fadds (current_cpu, tmp_res, sh64_fmuls (current_cpu, GET_H_XF (((UINT) 10)), GET_H_FRC (ADDQI (tmp_n, 2))));
  tmp_res = sh64_fadds (current_cpu, tmp_res, sh64_fmuls (current_cpu, GET_H_XF (((UINT) 14)), GET_H_FRC (ADDQI (tmp_n, 3))));
  {
    SF opval = tmp_res;
    SET_H_FRC (ADDQI (tmp_n, 2), opval);
    TRACE_RESULT (current_cpu, abuf, "frc-add--DFLT-n-2", 'f', opval);
  }
  tmp_res = sh64_fmuls (current_cpu, GET_H_XF (((UINT) 3)), GET_H_FRC (tmp_n));
  tmp_res = sh64_fadds (current_cpu, tmp_res, sh64_fmuls (current_cpu, GET_H_XF (((UINT) 7)), GET_H_FRC (ADDQI (tmp_n, 1))));
  tmp_res = sh64_fadds (current_cpu, tmp_res, sh64_fmuls (current_cpu, GET_H_XF (((UINT) 11)), GET_H_FRC (ADDQI (tmp_n, 2))));
  tmp_res = sh64_fadds (current_cpu, tmp_res, sh64_fmuls (current_cpu, GET_H_XF (((UINT) 15)), GET_H_FRC (ADDQI (tmp_n, 3))));
  {
    SF opval = tmp_res;
    SET_H_FRC (ADDQI (tmp_n, 3), opval);
    TRACE_RESULT (current_cpu, abuf, "frc-add--DFLT-n-3", 'f', opval);
d2317 2
d2320 1
d2325 1
a2325 1
  CASE (sem, INSN_JMP_COMPACT) : /* jmp @@$rn */
d2336 14
d2355 42
a2396 1
}
a2397 1
  SEM_BRANCH_FINI (vpc);
d2402 1
a2402 1
  CASE (sem, INSN_JSR_COMPACT) : /* jsr @@$rn */
a2408 1
  SEM_BRANCH_INIT
a2410 2
{
{
d2412 3
a2414 8
    SI opval = ADDDI (pc, 4);
    SET_H_PR (opval);
    TRACE_RESULT (current_cpu, abuf, "pr", 'x', opval);
  }
  {
    UDI opval = GET_H_GRC (FLD (f_rn));
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
a2415 2
}
}
a2416 1
  SEM_BRANCH_FINI (vpc);
d2421 1
a2421 1
  CASE (sem, INSN_LDC_COMPACT) : /* ldc $rn, gbr */
d2430 1
d2432 1
a2432 1
    SI opval = GET_H_GRC (FLD (f_rn));
d2436 6
d2447 1
a2447 1
  CASE (sem, INSN_LDCL_COMPACT) : /* ldc.l @@${rn}+, gbr */
d2459 2
a2460 2
    SET_H_GBR (opval);
    TRACE_RESULT (current_cpu, abuf, "gbr", 'x', opval);
d2465 1
a2465 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d2484 1
a2484 1
    SET_H_FPCCR (opval);
d2504 1
a2504 1
    SET_H_FPCCR (opval);
d2510 1
a2510 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d2530 1
a2530 1
    TRACE_RESULT (current_cpu, abuf, "fpul", 'f', opval);
d2550 1
a2550 1
    TRACE_RESULT (current_cpu, abuf, "fpul", 'f', opval);
d2555 1
a2555 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d2600 1
a2600 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d2645 1
a2645 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d2690 1
a2690 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d2702 1
a2702 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d2717 1
a2717 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d2724 1
a2724 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d2730 1
a2730 1
    TRACE_RESULT (current_cpu, abuf, "rm", 'x', opval);
d2739 1
a2739 1
    TRACE_RESULT (current_cpu, abuf, "rm", 'x', opval);
d2782 1
a2782 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d2797 1
a2797 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d2804 1
a2804 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d2810 1
a2810 1
    TRACE_RESULT (current_cpu, abuf, "rm", 'x', opval);
d2819 1
a2819 1
    TRACE_RESULT (current_cpu, abuf, "rm", 'x', opval);
d2868 1
a2868 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d2876 1
a2876 1
    TRACE_RESULT (current_cpu, abuf, "rn64", 'D', opval);
d2895 20
a2914 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d2925 1
a2925 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d2944 1
a2944 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d2960 1
a2960 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d2972 1
a2972 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3037 1
a3037 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3045 1
a3045 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d3056 1
a3056 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3069 1
a3069 1
    TRACE_RESULT (current_cpu, abuf, "rm", 'x', opval);
d3076 1
a3076 1
    TRACE_RESULT (current_cpu, abuf, "rm", 'x', opval);
d3082 1
a3082 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d3095 1
a3095 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3103 1
a3103 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d3122 1
a3122 1
    TRACE_RESULT (current_cpu, abuf, "r0", 'x', opval);
d3141 1
a3141 1
    TRACE_RESULT (current_cpu, abuf, "r0", 'x', opval);
d3152 1
a3152 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3171 1
a3171 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3187 1
a3187 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d3199 1
a3199 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3256 1
a3256 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3264 1
a3264 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d3275 1
a3275 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3284 1
a3284 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d3291 1
a3291 1
    TRACE_RESULT (current_cpu, abuf, "rm", 'x', opval);
d3298 1
a3298 1
    TRACE_RESULT (current_cpu, abuf, "rm", 'x', opval);
d3312 1
a3312 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3320 1
a3320 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d3339 1
a3339 1
    TRACE_RESULT (current_cpu, abuf, "r0", 'x', opval);
d3358 1
a3358 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d3377 39
a3415 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d3426 1
a3426 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3445 1
a3445 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3461 1
a3461 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d3473 1
a3473 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3507 1
a3507 1
  CASE (sem, INSN_MOVW5_COMPACT) : /* mov.w r0, @@($imm4x2, $rn) */
d3518 1
a3518 1
    SETMEMHI (current_cpu, pc, ADDSI (GET_H_GRC (FLD (f_rn)), FLD (f_imm4x2)), opval);
d3530 1
a3530 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3538 1
a3538 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d3549 1
a3549 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3562 1
a3562 1
    TRACE_RESULT (current_cpu, abuf, "rm", 'x', opval);
d3569 1
a3569 1
    TRACE_RESULT (current_cpu, abuf, "rm", 'x', opval);
d3575 1
a3575 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d3588 1
a3588 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3596 1
a3596 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d3615 1
a3615 1
    TRACE_RESULT (current_cpu, abuf, "r0", 'x', opval);
d3634 1
a3634 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d3645 1
a3645 1
#define FLD(f) abuf->fields.sfmt_movw11_compact.f
d3653 1
a3653 1
    TRACE_RESULT (current_cpu, abuf, "r0", 'x', opval);
d3672 1
a3672 1
    TRACE_RESULT (current_cpu, abuf, "r0", 'x', opval);
d3698 19
d3729 45
a3773 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d3775 1
d3785 1
a3785 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3804 1
a3804 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3823 1
a3823 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3842 1
a3842 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3850 1
a3850 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d3861 1
a3861 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3872 1
a3872 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d3904 1
a3904 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3912 1
a3912 1
    TRACE_RESULT (current_cpu, abuf, "rn64", 'D', opval);
d3923 1
a3923 1
#define FLD(f) abuf->fields.fmt_empty.f
d3928 6
d3935 1
d3945 1
a3945 1
#define FLD(f) abuf->fields.fmt_empty.f
d3950 6
d3957 1
d3967 1
a3967 1
#define FLD(f) abuf->fields.fmt_empty.f
d3972 6
d3979 1
d3989 1
a3989 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3997 1
a3997 1
    TRACE_RESULT (current_cpu, abuf, "rn64", 'D', opval);
d4016 1
a4016 1
    TRACE_RESULT (current_cpu, abuf, "r0", 'x', opval);
d4052 1
a4052 1
#define FLD(f) abuf->fields.fmt_empty.f
d4057 1
a4057 1
((void) 0); /*nop*/
d4078 1
a4078 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4108 1
a4108 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4136 1
a4136 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4166 1
a4166 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4191 7
d4203 2
d4253 1
a4253 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d4259 2
a4260 2
  QI tmp_shamt;
  tmp_shamt = ANDQI (GET_H_GRC (FLD (f_rm)), 31);
d4265 2
a4266 2
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4269 1
a4269 1
if (NEQI (tmp_shamt, 0)) {
d4273 2
a4274 2
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4281 2
a4282 2
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4288 2
a4289 2
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4316 1
a4316 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4344 1
a4344 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4361 1
a4361 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d4367 2
a4368 2
  QI tmp_shamt;
  tmp_shamt = ANDQI (GET_H_GRC (FLD (f_rm)), 31);
d4373 2
a4374 2
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4377 1
a4377 1
if (NEQI (tmp_shamt, 0)) {
d4381 2
a4382 2
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4388 2
a4389 2
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4415 1
a4415 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4440 1
a4440 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4459 1
a4459 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4478 1
a4478 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4500 1
a4500 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4525 1
a4525 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4544 1
a4544 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4563 1
a4563 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4582 20
a4601 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4628 29
a4656 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4674 1
a4674 1
    SI opval = GET_H_FPCCR ();
d4676 1
a4676 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4696 1
a4696 1
    SI opval = GET_H_FPCCR ();
d4703 1
a4703 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4723 1
a4723 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4750 1
a4750 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4770 1
a4770 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4797 1
a4797 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4817 1
a4817 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4844 1
a4844 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4864 1
a4864 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4891 1
a4891 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4903 1
a4903 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d4911 1
a4911 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4922 1
a4922 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d4933 1
a4933 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4950 1
a4950 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d4961 1
a4961 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4978 1
a4978 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d4993 1
a4993 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d5005 1
a5005 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d5013 1
a5013 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d5068 1
a5068 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d5129 1
a5129 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d5137 1
a5137 1
    TRACE_RESULT (current_cpu, abuf, "rn64", 'D', opval);
d5154 3
a5156 3
    DI opval = XORDI (GET_H_GR (((UINT) 0)), ZEXTSIDI (FLD (f_imm8)));
    SET_H_GR (((UINT) 0), opval);
    TRACE_RESULT (current_cpu, abuf, "gr-0", 'D', opval);
d5192 1
a5192 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d5200 1
a5200 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
@

