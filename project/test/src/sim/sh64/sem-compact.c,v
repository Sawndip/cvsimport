head	1.9;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.9
	gdb_7_6-2013-04-26-release:1.9
	gdb_7_6-branch:1.9.0.2
	gdb_7_6-2013-03-12-branchpoint:1.9
	gdb_7_5_1-2012-11-29-release:1.7
	gdb_7_5-2012-08-17-release:1.7
	gdb_7_5-branch:1.7.0.2
	gdb_7_5-2012-07-18-branchpoint:1.7
	gdb_7_4_1-2012-04-26-release:1.6.8.1
	gdb_7_4-2012-01-24-release:1.6.8.1
	gdb_7_4-branch:1.6.0.8
	gdb_7_4-2011-12-13-branchpoint:1.6
	gdb_7_3_1-2011-09-04-release:1.6
	gdb_7_3-2011-07-26-release:1.6
	gdb_7_3-branch:1.6.0.6
	gdb_7_3-2011-04-01-branchpoint:1.6
	gdb_7_2-2010-09-02-release:1.6
	gdb_7_2-branch:1.6.0.4
	gdb_7_2-2010-07-07-branchpoint:1.6
	gdb_7_1-2010-03-18-release:1.6
	gdb_7_1-branch:1.6.0.2
	gdb_7_1-2010-02-18-branchpoint:1.6
	gdb_7_0_1-2009-12-22-release:1.3
	gdb_7_0-2009-10-06-release:1.3
	gdb_7_0-branch:1.3.0.22
	gdb_7_0-2009-09-16-branchpoint:1.3
	arc-sim-20090309:1.3
	msnyder-checkpoint-072509-branch:1.3.0.20
	msnyder-checkpoint-072509-branchpoint:1.3
	arc-insight_6_8-branch:1.3.0.18
	arc-insight_6_8-branchpoint:1.3
	insight_6_8-branch:1.3.0.16
	insight_6_8-branchpoint:1.3
	reverse-20081226-branch:1.3.0.14
	reverse-20081226-branchpoint:1.3
	multiprocess-20081120-branch:1.3.0.12
	multiprocess-20081120-branchpoint:1.3
	reverse-20080930-branch:1.3.0.10
	reverse-20080930-branchpoint:1.3
	reverse-20080717-branch:1.3.0.8
	reverse-20080717-branchpoint:1.3
	msnyder-reverse-20080609-branch:1.3.0.6
	msnyder-reverse-20080609-branchpoint:1.3
	drow-reverse-20070409-branch:1.2.0.2
	drow-reverse-20070409-branchpoint:1.2
	gdb_6_8-2008-03-27-release:1.3
	gdb_6_8-branch:1.3.0.4
	gdb_6_8-2008-02-26-branchpoint:1.3
	gdb_6_7_1-2007-10-29-release:1.3
	gdb_6_7-2007-10-10-release:1.3
	gdb_6_7-branch:1.3.0.2
	gdb_6_7-2007-09-07-branchpoint:1.3
	gdb-csl-arm-20051020-branch:1.1.0.2
	gdb-csl-arm-20051020-branchpoint:1.1;
locks; strict;
comment	@ * @;


1.9
date	2013.01.01.06.41.40;	author brobecke;	state Exp;
branches;
next	1.8;

1.8
date	2012.12.19.07.18.22;	author brobecke;	state Exp;
branches;
next	1.7;

1.7
date	2012.01.04.08.28.25;	author brobecke;	state Exp;
branches;
next	1.6;

1.6
date	2010.02.12.02.44.26;	author devans;	state Exp;
branches
	1.6.8.1;
next	1.5;

1.5
date	2010.01.02.19.09.21;	author devans;	state Exp;
branches;
next	1.4;

1.4
date	2009.11.04.04.40.47;	author devans;	state Exp;
branches;
next	1.3;

1.3
date	2007.08.24.14.28.42;	author brobecke;	state Exp;
branches;
next	1.2;

1.2
date	2006.10.18.18.13.22;	author brolley;	state Exp;
branches;
next	1.1;

1.1
date	2002.02.01.11.44.27;	author bje;	state Exp;
branches;
next	;

1.6.8.1
date	2012.01.06.04.54.56;	author brobecke;	state Exp;
branches;
next	;


desc
@@


1.9
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* Simulator instruction semantics for sh64.

THIS FILE IS MACHINE GENERATED WITH CGEN.

Copyright 1996-2013 Free Software Foundation, Inc.

This file is part of the GNU simulators.

   This file is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License along
   with this program; if not, see <http://www.gnu.org/licenses/>.

*/

#define WANT_CPU sh64
#define WANT_CPU_SH64

#include "sim-main.h"
#include "cgen-mem.h"
#include "cgen-ops.h"

#undef GET_ATTR
#define GET_ATTR(cpu, num, attr) CGEN_ATTR_VALUE (NULL, abuf->idesc->attrs, CGEN_INSN_##attr)

/* This is used so that we can compile two copies of the semantic code,
   one with full feature support and one without that runs fast(er).
   FAST_P, when desired, is defined on the command line, -DFAST_P=1.  */
#if FAST_P
#define SEM_FN_NAME(cpu,fn) XCONCAT3 (cpu,_semf_,fn)
#undef TRACE_RESULT
#define TRACE_RESULT(cpu, abuf, name, type, val)
#else
#define SEM_FN_NAME(cpu,fn) XCONCAT3 (cpu,_sem_,fn)
#endif

/* x-invalid: --invalid-- */

static SEM_PC
SEM_FN_NAME (sh64_compact,x_invalid) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  {
    /* Update the recorded pc in the cpu state struct.
       Only necessary for WITH_SCACHE case, but to avoid the
       conditional compilation ....  */
    SET_H_PC (pc);
    /* Virtual insns have zero size.  Overwrite vpc with address of next insn
       using the default-insn-bitsize spec.  When executing insns in parallel
       we may want to queue the fault and continue execution.  */
    vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
    vpc = sim_engine_invalid_insn (current_cpu, pc, vpc);
  }

  return vpc;
#undef FLD
}

/* x-after: --after-- */

static SEM_PC
SEM_FN_NAME (sh64_compact,x_after) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  {
#if WITH_SCACHE_PBB_SH64_COMPACT
    sh64_compact_pbb_after (current_cpu, sem_arg);
#endif
  }

  return vpc;
#undef FLD
}

/* x-before: --before-- */

static SEM_PC
SEM_FN_NAME (sh64_compact,x_before) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  {
#if WITH_SCACHE_PBB_SH64_COMPACT
    sh64_compact_pbb_before (current_cpu, sem_arg);
#endif
  }

  return vpc;
#undef FLD
}

/* x-cti-chain: --cti-chain-- */

static SEM_PC
SEM_FN_NAME (sh64_compact,x_cti_chain) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  {
#if WITH_SCACHE_PBB_SH64_COMPACT
#ifdef DEFINE_SWITCH
    vpc = sh64_compact_pbb_cti_chain (current_cpu, sem_arg,
			       pbb_br_type, pbb_br_npc);
    BREAK (sem);
#else
    /* FIXME: Allow provision of explicit ifmt spec in insn spec.  */
    vpc = sh64_compact_pbb_cti_chain (current_cpu, sem_arg,
			       CPU_PBB_BR_TYPE (current_cpu),
			       CPU_PBB_BR_NPC (current_cpu));
#endif
#endif
  }

  return vpc;
#undef FLD
}

/* x-chain: --chain-- */

static SEM_PC
SEM_FN_NAME (sh64_compact,x_chain) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  {
#if WITH_SCACHE_PBB_SH64_COMPACT
    vpc = sh64_compact_pbb_chain (current_cpu, sem_arg);
#ifdef DEFINE_SWITCH
    BREAK (sem);
#endif
#endif
  }

  return vpc;
#undef FLD
}

/* x-begin: --begin-- */

static SEM_PC
SEM_FN_NAME (sh64_compact,x_begin) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  {
#if WITH_SCACHE_PBB_SH64_COMPACT
#if defined DEFINE_SWITCH || defined FAST_P
    /* In the switch case FAST_P is a constant, allowing several optimizations
       in any called inline functions.  */
    vpc = sh64_compact_pbb_begin (current_cpu, FAST_P);
#else
#if 0 /* cgen engine can't handle dynamic fast/full switching yet.  */
    vpc = sh64_compact_pbb_begin (current_cpu, STATE_RUN_FAST_P (CPU_STATE (current_cpu)));
#else
    vpc = sh64_compact_pbb_begin (current_cpu, 0);
#endif
#endif
#endif
  }

  return vpc;
#undef FLD
}

/* add-compact: add $rm, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,add_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rn)), GET_H_GRC (FLD (f_rm)));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* addi-compact: add #$imm8, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,addi_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_addi_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rn)), EXTQISI (ANDQI (FLD (f_imm8), 255)));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* addc-compact: addc $rm, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,addc_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  BI tmp_flag;
  tmp_flag = ADDCFSI (GET_H_GRC (FLD (f_rn)), GET_H_GRC (FLD (f_rm)), GET_H_TBIT ());
  {
    SI opval = ADDCSI (GET_H_GRC (FLD (f_rn)), GET_H_GRC (FLD (f_rm)), GET_H_TBIT ());
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  {
    BI opval = tmp_flag;
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* addv-compact: addv $rm, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,addv_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  BI tmp_t;
  tmp_t = ADDOFSI (GET_H_GRC (FLD (f_rn)), GET_H_GRC (FLD (f_rm)), 0);
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rn)), GET_H_GRC (FLD (f_rm)));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  {
    BI opval = tmp_t;
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* and-compact: and $rm64, $rn64 */

static SEM_PC
SEM_FN_NAME (sh64_compact,and_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = ANDDI (GET_H_GR (FLD (f_rm)), GET_H_GR (FLD (f_rn)));
    SET_H_GR (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'D', opval);
  }

  return vpc;
#undef FLD
}

/* andi-compact: and #$uimm8, r0 */

static SEM_PC
SEM_FN_NAME (sh64_compact,andi_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_addi_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ANDSI (GET_H_GRC (((UINT) 0)), ZEXTSIDI (FLD (f_imm8)));
    SET_H_GRC (((UINT) 0), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* andb-compact: and.b #$imm8, @@(r0, gbr) */

static SEM_PC
SEM_FN_NAME (sh64_compact,andb_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_addi_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_addr;
  UQI tmp_data;
  tmp_addr = ADDSI (GET_H_GRC (((UINT) 0)), GET_H_GBR ());
  tmp_data = ANDQI (GETMEMUQI (current_cpu, pc, tmp_addr), FLD (f_imm8));
  {
    UQI opval = tmp_data;
    SETMEMUQI (current_cpu, pc, tmp_addr, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* bf-compact: bf $disp8 */

static SEM_PC
SEM_FN_NAME (sh64_compact,bf_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bf_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (NOTBI (GET_H_TBIT ())) {
  {
    UDI opval = FLD (i_disp8);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bfs-compact: bf/s $disp8 */

static SEM_PC
SEM_FN_NAME (sh64_compact,bfs_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bf_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (NOTBI (GET_H_TBIT ())) {
{
  {
    UDI opval = ADDDI (pc, 2);
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
((void) 0); /*nop*/
{
  {
    UDI opval = FLD (i_disp8);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
}
}
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bra-compact: bra $disp12 */

static SEM_PC
SEM_FN_NAME (sh64_compact,bra_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bra_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    UDI opval = ADDDI (pc, 2);
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
((void) 0); /*nop*/
{
  {
    UDI opval = FLD (i_disp12);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
}
}

  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* braf-compact: braf $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,braf_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    UDI opval = ADDDI (pc, 2);
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
((void) 0); /*nop*/
{
  {
    UDI opval = ADDDI (EXTSIDI (GET_H_GRC (FLD (f_rn))), ADDDI (pc, 4));
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
}
}

  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* brk-compact: brk */

static SEM_PC
SEM_FN_NAME (sh64_compact,brk_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

sh64_break (current_cpu, pc);

  return vpc;
#undef FLD
}

/* bsr-compact: bsr $disp12 */

static SEM_PC
SEM_FN_NAME (sh64_compact,bsr_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bra_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
{
  {
    SI opval = ADDDI (pc, 4);
    SET_H_PR (opval);
    TRACE_RESULT (current_cpu, abuf, "pr", 'x', opval);
  }
}
  {
    UDI opval = ADDDI (pc, 2);
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
((void) 0); /*nop*/
{
  {
    UDI opval = FLD (i_disp12);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
}
}

  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bsrf-compact: bsrf $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,bsrf_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
{
  {
    SI opval = ADDDI (pc, 4);
    SET_H_PR (opval);
    TRACE_RESULT (current_cpu, abuf, "pr", 'x', opval);
  }
}
  {
    UDI opval = ADDDI (pc, 2);
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
((void) 0); /*nop*/
{
  {
    UDI opval = ADDDI (EXTSIDI (GET_H_GRC (FLD (f_rn))), ADDDI (pc, 4));
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
}
}

  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bt-compact: bt $disp8 */

static SEM_PC
SEM_FN_NAME (sh64_compact,bt_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bf_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (GET_H_TBIT ()) {
  {
    UDI opval = FLD (i_disp8);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* bts-compact: bt/s $disp8 */

static SEM_PC
SEM_FN_NAME (sh64_compact,bts_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_bf_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (GET_H_TBIT ()) {
{
  {
    UDI opval = ADDDI (pc, 2);
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
((void) 0); /*nop*/
{
  {
    UDI opval = FLD (i_disp8);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
}
}
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* clrmac-compact: clrmac */

static SEM_PC
SEM_FN_NAME (sh64_compact,clrmac_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    SI opval = 0;
    SET_H_MACL (opval);
    TRACE_RESULT (current_cpu, abuf, "macl", 'x', opval);
  }
  {
    SI opval = 0;
    SET_H_MACH (opval);
    TRACE_RESULT (current_cpu, abuf, "mach", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* clrs-compact: clrs */

static SEM_PC
SEM_FN_NAME (sh64_compact,clrs_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = 0;
    SET_H_SBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "sbit", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* clrt-compact: clrt */

static SEM_PC
SEM_FN_NAME (sh64_compact,clrt_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = 0;
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* cmpeq-compact: cmp/eq $rm, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,cmpeq_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = EQSI (GET_H_GRC (FLD (f_rm)), GET_H_GRC (FLD (f_rn)));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* cmpeqi-compact: cmp/eq #$imm8, r0 */

static SEM_PC
SEM_FN_NAME (sh64_compact,cmpeqi_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_addi_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = EQSI (GET_H_GRC (((UINT) 0)), EXTQISI (ANDQI (FLD (f_imm8), 255)));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* cmpge-compact: cmp/ge $rm, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,cmpge_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = GESI (GET_H_GRC (FLD (f_rn)), GET_H_GRC (FLD (f_rm)));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* cmpgt-compact: cmp/gt $rm, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,cmpgt_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = GTSI (GET_H_GRC (FLD (f_rn)), GET_H_GRC (FLD (f_rm)));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* cmphi-compact: cmp/hi $rm, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,cmphi_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = GTUSI (GET_H_GRC (FLD (f_rn)), GET_H_GRC (FLD (f_rm)));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* cmphs-compact: cmp/hs $rm, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,cmphs_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = GEUSI (GET_H_GRC (FLD (f_rn)), GET_H_GRC (FLD (f_rm)));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* cmppl-compact: cmp/pl $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,cmppl_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = GTSI (GET_H_GRC (FLD (f_rn)), 0);
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* cmppz-compact: cmp/pz $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,cmppz_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = GESI (GET_H_GRC (FLD (f_rn)), 0);
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* cmpstr-compact: cmp/str $rm, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,cmpstr_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  BI tmp_t;
  SI tmp_temp;
  tmp_temp = XORSI (GET_H_GRC (FLD (f_rm)), GET_H_GRC (FLD (f_rn)));
  tmp_t = EQSI (ANDSI (tmp_temp, 0xff000000), 0);
  tmp_t = ORBI (EQSI (ANDSI (tmp_temp, 16711680), 0), tmp_t);
  tmp_t = ORBI (EQSI (ANDSI (tmp_temp, 65280), 0), tmp_t);
  tmp_t = ORBI (EQSI (ANDSI (tmp_temp, 255), 0), tmp_t);
  {
    BI opval = ((GTUBI (tmp_t, 0)) ? (1) : (0));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* div0s-compact: div0s $rm, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,div0s_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    BI opval = SRLSI (GET_H_GRC (FLD (f_rn)), 31);
    SET_H_QBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "qbit", 'x', opval);
  }
  {
    BI opval = SRLSI (GET_H_GRC (FLD (f_rm)), 31);
    SET_H_MBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "mbit", 'x', opval);
  }
  {
    BI opval = ((EQSI (SRLSI (GET_H_GRC (FLD (f_rm)), 31), SRLSI (GET_H_GRC (FLD (f_rn)), 31))) ? (0) : (1));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* div0u-compact: div0u */

static SEM_PC
SEM_FN_NAME (sh64_compact,div0u_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    BI opval = 0;
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
  {
    BI opval = 0;
    SET_H_QBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "qbit", 'x', opval);
  }
  {
    BI opval = 0;
    SET_H_MBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "mbit", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* div1-compact: div1 $rm, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,div1_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  BI tmp_oldq;
  SI tmp_tmp0;
  UQI tmp_tmp1;
  tmp_oldq = GET_H_QBIT ();
  {
    BI opval = SRLSI (GET_H_GRC (FLD (f_rn)), 31);
    SET_H_QBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "qbit", 'x', opval);
  }
  {
    SI opval = ORSI (SLLSI (GET_H_GRC (FLD (f_rn)), 1), ZEXTBISI (GET_H_TBIT ()));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
if (NOTBI (tmp_oldq)) {
if (NOTBI (GET_H_MBIT ())) {
{
  tmp_tmp0 = GET_H_GRC (FLD (f_rn));
  {
    SI opval = SUBSI (GET_H_GRC (FLD (f_rn)), GET_H_GRC (FLD (f_rm)));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  tmp_tmp1 = GTUSI (GET_H_GRC (FLD (f_rn)), tmp_tmp0);
if (NOTBI (GET_H_QBIT ())) {
  {
    BI opval = ((tmp_tmp1) ? (1) : (0));
    SET_H_QBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "qbit", 'x', opval);
  }
} else {
  {
    BI opval = ((EQQI (tmp_tmp1, 0)) ? (1) : (0));
    SET_H_QBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "qbit", 'x', opval);
  }
}
}
} else {
{
  tmp_tmp0 = GET_H_GRC (FLD (f_rn));
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rn)), GET_H_GRC (FLD (f_rm)));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  tmp_tmp1 = LTUSI (GET_H_GRC (FLD (f_rn)), tmp_tmp0);
if (NOTBI (GET_H_QBIT ())) {
  {
    BI opval = ((EQQI (tmp_tmp1, 0)) ? (1) : (0));
    SET_H_QBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "qbit", 'x', opval);
  }
} else {
  {
    BI opval = ((tmp_tmp1) ? (1) : (0));
    SET_H_QBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "qbit", 'x', opval);
  }
}
}
}
} else {
if (NOTBI (GET_H_MBIT ())) {
{
  tmp_tmp0 = GET_H_GRC (FLD (f_rn));
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rm)), GET_H_GRC (FLD (f_rn)));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  tmp_tmp1 = LTUSI (GET_H_GRC (FLD (f_rn)), tmp_tmp0);
if (NOTBI (GET_H_QBIT ())) {
  {
    BI opval = ((tmp_tmp1) ? (1) : (0));
    SET_H_QBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "qbit", 'x', opval);
  }
} else {
  {
    BI opval = ((EQQI (tmp_tmp1, 0)) ? (1) : (0));
    SET_H_QBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "qbit", 'x', opval);
  }
}
}
} else {
{
  tmp_tmp0 = GET_H_GRC (FLD (f_rn));
  {
    SI opval = SUBSI (GET_H_GRC (FLD (f_rn)), GET_H_GRC (FLD (f_rm)));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  tmp_tmp1 = GTUSI (GET_H_GRC (FLD (f_rn)), tmp_tmp0);
if (NOTBI (GET_H_QBIT ())) {
  {
    BI opval = ((EQQI (tmp_tmp1, 0)) ? (1) : (0));
    SET_H_QBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "qbit", 'x', opval);
  }
} else {
  {
    BI opval = ((tmp_tmp1) ? (1) : (0));
    SET_H_QBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "qbit", 'x', opval);
  }
}
}
}
}
  {
    BI opval = ((EQBI (GET_H_QBIT (), GET_H_MBIT ())) ? (1) : (0));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* divu-compact: divu r0, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,divu_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = UDIVSI (GET_H_GRC (FLD (f_rn)), GET_H_GRC (((UINT) 0)));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* mulr-compact: mulr r0, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,mulr_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = MULSI (GET_H_GRC (FLD (f_rn)), GET_H_GRC (((UINT) 0)));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* dmulsl-compact: dmuls.l $rm, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,dmulsl_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_result;
  tmp_result = MULDI (EXTSIDI (GET_H_GRC (FLD (f_rm))), EXTSIDI (GET_H_GRC (FLD (f_rn))));
  {
    SI opval = SUBWORDDISI (tmp_result, 0);
    SET_H_MACH (opval);
    TRACE_RESULT (current_cpu, abuf, "mach", 'x', opval);
  }
  {
    SI opval = SUBWORDDISI (tmp_result, 1);
    SET_H_MACL (opval);
    TRACE_RESULT (current_cpu, abuf, "macl", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* dmulul-compact: dmulu.l $rm, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,dmulul_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_result;
  tmp_result = MULDI (ZEXTSIDI (GET_H_GRC (FLD (f_rm))), ZEXTSIDI (GET_H_GRC (FLD (f_rn))));
  {
    SI opval = SUBWORDDISI (tmp_result, 0);
    SET_H_MACH (opval);
    TRACE_RESULT (current_cpu, abuf, "mach", 'x', opval);
  }
  {
    SI opval = SUBWORDDISI (tmp_result, 1);
    SET_H_MACL (opval);
    TRACE_RESULT (current_cpu, abuf, "macl", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* dt-compact: dt $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,dt_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    SI opval = SUBSI (GET_H_GRC (FLD (f_rn)), 1);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  {
    BI opval = EQSI (GET_H_GRC (FLD (f_rn)), 0);
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* extsb-compact: exts.b $rm, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,extsb_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = EXTQISI (SUBWORDSIQI (GET_H_GRC (FLD (f_rm)), 3));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* extsw-compact: exts.w $rm, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,extsw_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = EXTHISI (SUBWORDSIHI (GET_H_GRC (FLD (f_rm)), 1));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* extub-compact: extu.b $rm, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,extub_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ZEXTQISI (SUBWORDSIQI (GET_H_GRC (FLD (f_rm)), 3));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* extuw-compact: extu.w $rm, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,extuw_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ZEXTHISI (SUBWORDSIHI (GET_H_GRC (FLD (f_rm)), 1));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* fabs-compact: fabs $fsdn */

static SEM_PC
SEM_FN_NAME (sh64_compact,fabs_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (GET_H_PRBIT ()) {
  {
    DF opval = sh64_fabsd (current_cpu, GET_H_FSD (FLD (f_rn)));
    SET_H_FSD (FLD (f_rn), opval);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "fsd", 'f', opval);
  }
} else {
  {
    DF opval = sh64_fabss (current_cpu, GET_H_FSD (FLD (f_rn)));
    SET_H_FSD (FLD (f_rn), opval);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "fsd", 'f', opval);
  }
}

  abuf->written = written;
  return vpc;
#undef FLD
}

/* fadd-compact: fadd $fsdm, $fsdn */

static SEM_PC
SEM_FN_NAME (sh64_compact,fadd_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (GET_H_PRBIT ()) {
  {
    DF opval = sh64_faddd (current_cpu, GET_H_FSD (FLD (f_rm)), GET_H_FSD (FLD (f_rn)));
    SET_H_FSD (FLD (f_rn), opval);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "fsd", 'f', opval);
  }
} else {
  {
    DF opval = sh64_fadds (current_cpu, GET_H_FSD (FLD (f_rm)), GET_H_FSD (FLD (f_rn)));
    SET_H_FSD (FLD (f_rn), opval);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "fsd", 'f', opval);
  }
}

  abuf->written = written;
  return vpc;
#undef FLD
}

/* fcmpeq-compact: fcmp/eq $fsdm, $fsdn */

static SEM_PC
SEM_FN_NAME (sh64_compact,fcmpeq_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (GET_H_PRBIT ()) {
  {
    BI opval = sh64_fcmpeqd (current_cpu, GET_H_FSD (FLD (f_rm)), GET_H_FSD (FLD (f_rn)));
    SET_H_TBIT (opval);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
} else {
  {
    BI opval = sh64_fcmpeqs (current_cpu, GET_H_FSD (FLD (f_rm)), GET_H_FSD (FLD (f_rn)));
    SET_H_TBIT (opval);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

  abuf->written = written;
  return vpc;
#undef FLD
}

/* fcmpgt-compact: fcmp/gt $fsdm, $fsdn */

static SEM_PC
SEM_FN_NAME (sh64_compact,fcmpgt_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (GET_H_PRBIT ()) {
  {
    BI opval = sh64_fcmpgtd (current_cpu, GET_H_FSD (FLD (f_rn)), GET_H_FSD (FLD (f_rm)));
    SET_H_TBIT (opval);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
} else {
  {
    BI opval = sh64_fcmpgts (current_cpu, GET_H_FSD (FLD (f_rn)), GET_H_FSD (FLD (f_rm)));
    SET_H_TBIT (opval);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

  abuf->written = written;
  return vpc;
#undef FLD
}

/* fcnvds-compact: fcnvds $drn, fpul */

static SEM_PC
SEM_FN_NAME (sh64_compact,fcnvds_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_fmov8_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SF opval = sh64_fcnvds (current_cpu, GET_H_DRC (FLD (f_dn)));
    CPU (h_fr[((UINT) 32)]) = opval;
    TRACE_RESULT (current_cpu, abuf, "fr", 'f', opval);
  }

  return vpc;
#undef FLD
}

/* fcnvsd-compact: fcnvsd fpul, $drn */

static SEM_PC
SEM_FN_NAME (sh64_compact,fcnvsd_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_fmov8_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DF opval = sh64_fcnvsd (current_cpu, CPU (h_fr[((UINT) 32)]));
    SET_H_DRC (FLD (f_dn), opval);
    TRACE_RESULT (current_cpu, abuf, "drc", 'f', opval);
  }

  return vpc;
#undef FLD
}

/* fdiv-compact: fdiv $fsdm, $fsdn */

static SEM_PC
SEM_FN_NAME (sh64_compact,fdiv_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (GET_H_PRBIT ()) {
  {
    DF opval = sh64_fdivd (current_cpu, GET_H_FSD (FLD (f_rn)), GET_H_FSD (FLD (f_rm)));
    SET_H_FSD (FLD (f_rn), opval);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "fsd", 'f', opval);
  }
} else {
  {
    DF opval = sh64_fdivs (current_cpu, GET_H_FSD (FLD (f_rn)), GET_H_FSD (FLD (f_rm)));
    SET_H_FSD (FLD (f_rn), opval);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "fsd", 'f', opval);
  }
}

  abuf->written = written;
  return vpc;
#undef FLD
}

/* fipr-compact: fipr $fvm, $fvn */

static SEM_PC
SEM_FN_NAME (sh64_compact,fipr_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_fipr_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

sh64_fipr (current_cpu, FLD (f_vm), FLD (f_vn));

  return vpc;
#undef FLD
}

/* flds-compact: flds $frn, fpul */

static SEM_PC
SEM_FN_NAME (sh64_compact,flds_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SF opval = GET_H_FRC (FLD (f_rn));
    CPU (h_fr[((UINT) 32)]) = opval;
    TRACE_RESULT (current_cpu, abuf, "fr", 'f', opval);
  }

  return vpc;
#undef FLD
}

/* fldi0-compact: fldi0 $frn */

static SEM_PC
SEM_FN_NAME (sh64_compact,fldi0_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SF opval = sh64_fldi0 (current_cpu);
    SET_H_FRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "frc", 'f', opval);
  }

  return vpc;
#undef FLD
}

/* fldi1-compact: fldi1 $frn */

static SEM_PC
SEM_FN_NAME (sh64_compact,fldi1_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SF opval = sh64_fldi1 (current_cpu);
    SET_H_FRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "frc", 'f', opval);
  }

  return vpc;
#undef FLD
}

/* float-compact: float fpul, $fsdn */

static SEM_PC
SEM_FN_NAME (sh64_compact,float_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (GET_H_PRBIT ()) {
  {
    DF opval = sh64_floatld (current_cpu, CPU (h_fr[((UINT) 32)]));
    SET_H_FSD (FLD (f_rn), opval);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "fsd", 'f', opval);
  }
} else {
  {
    DF opval = sh64_floatls (current_cpu, CPU (h_fr[((UINT) 32)]));
    SET_H_FSD (FLD (f_rn), opval);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "fsd", 'f', opval);
  }
}

  abuf->written = written;
  return vpc;
#undef FLD
}

/* fmac-compact: fmac fr0, $frm, $frn */

static SEM_PC
SEM_FN_NAME (sh64_compact,fmac_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SF opval = sh64_fmacs (current_cpu, GET_H_FRC (((UINT) 0)), GET_H_FRC (FLD (f_rm)), GET_H_FRC (FLD (f_rn)));
    SET_H_FRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "frc", 'f', opval);
  }

  return vpc;
#undef FLD
}

/* fmov1-compact: fmov $fmovm, $fmovn */

static SEM_PC
SEM_FN_NAME (sh64_compact,fmov1_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DF opval = GET_H_FMOV (FLD (f_rm));
    SET_H_FMOV (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "fmov", 'f', opval);
  }

  return vpc;
#undef FLD
}

/* fmov2-compact: fmov @@$rm, $fmovn */

static SEM_PC
SEM_FN_NAME (sh64_compact,fmov2_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (NOTBI (GET_H_SZBIT ())) {
  {
    DF opval = GETMEMSF (current_cpu, pc, GET_H_GRC (FLD (f_rm)));
    SET_H_FMOV (FLD (f_rn), opval);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "fmov", 'f', opval);
  }
} else {
  {
    DF opval = GETMEMDF (current_cpu, pc, GET_H_GRC (FLD (f_rm)));
    SET_H_FMOV (FLD (f_rn), opval);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "fmov", 'f', opval);
  }
}

  abuf->written = written;
  return vpc;
#undef FLD
}

/* fmov3-compact: fmov @@${rm}+, fmovn */

static SEM_PC
SEM_FN_NAME (sh64_compact,fmov3_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (NOTBI (GET_H_SZBIT ())) {
{
  {
    DF opval = GETMEMSF (current_cpu, pc, GET_H_GRC (FLD (f_rm)));
    SET_H_FMOV (FLD (f_rn), opval);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "fmov", 'f', opval);
  }
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rm)), 4);
    SET_H_GRC (FLD (f_rm), opval);
    written |= (1 << 5);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}
} else {
{
  {
    DF opval = GETMEMDF (current_cpu, pc, GET_H_GRC (FLD (f_rm)));
    SET_H_FMOV (FLD (f_rn), opval);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "fmov", 'f', opval);
  }
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rm)), 8);
    SET_H_GRC (FLD (f_rm), opval);
    written |= (1 << 5);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}
}

  abuf->written = written;
  return vpc;
#undef FLD
}

/* fmov4-compact: fmov @@(r0, $rm), $fmovn */

static SEM_PC
SEM_FN_NAME (sh64_compact,fmov4_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (NOTBI (GET_H_SZBIT ())) {
  {
    DF opval = GETMEMSF (current_cpu, pc, ADDSI (GET_H_GRC (((UINT) 0)), GET_H_GRC (FLD (f_rm))));
    SET_H_FMOV (FLD (f_rn), opval);
    written |= (1 << 5);
    TRACE_RESULT (current_cpu, abuf, "fmov", 'f', opval);
  }
} else {
  {
    DF opval = GETMEMDF (current_cpu, pc, ADDSI (GET_H_GRC (((UINT) 0)), GET_H_GRC (FLD (f_rm))));
    SET_H_FMOV (FLD (f_rn), opval);
    written |= (1 << 5);
    TRACE_RESULT (current_cpu, abuf, "fmov", 'f', opval);
  }
}

  abuf->written = written;
  return vpc;
#undef FLD
}

/* fmov5-compact: fmov $fmovm, @@$rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,fmov5_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (NOTBI (GET_H_SZBIT ())) {
  {
    SF opval = GET_H_FMOV (FLD (f_rm));
    SETMEMSF (current_cpu, pc, GET_H_GRC (FLD (f_rn)), opval);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "memory", 'f', opval);
  }
} else {
  {
    DF opval = GET_H_FMOV (FLD (f_rm));
    SETMEMDF (current_cpu, pc, GET_H_GRC (FLD (f_rn)), opval);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "memory", 'f', opval);
  }
}

  abuf->written = written;
  return vpc;
#undef FLD
}

/* fmov6-compact: fmov $fmovm, @@-$rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,fmov6_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (NOTBI (GET_H_SZBIT ())) {
{
  {
    SI opval = SUBSI (GET_H_GRC (FLD (f_rn)), 4);
    SET_H_GRC (FLD (f_rn), opval);
    written |= (1 << 5);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  {
    SF opval = GET_H_FMOV (FLD (f_rm));
    SETMEMSF (current_cpu, pc, GET_H_GRC (FLD (f_rn)), opval);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "memory", 'f', opval);
  }
}
} else {
{
  {
    SI opval = SUBSI (GET_H_GRC (FLD (f_rn)), 8);
    SET_H_GRC (FLD (f_rn), opval);
    written |= (1 << 5);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  {
    DF opval = GET_H_FMOV (FLD (f_rm));
    SETMEMDF (current_cpu, pc, GET_H_GRC (FLD (f_rn)), opval);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "memory", 'f', opval);
  }
}
}

  abuf->written = written;
  return vpc;
#undef FLD
}

/* fmov7-compact: fmov $fmovm, @@(r0, $rn) */

static SEM_PC
SEM_FN_NAME (sh64_compact,fmov7_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (NOTBI (GET_H_SZBIT ())) {
  {
    SF opval = GET_H_FMOV (FLD (f_rm));
    SETMEMSF (current_cpu, pc, ADDSI (GET_H_GRC (((UINT) 0)), GET_H_GRC (FLD (f_rn))), opval);
    written |= (1 << 5);
    TRACE_RESULT (current_cpu, abuf, "memory", 'f', opval);
  }
} else {
  {
    DF opval = GET_H_FMOV (FLD (f_rm));
    SETMEMDF (current_cpu, pc, ADDSI (GET_H_GRC (((UINT) 0)), GET_H_GRC (FLD (f_rn))), opval);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "memory", 'f', opval);
  }
}

  abuf->written = written;
  return vpc;
#undef FLD
}

/* fmov8-compact: fmov.d @@($imm12x8, $rm), $drn */

static SEM_PC
SEM_FN_NAME (sh64_compact,fmov8_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_fmov8_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    DF opval = GETMEMDF (current_cpu, pc, ADDSI (GET_H_GRC (FLD (f_rm)), FLD (f_imm12x8)));
    SET_H_DRC (FLD (f_dn), opval);
    TRACE_RESULT (current_cpu, abuf, "drc", 'f', opval);
  }

  return vpc;
#undef FLD
}

/* fmov9-compact: mov.l $drm, @@($imm12x8, $rn) */

static SEM_PC
SEM_FN_NAME (sh64_compact,fmov9_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_fmov9_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    DF opval = GET_H_DRC (FLD (f_dm));
    SETMEMDF (current_cpu, pc, ADDSI (GET_H_GRC (FLD (f_rn)), FLD (f_imm12x8)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'f', opval);
  }

  return vpc;
#undef FLD
}

/* fmul-compact: fmul $fsdm, $fsdn */

static SEM_PC
SEM_FN_NAME (sh64_compact,fmul_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (GET_H_PRBIT ()) {
  {
    DF opval = sh64_fmuld (current_cpu, GET_H_FSD (FLD (f_rm)), GET_H_FSD (FLD (f_rn)));
    SET_H_FSD (FLD (f_rn), opval);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "fsd", 'f', opval);
  }
} else {
  {
    DF opval = sh64_fmuls (current_cpu, GET_H_FSD (FLD (f_rm)), GET_H_FSD (FLD (f_rn)));
    SET_H_FSD (FLD (f_rn), opval);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "fsd", 'f', opval);
  }
}

  abuf->written = written;
  return vpc;
#undef FLD
}

/* fneg-compact: fneg $fsdn */

static SEM_PC
SEM_FN_NAME (sh64_compact,fneg_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (GET_H_PRBIT ()) {
  {
    DF opval = sh64_fnegd (current_cpu, GET_H_FSD (FLD (f_rn)));
    SET_H_FSD (FLD (f_rn), opval);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "fsd", 'f', opval);
  }
} else {
  {
    DF opval = sh64_fnegs (current_cpu, GET_H_FSD (FLD (f_rn)));
    SET_H_FSD (FLD (f_rn), opval);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "fsd", 'f', opval);
  }
}

  abuf->written = written;
  return vpc;
#undef FLD
}

/* frchg-compact: frchg */

static SEM_PC
SEM_FN_NAME (sh64_compact,frchg_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = NOTBI (GET_H_FRBIT ());
    SET_H_FRBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "frbit", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* fschg-compact: fschg */

static SEM_PC
SEM_FN_NAME (sh64_compact,fschg_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = NOTBI (GET_H_SZBIT ());
    SET_H_SZBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "szbit", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* fsqrt-compact: fsqrt $fsdn */

static SEM_PC
SEM_FN_NAME (sh64_compact,fsqrt_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (GET_H_PRBIT ()) {
  {
    DF opval = sh64_fsqrtd (current_cpu, GET_H_FSD (FLD (f_rn)));
    SET_H_FSD (FLD (f_rn), opval);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "fsd", 'f', opval);
  }
} else {
  {
    DF opval = sh64_fsqrts (current_cpu, GET_H_FSD (FLD (f_rn)));
    SET_H_FSD (FLD (f_rn), opval);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "fsd", 'f', opval);
  }
}

  abuf->written = written;
  return vpc;
#undef FLD
}

/* fsts-compact: fsts fpul, $frn */

static SEM_PC
SEM_FN_NAME (sh64_compact,fsts_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SF opval = CPU (h_fr[((UINT) 32)]);
    SET_H_FRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "frc", 'f', opval);
  }

  return vpc;
#undef FLD
}

/* fsub-compact: fsub $fsdm, $fsdn */

static SEM_PC
SEM_FN_NAME (sh64_compact,fsub_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (GET_H_PRBIT ()) {
  {
    DF opval = sh64_fsubd (current_cpu, GET_H_FSD (FLD (f_rn)), GET_H_FSD (FLD (f_rm)));
    SET_H_FSD (FLD (f_rn), opval);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "fsd", 'f', opval);
  }
} else {
  {
    DF opval = sh64_fsubs (current_cpu, GET_H_FSD (FLD (f_rn)), GET_H_FSD (FLD (f_rm)));
    SET_H_FSD (FLD (f_rn), opval);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "fsd", 'f', opval);
  }
}

  abuf->written = written;
  return vpc;
#undef FLD
}

/* ftrc-compact: ftrc $fsdn, fpul */

static SEM_PC
SEM_FN_NAME (sh64_compact,ftrc_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SF opval = ((GET_H_PRBIT ()) ? (sh64_ftrcdl (current_cpu, GET_H_FSD (FLD (f_rn)))) : (sh64_ftrcsl (current_cpu, GET_H_FSD (FLD (f_rn)))));
    CPU (h_fr[((UINT) 32)]) = opval;
    TRACE_RESULT (current_cpu, abuf, "fr", 'f', opval);
  }

  return vpc;
#undef FLD
}

/* ftrv-compact: ftrv xmtrx, $fvn */

static SEM_PC
SEM_FN_NAME (sh64_compact,ftrv_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_fipr_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

sh64_ftrv (current_cpu, FLD (f_vn));

  return vpc;
#undef FLD
}

/* jmp-compact: jmp @@$rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,jmp_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    UDI opval = ADDDI (pc, 2);
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
((void) 0); /*nop*/
{
  {
    UDI opval = GET_H_GRC (FLD (f_rn));
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
}
((void) 0); /*nop*/
}

  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* jsr-compact: jsr @@$rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,jsr_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
{
  {
    SI opval = ADDDI (pc, 4);
    SET_H_PR (opval);
    TRACE_RESULT (current_cpu, abuf, "pr", 'x', opval);
  }
}
  {
    UDI opval = ADDDI (pc, 2);
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
((void) 0); /*nop*/
{
  {
    UDI opval = GET_H_GRC (FLD (f_rn));
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
}
((void) 0); /*nop*/
}

  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* ldc-gbr-compact: ldc $rn, gbr */

static SEM_PC
SEM_FN_NAME (sh64_compact,ldc_gbr_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_GRC (FLD (f_rn));
    SET_H_GBR (opval);
    TRACE_RESULT (current_cpu, abuf, "gbr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* ldc-vbr-compact: ldc $rn, vbr */

static SEM_PC
SEM_FN_NAME (sh64_compact,ldc_vbr_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_GRC (FLD (f_rn));
    SET_H_VBR (opval);
    TRACE_RESULT (current_cpu, abuf, "vbr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* ldc-sr-compact: ldc $rn, sr */

static SEM_PC
SEM_FN_NAME (sh64_compact,ldc_sr_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_GRC (FLD (f_rn));
    CPU (h_sr) = opval;
    TRACE_RESULT (current_cpu, abuf, "sr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* ldcl-gbr-compact: ldc.l @@${rn}+, gbr */

static SEM_PC
SEM_FN_NAME (sh64_compact,ldcl_gbr_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    SI opval = GETMEMSI (current_cpu, pc, GET_H_GRC (FLD (f_rn)));
    SET_H_GBR (opval);
    TRACE_RESULT (current_cpu, abuf, "gbr", 'x', opval);
  }
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rn)), 4);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* ldcl-vbr-compact: ldc.l @@${rn}+, vbr */

static SEM_PC
SEM_FN_NAME (sh64_compact,ldcl_vbr_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    SI opval = GETMEMSI (current_cpu, pc, GET_H_GRC (FLD (f_rn)));
    SET_H_VBR (opval);
    TRACE_RESULT (current_cpu, abuf, "vbr", 'x', opval);
  }
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rn)), 4);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* lds-fpscr-compact: lds $rn, fpscr */

static SEM_PC
SEM_FN_NAME (sh64_compact,lds_fpscr_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_GRC (FLD (f_rn));
    CPU (h_fpscr) = opval;
    TRACE_RESULT (current_cpu, abuf, "fpscr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* ldsl-fpscr-compact: lds.l @@${rn}+, fpscr */

static SEM_PC
SEM_FN_NAME (sh64_compact,ldsl_fpscr_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    SI opval = GETMEMSI (current_cpu, pc, GET_H_GRC (FLD (f_rn)));
    CPU (h_fpscr) = opval;
    TRACE_RESULT (current_cpu, abuf, "fpscr", 'x', opval);
  }
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rn)), 4);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* lds-fpul-compact: lds $rn, fpul */

static SEM_PC
SEM_FN_NAME (sh64_compact,lds_fpul_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SF opval = SUBWORDSISF (GET_H_GRC (FLD (f_rn)));
    CPU (h_fr[((UINT) 32)]) = opval;
    TRACE_RESULT (current_cpu, abuf, "fr", 'f', opval);
  }

  return vpc;
#undef FLD
}

/* ldsl-fpul-compact: lds.l @@${rn}+, fpul */

static SEM_PC
SEM_FN_NAME (sh64_compact,ldsl_fpul_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    SF opval = GETMEMSF (current_cpu, pc, GET_H_GRC (FLD (f_rn)));
    CPU (h_fr[((UINT) 32)]) = opval;
    TRACE_RESULT (current_cpu, abuf, "fr", 'f', opval);
  }
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rn)), 4);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* lds-mach-compact: lds $rn, mach */

static SEM_PC
SEM_FN_NAME (sh64_compact,lds_mach_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_GRC (FLD (f_rn));
    SET_H_MACH (opval);
    TRACE_RESULT (current_cpu, abuf, "mach", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* ldsl-mach-compact: lds.l @@${rn}+, mach */

static SEM_PC
SEM_FN_NAME (sh64_compact,ldsl_mach_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    SI opval = GETMEMSI (current_cpu, pc, GET_H_GRC (FLD (f_rn)));
    SET_H_MACH (opval);
    TRACE_RESULT (current_cpu, abuf, "mach", 'x', opval);
  }
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rn)), 4);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* lds-macl-compact: lds $rn, macl */

static SEM_PC
SEM_FN_NAME (sh64_compact,lds_macl_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_GRC (FLD (f_rn));
    SET_H_MACL (opval);
    TRACE_RESULT (current_cpu, abuf, "macl", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* ldsl-macl-compact: lds.l @@${rn}+, macl */

static SEM_PC
SEM_FN_NAME (sh64_compact,ldsl_macl_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    SI opval = GETMEMSI (current_cpu, pc, GET_H_GRC (FLD (f_rn)));
    SET_H_MACL (opval);
    TRACE_RESULT (current_cpu, abuf, "macl", 'x', opval);
  }
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rn)), 4);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* lds-pr-compact: lds $rn, pr */

static SEM_PC
SEM_FN_NAME (sh64_compact,lds_pr_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_GRC (FLD (f_rn));
    SET_H_PR (opval);
    TRACE_RESULT (current_cpu, abuf, "pr", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* ldsl-pr-compact: lds.l @@${rn}+, pr */

static SEM_PC
SEM_FN_NAME (sh64_compact,ldsl_pr_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    SI opval = GETMEMSI (current_cpu, pc, GET_H_GRC (FLD (f_rn)));
    SET_H_PR (opval);
    TRACE_RESULT (current_cpu, abuf, "pr", 'x', opval);
  }
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rn)), 4);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* macl-compact: mac.l @@${rm}+, @@${rn}+ */

static SEM_PC
SEM_FN_NAME (sh64_compact,macl_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_tmpry;
  DI tmp_mac;
  DI tmp_result;
  SI tmp_x;
  SI tmp_y;
  tmp_x = GETMEMSI (current_cpu, pc, GET_H_GRC (FLD (f_rn)));
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rn)), 4);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
if (EQSI (FLD (f_rn), FLD (f_rm))) {
{
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rn)), 4);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rm)), 4);
    SET_H_GRC (FLD (f_rm), opval);
    written |= (1 << 11);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}
}
  tmp_y = GETMEMSI (current_cpu, pc, GET_H_GRC (FLD (f_rm)));
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rm)), 4);
    SET_H_GRC (FLD (f_rm), opval);
    written |= (1 << 11);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  tmp_tmpry = MULDI (ZEXTSIDI (tmp_x), ZEXTSIDI (tmp_y));
  tmp_mac = ORDI (SLLDI (ZEXTSIDI (GET_H_MACH ()), 32), ZEXTSIDI (GET_H_MACL ()));
  tmp_result = ADDDI (tmp_mac, tmp_tmpry);
{
if (GET_H_SBIT ()) {
{
  SI tmp_min;
  SI tmp_max;
  tmp_max = SRLDI (INVDI (0), 16);
  tmp_min = SRLDI (INVDI (0), 15);
if (GTDI (tmp_result, tmp_max)) {
  tmp_result = tmp_max;
} else {
if (LTDI (tmp_result, tmp_min)) {
  tmp_result = tmp_min;
}
}
}
}
  {
    SI opval = SUBWORDDISI (tmp_result, 0);
    SET_H_MACH (opval);
    TRACE_RESULT (current_cpu, abuf, "mach", 'x', opval);
  }
  {
    SI opval = SUBWORDDISI (tmp_result, 1);
    SET_H_MACL (opval);
    TRACE_RESULT (current_cpu, abuf, "macl", 'x', opval);
  }
}
}

  abuf->written = written;
  return vpc;
#undef FLD
}

/* macw-compact: mac.w @@${rm}+, @@${rn}+ */

static SEM_PC
SEM_FN_NAME (sh64_compact,macw_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  SI tmp_tmpry;
  DI tmp_mac;
  DI tmp_result;
  HI tmp_x;
  HI tmp_y;
  tmp_x = GETMEMHI (current_cpu, pc, GET_H_GRC (FLD (f_rn)));
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rn)), 2);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
if (EQSI (FLD (f_rn), FLD (f_rm))) {
{
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rn)), 2);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rm)), 2);
    SET_H_GRC (FLD (f_rm), opval);
    written |= (1 << 11);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}
}
  tmp_y = GETMEMHI (current_cpu, pc, GET_H_GRC (FLD (f_rm)));
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rm)), 2);
    SET_H_GRC (FLD (f_rm), opval);
    written |= (1 << 11);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  tmp_tmpry = MULSI (ZEXTHISI (tmp_x), ZEXTHISI (tmp_y));
if (GET_H_SBIT ()) {
{
if (ADDOFSI (tmp_tmpry, GET_H_MACL (), 0)) {
  {
    SI opval = 1;
    SET_H_MACH (opval);
    written |= (1 << 9);
    TRACE_RESULT (current_cpu, abuf, "mach", 'x', opval);
  }
}
  {
    SI opval = ADDSI (tmp_tmpry, GET_H_MACL ());
    SET_H_MACL (opval);
    written |= (1 << 10);
    TRACE_RESULT (current_cpu, abuf, "macl", 'x', opval);
  }
}
} else {
{
  tmp_mac = ORDI (SLLDI (ZEXTSIDI (GET_H_MACH ()), 32), ZEXTSIDI (GET_H_MACL ()));
  tmp_result = ADDDI (tmp_mac, EXTSIDI (tmp_tmpry));
  {
    SI opval = SUBWORDDISI (tmp_result, 0);
    SET_H_MACH (opval);
    written |= (1 << 9);
    TRACE_RESULT (current_cpu, abuf, "mach", 'x', opval);
  }
  {
    SI opval = SUBWORDDISI (tmp_result, 1);
    SET_H_MACL (opval);
    written |= (1 << 10);
    TRACE_RESULT (current_cpu, abuf, "macl", 'x', opval);
  }
}
}
}

  abuf->written = written;
  return vpc;
#undef FLD
}

/* mov-compact: mov $rm64, $rn64 */

static SEM_PC
SEM_FN_NAME (sh64_compact,mov_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = GET_H_GR (FLD (f_rm));
    SET_H_GR (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'D', opval);
  }

  return vpc;
#undef FLD
}

/* movi-compact: mov #$imm8, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,movi_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_addi_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = EXTQIDI (ANDQI (FLD (f_imm8), 255));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* movi20-compact: movi20 #$imm20, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,movi20_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movi20_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = FLD (f_imm20);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* movb1-compact: mov.b $rm, @@$rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,movb1_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    UQI opval = SUBWORDSIUQI (GET_H_GRC (FLD (f_rm)), 3);
    SETMEMUQI (current_cpu, pc, GET_H_GRC (FLD (f_rn)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* movb2-compact: mov.b $rm, @@-$rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,movb2_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_addr;
  tmp_addr = SUBSI (GET_H_GRC (FLD (f_rn)), 1);
  {
    UQI opval = SUBWORDSIUQI (GET_H_GRC (FLD (f_rm)), 3);
    SETMEMUQI (current_cpu, pc, tmp_addr, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
  {
    SI opval = tmp_addr;
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* movb3-compact: mov.b $rm, @@(r0,$rn) */

static SEM_PC
SEM_FN_NAME (sh64_compact,movb3_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    UQI opval = SUBWORDSIUQI (GET_H_GRC (FLD (f_rm)), 3);
    SETMEMUQI (current_cpu, pc, ADDSI (GET_H_GRC (((UINT) 0)), GET_H_GRC (FLD (f_rn))), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* movb4-compact: mov.b r0, @@($imm8, gbr) */

static SEM_PC
SEM_FN_NAME (sh64_compact,movb4_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_addi_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_addr;
  tmp_addr = ADDSI (GET_H_GBR (), FLD (f_imm8));
  {
    UQI opval = SUBWORDSIUQI (GET_H_GRC (((UINT) 0)), 3);
    SETMEMUQI (current_cpu, pc, tmp_addr, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* movb5-compact: mov.b r0, @@($imm4, $rm) */

static SEM_PC
SEM_FN_NAME (sh64_compact,movb5_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movb5_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_addr;
  tmp_addr = ADDSI (GET_H_GRC (FLD (f_rm)), FLD (f_imm4));
  {
    UQI opval = SUBWORDSIUQI (GET_H_GRC (((UINT) 0)), 3);
    SETMEMUQI (current_cpu, pc, tmp_addr, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* movb6-compact: mov.b @@$rm, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,movb6_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = EXTQISI (GETMEMQI (current_cpu, pc, GET_H_GRC (FLD (f_rm))));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* movb7-compact: mov.b @@${rm}+, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,movb7_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  QI tmp_data;
  tmp_data = GETMEMQI (current_cpu, pc, GET_H_GRC (FLD (f_rm)));
if (EQSI (FLD (f_rm), FLD (f_rn))) {
  {
    SI opval = EXTQISI (tmp_data);
    SET_H_GRC (FLD (f_rm), opval);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
} else {
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rm)), 1);
    SET_H_GRC (FLD (f_rm), opval);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}
  {
    SI opval = EXTQISI (tmp_data);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

  abuf->written = written;
  return vpc;
#undef FLD
}

/* movb8-compact: mov.b @@(r0, $rm), $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,movb8_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = EXTQISI (GETMEMQI (current_cpu, pc, ADDSI (GET_H_GRC (((UINT) 0)), GET_H_GRC (FLD (f_rm)))));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* movb9-compact: mov.b @@($imm8, gbr), r0 */

static SEM_PC
SEM_FN_NAME (sh64_compact,movb9_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_addi_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = EXTQISI (GETMEMQI (current_cpu, pc, ADDSI (GET_H_GBR (), FLD (f_imm8))));
    SET_H_GRC (((UINT) 0), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* movb10-compact: mov.b @@($imm4, $rm), r0 */

static SEM_PC
SEM_FN_NAME (sh64_compact,movb10_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movb5_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = EXTQISI (GETMEMQI (current_cpu, pc, ADDSI (GET_H_GRC (FLD (f_rm)), FLD (f_imm4))));
    SET_H_GRC (((UINT) 0), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* movl1-compact: mov.l $rm, @@$rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,movl1_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_GRC (FLD (f_rm));
    SETMEMSI (current_cpu, pc, GET_H_GRC (FLD (f_rn)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* movl2-compact: mov.l $rm, @@-$rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,movl2_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  SI tmp_addr;
  tmp_addr = SUBSI (GET_H_GRC (FLD (f_rn)), 4);
  {
    SI opval = GET_H_GRC (FLD (f_rm));
    SETMEMSI (current_cpu, pc, tmp_addr, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
  {
    SI opval = tmp_addr;
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* movl3-compact: mov.l $rm, @@(r0, $rn) */

static SEM_PC
SEM_FN_NAME (sh64_compact,movl3_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_GRC (FLD (f_rm));
    SETMEMSI (current_cpu, pc, ADDSI (GET_H_GRC (((UINT) 0)), GET_H_GRC (FLD (f_rn))), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* movl4-compact: mov.l r0, @@($imm8x4, gbr) */

static SEM_PC
SEM_FN_NAME (sh64_compact,movl4_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_GRC (((UINT) 0));
    SETMEMSI (current_cpu, pc, ADDSI (GET_H_GBR (), FLD (f_imm8x4)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* movl5-compact: mov.l $rm, @@($imm4x4, $rn) */

static SEM_PC
SEM_FN_NAME (sh64_compact,movl5_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_GRC (FLD (f_rm));
    SETMEMSI (current_cpu, pc, ADDSI (GET_H_GRC (FLD (f_rn)), FLD (f_imm4x4)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* movl6-compact: mov.l @@$rm, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,movl6_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GETMEMSI (current_cpu, pc, GET_H_GRC (FLD (f_rm)));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* movl7-compact: mov.l @@${rm}+, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,movl7_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    SI opval = GETMEMSI (current_cpu, pc, GET_H_GRC (FLD (f_rm)));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
if (EQSI (FLD (f_rm), FLD (f_rn))) {
  {
    SI opval = GET_H_GRC (FLD (f_rn));
    SET_H_GRC (FLD (f_rm), opval);
    written |= (1 << 5);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
} else {
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rm)), 4);
    SET_H_GRC (FLD (f_rm), opval);
    written |= (1 << 5);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}
}

  abuf->written = written;
  return vpc;
#undef FLD
}

/* movl8-compact: mov.l @@(r0, $rm), $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,movl8_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GETMEMSI (current_cpu, pc, ADDSI (GET_H_GRC (((UINT) 0)), GET_H_GRC (FLD (f_rm))));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* movl9-compact: mov.l @@($imm8x4, gbr), r0 */

static SEM_PC
SEM_FN_NAME (sh64_compact,movl9_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GETMEMSI (current_cpu, pc, ADDSI (GET_H_GBR (), FLD (f_imm8x4)));
    SET_H_GRC (((UINT) 0), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* movl10-compact: mov.l @@($imm8x4, pc), $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,movl10_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GETMEMSI (current_cpu, pc, ADDSI (FLD (f_imm8x4), ANDDI (ADDDI (pc, 4), INVSI (3))));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* movl11-compact: mov.l @@($imm4x4, $rm), $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,movl11_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GETMEMSI (current_cpu, pc, ADDSI (GET_H_GRC (FLD (f_rm)), FLD (f_imm4x4)));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* movl12-compact: mov.l @@($imm12x4, $rm), $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,movl12_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = GETMEMSI (current_cpu, pc, ADDSI (GET_H_GRC (FLD (f_rm)), FLD (f_imm12x4)));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* movl13-compact: mov.l $rm, @@($imm12x4, $rn) */

static SEM_PC
SEM_FN_NAME (sh64_compact,movl13_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = GET_H_GRC (FLD (f_rm));
    SETMEMSI (current_cpu, pc, ADDSI (GET_H_GRC (FLD (f_rn)), FLD (f_imm12x4)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* movw1-compact: mov.w $rm, @@$rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,movw1_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    HI opval = SUBWORDSIHI (GET_H_GRC (FLD (f_rm)), 1);
    SETMEMHI (current_cpu, pc, GET_H_GRC (FLD (f_rn)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* movw2-compact: mov.w $rm, @@-$rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,movw2_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_addr;
  tmp_addr = SUBSI (GET_H_GRC (FLD (f_rn)), 2);
  {
    HI opval = SUBWORDSIHI (GET_H_GRC (FLD (f_rm)), 1);
    SETMEMHI (current_cpu, pc, tmp_addr, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
  {
    SI opval = tmp_addr;
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* movw3-compact: mov.w $rm, @@(r0, $rn) */

static SEM_PC
SEM_FN_NAME (sh64_compact,movw3_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    HI opval = SUBWORDSIHI (GET_H_GRC (FLD (f_rm)), 1);
    SETMEMHI (current_cpu, pc, ADDSI (GET_H_GRC (((UINT) 0)), GET_H_GRC (FLD (f_rn))), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* movw4-compact: mov.w r0, @@($imm8x2, gbr) */

static SEM_PC
SEM_FN_NAME (sh64_compact,movw4_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    HI opval = SUBWORDSIHI (GET_H_GRC (((UINT) 0)), 1);
    SETMEMHI (current_cpu, pc, ADDSI (GET_H_GBR (), FLD (f_imm8x2)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* movw5-compact: mov.w r0, @@($imm4x2, $rm) */

static SEM_PC
SEM_FN_NAME (sh64_compact,movw5_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw5_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    HI opval = SUBWORDSIHI (GET_H_GRC (((UINT) 0)), 1);
    SETMEMHI (current_cpu, pc, ADDSI (GET_H_GRC (FLD (f_rm)), FLD (f_imm4x2)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* movw6-compact: mov.w @@$rm, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,movw6_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = EXTHISI (GETMEMHI (current_cpu, pc, GET_H_GRC (FLD (f_rm))));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* movw7-compact: mov.w @@${rm}+, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,movw7_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  HI tmp_data;
  tmp_data = GETMEMHI (current_cpu, pc, GET_H_GRC (FLD (f_rm)));
if (EQSI (FLD (f_rm), FLD (f_rn))) {
  {
    SI opval = EXTHISI (tmp_data);
    SET_H_GRC (FLD (f_rm), opval);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
} else {
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rm)), 2);
    SET_H_GRC (FLD (f_rm), opval);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}
  {
    SI opval = EXTHISI (tmp_data);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

  abuf->written = written;
  return vpc;
#undef FLD
}

/* movw8-compact: mov.w @@(r0, $rm), $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,movw8_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = EXTHISI (GETMEMHI (current_cpu, pc, ADDSI (GET_H_GRC (((UINT) 0)), GET_H_GRC (FLD (f_rm)))));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* movw9-compact: mov.w @@($imm8x2, gbr), r0 */

static SEM_PC
SEM_FN_NAME (sh64_compact,movw9_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = EXTHISI (GETMEMHI (current_cpu, pc, ADDSI (GET_H_GBR (), FLD (f_imm8x2))));
    SET_H_GRC (((UINT) 0), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* movw10-compact: mov.w @@($imm8x2, pc), $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,movw10_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = EXTHISI (GETMEMHI (current_cpu, pc, ADDDI (ADDDI (pc, 4), FLD (f_imm8x2))));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* movw11-compact: mov.w @@($imm4x2, $rm), r0 */

static SEM_PC
SEM_FN_NAME (sh64_compact,movw11_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw5_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = EXTHISI (GETMEMHI (current_cpu, pc, ADDSI (GET_H_GRC (FLD (f_rm)), FLD (f_imm4x2))));
    SET_H_GRC (((UINT) 0), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* mova-compact: mova @@($imm8x4, pc), r0 */

static SEM_PC
SEM_FN_NAME (sh64_compact,mova_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ADDDI (ANDDI (ADDDI (pc, 4), INVSI (3)), FLD (f_imm8x4));
    SET_H_GRC (((UINT) 0), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* movcal-compact: movca.l r0, @@$rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,movcal_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_GRC (((UINT) 0));
    SETMEMSI (current_cpu, pc, GET_H_GRC (FLD (f_rn)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* movcol-compact: movco.l r0, @@$rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,movcol_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_GRC (FLD (f_rn));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* movt-compact: movt $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,movt_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ZEXTBISI (GET_H_TBIT ());
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* movual-compact: movua.l @@$rn, r0 */

static SEM_PC
SEM_FN_NAME (sh64_compact,movual_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = sh64_movua (current_cpu, pc, GET_H_GRC (FLD (f_rn)));
    SET_H_GRC (((UINT) 0), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* movual2-compact: movua.l @@$rn+, r0 */

static SEM_PC
SEM_FN_NAME (sh64_compact,movual2_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    SI opval = sh64_movua (current_cpu, pc, GET_H_GRC (FLD (f_rn)));
    SET_H_GRC (((UINT) 0), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  {
    SI opval = ADDSI (GET_H_GRC (FLD (f_rn)), 4);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* mull-compact: mul.l $rm, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,mull_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = MULSI (GET_H_GRC (FLD (f_rm)), GET_H_GRC (FLD (f_rn)));
    SET_H_MACL (opval);
    TRACE_RESULT (current_cpu, abuf, "macl", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* mulsw-compact: muls.w $rm, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,mulsw_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = MULSI (EXTHISI (SUBWORDSIHI (GET_H_GRC (FLD (f_rm)), 1)), EXTHISI (SUBWORDSIHI (GET_H_GRC (FLD (f_rn)), 1)));
    SET_H_MACL (opval);
    TRACE_RESULT (current_cpu, abuf, "macl", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* muluw-compact: mulu.w $rm, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,muluw_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = MULSI (ZEXTHISI (SUBWORDSIHI (GET_H_GRC (FLD (f_rm)), 1)), ZEXTHISI (SUBWORDSIHI (GET_H_GRC (FLD (f_rn)), 1)));
    SET_H_MACL (opval);
    TRACE_RESULT (current_cpu, abuf, "macl", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* neg-compact: neg $rm, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,neg_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = NEGSI (GET_H_GRC (FLD (f_rm)));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* negc-compact: negc $rm, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,negc_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  BI tmp_flag;
  tmp_flag = SUBCFSI (0, GET_H_GRC (FLD (f_rm)), GET_H_TBIT ());
  {
    SI opval = SUBCSI (0, GET_H_GRC (FLD (f_rm)), GET_H_TBIT ());
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  {
    BI opval = tmp_flag;
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* nop-compact: nop */

static SEM_PC
SEM_FN_NAME (sh64_compact,nop_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

((void) 0); /*nop*/

  return vpc;
#undef FLD
}

/* not-compact: not $rm64, $rn64 */

static SEM_PC
SEM_FN_NAME (sh64_compact,not_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = INVDI (GET_H_GR (FLD (f_rm)));
    SET_H_GR (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'D', opval);
  }

  return vpc;
#undef FLD
}

/* ocbi-compact: ocbi @@$rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,ocbi_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    SI opval = GET_H_GRC (FLD (f_rn));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
((void) 0); /*nop*/
}

  return vpc;
#undef FLD
}

/* ocbp-compact: ocbp @@$rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,ocbp_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    SI opval = GET_H_GRC (FLD (f_rn));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
((void) 0); /*nop*/
}

  return vpc;
#undef FLD
}

/* ocbwb-compact: ocbwb @@$rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,ocbwb_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    SI opval = GET_H_GRC (FLD (f_rn));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
((void) 0); /*nop*/
}

  return vpc;
#undef FLD
}

/* or-compact: or $rm64, $rn64 */

static SEM_PC
SEM_FN_NAME (sh64_compact,or_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = ORDI (GET_H_GR (FLD (f_rm)), GET_H_GR (FLD (f_rn)));
    SET_H_GR (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'D', opval);
  }

  return vpc;
#undef FLD
}

/* ori-compact: or #$uimm8, r0 */

static SEM_PC
SEM_FN_NAME (sh64_compact,ori_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_addi_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ORSI (GET_H_GRC (((UINT) 0)), ZEXTSIDI (FLD (f_imm8)));
    SET_H_GRC (((UINT) 0), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* orb-compact: or.b #$imm8, @@(r0, gbr) */

static SEM_PC
SEM_FN_NAME (sh64_compact,orb_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_addi_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_addr;
  UQI tmp_data;
  tmp_addr = ADDSI (GET_H_GRC (((UINT) 0)), GET_H_GBR ());
  tmp_data = ORQI (GETMEMUQI (current_cpu, pc, tmp_addr), FLD (f_imm8));
  {
    UQI opval = tmp_data;
    SETMEMUQI (current_cpu, pc, tmp_addr, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* pref-compact: pref @@$rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,pref_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

sh64_pref (current_cpu, GET_H_GRC (FLD (f_rn)));

  return vpc;
#undef FLD
}

/* rotcl-compact: rotcl $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,rotcl_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  BI tmp_temp;
  tmp_temp = SRLSI (GET_H_GRC (FLD (f_rn)), 31);
  {
    SI opval = ORSI (SLLSI (GET_H_GRC (FLD (f_rn)), 1), GET_H_TBIT ());
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  {
    BI opval = ((tmp_temp) ? (1) : (0));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* rotcr-compact: rotcr $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,rotcr_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  BI tmp_lsbit;
  SI tmp_temp;
  tmp_lsbit = ((EQSI (ANDSI (GET_H_GRC (FLD (f_rn)), 1), 0)) ? (0) : (1));
  tmp_temp = GET_H_TBIT ();
  {
    SI opval = ORSI (SRLSI (GET_H_GRC (FLD (f_rn)), 1), SLLSI (tmp_temp, 31));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  {
    BI opval = ((tmp_lsbit) ? (1) : (0));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* rotl-compact: rotl $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,rotl_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  BI tmp_temp;
  tmp_temp = SRLSI (GET_H_GRC (FLD (f_rn)), 31);
  {
    SI opval = ORSI (SLLSI (GET_H_GRC (FLD (f_rn)), 1), tmp_temp);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  {
    BI opval = ((tmp_temp) ? (1) : (0));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* rotr-compact: rotr $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,rotr_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  BI tmp_lsbit;
  SI tmp_temp;
  tmp_lsbit = ((EQSI (ANDSI (GET_H_GRC (FLD (f_rn)), 1), 0)) ? (0) : (1));
  tmp_temp = tmp_lsbit;
  {
    SI opval = ORSI (SRLSI (GET_H_GRC (FLD (f_rn)), 1), SLLSI (tmp_temp, 31));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  {
    BI opval = ((tmp_lsbit) ? (1) : (0));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* rts-compact: rts */

static SEM_PC
SEM_FN_NAME (sh64_compact,rts_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    UDI opval = ADDDI (pc, 2);
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
((void) 0); /*nop*/
{
  {
    UDI opval = GET_H_PR ();
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
  }
}
((void) 0); /*nop*/
}

  SEM_BRANCH_FINI (vpc);
  return vpc;
#undef FLD
}

/* sets-compact: sets */

static SEM_PC
SEM_FN_NAME (sh64_compact,sets_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = 1;
    SET_H_SBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "sbit", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* sett-compact: sett */

static SEM_PC
SEM_FN_NAME (sh64_compact,sett_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_empty.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = 1;
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* shad-compact: shad $rm, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,shad_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  SI tmp_shamt;
  tmp_shamt = ANDSI (GET_H_GRC (FLD (f_rm)), 31);
if (GESI (GET_H_GRC (FLD (f_rm)), 0)) {
  {
    SI opval = SLLSI (GET_H_GRC (FLD (f_rn)), tmp_shamt);
    SET_H_GRC (FLD (f_rn), opval);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
} else {
if (NESI (tmp_shamt, 0)) {
  {
    SI opval = SRASI (GET_H_GRC (FLD (f_rn)), SUBSI (32, tmp_shamt));
    SET_H_GRC (FLD (f_rn), opval);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
} else {
if (LTSI (GET_H_GRC (FLD (f_rn)), 0)) {
  {
    SI opval = NEGSI (1);
    SET_H_GRC (FLD (f_rn), opval);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
} else {
  {
    SI opval = 0;
    SET_H_GRC (FLD (f_rn), opval);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}
}
}
}

  abuf->written = written;
  return vpc;
#undef FLD
}

/* shal-compact: shal $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,shal_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  BI tmp_t;
  tmp_t = SRLSI (GET_H_GRC (FLD (f_rn)), 31);
  {
    SI opval = SLLSI (GET_H_GRC (FLD (f_rn)), 1);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  {
    BI opval = ((tmp_t) ? (1) : (0));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* shar-compact: shar $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,shar_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  BI tmp_t;
  tmp_t = ANDSI (GET_H_GRC (FLD (f_rn)), 1);
  {
    SI opval = SRASI (GET_H_GRC (FLD (f_rn)), 1);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  {
    BI opval = ((tmp_t) ? (1) : (0));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* shld-compact: shld $rm, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,shld_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  SI tmp_shamt;
  tmp_shamt = ANDSI (GET_H_GRC (FLD (f_rm)), 31);
if (GESI (GET_H_GRC (FLD (f_rm)), 0)) {
  {
    SI opval = SLLSI (GET_H_GRC (FLD (f_rn)), tmp_shamt);
    SET_H_GRC (FLD (f_rn), opval);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
} else {
if (NESI (tmp_shamt, 0)) {
  {
    SI opval = SRLSI (GET_H_GRC (FLD (f_rn)), SUBSI (32, tmp_shamt));
    SET_H_GRC (FLD (f_rn), opval);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
} else {
  {
    SI opval = 0;
    SET_H_GRC (FLD (f_rn), opval);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}
}
}

  abuf->written = written;
  return vpc;
#undef FLD
}

/* shll-compact: shll $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,shll_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  BI tmp_t;
  tmp_t = SRLSI (GET_H_GRC (FLD (f_rn)), 31);
  {
    SI opval = SLLSI (GET_H_GRC (FLD (f_rn)), 1);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  {
    BI opval = ((tmp_t) ? (1) : (0));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* shll2-compact: shll2 $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,shll2_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = SLLSI (GET_H_GRC (FLD (f_rn)), 2);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* shll8-compact: shll8 $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,shll8_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = SLLSI (GET_H_GRC (FLD (f_rn)), 8);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* shll16-compact: shll16 $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,shll16_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = SLLSI (GET_H_GRC (FLD (f_rn)), 16);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* shlr-compact: shlr $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,shlr_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  BI tmp_t;
  tmp_t = ANDSI (GET_H_GRC (FLD (f_rn)), 1);
  {
    SI opval = SRLSI (GET_H_GRC (FLD (f_rn)), 1);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  {
    BI opval = ((tmp_t) ? (1) : (0));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* shlr2-compact: shlr2 $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,shlr2_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = SRLSI (GET_H_GRC (FLD (f_rn)), 2);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* shlr8-compact: shlr8 $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,shlr8_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = SRLSI (GET_H_GRC (FLD (f_rn)), 8);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* shlr16-compact: shlr16 $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,shlr16_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = SRLSI (GET_H_GRC (FLD (f_rn)), 16);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* stc-gbr-compact: stc gbr, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,stc_gbr_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_GBR ();
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* stc-vbr-compact: stc vbr, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,stc_vbr_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_VBR ();
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* stcl-gbr-compact: stc.l gbr, @@-$rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,stcl_gbr_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_addr;
  tmp_addr = SUBSI (GET_H_GRC (FLD (f_rn)), 4);
  {
    SI opval = GET_H_GBR ();
    SETMEMSI (current_cpu, pc, tmp_addr, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
  {
    SI opval = tmp_addr;
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* stcl-vbr-compact: stc.l vbr, @@-$rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,stcl_vbr_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_addr;
  tmp_addr = SUBSI (GET_H_GRC (FLD (f_rn)), 4);
  {
    SI opval = GET_H_VBR ();
    SETMEMSI (current_cpu, pc, tmp_addr, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
  {
    SI opval = tmp_addr;
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* sts-fpscr-compact: sts fpscr, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,sts_fpscr_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = CPU (h_fpscr);
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* stsl-fpscr-compact: sts.l fpscr, @@-$rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,stsl_fpscr_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_addr;
  tmp_addr = SUBSI (GET_H_GRC (FLD (f_rn)), 4);
  {
    SI opval = CPU (h_fpscr);
    SETMEMSI (current_cpu, pc, tmp_addr, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
  {
    SI opval = tmp_addr;
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* sts-fpul-compact: sts fpul, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,sts_fpul_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = SUBWORDSFSI (CPU (h_fr[((UINT) 32)]));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* stsl-fpul-compact: sts.l fpul, @@-$rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,stsl_fpul_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_addr;
  tmp_addr = SUBSI (GET_H_GRC (FLD (f_rn)), 4);
  {
    SF opval = CPU (h_fr[((UINT) 32)]);
    SETMEMSF (current_cpu, pc, tmp_addr, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'f', opval);
  }
  {
    SI opval = tmp_addr;
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* sts-mach-compact: sts mach, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,sts_mach_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_MACH ();
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* stsl-mach-compact: sts.l mach, @@-$rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,stsl_mach_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_addr;
  tmp_addr = SUBSI (GET_H_GRC (FLD (f_rn)), 4);
  {
    SI opval = GET_H_MACH ();
    SETMEMSI (current_cpu, pc, tmp_addr, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
  {
    SI opval = tmp_addr;
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* sts-macl-compact: sts macl, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,sts_macl_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_MACL ();
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* stsl-macl-compact: sts.l macl, @@-$rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,stsl_macl_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_addr;
  tmp_addr = SUBSI (GET_H_GRC (FLD (f_rn)), 4);
  {
    SI opval = GET_H_MACL ();
    SETMEMSI (current_cpu, pc, tmp_addr, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
  {
    SI opval = tmp_addr;
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* sts-pr-compact: sts pr, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,sts_pr_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_PR ();
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* stsl-pr-compact: sts.l pr, @@-$rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,stsl_pr_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_addr;
  tmp_addr = SUBSI (GET_H_GRC (FLD (f_rn)), 4);
  {
    SI opval = GET_H_PR ();
    SETMEMSI (current_cpu, pc, tmp_addr, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
  {
    SI opval = tmp_addr;
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* sub-compact: sub $rm, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,sub_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = SUBSI (GET_H_GRC (FLD (f_rn)), GET_H_GRC (FLD (f_rm)));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* subc-compact: subc $rm, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,subc_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  BI tmp_flag;
  tmp_flag = SUBCFSI (GET_H_GRC (FLD (f_rn)), GET_H_GRC (FLD (f_rm)), GET_H_TBIT ());
  {
    SI opval = SUBCSI (GET_H_GRC (FLD (f_rn)), GET_H_GRC (FLD (f_rm)), GET_H_TBIT ());
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  {
    BI opval = tmp_flag;
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* subv-compact: subv $rm, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,subv_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  BI tmp_t;
  tmp_t = SUBOFSI (GET_H_GRC (FLD (f_rn)), GET_H_GRC (FLD (f_rm)), 0);
  {
    SI opval = SUBSI (GET_H_GRC (FLD (f_rn)), GET_H_GRC (FLD (f_rm)));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
  {
    BI opval = ((tmp_t) ? (1) : (0));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* swapb-compact: swap.b $rm, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,swapb_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  UHI tmp_top_half;
  UQI tmp_byte1;
  UQI tmp_byte0;
  tmp_top_half = SUBWORDSIHI (GET_H_GRC (FLD (f_rm)), 0);
  tmp_byte1 = SUBWORDSIQI (GET_H_GRC (FLD (f_rm)), 2);
  tmp_byte0 = SUBWORDSIQI (GET_H_GRC (FLD (f_rm)), 3);
  {
    SI opval = ORSI (SLLSI (tmp_top_half, 16), ORSI (SLLSI (tmp_byte0, 8), tmp_byte1));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* swapw-compact: swap.w $rm, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,swapw_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ORSI (SRLSI (GET_H_GRC (FLD (f_rm)), 16), SLLSI (GET_H_GRC (FLD (f_rm)), 16));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* tasb-compact: tas.b @@$rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,tasb_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movw10_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  UQI tmp_byte;
  tmp_byte = GETMEMUQI (current_cpu, pc, GET_H_GRC (FLD (f_rn)));
  {
    BI opval = ((EQQI (tmp_byte, 0)) ? (1) : (0));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
  tmp_byte = ORQI (tmp_byte, 128);
  {
    UQI opval = tmp_byte;
    SETMEMUQI (current_cpu, pc, GET_H_GRC (FLD (f_rn)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* trapa-compact: trapa #$uimm8 */

static SEM_PC
SEM_FN_NAME (sh64_compact,trapa_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_addi_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

sh64_compact_trapa (current_cpu, FLD (f_imm8), pc);

  return vpc;
#undef FLD
}

/* tst-compact: tst $rm, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,tst_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = ((EQSI (ANDSI (GET_H_GRC (FLD (f_rm)), GET_H_GRC (FLD (f_rn))), 0)) ? (1) : (0));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* tsti-compact: tst #$uimm8, r0 */

static SEM_PC
SEM_FN_NAME (sh64_compact,tsti_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_addi_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = ((EQSI (ANDSI (GET_H_GRC (((UINT) 0)), ZEXTSISI (FLD (f_imm8))), 0)) ? (1) : (0));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* tstb-compact: tst.b #$imm8, @@(r0, gbr) */

static SEM_PC
SEM_FN_NAME (sh64_compact,tstb_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_addi_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_addr;
  tmp_addr = ADDSI (GET_H_GRC (((UINT) 0)), GET_H_GBR ());
  {
    BI opval = ((EQQI (ANDQI (GETMEMUQI (current_cpu, pc, tmp_addr), FLD (f_imm8)), 0)) ? (1) : (0));
    SET_H_TBIT (opval);
    TRACE_RESULT (current_cpu, abuf, "tbit", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* xor-compact: xor $rm64, $rn64 */

static SEM_PC
SEM_FN_NAME (sh64_compact,xor_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = XORDI (GET_H_GR (FLD (f_rn)), GET_H_GR (FLD (f_rm)));
    SET_H_GR (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "gr", 'D', opval);
  }

  return vpc;
#undef FLD
}

/* xori-compact: xor #$uimm8, r0 */

static SEM_PC
SEM_FN_NAME (sh64_compact,xori_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_addi_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = XORSI (GET_H_GRC (((UINT) 0)), ZEXTSIDI (FLD (f_imm8)));
    SET_H_GRC (((UINT) 0), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* xorb-compact: xor.b #$imm8, @@(r0, gbr) */

static SEM_PC
SEM_FN_NAME (sh64_compact,xorb_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_addi_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_addr;
  UQI tmp_data;
  tmp_addr = ADDSI (GET_H_GRC (((UINT) 0)), GET_H_GBR ());
  tmp_data = XORQI (GETMEMUQI (current_cpu, pc, tmp_addr), FLD (f_imm8));
  {
    UQI opval = tmp_data;
    SETMEMUQI (current_cpu, pc, tmp_addr, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
}

  return vpc;
#undef FLD
}

/* xtrct-compact: xtrct $rm, $rn */

static SEM_PC
SEM_FN_NAME (sh64_compact,xtrct_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
{
#define FLD(f) abuf->fields.sfmt_movl12_compact.f
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_PC vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ORSI (SLLSI (GET_H_GRC (FLD (f_rm)), 16), SRLSI (GET_H_GRC (FLD (f_rn)), 16));
    SET_H_GRC (FLD (f_rn), opval);
    TRACE_RESULT (current_cpu, abuf, "grc", 'x', opval);
  }

  return vpc;
#undef FLD
}

/* Table of all semantic fns.  */

static const struct sem_fn_desc sem_fns[] = {
  { SH64_COMPACT_INSN_X_INVALID, SEM_FN_NAME (sh64_compact,x_invalid) },
  { SH64_COMPACT_INSN_X_AFTER, SEM_FN_NAME (sh64_compact,x_after) },
  { SH64_COMPACT_INSN_X_BEFORE, SEM_FN_NAME (sh64_compact,x_before) },
  { SH64_COMPACT_INSN_X_CTI_CHAIN, SEM_FN_NAME (sh64_compact,x_cti_chain) },
  { SH64_COMPACT_INSN_X_CHAIN, SEM_FN_NAME (sh64_compact,x_chain) },
  { SH64_COMPACT_INSN_X_BEGIN, SEM_FN_NAME (sh64_compact,x_begin) },
  { SH64_COMPACT_INSN_ADD_COMPACT, SEM_FN_NAME (sh64_compact,add_compact) },
  { SH64_COMPACT_INSN_ADDI_COMPACT, SEM_FN_NAME (sh64_compact,addi_compact) },
  { SH64_COMPACT_INSN_ADDC_COMPACT, SEM_FN_NAME (sh64_compact,addc_compact) },
  { SH64_COMPACT_INSN_ADDV_COMPACT, SEM_FN_NAME (sh64_compact,addv_compact) },
  { SH64_COMPACT_INSN_AND_COMPACT, SEM_FN_NAME (sh64_compact,and_compact) },
  { SH64_COMPACT_INSN_ANDI_COMPACT, SEM_FN_NAME (sh64_compact,andi_compact) },
  { SH64_COMPACT_INSN_ANDB_COMPACT, SEM_FN_NAME (sh64_compact,andb_compact) },
  { SH64_COMPACT_INSN_BF_COMPACT, SEM_FN_NAME (sh64_compact,bf_compact) },
  { SH64_COMPACT_INSN_BFS_COMPACT, SEM_FN_NAME (sh64_compact,bfs_compact) },
  { SH64_COMPACT_INSN_BRA_COMPACT, SEM_FN_NAME (sh64_compact,bra_compact) },
  { SH64_COMPACT_INSN_BRAF_COMPACT, SEM_FN_NAME (sh64_compact,braf_compact) },
  { SH64_COMPACT_INSN_BRK_COMPACT, SEM_FN_NAME (sh64_compact,brk_compact) },
  { SH64_COMPACT_INSN_BSR_COMPACT, SEM_FN_NAME (sh64_compact,bsr_compact) },
  { SH64_COMPACT_INSN_BSRF_COMPACT, SEM_FN_NAME (sh64_compact,bsrf_compact) },
  { SH64_COMPACT_INSN_BT_COMPACT, SEM_FN_NAME (sh64_compact,bt_compact) },
  { SH64_COMPACT_INSN_BTS_COMPACT, SEM_FN_NAME (sh64_compact,bts_compact) },
  { SH64_COMPACT_INSN_CLRMAC_COMPACT, SEM_FN_NAME (sh64_compact,clrmac_compact) },
  { SH64_COMPACT_INSN_CLRS_COMPACT, SEM_FN_NAME (sh64_compact,clrs_compact) },
  { SH64_COMPACT_INSN_CLRT_COMPACT, SEM_FN_NAME (sh64_compact,clrt_compact) },
  { SH64_COMPACT_INSN_CMPEQ_COMPACT, SEM_FN_NAME (sh64_compact,cmpeq_compact) },
  { SH64_COMPACT_INSN_CMPEQI_COMPACT, SEM_FN_NAME (sh64_compact,cmpeqi_compact) },
  { SH64_COMPACT_INSN_CMPGE_COMPACT, SEM_FN_NAME (sh64_compact,cmpge_compact) },
  { SH64_COMPACT_INSN_CMPGT_COMPACT, SEM_FN_NAME (sh64_compact,cmpgt_compact) },
  { SH64_COMPACT_INSN_CMPHI_COMPACT, SEM_FN_NAME (sh64_compact,cmphi_compact) },
  { SH64_COMPACT_INSN_CMPHS_COMPACT, SEM_FN_NAME (sh64_compact,cmphs_compact) },
  { SH64_COMPACT_INSN_CMPPL_COMPACT, SEM_FN_NAME (sh64_compact,cmppl_compact) },
  { SH64_COMPACT_INSN_CMPPZ_COMPACT, SEM_FN_NAME (sh64_compact,cmppz_compact) },
  { SH64_COMPACT_INSN_CMPSTR_COMPACT, SEM_FN_NAME (sh64_compact,cmpstr_compact) },
  { SH64_COMPACT_INSN_DIV0S_COMPACT, SEM_FN_NAME (sh64_compact,div0s_compact) },
  { SH64_COMPACT_INSN_DIV0U_COMPACT, SEM_FN_NAME (sh64_compact,div0u_compact) },
  { SH64_COMPACT_INSN_DIV1_COMPACT, SEM_FN_NAME (sh64_compact,div1_compact) },
  { SH64_COMPACT_INSN_DIVU_COMPACT, SEM_FN_NAME (sh64_compact,divu_compact) },
  { SH64_COMPACT_INSN_MULR_COMPACT, SEM_FN_NAME (sh64_compact,mulr_compact) },
  { SH64_COMPACT_INSN_DMULSL_COMPACT, SEM_FN_NAME (sh64_compact,dmulsl_compact) },
  { SH64_COMPACT_INSN_DMULUL_COMPACT, SEM_FN_NAME (sh64_compact,dmulul_compact) },
  { SH64_COMPACT_INSN_DT_COMPACT, SEM_FN_NAME (sh64_compact,dt_compact) },
  { SH64_COMPACT_INSN_EXTSB_COMPACT, SEM_FN_NAME (sh64_compact,extsb_compact) },
  { SH64_COMPACT_INSN_EXTSW_COMPACT, SEM_FN_NAME (sh64_compact,extsw_compact) },
  { SH64_COMPACT_INSN_EXTUB_COMPACT, SEM_FN_NAME (sh64_compact,extub_compact) },
  { SH64_COMPACT_INSN_EXTUW_COMPACT, SEM_FN_NAME (sh64_compact,extuw_compact) },
  { SH64_COMPACT_INSN_FABS_COMPACT, SEM_FN_NAME (sh64_compact,fabs_compact) },
  { SH64_COMPACT_INSN_FADD_COMPACT, SEM_FN_NAME (sh64_compact,fadd_compact) },
  { SH64_COMPACT_INSN_FCMPEQ_COMPACT, SEM_FN_NAME (sh64_compact,fcmpeq_compact) },
  { SH64_COMPACT_INSN_FCMPGT_COMPACT, SEM_FN_NAME (sh64_compact,fcmpgt_compact) },
  { SH64_COMPACT_INSN_FCNVDS_COMPACT, SEM_FN_NAME (sh64_compact,fcnvds_compact) },
  { SH64_COMPACT_INSN_FCNVSD_COMPACT, SEM_FN_NAME (sh64_compact,fcnvsd_compact) },
  { SH64_COMPACT_INSN_FDIV_COMPACT, SEM_FN_NAME (sh64_compact,fdiv_compact) },
  { SH64_COMPACT_INSN_FIPR_COMPACT, SEM_FN_NAME (sh64_compact,fipr_compact) },
  { SH64_COMPACT_INSN_FLDS_COMPACT, SEM_FN_NAME (sh64_compact,flds_compact) },
  { SH64_COMPACT_INSN_FLDI0_COMPACT, SEM_FN_NAME (sh64_compact,fldi0_compact) },
  { SH64_COMPACT_INSN_FLDI1_COMPACT, SEM_FN_NAME (sh64_compact,fldi1_compact) },
  { SH64_COMPACT_INSN_FLOAT_COMPACT, SEM_FN_NAME (sh64_compact,float_compact) },
  { SH64_COMPACT_INSN_FMAC_COMPACT, SEM_FN_NAME (sh64_compact,fmac_compact) },
  { SH64_COMPACT_INSN_FMOV1_COMPACT, SEM_FN_NAME (sh64_compact,fmov1_compact) },
  { SH64_COMPACT_INSN_FMOV2_COMPACT, SEM_FN_NAME (sh64_compact,fmov2_compact) },
  { SH64_COMPACT_INSN_FMOV3_COMPACT, SEM_FN_NAME (sh64_compact,fmov3_compact) },
  { SH64_COMPACT_INSN_FMOV4_COMPACT, SEM_FN_NAME (sh64_compact,fmov4_compact) },
  { SH64_COMPACT_INSN_FMOV5_COMPACT, SEM_FN_NAME (sh64_compact,fmov5_compact) },
  { SH64_COMPACT_INSN_FMOV6_COMPACT, SEM_FN_NAME (sh64_compact,fmov6_compact) },
  { SH64_COMPACT_INSN_FMOV7_COMPACT, SEM_FN_NAME (sh64_compact,fmov7_compact) },
  { SH64_COMPACT_INSN_FMOV8_COMPACT, SEM_FN_NAME (sh64_compact,fmov8_compact) },
  { SH64_COMPACT_INSN_FMOV9_COMPACT, SEM_FN_NAME (sh64_compact,fmov9_compact) },
  { SH64_COMPACT_INSN_FMUL_COMPACT, SEM_FN_NAME (sh64_compact,fmul_compact) },
  { SH64_COMPACT_INSN_FNEG_COMPACT, SEM_FN_NAME (sh64_compact,fneg_compact) },
  { SH64_COMPACT_INSN_FRCHG_COMPACT, SEM_FN_NAME (sh64_compact,frchg_compact) },
  { SH64_COMPACT_INSN_FSCHG_COMPACT, SEM_FN_NAME (sh64_compact,fschg_compact) },
  { SH64_COMPACT_INSN_FSQRT_COMPACT, SEM_FN_NAME (sh64_compact,fsqrt_compact) },
  { SH64_COMPACT_INSN_FSTS_COMPACT, SEM_FN_NAME (sh64_compact,fsts_compact) },
  { SH64_COMPACT_INSN_FSUB_COMPACT, SEM_FN_NAME (sh64_compact,fsub_compact) },
  { SH64_COMPACT_INSN_FTRC_COMPACT, SEM_FN_NAME (sh64_compact,ftrc_compact) },
  { SH64_COMPACT_INSN_FTRV_COMPACT, SEM_FN_NAME (sh64_compact,ftrv_compact) },
  { SH64_COMPACT_INSN_JMP_COMPACT, SEM_FN_NAME (sh64_compact,jmp_compact) },
  { SH64_COMPACT_INSN_JSR_COMPACT, SEM_FN_NAME (sh64_compact,jsr_compact) },
  { SH64_COMPACT_INSN_LDC_GBR_COMPACT, SEM_FN_NAME (sh64_compact,ldc_gbr_compact) },
  { SH64_COMPACT_INSN_LDC_VBR_COMPACT, SEM_FN_NAME (sh64_compact,ldc_vbr_compact) },
  { SH64_COMPACT_INSN_LDC_SR_COMPACT, SEM_FN_NAME (sh64_compact,ldc_sr_compact) },
  { SH64_COMPACT_INSN_LDCL_GBR_COMPACT, SEM_FN_NAME (sh64_compact,ldcl_gbr_compact) },
  { SH64_COMPACT_INSN_LDCL_VBR_COMPACT, SEM_FN_NAME (sh64_compact,ldcl_vbr_compact) },
  { SH64_COMPACT_INSN_LDS_FPSCR_COMPACT, SEM_FN_NAME (sh64_compact,lds_fpscr_compact) },
  { SH64_COMPACT_INSN_LDSL_FPSCR_COMPACT, SEM_FN_NAME (sh64_compact,ldsl_fpscr_compact) },
  { SH64_COMPACT_INSN_LDS_FPUL_COMPACT, SEM_FN_NAME (sh64_compact,lds_fpul_compact) },
  { SH64_COMPACT_INSN_LDSL_FPUL_COMPACT, SEM_FN_NAME (sh64_compact,ldsl_fpul_compact) },
  { SH64_COMPACT_INSN_LDS_MACH_COMPACT, SEM_FN_NAME (sh64_compact,lds_mach_compact) },
  { SH64_COMPACT_INSN_LDSL_MACH_COMPACT, SEM_FN_NAME (sh64_compact,ldsl_mach_compact) },
  { SH64_COMPACT_INSN_LDS_MACL_COMPACT, SEM_FN_NAME (sh64_compact,lds_macl_compact) },
  { SH64_COMPACT_INSN_LDSL_MACL_COMPACT, SEM_FN_NAME (sh64_compact,ldsl_macl_compact) },
  { SH64_COMPACT_INSN_LDS_PR_COMPACT, SEM_FN_NAME (sh64_compact,lds_pr_compact) },
  { SH64_COMPACT_INSN_LDSL_PR_COMPACT, SEM_FN_NAME (sh64_compact,ldsl_pr_compact) },
  { SH64_COMPACT_INSN_MACL_COMPACT, SEM_FN_NAME (sh64_compact,macl_compact) },
  { SH64_COMPACT_INSN_MACW_COMPACT, SEM_FN_NAME (sh64_compact,macw_compact) },
  { SH64_COMPACT_INSN_MOV_COMPACT, SEM_FN_NAME (sh64_compact,mov_compact) },
  { SH64_COMPACT_INSN_MOVI_COMPACT, SEM_FN_NAME (sh64_compact,movi_compact) },
  { SH64_COMPACT_INSN_MOVI20_COMPACT, SEM_FN_NAME (sh64_compact,movi20_compact) },
  { SH64_COMPACT_INSN_MOVB1_COMPACT, SEM_FN_NAME (sh64_compact,movb1_compact) },
  { SH64_COMPACT_INSN_MOVB2_COMPACT, SEM_FN_NAME (sh64_compact,movb2_compact) },
  { SH64_COMPACT_INSN_MOVB3_COMPACT, SEM_FN_NAME (sh64_compact,movb3_compact) },
  { SH64_COMPACT_INSN_MOVB4_COMPACT, SEM_FN_NAME (sh64_compact,movb4_compact) },
  { SH64_COMPACT_INSN_MOVB5_COMPACT, SEM_FN_NAME (sh64_compact,movb5_compact) },
  { SH64_COMPACT_INSN_MOVB6_COMPACT, SEM_FN_NAME (sh64_compact,movb6_compact) },
  { SH64_COMPACT_INSN_MOVB7_COMPACT, SEM_FN_NAME (sh64_compact,movb7_compact) },
  { SH64_COMPACT_INSN_MOVB8_COMPACT, SEM_FN_NAME (sh64_compact,movb8_compact) },
  { SH64_COMPACT_INSN_MOVB9_COMPACT, SEM_FN_NAME (sh64_compact,movb9_compact) },
  { SH64_COMPACT_INSN_MOVB10_COMPACT, SEM_FN_NAME (sh64_compact,movb10_compact) },
  { SH64_COMPACT_INSN_MOVL1_COMPACT, SEM_FN_NAME (sh64_compact,movl1_compact) },
  { SH64_COMPACT_INSN_MOVL2_COMPACT, SEM_FN_NAME (sh64_compact,movl2_compact) },
  { SH64_COMPACT_INSN_MOVL3_COMPACT, SEM_FN_NAME (sh64_compact,movl3_compact) },
  { SH64_COMPACT_INSN_MOVL4_COMPACT, SEM_FN_NAME (sh64_compact,movl4_compact) },
  { SH64_COMPACT_INSN_MOVL5_COMPACT, SEM_FN_NAME (sh64_compact,movl5_compact) },
  { SH64_COMPACT_INSN_MOVL6_COMPACT, SEM_FN_NAME (sh64_compact,movl6_compact) },
  { SH64_COMPACT_INSN_MOVL7_COMPACT, SEM_FN_NAME (sh64_compact,movl7_compact) },
  { SH64_COMPACT_INSN_MOVL8_COMPACT, SEM_FN_NAME (sh64_compact,movl8_compact) },
  { SH64_COMPACT_INSN_MOVL9_COMPACT, SEM_FN_NAME (sh64_compact,movl9_compact) },
  { SH64_COMPACT_INSN_MOVL10_COMPACT, SEM_FN_NAME (sh64_compact,movl10_compact) },
  { SH64_COMPACT_INSN_MOVL11_COMPACT, SEM_FN_NAME (sh64_compact,movl11_compact) },
  { SH64_COMPACT_INSN_MOVL12_COMPACT, SEM_FN_NAME (sh64_compact,movl12_compact) },
  { SH64_COMPACT_INSN_MOVL13_COMPACT, SEM_FN_NAME (sh64_compact,movl13_compact) },
  { SH64_COMPACT_INSN_MOVW1_COMPACT, SEM_FN_NAME (sh64_compact,movw1_compact) },
  { SH64_COMPACT_INSN_MOVW2_COMPACT, SEM_FN_NAME (sh64_compact,movw2_compact) },
  { SH64_COMPACT_INSN_MOVW3_COMPACT, SEM_FN_NAME (sh64_compact,movw3_compact) },
  { SH64_COMPACT_INSN_MOVW4_COMPACT, SEM_FN_NAME (sh64_compact,movw4_compact) },
  { SH64_COMPACT_INSN_MOVW5_COMPACT, SEM_FN_NAME (sh64_compact,movw5_compact) },
  { SH64_COMPACT_INSN_MOVW6_COMPACT, SEM_FN_NAME (sh64_compact,movw6_compact) },
  { SH64_COMPACT_INSN_MOVW7_COMPACT, SEM_FN_NAME (sh64_compact,movw7_compact) },
  { SH64_COMPACT_INSN_MOVW8_COMPACT, SEM_FN_NAME (sh64_compact,movw8_compact) },
  { SH64_COMPACT_INSN_MOVW9_COMPACT, SEM_FN_NAME (sh64_compact,movw9_compact) },
  { SH64_COMPACT_INSN_MOVW10_COMPACT, SEM_FN_NAME (sh64_compact,movw10_compact) },
  { SH64_COMPACT_INSN_MOVW11_COMPACT, SEM_FN_NAME (sh64_compact,movw11_compact) },
  { SH64_COMPACT_INSN_MOVA_COMPACT, SEM_FN_NAME (sh64_compact,mova_compact) },
  { SH64_COMPACT_INSN_MOVCAL_COMPACT, SEM_FN_NAME (sh64_compact,movcal_compact) },
  { SH64_COMPACT_INSN_MOVCOL_COMPACT, SEM_FN_NAME (sh64_compact,movcol_compact) },
  { SH64_COMPACT_INSN_MOVT_COMPACT, SEM_FN_NAME (sh64_compact,movt_compact) },
  { SH64_COMPACT_INSN_MOVUAL_COMPACT, SEM_FN_NAME (sh64_compact,movual_compact) },
  { SH64_COMPACT_INSN_MOVUAL2_COMPACT, SEM_FN_NAME (sh64_compact,movual2_compact) },
  { SH64_COMPACT_INSN_MULL_COMPACT, SEM_FN_NAME (sh64_compact,mull_compact) },
  { SH64_COMPACT_INSN_MULSW_COMPACT, SEM_FN_NAME (sh64_compact,mulsw_compact) },
  { SH64_COMPACT_INSN_MULUW_COMPACT, SEM_FN_NAME (sh64_compact,muluw_compact) },
  { SH64_COMPACT_INSN_NEG_COMPACT, SEM_FN_NAME (sh64_compact,neg_compact) },
  { SH64_COMPACT_INSN_NEGC_COMPACT, SEM_FN_NAME (sh64_compact,negc_compact) },
  { SH64_COMPACT_INSN_NOP_COMPACT, SEM_FN_NAME (sh64_compact,nop_compact) },
  { SH64_COMPACT_INSN_NOT_COMPACT, SEM_FN_NAME (sh64_compact,not_compact) },
  { SH64_COMPACT_INSN_OCBI_COMPACT, SEM_FN_NAME (sh64_compact,ocbi_compact) },
  { SH64_COMPACT_INSN_OCBP_COMPACT, SEM_FN_NAME (sh64_compact,ocbp_compact) },
  { SH64_COMPACT_INSN_OCBWB_COMPACT, SEM_FN_NAME (sh64_compact,ocbwb_compact) },
  { SH64_COMPACT_INSN_OR_COMPACT, SEM_FN_NAME (sh64_compact,or_compact) },
  { SH64_COMPACT_INSN_ORI_COMPACT, SEM_FN_NAME (sh64_compact,ori_compact) },
  { SH64_COMPACT_INSN_ORB_COMPACT, SEM_FN_NAME (sh64_compact,orb_compact) },
  { SH64_COMPACT_INSN_PREF_COMPACT, SEM_FN_NAME (sh64_compact,pref_compact) },
  { SH64_COMPACT_INSN_ROTCL_COMPACT, SEM_FN_NAME (sh64_compact,rotcl_compact) },
  { SH64_COMPACT_INSN_ROTCR_COMPACT, SEM_FN_NAME (sh64_compact,rotcr_compact) },
  { SH64_COMPACT_INSN_ROTL_COMPACT, SEM_FN_NAME (sh64_compact,rotl_compact) },
  { SH64_COMPACT_INSN_ROTR_COMPACT, SEM_FN_NAME (sh64_compact,rotr_compact) },
  { SH64_COMPACT_INSN_RTS_COMPACT, SEM_FN_NAME (sh64_compact,rts_compact) },
  { SH64_COMPACT_INSN_SETS_COMPACT, SEM_FN_NAME (sh64_compact,sets_compact) },
  { SH64_COMPACT_INSN_SETT_COMPACT, SEM_FN_NAME (sh64_compact,sett_compact) },
  { SH64_COMPACT_INSN_SHAD_COMPACT, SEM_FN_NAME (sh64_compact,shad_compact) },
  { SH64_COMPACT_INSN_SHAL_COMPACT, SEM_FN_NAME (sh64_compact,shal_compact) },
  { SH64_COMPACT_INSN_SHAR_COMPACT, SEM_FN_NAME (sh64_compact,shar_compact) },
  { SH64_COMPACT_INSN_SHLD_COMPACT, SEM_FN_NAME (sh64_compact,shld_compact) },
  { SH64_COMPACT_INSN_SHLL_COMPACT, SEM_FN_NAME (sh64_compact,shll_compact) },
  { SH64_COMPACT_INSN_SHLL2_COMPACT, SEM_FN_NAME (sh64_compact,shll2_compact) },
  { SH64_COMPACT_INSN_SHLL8_COMPACT, SEM_FN_NAME (sh64_compact,shll8_compact) },
  { SH64_COMPACT_INSN_SHLL16_COMPACT, SEM_FN_NAME (sh64_compact,shll16_compact) },
  { SH64_COMPACT_INSN_SHLR_COMPACT, SEM_FN_NAME (sh64_compact,shlr_compact) },
  { SH64_COMPACT_INSN_SHLR2_COMPACT, SEM_FN_NAME (sh64_compact,shlr2_compact) },
  { SH64_COMPACT_INSN_SHLR8_COMPACT, SEM_FN_NAME (sh64_compact,shlr8_compact) },
  { SH64_COMPACT_INSN_SHLR16_COMPACT, SEM_FN_NAME (sh64_compact,shlr16_compact) },
  { SH64_COMPACT_INSN_STC_GBR_COMPACT, SEM_FN_NAME (sh64_compact,stc_gbr_compact) },
  { SH64_COMPACT_INSN_STC_VBR_COMPACT, SEM_FN_NAME (sh64_compact,stc_vbr_compact) },
  { SH64_COMPACT_INSN_STCL_GBR_COMPACT, SEM_FN_NAME (sh64_compact,stcl_gbr_compact) },
  { SH64_COMPACT_INSN_STCL_VBR_COMPACT, SEM_FN_NAME (sh64_compact,stcl_vbr_compact) },
  { SH64_COMPACT_INSN_STS_FPSCR_COMPACT, SEM_FN_NAME (sh64_compact,sts_fpscr_compact) },
  { SH64_COMPACT_INSN_STSL_FPSCR_COMPACT, SEM_FN_NAME (sh64_compact,stsl_fpscr_compact) },
  { SH64_COMPACT_INSN_STS_FPUL_COMPACT, SEM_FN_NAME (sh64_compact,sts_fpul_compact) },
  { SH64_COMPACT_INSN_STSL_FPUL_COMPACT, SEM_FN_NAME (sh64_compact,stsl_fpul_compact) },
  { SH64_COMPACT_INSN_STS_MACH_COMPACT, SEM_FN_NAME (sh64_compact,sts_mach_compact) },
  { SH64_COMPACT_INSN_STSL_MACH_COMPACT, SEM_FN_NAME (sh64_compact,stsl_mach_compact) },
  { SH64_COMPACT_INSN_STS_MACL_COMPACT, SEM_FN_NAME (sh64_compact,sts_macl_compact) },
  { SH64_COMPACT_INSN_STSL_MACL_COMPACT, SEM_FN_NAME (sh64_compact,stsl_macl_compact) },
  { SH64_COMPACT_INSN_STS_PR_COMPACT, SEM_FN_NAME (sh64_compact,sts_pr_compact) },
  { SH64_COMPACT_INSN_STSL_PR_COMPACT, SEM_FN_NAME (sh64_compact,stsl_pr_compact) },
  { SH64_COMPACT_INSN_SUB_COMPACT, SEM_FN_NAME (sh64_compact,sub_compact) },
  { SH64_COMPACT_INSN_SUBC_COMPACT, SEM_FN_NAME (sh64_compact,subc_compact) },
  { SH64_COMPACT_INSN_SUBV_COMPACT, SEM_FN_NAME (sh64_compact,subv_compact) },
  { SH64_COMPACT_INSN_SWAPB_COMPACT, SEM_FN_NAME (sh64_compact,swapb_compact) },
  { SH64_COMPACT_INSN_SWAPW_COMPACT, SEM_FN_NAME (sh64_compact,swapw_compact) },
  { SH64_COMPACT_INSN_TASB_COMPACT, SEM_FN_NAME (sh64_compact,tasb_compact) },
  { SH64_COMPACT_INSN_TRAPA_COMPACT, SEM_FN_NAME (sh64_compact,trapa_compact) },
  { SH64_COMPACT_INSN_TST_COMPACT, SEM_FN_NAME (sh64_compact,tst_compact) },
  { SH64_COMPACT_INSN_TSTI_COMPACT, SEM_FN_NAME (sh64_compact,tsti_compact) },
  { SH64_COMPACT_INSN_TSTB_COMPACT, SEM_FN_NAME (sh64_compact,tstb_compact) },
  { SH64_COMPACT_INSN_XOR_COMPACT, SEM_FN_NAME (sh64_compact,xor_compact) },
  { SH64_COMPACT_INSN_XORI_COMPACT, SEM_FN_NAME (sh64_compact,xori_compact) },
  { SH64_COMPACT_INSN_XORB_COMPACT, SEM_FN_NAME (sh64_compact,xorb_compact) },
  { SH64_COMPACT_INSN_XTRCT_COMPACT, SEM_FN_NAME (sh64_compact,xtrct_compact) },
  { 0, 0 }
};

/* Add the semantic fns to IDESC_TABLE.  */

void
SEM_FN_NAME (sh64_compact,init_idesc_table) (SIM_CPU *current_cpu)
{
  IDESC *idesc_table = CPU_IDESC (current_cpu);
  const struct sem_fn_desc *sf;
  int mach_num = MACH_NUM (CPU_MACH (current_cpu));

  for (sf = &sem_fns[0]; sf->fn != 0; ++sf)
    {
      const CGEN_INSN *insn = idesc_table[sf->index].idata;
      int valid_p = (CGEN_INSN_VIRTUAL_P (insn)
		     || CGEN_INSN_MACH_HAS_P (insn, mach_num));
#if FAST_P
      if (valid_p)
	idesc_table[sf->index].sem_fast = sf->fn;
      else
	idesc_table[sf->index].sem_fast = SEM_FN_NAME (sh64_compact,x_invalid);
#else
      if (valid_p)
	idesc_table[sf->index].sem_full = sf->fn;
      else
	idesc_table[sf->index].sem_full = SEM_FN_NAME (sh64_compact,x_invalid);
#endif
    }
}

@


1.8
log
@[sim] Update old contact info in GPL license notices

sim/ChangeLog:

        Update old contact info in GPL license notices.
@
text
@d5 1
a5 1
Copyright 1996-2010, 2012 Free Software Foundation, Inc.
@


1.7
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d20 1
a20 2
   with this program; if not, write to the Free Software Foundation, Inc.,
   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
@


1.6
log
@Regenerate cgen-derived files.
@
text
@d5 1
a5 1
Copyright 1996-2010 Free Software Foundation, Inc.
@


1.6.8.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d5 1
a5 1
Copyright 1996-2010, 2012 Free Software Foundation, Inc.
@


1.5
log
@Regenerate cgen files, update copyright year.
@
text
@a32 1
#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
a33 3
#else
#define GET_ATTR(cpu, num, attr) CGEN_ATTR_VALUE (NULL, abuf->idesc->attrs, CGEN_INSN_/**/attr)
#endif
d51 1
a51 1
#define FLD(f) abuf->fields.fmt_empty.f
d78 1
a78 1
#define FLD(f) abuf->fields.fmt_empty.f
d99 1
a99 1
#define FLD(f) abuf->fields.fmt_empty.f
d120 1
a120 1
#define FLD(f) abuf->fields.fmt_empty.f
d150 1
a150 1
#define FLD(f) abuf->fields.fmt_empty.f
d174 1
a174 1
#define FLD(f) abuf->fields.fmt_empty.f
d507 1
a507 1
#define FLD(f) abuf->fields.fmt_empty.f
d669 1
a669 1
#define FLD(f) abuf->fields.fmt_empty.f
d697 1
a697 1
#define FLD(f) abuf->fields.fmt_empty.f
d718 1
a718 1
#define FLD(f) abuf->fields.fmt_empty.f
d970 1
a970 1
#define FLD(f) abuf->fields.fmt_empty.f
d2037 1
a2037 1
#define FLD(f) abuf->fields.fmt_empty.f
d2058 1
a2058 1
#define FLD(f) abuf->fields.fmt_empty.f
d3928 1
a3928 1
#define FLD(f) abuf->fields.fmt_empty.f
d4248 1
a4248 1
#define FLD(f) abuf->fields.fmt_empty.f
d4282 1
a4282 1
#define FLD(f) abuf->fields.fmt_empty.f
d4303 1
a4303 1
#define FLD(f) abuf->fields.fmt_empty.f
@


1.4
log
@	* arch.c: Regenerate.
	* arch.h: Regenerate.
	* cpu.c: Regenerate.
	* cpu.h: Regenerate.
	* cpuall.h: Regenerate.
	* decode-compact.c: Regenerate.
	* decode-compact.h: Regenerate.
	* decode-media.c: Regenerate.
	* decode-media.h: Regenerate.
	* defs-compact.h: Regenerate.
	* defs-media.h: Regenerate.
	* sem-compact-switch.c: Regenerate.
	* sem-compact.c: Regenerate.
	* sem-media-switch.c: Regenerate.
	* sem-media.c: Regenerate.
	* sh-desc.c: Regenerate.
	* sh-opc.h: Regenerate.
@
text
@d5 1
a5 1
Copyright 1996-2009 Free Software Foundation, Inc.
@


1.3
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d5 1
a5 1
Copyright 1996-2005 Free Software Foundation, Inc.
d9 13
a21 12
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
@


1.2
log
@2006-10-18  Dave Brolley  <brolley@@redhat.com>

        * Contribute the following changes:

        2006-06-14  Dave Brolley  <brolley@@redhat.com>

        * sh64-sim.h (sh64_fipr,sh64_fiprs,sh64_fldp,sh64_fstp,sh64_ftrv)
        (sh64_fpref): New functions.
        * sh64.c (sh64_fipr,sh64_fiprs,sh64_fldp,sh64_fstp,sh64_ftrv)
        (sh64_fpref): New functions.
        (sh_models): Add sh2e, sh2a, sh2a_nofpu, sh4_nofpu, sh4a,
        sh4a_nofpu and sh4al.
        (sh2e_mach): New MACH.
        (sh2a_fpu_mach): New MACH.
        (sh2a_nofpu_mach): New MACH.
        (sh4_nofpu): New MACH.
        (sh4a_mach): New MACH.
        (sh4a_nofpu_mach): New MACH.
        (sh4al_mach): New MACH.
        * Makefile.in (stamp-*): Depend on $(CGEN_CPU_DIR)/sh-sim.cpu. Pass
        archfile to CGEN script.
        * arch.c: Regenerated.
        * arch.h: Regenerated.
        * cpu.c: Regenerated.
        * cpu.h: Regenerated.
        * cpuall.h: Regenerated.
        * decode-compact.c: Regenerated.
        * decode-compact.h: Regenerated.
        * decode-media.c: Regenerated.
        * decode-media.h: Regenerated.
        * defs-compact.h: Regenerated.
        * defs-media.h: Regenerated.
        * sem-compact-switch.c: Regenerated.
        * sem-compact.c: Regenerated.
        * sem-media-switch.c: Regenerated.
        * sem-media.c: Regenerated.
        * sh-desc.c: Regenerated.
        * sh-desc.h: Regenerated.
        * sh-opc.h: Regenerated.
@
text
@d11 2
a12 2
the Free Software Foundation; either version 2, or (at your option)
any later version.
d19 2
a20 3
You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
@


1.1
log
@* Contribute Hitachi SH5 simulator.
@
text
@d5 1
a5 1
Copyright (C) 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
d7 1
a7 1
This file is part of the GNU Simulators.
d21 1
a21 1
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
d209 1
a209 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d218 1
a218 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d239 1
a239 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d251 1
a251 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d263 1
a263 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d281 1
a281 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d293 1
a293 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d311 1
a311 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d320 1
a320 1
    TRACE_RESULT (current_cpu, abuf, "rn64", 'D', opval);
d341 1
a341 1
    TRACE_RESULT (current_cpu, abuf, "r0", 'x', opval);
d417 8
d427 1
a427 1
    written |= (1 << 2);
d432 1
d454 7
d466 1
d487 7
d499 1
d542 8
d582 8
d645 8
d655 1
a655 1
    written |= (1 << 2);
d660 1
d743 1
a743 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d785 1
a785 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d806 1
a806 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d827 1
a827 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d848 1
a848 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d911 1
a911 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d941 1
a941 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1007 1
a1007 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1026 1
a1026 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d1035 1
a1035 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d1058 1
a1058 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d1083 1
a1083 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d1106 1
a1106 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d1136 42
d1183 1
a1183 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1213 1
a1213 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1253 1
a1253 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d1271 1
a1271 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1280 1
a1280 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d1292 1
a1292 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1301 1
a1301 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d1313 1
a1313 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1322 1
a1322 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d1334 1
a1334 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1343 1
a1343 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d1363 4
a1366 4
    DF opval = sh64_fabsd (current_cpu, GET_H_DR (FLD (f_rn)));
    SET_H_DR (FLD (f_rn), opval);
    written |= (1 << 5);
    TRACE_RESULT (current_cpu, abuf, "dr-index-of--DFLT-fsdn", 'f', opval);
d1370 4
a1373 4
    SF opval = sh64_fabss (current_cpu, GET_H_FRC (FLD (f_rn)));
    SET_H_FRC (FLD (f_rn), opval);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "fsdn", 'f', opval);
d1387 1
a1387 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1395 4
a1398 4
    DF opval = sh64_faddd (current_cpu, GET_H_DR (FLD (f_rm)), GET_H_DR (FLD (f_rn)));
    SET_H_DR (FLD (f_rn), opval);
    written |= (1 << 8);
    TRACE_RESULT (current_cpu, abuf, "dr-index-of--DFLT-fsdn", 'f', opval);
d1402 4
a1405 4
    SF opval = sh64_fadds (current_cpu, GET_H_FRC (FLD (f_rm)), GET_H_FRC (FLD (f_rn)));
    SET_H_FRC (FLD (f_rn), opval);
    written |= (1 << 7);
    TRACE_RESULT (current_cpu, abuf, "fsdn", 'f', opval);
d1419 1
a1419 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1427 1
a1427 1
    BI opval = sh64_fcmpeqd (current_cpu, GET_H_DR (FLD (f_rm)), GET_H_DR (FLD (f_rn)));
d1429 1
a1429 1
    written |= (1 << 7);
d1434 1
a1434 1
    BI opval = sh64_fcmpeqs (current_cpu, GET_H_FRC (FLD (f_rm)), GET_H_FRC (FLD (f_rn)));
d1436 1
a1436 1
    written |= (1 << 7);
d1451 1
a1451 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1459 1
a1459 1
    BI opval = sh64_fcmpgtd (current_cpu, GET_H_DR (FLD (f_rn)), GET_H_DR (FLD (f_rm)));
d1461 1
a1461 1
    written |= (1 << 7);
d1466 1
a1466 1
    BI opval = sh64_fcmpgts (current_cpu, GET_H_FRC (FLD (f_rn)), GET_H_FRC (FLD (f_rm)));
d1468 1
a1468 1
    written |= (1 << 7);
d1483 1
a1483 1
#define FLD(f) abuf->fields.sfmt_fcnvds_compact.f
d1492 1
a1492 1
    TRACE_RESULT (current_cpu, abuf, "fpul", 'f', opval);
d1504 1
a1504 1
#define FLD(f) abuf->fields.sfmt_fcnvds_compact.f
d1513 1
a1513 1
    TRACE_RESULT (current_cpu, abuf, "drn", 'f', opval);
d1525 1
a1525 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1533 4
a1536 4
    DF opval = sh64_fdivd (current_cpu, GET_H_DR (FLD (f_rn)), GET_H_DR (FLD (f_rm)));
    SET_H_DR (FLD (f_rn), opval);
    written |= (1 << 8);
    TRACE_RESULT (current_cpu, abuf, "dr-index-of--DFLT-fsdn", 'f', opval);
d1540 4
a1543 4
    SF opval = sh64_fdivs (current_cpu, GET_H_FRC (FLD (f_rn)), GET_H_FRC (FLD (f_rm)));
    SET_H_FRC (FLD (f_rn), opval);
    written |= (1 << 7);
    TRACE_RESULT (current_cpu, abuf, "fsdn", 'f', opval);
d1563 1
a1563 16
{
  QI tmp_m;
  QI tmp_n;
  SF tmp_res;
  tmp_m = FLD (f_vm);
  tmp_n = FLD (f_vn);
  tmp_res = sh64_fmuls (current_cpu, GET_H_FVC (FLD (f_vm)), GET_H_FVC (FLD (f_vn)));
  tmp_res = sh64_fadds (current_cpu, tmp_res, sh64_fmuls (current_cpu, GET_H_FRC (ADDQI (tmp_m, 1)), GET_H_FRC (ADDQI (tmp_n, 1))));
  tmp_res = sh64_fadds (current_cpu, tmp_res, sh64_fmuls (current_cpu, GET_H_FRC (ADDQI (tmp_m, 2)), GET_H_FRC (ADDQI (tmp_n, 2))));
  tmp_res = sh64_fadds (current_cpu, tmp_res, sh64_fmuls (current_cpu, GET_H_FRC (ADDQI (tmp_m, 3)), GET_H_FRC (ADDQI (tmp_n, 3))));
  {
    SF opval = tmp_res;
    SET_H_FRC (ADDQI (tmp_n, 3), opval);
    TRACE_RESULT (current_cpu, abuf, "frc-add--DFLT-n-3", 'f', opval);
  }
}
d1569 1
a1569 1
/* flds-compact: flds $frn */
d1583 1
a1583 1
    TRACE_RESULT (current_cpu, abuf, "fpul", 'f', opval);
d1604 1
a1604 1
    TRACE_RESULT (current_cpu, abuf, "frn", 'f', opval);
d1625 1
a1625 1
    TRACE_RESULT (current_cpu, abuf, "frn", 'f', opval);
d1646 3
a1648 3
    SET_H_DR (FLD (f_rn), opval);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "dr-index-of--DFLT-fsdn", 'f', opval);
d1652 4
a1655 4
    SF opval = sh64_floatls (current_cpu, CPU (h_fr[((UINT) 32)]));
    SET_H_FRC (FLD (f_rn), opval);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "fsdn", 'f', opval);
d1669 1
a1669 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1678 1
a1678 1
    TRACE_RESULT (current_cpu, abuf, "frn", 'f', opval);
d1685 1
a1685 1
/* fmov1-compact: fmov $frm, $frn */
d1690 1
a1690 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
a1695 1
if (NOTBI (GET_H_SZBIT ())) {
d1697 3
a1699 4
    SF opval = GET_H_FRC (FLD (f_rm));
    SET_H_FRC (FLD (f_rn), opval);
    written |= (1 << 6);
    TRACE_RESULT (current_cpu, abuf, "frn", 'f', opval);
a1700 35
} else {
if (EQSI (ANDSI (FLD (f_rm), 1), 1)) {
if (EQSI (ANDSI (FLD (f_rn), 1), 1)) {
  {
    DF opval = GET_H_XD (((FLD (f_rm)) & (INVQI (1))));
    SET_H_XD (((FLD (f_rn)) & (INVQI (1))), opval);
    written |= (1 << 8);
    TRACE_RESULT (current_cpu, abuf, "xd-and--DFLT-index-of--DFLT-frn-inv--QI-1", 'f', opval);
  }
} else {
  {
    DF opval = GET_H_XD (((FLD (f_rm)) & (INVQI (1))));
    SET_H_DR (FLD (f_rn), opval);
    written |= (1 << 7);
    TRACE_RESULT (current_cpu, abuf, "dr-index-of--DFLT-frn", 'f', opval);
  }
}
} else {
if (EQSI (ANDSI (FLD (f_rn), 1), 1)) {
  {
    DF opval = GET_H_DR (FLD (f_rm));
    SET_H_XD (((FLD (f_rn)) & (INVQI (1))), opval);
    written |= (1 << 8);
    TRACE_RESULT (current_cpu, abuf, "xd-and--DFLT-index-of--DFLT-frn-inv--QI-1", 'f', opval);
  }
} else {
  {
    DF opval = GET_H_DR (FLD (f_rm));
    SET_H_DR (FLD (f_rn), opval);
    written |= (1 << 7);
    TRACE_RESULT (current_cpu, abuf, "dr-index-of--DFLT-frn", 'f', opval);
  }
}
}
}
a1701 1
  abuf->written = written;
d1706 1
a1706 1
/* fmov2-compact: fmov @@$rm, $frn */
d1711 1
a1711 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1719 4
a1722 4
    SF opval = GETMEMSF (current_cpu, pc, GET_H_GRC (FLD (f_rm)));
    SET_H_FRC (FLD (f_rn), opval);
    written |= (1 << 5);
    TRACE_RESULT (current_cpu, abuf, "frn", 'f', opval);
a1724 1
if (EQSI (ANDSI (FLD (f_rn), 1), 1)) {
d1727 3
a1729 10
    SET_H_XD (((FLD (f_rn)) & (INVQI (1))), opval);
    written |= (1 << 7);
    TRACE_RESULT (current_cpu, abuf, "xd-and--DFLT-index-of--DFLT-frn-inv--QI-1", 'f', opval);
  }
} else {
  {
    DF opval = GETMEMDF (current_cpu, pc, GET_H_GRC (FLD (f_rm)));
    SET_H_DR (FLD (f_rn), opval);
    written |= (1 << 6);
    TRACE_RESULT (current_cpu, abuf, "dr-index-of--DFLT-frn", 'f', opval);
a1731 1
}
d1738 1
a1738 1
/* fmov3-compact: fmov @@${rm}+, frn */
d1743 1
a1743 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1752 4
a1755 4
    SF opval = GETMEMSF (current_cpu, pc, GET_H_GRC (FLD (f_rm)));
    SET_H_FRC (FLD (f_rn), opval);
    written |= (1 << 5);
    TRACE_RESULT (current_cpu, abuf, "frn", 'f', opval);
d1760 2
a1761 2
    written |= (1 << 8);
    TRACE_RESULT (current_cpu, abuf, "rm", 'x', opval);
a1765 1
if (EQSI (ANDSI (FLD (f_rn), 1), 1)) {
d1768 3
a1770 3
    SET_H_XD (((FLD (f_rn)) & (INVQI (1))), opval);
    written |= (1 << 7);
    TRACE_RESULT (current_cpu, abuf, "xd-and--DFLT-index-of--DFLT-frn-inv--QI-1", 'f', opval);
a1771 8
} else {
  {
    DF opval = GETMEMDF (current_cpu, pc, GET_H_GRC (FLD (f_rm)));
    SET_H_DR (FLD (f_rn), opval);
    written |= (1 << 6);
    TRACE_RESULT (current_cpu, abuf, "dr-index-of--DFLT-frn", 'f', opval);
  }
}
d1775 2
a1776 2
    written |= (1 << 8);
    TRACE_RESULT (current_cpu, abuf, "rm", 'x', opval);
d1786 1
a1786 1
/* fmov4-compact: fmov @@(r0, $rm), $frn */
d1791 1
a1791 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1799 4
a1802 4
    SF opval = GETMEMSF (current_cpu, pc, ADDSI (GET_H_GRC (((UINT) 0)), GET_H_GRC (FLD (f_rm))));
    SET_H_FRC (FLD (f_rn), opval);
    written |= (1 << 6);
    TRACE_RESULT (current_cpu, abuf, "frn", 'f', opval);
a1804 1
if (EQSI (ANDSI (FLD (f_rn), 1), 1)) {
d1807 3
a1809 10
    SET_H_XD (((FLD (f_rn)) & (INVQI (1))), opval);
    written |= (1 << 8);
    TRACE_RESULT (current_cpu, abuf, "xd-and--DFLT-index-of--DFLT-frn-inv--QI-1", 'f', opval);
  }
} else {
  {
    DF opval = GETMEMDF (current_cpu, pc, ADDSI (GET_H_GRC (((UINT) 0)), GET_H_GRC (FLD (f_rm))));
    SET_H_DR (FLD (f_rn), opval);
    written |= (1 << 7);
    TRACE_RESULT (current_cpu, abuf, "dr-index-of--DFLT-frn", 'f', opval);
a1811 1
}
d1818 1
a1818 1
/* fmov5-compact: fmov $frm, @@$rn */
d1823 1
a1823 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1831 1
a1831 1
    SF opval = GET_H_FRC (FLD (f_rm));
d1833 1
a1833 1
    written |= (1 << 6);
a1836 1
if (EQSI (ANDSI (FLD (f_rm), 1), 1)) {
d1838 1
a1838 1
    DF opval = GET_H_XD (((FLD (f_rm)) & (INVQI (1))));
d1840 1
a1840 8
    written |= (1 << 7);
    TRACE_RESULT (current_cpu, abuf, "memory", 'f', opval);
  }
} else {
  {
    DF opval = GET_H_DR (FLD (f_rm));
    SETMEMDF (current_cpu, pc, GET_H_GRC (FLD (f_rn)), opval);
    written |= (1 << 7);
a1843 1
}
d1850 1
a1850 1
/* fmov6-compact: fmov $frm, @@-$rn */
d1855 1
a1855 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1866 2
a1867 2
    written |= (1 << 8);
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d1870 1
a1870 1
    SF opval = GET_H_FRC (FLD (f_rm));
d1872 1
a1872 1
    written |= (1 << 6);
d1881 2
a1882 2
    written |= (1 << 8);
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
a1883 1
if (EQSI (ANDSI (FLD (f_rm), 1), 1)) {
d1885 1
a1885 1
    DF opval = GET_H_XD (((FLD (f_rm)) & (INVQI (1))));
d1887 1
a1887 1
    written |= (1 << 7);
a1889 8
} else {
  {
    DF opval = GET_H_DR (FLD (f_rm));
    SETMEMDF (current_cpu, pc, GET_H_GRC (FLD (f_rn)), opval);
    written |= (1 << 7);
    TRACE_RESULT (current_cpu, abuf, "memory", 'f', opval);
  }
}
d1898 1
a1898 1
/* fmov7-compact: fmov $frm, @@(r0, $rn) */
d1903 1
a1903 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1911 1
a1911 1
    SF opval = GET_H_FRC (FLD (f_rm));
d1913 1
a1913 1
    written |= (1 << 7);
a1916 1
if (EQSI (ANDSI (FLD (f_rm), 1), 1)) {
d1918 1
a1918 1
    DF opval = GET_H_XD (((FLD (f_rm)) & (INVQI (1))));
d1920 1
a1920 1
    written |= (1 << 8);
d1923 39
a1961 1
} else {
d1963 2
a1964 3
    DF opval = GET_H_DR (FLD (f_rm));
    SETMEMDF (current_cpu, pc, ADDSI (GET_H_GRC (((UINT) 0)), GET_H_GRC (FLD (f_rn))), opval);
    written |= (1 << 8);
a1966 2
}
}
a1967 1
  abuf->written = written;
d1977 1
a1977 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d1985 4
a1988 4
    DF opval = sh64_fmuld (current_cpu, GET_H_DR (FLD (f_rm)), GET_H_DR (FLD (f_rn)));
    SET_H_DR (FLD (f_rn), opval);
    written |= (1 << 8);
    TRACE_RESULT (current_cpu, abuf, "dr-index-of--DFLT-fsdn", 'f', opval);
d1992 4
a1995 4
    SF opval = sh64_fmuls (current_cpu, GET_H_FRC (FLD (f_rm)), GET_H_FRC (FLD (f_rn)));
    SET_H_FRC (FLD (f_rn), opval);
    written |= (1 << 7);
    TRACE_RESULT (current_cpu, abuf, "fsdn", 'f', opval);
d2017 4
a2020 4
    DF opval = sh64_fnegd (current_cpu, GET_H_DR (FLD (f_rn)));
    SET_H_DR (FLD (f_rn), opval);
    written |= (1 << 5);
    TRACE_RESULT (current_cpu, abuf, "dr-index-of--DFLT-fsdn", 'f', opval);
d2024 4
a2027 4
    SF opval = sh64_fnegs (current_cpu, GET_H_FRC (FLD (f_rn)));
    SET_H_FRC (FLD (f_rn), opval);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "fsdn", 'f', opval);
d2091 4
a2094 4
    DF opval = sh64_fsqrtd (current_cpu, GET_H_DR (FLD (f_rn)));
    SET_H_DR (FLD (f_rn), opval);
    written |= (1 << 5);
    TRACE_RESULT (current_cpu, abuf, "dr-index-of--DFLT-fsdn", 'f', opval);
d2098 4
a2101 4
    SF opval = sh64_fsqrts (current_cpu, GET_H_FRC (FLD (f_rn)));
    SET_H_FRC (FLD (f_rn), opval);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "fsdn", 'f', opval);
d2124 1
a2124 1
    TRACE_RESULT (current_cpu, abuf, "frn", 'f', opval);
d2136 1
a2136 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d2144 4
a2147 4
    DF opval = sh64_fsubd (current_cpu, GET_H_DR (FLD (f_rn)), GET_H_DR (FLD (f_rm)));
    SET_H_DR (FLD (f_rn), opval);
    written |= (1 << 8);
    TRACE_RESULT (current_cpu, abuf, "dr-index-of--DFLT-fsdn", 'f', opval);
d2151 4
a2154 4
    SF opval = sh64_fsubs (current_cpu, GET_H_FRC (FLD (f_rn)), GET_H_FRC (FLD (f_rm)));
    SET_H_FRC (FLD (f_rn), opval);
    written |= (1 << 7);
    TRACE_RESULT (current_cpu, abuf, "fsdn", 'f', opval);
d2175 1
a2175 1
    SF opval = ((GET_H_PRBIT ()) ? (sh64_ftrcdl (current_cpu, GET_H_DR (FLD (f_rn)))) : (sh64_ftrcsl (current_cpu, GET_H_FRC (FLD (f_rn)))));
d2177 1
a2177 1
    TRACE_RESULT (current_cpu, abuf, "fpul", 'f', opval);
d2195 1
a2195 41
{
  QI tmp_n;
  SF tmp_res;
  tmp_n = FLD (f_vn);
  tmp_res = sh64_fmuls (current_cpu, GET_H_XF (((UINT) 0)), GET_H_FRC (tmp_n));
  tmp_res = sh64_fadds (current_cpu, tmp_res, sh64_fmuls (current_cpu, GET_H_XF (((UINT) 4)), GET_H_FRC (ADDQI (tmp_n, 1))));
  tmp_res = sh64_fadds (current_cpu, tmp_res, sh64_fmuls (current_cpu, GET_H_XF (((UINT) 8)), GET_H_FRC (ADDQI (tmp_n, 2))));
  tmp_res = sh64_fadds (current_cpu, tmp_res, sh64_fmuls (current_cpu, GET_H_XF (((UINT) 12)), GET_H_FRC (ADDQI (tmp_n, 3))));
  {
    SF opval = tmp_res;
    SET_H_FRC (tmp_n, opval);
    TRACE_RESULT (current_cpu, abuf, "frc-n", 'f', opval);
  }
  tmp_res = sh64_fmuls (current_cpu, GET_H_XF (((UINT) 1)), GET_H_FRC (tmp_n));
  tmp_res = sh64_fadds (current_cpu, tmp_res, sh64_fmuls (current_cpu, GET_H_XF (((UINT) 5)), GET_H_FRC (ADDQI (tmp_n, 1))));
  tmp_res = sh64_fadds (current_cpu, tmp_res, sh64_fmuls (current_cpu, GET_H_XF (((UINT) 9)), GET_H_FRC (ADDQI (tmp_n, 2))));
  tmp_res = sh64_fadds (current_cpu, tmp_res, sh64_fmuls (current_cpu, GET_H_XF (((UINT) 13)), GET_H_FRC (ADDQI (tmp_n, 3))));
  {
    SF opval = tmp_res;
    SET_H_FRC (ADDQI (tmp_n, 1), opval);
    TRACE_RESULT (current_cpu, abuf, "frc-add--DFLT-n-1", 'f', opval);
  }
  tmp_res = sh64_fmuls (current_cpu, GET_H_XF (((UINT) 2)), GET_H_FRC (tmp_n));
  tmp_res = sh64_fadds (current_cpu, tmp_res, sh64_fmuls (current_cpu, GET_H_XF (((UINT) 6)), GET_H_FRC (ADDQI (tmp_n, 1))));
  tmp_res = sh64_fadds (current_cpu, tmp_res, sh64_fmuls (current_cpu, GET_H_XF (((UINT) 10)), GET_H_FRC (ADDQI (tmp_n, 2))));
  tmp_res = sh64_fadds (current_cpu, tmp_res, sh64_fmuls (current_cpu, GET_H_XF (((UINT) 14)), GET_H_FRC (ADDQI (tmp_n, 3))));
  {
    SF opval = tmp_res;
    SET_H_FRC (ADDQI (tmp_n, 2), opval);
    TRACE_RESULT (current_cpu, abuf, "frc-add--DFLT-n-2", 'f', opval);
  }
  tmp_res = sh64_fmuls (current_cpu, GET_H_XF (((UINT) 3)), GET_H_FRC (tmp_n));
  tmp_res = sh64_fadds (current_cpu, tmp_res, sh64_fmuls (current_cpu, GET_H_XF (((UINT) 7)), GET_H_FRC (ADDQI (tmp_n, 1))));
  tmp_res = sh64_fadds (current_cpu, tmp_res, sh64_fmuls (current_cpu, GET_H_XF (((UINT) 11)), GET_H_FRC (ADDQI (tmp_n, 2))));
  tmp_res = sh64_fadds (current_cpu, tmp_res, sh64_fmuls (current_cpu, GET_H_XF (((UINT) 15)), GET_H_FRC (ADDQI (tmp_n, 3))));
  {
    SF opval = tmp_res;
    SET_H_FRC (ADDQI (tmp_n, 3), opval);
    TRACE_RESULT (current_cpu, abuf, "frc-add--DFLT-n-3", 'f', opval);
  }
}
d2215 7
d2227 2
d2251 78
a2328 3
    SET_H_PR (opval);
    TRACE_RESULT (current_cpu, abuf, "pr", 'x', opval);
  }
d2330 3
a2332 3
    UDI opval = GET_H_GRC (FLD (f_rn));
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'D', opval);
a2333 2
}
}
a2334 1
  SEM_BRANCH_FINI (vpc);
d2339 1
a2339 1
/* ldc-compact: ldc $rn, gbr */
d2342 1
a2342 1
SEM_FN_NAME (sh64_compact,ldc_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
d2350 1
d2352 1
a2352 1
    SI opval = GET_H_GRC (FLD (f_rn));
d2356 6
d2367 1
a2367 1
/* ldcl-compact: ldc.l @@${rn}+, gbr */
d2370 1
a2370 1
SEM_FN_NAME (sh64_compact,ldcl_compact) (SIM_CPU *current_cpu, SEM_ARG sem_arg)
d2381 2
a2382 2
    SET_H_GBR (opval);
    TRACE_RESULT (current_cpu, abuf, "gbr", 'x', opval);
d2387 1
a2387 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d2408 1
a2408 1
    SET_H_FPCCR (opval);
d2430 1
a2430 1
    SET_H_FPCCR (opval);
d2436 1
a2436 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d2458 1
a2458 1
    TRACE_RESULT (current_cpu, abuf, "fpul", 'f', opval);
d2480 1
a2480 1
    TRACE_RESULT (current_cpu, abuf, "fpul", 'f', opval);
d2485 1
a2485 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d2534 1
a2534 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d2583 1
a2583 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d2632 1
a2632 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d2645 1
a2645 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d2661 1
a2661 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d2668 1
a2668 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d2674 1
a2674 1
    TRACE_RESULT (current_cpu, abuf, "rm", 'x', opval);
d2683 1
a2683 1
    TRACE_RESULT (current_cpu, abuf, "rm", 'x', opval);
d2727 1
a2727 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d2743 1
a2743 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d2750 1
a2750 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d2756 1
a2756 1
    TRACE_RESULT (current_cpu, abuf, "rm", 'x', opval);
d2765 1
a2765 1
    TRACE_RESULT (current_cpu, abuf, "rm", 'x', opval);
d2815 1
a2815 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d2824 1
a2824 1
    TRACE_RESULT (current_cpu, abuf, "rn64", 'D', opval);
d2845 22
a2866 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d2878 1
a2878 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d2899 1
a2899 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d2916 1
a2916 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d2929 1
a2929 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3000 1
a3000 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3009 1
a3009 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d3021 1
a3021 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3035 1
a3035 1
    TRACE_RESULT (current_cpu, abuf, "rm", 'x', opval);
d3042 1
a3042 1
    TRACE_RESULT (current_cpu, abuf, "rm", 'x', opval);
d3048 1
a3048 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d3062 1
a3062 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3071 1
a3071 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d3092 1
a3092 1
    TRACE_RESULT (current_cpu, abuf, "r0", 'x', opval);
d3113 1
a3113 1
    TRACE_RESULT (current_cpu, abuf, "r0", 'x', opval);
d3125 1
a3125 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3146 1
a3146 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3163 1
a3163 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d3176 1
a3176 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3239 1
a3239 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3248 1
a3248 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d3260 1
a3260 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3270 1
a3270 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d3277 1
a3277 1
    TRACE_RESULT (current_cpu, abuf, "rm", 'x', opval);
d3284 1
a3284 1
    TRACE_RESULT (current_cpu, abuf, "rm", 'x', opval);
d3299 1
a3299 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3308 1
a3308 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d3329 1
a3329 1
    TRACE_RESULT (current_cpu, abuf, "r0", 'x', opval);
d3350 1
a3350 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d3371 43
a3413 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d3425 1
a3425 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3446 1
a3446 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3463 1
a3463 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d3476 1
a3476 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3513 1
a3513 1
/* movw5-compact: mov.w r0, @@($imm4x2, $rn) */
d3526 1
a3526 1
    SETMEMHI (current_cpu, pc, ADDSI (GET_H_GRC (FLD (f_rn)), FLD (f_imm4x2)), opval);
d3539 1
a3539 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3548 1
a3548 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d3560 1
a3560 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3574 1
a3574 1
    TRACE_RESULT (current_cpu, abuf, "rm", 'x', opval);
d3581 1
a3581 1
    TRACE_RESULT (current_cpu, abuf, "rm", 'x', opval);
d3587 1
a3587 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d3601 1
a3601 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3610 1
a3610 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d3631 1
a3631 1
    TRACE_RESULT (current_cpu, abuf, "r0", 'x', opval);
d3652 1
a3652 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d3664 1
a3664 1
#define FLD(f) abuf->fields.sfmt_movw11_compact.f
d3673 1
a3673 1
    TRACE_RESULT (current_cpu, abuf, "r0", 'x', opval);
d3694 1
a3694 1
    TRACE_RESULT (current_cpu, abuf, "r0", 'x', opval);
d3722 21
d3757 49
a3805 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d3807 1
d3818 1
a3818 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3839 1
a3839 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3860 1
a3860 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3881 1
a3881 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3890 1
a3890 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d3902 1
a3902 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3914 1
a3914 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d3949 1
a3949 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d3958 1
a3958 1
    TRACE_RESULT (current_cpu, abuf, "rn64", 'D', opval);
d3970 1
a3970 1
#define FLD(f) abuf->fields.fmt_empty.f
d3976 6
d3983 1
d3994 1
a3994 1
#define FLD(f) abuf->fields.fmt_empty.f
d4000 6
d4007 1
d4018 1
a4018 1
#define FLD(f) abuf->fields.fmt_empty.f
d4024 6
d4031 1
d4042 1
a4042 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d4051 1
a4051 1
    TRACE_RESULT (current_cpu, abuf, "rn64", 'D', opval);
d4072 1
a4072 1
    TRACE_RESULT (current_cpu, abuf, "r0", 'x', opval);
d4111 1
a4111 1
#define FLD(f) abuf->fields.fmt_empty.f
d4117 1
a4117 1
((void) 0); /*nop*/
d4140 1
a4140 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4172 1
a4172 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4202 1
a4202 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4234 1
a4234 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4261 7
d4273 2
d4328 1
a4328 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d4335 2
a4336 2
  QI tmp_shamt;
  tmp_shamt = ANDQI (GET_H_GRC (FLD (f_rm)), 31);
d4341 2
a4342 2
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4345 1
a4345 1
if (NEQI (tmp_shamt, 0)) {
d4349 2
a4350 2
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4357 2
a4358 2
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4364 2
a4365 2
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4394 1
a4394 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4424 1
a4424 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4442 1
a4442 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d4449 2
a4450 2
  QI tmp_shamt;
  tmp_shamt = ANDQI (GET_H_GRC (FLD (f_rm)), 31);
d4455 2
a4456 2
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4459 1
a4459 1
if (NEQI (tmp_shamt, 0)) {
d4463 2
a4464 2
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4470 2
a4471 2
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4499 1
a4499 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4526 1
a4526 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4547 1
a4547 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4568 1
a4568 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4592 1
a4592 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4619 1
a4619 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4640 1
a4640 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4661 1
a4661 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4682 22
a4703 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4732 31
a4762 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4782 1
a4782 1
    SI opval = GET_H_FPCCR ();
d4784 1
a4784 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4806 1
a4806 1
    SI opval = GET_H_FPCCR ();
d4813 1
a4813 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4835 1
a4835 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4864 1
a4864 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4886 1
a4886 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4915 1
a4915 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4937 1
a4937 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4966 1
a4966 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d4988 1
a4988 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d5017 1
a5017 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d5030 1
a5030 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d5039 1
a5039 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d5051 1
a5051 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d5063 1
a5063 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d5081 1
a5081 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d5093 1
a5093 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d5111 1
a5111 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d5127 1
a5127 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d5140 1
a5140 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d5149 1
a5149 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d5209 1
a5209 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d5276 1
a5276 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d5285 1
a5285 1
    TRACE_RESULT (current_cpu, abuf, "rn64", 'D', opval);
d5304 3
a5306 3
    DI opval = XORDI (GET_H_GR (((UINT) 0)), ZEXTSIDI (FLD (f_imm8)));
    SET_H_GR (((UINT) 0), opval);
    TRACE_RESULT (current_cpu, abuf, "gr-0", 'D', opval);
d5345 1
a5345 1
#define FLD(f) abuf->fields.sfmt_movl5_compact.f
d5354 1
a5354 1
    TRACE_RESULT (current_cpu, abuf, "rn", 'x', opval);
d5401 2
d5430 2
d5443 5
a5447 2
  { SH64_COMPACT_INSN_LDC_COMPACT, SEM_FN_NAME (sh64_compact,ldc_compact) },
  { SH64_COMPACT_INSN_LDCL_COMPACT, SEM_FN_NAME (sh64_compact,ldcl_compact) },
d5462 1
d5484 2
d5499 1
d5501 2
d5537 1
d5539 1
@

