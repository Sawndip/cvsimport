head	1.14;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.14
	gdb_7_6-2013-04-26-release:1.14
	gdb_7_6-branch:1.14.0.2
	gdb_7_6-2013-03-12-branchpoint:1.14
	gdb_7_5_1-2012-11-29-release:1.12
	gdb_7_5-2012-08-17-release:1.12
	gdb_7_5-branch:1.12.0.2
	gdb_7_5-2012-07-18-branchpoint:1.12
	gdb_7_4_1-2012-04-26-release:1.11.8.1
	gdb_7_4-2012-01-24-release:1.11.8.1
	gdb_7_4-branch:1.11.0.8
	gdb_7_4-2011-12-13-branchpoint:1.11
	gdb_7_3_1-2011-09-04-release:1.11
	gdb_7_3-2011-07-26-release:1.11
	gdb_7_3-branch:1.11.0.6
	gdb_7_3-2011-04-01-branchpoint:1.11
	gdb_7_2-2010-09-02-release:1.11
	gdb_7_2-branch:1.11.0.4
	gdb_7_2-2010-07-07-branchpoint:1.11
	gdb_7_1-2010-03-18-release:1.11
	gdb_7_1-branch:1.11.0.2
	gdb_7_1-2010-02-18-branchpoint:1.11
	gdb_7_0_1-2009-12-22-release:1.8
	gdb_7_0-2009-10-06-release:1.8
	gdb_7_0-branch:1.8.0.22
	gdb_7_0-2009-09-16-branchpoint:1.8
	arc-sim-20090309:1.8
	msnyder-checkpoint-072509-branch:1.8.0.20
	msnyder-checkpoint-072509-branchpoint:1.8
	arc-insight_6_8-branch:1.8.0.18
	arc-insight_6_8-branchpoint:1.8
	insight_6_8-branch:1.8.0.16
	insight_6_8-branchpoint:1.8
	reverse-20081226-branch:1.8.0.14
	reverse-20081226-branchpoint:1.8
	multiprocess-20081120-branch:1.8.0.12
	multiprocess-20081120-branchpoint:1.8
	reverse-20080930-branch:1.8.0.10
	reverse-20080930-branchpoint:1.8
	reverse-20080717-branch:1.8.0.8
	reverse-20080717-branchpoint:1.8
	msnyder-reverse-20080609-branch:1.8.0.6
	msnyder-reverse-20080609-branchpoint:1.8
	drow-reverse-20070409-branch:1.7.0.50
	drow-reverse-20070409-branchpoint:1.7
	gdb_6_8-2008-03-27-release:1.8
	gdb_6_8-branch:1.8.0.4
	gdb_6_8-2008-02-26-branchpoint:1.8
	gdb_6_7_1-2007-10-29-release:1.8
	gdb_6_7-2007-10-10-release:1.8
	gdb_6_7-branch:1.8.0.2
	gdb_6_7-2007-09-07-branchpoint:1.8
	insight_6_6-20070208-release:1.7
	gdb_6_6-2006-12-18-release:1.7
	gdb_6_6-branch:1.7.0.48
	gdb_6_6-2006-11-15-branchpoint:1.7
	insight_6_5-20061003-release:1.7
	gdb-csl-symbian-6_4_50_20060226-12:1.7
	gdb-csl-sourcerygxx-3_4_4-25:1.7
	nickrob-async-20060828-mergepoint:1.7
	gdb-csl-symbian-6_4_50_20060226-11:1.7
	gdb-csl-sourcerygxx-4_1-17:1.7
	gdb-csl-20060226-branch-local-2:1.7
	gdb-csl-sourcerygxx-4_1-14:1.7
	gdb-csl-sourcerygxx-4_1-13:1.7
	gdb-csl-sourcerygxx-4_1-12:1.7
	gdb-csl-sourcerygxx-3_4_4-21:1.7
	gdb_6_5-20060621-release:1.7
	gdb-csl-sourcerygxx-4_1-9:1.7
	gdb-csl-sourcerygxx-4_1-8:1.7
	gdb-csl-sourcerygxx-4_1-7:1.7
	gdb-csl-arm-2006q1-6:1.7
	gdb-csl-sourcerygxx-4_1-6:1.7
	gdb-csl-symbian-6_4_50_20060226-10:1.7
	gdb-csl-symbian-6_4_50_20060226-9:1.7
	gdb-csl-symbian-6_4_50_20060226-8:1.7
	gdb-csl-coldfire-4_1-11:1.7
	gdb-csl-sourcerygxx-3_4_4-19:1.7
	gdb-csl-coldfire-4_1-10:1.7
	gdb_6_5-branch:1.7.0.46
	gdb_6_5-2006-05-14-branchpoint:1.7
	gdb-csl-sourcerygxx-4_1-5:1.7
	nickrob-async-20060513-branch:1.7.0.44
	nickrob-async-20060513-branchpoint:1.7
	gdb-csl-sourcerygxx-4_1-4:1.7
	msnyder-reverse-20060502-branch:1.7.0.42
	msnyder-reverse-20060502-branchpoint:1.7
	gdb-csl-morpho-4_1-4:1.7
	gdb-csl-sourcerygxx-3_4_4-17:1.7
	readline_5_1-import-branch:1.7.0.40
	readline_5_1-import-branchpoint:1.7
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.7
	gdb-csl-symbian-20060226-branch:1.7.0.38
	gdb-csl-symbian-20060226-branchpoint:1.7
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.7
	msnyder-reverse-20060331-branch:1.7.0.36
	msnyder-reverse-20060331-branchpoint:1.7
	gdb-csl-available-20060303-branch:1.7.0.34
	gdb-csl-available-20060303-branchpoint:1.7
	gdb-csl-20060226-branch:1.7.0.32
	gdb-csl-20060226-branchpoint:1.7
	gdb_6_4-20051202-release:1.7
	msnyder-fork-checkpoint-branch:1.7.0.30
	msnyder-fork-checkpoint-branchpoint:1.7
	gdb-csl-gxxpro-6_3-branch:1.7.0.28
	gdb-csl-gxxpro-6_3-branchpoint:1.7
	gdb_6_4-branch:1.7.0.26
	gdb_6_4-2005-11-01-branchpoint:1.7
	gdb-csl-arm-20051020-branch:1.7.0.24
	gdb-csl-arm-20051020-branchpoint:1.7
	msnyder-tracepoint-checkpoint-branch:1.7.0.22
	msnyder-tracepoint-checkpoint-branchpoint:1.7
	gdb-csl-arm-20050325-2005-q1b:1.7
	gdb-csl-arm-20050325-2005-q1a:1.7
	csl-arm-20050325-branch:1.7.0.20
	csl-arm-20050325-branchpoint:1.7
	gdb_6_3-20041109-release:1.7
	gdb_6_3-branch:1.7.0.16
	gdb_6_3-20041019-branchpoint:1.7
	drow_intercu-merge-20040921:1.7
	drow_intercu-merge-20040915:1.7
	jimb-gdb_6_2-e500-branch:1.7.0.18
	jimb-gdb_6_2-e500-branchpoint:1.7
	gdb_6_2-20040730-release:1.7
	gdb_6_2-branch:1.7.0.14
	gdb_6_2-2004-07-10-gmt-branchpoint:1.7
	gdb_6_1_1-20040616-release:1.7
	gdb_6_1-2004-04-05-release:1.7
	drow_intercu-merge-20040402:1.7
	drow_intercu-merge-20040327:1.7
	ezannoni_pie-20040323-branch:1.7.0.12
	ezannoni_pie-20040323-branchpoint:1.7
	cagney_tramp-20040321-mergepoint:1.7
	cagney_tramp-20040309-branch:1.7.0.10
	cagney_tramp-20040309-branchpoint:1.7
	gdb_6_1-branch:1.7.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.7
	drow_intercu-20040221-branch:1.7.0.6
	drow_intercu-20040221-branchpoint:1.7
	cagney_bfdfile-20040213-branch:1.7.0.4
	cagney_bfdfile-20040213-branchpoint:1.7
	drow-cplus-merge-20040208:1.7
	carlton_dictionary-20040126-merge:1.7
	cagney_bigcore-20040122-branch:1.7.0.2
	cagney_bigcore-20040122-branchpoint:1.7
	drow-cplus-merge-20040113:1.7
	drow-cplus-merge-20031224:1.7
	drow-cplus-merge-20031220:1.7
	carlton_dictionary-20031215-merge:1.7
	drow-cplus-merge-20031214:1.7
	carlton-dictionary-20031111-merge:1.6
	gdb_6_0-2003-10-04-release:1.6
	kettenis_sparc-20030918-branch:1.6.0.40
	kettenis_sparc-20030918-branchpoint:1.6
	carlton_dictionary-20030917-merge:1.6
	ezannoni_pie-20030916-branchpoint:1.6
	ezannoni_pie-20030916-branch:1.6.0.38
	cagney_x86i386-20030821-branch:1.6.0.36
	cagney_x86i386-20030821-branchpoint:1.6
	carlton_dictionary-20030805-merge:1.6
	carlton_dictionary-20030627-merge:1.6
	gdb_6_0-branch:1.6.0.34
	gdb_6_0-2003-06-23-branchpoint:1.6
	jimb-ppc64-linux-20030613-branch:1.6.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.6
	cagney_convert-20030606-branch:1.6.0.30
	cagney_convert-20030606-branchpoint:1.6
	cagney_writestrings-20030508-branch:1.6.0.28
	cagney_writestrings-20030508-branchpoint:1.6
	jimb-ppc64-linux-20030528-branch:1.6.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.6
	carlton_dictionary-20030523-merge:1.6
	cagney_fileio-20030521-branch:1.6.0.24
	cagney_fileio-20030521-branchpoint:1.6
	kettenis_i386newframe-20030517-mergepoint:1.6
	jimb-ppc64-linux-20030509-branch:1.6.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.6
	kettenis_i386newframe-20030504-mergepoint:1.6
	carlton_dictionary-20030430-merge:1.6
	kettenis_i386newframe-20030419-branch:1.6.0.20
	kettenis_i386newframe-20030419-branchpoint:1.6
	carlton_dictionary-20030416-merge:1.6
	cagney_frameaddr-20030409-mergepoint:1.6
	kettenis_i386newframe-20030406-branch:1.6.0.18
	kettenis_i386newframe-20030406-branchpoint:1.6
	cagney_frameaddr-20030403-branchpoint:1.6
	cagney_frameaddr-20030403-branch:1.6.0.16
	cagney_framebase-20030330-mergepoint:1.6
	cagney_framebase-20030326-branch:1.6.0.14
	cagney_framebase-20030326-branchpoint:1.6
	cagney_lazyid-20030317-branch:1.6.0.12
	cagney_lazyid-20030317-branchpoint:1.6
	kettenis-i386newframe-20030316-mergepoint:1.6
	offbyone-20030313-branch:1.6.0.10
	offbyone-20030313-branchpoint:1.6
	kettenis-i386newframe-20030308-branch:1.6.0.8
	kettenis-i386newframe-20030308-branchpoint:1.6
	carlton_dictionary-20030305-merge:1.6
	cagney_offbyone-20030303-branch:1.6.0.6
	cagney_offbyone-20030303-branchpoint:1.6
	carlton_dictionary-20030207-merge:1.6
	interps-20030202-branch:1.6.0.4
	interps-20030202-branchpoint:1.6
	cagney-unwind-20030108-branch:1.6.0.2
	cagney-unwind-20030108-branchpoint:1.6
	carlton_dictionary-20021223-merge:1.6
	gdb_5_3-2002-12-12-release:1.5
	carlton_dictionary-20021115-merge:1.5
	kseitz_interps-20021105-merge:1.5
	kseitz_interps-20021103-merge:1.5
	drow-cplus-merge-20021020:1.5
	drow-cplus-merge-20021025:1.5
	carlton_dictionary-20021025-merge:1.5
	carlton_dictionary-20021011-merge:1.5
	drow-cplus-branch:1.5.0.18
	drow-cplus-branchpoint:1.5
	kseitz_interps-20020930-merge:1.5
	carlton_dictionary-20020927-merge:1.5
	carlton_dictionary-branch:1.5.0.16
	carlton_dictionary-20020920-branchpoint:1.5
	gdb_5_3-branch:1.5.0.14
	gdb_5_3-2002-09-04-branchpoint:1.5
	kseitz_interps-20020829-merge:1.5
	cagney_sysregs-20020825-branch:1.5.0.12
	cagney_sysregs-20020825-branchpoint:1.5
	readline_4_3-import-branch:1.5.0.10
	readline_4_3-import-branchpoint:1.5
	gdb_5_2_1-2002-07-23-release:1.5
	kseitz_interps-20020528-branch:1.5.0.8
	kseitz_interps-20020528-branchpoint:1.5
	cagney_regbuf-20020515-branch:1.5.0.6
	cagney_regbuf-20020515-branchpoint:1.5
	jimb-macro-020506-branch:1.5.0.4
	jimb-macro-020506-branchpoint:1.5
	gdb_5_2-2002-04-29-release:1.5
	gdb_5_2-branch:1.5.0.2
	gdb_5_2-2002-03-03-branchpoint:1.5
	gdb_5_1_1-2002-01-24-release:1.4
	gdb_5_1_0_1-2002-01-03-release:1.4
	gdb_5_1_0_1-2002-01-03-branch:1.4.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.4
	gdb_5_1-2001-11-21-release:1.4
	gdb_s390-2001-09-26-branch:1.4.0.4
	gdb_s390-2001-09-26-branchpoint:1.4
	gdb_5_1-2001-07-29-branch:1.4.0.2
	gdb_5_1-2001-07-29-branchpoint:1.4
	insight-precleanup-2001-01-01:1.3
	gdb-premipsmulti-2000-06-06-branch:1.1.1.1.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	gdb-2000-02-04:1.1.1.1
	gdb-2000-02-02:1.1.1.1
	gdb-2000-02-01:1.1.1.1
	gdb-2000-01-31:1.1.1.1
	gdb-2000-01-26:1.1.1.1
	gdb-2000-01-24:1.1.1.1
	gdb-2000-01-17:1.1.1.1
	gdb-2000-01-10:1.1.1.1
	gdb-2000-01-05:1.1.1.1
	gdb-1999-12-21:1.1.1.1
	gdb-1999-12-13:1.1.1.1
	gdb-1999-12-07:1.1.1.1
	gdb-1999-12-06:1.1.1.1
	gdb-1999-11-16:1.1.1.1
	gdb-1999-11-08:1.1.1.1
	gdb-1999-11-01:1.1.1.1
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.14
date	2013.01.01.06.41.38;	author brobecke;	state Exp;
branches;
next	1.13;

1.13
date	2012.12.19.07.18.19;	author brobecke;	state Exp;
branches;
next	1.12;

1.12
date	2012.01.04.08.28.13;	author brobecke;	state Exp;
branches;
next	1.11;

1.11
date	2010.02.12.02.44.26;	author devans;	state Exp;
branches
	1.11.8.1;
next	1.10;

1.10
date	2010.01.02.19.09.20;	author devans;	state Exp;
branches;
next	1.9;

1.9
date	2009.11.04.05.07.00;	author devans;	state Exp;
branches;
next	1.8;

1.8
date	2007.08.24.14.28.37;	author brobecke;	state Exp;
branches;
next	1.7;

1.7
date	2003.12.11.11.33.44;	author nickc;	state Exp;
branches;
next	1.6;

1.6
date	2002.12.20.02.26.35;	author devans;	state Exp;
branches;
next	1.5;

1.5
date	2001.11.14.19.51.40;	author brolley;	state Exp;
branches
	1.5.16.1
	1.5.18.1;
next	1.4;

1.4
date	2001.03.05.16.05.38;	author brolley;	state Exp;
branches;
next	1.3;

1.3
date	2000.10.06.16.59.56;	author brolley;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.28.18.20.30;	author brolley;	state Exp;
branches;
next	1.1;

1.1
date	99.10.12.04.37.53;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.11.8.1
date	2012.01.06.04.54.52;	author brobecke;	state Exp;
branches;
next	;

1.5.16.1
date	2002.12.23.19.39.57;	author carlton;	state Exp;
branches;
next	1.5.16.2;

1.5.16.2
date	2003.12.16.00.01.26;	author carlton;	state Exp;
branches;
next	;

1.5.18.1
date	2003.12.14.20.28.25;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.10.12.04.37.53;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.14
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* Simulator instruction semantics for m32rxf.

THIS FILE IS MACHINE GENERATED WITH CGEN.

Copyright 1996-2013 Free Software Foundation, Inc.

This file is part of the GNU simulators.

   This file is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License along
   with this program; if not, see <http://www.gnu.org/licenses/>.

*/

#ifdef DEFINE_LABELS

  /* The labels have the case they have because the enum of insn types
     is all uppercase and in the non-stdc case the insn symbol is built
     into the enum name.  */

  static struct {
    int index;
    void *label;
  } labels[] = {
    { M32RXF_INSN_X_INVALID, && case_sem_INSN_X_INVALID },
    { M32RXF_INSN_X_AFTER, && case_sem_INSN_X_AFTER },
    { M32RXF_INSN_X_BEFORE, && case_sem_INSN_X_BEFORE },
    { M32RXF_INSN_X_CTI_CHAIN, && case_sem_INSN_X_CTI_CHAIN },
    { M32RXF_INSN_X_CHAIN, && case_sem_INSN_X_CHAIN },
    { M32RXF_INSN_X_BEGIN, && case_sem_INSN_X_BEGIN },
    { M32RXF_INSN_ADD, && case_sem_INSN_ADD },
    { M32RXF_INSN_ADD3, && case_sem_INSN_ADD3 },
    { M32RXF_INSN_AND, && case_sem_INSN_AND },
    { M32RXF_INSN_AND3, && case_sem_INSN_AND3 },
    { M32RXF_INSN_OR, && case_sem_INSN_OR },
    { M32RXF_INSN_OR3, && case_sem_INSN_OR3 },
    { M32RXF_INSN_XOR, && case_sem_INSN_XOR },
    { M32RXF_INSN_XOR3, && case_sem_INSN_XOR3 },
    { M32RXF_INSN_ADDI, && case_sem_INSN_ADDI },
    { M32RXF_INSN_ADDV, && case_sem_INSN_ADDV },
    { M32RXF_INSN_ADDV3, && case_sem_INSN_ADDV3 },
    { M32RXF_INSN_ADDX, && case_sem_INSN_ADDX },
    { M32RXF_INSN_BC8, && case_sem_INSN_BC8 },
    { M32RXF_INSN_BC24, && case_sem_INSN_BC24 },
    { M32RXF_INSN_BEQ, && case_sem_INSN_BEQ },
    { M32RXF_INSN_BEQZ, && case_sem_INSN_BEQZ },
    { M32RXF_INSN_BGEZ, && case_sem_INSN_BGEZ },
    { M32RXF_INSN_BGTZ, && case_sem_INSN_BGTZ },
    { M32RXF_INSN_BLEZ, && case_sem_INSN_BLEZ },
    { M32RXF_INSN_BLTZ, && case_sem_INSN_BLTZ },
    { M32RXF_INSN_BNEZ, && case_sem_INSN_BNEZ },
    { M32RXF_INSN_BL8, && case_sem_INSN_BL8 },
    { M32RXF_INSN_BL24, && case_sem_INSN_BL24 },
    { M32RXF_INSN_BCL8, && case_sem_INSN_BCL8 },
    { M32RXF_INSN_BCL24, && case_sem_INSN_BCL24 },
    { M32RXF_INSN_BNC8, && case_sem_INSN_BNC8 },
    { M32RXF_INSN_BNC24, && case_sem_INSN_BNC24 },
    { M32RXF_INSN_BNE, && case_sem_INSN_BNE },
    { M32RXF_INSN_BRA8, && case_sem_INSN_BRA8 },
    { M32RXF_INSN_BRA24, && case_sem_INSN_BRA24 },
    { M32RXF_INSN_BNCL8, && case_sem_INSN_BNCL8 },
    { M32RXF_INSN_BNCL24, && case_sem_INSN_BNCL24 },
    { M32RXF_INSN_CMP, && case_sem_INSN_CMP },
    { M32RXF_INSN_CMPI, && case_sem_INSN_CMPI },
    { M32RXF_INSN_CMPU, && case_sem_INSN_CMPU },
    { M32RXF_INSN_CMPUI, && case_sem_INSN_CMPUI },
    { M32RXF_INSN_CMPEQ, && case_sem_INSN_CMPEQ },
    { M32RXF_INSN_CMPZ, && case_sem_INSN_CMPZ },
    { M32RXF_INSN_DIV, && case_sem_INSN_DIV },
    { M32RXF_INSN_DIVU, && case_sem_INSN_DIVU },
    { M32RXF_INSN_REM, && case_sem_INSN_REM },
    { M32RXF_INSN_REMU, && case_sem_INSN_REMU },
    { M32RXF_INSN_DIVH, && case_sem_INSN_DIVH },
    { M32RXF_INSN_JC, && case_sem_INSN_JC },
    { M32RXF_INSN_JNC, && case_sem_INSN_JNC },
    { M32RXF_INSN_JL, && case_sem_INSN_JL },
    { M32RXF_INSN_JMP, && case_sem_INSN_JMP },
    { M32RXF_INSN_LD, && case_sem_INSN_LD },
    { M32RXF_INSN_LD_D, && case_sem_INSN_LD_D },
    { M32RXF_INSN_LDB, && case_sem_INSN_LDB },
    { M32RXF_INSN_LDB_D, && case_sem_INSN_LDB_D },
    { M32RXF_INSN_LDH, && case_sem_INSN_LDH },
    { M32RXF_INSN_LDH_D, && case_sem_INSN_LDH_D },
    { M32RXF_INSN_LDUB, && case_sem_INSN_LDUB },
    { M32RXF_INSN_LDUB_D, && case_sem_INSN_LDUB_D },
    { M32RXF_INSN_LDUH, && case_sem_INSN_LDUH },
    { M32RXF_INSN_LDUH_D, && case_sem_INSN_LDUH_D },
    { M32RXF_INSN_LD_PLUS, && case_sem_INSN_LD_PLUS },
    { M32RXF_INSN_LD24, && case_sem_INSN_LD24 },
    { M32RXF_INSN_LDI8, && case_sem_INSN_LDI8 },
    { M32RXF_INSN_LDI16, && case_sem_INSN_LDI16 },
    { M32RXF_INSN_LOCK, && case_sem_INSN_LOCK },
    { M32RXF_INSN_MACHI_A, && case_sem_INSN_MACHI_A },
    { M32RXF_INSN_MACLO_A, && case_sem_INSN_MACLO_A },
    { M32RXF_INSN_MACWHI_A, && case_sem_INSN_MACWHI_A },
    { M32RXF_INSN_MACWLO_A, && case_sem_INSN_MACWLO_A },
    { M32RXF_INSN_MUL, && case_sem_INSN_MUL },
    { M32RXF_INSN_MULHI_A, && case_sem_INSN_MULHI_A },
    { M32RXF_INSN_MULLO_A, && case_sem_INSN_MULLO_A },
    { M32RXF_INSN_MULWHI_A, && case_sem_INSN_MULWHI_A },
    { M32RXF_INSN_MULWLO_A, && case_sem_INSN_MULWLO_A },
    { M32RXF_INSN_MV, && case_sem_INSN_MV },
    { M32RXF_INSN_MVFACHI_A, && case_sem_INSN_MVFACHI_A },
    { M32RXF_INSN_MVFACLO_A, && case_sem_INSN_MVFACLO_A },
    { M32RXF_INSN_MVFACMI_A, && case_sem_INSN_MVFACMI_A },
    { M32RXF_INSN_MVFC, && case_sem_INSN_MVFC },
    { M32RXF_INSN_MVTACHI_A, && case_sem_INSN_MVTACHI_A },
    { M32RXF_INSN_MVTACLO_A, && case_sem_INSN_MVTACLO_A },
    { M32RXF_INSN_MVTC, && case_sem_INSN_MVTC },
    { M32RXF_INSN_NEG, && case_sem_INSN_NEG },
    { M32RXF_INSN_NOP, && case_sem_INSN_NOP },
    { M32RXF_INSN_NOT, && case_sem_INSN_NOT },
    { M32RXF_INSN_RAC_DSI, && case_sem_INSN_RAC_DSI },
    { M32RXF_INSN_RACH_DSI, && case_sem_INSN_RACH_DSI },
    { M32RXF_INSN_RTE, && case_sem_INSN_RTE },
    { M32RXF_INSN_SETH, && case_sem_INSN_SETH },
    { M32RXF_INSN_SLL, && case_sem_INSN_SLL },
    { M32RXF_INSN_SLL3, && case_sem_INSN_SLL3 },
    { M32RXF_INSN_SLLI, && case_sem_INSN_SLLI },
    { M32RXF_INSN_SRA, && case_sem_INSN_SRA },
    { M32RXF_INSN_SRA3, && case_sem_INSN_SRA3 },
    { M32RXF_INSN_SRAI, && case_sem_INSN_SRAI },
    { M32RXF_INSN_SRL, && case_sem_INSN_SRL },
    { M32RXF_INSN_SRL3, && case_sem_INSN_SRL3 },
    { M32RXF_INSN_SRLI, && case_sem_INSN_SRLI },
    { M32RXF_INSN_ST, && case_sem_INSN_ST },
    { M32RXF_INSN_ST_D, && case_sem_INSN_ST_D },
    { M32RXF_INSN_STB, && case_sem_INSN_STB },
    { M32RXF_INSN_STB_D, && case_sem_INSN_STB_D },
    { M32RXF_INSN_STH, && case_sem_INSN_STH },
    { M32RXF_INSN_STH_D, && case_sem_INSN_STH_D },
    { M32RXF_INSN_ST_PLUS, && case_sem_INSN_ST_PLUS },
    { M32RXF_INSN_STH_PLUS, && case_sem_INSN_STH_PLUS },
    { M32RXF_INSN_STB_PLUS, && case_sem_INSN_STB_PLUS },
    { M32RXF_INSN_ST_MINUS, && case_sem_INSN_ST_MINUS },
    { M32RXF_INSN_SUB, && case_sem_INSN_SUB },
    { M32RXF_INSN_SUBV, && case_sem_INSN_SUBV },
    { M32RXF_INSN_SUBX, && case_sem_INSN_SUBX },
    { M32RXF_INSN_TRAP, && case_sem_INSN_TRAP },
    { M32RXF_INSN_UNLOCK, && case_sem_INSN_UNLOCK },
    { M32RXF_INSN_SATB, && case_sem_INSN_SATB },
    { M32RXF_INSN_SATH, && case_sem_INSN_SATH },
    { M32RXF_INSN_SAT, && case_sem_INSN_SAT },
    { M32RXF_INSN_PCMPBZ, && case_sem_INSN_PCMPBZ },
    { M32RXF_INSN_SADD, && case_sem_INSN_SADD },
    { M32RXF_INSN_MACWU1, && case_sem_INSN_MACWU1 },
    { M32RXF_INSN_MSBLO, && case_sem_INSN_MSBLO },
    { M32RXF_INSN_MULWU1, && case_sem_INSN_MULWU1 },
    { M32RXF_INSN_MACLH1, && case_sem_INSN_MACLH1 },
    { M32RXF_INSN_SC, && case_sem_INSN_SC },
    { M32RXF_INSN_SNC, && case_sem_INSN_SNC },
    { M32RXF_INSN_CLRPSW, && case_sem_INSN_CLRPSW },
    { M32RXF_INSN_SETPSW, && case_sem_INSN_SETPSW },
    { M32RXF_INSN_BSET, && case_sem_INSN_BSET },
    { M32RXF_INSN_BCLR, && case_sem_INSN_BCLR },
    { M32RXF_INSN_BTST, && case_sem_INSN_BTST },
    { M32RXF_INSN_PAR_ADD, && case_sem_INSN_PAR_ADD },
    { M32RXF_INSN_WRITE_ADD, && case_sem_INSN_WRITE_ADD },
    { M32RXF_INSN_PAR_AND, && case_sem_INSN_PAR_AND },
    { M32RXF_INSN_WRITE_AND, && case_sem_INSN_WRITE_AND },
    { M32RXF_INSN_PAR_OR, && case_sem_INSN_PAR_OR },
    { M32RXF_INSN_WRITE_OR, && case_sem_INSN_WRITE_OR },
    { M32RXF_INSN_PAR_XOR, && case_sem_INSN_PAR_XOR },
    { M32RXF_INSN_WRITE_XOR, && case_sem_INSN_WRITE_XOR },
    { M32RXF_INSN_PAR_ADDI, && case_sem_INSN_PAR_ADDI },
    { M32RXF_INSN_WRITE_ADDI, && case_sem_INSN_WRITE_ADDI },
    { M32RXF_INSN_PAR_ADDV, && case_sem_INSN_PAR_ADDV },
    { M32RXF_INSN_WRITE_ADDV, && case_sem_INSN_WRITE_ADDV },
    { M32RXF_INSN_PAR_ADDX, && case_sem_INSN_PAR_ADDX },
    { M32RXF_INSN_WRITE_ADDX, && case_sem_INSN_WRITE_ADDX },
    { M32RXF_INSN_PAR_BC8, && case_sem_INSN_PAR_BC8 },
    { M32RXF_INSN_WRITE_BC8, && case_sem_INSN_WRITE_BC8 },
    { M32RXF_INSN_PAR_BL8, && case_sem_INSN_PAR_BL8 },
    { M32RXF_INSN_WRITE_BL8, && case_sem_INSN_WRITE_BL8 },
    { M32RXF_INSN_PAR_BCL8, && case_sem_INSN_PAR_BCL8 },
    { M32RXF_INSN_WRITE_BCL8, && case_sem_INSN_WRITE_BCL8 },
    { M32RXF_INSN_PAR_BNC8, && case_sem_INSN_PAR_BNC8 },
    { M32RXF_INSN_WRITE_BNC8, && case_sem_INSN_WRITE_BNC8 },
    { M32RXF_INSN_PAR_BRA8, && case_sem_INSN_PAR_BRA8 },
    { M32RXF_INSN_WRITE_BRA8, && case_sem_INSN_WRITE_BRA8 },
    { M32RXF_INSN_PAR_BNCL8, && case_sem_INSN_PAR_BNCL8 },
    { M32RXF_INSN_WRITE_BNCL8, && case_sem_INSN_WRITE_BNCL8 },
    { M32RXF_INSN_PAR_CMP, && case_sem_INSN_PAR_CMP },
    { M32RXF_INSN_WRITE_CMP, && case_sem_INSN_WRITE_CMP },
    { M32RXF_INSN_PAR_CMPU, && case_sem_INSN_PAR_CMPU },
    { M32RXF_INSN_WRITE_CMPU, && case_sem_INSN_WRITE_CMPU },
    { M32RXF_INSN_PAR_CMPEQ, && case_sem_INSN_PAR_CMPEQ },
    { M32RXF_INSN_WRITE_CMPEQ, && case_sem_INSN_WRITE_CMPEQ },
    { M32RXF_INSN_PAR_CMPZ, && case_sem_INSN_PAR_CMPZ },
    { M32RXF_INSN_WRITE_CMPZ, && case_sem_INSN_WRITE_CMPZ },
    { M32RXF_INSN_PAR_JC, && case_sem_INSN_PAR_JC },
    { M32RXF_INSN_WRITE_JC, && case_sem_INSN_WRITE_JC },
    { M32RXF_INSN_PAR_JNC, && case_sem_INSN_PAR_JNC },
    { M32RXF_INSN_WRITE_JNC, && case_sem_INSN_WRITE_JNC },
    { M32RXF_INSN_PAR_JL, && case_sem_INSN_PAR_JL },
    { M32RXF_INSN_WRITE_JL, && case_sem_INSN_WRITE_JL },
    { M32RXF_INSN_PAR_JMP, && case_sem_INSN_PAR_JMP },
    { M32RXF_INSN_WRITE_JMP, && case_sem_INSN_WRITE_JMP },
    { M32RXF_INSN_PAR_LD, && case_sem_INSN_PAR_LD },
    { M32RXF_INSN_WRITE_LD, && case_sem_INSN_WRITE_LD },
    { M32RXF_INSN_PAR_LDB, && case_sem_INSN_PAR_LDB },
    { M32RXF_INSN_WRITE_LDB, && case_sem_INSN_WRITE_LDB },
    { M32RXF_INSN_PAR_LDH, && case_sem_INSN_PAR_LDH },
    { M32RXF_INSN_WRITE_LDH, && case_sem_INSN_WRITE_LDH },
    { M32RXF_INSN_PAR_LDUB, && case_sem_INSN_PAR_LDUB },
    { M32RXF_INSN_WRITE_LDUB, && case_sem_INSN_WRITE_LDUB },
    { M32RXF_INSN_PAR_LDUH, && case_sem_INSN_PAR_LDUH },
    { M32RXF_INSN_WRITE_LDUH, && case_sem_INSN_WRITE_LDUH },
    { M32RXF_INSN_PAR_LD_PLUS, && case_sem_INSN_PAR_LD_PLUS },
    { M32RXF_INSN_WRITE_LD_PLUS, && case_sem_INSN_WRITE_LD_PLUS },
    { M32RXF_INSN_PAR_LDI8, && case_sem_INSN_PAR_LDI8 },
    { M32RXF_INSN_WRITE_LDI8, && case_sem_INSN_WRITE_LDI8 },
    { M32RXF_INSN_PAR_LOCK, && case_sem_INSN_PAR_LOCK },
    { M32RXF_INSN_WRITE_LOCK, && case_sem_INSN_WRITE_LOCK },
    { M32RXF_INSN_PAR_MACHI_A, && case_sem_INSN_PAR_MACHI_A },
    { M32RXF_INSN_WRITE_MACHI_A, && case_sem_INSN_WRITE_MACHI_A },
    { M32RXF_INSN_PAR_MACLO_A, && case_sem_INSN_PAR_MACLO_A },
    { M32RXF_INSN_WRITE_MACLO_A, && case_sem_INSN_WRITE_MACLO_A },
    { M32RXF_INSN_PAR_MACWHI_A, && case_sem_INSN_PAR_MACWHI_A },
    { M32RXF_INSN_WRITE_MACWHI_A, && case_sem_INSN_WRITE_MACWHI_A },
    { M32RXF_INSN_PAR_MACWLO_A, && case_sem_INSN_PAR_MACWLO_A },
    { M32RXF_INSN_WRITE_MACWLO_A, && case_sem_INSN_WRITE_MACWLO_A },
    { M32RXF_INSN_PAR_MUL, && case_sem_INSN_PAR_MUL },
    { M32RXF_INSN_WRITE_MUL, && case_sem_INSN_WRITE_MUL },
    { M32RXF_INSN_PAR_MULHI_A, && case_sem_INSN_PAR_MULHI_A },
    { M32RXF_INSN_WRITE_MULHI_A, && case_sem_INSN_WRITE_MULHI_A },
    { M32RXF_INSN_PAR_MULLO_A, && case_sem_INSN_PAR_MULLO_A },
    { M32RXF_INSN_WRITE_MULLO_A, && case_sem_INSN_WRITE_MULLO_A },
    { M32RXF_INSN_PAR_MULWHI_A, && case_sem_INSN_PAR_MULWHI_A },
    { M32RXF_INSN_WRITE_MULWHI_A, && case_sem_INSN_WRITE_MULWHI_A },
    { M32RXF_INSN_PAR_MULWLO_A, && case_sem_INSN_PAR_MULWLO_A },
    { M32RXF_INSN_WRITE_MULWLO_A, && case_sem_INSN_WRITE_MULWLO_A },
    { M32RXF_INSN_PAR_MV, && case_sem_INSN_PAR_MV },
    { M32RXF_INSN_WRITE_MV, && case_sem_INSN_WRITE_MV },
    { M32RXF_INSN_PAR_MVFACHI_A, && case_sem_INSN_PAR_MVFACHI_A },
    { M32RXF_INSN_WRITE_MVFACHI_A, && case_sem_INSN_WRITE_MVFACHI_A },
    { M32RXF_INSN_PAR_MVFACLO_A, && case_sem_INSN_PAR_MVFACLO_A },
    { M32RXF_INSN_WRITE_MVFACLO_A, && case_sem_INSN_WRITE_MVFACLO_A },
    { M32RXF_INSN_PAR_MVFACMI_A, && case_sem_INSN_PAR_MVFACMI_A },
    { M32RXF_INSN_WRITE_MVFACMI_A, && case_sem_INSN_WRITE_MVFACMI_A },
    { M32RXF_INSN_PAR_MVFC, && case_sem_INSN_PAR_MVFC },
    { M32RXF_INSN_WRITE_MVFC, && case_sem_INSN_WRITE_MVFC },
    { M32RXF_INSN_PAR_MVTACHI_A, && case_sem_INSN_PAR_MVTACHI_A },
    { M32RXF_INSN_WRITE_MVTACHI_A, && case_sem_INSN_WRITE_MVTACHI_A },
    { M32RXF_INSN_PAR_MVTACLO_A, && case_sem_INSN_PAR_MVTACLO_A },
    { M32RXF_INSN_WRITE_MVTACLO_A, && case_sem_INSN_WRITE_MVTACLO_A },
    { M32RXF_INSN_PAR_MVTC, && case_sem_INSN_PAR_MVTC },
    { M32RXF_INSN_WRITE_MVTC, && case_sem_INSN_WRITE_MVTC },
    { M32RXF_INSN_PAR_NEG, && case_sem_INSN_PAR_NEG },
    { M32RXF_INSN_WRITE_NEG, && case_sem_INSN_WRITE_NEG },
    { M32RXF_INSN_PAR_NOP, && case_sem_INSN_PAR_NOP },
    { M32RXF_INSN_WRITE_NOP, && case_sem_INSN_WRITE_NOP },
    { M32RXF_INSN_PAR_NOT, && case_sem_INSN_PAR_NOT },
    { M32RXF_INSN_WRITE_NOT, && case_sem_INSN_WRITE_NOT },
    { M32RXF_INSN_PAR_RAC_DSI, && case_sem_INSN_PAR_RAC_DSI },
    { M32RXF_INSN_WRITE_RAC_DSI, && case_sem_INSN_WRITE_RAC_DSI },
    { M32RXF_INSN_PAR_RACH_DSI, && case_sem_INSN_PAR_RACH_DSI },
    { M32RXF_INSN_WRITE_RACH_DSI, && case_sem_INSN_WRITE_RACH_DSI },
    { M32RXF_INSN_PAR_RTE, && case_sem_INSN_PAR_RTE },
    { M32RXF_INSN_WRITE_RTE, && case_sem_INSN_WRITE_RTE },
    { M32RXF_INSN_PAR_SLL, && case_sem_INSN_PAR_SLL },
    { M32RXF_INSN_WRITE_SLL, && case_sem_INSN_WRITE_SLL },
    { M32RXF_INSN_PAR_SLLI, && case_sem_INSN_PAR_SLLI },
    { M32RXF_INSN_WRITE_SLLI, && case_sem_INSN_WRITE_SLLI },
    { M32RXF_INSN_PAR_SRA, && case_sem_INSN_PAR_SRA },
    { M32RXF_INSN_WRITE_SRA, && case_sem_INSN_WRITE_SRA },
    { M32RXF_INSN_PAR_SRAI, && case_sem_INSN_PAR_SRAI },
    { M32RXF_INSN_WRITE_SRAI, && case_sem_INSN_WRITE_SRAI },
    { M32RXF_INSN_PAR_SRL, && case_sem_INSN_PAR_SRL },
    { M32RXF_INSN_WRITE_SRL, && case_sem_INSN_WRITE_SRL },
    { M32RXF_INSN_PAR_SRLI, && case_sem_INSN_PAR_SRLI },
    { M32RXF_INSN_WRITE_SRLI, && case_sem_INSN_WRITE_SRLI },
    { M32RXF_INSN_PAR_ST, && case_sem_INSN_PAR_ST },
    { M32RXF_INSN_WRITE_ST, && case_sem_INSN_WRITE_ST },
    { M32RXF_INSN_PAR_STB, && case_sem_INSN_PAR_STB },
    { M32RXF_INSN_WRITE_STB, && case_sem_INSN_WRITE_STB },
    { M32RXF_INSN_PAR_STH, && case_sem_INSN_PAR_STH },
    { M32RXF_INSN_WRITE_STH, && case_sem_INSN_WRITE_STH },
    { M32RXF_INSN_PAR_ST_PLUS, && case_sem_INSN_PAR_ST_PLUS },
    { M32RXF_INSN_WRITE_ST_PLUS, && case_sem_INSN_WRITE_ST_PLUS },
    { M32RXF_INSN_PAR_STH_PLUS, && case_sem_INSN_PAR_STH_PLUS },
    { M32RXF_INSN_WRITE_STH_PLUS, && case_sem_INSN_WRITE_STH_PLUS },
    { M32RXF_INSN_PAR_STB_PLUS, && case_sem_INSN_PAR_STB_PLUS },
    { M32RXF_INSN_WRITE_STB_PLUS, && case_sem_INSN_WRITE_STB_PLUS },
    { M32RXF_INSN_PAR_ST_MINUS, && case_sem_INSN_PAR_ST_MINUS },
    { M32RXF_INSN_WRITE_ST_MINUS, && case_sem_INSN_WRITE_ST_MINUS },
    { M32RXF_INSN_PAR_SUB, && case_sem_INSN_PAR_SUB },
    { M32RXF_INSN_WRITE_SUB, && case_sem_INSN_WRITE_SUB },
    { M32RXF_INSN_PAR_SUBV, && case_sem_INSN_PAR_SUBV },
    { M32RXF_INSN_WRITE_SUBV, && case_sem_INSN_WRITE_SUBV },
    { M32RXF_INSN_PAR_SUBX, && case_sem_INSN_PAR_SUBX },
    { M32RXF_INSN_WRITE_SUBX, && case_sem_INSN_WRITE_SUBX },
    { M32RXF_INSN_PAR_TRAP, && case_sem_INSN_PAR_TRAP },
    { M32RXF_INSN_WRITE_TRAP, && case_sem_INSN_WRITE_TRAP },
    { M32RXF_INSN_PAR_UNLOCK, && case_sem_INSN_PAR_UNLOCK },
    { M32RXF_INSN_WRITE_UNLOCK, && case_sem_INSN_WRITE_UNLOCK },
    { M32RXF_INSN_PAR_PCMPBZ, && case_sem_INSN_PAR_PCMPBZ },
    { M32RXF_INSN_WRITE_PCMPBZ, && case_sem_INSN_WRITE_PCMPBZ },
    { M32RXF_INSN_PAR_SADD, && case_sem_INSN_PAR_SADD },
    { M32RXF_INSN_WRITE_SADD, && case_sem_INSN_WRITE_SADD },
    { M32RXF_INSN_PAR_MACWU1, && case_sem_INSN_PAR_MACWU1 },
    { M32RXF_INSN_WRITE_MACWU1, && case_sem_INSN_WRITE_MACWU1 },
    { M32RXF_INSN_PAR_MSBLO, && case_sem_INSN_PAR_MSBLO },
    { M32RXF_INSN_WRITE_MSBLO, && case_sem_INSN_WRITE_MSBLO },
    { M32RXF_INSN_PAR_MULWU1, && case_sem_INSN_PAR_MULWU1 },
    { M32RXF_INSN_WRITE_MULWU1, && case_sem_INSN_WRITE_MULWU1 },
    { M32RXF_INSN_PAR_MACLH1, && case_sem_INSN_PAR_MACLH1 },
    { M32RXF_INSN_WRITE_MACLH1, && case_sem_INSN_WRITE_MACLH1 },
    { M32RXF_INSN_PAR_SC, && case_sem_INSN_PAR_SC },
    { M32RXF_INSN_WRITE_SC, && case_sem_INSN_WRITE_SC },
    { M32RXF_INSN_PAR_SNC, && case_sem_INSN_PAR_SNC },
    { M32RXF_INSN_WRITE_SNC, && case_sem_INSN_WRITE_SNC },
    { M32RXF_INSN_PAR_CLRPSW, && case_sem_INSN_PAR_CLRPSW },
    { M32RXF_INSN_WRITE_CLRPSW, && case_sem_INSN_WRITE_CLRPSW },
    { M32RXF_INSN_PAR_SETPSW, && case_sem_INSN_PAR_SETPSW },
    { M32RXF_INSN_WRITE_SETPSW, && case_sem_INSN_WRITE_SETPSW },
    { M32RXF_INSN_PAR_BTST, && case_sem_INSN_PAR_BTST },
    { M32RXF_INSN_WRITE_BTST, && case_sem_INSN_WRITE_BTST },
    { 0, 0 }
  };
  int i;

  for (i = 0; labels[i].label != 0; ++i)
    {
#if FAST_P
      CPU_IDESC (current_cpu) [labels[i].index].sem_fast_lab = labels[i].label;
#else
      CPU_IDESC (current_cpu) [labels[i].index].sem_full_lab = labels[i].label;
#endif
    }

#undef DEFINE_LABELS
#endif /* DEFINE_LABELS */

#ifdef DEFINE_SWITCH

/* If hyper-fast [well not unnecessarily slow] execution is selected, turn
   off frills like tracing and profiling.  */
/* FIXME: A better way would be to have TRACE_RESULT check for something
   that can cause it to be optimized out.  Another way would be to emit
   special handlers into the instruction "stream".  */

#if FAST_P
#undef TRACE_RESULT
#define TRACE_RESULT(cpu, abuf, name, type, val)
#endif

#undef GET_ATTR
#define GET_ATTR(cpu, num, attr) CGEN_ATTR_VALUE (NULL, abuf->idesc->attrs, CGEN_INSN_##attr)

{

#if WITH_SCACHE_PBB

/* Branch to next handler without going around main loop.  */
#define NEXT(vpc) goto * SEM_ARGBUF (vpc) -> semantic.sem_case
SWITCH (sem, SEM_ARGBUF (vpc) -> semantic.sem_case)

#else /* ! WITH_SCACHE_PBB */

#define NEXT(vpc) BREAK (sem)
#ifdef __GNUC__
#if FAST_P
  SWITCH (sem, SEM_ARGBUF (sc) -> idesc->sem_fast_lab)
#else
  SWITCH (sem, SEM_ARGBUF (sc) -> idesc->sem_full_lab)
#endif
#else
  SWITCH (sem, SEM_ARGBUF (sc) -> idesc->num)
#endif

#endif /* ! WITH_SCACHE_PBB */

    {

  CASE (sem, INSN_X_INVALID) : /* --invalid-- */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_empty.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  {
    /* Update the recorded pc in the cpu state struct.
       Only necessary for WITH_SCACHE case, but to avoid the
       conditional compilation ....  */
    SET_H_PC (pc);
    /* Virtual insns have zero size.  Overwrite vpc with address of next insn
       using the default-insn-bitsize spec.  When executing insns in parallel
       we may want to queue the fault and continue execution.  */
    vpc = SEM_NEXT_VPC (sem_arg, pc, 4);
    vpc = sim_engine_invalid_insn (current_cpu, pc, vpc);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_X_AFTER) : /* --after-- */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_empty.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  {
#if WITH_SCACHE_PBB_M32RXF
    m32rxf_pbb_after (current_cpu, sem_arg);
#endif
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_X_BEFORE) : /* --before-- */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_empty.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  {
#if WITH_SCACHE_PBB_M32RXF
    m32rxf_pbb_before (current_cpu, sem_arg);
#endif
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_X_CTI_CHAIN) : /* --cti-chain-- */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_empty.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  {
#if WITH_SCACHE_PBB_M32RXF
#ifdef DEFINE_SWITCH
    vpc = m32rxf_pbb_cti_chain (current_cpu, sem_arg,
			       pbb_br_type, pbb_br_npc);
    BREAK (sem);
#else
    /* FIXME: Allow provision of explicit ifmt spec in insn spec.  */
    vpc = m32rxf_pbb_cti_chain (current_cpu, sem_arg,
			       CPU_PBB_BR_TYPE (current_cpu),
			       CPU_PBB_BR_NPC (current_cpu));
#endif
#endif
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_X_CHAIN) : /* --chain-- */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_empty.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  {
#if WITH_SCACHE_PBB_M32RXF
    vpc = m32rxf_pbb_chain (current_cpu, sem_arg);
#ifdef DEFINE_SWITCH
    BREAK (sem);
#endif
#endif
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_X_BEGIN) : /* --begin-- */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_empty.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  {
#if WITH_SCACHE_PBB_M32RXF
#if defined DEFINE_SWITCH || defined FAST_P
    /* In the switch case FAST_P is a constant, allowing several optimizations
       in any called inline functions.  */
    vpc = m32rxf_pbb_begin (current_cpu, FAST_P);
#else
#if 0 /* cgen engine can't handle dynamic fast/full switching yet.  */
    vpc = m32rxf_pbb_begin (current_cpu, STATE_RUN_FAST_P (CPU_STATE (current_cpu)));
#else
    vpc = m32rxf_pbb_begin (current_cpu, 0);
#endif
#endif
#endif
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_ADD) : /* add $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ADDSI (* FLD (i_dr), * FLD (i_sr));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_ADD3) : /* add3 $dr,$sr,$hash$slo16 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add3.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = ADDSI (* FLD (i_sr), FLD (f_simm16));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_AND) : /* and $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ANDSI (* FLD (i_dr), * FLD (i_sr));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_AND3) : /* and3 $dr,$sr,$uimm16 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_and3.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = ANDSI (* FLD (i_sr), FLD (f_uimm16));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_OR) : /* or $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ORSI (* FLD (i_dr), * FLD (i_sr));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_OR3) : /* or3 $dr,$sr,$hash$ulo16 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_and3.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = ORSI (* FLD (i_sr), FLD (f_uimm16));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_XOR) : /* xor $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = XORSI (* FLD (i_dr), * FLD (i_sr));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_XOR3) : /* xor3 $dr,$sr,$uimm16 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_and3.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = XORSI (* FLD (i_sr), FLD (f_uimm16));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_ADDI) : /* addi $dr,$simm8 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_addi.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ADDSI (* FLD (i_dr), FLD (f_simm8));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_ADDV) : /* addv $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  SI temp0;BI temp1;
  temp0 = ADDSI (* FLD (i_dr), * FLD (i_sr));
  temp1 = ADDOFSI (* FLD (i_dr), * FLD (i_sr), 0);
  {
    SI opval = temp0;
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
  {
    BI opval = temp1;
    CPU (h_cond) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_ADDV3) : /* addv3 $dr,$sr,$simm16 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add3.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

{
  SI temp0;BI temp1;
  temp0 = ADDSI (* FLD (i_sr), FLD (f_simm16));
  temp1 = ADDOFSI (* FLD (i_sr), FLD (f_simm16), 0);
  {
    SI opval = temp0;
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
  {
    BI opval = temp1;
    CPU (h_cond) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_ADDX) : /* addx $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  SI temp0;BI temp1;
  temp0 = ADDCSI (* FLD (i_dr), * FLD (i_sr), CPU (h_cond));
  temp1 = ADDCFSI (* FLD (i_dr), * FLD (i_sr), CPU (h_cond));
  {
    SI opval = temp0;
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
  {
    BI opval = temp1;
    CPU (h_cond) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_BC8) : /* bc.s $disp8 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_bl8.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (CPU (h_cond)) {
  {
    USI opval = FLD (i_disp8);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_BC24) : /* bc.l $disp24 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_bl24.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (CPU (h_cond)) {
  {
    USI opval = FLD (i_disp24);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_BEQ) : /* beq $src1,$src2,$disp16 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_beq.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (EQSI (* FLD (i_src1), * FLD (i_src2))) {
  {
    USI opval = FLD (i_disp16);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_BEQZ) : /* beqz $src2,$disp16 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_beq.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (EQSI (* FLD (i_src2), 0)) {
  {
    USI opval = FLD (i_disp16);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_BGEZ) : /* bgez $src2,$disp16 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_beq.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (GESI (* FLD (i_src2), 0)) {
  {
    USI opval = FLD (i_disp16);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_BGTZ) : /* bgtz $src2,$disp16 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_beq.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (GTSI (* FLD (i_src2), 0)) {
  {
    USI opval = FLD (i_disp16);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_BLEZ) : /* blez $src2,$disp16 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_beq.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (LESI (* FLD (i_src2), 0)) {
  {
    USI opval = FLD (i_disp16);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_BLTZ) : /* bltz $src2,$disp16 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_beq.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (LTSI (* FLD (i_src2), 0)) {
  {
    USI opval = FLD (i_disp16);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_BNEZ) : /* bnez $src2,$disp16 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_beq.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (NESI (* FLD (i_src2), 0)) {
  {
    USI opval = FLD (i_disp16);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_BL8) : /* bl.s $disp8 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_bl8.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    SI opval = ADDSI (ANDSI (pc, -4), 4);
    CPU (h_gr[((UINT) 14)]) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
  {
    USI opval = FLD (i_disp8);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  SEM_BRANCH_FINI (vpc);
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_BL24) : /* bl.l $disp24 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_bl24.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

{
  {
    SI opval = ADDSI (pc, 4);
    CPU (h_gr[((UINT) 14)]) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
  {
    USI opval = FLD (i_disp24);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  SEM_BRANCH_FINI (vpc);
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_BCL8) : /* bcl.s $disp8 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_bl8.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (CPU (h_cond)) {
{
  {
    SI opval = ADDSI (ANDSI (pc, -4), 4);
    CPU (h_gr[((UINT) 14)]) = opval;
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
  {
    USI opval = FLD (i_disp8);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_BCL24) : /* bcl.l $disp24 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_bl24.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (CPU (h_cond)) {
{
  {
    SI opval = ADDSI (pc, 4);
    CPU (h_gr[((UINT) 14)]) = opval;
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
  {
    USI opval = FLD (i_disp24);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_BNC8) : /* bnc.s $disp8 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_bl8.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (NOTBI (CPU (h_cond))) {
  {
    USI opval = FLD (i_disp8);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_BNC24) : /* bnc.l $disp24 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_bl24.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (NOTBI (CPU (h_cond))) {
  {
    USI opval = FLD (i_disp24);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_BNE) : /* bne $src1,$src2,$disp16 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_beq.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (NESI (* FLD (i_src1), * FLD (i_src2))) {
  {
    USI opval = FLD (i_disp16);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_BRA8) : /* bra.s $disp8 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_bl8.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    USI opval = FLD (i_disp8);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }

  SEM_BRANCH_FINI (vpc);
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_BRA24) : /* bra.l $disp24 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_bl24.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    USI opval = FLD (i_disp24);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }

  SEM_BRANCH_FINI (vpc);
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_BNCL8) : /* bncl.s $disp8 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_bl8.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (NOTBI (CPU (h_cond))) {
{
  {
    SI opval = ADDSI (ANDSI (pc, -4), 4);
    CPU (h_gr[((UINT) 14)]) = opval;
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
  {
    USI opval = FLD (i_disp8);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_BNCL24) : /* bncl.l $disp24 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_bl24.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (NOTBI (CPU (h_cond))) {
{
  {
    SI opval = ADDSI (pc, 4);
    CPU (h_gr[((UINT) 14)]) = opval;
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
  {
    USI opval = FLD (i_disp24);
    SEM_BRANCH_VIA_CACHE (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_CMP) : /* cmp $src1,$src2 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = LTSI (* FLD (i_src1), * FLD (i_src2));
    CPU (h_cond) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_CMPI) : /* cmpi $src2,$simm16 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_d.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    BI opval = LTSI (* FLD (i_src2), FLD (f_simm16));
    CPU (h_cond) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_CMPU) : /* cmpu $src1,$src2 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = LTUSI (* FLD (i_src1), * FLD (i_src2));
    CPU (h_cond) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_CMPUI) : /* cmpui $src2,$simm16 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_d.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    BI opval = LTUSI (* FLD (i_src2), FLD (f_simm16));
    CPU (h_cond) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_CMPEQ) : /* cmpeq $src1,$src2 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = EQSI (* FLD (i_src1), * FLD (i_src2));
    CPU (h_cond) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_CMPZ) : /* cmpz $src2 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = EQSI (* FLD (i_src2), 0);
    CPU (h_cond) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_DIV) : /* div $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (NESI (* FLD (i_sr), 0)) {
  {
    SI opval = DIVSI (* FLD (i_dr), * FLD (i_sr));
    * FLD (i_dr) = opval;
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

  abuf->written = written;
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_DIVU) : /* divu $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (NESI (* FLD (i_sr), 0)) {
  {
    SI opval = UDIVSI (* FLD (i_dr), * FLD (i_sr));
    * FLD (i_dr) = opval;
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

  abuf->written = written;
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_REM) : /* rem $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (NESI (* FLD (i_sr), 0)) {
  {
    SI opval = MODSI (* FLD (i_dr), * FLD (i_sr));
    * FLD (i_dr) = opval;
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

  abuf->written = written;
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_REMU) : /* remu $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (NESI (* FLD (i_sr), 0)) {
  {
    SI opval = UMODSI (* FLD (i_dr), * FLD (i_sr));
    * FLD (i_dr) = opval;
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

  abuf->written = written;
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_DIVH) : /* divh $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

if (NESI (* FLD (i_sr), 0)) {
  {
    SI opval = DIVSI (EXTHISI (TRUNCSIHI (* FLD (i_dr))), * FLD (i_sr));
    * FLD (i_dr) = opval;
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

  abuf->written = written;
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_JC) : /* jc $sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_jl.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (CPU (h_cond)) {
  {
    USI opval = ANDSI (* FLD (i_sr), -4);
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_JNC) : /* jnc $sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_jl.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (NOTBI (CPU (h_cond))) {
  {
    USI opval = ANDSI (* FLD (i_sr), -4);
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  abuf->written = written;
  SEM_BRANCH_FINI (vpc);
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_JL) : /* jl $sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_jl.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  SI temp0;USI temp1;
  temp0 = ADDSI (ANDSI (pc, -4), 4);
  temp1 = ANDSI (* FLD (i_sr), -4);
  {
    SI opval = temp0;
    CPU (h_gr[((UINT) 14)]) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
  {
    USI opval = temp1;
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  SEM_BRANCH_FINI (vpc);
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_JMP) : /* jmp $sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_jl.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    USI opval = ANDSI (* FLD (i_sr), -4);
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }

  SEM_BRANCH_FINI (vpc);
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_LD) : /* ld $dr,@@$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_ld_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GETMEMSI (current_cpu, pc, * FLD (i_sr));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_LD_D) : /* ld $dr,@@($slo16,$sr) */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add3.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = GETMEMSI (current_cpu, pc, ADDSI (* FLD (i_sr), FLD (f_simm16)));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_LDB) : /* ldb $dr,@@$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_ld_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = EXTQISI (GETMEMQI (current_cpu, pc, * FLD (i_sr)));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_LDB_D) : /* ldb $dr,@@($slo16,$sr) */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add3.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = EXTQISI (GETMEMQI (current_cpu, pc, ADDSI (* FLD (i_sr), FLD (f_simm16))));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_LDH) : /* ldh $dr,@@$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_ld_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = EXTHISI (GETMEMHI (current_cpu, pc, * FLD (i_sr)));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_LDH_D) : /* ldh $dr,@@($slo16,$sr) */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add3.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = EXTHISI (GETMEMHI (current_cpu, pc, ADDSI (* FLD (i_sr), FLD (f_simm16))));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_LDUB) : /* ldub $dr,@@$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_ld_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ZEXTQISI (GETMEMQI (current_cpu, pc, * FLD (i_sr)));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_LDUB_D) : /* ldub $dr,@@($slo16,$sr) */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add3.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = ZEXTQISI (GETMEMQI (current_cpu, pc, ADDSI (* FLD (i_sr), FLD (f_simm16))));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_LDUH) : /* lduh $dr,@@$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_ld_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ZEXTHISI (GETMEMHI (current_cpu, pc, * FLD (i_sr)));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_LDUH_D) : /* lduh $dr,@@($slo16,$sr) */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add3.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = ZEXTHISI (GETMEMHI (current_cpu, pc, ADDSI (* FLD (i_sr), FLD (f_simm16))));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_LD_PLUS) : /* ld $dr,@@$sr+ */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_ld_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  SI temp0;SI temp1;
  temp0 = GETMEMSI (current_cpu, pc, * FLD (i_sr));
  temp1 = ADDSI (* FLD (i_sr), 4);
  {
    SI opval = temp0;
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
  {
    SI opval = temp1;
    * FLD (i_sr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_LD24) : /* ld24 $dr,$uimm24 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_ld24.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = FLD (i_uimm24);
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_LDI8) : /* ldi8 $dr,$simm8 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_addi.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = FLD (f_simm8);
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_LDI16) : /* ldi16 $dr,$hash$slo16 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add3.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = FLD (f_simm16);
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_LOCK) : /* lock $dr,@@$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_ld_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    BI opval = 1;
    CPU (h_lock) = opval;
    TRACE_RESULT (current_cpu, abuf, "lock", 'x', opval);
  }
  {
    SI opval = GETMEMSI (current_cpu, pc, * FLD (i_sr));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MACHI_A) : /* machi $src1,$src2,$acc */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_machi_a.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = SRADI (SLLDI (ADDDI (GET_H_ACCUMS (FLD (f_acc)), MULDI (EXTSIDI (ANDSI (* FLD (i_src1), 0xffff0000)), EXTHIDI (TRUNCSIHI (SRASI (* FLD (i_src2), 16))))), 8), 8);
    SET_H_ACCUMS (FLD (f_acc), opval);
    TRACE_RESULT (current_cpu, abuf, "accums", 'D', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MACLO_A) : /* maclo $src1,$src2,$acc */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_machi_a.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = SRADI (SLLDI (ADDDI (GET_H_ACCUMS (FLD (f_acc)), MULDI (EXTSIDI (SLLSI (* FLD (i_src1), 16)), EXTHIDI (TRUNCSIHI (* FLD (i_src2))))), 8), 8);
    SET_H_ACCUMS (FLD (f_acc), opval);
    TRACE_RESULT (current_cpu, abuf, "accums", 'D', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MACWHI_A) : /* macwhi $src1,$src2,$acc */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_machi_a.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = ADDDI (GET_H_ACCUMS (FLD (f_acc)), MULDI (EXTSIDI (* FLD (i_src1)), EXTHIDI (TRUNCSIHI (SRASI (* FLD (i_src2), 16)))));
    SET_H_ACCUMS (FLD (f_acc), opval);
    TRACE_RESULT (current_cpu, abuf, "accums", 'D', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MACWLO_A) : /* macwlo $src1,$src2,$acc */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_machi_a.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = ADDDI (GET_H_ACCUMS (FLD (f_acc)), MULDI (EXTSIDI (* FLD (i_src1)), EXTHIDI (TRUNCSIHI (* FLD (i_src2)))));
    SET_H_ACCUMS (FLD (f_acc), opval);
    TRACE_RESULT (current_cpu, abuf, "accums", 'D', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MUL) : /* mul $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = MULSI (* FLD (i_dr), * FLD (i_sr));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MULHI_A) : /* mulhi $src1,$src2,$acc */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_machi_a.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = SRADI (SLLDI (MULDI (EXTSIDI (ANDSI (* FLD (i_src1), 0xffff0000)), EXTHIDI (TRUNCSIHI (SRASI (* FLD (i_src2), 16)))), 16), 16);
    SET_H_ACCUMS (FLD (f_acc), opval);
    TRACE_RESULT (current_cpu, abuf, "accums", 'D', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MULLO_A) : /* mullo $src1,$src2,$acc */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_machi_a.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = SRADI (SLLDI (MULDI (EXTSIDI (SLLSI (* FLD (i_src1), 16)), EXTHIDI (TRUNCSIHI (* FLD (i_src2)))), 16), 16);
    SET_H_ACCUMS (FLD (f_acc), opval);
    TRACE_RESULT (current_cpu, abuf, "accums", 'D', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MULWHI_A) : /* mulwhi $src1,$src2,$acc */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_machi_a.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = MULDI (EXTSIDI (* FLD (i_src1)), EXTHIDI (TRUNCSIHI (SRASI (* FLD (i_src2), 16))));
    SET_H_ACCUMS (FLD (f_acc), opval);
    TRACE_RESULT (current_cpu, abuf, "accums", 'D', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MULWLO_A) : /* mulwlo $src1,$src2,$acc */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_machi_a.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = MULDI (EXTSIDI (* FLD (i_src1)), EXTHIDI (TRUNCSIHI (* FLD (i_src2))));
    SET_H_ACCUMS (FLD (f_acc), opval);
    TRACE_RESULT (current_cpu, abuf, "accums", 'D', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MV) : /* mv $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_ld_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = * FLD (i_sr);
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MVFACHI_A) : /* mvfachi $dr,$accs */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_mvfachi_a.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = TRUNCDISI (SRADI (GET_H_ACCUMS (FLD (f_accs)), 32));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MVFACLO_A) : /* mvfaclo $dr,$accs */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_mvfachi_a.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = TRUNCDISI (GET_H_ACCUMS (FLD (f_accs)));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MVFACMI_A) : /* mvfacmi $dr,$accs */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_mvfachi_a.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = TRUNCDISI (SRADI (GET_H_ACCUMS (FLD (f_accs)), 16));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MVFC) : /* mvfc $dr,$scr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_ld_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_CR (FLD (f_r2));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MVTACHI_A) : /* mvtachi $src1,$accs */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_mvtachi_a.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = ORDI (ANDDI (GET_H_ACCUMS (FLD (f_accs)), MAKEDI (0, 0xffffffff)), SLLDI (EXTSIDI (* FLD (i_src1)), 32));
    SET_H_ACCUMS (FLD (f_accs), opval);
    TRACE_RESULT (current_cpu, abuf, "accums", 'D', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MVTACLO_A) : /* mvtaclo $src1,$accs */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_mvtachi_a.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = ORDI (ANDDI (GET_H_ACCUMS (FLD (f_accs)), MAKEDI (0xffffffff, 0)), ZEXTSIDI (* FLD (i_src1)));
    SET_H_ACCUMS (FLD (f_accs), opval);
    TRACE_RESULT (current_cpu, abuf, "accums", 'D', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MVTC) : /* mvtc $sr,$dcr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_ld_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    USI opval = * FLD (i_sr);
    SET_H_CR (FLD (f_r1), opval);
    TRACE_RESULT (current_cpu, abuf, "cr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_NEG) : /* neg $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_ld_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = NEGSI (* FLD (i_sr));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_NOP) : /* nop */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_empty.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

PROFILE_COUNT_FILLNOPS (current_cpu, abuf->addr);

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_NOT) : /* not $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_ld_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = INVSI (* FLD (i_sr));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_RAC_DSI) : /* rac $accd,$accs,$imm1 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_rac_dsi.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_tmp1;
  tmp_tmp1 = SLLDI (GET_H_ACCUMS (FLD (f_accs)), FLD (f_imm1));
  tmp_tmp1 = ADDDI (tmp_tmp1, MAKEDI (0, 32768));
  {
    DI opval = (GTDI (tmp_tmp1, MAKEDI (32767, 0xffff0000))) ? (MAKEDI (32767, 0xffff0000)) : (LTDI (tmp_tmp1, MAKEDI (0xffff8000, 0))) ? (MAKEDI (0xffff8000, 0)) : (ANDDI (tmp_tmp1, MAKEDI (0xffffffff, 0xffff0000)));
    SET_H_ACCUMS (FLD (f_accd), opval);
    TRACE_RESULT (current_cpu, abuf, "accums", 'D', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_RACH_DSI) : /* rach $accd,$accs,$imm1 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_rac_dsi.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_tmp1;
  tmp_tmp1 = SLLDI (GET_H_ACCUMS (FLD (f_accs)), FLD (f_imm1));
  tmp_tmp1 = ADDDI (tmp_tmp1, MAKEDI (0, 0x80000000));
  {
    DI opval = (GTDI (tmp_tmp1, MAKEDI (32767, 0))) ? (MAKEDI (32767, 0)) : (LTDI (tmp_tmp1, MAKEDI (0xffff8000, 0))) ? (MAKEDI (0xffff8000, 0)) : (ANDDI (tmp_tmp1, MAKEDI (0xffffffff, 0)));
    SET_H_ACCUMS (FLD (f_accd), opval);
    TRACE_RESULT (current_cpu, abuf, "accums", 'D', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_RTE) : /* rte */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_empty.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    USI opval = ANDSI (GET_H_CR (((UINT) 6)), -4);
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
  {
    USI opval = GET_H_CR (((UINT) 14));
    SET_H_CR (((UINT) 6), opval);
    TRACE_RESULT (current_cpu, abuf, "cr", 'x', opval);
  }
  {
    UQI opval = CPU (h_bpsw);
    SET_H_PSW (opval);
    TRACE_RESULT (current_cpu, abuf, "psw", 'x', opval);
  }
  {
    UQI opval = CPU (h_bbpsw);
    CPU (h_bpsw) = opval;
    TRACE_RESULT (current_cpu, abuf, "bpsw", 'x', opval);
  }
}

  SEM_BRANCH_FINI (vpc);
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SETH) : /* seth $dr,$hash$hi16 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_seth.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = SLLSI (FLD (f_hi16), 16);
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SLL) : /* sll $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = SLLSI (* FLD (i_dr), ANDSI (* FLD (i_sr), 31));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SLL3) : /* sll3 $dr,$sr,$simm16 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add3.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = SLLSI (* FLD (i_sr), ANDSI (FLD (f_simm16), 31));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SLLI) : /* slli $dr,$uimm5 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_slli.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = SLLSI (* FLD (i_dr), FLD (f_uimm5));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SRA) : /* sra $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = SRASI (* FLD (i_dr), ANDSI (* FLD (i_sr), 31));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SRA3) : /* sra3 $dr,$sr,$simm16 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add3.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = SRASI (* FLD (i_sr), ANDSI (FLD (f_simm16), 31));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SRAI) : /* srai $dr,$uimm5 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_slli.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = SRASI (* FLD (i_dr), FLD (f_uimm5));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SRL) : /* srl $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = SRLSI (* FLD (i_dr), ANDSI (* FLD (i_sr), 31));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SRL3) : /* srl3 $dr,$sr,$simm16 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add3.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = SRLSI (* FLD (i_sr), ANDSI (FLD (f_simm16), 31));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SRLI) : /* srli $dr,$uimm5 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_slli.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = SRLSI (* FLD (i_dr), FLD (f_uimm5));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_ST) : /* st $src1,@@$src2 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = * FLD (i_src1);
    SETMEMSI (current_cpu, pc, * FLD (i_src2), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_ST_D) : /* st $src1,@@($slo16,$src2) */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_d.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = * FLD (i_src1);
    SETMEMSI (current_cpu, pc, ADDSI (* FLD (i_src2), FLD (f_simm16)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_STB) : /* stb $src1,@@$src2 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    QI opval = * FLD (i_src1);
    SETMEMQI (current_cpu, pc, * FLD (i_src2), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_STB_D) : /* stb $src1,@@($slo16,$src2) */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_d.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    QI opval = * FLD (i_src1);
    SETMEMQI (current_cpu, pc, ADDSI (* FLD (i_src2), FLD (f_simm16)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_STH) : /* sth $src1,@@$src2 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    HI opval = * FLD (i_src1);
    SETMEMHI (current_cpu, pc, * FLD (i_src2), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_STH_D) : /* sth $src1,@@($slo16,$src2) */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_d.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    HI opval = * FLD (i_src1);
    SETMEMHI (current_cpu, pc, ADDSI (* FLD (i_src2), FLD (f_simm16)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_ST_PLUS) : /* st $src1,@@+$src2 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  SI tmp_new_src2;
  tmp_new_src2 = ADDSI (* FLD (i_src2), 4);
  {
    SI opval = * FLD (i_src1);
    SETMEMSI (current_cpu, pc, tmp_new_src2, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
  {
    SI opval = tmp_new_src2;
    * FLD (i_src2) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_STH_PLUS) : /* sth $src1,@@$src2+ */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  SI tmp_new_src2;
  tmp_new_src2 = * FLD (i_src2);
  {
    HI opval = * FLD (i_src1);
    SETMEMHI (current_cpu, pc, tmp_new_src2, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
  {
    SI opval = ADDSI (tmp_new_src2, 2);
    * FLD (i_src2) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_STB_PLUS) : /* stb $src1,@@$src2+ */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  SI tmp_new_src2;
  tmp_new_src2 = * FLD (i_src2);
  {
    QI opval = * FLD (i_src1);
    SETMEMQI (current_cpu, pc, tmp_new_src2, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
  {
    SI opval = ADDSI (tmp_new_src2, 1);
    * FLD (i_src2) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_ST_MINUS) : /* st $src1,@@-$src2 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  SI tmp_new_src2;
  tmp_new_src2 = SUBSI (* FLD (i_src2), 4);
  {
    SI opval = * FLD (i_src1);
    SETMEMSI (current_cpu, pc, tmp_new_src2, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
  {
    SI opval = tmp_new_src2;
    * FLD (i_src2) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SUB) : /* sub $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = SUBSI (* FLD (i_dr), * FLD (i_sr));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SUBV) : /* subv $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  SI temp0;BI temp1;
  temp0 = SUBSI (* FLD (i_dr), * FLD (i_sr));
  temp1 = SUBOFSI (* FLD (i_dr), * FLD (i_sr), 0);
  {
    SI opval = temp0;
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
  {
    BI opval = temp1;
    CPU (h_cond) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SUBX) : /* subx $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  SI temp0;BI temp1;
  temp0 = SUBCSI (* FLD (i_dr), * FLD (i_sr), CPU (h_cond));
  temp1 = SUBCFSI (* FLD (i_dr), * FLD (i_sr), CPU (h_cond));
  {
    SI opval = temp0;
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
  {
    BI opval = temp1;
    CPU (h_cond) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_TRAP) : /* trap $uimm4 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_trap.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  SEM_BRANCH_INIT
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    USI opval = GET_H_CR (((UINT) 6));
    SET_H_CR (((UINT) 14), opval);
    TRACE_RESULT (current_cpu, abuf, "cr", 'x', opval);
  }
  {
    USI opval = ADDSI (pc, 4);
    SET_H_CR (((UINT) 6), opval);
    TRACE_RESULT (current_cpu, abuf, "cr", 'x', opval);
  }
  {
    UQI opval = CPU (h_bpsw);
    CPU (h_bbpsw) = opval;
    TRACE_RESULT (current_cpu, abuf, "bbpsw", 'x', opval);
  }
  {
    UQI opval = GET_H_PSW ();
    CPU (h_bpsw) = opval;
    TRACE_RESULT (current_cpu, abuf, "bpsw", 'x', opval);
  }
  {
    UQI opval = ANDQI (GET_H_PSW (), 128);
    SET_H_PSW (opval);
    TRACE_RESULT (current_cpu, abuf, "psw", 'x', opval);
  }
  {
    SI opval = m32r_trap (current_cpu, pc, FLD (f_uimm4));
    SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, opval, vpc);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  SEM_BRANCH_FINI (vpc);
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_UNLOCK) : /* unlock $src1,@@$src2 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
if (CPU (h_lock)) {
  {
    SI opval = * FLD (i_src1);
    SETMEMSI (current_cpu, pc, * FLD (i_src2), opval);
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
}
  {
    BI opval = 0;
    CPU (h_lock) = opval;
    TRACE_RESULT (current_cpu, abuf, "lock", 'x', opval);
  }
}

  abuf->written = written;
#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SATB) : /* satb $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_ld_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = (GESI (* FLD (i_sr), 127)) ? (127) : (LESI (* FLD (i_sr), -128)) ? (-128) : (* FLD (i_sr));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SATH) : /* sath $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_ld_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = (GESI (* FLD (i_sr), 32767)) ? (32767) : (LESI (* FLD (i_sr), -32768)) ? (-32768) : (* FLD (i_sr));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SAT) : /* sat $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_ld_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    SI opval = ((CPU (h_cond)) ? (((LTSI (* FLD (i_sr), 0)) ? (2147483647) : (0x80000000))) : (* FLD (i_sr)));
    * FLD (i_dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_PCMPBZ) : /* pcmpbz $src2 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = (EQSI (ANDSI (* FLD (i_src2), 255), 0)) ? (1) : (EQSI (ANDSI (* FLD (i_src2), 65280), 0)) ? (1) : (EQSI (ANDSI (* FLD (i_src2), 16711680), 0)) ? (1) : (EQSI (ANDSI (* FLD (i_src2), 0xff000000), 0)) ? (1) : (0);
    CPU (h_cond) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SADD) : /* sadd */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_empty.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = ADDDI (SRADI (GET_H_ACCUMS (((UINT) 1)), 16), GET_H_ACCUMS (((UINT) 0)));
    SET_H_ACCUMS (((UINT) 0), opval);
    TRACE_RESULT (current_cpu, abuf, "accums", 'D', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MACWU1) : /* macwu1 $src1,$src2 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = SRADI (SLLDI (ADDDI (GET_H_ACCUMS (((UINT) 1)), MULDI (EXTSIDI (* FLD (i_src1)), EXTSIDI (ANDSI (* FLD (i_src2), 65535)))), 8), 8);
    SET_H_ACCUMS (((UINT) 1), opval);
    TRACE_RESULT (current_cpu, abuf, "accums", 'D', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MSBLO) : /* msblo $src1,$src2 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = SRADI (SLLDI (SUBDI (GET_H_ACCUM (), SRADI (SLLDI (MULDI (EXTHIDI (TRUNCSIHI (* FLD (i_src1))), EXTHIDI (TRUNCSIHI (* FLD (i_src2)))), 32), 16)), 8), 8);
    SET_H_ACCUM (opval);
    TRACE_RESULT (current_cpu, abuf, "accum", 'D', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MULWU1) : /* mulwu1 $src1,$src2 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = SRADI (SLLDI (MULDI (EXTSIDI (* FLD (i_src1)), EXTSIDI (ANDSI (* FLD (i_src2), 65535))), 16), 16);
    SET_H_ACCUMS (((UINT) 1), opval);
    TRACE_RESULT (current_cpu, abuf, "accums", 'D', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_MACLH1) : /* maclh1 $src1,$src2 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = SRADI (SLLDI (ADDDI (GET_H_ACCUMS (((UINT) 1)), SLLDI (EXTSIDI (MULSI (EXTHISI (TRUNCSIHI (* FLD (i_src1))), SRASI (* FLD (i_src2), 16))), 16)), 8), 8);
    SET_H_ACCUMS (((UINT) 1), opval);
    TRACE_RESULT (current_cpu, abuf, "accums", 'D', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SC) : /* sc */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_empty.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (ZEXTBISI (CPU (h_cond)))
  SEM_SKIP_INSN (current_cpu, sem_arg, vpc);

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SNC) : /* snc */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_empty.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (ZEXTBISI (NOTBI (CPU (h_cond))))
  SEM_SKIP_INSN (current_cpu, sem_arg, vpc);

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_CLRPSW) : /* clrpsw $uimm8 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_clrpsw.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    USI opval = ANDSI (GET_H_CR (((UINT) 0)), ORSI (ZEXTQISI (INVQI (FLD (f_uimm8))), 65280));
    SET_H_CR (((UINT) 0), opval);
    TRACE_RESULT (current_cpu, abuf, "cr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SETPSW) : /* setpsw $uimm8 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_clrpsw.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    USI opval = FLD (f_uimm8);
    SET_H_CR (((UINT) 0), opval);
    TRACE_RESULT (current_cpu, abuf, "cr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_BSET) : /* bset $uimm3,@@($slo16,$sr) */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_bset.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    QI opval = ORQI (GETMEMQI (current_cpu, pc, ADDSI (* FLD (i_sr), FLD (f_simm16))), SLLQI (1, SUBSI (7, FLD (f_uimm3))));
    SETMEMQI (current_cpu, pc, ADDSI (* FLD (i_sr), FLD (f_simm16)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_BCLR) : /* bclr $uimm3,@@($slo16,$sr) */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_bset.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    QI opval = ANDQI (GETMEMQI (current_cpu, pc, ADDSI (* FLD (i_sr), FLD (f_simm16))), INVQI (SLLQI (1, SUBSI (7, FLD (f_uimm3)))));
    SETMEMQI (current_cpu, pc, ADDSI (* FLD (i_sr), FLD (f_simm16)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_BTST) : /* btst $uimm3,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_bset.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = ANDQI (SRLQI (* FLD (i_sr), SUBSI (7, FLD (f_uimm3))), 1);
    CPU (h_cond) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_PAR_ADD) : /* add $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add.f
#define OPRND(f) par_exec->operands.sfmt_add.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ADDSI (* FLD (i_dr), * FLD (i_sr));
    OPRND (dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_ADD) : /* add $dr,$sr */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_add.f
#define OPRND(f) par_exec->operands.sfmt_add.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  * FLD (i_dr) = OPRND (dr);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_AND) : /* and $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add.f
#define OPRND(f) par_exec->operands.sfmt_add.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ANDSI (* FLD (i_dr), * FLD (i_sr));
    OPRND (dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_AND) : /* and $dr,$sr */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_add.f
#define OPRND(f) par_exec->operands.sfmt_add.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  * FLD (i_dr) = OPRND (dr);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_OR) : /* or $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add.f
#define OPRND(f) par_exec->operands.sfmt_add.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ORSI (* FLD (i_dr), * FLD (i_sr));
    OPRND (dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_OR) : /* or $dr,$sr */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_add.f
#define OPRND(f) par_exec->operands.sfmt_add.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  * FLD (i_dr) = OPRND (dr);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_XOR) : /* xor $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add.f
#define OPRND(f) par_exec->operands.sfmt_add.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = XORSI (* FLD (i_dr), * FLD (i_sr));
    OPRND (dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_XOR) : /* xor $dr,$sr */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_add.f
#define OPRND(f) par_exec->operands.sfmt_add.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  * FLD (i_dr) = OPRND (dr);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_ADDI) : /* addi $dr,$simm8 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_addi.f
#define OPRND(f) par_exec->operands.sfmt_addi.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ADDSI (* FLD (i_dr), FLD (f_simm8));
    OPRND (dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_ADDI) : /* addi $dr,$simm8 */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_addi.f
#define OPRND(f) par_exec->operands.sfmt_addi.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  * FLD (i_dr) = OPRND (dr);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_ADDV) : /* addv $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add.f
#define OPRND(f) par_exec->operands.sfmt_addv.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  SI temp0;BI temp1;
  temp0 = ADDSI (* FLD (i_dr), * FLD (i_sr));
  temp1 = ADDOFSI (* FLD (i_dr), * FLD (i_sr), 0);
  {
    SI opval = temp0;
    OPRND (dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
  {
    BI opval = temp1;
    OPRND (condbit) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }
}

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_ADDV) : /* addv $dr,$sr */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_add.f
#define OPRND(f) par_exec->operands.sfmt_addv.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  CPU (h_cond) = OPRND (condbit);
  * FLD (i_dr) = OPRND (dr);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_ADDX) : /* addx $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add.f
#define OPRND(f) par_exec->operands.sfmt_addx.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  SI temp0;BI temp1;
  temp0 = ADDCSI (* FLD (i_dr), * FLD (i_sr), CPU (h_cond));
  temp1 = ADDCFSI (* FLD (i_dr), * FLD (i_sr), CPU (h_cond));
  {
    SI opval = temp0;
    OPRND (dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
  {
    BI opval = temp1;
    OPRND (condbit) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }
}

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_ADDX) : /* addx $dr,$sr */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_add.f
#define OPRND(f) par_exec->operands.sfmt_addx.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  CPU (h_cond) = OPRND (condbit);
  * FLD (i_dr) = OPRND (dr);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_BC8) : /* bc.s $disp8 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_bl8.f
#define OPRND(f) par_exec->operands.sfmt_bc8.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (CPU (h_cond)) {
  {
    USI opval = FLD (i_disp8);
    OPRND (pc) = opval;
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  abuf->written = written;
#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_BC8) : /* bc.s $disp8 */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_bl8.f
#define OPRND(f) par_exec->operands.sfmt_bc8.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    SEM_BRANCH_INIT
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  if (written & (1 << 2))
    {
      SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, OPRND (pc), vpc);
    }

  SEM_BRANCH_FINI (vpc);
#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_BL8) : /* bl.s $disp8 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_bl8.f
#define OPRND(f) par_exec->operands.sfmt_bl8.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    SI opval = ADDSI (ANDSI (pc, -4), 4);
    OPRND (h_gr_SI_14) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
  {
    USI opval = FLD (i_disp8);
    OPRND (pc) = opval;
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_BL8) : /* bl.s $disp8 */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_bl8.f
#define OPRND(f) par_exec->operands.sfmt_bl8.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    SEM_BRANCH_INIT
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  CPU (h_gr[((UINT) 14)]) = OPRND (h_gr_SI_14);
  SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, OPRND (pc), vpc);

  SEM_BRANCH_FINI (vpc);
#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_BCL8) : /* bcl.s $disp8 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_bl8.f
#define OPRND(f) par_exec->operands.sfmt_bcl8.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (CPU (h_cond)) {
{
  {
    SI opval = ADDSI (ANDSI (pc, -4), 4);
    OPRND (h_gr_SI_14) = opval;
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
  {
    USI opval = FLD (i_disp8);
    OPRND (pc) = opval;
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}
}

  abuf->written = written;
#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_BCL8) : /* bcl.s $disp8 */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_bl8.f
#define OPRND(f) par_exec->operands.sfmt_bcl8.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    SEM_BRANCH_INIT
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  if (written & (1 << 3))
    {
      CPU (h_gr[((UINT) 14)]) = OPRND (h_gr_SI_14);
    }
  if (written & (1 << 4))
    {
      SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, OPRND (pc), vpc);
    }

  SEM_BRANCH_FINI (vpc);
#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_BNC8) : /* bnc.s $disp8 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_bl8.f
#define OPRND(f) par_exec->operands.sfmt_bc8.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (NOTBI (CPU (h_cond))) {
  {
    USI opval = FLD (i_disp8);
    OPRND (pc) = opval;
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  abuf->written = written;
#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_BNC8) : /* bnc.s $disp8 */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_bl8.f
#define OPRND(f) par_exec->operands.sfmt_bc8.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    SEM_BRANCH_INIT
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  if (written & (1 << 2))
    {
      SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, OPRND (pc), vpc);
    }

  SEM_BRANCH_FINI (vpc);
#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_BRA8) : /* bra.s $disp8 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_bl8.f
#define OPRND(f) par_exec->operands.sfmt_bra8.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    USI opval = FLD (i_disp8);
    OPRND (pc) = opval;
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_BRA8) : /* bra.s $disp8 */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_bl8.f
#define OPRND(f) par_exec->operands.sfmt_bra8.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    SEM_BRANCH_INIT
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, OPRND (pc), vpc);

  SEM_BRANCH_FINI (vpc);
#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_BNCL8) : /* bncl.s $disp8 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_bl8.f
#define OPRND(f) par_exec->operands.sfmt_bcl8.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (NOTBI (CPU (h_cond))) {
{
  {
    SI opval = ADDSI (ANDSI (pc, -4), 4);
    OPRND (h_gr_SI_14) = opval;
    written |= (1 << 3);
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
  {
    USI opval = FLD (i_disp8);
    OPRND (pc) = opval;
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}
}

  abuf->written = written;
#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_BNCL8) : /* bncl.s $disp8 */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_bl8.f
#define OPRND(f) par_exec->operands.sfmt_bcl8.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    SEM_BRANCH_INIT
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  if (written & (1 << 3))
    {
      CPU (h_gr[((UINT) 14)]) = OPRND (h_gr_SI_14);
    }
  if (written & (1 << 4))
    {
      SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, OPRND (pc), vpc);
    }

  SEM_BRANCH_FINI (vpc);
#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_CMP) : /* cmp $src1,$src2 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_cmp.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = LTSI (* FLD (i_src1), * FLD (i_src2));
    OPRND (condbit) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_CMP) : /* cmp $src1,$src2 */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_cmp.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  CPU (h_cond) = OPRND (condbit);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_CMPU) : /* cmpu $src1,$src2 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_cmp.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = LTUSI (* FLD (i_src1), * FLD (i_src2));
    OPRND (condbit) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_CMPU) : /* cmpu $src1,$src2 */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_cmp.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  CPU (h_cond) = OPRND (condbit);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_CMPEQ) : /* cmpeq $src1,$src2 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_cmp.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = EQSI (* FLD (i_src1), * FLD (i_src2));
    OPRND (condbit) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_CMPEQ) : /* cmpeq $src1,$src2 */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_cmp.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  CPU (h_cond) = OPRND (condbit);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_CMPZ) : /* cmpz $src2 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_cmpz.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = EQSI (* FLD (i_src2), 0);
    OPRND (condbit) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_CMPZ) : /* cmpz $src2 */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_cmpz.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  CPU (h_cond) = OPRND (condbit);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_JC) : /* jc $sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_jl.f
#define OPRND(f) par_exec->operands.sfmt_jc.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (CPU (h_cond)) {
  {
    USI opval = ANDSI (* FLD (i_sr), -4);
    OPRND (pc) = opval;
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  abuf->written = written;
#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_JC) : /* jc $sr */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_jl.f
#define OPRND(f) par_exec->operands.sfmt_jc.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    SEM_BRANCH_INIT
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  if (written & (1 << 2))
    {
      SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, OPRND (pc), vpc);
    }

  SEM_BRANCH_FINI (vpc);
#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_JNC) : /* jnc $sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_jl.f
#define OPRND(f) par_exec->operands.sfmt_jc.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (NOTBI (CPU (h_cond))) {
  {
    USI opval = ANDSI (* FLD (i_sr), -4);
    OPRND (pc) = opval;
    written |= (1 << 2);
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

  abuf->written = written;
#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_JNC) : /* jnc $sr */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_jl.f
#define OPRND(f) par_exec->operands.sfmt_jc.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    SEM_BRANCH_INIT
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  if (written & (1 << 2))
    {
      SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, OPRND (pc), vpc);
    }

  SEM_BRANCH_FINI (vpc);
#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_JL) : /* jl $sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_jl.f
#define OPRND(f) par_exec->operands.sfmt_jl.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  SI temp0;USI temp1;
  temp0 = ADDSI (ANDSI (pc, -4), 4);
  temp1 = ANDSI (* FLD (i_sr), -4);
  {
    SI opval = temp0;
    OPRND (h_gr_SI_14) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
  {
    USI opval = temp1;
    OPRND (pc) = opval;
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_JL) : /* jl $sr */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_jl.f
#define OPRND(f) par_exec->operands.sfmt_jl.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    SEM_BRANCH_INIT
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  CPU (h_gr[((UINT) 14)]) = OPRND (h_gr_SI_14);
  SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, OPRND (pc), vpc);

  SEM_BRANCH_FINI (vpc);
#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_JMP) : /* jmp $sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_jl.f
#define OPRND(f) par_exec->operands.sfmt_jmp.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    USI opval = ANDSI (* FLD (i_sr), -4);
    OPRND (pc) = opval;
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_JMP) : /* jmp $sr */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_jl.f
#define OPRND(f) par_exec->operands.sfmt_jmp.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    SEM_BRANCH_INIT
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, OPRND (pc), vpc);

  SEM_BRANCH_FINI (vpc);
#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_LD) : /* ld $dr,@@$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_ld_plus.f
#define OPRND(f) par_exec->operands.sfmt_ld.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GETMEMSI (current_cpu, pc, * FLD (i_sr));
    OPRND (dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_LD) : /* ld $dr,@@$sr */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_ld_plus.f
#define OPRND(f) par_exec->operands.sfmt_ld.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  * FLD (i_dr) = OPRND (dr);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_LDB) : /* ldb $dr,@@$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_ld_plus.f
#define OPRND(f) par_exec->operands.sfmt_ldb.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = EXTQISI (GETMEMQI (current_cpu, pc, * FLD (i_sr)));
    OPRND (dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_LDB) : /* ldb $dr,@@$sr */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_ld_plus.f
#define OPRND(f) par_exec->operands.sfmt_ldb.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  * FLD (i_dr) = OPRND (dr);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_LDH) : /* ldh $dr,@@$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_ld_plus.f
#define OPRND(f) par_exec->operands.sfmt_ldh.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = EXTHISI (GETMEMHI (current_cpu, pc, * FLD (i_sr)));
    OPRND (dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_LDH) : /* ldh $dr,@@$sr */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_ld_plus.f
#define OPRND(f) par_exec->operands.sfmt_ldh.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  * FLD (i_dr) = OPRND (dr);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_LDUB) : /* ldub $dr,@@$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_ld_plus.f
#define OPRND(f) par_exec->operands.sfmt_ldb.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ZEXTQISI (GETMEMQI (current_cpu, pc, * FLD (i_sr)));
    OPRND (dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_LDUB) : /* ldub $dr,@@$sr */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_ld_plus.f
#define OPRND(f) par_exec->operands.sfmt_ldb.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  * FLD (i_dr) = OPRND (dr);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_LDUH) : /* lduh $dr,@@$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_ld_plus.f
#define OPRND(f) par_exec->operands.sfmt_ldh.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ZEXTHISI (GETMEMHI (current_cpu, pc, * FLD (i_sr)));
    OPRND (dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_LDUH) : /* lduh $dr,@@$sr */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_ld_plus.f
#define OPRND(f) par_exec->operands.sfmt_ldh.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  * FLD (i_dr) = OPRND (dr);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_LD_PLUS) : /* ld $dr,@@$sr+ */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_ld_plus.f
#define OPRND(f) par_exec->operands.sfmt_ld_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  SI temp0;SI temp1;
  temp0 = GETMEMSI (current_cpu, pc, * FLD (i_sr));
  temp1 = ADDSI (* FLD (i_sr), 4);
  {
    SI opval = temp0;
    OPRND (dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
  {
    SI opval = temp1;
    OPRND (sr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_LD_PLUS) : /* ld $dr,@@$sr+ */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_ld_plus.f
#define OPRND(f) par_exec->operands.sfmt_ld_plus.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  * FLD (i_dr) = OPRND (dr);
  * FLD (i_sr) = OPRND (sr);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_LDI8) : /* ldi8 $dr,$simm8 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_addi.f
#define OPRND(f) par_exec->operands.sfmt_ldi8.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = FLD (f_simm8);
    OPRND (dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_LDI8) : /* ldi8 $dr,$simm8 */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_addi.f
#define OPRND(f) par_exec->operands.sfmt_ldi8.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  * FLD (i_dr) = OPRND (dr);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_LOCK) : /* lock $dr,@@$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_ld_plus.f
#define OPRND(f) par_exec->operands.sfmt_lock.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    BI opval = 1;
    OPRND (h_lock_BI) = opval;
    TRACE_RESULT (current_cpu, abuf, "lock", 'x', opval);
  }
  {
    SI opval = GETMEMSI (current_cpu, pc, * FLD (i_sr));
    OPRND (dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_LOCK) : /* lock $dr,@@$sr */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_ld_plus.f
#define OPRND(f) par_exec->operands.sfmt_lock.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  * FLD (i_dr) = OPRND (dr);
  CPU (h_lock) = OPRND (h_lock_BI);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_MACHI_A) : /* machi $src1,$src2,$acc */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_machi_a.f
#define OPRND(f) par_exec->operands.sfmt_machi_a.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = SRADI (SLLDI (ADDDI (GET_H_ACCUMS (FLD (f_acc)), MULDI (EXTSIDI (ANDSI (* FLD (i_src1), 0xffff0000)), EXTHIDI (TRUNCSIHI (SRASI (* FLD (i_src2), 16))))), 8), 8);
    OPRND (acc) = opval;
    TRACE_RESULT (current_cpu, abuf, "accums", 'D', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_MACHI_A) : /* machi $src1,$src2,$acc */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_machi_a.f
#define OPRND(f) par_exec->operands.sfmt_machi_a.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  SET_H_ACCUMS (FLD (f_acc), OPRND (acc));

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_MACLO_A) : /* maclo $src1,$src2,$acc */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_machi_a.f
#define OPRND(f) par_exec->operands.sfmt_machi_a.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = SRADI (SLLDI (ADDDI (GET_H_ACCUMS (FLD (f_acc)), MULDI (EXTSIDI (SLLSI (* FLD (i_src1), 16)), EXTHIDI (TRUNCSIHI (* FLD (i_src2))))), 8), 8);
    OPRND (acc) = opval;
    TRACE_RESULT (current_cpu, abuf, "accums", 'D', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_MACLO_A) : /* maclo $src1,$src2,$acc */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_machi_a.f
#define OPRND(f) par_exec->operands.sfmt_machi_a.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  SET_H_ACCUMS (FLD (f_acc), OPRND (acc));

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_MACWHI_A) : /* macwhi $src1,$src2,$acc */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_machi_a.f
#define OPRND(f) par_exec->operands.sfmt_machi_a.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = ADDDI (GET_H_ACCUMS (FLD (f_acc)), MULDI (EXTSIDI (* FLD (i_src1)), EXTHIDI (TRUNCSIHI (SRASI (* FLD (i_src2), 16)))));
    OPRND (acc) = opval;
    TRACE_RESULT (current_cpu, abuf, "accums", 'D', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_MACWHI_A) : /* macwhi $src1,$src2,$acc */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_machi_a.f
#define OPRND(f) par_exec->operands.sfmt_machi_a.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  SET_H_ACCUMS (FLD (f_acc), OPRND (acc));

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_MACWLO_A) : /* macwlo $src1,$src2,$acc */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_machi_a.f
#define OPRND(f) par_exec->operands.sfmt_machi_a.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = ADDDI (GET_H_ACCUMS (FLD (f_acc)), MULDI (EXTSIDI (* FLD (i_src1)), EXTHIDI (TRUNCSIHI (* FLD (i_src2)))));
    OPRND (acc) = opval;
    TRACE_RESULT (current_cpu, abuf, "accums", 'D', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_MACWLO_A) : /* macwlo $src1,$src2,$acc */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_machi_a.f
#define OPRND(f) par_exec->operands.sfmt_machi_a.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  SET_H_ACCUMS (FLD (f_acc), OPRND (acc));

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_MUL) : /* mul $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add.f
#define OPRND(f) par_exec->operands.sfmt_add.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = MULSI (* FLD (i_dr), * FLD (i_sr));
    OPRND (dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_MUL) : /* mul $dr,$sr */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_add.f
#define OPRND(f) par_exec->operands.sfmt_add.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  * FLD (i_dr) = OPRND (dr);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_MULHI_A) : /* mulhi $src1,$src2,$acc */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_machi_a.f
#define OPRND(f) par_exec->operands.sfmt_mulhi_a.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = SRADI (SLLDI (MULDI (EXTSIDI (ANDSI (* FLD (i_src1), 0xffff0000)), EXTHIDI (TRUNCSIHI (SRASI (* FLD (i_src2), 16)))), 16), 16);
    OPRND (acc) = opval;
    TRACE_RESULT (current_cpu, abuf, "accums", 'D', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_MULHI_A) : /* mulhi $src1,$src2,$acc */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_machi_a.f
#define OPRND(f) par_exec->operands.sfmt_mulhi_a.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  SET_H_ACCUMS (FLD (f_acc), OPRND (acc));

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_MULLO_A) : /* mullo $src1,$src2,$acc */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_machi_a.f
#define OPRND(f) par_exec->operands.sfmt_mulhi_a.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = SRADI (SLLDI (MULDI (EXTSIDI (SLLSI (* FLD (i_src1), 16)), EXTHIDI (TRUNCSIHI (* FLD (i_src2)))), 16), 16);
    OPRND (acc) = opval;
    TRACE_RESULT (current_cpu, abuf, "accums", 'D', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_MULLO_A) : /* mullo $src1,$src2,$acc */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_machi_a.f
#define OPRND(f) par_exec->operands.sfmt_mulhi_a.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  SET_H_ACCUMS (FLD (f_acc), OPRND (acc));

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_MULWHI_A) : /* mulwhi $src1,$src2,$acc */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_machi_a.f
#define OPRND(f) par_exec->operands.sfmt_mulhi_a.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = MULDI (EXTSIDI (* FLD (i_src1)), EXTHIDI (TRUNCSIHI (SRASI (* FLD (i_src2), 16))));
    OPRND (acc) = opval;
    TRACE_RESULT (current_cpu, abuf, "accums", 'D', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_MULWHI_A) : /* mulwhi $src1,$src2,$acc */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_machi_a.f
#define OPRND(f) par_exec->operands.sfmt_mulhi_a.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  SET_H_ACCUMS (FLD (f_acc), OPRND (acc));

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_MULWLO_A) : /* mulwlo $src1,$src2,$acc */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_machi_a.f
#define OPRND(f) par_exec->operands.sfmt_mulhi_a.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = MULDI (EXTSIDI (* FLD (i_src1)), EXTHIDI (TRUNCSIHI (* FLD (i_src2))));
    OPRND (acc) = opval;
    TRACE_RESULT (current_cpu, abuf, "accums", 'D', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_MULWLO_A) : /* mulwlo $src1,$src2,$acc */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_machi_a.f
#define OPRND(f) par_exec->operands.sfmt_mulhi_a.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  SET_H_ACCUMS (FLD (f_acc), OPRND (acc));

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_MV) : /* mv $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_ld_plus.f
#define OPRND(f) par_exec->operands.sfmt_mv.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = * FLD (i_sr);
    OPRND (dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_MV) : /* mv $dr,$sr */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_ld_plus.f
#define OPRND(f) par_exec->operands.sfmt_mv.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  * FLD (i_dr) = OPRND (dr);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_MVFACHI_A) : /* mvfachi $dr,$accs */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_mvfachi_a.f
#define OPRND(f) par_exec->operands.sfmt_mvfachi_a.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = TRUNCDISI (SRADI (GET_H_ACCUMS (FLD (f_accs)), 32));
    OPRND (dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_MVFACHI_A) : /* mvfachi $dr,$accs */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_mvfachi_a.f
#define OPRND(f) par_exec->operands.sfmt_mvfachi_a.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  * FLD (i_dr) = OPRND (dr);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_MVFACLO_A) : /* mvfaclo $dr,$accs */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_mvfachi_a.f
#define OPRND(f) par_exec->operands.sfmt_mvfachi_a.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = TRUNCDISI (GET_H_ACCUMS (FLD (f_accs)));
    OPRND (dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_MVFACLO_A) : /* mvfaclo $dr,$accs */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_mvfachi_a.f
#define OPRND(f) par_exec->operands.sfmt_mvfachi_a.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  * FLD (i_dr) = OPRND (dr);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_MVFACMI_A) : /* mvfacmi $dr,$accs */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_mvfachi_a.f
#define OPRND(f) par_exec->operands.sfmt_mvfachi_a.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = TRUNCDISI (SRADI (GET_H_ACCUMS (FLD (f_accs)), 16));
    OPRND (dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_MVFACMI_A) : /* mvfacmi $dr,$accs */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_mvfachi_a.f
#define OPRND(f) par_exec->operands.sfmt_mvfachi_a.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  * FLD (i_dr) = OPRND (dr);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_MVFC) : /* mvfc $dr,$scr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_ld_plus.f
#define OPRND(f) par_exec->operands.sfmt_mvfc.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = GET_H_CR (FLD (f_r2));
    OPRND (dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_MVFC) : /* mvfc $dr,$scr */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_ld_plus.f
#define OPRND(f) par_exec->operands.sfmt_mvfc.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  * FLD (i_dr) = OPRND (dr);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_MVTACHI_A) : /* mvtachi $src1,$accs */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_mvtachi_a.f
#define OPRND(f) par_exec->operands.sfmt_mvtachi_a.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = ORDI (ANDDI (GET_H_ACCUMS (FLD (f_accs)), MAKEDI (0, 0xffffffff)), SLLDI (EXTSIDI (* FLD (i_src1)), 32));
    OPRND (accs) = opval;
    TRACE_RESULT (current_cpu, abuf, "accums", 'D', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_MVTACHI_A) : /* mvtachi $src1,$accs */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_mvtachi_a.f
#define OPRND(f) par_exec->operands.sfmt_mvtachi_a.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  SET_H_ACCUMS (FLD (f_accs), OPRND (accs));

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_MVTACLO_A) : /* mvtaclo $src1,$accs */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_mvtachi_a.f
#define OPRND(f) par_exec->operands.sfmt_mvtachi_a.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = ORDI (ANDDI (GET_H_ACCUMS (FLD (f_accs)), MAKEDI (0xffffffff, 0)), ZEXTSIDI (* FLD (i_src1)));
    OPRND (accs) = opval;
    TRACE_RESULT (current_cpu, abuf, "accums", 'D', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_MVTACLO_A) : /* mvtaclo $src1,$accs */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_mvtachi_a.f
#define OPRND(f) par_exec->operands.sfmt_mvtachi_a.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  SET_H_ACCUMS (FLD (f_accs), OPRND (accs));

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_MVTC) : /* mvtc $sr,$dcr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_ld_plus.f
#define OPRND(f) par_exec->operands.sfmt_mvtc.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    USI opval = * FLD (i_sr);
    OPRND (dcr) = opval;
    TRACE_RESULT (current_cpu, abuf, "cr", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_MVTC) : /* mvtc $sr,$dcr */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_ld_plus.f
#define OPRND(f) par_exec->operands.sfmt_mvtc.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  SET_H_CR (FLD (f_r1), OPRND (dcr));

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_NEG) : /* neg $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_ld_plus.f
#define OPRND(f) par_exec->operands.sfmt_mv.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = NEGSI (* FLD (i_sr));
    OPRND (dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_NEG) : /* neg $dr,$sr */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_ld_plus.f
#define OPRND(f) par_exec->operands.sfmt_mv.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  * FLD (i_dr) = OPRND (dr);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_NOP) : /* nop */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_empty.f
#define OPRND(f) par_exec->operands.sfmt_nop.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

PROFILE_COUNT_FILLNOPS (current_cpu, abuf->addr);

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_NOP) : /* nop */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_empty.f
#define OPRND(f) par_exec->operands.sfmt_nop.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);


#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_NOT) : /* not $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_ld_plus.f
#define OPRND(f) par_exec->operands.sfmt_mv.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = INVSI (* FLD (i_sr));
    OPRND (dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_NOT) : /* not $dr,$sr */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_ld_plus.f
#define OPRND(f) par_exec->operands.sfmt_mv.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  * FLD (i_dr) = OPRND (dr);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_RAC_DSI) : /* rac $accd,$accs,$imm1 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_rac_dsi.f
#define OPRND(f) par_exec->operands.sfmt_rac_dsi.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_tmp1;
  tmp_tmp1 = SLLDI (GET_H_ACCUMS (FLD (f_accs)), FLD (f_imm1));
  tmp_tmp1 = ADDDI (tmp_tmp1, MAKEDI (0, 32768));
  {
    DI opval = (GTDI (tmp_tmp1, MAKEDI (32767, 0xffff0000))) ? (MAKEDI (32767, 0xffff0000)) : (LTDI (tmp_tmp1, MAKEDI (0xffff8000, 0))) ? (MAKEDI (0xffff8000, 0)) : (ANDDI (tmp_tmp1, MAKEDI (0xffffffff, 0xffff0000)));
    OPRND (accd) = opval;
    TRACE_RESULT (current_cpu, abuf, "accums", 'D', opval);
  }
}

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_RAC_DSI) : /* rac $accd,$accs,$imm1 */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_rac_dsi.f
#define OPRND(f) par_exec->operands.sfmt_rac_dsi.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  SET_H_ACCUMS (FLD (f_accd), OPRND (accd));

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_RACH_DSI) : /* rach $accd,$accs,$imm1 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_rac_dsi.f
#define OPRND(f) par_exec->operands.sfmt_rac_dsi.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  DI tmp_tmp1;
  tmp_tmp1 = SLLDI (GET_H_ACCUMS (FLD (f_accs)), FLD (f_imm1));
  tmp_tmp1 = ADDDI (tmp_tmp1, MAKEDI (0, 0x80000000));
  {
    DI opval = (GTDI (tmp_tmp1, MAKEDI (32767, 0))) ? (MAKEDI (32767, 0)) : (LTDI (tmp_tmp1, MAKEDI (0xffff8000, 0))) ? (MAKEDI (0xffff8000, 0)) : (ANDDI (tmp_tmp1, MAKEDI (0xffffffff, 0)));
    OPRND (accd) = opval;
    TRACE_RESULT (current_cpu, abuf, "accums", 'D', opval);
  }
}

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_RACH_DSI) : /* rach $accd,$accs,$imm1 */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_rac_dsi.f
#define OPRND(f) par_exec->operands.sfmt_rac_dsi.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  SET_H_ACCUMS (FLD (f_accd), OPRND (accd));

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_RTE) : /* rte */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_empty.f
#define OPRND(f) par_exec->operands.sfmt_rte.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    USI opval = ANDSI (GET_H_CR (((UINT) 6)), -4);
    OPRND (pc) = opval;
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
  {
    USI opval = GET_H_CR (((UINT) 14));
    OPRND (h_cr_USI_6) = opval;
    TRACE_RESULT (current_cpu, abuf, "cr", 'x', opval);
  }
  {
    UQI opval = CPU (h_bpsw);
    OPRND (h_psw_UQI) = opval;
    TRACE_RESULT (current_cpu, abuf, "psw", 'x', opval);
  }
  {
    UQI opval = CPU (h_bbpsw);
    OPRND (h_bpsw_UQI) = opval;
    TRACE_RESULT (current_cpu, abuf, "bpsw", 'x', opval);
  }
}

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_RTE) : /* rte */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_empty.f
#define OPRND(f) par_exec->operands.sfmt_rte.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    SEM_BRANCH_INIT
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  CPU (h_bpsw) = OPRND (h_bpsw_UQI);
  SET_H_CR (((UINT) 6), OPRND (h_cr_USI_6));
  SET_H_PSW (OPRND (h_psw_UQI));
  SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, OPRND (pc), vpc);

  SEM_BRANCH_FINI (vpc);
#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_SLL) : /* sll $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add.f
#define OPRND(f) par_exec->operands.sfmt_add.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = SLLSI (* FLD (i_dr), ANDSI (* FLD (i_sr), 31));
    OPRND (dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_SLL) : /* sll $dr,$sr */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_add.f
#define OPRND(f) par_exec->operands.sfmt_add.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  * FLD (i_dr) = OPRND (dr);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_SLLI) : /* slli $dr,$uimm5 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_slli.f
#define OPRND(f) par_exec->operands.sfmt_slli.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = SLLSI (* FLD (i_dr), FLD (f_uimm5));
    OPRND (dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_SLLI) : /* slli $dr,$uimm5 */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_slli.f
#define OPRND(f) par_exec->operands.sfmt_slli.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  * FLD (i_dr) = OPRND (dr);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_SRA) : /* sra $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add.f
#define OPRND(f) par_exec->operands.sfmt_add.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = SRASI (* FLD (i_dr), ANDSI (* FLD (i_sr), 31));
    OPRND (dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_SRA) : /* sra $dr,$sr */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_add.f
#define OPRND(f) par_exec->operands.sfmt_add.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  * FLD (i_dr) = OPRND (dr);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_SRAI) : /* srai $dr,$uimm5 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_slli.f
#define OPRND(f) par_exec->operands.sfmt_slli.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = SRASI (* FLD (i_dr), FLD (f_uimm5));
    OPRND (dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_SRAI) : /* srai $dr,$uimm5 */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_slli.f
#define OPRND(f) par_exec->operands.sfmt_slli.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  * FLD (i_dr) = OPRND (dr);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_SRL) : /* srl $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add.f
#define OPRND(f) par_exec->operands.sfmt_add.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = SRLSI (* FLD (i_dr), ANDSI (* FLD (i_sr), 31));
    OPRND (dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_SRL) : /* srl $dr,$sr */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_add.f
#define OPRND(f) par_exec->operands.sfmt_add.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  * FLD (i_dr) = OPRND (dr);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_SRLI) : /* srli $dr,$uimm5 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_slli.f
#define OPRND(f) par_exec->operands.sfmt_slli.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = SRLSI (* FLD (i_dr), FLD (f_uimm5));
    OPRND (dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_SRLI) : /* srli $dr,$uimm5 */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_slli.f
#define OPRND(f) par_exec->operands.sfmt_slli.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  * FLD (i_dr) = OPRND (dr);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_ST) : /* st $src1,@@$src2 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_st.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = * FLD (i_src1);
    OPRND (h_memory_SI_src2_idx) = * FLD (i_src2);
    OPRND (h_memory_SI_src2) = opval;
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_ST) : /* st $src1,@@$src2 */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_st.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  SETMEMSI (current_cpu, pc, OPRND (h_memory_SI_src2_idx), OPRND (h_memory_SI_src2));

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_STB) : /* stb $src1,@@$src2 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_stb.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    QI opval = * FLD (i_src1);
    OPRND (h_memory_QI_src2_idx) = * FLD (i_src2);
    OPRND (h_memory_QI_src2) = opval;
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_STB) : /* stb $src1,@@$src2 */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_stb.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  SETMEMQI (current_cpu, pc, OPRND (h_memory_QI_src2_idx), OPRND (h_memory_QI_src2));

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_STH) : /* sth $src1,@@$src2 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_sth.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    HI opval = * FLD (i_src1);
    OPRND (h_memory_HI_src2_idx) = * FLD (i_src2);
    OPRND (h_memory_HI_src2) = opval;
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_STH) : /* sth $src1,@@$src2 */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_sth.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  SETMEMHI (current_cpu, pc, OPRND (h_memory_HI_src2_idx), OPRND (h_memory_HI_src2));

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_ST_PLUS) : /* st $src1,@@+$src2 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_st_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  SI tmp_new_src2;
  tmp_new_src2 = ADDSI (* FLD (i_src2), 4);
  {
    SI opval = * FLD (i_src1);
    OPRND (h_memory_SI_new_src2_idx) = tmp_new_src2;
    OPRND (h_memory_SI_new_src2) = opval;
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
  {
    SI opval = tmp_new_src2;
    OPRND (src2) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_ST_PLUS) : /* st $src1,@@+$src2 */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_st_plus.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  SETMEMSI (current_cpu, pc, OPRND (h_memory_SI_new_src2_idx), OPRND (h_memory_SI_new_src2));
  * FLD (i_src2) = OPRND (src2);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_STH_PLUS) : /* sth $src1,@@$src2+ */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_sth_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  SI tmp_new_src2;
  tmp_new_src2 = * FLD (i_src2);
  {
    HI opval = * FLD (i_src1);
    OPRND (h_memory_HI_new_src2_idx) = tmp_new_src2;
    OPRND (h_memory_HI_new_src2) = opval;
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
  {
    SI opval = ADDSI (tmp_new_src2, 2);
    OPRND (src2) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_STH_PLUS) : /* sth $src1,@@$src2+ */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_sth_plus.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  SETMEMHI (current_cpu, pc, OPRND (h_memory_HI_new_src2_idx), OPRND (h_memory_HI_new_src2));
  * FLD (i_src2) = OPRND (src2);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_STB_PLUS) : /* stb $src1,@@$src2+ */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_stb_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  SI tmp_new_src2;
  tmp_new_src2 = * FLD (i_src2);
  {
    QI opval = * FLD (i_src1);
    OPRND (h_memory_QI_new_src2_idx) = tmp_new_src2;
    OPRND (h_memory_QI_new_src2) = opval;
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
  {
    SI opval = ADDSI (tmp_new_src2, 1);
    OPRND (src2) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_STB_PLUS) : /* stb $src1,@@$src2+ */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_stb_plus.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  SETMEMQI (current_cpu, pc, OPRND (h_memory_QI_new_src2_idx), OPRND (h_memory_QI_new_src2));
  * FLD (i_src2) = OPRND (src2);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_ST_MINUS) : /* st $src1,@@-$src2 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_st_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  SI tmp_new_src2;
  tmp_new_src2 = SUBSI (* FLD (i_src2), 4);
  {
    SI opval = * FLD (i_src1);
    OPRND (h_memory_SI_new_src2_idx) = tmp_new_src2;
    OPRND (h_memory_SI_new_src2) = opval;
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
  {
    SI opval = tmp_new_src2;
    OPRND (src2) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_ST_MINUS) : /* st $src1,@@-$src2 */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_st_plus.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  SETMEMSI (current_cpu, pc, OPRND (h_memory_SI_new_src2_idx), OPRND (h_memory_SI_new_src2));
  * FLD (i_src2) = OPRND (src2);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_SUB) : /* sub $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add.f
#define OPRND(f) par_exec->operands.sfmt_add.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = SUBSI (* FLD (i_dr), * FLD (i_sr));
    OPRND (dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_SUB) : /* sub $dr,$sr */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_add.f
#define OPRND(f) par_exec->operands.sfmt_add.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  * FLD (i_dr) = OPRND (dr);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_SUBV) : /* subv $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add.f
#define OPRND(f) par_exec->operands.sfmt_addv.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  SI temp0;BI temp1;
  temp0 = SUBSI (* FLD (i_dr), * FLD (i_sr));
  temp1 = SUBOFSI (* FLD (i_dr), * FLD (i_sr), 0);
  {
    SI opval = temp0;
    OPRND (dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
  {
    BI opval = temp1;
    OPRND (condbit) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }
}

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_SUBV) : /* subv $dr,$sr */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_add.f
#define OPRND(f) par_exec->operands.sfmt_addv.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  CPU (h_cond) = OPRND (condbit);
  * FLD (i_dr) = OPRND (dr);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_SUBX) : /* subx $dr,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_add.f
#define OPRND(f) par_exec->operands.sfmt_addx.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  SI temp0;BI temp1;
  temp0 = SUBCSI (* FLD (i_dr), * FLD (i_sr), CPU (h_cond));
  temp1 = SUBCFSI (* FLD (i_dr), * FLD (i_sr), CPU (h_cond));
  {
    SI opval = temp0;
    OPRND (dr) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
  {
    BI opval = temp1;
    OPRND (condbit) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }
}

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_SUBX) : /* subx $dr,$sr */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_add.f
#define OPRND(f) par_exec->operands.sfmt_addx.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  CPU (h_cond) = OPRND (condbit);
  * FLD (i_dr) = OPRND (dr);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_TRAP) : /* trap $uimm4 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_trap.f
#define OPRND(f) par_exec->operands.sfmt_trap.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  {
    USI opval = GET_H_CR (((UINT) 6));
    OPRND (h_cr_USI_14) = opval;
    TRACE_RESULT (current_cpu, abuf, "cr", 'x', opval);
  }
  {
    USI opval = ADDSI (pc, 4);
    OPRND (h_cr_USI_6) = opval;
    TRACE_RESULT (current_cpu, abuf, "cr", 'x', opval);
  }
  {
    UQI opval = CPU (h_bpsw);
    OPRND (h_bbpsw_UQI) = opval;
    TRACE_RESULT (current_cpu, abuf, "bbpsw", 'x', opval);
  }
  {
    UQI opval = GET_H_PSW ();
    OPRND (h_bpsw_UQI) = opval;
    TRACE_RESULT (current_cpu, abuf, "bpsw", 'x', opval);
  }
  {
    UQI opval = ANDQI (GET_H_PSW (), 128);
    OPRND (h_psw_UQI) = opval;
    TRACE_RESULT (current_cpu, abuf, "psw", 'x', opval);
  }
  {
    SI opval = m32r_trap (current_cpu, pc, FLD (f_uimm4));
    OPRND (pc) = opval;
    TRACE_RESULT (current_cpu, abuf, "pc", 'x', opval);
  }
}

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_TRAP) : /* trap $uimm4 */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_trap.f
#define OPRND(f) par_exec->operands.sfmt_trap.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    SEM_BRANCH_INIT
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  CPU (h_bbpsw) = OPRND (h_bbpsw_UQI);
  CPU (h_bpsw) = OPRND (h_bpsw_UQI);
  SET_H_CR (((UINT) 14), OPRND (h_cr_USI_14));
  SET_H_CR (((UINT) 6), OPRND (h_cr_USI_6));
  SET_H_PSW (OPRND (h_psw_UQI));
  SEM_BRANCH_VIA_ADDR (current_cpu, sem_arg, OPRND (pc), vpc);

  SEM_BRANCH_FINI (vpc);
#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_UNLOCK) : /* unlock $src1,@@$src2 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_unlock.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
if (CPU (h_lock)) {
  {
    SI opval = * FLD (i_src1);
    OPRND (h_memory_SI_src2_idx) = * FLD (i_src2);
    OPRND (h_memory_SI_src2) = opval;
    written |= (1 << 4);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
}
  {
    BI opval = 0;
    OPRND (h_lock_BI) = opval;
    TRACE_RESULT (current_cpu, abuf, "lock", 'x', opval);
  }
}

  abuf->written = written;
#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_UNLOCK) : /* unlock $src1,@@$src2 */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_unlock.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  CPU (h_lock) = OPRND (h_lock_BI);
  if (written & (1 << 4))
    {
      SETMEMSI (current_cpu, pc, OPRND (h_memory_SI_src2_idx), OPRND (h_memory_SI_src2));
    }

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_PCMPBZ) : /* pcmpbz $src2 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_cmpz.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = (EQSI (ANDSI (* FLD (i_src2), 255), 0)) ? (1) : (EQSI (ANDSI (* FLD (i_src2), 65280), 0)) ? (1) : (EQSI (ANDSI (* FLD (i_src2), 16711680), 0)) ? (1) : (EQSI (ANDSI (* FLD (i_src2), 0xff000000), 0)) ? (1) : (0);
    OPRND (condbit) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_PCMPBZ) : /* pcmpbz $src2 */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_cmpz.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  CPU (h_cond) = OPRND (condbit);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_SADD) : /* sadd */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_empty.f
#define OPRND(f) par_exec->operands.sfmt_sadd.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = ADDDI (SRADI (GET_H_ACCUMS (((UINT) 1)), 16), GET_H_ACCUMS (((UINT) 0)));
    OPRND (h_accums_DI_0) = opval;
    TRACE_RESULT (current_cpu, abuf, "accums", 'D', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_SADD) : /* sadd */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_empty.f
#define OPRND(f) par_exec->operands.sfmt_sadd.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  SET_H_ACCUMS (((UINT) 0), OPRND (h_accums_DI_0));

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_MACWU1) : /* macwu1 $src1,$src2 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_macwu1.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = SRADI (SLLDI (ADDDI (GET_H_ACCUMS (((UINT) 1)), MULDI (EXTSIDI (* FLD (i_src1)), EXTSIDI (ANDSI (* FLD (i_src2), 65535)))), 8), 8);
    OPRND (h_accums_DI_1) = opval;
    TRACE_RESULT (current_cpu, abuf, "accums", 'D', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_MACWU1) : /* macwu1 $src1,$src2 */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_macwu1.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  SET_H_ACCUMS (((UINT) 1), OPRND (h_accums_DI_1));

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_MSBLO) : /* msblo $src1,$src2 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_msblo.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = SRADI (SLLDI (SUBDI (GET_H_ACCUM (), SRADI (SLLDI (MULDI (EXTHIDI (TRUNCSIHI (* FLD (i_src1))), EXTHIDI (TRUNCSIHI (* FLD (i_src2)))), 32), 16)), 8), 8);
    OPRND (accum) = opval;
    TRACE_RESULT (current_cpu, abuf, "accum", 'D', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_MSBLO) : /* msblo $src1,$src2 */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_msblo.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  SET_H_ACCUM (OPRND (accum));

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_MULWU1) : /* mulwu1 $src1,$src2 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_mulwu1.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = SRADI (SLLDI (MULDI (EXTSIDI (* FLD (i_src1)), EXTSIDI (ANDSI (* FLD (i_src2), 65535))), 16), 16);
    OPRND (h_accums_DI_1) = opval;
    TRACE_RESULT (current_cpu, abuf, "accums", 'D', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_MULWU1) : /* mulwu1 $src1,$src2 */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_mulwu1.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  SET_H_ACCUMS (((UINT) 1), OPRND (h_accums_DI_1));

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_MACLH1) : /* maclh1 $src1,$src2 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_macwu1.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    DI opval = SRADI (SLLDI (ADDDI (GET_H_ACCUMS (((UINT) 1)), SLLDI (EXTSIDI (MULSI (EXTHISI (TRUNCSIHI (* FLD (i_src1))), SRASI (* FLD (i_src2), 16))), 16)), 8), 8);
    OPRND (h_accums_DI_1) = opval;
    TRACE_RESULT (current_cpu, abuf, "accums", 'D', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_MACLH1) : /* maclh1 $src1,$src2 */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_macwu1.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  SET_H_ACCUMS (((UINT) 1), OPRND (h_accums_DI_1));

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_SC) : /* sc */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_empty.f
#define OPRND(f) par_exec->operands.sfmt_sc.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (ZEXTBISI (CPU (h_cond)))
  SEM_SKIP_INSN (current_cpu, sem_arg, vpc);

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_SC) : /* sc */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_empty.f
#define OPRND(f) par_exec->operands.sfmt_sc.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);


#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_SNC) : /* snc */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_empty.f
#define OPRND(f) par_exec->operands.sfmt_sc.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

if (ZEXTBISI (NOTBI (CPU (h_cond))))
  SEM_SKIP_INSN (current_cpu, sem_arg, vpc);

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_SNC) : /* snc */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_empty.f
#define OPRND(f) par_exec->operands.sfmt_sc.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);


#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_CLRPSW) : /* clrpsw $uimm8 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_clrpsw.f
#define OPRND(f) par_exec->operands.sfmt_clrpsw.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    USI opval = ANDSI (GET_H_CR (((UINT) 0)), ORSI (ZEXTQISI (INVQI (FLD (f_uimm8))), 65280));
    OPRND (h_cr_USI_0) = opval;
    TRACE_RESULT (current_cpu, abuf, "cr", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_CLRPSW) : /* clrpsw $uimm8 */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_clrpsw.f
#define OPRND(f) par_exec->operands.sfmt_clrpsw.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  SET_H_CR (((UINT) 0), OPRND (h_cr_USI_0));

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_SETPSW) : /* setpsw $uimm8 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_clrpsw.f
#define OPRND(f) par_exec->operands.sfmt_setpsw.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    USI opval = FLD (f_uimm8);
    OPRND (h_cr_USI_0) = opval;
    TRACE_RESULT (current_cpu, abuf, "cr", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_SETPSW) : /* setpsw $uimm8 */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_clrpsw.f
#define OPRND(f) par_exec->operands.sfmt_setpsw.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  SET_H_CR (((UINT) 0), OPRND (h_cr_USI_0));

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_BTST) : /* btst $uimm3,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_bset.f
#define OPRND(f) par_exec->operands.sfmt_btst.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = ANDQI (SRLQI (* FLD (i_sr), SUBSI (7, FLD (f_uimm3))), 1);
    OPRND (condbit) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_BTST) : /* btst $uimm3,$sr */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_bset.f
#define OPRND(f) par_exec->operands.sfmt_btst.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  CPU (h_cond) = OPRND (condbit);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);


    }
  ENDSWITCH (sem) /* End of semantic switch.  */

  /* At this point `vpc' contains the next insn to execute.  */
}

#undef DEFINE_SWITCH
#endif /* DEFINE_SWITCH */
@


1.13
log
@[sim] Update old contact info in GPL license notices

sim/ChangeLog:

        Update old contact info in GPL license notices.
@
text
@d5 1
a5 1
Copyright 1996-2010, 2012 Free Software Foundation, Inc.
@


1.12
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d20 1
a20 2
   with this program; if not, write to the Free Software Foundation, Inc.,
   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
@


1.11
log
@Regenerate cgen-derived files.
@
text
@d5 1
a5 1
Copyright 1996-2010 Free Software Foundation, Inc.
@


1.11.8.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d5 1
a5 1
Copyright 1996-2010, 2012 Free Software Foundation, Inc.
@


1.10
log
@Regenerate cgen files, update copyright year.
@
text
@a358 1
#if defined (__STDC__) || defined (ALMOST_STDC) || defined (HAVE_STRINGIZE)
a359 3
#else
#define GET_ATTR(cpu, num, attr) CGEN_ATTR_VALUE (NULL, abuf->idesc->attrs, CGEN_INSN_/**/attr)
#endif
d390 1
a390 1
#define FLD(f) abuf->fields.fmt_empty.f
d415 1
a415 1
#define FLD(f) abuf->fields.fmt_empty.f
d434 1
a434 1
#define FLD(f) abuf->fields.fmt_empty.f
d453 1
a453 1
#define FLD(f) abuf->fields.fmt_empty.f
d481 1
a481 1
#define FLD(f) abuf->fields.fmt_empty.f
d503 1
a503 1
#define FLD(f) abuf->fields.fmt_empty.f
d2295 1
a2295 1
#define FLD(f) abuf->fields.fmt_empty.f
d2377 1
a2377 1
#define FLD(f) abuf->fields.fmt_empty.f
d3062 1
a3062 1
#define FLD(f) abuf->fields.fmt_empty.f
d3157 1
a3157 1
#define FLD(f) abuf->fields.fmt_empty.f
d3173 1
a3173 1
#define FLD(f) abuf->fields.fmt_empty.f
d5216 1
a5216 1
#define FLD(f) abuf->fields.fmt_empty.f
d5233 1
a5233 1
#define FLD(f) abuf->fields.fmt_empty.f
d5373 1
a5373 1
#define FLD(f) abuf->fields.fmt_empty.f
d5411 1
a5411 1
#define FLD(f) abuf->fields.fmt_empty.f
d6274 1
a6274 1
#define FLD(f) abuf->fields.fmt_empty.f
d6295 1
a6295 1
#define FLD(f) abuf->fields.fmt_empty.f
d6464 1
a6464 1
#define FLD(f) abuf->fields.fmt_empty.f
d6482 1
a6482 1
#define FLD(f) abuf->fields.fmt_empty.f
d6498 1
a6498 1
#define FLD(f) abuf->fields.fmt_empty.f
d6516 1
a6516 1
#define FLD(f) abuf->fields.fmt_empty.f
@


1.9
log
@	* arch.c: Regenerate.
	* arch.h: Regenerate.
	* cpu.c: Regenerate.
	* cpu.h: Regenerate.
	* cpu2.c: Regenerate.
	* cpu2.h: Regenerate.
	* cpuall.h: Regenerate.
	* cpux.c: Regenerate.
	* cpux.h: Regenerate.
	* decode.c: Regenerate.
	* decode.h: Regenerate.
	* decode2.c: Regenerate.
	* decode2.h: Regenerate.
	* decodex.c: Regenerate.
	* decodex.h: Regenerate.
	* model.c: Regenerate.
	* model2.c: Regenerate.
	* modelx.c: Regenerate.
	* sem-switch.c: Regenerate.
	* sem.c: Regenerate.
	* sem2-switch.c: Regenerate.
	* semx-switch.c: Regenerate.
@
text
@d5 1
a5 1
Copyright 1996-2009 Free Software Foundation, Inc.
@


1.8
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d5 1
a5 1
Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d9 13
a21 12
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
d2757 2
a2758 1
  HI tmp_new_src2;
a2763 1
  tmp_new_src2 = ADDSI (* FLD (i_src2), 2);
d2765 1
a2765 1
    SI opval = tmp_new_src2;
d2785 2
a2786 1
  QI tmp_new_src2;
a2791 1
  tmp_new_src2 = ADDSI (* FLD (i_src2), 1);
d2793 1
a2793 1
    SI opval = tmp_new_src2;
d3199 1
a3199 1
    SI opval = ANDSI (GET_H_CR (((UINT) 0)), ORSI (INVBI (FLD (f_uimm8)), 65280));
d3218 1
a3218 1
    SI opval = FLD (f_uimm8);
d3237 1
a3237 1
    QI opval = ORQI (GETMEMQI (current_cpu, pc, ADDSI (* FLD (i_sr), FLD (f_simm16))), SLLSI (1, SUBSI (7, FLD (f_uimm3))));
d3256 1
a3256 1
    QI opval = ANDQI (GETMEMQI (current_cpu, pc, ADDSI (* FLD (i_sr), FLD (f_simm16))), INVQI (SLLSI (1, SUBSI (7, FLD (f_uimm3)))));
d3275 1
a3275 1
    BI opval = ANDQI (SRLSI (* FLD (i_sr), SUBSI (7, FLD (f_uimm3))), 1);
d5838 2
a5839 1
  HI tmp_new_src2;
a5845 1
  tmp_new_src2 = ADDSI (* FLD (i_src2), 2);
d5847 1
a5847 1
    SI opval = tmp_new_src2;
d5887 2
a5888 1
  QI tmp_new_src2;
a5894 1
  tmp_new_src2 = ADDSI (* FLD (i_src2), 1);
d5896 1
a5896 1
    SI opval = tmp_new_src2;
d6543 1
a6543 1
    SI opval = ANDSI (GET_H_CR (((UINT) 0)), ORSI (INVBI (FLD (f_uimm8)), 65280));
d6581 1
a6581 1
    SI opval = FLD (f_uimm8);
d6619 1
a6619 1
    BI opval = ANDQI (SRLSI (* FLD (i_sr), SUBSI (7, FLD (f_uimm3))), 1);
@


1.7
log
@Add support for the m32r2 processor
@
text
@d11 2
a12 2
the Free Software Foundation; either version 2, or (at your option)
any later version.
d19 2
a20 3
You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
@


1.6
log
@	* arch.c,arch.h,cpuall.h: Regenerate.
	* cpu.c,cpu.h,decode.c,decode.h,model.c,sem-switch.c,sem.c: Regenerate.
	* cpux.c,cpux.h,decodex.c,decodex.h,modelx.c,semx-switch.c: Regenerate.
@
text
@d5 1
a5 1
Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d143 2
d162 5
d291 4
d323 6
d2747 56
d3189 95
d5827 98
d6526 114
@


1.5
log
@2001-11-14  Dave Brolley  <brolley@@redhat.com>

	* arch.c: Regenerate.
	* arch.h: Regenerate.
	* cpu.c: Regenerate.
	* cpu.h: Regenerate.
	* cpuall.h: Regenerate.
	* cpux.c: Regenerate.
	* cpux.h: Regenerate.
	* decode.c: Regenerate.
	* decode.h: Regenerate.
	* decodex.c: Regenerate.
	* decodex.h: Regenerate.
	* model.c: Regenerate.
	* modelx.c: Regenerate.
	* sem-switch.c: Regenerate.
	* sem.c: Regenerate.
	* semx-switch.c: Regenerate.
@
text
@d5 1
a5 1
Copyright 1996, 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
@


1.5.18.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d5 1
a5 1
Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
a142 2
    { M32RXF_INSN_STH_PLUS, && case_sem_INSN_STH_PLUS },
    { M32RXF_INSN_STB_PLUS, && case_sem_INSN_STB_PLUS },
a159 5
    { M32RXF_INSN_CLRPSW, && case_sem_INSN_CLRPSW },
    { M32RXF_INSN_SETPSW, && case_sem_INSN_SETPSW },
    { M32RXF_INSN_BSET, && case_sem_INSN_BSET },
    { M32RXF_INSN_BCLR, && case_sem_INSN_BCLR },
    { M32RXF_INSN_BTST, && case_sem_INSN_BTST },
a283 4
    { M32RXF_INSN_PAR_STH_PLUS, && case_sem_INSN_PAR_STH_PLUS },
    { M32RXF_INSN_WRITE_STH_PLUS, && case_sem_INSN_WRITE_STH_PLUS },
    { M32RXF_INSN_PAR_STB_PLUS, && case_sem_INSN_PAR_STB_PLUS },
    { M32RXF_INSN_WRITE_STB_PLUS, && case_sem_INSN_WRITE_STB_PLUS },
a311 6
    { M32RXF_INSN_PAR_CLRPSW, && case_sem_INSN_PAR_CLRPSW },
    { M32RXF_INSN_WRITE_CLRPSW, && case_sem_INSN_WRITE_CLRPSW },
    { M32RXF_INSN_PAR_SETPSW, && case_sem_INSN_PAR_SETPSW },
    { M32RXF_INSN_WRITE_SETPSW, && case_sem_INSN_WRITE_SETPSW },
    { M32RXF_INSN_PAR_BTST, && case_sem_INSN_PAR_BTST },
    { M32RXF_INSN_WRITE_BTST, && case_sem_INSN_WRITE_BTST },
a2729 56
  CASE (sem, INSN_STH_PLUS) : /* sth $src1,@@$src2+ */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  HI tmp_new_src2;
  {
    HI opval = * FLD (i_src1);
    SETMEMHI (current_cpu, pc, tmp_new_src2, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
  tmp_new_src2 = ADDSI (* FLD (i_src2), 2);
  {
    SI opval = tmp_new_src2;
    * FLD (i_src2) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_STB_PLUS) : /* stb $src1,@@$src2+ */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  QI tmp_new_src2;
  {
    QI opval = * FLD (i_src1);
    SETMEMQI (current_cpu, pc, tmp_new_src2, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
  tmp_new_src2 = ADDSI (* FLD (i_src2), 1);
  {
    SI opval = tmp_new_src2;
    * FLD (i_src2) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

a3115 95
  CASE (sem, INSN_CLRPSW) : /* clrpsw $uimm8 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_clrpsw.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ANDSI (GET_H_CR (((UINT) 0)), ORSI (INVBI (FLD (f_uimm8)), 65280));
    SET_H_CR (((UINT) 0), opval);
    TRACE_RESULT (current_cpu, abuf, "cr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SETPSW) : /* setpsw $uimm8 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_clrpsw.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = FLD (f_uimm8);
    SET_H_CR (((UINT) 0), opval);
    TRACE_RESULT (current_cpu, abuf, "cr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_BSET) : /* bset $uimm3,@@($slo16,$sr) */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_bset.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    QI opval = ORQI (GETMEMQI (current_cpu, pc, ADDSI (* FLD (i_sr), FLD (f_simm16))), SLLSI (1, SUBSI (7, FLD (f_uimm3))));
    SETMEMQI (current_cpu, pc, ADDSI (* FLD (i_sr), FLD (f_simm16)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_BCLR) : /* bclr $uimm3,@@($slo16,$sr) */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_bset.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    QI opval = ANDQI (GETMEMQI (current_cpu, pc, ADDSI (* FLD (i_sr), FLD (f_simm16))), INVQI (SLLSI (1, SUBSI (7, FLD (f_uimm3)))));
    SETMEMQI (current_cpu, pc, ADDSI (* FLD (i_sr), FLD (f_simm16)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_BTST) : /* btst $uimm3,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_bset.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = ANDQI (SRLSI (* FLD (i_sr), SUBSI (7, FLD (f_uimm3))), 1);
    CPU (h_cond) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

a5658 98
  CASE (sem, INSN_PAR_STH_PLUS) : /* sth $src1,@@$src2+ */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_sth_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  HI tmp_new_src2;
  {
    HI opval = * FLD (i_src1);
    OPRND (h_memory_HI_new_src2_idx) = tmp_new_src2;
    OPRND (h_memory_HI_new_src2) = opval;
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
  tmp_new_src2 = ADDSI (* FLD (i_src2), 2);
  {
    SI opval = tmp_new_src2;
    OPRND (src2) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_STH_PLUS) : /* sth $src1,@@$src2+ */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_sth_plus.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  SETMEMHI (current_cpu, pc, OPRND (h_memory_HI_new_src2_idx), OPRND (h_memory_HI_new_src2));
  * FLD (i_src2) = OPRND (src2);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_STB_PLUS) : /* stb $src1,@@$src2+ */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_stb_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  QI tmp_new_src2;
  {
    QI opval = * FLD (i_src1);
    OPRND (h_memory_QI_new_src2_idx) = tmp_new_src2;
    OPRND (h_memory_QI_new_src2) = opval;
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
  tmp_new_src2 = ADDSI (* FLD (i_src2), 1);
  {
    SI opval = tmp_new_src2;
    OPRND (src2) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_STB_PLUS) : /* stb $src1,@@$src2+ */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_stb_plus.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  SETMEMQI (current_cpu, pc, OPRND (h_memory_QI_new_src2_idx), OPRND (h_memory_QI_new_src2));
  * FLD (i_src2) = OPRND (src2);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

a6259 114

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_CLRPSW) : /* clrpsw $uimm8 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_clrpsw.f
#define OPRND(f) par_exec->operands.sfmt_clrpsw.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ANDSI (GET_H_CR (((UINT) 0)), ORSI (INVBI (FLD (f_uimm8)), 65280));
    OPRND (h_cr_USI_0) = opval;
    TRACE_RESULT (current_cpu, abuf, "cr", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_CLRPSW) : /* clrpsw $uimm8 */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_clrpsw.f
#define OPRND(f) par_exec->operands.sfmt_clrpsw.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  SET_H_CR (((UINT) 0), OPRND (h_cr_USI_0));

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_SETPSW) : /* setpsw $uimm8 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_clrpsw.f
#define OPRND(f) par_exec->operands.sfmt_setpsw.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = FLD (f_uimm8);
    OPRND (h_cr_USI_0) = opval;
    TRACE_RESULT (current_cpu, abuf, "cr", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_SETPSW) : /* setpsw $uimm8 */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_clrpsw.f
#define OPRND(f) par_exec->operands.sfmt_setpsw.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  SET_H_CR (((UINT) 0), OPRND (h_cr_USI_0));

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_BTST) : /* btst $uimm3,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_bset.f
#define OPRND(f) par_exec->operands.sfmt_btst.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = ANDQI (SRLSI (* FLD (i_sr), SUBSI (7, FLD (f_uimm3))), 1);
    OPRND (condbit) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_BTST) : /* btst $uimm3,$sr */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_bset.f
#define OPRND(f) par_exec->operands.sfmt_btst.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  CPU (h_cond) = OPRND (condbit);
@


1.5.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d5 1
a5 1
Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
@


1.5.16.2
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d5 1
a5 1
Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
a142 2
    { M32RXF_INSN_STH_PLUS, && case_sem_INSN_STH_PLUS },
    { M32RXF_INSN_STB_PLUS, && case_sem_INSN_STB_PLUS },
a159 5
    { M32RXF_INSN_CLRPSW, && case_sem_INSN_CLRPSW },
    { M32RXF_INSN_SETPSW, && case_sem_INSN_SETPSW },
    { M32RXF_INSN_BSET, && case_sem_INSN_BSET },
    { M32RXF_INSN_BCLR, && case_sem_INSN_BCLR },
    { M32RXF_INSN_BTST, && case_sem_INSN_BTST },
a283 4
    { M32RXF_INSN_PAR_STH_PLUS, && case_sem_INSN_PAR_STH_PLUS },
    { M32RXF_INSN_WRITE_STH_PLUS, && case_sem_INSN_WRITE_STH_PLUS },
    { M32RXF_INSN_PAR_STB_PLUS, && case_sem_INSN_PAR_STB_PLUS },
    { M32RXF_INSN_WRITE_STB_PLUS, && case_sem_INSN_WRITE_STB_PLUS },
a311 6
    { M32RXF_INSN_PAR_CLRPSW, && case_sem_INSN_PAR_CLRPSW },
    { M32RXF_INSN_WRITE_CLRPSW, && case_sem_INSN_WRITE_CLRPSW },
    { M32RXF_INSN_PAR_SETPSW, && case_sem_INSN_PAR_SETPSW },
    { M32RXF_INSN_WRITE_SETPSW, && case_sem_INSN_WRITE_SETPSW },
    { M32RXF_INSN_PAR_BTST, && case_sem_INSN_PAR_BTST },
    { M32RXF_INSN_WRITE_BTST, && case_sem_INSN_WRITE_BTST },
a2729 56
  CASE (sem, INSN_STH_PLUS) : /* sth $src1,@@$src2+ */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  HI tmp_new_src2;
  {
    HI opval = * FLD (i_src1);
    SETMEMHI (current_cpu, pc, tmp_new_src2, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
  tmp_new_src2 = ADDSI (* FLD (i_src2), 2);
  {
    SI opval = tmp_new_src2;
    * FLD (i_src2) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_STB_PLUS) : /* stb $src1,@@$src2+ */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  QI tmp_new_src2;
  {
    QI opval = * FLD (i_src1);
    SETMEMQI (current_cpu, pc, tmp_new_src2, opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
  tmp_new_src2 = ADDSI (* FLD (i_src2), 1);
  {
    SI opval = tmp_new_src2;
    * FLD (i_src2) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

#undef FLD
}
  NEXT (vpc);

a3115 95
  CASE (sem, INSN_CLRPSW) : /* clrpsw $uimm8 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_clrpsw.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ANDSI (GET_H_CR (((UINT) 0)), ORSI (INVBI (FLD (f_uimm8)), 65280));
    SET_H_CR (((UINT) 0), opval);
    TRACE_RESULT (current_cpu, abuf, "cr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_SETPSW) : /* setpsw $uimm8 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_clrpsw.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = FLD (f_uimm8);
    SET_H_CR (((UINT) 0), opval);
    TRACE_RESULT (current_cpu, abuf, "cr", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_BSET) : /* bset $uimm3,@@($slo16,$sr) */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_bset.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    QI opval = ORQI (GETMEMQI (current_cpu, pc, ADDSI (* FLD (i_sr), FLD (f_simm16))), SLLSI (1, SUBSI (7, FLD (f_uimm3))));
    SETMEMQI (current_cpu, pc, ADDSI (* FLD (i_sr), FLD (f_simm16)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_BCLR) : /* bclr $uimm3,@@($slo16,$sr) */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_bset.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 4);

  {
    QI opval = ANDQI (GETMEMQI (current_cpu, pc, ADDSI (* FLD (i_sr), FLD (f_simm16))), INVQI (SLLSI (1, SUBSI (7, FLD (f_uimm3)))));
    SETMEMQI (current_cpu, pc, ADDSI (* FLD (i_sr), FLD (f_simm16)), opval);
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

  CASE (sem, INSN_BTST) : /* btst $uimm3,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_bset.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = ANDQI (SRLSI (* FLD (i_sr), SUBSI (7, FLD (f_uimm3))), 1);
    CPU (h_cond) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }

#undef FLD
}
  NEXT (vpc);

a5658 98
  CASE (sem, INSN_PAR_STH_PLUS) : /* sth $src1,@@$src2+ */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_sth_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  HI tmp_new_src2;
  {
    HI opval = * FLD (i_src1);
    OPRND (h_memory_HI_new_src2_idx) = tmp_new_src2;
    OPRND (h_memory_HI_new_src2) = opval;
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
  tmp_new_src2 = ADDSI (* FLD (i_src2), 2);
  {
    SI opval = tmp_new_src2;
    OPRND (src2) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_STH_PLUS) : /* sth $src1,@@$src2+ */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_sth_plus.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  SETMEMHI (current_cpu, pc, OPRND (h_memory_HI_new_src2_idx), OPRND (h_memory_HI_new_src2));
  * FLD (i_src2) = OPRND (src2);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_STB_PLUS) : /* stb $src1,@@$src2+ */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_stb_plus.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

{
  QI tmp_new_src2;
  {
    QI opval = * FLD (i_src1);
    OPRND (h_memory_QI_new_src2_idx) = tmp_new_src2;
    OPRND (h_memory_QI_new_src2) = opval;
    TRACE_RESULT (current_cpu, abuf, "memory", 'x', opval);
  }
  tmp_new_src2 = ADDSI (* FLD (i_src2), 1);
  {
    SI opval = tmp_new_src2;
    OPRND (src2) = opval;
    TRACE_RESULT (current_cpu, abuf, "gr", 'x', opval);
  }
}

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_STB_PLUS) : /* stb $src1,@@$src2+ */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_st_plus.f
#define OPRND(f) par_exec->operands.sfmt_stb_plus.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  SETMEMQI (current_cpu, pc, OPRND (h_memory_QI_new_src2_idx), OPRND (h_memory_QI_new_src2));
  * FLD (i_src2) = OPRND (src2);

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

a6259 114

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_CLRPSW) : /* clrpsw $uimm8 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_clrpsw.f
#define OPRND(f) par_exec->operands.sfmt_clrpsw.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = ANDSI (GET_H_CR (((UINT) 0)), ORSI (INVBI (FLD (f_uimm8)), 65280));
    OPRND (h_cr_USI_0) = opval;
    TRACE_RESULT (current_cpu, abuf, "cr", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_CLRPSW) : /* clrpsw $uimm8 */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_clrpsw.f
#define OPRND(f) par_exec->operands.sfmt_clrpsw.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  SET_H_CR (((UINT) 0), OPRND (h_cr_USI_0));

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_SETPSW) : /* setpsw $uimm8 */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_clrpsw.f
#define OPRND(f) par_exec->operands.sfmt_setpsw.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    SI opval = FLD (f_uimm8);
    OPRND (h_cr_USI_0) = opval;
    TRACE_RESULT (current_cpu, abuf, "cr", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_SETPSW) : /* setpsw $uimm8 */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_clrpsw.f
#define OPRND(f) par_exec->operands.sfmt_setpsw.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  SET_H_CR (((UINT) 0), OPRND (h_cr_USI_0));

#undef OPRND
#undef FLD
  }
  NEXT (vpc);

  CASE (sem, INSN_PAR_BTST) : /* btst $uimm3,$sr */
{
  SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
  ARGBUF *abuf = SEM_ARGBUF (sem_arg);
#define FLD(f) abuf->fields.sfmt_bset.f
#define OPRND(f) par_exec->operands.sfmt_btst.f
  int UNUSED written = 0;
  IADDR UNUSED pc = abuf->addr;
  vpc = SEM_NEXT_VPC (sem_arg, pc, 2);

  {
    BI opval = ANDQI (SRLSI (* FLD (i_sr), SUBSI (7, FLD (f_uimm3))), 1);
    OPRND (condbit) = opval;
    TRACE_RESULT (current_cpu, abuf, "cond", 'x', opval);
  }

#undef OPRND
#undef FLD
}
  NEXT (vpc);

CASE (sem, INSN_WRITE_BTST) : /* btst $uimm3,$sr */
  {
    SEM_ARG sem_arg = SEM_SEM_ARG (vpc, sc);
    const ARGBUF *abuf = SEM_ARGBUF (sem_arg)->fields.write.abuf;
#define FLD(f) abuf->fields.sfmt_bset.f
#define OPRND(f) par_exec->operands.sfmt_btst.f
    int UNUSED written = abuf->written;
    IADDR UNUSED pc = abuf->addr;
    vpc = SEM_NEXT_VPC (sem_arg, pc, 0);

  CPU (h_cond) = OPRND (condbit);
@


1.4
log
@2001-03-05  Dave Brolley  <brolley

        arch.c: Regenerate.
        arch.h: Regenerate.
        cpu.c: Regenerate.
        cpu.h: Regenerate.
        cpuall.h: Regenerate.
        cpux.c: Regenerate.
        cpux.h: Regenerate.
        decode.c: Regenerate.
        decode.h: Regenerate.
        decodex.c: Regenerate.
        decodex.h: Regenerate.
        model.c: Regenerate.
        modelx.c: Regenerate.
        sem-switch.c: Regenerate.
        sem.c: Regenerate.
        semx-switch.c: Regenerate.
@
text
@d5 1
a5 1
Copyright (C) 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
d7 1
a7 1
This file is part of the GNU Simulators.
d3464 1
a3464 1
    OPRND (h_gr_14) = opval;
d3490 1
a3490 1
  CPU (h_gr[((UINT) 14)]) = OPRND (h_gr_14);
d3513 1
a3513 1
    OPRND (h_gr_14) = opval;
d3545 1
a3545 1
      CPU (h_gr[((UINT) 14)]) = OPRND (h_gr_14);
d3659 1
a3659 1
    OPRND (h_gr_14) = opval;
d3691 1
a3691 1
      CPU (h_gr[((UINT) 14)]) = OPRND (h_gr_14);
d3966 1
a3966 1
    OPRND (h_gr_14) = opval;
d3992 1
a3992 1
  CPU (h_gr[((UINT) 14)]) = OPRND (h_gr_14);
d4084 1
a4084 1
#define OPRND(f) par_exec->operands.sfmt_ld.f
d4105 1
a4105 1
#define OPRND(f) par_exec->operands.sfmt_ld.f
d4122 1
a4122 1
#define OPRND(f) par_exec->operands.sfmt_ld.f
d4143 1
a4143 1
#define OPRND(f) par_exec->operands.sfmt_ld.f
d4160 1
a4160 1
#define OPRND(f) par_exec->operands.sfmt_ld.f
d4181 1
a4181 1
#define OPRND(f) par_exec->operands.sfmt_ld.f
d4198 1
a4198 1
#define OPRND(f) par_exec->operands.sfmt_ld.f
d4219 1
a4219 1
#define OPRND(f) par_exec->operands.sfmt_ld.f
d4331 1
a4331 1
    OPRND (h_lock) = opval;
d4357 1
a4357 1
  CPU (h_lock) = OPRND (h_lock);
d5223 1
a5223 1
    OPRND (h_cr_6) = opval;
d5228 1
a5228 1
    OPRND (h_psw) = opval;
d5233 1
a5233 1
    OPRND (h_bpsw) = opval;
d5254 3
a5256 3
  CPU (h_bpsw) = OPRND (h_bpsw);
  SET_H_CR (((UINT) 6), OPRND (h_cr_6));
  SET_H_PSW (OPRND (h_psw));
d5505 2
a5506 2
    OPRND (h_memory_src2_idx) = * FLD (i_src2);
    OPRND (h_memory_src2) = opval;
d5525 1
a5525 1
  SETMEMSI (current_cpu, pc, OPRND (h_memory_src2_idx), OPRND (h_memory_src2));
d5544 2
a5545 2
    OPRND (h_memory_src2_idx) = * FLD (i_src2);
    OPRND (h_memory_src2) = opval;
d5564 1
a5564 1
  SETMEMQI (current_cpu, pc, OPRND (h_memory_src2_idx), OPRND (h_memory_src2));
d5583 2
a5584 2
    OPRND (h_memory_src2_idx) = * FLD (i_src2);
    OPRND (h_memory_src2) = opval;
d5603 1
a5603 1
  SETMEMHI (current_cpu, pc, OPRND (h_memory_src2_idx), OPRND (h_memory_src2));
d5625 2
a5626 2
    OPRND (h_memory_new_src2_idx) = tmp_new_src2;
    OPRND (h_memory_new_src2) = opval;
d5651 1
a5651 1
  SETMEMSI (current_cpu, pc, OPRND (h_memory_new_src2_idx), OPRND (h_memory_new_src2));
d5674 2
a5675 2
    OPRND (h_memory_new_src2_idx) = tmp_new_src2;
    OPRND (h_memory_new_src2) = opval;
d5700 1
a5700 1
  SETMEMSI (current_cpu, pc, OPRND (h_memory_new_src2_idx), OPRND (h_memory_new_src2));
d5857 1
a5857 1
    OPRND (h_cr_14) = opval;
d5862 1
a5862 1
    OPRND (h_cr_6) = opval;
d5867 1
a5867 1
    OPRND (h_bbpsw) = opval;
d5872 1
a5872 1
    OPRND (h_bpsw) = opval;
d5877 1
a5877 1
    OPRND (h_psw) = opval;
d5903 5
a5907 5
  CPU (h_bbpsw) = OPRND (h_bbpsw);
  CPU (h_bpsw) = OPRND (h_bpsw);
  SET_H_CR (((UINT) 14), OPRND (h_cr_14));
  SET_H_CR (((UINT) 6), OPRND (h_cr_6));
  SET_H_PSW (OPRND (h_psw));
d5930 2
a5931 2
    OPRND (h_memory_src2_idx) = * FLD (i_src2);
    OPRND (h_memory_src2) = opval;
d5938 1
a5938 1
    OPRND (h_lock) = opval;
d5959 1
a5959 1
  CPU (h_lock) = OPRND (h_lock);
d5962 1
a5962 1
      SETMEMSI (current_cpu, pc, OPRND (h_memory_src2_idx), OPRND (h_memory_src2));
d6020 1
a6020 1
    OPRND (h_accums_0) = opval;
d6039 1
a6039 1
  SET_H_ACCUMS (((UINT) 0), OPRND (h_accums_0));
d6058 1
a6058 1
    OPRND (h_accums_1) = opval;
d6077 1
a6077 1
  SET_H_ACCUMS (((UINT) 1), OPRND (h_accums_1));
d6134 1
a6134 1
    OPRND (h_accums_1) = opval;
d6153 1
a6153 1
  SET_H_ACCUMS (((UINT) 1), OPRND (h_accums_1));
d6172 1
a6172 1
    OPRND (h_accums_1) = opval;
d6191 1
a6191 1
  SET_H_ACCUMS (((UINT) 1), OPRND (h_accums_1));
@


1.3
log
@2000-10-06  Dave Brolley  <brolley@@redhat.com>

	* sem.c: Regenerated.
	* sem-switch.c: Regenerated.
	* semx-switch.c: Regenerated.
@
text
@d5 1
a5 1
Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
d342 1
d344 3
d527 1
a527 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d546 1
a546 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d565 1
a565 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d584 1
a584 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d603 1
a603 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d622 1
a622 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d641 1
a641 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d660 1
a660 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d679 1
a679 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d702 1
a702 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d707 1
a707 1
    TRACE_RESULT (current_cpu, abuf, "condbit", 'x', opval);
d731 1
a731 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d736 1
a736 1
    TRACE_RESULT (current_cpu, abuf, "condbit", 'x', opval);
d760 1
a760 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d765 1
a765 1
    TRACE_RESULT (current_cpu, abuf, "condbit", 'x', opval);
d1012 1
a1012 1
    TRACE_RESULT (current_cpu, abuf, "gr-14", 'x', opval);
d1040 1
a1040 1
    TRACE_RESULT (current_cpu, abuf, "gr-14", 'x', opval);
d1070 1
a1070 1
    TRACE_RESULT (current_cpu, abuf, "gr-14", 'x', opval);
d1103 1
a1103 1
    TRACE_RESULT (current_cpu, abuf, "gr-14", 'x', opval);
d1253 1
a1253 1
    TRACE_RESULT (current_cpu, abuf, "gr-14", 'x', opval);
d1286 1
a1286 1
    TRACE_RESULT (current_cpu, abuf, "gr-14", 'x', opval);
d1315 1
a1315 1
    TRACE_RESULT (current_cpu, abuf, "condbit", 'x', opval);
d1334 1
a1334 1
    TRACE_RESULT (current_cpu, abuf, "condbit", 'x', opval);
d1353 1
a1353 1
    TRACE_RESULT (current_cpu, abuf, "condbit", 'x', opval);
d1372 1
a1372 1
    TRACE_RESULT (current_cpu, abuf, "condbit", 'x', opval);
d1391 1
a1391 1
    TRACE_RESULT (current_cpu, abuf, "condbit", 'x', opval);
d1410 1
a1410 1
    TRACE_RESULT (current_cpu, abuf, "condbit", 'x', opval);
d1431 1
a1431 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1454 1
a1454 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1477 1
a1477 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1500 1
a1500 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1523 1
a1523 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1599 1
a1599 1
    TRACE_RESULT (current_cpu, abuf, "gr-14", 'x', opval);
d1646 1
a1646 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1665 1
a1665 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1684 1
a1684 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1703 1
a1703 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1722 1
a1722 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1741 1
a1741 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1760 1
a1760 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1779 1
a1779 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1798 1
a1798 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1817 1
a1817 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1840 1
a1840 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1845 1
a1845 1
    TRACE_RESULT (current_cpu, abuf, "sr", 'x', opval);
d1865 1
a1865 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1884 1
a1884 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1903 1
a1903 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1928 1
a1928 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d1948 1
a1948 1
    TRACE_RESULT (current_cpu, abuf, "acc", 'D', opval);
d1967 1
a1967 1
    TRACE_RESULT (current_cpu, abuf, "acc", 'D', opval);
d1986 1
a1986 1
    TRACE_RESULT (current_cpu, abuf, "acc", 'D', opval);
d2005 1
a2005 1
    TRACE_RESULT (current_cpu, abuf, "acc", 'D', opval);
d2024 1
a2024 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d2043 1
a2043 1
    TRACE_RESULT (current_cpu, abuf, "acc", 'D', opval);
d2062 1
a2062 1
    TRACE_RESULT (current_cpu, abuf, "acc", 'D', opval);
d2081 1
a2081 1
    TRACE_RESULT (current_cpu, abuf, "acc", 'D', opval);
d2100 1
a2100 1
    TRACE_RESULT (current_cpu, abuf, "acc", 'D', opval);
d2119 1
a2119 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d2138 1
a2138 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d2157 1
a2157 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d2176 1
a2176 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d2195 1
a2195 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d2214 1
a2214 1
    TRACE_RESULT (current_cpu, abuf, "accs", 'D', opval);
d2233 1
a2233 1
    TRACE_RESULT (current_cpu, abuf, "accs", 'D', opval);
d2252 1
a2252 1
    TRACE_RESULT (current_cpu, abuf, "dcr", 'x', opval);
d2271 1
a2271 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d2305 1
a2305 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d2328 1
a2328 1
    TRACE_RESULT (current_cpu, abuf, "accd", 'D', opval);
d2352 1
a2352 1
    TRACE_RESULT (current_cpu, abuf, "accd", 'D', opval);
d2379 1
a2379 1
    TRACE_RESULT (current_cpu, abuf, "cr-6", 'x', opval);
d2410 1
a2410 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d2429 1
a2429 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d2448 1
a2448 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d2467 1
a2467 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d2486 1
a2486 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d2505 1
a2505 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d2524 1
a2524 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d2543 1
a2543 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d2562 1
a2562 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d2581 1
a2581 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d2722 1
a2722 1
    TRACE_RESULT (current_cpu, abuf, "src2", 'x', opval);
d2750 1
a2750 1
    TRACE_RESULT (current_cpu, abuf, "src2", 'x', opval);
d2770 1
a2770 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d2793 1
a2793 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d2798 1
a2798 1
    TRACE_RESULT (current_cpu, abuf, "condbit", 'x', opval);
d2822 1
a2822 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d2827 1
a2827 1
    TRACE_RESULT (current_cpu, abuf, "condbit", 'x', opval);
d2849 1
a2849 1
    TRACE_RESULT (current_cpu, abuf, "cr-14", 'x', opval);
d2854 1
a2854 1
    TRACE_RESULT (current_cpu, abuf, "cr-6", 'x', opval);
d2925 1
a2925 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d2944 1
a2944 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d2963 1
a2963 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d2982 1
a2982 1
    TRACE_RESULT (current_cpu, abuf, "condbit", 'x', opval);
d3001 1
a3001 1
    TRACE_RESULT (current_cpu, abuf, "accums-0", 'D', opval);
d3020 1
a3020 1
    TRACE_RESULT (current_cpu, abuf, "accums-1", 'D', opval);
d3058 1
a3058 1
    TRACE_RESULT (current_cpu, abuf, "accums-1", 'D', opval);
d3077 1
a3077 1
    TRACE_RESULT (current_cpu, abuf, "accums-1", 'D', opval);
d3129 1
a3129 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d3167 1
a3167 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d3205 1
a3205 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d3243 1
a3243 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d3281 1
a3281 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d3323 1
a3323 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d3328 1
a3328 1
    TRACE_RESULT (current_cpu, abuf, "condbit", 'x', opval);
d3372 1
a3372 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d3377 1
a3377 1
    TRACE_RESULT (current_cpu, abuf, "condbit", 'x', opval);
d3465 1
a3465 1
    TRACE_RESULT (current_cpu, abuf, "gr-14", 'x', opval);
d3515 1
a3515 1
    TRACE_RESULT (current_cpu, abuf, "gr-14", 'x', opval);
d3661 1
a3661 1
    TRACE_RESULT (current_cpu, abuf, "gr-14", 'x', opval);
d3717 1
a3717 1
    TRACE_RESULT (current_cpu, abuf, "condbit", 'x', opval);
d3755 1
a3755 1
    TRACE_RESULT (current_cpu, abuf, "condbit", 'x', opval);
d3793 1
a3793 1
    TRACE_RESULT (current_cpu, abuf, "condbit", 'x', opval);
d3831 1
a3831 1
    TRACE_RESULT (current_cpu, abuf, "condbit", 'x', opval);
d3967 1
a3967 1
    TRACE_RESULT (current_cpu, abuf, "gr-14", 'x', opval);
d4054 1
a4054 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d4092 1
a4092 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d4130 1
a4130 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d4168 1
a4168 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d4206 1
a4206 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d4248 1
a4248 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d4253 1
a4253 1
    TRACE_RESULT (current_cpu, abuf, "sr", 'x', opval);
d4293 1
a4293 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d4337 1
a4337 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d4377 1
a4377 1
    TRACE_RESULT (current_cpu, abuf, "acc", 'D', opval);
d4415 1
a4415 1
    TRACE_RESULT (current_cpu, abuf, "acc", 'D', opval);
d4453 1
a4453 1
    TRACE_RESULT (current_cpu, abuf, "acc", 'D', opval);
d4491 1
a4491 1
    TRACE_RESULT (current_cpu, abuf, "acc", 'D', opval);
d4529 1
a4529 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d4567 1
a4567 1
    TRACE_RESULT (current_cpu, abuf, "acc", 'D', opval);
d4605 1
a4605 1
    TRACE_RESULT (current_cpu, abuf, "acc", 'D', opval);
d4643 1
a4643 1
    TRACE_RESULT (current_cpu, abuf, "acc", 'D', opval);
d4681 1
a4681 1
    TRACE_RESULT (current_cpu, abuf, "acc", 'D', opval);
d4719 1
a4719 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d4757 1
a4757 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d4795 1
a4795 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d4833 1
a4833 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d4871 1
a4871 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d4909 1
a4909 1
    TRACE_RESULT (current_cpu, abuf, "accs", 'D', opval);
d4947 1
a4947 1
    TRACE_RESULT (current_cpu, abuf, "accs", 'D', opval);
d4985 1
a4985 1
    TRACE_RESULT (current_cpu, abuf, "dcr", 'x', opval);
d5023 1
a5023 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d5094 1
a5094 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d5136 1
a5136 1
    TRACE_RESULT (current_cpu, abuf, "accd", 'D', opval);
d5179 1
a5179 1
    TRACE_RESULT (current_cpu, abuf, "accd", 'D', opval);
d5224 1
a5224 1
    TRACE_RESULT (current_cpu, abuf, "cr-6", 'x', opval);
d5278 1
a5278 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d5316 1
a5316 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d5354 1
a5354 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d5392 1
a5392 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d5430 1
a5430 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d5468 1
a5468 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d5632 1
a5632 1
    TRACE_RESULT (current_cpu, abuf, "src2", 'x', opval);
d5681 1
a5681 1
    TRACE_RESULT (current_cpu, abuf, "src2", 'x', opval);
d5721 1
a5721 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d5763 1
a5763 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d5768 1
a5768 1
    TRACE_RESULT (current_cpu, abuf, "condbit", 'x', opval);
d5812 1
a5812 1
    TRACE_RESULT (current_cpu, abuf, "dr", 'x', opval);
d5817 1
a5817 1
    TRACE_RESULT (current_cpu, abuf, "condbit", 'x', opval);
d5858 1
a5858 1
    TRACE_RESULT (current_cpu, abuf, "cr-14", 'x', opval);
d5863 1
a5863 1
    TRACE_RESULT (current_cpu, abuf, "cr-6", 'x', opval);
d5983 1
a5983 1
    TRACE_RESULT (current_cpu, abuf, "condbit", 'x', opval);
d6021 1
a6021 1
    TRACE_RESULT (current_cpu, abuf, "accums-0", 'D', opval);
d6059 1
a6059 1
    TRACE_RESULT (current_cpu, abuf, "accums-1", 'D', opval);
d6135 1
a6135 1
    TRACE_RESULT (current_cpu, abuf, "accums-1", 'D', opval);
d6173 1
a6173 1
    TRACE_RESULT (current_cpu, abuf, "accums-1", 'D', opval);
@


1.2
log
@2000-08-28  Dave Brolley  <brolley@@redhat.com>

	* Makefile.in: Use of @@true confuses VPATH. Remove it.
	* cpu.h: Regenerated.
	* cpux.h: Regenerated.
	* decode.c: Regenerated.
	* decodex.c: Regenerated.
	* model.c: Regenerated.
	* modelx.c: Regenerated.
	* sem-switch.c: Regenerated.
	* sem.c: Regenerated.
	* semx-switch.c: Regenerated.
@
text
@d493 1
a493 1
#ifdef DEFINE_SWITCH
d498 1
d500 3
@


1.1
log
@Initial revision
@
text
@d1528 1
a1528 1
#define FLD(f) abuf->fields.sfmt_mvtc.f
d1553 1
a1553 1
#define FLD(f) abuf->fields.sfmt_mvtc.f
d1609 1
a1609 1
#define FLD(f) abuf->fields.sfmt_mvtc.f
d2179 1
a2179 1
#define FLD(f) abuf->fields.sfmt_mvfc.f
d2236 1
a2236 1
#define FLD(f) abuf->fields.sfmt_mvtc.f
d3852 1
a3852 1
#define FLD(f) abuf->fields.sfmt_mvtc.f
d3877 1
a3877 1
#define FLD(f) abuf->fields.sfmt_mvtc.f
d3899 1
a3899 1
#define FLD(f) abuf->fields.sfmt_mvtc.f
d3924 1
a3924 1
#define FLD(f) abuf->fields.sfmt_mvtc.f
d3997 1
a3997 1
#define FLD(f) abuf->fields.sfmt_mvtc.f
d4018 1
a4018 1
#define FLD(f) abuf->fields.sfmt_mvtc.f
d4854 1
a4854 1
#define FLD(f) abuf->fields.sfmt_mvfc.f
d4875 1
a4875 1
#define FLD(f) abuf->fields.sfmt_mvfc.f
d4968 1
a4968 1
#define FLD(f) abuf->fields.sfmt_mvtc.f
d4989 1
a4989 1
#define FLD(f) abuf->fields.sfmt_mvtc.f
@


1.1.1.1
log
@import gdb-1999-10-11 snapshot
@
text
@@
