head	1.11;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.11
	gdb_7_6-2013-04-26-release:1.11
	gdb_7_6-branch:1.11.0.2
	gdb_7_6-2013-03-12-branchpoint:1.11
	gdb_7_5_1-2012-11-29-release:1.10
	gdb_7_5-2012-08-17-release:1.10
	gdb_7_5-branch:1.10.0.2
	gdb_7_5-2012-07-18-branchpoint:1.10
	gdb_7_4_1-2012-04-26-release:1.9.4.1
	gdb_7_4-2012-01-24-release:1.9.4.1
	gdb_7_4-branch:1.9.0.4
	gdb_7_4-2011-12-13-branchpoint:1.9
	gdb_7_3_1-2011-09-04-release:1.9
	gdb_7_3-2011-07-26-release:1.9
	gdb_7_3-branch:1.9.0.2
	gdb_7_3-2011-04-01-branchpoint:1.9
	gdb_7_2-2010-09-02-release:1.8
	gdb_7_2-branch:1.8.0.4
	gdb_7_2-2010-07-07-branchpoint:1.8
	gdb_7_1-2010-03-18-release:1.8
	gdb_7_1-branch:1.8.0.2
	gdb_7_1-2010-02-18-branchpoint:1.8
	gdb_7_0_1-2009-12-22-release:1.7
	gdb_7_0-2009-10-06-release:1.7
	gdb_7_0-branch:1.7.0.4
	gdb_7_0-2009-09-16-branchpoint:1.7
	arc-sim-20090309:1.5
	msnyder-checkpoint-072509-branch:1.7.0.2
	msnyder-checkpoint-072509-branchpoint:1.7
	arc-insight_6_8-branch:1.5.0.16
	arc-insight_6_8-branchpoint:1.5
	insight_6_8-branch:1.5.0.14
	insight_6_8-branchpoint:1.5
	reverse-20081226-branch:1.5.0.12
	reverse-20081226-branchpoint:1.5
	multiprocess-20081120-branch:1.5.0.10
	multiprocess-20081120-branchpoint:1.5
	reverse-20080930-branch:1.5.0.8
	reverse-20080930-branchpoint:1.5
	reverse-20080717-branch:1.5.0.6
	reverse-20080717-branchpoint:1.5
	msnyder-reverse-20080609-branch:1.5.0.4
	msnyder-reverse-20080609-branchpoint:1.5
	drow-reverse-20070409-branch:1.3.0.2
	drow-reverse-20070409-branchpoint:1.3
	gdb_6_8-2008-03-27-release:1.5
	gdb_6_8-branch:1.5.0.2
	gdb_6_8-2008-02-26-branchpoint:1.5
	gdb_6_7_1-2007-10-29-release:1.4
	gdb_6_7-2007-10-10-release:1.4
	gdb_6_7-branch:1.4.0.2
	gdb_6_7-2007-09-07-branchpoint:1.4
	insight_6_6-20070208-release:1.2
	gdb_6_6-2006-12-18-release:1.2
	gdb_6_6-branch:1.2.0.46
	gdb_6_6-2006-11-15-branchpoint:1.2
	insight_6_5-20061003-release:1.2
	gdb-csl-symbian-6_4_50_20060226-12:1.2
	gdb-csl-sourcerygxx-3_4_4-25:1.2
	nickrob-async-20060828-mergepoint:1.2
	gdb-csl-symbian-6_4_50_20060226-11:1.2
	gdb-csl-sourcerygxx-4_1-17:1.2
	gdb-csl-20060226-branch-local-2:1.2
	gdb-csl-sourcerygxx-4_1-14:1.2
	gdb-csl-sourcerygxx-4_1-13:1.2
	gdb-csl-sourcerygxx-4_1-12:1.2
	gdb-csl-sourcerygxx-3_4_4-21:1.2
	gdb_6_5-20060621-release:1.2
	gdb-csl-sourcerygxx-4_1-9:1.2
	gdb-csl-sourcerygxx-4_1-8:1.2
	gdb-csl-sourcerygxx-4_1-7:1.2
	gdb-csl-arm-2006q1-6:1.2
	gdb-csl-sourcerygxx-4_1-6:1.2
	gdb-csl-symbian-6_4_50_20060226-10:1.2
	gdb-csl-symbian-6_4_50_20060226-9:1.2
	gdb-csl-symbian-6_4_50_20060226-8:1.2
	gdb-csl-coldfire-4_1-11:1.2
	gdb-csl-sourcerygxx-3_4_4-19:1.2
	gdb-csl-coldfire-4_1-10:1.2
	gdb_6_5-branch:1.2.0.44
	gdb_6_5-2006-05-14-branchpoint:1.2
	gdb-csl-sourcerygxx-4_1-5:1.2
	nickrob-async-20060513-branch:1.2.0.42
	nickrob-async-20060513-branchpoint:1.2
	gdb-csl-sourcerygxx-4_1-4:1.2
	msnyder-reverse-20060502-branch:1.2.0.40
	msnyder-reverse-20060502-branchpoint:1.2
	gdb-csl-morpho-4_1-4:1.2
	gdb-csl-sourcerygxx-3_4_4-17:1.2
	readline_5_1-import-branch:1.2.0.38
	readline_5_1-import-branchpoint:1.2
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.2
	gdb-csl-symbian-20060226-branch:1.2.0.36
	gdb-csl-symbian-20060226-branchpoint:1.2
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.2
	msnyder-reverse-20060331-branch:1.2.0.34
	msnyder-reverse-20060331-branchpoint:1.2
	gdb-csl-available-20060303-branch:1.2.0.32
	gdb-csl-available-20060303-branchpoint:1.2
	gdb-csl-20060226-branch:1.2.0.30
	gdb-csl-20060226-branchpoint:1.2
	gdb_6_4-20051202-release:1.2
	msnyder-fork-checkpoint-branch:1.2.0.28
	msnyder-fork-checkpoint-branchpoint:1.2
	gdb-csl-gxxpro-6_3-branch:1.2.0.26
	gdb-csl-gxxpro-6_3-branchpoint:1.2
	gdb_6_4-branch:1.2.0.24
	gdb_6_4-2005-11-01-branchpoint:1.2
	gdb-csl-arm-20051020-branch:1.2.0.22
	gdb-csl-arm-20051020-branchpoint:1.2
	msnyder-tracepoint-checkpoint-branch:1.2.0.20
	msnyder-tracepoint-checkpoint-branchpoint:1.2
	gdb-csl-arm-20050325-2005-q1b:1.2
	gdb-csl-arm-20050325-2005-q1a:1.2
	csl-arm-20050325-branch:1.2.0.18
	csl-arm-20050325-branchpoint:1.2
	gdb_6_3-20041109-release:1.2
	gdb_6_3-branch:1.2.0.14
	gdb_6_3-20041019-branchpoint:1.2
	drow_intercu-merge-20040921:1.2
	drow_intercu-merge-20040915:1.2
	jimb-gdb_6_2-e500-branch:1.2.0.16
	jimb-gdb_6_2-e500-branchpoint:1.2
	gdb_6_2-20040730-release:1.2
	gdb_6_2-branch:1.2.0.12
	gdb_6_2-2004-07-10-gmt-branchpoint:1.2
	gdb_6_1_1-20040616-release:1.2
	gdb_6_1-2004-04-05-release:1.2
	drow_intercu-merge-20040402:1.2
	drow_intercu-merge-20040327:1.2
	ezannoni_pie-20040323-branch:1.2.0.10
	ezannoni_pie-20040323-branchpoint:1.2
	cagney_tramp-20040321-mergepoint:1.2
	cagney_tramp-20040309-branch:1.2.0.8
	cagney_tramp-20040309-branchpoint:1.2
	gdb_6_1-branch:1.2.0.6
	gdb_6_1-2004-03-01-gmt-branchpoint:1.2
	drow_intercu-20040221-branch:1.2.0.4
	drow_intercu-20040221-branchpoint:1.2
	cagney_bfdfile-20040213-branch:1.2.0.2
	cagney_bfdfile-20040213-branchpoint:1.2
	drow-cplus-merge-20040208:1.2
	carlton_dictionary-20040126-merge:1.1.1.1
	cagney_bigcore-20040122-branch:1.1.1.1.0.70
	cagney_bigcore-20040122-branchpoint:1.1.1.1
	drow-cplus-merge-20040113:1.1.1.1
	drow-cplus-merge-20031224:1.1.1.1
	drow-cplus-merge-20031220:1.1.1.1
	carlton_dictionary-20031215-merge:1.1.1.1
	drow-cplus-merge-20031214:1.1.1.1
	carlton-dictionary-20031111-merge:1.1.1.1
	gdb_6_0-2003-10-04-release:1.1.1.1
	kettenis_sparc-20030918-branch:1.1.1.1.0.68
	kettenis_sparc-20030918-branchpoint:1.1.1.1
	carlton_dictionary-20030917-merge:1.1.1.1
	ezannoni_pie-20030916-branchpoint:1.1.1.1
	ezannoni_pie-20030916-branch:1.1.1.1.0.66
	cagney_x86i386-20030821-branch:1.1.1.1.0.64
	cagney_x86i386-20030821-branchpoint:1.1.1.1
	carlton_dictionary-20030805-merge:1.1.1.1
	carlton_dictionary-20030627-merge:1.1.1.1
	gdb_6_0-branch:1.1.1.1.0.62
	gdb_6_0-2003-06-23-branchpoint:1.1.1.1
	jimb-ppc64-linux-20030613-branch:1.1.1.1.0.60
	jimb-ppc64-linux-20030613-branchpoint:1.1.1.1
	cagney_convert-20030606-branch:1.1.1.1.0.58
	cagney_convert-20030606-branchpoint:1.1.1.1
	cagney_writestrings-20030508-branch:1.1.1.1.0.56
	cagney_writestrings-20030508-branchpoint:1.1.1.1
	jimb-ppc64-linux-20030528-branch:1.1.1.1.0.54
	jimb-ppc64-linux-20030528-branchpoint:1.1.1.1
	carlton_dictionary-20030523-merge:1.1.1.1
	cagney_fileio-20030521-branch:1.1.1.1.0.52
	cagney_fileio-20030521-branchpoint:1.1.1.1
	kettenis_i386newframe-20030517-mergepoint:1.1.1.1
	jimb-ppc64-linux-20030509-branch:1.1.1.1.0.50
	jimb-ppc64-linux-20030509-branchpoint:1.1.1.1
	kettenis_i386newframe-20030504-mergepoint:1.1.1.1
	carlton_dictionary-20030430-merge:1.1.1.1
	kettenis_i386newframe-20030419-branch:1.1.1.1.0.48
	kettenis_i386newframe-20030419-branchpoint:1.1.1.1
	carlton_dictionary-20030416-merge:1.1.1.1
	cagney_frameaddr-20030409-mergepoint:1.1.1.1
	kettenis_i386newframe-20030406-branch:1.1.1.1.0.46
	kettenis_i386newframe-20030406-branchpoint:1.1.1.1
	cagney_frameaddr-20030403-branchpoint:1.1.1.1
	cagney_frameaddr-20030403-branch:1.1.1.1.0.44
	cagney_framebase-20030330-mergepoint:1.1.1.1
	cagney_framebase-20030326-branch:1.1.1.1.0.42
	cagney_framebase-20030326-branchpoint:1.1.1.1
	cagney_lazyid-20030317-branch:1.1.1.1.0.40
	cagney_lazyid-20030317-branchpoint:1.1.1.1
	kettenis-i386newframe-20030316-mergepoint:1.1.1.1
	offbyone-20030313-branch:1.1.1.1.0.38
	offbyone-20030313-branchpoint:1.1.1.1
	kettenis-i386newframe-20030308-branch:1.1.1.1.0.36
	kettenis-i386newframe-20030308-branchpoint:1.1.1.1
	carlton_dictionary-20030305-merge:1.1.1.1
	cagney_offbyone-20030303-branch:1.1.1.1.0.34
	cagney_offbyone-20030303-branchpoint:1.1.1.1
	carlton_dictionary-20030207-merge:1.1.1.1
	interps-20030202-branch:1.1.1.1.0.32
	interps-20030202-branchpoint:1.1.1.1
	cagney-unwind-20030108-branch:1.1.1.1.0.30
	cagney-unwind-20030108-branchpoint:1.1.1.1
	carlton_dictionary-20021223-merge:1.1.1.1
	gdb_5_3-2002-12-12-release:1.1.1.1
	carlton_dictionary-20021115-merge:1.1.1.1
	kseitz_interps-20021105-merge:1.1.1.1
	kseitz_interps-20021103-merge:1.1.1.1
	drow-cplus-merge-20021020:1.1.1.1
	drow-cplus-merge-20021025:1.1.1.1
	carlton_dictionary-20021025-merge:1.1.1.1
	carlton_dictionary-20021011-merge:1.1.1.1
	drow-cplus-branch:1.1.1.1.0.28
	drow-cplus-branchpoint:1.1.1.1
	kseitz_interps-20020930-merge:1.1.1.1
	carlton_dictionary-20020927-merge:1.1.1.1
	carlton_dictionary-branch:1.1.1.1.0.26
	carlton_dictionary-20020920-branchpoint:1.1.1.1
	gdb_5_3-branch:1.1.1.1.0.24
	gdb_5_3-2002-09-04-branchpoint:1.1.1.1
	kseitz_interps-20020829-merge:1.1.1.1
	cagney_sysregs-20020825-branch:1.1.1.1.0.22
	cagney_sysregs-20020825-branchpoint:1.1.1.1
	readline_4_3-import-branch:1.1.1.1.0.20
	readline_4_3-import-branchpoint:1.1.1.1
	gdb_5_2_1-2002-07-23-release:1.1.1.1
	kseitz_interps-20020528-branch:1.1.1.1.0.18
	kseitz_interps-20020528-branchpoint:1.1.1.1
	cagney_regbuf-20020515-branch:1.1.1.1.0.16
	cagney_regbuf-20020515-branchpoint:1.1.1.1
	jimb-macro-020506-branch:1.1.1.1.0.14
	jimb-macro-020506-branchpoint:1.1.1.1
	gdb_5_2-2002-04-29-release:1.1.1.1
	gdb_5_2-branch:1.1.1.1.0.12
	gdb_5_2-2002-03-03-branchpoint:1.1.1.1
	gdb_5_1_1-2002-01-24-release:1.1.1.1
	gdb_5_1_0_1-2002-01-03-release:1.1.1.1
	gdb_5_1_0_1-2002-01-03-branch:1.1.1.1.0.10
	gdb_5_1_0_1-2002-01-03-branchpoint:1.1.1.1
	gdb_5_1-2001-11-21-release:1.1.1.1
	gdb_s390-2001-09-26-branch:1.1.1.1.0.8
	gdb_s390-2001-09-26-branchpoint:1.1.1.1
	gdb_5_1-2001-07-29-branch:1.1.1.1.0.6
	gdb_5_1-2001-07-29-branchpoint:1.1.1.1
	insight-precleanup-2001-01-01:1.1.1.1
	gdb-premipsmulti-2000-06-06-branch:1.1.1.1.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.1
	gdb_5_0-2000-05-19-release:1.1.1.1
	gdb_4_18_2-2000-05-18-release:1.1.1.1
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.1
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.1
	gdb_5_0-2000-04-10-branch:1.1.1.1.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.1
	repo-unification-2000-02-06:1.1.1.1
	gdb-2000-02-04:1.1.1.1
	gdb-2000-02-02:1.1.1.1
	gdb-2000-02-01:1.1.1.1
	gdb-2000-01-31:1.1.1.1
	gdb-2000-01-26:1.1.1.1
	gdb-2000-01-24:1.1.1.1
	gdb-2000-01-17:1.1.1.1
	gdb-2000-01-10:1.1.1.1
	gdb-2000-01-05:1.1.1.1
	gdb-1999-12-21:1.1.1.1
	gdb-1999-12-13:1.1.1.1
	gdb-1999-12-07:1.1.1.1
	gdb-1999-12-06:1.1.1.1
	gdb-1999-11-16:1.1.1.1
	gdb-1999-11-08:1.1.1.1
	gdb-1999-11-01:1.1.1.1
	gdb-1999-10-25:1.1.1.1
	gdb-1999-10-18:1.1.1.1
	gdb-1999-10-11:1.1.1.1
	SNAPSHOT:1.1.1;
locks; strict;
comment	@# @;
expand	@o@;


1.11
date	2013.01.01.06.41.38;	author brobecke;	state Exp;
branches;
next	1.10;

1.10
date	2012.01.04.08.28.13;	author brobecke;	state Exp;
branches;
next	1.9;

1.9
date	2011.01.01.15.34.02;	author brobecke;	state Exp;
branches
	1.9.4.1;
next	1.8;

1.8
date	2010.01.01.10.03.31;	author brobecke;	state Exp;
branches;
next	1.7;

1.7
date	2009.06.20.21.19.20;	author devans;	state Exp;
branches;
next	1.6;

1.6
date	2009.01.14.10.53.08;	author brobecke;	state Exp;
branches;
next	1.5;

1.5
date	2008.01.01.22.53.25;	author drow;	state Exp;
branches;
next	1.4;

1.4
date	2007.08.24.14.28.37;	author brobecke;	state Exp;
branches;
next	1.3;

1.3
date	2007.01.09.17.59.18;	author drow;	state Exp;
branches;
next	1.2;

1.2
date	2004.02.04.22.05.37;	author cagney;	state Exp;
branches;
next	1.1;

1.1
date	99.10.12.04.37.53;	author jsm;	state Exp;
branches
	1.1.1.1;
next	;

1.9.4.1
date	2012.01.06.04.54.51;	author brobecke;	state Exp;
branches;
next	;

1.1.1.1
date	99.10.12.04.37.53;	author jsm;	state Exp;
branches
	1.1.1.1.28.1;
next	;

1.1.1.1.28.1
date	2004.02.09.19.44.03;	author drow;	state Exp;
branches;
next	;


desc
@@


1.11
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@# Simulator main loop for m32rx. -*- C -*-
#
# Copyright 1996-2013 Free Software Foundation, Inc.
#
# This file is part of the GNU Simulators.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# Syntax:
# /bin/sh mainloop.in command
#
# Command is one of:
#
# init
# support
# extract-{simple,scache,pbb}
# {full,fast}-exec-{simple,scache,pbb}
#
# A target need only provide a "full" version of one of simple,scache,pbb.
# If the target wants it can also provide a fast version of same, or if
# the slow (full featured) version is `simple', then the fast version can be
# one of scache/pbb.
# A target can't provide more than this.

# ??? After a few more ports are done, revisit.
# Will eventually need to machine generate a lot of this.

case "x$1" in

xsupport)

cat <<EOF

/* Emit insns to write back the results of insns executed in parallel.
   SC points to a sufficient number of scache entries for the writeback
   handlers.
   SC1/ID1 is the first insn (left slot, lower address).
   SC2/ID2 is the second insn (right slot, higher address).  */

static INLINE void
emit_par_finish (SIM_CPU *current_cpu, PCADDR pc, SCACHE *sc,
		 SCACHE *sc1, const IDESC *id1, SCACHE *sc2, const IDESC *id2)
{
  ARGBUF *abuf;

  abuf = &sc->argbuf;
  id1 = id1->par_idesc;
  abuf->fields.write.abuf = &sc1->argbuf;
  @@cpu@@_fill_argbuf (current_cpu, abuf, id1, pc, 0);
  /* no need to set trace_p,profile_p */
#if 0 /* not currently needed for id2 since results written directly */
  abuf = &sc[1].argbuf;
  id2 = id2->par_idesc;
  abuf->fields.write.abuf = &sc2->argbuf;
  @@cpu@@_fill_argbuf (current_cpu, abuf, id2, pc + 2, 0);
  /* no need to set trace_p,profile_p */
#endif
}

static INLINE const IDESC *
emit_16 (SIM_CPU *current_cpu, PCADDR pc, CGEN_INSN_INT insn,
	 SCACHE *sc, int fast_p, int parallel_p)
{
  ARGBUF *abuf = &sc->argbuf;
  const IDESC *id = @@cpu@@_decode (current_cpu, pc, insn, insn, abuf);

  if (parallel_p)
    id = id->par_idesc;
  @@cpu@@_fill_argbuf (current_cpu, abuf, id, pc, fast_p);
  return id;
}

static INLINE const IDESC *
emit_full16 (SIM_CPU *current_cpu, PCADDR pc, CGEN_INSN_INT insn, SCACHE *sc,
	     int trace_p, int profile_p)
{
  const IDESC *id;

  @@cpu@@_emit_before (current_cpu, sc, pc, 1);
  id = emit_16 (current_cpu, pc, insn, sc + 1, 0, 0);
  @@cpu@@_emit_after (current_cpu, sc + 2, pc);
  sc[1].argbuf.trace_p = trace_p;
  sc[1].argbuf.profile_p = profile_p;
  return id;
}

static INLINE const IDESC *
emit_parallel (SIM_CPU *current_cpu, PCADDR pc, CGEN_INSN_INT insn,
	       SCACHE *sc, int fast_p)
{
  const IDESC *id,*id2;

  /* Emit both insns, then emit a finisher-upper.
     We speed things up by handling the second insn serially
     [not parallelly].  Then the writeback only has to deal
     with the first insn.  */
  /* ??? Revisit to handle exceptions right.  */

  /* FIXME: No need to handle this parallely if second is nop.  */
  id = emit_16 (current_cpu, pc, insn >> 16, sc, fast_p, 1);

  /* Note that this can never be a cti.  No cti's go in the S pipeline.  */
  id2 = emit_16 (current_cpu, pc + 2, insn & 0x7fff, sc + 1, fast_p, 0);

  /* Set sc/snc insns notion of where to skip to.  */
  if (IDESC_SKIP_P (id))
    SEM_SKIP_COMPILE (current_cpu, sc, 1);

  /* Emit code to finish executing the semantics
     (write back the results).  */
  emit_par_finish (current_cpu, pc, sc + 2, sc, id, sc + 1, id2);

  return id;
}

static INLINE const IDESC *
emit_full_parallel (SIM_CPU *current_cpu, PCADDR pc, CGEN_INSN_INT insn,
		    SCACHE *sc, int trace_p, int profile_p)
{
  const IDESC *id,*id2;

  /* Emit both insns, then emit a finisher-upper.
     We speed things up by handling the second insn serially
     [not parallelly].  Then the writeback only has to deal
     with the first insn.  */
  /* ??? Revisit to handle exceptions right.  */

  @@cpu@@_emit_before (current_cpu, sc, pc, 1);

  /* FIXME: No need to handle this parallelly if second is nop.  */
  id = emit_16 (current_cpu, pc, insn >> 16, sc + 1, 0, 1);
  sc[1].argbuf.trace_p = trace_p;
  sc[1].argbuf.profile_p = profile_p;

  @@cpu@@_emit_before (current_cpu, sc + 2, pc, 0);

  /* Note that this can never be a cti.  No cti's go in the S pipeline.  */
  id2 = emit_16 (current_cpu, pc + 2, insn & 0x7fff, sc + 3, 0, 0);
  sc[3].argbuf.trace_p = trace_p;
  sc[3].argbuf.profile_p = profile_p;

  /* Set sc/snc insns notion of where to skip to.  */
  if (IDESC_SKIP_P (id))
    SEM_SKIP_COMPILE (current_cpu, sc, 4);

  /* Emit code to finish executing the semantics
     (write back the results).  */
  emit_par_finish (current_cpu, pc, sc + 4, sc + 1, id, sc + 3, id2);

  @@cpu@@_emit_after (current_cpu, sc + 5, pc);

  return id;
}

static INLINE const IDESC *
emit_32 (SIM_CPU *current_cpu, PCADDR pc, CGEN_INSN_INT insn,
	 SCACHE *sc, int fast_p)
{
  ARGBUF *abuf = &sc->argbuf;
  const IDESC *id = @@cpu@@_decode (current_cpu, pc,
				  (USI) insn >> 16, insn, abuf);

  @@cpu@@_fill_argbuf (current_cpu, abuf, id, pc, fast_p);
  return id;
}

static INLINE const IDESC *
emit_full32 (SIM_CPU *current_cpu, PCADDR pc, CGEN_INSN_INT insn, SCACHE *sc,
	     int trace_p, int profile_p)
{
  const IDESC *id;

  @@cpu@@_emit_before (current_cpu, sc, pc, 1);
  id = emit_32 (current_cpu, pc, insn, sc + 1, 0);
  @@cpu@@_emit_after (current_cpu, sc + 2, pc);
  sc[1].argbuf.trace_p = trace_p;
  sc[1].argbuf.profile_p = profile_p;
  return id;
}

EOF

;;

xinit)

# Nothing needed.

;;

xextract-pbb)

# Inputs:  current_cpu, pc, sc, max_insns, FAST_P
# Outputs: sc, pc
# sc must be left pointing past the last created entry.
# pc must be left pointing past the last created entry.
# If the pbb is terminated by a cti insn, SET_CTI_VPC(sc) must be called
# to record the vpc of the cti insn.
# SET_INSN_COUNT(n) must be called to record number of real insns.

cat <<EOF
{
  const IDESC *idesc;
  int icount = 0;

  if ((pc & 3) != 0)
    {
      /* This occurs when single stepping and when compiling the not-taken
	 part of conditional branches.  */
      UHI insn = GETIMEMUHI (current_cpu, pc);
      int trace_p = PC_IN_TRACE_RANGE_P (current_cpu, pc);
      int profile_p = PC_IN_PROFILE_RANGE_P (current_cpu, pc);
      SCACHE *cti_sc; /* ??? tmp hack */

      /* A parallel insn isn't allowed here, but we don't mind nops.
	 ??? We need to wait until the insn is executed before signalling
	 the error, for situations where such signalling is wanted.  */
#if 0
      if ((insn & 0x8000) != 0
	  && (insn & 0x7fff) != 0x7000) /* parallel nops are ok */
	sim_engine_invalid_insn (current_cpu, pc, 0);
#endif

      /* Only emit before/after handlers if necessary.  */
      if (FAST_P || (! trace_p && ! profile_p))
	{
	  idesc = emit_16 (current_cpu, pc, insn & 0x7fff, sc, FAST_P, 0);
	  cti_sc = sc;
	  ++sc;
	  --max_insns;
	}
      else
	{
	  idesc = emit_full16 (current_cpu, pc, insn & 0x7fff, sc,
			       trace_p, profile_p);
	  cti_sc = sc + 1;
	  sc += 3;
	  max_insns -= 3;
	}
      ++icount;
      pc += 2;
      if (IDESC_CTI_P (idesc))
	{
	  SET_CTI_VPC (cti_sc);
	  goto Finish;
	}
    }

  /* There are two copies of the compiler: full(!fast) and fast.
     The "full" case emits before/after handlers for each insn.
     Having two copies of this code is a tradeoff, having one copy
     seemed a bit more difficult to read (due to constantly testing
     FAST_P).  ??? On the other hand, with address ranges we'll want to
     omit before/after handlers for unwanted insns.  Having separate loops
     for FAST/!FAST avoids constantly doing the test in the loop, but
     typically FAST_P is a constant and such tests will get optimized out.  */

  if (FAST_P)
    {
      while (max_insns > 0)
	{
	  USI insn = GETIMEMUSI (current_cpu, pc);
	  if ((SI) insn < 0)
	    {
	      /* 32 bit insn */
	      idesc = emit_32 (current_cpu, pc, insn, sc, 1);
	      ++sc;
	      --max_insns;
	      ++icount;
	      pc += 4;
	      if (IDESC_CTI_P (idesc))
		{
		  SET_CTI_VPC (sc - 1);
		  break;
		}
	    }
	  else
	    {
	      if ((insn & 0x8000) != 0) /* parallel? */
		{
		  int up_count;

		  if (((insn >> 16) & 0xfff0) == 0x10f0)
		    {
		      /* FIXME: No need to handle this sequentially if system
		         calls will be able to execute after second insn in
		         parallel. ( trap #num || insn ) */
		      /* insn */
		      idesc = emit_16 (current_cpu, pc + 2, insn & 0x7fff,
 				       sc, 1, 0);
		      /* trap */
		      emit_16 (current_cpu, pc, insn >> 16, sc + 1, 1, 0);
		      up_count = 2;
		    }
		  else
		    {
		      /* Yep.  Here's the "interesting" [sic] part.  */
		      idesc = emit_parallel (current_cpu, pc, insn, sc, 1);
		      up_count = 3;
		    }
		  sc += up_count;
		  max_insns -= up_count;
		  icount += 2;
		  pc += 4;
		  if (IDESC_CTI_P (idesc))
		    {
		      SET_CTI_VPC (sc - up_count);
		      break;
		    }
		}
	      else /* 2 serial 16 bit insns */
		{
		  idesc = emit_16 (current_cpu, pc, insn >> 16, sc, 1, 0);
		  ++sc;
		  --max_insns;
		  ++icount;
		  pc += 2;
		  if (IDESC_CTI_P (idesc))
		    {
		      SET_CTI_VPC (sc - 1);
		      break;
		    }
		  /* While we're guaranteed that there's room to extract the
		     insn, when single stepping we can't; the pbb must stop
		     after the first insn.  */
		  if (max_insns == 0)
		    break;
		  idesc = emit_16 (current_cpu, pc, insn & 0x7fff, sc, 1, 0);
		  ++sc;
		  --max_insns;
		  ++icount;
		  pc += 2;
		  if (IDESC_CTI_P (idesc))
		    {
		      SET_CTI_VPC (sc - 1);
		      break;
		    }
		}
	    }
	}
    }
  else /* ! FAST_P */
    {
      while (max_insns > 0)
	{
	  USI insn = GETIMEMUSI (current_cpu, pc);
	  int trace_p = PC_IN_TRACE_RANGE_P (current_cpu, pc);
	  int profile_p = PC_IN_PROFILE_RANGE_P (current_cpu, pc);
	  SCACHE *cti_sc; /* ??? tmp hack */
	  if ((SI) insn < 0)
	    {
	      /* 32 bit insn
		 Only emit before/after handlers if necessary.  */
	      if (trace_p || profile_p)
		{
		  idesc = emit_full32 (current_cpu, pc, insn, sc,
				       trace_p, profile_p);
		  cti_sc = sc + 1;
		  sc += 3;
		  max_insns -= 3;
		}
	      else
		{
		  idesc = emit_32 (current_cpu, pc, insn, sc, 0);
		  cti_sc = sc;
		  ++sc;
		  --max_insns;
		}
	      ++icount;
	      pc += 4;
	      if (IDESC_CTI_P (idesc))
		{
		  SET_CTI_VPC (cti_sc);
		  break;
		}
	    }
	  else
	    {
	      if ((insn & 0x8000) != 0) /* parallel? */
		{
		  /* Yep.  Here's the "interesting" [sic] part.
		     Only emit before/after handlers if necessary.  */
		  if (trace_p || profile_p)
		    {
		      if (((insn >> 16) & 0xfff0) == 0x10f0)
			{
			  /* FIXME: No need to handle this sequentially if
			     system calls will be able to execute after second
			     insn in parallel. ( trap #num || insn ) */
			  /* insn */
			  idesc = emit_full16 (current_cpu, pc + 2,
					       insn & 0x7fff, sc, 0, 0);
			  /* trap */
			  emit_full16 (current_cpu, pc, insn >> 16, sc + 3,
				       0, 0);
			}
		      else
			{
		          idesc = emit_full_parallel (current_cpu, pc, insn,
						      sc, trace_p, profile_p);
			}
		      cti_sc = sc + 1;
		      sc += 6;
		      max_insns -= 6;
		    }
		  else
		    {
		      int up_count;

		      if (((insn >> 16) & 0xfff0) == 0x10f0)
			{
                          /* FIXME: No need to handle this sequentially if
                             system calls will be able to execute after second
                             insn in parallel. ( trap #num || insn ) */
                          /* insn */
                          idesc = emit_16 (current_cpu, pc + 2, insn & 0x7fff,
                                           sc, 0, 0);
                          /* trap */
                          emit_16 (current_cpu, pc, insn >> 16, sc + 1, 0, 0);
                          up_count = 2;
			}
		      else
			{
		          idesc = emit_parallel (current_cpu, pc, insn, sc, 0);
                          up_count = 3;
			}
		      cti_sc = sc;
		      sc += up_count;
		      max_insns -= up_count;
		    }
		  icount += 2;
		  pc += 4;
		  if (IDESC_CTI_P (idesc))
		    {
		      SET_CTI_VPC (cti_sc);
		      break;
		    }
		}
	      else /* 2 serial 16 bit insns */
		{
		  /* Only emit before/after handlers if necessary.  */
		  if (trace_p || profile_p)
		    {
		      idesc = emit_full16 (current_cpu, pc, insn >> 16, sc,
					   trace_p, profile_p);
		      cti_sc = sc + 1;
		      sc += 3;
		      max_insns -= 3;
		    }
		  else
		    {
		      idesc = emit_16 (current_cpu, pc, insn >> 16, sc, 0, 0);
		      cti_sc = sc;
		      ++sc;
		      --max_insns;
		    }
		  ++icount;
		  pc += 2;
		  if (IDESC_CTI_P (idesc))
		    {
		      SET_CTI_VPC (cti_sc);
		      break;
		    }
		  /* While we're guaranteed that there's room to extract the
		     insn, when single stepping we can't; the pbb must stop
		     after the first insn.  */
		  if (max_insns <= 0)
		    break;
		  /* Use the same trace/profile address for the 2nd insn.
		     Saves us having to compute it and they come in pairs
		     anyway (e.g. can never branch to the 2nd insn).  */
		  if (trace_p || profile_p)
		    {
		      idesc = emit_full16 (current_cpu, pc, insn & 0x7fff, sc,
					   trace_p, profile_p);
		      cti_sc = sc + 1;
		      sc += 3;
		      max_insns -= 3;
		    }
		  else
		    {
		      idesc = emit_16 (current_cpu, pc, insn & 0x7fff, sc, 0, 0);
		      cti_sc = sc;
		      ++sc;
		      --max_insns;
		    }
		  ++icount;
		  pc += 2;
		  if (IDESC_CTI_P (idesc))
		    {
		      SET_CTI_VPC (cti_sc);
		      break;
		    }
		}
	    }
	}
    }

 Finish:
  SET_INSN_COUNT (icount);
}
EOF

;;

xfull-exec-pbb)

# Inputs: current_cpu, vpc, FAST_P
# Outputs: vpc
# vpc is the virtual program counter.

cat <<EOF
#define DEFINE_SWITCH
#include "semx-switch.c"
EOF

;;

*)
  echo "Invalid argument to mainloop.in: $1" >&2
  exit 1
  ;;

esac
@


1.10
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 1
a3 1
# Copyright 1996-1998, 2004, 2007-2012 Free Software Foundation, Inc.
@


1.9
log
@run copyright.sh for 2011.
@
text
@d3 1
a3 2
# Copyright 1996, 1997, 1998, 2004, 2007, 2008, 2009, 2010, 2011
# Free Software Foundation, Inc.
@


1.9.4.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d3 2
a4 1
# Copyright 1996-1998, 2004, 2007-2012 Free Software Foundation, Inc.
@


1.8
log
@Update copyright notices to add year 2010.
@
text
@d3 1
a3 1
# Copyright 1996, 1997, 1998, 2004, 2007, 2008, 2009, 2010
@


1.7
log
@	* mloop.in: Add missing # comment marker.
	* mloop2.in: Ditto.
	* mloopx.in: Ditto.
@
text
@d3 1
a3 1
# Copyright 1996, 1997, 1998, 2004, 2007, 2008, 2009
@


1.6
log
@        Update the copyright notice of some of the files I missed
        in the previous copyright update.
@
text
@d4 1
a4 1
  Free Software Foundation, Inc.
@


1.5
log
@	Updated copyright notices for most files.
@
text
@d3 2
a4 1
# Copyright 1996, 1997, 1998, 2004, 2007, 2008 Free Software Foundation, Inc.
@


1.4
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d3 1
a3 1
# Copyright 1996, 1997, 1998, 2004, 2007 Free Software Foundation, Inc.
@


1.3
log
@Copyright updates for 2007.
@
text
@d9 2
a10 2
# the Free Software Foundation; either version 2, or (at your option)
# any later version.
d17 2
a18 3
# You should have received a copy of the GNU General Public License along
# with this program; if not, write to the Free Software Foundation, Inc.,
# 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
@


1.2
log
@2004-02-04  Andrew Cagney  <cagney@@redhat.com>

	Committed by Andrew Cagney.
	* mloopx.in: Update copyright.
	(xextract-pbb): Fixed trap for system calls operation in parallel.
	* mloop2.in (xextract-pbb): Ditto.
@
text
@d3 1
a3 1
# Copyright 1996, 1997, 1998, 2004 Free Software Foundation, Inc.
@


1.1
log
@Initial revision
@
text
@d2 2
a3 1
# Copyright (C) 1996, 1997, 1998 Free Software Foundation, Inc.
d293 22
a314 4
		  /* Yep.  Here's the "interesting" [sic] part.  */
		  idesc = emit_parallel (current_cpu, pc, insn, sc, 1);
		  sc += 3;
		  max_insns -= 3;
d319 1
a319 1
		      SET_CTI_VPC (sc - 3);
d397 17
a413 2
		      idesc = emit_full_parallel (current_cpu, pc, insn, sc,
						  trace_p, profile_p);
d420 19
a438 1
		      idesc = emit_parallel (current_cpu, pc, insn, sc, 0);
d440 2
a441 2
		      sc += 3;
		      max_insns -= 3;
@


1.1.1.1
log
@import gdb-1999-10-11 snapshot
@
text
@@


1.1.1.1.28.1
log
@Merge drow-cplus-merge-20040208 to drow-cplus-branch.
@
text
@d2 1
a2 2
#
# Copyright 1996, 1997, 1998, 2004 Free Software Foundation, Inc.
d292 4
a295 22
		  int up_count;

		  if (((insn >> 16) & 0xfff0) == 0x10f0)
		    {
		      /* FIXME: No need to handle this sequentially if system
		         calls will be able to execute after second insn in
		         parallel. ( trap #num || insn ) */
		      /* insn */
		      idesc = emit_16 (current_cpu, pc + 2, insn & 0x7fff,
 				       sc, 1, 0);
		      /* trap */
		      emit_16 (current_cpu, pc, insn >> 16, sc + 1, 1, 0);
		      up_count = 2;
		    }
		  else
		    {
		      /* Yep.  Here's the "interesting" [sic] part.  */
		      idesc = emit_parallel (current_cpu, pc, insn, sc, 1);
		      up_count = 3;
		    }
		  sc += up_count;
		  max_insns -= up_count;
d300 1
a300 1
		      SET_CTI_VPC (sc - up_count);
d378 2
a379 17
		      if (((insn >> 16) & 0xfff0) == 0x10f0)
			{
			  /* FIXME: No need to handle this sequentially if
			     system calls will be able to execute after second
			     insn in parallel. ( trap #num || insn ) */
			  /* insn */
			  idesc = emit_full16 (current_cpu, pc + 2,
					       insn & 0x7fff, sc, 0, 0);
			  /* trap */
			  emit_full16 (current_cpu, pc, insn >> 16, sc + 3,
				       0, 0);
			}
		      else
			{
		          idesc = emit_full_parallel (current_cpu, pc, insn,
						      sc, trace_p, profile_p);
			}
d386 1
a386 19
		      int up_count;

		      if (((insn >> 16) & 0xfff0) == 0x10f0)
			{
                          /* FIXME: No need to handle this sequentially if
                             system calls will be able to execute after second
                             insn in parallel. ( trap #num || insn ) */
                          /* insn */
                          idesc = emit_16 (current_cpu, pc + 2, insn & 0x7fff,
                                           sc, 0, 0);
                          /* trap */
                          emit_16 (current_cpu, pc, insn >> 16, sc + 1, 0, 0);
                          up_count = 2;
			}
		      else
			{
		          idesc = emit_parallel (current_cpu, pc, insn, sc, 0);
                          up_count = 3;
			}
d388 2
a389 2
		      sc += up_count;
		      max_insns -= up_count;
@

