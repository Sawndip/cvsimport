head	1.15;
access;
symbols
	gdb_7_6_1-2013-08-30-release:1.15
	gdb_7_6-2013-04-26-release:1.15
	gdb_7_6-branch:1.15.0.2
	gdb_7_6-2013-03-12-branchpoint:1.15
	gdb_7_5_1-2012-11-29-release:1.13
	gdb_7_5-2012-08-17-release:1.13
	gdb_7_5-branch:1.13.0.2
	gdb_7_5-2012-07-18-branchpoint:1.13
	gdb_7_4_1-2012-04-26-release:1.12.8.1
	gdb_7_4-2012-01-24-release:1.12.8.1
	gdb_7_4-branch:1.12.0.8
	gdb_7_4-2011-12-13-branchpoint:1.12
	gdb_7_3_1-2011-09-04-release:1.12
	gdb_7_3-2011-07-26-release:1.12
	gdb_7_3-branch:1.12.0.6
	gdb_7_3-2011-04-01-branchpoint:1.12
	gdb_7_2-2010-09-02-release:1.12
	gdb_7_2-branch:1.12.0.4
	gdb_7_2-2010-07-07-branchpoint:1.12
	gdb_7_1-2010-03-18-release:1.12
	gdb_7_1-branch:1.12.0.2
	gdb_7_1-2010-02-18-branchpoint:1.12
	gdb_7_0_1-2009-12-22-release:1.7
	gdb_7_0-2009-10-06-release:1.7
	gdb_7_0-branch:1.7.0.22
	gdb_7_0-2009-09-16-branchpoint:1.7
	arc-sim-20090309:1.7
	msnyder-checkpoint-072509-branch:1.7.0.20
	msnyder-checkpoint-072509-branchpoint:1.7
	arc-insight_6_8-branch:1.7.0.18
	arc-insight_6_8-branchpoint:1.7
	insight_6_8-branch:1.7.0.16
	insight_6_8-branchpoint:1.7
	reverse-20081226-branch:1.7.0.14
	reverse-20081226-branchpoint:1.7
	multiprocess-20081120-branch:1.7.0.12
	multiprocess-20081120-branchpoint:1.7
	reverse-20080930-branch:1.7.0.10
	reverse-20080930-branchpoint:1.7
	reverse-20080717-branch:1.7.0.8
	reverse-20080717-branchpoint:1.7
	msnyder-reverse-20080609-branch:1.7.0.6
	msnyder-reverse-20080609-branchpoint:1.7
	drow-reverse-20070409-branch:1.6.0.50
	drow-reverse-20070409-branchpoint:1.6
	gdb_6_8-2008-03-27-release:1.7
	gdb_6_8-branch:1.7.0.4
	gdb_6_8-2008-02-26-branchpoint:1.7
	gdb_6_7_1-2007-10-29-release:1.7
	gdb_6_7-2007-10-10-release:1.7
	gdb_6_7-branch:1.7.0.2
	gdb_6_7-2007-09-07-branchpoint:1.7
	insight_6_6-20070208-release:1.6
	gdb_6_6-2006-12-18-release:1.6
	gdb_6_6-branch:1.6.0.48
	gdb_6_6-2006-11-15-branchpoint:1.6
	insight_6_5-20061003-release:1.6
	gdb-csl-symbian-6_4_50_20060226-12:1.6
	gdb-csl-sourcerygxx-3_4_4-25:1.6
	nickrob-async-20060828-mergepoint:1.6
	gdb-csl-symbian-6_4_50_20060226-11:1.6
	gdb-csl-sourcerygxx-4_1-17:1.6
	gdb-csl-20060226-branch-local-2:1.6
	gdb-csl-sourcerygxx-4_1-14:1.6
	gdb-csl-sourcerygxx-4_1-13:1.6
	gdb-csl-sourcerygxx-4_1-12:1.6
	gdb-csl-sourcerygxx-3_4_4-21:1.6
	gdb_6_5-20060621-release:1.6
	gdb-csl-sourcerygxx-4_1-9:1.6
	gdb-csl-sourcerygxx-4_1-8:1.6
	gdb-csl-sourcerygxx-4_1-7:1.6
	gdb-csl-arm-2006q1-6:1.6
	gdb-csl-sourcerygxx-4_1-6:1.6
	gdb-csl-symbian-6_4_50_20060226-10:1.6
	gdb-csl-symbian-6_4_50_20060226-9:1.6
	gdb-csl-symbian-6_4_50_20060226-8:1.6
	gdb-csl-coldfire-4_1-11:1.6
	gdb-csl-sourcerygxx-3_4_4-19:1.6
	gdb-csl-coldfire-4_1-10:1.6
	gdb_6_5-branch:1.6.0.46
	gdb_6_5-2006-05-14-branchpoint:1.6
	gdb-csl-sourcerygxx-4_1-5:1.6
	nickrob-async-20060513-branch:1.6.0.44
	nickrob-async-20060513-branchpoint:1.6
	gdb-csl-sourcerygxx-4_1-4:1.6
	msnyder-reverse-20060502-branch:1.6.0.42
	msnyder-reverse-20060502-branchpoint:1.6
	gdb-csl-morpho-4_1-4:1.6
	gdb-csl-sourcerygxx-3_4_4-17:1.6
	readline_5_1-import-branch:1.6.0.40
	readline_5_1-import-branchpoint:1.6
	gdb-csl-20060226-branch-merge-to-csl-symbian-1:1.6
	gdb-csl-symbian-20060226-branch:1.6.0.38
	gdb-csl-symbian-20060226-branchpoint:1.6
	gdb-csl-20060226-branch-merge-to-csl-local-1:1.6
	msnyder-reverse-20060331-branch:1.6.0.36
	msnyder-reverse-20060331-branchpoint:1.6
	gdb-csl-available-20060303-branch:1.6.0.34
	gdb-csl-available-20060303-branchpoint:1.6
	gdb-csl-20060226-branch:1.6.0.32
	gdb-csl-20060226-branchpoint:1.6
	gdb_6_4-20051202-release:1.6
	msnyder-fork-checkpoint-branch:1.6.0.30
	msnyder-fork-checkpoint-branchpoint:1.6
	gdb-csl-gxxpro-6_3-branch:1.6.0.28
	gdb-csl-gxxpro-6_3-branchpoint:1.6
	gdb_6_4-branch:1.6.0.26
	gdb_6_4-2005-11-01-branchpoint:1.6
	gdb-csl-arm-20051020-branch:1.6.0.24
	gdb-csl-arm-20051020-branchpoint:1.6
	msnyder-tracepoint-checkpoint-branch:1.6.0.22
	msnyder-tracepoint-checkpoint-branchpoint:1.6
	gdb-csl-arm-20050325-2005-q1b:1.6
	gdb-csl-arm-20050325-2005-q1a:1.6
	csl-arm-20050325-branch:1.6.0.20
	csl-arm-20050325-branchpoint:1.6
	gdb_6_3-20041109-release:1.6
	gdb_6_3-branch:1.6.0.16
	gdb_6_3-20041019-branchpoint:1.6
	drow_intercu-merge-20040921:1.6
	drow_intercu-merge-20040915:1.6
	jimb-gdb_6_2-e500-branch:1.6.0.18
	jimb-gdb_6_2-e500-branchpoint:1.6
	gdb_6_2-20040730-release:1.6
	gdb_6_2-branch:1.6.0.14
	gdb_6_2-2004-07-10-gmt-branchpoint:1.6
	gdb_6_1_1-20040616-release:1.6
	gdb_6_1-2004-04-05-release:1.6
	drow_intercu-merge-20040402:1.6
	drow_intercu-merge-20040327:1.6
	ezannoni_pie-20040323-branch:1.6.0.12
	ezannoni_pie-20040323-branchpoint:1.6
	cagney_tramp-20040321-mergepoint:1.6
	cagney_tramp-20040309-branch:1.6.0.10
	cagney_tramp-20040309-branchpoint:1.6
	gdb_6_1-branch:1.6.0.8
	gdb_6_1-2004-03-01-gmt-branchpoint:1.6
	drow_intercu-20040221-branch:1.6.0.6
	drow_intercu-20040221-branchpoint:1.6
	cagney_bfdfile-20040213-branch:1.6.0.4
	cagney_bfdfile-20040213-branchpoint:1.6
	drow-cplus-merge-20040208:1.6
	carlton_dictionary-20040126-merge:1.6
	cagney_bigcore-20040122-branch:1.6.0.2
	cagney_bigcore-20040122-branchpoint:1.6
	drow-cplus-merge-20040113:1.6
	drow-cplus-merge-20031224:1.6
	drow-cplus-merge-20031220:1.6
	carlton_dictionary-20031215-merge:1.6
	drow-cplus-merge-20031214:1.6
	carlton-dictionary-20031111-merge:1.5
	gdb_6_0-2003-10-04-release:1.5
	kettenis_sparc-20030918-branch:1.5.0.40
	kettenis_sparc-20030918-branchpoint:1.5
	carlton_dictionary-20030917-merge:1.5
	ezannoni_pie-20030916-branchpoint:1.5
	ezannoni_pie-20030916-branch:1.5.0.38
	cagney_x86i386-20030821-branch:1.5.0.36
	cagney_x86i386-20030821-branchpoint:1.5
	carlton_dictionary-20030805-merge:1.5
	carlton_dictionary-20030627-merge:1.5
	gdb_6_0-branch:1.5.0.34
	gdb_6_0-2003-06-23-branchpoint:1.5
	jimb-ppc64-linux-20030613-branch:1.5.0.32
	jimb-ppc64-linux-20030613-branchpoint:1.5
	cagney_convert-20030606-branch:1.5.0.30
	cagney_convert-20030606-branchpoint:1.5
	cagney_writestrings-20030508-branch:1.5.0.28
	cagney_writestrings-20030508-branchpoint:1.5
	jimb-ppc64-linux-20030528-branch:1.5.0.26
	jimb-ppc64-linux-20030528-branchpoint:1.5
	carlton_dictionary-20030523-merge:1.5
	cagney_fileio-20030521-branch:1.5.0.24
	cagney_fileio-20030521-branchpoint:1.5
	kettenis_i386newframe-20030517-mergepoint:1.5
	jimb-ppc64-linux-20030509-branch:1.5.0.22
	jimb-ppc64-linux-20030509-branchpoint:1.5
	kettenis_i386newframe-20030504-mergepoint:1.5
	carlton_dictionary-20030430-merge:1.5
	kettenis_i386newframe-20030419-branch:1.5.0.20
	kettenis_i386newframe-20030419-branchpoint:1.5
	carlton_dictionary-20030416-merge:1.5
	cagney_frameaddr-20030409-mergepoint:1.5
	kettenis_i386newframe-20030406-branch:1.5.0.18
	kettenis_i386newframe-20030406-branchpoint:1.5
	cagney_frameaddr-20030403-branchpoint:1.5
	cagney_frameaddr-20030403-branch:1.5.0.16
	cagney_framebase-20030330-mergepoint:1.5
	cagney_framebase-20030326-branch:1.5.0.14
	cagney_framebase-20030326-branchpoint:1.5
	cagney_lazyid-20030317-branch:1.5.0.12
	cagney_lazyid-20030317-branchpoint:1.5
	kettenis-i386newframe-20030316-mergepoint:1.5
	offbyone-20030313-branch:1.5.0.10
	offbyone-20030313-branchpoint:1.5
	kettenis-i386newframe-20030308-branch:1.5.0.8
	kettenis-i386newframe-20030308-branchpoint:1.5
	carlton_dictionary-20030305-merge:1.5
	cagney_offbyone-20030303-branch:1.5.0.6
	cagney_offbyone-20030303-branchpoint:1.5
	carlton_dictionary-20030207-merge:1.5
	interps-20030202-branch:1.5.0.4
	interps-20030202-branchpoint:1.5
	cagney-unwind-20030108-branch:1.5.0.2
	cagney-unwind-20030108-branchpoint:1.5
	carlton_dictionary-20021223-merge:1.5
	gdb_5_3-2002-12-12-release:1.4
	carlton_dictionary-20021115-merge:1.4
	kseitz_interps-20021105-merge:1.4
	kseitz_interps-20021103-merge:1.4
	drow-cplus-merge-20021020:1.4
	drow-cplus-merge-20021025:1.4
	carlton_dictionary-20021025-merge:1.4
	carlton_dictionary-20021011-merge:1.4
	drow-cplus-branch:1.4.0.18
	drow-cplus-branchpoint:1.4
	kseitz_interps-20020930-merge:1.4
	carlton_dictionary-20020927-merge:1.4
	carlton_dictionary-branch:1.4.0.16
	carlton_dictionary-20020920-branchpoint:1.4
	gdb_5_3-branch:1.4.0.14
	gdb_5_3-2002-09-04-branchpoint:1.4
	kseitz_interps-20020829-merge:1.4
	cagney_sysregs-20020825-branch:1.4.0.12
	cagney_sysregs-20020825-branchpoint:1.4
	readline_4_3-import-branch:1.4.0.10
	readline_4_3-import-branchpoint:1.4
	gdb_5_2_1-2002-07-23-release:1.4
	kseitz_interps-20020528-branch:1.4.0.8
	kseitz_interps-20020528-branchpoint:1.4
	cagney_regbuf-20020515-branch:1.4.0.6
	cagney_regbuf-20020515-branchpoint:1.4
	jimb-macro-020506-branch:1.4.0.4
	jimb-macro-020506-branchpoint:1.4
	gdb_5_2-2002-04-29-release:1.4
	gdb_5_2-branch:1.4.0.2
	gdb_5_2-2002-03-03-branchpoint:1.4
	gdb_5_1_1-2002-01-24-release:1.3
	gdb_5_1_0_1-2002-01-03-release:1.3
	gdb_5_1_0_1-2002-01-03-branch:1.3.0.6
	gdb_5_1_0_1-2002-01-03-branchpoint:1.3
	gdb_5_1-2001-11-21-release:1.3
	gdb_s390-2001-09-26-branch:1.3.0.4
	gdb_s390-2001-09-26-branchpoint:1.3
	gdb_5_1-2001-07-29-branch:1.3.0.2
	gdb_5_1-2001-07-29-branchpoint:1.3
	insight-precleanup-2001-01-01:1.2
	gdb-premipsmulti-2000-06-06-branch:1.1.1.3.0.4
	gdb-premipsmulti-2000-06-06-branchpoint:1.1.1.3
	gdb_5_0-2000-05-19-release:1.1.1.3
	gdb_4_18_2-2000-05-18-release:1.1.1.3
	gdb_4_95_1-2000-05-11-snapshot:1.1.1.3
	gdb_4_95_0-2000-04-27-snapshot:1.1.1.3
	gdb_5_0-2000-04-10-branch:1.1.1.3.0.2
	gdb_5_0-2000-04-10-branchpoint:1.1.1.3
	repo-unification-2000-02-06:1.1.1.3
	gdb-2000-02-04:1.1.1.3
	gdb-2000-02-02:1.1.1.3
	gdb-2000-02-01:1.1.1.3
	gdb-2000-01-31:1.1.1.3
	gdb-2000-01-26:1.1.1.3
	gdb-2000-01-24:1.1.1.3
	gdb-2000-01-17:1.1.1.3
	gdb-2000-01-10:1.1.1.3
	gdb-2000-01-05:1.1.1.3
	gdb-1999-12-21:1.1.1.3
	gdb-1999-12-13:1.1.1.3
	gdb-1999-12-07:1.1.1.3
	gdb-1999-12-06:1.1.1.3
	gdb-1999-11-16:1.1.1.3
	gdb-1999-11-08:1.1.1.3
	gdb-1999-11-01:1.1.1.3
	gdb-1999-10-25:1.1.1.3
	gdb-1999-10-18:1.1.1.3
	gdb-1999-10-11:1.1.1.3
	gdb-1999-10-04:1.1.1.3
	gdb-1999-09-28:1.1.1.3
	gdb-1999-09-21:1.1.1.3
	gdb-1999-09-13:1.1.1.3
	gdb-1999-09-08:1.1.1.3
	gdb-1999-08-30:1.1.1.3
	gdb-1999-08-23:1.1.1.3
	gdb-1999-08-16:1.1.1.3
	gdb-1999-08-09:1.1.1.3
	gdb-1999-08-02:1.1.1.2
	gdb-1999-07-26:1.1.1.2
	gdb-1999-07-19:1.1.1.2
	gdb-1999-07-12:1.1.1.2
	gdb-post-reformat-19990707:1.1.1.2
	gdb-1999-07-07-post-reformat-snapshot:1.1.1.2
	gdb-pre-reformat-19990707:1.1.1.2
	gdb-1999-07-07:1.1.1.2
	gdb-1999-07-05:1.1.1.2
	gdb-1999-06-28:1.1.1.2
	gdb-1999-06-21:1.1.1.2
	gdb-1999-06-14:1.1.1.2
	gdb-1999-06-07:1.1.1.2
	gdb-1999-06-01:1.1.1.2
	gdb-4_18-branch:1.1.1.1.0.2
	gdb-4_18-release:1.1.1.1
	gdb-1999-05-25:1.1.1.2
	gdb-1999-05-19:1.1.1.2
	gdb-1999-05-10:1.1.1.2
	gdb-19990504:1.1.1.2
	gdb-19990422:1.1.1.2
	SNAPSHOT:1.1.1
	gdb-4_18:1.1.1.1
	GDB_4_18:1.1.1;
locks; strict;
comment	@ * @;
expand	@o@;


1.15
date	2013.01.01.06.41.38;	author brobecke;	state Exp;
branches;
next	1.14;

1.14
date	2012.12.19.07.18.19;	author brobecke;	state Exp;
branches;
next	1.13;

1.13
date	2012.01.04.08.28.12;	author brobecke;	state Exp;
branches;
next	1.12;

1.12
date	2010.02.12.02.44.25;	author devans;	state Exp;
branches
	1.12.8.1;
next	1.11;

1.11
date	2010.01.02.19.09.20;	author devans;	state Exp;
branches;
next	1.10;

1.10
date	2009.11.23.09.37.08;	author devans;	state Exp;
branches;
next	1.9;

1.9
date	2009.11.23.04.12.17;	author devans;	state Exp;
branches;
next	1.8;

1.8
date	2009.11.04.05.06.59;	author devans;	state Exp;
branches;
next	1.7;

1.7
date	2007.08.24.14.28.37;	author brobecke;	state Exp;
branches;
next	1.6;

1.6
date	2003.12.11.11.33.44;	author nickc;	state Exp;
branches;
next	1.5;

1.5
date	2002.12.20.02.26.34;	author devans;	state Exp;
branches;
next	1.4;

1.4
date	2001.11.14.19.51.40;	author brolley;	state Exp;
branches
	1.4.16.1
	1.4.18.1;
next	1.3;

1.3
date	2001.03.05.16.05.38;	author brolley;	state Exp;
branches;
next	1.2;

1.2
date	2000.08.28.18.20.29;	author brolley;	state Exp;
branches;
next	1.1;

1.1
date	99.04.16.01.35.06;	author shebs;	state Exp;
branches
	1.1.1.1;
next	;

1.12.8.1
date	2012.01.06.04.54.51;	author brobecke;	state Exp;
branches;
next	;

1.4.16.1
date	2002.12.23.19.39.56;	author carlton;	state Exp;
branches;
next	1.4.16.2;

1.4.16.2
date	2003.12.16.00.01.23;	author carlton;	state Exp;
branches;
next	;

1.4.18.1
date	2003.12.14.20.28.25;	author drow;	state Exp;
branches;
next	;

1.1.1.1
date	99.04.16.01.35.06;	author shebs;	state Exp;
branches;
next	1.1.1.2;

1.1.1.2
date	99.04.26.18.32.53;	author shebs;	state Exp;
branches;
next	1.1.1.3;

1.1.1.3
date	99.08.09.21.36.22;	author jsm;	state Exp;
branches;
next	;


desc
@@


1.15
log
@Update years in copyright notice for the GDB files.

Two modifications:
  1. The addition of 2013 to the copyright year range for every file;
  2. The use of a single year range, instead of potentially multiple
     year ranges, as approved by the FSF.
@
text
@/* Simulator instruction decoder for m32rbf.

THIS FILE IS MACHINE GENERATED WITH CGEN.

Copyright 1996-2013 Free Software Foundation, Inc.

This file is part of the GNU simulators.

   This file is free software; you can redistribute it and/or modify
   it under the terms of the GNU General Public License as published by
   the Free Software Foundation; either version 3, or (at your option)
   any later version.

   It is distributed in the hope that it will be useful, but WITHOUT
   ANY WARRANTY; without even the implied warranty of MERCHANTABILITY
   or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public
   License for more details.

   You should have received a copy of the GNU General Public License along
   with this program; if not, see <http://www.gnu.org/licenses/>.

*/

#define WANT_CPU m32rbf
#define WANT_CPU_M32RBF

#include "sim-main.h"
#include "sim-assert.h"

/* The instruction descriptor array.
   This is computed at runtime.  Space for it is not malloc'd to save a
   teensy bit of cpu in the decoder.  Moving it to malloc space is trivial
   but won't be done until necessary (we don't currently support the runtime
   addition of instructions nor an SMP machine with different cpus).  */
static IDESC m32rbf_insn_data[M32RBF_INSN__MAX];

/* Commas between elements are contained in the macros.
   Some of these are conditionally compiled out.  */

static const struct insn_sem m32rbf_insn_sem[] =
{
  { VIRTUAL_INSN_X_INVALID, M32RBF_INSN_X_INVALID, M32RBF_SFMT_EMPTY },
  { VIRTUAL_INSN_X_AFTER, M32RBF_INSN_X_AFTER, M32RBF_SFMT_EMPTY },
  { VIRTUAL_INSN_X_BEFORE, M32RBF_INSN_X_BEFORE, M32RBF_SFMT_EMPTY },
  { VIRTUAL_INSN_X_CTI_CHAIN, M32RBF_INSN_X_CTI_CHAIN, M32RBF_SFMT_EMPTY },
  { VIRTUAL_INSN_X_CHAIN, M32RBF_INSN_X_CHAIN, M32RBF_SFMT_EMPTY },
  { VIRTUAL_INSN_X_BEGIN, M32RBF_INSN_X_BEGIN, M32RBF_SFMT_EMPTY },
  { M32R_INSN_ADD, M32RBF_INSN_ADD, M32RBF_SFMT_ADD },
  { M32R_INSN_ADD3, M32RBF_INSN_ADD3, M32RBF_SFMT_ADD3 },
  { M32R_INSN_AND, M32RBF_INSN_AND, M32RBF_SFMT_ADD },
  { M32R_INSN_AND3, M32RBF_INSN_AND3, M32RBF_SFMT_AND3 },
  { M32R_INSN_OR, M32RBF_INSN_OR, M32RBF_SFMT_ADD },
  { M32R_INSN_OR3, M32RBF_INSN_OR3, M32RBF_SFMT_OR3 },
  { M32R_INSN_XOR, M32RBF_INSN_XOR, M32RBF_SFMT_ADD },
  { M32R_INSN_XOR3, M32RBF_INSN_XOR3, M32RBF_SFMT_AND3 },
  { M32R_INSN_ADDI, M32RBF_INSN_ADDI, M32RBF_SFMT_ADDI },
  { M32R_INSN_ADDV, M32RBF_INSN_ADDV, M32RBF_SFMT_ADDV },
  { M32R_INSN_ADDV3, M32RBF_INSN_ADDV3, M32RBF_SFMT_ADDV3 },
  { M32R_INSN_ADDX, M32RBF_INSN_ADDX, M32RBF_SFMT_ADDX },
  { M32R_INSN_BC8, M32RBF_INSN_BC8, M32RBF_SFMT_BC8 },
  { M32R_INSN_BC24, M32RBF_INSN_BC24, M32RBF_SFMT_BC24 },
  { M32R_INSN_BEQ, M32RBF_INSN_BEQ, M32RBF_SFMT_BEQ },
  { M32R_INSN_BEQZ, M32RBF_INSN_BEQZ, M32RBF_SFMT_BEQZ },
  { M32R_INSN_BGEZ, M32RBF_INSN_BGEZ, M32RBF_SFMT_BEQZ },
  { M32R_INSN_BGTZ, M32RBF_INSN_BGTZ, M32RBF_SFMT_BEQZ },
  { M32R_INSN_BLEZ, M32RBF_INSN_BLEZ, M32RBF_SFMT_BEQZ },
  { M32R_INSN_BLTZ, M32RBF_INSN_BLTZ, M32RBF_SFMT_BEQZ },
  { M32R_INSN_BNEZ, M32RBF_INSN_BNEZ, M32RBF_SFMT_BEQZ },
  { M32R_INSN_BL8, M32RBF_INSN_BL8, M32RBF_SFMT_BL8 },
  { M32R_INSN_BL24, M32RBF_INSN_BL24, M32RBF_SFMT_BL24 },
  { M32R_INSN_BNC8, M32RBF_INSN_BNC8, M32RBF_SFMT_BC8 },
  { M32R_INSN_BNC24, M32RBF_INSN_BNC24, M32RBF_SFMT_BC24 },
  { M32R_INSN_BNE, M32RBF_INSN_BNE, M32RBF_SFMT_BEQ },
  { M32R_INSN_BRA8, M32RBF_INSN_BRA8, M32RBF_SFMT_BRA8 },
  { M32R_INSN_BRA24, M32RBF_INSN_BRA24, M32RBF_SFMT_BRA24 },
  { M32R_INSN_CMP, M32RBF_INSN_CMP, M32RBF_SFMT_CMP },
  { M32R_INSN_CMPI, M32RBF_INSN_CMPI, M32RBF_SFMT_CMPI },
  { M32R_INSN_CMPU, M32RBF_INSN_CMPU, M32RBF_SFMT_CMP },
  { M32R_INSN_CMPUI, M32RBF_INSN_CMPUI, M32RBF_SFMT_CMPI },
  { M32R_INSN_DIV, M32RBF_INSN_DIV, M32RBF_SFMT_DIV },
  { M32R_INSN_DIVU, M32RBF_INSN_DIVU, M32RBF_SFMT_DIV },
  { M32R_INSN_REM, M32RBF_INSN_REM, M32RBF_SFMT_DIV },
  { M32R_INSN_REMU, M32RBF_INSN_REMU, M32RBF_SFMT_DIV },
  { M32R_INSN_JL, M32RBF_INSN_JL, M32RBF_SFMT_JL },
  { M32R_INSN_JMP, M32RBF_INSN_JMP, M32RBF_SFMT_JMP },
  { M32R_INSN_LD, M32RBF_INSN_LD, M32RBF_SFMT_LD },
  { M32R_INSN_LD_D, M32RBF_INSN_LD_D, M32RBF_SFMT_LD_D },
  { M32R_INSN_LDB, M32RBF_INSN_LDB, M32RBF_SFMT_LDB },
  { M32R_INSN_LDB_D, M32RBF_INSN_LDB_D, M32RBF_SFMT_LDB_D },
  { M32R_INSN_LDH, M32RBF_INSN_LDH, M32RBF_SFMT_LDH },
  { M32R_INSN_LDH_D, M32RBF_INSN_LDH_D, M32RBF_SFMT_LDH_D },
  { M32R_INSN_LDUB, M32RBF_INSN_LDUB, M32RBF_SFMT_LDB },
  { M32R_INSN_LDUB_D, M32RBF_INSN_LDUB_D, M32RBF_SFMT_LDB_D },
  { M32R_INSN_LDUH, M32RBF_INSN_LDUH, M32RBF_SFMT_LDH },
  { M32R_INSN_LDUH_D, M32RBF_INSN_LDUH_D, M32RBF_SFMT_LDH_D },
  { M32R_INSN_LD_PLUS, M32RBF_INSN_LD_PLUS, M32RBF_SFMT_LD_PLUS },
  { M32R_INSN_LD24, M32RBF_INSN_LD24, M32RBF_SFMT_LD24 },
  { M32R_INSN_LDI8, M32RBF_INSN_LDI8, M32RBF_SFMT_LDI8 },
  { M32R_INSN_LDI16, M32RBF_INSN_LDI16, M32RBF_SFMT_LDI16 },
  { M32R_INSN_LOCK, M32RBF_INSN_LOCK, M32RBF_SFMT_LOCK },
  { M32R_INSN_MACHI, M32RBF_INSN_MACHI, M32RBF_SFMT_MACHI },
  { M32R_INSN_MACLO, M32RBF_INSN_MACLO, M32RBF_SFMT_MACHI },
  { M32R_INSN_MACWHI, M32RBF_INSN_MACWHI, M32RBF_SFMT_MACHI },
  { M32R_INSN_MACWLO, M32RBF_INSN_MACWLO, M32RBF_SFMT_MACHI },
  { M32R_INSN_MUL, M32RBF_INSN_MUL, M32RBF_SFMT_ADD },
  { M32R_INSN_MULHI, M32RBF_INSN_MULHI, M32RBF_SFMT_MULHI },
  { M32R_INSN_MULLO, M32RBF_INSN_MULLO, M32RBF_SFMT_MULHI },
  { M32R_INSN_MULWHI, M32RBF_INSN_MULWHI, M32RBF_SFMT_MULHI },
  { M32R_INSN_MULWLO, M32RBF_INSN_MULWLO, M32RBF_SFMT_MULHI },
  { M32R_INSN_MV, M32RBF_INSN_MV, M32RBF_SFMT_MV },
  { M32R_INSN_MVFACHI, M32RBF_INSN_MVFACHI, M32RBF_SFMT_MVFACHI },
  { M32R_INSN_MVFACLO, M32RBF_INSN_MVFACLO, M32RBF_SFMT_MVFACHI },
  { M32R_INSN_MVFACMI, M32RBF_INSN_MVFACMI, M32RBF_SFMT_MVFACHI },
  { M32R_INSN_MVFC, M32RBF_INSN_MVFC, M32RBF_SFMT_MVFC },
  { M32R_INSN_MVTACHI, M32RBF_INSN_MVTACHI, M32RBF_SFMT_MVTACHI },
  { M32R_INSN_MVTACLO, M32RBF_INSN_MVTACLO, M32RBF_SFMT_MVTACHI },
  { M32R_INSN_MVTC, M32RBF_INSN_MVTC, M32RBF_SFMT_MVTC },
  { M32R_INSN_NEG, M32RBF_INSN_NEG, M32RBF_SFMT_MV },
  { M32R_INSN_NOP, M32RBF_INSN_NOP, M32RBF_SFMT_NOP },
  { M32R_INSN_NOT, M32RBF_INSN_NOT, M32RBF_SFMT_MV },
  { M32R_INSN_RAC, M32RBF_INSN_RAC, M32RBF_SFMT_RAC },
  { M32R_INSN_RACH, M32RBF_INSN_RACH, M32RBF_SFMT_RAC },
  { M32R_INSN_RTE, M32RBF_INSN_RTE, M32RBF_SFMT_RTE },
  { M32R_INSN_SETH, M32RBF_INSN_SETH, M32RBF_SFMT_SETH },
  { M32R_INSN_SLL, M32RBF_INSN_SLL, M32RBF_SFMT_ADD },
  { M32R_INSN_SLL3, M32RBF_INSN_SLL3, M32RBF_SFMT_SLL3 },
  { M32R_INSN_SLLI, M32RBF_INSN_SLLI, M32RBF_SFMT_SLLI },
  { M32R_INSN_SRA, M32RBF_INSN_SRA, M32RBF_SFMT_ADD },
  { M32R_INSN_SRA3, M32RBF_INSN_SRA3, M32RBF_SFMT_SLL3 },
  { M32R_INSN_SRAI, M32RBF_INSN_SRAI, M32RBF_SFMT_SLLI },
  { M32R_INSN_SRL, M32RBF_INSN_SRL, M32RBF_SFMT_ADD },
  { M32R_INSN_SRL3, M32RBF_INSN_SRL3, M32RBF_SFMT_SLL3 },
  { M32R_INSN_SRLI, M32RBF_INSN_SRLI, M32RBF_SFMT_SLLI },
  { M32R_INSN_ST, M32RBF_INSN_ST, M32RBF_SFMT_ST },
  { M32R_INSN_ST_D, M32RBF_INSN_ST_D, M32RBF_SFMT_ST_D },
  { M32R_INSN_STB, M32RBF_INSN_STB, M32RBF_SFMT_STB },
  { M32R_INSN_STB_D, M32RBF_INSN_STB_D, M32RBF_SFMT_STB_D },
  { M32R_INSN_STH, M32RBF_INSN_STH, M32RBF_SFMT_STH },
  { M32R_INSN_STH_D, M32RBF_INSN_STH_D, M32RBF_SFMT_STH_D },
  { M32R_INSN_ST_PLUS, M32RBF_INSN_ST_PLUS, M32RBF_SFMT_ST_PLUS },
  { M32R_INSN_ST_MINUS, M32RBF_INSN_ST_MINUS, M32RBF_SFMT_ST_PLUS },
  { M32R_INSN_SUB, M32RBF_INSN_SUB, M32RBF_SFMT_ADD },
  { M32R_INSN_SUBV, M32RBF_INSN_SUBV, M32RBF_SFMT_ADDV },
  { M32R_INSN_SUBX, M32RBF_INSN_SUBX, M32RBF_SFMT_ADDX },
  { M32R_INSN_TRAP, M32RBF_INSN_TRAP, M32RBF_SFMT_TRAP },
  { M32R_INSN_UNLOCK, M32RBF_INSN_UNLOCK, M32RBF_SFMT_UNLOCK },
  { M32R_INSN_CLRPSW, M32RBF_INSN_CLRPSW, M32RBF_SFMT_CLRPSW },
  { M32R_INSN_SETPSW, M32RBF_INSN_SETPSW, M32RBF_SFMT_SETPSW },
  { M32R_INSN_BSET, M32RBF_INSN_BSET, M32RBF_SFMT_BSET },
  { M32R_INSN_BCLR, M32RBF_INSN_BCLR, M32RBF_SFMT_BSET },
  { M32R_INSN_BTST, M32RBF_INSN_BTST, M32RBF_SFMT_BTST },
};

static const struct insn_sem m32rbf_insn_sem_invalid =
{
  VIRTUAL_INSN_X_INVALID, M32RBF_INSN_X_INVALID, M32RBF_SFMT_EMPTY
};

/* Initialize an IDESC from the compile-time computable parts.  */

static INLINE void
init_idesc (SIM_CPU *cpu, IDESC *id, const struct insn_sem *t)
{
  const CGEN_INSN *insn_table = CGEN_CPU_INSN_TABLE (CPU_CPU_DESC (cpu))->init_entries;

  id->num = t->index;
  id->sfmt = t->sfmt;
  if ((int) t->type <= 0)
    id->idata = & cgen_virtual_insn_table[- (int) t->type];
  else
    id->idata = & insn_table[t->type];
  id->attrs = CGEN_INSN_ATTRS (id->idata);
  /* Oh my god, a magic number.  */
  id->length = CGEN_INSN_BITSIZE (id->idata) / 8;

#if WITH_PROFILE_MODEL_P
  id->timing = & MODEL_TIMING (CPU_MODEL (cpu)) [t->index];
  {
    SIM_DESC sd = CPU_STATE (cpu);
    SIM_ASSERT (t->index == id->timing->num);
  }
#endif

  /* Semantic pointers are initialized elsewhere.  */
}

/* Initialize the instruction descriptor table.  */

void
m32rbf_init_idesc_table (SIM_CPU *cpu)
{
  IDESC *id,*tabend;
  const struct insn_sem *t,*tend;
  int tabsize = M32RBF_INSN__MAX;
  IDESC *table = m32rbf_insn_data;

  memset (table, 0, tabsize * sizeof (IDESC));

  /* First set all entries to the `invalid insn'.  */
  t = & m32rbf_insn_sem_invalid;
  for (id = table, tabend = table + tabsize; id < tabend; ++id)
    init_idesc (cpu, id, t);

  /* Now fill in the values for the chosen cpu.  */
  for (t = m32rbf_insn_sem, tend = t + sizeof (m32rbf_insn_sem) / sizeof (*t);
       t != tend; ++t)
    {
      init_idesc (cpu, & table[t->index], t);
    }

  /* Link the IDESC table into the cpu.  */
  CPU_IDESC (cpu) = table;
}

/* Given an instruction, return a pointer to its IDESC entry.  */

const IDESC *
m32rbf_decode (SIM_CPU *current_cpu, IADDR pc,
              CGEN_INSN_WORD base_insn, CGEN_INSN_WORD entire_insn,
              ARGBUF *abuf)
{
  /* Result of decoder.  */
  M32RBF_INSN_TYPE itype;

  {
    CGEN_INSN_WORD insn = base_insn;

    {
      unsigned int val = (((insn >> 8) & (15 << 4)) | ((insn >> 4) & (15 << 0)));
      switch (val)
      {
      case 0 : itype = M32RBF_INSN_SUBV; goto extract_sfmt_addv;
      case 1 : itype = M32RBF_INSN_SUBX; goto extract_sfmt_addx;
      case 2 : itype = M32RBF_INSN_SUB; goto extract_sfmt_add;
      case 3 : itype = M32RBF_INSN_NEG; goto extract_sfmt_mv;
      case 4 : itype = M32RBF_INSN_CMP; goto extract_sfmt_cmp;
      case 5 : itype = M32RBF_INSN_CMPU; goto extract_sfmt_cmp;
      case 8 : itype = M32RBF_INSN_ADDV; goto extract_sfmt_addv;
      case 9 : itype = M32RBF_INSN_ADDX; goto extract_sfmt_addx;
      case 10 : itype = M32RBF_INSN_ADD; goto extract_sfmt_add;
      case 11 : itype = M32RBF_INSN_NOT; goto extract_sfmt_mv;
      case 12 : itype = M32RBF_INSN_AND; goto extract_sfmt_add;
      case 13 : itype = M32RBF_INSN_XOR; goto extract_sfmt_add;
      case 14 : itype = M32RBF_INSN_OR; goto extract_sfmt_add;
      case 15 :
        if ((entire_insn & 0xf8f0) == 0xf0)
          { itype = M32RBF_INSN_BTST; goto extract_sfmt_btst; }
        itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 16 : itype = M32RBF_INSN_SRL; goto extract_sfmt_add;
      case 18 : itype = M32RBF_INSN_SRA; goto extract_sfmt_add;
      case 20 : itype = M32RBF_INSN_SLL; goto extract_sfmt_add;
      case 22 : itype = M32RBF_INSN_MUL; goto extract_sfmt_add;
      case 24 : itype = M32RBF_INSN_MV; goto extract_sfmt_mv;
      case 25 : itype = M32RBF_INSN_MVFC; goto extract_sfmt_mvfc;
      case 26 : itype = M32RBF_INSN_MVTC; goto extract_sfmt_mvtc;
      case 28 :
        {
          unsigned int val = (((insn >> 8) & (1 << 0)));
          switch (val)
          {
          case 0 :
            if ((entire_insn & 0xfff0) == 0x1ec0)
              { itype = M32RBF_INSN_JL; goto extract_sfmt_jl; }
            itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
          case 1 :
            if ((entire_insn & 0xfff0) == 0x1fc0)
              { itype = M32RBF_INSN_JMP; goto extract_sfmt_jmp; }
            itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
          default : itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
          }
        }
      case 29 :
        if ((entire_insn & 0xffff) == 0x10d6)
          { itype = M32RBF_INSN_RTE; goto extract_sfmt_rte; }
        itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 31 :
        if ((entire_insn & 0xfff0) == 0x10f0)
          { itype = M32RBF_INSN_TRAP; goto extract_sfmt_trap; }
        itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 32 : itype = M32RBF_INSN_STB; goto extract_sfmt_stb;
      case 34 : itype = M32RBF_INSN_STH; goto extract_sfmt_sth;
      case 36 : itype = M32RBF_INSN_ST; goto extract_sfmt_st;
      case 37 : itype = M32RBF_INSN_UNLOCK; goto extract_sfmt_unlock;
      case 38 : itype = M32RBF_INSN_ST_PLUS; goto extract_sfmt_st_plus;
      case 39 : itype = M32RBF_INSN_ST_MINUS; goto extract_sfmt_st_plus;
      case 40 : itype = M32RBF_INSN_LDB; goto extract_sfmt_ldb;
      case 41 : itype = M32RBF_INSN_LDUB; goto extract_sfmt_ldb;
      case 42 : itype = M32RBF_INSN_LDH; goto extract_sfmt_ldh;
      case 43 : itype = M32RBF_INSN_LDUH; goto extract_sfmt_ldh;
      case 44 : itype = M32RBF_INSN_LD; goto extract_sfmt_ld;
      case 45 : itype = M32RBF_INSN_LOCK; goto extract_sfmt_lock;
      case 46 : itype = M32RBF_INSN_LD_PLUS; goto extract_sfmt_ld_plus;
      case 48 : itype = M32RBF_INSN_MULHI; goto extract_sfmt_mulhi;
      case 49 : itype = M32RBF_INSN_MULLO; goto extract_sfmt_mulhi;
      case 50 : itype = M32RBF_INSN_MULWHI; goto extract_sfmt_mulhi;
      case 51 : itype = M32RBF_INSN_MULWLO; goto extract_sfmt_mulhi;
      case 52 : itype = M32RBF_INSN_MACHI; goto extract_sfmt_machi;
      case 53 : itype = M32RBF_INSN_MACLO; goto extract_sfmt_machi;
      case 54 : itype = M32RBF_INSN_MACWHI; goto extract_sfmt_machi;
      case 55 : itype = M32RBF_INSN_MACWLO; goto extract_sfmt_machi;
      case 64 : /* fall through */
      case 65 : /* fall through */
      case 66 : /* fall through */
      case 67 : /* fall through */
      case 68 : /* fall through */
      case 69 : /* fall through */
      case 70 : /* fall through */
      case 71 : /* fall through */
      case 72 : /* fall through */
      case 73 : /* fall through */
      case 74 : /* fall through */
      case 75 : /* fall through */
      case 76 : /* fall through */
      case 77 : /* fall through */
      case 78 : /* fall through */
      case 79 : itype = M32RBF_INSN_ADDI; goto extract_sfmt_addi;
      case 80 : /* fall through */
      case 81 : itype = M32RBF_INSN_SRLI; goto extract_sfmt_slli;
      case 82 : /* fall through */
      case 83 : itype = M32RBF_INSN_SRAI; goto extract_sfmt_slli;
      case 84 : /* fall through */
      case 85 : itype = M32RBF_INSN_SLLI; goto extract_sfmt_slli;
      case 87 :
        {
          unsigned int val = (((insn >> 0) & (1 << 0)));
          switch (val)
          {
          case 0 :
            if ((entire_insn & 0xf0ff) == 0x5070)
              { itype = M32RBF_INSN_MVTACHI; goto extract_sfmt_mvtachi; }
            itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
          case 1 :
            if ((entire_insn & 0xf0ff) == 0x5071)
              { itype = M32RBF_INSN_MVTACLO; goto extract_sfmt_mvtachi; }
            itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
          default : itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
          }
        }
      case 88 :
        if ((entire_insn & 0xffff) == 0x5080)
          { itype = M32RBF_INSN_RACH; goto extract_sfmt_rac; }
        itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 89 :
        if ((entire_insn & 0xffff) == 0x5090)
          { itype = M32RBF_INSN_RAC; goto extract_sfmt_rac; }
        itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 95 :
        {
          unsigned int val = (((insn >> 0) & (3 << 0)));
          switch (val)
          {
          case 0 :
            if ((entire_insn & 0xf0ff) == 0x50f0)
              { itype = M32RBF_INSN_MVFACHI; goto extract_sfmt_mvfachi; }
            itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
          case 1 :
            if ((entire_insn & 0xf0ff) == 0x50f1)
              { itype = M32RBF_INSN_MVFACLO; goto extract_sfmt_mvfachi; }
            itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
          case 2 :
            if ((entire_insn & 0xf0ff) == 0x50f2)
              { itype = M32RBF_INSN_MVFACMI; goto extract_sfmt_mvfachi; }
            itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
          default : itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
          }
        }
      case 96 : /* fall through */
      case 97 : /* fall through */
      case 98 : /* fall through */
      case 99 : /* fall through */
      case 100 : /* fall through */
      case 101 : /* fall through */
      case 102 : /* fall through */
      case 103 : /* fall through */
      case 104 : /* fall through */
      case 105 : /* fall through */
      case 106 : /* fall through */
      case 107 : /* fall through */
      case 108 : /* fall through */
      case 109 : /* fall through */
      case 110 : /* fall through */
      case 111 : itype = M32RBF_INSN_LDI8; goto extract_sfmt_ldi8;
      case 112 :
        {
          unsigned int val = (((insn >> 8) & (15 << 0)));
          switch (val)
          {
          case 0 :
            if ((entire_insn & 0xffff) == 0x7000)
              { itype = M32RBF_INSN_NOP; goto extract_sfmt_nop; }
            itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
          case 1 : itype = M32RBF_INSN_SETPSW; goto extract_sfmt_setpsw;
          case 2 : itype = M32RBF_INSN_CLRPSW; goto extract_sfmt_clrpsw;
          case 12 : itype = M32RBF_INSN_BC8; goto extract_sfmt_bc8;
          case 13 : itype = M32RBF_INSN_BNC8; goto extract_sfmt_bc8;
          case 14 : itype = M32RBF_INSN_BL8; goto extract_sfmt_bl8;
          case 15 : itype = M32RBF_INSN_BRA8; goto extract_sfmt_bra8;
          default : itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
          }
        }
      case 113 : /* fall through */
      case 114 : /* fall through */
      case 115 : /* fall through */
      case 116 : /* fall through */
      case 117 : /* fall through */
      case 118 : /* fall through */
      case 119 : /* fall through */
      case 120 : /* fall through */
      case 121 : /* fall through */
      case 122 : /* fall through */
      case 123 : /* fall through */
      case 124 : /* fall through */
      case 125 : /* fall through */
      case 126 : /* fall through */
      case 127 :
        {
          unsigned int val = (((insn >> 8) & (15 << 0)));
          switch (val)
          {
          case 1 : itype = M32RBF_INSN_SETPSW; goto extract_sfmt_setpsw;
          case 2 : itype = M32RBF_INSN_CLRPSW; goto extract_sfmt_clrpsw;
          case 12 : itype = M32RBF_INSN_BC8; goto extract_sfmt_bc8;
          case 13 : itype = M32RBF_INSN_BNC8; goto extract_sfmt_bc8;
          case 14 : itype = M32RBF_INSN_BL8; goto extract_sfmt_bl8;
          case 15 : itype = M32RBF_INSN_BRA8; goto extract_sfmt_bra8;
          default : itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
          }
        }
      case 132 :
        if ((entire_insn & 0xfff00000) == 0x80400000)
          { itype = M32RBF_INSN_CMPI; goto extract_sfmt_cmpi; }
        itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 133 :
        if ((entire_insn & 0xfff00000) == 0x80500000)
          { itype = M32RBF_INSN_CMPUI; goto extract_sfmt_cmpi; }
        itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 136 : itype = M32RBF_INSN_ADDV3; goto extract_sfmt_addv3;
      case 138 : itype = M32RBF_INSN_ADD3; goto extract_sfmt_add3;
      case 140 : itype = M32RBF_INSN_AND3; goto extract_sfmt_and3;
      case 141 : itype = M32RBF_INSN_XOR3; goto extract_sfmt_and3;
      case 142 : itype = M32RBF_INSN_OR3; goto extract_sfmt_or3;
      case 144 :
        if ((entire_insn & 0xf0f0ffff) == 0x90000000)
          { itype = M32RBF_INSN_DIV; goto extract_sfmt_div; }
        itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 145 :
        if ((entire_insn & 0xf0f0ffff) == 0x90100000)
          { itype = M32RBF_INSN_DIVU; goto extract_sfmt_div; }
        itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 146 :
        if ((entire_insn & 0xf0f0ffff) == 0x90200000)
          { itype = M32RBF_INSN_REM; goto extract_sfmt_div; }
        itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 147 :
        if ((entire_insn & 0xf0f0ffff) == 0x90300000)
          { itype = M32RBF_INSN_REMU; goto extract_sfmt_div; }
        itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 152 : itype = M32RBF_INSN_SRL3; goto extract_sfmt_sll3;
      case 154 : itype = M32RBF_INSN_SRA3; goto extract_sfmt_sll3;
      case 156 : itype = M32RBF_INSN_SLL3; goto extract_sfmt_sll3;
      case 159 :
        if ((entire_insn & 0xf0ff0000) == 0x90f00000)
          { itype = M32RBF_INSN_LDI16; goto extract_sfmt_ldi16; }
        itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 160 : itype = M32RBF_INSN_STB_D; goto extract_sfmt_stb_d;
      case 162 : itype = M32RBF_INSN_STH_D; goto extract_sfmt_sth_d;
      case 164 : itype = M32RBF_INSN_ST_D; goto extract_sfmt_st_d;
      case 166 :
        if ((entire_insn & 0xf8f00000) == 0xa0600000)
          { itype = M32RBF_INSN_BSET; goto extract_sfmt_bset; }
        itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 167 :
        if ((entire_insn & 0xf8f00000) == 0xa0700000)
          { itype = M32RBF_INSN_BCLR; goto extract_sfmt_bset; }
        itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 168 : itype = M32RBF_INSN_LDB_D; goto extract_sfmt_ldb_d;
      case 169 : itype = M32RBF_INSN_LDUB_D; goto extract_sfmt_ldb_d;
      case 170 : itype = M32RBF_INSN_LDH_D; goto extract_sfmt_ldh_d;
      case 171 : itype = M32RBF_INSN_LDUH_D; goto extract_sfmt_ldh_d;
      case 172 : itype = M32RBF_INSN_LD_D; goto extract_sfmt_ld_d;
      case 176 : itype = M32RBF_INSN_BEQ; goto extract_sfmt_beq;
      case 177 : itype = M32RBF_INSN_BNE; goto extract_sfmt_beq;
      case 184 :
        if ((entire_insn & 0xfff00000) == 0xb0800000)
          { itype = M32RBF_INSN_BEQZ; goto extract_sfmt_beqz; }
        itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 185 :
        if ((entire_insn & 0xfff00000) == 0xb0900000)
          { itype = M32RBF_INSN_BNEZ; goto extract_sfmt_beqz; }
        itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 186 :
        if ((entire_insn & 0xfff00000) == 0xb0a00000)
          { itype = M32RBF_INSN_BLTZ; goto extract_sfmt_beqz; }
        itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 187 :
        if ((entire_insn & 0xfff00000) == 0xb0b00000)
          { itype = M32RBF_INSN_BGEZ; goto extract_sfmt_beqz; }
        itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 188 :
        if ((entire_insn & 0xfff00000) == 0xb0c00000)
          { itype = M32RBF_INSN_BLEZ; goto extract_sfmt_beqz; }
        itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 189 :
        if ((entire_insn & 0xfff00000) == 0xb0d00000)
          { itype = M32RBF_INSN_BGTZ; goto extract_sfmt_beqz; }
        itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 220 :
        if ((entire_insn & 0xf0ff0000) == 0xd0c00000)
          { itype = M32RBF_INSN_SETH; goto extract_sfmt_seth; }
        itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
      case 224 : /* fall through */
      case 225 : /* fall through */
      case 226 : /* fall through */
      case 227 : /* fall through */
      case 228 : /* fall through */
      case 229 : /* fall through */
      case 230 : /* fall through */
      case 231 : /* fall through */
      case 232 : /* fall through */
      case 233 : /* fall through */
      case 234 : /* fall through */
      case 235 : /* fall through */
      case 236 : /* fall through */
      case 237 : /* fall through */
      case 238 : /* fall through */
      case 239 : itype = M32RBF_INSN_LD24; goto extract_sfmt_ld24;
      case 240 : /* fall through */
      case 241 : /* fall through */
      case 242 : /* fall through */
      case 243 : /* fall through */
      case 244 : /* fall through */
      case 245 : /* fall through */
      case 246 : /* fall through */
      case 247 : /* fall through */
      case 248 : /* fall through */
      case 249 : /* fall through */
      case 250 : /* fall through */
      case 251 : /* fall through */
      case 252 : /* fall through */
      case 253 : /* fall through */
      case 254 : /* fall through */
      case 255 :
        {
          unsigned int val = (((insn >> 8) & (3 << 0)));
          switch (val)
          {
          case 0 :
            if ((entire_insn & 0xff000000) == 0xfc000000)
              { itype = M32RBF_INSN_BC24; goto extract_sfmt_bc24; }
            itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
          case 1 :
            if ((entire_insn & 0xff000000) == 0xfd000000)
              { itype = M32RBF_INSN_BNC24; goto extract_sfmt_bc24; }
            itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
          case 2 :
            if ((entire_insn & 0xff000000) == 0xfe000000)
              { itype = M32RBF_INSN_BL24; goto extract_sfmt_bl24; }
            itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
          case 3 :
            if ((entire_insn & 0xff000000) == 0xff000000)
              { itype = M32RBF_INSN_BRA24; goto extract_sfmt_bra24; }
            itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
          default : itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
          }
        }
      default : itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
      }
    }
  }

  /* The instruction has been decoded, now extract the fields.  */

 extract_sfmt_empty:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
#define FLD(f) abuf->fields.sfmt_empty.f


  /* Record the fields for the semantic handler.  */
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_empty", (char *) 0));

#undef FLD
    return idesc;
  }

 extract_sfmt_add:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_add.f
    UINT f_r1;
    UINT f_r2;

    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);

  /* Record the fields for the semantic handler.  */
  FLD (f_r1) = f_r1;
  FLD (f_r2) = f_r2;
  FLD (i_dr) = & CPU (h_gr)[f_r1];
  FLD (i_sr) = & CPU (h_gr)[f_r2];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_add", "f_r1 0x%x", 'x', f_r1, "f_r2 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, "sr 0x%x", 'x', f_r2, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_dr) = f_r1;
      FLD (in_sr) = f_r2;
      FLD (out_dr) = f_r1;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_add3:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_add3.f
    UINT f_r1;
    UINT f_r2;
    INT f_simm16;

    f_r1 = EXTRACT_MSB0_UINT (insn, 32, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 32, 12, 4);
    f_simm16 = EXTRACT_MSB0_SINT (insn, 32, 16, 16);

  /* Record the fields for the semantic handler.  */
  FLD (f_simm16) = f_simm16;
  FLD (f_r2) = f_r2;
  FLD (f_r1) = f_r1;
  FLD (i_sr) = & CPU (h_gr)[f_r2];
  FLD (i_dr) = & CPU (h_gr)[f_r1];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_add3", "f_simm16 0x%x", 'x', f_simm16, "f_r2 0x%x", 'x', f_r2, "f_r1 0x%x", 'x', f_r1, "sr 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_sr) = f_r2;
      FLD (out_dr) = f_r1;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_and3:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_and3.f
    UINT f_r1;
    UINT f_r2;
    UINT f_uimm16;

    f_r1 = EXTRACT_MSB0_UINT (insn, 32, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 32, 12, 4);
    f_uimm16 = EXTRACT_MSB0_UINT (insn, 32, 16, 16);

  /* Record the fields for the semantic handler.  */
  FLD (f_r2) = f_r2;
  FLD (f_uimm16) = f_uimm16;
  FLD (f_r1) = f_r1;
  FLD (i_sr) = & CPU (h_gr)[f_r2];
  FLD (i_dr) = & CPU (h_gr)[f_r1];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_and3", "f_r2 0x%x", 'x', f_r2, "f_uimm16 0x%x", 'x', f_uimm16, "f_r1 0x%x", 'x', f_r1, "sr 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_sr) = f_r2;
      FLD (out_dr) = f_r1;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_or3:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_and3.f
    UINT f_r1;
    UINT f_r2;
    UINT f_uimm16;

    f_r1 = EXTRACT_MSB0_UINT (insn, 32, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 32, 12, 4);
    f_uimm16 = EXTRACT_MSB0_UINT (insn, 32, 16, 16);

  /* Record the fields for the semantic handler.  */
  FLD (f_r2) = f_r2;
  FLD (f_uimm16) = f_uimm16;
  FLD (f_r1) = f_r1;
  FLD (i_sr) = & CPU (h_gr)[f_r2];
  FLD (i_dr) = & CPU (h_gr)[f_r1];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_or3", "f_r2 0x%x", 'x', f_r2, "f_uimm16 0x%x", 'x', f_uimm16, "f_r1 0x%x", 'x', f_r1, "sr 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_sr) = f_r2;
      FLD (out_dr) = f_r1;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_addi:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_addi.f
    UINT f_r1;
    INT f_simm8;

    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_simm8 = EXTRACT_MSB0_SINT (insn, 16, 8, 8);

  /* Record the fields for the semantic handler.  */
  FLD (f_r1) = f_r1;
  FLD (f_simm8) = f_simm8;
  FLD (i_dr) = & CPU (h_gr)[f_r1];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_addi", "f_r1 0x%x", 'x', f_r1, "f_simm8 0x%x", 'x', f_simm8, "dr 0x%x", 'x', f_r1, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_dr) = f_r1;
      FLD (out_dr) = f_r1;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_addv:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_add.f
    UINT f_r1;
    UINT f_r2;

    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);

  /* Record the fields for the semantic handler.  */
  FLD (f_r1) = f_r1;
  FLD (f_r2) = f_r2;
  FLD (i_dr) = & CPU (h_gr)[f_r1];
  FLD (i_sr) = & CPU (h_gr)[f_r2];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_addv", "f_r1 0x%x", 'x', f_r1, "f_r2 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, "sr 0x%x", 'x', f_r2, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_dr) = f_r1;
      FLD (in_sr) = f_r2;
      FLD (out_dr) = f_r1;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_addv3:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_add3.f
    UINT f_r1;
    UINT f_r2;
    INT f_simm16;

    f_r1 = EXTRACT_MSB0_UINT (insn, 32, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 32, 12, 4);
    f_simm16 = EXTRACT_MSB0_SINT (insn, 32, 16, 16);

  /* Record the fields for the semantic handler.  */
  FLD (f_simm16) = f_simm16;
  FLD (f_r2) = f_r2;
  FLD (f_r1) = f_r1;
  FLD (i_sr) = & CPU (h_gr)[f_r2];
  FLD (i_dr) = & CPU (h_gr)[f_r1];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_addv3", "f_simm16 0x%x", 'x', f_simm16, "f_r2 0x%x", 'x', f_r2, "f_r1 0x%x", 'x', f_r1, "sr 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_sr) = f_r2;
      FLD (out_dr) = f_r1;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_addx:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_add.f
    UINT f_r1;
    UINT f_r2;

    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);

  /* Record the fields for the semantic handler.  */
  FLD (f_r1) = f_r1;
  FLD (f_r2) = f_r2;
  FLD (i_dr) = & CPU (h_gr)[f_r1];
  FLD (i_sr) = & CPU (h_gr)[f_r2];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_addx", "f_r1 0x%x", 'x', f_r1, "f_r2 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, "sr 0x%x", 'x', f_r2, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_dr) = f_r1;
      FLD (in_sr) = f_r2;
      FLD (out_dr) = f_r1;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_bc8:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_bl8.f
    SI f_disp8;

    f_disp8 = ((((EXTRACT_MSB0_SINT (insn, 16, 8, 8)) << (2))) + (((pc) & (-4))));

  /* Record the fields for the semantic handler.  */
  FLD (i_disp8) = f_disp8;
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_bc8", "disp8 0x%x", 'x', f_disp8, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_bc24:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_bl24.f
    SI f_disp24;

    f_disp24 = ((((EXTRACT_MSB0_SINT (insn, 32, 8, 24)) << (2))) + (pc));

  /* Record the fields for the semantic handler.  */
  FLD (i_disp24) = f_disp24;
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_bc24", "disp24 0x%x", 'x', f_disp24, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_beq:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_beq.f
    UINT f_r1;
    UINT f_r2;
    SI f_disp16;

    f_r1 = EXTRACT_MSB0_UINT (insn, 32, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 32, 12, 4);
    f_disp16 = ((((EXTRACT_MSB0_SINT (insn, 32, 16, 16)) << (2))) + (pc));

  /* Record the fields for the semantic handler.  */
  FLD (f_r1) = f_r1;
  FLD (f_r2) = f_r2;
  FLD (i_disp16) = f_disp16;
  FLD (i_src1) = & CPU (h_gr)[f_r1];
  FLD (i_src2) = & CPU (h_gr)[f_r2];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_beq", "f_r1 0x%x", 'x', f_r1, "f_r2 0x%x", 'x', f_r2, "disp16 0x%x", 'x', f_disp16, "src1 0x%x", 'x', f_r1, "src2 0x%x", 'x', f_r2, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_src1) = f_r1;
      FLD (in_src2) = f_r2;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_beqz:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_beq.f
    UINT f_r2;
    SI f_disp16;

    f_r2 = EXTRACT_MSB0_UINT (insn, 32, 12, 4);
    f_disp16 = ((((EXTRACT_MSB0_SINT (insn, 32, 16, 16)) << (2))) + (pc));

  /* Record the fields for the semantic handler.  */
  FLD (f_r2) = f_r2;
  FLD (i_disp16) = f_disp16;
  FLD (i_src2) = & CPU (h_gr)[f_r2];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_beqz", "f_r2 0x%x", 'x', f_r2, "disp16 0x%x", 'x', f_disp16, "src2 0x%x", 'x', f_r2, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_src2) = f_r2;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_bl8:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_bl8.f
    SI f_disp8;

    f_disp8 = ((((EXTRACT_MSB0_SINT (insn, 16, 8, 8)) << (2))) + (((pc) & (-4))));

  /* Record the fields for the semantic handler.  */
  FLD (i_disp8) = f_disp8;
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_bl8", "disp8 0x%x", 'x', f_disp8, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (out_h_gr_SI_14) = 14;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_bl24:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_bl24.f
    SI f_disp24;

    f_disp24 = ((((EXTRACT_MSB0_SINT (insn, 32, 8, 24)) << (2))) + (pc));

  /* Record the fields for the semantic handler.  */
  FLD (i_disp24) = f_disp24;
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_bl24", "disp24 0x%x", 'x', f_disp24, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (out_h_gr_SI_14) = 14;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_bra8:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_bl8.f
    SI f_disp8;

    f_disp8 = ((((EXTRACT_MSB0_SINT (insn, 16, 8, 8)) << (2))) + (((pc) & (-4))));

  /* Record the fields for the semantic handler.  */
  FLD (i_disp8) = f_disp8;
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_bra8", "disp8 0x%x", 'x', f_disp8, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_bra24:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_bl24.f
    SI f_disp24;

    f_disp24 = ((((EXTRACT_MSB0_SINT (insn, 32, 8, 24)) << (2))) + (pc));

  /* Record the fields for the semantic handler.  */
  FLD (i_disp24) = f_disp24;
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_bra24", "disp24 0x%x", 'x', f_disp24, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_cmp:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_st_plus.f
    UINT f_r1;
    UINT f_r2;

    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);

  /* Record the fields for the semantic handler.  */
  FLD (f_r1) = f_r1;
  FLD (f_r2) = f_r2;
  FLD (i_src1) = & CPU (h_gr)[f_r1];
  FLD (i_src2) = & CPU (h_gr)[f_r2];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_cmp", "f_r1 0x%x", 'x', f_r1, "f_r2 0x%x", 'x', f_r2, "src1 0x%x", 'x', f_r1, "src2 0x%x", 'x', f_r2, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_src1) = f_r1;
      FLD (in_src2) = f_r2;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_cmpi:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_st_d.f
    UINT f_r2;
    INT f_simm16;

    f_r2 = EXTRACT_MSB0_UINT (insn, 32, 12, 4);
    f_simm16 = EXTRACT_MSB0_SINT (insn, 32, 16, 16);

  /* Record the fields for the semantic handler.  */
  FLD (f_simm16) = f_simm16;
  FLD (f_r2) = f_r2;
  FLD (i_src2) = & CPU (h_gr)[f_r2];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_cmpi", "f_simm16 0x%x", 'x', f_simm16, "f_r2 0x%x", 'x', f_r2, "src2 0x%x", 'x', f_r2, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_src2) = f_r2;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_div:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_add.f
    UINT f_r1;
    UINT f_r2;

    f_r1 = EXTRACT_MSB0_UINT (insn, 32, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 32, 12, 4);

  /* Record the fields for the semantic handler.  */
  FLD (f_r1) = f_r1;
  FLD (f_r2) = f_r2;
  FLD (i_dr) = & CPU (h_gr)[f_r1];
  FLD (i_sr) = & CPU (h_gr)[f_r2];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_div", "f_r1 0x%x", 'x', f_r1, "f_r2 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, "sr 0x%x", 'x', f_r2, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_dr) = f_r1;
      FLD (in_sr) = f_r2;
      FLD (out_dr) = f_r1;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_jl:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_jl.f
    UINT f_r2;

    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);

  /* Record the fields for the semantic handler.  */
  FLD (f_r2) = f_r2;
  FLD (i_sr) = & CPU (h_gr)[f_r2];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_jl", "f_r2 0x%x", 'x', f_r2, "sr 0x%x", 'x', f_r2, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_sr) = f_r2;
      FLD (out_h_gr_SI_14) = 14;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_jmp:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_jl.f
    UINT f_r2;

    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);

  /* Record the fields for the semantic handler.  */
  FLD (f_r2) = f_r2;
  FLD (i_sr) = & CPU (h_gr)[f_r2];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_jmp", "f_r2 0x%x", 'x', f_r2, "sr 0x%x", 'x', f_r2, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_sr) = f_r2;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_ld:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_ld_plus.f
    UINT f_r1;
    UINT f_r2;

    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);

  /* Record the fields for the semantic handler.  */
  FLD (f_r2) = f_r2;
  FLD (f_r1) = f_r1;
  FLD (i_sr) = & CPU (h_gr)[f_r2];
  FLD (i_dr) = & CPU (h_gr)[f_r1];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_ld", "f_r2 0x%x", 'x', f_r2, "f_r1 0x%x", 'x', f_r1, "sr 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_sr) = f_r2;
      FLD (out_dr) = f_r1;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_ld_d:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_add3.f
    UINT f_r1;
    UINT f_r2;
    INT f_simm16;

    f_r1 = EXTRACT_MSB0_UINT (insn, 32, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 32, 12, 4);
    f_simm16 = EXTRACT_MSB0_SINT (insn, 32, 16, 16);

  /* Record the fields for the semantic handler.  */
  FLD (f_simm16) = f_simm16;
  FLD (f_r2) = f_r2;
  FLD (f_r1) = f_r1;
  FLD (i_sr) = & CPU (h_gr)[f_r2];
  FLD (i_dr) = & CPU (h_gr)[f_r1];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_ld_d", "f_simm16 0x%x", 'x', f_simm16, "f_r2 0x%x", 'x', f_r2, "f_r1 0x%x", 'x', f_r1, "sr 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_sr) = f_r2;
      FLD (out_dr) = f_r1;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_ldb:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_ld_plus.f
    UINT f_r1;
    UINT f_r2;

    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);

  /* Record the fields for the semantic handler.  */
  FLD (f_r2) = f_r2;
  FLD (f_r1) = f_r1;
  FLD (i_sr) = & CPU (h_gr)[f_r2];
  FLD (i_dr) = & CPU (h_gr)[f_r1];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_ldb", "f_r2 0x%x", 'x', f_r2, "f_r1 0x%x", 'x', f_r1, "sr 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_sr) = f_r2;
      FLD (out_dr) = f_r1;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_ldb_d:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_add3.f
    UINT f_r1;
    UINT f_r2;
    INT f_simm16;

    f_r1 = EXTRACT_MSB0_UINT (insn, 32, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 32, 12, 4);
    f_simm16 = EXTRACT_MSB0_SINT (insn, 32, 16, 16);

  /* Record the fields for the semantic handler.  */
  FLD (f_simm16) = f_simm16;
  FLD (f_r2) = f_r2;
  FLD (f_r1) = f_r1;
  FLD (i_sr) = & CPU (h_gr)[f_r2];
  FLD (i_dr) = & CPU (h_gr)[f_r1];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_ldb_d", "f_simm16 0x%x", 'x', f_simm16, "f_r2 0x%x", 'x', f_r2, "f_r1 0x%x", 'x', f_r1, "sr 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_sr) = f_r2;
      FLD (out_dr) = f_r1;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_ldh:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_ld_plus.f
    UINT f_r1;
    UINT f_r2;

    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);

  /* Record the fields for the semantic handler.  */
  FLD (f_r2) = f_r2;
  FLD (f_r1) = f_r1;
  FLD (i_sr) = & CPU (h_gr)[f_r2];
  FLD (i_dr) = & CPU (h_gr)[f_r1];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_ldh", "f_r2 0x%x", 'x', f_r2, "f_r1 0x%x", 'x', f_r1, "sr 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_sr) = f_r2;
      FLD (out_dr) = f_r1;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_ldh_d:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_add3.f
    UINT f_r1;
    UINT f_r2;
    INT f_simm16;

    f_r1 = EXTRACT_MSB0_UINT (insn, 32, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 32, 12, 4);
    f_simm16 = EXTRACT_MSB0_SINT (insn, 32, 16, 16);

  /* Record the fields for the semantic handler.  */
  FLD (f_simm16) = f_simm16;
  FLD (f_r2) = f_r2;
  FLD (f_r1) = f_r1;
  FLD (i_sr) = & CPU (h_gr)[f_r2];
  FLD (i_dr) = & CPU (h_gr)[f_r1];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_ldh_d", "f_simm16 0x%x", 'x', f_simm16, "f_r2 0x%x", 'x', f_r2, "f_r1 0x%x", 'x', f_r1, "sr 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_sr) = f_r2;
      FLD (out_dr) = f_r1;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_ld_plus:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_ld_plus.f
    UINT f_r1;
    UINT f_r2;

    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);

  /* Record the fields for the semantic handler.  */
  FLD (f_r2) = f_r2;
  FLD (f_r1) = f_r1;
  FLD (i_sr) = & CPU (h_gr)[f_r2];
  FLD (i_dr) = & CPU (h_gr)[f_r1];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_ld_plus", "f_r2 0x%x", 'x', f_r2, "f_r1 0x%x", 'x', f_r1, "sr 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_sr) = f_r2;
      FLD (out_dr) = f_r1;
      FLD (out_sr) = f_r2;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_ld24:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_ld24.f
    UINT f_r1;
    UINT f_uimm24;

    f_r1 = EXTRACT_MSB0_UINT (insn, 32, 4, 4);
    f_uimm24 = EXTRACT_MSB0_UINT (insn, 32, 8, 24);

  /* Record the fields for the semantic handler.  */
  FLD (f_r1) = f_r1;
  FLD (i_uimm24) = f_uimm24;
  FLD (i_dr) = & CPU (h_gr)[f_r1];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_ld24", "f_r1 0x%x", 'x', f_r1, "uimm24 0x%x", 'x', f_uimm24, "dr 0x%x", 'x', f_r1, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (out_dr) = f_r1;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_ldi8:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_addi.f
    UINT f_r1;
    INT f_simm8;

    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_simm8 = EXTRACT_MSB0_SINT (insn, 16, 8, 8);

  /* Record the fields for the semantic handler.  */
  FLD (f_simm8) = f_simm8;
  FLD (f_r1) = f_r1;
  FLD (i_dr) = & CPU (h_gr)[f_r1];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_ldi8", "f_simm8 0x%x", 'x', f_simm8, "f_r1 0x%x", 'x', f_r1, "dr 0x%x", 'x', f_r1, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (out_dr) = f_r1;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_ldi16:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_add3.f
    UINT f_r1;
    INT f_simm16;

    f_r1 = EXTRACT_MSB0_UINT (insn, 32, 4, 4);
    f_simm16 = EXTRACT_MSB0_SINT (insn, 32, 16, 16);

  /* Record the fields for the semantic handler.  */
  FLD (f_simm16) = f_simm16;
  FLD (f_r1) = f_r1;
  FLD (i_dr) = & CPU (h_gr)[f_r1];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_ldi16", "f_simm16 0x%x", 'x', f_simm16, "f_r1 0x%x", 'x', f_r1, "dr 0x%x", 'x', f_r1, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (out_dr) = f_r1;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_lock:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_ld_plus.f
    UINT f_r1;
    UINT f_r2;

    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);

  /* Record the fields for the semantic handler.  */
  FLD (f_r2) = f_r2;
  FLD (f_r1) = f_r1;
  FLD (i_sr) = & CPU (h_gr)[f_r2];
  FLD (i_dr) = & CPU (h_gr)[f_r1];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_lock", "f_r2 0x%x", 'x', f_r2, "f_r1 0x%x", 'x', f_r1, "sr 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_sr) = f_r2;
      FLD (out_dr) = f_r1;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_machi:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_st_plus.f
    UINT f_r1;
    UINT f_r2;

    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);

  /* Record the fields for the semantic handler.  */
  FLD (f_r1) = f_r1;
  FLD (f_r2) = f_r2;
  FLD (i_src1) = & CPU (h_gr)[f_r1];
  FLD (i_src2) = & CPU (h_gr)[f_r2];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_machi", "f_r1 0x%x", 'x', f_r1, "f_r2 0x%x", 'x', f_r2, "src1 0x%x", 'x', f_r1, "src2 0x%x", 'x', f_r2, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_src1) = f_r1;
      FLD (in_src2) = f_r2;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_mulhi:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_st_plus.f
    UINT f_r1;
    UINT f_r2;

    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);

  /* Record the fields for the semantic handler.  */
  FLD (f_r1) = f_r1;
  FLD (f_r2) = f_r2;
  FLD (i_src1) = & CPU (h_gr)[f_r1];
  FLD (i_src2) = & CPU (h_gr)[f_r2];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_mulhi", "f_r1 0x%x", 'x', f_r1, "f_r2 0x%x", 'x', f_r2, "src1 0x%x", 'x', f_r1, "src2 0x%x", 'x', f_r2, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_src1) = f_r1;
      FLD (in_src2) = f_r2;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_mv:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_ld_plus.f
    UINT f_r1;
    UINT f_r2;

    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);

  /* Record the fields for the semantic handler.  */
  FLD (f_r2) = f_r2;
  FLD (f_r1) = f_r1;
  FLD (i_sr) = & CPU (h_gr)[f_r2];
  FLD (i_dr) = & CPU (h_gr)[f_r1];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_mv", "f_r2 0x%x", 'x', f_r2, "f_r1 0x%x", 'x', f_r1, "sr 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_sr) = f_r2;
      FLD (out_dr) = f_r1;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_mvfachi:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_seth.f
    UINT f_r1;

    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);

  /* Record the fields for the semantic handler.  */
  FLD (f_r1) = f_r1;
  FLD (i_dr) = & CPU (h_gr)[f_r1];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_mvfachi", "f_r1 0x%x", 'x', f_r1, "dr 0x%x", 'x', f_r1, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (out_dr) = f_r1;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_mvfc:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_ld_plus.f
    UINT f_r1;
    UINT f_r2;

    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);

  /* Record the fields for the semantic handler.  */
  FLD (f_r2) = f_r2;
  FLD (f_r1) = f_r1;
  FLD (i_dr) = & CPU (h_gr)[f_r1];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_mvfc", "f_r2 0x%x", 'x', f_r2, "f_r1 0x%x", 'x', f_r1, "dr 0x%x", 'x', f_r1, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (out_dr) = f_r1;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_mvtachi:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_st_plus.f
    UINT f_r1;

    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);

  /* Record the fields for the semantic handler.  */
  FLD (f_r1) = f_r1;
  FLD (i_src1) = & CPU (h_gr)[f_r1];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_mvtachi", "f_r1 0x%x", 'x', f_r1, "src1 0x%x", 'x', f_r1, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_src1) = f_r1;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_mvtc:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_ld_plus.f
    UINT f_r1;
    UINT f_r2;

    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);

  /* Record the fields for the semantic handler.  */
  FLD (f_r2) = f_r2;
  FLD (f_r1) = f_r1;
  FLD (i_sr) = & CPU (h_gr)[f_r2];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_mvtc", "f_r2 0x%x", 'x', f_r2, "f_r1 0x%x", 'x', f_r1, "sr 0x%x", 'x', f_r2, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_sr) = f_r2;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_nop:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
#define FLD(f) abuf->fields.sfmt_empty.f


  /* Record the fields for the semantic handler.  */
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_nop", (char *) 0));

#undef FLD
    return idesc;
  }

 extract_sfmt_rac:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
#define FLD(f) abuf->fields.sfmt_empty.f


  /* Record the fields for the semantic handler.  */
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_rac", (char *) 0));

#undef FLD
    return idesc;
  }

 extract_sfmt_rte:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
#define FLD(f) abuf->fields.sfmt_empty.f


  /* Record the fields for the semantic handler.  */
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_rte", (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_seth:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_seth.f
    UINT f_r1;
    UINT f_hi16;

    f_r1 = EXTRACT_MSB0_UINT (insn, 32, 4, 4);
    f_hi16 = EXTRACT_MSB0_UINT (insn, 32, 16, 16);

  /* Record the fields for the semantic handler.  */
  FLD (f_hi16) = f_hi16;
  FLD (f_r1) = f_r1;
  FLD (i_dr) = & CPU (h_gr)[f_r1];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_seth", "f_hi16 0x%x", 'x', f_hi16, "f_r1 0x%x", 'x', f_r1, "dr 0x%x", 'x', f_r1, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (out_dr) = f_r1;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_sll3:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_add3.f
    UINT f_r1;
    UINT f_r2;
    INT f_simm16;

    f_r1 = EXTRACT_MSB0_UINT (insn, 32, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 32, 12, 4);
    f_simm16 = EXTRACT_MSB0_SINT (insn, 32, 16, 16);

  /* Record the fields for the semantic handler.  */
  FLD (f_simm16) = f_simm16;
  FLD (f_r2) = f_r2;
  FLD (f_r1) = f_r1;
  FLD (i_sr) = & CPU (h_gr)[f_r2];
  FLD (i_dr) = & CPU (h_gr)[f_r1];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_sll3", "f_simm16 0x%x", 'x', f_simm16, "f_r2 0x%x", 'x', f_r2, "f_r1 0x%x", 'x', f_r1, "sr 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_sr) = f_r2;
      FLD (out_dr) = f_r1;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_slli:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_slli.f
    UINT f_r1;
    UINT f_uimm5;

    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_uimm5 = EXTRACT_MSB0_UINT (insn, 16, 11, 5);

  /* Record the fields for the semantic handler.  */
  FLD (f_r1) = f_r1;
  FLD (f_uimm5) = f_uimm5;
  FLD (i_dr) = & CPU (h_gr)[f_r1];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_slli", "f_r1 0x%x", 'x', f_r1, "f_uimm5 0x%x", 'x', f_uimm5, "dr 0x%x", 'x', f_r1, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_dr) = f_r1;
      FLD (out_dr) = f_r1;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_st:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_st_plus.f
    UINT f_r1;
    UINT f_r2;

    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);

  /* Record the fields for the semantic handler.  */
  FLD (f_r1) = f_r1;
  FLD (f_r2) = f_r2;
  FLD (i_src1) = & CPU (h_gr)[f_r1];
  FLD (i_src2) = & CPU (h_gr)[f_r2];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_st", "f_r1 0x%x", 'x', f_r1, "f_r2 0x%x", 'x', f_r2, "src1 0x%x", 'x', f_r1, "src2 0x%x", 'x', f_r2, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_src1) = f_r1;
      FLD (in_src2) = f_r2;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_st_d:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_st_d.f
    UINT f_r1;
    UINT f_r2;
    INT f_simm16;

    f_r1 = EXTRACT_MSB0_UINT (insn, 32, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 32, 12, 4);
    f_simm16 = EXTRACT_MSB0_SINT (insn, 32, 16, 16);

  /* Record the fields for the semantic handler.  */
  FLD (f_simm16) = f_simm16;
  FLD (f_r1) = f_r1;
  FLD (f_r2) = f_r2;
  FLD (i_src1) = & CPU (h_gr)[f_r1];
  FLD (i_src2) = & CPU (h_gr)[f_r2];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_st_d", "f_simm16 0x%x", 'x', f_simm16, "f_r1 0x%x", 'x', f_r1, "f_r2 0x%x", 'x', f_r2, "src1 0x%x", 'x', f_r1, "src2 0x%x", 'x', f_r2, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_src1) = f_r1;
      FLD (in_src2) = f_r2;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_stb:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_st_plus.f
    UINT f_r1;
    UINT f_r2;

    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);

  /* Record the fields for the semantic handler.  */
  FLD (f_r1) = f_r1;
  FLD (f_r2) = f_r2;
  FLD (i_src1) = & CPU (h_gr)[f_r1];
  FLD (i_src2) = & CPU (h_gr)[f_r2];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_stb", "f_r1 0x%x", 'x', f_r1, "f_r2 0x%x", 'x', f_r2, "src1 0x%x", 'x', f_r1, "src2 0x%x", 'x', f_r2, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_src1) = f_r1;
      FLD (in_src2) = f_r2;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_stb_d:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_st_d.f
    UINT f_r1;
    UINT f_r2;
    INT f_simm16;

    f_r1 = EXTRACT_MSB0_UINT (insn, 32, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 32, 12, 4);
    f_simm16 = EXTRACT_MSB0_SINT (insn, 32, 16, 16);

  /* Record the fields for the semantic handler.  */
  FLD (f_simm16) = f_simm16;
  FLD (f_r1) = f_r1;
  FLD (f_r2) = f_r2;
  FLD (i_src1) = & CPU (h_gr)[f_r1];
  FLD (i_src2) = & CPU (h_gr)[f_r2];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_stb_d", "f_simm16 0x%x", 'x', f_simm16, "f_r1 0x%x", 'x', f_r1, "f_r2 0x%x", 'x', f_r2, "src1 0x%x", 'x', f_r1, "src2 0x%x", 'x', f_r2, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_src1) = f_r1;
      FLD (in_src2) = f_r2;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_sth:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_st_plus.f
    UINT f_r1;
    UINT f_r2;

    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);

  /* Record the fields for the semantic handler.  */
  FLD (f_r1) = f_r1;
  FLD (f_r2) = f_r2;
  FLD (i_src1) = & CPU (h_gr)[f_r1];
  FLD (i_src2) = & CPU (h_gr)[f_r2];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_sth", "f_r1 0x%x", 'x', f_r1, "f_r2 0x%x", 'x', f_r2, "src1 0x%x", 'x', f_r1, "src2 0x%x", 'x', f_r2, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_src1) = f_r1;
      FLD (in_src2) = f_r2;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_sth_d:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_st_d.f
    UINT f_r1;
    UINT f_r2;
    INT f_simm16;

    f_r1 = EXTRACT_MSB0_UINT (insn, 32, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 32, 12, 4);
    f_simm16 = EXTRACT_MSB0_SINT (insn, 32, 16, 16);

  /* Record the fields for the semantic handler.  */
  FLD (f_simm16) = f_simm16;
  FLD (f_r1) = f_r1;
  FLD (f_r2) = f_r2;
  FLD (i_src1) = & CPU (h_gr)[f_r1];
  FLD (i_src2) = & CPU (h_gr)[f_r2];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_sth_d", "f_simm16 0x%x", 'x', f_simm16, "f_r1 0x%x", 'x', f_r1, "f_r2 0x%x", 'x', f_r2, "src1 0x%x", 'x', f_r1, "src2 0x%x", 'x', f_r2, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_src1) = f_r1;
      FLD (in_src2) = f_r2;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_st_plus:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_st_plus.f
    UINT f_r1;
    UINT f_r2;

    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);

  /* Record the fields for the semantic handler.  */
  FLD (f_r1) = f_r1;
  FLD (f_r2) = f_r2;
  FLD (i_src1) = & CPU (h_gr)[f_r1];
  FLD (i_src2) = & CPU (h_gr)[f_r2];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_st_plus", "f_r1 0x%x", 'x', f_r1, "f_r2 0x%x", 'x', f_r2, "src1 0x%x", 'x', f_r1, "src2 0x%x", 'x', f_r2, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_src1) = f_r1;
      FLD (in_src2) = f_r2;
      FLD (out_src2) = f_r2;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_trap:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_trap.f
    UINT f_uimm4;

    f_uimm4 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);

  /* Record the fields for the semantic handler.  */
  FLD (f_uimm4) = f_uimm4;
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_trap", "f_uimm4 0x%x", 'x', f_uimm4, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_unlock:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_st_plus.f
    UINT f_r1;
    UINT f_r2;

    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);

  /* Record the fields for the semantic handler.  */
  FLD (f_r1) = f_r1;
  FLD (f_r2) = f_r2;
  FLD (i_src1) = & CPU (h_gr)[f_r1];
  FLD (i_src2) = & CPU (h_gr)[f_r2];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_unlock", "f_r1 0x%x", 'x', f_r1, "f_r2 0x%x", 'x', f_r2, "src1 0x%x", 'x', f_r1, "src2 0x%x", 'x', f_r2, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_src1) = f_r1;
      FLD (in_src2) = f_r2;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_clrpsw:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_clrpsw.f
    UINT f_uimm8;

    f_uimm8 = EXTRACT_MSB0_UINT (insn, 16, 8, 8);

  /* Record the fields for the semantic handler.  */
  FLD (f_uimm8) = f_uimm8;
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_clrpsw", "f_uimm8 0x%x", 'x', f_uimm8, (char *) 0));

#undef FLD
    return idesc;
  }

 extract_sfmt_setpsw:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_clrpsw.f
    UINT f_uimm8;

    f_uimm8 = EXTRACT_MSB0_UINT (insn, 16, 8, 8);

  /* Record the fields for the semantic handler.  */
  FLD (f_uimm8) = f_uimm8;
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_setpsw", "f_uimm8 0x%x", 'x', f_uimm8, (char *) 0));

#undef FLD
    return idesc;
  }

 extract_sfmt_bset:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_bset.f
    UINT f_uimm3;
    UINT f_r2;
    INT f_simm16;

    f_uimm3 = EXTRACT_MSB0_UINT (insn, 32, 5, 3);
    f_r2 = EXTRACT_MSB0_UINT (insn, 32, 12, 4);
    f_simm16 = EXTRACT_MSB0_SINT (insn, 32, 16, 16);

  /* Record the fields for the semantic handler.  */
  FLD (f_simm16) = f_simm16;
  FLD (f_r2) = f_r2;
  FLD (f_uimm3) = f_uimm3;
  FLD (i_sr) = & CPU (h_gr)[f_r2];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_bset", "f_simm16 0x%x", 'x', f_simm16, "f_r2 0x%x", 'x', f_r2, "f_uimm3 0x%x", 'x', f_uimm3, "sr 0x%x", 'x', f_r2, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_sr) = f_r2;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_btst:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_WORD insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_bset.f
    UINT f_uimm3;
    UINT f_r2;

    f_uimm3 = EXTRACT_MSB0_UINT (insn, 16, 5, 3);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);

  /* Record the fields for the semantic handler.  */
  FLD (f_r2) = f_r2;
  FLD (f_uimm3) = f_uimm3;
  FLD (i_sr) = & CPU (h_gr)[f_r2];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_btst", "f_r2 0x%x", 'x', f_r2, "f_uimm3 0x%x", 'x', f_uimm3, "sr 0x%x", 'x', f_r2, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_sr) = f_r2;
    }
#endif
#undef FLD
    return idesc;
  }

}
@


1.14
log
@[sim] Update old contact info in GPL license notices

sim/ChangeLog:

        Update old contact info in GPL license notices.
@
text
@d5 1
a5 1
Copyright 1996-2010, 2012 Free Software Foundation, Inc.
@


1.13
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d20 1
a20 2
   with this program; if not, write to the Free Software Foundation, Inc.,
   51 Franklin Street - Fifth Floor, Boston, MA 02110-1301, USA.
@


1.12
log
@Regenerate cgen-derived files.
@
text
@d5 1
a5 1
Copyright 1996-2010 Free Software Foundation, Inc.
@


1.12.8.1
log
@Copyright year update in most files of the GDB Project.

gdb/ChangeLog:

        Copyright year update in most files of the GDB Project.
@
text
@d5 1
a5 1
Copyright 1996-2010, 2012 Free Software Foundation, Inc.
@


1.11
log
@Regenerate cgen files, update copyright year.
@
text
@d155 2
a156 1
static const struct insn_sem m32rbf_insn_sem_invalid = {
d577 1
a577 1
#define FLD(f) abuf->fields.fmt_empty.f
d1715 1
a1715 1
#define FLD(f) abuf->fields.fmt_empty.f
d1728 1
a1728 1
#define FLD(f) abuf->fields.fmt_empty.f
d1741 1
a1741 1
#define FLD(f) abuf->fields.fmt_empty.f
@


1.10
log
@	* cgen-engine.h (EXTRACT_MSB0_SINT): Renamed from EXTRACT_MSB0_INT.
	(EXTRACT_LSB0_SINT): Renamed from EXTRACT_LSB0_INT.
plus regenerate cgen files
@
text
@d5 1
a5 1
Copyright 1996-2009 Free Software Foundation, Inc.
@


1.9
log
@	* cgen-engine.h (EXTRACT_MSB0_LGSINT, EXTRACT_MSB0_LGUINT): Define.
	(EXTRACT_LSB0_LGSINT, EXTRACT_LSB0_LGUINT): Define.
	(EXTRACT_FN, SEMANTIC_FN): Use CGEN_INSN_WORD in prototype
	instead of CGEN_INSN_INT.
plus, cgen files: Regenerate.
@
text
@d628 1
a628 1
    f_simm16 = EXTRACT_MSB0_INT (insn, 32, 16, 16);
d725 1
a725 1
    f_simm8 = EXTRACT_MSB0_INT (insn, 16, 8, 8);
d787 1
a787 1
    f_simm16 = EXTRACT_MSB0_INT (insn, 32, 16, 16);
d847 1
a847 1
    f_disp8 = ((((EXTRACT_MSB0_INT (insn, 16, 8, 8)) << (2))) + (((pc) & (-4))));
d870 1
a870 1
    f_disp24 = ((((EXTRACT_MSB0_INT (insn, 32, 8, 24)) << (2))) + (pc));
d897 1
a897 1
    f_disp16 = ((((EXTRACT_MSB0_INT (insn, 32, 16, 16)) << (2))) + (pc));
d928 1
a928 1
    f_disp16 = ((((EXTRACT_MSB0_INT (insn, 32, 16, 16)) << (2))) + (pc));
d954 1
a954 1
    f_disp8 = ((((EXTRACT_MSB0_INT (insn, 16, 8, 8)) << (2))) + (((pc) & (-4))));
d978 1
a978 1
    f_disp24 = ((((EXTRACT_MSB0_INT (insn, 32, 8, 24)) << (2))) + (pc));
d1002 1
a1002 1
    f_disp8 = ((((EXTRACT_MSB0_INT (insn, 16, 8, 8)) << (2))) + (((pc) & (-4))));
d1025 1
a1025 1
    f_disp24 = ((((EXTRACT_MSB0_INT (insn, 32, 8, 24)) << (2))) + (pc));
d1080 1
a1080 1
    f_simm16 = EXTRACT_MSB0_INT (insn, 32, 16, 16);
d1222 1
a1222 1
    f_simm16 = EXTRACT_MSB0_INT (insn, 32, 16, 16);
d1285 1
a1285 1
    f_simm16 = EXTRACT_MSB0_INT (insn, 32, 16, 16);
d1348 1
a1348 1
    f_simm16 = EXTRACT_MSB0_INT (insn, 32, 16, 16);
d1438 1
a1438 1
    f_simm8 = EXTRACT_MSB0_INT (insn, 16, 8, 8);
d1466 1
a1466 1
    f_simm16 = EXTRACT_MSB0_INT (insn, 32, 16, 16);
d1795 1
a1795 1
    f_simm16 = EXTRACT_MSB0_INT (insn, 32, 16, 16);
d1887 1
a1887 1
    f_simm16 = EXTRACT_MSB0_INT (insn, 32, 16, 16);
d1950 1
a1950 1
    f_simm16 = EXTRACT_MSB0_INT (insn, 32, 16, 16);
d2013 1
a2013 1
    f_simm16 = EXTRACT_MSB0_INT (insn, 32, 16, 16);
d2164 1
a2164 1
    f_simm16 = EXTRACT_MSB0_INT (insn, 32, 16, 16);
@


1.8
log
@	* arch.c: Regenerate.
	* arch.h: Regenerate.
	* cpu.c: Regenerate.
	* cpu.h: Regenerate.
	* cpu2.c: Regenerate.
	* cpu2.h: Regenerate.
	* cpuall.h: Regenerate.
	* cpux.c: Regenerate.
	* cpux.h: Regenerate.
	* decode.c: Regenerate.
	* decode.h: Regenerate.
	* decode2.c: Regenerate.
	* decode2.h: Regenerate.
	* decodex.c: Regenerate.
	* decodex.h: Regenerate.
	* model.c: Regenerate.
	* model2.c: Regenerate.
	* modelx.c: Regenerate.
	* sem-switch.c: Regenerate.
	* sem.c: Regenerate.
	* sem2-switch.c: Regenerate.
	* semx-switch.c: Regenerate.
@
text
@d219 1
a219 1
              CGEN_INSN_INT base_insn, CGEN_INSN_INT entire_insn,
d226 1
a226 1
    CGEN_INSN_INT insn = base_insn;
d589 1
a589 1
    CGEN_INSN_INT insn = entire_insn;
d620 1
a620 1
    CGEN_INSN_INT insn = entire_insn;
d653 1
a653 1
    CGEN_INSN_INT insn = entire_insn;
d686 1
a686 1
    CGEN_INSN_INT insn = entire_insn;
d719 1
a719 1
    CGEN_INSN_INT insn = entire_insn;
d748 1
a748 1
    CGEN_INSN_INT insn = entire_insn;
d779 1
a779 1
    CGEN_INSN_INT insn = entire_insn;
d812 1
a812 1
    CGEN_INSN_INT insn = entire_insn;
d843 1
a843 1
    CGEN_INSN_INT insn = entire_insn;
d866 1
a866 1
    CGEN_INSN_INT insn = entire_insn;
d889 1
a889 1
    CGEN_INSN_INT insn = entire_insn;
d922 1
a922 1
    CGEN_INSN_INT insn = entire_insn;
d950 1
a950 1
    CGEN_INSN_INT insn = entire_insn;
d974 1
a974 1
    CGEN_INSN_INT insn = entire_insn;
d998 1
a998 1
    CGEN_INSN_INT insn = entire_insn;
d1021 1
a1021 1
    CGEN_INSN_INT insn = entire_insn;
d1044 1
a1044 1
    CGEN_INSN_INT insn = entire_insn;
d1074 1
a1074 1
    CGEN_INSN_INT insn = entire_insn;
d1102 1
a1102 1
    CGEN_INSN_INT insn = entire_insn;
d1133 1
a1133 1
    CGEN_INSN_INT insn = entire_insn;
d1159 1
a1159 1
    CGEN_INSN_INT insn = entire_insn;
d1184 1
a1184 1
    CGEN_INSN_INT insn = entire_insn;
d1214 1
a1214 1
    CGEN_INSN_INT insn = entire_insn;
d1247 1
a1247 1
    CGEN_INSN_INT insn = entire_insn;
d1277 1
a1277 1
    CGEN_INSN_INT insn = entire_insn;
d1310 1
a1310 1
    CGEN_INSN_INT insn = entire_insn;
d1340 1
a1340 1
    CGEN_INSN_INT insn = entire_insn;
d1373 1
a1373 1
    CGEN_INSN_INT insn = entire_insn;
d1404 1
a1404 1
    CGEN_INSN_INT insn = entire_insn;
d1432 1
a1432 1
    CGEN_INSN_INT insn = entire_insn;
d1460 1
a1460 1
    CGEN_INSN_INT insn = entire_insn;
d1488 1
a1488 1
    CGEN_INSN_INT insn = entire_insn;
d1518 1
a1518 1
    CGEN_INSN_INT insn = entire_insn;
d1548 1
a1548 1
    CGEN_INSN_INT insn = entire_insn;
d1578 1
a1578 1
    CGEN_INSN_INT insn = entire_insn;
d1608 1
a1608 1
    CGEN_INSN_INT insn = entire_insn;
d1633 1
a1633 1
    CGEN_INSN_INT insn = entire_insn;
d1661 1
a1661 1
    CGEN_INSN_INT insn = entire_insn;
d1686 1
a1686 1
    CGEN_INSN_INT insn = entire_insn;
d1759 1
a1759 1
    CGEN_INSN_INT insn = entire_insn;
d1787 1
a1787 1
    CGEN_INSN_INT insn = entire_insn;
d1820 1
a1820 1
    CGEN_INSN_INT insn = entire_insn;
d1849 1
a1849 1
    CGEN_INSN_INT insn = entire_insn;
d1879 1
a1879 1
    CGEN_INSN_INT insn = entire_insn;
d1912 1
a1912 1
    CGEN_INSN_INT insn = entire_insn;
d1942 1
a1942 1
    CGEN_INSN_INT insn = entire_insn;
d1975 1
a1975 1
    CGEN_INSN_INT insn = entire_insn;
d2005 1
a2005 1
    CGEN_INSN_INT insn = entire_insn;
d2038 1
a2038 1
    CGEN_INSN_INT insn = entire_insn;
d2069 1
a2069 1
    CGEN_INSN_INT insn = entire_insn;
d2092 1
a2092 1
    CGEN_INSN_INT insn = entire_insn;
d2122 1
a2122 1
    CGEN_INSN_INT insn = entire_insn;
d2139 1
a2139 1
    CGEN_INSN_INT insn = entire_insn;
d2156 1
a2156 1
    CGEN_INSN_INT insn = entire_insn;
d2187 1
a2187 1
    CGEN_INSN_INT insn = entire_insn;
@


1.7
log
@        Switch the license of all files explicitly copyright the FSF
        to GPLv3.
@
text
@d5 1
a5 1
Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d9 13
a21 12
This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 3 of the License, or
(at your option) any later version.

This program is distributed in the hope that it will be useful,
but WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
GNU General Public License for more details.

You should have received a copy of the GNU General Public License
along with this program.  If not, see <http://www.gnu.org/licenses/>.
d245 4
a248 1
      case 15 : itype = M32RBF_INSN_BTST; goto extract_sfmt_btst;
d261 8
a268 2
          case 0 : itype = M32RBF_INSN_JL; goto extract_sfmt_jl;
          case 1 : itype = M32RBF_INSN_JMP; goto extract_sfmt_jmp;
d272 8
a279 2
      case 29 : itype = M32RBF_INSN_RTE; goto extract_sfmt_rte;
      case 31 : itype = M32RBF_INSN_TRAP; goto extract_sfmt_trap;
d328 8
a335 2
          case 0 : itype = M32RBF_INSN_MVTACHI; goto extract_sfmt_mvtachi;
          case 1 : itype = M32RBF_INSN_MVTACLO; goto extract_sfmt_mvtachi;
d339 8
a346 2
      case 88 : itype = M32RBF_INSN_RACH; goto extract_sfmt_rac;
      case 89 : itype = M32RBF_INSN_RAC; goto extract_sfmt_rac;
d352 12
a363 3
          case 0 : itype = M32RBF_INSN_MVFACHI; goto extract_sfmt_mvfachi;
          case 1 : itype = M32RBF_INSN_MVFACLO; goto extract_sfmt_mvfachi;
          case 2 : itype = M32RBF_INSN_MVFACMI; goto extract_sfmt_mvfachi;
d388 4
a391 1
          case 0 : itype = M32RBF_INSN_NOP; goto extract_sfmt_nop;
d429 8
a436 2
      case 132 : itype = M32RBF_INSN_CMPI; goto extract_sfmt_cmpi;
      case 133 : itype = M32RBF_INSN_CMPUI; goto extract_sfmt_cmpi;
d442 16
a457 4
      case 144 : itype = M32RBF_INSN_DIV; goto extract_sfmt_div;
      case 145 : itype = M32RBF_INSN_DIVU; goto extract_sfmt_div;
      case 146 : itype = M32RBF_INSN_REM; goto extract_sfmt_div;
      case 147 : itype = M32RBF_INSN_REMU; goto extract_sfmt_div;
d461 4
a464 1
      case 159 : itype = M32RBF_INSN_LDI16; goto extract_sfmt_ldi16;
d468 8
a475 2
      case 166 : itype = M32RBF_INSN_BSET; goto extract_sfmt_bset;
      case 167 : itype = M32RBF_INSN_BCLR; goto extract_sfmt_bset;
d483 28
a510 7
      case 184 : itype = M32RBF_INSN_BEQZ; goto extract_sfmt_beqz;
      case 185 : itype = M32RBF_INSN_BNEZ; goto extract_sfmt_beqz;
      case 186 : itype = M32RBF_INSN_BLTZ; goto extract_sfmt_beqz;
      case 187 : itype = M32RBF_INSN_BGEZ; goto extract_sfmt_beqz;
      case 188 : itype = M32RBF_INSN_BLEZ; goto extract_sfmt_beqz;
      case 189 : itype = M32RBF_INSN_BGTZ; goto extract_sfmt_beqz;
      case 220 : itype = M32RBF_INSN_SETH; goto extract_sfmt_seth;
d547 16
a562 4
          case 0 : itype = M32RBF_INSN_BC24; goto extract_sfmt_bc24;
          case 1 : itype = M32RBF_INSN_BNC24; goto extract_sfmt_bc24;
          case 2 : itype = M32RBF_INSN_BL24; goto extract_sfmt_bl24;
          case 3 : itype = M32RBF_INSN_BRA24; goto extract_sfmt_bra24;
@


1.6
log
@Add support for the m32r2 processor
@
text
@d11 2
a12 2
the Free Software Foundation; either version 2, or (at your option)
any later version.
d19 2
a20 3
You should have received a copy of the GNU General Public License along
with this program; if not, write to the Free Software Foundation, Inc.,
59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.
@


1.5
log
@	* arch.c,arch.h,cpuall.h: Regenerate.
	* cpu.c,cpu.h,decode.c,decode.h,model.c,sem-switch.c,sem.c: Regenerate.
	* cpux.c,cpux.h,decodex.c,decodex.h,modelx.c,semx-switch.c: Regenerate.
@
text
@d5 1
a5 1
Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d148 5
d245 1
d353 2
d378 1
a378 1
          unsigned int val = (((insn >> 8) & (3 << 0)));
d381 6
a386 4
          case 0 : itype = M32RBF_INSN_BC8; goto extract_sfmt_bc8;
          case 1 : itype = M32RBF_INSN_BNC8; goto extract_sfmt_bc8;
          case 2 : itype = M32RBF_INSN_BL8; goto extract_sfmt_bl8;
          case 3 : itype = M32RBF_INSN_BRA8; goto extract_sfmt_bra8;
d408 2
d2014 93
@


1.4
log
@2001-11-14  Dave Brolley  <brolley@@redhat.com>

	* arch.c: Regenerate.
	* arch.h: Regenerate.
	* cpu.c: Regenerate.
	* cpu.h: Regenerate.
	* cpuall.h: Regenerate.
	* cpux.c: Regenerate.
	* cpux.h: Regenerate.
	* decode.c: Regenerate.
	* decode.h: Regenerate.
	* decodex.c: Regenerate.
	* decodex.h: Regenerate.
	* model.c: Regenerate.
	* modelx.c: Regenerate.
	* sem-switch.c: Regenerate.
	* sem.c: Regenerate.
	* semx-switch.c: Regenerate.
@
text
@d5 1
a5 1
Copyright 1996, 1997, 1998, 1999, 2000, 2001 Free Software Foundation, Inc.
d36 1
a36 1
static IDESC m32rbf_insn_data[M32RBF_INSN_UNLOCK + 1];
d189 1
a189 1
  int tabsize = sizeof (m32rbf_insn_data) / sizeof (IDESC);
d227 20
a246 20
      case 0 : itype = M32RBF_INSN_SUBV;goto extract_sfmt_addv;
      case 1 : itype = M32RBF_INSN_SUBX;goto extract_sfmt_addx;
      case 2 : itype = M32RBF_INSN_SUB;goto extract_sfmt_add;
      case 3 : itype = M32RBF_INSN_NEG;goto extract_sfmt_mv;
      case 4 : itype = M32RBF_INSN_CMP;goto extract_sfmt_cmp;
      case 5 : itype = M32RBF_INSN_CMPU;goto extract_sfmt_cmp;
      case 8 : itype = M32RBF_INSN_ADDV;goto extract_sfmt_addv;
      case 9 : itype = M32RBF_INSN_ADDX;goto extract_sfmt_addx;
      case 10 : itype = M32RBF_INSN_ADD;goto extract_sfmt_add;
      case 11 : itype = M32RBF_INSN_NOT;goto extract_sfmt_mv;
      case 12 : itype = M32RBF_INSN_AND;goto extract_sfmt_add;
      case 13 : itype = M32RBF_INSN_XOR;goto extract_sfmt_add;
      case 14 : itype = M32RBF_INSN_OR;goto extract_sfmt_add;
      case 16 : itype = M32RBF_INSN_SRL;goto extract_sfmt_add;
      case 18 : itype = M32RBF_INSN_SRA;goto extract_sfmt_add;
      case 20 : itype = M32RBF_INSN_SLL;goto extract_sfmt_add;
      case 22 : itype = M32RBF_INSN_MUL;goto extract_sfmt_add;
      case 24 : itype = M32RBF_INSN_MV;goto extract_sfmt_mv;
      case 25 : itype = M32RBF_INSN_MVFC;goto extract_sfmt_mvfc;
      case 26 : itype = M32RBF_INSN_MVTC;goto extract_sfmt_mvtc;
d252 2
a253 2
          case 0 : itype = M32RBF_INSN_JL;goto extract_sfmt_jl;
          case 1 : itype = M32RBF_INSN_JMP;goto extract_sfmt_jmp;
d257 23
a279 23
      case 29 : itype = M32RBF_INSN_RTE;goto extract_sfmt_rte;
      case 31 : itype = M32RBF_INSN_TRAP;goto extract_sfmt_trap;
      case 32 : itype = M32RBF_INSN_STB;goto extract_sfmt_stb;
      case 34 : itype = M32RBF_INSN_STH;goto extract_sfmt_sth;
      case 36 : itype = M32RBF_INSN_ST;goto extract_sfmt_st;
      case 37 : itype = M32RBF_INSN_UNLOCK;goto extract_sfmt_unlock;
      case 38 : itype = M32RBF_INSN_ST_PLUS;goto extract_sfmt_st_plus;
      case 39 : itype = M32RBF_INSN_ST_MINUS;goto extract_sfmt_st_plus;
      case 40 : itype = M32RBF_INSN_LDB;goto extract_sfmt_ldb;
      case 41 : itype = M32RBF_INSN_LDUB;goto extract_sfmt_ldb;
      case 42 : itype = M32RBF_INSN_LDH;goto extract_sfmt_ldh;
      case 43 : itype = M32RBF_INSN_LDUH;goto extract_sfmt_ldh;
      case 44 : itype = M32RBF_INSN_LD;goto extract_sfmt_ld;
      case 45 : itype = M32RBF_INSN_LOCK;goto extract_sfmt_lock;
      case 46 : itype = M32RBF_INSN_LD_PLUS;goto extract_sfmt_ld_plus;
      case 48 : itype = M32RBF_INSN_MULHI;goto extract_sfmt_mulhi;
      case 49 : itype = M32RBF_INSN_MULLO;goto extract_sfmt_mulhi;
      case 50 : itype = M32RBF_INSN_MULWHI;goto extract_sfmt_mulhi;
      case 51 : itype = M32RBF_INSN_MULWLO;goto extract_sfmt_mulhi;
      case 52 : itype = M32RBF_INSN_MACHI;goto extract_sfmt_machi;
      case 53 : itype = M32RBF_INSN_MACLO;goto extract_sfmt_machi;
      case 54 : itype = M32RBF_INSN_MACWHI;goto extract_sfmt_machi;
      case 55 : itype = M32RBF_INSN_MACWLO;goto extract_sfmt_machi;
d295 1
a295 1
      case 79 : itype = M32RBF_INSN_ADDI;goto extract_sfmt_addi;
d297 1
a297 1
      case 81 : itype = M32RBF_INSN_SRLI;goto extract_sfmt_slli;
d299 1
a299 1
      case 83 : itype = M32RBF_INSN_SRAI;goto extract_sfmt_slli;
d301 1
a301 1
      case 85 : itype = M32RBF_INSN_SLLI;goto extract_sfmt_slli;
d307 2
a308 2
          case 0 : itype = M32RBF_INSN_MVTACHI;goto extract_sfmt_mvtachi;
          case 1 : itype = M32RBF_INSN_MVTACLO;goto extract_sfmt_mvtachi;
d312 2
a313 2
      case 88 : itype = M32RBF_INSN_RACH;goto extract_sfmt_rac;
      case 89 : itype = M32RBF_INSN_RAC;goto extract_sfmt_rac;
d319 3
a321 3
          case 0 : itype = M32RBF_INSN_MVFACHI;goto extract_sfmt_mvfachi;
          case 1 : itype = M32RBF_INSN_MVFACLO;goto extract_sfmt_mvfachi;
          case 2 : itype = M32RBF_INSN_MVFACMI;goto extract_sfmt_mvfachi;
d340 1
a340 1
      case 111 : itype = M32RBF_INSN_LDI8;goto extract_sfmt_ldi8;
d346 5
a350 5
          case 0 : itype = M32RBF_INSN_NOP;goto extract_sfmt_nop;
          case 12 : itype = M32RBF_INSN_BC8;goto extract_sfmt_bc8;
          case 13 : itype = M32RBF_INSN_BNC8;goto extract_sfmt_bc8;
          case 14 : itype = M32RBF_INSN_BL8;goto extract_sfmt_bl8;
          case 15 : itype = M32RBF_INSN_BRA8;goto extract_sfmt_bra8;
d373 4
a376 4
          case 0 : itype = M32RBF_INSN_BC8;goto extract_sfmt_bc8;
          case 1 : itype = M32RBF_INSN_BNC8;goto extract_sfmt_bc8;
          case 2 : itype = M32RBF_INSN_BL8;goto extract_sfmt_bl8;
          case 3 : itype = M32RBF_INSN_BRA8;goto extract_sfmt_bra8;
d380 32
a411 32
      case 132 : itype = M32RBF_INSN_CMPI;goto extract_sfmt_cmpi;
      case 133 : itype = M32RBF_INSN_CMPUI;goto extract_sfmt_cmpi;
      case 136 : itype = M32RBF_INSN_ADDV3;goto extract_sfmt_addv3;
      case 138 : itype = M32RBF_INSN_ADD3;goto extract_sfmt_add3;
      case 140 : itype = M32RBF_INSN_AND3;goto extract_sfmt_and3;
      case 141 : itype = M32RBF_INSN_XOR3;goto extract_sfmt_and3;
      case 142 : itype = M32RBF_INSN_OR3;goto extract_sfmt_or3;
      case 144 : itype = M32RBF_INSN_DIV;goto extract_sfmt_div;
      case 145 : itype = M32RBF_INSN_DIVU;goto extract_sfmt_div;
      case 146 : itype = M32RBF_INSN_REM;goto extract_sfmt_div;
      case 147 : itype = M32RBF_INSN_REMU;goto extract_sfmt_div;
      case 152 : itype = M32RBF_INSN_SRL3;goto extract_sfmt_sll3;
      case 154 : itype = M32RBF_INSN_SRA3;goto extract_sfmt_sll3;
      case 156 : itype = M32RBF_INSN_SLL3;goto extract_sfmt_sll3;
      case 159 : itype = M32RBF_INSN_LDI16;goto extract_sfmt_ldi16;
      case 160 : itype = M32RBF_INSN_STB_D;goto extract_sfmt_stb_d;
      case 162 : itype = M32RBF_INSN_STH_D;goto extract_sfmt_sth_d;
      case 164 : itype = M32RBF_INSN_ST_D;goto extract_sfmt_st_d;
      case 168 : itype = M32RBF_INSN_LDB_D;goto extract_sfmt_ldb_d;
      case 169 : itype = M32RBF_INSN_LDUB_D;goto extract_sfmt_ldb_d;
      case 170 : itype = M32RBF_INSN_LDH_D;goto extract_sfmt_ldh_d;
      case 171 : itype = M32RBF_INSN_LDUH_D;goto extract_sfmt_ldh_d;
      case 172 : itype = M32RBF_INSN_LD_D;goto extract_sfmt_ld_d;
      case 176 : itype = M32RBF_INSN_BEQ;goto extract_sfmt_beq;
      case 177 : itype = M32RBF_INSN_BNE;goto extract_sfmt_beq;
      case 184 : itype = M32RBF_INSN_BEQZ;goto extract_sfmt_beqz;
      case 185 : itype = M32RBF_INSN_BNEZ;goto extract_sfmt_beqz;
      case 186 : itype = M32RBF_INSN_BLTZ;goto extract_sfmt_beqz;
      case 187 : itype = M32RBF_INSN_BGEZ;goto extract_sfmt_beqz;
      case 188 : itype = M32RBF_INSN_BLEZ;goto extract_sfmt_beqz;
      case 189 : itype = M32RBF_INSN_BGTZ;goto extract_sfmt_beqz;
      case 220 : itype = M32RBF_INSN_SETH;goto extract_sfmt_seth;
d427 1
a427 1
      case 239 : itype = M32RBF_INSN_LD24;goto extract_sfmt_ld24;
d448 4
a451 4
          case 0 : itype = M32RBF_INSN_BC24;goto extract_sfmt_bc24;
          case 1 : itype = M32RBF_INSN_BNC24;goto extract_sfmt_bc24;
          case 2 : itype = M32RBF_INSN_BL24;goto extract_sfmt_bl24;
          case 3 : itype = M32RBF_INSN_BRA24;goto extract_sfmt_bra24;
@


1.4.18.1
log
@Merge drow-cplus-branch to:
  cvs rtag -D 2003-12-14 00:00:00 UTC drow-cplus-merge-20031214 gdb+dejagnu
@
text
@d5 1
a5 1
Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
d36 1
a36 1
static IDESC m32rbf_insn_data[M32RBF_INSN__MAX];
a147 5
  { M32R_INSN_CLRPSW, M32RBF_INSN_CLRPSW, M32RBF_SFMT_CLRPSW },
  { M32R_INSN_SETPSW, M32RBF_INSN_SETPSW, M32RBF_SFMT_SETPSW },
  { M32R_INSN_BSET, M32RBF_INSN_BSET, M32RBF_SFMT_BSET },
  { M32R_INSN_BCLR, M32RBF_INSN_BCLR, M32RBF_SFMT_BSET },
  { M32R_INSN_BTST, M32RBF_INSN_BTST, M32RBF_SFMT_BTST },
d189 1
a189 1
  int tabsize = M32RBF_INSN__MAX;
d227 20
a246 21
      case 0 : itype = M32RBF_INSN_SUBV; goto extract_sfmt_addv;
      case 1 : itype = M32RBF_INSN_SUBX; goto extract_sfmt_addx;
      case 2 : itype = M32RBF_INSN_SUB; goto extract_sfmt_add;
      case 3 : itype = M32RBF_INSN_NEG; goto extract_sfmt_mv;
      case 4 : itype = M32RBF_INSN_CMP; goto extract_sfmt_cmp;
      case 5 : itype = M32RBF_INSN_CMPU; goto extract_sfmt_cmp;
      case 8 : itype = M32RBF_INSN_ADDV; goto extract_sfmt_addv;
      case 9 : itype = M32RBF_INSN_ADDX; goto extract_sfmt_addx;
      case 10 : itype = M32RBF_INSN_ADD; goto extract_sfmt_add;
      case 11 : itype = M32RBF_INSN_NOT; goto extract_sfmt_mv;
      case 12 : itype = M32RBF_INSN_AND; goto extract_sfmt_add;
      case 13 : itype = M32RBF_INSN_XOR; goto extract_sfmt_add;
      case 14 : itype = M32RBF_INSN_OR; goto extract_sfmt_add;
      case 15 : itype = M32RBF_INSN_BTST; goto extract_sfmt_btst;
      case 16 : itype = M32RBF_INSN_SRL; goto extract_sfmt_add;
      case 18 : itype = M32RBF_INSN_SRA; goto extract_sfmt_add;
      case 20 : itype = M32RBF_INSN_SLL; goto extract_sfmt_add;
      case 22 : itype = M32RBF_INSN_MUL; goto extract_sfmt_add;
      case 24 : itype = M32RBF_INSN_MV; goto extract_sfmt_mv;
      case 25 : itype = M32RBF_INSN_MVFC; goto extract_sfmt_mvfc;
      case 26 : itype = M32RBF_INSN_MVTC; goto extract_sfmt_mvtc;
d252 2
a253 2
          case 0 : itype = M32RBF_INSN_JL; goto extract_sfmt_jl;
          case 1 : itype = M32RBF_INSN_JMP; goto extract_sfmt_jmp;
d257 23
a279 23
      case 29 : itype = M32RBF_INSN_RTE; goto extract_sfmt_rte;
      case 31 : itype = M32RBF_INSN_TRAP; goto extract_sfmt_trap;
      case 32 : itype = M32RBF_INSN_STB; goto extract_sfmt_stb;
      case 34 : itype = M32RBF_INSN_STH; goto extract_sfmt_sth;
      case 36 : itype = M32RBF_INSN_ST; goto extract_sfmt_st;
      case 37 : itype = M32RBF_INSN_UNLOCK; goto extract_sfmt_unlock;
      case 38 : itype = M32RBF_INSN_ST_PLUS; goto extract_sfmt_st_plus;
      case 39 : itype = M32RBF_INSN_ST_MINUS; goto extract_sfmt_st_plus;
      case 40 : itype = M32RBF_INSN_LDB; goto extract_sfmt_ldb;
      case 41 : itype = M32RBF_INSN_LDUB; goto extract_sfmt_ldb;
      case 42 : itype = M32RBF_INSN_LDH; goto extract_sfmt_ldh;
      case 43 : itype = M32RBF_INSN_LDUH; goto extract_sfmt_ldh;
      case 44 : itype = M32RBF_INSN_LD; goto extract_sfmt_ld;
      case 45 : itype = M32RBF_INSN_LOCK; goto extract_sfmt_lock;
      case 46 : itype = M32RBF_INSN_LD_PLUS; goto extract_sfmt_ld_plus;
      case 48 : itype = M32RBF_INSN_MULHI; goto extract_sfmt_mulhi;
      case 49 : itype = M32RBF_INSN_MULLO; goto extract_sfmt_mulhi;
      case 50 : itype = M32RBF_INSN_MULWHI; goto extract_sfmt_mulhi;
      case 51 : itype = M32RBF_INSN_MULWLO; goto extract_sfmt_mulhi;
      case 52 : itype = M32RBF_INSN_MACHI; goto extract_sfmt_machi;
      case 53 : itype = M32RBF_INSN_MACLO; goto extract_sfmt_machi;
      case 54 : itype = M32RBF_INSN_MACWHI; goto extract_sfmt_machi;
      case 55 : itype = M32RBF_INSN_MACWLO; goto extract_sfmt_machi;
d295 1
a295 1
      case 79 : itype = M32RBF_INSN_ADDI; goto extract_sfmt_addi;
d297 1
a297 1
      case 81 : itype = M32RBF_INSN_SRLI; goto extract_sfmt_slli;
d299 1
a299 1
      case 83 : itype = M32RBF_INSN_SRAI; goto extract_sfmt_slli;
d301 1
a301 1
      case 85 : itype = M32RBF_INSN_SLLI; goto extract_sfmt_slli;
d307 2
a308 2
          case 0 : itype = M32RBF_INSN_MVTACHI; goto extract_sfmt_mvtachi;
          case 1 : itype = M32RBF_INSN_MVTACLO; goto extract_sfmt_mvtachi;
d312 2
a313 2
      case 88 : itype = M32RBF_INSN_RACH; goto extract_sfmt_rac;
      case 89 : itype = M32RBF_INSN_RAC; goto extract_sfmt_rac;
d319 3
a321 3
          case 0 : itype = M32RBF_INSN_MVFACHI; goto extract_sfmt_mvfachi;
          case 1 : itype = M32RBF_INSN_MVFACLO; goto extract_sfmt_mvfachi;
          case 2 : itype = M32RBF_INSN_MVFACMI; goto extract_sfmt_mvfachi;
d340 1
a340 1
      case 111 : itype = M32RBF_INSN_LDI8; goto extract_sfmt_ldi8;
d346 5
a350 7
          case 0 : itype = M32RBF_INSN_NOP; goto extract_sfmt_nop;
          case 1 : itype = M32RBF_INSN_SETPSW; goto extract_sfmt_setpsw;
          case 2 : itype = M32RBF_INSN_CLRPSW; goto extract_sfmt_clrpsw;
          case 12 : itype = M32RBF_INSN_BC8; goto extract_sfmt_bc8;
          case 13 : itype = M32RBF_INSN_BNC8; goto extract_sfmt_bc8;
          case 14 : itype = M32RBF_INSN_BL8; goto extract_sfmt_bl8;
          case 15 : itype = M32RBF_INSN_BRA8; goto extract_sfmt_bra8;
d370 1
a370 1
          unsigned int val = (((insn >> 8) & (15 << 0)));
d373 4
a376 6
          case 1 : itype = M32RBF_INSN_SETPSW; goto extract_sfmt_setpsw;
          case 2 : itype = M32RBF_INSN_CLRPSW; goto extract_sfmt_clrpsw;
          case 12 : itype = M32RBF_INSN_BC8; goto extract_sfmt_bc8;
          case 13 : itype = M32RBF_INSN_BNC8; goto extract_sfmt_bc8;
          case 14 : itype = M32RBF_INSN_BL8; goto extract_sfmt_bl8;
          case 15 : itype = M32RBF_INSN_BRA8; goto extract_sfmt_bra8;
d380 32
a411 34
      case 132 : itype = M32RBF_INSN_CMPI; goto extract_sfmt_cmpi;
      case 133 : itype = M32RBF_INSN_CMPUI; goto extract_sfmt_cmpi;
      case 136 : itype = M32RBF_INSN_ADDV3; goto extract_sfmt_addv3;
      case 138 : itype = M32RBF_INSN_ADD3; goto extract_sfmt_add3;
      case 140 : itype = M32RBF_INSN_AND3; goto extract_sfmt_and3;
      case 141 : itype = M32RBF_INSN_XOR3; goto extract_sfmt_and3;
      case 142 : itype = M32RBF_INSN_OR3; goto extract_sfmt_or3;
      case 144 : itype = M32RBF_INSN_DIV; goto extract_sfmt_div;
      case 145 : itype = M32RBF_INSN_DIVU; goto extract_sfmt_div;
      case 146 : itype = M32RBF_INSN_REM; goto extract_sfmt_div;
      case 147 : itype = M32RBF_INSN_REMU; goto extract_sfmt_div;
      case 152 : itype = M32RBF_INSN_SRL3; goto extract_sfmt_sll3;
      case 154 : itype = M32RBF_INSN_SRA3; goto extract_sfmt_sll3;
      case 156 : itype = M32RBF_INSN_SLL3; goto extract_sfmt_sll3;
      case 159 : itype = M32RBF_INSN_LDI16; goto extract_sfmt_ldi16;
      case 160 : itype = M32RBF_INSN_STB_D; goto extract_sfmt_stb_d;
      case 162 : itype = M32RBF_INSN_STH_D; goto extract_sfmt_sth_d;
      case 164 : itype = M32RBF_INSN_ST_D; goto extract_sfmt_st_d;
      case 166 : itype = M32RBF_INSN_BSET; goto extract_sfmt_bset;
      case 167 : itype = M32RBF_INSN_BCLR; goto extract_sfmt_bset;
      case 168 : itype = M32RBF_INSN_LDB_D; goto extract_sfmt_ldb_d;
      case 169 : itype = M32RBF_INSN_LDUB_D; goto extract_sfmt_ldb_d;
      case 170 : itype = M32RBF_INSN_LDH_D; goto extract_sfmt_ldh_d;
      case 171 : itype = M32RBF_INSN_LDUH_D; goto extract_sfmt_ldh_d;
      case 172 : itype = M32RBF_INSN_LD_D; goto extract_sfmt_ld_d;
      case 176 : itype = M32RBF_INSN_BEQ; goto extract_sfmt_beq;
      case 177 : itype = M32RBF_INSN_BNE; goto extract_sfmt_beq;
      case 184 : itype = M32RBF_INSN_BEQZ; goto extract_sfmt_beqz;
      case 185 : itype = M32RBF_INSN_BNEZ; goto extract_sfmt_beqz;
      case 186 : itype = M32RBF_INSN_BLTZ; goto extract_sfmt_beqz;
      case 187 : itype = M32RBF_INSN_BGEZ; goto extract_sfmt_beqz;
      case 188 : itype = M32RBF_INSN_BLEZ; goto extract_sfmt_beqz;
      case 189 : itype = M32RBF_INSN_BGTZ; goto extract_sfmt_beqz;
      case 220 : itype = M32RBF_INSN_SETH; goto extract_sfmt_seth;
d427 1
a427 1
      case 239 : itype = M32RBF_INSN_LD24; goto extract_sfmt_ld24;
d448 4
a451 4
          case 0 : itype = M32RBF_INSN_BC24; goto extract_sfmt_bc24;
          case 1 : itype = M32RBF_INSN_BNC24; goto extract_sfmt_bc24;
          case 2 : itype = M32RBF_INSN_BL24; goto extract_sfmt_bl24;
          case 3 : itype = M32RBF_INSN_BRA24; goto extract_sfmt_bra24;
a2001 93
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_clrpsw:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_INT insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_clrpsw.f
    UINT f_uimm8;

    f_uimm8 = EXTRACT_MSB0_UINT (insn, 16, 8, 8);

  /* Record the fields for the semantic handler.  */
  FLD (f_uimm8) = f_uimm8;
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_clrpsw", "f_uimm8 0x%x", 'x', f_uimm8, (char *) 0));

#undef FLD
    return idesc;
  }

 extract_sfmt_setpsw:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_INT insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_clrpsw.f
    UINT f_uimm8;

    f_uimm8 = EXTRACT_MSB0_UINT (insn, 16, 8, 8);

  /* Record the fields for the semantic handler.  */
  FLD (f_uimm8) = f_uimm8;
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_setpsw", "f_uimm8 0x%x", 'x', f_uimm8, (char *) 0));

#undef FLD
    return idesc;
  }

 extract_sfmt_bset:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_INT insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_bset.f
    UINT f_uimm3;
    UINT f_r2;
    INT f_simm16;

    f_uimm3 = EXTRACT_MSB0_UINT (insn, 32, 5, 3);
    f_r2 = EXTRACT_MSB0_UINT (insn, 32, 12, 4);
    f_simm16 = EXTRACT_MSB0_INT (insn, 32, 16, 16);

  /* Record the fields for the semantic handler.  */
  FLD (f_simm16) = f_simm16;
  FLD (f_r2) = f_r2;
  FLD (f_uimm3) = f_uimm3;
  FLD (i_sr) = & CPU (h_gr)[f_r2];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_bset", "f_simm16 0x%x", 'x', f_simm16, "f_r2 0x%x", 'x', f_r2, "f_uimm3 0x%x", 'x', f_uimm3, "sr 0x%x", 'x', f_r2, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_sr) = f_r2;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_btst:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_INT insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_bset.f
    UINT f_uimm3;
    UINT f_r2;

    f_uimm3 = EXTRACT_MSB0_UINT (insn, 16, 5, 3);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);

  /* Record the fields for the semantic handler.  */
  FLD (f_r2) = f_r2;
  FLD (f_uimm3) = f_uimm3;
  FLD (i_sr) = & CPU (h_gr)[f_r2];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_btst", "f_r2 0x%x", 'x', f_r2, "f_uimm3 0x%x", 'x', f_uimm3, "sr 0x%x", 'x', f_r2, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_sr) = f_r2;
@


1.4.16.1
log
@2002-12-23  David Carlton  <carlton@@math.stanford.edu>

	* Merge from mainline; tag is carlton_dictionary-20021223-merge.
@
text
@d5 1
a5 1
Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002 Free Software Foundation, Inc.
d36 1
a36 1
static IDESC m32rbf_insn_data[M32RBF_INSN__MAX];
d189 1
a189 1
  int tabsize = M32RBF_INSN__MAX;
d227 20
a246 20
      case 0 : itype = M32RBF_INSN_SUBV; goto extract_sfmt_addv;
      case 1 : itype = M32RBF_INSN_SUBX; goto extract_sfmt_addx;
      case 2 : itype = M32RBF_INSN_SUB; goto extract_sfmt_add;
      case 3 : itype = M32RBF_INSN_NEG; goto extract_sfmt_mv;
      case 4 : itype = M32RBF_INSN_CMP; goto extract_sfmt_cmp;
      case 5 : itype = M32RBF_INSN_CMPU; goto extract_sfmt_cmp;
      case 8 : itype = M32RBF_INSN_ADDV; goto extract_sfmt_addv;
      case 9 : itype = M32RBF_INSN_ADDX; goto extract_sfmt_addx;
      case 10 : itype = M32RBF_INSN_ADD; goto extract_sfmt_add;
      case 11 : itype = M32RBF_INSN_NOT; goto extract_sfmt_mv;
      case 12 : itype = M32RBF_INSN_AND; goto extract_sfmt_add;
      case 13 : itype = M32RBF_INSN_XOR; goto extract_sfmt_add;
      case 14 : itype = M32RBF_INSN_OR; goto extract_sfmt_add;
      case 16 : itype = M32RBF_INSN_SRL; goto extract_sfmt_add;
      case 18 : itype = M32RBF_INSN_SRA; goto extract_sfmt_add;
      case 20 : itype = M32RBF_INSN_SLL; goto extract_sfmt_add;
      case 22 : itype = M32RBF_INSN_MUL; goto extract_sfmt_add;
      case 24 : itype = M32RBF_INSN_MV; goto extract_sfmt_mv;
      case 25 : itype = M32RBF_INSN_MVFC; goto extract_sfmt_mvfc;
      case 26 : itype = M32RBF_INSN_MVTC; goto extract_sfmt_mvtc;
d252 2
a253 2
          case 0 : itype = M32RBF_INSN_JL; goto extract_sfmt_jl;
          case 1 : itype = M32RBF_INSN_JMP; goto extract_sfmt_jmp;
d257 23
a279 23
      case 29 : itype = M32RBF_INSN_RTE; goto extract_sfmt_rte;
      case 31 : itype = M32RBF_INSN_TRAP; goto extract_sfmt_trap;
      case 32 : itype = M32RBF_INSN_STB; goto extract_sfmt_stb;
      case 34 : itype = M32RBF_INSN_STH; goto extract_sfmt_sth;
      case 36 : itype = M32RBF_INSN_ST; goto extract_sfmt_st;
      case 37 : itype = M32RBF_INSN_UNLOCK; goto extract_sfmt_unlock;
      case 38 : itype = M32RBF_INSN_ST_PLUS; goto extract_sfmt_st_plus;
      case 39 : itype = M32RBF_INSN_ST_MINUS; goto extract_sfmt_st_plus;
      case 40 : itype = M32RBF_INSN_LDB; goto extract_sfmt_ldb;
      case 41 : itype = M32RBF_INSN_LDUB; goto extract_sfmt_ldb;
      case 42 : itype = M32RBF_INSN_LDH; goto extract_sfmt_ldh;
      case 43 : itype = M32RBF_INSN_LDUH; goto extract_sfmt_ldh;
      case 44 : itype = M32RBF_INSN_LD; goto extract_sfmt_ld;
      case 45 : itype = M32RBF_INSN_LOCK; goto extract_sfmt_lock;
      case 46 : itype = M32RBF_INSN_LD_PLUS; goto extract_sfmt_ld_plus;
      case 48 : itype = M32RBF_INSN_MULHI; goto extract_sfmt_mulhi;
      case 49 : itype = M32RBF_INSN_MULLO; goto extract_sfmt_mulhi;
      case 50 : itype = M32RBF_INSN_MULWHI; goto extract_sfmt_mulhi;
      case 51 : itype = M32RBF_INSN_MULWLO; goto extract_sfmt_mulhi;
      case 52 : itype = M32RBF_INSN_MACHI; goto extract_sfmt_machi;
      case 53 : itype = M32RBF_INSN_MACLO; goto extract_sfmt_machi;
      case 54 : itype = M32RBF_INSN_MACWHI; goto extract_sfmt_machi;
      case 55 : itype = M32RBF_INSN_MACWLO; goto extract_sfmt_machi;
d295 1
a295 1
      case 79 : itype = M32RBF_INSN_ADDI; goto extract_sfmt_addi;
d297 1
a297 1
      case 81 : itype = M32RBF_INSN_SRLI; goto extract_sfmt_slli;
d299 1
a299 1
      case 83 : itype = M32RBF_INSN_SRAI; goto extract_sfmt_slli;
d301 1
a301 1
      case 85 : itype = M32RBF_INSN_SLLI; goto extract_sfmt_slli;
d307 2
a308 2
          case 0 : itype = M32RBF_INSN_MVTACHI; goto extract_sfmt_mvtachi;
          case 1 : itype = M32RBF_INSN_MVTACLO; goto extract_sfmt_mvtachi;
d312 2
a313 2
      case 88 : itype = M32RBF_INSN_RACH; goto extract_sfmt_rac;
      case 89 : itype = M32RBF_INSN_RAC; goto extract_sfmt_rac;
d319 3
a321 3
          case 0 : itype = M32RBF_INSN_MVFACHI; goto extract_sfmt_mvfachi;
          case 1 : itype = M32RBF_INSN_MVFACLO; goto extract_sfmt_mvfachi;
          case 2 : itype = M32RBF_INSN_MVFACMI; goto extract_sfmt_mvfachi;
d340 1
a340 1
      case 111 : itype = M32RBF_INSN_LDI8; goto extract_sfmt_ldi8;
d346 5
a350 5
          case 0 : itype = M32RBF_INSN_NOP; goto extract_sfmt_nop;
          case 12 : itype = M32RBF_INSN_BC8; goto extract_sfmt_bc8;
          case 13 : itype = M32RBF_INSN_BNC8; goto extract_sfmt_bc8;
          case 14 : itype = M32RBF_INSN_BL8; goto extract_sfmt_bl8;
          case 15 : itype = M32RBF_INSN_BRA8; goto extract_sfmt_bra8;
d373 4
a376 4
          case 0 : itype = M32RBF_INSN_BC8; goto extract_sfmt_bc8;
          case 1 : itype = M32RBF_INSN_BNC8; goto extract_sfmt_bc8;
          case 2 : itype = M32RBF_INSN_BL8; goto extract_sfmt_bl8;
          case 3 : itype = M32RBF_INSN_BRA8; goto extract_sfmt_bra8;
d380 32
a411 32
      case 132 : itype = M32RBF_INSN_CMPI; goto extract_sfmt_cmpi;
      case 133 : itype = M32RBF_INSN_CMPUI; goto extract_sfmt_cmpi;
      case 136 : itype = M32RBF_INSN_ADDV3; goto extract_sfmt_addv3;
      case 138 : itype = M32RBF_INSN_ADD3; goto extract_sfmt_add3;
      case 140 : itype = M32RBF_INSN_AND3; goto extract_sfmt_and3;
      case 141 : itype = M32RBF_INSN_XOR3; goto extract_sfmt_and3;
      case 142 : itype = M32RBF_INSN_OR3; goto extract_sfmt_or3;
      case 144 : itype = M32RBF_INSN_DIV; goto extract_sfmt_div;
      case 145 : itype = M32RBF_INSN_DIVU; goto extract_sfmt_div;
      case 146 : itype = M32RBF_INSN_REM; goto extract_sfmt_div;
      case 147 : itype = M32RBF_INSN_REMU; goto extract_sfmt_div;
      case 152 : itype = M32RBF_INSN_SRL3; goto extract_sfmt_sll3;
      case 154 : itype = M32RBF_INSN_SRA3; goto extract_sfmt_sll3;
      case 156 : itype = M32RBF_INSN_SLL3; goto extract_sfmt_sll3;
      case 159 : itype = M32RBF_INSN_LDI16; goto extract_sfmt_ldi16;
      case 160 : itype = M32RBF_INSN_STB_D; goto extract_sfmt_stb_d;
      case 162 : itype = M32RBF_INSN_STH_D; goto extract_sfmt_sth_d;
      case 164 : itype = M32RBF_INSN_ST_D; goto extract_sfmt_st_d;
      case 168 : itype = M32RBF_INSN_LDB_D; goto extract_sfmt_ldb_d;
      case 169 : itype = M32RBF_INSN_LDUB_D; goto extract_sfmt_ldb_d;
      case 170 : itype = M32RBF_INSN_LDH_D; goto extract_sfmt_ldh_d;
      case 171 : itype = M32RBF_INSN_LDUH_D; goto extract_sfmt_ldh_d;
      case 172 : itype = M32RBF_INSN_LD_D; goto extract_sfmt_ld_d;
      case 176 : itype = M32RBF_INSN_BEQ; goto extract_sfmt_beq;
      case 177 : itype = M32RBF_INSN_BNE; goto extract_sfmt_beq;
      case 184 : itype = M32RBF_INSN_BEQZ; goto extract_sfmt_beqz;
      case 185 : itype = M32RBF_INSN_BNEZ; goto extract_sfmt_beqz;
      case 186 : itype = M32RBF_INSN_BLTZ; goto extract_sfmt_beqz;
      case 187 : itype = M32RBF_INSN_BGEZ; goto extract_sfmt_beqz;
      case 188 : itype = M32RBF_INSN_BLEZ; goto extract_sfmt_beqz;
      case 189 : itype = M32RBF_INSN_BGTZ; goto extract_sfmt_beqz;
      case 220 : itype = M32RBF_INSN_SETH; goto extract_sfmt_seth;
d427 1
a427 1
      case 239 : itype = M32RBF_INSN_LD24; goto extract_sfmt_ld24;
d448 4
a451 4
          case 0 : itype = M32RBF_INSN_BC24; goto extract_sfmt_bc24;
          case 1 : itype = M32RBF_INSN_BNC24; goto extract_sfmt_bc24;
          case 2 : itype = M32RBF_INSN_BL24; goto extract_sfmt_bl24;
          case 3 : itype = M32RBF_INSN_BRA24; goto extract_sfmt_bra24;
@


1.4.16.2
log
@2003-12-15  David Carlton  <carlton@@kealia.com>

	* Merge with mainline; tag is carlton_dictionary-20031215-merge.
	* cp-support.c (class_name_from_physname): Add DMGL_PARAMS to call
	to cplus_demangle.
	(method_name_from_physname): Ditto.
@
text
@d5 1
a5 1
Copyright 1996, 1997, 1998, 1999, 2000, 2001, 2002, 2003 Free Software Foundation, Inc.
a147 5
  { M32R_INSN_CLRPSW, M32RBF_INSN_CLRPSW, M32RBF_SFMT_CLRPSW },
  { M32R_INSN_SETPSW, M32RBF_INSN_SETPSW, M32RBF_SFMT_SETPSW },
  { M32R_INSN_BSET, M32RBF_INSN_BSET, M32RBF_SFMT_BSET },
  { M32R_INSN_BCLR, M32RBF_INSN_BCLR, M32RBF_SFMT_BSET },
  { M32R_INSN_BTST, M32RBF_INSN_BTST, M32RBF_SFMT_BTST },
a239 1
      case 15 : itype = M32RBF_INSN_BTST; goto extract_sfmt_btst;
a346 2
          case 1 : itype = M32RBF_INSN_SETPSW; goto extract_sfmt_setpsw;
          case 2 : itype = M32RBF_INSN_CLRPSW; goto extract_sfmt_clrpsw;
d370 1
a370 1
          unsigned int val = (((insn >> 8) & (15 << 0)));
d373 4
a376 6
          case 1 : itype = M32RBF_INSN_SETPSW; goto extract_sfmt_setpsw;
          case 2 : itype = M32RBF_INSN_CLRPSW; goto extract_sfmt_clrpsw;
          case 12 : itype = M32RBF_INSN_BC8; goto extract_sfmt_bc8;
          case 13 : itype = M32RBF_INSN_BNC8; goto extract_sfmt_bc8;
          case 14 : itype = M32RBF_INSN_BL8; goto extract_sfmt_bl8;
          case 15 : itype = M32RBF_INSN_BRA8; goto extract_sfmt_bra8;
a397 2
      case 166 : itype = M32RBF_INSN_BSET; goto extract_sfmt_bset;
      case 167 : itype = M32RBF_INSN_BCLR; goto extract_sfmt_bset;
a2001 93
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_clrpsw:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_INT insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_clrpsw.f
    UINT f_uimm8;

    f_uimm8 = EXTRACT_MSB0_UINT (insn, 16, 8, 8);

  /* Record the fields for the semantic handler.  */
  FLD (f_uimm8) = f_uimm8;
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_clrpsw", "f_uimm8 0x%x", 'x', f_uimm8, (char *) 0));

#undef FLD
    return idesc;
  }

 extract_sfmt_setpsw:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_INT insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_clrpsw.f
    UINT f_uimm8;

    f_uimm8 = EXTRACT_MSB0_UINT (insn, 16, 8, 8);

  /* Record the fields for the semantic handler.  */
  FLD (f_uimm8) = f_uimm8;
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_setpsw", "f_uimm8 0x%x", 'x', f_uimm8, (char *) 0));

#undef FLD
    return idesc;
  }

 extract_sfmt_bset:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_INT insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_bset.f
    UINT f_uimm3;
    UINT f_r2;
    INT f_simm16;

    f_uimm3 = EXTRACT_MSB0_UINT (insn, 32, 5, 3);
    f_r2 = EXTRACT_MSB0_UINT (insn, 32, 12, 4);
    f_simm16 = EXTRACT_MSB0_INT (insn, 32, 16, 16);

  /* Record the fields for the semantic handler.  */
  FLD (f_simm16) = f_simm16;
  FLD (f_r2) = f_r2;
  FLD (f_uimm3) = f_uimm3;
  FLD (i_sr) = & CPU (h_gr)[f_r2];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_bset", "f_simm16 0x%x", 'x', f_simm16, "f_r2 0x%x", 'x', f_r2, "f_uimm3 0x%x", 'x', f_uimm3, "sr 0x%x", 'x', f_r2, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_sr) = f_r2;
    }
#endif
#undef FLD
    return idesc;
  }

 extract_sfmt_btst:
  {
    const IDESC *idesc = &m32rbf_insn_data[itype];
    CGEN_INSN_INT insn = entire_insn;
#define FLD(f) abuf->fields.sfmt_bset.f
    UINT f_uimm3;
    UINT f_r2;

    f_uimm3 = EXTRACT_MSB0_UINT (insn, 16, 5, 3);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);

  /* Record the fields for the semantic handler.  */
  FLD (f_r2) = f_r2;
  FLD (f_uimm3) = f_uimm3;
  FLD (i_sr) = & CPU (h_gr)[f_r2];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_btst", "f_r2 0x%x", 'x', f_r2, "f_uimm3 0x%x", 'x', f_uimm3, "sr 0x%x", 'x', f_r2, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_sr) = f_r2;
@


1.3
log
@2001-03-05  Dave Brolley  <brolley

        arch.c: Regenerate.
        arch.h: Regenerate.
        cpu.c: Regenerate.
        cpu.h: Regenerate.
        cpuall.h: Regenerate.
        cpux.c: Regenerate.
        cpux.h: Regenerate.
        decode.c: Regenerate.
        decode.h: Regenerate.
        decodex.c: Regenerate.
        decodex.h: Regenerate.
        model.c: Regenerate.
        modelx.c: Regenerate.
        sem-switch.c: Regenerate.
        sem.c: Regenerate.
        semx-switch.c: Regenerate.
@
text
@d5 1
a5 1
Copyright (C) 1996, 1997, 1998, 1999, 2000 Free Software Foundation, Inc.
d7 1
a7 1
This file is part of the GNU Simulators.
d36 1
a36 1
static IDESC m32rbf_insn_data[M32RBF_INSN_MAX];
d89 8
a96 8
  { M32R_INSN_LDB, M32RBF_INSN_LDB, M32RBF_SFMT_LD },
  { M32R_INSN_LDB_D, M32RBF_INSN_LDB_D, M32RBF_SFMT_LD_D },
  { M32R_INSN_LDH, M32RBF_INSN_LDH, M32RBF_SFMT_LD },
  { M32R_INSN_LDH_D, M32RBF_INSN_LDH_D, M32RBF_SFMT_LD_D },
  { M32R_INSN_LDUB, M32RBF_INSN_LDUB, M32RBF_SFMT_LD },
  { M32R_INSN_LDUB_D, M32RBF_INSN_LDUB_D, M32RBF_SFMT_LD_D },
  { M32R_INSN_LDUH, M32RBF_INSN_LDUH, M32RBF_SFMT_LD },
  { M32R_INSN_LDUH_D, M32RBF_INSN_LDUH_D, M32RBF_SFMT_LD_D },
d189 1
a189 1
  int tabsize = M32RBF_INSN_MAX;
d227 21
a247 1
      case 0 : itype = M32RBF_INSN_SUBV; goto extract_sfmt_addv;      case 1 : itype = M32RBF_INSN_SUBX; goto extract_sfmt_addx;      case 2 : itype = M32RBF_INSN_SUB; goto extract_sfmt_add;      case 3 : itype = M32RBF_INSN_NEG; goto extract_sfmt_mv;      case 4 : itype = M32RBF_INSN_CMP; goto extract_sfmt_cmp;      case 5 : itype = M32RBF_INSN_CMPU; goto extract_sfmt_cmp;      case 8 : itype = M32RBF_INSN_ADDV; goto extract_sfmt_addv;      case 9 : itype = M32RBF_INSN_ADDX; goto extract_sfmt_addx;      case 10 : itype = M32RBF_INSN_ADD; goto extract_sfmt_add;      case 11 : itype = M32RBF_INSN_NOT; goto extract_sfmt_mv;      case 12 : itype = M32RBF_INSN_AND; goto extract_sfmt_add;      case 13 : itype = M32RBF_INSN_XOR; goto extract_sfmt_add;      case 14 : itype = M32RBF_INSN_OR; goto extract_sfmt_add;      case 16 : itype = M32RBF_INSN_SRL; goto extract_sfmt_add;      case 18 : itype = M32RBF_INSN_SRA; goto extract_sfmt_add;      case 20 : itype = M32RBF_INSN_SLL; goto extract_sfmt_add;      case 22 : itype = M32RBF_INSN_MUL; goto extract_sfmt_add;      case 24 : itype = M32RBF_INSN_MV; goto extract_sfmt_mv;      case 25 : itype = M32RBF_INSN_MVFC; goto extract_sfmt_mvfc;      case 26 : itype = M32RBF_INSN_MVTC; goto extract_sfmt_mvtc;      case 28 :
d252 3
a254 1
          case 0 : itype = M32RBF_INSN_JL; goto extract_sfmt_jl;          case 1 : itype = M32RBF_INSN_JMP; goto extract_sfmt_jmp;          default : itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
d257 24
a280 1
      case 29 : itype = M32RBF_INSN_RTE; goto extract_sfmt_rte;      case 31 : itype = M32RBF_INSN_TRAP; goto extract_sfmt_trap;      case 32 : itype = M32RBF_INSN_STB; goto extract_sfmt_stb;      case 34 : itype = M32RBF_INSN_STH; goto extract_sfmt_sth;      case 36 : itype = M32RBF_INSN_ST; goto extract_sfmt_st;      case 37 : itype = M32RBF_INSN_UNLOCK; goto extract_sfmt_unlock;      case 38 : itype = M32RBF_INSN_ST_PLUS; goto extract_sfmt_st_plus;      case 39 : itype = M32RBF_INSN_ST_MINUS; goto extract_sfmt_st_plus;      case 40 : itype = M32RBF_INSN_LDB; goto extract_sfmt_ld;      case 41 : itype = M32RBF_INSN_LDUB; goto extract_sfmt_ld;      case 42 : itype = M32RBF_INSN_LDH; goto extract_sfmt_ld;      case 43 : itype = M32RBF_INSN_LDUH; goto extract_sfmt_ld;      case 44 : itype = M32RBF_INSN_LD; goto extract_sfmt_ld;      case 45 : itype = M32RBF_INSN_LOCK; goto extract_sfmt_lock;      case 46 : itype = M32RBF_INSN_LD_PLUS; goto extract_sfmt_ld_plus;      case 48 : itype = M32RBF_INSN_MULHI; goto extract_sfmt_mulhi;      case 49 : itype = M32RBF_INSN_MULLO; goto extract_sfmt_mulhi;      case 50 : itype = M32RBF_INSN_MULWHI; goto extract_sfmt_mulhi;      case 51 : itype = M32RBF_INSN_MULWLO; goto extract_sfmt_mulhi;      case 52 : itype = M32RBF_INSN_MACHI; goto extract_sfmt_machi;      case 53 : itype = M32RBF_INSN_MACLO; goto extract_sfmt_machi;      case 54 : itype = M32RBF_INSN_MACWHI; goto extract_sfmt_machi;      case 55 : itype = M32RBF_INSN_MACWLO; goto extract_sfmt_machi;      case 64 : /* fall through */
d295 8
a302 4
      case 79 : itype = M32RBF_INSN_ADDI; goto extract_sfmt_addi;      case 80 : /* fall through */
      case 81 : itype = M32RBF_INSN_SRLI; goto extract_sfmt_slli;      case 82 : /* fall through */
      case 83 : itype = M32RBF_INSN_SRAI; goto extract_sfmt_slli;      case 84 : /* fall through */
      case 85 : itype = M32RBF_INSN_SLLI; goto extract_sfmt_slli;      case 87 :
d307 3
a309 1
          case 0 : itype = M32RBF_INSN_MVTACHI; goto extract_sfmt_mvtachi;          case 1 : itype = M32RBF_INSN_MVTACLO; goto extract_sfmt_mvtachi;          default : itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
d312 3
a314 1
      case 88 : itype = M32RBF_INSN_RACH; goto extract_sfmt_rac;      case 89 : itype = M32RBF_INSN_RAC; goto extract_sfmt_rac;      case 95 :
d319 4
a322 1
          case 0 : itype = M32RBF_INSN_MVFACHI; goto extract_sfmt_mvfachi;          case 1 : itype = M32RBF_INSN_MVFACLO; goto extract_sfmt_mvfachi;          case 2 : itype = M32RBF_INSN_MVFACMI; goto extract_sfmt_mvfachi;          default : itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
d340 2
a341 1
      case 111 : itype = M32RBF_INSN_LDI8; goto extract_sfmt_ldi8;      case 112 :
d346 6
a351 1
          case 0 : itype = M32RBF_INSN_NOP; goto extract_sfmt_nop;          case 12 : itype = M32RBF_INSN_BC8; goto extract_sfmt_bc8;          case 13 : itype = M32RBF_INSN_BNC8; goto extract_sfmt_bc8;          case 14 : itype = M32RBF_INSN_BL8; goto extract_sfmt_bl8;          case 15 : itype = M32RBF_INSN_BRA8; goto extract_sfmt_bra8;          default : itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
d373 5
a377 1
          case 0 : itype = M32RBF_INSN_BC8; goto extract_sfmt_bc8;          case 1 : itype = M32RBF_INSN_BNC8; goto extract_sfmt_bc8;          case 2 : itype = M32RBF_INSN_BL8; goto extract_sfmt_bl8;          case 3 : itype = M32RBF_INSN_BRA8; goto extract_sfmt_bra8;          default : itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
d380 33
a412 1
      case 132 : itype = M32RBF_INSN_CMPI; goto extract_sfmt_cmpi;      case 133 : itype = M32RBF_INSN_CMPUI; goto extract_sfmt_cmpi;      case 136 : itype = M32RBF_INSN_ADDV3; goto extract_sfmt_addv3;      case 138 : itype = M32RBF_INSN_ADD3; goto extract_sfmt_add3;      case 140 : itype = M32RBF_INSN_AND3; goto extract_sfmt_and3;      case 141 : itype = M32RBF_INSN_XOR3; goto extract_sfmt_and3;      case 142 : itype = M32RBF_INSN_OR3; goto extract_sfmt_or3;      case 144 : itype = M32RBF_INSN_DIV; goto extract_sfmt_div;      case 145 : itype = M32RBF_INSN_DIVU; goto extract_sfmt_div;      case 146 : itype = M32RBF_INSN_REM; goto extract_sfmt_div;      case 147 : itype = M32RBF_INSN_REMU; goto extract_sfmt_div;      case 152 : itype = M32RBF_INSN_SRL3; goto extract_sfmt_sll3;      case 154 : itype = M32RBF_INSN_SRA3; goto extract_sfmt_sll3;      case 156 : itype = M32RBF_INSN_SLL3; goto extract_sfmt_sll3;      case 159 : itype = M32RBF_INSN_LDI16; goto extract_sfmt_ldi16;      case 160 : itype = M32RBF_INSN_STB_D; goto extract_sfmt_stb_d;      case 162 : itype = M32RBF_INSN_STH_D; goto extract_sfmt_sth_d;      case 164 : itype = M32RBF_INSN_ST_D; goto extract_sfmt_st_d;      case 168 : itype = M32RBF_INSN_LDB_D; goto extract_sfmt_ld_d;      case 169 : itype = M32RBF_INSN_LDUB_D; goto extract_sfmt_ld_d;      case 170 : itype = M32RBF_INSN_LDH_D; goto extract_sfmt_ld_d;      case 171 : itype = M32RBF_INSN_LDUH_D; goto extract_sfmt_ld_d;      case 172 : itype = M32RBF_INSN_LD_D; goto extract_sfmt_ld_d;      case 176 : itype = M32RBF_INSN_BEQ; goto extract_sfmt_beq;      case 177 : itype = M32RBF_INSN_BNE; goto extract_sfmt_beq;      case 184 : itype = M32RBF_INSN_BEQZ; goto extract_sfmt_beqz;      case 185 : itype = M32RBF_INSN_BNEZ; goto extract_sfmt_beqz;      case 186 : itype = M32RBF_INSN_BLTZ; goto extract_sfmt_beqz;      case 187 : itype = M32RBF_INSN_BGEZ; goto extract_sfmt_beqz;      case 188 : itype = M32RBF_INSN_BLEZ; goto extract_sfmt_beqz;      case 189 : itype = M32RBF_INSN_BGTZ; goto extract_sfmt_beqz;      case 220 : itype = M32RBF_INSN_SETH; goto extract_sfmt_seth;      case 224 : /* fall through */
d427 2
a428 1
      case 239 : itype = M32RBF_INSN_LD24; goto extract_sfmt_ld24;      case 240 : /* fall through */
d448 5
a452 1
          case 0 : itype = M32RBF_INSN_BC24; goto extract_sfmt_bc24;          case 1 : itype = M32RBF_INSN_BNC24; goto extract_sfmt_bc24;          case 2 : itype = M32RBF_INSN_BL24; goto extract_sfmt_bl24;          case 3 : itype = M32RBF_INSN_BRA24; goto extract_sfmt_bra24;          default : itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
d853 1
a853 1
      FLD (out_h_gr_14) = 14;
d877 1
a877 1
      FLD (out_h_gr_14) = 14;
d1038 1
a1038 1
      FLD (out_h_gr_14) = 14;
d1120 126
@


1.2
log
@2000-08-28  Dave Brolley  <brolley@@redhat.com>

	* Makefile.in: Use of @@true confuses VPATH. Remove it.
	* cpu.h: Regenerated.
	* cpux.h: Regenerated.
	* decode.c: Regenerated.
	* decodex.c: Regenerated.
	* model.c: Regenerated.
	* modelx.c: Regenerated.
	* sem-switch.c: Regenerated.
	* sem.c: Regenerated.
	* semx-switch.c: Regenerated.
@
text
@d5 1
a5 1
Copyright (C) 1996, 1997, 1998, 1999 Free Software Foundation, Inc.
d227 1
a227 21
      case 0 : itype = M32RBF_INSN_SUBV; goto extract_sfmt_addv;
      case 1 : itype = M32RBF_INSN_SUBX; goto extract_sfmt_addx;
      case 2 : itype = M32RBF_INSN_SUB; goto extract_sfmt_add;
      case 3 : itype = M32RBF_INSN_NEG; goto extract_sfmt_mv;
      case 4 : itype = M32RBF_INSN_CMP; goto extract_sfmt_cmp;
      case 5 : itype = M32RBF_INSN_CMPU; goto extract_sfmt_cmp;
      case 8 : itype = M32RBF_INSN_ADDV; goto extract_sfmt_addv;
      case 9 : itype = M32RBF_INSN_ADDX; goto extract_sfmt_addx;
      case 10 : itype = M32RBF_INSN_ADD; goto extract_sfmt_add;
      case 11 : itype = M32RBF_INSN_NOT; goto extract_sfmt_mv;
      case 12 : itype = M32RBF_INSN_AND; goto extract_sfmt_add;
      case 13 : itype = M32RBF_INSN_XOR; goto extract_sfmt_add;
      case 14 : itype = M32RBF_INSN_OR; goto extract_sfmt_add;
      case 16 : itype = M32RBF_INSN_SRL; goto extract_sfmt_add;
      case 18 : itype = M32RBF_INSN_SRA; goto extract_sfmt_add;
      case 20 : itype = M32RBF_INSN_SLL; goto extract_sfmt_add;
      case 22 : itype = M32RBF_INSN_MUL; goto extract_sfmt_add;
      case 24 : itype = M32RBF_INSN_MV; goto extract_sfmt_mv;
      case 25 : itype = M32RBF_INSN_MVFC; goto extract_sfmt_mvfc;
      case 26 : itype = M32RBF_INSN_MVTC; goto extract_sfmt_mvtc;
      case 28 :
d229 1
a229 1
          unsigned int val = (((insn >> 8) & (15 << 0)));
d232 1
a232 3
          case 14 : itype = M32RBF_INSN_JL; goto extract_sfmt_jl;
          case 15 : itype = M32RBF_INSN_JMP; goto extract_sfmt_jmp;
          default : itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
d235 1
a235 24
      case 29 : itype = M32RBF_INSN_RTE; goto extract_sfmt_rte;
      case 31 : itype = M32RBF_INSN_TRAP; goto extract_sfmt_trap;
      case 32 : itype = M32RBF_INSN_STB; goto extract_sfmt_stb;
      case 34 : itype = M32RBF_INSN_STH; goto extract_sfmt_sth;
      case 36 : itype = M32RBF_INSN_ST; goto extract_sfmt_st;
      case 37 : itype = M32RBF_INSN_UNLOCK; goto extract_sfmt_unlock;
      case 38 : itype = M32RBF_INSN_ST_PLUS; goto extract_sfmt_st_plus;
      case 39 : itype = M32RBF_INSN_ST_MINUS; goto extract_sfmt_st_plus;
      case 40 : itype = M32RBF_INSN_LDB; goto extract_sfmt_ld;
      case 41 : itype = M32RBF_INSN_LDUB; goto extract_sfmt_ld;
      case 42 : itype = M32RBF_INSN_LDH; goto extract_sfmt_ld;
      case 43 : itype = M32RBF_INSN_LDUH; goto extract_sfmt_ld;
      case 44 : itype = M32RBF_INSN_LD; goto extract_sfmt_ld;
      case 45 : itype = M32RBF_INSN_LOCK; goto extract_sfmt_lock;
      case 46 : itype = M32RBF_INSN_LD_PLUS; goto extract_sfmt_ld_plus;
      case 48 : itype = M32RBF_INSN_MULHI; goto extract_sfmt_mulhi;
      case 49 : itype = M32RBF_INSN_MULLO; goto extract_sfmt_mulhi;
      case 50 : itype = M32RBF_INSN_MULWHI; goto extract_sfmt_mulhi;
      case 51 : itype = M32RBF_INSN_MULWLO; goto extract_sfmt_mulhi;
      case 52 : itype = M32RBF_INSN_MACHI; goto extract_sfmt_machi;
      case 53 : itype = M32RBF_INSN_MACLO; goto extract_sfmt_machi;
      case 54 : itype = M32RBF_INSN_MACWHI; goto extract_sfmt_machi;
      case 55 : itype = M32RBF_INSN_MACWLO; goto extract_sfmt_machi;
      case 64 : /* fall through */
d250 4
a253 8
      case 79 : itype = M32RBF_INSN_ADDI; goto extract_sfmt_addi;
      case 80 : /* fall through */
      case 81 : itype = M32RBF_INSN_SRLI; goto extract_sfmt_slli;
      case 82 : /* fall through */
      case 83 : itype = M32RBF_INSN_SRAI; goto extract_sfmt_slli;
      case 84 : /* fall through */
      case 85 : itype = M32RBF_INSN_SLLI; goto extract_sfmt_slli;
      case 87 :
d255 1
a255 1
          unsigned int val = (((insn >> 0) & (15 << 0)));
d258 1
a258 3
          case 0 : itype = M32RBF_INSN_MVTACHI; goto extract_sfmt_mvtachi;
          case 1 : itype = M32RBF_INSN_MVTACLO; goto extract_sfmt_mvtachi;
          default : itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
d261 1
a261 3
      case 88 : itype = M32RBF_INSN_RACH; goto extract_sfmt_rac;
      case 89 : itype = M32RBF_INSN_RAC; goto extract_sfmt_rac;
      case 95 :
d263 1
a263 1
          unsigned int val = (((insn >> 0) & (15 << 0)));
d266 1
a266 4
          case 0 : itype = M32RBF_INSN_MVFACHI; goto extract_sfmt_mvfachi;
          case 1 : itype = M32RBF_INSN_MVFACLO; goto extract_sfmt_mvfachi;
          case 2 : itype = M32RBF_INSN_MVFACMI; goto extract_sfmt_mvfachi;
          default : itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
d284 1
a284 2
      case 111 : itype = M32RBF_INSN_LDI8; goto extract_sfmt_ldi8;
      case 112 :
d289 1
a289 6
          case 0 : itype = M32RBF_INSN_NOP; goto extract_sfmt_nop;
          case 12 : itype = M32RBF_INSN_BC8; goto extract_sfmt_bc8;
          case 13 : itype = M32RBF_INSN_BNC8; goto extract_sfmt_bc8;
          case 14 : itype = M32RBF_INSN_BL8; goto extract_sfmt_bl8;
          case 15 : itype = M32RBF_INSN_BRA8; goto extract_sfmt_bra8;
          default : itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
d308 1
a308 1
          unsigned int val = (((insn >> 8) & (15 << 0)));
d311 1
a311 5
          case 12 : itype = M32RBF_INSN_BC8; goto extract_sfmt_bc8;
          case 13 : itype = M32RBF_INSN_BNC8; goto extract_sfmt_bc8;
          case 14 : itype = M32RBF_INSN_BL8; goto extract_sfmt_bl8;
          case 15 : itype = M32RBF_INSN_BRA8; goto extract_sfmt_bra8;
          default : itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
d314 1
a314 33
      case 132 : itype = M32RBF_INSN_CMPI; goto extract_sfmt_cmpi;
      case 133 : itype = M32RBF_INSN_CMPUI; goto extract_sfmt_cmpi;
      case 136 : itype = M32RBF_INSN_ADDV3; goto extract_sfmt_addv3;
      case 138 : itype = M32RBF_INSN_ADD3; goto extract_sfmt_add3;
      case 140 : itype = M32RBF_INSN_AND3; goto extract_sfmt_and3;
      case 141 : itype = M32RBF_INSN_XOR3; goto extract_sfmt_and3;
      case 142 : itype = M32RBF_INSN_OR3; goto extract_sfmt_or3;
      case 144 : itype = M32RBF_INSN_DIV; goto extract_sfmt_div;
      case 145 : itype = M32RBF_INSN_DIVU; goto extract_sfmt_div;
      case 146 : itype = M32RBF_INSN_REM; goto extract_sfmt_div;
      case 147 : itype = M32RBF_INSN_REMU; goto extract_sfmt_div;
      case 152 : itype = M32RBF_INSN_SRL3; goto extract_sfmt_sll3;
      case 154 : itype = M32RBF_INSN_SRA3; goto extract_sfmt_sll3;
      case 156 : itype = M32RBF_INSN_SLL3; goto extract_sfmt_sll3;
      case 159 : itype = M32RBF_INSN_LDI16; goto extract_sfmt_ldi16;
      case 160 : itype = M32RBF_INSN_STB_D; goto extract_sfmt_stb_d;
      case 162 : itype = M32RBF_INSN_STH_D; goto extract_sfmt_sth_d;
      case 164 : itype = M32RBF_INSN_ST_D; goto extract_sfmt_st_d;
      case 168 : itype = M32RBF_INSN_LDB_D; goto extract_sfmt_ld_d;
      case 169 : itype = M32RBF_INSN_LDUB_D; goto extract_sfmt_ld_d;
      case 170 : itype = M32RBF_INSN_LDH_D; goto extract_sfmt_ld_d;
      case 171 : itype = M32RBF_INSN_LDUH_D; goto extract_sfmt_ld_d;
      case 172 : itype = M32RBF_INSN_LD_D; goto extract_sfmt_ld_d;
      case 176 : itype = M32RBF_INSN_BEQ; goto extract_sfmt_beq;
      case 177 : itype = M32RBF_INSN_BNE; goto extract_sfmt_beq;
      case 184 : itype = M32RBF_INSN_BEQZ; goto extract_sfmt_beqz;
      case 185 : itype = M32RBF_INSN_BNEZ; goto extract_sfmt_beqz;
      case 186 : itype = M32RBF_INSN_BLTZ; goto extract_sfmt_beqz;
      case 187 : itype = M32RBF_INSN_BGEZ; goto extract_sfmt_beqz;
      case 188 : itype = M32RBF_INSN_BLEZ; goto extract_sfmt_beqz;
      case 189 : itype = M32RBF_INSN_BGTZ; goto extract_sfmt_beqz;
      case 220 : itype = M32RBF_INSN_SETH; goto extract_sfmt_seth;
      case 224 : /* fall through */
d329 1
a329 2
      case 239 : itype = M32RBF_INSN_LD24; goto extract_sfmt_ld24;
      case 240 : /* fall through */
d346 1
a346 1
          unsigned int val = (((insn >> 8) & (15 << 0)));
d349 1
a349 5
          case 12 : itype = M32RBF_INSN_BC24; goto extract_sfmt_bc24;
          case 13 : itype = M32RBF_INSN_BNC24; goto extract_sfmt_bc24;
          case 14 : itype = M32RBF_INSN_BL24; goto extract_sfmt_bl24;
          case 15 : itype = M32RBF_INSN_BRA24; goto extract_sfmt_bra24;
          default : itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
a361 1
    CGEN_INSN_INT insn = entire_insn;
a1373 1
    CGEN_INSN_INT insn = entire_insn;
a1386 1
    CGEN_INSN_INT insn = entire_insn;
a1399 1
    CGEN_INSN_INT insn = entire_insn;
@


1.1
log
@Initial revision
@
text
@a30 18
/* FIXME: Need to review choices for the following.  */

#if WITH_SEM_SWITCH_FULL
#define FULL(fn)
#else
#define FULL(fn) CONCAT3 (m32rbf,_sem_,fn) ,
#endif

#if WITH_FAST
#if WITH_SEM_SWITCH_FAST
#define FAST(fn)
#else
#define FAST(fn) CONCAT3 (m32rbf,_semf_,fn) , /* f for fast */
#endif
#else
#define FAST(fn)
#endif

a37 5
/* The INSN_ prefix is not here and is instead part of the `insn' argument
   to avoid collisions with header files (e.g. `AND' in ansidecl.h).  */
#define IDX(insn) CONCAT2 (M32RBF_,insn)
#define TYPE(insn) CONCAT2 (M32R_,insn)

d43 105
a147 105
  { VIRTUAL_INSN_X_INVALID, IDX (INSN_X_INVALID), FULL (x_invalid) FAST (x_invalid) },
  { VIRTUAL_INSN_X_AFTER, IDX (INSN_X_AFTER), FULL (x_after) FAST (x_after) },
  { VIRTUAL_INSN_X_BEFORE, IDX (INSN_X_BEFORE), FULL (x_before) FAST (x_before) },
  { VIRTUAL_INSN_X_CTI_CHAIN, IDX (INSN_X_CTI_CHAIN), FULL (x_cti_chain) FAST (x_cti_chain) },
  { VIRTUAL_INSN_X_CHAIN, IDX (INSN_X_CHAIN), FULL (x_chain) FAST (x_chain) },
  { VIRTUAL_INSN_X_BEGIN, IDX (INSN_X_BEGIN), FULL (x_begin) FAST (x_begin) },
  { TYPE (INSN_ADD), IDX (INSN_ADD), FULL (add) FAST (add) },
  { TYPE (INSN_ADD3), IDX (INSN_ADD3), FULL (add3) FAST (add3) },
  { TYPE (INSN_AND), IDX (INSN_AND), FULL (and) FAST (and) },
  { TYPE (INSN_AND3), IDX (INSN_AND3), FULL (and3) FAST (and3) },
  { TYPE (INSN_OR), IDX (INSN_OR), FULL (or) FAST (or) },
  { TYPE (INSN_OR3), IDX (INSN_OR3), FULL (or3) FAST (or3) },
  { TYPE (INSN_XOR), IDX (INSN_XOR), FULL (xor) FAST (xor) },
  { TYPE (INSN_XOR3), IDX (INSN_XOR3), FULL (xor3) FAST (xor3) },
  { TYPE (INSN_ADDI), IDX (INSN_ADDI), FULL (addi) FAST (addi) },
  { TYPE (INSN_ADDV), IDX (INSN_ADDV), FULL (addv) FAST (addv) },
  { TYPE (INSN_ADDV3), IDX (INSN_ADDV3), FULL (addv3) FAST (addv3) },
  { TYPE (INSN_ADDX), IDX (INSN_ADDX), FULL (addx) FAST (addx) },
  { TYPE (INSN_BC8), IDX (INSN_BC8), FULL (bc8) FAST (bc8) },
  { TYPE (INSN_BC24), IDX (INSN_BC24), FULL (bc24) FAST (bc24) },
  { TYPE (INSN_BEQ), IDX (INSN_BEQ), FULL (beq) FAST (beq) },
  { TYPE (INSN_BEQZ), IDX (INSN_BEQZ), FULL (beqz) FAST (beqz) },
  { TYPE (INSN_BGEZ), IDX (INSN_BGEZ), FULL (bgez) FAST (bgez) },
  { TYPE (INSN_BGTZ), IDX (INSN_BGTZ), FULL (bgtz) FAST (bgtz) },
  { TYPE (INSN_BLEZ), IDX (INSN_BLEZ), FULL (blez) FAST (blez) },
  { TYPE (INSN_BLTZ), IDX (INSN_BLTZ), FULL (bltz) FAST (bltz) },
  { TYPE (INSN_BNEZ), IDX (INSN_BNEZ), FULL (bnez) FAST (bnez) },
  { TYPE (INSN_BL8), IDX (INSN_BL8), FULL (bl8) FAST (bl8) },
  { TYPE (INSN_BL24), IDX (INSN_BL24), FULL (bl24) FAST (bl24) },
  { TYPE (INSN_BNC8), IDX (INSN_BNC8), FULL (bnc8) FAST (bnc8) },
  { TYPE (INSN_BNC24), IDX (INSN_BNC24), FULL (bnc24) FAST (bnc24) },
  { TYPE (INSN_BNE), IDX (INSN_BNE), FULL (bne) FAST (bne) },
  { TYPE (INSN_BRA8), IDX (INSN_BRA8), FULL (bra8) FAST (bra8) },
  { TYPE (INSN_BRA24), IDX (INSN_BRA24), FULL (bra24) FAST (bra24) },
  { TYPE (INSN_CMP), IDX (INSN_CMP), FULL (cmp) FAST (cmp) },
  { TYPE (INSN_CMPI), IDX (INSN_CMPI), FULL (cmpi) FAST (cmpi) },
  { TYPE (INSN_CMPU), IDX (INSN_CMPU), FULL (cmpu) FAST (cmpu) },
  { TYPE (INSN_CMPUI), IDX (INSN_CMPUI), FULL (cmpui) FAST (cmpui) },
  { TYPE (INSN_DIV), IDX (INSN_DIV), FULL (div) FAST (div) },
  { TYPE (INSN_DIVU), IDX (INSN_DIVU), FULL (divu) FAST (divu) },
  { TYPE (INSN_REM), IDX (INSN_REM), FULL (rem) FAST (rem) },
  { TYPE (INSN_REMU), IDX (INSN_REMU), FULL (remu) FAST (remu) },
  { TYPE (INSN_JL), IDX (INSN_JL), FULL (jl) FAST (jl) },
  { TYPE (INSN_JMP), IDX (INSN_JMP), FULL (jmp) FAST (jmp) },
  { TYPE (INSN_LD), IDX (INSN_LD), FULL (ld) FAST (ld) },
  { TYPE (INSN_LD_D), IDX (INSN_LD_D), FULL (ld_d) FAST (ld_d) },
  { TYPE (INSN_LDB), IDX (INSN_LDB), FULL (ldb) FAST (ldb) },
  { TYPE (INSN_LDB_D), IDX (INSN_LDB_D), FULL (ldb_d) FAST (ldb_d) },
  { TYPE (INSN_LDH), IDX (INSN_LDH), FULL (ldh) FAST (ldh) },
  { TYPE (INSN_LDH_D), IDX (INSN_LDH_D), FULL (ldh_d) FAST (ldh_d) },
  { TYPE (INSN_LDUB), IDX (INSN_LDUB), FULL (ldub) FAST (ldub) },
  { TYPE (INSN_LDUB_D), IDX (INSN_LDUB_D), FULL (ldub_d) FAST (ldub_d) },
  { TYPE (INSN_LDUH), IDX (INSN_LDUH), FULL (lduh) FAST (lduh) },
  { TYPE (INSN_LDUH_D), IDX (INSN_LDUH_D), FULL (lduh_d) FAST (lduh_d) },
  { TYPE (INSN_LD_PLUS), IDX (INSN_LD_PLUS), FULL (ld_plus) FAST (ld_plus) },
  { TYPE (INSN_LD24), IDX (INSN_LD24), FULL (ld24) FAST (ld24) },
  { TYPE (INSN_LDI8), IDX (INSN_LDI8), FULL (ldi8) FAST (ldi8) },
  { TYPE (INSN_LDI16), IDX (INSN_LDI16), FULL (ldi16) FAST (ldi16) },
  { TYPE (INSN_LOCK), IDX (INSN_LOCK), FULL (lock) FAST (lock) },
  { TYPE (INSN_MACHI), IDX (INSN_MACHI), FULL (machi) FAST (machi) },
  { TYPE (INSN_MACLO), IDX (INSN_MACLO), FULL (maclo) FAST (maclo) },
  { TYPE (INSN_MACWHI), IDX (INSN_MACWHI), FULL (macwhi) FAST (macwhi) },
  { TYPE (INSN_MACWLO), IDX (INSN_MACWLO), FULL (macwlo) FAST (macwlo) },
  { TYPE (INSN_MUL), IDX (INSN_MUL), FULL (mul) FAST (mul) },
  { TYPE (INSN_MULHI), IDX (INSN_MULHI), FULL (mulhi) FAST (mulhi) },
  { TYPE (INSN_MULLO), IDX (INSN_MULLO), FULL (mullo) FAST (mullo) },
  { TYPE (INSN_MULWHI), IDX (INSN_MULWHI), FULL (mulwhi) FAST (mulwhi) },
  { TYPE (INSN_MULWLO), IDX (INSN_MULWLO), FULL (mulwlo) FAST (mulwlo) },
  { TYPE (INSN_MV), IDX (INSN_MV), FULL (mv) FAST (mv) },
  { TYPE (INSN_MVFACHI), IDX (INSN_MVFACHI), FULL (mvfachi) FAST (mvfachi) },
  { TYPE (INSN_MVFACLO), IDX (INSN_MVFACLO), FULL (mvfaclo) FAST (mvfaclo) },
  { TYPE (INSN_MVFACMI), IDX (INSN_MVFACMI), FULL (mvfacmi) FAST (mvfacmi) },
  { TYPE (INSN_MVFC), IDX (INSN_MVFC), FULL (mvfc) FAST (mvfc) },
  { TYPE (INSN_MVTACHI), IDX (INSN_MVTACHI), FULL (mvtachi) FAST (mvtachi) },
  { TYPE (INSN_MVTACLO), IDX (INSN_MVTACLO), FULL (mvtaclo) FAST (mvtaclo) },
  { TYPE (INSN_MVTC), IDX (INSN_MVTC), FULL (mvtc) FAST (mvtc) },
  { TYPE (INSN_NEG), IDX (INSN_NEG), FULL (neg) FAST (neg) },
  { TYPE (INSN_NOP), IDX (INSN_NOP), FULL (nop) FAST (nop) },
  { TYPE (INSN_NOT), IDX (INSN_NOT), FULL (not) FAST (not) },
  { TYPE (INSN_RAC), IDX (INSN_RAC), FULL (rac) FAST (rac) },
  { TYPE (INSN_RACH), IDX (INSN_RACH), FULL (rach) FAST (rach) },
  { TYPE (INSN_RTE), IDX (INSN_RTE), FULL (rte) FAST (rte) },
  { TYPE (INSN_SETH), IDX (INSN_SETH), FULL (seth) FAST (seth) },
  { TYPE (INSN_SLL), IDX (INSN_SLL), FULL (sll) FAST (sll) },
  { TYPE (INSN_SLL3), IDX (INSN_SLL3), FULL (sll3) FAST (sll3) },
  { TYPE (INSN_SLLI), IDX (INSN_SLLI), FULL (slli) FAST (slli) },
  { TYPE (INSN_SRA), IDX (INSN_SRA), FULL (sra) FAST (sra) },
  { TYPE (INSN_SRA3), IDX (INSN_SRA3), FULL (sra3) FAST (sra3) },
  { TYPE (INSN_SRAI), IDX (INSN_SRAI), FULL (srai) FAST (srai) },
  { TYPE (INSN_SRL), IDX (INSN_SRL), FULL (srl) FAST (srl) },
  { TYPE (INSN_SRL3), IDX (INSN_SRL3), FULL (srl3) FAST (srl3) },
  { TYPE (INSN_SRLI), IDX (INSN_SRLI), FULL (srli) FAST (srli) },
  { TYPE (INSN_ST), IDX (INSN_ST), FULL (st) FAST (st) },
  { TYPE (INSN_ST_D), IDX (INSN_ST_D), FULL (st_d) FAST (st_d) },
  { TYPE (INSN_STB), IDX (INSN_STB), FULL (stb) FAST (stb) },
  { TYPE (INSN_STB_D), IDX (INSN_STB_D), FULL (stb_d) FAST (stb_d) },
  { TYPE (INSN_STH), IDX (INSN_STH), FULL (sth) FAST (sth) },
  { TYPE (INSN_STH_D), IDX (INSN_STH_D), FULL (sth_d) FAST (sth_d) },
  { TYPE (INSN_ST_PLUS), IDX (INSN_ST_PLUS), FULL (st_plus) FAST (st_plus) },
  { TYPE (INSN_ST_MINUS), IDX (INSN_ST_MINUS), FULL (st_minus) FAST (st_minus) },
  { TYPE (INSN_SUB), IDX (INSN_SUB), FULL (sub) FAST (sub) },
  { TYPE (INSN_SUBV), IDX (INSN_SUBV), FULL (subv) FAST (subv) },
  { TYPE (INSN_SUBX), IDX (INSN_SUBX), FULL (subx) FAST (subx) },
  { TYPE (INSN_TRAP), IDX (INSN_TRAP), FULL (trap) FAST (trap) },
  { TYPE (INSN_UNLOCK), IDX (INSN_UNLOCK), FULL (unlock) FAST (unlock) },
d150 2
a151 3
static const struct insn_sem m32rbf_insn_sem_invalid =
{
  VIRTUAL_INSN_X_INVALID, IDX (INSN_X_INVALID), FULL (x_invalid) FAST (x_invalid)
a153 3
#undef IDX
#undef TYPE

d162 1
d170 1
a170 6
#if ! WITH_SEM_SWITCH_FULL
  id->sem_full = t->sem_full;
#endif
#if WITH_FAST && ! WITH_SEM_SWITCH_FAST
  id->sem_fast = t->sem_fast;
#endif
d178 2
a209 44
/* Enum declaration for all instruction semantic formats.  */
typedef enum sfmt {
  FMT_EMPTY, FMT_ADD, FMT_ADD3, FMT_AND3
 , FMT_OR3, FMT_ADDI, FMT_ADDV, FMT_ADDV3
 , FMT_ADDX, FMT_BC8, FMT_BC24, FMT_BEQ
 , FMT_BEQZ, FMT_BL8, FMT_BL24, FMT_BRA8
 , FMT_BRA24, FMT_CMP, FMT_CMPI, FMT_DIV
 , FMT_JL, FMT_JMP, FMT_LD, FMT_LD_D
 , FMT_LDB, FMT_LDB_D, FMT_LDH, FMT_LDH_D
 , FMT_LD_PLUS, FMT_LD24, FMT_LDI8, FMT_LDI16
 , FMT_LOCK, FMT_MACHI, FMT_MULHI, FMT_MV
 , FMT_MVFACHI, FMT_MVFC, FMT_MVTACHI, FMT_MVTC
 , FMT_NOP, FMT_RAC, FMT_RTE, FMT_SETH
 , FMT_SLL3, FMT_SLLI, FMT_ST, FMT_ST_D
 , FMT_STB, FMT_STB_D, FMT_STH, FMT_STH_D
 , FMT_ST_PLUS, FMT_TRAP, FMT_UNLOCK
} SFMT;

/* The decoder uses this to record insns and direct extraction handling.  */

typedef struct {
  const IDESC *idesc;
#ifdef __GNUC__
  void *sfmt;
#else
  enum sfmt sfmt;
#endif
} DECODE_DESC;

/* Macro to go from decode phase to extraction phase.  */

#ifdef __GNUC__
#define GOTO_EXTRACT(id) goto *(id)->sfmt
#else
#define GOTO_EXTRACT(id) goto extract
#endif

/* The decoder needs a slightly different computed goto switch control.  */
#ifdef __GNUC__
#define DECODE_SWITCH(N, X) goto *labels_##N[X];
#else
#define DECODE_SWITCH(N, X) switch (X)
#endif

d217 2
a218 4
  /* Result of decoder, used by extractor.  */
  const DECODE_DESC *idecode;

  /* First decode the instruction.  */
a220 6
#define I(insn) & m32rbf_insn_data[CONCAT2 (M32RBF_,insn)]
#ifdef __GNUC__
#define E(fmt) && case_ex_##fmt
#else
#define E(fmt) fmt
#endif
a221 1
    static const DECODE_DESC idecode_invalid = { I (INSN_X_INVALID), E (FMT_EMPTY) };
d224 24
a247 201
#ifdef __GNUC__
      static const void *labels_0[256] = {
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && case_0_28, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && case_0_87, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && case_0_95, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && case_0_112, && case_0_113, && case_0_114, && case_0_115, 
        && case_0_116, && case_0_117, && case_0_118, && case_0_119, 
        && case_0_120, && case_0_121, && case_0_122, && case_0_123, 
        && case_0_124, && case_0_125, && case_0_126, && case_0_127, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && default_0, && default_0, && default_0, && default_0, 
        && case_0_240, && case_0_241, && case_0_242, && case_0_243, 
        && case_0_244, && case_0_245, && case_0_246, && case_0_247, 
        && case_0_248, && case_0_249, && case_0_250, && case_0_251, 
        && case_0_252, && case_0_253, && case_0_254, && case_0_255, 
      };
#endif
      static const DECODE_DESC insns[256] = {
        { I (INSN_SUBV), E (FMT_ADDV) }, { I (INSN_SUBX), E (FMT_ADDX) }, 
        { I (INSN_SUB), E (FMT_ADD) }, { I (INSN_NEG), E (FMT_MV) }, 
        { I (INSN_CMP), E (FMT_CMP) }, { I (INSN_CMPU), E (FMT_CMP) }, 
        { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_ADDV), E (FMT_ADDV) }, { I (INSN_ADDX), E (FMT_ADDX) }, 
        { I (INSN_ADD), E (FMT_ADD) }, { I (INSN_NOT), E (FMT_MV) }, 
        { I (INSN_AND), E (FMT_ADD) }, { I (INSN_XOR), E (FMT_ADD) }, 
        { I (INSN_OR), E (FMT_ADD) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_SRL), E (FMT_ADD) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_SRA), E (FMT_ADD) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_SLL), E (FMT_ADD) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_MUL), E (FMT_ADD) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_MV), E (FMT_MV) }, { I (INSN_MVFC), E (FMT_MVFC) }, 
        { I (INSN_MVTC), E (FMT_MVTC) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { 0 }, { I (INSN_RTE), E (FMT_RTE) }, 
        { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_TRAP), E (FMT_TRAP) }, 
        { I (INSN_STB), E (FMT_STB) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_STH), E (FMT_STH) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_ST), E (FMT_ST) }, { I (INSN_UNLOCK), E (FMT_UNLOCK) }, 
        { I (INSN_ST_PLUS), E (FMT_ST_PLUS) }, { I (INSN_ST_MINUS), E (FMT_ST_PLUS) }, 
        { I (INSN_LDB), E (FMT_LDB) }, { I (INSN_LDUB), E (FMT_LDB) }, 
        { I (INSN_LDH), E (FMT_LDH) }, { I (INSN_LDUH), E (FMT_LDH) }, 
        { I (INSN_LD), E (FMT_LD) }, { I (INSN_LOCK), E (FMT_LOCK) }, 
        { I (INSN_LD_PLUS), E (FMT_LD_PLUS) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_MULHI), E (FMT_MULHI) }, { I (INSN_MULLO), E (FMT_MULHI) }, 
        { I (INSN_MULWHI), E (FMT_MULHI) }, { I (INSN_MULWLO), E (FMT_MULHI) }, 
        { I (INSN_MACHI), E (FMT_MACHI) }, { I (INSN_MACLO), E (FMT_MACHI) }, 
        { I (INSN_MACWHI), E (FMT_MACHI) }, { I (INSN_MACWLO), E (FMT_MACHI) }, 
        { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_ADDI), E (FMT_ADDI) }, { I (INSN_ADDI), E (FMT_ADDI) }, 
        { I (INSN_ADDI), E (FMT_ADDI) }, { I (INSN_ADDI), E (FMT_ADDI) }, 
        { I (INSN_ADDI), E (FMT_ADDI) }, { I (INSN_ADDI), E (FMT_ADDI) }, 
        { I (INSN_ADDI), E (FMT_ADDI) }, { I (INSN_ADDI), E (FMT_ADDI) }, 
        { I (INSN_ADDI), E (FMT_ADDI) }, { I (INSN_ADDI), E (FMT_ADDI) }, 
        { I (INSN_ADDI), E (FMT_ADDI) }, { I (INSN_ADDI), E (FMT_ADDI) }, 
        { I (INSN_ADDI), E (FMT_ADDI) }, { I (INSN_ADDI), E (FMT_ADDI) }, 
        { I (INSN_ADDI), E (FMT_ADDI) }, { I (INSN_ADDI), E (FMT_ADDI) }, 
        { I (INSN_SRLI), E (FMT_SLLI) }, { I (INSN_SRLI), E (FMT_SLLI) }, 
        { I (INSN_SRAI), E (FMT_SLLI) }, { I (INSN_SRAI), E (FMT_SLLI) }, 
        { I (INSN_SLLI), E (FMT_SLLI) }, { I (INSN_SLLI), E (FMT_SLLI) }, 
        { I (INSN_X_INVALID), E (FMT_EMPTY) }, { 0 }, 
        { I (INSN_RACH), E (FMT_RAC) }, { I (INSN_RAC), E (FMT_RAC) }, 
        { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_X_INVALID), E (FMT_EMPTY) }, { 0 }, 
        { I (INSN_LDI8), E (FMT_LDI8) }, { I (INSN_LDI8), E (FMT_LDI8) }, 
        { I (INSN_LDI8), E (FMT_LDI8) }, { I (INSN_LDI8), E (FMT_LDI8) }, 
        { I (INSN_LDI8), E (FMT_LDI8) }, { I (INSN_LDI8), E (FMT_LDI8) }, 
        { I (INSN_LDI8), E (FMT_LDI8) }, { I (INSN_LDI8), E (FMT_LDI8) }, 
        { I (INSN_LDI8), E (FMT_LDI8) }, { I (INSN_LDI8), E (FMT_LDI8) }, 
        { I (INSN_LDI8), E (FMT_LDI8) }, { I (INSN_LDI8), E (FMT_LDI8) }, 
        { I (INSN_LDI8), E (FMT_LDI8) }, { I (INSN_LDI8), E (FMT_LDI8) }, 
        { I (INSN_LDI8), E (FMT_LDI8) }, { I (INSN_LDI8), E (FMT_LDI8) }, 
        { 0 }, { 0 }, 
        { 0 }, { 0 }, 
        { 0 }, { 0 }, 
        { 0 }, { 0 }, 
        { 0 }, { 0 }, 
        { 0 }, { 0 }, 
        { 0 }, { 0 }, 
        { 0 }, { 0 }, 
        { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_CMPI), E (FMT_CMPI) }, { I (INSN_CMPUI), E (FMT_CMPI) }, 
        { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_ADDV3), E (FMT_ADDV3) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_ADD3), E (FMT_ADD3) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_AND3), E (FMT_AND3) }, { I (INSN_XOR3), E (FMT_AND3) }, 
        { I (INSN_OR3), E (FMT_OR3) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_DIV), E (FMT_DIV) }, { I (INSN_DIVU), E (FMT_DIV) }, 
        { I (INSN_REM), E (FMT_DIV) }, { I (INSN_REMU), E (FMT_DIV) }, 
        { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_SRL3), E (FMT_SLL3) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_SRA3), E (FMT_SLL3) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_SLL3), E (FMT_SLL3) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_LDI16), E (FMT_LDI16) }, 
        { I (INSN_STB_D), E (FMT_STB_D) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_STH_D), E (FMT_STH_D) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_ST_D), E (FMT_ST_D) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_LDB_D), E (FMT_LDB_D) }, { I (INSN_LDUB_D), E (FMT_LDB_D) }, 
        { I (INSN_LDH_D), E (FMT_LDH_D) }, { I (INSN_LDUH_D), E (FMT_LDH_D) }, 
        { I (INSN_LD_D), E (FMT_LD_D) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_BEQ), E (FMT_BEQ) }, { I (INSN_BNE), E (FMT_BEQ) }, 
        { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_BEQZ), E (FMT_BEQZ) }, { I (INSN_BNEZ), E (FMT_BEQZ) }, 
        { I (INSN_BLTZ), E (FMT_BEQZ) }, { I (INSN_BGEZ), E (FMT_BEQZ) }, 
        { I (INSN_BLEZ), E (FMT_BEQZ) }, { I (INSN_BGTZ), E (FMT_BEQZ) }, 
        { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_SETH), E (FMT_SETH) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
        { I (INSN_LD24), E (FMT_LD24) }, { I (INSN_LD24), E (FMT_LD24) }, 
        { I (INSN_LD24), E (FMT_LD24) }, { I (INSN_LD24), E (FMT_LD24) }, 
        { I (INSN_LD24), E (FMT_LD24) }, { I (INSN_LD24), E (FMT_LD24) }, 
        { I (INSN_LD24), E (FMT_LD24) }, { I (INSN_LD24), E (FMT_LD24) }, 
        { I (INSN_LD24), E (FMT_LD24) }, { I (INSN_LD24), E (FMT_LD24) }, 
        { I (INSN_LD24), E (FMT_LD24) }, { I (INSN_LD24), E (FMT_LD24) }, 
        { I (INSN_LD24), E (FMT_LD24) }, { I (INSN_LD24), E (FMT_LD24) }, 
        { I (INSN_LD24), E (FMT_LD24) }, { I (INSN_LD24), E (FMT_LD24) }, 
        { 0 }, { 0 }, 
        { 0 }, { 0 }, 
        { 0 }, { 0 }, 
        { 0 }, { 0 }, 
        { 0 }, { 0 }, 
        { 0 }, { 0 }, 
        { 0 }, { 0 }, 
        { 0 }, { 0 }, 
      };
      unsigned int val;
      val = (((insn >> 8) & (15 << 4)) | ((insn >> 4) & (15 << 0)));
      DECODE_SWITCH (0, val)
d249 2
a250 1
        CASE (0, 28) :
d252 3
a254 13
            static const DECODE_DESC insns[16] = {
              { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
              { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
              { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
              { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
              { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
              { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
              { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
              { I (INSN_JL), E (FMT_JL) }, { I (INSN_JMP), E (FMT_JMP) }, 
            };
            unsigned int val = (((insn >> 8) & (15 << 0)));
            idecode = &insns[val];
            GOTO_EXTRACT (idecode);
d256 50
a305 1
        CASE (0, 87) :
d307 3
a309 13
            static const DECODE_DESC insns[16] = {
              { I (INSN_MVTACHI), E (FMT_MVTACHI) }, { I (INSN_MVTACLO), E (FMT_MVTACHI) }, 
              { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
              { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
              { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
              { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
              { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
              { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
              { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
            };
            unsigned int val = (((insn >> 0) & (15 << 0)));
            idecode = &insns[val];
            GOTO_EXTRACT (idecode);
d311 7
a317 1
        CASE (0, 95) :
d319 4
a322 13
            static const DECODE_DESC insns[16] = {
              { I (INSN_MVFACHI), E (FMT_MVFACHI) }, { I (INSN_MVFACLO), E (FMT_MVFACHI) }, 
              { I (INSN_MVFACMI), E (FMT_MVFACHI) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
              { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
              { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
              { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
              { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
              { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
              { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
            };
            unsigned int val = (((insn >> 0) & (15 << 0)));
            idecode = &insns[val];
            GOTO_EXTRACT (idecode);
d324 21
a344 1
        CASE (0, 112) :
d346 6
a351 13
            static const DECODE_DESC insns[16] = {
              { I (INSN_NOP), E (FMT_NOP) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
              { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
              { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
              { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
              { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
              { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
              { I (INSN_BC8), E (FMT_BC8) }, { I (INSN_BNC8), E (FMT_BC8) }, 
              { I (INSN_BL8), E (FMT_BL8) }, { I (INSN_BRA8), E (FMT_BRA8) }, 
            };
            unsigned int val = (((insn >> 8) & (15 << 0)));
            idecode = &insns[val];
            GOTO_EXTRACT (idecode);
d353 19
a371 15
        CASE (0, 113) : /* fall through */
        CASE (0, 114) : /* fall through */
        CASE (0, 115) : /* fall through */
        CASE (0, 116) : /* fall through */
        CASE (0, 117) : /* fall through */
        CASE (0, 118) : /* fall through */
        CASE (0, 119) : /* fall through */
        CASE (0, 120) : /* fall through */
        CASE (0, 121) : /* fall through */
        CASE (0, 122) : /* fall through */
        CASE (0, 123) : /* fall through */
        CASE (0, 124) : /* fall through */
        CASE (0, 125) : /* fall through */
        CASE (0, 126) : /* fall through */
        CASE (0, 127) :
d373 5
a377 13
            static const DECODE_DESC insns[16] = {
              { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
              { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
              { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
              { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
              { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
              { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
              { I (INSN_BC8), E (FMT_BC8) }, { I (INSN_BNC8), E (FMT_BC8) }, 
              { I (INSN_BL8), E (FMT_BL8) }, { I (INSN_BRA8), E (FMT_BRA8) }, 
            };
            unsigned int val = (((insn >> 8) & (15 << 0)));
            idecode = &insns[val];
            GOTO_EXTRACT (idecode);
d379 68
a446 16
        CASE (0, 240) : /* fall through */
        CASE (0, 241) : /* fall through */
        CASE (0, 242) : /* fall through */
        CASE (0, 243) : /* fall through */
        CASE (0, 244) : /* fall through */
        CASE (0, 245) : /* fall through */
        CASE (0, 246) : /* fall through */
        CASE (0, 247) : /* fall through */
        CASE (0, 248) : /* fall through */
        CASE (0, 249) : /* fall through */
        CASE (0, 250) : /* fall through */
        CASE (0, 251) : /* fall through */
        CASE (0, 252) : /* fall through */
        CASE (0, 253) : /* fall through */
        CASE (0, 254) : /* fall through */
        CASE (0, 255) :
d448 5
a452 13
            static const DECODE_DESC insns[16] = {
              { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
              { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
              { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
              { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
              { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
              { I (INSN_X_INVALID), E (FMT_EMPTY) }, { I (INSN_X_INVALID), E (FMT_EMPTY) }, 
              { I (INSN_BC24), E (FMT_BC24) }, { I (INSN_BNC24), E (FMT_BC24) }, 
              { I (INSN_BL24), E (FMT_BL24) }, { I (INSN_BRA24), E (FMT_BRA24) }, 
            };
            unsigned int val = (((insn >> 8) & (15 << 0)));
            idecode = &insns[val];
            GOTO_EXTRACT (idecode);
a453 3
        DEFAULT (0) :
          idecode = &insns[val];
          GOTO_EXTRACT (idecode);
d455 2
a456 1
      ENDSWITCH (0)
a457 2
#undef I
#undef E
d462 1
a462 8
 extract:
  {
#ifndef __GNUC__
    switch (idecode->sfmt)
#endif
      {

  CASE (ex, FMT_EMPTY) :
d464 1
a466 1
  EXTRACT_IFMT_EMPTY_VARS /* */
a467 1
  EXTRACT_IFMT_EMPTY_CODE
d470 1
a470 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_empty", (char *) 0));
d473 1
a473 1
  BREAK (ex);
d476 1
a476 1
  CASE (ex, FMT_ADD) :
d478 1
d480 3
a482 2
#define FLD(f) abuf->fields.fmt_add.f
  EXTRACT_IFMT_ADD_VARS /* f-op1 f-r1 f-op2 f-r2 */
d484 2
a485 1
  EXTRACT_IFMT_ADD_CODE
d488 2
d492 1
a492 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_add", "dr 0x%x", 'x', f_r1, "sr 0x%x", 'x', f_r2, (char *) 0));
d504 1
a504 1
  BREAK (ex);
d507 1
a507 1
  CASE (ex, FMT_ADD3) :
d509 1
d511 4
a514 2
#define FLD(f) abuf->fields.fmt_add3.f
  EXTRACT_IFMT_ADD3_VARS /* f-op1 f-r1 f-op2 f-r2 f-simm16 */
d516 3
a518 1
  EXTRACT_IFMT_ADD3_CODE
d522 2
d526 1
a526 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_add3", "f_simm16 0x%x", 'x', f_simm16, "sr 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));
d537 1
a537 1
  BREAK (ex);
d540 1
a540 1
  CASE (ex, FMT_AND3) :
d542 1
d544 4
a547 2
#define FLD(f) abuf->fields.fmt_and3.f
  EXTRACT_IFMT_AND3_VARS /* f-op1 f-r1 f-op2 f-r2 f-uimm16 */
d549 3
a551 1
  EXTRACT_IFMT_AND3_CODE
d554 1
d556 1
d559 1
a559 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_and3", "f_uimm16 0x%x", 'x', f_uimm16, "sr 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));
d570 1
a570 1
  BREAK (ex);
d573 1
a573 1
  CASE (ex, FMT_OR3) :
d575 1
d577 4
a580 2
#define FLD(f) abuf->fields.fmt_or3.f
  EXTRACT_IFMT_OR3_VARS /* f-op1 f-r1 f-op2 f-r2 f-uimm16 */
d582 3
a584 1
  EXTRACT_IFMT_OR3_CODE
d587 1
d589 1
d592 1
a592 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_or3", "f_uimm16 0x%x", 'x', f_uimm16, "sr 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));
d603 1
a603 1
  BREAK (ex);
d606 1
a606 1
  CASE (ex, FMT_ADDI) :
d608 1
d610 3
a612 2
#define FLD(f) abuf->fields.fmt_addi.f
  EXTRACT_IFMT_ADDI_VARS /* f-op1 f-r1 f-simm8 */
d614 2
a615 1
  EXTRACT_IFMT_ADDI_CODE
d618 1
d621 1
a621 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_addi", "f_simm8 0x%x", 'x', f_simm8, "dr 0x%x", 'x', f_r1, (char *) 0));
d632 1
a632 1
  BREAK (ex);
d635 1
a635 1
  CASE (ex, FMT_ADDV) :
d637 1
d639 3
a641 2
#define FLD(f) abuf->fields.fmt_addv.f
  EXTRACT_IFMT_ADD_VARS /* f-op1 f-r1 f-op2 f-r2 */
d643 2
a644 1
  EXTRACT_IFMT_ADD_CODE
d647 2
d651 1
a651 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_addv", "dr 0x%x", 'x', f_r1, "sr 0x%x", 'x', f_r2, (char *) 0));
d663 1
a663 1
  BREAK (ex);
d666 1
a666 1
  CASE (ex, FMT_ADDV3) :
d668 1
d670 4
a673 2
#define FLD(f) abuf->fields.fmt_addv3.f
  EXTRACT_IFMT_ADDV3_VARS /* f-op1 f-r1 f-op2 f-r2 f-simm16 */
d675 3
a677 1
  EXTRACT_IFMT_ADDV3_CODE
d681 2
d685 1
a685 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_addv3", "f_simm16 0x%x", 'x', f_simm16, "sr 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));
d696 1
a696 1
  BREAK (ex);
d699 1
a699 1
  CASE (ex, FMT_ADDX) :
d701 1
d703 3
a705 2
#define FLD(f) abuf->fields.fmt_addx.f
  EXTRACT_IFMT_ADD_VARS /* f-op1 f-r1 f-op2 f-r2 */
d707 2
a708 1
  EXTRACT_IFMT_ADD_CODE
d711 2
d715 1
a715 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_addx", "dr 0x%x", 'x', f_r1, "sr 0x%x", 'x', f_r2, (char *) 0));
d727 1
a727 1
  BREAK (ex);
d730 1
a730 1
  CASE (ex, FMT_BC8) :
d732 1
d734 2
a735 2
#define FLD(f) abuf->fields.cti.fields.fmt_bc8.f
  EXTRACT_IFMT_BC8_VARS /* f-op1 f-r1 f-disp8 */
d737 1
a737 1
  EXTRACT_IFMT_BC8_CODE
d741 1
a741 2
  SEM_BRANCH_INIT_EXTRACT (abuf);
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_bc8", "disp8 0x%x", 'x', f_disp8, (char *) 0));
d750 1
a750 1
  BREAK (ex);
d753 1
a753 1
  CASE (ex, FMT_BC24) :
d755 1
d757 2
a758 2
#define FLD(f) abuf->fields.cti.fields.fmt_bc24.f
  EXTRACT_IFMT_BC24_VARS /* f-op1 f-r1 f-disp24 */
d760 1
a760 1
  EXTRACT_IFMT_BC24_CODE
d764 1
a764 2
  SEM_BRANCH_INIT_EXTRACT (abuf);
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_bc24", "disp24 0x%x", 'x', f_disp24, (char *) 0));
d773 1
a773 1
  BREAK (ex);
d776 1
a776 1
  CASE (ex, FMT_BEQ) :
d778 1
d780 4
a783 2
#define FLD(f) abuf->fields.cti.fields.fmt_beq.f
  EXTRACT_IFMT_BEQ_VARS /* f-op1 f-r1 f-op2 f-r2 f-disp16 */
d785 3
a787 1
  EXTRACT_IFMT_BEQ_CODE
d790 2
d795 1
a795 2
  SEM_BRANCH_INIT_EXTRACT (abuf);
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_beq", "disp16 0x%x", 'x', f_disp16, "src1 0x%x", 'x', f_r1, "src2 0x%x", 'x', f_r2, (char *) 0));
d806 1
a806 1
  BREAK (ex);
d809 1
a809 1
  CASE (ex, FMT_BEQZ) :
d811 1
d813 3
a815 2
#define FLD(f) abuf->fields.cti.fields.fmt_beqz.f
  EXTRACT_IFMT_BEQZ_VARS /* f-op1 f-r1 f-op2 f-r2 f-disp16 */
d817 2
a818 1
  EXTRACT_IFMT_BEQZ_CODE
d821 1
d824 1
a824 2
  SEM_BRANCH_INIT_EXTRACT (abuf);
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_beqz", "disp16 0x%x", 'x', f_disp16, "src2 0x%x", 'x', f_r2, (char *) 0));
d834 1
a834 1
  BREAK (ex);
d837 1
a837 1
  CASE (ex, FMT_BL8) :
d839 1
d841 2
a842 2
#define FLD(f) abuf->fields.cti.fields.fmt_bl8.f
  EXTRACT_IFMT_BC8_VARS /* f-op1 f-r1 f-disp8 */
d844 1
a844 1
  EXTRACT_IFMT_BC8_CODE
d848 1
a848 2
  SEM_BRANCH_INIT_EXTRACT (abuf);
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_bl8", "disp8 0x%x", 'x', f_disp8, (char *) 0));
d858 1
a858 1
  BREAK (ex);
d861 1
a861 1
  CASE (ex, FMT_BL24) :
d863 1
d865 2
a866 2
#define FLD(f) abuf->fields.cti.fields.fmt_bl24.f
  EXTRACT_IFMT_BC24_VARS /* f-op1 f-r1 f-disp24 */
d868 1
a868 1
  EXTRACT_IFMT_BC24_CODE
d872 1
a872 2
  SEM_BRANCH_INIT_EXTRACT (abuf);
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_bl24", "disp24 0x%x", 'x', f_disp24, (char *) 0));
d882 1
a882 1
  BREAK (ex);
d885 1
a885 1
  CASE (ex, FMT_BRA8) :
d887 1
d889 2
a890 2
#define FLD(f) abuf->fields.cti.fields.fmt_bra8.f
  EXTRACT_IFMT_BC8_VARS /* f-op1 f-r1 f-disp8 */
d892 1
a892 1
  EXTRACT_IFMT_BC8_CODE
d896 1
a896 2
  SEM_BRANCH_INIT_EXTRACT (abuf);
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_bra8", "disp8 0x%x", 'x', f_disp8, (char *) 0));
d905 1
a905 1
  BREAK (ex);
d908 1
a908 1
  CASE (ex, FMT_BRA24) :
d910 1
d912 2
a913 2
#define FLD(f) abuf->fields.cti.fields.fmt_bra24.f
  EXTRACT_IFMT_BC24_VARS /* f-op1 f-r1 f-disp24 */
d915 1
a915 1
  EXTRACT_IFMT_BC24_CODE
d919 1
a919 2
  SEM_BRANCH_INIT_EXTRACT (abuf);
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_bra24", "disp24 0x%x", 'x', f_disp24, (char *) 0));
d928 1
a928 1
  BREAK (ex);
d931 1
a931 1
  CASE (ex, FMT_CMP) :
d933 1
d935 3
a937 2
#define FLD(f) abuf->fields.fmt_cmp.f
  EXTRACT_IFMT_CMP_VARS /* f-op1 f-r1 f-op2 f-r2 */
d939 2
a940 1
  EXTRACT_IFMT_CMP_CODE
d943 2
d947 1
a947 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_cmp", "src1 0x%x", 'x', f_r1, "src2 0x%x", 'x', f_r2, (char *) 0));
d958 1
a958 1
  BREAK (ex);
d961 1
a961 1
  CASE (ex, FMT_CMPI) :
d963 1
d965 3
a967 2
#define FLD(f) abuf->fields.fmt_cmpi.f
  EXTRACT_IFMT_CMPI_VARS /* f-op1 f-r1 f-op2 f-r2 f-simm16 */
d969 2
a970 1
  EXTRACT_IFMT_CMPI_CODE
d974 1
d976 1
a976 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_cmpi", "f_simm16 0x%x", 'x', f_simm16, "src2 0x%x", 'x', f_r2, (char *) 0));
d986 1
a986 1
  BREAK (ex);
d989 1
a989 1
  CASE (ex, FMT_DIV) :
d991 1
d993 3
a995 2
#define FLD(f) abuf->fields.fmt_div.f
  EXTRACT_IFMT_DIV_VARS /* f-op1 f-r1 f-op2 f-r2 f-simm16 */
d997 2
a998 1
  EXTRACT_IFMT_DIV_CODE
d1001 2
d1005 1
a1005 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_div", "dr 0x%x", 'x', f_r1, "sr 0x%x", 'x', f_r2, (char *) 0));
d1017 1
a1017 1
  BREAK (ex);
d1020 1
a1020 1
  CASE (ex, FMT_JL) :
d1022 1
d1024 2
a1025 2
#define FLD(f) abuf->fields.cti.fields.fmt_jl.f
  EXTRACT_IFMT_JL_VARS /* f-op1 f-r1 f-op2 f-r2 */
d1027 1
a1027 1
  EXTRACT_IFMT_JL_CODE
d1030 1
d1032 1
a1032 2
  SEM_BRANCH_INIT_EXTRACT (abuf);
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_jl", "sr 0x%x", 'x', f_r2, (char *) 0));
d1043 1
a1043 1
  BREAK (ex);
d1046 1
a1046 1
  CASE (ex, FMT_JMP) :
d1048 1
d1050 2
a1051 2
#define FLD(f) abuf->fields.cti.fields.fmt_jmp.f
  EXTRACT_IFMT_JL_VARS /* f-op1 f-r1 f-op2 f-r2 */
d1053 1
a1053 1
  EXTRACT_IFMT_JL_CODE
d1056 1
d1058 1
a1058 2
  SEM_BRANCH_INIT_EXTRACT (abuf);
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_jmp", "sr 0x%x", 'x', f_r2, (char *) 0));
d1068 1
a1068 1
  BREAK (ex);
d1071 1
a1071 1
  CASE (ex, FMT_LD) :
d1073 1
d1075 3
a1077 2
#define FLD(f) abuf->fields.fmt_ld.f
  EXTRACT_IFMT_ADD_VARS /* f-op1 f-r1 f-op2 f-r2 */
d1079 2
a1080 1
  EXTRACT_IFMT_ADD_CODE
d1083 2
d1087 1
a1087 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_ld", "sr 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));
d1098 1
a1098 1
  BREAK (ex);
d1101 1
a1101 1
  CASE (ex, FMT_LD_D) :
d1103 1
d1105 4
a1108 2
#define FLD(f) abuf->fields.fmt_ld_d.f
  EXTRACT_IFMT_ADD3_VARS /* f-op1 f-r1 f-op2 f-r2 f-simm16 */
d1110 3
a1112 1
  EXTRACT_IFMT_ADD3_CODE
d1116 2
d1120 1
a1120 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_ld_d", "f_simm16 0x%x", 'x', f_simm16, "sr 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));
d1131 1
a1131 1
  BREAK (ex);
d1134 1
a1134 1
  CASE (ex, FMT_LDB) :
d1136 1
d1138 3
a1140 2
#define FLD(f) abuf->fields.fmt_ldb.f
  EXTRACT_IFMT_ADD_VARS /* f-op1 f-r1 f-op2 f-r2 */
d1142 2
a1143 1
  EXTRACT_IFMT_ADD_CODE
d1146 2
d1150 1
a1150 103
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_ldb", "sr 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_sr) = f_r2;
      FLD (out_dr) = f_r1;
    }
#endif
#undef FLD
  BREAK (ex);
  }

  CASE (ex, FMT_LDB_D) :
  {
    CGEN_INSN_INT insn = entire_insn;
#define FLD(f) abuf->fields.fmt_ldb_d.f
  EXTRACT_IFMT_ADD3_VARS /* f-op1 f-r1 f-op2 f-r2 f-simm16 */

  EXTRACT_IFMT_ADD3_CODE

  /* Record the fields for the semantic handler.  */
  FLD (f_simm16) = f_simm16;
  FLD (i_sr) = & CPU (h_gr)[f_r2];
  FLD (i_dr) = & CPU (h_gr)[f_r1];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_ldb_d", "f_simm16 0x%x", 'x', f_simm16, "sr 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_sr) = f_r2;
      FLD (out_dr) = f_r1;
    }
#endif
#undef FLD
  BREAK (ex);
  }

  CASE (ex, FMT_LDH) :
  {
    CGEN_INSN_INT insn = entire_insn;
#define FLD(f) abuf->fields.fmt_ldh.f
  EXTRACT_IFMT_ADD_VARS /* f-op1 f-r1 f-op2 f-r2 */

  EXTRACT_IFMT_ADD_CODE

  /* Record the fields for the semantic handler.  */
  FLD (i_sr) = & CPU (h_gr)[f_r2];
  FLD (i_dr) = & CPU (h_gr)[f_r1];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_ldh", "sr 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_sr) = f_r2;
      FLD (out_dr) = f_r1;
    }
#endif
#undef FLD
  BREAK (ex);
  }

  CASE (ex, FMT_LDH_D) :
  {
    CGEN_INSN_INT insn = entire_insn;
#define FLD(f) abuf->fields.fmt_ldh_d.f
  EXTRACT_IFMT_ADD3_VARS /* f-op1 f-r1 f-op2 f-r2 f-simm16 */

  EXTRACT_IFMT_ADD3_CODE

  /* Record the fields for the semantic handler.  */
  FLD (f_simm16) = f_simm16;
  FLD (i_sr) = & CPU (h_gr)[f_r2];
  FLD (i_dr) = & CPU (h_gr)[f_r1];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_ldh_d", "f_simm16 0x%x", 'x', f_simm16, "sr 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));

#if WITH_PROFILE_MODEL_P
  /* Record the fields for profiling.  */
  if (PROFILE_MODEL_P (current_cpu))
    {
      FLD (in_sr) = f_r2;
      FLD (out_dr) = f_r1;
    }
#endif
#undef FLD
  BREAK (ex);
  }

  CASE (ex, FMT_LD_PLUS) :
  {
    CGEN_INSN_INT insn = entire_insn;
#define FLD(f) abuf->fields.fmt_ld_plus.f
  EXTRACT_IFMT_ADD_VARS /* f-op1 f-r1 f-op2 f-r2 */

  EXTRACT_IFMT_ADD_CODE

  /* Record the fields for the semantic handler.  */
  FLD (i_sr) = & CPU (h_gr)[f_r2];
  FLD (i_dr) = & CPU (h_gr)[f_r1];
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_ld_plus", "sr 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));
d1162 1
a1162 1
  BREAK (ex);
d1165 1
a1165 1
  CASE (ex, FMT_LD24) :
d1167 1
d1169 3
a1171 2
#define FLD(f) abuf->fields.fmt_ld24.f
  EXTRACT_IFMT_LD24_VARS /* f-op1 f-r1 f-uimm24 */
d1173 2
a1174 1
  EXTRACT_IFMT_LD24_CODE
d1177 1
d1180 1
a1180 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_ld24", "uimm24 0x%x", 'x', f_uimm24, "dr 0x%x", 'x', f_r1, (char *) 0));
d1190 1
a1190 1
  BREAK (ex);
d1193 1
a1193 1
  CASE (ex, FMT_LDI8) :
d1195 1
d1197 3
a1199 2
#define FLD(f) abuf->fields.fmt_ldi8.f
  EXTRACT_IFMT_ADDI_VARS /* f-op1 f-r1 f-simm8 */
d1201 2
a1202 1
  EXTRACT_IFMT_ADDI_CODE
d1206 1
d1208 1
a1208 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_ldi8", "f_simm8 0x%x", 'x', f_simm8, "dr 0x%x", 'x', f_r1, (char *) 0));
d1218 1
a1218 1
  BREAK (ex);
d1221 1
a1221 1
  CASE (ex, FMT_LDI16) :
d1223 1
d1225 3
a1227 2
#define FLD(f) abuf->fields.fmt_ldi16.f
  EXTRACT_IFMT_LDI16_VARS /* f-op1 f-r1 f-op2 f-r2 f-simm16 */
d1229 2
a1230 1
  EXTRACT_IFMT_LDI16_CODE
d1234 1
d1236 1
a1236 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_ldi16", "f_simm16 0x%x", 'x', f_simm16, "dr 0x%x", 'x', f_r1, (char *) 0));
d1246 1
a1246 1
  BREAK (ex);
d1249 1
a1249 1
  CASE (ex, FMT_LOCK) :
d1251 1
d1253 3
a1255 2
#define FLD(f) abuf->fields.fmt_lock.f
  EXTRACT_IFMT_ADD_VARS /* f-op1 f-r1 f-op2 f-r2 */
d1257 2
a1258 1
  EXTRACT_IFMT_ADD_CODE
d1261 2
d1265 1
a1265 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_lock", "sr 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));
d1276 1
a1276 1
  BREAK (ex);
d1279 1
a1279 1
  CASE (ex, FMT_MACHI) :
d1281 1
d1283 3
a1285 2
#define FLD(f) abuf->fields.fmt_machi.f
  EXTRACT_IFMT_CMP_VARS /* f-op1 f-r1 f-op2 f-r2 */
d1287 2
a1288 1
  EXTRACT_IFMT_CMP_CODE
d1291 2
d1295 1
a1295 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_machi", "src1 0x%x", 'x', f_r1, "src2 0x%x", 'x', f_r2, (char *) 0));
d1306 1
a1306 1
  BREAK (ex);
d1309 1
a1309 1
  CASE (ex, FMT_MULHI) :
d1311 1
d1313 3
a1315 2
#define FLD(f) abuf->fields.fmt_mulhi.f
  EXTRACT_IFMT_CMP_VARS /* f-op1 f-r1 f-op2 f-r2 */
d1317 2
a1318 1
  EXTRACT_IFMT_CMP_CODE
d1321 2
d1325 1
a1325 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_mulhi", "src1 0x%x", 'x', f_r1, "src2 0x%x", 'x', f_r2, (char *) 0));
d1336 1
a1336 1
  BREAK (ex);
d1339 1
a1339 1
  CASE (ex, FMT_MV) :
d1341 1
d1343 3
a1345 2
#define FLD(f) abuf->fields.fmt_mv.f
  EXTRACT_IFMT_ADD_VARS /* f-op1 f-r1 f-op2 f-r2 */
d1347 2
a1348 1
  EXTRACT_IFMT_ADD_CODE
d1351 2
d1355 1
a1355 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_mv", "sr 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));
d1366 1
a1366 1
  BREAK (ex);
d1369 1
a1369 1
  CASE (ex, FMT_MVFACHI) :
d1371 1
d1373 2
a1374 2
#define FLD(f) abuf->fields.fmt_mvfachi.f
  EXTRACT_IFMT_MVFACHI_VARS /* f-op1 f-r1 f-op2 f-r2 */
d1376 1
a1376 1
  EXTRACT_IFMT_MVFACHI_CODE
d1379 1
d1381 1
a1381 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_mvfachi", "dr 0x%x", 'x', f_r1, (char *) 0));
d1391 1
a1391 1
  BREAK (ex);
d1394 1
a1394 1
  CASE (ex, FMT_MVFC) :
d1396 1
d1398 3
a1400 2
#define FLD(f) abuf->fields.fmt_mvfc.f
  EXTRACT_IFMT_MVFC_VARS /* f-op1 f-r1 f-op2 f-r2 */
d1402 2
a1403 1
  EXTRACT_IFMT_MVFC_CODE
d1407 1
d1409 1
a1409 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_mvfc", "f_r2 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));
d1419 1
a1419 1
  BREAK (ex);
d1422 1
a1422 1
  CASE (ex, FMT_MVTACHI) :
d1424 1
d1426 2
a1427 2
#define FLD(f) abuf->fields.fmt_mvtachi.f
  EXTRACT_IFMT_MVTACHI_VARS /* f-op1 f-r1 f-op2 f-r2 */
d1429 1
a1429 1
  EXTRACT_IFMT_MVTACHI_CODE
d1432 1
d1434 1
a1434 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_mvtachi", "src1 0x%x", 'x', f_r1, (char *) 0));
d1444 1
a1444 1
  BREAK (ex);
d1447 1
a1447 1
  CASE (ex, FMT_MVTC) :
d1449 1
d1451 3
a1453 2
#define FLD(f) abuf->fields.fmt_mvtc.f
  EXTRACT_IFMT_MVTC_VARS /* f-op1 f-r1 f-op2 f-r2 */
d1455 2
a1456 1
  EXTRACT_IFMT_MVTC_CODE
d1459 1
d1462 1
a1462 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_mvtc", "f_r1 0x%x", 'x', f_r1, "sr 0x%x", 'x', f_r2, (char *) 0));
d1472 1
a1472 1
  BREAK (ex);
d1475 1
a1475 1
  CASE (ex, FMT_NOP) :
d1477 1
d1479 1
a1479 2
#define FLD(f) abuf->fields.fmt_nop.f
  EXTRACT_IFMT_NOP_VARS /* f-op1 f-r1 f-op2 f-r2 */
a1480 1
  EXTRACT_IFMT_NOP_CODE
d1483 1
a1483 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_nop", (char *) 0));
d1486 1
a1486 1
  BREAK (ex);
d1489 1
a1489 1
  CASE (ex, FMT_RAC) :
d1491 1
d1493 1
a1493 2
#define FLD(f) abuf->fields.fmt_rac.f
  EXTRACT_IFMT_NOP_VARS /* f-op1 f-r1 f-op2 f-r2 */
a1494 1
  EXTRACT_IFMT_NOP_CODE
d1497 1
a1497 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_rac", (char *) 0));
d1500 1
a1500 1
  BREAK (ex);
d1503 1
a1503 1
  CASE (ex, FMT_RTE) :
d1505 1
d1507 1
a1507 2
#define FLD(f) abuf->fields.cti.fields.fmt_rte.f
  EXTRACT_IFMT_NOP_VARS /* f-op1 f-r1 f-op2 f-r2 */
a1508 1
  EXTRACT_IFMT_NOP_CODE
d1511 1
a1511 2
  SEM_BRANCH_INIT_EXTRACT (abuf);
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_rte", (char *) 0));
d1520 1
a1520 1
  BREAK (ex);
d1523 1
a1523 1
  CASE (ex, FMT_SETH) :
d1525 1
d1527 3
a1529 2
#define FLD(f) abuf->fields.fmt_seth.f
  EXTRACT_IFMT_SETH_VARS /* f-op1 f-r1 f-op2 f-r2 f-hi16 */
d1531 2
a1532 1
  EXTRACT_IFMT_SETH_CODE
d1536 1
d1538 1
a1538 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_seth", "f_hi16 0x%x", 'x', f_hi16, "dr 0x%x", 'x', f_r1, (char *) 0));
d1548 1
a1548 1
  BREAK (ex);
d1551 1
a1551 1
  CASE (ex, FMT_SLL3) :
d1553 1
d1555 4
a1558 2
#define FLD(f) abuf->fields.fmt_sll3.f
  EXTRACT_IFMT_ADDV3_VARS /* f-op1 f-r1 f-op2 f-r2 f-simm16 */
d1560 3
a1562 1
  EXTRACT_IFMT_ADDV3_CODE
d1566 2
d1570 1
a1570 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_sll3", "f_simm16 0x%x", 'x', f_simm16, "sr 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));
d1581 1
a1581 1
  BREAK (ex);
d1584 1
a1584 1
  CASE (ex, FMT_SLLI) :
d1586 1
d1588 3
a1590 2
#define FLD(f) abuf->fields.fmt_slli.f
  EXTRACT_IFMT_SLLI_VARS /* f-op1 f-r1 f-shift-op2 f-uimm5 */
d1592 2
a1593 1
  EXTRACT_IFMT_SLLI_CODE
d1596 1
d1599 1
a1599 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_slli", "f_uimm5 0x%x", 'x', f_uimm5, "dr 0x%x", 'x', f_r1, (char *) 0));
d1610 1
a1610 1
  BREAK (ex);
d1613 1
a1613 1
  CASE (ex, FMT_ST) :
d1615 1
d1617 3
a1619 2
#define FLD(f) abuf->fields.fmt_st.f
  EXTRACT_IFMT_CMP_VARS /* f-op1 f-r1 f-op2 f-r2 */
d1621 2
a1622 1
  EXTRACT_IFMT_CMP_CODE
d1625 2
d1629 1
a1629 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_st", "src1 0x%x", 'x', f_r1, "src2 0x%x", 'x', f_r2, (char *) 0));
d1640 1
a1640 1
  BREAK (ex);
d1643 1
a1643 1
  CASE (ex, FMT_ST_D) :
d1645 1
d1647 4
a1650 2
#define FLD(f) abuf->fields.fmt_st_d.f
  EXTRACT_IFMT_ST_D_VARS /* f-op1 f-r1 f-op2 f-r2 f-simm16 */
d1652 3
a1654 1
  EXTRACT_IFMT_ST_D_CODE
d1658 2
d1662 1
a1662 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_st_d", "f_simm16 0x%x", 'x', f_simm16, "src1 0x%x", 'x', f_r1, "src2 0x%x", 'x', f_r2, (char *) 0));
d1673 1
a1673 1
  BREAK (ex);
d1676 1
a1676 1
  CASE (ex, FMT_STB) :
d1678 1
d1680 3
a1682 2
#define FLD(f) abuf->fields.fmt_stb.f
  EXTRACT_IFMT_CMP_VARS /* f-op1 f-r1 f-op2 f-r2 */
d1684 2
a1685 1
  EXTRACT_IFMT_CMP_CODE
d1688 2
d1692 1
a1692 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_stb", "src1 0x%x", 'x', f_r1, "src2 0x%x", 'x', f_r2, (char *) 0));
d1703 1
a1703 1
  BREAK (ex);
d1706 1
a1706 1
  CASE (ex, FMT_STB_D) :
d1708 1
d1710 4
a1713 2
#define FLD(f) abuf->fields.fmt_stb_d.f
  EXTRACT_IFMT_ST_D_VARS /* f-op1 f-r1 f-op2 f-r2 f-simm16 */
d1715 3
a1717 1
  EXTRACT_IFMT_ST_D_CODE
d1721 2
d1725 1
a1725 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_stb_d", "f_simm16 0x%x", 'x', f_simm16, "src1 0x%x", 'x', f_r1, "src2 0x%x", 'x', f_r2, (char *) 0));
d1736 1
a1736 1
  BREAK (ex);
d1739 1
a1739 1
  CASE (ex, FMT_STH) :
d1741 1
d1743 3
a1745 2
#define FLD(f) abuf->fields.fmt_sth.f
  EXTRACT_IFMT_CMP_VARS /* f-op1 f-r1 f-op2 f-r2 */
d1747 2
a1748 1
  EXTRACT_IFMT_CMP_CODE
d1751 2
d1755 1
a1755 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_sth", "src1 0x%x", 'x', f_r1, "src2 0x%x", 'x', f_r2, (char *) 0));
d1766 1
a1766 1
  BREAK (ex);
d1769 1
a1769 1
  CASE (ex, FMT_STH_D) :
d1771 1
d1773 4
a1776 2
#define FLD(f) abuf->fields.fmt_sth_d.f
  EXTRACT_IFMT_ST_D_VARS /* f-op1 f-r1 f-op2 f-r2 f-simm16 */
d1778 3
a1780 1
  EXTRACT_IFMT_ST_D_CODE
d1784 2
d1788 1
a1788 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_sth_d", "f_simm16 0x%x", 'x', f_simm16, "src1 0x%x", 'x', f_r1, "src2 0x%x", 'x', f_r2, (char *) 0));
d1799 1
a1799 1
  BREAK (ex);
d1802 1
a1802 1
  CASE (ex, FMT_ST_PLUS) :
d1804 1
d1806 3
a1808 2
#define FLD(f) abuf->fields.fmt_st_plus.f
  EXTRACT_IFMT_CMP_VARS /* f-op1 f-r1 f-op2 f-r2 */
d1810 2
a1811 1
  EXTRACT_IFMT_CMP_CODE
d1814 2
d1818 1
a1818 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_st_plus", "src1 0x%x", 'x', f_r1, "src2 0x%x", 'x', f_r2, (char *) 0));
d1830 1
a1830 1
  BREAK (ex);
d1833 1
a1833 1
  CASE (ex, FMT_TRAP) :
d1835 1
d1837 2
a1838 2
#define FLD(f) abuf->fields.cti.fields.fmt_trap.f
  EXTRACT_IFMT_TRAP_VARS /* f-op1 f-r1 f-op2 f-uimm4 */
d1840 1
a1840 1
  EXTRACT_IFMT_TRAP_CODE
d1844 1
a1844 2
  SEM_BRANCH_INIT_EXTRACT (abuf);
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_trap", "f_uimm4 0x%x", 'x', f_uimm4, (char *) 0));
d1853 1
a1853 1
  BREAK (ex);
d1856 1
a1856 1
  CASE (ex, FMT_UNLOCK) :
d1858 1
d1860 3
a1862 2
#define FLD(f) abuf->fields.fmt_unlock.f
  EXTRACT_IFMT_CMP_VARS /* f-op1 f-r1 f-op2 f-r2 */
d1864 2
a1865 1
  EXTRACT_IFMT_CMP_CODE
d1868 2
d1872 1
a1872 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "fmt_unlock", "src1 0x%x", 'x', f_r1, "src2 0x%x", 'x', f_r2, (char *) 0));
d1883 1
a1883 7
  BREAK (ex);
  }


      }
    ENDSWITCH (ex)

a1885 1
  return idecode->idesc;
@


1.1.1.1
log
@Initial creation of sourceware repository
@
text
@@


1.1.1.2
log
@import gdb-19990422 snapshot
@
text
@a48 5
/* The INSN_ prefix is not here and is instead part of the `insn' argument
   to avoid collisions with header files (e.g. `AND' in ansidecl.h).  */
#define IDX(insn) CONCAT2 (M32RBF_,insn)
#define TYPE(insn) CONCAT2 (M32R_,insn)

d56 5
a177 3
#undef FMT
#undef FULL
#undef FAST
d239 44
d290 4
a293 2
  /* Result of decoder.  */
  M32RBF_INSN_TYPE itype;
d296 6
d303 1
d306 201
a506 24
      unsigned int val = (((insn >> 8) & (15 << 4)) | ((insn >> 4) & (15 << 0)));
      switch (val)
      {
      case 0 : itype = M32RBF_INSN_SUBV; goto extract_fmt_addv;
      case 1 : itype = M32RBF_INSN_SUBX; goto extract_fmt_addx;
      case 2 : itype = M32RBF_INSN_SUB; goto extract_fmt_add;
      case 3 : itype = M32RBF_INSN_NEG; goto extract_fmt_mv;
      case 4 : itype = M32RBF_INSN_CMP; goto extract_fmt_cmp;
      case 5 : itype = M32RBF_INSN_CMPU; goto extract_fmt_cmp;
      case 8 : itype = M32RBF_INSN_ADDV; goto extract_fmt_addv;
      case 9 : itype = M32RBF_INSN_ADDX; goto extract_fmt_addx;
      case 10 : itype = M32RBF_INSN_ADD; goto extract_fmt_add;
      case 11 : itype = M32RBF_INSN_NOT; goto extract_fmt_mv;
      case 12 : itype = M32RBF_INSN_AND; goto extract_fmt_add;
      case 13 : itype = M32RBF_INSN_XOR; goto extract_fmt_add;
      case 14 : itype = M32RBF_INSN_OR; goto extract_fmt_add;
      case 16 : itype = M32RBF_INSN_SRL; goto extract_fmt_add;
      case 18 : itype = M32RBF_INSN_SRA; goto extract_fmt_add;
      case 20 : itype = M32RBF_INSN_SLL; goto extract_fmt_add;
      case 22 : itype = M32RBF_INSN_MUL; goto extract_fmt_add;
      case 24 : itype = M32RBF_INSN_MV; goto extract_fmt_mv;
      case 25 : itype = M32RBF_INSN_MVFC; goto extract_fmt_mvfc;
      case 26 : itype = M32RBF_INSN_MVTC; goto extract_fmt_mvtc;
      case 28 :
d508 1
a508 2
          unsigned int val = (((insn >> 8) & (15 << 0)));
          switch (val)
d510 13
a522 3
          case 14 : itype = M32RBF_INSN_JL; goto extract_fmt_jl;
          case 15 : itype = M32RBF_INSN_JMP; goto extract_fmt_jmp;
          default : itype = M32RBF_INSN_X_INVALID; goto extract_fmt_empty;
d524 1
a524 50
        }
      case 29 : itype = M32RBF_INSN_RTE; goto extract_fmt_rte;
      case 31 : itype = M32RBF_INSN_TRAP; goto extract_fmt_trap;
      case 32 : itype = M32RBF_INSN_STB; goto extract_fmt_stb;
      case 34 : itype = M32RBF_INSN_STH; goto extract_fmt_sth;
      case 36 : itype = M32RBF_INSN_ST; goto extract_fmt_st;
      case 37 : itype = M32RBF_INSN_UNLOCK; goto extract_fmt_unlock;
      case 38 : itype = M32RBF_INSN_ST_PLUS; goto extract_fmt_st_plus;
      case 39 : itype = M32RBF_INSN_ST_MINUS; goto extract_fmt_st_plus;
      case 40 : itype = M32RBF_INSN_LDB; goto extract_fmt_ldb;
      case 41 : itype = M32RBF_INSN_LDUB; goto extract_fmt_ldb;
      case 42 : itype = M32RBF_INSN_LDH; goto extract_fmt_ldh;
      case 43 : itype = M32RBF_INSN_LDUH; goto extract_fmt_ldh;
      case 44 : itype = M32RBF_INSN_LD; goto extract_fmt_ld;
      case 45 : itype = M32RBF_INSN_LOCK; goto extract_fmt_lock;
      case 46 : itype = M32RBF_INSN_LD_PLUS; goto extract_fmt_ld_plus;
      case 48 : itype = M32RBF_INSN_MULHI; goto extract_fmt_mulhi;
      case 49 : itype = M32RBF_INSN_MULLO; goto extract_fmt_mulhi;
      case 50 : itype = M32RBF_INSN_MULWHI; goto extract_fmt_mulhi;
      case 51 : itype = M32RBF_INSN_MULWLO; goto extract_fmt_mulhi;
      case 52 : itype = M32RBF_INSN_MACHI; goto extract_fmt_machi;
      case 53 : itype = M32RBF_INSN_MACLO; goto extract_fmt_machi;
      case 54 : itype = M32RBF_INSN_MACWHI; goto extract_fmt_machi;
      case 55 : itype = M32RBF_INSN_MACWLO; goto extract_fmt_machi;
      case 64 : /* fall through */
      case 65 : /* fall through */
      case 66 : /* fall through */
      case 67 : /* fall through */
      case 68 : /* fall through */
      case 69 : /* fall through */
      case 70 : /* fall through */
      case 71 : /* fall through */
      case 72 : /* fall through */
      case 73 : /* fall through */
      case 74 : /* fall through */
      case 75 : /* fall through */
      case 76 : /* fall through */
      case 77 : /* fall through */
      case 78 : /* fall through */
      case 79 : itype = M32RBF_INSN_ADDI; goto extract_fmt_addi;
      case 80 : /* fall through */
      case 81 : itype = M32RBF_INSN_SRLI; goto extract_fmt_slli;
      case 82 : /* fall through */
      case 83 : itype = M32RBF_INSN_SRAI; goto extract_fmt_slli;
      case 84 : /* fall through */
      case 85 : itype = M32RBF_INSN_SLLI; goto extract_fmt_slli;
      case 87 :
        {
          unsigned int val = (((insn >> 0) & (15 << 0)));
          switch (val)
d526 13
a538 3
          case 0 : itype = M32RBF_INSN_MVTACHI; goto extract_fmt_mvtachi;
          case 1 : itype = M32RBF_INSN_MVTACLO; goto extract_fmt_mvtachi;
          default : itype = M32RBF_INSN_X_INVALID; goto extract_fmt_empty;
d540 1
a540 7
        }
      case 88 : itype = M32RBF_INSN_RACH; goto extract_fmt_rac;
      case 89 : itype = M32RBF_INSN_RAC; goto extract_fmt_rac;
      case 95 :
        {
          unsigned int val = (((insn >> 0) & (15 << 0)));
          switch (val)
d542 13
a554 4
          case 0 : itype = M32RBF_INSN_MVFACHI; goto extract_fmt_mvfachi;
          case 1 : itype = M32RBF_INSN_MVFACLO; goto extract_fmt_mvfachi;
          case 2 : itype = M32RBF_INSN_MVFACMI; goto extract_fmt_mvfachi;
          default : itype = M32RBF_INSN_X_INVALID; goto extract_fmt_empty;
d556 1
a556 21
        }
      case 96 : /* fall through */
      case 97 : /* fall through */
      case 98 : /* fall through */
      case 99 : /* fall through */
      case 100 : /* fall through */
      case 101 : /* fall through */
      case 102 : /* fall through */
      case 103 : /* fall through */
      case 104 : /* fall through */
      case 105 : /* fall through */
      case 106 : /* fall through */
      case 107 : /* fall through */
      case 108 : /* fall through */
      case 109 : /* fall through */
      case 110 : /* fall through */
      case 111 : itype = M32RBF_INSN_LDI8; goto extract_fmt_ldi8;
      case 112 :
        {
          unsigned int val = (((insn >> 8) & (15 << 0)));
          switch (val)
d558 13
a570 6
          case 0 : itype = M32RBF_INSN_NOP; goto extract_fmt_nop;
          case 12 : itype = M32RBF_INSN_BC8; goto extract_fmt_bc8;
          case 13 : itype = M32RBF_INSN_BNC8; goto extract_fmt_bc8;
          case 14 : itype = M32RBF_INSN_BL8; goto extract_fmt_bl8;
          case 15 : itype = M32RBF_INSN_BRA8; goto extract_fmt_bra8;
          default : itype = M32RBF_INSN_X_INVALID; goto extract_fmt_empty;
d572 15
a586 19
        }
      case 113 : /* fall through */
      case 114 : /* fall through */
      case 115 : /* fall through */
      case 116 : /* fall through */
      case 117 : /* fall through */
      case 118 : /* fall through */
      case 119 : /* fall through */
      case 120 : /* fall through */
      case 121 : /* fall through */
      case 122 : /* fall through */
      case 123 : /* fall through */
      case 124 : /* fall through */
      case 125 : /* fall through */
      case 126 : /* fall through */
      case 127 :
        {
          unsigned int val = (((insn >> 8) & (15 << 0)));
          switch (val)
d588 13
a600 5
          case 12 : itype = M32RBF_INSN_BC8; goto extract_fmt_bc8;
          case 13 : itype = M32RBF_INSN_BNC8; goto extract_fmt_bc8;
          case 14 : itype = M32RBF_INSN_BL8; goto extract_fmt_bl8;
          case 15 : itype = M32RBF_INSN_BRA8; goto extract_fmt_bra8;
          default : itype = M32RBF_INSN_X_INVALID; goto extract_fmt_empty;
d602 16
a617 68
        }
      case 132 : itype = M32RBF_INSN_CMPI; goto extract_fmt_cmpi;
      case 133 : itype = M32RBF_INSN_CMPUI; goto extract_fmt_cmpi;
      case 136 : itype = M32RBF_INSN_ADDV3; goto extract_fmt_addv3;
      case 138 : itype = M32RBF_INSN_ADD3; goto extract_fmt_add3;
      case 140 : itype = M32RBF_INSN_AND3; goto extract_fmt_and3;
      case 141 : itype = M32RBF_INSN_XOR3; goto extract_fmt_and3;
      case 142 : itype = M32RBF_INSN_OR3; goto extract_fmt_or3;
      case 144 : itype = M32RBF_INSN_DIV; goto extract_fmt_div;
      case 145 : itype = M32RBF_INSN_DIVU; goto extract_fmt_div;
      case 146 : itype = M32RBF_INSN_REM; goto extract_fmt_div;
      case 147 : itype = M32RBF_INSN_REMU; goto extract_fmt_div;
      case 152 : itype = M32RBF_INSN_SRL3; goto extract_fmt_sll3;
      case 154 : itype = M32RBF_INSN_SRA3; goto extract_fmt_sll3;
      case 156 : itype = M32RBF_INSN_SLL3; goto extract_fmt_sll3;
      case 159 : itype = M32RBF_INSN_LDI16; goto extract_fmt_ldi16;
      case 160 : itype = M32RBF_INSN_STB_D; goto extract_fmt_stb_d;
      case 162 : itype = M32RBF_INSN_STH_D; goto extract_fmt_sth_d;
      case 164 : itype = M32RBF_INSN_ST_D; goto extract_fmt_st_d;
      case 168 : itype = M32RBF_INSN_LDB_D; goto extract_fmt_ldb_d;
      case 169 : itype = M32RBF_INSN_LDUB_D; goto extract_fmt_ldb_d;
      case 170 : itype = M32RBF_INSN_LDH_D; goto extract_fmt_ldh_d;
      case 171 : itype = M32RBF_INSN_LDUH_D; goto extract_fmt_ldh_d;
      case 172 : itype = M32RBF_INSN_LD_D; goto extract_fmt_ld_d;
      case 176 : itype = M32RBF_INSN_BEQ; goto extract_fmt_beq;
      case 177 : itype = M32RBF_INSN_BNE; goto extract_fmt_beq;
      case 184 : itype = M32RBF_INSN_BEQZ; goto extract_fmt_beqz;
      case 185 : itype = M32RBF_INSN_BNEZ; goto extract_fmt_beqz;
      case 186 : itype = M32RBF_INSN_BLTZ; goto extract_fmt_beqz;
      case 187 : itype = M32RBF_INSN_BGEZ; goto extract_fmt_beqz;
      case 188 : itype = M32RBF_INSN_BLEZ; goto extract_fmt_beqz;
      case 189 : itype = M32RBF_INSN_BGTZ; goto extract_fmt_beqz;
      case 220 : itype = M32RBF_INSN_SETH; goto extract_fmt_seth;
      case 224 : /* fall through */
      case 225 : /* fall through */
      case 226 : /* fall through */
      case 227 : /* fall through */
      case 228 : /* fall through */
      case 229 : /* fall through */
      case 230 : /* fall through */
      case 231 : /* fall through */
      case 232 : /* fall through */
      case 233 : /* fall through */
      case 234 : /* fall through */
      case 235 : /* fall through */
      case 236 : /* fall through */
      case 237 : /* fall through */
      case 238 : /* fall through */
      case 239 : itype = M32RBF_INSN_LD24; goto extract_fmt_ld24;
      case 240 : /* fall through */
      case 241 : /* fall through */
      case 242 : /* fall through */
      case 243 : /* fall through */
      case 244 : /* fall through */
      case 245 : /* fall through */
      case 246 : /* fall through */
      case 247 : /* fall through */
      case 248 : /* fall through */
      case 249 : /* fall through */
      case 250 : /* fall through */
      case 251 : /* fall through */
      case 252 : /* fall through */
      case 253 : /* fall through */
      case 254 : /* fall through */
      case 255 :
        {
          unsigned int val = (((insn >> 8) & (15 << 0)));
          switch (val)
d619 13
a631 5
          case 12 : itype = M32RBF_INSN_BC24; goto extract_fmt_bc24;
          case 13 : itype = M32RBF_INSN_BNC24; goto extract_fmt_bc24;
          case 14 : itype = M32RBF_INSN_BL24; goto extract_fmt_bl24;
          case 15 : itype = M32RBF_INSN_BRA24; goto extract_fmt_bra24;
          default : itype = M32RBF_INSN_X_INVALID; goto extract_fmt_empty;
d633 3
d637 1
a637 2
      default : itype = M32RBF_INSN_X_INVALID; goto extract_fmt_empty;
      }
d639 2
d645 8
a652 1
 extract_fmt_empty:
a653 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d664 1
a664 1
    return idesc;
d667 1
a667 1
 extract_fmt_add:
a668 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d690 1
a690 1
    return idesc;
d693 1
a693 1
 extract_fmt_add3:
a694 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d716 1
a716 1
    return idesc;
d719 1
a719 1
 extract_fmt_and3:
a720 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d742 1
a742 1
    return idesc;
d745 1
a745 1
 extract_fmt_or3:
a746 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d768 1
a768 1
    return idesc;
d771 1
a771 1
 extract_fmt_addi:
a772 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d793 1
a793 1
    return idesc;
d796 1
a796 1
 extract_fmt_addv:
a797 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d819 1
a819 1
    return idesc;
d822 1
a822 1
 extract_fmt_addv3:
a823 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d845 1
a845 1
    return idesc;
d848 1
a848 1
 extract_fmt_addx:
a849 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d871 1
a871 1
    return idesc;
d874 1
a874 1
 extract_fmt_bc8:
a875 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d894 1
a894 1
    return idesc;
d897 1
a897 1
 extract_fmt_bc24:
a898 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d917 1
a917 1
    return idesc;
d920 1
a920 1
 extract_fmt_beq:
a921 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d944 1
a944 1
    return idesc;
d947 1
a947 1
 extract_fmt_beqz:
a948 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d969 1
a969 1
    return idesc;
d972 1
a972 1
 extract_fmt_bl8:
a973 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d993 1
a993 1
    return idesc;
d996 1
a996 1
 extract_fmt_bl24:
a997 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1017 1
a1017 1
    return idesc;
d1020 1
a1020 1
 extract_fmt_bra8:
a1021 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1040 1
a1040 1
    return idesc;
d1043 1
a1043 1
 extract_fmt_bra24:
a1044 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1063 1
a1063 1
    return idesc;
d1066 1
a1066 1
 extract_fmt_cmp:
a1067 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1088 1
a1088 1
    return idesc;
d1091 1
a1091 1
 extract_fmt_cmpi:
a1092 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1112 1
a1112 1
    return idesc;
d1115 1
a1115 1
 extract_fmt_div:
a1116 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1138 1
a1138 1
    return idesc;
d1141 1
a1141 1
 extract_fmt_jl:
a1142 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1163 1
a1163 1
    return idesc;
d1166 1
a1166 1
 extract_fmt_jmp:
a1167 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1187 1
a1187 1
    return idesc;
d1190 1
a1190 1
 extract_fmt_ld:
a1191 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1212 1
a1212 1
    return idesc;
d1215 1
a1215 1
 extract_fmt_ld_d:
a1216 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1238 1
a1238 1
    return idesc;
d1241 1
a1241 1
 extract_fmt_ldb:
a1242 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1263 1
a1263 1
    return idesc;
d1266 1
a1266 1
 extract_fmt_ldb_d:
a1267 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1289 1
a1289 1
    return idesc;
d1292 1
a1292 1
 extract_fmt_ldh:
a1293 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1314 1
a1314 1
    return idesc;
d1317 1
a1317 1
 extract_fmt_ldh_d:
a1318 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1340 1
a1340 1
    return idesc;
d1343 1
a1343 1
 extract_fmt_ld_plus:
a1344 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1366 1
a1366 1
    return idesc;
d1369 1
a1369 1
 extract_fmt_ld24:
a1370 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1390 1
a1390 1
    return idesc;
d1393 1
a1393 1
 extract_fmt_ldi8:
a1394 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1414 1
a1414 1
    return idesc;
d1417 1
a1417 1
 extract_fmt_ldi16:
a1418 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1438 1
a1438 1
    return idesc;
d1441 1
a1441 1
 extract_fmt_lock:
a1442 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1463 1
a1463 1
    return idesc;
d1466 1
a1466 1
 extract_fmt_machi:
a1467 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1488 1
a1488 1
    return idesc;
d1491 1
a1491 1
 extract_fmt_mulhi:
a1492 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1513 1
a1513 1
    return idesc;
d1516 1
a1516 1
 extract_fmt_mv:
a1517 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1538 1
a1538 1
    return idesc;
d1541 1
a1541 1
 extract_fmt_mvfachi:
a1542 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1561 1
a1561 1
    return idesc;
d1564 1
a1564 1
 extract_fmt_mvfc:
a1565 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1585 1
a1585 1
    return idesc;
d1588 1
a1588 1
 extract_fmt_mvtachi:
a1589 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1608 1
a1608 1
    return idesc;
d1611 1
a1611 1
 extract_fmt_mvtc:
a1612 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1632 1
a1632 1
    return idesc;
d1635 1
a1635 1
 extract_fmt_nop:
a1636 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1647 1
a1647 1
    return idesc;
d1650 1
a1650 1
 extract_fmt_rac:
a1651 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1662 1
a1662 1
    return idesc;
d1665 1
a1665 1
 extract_fmt_rte:
a1666 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1684 1
a1684 1
    return idesc;
d1687 1
a1687 1
 extract_fmt_seth:
a1688 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1708 1
a1708 1
    return idesc;
d1711 1
a1711 1
 extract_fmt_sll3:
a1712 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1734 1
a1734 1
    return idesc;
d1737 1
a1737 1
 extract_fmt_slli:
a1738 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1759 1
a1759 1
    return idesc;
d1762 1
a1762 1
 extract_fmt_st:
a1763 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1784 1
a1784 1
    return idesc;
d1787 1
a1787 1
 extract_fmt_st_d:
a1788 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1810 1
a1810 1
    return idesc;
d1813 1
a1813 1
 extract_fmt_stb:
a1814 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1835 1
a1835 1
    return idesc;
d1838 1
a1838 1
 extract_fmt_stb_d:
a1839 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1861 1
a1861 1
    return idesc;
d1864 1
a1864 1
 extract_fmt_sth:
a1865 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1886 1
a1886 1
    return idesc;
d1889 1
a1889 1
 extract_fmt_sth_d:
a1890 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1912 1
a1912 1
    return idesc;
d1915 1
a1915 1
 extract_fmt_st_plus:
a1916 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1938 1
a1938 1
    return idesc;
d1941 1
a1941 1
 extract_fmt_trap:
a1942 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1961 1
a1961 1
    return idesc;
d1964 1
a1964 1
 extract_fmt_unlock:
a1965 1
    const IDESC *idesc = &m32rbf_insn_data[itype];
d1986 7
a1992 1
    return idesc;
d1995 1
@


1.1.1.3
log
@import gdb-1999-08-09 snapshot
@
text
@d31 23
d66 105
a170 105
  { VIRTUAL_INSN_X_INVALID, M32RBF_INSN_X_INVALID, M32RBF_SFMT_EMPTY },
  { VIRTUAL_INSN_X_AFTER, M32RBF_INSN_X_AFTER, M32RBF_SFMT_EMPTY },
  { VIRTUAL_INSN_X_BEFORE, M32RBF_INSN_X_BEFORE, M32RBF_SFMT_EMPTY },
  { VIRTUAL_INSN_X_CTI_CHAIN, M32RBF_INSN_X_CTI_CHAIN, M32RBF_SFMT_EMPTY },
  { VIRTUAL_INSN_X_CHAIN, M32RBF_INSN_X_CHAIN, M32RBF_SFMT_EMPTY },
  { VIRTUAL_INSN_X_BEGIN, M32RBF_INSN_X_BEGIN, M32RBF_SFMT_EMPTY },
  { M32R_INSN_ADD, M32RBF_INSN_ADD, M32RBF_SFMT_ADD },
  { M32R_INSN_ADD3, M32RBF_INSN_ADD3, M32RBF_SFMT_ADD3 },
  { M32R_INSN_AND, M32RBF_INSN_AND, M32RBF_SFMT_ADD },
  { M32R_INSN_AND3, M32RBF_INSN_AND3, M32RBF_SFMT_AND3 },
  { M32R_INSN_OR, M32RBF_INSN_OR, M32RBF_SFMT_ADD },
  { M32R_INSN_OR3, M32RBF_INSN_OR3, M32RBF_SFMT_OR3 },
  { M32R_INSN_XOR, M32RBF_INSN_XOR, M32RBF_SFMT_ADD },
  { M32R_INSN_XOR3, M32RBF_INSN_XOR3, M32RBF_SFMT_AND3 },
  { M32R_INSN_ADDI, M32RBF_INSN_ADDI, M32RBF_SFMT_ADDI },
  { M32R_INSN_ADDV, M32RBF_INSN_ADDV, M32RBF_SFMT_ADDV },
  { M32R_INSN_ADDV3, M32RBF_INSN_ADDV3, M32RBF_SFMT_ADDV3 },
  { M32R_INSN_ADDX, M32RBF_INSN_ADDX, M32RBF_SFMT_ADDX },
  { M32R_INSN_BC8, M32RBF_INSN_BC8, M32RBF_SFMT_BC8 },
  { M32R_INSN_BC24, M32RBF_INSN_BC24, M32RBF_SFMT_BC24 },
  { M32R_INSN_BEQ, M32RBF_INSN_BEQ, M32RBF_SFMT_BEQ },
  { M32R_INSN_BEQZ, M32RBF_INSN_BEQZ, M32RBF_SFMT_BEQZ },
  { M32R_INSN_BGEZ, M32RBF_INSN_BGEZ, M32RBF_SFMT_BEQZ },
  { M32R_INSN_BGTZ, M32RBF_INSN_BGTZ, M32RBF_SFMT_BEQZ },
  { M32R_INSN_BLEZ, M32RBF_INSN_BLEZ, M32RBF_SFMT_BEQZ },
  { M32R_INSN_BLTZ, M32RBF_INSN_BLTZ, M32RBF_SFMT_BEQZ },
  { M32R_INSN_BNEZ, M32RBF_INSN_BNEZ, M32RBF_SFMT_BEQZ },
  { M32R_INSN_BL8, M32RBF_INSN_BL8, M32RBF_SFMT_BL8 },
  { M32R_INSN_BL24, M32RBF_INSN_BL24, M32RBF_SFMT_BL24 },
  { M32R_INSN_BNC8, M32RBF_INSN_BNC8, M32RBF_SFMT_BC8 },
  { M32R_INSN_BNC24, M32RBF_INSN_BNC24, M32RBF_SFMT_BC24 },
  { M32R_INSN_BNE, M32RBF_INSN_BNE, M32RBF_SFMT_BEQ },
  { M32R_INSN_BRA8, M32RBF_INSN_BRA8, M32RBF_SFMT_BRA8 },
  { M32R_INSN_BRA24, M32RBF_INSN_BRA24, M32RBF_SFMT_BRA24 },
  { M32R_INSN_CMP, M32RBF_INSN_CMP, M32RBF_SFMT_CMP },
  { M32R_INSN_CMPI, M32RBF_INSN_CMPI, M32RBF_SFMT_CMPI },
  { M32R_INSN_CMPU, M32RBF_INSN_CMPU, M32RBF_SFMT_CMP },
  { M32R_INSN_CMPUI, M32RBF_INSN_CMPUI, M32RBF_SFMT_CMPI },
  { M32R_INSN_DIV, M32RBF_INSN_DIV, M32RBF_SFMT_DIV },
  { M32R_INSN_DIVU, M32RBF_INSN_DIVU, M32RBF_SFMT_DIV },
  { M32R_INSN_REM, M32RBF_INSN_REM, M32RBF_SFMT_DIV },
  { M32R_INSN_REMU, M32RBF_INSN_REMU, M32RBF_SFMT_DIV },
  { M32R_INSN_JL, M32RBF_INSN_JL, M32RBF_SFMT_JL },
  { M32R_INSN_JMP, M32RBF_INSN_JMP, M32RBF_SFMT_JMP },
  { M32R_INSN_LD, M32RBF_INSN_LD, M32RBF_SFMT_LD },
  { M32R_INSN_LD_D, M32RBF_INSN_LD_D, M32RBF_SFMT_LD_D },
  { M32R_INSN_LDB, M32RBF_INSN_LDB, M32RBF_SFMT_LD },
  { M32R_INSN_LDB_D, M32RBF_INSN_LDB_D, M32RBF_SFMT_LD_D },
  { M32R_INSN_LDH, M32RBF_INSN_LDH, M32RBF_SFMT_LD },
  { M32R_INSN_LDH_D, M32RBF_INSN_LDH_D, M32RBF_SFMT_LD_D },
  { M32R_INSN_LDUB, M32RBF_INSN_LDUB, M32RBF_SFMT_LD },
  { M32R_INSN_LDUB_D, M32RBF_INSN_LDUB_D, M32RBF_SFMT_LD_D },
  { M32R_INSN_LDUH, M32RBF_INSN_LDUH, M32RBF_SFMT_LD },
  { M32R_INSN_LDUH_D, M32RBF_INSN_LDUH_D, M32RBF_SFMT_LD_D },
  { M32R_INSN_LD_PLUS, M32RBF_INSN_LD_PLUS, M32RBF_SFMT_LD_PLUS },
  { M32R_INSN_LD24, M32RBF_INSN_LD24, M32RBF_SFMT_LD24 },
  { M32R_INSN_LDI8, M32RBF_INSN_LDI8, M32RBF_SFMT_LDI8 },
  { M32R_INSN_LDI16, M32RBF_INSN_LDI16, M32RBF_SFMT_LDI16 },
  { M32R_INSN_LOCK, M32RBF_INSN_LOCK, M32RBF_SFMT_LOCK },
  { M32R_INSN_MACHI, M32RBF_INSN_MACHI, M32RBF_SFMT_MACHI },
  { M32R_INSN_MACLO, M32RBF_INSN_MACLO, M32RBF_SFMT_MACHI },
  { M32R_INSN_MACWHI, M32RBF_INSN_MACWHI, M32RBF_SFMT_MACHI },
  { M32R_INSN_MACWLO, M32RBF_INSN_MACWLO, M32RBF_SFMT_MACHI },
  { M32R_INSN_MUL, M32RBF_INSN_MUL, M32RBF_SFMT_ADD },
  { M32R_INSN_MULHI, M32RBF_INSN_MULHI, M32RBF_SFMT_MULHI },
  { M32R_INSN_MULLO, M32RBF_INSN_MULLO, M32RBF_SFMT_MULHI },
  { M32R_INSN_MULWHI, M32RBF_INSN_MULWHI, M32RBF_SFMT_MULHI },
  { M32R_INSN_MULWLO, M32RBF_INSN_MULWLO, M32RBF_SFMT_MULHI },
  { M32R_INSN_MV, M32RBF_INSN_MV, M32RBF_SFMT_MV },
  { M32R_INSN_MVFACHI, M32RBF_INSN_MVFACHI, M32RBF_SFMT_MVFACHI },
  { M32R_INSN_MVFACLO, M32RBF_INSN_MVFACLO, M32RBF_SFMT_MVFACHI },
  { M32R_INSN_MVFACMI, M32RBF_INSN_MVFACMI, M32RBF_SFMT_MVFACHI },
  { M32R_INSN_MVFC, M32RBF_INSN_MVFC, M32RBF_SFMT_MVFC },
  { M32R_INSN_MVTACHI, M32RBF_INSN_MVTACHI, M32RBF_SFMT_MVTACHI },
  { M32R_INSN_MVTACLO, M32RBF_INSN_MVTACLO, M32RBF_SFMT_MVTACHI },
  { M32R_INSN_MVTC, M32RBF_INSN_MVTC, M32RBF_SFMT_MVTC },
  { M32R_INSN_NEG, M32RBF_INSN_NEG, M32RBF_SFMT_MV },
  { M32R_INSN_NOP, M32RBF_INSN_NOP, M32RBF_SFMT_NOP },
  { M32R_INSN_NOT, M32RBF_INSN_NOT, M32RBF_SFMT_MV },
  { M32R_INSN_RAC, M32RBF_INSN_RAC, M32RBF_SFMT_RAC },
  { M32R_INSN_RACH, M32RBF_INSN_RACH, M32RBF_SFMT_RAC },
  { M32R_INSN_RTE, M32RBF_INSN_RTE, M32RBF_SFMT_RTE },
  { M32R_INSN_SETH, M32RBF_INSN_SETH, M32RBF_SFMT_SETH },
  { M32R_INSN_SLL, M32RBF_INSN_SLL, M32RBF_SFMT_ADD },
  { M32R_INSN_SLL3, M32RBF_INSN_SLL3, M32RBF_SFMT_SLL3 },
  { M32R_INSN_SLLI, M32RBF_INSN_SLLI, M32RBF_SFMT_SLLI },
  { M32R_INSN_SRA, M32RBF_INSN_SRA, M32RBF_SFMT_ADD },
  { M32R_INSN_SRA3, M32RBF_INSN_SRA3, M32RBF_SFMT_SLL3 },
  { M32R_INSN_SRAI, M32RBF_INSN_SRAI, M32RBF_SFMT_SLLI },
  { M32R_INSN_SRL, M32RBF_INSN_SRL, M32RBF_SFMT_ADD },
  { M32R_INSN_SRL3, M32RBF_INSN_SRL3, M32RBF_SFMT_SLL3 },
  { M32R_INSN_SRLI, M32RBF_INSN_SRLI, M32RBF_SFMT_SLLI },
  { M32R_INSN_ST, M32RBF_INSN_ST, M32RBF_SFMT_ST },
  { M32R_INSN_ST_D, M32RBF_INSN_ST_D, M32RBF_SFMT_ST_D },
  { M32R_INSN_STB, M32RBF_INSN_STB, M32RBF_SFMT_STB },
  { M32R_INSN_STB_D, M32RBF_INSN_STB_D, M32RBF_SFMT_STB_D },
  { M32R_INSN_STH, M32RBF_INSN_STH, M32RBF_SFMT_STH },
  { M32R_INSN_STH_D, M32RBF_INSN_STH_D, M32RBF_SFMT_STH_D },
  { M32R_INSN_ST_PLUS, M32RBF_INSN_ST_PLUS, M32RBF_SFMT_ST_PLUS },
  { M32R_INSN_ST_MINUS, M32RBF_INSN_ST_MINUS, M32RBF_SFMT_ST_PLUS },
  { M32R_INSN_SUB, M32RBF_INSN_SUB, M32RBF_SFMT_ADD },
  { M32R_INSN_SUBV, M32RBF_INSN_SUBV, M32RBF_SFMT_ADDV },
  { M32R_INSN_SUBX, M32RBF_INSN_SUBX, M32RBF_SFMT_ADDX },
  { M32R_INSN_TRAP, M32RBF_INSN_TRAP, M32RBF_SFMT_TRAP },
  { M32R_INSN_UNLOCK, M32RBF_INSN_UNLOCK, M32RBF_SFMT_UNLOCK },
d173 3
a175 2
static const struct insn_sem m32rbf_insn_sem_invalid = {
  VIRTUAL_INSN_X_INVALID, M32RBF_INSN_X_INVALID, M32RBF_SFMT_EMPTY
d178 6
a191 1
  id->sfmt = t->sfmt;
d199 6
a204 1

a211 2

  /* Semantic pointers are initialized elsewhere.  */
d259 20
a278 20
      case 0 : itype = M32RBF_INSN_SUBV; goto extract_sfmt_addv;
      case 1 : itype = M32RBF_INSN_SUBX; goto extract_sfmt_addx;
      case 2 : itype = M32RBF_INSN_SUB; goto extract_sfmt_add;
      case 3 : itype = M32RBF_INSN_NEG; goto extract_sfmt_mv;
      case 4 : itype = M32RBF_INSN_CMP; goto extract_sfmt_cmp;
      case 5 : itype = M32RBF_INSN_CMPU; goto extract_sfmt_cmp;
      case 8 : itype = M32RBF_INSN_ADDV; goto extract_sfmt_addv;
      case 9 : itype = M32RBF_INSN_ADDX; goto extract_sfmt_addx;
      case 10 : itype = M32RBF_INSN_ADD; goto extract_sfmt_add;
      case 11 : itype = M32RBF_INSN_NOT; goto extract_sfmt_mv;
      case 12 : itype = M32RBF_INSN_AND; goto extract_sfmt_add;
      case 13 : itype = M32RBF_INSN_XOR; goto extract_sfmt_add;
      case 14 : itype = M32RBF_INSN_OR; goto extract_sfmt_add;
      case 16 : itype = M32RBF_INSN_SRL; goto extract_sfmt_add;
      case 18 : itype = M32RBF_INSN_SRA; goto extract_sfmt_add;
      case 20 : itype = M32RBF_INSN_SLL; goto extract_sfmt_add;
      case 22 : itype = M32RBF_INSN_MUL; goto extract_sfmt_add;
      case 24 : itype = M32RBF_INSN_MV; goto extract_sfmt_mv;
      case 25 : itype = M32RBF_INSN_MVFC; goto extract_sfmt_mvfc;
      case 26 : itype = M32RBF_INSN_MVTC; goto extract_sfmt_mvtc;
d284 3
a286 3
          case 14 : itype = M32RBF_INSN_JL; goto extract_sfmt_jl;
          case 15 : itype = M32RBF_INSN_JMP; goto extract_sfmt_jmp;
          default : itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
d289 23
a311 23
      case 29 : itype = M32RBF_INSN_RTE; goto extract_sfmt_rte;
      case 31 : itype = M32RBF_INSN_TRAP; goto extract_sfmt_trap;
      case 32 : itype = M32RBF_INSN_STB; goto extract_sfmt_stb;
      case 34 : itype = M32RBF_INSN_STH; goto extract_sfmt_sth;
      case 36 : itype = M32RBF_INSN_ST; goto extract_sfmt_st;
      case 37 : itype = M32RBF_INSN_UNLOCK; goto extract_sfmt_unlock;
      case 38 : itype = M32RBF_INSN_ST_PLUS; goto extract_sfmt_st_plus;
      case 39 : itype = M32RBF_INSN_ST_MINUS; goto extract_sfmt_st_plus;
      case 40 : itype = M32RBF_INSN_LDB; goto extract_sfmt_ld;
      case 41 : itype = M32RBF_INSN_LDUB; goto extract_sfmt_ld;
      case 42 : itype = M32RBF_INSN_LDH; goto extract_sfmt_ld;
      case 43 : itype = M32RBF_INSN_LDUH; goto extract_sfmt_ld;
      case 44 : itype = M32RBF_INSN_LD; goto extract_sfmt_ld;
      case 45 : itype = M32RBF_INSN_LOCK; goto extract_sfmt_lock;
      case 46 : itype = M32RBF_INSN_LD_PLUS; goto extract_sfmt_ld_plus;
      case 48 : itype = M32RBF_INSN_MULHI; goto extract_sfmt_mulhi;
      case 49 : itype = M32RBF_INSN_MULLO; goto extract_sfmt_mulhi;
      case 50 : itype = M32RBF_INSN_MULWHI; goto extract_sfmt_mulhi;
      case 51 : itype = M32RBF_INSN_MULWLO; goto extract_sfmt_mulhi;
      case 52 : itype = M32RBF_INSN_MACHI; goto extract_sfmt_machi;
      case 53 : itype = M32RBF_INSN_MACLO; goto extract_sfmt_machi;
      case 54 : itype = M32RBF_INSN_MACWHI; goto extract_sfmt_machi;
      case 55 : itype = M32RBF_INSN_MACWLO; goto extract_sfmt_machi;
d327 1
a327 1
      case 79 : itype = M32RBF_INSN_ADDI; goto extract_sfmt_addi;
d329 1
a329 1
      case 81 : itype = M32RBF_INSN_SRLI; goto extract_sfmt_slli;
d331 1
a331 1
      case 83 : itype = M32RBF_INSN_SRAI; goto extract_sfmt_slli;
d333 1
a333 1
      case 85 : itype = M32RBF_INSN_SLLI; goto extract_sfmt_slli;
d339 3
a341 3
          case 0 : itype = M32RBF_INSN_MVTACHI; goto extract_sfmt_mvtachi;
          case 1 : itype = M32RBF_INSN_MVTACLO; goto extract_sfmt_mvtachi;
          default : itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
d344 2
a345 2
      case 88 : itype = M32RBF_INSN_RACH; goto extract_sfmt_rac;
      case 89 : itype = M32RBF_INSN_RAC; goto extract_sfmt_rac;
d351 4
a354 4
          case 0 : itype = M32RBF_INSN_MVFACHI; goto extract_sfmt_mvfachi;
          case 1 : itype = M32RBF_INSN_MVFACLO; goto extract_sfmt_mvfachi;
          case 2 : itype = M32RBF_INSN_MVFACMI; goto extract_sfmt_mvfachi;
          default : itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
d372 1
a372 1
      case 111 : itype = M32RBF_INSN_LDI8; goto extract_sfmt_ldi8;
d378 6
a383 6
          case 0 : itype = M32RBF_INSN_NOP; goto extract_sfmt_nop;
          case 12 : itype = M32RBF_INSN_BC8; goto extract_sfmt_bc8;
          case 13 : itype = M32RBF_INSN_BNC8; goto extract_sfmt_bc8;
          case 14 : itype = M32RBF_INSN_BL8; goto extract_sfmt_bl8;
          case 15 : itype = M32RBF_INSN_BRA8; goto extract_sfmt_bra8;
          default : itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
d405 5
a409 5
          case 12 : itype = M32RBF_INSN_BC8; goto extract_sfmt_bc8;
          case 13 : itype = M32RBF_INSN_BNC8; goto extract_sfmt_bc8;
          case 14 : itype = M32RBF_INSN_BL8; goto extract_sfmt_bl8;
          case 15 : itype = M32RBF_INSN_BRA8; goto extract_sfmt_bra8;
          default : itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
d412 32
a443 32
      case 132 : itype = M32RBF_INSN_CMPI; goto extract_sfmt_cmpi;
      case 133 : itype = M32RBF_INSN_CMPUI; goto extract_sfmt_cmpi;
      case 136 : itype = M32RBF_INSN_ADDV3; goto extract_sfmt_addv3;
      case 138 : itype = M32RBF_INSN_ADD3; goto extract_sfmt_add3;
      case 140 : itype = M32RBF_INSN_AND3; goto extract_sfmt_and3;
      case 141 : itype = M32RBF_INSN_XOR3; goto extract_sfmt_and3;
      case 142 : itype = M32RBF_INSN_OR3; goto extract_sfmt_or3;
      case 144 : itype = M32RBF_INSN_DIV; goto extract_sfmt_div;
      case 145 : itype = M32RBF_INSN_DIVU; goto extract_sfmt_div;
      case 146 : itype = M32RBF_INSN_REM; goto extract_sfmt_div;
      case 147 : itype = M32RBF_INSN_REMU; goto extract_sfmt_div;
      case 152 : itype = M32RBF_INSN_SRL3; goto extract_sfmt_sll3;
      case 154 : itype = M32RBF_INSN_SRA3; goto extract_sfmt_sll3;
      case 156 : itype = M32RBF_INSN_SLL3; goto extract_sfmt_sll3;
      case 159 : itype = M32RBF_INSN_LDI16; goto extract_sfmt_ldi16;
      case 160 : itype = M32RBF_INSN_STB_D; goto extract_sfmt_stb_d;
      case 162 : itype = M32RBF_INSN_STH_D; goto extract_sfmt_sth_d;
      case 164 : itype = M32RBF_INSN_ST_D; goto extract_sfmt_st_d;
      case 168 : itype = M32RBF_INSN_LDB_D; goto extract_sfmt_ld_d;
      case 169 : itype = M32RBF_INSN_LDUB_D; goto extract_sfmt_ld_d;
      case 170 : itype = M32RBF_INSN_LDH_D; goto extract_sfmt_ld_d;
      case 171 : itype = M32RBF_INSN_LDUH_D; goto extract_sfmt_ld_d;
      case 172 : itype = M32RBF_INSN_LD_D; goto extract_sfmt_ld_d;
      case 176 : itype = M32RBF_INSN_BEQ; goto extract_sfmt_beq;
      case 177 : itype = M32RBF_INSN_BNE; goto extract_sfmt_beq;
      case 184 : itype = M32RBF_INSN_BEQZ; goto extract_sfmt_beqz;
      case 185 : itype = M32RBF_INSN_BNEZ; goto extract_sfmt_beqz;
      case 186 : itype = M32RBF_INSN_BLTZ; goto extract_sfmt_beqz;
      case 187 : itype = M32RBF_INSN_BGEZ; goto extract_sfmt_beqz;
      case 188 : itype = M32RBF_INSN_BLEZ; goto extract_sfmt_beqz;
      case 189 : itype = M32RBF_INSN_BGTZ; goto extract_sfmt_beqz;
      case 220 : itype = M32RBF_INSN_SETH; goto extract_sfmt_seth;
d459 1
a459 1
      case 239 : itype = M32RBF_INSN_LD24; goto extract_sfmt_ld24;
d480 5
a484 5
          case 12 : itype = M32RBF_INSN_BC24; goto extract_sfmt_bc24;
          case 13 : itype = M32RBF_INSN_BNC24; goto extract_sfmt_bc24;
          case 14 : itype = M32RBF_INSN_BL24; goto extract_sfmt_bl24;
          case 15 : itype = M32RBF_INSN_BRA24; goto extract_sfmt_bra24;
          default : itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
d487 1
a487 1
      default : itype = M32RBF_INSN_X_INVALID; goto extract_sfmt_empty;
d494 1
a494 1
 extract_sfmt_empty:
d499 1
d501 1
d504 1
a504 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_empty", (char *) 0));
d510 1
a510 1
 extract_sfmt_add:
d514 2
a515 3
#define FLD(f) abuf->fields.sfmt_add.f
    UINT f_r1;
    UINT f_r2;
d517 1
a517 2
    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);
d522 1
a522 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_add", "dr 0x%x", 'x', f_r1, "sr 0x%x", 'x', f_r2, (char *) 0));
d537 1
a537 1
 extract_sfmt_add3:
d541 2
a542 4
#define FLD(f) abuf->fields.sfmt_add3.f
    UINT f_r1;
    UINT f_r2;
    INT f_simm16;
d544 1
a544 3
    f_r1 = EXTRACT_MSB0_UINT (insn, 32, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 32, 12, 4);
    f_simm16 = EXTRACT_MSB0_INT (insn, 32, 16, 16);
d550 1
a550 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_add3", "f_simm16 0x%x", 'x', f_simm16, "sr 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));
d564 1
a564 1
 extract_sfmt_and3:
d568 2
a569 4
#define FLD(f) abuf->fields.sfmt_and3.f
    UINT f_r1;
    UINT f_r2;
    UINT f_uimm16;
d571 1
a571 3
    f_r1 = EXTRACT_MSB0_UINT (insn, 32, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 32, 12, 4);
    f_uimm16 = EXTRACT_MSB0_UINT (insn, 32, 16, 16);
d577 1
a577 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_and3", "f_uimm16 0x%x", 'x', f_uimm16, "sr 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));
d591 1
a591 1
 extract_sfmt_or3:
d595 2
a596 4
#define FLD(f) abuf->fields.sfmt_and3.f
    UINT f_r1;
    UINT f_r2;
    UINT f_uimm16;
d598 1
a598 3
    f_r1 = EXTRACT_MSB0_UINT (insn, 32, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 32, 12, 4);
    f_uimm16 = EXTRACT_MSB0_UINT (insn, 32, 16, 16);
d604 1
a604 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_or3", "f_uimm16 0x%x", 'x', f_uimm16, "sr 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));
d618 1
a618 1
 extract_sfmt_addi:
d622 2
a623 3
#define FLD(f) abuf->fields.sfmt_addi.f
    UINT f_r1;
    INT f_simm8;
d625 1
a625 2
    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_simm8 = EXTRACT_MSB0_INT (insn, 16, 8, 8);
d630 1
a630 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_addi", "f_simm8 0x%x", 'x', f_simm8, "dr 0x%x", 'x', f_r1, (char *) 0));
d644 1
a644 1
 extract_sfmt_addv:
d648 2
a649 3
#define FLD(f) abuf->fields.sfmt_add.f
    UINT f_r1;
    UINT f_r2;
d651 1
a651 2
    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);
d656 1
a656 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_addv", "dr 0x%x", 'x', f_r1, "sr 0x%x", 'x', f_r2, (char *) 0));
d671 1
a671 1
 extract_sfmt_addv3:
d675 2
a676 4
#define FLD(f) abuf->fields.sfmt_add3.f
    UINT f_r1;
    UINT f_r2;
    INT f_simm16;
d678 1
a678 3
    f_r1 = EXTRACT_MSB0_UINT (insn, 32, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 32, 12, 4);
    f_simm16 = EXTRACT_MSB0_INT (insn, 32, 16, 16);
d684 1
a684 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_addv3", "f_simm16 0x%x", 'x', f_simm16, "sr 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));
d698 1
a698 1
 extract_sfmt_addx:
d702 2
a703 3
#define FLD(f) abuf->fields.sfmt_add.f
    UINT f_r1;
    UINT f_r2;
d705 1
a705 2
    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);
d710 1
a710 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_addx", "dr 0x%x", 'x', f_r1, "sr 0x%x", 'x', f_r2, (char *) 0));
d725 1
a725 1
 extract_sfmt_bc8:
d729 2
a730 2
#define FLD(f) abuf->fields.sfmt_bl8.f
    SI f_disp8;
d732 1
a732 1
    f_disp8 = ((((EXTRACT_MSB0_INT (insn, 16, 8, 8)) << (2))) + (((pc) & (-4))));
d736 2
a737 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_bc8", "disp8 0x%x", 'x', f_disp8, (char *) 0));
d749 1
a749 1
 extract_sfmt_bc24:
d753 2
a754 2
#define FLD(f) abuf->fields.sfmt_bl24.f
    SI f_disp24;
d756 1
a756 1
    f_disp24 = ((((EXTRACT_MSB0_INT (insn, 32, 8, 24)) << (2))) + (pc));
d760 2
a761 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_bc24", "disp24 0x%x", 'x', f_disp24, (char *) 0));
d773 1
a773 1
 extract_sfmt_beq:
d777 2
a778 4
#define FLD(f) abuf->fields.sfmt_beq.f
    UINT f_r1;
    UINT f_r2;
    SI f_disp16;
d780 1
a780 3
    f_r1 = EXTRACT_MSB0_UINT (insn, 32, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 32, 12, 4);
    f_disp16 = ((((EXTRACT_MSB0_INT (insn, 32, 16, 16)) << (2))) + (pc));
d786 2
a787 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_beq", "disp16 0x%x", 'x', f_disp16, "src1 0x%x", 'x', f_r1, "src2 0x%x", 'x', f_r2, (char *) 0));
d801 1
a801 1
 extract_sfmt_beqz:
d805 2
a806 3
#define FLD(f) abuf->fields.sfmt_beq.f
    UINT f_r2;
    SI f_disp16;
d808 1
a808 2
    f_r2 = EXTRACT_MSB0_UINT (insn, 32, 12, 4);
    f_disp16 = ((((EXTRACT_MSB0_INT (insn, 32, 16, 16)) << (2))) + (pc));
d813 2
a814 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_beqz", "disp16 0x%x", 'x', f_disp16, "src2 0x%x", 'x', f_r2, (char *) 0));
d827 1
a827 1
 extract_sfmt_bl8:
d831 2
a832 2
#define FLD(f) abuf->fields.sfmt_bl8.f
    SI f_disp8;
d834 1
a834 1
    f_disp8 = ((((EXTRACT_MSB0_INT (insn, 16, 8, 8)) << (2))) + (((pc) & (-4))));
d838 2
a839 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_bl8", "disp8 0x%x", 'x', f_disp8, (char *) 0));
d852 1
a852 1
 extract_sfmt_bl24:
d856 2
a857 2
#define FLD(f) abuf->fields.sfmt_bl24.f
    SI f_disp24;
d859 1
a859 1
    f_disp24 = ((((EXTRACT_MSB0_INT (insn, 32, 8, 24)) << (2))) + (pc));
d863 2
a864 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_bl24", "disp24 0x%x", 'x', f_disp24, (char *) 0));
d877 1
a877 1
 extract_sfmt_bra8:
d881 2
a882 2
#define FLD(f) abuf->fields.sfmt_bl8.f
    SI f_disp8;
d884 1
a884 1
    f_disp8 = ((((EXTRACT_MSB0_INT (insn, 16, 8, 8)) << (2))) + (((pc) & (-4))));
d888 2
a889 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_bra8", "disp8 0x%x", 'x', f_disp8, (char *) 0));
d901 1
a901 1
 extract_sfmt_bra24:
d905 2
a906 2
#define FLD(f) abuf->fields.sfmt_bl24.f
    SI f_disp24;
d908 1
a908 1
    f_disp24 = ((((EXTRACT_MSB0_INT (insn, 32, 8, 24)) << (2))) + (pc));
d912 2
a913 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_bra24", "disp24 0x%x", 'x', f_disp24, (char *) 0));
d925 1
a925 1
 extract_sfmt_cmp:
d929 2
a930 3
#define FLD(f) abuf->fields.sfmt_st_plus.f
    UINT f_r1;
    UINT f_r2;
d932 1
a932 2
    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);
d937 1
a937 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_cmp", "src1 0x%x", 'x', f_r1, "src2 0x%x", 'x', f_r2, (char *) 0));
d951 1
a951 1
 extract_sfmt_cmpi:
d955 2
a956 3
#define FLD(f) abuf->fields.sfmt_st_d.f
    UINT f_r2;
    INT f_simm16;
d958 1
a958 2
    f_r2 = EXTRACT_MSB0_UINT (insn, 32, 12, 4);
    f_simm16 = EXTRACT_MSB0_INT (insn, 32, 16, 16);
d963 1
a963 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_cmpi", "f_simm16 0x%x", 'x', f_simm16, "src2 0x%x", 'x', f_r2, (char *) 0));
d976 1
a976 1
 extract_sfmt_div:
d980 2
a981 3
#define FLD(f) abuf->fields.sfmt_add.f
    UINT f_r1;
    UINT f_r2;
d983 1
a983 2
    f_r1 = EXTRACT_MSB0_UINT (insn, 32, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 32, 12, 4);
d988 1
a988 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_div", "dr 0x%x", 'x', f_r1, "sr 0x%x", 'x', f_r2, (char *) 0));
d1003 1
a1003 1
 extract_sfmt_jl:
d1007 2
a1008 2
#define FLD(f) abuf->fields.sfmt_jl.f
    UINT f_r2;
d1010 1
a1010 1
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);
d1014 2
a1015 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_jl", "sr 0x%x", 'x', f_r2, (char *) 0));
d1029 52
a1080 1
 extract_sfmt_jmp:
d1084 2
a1085 2
#define FLD(f) abuf->fields.sfmt_mvtc.f
    UINT f_r2;
d1087 1
a1087 1
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);
d1090 1
d1092 2
a1093 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_jmp", "sr 0x%x", 'x', f_r2, (char *) 0));
d1100 1
d1107 1
a1107 1
 extract_sfmt_ld:
d1111 2
a1112 3
#define FLD(f) abuf->fields.sfmt_ld_plus.f
    UINT f_r1;
    UINT f_r2;
d1114 1
a1114 2
    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);
d1119 1
a1119 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_ld", "sr 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));
d1133 1
a1133 1
 extract_sfmt_ld_d:
d1137 2
a1138 4
#define FLD(f) abuf->fields.sfmt_add3.f
    UINT f_r1;
    UINT f_r2;
    INT f_simm16;
d1140 1
a1140 3
    f_r1 = EXTRACT_MSB0_UINT (insn, 32, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 32, 12, 4);
    f_simm16 = EXTRACT_MSB0_INT (insn, 32, 16, 16);
d1146 1
a1146 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_ld_d", "f_simm16 0x%x", 'x', f_simm16, "sr 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));
d1160 1
a1160 1
 extract_sfmt_ld_plus:
d1164 2
a1165 3
#define FLD(f) abuf->fields.sfmt_ld_plus.f
    UINT f_r1;
    UINT f_r2;
d1167 1
a1167 2
    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);
d1172 54
a1225 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_ld_plus", "sr 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));
d1240 1
a1240 1
 extract_sfmt_ld24:
d1244 2
a1245 3
#define FLD(f) abuf->fields.sfmt_ld24.f
    UINT f_r1;
    UINT f_uimm24;
d1247 1
a1247 2
    f_r1 = EXTRACT_MSB0_UINT (insn, 32, 4, 4);
    f_uimm24 = EXTRACT_MSB0_UINT (insn, 32, 8, 24);
d1252 1
a1252 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_ld24", "uimm24 0x%x", 'x', f_uimm24, "dr 0x%x", 'x', f_r1, (char *) 0));
d1265 1
a1265 1
 extract_sfmt_ldi8:
d1269 2
a1270 3
#define FLD(f) abuf->fields.sfmt_addi.f
    UINT f_r1;
    INT f_simm8;
d1272 1
a1272 2
    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_simm8 = EXTRACT_MSB0_INT (insn, 16, 8, 8);
d1277 1
a1277 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_ldi8", "f_simm8 0x%x", 'x', f_simm8, "dr 0x%x", 'x', f_r1, (char *) 0));
d1290 1
a1290 1
 extract_sfmt_ldi16:
d1294 2
a1295 3
#define FLD(f) abuf->fields.sfmt_add3.f
    UINT f_r1;
    INT f_simm16;
d1297 1
a1297 2
    f_r1 = EXTRACT_MSB0_UINT (insn, 32, 4, 4);
    f_simm16 = EXTRACT_MSB0_INT (insn, 32, 16, 16);
d1302 1
a1302 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_ldi16", "f_simm16 0x%x", 'x', f_simm16, "dr 0x%x", 'x', f_r1, (char *) 0));
d1315 1
a1315 1
 extract_sfmt_lock:
d1319 2
a1320 3
#define FLD(f) abuf->fields.sfmt_ld_plus.f
    UINT f_r1;
    UINT f_r2;
d1322 1
a1322 2
    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);
d1327 1
a1327 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_lock", "sr 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));
d1341 1
a1341 1
 extract_sfmt_machi:
d1345 2
a1346 3
#define FLD(f) abuf->fields.sfmt_st_plus.f
    UINT f_r1;
    UINT f_r2;
d1348 1
a1348 2
    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);
d1353 1
a1353 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_machi", "src1 0x%x", 'x', f_r1, "src2 0x%x", 'x', f_r2, (char *) 0));
d1367 1
a1367 1
 extract_sfmt_mulhi:
d1371 2
a1372 3
#define FLD(f) abuf->fields.sfmt_st_plus.f
    UINT f_r1;
    UINT f_r2;
d1374 1
a1374 2
    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);
d1379 1
a1379 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_mulhi", "src1 0x%x", 'x', f_r1, "src2 0x%x", 'x', f_r2, (char *) 0));
d1393 1
a1393 1
 extract_sfmt_mv:
d1397 2
a1398 3
#define FLD(f) abuf->fields.sfmt_ld_plus.f
    UINT f_r1;
    UINT f_r2;
d1400 1
a1400 2
    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);
d1405 1
a1405 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_mv", "sr 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));
d1419 1
a1419 1
 extract_sfmt_mvfachi:
d1423 2
a1424 2
#define FLD(f) abuf->fields.sfmt_seth.f
    UINT f_r1;
d1426 1
a1426 1
    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
d1430 1
a1430 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_mvfachi", "dr 0x%x", 'x', f_r1, (char *) 0));
d1443 1
a1443 1
 extract_sfmt_mvfc:
d1447 2
a1448 3
#define FLD(f) abuf->fields.sfmt_mvfc.f
    UINT f_r1;
    UINT f_r2;
d1450 1
a1450 2
    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);
d1455 1
a1455 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_mvfc", "f_r2 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));
d1468 1
a1468 1
 extract_sfmt_mvtachi:
d1472 2
a1473 2
#define FLD(f) abuf->fields.sfmt_st_plus.f
    UINT f_r1;
d1475 1
a1475 1
    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
d1479 1
a1479 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_mvtachi", "src1 0x%x", 'x', f_r1, (char *) 0));
d1492 1
a1492 1
 extract_sfmt_mvtc:
d1496 2
a1497 3
#define FLD(f) abuf->fields.sfmt_mvtc.f
    UINT f_r1;
    UINT f_r2;
d1499 1
a1499 2
    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);
d1504 1
a1504 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_mvtc", "f_r1 0x%x", 'x', f_r1, "sr 0x%x", 'x', f_r2, (char *) 0));
d1517 1
a1517 1
 extract_sfmt_nop:
d1521 2
a1522 1
#define FLD(f) abuf->fields.fmt_empty.f
d1524 1
d1527 1
a1527 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_nop", (char *) 0));
d1533 1
a1533 1
 extract_sfmt_rac:
d1537 2
a1538 1
#define FLD(f) abuf->fields.fmt_empty.f
d1540 1
d1543 1
a1543 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_rac", (char *) 0));
d1549 1
a1549 1
 extract_sfmt_rte:
d1553 2
a1554 1
#define FLD(f) abuf->fields.fmt_empty.f
d1556 1
d1559 2
a1560 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_rte", (char *) 0));
d1572 1
a1572 1
 extract_sfmt_seth:
d1576 2
a1577 3
#define FLD(f) abuf->fields.sfmt_seth.f
    UINT f_r1;
    UINT f_hi16;
d1579 1
a1579 2
    f_r1 = EXTRACT_MSB0_UINT (insn, 32, 4, 4);
    f_hi16 = EXTRACT_MSB0_UINT (insn, 32, 16, 16);
d1584 1
a1584 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_seth", "f_hi16 0x%x", 'x', f_hi16, "dr 0x%x", 'x', f_r1, (char *) 0));
d1597 1
a1597 1
 extract_sfmt_sll3:
d1601 2
a1602 4
#define FLD(f) abuf->fields.sfmt_add3.f
    UINT f_r1;
    UINT f_r2;
    INT f_simm16;
d1604 1
a1604 3
    f_r1 = EXTRACT_MSB0_UINT (insn, 32, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 32, 12, 4);
    f_simm16 = EXTRACT_MSB0_INT (insn, 32, 16, 16);
d1610 1
a1610 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_sll3", "f_simm16 0x%x", 'x', f_simm16, "sr 0x%x", 'x', f_r2, "dr 0x%x", 'x', f_r1, (char *) 0));
d1624 1
a1624 1
 extract_sfmt_slli:
d1628 2
a1629 3
#define FLD(f) abuf->fields.sfmt_slli.f
    UINT f_r1;
    UINT f_uimm5;
d1631 1
a1631 2
    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_uimm5 = EXTRACT_MSB0_UINT (insn, 16, 11, 5);
d1636 1
a1636 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_slli", "f_uimm5 0x%x", 'x', f_uimm5, "dr 0x%x", 'x', f_r1, (char *) 0));
d1650 1
a1650 1
 extract_sfmt_st:
d1654 2
a1655 3
#define FLD(f) abuf->fields.sfmt_st_plus.f
    UINT f_r1;
    UINT f_r2;
d1657 1
a1657 2
    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);
d1662 1
a1662 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_st", "src1 0x%x", 'x', f_r1, "src2 0x%x", 'x', f_r2, (char *) 0));
d1676 1
a1676 1
 extract_sfmt_st_d:
d1680 2
a1681 4
#define FLD(f) abuf->fields.sfmt_st_d.f
    UINT f_r1;
    UINT f_r2;
    INT f_simm16;
d1683 1
a1683 3
    f_r1 = EXTRACT_MSB0_UINT (insn, 32, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 32, 12, 4);
    f_simm16 = EXTRACT_MSB0_INT (insn, 32, 16, 16);
d1689 1
a1689 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_st_d", "f_simm16 0x%x", 'x', f_simm16, "src1 0x%x", 'x', f_r1, "src2 0x%x", 'x', f_r2, (char *) 0));
d1703 1
a1703 1
 extract_sfmt_stb:
d1707 2
a1708 3
#define FLD(f) abuf->fields.sfmt_st_plus.f
    UINT f_r1;
    UINT f_r2;
d1710 1
a1710 2
    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);
d1715 1
a1715 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_stb", "src1 0x%x", 'x', f_r1, "src2 0x%x", 'x', f_r2, (char *) 0));
d1729 1
a1729 1
 extract_sfmt_stb_d:
d1733 2
a1734 4
#define FLD(f) abuf->fields.sfmt_st_d.f
    UINT f_r1;
    UINT f_r2;
    INT f_simm16;
d1736 1
a1736 3
    f_r1 = EXTRACT_MSB0_UINT (insn, 32, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 32, 12, 4);
    f_simm16 = EXTRACT_MSB0_INT (insn, 32, 16, 16);
d1742 1
a1742 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_stb_d", "f_simm16 0x%x", 'x', f_simm16, "src1 0x%x", 'x', f_r1, "src2 0x%x", 'x', f_r2, (char *) 0));
d1756 1
a1756 1
 extract_sfmt_sth:
d1760 2
a1761 3
#define FLD(f) abuf->fields.sfmt_st_plus.f
    UINT f_r1;
    UINT f_r2;
d1763 1
a1763 2
    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);
d1768 1
a1768 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_sth", "src1 0x%x", 'x', f_r1, "src2 0x%x", 'x', f_r2, (char *) 0));
d1782 1
a1782 1
 extract_sfmt_sth_d:
d1786 2
a1787 4
#define FLD(f) abuf->fields.sfmt_st_d.f
    UINT f_r1;
    UINT f_r2;
    INT f_simm16;
d1789 1
a1789 3
    f_r1 = EXTRACT_MSB0_UINT (insn, 32, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 32, 12, 4);
    f_simm16 = EXTRACT_MSB0_INT (insn, 32, 16, 16);
d1795 1
a1795 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_sth_d", "f_simm16 0x%x", 'x', f_simm16, "src1 0x%x", 'x', f_r1, "src2 0x%x", 'x', f_r2, (char *) 0));
d1809 1
a1809 1
 extract_sfmt_st_plus:
d1813 2
a1814 3
#define FLD(f) abuf->fields.sfmt_st_plus.f
    UINT f_r1;
    UINT f_r2;
d1816 1
a1816 2
    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);
d1821 1
a1821 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_st_plus", "src1 0x%x", 'x', f_r1, "src2 0x%x", 'x', f_r2, (char *) 0));
d1836 1
a1836 1
 extract_sfmt_trap:
d1840 2
a1841 2
#define FLD(f) abuf->fields.sfmt_trap.f
    UINT f_uimm4;
d1843 1
a1843 1
    f_uimm4 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);
d1847 2
a1848 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_trap", "f_uimm4 0x%x", 'x', f_uimm4, (char *) 0));
d1860 1
a1860 1
 extract_sfmt_unlock:
d1864 2
a1865 3
#define FLD(f) abuf->fields.sfmt_st_plus.f
    UINT f_r1;
    UINT f_r2;
d1867 1
a1867 2
    f_r1 = EXTRACT_MSB0_UINT (insn, 16, 4, 4);
    f_r2 = EXTRACT_MSB0_UINT (insn, 16, 12, 4);
d1872 1
a1872 1
  TRACE_EXTRACT (current_cpu, abuf, (current_cpu, pc, "sfmt_unlock", "src1 0x%x", 'x', f_r1, "src2 0x%x", 'x', f_r2, (char *) 0));
@


